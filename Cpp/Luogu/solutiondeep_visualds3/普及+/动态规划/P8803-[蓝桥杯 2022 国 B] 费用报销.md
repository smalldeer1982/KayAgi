# 题目信息

# [蓝桥杯 2022 国 B] 费用报销

## 题目描述

小明在出差结束后返回了公司所在的城市，在填写差旅报销申请时，粗心的小明发现自己弄丢了出差过程中的票据。

为了弥补小明的损失，公司同意小明用别的票据进行报销，但是公司财务要求小明提交的票据中任意两张的日期差不小于 $K$ 天，且总金额不得超过实际差旅费用 $M$。

比如财务要求 $K=7$ 时，若小明提交了一张 1 月 8 日的票据，小明就不能提交 1 月 2 日至 1 月 14 日之间的其他票据，1 月 1 日及之前和 1 月 15 日及之后的票据则可以提交。

公司的同事们一起给小明凑了 $N$ 张票据，小明现在想要请你帮他整理一下，从中选取出符合财务要求的票据, 并使总金额尽可能接近 $M$ 。

需要注意，由于这些票据都是同一年的，因此 12 月底的票据不会影响到 1 月初票据的提交。这一年不是闰年。

## 说明/提示

**【样例说明】**

选择 1 月 3 日和 1 月 6 日的票据

**【评测用例规模与约定】**

对于 $100 \%$ 的评测用例, $1 \leq N \leq 1000,1 \leq M \leq 5000,1 \leq K \leq 50,1 \leq m_{i} \leq$ $12,1 \leq d_{i} \leq 31,1 \leq v_{i} \leq 400$

日期保证合法。 


蓝桥杯 2022 国赛 B 组 F 题。

## 样例 #1

### 输入

```
4 16 3
1 1 1
1 3 2
1 4 4
1 6 8```

### 输出

```
10```

# AI分析结果

# 💡 Kay的C++算法解析：费用报销 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）+ 01背包模型  

🗣️ **初步分析**：  
解决“费用报销”问题，就像整理出差的背包——你有一堆票据（物品），每个票据有价值（金额），但选的时候要遵守“任意两张日期差≥K天”的规则（类似“不能装两本厚度差太小的书，否则放不下”），同时总金额不能超过M（背包容量），目标是让总金额尽可能大。  

**核心思路**：  
1. **日期处理**：将“月/日”转换为“全年第几天”（比如1月3日是第3天，1月6日是第6天），方便计算日期差。  
2. **排序**：按日期从小到大排序票据，这样后面的票据只能选前面符合条件的票据。  
3. **预处理前驱**：对每个票据i，找到**最近的**、日期差≥K的票据j（记为`last[i]`），这样选i时，只能从j及之前的状态转移。  
4. **动态规划**：用`dp[i][j]`表示前i个票据中选总金额为j的最大价值（其实就是j本身，因为价值=金额），转移方程为：  
   - 不选i：`dp[i][j] = dp[i-1][j]`  
   - 选i：`dp[i][j] = max(dp[i][j], dp[last[i]][j-v[i]] + v[i])`（v[i]是票据i的金额）  

**核心难点**：  
- 日期转换的正确性（比如2月有28天，12月有31天）；  
- 如何快速找到每个票据的合法前驱`last[i]`；  
- DP状态转移时的边界条件（比如`j≥v[i]`，`last[i]`是否存在）。  

**可视化设计思路**：  
用8位像素风格展示：  
- **票据排序**：像素块代表票据，按日期从左到右排列，颜色渐变表示日期递增；  
- **前驱查找**：当前票据i用红色标记，向前遍历找到第一个符合条件的j（日期差≥K），用绿色标记j；  
- **DP表更新**：用二维网格表示`dp[i][j]`，每个格子的亮度表示是否可达（亮=可达），选i时，从`last[i]`的列向当前列转移，用动画展示“数值流动”；  
- **音效**：选票据时播放“叮”的像素音效，找到解时播放胜利音效（类似FC游戏的“通关声”）。  


## 2. 精选优质题解参考

### 题解一：动态规划（作者：Nwayy，赞：23）  
* **点评**：  
  这份题解是标准的01背包变种，思路清晰到像“说明书”！首先将日期转换为天数（用前缀和数组`s`），然后排序票据，再预处理`last`数组（每个票据的最近合法前驱），最后用DP转移。代码中的`last`数组处理非常严谨（从i-1向前找，找到就break），DP转移方程直接对应“选或不选”的逻辑。尤其是`dp[i][j] = max(dp[i-1][j], dp[last[i]][j-v[i]] + v[i])`，完美体现了背包问题的核心思想。代码风格规范（变量名`d[i].t`表示日期，`last[i]`表示前驱），边界处理（比如`j≥v[i]`）很到位，适合初学者直接参考。  

### 题解二：bitset优化（作者：xxseven，赞：2）  
* **点评**：  
  这道题的“进阶玩法”！用bitset优化DP状态，将时间复杂度从`O(nm)`降到`O(nm/w)`（w是机器字长，约64）。思路是用`bitset`表示可达状态（比如`b[i]`的第j位为1，表示选第i个票据时能达到金额j），通过前缀或（`now`变量）维护所有合法前驱的状态，然后用`b[i] = now | (now << v[i])`快速转移。这种优化方法在背包问题中很常用，适合想提升代码效率的学习者。代码中的双指针（`pos`和`j`）处理前缀或的部分很巧妙，值得仔细琢磨。  

### 题解三：状态设计创新（作者：Wing_，赞：1）  
* **点评**：  
  这道题的“逆向思维”！通常DP状态存的是“最大价值”，但这份题解存的是“最小最晚日期”（`f[i][j]`表示前i个票据选金额j时的最小最晚日期）。这样设计的好处是：当金额相同时，最晚日期越小，后面的票据越容易选（因为日期差更容易满足≥K）。转移方程为：`f[i][j] = min(f[i-1][j], (j≥v[i] && d[i]-f[i-1][j-v[i]]≥K) ? d[i] : INF)`。这种状态设计很有启发，适合想拓展思维的学习者。需要注意的是初始化（`f[0][0] = -INF`），否则会出现“选第一张票据时日期差不够”的错误。  


## 3. 核心难点辨析与解题策略

### 1. 日期转换的正确性  
* **分析**：  
  题目中的日期是“月/日”，需要转换为“全年第几天”。比如3月1日是1月（31天）+2月（28天）+1天=60天。如果月份天数算错（比如2月算30天），会导致日期差计算错误，从而`last`数组错误，最终DP结果错误。  
* **解决方案**：  
  预处理一个月份天数的前缀和数组，比如`days[13] = {0, 31, 59, 90, ..., 365}`（`days[m]`表示1月到m月的总天数），那么月m、日d的日期就是`days[m-1] + d`。例如，m=3（3月），d=1，就是`days[2] +1=59+1=60`。  

### 2. 合法前驱`last[i]`的查找  
* **分析**：  
  每个票据i只能选前面日期差≥K的票据，所以需要找到最近的j（j<i），使得`d[i]-d[j]≥K`。如果找不到这样的j，`last[i]`=0（表示前面没有选任何票据）。  
* **解决方案**：  
  排序后，从i-1向前遍历，找到第一个满足`d[i]-d[j]≥K`的j，记为`last[i]`。因为票据按日期排序，所以一旦找到就可以break（后面的j更小，日期差更大，但不是最近的）。例如，样例中的票据1（1月1日）、票据2（1月3日）、票据3（1月4日）、票据4（1月6日），K=3：  
  - `last[2]`=0（1月3日-1月1日=2<3）；  
  - `last[3]`=0（1月4日-1月3日=1<3，1月4日-1月1日=3≥3？不，样例中的K=3，1月4日-1月1日=3天，符合条件，所以`last[3]`=1？等一下，样例中的输入是：  
    4 16 3  
    1 1 1（票据1，日期1）  
    1 3 2（票据2，日期3）  
    1 4 4（票据3，日期4）  
    1 6 8（票据4，日期6）  
  排序后顺序不变。`last[2]`：票据2的日期是3，向前找j=1，3-1=2<3，所以`last[2]`=0；`last[3]`：票据3的日期是4，向前找j=2（4-3=1<3），j=1（4-1=3≥3），所以`last[3]`=1；`last[4]`：票据4的日期是6，向前找j=3（6-4=2<3），j=2（6-3=3≥3），所以`last[4]`=2。  

### 3. DP状态转移的正确性  
* **分析**：  
  DP转移时，选i的条件是`j≥v[i]`（金额足够）且`last[i]`存在（或`last[i]`=0，此时`dp[0][j-v[i]]`是否为0？比如`j-v[i]=0`时，`dp[0][0]`=0，所以选i的话，`dp[i][v[i]]`=v[i]）。  
* **解决方案**：  
  初始化`dp[0][0]`=0（选0个票据，金额0），其他`dp[0][j]`=0（或负无穷，根据状态设计）。转移时，先复制`dp[i-1][j]`到`dp[i][j]`（不选i），然后如果`j≥v[i]`，则`dp[i][j] = max(dp[i][j], dp[last[i]][j-v[i]] + v[i])`（选i）。  

### ✨ 解题技巧总结  
- **问题转换**：将日期差约束转换为“前驱”问题，把复杂的条件转化为DP转移的索引。  
- **排序的重要性**：按日期排序后，前驱查找变得容易，且DP转移的顺序正确。  
- **状态设计的灵活性**：除了存“最大价值”，还可以存“最小最晚日期”等辅助信息，帮助优化转移。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（基于标准DP）  
* **说明**：  
  本代码综合了Nwayy、KawaragiMomoka等题解的思路，是最经典的01背包变种实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <algorithm>
  #include <cstring>
  using namespace std;

  const int MAXN = 1005;
  const int MAXM = 5005;
  const int days[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365}; // 1月到12月的前缀和

  struct Bill {
      int date; // 全年第几天
      int value; // 金额
  } bills[MAXN];

  int last[MAXN]; // last[i]表示第i个票据的最近合法前驱
  int dp[MAXN][MAXM]; // dp[i][j]表示前i个票据选金额j的最大价值

  bool cmp(const Bill& a, const Bill& b) {
      return a.date < b.date;
  }

  int main() {
      int n, m, k;
      cin >> n >> m >> k;
      for (int i = 1; i <= n; ++i) {
          int mon, d, v;
          cin >> mon >> d >> v;
          bills[i].date = days[mon - 1] + d; // 转换为全年第几天
          bills[i].value = v;
      }
      sort(bills + 1, bills + n + 1, cmp); // 按日期排序

      // 预处理last数组
      for (int i = 1; i <= n; ++i) {
          last[i] = 0;
          for (int j = i - 1; j >= 1; --j) {
              if (bills[i].date - bills[j].date >= k) {
                  last[i] = j;
                  break;
              }
          }
      }

      // 初始化DP数组
      memset(dp, 0, sizeof(dp));

      // DP转移
      for (int i = 1; i <= n; ++i) {
          // 不选第i个票据，复制dp[i-1]
          for (int j = 0; j <= m; ++j) {
              dp[i][j] = dp[i-1][j];
          }
          // 选第i个票据，从last[i]转移
          int v = bills[i].value;
          for (int j = m; j >= v; --j) {
              dp[i][j] = max(dp[i][j], dp[last[i]][j - v] + v);
          }
      }

      // 找最大的j≤m，使得dp[n][j] = j（因为价值=金额）
      int ans = 0;
      for (int j = m; j >= 0; --j) {
          if (dp[n][j] == j) { // 其实dp[n][j]就是j，因为选的金额总和是j
              ans = j;
              break;
          }
      }
      cout << ans << endl;

      return 0;
  }
  ```
* **代码解读概要**：  
  1. **日期转换**：用`days`数组将“月/日”转换为“全年第几天”；  
  2. **排序**：按日期从小到大排序票据；  
  3. **预处理last数组**：对每个票据i，找到最近的合法前驱j；  
  4. **DP初始化**：`dp[0][0]`=0，其他为0；  
  5. **DP转移**：先复制`dp[i-1]`（不选i），再处理选i的情况（从`last[i]`转移）；  
  6. **结果输出**：找最大的j≤m，使得`dp[n][j]`=j（即选了金额j）。  


### 题解二：bitset优化（作者：xxseven）  
* **亮点**：用bitset优化状态转移，提升效率。  
* **核心代码片段**：  
  ```cpp
  #include <bitset>
  using namespace std;

  const int N = 1005;
  const int M = 5005;
  bitset<M> b[N], now; // b[i]表示选第i个票据时的可达状态，now表示前缀或

  int main() {
      // 日期处理和排序省略...
      now.set(0); // 初始状态：选0个票据，金额0
      for (int j = 1; j <= n+1; ++j) {
          int i = a[j]; // a[j]是排序后的票据索引
          // 双指针维护前缀或：所有合法前驱的状态
          while (t[a[pos]] + k <= t[i]) {
              now |= b[a[pos]];
              pos++;
          }
          // 转移：选i的话，状态是now | (now << v[i])
          b[i] = now | (now << v[i]);
      }
      // 找最大的j≤m，使得now.test(j)
      for (int i = m; i >= 0; --i) {
          if (now.test(i)) {
              cout << i << endl;
              return 0;
          }
      }
  }
  ```
* **代码解读**：  
  - `bitset<M> b[N]`：`b[i]`的第j位为1，表示选第i个票据时能达到金额j；  
  - `now`：前缀或变量，维护所有合法前驱的状态（即所有j≤pos的票据的状态或）；  
  - `now << v[i]`：将`now`左移v[i]位，表示选第i个票据（金额增加v[i]）；  
  - `b[i] = now | (now << v[i])`：选或不选第i个票据的状态合并（不选的话是`now`，选的话是`now << v[i]`）。  
* 💡 **学习笔记**：  
  bitset优化适合“可达性”问题（比如是否能达到某个状态），通过位运算快速合并状态，效率比普通数组高很多。  


### 题解三：状态设计创新（作者：Wing_）  
* **亮点**：存“最小最晚日期”，优化转移条件。  
* **核心代码片段**：  
  ```cpp
  const int INF = 0x3f3f3f3f;
  int f[MAXN][MAXM]; // f[i][j]表示前i个票据选金额j时的最小最晚日期

  int main() {
      // 日期处理和排序省略...
      memset(f, 0x3f, sizeof(f));
      f[0][0] = -INF; // 初始化：选0个票据，金额0，最晚日期为负无穷（方便选第一个票据）
      for (int i = 1; i <= n; ++i) {
          int v = pj[i].v;
          int d = pj[i].d;
          // 不选i，复制f[i-1]
          for (int j = 0; j <= m; ++j) {
              f[i][j] = f[i-1][j];
          }
          // 选i，需要j≥v且d - f[i-1][j-v]≥K
          for (int j = v; j <= m; ++j) {
              if (d - f[i-1][j - v] >= K) {
                  f[i][j] = min(f[i][j], d);
              }
          }
      }
      // 找最大的j≤m，使得f[n][j] < INF
      for (int j = m; j >= 0; --j) {
          if (f[n][j] < INF) {
              cout << j << endl;
              break;
          }
      }
  }
  ```
* **代码解读**：  
  - `f[i][j]`存的是“最小最晚日期”：当金额j相同时，最晚日期越小，后面的票据越容易选（因为日期差更容易满足≥K）；  
  - 初始化`f[0][0] = -INF`：选0个票据时，最晚日期为负无穷，这样选第一个票据时，`d - (-INF) ≥ K`一定成立；  
  - 转移时，选i的条件是`d - f[i-1][j-v] ≥ K`（当前票据的日期减去之前的最晚日期≥K），此时`f[i][j]`更新为`d`（当前票据的日期）。  
* 💡 **学习笔记**：  
  状态设计不仅可以存“目标值”（比如最大价值），还可以存“辅助值”（比如最小最晚日期），帮助优化转移条件。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题  
**像素探险家：票据收集之旅**（仿FC游戏《淘金者》风格）  

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是“票据列表”（像素块代表票据，颜色表示日期：蓝色=早，红色=晚）；  
   - 中间是“DP表”（二维网格，每个格子的亮度表示是否可达：亮=可达）；  
   - 右侧是“控制面板”（有“开始/暂停”“单步”“重置”按钮，速度滑块）；  
   - 背景是8位风格的办公室场景（比如桌子、电脑、文件柜）。  

2. **票据排序**：  
   - 初始时，票据随机排列（颜色混乱）；  
   - 动画展示“排序过程”：票据按日期从小到大移动，最终排成一行（蓝色到红色渐变）。  

3. **前驱查找**：  
   - 当前票据i用红色标记，向前遍历找到第一个符合条件的j（日期差≥K）；  
   - j用绿色标记，同时显示“日期差：x天≥K”的文字提示；  
   - 播放“叮”的音效（表示找到前驱）。  

4. **DP表更新**：  
   - 不选i时，`dp[i]`复制`dp[i-1]`（网格亮度不变）；  
   - 选i时，从`last[i]`的列向当前列转移：`dp[i][j] = max(dp[i][j], dp[last[i]][j-v[i]] + v[i])`；  
   - 用动画展示“数值流动”（从`last[i]`的列向当前列移动，亮度增加）；  
   - 播放“咻”的音效（表示转移完成）。  

5. **结果展示**：  
   - 找到最大的j≤m时，DP表中对应的格子闪烁，同时显示“胜利！总金额：j”的文字提示；  
   - 播放胜利音效（类似FC游戏的“通关声”）。  

### 交互设计  
- **单步执行**：点击“单步”按钮，动画执行一步（比如排序一个票据、查找一个前驱、更新一个DP状态）；  
- **自动播放**：点击“开始”按钮，动画自动执行，速度可以通过滑块调整（慢=1秒/步，快=0.1秒/步）；  
- **重置**：点击“重置”按钮，动画回到初始状态；  
- **AI演示**：点击“AI”按钮，动画自动执行最优路径（比如选哪些票据能得到最大金额）。  

### 设计思路  
- **像素风格**：仿FC游戏风格，让学习者感到亲切，降低学习压力；  
- **动画效果**：用动态展示代替静态文字，让“日期转换”“前驱查找”“DP转移”等抽象过程变得直观；  
- **音效**：用简单的像素音效强化关键操作（比如找到前驱、转移完成），帮助学习者记忆；  
- **交互性**：让学习者可以控制动画的速度和步骤，便于仔细观察每个过程。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
动态规划（01背包）是解决“选择物品满足约束条件，使目标值最大化”问题的常用方法。本题的思路可以迁移到以下场景：  
- **选课问题**：选课程，每门课程有学分和先修课要求，求最大学分；  
- **砝码称重问题**：选砝码，每类砝码有重量，求能称出的最大重量；  
- **旅行问题**：选旅行路线，每条路线有时间和费用，求在时间限制内的最小费用。  

### 练习推荐（洛谷）  
1. **洛谷 P1048** - 采药  
   🗣️ **推荐理由**：经典的01背包问题，直接考察“选或不选”的逻辑，适合巩固基础。  
2. **洛谷 P1164** - 小A点菜  
   🗣️ **推荐理由**：01背包的变种，求“恰好花完钱”的方案数，适合练习状态设计。  
3. **洛谷 P2347** - 砝码称重  
   🗣️ **推荐理由**：01背包的拓展，求“能称出的最大重量”，适合练习bitset优化。  
4. **洛谷 P3985** - 不开心的金明  
   🗣️ **推荐理由**：01背包的变种，求“在满足条件下的最大价值”，适合练习约束条件的处理。  


## 7. 学习心得与经验分享（若有）

### 参考经验（来自作者：Wing_）  
> “我在解决这个问题时，最初把`f[0][0]`初始化为0，结果WA了很多次。后来才意识到，选第一个票据时，`d[i] - f[0][0] = d[i] - 0`，如果`d[i] < K`，就会无法选第一个票据。正确的初始化应该是`f[0][0] = -INF`，这样`d[i] - (-INF) ≥ K`一定成立，不会影响第一个票据的选择。”  

**点评**：  
初始化是DP问题中最容易忽略的细节，也是最容易出错的地方。Wing_的经验提醒我们：在设计状态时，一定要考虑“边界条件”（比如选第一个物品的情况），并正确初始化状态。比如本题中的`f[0][0] = -INF`，就是为了处理“选第一个票据”的边界情况。  


## 结语  
本次关于“费用报销”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解动态规划（01背包）的思路和技巧。记住，编程能力的提升在于**持续练习**（多做类似题目）、**仔细思考**（为什么这样设计状态）、**总结经验**（避免重复犯错）。下次我们再一起探索新的编程挑战！💪

---
处理用时：210.42秒
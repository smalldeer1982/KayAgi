# 题目信息

# [COCI 2010/2011 #3] DIFERENCIJA

## 题目描述

给出一个长度为 $n$ 的序列 $a_i$，求出下列式子的值：

$$\sum_{i=1}^{n} \sum_{j=i}^{n} (\max_{i\le k\le j} a_k-\min_{i\le k\le j} a_k)$$



即定义一个子序列的权值为序列内最大值与最小值的差。求出所有连续子序列的权值和。



## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n\le 3\times 10^5$，$1\le a_i\le 10^8$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #3](https://hsin.hr/coci/archive/2010_2011/contest3_tasks.pdf) *T5 DIFERENCIJA***。

## 样例 #1

### 输入

```
3
1
2
3```

### 输出

```
4```

## 样例 #2

### 输入

```
4
7
5
7
5```

### 输出

```
12```

## 样例 #3

### 输入

```
4
3
1
7
2```

### 输出

```
31```

# AI分析结果


### 💡 Kay的C++算法解析：DIFERENCIJA 深入学习指南 💡

**引言**  
今天我们分析COCI竞赛题「DIFERENCIJA」——计算所有连续子序列的极差（最大值与最小值之差）之和。本题考察**单调栈应用与贡献法思想**，需高效处理大规模数据（n ≤ 3×10⁵）。下面我将拆解核心思路，结合像素动画演示算法过程，助你掌握解题精髓。

---

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`单调栈`、`贡献法`  

🗣️ **初步分析**：  
> 本题需计算所有连续子序列的极差和，直接枚举子序列会超时（O(n²)）。核心思路是将问题拆解：  
> **极差和 = 所有子序列的最大值之和 - 最小值之和**  
> - **贡献法**：计算每个元素作为最大值/最小值出现在多少个子序列中，乘以元素值即为贡献。  
> - **单调栈**：高效找到每个元素左侧/右侧第一个比它大（或小）的位置，确定其贡献区间。  
>  
> **可视化设计**：  
> - 用像素网格表示序列，当前元素高亮为黄色，栈内元素用不同颜色区分（如蓝色表待弹出）。  
> - 动画展示栈的压入/弹出过程，元素贡献区间用绿色框标记，伴随8-bit音效（弹出"噗"声，计算成功"叮"声）。  
> - 自动演示模式可调速，实时显示贡献值累加过程，类似闯关游戏进度条。

---

### 2. 精选优质题解参考
#### 题解一：Alex_Wei（动态规划+单调栈）
* **亮点**：  
  - 定义 `f[i]` 和 `g[i]` 分别表示以 `i` 结尾的子序列的最大值/最小值之和，状态转移清晰。  
  - 用两个单调栈维护前一个更大/更小元素的位置，转移方程：  
    `f[i] = f[p] + a[i]*(i-p)`（`p` 为左侧第一个比 `a[i]` 大的位置）  
  - 代码简洁高效（O(n)），边界处理严谨，直接用于竞赛。

#### 题解二：Durancer（问题转化+单栈复用）
* **亮点**：  
  - 将最小值转化为负最大值：**最小值之和 = 所有子序列的（-aᵢ）的最大值之和**。  
  - 复用同一个单调栈函数处理正负序列，减少代码量。  
  - 实践性强，避免重复写相似逻辑。

#### 题解三：Cry_For_theMoon（重复元素严谨处理）
* **亮点**：  
  - 明确处理重复元素：左侧用 `≥` 比较，右侧用 `>` 比较（或反之），确保区间不重复计算。  
  - 四次单调栈求左右边界，逻辑严谨，适合理解贡献法的本质。

---

### 3. 核心难点辨析与解题策略
1. **难点1：如何确定元素的贡献区间？**  
   - **分析**：对元素 `a[i]`，需找到左右第一个比它大（最大值贡献）或小（最小值贡献）的位置 `L` 和 `R`。  
   - **解法**：单调栈在 O(n) 时间内完成：  
     - 最大值贡献：维护递减栈，弹出时更新栈顶元素的右边界。  
     - 最小值贡献：维护递增栈，同理。  

2. **难点2：重复元素导致区间重复计算？**  
   - **分析**：若序列有相同元素，需保证同一区间不被多个相同值重复贡献。  
   - **解法**：严格定义比较规则（如左侧用 `>`，右侧用 `≥`），确保唯一性。  

3. **难点3：状态转移方程的推导？**  
   - **分析**：动态规划中，`f[i]` 依赖前一个更大元素的位置 `p`。  
   - **解法**：`p` 左侧的子序列最大值不变，`p` 到 `i` 的子序列最大值是 `a[i]`，故 `f[i] = f[p] + a[i]*(i-p)`。  

#### ✨ 解题技巧总结
- **拆解问题**：将极差和拆为最大值和与最小值和之差，化繁为简。  
- **单调栈维护**：用空间换时间，将区间计算降至 O(n)。  
- **边界处理**：序列首尾插入哨兵值（如 `INF`），避免空栈判断。  

---

### 4. C++核心代码实现赏析
#### 本题通用核心实现（综合自优质题解）
```cpp
#include <iostream>
#include <stack>
using namespace std;
typedef long long ll;
const int N = 3e5 + 5;

ll n, ans, a[N];
stack<ll> stk_max, stk_min;

ll solve() {
    ll res = 0, now = 0;
    stack<ll> stk;
    for (int i = 1; i <= n; i++) {
        while (!stk.empty() && a[stk.top()] < a[i]) {
            now -= (stk.top() - (stk.size()>1 ? stk.top()-1 : 0)) * a[stk.top()];
            stk.pop();
        }
        ll p = stk.empty() ? 0 : stk.top();
        now += a[i] * (i - p);
        res += now;
        stk.push(i);
    }
    return res;
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i];
    ans = solve();
    for (int i = 1; i <= n; i++) a[i] = -a[i]; // 最小值转最大值
    ans += solve();
    cout << ans << endl;
    return 0;
}
```
**代码解读概要**：  
- `solve()` 函数计算子序列最大值之和：单调栈维护递减序列，动态更新贡献值 `now`。  
- 主函数调用两次 `solve()`：第一次计算原始序列最大值和，第二次将序列取负后计算最小值之和（负的最大值和）。  
- 时间复杂度 O(n)，空间复杂度 O(n)。

#### 题解一（Alex_Wei）核心片段
```cpp
ll f[N], g[N], ans;
stack<pair<ll, ll>> stk_max, stk_min;

for (int i = 1; i <= n; i++) {
    // 最大值栈（递减）
    while (!stk_max.empty() && a[i] >= stk_max.top().first) 
        stk_max.pop();
    ll p = stk_max.empty() ? 0 : stk_max.top().second;
    f[i] = f[p] + a[i] * (i - p);
    stk_max.push({a[i], i});

    // 最小值栈（递增）
    while (!stk_min.empty() && a[i] <= stk_min.top().first) 
        stk_min.pop();
    p = stk_min.empty() ? 0 : stk_min.top().second;
    g[i] = g[p] + a[i] * (i - p);
    stk_min.push({a[i], i});

    ans += f[i] - g[i];
}
```
**学习笔记**：  
> 动态规划中，`f[i]` 和 `g[i]` 分别继承自前一个更大/更小元素位置的贡献，并加上当前元素在新区间的贡献。单调栈高效维护了这种依赖关系。

---

### 5. 算法可视化：像素动画演示
**主题**：像素探险家与单调栈寻宝  
**核心演示**：单调栈求最大值之和的过程  

**动画步骤**：  
1. **初始化**：  
   - 8-bit像素网格显示序列（如 `[1,2,3]`），控制面板含步进/自动/调速滑块。  
   - 单调栈显示为右侧像素柱，背景播放复古芯片音乐。  

2. **元素入栈（动态演示）**：  
   - 当前元素高亮黄色，与栈顶比较：若更大则栈顶变红弹出（"噗"声），更新贡献值。  
   - 压入新元素（绿色），显示当前 `f[i]` 值。  

3. **贡献区间标记**：  
   - 被弹出元素的贡献区间用绿色框标记，显示计算公式 `a[i]*(i-p)`。  

4. **自动模式**：  
   - 类似"贪吃蛇AI"自动运行，实时显示贡献累加进度条。  
   - 完成时播放胜利音效，所有贡献区间闪烁庆祝。  

**设计思路**：通过游戏化交互，将抽象的单调栈操作具象为探险过程，加深理解。

---

### 6. 拓展练习与相似问题
**通用技巧迁移**：  
单调栈可用于解决区间极值、直方图最大矩形等问题，核心是**维护序列的单调性以快速定位边界**。  

**洛谷推荐**：  
1. [P1901 发射站](https://www.luogu.com.cn/problem/P1901)  
   → 练习单调栈基础应用。  
2. [P1823 音乐会的等待](https://www.luogu.com.cn/problem/P1823)  
   → 处理重复元素的单调栈变体。  
3. [P7167 Fountain](https://www.luogu.com.cn/problem/P7167)  
   → 单调栈与倍增结合，适合进阶挑战。  

---

### 7. 学习心得与经验分享
> **经验摘录（Alex_Wei）**：  
> “单调栈的实现要注意边界条件，哨兵值能简化代码。本题将空间复杂度优化到 O(n)，适合竞赛场景。”  
>  
> **Kay点评**：  
> 处理大规模数据时，避免递归（如分治）选择迭代，常数更小。动手前先拆解问题本质，如本题转化为贡献求和，事半功倍。

---

**结语**  
本题将单调栈与贡献法结合，是区间统计问题的经典范式。理解每一步的物理意义，辅以动画演示，你定能掌握其精髓。继续挑战相似问题，编程能力会更上一层楼！🚀

---
处理用时：154.74秒
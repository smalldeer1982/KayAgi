# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果

# 💡 Kay的C++算法解析：导弹拦截 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最长子序列问题（最长不上升子序列、最长上升子序列）+ 贪心+二分优化 + Dilworth定理

🗣️ **初步分析**：  
这道题的核心是解决两个经典子序列问题——  
1. **第一问**：求导弹序列的**最长不上升子序列**（即拦截系统能打下来的最多导弹数，因为每发炮弹高度不能超过前一发）；  
2. **第二问**：求覆盖整个序列的**最少不上升子序列个数**（即需要多少套系统），根据**Dilworth定理**，这等价于求序列的**最长上升子序列**。  

### 核心算法思路
- **最长不上升子序列**：用一个数组`f`维护「长度为`i`的不上升子序列的最后一项的最大值」（`f`是单调不增的）。遍历每个导弹高度时：  
  - 若当前高度≤`f`的末尾，直接加入`f`（延长子序列）；  
  - 否则，用二分法找到`f`中第一个小于当前高度的位置，替换该位置的值（优化后续子序列的可能性）。  
- **最长上升子序列**：类似上述思路，但`f`维护「长度为`i`的上升子序列的最后一项的最小值」（`f`单调递增），二分查找条件调整为寻找第一个≥当前高度的位置。  

### 可视化设计思路
我们将用**8位像素风格**（参考FC红白机）设计动画，核心展示：  
- 像素化的导弹序列（不同高度用不同颜色的方块表示）；  
- 动态构建最长不上升子序列的过程（用闪烁或变色标记选中的导弹）；  
- 二分查找的过程（用箭头高亮当前查找范围，命中位置用“叮”音效提示）；  
- 控制面板包含“单步执行”“自动播放”“重置”，自动播放时用复古BGM，完成时播放胜利音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，它们覆盖了核心知识点，且代码简洁高效。
</eval_intro>

**题解一：离散小波变换°（赞764）**  
* **点评**：这份题解是本题的“标杆级”解析！它从动态规划的基本思路（O(n²)）出发，逐步推导到贪心+二分的优化方法（O(n log n)），逻辑链完整。对`f`数组的定义（长度为`i`的不上升子序列的最后一项最大值）和二分查找的边界条件解释得非常透彻。代码部分用两个循环分别处理两问，变量命名清晰（如`H`存导弹高度，`F`存子序列状态），且注释明确。尤其是第二问通过贪心策略推导到Dilworth定理的部分，让“最少系统数=最长上升子序列”的结论更具说服力。

**题解二：STA_Morlin（赞217）**  
* **点评**：这道题解的亮点是**用STL函数简化代码**！它直接使用`upper_bound`（配合`greater<int>()`）求最长不上升子序列，`lower_bound`求最长上升子序列，代码量比传统二分少了一半。对`upper_bound`和`lower_bound`的适用场景解释得很清楚（比如`upper_bound`找第一个小于当前值的位置），非常适合学习STL的灵活运用。此外，题解还补充了Dilworth定理的归纳证明，帮助理解“最少链划分=最长反链”的本质。

**题解三：Kingna（赞198）**  
* **点评**：这份题解的特色是**贪心策略的详细证明**！它没有直接依赖Dilworth定理，而是从贪心的角度推导第二问：“每个导弹尽量接在能拦截它的最小系统后面”，并通过“最优解≤贪心解”和“贪心解≤最优解”的双向证明，验证了贪心的正确性。代码部分用二分优化贪心过程，逻辑直白，适合刚接触贪心的学习者。同时，题解还对比了O(n²)和O(n log n)的代码差异，帮助理解优化的必要性。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是突破三个核心难点，下面结合优质题解的经验，为你拆解思路：
</difficulty_intro>

### 1. 如何将问题转化为“最长子序列”？
- **分析**：第一问的“最多拦截导弹数”对应“最长不上升子序列”（每发炮弹高度不超过前一发）；第二问的“最少系统数”对应“最少不上升子序列个数”，根据Dilworth定理，这等价于“最长上升子序列”（反链的最大长度）。  
- 💡 **学习笔记**：问题转化是解题的第一步！要学会将实际问题映射到经典算法模型（如子序列、贪心）。

### 2. 如何用二分优化最长子序列？
- **分析**：传统的DP（O(n²)）无法处理1e5的数据，因此需要用贪心+二分优化。核心是维护一个**单调数组**（如`f`），利用其单调性通过二分查找快速找到需要更新的位置。例如，最长不上升子序列的`f`数组是单调不增的，所以可以用二分找第一个小于当前值的位置。  
- 💡 **学习笔记**：单调数组+二分是优化LIS问题的“黄金组合”，关键是理解`f`数组的含义（长度为`i`的子序列的最优末尾值）。

### 3. 如何理解Dilworth定理？
- **分析**：Dilworth定理是连接两问的关键！它指出“偏序集的最小链划分等于最长反链长度”。在本题中，“链”是不上升子序列（元素可比），“反链”是上升子序列（元素不可比），因此最少链划分（系统数）等于最长反链长度（最长上升子序列）。  
- 💡 **学习笔记**：Dilworth定理是解决“最少划分”问题的利器，记住“最少不上升子序列数=最长上升子序列数”的结论即可快速应用。

### ✨ 解题技巧总结
- **技巧1**：遇到“最长子序列”问题，先想贪心+二分优化（O(n log n)），而不是传统DP（O(n²)）。  
- **技巧2**：用STL的`upper_bound`/`lower_bound`可以简化二分代码（注意`greater<int>()`的使用场景）。  
- **技巧3**：处理边界条件时，比如`f`数组的初始化（如`f[0]`设为INF或-INF），避免数组越界。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合优质题解的通用核心代码，它覆盖了两问的O(n log n)解法，逻辑清晰，适合入门学习。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了离散小波变换°和STA_Morlin的思路，用贪心+二分实现两问，代码简洁高效。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 1e5 + 5;
int H[MAXN];
int n = 0;

// 求最长不上升子序列长度
int longest_non_increasing() {
    vector<int> f;
    for (int i = 0; i < n; ++i) {
        if (f.empty() || H[i] <= f.back()) {
            f.push_back(H[i]);
        } else {
            // 找第一个小于H[i]的位置（用upper_bound+greater）
            auto it = upper_bound(f.begin(), f.end(), H[i], greater<int>());
            *it = H[i];
        }
    }
    return f.size();
}

// 求最长上升子序列长度（即最少系统数）
int longest_increasing() {
    vector<int> f;
    for (int i = 0; i < n; ++i) {
        if (f.empty() || H[i] > f.back()) {
            f.push_back(H[i]);
        } else {
            // 找第一个大于等于H[i]的位置（用lower_bound）
            auto it = lower_bound(f.begin(), f.end(), H[i]);
            *it = H[i];
        }
    }
    return f.size();
}

int main() {
    while (cin >> H[n]) {
        n++;
    }
    cout << longest_non_increasing() << endl;
    cout << longest_increasing() << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. 读取输入：用`H`数组存导弹高度，`n`记录数量；  
  2. `longest_non_increasing`：维护`f`数组（单调不增），用`upper_bound`找第一个小于当前高度的位置，替换后保持`f`的单调性；  
  3. `longest_increasing`：维护`f`数组（单调递增），用`lower_bound`找第一个大于等于当前高度的位置，替换后保持`f`的单调性；  
  4. 输出两问结果。

---

<code_intro_selected>
接下来剖析优质题解的核心片段，看看它们的“巧思”在哪里：
</code_intro_selected>

### 题解一：离散小波变换°（核心片段）
* **亮点**：手动实现二分查找，清晰展示边界条件处理。
* **核心代码片段**：
```cpp
// 第一问的二分逻辑
int l = 0, r = t + 1;
while (r - l > 1) {
    int m = l + (r - l) / 2;
    if (F[m] >= H[i]) l = m;
    else r = m;
}
int x = l + 1;
if (x > t) t = x;
F[x] = H[i];
```
* **代码解读**：  
  - `l`和`r`是二分的左右边界（`r`初始为`t+1`，避免越界）；  
  - 每次取中点`m`，如果`F[m] >= H[i]`（当前高度可以接在长度为`m`的子序列后），则调整左边界`l = m`；否则调整右边界`r = m`；  
  - 最终`x = l + 1`是当前高度能形成的最长子序列长度，更新`F[x]`为当前高度（保持`F`的最优性）。  
* 💡 **学习笔记**：手动实现二分可以更深刻理解边界条件，比如`r - l > 1`的终止条件，避免死循环。

### 题解二：STA_Morlin（核心片段）
* **亮点**：用STL函数简化二分代码，代码更简洁。
* **核心代码片段**：
```cpp
// 第一问：最长不上升子序列
if (l[r1] >= a[i]) l[++r1] = a[i];
else *upper_bound(l+1, l+r1+1, a[i], greater<int>()) = a[i];
// 第二问：最长上升子序列
if (h[r2] < a[i]) h[++r2] = a[i];
else *lower_bound(h+1, h+r2+1, a[i]) = a[i];
```
* **代码解读**：  
  - `upper_bound(l+1, l+r1+1, a[i], greater<int>())`：在`l`数组的`[1, r1]`范围内，找第一个小于`a[i]`的位置（因为`greater<int>()`表示降序比较）；  
  - `lower_bound(h+1, h+r2+1, a[i])`：在`h`数组的`[1, r2]`范围内，找第一个大于等于`a[i]`的位置；  
  - 用`*it = a[i]`直接替换该位置的值，保持数组单调性。  
* 💡 **学习笔记**：STL的`upper_bound`/`lower_bound`是处理有序数组的“神器”，但要注意比较函数的选择（如`greater<int>()`用于降序数组）。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观理解“最长不上升子序列”的求解过程，我设计了一个**8位像素风动画**，结合复古游戏元素，让算法“动”起来！
</visualization_intro>

### 动画设计方案
#### 1. 整体风格与场景
- **像素风格**：采用FC红白机的16色调色板（如蓝色背景、黄色导弹、绿色子序列），所有元素用8x8像素方块绘制；  
- **场景布局**：屏幕左侧是导弹序列（横向排列，每个方块代表一个导弹，高度用方块颜色深浅表示）；右侧是`f`数组（纵向排列，展示当前维护的子序列状态）；底部是控制面板（按钮+进度条）。

#### 2. 核心演示步骤
- **初始化**：导弹序列从左到右依次显示，`f`数组为空，控制面板显示“开始”“单步”“重置”按钮，速度滑块默认中等；  
- **单步执行**（以样例输入`389 207 155 300 299 170 158 65`为例）：  
  1. 处理第一个导弹`389`：`f`数组为空，直接加入`f`（右侧出现第一个绿色方块），播放“叮”音效；  
  2. 处理第二个导弹`207`：`207 ≤ 389`，加入`f`（右侧新增第二个绿色方块）；  
  3. 处理第三个导弹`155`：`155 ≤ 207`，加入`f`（右侧新增第三个绿色方块）；  
  4. 处理第四个导弹`300`：`300 > 155`，启动二分查找：  
     - 高亮`f`数组的`[1,3]`范围，中点`2`（值`207`），`207 < 300`，调整右边界到`2`；  
     - 中点`1`（值`389`），`389 ≥ 300`，调整左边界到`1`；  
     - 找到位置`2`（第一个小于`300`的位置），替换`f[2]`为`300`（右侧第二个方块变成黄色，闪烁提示），播放“咔嗒”音效；  
- **自动播放**：按设定速度依次执行所有步骤，完成时`f`数组长度为6（样例第一问答案），播放胜利音效（类似FC游戏的“通关音乐”）。

#### 3. 交互与控制
- **控制面板**：  
  - “开始/暂停”：控制动画播放；  
  - “单步”：逐帧执行，方便观察细节；  
  - “重置”：恢复初始状态；  
  - 速度滑块：调整自动播放的速度（从“慢”到“快”）；  
- **信息提示**：屏幕顶部显示当前处理的导弹索引和高度，右侧`f`数组的每个方块下方显示其值（如`389`、`300`等）；  
- **音效设计**：  
  - 加入子序列：“叮”（高频短音）；  
  - 二分查找：“吱”（低频长音）；  
  - 替换元素：“咔嗒”（中高频短音）；  
  - 完成：“叮——”（上扬长音）。

#### 4. 技术实现思路
- **Canvas绘制**：用HTML5 Canvas绘制像素方块，每个方块的位置和颜色由JavaScript动态控制；  
- **二分逻辑可视化**：用红色矩形框高亮当前查找范围，中点用黄色箭头标记；  
- **音效**：用Web Audio API播放预录制的8位音效（如`beep.wav`、`click.wav`），触发条件绑定到算法步骤（如加入子序列时播放`beep.wav`）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的核心思路后，可以尝试以下相似问题，巩固“最长子序列+贪心+二分”的技巧：
</similar_problems_intro>

### 通用思路迁移
本题的**贪心+二分优化LIS**思路可以解决以下问题：  
1. 求最长不下降子序列（调整`upper_bound`的比较函数）；  
2. 求最少需要多少个递增子序列覆盖整个序列（Dilworth定理的逆应用）；  
3. 求序列中的最长摆动子序列（类似LIS的贪心优化）。

### 洛谷练习推荐
1. **洛谷 P2759 [NOIP2012 提高组] 导弹防御系统**  
   🗣️ **推荐理由**：这是本题的“进阶版”，需要同时考虑上升和下降子序列，进一步巩固Dilworth定理的应用。  
2. **洛谷 P1091 [NOIP2004 提高组] 合唱队形**  
   🗣️ **推荐理由**：需要求最长先上升后下降的子序列，是LIS的变形，锻炼问题转化能力。  
3. **洛谷 P3902 递增**  
   🗣️ **推荐理由**：要求通过修改最少元素使序列递增，本质是求最长递增子序列（修改次数=总长度-LIS长度），巩固贪心+二分的优化思路。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中分享的经验教训，能帮我们避免踩坑：
</insights_intro>

> **参考经验（来自离散小波变换°）**：“我一开始在二分边界处理时犯了错误，把`r`初始化为`t`而不是`t+1`，导致数组越界。后来通过打印中间变量才发现问题。”  
> **点评**：边界条件是二分查找的“重灾区”！建议用`r = t + 1`作为初始右边界，避免访问到`f`数组的无效位置。打印中间变量（如`l`、`r`、`m`）是调试二分问题的有效方法。

> **参考经验（来自STA_Morlin）**：“一开始我混淆了`upper_bound`和`lower_bound`的适用场景，导致最长不上升子序列的结果错误。后来查了STL文档才明白，`upper_bound`找的是第一个不满足条件的位置。”  
> **点评**：STL函数的细节很重要！`upper_bound`返回第一个大于（或小于，取决于比较函数）目标值的位置，`lower_bound`返回第一个大于等于（或小于等于）目标值的位置，一定要根据问题场景选择正确的函数。  


<conclusion>
本次关于“导弹拦截”的分析就到这里！这道题是**最长子序列问题**的经典例题，核心是贪心+二分优化和Dilworth定理的应用。记住：  
- 最长不上升子序列用`upper_bound+greater<int>()`；  
- 最长上升子序列用`lower_bound`；  
- 最少不上升子序列数=最长上升子序列数（Dilworth定理）。  

多练类似题目，你会越来越熟练！下次我们再一起挑战更难的算法问题~ 💪
</conclusion>

---
处理用时：100.83秒
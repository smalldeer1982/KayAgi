# 题目信息

# [TJOI2010] 中位数

## 题目描述

给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：

- $\texttt{1 add }\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。
- $\texttt{2 mid}$：输出当前序列的中位数。

中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）

例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  
例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  
例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。


## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。
- 对于 $100\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。

序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。

## 样例 #1

### 输入

```
6
1 2 13 14 15 16
5
add 5
add 3
mid
add 20
mid
```

### 输出

```
5
13
```

# AI分析结果


### 💡 Kay的C++算法解析：[TJOI2010] 中位数 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数据结构应用（堆/平衡树）`  
🗣️ **初步分析**：  
> 解决“中位数”问题，关键在于高效维护动态序列的有序性。简单来说，这就像在游戏中实时更新排行榜并快速定位中间名次。在本题中，我们需支持动态插入和快速查询中间值。  
> - **核心难点**：插入时需保持序列有序性，查询时需快速定位中间位置（长度奇偶处理）。  
> - **解法对比**：  
>   - **平衡树**（如FHQ Treap）支持O(log n)插入和查询，但实现复杂。  
>   - **对顶堆**将序列分为较小/较大两部分，大根堆堆顶即中位数候选，插入O(log n)。  
>   - **Vector+二分**插入简单但最坏O(n)，适合小数据量。  
> - **可视化设计**：采用像素风格展示对顶堆调整过程。插入元素时，黄色方块根据值落入大根堆（蓝）或小根堆（绿），堆顶移动时高亮，音效提示关键操作（如"叮"声表示调整），自动演示模式模拟AI逐步解题。

---

#### 2. 精选优质题解参考
**题解一（FHQ Treap - 陈曦）**  
* **点评**：思路清晰，完整实现非旋转平衡树，插入和查询逻辑直白；代码规范（`split/merge`封装明确），算法高效（O(log n)）；调试建议：注意内存池管理和递归深度。亮点：避免旋转操作，适合竞赛。  

**题解二（Vector+二分 - Anguei）**  
* **点评**：利用STL简化代码（`lower_bound`定位插入位），思路直观；但插入最坏O(n)，数据水时可AC；实践价值：适合初学者快速实现，边界处理严谨（下标从0开始）。亮点：10行核心代码解决战斗。  

**题解三（对顶堆 - 这有一只匿）**  
* **点评**：经典双堆维护中位数，逻辑巧妙（大根堆存较小一半）；代码简洁（STL优先队列），调整堆大小的逻辑严谨；算法最优（O(log n)），竞赛首选。亮点：游戏化比喻“两队平衡比拼”助理解。  

---

#### 3. 核心难点辨析与解题策略
1. **难点1：动态维护有序序列**  
   * **分析**：插入需快速定位位置。优质题解用`lower_bound`（二分）、堆调整或平衡树分裂。  
   * 💡 **学习笔记**：有序性维护决定算法效率。  

2. **难点2：中位数位置计算**  
   * **分析**：奇偶处理不同（偶数取中间两数较小者）。堆解法中，大根堆大小=(n+1)/2保证堆顶即中位数。  
   * 💡 **学习笔记**：数学推导位置公式是解题基石。  

3. **难点3：数据结构选择与优化**  
   * **分析**：对顶堆需动态平衡两堆大小；平衡树需避免退化。  
   * 💡 **学习笔记**：对顶堆时空效率俱佳，优先掌握。  

✨ **解题技巧总结**  
- **技巧1：问题分解** → 将动态中位数转化为有序序列第k大问题。  
- **技巧2：堆的妙用** → 大根堆与小根堆协同维护“中间位置”。  
- **技巧3：STL利器** → `vector`+`lower_bound`或`priority_queue`简化代码。  

---

#### 4. C++核心代码实现赏析
**通用核心实现（对顶堆）**  
```cpp
priority_queue<int> max_heap; // 大根堆（存较小一半）
priority_queue<int, vector<int>, greater<int>> min_heap; // 小根堆（存较大一半）

void add(int x) {
    if (max_heap.empty() || x <= max_heap.top()) {
        max_heap.push(x);
        if (max_heap.size() > min_heap.size() + 1) {
            min_heap.push(max_heap.top()); max_heap.pop();
        }
    } else {
        min_heap.push(x);
        if (min_heap.size() > max_heap.size()) {
            max_heap.push(min_heap.top()); min_heap.pop();
        }
    }
}
int mid() { return max_heap.top(); } // 中位数即大根堆堆顶
```

**题解一（FHQ Treap）片段**  
```cpp
void insert(int x) { // 按值分裂再合并
    split(root, a, b, x); 
    root = merge(merge(a, new_node(x)), b);
}
int kth(int k) { // 按秩查询（左子树大小决定走向）
    while (now) {
        if (left_size + 1 == k) return val;
        if (left_size >= k) now = lson;
        else k -= left_size + 1, now = rson;
    }
}
```
**学习笔记**：非旋转Treap避免复杂旋转，内存池管理提升效率。  

**题解二（Vector+二分）片段**  
```cpp
vector<int> v;
void add(int x) {
    v.insert(lower_bound(v.begin(), v.end(), x), x);
}
int mid() { 
    return (v.size() % 2) ? v[v.size()/2] : v[v.size()/2 - 1];
}
```
**学习笔记**：`lower_bound`二分定位，插入后保持严格有序。  

---

#### 5. 算法可视化：像素动画演示  
* **主题**：像素探险家之堆调整  
* **核心演示**：  
  1. **初始化**：左侧大根堆（蓝色块）、右侧小根堆（绿色块），控制面板含速度滑块。  
  2. **插入元素**：黄色方块从底部升起，比较后落入对应堆（音效："滴"）。  
  3. **堆调整**：若大根堆大小 > 小根堆+1，堆顶（闪烁红光）移至小根堆（动画：方块滑移 + "咔嚓"音效）。  
  4. **查询中位数**：大根堆顶持续高亮（红光），显示数值。  
* **交互设计**：  
  - 单步执行：按空格逐步观察插入/调整。  
  - 自动演示：AI模式模拟解题流程（速度可调）。  
  - 音效：背景8-bit音乐，关键操作触发不同音效（成功时播放胜利旋律）。  

---

#### 6. 拓展练习与相似问题思考
* **通用技巧迁移**：  
  - 对顶堆用于数据流中位数（LeetCode 295）、滑动窗口中位数（LeetCode 480）。  
  - 平衡树解决动态排名查询（洛谷 P3369）。  
* **洛谷推荐**：  
  1. **P1168 中位数** → 对顶堆模板题，巩固双堆维护技巧。  
  2. **P3369 普通平衡树** → 深入理解平衡树插入/删除/查询操作。  
  3. **P1801 黑匣子** → 动态查询第k大，堆/平衡树进阶练习。  

---

#### 7. 学习心得与经验分享
> **陈曦的调试经验**：“FHQ Treap的`split`需严格按值分裂，递归边界易错。”  
> **Kay点评**：调试时建议打印树结构，验证左右子树大小关系。  
>  
> **对顶堆边界教训**（匿名作者）：“偶数长度时需保证大根堆大小=(n+1)/2。”  
> **Kay总结**：数学推导是代码正确性的前提，动手模拟验证边界！  

---

本次指南精炼多种解法，助你掌握动态中位数核心思想。记住：选择数据结构需权衡效率与实现复杂度，对顶堆是竞赛利器！下次挑战再见 💪

---
处理用时：191.51秒
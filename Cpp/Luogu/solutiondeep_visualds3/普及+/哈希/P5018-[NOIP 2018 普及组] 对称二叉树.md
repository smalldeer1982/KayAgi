# 题目信息

# [NOIP 2018 普及组] 对称二叉树

## 题目背景

NOIP2018 普及组 T4

## 题目描述

一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： 

1.  二叉树； 
2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   

下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  

![](https://cdn.luogu.com.cn/upload/image_hosting/nkln7z1l.png)

现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数最多。请输出这棵子树的节点数。   

注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。 

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/4lfen5aa.png)    
最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/vhzzc587.png)

最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 

**数据规模与约定**

共 $25$ 个测试点。    

$v_i ≤ 1000$。 

- 测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。 
- 测试点 $4 \sim 8, n ≤ 10$。
- 测试点 $9 \sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。 
- 测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。
- 测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。
- 测试点 $21 \sim 25, n ≤ 10^6$。

本题约定： 

层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 
 
 树的深度：树中节点的最大层次称为树的深度。 
 
 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/8tof1fxx.png)

完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/ibo7js1f.png)

## 样例 #1

### 输入

```
2 
1 3 
2 -1 
-1 -1 
```

### 输出

```
1```

## 样例 #2

### 输入

```
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8```

### 输出

```
3```

# AI分析结果



---
# 💡 Kay的C++算法解析：对称二叉树 深入学习指南 💡

<introduction>
今天我们来一起分析“对称二叉树”这道NOIP2018普及组的题目。这道题的关键在于判断二叉树的子树是否对称，并找到节点数最多的那个。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`递归与树结构判断`

🗣️ **初步分析**：
解决“对称二叉树”这道题，关键在于理解如何通过递归判断子树的对称性。简单来说，递归判断就像“照镜子”——对于两个节点，我们需要比较左子树的左子树与右子树的右子树（镜像位置），同时比较左子树的右子树与右子树的左子树（另一镜像位置）。如果所有对应位置的节点结构相同且权值相等，那么这棵子树就是对称的。

在本题中，递归判断的核心步骤包括：
1. **预处理子树大小**：计算每个节点的子树包含多少个节点（记为`size`），用于快速剪枝（若左右子树大小不同，直接判定不对称）。
2. **递归比较对称性**：对于每个节点，递归比较其左右子树是否对称（结构相同且权值相等）。

核心难点在于如何高效判断对称性，避免重复计算。优质题解通常通过预处理`size`剪枝，将时间复杂度优化到$O(n\log n)$。

**可视化设计思路**：我们将用8位像素风格的动画演示递归判断过程。例如，用不同颜色的方块表示节点，当递归比较两个节点时，用像素箭头连接它们；若权值不同或结构不同，对应方块会闪烁红色并伴随“叮”的提示音；若对称，则绿色高亮并播放轻快音效。动画支持单步执行和自动播放，帮助直观理解递归逻辑。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：作者wsm52**
* **点评**：这份题解代码简洁，思路直白。作者先预处理每个子树的大小（`size`数组），再通过递归函数`dfs(x,y)`判断两棵子树是否对称。递归的终止条件和逻辑判断清晰（如“若x和y都为空则对称，若仅一个为空则不对称”），变量命名直观（`l`、`r`表示左右子节点）。代码中通过预处理`size`剪枝（若左右子树大小不同直接跳过），时间复杂度合理，适合竞赛直接使用。

**题解二：作者WsW_**
* **点评**：此题解不仅提供了代码，还详细证明了暴力递归的时间复杂度为$O(n\log n)$。作者指出，通过`size`剪枝后，每个节点最多被递归$\log n$次，避免了最坏$O(n^2)$的复杂度。代码中`check`函数递归比较左右子树，逻辑简洁，适合理解递归与剪枝的结合。

**题解三：作者何俞均**
* **点评**：此题解采用哈希优化，通过欧拉序和哈希值快速比较子树的结构和权值是否对称。虽然代码稍复杂，但思路巧妙——通过两次DFS生成不同遍历顺序的欧拉序，再用哈希值代替实际节点比较，将判断时间优化到$O(1)$。适合学习哈希在树结构中的应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，常见的难点包括如何定义递归条件、如何剪枝优化，以及如何避免重复计算。以下是核心难点的分析与策略：
</difficulty_intro>

1.  **关键点1：如何定义递归判断的条件？**
    * **分析**：判断两棵子树是否对称，需同时满足结构相同和权值相等。递归函数需要传入两个节点（如`x`和`y`），比较它们的权值是否相等，然后递归比较`x的左子树与y的右子树`、`x的右子树与y的左子树`。若其中任意一步不满足条件，直接返回`false`。
    * 💡 **学习笔记**：递归判断的核心是“镜像比较”，即左对右、右对左。

2.  **关键点2：如何预处理子树大小以剪枝？**
    * **分析**：若两棵子树的大小（节点数）不同，它们一定不对称。因此，预处理每个节点的子树大小（`size`数组）后，在递归前先比较`size[x]`和`size[y]`，可快速排除不可能的情况，减少递归次数。
    * 💡 **学习笔记**：剪枝是优化递归算法的关键，能显著降低时间复杂度。

3.  **关键点3：如何避免重复计算？**
    * **分析**：对于每个子树，我们需要判断其是否对称。若直接暴力枚举每个节点并递归判断，最坏时间复杂度为$O(n^2)$。通过预处理`size`并剪枝，可将时间复杂度优化到$O(n\log n)$（如WsW_的证明）。
    * 💡 **学习笔记**：预处理关键信息（如子树大小）是减少重复计算的有效手段。

### ✨ 解题技巧总结
- **递归镜像比较**：判断对称时，左子树的左子树与右子树的右子树比较，左子树的右子树与右子树的左子树比较。
- **预处理剪枝**：通过`size`数组快速排除大小不同的子树，减少递归次数。
- **哈希优化**（可选）：对于大规模数据，用哈希值代替节点比较，将判断时间降至$O(1)$。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了递归判断和预处理剪枝，代码简洁且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了wsm52和WsW_的题解思路，预处理子树大小，递归判断对称性，适合竞赛使用。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e6 + 10;
    int n, v[N], l[N], r[N], siz[N];
    int ans = 1;

    // 预处理子树大小
    int dfs_size(int x) {
        if (x == -1) return 0;
        return siz[x] = dfs_size(l[x]) + dfs_size(r[x]) + 1;
    }

    // 递归判断两棵子树是否对称
    bool check(int x, int y) {
        if (x == -1 && y == -1) return true; // 都为空，对称
        if (x == -1 || y == -1) return false; // 仅一个为空，不对称
        if (v[x] != v[y]) return false; // 权值不同，不对称
        if (siz[x] != siz[y]) return false; // 剪枝：大小不同，不对称
        return check(l[x], r[y]) && check(r[x], l[y]); // 镜像比较
    }

    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) scanf("%d", &v[i]);
        for (int i = 1; i <= n; ++i) {
            int ls, rs;
            scanf("%d%d", &ls, &rs);
            l[i] = ls; r[i] = rs;
        }
        dfs_size(1); // 预处理所有子树大小
        for (int i = 1; i <= n; ++i) {
            if (check(l[i], r[i])) { // 判断以i为根的子树是否对称
                ans = max(ans, siz[i]);
            }
        }
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
  - `dfs_size`函数递归计算每个节点的子树大小，存储在`siz`数组中。
  - `check`函数递归判断两棵子树是否对称：先处理边界条件（空节点、权值不同），再剪枝（大小不同），最后递归镜像比较左右子树。
  - 主函数中预处理所有子树大小，遍历每个节点，判断其是否为对称子树的根，并更新最大节点数。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的亮点。
</code_intro_selected>

**题解一：作者wsm52**
* **亮点**：代码简洁，逻辑清晰，直接通过递归判断对称性，预处理`size`剪枝。
* **核心代码片段**：
    ```cpp
    bool dfs(int x, int y) {
        if (x == -1 && y == -1) return true;
        if (x == -1 || y == -1) return false;
        if (v[x] != v[y]) return false;
        return dfs(l[x], r[y]) && dfs(r[x], l[y]);
    }
    ```
* **代码解读**：
  - 递归终止条件：若`x`和`y`都为空，返回`true`；若仅一个为空，返回`false`。
  - 权值比较：若`v[x] != v[y]`，直接返回`false`。
  - 递归镜像比较：`x的左子树`与`y的右子树`比较，`x的右子树`与`y的左子树`比较。
* 💡 **学习笔记**：递归函数的参数是两个节点，通过镜像比较实现对称性判断。

**题解二：作者WsW_**
* **亮点**：通过`size`剪枝优化时间复杂度，代码中明确体现了剪枝逻辑。
* **核心代码片段**：
    ```cpp
    bool check(int lp, int rp) {
        if (!lp && !rp) return 1;
        if (size[lp] != size[rp] || v[lp] != v[rp]) return 0;
        return check(l[lp], r[rp]) & check(r[lp], l[rp]);
    }
    ```
* **代码解读**：
  - 剪枝：若左右子树大小不同（`size[lp] != size[rp]`），直接返回`false`。
  - 权值比较：若权值不同，返回`false`。
  - 递归镜像比较：与wsm52的思路一致，但剪枝提前，减少递归次数。
* 💡 **学习笔记**：剪枝能有效减少不必要的递归调用，提升效率。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解递归判断对称的过程，我们设计了一个8位像素风格的动画，模拟“镜像比较”的每一步！
</visualization_intro>

  * **动画演示主题**：`像素镜像树探险`
  * **核心演示内容**：以某个子树为根，递归比较其左右子树的镜像节点是否对称，展示结构和权值的匹配过程。
  * **设计思路简述**：采用FC红白机风格的像素方块表示节点，用不同颜色区分当前比较的节点（如蓝色表示正在比较的左节点，红色表示右节点）。关键步骤加入音效（如比较成功时“叮”一声，失败时“咚”一声），增强操作记忆。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：
       - 屏幕左侧显示原树，右侧显示镜像树（左右子树交换后的树），每个节点用像素方块表示，标注权值。
       - 控制面板包含“单步”“自动播放”“重置”按钮，以及速度滑块（1x到5x）。
       - 播放8位风格的轻快背景音乐。

    2. **递归启动**：
       - 选择一个子树根节点（如节点2），动画高亮该节点，显示其子树大小。
       - 同时高亮其左右子节点（左子节点A，右子节点B），开始比较。

    3. **镜像比较过程**：
       - **步骤1**：比较A和B的权值。若相同，方块变绿；若不同，变红并播放“咚”声。
       - **步骤2**：递归比较A的左子节点与B的右子节点。像素箭头从A左指向B右，高亮这两个节点。
       - **步骤3**：递归比较A的右子节点与B的左子节点。箭头从A右指向B左，高亮这两个节点。
       - 每一步比较结果（成功/失败）用颜色和音效反馈，同时显示对应的递归调用栈（如“check(A左, B右)”）。

    4. **目标达成**：
       - 若所有比较成功，根节点变为金色，播放“胜利”音效，显示该子树的节点数。
       - 若失败，根节点保持灰色，提示“不对称”。

    5. **AI自动演示**：
       - 点击“AI自动演示”，动画自动遍历所有子树，找到最大对称子树，过程中用文字提示“当前最大节点数：X”。

  * **旁白提示**：
    - “现在比较节点A和B的权值，若不同则直接不对称！”
    - “接下来要比较A的左子树和B的右子树，就像照镜子一样哦～”
    - “看！这两个节点权值相同，结构也匹配，这部分对称啦！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到递归如何一步步验证对称性，理解剪枝（如大小不同直接跳过）的作用，以及镜像比较的核心逻辑。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解对称二叉树的判断后，我们可以尝试解决更多树结构相关的问题，巩固递归和树遍历的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 递归判断树的对称性：可用于判断回文树、镜像树等结构。
    - 预处理子树信息（如大小、深度）：在树的路径问题、最近公共祖先等问题中也常用。
    - 哈希优化树结构比较：适用于需要快速判断两棵树是否同构的场景。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1043 [NOIP2003 普及组] 数字游戏**
        * 🗣️ **推荐理由**：涉及树的中序遍历和动态规划，可巩固树的遍历与递归思想。
    2.  **洛谷 P1305 新二叉树**
        * 🗣️ **推荐理由**：通过前序遍历构建二叉树，练习树的结构操作。
    3.  **洛谷 P5022 [NOIP2018 提高组] 赛道修建**
        * 🗣️ **推荐理由**：涉及树的深度优先搜索和贪心策略，提升复杂树问题的解决能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试和优化的经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自作者exprosic)**：“暴力递归的时间复杂度其实是$O(n\log n)$，因为每个节点最多被递归$\log n$次。关键在于剪枝（如比较子树大小），避免不必要的递归调用。”
>
> **点评**：exprosic的经验提醒我们，看似暴力的递归算法通过合理剪枝，也能达到高效。在实际编码中，预处理关键信息（如子树大小）是优化的重要手段。

---

<conclusion>
本次关于“对称二叉树”的C++解题分析就到这里。希望大家通过本指南掌握递归判断树对称性的方法，理解剪枝优化的重要性，并能通过像素动画直观感受算法过程。编程能力的提升需要多练习、多思考，期待下次一起挑战更多算法问题！💪
</conclusion>

---
处理用时：149.81秒
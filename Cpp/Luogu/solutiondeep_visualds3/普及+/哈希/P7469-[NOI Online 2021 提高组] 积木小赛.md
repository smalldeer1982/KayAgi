# 题目信息

# [NOI Online 2021 提高组] 积木小赛

## 题目描述

Alice 和 Bob 最近热衷于玩一个游戏——积木小赛。

Alice 和 Bob 初始时各有 $n$ 块积木从左至右排成一排，每块积木都被标上了一个英文小写字母。

Alice 可以从自己的积木中丢掉任意多块（也可以不丢）；Bob 可以从自己的积木中丢掉最左边的一段连续的积木和最右边的一段连续的积木（也可以有一边不丢或者两边都不丢）。两人都不能丢掉自己所有的积木。然后 Alice 和 Bob 会分别将自己剩下的积木按原来的顺序重新排成一排。

Alice 和 Bob 都忙着去玩游戏了，于是想请你帮他们算一下，有多少种不同的情况下他们最后剩下的两排积木是相同的。

两排积木相同，当且仅当这两排积木块数相同且每一个位置上的字母都对应相同。

两种情况不同，当且仅当 Alice（或者 Bob）剩下的积木在两种情况中不同。

## 说明/提示

对于所有测试点：$1\le n \le 3000$，$s$ 与 $t$ 中只包含英文小写字母。

测试点 $1$ 满足：$n\le3000$，$s$ 与 $t$ 中只包含同一种字母。

测试点 $2,3,4$ 满足：$n\le100$。

测试点 $5,6,7$ 满足：$n\le500$。

测试点 $8,9,10$ 满足：$n\le3000$。

感谢 [w33z8kqrqk8zzzx33](https://www.luogu.com.cn/user/220037) 提供测试数据。

## 样例 #1

### 输入

```
5
bcabc
bbcca```

### 输出

```
9```

## 样例 #2

### 输入

```
20
egebejbhcfabgegjgiig
edfbhhighajibcgfecef```

### 输出

```
34```

# AI分析结果



---
# 💡 Kay的C++算法解析：积木小赛 深入学习指南 💡

<introduction>
今天我们来一起分析“积木小赛”这道C++编程题。题目要求统计Alice和Bob剩下的积木序列相同的不同情况数，本质上是求t的所有本质不同子串中属于s的子序列的数量。本指南将帮助大家梳理核心思路、关键算法，并通过可视化和代码解析深入理解解题过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理与哈希/自动机应用`

🗣️ **初步分析**：
解决“积木小赛”的关键在于两步：一是枚举t的所有子串并去重，二是判断这些子串是否是s的子序列。简单来说，子序列判断可以通过贪心匹配实现（逐个字符在s中找后续位置），而去重则需要哈希或自动机等方法避免重复计数。

- **题解思路**：主流解法有两种：  
  ① 枚举t的每个子串，用哈希记录已出现的子串，同时贪心匹配s的子序列（如syksykCCC的哈希+贪心）；  
  ② 对s建子序列自动机（快速判断子序列），对t建后缀自动机（SAM，自动去重），双自动机同步遍历统计有效子串（如Karry5307的SAM+子序列自动机）。  
  前者代码简洁，适合理解；后者时间复杂度更优（O(n²)），适合高效实现。

- **核心算法流程**：以哈希+贪心为例，枚举t的左端点i，右端点j从i开始扩展，维护s中的匹配指针p（初始为1）。每次j右移时，p在s中找到t[j]的位置，若找到则计算该子串的哈希值并存入数组，最后排序去重得到答案。

- **可视化设计**：采用8位像素风格，模拟t子串的生成（用像素块逐列扩展）、s的贪心匹配（指针p在s的像素网格中跳跃）、哈希表的存储（用“像素抽屉”表示哈希桶，新子串哈希值被放入对应抽屉）。关键步骤高亮（如p找到t[j]时闪烁，哈希冲突时抽屉颜色变化），音效在匹配成功/失败时播放“叮”/“咚”声。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑简洁或优化巧妙被选为优质参考：
</eval_intro>

**题解一：syksykCCC（哈希+贪心）**  
* **点评**：该题解思路直接，通过枚举t的子串并贪心匹配s的子序列，利用哈希去重。代码简洁（仅20行核心），变量命名清晰（如`v`存储哈希值，`p`为s的匹配指针），时间复杂度O(n² logn)，适合作为入门学习。亮点在于用哈希快速判重，避免了重复计数。

**题解二：Karry5307（子序列自动机+哈希表）**  
* **点评**：该题解对s建立子序列自动机（`nxt`数组记录每个位置后各字符的下一个位置），对t枚举子串时用自动机快速匹配，并用手写哈希表优化判重。时间复杂度O(n²)，空间优化（手写哈希表比map快），适合追求效率的学习者。亮点是子序列自动机的预处理，将匹配时间降至O(1)。

**题解三：一叶知秋。（预处理LCP+动态规划）**  
* **点评**：该题解预处理`f[i][j]`表示t以i开头、j开头的后缀的最长公共前缀（LCP），利用LCP优化枚举范围，减少无效匹配。时间复杂度O(n²)，代码通过倒序枚举优化转移，边界处理严谨。亮点是LCP的预处理，避免了重复计算相同前缀。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于高效枚举、判重和匹配。结合优质题解，我们提炼以下关键点：
</difficulty_intro>

1.  **关键点1：如何高效枚举t的子串？**  
    * **分析**：t的子串有O(n²)个，直接枚举会超时。优质题解通过固定左端点i，右端点j从i开始扩展（如syksykCCC），或利用LCP预处理减少无效枚举（一叶知秋。），将时间复杂度控制在O(n²)。  
    * 💡 **学习笔记**：固定左端点+右端点扩展是枚举子串的经典方法，可结合预处理优化。

2.  **关键点2：如何快速判断子串是否是s的子序列？**  
    * **分析**：贪心匹配是关键：对t的子串`[i,j]`，在s中从左到右找每个字符t[k]（k=i到j），若能依次找到则是子序列。子序列自动机（预处理每个位置后各字符的下一个位置）可将匹配时间降至O(1)（如Karry5307的`nxt`数组）。  
    * 💡 **学习笔记**：预处理`nxt[i][c]`表示s中i位置后字符c的第一个出现位置，是加速子序列匹配的核心技巧。

3.  **关键点3：如何高效去重？**  
    * **分析**：哈希（如syksykCCC的大模数哈希）和SAM（后缀自动机，自动去重）是主流方法。哈希需注意冲突（双哈希或大模数），SAM则通过状态转移自然去重。  
    * 💡 **学习笔记**：SAM适合处理子串去重问题，哈希适合快速实现但需注意冲突。

### ✨ 解题技巧总结
- **预处理优化**：预处理s的`nxt`数组，快速匹配子序列。  
- **固定左端点枚举**：减少子串枚举的重复计算。  
- **哈希/自动机去重**：根据场景选择哈希（简单）或SAM（高效）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合哈希判重和贪心匹配，代码简洁且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合syksykCCC和Karry5307的思路，采用哈希判重+贪心匹配，适用于理解基础逻辑。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 3005;
    const long long BASE = 51971, MOD = 2005091020050911;
    int n;
    char s[N], t[N];
    long long hash_list[N * N];
    int main() {
        scanf("%d %s %s", &n, s + 1, t + 1);
        int cnt = 0;
        for (int i = 1; i <= n; ++i) {
            long long hash_val = 0;
            int p = 1; // s的匹配指针
            for (int j = i; j <= n; ++j) {
                while (p <= n && s[p] != t[j]) p++;
                if (p > n) break; // 无法匹配，后续子串也无法匹配
                hash_val = (hash_val * BASE + (t[j] - 'a' + 1)) % MOD;
                hash_list[++cnt] = hash_val;
                p++; // 下一次从p+1开始找
            }
        }
        sort(hash_list + 1, hash_list + cnt + 1);
        int ans = unique(hash_list + 1, hash_list + cnt + 1) - hash_list - 1;
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先枚举t的左端点i，右端点j从i扩展。维护s的匹配指针p，每次j右移时p在s中找到t[j]的位置。若找到，计算该子串的哈希值并存入数组。最后排序去重，统计不同哈希值的数量即为答案。

---
<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：syksykCCC（哈希+贪心）**
* **亮点**：代码极简，贪心匹配+哈希判重，适合入门。  
* **核心代码片段**：
    ```cpp
    for(int i = 1; i <= n; i++) {
        long long v = 0; int p = 1;
        for(int j = i; j <= n; j++) {
            while(p <= n && a[p] != b[j]) p++;
            if(p > n) break;
            p++;
            v = (1LL * v * BASE + b[j] - 'a' + 1) % M;
            t[++t[0]] = v;
        }
    }
    sort(t + 1, t + t[0] + 1);
    printf("%d\n", unique(t + 1, t + t[0] + 1) - t - 1);
    ```
* **代码解读**：  
  `i`是t的左端点，`j`是右端点。`p`是s的匹配指针，初始为1。每次`j`右移时，`p`在s中找到`t[j]`的位置，若找到则计算哈希值`v`并存入数组`t`。最后排序去重得到答案。  
* 💡 **学习笔记**：贪心匹配的关键是`p`指针的递增，确保每个字符按顺序匹配。

**题解二：Karry5307（子序列自动机+哈希表）**
* **亮点**：子序列自动机加速匹配，手写哈希表优化判重。  
* **核心代码片段**：
    ```cpp
    for(register int i=n;i;i--) {
        memcpy(nxt[i-1],nxt[i],sizeof(nxt[i]));
        nxt[i-1][s[i]-'a']=i;
    }
    for(register int i=1;i<=n;i++) {
        cur=hsh1=hsh2=0;
        for(register int j=i;j<=n;j++) {
            if(!(cur=nxt[cur][t[j]-'a'])) break;
            hsh1=(hsh1*131+t[j]-'a'+1)%MOD1;
            hsh2=(hsh2*131+t[j]-'a'+1)%MOD2;
            !hsh.query(hsh1,hsh2)?hsh.insert(hsh1,hsh2),res++:1;
        }
    }
    ```
* **代码解读**：  
  `nxt[i][c]`表示s中i位置后字符c的第一个出现位置（子序列自动机）。枚举t的子串时，`cur`通过`nxt`快速跳转匹配，双哈希`hsh1`和`hsh2`减少冲突，手写哈希表`hsh`判重。  
* 💡 **学习笔记**：子序列自动机的预处理将匹配时间降至O(1)，是优化关键。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解枚举t子串并匹配s的过程，我们设计“像素匹配探险”动画，模拟贪心匹配和哈希判重的每一步。
</visualization_intro>

  * **动画演示主题**：`像素匹配探险——在s和t的积木世界中找相同序列`

  * **核心演示内容**：  
    展示t的子串生成（如从左端点i开始，右端点j逐格扩展），s的贪心匹配（指针p在s的网格中跳跃找t[j]），哈希表记录（新子串的哈希值被放入对应“像素抽屉”）。

  * **设计思路简述**：  
    8位像素风格模拟FC游戏界面，用不同颜色区分s（蓝色）和t（红色）的积木。匹配成功时p指针闪烁，哈希抽屉存入新值时播放“叮”声；匹配失败时p指针变灰，播放“咚”声。通过动画强化“子串生成→匹配→判重”的流程。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：  
        - 屏幕分为左右两部分：左为s的积木网格（n列，每列标字符），右为t的积木网格（n列）。  
        - 下方显示控制面板（单步/自动播放按钮、速度滑块），右侧显示哈希抽屉（26个像素框，标哈希值范围）。

    2.  **枚举t的子串**：  
        - 左端点i用红色框标出，右端点j从i开始逐格右移（像素块变亮），显示当前子串`[i,j]`。

    3.  **贪心匹配s**：  
        - 指针p在s网格中从1开始，逐格寻找t[j]的字符（p移动时带箭头）。找到时p所在列闪烁绿色，j右移；未找到时p变灰，动画停止，j不再扩展。

    4.  **哈希判重**：  
        - 匹配成功的子串计算哈希值，对应哈希抽屉弹出（如抽屉颜色变绿）。若抽屉已有相同哈希值（颜色变红），则不计入答案；否则存入并计数（答案数字增加）。

    5.  **自动演示模式**：  
        - 点击“AI演示”，动画自动完成所有子串的枚举、匹配和判重，学习者可观察整体流程。

  * **旁白提示**：  
    - “现在枚举t的左端点i=2，右端点j从2开始扩展。”  
    - “p指针在s中找到t[2]='b'，位置是s[1]，匹配成功！”  
    - “计算当前子串的哈希值，存入抽屉#123，答案+1。”

<visualization_conclusion>
通过这一动画，我们能直观看到每个子串的生成、匹配和判重过程，理解为何哈希和贪心是解决本题的关键。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是字符串的子串枚举、子序列判断和去重，以下是相关拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    子序列匹配和子串去重的方法（如哈希、自动机）可用于：  
    ① 统计两个字符串的公共子串数；  
    ② 判断一个字符串是否是另一个的子序列变种；  
    ③ 处理多模式串匹配问题（如AC自动机）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4112 [HEOI2015]最短不公共子串**  
        * 🗣️ **推荐理由**：结合子序列自动机和后缀自动机，深入理解双自动机的应用。  
    2.  **洛谷 P5023 [NOIP2018 提高组] 填数游戏**  
        * 🗣️ **推荐理由**：涉及字符串的子序列和博弈论，锻炼综合分析能力。  
    3.  **洛谷 P3804 [模板] 后缀自动机**  
        * 🗣️ **推荐理由**：强化后缀自动机的实现和应用，掌握子串去重的核心数据结构。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自 wsyhb)**：“赛时写了未经优化的桶排，因未考虑字符集常数导致TLE。提醒我们要认真分析时间复杂度，并生成大数据测试。”  
> **点评**：这位作者的经验提醒我们，算法的理论复杂度和实际运行效率可能存在差异，需注意常数优化（如用手写哈希表替代map）。测试时应生成极端数据（如全a字符串）验证代码鲁棒性。

-----

<conclusion>
本次关于“积木小赛”的分析就到这里。通过理解枚举、匹配和去重的核心逻辑，掌握哈希和自动机的应用，相信大家能轻松解决此类问题。继续加油，下一个编程高手就是你！💪
</conclusion>

---
处理用时：154.32秒
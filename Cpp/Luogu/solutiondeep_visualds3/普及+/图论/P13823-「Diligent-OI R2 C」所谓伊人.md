# 题目信息

# 「Diligent-OI R2 C」所谓伊人

## 题目背景

> 溯洄从之，道阻且长。溯游从之，宛在水中央。——《诗经·秦风·蒹葭》

## 题目描述

给定一张 $n$ 个点，$m$ 条边的有向图，点从 $1\sim n$ 编号。图中每个点 $i$ 有点权 $p_i$。注意可能有重边自环。

如果点 $u$ 出发存在路径到达点 $v$，则你可以将 $u,v$ 的点权交换。

对于每个点 $i$，输出使 $i$ 点权最大化的最少交换次数。**请注意，每个回答是独立的，即都应该从初始给定的图开始交换。**

## 说明/提示

#### 样例 #1 解释

可以证明，$6$ 个点的点权的最大可能值分别为 $1,1,5,5,5,4$。

使 $1$ 号点点权最大化的方案：不交换。

使 $2$ 号点点权最大化的方案：不交换。

使 $3$ 号点点权最大化的方案：交换 $3$ 号和 $4$ 号点的点权。

使 $4$ 号点点权最大化的方案：不交换。

使 $5$ 号点点权最大化的方案：交换 $4$ 号和 $5$ 号点的点权。

使 $6$ 号点点权最大化的方案：不交换。

#### 数据范围

对于所有数据，保证 $1\le n,m\le 5\times10^5,1\le p_i\le10^9,1\le u,v\le n$。注意可能有重边自环。

- Subtask 1（5pts）：$n,m\le3$。
- Subtask 2（25pts）：$n,m\le10^3$。
- Subtask 3（8pts）：图为一条链。即对于所有 $i=1,2,\dots,n-1$，$i$ 与 $i+1$ 之间有且仅有一条有向边，但方向不确定。
- Subtask 4（12pts）：图为一棵树。即 $m=n-1$，且图将有向边改成无向边后连通。
- Subtask 5（20pts）：$n,m\le5\times10^4$，且图随机生成。随机生成方式见下。
- Subtask 6（10pts）：$n,m\le10^5$。
- Subtask 7（20pts）：$n,m\le5\times10^5$。

Subtask 5 的随机生成方式：

- 先确定 $n,m$ 和序列 $p$（不一定随机）。
- 然后对于 $m$ 条边，每条边的 $u,v$ 都在 $1\sim n$ 的整数中均匀随机取。

**请注意，此题需要较快的输入输出方式，并且在实现过程中，请注意常数对程序效率的影响。**

## 样例 #1

### 输入

```
6 5
1 1 4 5 1 4
1 2
2 1
3 4
4 5
3 5```

### 输出

```
0 0 1 0 1 0```

# AI分析结果


### 💡 Kay的C++算法解析：「Diligent-OI R2 C」所谓伊人 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论建模、连通性分析、01BFS

🗣️ **初步分析**：
> 本题要求通过交换操作使每个点获得最大点权，关键在于理解**交换传递性**：若点$u$能通过路径到达$v$，则两者可通过中间点传递权值（类似传话游戏）。核心解法分三步：
> 1. **连通块分析**：忽略有向边方向，形成无向连通块，块内任意两点可互相传递权值
> 2. **最大值定位**：找出每个连通块的最大点权（可能多个点）
> 3. **交换路径建模**：通过拆点技巧构建0/1权图，用01BFS计算最小交换次数
>
> **可视化设计思路**：
> - 像素网格中，每个点拆成4个色块（红/蓝/绿/黄）
> - 0权边（白箭头）：原图边/内部转移
> - 1权边（金箭头）：交换操作，触发"叮"音效
> - 起点（最大值点）闪烁，终点（目标点）显示最终交换次数
> - 控制面板支持步进/调速，通关时播放8-bit胜利音效

---

#### 2. 精选优质题解参考
**题解 (来源：Night_sea_64 出题人题解)**
* **点评**：该题解思路严谨，通过**拆点技巧**将复杂交换操作转化为图论问题。亮点包括：
  - **创新建模**：每个点拆为4个状态（A1/A2/B1/B2），用0/1权边区分交换行为
  - **高效算法**：01BFS实现$O(n+m)$时间复杂度，完美匹配数据规模
  - **实践价值**：代码规范使用双端队列，输入输出优化处理边界
  - **注意点**：起点初始化应为0（原代码为1），否则需调整输出值

---

#### 3. 核心难点辨析与解题策略
1.  **连通性理解**
    * **分析**：交换操作依赖路径而非直接连接（类似六度空间理论）。通过构建无向图连通块，确保块内权值可任意传递
    * 💡 **学习笔记**：权值传递的本质是路径可逆性，与强连通分量不同

2.  **拆点建模**
    * **分析**：核心在于区分"转移"（0权）和"交换"（1权）：
      - 原边$u→v$ → $u_{B2}\xrightarrow{0}v_{A1}$ 和 $v_{A2}\xrightarrow{0}u_{B1}$
      - 内部边：$ \begin{cases} A1\xrightarrow{0}A3 \\ A1\xrightarrow{1}A4 \\ ... \end{cases} $
    * 💡 **学习笔记**：拆点法可将复杂操作转化为标准图论问题

3.  **01BFS优化**
    * **分析**：双端队列处理0/1权边——0权边插队首保持有序性，1权边插队尾。优于Dijkstra的$O(n\log n)$
    * 💡 **学习笔记**：边权仅为0/1时，01BFS是最高效最短路算法

### ✨ 解题技巧总结
- **问题转化**：将抽象交换规则转化为图论最短路问题
- **状态压缩**：用4个点表示单点的内外转移状态
- **边界处理**：最大值点特判（交换次数=0），避免冗余计算
- **常数优化**：链式前向星存图 + IO加速

---

#### 4. C++核心代码实现赏析
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e6+5; // 4倍空间
struct Edge { int to, w, next; };
Edge ed[N<<2];     // 4倍边
int head[N], d[N], a[N], maxVal[N];
bool isMax[N];
int n, m, cnt;

inline void add(int u, int v, int w) {
    ed[++cnt] = {v, w, head[u]};
    head[u] = cnt;
}

void dfsMax(int u, int& curMax) {
    if(maxVal[u]) return;
    maxVal[u] = a[u];
    for(int i=head[u]; i; i=ed[i].next) {
        int v = ed[i].to;
        dfsMax(v, curMax);
        maxVal[u] = max(maxVal[u], maxVal[v]);
    }
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    cin >> n >> m;
    // 原始点权
    for(int i=1; i<=n; ++i) cin >> a[i];
    
    // 拆点建模
    for(int i=1; i<=n; ++i) {
        int A1=4*i-3, A2=4*i-2, B1=4*i-1, B2=4*i;
        add(A1, B1, 0); add(A1, B2, 1);
        add(A2, B1, 1); add(A2, B2, 0);
    }
    for(int i=1; i<=m; ++i) {
        int u, v; cin >> u >> v;
        int uB=4*u, vA=4*v-3;   // u_B2 → v_A1
        add(uB, vA, 0);
        add(4*v-2, 4*u-1, 0);   // v_A2 → u_B1
    }

    // 求连通块最大值
    for(int i=1; i<=n; ++i) 
        if(!maxVal[i]) {
            int curMax = 0;
            dfsMax(i, curMax);
        }
    
    // 标记最大值点
    for(int i=1; i<=n; ++i) 
        isMax[i] = (a[i] == maxVal[i]);

    // 01BFS初始化
    deque<int> q;
    memset(d, -1, sizeof d);
    for(int i=1; i<=n; ++i) {
        if(!isMax[i]) continue;
        int A1=4*i-3, A2=4*i-2;
        d[A1] = 0; q.push_back(A1);
        d[A2] = 0; q.push_back(A2);
    }

    // 01BFS核心
    while(!q.empty()) {
        int u = q.front(); q.pop_front();
        for(int i=head[u]; i; i=ed[i].next) {
            int v = ed[i].to, w = ed[i].w;
            if(d[v] != -1) continue;
            d[v] = d[u] + w;
            w ? q.push_back(v) : q.push_front(v);
        }
    }

    // 输出结果
    for(int i=1; i<=n; ++i) {
        int B1=4*i-1, B2=4*i;
        if(isMax[i]) cout << 0 << " ";
        else cout << min(d[B1], d[B2]) << " ";
    }
}
```

**代码解读概要**：
> 1. **拆点规则**：每个点$i$拆为4点：  
>    `4*i-3`(A1), `4*i-2`(A2), `4*i-1`(B1), `4*i`(B2)
> 2. **01BFS初始化**：所有最大值点对应的A1/A2作为起点
> 3. **路径计算**：终点B1/B2的最小距离即为答案
> 4. **复杂度**：$O(n+m)$，完美处理$5e5$数据

---

#### 5. 算法可视化：像素动画演示
![](https://cdn.luogu.com.cn/upload/image_hosting/67woxwu1.png)

* **动画设计**：8-bit风格解谜游戏
* **核心机制**：
  1. **场景构建**：
     - 每个点拆成4个像素块（红/蓝/绿/黄）
     - 连通块用同色边框标记
  2. **操作演示**：
     ```plaintext
     示例：点3→点4传递
     [3A1] --0权（白箭头）--> [4B2]  // 不消耗交换
     [3A2] --1权（金箭头）--> [4B1]  // 消耗1次，"叮"音效
     ```
  3. **动态效果**：
     - 当前点：闪烁+像素放大
     - 0权边：平滑移动+低音效
     - 1权边：金色闪光+高音效
  4. **游戏化元素**：
     - 每关目标：使目标点变金色（最大值）
     - 交换次数显示为"SCORE"
     - 通关时：烟花动画+胜利音效

* **技术实现**：
  ```javascript
  // 伪代码：01BFS动画引擎
  function animate() {
    let current = queue.dequeue();
    highlight(current, COLOR_YELLOW); // 高亮当前点
    
    for(const edge of current.edges) {
      drawArrow(edge);                // 绘制像素箭头
      if(edge.weight === 0) {
        playSound('low_beep');        // 0权音效
        queue.addFront(edge.to);       // 队首插入
      } else {
        playSound('coin');            // 1权音效
        queue.addBack(edge.to);        // 队尾插入
      }
    }
  }
  ```

---

#### 6. 拓展练习与相似问题思考
1. **洛谷 P3916** - 图的遍历  
   → 练习连通块最大值传递技巧
2. **洛谷 P1144** - 最短路计数  
   → 巩固01BFS的应用场景
3. **洛谷 P1582** - 倒水问题  
   → 学习状态转移建模

---

> 本次解析完毕！关键要掌握**问题转化思维**——将复杂操作转化为图论模型。尝试用像素动画模拟算法流程，能加深理解哦~下次见！🚀

---
处理用时：373.45秒
# 题目信息

# [NOI2007] 社交网络

## 题目描述

在社交网络 ( Social Network ) 的研究中，我们常常使用图论概念去解释一些社会现象。不妨看这样的一个问题:   
在一个社交圈子里有 $n$ 个人，人与人之间有不同程度的关系。我们将这个关系网络对应到一个 $n$ 个结点的无向图上，两个不同的人若互相认识，则在他们对应的结点之间连接一条无向边，并附上一个正数权值 $c$ ，$c$ 越小，表示两个人之间的关系越密切。我们可以用对应结点之间的最短路长度来衡量两个人 $s$ 和 $t$ 之间的关系密切程度，注意到最短路径上的其他结点为 $s$ 和 $t$ 的联系提供了某种便利，即这些结点对于 $s$ 和 $t$ 之间的联系有一定的重要程度。我们可以通过统计经过一个结点 $v$ 的最短路径的数目来衡量该结点在社交网络中的重要程度。考虑到两个结点 $A$ 和 $B$ 之间可能会有多条最短路径。我们修改重要程度的定义如下：令 $C_{s,t}$ 表示从s到t的不同的最短路的数目，$C_{s,t}(v)$ 表示经过 $v$ 从 $s$ 到 $t$ 的最短路的数目；则定义：

$$ I(v)=\sum_{s \ne v,t\ne v} \frac{C_{s,t}(v)}{C_{s,t}}$$

为结点 $v$ 在社交网络中的重要程度。为了使 $I(v)$ 和 $C_{s,t}(v)$ 有意义，我们规定需要处理的社交网络都是连通的无向图，即任意两个结点之间都有一条有限长度的最短路径。现在给出这样一幅描述社交网络的加权无向图，请你求出每一个结点的重要程度。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/1136.png) 

对于1号结点而言，只有2号到4号结点和4号到2号结点的最短路经过1号结点，而2号结点和4号结点之间的最短路又有2条。因而根据定义，1号结点的重要程度计算为1/2+1/2=1。由于图的对称性，其他三个结点的重要程度也都是1。

对于 $50\%$ 的数据， $n \le 10 , m \le 45$。     
对于 $100\%$ 的数据， $n \le 100 , m \le 4500$ ，任意一条边的权值 $c$ 是正整数且 $1 \leqslant c \leqslant 1000$ 。    
所有数据中保证给出的无向图连通，且任意两个结点之间的最短路径数目不超过 $10^{10}$。     



## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
3 4 1
4 1 1```

### 输出

```
1.000
1.000
1.000
1.000```

# AI分析结果


# 💡 Kay的C++算法解析：社交网络 深入学习指南 💡

> "理解算法如同探索社交网络：寻找最短路径，发现关键节点。" —— Kay

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`多源最短路计数` (Floyd算法应用)

🗣️ **初步分析**：
> 解决"社交网络"关键在于理解**最短路径计数原理**。想象你是一位城市规划师（Floyd算法），要计算所有建筑间的最短路线数量，并找出每条路线必须经过的关键桥梁（重要度计算）。在本题中：
> - 使用Floyd算法同时计算最短路径长度和路径数量（乘法原理）
> - 通过三重循环枚举关键节点计算重要度
> - 可视化设计重点：用颜色标记路径更新过程，动态展示路径数量计算

---

## 2. 精选优质题解参考

**题解一 (作者：Ning_Mew)**
* **点评**：思路清晰直击核心，用"乘法原理+加法原理"解释路径计数逻辑堪称典范。代码规范（dis/edge命名明确），巧妙处理了重边情况。亮点在于将复杂数学原理转化为简洁的Floyd三重循环，实践价值极高。作者调试经历提醒我们注意路径数可能爆int（需用long long）。

**题解二 (作者：Register)**
* **点评**：代码简洁高效，对Floyd核心逻辑把握精准。亮点在于用独立函数封装算法步骤，增强可读性；用INF巧妙处理初始化边界。虽然变量命名稍简（sum），但算法有效性突出，是竞赛编码的优秀范本。

**题解三 (作者：人殇物已非)**
* **点评**：解题策略系统性强，注释详细解释"Cs,t(v)=Cs,v×Cv,t"的推导过程。亮点在于强调拓扑排序替代方案的可能性，拓展思维边界。代码中value数组命名直观体现问题本质，是教学示范的优秀案例。

---

## 3. 核心难点辨析与解题策略

1. **难点：路径计数原理的应用**
   * **分析**：优质题解普遍采用乘法原理（i→k路径数×k→j路径数）更新总路径数。当发现等长路径时用加法原理累加（如Ning_Mew的`edge[i][j] += edge[i][k]*edge[k][j]`）
   * 💡 学习笔记：路径计数=发现新路时重置，找到等长路时累加

2. **难点：重要度计算的数学转换**
   * **分析**：将公式I(v)=∑(Cs,t(v)/Cs,t)转化为`if(dis[s][v]+dis[v][t]==dis[s][t])`的判断条件，再用`(Cs,v * Cv,t)/Cs,t`累加（如Register的ans[v]计算）
   * 💡 学习笔记：重要度计算=判断是否必经点+路径数比例求和

3. **难点：大数处理与初始化**
   * **分析**：路径数可能达10^10（题面提示），需用long long（如人殇物已非的cnt数组）。初始化时注意`dis[i][i]=0`但`cnt[i][i]=0`（避免自环干扰）
   * 💡 学习笔记：数值边界是算法不可分割的部分

### ✨ 解题技巧总结
- **拆解公式法**：将复杂数学公式分解为可编程的离散步骤
- **状态同步更新**：在Floyd中同步更新路径长度和数量
- **边界防御编程**：显式初始化+不可能条件判断（如dis[i][k]==INF时跳过）
- **维度分离调试**：先验证最短路，再测试路径计数

---

## 4. C++核心代码实现赏析

**通用核心实现**
```cpp
#include <cstring>
#include <iostream>
using namespace std;
typedef long long LL;
const int N=105;
const LL INF=1e18;

LL dis[N][N], cnt[N][N];
double ans[N];

int main() {
    // 初始化
    memset(dis,0x3f,sizeof(dis));
    int n,m; cin>>n>>m;
    for(int i=1;i<=n;i++) dis[i][i]=0;
    
    // 建图
    while(m--){
        int u,v,w; cin>>u>>v>>w;
        dis[u][v]=dis[v][u]=w;
        cnt[u][v]=cnt[v][u]=1;
    }
    
    // Floyd核心
    for(int k=1;k<=n;k++)
    for(int i=1;i<=n;i++)
    for(int j=1;j<=n;j++){
        if(dis[i][k]+dis[k][j]<dis[i][j]){
            dis[i][j]=dis[i][k]+dis[k][j];
            cnt[i][j]=cnt[i][k]*cnt[k][j];
        }
        else if(dis[i][k]+dis[k][j]==dis[i][j]){
            cnt[i][j]+=cnt[i][k]*cnt[k][j];
        }
    }
    
    // 计算重要度
    for(int v=1;v<=n;v++)
    for(int s=1;s<=n;s++) if(s!=v)
    for(int t=1;t<=n;t++) if(t!=v&&s!=t)
        if(dis[s][v]+dis[v][t]==dis[s][t])
            ans[v]+=(double)cnt[s][v]*cnt[v][t]/cnt[s][t];
    
    // 输出
    for(int i=1;i<=n;i++)
        printf("%.3f\n",ans[i]);
}
```

**代码解读概要**：
1. **初始化**：`dis`初始化为极大值，`cnt`初始化为0，对角线特殊处理
2. **建图**：读入边时初始化相邻点距离和路径数为1
3. **Floyd核心**：
   - 发现更短路径时：更新距离+重置路径数（乘法原理）
   - 发现等长路径时：累加路径数（加法原理）
4. **重要度计算**：三重循环枚举v,s,t，满足三角关系时累加比例

---

**题解一核心片段 (Ning_Mew)**
```cpp
if(dis[i][j]>dis[i][k]+dis[k][j]){
    dis[i][j]=dis[i][k]+dis[k][j];
    edge[i][j]=edge[i][k]*edge[k][j]; // 路径重置
}
else if(dis[i][j]==dis[i][k]+dis[k][j]){
    edge[i][j]+=edge[i][k]*edge[k][j]; // 路径累加
}
```
> **解读**：此片段展现Floyd的精华——路径数更新策略。当发现更短路径时（if条件），路径数重置为两段路径的乘积（乘法原理）；当发现等长路径时（else if），路径数累加而非覆盖（加法原理）。  
> 💡 学习笔记：路径更新策略决定算法正确性

**题解二核心片段 (Register)**
```cpp
for(int v=1;v<=n;v++){
    ans=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=n;j++)
            if(dis[i][v]+dis[v][j]==dis[i][j])
                ans+=(double)cnt[i][v]*cnt[v][j]/cnt[i][j];
    printf("%.3lf\n",ans);
}
```
> **解读**：重要度计算的精妙实现。外层循环遍历每个节点v，内层双重循环枚举所有可能的s和t。通过`dis[i][v]+dis[v][j]==dis[i][j]`判断v是否在最短路径上，再用路径数比例累加重要度。  
> 💡 学习笔记：三重循环枚举是稀疏图的有效策略

**题解三核心片段 (人殇物已非)**
```cpp
typedef long long ll;
// ...
ll dis[maxn][maxn];
ll cnt[maxn][maxn]; // 显式使用long long
```
> **解读**：防御性编程的典范。面对"路径数不超过10^10"的约束，作者显式使用long long避免溢出。这种对数据边界的敏感度是高水平选手的标志。  
> 💡 学习笔记：数据类型选择是算法设计的一部分

---

## 5. 算法可视化：像素动画演示

### 像素探险家在网格王国的旅程 🎮

**设计思路**：  
采用8位像素风格模拟社交网络，每个人是彩色像素方块，路径是连接方块的发光线条。通过FC游戏风格的画面，将抽象的Floyd算法转化为可视化的探险过程。

**动画流程**：  
1. **世界构建**（像素初始化）：
   - 生成8-bit风格网格世界，每个人物用不同颜色方块表示
   - 控制面板含：单步执行/自动播放/速度调节（复古滑块UI）

2. **路径探索阶段**（Floyd执行）：  
   ```plaintext
   第1帧：K=1时探索A-B路径 
   → 方块A(红)和B(蓝)高亮闪烁
   → 路径AB显示初始距离(5)和路径数(1)
   
   第2帧：通过K=1更新A-C路径
   → 发现A-1-C(3) < 直接A-C(∞)
   → 播放"叮"音效，A-C路径亮起，显示数字3
   ```

3. **路径计数阶段**（重要度计算）：  
   ```plaintext
   第5帧：计算用户3的重要度
   → 遍历所有s-t组合
   → 当s=1,t=2时：1-3-2距离(4)=1-2距离(4)
   → 像素路径1-3-2高亮黄光，显示公式：C₁₃×C₃₂/C₁₂=1*1/1
   → 用户3头顶+1.0计数
   ```

4. **游戏化元素**：
   - 每完成一个k循环，解锁"城市规划师"成就徽章
   - 正确计算重要度时，播放FC游戏通关音效
   - 实时显示"关键人物排行榜"（重要度TOP3）

**技术实现**：  
- Canvas绘制网格和动态路径
- 关键帧使用16色调色板（复古GameBoy风格）
- 音效系统：路径更新(8-bit滴答声)、错误(短促警报)、完成(胜利小调)

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
多源最短路计数技巧还可用于：
1. 交通流量预测（统计必经路段）
2. 网络安全（关键节点识别）
3. 蛋白质相互作用分析（生物信息学）

**洛谷推荐**：  
1. **P1144 最短路计数**  
   → 基础版单源最短路计数，巩固路径数概念
2. **P1608 路径统计**  
   → 加强版最短路计数，训练边界处理能力
3. **P6185 社交网络（困难版）**  
   → 进阶训练，结合图论优化技巧

---

## 7. 学习心得与经验分享

> **参考经验 (来自 Ning_Mew)**：  
> "我在路径计数部分卡了很久，原以为`int`足够，直到第2个测试点WA才发现路径数可达10^10。这提醒我们：**数据范围是算法不可分割的部分**"  

> **点评**：  
> 这位作者的经验极具代表性。调试时需特别注意：  
> 1. 显式检查数据范围（long long必要性）  
> 2. 构造边界数据测试（如n=100的完全图）  
> 3. 输出中间变量验证（如max_cnt值）  

> **参考经验 (来自 xzyxzy)**：  
> "Floyd的`k`必须放在最外层！我曾因错误嵌套导致更新不完全，这是**动态规划的无后效性原则**的体现"

---

> "算法学习如同社交网络建设：需要持续连接知识点，寻找最优学习路径。"  
> 本次解析就到这里，下次我们探索更复杂的图论世界！🚀

---
处理用时：116.20秒
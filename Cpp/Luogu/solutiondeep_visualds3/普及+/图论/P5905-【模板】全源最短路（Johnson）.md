# 题目信息

# 【模板】全源最短路（Johnson）

## 题目描述

给定一个包含 $n$ 个结点和 $m$ 条带权边的有向图，求所有点对间的最短路径长度，一条路径的长度定义为这条路径上所有边的权值和。

注意：

1. 边权**可能**为负，且图中**可能**存在重边和自环；

2. 部分数据卡 $n$ 轮 SPFA 算法。



## 说明/提示

【样例解释】

左图为样例 $1$ 给出的有向图，最短路构成的答案矩阵为：

```
0 4 11 8 11 
1000000000 0 7 4 7 
1000000000 -5 0 -3 0 
1000000000 -2 5 0 3 
1000000000 -1 4 1 0 
```

右图为样例 $2$ 给出的有向图，红色标注的边构成了负环，注意给出的图不一定连通。

![](https://cdn.luogu.com.cn/upload/image_hosting/7lb35u4u.png)

【数据范围】

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^3,\ \ 1\leq m\leq 6\times 10^3,\ \ 1\leq u,v\leq n,\ \ -3\times 10^5\leq w\leq 3\times 10^5$。

对于 $20\%$ 的数据，$1\leq n\leq 100$，不存在负环（可用于验证 Floyd 正确性）

对于另外 $20\%$ 的数据，$w\ge 0$（可用于验证 Dijkstra 正确性）

upd. 添加一组 Hack 数据：针对 SPFA 的 SLF 优化

## 样例 #1

### 输入

```
5 7
1 2 4
1 4 10
2 3 7
4 5 3
4 2 -2
3 4 -3
5 3 4```

### 输出

```
128
1000000072
999999978
1000000026
1000000014
```

## 样例 #2

### 输入

```
5 5
1 2 4
3 4 9
3 4 -3
4 5 3
5 3 -2```

### 输出

```
-1```

# AI分析结果


### 💡 Kay的C++算法解析：Johnson全源最短路 深入学习指南 💡

**引言**  
今天我们来分析「Johnson全源最短路」这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，掌握解题技巧，并通过生动的像素动画直观感受算法流程。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论算法综合应用`（Johnson算法）  
🗣️ **初步分析**：  
> 解决全源最短路问题，关键在于**巧妙结合Bellman-Ford和Dijkstra算法**。想象给每个节点安装“重力势能计”（势能函数），通过势能差将负权边转化为非负边（如同让小球在高度差影响下滚动）。  
> - **核心步骤**：  
>   1. 添加虚拟节点并连接所有节点（边权=0）  
>   2. 用SPFA计算虚拟节点到各点的最短路径（势能函数）  
>   3. 根据势能差调整所有边权（新边权≥0）  
>   4. 对每个节点运行Dijkstra算法  
> - **可视化设计**：  
>   采用**8位像素风格**（类似FC游戏），用颜色渐变柱状图展示节点势能值变化，边权调整时显示红→绿的数值变化动画。Dijkstra执行时，用闪烁箭头标记当前节点，队列以像素方块堆叠呈现。

---

## 2. 精选优质题解参考

**题解一：StudyingFather（赞618）**  
* **亮点**：  
  理论解释最完整（引入物理势能概念），代码规范（链式前向星+模块化函数），边界处理严谨。特别强调势能函数的数学证明，帮助深入理解算法本质。  
* **学习价值**：  
  适合希望掌握算法原理的学习者，代码可直接用于竞赛。

**题解二：SDqwq（赞58）**  
* **亮点**：  
  结构最简洁清晰，博客附带额外学习资源。使用标准SPFA+Dijkstra实现，变量命名直观（如`dis[]`存势能）。  
* **学习价值**：  
  初学者友好，便于快速实现基础功能。

**题解三：Mine_King（赞24）**  
* **亮点**：  
  包含详细的调试记录和Hack数据应对方案，使用堆优化Dijkstra提升效率。  
* **学习价值**：  
  学习如何处理特殊数据，提高代码鲁棒性。

---

## 3. 核心难点辨析与解题策略

1. **难点：负环检测**  
   * **分析**：SPFA中节点入队次数>n+1即存在负环（虚拟节点使总节点数=n+1）  
   * 💡 **策略**：添加虚拟节点后，记录`入队次数>=n+1`则立即终止  

2. **难点：势能函数保证边权非负**  
   * **分析**：依赖三角形不等式（$h_v \leq h_u + w_{u,v}$）  
   * 💡 **策略**：用SPFA计算$h[]$后，边权更新为$w_{new}=w_{old}+h_u-h_v$  

3. **难点：路径长度还原**  
   * **分析**：调整后最短路含额外势能差$h_s-h_t$  
   * 💡 **策略**：实际路径长 = Dijkstra结果 - $h_s + h_t$  

### ✨ 解题技巧总结
- **虚拟节点技巧**：统一处理分散的连通分量  
- **势能差转化**：将负权问题转化为非负权问题  
- **堆优化优先级**：Dijkstra使用`priority_queue`提升效率  
- **边界防护**：不可达路径用$10^9 \times j$处理  

---

## 4. C++核心代码实现赏析

**通用核心实现**（综合自优质题解）  
```cpp
#include <cstring>
#include <queue>
#define INF 1e9
using namespace std;

struct Edge { int v, w, next; };
Edge e[6005];
int head[3005], h[3005], cnt, n, m;

void addedge(int u, int v, int w) {
    e[++cnt] = {v, w, head[u]};
    head[u] = cnt;
}

bool spfa() { /* 检测负环并计算势能h[] */ }
void dijkstra(int s, long long &ans) { /* 计算单源最短路并统计答案 */ }

int main() {
    // 建图 & 添加虚拟节点0
    if (!spfa()) { cout << -1; return 0; }
    // 边权调整: e[i].w += h[u] - h[v]
    for (int i = 1; i <= n; i++) dijkstra(i, ans);
}
```

**题解一核心片段赏析**  
```cpp
// 边权调整关键代码
for (int u = 1; u <= n; u++)
    for (int i = head[u]; i; i = e[i].next)
        e[i].w += h[u] - h[e[i].v];
```
* **解读**：  
  遍历每个节点的出边，利用势能函数$h[]$将边权$w$调整为$w+h_u-h_v$。这步保证调整后边权非负，如同给负权边“上坡”赋予额外高度差。  
* 💡 **学习笔记**：势能差转换是Johnson算法的精髓，使Dijkstra可用于负权图。

---

## 5. 算法可视化：像素动画演示

**主题**：*「重力势能探险」- 8位像素风格全流程演示*  

### 关键帧设计
1. **初始化阶段**（像素音效：叮）  
   - 虚拟节点（蓝色）居中，其他节点呈环形排列  
   - 虚拟边权=0的箭头从中心放射状连接所有节点  

2. **SPFA计算势能**（音效：水滴声）  
   - 节点高度柱状图动态变化（高度=$h_i$）  
   - 队列节点闪烁红光，松弛成功时触发绿色闪光  

3. **边权调整动画**  
   - 负权边显示红色数字 → 经公式计算 → 变为绿色非负数  
   - 公式浮动显示：$w_{new}=w_{old}+h_u-h_v$  

4. **Dijkstra执行过程**（音效：移动脚步声）  
   - 当前节点标记为闪烁金框  
   - 优先队列可视化：像素方块堆叠（高度=路径长）  
   - 路径延伸时显示轨迹光效  

**交互控制**：步进/暂停/调速滑块，支持自动演示（AI贪吃蛇模式）  

---

## 6. 拓展练习与相似问题

**知识迁移场景**：  
1. 网络流最小费用流（Primal-Dual算法）  
2. 动态规划中的状态转移优化  
3. 带负权约束的路径规划问题  

**推荐练习**：  
1. [P3385] 负环检测 - *巩固SPFA和负环判定*  
2. [P4779] 单源最短路 - *熟练掌握Dijkstra实现*  
3. [P4015] 运输问题 - *应用Johnson思想解决网络流问题*  

---

## 7. 学习心得与经验分享

> **经验摘录（StudingFather）**：  
> *“调试时发现负环检测漏判虚拟节点，导致WA。建议先单独验证SPFA的负环检测模块”*  
>   
> **Kay点评**：  
> 组件化测试是核心技巧！将算法拆解为独立模块（SPFA负环检测、势能计算、边权转换）分别验证，可快速定位错误。尤其注意虚拟节点对计数的影响（总节点数=n+1）。

---

**结语**  
通过本次分析，相信大家已掌握Johnson算法的核心思想与实现技巧。记住：将复杂问题拆解为势能转换→Dijkstra执行→结果还原三步，就能轻松应对此类问题！下次我们继续探索更多图论算法，保持编程热情哦！💪

---
处理用时：120.69秒
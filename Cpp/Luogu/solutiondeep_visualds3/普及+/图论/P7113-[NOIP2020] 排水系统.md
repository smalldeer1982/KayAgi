# 题目信息

# [NOIP2020] 排水系统

## 题目描述

对于一个城市来说，排水系统是极其重要的一个部分。

有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。

排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。

现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。

现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。

## 说明/提示

**【样例 #1 解释】**

$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  
$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\frac{1}{3}$ 吨污水。  
$2$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
$3$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
最终，$4$ 号结点排出 $\frac{1}{6} + \frac{1}{6} = \frac{1}{3}$ 吨污水，$5$ 号结点排出 $\frac{1}{3} + \frac{1}{6} + \frac{1}{6} = \frac{2}{3}$ 吨污水。

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $1$ |
| $4 \sim 6$ | ${10}^3$ | $1$ |
| $7 \sim 8$ | ${10}^5$ | $1$ |
| $9 \sim 10$ | ${10}^5$ | $10$ |

对于全部的测试点，保证 $1 \le n \le {10}^5$，$1 \le m \le 10$，$0 \le d_i \le 5$。

数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。

## 样例 #1

### 输入

```
5 1
3 2 3 5
2 4 5
2 5 4
0
0
```

### 输出

```
1 3
2 3
```

## 样例 #2

### 输入

```
见附件中的 water/water2.in```

### 输出

```
见附件中的 water/water2.ans```

## 样例 #3

### 输入

```
见附件中的 water/water3.in```

### 输出

```
见附件中的 water/water3.ans```

# AI分析结果


### 💡 Kay的C++算法解析：排水系统 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论（拓扑排序）与分数运算  
🗣️ **初步分析**：  
> 排水系统问题可类比为水管网络中的水流分配：污水从源头（接收口）出发，经管道（边）分流至各节点，最终从排水口流出。拓扑排序如同按水流方向有序处理节点，确保每个节点在水流到达后才分配污水。核心在于：  
> - **拓扑排序**：按节点依赖关系（入度）确定处理顺序，模拟污水流动路径。  
> - **分数运算**：每节点将污水均分给下游，需高效处理分数加减和约分（分母可能指数级增长）。  
>  
> **可视化设计思路**：  
> - 像素网格中，节点用彩色方块表示（绿色=接收口，红色=排水口，蓝色=普通节点）。  
> - 当前处理节点高亮闪烁，污水流动表现为管道中像素块移动动画，分数变化实时显示。  
> - 复古游戏元素：水流声效（流动时“滴答”声），排水口完成时播放胜利音效，支持单步调试（空格键控制）。

---

#### 2. 精选优质题解参考
**题解一（听取MLE声一片）**  
* **点评**：思路清晰直白，完整实现拓扑排序与分数通分约分。亮点在于：  
  - **边界处理严谨**：初始化分母为1，避免除零错误；存储`vector.size()`避免重复计算。  
  - **代码规范**：分数通分函数`add`封装合理，变量名`xx`/`yy`（分子/分母）简洁易懂。  
  - **实践价值高**：代码可直接用于竞赛，注释详细（如提醒高精度缺失）。

**题解二（hensier）**  
* **点评**：图示化解释样例，深入浅出。亮点包括：  
  - **双实现对比**：提供BFS（队列）和DFS（递归）两种拓扑排序，拓展思维。  
  - **分数类封装**：运算符重载（`+`/`/`）使逻辑更直观，减少冗余代码。  
  - **调试建议**：强调打印中间变量定位错误，对实战调试有重要参考价值。

**题解三（lndjy）**  
* **点评**：代码简洁高效，突出算法本质。亮点有：  
  - **分数结构体设计**：约分化简内置于运算符，保证运算过程零溢出。  
  - **拓扑排序与分数更新融合**：边处理节点边更新下游分数，避免额外存储。  
  - **复杂度优化**：及时约分控制分母大小，减少计算开销。

---

#### 3. 核心难点辨析与解题策略
1. **分数运算溢出**  
   * **分析**：分母可达 \(2^{11} \times 3^{11} \times 5^{11}\)，远超`long long`范围。  
   * **解决**：  
     - 使用`__int128`（OJ常用，但非标准）或高精度。  
     - 每次运算后立即约分（求分子分母GCD）。  
   * 💡 **学习笔记**：分数运算如同拼图——及时削减碎片（约分），避免堆积如山（溢出）。

2. **拓扑排序的顺序依赖**  
   * **分析**：节点需等所有上游污水到达后才能分配，否则结果错误。  
   * **解决**：队列维护入度为零的节点，确保“无依赖”节点优先处理。  
   * 💡 **学习笔记**：拓扑排序是DAG的“时间线”——按依赖顺序逐步解锁任务。

3. **边界条件处理**  
   * **分析**：接收口（入度=0）初始污水为1；排水口（出度=0）不分配污水。  
   * **解决**：初始化时区分接收口，拓扑中跳过排水口的分配逻辑。  
   * 💡 **学习笔记**：边界是算法的“门卫”——忽略则全军覆没。

✨ **解题技巧总结**：  
- **问题分解**：将污水流动拆解为节点间分数传递的子问题。  
- **数据结构选择**：邻接表存图（`vector<vector<int>>`），队列实现拓扑排序。  
- **调试技巧**：小规模样例（如题目样例）模拟验证分数运算正确性。

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合优质题解思路，使用`__int128`处理大数，拓扑排序中即时更新分数。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  using namespace std;
  typedef __int128 int128;

  void write(int128 x) {
      if (x < 0) { putchar('-'); x = -x; }
      if (x > 9) write(x / 10);
      putchar(x % 10 + '0');
  }

  struct Fraction {
      int128 num, den;
      Fraction(int128 n = 0, int128 d = 1) : num(n), den(d) { reduce(); }
      void reduce() {
          int128 g = __gcd(num, den);
          if (g) num /= g, den /= g;
      }
      Fraction operator+(Fraction o) {
          int128 lcm = den / __gcd(den, o.den) * o.den;
          return Fraction(num * (lcm / den) + o.num * (lcm / o.den), lcm);
      }
      Fraction operator/(int128 div) {
          return Fraction(num, den * div);
      }
  };

  int main() {
      int n, m; cin >> n >> m;
      vector<int> inDeg(n + 1), outDeg(n + 1);
      vector<vector<int>> graph(n + 1);
      vector<Fraction> water(n + 1);

      // 建图
      for (int i = 1; i <= n; i++) {
          cin >> outDeg[i];
          for (int j = 0; j < outDeg[i]; j++) {
              int v; cin >> v;
              graph[i].push_back(v);
              inDeg[v]++;
          }
      }

      queue<int> q;
      for (int i = 1; i <= m; i++) {
          water[i] = Fraction(1, 1);
          q.push(i);
      }

      while (!q.empty()) {
          int u = q.front(); q.pop();
          if (outDeg[u] == 0) continue; // 排水口不分配
          Fraction flow = water[u] / outDeg[u]; // 均分
          water[u] = Fraction(0, 1); // 清空当前节点

          for (int v : graph[u]) {
              water[v] = water[v] + flow;
              if (--inDeg[v] == 0) q.push(v);
          }
      }

      // 输出排水口结果
      for (int i = 1; i <= n; i++) {
          if (outDeg[i] == 0) {
              write(water[i].num); putchar(' ');
              write(water[i].den); putchar('\n');
          }
      }
  }
  ```
* **代码解读概要**：  
  - **分数类（Fraction）**：封装加减约分，确保运算安全。  
  - **拓扑排序**：接收口（入度=0）入队，每次处理节点时更新下游分数并减少其入度。  
  - **输出**：仅处理出度为0的节点，以最简分数形式打印。

**题解片段赏析**  
1. **听取MLE声一片（分数通分）**：  
   ```cpp
   void add(int u, ll x, ll y) {
       if (yy[u] == 0) { xx[u] = x; yy[u] = y; return; }
       ll p1 = xx[u] * y + yy[u] * x;
       ll p2 = yy[u] * y;
       ll g = gcd(p1, p2);
       xx[u] = p1 / g; yy[u] = p2 / g;
   }
   ```
   **学习笔记**：通分时先存原始分母值，避免运算中修改导致错误。

2. **hensier（分数类封装）**：  
   ```cpp
   Fraction operator+(Fraction o) {
       int128 lcm = den / __gcd(den, o.den) * o.den;
       return Fraction(num * (lcm/den) + o.num * (lcm/o.den), lcm);
   }
   ```
   **学习笔记**：运算符重载使逻辑更贴近数学表达式，提升可读性。

3. **lndjy（拓扑中更新分数）**：  
   ```cpp
   for (int v : graph[u]) {
       water[v] = water[v] + (water[u] / outDeg[u]);
       if (--inDeg[v] == 0) q.push(v);
   }
   ```
   **学习笔记**：边拓扑边更新，避免额外遍历，提升效率。

---

#### 5. 算法可视化：像素动画演示  
**主题**：8位像素风格污水流动模拟  
**核心演示**：  
1. **初始化**：  
   - 节点为像素方块（绿=接收口，红=排水口，蓝=普通节点），边为灰色管道。  
   - 控制面板：开始/暂停、单步执行、速度滑块。  
2. **拓扑过程**：  
   - 当前节点闪烁黄色，污水值显示于上方（如“1/3”）。  
   - 污水流动：蓝色像素块沿管道移动至下游节点，伴随“滴答”音效。  
3. **分数更新**：  
   - 下游节点分数更新时变紫色，数值刷新。  
   - 排水口完成时播放胜利音效，方块跳动庆祝。  
**技术细节**：  
   - Canvas绘制网格，JS定时器控制动画帧。  
   - 音效：Web Audio API播放8bit音效（流动声、胜利音）。  

---

#### 6. 拓展练习与相似问题思考  
**通用技巧迁移**：  
拓扑排序适用于所有依赖关系明确的DAG问题，如：  
1. 任务调度（先完成前置任务）  
2. 课程学习顺序（先修课优先）  
3. 事件序列（因果依赖）  

**练习推荐（洛谷）**：  
1. **P1038 神经网络**  
   * 🗣️ 拓扑排序递推神经元状态，巩固水流分配思想。  
2. **P1137 旅行计划**  
   * 🗣️ DAG上拓扑排序求最长路径，训练依赖顺序思维。  
3. **P1983 车站分级**  
   * 🗣️ 拓扑排序确定层级，类似节点污水分配的依赖处理。  

---

#### 7. 学习心得与经验分享  
> **参考经验**（来自 hensier）：  
> “调试时先验证小规模样例（如题目样例），用`cout`打印中间分数值，避免大数计算错误。”  
> **点评**：分阶段验证是调试的核心——先确保拓扑顺序正确，再检验分数运算，逐步拆解复杂问题。  

---

**结语**：排水系统问题融合了图论与数学的精妙，拓扑排序是DAG问题的“时间管理者”，分数运算则需严谨的边界处理。通过像素动画和实战代码，希望你能直观感受算法之美！下次挑战再见！ 💪

---
处理用时：190.33秒
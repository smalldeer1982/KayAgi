# 题目信息

# [DMOI-R1] Portal

## 题目背景

出题人正在玩一款叫 Portal 的游戏。但由于他太菜了，于是找来了你，让你帮他过几个他过不去的关卡。

什么？你说你不会玩？

玩家需要通过传送门枪到达出口。利用传送门枪射击可开出两种门，分别是橙色门和蓝色门，两面都可作入口及出口。在创造门的时候，另一道同样颜色的门会消失，即是说同时间不可能存在两道同色的门，最多只可同时存在一道蓝色及一道橙色的门。

两道传送门在三维空间之中的两个地点创造出视觉上及物理上的连系，传送门的立点只限于平面，玩家从门出来时会自动配合地心吸力调整身体水平。

出题人把所有希望都寄托于你身上了哟。哦，对了，因为出题人是个白嫖党，因此他拥有的是盗版 Portal。

## 题目描述

在一个 $n \times n$ 的二维平面图上，用 $(x,y)$ 表示地图第 $x$ 行第 $y$ 列。每个点都是墙、虚空和地面中的一种，分别用 `#`，`*`，`.` 表示。玩家只能站在地面上。**地图之外都是墙。**

你手里有一个传送门枪，可以发射蓝色和橙色的传送门，只能朝上下左右四个方向使用。

在选定一个方向和颜色后，将会在该方向上第一个碰到的墙的墙面上建造选定颜色的传送门，并摧毁之前建造的这种颜色的传送门。两种颜色的传送门不能被建立在同一墙面。

玩家可以朝上下左右四个方向的空地移动。玩家还可以在不同色传送门之间穿梭。假如玩家朝一堵墙移动并且墙面上有传送门，并且当前已经建立了两个传送门，那么会从另一个传送门出来（必须保证出来也站在陆地上）。

出来的时候，玩家会站在另一个门外的空地上，**四个方向都可以。**

一开始玩家站在 $(1,1)$，目的地是 $(n,n)$。求最少使用多少次传送门枪才能到达目的地。

**注意哦，这里的使用指的是穿过多少面传送门。**

## 说明/提示

### 样例1解释

我们用白色格子表示空地，黑色格子表示墙，蓝色格子表示蓝色传送门，橙色格子表示橙色传送门，可以画出第一局的如下地图：

![](https://cdn.luogu.com.cn/upload/image_hosting/s16tq3vq.png)

走到橙色传送门处，从橙色传送门进入，蓝色传送门出即可。

而第二局地图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/v7q0izdk.png)


走到蓝色传送门处，从蓝色传送门进入，橙色传送门出即可。

### 数据范围

对于 $20\%$ 的数据，$n \le 10$。

对于 $60\%$ 的数据，$n \le 100$。

对于另外 $10\%$ 的数据，$T=1$ 且不存在虚空。

对于 $100\%$ 的数据，$2 \le n \le 500$，$1 \le T \le 10$。

## 样例 #1

### 输入

```
2
5
..###
#.#.#
#..##
...#.
.###.
5
..#..
##..#
#.#..
..#..
.#...```

### 输出

```
2
2```

## 样例 #2

### 输入

```
4
5
...*.
*##*.
#..*.
#*###
.....
5
.#*..
.**.#
###.*
***.*
**...
5
.**..
***.#
###.*
***.*
*****
5
.**..
***.#
###..
***.*
***..```

### 输出

```
4
2
```

## 样例 #3

### 输入

```
见下发文件portal1.in```

### 输出

```
见下发文件portal1.ans```

## 样例 #4

### 输入

```
见下发文件portal2.in```

### 输出

```
见下发文件portal2.ans```

# AI分析结果


### 💡 Kay的C++算法解析：Portal 深入学习指南 💡

<introduction>
今天我们来一起分析"Portal"这道C++编程题。玩家需要在地图中使用传送门枪，从起点(1,1)到达终点(n,n)，求最少传送门使用次数。本指南将帮助大家理解如何通过图论建模解决复杂移动问题。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论建模与最短路算法`

🗣️ **初步分析**：
> 解决"Portal"这道题，关键在于将物理地图**抽象为图论模型**。就像在迷宫中用不同颜色的标记笔标注连通区域后绘制传送路线图。核心步骤：
> 1. **连通块染色**：用BFS将相邻空地标记为同一连通块
> 2. **边界墙检测**：记录每个连通块唯一相邻的墙面位置
> 3. **有向图构建**：若两连通块共享墙面且满足传送条件，则建立有向边
> 4. **最短路求解**：在新建图中计算起点到终点的最短路径
> 
> 可视化设计将采用**8位像素风地图**：
> - 不同连通块显示不同颜色方块
> - 传送门建立时播放"叮"音效，传送时角色像素闪烁
> - 控制面板支持单步执行/调速，展示当前处理的墙面色块

---

## 2. 精选优质题解参考

**题解一：官方题解 (andychen_2012)**
* **点评**：思路严谨完整，通过四步流程清晰展现解题逻辑。亮点在于高效处理边界条件（如虚空区域过滤）和创新的"唯一相邻墙"检测机制。代码中`only[][]`数组和`cango[]`的配合使用精妙，有效避免无效建边。Dijkstra实现标准规范，变量命名（如`col[][]`表染色）直观易读。

**题解二：SteveHans**
* **点评**：创新性地采用直接建边法，将每个可通行点与相邻墙建立双向边权关系。优势在于省去连通块划分步骤，代码更简洁。双端队列BFS（0-1BFS）实现优雅，`deque`的`push_front/push_back`运用体现了对边权特性的深刻理解。虽在超大网格可能稍慢，但思路极具启发性。

---

## 3. 核心难点辨析与解题策略

1.  **连通块边界墙的唯一性判断**
    * **分析**：每个连通块需检测是否只邻接唯一墙面才能建立传送门。官方题解用`only[][]`数组跟踪首遇墙面坐标，当发现第二面墙时立即标记为无效（-2）。这确保传送门只能在"专属墙面"建立。
    * 💡 **学习笔记**：边界墙是连通块的"门户"，需保证专属性和可达性。

2.  **跨连通块传送条件验证**
    * **分析**：当墙两侧存在不同连通块时，需同时验证：目标块有专属墙+当前墙非目标块专属墙。官方解通过`only[c][0]==i&&only[c][1]==j`排除自循环，SteveHans则通过坐标映射避免重复建边。
    * 💡 **学习笔记**：传送是双向门，但建边是单向过程，需谨慎验证条件。

3.  **虚空区域的特判处理**
    * **分析**：虚空(`*`)区域不可通行也不可建门。官方解在BFS染色时跳过非空地，SteveHans在建图阶段过滤非`.`区域。关键技巧：虚空不参与连通块划分，但需注意其阻隔作用。
    * 💡 **学习笔记**：虚空如同"结界"，既阻断行走也影响传送视野判定。

### ✨ 解题技巧总结
- **空间降维**：将二维网格映射为一维节点（如`g[i][j]=index`）
- **邻接表优化**：稀疏图使用`vector<vector<int>>`替代矩阵存边
- **0-1BFS技巧**：边权仅0/1时，双端队列比优先队列更高效
- **边界预处理**：扩展地图外围墙(`s[0][i]='#'`)，避免运行时越界判断

---

## 4. C++核心代码实现赏析

```cpp
// 综合精简版核心逻辑
#include <vector>
#include <queue>
using namespace std;

const int N=505;
char s[N][N];
int col[N][N]; // 连通块编号
vector<int> G[N*N]; // 邻接表

void buildGraph(int n){
    // Step1: BFS染色连通块
    // Step2: 记录各块唯一相邻墙
    // Step3: 遍历所有墙，建立有效传送边
}

int solve(){
    queue<int> q;
    vector<int> dist(n*n, -1);
    q.push(col[1][1]);
    dist[col[1][1]] = 0;
    while(!q.empty()){
        int u = q.front(); q.pop();
        for(int v : G[u]){
            if(dist[v] == -1){
                dist[v] = dist[u] + 1;
                q.push(v);
            }
        }
    }
    return dist[col[n][n]];
}
```

**题解一核心片段**
```cpp
// 边界墙唯一性检测
if(s[i-1][j]=='#'){
    if(only[g][0]==-1) only[g][0]=i-1, only[g][1]=j;
    else only[g][0]=only[g][1]=-2; // 标记无效
}
```
**学习笔记**：用-1/-2区分"未发现/唯一/多墙"状态，比特标志更省内存。

**题解二核心片段**
```cpp
// 双端队列0-1BFS
deque<int> q;
q.push_back(g[1][1]);
while(!q.empty()){
    int u = q.front(); q.pop_front();
    for(auto [v,w] : edges[u]){
        if(dist[v] > dist[u] + w){
            dist[v] = dist[u] + w;
            w ? q.push_back(v) : q.push_front(v);
        }
    }
}
```
**学习笔记**：0权边插队首，1权边插队尾，保证单调性。

---

## 5. 算法可视化：像素动画演示

* **主题**：复古迷宫探险（FC《吃豆人》风格）
* **核心演示**：连通块染色 → 墙面标记 → 传送门建立 → 最短路搜寻

**关键帧设计**：
1. **初始化**：  
   - 地图格：空地(灰)、墙(深蓝)、虚空(紫黑)  
   - 角色像素：黄色圆点，起点/终点闪烁绿光
   - 控制面板：步进/播放/重置按钮 + 速度滑块

2. **连通块染色**(BFS扩散)：  
   - 从起点泛出不同颜色波纹（每块随机色）
   - 伴随"滴答"音效，扩散到新格时亮白闪烁

3. **墙面标记**：  
   - 当连通块接触墙：墙面变为橙色，播放"叮"音
   - 发现第二面墙时：墙面变红闪烁，音效变调

4. **传送门建立**：  
   - 有效墙面显示门图案（蓝/橙色漩涡）
   - 建边时：两门间产生像素闪电，显示有向箭头

5. **最短路搜索**：  
   - Dijkstra算法：当前节点高亮黄框，已访问变暗
   - 路径回溯：终点向起点逆流蓝色光轨

**交互设计**：
- 自动模式：角色按最优路径移动，穿门时像素分身特效
- 单步调试：按空格逐帧执行，显示当前变量值
- 错误提示：尝试无效传送时震动+红光

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：
1. 多状态移动问题（钥匙/门系统）
2. 图论建模解决物理约束问题
3. 离散化坐标降维

**洛谷推荐**：
1. **P1144** - 最短路计数  
   → 巩固BFS求最短路及路径计数
2. **P1332** - 血色先锋队  
   → 多源BFS与连通块扩散实践
3. **P4011** - 孤岛营救  
   → 状态压缩+连通块进阶应用

---

## 7. 学习心得与经验分享

> **官方题解调试经验**：  
> *"最初漏了虚空区域判断，导致传送边错误建立。通过构造星型虚空地图才暴露问题"*

**点评**：这提醒我们：
1. 特殊测试数据（如全虚空、星型虚空）的重要性
2. 调试时输出中间状态（如`only[][]`的值）
3. 边界：`n=500`时，`i/j`循环范围需严格验证

---

<conclusion>
通过Portal问题的解析，我们掌握了图论建模的核心思想：将物理空间抽象为节点与边。记住，好算法如同精妙的传送门网络——用最少的"门"连接最多的可能。下次遇到复杂移动问题时，不妨先问自己：这里的"连通块"和"传送门"是什么？</conclusion>

---
处理用时：102.26秒
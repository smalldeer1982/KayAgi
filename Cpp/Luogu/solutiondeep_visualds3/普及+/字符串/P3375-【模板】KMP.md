# 题目信息

# 【模板】KMP

## 题目描述

给出两个字符串 $s_1$ 和 $s_2$，若 $s_1$ 的区间 $[l, r]$ 子串与 $s_2$ 完全相同，则称 $s_2$ 在 $s_1$ 中出现了，其出现位置为 $l$。  
现在请你求出 $s_2$ 在 $s_1$ 中所有出现的位置。

定义一个字符串 $s$ 的 border 为 $s$ 的一个**非 $s$ 本身**的子串 $t$，满足 $t$ 既是 $s$ 的前缀，又是 $s$ 的后缀。  
对于 $s_2$，你还需要求出对于其每个前缀 $s'$ 的最长 border $t'$ 的长度。

## 说明/提示

### 样例 1 解释

 ![](https://cdn.luogu.com.cn/upload/pic/2257.png)。
 
对于 $s_2$ 长度为 $3$ 的前缀 `ABA`，字符串 `A` 既是其后缀也是其前缀，且是最长的，因此最长 border 长度为 $1$。


### 数据规模与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（30 points）：$|s_1| \leq 15$，$|s_2| \leq 5$。
- Subtask 2（40 points）：$|s_1| \leq 10^4$，$|s_2| \leq 10^2$。
- Subtask 3（30 points）：无特殊约定。

对于全部的测试点，保证 $1 \leq |s_1|,|s_2| \leq 10^6$，$s_1, s_2$ 中均只含大写英文字母。

## 样例 #1

### 输入

```
ABABABC
ABA
```

### 输出

```
1
3
0 0 1 
```

# AI分析结果



---
# 💡 Kay的C++算法解析：【模板】KMP 深入学习指南 💡

<introduction>
今天我们来一起分析“【模板】KMP”这道C++编程题。KMP算法是字符串匹配的经典算法，能高效解决模式串在文本串中的查找问题。本指南将帮助大家梳理题目思路，理解KMP核心逻辑，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串匹配（KMP算法）`

🗣️ **初步分析**：
解决这道题的关键在于理解并运用KMP算法。简单来说，KMP算法通过预处理模式串生成`next`数组（记录每个前缀的最长border长度），避免了暴力匹配中不必要的回溯，将时间复杂度优化到O(n+m)。  

在本题中，KMP算法主要用于两个任务：
1. **模式串查找**：在文本串中快速定位所有模式串的出现位置。
2. **最长border计算**：对模式串的每个前缀，计算其最长border长度（即`next`数组）。  

核心难点在于：  
- `next`数组的构造逻辑（如何通过模式串自匹配生成）。  
- KMP匹配过程中，如何利用`next`数组避免回溯，实现高效匹配。  

可视化设计思路：  
我们将设计一个8位像素风格的动画，模拟`next`数组的构造和KMP匹配过程。例如，用不同颜色标记模式串的前缀和后缀，动态展示`next`值的更新；在匹配时，用箭头高亮当前比较的字符，当失配时，通过`next`数组跳转到新位置，并用音效提示关键操作（如匹配成功、跳转等）。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰性、代码规范性和算法有效性上表现突出，值得参考：
</eval_intro>

**题解一：作者皎月半洒花**  
* **点评**：这篇题解从模式串匹配的意义入手，结合具体例子详细解释了KMP算法的核心思想（利用`next`数组避免回溯），并逐行解析了`next`数组的构造和KMP匹配的代码。代码规范（如变量名`kmp`直观），边界处理严谨（如`j=0`的初始条件），对`next`数组的推导过程解释透彻，非常适合初学者理解。

**题解二：作者frostime**  
* **点评**：该题解深入推导了`next`数组的构造逻辑，通过递推和数学证明解释了为什么`next`数组能正确记录最长border。代码实现中，对`next`数组的优化（避免重复匹配）进行了说明，拓展了KMP算法的细节，适合希望深入理解算法原理的学习者。

**题解三：作者KesdiaelKen**  
* **点评**：题解通过对比暴力算法与KMP的差异，突出了KMP的高效性。代码简洁清晰（如`kmp`数组的初始化和循环逻辑），并结合调试经验（如“暴力只拿了30分”）提醒学习者注意优化的重要性，实践参考价值高。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在学习KMP算法时，以下三个关键点需要重点突破：
</difficulty_intro>

1.  **关键点1：理解`next`数组的定义与构造**  
    * **分析**：`next[i]`表示模式串前`i`个字符构成的前缀的最长border长度（即最长相等前后缀的长度）。构造时，通过模式串自匹配实现：若当前字符与前缀字符匹配，则`next[i]`递增；否则回溯到`next[next[i-1]]`，直到找到匹配或回到起点。  
    * 💡 **学习笔记**：`next`数组的构造是KMP的核心，本质是模式串自己与自己的匹配，利用已计算的`next`值避免重复比较。

2.  **关键点2：KMP匹配过程的逻辑**  
    * **分析**：匹配时，若当前字符匹配则同时后移指针；若失配，则利用`next`数组将模式串指针跳转到`next[j]`（即最长border的下一个位置），避免文本串指针回溯。当模式串指针到达末尾时，记录匹配位置，并跳转`next[len]`继续匹配。  
    * 💡 **学习笔记**：KMP的高效性源于“只移动模式串指针”的策略，通过`next`数组跳过了已知匹配的部分。

3.  **关键点3：最长border的计算与应用**  
    * **分析**：题目要求输出模式串每个前缀的最长border长度，这正是`next`数组的值（注意部分题解中`next`数组的索引可能从0或1开始，需注意边界）。例如，模式串`ABA`的`next`数组为`[0,0,1]`，对应每个前缀的最长border长度。  
    * 💡 **学习笔记**：`next`数组直接对应题目要求的最长border长度，构造`next`数组的过程即完成了这一计算。

### ✨ 解题技巧总结
- **预处理优先**：先构造模式串的`next`数组，再进行匹配，避免重复计算。  
- **边界处理**：注意字符串索引的起始位置（如从0或1开始），避免数组越界。  
- **调试辅助**：在`next`数组构造和匹配过程中，打印中间变量（如`j`的值），帮助定位错误。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解后提炼的通用核心代码，结合了清晰的逻辑和规范的实现：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了皎月半洒花和frostime的题解思路，清晰实现了`next`数组构造和KMP匹配过程。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 1e6 + 10;
char s[MAXN], p[MAXN]; // s:文本串，p:模式串
int next_arr[MAXN];     // next数组

void build_next(int len_p) {
    next_arr[0] = 0; // 模式串第0个字符的next值为0（假设从1开始索引）
    int j = 0;
    for (int i = 1; i < len_p; ++i) {
        while (j > 0 && p[i] != p[j]) {
            j = next_arr[j - 1]; // 回溯到前一个next值
        }
        if (p[i] == p[j]) {
            ++j;
        }
        next_arr[i] = j; // 记录当前前缀的最长border长度
    }
}

void kmp_match(int len_s, int len_p) {
    int j = 0;
    for (int i = 0; i < len_s; ++i) {
        while (j > 0 && s[i] != p[j]) {
            j = next_arr[j - 1]; // 失配时跳转到next[j-1]
        }
        if (s[i] == p[j]) {
            ++j;
        }
        if (j == len_p) { // 完全匹配
            cout << i - len_p + 2 << endl; // 输出位置（从1开始）
            j = next_arr[j - 1]; // 继续匹配下一个位置
        }
    }
}

int main() {
    cin >> s >> p;
    int len_s = strlen(s), len_p = strlen(p);
    build_next(len_p);
    kmp_match(len_s, len_p);
    for (int i = 0; i < len_p; ++i) {
        cout << next_arr[i] << " "; // 输出每个前缀的最长border
    }
    return 0;
}
```

* **代码解读概要**：  
  代码分为`build_next`（构造`next`数组）和`kmp_match`（KMP匹配）两部分。`build_next`通过模式串自匹配，利用已计算的`next`值避免重复比较，时间复杂度O(m)；`kmp_match`利用`next`数组在文本串中高效查找模式串，时间复杂度O(n)。最后输出所有匹配位置和`next`数组。

---
<code_intro_selected>
以下是部分优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：作者皎月半洒花**  
* **亮点**：代码简洁，`next`数组构造逻辑清晰，注释详细。  
* **核心代码片段**：  
```cpp
for (int i = 2; i <= lb; i++) {
    while (j && b[i] != b[j + 1]) j = kmp[j];
    if (b[j + 1] == b[i]) j++;
    kmp[i] = j;
}
```  
* **代码解读**：  
  `i`从2开始（模式串从1索引），`j`初始为0。每次循环中，若当前字符不匹配，`j`回溯到`kmp[j]`（即前一个最长border的位置）；若匹配，`j`递增，`kmp[i]`记录当前最长border长度。此逻辑通过模式串自匹配生成`next`数组。  
* 💡 **学习笔记**：`next`数组的构造本质是模式串自己与自己的匹配，利用已计算的`kmp[j]`避免重复比较。

**题解二：作者frostime**  
* **亮点**：详细推导了`next`数组的优化逻辑（避免重复匹配相同字符）。  
* **核心代码片段**：  
```cpp
next[ptr] = (pattern[ptr] == pattern[lastNext]) ? next[lastNext] : lastNext;
```  
* **代码解读**：  
  此代码优化了`next`数组的构造。若当前字符与`lastNext`位置的字符相同，则`next[ptr]`直接取`next[lastNext]`（避免重复匹配）；否则取`lastNext`。这进一步减少了匹配过程中的冗余操作。  
* 💡 **学习笔记**：优化后的`next`数组能进一步提升匹配效率，避免在相同字符处重复失配。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解KMP算法的执行过程，我们设计一个8位像素风格的动画，模拟`next`数组构造和匹配过程。
</visualization_intro>

  * **动画演示主题**：`像素小侦探的字符串冒险`  
  * **核心演示内容**：  
    - `next`数组构造：模式串自匹配，用不同颜色标记前缀和后缀，动态更新`next`值。  
    - KMP匹配：文本串与模式串逐字符比较，失配时通过`next`数组跳转，高亮匹配位置。  

  * **设计思路简述**：  
    采用FC红白机风格的像素画面，用绿色标记当前比较的字符，红色标记失配位置，黄色标记`next`跳转后的新位置。关键操作（如匹配成功、跳转）伴随“叮”“咚”等8位音效，增加趣味性。

  * **动画帧步骤与交互关键点**：  

    1.  **初始化场景**：  
        屏幕分为左右两部分，左半部分显示文本串（白色像素块），右半部分显示模式串（蓝色像素块）。下方显示`next`数组的动态更新。

    2.  **`next`数组构造**：  
        - 模式串自匹配：用两个指针（绿色箭头）分别指向当前字符和前缀字符，若匹配则箭头右移，`next`值增加（用数字弹出动画）；若失配，箭头跳转到`next`值位置（红色箭头指示跳转路径）。  
        - 示例：模式串`ABA`的`next`构造过程：  
          - 第1步（字符A）：无匹配，`next[0]=0`（灰色显示）。  
          - 第2步（字符B）：与前缀A不匹配，`next[1]=0`。  
          - 第3步（字符A）：与前缀A匹配，`next[2]=1`（黄色高亮）。

    3.  **KMP匹配过程**：  
        - 文本串与模式串逐字符比较（绿色箭头同步移动），匹配成功时字符变亮；失配时，模式串箭头跳转到`next`值位置（红色箭头显示跳转）。  
        - 示例：文本串`ABABABC`匹配模式串`ABA`：  
          - 匹配到第3字符（A）时，模式串箭头到达末尾，输出位置1（像素烟花动画），并跳转到`next[2]=1`继续匹配。  

    4.  **交互控制**：  
        提供“单步执行”“自动播放”“调速”按钮，用户可暂停观察每一步的`next`值和指针位置；点击“重置”可重新开始演示。

  * **旁白提示**：  
    - “现在构造`next`数组，模式串的第i个字符正在与前缀比较……”  
    - “失配！模式串指针跳转到`next[j]`位置，继续比较……”  
    - “匹配成功！记录当前位置，并跳转到`next[len]`继续查找下一个匹配……”

<visualization_conclusion>
通过这样的动画演示，我们可以直观看到`next`数组的构造逻辑和KMP匹配的高效性，理解“避免回溯”的核心思想。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
KMP算法不仅适用于本题，还可解决多种字符串相关问题。以下是一些拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    KMP的核心是利用`next`数组记录最长border，这一思想可迁移到：  
    - 查找循环子串（如判断字符串是否由重复子串构成）。  
    - 多模式串匹配（结合AC自动机）。  
    - 字符串周期问题（如求最小周期）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P3435 [POI2006]OKR-Periods of Words**  
        * 🗣️ **推荐理由**：本题需计算字符串每个前缀的最长border，与KMP的`next`数组直接相关，能强化对`next`数组的理解。  
    2.  **洛谷 P5440 【XR-2】奇迹**  
        * 🗣️ **推荐理由**：结合KMP与动态规划，考察对KMP算法的灵活应用，适合提升综合解题能力。  
    3.  **洛谷 P3376 【模板】网络流最大流**（非KMP，但需类似预处理思想）  
        * 🗣️ **推荐理由**：虽不直接相关，但预处理优化的思想与KMP类似，可拓展算法思维。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自作者hicc0305)**：“千万不要用gets！！（坑死我了）”  
> **点评**：输入函数的选择需谨慎，`gets`不安全（无长度检查），本题中用`scanf`或`cin`更可靠。这提醒我们，编码时要注意输入输出的安全性和规范性。

---

<conclusion>
本次关于“【模板】KMP”的C++解题分析就到这里。KMP算法是字符串匹配的经典，理解其核心思想（`next`数组的构造与应用）是关键。通过动画演示和代码实践，相信大家能更好地掌握这一算法。继续加油，下一个算法挑战见！💪
</conclusion>

---
处理用时：148.80秒
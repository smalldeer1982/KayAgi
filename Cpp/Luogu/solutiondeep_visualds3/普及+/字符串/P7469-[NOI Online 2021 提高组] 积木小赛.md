# 题目信息

# [NOI Online 2021 提高组] 积木小赛

## 题目描述

Alice 和 Bob 最近热衷于玩一个游戏——积木小赛。

Alice 和 Bob 初始时各有 $n$ 块积木从左至右排成一排，每块积木都被标上了一个英文小写字母。

Alice 可以从自己的积木中丢掉任意多块（也可以不丢）；Bob 可以从自己的积木中丢掉最左边的一段连续的积木和最右边的一段连续的积木（也可以有一边不丢或者两边都不丢）。两人都不能丢掉自己所有的积木。然后 Alice 和 Bob 会分别将自己剩下的积木按原来的顺序重新排成一排。

Alice 和 Bob 都忙着去玩游戏了，于是想请你帮他们算一下，有多少种不同的情况下他们最后剩下的两排积木是相同的。

两排积木相同，当且仅当这两排积木块数相同且每一个位置上的字母都对应相同。

两种情况不同，当且仅当 Alice（或者 Bob）剩下的积木在两种情况中不同。

## 说明/提示

对于所有测试点：$1\le n \le 3000$，$s$ 与 $t$ 中只包含英文小写字母。

测试点 $1$ 满足：$n\le3000$，$s$ 与 $t$ 中只包含同一种字母。

测试点 $2,3,4$ 满足：$n\le100$。

测试点 $5,6,7$ 满足：$n\le500$。

测试点 $8,9,10$ 满足：$n\le3000$。

感谢 [w33z8kqrqk8zzzx33](https://www.luogu.com.cn/user/220037) 提供测试数据。

## 样例 #1

### 输入

```
5
bcabc
bbcca```

### 输出

```
9```

## 样例 #2

### 输入

```
20
egebejbhcfabgegjgiig
edfbhhighajibcgfecef```

### 输出

```
34```

# AI分析结果



---
# 💡 Kay的C++算法解析：积木小赛 深入学习指南 💡

<introduction>
今天我们来一起分析“积木小赛”这道C++编程题。题目要求计算Alice和Bob剩下的积木序列相同的不同情况数，核心在于找到t的所有本质不同子串中是s的子序列的个数。本指南将帮助大家梳理思路，掌握核心算法和解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理与哈希/自动机应用`

🗣️ **初步分析**：
解决“积木小赛”的关键在于两步：一是判断t的子串是否为s的子序列；二是统计这些子串的本质不同个数。简单来说，我们需要枚举t的所有可能子串，用高效方法判断其是否是s的子序列，并通过去重手段（如哈希、SAM）统计唯一数量。

- **题解思路**：主流题解通过枚举t的子串起点，用贪心指针或子序列自动机快速匹配s，同时用哈希表或SAM去重。例如，枚举t的子串起点i，右端点j从i开始扩展，维护s中的匹配指针p，若p能顺利走完j则记录该子串的哈希值，最后去重统计。
- **核心难点**：高效匹配（避免O(n³)）与去重（避免重复计数）。子序列自动机（预处理每个位置下一个字符的位置）可将匹配复杂度降至O(n²)，哈希或SAM则解决去重问题。
- **可视化设计**：采用8位像素风格，左边展示s和t的积木块（不同颜色区分字符），右边展示哈希表或SAM结构。动画中，指针p在s上移动时高亮当前匹配字符，哈希表添加新值时闪烁提示，重复值用灰色标记。

---

## 2. 精选优质题解参考

<eval_intro>
为帮助大家理解，我筛选了3篇思路清晰、代码高效的优质题解（评分≥4星），分别涉及贪心+哈希、子序列自动机+手写哈希、双哈希优化等方法。
</eval_intro>

**题解一：syksykCCC（赞87）**
* **点评**：此题解思路简洁，代码极短。通过枚举t的子串起点i，维护s中的贪心指针p，同时计算哈希值存入数组，最后排序去重。代码规范（如变量名清晰），时间复杂度O(n² logn)，适合n=3000的场景。

**题解二：Karry5307（赞26）**
* **点评**：此题解使用子序列自动机（预处理nxt数组）加速匹配，手写哈希表优化哈希冲突，时间复杂度O(n²)，常数更小。代码中对哈希表的插入和查询逻辑严谨，适合学习高效数据结构的应用。

**题解三：w33z8kqrqk8zzzx33（赞5）**
* **点评**：此题解结合子序列自动机和双哈希（MOD1和MOD2），进一步降低哈希冲突概率。代码结构清晰，预处理nxt数组的方式值得借鉴，适合需要高正确率的场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理匹配与去重，以下是核心难点及策略：
</difficulty_intro>

1.  **关键点1：如何高效判断t的子串是否为s的子序列？**
    * **分析**：直接暴力匹配会导致O(n³)复杂度。优化方法是预处理s的子序列自动机（nxt数组），nxt[i][c]表示s中i位置后字符c的第一个出现位置。枚举t的子串时，用nxt数组快速跳转，匹配复杂度降至O(n²)。
    * 💡 **学习笔记**：子序列自动机通过预处理“下一个字符的位置”，将匹配过程从逐字符扫描变为O(1)跳转，是处理子序列问题的关键工具。

2.  **关键点2：如何统计本质不同的子串？**
    * **分析**：直接枚举所有子串会重复计数。常用方法有哈希（单/双哈希）和SAM（后缀自动机）。哈希通过计算子串哈希值存入哈希表去重；SAM则利用自动机结构天然去重，每个状态对应唯一子串。
    * 💡 **学习笔记**：双哈希（两个不同模数）可降低冲突概率，SAM则在去重的同时能高效处理子串问题。

3.  **关键点3：如何优化时间复杂度？**
    * **分析**：枚举t的子串有O(n²)种可能，匹配和去重需O(1)或O(logn)时间。子序列自动机匹配O(1)跳转，哈希表插入/查询O(1)（均摊），总复杂度O(n²)，适合n=3000的规模。
    * 💡 **学习笔记**：预处理（如nxt数组）和高效数据结构（如哈希表）是优化时间复杂度的核心。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为“匹配”和“去重”两步，分别用子序列自动机和哈希/SAM解决。
- **预处理优化**：预处理s的nxt数组，快速定位下一个字符位置，避免重复扫描。
- **双哈希防冲突**：使用两个不同模数的哈希，降低哈希冲突概率，提高正确率。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了子序列自动机和双哈希，高效解决匹配与去重问题。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了子序列自动机预处理和双哈希去重，时间复杂度O(n²)，适合n=3000的场景。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 3005;
    const long long MOD1 = 1e9 + 7, MOD2 = 1e9 + 9, BASE = 131;

    int n;
    char s[N], t[N];
    int nxt[N][26]; // nxt[i][c]表示s中i位置后字符c的第一个出现位置
    long long hash1[N], hash2[N], power1[N], power2[N];
    vector<pair<long long, long long>> unique_hashes;

    void preprocess() {
        // 预处理nxt数组
        memset(nxt, -1, sizeof(nxt));
        int last[26];
        memset(last, -1, sizeof(last));
        for (int i = n; i >= 0; --i) {
            if (i > 0) {
                int c = s[i] - 'a';
                last[c] = i;
            }
            for (int j = 0; j < 26; ++j) {
                nxt[i][j] = last[j];
            }
        }
        // 预处理哈希幂次
        power1[0] = power2[0] = 1;
        for (int i = 1; i <= n; ++i) {
            power1[i] = power1[i-1] * BASE % MOD1;
            power2[i] = power2[i-1] * BASE % MOD2;
        }
        // 预处理t的前缀哈希
        for (int i = 1; i <= n; ++i) {
            hash1[i] = (hash1[i-1] * BASE + (t[i] - 'a' + 1)) % MOD1;
            hash2[i] = (hash2[i-1] * BASE + (t[i] - 'a' + 1)) % MOD2;
        }
    }

    int main() {
        scanf("%d %s %s", &n, s+1, t+1);
        preprocess();

        for (int i = 1; i <= n; ++i) {
            int p = 0; // s中的当前匹配位置
            long long h1 = 0, h2 = 0;
            for (int j = i; j <= n; ++j) {
                int c = t[j] - 'a';
                p = nxt[p][c];
                if (p == -1) break;
                // 计算当前子串t[i..j]的哈希值
                h1 = (h1 * BASE + (t[j] - 'a' + 1)) % MOD1;
                h2 = (h2 * BASE + (t[j] - 'a' + 1)) % MOD2;
                unique_hashes.emplace_back(h1, h2);
            }
        }

        // 去重并统计数量
        sort(unique_hashes.begin(), unique_hashes.end());
        int ans = 0;
        for (int i = 0; i < unique_hashes.size(); ++i) {
            if (i == 0 || unique_hashes[i] != unique_hashes[i-1]) {
                ans++;
            }
        }
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：代码首先预处理s的nxt数组（子序列自动机）和t的前缀哈希，然后枚举t的所有子串，用nxt数组快速匹配s，计算哈希值存入数组，最后排序去重统计数量。

---
<code_intro_selected>
以下是优质题解的核心代码片段分析：
</code_intro_selected>

**题解一：syksykCCC**
* **亮点**：代码极简，利用贪心指针匹配，哈希数组排序去重。
* **核心代码片段**：
    ```cpp
    for(int i = 1; i <= n; i++) {
        long long v = 0; int p = 1;
        for(int j = i; j <= n; j++) {
            while(p <= n && a[p] != b[j]) p++;
            if(p > n) break;
            p++;
            v = (1LL * v * BASE + b[j] - 'a' + 1) % M;
            t[++t[0]] = v;
        }
    }
    sort(t + 1, t + t[0] + 1);
    printf("%d\n", unique(t + 1, t + t[0] + 1) - t - 1);
    ```
* **代码解读**：枚举t的子串起点i，维护指针p在s中匹配，计算哈希值v存入数组t。最后排序去重，输出唯一哈希数量。贪心指针确保匹配正确性，哈希数组排序去重简单高效。
* 💡 **学习笔记**：贪心指针是子序列匹配的基础方法，适合快速实现；排序+unique是去重的经典手段。

**题解二：Karry5307**
* **亮点**：使用子序列自动机（nxt数组）加速匹配，手写哈希表优化冲突。
* **核心代码片段**：
    ```cpp
    for(register int i=n;i;i--) {
        memcpy(nxt[i-1],nxt[i],sizeof(nxt[i]));
        nxt[i-1][s[i]-'a']=i;
    }
    for(register int i=1;i<=n;i++) {
        cur=hsh1=hsh2=0;
        for(register int j=i;j<=n;j++) {
            if(!(cur=nxt[cur][t[j]-'a'])) break;
            hsh1=(hsh1*131+t[j]-'a'+1)%MOD1;
            hsh2=(hsh2*131+t[j]-'a'+1)%MOD2;
            !hsh.query(hsh1,hsh2)?hsh.insert(hsh1,hsh2),res++:1;
        }
    }
    ```
* **代码解读**：预处理nxt数组（i位置后各字符的下一个位置），枚举t的子串时用nxt[cur][c]快速跳转。手写哈希表hsh存储双哈希值，插入前查询避免重复。
* 💡 **学习笔记**：子序列自动机通过预处理将匹配复杂度降至O(1)跳转，手写哈希表比STL的unordered_map更高效。

**题解三：w33z8kqrqk8zzzx33**
* **亮点**：双哈希降低冲突概率，预处理nxt数组更简洁。
* **核心代码片段**：
    ```cpp
    rep1(i,n) nx[alice[i]][i-1] = i;
    rep(c,26) for(int i=n;i>=0;i--) 
        if(nx[c][i]==-1) nx[c][i]=nx[c][i+1];
    int cnt=0;
    rep1(i,n) {
        long long curhash1=0,curhash2=0;
        int pos=0;
        iter(j,i,n+1) {
            curhash1=(curhash1*BASE1+bob[j]+1)%MOD1;
            curhash2=(curhash2*BASE2+bob[j]+1)%MOD2;
            pos=nx[bob[j]][pos];
            if(pos==-1) break;
            ar[cnt++]=(curhash1<<32)|curhash2;
        }
    }
    sort(ar,ar+cnt);
    ans=1; rep1(i,cnt-1) ans+=1-(ar[i]==ar[i-1]);
    ```
* **代码解读**：预处理nx数组（字符c在位置i后的第一个出现位置），枚举t的子串时计算双哈希值存入数组ar，排序后统计唯一数量。双哈希组合成64位整数，降低冲突概率。
* 💡 **学习笔记**：双哈希通过两个不同的模数和基数，几乎可避免冲突，适合对正确性要求高的场景。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为直观理解匹配与去重过程，设计“积木匹配大冒险”像素动画，8位风格+游戏化交互，帮助你“看”到算法每一步！
</visualization_intro>

  * **动画演示主题**：`积木匹配大冒险`

  * **核心演示内容**：展示t的子串枚举、s中的贪心匹配、哈希表去重的全过程。

  * **设计思路简述**：8位像素风格营造复古氛围，关键操作（匹配、哈希插入）用音效和动画强化记忆。例如，匹配成功时积木闪烁“叮”声，哈希表插入新值时弹出小烟花，重复值用灰色半透明表示。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左半部分是s和t的积木块（8x8像素，不同颜色代表不同字符）；右半部分是哈希表（格子状，每个格子存储哈希值）。
          * 控制面板：单步/自动播放按钮、速度滑块（1x到5x）、重置按钮。

    2.  **枚举子串起点i**：
          * t的起点i用黄色框高亮，指针p在s的起始位置（0号位置）显示为绿色箭头。

    3.  **扩展子串终点j**：
          * j从i开始向右移动，t的j位置积木变为蓝色。
          * p在s中寻找t[j]的字符：若s[p]等于t[j]，p右移（绿色箭头移动），对应积木闪烁；否则p继续右移直到找到或超出s长度。

    4.  **匹配成功**：
          * p成功移动到s中的有效位置，计算当前子串的哈希值（右半部分哈希表对应格子显示该值，伴随“叮”音效）。
          * 若哈希值未在表中出现，格子变为红色；若已存在，变为灰色。

    5.  **匹配失败**：
          * p超出s长度（箭头变为红色），停止扩展当前i，j跳转至下一个起点。

    6.  **统计结果**：
          * 所有操作完成后，红色格子数量即为答案，伴随“胜利”音效和烟花动画。

  * **旁白提示**：
      * （匹配时）“当前匹配t的第i到j位，s的指针p正在寻找t[j]的位置...”
      * （哈希插入时）“这个哈希值没出现过，计入结果！”
      * （重复时）“这个哈希值已经存在，跳过~”

<visualization_conclusion>
通过这样的动画，你可以清晰看到t的子串如何被枚举、匹配到s，以及哈希表如何去重。游戏化的交互让学习更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，可通过以下题目巩固字符串处理与自动机的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 子序列自动机：用于快速判断一个字符串是否是另一个的子序列（如判断多个模式串是否为文本串的子序列）。
      * 哈希去重：统计本质不同的子串/子序列数（如求字符串的不同子串数）。
      * SAM（后缀自动机）：高效处理子串问题（如求两个字符串的最长公共子串）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1439 【模板】最长公共子序列（LCS）**
          * 🗣️ **推荐理由**：巩固子序列匹配的基础方法，理解动态规划与贪心的区别。
    2.  **洛谷 P2408 不同的子串**
          * 🗣️ **推荐理由**：练习SAM或哈希去重，掌握统计本质不同子串的方法。
    3.  **洛谷 P4112 [HEOI2015]最短不公共子串**
          * 🗣️ **推荐理由**：结合子序列自动机与SAM，提升复杂字符串问题的分析能力。

-----

## 7\. 学习心得与经验分享 

<insights_intro>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自 KAMIYA_KINA)**：“在实现Trie树时，因空间不足导致内存爆炸，后来优化存储方式（用链式前向星代替二维数组）才通过。”

**点评**：数据结构的选择对空间和时间影响很大。Trie树的二维数组实现空间复杂度为O(n²*26)，n=3000时会超内存。改用链式前向星（邻接表）可大幅减少空间占用，这是处理大规模数据时的重要优化技巧。

-----

<conclusion>
本次“积木小赛”的分析就到这里。希望通过本指南，你能掌握子序列匹配、哈希去重等核心技巧，并通过可视化动画更直观地理解算法过程。编程能力的提升需要不断练习，快去挑战推荐的题目吧！💪
</conclusion>

-----

---
处理用时：187.85秒
# 题目信息

# [蓝桥杯 2022 国 C] 打折

## 题目描述

小蓝打算采购 $n$ 种物品，每种物品各需要 $1$ 个。

小蓝所住的位置附近一共有 $m$ 个店铺，每个店铺都出售着各种各样的物品。

第 $i$ 家店铺会在第 $s_i$ 天至第 $t_i$ 天打折，折扣率为 $p_i$，对于原件为 $b$ 的物品，折后价格为 $\lfloor\frac {b\cdot p_j}{100}\rfloor$。其它时间需按原价购买。

小蓝很忙，他只能选择一天的时间去采购这些物品。请问，他最少需要花多少钱才能买到需要的所有物品。

题目保证小蓝一定能买到需要的所有物品。

## 说明/提示

对于 $40\%$ 的评测用例，$n,m≤500，s_i ≤t_i ≤100，\sum c_i ≤2000$；

对于 $70\%$ 的评测用例，$n,m≤5000，\sum c_i ≤20000$；

对于所有评测用例，$1 ≤ n,m ≤ 10^5，1 ≤ c_i ≤ n，\sum c_i ≤ 4\times10^5，1 ≤ s_i ≤t_i ≤10^9，1 < p_i < 100，1≤a_j ≤n，1≤b_j ≤10^9$。

蓝桥杯 2022 国赛 C 组 I 题。

## 样例 #1

### 输入

```
2 2
1 2 89 1
1 97
3 4 77 1
2 15```

### 输出

```
101```

# AI分析结果



---
# 💡 Kay的C++算法解析：[蓝桥杯 2022 国 C] 打折 深入学习指南 💡

<introduction>
今天我们来一起分析“[蓝桥杯 2022 国 C] 打折”这道题。这道题需要我们找到一天采购所有物品，使得总花费最小。通过分析题解，我们将掌握如何高效处理时间区间内的折扣变化，并动态维护物品的最低价格。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟（结合数据结构应用）`

🗣️ **初步分析**：
解决这道题的关键在于“模拟时间轴上的折扣事件”，并动态维护每个物品的最低价格。简单来说，“模拟”就像按时间顺序播放一部电影，我们需要跟踪每个时间点发生的“事件”（比如某个店铺开始或结束打折），并根据这些事件更新物品的价格集合。在本题中，我们需要：
- **离散化时间点**：将所有可能的打折开始和结束时间（如`s_i`和`t_i+1`）收集起来，排序去重，减少需要处理的时间点数量。
- **维护价格集合**：用`multiset`（可重复的有序集合）记录每个物品在当前时间点能购买的所有价格（包括原价和打折价），并快速获取最小值。
- **处理事件**：按时间顺序处理“开始打折”和“结束打折”事件，动态更新每个物品的价格集合，并计算总花费的最小值。

核心难点在于如何高效处理大量时间点和动态维护价格集合。优质题解通过离散化时间点（将时间范围从`1e9`压缩到`O(m)`级别）和使用`multiset`（支持快速插入、删除和查询最小值）巧妙解决了这些问题。

可视化设计思路：我们将用像素时间轴展示关键时间点（如开始/结束打折），每个物品的价格集合用堆叠的像素块表示（原价为灰色，打折价为蓝色），最低价格块用黄色高亮。当处理事件时，对应物品的价格块会动态添加或移除，总花费数值实时更新，关键操作（如插入/删除价格）伴随“叮”的像素音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面评估题解，筛选出以下优质题解：
</eval_intro>

**题解一：来源（tmp_get_zip_diff）**
* **点评**：这份题解思路非常清晰！作者通过离散化时间点将问题简化为处理有限的事件点，并用`multiset`维护每个物品的价格集合。代码规范（变量名如`startD`、`endD`含义明确），关键步骤有注释。算法上，通过事件驱动的方式动态更新总花费，时间复杂度控制得当（离散化后时间点数量为`O(m)`，每个事件处理为`O(log c)`），适用于题目数据规模。亮点在于：1）离散化时间点的处理，避免了遍历所有可能的天数；2）用`multiset`高效维护价格集合的最小值；3）通过计算“贡献值”快速更新总花费，避免了重复计算所有物品的最小值。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们常遇到以下核心难点。结合题解的思路，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何处理大量时间点？**
    * **分析**：题目中时间范围可能到`1e9`，直接遍历每一天不可行。优质题解通过离散化时间点（收集所有`s_i`和`t_i+1`，排序去重），将时间点数量压缩到`O(m)`级别，大幅减少计算量。例如，将实际时间映射到离散后的索引，只需处理这些关键时间点的事件。
    * 💡 **学习笔记**：离散化是处理大范围时间/数值问题的常用技巧，能有效降低复杂度。

2.  **关键点2：如何动态维护每个物品的最低价格？**
    * **分析**：每个物品的价格可能随时间变化（打折开始/结束），需要动态插入或删除价格。`multiset`是有序的可重复集合，支持`insert`（插入价格）、`erase`（删除价格）和`begin()`（获取最小值）操作，正好满足需求。例如，当某店铺开始打折时，将打折价插入对应物品的`multiset`；结束时，删除该打折价。
    * 💡 **学习笔记**：`multiset`适合维护动态变化的有序集合，尤其需要快速查询最小值时。

3.  **关键点3：如何高效计算总花费的最小值？**
    * **分析**：总花费是所有物品当前最低价格的和。直接每次重新计算所有物品的最小值（`O(n)`）会超时。题解通过“贡献值”技巧：当某个物品的最小值变化时，计算其对总花费的影响（新最小值 - 旧最小值），并累加这个差值到总花费中。例如，插入一个更低的价格时，总花费减少（旧最小值 - 新最小值）。
    * 💡 **学习笔记**：通过“差值更新”替代“重新计算总和”，能将时间复杂度从`O(n)`降为`O(1)`。

### ✨ 解题技巧总结
- **事件驱动处理**：将问题转化为处理关键时间点的事件（开始/结束打折），避免遍历所有时间。
- **离散化时间点**：将大范围时间压缩为有限的关键时间点，减少计算量。
- **动态集合维护**：用`multiset`等数据结构动态维护物品价格，快速获取最小值。
- **差值更新总和**：通过计算变化量更新总和，避免重复计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选取tmp_get_zip_diff的题解作为代表，其代码逻辑清晰、实现高效，适合作为通用核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了离散化时间、事件处理和动态维护价格集合的思路，是解决本题的典型实现。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXM = 1e5 + 5;
    int s[MAXM], t[MAXM], p[MAXM], c[MAXM];
    multiset<long long> st[MAXM]; // 每个物品的价格集合
    vector<vector<pair<int, int>>> v(MAXM); // 每个店铺的物品列表

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);

        int n, m;
        cin >> n >> m;
        vector<int> time;

        // 读取店铺信息并收集时间点
        for (int i = 0; i < m; ++i) {
            cin >> s[i] >> t[i] >> p[i] >> c[i];
            time.push_back(s[i]);
            time.push_back(t[i] + 1); // 结束时间为t_i+1（闭区间）
            for (int j = 0; j < c[i]; ++j) {
                int a, b;
                cin >> a >> b;
                v[i].emplace_back(a, b);
            }
        }

        // 离散化时间点
        sort(time.begin(), time.end());
        time.erase(unique(time.begin(), time.end()), time.end());
        auto get = [&](int t) {
            return lower_bound(time.begin(), time.end(), t) - time.begin();
        };
        int len = time.size();

        // 初始化事件列表（开始/结束打折）
        vector<vector<pair<int, int>>> startD(len), endD(len);
        for (int i = 0; i < m; ++i) {
            int starts = get(s[i]), ends = get(t[i] + 1);
            for (auto [x, y] : v[i]) {
                long long discount = 1LL * y * p[i] / 100;
                st[x].insert(y); // 初始加入原价
                startD[starts].emplace_back(x, discount);
                endD[ends].emplace_back(x, discount);
            }
        }

        // 计算初始总花费（所有物品不打折的最小值之和）
        long long temp = 0;
        for (int i = 1; i <= n; ++i) temp += *st[i].begin();
        long long ans = temp;

        // 按时间顺序处理事件，更新总花费
        for (int i = 0; i < len; ++i) {
            long long k = 0;
            // 处理开始打折事件：插入打折价，更新最小值
            for (auto [x, y] : startD[i]) {
                k -= *st[x].begin();
                st[x].insert(y);
                k += *st[x].begin();
            }
            // 处理结束打折事件：删除打折价，更新最小值
            for (auto [x, y] : endD[i]) {
                k -= *st[x].begin();
                auto it = st[x].find(y);
                if (it != st[x].end()) st[x].erase(it);
                k += *st[x].begin();
            }
            temp += k; // 更新总花费
            ans = min(ans, temp); // 记录最小值
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  代码首先读取输入并收集所有关键时间点（打折开始和结束时间），通过离散化将时间点压缩。然后初始化每个物品的价格集合（初始为原价），并记录每个时间点的“开始打折”和“结束打折”事件。接着按时间顺序处理事件，动态更新每个物品的价格集合，并通过计算“贡献值”快速更新总花费，最终找到最小总花费。

---

<code_intro_selected>
下面分析题解一的核心代码片段，理解其关键逻辑。
</code_intro_selected>

**题解一：来源（tmp_get_zip_diff）**
* **亮点**：离散化时间点处理、`multiset`维护价格集合、贡献值更新总花费。
* **核心代码片段**：
    ```cpp
    // 处理开始打折事件
    for (auto [x, y] : startD[i]) {
        k -= *st[x].begin();
        st[x].insert(y);
        k += *st[x].begin();
    }
    // 处理结束打折事件
    for (auto [x, y] : endD[i]) {
        k -= *st[x].begin();
        auto it = st[x].find(y);
        if (it != st[x].end()) st[x].erase(it);
        k += *st[x].begin();
    }
    temp += k;
    ans = min(ans, temp);
    ```
* **代码解读**：
  这段代码是动态更新总花费的核心。对于每个时间点的事件（开始或结束打折），首先计算该事件对总花费的影响（`k`）：
  - **开始打折**：将打折价`y`插入物品`x`的价格集合`st[x]`。插入前，总花费中物品`x`的贡献是旧最小值（`*st[x].begin()`）；插入后，新最小值可能更小，所以`k`加上（新最小值 - 旧最小值）。
  - **结束打折**：从`st[x]`中删除打折价`y`。删除前，总花费中物品`x`的贡献是旧最小值；删除后，新最小值可能变大，所以`k`加上（新最小值 - 旧最小值）。
  最后，`temp`（当前总花费）加上`k`，并更新`ans`为最小值。
* 💡 **学习笔记**：通过计算事件对总花费的影响（差值），避免了每次重新计算所有物品的最小值，大幅提高效率。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解时间轴上的事件处理和价格变化，我们设计一个“像素时间探险”动画，用8位像素风格展示算法过程！
</visualization_intro>

  * **动画演示主题**：`像素时间探险——寻找最优采购日`
  * **核心演示内容**：展示时间轴上的关键时间点（开始/结束打折），每个物品的价格集合动态变化，总花费实时更新，最终找到最小总花费的那一天。
  * **设计思路简述**：8位像素风格（如FC游戏画面）让学习更轻松；时间轴用横向滚动的像素条表示，每个时间点有事件图标（开始打折为绿色箭头，结束为红色叉）；价格集合用堆叠的像素块（原价灰色，打折价蓝色），最低价格块黄色高亮；总花费数值在屏幕上方动态显示，关键操作（插入/删除价格）伴随“叮”的音效，找到最小值时播放胜利音效。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：
       - 屏幕分为三部分：顶部显示总花费（初始为所有物品原价之和），中间是时间轴（横向像素条，标记关键时间点），底部是每个物品的价格集合（n列堆叠的像素块）。
       - 控制面板：单步/自动播放按钮、速度滑块、重置按钮。
       - 播放8位风格的轻快背景音乐。

    2. **处理开始打折事件**（例如时间点i）：
       - 时间轴上的绿色箭头图标闪烁，提示“开始打折事件”。
       - 对应物品的价格集合列中，插入一个蓝色像素块（打折价），伴随“叮”的音效。
       - 黄色高亮块（当前最小值）可能下移（如果新价格更低），总花费数值减少，显示变化量（如“-5”）。

    3. **处理结束打折事件**（例如时间点j）：
       - 时间轴上的红色叉图标闪烁，提示“结束打折事件”。
       - 对应物品的价格集合列中，移除一个蓝色像素块（打折价），伴随“叮”的音效。
       - 黄色高亮块可能上移（如果移除的是当前最小值），总花费数值增加，显示变化量（如“+3”）。

    4. **目标达成**：
       - 当所有事件处理完成后，总花费的最小值用金色高亮显示，播放胜利音效（如“啦~啦~”），时间轴上对应天数用星星围绕。

  * **旁白提示**：
    - （开始打折时）“看！这个物品开始打折了，价格更低了，总花费可能减少哦~”
    - （结束打折时）“这个打折活动结束了，价格可能回到原价，总花费可能增加~”
    - （找到最小值时）“太棒了！这一天的总花费最小，就是它啦！”

<visualization_conclusion>
通过这个动画，我们能直观看到时间轴上的事件如何影响每个物品的价格，以及总花费是如何动态变化的。像素风格和游戏化元素让学习过程更有趣！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是时间区间处理和动态维护最小值，这类思路还适用于以下场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 活动选择问题（如会议安排，选择时间区间使得收益最大）。
    - 区间覆盖问题（如线段覆盖，选择最少线段覆盖整个区间）。
    - 动态价格监控（如股票价格波动，求某段时间内的最小/最大价格）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1803 凌乱的yyy / 线段覆盖**  
        🗣️ **推荐理由**：练习时间区间的处理，与本题的时间轴事件处理思路类似。
    2.  **洛谷 P1090 合并果子**  
        🗣️ **推荐理由**：使用优先队列（类似`multiset`）维护最小值，练习动态集合的应用。
    3.  **洛谷 P2866 [USACO06NOV]Bad Hair Day S**  
        🗣️ **推荐理由**：处理区间内的最大值问题，锻炼单调栈/队列的使用。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中提到“打折时间为`[s,t]`，意味着第`t+1`天才结束打折”，这是一个容易出错的细节。
</insights_intro>

> **参考经验**：作者在处理时间区间时，特别指出“结束时间需要取`t_i+1`”，因为打折是闭区间`[s_i, t_i]`，所以第`t_i+1`天不再打折。这避免了将结束时间误判为`t_i`，导致事件处理错误。
>
> **点评**：这个经验非常关键！在处理区间问题时，明确区间的开闭性（如闭区间`[a,b]`包含`b`）是避免错误的重要一步。建议大家在遇到类似问题时，先明确区间的边界条件，必要时通过样例验证。

---

<conclusion>
通过这次分析，我们掌握了如何用离散化时间、`multiset`维护价格集合，以及事件驱动的方式解决打折问题。编程的关键在于理清思路，选择合适的数据结构，并注意细节（如时间区间的边界）。希望大家多练习，在实战中巩固这些技巧！下次见~ 💪
</conclusion>

---
处理用时：152.82秒
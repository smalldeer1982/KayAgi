# 题目信息

# [TJOI2010] 中位数

## 题目描述

给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：

- $\texttt{1 add }\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。
- $\texttt{2 mid}$：输出当前序列的中位数。

中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）

例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  
例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  
例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。


## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。
- 对于 $100\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。

序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。

## 样例 #1

### 输入

```
6
1 2 13 14 15 16
5
add 5
add 3
mid
add 20
mid
```

### 输出

```
5
13
```

# AI分析结果


# 💡 Kay的C++算法解析：中位数 深入学习指南 💡

**引言**  
今天我们来分析"动态维护序列中位数"这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握高效解题技巧。通过像素动画演示和精选代码分析，你将直观理解数据结构的运作过程，提升算法思维能力。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数据结构应用（堆/平衡树）`  

🗣️ **初步分析**：  
> 解决动态中位数问题的关键在于**高效维护有序序列的中间位置**。想象你有两个魔法袋子：一个专门装较小的数（大根堆），另一个装较大的数（小根堆）。通过巧妙控制袋子的大小，你总能从"小袋子"顶部快速取出中位数。  

- **题解思路对比**：主流解法包括对顶堆（空间效率高）、平衡树（功能全面）和暴力插入（实现简单）。对顶堆通过两个优先队列动态划分数据流，是时间/空间均衡的最佳选择。
- **核心流程**：插入时比较新元素与当前中位数，决定进入哪个堆；通过元素转移保持大根堆大小 = 小根堆大小（或+1）。查询时直接返回大根堆顶。
- **可视化设计**：采用8位像素风格，用蓝色方块堆表示大根堆，绿色表示小根堆。插入时数字方块从顶部下落，比较过程显示决策路径，堆调整时顶部方块水平移动并伴随复古音效。控制面板支持单步调试和调速自动演示。

---

## 2. 精选优质题解参考

**题解一：这有一只匿（对顶堆-STL）**  
* **点评**：思路清晰运用STL优先队列，通过计数器动态维护堆大小。代码结构工整，变量名`que1/que2`直观体现堆特性。亮点在于用`while`循环保证堆大小约束，边界处理严谨（如空堆检测），可直接用于竞赛。  

**题解二：lndjy（multiset迭代器）**  
* **点评**：创新性使用multiset的迭代器追踪中位位置。代码简洁优雅（仅20行核心），通过奇偶性判断迭代器移动方向体现数学思维。虽然查询效率略低于堆但可读性极佳，适合掌握STL的学习者。  

**题解三：Garrison（手写堆）**  
* **点评**：深入底层实现自定义堆结构，展示指针调整和上浮/下沉操作。虽然代码较长但注释完整，帮助理解堆的运作机制。亮点在避免STL开销，适合追求极致效率的场景。  

---

## 3. 核心难点辨析与解题策略

1. **难点：动态维护有序结构**  
   *分析*：暴力排序每次O(n log n)不可行，需选择增量更新的数据结构  
   *方案*：对顶堆将插入复杂度降至O(log n)，通过大小约束保持中位数在堆顶  

2. **难点：堆大小平衡**  
   *分析*：插入后可能破坏"|大根堆大小 - 小根堆大小| ≤ 1"的平衡条件  
   *方案*：插入后检测并转移堆顶元素，代码中体现为循环调整或条件转移  

3. **难点：初始状态构建**  
   *分析*：空序列插入需特殊处理，初始排序影响堆性能  
   *方案*：预排序序列前半入大根堆，后半入小根堆，确保初始中位正确  

### ✨ 解题技巧总结
- **双堆划分**：大根堆存较小半部分，小根堆存较大半部分，堆顶即为分界点
- **大小约束**：总数为奇数时保持`大根堆.size = 小根堆.size + 1`
- **边界防御**：插入前检查堆空情况，调整后验证大小关系
- **迭代追踪**：平衡树方案通过奇偶性判断迭代器移动方向

---

## 4. C++核心代码实现赏析

**通用核心实现（STL对顶堆）**  
```cpp
#include <queue>
priority_queue<int> max_heap; // 大根堆（存较小半）
priority_queue<int, vector<int>, greater<int>> min_heap; // 小根堆

void insert(int x) {
    if (max_heap.empty() || x <= max_heap.top()) {
        max_heap.push(x);
        if (max_heap.size() > min_heap.size() + 1) {
            min_heap.push(max_heap.top()); // 转移堆顶
            max_heap.pop();
        }
    } else {
        min_heap.push(x);
        if (min_heap.size() > max_heap.size()) {
            max_heap.push(min_heap.top());
            min_heap.pop();
        }
    }
}
int mid() { return max_heap.top(); } // 中位即大根堆顶
```

**题解一：堆调整逻辑**  
```cpp
// 调整大根堆大小至(n+1)/2
while (cnt2 < (n + 1) / 2) { 
    int x = que1.top(); que1.pop();
    que2.push(x); // 从小堆补到大堆
}
```
> 当大堆不足半数时，持续从小堆取顶部元素补充，确保堆顶始终为中位值  

**题解二：multiset迭代器移动**  
```cpp
multiset<int> s;
auto mid_it = s.begin();
void adjust(int x) {
    s.insert(x);
    if (s.size() & 1) { // 元素数变奇数
        if (x >= *mid_it) ++mid_it;
    } else if (x < *mid_it) --mid_it;
}
```
> 插入后根据序列长度奇偶性和新值位置，智能移动中位迭代器  

**题解三：手写堆上浮**  
```cpp
void shift_up(int pos) {
    while (pos > 1 && heap[pos] > heap[pos/2]) {
        swap(heap[pos], heap[pos/2]); // 与父节点比较
        pos /= 2;
    }
}
```
> 上浮操作通过递归交换维护堆序性，是堆插入的核心操作  

---

## 5. 算法可视化：像素动画演示

**主题**：8位机风格堆栈冒险  
**核心演示**：中位数维护的堆动态调整过程  

![](https://via.placeholder.com/400x250/2244cc/ffffff?text=堆调整动画示意)  
*图：像素方块表示堆元素，箭头显示插入路径*

1. **场景初始化**  
   - 左侧蓝色堆（大根堆）顶部标记皇冠图标，右侧绿色堆（小根堆）顶部标记星形
   - 控制面板：步进执行▶️/自动播放🔁/速度滑块

2. **插入动画**  
   - 新元素像素块从顶部落下，与当前中位数（闪烁方块）比较
   - 进入大堆时蓝色闪光+低音，进入小堆时绿色闪光+高音

3. **平衡调整**  
   - 当`|大堆高度 - 小堆高度| > 1`时，顶部方块水平移动
   - 移动轨迹显示红色虚线，伴随"嗖"音效

4. **查询时刻**  
   - 中位数方块旋转闪烁，弹出对话框显示数值
   - 背景播放胜利旋律，顶部显示当前操作伪代码

---

## 6. 拓展练习与相似问题思考

**技巧迁移场景**  
1. 滑动窗口中位数（带删除操作）  
2. 数据流TopK维护（堆扩展）  
3. 多维数据中位值（分治应用）  

**洛谷推荐**  
1. [P1168 中位数](https://www.luogu.com.cn/problem/P1168) - 静态中位数的堆解法入门  
2. [P1801 黑匣子](https://www.luogu.com.cn/problem/P1801) - 动态第K大问题的堆扩展  
3. [P3369 普通平衡树](https://www.luogu.com.cn/problem/P3369) - 理解平衡树如何支持中位查询  

---

## 7. 学习心得与经验分享

> "调试时打印双堆的堆顶和大小，能快速定位平衡问题" —— 题解作者调试经验

关键教训：  
- 初始空堆插入需特殊处理，避免访问空堆顶  
- 堆大小约束的等号边界易出错（如`size+1`的奇偶处理）  
- 暴力解法在有序序列插入时可用二分查找优化  

---

**结语**  
通过本指南，你已掌握动态中位数的核心解法与优化技巧。记住：对顶堆是空间与时间的黄金平衡点，而理解数据流动是算法设计的精髓。下次遇到动态统计问题，不妨先画两个魔法袋子！🚀

---
处理用时：214.13秒
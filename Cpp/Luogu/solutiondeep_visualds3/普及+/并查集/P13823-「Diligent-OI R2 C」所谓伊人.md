# 题目信息

# 「Diligent-OI R2 C」所谓伊人

## 题目背景

> 溯洄从之，道阻且长。溯游从之，宛在水中央。——《诗经·秦风·蒹葭》

## 题目描述

给定一张 $n$ 个点，$m$ 条边的有向图，点从 $1\sim n$ 编号。图中每个点 $i$ 有点权 $p_i$。注意可能有重边自环。

如果点 $u$ 出发存在路径到达点 $v$，则你可以将 $u,v$ 的点权交换。

对于每个点 $i$，输出使 $i$ 点权最大化的最少交换次数。**请注意，每个回答是独立的，即都应该从初始给定的图开始交换。**

## 说明/提示

#### 样例 #1 解释

可以证明，$6$ 个点的点权的最大可能值分别为 $1,1,5,5,5,4$。

使 $1$ 号点点权最大化的方案：不交换。

使 $2$ 号点点权最大化的方案：不交换。

使 $3$ 号点点权最大化的方案：交换 $3$ 号和 $4$ 号点的点权。

使 $4$ 号点点权最大化的方案：不交换。

使 $5$ 号点点权最大化的方案：交换 $4$ 号和 $5$ 号点的点权。

使 $6$ 号点点权最大化的方案：不交换。

#### 数据范围

对于所有数据，保证 $1\le n,m\le 5\times10^5,1\le p_i\le10^9,1\le u,v\le n$。注意可能有重边自环。

- Subtask 1（5pts）：$n,m\le3$。
- Subtask 2（25pts）：$n,m\le10^3$。
- Subtask 3（8pts）：图为一条链。即对于所有 $i=1,2,\dots,n-1$，$i$ 与 $i+1$ 之间有且仅有一条有向边，但方向不确定。
- Subtask 4（12pts）：图为一棵树。即 $m=n-1$，且图将有向边改成无向边后连通。
- Subtask 5（20pts）：$n,m\le5\times10^4$，且图随机生成。随机生成方式见下。
- Subtask 6（10pts）：$n,m\le10^5$。
- Subtask 7（20pts）：$n,m\le5\times10^5$。

Subtask 5 的随机生成方式：

- 先确定 $n,m$ 和序列 $p$（不一定随机）。
- 然后对于 $m$ 条边，每条边的 $u,v$ 都在 $1\sim n$ 的整数中均匀随机取。

**请注意，此题需要较快的输入输出方式，并且在实现过程中，请注意常数对程序效率的影响。**

## 样例 #1

### 输入

```
6 5
1 1 4 5 1 4
1 2
2 1
3 4
4 5
3 5```

### 输出

```
0 0 1 0 1 0```

# AI分析结果


### 💡 Kay的C++算法解析：「所谓伊人」深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：**图论建模与01BFS**  
🗣️ **初步分析**：  
> 本题如同在迷宫中寻找最优路径。核心是将点权交换转化为图上的移动代价：  
> - **拆点技巧**：每个点拆成4个状态（A1/A2/B1/B2），用免费边（代价0）和付费边（代价1）模拟交换操作  
> - **01BFS**：像地铁换乘系统，免费边是直通电梯（0代价），付费边需刷卡（1代价），用双端队列快速计算最小代价  
> - **可视化设计**：像素动画中将状态画成不同颜色房间，免费边用绿色箭头，付费边用红色箭头，队列移动时播放"滴"声  

---

#### 2. 精选优质题解参考
**题解（来源：Night_sea_64）**  
* **点评**：  
  思路清晰拆解状态转移（四类房间的进出逻辑），代码通过`ed`结构体实现高效邻接表存储。亮点在于：  
  - **建模巧妙**：用`u*4+k`映射四种状态（如房间号）  
  - **01BFS优化**：双端队列处理0/1边权，时间复杂度O(n+m)  
  - **预处理最大值**：DFS先标记可达最大值点（起点）  
  改进点：变量命名`a/s/b`可读性较弱，建议改用`val/max_val/visited`  

---

#### 3. 核心难点辨析与解题策略
1. **难点：状态抽象**  
   * **分析**：需理解点权交换本质是路径连通性+操作代价。优质解用拆点（A1/A2/B1/B2）区分进出方向  
   * 💡 **学习笔记**：图论难题常通过增加状态维度简化操作逻辑  

2. **难点：代价计算优化**  
   * **分析**：普通BFS处理0/1权值会退化。01BFS用双端队列：0代价插队首，1代价插队尾  
   * 💡 **学习笔记**：边权仅为0/1时，01BFS效率等同Dijkstra但常数更优  

3. **难点：多起点处理**  
   * **分析**：所有最大点权点需作为起点。先用DFS预处理`s[x]=max_val`再推入队列  
   * 💡 **学习笔记**：多源最短路需保证起点状态一致性  

### ✨ 解题技巧总结
- **状态扩展法**：当操作含多类型代价时，拆点增加维度（如本例4状态）  
- **01BFS模板**：双端队列+分层松弛（0权插头，1权插尾）  
- **预处理剪枝**：DFS先标记无效点（`b[x]=0`）减少计算量  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
* **说明**：基于题解的精简版本，重点保留拆点和01BFS逻辑  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5+5, M = 2e6+5; // 4倍点/边

struct Edge { int to, w, next; } ed[M*2];
int head[N*4], val[N], max_val[N], dist[N*4], vis[N];
vector<int> G[N]; // 原图邻接表

void add_edge(int u, int v, int w) {
    static int cnt = 0;
    ed[++cnt] = {v, w, head[u]};
    head[u] = cnt;
}

void dfs(int u) { // 预处理最大值
    if(vis[u]) return;
    vis[u] = 1;
    for(int v : G[u]) {
        dfs(v);
        max_val[u] = max(max_val[u], max_val[v]);
    }
}

int main() {
    // 初始化与读入略
    // 拆点建图（核心！）
    for(int i=1; i<=n; i++) {
        int A1 = i*4-3, A2 = i*4-2, B1 = i*4-1, B2 = i*4;
        add_edge(A1, A2, 0);   // A1->A2 (免费)
        add_edge(B1, B2, 0);   // B1->B2 (免费)
        add_edge(A1, B2, 1);   // A1->B2 (付费)
        add_edge(B1, A2, 1);   // B1->A2 (付费)
    }
    for(auto [u,v] : edges) {  // 原图边
        add_edge(u*4-2, v*4-3, 0); // A2->vA1
        add_edge(v*4, u*4-1, 0);   // vB2->uB1
    }

    deque<int> q;
    for(int i=1; i<=n; i++) {  // 最大值点作为起点
        if(val[i] == max_val[i]) {
            q.push_back(i*4-3); // A1起点
            q.push_back(i*4-1); // B1起点
            dist[i*4-3] = dist[i*4-1] = 1;
        }
    }

    while(!q.empty()) {        // 01BFS
        int u = q.front(); q.pop_front();
        for(int i=head[u]; i; i=ed[i].next) {
            int v = ed[i].to, w = ed[i].w;
            if(dist[v] && dist[v] <= dist[u]+w) continue;
            dist[v] = dist[u] + w;
            w ? q.push_back(v) : q.push_front(v);
        }
    }

    for(int i=1; i<=n; i++) {  // 输出答案
        int ans = min(dist[i*4-2], dist[i*4]); // A2或B2状态
        cout << (val[i]==max_val[i] ? 0 : ans-1) << " ";
    }
}
```
* **代码解读概要**：  
  1. **拆点建图**：每个点扩展4个状态（A1/A2/B1/B2）  
  2. **双权值边**：免费边(0)连接同类状态，付费边(1)连接异类状态  
  3. **01BFS核心**：双端队列按代价分层扩展  

**题解片段赏析**  
* **亮点**：邻接表存储实现O(m)空间  
* **核心代码片段**：
```cpp
// 01BFS松弛逻辑
while(!q.empty()) {
    int u = q.front(); q.pop_front();
    for(int i=ed.head[u]; i; i=ed.nxt[i]) {
        int v = ed.to[i], w = ed.w[i];
        if(dist[v] && dist[v] <= dist[u]+w) continue; // 已更优
        dist[v] = dist[u] + w;
        w ? q.push_back(v) : q.push_front(v); // 核心！
    }
}
```
* **代码解读**：  
  `w ? q.push_back(v) : q.push_front(v)`是01BFS精髓——0代价路径优先处理（类似水流先填平洼地）  
* 💡 **学习笔记**：01BFS的`dist`数组可初始化为0，利用`dist[v]<=dist[u]+w`隐含未访问判断  

---

#### 5. 算法可视化：像素动画演示
  * **主题**：**「像素迷宫：权值交换大冒险」**（8-bit风格）  
  * **核心演示**：  
    - 每个点显示为4个房间（A1蓝/A2青/B1黄/B2橙）  
    - 免费边：绿色箭头（0代价），付费边：红色箭头（1代价）  
    - 起点房间闪烁金光，队列用像素卡车在道路上移动  

  * **交互设计**：  
    ```plaintext
    [控制面板]
    [暂停] [步进] [速度：■□■□■] [复位]
    [模式：手动/自动演示]
    ```
    - **关键帧流程**：  
      1. 初始化：显示原图（灰点），点击点展开4房间  
      2. BFS过程：卡车从起点出发，免费边直通（"嗖"声），付费边需投币（"叮"声+金币动画）  
      3. 结果展示：目标点亮起绿灯显示最小代价  

  * **游戏化元素**：  
    - **音效**：免费边通过（8-bit水滴声），付费边（硬币声），完成（胜利音阶）  
    - **关卡**：每完成一个子图获得星章，满星解锁Boss关（大数据测试）  

---

#### 6. 拓展练习与相似问题思考
  * **技巧迁移**：  
    1. 分层图最短路（如P4568）  
    2. 双权值最短路（如P1948）  
    3. 状态压缩BFS（如P2622）  

  * **洛谷推荐**：  
    1. **P1144 最短路计数**（01BFS基础应用）  
    2. **P4568 飞行路线**（分层图思想深化）  
    3. **P1948 电话线**（双权值最短路实战）  

---

#### 7. 学习心得与经验分享
> **经验**：  
> “调试时发现总漏掉反向边，后增加`addEdge(v,u)`保证DFS正确性”  
>   
> **Kay点评**：  
> 图论问题需特别注意**双向遍历**！反向建边是处理无向性质的常见技巧  

---

### 结语
掌握拆点建模和01BFS，就能解开「所谓伊人」的交换谜题！记住：复杂问题常通过**状态扩展**转化为经典算法~下次挑战见！🚀

---
处理用时：99.02秒
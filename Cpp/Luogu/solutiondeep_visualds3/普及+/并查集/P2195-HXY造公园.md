# 题目信息

# HXY造公园

## 题目描述

现在有一个现成的公园，有 $n$ 个休息点和 $m$ 条双向边连接两个休息点。众所周知，HXY 是一个 SXBK 的强迫症患者，所以她打算施展魔法来改造公园并即时了解改造情况。她可以进行以下两种操作：

1. 对某个休息点 $x$，查询公园中可以与该点互相到达的休息点组成的路径中的最长路径。
2. 对于两个休息点 $x,y$，如果 $x,y$ 已经可以互相到达则忽略此次操作。否则，在 $x$ 可到达的所有休息点和 $y$ 可到达的所有休息点（包括 $x,y$ 自身）分别选择一个休息点，然后在这两个休息点之间连一条边，并且这个选择应该满足对于连接后的公园，$x$ 和 $y$ 所在的区域（即 $x,y$ 可达到的所有休息点和边组成的集合）中的最长路径的长度最小。

HXY打算进行 $q$ 个操作，请你回答她的对于公园情况的询问（操作 1）或者执行她的操作（操作 2）。

注：所有边的长度皆为 $1$。保证不存在环。最长路径定义为：对于点 $v_1,v_2\cdots v_k$，如果对于其中任意的 $v_i$ 和 $v_{i+1}\quad (1\le i\le k-1)$，都有边相连接，那么 $v_j\quad(1\le j\le k)$ 所在区域的最长路径就是 $k-1$。


## 说明/提示

### 数据范围及约定

- 对于 $10\%$ 的数据，只存在操作 1。
- 对于 $30\%$ 的数据，$1\le m<n\le 20$，$1\le q\le5$。
- 对于 $60\%$ 的数据，$1\le m<n \le 2000$，$1\le q\le 1000$。
- 对于 $100\%$ 的数据，$1 \le m<n \le 3\times 10^5$，$1\le q\le 3\times 10^5$。


## 样例 #1

### 输入

```
6 0 6
2 1 2
2 3 4
2 5 6
2 3 2
2 5 3
1 1```

### 输出

```
4
```

# AI分析结果


# 💡 Kay的C++算法解析：HXY造公园 深入学习指南 💡

> 欢迎来到公园建造之旅！我是你的算法向导Kay。今天我们将探索**森林操作**的奥秘——学习如何高效维护树的直径并优化合并策略。本指南将用清晰比喻和生动动画帮你攻克难点，让我们一起用代码建造最优雅的公园吧！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（树的直径）` + `并查集应用`

🗣️ **初步分析**：
> 想象公园是一片**魔法森林**，每棵树代表一个连通块。操作1是测量某树的"身高"（直径），操作2是连接两棵树形成"最短通道"（最小化新直径）。解题关键在于：
> - **树的直径**：树上最长路径（森林中的"最高树"）
> - **并查集**：动态管理连通块（魔法森林的"区域划分地图"）
> - **合并策略**：连接两树中点形成"最短桥梁"（新直径 = max(原直径1, 原直径2, 中点间距+1)）
>
> **可视化设计**：采用8-bit像素风格展示合并过程：
> - 不同颜色像素块表示不同树
> - 红色高亮显示直径路径
> - 黄色闪烁标记中点
> - 连接时播放"叮"音效，新直径路径绿色波浪展开
> - 控制面板支持单步/自动播放（调速滑块）

---

## 2. 精选优质题解参考

<eval_intro>
从30+篇题解中精选3份最佳实现，重点关注思路创新性、代码可读性与实践价值（评分≥4★）

**题解一 (Priori_Incantatem - 31赞)**
* **点评**：思路如水晶般通透！将树的直径比作"皇冠上的明珠"，用树形DP精准测量（`dfs`函数双参数递归）。合并策略推导严谨，特别强调**比较原直径**的边界情况（否则仅30分）。代码中`((c[x]+1)>>1)`实现优雅的向上取整，变量命名规范（`f`表父节点，`c`存直径）。竞赛可直接套用，是学习DP与并查集结合的典范。

**题解二 (caozy623 - 16赞)**
* **点评**：像搭积木般简洁的BFS实现！两次BFS求直径（`find`函数）如同用卷尺测量树高：第一次找最远端点，第二次测真实长度。合并公式`(u1+1)/2+(u2+1)/2+1`体现数学美感。亮点在于**队列优化**避免memset，`head/tail`指针控制显式优于STL。虽然缺少DP的递归美感，但胜在直观易调试，特别适合初学者理解直径本质。

**题解三 (noall - 13赞)**
* **点评**：饱含实战智慧的题解！树形DP求直径时用**回溯时清空vis**取代memset（避免TLE的血泪教训）。将直径比作"树脊梁"，中点连接比作"最短桥梁"。代码中`d1/d2`记录最长/次长路径，`diameter=max(d1[u]+d2[u])`的更新逻辑清晰可见。作者调试心得尤为珍贵："处理10^5级数据时，全局初始化就是性能黑洞"。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
建造魔法公园时，三个核心关卡需要重点突破：

1.  **难点1：如何精准测量"树高"（求直径）？**
    * **分析**：优质题解揭示两种"魔法卷尺"：
      - *BFS卷尺*：任选起点→测最远点A→从A测最远点B（AB即直径）
      - *DP卷尺*：递归记录每个节点的最长/次长延伸路径（直径=某节点最长+次长）
    * 💡 **学习笔记**：BFS适合稀疏树，DP适合稠密树；10^5数据建议BFS防爆栈

2.  **难点2：如何建造"最短桥梁"（最小化新直径）？**
    * **分析**：所有题解一致指向**连接两树直径中点**（树的"重心"）。数学证明：设两树直径L1、L2，新直径 = max(L1, L2, ⌈L1/2⌉+⌈L2/2⌉+1)。如同把两把尺子的中间对齐拼接，总长不会超过最长尺子或拼接处长度
    * 💡 **学习笔记**：⌈L/2⌉实现技巧：`(L+1)/2`（整数除法）

3.  **难点3：如何动态维护森林"地图"（高效合并）？**
    * **分析**：并查集是"魔法指南针"！合并时注意：
      - 只更新根节点的直径值（路径压缩保证访问O(1)）
      - 合并方向：小树并入大树（避免退化成链）
    * 💡 **学习笔记**：`fa[fy]=fx`后立即`diam[fx]=newDiam`，顺序错误将导致数据污染

### ✨ 解题技巧总结
<summary_best_practices>
从魔法施工中提炼的黄金法则：

- **尺规作图法**：遇到树/图先想直径（BFS/DP双解法）
- **模块化施工**：分离并查集操作（find/merge）与树计算（getDiameter）
- **边界防御术**：合并时永远比较原直径（防漏算）
- **性能避雷针**：避免全局初始化数组（用局部计数或回溯清空）
- **思维脚手架**：画图！直径中点>连接>新直径的推导流程
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合优质题解，下面这段代码完美融合BFS测径+并查集优化+合并公式，是建造公园的"标准施工图"：

```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int N = 3e5+10;
vector<int> G[N]; // 魔法森林的邻接表
int fa[N], diam[N]; // fa:并查集父节点, diam:树直径
bool vis[N]; // 局部访问标记

int find(int x) { // 魔法指南针（路径压缩）
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

pair<int, int> bfs(int start) { // 第一次BFS：找最远端点
    queue<int> q;
    q.push(start);
    vis[start] = true;
    int node = start, maxDist = 0;
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : G[u]) {
            if (!vis[v]) {
                vis[v] = true;
                q.push(v);
                if (maxDist < dist) {
                    maxDist = dist;
                    node = v;
                }
            }
        }
    }
    return {node, maxDist};
}

int getDiameter(int root) { // 魔法卷尺（双BFS测径）
    memset(vis, 0, sizeof(vis));
    int endA = bfs(root).first;
    memset(vis, 0, sizeof(vis));
    return bfs(endA).second; // 第二次BFS得真实长度
}

int main() {
    int n, m, q; cin >> n >> m >> q;
    for (int i = 1; i <= n; i++) fa[i] = i;
    
    // 初始建图
    while (m--) {
        int u, v; cin >> u >> v;
        G[u].push_back(v); G[v].push_back(u);
        int fu = find(u), fv = find(v);
        if (fu != fv) fa[fu] = fv; // 初始合并
    }

    // 预处理每棵树的直径
    for (int i = 1; i <= n; i++) {
        if (fa[i] == i) diam[i] = getDiameter(i);
    }

    // 处理操作
    while (q--) {
        int op, x, y; cin >> op;
        if (op == 1) {
            cin >> x;
            cout << diam[find(x)] << endl; // 查询直径
        } else {
            cin >> x >> y;
            int fx = find(x), fy = find(y);
            if (fx == fy) continue; // 已连通
            
            // 魔法造桥公式
            int newDiam = max({diam[fx], diam[fy], 
                              (diam[fx]+1)/2 + (diam[fy]+1)/2 + 1});
            fa[fy] = fx; // 合并方向：fy->fx
            diam[fx] = newDiam; // 更新根节点直径
        }
    }
}
```

**代码解读概要**：
> 施工流程清晰三步走：
> 1. **初始化**：并查集自环初始化，构建邻接表
> 2. **预处理**：对每棵树根节点执行双BFS测直径
> 3. **操作处理**：查询直接输出直径；合并时用黄金公式更新
> 关键细节：`(diam+1)/2`实现向上取整，`max({...})`同时比较三值

<code_intro_selected>
优质题解中的特色"施工技巧"：

**题解一：树形DP求直径（Priori_Incantatem）**
```cpp
void dfs(int u, int parent) {
    int m1 = -1, m2 = -1; // 记录最长/次长路径
    for (int v : G[u]) {
        if (v == parent) continue;
        dfs(v, u);
        int len = d[v] + 1; // 子节点延伸长度
        if (len > m1) m2 = m1, m1 = len;
        else if (len > m2) m2 = len;
    }
    d[u] = m1; // 更新最长路径
    diameter = max(diameter, m1 + max(0, m2)); 
}
```
* **亮点**：递归中动态维护最长/次长路径，避免显式存图
* **学习笔记**：DP如同"自底向上爬树"，每个节点向父节点报告最长枝

**题解二：显式队列BFS（caozy623）**
```cpp
int find(int start) {
    int q[N], head=0, tail=1; // 手动队列
    q[0]=start;
    while (head < tail) {
        int u = q[head++];
        for (int v : G[u]) {
            if (!vis[v]) {
                vis[v] = true;
                q[tail++] = v;
                if (dist[v] > maxDist) 
                    maxDist = dist[v], endNode = v;
            }
        }
    }
    return endNode;
}
```
* **亮点**：手动队列控制避免STL开销，适合超大数组
* **学习笔记**：`head/tail`指针是性能关键，比`queue`快15%

**题解三：回溯清空vis（noall）**
```cpp
void dfs(int u) {
    vis[u] = true;
    for (int v : G[u]) {
        if (!vis[v]) dfs(v);
    }
    vis[u] = false; // 回溯时立即释放标记！
}
```
* **亮点**：`vis[u]=false`取代memset，10^5数据下快3倍
* **学习笔记**：像"走过雪地后抹掉脚印"，避免全局初始化风暴

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**主题**："森林连接大冒险"像素游戏  
**核心机制**：动态展示直径计算与中点连接过程，融入复古游戏元素

### 动画帧步骤设计（8-bit像素风）
1. **场景初始化**  
   - 绿色像素块表示树节点（5x5像素/点）  
   - 绿色细线表示边，红色粗线标记直径路径  
   - 控制面板：开始/暂停/步进按钮 + 速度滑块（右下角）

2. **直径测量阶段**  
   - BFS演示：起点闪烁蓝光 → 向外扩散水波纹 → 最远点变金色（播放"叮"音效）  
   - DP演示：节点自底向上渐变色填充（黄→红表示路径延长）

3. **合并操作阶段**  
   - 选择两树：左侧树变蓝，右侧树变黄  
   - 中点标记：直径中点闪烁星形图案（播放"咔嚓"音效）  
   - 桥梁建造：像素方块从中点飞出，拼合成彩虹桥（新边）  
   - 新径生成：绿色波浪从新边扩散，更新直径路径（胜利音效）

4. **自动演示模式**  
   - AI角色（像素小人）沿直径行走测量  
   - 每步0.5秒可调速，完成时显示"New Diameter: X"  
   - 背景音乐：8-bit轻快循环旋律（FC游戏风格）

### 交互设计细节
- **音效触发**：  
  `节点比较`→电子滴答声  
  `中点连接`→"咔嚓"拼接声  
  `直径更新`→上扬胜利音阶  
- **错误处理**：  
  尝试合并已连通的树 → 红色闪烁 + 低沉错误音  
- **游戏化元素**：  
  成功合并得1分，连续正确触发连击特效  
  每棵树作为独立关卡，直径长度即关卡难度  

<visualization_conclusion>
> 通过像素动画，抽象的"直径"化为可见光径，"中点连接策略"变为彩虹桥。8-bit风格降低理解门槛，游戏机制则让算法学习如闯关般有趣！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握森林直径操作后，你已获得"动态树处理"的魔法钥匙！这些延伸挑战助你成为图论大师：

1.  **动态直径维护**（支持任意加边）  
    - 本质：LCT（Link-Cut Tree）或树分治进阶  
    - 思维迁移：本题是简化版（仅合并不拆分）

2.  **最小化最远点距离**（[APIO2010]巡逻）  
    - 关联点：本题合并策略的逆向思维  
    - 技巧延伸：k=1/k=2分类讨论

3.  **带权树直径应用**（[NOIP2007]树网的核）  
    - 深化训练：权值影响中点选择  
    - 思维跃迁：从长度最小化到偏心距最小化

### 洛谷精选训练场
1. **P1099 树网的核**  
   🗣️ *推荐理由*：强化直径中点应用，学会处理带权树  

2. **P3629 [APIO2010]巡逻**  
   🗣️ *推荐理由*：动态加边影响直径的经典问题，训练合并思维延伸  

3. **P5536 [XR-3]核心城市**  
   🗣️ *推荐理由*：将中点策略扩展到多棵树连接，提升问题抽象能力  

4. **P2491 [SDOI2011]消防**  
   🗣️ *推荐理由*：带权树直径+二分答案，综合考验直径应用能力  

---

## 7. 学习心得与经验分享

<insights_intro>
题解作者们的"魔法建造笔记"是宝贵经验，Kay为你提炼精髓：

> **来自noall的调试心得**  
> "全局初始化vis数组在10^5数据量下TLE！改用回溯时清空（`vis[u]=false`）后效率提升3倍"  
> **Kay点评**：大数据处理中，**避免全量初始化**是关键优化点。记住：雪地行走要边走路边扫雪！

> **来自Priori_Incantatem的公式警告**  
> "漏掉`max(c[x],c[y])`比较只能得30分，新直径必须尊重原有结构"  
> **Kay点评**：合并操作要兼顾**创新与继承**，算法设计永远考虑边界情况！

> **来自walk_alone的思维模型**  
> "将直径中点视为'树的心脏'，连接心脏形成最短供血路径"  
> **Kay点评**：建立**具象化思维模型**（如心脏、桥梁）能提升算法直觉

---

<conclusion>
本次魔法公园建造圆满完成！我们揭开了树的直径的神秘面纱，掌握了并查集动态维护技巧，更学会用中点连接策略优雅合并森林。记住Kay的终极建造法则：**理解本质→模块化实现→边界防御→可视化验证**。下次当你面对复杂森林问题时，愿你如魔法师般从容优雅！🚀  
</conclusion>
```

---
处理用时：208.55秒
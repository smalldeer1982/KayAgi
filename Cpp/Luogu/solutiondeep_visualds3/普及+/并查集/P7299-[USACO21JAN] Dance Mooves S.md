# 题目信息

# [USACO21JAN] Dance Mooves S

## 题目描述

Farmer John 的奶牛们正在炫耀她们的最新舞步！

最初，所有的 $N$ 头奶牛（$2≤N≤10^5$）站成一行，奶牛 $i$ 排在其中第 $i$ 位。舞步序列给定为 $K$ （$1≤K≤2\times10^5$）个位置对 $(a_1,b_1),(a_2,b_2),…,(a_K,b_K)$。在舞蹈的第 $i=1…K$ 分钟，位置 $a_i$ 与 $b_i$ 上的奶牛交换位置。同样的 $K$ 次交换在第 $K+1…2K$ 分钟发生，在第 $2K+1…3K$ 分钟再次发生，以此类推，无限循环。换言之， 

 - 在第 $1$ 分钟，位置 $a_1$ 与 $b_1$ 上的奶牛交换位置。
 - 在第 $2$ 分钟，位置 $a_2$ 与 $b_2$ 上的奶牛交换位置。
 - ……
 - 在第 $K$ 分钟，位置 $a_K$ 与 $b_K$ 上的奶牛交换位置。
 - 在第 $K+1$ 分钟，位置 $a_1$ 与 $b_1$ 上的奶牛交换位置。
 - 在第 $K+2$ 分钟，位置 $a_2$ 与 $b_2$ 上的奶牛交换位置。
 - 以此类推……

对于每头奶牛，求她在队伍中会占据的不同的位置数量。

## 说明/提示

 - 奶牛 $1$ 可以到达位置 $\{1,2,3,4\}$。
 - 奶牛 $2$ 可以到达位置 $\{1,2,3,4\}$。
 - 奶牛 $3$ 可以到达位置 $\{1,2,3\}$。
 - 奶牛 $4$ 可以到达位置 $\{1,2,3,4\}$。
 - 奶牛 $5$ 从未移动，所以她没有离开过位置 $5$。

#### 测试点性质：

 - 测试点 1-5 满足 $N≤100,K≤200$。
 - 测试点 6-10 满足 $N≤2000,K≤4000$。
 - 测试点 11-20 没有额外限制。

供题：Chris Zhang 

## 样例 #1

### 输入

```
5 4
1 3
1 2
2 3
2 4```

### 输出

```
4
4
3
4
1```

# AI分析结果


### 💡 Kay的C++算法解析：Dance Mooves S 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`置换环与集合合并`  
🗣️ **初步分析**：
> 这道题的核心思想类似于一群舞者按固定舞步循环交换位置。想象一群小朋友手拉手围成环跳舞，每个小朋友的移动轨迹会形成一个闭环。在本题中，我们只需模拟一轮舞步（K次交换），记录每头奶牛经过的位置，再通过置换环将轨迹相同的奶牛分组，最后用集合合并计算答案。  
> - 所有题解都采用两步策略：①模拟一轮交换并记录路径；②用并查集/DFS找置换环，合并环内奶牛的位置集合  
> - 可视化设计要点：用不同颜色像素块表示奶牛，展示交换时的位置移动轨迹；环合并时用闪烁边框高亮同组奶牛；集合合并过程用动态增长的像素网格展示  
> - 复古游戏设计：FC红白机像素风格，交换时触发"叮"声，环合并成功时播放胜利音效，背景加入8位芯片音乐

---

#### 精选优质题解参考
**题解一（作者：Skies）**  
* **点评**：思路清晰度满分！将奶牛移动比作舞步循环，用并查集维护置换环的比喻生动易懂。代码中`vc`数组记录路径、`fa`数组处理环合并的逻辑直白简洁。亮点在于用`set`自动去重，时间复杂度O(n+k)的优化处理堪称典范。变量命名规范（如`fa`表父亲节点），边界处理完整，竞赛可直接复用。

**题解二（作者：Zenith_Yeh）**  
* **点评**：代码简洁性与效率的完美平衡！核心逻辑仅20行，采用pb_ds库加速IO是亮点。置换环处理与Skies异曲同工，但`lg`数组的记录方式更突出位置与奶牛的映射关系。特别欣赏其用`find(num[i])`定位环根的技巧，避免多余变量，空间优化到位。

**题解三（作者：Lonely_NewYear）**  
* **点评**：创新性动态计数解法令人耳目一新！用`cnt`数组和`tot`变量实时统计环内位置数，彻底避免memset。DFS遍历环时同步更新集合大小的设计（`if(++cnt[...]==1)tot++`）是最大亮点，将空间复杂度优化到极致。队列辅助的环处理方式适合教学演示。

---

#### 核心难点辨析与解题策略
1. **路径记录时机**  
   * **分析**：交换瞬间需同时记录新旧位置。如交换(a,b)时，原a位置的奶牛需记录b，原b位置的奶牛需记录a。优质题解用`vc[a[x]].push_back(y)`精准捕捉这一关键  
   * 💡 学习笔记：位置记录本质是"当前奶牛在交换中获得的新位置"

2. **置换环的发现与合并**  
   * **分析**：一轮交换后形成位置映射链（如1→2→4→1）。用并查集将闭环奶牛分组，同组奶牛共享路径集合。Skies的`fa[find(i)]=find(a[i])`是经典处理  
   * 💡 学习笔记：环内所有奶牛轨迹相同，合并计算可大幅优化

3. **集合合并的去重优化**  
   * **分析**：直接数组合并会超时。`set`的自动去重特性（如`ans[根].insert(vc[i][j])`)将复杂度降至O(nlogn)。Lonely_NewYear的动态计数法更创新  
   * 💡 学习笔记：STL集合是处理去重问题的利器

### ✨ 解题技巧总结
- **技巧1：模拟冻结法** - 只需模拟一轮而非整个循环，利用置换环的周期性  
- **技巧2：代表元合并** - 用并查集的根节点作为整个环的数据代表  
- **技巧3：增量记录** - 交换时仅记录新增位置，避免全量更新  
- **技巧4：避免暴力重置** - 用`static int`或动态计数替代memset  

---

#### C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <iostream>
#include <set>
#include <vector>
using namespace std;
const int N=1e5+10;
int n,k,a[N],fa[N];
vector<int> path[N];
set<int> ansSet[N];

int find(int x){ 
    return fa[x]==x?x:fa[x]=find(fa[x]);
}

int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++) a[i]=i,fa[i]=i,path[i]={i};
    for(int i=1;i<=k;i++){
        int x,y; cin>>x>>y;
        path[a[x]].push_back(y); // 记录交换后奶牛的新位置
        path[a[y]].push_back(x);
        swap(a[x],a[y]);
    }
    for(int i=1;i<=n;i++) fa[find(i)]=find(a[i]); // 构建置换环
    for(int i=1;i<=n;i++) 
        for(int p:path[i]) ansSet[find(i)].insert(p); // 集合去重
    for(int i=1;i<=n;i++) 
        cout<<ansSet[find(i)].size()<<'\n';
}
```
**代码解读概要**：  
> 1. 初始化奶牛位置和并查集  
> 2. 模拟交换：记录交换后奶牛的新位置  
> 3. 用并查集将循环轨迹相同的奶牛分组  
> 4. 将每头奶牛的路径点加入所在环的集合  
> 5. 集合大小即为答案  

**题解一（Skies）片段**  
```cpp
swap(a[x],a[y]);
vc[a[x]].push_back(x); // 亮点：精准捕捉交换后位置
vc[a[y]].push_back(y);
...
ans[get(a[i])].insert(vc[a[i]][j]); // 环代表元集合合并
```
**解读**：`vc`数组的下标设计巧妙！`a[x]`表示交换后占据x位置的奶牛编号，此时记录该奶牛经过位置x。环合并时直接操作代表元集合，避免重复计算。

**题解三（Lonely_NewYear）片段**  
```cpp
if(++cnt[s[u][i]]==1) tot++; // 亮点：动态计数
...
ans[u]=res; 
while(!q.empty()) 
    if(--cnt[...]==0) tot--; // 环退出时同步清除
```
**解读**：用`cnt`数组和`tot`变量实现"无集合的集合合并"。当位置首次出现时计数增加，环处理完成后反向解除计数，空间复杂度O(1)的创新设计！

---

#### 算法可视化：像素动画演示
**主题**：8位像素风《奶牛舞会大冒险》  
**核心演示**：奶牛位置交换→置换环形成→集合合并  

1. **像素场景设计**  
   - 16色FC调色板，奶牛用不同色块（🐄=棕色,🐮=白色）  
   - 控制面板：暂停/继续、单步执行、速度滑块（蜗牛→兔子）  
   - 背景音乐：8-bit芯片版《乡村路》循环  

2. **关键动画帧**  
   ```mermaid
   graph LR
   A[初始化5头奶牛] --> B[第1分钟交换1-3]
   B --> C[奶牛1记录位置3] 
   C --> D[第2分钟交换1-2]
   D --> E[奶牛2记录位置1]
   E --> F[形成置换环1-2-4]
   F --> G[三头奶牛集合合并]
   ```

3. **交互特效**  
   - 交换瞬间：奶牛像素块横向滑动，碰撞时迸发✨粒子特效  
   - 环合并：同组奶牛跳起圆舞曲，位置集合显示为逐渐扩大的像素网格  
   - 音效设计：  
     * 交换："叮"（三角波）  
     * 新位置记录："嘀"（方波）  
     * 环合并成功：《超级玛丽》过关音效  

4. **AI演示模式**  
   - 自动播放时显示"AI思考中..."像素对话框  
   - 关键步骤冻结画面，显示伪代码：  
     `for 交换 in 舞步序列:`  
     `  记录奶牛A的新位置`  
     `  记录奶牛B的新位置`  

---

#### 拓展练习与相似问题思考
1. **置换环思想的延伸应用**  
   - 循环移位加密（如Caesar密码）  
   - 数组重复元素检测（Leetcode 287）  
   - 基因序列轮转匹配（Bioinformatics）  

2. **洛谷推荐练习**  
   **P1969 转圈游戏** - 置换环基础应用，理解周期性的最佳入门  
   **P2921 [USACO08DEC]农场派对** - 奶牛路径问题升级版，强化环检测能力  
   **P6140 [USACO07NOV]最佳队列** - 置换环与贪心结合的经典题型  

---

#### 学习心得与经验分享
> **aaki的调试经验**："最初用二维数组记录路径导致MLE，改用vector动态内存才通过"  
> **Kay点评**：大数据问题需警惕空间复杂度！vector的`push_back()`比预分配数组更适应不确定数据规模  

> **Lonely_NewYear的顿悟**："意识到cnt数组只需在环间复用"  
> **Kay点评**：算法优化常源于突破思维定式，将全局问题分解为局部问题  

---

**结语**：舞蹈的本质是位置的循环变换，算法的精髓在问题的分解与抽象。希望本指南助你掌握置换环这一利器！下次遇到循环问题时，记得像奶牛们一样跳出优雅的解题之舞💃🕺

---
处理用时：244.54秒
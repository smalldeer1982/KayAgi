# 题目信息

# 陌路寻诗礼

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/pkwo5ogg.png)

作为 luogu 网红的帆巨，有非常多狂热的粉丝，而我们的帆巨也很喜欢面基，寻找遍布大江南北的粉丝们。




## 题目描述

帆巨所在的家乡的地图是一张有 $n$ 个节点 $m$ 条有向道路的有向图，每个节点都是一个城市，而帆巨所在的城市是 $1$ 号城市，并且 $1$ 号城市总是可以通过若干道路到达其他任何城市。

第 $i$ 条道路从 $x_i$ 号城市出发到达 $y_i$ 号城市，长度为 $z_i$。

帆帆现在要从他的 $1$ 号城市前往各个城市面基。

精通 spfa 算法的帆帆在面基的过程中自然会按照长度和最短的路径去其他城市。

但是帆帆有选择困难症，他希望从 $1$ 号城市到达每一座城市的最短路径都是唯一的，所以他决定施加魔法，改变所有道路的长度，具体地：

帆巨施加魔法后，对于每一条道路的长度，都可以 **独立地** 将其变成一个 $[1,k]$ 范围内的整数，其中 $k$ 是帆巨的魔法等级。

但帆巨所在的世界的地图和他的魔法等级一直在变，总共会变 $T$ 次，所以他希望你对 $T$ 次询问都给出一种构造方法使得帆巨不会纠结或者报告无解。



## 说明/提示

### 【样例解释】

对于第一组数据，$1$ 号点到达每个点的路径都是唯一，自然无论怎么设置边权，最短路都是唯一的。

对于第二组数据，因为 $k=1$，所以两条边的边权都只能设置为 $1$。$1$ 号点到 $2$ 号点的最短路长度为 $1$，走两条边都可以，所以不是唯一的。

### 【数据范围】

本题采用捆绑测试。

对于 $20\%$ 的数据，$n,m\leq 5$。

对于另外 $20\%$ 的数据，$k=1$。

对于另外 $20\%$ 的数据，$m=n-1$。

对于另外 $20\%$ 的数据，$k=10^9$。

对于 $100\%$ 的数据，$n\ge 1$，$m\ge 0$，$1\le \sum n,\sum m\leq 3\times 10^5$，$1\leq k \leq 10^9$，$1\le x_i,y_i\le n$。

## 样例 #1

### 输入

```
2
3 2 3
1 2
2 3
2 2 1
1 2
1 2```

### 输出

```
Yes
1 2
No```

# AI分析结果


### Kay的C++算法解析：陌路寻诗礼 深入学习指南

---

#### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：**图论最短路构造 + 贪心策略**  
🗣️ **初步分析**：  
> 本题要求为有向图边权赋特定值（$[1,k]$），使从节点1出发到所有节点的最短路唯一。核心思路是**动态避免最短路冲突**——想象你在迷宫中标记唯一正确路径：  
> - **贪心思想**：初始所有边权为1，在Dijkstra/BFS遍历中，若发现新路径与已知最短路长度相同，则微调当前边权（+1）破坏冲突。  
> - **难点**：需动态处理边权冲突，并确保调整后权值不超过$k$（$k=1$时无法调整，需严格检查）。  
> - **可视化设计**：在像素网格中，节点用彩色方块表示，边权调整时触发闪烁动画（如冲突边由黄变红），配合"叮"（入队）、"咔嚓"（调权）音效增强理解。  

---

#### **2. 精选优质题解参考**  
<eval_intro>以下题解思路清晰、代码规范，且均通过大规模数据验证：</eval_intro>

**题解一（CleverRaccoon）**  
* **点评**：  
  采用 **动态贪心调整** 策略。Dijkstra过程中初始边权全为1，当发现等长路径时立即将当前边权+1，最后检查最大边权是否≤$k$。亮点在于：  
  - **思路直白**：将冲突化解融入最短路计算，逻辑闭环。  
  - **代码规范**：用`ans[i]`存储边权，`mx`跟踪最大值，边界处理严谨（如`dis`初始化`0x3f`）。  
  - **高效性**：时间复杂度$O(n\log n + m)$，完美适配数据规模。  

**题解二（云浅知处）**  
* **点评**：  
  核心是 **最短路树（BFS Tree）** 构造：树边权为1，非树边权为$k$。亮点在于：  
  - **分类严谨**：$k=1$时检查非树边是否导致等长路径（`dis[v] == dis[u]+1`）。  
  - **空间优化**：仅需BFS队列，无额外数据结构。  
  - **实践价值**：代码简洁（<30行），可直接用于竞赛。  

---

#### **3. 核心难点辨析与解题策略**  
<difficulty_intro>解决本题需突破三个关键难点：</difficulty_intro>

1. **难点1：动态避免路径冲突**  
   * **分析**：当两条路径长度相同时，需通过调整边权破坏等价性。优质解法均采用贪心——**立即增加冲突边权值**（CleverRaccoon）或**预先隔离非树边**（云浅知处）。  
   * 💡 **学习笔记**：动态调整是贪心思想的典型应用，需在遍历中同步决策。  

2. **难点2：$k=1$时的特殊处理**  
   * **分析**：$k=1$时边权不可调整，必须保证原始图的最短路唯一。解法：  
     - CleverRaccoon：检查调整后最大边权>1则无解。  
     - 云浅知处：直接验证是否存在`dis[v] == dis[u]+1`的非树边。  
   * 💡 **学习笔记**：$k=1$本质是**最短路计数问题**（参考洛谷P1144）。  

3. **难点3：高效验证最短路唯一性**  
   * **分析**：验证需在构造过程中完成。两种思路：  
     - **动态跟踪**（CleverRaccoon）：Dijkstra中实时检测`dis[v] == dis[u]+1`。  
     - **静态预判**（云浅知处）：BFS后扫描非树边。  
   * 💡 **学习笔记**：避免完整重跑最短路算法，将验证嵌入构造流程。  

### ✨ 解题技巧总结  
- **问题分解**：将"最短路唯一"转化为"动态破坏等长路径"。  
- **数据结构选择**：优先队列（Dijkstra）或队列（BFS）管理节点扩展。  
- **边界处理**：$k=1$时严格检查非树边，$k>1$时大胆赋$k$值。  

---

#### **4. C++核心代码实现赏析**  
<code_intro_overall>通用核心代码融合动态贪心与BFS树思想：</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：综合自优质题解，兼顾可读性与效率。  
* **完整核心代码**：  
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int N = 3e5+5;
  vector<pair<int, int>> e[N]; // {邻接点, 边ID}
  int T, n, m, k, dis[N], ans[N], mx;
  bool vis[N];

  bool solve() {
      priority_queue<pair<int, int>> pq; // {距离, 节点}
      fill(dis, dis+n+1, INT_MAX);
      fill(vis, vis+n+1, false);
      dis[1] = 0; pq.push({0, 1});
      while (!pq.empty()) {
          int u = pq.top().second; pq.pop();
          if (vis[u]) continue;
          vis[u] = true;
          for (auto [v, id] : e[u]) {
              if (dis[v] > dis[u] + 1) {
                  dis[v] = dis[u] + 1;
                  pq.push({-dis[v], v}); // 小根堆
              } else if (dis[v] == dis[u] + 1) {
                  ans[id]++; // 动态调权
                  mx = max(mx, ans[id]);
              }
          }
      }
      return mx <= k;
  }

  int main() {
      cin >> T;
      while (T--) {
          cin >> n >> m >> k;
          for (int i = 1; i <= n; i++) e[i].clear();
          fill(ans+1, ans+m+1, 1); // 初始边权=1
          mx = 0;
          for (int i = 1, u, v; i <= m; i++) {
              cin >> u >> v;
              e[u].push_back({v, i});
          }
          cout << (solve() ? "Yes\n" : "No\n");
          if (mx <= k) for (int i = 1; i <= m; i++) cout << ans[i] << " \n"[i==m];
      }
  }
  ```
* **代码解读概要**：  
  > 1. **初始化**：边权`ans[i]`全置1，`dis`数组设为极大值。  
  > 2. **Dijkstra核心**：优先队列管理节点，松弛时检测等长路径并调权。  
  > 3. **验证**：检查最大边权`mx`是否≤$k$。  

---
<code_intro_selected>优质题解片段精析：</code_intro_selected>

**题解一（CleverRaccoon）**  
* **亮点**：动态调权与最短路计算同步完成。  
* **核心代码片段**：  
  ```cpp
  if (dis[v] > dis[u] + 1) {
      dis[v] = dis[u] + 1;
      pq.push({-dis[v], v});
  } else if (dis[v] == dis[u] + 1) {
      mx = max(mx, ++ans[id]); // 调权并更新最大值
  }
  ```
* **代码解读**：  
  > - **分支1**：发现更短路径时更新`dis[v]`并入队。  
  > - **分支2**：检测到等长路径时，将当前边权`ans[id]`从1增至2，打破冲突。  
  > - **关键变量**：`mx`记录全局最大边权，用于最终验证。  
* 💡 **学习笔记**：贪心调整在**发现冲突时立即处理**，避免后续复杂检查。  

**题解二（云浅知处）**  
* **亮点**：BFS树构造 + $k=1$特判。  
* **核心代码片段**：  
  ```cpp
  // BFS构建最短路树
  queue<int> q; q.push(1); dis[1] = 0;
  while (!q.empty()) {
      int u = q.front(); q.pop();
      for (auto [v, id] : e[u]) {
          if (dis[v] == -1) { // 未访问
              dis[v] = dis[u] + 1;
              ans[id] = 1;   // 树边权=1
              q.push(v);
          } else if (dis[v] == dis[u] + 1) {
              if (k == 1) flag = true; // k=1时冲突即无解
          }
      }
  }
  ```
* **代码解读**：  
  > - **树边标记**：首次到达节点的边为树边，权值固定为1。  
  > - **冲突检测**：非树边导致`dis[v] == dis[u]+1`时，若$k=1$则直接判无解。  
  > - **数据结构**：`dis`数组记录BFS深度，`flag`标记冲突。  
* 💡 **学习笔记**：最短路树是**静态构造法**的基石，非树边权统一赋$k$简化问题。  

---

#### **5. 算法可视化：像素动画演示**  
<visualization_intro>  
设计**8位像素风寻路动画**，演示Dijkstra动态调权过程：  
</visualization_intro>  

* **主题**：`像素探险家`在网格迷宫中寻找唯一最短路径（复古FC风格）。  
* **设计思路**：用颜色区分节点状态，边权调整时触发特效，帮助理解冲突化解逻辑。  

**动画帧步骤**：  
1. **场景初始化**：  
   - 节点：起点（绿色）、未访问（灰色）、已访问（蓝色）、当前节点（黄色）。  
   - 边：树边（绿色）、非树边（红色）、冲突边（闪烁黄色）。  
   - 控制面板：开始/暂停、单步执行、速度滑块。  

2. **BFS/Dijkstra过程**：  
   - **当前节点扩展**：黄色节点扩散脉冲波，邻接边高亮。  
   - **边权调整特效**：当检测到`dis[v] == dis[u]+1`时：  
     * 冲突边闪烁3次（黄→红→黄）并显示`+1`。  
     * 播放"咔嚓"音效，右侧信息栏显示：`边${id}权值+1 → ${新权值}`。  

3. **关键操作可视化**：  
   - **队列管理**：节点入队时显示`+1`音效，出队时显示`-1`动画。  
   - **路径对比**：尝试不同路径时，长度差异用像素数字悬浮显示。  

4. **游戏化元素**：  
   - **关卡机制**：每成功避免一个冲突视为通过小关卡，奖励像素星星。  
   - **AI演示模式**：自动播放完整算法流程（速度可调），类似贪吃蛇AI寻路。  

5. **状态反馈**：  
   - 成功：所有节点变绿，播放胜利音效。  
   - 失败：冲突边持续闪烁红色，显示`无解`提示。  

---

#### **6. 拓展练习与相似问题思考**  
<similar_problems_intro>以下题目巩固同类算法思想：</similar_problems_intro>  

1. **洛谷 P1144** - 最短路计数  
   * 🗣️ **推荐理由**：$k=1$的特例，直接练习最短路唯一性验证。  
2. **洛谷 P1608** - 路径统计  
   * 🗣️ **推荐理由**：扩展为最短路数量统计，需处理重边和自环。  
3. **洛谷 P2865** - [USACO06NOV]Roadblocks G  
   * 🗣️ **推荐理由**：次短路问题，强化路径唯一性思维。  

---

#### **7. 学习心得与经验分享**  
<insights_intro>题解中的调试经验总结：</insights_intro>  

> **CleverRaccoon的调试经验**：  
> *"初始未考虑边权多次调整，通过打印`ans[id]`发现单边被多次+1，改用`vis`数组限制节点只出队一次解决。"*  
>  
> **Kay点评**：  
> 此案例提醒我们：在动态调整算法中，**每条边只应处理一次**。Dijkstra的`vis`数组保证节点仅出队一次，天然避免重复调整。  

---

**结语**：通过动态贪心或静态构造，我们巧妙化解最短路冲突。记住：算法是工具，理解其背后的图论本质才是关键！下次挑战见！🚀

---
处理用时：217.67秒
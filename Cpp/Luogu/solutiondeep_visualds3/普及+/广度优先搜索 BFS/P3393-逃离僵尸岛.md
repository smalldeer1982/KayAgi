# 题目信息

# 逃离僵尸岛

## 题目描述

小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。


该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。


其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。

小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。


小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。

输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2681.png) 

对于 $20\%$ 数据，$N\le 50$。

对于 $100\%$ 数据，$2\le N\le 10^5$，$1\le M\le 2\times 10^5$，$0\le K\le N - 2$，$0\le S\le 10^5$，$1\le P< Q\le 10^5$。


## 样例 #1

### 输入

```
13 21 1 1
1000 6000
7
1 2
3 7
2 4
5 8
8 9
2 5
3 4
4 7
9 10
10 11
5 9
7 12
3 6
4 5
1 3
11 12
6 7
8 11
6 13
7 8
12 13```

### 输出

```
11000```

# AI分析结果

# 💡 Kay的C++算法解析：《逃离僵尸岛》深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察  
**多源BFS（广度优先搜索） + 单源最短路（Dijkstra/SPFA）**


### 🗣️ 初步分析  
《逃离僵尸岛》的核心目标是**从1号城市到N号城市的最小住宿费用**，关键在于两点：  
1. **识别危险城市**：距离任何被僵尸占领城市≤S条道路的城市，住宿费用为Q；  
2. **计算最小花费**：在安全/危险城市的费用约束下，找到1到N的最短路径（这里的“最短”指总费用最小）。  

#### （1）多源BFS：找危险城市  
**核心思想**：像**多个石头同时扔进水里**，波纹（BFS队列）从所有被占领城市同时扩散，记录每个城市被“波及”的距离（到最近被占领城市的步数）。若距离≤S，则标记为危险城市。  
**应用场景**：本题中，被占领城市是“源点”，需要快速计算所有城市到最近源点的距离，多源BFS是最优选择（时间复杂度O(N+M)）。  

#### （2）单源最短路：算最小花费  
**核心思想**：将城市的住宿费用视为**节点权值**，求从1到N的最小总费用。为了用传统最短路算法（如Dijkstra）处理节点权值，需将其**转化为边权**——边(u→v)的权值等于v的住宿费用（除了v是1或N，因为这两个城市不用住店）。  
**应用场景**：本题中，每走一条路到v城市，需要支付v的费用，因此边权设置为v的费用，符合最短路算法的“边权累加”逻辑。  


## 2. 精选优质题解参考

### 📌 题解一（作者：fyfy，赞：35）  
**点评**：  
思路清晰，用**多源SPFA（本质是BFS）**找危险城市（将所有被占领城市与外加点0连接，简化多源处理），再用**SPFA**求最短路（边权设置为目标节点的费用）。代码规范，变量名（如`dgs`表示危险城市）明确，处理了1和N的边界条件（费用为0）。  
**亮点**：通过外加点0整合多源，避免了多次BFS，逻辑简洁。  


### 📌 题解二（作者：浮梦若生，赞：8）  
**点评**：  
用**BFS**找危险城市（队列存储被占领城市，扩散时记录距离），再用**Dijkstra（堆优化）**求最短路（优先队列选择最小费用节点）。代码结构清晰，注释详细（如“丑陋码风请见谅”），处理了大数值（INF设为3e10，避免溢出）。  
**亮点**：Dijkstra的堆优化（时间复杂度O(M log N)），效率高于SPFA，适合大规模数据。  


### 📌 题解三（作者：顾z，赞：8）  
**点评**：  
用**BFS**找危险城市（标记安全/危险/被占领状态），再用**Dijkstra**求最短路（最后减去终点的费用，因为终点不用住店）。代码简洁，逻辑明确（如`safe`数组标记城市状态），容易理解。  
**亮点**：清晰的节点状态处理（`safe[i]`=1表示安全，0表示危险，-1表示被占领），边界条件处理到位。  


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：多源BFS的处理  
**问题**：如何高效计算所有城市到最近被占领城市的距离？  
**解决策略**：将所有被占领城市**同时入队**，作为BFS的起点。每扩散一步，更新相邻城市的距离（若未被访问过）。例如：  
```cpp
queue<int> q;
for (int i=1; i<=k; i++) {
    int x = c[i]; // c[i]是被占领城市
    q.push(x);
    dist[x] = 0; // 距离为0
}
while (!q.empty()) {
    int u = q.front(); q.pop();
    for (int v : adj[u]) { // adj是邻接表
        if (dist[v] == -1) { // 未被访问
            dist[v] = dist[u] + 1;
            q.push(v);
        }
    }
}
```


### 🔍 核心难点2：节点权值转化为边权  
**问题**：如何将城市的住宿费用（节点权值）整合到最短路算法中？  
**解决策略**：将边(u→v)的权值设置为**v的住宿费用**（除了v是1或N）。这样，走这条边就相当于支付了v的费用。例如：  
```cpp
// 构建边权：v的费用（除了1和N）
for (int u=1; u<=n; u++) {
    for (int v : adj[u]) {
        if (v == 1 || v == n) {
            edge_weight[u][v] = 0; // 1和N不用住店
        } else if (is_danger[v]) { // is_danger标记危险城市
            edge_weight[u][v] = Q;
        } else {
            edge_weight[u][v] = P;
        }
    }
}
```


### 🔍 核心难点3：大数值处理  
**问题**：费用可能很大（如Q=1e5，路径长度1e5，总费用1e10），容易溢出int。  
**解决策略**：使用**long long**类型存储距离和费用，INF设为足够大的值（如1e18）。例如：  
```cpp
const long long INF = 1e18;
long long dist[N];
memset(dist, INF, sizeof(dist));
dist[1] = 0;
```


### ✨ 解题技巧总结  
1. **多源问题用多源BFS**：避免多次单源BFS，提高效率；  
2. **节点权值转边权**：将“进入节点支付费用”转化为“边权等于节点费用”，适配传统最短路算法；  
3. **大数值用long long**：避免溢出，INF设为足够大的值；  
4. **边界条件处理**：1和N号城市不用住店，费用为0。  


## 4. C++核心代码实现赏析

### 📝 本题通用核心C++实现参考  
**说明**：综合优质题解思路，采用**多源BFS+Dijkstra（堆优化）**实现，逻辑清晰，效率高。  

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

typedef long long ll;
const int N = 1e5 + 5;
const ll INF = 1e18;

vector<int> adj[N]; // 邻接表
int dist_from_zombie[N]; // 每个城市到最近被占领城市的距离
bool is_danger[N]; // 是否是危险城市
ll d[N]; // 1到各城市的最小费用
bool vis[N]; // Dijkstra标记数组

int main() {
    int n, m, k, s, P, Q;
    cin >> n >> m >> k >> s >> P >> Q;

    // 1. 输入被占领城市，初始化多源BFS
    queue<int> q;
    memset(dist_from_zombie, -1, sizeof(dist_from_zombie));
    for (int i=0; i<k; i++) {
        int x;
        cin >> x;
        q.push(x);
        dist_from_zombie[x] = 0;
    }

    // 2. 输入道路，构建邻接表
    for (int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    // 3. 多源BFS计算距离，标记危险城市
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : adj[u]) {
            if (dist_from_zombie[v] == -1) {
                dist_from_zombie[v] = dist_from_zombie[u] + 1;
                q.push(v);
            }
        }
    }
    for (int i=1; i<=n; i++) {
        if (dist_from_zombie[i] != -1 && dist_from_zombie[i] <= s) {
            is_danger[i] = true;
        } else {
            is_danger[i] = false;
        }
    }

    // 4. Dijkstra求最小费用（堆优化）
    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;
    memset(d, INF, sizeof(d));
    d[1] = 0;
    pq.push({0, 1});

    while (!pq.empty()) {
        auto [cost, u] = pq.top();
        pq.pop();
        if (vis[u]) continue;
        vis[u] = true;
        for (int v : adj[u]) {
            // 计算边权：v的费用（除了1和N）
            ll w;
            if (v == 1 || v == n) {
                w = 0;
            } else if (is_danger[v]) {
                w = Q;
            } else {
                w = P;
            }
            // 松弛操作
            if (d[v] > d[u] + w) {
                d[v] = d[u] + w;
                pq.push({d[v], v});
            }
        }
    }

    // 输出结果
    cout << d[n] << endl;

    return 0;
}
```


### 📝 代码解读概要  
1. **多源BFS**：从所有被占领城市出发，计算每个城市到最近被占领城市的距离；  
2. **标记危险城市**：距离≤S的城市标记为危险；  
3. **Dijkstra（堆优化）**：从1号城市出发，优先选择最小费用的节点，更新相邻节点的费用（边权为目标节点的费用）；  
4. **输出结果**：d[n]即为1到N的最小费用。  


## 5. 算法可视化：像素动画演示（核心部分）

### 🎮 动画主题  
**像素风格城市地图**：展示多源BFS的“波纹扩散”（危险城市标记）和Dijkstra的“最短路径寻找”（路径高亮）。


### 📊 核心演示内容  
1. **场景初始化**：  
   - 8位像素风格的城市地图（用方块表示城市，线条表示道路）；  
   - 被占领城市标记为**红色**，1号城市标记为**绿色**，N号城市标记为**蓝色**；  
   - 控制面板：单步执行、自动播放、重置按钮，速度滑块（1~10倍速）。  

2. **多源BFS演示**：  
   - 红色波纹从所有被占领城市同时扩散（每步扩散一个格子）；  
   - 每个城市被波纹覆盖时，显示其到最近被占领城市的距离（如“距离：2”）；  
   - 距离≤S的城市变为**橙色**（危险城市），伴随“叮”的音效。  

3. **Dijkstra演示**：  
   - 绿色路径从1号城市出发，每步选择最小费用的节点（节点闪烁）；  
   - 路径用**绿色线条**高亮，显示当前总费用（如“总费用：5000”）；  
   - 到达N号城市时，播放“胜利”音效（8位风格），路径变为**金色**。  


### 🎨 设计思路  
- **像素风格**：模拟FC红白机画面，降低视觉复杂度，适合青少年理解；  
- **波纹扩散**：直观展示多源BFS的过程，让“危险城市”的概念更易理解；  
- **路径高亮**：清晰展示Dijkstra的“贪心”策略（选择最小费用节点）；  
- **音效反馈**：关键操作（如扩散、路径选择）用音效强化记忆，增加趣味性。  


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
多源BFS+最短路的组合，可用于解决**“多源影响范围+路径优化”**问题，例如：  
1. **疫情扩散问题**：计算每个地区到最近疫情点的距离，找到安全路径；  
2. **基站覆盖问题**：计算每个用户到最近基站的距离，找到最优基站部署方案；  
3. **火灾逃生问题**：计算每个房间到最近出口的距离，找到最短逃生路径。  


### 📚 洛谷练习推荐  
1. **洛谷P1144** - 最短路计数  
   - 推荐理由：练习多源BFS（计算每个节点的最短路径数目），巩固多源问题的处理技巧。  
2. **洛谷P1339** - 热浪  
   - 推荐理由：练习单源最短路（Dijkstra），处理边权问题，类似本题的“费用计算”。  
3. **洛谷P2384** - 最短路问题  
   - 推荐理由：练习多源最短路（Floyd-Warshall），对比多源BFS的效率，理解不同算法的适用场景。  


## 7. 学习心得与经验分享（若有）

### 📝 来自题解的经验  
- **多源BFS的优化**：题解中“将被占领城市同时入队”的方法，避免了多次单源BFS，效率更高；  
- **节点权值转边权的技巧**：题解中“边权等于目标节点费用”的处理，让最短路算法直接适用，逻辑清晰；  
- **大数值的处理**：题解中用long long存储费用，INF设为1e18，避免了溢出问题，这是本题的关键细节。  


## 🎉 总结  
《逃离僵尸岛》是一道**多源BFS+最短路**的经典题，核心在于**识别危险城市**和**处理节点权值**。通过多源BFS快速标记危险城市，再用Dijkstra求最小费用，即可解决问题。  

**学习建议**：  
- 重点掌握多源BFS的处理方法（同时入队）；  
- 理解节点权值转边权的逻辑（边权等于目标节点费用）；  
- 注意大数值的处理（long long和足够大的INF）。  

希望这份指南能帮助你掌握这类问题的解决技巧，下次遇到类似题目时能举一反三！💪

---
处理用时：132.55秒
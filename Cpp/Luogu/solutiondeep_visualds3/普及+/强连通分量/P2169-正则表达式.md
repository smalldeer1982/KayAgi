# 题目信息

# 正则表达式

## 题目背景

小Z童鞋一日意外的看到小X写了一个正则表达式的高级程序，这个正则表达式程序仅仅由字符“0”,“1”，“.”和“\*”构成，但是他能够匹配出所有在OJ上都AC的程序的核心代码！小Z大为颇感好奇，于是他决定入侵小X的电脑上去获得这个正则表达式的高级程序。


## 题目描述

在 Internet 网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在 $A$ 到 $B$ 的连接不一定存在 $B$ 到 $A$ 的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在 $A$ 到 $B$ 的连接的同时也存在 $B$ 到 $A$ 的连接的话，那么 $A$ 和 $B$ 实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为 $0$。

现在小 Z 告诉你整个网络的构成情况，他希望知道从他的电脑（编号为 $1$），到小 X 的电脑（编号为 $n$）所需要的最短传输时间。

## 说明/提示

- 对于  $40\%$ 的数据，$1\leq n\leq 10^3$, $1\leq m\leq 10^4$；
- 对于  $70\%$ 的数据，$1\leq n\leq 5 \times 10^3$， $1\leq m\leq 10^5$；
- 对于  $100\%$ 的数据，$1\leq n\leq 2 \times 10^5$， $1\leq m\leq 10^6$。

保证答案在 `int` 范围内。

## 样例 #1

### 输入

```
3 2
1 2 1
2 3 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5
1 2 1
2 3 6
3 4 1
4 2 1
3 5 2
```

### 输出

```
3```

# AI分析结果


### Kay的C++算法解析：正则表达式 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论（强连通分量+最短路算法）

🗣️ **初步分析**：
> 解决"正则表达式"这道题，关键在于运用 **Tarjan缩点+最短路算法**。就像在迷宫中寻找最短路径时，如果发现环形走廊（强连通分量），可以瞬间传送到环内任意位置（传输时间为0）。在本题中：
> - **核心流程**：先用Tarjan算法识别强连通分量（局域网），将每个分量缩为超级节点，形成有向无环图（DAG）。然后在DAG上运行Dijkstra算法计算最短路。
> - **可视化设计**：动画将分三阶段展示：①原始图遍历（像素节点闪烁DFS路径）②缩点过程（同分量节点融合为超级节点）③最短路搜索（Dijkstra的优先队列动态显示）。
> - **复古游戏化**：采用8-bit像素风格，节点如《吃豆人》中的能量球，缩点时播放"叮"音效，最短路更新时触发"跳跃"音效。支持AI自动演示模式，可调速观察算法细节。

---

#### 2. 精选优质题解参考

**题解一（Diamiko）**
* **点评**：思路清晰展示Tarjan缩点与Dijkstra的结合，代码规范（`belong`数组明确分量归属）。亮点在于完整处理原图到新图的转换，并用`priority_queue`实现堆优化，时间复杂度O((n+m)logn)。变量`color_cnt`等命名直观，边界处理严谨，竞赛可直接复用。

**题解二（subarude）**
* **点评**：创新性采用拓扑排序替代Dijkstra，利用DAG特性实现O(n+m)线性解法。亮点在于重建图时精准处理分量间边权，`belong[]`数组的应用简洁高效。代码中`rebuild()`函数体现模块化思想，但需注意拓扑排序仅适用于无环新图。

**题解三（PrincessQi）**
* **点评**：提供最简实现方案，Tarjan与Dijkstra不足70行。亮点在于内存管理（两次初始化链式前向星），并用`belong[u]==belong[v]`快速判断零权边。代码高度紧凑，适合学习者理解核心逻辑。

---

#### 3. 核心难点辨析与解题策略

1. **强连通分量识别**
   * **分析**：Tarjan算法中`dfn/low`的维护是难点。优质解法通过DFS树回溯更新`low`值，当`dfn[u]==low[u]`时弹出栈中节点形成分量。
   * 💡 **学习笔记**：`low[u]`实质是u通过后向边可达的最早祖先，决定分量边界。

2. **缩点建图优化**
   * **分析**：遍历原图边时，仅当`belong[u]!=belong[v]`才添加新边。Diamiko解法用`color`数组高效映射分量ID，避免重复建边。
   * 💡 **学习笔记**：缩点后节点数≤n，极大降低图复杂度。

3. **最短路算法选择**
   * **分析**：Dijkstra堆优化（题解一/三）适合稀疏图，拓扑排序（题解二）适合稠密DAG。注意分量内距离为0的特性已通过建图自然满足。
   * 💡 **学习笔记**：在新图上，节点实为分量，边权保持原值。

### ✨ 解题技巧总结
- **问题分解**：分阶段解决（SCC识别→缩点→最短路）
- **数据结构选择**：链式前向星存大图，`stack`实现Tarjan，`priority_queue`优化Dijkstra
- **调试技巧**：打印`dfn/low`值验证分量划分，可视化缩点前后图结构

---

#### 4. C++核心代码实现赏析

**通用核心实现（综合优化版）**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5, M=1e6+5;

struct Edge { int to,w,next; } e[M], newe[M];
int head[N], newhead[N], tot, newtot;
int dfn[N], low[N], bel[N], dis[N];
stack<int> st; 
bool ins[N];
int n, m, idx, scc_cnt;

void add(int u, int v, int w) {
    e[++tot] = {v, w, head[u]}; head[u] = tot;
}

void new_add(int u, int v, int w) {
    newe[++newtot] = {v, w, newhead[u]}; newhead[u] = newtot;
}

void tarjan(int u) {
    dfn[u] = low[u] = ++idx;
    st.push(u); ins[u] = true;
    for(int i=head[u]; i; i=e[i].next) {
        int v = e[i].to;
        if(!dfn[v]) {
            tarjan(v);
            low[u] = min(low[u], low[v]);
        } else if(ins[v]) 
            low[u] = min(low[u], dfn[v]);
    }
    if(dfn[u] == low[u]) {
        scc_cnt++;
        while(true) {
            int v = st.top(); st.pop();
            bel[v] = scc_cnt; ins[v] = false;
            if(u == v) break;
        }
    }
}

void dijkstra() {
    priority_queue<pair<int,int>> pq;
    int start = bel[1], end = bel[n];
    memset(dis, 0x3f, sizeof dis);
    pq.push({0, start}); dis[start] = 0;
    while(!pq.empty()) {
        int u = pq.top().second; pq.pop();
        for(int i=newhead[u]; i; i=newe[i].next) {
            int v = newe[i].to, w = newe[i].w;
            if(dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                pq.push({-dis[v], v});
            }
        }
    }
    cout << dis[end];
}

int main() {
    cin >> n >> m;
    for(int i=1; i<=m; i++) {
        int u,v,w; cin>>u>>v>>w;
        add(u,v,w);
    }
    for(int i=1; i<=n; i++) 
        if(!dfn[i]) tarjan(i);
    for(int u=1; u<=n; u++) 
        for(int i=head[u]; i; i=e[i].next) {
            int v = e[i].to;
            if(bel[u] != bel[v]) 
                new_add(bel[u], bel[v], e[i].w);
        }
    dijkstra();
}
```
**代码解读概要**：
1. **链式前向星**：`head/tot`管理原图，`newhead/newtot`管理新图
2. **Tarjan流程**：DFS遍历时维护`dfn/low`栈，分量识别后更新`bel`数组
3. **缩点建图**：遍历原图边，仅当端点属不同分量时添加新边
4. **Dijkstra**：在新图上以`bel[1]`为起点跑最短路

**题解一核心片段赏析**（Diamiko）：
```cpp
// 缩点后Dijkstra核心
int S = node[1].color; // 获取起点的颜色(分量ID)
dis[S] = 0;
priority_queue<pii, vector<pii>, greater<pii>> pq; 
pq.push({0, S});
while(pq.size()) {
    int u = pq.top().second; pq.pop();
    for(auto [v, w] : newG[u]) { // 遍历新图邻接点
        if(dis[v] > dis[u] + w) {
            dis[v] = dis[u] + w; // 松弛操作
            pq.push({dis[v], v});
        }
    }
}
cout << dis[belong[n]]; // 输出终点所在分量的距离
```
**学习笔记**：分量ID作为新图节点索引是缩点算法的精髓

---

#### 5. 算法可视化：像素动画演示
![像素动画示意图](https://img.pixhost.to/images/314/137831476_tarjan.png)

* **主题**："像素迷宫探险"（8-bit风格）
* **核心演示**：
  1. **Tarjan阶段**：
     - 节点闪烁绿色（DFS访问中）
     - 栈内节点显示为橙色
     - 发现SCC时播放"融合音效"，同分量节点变为同色方块
  2. **缩点阶段**：
     - 超级节点用大像素块表示，内部显示分量大小
     - 跨分量边显示为发光箭头
  3. **Dijkstra阶段**：
     - 当前节点显示为闪烁的勇者 sprite
     - 优先队列可视化（底部像素条显示）
     - 松弛成功时触发"路径延伸"动画和音效

* **交互控制**：
  - 速度滑块：调节动画速度（0.5x~4x）
  - 模式切换：单步/自动/AI演示
  - 信息面板：实时显示dfn/low/距离数组

---

#### 6. 拓展练习与相似问题
1. **洛谷 P3387**（缩点+DP）：练习分量内权值合并
2. **洛谷 P4779**（标准Dijkstra）：巩固最短路基础
3. **洛谷 P2863**（SCC计数）：简化版Tarjan应用

---

#### 7. 学习心得分享
> **经验摘录**（题解作者调试心得）：
> "Tarjan递归边界易漏栈操作，通过打印dfn/low值验证分量划分"
> 
> **Kay点评**：调试时可在DFS入口/出口打印节点状态，观察low值传播。缩点后务必验证新图无环，这是拓扑排序和Dijkstra的前提条件。

通过本次分析，我们掌握了图论问题的标准解法框架：问题转化（缩点）→ DAG处理→算法应用。继续加油！💪🏻

---
处理用时：161.81秒
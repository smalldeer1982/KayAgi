# 题目信息

# [IOI 1998][USACO5.5] 矩形周长 Picture

## 题目背景

墙上贴着许多形状相同的海报、照片。它们的边都是水平和垂直的。每个矩形图片可能部分或全部的覆盖了其他图片。所有矩形合并后的边长称为周长。

## 题目描述

编写一个程序计算周长。

![](https://cdn.luogu.com.cn/upload/image_hosting/2eo4hzl6.png)

如图 $1$ 所示 $7$ 个矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/buk96amj.png)

如图 $2$ 所示，所有矩形的边界。所有矩形顶点的坐标都是整数。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N<5000$，所有坐标的数值范围都在 $-10^4$ 到 $10^4$ 之间。

## 样例 #1

### 输入

```
7
-15 0 5 10
-5 8 20 25
15 -4 24 14
0 -6 16 4
2 15 10 22
30 10 36 20
34 0 40 16```

### 输出

```
228```

# AI分析结果

---
# 💡 Kay的C++算法解析：矩形周长Picture 深入学习指南 💡

<introduction>
  今天我们来一起分析经典的「矩形周长Picture」问题。这个问题需要计算多个矩形合并后的总周长，看起来有点复杂，但只要掌握了「扫描线+线段树」的组合技巧，就能轻松解决！本指南会帮你梳理思路、理解核心算法，并通过趣味可视化让你直观看到算法运行过程～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扫描线算法 + 线段树（几何算法与数据结构结合）

🗣️ **初步分析**：
> 解决「矩形周长」问题的关键，是用**扫描线算法**模拟“扫地”的过程——想象有一条线从下往上扫过所有矩形，每次遇到矩形的**上边**或**下边**时，就更新当前的覆盖状态，再计算周长的变化。而**线段树**则是我们的“工具包”，帮我们快速统计当前扫描线覆盖的长度和线段数量（这两个值直接决定了周长的贡献）。

### 核心算法思想类比
扫描线就像你用扫帚从地板底部扫到顶部：
- 遇到矩形的**下边**（扫帚碰到矩形的底部）：相当于“开始覆盖”这个矩形的横向区间，我们要在对应的区间**加1**（标记覆盖次数）。
- 遇到矩形的**上边**（扫帚离开矩形的顶部）：相当于“结束覆盖”这个矩形的横向区间，我们要在对应的区间**减1**（取消覆盖标记）。
- 每次扫描线移动后，我们需要计算：
  1. **横边贡献**：当前覆盖长度与上一次的差（绝对值）——这是扫描线移动过程中新增的横边长度。
  2. **竖边贡献**：当前覆盖的线段数量 × 扫描线移动的距离（上下两条边的高度差）——这是扫描线之间的竖边总长度。

### 可视化设计思路
为了让你直观看到这个过程，我设计了一个**FC红白机风格的像素动画**：
- **场景**：屏幕上显示多个像素化矩形（用不同颜色区分），底部有一条黄色的“扫描线”从下往上移动。
- **关键动作**：
  - 扫描线遇到矩形下边时，对应的横向区间会**变亮**（表示开始覆盖），同时播放“叮”的音效。
  - 遇到矩形上边时，对应的区间会**变暗**（表示结束覆盖），播放“咔”的音效。
  - 屏幕右侧实时显示当前的**覆盖长度**、**线段数量**和**累计周长**，数值会随扫描线移动动态更新。
- **交互设计**：支持“单步执行”（逐行扫描）、“自动播放”（快速扫完）和“重置”，你可以手动调整扫描速度，甚至暂停查看某一步的细节！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速掌握核心技巧～
</eval_intro>

**题解一：扫描线+线段树经典实现（作者：wucstdio，赞285）**
* **点评**：这份题解是扫描线算法的“标准模板”，思路极其清晰！作者把矩形拆分为上下边，用线段树维护**覆盖次数**、**覆盖长度**、**线段数量**和**左右端点是否覆盖**四个关键信息。代码中的`pushup`函数完美处理了线段树的合并逻辑（比如两个相邻区间的端点是否重合，从而减少线段数量），边界条件也处理得非常严谨（比如将矩形的右边减1，避免重复计算）。尤其值得学习的是**同层边的处理顺序**——作者在排序时让“下边”（加1操作）优先于“上边”（减1操作），避免了相邻矩形的边被错误计算。

**题解二：双向扫描简化代码（作者：xiejinhao，赞68）**
* **点评**：这份题解的亮点是**“扫两次”**——分别扫描横向边（计算竖边贡献）和纵向边（计算横边贡献），用函数传参的方式复用了线段树代码，大大减少了重复劳动！作者还用到了**离散化**（把大坐标映射到小范围），解决了题目中坐标范围大的问题。代码风格非常简洁，变量命名清晰（比如`line1`存横向边，`line2`存纵向边），适合入门者模仿。

**题解三：边界条件关键提醒（作者：彼岸归航，赞39）**
* **点评**：这份题解虽然代码不多，但**踩坑经验**非常宝贵！作者特别强调：**同层的边要先加边再删边**。比如两个相邻矩形（一个在另一个正上方），如果先删下边再加上边，会错误地把中间的重合边计入周长。这个细节直接决定了代码的正确性，很多初学者都会在这里栽跟头～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这个问题时，大家常遇到3个“拦路虎”，我帮你拆解清楚并给出应对策略：
</difficulty_intro>

1.  **难点1：如何处理大坐标？**
    * **分析**：题目中坐标范围是-10000到10000，直接用数组存会浪费空间。
    * **解决策略**：**离散化**——把所有用到的坐标收集起来，排序去重后映射到连续的小下标（比如把-10000→1，0→2，10000→20001）。这样线段树的大小就能从20001缩小到40000左右（因为每个矩形有2个x坐标和2个y坐标，总共有2×5000×2=20000个坐标）。
    * 💡 **学习笔记**：离散化是处理大坐标问题的“神器”，本质是“压缩空间”。

2.  **难点2：线段树要维护哪些信息？**
    * **分析**：周长需要两个关键值：**当前覆盖的总长度**（计算横边贡献）和**当前覆盖的线段数量**（计算竖边贡献）。此外，线段数量的计算需要知道区间的**左右端点是否被覆盖**（比如两个相邻区间的右端点和左端点都被覆盖，线段数量要减1）。
    * **解决策略**：线段树的每个节点维护4个值：
      - `sum`：区间被覆盖的次数（用于判断是否完全覆盖）。
      - `len`：区间被覆盖的总长度。
      - `num`：区间内的线段数量。
      - `lflag/rflag`：区间的左/右端点是否被覆盖。
    * 💡 **学习笔记**：线段树的节点设计要“按需定制”，需要什么信息就维护什么。

3.  **难点3：同层边的处理顺序为什么重要？**
    * **分析**：如果同一条水平线上有“加边”和“删边”操作，先删边会导致中间的重合边被错误计入周长（比如两个相邻矩形的边重合时，先删边会让覆盖长度变为0，再加边又变为正数，差的绝对值会被计入，但实际上这条边是重合的，不该算）。
    * **解决策略**：排序时让“加边”（`flag=1`）优先于“删边”（`flag=-1`）——这样同层的边会先完成所有加操作，再处理删操作，避免中间出现“假0”。
    * 💡 **学习笔记**：排序顺序是处理边界条件的关键，一定要想清楚“先做什么后做什么”。

### ✨ 解题技巧总结
- **拆分问题**：把矩形拆成上下边（或左右边），将二维问题转化为一维问题。
- **工具复用**：用线段树维护区间信息，避免暴力枚举的高时间复杂度。
- **细节优先**：处理边界条件（比如坐标减1、同层边顺序）时要“斤斤计较”，否则容易出错。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**经典的扫描线+线段树实现**，帮你建立整体框架～
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合wucstdio和xiejinhao的题解，提炼出的标准实现，包含离散化和线段树核心逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 5005;
const int OFFSET = 10001; // 将负坐标转为正坐标

struct Edge {
    int l, r, h, flag;
    bool operator<(const Edge& other) const {
        return h < other.h || (h == other.h && flag > other.flag);
    }
};

struct SegmentTree {
    int sum, len, num;
    bool lflag, rflag;
} tree[MAXN << 3];

vector<Edge> edges;
vector<int> xs; // 用于离散化的x坐标

void pushup(int o, int l, int r) {
    if (tree[o].sum) {
        tree[o].len = xs[r+1] - xs[l];
        tree[o].num = 1;
        tree[o].lflag = tree[o].rflag = true;
    } else if (l == r) {
        tree[o].len = 0;
        tree[o].num = 0;
        tree[o].lflag = tree[o].rflag = false;
    } else {
        int mid = (l + r) >> 1;
        tree[o].len = tree[o<<1].len + tree[o<<1|1].len;
        tree[o].num = tree[o<<1].num + tree[o<<1|1].num;
        if (tree[o<<1].rflag && tree[o<<1|1].lflag) tree[o].num--;
        tree[o].lflag = tree[o<<1].lflag;
        tree[o].rflag = tree[o<<1|1].rflag;
    }
}

void update(int o, int l, int r, int L, int R, int val) {
    if (L <= l && r <= R) {
        tree[o].sum += val;
        pushup(o, l, r);
        return;
    }
    int mid = (l + r) >> 1;
    if (L <= mid) update(o<<1, l, mid, L, R, val);
    if (R > mid) update(o<<1|1, mid+1, r, L, R, val);
    pushup(o, l, r);
}

int main() {
    int n;
    cin >> n;
    for (int i = 0; i < n; ++i) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        x1 += OFFSET; x2 += OFFSET; // 转为正坐标
        edges.push_back({x1, x2, y1, 1}); // 下边
        edges.push_back({x1, x2, y2, -1}); // 上边
        xs.push_back(x1); xs.push_back(x2);
    }
    // 离散化x坐标
    sort(xs.begin(), xs.end());
    xs.erase(unique(xs.begin(), xs.end()), xs.end());
    int m = xs.size() - 1; // 离散后的区间数
    sort(edges.begin(), edges.end());
    
    long long ans = 0;
    int last_len = 0;
    for (int i = 0; i < edges.size(); ++i) {
        Edge& e = edges[i];
        // 找到离散后的左右下标
        int L = lower_bound(xs.begin(), xs.end(), e.l) - xs.begin();
        int R = lower_bound(xs.begin(), xs.end(), e.r) - xs.begin() - 1;
        if (L <= R) update(1, 0, m-1, L, R, e.flag);
        // 计算横边贡献
        ans += abs(tree[1].len - last_len);
        last_len = tree[1].len;
        // 计算竖边贡献（下一条边的高度差）
        if (i < edges.size()-1) {
            ans += (long long)tree[1].num * 2 * (edges[i+1].h - e.h);
        }
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取矩形的坐标，拆分为上下边，并将坐标转为正坐标（避免负下标）。
  2. **离散化**：收集所有x坐标，排序去重，映射到小范围。
  3. **扫描线排序**：将边按高度排序，同高度的下边优先。
  4. **线段树更新**：遍历每条边，更新线段树的覆盖状态。
  5. **周长计算**：每次更新后，计算横边（覆盖长度差）和竖边（线段数量×高度差）的贡献，累加得到总周长。

---

<code_intro_selected>
接下来剖析优质题解的核心片段，看看它们的“巧妙之处”～
</code_intro_selected>

### 题解一：wucstdio的线段树`pushup`函数
* **亮点**：完美处理了线段数量的合并逻辑。
* **核心代码片段**：
```cpp
void pushup(int o, int l, int r) {
    if (tree[o].sum) { // 完全覆盖
        tree[o].num = 1;
        tree[o].len = r - l + 1;
        tree[o].lflag = tree[o].rflag = 1;
    } else if (l == r) { // 叶节点
        tree[o].num = 0;
        tree[o].len = 0;
        tree[o].lflag = tree[o].rflag = 0;
    } else { // 合并子节点
        tree[o].num = tree[lson].num + tree[rson].num;
        if (tree[lson].rflag && tree[rson].lflag) tree[o].num--; // 端点重合，线段数减1
        tree[o].len = tree[lson].len + tree[rson].len;
        tree[o].lflag = tree[lson].lflag;
        tree[o].rflag = tree[rson].rflag;
    }
}
```
* **代码解读**：
  - 如果区间被完全覆盖（`sum>0`），那么这个区间就是一条完整的线段（`num=1`），长度是区间总长。
  - 如果是叶节点（`l==r`），说明是一个点，没有长度和线段。
  - 否则，合并左右子节点的信息：线段数量是子节点之和，但如果左子节点的右端点和右子节点的左端点都被覆盖（`lson.rflag && rson.lflag`），说明这两个线段是连在一起的，要减1。
* 💡 **学习笔记**：线段树的`pushup`函数是“合并逻辑”的核心，一定要根据需要维护的信息设计。

### 题解二：xiejinhao的双向扫描
* **亮点**：用函数传参复用线段树代码，减少重复。
* **核心代码片段**：
```cpp
// 通用的线段树更新函数，传树和离散化数组的地址
void change(int p, int l, int r, int d, SegmentTree *t, int *b) {
    if (l <= t[p].l && r >= t[p].r) {
        t[p].cnt += d;
        updata(p, t, b); // 更新长度
        return;
    }
    int mid = (t[p].l + t[p].r) >> 1;
    if (l <= mid) change(ls(p), l, r, d, t, b);
    if (r > mid) change(rs(p), l, r, d, t, b);
    updata(p, t, b);
}

// 主函数中扫描横向和纵向边
int main() {
    // ... 输入处理 ...
    sort(line1 + 1, line1 + n + 1); // 横向边排序
    sort(line2 + 1, line2 + n + 1); // 纵向边排序
    // 扫描横向边（计算竖边贡献）
    build(1, 1, m1 - 1, t1);
    for (int i = 1; i <= n; i++) {
        // ... 更新t1 ...
        ans += abs(t1[1].len - temp1);
    }
    // 扫描纵向边（计算横边贡献）
    build(1, 1, m2 - 1, t2);
    for (int i = 1; i <= n; i++) {
        // ... 更新t2 ...
        ans += abs(t2[1].len - temp2);
    }
    cout << ans;
}
```
* **代码解读**：
  - 作者定义了`change`函数，通过传`SegmentTree *t`和`int *b`（离散化数组），复用了线段树的更新逻辑。
  - 分别扫描横向边（`line1`）和纵向边（`line2`），计算两部分的贡献，最终相加得到总周长。
* 💡 **学习笔记**：复用代码可以减少出错概率，尤其是当逻辑重复时，用函数或模板是很好的选择。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”扫描线的工作过程，我设计了一个**FC红白机风格的像素动画**，像玩游戏一样学算法！
</visualization_intro>

### 动画设计方案
#### 1. 整体风格与场景
- **像素风格**：采用8位像素画，颜色用FC经典的64色（比如矩形用红、蓝、绿，扫描线用黄色）。
- **场景布局**：
  - 左侧：20×20的像素网格（代表坐标范围-10到10，缩放后显示），矩形用不同颜色的像素块填充。
  - 右侧：控制面板+信息栏，显示“覆盖长度”“线段数量”“累计周长”三个数值，以及“单步”“自动”“重置”按钮。
- **背景音乐**：循环播放FC风格的轻快BGM（比如《超级马里奥》的地面关卡音乐）。

#### 2. 核心动画流程
以样例输入中的7个矩形为例：
1. **初始化**：网格中显示7个像素矩形（比如第一个矩形是-15→5（x）、0→10（y），缩放后变成x从0到20，y从0到10的像素块）。
2. **扫描线启动**：黄色扫描线从网格底部（y=0）开始，缓慢向上移动。
3. **遇到下边**：当扫描线到达y=0时，遇到第一个矩形的下边（flag=1），对应的x区间（0→20）会**变亮**（比如白色），同时播放“叮”的音效。信息栏中的“覆盖长度”变为20，“线段数量”变为1，“累计周长”增加20（横边贡献）。
4. **遇到上边**：当扫描线到达y=10时，遇到第一个矩形的上边（flag=-1），对应的x区间**变暗**，播放“咔”的音效。信息栏中的“覆盖长度”变为0，“线段数量”变为0，“累计周长”增加20（横边贡献）+ 1×2×(10-0)（竖边贡献）= 40。
5. **继续扫描**：扫描线继续向上，遇到其他矩形的边时重复上述过程，直到扫完所有边。
6. **结束**：扫描线到达顶部，播放胜利音效（比如《魂斗罗》的通关音乐），信息栏显示最终周长228。

#### 3. 交互设计
- **单步执行**：点击“单步”按钮，扫描线移动一行，暂停让你观察当前状态。
- **自动播放**：点击“自动”按钮，扫描线匀速移动，速度可调（滑块从“慢”到“快”）。
- **重置**：点击“重置”按钮，扫描线回到底部，所有数值清零，重新开始。

#### 4. 技术实现
- **Canvas绘制**：用HTML5 Canvas绘制像素网格和扫描线，每个像素块是10×10的正方形（方便点击）。
- **音效**：用Web Audio API播放8位音效（比如“叮”用频率440Hz的正弦波，“咔”用频率220Hz的方波）。
- **逻辑控制**：用JavaScript维护线段树的状态，每次扫描线移动时更新Canvas和信息栏。

<visualization_conclusion>
通过这个动画，你可以直观看到扫描线如何“扫过”矩形，线段树如何维护覆盖信息，周长如何一步步积累。就像玩游戏一样，轻松理解复杂的算法！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了扫描线+线段树的技巧后，你可以解决很多**几何覆盖问题**，比如面积并、区间点计数等。下面是几个相似的练习：
</similar_problems_intro>

### 通用思路迁移
扫描线算法的核心是**将二维问题转化为一维问题**，用线段树维护一维区间的信息。它可以解决：
1. **矩形面积并**：计算多个矩形合并后的面积（只需统计覆盖长度×高度差）。
2. **区间点计数**：统计多个区间中被覆盖k次的点的数量（线段树维护覆盖次数）。
3. **天际线问题**：计算城市天际线的轮廓（类似周长问题，但只需统计最高的点）。

### 洛谷练习推荐
1. **洛谷 P2061 [USACO07OPEN]City Horizon S**  
   🗣️ **推荐理由**：扫描线算法的入门题，计算矩形面积并，巩固覆盖长度的统计。
2. **洛谷 P1502 窗口的星星**  
   🗣️ **推荐理由**：扫描线+线段树的变形，需要统计区间内的最大值，锻炼灵活运用能力。
3. **洛谷 P3380 【模板】二逼平衡树（树套树）**  
   🗣️ **推荐理由**：线段树的进阶练习，虽然不是几何问题，但能巩固线段树的区间维护技巧。
4. **洛谷 P1816 忠诚**  
   🗣️ **推荐理由**：线段树的基础题，计算区间最小值，帮你熟悉线段树的基本操作。


## 7. 学习心得与经验分享 (若有)
> **参考经验（来自彼岸归航）**：“我在解决这个问题时，最初没注意同层边的顺序，导致样例输入2（两个上下相邻的矩形）的输出错误。后来通过调试发现，先删边再加边会把中间的重合边计入周长，改成先加边再删边就对了。”  
> **点评**：这个经验非常典型！很多时候，算法的正确性就藏在“顺序”这样的细节里。遇到错误时，不妨**手动模拟小例子**（比如两个相邻矩形），看看每一步的变量变化，就能快速定位问题。


<conclusion>
本次关于「矩形周长Picture」的分析就到这里啦！扫描线+线段树是几何算法中的“黄金组合”，掌握它能解决很多复杂的覆盖问题。记住：**算法的本质是“问题转化”**——把二维的矩形周长问题，转化为一维的扫描线问题，再用线段树高效处理。下次遇到几何问题时，不妨想想“能不能用扫描线扫一遍？”，说不定就能找到思路～  
加油，你一定能成为算法小能手！💪
</conclusion>

---

---
处理用时：169.33秒
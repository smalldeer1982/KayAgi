# 题目信息

# [NOIP2020] 排水系统

## 题目描述

对于一个城市来说，排水系统是极其重要的一个部分。

有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。

排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。

现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。

现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。

## 说明/提示

**【样例 #1 解释】**

$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  
$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\frac{1}{3}$ 吨污水。  
$2$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
$3$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
最终，$4$ 号结点排出 $\frac{1}{6} + \frac{1}{6} = \frac{1}{3}$ 吨污水，$5$ 号结点排出 $\frac{1}{3} + \frac{1}{6} + \frac{1}{6} = \frac{2}{3}$ 吨污水。

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $1$ |
| $4 \sim 6$ | ${10}^3$ | $1$ |
| $7 \sim 8$ | ${10}^5$ | $1$ |
| $9 \sim 10$ | ${10}^5$ | $10$ |

对于全部的测试点，保证 $1 \le n \le {10}^5$，$1 \le m \le 10$，$0 \le d_i \le 5$。

数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。

## 样例 #1

### 输入

```
5 1
3 2 3 5
2 4 5
2 5 4
0
0
```

### 输出

```
1 3
2 3
```

## 样例 #2

### 输入

```
见附件中的 water/water2.in```

### 输出

```
见附件中的 water/water2.ans```

## 样例 #3

### 输入

```
见附件中的 water/water3.in```

### 输出

```
见附件中的 water/water3.ans```

# AI分析结果



---
# 💡 Kay的C++算法解析：排水系统 深入学习指南 💡

<introduction>
今天我们来一起分析NOIP2020的“排水系统”这道题。这道题结合了图论与分数运算，是一道非常经典的算法应用题。本指南将帮助你梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`拓扑排序 + 分数运算`

🗣️ **初步分析**：
解决“排水系统”的关键在于理解并运用拓扑排序处理有向无环图（DAG）。拓扑排序就像给节点排了个“处理顺序”，确保每个节点被处理时，所有可能流入它的污水都已计算完毕。简单来说，拓扑排序的核心思想是“按依赖关系依次处理节点”，就像你要先写完作业才能出去玩一样～

在本题中，污水从接收口（入度为0的节点）开始流动，每个节点的污水会均分到所有排出管道。由于图无环，我们可以用拓扑排序确定处理顺序，确保每个节点处理时，其所有前驱节点的水量已计算完成。核心难点在于：
- 如何维护分数形式的水量（避免溢出，正确约分）；
- 如何高效处理DAG的节点顺序（拓扑排序的正确实现）；
- 最终排水口的判断（出度为0的节点）。

可视化设计思路：我们将用8位像素风格的动画演示拓扑排序过程。例如，初始接收口节点（如1号）用蓝色像素块表示，队列中的节点用黄色闪烁标记，处理节点时，其水量均分到子节点（红色像素流），最终排水口用绿色高亮。关键步骤（如入队、分流）会伴随“叮”的音效，成功完成所有处理后播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选出以下3篇优质题解（评分≥4星）：
</eval_intro>

**题解一：作者“听取MLE声一片”**
* **点评**：这篇题解思路非常清晰，明确指出拓扑排序是核心，并结合分数通分处理水量。代码结构规范（如用`vector`存边，`queue`实现拓扑排序），变量名`xx[i]`（分子）、`yy[i]`（分母）含义明确。亮点在于分数加法的`add`函数，通过通分和约分保证结果最简。美中不足是未处理高精度，但对理解核心逻辑很有帮助。

**题解二：作者“hensier”**
* **点评**：此题解使用`__int128`处理大数，避免了高精度的复杂实现。代码中`update`函数巧妙处理分数加法（先通分再合并），拓扑排序部分逻辑简洁（队列处理入度为0的节点）。亮点是用链式前向星存图，适合处理大规模数据，实践价值高（可直接用于竞赛）。

**题解三：作者“lndjy”**
* **点评**：此题解定义了`fenshu`类封装分数运算（加法、约分），代码模块化强，可读性高。拓扑排序部分通过队列维护处理顺序，逻辑直白。亮点是用`__int128`简化大数处理，同时保留了分数运算的核心逻辑，适合学习如何将数学模型转化为代码。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们常遇到以下关键点。结合优质题解的共性，提炼出核心思考方向：
</difficulty_intro>

1.  **关键点1：如何正确应用拓扑排序确定处理顺序？**
    * **分析**：拓扑排序的关键是维护入度数组。初始时，入度为0的节点（接收口）入队。处理节点时，将其水量均分到所有子节点，并减少子节点的入度；当子节点入度减为0时，说明所有前驱已处理完毕，即可入队。例如，样例中1号节点处理后，其子节点2、3、5的入度减少，当2号节点入度减为0时，开始处理它的子节点。
    * 💡 **学习笔记**：拓扑排序的本质是“依赖关系的顺序处理”，确保每个节点处理时，所有可能影响它的节点已处理完毕。

2.  **关键点2：如何维护分数形式的水量（避免溢出，正确约分）？**
    * **分析**：每个节点的水量是分数（分子/分母）。当节点u的水量为`a/b`，出度为d时，每个子节点v会获得`a/(b*d)`的水量。需要将v的当前水量与该值相加，并通分约分。例如，样例中2号节点接收1/3吨水，出度为2，子节点4和5各获得1/6吨。优质题解通过`gcd`函数实现约分，用`__int128`或高精度避免溢出。
    * 💡 **学习笔记**：分数运算的核心是通分（最小公倍数）和约分（最大公约数），大数处理可用`__int128`简化代码。

3.  **关键点3：如何判断最终排水口并输出结果？**
    * **分析**：最终排水口是出度为0的节点（无排出管道）。处理完所有节点后，遍历所有节点，输出出度为0的节点的水量（约分后的分子/分母）。例如，样例中4号和5号节点出度为0，分别输出1/3和2/3。
    * 💡 **学习笔记**：最终排水口的判断条件是出度为0，需在输入时记录每个节点的出度。

### ✨ 解题技巧总结
- **问题抽象**：将污水流动问题抽象为DAG上的拓扑排序，用分数维护水量。
- **模块化设计**：将分数运算（加法、约分）封装为函数或类，提高代码可读性。
- **大数处理**：用`__int128`替代高精度，简化代码（适用于支持该类型的OJ）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼一个通用的核心实现。该代码使用拓扑排序处理DAG，`__int128`维护分数，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了“hensier”和“lndjy”的题解思路，使用拓扑排序和`__int128`处理分数，适用于大规模数据。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef __int128 ll;

    void write(ll x) {
        if (x < 0) { putchar('-'); x = -x; }
        if (x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }

    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }

    struct Frac {
        ll num, den; // 分子、分母
        Frac(ll n = 0, ll d = 1) : num(n), den(d) { simplify(); }
        void simplify() { ll g = gcd(num, den); num /= g; den /= g; }
        Frac operator+(const Frac& o) const {
            ll lcm = den / gcd(den, o.den) * o.den;
            ll new_num = num * (lcm / den) + o.num * (lcm / o.den);
            return Frac(new_num, lcm);
        }
        Frac operator/(int k) const { return Frac(num, den * k); }
    };

    int main() {
        int n, m; scanf("%d%d", &n, &m);
        vector<vector<int>> g(n + 1);
        vector<int> in(n + 1), out(n + 1);
        vector<Frac> water(n + 1);

        for (int i = 1; i <= n; ++i) {
            int d; scanf("%d", &d);
            out[i] = d;
            while (d--) {
                int v; scanf("%d", &v);
                g[i].push_back(v);
                in[v]++;
            }
        }

        queue<int> q;
        for (int i = 1; i <= n; ++i) {
            if (in[i] == 0) {
                q.push(i);
                water[i] = Frac(1, 1);
            }
        }

        while (!q.empty()) {
            int u = q.front(); q.pop();
            if (out[u] == 0) continue; // 最终排水口无需处理

            Frac add = water[u] / out[u];
            for (int v : g[u]) {
                water[v] = water[v] + add;
                if (--in[v] == 0) q.push(v);
            }
        }

        for (int i = 1; i <= n; ++i) {
            if (out[i] == 0) {
                write(water[i].num); putchar(' ');
                write(water[i].den); putchar('\n');
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入并建图（邻接表`g`），维护入度`in`和出度`out`。初始化时，入度为0的节点（接收口）水量设为1/1。通过队列进行拓扑排序，处理每个节点时，将其水量均分到子节点（`water[v] += water[u]/out[u]`）。最终遍历所有出度为0的节点，输出其水量（约分后的分子/分母）。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其亮点。
</code_intro_selected>

**题解一：作者“听取MLE声一片”**
* **亮点**：分数加法的`add`函数逻辑清晰，通过通分和约分保证结果最简。
* **核心代码片段**：
    ```cpp
    void add(int u, ll x, ll y) {
        if (y == 0) return;
        if (yy[u] == 0) { xx[u] = x; yy[u] = y; return; }
        ll p1 = xx[u] * y + yy[u] * x;
        ll p2 = yy[u] * y;
        ll p3 = gcd(p1, p2);
        xx[u] = p1 / p3; yy[u] = p2 / p3;
    }
    ```
* **代码解读**：
    `add`函数用于将分数`x/y`加到节点`u`的当前水量（`xx[u]/yy[u]`）。若`u`当前无水量（`yy[u]==0`），直接赋值；否则计算通分后的分子`p1`和分母`p2`，用`gcd`约分后更新`u`的水量。例如，样例中2号节点接收1/3吨水（x=1,y=3），其子节点4的当前水量为0，调用`add(4,1,3*2)`（因为出度为2），得到1/6。
* 💡 **学习笔记**：分数加法的关键是通分（最小公倍数）和约分（最大公约数），这是处理分数运算的基础。

**题解二：作者“hensier”**
* **亮点**：使用链式前向星存图，适合处理大规模数据，拓扑排序逻辑简洁。
* **核心代码片段**：
    ```cpp
    void update(I128 &x_1, I128 &y_1, I128 x_2, I128 y_2) {
        I128 p = y_1 * y_2 / gcd(y_1, y_2);
        x_1 *= p / y_1;
        x_2 *= p / y_2;
        x_1 += x_2;
        y_1 = p;
    }
    ```
* **代码解读**：
    `update`函数将分数`x_2/y_2`加到`x_1/y_1`。首先计算分母的最小公倍数`p`，将两个分数通分到分母`p`，相加后更新`x_1`和`y_1`。例如，节点4的水量初始为0/1，加入1/6后，`x_1=0*6 +1*1=1`，`y_1=6`，得到1/6。
* 💡 **学习笔记**：链式前向星存图在处理大规模边数时更高效，适合本题`n≤1e5`的情况。

**题解三：作者“lndjy”**
* **亮点**：定义`fenshu`类封装分数运算，代码模块化强。
* **核心代码片段**：
    ```cpp
    struct fenshu {
        __int128 x, y;
        fenshu(int a=0, int b=1) { x=a; y=b; yuefen(); }
        int gcd(int a, int b) { return b?gcd(b,a%b):a; }
        void yuefen() { int k=gcd(x,y); x/=k; y/=k; }
        void add(fenshu k) {
            fenshu ans;
            ans.x = x*k.y + k.x*y;
            ans.y = y*k.y;
            ans.yuefen();
            *this = ans;
        }
    };
    ```
* **代码解读**：
    `fenshu`类包含分子`x`和分母`y`，`yuefen`方法用于约分，`add`方法实现分数加法。例如，节点5的水量由1/3（来自1号节点）、1/6（来自2号节点）、1/6（来自3号节点）相加，最终得到(1*6 +1*3 +1*3)/(3*6)=12/18=2/3。
* 💡 **学习笔记**：类的封装能提高代码的可读性和复用性，是良好的编程习惯。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解拓扑排序和污水流动的过程，我设计了一个“像素排水探险”动画方案，用8位复古风格展示算法每一步！
</visualization_intro>

  * **动画演示主题**：`像素排水探险——污水流动大作战`

  * **核心演示内容**：
    展示拓扑排序的处理顺序（队列中的节点）、每个节点的水量变化（分数显示）、污水均分到子节点的过程（像素流动画），以及最终排水口的高亮。

  * **设计思路简述**：
    采用8位像素风格（类似FC红白机），用不同颜色区分节点类型（接收口：蓝色，中间节点：黄色，最终排水口：绿色）。关键操作（入队、分流）伴随“叮”的音效，完成所有处理后播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示像素网格（节点用方块表示，编号在方块上方），右侧显示队列（像素堆叠的方块）和当前处理节点。
        - 控制面板包含“单步”、“自动播放”按钮和速度滑块（1x-5x）。
        - 播放8位风格的轻快背景音乐。

    2.  **初始状态**：
        - 接收口节点（如1号）显示为蓝色方块，水量1/1（下方文字显示）。
        - 队列中只有接收口节点，队列方块显示“1”。

    3.  **处理节点（单步执行）**：
        - 点击“单步”，队列弹出队首节点（如1号），节点变为黄色（处理中）。
        - 计算该节点的出度（如3），生成3条红色像素流，分别流向子节点（2、3、5号）。
        - 子节点的水量更新（如2号从0/1变为1/3），下方文字显示新分数，伴随“叮”的音效。
        - 子节点入度减1，若减为0则加入队列（如2号入度从1变为0，队列新增“2”）。

    4.  **自动播放模式**：
        - 点击“自动播放”，算法自动执行，节点处理速度由滑块控制（如2x速）。
        - 队列动态更新，处理中的节点闪烁，子节点接收水量时像素流快速流动。

    5.  **最终排水口高亮**：
        - 所有节点处理完成后，最终排水口（如4、5号）变为绿色，水量分数放大显示。
        - 播放上扬的胜利音效，屏幕飘落像素星星。

    6.  **代码同步**：
        - 动画下方同步显示核心代码（如拓扑排序的循环、分数加法的`add`函数），当前执行的代码行用黄色高亮。

  * **旁白提示**：
    - （处理1号节点时）“当前处理节点1，出度为3，污水被均分为3份，流向节点2、3、5！”
    - （子节点入队时）“节点2的入度减为0，加入队列，即将处理！”
    - （最终排水口显示时）“看！这就是最终的排水口，它们的水量分别是1/3和2/3！”

<visualization_conclusion>
通过这样的像素动画，你可以直观看到拓扑排序的处理顺序和污水流动的每一步，理解分数运算如何影响最终结果。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
拓扑排序和分数运算的思想不仅能解决本题，还适用于其他DAG上的流量分配问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **DAG上的依赖问题**：如任务调度（P1137旅行计划），需按拓扑序计算每个任务的最早开始时间。
    - **网络流简化问题**：如神经网络（P1038），每个节点的输出是输入的线性组合，需按拓扑序计算。
    - **分层图问题**：如车站分级（P1983），需按拓扑序确定每个节点的层级。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1038 神经网络**
          * 🗣️ **推荐理由**：这道题是拓扑排序的经典应用，需计算每个神经元的输出值，与本题的污水流动思路类似。
    2.  **洛谷 P1137 旅行计划**
          * 🗣️ **推荐理由**：本题需计算每个节点的最长路径，通过拓扑排序依次处理节点，锻炼拓扑序的灵活应用。
    3.  **洛谷 P1983 车站分级**
          * 🗣️ **推荐理由**：本题需确定车站的等级，涉及分层图的拓扑排序，能提升对拓扑序的深入理解。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者“Legitimity”)**：“赛场上用`long long`爆了，后来用`__int128`才过。这让我意识到，处理大数时要提前估算数据范围，避免溢出。”

**点评**：这位作者的经验非常实用！在编程中，尤其是涉及分数运算时，一定要考虑数据范围。本题中分母可能达到`5^10`（根据题目提示，中间节点不超过10个），`__int128`的范围（约`1e38`）足够覆盖，而`long long`（约`1e18`）可能溢出。这提醒我们，处理大数问题时，选择合适的数据类型或高精度方法至关重要。

-----

<conclusion>
本次关于“排水系统”的分析就到这里。希望你通过这份指南，掌握了拓扑排序和分数运算的核心技巧，理解了如何将实际问题转化为算法模型。记住，多动手写代码、调试，你会越来越熟练！下次见～💪
</conclusion>

-----

---
处理用时：186.48秒
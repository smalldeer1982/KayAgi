# 题目信息

# 魔法

## 题目描述

cjwssb 知道是误会之后，跟你道了歉。你为了逗笑他，准备和他一起开始魔法。不过你的时间不多了，但是更惨的是你还需要完成 $n$ 个魔法任务。假设你当前的时间为 $T$，每个任务需要有一定的限制 $t_i$ 表示只有当你的 $T$ 严格大于 $t_i$ 时你才能完成这个任务，完成任务并不需要消耗时间。当你完成第 $i$ 个任务时，你的时间 $T$ 会加上 $b_i$，此时要保证 $T$ 在任何时刻都大于 $0$，那么请问你是否能完成这 $n$ 个魔法任务，如果可以，输出 $\texttt{+1}\texttt{s}$，如果不行，输出 $\texttt{-1}\texttt{s}$。


## 说明/提示

对于 $20\%$ 的数据，$n\leq10$；

对于 $100\%$ 的数据，$n\leq10^5,Z\leq10,t_i\leq10^5,T\leq10^5,-10^5\leq b_i\leq 10^5$。

By lantian

$\LaTeX$ By ⚡炭治郎⚡

## 因为历史遗留问题，博客讨论可能无法发出样例输出的字符串，可以考虑使用其他方式规避。


## 样例 #1

### 输入

```
1
2 13
1 -9
5 -3
```

### 输出

```
+1s
```

# AI分析结果

# 💡 Kay的C++算法解析：魔法 深入学习指南 💡

<introduction>
  今天我们来一起分析“魔法”这道C++编程题。这道题看似简单，实则藏着贪心算法的巧妙逻辑——如何安排任务顺序，让时间T“越用越多”（或者至少撑过所有任务）？本指南将帮你理清思路，掌握贪心策略的核心，还会用像素动画让算法“动”起来！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法（Greedy Algorithm）

🗣️ **初步分析**：
> 解决“魔法”问题的关键，就像你去超市买零食——**先拿能让你更有钱的（b>0的任务），再拿会花掉你钱的（b≤0的任务）**。贪心算法的核心是“每一步都选当前最优”，这里的“最优”就是让T尽可能大，才能完成更多任务。  
> - **b>0的任务**：必须按`t_i`从小到大排序（门槛低的先做），因为完成后T会增加，能帮你解锁更难的任务（t_i大的）。  
> - **b≤0的任务**：这部分需要“反向聪明”——按`t_i + b_i`从大到小排序（比如，一个任务t=9、b=-5，另一个t=4、b=-2，前者t+b=4，后者t+b=2，所以先做前者）。为什么？因为`t_i + b_i`代表“完成这个任务后，剩下的T至少要能满足下一个任务的t要求”（后面会用数学证明哦）。  
> - **核心难点**：如何证明b≤0部分的排序策略是正确的？如何处理T的实时检查（不能≤0，不能≤t_i）？  
> - **可视化设计思路**：我们会用8位像素风格展示任务列表，b>0的任务用绿色方块（“增益”），b≤0的用红色方块（“消耗”）。T用进度条显示，每完成一个任务，进度条会跳动，同时高亮当前处理的任务。比如，处理b>0的任务时，进度条变长；处理b≤0的任务时，进度条变短，但会提示“是否能撑过下一个？”。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速掌握核心逻辑：
</eval_intro>

**题解一：来源（作者：lwz2002，赞：56）**
* **点评**：这份题解是“贪心策略的标准模板”！作者把任务分成b>0和b≤0两组，分别排序，逻辑非常清晰。对于b>0的任务，按`t_i`升序排列（门槛低的先做）；对于b≤0的任务，用数学证明了按`t_i + b_i`降序排列的正确性（比如举了反例：先做t=4、b=-2会导致t=9、b=-5做不了，而先做t=9、b=-5则可以完成两个任务）。代码结构工整，变量名（如`a`数组存b>0的任务，`f`数组存b≤0的任务）含义明确，每一步都检查T是否符合要求（比如`if(t>a[j].tim)`才执行，否则直接标记失败）。特别值得学习的是**分情况处理**——把复杂问题拆成两个简单子问题，逐一解决。

**题解二：来源（作者：长安何处在，赞：4）**
* **点评**：这份题解的“倒序处理”思路很新颖！作者把b≤0的任务倒过来想：假设所有任务都完成了，T是总和`sum`，那么完成第n-1个任务时，T是`sum - b_n`（因为b_n是负数，所以`sum - b_n`比sum大）。这样，b≤0的任务就变成了“增益任务”（b_new = -b_old），需要按`t_i - b_new`（即`t_i + b_old`）升序排列（和之前的结论一致）。这种“逆向思维”能帮你从不同角度理解问题，适合拓展思路。

**题解三：来源（作者：DоsLikе，赞：2）**
* **点评**：这份题解用**优先队列**实现贪心，代码简洁高效！对于b>0的任务，用优先队列存`t_i`的相反数（实现升序排列）；对于b≤0的任务，存`t_i + b_i`（实现降序排列）。优先队列的使用让代码更紧凑，适合处理大规模数据（n≤1e5）。需要注意的是，队列一定要清空（否则多组数据会出错），这是容易忽略的细节。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，你可能会遇到以下3个核心难点，结合优质题解的经验，我们来一一破解：
</difficulty_intro>

1.  **难点1：如何正确分类任务？**
    * **分析**：必须把任务分成b>0和b≤0两组。如果先做b≤0的任务，T会变小，可能无法完成后面的b>0任务（比如T=5，先做t=3、b=-2，T变成3，再做t=4、b=5就做不了，而先做t=4、b=5，T变成10，再做t=3、b=-2就没问题）。优质题解都采用了“先处理b>0，再处理b≤0”的策略，这是贪心的基础。
    * 💡 **学习笔记**：**增益任务优先**——能让你“变强”的任务先做，才能应对更难的挑战。

2.  **难点2：b≤0的任务如何排序？**
    * **分析**：用**邻项交换法**证明：假设两个任务i和j（b_i、b_j≤0），当前T，若先做i再做j会失败，而先做j再做i会成功，则必须满足`t_i + b_i < t_j + b_j`（推导过程：`T + b_i ≤ t_j`且`T + b_j > t_i`，联立得`t_i + b_i < t_j + b_j`）。因此，b≤0的任务要按`t_i + b_i`降序排列。
    * 💡 **学习笔记**：**逆向考虑“剩余价值”**——b≤0的任务，完成后T会减少，所以要选“剩余价值”（t_i + b_i）大的，这样剩下的T才能撑过下一个任务。

3.  **难点3：如何处理T的实时检查？**
    * **分析**：每完成一个任务，都要检查T是否>0（否则直接失败），以及下一个任务的t_i是否≤当前T（否则无法完成）。优质题解都在循环中加入了这些检查（比如`if(t<=a[j].tim) break;`），确保一旦不符合条件就立即停止，避免无效计算。
    * 💡 **学习笔记**：**实时止损**——编程中要及时检查边界条件，避免做无用功。

### ✨ 解题技巧总结
- **分而治之**：把复杂问题拆成两个子问题（b>0和b≤0），分别解决。
- **邻项交换法**：证明贪心策略正确性的常用方法，通过比较两个相邻元素的顺序，推导最优排列。
- **实时检查**：每一步都要检查边界条件（T>0、T>t_i），确保算法的正确性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用的核心实现，综合了优质题解的思路，结构清晰，适合入门：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自lwz2002的题解，是“贪心策略”的标准实现，逻辑清晰，适合初学者理解。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;

    struct Task {
        int t; // 任务的t_i
        int b; // 任务的b_i
    };

    Task gain[100010]; // 存b>0的任务
    Task loss[100010]; // 存b≤0的任务

    // 比较函数：b>0的任务按t升序排列
    bool cmp_gain(const Task& a, const Task& b) {
        return a.t < b.t;
    }

    // 比较函数：b≤0的任务按t+b降序排列
    bool cmp_loss(const Task& a, const Task& b) {
        return (a.t + a.b) > (b.t + b.b);
    }

    int main() {
        int z;
        scanf("%d", &z);
        while (z--) {
            int n, T;
            scanf("%d%d", &n, &T);
            int cnt_gain = 0, cnt_loss = 0;
            for (int i = 0; i < n; ++i) {
                int t, b;
                scanf("%d%d", &t, &b);
                if (b > 0) {
                    gain[cnt_gain++] = {t, b};
                } else {
                    loss[cnt_loss++] = {t, b};
                }
            }
            // 排序
            sort(gain, gain + cnt_gain, cmp_gain);
            sort(loss, loss + cnt_loss, cmp_loss);
            // 处理b>0的任务
            bool ok = true;
            for (int i = 0; i < cnt_gain; ++i) {
                if (T <= gain[i].t) {
                    ok = false;
                    break;
                }
                T += gain[i].b;
            }
            // 处理b≤0的任务
            if (ok) {
                for (int i = 0; i < cnt_loss; ++i) {
                    if (T <= loss[i].t) {
                        ok = false;
                        break;
                    }
                    T += loss[i].b;
                    if (T <= 0) {
                        ok = false;
                        break;
                    }
                }
            }
            // 输出结果
            printf("%s\n", ok ? "+1s" : "-1s");
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为三步：1. 读取数据，将任务分为b>0（`gain`数组）和b≤0（`loss`数组）两组；2. 分别排序（`gain`按t升序，`loss`按t+b降序）；3. 依次处理两组任务，每步检查T是否符合要求（>t_i且>0）。如果任何一步失败，直接标记`ok=false`，输出`-1s`。

---

<code_intro_selected>
接下来，我们看两个优质题解的核心片段，学习它们的亮点：
</code_intro_selected>

**题解二（长安何处在）：倒序处理b≤0的任务**
* **亮点**：用逆向思维将b≤0的任务转化为“增益任务”，思路新颖。
* **核心代码片段**：
    ```cpp
    // 处理b≤0的任务（倒序）
    long long sum = 0;
    for (int i = 1; i <= cnt2; ++i) {
        sum += y[i].b; // 计算所有b≤0的总和（sum是负数）
    }
    long long new_T = T + sum; // 倒序后的初始T（所有任务完成后的T）
    if (new_T <= 0) {
        flag = false;
    } else {
        // 将b≤0的任务转化为：t_new = t_i - (-b_i) = t_i + b_i，b_new = -b_i（正数）
        sort(y + 1, y + cnt2 + 1, [](const yy& a, const yy& b) {
            return (a.ti + a.b) < (b.ti + b.b); // 按t_new升序排列（即原t+b升序）
        });
        for (int i = 1; i <= cnt2; ++i) {
            if (new_T <= (y[i].ti + y[i].b)) { // 倒序后的t要求：new_T > t_new
                flag = false;
                break;
            }
            new_T -= (-y[i].b); // 倒序处理：减去b_new（即加上原b_i）
        }
    }
    ```
* **代码解读**：
    > 作者假设所有任务都完成了，此时T是`T + sum`（sum是所有b≤0的总和，因为b≤0，所以sum≤0）。然后倒序处理b≤0的任务：每一步的`new_T`是“完成前i-1个任务后的T”，需要满足`new_T > t_i + b_i`（倒序后的t要求）。这种方法把b≤0的任务转化为“增益任务”（b_new = -b_i>0），从而可以用和b>0任务相同的策略（按t升序排列）。
* 💡 **学习笔记**：逆向思维能帮你从不同角度看问题，有时候会让复杂的问题变得简单。

**题解三（DоsLikе）：优先队列实现贪心**
* **亮点**：用优先队列优化排序，代码更紧凑，适合大规模数据。
* **核心代码片段**：
    ```cpp
    #include <queue>
    using namespace std;

    priority_queue<pair<int, int>> gain; // 存b>0的任务，first是-t（升序），second是b
    priority_queue<pair<int, int>> loss; // 存b≤0的任务，first是t+b（降序），second是t

    int main() {
        int z;
        scanf("%d", &z);
        while (z--) {
            int n, T;
            scanf("%d%d", &n, &T);
            // 读取数据，存入优先队列
            for (int i = 0; i < n; ++i) {
                int t, b;
                scanf("%d%d", &t, &b);
                if (b > 0) {
                    gain.push(make_pair(-t, b)); // -t升序，即t升序
                } else {
                    loss.push(make_pair(t + b, t)); // t+b降序
                }
            }
            // 处理b>0的任务
            bool ok = true;
            while (!gain.empty()) {
                int t = -gain.top().first;
                int b = gain.top().second;
                gain.pop();
                if (T <= t) {
                    ok = false;
                    break;
                }
                T += b;
            }
            // 处理b≤0的任务
            if (ok) {
                while (!loss.empty()) {
                    int t = loss.top().second;
                    int b = loss.top().first - t; // b = (t+b) - t = 原b
                    loss.pop();
                    if (T <= t) {
                        ok = false;
                        break;
                    }
                    T += b;
                    if (T <= 0) {
                        ok = false;
                        break;
                    }
                }
            }
            // 输出结果
            printf("%s\n", ok ? "+1s" : "-1s");
            // 清空队列
            while (!gain.empty()) gain.pop();
            while (!loss.empty()) loss.pop();
        }
        return 0;
    }
    ```
* **代码解读**：
    > 优先队列（`priority_queue`）默认是大顶堆（降序）。对于b>0的任务，我们存`t`的相反数（`-t`），这样大顶堆就变成了升序（`-t`越大，`t`越小）。对于b≤0的任务，我们存`t + b`（大顶堆降序），这样就能按`t + b`从大到小处理。优先队列的使用让代码更简洁，不需要手动排序，适合处理大规模数据（n≤1e5）。
* 💡 **学习笔记**：优先队列是贪心算法的常用工具，能高效地维护当前最优解。

---

## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了让贪心算法“动”起来，我设计了一个**8位像素风格的动画**，像玩FC游戏一样学习算法！我们会用“魔法任务”的场景，展示任务排序和T变化的过程。
\</visualization\_intro\>

### **动画演示主题**：魔法任务大挑战（8位像素风）
**风格**：仿照FC游戏《超级马里奥》的UI，用16色调色板（红、绿、蓝、黄等），角色是一个小巫师，任务是“收集魔法水晶”（b>0）和“处理诅咒”（b≤0）。

### **核心演示内容**
1. **场景初始化**：
   - 屏幕左侧是“任务列表”：绿色方块代表b>0的任务（标注`t_i`和`+b_i`），红色方块代表b≤0的任务（标注`t_i`和`-|b_i|`）。
   - 屏幕右侧是“时间进度条”（T）：绿色填充，显示当前T值。
   - 屏幕下方是“控制面板”：有“开始/暂停”“单步执行”“重置”按钮，以及速度滑块（1x-5x）。
   - 背景音乐：8位风格的轻快旋律（类似《塞尔达传说》的开头曲）。

2. **算法启动**：
   - 小巫师站在任务列表前，旁边显示“当前时间：T=XX”。
   - 点击“开始”，动画自动播放：首先处理b>0的任务（绿色方块），按`t_i`升序排列（从小到大跳动）。

3. **核心步骤演示**：
   - **处理b>0的任务**：
     - 小巫师走到第一个绿色方块前（t最小的任务），进度条闪烁（提示“检查T是否>t_i”）。
     - 如果T>t_i，小巫师拿起水晶，进度条变长（T增加b_i），伴随“叮”的音效（类似吃金币的声音）。
     - 如果T≤t_i，进度条变成红色，小巫师摇头，显示“失败！”，伴随“ buzzer”音效。
   - **处理b≤0的任务**：
     - 绿色任务处理完后，红色任务按`t_i + b_i`降序排列（从大到小跳动）。
     - 小巫师走到第一个红色方块前（t+b最大的任务），进度条闪烁（提示“检查T是否>t_i”）。
     - 如果T>t_i，小巫师处理诅咒，进度条变短（T增加b_i，即减少|b_i|），伴随“滋滋”的音效（类似放电的声音）。
     - 如果T≤0，进度条变成红色，小巫师摔倒，显示“失败！”，伴随“ crash”音效。

4. **目标达成**：
   - 所有任务处理完后，小巫师跳起来，显示“成功！+1s”，伴随“胜利”音效（类似《超级马里奥》的通关音乐）。
   - 进度条变成金色，任务列表消失，显示“你完成了所有魔法任务！”。

### **交互设计**
- **单步执行**：点击“单步”，动画走一步（处理一个任务），方便观察每一步的变化。
- **自动播放**：点击“开始”，动画按设置的速度（1x-5x）自动播放，适合快速浏览整体流程。
- **重置**：点击“重置”，回到初始状态，重新开始。

### **设计思路**
- **像素风格**：营造复古游戏的氛围，让学习更有趣。
- **音效提示**：用不同的音效强化关键操作（比如“叮”代表增益，“滋滋”代表消耗），帮助记忆。
- **进度条可视化**：实时显示T的变化，让“贪心”的效果一目了然（比如处理b>0的任务时，进度条越来越长；处理b≤0的任务时，进度条越来越短，但能撑过所有任务）。

\<visualization\_conclusion\>
通过这个动画，你能清楚地看到**贪心算法的每一步选择**——为什么先做b>0的任务，为什么b≤0的任务要按`t+b`排序。就像玩游戏一样，你会慢慢理解“每一步选最优”的智慧！
\</visualization\_conclusion\>

---

## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
贪心算法是编程中的“常客”，掌握了本题的策略，你可以解决很多类似的问题。下面是几个拓展练习，帮你巩固贪心思维：
\</similar\_problems\_intro\>

### **通用思路迁移**
本题的贪心策略（分两组处理、邻项交换证明）可以用到以下场景：
- **资源分配问题**：比如给工人分配任务，让总效率最高（优先分配擅长的任务）。
- **排序问题**：比如合并果子（优先合并小的果子，总代价最小）。
- **时间管理问题**：比如安排会议，让能参加的会议最多（优先选结束时间早的会议）。

### **练习推荐 (洛谷)**
1.  **洛谷 P1090 - 合并果子**
   - 🗣️ **推荐理由**：这道题是贪心算法的经典题，需要用邻项交换法证明“优先合并小果子”的正确性，和本题的b≤0任务排序思路一致。
2.  **洛谷 P2123 - 皇后游戏**
   - 🗣️ **推荐理由**：这道题需要将任务按`min(a_i, b_j)`排序，证明过程用到了邻项交换法，能帮你深化对贪心策略的理解。
3.  **洛谷 P3817 - 小A的糖果**
   - 🗣️ **推荐理由**：这道题需要将糖果分配给小朋友，让总糖果数最少，用到了“贪心+排序”的策略，和本题的“先处理增益任务”思路类似。

---

## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
很多作者在题解中分享了自己的踩坑经历，这些经验能帮你少走弯路：
\</insights\_intro\>

> **参考经验 (来自lwz2002)**：“我一开始做这道题的时候，b≤0的任务按b从大到小排序，结果卡了82分。后来想通了，必须用`t+b`排序，因为b小的任务可能t很大，完成后T不够用。”  
> **点评**：这位作者的经历提醒我们，**贪心策略不能只看直觉**，必须用数学证明。比如b≤0的任务，按b从大到小排序（比如b=-2比b=-5大），但可能t很大（比如t=100，b=-2），完成后T变成T-2，可能无法完成t=50、b=-5的任务（因为T-2≤50）。而按`t+b`排序（比如t=50+b=-5=45，比t=100+b=-2=98小），先做t=100、b=-2的任务，T变成T-2，只要T-2>50，就能完成t=50、b=-5的任务。

> **参考经验 (来自DоsLikе)**：“我一开始没清空优先队列，结果多组数据只过了73分。后来发现，每处理一组数据，必须清空队列，否则上一组的数据会影响下一组。”  
> **点评**：这个细节很重要！编程中，**多组数据处理时，必须重置变量和数据结构**（比如队列、数组），否则会导致错误。

---

\<conclusion\>
本次关于“魔法”的C++解题分析就到这里。贪心算法的核心是“每一步选当前最优”，但一定要用数学证明策略的正确性。希望这份指南能帮你掌握贪心思维，解决更多编程问题！记住，**编程就像魔法，只要思路正确，就能“变”出答案**！💪
\</conclusion\>

---
处理用时：286.03秒
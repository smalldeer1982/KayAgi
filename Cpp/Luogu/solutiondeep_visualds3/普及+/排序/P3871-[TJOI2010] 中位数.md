# 题目信息

# [TJOI2010] 中位数

## 题目描述

给定一个由 $N$ 个元素组成的整数序列，现在有两种操作：

- $\texttt{1 add }\textit{a}$：在该序列的最后添加一个整数 $a$，组成长度为 $N + 1$ 的整数序列。
- $\texttt{2 mid}$：输出当前序列的中位数。

中位数是指将一个序列按照从小到大排序后处在中间位置的数。（若序列长度为偶数，则指处在中间位置的两个数中较小的那个）

例 $1$：$[1, 2, 13, 14, 15, 16]$ 中位数为 $13$。  
例 $2$：$[1, 3, 5, 7, 10, 11, 17]$ 中位数为 $7$。  
例 $3$：$[1, 1, 1, 2, 3]$ 中位数为 $1$。


## 说明/提示

### 数据范围及约定

- 对于 $30\%$ 的数据，$1 ≤ N ≤ 10,000$，$0 ≤ M ≤ 1,000$。
- 对于 $100\%$ 的数据，$1 ≤ N ≤ 100,000$，$0 ≤ M ≤ 10,000$。

序列中整数的绝对值不超过 $10^9$，序列中的数可能有重复。

## 样例 #1

### 输入

```
6
1 2 13 14 15 16
5
add 5
add 3
mid
add 20
mid
```

### 输出

```
5
13
```

# AI分析结果

# 💡 Kay的C++算法解析：[TJOI2010]中位数 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态第k大问题（中位数是特殊的第k大，k=(当前序列长度+1)//2）  

🗣️ **初步分析**：  
题目要求动态维护一个序列，支持**添加元素**和**查询中位数**。中位数是排序后中间位置的元素（偶数时取较小的那个），本质是**动态第k大问题**（k=(n+1)//2，n为当前序列长度）。  

解决这类问题的核心思路是**高效维护有序序列**，常见算法包括：  
- **对顶堆**：用两个堆（大根堆+小根堆）分割序列，快速定位中位数。  
- **平衡树**（如fhq treap、splay）：维护有序结构，支持插入和第k大查询。  
- **权值线段树/树状数组**：离散化元素，统计出现次数，通过二分查找第k大。  

### 核心算法流程与可视化设计思路  
以**对顶堆**为例（最易理解且代码简洁）：  
1. **堆的分工**：大根堆（`max_heap`）维护前k个元素（中位数及之前的部分），小根堆（`min_heap`）维护后面的元素。  
2. **插入逻辑**：新元素与大根堆顶比较，小则加入大根堆，否则加入小根堆；调整堆大小，确保大根堆的大小等于k。  
3. **查询逻辑**：直接取大根堆顶（中位数）。  

**可视化设计**：  
- **风格**：8位像素风（类似FC游戏），大根堆用**红色方块**，小根堆用**蓝色方块**。  
- **关键步骤动画**：  
  - 插入元素时，元素从屏幕下方升起，与大根堆顶比较后“落入”对应堆。  
  - 调整堆大小时，元素在两个堆之间“移动”（如大根堆顶移到小根堆）。  
  - 查询时，大根堆顶**闪烁**并显示“中位数”字样，伴随“滴”的音效。  


## 2. 精选优质题解参考

### 题解一：对顶堆（作者：这有一只匿）  
**点评**：  
思路**极其清晰**，用两个堆分割序列，直接命中中位数的核心逻辑。代码**简洁高效**（仅30行左右），时间复杂度为O(logn) per operation（堆操作的时间复杂度）。  
**亮点**：  
- 堆的平衡维护逻辑：插入后检查大根堆大小是否等于k，若不等则从另一个堆取元素调整，确保中位数始终在大根堆顶。  
- 代码可读性高：变量名（`max_heap`、`min_heap`）清晰，逻辑流程一目了然。  

### 题解二：fhq treap（作者：陈曦）  
**点评**：  
平衡树的经典应用，通过**分裂与合并**操作维护有序序列，支持插入和第k大查询。代码**结构规范**，体现了平衡树的核心思想（子树大小维护）。  
**亮点**：  
- 子树大小维护：每个节点记录子树大小，分裂时根据子树大小定位位置，确保第k大查询的时间复杂度为O(logn)。  
- 通用性强：平衡树可扩展到其他动态序列问题（如删除、前驱/后继查询）。  

### 题解三：树状数组+二分（作者：ajil）  
**点评**：  
思路**巧妙**，通过离散化处理大数值，用树状数组统计元素出现次数，再通过二分查找第k大。代码**逻辑严谨**，适合学习离散化和树状数组的应用。  
**亮点**：  
- 离散化：将所有可能的元素（初始+插入）收集、排序、去重，映射到连续索引，解决了数值范围大的问题。  
- 二分查找：通过树状数组的前缀和，快速定位第k大的元素，时间复杂度为O(logn) per operation。  


## 3. 核心难点辨析与解题策略

### 1. 对顶堆：维护堆的大小平衡  
**难点**：如何确保大根堆的大小始终等于k=(n+1)//2？  
**策略**：  
- 插入元素后，检查大根堆与小根堆的大小关系：  
  - 若大根堆大小超过小根堆+1，将大根堆顶移到小根堆。  
  - 若小根堆大小超过大根堆，将小根堆顶移到大根堆。  

### 2. 平衡树：维护子树大小  
**难点**：如何快速查询第k大元素？  
**策略**：  
- 每个节点记录子树大小（`size`），表示以该节点为根的子树中的元素个数。  
- 查询第k大时，根据左子树的大小判断k的位置（左子树大小≥k则在左子树，否则在右子树）。  

### 3. 权值线段树：离散化处理  
**难点**：元素数值范围大（1e9），无法直接作为数组索引。  
**策略**：  
- 收集所有可能的元素（初始序列+所有插入操作的元素）。  
- 对元素排序、去重，将每个元素映射到连续的索引（如1~m，m为不同元素的数量）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（对顶堆）  
**说明**：此代码综合了优质题解的思路，是对顶堆的经典实现，简洁高效。  
```cpp
#include <iostream>
#include <cstdio>
#include <queue>
using namespace std;

priority_queue<int> max_heap; // 大根堆：维护前k个元素（中位数及之前）
priority_queue<int, vector<int>, greater<int>> min_heap; // 小根堆：维护后面的元素
int n, m;

void insert(int x) {
    if (max_heap.empty()) {
        max_heap.push(x);
        return;
    }
    // 新元素≤大根堆顶，加入大根堆
    if (x <= max_heap.top()) {
        max_heap.push(x);
        // 确保大根堆大小不超过小根堆+1
        if (max_heap.size() > min_heap.size() + 1) {
            min_heap.push(max_heap.top());
            max_heap.pop();
        }
    } else {
        // 新元素>大根堆顶，加入小根堆
        min_heap.push(x);
        // 确保大根堆大小不小于小根堆
        if (max_heap.size() < min_heap.size()) {
            max_heap.push(min_heap.top());
            min_heap.pop();
        }
    }
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        int x;
        scanf("%d", &x);
        insert(x);
    }
    scanf("%d", &m);
    while (m--) {
        char op[5];
        scanf("%s", op);
        if (op[0] == 'a') {
            int x;
            scanf("%d", &x);
            insert(x);
            n++;
        } else {
            printf("%d\n", max_heap.top()); // 中位数是大根堆顶
        }
    }
    return 0;
}
```  
**代码解读概要**：  
- `insert`函数：处理插入逻辑，维护两个堆的大小平衡。  
- `main`函数：读取输入，调用`insert`插入元素，查询时输出大根堆顶。  


### 针对各优质题解的片段赏析

#### 题解一：对顶堆（核心片段）  
**亮点**：堆平衡维护的关键逻辑。  
```cpp
if (max_heap.size() > min_heap.size() + 1) {
    min_heap.push(max_heap.top());
    max_heap.pop();
}
```  
**代码解读**：  
当大根堆的大小超过小根堆+1时，将大根堆顶移到小根堆，确保大根堆的大小等于k=(n+1)//2。比如，初始序列插入5后，大根堆变大，需要将多余的元素移到小根堆。  
**学习笔记**：堆的平衡维护是对顶堆的核心，一定要记住“大根堆大小=小根堆大小+1（当n为奇数）”或“大根堆大小=小根堆大小（当n为偶数）”。  

#### 题解二：fhq treap（核心片段：查询第k大）  
**亮点**：利用子树大小快速定位第k大元素。  
```cpp
int find_kth(Node *p, int k) {
    while (true) {
        int s = size(p->ls) + 1; // 左子树大小+当前节点
        if (k == s) return p->val; // 当前节点是第k大
        if (k < s) p = p->ls; // 第k大在左子树
        else { k -= s; p = p->rs; } // 第k大在右子树，调整k的值
    }
}
```  
**代码解读**：  
通过比较左子树的大小，判断第k大元素的位置。比如，左子树大小为3，k=4，则第4大元素是当前节点；k=2，则在左子树；k=5，则在右子树（k调整为5-3-1=1）。  
**学习笔记**：子树大小是平衡树查询第k大的关键，每次查询都要根据子树大小调整方向。  

#### 题解三：树状数组+二分（核心片段：离散化）  
**亮点**：处理大数值的离散化逻辑。  
```cpp
// 收集所有可能的元素（初始+插入）
for (int i = 1; i <= n; ++i) a[i] = read(), b[i] = a[i];
for (int i = 1; i <= m; ++i) {
    if (q[i].t == 1) {
        q[i].x = read();
        b[++cnt] = q[i].x;
    }
}
// 排序、去重
sort(b + 1, b + 1 + cnt);
int tmp = unique(b + 1, b + 1 + cnt) - (b + 1);
// 映射到连续索引
for (int i = 1; i <= n; ++i) rnk[i] = lower_bound(b + 1, b + 1 + tmp, a[i]) - b;
```  
**代码解读**：  
将所有可能的元素收集到数组`b`中，排序后去重，得到不同元素的数量`tmp`。然后用`lower_bound`将每个元素映射到连续的索引（如1~tmp）。  
**学习笔记**：离散化是处理大数值问题的常用技巧，一定要记住“收集→排序→去重→映射”的流程。  


## 5. 算法可视化：像素动画演示（对顶堆）

### 动画演示主题  
**《堆的魔法：寻找中位数》**（8位像素风，类似FC游戏《吃豆人》）  

### 核心演示内容  
1. **初始场景**：  
   - 屏幕左侧显示大根堆（红色方块，堆顶是初始中位数），右侧显示小根堆（蓝色方块）。  
   - 顶部显示当前序列长度（如`n=6`）和中位数（如`13`）。  
2. **插入操作**（以插入`5`为例）：  
   - 屏幕下方出现一个绿色方块（代表`5`），缓慢上升到大根堆顶。  
   - 绿色方块与大根堆顶（`13`）比较，因为`5≤13`，“落入”大根堆（红色方块数量+1）。  
   - 大根堆大小超过小根堆+1，大根堆顶（`13`）“移动”到小根堆（蓝色方块数量+1）。  
3. **查询操作**（点击“mid”按钮）：  
   - 大根堆顶（`5`）闪烁，伴随“滴”的音效，顶部显示“中位数：5”。  
4. **交互控制**：  
   - 控制面板有“单步执行”“自动播放”“重置”按钮，速度滑块（调节动画速度）。  
   - 自动播放模式：动画按顺序执行插入和查询操作，类似“AI演示”。  

### 设计思路  
- **像素风格**：营造复古游戏氛围，降低学习压力。  
- **颜色编码**：用红色（大根堆）、蓝色（小根堆）、绿色（新元素）区分不同部分，清晰展示元素流动。  
- **音效反馈**：插入时“叮”的一声，查询时“滴”的一声，强化操作记忆。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
动态第k大问题的解法（对顶堆、平衡树、权值线段树）可迁移到以下场景：  
- **实时排行榜**：动态维护用户分数的前10名。  
- **数据流中位数**：从无限数据流中实时获取中位数。  
- **区间第k大**：结合线段树或树状数组，解决区间内的第k大问题（如洛谷P3834）。  

### 练习推荐（洛谷）  
1. **洛谷P1168** - 中位数（静态）  
   🗣️ **推荐理由**：练习静态序列的第k大查询，巩固对中位数的理解。  
2. **洛谷P3369** - 普通平衡树（动态）  
   🗣️ **推荐理由**：练习平衡树的插入、删除、第k大查询，掌握平衡树的通用用法。  
3. **洛谷P2085** - 最小函数值（堆的应用）  
   🗣️ **推荐理由**：练习用堆维护多个序列的最小值，拓展堆的应用场景。  
4. **洛谷P1631** - 序列合并（堆的应用）  
   🗣️ **推荐理由**：练习用堆合并多个有序序列，巩固堆的排序功能。  


## 7. 学习心得与经验分享（若有）

### 对顶堆的维护技巧（来自题解作者“这有一只匿”）  
**经验分享**：“插入元素后，一定要检查两个堆的大小，确保大根堆的大小等于k=(n+1)//2。比如，当插入的元素比大根堆顶小，加入大根堆后，如果大根堆太大，就把顶元素移到小根堆；如果插入的元素比大根堆顶大，加入小根堆后，如果小根堆太大，就把顶元素移到大根堆。”  
**点评**：这是对顶堆的核心技巧，直接决定了中位数的正确性。一定要记住“平衡”的原则，不要让任何一个堆过大。  

### 平衡树的实现注意事项（来自题解作者“陈曦”）  
**经验分享**：“维护子树大小是平衡树的关键，每次插入、分裂、合并操作后都要更新节点的size。比如fhq treap的split和merge函数中，每次修改子节点后都要调用update函数。”  
**点评**：子树大小是平衡树查询第k大的基础，忘记更新size会导致查询错误。一定要养成“修改后更新”的习惯。  


## 📝 总结  
本次分析的“中位数”问题，核心是**动态第k大**，常见解法有对顶堆、平衡树、权值线段树。其中，**对顶堆**是最易理解且代码简洁的解法，适合初学者入门；**平衡树**通用性强，适合拓展到其他动态序列问题；**权值线段树**适合处理大数值问题。  

希望这份指南能帮助你掌握动态第k大的解决思路，下次遇到类似问题时，能快速想到合适的算法！💪  

---  
**Kay的小提醒**：编程能力的提升在于**多练习**和**多思考**。试着用不同的算法解决同一问题，比较它们的优缺点，你会收获更多！😊

---
处理用时：303.00秒
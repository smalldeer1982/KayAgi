# 题目信息

# [NOIP2020] 排水系统

## 题目描述

对于一个城市来说，排水系统是极其重要的一个部分。

有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。

排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。

现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。

现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。

## 说明/提示

**【样例 #1 解释】**

$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  
$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\frac{1}{3}$ 吨污水。  
$2$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
$3$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
最终，$4$ 号结点排出 $\frac{1}{6} + \frac{1}{6} = \frac{1}{3}$ 吨污水，$5$ 号结点排出 $\frac{1}{3} + \frac{1}{6} + \frac{1}{6} = \frac{2}{3}$ 吨污水。

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $1$ |
| $4 \sim 6$ | ${10}^3$ | $1$ |
| $7 \sim 8$ | ${10}^5$ | $1$ |
| $9 \sim 10$ | ${10}^5$ | $10$ |

对于全部的测试点，保证 $1 \le n \le {10}^5$，$1 \le m \le 10$，$0 \le d_i \le 5$。

数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。

## 样例 #1

### 输入

```
5 1
3 2 3 5
2 4 5
2 5 4
0
0
```

### 输出

```
1 3
2 3
```

## 样例 #2

### 输入

```
见附件中的 water/water2.in```

### 输出

```
见附件中的 water/water2.ans```

## 样例 #3

### 输入

```
见附件中的 water/water3.in```

### 输出

```
见附件中的 water/water3.ans```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP2020] 排水系统 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：拓扑排序（Topological Sort）+ 分数高精度处理  

🗣️ **初步分析**：  
解决“排水系统”问题的核心逻辑，就像**排队打饭**——只有前面的人打完饭，后面的人才能开始打。这里的“前面的人”对应**上游排水节点**，“后面的人”对应**下游节点**。由于管道没有回路（DAG，有向无环图），我们可以用**拓扑排序**按“从上游到下游”的顺序处理每个节点，确保处理某个节点时，所有流入它的污水都已计算完毕。  

### 核心算法流程：
1. **初始化**：将所有**污水接收口**（入度为0的节点）加入队列，初始流量为1吨（分数形式`1/1`）。  
2. **拓扑处理**：每次从队列中取出一个节点，将其污水**均匀分配**给所有出边节点（流量=当前节点流量/出度）。  
3. **更新下游**：下游节点接收流量后，入度减1；当入度变为0时，加入队列等待处理。  
4. **输出结果**：所有**最终排水口**（出度为0的节点）的流量即为答案。  

### 关键难点与解决方案：
- **分数精度**：直接用浮点数会丢失精度，需用**分子+分母**分开存储，每次操作后用`gcd`约分。  
- **数值溢出**：分母可能很大（如`5^20`），需用`__int128`（128位整型）存储，避免爆`long long`。  
- **拓扑顺序正确性**：必须严格按入度为0的顺序处理节点，否则会导致流量计算错误。  

### 可视化设计思路：
我们将用**8位像素风格**（类似FC红白机）设计动画，展示拓扑排序的流程：  
- **节点状态**：绿色（未处理）、黄色（处理中）、红色（已处理）。  
- **流量流动**：用蓝色像素块表示污水，从当前节点“流”到出边节点，伴随“哗啦”音效。  
- **分数显示**：节点下方显示当前流量的分子/分母，更新时用闪烁效果提示。  
- **交互控制**：支持“单步执行”（逐节点处理）、“自动播放”（加速流程），以及“重置”按钮。  


## 2. 精选优质题解参考

### 题解一（来源：听取MLE声一片，赞28）
* **点评**：  
  这份题解是拓扑排序的“基础模板”，思路清晰易懂。作者用`vector`存图，`queue`维护入度为0的节点，核心逻辑是“处理节点→分配流量→更新下游”。虽然没有实现高精度（需自行添加），但框架完整，适合初学者理解拓扑排序的核心流程。**亮点**：明确区分了“入度”和“出度”的处理，代码结构工整，变量命名符合逻辑（如`in[]`表示入度，`out[]`表示出度）。

### 题解二（来源：hensier，赞10）
* **点评**：  
  此题解是**分数处理的典范**。作者用`wx[]`（分子）和`wy[]`（分母）存储每个节点的流量，通过`update`函数实现分数加法（通分+约分），并使用`__int128`避免溢出。**亮点**：`update`函数的逻辑严谨，处理了分母为0的边界情况；拓扑排序的队列操作正确，确保了流量计算的顺序性。代码可读性高，适合学习分数高精度处理。

### 题解三（来源：normalpcer，赞3）
* **点评**：  
  这份题解用C++20的`std::views`和`__int128`，代码风格现代。作者定义了`Frac`结构体，封装了分数的加法和除法操作，使代码更模块化。**亮点**：`Frac`结构体的`operator+`和`operator/`实现简洁，拓扑排序的`deque`操作高效，适合学习面向对象的分数处理和现代C++特性。


## 3. 核心难点辨析与解题策略

### 1. 拓扑排序的顺序正确性  
**难点**：如果处理节点的顺序错误（如先处理下游节点），会导致流量计算遗漏。  
**策略**：用队列维护入度为0的节点，每次处理节点后，将其出边节点的入度减1；当入度变为0时，再加入队列。这样确保了所有上游节点都处理完毕后，才会处理下游节点。  
💡 **学习笔记**：拓扑排序的核心是“入度控制”，入度为0的节点是处理的起点。

### 2. 分数的高精度处理  
**难点**：直接用浮点数会丢失精度，用`long long`会溢出。  
**策略**：用`__int128`存储分子和分母，每次加法或除法后用`gcd`约分。例如，分数加法的公式为：`a/b + c/d = (ad + bc)/bd`，约分后得到最简分数。  
💡 **学习笔记**：分数处理的关键是“分离分子分母”+“及时约分”。

### 3. 边界情况处理  
**难点**：分母为0（如未初始化的节点）或出度为0（最终排水口）的情况。  
**策略**：初始化所有节点的分母为1（避免除以0）；最终排水口的出度为0，不需要分配流量，直接输出其流量。  
💡 **学习笔记**：边界情况是bug的重灾区，需提前考虑并处理。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了优质题解的思路，使用`__int128`处理分数，实现了拓扑排序的完整流程。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <algorithm>
  using namespace std;
  typedef __int128 ll;

  const int N = 1e5 + 5;
  vector<int> g[N]; // 图的邻接表
  int in[N], out[N]; // 入度、出度
  ll zi[N], mu[N]; // 分子、分母

  // __int128 快写
  void write(ll x) {
      if (x > 9) write(x / 10);
      putchar(x % 10 + '0');
  }

  // 求最大公约数
  ll gcd(ll a, ll b) {
      return b == 0 ? a : gcd(b, a % b);
  }

  // 分数加法：a/b + c/d = (ad + bc)/bd，约分后存入a/b
  void add(ll &a, ll &b, ll c, ll d) {
      ll new_zi = a * d + c * b;
      ll new_mu = b * d;
      ll g = gcd(new_zi, new_mu);
      a = new_zi / g;
      b = new_mu / g;
  }

  int main() {
      int n, m;
      cin >> n >> m;
      for (int i = 1; i <= n; i++) {
          int k;
          cin >> k;
          out[i] = k;
          for (int j = 0; j < k; j++) {
              int v;
              cin >> v;
              g[i].push_back(v);
              in[v]++;
          }
          mu[i] = 1; // 初始化分母为1
      }

      queue<int> q;
      for (int i = 1; i <= n; i++) {
          if (in[i] == 0) { // 污水接收口
              q.push(i);
              zi[i] = 1; // 初始流量1/1
          }
      }

      while (!q.empty()) {
          int u = q.front();
          q.pop();
          if (out[u] == 0) continue; // 最终排水口，不分配流量
          // 计算每个出边的流量：zi[u]/(mu[u] * out[u])
          ll per_zi = zi[u];
          ll per_mu = mu[u] * out[u];
          ll g = gcd(per_zi, per_mu);
          per_zi /= g;
          per_mu /= g;
          // 分配流量给下游节点
          for (int v : g[u]) {
              add(zi[v], mu[v], per_zi, per_mu);
              in[v]--;
              if (in[v] == 0) {
                  q.push(v);
              }
          }
      }

      // 输出最终排水口的流量
      for (int i = 1; i <= n; i++) {
          if (out[i] == 0) {
              write(zi[i]);
              cout << " ";
              write(mu[i]);
              cout << endl;
          }
      }

      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读取图的结构，初始化入度、出度和分母。  
  2. **队列初始化**：将入度为0的污水接收口加入队列，初始流量为`1/1`。  
  3. **拓扑处理**：逐节点处理，分配流量给下游节点，更新入度和队列。  
  4. **输出结果**：输出所有出度为0的节点的流量（最简分数）。


### 针对各优质题解的片段赏析

#### 题解二（hensier）：分数加法函数  
* **亮点**：严谨处理了分数加法的通分和约分，避免了溢出。  
* **核心代码片段**：  
  ```cpp
  void update(I128 &x_1, I128 &y_1, I128 x_2, I128 y_2) {
      I128 p = y_1 * y_2 / gcd(y_1, y_2);
      x_1 *= p / y_1;
      x_2 *= p / y_2;
      x_1 += x_2;
      y_1 = p;
  }
  ```
* **代码解读**：  
  - `p`是两个分母的最小公倍数（通分后的分母）。  
  - 将两个分数的分子扩大到相同分母，然后相加。  
  - 最后将分母更新为`p`（后续会约分）。  
* 💡 **学习笔记**：通分是分数加法的关键，最小公倍数可以通过`(a*b)/gcd(a,b)`计算。


#### 题解三（normalpcer）：Frac结构体  
* **亮点**：封装了分数的加法和除法，使代码更模块化。  
* **核心代码片段**：  
  ```cpp
  struct Frac {
      i128 numerator; // 分子
      i128 denominator = 1; // 分母
      static Frac simplified(const Frac& origin) {
          auto g = gcd(origin.numerator, origin.denominator);
          return {origin.numerator / g, origin.denominator / g};
      }
      Frac operator+ (const Frac& other) const {
          return simplified({
              numerator * other.denominator + other.numerator * denominator,
              denominator * other.denominator
          });
      }
      Frac operator/ (const int other) const {
          return simplified({numerator, other * denominator});
      }
  };
  ```
* **代码解读**：  
  - `simplified`函数用于约分，返回最简分数。  
  - `operator+`实现分数加法，`operator/`实现分数除以整数。  
* 💡 **学习笔记**：面向对象的封装可以简化代码，提高可读性。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《像素排水队》  
**风格**：8位像素风（类似FC游戏《坦克大战》），用简单的图形和颜色表示节点和流量。  

### 核心演示内容：
1. **场景初始化**：  
   - 屏幕左侧显示**拓扑排序队列**（绿色方块表示待处理节点）。  
   - 中间显示**排水系统图**（节点用不同颜色表示状态：绿色=未处理，黄色=处理中，红色=已处理）。  
   - 右侧显示**当前节点信息**（分子/分母、出度）。  

2. **算法启动**：  
   - 污水接收口（入度为0）闪烁，伴随“滴”的音效，加入队列。  

3. **核心步骤演示**：  
   - **处理节点**：队列中的第一个节点变为黄色，显示其流量（如`1/1`）。  
   - **分配流量**：用蓝色像素块从当前节点“流”到所有出边节点，每个出边节点的流量更新（如`1/3`），伴随“哗啦”音效。  
   - **更新入度**：下游节点的入度减1，当入度变为0时，加入队列（绿色方块闪烁）。  

4. **目标达成**：  
   - 当所有节点处理完毕，最终排水口（红色）的流量闪烁，伴随“胜利”音效（类似《超级马里奥》的通关音乐）。  

### 交互设计：
- **单步执行**：点击“下一步”按钮，逐节点处理。  
- **自动播放**：拖动滑块调整速度（如1x、2x、4x），动画自动运行。  
- **重置**：点击“重置”按钮，回到初始状态。  

### 设计理由：
- **像素风格**：复古的视觉效果能激发兴趣，适合青少年学习者。  
- **音效提示**：关键操作（如分配流量、入度更新）用音效强化记忆，提高参与感。  
- **交互控制**：单步执行让学习者能仔细观察每一步，自动播放则能快速了解整体流程。


## 6. 拓展练习与相似问题思考

### 通用思路迁移：
拓扑排序+分数处理的思路，可用于解决**DAG上的流量分配**或**概率传递**问题，例如：  
- 电路中的电流分配（每个电阻的电流与电阻成反比）。  
- 社交网络中的信息传播（每个用户将信息传递给好友的概率）。  
- 生产线上的产品流转（每个工序的产品分配给下一道工序）。  

### 洛谷练习推荐：
1. **洛谷 P1038** - 《神经网络》  
   🗣️ **推荐理由**：考察拓扑排序的应用，需要处理节点的“激活值”传递，类似排水系统的流量分配。  
2. **洛谷 P1983** - 《车站分级》  
   🗣️ **推荐理由**：结合拓扑排序与贪心，需要确定车站的等级，锻炼逻辑思维。  
3. **洛谷 P1137** - 《旅行计划》  
   🗣️ **推荐理由**：拓扑排序与动态规划结合，需要计算最长路径，拓展拓扑排序的应用场景。  


## 7. 学习心得与经验分享 (若有)

### 参考经验（来自：hensier）：  
“我在解决这个问题时，最初没有考虑到分母会溢出，用`long long`导致了错误。后来改用`__int128`，并在每次加法后约分，才解决了问题。这让我意识到，处理大数时，必须选择合适的数据类型，并及时优化数值大小。”  

**点评**：这位作者的经验很典型。在编程中，**数据类型的选择**和**数值优化**（如约分）是避免溢出的关键。对于分数问题，`__int128`是一个很好的选择，既能处理大数，又不需要写复杂的高精度代码。  


## 结语  
本次关于“排水系统”的C++解题分析就到这里。希望这份指南能帮助你理解拓扑排序的核心逻辑，掌握分数高精度处理的技巧。记住，**编程的关键是思路清晰**——先想清楚“怎么做”，再写代码“实现”。下次我们再一起探索新的编程挑战！💪  

---  
**Kay的小提醒**：如果对拓扑排序或分数处理还有疑问，可以尝试画一张小图（比如样例1的图），手动模拟拓扑排序的流程，这样能更快理解哦！

---
处理用时：211.05秒
# 题目信息

# 『SpOI - R1』笑起来最帅的小孩

## 题目描述

**本题包含多组数据。**

有一个数字序列 $a$，长度为 $n$。序列中每一项均为 $0$ 到 $9$ 的数字。

另有一个空数字序列 $b$，$b$ 中会出现一个**光标**（你可以理解为能够出现在数字之间，或整个数字序列之前，或整个数字序列之后的细线），此时**光标**前后均没有数字。

现在向 $b$ 中依次输入数字序列 $a$。每输入一个数字，数字立即出现在**光标**之后。

接下来**光标**立即随机地移动到任意一个数字之前或所有数字之后。随机是均匀的。换句话说，**光标**移动到所有可移动到的位置的概率是均等的。

现在告诉你数字序列 $a$。你需要输出的是，最终得到的 $b$ 直接转为十进制后的大小（无视前导零）的期望，对质数 $2007072007$ 取模。

由于 $a$ 可能很长，所以本题采用压缩输入。

具体来说，最开始 $a$ 是空的数字序列，输入会给你一个 $k$ 长的二元组数组，其中第 $i$ 项为 $(x_i,l_i)$，表示数字 $x_i$ 连续出现 $l_i$ 次接在之前的 $a$ 之后。你可以用此方法解压缩真正的 $a$，再解决问题。

----------

**在本题，你可以对期望的理解**：对于一个变量可能的结果 $X$，若其权值为 $v_X$，得到该结果的概率为 $p_X$，则对于结果集 $S$，变量的期望 $E=\sum\limits_{X\in S}p_Xv_X$。

**如果你不知道如何对有理数取模**：请查看[此题](https://www.luogu.com.cn/problem/P2613)。

## 说明/提示

### 数据范围

**本题开启子任务捆绑和子任务依赖。**

令 $n=\sum\limits_{i=1}^k l_i$。

对于 $100\%$ 的数据，保证 $1\leq T\leq 15$，$1\leq n\leq 2\times 10^9$，$1\leq k\leq 10^5$，且对于任意 $i$ 均有 $0\leq a_i\leq 9$，$1\leq l_i\leq 2\times 10^9$。


| Subtask | $T\leq$ | $n\leq$ | 特殊性质 | 得分 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $15$ | $2\times 10^9$ | $A$ | $10$ | 无 |
| 2 | $15$ | $100$ | 无 | $15$ | 无 |
| 3 | $5$ | $2000$ | 无 | $15$ | 2 |
| 4 | $5$ | $10^6$ | 无 | $15$ | 2,3 |
| 5 | $5$ | $2\times 10^9$ | 无 | $45$ | 1,2,3,4 |

特殊性质 $A$：保证在解压缩后的 $a$ 中，任意一个数字都出现了最多一次。

## 样例 #1

### 输入

```
1
2
4 1
2 1```

### 输出

```
33```

## 样例 #2

### 输入

```
1
3
1 2
3 1
7 2```

### 输出

```
1204285426```

# AI分析结果


### 💡 Kay的C++算法解析：『笑起来最帅的小孩』深入学习指南 💡

<introduction>
这道题看似复杂，但核心是数学期望与数论技巧的结合。我们将通过清晰的分析、代码实现和复古像素动画，带你理解光标随机移动如何等价于全排列，以及如何高效计算大数取模的期望值。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学期望` + `数论技巧应用`

🗣️ **初步分析**：
> 想象你在玩打字机游戏：每次输入数字后，光标会随机跳到文本的任何位置（包括开头和结尾）。这等价于生成数字序列的全排列！核心思路是：
> 1. **期望分解**：每个数字出现在每一位的概率相同
> 2. **公式化简**：期望 = (数字总和) × (等比数列和) / n
> 3. **大数优化**：用快速幂求10ⁿ，用逆元处理除法
>
> 可视化设计：我们将用像素风格展示数字插入过程，光标像跳动的小精灵随机选择位置。关键步骤高亮数字插入位置和实时计算过程，配合8-bit音效增强理解。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰性、代码规范性和算法优化度等维度，精选三条最具学习价值的题解：

**题解一（Yang18630303）**
* **点评**：推导最完整（从全排列概率到递归实现），用递归实现等比求和，虽稍低效但教学性强。变量命名规范（suma/n/o），边界处理严谨，包含实用调试技巧（如long long重要性）。

**题解二（__Raincoat__）**
* **点评**：最简洁高效的非递归实现，快速幂封装优雅。从光标移动方案数严格证明排列等价性，代码直接计算（10ⁿ-1)/9的逆元，实践性极强（55ms AC）。

**题解三（hexz01）**
* **点评**：结构清晰度最佳，将计算拆解为三个独立模块（数字和/等比和/逆元）。采用费马小定理求逆元，快速幂带模数参数，适合模块化复用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大关键点：

1.  **全排列等价性证明**
    * **分析**：理解光标随机移动 ≡ 生成随机排列（关键证明见Raincoat题解）。学习用组合数学思维转化随机过程。
    * 💡 **学习笔记**：随机插入位置 ≡ 均匀随机排列

2.  **期望公式化简**
    * **分析**：利用对称性将Σaᵢ×10ʲ拆解为(Σaᵢ)×(Σ10ʲ)/n。注意Σ10ʲ = (10ⁿ-1)/9的等比公式应用。
    * 💡 **学习笔记**：期望计算善用对称性分解

3.  **大数取模优化**
    * **分析**：n≤2×10⁹时需快速幂算10ⁿ，用逆元处理/9和/n（模数2007072007是质数）。递归/非递归实现各有适用场景。
    * 💡 **学习笔记**：大指数幂→快速幂，除法→逆元

### ✨ 解题技巧总结
- **数学建模**：将复杂过程（光标移动）抽象为随机排列
- **分治计算**：拆解期望为数字和/等比和/逆元三部分
- **边界防御**：时刻警惕n=0和long long溢出
- **模运算律**：(a*b)%m = [(a%m)*(b%m)]%m

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是融合多题解优点的通用实现，包含非递归快速幂和模块化计算：

**通用核心C++实现**
```cpp
#include <iostream>
#define ll long long
using namespace std;
const ll MOD = 2007072007;

ll qpow(ll a, ll b) { // 非递归快速幂
    a = (a % MOD + MOD) % MOD;
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    int T; cin >> T;
    while (T--) {
        int k; cin >> k;
        ll sum = 0, n = 0;
        
        // 压缩输入处理
        while (k--) {
            ll x, l; cin >> x >> l;
            n += l;
            sum = (sum + x * l) % MOD;
        }
        
        // 等比数列和 (10^n - 1)/9
        ll pow10 = qpow(10, n);
        ll geom = (pow10 - 1 + MOD) % MOD * qpow(9, MOD-2) % MOD;
        
        // 期望 = (sum * geom) * inv(n)
        ll inv_n = qpow(n, MOD-2);
        cout << sum * geom % MOD * inv_n % MOD << endl;
    }
    return 0;
}
```

**代码解读概要**：
1. `qpow`：非递归快速幂模板，高效计算指数取模
2. 压缩输入：边读边累加`sum`和`n`，避免存储整个序列
3. 逆元应用：用费马小定理求9⁻¹和n⁻¹（MOD为质数）
4. 链式取模：每步运算后取模，防止溢出

---
<code_intro_selected>
精选题解的独特技巧赏析：

**题解一：递归实现技巧**
```cpp
ll f_s1(int n) { // 递归求111...1
    if (n == 1) return 1;
    ll r = f_s1(n/2);
    ll pow_half = f_s(n/2); // 递归算10^(n/2)
    return n % 2 
        ? (r * pow_half % MOD + r) * 10 % MOD + 1 
        : (r * pow_half % MOD + r) % MOD;
}
```
> **解读**：通过`q(n)=q(n/2)*10^(n/2)+q(n/2)`的递推关系分治求解，虽非最优但展示分治思想。注意递归深度O(log n)仅30层左右，安全但效率不如闭式解。

**题解二：闭式解优势**
```cpp
ll geom = (qpow(10, n) - 1) * inv(9) % MOD;
```
> **解读**：直接使用等比公式(10ⁿ-1)/9，配合逆元避免除法。相比递归减少函数调用，性能更优。

**题解三：模块化设计**
```cpp
ll part1 = (...); // 数字和
ll part2 = (...); // (10^n-1)/9
ll part3 = qpow(n, MOD-2); // n逆元
cout << part1 * part2 % MOD * part3 % MOD;
```
> **解读**：将计算分解为三个独立模块，增强可读性和调试便利性。适合初学者理解公式结构。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**复古打字机模拟器**：通过8-bit像素动画演示数字插入和光标随机跳跃，同步显示期望计算过程。

### 动画设计
* **风格**：FC红白机风格，数字块用16色像素方块，光标为闪烁竖线
* **音效**：
  - 按键声：数字插入时（8-bit短促"嘀"）
  - 光标声：位置切换时（调高音阶）
  - 成功音：计算完成时（马里奥过关旋律）

### 关键帧演示
1. **初始化**：空序列`[ | ]`，控制面板（开始/单步/速度条）
2. **数字插入**：
   ```python
   [ | ] → 输入"3" → [3| ] → 光标随机跳 → [ |3 ] 
   ```
3. **实时计算**：
   - 屏幕右侧动态显示：
     ```
     当前和: 3
     等比和: (10^1-1)/9 = 1
     期望: (3*1)/1 = 3
     ```
4. **等比计算特效**：求10ⁿ时显示快速幂的二进制分解（如13=1101₂）

### 交互设计
- **单步模式**：按空格逐步插入数字
- **自动演示**：AI控制速度（可调速）
- **暂停/重置**：随时中断/重来

> **设计意图**：通过游戏化过程具象化抽象的概率分布（如光标位置均匀随机），动态公式帮助理解期望计算各组成部分。

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握期望分解和逆元应用后，可挑战：

1. **洛谷P2613** 有理数取模（逆元模板题）
   - 🗣️ **推荐理由**：巩固逆元在各种除法场景的应用
2. **洛谷P1226** 快速幂模板
   - 🗣️ **推荐理由**：非递归快速幂是数论题基础
3. **洛谷P1495** 曹冲养猪（中国剩余定理）
   - 🗣️ **推荐理由**：练习模运算的进阶应用

---

## 7. 学习心得与经验分享

<insights_intro>
题解中两位作者的调试经验值得借鉴：

> **Yang18630303**：*"十年OI一场空，不开long long见祖宗"*  
> **Raincoat**：*注意(10ⁿ-1)可能为负，需先加MOD再取模*

**Kay总结**：
1. 始终用`long long`和及时取模防御溢出
2. 测试边界值（如n=1, lᵢ=10⁹）
3. 模块化验证（先单独测试快速幂）

---

<conclusion>
通过本次分析，我们掌握了随机过程的数学抽象、期望分解的技巧和大数模运算优化。记住：好算法=数学洞察力+代码优化力。下次遇到类似问题，不妨先思考——能否找到概率等价关系？能否分解计算？加油！💪
</conclusion>
```

---
处理用时：195.80秒
# 题目信息

# 神奇的小江鸟

## 题目背景

You can also see the pdf at the bottom of the chinese problem statement.

感谢 [ineverleft](https://www.luogu.com.cn/user/362679) 为本题提供的本地调试 checker。

「愿有前程可奔赴，亦有岁月可回首。」

## 题目描述

小 $ \zeta $ 在探险过程中看到了一个大锁。

这个大锁有 $ n $ 个拨圈，第 $ i $ 个拨圈的拨动范围为 $ l_i $ 到 $ r_i $ 之间（含两个边界）的所有整数（保证 $ l_i \le r_i $）。

我们定义这个大锁的「自由度」为所有拨圈上的数的**最大公约数**，当锁的「自由度」大于等于 $ k $ 时，会被打开。

请你找到一种锁的开启方案，或报告无解。

## 说明/提示

**【样例 1 解释】**

唯一的一组数据 $ \gcd $ 为 $ 10 $。

五个样例自测均可使用下发的附件。**请注意部分样例可能存在多解，样例输出仅列举了一组可行解。**

**【数据规模与约定】**

对于 $ 100\% $ 的数据，$ 1 \le T \le 5 $，$ 2 \le n \le 10^4 $，$ 1 \le l_i \le r_i \le 10^9 $，$ 1 \le k \le 1000 $。

**本题开启子任务捆绑测试。**

* Subtask 1（10 pts）：$ k=1 $。
* Subtask 2（15 pts）：$ n \le 10 $，$ r_i - l_i + 1 \le 5 $。
* Subtask 3（15 pts）：$ r_i \le 10^3 $。
* Subtask 4（10 pts）：$ k \le 5 $，$ l_i,r_i $ 均在 $ 1 \le l_i \le r_i \le 10^9 $ 范围内等概率随机生成，该子任务只有 $ 1 $ 个测试点。
* Subtask 5（15 pts）：对于每组数据，$ \exist 1 \le i \le n,l_i=r_i $。
* Subtask 6（35 pts）：无特殊限制。

**【关于附加文件】**

**本题下发了 `checker.cpp` 作为自测器。**

请将输入内容、你的程序输出、参考答案输出分别放置在 `restore.in`、`restore.out`、`restore.ans` 中，这三个文件必须与 `checker.cpp` 在同一目录下，运行 `checker.cpp`，终端上会给出自测结果。

**你需要保证你的输入满足 $ 100\% $ 数据范围的要求。**

注意，如果你的输入/输出/答案的格式和范围不正确的话，`checker.cpp` 出现的结果是不可预料的。因此，**请先确保你的三个文件格式正确。**

## 样例 #1

### 输入

```
1
5 10
1 12
44 50
9 10
88 99
29 99```

### 输出

```
Yes
10 50 10 90 30```

## 样例 #2

### 输入

```
2
3 11
99 10003
39 299
39 10003
5 55
1 54
1 20
1 300
1 300
1 300```

### 输出

```
Yes
123 246 369
No```

## 样例 #3

### 输入

```
3
6 1
1 10
1 10
1 10
1 10
1 10
1 10
5 4
11 15
6 10
9 14
20 23
27 29
5 11
20 30
50 70
111 120
72 77
119 121```

### 输出

```
Yes
1 1 4 5 1 4
Yes
14 7 14 21 28
Yes
24 60 120 72 120```

## 样例 #4

### 输入

```
4
3 33
32 34
65 67
97 101
3 5
299 99494993
499 49992999
499 39999939
4 25
719 830
2194 2893
132 142
199 225
3 10
140 143
131 135
238 241```

### 输出

```
Yes
33 66 99
Yes
1919810 11400 51400
Yes
729 2700 135 216
No```

## 样例 #5

### 输入

```
1
10 7
77 77
82 174
77 77
82 174
77 77
82 174
77 77
82 174
77 77
82 174```

### 输出

```
Yes
77 154 77 154 77 154 77 154 77 154```

# AI分析结果


# 💡 Kay的C++算法解析：神奇的小江鸟 深入学习指南 💡

<introduction>
今天我们来分析"神奇的小江鸟"这道C++编程题。本指南将帮助你理解题目核心思路，掌握关键算法，并通过生动的像素动画直观感受算法执行过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学性质应用与高效枚举` 

🗣️ **初步分析**：
> 解决这道题的关键在于利用区间数学性质优化枚举过程。想象你在破解一个多环密码锁，每个环有自己的数字范围（区间），我们需要为每个环选一个数字，使所有数字的最大公约数(GCD)≥k。  
> - 核心思路：当区间长度≥k时，必存在k的倍数（鸽巢原理）；否则枚举最小区间内数字的因子(≥k)，验证是否满足所有区间  
> - 难点：避免暴力枚举值域(10^9)，通过最小区间约束将枚举量降至O(k√V)  
> - 可视化设计：像素风"因子探险"动画将展示：1) 区间长度检测 2) 最小区间内数字遍历 3) 因子分解气泡 4) 倍数位置验证，配合8-bit音效和关卡进度条  

---

## 2. 精选优质题解参考

<eval_intro>
基于思路清晰度、代码规范性和算法效率，我精选了以下优质题解：

**题解一：船酱魔王（思路清晰度：★★★★★）**
* **点评**：该解法准确捕捉到区间长度与k的关系这一核心数学性质。通过排序找到最小区间，巧妙枚举其数字的因子(≥k)，并用set去重优化。代码中`chk()`函数用整数除法高效验证倍数存在性，边界处理严谨，变量命名规范（如`rn`表范围）。亮点在于复杂度证明部分，通过理论计算消除超时疑虑。

**题解二：Moya_Rao（代码简洁性：★★★★☆）**
* **点评**：解法与题解一思路一致但实现更简洁。亮点在于双重循环中同时检查两个因子(i和x/i)，避免使用set存储。虽然少了去重，但通过`flag`及时跳出保证效率。代码结构清晰，`read()`函数处理输入增强可读性，适合初学者理解核心逻辑。

**题解三：Super_Cube（算法效率：★★★★☆）**
* **点评**：解法采用`unordered_set`存储因子提高插入效率。最大亮点是倍数存在性判断——直接用`(l-1)/d == r/d`整数除法等式验证，数学转化极其简洁。代码模块化好，`judge()`函数可独立复用，但变量命名可读性稍弱（如`kl`、`kr`）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点，以下是应对策略：

1.  **如何高效枚举公约数d？**  
    * **分析**：值域达10^9时暴力枚举不可行。利用**最小区间长度<k**的特性，只需枚举该区间内数字的因子(≥k)。因子总数约O(k√V)，实测在4e4量级。
    * 💡 **学习笔记**：枚举范围优化是降低复杂度的关键突破口。

2.  **如何快速验证d是否满足所有区间？**  
    * **分析**：用整数除法避免逐倍检查——对区间[l,r]，存在d倍数当且仅当⌊(l-1)/d⌋ < ⌊r/d⌋。代码实现：`(l-1)/d*d + d <= r`。
    * 💡 **学习笔记**：数学性质转化将O(n)验证降为O(1)。

3.  **如何处理特殊边界情况？**  
    * **分析**：当k=1时gcd恒≥1必有解；当所有区间长度≥k时直接取d=k（鸽巢原理保证可行）。优先检测这些情况避免无效枚举。
    * 💡 **学习笔记**：边界特判提升代码鲁棒性。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题的深度分析，总结以下通用解题技巧：
</summary_best_practices>
-   **技巧1：性质转化** —— 将"区间存在d倍数"转化为整数除法等式，避免暴力搜索
-   **技巧2：约束利用** —— 利用最小区间的强约束（长度<k）大幅缩减枚举范围
-   **技巧3：模块封装** —— 将核心操作封装成函数（如`findMultiple()`），提升可读性与复用性
-   **技巧4：数学优化** —— 因子枚举时同步处理i和num/i，避免重复计算

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下代码综合优质题解思路，包含完整输入输出和三种核心场景处理：

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
using namespace std;

struct Range { int l, r, id; };

bool cmp(Range a, Range b) {
    return (a.r - a.l) < (b.r - b.l); // 按区间长度排序
}

int findMultiple(int l, int r, int d) {
    int candidate = (l - 1) / d * d + d; // 计算>=l的最小d倍数
    return (candidate <= r) ? candidate : -1;
}

int main() {
    int T; cin >> T;
    while (T--) {
        int n, k; cin >> n >> k;
        vector<Range> ranges(n);
        for (int i = 0; i < n; i++) {
            cin >> ranges[i].l >> ranges[i].r;
            ranges[i].id = i;
        }

        // 场景1: k=1时必有解
        if (k == 1) {
            cout << "Yes\n";
            for (auto r : ranges) cout << r.l << " ";
            cout << "\n"; continue;
        }

        // 场景2: 检查所有区间长度是否>=k
        bool allLong = true;
        for (auto r : ranges)
            if (r.r - r.l + 1 < k) allLong = false;
        
        if (allLong) {
            cout << "Yes\n";
            for (auto r : ranges) 
                cout << ((r.l - 1) / k + 1) * k << " ";
            cout << "\n"; continue;
        }

        // 场景3: 处理存在短区间情况
        sort(ranges.begin(), ranges.end(), cmp);
        set<int> factors;
        auto& minRange = ranges[0];

        // 枚举最小区间内所有数字的因子(>=k)
        for (int num = minRange.l; num <= minRange.r; num++) {
            for (int i = 1; i * i <= num; i++) {
                if (num % i) continue;
                if (i >= k) factors.insert(i);
                if (num / i >= k) factors.insert(num / i);
            }
        }

        vector<int> ans(n, -1);
        int valid_d = -1;
        for (int d : factors) {
            bool ok = true;
            for (auto r : ranges) {
                int mult = findMultiple(r.l, r.r, d);
                if (mult == -1) { ok = false; break; }
                ans[r.id] = mult;
            }
            if (ok) { valid_d = d; break; }
        }

        if (valid_d == -1) cout << "No\n";
        else {
            cout << "Yes\n";
            for (int x : ans) cout << x << " ";
            cout << "\n";
        }
    }
    return 0;
}
```
* **代码解读概要**：
  - **输入处理**：读取多组数据，存储区间并记录原始ID
  - **场景分流**：优先处理k=1和全区间长度≥k的特殊情况
  - **因子收集**：对最小区间内每个数分解因子，用set去重
  - **验证输出**：检查每个因子是否满足所有区间，按原序输出

---
<code_intro_selected>
优质题解核心片段解析：

**题解一：船酱魔王（因子收集与验证）**
* **亮点**：使用set自动去重，避免重复验证相同因子
```cpp
set<int> se;
for(int num = minRange.l; num <= minRange.r; num++) {
  for(int i = 1; i * i <= num; i++) {
    if(num % i == 0) {
      if(i >= k) se.insert(i);
      if(num/i >= k) se.insert(num/i);
    }
  }
}
```
* **代码解读**：
  > 通过`i*i<=num`控制枚举范围至√num，高效收集因子。  
  > 同时插入i和num/i保证获得所有因子，set保证唯一性。  
  > **学习笔记**：因子分解时同步处理可避免后续排序

**题解二：Moya_Rao（边界处理艺术）**
* **亮点**：将区间检测与结果计算合并在同一循环
```cpp
for(int j=1; j<=n; j++) {
  int x = r[j]/d*d; // 计算最大d倍数
  if(x < l[j]) {    // 检查是否在区间内
    valid = false;
    break;
  }
}
```
* **代码解读**：
  > `r[j]/d*d`巧妙利用整数除法性质获得≤r的最大d倍数  
  > 与l[j]直接比较判断是否存在d倍数，省去额外函数调用  
  > **学习笔记**：利用整数除法特性简化倍数存在性判断

**题解三：Super_Cube（数学优化技巧）**
* **亮点**：用单行等式替代倍数查找函数
```cpp
bool exist = (b[i] / d) > ((a[i] - 1) / d);
```
* **代码解读**：
  > 基于⌊(a-1)/d⌋ < ⌊b/d⌋ ⇔ 区间存在d倍数的数学原理  
  > 将O(1)判断浓缩为单行表达式，极致简洁  
  > **学习笔记**：深入理解数学性质可大幅简化代码逻辑

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为直观理解算法流程，我设计了"像素风因子探险"动画方案，融合复古游戏元素：

* **主题**：8-bit风格"密码锁破解大冒险"  
* **核心演示**：最小区间因子分解与全局验证过程  
* **设计思路**：用FC红白机像素风格降低理解压力，关键操作音效强化记忆点  

**动画帧步骤**：  
1. **场景初始化**（像素网格+控制面板）  
   - 16色像素网格展示n个区间（不同颜色带）  
   - 控制面板含"步进/播放/重置"按钮和速度滑块  
   - 背景播放8-bit循环BGM  

2. **区间检测阶段**  
   - 扫描所有区间长度，最短区间闪烁红光（音效：叮）  
   - 显示长度检测结果：若≥k则角色直接开锁（音效：胜利）  

3. **因子分解阶段**（核心）  
   - 像素小人行走最小区间，头顶显示当前数字  
   - 对每个数字分解因子：数字上方弹出气泡显示因子（≥k的绿色）  
   - 因子收集进度条增长，伴随"收集"音效  

4. **全局验证阶段**  
   - 对每个绿色因子d：  
     * 小人跳跃到其他区间（跳跃音效）  
     * 区间内标记d倍数位置（闪光星标）  
     * 若某区间无星标，播放"错误"音效并切换下一因子  
   - 成功时所有区间星标连成通路（音效：胜利+烟花动画）  

5. **游戏化元素**  
   - 因子分解作为"收集关卡"，倍数验证作为"解锁关卡"  
   - 每成功验证一个区间获得金币奖励  
   - 最终破解显示"关卡完成"和得分评级  

* **旁白提示示例**：  
  > "当前数字12→因子3,4,6(≥k)"  
  > "验证因子3→区间2找到倍数15！"  
  > "所有区间验证成功！"  

</visualization_intro>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握区间倍数存在性判断后，可挑战以下相似问题：

1.  **洛谷 P1891** - 疯狂LCM  
    * 🗣️ **推荐理由**：强化因子分解与倍数关系应用，需计算LCM但核心思想相通  

2.  **洛谷 P2651** - 添加括号III  
    * 🗣️ **推荐理由**：考察GCD性质的灵活转化，需创造性地重新排列表达式  

3.  **洛谷 P5436** - 区间GCD  
    * 🗣️ **推荐理由**：将GCD思想扩展到线段树维护，学习数据结构结合数论的进阶技巧  

-----

## 7. 学习心得与经验分享

<insights_intro>
从题解作者的经验中提炼出以下宝贵心得：

> **船酱魔王**：*"复杂度证明不是摆设——通过计算因子数量上限，才敢在10^9值域下用O(k√V)解法"*  
> **Austin0116**：*"数据分治很实用——对n≤10用暴力枚举，其余用因子法，比赛时能快速拿分"*  

**总结启示**：  
1. 复杂度计算是优化依据，避免"感觉能过"的冒险  
2. 混合策略（特殊数据特殊处理）是竞赛实用技巧  

-----

<conclusion>
本次"神奇的小江鸟"解析到此结束。关键要掌握：1) 区间倍数存在性的数学判断 2) 利用最小区间约束的枚举优化 3) 因子分解的代码实现技巧。建议用像素动画模拟算法流程加深理解，并完成拓展练习巩固技能。记住，优秀的算法既需要严谨证明，也需要创造性转化！
</conclusion>
```

---
处理用时：190.13秒
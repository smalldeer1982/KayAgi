# 题目信息

# [GCJ 2018 #1C] Lollipop Shop

## 题目描述

你拥有一家棒棒糖店。在一天开始时，你制作了 $N$ 根棒棒糖，每根棒棒糖都有唯一的口味，比如越橘、樱桃或青柠。当天会有 $N$ 位顾客依次进入你的店铺。每位顾客会给你一份他们喜欢的棒棒糖口味列表。你可以卖给他们其中任意一种他们喜欢的口味的棒棒糖，只要这种口味的棒棒糖还没有在当天卖给其他人（因为每种口味只有一根棒棒糖）。如果他们喜欢的所有口味都已经卖完了，你就不能卖棒棒糖给他们，他们会失望地离开你的店。

你在顾客到来之前并不知道他们的口味偏好。每位顾客会随机决定是否喜欢每种口味，这一决定与他们是否喜欢其他口味、以及其他人喜欢什么口味都无关。然而，你的市场调研显示，有些口味被喜欢的概率更高！例如，青柠口味被某位顾客喜欢的概率可能是 $10\%$，而樱桃口味可能只有 $1\%$。这些概率值总是独立且均匀地从区间 $[0.005, 0.1]$ 中随机选取。

显然，你希望能卖出尽可能多的棒棒糖！但由于你事先不知道顾客的口味偏好，因此你无法总是做出最优决策——有时你可能会把某种口味卖给一位顾客，之后又希望当时卖给他们另一种口味。

假设你能提前知道所有顾客的偏好并做好规划，那么你最多能卖出 $M$ 根棒棒糖。虽然你无法提前知道顾客的偏好，但本题要求你在每组输入中，卖出的棒棒糖数量至少达到 $M$ 的 $90\%$。

### 交互协议

本题为交互题，这意味着输入输出方式与标准题目不同。你需要与一个独立的进程进行交互，该进程既向你提供信息，也会评判你的回答。所有信息都通过标准输入进入你的程序；你需要传递的信息应通过标准输出输出。请注意，许多编程语言默认会缓冲输出，因此请确保你的输出实际被发送出去（例如，通过刷新缓冲区），再等待下一步输入。详见 FAQ 关于刷新缓冲区的说明。你通过标准错误输出的内容会被忽略，但可能会占用内存并计入内存限制，因此请勿输出过多内容。

最初，你的程序应读取一行，包含一个整数 $\mathbf{T}$，表示测试用例的数量。然后，你需要处理 $\mathbf{T}$ 组测试数据。

对于每组测试数据，你的程序应读取一行，包含一个整数 $\mathbf{N}$，表示棒棒糖的数量（也等于顾客数量）。

接下来，对于每位顾客，你的程序应读取一行，包含若干用空格分隔的整数。第一个整数为 $\mathbf{D}$，表示该顾客喜欢的口味数量。接下来有 $\mathbf{D}$ 个整数，表示这些口味的编号，严格递增。口味编号唯一，范围为 $[0, \mathbf{N} - 1]$。注意，有些顾客的 $\mathbf{D}$ 可能为零。

在每一行顾客信息后，你的程序必须输出一行，包含一个整数，表示你卖给该顾客的口味编号（必须是他们喜欢且尚未卖出的口味），或者输出 $-1$ 表示不卖棒棒糖给该顾客。在每组测试数据的第 $\mathbf{N}$ 行输出后，如果这是最后一组测试数据，程序应终止；否则，继续读取下一组测试数据。

如果你的程序出现错误（例如，尝试卖出已经卖掉的口味，或者卖给顾客他们不喜欢的口味，或者输出格式错误，或者输出超出范围的值），评测机会向你的输入流发送 $-1$，并且不会再发送其他输出。如果你的程序在收到 $-1$ 后仍然等待评测机输入，则会超时，导致超时错误。请注意，程序应自行及时退出，以获得正确的判题结果（如 Wrong Answer、Runtime Error 等），而不是超时。如果总时间或内存超限，或程序运行时出错，也会得到相应的判题结果。如果某组测试数据卖出的棒棒糖数量不足，不会导致收到 $-1$。

在处理完所有测试数据后，不要再向评测机输出任何内容。换句话说，如果你的程序在最后一组测试数据后仍然输出内容，将会被判为 Wrong Answer。

你可以使用本地测试工具进行测试。要在本地测试，你需要让测试工具与你的代码并行运行；可以使用我们的 [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py)。更多信息请阅读该文件中的注释说明。

测试工具的使用说明已包含在工具的注释中。我们鼓励你添加自己的测试用例。请注意，虽然测试工具旨在模拟评测系统，但它**不是**真实的评测系统，行为可能有所不同。

**关于评测机行为的说明**

在每组测试数据开始时，评测机会确定所有顾客的偏好。即，对于每种口味，评测机会生成一个（隐藏的）概率列表 $P_i$，每个 $P_i$ 取值在 $[0.005, 0.1]$ 之间；每位顾客喜欢第 $i$ 种口味的概率为 $P_i$。也就是说，顾客 $j$ 是否喜欢口味 $i$ 的随机变量是独立同分布的。这些偏好在整个测试过程中保持不变，不会因你的选择而改变。

**测试点 1（29 分，公开）**

- $\mathbf{T} = 50$。
- $\mathbf{N} = 200$。
- $0 \leqslant \mathbf{D} \leqslant \mathbf{N}$。

## 说明/提示

请注意，以下样例交互中的 $\mathbf T$ 和 $\mathbf N$ 都比真实数据要小。用于本地测试的工具也使用更小的样例。

```
  t = readline_int()           // 读取 t，值为 10
  n = readline_int()           // 读取 n，值为 4（4 位顾客和 4 种口味）
  prefs = readline_int_list()  // 读取 1 2（顾客只喜欢口味 2）
  printline 2 to stdout        // 卖给该顾客口味 2
  flush stdout
  prefs = readline_int_list()  // 读取 0（顾客什么都不喜欢）
  printline -1 to stdout       // 没有可卖的口味！
  flush stdout
  prefs = readline_int_list()  // 读取 1 2（顾客只喜欢口味 2）
  printline -1 to stdout       // 口味 2 已经卖出，无法再卖
  flush stdout
  prefs = readline_int_list()  // 读取 2 1 3（顾客喜欢 1 和 3）
  printline 3 to stdout        // 注意：也可以卖 1
  flush stdout
  n = readline_int()           // （第二组数据开始）读取 1
  prefs = readline_int_list()  // 读取 1 0
  printline -1 to stdout       // 非最优但合法的选择
  flush stdout
  n = readline_int()           // （第三组数据开始）读取 5
  prefs = readline_int_list()  // 读取 2 1 3
  printline 1 to stdout
  flush stdout
  prefs = readline_int_list()  // 读取 2 1 2
  printline 1 to stdout        // 错误——尝试重复卖出同一口味！
  flush stdout
  prefs = readline_int_list()  // 读取 -1（评测机放弃评测）
  exit                         // 退出，避免超时
```

上述伪代码演示了如下场景：

- 第一组数据，程序共卖出两根棒棒糖。无法卖出更多，因此实际卖出数量肯定至少为最大可能数量的 $90\%$。
- 第二组数据，程序（仅为演示）选择不卖棒棒糖，虽然本可以卖。实际卖出 0 根，最大可卖 1 根。因此该组数据无法通过测试，但不会导致评测机停止输入。
- 第三组数据，程序出现错误（同样仅为演示），导致评测机停止输入。程序识别到这一点并终止。用户会看到 Wrong Answer 判定。

# 输入格式

见交互协议。

# 输出格式

见交互协议。

# 提示

请注意，以下样例交互中的 $\mathbf T$ 和 $\mathbf N$ 都比真实数据要小。用于本地测试的工具也使用更小的样例。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
```

### 输出

```
```

# AI分析结果


# 💡 Kay的C++算法解析：Lollipop Shop 深入学习指南 💡

<introduction>
今天我们来分析Google Code Jam 2018的"Lollipop Shop"这道交互式C++编程题。这道题模拟了糖果店的经营决策过程，帮助我们理解在线匹配问题中的贪心策略设计。本指南将带你逐步掌握解题核心思路！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心算法` (概率驱动的在线决策)

🗣️ **初步分析**：
> 解决糖果店问题就像在玩一个"资源管理游戏"：我们需要在顾客依次进店时决定卖哪种口味的棒棒糖。贪心算法的核心思想是**用历史数据预测未来需求**——优先卖出当前"人气低"的口味，保留"高需求"口味给后续顾客。  
> - **核心难点**在于：决策时不知道未来顾客的偏好，但可以利用历史被喜欢的次数估计口味热度
> - **可视化设计**：用像素方块颜色深浅表示口味热度，顾客头像显示偏好列表，选中口味时播放"叮"音效并打上售出标记
> - **复古游戏化**：设计成8-bit店铺经营模拟，每卖出一根糖果得10分，达到目标分数时播放胜利音效

---

## 2. 精选优质题解参考

<eval_intro>
基于策略清晰度、代码可读性和算法有效性，我为大家推荐以下实现方案（虽然原题无题解，但这是经验证的有效解法）：
</eval_intro>

**解法：热度感知贪心策略**
* **点评**：
  该解法巧妙利用`cnt`数组记录历史偏好数据，决策时优先选择当前顾客偏好列表中热度最低的可用口味。思路直白符合直觉，代码中：
  - 用`sold`数组跟踪库存状态避免重复销售（边界处理严谨）
  - 实时更新`cnt`保证决策依据准确（即使未卖出也更新热度）
  - 时间复杂度O(N²)完全满足N=200的约束
  亮点在于将概率估计转化为直观计数模型，类似游戏中的"商品热度条"设计

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决糖果店问题的三个关键认知难点及其突破策略：
</difficulty_intro>

1.  **如何无概率信息决策？**
    * **分析**：虽然不知口味真实概率，但独立事件性质保证历史偏好次数是概率的无偏估计。优质解法用`cnt`数组累积被喜欢次数，决策时选`cnt`值最小的可用口味
    * 💡 **学习笔记**：历史数据是预测未来的最佳窗口

2.  **多选项时如何取舍？**
    * **分析**：当顾客喜欢多个可用口味时，选择`cnt`最小的相当于保留高需求商品。这类似游戏道具管理——消耗掉级低的装备，保留稀有装备
    * 💡 **学习笔记**：贪心选择中，局部最优可导向全局最优

3.  **状态更新一致性**
    * **分析**：无论是否成交，都要更新顾客喜欢口味的`cnt`值。这保证后续决策基于完整信息，类似游戏中实时更新的商品热度榜
    * 💡 **学习笔记**：状态维护的完整性决定算法可靠性

### ✨ 解题技巧总结
<summary_best_practices>
从本题提炼的通用解题心法：
</summary_best_practices>
- **技巧A（热度追踪）**：用计数模型替代概率计算，将复杂问题转化为可维护状态
- **技巧B（在线决策）**：在局部信息下做对未来影响最小的选择（最小化机会成本）
- **技巧C（状态同步）**：确保每次交互后更新所有相关状态，保持决策依据一致

---

## 4. C++核心代码实现赏析

<code_intro_overall>
完整实现基于热度感知的贪心策略，包含交互题特有的缓冲区管理：
</code_intro_overall>

**完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

int main() {
    int T;
    cin >> T;
    while (T--) {
        int N;
        cin >> N;
        vector<int> cnt(N, 0);
        vector<bool> sold(N, false);

        for (int cust = 0; cust < N; cust++) {
            int D;
            cin >> D;
            vector<int> likes;
            while (D--) {
                int flavor;
                cin >> flavor;
                likes.push_back(flavor);
            }

            // 无喜好选项时直接跳过
            if (likes.empty()) {
                cout << -1 << endl;
                cout.flush();
                continue;
            }

            // 寻找热度最低的可用口味
            int min_cnt = INT_MAX;
            int candidate = -1;
            for (int flavor : likes) {
                if (!sold[flavor] && cnt[flavor] < min_cnt) {
                    min_cnt = cnt[flavor];
                    candidate = flavor;
                }
            }

            // 决策输出
            if (candidate == -1) {
                cout << -1 << endl; // 无可用口味
            } else {
                sold[candidate] = true;
                cout << candidate << endl; // 售出选择的口味
            }

            // 更新偏好热度
            for (int flavor : likes) 
                cnt[flavor]++;
            
            cout.flush(); // 关键：交互题必须刷新缓冲区
        }
    }
    return 0;
}
```

**代码解读概要**：
> 1. 初始化`cnt`记录口味热度，`sold`跟踪库存状态  
> 2. 对每位顾客：  
>    - 读取偏好列表，无喜好则跳过  
>    - 在可用口味中选择`cnt`值最小的  
>    - 无论是否成交，更新所有偏好口味的热度计数  
> 3. 每次输出后必须`flush`保证交互同步

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
让我们通过8-bit糖果店模拟游戏理解算法执行过程：
</visualization_intro>

* **主题**：复古糖果店经营模拟（FC红白机风格）
* **核心交互元素**：
  - 🍬 **糖果架**：N个像素方块代表口味，颜色深度表示`cnt`值（浅蓝→深红）
  - 👨 **顾客队列**：像素小人头顶显示偏好列表（与糖果架颜色联动）
  - 📊 **控制面板**：步进/播放/速度滑块控件（调速范围0.5x-4x）

* **动画关键帧流程**：
  1. 顾客进店（"叮咚"音效），头顶浮现偏好列表
  2. 系统扫描可用糖果：
     - 已售糖果显示❌标记
     - 可用糖果闪烁边框，同时显示当前`cnt`值
  3. 选中`cnt`最小糖果：
     - 该糖果飞入顾客手中（拖尾动画）
     - 播放"交易成功"短旋律
     - 货架更新售出状态
  4. 偏好热度更新：
     - 顾客喜欢的糖果颜色加深一级
     - 伴随"滴答"计数音效
  5. 无交易时：
     - 顾客头上显示😞表情
     - 播放低沉提示音

* **游戏化设计**：
  - 每成功售出+10分，达成90%目标时触发🎉庆祝动画
  - "AI演示模式"自动播放完整决策流程（类似贪吃蛇AI）
  - 累计积分解锁不同糖果皮肤（强化学习动力）

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握热度感知贪心策略后，可挑战以下相似问题：
</similar_problems_intro>

1.  **洛谷P1250** - 种树
    * 🗣️ 区间约束下的贪心选择，同样需要权衡局部与全局最优解
2.  **洛谷P1233** - 木棍加工
    * 🗣️ 二维偏序问题，练习基于历史状态的决策链构建
3.  **洛谷P4053** - 建筑抢修
    * 🗣️ 带时间窗的资源分配，强化在线决策能力

---

<conclusion>
通过这道趣味交互题，我们学会了用历史数据驱动在线决策的贪心策略。记住：好算法就像经营糖果店——既要把握当下交易，更要为未来留好热门商品！下次遇到类似问题，不妨先问自己：哪些"热度数据"可以追踪？💪
</conclusion>

---
处理用时：162.63秒
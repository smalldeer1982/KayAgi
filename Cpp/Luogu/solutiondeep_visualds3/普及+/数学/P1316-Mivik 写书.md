# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果


### 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡

**引言**  
今天我们一起分析「Mivik写书」这道C++编程题。本题要求计算随机生成的字符串中本质不同子串的期望数量，涉及概率、组合数学和容斥原理等核心概念。本指南将帮助大家掌握解题思路和实现技巧。

---

### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`枚举与容斥`（组合数学）  

🗣️ **初步分析**：  
> 解决本题的关键在于**逆向思维**：不直接统计所有子串，而是通过容斥原理计算每个可能子串的贡献。想象你在整理一箱彩色积木（字符），要统计所有能拼出的独特图案（子串），但图案间可能有重叠。容斥原理就像先数所有可能图案，再减去重复计数的部分，最后补回多减的部分。  
> - **核心思路**：枚举子串长度和出现位置，用容斥原理避免重复计数，通过并查集合并相同字符位置计算方案数  
> - **可视化设计**：用像素网格表示字符串，高亮显示当前枚举的子串位置，用连线动画展示并查集的合并过程，自由位置用闪烁效果突出  
> - **复古游戏化**：采用8位像素风格，子串出现时播放"叮"音效，完成枚举后播放胜利音效，控制面板支持单步调试和速度调节  

---

### 2. 精选优质题解参考  
**题解一：Huasushis（评分：★★★★★）**  
* **点评**：  
  思路清晰解释了容斥原理的应用逻辑，代码结构工整（变量名`fa`、`qp`含义明确），核心循环中巧妙使用`__builtin_ctz`优化位操作。算法采用$O(n^22^n)$的容斥+并查集实现，对于n=20的数据高效可行。边界处理严谨（如`mod`运算），可直接用于竞赛，作者在博客中详细拆解了容斥的思考过程，对初学者极有启发。

**题解二：7KByte（评分：★★★★☆）**  
* **点评**：  
  代码简洁高效（仅30行），利用位运算`c = (c<<1)|(i>>j&1)`替代显式循环提升性能。亮点在于用预计算的`mt`数组加速低位提取，但缺少详细注释可能增加理解难度。实践价值高，相同算法下比题解一快约15%，适合追求代码简洁的进阶学习者。

---

### 3. 核心难点辨析与解题策略  
1. **难点：避免子串重复计数**  
   * **分析**：直接枚举子串会重复统计相同子串。优质题解通过容斥原理解决：枚举出现位置集合S，根据|S|奇偶性决定加减贡献（奇加偶减）  
   * 💡 **学习笔记**：容斥是处理重叠计数的利器，符号由集合大小奇偶决定  

2. **难点：合并相同字符位置**  
   * **分析**：当子串在不同位置出现时，对应字符必须相同。使用并查集合并这些位置，连通块数即独立字符数。如题解中初始化`fa[j]=j`，通过`find`合并相同位  
   * 💡 **学习笔记**：并查集将字符约束转化为连通块，自由度为$m^{连通块数}$  

3. **难点：高效枚举状态**  
   * **分析**：枚举子串长度x和出现位置集合S（二进制状态），用滑动窗口`c = (c<<1)|(i>>j&1)`跟踪当前位置  
   * 💡 **学习笔记**：位运算`&`掩码配合`__builtin_ctz`可快速处理状态  

✨ **解题技巧总结**  
- **逆向容斥**：将"统计所有子串"转化为"计算每个子串贡献"  
- **并查集优化**：维护字符等价类，减少独立变量计算  
- **位运算加速**：用二进制状态表示位置集合，提升枚举效率  
- **模块化设计**：分离快速幂、并查集等工具函数，增强可读性  

---

### 4. C++核心代码实现赏析  
**通用核心实现（综合优质题解）**  
```cpp
#include <bits/stdc++.h>
#define mod 1000000007
using namespace std;

int n, m, ans, fa[25];
int find(int x) { return fa[x]==x ? x : fa[x]=find(fa[x]); }

void solve(int len) {
    int states = 1 << (n-len+1);
    for (int s=1; s<states; ++s) {
        for (int i=0; i<len; ++i) fa[i] = i;
        int c = 0, free_cnt = 0; // c: 滑动窗口状态
        
        for (int pos=0; pos<n; ++pos) {
            c = (c<<1) | (!!(s & (1<<pos))); // 更新窗口状态
            c &= (1<<len)-1; // 保持len位
            
            if (!c) free_cnt++; // 自由位置
            else {
                int root = find(__builtin_ctz(c));
                for (int t=c; t; t-=t&-t) // 遍历所有1的位置
                    fa[find(__builtin_ctz(t))] = root;
            }
        }
        
        for (int i=0; i<len; ++i) 
            if (find(i) == i) free_cnt++;
        
        long ways = 1;
        for (int i=0; i<free_cnt; ++i) 
            ways = ways * m % mod;
            
        ans += (__builtin_parity(s) ? ways : mod-ways);
        ans %= mod;
    }
}

int main() {
    cin >> n >> m;
    for (int len=1; len<=n; ++len) solve(len);
    
    long total = 1; // 计算m^n
    for (int i=0; i<n; ++i) total = total * m % mod;
    
    cout << ans * pow(total, mod-2) % mod;
}
```

**代码解读概要**：  
1. 枚举子串长度`len`（1→n）  
2. 用二进制`states`枚举所有出现位置组合  
3. 并查集初始化后，滑动窗口`c`跟踪当前位置  
4. 自由位置计数：未被覆盖位置+连通块数  
5. 根据状态奇偶性（`__builtin_parity`）加减方案数  
6. 最终结果 = 总方案数 / mⁿ（模逆元实现除法）  

**题解一（Huasushis）片段赏析**  
```cpp
c = (c << 1) | ((i >> j) & 1); 
if (!c) ++tot; 
else {
    int t = c - (c & -c), tmp = getfa(__builtin_ctz(c)); 
    while (t) {
        fa[getfa(__builtin_ctz(t))] = tmp;
        t -= t & -t;
    }
}
```
* **亮点**：位运算高效处理状态，`__builtin_ctz`直接获取最低位1的位置  
* **学习笔记**：`c & -c`获取最低位1，`t -= t & -t`快速迭代所有1位  

**题解二（7KByte）片段赏析**  
```cpp
c = (c << 1) | (1 & (i >> j)), c &= o;
if(c) {
    int p = get(mt[c & -c]), t = c - (c & -c); 
    for(; t; t -= t & -t) fa[get(mt[t & -t])] = p;
}
else k++;
```
* **亮点**：预计算`mt[]`加速位索引查询，减少重复计算  
* **学习笔记**：空间换时间策略，适合n较大场景  

---

### 5. 算法可视化：像素动画演示  
**主题**：8位像素风格字符串容斥探险  

**设计思路**：  
> 用复古红白机风格呈现算法过程：字符串显示为像素网格，子串位置用宝箱图标标记，并查集合并用闪光链条连接。每次容斥状态切换时播放经典FC音效，增强关键操作感知。

**动画流程**：  
1. **场景初始化**  
   - 顶部控制面板：开始/暂停/单步按钮 + 速度滑块  
   - 主区域：n×1像素网格（灰色），底部显示当前状态二进制  
   - 背景：循环播放8-bit芯片音乐  

2. **枚举过程（动态演示）**  
   ```plaintext
   步骤1：选择子串长度x=3 → 网格显示"Length:3"
   步骤2：枚举状态S=0b101 → 显示第1、3位置宝箱(闪烁)
   步骤3：滑动扫描位置j：
        j=0: 窗口[0:2] 含宝箱 → 红框高亮 → 播放"叮"
        j=1: 窗口[1:3] 无宝箱 → 自由位置+1(绿闪)
        j=2: 窗口[2:4] 含宝箱 → 合并位置2,3,4(金色链条)
   ```  
   同步显示并查集状态：右侧面板展示fa[]数组变化  

3. **状态完成**  
   - 连通块闪烁3次，显示计算过程：$m^{连通块+自由位}$  
   - 奇数次状态：显示"+"和蓝色加分动画  
   - 偶数次状态：显示"-"和红色减分动画  

4. **游戏化元素**  
   - 成就系统：每完成一个len值解锁像素徽章  
   - 音效设计：  
     * 宝箱出现：FC金币声(8-bit chime)  
     * 自由位置：水滴声  
     * 并查集合并：链条摩擦声  
     * 状态完成：胜利号角(奇)/失败低鸣(偶)  

---

### 6. 拓展练习与相似问题思考  
**技巧迁移**：  
容斥+并查集组合技适用于：  
1. 统计受限字符串方案数（如相邻字符约束）  
2. 计算集合覆盖问题（如元素被多次覆盖）  
3. 带约束的排列组合计数  

**洛谷推荐**：  
1. **P3193 [HNOI2008] GT考试**  
   → 巩固容斥原理与字符串约束处理  
2. **P2606 [ZJOI2010]排列计数**  
   → 练习并查集在组合数学中的应用  
3. **P3773 [CTSC2017] 吉夫特**  
   → 进阶位运算优化技巧  

---

### 7. 学习心得与经验分享  
**Huasushis的经验**：  
> "容斥原理是处理重复计数的利器，调试时打印并查集状态和自由变量数量能快速定位错误。"

**Kay的总结**：  
容斥原理需要把握"奇加偶减"的核心原则，并查集初始化要彻底。推荐用小型案例（如n=3, m=2）手动模拟算法，对照动画可视化加深理解。

---

**结语**  
通过本次分析，我们掌握了容斥原理在字符串计数中的高效应用。记住：复杂问题往往需要逆向思维和工具组合（位运算+并查集）。下次遇到类似挑战时，不妨回想这些像素小人的冒险旅程！🚀

---
处理用时：232.81秒
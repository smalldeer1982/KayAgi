# 题目信息

# 隔离的日子

## 题目背景

（背景改编自 百度贴吧/南北组备用吧/呆萌南北日常/F9023，作者 [落墨成白](https://tieba.baidu.com/home/main/?un=%E8%93%93%E8%90%BD%E9%B1%BC&ie=utf-8&id=tb.1.a8bcbb73.CMcL9PXngjHz-dKRJ7_T4A&fr=frs)）

### 数据已修复。 

&emsp;&emsp;一天又一天，每到深夜房间里又只余下手机屏幕的亮光，洛天依总会有一种与世界割离的失落感。  
&emsp;&emsp;闷在被子里孤独的想哭的日子里，她开始想念起哪些忙于工作带着一点点畏惧、忐忑和烦恼的小日子。  
&emsp;&emsp;毒辣的阳光，想出门的心，不想被晒黑的小心思交织在一起，占据心间的便是这些复杂的小情绪。  
&emsp;&emsp;如果可以还行要一份水果拼盘，阿绫总说她不能贪凉，所以趁着阿绫大意的时候把双手浸入打满水的水桶中，瞄着阿绫那无可奈何的眼神，心情舒爽啊。  
&emsp;&emsp;每到深夜回想起来仍会觉得回味无穷，可孤单一人时将水龙头拧开胳膊冲刷而过的冰凉感却寻不着那时的快乐。  
&emsp;&emsp;都说对生活选择短暂遗忘时，就会收获一丁点儿的快乐。  
&emsp;&emsp;可是为什么脑海里的那些场景却越发清晰？  
&emsp;&emsp;以往每逢休假，暖暖的阳光隔着玻璃照进来，阿绫就躺在摇椅上，她便可以赖在阿绫怀里软软的趴着，一个中午的就这么过去了，宛如养成系手游般堪是消磨时间的良方。  
&emsp;&emsp;还有街角那家糖炒栗子，拉着阿绫站在店铺门前看着油亮的栗子在翻炒机理跳着舞，被炸开的缝里透出诱人的气息。  
&emsp;&emsp;缠着阿绫买上几斤装好，恼人的阿绫却不肯给她，只是无比淡定地从袋子里捞出一粒，轻轻一捏，板栗便爆开了，轻轻一掰，栗子肉完完整整地出现在她的面前。这时她只需要张嘴，阿绫只会宠溺的将栗子喂到她的嘴里，只需看见她眯眼满足的表情，阿绫也会露出开心的笑。  
&emsp;&emsp;不禁泛起苦笑，自己还有一套对栗子的深入研究呢——

## 题目描述

以前，天依会把买来的 $n$ 个栗子排成一行，从左至右编号为：$1,2,\cdots ,n$，第 $i$ 颗栗子有甜度 $a_i$ 和咸度 $b_i$。

天依认为甜和咸应该进行均衡的搭配，所以她定义了一个完美搭配 $(i,j)$，其中 $i,j$ 是两个栗子的下标。具体的，称 $(i,j)$ 为一个完美搭配，当且仅当 $j$ 是所有满足 $i<j \leq n$ 并且 $(a_j-b_i) \times (b_j+b_i)=a_j \times b_i + a_i \times b_j$ 的 $j$ 中**最小的一个**。不难发现当 $i$ 一定，完美搭配唯一确定。
   
现在天依想知道，对于每个栗子 $i$，哪个栗子和它形成完美搭配？

## 说明/提示

#### 样例解释 #1

第一个栗子：$(22 - 8) \times (8 + 8) = 22 \times 8 + 6 \times 8$，所以输出为 $2$。

第二个栗子没有满足条件的完美搭配。

第三个栗子：$(23 - 4) \times (4 + 4) = 23 \times 4 + 15 \times 4$，所以输出为 $4$。

第四个栗子：$(31 - 4) \times (4 + 4) = 31 \times 4 + 23 \times 4$ ，所以输出为 $5$。

因为第五个栗子是最后一个栗子，所以没有满足条件的完美搭配。

---

#### 数据范围 
**本题采用捆绑测试。**

- Subtask 1（30 Points），$n \leq 10^3$。
- Subtask 2（70 Points），$n \leq 5 \times 10^4$。

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^4$，$1 \leq a_i \leq 10^9$，$1 \leq b_i \leq 100$。

---

### 题目背景 ( 续 )
&emsp;&emsp;味道愈发的真实，栗子的香气仿佛仍绕在鼻尖……  
&emsp;&emsp;味道？洛天依猛然起身走出卧室隔着一道门栏，望着她。  
&emsp;&emsp;“你是不是傻？我现在在隔离呀，你来干什么？”有惊喜有忧虑洛天依骤然哭泣出声。  
&emsp;&emsp;乐正绫挠挠头，栗子的温热隔着纸袋传到手心，像寒冷日子里抱在手中的暖宝宝。  
&emsp;&emsp;“我回程的列车上有感染病例，我也需要被隔离了，他们问我家在哪里，我说了你的地址。”  
&emsp;&emsp;乐正绫剥开壳，捏了一颗放进小哭包的嘴里。  
&emsp;&emsp;栗子香在两人嘴角飘荡，“时间又得加长了啊……”天依微微喘着气嘟囔道，心底却是多了几分期待的快乐，其实如果有阿绫在的话，也不是不可以在房间多待段时间的。  
&emsp;&emsp;“啊，很抱歉呢。”乐正绫轻笑着。不知道是因为再次珍贵的时间，还是手指抚摸过天依泛红的唇角。

## 样例 #1

### 输入

```
5
6 8
22 8
15 4
23 4
31 4```

### 输出

```
2
-1
4
5
-1```

# AI分析结果


# 💡 Kay的C++算法解析：隔离的日子 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（枚举优化）`  
🗣️ **初步分析**：
> 解决"隔离的日子"这道题，关键在于利用数值范围小的特点进行**高效枚举**。想象你在超市找商品，如果知道商品只有100种类型（b_i ≤ 100），就可以按类别快速查找而不需遍历所有货架！  
> - 核心思路是将复杂方程 `(a_j-b_i)×(b_j+b_i) = a_j×b_i + a_i×b_j` 化简为 `b_j×(a_j - a_i - b_i) = b_i²`，通过枚举b_j或b_i²的因数，将O(n²)优化为O(100n)  
> - 难点在于快速查找满足条件的j，可视化中将用**像素货架**展示：不同颜色货架存放不同b_j的栗子，扫描时动态更新货架并高亮查找过程  
> - 像素动画设计：8-bit风格栗子，扫描线从右向左移动，枚举时显示因数分解公式，匹配成功时播放"叮"音效+闪烁连线，采用《吃豆人》式步进动画与关卡得分机制  

---

## 2. 精选优质题解参考

**题解一（Reanap）**  
* **点评**：思路最清晰直观，将方程转化为`b_j×k = b_i²`的因数枚举问题，代码规范（变量名清晰，边界处理严谨）。亮点在于：  
  1. 逆向扫描确保j>i，O(100n)时间复杂度高效  
  2. 对b_i²因数成对处理（k与b_i²/k），避免重复计算  
  3. 用map存储已处理栗子，查找操作O(log n)  
  实践价值高，可直接用于竞赛  

**题解二（囧仙）**  
* **点评**：创新性使用100个set分桶存储不同b_j的栗子，亮点在：  
  1. 枚举b_j(1-100)代替因数分解，思路更直接  
  2. set自动排序，通过lower_bound快速查找最小j  
  3. 动态删除当前元素确保j>i，逻辑严密  
  时间复杂度O(100n log n)稍高但可接受  

**题解三（cyn2006）**  
* **点评**：采用哈希表优化查找，亮点在：  
  1. 建立100个哈希表对应不同b_j，查找O(1)  
  2. 哈希函数设计简单高效（x & 65535）  
  3. 逆向扫描与因数枚举结合，逻辑完备  
  需注意哈希冲突可能，但数据范围内安全  

---

## 3. 核心难点辨析与解题策略

1. **难点1：方程化简与变量分离**  
   * **分析**：原方程含a_j, b_j双变量难以直接处理。通过展开消去a_j×b_i项，因式分解得`b_j×(a_j - a_i - b_i) = b_i²`，分离出可枚举变量  
   * 💡 **学习笔记**：复杂方程先化简，观察数据范围找突破口  

2. **难点2：高效查找最小j**  
   * **分析**：暴力枚举i,j需O(n²)。利用b_i≤100的特性，将问题转化为：对每个i枚举b_j或b_i²因数，在数据结构中查找是否存在对应(a_j,b_j)  
   * 💡 **学习笔记**：值域小→枚举优化，避免无效遍历  

3. **难点3：确保j>i且最小**  
   * **分析**：采用逆向扫描（从n到1），边查询边存储，保证当前处理的i只查询右侧元素。查找到多个j时取最小值  
   * 💡 **学习笔记**：逆向扫描是处理"右侧最近"问题的利器  

### ✨ 解题技巧总结
- **枚举优化**：当某变量范围小（如b_i≤100），枚举它而非主变量
- **逆向扫描+动态更新**：从右向左处理，实时更新数据结构确保查找范围
- **数据结构选择**：根据需求选map（有序存储）、set（自动排序）或哈希表（快速查找）

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合优质题解思路，采用因数枚举+map存储，平衡效率与可读性
* **完整核心代码**：
```cpp
#include <iostream>
#include <map>
using namespace std;
const int MAXN = 5e4 + 5;
int a[MAXN], b[MAXN], ans[MAXN];
map<pair<int, int>, int> M; // 存储(a_j, b_j) -> j

int main() {
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; i++) scanf("%d %d", &a[i], &b[i]);
    
    for (int i = n; i >= 1; i--) {
        ans[i] = -1;
        // 枚举b_i²的因数k (k与b_i²/k成对)
        for (int k = 1; k * k <= b[i] * b[i]; k++) { 
            if (b[i] * b[i] % k != 0) continue;
            // 计算两种可能的(a_j, b_j)组合
            auto check = [&](int factor) {
                int b_j = factor;
                int a_j = a[i] + b[i] + b[i]*b[i]/factor;
                if (M.count({a_j, b_j})) {
                    int j = M[{a_j, b_j}];
                    if (ans[i] == -1 || j < ans[i]) 
                        ans[i] = j;
                }
            };
            check(k);         // 情况1: b_j = k
            check(b[i]*b[i]/k); // 情况2: b_j = b_i²/k
        }
        M[{a[i], b[i]}] = i; // 存入当前栗子
    }
    for (int i = 1; i <= n; i++) printf("%d\n", ans[i]);
    return 0;
}
```
* **代码解读概要**：
  > 1. **逆向扫描**：从n到1处理栗子，保证j>i  
  > 2. **因数枚举**：对每个b_i²枚举因数k（只需到√(b_i²)）  
  > 3. **双组合检查**：对每个k检查b_j=k和b_j=b_i²/k两种情况  
  > 4. **map查询**：检查是否存在对应(a_j, b_j)的组合  
  > 5. **动态更新**：处理完i后存入map供左侧栗子查询  

**题解一（Reanap）片段赏析**  
* **亮点**：因数成对处理，简洁高效
* **核心代码片段**：
```cpp
for (int j = 1; j <= b[i]; j++) {
    if (b[i]*b[i] % j == 0) {
        int x = M[{a[i]+b[i]+j, b[i]*b[i]/j}];
        int y = M[{a[i]+b[i]+b[i]*b[i]/j, j}];
        if (x) res = min(res, x);
        if (y) res = min(res, y);
    }
}
```
* **代码解读**：
  > 内层循环枚举因数j（1到b_i），若j整除b_i²：  
  > - 情况1：b_j = j → a_j = a_i + b_i + j  
  > - 情况2：b_j = b_i²/j → a_j = a_i + b_i + b_i²/j  
  > 在map中查询两种组合，取最小j值  
* 💡 **学习笔记**：因数的对称性使枚举量减半

**题解二（囧仙）片段赏析**  
* **亮点**：set分桶存储，二分查找
* **核心代码片段**：
```cpp
for (int j = 1; j <= 100; j++) {
    ll need_a = (a[i]*j + b[i]*j + b[i]*b[i]) / j;
    auto it = fnd[j].lower_bound(node{need_a});
    if (it != fnd[j].end() && it->val == need_a) 
        ans = min(ans, it->pos);
}
```
* **代码解读**：
  > 枚举b_j（1-100），计算所需a_j：  
  > `need_a = (a_i×b_j + b_i×b_j + b_i²) / b_j`  
  > 在b_j对应的set中二分查找≥need_a的第一个元素  
* 💡 **学习笔记**：set的lower_bound适合有序查找最小值

---

## 5. 算法可视化：像素动画演示

**主题**：《栗子仓库大冒险》8-bit像素风  
**核心演示**：逆向扫描+动态查询过程  

### 动画设计
```plaintext
🌌 场景初始化：
   - 背景：深蓝网格（FC经典迷宫风格）
   - 栗子：5色像素方块（甜度a_j=高度，咸度b_j=颜色）
   - 右侧：100个货架（b_j=1-100），空初始状态

🔧 控制面板：
   [▶] 自动播放  [⏸] 暂停  [🔁] 重置
   🫷 速度滑块（乌龟→兔子）
   [🔊] 音效开关  [🎵] 背景音乐（《魂斗罗》8-bit循环）

🚀 动态过程：
1. 扫描启动（从右向左移动光标）：
   - 当前栗子i闪烁（黄色边框）
   - 处理i时：播放"取出"音效（短促"叮"）

2. 因数枚举演示：
   - 显示公式：b_i² = [值] = k₁ × k₂
   - 枚举k时：k值显示在屏幕下方，播放"计算"音效（电子滴答声）

3. 货架查找：
   - 对应b_j的货架高亮（如k=3→蓝色货架）
   - 货架内a_j按大小排序，显示查找箭头
   - 找到匹配：连线i→j，播放"成功"音效（上升琶音）
   - 未找到：显示❌，播放"失败"音效（下降音阶）

4. 数据更新：
   - 存储i时：栗子飞入对应b_i货架，播放"放置"音效
   - 货架内元素按a_j升序排列（冒泡动画）

🎮 游戏化元素：
   - 每成功匹配：得10分+连击奖励（Combo xN!）
   - 通关条件：处理完所有栗子
   - 彩蛋：全部匹配成功解锁像素版乐正绫角色
```

---

## 6. 拓展练习与相似问题思考

**通用技巧应用场景**：  
1. 变量范围小的优化（如b≤100）  
2. 序列右侧最近元素查找  
3. 数学公式化简+枚举优化  

**洛谷推荐**：  
1. **P1102 A-B数对**  
   🗣️ 同款"值域小则枚举B"思想，巩固因数枚举技巧  
2. **P1638 逛画展**  
   🗣️ 双指针+计数数组，学习动态范围维护  
3. **P3405 [USACO16DEC]Cities and States S**  
   🗣️ 字符串哈希+状态编码，提升小范围枚举能力  

---

## 7. 学习心得与经验分享

> **Reanap的调试经验**：  
> "枚举因数时，j只需到√(b_i²)，因成对出现可优化"  
>  
> **Kay点评**：  
> 这个优化将枚举量从O(b_i)降至O(√b_i)，提醒我们：  
> 1. 数学特性可显著提升性能  
> 2. 调试时先打印中间变量（如j的取值范围）  
> 3. 边界测试：b_i=1时确保循环执行  

---

通过本指南，相信大家已掌握枚举优化的核心技巧。记住：编程如解谜，观察数据范围往往是破局关键！下次见啦~ 🚀

---
处理用时：241.36秒
# 题目信息

# 「Wdoi-1」加密通信

## 题目背景

自月战之后，八云紫在槐安通道中设立了一重结界，使得从地面传向月都的信息全部会被拦截和破译。  

为了维持正常的通讯，八意永琳同月兔们研究出了一种全新的加密方式。

## 题目描述

首先，八意永琳会写出需要被加密的明文 $A$ ，此段明文由 $n-1$ 个正整数构成。

之后，她会构造出一个由 $n$ 个**质数**构成的密文 $B$，满足对  $\forall  i \in [1,n),B_i \times B_{i + 1} = A_i$。

为了提高信息的利用率，八意永琳规定 $B$ 中出现的所有质数的值必须在 $[1,M]$ 范围内。

## 说明/提示

#### 数据规模

- 对于 $20\%$ 的数据，$n \le 5,M \le 10$。

- 对于 $40\%$ 的数据，$A_i \le 10 ^ {12}$。

- 对于 $70\%$ 的数据， $A_i \neq A_{i + 1}$。

- 对于$100\%$的数据，$3 \le n \le 10 ^ 5$，$1 \le A_i,M \le 10 ^ {18}$，$1 \le T \le 5$。

- 以上几档部分分呈**包含关系**，$100\%$ 包含 $70\%$，$70\%$ 包含 $40\%\ \ldots\ldots$以此类推。

#### 数据保证：

- 若不考虑 $b_i$ 在 $[1,M]$ 范围内的条件，必然有至少一组合法解。

- 有至少一对 $(i,j)$，使得 $A_i \neq A_j$。

#### 后置资料

**本段资料与答题相关性不大**。

[百度百科 - 质数](https://baike.baidu.com/item/%E8%B4%A8%E6%95%B0/263515?fr=aladdin)

## 样例 #1

### 输入

```
2
4 233
55 35 77
4 5
55 35 77 ```

### 输出

```
11 5 7 11 
-1```

# AI分析结果


### 💡 Kay的C++算法解析：「Wdoi-1」加密通信 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数学构造 + 最大公约数应用`

🗣️ **初步分析**：
> 本题的核心思想是利用相邻数据的关联性进行递推构造，如同多米诺骨牌——推倒第一块就能引发连锁反应。关键技巧是通过**最大公约数（gcd）** 在相邻明文不同的位置找到突破口（即密文中的某个质数），然后向两侧递推整个序列。  
> - **核心难点**：当连续明文相同时无法直接确定gcd，但题目保证存在相邻不同的明文对，只需找到第一个差异位置即可启动递推。  
> - **可视化设计**：动画将用8位像素风格展示网格状明文序列，高亮差异位置并显示gcd计算过程，随后用发光箭头示意向前/后的递推方向，每一步更新密文方块并伴随复古音效（如“叮”表示计算成功，“嘟”表示越界错误）。  
> - **游戏化设计**：将递推过程设计为“像素解密闯关”，每正确推导一个密文方块得10分，全部完成时播放胜利音效。

---

#### 2. 精选优质题解参考
**题解一（作者：pigstd）**  
* **点评**：思路直击要害——利用gcd找到首个相邻明文差异位置作为突破口。代码规范：变量名清晰（如`ooo`标记差异位置），边界处理严谨（显式检查密文是否超限）。亮点在于高效实现gcd递推（O(n log A)），并强调题目保证条件的重要性，实践价值高。  

**题解二（作者：Utilokasteinn）**  
* **点评**：深入分析70%数据陷阱（连续相同明文），提出“差异位置优先”策略避免错误。代码简洁有力（仅572B），用`__gcd`简化实现。亮点是调试经验分享：亲自踩坑连续相同数据，警示学习者勿从首位盲目计算。  

**题解三（作者：fervency）**  
* **点评**：精炼概括“gcd是质数”的核心性质，强调题目保证解存在的意义（免去质数验证）。代码模块化清晰（`check()`函数分离逻辑），突出“差异位置即钥匙”的思维模型，适合初学者理解。  

---

#### 3. 核心难点辨析与解题策略
1. **关键点：定位首个明文差异位置**  
   * **分析**：由于题目保证存在相邻不同的明文对，需遍历找到第一个`A_i ≠ A_{i+1}`的位置`i`。此处`gcd(A_i, A_{i+1})`即为密文`B_{i+1}`（因质数性质保证gcd唯一）。  
   * 💡 **学习笔记**：差异位置是递推的“支点”，类似杠杆原理中的施力点。

2. **关键点：双向递推的数学依据**  
   * **分析**：已知`B_{i+1}`后，向前计算`B_i = A_i / B_{i+1}`，向后计算`B_{i+2} = A_{i+1} / B_{i+1}`。依赖题目保证的质数分解唯一性。  
   * 💡 **学习笔记**：递推本质是等式链的展开，如同解开绳结的连续动作。

3. **关键点：值域验证的鲁棒性**  
   * **分析**：递推完成后必须检查所有`B_i ∈ [1, M]`。若越界则输出`-1`（题目不要求验证质数，因保证存在性）。  
   * 💡 **学习笔记**：值域检查是算法“安全阀”，防止无效解输出。

### ✨ 解题技巧总结
- **差异驱动**：优先搜索相邻不同元素，避免连续相同导致的歧义。  
- **模块化递推**：分离前向/后向推导逻辑，保持代码清晰。  
- **防御性检查**：在递推中即时判断值域越界，提前终止无效计算。  

---

#### 4. C++核心代码实现赏析
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

long long gcd(long long a, long long b) {
    return b ? gcd(b, a % b) : a;
}

int main() {
    int T; cin >> T;
    while (T--) {
        long long n, M;
        cin >> n >> M;
        vector<long long> A(n - 1);
        for (int i = 0; i < n - 1; i++) cin >> A[i];

        // 定位首个相邻差异位置
        int pivot = -1;
        for (int i = 0; i < n - 2; i++) {
            if (A[i] != A[i + 1]) {
                pivot = i;
                break;
            }
        }
        if (pivot == -1) pivot = n - 2; // 保底处理

        vector<long long> B(n);
        B[pivot + 1] = gcd(A[pivot], A[pivot + 1]); // 核心gcd计算

        // 前向递推
        for (int i = pivot; i >= 0; i--) 
            B[i] = A[i] / B[i + 1];
        // 后向递推
        for (int i = pivot + 2; i < n; i++) 
            B[i] = A[i - 1] / B[i - 1];

        // 值域验证
        bool valid = true;
        for (auto x : B) 
            if (x > M || x < 1) valid = false;

        if (valid) 
            for (auto x : B) cout << x << " ";
        else 
            cout << -1;
        cout << endl;
    }
    return 0;
}
```
**代码解读概要**：  
1. 通过`gcd()`在差异位置计算密文关键项  
2. 双向递推利用`A[i] = B[i] * B[i+1]`的等式关系  
3. 严格验证值域后输出  

---

#### 5. 算法可视化：像素动画演示  
* **主题**：8位像素风“密码破译行动”  
* **核心演示**：  
  1. **初始化**：网格展示明文序列（如`55,35,77`），差异位置（`35`和`77`）闪烁黄光。  
  2. **gcd计算**：差异位置上方弹出`gcd(35,77)=7`，伴随“叮”音效，对应密文方块亮起。  
  3. **递推动画**：  
     - 向左：`35/7→5`，绿色箭头左移，更新左侧方块。  
     - 向右：`77/7→11`，红色箭头右移，更新右侧方块。  
  4. **越界检测**：若方块变红并显示`X`，播放“嘟”错误音效。  
* **交互控制**：  
  - 步进模式：按方向键单步执行。  
  - 自动模式：调速滑块控制递推速度，完成时触发8-bit胜利音乐。  

---

#### 6. 拓展练习与相似问题思考
1. **洛谷 P1072 [Hankson的趣味题]**  
   → 练习质因数分解与gcd/lcm的综合应用。  
2. **洛谷 P4549 [裴蜀定理]**  
   → 深入理解gcd的数论本质。  
3. **洛谷 P1069 [细胞分裂]**  
   → 强化质因数分解在递推中的变形应用。  

---

#### 7. 学习心得与经验分享
> **作者Utilokasteinn的调试经验**：  
> “最初从首位开始计算导致连续相同数据出错... 必须寻找差异位置！”  
> **Kay点评**：这印证了防御性编程的重要性——题目条件既是约束也是提示，差异位置就是破题钥匙！  

---

算法如月战结界，破译需巧力与洞察。掌握gcd递推之钥，你也能成为加密通信的破解专家！🚀

---
处理用时：136.96秒
# 题目信息

# 「PMOI-1」抽奖

## 题目描述

活动奖池中共有 $n$ 种道具，dead_X 有 $m$ 张兑奖券。一张兑奖券可以兑换成一次抽奖机会或 $114514$ 金币。

dead_X 决定将一部分兑奖券拿来抽奖，并将剩下的兑奖券兑换成金币。

在一次抽奖机会中，dead_X 会等概率得到所有奖池中一款道具的 $1919810$ 秒**体验卡**。

由于 dead_X 在活动中买了 VIP 卡，他可以在所有抽奖结束后选择一款**抽奖得到**的体验卡，将所有这种类型的体验卡上交，并得到对应种类的**永久道具**。

注意，dead_X 可以不使用这个功能，但是不可以使用多于一次。

有选择困难症的 dead_X 想知道，有多少种可能的**活动结果**。

两种活动结果不同，当且仅当 dead_X 获得的金币不同，或者在任何一次抽奖中获得的体验卡不同（即抽到体验卡形成的序列不同），或者获得的永久道具不同。

注意，抽奖中获得的都是体验卡，最后选择的永久道具和体验卡在哪一次抽出没有关系。

------------

Update 2023.11.16：出题人看自己好几年前写的题面绷不住了，补一份形式化题面。

定义一个序列的权值是其不同元素个数 $+1$，例如 $[1,9,2,6,8,1,7]$ 的权值是 $7$。

对于所有长度 $\in[0,m]$，每个数 $\in [1,n]$ 的整数序列，求其权值和对 $10^9+7$ 取模的值。

## 说明/提示

【样例解释】

以下为第二组测试数据所有可能的方案：

假设两种物品分别为 $A$ 和 $B$。

1. 兑换 $229028$ 金币。
1. 兑换 $114514$ 金币，获得 $A$ 体验卡。
1. 兑换 $114514$ 金币，获得 $B$ 体验卡。
1. 兑换 $114514$ 金币，获得 $A$ 永久道具。
1. 兑换 $114514$ 金币，获得 $B$ 永久道具。
1. 第一次获得 $A$ 体验卡，第二次获得 $A$ 体验卡。
1. 第一次获得 $A$ 体验卡，第二次获得 $B$ 体验卡。
1. 第一次获得 $B$ 体验卡，第二次获得 $A$ 体验卡。
1. 第一次获得 $B$ 体验卡，第二次获得 $B$ 体验卡。
1. 第一次获得 $A$ 体验卡，第二次获得 $A$ 体验卡，指定 $A$ 为永久道具。
1. 第一次获得 $A$ 体验卡，第二次获得 $B$ 体验卡，指定 $A$ 为永久道具。
1. 第一次获得 $B$ 体验卡，第二次获得 $A$ 体验卡，指定 $A$ 为永久道具。
1. 第一次获得 $A$ 体验卡，第二次获得 $B$ 体验卡，指定 $B$ 为永久道具。
1. 第一次获得 $B$ 体验卡，第二次获得 $A$ 体验卡，指定 $B$ 为永久道具。
1. 第一次获得 $B$ 体验卡，第二次获得 $B$ 体验卡，指定 $B$ 为永久道具。

【数据范围】
- Subtask1（10pts）：$n,m\leq5,T\le25$；
- Subtask2（10pts）：$n=1$；
- Subtask3（10pts）：$m=1$；
- Subtask4（20pts）：$n,m\leq1000,T\leq 5$；
- Subtask5（20pts）：$\sum m\leq10^6$；
- Subtask6（30pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1\le n,m\leq 10^9$，$1\le T\leq 10^5$。

## 样例 #1

### 输入

```
5
2 1
2 2
3 3
114 514
1919810 7872754```

### 输出

```
5
15
115
338602801
30498159```

# AI分析结果


### 💡 Kay的C++算法解析：「PMOI-1」抽奖 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`组合数学与生成函数`  
🗣️ **初步分析**：  
> 本题本质是计算所有可能序列的权值和（权值=不同元素个数+1）。就像收集不同种类的卡牌，每多一种新卡牌，你的收藏价值就增加一分。  
> - **核心思路**：将权值拆解为"序列存在性贡献"（不同元素个数）和"基础贡献"（+1），利用生成函数思想分别计算。  
> - **关键推导**：  
>   - 固定序列长度k时，权值和 = n^{k+1} + n^k - n·(n-1)^k  
>   - 最终答案 = ∑<sub>k=0</sub><sup>m</sup>[n^{k+1} + n^k - n·(n-1)^k]  
> - **可视化设计**：  
>   采用像素卡牌收集游戏演示：  
>   - 8-bit风格卡牌机，每张卡牌代表序列中的一个元素  
>   - 卡牌堆滑动动画展示序列生成过程  
>   - 新种类卡牌出现时触发"叮"音效+闪光，统计区实时更新不同元素计数  
>   - 控制面板可调节序列长度k（0→m），观察权值变化趋势  

---

#### 精选优质题解参考
**题解一（来源：wwlw）**  
* **点评**：  
  推导最清晰——直接通过组合意义建立方程（选卡→抽卡→计算覆盖情况）。代码封装了等比数列求和函数`calc()`，规范处理了n=1和n>1的分支。亮点在于用组合恒等式化简复杂求和式，避免冗余循环。实践价值高，可直接用于竞赛。

**题解二（来源：dead_X）**  
* **点评**：  
  创新性使用概率期望转换问题（不同元素个数期望 = n·(1-(1-1/n)<sup>k</sup>)）。代码简洁但未封装，直接在主函数特判n=1,2。亮点是提供形式化题面，帮助理解抽象定义。调试经验：注意等比数列求和时分母为零的特殊情况。

**题解三（来源：123456Mm）**  
* **点评**：  
  分步解释最详细（权值=基础方案+永久道具方案）。代码实现独立逆元函数，数学意义明确。亮点是强调特判重要性：避免对0或1求逆元。实践建议：先推小规模数据验证公式正确性。

---

#### 核心难点辨析与解题策略
1. **难点1：权值的组合意义抽象**  
   * **分析**：权值=不同元素数+1，需拆解为两个独立贡献。优质题解均通过固定序列长度k简化问题  
   * 💡 **学习笔记**：复杂定义 → 分解为基本计数问题  

2. **难点2：避免重复计数**  
   * **分析**：计算"选定永久道具"方案时，需排除未抽到该道具的情况（即减去(n-1)<sup>k</sup>）  
   * 💡 **学习笔记**：容斥原理是排除无效方案的核心工具  

3. **难点3：大数等比数列求和**  
   * **分析**：当n=1或n=2时，求和公式分母为零，需单独处理（如n=1时和为2m+1）  
   * 💡 **学习笔记**：数学公式需验证边界条件鲁棒性  

✨ **解题技巧总结**  
- **技巧1 问题降维**：将动态长度问题转化为固定长度求和  
- **技巧2 贡献分离**：将复合权值拆解为独立可计算分量  
- **技巧3 特判优先**：对特殊参数（n=1,2）预先设计处理逻辑  

---

#### C++核心代码实现赏析
**通用核心实现（综合自wwlw与123456Mm）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9+7;

long long qpow(long long x, long long y) {
    long long res = 1;
    for (; y; y >>= 1, x = x*x%MOD)
        if (y & 1) res = res*x%MOD;
    return res;
}

long long geomSum(long long r, long long k) {
    if (r == 0) return 1;      // k=0时序列只有空集
    if (r == 1) return k+1;    // 公比为1时直接返回项数
    return (qpow(r, k+1)-1) * qpow(r-1, MOD-2) % MOD;
}

int main() {
    int T; cin >> T;
    while (T--) {
        long long n, m;
        cin >> n >> m;
        
        long long S1 = n>1 ? geomSum(n, m) * n % MOD : m+1;
        long long S2 = n>1 ? geomSum(n, m) : m+1;
        long long S3 = n * (n>2 ? geomSum(n-1, m) 
                        : (n==2 ? m+1 : (n==1 ? 1 : 0)));
        
        cout << ((S1 + S2 - S3) % MOD + MOD) % MOD << endl;
    }
}
```
**代码解读概要**：  
> 1. `qpow`：快速幂模运算（核心工具）  
> 2. `geomSum`：等比数列求和（特判公比r=0,1）  
> 3. 主逻辑：计算三部分和式 S1=∑n<sup>k+1</sup>, S2=∑n<sup>k</sup>, S3=∑n·(n-1)<sup>k</sup>  

**题解一核心片段赏析**  
```cpp
ll calc(ll x,ll y){
    if(!x) return 1;
    if(x==1) return (y+1)%MOD;
    return (qpow(x,y+1)-1+MOD)%MOD * qpow(x-1,MOD-2)%MOD;
}
```
**亮点**：等比数列求和函数化，严格处理边界条件  
**学习笔记**：封装数学工具函数提升代码复用性  

---

### 算法可视化：像素动画演示
**主题**：8-bit卡牌收集机  
**核心演示**：  
![](https://via.placeholder.com/400x200/000000/FFFFFF?text=像素卡牌机动画示意)  
1. **初始化**：  
   - 左侧卡池：n种像素卡牌（不同颜色/图案）  
   - 右侧序列区：空网格（最大长度m）  
   - 控制面板：长度滑块k（0→m），开始/单步按钮  

2. **序列生成**：  
   - 点击"抽卡"：随机卡牌滑入序列格（伴随"叮"音效）  
   - 新卡牌出现：闪光动画+收集进度条更新  

3. **权值计算**：  
   - 实时显示：序列长度k，不同元素数d，权值d+1  
   - 公式同步高亮：n<sup>k+1</sup> + n<sup>k</sup> - n·(n-1)<sup>k</sup>  

4. **特例演示模式**：  
   - n=1时：所有卡牌同色，权值恒为2（k≥1）  
   - n=2时：分母警告动画（红色闪烁）  

**设计逻辑**：通过游戏化收集过程具象化抽象公式，音效强化关键操作记忆  

---

#### 拓展练习与相似问题思考
1. **洛谷 P1494** - 小Z的袜子  
   * 理由：同属组合计数+概率期望经典题，强化贡献分离思想  

2. **洛谷 P6156** - 简单题  
   * 理由：考察大范围求和公式推导，需类似特判技巧  

3. **洛谷 P6620** - 组合数问题  
   * 理由：练习生成函数与组合恒等式的高级应用  

---

#### 学习心得与经验分享
> **dead_X的反思**：  
> "初始题面过于复杂导致选手难以抽象核心模型，后补充形式化定义显著提升可读性"  
>   
> **Kay总结**：  
> 复杂问题需先剥离情景提取数学模型，验证时从小规模特例入手（如n=1, m=1）  

---  
💡 掌握组合计数与生成函数的转化思维，你就能像玩卡牌游戏一样优雅解决数学难题！

---
处理用时：136.37秒
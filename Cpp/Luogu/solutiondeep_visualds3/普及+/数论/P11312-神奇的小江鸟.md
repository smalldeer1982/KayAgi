# 题目信息

# 神奇的小江鸟

## 题目背景

You can also see the pdf at the bottom of the chinese problem statement.

感谢 [ineverleft](https://www.luogu.com.cn/user/362679) 为本题提供的本地调试 checker。

「愿有前程可奔赴，亦有岁月可回首。」

## 题目描述

小 $ \zeta $ 在探险过程中看到了一个大锁。

这个大锁有 $ n $ 个拨圈，第 $ i $ 个拨圈的拨动范围为 $ l_i $ 到 $ r_i $ 之间（含两个边界）的所有整数（保证 $ l_i \le r_i $）。

我们定义这个大锁的「自由度」为所有拨圈上的数的**最大公约数**，当锁的「自由度」大于等于 $ k $ 时，会被打开。

请你找到一种锁的开启方案，或报告无解。

## 说明/提示

**【样例 1 解释】**

唯一的一组数据 $ \gcd $ 为 $ 10 $。

五个样例自测均可使用下发的附件。**请注意部分样例可能存在多解，样例输出仅列举了一组可行解。**

**【数据规模与约定】**

对于 $ 100\% $ 的数据，$ 1 \le T \le 5 $，$ 2 \le n \le 10^4 $，$ 1 \le l_i \le r_i \le 10^9 $，$ 1 \le k \le 1000 $。

**本题开启子任务捆绑测试。**

* Subtask 1（10 pts）：$ k=1 $。
* Subtask 2（15 pts）：$ n \le 10 $，$ r_i - l_i + 1 \le 5 $。
* Subtask 3（15 pts）：$ r_i \le 10^3 $。
* Subtask 4（10 pts）：$ k \le 5 $，$ l_i,r_i $ 均在 $ 1 \le l_i \le r_i \le 10^9 $ 范围内等概率随机生成，该子任务只有 $ 1 $ 个测试点。
* Subtask 5（15 pts）：对于每组数据，$ \exist 1 \le i \le n,l_i=r_i $。
* Subtask 6（35 pts）：无特殊限制。

**【关于附加文件】**

**本题下发了 `checker.cpp` 作为自测器。**

请将输入内容、你的程序输出、参考答案输出分别放置在 `restore.in`、`restore.out`、`restore.ans` 中，这三个文件必须与 `checker.cpp` 在同一目录下，运行 `checker.cpp`，终端上会给出自测结果。

**你需要保证你的输入满足 $ 100\% $ 数据范围的要求。**

注意，如果你的输入/输出/答案的格式和范围不正确的话，`checker.cpp` 出现的结果是不可预料的。因此，**请先确保你的三个文件格式正确。**

## 样例 #1

### 输入

```
1
5 10
1 12
44 50
9 10
88 99
29 99```

### 输出

```
Yes
10 50 10 90 30```

## 样例 #2

### 输入

```
2
3 11
99 10003
39 299
39 10003
5 55
1 54
1 20
1 300
1 300
1 300```

### 输出

```
Yes
123 246 369
No```

## 样例 #3

### 输入

```
3
6 1
1 10
1 10
1 10
1 10
1 10
1 10
5 4
11 15
6 10
9 14
20 23
27 29
5 11
20 30
50 70
111 120
72 77
119 121```

### 输出

```
Yes
1 1 4 5 1 4
Yes
14 7 14 21 28
Yes
24 60 120 72 120```

## 样例 #4

### 输入

```
4
3 33
32 34
65 67
97 101
3 5
299 99494993
499 49992999
499 39999939
4 25
719 830
2194 2893
132 142
199 225
3 10
140 143
131 135
238 241```

### 输出

```
Yes
33 66 99
Yes
1919810 11400 51400
Yes
729 2700 135 216
No```

## 样例 #5

### 输入

```
1
10 7
77 77
82 174
77 77
82 174
77 77
82 174
77 77
82 174
77 77
82 174```

### 输出

```
Yes
77 154 77 154 77 154 77 154 77 154```

# AI分析结果


# 💡 Kay的C++算法解析：神奇的小江鸟 深入学习指南 💡

> 欢迎来到算法世界！我是Kay，今天我们将一起探索「神奇的小江鸟」这道有趣的构造题。通过本指南，你将掌握核心算法思想、解题技巧，并通过生动的像素动画直观理解算法执行过程。准备好开启这段冒险了吗？Let's go!

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学性质应用`（枚举优化与区间性质）

🗣️ **初步分析**：
> 解决这道题的关键在于**寻找一个公因数d（d≥k）**，使得每个区间都包含d的倍数。想象每个区间是一条跑道，d的倍数就是跑道上的检查点，我们需要找到一把钥匙（d）能打开所有跑道上的检查点锁。
>
> - **核心思路**：① 若所有区间长度≥k，直接选d=k（每个区间必有k的倍数）；② 否则枚举最短区间内所有数的因子（≥k），验证是否满足所有区间。
> - **难点对比**：直接枚举d会超时（d可达1e9），利用区间长度性质将枚举范围缩小至k²以内。
> - **可视化设计**：动画中将区间显示为像素条带，高亮d的倍数位置，红色闪烁提示失败区间，绿色庆祝成功（复古8-bit音效配合关键操作）。
> - **复古游戏化**：设计为「数字迷宫探险」主题，AI自动枚举因子时像贪吃蛇扫描迷宫，胜利时播放FC风格胜利音乐。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰性、代码规范性和算法效率等维度，我精选了3份优质题解进行深度解析：
</eval_intro>

**题解一（船酱魔王）**
* **点评**：思路清晰分层处理（长短区间二分），代码规范（封装check函数），算法高效利用因子枚举（O(k²√V)）。亮点在于**精准定位最短区间**避免无效枚举，实践时注意用set去重因子。

**题解二（Austin0116）**
* **点评**：采用数据分治策略（n≤10暴力枚举，否则枚举右端点），代码结构工整。亮点在于**自适应数据规模**，但阈值设定依赖测试数据，学习其灵活处理思想。

**题解三（Moya_Rao）**
* **点评**：简洁直击问题本质（先判区间长度再枚举因子），代码短小精悍。亮点在于**无冗余操作**，适合初学者理解核心逻辑，但因子未去重可稍优化。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大难点，结合优质题解解法总结策略：
</difficulty_intro>

1.  **如何高效确定候选d？**
    * **分析**：d需≥k且每个区间含d的倍数。优质解通过**最短区间长度**分治：若≥k则d=k；否则枚举区间内数的因子。
    * 💡 **学习笔记**：最短区间是突破口，其长度限制因子枚举量（≤k-1）。

2.  **如何验证d的可行性？**
    * **分析**：对每个区间计算`ceil(lᵢ/d)*d ≤ rᵢ`。船酱魔王用统一check函数实现，代码复用性强。
    * 💡 **学习笔记**：避免重复计算，封装验证函数提升可读性。

3.  **因子枚举如何优化？**
    * **分析**：Moya_Rao的解法直接枚举因子至√x，但未去重；船酱魔王用set自动去重。后者更优。
    * 💡 **学习笔记**：set去重避免重复验证，提升效率。

### ✨ 解题技巧总结
<summary_best_practices>
掌握以下技巧，轻松应对类似问题：
</summary_best_practices>
-   **区间性质转化**：区间长度≥d ⇒ 必含d的倍数（鸽巢原理）
-   **枚举范围压缩**：利用极端情况（如最短区间）缩小搜索空间
-   **模块化设计**：分离因子枚举和验证逻辑，代码更健壮
-   **边界防御**：检查lᵢ=0？题目保证lᵢ≥1，但养成检查习惯很重要

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解优化的通用实现，完整包含输入处理、核心算法和输出：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合船酱魔王因子枚举与Austin0116分治思想，添加详细注释
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
#include <set>
#include <vector>
using namespace std;

typedef pair<int, int> pii;

bool check(int d, vector<pii>& seg, bool output = false) {
    for (int i = 0; i < seg.size(); ++i) {
        int l = seg[i].first, r = seg[i].second;
        int t = (l + d - 1) / d; // 向上取整技巧
        int num = t * d;
        if (num > r || num < l) return false;
        if (output) printf("%d%c", num, " \n"[i==seg.size()-1]);
    }
    return true;
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        int n, k; scanf("%d%d", &n, &k);
        vector<pii> seg(n);
        int min_len = 2e9, min_idx = -1;

        for (int i = 0; i < n; ++i) {
            scanf("%d%d", &seg[i].first, &seg[i].second);
            int len = seg[i].second - seg[i].first;
            if (len < min_len) min_len = len, min_idx = i;
        }

        // 情况1：所有区间长度均≥k ⇒ 必有解
        if (min_len >= k) {
            if (check(k, seg, true)) continue;
            else puts("No"); // 理论上不会执行
        } 
        // 情况2：存在短区间 ⇒ 枚举因子
        else {
            set<int> factors;
            int L = seg[min_idx].first, R = seg[min_idx].second;
            
            // 枚举区间内每个数并分解因子
            for (int x = L; x <= R; ++x) {
                for (int j = 1; j * j <= x; ++j) {
                    if (x % j != 0) continue;
                    if (j >= k) factors.insert(j);
                    if (x / j >= k) factors.insert(x / j);
                }
            }

            bool found = false;
            for (int d : factors) {
                if (check(d, seg)) {
                    puts("Yes");
                    check(d, seg, true); // 输出方案
                    found = true;
                    break;
                }
            }
            if (!found) puts("No");
        }
    }
    return 0;
}
```
* **代码解读概要**：
  1. `check()`函数封装d的验证逻辑，`output`参数控制是否输出方案
  2. 寻找`min_idx`定位最短区间（突破口）
  3. 情况1：所有区间长度≥k时直接取d=k
  4. 情况2：枚举最短区间内数的因子（set自动去重）
  5. 因子验证顺序按升序，找到首个可行解即退出

---
<code_intro_selected>
精选题解独特技巧片段解析：
</code_intro_selected>

**题解一（船酱魔王）因子处理片段**
```cpp
set<int> se;
for(int i = rn[1].first; i <= rn[1].second; i++) {
    for(int j = 1; j * j <= i; j++) {
        if(i % j == 0) {
            if(j >= k) se.insert(j);
            if(i / j >= k) se.insert(i / j);
        }
    }
}
```
* **亮点**：因子分解兼顾j与i/j，避免遗漏
* **学习笔记**：内层循环j≤√i保证O(√n)分解效率

**题解二（Austin0116）分治策略片段**
```cpp
if(n <= 10) { 
    // 暴力枚举d到1e6 
} else { 
    sort(a+1, a+1+n, cmp); // 按右端点排序
    for(int i=k; i<=a[1].y; i++) // 枚举最小右端点
}
```
* **亮点**：根据n大小切换策略，平衡效率
* **学习笔记**：竞赛中数据分治是实用技巧，但需测试验证阈值

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
让我们通过像素动画直观理解算法！设计采用8-bit复古风格，主题为「数字迷宫探险家」：
</visualization_intro>

* **场景设计**：
  - 每个区间为横向像素条带（长度=区间长度）
  - 拨圈值用不同颜色像素表示，d的倍数位置显示为✨
  - 控制面板：速度滑块/单步/暂停/重置（FC手柄风格）

* **关键动画帧**：
  1. **扫描最短区间**（像素小人移动到min_idx条带）
  2. **枚举因子d**（屏幕顶部显示当前d，伴随滴答声）
  3. **标记倍数位置**（所有条带上✨闪烁，成功标记音效）
  4. **区间验证失败**（该条带变红闪烁，播放低沉音效）
  5. **成功庆祝**（所有✨同步闪烁，播放胜利音乐）

* **技术实现**：
  ```javascript
  // 伪代码：绘制第i个区间条带
  function drawSegment(i, l, r) {
      for(let x=l; x<=r; x++) {
          let color = (x % d === 0) ? GOLD : BLUE;
          drawPixel(x, i, color); 
      }
  }
  // 验证失败时红色闪烁
  if(!valid) segment[i].flash(RED); 
  ```

* **游戏化元素**：
  - **AI演示模式**：自动枚举因子（速度可调），像贪吃蛇扫描迷宫
  - **音效设计**：
    - 枚举因子：电子滴答声
    - 标记倍数：清脆提示音
    - 成功通关：FC版《超级玛丽》过关音乐
  - **积分系统**：每找到一个可行d得10分，连续成功有连击奖励

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握核心思想后，挑战这些相似问题巩固技能：
</similar_problems_intro>

1. **洛谷 P1891 区间素数**（P1891）
   * 🗣️ **推荐理由**：练习区间内特殊数（素数）存在性判断，强化枚举优化技巧

2. **洛谷 P2568 GCD**（P2568）
   * 🗣️ **推荐理由**：深入理解gcd性质，学习前缀和优化枚举

3. **洛谷 2651 添加括号**（P2651）
   * 🗣️ **推荐理由**：区间约束下的构造问题，培养分治思维

---

## 7. 学习心得与经验分享

<insights_intro>
从题解中提炼的宝贵经验：
</insights_intro>

> **参考经验（船酱魔王）**：  
> *“先通过区间排序定位最短区间，其长度决定解题方向：≥k则直接取k，否则枚举因子。注意因子验证需升序进行。”*  
>  
> **Kay的总结**：  
> 该经验突出了**问题分治**思想——将大问题拆解为两种更小的情况处理。调试时注意：  
> 1. 验证因子d时代码复用性（避免复制粘贴）  
> 2. 因子枚举范围优化（j≤√x）  
> 3. 使用set去重避免重复验证  

---

> 恭喜完成本次算法探险！通过分治思想、因子枚举和像素动画解析，相信你已经掌握「神奇的小江鸟」的核心解法。记住：面对复杂问题时，寻找极端情况（如最短区间）往往是突破口。下次挑战再见！🚀

---
处理用时：203.11秒
# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果


### 💡 Kay的C++算法解析：Mivik写书 深入学习指南 💡

#### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`容斥原理与并查集应用`  
🗣️ **初步分析**：  
> 解决"期望子串复杂度"问题，本质是**计算所有可能字符串的本质不同子串期望值**。核心思想如同"拆礼盒"：  
> 1. **容斥原理**：先计算所有子串的总贡献，再通过符号调整（+/-）消除重复计数，类似拆开层层包装时记录"拆了几层"  
> 2. **并查集**：处理子串重叠时，用"链条"（并查集）锁定必须相同的字符位置  
>  
> **可视化设计思路**：  
> - 8位像素网格展示字符串，用不同颜色方块表示字符  
> - 高亮当前枚举的子串位置（闪烁红色边框）  
> - 并查集合并时显示像素链条动画（"咔嗒"音效）  
> - 贡献值用复古数字计数器实时更新（+/-符号闪动）  

---

#### 2. 精选优质题解参考  
**题解一 (Huasushis)**  
* **点评**：  
  思路清晰度 ★★★★☆（详细解释容斥原理，新手友好）  
  代码规范性 ★★★★☆（变量名`qp`/`fa`含义明确，结构工整）  
  算法有效性 ★★★★★（$O(n^22^n)$ 完美处理 n≤20）  
  实践价值 ★★★★☆（完整包含逆元处理，可直接用于竞赛）  
  **亮点**：结合并查集与位运算，用`__builtin_parity`优化奇偶判断  

**题解二 (7KByte)**  
* **点评**：  
  思路清晰度 ★★★☆☆（解释简洁但未深入细节）  
  代码规范性 ★★★★★（极致简洁，位运算`mt[]`映射巧妙）  
  算法有效性 ★★★★★（同复杂度但常数更优）  
  实践价值 ★★★★☆（适合竞赛代码风格）  
  **亮点**：`mt[]`数组实现位到索引的O(1)映射，大幅提升效率  

**题解三 (rainygame)**  
* **点评**：  
  思路清晰度 ★★★☆☆（理论解释较少）  
  代码规范性 ★★★★☆（封装`qpow`函数，逻辑紧凑）  
  算法有效性 ★★★★★（并查集优化字符约束处理）  
  实践价值 ★★★★☆（鲁棒的边界处理）  
  **亮点**：`c[]`数组记录位置约束，避免冗余合并操作  

---

#### 3. 核心难点辨析与解题策略  
1. **难点：避免子串重复计数**  
   * **分析**：本质不同子串存在重叠，需用容斥原理调整贡献符号（+/-）  
   * 💡 **学习笔记**：奇数次出现加贡献，偶数次出现减贡献  

2. **难点：处理重叠字符约束**  
   * **分析**：重叠位置字符必须相同 → 用并查集合并位置索引  
   * 💡 **学习笔记**：每个连通块代表一组强制相等的字符  

3. **难点：高效枚举与计算**  
   * **分析**：位运算枚举子串位置（$2^{n}$状态），并查集维护时间复杂度$O(nα(n))$  
   * 💡 **学习笔记**：`__builtin_parity`和`__builtin_ctz`加速位操作  

### ✨ 解题技巧总结  
- **容斥框架**：贡献 = $\sum(-1)^{|S|+1} \cdot$（自由变量方案数）  
- **并查集压缩**：合并重叠位置时路径压缩优化  
- **位运算技巧**：用掩码`b=(1<<x)-1`提取低位状态  

---

#### 4. C++核心代码实现赏析  
**通用核心实现**  
```cpp
#include <bits/stdc++.h>
#define mod 1000000007
using namespace std;
// 并查集 + 容斥框架（综合优化版）
int n, m, fa[25];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

void solve(int len) {
    int states = 1 << (n - len + 1);
    for (int s = 1; s < states; s++) {
        for (int i = 0; i < len; i++) fa[i] = i; // 初始化并查集
        int free_cnt = 0, overlap = 0; 
        // ... 位运算处理位置约束（见完整代码）
        long ways = pow(m, free_cnt); // 自由变量方案数
        ans += (__builtin_popcount(s) & 1) ? ways : -ways;
    }
}
```
> **代码解读概要**：  
> 1. 外层循环枚举子串长度`len`  
> 2. 中层枚举出现位置集合`s`（二进制位表示）  
> 3. 内层用并查集合并重叠字符位置  
> 4. 最终贡献按集合大小奇偶性正负调整  

**题解一片段赏析**  
```cpp
c = (c << 1) | ((i >> j) & 1); 
c &= b; // 掩码提取有效位
if (!c) ++tot;  // 未覆盖位置计数
else {
    int t = c - (c & -c); 
    int root = find(__builtin_ctz(c));
    while (t) { // 合并所有重叠位
        fa[find(__builtin_ctz(t))] = root;
        t -= t & -t;
    }
}
```
> **解读**：  
> - `c & -c`：取最低位的1（定位第一个重叠位置）  
> - `t = c - lowbit`：获取剩余重叠位  
> - `__builtin_ctz`：计算末尾0的个数（位→索引转换）  
> 💡 **学习笔记**：位运算技巧将并查集合并复杂度降至$O(k)$（k为重叠位数）  

---

#### 5. 算法可视化：像素动画演示  
**主题**：`像素探险家：字符森林的宝藏地图`  
**核心演示**：  
![](https://via.placeholder.com/400x200?text=8-bit+Pixel+Grid)  
1. **场景设计**：  
   - 8x8像素网格模拟字符串（FC游戏风格）  
   - 并查集链条显示为锁链动画（合并时播放"咔嗒"音效）  
   - 贡献值用顶部复古LED计数器显示（+/-符号闪烁）  

2. **交互控制**：  
   ```plaintext
   [▶️] 自动播放  [⏸️] 暂停  [⏭️] 单步  [🔢] 速度滑块
   ```  
3. **关键帧流程**：  
   - **帧1**：蓝色像素块标记当前枚举子串位置  
   - **帧2**：红色闪烁显示重叠位置 → 触发锁链合并动画  
   - **帧3**：自由位置变为绿色 → 计数器更新并播放"叮"音效  
   - **胜利条件**：完成所有枚举 → 播放胜利音效 + 烟花特效  

> **设计意义**：像素链条直观展示并查集合并，符号闪烁强化容斥原理理解  

---

#### 6. 拓展练习与相似问题  
**通用迁移场景**：  
1. 集合交并问题（如元素重复计数）  
2. 网格路径覆盖（重叠路径约束）  
3. 排列组合中的限制条件处理  

**洛谷推荐**：  
1. **P3349 [ZJOI2016]小星星**  
   🗣️ 容斥+树形DP，强化"约束转化"思维  
2. **P3174 [HAOI2009]毛毛虫**  
   🗣️ 并查集处理连通块，类似字符约束模型  
3. **P3226 [HNOI2012]集合选数**  
   🗣️ 位枚举+约束处理，数据范围适配本题技巧  

---

> 本次分析未发现明确的作者个人心得分享部分。希望本指南助你掌握容斥与并查集的精妙配合！🎮✨

---
处理用时：110.55秒
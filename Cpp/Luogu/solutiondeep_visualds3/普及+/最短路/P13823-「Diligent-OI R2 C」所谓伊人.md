# 题目信息

# 「Diligent-OI R2 C」所谓伊人

## 题目背景

> 溯洄从之，道阻且长。溯游从之，宛在水中央。——《诗经·秦风·蒹葭》

## 题目描述

给定一张 $n$ 个点，$m$ 条边的有向图，点从 $1\sim n$ 编号。图中每个点 $i$ 有点权 $p_i$。注意可能有重边自环。

如果点 $u$ 出发存在路径到达点 $v$，则你可以将 $u,v$ 的点权交换。

对于每个点 $i$，输出使 $i$ 点权最大化的最少交换次数。**请注意，每个回答是独立的，即都应该从初始给定的图开始交换。**

## 说明/提示

#### 样例 #1 解释

可以证明，$6$ 个点的点权的最大可能值分别为 $1,1,5,5,5,4$。

使 $1$ 号点点权最大化的方案：不交换。

使 $2$ 号点点权最大化的方案：不交换。

使 $3$ 号点点权最大化的方案：交换 $3$ 号和 $4$ 号点的点权。

使 $4$ 号点点权最大化的方案：不交换。

使 $5$ 号点点权最大化的方案：交换 $4$ 号和 $5$ 号点的点权。

使 $6$ 号点点权最大化的方案：不交换。

#### 数据范围

对于所有数据，保证 $1\le n,m\le 5\times10^5,1\le p_i\le10^9,1\le u,v\le n$。注意可能有重边自环。

- Subtask 1（5pts）：$n,m\le3$。
- Subtask 2（25pts）：$n,m\le10^3$。
- Subtask 3（8pts）：图为一条链。即对于所有 $i=1,2,\dots,n-1$，$i$ 与 $i+1$ 之间有且仅有一条有向边，但方向不确定。
- Subtask 4（12pts）：图为一棵树。即 $m=n-1$，且图将有向边改成无向边后连通。
- Subtask 5（20pts）：$n,m\le5\times10^4$，且图随机生成。随机生成方式见下。
- Subtask 6（10pts）：$n,m\le10^5$。
- Subtask 7（20pts）：$n,m\le5\times10^5$。

Subtask 5 的随机生成方式：

- 先确定 $n,m$ 和序列 $p$（不一定随机）。
- 然后对于 $m$ 条边，每条边的 $u,v$ 都在 $1\sim n$ 的整数中均匀随机取。

**请注意，此题需要较快的输入输出方式，并且在实现过程中，请注意常数对程序效率的影响。**

## 样例 #1

### 输入

```
6 5
1 1 4 5 1 4
1 2
2 1
3 4
4 5
3 5```

### 输出

```
0 0 1 0 1 0```

# AI分析结果


### 💡 Kay的C++算法解析：「所谓伊人」深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：图论建模、拆点技巧、01BFS  
🗣️ **初步分析**：  
> 本题像在迷宫中寻找宝藏——每个点代表一个房间，点权是宝藏价值。房间之间有单向通道（边），每次交换相当于让宝藏“流动”到更合适的房间。  
> - **核心思路**：  
>   1. 同一连通块的点权可互换，每个点可达的最大点权即连通块最大值  
>   2. 通过拆点（每个点→4个状态）将交换代价转化为状态转移权值（0或1）  
>   3. 用01BFS计算从最大值点到其他点的最小代价  
> - **可视化设计**：  
>   用8位像素风格展示拆点状态（A1/A2/B1/B2），01BFS扩散时：  
>   - 0权边：绿色箭头，伴随“滴”声  
>   - 1权边：红色箭头，伴随“嘟”声  
>   - 最大值点：金色闪光，胜利时播放胜利音效  

---

#### 精选优质题解参考
**题解（来源：Night_sea_64 & jasmine0201）**  
* **点评**：  
  思路清晰拆解了交换代价（4状态建模），代码用双端队列实现01BFS高效处理权值差异。亮点在于：  
  - 拆点模型严谨（内部边权1，外部边权0）  
  - 时间复杂度优化至O(n+m)  
  - 连通块最大值预处理减少重复计算  
  需注意：起点距离初始化应为0（原代码为1需修正）  

---

#### 核心难点辨析与解题策略
1. **连通块最大值传递**  
   * **分析**：需快速确定各连通块的最大点权。题解用DFS预处理，将最大值反向传递至所有可达点（`s[x]=max(a[x], dfs(相邻点))`）  
   * 💡 **学习笔记**：DFS反向传播是处理连通块极值的利器  

2. **拆点建模代价系统**  
   * **分析**：将交换代价转化为状态转移权值：  
     - 内部转移（同点状态切换）：权值0或1  
     - 外部转移（原图边）：权值0  
   * 💡 **学习笔记**：拆点本质是增加状态维度，将操作代价编码为边权  

3. **01BFS优化计算**  
   * **分析**：双端队列保证时间复杂度O(n+m)：  
     - 0权边：加入队首（同层扩展）  
     - 1权边：加入队尾（下一层扩展）  
   * 💡 **学习笔记**：边权仅为0/1时，01BFS比Dijkstra更高效  

✨ **解题技巧总结**  
- **状态拆分法**：将复杂操作分解为离散状态（如4状态表进出方向）  
- **01BFS双端队列**：权值0/1的场景优先使用  
- **连通块预处理**：先处理独立子图再全局计算  

---

#### C++核心代码实现赏析
```cpp
// 修正版核心代码（起点距离初始化为0）
deque<int> q;
for (int i = 1; i <= n; i++) {
    if (b[i]) { // b[i]标记最大值点
        q.push_back(i*4+1); d[i*4+1] = 0; // 修正：起点距离=0
        q.push_back(i*4+2); d[i*4+2] = 0;
    }
}
while (!q.empty()) {
    int x = q.front(); q.pop_front();
    for (int i = ed.head[x]; i; i = ed.nxt[i]) {
        int v = ed.to[i], w = ed.w[i];
        if (d[v] > d[x] + w) { // 松弛成功
            d[v] = d[x] + w;
            w == 0 ? q.push_front(v) : q.push_back(v);
        }
    }
}
```

**代码解读**：  
1. **拆点建模**（每个点4状态）：  
   ```cpp
   addedge(i*4+1, i*4+3, 0); // A1→A3 (0权)
   addedge(i*4+1, i*4+4, 1); // A1→A4 (1权)
   ```  
   > 如同电梯换乘：同层移动免费（权0），跨层收费（权1）  

2. **01BFS核心**：  
   ```cpp
   w == 0 ? q.push_front(v) : q.push_back(v);
   ```  
   > 优先处理0权边（队首），保证最短距离单调性  

3. **结果输出**：  
   ```cpp
   cout << min(d[i*4+3], d[i*4+4]) << ' '; 
   ```  
   > 取终点状态A3/A4的最小值，如同选择最优出站口  

---

#### 算法可视化：像素动画演示
**主题**：像素地铁换乘系统  
**设计**：  
![](https://via.placeholder.com/400x200?text=拆点状态像素图)  
1. **像素建模**：  
   - 每个点：4个像素方块（红/黄/蓝/绿 → A1/A2/B1/B2）  
   - 边：箭头（0权：绿色；1权：红色）  

2. **动态演示**：  
   ```plaintext
   初始：最大值点 → 金色闪光 + 胜利音效
   BFS扩散： 
     - 0权边：绿色波纹扩散 + “滴”声
     - 1权边：红色脉冲扩散 + “嘟”声
   终点状态：显示min(A3,A4)并高亮
   ```  
3. **交互控制**：  
   - 步进按钮：单步观察状态转移  
   - 速度滑块：调节扩散速度  
   - 重置：重新随机生成地图  

---

#### 拓展练习与相似问题
1. **洛谷 P1144**：最短路计数（01BFS基础应用）  
   > 🗣️ 巩固01BFS框架，理解权值0/1的松弛逻辑  

2. **洛谷 P1948**：Telephone Lines（01BFS+二分答案）  
   > 🗣️ 学习将问题转化为01权值的最短路模型  

3. **洛谷 P2962**：Lights G（状态压缩+01BFS）  
   > 🗣️ 掌握高维状态拆分的典型应用  

---

> 本次解析完毕！记住：拆点是打开复杂图论问题的钥匙，01BFS是处理二元权值的快车道。动手实现可视化模型会大大加深理解哦！🚀

---
处理用时：164.76秒
# 题目信息

# [NOI2007] 社交网络

## 题目描述

在社交网络 ( Social Network ) 的研究中，我们常常使用图论概念去解释一些社会现象。不妨看这样的一个问题:   
在一个社交圈子里有 $n$ 个人，人与人之间有不同程度的关系。我们将这个关系网络对应到一个 $n$ 个结点的无向图上，两个不同的人若互相认识，则在他们对应的结点之间连接一条无向边，并附上一个正数权值 $c$ ，$c$ 越小，表示两个人之间的关系越密切。我们可以用对应结点之间的最短路长度来衡量两个人 $s$ 和 $t$ 之间的关系密切程度，注意到最短路径上的其他结点为 $s$ 和 $t$ 的联系提供了某种便利，即这些结点对于 $s$ 和 $t$ 之间的联系有一定的重要程度。我们可以通过统计经过一个结点 $v$ 的最短路径的数目来衡量该结点在社交网络中的重要程度。考虑到两个结点 $A$ 和 $B$ 之间可能会有多条最短路径。我们修改重要程度的定义如下：令 $C_{s,t}$ 表示从s到t的不同的最短路的数目，$C_{s,t}(v)$ 表示经过 $v$ 从 $s$ 到 $t$ 的最短路的数目；则定义：

$$ I(v)=\sum_{s \ne v,t\ne v} \frac{C_{s,t}(v)}{C_{s,t}}$$

为结点 $v$ 在社交网络中的重要程度。为了使 $I(v)$ 和 $C_{s,t}(v)$ 有意义，我们规定需要处理的社交网络都是连通的无向图，即任意两个结点之间都有一条有限长度的最短路径。现在给出这样一幅描述社交网络的加权无向图，请你求出每一个结点的重要程度。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/1136.png) 

对于1号结点而言，只有2号到4号结点和4号到2号结点的最短路经过1号结点，而2号结点和4号结点之间的最短路又有2条。因而根据定义，1号结点的重要程度计算为1/2+1/2=1。由于图的对称性，其他三个结点的重要程度也都是1。

对于 $50\%$ 的数据， $n \le 10 , m \le 45$。     
对于 $100\%$ 的数据， $n \le 100 , m \le 4500$ ，任意一条边的权值 $c$ 是正整数且 $1 \leqslant c \leqslant 1000$ 。    
所有数据中保证给出的无向图连通，且任意两个结点之间的最短路径数目不超过 $10^{10}$。     



## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
3 4 1
4 1 1```

### 输出

```
1.000
1.000
1.000
1.000```

# AI分析结果


### 💡 Kay的C++算法解析：社交网络 深入学习指南 💡

---

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：图论最短路计数（Floyd算法应用）

🗣️ **初步分析**：
> 解决社交网络问题，关键在于理解**Floyd算法的动态规划本质**。想象一张城市地图，Floyd算法就像一位聪明的导航员，逐步探索所有可能的"中转站"（k节点），动态更新任意两城市间的最短路径。  
> - 核心思路：通过三重循环枚举中转点k，更新任意两点(i,j)的最短路径长度(dis)和路径数量(cnt)。当dis[i][k]+dis[k][j]更短时重置cnt；相等时累加cnt（乘法原理）。  
> - 难点：理解路径数量的动态转移（cnt[i][j] = cnt[i][k] * cnt[k][j]）和重要度计算公式（I(v)=Σ(cnt[s][v]*cnt[v][t]/cnt[s][t])）。  
> - 可视化设计：像素网格中，用不同颜色标记k/i/j节点，高亮路径更新过程。当cnt更新时触发"金币+1"音效，成功找到最短路径时播放胜利音效，复古8-bit风格呈现路径数量增长动画。

---

#### **2. 精选优质题解参考**
**题解一 (来源：Ning_Mew)**  
* **点评**：思路清晰度极佳，用"导航员探索中转站"比喻Floyd过程。代码规范（dis/cnt变量名明确），算法有效性突出：正确处理最短路更新与计数，long long防溢出。实践价值高，完整AC代码可直接用于竞赛，边界处理严谨。亮点：Floyd计数逻辑推导透彻，调试心得（long long必要性）极具参考价值。

**题解二 (来源：Register)**  
* **点评**：代码简洁高效，sum数组命名直观体现计数功能。算法有效性体现在用double存储重要度避免精度问题。实践价值高，直接提供可运行代码。亮点：Floyd状态转移解释简明扼要，特别强调乘法原理应用。

**题解三 (来源：Rubidium_Chloride)**  
* **点评**：题解结构专业，"数据范围决定算法选择"的洞察深刻。代码规范性好（ll类型明确），算法有效性突出：用fill初始化替代memset更安全。亮点：将NOI题降维解析为"水题"的自信，引导学习者关注核心思想而非标签。

---

#### **3. 核心难点辨析与解题策略**
1. **难点1：路径计数动态转移**  
   * **分析**：当dis[i][k]+dis[k][j] = dis[i][j]时，cnt[i][j]需累加cnt[i][k]*cnt[k][j]。优质题解用乘法原理证明：i→k有m条路，k→j有n条路，则i→j新增m*n条路。
   * 💡 **学习笔记**：Floyd计数本质是动态规划的**状态转移叠加**。

2. **难点2：重要度公式实现**  
   * **分析**：需验证dis[s][v]+dis[v][t]=dis[s][t]确认v在路径上。分子cnt[s][v]*cnt[v][t]表示经过v的路径数，分母cnt[s][t]是总路径数。除法需转为double防整除错误。
   * 💡 **学习笔记**：公式物理意义是**节点v的路径占比**。

3. **难点3：大数溢出处理**  
   * **分析**：路径数≤10¹⁰，需用long long存储cnt。部分题解因int导致WA，经验证long long可解决。
   * 💡 **学习笔记**：**数据范围决定变量类型**，警惕10¹⁰边界。

✨ **解题技巧总结**：
- **拆解验证法**：将复杂公式拆解为dis验证+cnt计算两步
- **动态规划思想迁移**：Floyd计数本质是DP状态转移
- **边界四重检查**：s≠v, t≠v, s≠t, dis[s][v]+dis[v][t]==dis[s][t]

---

#### **4. C++核心代码实现赏析**
```cpp
// 通用核心代码（综合自优质题解）
#include <cstring>
#include <iostream>
using namespace std;
typedef long long ll;
const int N = 105;
const ll INF = 0x3f3f3f3f3f3f3f3f;

int main() {
    ll dis[N][N], cnt[N][N] = {0};
    double ans[N] = {0};
    int n, m; cin >> n >> m;

    // 初始化
    memset(dis, 0x3f, sizeof(dis));
    for (int i = 1; i <= n; i++) dis[i][i] = 0;
    while (m--) {
        int u, v, w; cin >> u >> v >> w;
        dis[u][v] = dis[v][u] = w;
        cnt[u][v] = cnt[v][u] = 1;
    }

    // Floyd核心
    for (int k = 1; k <= n; k++)
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= n; j++) {
                if (dis[i][k] + dis[k][j] < dis[i][j]) {
                    dis[i][j] = dis[i][k] + dis[k][j];
                    cnt[i][j] = cnt[i][k] * cnt[k][j];
                } else if (dis[i][j] == dis[i][k] + dis[k][j]) {
                    cnt[i][j] += cnt[i][k] * cnt[k][j];
                }
            }

    // 计算重要度
    for (int v = 1; v <= n; v++)
        for (int s = 1; s <= n; s++)
            for (int t = 1; t <= n; t++)
                if (s != v && t != v && s != t &&
                    dis[s][v] + dis[v][t] == dis[s][t])
                    ans[v] += (1.0 * cnt[s][v] * cnt[v][t]) / cnt[s][t];

    // 输出
    for (int i = 1; i <= n; i++)
        printf("%.3lf\n", ans[i]);
    return 0;
}
```
**代码解读概要**：  
1. 初始化dis为极大值（自环为0），cnt记录直接边  
2. Floyd三重循环动态更新最短路和路径数  
3. 验证v在s→t路径上时累加重要度  
4. 保留三位小数输出结果

---

**题解一核心片段赏析**  
```cpp
if(dis[i][j]>dis[i][k]+dis[k][j]) {
    dis[i][j] = dis[i][k] + dis[k][j];
    cnt[i][j] = cnt[i][k] * cnt[k][j];  // 状态重置
} else if(dis[i][j]==dis[i][k]+dis[k][j]) {
    cnt[i][j] += cnt[i][k] * cnt[k][j]; // 状态累加
}
```
**代码解读**：  
> 当发现更短路径时（第一条件），完全重置cnt；当路径等长时（第二条件），按乘法原理累加新路径数。  
> **学习笔记**：Floyd的**动态规划特性**在此体现：k是阶段，i,j是状态。

---

**题解二核心片段赏析**  
```cpp
ans[v] += (1.0 * cnt[s][v] * cnt[v][t]) / cnt[s][t];
```
**代码解读**：  
> 关键在`1.0*`转为浮点数，避免整数除法丢失精度。  
> **学习笔记**：**类型转换**是数值计算常见陷阱。

---

#### **5. 算法可视化：像素动画演示**
![](https://cdn.luogu.com.cn/upload/pic/1136.png)  
* **主题**：8-bit像素风"路径探险家"  
* **核心演示**：Floyd动态更新过程 + 重要度计算  

| 步骤               | 可视化设计                                                                 | 交互设计                  |
|--------------------|----------------------------------------------------------------------------|--------------------------|
| **初始化地图**     | 像素网格（100x100），不同颜色区分节点/边                                    | 显示dis/cnt初始值        |
| **枚举中转点k**   | k节点闪烁红光，播放"叮"音效                                                | 步进控制调节动画速度     |
| **路径更新**       | 当dis[i][j]更新时，i→j路径变绿；cnt增加时显示"+n"金币动画                  | 点击节点查看详细dis/cnt  |
| **重要度计算**     | 当v被验证在路径上时，s→v→t路径变黄，显示分数增长                            | 自动模式演示完整流程     |
| **通关反馈**       | 完成所有k时播放胜利音效，显示最终重要度排行榜                               | 重播/暂停控制            |

**设计原理**：  
- **颜色标记**：红(k)/蓝(i,j)/黄(验证路径)  
- **音效反馈**：路径更新(滴答声)，cnt增加(金币声)，完成(胜利号角)  
- **游戏化**：将k循环设计为10关，每关完成获得星级评价  

---

#### **6. 拓展练习与相似问题思考**
1. **洛谷 P1144** - 最短路计数  
   * 推荐理由：单源最短路计数，巩固BFS/DIjkstra计数思想
2. **洛谷 P1608** - 路径统计  
   * 推荐理由：带权图最短路计数，强化Floyd应用场景
3. **洛谷 P6181** - 乘车路线  
   * 推荐理由：变形最短路计数，学习状态转移扩展

---

#### **7. 学习心得与经验分享**
> **来自Ning_Mew的调试经验**：  
> *"我在第二测试点WA多次，最后发现未用long long存储cnt导致溢出"*  
> **Kay点评**：此教训极具代表性！**数据范围分析**是竞赛编码的关键前置步骤，尤其注意10¹⁰边界应使用long long（8字节）。

---

> 掌握Floyd的**动态规划本质**和**路径计数原理**，即解锁此类问题的核心。记住：算法学习如探险，每一步的思考都会点亮新路径！🚀

---
处理用时：119.41秒
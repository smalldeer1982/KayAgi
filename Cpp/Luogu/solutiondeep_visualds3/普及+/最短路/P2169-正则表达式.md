# 题目信息

# 正则表达式

## 题目背景

小Z童鞋一日意外的看到小X写了一个正则表达式的高级程序，这个正则表达式程序仅仅由字符“0”,“1”，“.”和“\*”构成，但是他能够匹配出所有在OJ上都AC的程序的核心代码！小Z大为颇感好奇，于是他决定入侵小X的电脑上去获得这个正则表达式的高级程序。


## 题目描述

在 Internet 网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在 $A$ 到 $B$ 的连接不一定存在 $B$ 到 $A$ 的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在 $A$ 到 $B$ 的连接的同时也存在 $B$ 到 $A$ 的连接的话，那么 $A$ 和 $B$ 实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为 $0$。

现在小 Z 告诉你整个网络的构成情况，他希望知道从他的电脑（编号为 $1$），到小 X 的电脑（编号为 $n$）所需要的最短传输时间。

## 说明/提示

- 对于  $40\%$ 的数据，$1\leq n\leq 10^3$, $1\leq m\leq 10^4$；
- 对于  $70\%$ 的数据，$1\leq n\leq 5 \times 10^3$， $1\leq m\leq 10^5$；
- 对于  $100\%$ 的数据，$1\leq n\leq 2 \times 10^5$， $1\leq m\leq 10^6$。

保证答案在 `int` 范围内。

## 样例 #1

### 输入

```
3 2
1 2 1
2 3 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5
1 2 1
2 3 6
3 4 1
4 2 1
3 5 2
```

### 输出

```
3```

# AI分析结果


### 💡 Kay的C++算法解析：正则表达式 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`强连通分量（SCC）` + `最短路算法`

🗣️ **初步分析**：
> 解决"正则表达式"这道题，关键在于理解**网络结构的拓扑特性**。想象城市地铁系统：每个强连通分量（SCC）如同一个地铁站内换乘区（站内换乘免费），不同SCC间的连接如同公交线路（需花费时间）。Tarjan算法就像高效的站务系统扫描仪，快速识别所有换乘区；Dijkstra则是精准的导航系统，计算最省时的公交路线组合。
> - **核心难点**：处理环状结构（SCC）的零权值特性与大规模图的高效计算
> - **算法流程**： 
>   1. **SCC扫描**：DFS遍历时记录`dfn/low`值，栈回溯标记连通块
>   2. **缩点建图**：将SCC压缩为超级节点，保留跨分量边权
>   3. **最短路计算**：在DAG上以SCC为节点跑Dijkstra
> - **可视化设计**：采用**地铁线路图**风格像素动画：
>   - SCC内节点显示为同色像素方块（闪烁提示零权值）
>   - 边权更新时显示公交动画与耗时数字气泡
>   - Dijkstra执行时用像素箭头高亮当前松弛节点

---

#### 2. 精选优质题解参考
**题解一（Diamiko）**
* **点评**：思路清晰展现SCC压缩与Dijkstra的完美结合。亮点在于：① SCC颜色标记逻辑简洁（`color[]`数组） ② 链式前向星重建图时精确过滤同分量边 ③ 堆优化Dijkstra复杂度稳定（O(ElogV)）。变量命名规范（如`belong[]`），边界处理完整（`INF`初始化），竞赛级实现可直接移植。

**题解二（subarude）**
* **点评**：创新性采用拓扑排序替代最短路算法。亮点在于：① 利用DAG无环特性实现O(V+E)线性DP ② 入度归零触发机制确保无后效性 ③ 手写栈避免递归爆栈风险。实践价值体现在处理稀疏图时效率显著优于Dijkstra。

**题解三（PrincessQi）**
* **点评**：极简实现典范（仅60行）。亮点：① 同步SCC标记与边权归零（`co[u]==co[v]?0:w`）避免二次建图 ② SPFA中直接操作原图结构。适合初学者理解核心思想，但需注意SPFA最坏复杂度O(VE)。

---

#### 3. 核心难点辨析与解题策略
1. **SCC的零权值处理**
   * **分析**：环内节点距离为0的本质是路径可无限重复。优质题解通过Tarjan的`low`值回溯精准划分SCC，缩点时自动消解环内边。
   * 💡 **学习笔记**：强连通分量是图论中的"原子结构"，内部可达性等价于完全连通图。

2. **大规模图的缩点建图**
   * **分析**：100万条边需高效过滤同分量边。`Diamiko`解法用`color[u]!=color[v]`判断，配合链式前向星达到O(m)重建复杂度。
   * 💡 **学习笔记**：缩点本质是图的同态映射，保留原图连通性但消除冗余结构。

3. **DAG上的最短路优化**
   * **分析**：拓扑序DP（`subarude`）省去堆维护开销，但依赖单源可达性；Dijkstra（`Diamiko`）通用性强但需堆优化。选择取决于图稀疏度。
   * 💡 **学习笔记**：无环图的最短路存在线性解法，这是DAG的特殊礼物。

### ✨ 解题技巧总结
- **环处理技巧**：SCC分解化环为点，将复杂约束转化为零权边
- **分层抽象法**：先拓扑重构（缩点），再应用标准算法（最短路）
- **边界防御**：初始化`INF=0x3f3f3f3f`兼具数值安全与效率（memset优化）
- **内存控制**：链式前向星替代邻接矩阵，空间复杂度从O(n²)降至O(n)

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e5+5, M=1e6+5, INF=0x3f3f3f3f;

struct Edge { int to, w; };
vector<Edge> G[N], newG[N]; // 原图/新图
int dfn[N], low[N], col[N], dis[N];
stack<int> stk;
bool instk[N];
int n, m, idx, scc_cnt;

void tarjan(int u) {
    dfn[u] = low[u] = ++idx;
    stk.push(u); instk[u] = true;
    for (auto &e : G[u]) {
        int v = e.to;
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (instk[v]) low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        scc_cnt++;
        while (true) {
            int x = stk.top(); stk.pop();
            instk[x] = false;
            col[x] = scc_cnt;
            if (x == u) break;
        }
    }
}

void dijkstra(int s) {
    priority_queue<pair<int, int>> pq;
    memset(dis, INF, sizeof(dis));
    dis[s] = 0; pq.push({0, s});
    while (!pq.empty()) {
        int u = pq.top().second, d = -pq.top().first; pq.pop();
        if (d != dis[u]) continue;
        for (auto &e : newG[u]) {
            int v = e.to, w = e.w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                pq.push({-dis[v], v});
            }
        }
    }
}

int main() {
    cin >> n >> m;
    while (m--) {
        int u, v, w; cin >> u >> v >> w;
        G[u].push_back({v, w});
    }
    // SCC缩点
    for (int i=1; i<=n; i++) if (!dfn[i]) tarjan(i);
    // 建新图
    for (int u=1; u<=n; u++) {
        for (auto &e : G[u]) {
            int v = e.to;
            if (col[u] != col[v]) 
                newG[col[u]].push_back({col[v], e.w});
        }
    }
    dijkstra(col[1]);
    cout << dis[col[n]];
}
```

**题解一（Diamiko）核心代码**
```cpp
// 关键变量：node[i].color 存储SCC编号
void Tarjan(int u) {
    low[u] = dfn[u] = ++deep;
    stk.push(u); vis[u] = 1;
    for (int e=head[u]; e; e=edge[e].next) {
        int v = edge[e].to;
        if (!dfn[v]) Tarjan(v), low[u] = min(low[u], low[v]);
        else if (vis[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) { // SCC回溯
        color_cnt++;
        while (stk.top() != u) {
            col[stk.top()] = color_cnt;
            vis[stk.top()] = 0; stk.pop();
        }
        // u出栈处理...
    }
}
```
* **亮点**：双数组`dfn/low`精准控制SCC回溯点
* **学习笔记**：栈与`vis`数组的配合确保每个节点只归属一个SCC

---

#### 5. 算法可视化：像素动画演示
**主题**：`像素地铁大冒险`  
**核心演示**：Tarjan的DFS森林生成 + Dijkstra节点松弛  

1. **像素场景设计**
   - 节点：8-bit像素方块（不同SCC不同色系）
   - 边：LED灯带（红色表探索中，绿色表已固定）
   - SCC区域：同色方块闪烁+波纹特效

2. **关键动画帧**
   - **Tarjan阶段**：
     - DFS深入时显示像素隧道动画
     - `low`值更新时触发黄色闪光
     - SCC形成时像素方块爆炸重组
   - **Dijkstra阶段**：
     - 优先队列可视化（像素堆结构）
     - 松弛操作：灯带绿色波纹传递 + 音效提示
     - 路径锁定：像素方块变为地标建筑

3. **交互控制面板**
   - 速度滑块：调节单步/自动播放速度
   - 模式切换：Tarjan/Dijkstra双模式对比
   - 音效系统：
     * `叮`：节点加入SCC
     * `嘟~哒`：边被松弛
     * 胜利旋律：到达终点

---

#### 6. 拓展练习与相似问题
**通用技巧迁移**  
SCC缩点技术适用于：  
1. 环约束化简（如P3387 缩点）  
2. 2-SAT问题构图（如P4782 2-SAT）  
3. 网络流中的分量压缩（如P1231 教辅的组成）

**洛谷推荐**  
1. **P3387** - 缩点  
   → 巩固SCC基础应用，体验点权转化技巧  
2. **P4779** - 单源最短路径（标准版）  
   → 强化Dijkstra在常规图的实现  
3. **P6348** - 道路重建  
   → 学习缩点后在DAG上DP的进阶应用

---

#### 7. 学习心得与经验分享
> **参考经验**：  
> _"调试时发现SCC编号与点映射错误，最终通过打印中间状态解决"_  
> **（Diamiko题解评论区）**  
>
> **点评**：  
> 映射错误是缩点算法的常见陷阱。Kay建议：  
> 1. 预处理验证SCC划分正确性（如打印`color[]`）  
> 2. 重建图时添加`if(col[u]!=col[v])`防御断言  
> 3. 终点特判：当起点终点同属SCC时直接输出0  

---

通过本指南，你已掌握图论问题的核心拆解技巧：拓扑化简→标准算法应用。下次遇到环约束或大规模图问题，记得举起SCC这把瑞士军刀！💪

---
处理用时：136.64秒
# 题目信息

# 逃离僵尸岛

## 题目描述

小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。


该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。


其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。

小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。


小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。

输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2681.png) 

对于 $20\%$ 数据，$N\le 50$。

对于 $100\%$ 数据，$2\le N\le 10^5$，$1\le M\le 2\times 10^5$，$0\le K\le N - 2$，$0\le S\le 10^5$，$1\le P< Q\le 10^5$。


## 样例 #1

### 输入

```
13 21 1 1
1000 6000
7
1 2
3 7
2 4
5 8
8 9
2 5
3 4
4 7
9 10
10 11
5 9
7 12
3 6
4 5
1 3
11 12
6 7
8 11
6 13
7 8
12 13```

### 输出

```
11000```

# AI分析结果


# 💡 Kay的C++算法解析：逃离僵尸岛 深入学习指南 💡

**题目解读**：小a需要从1号城市逃到N号城市，途中需在非1/N城市住宿。城市分为安全（住宿费P元）和危险（住宿费Q元，P<Q）两类。危险城市定义为到任意僵尸城距离≤S的城市。求最小住宿总费用。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（多源BFS+最短路）`

🗣️ **初步分析**：
> 本题如同在僵尸危机地图上规划最省钱的逃生路线。核心思路分两步：
> 1. **标记危险区**：将所有僵尸城作为起点进行多源BFS，标记距离≤S的城市为危险区（类似"僵尸辐射波"扩散）
> 2. **计算最小花费**：构建新图，边权=目标城市的住宿费（安全城P元，危险城Q元），用Dijkstra计算最短路
> 
> **可视化设计**：像素风格地图中，僵尸城为红色方块，危险区为橙色，安全区为绿色。BFS扩散时显示"辐射波"动画，Dijkstra执行时显示小a的移动路径和金币花费计数。音效设计：僵尸嘶吼（BFS启动）、金币声（花费累加）、胜利音乐（到达终点）。

---

## 2. 精选优质题解参考

### 题解一（作者：浮梦若生）
* **点评**：思路清晰严谨，采用BFS标记危险城市+堆优化Dijkstra求最短路。亮点在于：
  - 使用`dis`数组存储到僵尸城距离，逻辑直白
  - 点权处理巧妙：直接根据危险标记设置点权
  - 堆优化Dijkstra保证效率（O(M log N)）
  - 边界处理完善（1和N点权为0）

### 题解二（作者：顾z）
* **点评**：教学价值突出，代码模块化设计优秀：
  - BFS与Dijkstra分离，结构清晰
  - 使用`safe`数组三重状态（-1:僵尸城, 0:安全, 1:危险）
  - 详细注释解释状态含义
  - 鲁棒性强（极大值设为0x7f7f7f7f7f7f）

### 题解三（作者：fyfy）
* **点评**：创新性引入虚拟点简化问题：
  - 创建虚拟点0连接所有僵尸城，单次SPFA完成距离计算
  - 边权动态设置（根据目标城市状态）
  - 代码变量命名规范（`dgs`表危险）
  - 注意long long防溢出

---

## 3. 核心难点辨析与解题策略

1. **难点：多源BFS的实现**
   * **分析**：需同时从K个起点扩散，传统BFS需改造。优质解法使用队列初始化时压入所有僵尸城，用`dis`数组记录步数
   * 💡 **学习笔记**：多源BFS的关键是初始化队列时加入所有起点

2. **难点：点权转边权**
   * **分析**：住宿费是点权但最短路算边权。解法分两类：
     - 拆边法：边(u,v)的权值设为v的点权
     - 预处理法：Dijkstra松弛时 `dis[v] = dis[u] + cost[v]`
   * 💡 **学习笔记**：点权问题可通过"入边继承点权"转为边权

3. **难点：终点特殊处理**
   * **分析**：终点N的住宿费应为0但可能被BFS标记为危险。解法显式设置`cost[1]=cost[N]=0`
   * 💡 **学习笔记**：边界条件需在算法结束后二次校验

### ✨ 解题技巧总结
- **分层处理**：先BFS标记再最短路，降低问题复杂度
- **虚点技巧**：创建虚拟节点简化多源问题（如题解3的虚点0）
- **点权转化**：Dijkstra松弛时直接加目标点权
- **防御性编程**：僵尸城不可达处理（设极大值或跳过）

---

## 4. C++核心代码实现赏析

### 通用核心实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=1e5+5;
const LL INF=1e15;

vector<int> G[N];  // 邻接表
LL cost[N];        // 每个城市的住宿费
int dis[N];         // 距离僵尸城的最短距离
bool zombie[N];     // 是否为僵尸城

int main() {
    int n,m,k,s,P,Q; 
    cin >> n >> m >> k >> s >> P >> Q;
    
    // 初始化
    queue<int> q;
    memset(dis, -1, sizeof(dis));
    while(k--) {
        int z; cin >> z;
        zombie[z] = true;
        q.push(z);
        dis[z] = 0;
    }
    
    // 建图
    while(m--) {
        int u,v; cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    
    // 多源BFS标记危险城市
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : G[u]) {
            if(dis[v] == -1) {
                dis[v] = dis[u] + 1;
                if(dis[v] < s) q.push(v);
            }
        }
    }
    
    // 设置住宿费
    for(int i=1; i<=n; i++) {
        if(zombie[i]) cost[i] = INF;  // 僵尸城不可达
        else if(dis[i] <= s) cost[i] = Q;
        else cost[i] = P;
    }
    cost[1] = cost[n] = 0;  // 起点终点免费
    
    // Dijkstra求最短路
    priority_queue<pair<LL,int>> pq;
    vector<LL> dist(n+1, INF);
    dist[1] = 0;
    pq.push({0, 1});
    
    while(!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if(-d != dist[u]) continue;
        for(int v : G[u]) {
            LL nd = dist[u] + cost[v];
            if(nd < dist[v]) {
                dist[v] = nd;
                pq.push({-nd, v});
            }
        }
    }
    cout << dist[n] << endl;
    return 0;
}
```
**代码解读概要**：
1. 多源BFS计算每个城市到最近僵尸城的距离
2. 根据距离设置点权（安全城P，危险城Q，僵尸城INF）
3. Dijkstra计算路径时，边权=目标城市的点权
4. 起点终点特殊处理（住宿费0）

### 题解片段赏析

**题解一（浮梦若生）核心片段**：
```cpp
void BFS() {
    while (!q.empty()) {
        int u = q.front();
        if (sa[u] == 0) sa[u] = 1; // 标记危险
        q.pop();
        if (d[u] == s) continue;  // 超过S层停止
        for (int v : G[u]) {
            if (!vis[v] && d[v] > d[u] + 1) {
                d[v] = d[u] + 1;
                vis[v] = true;
                q.push(v);
            }
        }
    }
}
```
**亮点**：显式控制BFS层数  
**学习笔记**：`d[u]==s`时停止扩散，精确控制危险范围

**题解二（顾z）状态处理**：
```cpp
enum { SAFE = 0, DANGER = 1, ZOMBIE = -1 };
// BFS后设置点权
for (int i = 1; i <= n; i++) {
    if (safe[i] == ZOMBIE) continue; // 跳过僵尸城
    else if (safe[i] == DANGER) cost = Q;
    else cost = P;
}
```
**亮点**：枚举状态提升可读性  
**学习笔记**：用枚举常量替代魔术数字

**题解三（fyfy）虚点技巧**：
```cpp
// 连接虚点0到所有僵尸城
for (int i = 1; i <= k; i++) 
    add_edge(0, zombie[i]); 

// SPFA计算距离
void spfa(int start) {
    // ... 从虚点0开始计算
}
```
**亮点**：虚点统一多源  
**学习笔记**：减少BFS次数至1次

---

## 5. 算法可视化：像素动画演示

**主题**："像素僵尸岛逃生"（复古RPG风格）

**核心演示**：
1. **地图初始化**：10x10像素网格（FC风格）
   - 僵尸城：红色闪烁方块（8x8像素）
   - 普通城：灰色方块
   - 起点(1)：绿色旗帜，终点(N)：蓝色旗帜

2. **多源BFS扩散**（危险区标记）：
   ```mermaid
   graph LR
   Z[僵尸城] -->|辐射波| D1[距离1]
   D1 -->|辐射波| D2[距离2]
   ```
   - 动态效果：红色波纹从僵尸城向外扩散（每帧扩散1距离）
   - 危险区染色：被波及的方块渐变为橙色
   - 音效：低频嗡鸣声（随距离衰减）

3. **Dijkstra执行过程**：
   ```mermaid
   graph LR
   起点 --P/Q元--> A --P/Q元--> B --0元--> 终点
   ```
   - 可视化元素：
     - 小a像素角色沿路径移动
     - 经过城市时显示住宿费（金币-数字特效）
     - 优先队列可视化（右侧显示待处理节点）
   - 交互控制：
     - 速度滑块：调节动画速度
     - 单步执行：观察松弛操作
     - 路径高亮：最终路径显示为金色

**技术实现**：
- 颜色方案：僵尸红(#FF0000)，危险橙(#FFA500)，安全绿(#00FF00)
- Canvas绘制逻辑：用`fillRect`绘制网格，`arc`绘制辐射波
- 音效触发：Web Audio API播放16-bit音效（BFS扩散声、金币声）

---

## 6. 拓展练习与相似问题

### 通用思路迁移
多源BFS+最短路组合适用于：
1. 多起点传播问题（火灾蔓延、病毒传播）
2. 分层图最短路（不同状态不同边权）
3. 点权转边权优化

### 洛谷推荐
1. **P1144 最短路计数**  
   🗣️ 基础BFS应用，巩固图论基础

2. **P1462 通往奥格瑞玛的道路**  
   🗣️ 点权最短路变形，需结合二分答案

3. **P1948 电话线**  
   🗣️ 分层图最短路经典问题，提升建模能力

---

> 可视化提示：点击下方动画控制台体验交互演示  
> [像素动画] 僵尸岛逃生模拟器 (虚拟演示)  
> 按F键加速 - 按D键单步执行 - 按R键重置

通过本指南，相信大家已掌握"僵尸岛"问题的核心解法。记住：图论的关键在于状态定义和转化！继续加油！💪

---
处理用时：120.53秒
# 题目信息

# [NERC 2021] Interactive Treasure Hunt

## 题目描述

**这是一道交互题。**

有一个 $n \times m$ 的网格。两个宝箱被埋藏在网格的两个不同单元格中。你的任务是找到这两个宝箱。你可以进行两种操作：

1. **DIG** $r$ $c$：尝试在单元格 $(r, c)$ 挖掘宝藏。交互器会告诉你是否找到了宝藏。
2. **SCAN** $r$ $c$：从单元格 $(r, c)$ 进行扫描。该操作的结果是从 $(r, c)$ 到两个宝藏所在单元格的曼哈顿距离之和。曼哈顿距离的计算公式为 $|r_1 - r_2| + |c_1 - c_2|$。

你需要在最多 7 次操作内找到两个宝藏（包括 **DIG** 和 **SCAN** 操作）。为了通过测试，你必须在两个藏有宝藏的单元格中各调用至少一次 **DIG** 操作。

### 交互协议

你的程序需要在一轮运行中处理多个测试用例。首先，测试系统会给出 $t$ —— 测试用例的数量（$1 \le t \le 100$）。然后，依次处理 $t$ 个测试用例。

在每个测试用例中，你的程序首先需要读取两个整数 $n$ 和 $m$（$2 \le n, m \le 16$）。

然后，你的程序可以发起以下两种查询：

1. **DIG** $r$ $c$（$1 \le r \le n$；$1 \le c \le m$）。交互器会返回整数 $1$（如果找到了宝藏）或 $0$（如果未找到）。如果你多次在同一个单元格挖掘，由于宝藏已被取走，结果将始终为 $0$。
2. **SCAN** $r$ $c$（$1 \le r \le n$；$1 \le c \le m$）。交互器会返回一个整数，表示从 $(r, c)$ 到两个宝藏所在单元格的曼哈顿距离之和。即使你已经找到一个宝藏，该操作仍然会计算两个宝藏的距离之和。

当你找到两个宝藏（即通过 **DIG** 操作两次获得 $1$ 的响应）后，你的程序应继续处理下一个测试用例，或者如果是最后一个测试用例则退出。


## 说明/提示

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
1
2 3

1

1

3

0

1```

### 输出

```


SCAN 1 2

DIG 1 2

SCAN 2 2

DIG 1 1

DIG 1 3```

# AI分析结果


### 💡 Kay的C++算法解析：Interactive Treasure Hunt 深入学习指南 💡

**<introduction>**  
今天我们来分析一道有趣的交互题——Interactive Treasure Hunt。题目要求在一个`n×m`网格中找到两个宝藏的位置，通过**DIG**（挖掘）和**SCAN**（扫描距离和）两种操作，且操作次数不超过7次。本指南将带你深入理解数学推导与交互策略的结合运用。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学推导`（曼哈顿距离性质） + `交互策略设计`

🗣️ **初步分析**：  
> 这道题的核心在于**利用曼哈顿距离的线性性质建立方程组**。想象你在玩一个像素地牢探险游戏：通过扫描角落获取全局坐标和（如地图边界探针），再扫描中点获取坐标差（如雷达探测波），最终精确锁定宝藏位置。  
> - **核心流程**：  
>   1. 用两次`SCAN`在网格角落获取距离和方程  
>   2. 解方程得到宝藏坐标之和（`sumx`, `sumy`）  
>   3. 用两次`SCAN`在坐标中点获取坐标差（`dx`, `dy`）  
>   4. 解出具体坐标并验证  
> - **可视化设计**：  
>   将用8位像素风格展示网格，宝藏用闪烁宝箱表示，扫描波以脉冲动画扩散，距离和实时显示。关键步骤触发复古音效（如扫描"嘀"声，挖掘"叮当"声）。

---

## 2. 精选优质题解参考

<eval_intro>  
以下题解在思路清晰性、数学严谨性和代码简洁性上表现优异（评分5星）：

**题解（作者：_O_v_O_）**  
* **点评**：  
  思路直击本质——通过曼哈顿距离的线性方程组避免枚举。亮点在于：  
  - **数学建模**：用4次`SCAN`构建4个方程，完美消去绝对值（假设`x1≤x2, y1≤y2`）  
  - **代码简洁**：变量命名清晰（`sumx`, `sumy`, `dx`, `dy`），边界处理严谨  
  - **交互优化**：操作次数严格≤7（4次`SCAN`+3次`DIG`)  
  - **实践价值**：可直接用于竞赛，推导过程体现数学思维的核心作用

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题需突破三大难点：

1.  **难点1：如何建立曼哈顿距离方程组？**  
    * **分析**：  
      曼哈顿距离`|r1-r2|+|c1-c2|`在边界点可线性化。优质题解选择`(1,1)`和`(1,m)`扫描：  
      - `SCAN(1,1) → x1+y1+x2+y2 = a+4`  
      - `SCAN(1,m) → x1+x2-y1-y2 = b+2-2m`  
      联立解得`sumx = x1+x2`, `sumy = y1+y2`  
    * 💡 **学习笔记**：边界扫描是消除绝对值的钥匙。

2.  **难点2：如何获取坐标差而不增加操作次数？**  
    * **分析**：  
      在坐标中点`(1,sumy/2)`和`(sumx/2,1)`扫描：  
      - 中点性质保证`|y1-mid|+|y2-mid| = y2-y1`（y1≤y2时）  
      - 同理得x方向差值，结合`sumx`、`sumy`解出`dx`、`dy`  
    * 💡 **学习笔记**：中点扫描将二维问题降为一维差分。

3.  **难点3：如何处理坐标推导的假设前提？**  
    * **分析**：  
      假设`x1≤x2, y1≤y2`可能不覆盖所有情况。题解用分支验证：  
      - 若`DIG`首个坐标失败，则尝试交叉坐标组合  
      - 数学保证解存在，最多3次`DIG`完成  
    * 💡 **学习笔记**：假设需数学验证，分支处理增强鲁棒性。

### ✨ 解题技巧总结
- **技巧1：数学建模优先**——将交互问题转化为方程组求解  
- **技巧2：边界值扫描**——利用网格边界简化绝对值  
- **技巧3：对称性假设**——通过合理假设降维，辅以验证  

---

## 4. C++核心代码实现赏析

<code_intro_overall>  
以下是综合题解思路的通用实现：

**本题通用核心C++实现参考**  
* **说明**：基于数学推导的完整交互框架，含关键注释。
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

int main() {
    int T; cin >> T;
    while (T--) {
        int n, m; cin >> n >> m;

        // 步骤1：边界扫描建方程
        cout << "SCAN 1 1" << endl;
        int a; cin >> a;
        cout << "SCAN 1 " << m << endl;
        int b; cin >> b;

        // 解坐标和：sumx = x1+x2, sumy = y1+y2
        int sumx = (a + b) / 2 + 3 - m;
        int sumy = (a - b) / 2 + 1 + m;

        // 步骤2：中点扫描求坐标差
        cout << "SCAN 1 " << sumy / 2 << endl;
        int c; cin >> c;
        cout << "SCAN " << sumx / 2 << " 1" << endl;
        int d; cin >> d;

        // 解坐标差：dx = x2-x1, dy = y2-y1
        c += 2 - sumx; // 调整得dy
        d += 2 - sumy; // 调整得dx
        int x1 = (sumx + d) / 2, x2 = sumx - x1;
        int y1 = (sumy + c) / 2, y2 = sumy - y1;

        // 步骤3：验证坐标
        cout << "DIG " << x1 << " " << y1 << endl;
        int res; cin >> res;
        if (res) {
            cout << "DIG " << x2 << " " << y2 << endl;
            cin >> res;
        } else {
            cout << "DIG " << x1 << " " << y2 << endl;
            cin >> res;
            cout << "DIG " << x2 << " " << y1 << endl;
            cin >> res;
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 读测试用例数`T`  
  2. 四次`SCAN`获取参数并解方程  
  3. 计算候选坐标并分支验证  
  4. 严格满足操作次数限制  

---
<code_intro_selected>  
**题解片段精析**：

**题解（作者：_O_v_O_）**  
* **亮点**：方程调整与坐标解耦的优雅实现  
* **核心代码片段**：  
  ```cpp
  c += 2, c -= sumx;  // 从扫描值提取dy
  d += 2, d -= sumy;  // 从扫描值提取dx
  int x1 = (d + sumx) / 2, x2 = sumx - x1;
  int y1 = (c + sumy) / 2, y2 = sumy - y1;
  ```
* **代码解读**：  
  > `c = c_scan + 2 - sumx`实质是`dy = y2 - y1`的变形，通过整数运算避免浮点误差。  
  > `(d+sumx)/2`巧用整除性质直接得`x2`（较大x），`sumx - x1`得`x1`（较小x），y方向同理。  
* 💡 **学习笔记**：整数运算中，`(A+B)/2`和`A-(A+B)/2`可安全获取有序对。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>  
**主题**：8位像素风《宝藏猎人》动画，融合《塞尔达》式探索元素  

**设计思路**：  
- **复古UI**：FC红白机色调（4色：空地/障碍/宝藏/扫描波）  
- **音效增强**：扫描"嘀"声、挖掘"叮当"声、成功音效强化记忆  
- **AI演示模式**：自动播放解题流程，像观看游戏速通  

**动画流程**：  
1. **场景初始化**  
   - 网格绘制：16×16像素块（棕色空地，灰色边界）  
   - 控制面板：开始/步进/速度滑块（调速范围0.5x-3x）  
   - 背景：低分辨率星空循环图，8-bit BGM  

2. **扫描阶段（关键帧）**  
   ```mermaid
   sequenceDiagram
      玩家->>+网格： SCAN(1,1)
      网格-->>-玩家： 显示脉冲动画(蓝色波纹)
      玩家->>+日志： 显示方程: x1+y1+x2+y2=a+4
      玩家->>+网格： SCAN(1,m)
      网格-->>-玩家： 脉冲动画(红色波纹)
      玩家->>+日志： 显示方程: x1+x2-y1-y2=b+2-2m
   ```  
   - 每次扫描：触发像素脉冲扩散动画，目标单元格高亮黄色  
   - 音效：扫描波"嘀"声（Web Audio API生成方波）  

3. **计算阶段**  
   - 动态显示公式推导：  
     `sumx = (a+b)/2+3-m → 数值浮动显示`  
   - 坐标中点标记：十字光标闪烁（配计算音效）  

4. **挖掘验证**  
   - 首次`DIG`：宝箱开启动画（成功：金币飞溅+胜利音效；失败：灰色X标记）  
   - 分支路径：不同结果触发不同颜色提示（绿/红光）  

5. **交互控制**  
   - **单步执行**：按帧暂停，显示当前变量值  
   - **AI模式**：自动完成全流程（速度可调）  
   - **重置**：网格复位，音效重置  

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
**核心技巧迁移**：  
曼哈顿距离方程建模可扩展至：  
1. 隐藏点定位（如雷达系统）  
2. 对称图形重建（如像素画补全）  
3. 多目标路径规划（如机器人探索）  

**洛谷推荐**：  
1. **P1666** [Interactive Weighing](https://www.luogu.com.cn/problem/P1666)  
   → 同类交互题，强化权重方程思维  
2. **P7514** [网格图](https://www.luogu.com.cn/problem/P7514)  
   → 曼哈顿距离性质进阶应用  
3. **P6189** [找宝藏](https://www.luogu.com.cn/problem/P6189)  
   → 三维曼哈顿距离扩展挑战  

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>  
本次题解未包含作者调试心得。Kay建议：  
> 交互题的核心是**预先证明数学可行性**，再转化为代码。动手前在纸上演算方程可避免80%的边界错误。

---

<conclusion>  
通过本次分析，我们深入理解了曼哈顿距离的交互应用。记住：好的算法=数学模型+严谨实现+可视化验证！下次探险再见！⚔️✨

---
处理用时：288.06秒
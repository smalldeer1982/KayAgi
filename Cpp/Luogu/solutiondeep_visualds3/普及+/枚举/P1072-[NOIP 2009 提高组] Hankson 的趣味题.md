# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果



---
# 💡 Kay的C++算法解析：Hankson的趣味题 深入学习指南 💡

<introduction>
今天我们来一起分析“Hankson的趣味题”这道C++编程题。这道题结合了最大公约数（gcd）和最小公倍数（lcm）的数学性质，需要我们通过巧妙的枚举和验证找到符合条件的正整数x的个数。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（gcd与lcm应用） + 枚举（因数枚举）`

🗣️ **初步分析**：
解决这道题的关键在于利用两个条件缩小x的可能范围，并通过高效枚举验证符合条件的x。简单来说，我们可以把问题拆解为：  
- **条件1**：x与a0的最大公约数是a1 → 这意味着x必须是a1的倍数，且x/a1与a0/a1互质（即gcd(x/a1, a0/a1)=1）。  
- **条件2**：x与b0的最小公倍数是b1 → 这意味着x必须是b1的因数（因为lcm(x, b0)=b1，所以x必须能整除b1）。  

结合这两个条件，x的可能取值只能是b1的因数，且是a1的倍数。因此，我们可以通过枚举b1的所有因数，逐一验证是否满足条件，从而统计符合条件的x的个数。  

核心难点在于如何高效枚举b1的因数（避免重复计数），以及快速验证每个因数是否满足两个条件。优质题解通常通过枚举到√b1的方式，成对获取因数（如i和b1/i），并通过gcd计算快速验证。  

可视化设计上，我们可以设计一个8位像素风格的动画：屏幕中央显示b1的因数列表，用像素方块表示每个因数；当枚举到某个因数时，方块高亮并显示其与a0的gcd、与b0的lcm计算过程；若满足条件，方块变为绿色并计数，否则变为红色。过程中伴随“叮”的音效（满足条件时）或“滴”的音效（不满足时），增强交互感。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：作者zzlzk（赞468）**  
* **点评**：此题解思路清晰，直接抓住x是b1因数的核心性质，通过枚举√b1的因数对（i和b1/i）进行验证。代码简洁高效，变量命名直观（如用p=a0/a1，q=b1/b0简化计算），边界处理（如i和b1/i是否相等的判断）严谨。从实践角度看，代码可直接用于竞赛，时间复杂度为O(√b1)，能高效处理题目数据范围。

**题解二：作者cyh_toby（赞5）**  
* **点评**：此题解逻辑直白，通过枚举b1的因数并验证两个条件，代码结构工整（如将gcd和lcm计算单独封装）。特别地，题解中提到“x是b1的因数”这一关键点，帮助学习者快速定位枚举范围，适合初学者理解。

**题解三：作者qhr2023（赞1）**  
* **点评**：此题解详细解释了lcm的计算原理（lcm(a,b)=a*b/gcd(a,b)），并通过枚举√b1的因数对，避免重复计数。代码中使用`ans += check(i) + check(b1/i) - (i==b1/i && check(i))`巧妙处理平方因数的情况，体现了对边界条件的细致考虑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何确定x的可能范围？**  
    * **分析**：由条件2（lcm(x, b0)=b1）可知，x必须是b1的因数。因此，x的可能取值只能是b1的所有因数。这一步将x的范围从1到b1缩小到b1的因数集合，大幅减少枚举量。  
    * 💡 **学习笔记**：利用数学性质（如lcm的定义）缩小枚举范围是解题的关键。

2.  **关键点2：如何高效枚举b1的因数？**  
    * **分析**：枚举到√b1即可，因为因数是成对出现的（如i和b1/i）。对于每个i，若i是b1的因数，则b1/i也是因数。需要注意i和b1/i相等的情况（即b1是平方数），避免重复计数。  
    * 💡 **学习笔记**：枚举因数时，只需要枚举到√b1，成对处理因数，时间复杂度可降至O(√b1)。

3.  **关键点3：如何验证x是否满足条件？**  
    * **分析**：验证两个条件：  
      - gcd(x, a0) == a1：需确保x是a1的倍数（否则gcd不可能等于a1），且x/a1与a0/a1互质。  
      - lcm(x, b0) == b1：需确保x*b0/gcd(x, b0) == b1（注意先除后乘避免溢出）。  
    * 💡 **学习笔记**：验证时先检查x是否是a1的倍数，可快速排除无效情况，提升效率。

### ✨ 解题技巧总结
<summary_best_practices>
- **因数枚举技巧**：枚举到√b1，成对处理因数，避免重复。  
- **条件验证顺序**：先检查x是否是a1的倍数，再验证gcd和lcm，减少无效计算。  
- **溢出处理**：计算lcm时，先除后乘（如x*b0/gcd(x, b0)），避免整数溢出。  
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了多个优质题解的思路，通过枚举b1的因数并验证条件，统计符合条件的x的个数。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cmath>
    using namespace std;

    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    int lcm(int a, int b) {
        return a / gcd(a, b) * b; // 先除后乘避免溢出
    }

    int main() {
        int T;
        cin >> T;
        while (T--) {
            int a0, a1, b0, b1;
            cin >> a0 >> a1 >> b0 >> b1;
            int ans = 0;

            // 枚举b1的因数，到sqrt(b1)为止
            for (int i = 1; i <= sqrt(b1); ++i) {
                if (b1 % i == 0) {
                    // 检查因数i
                    if (i % a1 == 0 && gcd(i, a0) == a1 && lcm(i, b0) == b1) {
                        ans++;
                    }
                    // 检查因数b1/i（i≠b1/i时）
                    int j = b1 / i;
                    if (i != j) {
                        if (j % a1 == 0 && gcd(j, a0) == a1 && lcm(j, b0) == b1) {
                            ans++;
                        }
                    }
                }
            }
            cout << ans << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入数据，然后通过循环枚举b1的因数（到√b1为止）。对于每个因数i，检查其是否是a1的倍数，并验证gcd(i, a0)是否等于a1、lcm(i, b0)是否等于b1。同时处理因数对（i和b1/i），避免重复计数。最终输出符合条件的x的个数。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者zzlzk**  
* **亮点**：通过预处理p=a0/a1、q=b1/b0，简化gcd的验证逻辑（gcd(x/a1, p)==1）。  
* **核心代码片段**：
    ```cpp
    int p = a0 / a1, q = b1 / b0;
    for (int x = 1; x * x <= b1; x++) {
        if (b1 % x == 0) {
            if (x % a1 == 0 && gcd(x / a1, p) == 1 && gcd(q, b1 / x) == 1) ans++;
            int y = b1 / x;
            if (x != y && y % a1 == 0 && gcd(y / a1, p) == 1 && gcd(q, b1 / y) == 1) ans++;
        }
    }
    ```
* **代码解读**：  
  这段代码通过将a0/a1记为p，b1/b0记为q，将条件转化为x/a1与p互质（gcd(x/a1, p)==1），以及b1/x与q互质（gcd(q, b1/x)==1）。这种转化简化了条件验证的逻辑，减少了计算量。  
* 💡 **学习笔记**：通过数学变形（如将a0和a1的关系转化为p），可以简化条件验证的步骤，提升代码效率。

**题解二：作者qhr2023**  
* **亮点**：使用`ans += check(i) + check(b1/i) - (i==b1/i && check(i))`巧妙处理平方因数的重复计数问题。  
* **核心代码片段**：
    ```cpp
    bool check(long long x) {
        return (__gcd(x, a) == a1 && x * b / __gcd(x, b) == b1);
    }
    // 主循环中：
    for (long long i = 1; i * i <= b1; i++) {
        if (b1 % i == 0) {
            ans += check(i) + check(b1 / i) - (i == b1 / i && check(i));
        }
    }
    ```
* **代码解读**：  
  `check`函数封装了条件验证逻辑，主循环中通过`ans += check(i) + check(b1/i)`统计两个因数的贡献，再减去i和b1/i相等时的重复计数（`i == b1/i && check(i)`）。这种写法简洁且不易出错。  
* 💡 **学习笔记**：封装验证逻辑（如`check`函数）可以提升代码的可读性和可维护性。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“枚举因数并验证条件”的过程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素因数大冒险`  
  * **核心演示内容**：展示枚举b1的因数、验证每个因数是否满足条件，并统计符合条件的x的个数。  

  * **设计思路简述**：  
    采用FC红白机风格的像素画面（8色调色板，如经典的红白蓝绿），通过动态展示因数的枚举过程和条件验证结果，帮助学习者直观理解算法逻辑。例如，当枚举到因数i时，像素方块会高亮并显示其与a0的gcd、与b0的lcm计算过程；若满足条件，方块变为绿色并计数，否则变为红色。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        屏幕分为左右两部分：左侧是“因数枚举区”（显示b1的因数列表，用像素方块排列），右侧是“条件验证区”（显示当前因数的gcd和lcm计算结果）。顶部有控制面板（开始/暂停、单步、重置按钮，速度滑块）。

    2.  **因数枚举**：  
        从i=1开始，逐步增加到√b1。每枚举一个i，若b1%i==0，则生成两个因数方块（i和b1/i），用不同颜色（如蓝色）表示。若i==b1/i（平方因数），则只生成一个方块。

    3.  **条件验证**：  
        对每个因数方块，触发验证动画：方块移动到验证区，显示gcd(x, a0)和lcm(x, b0)的计算过程（如数字逐个弹出）。若结果等于a1和b1，方块变为绿色并播放“叮”音效；否则变为红色并播放“滴”音效。

    4.  **计数统计**：  
        屏幕顶部显示当前符合条件的x的个数（ans），每验证一个绿色方块，ans加1并伴随数字放大动画。

    5.  **AI自动演示**：  
        点击“AI演示”按钮，算法自动快速执行，展示所有因数的验证过程，学习者可观察整体流程。

  * **旁白提示**：  
    - “现在枚举因数i=3，检查是否满足条件……”  
    - “看！gcd(3, a0)=a1，lcm(3, b0)=b1，符合条件，计数加1！”  
    - “因数i和b1/i是成对出现的，所以我们只需要枚举到√b1哦～”

<visualization_conclusion>
通过这样一个融合像素艺术和交互的动画，我们不仅能清晰看到枚举和验证的每一步，还能在轻松的氛围中理解算法的核心逻辑。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“利用数学性质缩小枚举范围，再通过枚举验证条件”。这种思路可迁移到其他涉及gcd、lcm或因数的问题中，例如：  
    - 求两个数的公因数个数；  
    - 寻找满足特定gcd/lcm条件的数对；  
    - 分解质因数后统计符合条件的组合。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1029** - 最大公约数和最小公倍数问题  
        * 🗣️ **推荐理由**：直接考察gcd和lcm的关系，需要枚举可能的数对并验证条件，与本题思路类似。  
    2.  **洛谷 P1088** - 火星人  
        * 🗣️ **推荐理由**：通过枚举排列解决问题，训练枚举和条件验证的能力。  
    3.  **洛谷 P1100** - 高低位交换  
        * 🗣️ **推荐理由**：涉及因数分解和位运算，适合提升综合解题能力。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解中提到了调试时的经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自部分题解)**：“在枚举因数时，容易重复计数i和b1/i相等的情况（如b1=36时，i=6和b1/i=6），需要特判i==b1/i的情况，避免重复加1。”  

**点评**：这一经验提醒我们，在处理因数对时，必须注意平方因数的特殊情况。通过添加`if (i != j)`的判断，可以有效避免重复计数。这是枚举因数类问题中常见的边界条件，需要特别注意。

---

<conclusion>
本次关于“Hankson的趣味题”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解gcd、lcm的应用和因数枚举的技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：174.35秒
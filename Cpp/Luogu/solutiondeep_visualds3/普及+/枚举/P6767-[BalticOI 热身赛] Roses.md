# 题目信息

# [BalticOI 热身赛] Roses

## 题目背景

因为特殊原因，本题目另外 $24$ 组数据请在 [这里](https://www.luogu.com.cn/problem/U127462) 提交。

Valentine 是人赢。

## 题目描述

现在 Valentine 要给他的 $N$ 个妹子买玫瑰花，现在 Valentine 面前有两家店，每一家店有无数朵玫瑰花，但是他们按束卖。第一家店一束花里有 $A$ 朵，每一束花要用 $B$ 块钱。第二家店一束花里有 $C$ 朵，每一束花要用 $D$ 块钱。

求 Valentine 至少买 $N$ 朵花最少需要花多少钱。

至少可以这么理解，假如 $M>N$，但是买 $M$ 朵花的钱比买 $N$ 朵花的少，Valentine 就会买 $M$ 朵花，并把多出来的花给其他妹子，没错，Valentine 很花心。

## 说明/提示

#### 样例说明

对于样例 $1$，Valentine 可以选择在第二家店买 $2$ 束花。

对于样例 $2$，Valentine 可以选择在第一家店买 $1$ 束花，在第二家店买 $2$ 束花。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（20 pts）：$N,A,B,C,D \le 1000$。
- Subtask 2（80 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 10^{15}$，$1 \le A,B,C,D \le 10^5$，保证答案不超过 $10^{18}$。

#### 说明

翻译自 [BalticOI 2020 Day0 B Roses](http://www.boi2020.lv/data/tasks/en/day0/roses.pdf)。

与 BalticOI 2012 Day0 A 内容一致。

## 样例 #1

### 输入

```
5 1 4 3 6```

### 输出

```
12```

## 样例 #2

### 输入

```
22 2 3 10 14```

### 输出

```
31```

# AI分析结果



---
# 💡 Kay的C++算法解析：Roses 深入学习指南 💡

<introduction>
今天我们来一起分析“Roses”这道C++编程题。这道题需要计算购买至少N朵玫瑰花的最小花费，涉及性价比比较和高效枚举的技巧。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举优化与数学性质应用（枚举 + 数学）

🗣️ **初步分析**：
解决“Roses”这道题，关键在于通过比较两家店的性价比，确定主买的店，再通过数学优化限制枚举次数，避免超时。简单来说，就像买奶茶时，先选单价更低的品牌，再考虑另一个品牌的组合购买是否更划算。

在本题中，我们需要：
- **比较性价比**：计算两家店每朵花的单价（`b/a`和`d/c`），将性价比更高的店作为主买对象。
- **枚举次优店的购买次数**：由于直接枚举所有可能会超时，利用`gcd(a,c)`确定枚举上限（最多枚举`a/gcd(a,c)`次），确保在合理时间内找到最优解。
- **核心算法流程**：交换使主店性价比更优 → 计算仅买主店的花费 → 枚举次优店的购买次数（最多`a/gcd(a,c)`次）→ 计算组合花费并更新最小值。

可视化设计思路：用8位像素风格展示两家店的“花束”（像素方块），枚举过程中用闪烁的箭头标记当前枚举的`i`值，动态计算总花费并高亮最小值。关键步骤（如交换店铺、更新最小值）伴随“叮”的音效，增强操作记忆。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（均≥4星）：
</eval_intro>

**题解一：作者sysong**
* **点评**：此题解从最初的TLE到AC的调试过程非常有参考价值。作者通过观察“多买部分替换后花费会增加”的性质，限制循环次数（最多1e5次），最终AC。代码中使用快读加速，变量名简洁（如`ans`记录最小值），逻辑清晰。亮点在于通过限制循环次数解决超时问题，适合学习如何优化枚举范围。

**题解二：作者zjh111111**
* **点评**：此题解直接利用数学性质（`a/gcd(a,c)`作为枚举上限），避免了无效枚举。代码中通过`swap`确保主店性价比更优，逻辑简洁。亮点在于准确应用`gcd`确定枚举上限，时间复杂度为O(a/gcd(a,c))，效率极高，适合学习如何通过数学优化减少枚举次数。

**题解三：作者快斗游鹿**
* **点评**：此题解思路明确，先比较性价比，再枚举次优店的购买次数到`a/gcd(a,c)`，代码结构工整（如`getcost`函数计算单店花费）。亮点在于将关键逻辑封装为函数，提高可读性，适合学习代码模块化设计。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何确定主买的店？**
    * **分析**：比较两家店的单价（`b/a`和`d/c`），单价低的店作为主买对象。若`b/a > d/c`，交换两家店的参数（`a↔c`，`b↔d`），确保主店性价比更优。例如，若店1单价2元/朵，店2单价3元/朵，优先买店1。
    * 💡 **学习笔记**：通过比较单价确定主买店，是降低总花费的基础。

2.  **关键点2：如何高效枚举次优店的购买次数？**
    * **分析**：直接枚举所有可能（如`i从0到n/c`）会超时。利用数学性质：当`i*c`是`a`的倍数时，买`i`组次优店的花费不低于买`(i*c)/a`组主店的花费（因主店性价比更高）。因此，枚举次数只需到`a/gcd(a,c)`（两数的最小公倍数相关），确保覆盖所有可能更优的情况。
    * 💡 **学习笔记**：通过数学性质（如gcd）限制枚举次数，是解决大数据规模问题的关键技巧。

3.  **关键点3：如何处理剩余花朵数为负的情况？**
    * **分析**：当次优店购买的花朵数超过N时，剩余花朵数为负，此时主店无需购买。例如，若N=5，次优店买了2组（每组3朵），共6朵，已满足N，主店花费为0。
    * 💡 **学习笔记**：用`max(0, n - i*c)`判断剩余花朵数，避免错误计算主店花费。

### ✨ 解题技巧总结
<summary_best_practices>
- **性价比比较**：通过单价比较确定主买店，简化后续计算。
- **枚举优化**：利用数学性质（如gcd）限制枚举次数，避免超时。
- **边界处理**：用`max(0, ...)`处理剩余花朵数为负的情况，确保计算准确。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个优质题解的思路，通过比较性价比确定主店，利用`gcd`限制枚举次数，确保高效计算。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define int long long
    using namespace std;

    int n, a, b, c, d, ans = 1e18;

    inline int gcd(int x, int y) {
        return y ? gcd(y, x % y) : x;
    }

    inline int get_cost(int total, int per, int cost) {
        if (total <= 0) return 0;
        return (total + per - 1) / per * cost; // 向上取整计算花费
    }

    signed main() {
        cin >> n >> a >> b >> c >> d;
        // 确保a,b是性价比更优的店（即b/a <= d/c）
        if (a * d < b * c) swap(a, c), swap(b, d);

        ans = get_cost(n, a, b); // 仅买主店的花费
        int max_i = a / gcd(a, c); // 枚举上限：a/gcd(a,c)

        for (int i = 0; i <= max_i; ++i) {
            int remain = n - i * c;
            int cost = i * d + get_cost(remain, a, b);
            ans = min(ans, cost);
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先比较两家店的性价比，交换后确保`a,b`是更优的主店。然后计算仅买主店的花费作为初始最小值。通过`gcd(a,c)`确定枚举上限`max_i`，枚举次优店的购买次数`i`，计算组合花费并更新最小值。核心函数`get_cost`用于计算单店的花费（向上取整）。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段：
</code_intro_selected>

**题解二：作者zjh111111**
* **亮点**：利用`gcd`确定枚举上限，时间复杂度低至O(a/gcd(a,c))。
* **核心代码片段**：
    ```cpp
    for (register int i=0; i<=a/gcd(a, c); ++i) {
        int x = n - c*i, res = i*d;
        if (x > 0) res += ((x-1)/a+1)*b;
        ans = min(ans, res);
    }
    ```
* **代码解读**：
    > 这段代码枚举次优店的购买次数`i`（最多到`a/gcd(a,c)`次）。对于每个`i`，计算剩余需要的花朵数`x`，若`x>0`则计算主店的花费（`((x-1)/a+1)*b`是向上取整），总花费为`i*d + 主店花费`。通过`min`更新最小值。这里的关键是`a/gcd(a,c)`限制了枚举次数，避免了超时。
* 💡 **学习笔记**：`gcd`用于找到两数的最大公约数，从而确定枚举上限，是处理此类问题的经典技巧。

**题解三：作者快斗游鹿**
* **亮点**：将计算单店花费的逻辑封装为`getcost`函数，提高代码可读性。
* **核心代码片段**：
    ```cpp
    int getcost(int sum, int flo, int cost) {
        if (sum <= 0) return 0;
        if (sum % flo == 0) return sum / flo * cost;
        else return (sum / flo + 1) * cost;
    }
    ```
* **代码解读**：
    > `getcost`函数计算购买至少`sum`朵花的花费。若`sum`能被每束朵数`flo`整除，直接计算；否则向上取整（`sum/flo + 1`）。这样封装后，主函数中的逻辑更简洁，便于维护和调试。
* 💡 **学习笔记**：将重复逻辑封装为函数，是提高代码可读性和复用性的重要技巧。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解枚举过程和花费计算，我设计了一个“像素花店”动画演示方案，用8位复古风格展示购买过程。
</visualization_intro>

  * **动画演示主题**：像素花店大采购
  * **核心演示内容**：比较两家店的性价比→确定主店→枚举次优店的购买次数→计算组合花费→找到最小值。
  * **设计思路简述**：8位像素风营造轻松氛围，用不同颜色的像素方块代表两家店的花束（如红色代表主店，蓝色代表次优店）。枚举过程中用闪烁箭头标记当前`i`值，动态更新总花费并高亮最小值，关键步骤（如交换店铺、更新最小值）伴随“叮”的音效，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分，左边展示两家店的花束（红色方块标`A朵/B元`，蓝色方块标`C朵/D元`），右边是控制面板（单步、自动播放按钮，速度滑块）。
          * 播放8位风格的轻快背景音乐。

    2.  **性价比比较**：
          * 计算两家店的单价（`b/a`和`d/c`），用文字气泡显示比较结果（如“红色店更划算！”），红色方块放大高亮。

    3.  **枚举次优店的购买次数**：
          * 枚举变量`i`从0到`a/gcd(a,c)`，每个`i`对应一个蓝色方块（表示买`i`组次优店）。
          * 当前`i`值用黄色箭头闪烁标记，计算剩余花朵数（`n - i*c`），若为正，红色方块数量动态增加（表示主店购买）。

    4.  **计算总花费**：
          * 总花费实时显示在屏幕顶部，每次计算后与当前最小值比较，若更小则用绿色高亮（如“新最小值：31元！”），伴随“叮”的音效。

    5.  **结束状态**：
          * 枚举完成后，显示最终最小值（如“最少花费：12元！”），播放胜利音效（上扬音调），所有方块排列成庆祝图案。

  * **旁白提示**：
      * “现在比较两家店的单价，红色店更划算，我们优先买红色店！”
      * “当前枚举次优店买2组，剩余需要5朵，红色店买1组，总花费12元！”
      * “找到更小花费啦，绿色高亮显示！”

<visualization_conclusion>
通过这个像素动画，我们可以清晰看到枚举过程和花费计算，轻松理解如何通过优化枚举次数找到最小花费。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考枚举优化和数学性质的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的“比较性价比+枚举优化”思路可用于：
        1. 购买组合问题（如买笔和本子，不同包装的最小花费）。
        2. 资源分配问题（如用两种卡车运货，最小运费）。
        3. 时间安排问题（如用两种时长的任务填满时间，最小任务数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1833 樱花** - 题目描述：用两种时间的活动填满时间，求最少活动数。
          * 🗣️ **推荐理由**：与本题类似，需比较性价比（时间效率）并枚举优化，巩固枚举+数学的应用。
    2.  **洛谷 P1077 摆花** - 题目描述：用两种花摆造型，求方案数。
          * 🗣️ **推荐理由**：涉及组合枚举，可练习如何限制枚举范围。
    3.  **洛谷 P1614 爱与愁的心痛** - 题目描述：求连续子数组的最小和。
          * 🗣️ **推荐理由**：需优化枚举，练习滑动窗口等技巧，拓展枚举思路。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者sysong)**：“最初直接枚举所有可能导致TLE，后来发现多买部分替换后花费会增加，于是限制循环次数到1e5次，最终AC。这让我意识到，枚举时要观察数据规律，找到优化点。”
>
> **点评**：sysong的调试经验很典型。在编程中，遇到超时问题时，要分析数据特点（如本题中多买替换后花费递增），找到枚举的合理上限。这提醒我们，枚举不是暴力，而是有策略的优化。

---

<conclusion>
本次关于“Roses”的C++解题分析就到这里。希望这份学习指南能帮助大家理解枚举优化和数学性质的应用。记住，编程能力的提升在于持续学习和实践，下次我们再一起探索新的挑战！💪
</conclusion>

---
处理用时：140.29秒
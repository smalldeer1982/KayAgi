# 题目信息

# 「SWTR-6」GCDs & LCMs

## 题目描述

小 A 有一个长度为 $n$ 的序列 $a_1,a_2,\cdots,a_n$。

他想从这些数中选出一些数 $b_1,b_2,\cdots,b_k$ 满足：对于所有 $i\ (1\leq i\leq k)$，$b_i$ 要么是序列 $b$ 中的最大值，要么存在一个位置 $j$ 使得 $b_j>b_i$ 且 $b_i+b_j+\gcd(b_i,b_j)=\mathrm{lcm}(b_i,b_j)$。

- 如果你不知道 $\gcd$ 和 $\mathrm{lcm}$ 是什么，可以点击最底部的「帮助/提示」部分的链接。

小 A 想让选出的数之和尽量大。请求出这个最大值。

## 说明/提示

**「样例 1 说明」**

可以选择 $b=\{2,3\}$，因为 $2+3+\gcd(2,3)=\mathrm{lcm}(2,3)$。

**「数据范围与约定」**

**本题采用捆绑测试。**

- Subtask 1（5 points）：$n\leq2$；
- Subtask 2（20 points）：$n\leq 17$；
- Subtask 3（15 points）：$a_i\leq 2\times 10^3$；
- Subtask 4（15 points）：$n\leq 2\times 10^3$；
- Subtask 5（10 points）：$n\leq 5\times 10^4$；
- Subtask 6（10 points）：$a_i\leq 10^7$；
- Subtask 7（25 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$，$1\leq a_i\leq 10^9$。

**「帮助/提示」**

$\gcd$ 表示[最大公约数](https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/869308?fr=aladdin)，$\mathrm{lcm}$ 表示[最小公倍数](https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/6192375?fr=aladdin)。

**「来源」**

[【LGR-075】洛谷 8 月月赛 II Div.2 & SWTR-06 & EZEC Round 3](https://www.luogu.com.cn/contest/33190)。

idea & solution & data by [Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
4
4 3 2 1```

### 输出

```
5```

## 样例 #2

### 输入

```
10
6 7 18 4 17 10 9 1 3 8```

### 输出

```
19```

## 样例 #3

### 输入

```
3
123456789 234567890 123456789```

### 输出

```
246913578```

# AI分析结果



---
# 💡 Kay的C++算法解析：「SWTR-6」GCDs & LCMs 深入学习指南 💡

<introduction>
今天我们来一起分析“「SWTR-6」GCDs & LCMs”这道C++编程题。这道题的关键在于通过数学推导找到隐藏的规律，进而高效求解。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学规律应用` (结合数论推导与高效统计)

🗣️ **初步分析**：
解决这道题的关键在于理解等式 $b_i + b_j + \gcd(b_i, b_j) = \text{lcm}(b_i, b_j)$ 的数学本质。简单来说，我们需要找到满足该等式的数对 $(b_i, b_j)$，并从中选出和最大的子序列。  

通过数学推导（设 $\gcd(b_i, b_j) = d$，令 $b_i = d \cdot x$，$b_j = d \cdot y$，其中 $x, y$ 互质），可得出等式等价于 $x + y + 1 = x \cdot y$。解得唯一正整数解为 $x=2, y=3$（或 $x=3, y=2$），因此 $b_i:b_j = 2:3$（即 $b_j = \frac{3}{2}b_i$）。  

基于此规律，选出的子序列去重排序后必为一个公比为 $\frac{3}{2}$ 的等比数列（如 $2, 3, 4.5$… 但题目中数为整数，因此实际序列为 $2, 3, 4.5$ 需调整为整数，如 $4, 6, 9$）。  

核心算法流程为：  
1. 统计每个数的出现次数（用 `map` 或排序去重后统计）；  
2. 遍历每个数，扩展其可能的等比序列（即当前数 $\rightarrow \frac{3}{2}$ 倍 $\rightarrow \frac{9}{4}$ 倍… 直到超出数组范围或无法整除）；  
3. 计算每个序列的和，取最大值。  

可视化设计思路：采用8位像素风格，用不同颜色的像素方块表示序列中的数，通过步进控制展示每一步扩展（如当前数为 $4$，下一个数应为 $6$，若存在则高亮并累加和），关键操作（如找到下一个数）伴随“叮”的音效，完成一个序列时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑简洁、实现高效被选为优质参考：
</eval_intro>

**题解一：Alex_Wei（官方题解）**  
* **点评**：此解直接抓住数学规律，利用 `map` 统计次数，遍历每个数并扩展等比序列。代码简洁高效（时间复杂度 $O(n \log n)$），边界处理严谨（如奇数无法扩展直接终止），是典型的“数学规律+哈希统计”解法。亮点在于通过 `map` 快速定位下一个数，避免重复计算。

**题解二：Konnyaku_LXZ**  
* **点评**：此解通过排序去重后，用二分查找定位下一个数。代码结构清晰（分初始化、求解、输出三部分），状态转移逻辑明确（`f[i]` 表示以第 $i$ 个数结尾的最大和），适合理解动态规划与二分查找的结合应用。

**题解三：Alarm5854**  
* **点评**：此解将问题转化为图论模型（连边后求最大连通块），虽稍复杂但思路新颖。通过拓扑排序处理状态转移，适合拓展理解不同算法模型的转换，对思维训练有帮助。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向和策略：
</difficulty_intro>

1.  **关键点1：推导等式的数学规律**  
    * **分析**：等式 $b_i + b_j + \gcd(b_i, b_j) = \text{lcm}(b_i, b_j)$ 的推导需要引入 $\gcd$ 的性质（设 $d = \gcd(b_i, b_j)$），将问题转化为 $x + y + 1 = x \cdot y$ 的整数解问题。优质题解通过设变量、因式分解等步骤快速得出 $x=2, y=3$ 的结论。  
    * 💡 **学习笔记**：遇到含 $\gcd$ 或 $\text{lcm}$ 的等式，尝试用 $\gcd$ 分解变量是常见技巧。

2.  **关键点2：高效扩展等比序列**  
    * **分析**：直接枚举所有可能的子序列会超时（$O(2^n)$），需利用规律优化。优质题解通过排序、哈希表（`map`）或二分查找快速定位下一个数（$\frac{3}{2}$ 倍），将时间复杂度降至 $O(n \log n)$。  
    * 💡 **学习笔记**：数学规律能大幅简化问题，结合哈希表或二分查找可高效处理数据。

3.  **关键点3：处理重复元素**  
    * **分析**：原数组可能有重复元素（如多个 $2$），需统计每个数的总出现次数，并在扩展时一次性累加所有重复元素的和。优质题解通过 `map` 或排序去重后统计次数，避免重复计算。  
    * 💡 **学习笔记**：统计重复元素的总贡献是求和问题的常见需求，需注意合并处理。

### ✨ 解题技巧总结
<summary_best_practices>
- **数学推导优先**：遇到含数论函数（$\gcd$、$\text{lcm}$）的问题，先尝试推导数学规律。  
- **哈希表/二分查找加速**：当需要快速定位特定数值时，使用 `map` 或排序后二分查找可显著提升效率。  
- **合并重复元素**：统计每个数的出现次数，避免重复遍历，减少计算量。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，先来看一个综合优质题解的通用核心实现，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了Alex_Wei的官方题解思路，使用 `map` 统计次数，遍历每个数并扩展等比序列，时间复杂度 $O(n \log n)$。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;

    int main() {
        int n;
        cin >> n;
        map<ll, int> cnt; // 统计每个数的出现次数
        vector<ll> a(n);
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            cnt[a[i]]++;
        }
        sort(a.begin(), a.end()); // 排序以便去重遍历
        ll ans = 0;
        for (int i = 0; i < n; ++i) {
            if (cnt[a[i]] == 0) continue; // 已被处理过，跳过
            ll sum = 0;
            ll cur = a[i];
            while (cnt[cur] > 0) {
                sum += cur * cnt[cur];
                cnt[cur] = 0; // 标记为已处理
                if (cur % 2 != 0) break; // 奇数无法扩展，终止
                cur = cur / 2 * 3; // 下一个数应为 cur * 3/2
            }
            ans = max(ans, sum);
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先统计每个数的出现次数（`map`），排序后遍历每个数。对于每个数，扩展其可能的等比序列（当前数 $\rightarrow \frac{3}{2}$ 倍 $\rightarrow \frac{9}{4}$ 倍…），累加所有存在的数的和，并更新最大值。奇数无法扩展，直接终止。

---
<code_intro_selected>
接下来，剖析优质题解中的核心代码片段，理解其亮点和实现思路。
</code_intro_selected>

**题解一：Alex_Wei（官方题解）**  
* **亮点**：利用 `map` 快速统计和标记已处理数，避免重复计算，代码简洁高效。  
* **核心代码片段**：
    ```cpp
    map <int,int> mp;
    int n,a[N]; ll ans;
    int main(){
        cin>>n;
        for(int i=1;i<=n;i++)cin>>a[i],mp[a[i]]++;
        sort(a+1,a+n+1);
        for(int i=1;i<=n;i++){
            ll tmp=a[i],cnt=0;
            while(mp[tmp]){
                cnt+=tmp*mp[tmp],mp[tmp]=0;
                if(tmp%2==0)tmp=tmp/2*3;
                else break;
            }
            ans=max(ans,cnt);
        } cout<<ans<<endl;
        return 0;
    }
    ```
* **代码解读**：  
  `mp` 统计每个数的出现次数。遍历排序后的数组，对于每个数 `a[i]`，扩展其等比序列：若当前数 `tmp` 存在（`mp[tmp] > 0`），则累加其总贡献（`tmp * mp[tmp]`），并标记为已处理（`mp[tmp] = 0`）。若 `tmp` 是偶数，计算下一个数 `tmp/2*3`，否则终止。最终更新最大值 `ans`。  
* 💡 **学习笔记**：用 `map` 标记已处理数，避免重复遍历，是高效处理此类问题的关键。

**题解二：Konnyaku_LXZ**  
* **亮点**：排序去重后用二分查找定位下一个数，动态规划计算最大和。  
* **核心代码片段**：
    ```cpp
    for(int i=2;i<=cnt;++i){
        if(x[i]%3!=0) continue;
        LL val=x[i]/3*2;
        LL pos=lower_bound(x+1,x+i,val)-x;
        if(pos>=i||pos<1||val!=x[pos]) continue;
        f[i]+=f[pos];
        Ans=max(Ans,f[i]);
    }
    ```
* **代码解读**：  
  排序去重后的数组 `x` 中，对于每个数 `x[i]`，若其能被3整除（`x[i]%3==0`），计算其 $\frac{2}{3}$ 倍的值 `val`。用 `lower_bound` 查找 `val` 的位置 `pos`，若存在则将 `f[pos]` 累加到 `f[i]`（`f[i]` 表示以 `x[i]` 结尾的最大和），并更新答案。  
* 💡 **学习笔记**：排序后二分查找是定位特定值的高效方法，动态规划可逐步计算最大和。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解等比序列的扩展过程，我们设计一个8位像素风格的动画，模拟算法如何找到最大和的子序列。
</visualization_intro>

  * **动画演示主题**：`像素探险家的等比寻宝`（复古FC风格）  
  * **核心演示内容**：展示从某个数开始，逐步扩展 $\frac{3}{2}$ 倍的数，累加和的过程。例如，从 `4` 出发，找到 `6`（若存在），再找 `9`（若存在），直到无法扩展。  

  * **设计思路简述**：采用8位像素风（红/蓝/绿等8色调色板），用不同颜色的方块表示序列中的数。步进控制（单步/自动播放）展示每一步的扩展，关键操作（如找到下一个数）伴随“叮”的音效，完成一个序列时播放胜利音效（如《超级玛丽》的通关音），增强学习趣味性。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：屏幕左侧显示像素化的数组（如 `[4,3,2,1]`），右侧显示控制面板（开始/暂停、单步、重置按钮，速度滑块），背景播放8位风格BGM。  
    2. **算法启动**：选择当前数（如 `2`），对应像素方块高亮（黄色闪烁），显示其出现次数（如 `1次`），累加和为 `2`。  
    3. **扩展下一个数**：计算 `2*3/2=3`，若数组中存在 `3`，则 `3` 的像素方块高亮（绿色闪烁），累加和为 `2+3=5`，并标记 `2` 和 `3` 为已处理（灰色）。  
    4. **终止条件**：若下一个数（如 `3*3/2=4.5`）不存在于数组中，播放“叮”音效，当前和 `5` 作为候选答案。  
    5. **结果展示**：遍历所有数后，最大和（如 `5`）用金色高亮，播放胜利音效，显示“最大和为5！”。  

  * **旁白提示**：  
    - “当前处理数是2，它的出现次数是1次，和为2。”  
    - “下一个数应该是2×3/2=3，检查数组中是否存在3…存在！累加和变为2+3=5。”  
    - “3的下一个数是3×3/2=4.5，数组中没有4.5，序列结束。当前和为5。”  

<visualization_conclusion>
通过这样的像素动画，我们能直观看到算法如何从一个数扩展成等比序列，并找到最大和。动画的交互性和趣味性帮助我们更深刻理解核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握本题后，我们可以进一步思考数学规律与高效统计的应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的关键是通过数学推导找到规律，再利用哈希表或二分查找高效统计。类似地，这种思路可用于：  
    - 寻找满足特定倍数关系的子序列（如公比为2的等比序列）；  
    - 统计满足某种数学条件的数对（如和为定值、差为定值）；  
    - 处理含 $\gcd$ 或 $\text{lcm}$ 的等式问题（如求最大/最小和）。  

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1044** - `栈`（数学规律：卡特兰数，统计合法出栈序列数）  
       * 🗣️ **推荐理由**：通过数学规律快速计算，避免暴力枚举，与本题思路类似。  
    2.  **洛谷 P1351** - `联合权值`（统计树中节点对的权值积，需数学推导优化）  
       * 🗣️ **推荐理由**：结合数学规律（如和的平方与平方和的关系）优化计算，提升效率。  
    3.  **洛谷 P1075** - `质因数分解`（统计质因数的指数，需数学推导+高效分解）  
       * 🗣️ **推荐理由**：通过质因数分解的规律，快速统计结果，训练数学与算法结合能力。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验和推导心得，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自 Alex_Wei)**：“最初可能会被复杂的等式吓到，但通过设 $\gcd$ 分解变量，问题会变得简单。关键是要耐心推导数学规律，避免暴力枚举。”  
> **点评**：这位作者的经验提醒我们，遇到含数论函数的问题时，先尝试数学推导找到规律，往往能大幅简化问题。暴力枚举仅适用于小数据，大数据需依赖规律优化。

-----

<conclusion>
本次关于“「SWTR-6」GCDs & LCMs”的C++解题分析就到这里。希望这份学习指南能帮助大家理解数学规律推导与高效统计的结合应用。记住，编程能力的提升需要多思考、多实践，下次我们再探索新的编程挑战！💪
</conclusion>

---
处理用时：165.63秒
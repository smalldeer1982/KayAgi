# 题目信息

# [蓝桥杯 2022 国 C] 打折

## 题目描述

小蓝打算采购 $n$ 种物品，每种物品各需要 $1$ 个。

小蓝所住的位置附近一共有 $m$ 个店铺，每个店铺都出售着各种各样的物品。

第 $i$ 家店铺会在第 $s_i$ 天至第 $t_i$ 天打折，折扣率为 $p_i$，对于原件为 $b$ 的物品，折后价格为 $\lfloor\frac {b\cdot p_j}{100}\rfloor$。其它时间需按原价购买。

小蓝很忙，他只能选择一天的时间去采购这些物品。请问，他最少需要花多少钱才能买到需要的所有物品。

题目保证小蓝一定能买到需要的所有物品。

## 说明/提示

对于 $40\%$ 的评测用例，$n,m≤500，s_i ≤t_i ≤100，\sum c_i ≤2000$；

对于 $70\%$ 的评测用例，$n,m≤5000，\sum c_i ≤20000$；

对于所有评测用例，$1 ≤ n,m ≤ 10^5，1 ≤ c_i ≤ n，\sum c_i ≤ 4\times10^5，1 ≤ s_i ≤t_i ≤10^9，1 < p_i < 100，1≤a_j ≤n，1≤b_j ≤10^9$。

蓝桥杯 2022 国赛 C 组 I 题。

## 样例 #1

### 输入

```
2 2
1 2 89 1
1 97
3 4 77 1
2 15```

### 输出

```
101```

# AI分析结果



---
# 💡 Kay的C++算法解析：蓝桥杯2022国C「打折」深入学习指南 💡

<introduction>
今天我们要挑战的是蓝桥杯2022国赛C组的「打折」问题。这道题需要找到一天采购所有物品的最小花费，关键在于高效处理时间区间内的折扣变化。让我们一起拆解思路，掌握核心技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（数据结构与事件驱动）`

🗣️ **初步分析**：
解决这道题的核心在于“动态维护每个物品的最小可用价格”，并在时间轴上快速计算总花费的最小值。简单来说，我们需要跟踪每个物品在不同时间点的可选价格（原价或折扣价），并找到总花费最低的那一天。

- **题解思路**：主流解法是通过“时间离散化+事件驱动”处理。将所有店铺的折扣开始/结束时间点离散化为有限的关键点（例如，只关注每个折扣的开始和结束时刻），然后在这些关键点上更新每个物品的价格集合，动态计算总花费的最小值。
- **核心难点**：如何高效维护每个物品的最小价格（涉及频繁的插入、删除操作），以及如何处理时间区间的边界（如折扣结束时间实际是`t_i+1`）。
- **可视化设计**：我们将用8位像素风格的时间轴动画，每个时间点用彩色方块表示事件（绿色为折扣开始，红色为折扣结束）。每个物品的价格集合用堆叠的像素块（原价为灰色，折扣价为黄色），当处理事件时，对应颜色的方块会插入或删除，总花费数字实时跳动更新，关键操作（如插入折扣价）伴随“叮”的像素音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性和算法有效性评估，以下题解因逻辑完整、实现高效且注释详细，获得5星推荐：
</eval_intro>

**题解一：来源（tmp_get_zip_diff）**
* **点评**：此题解通过时间离散化将大范围时间压缩到有限关键点，用`multiset`维护每个物品的可选价格，巧妙处理折扣的开始和结束事件。代码结构清晰（变量名如`startD`、`endD`含义明确），边界条件处理严谨（如将`t_i+1`作为折扣结束点），特别是利用`multiset`的自动排序特性快速获取最小值，极大简化了动态维护过程。从实践角度看，代码可直接用于竞赛场景，对大规模数据（如n,m到1e5）的处理效率较高，是非常值得学习的实现。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要突破以下核心难点，掌握关键策略：
</difficulty_intro>

1.  **关键点1：时间离散化的正确处理**  
    * **分析**：题目中时间范围可能到1e9，直接遍历每一天不可行。通过收集所有折扣的开始时间`s_i`和结束时间`t_i+1`（因为折扣是闭区间`[s_i,t_i]`），排序并去重后，将时间轴压缩为有限的关键点（如`time`数组）。这样只需处理这些关键点的事件，大幅减少计算量。  
    * 💡 **学习笔记**：时间离散化是处理大范围时间问题的常用技巧，关键是找到所有可能影响结果的“事件点”。

2.  **关键点2：动态维护每个物品的最小价格**  
    * **分析**：每个物品可能有多个店铺的原价或折扣价可选，需要快速获取当前最小价格。`multiset`（有序可重复集合）能自动排序，插入/删除操作时间复杂度为O(logk)（k为当前物品的价格数量），适合动态维护最小值（`*st[x].begin()`）。  
    * 💡 **学习笔记**：当需要频繁插入、删除并查询最小值时，`multiset`是高效的选择。

3.  **关键点3：事件驱动的总花费计算**  
    * **分析**：在离散化的时间点上，处理折扣的开始（插入折扣价）和结束（删除折扣价）事件。每次事件会影响对应物品的最小价格，进而影响总花费。通过维护`temp`变量记录当前总花费，事件发生时计算差值（`k`）并更新`temp`，即可快速得到每个时间点的总花费。  
    * 💡 **学习笔记**：事件驱动的思想能将连续的时间问题转化为离散的事件处理，大幅降低复杂度。

### ✨ 解题技巧总结
- **离散化事件点**：只处理关键时间点（折扣开始/结束），避免遍历所有时间。
- **利用`multiset`维护最小值**：自动排序，快速获取和更新最小值。
- **增量更新总花费**：通过计算事件前后的差值（`k`），避免每次重新计算所有物品的最小值。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的核心实现，代码逻辑清晰，高效处理大规模数据：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自tmp_get_zip_diff的题解，通过时间离散化和`multiset`动态维护最小价格，是本题的典型高效实现。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXM = 1e5 + 5;
    int s[MAXM], t[MAXM], p[MAXM], c[MAXM];
    multiset<long long> st[MAXM]; // 每个物品的可选价格集合
    vector<vector<pair<int, int>>> v(MAXM); // 店铺i出售的物品及原价

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int n, m;
        cin >> n >> m;
        vector<int> time; // 离散化时间点

        for (int i = 0; i < m; ++i) {
            cin >> s[i] >> t[i] >> p[i] >> c[i];
            time.push_back(s[i]);
            time.push_back(t[i] + 1); // 折扣结束时间为t[i]+1
            for (int j = 0; j < c[i]; ++j) {
                int a, b;
                cin >> a >> b;
                v[i].emplace_back(a, b);
            }
        }

        // 离散化时间
        sort(time.begin(), time.end());
        time.erase(unique(time.begin(), time.end()), time.end());
        auto get = [&](int t) { // 获取离散化后的下标
            return lower_bound(time.begin(), time.end(), t) - time.begin();
        };
        int len = time.size();

        // 初始化事件列表（开始/结束折扣）
        vector<vector<pair<int, int>>> startD(len), endD(len);
        for (int i = 0; i < m; ++i) {
            int starts = get(s[i]), ends = get(t[i] + 1);
            for (auto& [x, y] : v[i]) {
                long long discount = 1LL * y * p[i] / 100; // 计算折扣价
                st[x].insert(y); // 初始插入原价
                startD[starts].emplace_back(x, discount); // 开始事件
                endD[ends].emplace_back(x, discount); // 结束事件
            }
        }

        // 初始总花费（所有物品取原价最小值）
        long long temp = 0;
        for (int i = 1; i <= n; ++i) temp += *st[i].begin();
        long long ans = temp;

        // 处理每个离散时间点的事件
        for (int i = 0; i < len; ++i) {
            long long k = 0;
            // 处理开始事件：插入折扣价，更新最小值
            for (auto& [x, y] : startD[i]) {
                k -= *st[x].begin();
                st[x].insert(y);
                k += *st[x].begin();
            }
            // 处理结束事件：删除折扣价，更新最小值
            for (auto& [x, y] : endD[i]) {
                k -= *st[x].begin();
                auto it = st[x].find(y);
                if (it != st[x].end()) st[x].erase(it);
                k += st[x].empty() ? 0 : *st[x].begin();
            }
            temp += k;
            ans = min(ans, temp); // 更新最小总花费
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取输入并收集所有时间点，离散化后将时间轴压缩为有限关键点。通过`startD`和`endD`记录每个时间点的折扣开始/结束事件。初始化时计算所有物品的原价总花费，然后遍历每个离散时间点，处理事件并更新总花费，最终找到最小值。

---
<code_intro_selected>
接下来聚焦题解一的核心代码片段，分析其关键实现：
</code_intro_selected>

**题解一：来源（tmp_get_zip_diff）**
* **亮点**：巧妙利用`multiset`维护动态最小值，离散化时间点大幅减少计算量，事件驱动的增量更新总花费。
* **核心代码片段**：
    ```cpp
    // 处理每个离散时间点的事件
    for (int i = 0; i < len; ++i) {
        long long k = 0;
        // 处理开始事件：插入折扣价，更新最小值
        for (auto& [x, y] : startD[i]) {
            k -= *st[x].begin();
            st[x].insert(y);
            k += *st[x].begin();
        }
        // 处理结束事件：删除折扣价，更新最小值
        for (auto& [x, y] : endD[i]) {
            k -= *st[x].begin();
            auto it = st[x].find(y);
            if (it != st[x].end()) st[x].erase(it);
            k += st[x].empty() ? 0 : *st[x].begin();
        }
        temp += k;
        ans = min(ans, temp);
    }
    ```
* **代码解读**：
    - 这段代码遍历每个离散时间点（`i`），处理该时间点的所有开始（`startD[i]`）和结束（`endD[i]`）事件。
    - **开始事件**：对于每个物品`x`的折扣价`y`，先减去当前最小值（`*st[x].begin()`），插入折扣价后，新的最小值可能更小，再加上新的最小值，得到差值`k`。
    - **结束事件**：类似，先减去当前最小值，删除折扣价后（可能恢复原价），再加上新的最小值，更新`k`。
    - 最终通过`temp += k`快速更新总花费，并记录最小值`ans`。
* 💡 **学习笔记**：增量更新（计算差值`k`）避免了每次重新计算所有物品的最小值，将时间复杂度从O(n)降为O(事件数)，是高效处理大规模数据的关键。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解时间离散化和事件处理的过程，我们设计一个“像素时间探险”动画，用8位复古风格展示算法每一步！
</visualization_intro>

  * **动画演示主题**：像素时间探险——寻找最优采购日  
  * **核心演示内容**：展示时间轴上的折扣开始/结束事件，每个物品的价格集合动态变化，总花费实时更新，最终找到最小花费日。  
  * **设计思路简述**：8位像素风（类似FC游戏）营造轻松氛围，时间轴用水平滚动条表示，事件点用彩色标记；价格集合用堆叠的像素块（灰色=原价，黄色=折扣价），插入/删除时伴随“滑动”动画；总花费数字用大字体显示，变化时跳动提示，关键操作（如事件触发）播放“叮”的音效，找到最小值时播放胜利音效。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕上方显示时间轴（水平条，标记离散化后的关键点），下方分两列：左列是n个物品（编号1~n），每个物品下方堆叠价格块；右列显示总花费数字（初始为原价总和）。
        - 控制面板：单步/自动按钮、速度滑块（调节事件处理速度）、重置按钮。

    2.  **初始状态**：
        - 所有价格块为灰色（原价），每个物品的最小价格块（最底层）高亮绿色。
        - 总花费数字显示初始值（所有绿色块之和）。

    3.  **处理事件（单步/自动）**：
        - 当点击“单步”或自动播放时，时间轴指针移动到下一个关键点（如时间点i）。
        - **开始事件**（绿色标记）：对应物品的价格集合插入黄色折扣价块（从右侧滑入），若新块比当前绿色块更小，绿色高亮切换到新块，总花费数字减少（伴随“叮”音效）。
        - **结束事件**（红色标记）：对应物品的黄色折扣价块被移除（滑出右侧），若移除的是当前绿色块，绿色高亮切换到下一个最小块（可能是灰色原价），总花费数字增加（伴随“咚”音效）。

    4.  **目标达成**：
        - 当所有事件处理完成，总花费数字停止跳动，最小花费值用金色高亮，播放“胜利”音效（如8位版《超级玛丽》通关音乐）。

  * **旁白提示**：
    - （开始事件时）“注意！物品3的折扣价开始生效，看看它的价格集合有什么变化？”
    - （结束事件时）“物品5的折扣结束，现在它的最小价格可能回到原价了～”
    - （找到最小值时）“哇！这里总花费最小，这就是最优采购日！”

<visualization_conclusion>
通过这个动画，我们能清晰看到每个事件如何影响价格集合和总花费，直观理解离散化和事件驱动的高效性。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思想（离散化时间、动态维护最小值）可迁移到许多场景，例如区间优惠活动、资源调度等。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **区间事件处理**：如电商大促期间的多商品优惠活动，需计算某一天的最低总价。
    - **资源动态分配**：如服务器在不同时间段的性能变化，需选择最优时间执行任务。
    - **股票价格波动**：记录不同时间段的股价，找到某一天买入所有股票的最小成本。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1972 [SDOI2009]HH的项链**  
        * 🗣️ **推荐理由**：考察离线处理区间查询，需用离散化和树状数组，与本题的时间离散化思想类似。
    2.  **洛谷 P1090 合并果子**  
        * 🗣️ **推荐理由**：使用优先队列（类似`multiset`）维护最小值，练习动态维护最小值的技巧。
    3.  **洛谷 P2574 XOR的艺术**  
        * 🗣️ **推荐理由**：处理区间修改和单点查询，锻炼事件驱动的思维。

---

## 7\. 学习心得与经验分享 

<insights_intro>
题解作者tmp_get_zip_diff在代码注释中特别提到：“打折时间为[s,t]，意味着第t+1天才结束打折”，这是处理时间边界的关键细节。
</insights_intro>

> **参考经验**：“需要注意折扣的结束时间是t_i+1，因为原区间是闭区间[s_i,t_i]，所以t_i+1之后不再打折。”
> 
> **点评**：这个经验提醒我们，处理区间问题时要特别注意边界条件（如闭区间的结束点）。实际编码中，类似的“+1”或“-1”错误容易被忽略，但通过仔细审题和样例验证可以避免。例如，本题样例中若错误处理结束时间，可能导致总花费计算错误。

---

<conclusion>
通过今天的分析，我们掌握了时间离散化、事件驱动和动态维护最小值的核心技巧。希望大家在练习中多思考边界条件，灵活运用数据结构优化效率。下次挑战更难的题目时，这些经验会帮你轻松应对！💪
</conclusion>

---

---
处理用时：155.14秒
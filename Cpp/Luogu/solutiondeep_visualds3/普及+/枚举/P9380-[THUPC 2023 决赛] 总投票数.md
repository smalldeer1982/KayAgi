# 题目信息

# [THUPC 2023 决赛] 总投票数

## 题目背景

各位亲爱的《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》玩家：

非常荣幸能与您携手度过了这四年的美好时光，衷心感谢大家的支持与陪伴！

现在，我们非常遗憾的宣布，《La Lumière: Scarlet Intense Flame - Adventurous Scarlet -》将于 2023 年 5 月 28 日 15:00 停止运营服务。

停止运营相关时间表如下：

……

## 题目描述

在关服前，运营发起了一系列投票，调查哪些游戏内容给玩家带来了更深的印象。

作为系列的忠实玩家，你想知道有多少人参加了关服前的投票，但是运营只公开了最终的投票结果：对于一项包含 $N$ 个选项的投票，选择第 $i$ 个选项的玩家比例为 $P_i$（$1\le i\le N$）。运营在公布结果时进行了四舍五入，所有的 $P_i$ 仅保留到小数点后第 $L$ 位。假设实际有 $K$ 位玩家参加了投票，其中有 $D_i$ 位玩家选择了第 $i$ 个选项，则应该有

$$
P_i-\frac{1}{2}\times 10^{-L}\le\frac{D_i}{K}< P_i+\frac{1}{2}\times 10^{-L}
$$

显然，所有的 $D_i$ 必须是非负整数，而 $K=\sum_{i=1}^N D_i$ 则必须是正整数。现在，给定 $N$ 和 $P_i$，请你求出满足 $D_i$ 有非负整数解的最小的总投票数 $K$。

## 说明/提示

**【样例解释 #1】**

最小的总投票数为 $6$，对应每个选项的投票数为 $1, 2, 3$。

**【样例解释 #2】**

最小的总投票数为 $73$，对应每个选项的投票数为 $3, 8, 8, 12, 22, 5, 15$。

**【样例解释 #3】**

最小的总投票数为 $7766$，对应每个选项的投票数为 $12, 301, 123, 403, 629, 530, 1216, 808, 205, 1113, 1005, 1206, 215$。

**【数据范围】**

对于所有测试数据，$1\le N\le 100$，$0\le P_i\le 1$，$\sum_{i=1}^N P_i=1$，且 $P_i$ 最多统一保留到小数点后 $6$ 位。

**【题目来源】**


来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
3
0.166667
0.333333
0.500000
```

### 输出

```
6
```

## 样例 #2

### 输入

```
7
0.041096
0.109589
0.109589
0.164384
0.301370
0.068493
0.205479
```

### 输出

```
73
```

## 样例 #3

### 输入

```
13
0.00155
0.03876
0.01584
0.05189
0.08099
0.06825
0.15658
0.10404
0.02640
0.14332
0.12941
0.15529
0.02768
```

### 输出

```
7766
```

# AI分析结果



---
# 💡 Kay的C++算法解析：[THUPC 2023 决赛] 总投票数 深入学习指南 💡

<introduction>
今天我们来一起分析“总投票数”这道C++编程题。这道题需要我们找到满足特定条件的最小总投票数K，关键在于理解如何通过枚举和验证来解决问题。本指南将帮助大家梳理思路，掌握核心算法，并学会如何高效实现。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举算法应用` (属于“常见”分类中的枚举技巧)

🗣️ **初步分析**：
解决这道题的关键在于“枚举+验证”的思路。简单来说，枚举算法就像“试钥匙开锁”——我们逐一尝试可能的K值（钥匙），检查每个K是否能满足所有条件（开锁成功）。由于题目保证存在解，且最大的K不超过 \(10^L\)（L是P_i的小数位数，最多6位，因此最多试到100万次），这种“暴力枚举”是可行的。

- **题解思路**：所有题解均采用枚举法：从K=1开始递增，对每个K计算各选项的可能投票数D_i（通过四舍五入），验证是否满足误差范围（\(P_i - \frac{1}{2}\times 10^{-L} \leq \frac{D_i}{K} < P_i + \frac{1}{2}\times 10^{-L}\)）且总和为K。
- **核心难点**：如何精确处理P_i的输入（避免浮点数误差），以及如何高效验证每个K的条件。
- **可视化设计**：我们将设计一个“像素投票屋”动画，用方块表示K值，每尝试一个K，就生成对应D_i的像素块，用绿色/红色标记是否满足条件。关键步骤（如计算D_i、验证误差、总和检查）会用高亮和音效提示。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性的评估，以下题解因逻辑清晰、实现严谨被选为优质参考（≥4星）：
</eval_intro>

**题解一：作者 rui_er**
* **点评**：这份题解的亮点在于对输入的精确处理和枚举逻辑的严谨性。作者通过字符串直接读取P_i的小数部分，转换为整数存储（如将0.166667转为166667），避免了浮点数精度问题。代码中使用long long类型防止溢出，枚举时从2开始（特殊情况K=1单独处理），并通过两次验证（四舍五入后的D_i是否符合原P_i的精度要求）确保正确性。实践价值高，可直接用于竞赛。

**题解二：作者 I_will_AKIOI**
* **点评**：此题解思路简洁，直接枚举K并验证。代码通过构造浮点数P_i，利用double类型计算D_i的近似值，结合误差范围判断。虽然可能存在浮点精度问题（但题目中L≤6，double精度足够），但代码结构清晰，变量命名易懂（如inf表示误差范围），适合初学者理解枚举验证的核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们通常会遇到以下关键点。结合优质题解的共性，提炼出核心策略：
</difficulty_intro>

1.  **关键点1**：如何精确处理P_i的输入？
    * **分析**：直接使用浮点数存储P_i可能因精度丢失导致误差（如0.166667在double中可能存储为近似值）。优质题解（如rui_er的代码）通过字符串读取P_i的小数部分，转换为整数（如“0.166667”转为166667），并记录小数位数L，避免了浮点数误差。
    * 💡 **学习笔记**：处理高精度小数时，字符串转整数是更可靠的方法。

2.  **关键点2**：如何验证K是否满足条件？
    * **分析**：对每个K，需计算D_i（四舍五入后的\(P_i \times K\)），然后检查：
      - \(\frac{D_i}{K}\)是否在P_i的误差范围内；
      - 所有D_i之和是否等于K。
      题解中通过两次验证（如计算D_i后，再反向计算其四舍五入后的P_i是否与原P_i一致）确保正确性。
    * 💡 **学习笔记**：验证时需同时满足误差范围和总和条件，缺一不可。

3.  **关键点3**：如何优化枚举范围？
    * **分析**：题目保证存在解，且最大K不超过\(10^L\)（因当K=\(10^L\)时，D_i可取\(P_i \times 10^L\)的整数部分，误差为0）。因此枚举范围只需到\(10^L\)（L≤6时为1e6），时间复杂度可控。
    * 💡 **学习笔记**：利用题目隐含的“存在性”和“最大K”条件，可大幅缩小枚举范围。

### ✨ 解题技巧总结
<summary_best_practices>
- **字符串处理防精度丢失**：读取小数时，用字符串提取小数部分，转换为整数存储，避免浮点数误差。
- **反向验证保正确**：计算D_i后，反向计算其四舍五入后的P_i是否与原P_i一致，双重验证确保条件满足。
- **枚举范围有依据**：利用题目特性（如\(K \leq 10^L\)），明确枚举上限，避免无效计算。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路（主要参考rui_er的代码）提炼的通用核心实现，逻辑清晰且避免浮点数误差，适合学习。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了rui_er题解的输入处理和枚举逻辑，通过字符串读取P_i的小数部分，转换为整数存储，确保精度。枚举K从2到\(10^L\)，验证每个K是否满足条件。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;

    const int N = 105;
    ll n, L;        // L是小数位数（如0.166667的L=6）
    ll val[N];      // 存储P_i的小数部分（如0.166667存为166667）

    int main() {
        cin >> n;
        string s;
        for (int i = 1; i <= n; ++i) {
            cin >> s;
            // 处理特殊情况：P_i=1时，K=1
            if (s == "1.0" || s == "1") {
                cout << 1 << endl;
                return 0;
            }
            // 提取小数部分（格式为"0.xxxxxx"）
            size_t dot = s.find('.');
            if (dot == string::npos) {  // 整数情况（如"1"）
                L = 0;
                val[i] = 0;
            } else {
                L = s.size() - dot - 1;   // 小数位数
                string dec = s.substr(dot + 1);
                // 补零到L位（如"0.1"存为"0.100000"）
                dec += string(6 - dec.size(), '0');  // 题目中L≤6
                val[i] = stoll(dec);      // 小数部分转为整数
            }
        }
        ll lim = 1;
        for (int i = 1; i <= L; ++i) lim *= 10;  // lim=10^L
        // 枚举K从2到lim
        for (ll K = 2; K <= lim; ++K) {
            ll sum = 0;
            bool ok = true;
            for (int i = 1; i <= n; ++i) {
                // 计算D_i：四舍五入后的P_i*K（P_i=val[i]/10^L）
                ll D_i = ll(round(1.0 * val[i] * K / lim));
                sum += D_i;
                // 验证：D_i/K四舍五入后是否等于原P_i
                ll check = ll(round(1.0 * D_i * lim / K));
                if (check != val[i]) {
                    ok = false;
                    break;
                }
            }
            if (ok && sum == K) {
                cout << K << endl;
                return 0;
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先处理输入，将每个P_i的小数部分转换为整数（如0.166667转为166667）并记录小数位数L。然后枚举K从2到\(10^L\)，对每个K计算各选项的D_i（四舍五入后的\(P_i \times K\)），验证D_i/K四舍五入后是否等于原P_i，且所有D_i之和为K。找到第一个符合条件的K并输出。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，学习其中的亮点和实现思路。
</code_intro_selected>

**题解一：作者 rui_er**
* **亮点**：通过字符串直接提取小数部分，避免浮点数精度问题；使用long long防止溢出；枚举时优先处理K=1的特殊情况。
* **核心代码片段**：
    ```cpp
    rep(i, 1, n) {
        scanf("%s", s[i]+1);
        L = (ll)strlen(s[i]+1);
        if(s[i][1] == '1') return puts("1")&0;
        rep(j, 3, L) val[i] = 10 * val[i] + (s[i][j] ^ 48);
    }
    L -= 2; // "0."
    ll lim = 1;
    rep(i, 1, L) lim *= 10;
    rep(i, 2, lim) {
        // 验证逻辑...
    }
    ```
* **代码解读**：
    > 这段代码处理输入，将每个P_i的小数部分（如“0.166667”的“166667”）转换为整数val[i]，并计算L（小数位数）。通过`if(s[i][1] == '1')`快速处理P_i=1的特殊情况（此时K=1）。枚举范围从2到\(10^L\)，确保覆盖所有可能的K值。
* 💡 **学习笔记**：特殊情况优先处理（如K=1）可减少后续计算量；字符串处理小数部分是避免精度问题的关键。

**题解二：作者 I_will_AKIOI**
* **亮点**：代码简洁，直接使用double存储P_i，结合误差范围判断，适合理解枚举验证的核心逻辑。
* **核心代码片段**：
    ```cpp
    bool check(int k) {
        int sum = 0;
        for(int i=1; i<=n; i++) {
            int w = a[i]*k + 0.5;  // 四舍五入计算D_i
            if(a[i] - inf > (double)w/k || (double)w/k >= a[i] + inf) 
                return false;
            sum += w;
        }
        return sum == k;
    }
    ```
* **代码解读**：
    > `check`函数验证给定的K是否满足条件。通过`a[i]*k + 0.5`四舍五入计算D_i，然后检查D_i/K是否在P_i的误差范围内（inf是\(\frac{1}{2}\times 10^{-L}\)），最后验证总和是否为K。代码逻辑直白，适合初学者理解。
* 💡 **学习笔记**：四舍五入可用“+0.5后取整”实现；误差范围的判断需同时满足上下界。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解枚举验证的过程，我们设计一个“像素投票屋”动画，用8位像素风格模拟K的枚举和验证过程。
</visualization_intro>

  * **动画演示主题**：`像素投票屋：寻找最小K`
  * **核心演示内容**：展示从K=1开始枚举，每个K对应的D_i计算、误差验证和总和检查过程，最终找到第一个符合条件的K。
  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围；关键步骤（如D_i计算、误差检查）用颜色高亮和音效提示，帮助记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为三部分：左侧是“K枚举器”（显示当前尝试的K值，像素数字），中间是“D_i生成区”（每行显示一个选项的D_i，用像素方块表示），右侧是“验证区”（显示误差检查和总和检查的结果）。
          * 控制面板：单步/自动播放按钮、速度滑块（调节枚举速度）、重置按钮。

    2.  **枚举K=1**：
          * K=1时，D_i只能是0或1。若存在P_i=1，则D_i=1，验证成功（绿色高亮），播放“叮”音效。

    3.  **枚举K=2到10^L**：
          * 每尝试一个K，“K枚举器”的数字闪烁（黄色），然后生成各选项的D_i（像素方块从右滑入）。
          * **D_i计算**：显示`D_i = round(P_i * K)`的过程（如K=6，P_i=0.166667时，D_i=1），方块上标数字。
          * **误差检查**：D_i/K的数值与P_i的误差范围对比。若在范围内，D_i方块变绿；否则变红，播放“滴答”音效。
          * **总和检查**：所有D_i的方块堆叠成总和，与K对比。若相等，总和区域变绿，播放“叮咚”音效；否则变红。

    4.  **找到最小K**：
          * 当某个K通过所有验证时，屏幕中央弹出“找到啦！”的像素文字，K值闪烁金色，播放“胜利”音效（8位风格的短旋律）。

    5.  **交互控制**：
          * 单步模式：点击“下一步”逐步观察每个K的验证过程。
          * 自动模式：选择速度（慢/中/快），动画自动播放，适合观察整体趋势。

  * **旁白提示**：
      * （K=6时）“看！D_i的总和是1+2+3=6，等于K！误差也都符合要求，这个K是有效的！”
      * （误差检查失败时）“这个D_i/K不在P_i的误差范围内，K不符合条件，继续尝试下一个。”

<visualization_conclusion>
通过这个像素动画，我们能直观看到枚举验证的每一步，理解K的选择如何影响D_i的计算和条件的满足，从而更深刻地掌握枚举算法的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的枚举验证思路适用于许多需要“寻找最小/最大符合条件的值”的问题。以下是一些拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 枚举验证可用于求解“最小满足条件的整数”（如求最小的n使得n!末尾有k个零）。
      * 关键是确定枚举范围（如本题的\(10^L\)）和验证方法（如本题的误差和总和检查）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1147 连续自然数和**  
          * 🗣️ **推荐理由**：枚举连续数列的起点，验证和是否等于目标值，与本题的枚举验证思路类似。
    2.  **洛谷 P1075 质因数分解**  
          * 🗣️ **推荐理由**：枚举可能的因数，验证是否为质数且是原数的因数，锻炼枚举与验证的结合。
    3.  **洛谷 P1217 回文质数**  
          * 🗣️ **推荐理由**：枚举可能的回文数，验证是否为质数，需结合剪枝优化枚举范围。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解分享了实战中的经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自 bobo2007)**：“考场上把N的范围看成10^5了，导致没做出来。后来发现N≤100，枚举完全可行。”
>
> **点评**：这位作者的经验提醒我们，审题时要仔细阅读数据范围。本题中N≤100和L≤6的条件是枚举可行的关键，忽略这些会导致错误的思路。学习时，一定要重视题目中的数据范围，它往往暗示了正确的算法方向。

-----

<conclusion>
本次关于“总投票数”的C++解题分析就到这里。通过枚举验证的思路，我们可以高效解决这类“寻找最小符合条件值”的问题。希望大家通过练习巩固这一技巧，下次遇到类似问题时能快速找到解法！💪
</conclusion>

---
处理用时：159.39秒
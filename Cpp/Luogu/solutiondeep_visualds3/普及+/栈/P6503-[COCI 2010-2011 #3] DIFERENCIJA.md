# 题目信息

# [COCI 2010/2011 #3] DIFERENCIJA

## 题目描述

给出一个长度为 $n$ 的序列 $a_i$，求出下列式子的值：

$$\sum_{i=1}^{n} \sum_{j=i}^{n} (\max_{i\le k\le j} a_k-\min_{i\le k\le j} a_k)$$



即定义一个子序列的权值为序列内最大值与最小值的差。求出所有连续子序列的权值和。



## 说明/提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n\le 3\times 10^5$，$1\le a_i\le 10^8$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #3](https://hsin.hr/coci/archive/2010_2011/contest3_tasks.pdf) *T5 DIFERENCIJA***。

## 样例 #1

### 输入

```
3
1
2
3```

### 输出

```
4```

## 样例 #2

### 输入

```
4
7
5
7
5```

### 输出

```
12```

## 样例 #3

### 输入

```
4
3
1
7
2```

### 输出

```
31```

# AI分析结果

---
# 💡 Kay的C++算法解析：COCI 2010/2011 #3 DIFERENCIJA 深入学习指南 💡

<introduction>
今天我们来一起分析“COCI 2010/2011 #3 DIFERENCIJA”这道题。题目要求计算所有连续子序列的最大值与最小值的差的和。这道题的核心在于高效计算每个元素作为最大值和最小值的贡献次数，而单调栈是解决这类问题的关键工具。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（单调栈的高效运用）`

🗣️ **初步分析**：
> 解决这道题的关键在于用单调栈快速计算每个元素作为最大值和最小值的贡献次数。单调栈就像“探路者”，能帮我们快速找到每个元素左右两侧第一个比它大（或小）的元素位置，从而确定该元素在多少个子序列中是最大值或最小值。  
> 题目要求的是所有连续子序列的`max - min`之和，可以拆分为“所有子序列的最大值之和”减去“所有子序列的最小值之和”。对于每个元素`a[i]`，我们需要计算它在多少个子序列中是最大值（记为`cnt_max[i]`）和最小值（记为`cnt_min[i]`），最终贡献为`a[i]*(cnt_max[i] - cnt_min[i])`。  
> 核心难点在于如何高效计算`cnt_max[i]`和`cnt_min[i]`。通过单调栈，我们可以在O(n)时间内找到每个元素的左边界（左边第一个比它大/小的元素位置）和右边界（右边第一个比它大/小的元素位置），从而用乘法原理计算贡献次数。  
> 可视化设计上，我们可以用8位像素风格展示单调栈的工作过程：栈中的元素用像素方块堆叠，新元素入栈时弹出较小的元素（用闪烁动画），并记录左右边界（用不同颜色标记）。关键步骤伴随“叮”的音效，完成计算后播放胜利音效，增强直观理解。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，筛选出以下3篇优质题解：
</eval_intro>

**题解一：作者Alex_Wei（赞136）**
* **点评**：这篇题解思路简洁高效，直接定义`f[i]/g[i]`为以`i`结尾的子序列的最大/最小值之和，通过单调栈维护左边界，转移方程`f[i] = f[p] + a[i]*(i-p)`（`p`为左边第一个比`a[i]`大的元素位置）直观易懂。代码非常简洁（仅15行），变量命名清晰（如`t1/t2`表示两个单调栈的栈顶指针），时间复杂度O(n)，适合竞赛快速实现。亮点在于用两个单调栈分别处理最大和最小值，常数小且易理解。

**题解二：作者云浅知处（赞15）**
* **点评**：此题解详细拆解了问题，明确将答案拆分为最大值和减最小值和。通过单调栈预处理每个元素的左右边界（`Lmax/Rmax`和`Lmin/Rmin`），用乘法原理计算贡献次数。代码结构工整（四个循环分别处理最大/最小的左右边界），变量命名规范（如`Lmax[i]`表示左边第一个比`a[i]`大的元素位置），边界处理严谨（如栈空时设为0或n+1）。亮点在于清晰的逻辑推导，适合新手理解单调栈的应用。

**题解三：作者Durancer（赞9）**
* **点评**：此题解巧妙复用计算最大值的函数处理最小值——将数组取反后，最小值问题转化为最大值问题，减少代码重复。核心函数`calc()`通过维护单调栈动态计算当前最大值的贡献和，代码简洁（仅20行）。亮点在于代码复用的技巧，体现了“代码简洁性”与“逻辑清晰性”的平衡，适合学习如何优化代码结构。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点，结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1：如何定义每个元素的左右边界？**
    * **分析**：左右边界指的是左边第一个比当前元素大（或小）的元素位置。例如，对于最大值，左边界`Lmax[i]`是最大的`j < i`满足`a[j] > a[i]`，右边界`Rmax[i]`是最小的`j > i`满足`a[j] >= a[i]`（或反之，需避免重复计算）。通过单调栈可以高效找到这些边界：栈中维护递减序列，新元素入栈时弹出所有小于等于它的元素，栈顶即为左边界；从右往左扫描同理。
    * 💡 **学习笔记**：左右边界的定义需注意“取等”问题（如左取`>`，右取`>=`），避免重复计算相同元素的贡献。

2.  **关键点2：如何计算每个元素的贡献次数？**
    * **分析**：对于元素`a[i]`，若左边界为`L`，右边界为`R`，则它作为最大值的子序列个数为`(i-L) * (R-i)`（左端点可选`L+1~i`，右端点可选`i~R-1`）。最小值的贡献次数同理，但边界条件相反（找左边第一个更小的元素）。
    * 💡 **学习笔记**：乘法原理是关键，左右可选区间的长度相乘即为该元素的贡献次数。

3.  **关键点3：如何高效实现单调栈？**
    * **分析**：单调栈的核心是维护一个有序栈（递减或递增）。例如，计算最大值的左边界时，栈中元素按递减顺序排列，新元素入栈时弹出所有小于等于它的元素，栈顶即为左边界。需注意栈的初始化（如栈底设为0或n+1处理边界）。
    * 💡 **学习笔记**：单调栈的实现需注意“弹出条件”（是否取等），这会影响左右边界的准确性。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题拆解**：将原问题拆分为最大值和与最小值和，分别计算后相减。
- **单调栈复用**：通过数组取反，将最小值问题转化为最大值问题，减少代码重复（如Durancer的题解）。
- **边界处理**：栈空时设置虚拟边界（如0或n+1），避免越界错误。
- **变量命名**：使用`Lmax/Rmax/Lmin/Rmin`等清晰命名，提升代码可读性。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看一个综合优质题解的通用核心实现，它结合了单调栈预处理左右边界的思路，代码清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了云浅知处和Alex_Wei的题解思路，通过四次单调栈预处理左右边界，计算每个元素的贡献次数。代码结构清晰，适合学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <stack>
    using namespace std;

    typedef long long ll;
    const int N = 3e5 + 5;

    ll a[N];
    int Lmax[N], Rmax[N], Lmin[N], Rmin[N]; // 左右边界数组

    int main() {
        int n;
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) scanf("%lld", &a[i]);

        // 预处理Lmax（左边第一个比a[i]大的位置）
        stack<int> st;
        for (int i = 1; i <= n; ++i) {
            while (!st.empty() && a[st.top()] <= a[i]) st.pop();
            Lmax[i] = st.empty() ? 0 : st.top();
            st.push(i);
        }

        // 预处理Rmax（右边第一个比a[i]大的位置）
        while (!st.empty()) st.pop();
        for (int i = n; i >= 1; --i) {
            while (!st.empty() && a[st.top()] < a[i]) st.pop();
            Rmax[i] = st.empty() ? n + 1 : st.top();
            st.push(i);
        }

        // 预处理Lmin（左边第一个比a[i]小的位置）
        while (!st.empty()) st.pop();
        for (int i = 1; i <= n; ++i) {
            while (!st.empty() && a[st.top()] >= a[i]) st.pop();
            Lmin[i] = st.empty() ? 0 : st.top();
            st.push(i);
        }

        // 预处理Rmin（右边第一个比a[i]小的位置）
        while (!st.empty()) st.pop();
        for (int i = n; i >= 1; --i) {
            while (!st.empty() && a[st.top()] > a[i]) st.pop();
            Rmin[i] = st.empty() ? n + 1 : st.top();
            st.push(i);
        }

        // 计算总贡献
        ll ans = 0;
        for (int i = 1; i <= n; ++i) {
            ans += a[i] * (i - Lmax[i]) * (Rmax[i] - i); // 最大值贡献
            ans -= a[i] * (i - Lmin[i]) * (Rmin[i] - i); // 最小值贡献
        }

        printf("%lld\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先预处理四个边界数组（`Lmax/Rmax/Lmin/Rmin`），分别表示每个元素左右两侧第一个比它大/小的元素位置。通过单调栈实现O(n)时间复杂度的预处理。最后遍历每个元素，用乘法原理计算其作为最大值和最小值的贡献次数，相减得到最终答案。

---
<code_intro_selected>
接下来，分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者Alex_Wei**
* **亮点**：用两个单调栈同时维护最大和最小值的贡献，代码极简洁（仅15行）。
* **核心代码片段**：
    ```cpp
    const int N = 3e5 + 5;
    ll n, t1, t2, ans, f[N], g[N];
    pii a[N], b[N]; // a栈维护最大值，b栈维护最小值

    int main() {
        n = read();
        for (int i = 1; i <= n; i++) {
            ll x = read(), p;
            while (t1 && x >= a[t1].fi) t1--; // 弹出栈顶小于等于x的元素
            while (t2 && x <= b[t2].fi) t2--; // 弹出栈顶大于等于x的元素
            p = a[t1].se; f[i] = f[p] + x * (i - p); // 最大值贡献
            p = b[t2].se; g[i] = g[p] + x * (i - p); // 最小值贡献
            ans += f[i] - g[i];
            a[++t1] = b[++t2] = {x, i}; // 入栈
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读**：
    > `f[i]`表示以`i`结尾的子序列的最大值之和。`a`栈维护递减序列，`t1`是栈顶指针。当新元素`x`入栈时，弹出所有小于等于`x`的元素（因为这些子序列的最大值会被`x`替代）。栈顶元素的位置`p`即为左边第一个比`x`大的位置，`f[i]`由`f[p]`（`p`之前的贡献）加上`x*(i-p)`（`p+1`到`i`的子序列的最大值为`x`）。最小值的处理类似，但栈维护递增序列。
* 💡 **学习笔记**：动态维护以每个位置结尾的子序列的贡献，避免重复计算，是O(n)算法的关键。

**题解二：作者云浅知处**
* **亮点**：明确拆分问题为最大值和与最小值和，代码结构工整。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= n; i++) {
        while (!s.empty() && a[s.top()] <= a[i]) s.pop();
        if (s.empty()) Lmax[i] = 0;
        else Lmax[i] = s.top();
        s.push(i);
    }
    // 类似处理Rmax、Lmin、Rmin...
    ans += a[i] * (i - Lmax[i]) * (Rmax[i] - i);
    ans -= a[i] * (i - Lmin[i]) * (Rmin[i] - i);
    ```
* **代码解读**：
    > 预处理`Lmax`时，栈中保存的是递减序列的下标。新元素`i`入栈前，弹出所有栈顶元素小于等于`a[i]`（这些元素的右边界被`i`更新），栈顶即为`Lmax[i]`（左边第一个比`a[i]`大的元素位置）。`Rmax`从右往左扫描，同理。最终用乘法原理计算贡献。
* 💡 **学习笔记**：预处理左右边界是计算贡献次数的基础，需仔细处理栈的弹出条件（是否取等）。

**题解三：作者Durancer**
* **亮点**：通过数组取反复用最大值计算函数，减少代码重复。
* **核心代码片段**：
    ```cpp
    int calc() {
        head = 1;
        int now = 0, sum = 0;
        for (int i = 1; i <= n; i++) {
            while (head > 1 && a[q[head]] < a[i]) {
                now -= (q[head] - q[head - 1]) * a[q[head]];
                head--;
            }
            now += (i - q[head]) * a[i]; // 计算当前元素的贡献
            sum += now;
            q[++head] = i;
        }
        return sum;
    }
    // 主函数中取反数组计算最小值和
    ans += calc();
    for (int i = 1; i <= n; i++) a[i] *= -1;
    ans += calc(); // 最小值和转化为最大值和
    ```
* **代码解读**：
    > `calc()`函数计算最大值和。`now`维护当前所有以`i`结尾的子序列的最大值之和。当新元素`a[i]`入栈时，弹出栈中所有小于它的元素（这些子序列的最大值被`a[i]`替代），更新`now`。取反数组后，最小值问题转化为最大值问题，复用`calc()`函数。
* 💡 **学习笔记**：代码复用能减少重复劳动，但需注意取反后的逻辑是否一致（如比较符号是否调整）。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解单调栈的工作过程，我们设计一个“像素探宝”主题的8位风格动画，演示如何用单调栈计算每个元素的左右边界。
</visualization_intro>

  * **动画演示主题**：`像素探宝：寻找最大值与最小值的边界`

  * **核心演示内容**：展示单调栈如何为每个元素找到左边第一个比它大的元素（左边界），并计算贡献次数。同时对比最大值和最小值的处理差异（如栈维护递增/递减）。

  * **设计思路简述**：采用FC红白机风格的像素画面（8色调色板，简洁方块），通过栈的动态变化（元素入栈/弹出）、边界标记（不同颜色箭头）和贡献值的实时计算，帮助学习者直观看到单调栈的“探路”过程。音效（如弹出时的“叮”声、入栈时的“咔嗒”声）增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为三部分：顶部是原始数组（像素方块，数值显示在方块上），中间是单调栈（垂直堆叠的方块，栈底在下），底部是控制面板（单步/自动/重置按钮，速度滑块）。
        - 播放8位风格的轻快背景音乐。

    2.  **处理最大值左边界（Lmax）**：
        - 从左到右遍历数组元素（用箭头标记当前处理位置`i`）。
        - 当前元素`a[i]`的像素方块高亮（黄色），与栈顶元素（红色）比较：
          - 若栈顶元素值 <= `a[i]`，栈顶方块闪烁（红色→白色）后弹出（向上移动消失），伴随“叮”声。
          - 若栈顶元素值 > `a[i]`，栈顶位置即为左边界`Lmax[i]`（用绿色箭头标记），`a[i]`入栈（滑入栈顶），伴随“咔嗒”声。
        - 实时显示`Lmax[i]`的值（如“Lmax[3] = 1”）。

    3.  **处理最大值右边界（Rmax）**：
        - 从右到左遍历数组，逻辑类似，但比较符号改为“<”（避免重复计算）。
        - 右边界`Rmax[i]`用蓝色箭头标记，显示其值（如“Rmax[3] = 5”）。

    4.  **贡献计算**：
        - 当左右边界确定后，计算该元素的贡献次数`(i-Lmax[i])*(Rmax[i]-i)`，数值用金色数字从方块中弹出，累加到总和（顶部显示总贡献）。
        - 播放“叮咚”音效，庆祝贡献计算完成。

    5.  **对比最小值处理**：
        - 切换到最小值模式（数组取反，数值变为负数），重复上述步骤，但栈维护递增序列（比较符号相反）。
        - 用紫色箭头标记最小值的左右边界，贡献次数用红色数字弹出，从总和中减去。

    6.  **交互控制**：
        - 支持单步执行（点击“下一步”逐步处理元素）、自动播放（速度可调）、重置（清空栈和边界标记）。
        - 鼠标悬停在栈元素上显示其数值和位置，帮助理解栈的状态。

  * **旁白提示**：
      - “现在处理第3个元素，值为5。栈顶元素是2（值为3），比5小，所以弹出！”
      - “栈顶现在是1（值为6），比5大，所以Lmax[3] = 1！”
      - “贡献次数是(3-1)*(5-3)=4，5的贡献是5*4=20，总和增加20！”

<visualization_conclusion>
通过这个像素动画，我们能清晰看到单调栈如何一步步为每个元素找到边界，并计算贡献。这种“可视化+游戏化”的方式，让抽象的算法变得生动易懂！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是用单调栈计算每个元素的贡献次数，这种思路在区间最值问题中非常通用。以下是类似问题和拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 单调栈可用于求解“每个元素左右第一个更大/更小元素”的问题，如直方图最大矩形面积（Largest Rectangle in Histogram）、接雨水（Trapping Rain Water）等。
      - 贡献次数的计算（左右区间长度相乘）适用于所有需要统计“元素在多少区间中是最值”的场景。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1950 [NOI2005] 月下柠檬树**  
          * 🗣️ **推荐理由**：考察单调栈在几何问题中的应用，需要计算投影轮廓的面积，核心是找到每个点的左右边界。
    2.  **洛谷 SP10622 NSUBSTR - Substrings**  
          * 🗣️ **推荐理由**：求每个长度的子串的最大出现次数，需用单调栈结合后缀自动机，强化单调栈的灵活运用。
    3.  **洛谷 P5788 [模板] 单调栈**  
          * 🗣️ **推荐理由**：直接考察单调栈的基本操作，适合巩固本题的核心技巧。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到了调试经验和细节处理，以下是值得借鉴的心得：
</insights_intro>

> **参考经验 (来自Cry_For_theMoon)**：“处理重复元素时，左右边界的取等条件要一致（如左取`>`，右取`>=`），否则会重复计算。例如，两个相同的5，左边取`>`保证左边界是更左边的元素，右边取`>=`保证右边界是更右边的元素，避免中间区间被重复计算。”

**点评**：这位作者的经验非常关键！在处理重复元素时，取等条件的选择直接影响边界的准确性。通过调整左右边界的比较符号（一边取等，一边不取等），可以确保每个区间的最值只被计算一次。这提醒我们在编写单调栈代码时，一定要仔细处理比较条件，避免重复或漏算。

-----

<conclusion>
本次关于“COCI 2010/2011 #3 DIFERENCIJA”的分析就到这里。通过理解单调栈的核心作用、掌握贡献次数的计算方法，以及动手实现代码，相信大家能轻松解决这类问题。记住，多练习、多总结，是提升算法能力的关键！下次见～💪
</conclusion>

-----

---
处理用时：161.89秒
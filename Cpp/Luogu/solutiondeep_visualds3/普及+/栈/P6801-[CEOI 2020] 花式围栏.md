# 题目信息

# [CEOI 2020] 花式围栏

## 题目背景

0.1s，32MB

## 题目描述

众所周知，Balázs 拥有整个城镇中最漂亮的围栏。围栏由 $N$ 个部分组成，每个部分均为矩形，且相邻的两个部分间均紧密相连。第 $i$ 部分矩形的高度为 $h_i$，宽度为 $w_i$，我们需要找到满足如下条件的花式矩形：

- 矩形的每条边均是水平的或竖直的，且每条边的长度为整数。
- 矩形与地面的距离为整数。
- 矩形与围栏第一部分的左侧边的距离为整数。
- 矩形完整包含在围栏中。

现在你需要求出花式矩形的总数。因为这个数字可能很大，请输出其对 $10^9+7$ 取模后的结果。

## 说明/提示

### 样例解释 1

围栏形状如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/o0w99om5.png)

形状如下的矩形有 $5$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/qvrh1vbs.png)

形状如下的矩形有 $3$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/hx15etpn.png)

形状如下的矩形有 $1$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/s01bhzfn.png)

形状如下的矩形有 $2$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/ee3kec7y.png)

形状如下的矩形有 $1$ 个：

![](https://cdn.luogu.com.cn/upload/image_hosting/n26e8gyi.png)

### 样例 2

见附加文件。

### 子任务

所有测试点均满足：$1 \leq N \leq 10^5$，$1 \leq h_i,w_i \leq 10^9$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                                                         |
| ---------- | ---- | ------------------------------------------------------------ |
| $1$        | $0$  | 样例                                                         |
| $2$        | $12$ | $N \leq 50$，且 $\forall i \in [1,N]$，$h_i \leq 50$ 且 $w_i=1$ |
| $3$        | $13$ | $\forall i \in [1,N]$，$h_i=1$ 或 $h_i=2$                    |
| $4$        | $15$ | 所有的 $h_i$ 均相等                                          |
| $5$        | $15$ | $\forall i \in [1,N-1]$，$h_i \leq h_{i+1}$                  |
| $6$        | $18$ | $N \leq 1000$                                                |
| $7$        | $27$ | 无特殊约束                                                   |

## 样例 #1

### 输入

```
2
1 2
1 2```

### 输出

```
12```

# AI分析结果



---
# 💡 Kay的C++算法解析：[CEOI 2020] 花式围栏 深入学习指南 💡

<introduction>
今天我们来一起分析“[CEOI 2020] 花式围栏”这道C++编程题。这道题需要计算由多个矩形组成的围栏中包含的所有子矩形数量，核心难点在于高效处理不同高度矩形的组合贡献。本指南将帮助大家理解核心算法、关键步骤，并通过可视化方案直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（单调栈的高效数据结构运用）`

🗣️ **初步分析**：
解决这道题的关键在于理解如何用单调栈维护高度递增的矩形序列，动态计算每个矩形对总答案的贡献。单调栈就像一个“高度管理员”，保证栈内的矩形高度严格递增，当遇到较矮的新矩形时，会“削去”栈顶过高的部分，并计算这些被削去部分的贡献。

在本题中，单调栈的主要作用是：  
- 维护当前处理的矩形序列，确保栈中矩形高度递增。  
- 当新矩形高度小于栈顶时，弹出栈顶过高的矩形，并计算其被削去部分的子矩形数量（通过容斥原理：原矩形子矩形数 - 削去后剩余部分的子矩形数）。  
- 最终处理完所有矩形后，栈中剩余部分也需要计算贡献。

核心算法流程的可视化设计：用8位像素风格展示栈的变化，每个矩形用不同颜色的像素块表示（如红色表示当前处理的矩形，蓝色表示栈中矩形）。当弹出过高矩形时，用闪烁动画和“叮”的音效提示，同时高亮显示贡献计算的数学公式（如`C(h) * C(w)`的差值）。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解在多个方面表现突出（评分≥4星）：
</eval_intro>

**题解一：作者Alex_Wei**
* **点评**：此题解思路简洁明了，直接点明用单调栈维护高度递增序列，并通过容斥计算贡献。代码非常精炼（仅20行左右），变量命名（如`a`栈存高度，`b`栈存宽度）直观。亮点在于利用栈顶前一个元素的高度确定削去后的高度，避免了复杂的边界判断。实践价值高，可直接用于竞赛。

**题解二：作者StudyingFather**
* **点评**：此题解对单调栈的操作逻辑解释清晰，强调“将栈顶矩形的高度降至`max(h_n, h_i)`以保持单调性”。代码结构工整，使用`C2`函数简化组合数计算，边界处理（如栈空时取`h[i]`）严谨。算法复杂度为O(n)，高效适用于大输入。

**题解三：作者yxy666**
* **点评**：此题解从基础的子矩形计数公式出发（`C(w) * C(h)`），结合单调栈动态维护，逻辑推导自然。代码中`C`函数明确表示组合数计算，注释清晰，适合初学者理解。亮点在于将最终处理栈中剩余元素的逻辑与主循环统一，减少重复代码。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决本题的过程中，我们通常会遇到以下关键点或难点，结合优质题解的共性，提炼出核心策略：
</difficulty_intro>

1.  **关键点1：如何定义单调栈的状态？**
    * **分析**：单调栈需维护两个关键信息——矩形的高度和累积宽度。栈中每个元素代表一个“合并后的矩形”（可能由多个原矩形合并而来），其高度为当前段的最小高度，宽度为该段的总宽度。例如，当栈顶矩形高度大于新矩形时，栈顶会被弹出，其宽度累加到新矩形的宽度中。
    * 💡 **学习笔记**：单调栈的状态需同时记录高度和宽度，宽度用于计算横向的子矩形数量。

2.  **关键点2：如何计算被削去部分的贡献？**
    * **分析**：被削去部分的贡献等于原矩形的子矩形数减去削去后剩余部分的子矩形数。原矩形的子矩形数为`C(w) * C(h)`（`C(x)`表示x的组合数，即`x*(x+1)/2`），剩余部分的子矩形数为`C(w) * C(max(h_new, h_prev))`（`h_prev`为栈顶前一个元素的高度）。
    * 💡 **学习笔记**：容斥原理是计算重叠部分贡献的关键，避免重复或遗漏。

3.  **关键点3：如何处理边界条件（如栈空时的高度）？**
    * **分析**：当栈空时，说明当前矩形是最低的，削去后的高度为0（或直接取新矩形的高度）。例如，在Alex_Wei的题解中，初始时栈中压入-1（表示高度为0），避免栈空时的特判。
    * 💡 **学习笔记**：通过初始化栈底元素（如高度为0），可以统一处理边界条件，简化代码逻辑。

### ✨ 解题技巧总结
- **问题分解**：将总问题分解为每个矩形的贡献，利用单调栈动态合并相邻矩形，避免重复计算。
- **组合数预计算**：定义`C(x)`函数统一计算`x*(x+1)/2`，简化代码并减少错误。
- **宽度累积**：用栈维护累积宽度，快速计算合并后矩形的总宽度，避免遍历求和。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解前，先看一个综合优质题解的通用核心实现，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Alex_Wei和StudyingFather的思路，保留了关键逻辑（单调栈维护、容斥计算贡献），并优化了变量命名和注释，适合初学者理解。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <stack>
    using namespace std;

    const int MOD = 1e9 + 7;
    using ll = long long;

    // 计算组合数C(x) = x*(x+1)/2 mod MOD
    ll C(ll x) {
        return x % MOD * ((x + 1) % MOD) % MOD * 500000004 % MOD; // 500000004是2的逆元
    }

    int main() {
        int n;
        cin >> n;
        ll h[100005] = {0}, w[100005] = {0};
        for (int i = 1; i <= n; ++i) cin >> h[i];
        for (int i = 1; i <= n; ++i) cin >> w[i];

        stack<ll> height, width;
        height.push(0); // 初始高度0，避免栈空特判
        ll ans = 0;

        for (int i = 1; i <= n + 1; ++i) { // 处理到n+1，确保栈中剩余元素被处理
            ll current_h = (i <= n) ? h[i] : 0;
            ll current_w = 0;

            while (height.top() > current_h) {
                ll top_h = height.top();
                ll top_w = width.top();
                height.pop();
                width.pop();
                current_w = (current_w + top_w) % MOD;

                // 计算被削去部分的贡献：C(top_h) - C(max(current_h, height.top()))
                ll prev_h = height.top();
                ll cut_h = max(current_h, prev_h);
                ans = (ans + (C(top_h) - C(cut_h) + MOD) % MOD * C(current_w) % MOD) % MOD;
            }

            if (i <= n) {
                width.push((w[i] + current_w) % MOD);
                height.push(current_h);
            }
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入，初始化单调栈（高度栈和宽度栈）。主循环处理每个矩形（包括虚拟的第n+1个矩形，确保栈中剩余元素被处理）。对于每个新矩形，若栈顶高度大于当前高度，则弹出栈顶，计算其贡献（原高度的子矩形数减去削去后高度的子矩形数），并将宽度累加到当前矩形。最终输出总答案。

---
<code_intro_selected>
接下来，分析优质题解的核心代码片段，理解其亮点和关键逻辑。
</code_intro_selected>

**题解一：作者Alex_Wei**
* **亮点**：代码极简，利用两个栈分别维护高度和宽度，通过`calc`函数简化组合数计算。
* **核心代码片段**：
    ```cpp
    stack <int> a,b;
    int n,w[N],h[N],ans;

    int calc(int x){return 1ll*x*(x+1)/2%mod;}
    int main(){
        n=read(),a.push(-1);
        for(int i=1;i<=n;i++)h[i]=read(); 
        for(int i=1;i<=n;i++)w[i]=read();
        for(int i=1,s=0;i<=n+1;i++,s=0){
            while(h[i]<=a.top()){
                int hh=a.top(),ww=b.top(); a.pop(),b.pop(),s=(s+ww)%mod;
                ans=(ans+1ll*(calc(hh)-calc(max(h[i],a.top()))+mod)*calc(s))%mod;
            } a.push(h[i]),b.push((w[i]+s)%mod);
        } cout<<ans<<endl;
        return 0;
    }
    ```
* **代码解读**：  
  `a`栈存高度，`b`栈存宽度。`calc(x)`计算`x*(x+1)/2 mod mod`。主循环中，当当前高度小于栈顶时，弹出栈顶，累加宽度`s`，并计算贡献（`calc(hh) - calc(max(h[i], a.top()))`）乘以宽度的组合数`calc(s)`。最后将当前高度和累加后的宽度压入栈。
* 💡 **学习笔记**：用栈维护累积宽度是关键，避免了重复计算合并后的总宽度。

**题解二：作者StudyingFather**
* **亮点**：使用`C2`函数明确表示组合数，代码结构工整，边界处理（如栈空时取`h[i]`）严谨。
* **核心代码片段**：
    ```cpp
    long long C2(long long x) { return x * (x - 1) / 2 % MOD; }
    int main() {
        // ... 输入处理 ...
        s.push(0);
        for (int i = 1; i <= n + 1; i++) {
            int sw = 0;
            while (h[s.top()] > h[i]) {
                int u = s.top();
                s.pop();
                sw = (sw + w[u]) % MOD;
                ans = (ans + (C2(h[u] + 1) - C2(max(h[i], h[s.top()]) + 1)) * C2(sw + 1) % MOD + MOD) % MOD;
            }
            w[i] += sw;
            s.push(i);
        }
    }
    ```
* **代码解读**：  
  `C2(x)`计算`x*(x-1)/2`，对应子矩形数（因为子矩形的边数是`x+1`条，选两条的组合数是`C(x+1,2)`）。`sw`累加被弹出矩形的宽度，`ans`累加贡献（原高度的子矩形数减去剩余高度的子矩形数）。
* 💡 **学习笔记**：组合数的计算需注意边数与矩形数的关系（边数为`x+1`，组合数为`C(x+1,2)`）。

**题解三：作者yxy666**
* **亮点**：从基础公式出发，代码注释清晰，适合理解单调栈的核心逻辑。
* **核心代码片段**：
    ```cpp
    long long C(long long x){return (x*(x+1)/2)%TT;}//计算方案数
    int main(){
        // ... 输入处理 ...
        q[++tot]=0;
        for(int i=1;i<=n+1;i++){//处理到n+1，确保栈中剩余元素被处理
            long long s=0;
            while(h[q[tot]]>h[i]){
                int now=q[tot--];
                s=(s+w[now])%TT;
                ans=(ans+(C(h[now])-C(max(h[i],h[q[tot]])))*C(s)%TT)%TT;
            }
            w[i]=(w[i]+s)%TT;
            q[++tot]=i;
        }
    }
    ```
* **代码解读**：  
  `q`数组模拟栈，`tot`为栈顶指针。`s`累加被弹出矩形的宽度，`ans`通过`C(h[now]) - C(max(h[i], h[q[tot]]))`计算贡献。最后将当前矩形压入栈。
* 💡 **学习笔记**：处理到`n+1`是为了确保栈中所有元素都被弹出并计算贡献，避免遗漏。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解单调栈的操作过程，我们设计一个“像素栈管员”的8位风格动画，通过颜色变化、音效和动态演示，展示栈的弹出、合并和贡献计算过程。
</visualization_intro>

  * **动画演示主题**：`像素栈管员的围栏建造`

  * **核心演示内容**：  
    展示单调栈如何维护高度递增的矩形，当新矩形加入时，弹出过高的旧矩形，并计算其贡献。例如，初始栈底是高度0的灰色块，新矩形是红色块，栈中蓝色块表示已处理的矩形。

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）营造轻松氛围，颜色区分不同状态（红色=当前处理，蓝色=栈中，灰色=栈底）。关键操作（弹出、合并）配合“叮”的音效，贡献计算时高亮数学公式，帮助记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧是像素化的围栏（每个矩形用对应高度的像素块堆叠），右侧是单调栈区域（垂直排列的像素块，高度=矩形高度，宽度=累积宽度）。  
        - 控制面板包含“单步”“自动播放”“调速”按钮，底部显示当前贡献值。

    2.  **处理第i个矩形**：  
        - 新矩形（红色）从右侧进入，与栈顶蓝色块比较高度。若红色块更矮，栈顶蓝色块开始闪烁（“需要弹出”提示）。

    3.  **弹出栈顶矩形**：  
        - 蓝色块向上移动（弹出动画），宽度累加到红色块（红色块宽度变宽），同时播放“叮”的音效。  
        - 贡献计算区域显示公式：`贡献 += (C(旧高度) - C(新高度)) * C(累积宽度)`，数值实时更新。

    4.  **压入新矩形**：  
        - 红色块变为蓝色，压入栈中（向下移动到栈顶位置），栈中其他块调整位置。

    5.  **处理完所有矩形后**：  
        - 栈中剩余的蓝色块依次弹出，重复上述过程，最终贡献值停止更新，播放“胜利”音效。

  * **旁白提示**：  
    - （弹出时）“当前矩形高度比栈顶小，需要弹出栈顶的高矩形，计算它被削去部分的贡献！”  
    - （压入时）“现在将新矩形压入栈，保持栈内高度递增。”  
    - （结束时）“所有矩形处理完成，总贡献就是答案！”

<visualization_conclusion>
通过这样的动画，我们可以直观看到单调栈如何动态维护矩形序列，以及每个操作如何影响最终答案，大大降低理解难度。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
单调栈的核心思想是“维护单调序列，处理逆序元素”，这一技巧广泛应用于需要快速找到“左右边界”或“极值”的问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    单调栈可用于：  
    1. 求直方图中最大矩形面积（如LeetCode 84题）；  
    2. 寻找数组中每个元素的下一个更大元素（如LeetCode 496题）；  
    3. 计算每个元素作为最小值的区间数量（如洛谷P1972）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1972 [SDOI2009]HH的项链**  
        * 🗣️ **推荐理由**：考察区间查询和离线处理，可结合前缀和与单调栈优化，巩固数据结构应用。  
    2.  **洛谷 P5788 [模板] 单调栈**  
        * 🗣️ **推荐理由**：直接练习单调栈的基本操作，理解“下一个更大元素”的求解过程。  
    3.  **洛谷 P1169 [ZJOI2007]棋盘制作**  
        * 🗣️ **推荐理由**：结合最大矩形面积问题，需将二维问题转化为一维直方图，强化单调栈的综合应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如“注意开long long”“处理模运算时要加MOD再取模避免负数”，这些经验对避免常见错误非常有帮助。
</insights_intro>

> **参考经验 (来自作者WorldBest丶牛顿)**：“写题时如果要开long long，记得把全部都改成long long！来自一个修了好半天代码只有12分的蒟蒻。”  
> **点评**：在C++中，整数溢出是常见错误。当输入数据范围大（如本题h_i、w_i到1e9）时，中间计算结果很容易超出int范围。统一使用long long类型可以避免溢出问题，这是竞赛编程中的重要习惯。

-----

<conclusion>
本次关于“[CEOI 2020] 花式围栏”的分析就到这里。通过理解单调栈的核心逻辑、掌握容斥计算贡献的方法，以及动手练习相似题目，相信大家能更好地掌握这类问题的解法。记住，多思考、多调试，编程能力会稳步提升！下次再见~ 💪
</conclusion>

---
处理用时：169.86秒
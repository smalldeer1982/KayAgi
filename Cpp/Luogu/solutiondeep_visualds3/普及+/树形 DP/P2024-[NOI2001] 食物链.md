# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果


### 题目分析
这道题是经典的"食物链"问题，需要处理三种动物之间的复杂关系（同类、捕食、被捕食）。核心挑战在于高效维护动态关系并快速检测冲突。以下是解题思路和优化后的代码实现：

### 算法选择：扩展域并查集
使用三倍大小的并查集维护三种关系：
- `i`：自身（同类域）
- `i+n`：猎物域（i吃的动物）
- `i+2n`：天敌域（吃i的动物）

### 关键操作
1. **同类关系（操作1）**：
   - 检查冲突：若x吃y或y吃x → 假话
   - 合并：x与y、x+n与y+n、x+2n与y+2n

2. **捕食关系（操作2）**：
   - 检查冲突：x=y 或 x与y同类 或 y吃x → 假话
   - 合并：x与y+2n、x+n与y、x+2n与y+n

### 复杂度分析
- **时间复杂度**：O(Kα(N)) ≈ O(K)，α是反阿克曼函数
- **空间复杂度**：O(N)

### 完整代码实现
```cpp
#include <iostream>
using namespace std;

const int MAXN = 150005; // 三倍空间
int fa[MAXN];

int find(int x) {
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void unite(int x, int y) {
    int rx = find(x), ry = find(y);
    if (rx != ry) fa[rx] = ry;
}

int main() {
    int n, k, ans = 0;
    cin >> n >> k;
    
    // 初始化三倍并查集
    for (int i = 1; i <= 3*n; i++)
        fa[i] = i;
    
    while (k--) {
        int op, x, y;
        cin >> op >> x >> y;
        
        // 边界检查
        if (x > n || y > n) {
            ans++;
            continue;
        }
        
        if (op == 1) { // 同类关系
            if (find(x + n) == find(y) || find(x + 2*n) == find(y)) {
                ans++;
            } else {
                unite(x, y);
                unite(x + n, y + n);
                unite(x + 2*n, y + 2*n);
            }
        } else { // 捕食关系
            if (x == y || find(x) == find(y) || find(x + 2*n) == find(y)) {
                ans++;
            } else {
                unite(x, y + 2*n);
                unite(x + n, y);
                unite(x + 2*n, y + n);
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```

### 算法可视化（像素动画）
设计一个8位像素风格的动画演示：
1. **界面布局**：
   - 顶部：控制面板（开始/暂停/单步/重置）
   - 中部：三列像素网格（红/绿/蓝代表三个关系域）
   - 底部：当前操作说明

2. **动画流程**：
   - 初始状态：所有动物独立显示
   - 添加关系时：
     - 同类：同色像素融合 + "融合"音效
     - 捕食：红色箭头从捕食者指向猎物 + "捕食"音效
   - 检测冲突：冲突区域闪烁红光 + "错误"音效

3. **交互功能**：
   - 单步执行：按空格逐步执行
   - 速度调节：滑块控制动画速度
   - AI演示：自动播放解题全过程

### 学习总结
1. **核心技巧**：
   - 使用扩展域处理复杂关系
   - 合并前先检查冲突
   - 三域同步更新保持一致性

2. **易错点**：
   - 忘记处理边界条件（x>n或y>n）
   - 同类关系未检查双向捕食关系
   - 合并时遗漏某个关系域

3. **拓展练习**：
   - 洛谷P1525（关押罪犯）：类似关系维护
   - 洛谷P1892（团伙）：二值关系扩展
   - 洛谷P1197（星球大战）：动态连通性

> 通过本题可以深入理解并查集处理复杂关系的能力，其核心在于巧妙设计数据表示和关系映射。三倍空间的扩展域方法虽然增加空间开销，但极大简化了关系维护的逻辑复杂度。

---
处理用时：65.15秒
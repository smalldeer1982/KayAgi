# 题目信息

# [THUPC 2023 决赛] 大纲

## 题目描述

小 I、小 O 和小 N 是 ION 大纲的编写者，小 I 负责给每个知识点定难度。

ION 大纲计划列入 $n$ 个知识点，其中小 I 按照自己的认识给其中部分知识点定好了难度，还有部分知识点没有定难度。

知识点之间有依赖关系，这个依赖关系恰好构成了一棵以 $1$ 为根的外向树，知识点 $x$ 指向知识点 $y$ 表示 $x$ 依赖 $y$。**依赖关系不具有传递性。**

你需要告诉小 I 目前确定下来的难度是否合理。我们认为确定下来的难度是合理的当且仅当存在一个给所有未确定难度的知识点确定难度的方式，使得以下所有条件成立：

- 每个知识点的难度都是非负整数；
- 对于每个依赖其他知识点的知识点 $x$，设 $\max_x$ 为 $x$ 依赖的知识点中难度的最大值，则如果 $x$ 恰依赖一个难度为 $\max_x$ 的知识点，那么知识点 $x$ 的难度为 $\max_x$，否则为 $\max_x+1$。**对于不依赖其他知识点的知识点，没有其他限制。**

## 说明/提示

### 样例 1 解释

对于第一组测试数据，将知识点 $2$ 的难度定为 $0$ 即满足条件。

对于第二组测试数据，无论如何指定知识点 $2$ 的难度，知识点 $1$ 的难度会产生矛盾。

### 数据规模与约定

对于所有测试数据，$1 \le T \le 10^5$，$2 \le n \le 10^5$，$-1 \le a_i \le 10^9$，$1 \le u,v \le n$。  
保证单个测试点中所有测试数据的 $n$ 的和不超过 $2 \times 10^5$，每组测试数据输入的所有边构成一棵以 $1$ 为根的外向树。

### 后记

大纲发表了。若干天后，小 I 给 ION 比赛投题，却发现有人偷偷改了一笔难度表，导致他的题目超纲。于是小 I 只能把题投给 CPUHT。

### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023> 查看。

## 样例 #1

### 输入

```
2
3
0 -1 0
1 2
2 3
3
0 -1 0
1 2
1 3
```

### 输出

```
Reasonable
Unreasonable
```

# AI分析结果


### 💡 Kay的C++算法解析：THUPC 2023 决赛 - 大纲 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：树形动态规划/树形贪心

🗣️ **初步分析**：
> 解决本题的关键在于理解树形依赖关系中的**值传递规则**。想象一棵倒置的大树（根在上），每个树枝末梢（叶子）的值会影响上层树枝的值——就像水从叶尖流向树根，途中会因分支数量改变流速（值的变化规则）。  
> 核心算法流程：
> - **自底向上计算**：从叶子节点开始，每个节点根据子节点的值计算自己的取值范围（下界）和固定状态。
> - **规则处理**：若子节点最大值唯一，当前节点值=最大值；否则=最大值+1。
> - **可视化设计**：动画将用像素方块表示节点，颜色区分状态（绿色=固定值，黄色=可变值）。关键步骤高亮显示：子节点最大值计算（像素聚合效果）、规则触发时的+1动画（像素爆炸特效），冲突时闪烁红光。复古8-bit音效（"叮"=值更新，"胜利"=整树合法）增强反馈。

---

#### 2. 精选优质题解参考
**题解一（作者：y_kx_b）**  
* **点评**：思路清晰直击核心——用`ub[]`标记节点值是否可增大，完美处理未赋值节点的灵活性。代码中`flag`变量巧妙追踪子节点可变状态，边界处理严谨（如叶子节点初始化）。亮点在于用**单一标记替代复杂区间维护**，显著降低实现难度。竞赛实战性强，递归逻辑简洁（20行核心DFS），但需注意无向图建双向边后需避免父节点回溯。

**题解二（作者：SIXIANG32）**  
* **点评**：创新性引入`Right[]`标记记录节点确定性状态，通过`f[]`维护下界值。代码规范性优秀（模块化DFS），调试心得极具参考价值——强调手玩小样例验证性质。亮点在**确定性传播思想**：当子节点全固定时父节点必须精确匹配计算值，否则允许弹性。实践时需注意树链特判（如单节点根），变量名`Right`可优化为`isFixed`提升可读性。

---

#### 3. 核心难点辨析与解题策略
1. **难点：状态定义模糊**  
   * **分析**：节点值依赖子节点动态规则，未赋值时取值范围无限（如叶子可∈[0,∞]）。优质题解用`下界+固定标记`（y_kx_b）或`确定性标记`（SIXIANG32）替代复杂区间，避免上界误判。  
   * 💡 **学习笔记**：树形DP中，标记法比区间维护更适应无限取值场景。

2. **难点：规则触发条件复杂**  
   * **分析**：最大值唯一性判断需精确计数。解决方案：递归时同步统计子节点下界最大值`maxn`及其出现次数`cnt`，通过`maxn + (cnt>1)`计算父节点下界。  
   * 💡 **学习笔记**：计数器与最大值同步更新可优化为单次遍历（见通用代码）。

3. **难点：已/未赋值节点混合处理**  
   * **分析**：已赋值节点需严格校验，未赋值节点需保留弹性。策略：已赋值节点校验`值≥下界`，且当子节点全固定时必须`值==下界`；未赋值节点直接设值为下界，并根据子节点弹性传递标记。  
   * 💡 **学习笔记**：赋值状态和子节点弹性共同决定父节点约束强度。

✨ **解题技巧总结**  
- **规则转化**：将"最大值唯一性"转化为`下界+计数器`的数学表达。  
- **弹性传递**：用布尔标记（`ub[]`或`!isFixed`）记录值可变性，自底向上传播。  
- **防御性校验**：已赋值节点需双重校验（≥下界+子节点全固定时需精确匹配）。  

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合y_kx_b与SIXIANG32思路，保留标记法核心并优化变量名。
* **完整核心代码**：
```cpp
#include <vector>
using namespace std;
const int N = 1e5 + 10, INF = 1e9 + 1000;
vector<int> G[N];
int val[N]; // 节点当前值
bool isFlexible[N]; // 节点值是否可增大

bool dfs(int u, int parent) {
    int max_child = -1, cnt = 0;
    bool hasFlexChild = false;
    for (int v : G[u]) {
        if (v == parent) continue;
        if (!dfs(v, u)) return false;
        if (val[v] > max_child) max_child = val[v], cnt = 1;
        else if (val[v] == max_child) cnt++;
        hasFlexChild |= isFlexible[v];
    }
    if (cnt == 0) { // 叶子节点
        if (val[u] == -1) val[u] = 0, isFlexible[u] = true;
        return true;
    }
    int min_val = max_child + (cnt > 1); // 计算下界
    if (val[u] != -1) {
        if (val[u] < min_val) return false;
        if (!hasFlexChild && val[u] != min_val) return false;
    } else {
        val[u] = min_val;
        isFlexible[u] = hasFlexChild; // 弹性传递
    }
    return true;
}
```
* **代码解读概要**：  
  > 1. **初始化**：`val[u]`读入初始值（-1为未赋值），叶子节点未赋值时设0并标记弹性。  
  > 2. **递归子节点**：统计子节点值最大值`max_child`及其出现次数`cnt`，并记录是否存在弹性子节点。  
  > 3. **计算下界**：`min_val = max_child + (cnt>1)` 体现核心规则。  
  > 4. **校验/赋值**：已赋值节点校验值有效性；未赋值节点设值为下界并继承弹性状态。

**题解一（y_kx_b）片段赏析**  
* **亮点**：弹性标记传递逻辑清晰，避免复杂区间运算。  
* **核心代码**：
  ```cpp
  int min_val = max_child + (cnt > 1);
  if (val[u] != -1) {
      if (val[u] < min_val) return false;
      if (!hasFlexChild && val[u] != min_val) return false; // 关键校验
  } else {
      val[u] = min_val;
      isFlexible[u] = hasFlexChild; // 弹性继承
  }
  ```
* **代码解读**：  
  > 第2行：核心下界计算。  
  > 第4行：`!hasFlexChild`时子节点全固定，当前节点值必须精确匹配`min_val`。  
  > 第7行：未赋值节点继承子节点弹性状态，允许后续调整。  
* 💡 **学习笔记**：弹性标记像"多米诺骨牌"，一旦子节点可调，父节点随之解封。

**题解二（SIXIANG32）片段赏析**  
* **亮点**：确定性标记`isFixed`反向管理约束强度。  
* **核心代码**：
  ```cpp
  if (!hasFlexChild) { // 子节点全固定
      if (val[u] != -1) {
          if (val[u] != min_val) return false;
          else isFixed[u] = true;
      } else {
          val[u] = min_val;
          isFixed[u] = true; // 固定当前节点
      }
  } else { // 存在弹性子节点
      if (val[u] != -1) {
          if (val[u] < min_val) return false;
          isFixed[u] = true; // 赋值即固定
      } else val[u] = min_val; // 保留下界
  }
  ```
* **代码解读**：  
  > 第2行：子节点无弹性时，父节点值必须固定为`min_val`。  
  > 第9行：存在弹性子节点时，已赋值节点自我固定（不再受子节点后续变化影响）。  
* 💡 **学习笔记**：确定性标记实现"责任隔离"，赋值即锁定自身状态。

---

#### 5. 算法可视化：像素动画演示
* **主题**：8-bit风格"树形解谜之旅"，节点为可破坏砖块，值更新触发像素特效。  
* **核心流程**：  
  1. **场景初始化**：  
     - 树结构以棕褐色像素方块呈现，叶子节点闪烁绿光（已赋固定值）或黄光（未赋值）。  
     - 控制面板：方向键移动光标，A键（步进），B键（自动播放），滑块调速。  
  2. **递归过程可视化**：  
     - 选中节点边框变红，子节点值以气泡形式显示（最大值标红）。  
     - 规则触发：若`cnt>1`，触发"像素爆炸"（最大值子节点闪红，+1符号弹出）。  
  3. **冲突反馈**：校验失败时节点闪烁红光，8-bit"失败"音效（短促哔声）。  
  4. **弹性标记传播**：弹性节点显示波纹动画，非弹性节点显示锁图标。  
* **音效设计**：  
  - 值更新：NES风格"叮"声（频率随值增大升高）。  
  - 递归完成：FC游戏过关音效。  
  - 背景音乐：《松鼠大作战》循环BGM。  

---

#### 6. 拓展练习与相似问题思考
* **技巧迁移**：  
  树形DP中弹性标记法可用于：  
  1. 树形背包容量浮动优化  
  2. 依赖约束下的最值分配问题  
  3. 树形结构延迟确认决策  
* **洛谷推荐**：  
  1. **P2015 二叉苹果树**（树形DP基础）  
     🗣️ *巩固父子依赖关系建模，理解"保留枝干"如何转化为"保留子节点"。*  
  2. **P2585 三色二叉树**（状态约束传递）  
     🗣️ *练习多状态约束传递，类比本题弹性标记设计。*  
  3. **P3177 树上染色**（最值分配+子树影响）  
     🗣️ *拓展弹性边界思想，处理代价函数随子树变化场景。*  

---

#### 7. 学习心得与经验分享
> **经验摘录（y_kx_b）**：  
> *"细节有点多，卡了一天... 子节点弹性状态传递容易漏判，建议画3层满二叉树模拟。"*  
>   
> **点评**：调试树形DP时，**小规模满二叉树**是最佳测试模型（覆盖父子/兄弟节点交互）。关键断点：  
> 1. 叶子节点初始化后弹性标记  
> 2. 双子节点最大值相同时+1规则触发  
> 3. 已赋值节点遭遇全固定子节点时的强约束校验  

---

通过本指南，你已掌握树形DP中弹性标记法的核心思想。记住：**树是倒着解的，水（值）从叶尖流向树根，弹性标记是流动的许可证。** 下次遇到依赖约束的树形问题，不妨先问自己："我的标记够弹性吗？"

---
处理用时：263.08秒
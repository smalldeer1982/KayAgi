# 题目信息

# [KOI 2021 Round 1] 两个团队

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

某公司的组织架构可以用一棵有根树（rooted tree）来表示。树中的每个节点表示一名员工，边表示直属上下级关系。每位员工从 $1$ 到 $N$ 编号，其中编号 $1$ 的员工是公司的总裁，即树的根节点。每位员工都有一个整数形式的“能力值”，该能力值可能为负数。

下面是一棵示意组织树的例子，节点内的数字表示员工编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/yblc9z43.png)

现在希望从中选择若干人担任“团队负责人”。每位团队负责人必须组成自己的团队，团队必须满足以下条件：

1. 团队成员必须是该负责人下属员工（不一定是直属下属）。例如，如果员工 $3$ 是负责人，那么员工 $8$ 或 $11$ 可以是团队成员，但员工 $1$ 或 $9$ 不可以。
2. 如果某员工被包含为团队成员，那么该员工的直属上司也必须被包含为团队成员（负责人除外）。例如，若员工 $3$ 是负责人，则团队为 $\{3, 6, 11\}$ 是合法的，但 $\{3, 8, 11\}$ 是不合法的，因为员工 $11$ 的上司 $6$ 没有被包含。
3. 团队的得分定义为团队负责人及所有成员的能力值总和，团队成员的选择必须使团队得分最大。（若得分最大的团队组成不唯一，可任选其一。）例如，在所有员工的能力值均为正的情况下，若员工 $3$ 被选为负责人，则其团队必须为 $\{3, 6, 7, 8, 11, 12\}$，其中任何一人缺席都不被允许。
4. 员工不能同时属于两个团队（包括不能作为另一个团队的负责人）。也就是说，若某员工 $A$ 是负责人，其下属 $B$ 由于第 3 条必须包含进 $A$ 的团队，则 $A$ 和 $B$ 都不能被选为负责人。

公司最终希望选出两名团队负责人，组成两个团队，使这两个团队的得分总和（即所有成员能力值之和的总和）最大。

请你编写一个程序，计算在满足所有约束条件的前提下，这两个团队得分之和的最大值。

输入保证一定存在合法的两个团队的构成方式。

## 说明/提示

**约束条件**

- $2 \leq N \leq 200\,000$
- 每名员工的能力值在 $-1\,000\,000\,000$ 到 $1\,000\,000\,000$ 之间
- 除员工 $1$ 外的每位员工 $i$ 的直属上司编号不超过 $i - 1$
- 输入保证一定可以构成符合要求的两个团队

**子任务**

1. （17 分）所有员工的能力值均为正数  
2. （12 分）$N \leq 5\,000$，且员工 $i$ 的直属上司为 $i - 1$（员工 $1$ 除外）  
3. （20 分）员工 $i$ 的直属上司为 $i - 1$（员工 $1$ 除外）  
4. （16 分）$N \leq 400$  
5. （17 分）$N \leq 5\,000$  
6. （18 分）无附加约束条件

## 样例 #1

### 输入

```
4
3 -1
-2 1
2 2
-1 1```

### 输出

```
5```

# AI分析结果


### 💡 Kay的C++算法解析：[KOI 2021 Round 1] 两个团队 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：树形动态规划（Tree DP）  
🗣️ **初步分析**：  
> 解决"两个团队"问题就像在一棵公司树中圈出两个互不重叠的高价值领地。树形DP的核心思想是**自底向上汇总信息**：每个节点向父节点报告自己能为领地贡献的价值。  
> - 关键难点在于设计状态表示子树中不同的连通块信息，特别是两个互不相交的连通块。题解通过维护三个状态（`f`/`g`/`max_k`）巧妙解决。  
> - 可视化设计：将树结构转为像素化RPG技能树。DFS时节点闪烁变色（`f`值用绿色深浅表示，`g`值用蓝色），关键更新时显示数值动画，答案更新时覆盖彩色区块并播放胜利音效。

---

#### 2. 精选优质题解参考
**题解一（来源：sLMxf）**  
* **点评**：思路直击核心——用三个状态(`f`,`g`,`max_k`)覆盖子树信息。代码简洁高效（`f[x]`表示选x的连通块，`g[x]`表示与x不交的连通块），变量命名清晰（如`maxx`/`cmax`记录极值）。正确处理负权值（初始化`-inf`），时间复杂度O(n)完美适配20万数据规模，竞赛实用性强。

---

#### 3. 核心难点辨析与解题策略
1. **状态设计**  
   * **难点**：如何表示子树中两个互斥连通块  
   * **分析**：题解设计`f[x]`(选x的连通块)、`g[x]`(与x不交的块)、`max_k[x]`(子树最大块)，全面覆盖可能情况  
   * 💡 **学习笔记**：树形DP的状态要像"收纳盒"——分类存放子树信息  

2. **状态转移**  
   * **难点**：子节点`f[v]`正负影响父节点更新逻辑  
   * **分析**：`f[v]>0`时加入父连通块（`f[x]+=f[v]`），否则用`max_k[v]`更新`g[x]`  
   * 💡 **学习笔记**：转移方程是"决策说明书"——明确每种情况的处理规则  

3. **答案更新**  
   * **难点**：确保两个连通块全局最优且不重叠  
   * **分析**：用`g[x]+f[x]`(同一子树)或`maxx+cmax`(不同子树)更新答案  
   * 💡 **学习笔记**：答案可能产生于任意节点——需在DFS中动态更新  

✨ **解题技巧总结**  
- **问题分解**：将大树拆解为子树递归处理  
- **极值维护**：用`maxx`/`cmax`高效获取子树前二大值  
- **边界防御**：负无穷初始化预防负权值干扰  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
const long long inf = 1e18;
int w[200005], max_k[200005], f[200005], g[200005];
long long ans = -inf;
vector<int> G[200005];

void dfs(int x) {
    int maxx = -inf, cmax = -inf; // 记录子树max_k的极值
    g[x] = max_k[x] = -inf;       // 初始化
    f[x] = w[x];                  // 基础值：x自身权值
    
    for (auto v : G[x]) {
        dfs(v);
        if (f[v] > 0) {           // 子连通块有价值则合并
            f[x] += f[v];
            g[x] = max(g[x], g[v]);
        } else {                  // 否则保留子树的独立块
            g[x] = max(g[x], max_k[v]);
        }
        // 更新极值 (用于maxx+cmax)
        if (max_k[v] >= maxx) cmax = maxx, maxx = max_k[v];
        else if (max_k[v] > cmax) cmax = max_k[v];
        
        max_k[x] = max(max_k[x], max_k[v]); // 更新子树最大块
    }
    max_k[x] = max(max_k[x], f[x]);         // 当前连通块也可能是最大
    ans = max(ans, max(g[x] + f[x], maxx + cmax)); // 关键！更新全局答案
}

signed main() {
    int n, fa; cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> w[i] >> fa;
        if (i != 1) G[fa].push_back(i);
    }
    dfs(1);
    cout << ans;
}
```

**题解一（sLMxf）片段赏析**  
* **亮点**：负权值防御 + 极值维护高效更新答案  
* **核心片段**：  
  ```cpp
  if (f[v] > 0) { 
      f[x] += f[v];          // 合并高价值子块
      g[x] = max(g[x], g[v]); 
  } else {
      g[x] = max(g[x], max_k[v]); // 保留独立高价值块
  }
  ans = max(ans, max(g[x]+f[x], maxx+cmax)); // 双路径更新
  ```
* **代码解读**：  
  > 当子节点`v`的连通块值`f[v]>0`（正价值），将其合并到父节点`x`的连通块中（`f[x] += f[v]`），如同吸纳优质资产；否则保留该子树的独立高价值块（`max_k[v]`）作为候选。用`maxx`和`cmax`记录所有子树中前两大独立块，确保能发现分布在不同子树的最优双团队组合。  
* 💡 **学习笔记**：极值维护是树形DP优化利器——避免重复遍历子树！

---

#### 5. 算法可视化：像素动画演示
**主题**：像素化RPG技能树探险  
**核心演示**：DFS遍历树 + 状态更新动画 + 双团队区块高亮  

```mermaid
graph LR
    A[开始：像素树初始化] --> B[DFS递归叶子节点]
    B --> C[节点闪烁：状态更新]
    C --> D{子节点f[v]>0？}
    D -->|是| E[绿色箭头：合并连通块]
    D -->|否| F[红色箭头：保留独立块]
    E & F --> G[更新极值maxx/cmax]
    G --> H[答案更新动画]
    H --> I[双色覆盖团队区块+胜利音效]
```

**关键交互设计**：  
1. **像素树构建**：节点显示权值，边为像素化线条（FC风格）  
2. **状态可视化**：  
   - `f[x]`更新：绿色流动动画（值增加时）  
   - `g[x]`更新：蓝色脉冲波纹  
   - 极值更新：节点显示`maxx`/`cmax`徽章  
3. **音效系统**：  
   - 节点访问：8-bit "滴"声  
   - 团队合并：清脆"叮"声 (f[v]>0)  
   - 答案更新：16-bit胜利旋律  
4. **自动演示模式**：  
   - 速度滑块控制DFS步进频率  
   - 完成子树时显示"关卡通过"像素弹窗  

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：  
树形DP维护子树极值的思路适用于：  
1. 树上选不相交路径（如：直径+次直径）  
2. 树形背包问题（多连通块选择）  
3. 带负权的最优子树选取  

**洛谷推荐**：  
1. **P1122 最大子树和**（基础单连通块）  
   → 掌握树形DP的入门基石  
2. **P1273 有线电视网**（树形背包）  
   → 学习多连通块选择的扩展思路  
3. **P2585 [ZJOI2006]三色二叉树**（多状态设计）  
   → 强化状态定义的抽象能力  

---

> 本次题解未发现作者调试心得，但核心代码中的**负无穷初始化**和**极值维护**本身就是宝贵经验——它们像安全网，确保算法在负权丛林中稳健前行！ 🛡️

---
处理用时：169.41秒
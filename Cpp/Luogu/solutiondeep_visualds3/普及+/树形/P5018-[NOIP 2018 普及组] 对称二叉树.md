# 题目信息

# [NOIP 2018 普及组] 对称二叉树

## 题目背景

NOIP2018 普及组 T4

## 题目描述

一棵有点权的有根树如果满足以下条件，则被轩轩称为对称二叉树： 

1.  二叉树； 
2.  将这棵树所有节点的左右子树交换，新树和原树对应位置的结构相同且点权相等。   

下图中节点内的数字为权值，节点外的 $id$ 表示节点编号。  

![](https://cdn.luogu.com.cn/upload/image_hosting/nkln7z1l.png)

现在给出一棵二叉树，希望你找出它的一棵子树，该子树为对称二叉树，且节点数最多。请输出这棵子树的节点数。   

注意：只有树根的树也是对称二叉树。本题中约定，以节点 $T$ 为子树根的一棵“子 树”指的是：节点$T$ 和它的全部后代节点构成的二叉树。 

## 说明/提示

**样例 1 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/4lfen5aa.png)    
最大的对称二叉子树为以节点 $2$ 为树根的子树，节点数为 $1$。   

**样例 2 解释**

![](https://cdn.luogu.com.cn/upload/image_hosting/vhzzc587.png)

最大的对称二叉子树为以节点 $7$ 为树根的子树，节点数为 $3$。 

**数据规模与约定**

共 $25$ 个测试点。    

$v_i ≤ 1000$。 

- 测试点 $1 \sim 3, n ≤ 10$，保证根结点的左子树的所有节点都没有右孩子，根结点的右 子树的所有节点都没有左孩子。 
- 测试点 $4 \sim 8, n ≤ 10$。
- 测试点 $9 \sim 12, n ≤ 10^5$，保证输入是一棵“满二叉树” 。 
- 测试点 $13 \sim 16, n ≤ 10^5$，保证输入是一棵“完全二叉树”。
- 测试点 $17 \sim 20, n ≤ 10^5$，保证输入的树的点权均为 $1$。
- 测试点 $21 \sim 25, n ≤ 10^6$。

本题约定： 

层次：节点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一节 点的层次等于其父亲节点的层次加 $1$。 
 
 树的深度：树中节点的最大层次称为树的深度。 
 
 满二叉树：设二叉树的深度为 $h$，且二叉树有 $2^h-1$ 个节点，这就是满二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/8tof1fxx.png)

完全二叉树：设二叉树的深度为 $h$，除第 $h$ 层外，其它各层的结点数都达到最大 个数，第 $h$ 层所有的结点都连续集中在最左边，这就是完全二叉树。  

![](https://cdn.luogu.com.cn/upload/image_hosting/ibo7js1f.png)

## 样例 #1

### 输入

```
2 
1 3 
2 -1 
-1 -1 
```

### 输出

```
1```

## 样例 #2

### 输入

```
10 
2 2 5 5 5 5 4 4 2 3 
9 10 
-1 -1 
-1 -1 
-1 -1 
-1 -1 
-1 2 
3 4 
5 6 
-1 -1 
7 8```

### 输出

```
3```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP2018 普及组] 对称二叉树 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：递归与树的对称性判断（属于“递归/树处理”分类）


🗣️ **初步分析**：  
解决“对称二叉树”问题，关键在于**递归判断树的对称性**。简单来说，对称二叉树就像“镜子里的树”——把原树的左右子树交换后，每一个节点的位置和权值都和原树完全一致。比如，原树的根节点左子树的左孩子，对应镜子里根节点右子树的右孩子；原树左子树的右孩子，对应镜子里右子树的左孩子。  

**核心思路**：  
要判断以节点`x`为根的子树是否对称，需要满足两点：  
1. 左子树`ls`和右子树`rs`的**大小相同**（结构对称的必要条件）；  
2. 左子树`ls`的左孩子与右子树`rs`的右孩子对称，且左子树`ls`的右孩子与右子树`rs`的左孩子对称（递归判断）。  

**核心难点**：  
- 如何正确设计递归逻辑（交叉比较左右子树）；  
- 如何避免重复计算（预处理子树大小）；  
- 理解暴力递归的时间复杂度（并非O(n²)，而是O(nlogn)）。  

**可视化设计思路**：  
用**8位像素风格**展示树结构（比如根节点在顶部，左右子树向下延伸），用不同颜色标记当前比较的节点对（如左边节点为蓝色，右边对应节点为红色）。当节点权值相等时，颜色变为绿色；不等时变为红色。递归过程中，用“箭头”表示比较方向（比如左子树的左→右子树的右），并伴随“叮”的音效（正确）或“ buzzer”音效（错误）。


## 2. 精选优质题解参考

### 题解一：暴力递归（作者：wsm52，赞19）  
* **点评**：  
  这份题解的思路**极其直白**，直接枚举每个节点作为子树根，递归判断其左右子树是否对称。代码**简洁到极致**（仅30行左右），变量命名清晰（`l[x]`表示x的左孩子，`r[x]`表示右孩子，`son[x]`表示子树大小），非常适合初学者理解递归的核心逻辑。  
  亮点：**递归条件的设计**——`dfs(x,y)`比较x和y是否对称，先判断是否都为空（对称），再判断是否有一个为空（不对称），最后判断权值是否相等，并递归比较交叉子树。这种“由浅入深”的条件判断，完美覆盖了所有边界情况。  
  实践价值：代码可直接用于竞赛，边界处理严谨（比如`-1`表示空节点），且时间复杂度足够通过所有测试点（O(nlogn)）。


### 题解二：剪枝暴力（作者：WsW_，赞8）  
* **点评**：  
  这份题解在暴力递归的基础上，添加了**子树大小剪枝**（`size[lp] != size[rp]`时直接返回false），进一步优化了时间效率。代码结构与题解一类似，但通过`size`数组预处理子树大小，避免了不必要的递归。  
  亮点：**时间复杂度证明**——作者用“启发式合并”的思想，证明了每个节点最多被递归到logn次，总复杂度为O(nlogn)。这种“知其然更知其所以然”的思考，能帮助学习者理解暴力算法的合理性。


### 题解三：哈希法（作者：何俞均，赞52）  
* **点评**：  
  这份题解采用**哈希+欧拉序**的方法，将树的对称性转化为哈希值的比较，时间复杂度为O(n)，适合大数据量的情况。代码虽然较长，但逻辑清晰（预处理两次欧拉序，计算哈希值，然后比较区间哈希）。  
  亮点：**哈希的应用**——通过记录节点的访问顺序（欧拉序），将树的结构转化为字符串，从而用哈希快速比较是否对称。这种“将树结构转化为线性结构”的技巧，在树处理问题中非常常用。


## 3. 核心难点辨析与解题策略

### 1. 关键点1：如何正确设计递归逻辑？  
* **分析**：  
  对称的条件是“交叉比较”——左子树的左孩子对应右子树的右孩子，左子树的右孩子对应右子树的左孩子。比如，判断`x`的左右子树是否对称，需要调用`check(l[x], r[x])`，而`check(a,b)`的逻辑是：  
  - 如果`a`和`b`都为空，返回true；  
  - 如果`a`或`b`有一个为空，返回false；  
  - 如果`a`和`b`的权值不等，返回false；  
  - 否则，递归判断`check(l[a], r[b])`和`check(r[a], l[b])`。  
  这种逻辑完美覆盖了所有对称情况，是递归判断的核心。  

* 💡 **学习笔记**：递归的关键是“分解问题”——把大问题（判断x的子树是否对称）分解为小问题（判断x的左右子树是否对称），并正确处理边界情况。


### 2. 关键点2：为什么暴力递归的时间复杂度是O(nlogn)？  
* **分析**：  
  很多学习者会认为暴力递归是O(n²)，但实际上，由于**子树大小剪枝**（`size[lp] != size[rp]`时直接返回），每个节点最多被递归到logn次。比如，对于满二叉树，第i层的节点子树大小为2^(h-i+1)-1，而第i层有2^(i-1)个节点，总递归次数为O(nlogn)。  

* 💡 **学习笔记**：时间复杂度不是靠“感觉”，而是靠“分析”——通过剪枝减少不必要的计算，暴力算法也能变得高效。


### 3. 关键点3：为什么要预处理子树大小？  
* **分析**：  
  子树大小是判断结构对称的必要条件（如果左右子树大小不同，肯定不对称）。预处理子树大小（用`dfs`遍历一次树，计算每个节点的子树大小），可以避免在递归判断时重复计算，从而优化时间效率。  

* 💡 **学习笔记**：预处理是编程中的常用技巧——将重复计算的结果提前存储，减少后续计算量。


### ✨ 解题技巧总结  
- **递归条件设计**：由浅入深处理边界情况（都为空→有一个为空→权值不等→递归比较）；  
- **子树大小剪枝**：提前计算子树大小，避免不必要的递归；  
- **结构转化**：对于复杂的树结构问题，可以将其转化为线性结构（如哈希、欧拉序），用更简单的方法处理。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（基于wsm52的题解）  
* **说明**：  
  此代码是暴力递归的典型实现，思路清晰，代码简洁，适合初学者理解递归判断的核心逻辑。  

* **完整核心代码**：  
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  const int N=1e6+10;
  int n,v[N],l[N],r[N],son[N]; // son[x]表示x的子树大小
  bool dfs(int x,int y){
      if(x==-1&&y==-1) return true; // 都为空，对称
      if(x==-1||y==-1) return false; // 有一个为空，不对称
      if(v[x]!=v[y]) return false; // 权值不等，不对称
      return dfs(l[x],r[y])&&dfs(r[x],l[y]); // 交叉递归比较
  }
  int count(int x){ // 计算子树大小
      if(x==-1) return 0;
      son[x]=count(l[x])+count(r[x])+1;
      return son[x];
  }
  int main(){
      scanf("%d",&n);
      for(int i=1;i<=n;i++) scanf("%d",&v[i]);
      for(int i=1;i<=n;i++) scanf("%d%d",&l[i],&r[i]);
      count(1); // 预处理子树大小
      int sum=0;
      for(int i=1;i<=n;i++) if(dfs(i,i)) sum=max(sum,son[i]); // 枚举每个节点，判断是否对称
      printf("%d\n",sum);
      return 0;
  }
  ```

* **代码解读概要**：  
  1. **输入处理**：读取节点数、权值、左右孩子；  
  2. **预处理子树大小**：用`count`函数遍历树，计算每个节点的子树大小；  
  3. **枚举判断**：遍历每个节点，用`dfs(i,i)`判断以i为根的子树是否对称（因为对称的根节点的左右子树需要比较，所以`dfs(i,i)`等价于比较i的左子树和右子树）；  
  4. **输出结果**：记录最大的对称子树大小。


### 针对各优质题解的片段赏析

#### 题解一（暴力递归，作者：wsm52）  
* **亮点**：递归条件的完美设计，覆盖所有边界情况。  
* **核心代码片段**：  
  ```cpp
  bool dfs(int x,int y){
      if(x==-1&&y==-1) return true;
      if(x==-1||y==-1) return false;
      if(v[x]!=v[y]) return false;
      return dfs(l[x],r[y])&&dfs(r[x],l[y]);
  }
  ```  
* **代码解读**：  
  - 第一行：如果x和y都为空，说明对称，返回true；  
  - 第二行：如果有一个为空，说明结构不对称，返回false；  
  - 第三行：如果权值不等，说明权值不对称，返回false；  
  - 第四行：递归比较x的左孩子和y的右孩子（对应镜子里的位置），以及x的右孩子和y的左孩子（对应镜子里的位置）。  
* 💡 **学习笔记**：递归的边界条件是“最小的问题”，解决了边界问题，大问题就迎刃而解。


#### 题解二（剪枝暴力，作者：WsW_）  
* **亮点**：子树大小剪枝，优化时间效率。  
* **核心代码片段**：  
  ```cpp
  bool check(int lp,int rp){
      if(!lp&&!rp)return 1;
      if(size[lp]!=size[rp]||v[lp]!=v[rp])return 0; // 子树大小不等，直接返回false
      return check(l[lp],r[rp])&check(r[lp],l[rp]);
  }
  ```  
* **代码解读**：  
  相比题解一，这里添加了`size[lp]!=size[rp]`的判断。如果左右子树大小不同，说明结构肯定不对称，不需要再递归比较，直接返回false。这一步剪枝能大大减少递归次数。  
* 💡 **学习笔记**：剪枝是优化暴力算法的有效手段，只要找到“必要条件”（如子树大小相等），就能避免不必要的计算。


#### 题解三（哈希法，作者：何俞均）  
* **亮点**：将树结构转化为欧拉序，用哈希快速比较。  
* **核心代码片段**：  
  ```cpp
  void dfs(int x) { 
      P[L[x] = ++cnt] = x; 
      if (t[x].ch[0]) dfs(t[x].ch[0]); 
      if (t[x].ch[1]) dfs(t[x].ch[1]); 
      P[R[x] = ++cnt] = x; 
      t[x].size = t[t[x].ch[0]].size + t[t[x].ch[1]].size + 1; 
  }
  ```  
* **代码解读**：  
  这是预处理欧拉序的代码。`L[x]`表示x的进入时间戳，`R[x]`表示x的离开时间戳。欧拉序记录了节点的访问顺序（进入和离开），通过欧拉序的区间哈希，可以快速比较两棵子树的结构和权值是否对称。  
* 💡 **学习笔记**：将树结构转化为线性结构（如欧拉序、遍历序列），是处理树问题的常用技巧，能将复杂的树操作转化为简单的区间操作。


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《镜子里的树》（FC风格）


### 核心演示内容  
展示递归判断以节点`x`为根的子树是否对称的过程，重点演示**交叉比较**的逻辑。


### 设计思路简述  
采用**8位像素风格**（类似《超级马里奥》的画面），用简单的图形和颜色表示树结构：  
- 根节点在屏幕顶部，左右子树向下延伸（左子树在左，右子树在右）；  
- 节点用“方块”表示，权值显示在方块内；  
- 当前比较的节点对用**蓝色**（左子树节点）和**红色**（右子树对应节点）标记；  
- 比较结果用颜色变化表示：相等→**绿色**，不等→**红色**；  
- 递归过程用“箭头”表示比较方向（如左子树的左→右子树的右）。


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕显示一棵像素树（比如样例2中的树），根节点为7（权值4）；  
   - 控制面板有“开始”“单步”“重置”按钮，以及速度滑块；  
   - 8位风格的背景音乐（如《超级马里奥》的背景音乐）开始播放。  

2. **算法启动**：  
   - 点击“开始”按钮，动画开始；  
   - 根节点7的左右子树（节点3和节点4，权值都是5）被标记为蓝色和红色。  

3. **核心比较步骤**：  
   - **第一步**：比较节点3和节点4的权值（都是5），颜色变为绿色，伴随“叮”的音效；  
   - **第二步**：递归比较节点3的左孩子（节点5，权值5）和节点4的右孩子（节点6，权值5），标记为蓝色和红色；  
   - **第三步**：比较节点5和节点6的权值（都是5），颜色变为绿色，伴随“叮”的音效；  
   - **第四步**：递归比较节点5的左右孩子（都为空），返回true；  
   - **第五步**：递归比较节点3的右孩子（都为空）和节点4的左孩子（都为空），返回true；  
   - **第六步**：节点3和节点4的子树对称，返回true；  
   - **第七步**：根节点7的子树对称，节点数为3，显示“胜利”动画（如烟花），伴随胜利音效。  

4. **交互控制**：  
   - **单步执行**：点击“单步”按钮，动画执行一步（比如比较一个节点对）；  
   - **自动播放**：拖动速度滑块，调整动画播放速度（如1x、2x、3x）；  
   - **重置**：点击“重置”按钮，动画回到初始状态。


### 旁白提示（动画中的文字气泡）  
- “现在比较根节点7的左右子树：节点3（左）和节点4（右）”；  
- “节点3和节点4的权值都是5，相等！”；  
- “接下来比较节点3的左孩子（节点5）和节点4的右孩子（节点6）”；  
- “节点5和节点6的权值都是5，相等！”；  
- “节点5和节点6的子树都为空，对称！”；  
- “节点3和节点4的子树对称，根节点7的子树对称！”；  
- “最大对称子树的节点数是3！”。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
递归判断树的对称性的思路，可用于解决以下问题：  
1. **判断两棵树是否同构**（结构相同，权值无关）；  
2. **判断树是否为回文树**（中序遍历序列是回文）；  
3. **寻找树中的对称子结构**（如对称的子树、对称的路径）。


### 练习推荐（洛谷）  
1. **洛谷 P1827 [USACO3.4] 美国血统 American Heritage**  
   - 🗣️ **推荐理由**：这道题需要根据前序遍历和中序遍历重构二叉树，涉及树的遍历顺序和结构处理，能帮助你巩固树的结构转化技巧。  

2. **洛谷 P2585 [ZJOI2006] 三色二叉树**  
   - 🗣️ **推荐理由**：这道题需要用动态规划解决树的着色问题，涉及子树状态的转移，能帮助你理解树的动态规划思路。  

3. **洛谷 P3379 【模板】最近公共祖先（LCA）**  
   - 🗣️ **推荐理由**：这道题需要预处理树的祖先信息，涉及树的遍历和预处理技巧，能帮助你巩固树的预处理方法。  


## 7. 学习心得与经验分享（若有）  
- **来自wsm52的经验**：“递归的关键是处理好边界情况，比如都为空、有一个为空的情况。只要边界情况处理好了，递归逻辑就不会错。”  
  - **点评**：这位作者的经验很实用。递归的边界情况是“最小的问题”，解决了边界问题，大问题就迎刃而解。在编写递归代码时，一定要先考虑边界情况。  

- **来自WsW_的经验**：“子树大小剪枝能大大优化时间效率，因为结构对称的必要条件是子树大小相等。”  
  - **点评**：剪枝是优化暴力算法的有效手段，只要找到“必要条件”，就能避免不必要的计算。在解决树问题时，预处理子树大小是一个常用的剪枝技巧。  


## 结语  
本次关于“对称二叉树”的C++解题分析就到这里。希望这份学习指南能帮助你理解递归判断树对称性的核心逻辑，掌握树处理的常用技巧。记住，编程能力的提升在于**持续练习**和**深入思考**——多写代码，多分析问题，你一定会越来越厉害！💪  

如果有任何问题，欢迎随时向我提问，我会尽力帮助你！😊

---
处理用时：174.02秒
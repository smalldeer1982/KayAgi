# 题目信息

# [蓝桥杯 2013 国 C] 横向打印二叉树

## 题目背景

二叉树可以用于排序。

## 题目描述

其原理很简单：对于一个排序二叉树添加新节点时，先与根节点比较，若小则交给左子树继续处理，否则交给右子树。

当遇到空子树时，则把该节点放入那个位置。

比如，`10 8 5 7 12 4` 的输入顺序，应该建成二叉树如图 $1$ 所示。

本题目要求：根据已知的数字，建立排序二叉树，并在标准输出中横向打印该二叉树。


## 说明/提示

样例解释 1：

![](https://cdn.luogu.com.cn/upload/image_hosting/4z42ybq4.png)

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
10 8 5 7 12 4```

### 输出

```
...|-12
10-|
...|-8-|
.......|...|-7
.......|-5-|
...........|-4```

## 样例 #2

### 输入

```
10 5 20```

### 输出

```
...|-20
10-|
...|-5```

## 样例 #3

### 输入

```
5 10 20 8 4 7```

### 输出

```
.......|-20
..|-10-|
..|....|-8-|
..|........|-7
5-|
..|-4```

# AI分析结果

# 💡 Kay的C++算法解析：横向打印二叉树 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟+树形遍历（右根左）`  

🗣️ **初步分析**：  
解决“横向打印二叉树”问题，关键在于**模拟二叉树左旋转90度后的结构**（想象把树“躺下来”，根节点在中间，右子树向上延伸，左子树向下延伸），并通过**右根左遍历**（先访问右子树，再根节点，最后左子树）确定每个节点的行位置（第几个被访问就占第几行）。  

- **核心思路**：  
  1. 构建二叉搜索树（BST）：按输入顺序插入节点，小的放左子树，大的放右子树。  
  2. 模拟打印格式：用字符数组存储每个位置的字符（`.`表示空白，`|`表示竖线，`-`表示横线），通过递归遍历填充每个节点的字符（如`|-12`、`10-|`）。  
  3. 处理连接关系：父子节点之间的竖线`|`需要根据行号范围填充，避免被`.`覆盖。  

- **核心难点**：  
  - 如何确定每个节点的行号（遍历顺序）和列位置（前面的字符数）？  
  - 如何正确填充节点的字符（如根节点没有前缀`|-`，叶子节点没有后缀`-|`）？  
  - 如何处理父子节点之间的竖线`|`，确保不被空白覆盖？  

- **可视化设计思路**：  
  用**8位像素风格**模拟二叉树“躺下来”的结构，节点用不同颜色的像素块表示（如根节点是黄色，右子树是蓝色，左子树是绿色）。遍历过程中，逐步填充字符数组：  
  - 节点被访问时，用“滑入”动画显示其字符（如`10-|`）；  
  - 连接父子节点的`|`用“闪烁”动画显示，提示这是树枝；  
  - 音效：插入节点时播放“叮”的声音，填充字符时播放“嗒”的声音，完成时播放“胜利”音效。  


## 2. 精选优质题解参考

### 题解一：（来源：冷却心）  
* **点评**：  
  这份题解的思路非常清晰，用**递归中序遍历（右根左）**确定每个节点的行号，通过字符数组`mp`存储打印内容。亮点在于**处理连接竖线**的逻辑：用`line`数组记录每个节点的行号，当有左/右子树时，在对应的行范围和列位置填充`|`，避免被`.`覆盖。代码中的`Add`变量（增加的空格数）计算准确，考虑了根节点和叶子节点的特殊情况，边界处理严谨。  

### 题解二：（来源：Wing_）  
* **点评**：  
  此题解的结构最清晰，分`insert`（构建BST）、`print`（填充字符数组）、`work`（处理连接竖线）三个函数。`print`函数用`sum`参数记录节点前的字符数，正确计算子节点的`sum`（`sum+3+cnt`，其中`3`是`|-`和`-|`的长度，`cnt`是数字的位数）。`work`函数通过父子节点的行号和列位置，循环填充`|`，解决了连接问题。代码可读性强，变量名（如`tr[u].h`表示行号，`tr[u].z`表示列位置）含义明确，适合初学者学习。  

### 题解三：（来源：ChampionCyan）  
* **点评**：  
  此题解用**循环插入**代替递归，更高效（避免递归栈溢出）。`work`函数处理字符数组的逻辑与前两个题解类似，但代码更简洁（如用`eof`标记行结束）。亮点在于`front`变量的计算（`(p==1?0:2)+num.size()+1`），正确处理了根节点的前缀问题。此外，`line`数组记录行号，处理连接竖线的逻辑正确，适合学习循环插入和简洁代码风格。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：确定节点的行号和列位置**  
* **分析**：  
  行号由**右根左遍历顺序**决定（第几个被访问就占第几行），例如样例1中的`12`是第一个被访问的，占第1行；`10`是第二个，占第2行。列位置由父节点的列位置加上父节点的长度和连接符的长度（如父节点的`sum`是`0`，数字长度是`2`，则子节点的`sum`是`0+3+2=5`，其中`3`是`|-`和`-|`的长度）。  
* 💡 **学习笔记**：行号是遍历顺序，列位置是父节点的“延伸”。  

### 2. **关键点2：填充节点的字符**  
* **分析**：  
  每个节点的字符格式是：`[前缀]数字[后缀]`。前缀是`|-`（根节点没有），后缀是`-|`（叶子节点没有）。例如根节点`10`的格式是`10-|`（有后缀，因为有子节点），叶子节点`4`的格式是`....|-4`（没有后缀）。  
* 💡 **学习笔记**：特殊情况（根、叶子）需要单独处理。  

### 3. **关键点3：处理连接父子节点的竖线`|`**  
* **分析**：  
  父子节点之间的竖线`|`位于子节点前缀`|-`的`|`位置（列位置是`z-2`，其中`z`是子节点的列位置）。需要根据父子节点的行号范围（如父节点行号是`uh`，左子节点行号是`lh`，则需要填充`uh`到`lh`行的`z-2`列）填充`|`，避免被`.`覆盖。  
* 💡 **学习笔记**：竖线的位置和行范围是关键，需要用行号数组记录。  

### ✨ 解题技巧总结  
- **技巧A：用字符数组存储打印内容**：避免直接输出，方便后续修改（如填充竖线）。  
- **技巧B：递归遍历顺序（右根左）**：确保节点的行号符合横向打印的结构。  
- **技巧C：记录行号和列位置**：方便处理连接竖线，避免逻辑混乱。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合Wing_和ChampionCyan的题解，提取清晰的核心实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  using namespace std;
  const int N = 110;
  struct Node {
      int val, h, z, l, r; // 数值、行号、列位置、左子树、右子树
  } tr[N];
  int idx = 0, root = 0, h = 0;
  char c[110][10010]; // 字符数组

  void insert(int &u, int x) { // 插入节点（递归）
      if (!u) {
          u = ++idx;
          tr[u].val = x;
          return;
      }
      if (x < tr[u].val) insert(tr[u].l, x);
      else insert(tr[u].r, x);
  }

  void print(int u, int sum) { // 填充字符数组（右根左遍历）
      if (!u) return;
      int t = tr[u].val, cnt = 0;
      char num[10];
      while (t) num[++cnt] = t % 10 + '0', t /= 10;
      reverse(num + 1, num + cnt + 1);
      print(tr[u].r, sum + 3 + cnt); // 递归右子树
      h++;
      tr[u].h = h;
      if (sum) { // 非根节点，添加前缀`|-`
          for (int i = 1; i <= sum - 2; i++) c[h][i] = '.';
          c[h][sum - 1] = '|', c[h][sum] = '-';
      }
      tr[u].z = sum + 1; // 列位置
      for (int i = 1; i <= cnt; i++) c[h][sum + i] = num[i]; // 填充数字
      if (tr[u].l || tr[u].r) c[h][sum + cnt + 1] = '-', c[h][sum + cnt + 2] = '|'; // 非叶子节点，添加后缀`-|`
      print(tr[u].l, sum + 3 + cnt); // 递归左子树
  }

  void work(int u) { // 处理连接竖线
      if (!u) return;
      int uh = tr[u].h;
      if (tr[u].r) { // 连接右子树
          int rh = tr[tr[u].r].h, rz = tr[tr[u].r].z;
          for (int i = rh; i <= uh; i++) c[i][rz - 2] = '|';
      }
      if (tr[u].l) { // 连接左子树
          int lh = tr[tr[u].l].h, lz = tr[tr[u].l].z;
          for (int i = uh; i <= lh; i++) c[i][lz - 2] = '|';
      }
      work(tr[u].l), work(tr[u].r); // 递归处理子树
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      int x;
      while (cin >> x) insert(root, x);
      print(root, 0);
      work(root);
      for (int i = 1; i <= h; i++) {
          for (int j = 1; c[i][j]; j++) cout << c[i][j];
          cout << "\n";
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. `insert`函数：递归插入节点，构建BST。  
  2. `print`函数：右根左遍历，填充每个节点的字符（前缀、数字、后缀），记录行号`h`和列位置`z`。  
  3. `work`函数：处理父子节点之间的竖线`|`，根据行号范围和列位置填充。  
  4. `main`函数：读取输入，调用`insert`、`print`、`work`，输出字符数组。  

### 针对各优质题解的片段赏析  

#### 题解二（来源：Wing_）  
* **亮点**：`print`函数用`sum`参数记录节点前的字符数，正确计算子节点的`sum`。  
* **核心代码片段**：  
  ```cpp
  void print(int u, int sum) {
      if (!u) return;
      // 处理右子树
      print(tr[u].r, sum + 3 + cnt);
      // 填充当前节点
      if (sum) {
          for (int i = 1; i <= sum - 2; i++) c[h][i] = '.';
          c[h][sum - 1] = '|', c[h][sum] = '-';
      }
      // 处理左子树
      print(tr[u].l, sum + 3 + cnt);
  }
  ```  
* **代码解读**：  
  - `sum`是当前节点前的字符数，例如根节点的`sum`是`0`，右子节点的`sum`是`0+3+2=5`（`3`是`|-`和`-|`的长度，`2`是根节点数字的位数）。  
  - 填充当前节点时，非根节点需要添加前缀`|-`（`sum-1`列是`|`，`sum`列是`-`）。  
* 💡 **学习笔记**：`sum`参数是传递列位置的关键，需要正确计算。  

#### 题解三（来源：ChampionCyan）  
* **亮点**：用循环插入代替递归，更高效。  
* **核心代码片段**：  
  ```cpp
  inline void insert(int x, int p) {
      while (node[p] != -1) {
          if (x < node[p]) p = lc(p);
          else p = rc(p);
      }
      node[p] = x;
  }
  ```  
* **代码解读**：  
  - 循环查找插入位置，直到找到空节点（`node[p] == -1`），然后插入。  
  - 比递归更高效，避免了递归栈的开销。  
* 💡 **学习笔记**：循环插入是构建BST的常用优化方式。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：`像素树的“躺平”之旅`  
**风格**：8位像素风（类似FC游戏），背景是浅灰色，节点是彩色像素块（根节点黄色，右子树蓝色，左子树绿色），字符是白色像素。  

### 核心演示内容  
1. **初始化**：屏幕显示一棵“躺平”的二叉树框架（根节点在中间，右子树向上，左子树向下），控制面板有“开始”、“单步”、“重置”按钮，速度滑块。  
2. **插入节点**：输入数字时，节点从屏幕右侧滑入，插入到正确位置（如插入`10`，根节点变黄；插入`8`，左子节点变绿），伴随“叮”的音效。  
3. **遍历填充**：右根左遍历开始，每个节点被访问时，用“滑入”动画显示其字符（如`12`滑入第1行，显示`...|-12`），伴随“嗒”的音效。  
4. **连接竖线**：父子节点之间的竖线`|`用“闪烁”动画显示（如`10`和`8`之间的竖线闪烁），提示这是树枝。  
5. **完成**：所有节点填充完毕，屏幕显示“完成！”，伴随“胜利”音效。  

### 交互设计  
- **单步执行**：点击“单步”按钮，逐个节点填充，观察每一步的变化。  
- **自动播放**：拖动速度滑块调整播放速度，自动演示整个过程。  
- **重置**：点击“重置”按钮，清空屏幕，重新开始。  

### 设计思路  
- **像素风格**：营造复古游戏氛围，降低学习压力。  
- **动画效果**：用“滑入”、“闪烁”等动画突出关键步骤，帮助理解遍历顺序和连接关系。  
- **音效**：用不同的音效强化操作记忆（如插入节点的“叮”，填充字符的“嗒”）。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
`模拟+树形遍历`的思路不仅能解决横向打印二叉树问题，还能解决：  
- 二叉树的各种遍历（先序、中序、后序）输出；  
- 二叉树的可视化问题（如竖向打印、层序打印）；  
- 树形结构的模拟问题（如文件系统的目录结构打印）。  

### 练习推荐 (洛谷)  
1. **洛谷 P1030 求先序遍历**  
   🗣️ **推荐理由**：练习二叉树的遍历顺序（先序、中序、后序），巩固树形遍历的逻辑。  
2. **洛谷 P1305 新二叉树**  
   🗣️ **推荐理由**：练习构建二叉树（根据先序遍历和中序遍历），加深对树形结构的理解。  
3. **洛谷 P2058 海港**  
   🗣️ **推荐理由**：练习模拟和顺序处理，虽然不是树形问题，但模拟思路类似，有助于提升代码能力。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自 Wing_)**：“我在处理连接竖线时，一开始没有考虑行号范围，导致竖线被`.`覆盖。后来通过记录每个节点的行号，循环填充对应的行范围，才解决了这个问题。”  
**点评**：这位作者的经验很典型。在模拟问题中，**记录关键信息（如行号、列位置）**是解决问题的关键。遇到问题时，不妨先记录这些信息，再思考如何处理。  


## 结语  
本次关于“横向打印二叉树”的分析就到这里。希望这份指南能帮助你理解树形遍历和模拟的核心逻辑。记住，模拟问题的关键是**分解步骤**（如构建树、填充字符、处理连接），并**记录关键信息**（如行号、列位置）。下次我们再一起探索新的编程挑战！💪

---
处理用时：161.49秒
# 题目信息

# [THUPC 2023 决赛] 大纲

## 题目描述

小 I、小 O 和小 N 是 ION 大纲的编写者，小 I 负责给每个知识点定难度。

ION 大纲计划列入 $n$ 个知识点，其中小 I 按照自己的认识给其中部分知识点定好了难度，还有部分知识点没有定难度。

知识点之间有依赖关系，这个依赖关系恰好构成了一棵以 $1$ 为根的外向树，知识点 $x$ 指向知识点 $y$ 表示 $x$ 依赖 $y$。**依赖关系不具有传递性。**

你需要告诉小 I 目前确定下来的难度是否合理。我们认为确定下来的难度是合理的当且仅当存在一个给所有未确定难度的知识点确定难度的方式，使得以下所有条件成立：

- 每个知识点的难度都是非负整数；
- 对于每个依赖其他知识点的知识点 $x$，设 $\max_x$ 为 $x$ 依赖的知识点中难度的最大值，则如果 $x$ 恰依赖一个难度为 $\max_x$ 的知识点，那么知识点 $x$ 的难度为 $\max_x$，否则为 $\max_x+1$。**对于不依赖其他知识点的知识点，没有其他限制。**

## 说明/提示

### 样例 1 解释

对于第一组测试数据，将知识点 $2$ 的难度定为 $0$ 即满足条件。

对于第二组测试数据，无论如何指定知识点 $2$ 的难度，知识点 $1$ 的难度会产生矛盾。

### 数据规模与约定

对于所有测试数据，$1 \le T \le 10^5$，$2 \le n \le 10^5$，$-1 \le a_i \le 10^9$，$1 \le u,v \le n$。  
保证单个测试点中所有测试数据的 $n$ 的和不超过 $2 \times 10^5$，每组测试数据输入的所有边构成一棵以 $1$ 为根的外向树。

### 后记

大纲发表了。若干天后，小 I 给 ION 比赛投题，却发现有人偷偷改了一笔难度表，导致他的题目超纲。于是小 I 只能把题投给 CPUHT。

### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023> 查看。

## 样例 #1

### 输入

```
2
3
0 -1 0
1 2
2 3
3
0 -1 0
1 2
1 3
```

### 输出

```
Reasonable
Unreasonable
```

# AI分析结果

# 💡 Kay的C++算法解析：[THUPC 2023 决赛] 大纲 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树形动态规划（Tree DP）  

🗣️ **初步分析**：  
解决“大纲”问题的关键，在于**从子节点到父节点传递状态**——就像一棵“成长的树”，叶子节点的状态（难度）决定了父节点的状态，父节点又决定了祖父节点的状态。树形DP的核心思想就是**后序遍历**：先处理所有子节点，再用子节点的信息计算当前节点的状态。  

在本题中，每个节点的难度由其**儿子节点的最大值**决定：  
- 如果儿子中最大值出现**1次**，当前节点难度等于该最大值；  
- 如果出现**多次**，当前节点难度等于最大值+1。  

我们需要判断已确定的难度是否“合理”——即是否存在一种方式，给未确定的节点赋值，使得所有节点都满足上述规则。  

**核心难点**：  
1. 如何正确计算每个节点的**取值范围**（比如“最小可能难度”和“最大可能难度”）？  
2. 如何处理已确定节点的约束（比如已确定的难度是否在合理范围内）？  
3. 如何高效传递状态（避免重复计算）？  

**可视化设计思路**：  
用**8位像素风格**展示树的结构（比如根节点在顶部，子节点向下延伸），每个节点用“像素方块”表示，颜色代表状态：  
- 叶子节点：初始为“绿色”（未处理），处理后变为“蓝色”（状态确定）；  
- 父节点：处理时变为“黄色”（正在计算），计算完成后变为“紫色”（状态确定）。  
动画中会**高亮当前处理的节点**，并实时显示其“最小难度”和“最大难度”的变化（比如用数字像素块显示）。当状态更新时，伴随“叮”的音效；当发现不合理时，伴随“ buzz”的音效。  


## 2. 精选优质题解参考

为了帮助大家理解，我从思路清晰度、代码可读性、算法有效性等方面，筛选了以下3份优质题解：


### **题解一：Larryyu（赞：6）**  
* **点评**：  
  这份题解的**思路最清晰**——用`b数组`（节点难度的下界）和`u数组`（节点难度的上界）维护每个节点的取值范围。通过后序遍历，先计算子节点的`b`和`u`，再推导父节点的`b`和`u`：  
  - 子节点的`b`（下界）取最大值，若有多个最大值，则父节点的`b`加1；  
  - 子节点的`u`（上界）取最大值，父节点的`u`根据最大值的数量调整。  
  代码结构工整，变量命名明确（`b`代表“bottom”，`u`代表“upper”），边界处理严谨（比如叶子节点的特判）。**亮点**：通过“下界”和“上界”的约束，完美覆盖了所有可能的赋值情况，逻辑严密。  


### **题解二：y_kx_b（赞：4）**  
* **点评**：  
  这份题解的**思路最简洁**——用`a数组`（节点难度的最小值）和`ub数组`（是否有上界）维护状态。核心逻辑是：  
  - 子节点的最小值取最大值，若有多个最大值，则父节点的最小值加1；  
  - 若子节点有未确定的（`ub为true`），则父节点的`ub也为true`（即取值无上限）。  
  代码风格简洁，用`flag`标记是否有未确定的子节点，逻辑清晰。**亮点**：通过“最小值”和“是否有上界”的组合，巧妙简化了状态维护，容易理解。  


### **题解三：船酱魔王（赞：3）**  
* **点评**：  
  这份题解的**逻辑最全面**——用`l数组`（节点难度的最小值）和`r数组`（节点难度的最大值）维护取值范围。通过计算子节点的`l`和`r`，推导父节点的`l`和`r`：  
  - 父节点的`l`由子节点的`l`的最大值决定（多个最大值则加1）；  
  - 父节点的`r`由子节点的`r`的最大值决定（多个最大值则加1）。  
  代码覆盖了所有情况（比如叶子节点、已确定节点的约束检查），**亮点**：用“最小-最大”范围完整描述了节点的可能取值，逻辑严谨。  


## 3. 核心难点辨析与解题策略

### **关键点1：如何计算节点的取值范围？**  
- **分析**：  
  每个节点的取值范围由其子节点的取值范围决定。例如，父节点的**最小值**（`l`）是子节点最小值的最大值（若有多个最大值，则加1）；父节点的**最大值**（`r`）是子节点最大值的最大值（若有多个最大值，则加1）。  
  比如，子节点A的最小值是2，子节点B的最小值是3，那么父节点的最小值是3（因为3是子节点最小值的最大值）；如果子节点A和B的最小值都是3，那么父节点的最小值是3+1=4。  
- 💡 **学习笔记**：取值范围的计算是树形DP的核心，必须从子节点到父节点“递推”。  


### **关键点2：如何处理已确定节点的约束？**  
- **分析**：  
  若节点已确定（`a[u] != -1`），则其取值必须在计算出的`l`和`r`之间（`l <= a[u] <= r`）。否则，无法构造合理的赋值。  
  比如，父节点的`l`是3，`r`是5，若已确定父节点的难度是2，则不合理（因为2 < l）；若已确定是6，则不合理（因为6 > r）。  
- 💡 **学习笔记**：已确定节点的约束是“一票否决”，必须严格检查。  


### **关键点3：如何高效传递状态？**  
- **分析**：  
  树形DP的效率取决于**后序遍历**——每个节点只处理一次，子节点的状态计算完成后，再处理父节点。这样可以避免重复计算，时间复杂度为O(n)（n为节点数），符合题目数据规模的要求。  
- 💡 **学习笔记**：后序遍历是树形DP的“标准流程”，必须掌握。  


### ✨ 解题技巧总结  
1. **状态定义**：选择合适的状态（如下界、上界、最小值、是否有上界），是解决树形DP问题的关键。  
2. **后序遍历**：从叶子到根处理节点，确保子节点的状态先于父节点计算。  
3. **边界处理**：叶子节点的状态（比如未确定时，最小值为0）是整个DP的基础，必须正确处理。  


## 4. C++核心代码实现赏析

### **本题通用核心C++实现参考**  
* **说明**：综合了Larryyu、y_kx_b、船酱魔王的思路，用`l`（最小值）和`r`（最大值）维护节点的取值范围，逻辑清晰。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <cstring>
  using namespace std;
  const int N = 1e5 + 10;
  const int INF = 1e9 + 10;

  int T, n, a[N];
  vector<int> g[N];
  int l[N], r[N]; // l[u]: 节点u的最小可能难度；r[u]: 节点u的最大可能难度
  bool ans;

  void dfs(int u, int fath) {
      if (!ans) return;
      bool leaf = true;
      int mx_l = -1, cnt_l = 0; // 子节点l的最大值及数量
      int mx_r = -1, cnt_r = 0; // 子节点r的最大值及数量

      // 处理所有子节点
      for (int v : g[u]) {
          if (v == fath) continue;
          leaf = false;
          dfs(v, u);
          if (!ans) return;

          // 更新子节点l的最大值及数量
          if (l[v] > mx_l) {
              mx_l = l[v];
              cnt_l = 1;
          } else if (l[v] == mx_l) {
              cnt_l++;
          }

          // 更新子节点r的最大值及数量
          if (r[v] > mx_r) {
              mx_r = r[v];
              cnt_r = 1;
          } else if (r[v] == mx_r) {
              cnt_r++;
          }
      }

      // 处理叶子节点
      if (leaf) {
          if (a[u] == -1) {
              l[u] = 0;
              r[u] = INF;
          } else {
              l[u] = r[u] = a[u];
          }
          return;
      }

      // 计算父节点的l和r
      int new_l = mx_l + (cnt_l > 1 ? 1 : 0);
      int new_r = mx_r + (cnt_r > 1 ? 1 : 0);

      // 处理已确定的节点
      if (a[u] != -1) {
          if (a[u] < new_l || a[u] > new_r) {
              ans = false;
              return;
          }
          l[u] = r[u] = a[u];
      } else {
          l[u] = new_l;
          r[u] = new_r;
      }
  }

  void solve() {
      ans = true;
      cin >> n;
      for (int i = 1; i <= n; i++) {
          g[i].clear();
          cin >> a[i];
      }
      for (int i = 1; i < n; i++) {
          int x, y;
          cin >> x >> y;
          g[x].push_back(y);
          g[y].push_back(x);
      }
      dfs(1, 0);
      cout << (ans ? "Reasonable" : "Unreasonable") << endl;
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      cin >> T;
      while (T--) {
          solve();
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读取测试用例数`T`，每个测试用例读取节点数`n`、节点难度`a`数组，以及树的边。  
  2. **DFS函数**：后序遍历树，计算每个节点的`l`（最小值）和`r`（最大值）：  
     - 处理子节点，计算子节点的`l`和`r`的最大值及数量；  
     - 根据子节点的信息，计算父节点的`l`和`r`；  
     - 检查已确定节点的约束（`a[u]`是否在`l`和`r`之间）。  
  3. **输出结果**：根据`ans`变量输出是否合理。  


### **题解一（Larryyu）核心代码片段赏析**  
* **亮点**：用`b`（下界）和`u`（上界）维护状态，逻辑严密。  
* **核心代码片段**：  
  ```cpp
  void dfs(int x, int fax) {
      int maxn = -10, cnt = 0, maxx = -10;
      for (int i = head[x]; i; i = e[i].next) {
          int y = e[i].to;
          if (y == fax) continue;
          if (!dfs(y, x)) return 0;
          if (b[y] > maxn) {
              maxn = b[y];
              cnt = 1;
          } else if (b[y] == maxn) {
              cnt++;
          }
          maxx = max(maxx, u[y]);
      }
      if (maxn == -10) return 1; // 叶子节点
      maxn += (cnt > 1);
      if (a[x] != -1) {
          if (a[x] < maxn) return 0;
          else if (a[x] == maxn) return 1;
          else if (a[x] <= maxx) return 1;
          else return 0;
      }
      u[x] = maxx;
      b[x] = maxn;
      return 1;
  }
  ```
* **代码解读**：  
  - `maxn`：子节点`b`（下界）的最大值；`cnt`：`maxn`的数量；`maxx`：子节点`u`（上界）的最大值。  
  - 计算父节点的`b`（`maxn + (cnt > 1)`）和`u`（`maxx`）。  
  - 检查已确定节点的`a[x]`是否在`b`和`u`之间。  
* 💡 **学习笔记**：`b`和`u`的组合，完美覆盖了节点的取值范围，是处理“未确定节点”的有效方法。  


### **题解二（y_kx_b）核心代码片段赏析**  
* **亮点**：用`a`（最小值）和`ub`（是否有上界）维护状态，思路简洁。  
* **核心代码片段**：  
  ```cpp
  bool dfs(int u) {
      int mx = -1, cnt = 0;
      bool flag = 0;
      for (int i = head[u]; ~i; i = ne[i]) {
          int &v = to[i];
          if (!dfs(v)) return 0;
          if (a[v] > mx) mx = a[v], cnt = 1;
          else if (a[v] == mx) cnt++;
          flag |= ub[v];
      }
      if (cnt == 0 && a[u] == -1) {
          a[u] = 0;
          ub[u] = 1;
          return 1;
      }
      int x = mx + (cnt > 1);
      if (a[u] != -1) {
          if (a[u] < x) return 0;
          if (!flag && a[u] != x) return 0;
          return 1;
      }
      a[u] = x;
      ub[u] = flag;
      return 1;
  }
  ```
* **代码解读**：  
  - `mx`：子节点`a`（最小值）的最大值；`cnt`：`mx`的数量；`flag`：是否有子节点未确定（`ub[v]为true`）。  
  - 计算父节点的`a`（`mx + (cnt > 1)`）和`ub`（`flag`）。  
  - 检查已确定节点的`a[u]`是否大于等于`x`，且若子节点都确定（`flag为false`），则`a[u]`必须等于`x`。  
* 💡 **学习笔记**：`ub`数组的使用，简化了“是否有上界”的判断，思路非常巧妙。  


## 5. 算法可视化：像素动画演示 (核心部分)

### **动画演示主题**：像素树的“成长”之旅  
用8位像素风格展示树的结构，每个节点是一个“像素方块”，颜色代表状态：  
- 叶子节点：初始为“绿色”（未处理）；  
- 子节点处理完成：变为“蓝色”（状态确定）；  
- 父节点处理中：变为“黄色”（正在计算）；  
- 父节点处理完成：变为“紫色”（状态确定）；  
- 不合理节点：变为“红色”（错误）。  


### **核心演示内容**  
1. **初始化**：屏幕显示一棵像素树（根节点在顶部，子节点向下延伸），叶子节点为绿色，父节点为灰色。  
2. **后序遍历**：从最底层的叶子节点开始，依次处理：  
   - 叶子节点：若未确定（`a[u] = -1`），则`l[u] = 0`，`r[u] = INF`，变为蓝色；若已确定，则`l[u] = r[u] = a[u]`，变为蓝色。  
   - 父节点：处理时变为黄色，计算子节点的`l`和`r`的最大值及数量，推导父节点的`l`和`r`。若已确定节点的`a[u]`不在`l`和`r`之间，则变为红色，动画停止。  
3. **状态更新**：每个节点的`l`和`r`用数字像素块显示（比如在节点下方），更新时伴随“叮”的音效。  
4. **结果展示**：若所有节点处理完成且无错误，则树变为紫色，伴随“胜利”音效；若有错误，则错误节点变为红色，伴随“buzz”音效。  


### **交互设计**  
- **控制面板**：包含“开始/暂停”、“单步执行”、“重置”按钮，以及“速度滑块”（调节动画速度）。  
- **AI自动演示**：点击“AI演示”按钮，动画自动执行，展示完整的后序遍历过程。  
- **信息提示**：侧边栏显示当前处理的节点、其`l`和`r`的值，以及“正在计算父节点的状态”等提示文字。  


## 6. 拓展练习与相似问题思考

### **通用思路/技巧迁移**  
树形DP的思路可以迁移到以下场景：  
1. **员工薪资计算**：每个员工的薪资由其下属的薪资决定（比如经理的薪资是下属的最大值+1）；  
2. **课程难度设计**：课程的难度由其先修课程的难度决定（比如高级课程的难度是先修课程的最大值+1）；  
3. **家族树年龄计算**：每个家庭成员的年龄由其子女的年龄决定（比如父母的年龄是子女的最大值+20）。  


### **练习推荐 (洛谷)**  
1. **洛谷 P1352** - 没有上司的舞会  
   🗣️ **推荐理由**：这是树形DP的经典问题，需要计算子节点对父节点的影响（选或不选），有助于巩固后序遍历的思路。  
2. **洛谷 P2014** - 选课  
   🗣️ **推荐理由**：这道题需要处理树的结构（选课依赖），并计算最大价值，有助于理解树形DP的状态转移。  
3. **洛谷 P3174** - [HAOI2009]毛毛虫  
   🗣️ **推荐理由**：这道题需要计算树的最长路径（毛毛虫长度），有助于掌握树形DP的“子节点信息合并”技巧。  


## 7. 学习心得与经验分享 (若有)

### **参考经验 (来自Night_sea_64)**  
> “我交了11发才过啊 qwq……题面中的‘恰依赖一个难度为max_x的知识点’，意思是：当前知识点依赖的知识点中，只有一个难度为max_x。而不是当前知识点只依赖一个知识点（我就是这里看错了）。”  

**点评**：  
这位作者的经验很典型——**仔细读题**是解决问题的第一步。题中的“恰依赖一个”指的是“依赖的知识点中，有一个取到最大值”，而不是“依赖的知识点数量为1”。如果误解了题意，代码逻辑会完全错误。**学习建议**：遇到复杂题意时，一定要反复读题，甚至用样例验证自己的理解。  


## 结语  
本次关于“[THUPC 2023 决赛] 大纲”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解树形DP的思路和技巧。记住，树形DP的关键是**后序遍历**和**状态传递**，只要掌握了这两点，就能解决大部分树相关的问题。下次我们再一起探索新的编程挑战！💪

---
处理用时：175.37秒
# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果


### 题目分析：中位数问题
**题目描述**：给定长度为 \(N\) 的非负整数序列 \(A\)，对于前奇数项（1, 3, 5, ..., 2k-1）输出中位数。数据范围：\(1 \le N \le 100,000\)，\(0 \le A_i \le 10^9\)。

**核心问题**：动态维护序列并在每次添加奇数个元素后输出当前中位数。

---

### 算法分类与核心思想
**算法分类**：动态维护中位数的技巧（对顶堆/优先队列）  
**核心思想**：  
> 想象两个仓库：  
> - **大根堆仓库**（存储较小的一半数）：堆顶是仓库中的最大件（入口处放最大的箱子）。  
> - **小根堆仓库**（存储较大的一半数）：堆顶是仓库中的最小件（入口处放最小的箱子）。  
> 中位数总是两个仓库入口的“平衡点”——当仓库大小平衡时，中位数由物品更多的仓库入口决定。

**在本题中的应用**：  
1. 每次插入新元素时，根据其大小放入合适的仓库：
   - 若小于大根堆堆顶，放入大根堆仓库。
   - 否则放入小根堆仓库。
2. 维护仓库平衡：若两仓库大小差超过 1，则将物品更多的仓库入口处的箱子移到另一个仓库。
3. 输出中位数：当已插入奇数个元素时，物品更多的仓库的堆顶即为中位数。

---

### 精选题解对比
#### 题解一：对顶堆（作者：肖恩Sean）
- **思路**：  
  维护大根堆（存较小一半）和小根堆（存较大一半），保证小根堆堆顶 ≥ 大根堆堆顶。插入后调整堆大小差 ≤1。
- **亮点**：
  - 逻辑清晰：用堆顶比较决定插入位置，通过交换堆顶维护平衡。
  - 代码规范：使用 STL 优先队列，边界处理严谨（如空堆判断）。
  - 时间复杂度：\(O(N \log N)\)，空间 \(O(N)\)。
- **代码关键片段**：
  ```cpp
  priority_queue<int> q1; // 大根堆
  priority_queue<int, vector<int>, greater<int>> q2; // 小根堆
  // 插入与调整
  if (input > q1.top()) q2.push(input);
  else q1.push(input);
  while (abs(q1.size() - q2.size()) > 1) {
      if (q1.size() > q2.size()) { q2.push(q1.top()); q1.pop(); }
      else { q1.push(q2.top()); q2.pop(); }
  }
  // 输出中位数
  if (i % 2) cout << (q1.size() > q2.size() ? q1.top() : q2.top());
  ```

#### 题解二：树状数组（作者：ysj1173886760）
- **思路**：  
  离散化后建立权值树状数组，插入时更新对应位置计数，查询时二分查找第 \(k\) 小值。
- **亮点**：
  - 算法高效：离散化 + 树状数组求第 \(k\) 小，时间复杂度 \(O(N \log N)\)。
  - 解释详细：逐步推导离散化和二分查询过程。
  - 适用性广：可扩展至其他第 \(k\) 大问题。
- **难点**：离散化实现和树状数组的二分查询需要精细处理。

#### 题解三：平衡树（作者：Capella）
- **思路**：  
  使用 Treap 动态维护有序序列，插入后查询第 \((i+1)/2\) 小的元素。
- **亮点**：
  - 理论最优：平衡树原生支持动态插入和排名查询。
  - 代码严谨：手写 Treap 包含旋转维护和递归查询。
- **缺点**：实现复杂，代码量大（超 100 行），调试难度高。

---

### 核心难点与解题策略
1. **难点一：动态维护中位数位置**  
   - **策略**：用对顶堆保持“大小仓库”平衡，确保中位数始终位于堆顶。
2. **难点二：高效查询第 \(k\) 小**  
   - **策略**：树状数组/线段树上二分，或平衡树原生支持。
3. **难点三：处理大数据范围**  
   - **策略**：离散化压缩值域（树状数组必备），避免内存溢出。

**解题技巧总结**：
- 优先选择对顶堆：实现简单，效率稳定。
- 树状数组需注意离散化和边界条件。
- 平衡树仅推荐在需要支持删除操作时使用。

---

### C++ 核心代码实现（对顶堆）
```cpp
#include <iostream>
#include <queue>
#include <vector>
using namespace std;

int main() {
    int n;
    cin >> n;
    priority_queue<int> max_heap; // 大根堆（存较小一半）
    priority_queue<int, vector<int>, greater<int>> min_heap; // 小根堆（存较大一半）
    
    int first;
    cin >> first;
    max_heap.push(first);
    cout << first << endl;

    for (int i = 2; i <= n; i++) {
        int num;
        cin >> num;
        
        // 插入新元素（仓库选择逻辑）
        if (num > max_heap.top()) min_heap.push(num);
        else max_heap.push(num);
        
        // 平衡仓库大小（保证 |size_diff| <= 1）
        if (max_heap.size() > min_heap.size() + 1) {
            min_heap.push(max_heap.top());
            max_heap.pop();
        } else if (min_heap.size() > max_heap.size()) {
            max_heap.push(min_heap.top());
            min_heap.pop();
        }
        
        // 输出奇数项的中位数
        if (i % 2 == 1) {
            cout << (max_heap.size() > min_heap.size() ? max_heap.top() : min_heap.top()) << endl;
        }
    }
    return 0;
}
```

**代码解读**：
1. **初始化**：第一个元素直接作为中位数放入大根堆。
2. **插入逻辑**：新元素根据大小放入对应堆。
3. **平衡维护**：通过移动堆顶元素保证两堆大小差 ≤1。
4. **输出**：奇数项时，元素更多的堆顶即为中位数。

---

### 算法可视化：像素动画演示
**主题**：仓库管理员的中位数冒险（8-bit 像素风格）  
**场景设计**：
- 网格地图：每个数字表示为像素方块，颜色深浅代表数值大小。
- 两个仓库：左侧大根堆（蓝色仓库），右侧小根堆（红色仓库），堆顶用闪烁箭头标记。
- 控制面板：速度滑块、单步执行按钮。

**动画流程**：
1. **插入数字**：新数字从顶部降落，根据大小落入对应仓库（伴随音效）。
2. **平衡调整**：若仓库失衡，堆顶方块飞向另一个仓库（音效：物品移动声）。
3. **输出中位数**：当前中位数方块高亮闪烁，并显示数值（音效：胜利音符）。
4. **交互控制**：用户可调速或单步观察堆调整过程。

**设计细节**：
- **关键状态高亮**：当前操作的堆顶用金色边框标记。
- **数据同步显示**：屏幕底部实时显示序列和当前中位数。
- **复古元素**：背景 8-bit 音乐，像素化数字字体。

---

### 拓展练习
1. **洛谷 P1801 黑匣子**  
   - 动态维护第 \(k\) 小值，强化对顶堆/平衡树的应用。
2. **洛谷 P3871 中位数**  
   - 类似问题，数据量增大，测试优化效果。
3. **LeetCode 295. Find Median from Data Stream**  
   - 同一模型的双语言实现练习。

---

### 学习心得
- **对顶堆是本题最优解**：简洁高效，适合动态维护中位数问题。
- **调试技巧**：边界情况（如空堆）需特判；推荐初始插入一个元素避免空堆问题。
- **思维延伸**：该模型可扩展至动态维护百分位数（如 75% 分位）。

> 通过仓库比喻理解算法，平衡是关键——保持堆的大小差 ≤1，中位数自然浮现于堆顶！

---
处理用时：133.76秒
# 题目信息

# [JOIGST 2025] 电波塔 / Radio Towers

## 题目描述

在 EGOI 国，有 $N$ 座电波塔沿东西方向排列，为国民提供互联网通信服务。电波塔从西向东依次编号为 $1$ 到 $N$。每座电波塔 $i$（$1 \leq i \leq N$）具有以下功能：

- 接收西向波长范围 $[A_i, A_i + L]$ 的电波；
- 向东发射固定波长 $B_i$ 的电波。

对于两座满足 $1 \leq i_1 < i_2 \leq N$ 的塔 $i_1, i_2$，当满足 $A_{i_2} \leq B_{i_1} \leq A_{i_2} + L$ 时，信息可从塔 $i_1$ 传输到塔 $i_2$。

EGOI 国政$ $府将通信稳定性定义为**满足顺序传输条件的非空子集数量**。具体来说，如果子集 $S = {i_1, i_2, \dots, i_k}$（$i_1 < i_2 < \cdots < i_k$）满足以下条件，则 $S$ 满足顺序传输条件：

- 对于任意相邻的两座塔 $(i_j, i_{j+1})$（$1 \leq j \leq k-1$），都满足 $A_{i_{j+1}} \leq B_{i_j} \leq A_{i_{j+1}} + L$。

给定电波塔参数，计算符合条件的子集数量模 $10^9 + 7$ 的结果。

## 说明/提示

#### 【样例解释 #1】

考虑选择电波塔 $1, 2, 3$ 的情况。

  - 由于不满足 $A_2 \leq B_1 \leq A_2 + L$，因此无法从电波塔 $1$ 向电波塔 $2$ 传输信息。
  - 由于满足 $A_3 \leq B_2 \leq A_3 + L$，因此可以从电波塔 $2$ 向电波塔 $3$ 传输信息。

所以，这种选择方式不满足条件。

考虑选择电波塔 $1, 3$ 的情况。

  - 由于满足 $A_3 \leq B_1 \leq A_3 + L$，因此可以从电波塔 $1$ 向电波塔 $3$ 传输信息。

所以，这种选择方式满足条件。

满足条件的塔的选择方式有 $\lbrace1\rbrace, \lbrace2\rbrace, \lbrace3\rbrace, \lbrace1, 3\rbrace, \lbrace2, 3\rbrace$ 这 $5$ 种。因此，输出 $5\bmod (10^9 + 7) = 5$。

此样例满足所有子任务的限制。

#### 【样例解释 #2】

该样例满足子任务 $1,2,4$ 的限制。

#### 【样例解释 #3】

该样例满足子任务 $1,2,4$ 的限制。

#### 【数据范围】

-   $2 \leq N \leq 300\,000$。
-   $0 \leq L \leq 300\,000$。
-   $1 \leq A_i \leq 300\,000$（$1\leq i \leq N$）。
-   $1 \leq B_i \leq 300\,000$（$1\leq i \leq N$）。
-   输入的所有值都是整数。

#### 【子任务】

1. （$20$ 分）$N \leq 16$。
2. （$20$ 分）$N \leq 5\,000$。
3. （$25$ 分）$L = 0$。
4. （$35$ 分）无附加限制。

## 样例 #1

### 输入

```
3 0
1 3
2 3
3 2```

### 输出

```
5```

## 样例 #2

### 输入

```
8 2
1 3
5 1
6 7
7 5
5 2
2 1
3 1
1 6```

### 输出

```
36```

## 样例 #3

### 输入

```
10 3
1 5
2 3
2 4
5 4
10 7
7 9
4 3
3 7
7 7
6 5```

### 输出

```
109```

# AI分析结果


### 💡 Kay的C++算法解析：电波塔 / Radio Towers 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：动态规划 + 树状数组优化

🗣️ **初步分析**：
> 电波塔问题就像搭建多米诺骨牌链：每张牌（塔）只能推倒特定范围内的下一张牌。要统计所有可能的连锁反应方案，我们使用**动态规划**记录以每座塔结尾的合法子集数量，并用**树状数组**快速计算区间和。树状数组就像智能计数器，能在对数时间内完成"波长区间内有多少种前驱方案"的查询。  
> - **核心思路**：定义`dp[i]`为以塔i结尾的方案数，转移方程为`dp[i] = 1 + ∑(dp[j])`，其中`j`满足`A[i] ≤ B[j] ≤ A[i]+L`  
> - **难点**：直接计算时间复杂度O(n²)，需用树状数组将查询优化至O(log n)  
> - **可视化设计**：采用8位像素风格，塔显示为彩色方块，树状数组呈现为动态柱状图。当塔i被处理时：  
>   • 高亮黄色闪烁 + 显示接收范围[Aᵢ, Aᵢ+L]的蓝色光带  
>   • 播放"叮"音效标记关键查询  
>   • 树状数组更新时绿色柱体上升 + "升级"音效  

---

#### 精选优质题解参考
**题解一（Mindulle）**  
* **亮点**：代码简洁（23行），树状数组应用典范。变量命名清晰（dp/c数组），取模处理严谨（+mod防负数）。未离散化但通过扩大数组解决值域问题，实践性强  
* **改进点**：缺少离散化说明，大值域场景需注意内存  

**题解二（xAlec）**  
* **亮点**：完整实现离散化+线段树，适合学习离散化技巧。详细注释+函数封装规范（build/update/query）。转移逻辑清晰体现"动态维护Bⱼ的dp值和"  
* **注意点**：线段树代码量较大（50行），竞赛中树状数组更高效  

**题解三（Forge_Unique）**  
* **亮点**：树状数组实现简洁，初始化dp[i]=1体现独立子集思想。边界处理完善（N*2-1防越界），适合初学者理解  

---

#### 核心难点辨析与解题策略
1. **状态定义与无后效性**  
   * **难点**：如何定义dp状态满足"前驱状态完全确定后续决策"  
   * **解法**：定义`dp[i]`为以i结尾的方案数，确保前驱j的Bⱼ不影响i之后的决策  
   * 💡 学习笔记：DP状态应包含终止位置，保证状态封闭性  

2. **大值域区间查询优化**  
   * **难点**：A/B值域达3e5，暴力区间求和O(n²)超时  
   * **解法**：树状数组维护Bⱼ的dp值和，查询区间[Aᵢ, Aᵢ+L]  
   * 💡 学习笔记：值域≤6e5时直接开数组，否则需离散化  

3. **离散化实现技巧**  
   * **难点**：离散化后需快速定位[Aᵢ, Aᵢ+L]对应区间  
   * **解法**：对B统一离散化，用`lower_bound`定位区间端点  
   * 💡 学习笔记：离散化三步骤：排序→去重→二分映射  

### ✨ 解题技巧总结
- **DP优化套路**：遇到区间求和转移，立即考虑树状数组/线段树  
- **边界防护**：树状数组查询先判断`l>r`，减法取模先`+mod`  
- **空间权衡**：值域较小时(≤1e6)开静态数组，否则离散化  

---

### C++核心代码实现赏析
**通用核心实现（综合优化版）**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#define lowbit(x) (x & -x)
using namespace std;
const int MOD = 1e9+7, MAX = 6e5;

int n, L;
long long tree[MAX+10];

void update(int i, int v) {
    while(i <= MAX) tree[i] = (tree[i] + v) % MOD, i += lowbit(i);
}

long long query(int r) {
    long long s = 0;
    while(r) s = (s + tree[r]) % MOD, r -= lowbit(r);
    return s;
}

int main() {
    cin >> n >> L;
    vector<long long> dp(n+1);
    long long ans = 0;
    
    for(int i=1; i<=n; ++i) {
        int a, b; cin >> a >> b;
        // 区间查询
        long long sum = (query(min(a+L, MAX)) - query(a-1) + MOD) % MOD;
        dp[i] = (1 + sum) % MOD;  // 自身作为独立子集+前驱方案
        update(b, dp[i]);        // 树状数组更新
        ans = (ans + dp[i]) % MOD;
    }
    cout << ans;
}
```
**代码解读概要**：  
- **树状数组**：`update`单点更新，`query`前缀查询  
- **DP转移**：计算区间`[a, a+L]`的dp和，更新当前塔方案数  
- **技巧**：`min(a+L,MAX)`防越界，`+MOD`处理负数取模  

---

#### 题解片段赏析
**题解一（树状数组实战）**  
```cpp
dp[i]=(dp[i]+(getsum(a[i]+l)-getsum(a[i]-1)+mod)%mod)%mod;
add(b[i],dp[i]);
```
* **亮点**：单行完成区间查询和取模  
* **学习笔记**：树状数组区间和 = query(r) - query(l-1)  

**题解二（离散化实现）**  
```cpp
int lpos = lower_bound(cpy+1, cpy+nn+1, a[i]) - cpy;
int rpos = upper_bound(cpy+1, cpy+nn+1, a[i]+L) - cpy - 1;
f[i] = 1 + query(1, lpos, rpos);
```
* **亮点**：离散化后精确控制查询区间  
* **学习笔记**：`upper_bound`需-1获取闭区间右端点  

---

### 算法可视化：像素动画演示
**主题**：8位像素风《电波链之谜》  
**核心交互设计**：  
![](https://via.placeholder.com/400x200/000000/FFFFFF?text=像素动画示意图)  
1. **场景布局**  
   - 左侧：电波塔像素方块（颜色区分A/B值）  
   - 右侧：树状数组柱状图（高度=dp值之和）  
   - 底部：控制面板（开始/步进/调速滑块）  

2. **动态过程**  
   - **步骤1**：当前塔i高亮黄色，显示接收带[Aᵢ, Aᵢ+L]（蓝色光带）  
   - **步骤2**：树状数组区间[Aᵢ, Aᵢ+L]闪烁蓝框，播放"叮"音效  
   - **步骤3**：显示查询结果sum，塔i显示dp[i]=1+sum  
   - **步骤4**：塔i的Bᵢ位置绿柱上升，播放"升级"音效  

3. **游戏化元素**  
   - 每塔作为独立关卡，通关得⭐（根据dp值计算）  
   - 胜利时播放FC胜利音乐+全屏闪烁  
   - 错误操作触发"错误"音效（短促哔声）  

4. **技术实现**  
   ```javascript
   // 伪代码：树状数组更新动画
   function updateAnimation(i, value) {
     while(i <= MAX) {
       柱状图[i].高度 += value;
       i += lowbit(i);  // 路径节点高亮红色
       playSound('click'); // 像素音效
     }
   }
   ```

---

### 拓展练习与相似问题思考
1. **技巧迁移场景**  
   - 逆序对统计（P1908）：树状数组维护值域  
   - 最长上升子序列（LIS）：DP+树状数组求max  
   - 区间统计问题（P1972）：离线查询+树状数组  

2. **洛谷推荐**  
   - **P1908 逆序对**：树状数组入门经典  
   - **P3374 树状数组1**：掌握单点更新/区间查询  
   - **P5490 扫描线**：二维区间问题拓展  

---

### 学习心得与经验分享
> 本次题解虽未包含作者调试心得，但实践中需注意：  
> - **负数取模**：`(a-b+MOD)%MOD`是安全写法  
> - **离散化陷阱**：`upper_bound`需`-1`获取闭区间端点  
> - **边界检查**：树状数组查询下标>0，更新下标≤MAX  

---
通过本指南，相信大家已掌握动态规划与树状数组的协同作战技巧。记住：好的状态设计是DP成功的一半，而数据结构能让你的算法如虎添翼！下次见！🚀

---
处理用时：180.15秒
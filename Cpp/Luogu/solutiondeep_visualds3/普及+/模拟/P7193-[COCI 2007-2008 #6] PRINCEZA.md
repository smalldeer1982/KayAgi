# 题目信息

# [COCI 2007/2008 #6] PRINCEZA

## 题目背景

对于 C 语言和 C++ 语言，请使用 `cin`，`scanf` 进行读入，否则可能会出现 $\color{purple}\mathsf{RE}$ & $\color{red}\mathsf{WA}$。

## 题目描述



Luka 把卡车停在湖边。 

Barica 在湖中居住，Barica 跳过漂浮在湖面上的 $n$ 种植物。 

Luka 知道许多民间故事，知道如果他亲吻 Barica，她会变成一个可爱的女孩子。但是，他需要先抓住她！

可以用一对坐标定义植物在湖面上的位置。 Barica 可以从 $(x, y)$ 植物中跳跃，$p$ 为任意正整数。

- 方向 A：$(x + p, y + p)$。
- 方向 B：$(x + p, y - p)$。
- 方向 C：$(x - p, y + p)$。
- 方向 D：$(x - p, y - p)$。

Barica 选择四个方向之一，然后沿所选方向跳到第一个植物上。 

如果在选定的方向上没有植物，Barica 将留在原处。

Barica 跳下后，她从水槽上跳下的植物消失了。

知道植物的位置和 Barica 选择的方向顺序后，Luka 希望确定 Barica 最终将位于植物的坐标。 Luka 将在她的位置等她，亲吻她。

编写一个解决 Luka 问题的程序，并帮助他将 Barica 变成美丽的公主。

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，$1 \le n, k \le 10 ^ 5$，$0 \le x, y \le 10 ^ 9$。
#### 说明
- 本题满分 $60$ 分。
- 本题默认开启 O2 优化开关。
- 题目译自 [COCI2007-2008](https://hsin.hr/coci/archive/2007_2008/) [CONTEST #6](https://hsin.hr/coci/archive/2007_2008/contest6_tasks.pdf) T5 PRINCEZA，译者 @[tearing](https://www.luogu.com.cn/user/219791)。

## 样例 #1

### 输入

```
7 5
ACDBB
5 6
8 9
4 13
1 10
7 4
10 9
3 7
```

### 输出

```
7 4```

## 样例 #2

### 输入

```
6 12
AAAAAABCCCDD
1 1
2 2
3 3
4 4
5 3
6 2 
```

### 输出

```
5 3```

# AI分析结果

---
# 💡 Kay的C++算法解析：PRINCEZA 深入学习指南 💡

<introduction>
今天我们来一起分析“PRINCEZA”这道C++编程题。Barica在湖面上的植物间跳跃，我们需要模拟她的跳跃过程并找到最终位置。本指南将帮你理解核心思路、关键算法，并通过像素动画直观感受跳跃过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟 + 数据结构（链表/有序集合）`

🗣️ **初步分析**：
解决这道题的关键在于利用“对角线跳跃”的特性——Barica每次跳跃的方向对应两种斜线：  
- **方向A/D**：沿斜线 \( y = x + b \)（\( x - y \) 为定值）；  
- **方向B/C**：沿斜线 \( y = -x + b \)（\( x + y \) 为定值）。  

简单来说，我们可以将同一斜线上的植物按坐标排序，用链表或有序集合维护它们的顺序。每次跳跃时，快速找到当前点的下一个目标点，并删除原位置的植物（更新链表）。  

- **题解思路**：多数优质题解通过两次排序（按 \( x+y \) 和 \( x-y \)）将同一斜线上的点分组，然后用链表记录每个点的前后节点。模拟跳跃时，根据方向找到下一个节点，并删除当前节点（更新前后节点的链接）。  
- **核心难点**：如何高效维护斜线点的顺序，并在删除后正确更新链表关系。  
- **可视化设计**：采用8位像素风格，用不同颜色区分斜线；植物用彩色方块表示，跳跃时当前点褪色（删除），箭头指向目标点，链表指针用虚线动态更新。动画支持单步/自动播放，关键操作（如删除、跳跃）伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解值得重点学习：
</eval_intro>

**题解一：作者ShwStone**
* **点评**：此题解思路非常清晰！通过定义结构体存储每个点的 \( x+y \)（d1）和 \( x-y \)（d2），两次排序后为同一斜线上的点建立链表（flag数组）。代码中变量命名直观（如d1、d2），边界处理严谨（初始化为-1）。模拟跳跃时，通过更新链表指针实现删除操作，时间复杂度 \( O(n \log n + k) \)，完全适配题目数据规模。亮点在于链表的高效维护，是链表应用的经典示例。

**题解二：作者ybw731**
* **点评**：此题解简洁高效！同样利用 \( x+y \) 和 \( x-y \) 排序分组，用数组l[4]直接记录四个方向的下一个节点。代码结构工整，循环和条件判断逻辑直白（如排序后遍历相邻点建立链接）。模拟部分仅需遍历k次方向，每次更新链表指针，代码可读性极高。亮点是将复杂的跳跃逻辑转化为简单的链表操作，非常适合初学者学习。

**题解三：作者yxy666**
* **点评**：此题解逻辑严谨！通过read()函数优化输入效率，两次排序后建立链表（flg数组），模拟时遍历方向并更新链表。代码中“flg[3-j]”的处理巧妙，确保删除当前点时所有相关链接被正确更新。亮点是对链表删除操作的全面处理，避免了遗漏方向导致的错误。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要突破以下关键点：
</difficulty_intro>

1.  **关键点1：如何将点按斜线分组？**
    * **分析**：同一斜线上的点满足 \( x+y \) 或 \( x-y \) 为定值。通过两次排序（按 \( x+y \) 和 \( x-y \)），可以将同一斜线上的点聚集在一起。例如，按 \( x+y \) 排序后，所有 \( x+y \) 相等的点会连续出现，便于建立链表。  
    * 💡 **学习笔记**：利用“排序+分组”是处理同类元素聚集问题的常用技巧。

2.  **关键点2：如何建立链表关系？**
    * **分析**：对于同一斜线上的点，按坐标排序后，相邻点即为跳跃方向的下一个节点。例如，按 \( x+y \) 升序排列后，当前点的B方向（右下）的下一个节点是右侧相邻点，C方向（左上）的下一个节点是左侧相邻点。  
    * 💡 **学习笔记**：链表的“前驱-后继”关系可通过排序后的相邻元素直接建立。

3.  **关键点3：如何处理删除操作？**
    * **分析**：删除当前点时，需更新其前后节点的链表指针。例如，若当前点的前驱是A，后继是B，则A的后继应指向B，B的前驱应指向A。所有方向的指针都需更新，避免后续跳跃错误。  
    * 💡 **学习笔记**：链表删除的核心是“断链重连”，需确保所有相关节点的指针被正确修改。

### ✨ 解题技巧总结
- **问题抽象**：将跳跃问题转化为链表操作，利用斜线特性简化方向判断。  
- **排序分组**：通过排序将同类元素（同一斜线）聚集，便于后续处理。  
- **链表维护**：用数组直接记录前后节点，比指针更高效且易于实现。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，给出一个简洁高效的通用核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了ShwStone和ybw731的题解思路，通过两次排序建立链表，模拟跳跃时更新链表指针。代码简洁清晰，适合直接参考。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXN = 1e5 + 5;
    struct Point {
        int x, y, d1, d2; // d1=x+y, d2=x-y
        int next[4]; // 0:A, 1:B, 2:C, 3:D
    } pts[MAXN];
    int id[MAXN]; // 排序用的索引数组

    bool cmp_d1(int a, int b) {
        if (pts[a].d1 != pts[b].d1) return pts[a].d1 < pts[b].d1;
        return pts[a].x < pts[b].x; // 按x升序排列
    }

    bool cmp_d2(int a, int b) {
        if (pts[a].d2 != pts[b].d2) return pts[a].d2 < pts[b].d2;
        return pts[a].x < pts[b].x; // 按x升序排列
    }

    int main() {
        int n, k;
        scanf("%d%d", &n, &k);
        char dir[k + 1];
        scanf("%s", dir + 1);
        for (int i = 1; i <= n; ++i) {
            scanf("%d%d", &pts[i].x, &pts[i].y);
            pts[i].d1 = pts[i].x + pts[i].y;
            pts[i].d2 = pts[i].x - pts[i].y;
            fill(pts[i].next, pts[i].next + 4, -1); // 初始化为-1（无下一个节点）
            id[i] = i;
        }

        // 处理B/C方向（x+y相同的斜线）
        sort(id + 1, id + n + 1, cmp_d1);
        for (int i = 2; i <= n; ++i) {
            if (pts[id[i - 1]].d1 == pts[id[i]].d1) {
                pts[id[i - 1]].next[1] = id[i]; // B方向的下一个节点是i
                pts[id[i]].next[2] = id[i - 1]; // C方向的下一个节点是i-1
            }
        }

        // 处理A/D方向（x-y相同的斜线）
        sort(id + 1, id + n + 1, cmp_d2);
        for (int i = 2; i <= n; ++i) {
            if (pts[id[i - 1]].d2 == pts[id[i]].d2) {
                pts[id[i - 1]].next[0] = id[i]; // A方向的下一个节点是i
                pts[id[i]].next[3] = id[i - 1]; // D方向的下一个节点是i-1
            }
        }

        int cur = 1; // 初始位置是第一个点
        for (int i = 1; i <= k; ++i) {
            int d = dir[i] - 'A'; // 转换为0-3的方向
            int nxt = pts[cur].next[d];
            if (nxt == -1) continue; // 无下一个节点，跳过

            // 删除当前节点cur：更新前后节点的next指针
            for (int j = 0; j < 4; ++j) {
                if (pts[cur].next[j] != -1) {
                    int neighbor = pts[cur].next[j];
                    pts[neighbor].next[3 - j] = pts[cur].next[3 - j];
                }
            }
            cur = nxt; // 跳到下一个节点
        }

        printf("%d %d\n", pts[cur].x, pts[cur].y);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入并计算每个点的 \( d1 \)（\( x+y \)）和 \( d2 \)（\( x-y \)）。通过两次排序（按 \( d1 \) 和 \( d2 \)）将同一斜线上的点分组，建立四个方向的链表（next数组）。模拟跳跃时，根据方向找到下一个节点，并更新链表指针以删除当前节点，最终输出最终位置。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者ShwStone（核心代码片段）**
* **亮点**：用结构体存储d1、d2和flag数组，排序后建立链表，删除操作时更新所有相关指针。
* **核心代码片段**：
    ```cpp
    sort(id + 1, id + n + 1, d1_compare);
    for (int i = 2; i <= n; i++) {
        if (graph[id[i - 1]].d1 == graph[id[i]].d1) {
            graph[id[i - 1]].flag[1] = id[i];
            graph[id[i]].flag[2] = id[i - 1];
        }
    }
    sort(id + 1, id + n + 1, d2_compare);    
    for (int i = 2; i <= n; i++) {
        if (graph[id[i - 1]].d2 == graph[id[i]].d2) {
            graph[id[i - 1]].flag[0] = id[i];
            graph[id[i]].flag[3] = id[i - 1];
        }
    }
    ```
* **代码解读**：  
  这段代码通过两次排序（d1_compare和d2_compare）将同一斜线上的点聚集。遍历相邻点时，若它们的d1（或d2）相同，则建立链表关系。例如，d1相同的点中，前一个点的flag[1]（B方向）指向后一个点，后一个点的flag[2]（C方向）指向前一个点。这样，每个点的四个方向都记录了下一个跳跃节点。  
* 💡 **学习笔记**：排序是建立链表的前提，相邻点的判断确保链表的正确性。

**题解二：作者ybw731（核心代码片段）**
* **亮点**：用sum1和sum2表示 \( x+y \) 和 \( x-y \)，代码简洁，链表建立逻辑清晰。
* **核心代码片段**：
    ```cpp
    sort(id+1,id+n+1,Cmp1);
    for(int i=2;i<=n;i++)
        if(a[id[i]].sum1==a[id[i-1]].sum1){
            a[id[i-1]].l[1]=id[i];
            a[id[i]].l[2]=id[i-1];
        }
    sort(id+1,id+n+1,Cmp2);
    for(int i=2;i<=n;i++)
        if(a[id[i]].sum2==a[id[i-1]].sum2){
            a[id[i-1]].l[0]=id[i];
            a[id[i]].l[3]=id[i-1];
        }
    ```
* **代码解读**：  
  Cmp1和Cmp2分别按sum1（\( x+y \)）和sum2（\( x-y \)）排序。遍历排序后的id数组时，若相邻点的sum1（或sum2）相同，则建立链表。例如，sum1相同的点中，前一个点的l[1]（B方向）指向后一个点，后一个点的l[2]（C方向）指向前一个点。这一步为后续模拟跳跃提供了快速查找的基础。  
* 💡 **学习笔记**：链表的建立需要明确每个方向对应的相邻点，排序后的遍历是关键。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解跳跃过程，我们设计了一个“像素探险”动画，用8位风格展示Barica的跳跃！
\</visualization_intro\>

  * **动画演示主题**：`像素湖中的跳跃探险`  
  * **核心演示内容**：展示Barica从初始点出发，按给定方向跳跃，植物被删除的过程。重点演示链表指针的更新和跳跃路径的变化。  
  * **设计思路简述**：8位像素风营造轻松氛围，不同颜色区分斜线（如红色斜线 \( x+y \)，蓝色斜线 \( x-y \)）。植物用彩色方块表示，跳跃时当前点褪色（删除），箭头指向目标点，链表指针用虚线动态更新。音效（如“叮”）强化操作记忆，自动播放模式让学习者观察完整流程。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：  
       - 屏幕显示16色像素网格，每个植物用彩色方块（如绿色）表示，斜线用浅色背景（红/蓝）区分。  
       - 控制面板包含“单步”“自动播放”“调速”按钮，初始显示“点击开始”。  
       - 播放8位风格背景音乐（如《超级玛丽》主题曲变奏）。

    2. **初始状态展示**：  
       - 所有植物方块高亮，初始点（第一个点）用金色边框标记。  
       - 链表指针用虚线连接同一斜线上的相邻点（红色虚线表示B/C方向，蓝色虚线表示A/D方向）。

    3. **跳跃过程演示**：  
       - **单步执行**：点击“单步”按钮，按方向顺序执行一次跳跃。当前点方块褪色（灰色），箭头（黄色）从当前点指向目标点，目标点闪烁3次后变为新的当前点。  
       - **链表更新**：删除当前点时，前后节点的虚线指针重新连接（如原前驱→当前→后继，变为前驱→后继），用动画（虚线闪烁）表示指针更新。  
       - **音效触发**：每次跳跃成功时播放“叮”音效，无目标点时播放“滴”音效。

    4. **自动播放模式**：  
       - 点击“自动播放”，算法按设定速度（调速滑块控制）自动执行所有跳跃。学习者可观察完整跳跃路径的变化。

    5. **结束状态**：  
       - 所有跳跃完成后，最终点用金色闪光动画庆祝，播放“胜利”音效（如《超级玛丽》吃金币音），并显示最终坐标。

  * **旁白提示**：  
    - （单步开始）“现在执行第1次跳跃，方向A！当前点是(5,6)，我们需要找同一斜线（\( x-y= -1 \)）上的下一个点。”  
    - （跳跃时）“找到目标点(8,9)！当前点(5,6)消失，箭头指向(8,9)。”  
    - （链表更新）“注意看，原来的前驱和后继的虚线重新连接了！”

\<visualization_conclusion\>
通过这个动画，我们能清晰看到链表的建立、跳跃的路径和指针的更新，让抽象的链表操作变得“看得见、摸得着”！
\</visualization_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握本题后，我们可以尝试以下拓展练习，巩固链表和数据结构的应用：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：  
    本题的“排序分组+链表维护”思想可用于处理其他需要“按条件分组并快速查找”的问题，例如：  
    - 处理网格中的斜线移动问题（如国际象棋中的象移动）；  
    - 维护时间序列中的相邻事件；  
    - 处理二维平面上的同方向点查询。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1113 杂务**  
        * 🗣️ **推荐理由**：考察拓扑排序，需要维护任务间的依赖关系，类似链表的前驱-后继管理。  
    2.  **洛谷 P1827 美国血统**  
        * 🗣️ **推荐理由**：通过中序和后序遍历重建二叉树，需按顺序处理节点，锻炼链表和树结构的结合应用。  
    3.  **洛谷 P1030 求先序排列**  
        * 🗣️ **推荐理由**：中序和后序转先序，需要分组处理左右子树，与本题“排序分组”思路类似。  

-----

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解作者提到，调试时容易遗漏链表的某个方向更新，导致后续跳跃错误。例如，删除当前点时，需更新所有四个方向的指针，否则可能出现“幽灵节点”。
\</insights_intro\>

> **参考经验 (来自作者ShwStone)**：“一开始没考虑到删除当前点时要更新所有方向的指针，导致测试用例出错。后来通过打印链表指针，发现某些方向的指针未正确连接，才意识到需要遍历四个方向逐一更新。”

**点评**：这位作者的经验非常实用！在处理链表删除操作时，必须确保所有相关指针都被更新。通过打印中间变量（如链表指针）可以快速定位错误，这是调试链表问题的有效方法。

-----

\<conclusion\>
本次关于“PRINCEZA”的分析就到这里。通过理解斜线特性、链表维护和模拟跳跃，我们掌握了这类问题的核心解法。记住，多动手模拟链表的建立和删除过程，结合动画演示，能更快理解抽象的算法逻辑。下次再见！💪
\</conclusion\>

---
处理用时：166.61秒
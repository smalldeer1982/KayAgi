# 题目信息

# [省选联考 2022] 预处理器

## 题目描述

宏是 C/C++ 语言的一项特性，它根据预先定义的规则进行文本替换（也被称为 “宏展开”），能够实现定义常量、简化代码重复输入等功能。例如：

```cpp
#define PI 3.14159
double area = PI * r * r;
```

以上代码经过宏展开后变为：

```cpp

double area = 3.14159 * r * r;
```

其中，宏定义命令变成了空行，而其他行中的宏被展开成了规则定义的文本。

C/C++ 语言代码在编译时对宏的处理由**预处理器**完成。你的任务是实现一个简化版的预处理器，要求如下：

- 代码由**行**组成，每行除行末的换行符外，均由可打印 ASCII 字符（ASCII 码范围 $32\sim 126$）组成。每行要么是**预处理命令**（以 `#` 开头），要么是**普通文本**（其他情况）。

- 预处理器逐行处理代码，
	- 如果是预处理命令，执行该命令，并输出一个空行。
    - 如果是普通文本，对其进行宏展开并输出结果。
- 预处理命令有两种，分别是宏定义命令 `#define` 和取消宏定义命令 `#undef`。
	- 宏定义命令的格式为 `#define <name> <content>`，其中第一部分 `#define` 是命令名，第二部分 `<name>` 是要定义的宏的名字，第三部分 `<content>` 是要定义的宏的展开内容。
    - 取消宏定义命令的格式为 `#undef <name>`，其中第一部分 `#undef` 是命令名，第二部分 `<name>` 是要取消的宏的名字。
    
    以上两种预处理命令中，相邻两部分之间都严格用一个空格分隔。`<name>` 是由大小写字母和数字以及下划线组成的**标识符**（一个或多个字符），`<content>` 可以包含任意可打印 ASCII 字符（零个或多个字符）。一个宏定义的**有效范围**是从它定义所在行开始到后续最近的宏名匹配的取消定义所在行为止（如果没有对应的取消定义，则有效范围一直覆盖到文件结束）。
    
对普通文本进行宏展开时，将一行文本中每段**连续极长**的大小写字母和数字以及下划线视为标识符（而不是其中一部分），其余为**其他字符**。从左到右依次对文本中的标识符进行宏展开：
    
1. 如果该标识符是有效的宏名，则用对应的展开内容替换它，此时该宏名进入正在展开的状态，直到本流程结束；否则原样保留宏名。例如，若宏 `A` 定义为 `b`，则文本 `A` 展开结果为 `b`（发生替换），文本 `B` 展开结果仍然为 `B`（未定义，不替换），文本 `AA` 展开结果仍然为 `AA`（`AA` 是不同于 `A` 的另一个标识符，未定义），而文本 `A*B` 展开结果为 `b*B`。
    
2. 替换发生后，如果展开内容中包含标识符，重复应用以上的展开操作，称为 “多次展开”。例如，若宏 `A` 定义为 `B`，宏 `B` 定义为 `c`，则文本 `A` 的展开结果为 `c`。
    
3. 如果待展开的宏名与正在进行展开的某个宏名相同，称为 “递归展开”，此时该宏名不再展开。本规则用来防止无限递归展开。例如，若宏 `A` 定义为 `B+a`，宏 `B` 定义为 `A+b`，则文本 `A` 展开结果为 `A+b+a`，由于最初的 `A` 处于正在展开状态，因此 `A+b+a` 里的 `A` 不再展开。

4. 其他字符原样保留。

注意：出于简化的目的，本题的要求与 C/C++ 语言标准里的描述不完全一致，请以上面的要求为准。最明显的区别是本题只有标识符和其他字符两类词法单元，没有数值、字符串、注释等。

## 说明/提示

**【数据范围】**

对 $20\%$ 的数据，不会出现宏定义命令 `#define` 和宏取消定义命令 `#undef`。

对另外 $20\%$ 的数据，不会出现多次展开的情况，且不会出现宏取消定义命令 `#undef`。

对另外 $20\%$ 的数据，不会出现多次展开的情况。

对另外 $20\%$ 的数据，不会出现递归展开的情况。

对其余数据，无特殊限制。

对 $100\%$ 的数据，$n \leq 100$，输入的每行字符数都不超过 $100$，且保证输出的每行字符数都不超过 $1000$（字符数均不计行末换行符）。保证输入数据中的预处理命令都是合法的，包含但不限于：

- `#` 字符只会出现在预处理命令所在行的第一个字符的位置，其他任何位置（包括预处理命令和普通文本）都不会出现 `#` 字符。
- 宏定义和取消定义命令的格式是正确的，严格遵循题面所描述的格式。
- 同一个宏在取消定义之前不会被再次定义。
- 要取消定义的宏在之前被定义过且还没有被取消过。

也就是说，**你不需要做任何语法和语义的错误检查**。

**【提示】**

本题进行输入时建议使用 C++ 语言的按行读入字符串功能，示例如下：

```cpp
#include <iostream>
#include <string>
using namespace std;
string line;
// 从 cin 读入一行，放入 line 中（换行符被舍弃）
getline(cin, line);
```

也可以使用 C 语言提供的 `fgets` 函数，示例如下：

```cpp
#include <stdio.h>
#define MAX_LEN 200
char line[MAX_LEN];
// 从 stdin 读入一行，放入 line 中（包含换行符）
fgets(line, MAX_LEN, stdin);
```

**注意**：在读取行数 $n$ 之后可能需要额外读取一行以忽略其后的换行符。

## 样例 #1

### 输入

```
5
#define BEGIN {
#define END }
#define INTEGER int
class C BEGIN INTEGER x; END;
INTEGER main() BEGIN C c; END
```

### 输出

```



class C { int x; };
int main() { C c; }
```

## 样例 #2

### 输入

```
见附件中的 preprocessor/preprocessor2.in```

### 输出

```
见附件中的 preprocessor/preprocessor2.ans```

## 样例 #3

### 输入

```
见附件中的 preprocessor/preprocessor3.in```

### 输出

```
见附件中的 preprocessor/preprocessor3.ans```

# AI分析结果



---
# 💡 Kay的C++算法解析：[省选联考 2022] 预处理器 深入学习指南 💡

<introduction>
今天我们要挑战的题目是“预处理器”，这是一道需要模拟C/C++宏展开的题目。通过分析题目要求和优质题解，我们将掌握如何处理宏定义、取消定义以及普通文本的递归展开，同时理解其中的关键逻辑和实现技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与字符串处理`  

🗣️ **初步分析**：  
解决这道题的关键在于“模拟”——严格按照题目描述的规则处理每一行代码。我们需要维护宏的状态（定义/取消定义），并对普通文本中的标识符进行递归展开。可以把整个过程想象成一个“翻译机”：遇到预处理命令时更新宏的状态，遇到普通文本时按规则翻译（展开宏）。

### 核心思路与难点：
- **宏的状态管理**：用哈希表（如`unordered_map`或`map`）存储当前有效的宏，键是宏名，值是展开内容。遇到`#undef`时删除对应键。
- **标识符的识别**：普通文本中连续的字母、数字、下划线组成标识符，其余为其他字符。例如`A*B`中的`A`和`B`是标识符，`*`是其他字符。
- **递归展开**：展开一个宏后，若其内容包含新的标识符，需重复展开；但要防止无限递归（如宏`A`展开为`B`，`B`展开为`A`），需标记正在展开的宏。

### 可视化设计思路：
我们可以设计一个8位像素风格的动画，用不同颜色的方块表示标识符和其他字符。例如：
- 绿色方块：未展开的标识符；
- 黄色方块：正在展开的宏；
- 蓝色方块：已展开的内容；
- 音效：每次展开时播放“叮”声，递归开始/结束时用不同音调提示。动画支持单步执行和自动播放，同步显示当前处理的代码行和宏状态。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解表现突出（≥4星）：
</eval_intro>

### 题解一：宝硕的实现（来源：用户@宝硕）
* **点评**：  
此题解逻辑清晰，代码规范。使用`unordered_map`存储宏（键为宏名，值为`pair<内容, 展开标记>`），递归展开时通过标记避免无限循环。代码中`dfs`函数逐字符扫描文本，识别标识符并递归展开，边界处理严谨（如空内容、递归回溯）。实践价值高，可直接用于竞赛。

### 题解二：Exschawasion的实现（来源：用户@Exschawasion）
* **点评**：  
此题解采用“自顶向下”设计，先拆分词法（Tokenize）再递归展开。通过`Vector`存储词法单元（标识符和其他字符），递归展开时对每个词法单元处理。思路模块化，易于理解和调试，适合学习词法分析的基础。

### 题解三：XenonWZH的实现（来源：用户@XenonWZH）
* **点评**：  
此题解使用`std::tuple`辅助词法分析，递归展开时用`vis`标记正在展开的宏。代码结构简洁，处理了输入中的换行符问题，对细节（如空内容宏）的处理较为完善，适合理解递归展开的核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决此题时，以下三个难点最容易出错，我们需要针对性突破：
</difficulty_intro>

### 1. 关键点1：标识符的正确识别
**问题**：如何准确分割普通文本中的标识符和其他字符？  
**分析**：标识符由连续的字母、数字、下划线组成。可以逐字符扫描，遇到非标识符字符时结束当前标识符的读取。例如，`A+B`会被分割为`A`、`+`、`B`。  
💡 **学习笔记**：用循环判断字符是否为标识符字符（`isalpha`、`isdigit`或`_`），逐个读取直到遇到非标识符字符。

### 2. 关键点2：多次展开的递归处理
**问题**：如何实现宏的多次展开（如`A`展开为`B`，`B`展开为`C`）？  
**分析**：递归展开。每次展开一个宏时，先检查其内容中的标识符，若该标识符是有效宏且未被标记为“正在展开”，则递归展开。例如，展开`A`时，先展开为`B`，再展开`B`为`C`。  
💡 **学习笔记**：递归函数需传入当前正在展开的宏集合（或标记数组），避免重复展开。

### 3. 关键点3：防止无限递归展开
**问题**：如何避免宏的无限递归（如`A`展开为`B`，`B`展开为`A`）？  
**分析**：在递归展开时，标记当前正在展开的宏。若展开过程中再次遇到该宏，直接保留其原名。例如，展开`A`时标记`A`为“正在展开”，若`A`的展开内容中包含`A`，则不再展开。  
💡 **学习笔记**：用哈希表或数组记录“正在展开”的宏，递归结束后回溯（取消标记）。

### ✨ 解题技巧总结
- **输入处理**：使用`getline`读取整行，避免换行符干扰；读取`n`后用`getline`吸收多余换行。
- **宏的存储**：用`unordered_map`（哈希表）而非`map`（红黑树），提高查找效率（平均O(1)）。
- **递归优化**：标记正在展开的宏时，优先用局部变量（如函数参数中的`used`集合），避免全局变量污染。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼出一个结构清晰、易于理解的通用核心实现。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：此代码综合了宝硕、Exschawasion等题解的思路，使用`unordered_map`存储宏，递归展开时标记正在展开的宏，确保正确性和效率。
* **完整核心代码**：
```cpp
#include <iostream>
#include <string>
#include <unordered_map>
#include <vector>

using namespace std;

unordered_map<string, pair<string, bool>> macros; // 宏名 -> (内容, 正在展开标记)

// 递归展开函数
string dfs(const string& s) {
    string res;
    int n = s.size();
    for (int i = 0; i < n; ) {
        // 提取标识符
        string token;
        if (isalnum(s[i]) || s[i] == '_') {
            while (i < n && (isalnum(s[i]) || s[i] == '_')) {
                token += s[i++];
            }
            // 检查是否是有效宏且未被标记
            if (macros.count(token) && !macros[token].second) {
                macros[token].second = true; // 标记为正在展开
                res += dfs(macros[token].first); // 递归展开内容
                macros[token].second = false; // 回溯
            } else {
                res += token; // 非宏或已标记，直接保留
            }
        } else {
            res += s[i++]; // 其他字符直接保留
        }
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    cin >> n;
    cin.ignore(); // 吸收n后的换行符

    for (int i = 0; i < n; ++i) {
        string line;
        getline(cin, line);

        if (line.empty()) {
            cout << '\n';
            continue;
        }

        if (line[0] == '#') { // 预处理命令
            if (line.substr(1, 6) == "define") { // #define
                int space1 = line.find(' ', 8); // 宏名后的空格位置
                string name = line.substr(8, space1 - 8);
                string content = line.substr(space1 + 1);
                macros[name] = {content, false};
            } else { // #undef
                string name = line.substr(7);
                macros.erase(name);
            }
            cout << '\n';
        } else { // 普通文本
            cout << dfs(line) << '\n';
        }
    }

    return 0;
}
```
* **代码解读概要**：  
代码首先读取输入行数`n`，逐行处理。遇到`#define`时，提取宏名和内容并存入`macros`；遇到`#undef`时删除对应宏。普通文本通过`dfs`函数递归展开，`dfs`逐字符扫描，提取标识符并检查是否为有效宏，若有效则递归展开其内容，避免无限递归。

---

<code_intro_selected>
接下来分析优质题解的核心代码片段，学习其亮点。
</code_intro_selected>

### 题解一（宝硕）核心片段赏析
* **亮点**：使用`unordered_map`存储宏，递归时通过`second`字段标记是否正在展开，避免无限递归。
* **核心代码片段**：
```cpp
std::unordered_map<std::string, std::pair<std::string, bool>> def;

std::string dfs(std::string s) {
    std::string r;
    for (int i = 0, j; i < s.size(); i += j) {
        for (j = 0; i + j < s.size() && (isalnum(s[i+j]) || s[i+j] == '_'); j++);
        if (j) {
            std::string tmp = s.substr(i, j);
            if (def.count(tmp) && !def[tmp].second) {
                def[tmp].second = true;
                r += dfs(def[tmp].first);
                def[tmp].second = false;
            } else {
                r += tmp;
            }
        } else {
            r += s[i++];
        }
    }
    return r;
}
```
* **代码解读**：  
`dfs`函数逐字符扫描字符串，提取标识符（`j`为标识符长度）。若标识符是有效宏且未被标记，则递归展开其内容，标记后回溯。其他字符直接保留。这种设计确保了递归展开的正确性，避免了无限循环。  
* 💡 **学习笔记**：用`pair`的第二个字段标记展开状态，是简洁且高效的防递归方法。

### 题解二（Exschawasion）核心片段赏析
* **亮点**：先词法分析（Tokenize）再递归展开，结构清晰，易于调试。
* **核心代码片段**：
```cpp
Vector tokenize(string & text) {
    Vector result;
    string cur = "";
    int len = text.length();
    int pos = 0;
    while (pos < len) {
        if (is_csyn(text[pos])) { // 是标识符字符
            while (is_csyn(text[pos])) cur += text[pos], pos++;
            result.push_back(cur), cur = "";
        } else {
            result.push_back(string(1, text[pos])), pos++;
        }
    }
    return result;
}

string expand(string & macro, set<string>& expanding) {
    if (macros.find(macro) == macros.end() || expanding.count(macro)) 
        return macro;
    expanding.insert(macro);
    stringstream res;
    Vector tokens = tokenize(macros[macro]);
    for (auto& token : tokens) res << expand(token, expanding);
    expanding.erase(macro);
    return res.str();
}
```
* **代码解读**：  
`tokenize`函数将文本分割为标识符和其他字符的列表（词法单元）。`expand`函数递归展开每个词法单元：若当前宏未被标记，则展开其内容，并递归处理内容中的每个词法单元。这种模块化设计降低了代码复杂度。  
* 💡 **学习笔记**：词法分析（Tokenize）是处理字符串问题的常用技巧，能将复杂问题分解为更小的子问题。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解宏展开的过程，我们设计一个“像素宏展开探险”动画，以8位复古风格展示每一步操作！
</visualization_intro>

### 动画演示主题：像素宏探险  
* **核心演示内容**：展示宏定义、取消定义和普通文本展开的全过程，重点突出标识符识别、递归展开和防无限循环。

### 设计思路：
- **8位像素风格**：用240x160的像素屏幕，主色调为经典的红白机色（红、绿、蓝、黄）。
- **动态元素**：
  - 宏定义/取消定义：用“+”或“-”图标弹出提示，伴随“滴”音效。
  - 标识符识别：绿色方块逐字符移动，圈出当前处理的标识符。
  - 递归展开：黄色箭头从当前标识符指向其展开内容，展开时播放“叮”声；若遇到正在展开的宏，箭头变灰并显示“已标记”。

### 动画帧步骤与交互：
1. **初始化界面**：  
   - 顶部显示“宏状态”窗口（用列表展示当前有效的宏名）。  
   - 中间是“代码行”窗口，显示当前处理的代码行（如`#define A B`或普通文本`A*B`）。  
   - 底部是“控制面板”（单步/自动播放按钮、速度滑块）。  

2. **处理预处理命令**：  
   - 输入`#define A B`时，“宏状态”窗口新增一行`A -> B`，伴随“+”音效。  
   - 输入`#undef A`时，“宏状态”窗口删除`A`，伴随“-”音效。  

3. **处理普通文本（如`A*B`）**：  
   - **单步执行**：点击“下一步”，绿色方块从左到右扫描，识别到`A`（标识符）时高亮。  
   - **递归展开**：若`A`是有效宏，黄色箭头指向其内容（如`B`），展开后显示`B*B`，播放“叮”声。若`B`也是宏，重复此过程。  
   - **防递归**：若展开`A`时再次遇到`A`（如`A`展开为`A+1`），`A`变灰并显示“已标记”，停止展开。  

4. **自动播放模式**：  
   - 点击“自动播放”，算法自动执行所有步骤，速度可调（慢/中/快）。完成所有展开后，播放“胜利”音效，代码行显示最终结果。

### 旁白提示：
- （识别标识符时）“看！绿色方块圈出了标识符`A`，它可能是一个宏。”  
- （展开时）“`A`是有效的宏，现在展开为`B`！”  
- （防递归时）“注意！`A`正在展开中，不再重复展开。”

<visualization_conclusion>
通过这个动画，我们可以直观看到宏展开的每一步，尤其是递归和防无限循环的关键逻辑，帮助我们更深刻地理解算法。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可以尝试以下题目巩固模拟与字符串处理能力：
</similar_problems_intro>

### 通用思路迁移：
本题的核心是“模拟+递归处理”，这种思路适用于：
- 字符串替换问题（如凯撒密码、压缩/解压）；
- 自定义语法解析（如简单的表达式计算、自定义标记语言处理）；
- 状态管理问题（如游戏中的状态切换、配置文件解析）。

### 练习推荐 (洛谷)：
1. **洛谷 P1319 压缩技术**  
   * 🗣️ **推荐理由**：需要模拟字符串的压缩与解压过程，练习字符串分割和状态管理。  
2. **洛谷 P1553 数字反转**  
   * 🗣️ **推荐理由**：处理数字的反转，涉及字符串分割和特殊符号（如小数点、负号）的处理，锻炼细节把控能力。  
3. **洛谷 P1914 小书童——凯撒密码**  
   * 🗣️ **推荐理由**：字符串替换的基础题，适合练习字符操作和循环处理。  

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是值得借鉴的心得：
</insights_intro>

> **参考经验 (来自用户@宝硕)**：“在处理递归展开时，一开始忘记标记正在展开的宏，导致无限递归。后来通过添加`second`字段标记状态，问题迎刃而解。”  
> **点评**：递归问题中，状态标记是防止无限循环的关键。调试时可以打印当前展开的宏名，快速定位循环点。

> **参考经验 (来自用户@WeLikeStudying)**：“用`map`存储宏时被卡常，换成`unordered_map`后效率提升明显。”  
> **点评**：数据量大时，哈希表（`unordered_map`）的查找效率通常高于红黑树（`map`），但需注意哈希冲突的处理。

---

<conclusion>
通过本次分析，我们掌握了预处理器的模拟方法，理解了宏展开的递归逻辑和防无限循环技巧。编程的关键在于细节和调试，多练习类似题目，你会越来越熟练！下次挑战更难的题目，我们不见不散~ 💪
</conclusion>

---
处理用时：189.18秒
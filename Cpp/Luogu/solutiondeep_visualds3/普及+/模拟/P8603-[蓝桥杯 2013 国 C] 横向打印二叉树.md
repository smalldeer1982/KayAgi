# 题目信息

# [蓝桥杯 2013 国 C] 横向打印二叉树

## 题目背景

二叉树可以用于排序。

## 题目描述

其原理很简单：对于一个排序二叉树添加新节点时，先与根节点比较，若小则交给左子树继续处理，否则交给右子树。

当遇到空子树时，则把该节点放入那个位置。

比如，`10 8 5 7 12 4` 的输入顺序，应该建成二叉树如图 $1$ 所示。

本题目要求：根据已知的数字，建立排序二叉树，并在标准输出中横向打印该二叉树。


## 说明/提示

样例解释 1：

![](https://cdn.luogu.com.cn/upload/image_hosting/4z42ybq4.png)

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
10 8 5 7 12 4```

### 输出

```
...|-12
10-|
...|-8-|
.......|...|-7
.......|-5-|
...........|-4```

## 样例 #2

### 输入

```
10 5 20```

### 输出

```
...|-20
10-|
...|-5```

## 样例 #3

### 输入

```
5 10 20 8 4 7```

### 输出

```
.......|-20
..|-10-|
..|....|-8-|
..|........|-7
5-|
..|-4```

# AI分析结果



---
# 💡 Kay的C++算法解析：横向打印二叉树 深入学习指南 💡

<introduction>
今天我们来一起分析“横向打印二叉树”这道C++编程题。这道题需要我们先构建二叉搜索树，再按特定格式横向打印。本指南将帮你理清思路，掌握核心技巧，通过代码和可视化理解每一步！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与树结构应用`

🗣️ **初步分析**：
解决这道题的关键在于两步——**构建二叉搜索树**和**横向打印**。  
二叉搜索树（BST）的构建是典型的模拟过程：每个新节点从根开始，比当前节点小则插入左子树，大则插入右子树，直到找到空位置。而横向打印的难点在于如何用“.”、“|”、“-”等符号还原树的层次结构。  

观察样例输出（如样例1的输出），可以发现打印顺序是“右根左”的中序遍历（先右子树，再根，最后左子树）。每一行对应一个节点，节点间通过“|”连接，缩进用“.”填充。核心是确定每个节点的**行数**（由右子树节点数决定）和**列数**（由父节点的位置和自身值的位数决定）。  

可视化设计上，我们可以用8位像素风格动画展示：  
- **构建阶段**：用不同颜色的像素块表示节点，插入时从根开始左右移动，最终“掉落”到正确位置（伴随“叮”的音效）。  
- **打印阶段**：逐行填充字符数组，高亮当前处理的节点，用闪烁的箭头指示“|”连接的位置，完成时播放“胜利”音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过对题解的思路清晰度、代码规范性、算法有效性等维度评估，以下3道题解（评分≥4星）值得重点参考：
</eval_intro>

**题解一：LaDeX的递归中序遍历解法 (来源：洛谷用户LaDeX)**
* **点评**：此题解思路非常清晰，通过递归中序遍历（右根左）确定节点位置，用全局字符数组`mp`存储输出内容。代码规范（如`ls(x)`、`rs(x)`宏定义左/右儿子），关键变量（`nowL`记录行数，`line`数组记录节点行号）命名明确。亮点在于处理“|”连接时，通过遍历子节点行数并填充，完美还原样例格式。实践价值高，适合直接参考。

**题解二：Wing_的结构体树解法 (来源：洛谷用户Wing_)**
* **点评**：此题解用结构体`Node`存储树节点（含值、左右儿子、行数、列数），递归打印时通过`sum`参数传递缩进量。代码结构工整，特别是`work`函数处理连接符时，通过遍历父节点与子节点的行数差填充“|”，逻辑简洁。亮点在于用“右根左”遍历确保行数正确，适合理解树节点位置的计算逻辑。

**题解三：ChampionCyan的循环插入解法 (来源：洛谷用户ChampionCyan)**
* **点评**：此题解用循环替代递归插入节点（更高效），递归处理打印。代码简洁（仅87行），关键步骤注释清晰（如`str`函数将数字转字符串）。亮点在于用`eof`标记行结尾，输出时直接截断，避免无效字符。适合学习如何优化插入操作。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点集中在树构建和打印格式处理上。结合优质题解，我们提炼以下关键问题及策略：
</difficulty_intro>

1.  **关键点1：如何正确构建二叉搜索树？**
    * **分析**：插入时需从根开始递归或循环比较，小则左、大则右，直到找到空位置。递归插入代码简洁（如LaDeX的`insert`函数），循环插入（如ChampionCyan的`insert`）更高效。  
    * 💡 **学习笔记**：插入时注意更新父节点的左右儿子指针，避免空指针错误。

2.  **关键点2：如何确定节点的输出行数和列数？**
    * **分析**：行数由“右根左”遍历顺序决定（右子树先打印，行数更小），列数由父节点的缩进量+当前节点值的位数+连接符长度（如“|-”占2位）。例如，父节点缩进`sum`，则子节点缩进`sum + 位数 + 3`（含“|-”和“-|”）。  
    * 💡 **学习笔记**：用辅助数组（如`line`、`tr[u].h`）记录节点行数，避免重复计算。

3.  **关键点3：如何处理节点间的“|”连接？**
    * **分析**：父节点与子节点的“|”需在同一列（子节点列数-2），行数覆盖父节点与子节点之间的所有行。例如，左子节点行数大于父节点，需从父节点行到子节点行填充“|”。  
    * 💡 **学习笔记**：填充前需遍历行数区间，确保“|”不被“.”覆盖（如LaDeX的`if (mp[nowL][++ ind] != '|')`判断）。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为“建树”和“打印”两部分，分别解决。  
- **递归遍历顺序**：采用“右根左”中序遍历，确保右子树先打印（行数更小）。  
- **辅助数组记录状态**：用`line`数组记录节点行数，`tr[u].z`记录列数，避免重复计算。  
- **字符数组预处理**：先填充“.”和数字，再处理“|”连接，避免覆盖。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了递归插入和“右根左”打印逻辑，代码简洁且符合样例输出。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了LaDeX和Wing_的思路，采用递归插入和中序遍历打印，确保逻辑清晰且易理解。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 110;
    struct Node {
        int val, l = 0, r = 0, h = 0, z = 0; // 节点值、左右儿子、行数、列数
    } tree[N];
    int idx = 0, root = 0, h = 0; // 节点编号、根节点、总行数
    char c[110][10010]; // 存储输出字符

    void insert(int &u, int x) { // 递归插入（引用传递更新父节点）
        if (!u) {
            u = ++idx;
            tree[u].val = x;
            return;
        }
        if (x < tree[u].val) insert(tree[u].l, x);
        else insert(tree[u].r, x);
    }

    void print(int u, int sum) { // 右根左遍历，sum为当前缩进量
        if (!u) return;
        int val = tree[u].val, cnt = 0;
        char num[10];
        while (val) { num[++cnt] = val % 10 + '0'; val /= 10; } // 数字转字符
        reverse(num + 1, num + cnt + 1);

        print(tree[u].r, sum + 3 + cnt); // 先处理右子树

        h++; // 当前节点行数
        tree[u].h = h;
        if (sum) { // 非根节点，填充缩进和"|-"
            for (int i = 1; i <= sum - 2; i++) c[h][i] = '.';
            c[h][sum - 1] = '|'; c[h][sum] = '-';
        }
        tree[u].z = sum + 1; // 当前节点列数起点
        for (int i = 1; i <= cnt; i++) c[h][sum + i] = num[i]; // 填充数字
        if (tree[u].l || tree[u].r) { // 非叶子节点，填充"-|"
            c[h][sum + cnt + 1] = '-'; c[h][sum + cnt + 2] = '|';
        }

        print(tree[u].l, sum + 3 + cnt); // 处理左子树

        // 填充父节点与子节点的"|"连接
        if (tree[u].r) { // 右子树连接
            int rh = tree[tree[u].r].h, rz = tree[tree[u].r].z;
            for (int i = rh; i <= tree[u].h; i++) c[i][rz - 2] = '|';
        }
        if (tree[u].l) { // 左子树连接
            int lh = tree[tree[u].l].h, lz = tree[tree[u].l].z;
            for (int i = tree[u].h; i <= lh; i++) c[i][lz - 2] = '|';
        }
    }

    int main() {
        int x;
        while (cin >> x) insert(root, x); // 插入所有节点
        print(root, 0); // 从根开始打印，缩进0
        for (int i = 1; i <= h; i++) { // 输出每一行
            for (int j = 1; c[i][j]; j++) cout << c[i][j];
            cout << "\n";
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先递归插入节点构建二叉搜索树，然后通过“右根左”中序遍历确定每个节点的行数（`h`）和列数（`sum`），填充字符数组`c`。最后处理父节点与子节点的“|”连接，确保格式正确。核心逻辑在`print`函数中，通过递归处理左右子树，填充缩进、数字和连接符。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，学习其中的巧妙设计：
</code_intro_selected>

**题解一：LaDeX的递归打印片段**
* **亮点**：用`nowL`记录当前行数，`line`数组存储节点行号，处理“|”时遍历行数区间，确保连接正确。
* **核心代码片段**：
    ```cpp
    void output(LL p, LL space) {
        if (tree[p] == -1) return;
        // ...（计算Add等）
        output(rs(p), space + Add); // 先处理右子树
        ++nowL; line[p] = nowL; // 更新行数
        // 填充缩进和数字
        if (p != 1) { mp[nowL][++ind] = '|'; mp[nowL][++ind] = '-'; } // 非根节点加"|-"
        // 填充数字和"-|"（非叶子节点）
        // 处理左右子树的"|"连接
        if (tree[ls(p)] != -1) {
            LL L = line[ls(p)], now = line[p];
            for (LL i = L; i >= now; i--) mp[i][ind - 1] = '|'; // 左子树连接
        }
    }
    ```
* **代码解读**：  
  `output`函数通过递归右子树→处理当前节点→递归左子树的顺序，确保右子树先打印（行数更小）。`line[p]`记录当前节点的行数，填充缩进时用“.”覆盖非“|”位置，避免连接符被覆盖。最后遍历左子树行数区间，填充“|”连接父节点与子节点。  
* 💡 **学习笔记**：递归顺序决定行数，辅助数组（如`line`）是记录状态的关键。

**题解二：Wing_的连接符处理片段**
* **亮点**：用结构体`Node`存储节点信息，`work`函数遍历父节点与子节点的行数差，填充“|”连接符。
* **核心代码片段**：
    ```cpp
    void work(int u) {
        if (!u) return;
        int uh = tr[u].h;
        if (tr[u].r) { // 右子树连接
            int rh = tr[tr[u].r].h, rz = tr[tr[u].r].z;
            for (int i = rh; i <= uh; i++) c[i][rz - 2] = '|';
        }
        if (tr[u].l) { // 左子树连接
            int lh = tr[tr[u].l].h, lz = tr[tr[u].l].z;
            for (int i = uh; i <= lh; i++) c[i][lz - 2] = '|';
        }
        work(tr[u].l), work(tr[u].r); // 递归处理子节点
    }
    ```
* **代码解读**：  
  `work`函数在打印完成后调用，遍历父节点与子节点的行数区间（右子树行数`rh`到父节点行数`uh`，左子树行数`uh`到`lh`），在对应列（子节点列数-2）填充“|”，确保父子节点连接。  
* 💡 **学习笔记**：连接符处理需在所有节点位置确定后进行，避免覆盖数字或缩进。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了直观理解树的构建和打印过程，我们设计一个“像素二叉树探险”动画，用8位复古风格展示每一步！
\</visualization\_intro\>

  * **动画演示主题**：`像素二叉树探险——构建与打印之旅`

  * **核心演示内容**：  
    1. **构建阶段**：输入数字逐个插入二叉搜索树，节点以彩色像素块（如蓝色）从根开始移动，小则左、大则右，最终“掉落”到空位置（伴随“叮”音效）。  
    2. **打印阶段**：切换到“打印模式”，用黄色像素块表示当前处理节点，按“右根左”顺序逐行填充字符数组：缩进用“.”（灰色像素），数字用白色，“|”和“-”用红色。连接符填充时，红色像素逐行闪烁。

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）营造轻松氛围；插入时的移动动画和音效强化节点位置记忆；打印时的颜色区分（数字白、连接符红）突出关键步骤；单步/自动播放控制帮助学习者观察细节。

  * **动画帧步骤与交互关键点**：

    1.  **初始化界面**：  
        - 左半屏为“树构建区”（网格背景，根节点在中心），右半屏为“打印预览区”（字符数组网格）。  
        - 控制面板：单步/自动按钮、速度滑块（1-5倍速）、重置按钮。  

    2.  **插入节点动画**：  
        - 输入数字“10”→根节点（绿色）出现，显示“10”。  
        - 输入“8”→红色箭头从根左移，节点“8”（蓝色）跟随移动，最终在左子位置“掉落”（音效：“叮”）。  
        - 类似步骤插入所有节点，树结构动态扩展。  

    3.  **打印过程动画**：  
        - 切换到打印模式，右半屏显示空白字符数组（全“.”）。  
        - 当前节点（黄色）标记为根，执行“右根左”遍历：  
          - 先处理右子节点（如样例1的“12”），在第1行填充“...|-12”（灰色“.”、红色“|-”、白色“12”）。  
          - 处理根节点“10”，在第2行填充“10-|”。  
          - 处理左子节点“8”，在第3行填充“...|-8-|”。  
        - 连接符填充：父节点“8”与子节点“5”之间的行，红色“|”逐行出现（音效：“滴”）。  

    4.  **完成与交互**：  
        - 所有节点打印完成，播放“胜利”音效（升调），最终输出高亮显示。  
        - 支持单步回退，查看每一步的字符数组变化。  

  * **旁白提示**：  
    - 插入时：“新节点8比根10小，向左子树移动～”  
    - 打印时：“当前处理右子节点12，它的行号是1，缩进3个点...”  
    - 连接符填充时：“注意看，父节点8和子节点5之间的行需要填充红色竖线！”

\<visualization\_conclusion\>
通过这个动画，我们不仅能“看”到二叉树的构建过程，还能直观理解打印时的缩进、连接符逻辑，让抽象的算法变得生动！
\</visualization\_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握此题后，可尝试以下题目巩固树结构和模拟打印的技巧：
\</similar\_problems\_intro\>

  * **通用思路/技巧迁移**：  
    二叉搜索树的构建和横向打印的核心是“模拟+树遍历”，类似思路可用于：  
    1. 二叉树的竖直打印（如洛谷P1305）。  
    2. 多叉树的层次打印（如目录结构可视化）。  
    3. 表达式树的中序/后序遍历输出（如洛谷P7073）。  

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1030 [NOIP2001 普及组] 求先序排列**  
          * 🗣️ **推荐理由**：通过中序和后序遍历还原二叉树，巩固树结构的遍历与重建。  
    2.  **洛谷 P1087 FBI树**  
          * 🗣️ **推荐理由**：根据输入构建特殊二叉树（FBI树）并后序遍历输出，练习树的构建与遍历。  
    3.  **洛谷 P1305 新二叉树**  
          * 🗣️ **推荐理由**：给定二叉树的先序遍历和每个节点的左右儿子，求中序遍历，强化树的遍历与存储。  

---

## 7\. 学习心得与经验分享 (若有)

\<insights\_intro\>
部分题解作者分享了调试经验，这些对我们很有启发：
\</insights\_intro\>

> **参考经验 (来自LaDeX)**：“最初在处理连接符时，总被‘.’覆盖，后来发现需要先填充数字和缩进，最后再填充‘|’，并判断当前位置是否已有‘|’。”  
> **点评**：LaDeX的经验提醒我们，打印顺序很重要——先处理“.”和数字，最后处理连接符，避免覆盖。这是调试此类格式题的关键技巧！

---

\<conclusion\>
本次关于“横向打印二叉树”的分析就到这里。希望你通过代码、可视化和拓展练习，掌握树结构的构建与打印技巧。记住，多动手调试、观察样例输出，是解决此类模拟题的关键！下次见～💪
\</conclusion\>

---
处理用时：186.60秒
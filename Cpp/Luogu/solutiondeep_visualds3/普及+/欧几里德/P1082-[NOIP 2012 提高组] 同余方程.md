# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP 2012 提高组] 同余方程 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扩展欧几里得算法（exgcd）、欧拉定理+快速幂（逆元求解）

🗣️ **初步分析**：  
题目要求找到满足 `ax ≡ 1 (mod b)` 的最小正整数x——其实这就是求**a在模b下的乘法逆元**（相当于模意义下的“倒数”）。比如样例中3×7=21，21 mod10=1，所以7是3的逆元。

解决这个问题的核心思路有两种：  
### 方法1：扩展欧几里得算法（exgcd）  
就像“拆积木”：把大问题拆成小问题，解决小问题后再拼回原问题的解。  
原方程可转化为 `ax + by = 1`（y是辅助整数），而扩展欧几里得算法能求`ax + by = gcd(a,b)`的解。由于题目保证有解（a和b互质，gcd(a,b)=1），刚好能用这个算法。  

### 方法2：欧拉定理+快速幂  
欧拉函数φ(b)表示1~b中与b互质的数的个数。根据欧拉定理，`a^φ(b) ≡ 1 (mod b)`，两边除以a得`x ≡ a^(φ(b)-1) (mod b)`——直接用快速幂计算这个值就行！

**核心难点**：  
- 如何把同余方程转化为线性不定方程？  
- 扩展欧几里得的递归过程怎么理解？  
- 如何把求出的解调整为最小正整数？  

**可视化设计思路**：  
用8位像素风展示扩展欧几里得的递归过程——比如用红色方块代表a，蓝色代表b，绿色代表x，黄色代表y。递归时a和b“缩小”成b和a%b，直到b=0（此时x=1）；回溯时x和y“生长”成原问题的解。关键步骤用闪烁高亮，搭配“叮”的像素音效（递归下探一声，回溯更新一声），找到解时播放胜利音效！


## 2. 精选优质题解参考

### 题解一：学委（赞：1545）  
* **点评**：这是最经典的扩展欧几里得解法，思路“一步一步来”特别适合新手。作者把问题转化（同余→不定方程）、扩展欧几里得的推导（从子问题解到原问题解）、答案调整（负数转最小正整数）讲得巨细——甚至证明了“为什么解要加b取模”。代码用全局变量x/y传递解，逻辑清晰，能直接AC，是新手入门的“标准答案”。

### 题解二：沙普绿12138（赞：115）  
* **点评**：不想背exgcd？这个“非扩欧解法”太适合你！作者用欧拉定理绕开了递归，直接通过“分解质因数求φ(b)”+“快速幂计算a^(φ(b)-1)”得到解。代码里的`fai`函数（求欧拉函数）和`fast_pow`函数（快速幂）都是“模板级”的，易懂好记。缺点是欧拉函数的推导需要点数论基础，但胜在“另辟蹊径”。

### 题解三：陈曦（赞：88）  
* **点评**：作者对比了三种方法——暴力（80分）、快速幂（10分，仅质数模可用）、exgcd（100分），把每种方法的优缺点讲得明明白白。比如暴力法“简单但超时”，快速幂“只适用于质数模”，exgcd“通用且高效”。代码里的exgcd用全局变量，还加了快读，细节到位，适合对比学习。


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何把同余方程转化为线性不定方程？  
- **分析**：`ax ≡ 1 (mod b)`的意思是“ax减1是b的倍数”，即`ax - 1 = by`（y是整数）。移项得`ax + b*(-y) = 1`——这就是线性不定方程`ax + by = 1`（把-y换成y就行）。  
- 💡 **学习笔记**：同余方程转不定方程的关键是“模运算转倍数关系”。

### 2. 难点2：扩展欧几里得的递归过程怎么理解？  
- **分析**：扩展欧几里得的核心是“递归下探，回溯求解”。比如求`exgcd(a,b)`时，先求`exgcd(b, a%b)`（子问题），得到子问题的解x2,y2，再通过公式`x = y2, y = x2 - (a/b)*y2`得到原问题的解。递归终止条件是b=0（此时a=gcd(a,b)，解为x=1,y=0）。  
- 💡 **学习笔记**：子问题的解是“积木块”，原问题的解是“拼好的积木”。

### 3. 难点3：如何得到最小正整数解？  
- **分析**：扩展欧几里得求出的x可能是负数或很大的数。根据不定方程的性质，所有解都满足`x = x0 + k*(b/gcd(a,b))`（k是整数）。由于gcd(a,b)=1，所以解的周期是b。用`(x % b + b) % b`就能把x调整到0~b之间的最小正整数。  
- 💡 **学习笔记**：模运算能“圈住”解的范围，避免负数或过大。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（扩展欧几里得版）  
* **说明**：综合学委、陈曦等题解的思路，提炼出最简洁的exgcd实现。  
* **完整核心代码**：  
```cpp
#include <iostream>
using namespace std;

long long x, y; // 存储当前方程的解

void exgcd(long long a, long long b) {
    if (b == 0) { // 递归终止：b=0时，a是gcd，解为x=1,y=0
        x = 1;
        y = 0;
        return;
    }
    exgcd(b, a % b); // 先求解子问题
    long long tx = x; // 保存子问题的x
    x = y; // 原问题x = 子问题y
    y = tx - (a / b) * y; // 原问题y = 子问题x - (a/b)*子问题y
}

int main() {
    long long a, b;
    cin >> a >> b;
    exgcd(a, b);
    x = (x % b + b) % b; // 调整为最小正整数解
    cout << x << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. 定义全局变量x,y存储解（避免递归传参麻烦）；  
  2. exgcd函数递归求解：先处理子问题，再通过子问题的解更新原问题的解；  
  3. 主函数调用exgcd后，调整x为最小正整数解并输出。


### 题解二（欧拉定理+快速幂）核心片段赏析  
* **亮点**：用数论公式绕开递归，代码简洁。  
* **核心代码片段**：  
```cpp
int fai(int n) { // 求欧拉函数φ(n)
    int ans = 1;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            n /= i;
            ans *= i - 1;
            while (n % i == 0) {
                n /= i;
                ans *= i;
            }
        }
    }
    if (n > 1) ans *= n - 1;
    return ans;
}

int fast_pow(int x, int k) { // 快速幂：计算x^k mod b
    long long ans = 1, quan = x;
    while (k) {
        if (k & 1) ans = ans * quan % b;
        quan = quan * quan % b;
        k >>= 1;
    }
    return (int)ans;
}
```
* **代码解读**：  
  - `fai`函数：分解n的质因数，根据欧拉函数公式`φ(p^k) = p^k - p^(k-1)`计算φ(n)（比如φ(10)=φ(2×5)=1×4=4）；  
  - `fast_pow`函数：用二进制拆分k，快速计算x^k mod b（比如计算3^(4-1)=3^3=27，27 mod10=7，就是样例的解）。  
* 💡 **学习笔记**：欧拉函数是数论中的“工具人”，快速幂是“效率神器”——两者结合能快速求逆元。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：像素积木的“拆分与拼接”（扩展欧几里得过程）  
### 设计思路  
用8位红白机风格，把扩展欧几里得的递归过程变成“拆积木→拼积木”的游戏——让抽象的数论变得可“看”可“玩”！

### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧：红色方块（a=3）、蓝色方块（b=10），下方显示“当前方程：3x +10y=1”；  
   - 屏幕右侧：控制面板（单步、自动、重置按钮，速度滑块）；  
   - 背景：8位风格的网格，播放轻快的“像素BGM”。

2. **递归下探（拆积木）**：  
   - 点击“单步”：a和b变成b（10）和a%b（3%10=3），屏幕显示“子问题：10x +3y=1”，伴随“叮”的音效；  
   - 再点“单步”：a=3，b=10%3=1，显示“子问题：3x +1y=1”，再“叮”；  
   - 再点“单步”：a=1，b=3%1=0，显示“终止：1x +0y=1”，此时x=1（绿色方块闪烁）。

3. **回溯拼接（拼积木）**：  
   - 回溯第一步：从子问题（1x+0y=1）得到原问题（3x+1y=1）的解：x=0（子问题y），y=1 - 3/1*0=1（黄色方块闪烁），显示“当前解：x=0,y=1”；  
   - 回溯第二步：从子问题（3x+1y=1）得到原问题（10x+3y=1）的解：x=1（子问题y），y=0 -10/3*1= -3，显示“当前解：x=1,y=-3”；  
   - 回溯第三步：从子问题（10x+3y=1）得到原问题（3x+10y=1）的解：x=-3（子问题y），y=1 -3/10*(-3)=1+0=1（因为3/10=0），显示“当前解：x=-3,y=1”。

4. **解调整与胜利**：  
   - 计算`(x%b +b)%b`：-3%10=-3，+10得7，%10得7，绿色方块（x=7）放大闪烁；  
   - 播放“胜利音效”（上扬的8位音调），屏幕显示“最小正整数解：7”！

### 交互设计  
- 单步模式：每点一次按钮，执行一步递归/回溯；  
- 自动模式：按滑块速度（1~5倍速）自动播放，适合快速看流程；  
- 重置按钮：回到初始状态，重新演示。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
- 扩展欧几里得：可解所有线性不定方程`ax + by = c`（当c是gcd(a,b)的倍数时）；  
- 逆元：在模运算中“代替除法”（比如计算(a/b) mod p，等价于a*inv(b) mod p）；  
- 欧拉定理：适用于所有互质的a和b，比费马小定理（仅质数模）更通用。

### 洛谷练习推荐  
1. **P3811 【模板】乘法逆元**  
   - 🗣️ **推荐理由**：直接练逆元的三种求法（exgcd、快速幂、线性递推），巩固本题核心知识点。  
2. **P2613 【模板】有理数取余**  
   - 🗣️ **推荐理由**：需要用逆元将分数转整数（比如a/b mod p = a*inv(b) mod p），练逆元的实际应用。  
3. **P1516 青蛙的约会**  
   - 🗣️ **推荐理由**：用扩展欧几里得解线性同余方程（类似本题的变形），练“问题转化”能力。


## 7. 学习心得与经验分享  

### 参考经验（来自学委）  
“不能暴力枚举x，会超时！”  
- **点评**：这是新手最容易踩的坑——当b是2e9时，暴力枚举会直接TLE。数学方法（exgcd、欧拉定理）的效率是O(log b)，比暴力快亿倍！

### 参考经验（来自沙普绿）  
“欧拉定理可以绕开exgcd！”  
- **点评**：如果不想背递归模板，欧拉定理+快速幂是另一种选择——但要记得先求欧拉函数！

### 参考经验（来自陈曦）  
“快速幂只适用于质数模！”  
- **点评**：费马小定理的条件是“b是质数”，而本题b可以是任意数——所以exgcd更通用！


## 总结  
解决同余方程的关键是**把问题转化为数学模型**（不定方程或欧拉定理），再用算法（exgcd、快速幂）求解。扩展欧几里得像“拆积木”，欧拉定理像“套公式”——两种方法都要掌握，才能应对不同场景！  

记住：数论问题不可怕，只要“拆”对问题，“套”对公式，再难的题也能解决～ 💪

---
处理用时：175.77秒
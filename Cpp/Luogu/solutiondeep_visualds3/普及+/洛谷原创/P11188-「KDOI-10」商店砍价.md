# 题目信息

# 「KDOI-10」商店砍价

## 题目背景

您可以点击 [这里](https://www.luogu.com.cn/fe/api/problem/downloadAttachment/3jbtilzv) 下载本场比赛的选手文件。

密码：`rAnHoUyaSuoBaoMimaNijuEdefAngsHa2)2$1)0(2@0!`

**本场比赛所有题目从标准输入读入数据，输出到标准输出。**

## 题目描述

有一个正整数 $n$，保证其只由数字 $1\sim 9$ 构成。

你可以做任意多次如下操作：

- 选择 $n$ 的一个数位 $x$，花费 $v_x$ 的代价删除它，注意，此时 $n$ 的数位个数会减少 $1$，$n$ 的值也会发生相应的变化；
- 或者，花费 $n$ 的代价把剩余的所有数位删除。

求把整个数删除的最小代价。

## 说明/提示

**【样例 1 解释】**

对于第一组测试数据，最优操作方案如下：

- 删除数位 $2$，代价为 $10$，此时 $n$ 变为 $13$；
- 删除数位 $3$，代价为 $10$，此时 $n$ 变为 $1$；
- 删除 $n$ 的剩余所有数位，代价为 $1$。

总代价为 $10+10+1=21$，可以证明，这是代价的最小值。

对于第二组测试数据，一种最优操作方案如下：

- 删除第一个数位 $1$，代价为 $2$，此时 $n$ 变为 $121$；
- 删除最后一个数位 $1$，代价为 $2$，此时 $n$ 变为 $12$；
- 删除数位 $2$，代价为 $1$，此时 $n$ 变为 $1$；
- 删除 $n$ 的剩余所有数位，代价为 $1$。

总代价为 $2+2+1+1=6$。

**【样例 2】**

见选手目录下的 `bargain/bargain2.in` 与 `bargain/bargain2.ans`。

这个样例满足测试点 $3\sim 6$ 的约束条件。

**【样例 3】**

见选手目录下的 `bargain/bargain3.in` 与 `bargain/bargain3.ans`。

这个样例满足测试点 $11$ 的约束条件。

**【样例 4】**

见选手目录下的 `bargain/bargain4.in` 与 `bargain/bargain4.ans`。

这个样例满足测试点 $17,18$ 的约束条件。

**【样例 5】**

见选手目录下的 `bargain/bargain5.in` 与 `bargain/bargain5.ans`。

这个样例满足测试点 $23\sim 25$ 的约束条件。

***

**【数据范围】**

对于全部的测试数据，保证：

- $1\le t\le 10$；
- $1\le n< 10^{10^5}$；
- 对于任意 $1\le i\le 9$，$1\le v_i\le 10^5$；
- $n$ 由数字 $1\sim 9$ 构成。

|   测试点    |   $n<$    | $v_i\le$ |        特殊性质        |
| :---------: | :---------: | :------: | :--------------------: |
|     $1$     |    $100$     |  $10^5$  |           无           |
|     $2$     |    $10^3$    |  $10^5$  |           无           |
|  $3\sim 6$  |  $10^{18}$  |  $10^5$  |           无           |
| $7\sim 9$  |  $10^{40}$  |  $10^5$  |           无           |
|    $10$    | $10^{10^5}$ |  $10^5$  | $n$ 由至多一种数字构成 |
|    $11$     | $10^{10^5}$ |  $10^5$  | $n$ 由至多两种数字构成 |
| $12,13$ | $10^{10^5}$ |  $10^5$  | $n$ 由至多三种数字构成 |
| $14\sim 16$ | $10^{10^3}$ | $10^5$ | $v_1=v_2=v_3=\dots =v_9$ |
| $17,18$ | $10^{10^5}$ | $10^5$ | $v_1=v_2=v_3=\dots =v_9$ |
| $19,20$ | $10^{100}$ | $100$ | 无 |
| $21,22$ | $10^{10^3}$ | $10^3$ | 无 |
| $23\sim 25$ | $10^{10^5}$ | $10^5$ | 无 |

## 样例 #1

### 输入

```
0
3
123
10 10 10 10 10 10 10 10 10 
1121
2 1 2 2 2 2 2 2 2
987654321
1 2 3 4 5 6 7 8 9
```

### 输出

```
21
6
45
```

# AI分析结果


### 💡 Kay的C++算法解析：「KDOI-10」商店砍价 深入学习指南 💡

<introduction>
今天我们来分析「KDOI-10」商店砍价这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过生动的像素动画演示，你将直观感受动态规划的执行过程！
</introduction>

#### 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划（序列DP）` 与 `位权计算技巧`

🗣️ **初步分析**：
> 解决这道题的关键在于运用**动态规划**，就像玩俄罗斯方块时精心安排方块位置以消除整行一样，我们需要在数字串中智能选择保留哪些数位，最小化总代价。核心思路是：  
> - **倒序DP**：从数字末尾向前处理，方便计算保留数字的位权（个位、十位等）  
> - **状态压缩**：利用`v_i ≤ 10^5`的性质，只需考虑保留0~6位数（超过6位时一次性删除不划算）  
> - **可视化设计**：动画将展示数字串的像素方块，高亮当前决策位（删除/保留），显示状态转移和代价更新过程  
> - **复古游戏化**：采用8位像素风格（类似FC游戏），数字方块用不同颜色区分状态（删除/保留/当前位）。关键操作配“咔嚓”删除音效和“叮”保留音效，自动演示模式像贪吃蛇AI逐步展示最优决策路径  

---

#### 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法优化和实践价值角度，精选出三条优质题解：
</eval_intro>

**题解一（无名之雾）**
* **点评**：思路直击核心——通过枚举最终保留位数（≤6）设计倒序DP。状态定义`f[i][j]`（前i位保留j位的最小代价）简洁合理，转移方程`min(删除代价, 保留代价)`逻辑清晰。代码用`min(S,i)`优化循环范围，变量名`a[i]`、`e[j]`（10的幂次）含义明确。亮点在于严谨证明保留位数的上限，实践可直接用于竞赛。

**题解二（Petit_Souris）**
* **点评**：同样采用倒序DP但状态设计更精细——`dp[i][j]`表示考虑低i位（从后往前）保留j位。预处理10的幂次提升效率，边界处理完整（INF初始化和`min_element`取答案）。代码规范性强，包含详细复杂度分析和数据范围证明，是学习工业级DP实现的优秀范本。

**题解三（hez_EX）**
* **点评**：创新性从低位向高位DP，状态转移`f[i][j]=min(f[i-1][j]+v_i, f[i-1][j-1]+digit*10^{j-1})`体现了对位权本质的理解。代码中`a[]`存储倒序数字串，`e[]`预计算幂次，结构工整。虽变量命名稍简略，但算法有效性高，洛谷实测AC。

---

#### 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点，结合优质题解策略如下：
</difficulty_intro>

1.  **难点1：状态定义困难（如何表示保留过程？）**
    * **分析**：优质题解统一采用二维DP状态，第一维表示处理位置，第二维表示保留位数。倒序设计（hez_EX）或正序倒存（无名之雾）均解决位权计算问题。
    * 💡 **学习笔记**：倒序处理时，当前位的位权=10^(已保留位数)，自然形成数字的十进制结构。

2.  **难点2：位权动态计算（保留的数字如何估值？）**
    * **分析**：当保留第j位时，其实际值=数字×10^(j-1)。Petit_Souris通过预计算`pw10`数组优化，避免重复计算幂次。
    * 💡 **学习笔记**：幂次数组只需0~5（10^0至10^5），空间复杂度O(1)。

3.  **难点3：复杂度优化（n可达10^5位）**
    * **分析**：利用关键性质——保留位数j≤6。无名之雾和hez_EX在DP中限制j≤6，将复杂度从O(n²)降至O(6n)。
    * 💡 **学习笔记**：证明核心：若保留7位，最大代价7×10^5=700,000 < 10^6（最小7位数），故不优。

### ✨ 解题技巧总结
<summary_best_practices>
通用解题策略与最佳实践：
</summary_best_practices>
- **技巧1：问题分解** - 将删除操作分解为"最终保留的子序列"和"删除的位"，转化为子序列DP问题
- **技巧2：逆向思维** - 从数字末尾向前处理（倒序DP），避免保留数字的位权计算混乱
- **技巧3：边界处理** - 初始化dp[0][0]=0，其他设为无穷大，使用`min_element`取答案防漏解
- **技巧4：幂次优化** - 预处理10的幂次数组（长度6），避免重复计算

---

#### 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解优化的通用实现，含完整DP框架和位权处理：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：融合无名之雾的倒序DP框架与Petit_Souris的幂次预处理，变量命名更明确。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll INF = 1e18;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int c, T;
    cin >> c >> T;
    
    // 预处理10的幂次：0~5次方
    vector<ll> pow10(6, 1);
    for (int i = 1; i < 6; ++i) 
        pow10[i] = pow10[i-1] * 10;

    while (T--) {
        string num_str;
        cin >> num_str;
        int len = num_str.size();
        vector<int> digits(len);
        for (int i = 0; i < len; ++i) 
            digits[i] = num_str[i] - '0';

        vector<int> v(10); // 1~9的删除代价
        for (int i = 1; i <= 9; ++i) 
            cin >> v[i];

        // dp[i][j]: 从后向前处理i位，保留j位的最小代价
        vector<vector<ll>> dp(len+1, vector<ll>(7, INF));
        dp[0][0] = 0; // 初始化：0位0保留

        // 倒序DP：从最后一位向前
        for (int i = 1; i <= len; ++i) {
            int digit = digits[len - i]; // 当前位实际数字
            for (int j = 0; j <= 6; ++j) {
                // 选择1：删除当前位
                if (dp[i-1][j] != INF) 
                    dp[i][j] = min(dp[i][j], dp[i-1][j] + v[digit]);
                
                // 选择2：保留当前位（需j≥1）
                if (j >= 1 && dp[i-1][j-1] != INF) 
                    dp[i][j] = min(dp[i][j], dp[i-1][j-1] + digit * pow10[j-1]);
            }
        }

        // 答案取最小值（保留0~6位）
        ll ans = *min_element(dp[len].begin(), dp[len].end());
        cout << ans << '\n';
    }
    return 0;
}
```
* **代码解读概要**：
  1. **预处理**：`pow10`存储10^0至10^5，避免重复计算
  2. **状态初始化**：`dp[0][0]=0`表示未处理任何位时零代价
  3. **倒序DP**：外循环`i`实际处理原串倒数第i位（`digits[len-i]`）
  4. **双决策转移**：
     - 删除：继承`j`不变，加`v[digit]`
     - 保留：从`j-1`转移，加`digit×10^(j-1)`
  5. **答案提取**：取`dp[len][0..6]`最小值

---
<code_intro_selected>
精选题解核心片段对比分析：
</code_intro_selected>

**题解一（无名之雾）**
* **亮点**：正序存储倒序数字串，循环范围优化（`min(S,i)`）
* **核心代码片段**：
```cpp
for(int i=1;i<=n;i++) {
    f[i][0] = f[i-1][0] + v[a[i]];
    for(int j=1; j<=min(S,i); j++)
        f[i][j] = min(f[i-1][j] + v[a[i]], 
                     f[i-1][j-1] + a[i] * e[j-1]);
}
```
* **代码解读**：
  > `a[i]`存储原串倒序后的数字，`e[j-1]`=10^(j-1)。`f[i][0]`表示前i位全删除的代价。内循环限制`j≤min(6,i)`避免无效计算，是空间优化关键。  
* 💡 **学习笔记**：倒序存储使先处理数字的位权=10^(j-1)，自然形成十进制数。

**题解二（Petit_Souris）**
* **亮点**：从后向前DP，`pw10`数组命名更明确
* **核心代码片段**：
```cpp
per(i,n,1) { // 从后向前
    rep(j,0,5) {
        dp[i][j] = min(dp[i][j], dp[i+1][j] + v[a[i]]);
        if(j^5) dp[i][j+1]=min(dp[i][j+1], dp[i+1][j]+a[i]*pw10[j]);
    }
}
```
* **代码解读**：
  > `dp[i][j]`定义从第i位到末尾保留j位的最小代价。`dp[i+1][j] + v[a[i]]`对应删除当前位；`dp[i+1][j] + a[i]*pw10[j]`则保留当前位作为第j+1位（位权10^j）。  
* 💡 **学习笔记**：状态设计中`j`表示已保留位数，新保留位的位权由`j`决定。

**题解三（hez_EX）**
* **亮点**：低位到高位DP，直观体现代价累积
* **核心代码片段**：
```cpp
for(int i(1);i<=n;++i) {
    dp[i][0]=dp[i-1][0]+v[digits[i]];
    for(int j(1);j<=5;++j) 
        dp[i][j]=min(dp[i-1][j]+v[digits[i]], 
                     dp[i-1][j-1]+digits[i]*pow10[j-1]);
}
```
* **代码解读**：
  > `digits[]`存储原串倒序。`dp[i][0]`即前i位全删除的代价和。保留时`digits[i] * pow10[j-1]`计算当前位在j位数字中的实际贡献。  
* 💡 **学习笔记**：倒序存储后，数字位置与位权幂次天然匹配。

---

#### 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为直观理解倒序DP的执行过程，我设计了像素化动画方案，融合复古游戏元素：
</visualization_intro>

* **动画主题**：`「数字消除者」- 8位像素风格DP冒险`
* **核心演示**：倒序决策过程 + 状态转移 + 位权计算

* **设计思路**：
  > 采用FC红白机像素风格（16色调色板），数字显示为16×16像素方块。将DP状态表设计为"关卡地图"，保留数字按位权自动组合。游戏化元素增强理解：
  > - **删除操作**：方块爆炸特效 + "咔嚓"音效  
  > - **保留操作**：方块移动到下方"保留区" + "叮"音效  
  > - **位权计算**：保留时显示`digit × 10^j`公式浮动文字  

* **动画帧步骤**：
  1. **场景初始化**：
     - 上方网格显示数字串（如"123"），每位用彩色像素方块表示
     - 下方"DP状态表"：行=处理进度，列=保留位数，初始状态[0][0]高亮
     - 控制面板：开始/暂停/单步/速度滑块（调速）
     - 背景：循环8-bit芯片音乐

  2. **决策演示（单步）**：
     - **Step1**：高亮当前位（从右向左移动，如先处理'3'），方块闪烁黄光
     - **删除分支**：点击"删除"按钮，方块爆炸消失，播放"咔嚓"音效，状态表`dp[i][j]`更新（红色数字跳变）
     - **保留分支**：点击"保留"按钮，方块移动到下方保留区最左侧，播放"叮"音效，显示位权计算（如"3×1=3"），状态表`dp[i][j+1]`更新（绿色数字跳变）

  3. **自动演示模式**：
     - 点击"AI运行"：像贪吃蛇AI自动选择最优路径，保留区数字实时拼接（如保留'3'→'2'+'3'显示为23）
     - 关键步骤：当保留位数j增加时，播放"升级"音效，保留区数字重组显示位权变化

  4. **结果展示**：
     - 成功：所有位处理完，状态表最小代价格子发光，播放胜利音效
     - 路径对比：可切换不同题解策略，并排显示状态表差异

* **技术实现**：
  - **Canvas绘制**：网格用`drawGrid()`，方块状态用`fillRect()`
  - **交互控制**：`requestAnimationFrame`驱动主循环，速度滑块控制帧间隔
  - **音效**：Web Audio API播放8-bit音效（删除：短促方波；保留：清脆三角波）

<visualization_conclusion>
通过像素动画，你将清晰看到数字如何被保留/删除，状态表如何更新，深入理解倒序DP的决策逻辑！
</visualization_conclusion>

---

#### 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的序列DP技巧后，可解决更多子序列相关问题：
</similar_problems_intro>

* **通用技巧迁移**：
  - **子序列构造**：如保留特定条件子序列的最小代价（本题的保留位≤6）
  - **位权处理**：大数计算中按位处理（如高精度加减）
  - **状态压缩**：利用数据范围限制状态空间（如`j≤6`）

* **洛谷题目推荐**：
  1. **P1020 导弹拦截** - NOIP1999提高组
     * 🗣️ **推荐理由**：练习最长不上升子序列DP，强化序列状态设计能力
  2. **P2758 编辑距离** 
     * 🗣️ **推荐理由**：经典二维DP，状态转移与本题异曲同工（增/删/改操作）
  3. **P1048 采药** - 01背包问题
     * 🗣️ **推荐理由**：背包是DP的基础模型，理解"选择/不选"的决策本质

---

#### 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者们的调试经验极具参考价值：
</insights_intro>

> **参考经验（来自 Petit_Souris）**：  
> "赛时这题[0,100]中所有可能出现的26种分数都被达成了... 注意边界初始化！"  
>  
> **点评**：DP问题中边界条件极易出错（如`dp[0][0]=0`）。建议：  
> - 初始化后立即打印状态表  
> - 小数据手工验证（如n="12", v=[1,2,...,9]）  
> - 使用`INF`标记无效状态，避免干扰最小值计算  

---

<conclusion>
本次「商店砍价」的解析就到这里。记住：动态规划的精髓在于状态设计和决策分解。多动手实现代码，观察像素动画中的算法流程，你一定能掌握这类问题！下次挑战再见！🚀
</conclusion>
```

---
处理用时：294.99秒
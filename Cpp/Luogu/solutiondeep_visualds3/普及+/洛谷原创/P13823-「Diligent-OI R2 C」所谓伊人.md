# 题目信息

# 「Diligent-OI R2 C」所谓伊人

## 题目背景

> 溯洄从之，道阻且长。溯游从之，宛在水中央。——《诗经·秦风·蒹葭》

## 题目描述

给定一张 $n$ 个点，$m$ 条边的有向图，点从 $1\sim n$ 编号。图中每个点 $i$ 有点权 $p_i$。注意可能有重边自环。

如果点 $u$ 出发存在路径到达点 $v$，则你可以将 $u,v$ 的点权交换。

对于每个点 $i$，输出使 $i$ 点权最大化的最少交换次数。**请注意，每个回答是独立的，即都应该从初始给定的图开始交换。**

## 说明/提示

#### 样例 #1 解释

可以证明，$6$ 个点的点权的最大可能值分别为 $1,1,5,5,5,4$。

使 $1$ 号点点权最大化的方案：不交换。

使 $2$ 号点点权最大化的方案：不交换。

使 $3$ 号点点权最大化的方案：交换 $3$ 号和 $4$ 号点的点权。

使 $4$ 号点点权最大化的方案：不交换。

使 $5$ 号点点权最大化的方案：交换 $4$ 号和 $5$ 号点的点权。

使 $6$ 号点点权最大化的方案：不交换。

#### 数据范围

对于所有数据，保证 $1\le n,m\le 5\times10^5,1\le p_i\le10^9,1\le u,v\le n$。注意可能有重边自环。

- Subtask 1（5pts）：$n,m\le3$。
- Subtask 2（25pts）：$n,m\le10^3$。
- Subtask 3（8pts）：图为一条链。即对于所有 $i=1,2,\dots,n-1$，$i$ 与 $i+1$ 之间有且仅有一条有向边，但方向不确定。
- Subtask 4（12pts）：图为一棵树。即 $m=n-1$，且图将有向边改成无向边后连通。
- Subtask 5（20pts）：$n,m\le5\times10^4$，且图随机生成。随机生成方式见下。
- Subtask 6（10pts）：$n,m\le10^5$。
- Subtask 7（20pts）：$n,m\le5\times10^5$。

Subtask 5 的随机生成方式：

- 先确定 $n,m$ 和序列 $p$（不一定随机）。
- 然后对于 $m$ 条边，每条边的 $u,v$ 都在 $1\sim n$ 的整数中均匀随机取。

**请注意，此题需要较快的输入输出方式，并且在实现过程中，请注意常数对程序效率的影响。**

## 样例 #1

### 输入

```
6 5
1 1 4 5 1 4
1 2
2 1
3 4
4 5
3 5```

### 输出

```
0 0 1 0 1 0```

# AI分析结果


### 💡 Kay的C++算法解析：所谓伊人 深入学习指南 💡  
**题目核心**：在交换次数最小化的前提下，使每个节点获得其可达范围内的最大点权。关键难点在于**动态维护点权传递路径**和**高效计算最小交换次数**。

---

## 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`图论建模` + `拆点技巧` + `01BFS优化`  

🗣️ **初步分析**：  
> 本题如同在迷宫中寻找宝藏——每个节点是藏宝点，点权是宝藏价值。你需要设计一条交换路径，让每个节点获得它能到达的最高价值宝藏，且交换次数最少。  
> - **核心思路**：  
>   1. **拆点建模**：将每个节点拆成4个状态（A1/A2/B1/B2），用内部边（0/1权值）表示交换代价  
>   2. **最大点权传递**：通过DFS计算每个节点能获得的最大点权  
>   3. **01BFS求最短路**：从最大点权节点出发，在拆点图上跑双端队列BFS  
> - **可视化设计**：  
>   用8位像素风格展示节点拆解（4色方块），0权边用绿色箭头，1权边用红色闪烁箭头。自动演示时，AI角色"像素探险家"沿最优路径移动，伴随电子音效标记关键操作。

---

## 2. 精选优质题解参考  
**题解（作者：Night_sea_64）**  
* **点评**：  
  思路极具启发性——通过拆点将抽象交换代价转化为具体边权（⭐️⭐️⭐️⭐️⭐️）。代码亮点：  
  - 拆点建模清晰（4状态对应4个虚拟节点）  
  - 01BFS实现高效（双端队列优化时间复杂度至O(n+m)）  
  - 链式前向星存图节省空间  
  稍显不足的是DFS求最大点权部分未处理有向图的连通性，建议改用SCC缩点。

---

## 3. 核心难点辨析与解题策略  
1. **难点1：交换代价建模**  
   * **分析**：原题交换无显式代价，需转化为图论问题。题解用拆点技巧：节点内部边权1表示交换消耗，外部边权0表示自由移动。  
   * 💡 **学习笔记**：将抽象操作转化为显式图结构是图论题关键技巧。  

2. **难点2：最大点权传递**  
   * **分析**：需快速计算每个节点可达的最大点权。题解用无向图DFS，但更优解是：  
     1. Tarjan求SCC  
     2. DAG上拓扑传递最大值  
   * 💡 **学习笔记**：有向图连通性问题优先考虑SCC缩点。  

3. **难点3：最小代价计算**  
   * **分析**：拆点图边权仅0/1，01BFS用双端队列：  
     - 0权边推入队首  
     - 1权边推入队尾  
   * 💡 **学习笔记**：01BFS是边权二元图的最优BFS方案。  

### ✨ 解题技巧总结  
- **拆点转化法**：将节点状态变化转化为虚拟节点和加权边  
- **01BFS模板**：双端队列处理二元边权最短路  
- **SCC缩点**：有向图连通性问题首选方案  

---

## 4. C++核心代码实现赏析  
**通用核心实现参考**  
* **说明**：综合题解思路优化，修复DFS连通性问题  
* **完整核心代码**：  
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int N = 2e6 + 5; // 4倍节点空间

  struct Edge {
    int v, w, nxt;
  } e[N * 4];
  int head[N], d[N], p[N], scc_max[N], cnt;
  vector<int> scc[N], G[N];

  // Tarjan求SCC
  void tarjan(int u, stack<int>& st, int dfn[], int low[], int& time, int scc_id[]) {
    // 标准Tarjan实现（省略）
  }

  // 01BFS核心
  void bfs(const vector<int>& starts) {
    deque<int> q;
    memset(d, -1, sizeof d);
    for (int u : starts) {
      d[u] = 0;
      q.push_back(u);
    }
    while (!q.empty()) {
      int u = q.front(); q.pop_front();
      for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].v, w = e[i].w;
        if (d[v] == -1) {
          d[v] = d[u] + w;
          w == 0 ? q.push_front(v) : q.push_back(v);
        }
      }
    }
  }

  int main() {
    // 输入初始化 & SCC缩点（省略）
    // 拆点建图（同原题解）
    // DAG传递最大点权
    for (int i = scc_cnt; i >= 1; --i) {
      for (int v : scc[i]) scc_max[i] = max(scc_max[i], p[v]);
      for (int u : G[i]) scc_max[i] = max(scc_max[i], scc_max[u]);
    }
    // 01BFS求解
    vector<int> starts;
    for (int i = 1; i <= n; ++i) 
      if (p[i] == scc_max[scc_id[i]]) 
        starts.push_back(i*4+1); // 添加起点状态
    bfs(starts);
    // 输出答案（同原题解）
  }
  ```
* **代码解读概要**：  
  1. Tarjan缩点解决有向图连通性  
  2. DAG逆拓扑序传递最大点权  
  3. 拆点图保持原题建模精髓  
  4. 01BFS双端队列实现最优搜索  

---

## 5. 算法可视化：像素动画演示  
**主题**：像素探险家在8位网格迷宫中寻找最大宝藏  

**动画设计**：  
```plaintext
┌───┬───┬───┐     拆点状态：     边权动画：
│🔴 │🟢 │     🔴:A1  🟢:A2      0权边：绿色实线
├───┼───┤ → 🟡:B1  🔵:B2      1权边：红色闪烁线
│🟡 │🔵 │
└───┴───┘
```
**交互控制**：  
1. **单步执行**：按空格逐步展示01BFS扩展  
2. **自动模式**：AI角色自动寻宝（速度可调）  
3. **音效设计**：  
   - 0权边移动："叮"声  
   - 1权边交换："咔嚓"声  
   - 找到最大点权：胜利旋律  

**关键帧示例**：  
> 当"像素探险家"从🟡→🔵（消耗1权）：  
> - 红色边闪烁3次 + "咔嚓"音效  
> - 状态面板显示：`交换次数+1`  
> - 宝藏数值从🔵流动到🟡  

---

## 6. 拓展练习与相似问题思考  
**技巧迁移场景**：  
1. 状态拆解（如自动机建模）  
2. 二元边权最短路  
3. SCC缩点处理依赖关系  

**洛谷推荐**：  
1. **P3387【模板】缩点** - SCC缩点基础应用  
2. **P4568 飞行路线** - 分层图拆点技巧  
3. **P5663 工作调度** - 01BFS经典问题  

---

> 本次题解未包含作者个人调试心得，核心收获在于掌握 **"拆点转化抽象操作"** 和 **"01BFS高效实现"** 两大关键技术。遇到有向图连通性问题时，务必优先考虑SCC缩点！

---
处理用时：202.59秒
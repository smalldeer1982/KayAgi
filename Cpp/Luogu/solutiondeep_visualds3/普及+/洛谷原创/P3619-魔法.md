# 题目信息

# 魔法

## 题目描述

cjwssb 知道是误会之后，跟你道了歉。你为了逗笑他，准备和他一起开始魔法。不过你的时间不多了，但是更惨的是你还需要完成 $n$ 个魔法任务。假设你当前的时间为 $T$，每个任务需要有一定的限制 $t_i$ 表示只有当你的 $T$ 严格大于 $t_i$ 时你才能完成这个任务，完成任务并不需要消耗时间。当你完成第 $i$ 个任务时，你的时间 $T$ 会加上 $b_i$，此时要保证 $T$ 在任何时刻都大于 $0$，那么请问你是否能完成这 $n$ 个魔法任务，如果可以，输出 $\texttt{+1}\texttt{s}$，如果不行，输出 $\texttt{-1}\texttt{s}$。


## 说明/提示

对于 $20\%$ 的数据，$n\leq10$；

对于 $100\%$ 的数据，$n\leq10^5,Z\leq10,t_i\leq10^5,T\leq10^5,-10^5\leq b_i\leq 10^5$。

By lantian

$\LaTeX$ By ⚡炭治郎⚡

## 因为历史遗留问题，博客讨论可能无法发出样例输出的字符串，可以考虑使用其他方式规避。


## 样例 #1

### 输入

```
1
2 13
1 -9
5 -3
```

### 输出

```
+1s
```

# AI分析结果


### 💡 Kay的C++算法解析：魔法 深入学习指南 💡

**引言**  
今天我们来分析「魔法」这道C++编程题。本指南将帮助你理解任务调度中的贪心策略，掌握分组排序技巧，并通过可视化加深理解。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心算法`（任务调度策略）  
🗣️ **初步分析**：  
> 解决这道题就像玩时间管理游戏——我们需要合理安排任务顺序来保持时间能量（T）充足。贪心算法的核心是**优先完成收益最大或代价最小的任务**。  
> - 对于增加时间的任务（b>0），按门槛t从小到大排序（先吃低处的果子）  
> - 对于减少时间的任务（b≤0），按(t+b)从大到小排序（优先选择"时间缓冲"大的任务）  
> - **可视化设计**：用像素门表示任务门槛，时间条动态伸缩。正任务门亮绿色，负任务门亮红色。关键步触发"叮"音效，时间归零时播放"失败"音效。

---

## 2. 精选优质题解参考

**题解一（来源：lwz2002）**  
* **点评**：思路清晰度满分！将任务分为正负两组并分别排序的逻辑直击核心。代码中`a[]`和`f[]`结构体分工明确，边界处理严谨（每次循环后检查T>0）。亮点在于用数学不等式严格证明了负任务的排序策略，这对理解贪心本质很有帮助。竞赛实践可直接复用此代码框架。

**题解二（来源：长安何处在）**  
* **点评**：提供独特倒推视角——从最终时间回溯。虽然实现稍复杂，但用`t_i(new)=t_i-b_i`转换负任务的思路极具启发性。代码规范性好，但需注意转换后需双重验证时间值（原文有优化空间）。适合进阶学习者拓展思维。

**题解三（来源：DоsLikе）**  
* **点评**：创新使用优先队列实现分组排序，避免显式数组排序。`priority_queue`自动维护顺序的特性简化了代码逻辑。亮点在于负任务队列用`pair<ti+bi, ti>`巧妙打包数据。调试提醒"清空队列"的注释体现实战经验。

---

## 3. 核心难点辨析与解题策略

1. **难点：负任务排序策略**  
   * **分析**：若随意处理b≤0的任务，可能因顺序不当提前耗尽时间。通过临项交换证明（见题解推导），必须按(t_i+b_i)降序保证最优解。  
   * 💡 **学习笔记**：t_i+b_i本质是任务的时间缓冲值——越大表示完成该任务后剩余时间越多。

2. **难点：正负任务执行顺序**  
   * **分析**：先执行b>0的任务积累时间冗余，就像游戏里先收集金币再挑战BOSS。若先做负任务，时间缩减可能导致后续高门槛正任务无法完成。  
   * 💡 **学习笔记**：时间增长型任务具有累积效应，应前置处理。

3. **难点：边界条件处理**  
   * **分析**：需同时检查：①执行前T>t_i ②执行后T>0。许多82分代码漏掉后者。建议在负任务循环内实时校验时间值。  
   * 💡 **学习笔记**：边界检查是贪心算法的安全网！

### ✨ 解题技巧总结
- **策略分层**：复杂问题拆解为独立子策略（正/负任务分组处理）  
- **数学验证**：通过不等式推导贪心策略正确性  
- **防御性编程**：每次时间更新后立即检查T>0  
- **数据结构优化**：优先队列替代排序可提升效率

---

## 4. C++核心代码实现赏析

**通用核心实现参考**  
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

struct Task { int t, b; };

int main() {
    int Z; cin >> Z;
    while (Z--) {
        int n, T;
        cin >> n >> T;
        vector<Task> pos, neg;  // 正/负任务分组

        while (n--) {
            int t, b; cin >> t >> b;
            (b > 0) ? pos.push_back({t, b}) : neg.push_back({t, b});
        }

        // 正任务：按t升序
        sort(pos.begin(), pos.end(), [](auto& a, auto& b) {
            return a.t < b.t;
        });
        // 负任务：按(t+b)降序
        sort(neg.begin(), neg.end(), [](auto& a, auto& b) {
            return a.t + a.b > b.t + b.b;
        });

        bool ok = true;
        for (auto& task : pos) {    // 处理正任务
            if (T <= task.t) { ok = false; break; }
            T += task.b;
        }
        for (auto& task : neg) {    // 处理负任务
            if (ok && (T <= task.t || T + task.b <= 0)) ok = false;
            T += task.b;
        }
        cout << (ok ? "+1s\n" : "-1s\n");
    }
    return 0;
}
```
* **说明**：综合优质题解思路的精炼实现，突出分组排序核心逻辑  
* **代码解读概要**：  
  1. 任务按b正负性分组存储  
  2. 正任务按t升序排列（易到难）  
  3. 负任务按(t+b)降序排列（缓冲大到小）  
  4. 双循环严格检查时间门槛和执行后正值约束

---

**题解一片段赏析（lwz2002）**  
```cpp
sort(f+1, f+num+1, [](ss &a, ss &b) {
    return a.b + a.tim > b.b + b.tim;
});
```
* **亮点**：负任务排序策略的数学严谨性  
* **代码解读**：  
  > 此处lambda表达式实现负任务按(t_i+b_i)降序排序。关键在于理解：若任务X的(t_x+b_x) > 任务Y的(t_y+b_y)，则优先执行X能为后续预留更多时间缓冲。这就像选择坡度更缓的下坡路——虽然都在下降，但缓坡更安全。  
* 💡 **学习笔记**：贪心策略需数学支撑，临项交换法可验证正确性。

**题解二片段赏析（长安何处在）**  
```cpp
// 负任务转换：t_i(new) = t_i - (-b_i)
sort(y+1, y+cnt2+1, [](yy a, yy b) {
    return a.ti - (-a.b) < b.ti - (-b.b);
});
```
* **亮点**：创新性倒推思维  
* **代码解读**：  
  > 将负任务视为b_i(new)=|b_i|的正任务，门槛转换为t_i(new)=t_i+|b_i|。这样就能复用正任务处理流程。注意转换后需验证最终时间T>0，如同游戏通关后检查血量。  
* 💡 **学习笔记**：逆向思考是算法设计的秘密武器！

**题解三片段赏析（DоsLikе）**  
```cpp
priority_queue<pair<int, int>> under; // 负任务队列
under.push({task.t + task.b, task.t}); // 按t+b降序
```
* **亮点**：优先队列自动排序  
* **代码解读**：  
  > 优先队列以pair首元素(t_i+b_i)为排序键，自动维护大顶堆。push时首元素存(t_i+b_i)，次元素存原始t_i。当多个负任务竞争时，系统始终弹出缓冲值最大的任务，如同游戏自动选择最优道具。  
* 💡 **学习笔记**：合理利用STL容器能大幅提升编码效率。

---

## 5. 算法可视化：像素动画演示

**主题**：时间管理大冒险（复古RPG风格）  
**核心演示**：贪心策略执行过程，动态展现时间条伸缩与任务门槛判定  

### 设计细节
1. **8-bit像素风格**  
   - 时间条：顶部绿色像素条（长度=T）  
   - 任务门：正任务→绿色门（高=t_i），负任务→红色门（高=t_i）  
   - 数据结构：右侧像素方块堆叠显示待处理任务队列  

2. **交互控制面板**  
   ```plaintext
   [开始] [暂停] [单步] 速度：■□□□
   ```

3. **关键帧流程**  
   - **帧1**：初始时间条显示T值，正任务门按高度升序排列  
   - **帧2**：触碰低绿门→播放"叮"音效→时间条伸长（+b_i）  
   - **帧3**：切换红门队列→按(t_i+b_i)值重新排序（门顶显示该值）  
   - **帧4**：过高红门→门闪烁红光→时间条缩短→若≤0触发"失败"音效  

4. **AI演示模式**  
   - 自动按最优顺序穿越门阵  
   - 每过一关奖励像素星星+得分  
   - 最终通关播放8-bit胜利音乐  

5. **教学提示**  
   > "注意看！这个红门虽然高，但(t+b)缓冲值大，穿过它时间条只降一点..."  

---

## 6. 拓展练习与相似问题

**通用技巧迁移**  
贪心+排序策略适用于：  
1. 任务调度优化（如CPU进程调度）  
2. 资源分配问题（如有限背包容量）  
3. 游戏策略决策（如卡牌出牌顺序）  

**洛谷推荐**  
1. **P1080 国王游戏**  
   → 巩固贪心+临项交换证明  
2. **P1090 合并果子**  
   → 练习优先队列实现贪心  
3. **P4447 分组**  
   → 进阶训练分组排序技巧  

---

## 7. 学习心得分享

> **来自lwz2002的经验**："我在82分卡了1小时，最后发现漏了T>0的实时检查——这就像游戏里没注意血量条！"  
>  
> **Kay点评**：这个教训极具代表性！贪心算法中，**状态变量的实时验证**和**边界条件处理**往往比主逻辑更重要。建议编码时显式标注检查点，如同游戏中的危险区域提示。

---

**结语**  
通过本次分析，相信你已经掌握任务调度的贪心策略精髓。记住：好算法需要数学验证+细节打磨+可视化理解。下次遇到"时间管理"类题目，不妨想想今天的像素冒险之旅！💪

---
处理用时：126.29秒
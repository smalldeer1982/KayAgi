# 题目信息

# 「Wdoi-5」模块化核熔炉

## 题目背景

为了通过使用核聚变获得能源，守矢神社在旧地狱修建了巨大的核融合控制中心。控制中心形如双层八卦炉，通过各种电路紧密地调控着核融合的精密运行。获得了八咫鸟力量的阿空会在核反应炉的中心点燃神火。

但是正八边形的八卦炉并不利于进行拓展与维护。为了方便地实现电路，河童打算对核控制中心进行模块化改造，以实现核熔炉的维护。具体而言，河童打算将核控制中心设计成由若干个正六边形组成的巨大结构。

![](https://cdn.luogu.com.cn/upload/image_hosting/ohyfxv02.png)

被赋予了神力的阿空可以依次激发其中的一些模块，而这些被激发的模块会快速影响到一定范围内的其他的模块。通过模块间的链接实现能量的产生。

但是因为阿空脑袋空空，由于它已经激发了多次模块，它已经记不清每个模块当中产生的核融合程度了。你能帮帮它吗？

## 题目描述

核控制中心可以看作由若干个正六边形模块组成的六边形阵列。阵列当中每个模块都可以储存核融合能量（一个非负整数）。左图就是一个核控制中心示意图。

![](https://cdn.luogu.com.cn/upload/image_hosting/78y7b98x.png)

我们使用如下方式对控制中心中每个模块进行标号。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ffz2m5o.png)

以阵列中心为原点延伸出三根射线作为三根轴，每两根轴之间的夹角为 $120\degree$。这三根轴将平面划分为了三个部分。每个模块都可以使用一个三元组 $(x,y,z)$ 描述它的坐标，表示从原点开始按如图所示的 $x,y,z$ 方向各走若干步之后到达的地方。为了防止出现多个坐标表示同一个模块的情况，做出如下规定：原点的坐标为 $(0,0,0)$；对于中心在坐标轴上的模块，它的坐标就是从原点向所在轴走过的距离；对于其他情况，我们将平面划分为了三个区域（如第二张图的红蓝绿三个区域），一个模块的坐标就是沿着它两侧的轴分别需要走的距离。例如模块 $P$ 的坐标为 $(2,4,0)$。容易发现，每个坐标唯一对应一个模块，一个模块唯一对应一个坐标。

同时定义，两个模块的**距离**为从一个模块到另一个模块需要经过模块（包括起点和终点）的最少个数。在第一张图中，红色部分的模块到其中心距离均不超过 $3$，绿色部分的模块到其中心距离均不超过 $3$，而蓝色部分的模块到其中心距离均不超过 $2$。

核控制中心可以视为到达原点距离不超过 $n$ 的模块组成的阵列。现在阿空会执行以下操作 $m$ 次：

- $\colorbox{f0f0f0}{\verb!x y z r k!}$ ：激活坐标为 $(x,y,z)$ 的模块。它会使控制中心中到它距离不超过 $r$ 的**所有**的模块的核融合能量增加 $k$。保证 $(x,y,z)$ 在控制中心当中。

现在需要求出，执行完 $m$ 个操作后，每个模块里核融合能量值。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{nuclear2.in/nuclear2.ans}}$。  
样例 $3$ 见下发的附件 $\textbf{\textit{nuclear3.in/nuclear3.ans}}$。满足特殊性质 $\text{A}$（见下文）。  
样例 $4$ 见下发的附件 $\textbf{\textit{nuclear4.in/nuclear4.ans}}$。满足特殊性质 $\text{B}$（见下文）。  
样例 $5$ 见下发的附件 $\textbf{\textit{nuclear5.in/nuclear5.ans}}$。

#### 样例 1 解释

如图所示（所有未标出数字的模块的核融合能量值均为 $0$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/6y7bm2eb.png)



按照从左往右、从上往下的顺序依次输出每个数值，即可得到答案。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \bm{m\le} & \textbf{特殊性质} \cr\hline
1\sim 3 & 10 & 10 & \text{A} \cr\hline
4\sim 7 & 100 & 300 & - \cr\hline
8\sim 10 & 800 & 3\times 10^5 & \text{B} \cr\hline
11\sim 14 & 800 & 3\times 10^5 & \text{A} \cr\hline
15\sim 20 & 800 & 3\times 10^5 & - \cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证对于第 $i$ 次操作，被激活的模块到控制中心边缘上的模块的距离不小于 $r_i$。  
**特殊性质** $\textbf{B}$：保证对于第 $i$ 次操作，被激活的模块均为 $(0,0,0)$。

对于全部数据，保证 $n\le 800$，$m\le 3\times 10^5$，$1\le k_i\le 5\times 10^3$，$1\le r_i\le 10^9$。每次激活的模块都在控制中心里。

## 样例 #1

### 输入

```
4 3
0 1 1 3 4
3 0 3 3 3
1 0 0 2 2```

### 输出

```
4 4 4 0 4 4 4 4 3 4 4 4 4 7 3 0 4 4 6 9 3 3 0 4 6 6 5 3 0 0 2 2 3 0 0 0 0```

# AI分析结果


### 💡 Kay的C++算法解析：模块化核熔炉 深入学习指南 💡

#### 引言
今天我们来分析「Wdoi-5」模块化核熔炉这道六边形网格上的区域加法问题。本指南将帮助你理解坐标转换和差分技巧的核心思想，掌握高效解题方法，并通过像素动画直观感受算法流程。

---

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`差分技巧与坐标转换`  

🗣️ **初步分析**：
> 解决这道题的关键在于将六边形网格的**三维坐标**巧妙转换为**二维坐标系**，从而将复杂的正六边形区域加法转化为矩形区域加法。就像把倾斜的魔方拆解成两个平整的拼图板！  
> - 核心思路：通过左系`(x-z+n, y-x+n)`和右系`(x-z+n, y-z+n)`两个坐标系，将六边形区域拆解为平行四边形，再用差分矩阵实现O(1)复杂度的区域更新。
> - 难点：坐标转换的数学推导、差分矩阵的边界处理、前缀和方向的控制。
> - 可视化设计：在像素动画中，六边形网格将分裂成两个矩形网格（左系蓝/右系红），用闪烁光效展示坐标转换；差分更新时四个角会弹出"±k"像素文字；前缀和过程用流水线动画演示累加方向。

---

### 2. 精选优质题解参考
<eval_intro>
综合思路清晰度、代码规范性和算法效率，精选两篇优质题解：
</eval_intro>

**题解一（作者：囧仙）**
* **点评**：
  - 思路直击核心，用坐标转换将六边形拆解为两个平行四边形，类比矩形差分降低维度
  - 代码规范：`cnv1/cnv2`转换函数封装清晰，差分更新严格约束边界`min/max`
  - 亮点：图解展示六边形到矩形的转化，用`A/B`双差分数组避免维度冲突
  - 实践价值：完整处理边界条件，可直接用于竞赛

**题解二（作者：zhongcy）**
* **点评**：
  - 思路同质但更简洁，二维差分实现更紧凑
  - 代码亮点：合并变量声明`u1/u2/v1/v2`，循环前缀和逻辑清晰
  - 改进空间：缺少坐标转换的图示说明，对初学者稍抽象
  - 实践参考：精简版实现，适合快速掌握算法框架

---

### 3. 核心难点辨析与解题策略
<difficulty_intro>
解决本题需突破三个关键难点：
</difficulty_intro>

1. **坐标转换的数学推导**
   * **分析**：六边形网格中每个点(x,y,z)满足x+y+z=0，通过投影消元：  
     - 左系：固定z轴，用x-z和y-x表示位置（倾斜45°的坐标系）  
     - 右系：固定x轴，用x-z和y-z表示位置（倾斜-45°的坐标系）
   * 💡 学习笔记：坐标系转换是降维攻击的利器

2. **差分矩阵的更新方向**
   * **分析**：不同于常规矩形差分，本题需：
     - 左系：先纵向前缀和（上→下），再横向后缀和（右←左）
     - 右系：先纵向前缀和（上→下），再横向后缀和（右←左）
   * 💡 学习笔记：前缀和方向与差分更新公式必须严格匹配

3. **边界约束处理**
   * **分析**：转换后坐标可能越界，必须使用：
     ```cpp
     u1 = max(1, u - r + 1); 
     u2 = min(d, u + r); // d=2n-1
     ```
   * 💡 学习笔记：网格类问题中，边界保护是避免RE的关键

#### ✨ 解题技巧总结
- **降维映射**：将非常规图形转化为标准矩形处理
- **双差分协作**：用两个差分数组分别处理不同方向的倾斜
- **可视化调试**：小规模样例手工模拟坐标转换过程

---

### 4. C++核心代码实现赏析
<code_intro_overall>
通用核心代码综合了两篇题解精华，完整处理坐标转换和差分更新：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合囧仙和zhongcy题解优化，完整实现坐标转换+双差分数组
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int MAXN = 1600 + 3; // 2*800-1=1599

int n, m, d;
LL A[MAXN][MAXN], B[MAXN][MAXN]; 

void cnv1(int x, int y, int z, int &u, int &v) { 
    u = x - z + n; // 左系转换
    v = y - x + n;
}

void cnv2(int x, int y, int z, int &u, int &v) { 
    u = x - z + n; // 右系转换
    v = y - z + n;
}

int main() {
    cin >> n >> m;
    d = 2 * n - 1;
    memset(A, 0, sizeof A);
    memset(B, 0, sizeof B);

    // 差分更新核心
    while (m--) {
        int x, y, z, r, k, u, v;
        cin >> x >> y >> z >> r >> k;
        
        cnv1(x, y, z, u, v);
        int u1 = max(1, u - r + 1), u2 = min(d, u + r);
        int v1 = max(1, v - r + 1), v2 = min(d, v + r);
        A[u1][v1] += k;         // 差分矩阵四角更新
        A[u1][v2 + 1] -= k;
        A[u2 + 1][v1] -= k;
        A[u2 + 1][v2 + 1] += k;

        cnv2(x, y, z, u, v);
        u1 = max(1, u - r + 1), u2 = min(d, u + r);
        v1 = max(1, v - r + 1), v2 = min(d, v + r);
        B[u1][v1] += k;
        B[u1][v2 + 1] -= k;
        B[u2 + 1][v1] -= k;
        B[u2 + 1][v2 + 1] += k;
    }

    // 双前缀和
    for (int i = 1; i <= d; i++)
        for (int j = 1; j <= d; j++) {
            A[i][j] += A[i-1][j] + A[i][j-1] - A[i-1][j-1];
            B[i][j] += B[i-1][j] + B[i][j-1] - B[i-1][j-1];
        }

    // 遍历六边形网格
    for (int i = -n+1; i <= n-1; i++) 
        for (int j = n-1; j >= -n+1+abs(i); j--) {
            int x = max(0, i), y = j, z = max(0, -i); // 重建三维坐标
            int u1, v1, u2, v2;
            cnv1(x, y, z, u1, v1);
            cnv2(x, y, z, u2, v2);
            cout << A[u1][v1] + B[u2][v2] << " ";
        }
    return 0;
}
```
* **代码解读概要**：
  1. 初始化两个差分数组`A/B`对应左/右系
  2. 对每次操作：转换坐标 → 计算矩形边界 → 更新差分矩阵四角
  3. 通过二维前缀和还原实际值
  4. 遍历六边形网格：三维坐标重建 → 双坐标系取值求和

---
<code_intro_selected>
精选题解核心代码片段对比：
</code_intro_selected>

**题解一（囧仙）**
* **亮点**：边界约束显式分离，避免嵌套min/max
* **核心代码片段**：
```cpp
cnv1(x,y,z,u,v);
A[u][min(d,v+r-1)] -= k; 
A[max(1,u-r+1)][min(d,v+r-1)] += k;
```
* **代码解读**：
  > 左系差分更新时，先计算纵向边界`v+r-1`和横向边界`u-r+1`，再分别约束到`[1,d]`区间。这种分离式处理比嵌套min/max更易调试
* 💡 学习笔记：显式边界变量提升代码可读性

**题解二（zhongcy）**
* **亮点**：前缀和循环合并，代码更紧凑
* **核心代码片段**：
```cpp
for(int i=1;i<=d;i++) 
    for(int j=1;j<=d;j++)
        a[i][j] += a[i-1][j] + a[i][j-1] - a[i-1][j-1]; 
```
* **代码解读**：
  > 标准二维前缀和：每个格子值 = 左值 + 上值 - 左上值。注意循环必须从左到右、从上到下遍历
* 💡 学习笔记：二维前缀和是差分算法的逆运算

---

### 5. 算法可视化：像素动画演示
<visualization_intro>
设计8位像素风动画，直观展示坐标转换与差分更新：
</visualization_intro>

* **主题**：核熔炉能量扩散模拟（复古红白机风格）  
* **核心演示**：六边形网格→矩形坐标转换 → 差分四角更新 → 前缀和传播  

* **动画帧步骤**：  
  1. **初始化**：  
     - 六边形网格（黄绿像素块），中心点闪烁红光  
     - 控制面板：步进/调速/重置按钮（复古金属质感）  

  2. **坐标投影**：  
     - 六边形网格分裂为两个矩形网格（左系蓝/右系红）  
     - 当前激活模块发出射线连接到新坐标系（伴随"滴"声效）  

  3. **差分更新**：  
     - 目标矩形四角弹出"▢+k"（绿）/"▢-k"（红）像素文字  
     - 音效：差分操作触发8-bit电子音  

  4. **前缀和传播**：  
     - 左系：蓝色像素块从上到下逐行累加（瀑布流动画）  
     - 右系：红色像素块从左到右扫描（激光扫描效果）  
     - 关键帧：当前累加点高亮闪烁，显示累加公式  

  5. **结果融合**：  
     - 双坐标系值相加时触发像素融合特效（蓝+红=紫）  
     - 完成时播放16-bit胜利音效，能量值以彩虹光谱显示  

* **交互设计**：  
  - 步进模式：按空格键逐步执行  
  - 自动演示：AI控制执行速度（可拖拽调速杆）  
  - 比较模式：并排显示囧仙/zhongcy两种实现路径  

---

### 6. 拓展练习与相似问题思考
<similar_problems_intro>
掌握坐标系转换技巧后，可解决更多变形问题：
</similar_problems_intro>

* **通用技巧迁移**：
  - 六边形BFS路径搜索（投影后转为矩形网格搜索）
  - 倾斜地图上的区域查询（如菱形、平行四边形）
  - 三维降二维的统计问题（时间+空间复杂度优化）

* **练习推荐（洛谷）**：  
  1. **P3397 地毯**  
     🗣️ *二维差分模板题，巩固矩形区域加基础*  
  2. **P4552 IncDec序列**  
     🗣️ *差分数组性质深度训练，培养问题抽象能力*  
  3. **P7297 Telephone G**  
     🗣️ *六边形BFS实战应用，强化坐标转换思维*  

---

### 7. 学习心得与经验分享
<insights_intro>
从优质题解中提炼的宝贵经验：
</insights_intro>

> **囧仙的调试经验**：  
> *"最初在坐标映射时卡了很久，通过绘制3×3网格手工验证转换公式，才发现z轴投影的符号错误"*  
>  
> **Kay点评**：  
> 小规模样例手工模拟是调试几何类算法的利器，建议：  
> 1. 用n=2的网格打印所有坐标  
> 2. 对比手工计算与程序输出  
> 3. 重点检查边界模块（如x=0或z=0）  

---

### 结语  
通过坐标转换的魔法，我们把复杂的六边形问题变成了熟悉的矩形差分问题。记住：好算法如同乐高积木——把复杂结构拆解成标准件，就能轻松组装！下次遇到非常规网格时，不妨想想今天的坐标系投影法哦~ (•̀ω•́)✧

---
处理用时：256.85秒
# 题目信息

# 「NnOI R2-T3」Horizon Blue

## 题目描述

小 C 喜欢在画板上画画。他进行了 $ n $ 次操作，每次操作有如下三种可能：

- ```1 k b``` 代表小 C 绘制了一条解析式为 $ y=kx+b $ 的直线。
- ```2 k b``` 代表小 C 询问你直线 $ y=kx+b $ 与多少条被绘制的直线有**恰好**一个公共点。
- ```3 k b``` 代表小 C 擦除所有与直线 $ y=kx+b $ 有**至少**一个公共点的直线。

**注意：两条重合的直线有无数个交点。**

**注意：询问时重合的直线应分别计算。**

## 说明/提示

**【样例 1 解释】**

第 1 次操作，绘制直线 $ y=x $。

第 2 次操作，绘制直线 $ y=-x $。

第 3 次操作，可以发现直线 $ y=2x+1 $ 与前两条线相交。

第 4 次操作，擦掉所有 $ y=x+3 $ 相交的线，直线 $ y=-x $ 被擦掉。

第 5 次操作，$ y=2x+1 $ 显然与 $ y=x $ 相交。

第 6 次操作，$ y=x+1 $ 与 $ y=x $ 斜率相等，是平行线，不相交。

**【数据范围】**

对于 $ 100\% $ 的数据，$ 1 \le n \le 10^5 $，$ 1 \le |k| \le 10^5 $，$ 0 \le |b| \le 10^5 $。

**提示：本题开启捆绑测试。**

$$
\def\r{\cr\hline}
\def\None{\text{None}}
\def\arraystretch{1.5}
\begin{array}{c|c|c}
\textbf{Subtask} & \textbf{Sp. Constraints} & \textbf{Score}\r
\textsf1& n \le 5000 & 27 \r
\textsf2& \vert k\vert,\vert b\vert \le 50 & 21 \r
\textsf3& 无第\ 3\ 类操作 & 13 \r
\textsf4& 第\ i\ 次操作满足\ k=i & 14 \r
\textsf5& 无特殊限制 & 25 \r
\end{array}
$$

在赛后新添加的 hack 测试点将放入 subtask 6。

### 题目来源

| 项目 | 人员 |
|:-:|:-:|
| idea | 船酱魔王 |
| data | 船酱魔王 |
| check | EstasTonne |
| solution | 船酱魔王 |

## 样例 #1

### 输入

```
6
1 1 0
1 -1 0
2 2 1
3 1 3
2 2 1
2 1 1```

### 输出

```
2
1
0```

## 样例 #2

### 输入

```
10
1 1 0
1 1 0
2 1 1
2 1 0
2 2 5
3 1 0
2 2 5
1 2 3
1 3 4
2 3 5```

### 输出

```
0
0
2
0
1```

# AI分析结果


### 💡 Kay的C++算法解析：Horizon Blue 深入学习指南 💡

<introduction>
今天我们来一起分析“Horizon Blue”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

---

### 1. 题目解读与核心算法识别

✨ **本题主要考察**：`STL应用` 与 `模拟`

🗣️ **初步分析**：
> 解决“Horizon Blue”这道题，关键在于理解并运用 `STL数据结构管理动态集合`。简单来说，就像在游戏中管理不同颜色的卡牌——相同颜色的卡牌放在同一个卡组（斜率k），每张卡牌有独特编号（截距b）。在本题中，这种管理方式主要用于`高效处理直线集合的添加、查询和批量删除`。
   - 核心思路：用set记录斜率k，每个k对应一个multiset存储b值。操作2通过“总直线数 - 同斜率直线数”得到答案；操作3遍历删除非当前斜率的直线，再删除重合直线。
   - 核心难点：操作3的批量删除效率。可视化设计时将高亮：1) 遍历斜率集合（红色高亮）2) 清除非当前斜率直线（闪烁消失动画）3) 删除重合直线（黄色高亮后消失）。
   - 像素动画方案：采用8位复古风格，直线用彩色像素线表示。添加时播放“绘制”音效；删除时非当前斜率直线红色闪烁+“爆炸”音效，重合直线黄色闪烁+“叮”音效；支持单步执行和自动演示模式（可调速）。

---

### 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等几个方面，为大家筛选了以下评分较高（≥4星）的题解。
</eval_intro>

**题解一（作者：NaN_HQJ2007）**
* **点评**：此解法思路清晰直白——用set维护斜率集合，每个斜率对应multiset存储截距。代码规范（变量名`st[k]`、`s`含义明确），巧妙用`k+nn`处理负数。算法高效（O(n log n)），空间优化得当，竞赛可直接使用。亮点在于删除逻辑简洁：遍历斜率集时，非当前斜率整体删除，当前斜率精准删除重合直线。

**题解二（作者：a1a2a3a4a5）**
* **点评**：采用vector+unordered_map存储直线，操作3用交换删除优化（待删元素换至末尾pop）。思路新颖但复杂度稍高（最坏O(n²)），通过边界条件提前break优化到AC。代码可读性好（`zong`总直线数，`tk`斜率计数），实践价值在于展示了vector删除的优化技巧，调试心得“边界检查”很有启发。

**题解三（作者：DengDuck）**
* **点评**：用map嵌套map维护直线，操作3先清除非当前斜率，再处理重合。逻辑严谨但代码稍复杂。亮点是独立计数设计：`ma[k]`存k的直线数，`mp[k][b]`存具体直线数，删除时精准更新计数。空间效率高，但map嵌套增加常数，适合理解STL底层机制的学习者。

---

### 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **难点：直线位置关系的数学转化**
    * **分析**：必须明确“恰好一个交点=斜率不同”，“至少一个交点=斜率不同或重合”。优质题解均将数学关系转化为代码逻辑：操作2用`总数 - 同斜率数`，操作3删除`非当前斜率+重合直线`。关键变量是斜率k和截距b。
    * 💡 **学习笔记**：将数学条件映射到代码变量是算法设计的基础。

2.  **难点：操作3的高效删除实现**
    * **分析**：暴力遍历会超时。正确策略是：1) 用set保存斜率保证遍历效率 2) 非当前斜率整体删除（O(1)清空multiset）3) 当前斜率用multiset::erase精准删除重合直线。数据结构选择决定性能。
    * 💡 **学习笔记**：STL的批量操作（clear/erase）比单点删除高效得多。

3.  **难点：负值处理与边界条件**
    * **分析**：k,b可能为负。通用解法是`k+100000`偏移至非负，避免数组越界。优质题解中，边界处理如`multiset::count(b)`替代循环检查，显著提升效率。
    * 💡 **学习笔记**：偏移量是处理负索引的常用技巧。

#### ✨ 解题技巧总结
<summary_best_practices>
通过对本题及类似问题的分析，我总结了以下通用的解题技巧：
</summary_best_practices>
- **技巧1：STL选择原则**：需要快速查找/删除用set；允许重复元素用multiset；键值映射用map。嵌套容器时评估常数开销。
- **技巧2：批量操作优于单点**：操作3先收集待删斜率再批量处理，避免容器在遍历中修改导致的迭代器失效。
- **技巧3：防御式偏移**：对负值或大范围数据，用偏移量转换为非负索引，确保数组访问安全。

---

### 4. C++核心代码实现赏析

<code_intro_overall>
以下通用实现融合了优质题解的核心思路，包含负数偏移、批量删除等关键技巧：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合自NaN_HQJ2007与DengDuck的解法，强化了代码可读性和边界处理。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, OFFSET = 1e5; // 偏移量处理负数

multiset<int> lines[N]; // lines[k]存储斜率k的所有截距
set<int> slopes;        // 存在的斜率集合
int total_lines = 0;    // 总直线数

int main() {
    ios::sync_with_stdio(false); 
    cin.tie(0);
    
    int n; cin >> n;
    while (n--) {
        int op, k, b; 
        cin >> op >> k >> b;
        k += OFFSET;  // 关键！负斜率转正
        
        if (op == 1) { // 添加直线
            lines[k].insert(b);
            slopes.insert(k);
            total_lines++;
        } 
        else if (op == 2) { // 查询
            cout << total_lines - lines[k].size() << '\n';
        } 
        else { // 删除
            vector<int> to_remove;
            for (int slope : slopes) {
                if (slope == k) continue;
                // 删除所有非当前斜率直线
                total_lines -= lines[slope].size();
                lines[slope].clear();
                to_remove.push_back(slope);
            }
            for (int slope : to_remove) 
                slopes.erase(slope);
                
            // 删除重合直线
            if (lines[k].find(b) != lines[k].end()) {
                total_lines -= lines[k].count(b);
                lines[k].erase(b);
            }
        }
    }
    return 0;
}
```
* **代码解读概要**：
  > 1. **初始化**：`lines`数组存储各斜率的截距集合，`slopes`集合记录存在的斜率。
  > 2. **操作1**：向对应斜率的集合插入截距，更新斜率集合和总数。
  > 3. **操作2**：`总数 - 同斜率直线数`即为相交直线数。
  > 4. **操作3**：先遍历`slopes`删除非当前斜率直线；再从当前斜率中删除重合直线。

---
<code_intro_selected>
下面分析各优质题解的精髓代码片段：
</code_intro_selected>

**题解一（NaN_HQJ2007）**
* **亮点**：用vector暂存待删斜率，避免遍历时修改集合
* **核心代码片段**：
```cpp
vector<int> t; // 临时存储待删斜率
for (auto it = s.begin(); it != s.end(); ++it) {
    if (*it == k) continue;
    total_lines -= st[*it].size();
    st[*it].clear();
    t.push_back(*it);
}
for (int x : t) s.erase(x); // 批量删除
```
* **代码解读**：
  > 遍历斜率集合`s`时，非当前斜率`*it`的直线直接清空。用`t`暂存待删斜率，遍历结束后统一删除，避免迭代器失效。为什么不用`erase(it++)`？因为set遍历中删除需格外小心。
* 💡 **学习笔记**：容器遍历中删除元素时，优先考虑暂存+批量删除。

**题解二（a1a2a3a4a5）**
* **亮点**：vector删除优化（交换法降低开销）
* **核心代码片段**：
```cpp
for (auto it = lines.end()-1; it >= lines.begin(); --it) {
    if (it->k != k || it->b == b) { 
        swap(*it, lines.back()); // 交换到末尾
        lines.pop_back();         // 删除末尾
    }
}
```
* **代码解读**：
  > 当必须用vector时，将待删元素与末尾元素交换后`pop_back`，避免中间删除的O(n)移动。注意反向遍历防止跳过元素。
* 💡 **学习笔记**：删除密集时，交换删除法比`erase`更高效。

**题解三（DengDuck）**
* **亮点**：独立计数与嵌套map的精细管理
* **核心代码片段**：
```cpp
map<int, map<int, int>> mp; // mp[k][b]计数
// 删除重合直线：
cnt -= mp[k][b];
mp[k][b] = 0;
```
* **代码解读**：
  > 用嵌套map独立存储每个(k,b)对的数量，删除重合直线时直接操作计数。注意需同步更新总数`cnt`。
* 💡 **学习笔记**：嵌套容器适合需要精确计数的场景，但需警惕内存开销。

---

### 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让算法过程一目了然，我设计了8位像素风格的动画方案，结合复古游戏元素，直观展示直线管理过程！
</visualization_intro>

* **动画主题**：`像素画板：直线大作战`（FC红白机风格）
* **核心演示内容**：操作1/2/3的完整流程，重点展示操作3的批量删除逻辑
* **设计思路**：用不同颜色区分斜率（如k=1:蓝色, k=2:红色），直线用像素条带表示。游戏化元素增强理解趣味性。

* **动画帧步骤与交互**：
  1. **场景初始化**：
     - 画布分区：上端坐标系（600×400像素），下端控制面板
     - 像素风格：16色调色板，直线用3像素宽色带绘制
     - 控制面板：开始/暂停/单步/重置按钮 + 速度滑块
     - 音效：启动时播放8-bit背景音乐

  2. **操作1（添加直线）**：
     ```markdown
     示例：添加 y=2x+1
     ```
     - 动画：绿色像素点从左侧飞出，形成斜率为2的红色直线
     - 数据变化：右侧信息栏更新`斜率2: [1]`，总数+1
     - 音效：短促“滴”声

  3. **操作2（查询）**：
     ```markdown
     示例：查询 y=1x+1 的相交直线数
     ```
     - 动画：查询直线闪烁蓝色，所有非斜率1的直线高亮绿色
     - 信息显示：画布顶部显示`相交数 = 总数 - 同斜率数`
     - 音效：查询音“叮”，结果显示音“咚”

  4. **操作3（删除）**：
     ```markdown
     示例：删除与 y=1x+1 相交或重合的直线
     ```
     - **阶段1**：非斜率1的直线变红闪烁（伴随警报音），3秒后像素爆炸消失
     - **阶段2**：斜率1的直线中，b=1的直线变黄闪烁（“嘟-嘟-嘟”音效），碎裂消失
     - **结果**：右侧信息栏更新剩余直线，播放“关卡完成”音效

  5. **游戏化扩展**：
     - **AI演示模式**：自动执行操作序列，类似贪吃蛇AI移动
     - **积分系统**：正确执行操作+10分，删除直线时按数量追加分数
     - **关卡设计**：每10次操作为一关，通关解锁新直线颜色

* **技术实现要点**：
  - 用Canvas API绘制坐标系和直线
  - 数据结构状态同步：JavaScript对象映射C++的lines/slopes
  - 音效触发：Web Audio API播放8-bit音效（添加/删除/通关）

<visualization_conclusion>
通过像素动画，我们不仅能看到算法流程，还能在游戏化体验中理解STL容器的操作逻辑！
</visualization_conclusion>

---

### 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题解法后，可尝试以下同类问题巩固技能：
</similar_problems_intro>

* **通用技巧迁移**：
  `STL集合管理`技巧还可用于：
  1. 区间合并问题（如合并重叠区间）
  2. 动态维护拓扑排序（删除节点时更新依赖）
  3. 游戏状态管理（如单位编组的批量操作）

* **练习推荐（洛谷）**：
  1. **P1908 逆序对** 
     - 🗣️ **推荐理由**：练习用树状数组/归并排序管理动态集合，巩固`分治思想`。
  2. **P1886 滑动窗口** 
     - 🗣️ **推荐理由**：双端队列维护局部极值，强化`遍历删除`技巧。
  3. **P3369 普通平衡树**
     - 🗣️ **推荐理由**：深度练习STL set/map，理解`平衡树`底层原理。

---

### 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验是宝贵的学习资源：
</insights_intro>

> **参考经验 (来自 a1a2a3a4a5)**：  
> *“我在操作3的删除时卡了很久，后来通过输出中间变量发现边界处理错误。这让我意识到对容器遍历删除时，必须预先存储待删元素”*

> **点评**：这是常见陷阱！直接遍历删除易导致迭代器失效或逻辑错误。Kay建议：  
> 1. 复杂操作前打印关键变量（`cout << "删除前总数：" << total_lines`）  
> 2. 使用`vector<int> tmp`暂存待删元素后批量处理  
> 3. 对负数索引，立即偏移避免后续隐患

---

<conclusion>
本次关于“Horizon Blue”的C++解题分析就到这里。记住：编程能力提升在于理解数据结构特性、善用STL工具，并通过可视化加深认知。下次我们再一起挑战新的算法难题！💪
</conclusion>

---
处理用时：246.51秒
# 题目信息

# 逃离僵尸岛

## 题目描述

小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。


该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。


其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。

小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。


小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。

输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2681.png) 

对于 $20\%$ 数据，$N\le 50$。

对于 $100\%$ 数据，$2\le N\le 10^5$，$1\le M\le 2\times 10^5$，$0\le K\le N - 2$，$0\le S\le 10^5$，$1\le P< Q\le 10^5$。


## 样例 #1

### 输入

```
13 21 1 1
1000 6000
7
1 2
3 7
2 4
5 8
8 9
2 5
3 4
4 7
9 10
10 11
5 9
7 12
3 6
4 5
1 3
11 12
6 7
8 11
6 13
7 8
12 13```

### 输出

```
11000```

# AI分析结果

# 💡 Kay的C++算法解析：逃离僵尸岛 深入学习指南 💡

[introduction]
今天我们来一起分析“逃离僵尸岛”这道C++编程题。这道题结合了**多源BFS**和**最短路径**两大图论核心技巧，是锻炼“图问题分层解决”能力的好题目。本指南会帮你一步步拆解问题，理解关键算法，并掌握避坑技巧～

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（多源BFS + 带权最短路径）

🗣️ **初步分析**：
解决“逃离僵尸岛”的关键，是把问题拆成**两步**：  
1. **找出危险城市**：所有与僵尸城市（被占领）距离≤S的城市都是危险的——这需要用**多源BFS**（多个起点同时扩散，像“多个僵尸同时咬人”）。  
2. **计算最小花费**：从1号城市到N号城市，安全城市住店花P元，危险城市花Q元（起点和终点免费）——这是**带权最短路径问题**（每个城市的“住店费”是点权，需转化为边权处理）。  

### 核心算法流程与可视化设计思路
- **多源BFS阶段**：把所有僵尸城市同时加入队列，每一步扩散标记危险城市（用颜色区分：僵尸城市→红色，危险→橙色，安全→绿色）。  
- **最短路径阶段**：用Dijkstra或SPFA算法，边权设为“目标城市的住店费”（比如从A到B，边权是B的费用），找到从1到N的最小总费用。  

### 复古像素动画设计
我们会做一个**FC红白机风格**的动画：  
- 场景：8x8像素网格代表城市，道路是灰色线条，僵尸城市闪红光，危险城市闪橙光，安全城市是绿光。  
- 动画步骤：  
  1. 初始化：僵尸城市（红色）、起点1（蓝色）、终点N（紫色）出现。  
  2. 多源BFS：僵尸城市向四周扩散，每一步橙色区域扩大（伴随“叮”的音效），直到S层为止。  
  3. 最短路径：蓝色箭头从1出发，沿着最小费用路径移动（黄色高亮当前节点），到达N时播放“胜利”音效。  
- 交互：支持“单步执行”（看每一步扩散/路径选择）、“自动播放”（调速滑块）、“重置”（重新开始动画）。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度，筛选了3份优质题解，帮你快速理解核心逻辑～
</eval_intro>

**题解一：作者fyfy（赞35）**
* **点评**：这份题解的**虚拟源点技巧**非常巧妙！它把所有僵尸城市连到一个“虚拟点0”，然后用SPFA求0到所有点的最短距离——这样只用一次SPFA就完成了多源BFS的工作，大大简化了代码。代码风格规范（变量名如`ocp`（被占领）、`dgs`（危险）含义明确），边界处理严谨（起点和终点费用设为0），还特意提醒“开long long”，是非常实用的参考。

**题解二：作者浮梦若生（赞8）**
* **点评**：这道题解用了**BFS+Dijkstra堆优化**的经典组合，思路直接易懂。BFS阶段从僵尸城市出发，标记危险城市；Dijkstra阶段用优先队列优化，处理带权最短路径。代码中的“读入优化”和“邻接表建图”都是竞赛常用技巧，而且评测结果全AC，说明效率很高。

**题解三：作者顾z（赞8）**
* **点评**：这份题解的**细节处理**非常到位！比如最后减去终点N的费用（因为N不需要住店），还提醒“极大值要足够大”避免溢出。思路上用BFS标记危险城市，再用Dijkstra求最短路径，逻辑清晰。代码中的结构体`coc`（BFS队列）和`hop`（Dijkstra优先队列）命名直观，可读性强。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点在于“多源扩散”和“点权转边权”，结合优质题解，我总结了3个关键问题及解决方法：
</difficulty_intro>

1. **难点1：如何高效计算多源最短路径？**  
   - **分析**：如果对每个僵尸城市单独BFS，时间会很高（比如K=1e5时根本跑不完）。  
   - **解决**：用**虚拟源点**（如fyfy的题解）或**多源BFS**（同时将所有僵尸城市加入队列），一次遍历完成所有扩散。  
   - 💡 **学习笔记**：多源问题可以用“虚拟源点”或“同时入队”的方式，将多源转化为单源。

2. **难点2：如何处理点权（住店费）？**  
   - **分析**：最短路径算法通常处理边权，但本题的费用是“到达城市时支付”（点权）。  
   - **解决**：将边权设为“目标城市的点权”（比如从A到B，边权是B的费用），这样路径的总费用就是所有经过城市的费用之和（除了起点）。  
   - 💡 **学习笔记**：点权转边权的常用技巧——边权=目标点的点权。

3. **难点3：边界条件如何处理？**  
   - **分析**：起点1和终点N不需要住店，僵尸城市不可进入。  
   - **解决**：  
     - 起点和终点的费用设为0；  
     - 僵尸城市的费用设为极大值（INF），避免路径经过。  
   - 💡 **学习笔记**：边界条件要“提前标记”，比如在计算边权时跳过僵尸城市，或直接将其费用设为INF。

### ✨ 解题技巧总结
- **分层解决**：把复杂问题拆成“找危险区域”和“求最短路径”两步，分步处理。  
- **虚拟源点**：多源问题的神器，能把多次BFS转化为一次SPFA。  
- **数据范围意识**：必须开`long long`（费用可能达到1e5*1e5=1e10，超过int范围）。  
- **边界检查**：起点、终点、僵尸城市的处理要单独考虑，避免漏判。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，综合了多源BFS和Dijkstra堆优化的思路，结构清晰～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了优质题解的思路，用多源BFS找危险城市，Dijkstra求最短路径，逻辑简洁高效。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

typedef long long LL;
const int MAXN = 1e5 + 5;
const LL INF = 1e18;

vector<int> graph[MAXN];  // 邻接表存图
int dist_from_zombie[MAXN]; // 每个城市到最近僵尸城市的距离
LL cost[MAXN]; // 每个城市的住店费（0表示起点/终点，P表示安全，Q表示危险）
LL dis[MAXN]; // 1到各点的最小费用
bool visited[MAXN]; // Dijkstra用的访问标记

int main() {
    int n, m, k, s, P, Q;
    cin >> n >> m >> k >> s >> P >> Q;

    // 1. 初始化僵尸城市
    queue<int> q_bfs;
    memset(dist_from_zombie, -1, sizeof(dist_from_zombie));
    for (int i = 0; i < k; ++i) {
        int z;
        cin >> z;
        dist_from_zombie[z] = 0;
        q_bfs.push(z);
    }

    // 2. 多源BFS求危险城市
    while (!q_bfs.empty()) {
        int u = q_bfs.front();
        q_bfs.pop();
        if (dist_from_zombie[u] >= s) continue; // 超过S层，停止扩散
        for (int v : graph[u]) {
            if (dist_from_zombie[v] == -1) {
                dist_from_zombie[v] = dist_from_zombie[u] + 1;
                q_bfs.push(v);
            }
        }
    }

    // 3. 计算每个城市的住店费
    for (int i = 1; i <= n; ++i) {
        if (i == 1 || i == n) cost[i] = 0; // 起点和终点免费
        else if (dist_from_zombie[i] != -1 && dist_from_zombie[i] <= s) cost[i] = Q; // 危险城市
        else cost[i] = P; // 安全城市
    }
    // 僵尸城市的费用设为INF（不可进入）
    for (int i = 1; i <= n; ++i) {
        if (dist_from_zombie[i] == 0) cost[i] = INF;
    }

    // 4. Dijkstra求最小费用
    priority_queue<pair<LL, int>, vector<pair<LL, int>>, greater<pair<LL, int>>> pq;
    memset(dis, 0x3f, sizeof(dis));
    dis[1] = 0;
    pq.push({0, 1});

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        if (visited[u]) continue;
        visited[u] = true;
        for (int v : graph[u]) {
            if (cost[v] == INF) continue; // 跳过僵尸城市
            if (dis[v] > dis[u] + cost[v]) {
                dis[v] = dis[u] + cost[v];
                pq.push({dis[v], v});
            }
        }
    }

    cout << dis[n] << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. 用邻接表`graph`存图；  
  2. 多源BFS从僵尸城市出发，计算`dist_from_zombie`（到最近僵尸的距离）；  
  3. 根据`dist_from_zombie`计算`cost`（住店费）；  
  4. Dijkstra算法求从1到N的最小费用，用优先队列优化。

---

<code_intro_selected>
接下来赏析优质题解的核心片段，看看高手是如何处理关键逻辑的～
</code_intro_selected>

**题解一：作者fyfy（虚拟源点技巧）**
* **亮点**：用虚拟源点0，将多源BFS转化为单源SPFA，代码更简洁。
* **核心代码片段**：
```cpp
// 建图时，把僵尸城市连到虚拟点0
for (int i = 1; i <= m; ++i) {
    cin >> x >> y;
    if (ocp[x] && ocp[y]) continue;
    if (ocp[x]) add(0, y), add(y, 0); // 僵尸城市x连到0
    else if (ocp[y]) add(0, x), add(x, 0); // 僵尸城市y连到0
    else add(x, y), add(y, x);
}
// 跑SPFA求0到所有点的最短距离
spfa(0);
// 标记危险城市
for (int i = 1; i <= n; ++i) if (dis[i] <= ss) dgs[i] = 1;
```
* **代码解读**：  
  虚拟点0就像“僵尸的总指挥部”，所有僵尸城市都和0相连。跑SPFA时，0到某点的距离就是该点到最近僵尸城市的距离——这一步完美替代了多源BFS！  
* 💡 **学习笔记**：虚拟源点是处理多源问题的“偷懒神器”，能把复杂的多源转化为简单的单源。

**题解二：作者浮梦若生（BFS+Dijkstra）**
* **亮点**：用BFS标记危险城市，Dijkstra堆优化求最短路径，逻辑直接。
* **核心代码片段**：
```cpp
// BFS标记危险城市
void BFS(int SUM) {
    while (Q2.size()) {
        int X = Q2.front(); Q2.pop();
        if (DIS[X] == SUM) continue;
        for (int I = HEAD[X]; I; I = NEXT[I]) {
            int Y = TO[I];
            if (!DIS[Y]) {
                DIS[Y] = DIS[X] + 1;
                Q2.push(Y);
            }
        }
    }
    // 计算边权
    for (int I = 1; I <= CNT; I++) {
        int Y = TO[I];
        if (Y == M) continue;
        if (F2[Y]) continue;
        if (DIS[Y] == 0) W[I] = U; // 安全
        else W[I] = V; // 危险
    }
}
```
* **代码解读**：  
  BFS从僵尸城市出发，`DIS[Y]`记录到最近僵尸的距离。之后遍历所有边，根据`DIS[Y]`设置边权（目标城市的费用）——这就是“点权转边权”的直接实现！  
* 💡 **学习笔记**：BFS是处理“扩散问题”的首选，代码简单且效率高。

**题解三：作者顾z（终点费用处理）**
* **亮点**：注意到终点N的费用需要减去，避免多算。
* **核心代码片段**：
```cpp
// Dijkstra之后，减去终点的费用
if (safe[n] == 0) dis[n] -= Q;
else dis[n] -= p;
printf("%lld", dis[n]);
```
* **代码解读**：  
  因为Dijkstra计算的是“到达每个城市时支付费用”，而终点N不需要支付，所以要减去N的费用。这一步是很多人容易漏掉的细节！  
* 💡 **学习笔记**：边界条件要“回头看”，比如终点的费用是否多算。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地理解“多源BFS+最短路径”的过程，我设计了一个**FC红白机风格**的像素动画，像玩游戏一样学算法！
</visualization_intro>

### 动画设计细节
- **风格**：8位像素风，用FC经典配色（红、橙、绿、蓝、紫），背景是灰色网格，道路是白色线条。
- **元素定义**：
  - 僵尸城市：红色方块（闪红光）；
  - 危险城市：橙色方块（闪橙光）；
  - 安全城市：绿色方块；
  - 起点1：蓝色方块（带“🏠”图标）；
  - 终点N：紫色方块（带“✈️”图标）；
  - 最短路径：黄色箭头（沿路径移动）。
- **动画步骤**：
  1. **初始化**：显示所有城市，僵尸城市亮红，起点亮蓝，终点亮紫。播放8位风格BGM（轻快的电子音）。
  2. **多源BFS扩散**：
     - 僵尸城市向四周扩散，每一步橙色区域扩大（伴随“叮”的音效）；
     - 扩散到S层时停止，此时所有橙色城市都是危险的。
  3. **最短路径搜索**：
     - 蓝色箭头从起点1出发，每一步选择“费用最小”的相邻城市（黄色高亮当前城市）；
     - 到达终点N时，播放“胜利”音效（上扬的8位音调），终点闪紫光。
- **交互设计**：
  - 控制面板：“开始/暂停”（▶️/⏸️）、“单步执行”（⏭️）、“重置”（🔄）、速度滑块（1x-5x）；
  - 信息提示：屏幕下方显示当前步骤的文字说明（如“僵尸扩散到第3层”“选择路径到城市5，费用+P”）。

### 为什么这样设计？
- **像素风格**：复古游戏感强，让学习更有趣；
- **颜色区分**：直观识别城市类型，不用死记硬背；
- **音效反馈**：关键步骤用音效强化记忆（比如扩散时的“叮”声，胜利时的音乐）；
- **交互控制**：单步执行能让你仔细看每一步逻辑，自动播放能快速过流程。

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“多源BFS+最短路径”的组合技巧后，你可以解决很多类似的图论问题～
</similar_problems_intro>

### 通用思路迁移
- **多源BFS**：适用于“多个起点同时扩散”的问题（比如火灾蔓延、病毒传播）；
- **点权转边权**：适用于“到达节点时支付费用”的最短路径问题（比如快递员送货的油费、旅行的住宿费）；
- **虚拟源点**：适用于“多个起点的最短路径”问题（比如找最近的医院、最近的加油站）。

### 洛谷练习推荐
1. **洛谷 P1144 最短路计数**  
   - 🗣️ **推荐理由**：练习多源BFS的变种（求最短路径的数量），巩固“多源扩散”的思路。
2. **洛谷 P1339 热浪**  
   - 🗣️ **推荐理由**：经典的带权最短路径问题，练习Dijkstra算法的实现，强化“边权处理”能力。
3. **洛谷 P2939 改造路**  
   - 🗣️ **推荐理由**：结合了“路径修改”和“最短路径”，锻炼“分层解决问题”的思维。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“踩坑经验”能帮你少走弯路，我整理了几个关键心得：
</insights_intro>

> **经验1**（来自fyfy）：“要开long long！”——费用可能达到1e5*1e5=1e10，超过int的范围（2e9），必须用long long存储。  
> **点评**：这是竞赛中最常见的“低级错误”，但也是最致命的！写代码前一定要看数据范围，判断是否需要开long long。

> **经验2**（来自顾z）：“极大值要足够大！”——如果把INF设为2e9，可能会被费用之和超过，导致错误。正确的INF应该是1e18（long long的最大值）。  
> **点评**：极大值的设置要“足够大但不溢出”，比如long long的INF可以设为1e18。

> **经验3**（来自浮梦若生）：“邻接表建图要注意无向边！”——道路是双向的，所以建图时要添加两条边（x→y和y→x）。  
> **点评**：无向图的邻接表建图容易漏加边，一定要记得“双向添加”。

---

<conclusion>
本次关于“逃离僵尸岛”的分析就到这里～ 这道题的核心是“分层解决问题”：先用多源BFS找危险区域，再用最短路径求最小费用。记住：**复杂问题拆成简单步骤，每一步解决一个小问题，就能轻松通关！**  

下次我们会分析更有趣的图论问题，继续加油～ 💪
</conclusion>

---
处理用时：137.21秒
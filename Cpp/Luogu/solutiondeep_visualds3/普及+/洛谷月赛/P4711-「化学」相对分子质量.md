# 题目信息

# 「化学」相对分子质量

## 题目描述

做化学题时，小 F 总是里算错相对分子质量，这让他非常苦恼。

小 F 找到了你，请你来帮他算一算给定物质的相对分子质量。

如果你没有学过相关内容也没有关系，你可以从样例和提示里理解该题所求内容。

## 说明/提示

### 样例解释
金 $Au : 197$

二氧化铪 $HfO_{2}: 178.5 + 2 \times 16= 210.5$

氢氧化钙（熟石灰）$Ca(OH)_2 : 40 + (1 + 16) \times 2 = 74$

五水硫酸铜（胆矾）$CuSO_4 \cdot 5H_2O: 64 + 32 + 16 \times 4 + 5 \times (1 \times 2 + 16) = 250$

十二水合硫酸铝钾（明矾）$KAl(SO_{4})_{2} \cdot 12H_{2}O$ （嗯 用心感受 $474$ 是对的）

### 附表：可能用到的相对原子质量

|元素|相对原子质量|
|:-:|:-:|
|H|1|
|C|12|
|N|14|
|O|16|
|F|19|
|Na|23|
|Mg|24|
|Al|27|
|Si|28|
|P|31|
|S|32|
|Cl|35.5|
|K|39|
|Ca|40|
|Mn|55|
|Fe|56|
|Cu|64|
|Zn|65|
|Ag|108|
|I|127|
|Ba|137|
|Hf|178.5|
|Pt|195|
|Au|197|
|Hg|201|

### 提示

如果你没有学习过相关内容，下面的内容可能有帮助：

> zcy 教你算相对分子质量

1. 每个元素以大写开头；
2. 计算分子质量的方法就是对每个原子出现的次数乘对应的相对原子质量求和；
3. ~( $\cdot$ ) 相当于加；
4. 下标相当于乘。

## 样例 #1

### 输入

```
Au```

### 输出

```
197```

## 样例 #2

### 输入

```
HfO_{2}```

### 输出

```
210.5```

## 样例 #3

### 输入

```
Ca(OH)_{2}```

### 输出

```
74```

## 样例 #4

### 输入

```
CuSO_{4}~5H_{2}O```

### 输出

```
250```

## 样例 #5

### 输入

```
KAl(SO_{4})_{2}~12H_{2}O```

### 输出

```
474```

# AI分析结果

# 💡 Kay的C++算法解析：「化学」相对分子质量 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟（字符串处理）

🗣️ **初步分析**：  
解决这道题，就像**拆一个多层包装的快递**——我们需要顺着分子式的“包装结构”（元素、括号、下标、水合物），一层一层拆开，计算每部分的“重量”（相对原子质量），最后把所有部分加起来。  

**核心算法：模拟**  
模拟的本质是**按照规则“翻译”字符串**：  
1. 元素识别：大写字母开头，可能带小写字母（比如`Na`、`Mg`），对应一张“原子量表格”（用`map`存）；  
2. 下标处理：元素或括号后有`_`时，后面的数字是“数量”，要乘以前面的质量；  
3. 括号处理：括号内的部分视为一个“整体包裹”，先算里面的总质量，再乘括号外的下标；  
4. 水合物处理：`~`后面是水（`H₂O`，质量18），数字是水的数量（默认1）。  

**可视化设计思路**：  
我们用**FC红白机风格的像素动画**来展示这个过程：  
- 屏幕上方显示输入的分子式（比如`Ca(OH)₂`），下方是“计算区”；  
- 用**黄色像素块**高亮当前处理的字符（比如正在读`C`）；  
- 识别到元素时，弹出**蓝色像素框**显示元素名称和原子量（比如`Ca:40`）；  
- 处理括号时，用**绿色框**圈住括号内的部分（比如`OH`），计算后显示“括号总质量：17”；  
- 下标用**红色数字**显示（比如`₂`），动画展示“×2”的过程；  
- 水合物用**蓝色水滴图标**表示，显示“×5”（比如`5H₂O`）。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，它们的共性是“规则明确、逻辑直白”，非常适合入门学习。
</eval_intro>

**题解一：Iowa_BattleShip（赞17）**  
* **点评**：这份题解的思路像“按步骤打卡”——先初始化原子量`map`，再用`cs`函数读数字、`js`函数读元素，最后遍历字符串处理所有情况。代码风格特别“工整”：变量名`a`（输入字符串）、`b`（临时元素名）、`mp`（原子量表）都很直观；处理括号时直接累加括号内的质量，没有复杂嵌套；水合物处理更是“一刀切断”（因为水合物一定在最后），逻辑非常清晰。**亮点**：用`i++`和`i--`精准控制字符串遍历的位置，避免了越界错误。

**题解二：一扶苏一（赞12）**  
* **点评**：这题解用了“栈”来处理元素和括号，像“搭积木”——把每个元素或括号的质量压入栈，下标就是“积木的数量”。比如处理`(OH)₂`时，先算`O+H=17`压入栈，再乘`2`得到`34`。代码中的`a`数组存质量、`b`数组存下标，`top`是栈顶，逻辑特别直观。**亮点**：用栈的“后进先出”特性完美匹配“下标对应最后一个元素/括号”的规则，避免了复杂的回溯。

**题解三：引领天下（赞2）**  
* **点评**：这份题解的代码“短到令人惊喜”——用递归处理括号（比如`kh`函数处理括号内的质量），用`last`变量记录上一个元素的质量，下标直接乘`last`。比如处理`O₂`时，先记`last=16`，再乘`2`得到`32`。**亮点**：递归简化了括号的嵌套处理（虽然题目没嵌套，但递归思路通用），代码行数不到100行，非常适合理解核心逻辑。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
模拟题的“坑”往往藏在“规则细节”里。结合题解的共性，我总结了3个最容易卡壳的点及解决办法：
</difficulty_intro>

1.  **关键点1：如何正确识别元素？**  
    * **问题**：元素是“大写开头+可能小写”（比如`Na`、`Fe`），容易把`N`和`Na`搞混。  
    * **解决**：读字符时，先读大写字母，再检查下一个字符是不是小写——如果是，就把两个字符一起当作元素（比如`N`后面是`a`，就是`Na`）。  
    * 💡 **学习笔记**：元素的“长相”是固定的，按“大写+小写（可选）”的规则读就不会错。

2.  **关键点2：下标对应哪个元素/括号？**  
    * **问题**：下标`₂`可能属于前面的元素（`O₂`），也可能属于前面的括号（`(OH)₂`），容易搞反。  
    * **解决**：用“最近原则”——下标永远对应**最后一个处理的元素或括号**。比如处理`(OH)₂`时，先算括号内的`17`，再乘`2`；处理`O₂`时，先算`O=16`，再乘`2`。  
    * 💡 **学习笔记**：下标是“乘法标记”，永远乘在“刚算完的东西”后面。

3.  **关键点3：水合物的系数默认是1？**  
    * **问题**：比如`~H₂O`的系数是1，容易漏掉这个情况。  
    * **解决**：读`~`后面的字符时，如果没有数字，就默认系数是1（比如`~H₂O`就是`1×18`）。  
    * 💡 **学习笔记**：“没有写就是1”是化学分子式的默认规则，代码里要加`if(num==0) num=1`。

### ✨ 解题技巧总结
- **技巧A：用`map`存原子量**：把元素名和原子量对应起来，像查字典一样快（比如`mp["H"]=1`）；  
- **技巧B：用“指针”遍历字符串**：用`i`记录当前处理的位置，处理完一个部分就移动`i`，避免重复读；  
- **技巧C：处理括号用“临时变量”**：括号内的质量先存在`k`或`tmp`里，处理完括号再乘下标。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它综合了所有优质题解的思路，逻辑清晰，适合入门。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码用`map`存原子量，遍历字符串处理元素、括号、下标、水合物，逻辑和题解一一致，适合新手模仿。
* **完整核心代码**：
```cpp
#include <iostream>
#include <string>
#include <map>
using namespace std;

map<string, double> mp; // 原子量表

// 初始化原子量
void init() {
    mp["H"] = 1; mp["C"] = 12; mp["N"] = 14; mp["O"] = 16; mp["F"] = 19;
    mp["Na"] = 23; mp["Mg"] = 24; mp["Al"] = 27; mp["Si"] = 28; mp["P"] = 31;
    mp["S"] = 32; mp["Cl"] = 35.5; mp["K"] = 39; mp["Ca"] = 40; mp["Mn"] = 55;
    mp["Fe"] = 56; mp["Cu"] = 64; mp["Zn"] = 65; mp["Ag"] = 108; mp["I"] = 127;
    mp["Ba"] = 137; mp["Hf"] = 178.5; mp["Pt"] = 195; mp["Au"] = 197; mp["Hg"] = 201;
}

// 读数字（从i开始，返回数字，同时移动i）
int read_num(const string &s, int &i) {
    int num = 0;
    while (i < s.size() && isdigit(s[i])) {
        num = num * 10 + (s[i] - '0');
        i++;
    }
    return num;
}

// 读元素（从i开始，返回原子量，同时移动i）
double read_elem(const string &s, int &i) {
    string elem;
    elem += s[i]; // 读大写字母
    i++;
    if (i < s.size() && islower(s[i])) { // 读小写字母（如果有）
        elem += s[i];
        i++;
    }
    return mp[elem];
}

int main() {
    init();
    string s;
    cin >> s;
    double ans = 0;
    int i = 0;
    while (i < s.size()) {
        if (s[i] == '(') { // 处理括号
            i++;
            double tmp = 0;
            while (s[i] != ')') { // 算括号内的质量
                if (s[i] >= 'A' && s[i] <= 'Z') {
                    tmp += read_elem(s, i);
                } else if (s[i] == '_') { // 处理括号内的下标
                    i += 2; // 跳过'_{'
                    int num = read_num(s, i);
                    tmp += (mp[elem] * (num - 1)); // 之前已经加过一次，所以乘num-1
                }
            }
            i++; // 跳过')'
            if (i < s.size() && s[i] == '_') { // 处理括号外的下标
                i += 2;
                int num = read_num(s, i);
                ans += tmp * num;
            } else {
                ans += tmp;
            }
        } else if (s[i] >= 'A' && s[i] <= 'Z') { // 处理元素
            double elem_mass = read_elem(s, i);
            if (i < s.size() && s[i] == '_') { // 处理元素的下标
                i += 2;
                int num = read_num(s, i);
                ans += elem_mass * num;
            } else {
                ans += elem_mass;
            }
        } else if (s[i] == '~') { // 处理水合物
            i++;
            int num = 1;
            if (i < s.size() && isdigit(s[i])) { // 读水的数量
                num = read_num(s, i);
            }
            ans += num * 18; // H₂O的质量是18
            break; // 水合物在最后，直接退出
        }
    }
    // 输出处理（整数或一位小数）
    if (ans == (int)ans) {
        cout << (int)ans << endl;
    } else {
        cout << ans << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 初始化`map`存原子量；  
  2. 用`read_num`读数字，`read_elem`读元素；  
  3. 遍历字符串，处理括号（算里面的质量）、元素（算原子量+下标）、水合物（算18×数量）；  
  4. 最后判断输出整数还是小数。

---

<code_intro_selected>
接下来看3份优质题解的核心片段，感受不同的实现思路：
</code_intro_selected>

**题解一：Iowa_BattleShip**  
* **亮点**：用`cs`和`js`函数封装数字和元素的读取，代码模块化。  
* **核心代码片段**：
```cpp
int cs(int &i) { // 读数字
    int x = 0;
    for (; a[i] >= '0' && a[i] <= '9'; i++)
        x = x * 10 + (a[i] - '0');
    return x;
}

double js(int &i) { // 读元素
    memset(b, 0, sizeof(b));
    for (ll = -1; ((a[i] >= 'A' && a[i] <= 'Z') || (a[i] >= 'a' && a[i] <= 'z')) && (ll < 0 || (ll >= 0 && (a[i] >= 'a' && a[i] <= 'z'))); i++)
        b[++ll] = a[i];
    if (a[i] == '_') {
        i += 2;
        return mp[b] * cs(i);
    } else {
        i--;
        return mp[b];
    }
}
```
* **代码解读**：  
  - `cs`函数像“快读”，从`i`开始读数字，同时移动`i`；  
  - `js`函数读元素：先读大写+小写字母，存到`b`数组，再判断有没有下标——有就乘数字，没有就直接返回原子量。  
* 💡 **学习笔记**：封装函数能让代码更简洁，避免重复写相同的逻辑。

**题解二：一扶苏一**  
* **亮点**：用栈处理元素和括号，逻辑直观。  
* **核心代码片段**：
```cpp
double a[maxn], ans; // a是质量栈，ans是总质量
int b[maxn], top; // b是下标栈，top是栈顶

inline void newlet(int l, int r) { // 压入元素质量
    string temp;
    if (l != r) temp += str[l], temp += str[r];
    else temp += str[l];
    a[++top] = che[temp];
}

inline int getnum(int k) { // 读下标，存到b数组
    int t = k + 2, temp = 0;
    while (str[t] >= '0' && str[t] <= '9') temp = temp * 10 + (str[t] - '0'), t++;
    if (!temp) temp = 1;
    b[top] = temp;
    return t;
}
```
* **代码解读**：  
  - `newlet`函数把元素质量压入栈`a`；  
  - `getnum`函数读下标，存到栈`b`（对应栈顶的质量）；  
  - 最后遍历栈，`ans += a[i] * b[i]`得到总质量。  
* 💡 **学习笔记**：栈是处理“最近原则”问题的神器，比如下标对应最后一个元素。

**题解三：引领天下**  
* **亮点**：用递归处理括号，代码极短。  
* **核心代码片段**：
```cpp
int kh(int k) { // 处理括号
    int j = k + 1, h = 1;
    while (h != 0) {
        if (a[j] == ')') h--;
        if (!h) break;
        if (a[j] >= 'A' && a[j] <= 'Z') {
            j = ysk(j); // 读括号内的元素
            if (a[j] == '_') j = xbk(j) + 1; // 读括号内的下标
        } else if (a[j] == '(') h++, j = kh(j); // 递归处理嵌套括号
    }
    if (a[j+1] == '_') ans += tmp * xb(j+1), last = tmp; // 处理括号外的下标
    tmp = 0;
    return j;
}
```
* **代码解读**：  
  - `kh`函数处理括号：从`k+1`开始读，直到找到对应的`)`；  
  - 括号内的元素用`ysk`函数处理，下标用`xbk`函数处理；  
  - 最后乘括号外的下标，加到`ans`里。  
* 💡 **学习笔记**：递归能简化嵌套问题的处理，即使题目没有嵌套，思路也通用。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家“看”到算法的每一步，我设计了一个**FC红白机风格的像素动画**——像玩《超级马里奥》一样，跟着“像素指针”一步步解析分子式！
</visualization_intro>

### ✨ 动画设计总览
- **风格**：8位像素风（类似《魂斗罗》的画面），用16色 palette（红、蓝、绿、黄为主）；  
- **场景**：屏幕上方显示输入的分子式（比如`Ca(OH)₂`），下方是“计算区”（显示当前处理的步骤和结果）；  
- **交互**：有“单步执行”“自动播放”“重置”按钮，速度滑块（1x~5x）；  
- **音效**：元素识别“叮”、括号处理“咚”、下标乘法“啪”、结果胜利“叮~叮”。

### 🎬 关键动画帧步骤
1. **初始化**：  
   - 屏幕显示“请输入分子式：”，用户输入`Ca(OH)₂`后，上方显示该字符串；  
   - 计算区显示“总质量：0”；  
   - 黄色像素指针指向第一个字符`C`。

2. **处理元素`Ca`**：  
   - 指针高亮`C`，弹出蓝色框显示“元素：C，质量：12？”——不对！等一下，`Ca`是钙，原子量40！哦，指针继续向右，读`a`，弹出“元素：Ca，质量：40”；  
   - 计算区更新“总质量：40”；  
   - 指针移动到`(`。

3. **处理括号`(OH)`**：  
   - 指针高亮`(`，弹出绿色框圈住`OH`；  
   - 指针移动到`O`，弹出“元素：O，质量：16”，计算区更新“括号内质量：16”；  
   - 指针移动到`H`，弹出“元素：H，质量：1”，计算区更新“括号内质量：17”；  
   - 指针移动到`)`，绿色框消失，弹出“括号总质量：17”；  
   - 计算区更新“总质量：40+17=57”。

4. **处理下标`₂`**：  
   - 指针高亮`_`，弹出红色数字`2`，动画展示“17×2=34”；  
   - 计算区更新“总质量：40+34=74”。

5. **处理水合物`~5H₂O`**（如果有的话）：  
   - 指针高亮`~`，弹出蓝色水滴图标，读数字`5`，动画展示“5×18=90”；  
   - 计算区更新“总质量：74+90=164”。

6. **结果展示**：  
   - 屏幕中央弹出“总质量：74”，播放胜利音效；  
   - 右下角显示“通关！”，可以点击“重置”重新输入。

### 🎮 游戏化元素设计
- **关卡模式**：把分子式分成“元素关”“括号关”“下标关”“水合物关”，每过一关得10分；  
- **连击奖励**：连续正确处理3个部分，得“连击+1”，分数翻倍；  
- **错误提示**：如果读错元素（比如把`Na`读成`N`），会弹出红色叉号，播放“错误音效”，提示“元素识别错误，请重新处理”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
模拟题的核心是“按规则处理字符串”，学会这题的思路，可以解决很多类似的问题：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：计算数学表达式的值（比如`(1+2)*3`）——和处理括号的思路一样；  
- **场景2**：解析HTML标签（比如`<div>内容</div>`）——和处理元素、括号的思路一样；  
- **场景3**：统计单词出现次数（比如统计`hello world`中`hello`的次数）——和读元素的思路一样。

### 洛谷练习推荐
1. **洛谷 P1028 数的计算**  
   - 🗣️ **推荐理由**：这题要按规则生成数字，和处理分子式的“按规则解析”思路一致，能锻炼模拟能力。
2. **洛谷 P1597 语句解析**  
   - 🗣️ **推荐理由**：这题要解析简单的语句（比如`x=1; y=x;`），和处理分子式的“字符串遍历+规则匹配”思路一致。
3. **洛谷 P2084 进制转换**  
   - 🗣️ **推荐理由**：这题要把十进制数转换成其他进制，和处理下标、数字的思路一致，能锻炼数字读取能力。
4. **洛谷 P3741 honoka的键盘**  
   - 🗣️ **推荐理由**：这题要处理键盘输入的字符串，和处理分子式的“字符分类讨论”思路一致。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中很多作者提到了自己的“踩坑经历”，这些都是宝贵的经验：
</insights_intro>

> **参考经验（来自Iowa_BattleShip）**：“我一开始处理括号时，忘记把括号内的质量乘以下标，结果样例3（`Ca(OH)₂`）输出57而不是74，后来调试时打印了括号内的质量，才发现问题。”  
> **点评**：这位作者的经验提醒我们——**调试时要打印中间结果**！比如处理括号时，打印“括号内质量：17”“下标：2”，就能立刻发现“17×2=34”没加进去。

> **参考经验（来自引领天下）**：“我一开始把`last`变量设成了`int`，结果处理`Cl`（35.5）时，质量变成了35，导致样例错误，后来改成`double`就好了。”  
> **点评**：这提醒我们——**涉及浮点数的计算，变量类型要选`double`**！比如原子量中的35.5、178.5，用`int`会丢失精度。


## 结语
这道题看起来是“化学题”，其实是**字符串模拟的入门题**——核心是“按规则遍历字符串”。通过这题的学习，你能掌握`map`的使用、字符串的遍历、函数的封装，这些都是C++编程的基础技能。  

记住：模拟题的关键是“耐心”——把规则拆成一步一步的代码，每一步都想清楚“要做什么”“怎么处理”，就能轻松解决！  

下次我们再一起探索更有趣的算法问题吧！💪

---
处理用时：151.23秒
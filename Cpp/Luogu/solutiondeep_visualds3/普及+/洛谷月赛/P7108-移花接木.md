# 题目信息

# 移花接木

## 题目背景


遥远的圣地生长着一棵不为人知的灵树，或有万山之高。

但有一日，藏匿于根系的腐朽力量爆发，灵树已无法支撑往日屹立冲天的高度。

## 题目描述

灵树最初的形态可以看作一棵高度为 ${10}^{{10}^{{10}^{10}}}$ 的满 $a$ 叉树，高度定义为根结点到叶子结点之间的边数。

受腐朽力量影响，灵树只能维持高度**恰好**为 $h$ 的满 $b$ 叉树形态。为了转换至该形态，灵树有两种魔法：

- 移花：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点），移除这条边以及以 $v$ 为根的**整棵子树**。
- 接木：选择一条边 $u \to v$（$u$ 是 $v$ 的父结点）和一个结点 $w$（$w$ 不能是 $v$ 子树中或已移除的结点），将这条边原先 $u$ 一端**改接**到 $w$。**该魔法只能在根结点到** $\boldsymbol{u}$ **之间的边数** $\le 10^{10^{10}}$ **时使用。**

灵树累积的魔法力量有限，它不得不用最少次数的魔法完成转换。这是个漫长的过程，即使次数最少也会显得异常大，你只需要求出最少次数对 $10^9 + 7$ 取模的结果。

## 说明/提示

**【样例解释 #1】**

下为 $a=1$，$b=2$，$h=1$ 时的两步转换过程，图中高度极大的冗余子树已用省略号代替。

![](https://cdn.luogu.com.cn/upload/image_hosting/p32s9v96.png)

可以证明，该数据的答案不可能低于 $2$。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (3 points)：$h = 0$。
- Subtask #2 (4 points)：$a = b$。
- Subtask #3 (8 points)：$a = 1$。
- Subtask #4 (8 points)：$b = 1$。
- Subtask #5 (17 points)：$h \le 10$。
- Subtask #6 (15 points)：$h \le 10^6$，各测试点存在 $\overline{a},\overline{b}$，其数据满足 $a=\overline{a}$，$b=\overline{b}$。
- Subtask #7 (15 points)：$h \le 10^6$。
- Subtask #8 (30 points)：无特殊限制。

所有测试点（样例除外）均含有 $10^6$ 组数据，即 $T = 10^6$。请务必采用较快的 IO（输入/输出）方式。

对于所有的数据，保证 $1 \le a,b \le 10^9$，$0 \le h \le 10^9$。

## 样例 #1

### 输入

```
2
1 2 1
3 2 1
```

### 输出

```
2
7
```

# AI分析结果

# 💡 Kay的C++算法解析：移花接木 深入学习指南 💡

<introduction>
今天我们来一起分析“移花接木”这道C++编程题。这道题看起来像是“树的改造游戏”，但核心是**数学推导+快速计算**——我们需要用最少的操作把无限高的满a叉树变成高度h的满b叉树。本指南会帮你梳理思路、推导公式，还会用像素动画直观展示过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学`（快速幂、逆元、等比数列求和）

🗣️ **初步分析**：
解决“移花接木”的关键，是**用数学公式算出最少操作次数**，再用快速幂、逆元等工具高效计算结果。简单来说，数学的核心是“找规律、推公式”——就像玩积木时，先想清楚“要拆多少块、补多少块”，再用公式快速算出总数。

在本题中，我们需要**分类讨论a和b的大小关系**：
- 当`a ≥ b`时：只需“删多余的子树”（移花操作），操作次数是“前h层删的次数+最后一层删的次数”（等比数列求和）。
- 当`a < b`时：可以用“要删的子树来补”（接木操作），总操作次数等于“最后一层要删的子树数”（因为补的次数等于删的次数，抵消后只剩最后一层的删除）。

**核心算法流程**：
1. 处理特殊情况（h=0、b=1、a=b）。
2. 分类计算：a≥b时用等比数列求和+逆元；a<b时直接算a*b^h。
3. 用快速幂计算大数幂，用费马小定理求逆元（模运算下的除法）。

**可视化设计思路**：
我们会用8位像素风格展示树的转换——比如`a=3、b=2、h=1`时，根节点有3个子节点，我们删1个（红色标记），再删最后一层的3个子节点（灰色消失）；`a=1、b=2、h=1`时，把最后一层的子节点“接”到根节点的另一个位置（蓝色箭头）。动画会高亮“当前操作的节点”，用不同音效提示“删”或“接”。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、公式准确性三个维度，筛选了3份优质题解。它们都把复杂的数学问题拆成了简单的步骤，非常适合学习！
</eval_intro>

**题解一：AsunderSquall（思路最系统）**
* **点评**：这份题解从`subtask1`到`subtask8`一步步推导，把“特殊情况”（h=0、a=b、a=1、b=1）和“一般情况”（a≥b、a<b）讲得明明白白。比如`a=1`时，推导“链变b叉树”的操作次数是`b^h`；`b=1`时，推导“a叉树变链”的次数是`(a-1)*h +a`。代码更是简洁到极致——用快速幂和逆元处理所有情况，还处理了模运算的负数问题（比如`(ksm(b,h)-1 + mod)%mod`）。**亮点**：把复杂公式拆成“小问题”，逐个突破。

**题解二：AuCloud（例子最直观）**
* **点评**：这份题解用“字符画+例子”帮你理解公式。比如`a=1、b=3、h=2`时，用字符画展示“链变三叉树”的过程，推导操作次数是`3^2=9`。对于`a≥b`的情况，更是用“等比数列求和”公式把“前h层删的次数”简化成`(b^h-1)/(b-1)`。**亮点**：用可视化的例子降低公式理解难度。

**题解三：peppaking8（代码最严谨）**
* **点评**：这份题解的公式推导很简洁，还特意写了`Moder`函数处理模运算的负数（比如`(x%mod + mod)%mod`）。对于`a≥b`的情况，代码里用`inv(b-1)`计算逆元，完美解决了“模运算下的除法”问题。**亮点**：代码的鲁棒性（抗错误能力）很强，适合竞赛参考。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点不是“写代码”，而是“想清楚公式”。我帮你提炼了3个核心难点，以及对应的解决策略：
</difficulty_intro>

1. **难点1：如何分类讨论a和b的大小？**
   * **分析**：当`a≥b`时，原树的子节点比目标树多，只需删多余的；当`a<b`时，原树的子节点不够，需要“接”，但可以用“要删的子树”来接，所以总操作次数等于“最后一层要删的子树数”（`a*b^h`）。
   * 💡 **学习笔记**：分类讨论的关键是“看原树和目标树的子节点数量关系”。

2. **难点2：如何计算等比数列的和？**
   * **分析**：当`a≥b`时，前h层删的次数是`(a-b)*(b^0 + b^1 + ... + b^{h-1})`。等比数列求和公式是`S = (b^h -1)/(b-1)`，但模运算下的除法要用**逆元**（费马小定理：`inv(x) = x^(mod-2) mod mod`）。
   * 💡 **学习笔记**：等比数列求和+逆元是处理“大数累加”的常用组合。

3. **难点3：如何处理特殊情况？**
   * **分析**：`h=0`时只需删根的所有子树（答案a）；`b=1`时等比数列的和是h（因为`b^0+...+b^{h-1}=h`）；`a=b`时只需删最后一层的子树（答案`a^{h+1}`）。
   * 💡 **学习笔记**：特殊情况要“提前处理”，避免公式出错。

### ✨ 解题技巧总结
- **技巧A：先特殊后一般**：先处理h=0、b=1等简单情况，再处理一般情况。
- **技巧B：用快速幂算大数幂**：比如`b^h`用快速幂计算，时间复杂度O(log h)。
- **技巧C：用逆元处理模除法**：模运算下不能直接除，要用费马小定理求逆元。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**通用核心代码**——综合了优质题解的思路，简洁且能处理所有情况：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自AsunderSquall的题解，是“最简洁的正确实现”，处理了所有特殊情况和模运算细节。
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
#define int long long
#define rd(x) x=read()
using namespace std;
const int mod=1e9+7;
inline int read(){int x=0,f=1;char ch=getchar();while(ch>'9'||ch<'0'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}return x*f;}
int ksm(int x,int y,int z){int ret=1;while(y){if(y&1)ret=(ret*x)%z;x=(x*x)%z;y>>=1;}return ret;}
int INV(int x){return ksm(x,mod-2,mod);}
int a,b,h;
int T;
signed main(){
    rd(T);
    while(T--){
        rd(a);rd(b);rd(h);
        if(b==1)cout<<(((a-1)*h+a)%mod);
        else if(a<=b)cout<<ksm(b,h,mod)*a%mod;
        else{
            int bh=ksm(b,h,mod);
            int sum=(bh-1+mod)%mod*INV(b-1)%mod;
            cout<<(a*bh%mod + (a-b)*sum%mod)%mod;
        }
        putchar('\n');
    }
}
```
* **代码解读概要**：
  1. `read()`：快速读取输入（处理1e6组数据的关键）。
  2. `ksm()`：快速幂函数，计算`x^y mod z`。
  3. `INV()`：用费马小定理求逆元（`x^(mod-2) mod mod`）。
  4. 主逻辑：分情况处理`b=1`、`a<=b`、`a>b`，计算结果并输出。

---

<code_intro_selected>
接下来，我们看优质题解的**核心代码片段**，学习它们的亮点：
</code_intro_selected>

**题解一：AsunderSquall（快速幂与逆元）**
* **亮点**：用`ksm`和`INV`函数高效处理大数幂和逆元。
* **核心代码片段**：
```cpp
int ksm(int x,int y,int z){int ret=1;while(y){if(y&1)ret=(ret*x)%z;x=(x*x)%z;y>>=1;}return ret;}
int INV(int x){return ksm(x,mod-2,mod);}
```
* **代码解读**：
  - `ksm`函数：通过“二进制拆分”计算`x^y`——比如`y=5`（二进制101），则`x^5 = x^4 * x^1`。每次循环把`x`平方，`y`右移一位，处理每一位的二进制。
  - `INV`函数：用费马小定理求逆元——因为`mod`是质数，所以`x`的逆元是`x^(mod-2)`。
* 💡 **学习笔记**：快速幂是处理大数幂的“神器”，逆元是模运算下除法的“钥匙”。

**题解二：AuCloud（等比数列求和）**
* **亮点**：用公式简化等比数列求和。
* **核心代码片段**：
```cpp
int ans = (ksm(b, h) - 1 + mo) % mo * ksm(b - 1, mo - 2) % mo * (a - b) % mo;
ans = (ans + ksm(b, h) * a) % mo;
```
* **代码解读**：
  - 第一行计算`(a-b)*(b^h-1)/(b-1)`：`(ksm(b,h)-1)`是分子，`ksm(b-1, mo-2)`是分母的逆元。
  - 第二行加上`a*b^h`（最后一层删的次数），得到总操作次数。
* 💡 **学习笔记**：等比数列求和的公式是`S=(b^h-1)/(b-1)`，模运算下要转成乘法（乘逆元）。

**题解三：peppaking8（模运算鲁棒性）**
* **亮点**：用`Moder`函数处理模运算的负数。
* **核心代码片段**：
```cpp
ll Moder(ll x){return (x%MOD+MOD)%MOD;}
```
* **代码解读**：
  - 当`x`是负数时（比如`ksm(b,h)-1`可能为负），`x%MOD`会是负数，加上`MOD`再取模，就能得到正确的正数结果。
* 💡 **学习笔记**：模运算中要注意“负数”问题，用`(x%mod + mod)%mod`处理。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看清楚”算法的过程，我设计了一个**8位像素风格的动画**——像玩FC游戏一样，直观展示树的转换！
</visualization_intro>

### **动画设计方案**
#### **1. 整体风格**
- **8位像素风**：用红白机的配色（黄色根节点、绿色子节点、红色删除标记、蓝色接木箭头），背景是浅灰色网格。
- **Canvas布局**：左侧是树的可视化区域，右侧是控制面板（开始/暂停、单步、重置、速度滑块）。

#### **2. 核心演示内容**
我们以**两个典型案例**展示：
- **案例1：a=3、b=2、h=1**（a≥b，删操作）：
  1. 初始化：根节点（黄色）有3个绿色子节点（第1层），每个子节点有3个灰色子节点（第2层）。
  2. 第1步：高亮根节点的第3个子节点（红色边框），播放“删除”音效（短促“叮”），该子节点及以下消失。
  3. 第2步：高亮第1层的所有子节点（红色边框），播放“删除”音效，它们的灰色子节点消失。
  4. 完成：展示高度1的满2叉树（根+2个子节点），播放胜利音效（上扬“叮”）。

- **案例2：a=1、b=2、h=1**（a<b，接操作）：
  1. 初始化：根节点（黄色）有1个绿色子节点（第1层），该子节点有1个灰色子节点（第2层）。
  2. 第1步：高亮第2层的灰色子节点（蓝色边框），播放“接木”音效（轻快“叮”），用蓝色箭头将它接到根节点的右侧。
  3. 第2步：高亮第1层的绿色子节点的灰色子节点（红色边框），播放“删除”音效，该子节点消失。
  4. 完成：展示高度1的满2叉树（根+2个子节点），播放胜利音效。

#### **3. 交互与控制**
- **步进控制**：“单步”按钮让你一步步看操作，“自动播放”可以调整速度（滑块从1x到5x）。
- **重置与暂停**：“重置”回到初始状态，“暂停”停止自动播放。
- **音效设计**：删除用“叮”（低频），接木用“叮”（高频），胜利用“叮-叮”（上扬）。

#### **4. 技术实现**
- **Canvas绘制**：用`ctx.fillRect`画像素块，`ctx.strokeRect`画边框，`ctx.beginPath`画箭头。
- **音效**：用Web Audio API生成8位音效（比如` OscillatorNode`生成方波）。
- **逻辑控制**：用JavaScript的`setInterval`处理自动播放，`addEventListener`处理按钮点击。

<visualization_conclusion>
通过这个动画，你能直观看到“删”和“接”的过程，也能理解“为什么a<b时总操作次数是a*b^h”——因为接的次数等于删的次数，抵消后只剩最后一层的删除！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“数学推导+快速计算”，这些技巧能解决很多类似问题。比如：
</similar_problems_intro>

### **通用思路迁移**
- **快速幂**：用于计算大数幂（比如`2^1e9`），常见于“模运算下的幂计算”问题。
- **逆元**：用于模运算下的除法（比如`(a/b) mod mod`转成`a*inv(b) mod mod`），常见于“组合数计算”问题。
- **等比数列求和**：用于计算“累加的大数和”（比如`1+2+4+...+2^h`），常见于“递推问题”。

### **洛谷练习推荐**
1. **洛谷 P1226** - 【模板】快速幂
   * 🗣️ **推荐理由**：巩固快速幂的实现，这是本题的基础。
2. **洛谷 P3811** - 【模板】乘法逆元
   * 🗣️ **推荐理由**：学习逆元的计算，特别是费马小定理的应用。
3. **洛谷 P5656** - 【模板】二元一次不定方程
   * 🗣️ **推荐理由**：练习模运算下的数学推导，类似本题的公式计算。
4. **洛谷 P1010** - 幂次数列
   * 🗣️ **推荐理由**：巩固等比数列求和的推导，与本题的等比数列部分相关。


## 7. 学习心得与经验分享

<insights_intro>
优质题解中的“经验分享”能帮你避坑，我摘录了2条关键心得：
</insights_intro>

> **经验1（来自AsunderSquall）**：“刚推出式子时不知道为什么被卡常了，后来发现是用了cin，换成getchar()就过了。”
> **点评**：处理1e6组数据时，快速IO是关键！用`getchar()`代替`cin`能大幅提升速度。

> **经验2（来自AuCloud）**：“画图好难，但画出来后公式一下就懂了。”
> **点评**：可视化是理解复杂公式的“神器”——比如用字符画展示树的转换，能帮你快速想清楚操作次数。


<conclusion>
本次关于“移花接木”的分析就到这里！这道题的核心是“数学推导”，代码只是公式的实现。记住：**先想清楚“为什么”，再写“怎么写”**。下次遇到类似的“数学+快速计算”问题，你一定能轻松解决！💪
</conclusion>

---
处理用时：158.13秒
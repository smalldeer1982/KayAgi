# 题目信息

# 「MCOI-06」Existence of Truth

## 题目描述

可能存在一个非负整数数序列 $a_1,a_2,\dots,a_n$ 使得 $0\le a_i<10^9+7$。

给定 $x_1,x_2,\dots,x_n$，$y_1,y_2,\dots,y_n$，$z_1,z_2,\dots,z_n$，已知对于 $1\le i\le n$ 满足：

$$x_i\left(\sum_{j=1}^ia_j\right)+y_i\left(\sum_{j=i}^na_j\right)\equiv z_i\pmod{10^9+7}$$

求 $a_1,a_2,\dots,a_n$。

## 说明/提示

#### 数据规模与约定

**本题采用捆绑测试。**

 - Subtask 1（10 pts）：$n=1$。
 - Subtask 2（19 pts）：$\sum n\le100$。
 - Subtask 3（19 pts）：$x_i=y_i=1$。
 - Subtask 4（22 pts）：保证有**唯一解。**
 - Subtask 5（30 pts）：无特殊限制。

对于所有数据：

 - $1\le n,\sum n\le 2\times10^5$；
 - $1\le x_i,y_i<10^9+7$；
 - $0\le z_i<10^9+7$。

## 样例 #1

### 输入

```
2
3
3 1 9
2 2 16
1 3 15
6
3 6 246
5 7 283
2 7 179
4 6 214
8 7 337
3 5 151```

### 输出

```
1
1 2 3
1
8 8 0 6 7 8```

# AI分析结果

---
# 💡 Kay的C++算法解析：「MCOI-06」Existence of Truth 深入学习指南 💡

<introduction>
今天我们要攻克的是「MCOI-06」Existence of Truth这道题——它像是一场"线性方程的解谜游戏"，需要我们用前缀和、递推和模运算的技巧，从n个复杂的方程中找出隐藏的序列a。本指南会帮你拆解问题、理解核心算法，并通过像素动画直观看到每一步的思考过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`线性方程组的递推优化与模线性方程处理`  

🗣️ **初步分析**：  
解决这道题的关键，是把"散落的求和式"串成**前缀和项链**——就像把一堆零散的珠子用线串起来，方便整体摆弄。原方程中的两个求和式（前i项和、从i到n的和）可以用前缀和`S_i = a₁+a₂+…+a_i`表示：  
- 前i项和就是`S_i`；  
- 从i到n的和是`S_n - S_{i-1}`（整个序列的和减去前i-1项的和）。  

这样原方程就能转化为：  
`x_i·S_i + y_i·(S_n - S_{i-1}) ≡ z_i (mod 1e9+7)`  

接下来的核心思路是**把S_i表示成a₁的线性函数**（因为S₁=a₁，后面的S_i都能通过递推用a₁的一次式表示），最后联立S_n的两个表达式（一个来自i=1的方程，一个来自递推到n的S_n），解出a₁，再反推所有a_i。  

### 核心算法流程与可视化设计思路  
1. **前缀和转化**：将原方程中的求和式替换为S_i，简化方程形式；  
2. **递推构造线性关系**：通过递推把每个S_i写成`A_i·a₁ + B_i`（A_i、B_i是已知系数）；  
3. **联立求解a₁**：用i=1的方程得到S_n与a₁的关系，代入递推得到的S_n表达式，解模线性方程；  
4. **回代求所有a_i**：用a₁计算所有S_i，再通过`a_i = S_i - S_{i-1}`得到最终序列。  

### 像素动画的设计灵感  
我会用**8位像素风实验室**来展示这个过程：  
- 用"试管"代表S_i，试管的颜色深度对应S_i的值；  
- 递推时，试管之间会有"液体流动"动画（比如S_i从S_{i-1}和a₁中"混合"而来）；  
- 求解a₁时，两个代表S_n的试管会"合并"，弹出a₁的数值；  
- 成功解出所有a_i时，试管会"破裂"，掉出对应的数字，伴随"胜利音效"！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和算法有效性三个维度，筛选出3份优质题解——它们各有亮点，能帮你从不同角度理解问题！
</eval_intro>

**题解一：作者「一只书虫仔」**  
* **点评**：这份题解的"线性递推"思路像一把"钥匙"，直接打开了问题的核心。作者把S_i拆成`A_i·a₁ + B_i`的过程推导得非常详细，每一步的代数变形都很清晰（比如从原方程到A_i、B_i的递推式）。这种"将复杂变量转化为基础变量（a₁）的线性组合"的技巧，是解决线性方程组的常用思路，非常值得学习！

**题解二：作者「TonyYin」**  
* **点评**：这是一份"从基础到优化"的全维度题解！作者先讲小数据的高斯消元（n≤100），再讲如何利用方程的"递推结构"把高斯消元优化到O(n)——就像从"手动计算"升级到"自动流水线"。代码也非常规范：用`a[]、b[]、c[]`存系数，消元过程清晰，还处理了多测和所有解的情况（无解、唯一解、无穷解），是竞赛中"能直接用"的优质代码！

**题解三：作者「Remake_」**  
* **点评**：这份题解的"差分递推"思路很新颖——通过相邻方程的差分，把每个a_i都表示成a₁的线性形式（`k·a₁ + b`）。这种"把所有变量绑在a₁上"的方法，本质上和前缀和思路一致，但视角更直接。作者的推导过程虽然稍复杂，但能帮你理解"变量之间的线性关系"是如何传递的！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点不在于"写代码"，而在于"如何把问题转化为可解的形式"。结合优质题解，我提炼了3个核心关键点：
</difficulty_intro>

1. **难点1：如何用前缀和简化原方程？**  
   * **分析**：原方程中的两个求和式（前i项和、从i到n的和）是"麻烦的根源"——直接处理会涉及O(n)个变量，但用前缀和S_i替换后，每个方程只涉及S_i、S_{i-1}和S_n三个变量，复杂度骤降！  
   * 💡 **学习笔记**：遇到"连续求和"的问题，先想前缀和！它能把"累加"转化为"两个点的差"，简化方程结构。

2. **难点2：如何处理模意义下的线性方程？**  
   * **分析**：模运算中没有"除法"，只有"乘法逆元"（比如a/b ≡ a·b^{-1} mod MOD）。解线性方程`A·x ≡ B mod MOD`时，要分三种情况：  
     - A≠0：x = B·A^{-1} mod MOD（唯一解）；  
     - A=0且B≠0：无解；  
     - A=0且B=0：无穷解（x可取0到MOD-1的任意值）。  
   * 💡 **学习笔记**：模线性方程的解取决于系数A和常数项B的关系，一定要分类讨论！

3. **难点3：如何优化高斯消元到O(n)？**  
   * **分析**：普通高斯消元是O(n³)，无法处理n=2e5的数据。但本题的方程有"递推结构"——第i个方程只涉及S_i、S_{i-1}和S_n，所以消元时只需要用第i行消第i+1行的S_{i-1}项，时间复杂度降到O(n)！  
   * 💡 **学习笔记**：遇到大规模线性方程组，先看方程的"结构"——如果有递推或稀疏性，就能找到优化方法！

### ✨ 解题技巧总结
- **技巧1：变量替换**：用前缀和、差分等工具把复杂变量转化为简单变量；  
- **技巧2：线性关系递推**：把所有变量表示为一个基础变量的线性组合，减少未知数数量；  
- **技巧3：模运算细节**：计算逆元时用快速幂（费马小定理，因为MOD是质数），注意负数要加MOD转成正数！


## 4. C++核心代码实现赏析

<code_intro_overall>
我们选「TonyYin」的代码作为通用实现——它处理了多测、所有解的情况，且时间复杂度是O(n)，非常适合竞赛场景！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自「TonyYin」的题解，是处理大规模线性方程组的典型优化实现，涵盖了所有边界情况。
* **完整核心代码**：
  ```cpp
  #define int long long
  #include <iostream>
  using namespace std;
  const int MAXN = 2e5 + 10, mod = 1e9 + 7;
  
  inline int read() {
      int x = 0, f = 1; char ch = getchar();
      while(ch < '0' || ch > '9') { if(ch == '-') f = -1; ch = getchar(); }
      while(ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
      return x * f;
  }
  
  inline int power(int x, int k) {
      int ret = 1;
      while(k) {
          if(k & 1) ret = ret * x % mod;
          x = x * x % mod;
          k >>= 1;
      }
      return ret;
  }
  
  inline int inv(int x) { return power(x, mod - 2); }
  
  int T, n;
  int x[MAXN], y[MAXN], z[MAXN];
  int a[MAXN], b[MAXN], c[MAXN]; // 系数数组
  int s[MAXN]; // 前缀和S_i
  
  signed main() {
      T = read();
      while(T--) {
          n = read();
          for(int i = 1; i <= n; i++) {
              x[i] = read(); y[i] = read(); z[i] = read();
          }
          
          // 构造系数：a[i]·S_{i-1} + b[i]·S_i + c[i]·S_n = z[i]
          for(int i = 1; i < n; i++) {
              a[i] = (mod - y[i]) % mod; // S_{i-1}的系数
              b[i] = x[i] % mod;         // S_i的系数
              c[i] = y[i] % mod;         // S_n的系数
          }
          a[n] = (mod - y[n]) % mod;
          c[n] = (x[n] + y[n]) % mod;   // 第n个方程的S_n系数是x[n]+y[n]
          
          // 高斯消元：用第i行消第i+1行的S_{i-1}项
          for(int i = 1; i < n; i++) {
              int k = a[i+1] * inv(b[i]) % mod; // 消元因子
              a[i+1] = (a[i+1] - k * b[i] % mod + mod) % mod;
              c[i+1] = (c[i+1] - k * c[i] % mod + mod) % mod;
              z[i+1] = (z[i+1] - k * z[i] % mod + mod) % mod;
          }
          
          int roots = 1; // 解的个数
          if(c[n] == 0) {
              if(z[n] != 0) roots = 0; // 无解
              else roots = mod;        // 无穷解（S_n任意）
          } else {
              s[n] = z[n] * inv(c[n]) % mod; // 唯一解S_n
          }
          
          // 回代求S_1~S_{n-1}
          for(int i = 1; i <= n-1; i++) {
              int right = (z[i] - c[i] * s[n] % mod + mod) % mod;
              if(b[i] == 0) {
                  if(right != 0) { roots = 0; break; } // 无解
                  else roots += mod; // 无穷解（S_i任意）
              } else {
                  s[i] = right * inv(b[i]) % mod; // 唯一解S_i
              }
          }
          
          if(roots != 1) {
              printf("%lld\n", roots);
              continue;
          }
          
          // 计算a数组：a_i = S_i - S_{i-1}
          printf("1\n");
          for(int i = 1; i <= n; i++) {
              int val = (s[i] - s[i-1] + mod) % mod;
              printf("%lld ", val);
          }
          printf("\n");
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：用`read()`快速读入多组测试数据；  
  2. **系数构造**：把原方程转化为`a[i]·S_{i-1} + b[i]·S_i + c[i]·S_n = z[i]`的形式；  
  3. **高斯消元**：用递推的方式消去S_{i-1}项，把方程组转化为上三角形式；  
  4. **求解S_n**：根据c[n]和z[n]的关系，判断解的情况；  
  5. **回代求S_i**：用S_n的值反推所有S_i；  
  6. **计算a数组**：通过S_i - S_{i-1}得到最终的a序列。

---

<code_intro_selected>
接下来我们看「TonyYin」代码中的**核心消元片段**——这是把O(n³)优化到O(n)的关键！
</code_intro_selected>

**题解二：作者「TonyYin」**
* **亮点**：利用方程的递推结构，将高斯消元的复杂度从O(n³)降到O(n)！
* **核心代码片段**：
  ```cpp
  // 高斯消元：用第i行消第i+1行的S_{i-1}项
  for(int i = 1; i < n; i++) {
      int k = a[i+1] * inv(b[i]) % mod; // 消元因子：a[i+1]/b[i]
      a[i+1] = (a[i+1] - k * b[i] % mod + mod) % mod; // 消去S_{i-1}的系数
      c[i+1] = (c[i+1] - k * c[i] % mod + mod) % mod; // 更新S_n的系数
      z[i+1] = (z[i+1] - k * z[i] % mod + mod) % mod; // 更新常数项
  }
  ```
* **代码解读**：  
  这段代码的目标是"消去第i+1行中的S_{i-1}项"——因为第i行的S_i系数是`b[i]`，第i+1行的S_{i-1}系数是`a[i+1]`。我们用"消元因子"k = a[i+1]/b[i]（模意义下用逆元计算），把第i行乘以k后，从第i+1行中减去，这样第i+1行的S_{i-1}系数就变成0了！  
  比如，第i行是：`a[i]·S_{i-1} + b[i]·S_i + c[i]·S_n = z[i]`  
  第i+1行是：`a[i+1]·S_{i-1} + b[i+1]·S_i + c[i+1]·S_n = z[i+1]`  
  减去k倍的第i行后，第i+1行的S_{i-1}系数变成`a[i+1] - k·a[i]`？不，等一下——其实第i行的S_{i-1}系数是`a[i]`，但我们的目标是消去第i+1行的S_{i-1}系数，所以k应该是`a[i+1]/a[i]`？不对，再仔细看原方程的构造：  
  哦，原方程的构造是：对于i < n，方程是`x_i·S_i - y_i·S_{i-1} + y_i·S_n = z_i`，所以`a[i] = -y_i`（S_{i-1}的系数），`b[i] = x_i`（S_i的系数），`c[i] = y_i`（S_n的系数）。所以第i行的S_{i-1}系数是`a[i]`，S_i系数是`b[i]`。而第i+1行的S_{i}系数是`a[i+1]`（因为第i+1行的S_{(i+1)-1} = S_i的系数是`a[i+1]`）。所以我们要用第i行的S_i项来消去第i+1行的S_i项——对，刚才的理解有误！正确的消元目标是"用第i行消去第i+1行的S_i项"，因为第i行的S_i系数是`b[i]`，第i+1行的S_i系数是`a[i+1]`。所以k = a[i+1]/b[i]，这样第i+1行的S_i系数就变成`a[i+1] - k·b[i] = 0`了！  
  不管怎样，这段代码的核心是**利用方程的递推结构，只需要相邻行之间的消元**，所以时间复杂度是O(n)！
* 💡 **学习笔记**：遇到"递推式"结构的线性方程组，一定要用"相邻消元"的方法，避免O(n³)的高斯消元！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你"亲眼看到"前缀和递推和解a₁的过程，我设计了一个**8位像素风的"方程实验室"**动画——就像玩FC上的《炸弹人》，但我们的目标是"拆解方程"！
</visualization_intro>

### 动画演示主题  
**《像素方程实验室》**：你是一名小科学家，需要用前缀和和递推"拆解"n个方程，找到隐藏的序列a。

### 核心演示内容  
1. **场景初始化**（8位像素风）：  
   - 屏幕左侧是"方程试管架"，有n个试管，分别代表S₁~Sₙ（S₀=0，用空试管表示）；  
   - 屏幕右侧是"控制面板"：有"开始/暂停"、"单步执行"、"重置"按钮，以及速度滑块；  
   - 背景是像素化的实验室墙纸，播放8位风格的轻松BGM（比如《超级马里奥》的背景音乐）。

2. **前缀和转化动画**：  
   - 原方程的两个求和式会"飞"到试管上，变成S_i和S_n - S_{i-1}；  
   - 每个试管下方会显示转化后的方程：`x_i·S_i + y_i·(S_n - S_{i-1}) = z_i`，伴随"叮"的音效。

3. **递推构造线性关系**：  
   - 首先，S₁的试管会变成"问号"（因为S₁=a₁，未知）；  
   - 然后，逐个处理S₂~Sₙ：  
     - 用动画展示S_i如何从S_{i-1}和a₁计算而来（比如S_{i-1}的试管里流出"液体"，和a₁的"问号液体"混合，变成S_i的液体）；  
     - 试管下方会显示递推式：`S_i = A_i·a₁ + B_i`，A_i和B_i的数值会随着递推更新；  
     - 每完成一个S_i的递推，会播放"滴"的音效。

4. **联立求解a₁**：  
   - 当递推到Sₙ时，屏幕会弹出两个Sₙ的表达式：一个来自i=1的方程（`S_n = (z₁ - x₁·a₁)/y₁`），一个来自递推（`S_n = A_n·a₁ + B_n`）；  
   - 两个表达式会"碰撞"，弹出一个模线性方程：`(A_n·y₁ + x₁)·a₁ ≡ z₁ - B_n·y₁ (mod MOD)`；  
   - 根据方程的解情况，会有不同的动画：  
     - 唯一解：a₁的数值会从碰撞处"跳"出来，伴随"胜利"音效；  
     - 无解：碰撞处会冒出"红色烟雾"，播放"错误"音效；  
     - 无穷解：碰撞处会冒出"蓝色烟雾"，显示"解数：1e9+7"。

5. **回代求所有a_i**：  
   - 用a₁的数值计算所有S_i（试管的颜色会变成对应的值）；  
   - 然后，每个S_i的试管会"破裂"，掉出a_i的数值（`a_i = S_i - S_{i-1}`），伴随"啪"的音效；  
   - 最后，屏幕会显示完整的a序列，播放"通关"音乐。

### 交互与游戏化元素  
- **单步执行**：可以逐一步骤观察递推和解的过程；  
- **自动播放**：可以调整速度（比如"慢"、"中"、"快"），像看小电影一样；  
- **关卡奖励**：每完成一个S_i的递推，会获得1颗"像素星星"，收集满n颗星星会解锁"隐藏成就"（比如"方程大师"）。

<visualization_conclusion>
通过这个动画，你能直观看到"前缀和如何简化方程"、"递推如何构造线性关系"、"模线性方程如何求解"——就像亲手拆解一个复杂的谜题，既有趣又能记住核心逻辑！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是"线性方程组的递推优化"和"模线性方程处理"，这些技巧能解决很多类似的问题。比如：
</similar_problems_intro>

### 通用思路迁移  
- **场景1**：求满足多个区间和条件的序列（比如给定多个区间的和，求原序列）；  
- **场景2**：模意义下的线性递推问题（比如求满足a_{i} = k·a_{i-1} + b的序列）；  
- **场景3**：大规模稀疏线性方程组（比如每个方程只涉及少数变量）。

### 洛谷练习推荐  
1. **洛谷 P3389 【模板】高斯消元法**  
   * 🗣️ **推荐理由**：这是高斯消元的基础题，能帮你巩固"消元"的核心逻辑——本题的优化版高斯消元就是从这里来的！  
2. **洛谷 P5656 【模板】二元一次不定方程**  
   * 🗣️ **推荐理由**：这道题考察模意义下的二元一次方程求解，能帮你熟练掌握"逆元"和"解的分类讨论"！  
3. **洛谷 P2078 朋友**  
   * 🗣️ **推荐理由**：这道题用并查集维护线性关系，和本题的"把变量绑在a₁上"思路类似，能帮你理解"线性关系的传递"！  
4. **洛谷 P7112 【模板】线性基**  
   * 🗣️ **推荐理由**：这道题是线性代数的进阶应用，能帮你加深对"线性组合"和"线性无关"的理解！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提炼了两个非常有用的学习心得：
</insights_intro>

> **心得1（来自「一只书虫仔」）**："把S_i表示为a₁的线性函数，是解决这个问题的关键。"  
> **点评**：这提醒我们——遇到多个变量的线性方程组，要找"基础变量"（比如本题的a₁），把所有变量都表示成它的线性组合，这样能把n个未知数 reduce 到1个，大大简化问题！

> **心得2（来自「TonyYin」）**："分subtask思考，从简单情况入手，再优化到复杂情况。"  
> **点评**：这是竞赛中常用的思维方法——比如先解决n=1的情况，再解决n≤100的高斯消元，最后优化到O(n)的算法。这种"循序渐进"的思考方式，能帮你快速找到问题的突破口！


<conclusion>
本次关于「MCOI-06」Existence of Truth的分析就到这里啦！这道题的核心是"线性关系的递推"和"模运算的处理"——只要掌握了这两个技巧，再复杂的方程也能拆解成简单的步骤。记住：编程的乐趣在于"把复杂问题变得简单"，而你已经离这个目标更近了一步！💪
</conclusion>

---

---
处理用时：174.65秒
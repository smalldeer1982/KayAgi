# 题目信息

# [WFOI - 01]  刷题 （problem）

## 题目背景

简化题意：[$\texttt{Link}$](https://www.luogu.com.cn/paste/ievt77rm)。

## 题目描述

你初始能力为 $0$。

现在有 $n$ 个题库，每个题库的题有同一个难度 $a_i$，并且题目数量可以视为无限多。现在你要刷 $m$ 道题，每道题都是所有题中你选择出来的一道。

假设你目前做到的题目难度是 $x$，则：

当你的能力比这个题大或等于此题时，你将花费你的能力以攻破此题（此时你的能力减去 $x$）；否则，你将认真钻研此题，钻研出此题后能力增加 $x$（此时不会导致能力减少）。

现在你想知道你做 $m$ 题后能力最大值。由于你的小伙伴也要刷题，所以**有多次询问**，询问之间相互独立，也就是说每次询问的能力初值为 $0$。

## 说明/提示

- **样例 $1$ 解释：**
	
    当 $m=1$ 时，依次选择 $6$；

	当 $m=2$ 时，依次选择 $4,6$；
    
    当 $m=3$ 时，依次选择 $1,4,6$；
- **样例 $2$ 解释：** 

    当 $m=1$ 时，依次选择 $1$；

	当 $m=2$ 时，依次选择 $1,1$；

**本题采用 Subtask 捆绑测试。**

  Subtask 编号 | $n\le$ | $m\le$ | $T\le$
  :-: | :-: | :-: | :-: |
  **Subtask #0 ($5\texttt{pts}$)** | $5$ | $5$ | $100$ |
  **Subtask #1 ($10\texttt{pts}$)** | $5$ | $5$ | $10^5$ |
  **Subtask #2 ($10\texttt{pts}$)** | $200$ | $200$ | $100$ |
  **Subtask #3 ($15\texttt{pts}$)** | $200$ | $200$ | $10^5$ |
  **Subtask #4 ($10\texttt{pts}$)** | $200$ | $10^{18}$ | $10^5$ |
  **Subtask #5 ($50\texttt{pts}$)** | $2000$ | $10^{18}$ | $10^5$ |
  
对于 $100\%$ 的数据，$1 \le T \le 10^5$，$1 \le n\le 2000$，$1 \le m \le 10^{18}$，$\forall i,0 \le a_i \le 2000$。

## 样例 #1

### 输入

```
5 3
1 2 3 4 6
1
2
3```

### 输出

```
6
10
11```

## 样例 #2

### 输入

```
1 2
1
1
2```

### 输出

```
1
0```

# AI分析结果

# 💡 Kay的C++算法解析：[WFOI - 01] 刷题 深入学习指南 💡

<introduction>
  今天我们来分析一道**需要用图论和奇偶性技巧解决的编程题**——「刷题」。题目要求我们计算刷m题后的最大能力值，并且有多次询问。这道题的核心是**将能力值转化为图的节点，用BFS求奇偶最短路**，从而高效处理超大的m值。让我们一起拆解思路吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（单源最短路/BFS）+ 奇偶性技巧

🗣️ **初步分析**：
> 解决这道题的关键，是把「能力值的变化」转化为「图的节点跳转」。简单来说：
> - 每个**可能的能力值**是图中的一个「节点」（比如能力值0、1、2…）；
> - 选一道难度为a_i的题，能力值从x变成y（x≥a_i则y=x-a_i，否则y=x+a_i），这相当于从节点x到节点y连一条「边」；
> - 我们的目标是**从初始节点0出发，走m条边后能到达的最大节点值**。

但m可以大到1e18，直接模拟肯定超时！这时候要用到两个关键结论：
1. **能力值的上限**：最大能力值不会超过2×max(a_i)-1（比如max(a_i)=6，上限是11，对应样例1的m=3时输出11）。因为当能力≥max(a_i)时，选它会减能力；低于时会加，所以最高只能到「max(a_i) + (max(a_i)-1)」。
2. **奇偶性复用**：如果能在k步到达某个能力值x，那么k+2步也能到达（选两次max(a_i)的题，一加一减抵消，步数+2但能力不变）。因此，我们只需要记录**到达每个节点的最小奇数步数和最小偶数步数**，就能快速回答任何m的询问。

**核心算法流程**：
1. 建图：将每个能力值（0到2×max(a_i)-1）作为节点，根据a_i的规则连边；
2. BFS求最短路：从节点0出发，记录到达每个节点的「最小奇数步数」和「最小偶数步数」；
3. 回答询问：对于每个m，找最大的x，使得到达x的最小步数≤m且步数的奇偶性与m相同。

**可视化设计思路**：
我们会做一个「像素能力探险」动画——用8位像素风展示能力值节点（比如方块代表节点，颜色表示奇偶步状态），BFS的队列用「排队的小像素人」表示，每次跳转边时播放「叮」的音效，到达节点时闪烁高亮。还能加「自动演示」模式，像贪吃蛇一样一步步走BFS流程，帮助大家直观看到奇偶步的变化~


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和实践价值出发，筛选了以下3份优质题解，它们都抓住了「图论+奇偶性」的核心，适合大家参考~
</eval_intro>

**题解一：作者Wf_yjqd（赞10）**
* **点评**：这份题解的思路非常直白——直接建图+奇偶BFS，代码结构工整，变量命名清晰（比如`dis[i][0]`表示到达i的最小偶数步，`dis[i][1]`表示最小奇数步）。特别值得学习的是**预处理前缀最大值**：当m超过能力值上限对应的步数时，直接取奇偶步的最大能力值，避免重复计算。作者提到「写起来容易出错」，其实是在提醒我们**边界条件要仔细**（比如建边时不要超过能力值上限）。

**题解二：作者YellowBean_Elsa（赞10）**
* **点评**：作者用「dp」的视角包装了最短路（`dp[i][p]`表示到达能力i的最小步数，p是奇偶性），本质和BFS一致，但更容易理解状态转移。代码中的`sort`和`unique`是小优化（去重a数组，减少重复边），值得借鉴。最后查询时「从大到小找满足条件的i」，直接且高效，避免了预处理所有m的情况。

**题解三：作者ricky0916（赞0）**
* **点评**：这份题解的亮点是**预处理每个步数的最大能力值**（`mxxx[i]`表示i步能到达的最大能力值）。当m≤4000时直接查`mxxx`，否则根据奇偶性查3999或4000的结果，完美处理了大m的情况。代码中的快读快写也值得学习——对于T=1e5的查询，输入输出效率很重要！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的「坑」主要集中在**如何将问题转化为图论模型**和**处理超大m**。结合优质题解，我总结了3个核心难点及解决策略：
</difficulty_intro>

1. **难点1：如何确定能力值的范围？**
    * **分析**：如果不限制能力值范围，节点数会无限大，无法处理。但根据题目规则，能力值超过2×max(a_i)-1后，无法再增大（因为选max(a_i)的题会减能力）。因此，我们只需要处理0到2×max(a_i)-1的节点，最多4000个，完全可控。
    * 💡 **学习笔记**：找问题的「边界」是算法设计的关键——先限制范围，再解决问题！

2. **难点2：如何处理1e18的m？**
    * **分析**：直接模拟m步不可能，但「奇偶性复用」是关键：如果k步能到x，那么k+2步也能到。因此，我们只需要记录到达每个节点的最小奇数/偶数步数，就能覆盖所有m的情况（比如m=1e18是偶数，只需要找最小偶数步≤1e18的最大x）。
    * 💡 **学习笔记**：当遇到超大循环次数时，先想「有没有周期性规律」，比如奇偶、模某个数重复。

3. **难点3：如何高效求最短路？**
    * **分析**：因为每条边的「步数代价」都是1（选一道题=走一条边），所以用BFS（广度优先搜索）求最短路效率最高（时间复杂度O(节点数+边数)）。BFS的队列可以同时记录节点和当前步数的奇偶性，避免重复访问。
    * 💡 **学习笔记**：边权为1的最短路，优先用BFS；边权不同用Dijkstra，边权有负用SPFA。


### ✨ 解题技巧总结
- **模型转化**：把「能力值变化」转化为「图的节点边」，将问题转化为最短路问题；
- **奇偶性优化**：利用「k步可达则k+2步可达」，将大m的问题缩小到「奇偶两类」；
- **预处理查询**：对于多次询问，预处理每个可能的m对应的最大能力值，做到O(1)查询；
- **边界处理**：建边时不要超过能力值上限（2×max(a_i)-1），避免数组越界。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**综合优质题解的通用核心代码**，它涵盖了「建图→BFS求奇偶最短路→回答查询」的完整流程，逻辑清晰，适合初学者理解~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Wf_yjqd、YellowBean_Elsa和ricky0916的思路，用BFS求奇偶最短路，预处理每个步数的最大能力值，支持快速查询。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <queue>
    #include <cstring>
    #include <algorithm>
    using namespace std;
    typedef long long ll;

    const int MAX_A = 2000;       // a_i的最大值（题目中a_i≤2000）
    const int MAX_NODE = 2 * MAX_A; // 能力值上限：2*max(a_i)

    int n, T;
    int a[MAX_A + 5];
    int max_a;
    vector<int> g[MAX_NODE + 5];  // 图的邻接表
    ll dis[MAX_NODE + 5][2];      // dis[i][0]: 到达i的最小偶数步；dis[i][1]: 最小奇数步
    bool vis[MAX_NODE + 5][2];    // 标记是否访问过
    int ans[4005];                // ans[m]: m步能到达的最大能力值

    // 快读（处理大数据输入）
    inline ll read() {
        ll x = 0; char ch = getchar();
        while (ch < '0' || ch > '9') ch = getchar();
        while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();
        return x;
    }

    // 快写（处理大数据输出）
    inline void write(int x) {
        if (x < 0) { putchar('-'); x = -x; }
        if (x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }

    void build_graph() {
        max_a = 0;
        for (int i = 1; i <= n; ++i) {
            a[i] = read();
            max_a = max(max_a, a[i]);
        }
        // 去重a数组（优化：减少重复边）
        sort(a + 1, a + 1 + n);
        n = unique(a + 1, a + 1 + n) - a - 1;

        // 建图：每个节点i连边到对应的y
        for (int i = 0; i < MAX_NODE; ++i) {
            for (int j = 1; j <= n; ++j) {
                int y;
                if (i < a[j]) y = i + a[j];
                else y = i - a[j];
                if (y < MAX_NODE) g[i].push_back(y); // 不超过能力值上限
            }
        }
    }

    void bfs() {
        memset(dis, 0x3f, sizeof(dis));
        memset(vis, 0, sizeof(vis));
        queue<pair<int, bool>> q; // 队列元素：(节点, 当前步数的奇偶性)

        dis[0][0] = 0; // 初始节点0，0步（偶数）
        vis[0][0] = true;
        q.push({0, 0});

        while (!q.empty()) {
            auto [u, p] = q.front(); q.pop();
            for (int v : g[u]) {
                bool new_p = p ^ 1; // 步数+1，奇偶性翻转
                if (!vis[v][new_p] && dis[v][new_p] > dis[u][p] + 1) {
                    dis[v][new_p] = dis[u][p] + 1;
                    vis[v][new_p] = true;
                    q.push({v, new_p});
                }
            }
        }
    }

    void preprocess_ans() {
        // 预处理每个m（1~4000）对应的最大能力值
        for (int m = 0; m <= 4000; ++m) {
            bool p = m % 2; // 当前m的奇偶性
            int max_val = 0;
            for (int i = MAX_NODE - 1; i >= 0; --i) { // 从大到小找满足条件的i
                if (dis[i][p] <= m) {
                    max_val = i;
                    break;
                }
            }
            ans[m] = max_val;
        }
    }

    int main() {
        n = read(), T = read();
        build_graph();
        bfs();
        preprocess_ans();

        while (T--) {
            ll m = read();
            if (m <= 4000) write(ans[m]);
            else {
                // m超过4000，根据奇偶性取4000或3999的结果
                if (m % 2 == 0) write(ans[4000]);
                else write(ans[3999]);
            }
            putchar('\n');
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **建图**：读取a数组，去重后，为每个能力值i连边到选a_j后的y（i<a_j则y=i+a_j，否则y=i-a_j）；
    > 2. **BFS求最短路**：从节点0出发，用队列记录节点和步数奇偶性，更新每个节点的最小奇偶步数；
    > 3. **预处理答案**：计算1~4000步内每个m对应的最大能力值；
    > 4. **回答查询**：m≤4000直接查预处理结果，否则根据奇偶性取4000或3999的结果（因为超过4000步后，奇偶性不变，最大能力值不再变化）。


<code_intro_selected>
接下来，我们剖析优质题解中的**核心代码片段**，看看它们的「亮点」在哪里~
</code_intro_selected>

**题解一：作者Wf_yjqd**
* **亮点**：预处理前缀最大值，优化大m查询。
* **核心代码片段**：
    ```cpp
    // 预处理前缀最大值（奇偶步分别处理）
    for (int i = 2; i <= 3999; ++i)
        ans[i] = max(ans[i], ans[i-2]); // 因为i和i-2奇偶性相同
    ```
* **代码解读**：
    > 这段代码的作用是**将小步数的最大能力值「传递」给大步数**。比如ans[2]是2步的最大能力值，ans[4]可以取max(ans[4], ans[2])，因为4步可以用2步的结果加两次「抵消操作」（选两次max(a_i)）。这样，当m很大时，直接取奇偶步的最大前缀值即可。
* 💡 **学习笔记**：前缀最大值是处理「大数值查询」的常用技巧——用小范围的结果覆盖大范围的情况。

**题解二：作者YellowBean_Elsa**
* **亮点**：用dp的视角表示最短路，状态转移更直观。
* **核心代码片段**：
    ```cpp
    // dp[i][p]：到达能力i的最小步数（p是奇偶性）
    memset(dp, 0x7f, sizeof(dp));
    dp[0][0] = 0;
    queue<int> q; q.push(0);
    while (!q.empty()) {
        int x = q.front(); q.pop();
        for (int i = 1; i <= n; ++i) {
            if (x < a[i]) {
                // 从x到x+a[i]，步数+1，奇偶性翻转
                if (dp[x+a[i]][0] > dp[x][1]+1) {
                    dp[x+a[i]][0] = dp[x][1]+1;
                    q.push(x+a[i]);
                }
                if (dp[x+a[i]][1] > dp[x][0]+1) {
                    dp[x+a[i]][1] = dp[x][0]+1;
                    q.push(x+a[i]);
                }
            } else {
                // 从x到x-a[i]，同理
                if (dp[x-a[i]][0] > dp[x][1]+1) {
                    dp[x-a[i]][0] = dp[x][1]+1;
                    q.push(x-a[i]);
                }
                if (dp[x-a[i]][1] > dp[x][0]+1) {
                    dp[x-a[i]][1] = dp[x][0]+1;
                    q.push(x-a[i]);
                }
            }
        }
    }
    ```
* **代码解读**：
    > 这段代码用队列维护「待处理的节点」，每次取出节点x，遍历所有a_i，计算x选a_i后的目标节点y，然后更新y的奇偶步数（步数+1，奇偶性翻转）。其实这和BFS是一样的，只是用「dp数组」代替了「dis数组」，更符合「动态规划」的思维习惯。
* 💡 **学习笔记**：最短路和动态规划是相通的——当状态转移的代价是1时，BFS就是「按层推进的DP」。

**题解三：作者ricky0916**
* **亮点**：预处理每个m的最大能力值，直接查询。
* **核心代码片段**：
    ```cpp
    // 预处理每个m（0~4000）的最大能力值
    for (int i = 4000; i >= 0; --i) {
        bool p = i % 2;
        for (int j = (mxx << 1) - 1; j >= 0; --j) {
            if (step[j][p] <= i) {
                mxxx[i] = j;
                break;
            }
        }
    }
    ```
* **代码解读**：
    > 这段代码从大到小遍历每个m（0到4000），对于每个m的奇偶性p，找最大的j（能力值），使得到达j的最小步数≤m且奇偶性为p。这样，查询时直接取mxxx[m]即可，非常高效。
* 💡 **学习笔记**：预处理是「以空间换时间」的经典技巧——对于多次查询，提前计算好所有可能的结果，查询时直接取答案。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家更直观地理解「奇偶BFS」的过程，我设计了一个**8位像素风的动画**——「能力值探险记」！结合复古游戏元素，让算法「动」起来~
</visualization_intro>

### 动画设计方案
#### 1. **整体风格**
- **8位像素风**：仿照FC红白机的画面（比如《超级马里奥》的像素块），用16色调色板（红、蓝、黄、绿等明亮颜色）；
- **场景设定**：屏幕左侧是「能力值地图」（网格状，每个格子代表一个能力值节点，比如0号节点在左上角），右侧是「控制面板」（开始/暂停、单步、重置按钮，速度滑块）；
- **背景音乐**：循环播放8位风格的轻快BGM（比如《俄罗斯方块》的主题曲）。

#### 2. **核心演示内容**
- **节点表示**：每个能力值节点是一个32×32的像素块，颜色表示状态：
  - 白色：未访问；
  - 蓝色：已访问（偶数步到达）；
  - 红色：已访问（奇数步到达）；
  - 黄色：当前处理的节点（BFS队列的 front）。
- **边表示**：节点之间的边用「像素箭头」连接（比如从节点0到节点a_i的箭头，颜色为绿色）；
- **队列表示**：BFS的队列用「排队的小像素人」展示（每个小人均代表一个队列元素，举着牌子显示节点号和奇偶性）。

#### 3. **动画步骤**
1. **初始化**：屏幕显示能力值地图（0号节点是黄色，其他是白色），队列里有一个小像素人（举着「0/偶」的牌子），控制面板显示「准备开始」。
2. **BFS第一步**：点击「开始」，队列中的小像素人（0/偶）走到0号节点，触发连边（比如a_i=1，0→1），1号节点变成红色（奇数步），并加入队列（小像素人举着「1/奇」）。播放「叮」的音效。
3. **BFS第二步**：队列中的下一个元素是1/奇，处理1号节点，连边到0（1≥1→0）或2（1<2→3？根据a数组而定），对应的节点变色并加入队列。播放「叮」的音效。
4. **奇偶性展示**：当处理到节点x时，用「文字气泡」提示：「当前是第k步（奇/偶），到达节点x！」。
5. **目标达成**：当BFS完成（队列空），播放「胜利」音效，所有已访问的节点闪烁，屏幕显示「BFS完成！」。
6. **查询演示**：输入m=3（奇数），动画会高亮所有「奇数步可达的节点」，并找到最大的那个（比如11），用「星星闪烁」标记。

#### 4. **交互设计**
- **单步执行**：点击「单步」，动画执行BFS的一步（处理队列中的一个元素）；
- **自动播放**：点击「自动」，动画按设定速度（可通过滑块调整）连续执行BFS；
- **重置**：点击「重置」，回到初始状态，重新开始；
- **算法比较**：（可选）如果有不同的建图方式（比如不去重a数组），可以并排展示两个动画，对比边数的差异。

#### 5. **为什么这样设计？**
- **像素风格**：复古游戏风让学习更轻松，唤起大家对经典游戏的回忆；
- **颜色标记**：用不同颜色区分奇偶步，直观看到「奇偶性复用」的规律；
- **音效反馈**：关键操作的音效强化记忆（比如「叮」对应边跳转，「胜利」对应BFS完成）；
- **交互控制**：单步和自动播放让大家可以「慢下来」观察细节，或「快进」看整体流程。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的「图论+奇偶性」思路可以迁移到很多问题中。比如：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：「加工零件」（P5663）：需要加工零件，每个零件需要经过若干工序，求第m步是否能完成某个零件——和本题一样，用奇偶BFS求最短路。
- **场景2**：「走迷宫」：迷宫中有障碍物，每步可以走上下左右，求第m步能到达的最远距离——同样可以用奇偶BFS，因为m步的位置取决于前m-1步的位置，奇偶性决定了下一步的位置。
- **场景3**：「字符串变换」：每个字符串可以通过规则变成另一个字符串，求第m次变换后的最大字符串——将字符串映射为节点，变换规则为边，用奇偶BFS处理大m。

### 洛谷练习推荐
1. **洛谷 P5663 [CSP-J2019] 加工零件**
   - 🗣️ **推荐理由**：和本题几乎一样的思路！用奇偶BFS求最短路，处理大m的查询，能直接巩固本题的知识点。
2. **洛谷 P7997 [WFOI - 01] 刷题**（本题）
   - 🗣️ **推荐理由**：再做一遍本题，尝试优化代码（比如去重a数组、预处理前缀最大值），加深理解。
3. **洛谷 P1144 最短路计数**
   - 🗣️ **推荐理由**：用BFS求最短路的计数问题，练习BFS的基本用法，为本题的奇偶BFS打基础。
4. **洛谷 P2661 [NOIP2015 提高组] 信息传递**
   - 🗣️ **推荐理由**：用BFS求最小环，练习图论的建模和BFS的应用，拓展思路。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我摘录了一些**宝贵的经验教训**，这些都是作者踩坑后的总结，值得我们借鉴：
</insights_intro>

> **经验1（来自Wf_yjqd）**：「写起来还是很出错的。」
> **点评**：这提醒我们，**边界条件要仔细检查**——比如建边时不要超过能力值上限（2×max(a_i)-1），否则会数组越界；BFS时不要重复访问同一个节点的同一个奇偶状态，否则会超时。

> **经验2（来自YellowBean_Elsa）**：「经历了NOIp2021的洗礼，看啥都像dp。」
> **点评**：这说明**模型转化的重要性**——很多问题看似不同，但本质是一样的（比如本题的最短路和dp）。多做类似题目，能提高「模型识别」的能力。

> **经验3（来自starrylasky）**：「实测跑的就慢那么亿点点。」
> **点评**：这提醒我们，**优化的重要性**——比如去重a数组可以减少边数，快读快写可以提高输入输出效率，预处理可以减少查询时间。这些小优化能让代码从「超时」变「AC」。


<conclusion>
本次关于「刷题」的C++解题分析就到这里。这道题的核心是**将问题转化为图论模型，用奇偶BFS处理大m**。希望这份指南能帮助大家理解「图论+奇偶性」的技巧，下次遇到类似问题时能快速想到解决方案！

记住：编程的乐趣在于「把复杂问题拆成简单步骤」，多思考、多练习，你一定会越来越厉害~ 💪
</conclusion>

---
处理用时：171.40秒
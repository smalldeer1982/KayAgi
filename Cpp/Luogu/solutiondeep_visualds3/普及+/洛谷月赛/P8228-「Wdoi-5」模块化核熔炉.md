# 题目信息

# 「Wdoi-5」模块化核熔炉

## 题目背景

为了通过使用核聚变获得能源，守矢神社在旧地狱修建了巨大的核融合控制中心。控制中心形如双层八卦炉，通过各种电路紧密地调控着核融合的精密运行。获得了八咫鸟力量的阿空会在核反应炉的中心点燃神火。

但是正八边形的八卦炉并不利于进行拓展与维护。为了方便地实现电路，河童打算对核控制中心进行模块化改造，以实现核熔炉的维护。具体而言，河童打算将核控制中心设计成由若干个正六边形组成的巨大结构。

![](https://cdn.luogu.com.cn/upload/image_hosting/ohyfxv02.png)

被赋予了神力的阿空可以依次激发其中的一些模块，而这些被激发的模块会快速影响到一定范围内的其他的模块。通过模块间的链接实现能量的产生。

但是因为阿空脑袋空空，由于它已经激发了多次模块，它已经记不清每个模块当中产生的核融合程度了。你能帮帮它吗？

## 题目描述

核控制中心可以看作由若干个正六边形模块组成的六边形阵列。阵列当中每个模块都可以储存核融合能量（一个非负整数）。左图就是一个核控制中心示意图。

![](https://cdn.luogu.com.cn/upload/image_hosting/78y7b98x.png)

我们使用如下方式对控制中心中每个模块进行标号。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ffz2m5o.png)

以阵列中心为原点延伸出三根射线作为三根轴，每两根轴之间的夹角为 $120\degree$。这三根轴将平面划分为了三个部分。每个模块都可以使用一个三元组 $(x,y,z)$ 描述它的坐标，表示从原点开始按如图所示的 $x,y,z$ 方向各走若干步之后到达的地方。为了防止出现多个坐标表示同一个模块的情况，做出如下规定：原点的坐标为 $(0,0,0)$；对于中心在坐标轴上的模块，它的坐标就是从原点向所在轴走过的距离；对于其他情况，我们将平面划分为了三个区域（如第二张图的红蓝绿三个区域），一个模块的坐标就是沿着它两侧的轴分别需要走的距离。例如模块 $P$ 的坐标为 $(2,4,0)$。容易发现，每个坐标唯一对应一个模块，一个模块唯一对应一个坐标。

同时定义，两个模块的**距离**为从一个模块到另一个模块需要经过模块（包括起点和终点）的最少个数。在第一张图中，红色部分的模块到其中心距离均不超过 $3$，绿色部分的模块到其中心距离均不超过 $3$，而蓝色部分的模块到其中心距离均不超过 $2$。

核控制中心可以视为到达原点距离不超过 $n$ 的模块组成的阵列。现在阿空会执行以下操作 $m$ 次：

- $\colorbox{f0f0f0}{\verb!x y z r k!}$ ：激活坐标为 $(x,y,z)$ 的模块。它会使控制中心中到它距离不超过 $r$ 的**所有**的模块的核融合能量增加 $k$。保证 $(x,y,z)$ 在控制中心当中。

现在需要求出，执行完 $m$ 个操作后，每个模块里核融合能量值。

## 说明/提示

样例 $2$ 见下发的附件 $\textbf{\textit{nuclear2.in/nuclear2.ans}}$。  
样例 $3$ 见下发的附件 $\textbf{\textit{nuclear3.in/nuclear3.ans}}$。满足特殊性质 $\text{A}$（见下文）。  
样例 $4$ 见下发的附件 $\textbf{\textit{nuclear4.in/nuclear4.ans}}$。满足特殊性质 $\text{B}$（见下文）。  
样例 $5$ 见下发的附件 $\textbf{\textit{nuclear5.in/nuclear5.ans}}$。

#### 样例 1 解释

如图所示（所有未标出数字的模块的核融合能量值均为 $0$）：

![](https://cdn.luogu.com.cn/upload/image_hosting/6y7bm2eb.png)



按照从左往右、从上往下的顺序依次输出每个数值，即可得到答案。

#### 数据范围及约定

本题共有 $20$ 个测试点，每个测试点 $5$ 分。最终分数为所有测试点分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Task} & \bm{n\le } & \bm{m\le} & \textbf{特殊性质} \cr\hline
1\sim 3 & 10 & 10 & \text{A} \cr\hline
4\sim 7 & 100 & 300 & - \cr\hline
8\sim 10 & 800 & 3\times 10^5 & \text{B} \cr\hline
11\sim 14 & 800 & 3\times 10^5 & \text{A} \cr\hline
15\sim 20 & 800 & 3\times 10^5 & - \cr\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证对于第 $i$ 次操作，被激活的模块到控制中心边缘上的模块的距离不小于 $r_i$。  
**特殊性质** $\textbf{B}$：保证对于第 $i$ 次操作，被激活的模块均为 $(0,0,0)$。

对于全部数据，保证 $n\le 800$，$m\le 3\times 10^5$，$1\le k_i\le 5\times 10^3$，$1\le r_i\le 10^9$。每次激活的模块都在控制中心里。

## 样例 #1

### 输入

```
4 3
0 1 1 3 4
3 0 3 3 3
1 0 0 2 2```

### 输出

```
4 4 4 0 4 4 4 4 3 4 4 4 4 7 3 0 4 4 6 9 3 3 0 4 6 6 5 3 0 0 2 2 3 0 0 0 0```

# AI分析结果

# 💡 Kay的C++算法解析：「Wdoi-5」模块化核熔炉 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（差分思想 + 坐标转换）

🗣️ **初步分析**：  
解决这道题的关键，是把「六边形区域加」这个“复杂操作”，通过**坐标转换**变成「矩形区域加」，再用**差分思想**快速处理。  

打个比方：如果我们要给作业本上的一段文字加批注，不需要逐行写“这里要加1”，只需要在这段文字的开头贴一张“从这里开始加1”的便签，结尾贴一张“到这里停止加1”的便签——最后翻书时，顺着便签的标记“展开”，就能快速得到所有行的批注结果。这就是**差分**的核心：用“标记边界”代替“逐点修改”，把多次区间操作的时间从O(区间大小)降到O(1)。  

但题目中的区域是**六边形**，直接用差分不好处理。于是我们需要**坐标转换**：把六边形网格“掰直”成两个斜坐标系（左系、右系），这样原本的六边形区域就变成了斜坐标系中的**矩形区域**。比如，左系中的一个矩形，对应原六边形中“向左倾斜的平行四边形”；右系中的矩形对应“向右倾斜的平行四边形”。两者结合，就能覆盖所有六边形区域的修改。  

**核心算法流程**：  
1. 把每个操作的六边形区域，拆成左系和右系中的两个矩形；  
2. 对这两个矩形分别做差分标记（修改4个边界点）；  
3. 所有操作完成后，对差分数组做**前缀和**（逆运算），恢复出最终的能量值；  
4. 把斜坐标系的结果转换回原六边形坐标，输出答案。  

**可视化设计思路**：  
我们会用**FC红白机风格的像素动画**展示这个过程：  
- 六边形网格用8位像素块表示，每个模块是16x16的彩色方块；  
- 操作时，高亮左系和右系的矩形区域（比如左系用蓝色，右系用红色），差分标记点用闪烁的黄色方块；  
- 前缀和过程中，像素块的颜色逐步变深（代表能量值增加），伴随“沙沙”的像素音效；  
- 完成后，所有模块的最终颜色对应能量值，播放“叮铃”的胜利音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个方面筛选了以下优质题解，帮你快速掌握核心技巧：
</eval_intro>

**题解一：来源：囧仙**  
* **点评**：这份题解把“差分+坐标转换”的思路讲得特别透彻！作者先用正方形网格的差分做类比，再一步步推导六边形的坐标转换公式（左系：`(x-z+n, y-x+n)`；右系：`(x-z+n, y-z+n)`），甚至配了图说明“平行四边形变矩形”的过程。代码也特别规范：用`cnv1`/`cnv2`函数封装坐标转换，用`A`/`B`数组分别处理两个系的差分，最后通过两次前缀和（行方向、列方向）恢复结果。尤其是边界处理（比如`min(k, v+r-1)`防止越界），体现了作者的严谨——这正是竞赛代码的关键！

**题解二：来源：zhongcy**  
* **点评**：这题解的亮点是“接地气”！作者直接用洛谷的二维差分模板题（P3397）做类比，让你立刻联想到“矩形加”的经典解法。代码和囧仙的思路完全一致，但变量名更简洁（比如`d=2*n-1`表示斜坐标系的大小），前缀和的循环顺序也写得很清楚：先按行累加，再按列反向累加。如果你刚学差分，这份代码的“直白性”会帮你快速上手。

**题解三：来源：WYXkk**  
* **点评**：虽然没写代码，但作者点出了一个关键——“六边形网格用斜坐标系更简单”！他提到把六边形拆成“横条+竖条”，用斜向差分处理，这和前两位作者的思路本质一致。如果你对“为什么要转坐标”还有疑问，看他的“斜坐标系”比喻（比如把六边形写成类似金字塔的形状），会瞬间明白！  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要是三个问题，结合优质题解的经验，我们一一突破：
</difficulty_intro>

1.  **难点1：如何理解六边形的坐标系统？**  
    * **分析**：题目中的`(x,y,z)`坐标是“三元组”，但其实满足`x+y+z=0`（比如原点是`(0,0,0)`，向x走一步是`(1,0,-1)`）。优质题解的做法是**忽略z**，用`x`和`y`间接表示z（因为`z=-x-y`），再转换成斜坐标系的二维坐标。比如左系的`x`是`x-z`（即`2x+y`），`y`是`y-x`——这样就把三元组变成了二维坐标。  
    * 💡 **学习笔记**：复杂坐标的核心是“找独立变量”，比如`x,y,z`中只有两个是独立的，所以能转成二维。

2.  **难点2：如何把六边形区域加拆成矩形加？**  
    * **分析**：六边形可以看成“两个方向的平行四边形叠加”——左系处理“向左斜的平行四边形”，右系处理“向右斜的平行四边形”。每个平行四边形在对应的斜坐标系中就是**矩形**，而矩形的差分只需要修改4个角点（比如`A[u][v+r-1] -=k`、`A[u-r+1][v+r-1] +=k`）。  
    * 💡 **学习笔记**：把复杂形状拆成“已知形状”（比如矩形），是算法题的常用技巧。

3.  **难点3：如何正确处理差分的边界？**  
    * **分析**：斜坐标系的大小是`2n-1`（比如n=4时，斜坐标系是7x7的网格），所以所有操作都要限制在`1~d`（d=2n-1）的范围内。比如`min(d, v+r-1)`防止超过右边界，`max(1, u-r+1)`防止低于左边界。如果不处理边界，会导致数组越界，结果错误。  
    * 💡 **学习笔记**：边界处理是代码“不WA”的关键，一定要养成“先判断范围”的习惯！

### ✨ 解题技巧总结
- **技巧1：差分思想**：用“边界标记”代替“逐点修改”，适合大量区间加操作；  
- **技巧2：坐标转换**：把复杂坐标系（比如六边形）转成已知坐标系（比如二维矩形），降低问题难度；  
- **技巧3：模块化编码**：把坐标转换、差分操作封装成函数（比如`cnv1`/`cnv2`），让代码更清晰。  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合囧仙和zhongcy的代码，提炼了一份**通用核心实现**，涵盖所有关键步骤：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码整合了“坐标转换+双差分+前缀和”的核心逻辑，变量名清晰，边界处理严谨，适合直接学习。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int MAXN = 1605; // 2*800+5，足够覆盖n=800的情况

    int n, m, d;
    ll A[MAXN][MAXN], B[MAXN][MAXN]; // 左系、右系的差分数组

    // 标准系转左系：(x,y,z) → (x-z + n, y-x + n)
    void cnv1(int x, int y, int z, int &u, int &v) {
        u = x - z + n;
        v = y - x + n;
    }

    // 标准系转右系：(x,y,z) → (x-z + n, y-z + n)
    void cnv2(int x, int y, int z, int &u, int &v) {
        u = x - z + n;
        v = y - z + n;
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0);

        cin >> n >> m;
        d = 2 * n - 1; // 斜坐标系的大小（比如n=4时，d=7）

        for (int i = 0; i < m; ++i) {
            int x, y, z, r, k;
            cin >> x >> y >> z >> r >> k;

            int u, v;
            // 处理左系的差分
            cnv1(x, y, z, u, v);
            A[u][min(d, v + r - 1)] -= k;
            A[max(1, u - r + 1)][min(d, v + r - 1)] += k;
            A[u][max(0, v - r)] -= k;
            A[min(d + 1, u + r)][max(0, v - r)] += k;

            // 处理右系的差分
            cnv2(x, y, z, u, v);
            B[u][min(d, v + r - 1)] += k;
            B[min(d + 1, u + r)][min(d, v + r - 1)] -= k;
            B[u][max(0, v - r)] += k;
            B[max(1, u - r + 1)][max(0, v - r)] -= k;
        }

        // 对A数组做前缀和：先按行累加（向下），再按列反向累加（向右）
        for (int i = 1; i <= d; ++i)
            for (int j = 1; j <= d; ++j)
                A[i][j] += A[i - 1][j];
        for (int i = 1; i <= d; ++i)
            for (int j = d; j >= 1; --j)
                A[i][j] += A[i][j + 1];

        // 对B数组做同样的前缀和
        for (int i = 1; i <= d; ++i)
            for (int j = 1; j <= d; ++j)
                B[i][j] += B[i - 1][j];
        for (int i = 1; i <= d; ++i)
            for (int j = d; j >= 1; --j)
                B[i][j] += B[i][j + 1];

        // 转换回标准系，输出结果
        for (int i = -n + 1; i <= n - 1; ++i) {
            for (int j = n - 1; j >= 1 - n + abs(i); --j) {
                int x = 0, y = j, z = 0;
                if (i < 0) z = -i;
                else x = i;
                int u1, v1, u2, v2;
                cnv1(x, y, z, u1, v1);
                cnv2(x, y, z, u2, v2);
                cout << A[u1][v1] + B[u2][v2] << " ";
            }
        }

        return 0;
    }
    ```
* **代码解读概要**：  
  1. **输入处理**：读取n（六边形大小）和m（操作次数）；  
  2. **差分标记**：对每个操作，转换坐标后修改A（左系）和B（右系）的4个边界点；  
  3. **前缀和恢复**：先按行累加（恢复行方向的差分），再按列反向累加（恢复列方向的差分）；  
  4. **结果输出**：把标准系的每个点转成左系和右系，累加A和B的值，输出最终能量。


<code_intro_selected>
接下来，我们看两个关键代码片段，理解核心逻辑：
</code_intro_selected>

**题解一（囧仙）：坐标转换函数**
* **亮点**：用函数封装坐标转换，避免重复代码，提高可读性。
* **核心代码片段**：
    ```cpp
    void cnv1(int a,int b,int c,int &x,int &y){  //左系
        x=a-c+n,y=b-a+n;
    }
    void cnv2(int a,int b,int c,int &x,int &y){  //右系
        x=a-c+n,y=b-c+n;
    }
    ```
* **代码解读**：  
  为什么要加`n`？因为斜坐标系的原点在原六边形的中心，而数组的索引从1开始（避免负数）。比如原坐标`(0,0,0)`转左系是`(0-0 +n, 0-0 +n) = (n,n)`，正好是数组的中间位置！  
* 💡 **学习笔记**：封装重复操作是写好代码的关键，比如坐标转换用函数，不用每次都写公式。

**题解二（zhongcy）：差分边界处理**
* **亮点**：用`min`/`max`严格限制边界，防止数组越界。
* **核心代码片段**：
    ```cpp
    a[p][min(d,q+r-1)]-=k;
    a[max(1,p-r+1)][min(d,q+r-1)]+=k;
    a[p][max(0,q-r)]-=k;
    a[min(d+1,p+r)][max(0,q-r)]+=k;
    ```
* **代码解读**：  
  比如`min(d, q+r-1)`：`q+r-1`是右系中矩形的右边界，但不能超过斜坐标系的大小`d`（否则数组越界）；`max(1, p-r+1)`是左边界，不能小于1。这些判断保证了差分操作只在有效范围内进行。  
* 💡 **学习笔记**：处理数组时，一定要先检查索引是否在合法范围内！  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到差分和坐标转换的过程，我设计了一个**FC红白机风格的像素动画**，像玩《超级马里奥》一样学算法！
</visualization_intro>

### **动画设计方案**
* **主题**：像素版“核熔炉操作员”——你是阿空，要在六边形网格中执行操作，看差分如何“魔法般”更新能量值。
* **风格**：8位像素风（类似《塞尔达传说：初代》），用16色 palette（比如蓝色代表左系矩形，红色代表右系矩形，黄色代表差分标记点）。
* **核心演示步骤**：

1. **场景初始化**：  
   - 屏幕显示一个7x7的六边形网格（n=4时），每个模块是16x16的像素块，中心模块（原点）是亮黄色；  
   - 下方有“操作列表”（显示当前要执行的`x y z r k`）和“控制面板”（单步、自动、重置按钮，速度滑块）；  
   - 播放8位风格的背景音乐（比如《星之卡比》的轻松BGM）。

2. **坐标转换演示**：  
   - 点击“操作1”（比如样例中的`0 1 1 3 4`），屏幕上弹出“坐标转换”提示框：  
     - 标准系`(0,1,1)` → 左系`(0-1+4=3, 1-0+4=5)`（n=4）；  
     - 标准系`(0,1,1)` → 右系`(0-1+4=3,1-1+4=4)`；  
   - 对应的左系和右系坐标在网格中用“闪烁的箭头”标记。

3. **差分标记演示**：  
   - 左系的矩形边界（比如`u=3, v=5`，r=3）用蓝色高亮，四个差分点（`(3,5+3-1=7)`、`(3-3+1=1,7)`、`(3,5-3=2)`、`(3+3=6,2)`）用黄色闪烁，并伴随“叮”的音效；  
   - 右系的矩形边界用红色高亮，同样标记差分点，音效变成“叮——”（更长的音调）。

4. **前缀和恢复演示**：  
   - 点击“开始前缀和”，网格中的模块颜色逐步变深：  
     - 首先按行累加：每一行从左到右，颜色从浅蓝变深蓝（代表A数组的累加）；  
     - 然后按列反向累加：每一列从右到左，颜色从深蓝变紫（代表A数组的最终值）；  
     - B数组的累加同理，颜色从浅红变深红，最后变成紫色+红色的混合色（代表A+B的总和）；  
   - 每一步累加都伴随“沙沙”的像素音效，完成时播放“叮铃”的胜利音效。

5. **结果展示**：  
   - 所有模块的颜色对应最终能量值（比如样例中的`4`是浅绿，`7`是深绿，`9`是红色）；  
   - 点击模块可以显示“标准系坐标”“左系/右系坐标”“能量值”，帮助你验证结果。

### **交互设计**
- **单步模式**：每点击一次“下一步”，执行一个差分或前缀和步骤，适合仔细观察；  
- **自动模式**：按设定的速度（滑块调节：慢/中/快）自动播放，适合看整体流程；  
- **重置**：回到初始状态，重新执行操作；  
- **算法比较**：可以切换“原六边形”和“斜坐标系”视图，对比两个坐标系的矩形区域。

<visualization_conclusion>
通过这个动画，你能直观看到“差分标记→前缀和恢复”的全过程，再也不用死记公式啦！就像玩游戏一样，操作几次就能记住坐标转换和差分的技巧～
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
差分和坐标转换的技巧，能解决很多“网格区间加”的问题。比如：
</similar_problems_intro>

### **通用思路迁移**
- **场景1**：正方形网格的矩形加（比如洛谷P3397）；  
- **场景2**：三角形网格的区间加（比如ACM竞赛中的“三角差分”）；  
- **场景3**：圆形网格的区间加（通过极坐标转换为矩形）。

### **洛谷练习推荐**
1.  **洛谷 P3397** - 地毯  
   * 🗣️ **推荐理由**：这是二维差分的“模板题”，帮你巩固“矩形加→差分标记→前缀和”的基础逻辑。  
2.  **洛谷 P4552** - [Poetize6] IncDec Sequence  
   * 🗣️ **推荐理由**：这题是一维差分的进阶，需要你思考“如何用最少的操作让数组变平”，锻炼差分的逆向思维。  
3.  **洛谷 P5024** - 保卫王国  
   * 🗣️ **推荐理由**：虽然是树型DP，但其中“子树区间加”的部分可以用差分优化，帮你拓展差分的应用场景。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“踩坑经验”，能帮你少走弯路：
</insights_intro>

> **参考经验（来自囧仙）**：“我一开始没处理斜坐标系的边界，导致数组越界，结果WA了三次。后来加上`min`/`max`判断，立刻就过了！”  
> **点评**：这是最常见的“低级错误”，但也是最容易忽略的。记住：**数组操作前，先检查索引范围**！  

> **参考经验（来自zhongcy）**：“坐标转换的公式一定要推导一遍，不能死记硬背。比如左系的`x = x-z +n`，其实是因为`z=-x-y`，所以`x-z = x - (-x-y) = 2x + y`，这样就不会忘啦！”  
> **点评**：推导公式能帮你理解“为什么要这样转”，而不是“记住这样转”——这才是真正掌握技巧的关键！  


<conclusion>
本次分析就到这里啦！这道题的核心是“用差分简化区间操作”+“用坐标转换简化形状”，只要掌握这两个技巧，类似的网格问题都能迎刃而解。记住：编程不是死记代码，而是“把复杂问题拆成简单问题”的思维——多练、多推导，你一定能成为“算法小能手”！💪
</conclusion>

---
处理用时：151.02秒
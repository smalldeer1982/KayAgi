# 题目信息

# Two Operations

## 题目背景

**本题时限较小，请采用较快的读入方式，以下是出题人提供的快读模板：**

```cpp
typedef long long LL;
inline LL read(){
	register LL x=0,f=1;
	char c=getchar();
	while(c<'0'||c>'9'){
		if(c=='-') f=-1;
		c=getchar();
	}
	while(c>='0'&&c<='9') x=(x<<3)+(x<<1)+(c^48),c=getchar();
	return x*f;
}
```

当然你也可以采用自己的读入方法。

## 题目描述

在一次聚会上，一共有 $n$ 名学生，他们的编号分别为 $1,2,3,\cdots,n$，他们被分成 $k$ 组，组的编号分别为 $1,2,3,\ldots,k$。

小 V 老师负责组织这场聚会，在聚会的开始，第 $i$ 名学生被分到了第 $a_i$ 组，并拿到了 $b_i$ 颗糖果。（小 V 既不属于任何组别，也没有任何糖果。在接下来的活动中，小 V 作为组织者的身份。） 

这一次聚会一共有 $m$ 轮活动，对于每一轮活动，可能发生以下两种情况之一：

1.  `Change X Y`，表示把所有组别为 $X$ 的学生的组别改为 $Y$（修改后 $X$ 即为空组），并把组 $X$ **删除**。
2.  `Query`，表示小 V 想要知道，如果把**剩下**的组合并（定义见下） 成一大组，那么这一大组内**拥有最多糖果的学生的糖果数最少可能是多少**。

定义一个组 $G_i$ 的大小就是这个组内含有学生的个数，记为 $S_i$。

**合并**：将大小为 $S_1(S_1>0)$ 的组 $G_1$ 合并到大小为 $S_2(S_2>0)$ 的组 $G_2$，其中 $G_1$ 组内所有学生拥有糖果数之和为 $f$，则：

1. 第一步，将原先 $G_1$ 中所有学生的糖果数都变为 $0$，并将他们的组别改为 $G_2$。
2. 第二步，将目前 $G_2$ 中每位学生（包括原先 $G_1$ 中的学生）的糖果数加上 $\dfrac{f}{S_1+S_2}$（糖果数不一定为整数块）。

**注意：**

1. $G_1$ 合并到 $G_2$ 的最后结果可能会与 $G_2$ 合并到 $G_1$ 的最后结果不同。
2. `Query` 中的合并不会真实发生。即在这一次情况过后，所有学生的糖果数与所在组与此次操作未发生前一致。

请将每次 `Query` 中的答案对 $10^9+7$ 取模。（可能是分数取模，如果不知道如何取模请见**提示说明**）

## 说明/提示

【样例解释】

第一次 `Query` 时，将第二组合并到第一组，此时三名学生的糖果数分别为 $\dfrac{14}{3},\dfrac{17}{3},\dfrac{5}{3}$，糖果数最多的同学有 $\dfrac{17}{3}$ 块糖果，取到了最小值，对 $10^9+7$ 取模后为 $666666677$。

第二次 `Query` 时，所有学生都在同一组，而糖果数最多的同学有 $5$ 块糖果。

---

【数据范围】

| 数据点 | $n$  | $m$  | $k$  | $a_i$ | $b_i$  |
| -----------: | -----------: | -----------: | -----------: | -----------: | -----------: |
| $1$ | $\le 10$ |无特殊限制 | $\le 10$ | $\le 10$ | $\le 100$ |
| $2$ | $\le 100$ | $\le 10$ | $\le 100$ | $\le 100$ | $\le 100$ |
| $3$ | $\le 10^5$ | $=1$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ |
| $4$ | $\le 10^5$ | 无特殊限制 | $=1$ | $=1$ | $\le10^5$ |
| $5$ | $\le 10^3$ |无特殊限制 | $\le 5$ | $\le 5$ | $\le 100$ |
| $6$ | $\le 10^4$ | $\le 10^3$ | $\le 10^4$ | $\le 10^4$ | $\le 10^5$ |
| $7$ | $\le 10^4$ | $\le 5\times10^3$ | $\le 10^4$ | $\le 10^4$ | $\le 10^5$ |
| $8$ | $\le 10^5$ | 无特殊限制 | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ |
| $9 $| $\le 5\times10^5$ | 无特殊限制 | $5\times10^5$ | $5\times10^5$ | $\le 10^5$ |
| $10$ | $\le 10^6$ | 无特殊限制 | $\le 10^6$ | $\le 10^6$ | $\le 10^5$ |

对于 $100\%$ 的数据，满足 $1 \leq n \leq 10^6,\ 1\leq m \leq 2\times k-1,\ 1 \leq a_i\leq k \leq n,\ 1 \leq b_i \leq 10^5$。**数据保证合法，初始时每组是非空的。**


不熟悉有理数取模的请看[此处](/problem/solution/P2613)。


## 样例 #1

### 输入

```
3 3 2
1 1 2
3 4 5
Query
Change 2 1
Query```

### 输出

```
666666677
5```

# AI分析结果

# 💡 Kay的C++算法解析：Two Operations 深入学习指南 💡

<introduction>
今天我们来一起分析「Two Operations」这道C++编程题。这道题的核心是**通过数学推导简化问题**，再用合适的数据结构高效维护关键值。本指南会帮你理清题目本质、掌握核心公式，以及如何用优先队列或线段树解决动态更新问题～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（核心是「数学推导+数据结构维护」，用优先队列/线段树处理动态最小值查询）

🗣️ **初步分析**：
解决这道题的关键，是先**把复杂的合并问题转化为简单的数学公式**，再用数据结构高效维护结果。  
简单来说：题目中的「合并所有组」其实不用真的模拟——不管合并顺序如何，**合并到组G_i后的最大糖果数**只和G_i的两个属性有关：  
- `v_i`：G_i原本的最大糖果数（因为合并时G_i的原有学生不会被清空，他们的糖果是最大的基础）；  
- `f_i`：G_i的糖果总和（总糖果`sum`减去`f_i`，就是其他组要「分摊」给所有人的糖果）。  

推导后得到**核心公式**：  
$$w_i = v_i + \frac{sum - f_i}{n}$$  
其中`n`是总学生数（固定不变！）。`Query`的答案就是所有**非空组**的`w_i`的最小值～  

接下来的问题就变成了：如何高效维护这些`w_i`，并处理「Change X Y」（合并X组到Y组，删除X组）的更新？  
- 对于`Change`操作：合并X到Y后，Y的`v_y`会变成`max(v_x, v_y)`（两组的原最大值取最大），`f_y`会变成`f_x + f_y`（两组糖果总和相加）。此时X组被删除，不再参与后续查询。  

**核心算法流程**：  
1. 初始化每个组的`v_i`（组内最大糖果）、`f_i`（组内糖果总和）；  
2. 计算每个组的`w_i`（用核心公式）；  
3. 用**优先队列**或**线段树**维护所有`w_i`的最小值；  
4. 处理`Change`操作：更新Y组的`v`和`f`，标记X组为无效，将Y组的新`w_i`加入数据结构；  
5. 处理`Query`操作：直接查询数据结构中的最小值，再按模运算规则输出。  

**可视化设计思路**：  
我们会用「8位像素风」模拟组的合并和查询：  
- 用不同颜色的像素块代表不同的组，块的大小表示组的人数，块上显示`v_i`和`f_i`；  
- 合并X到Y时，X的像素块「融化」到Y的块中，Y的块颜色变深（表示`v`增大），同时显示新的`v`和`f`；  
- 查询时，所有组的块会「跳动」，最小`w_i`的块会闪烁并播放「叮」的音效；  
- 支持「单步执行」和「自动播放」，让你清楚看到每一步的变化～


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、算法有效性」三个维度筛选了3份优质题解，帮你从不同角度理解问题～
</eval_intro>

**题解一：优先队列维护最小值（作者：Anxiomgh）**  
* **点评**：这份题解的思路非常「接地气」——用优先队列（大根堆）维护所有`w_i`，但巧妙用`flag`数组标记「无效组」（被合并的组）。当处理`Query`时，先弹出队列中所有无效的`w_i`，剩下的队头就是最小值。代码中的`w_i`用「通分」后的形式（`v_i * n + sum - f_i`）避免浮点数运算，非常严谨。亮点是**用优先队列处理动态最小值**，即使有无效值也能快速过滤，适合刚学优先队列的同学～

**题解二：数学推导奠定基础（作者：gyc18，官方题解）**  
* **点评**：官方题解的核心是**证明合并顺序不影响结果**——不管怎么合并，只要最后合并到G_i，结果都是`v_i + (sum - f_i)/n`。这个证明直接把复杂的「合并顺序问题」简化成了「求每个组的`w_i`最小值」，是所有解法的基础。虽然没有给出具体代码，但帮我们抓住了问题的本质，非常重要～

**题解三：线段树高效维护（作者：qiucr）**  
* **点评**：这份题解用线段树维护所有`w_i`的最小值，实现非常简洁！`Change`操作时，把X组的`w_i`改成「无穷大」（标记为无效），再更新Y组的`w_i`；`Query`时直接查线段树的根节点（全局最小值）。线段树的「单点修改+区间查询」完美匹配本题的需求，代码量少且易读，是**工程化的优选方案**～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的「难点」其实是「如何把问题简化」——从复杂的合并规则中推导出核心公式，再选择合适的数据结构。下面帮你拆解三个关键问题：
</difficulty_intro>

1.  **关键点1：为什么合并顺序不影响结果？**  
    * **分析**：不管先合并A到B，还是先合并B到A，最终合并到G_i的结果都是`v_i + (sum - f_i)/n`。因为总糖果`sum`和总人数`n`是固定的，`v_i`是G_i的原最大值（合并时不会被清空），而其他组的糖果会被「平均分摊」给所有人。官方题解的证明帮我们跳过了「模拟合并」的坑，直接聚焦到`w_i`的计算。  
    * 💡 **学习笔记**：遇到复杂规则时，先尝试「数学建模」，把问题转化为可计算的公式！

2.  **关键点2：如何选择数据结构？**  
    * **分析**：本题需要「动态维护最小值+单点更新」，可选的结构有两种：  
      - 优先队列：适合「插入多、查询少」的场景，但需要处理「无效值」（用`flag`数组标记）；  
      - 线段树：适合「频繁更新+频繁查询」的场景，代码更直接，但需要掌握线段树的基本操作。  
    * 💡 **学习笔记**：根据问题的「操作类型」选数据结构——动态最小值优先考虑优先队列或线段树！

3.  **关键点3：如何处理Change操作？**  
    * **分析**：合并X到Y时，需要做三件事：  
      1. 更新Y组的`v`（取`max(v_x, v_y)`）和`f`（`f_x + f_y`）；  
      2. 标记X组为无效（优先队列用`flag`，线段树设为无穷大）；  
      3. 将Y组的新`w_i`加入数据结构（优先队列push新值，线段树修改Y的位置）。  
    * 💡 **学习笔记**：处理动态操作时，「标记无效」比「删除元素」更高效！


### ✨ 解题技巧总结
- **技巧1：数学建模简化问题**：先推导核心公式，避免模拟复杂的合并过程；  
- **技巧2：通分避免浮点数**：用`v_i * n + sum - f_i`代替`w_i`，防止精度误差；  
- **技巧3：选择合适的数据结构**：优先队列（处理无效值）或线段树（直接维护），根据需求选；  
- **技巧4：模运算处理分数**：分数取模用「逆元」——`(a/b) mod p = a * inv(b) mod p`，其中`inv(b)`是b的模p逆元（用快速幂计算）。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**基于线段树的通用核心实现**——它兼顾了代码简洁性和效率，适合大多数场景～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解三的线段树思路，用「通分」后的`w_i`（`n*v_i + sum - f_i`）避免浮点数，线段树维护全局最小值。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int MAXN = 2e6 + 10;
    const ll MOD = 1e9 + 7;
    const ll INF = 1e18;

    // 线段树结构：维护区间最小值
    struct Node {
        int l, r;
        ll min_val;
    } tree[MAXN * 4];

    ll n, m, k, sum_total; // sum_total是总糖果数
    ll v[MAXN], f[MAXN], w[MAXN]; // v[i]组i的最大糖果，f[i]组i的总和，w[i]通分后的w_i

    // 快读模板（题目要求）
    inline ll read() {
        ll x = 0, f = 1;
        char c = getchar();
        while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
        while (c >= '0' && c <= '9') x = (x << 3) + (x << 1) + (c ^ 48), c = getchar();
        return x * f;
    }

    // 快速幂求逆元
    ll qpow(ll a, ll b) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    // 线段树pushup：合并左右子节点的最小值
    void pushup(int u) {
        tree[u].min_val = min(tree[u << 1].min_val, tree[u << 1 | 1].min_val);
    }

    // 线段树构建：初始化每个叶子节点的w[i]
    void build(int u, int l, int r) {
        tree[u].l = l, tree[u].r = r;
        if (l == r) {
            tree[u].min_val = w[l];
            return;
        }
        int mid = (l + r) >> 1;
        build(u << 1, l, mid);
        build(u << 1 | 1, mid + 1, r);
        pushup(u);
    }

    // 线段树单点修改：将位置x的值改为val
    void modify(int u, int x, ll val) {
        if (tree[u].l == tree[u].r) {
            tree[u].min_val = val;
            return;
        }
        int mid = (tree[u].l + tree[u].r) >> 1;
        if (x <= mid) modify(u << 1, x, val);
        else modify(u << 1 | 1, x, val);
        pushup(u);
    }

    int main() {
        n = read(), m = read(), k = read();
        vector<ll> a(n + 1), b(n + 1); // a[i]是学生i的组号，b[i]是学生i的糖果
        for (int i = 1; i <= n; ++i) a[i] = read();
        for (int i = 1; i <= n; ++i) b[i] = read();

        // 初始化每个组的v[i]（最大糖果）和f[i]（总和）
        memset(v, 0, sizeof(v));
        memset(f, 0, sizeof(f));
        sum_total = 0;
        for (int i = 1; i <= n; ++i) {
            ll group = a[i];
            v[group] = max(v[group], b[i]);
            f[group] += b[i];
            sum_total += b[i];
        }

        // 计算每个组的w[i]（通分后：n*v[i] + sum_total - f[i]）
        for (int i = 1; i <= k; ++i) {
            w[i] = v[i] * n + (sum_total - f[i]);
        }

        // 构建线段树
        build(1, 1, k);

        // 预处理n的逆元（因为w_i = (n*v[i] + sum_total - f[i]) / n）
        ll inv_n = qpow(n, MOD - 2);

        while (m--) {
            char op[10];
            scanf("%s", op);
            if (op[0] == 'Q') { // Query操作：查询全局最小值
                ll min_w = tree[1].min_val;
                ll ans = min_w % MOD * inv_n % MOD;
                printf("%lld\n", ans);
            } else { // Change X Y操作：合并X到Y
                ll X = read(), Y = read();
                // 更新Y组的v和f
                v[Y] = max(v[X], v[Y]);
                f[Y] += f[X];
                // 标记X组为无效（w[X]设为INF）
                modify(1, X, INF);
                // 计算Y组的新w[i]，并更新线段树
                ll new_w = v[Y] * n + (sum_total - f[Y]);
                modify(1, Y, new_w);
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    1. **输入处理**：用快读读取数据，初始化每个组的`v`（最大糖果）和`f`（总和）；  
    2. **计算w[i]**：用通分后的公式`v[i] * n + sum_total - f[i]`，避免浮点数；  
    3. **构建线段树**：每个叶子节点对应一个组的`w[i]`，维护全局最小值；  
    4. **处理操作**：  
       - `Query`：查线段树的根节点（全局最小值），用逆元计算分数取模；  
       - `Change`：更新Y组的`v`和`f`，标记X组为无效（设为INF），更新Y组的`w[i]`。


---

<code_intro_selected>
接下来我们看**题解一的优先队列片段**——它展示了如何用优先队列处理无效值～
</code_intro_selected>

**题解一：优先队列实现（来源：Anxiomgh）**
* **亮点**：用优先队列维护`w[i]`，用`flag`数组标记无效组，巧妙过滤过期值。
* **核心代码片段**：
    ```cpp
    struct Item {
        ll pos; // 组的编号
        ll val; // 通分后的w[i]
        bool operator<(const Item& x) const {
            return x.val < val; // 大根堆（优先队列默认是大根堆，所以用x.val < val实现小根堆效果？不，等一下——C++的优先队列是「最大堆」，所以这个operator<会让val小的元素排在前面！因为当x.val < val时，当前元素的优先级比x低，所以优先队列会先弹出val小的元素～）
        }
    };
    priority_queue<Item> q;
    bool flag[MAXN]; // flag[pos]为true表示该组已被合并，无效

    // 处理Query操作
    while (flag[q.top().pos]) { // 弹出所有无效的队头元素
        q.pop();
    }
    ll min_w = q.top().val;
    ll ans = min_w % MOD * inv_n % MOD;
    printf("%lld\n", ans);

    // 处理Change操作
    ll X = read(), Y = read();
    v[Y] = max(v[X], v[Y]);
    f[Y] += f[X];
    if (v[Y] == v[X]) { // Y的最大值来自X，标记原来的Y的pos为无效
        flag[fa[Y]] = true;
        fa[Y] = fa[X];
    } else { // Y的最大值不变，标记X的pos为无效
        flag[fa[X]] = true;
    }
    ll new_w = v[Y] * n + (sum_total - f[Y]);
    q.push({fa[Y], new_w}); // 将Y的新w[i]加入队列
    ```
* **代码解读**：
    - **优先队列的排序逻辑**：`operator<`定义为「x.val < val」，这样优先队列会把`val`小的元素放在队头（因为当x的val更小，x的优先级更高）；  
    - **处理无效值**：`Query`时，先弹出所有`flag[pos]`为true的队头元素（这些组已经被合并，无效），剩下的队头就是当前的最小值；  
    - **Change操作**：合并X到Y后，更新Y的`v`和`f`，标记无效的组（X或Y原来的pos），然后将Y的新`w[i]`加入队列。  
* 💡 **学习笔记**：优先队列处理动态最小值时，「标记无效+延迟删除」是常用技巧！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地理解「合并组」和「查询最小值」的过程，我设计了一个**8位像素风的动画**——像玩FC游戏一样学算法！
</visualization_intro>

### **动画演示主题**：《像素组的合并大冒险》
**风格**：仿FC红白机的8位像素风，用「砖块+数字」表示组，颜色鲜艳（比如红色组、蓝色组），背景是简单的网格。  
**核心演示内容**：展示`Change`合并组和`Query`找最小值的过程，融入「音效+动画」增强记忆。


### **设计思路简述**
- **像素风格**：用16x16的像素块代表组，块的颜色区分不同组，块上显示`v_i`（最大糖果）和`f_i`（总和）；  
- **动画逻辑**：合并时X的块「滑向」Y的块，融合后Y的块变大（表示人数增加），颜色变深（表示`v`增大）；查询时所有块「跳动」，最小`w_i`的块闪烁并播放「叮」的音效；  
- **交互设计**：支持「单步执行」（点击「下一步」看每一步变化）、「自动播放」（调速滑块控制速度）、「重置」（回到初始状态）。


### **动画帧步骤与交互关键点**
1. **初始化场景**：  
   - 屏幕左侧显示所有组的像素块（比如初始有2个组：红色块`v=4, f=7`，蓝色块`v=5, f=5`）；  
   - 右侧是「控制面板」：有「开始/暂停」「单步」「重置」按钮，以及「速度滑块」（从1x到5x）；  
   - 底部显示「总糖果sum=12」「总人数n=3」（对应样例输入）。

2. **第一次Query操作**：  
   - 所有组的块开始「轻微跳动」，同时计算每个块的`w_i`（红色块`w=4*3 + (12-7)=12+5=17`，蓝色块`w=5*3 + (12-5)=15+7=22`）；  
   - 红色块（`w=17`更小）开始「快速闪烁」，伴随「叮」的音效；  
   - 屏幕上方弹出文字：「当前最小值是17，模运算后是666666677！」（对应样例输出）。

3. **Change 2 1操作（合并蓝色组到红色组）**：  
   - 蓝色块（组2）开始「缓慢滑向」红色块（组1）；  
   - 融合时，红色块的颜色变深（`v`从4变成5），块上的数字更新为`v=5, f=12`；  
   - 蓝色块消失，屏幕左侧显示「组2已删除」的提示；  
   - 线段树/优先队列的状态同步更新（红色组的`w_i`变为`5*3 + (12-12)=15`）。

4. **第二次Query操作**：  
   - 只剩红色块，直接闪烁并播放「叮」的音效；  
   - 屏幕上方弹出文字：「当前最小值是15，模运算后是5！」（对应样例输出）。


### **游戏化元素**
- **音效**：合并时播放「咻」的滑动声，查询时播放「叮」的提示声，成功时播放「胜利」的短音乐；  
- **关卡设计**：把样例分成「初始查询」「合并组」「最终查询」三个小关卡，完成每个关卡会获得「像素星星」奖励；  
- **AI演示**：点击「AI自动玩」，动画会自动执行所有操作，像「贪吃蛇AI」一样展示解题过程。


<visualization_conclusion>
通过这个动画，你可以**「看得到」**组的合并过程，**「听得到」**关键操作的提示，**「玩得到」**算法的执行逻辑——再也不用死记硬背公式啦！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心技巧是「数学建模+数据结构维护动态最小值」，能解决很多类似的问题～
</similar_problems_intro>

### **通用思路迁移**
- **场景1**：动态维护数组的最小值（比如「添加元素+删除元素+查询最小值」）；  
- **场景2**：合并集合并维护集合的某个属性（比如「合并两个堆，维护堆的最小值」）；  
- **场景3**：处理带修改的查询问题（比如「修改数组中的某个元素，查询区间最小值」）。


### **洛谷练习推荐**
1.  **洛谷 P1886** - 滑动窗口  
    * 🗣️ **推荐理由**：这道题要维护滑动窗口内的最小值，和本题的「动态最小值」思路一致，能帮你巩固优先队列/线段树的应用！

2.  **洛谷 P3372** - 线段树模板 1  
    * 🗣️ **推荐理由**：线段树的基础模板题，练习「区间修改+区间查询」，帮你熟悉线段树的实现细节！

3.  **洛谷 P1198** - [JSOI2008] 最大数  
    * 🗣️ **推荐理由**：这道题要维护动态数组的最大值，和本题的「动态最小值」互为补充，能帮你举一反三！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的「小技巧」能帮我们少走很多弯路，比如：
</insights_intro>

> **参考经验 (来自Anxiomgh)**：「本蒟蒻不会写multiset，于是写了一发优先队列（逃）。」  
> **点评**：这位作者的经验很真实——当遇到「维护动态最小值」时，如果不会用multiset（C++的有序集合），优先队列是很好的替代方案！只要用「标记无效+延迟删除」的技巧，就能实现同样的功能。  

> **参考经验 (来自qiucr)**：「这道题竟然没有人用线段树来写，感觉线段树写法还是比较简单的。」  
> **点评**：线段树的「单点修改+区间查询」完美匹配本题的需求，代码量少且易读。如果你已经学过线段树，这道题是很好的练习机会！


<conclusion>
本次关于「Two Operations」的分析就到这里啦！这道题的核心是**用数学推导简化问题**，再用数据结构高效维护结果。记住：遇到复杂规则时，先尝试「数学建模」；选择数据结构时，先想「需要哪些操作」（比如本题需要「动态更新+查询最小值」）。  
下次遇到类似的问题，你一定能快速解决！💪
</conclusion>

---
处理用时：165.31秒
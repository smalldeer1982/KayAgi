# 题目信息

# 「SWTR-8」15B03

## 题目背景

15B03 获得了 ION2064 的承办权。

## 题目描述

15B03 的座位非常拥挤，可以看成一张 $n\times m$ 的网格，每个小正方形 $(i, j)$ 代表一张桌子。

根据规定，考场上任何两张桌子不得相邻。这里相邻指含有 **公共点**。严格定义两张桌子 $(i, j)$ 和 $(i', j')$ 相邻当且仅当 $|i - i'|\leq 1$ 且 $|j - j'|\leq 1$。

布置考场的任务落在小 A 头上，他希望撤去最少的桌子满足上述要求。

小 A 认为这样太简单了，因此他添加了限制：在保证撤去桌子最少的前提下，最大化剩余每张桌子到距离它最远的桌子的距离之和。这里距离指 **欧几里得** 距离：桌子 $(a, b)$ 和 $(c, d)$ 的距离为 $\sqrt{(a - c) ^ 2 + (b - d) ^ 2}$。

平行时空中 15B03 的规模不尽相同：多组测试数据。

**请选手认真阅读本题的评分方式。**

## 说明/提示

**「样例解释」**

对于第一组询问，选择 $(1, 1), (1, 3), (3, 1)$ 和 $(3, 3)$ 最优。撤去了 $3\times 3 - 4 = 5$ 张桌子，且每张桌子到距离它最远的桌子的距离均为 $\sqrt{2 ^ 2 + 2 ^ 2} = 2\sqrt 2$，因此第二问答案为 $8\sqrt 2$。如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/y8fi4qhr.png)

对于第二组询问，选择 $(1, 1)$ 和 $(2, 4)$ 最优。撤去了 $2\times 4 - 2 = 6$ 张桌子，且每张桌子到距离它最远的桌子的距离均为 $\sqrt{1 ^ 2 + 3 ^ 2} = \sqrt {10}$，因此第二问答案为 $2\sqrt {10}$。

如果选择 $(1, 1)$ 和 $(2, 3)$，则第二问答案为 $2\sqrt 5$，不优。

**「评分方式」**

对于每组测试数据：

- 若你第一问的答案错误，得 0 分。
- 否则，若你第二问的答案错误，得 0.8 分。
- 否则，得 1 分。

每个测试点的得分为测试点内所有测试数据的得分的最小值乘以该测试点的分值。

注意，**若你输出的格式错误，得 0 分**。因此，如果你只希望获得第一问的分数，请在第二问输出任意合理范围内的实数。

**「数据范围与约定」**

- 测试点 #1（15 points）：$n, m$ 均为奇数。
- 测试点 #2（20 points）：$n = 1$。
- 测试点 #3（25 points）：$n = 2$。
- 测试点 #4（30 points）：$n$ 为奇数。
- 测试点 #5（10 points）：无特殊限制。

对于 $100\%$ 的数据：

- $1\leq T\leq 57$。
- $1\leq n, m\leq 1064$。

**「帮助与提示」**

- 你可以使用 `cmath` 中的 `sqrt(x)` 函数计算 $x$ 的平方根。它返回 `double` 类型的值。`sqrtl(x)` 精度更高，它返回 `long double` 类型的值。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) A
- Idea & Solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。
- Tester：[chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
4
3 3
2 4
15 57
1064 822```

### 输出

```
5 11.313708499
6 6.324555320
623 10206.135788972
655956 222400384.677931725
```

# AI分析结果

# 💡 Kay的C++算法解析：「SWTR-8」15B03 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法（Greedy Algorithm）


🗣️ **初步分析**：  
解决「15B03」的关键是**贪心策略**——**第一问用“最大化保留”贪最少撤去，第二问用“尽量分散”贪最大距离和**。  

贪心算法的核心像“捡芝麻”：每次选当前最划算的选项，不纠结未来。比如妈妈让你挑最少的糖留着（第一问），你会先挑最大的糖；如果还要让糖之间离得最远（第二问），你会把糖摆到盘子的四个角落。  

### 第一问的贪心逻辑  
要让撤去的桌子最少，就得**尽可能多留桌子**。由于桌子不能八连通（即周围8格不能有其他桌子），最优方式是**隔行隔列放桌子**——比如从(1,1)开始，每行只在奇数列放，每列只在奇数行放。这样保留的桌子数是 $\left\lceil \frac{n}{2} \right\rceil \times \left\lceil \frac{m}{2} \right\rceil$（$\lceil x \rceil$ 表示向上取整），撤去的数量就是总数减去这个值。  

### 第二问的贪心逻辑  
要让剩余桌子的“最远距离之和”最大，得让每个桌子**尽量靠近网格的角落**。因为一个点的最远点一定是四个角落中的一个（比如左上角的点最远是右下角）。当n或m是偶数时，后半部分的桌子要**往边缘挪一格**（比如n=4时，第3行的桌子移到第4行），这样能拉远与对角的距离。  

### 可视化设计思路  
我会用**8位像素风格**做动画：  
- 网格用黑白像素块表示，桌子用彩色方块（比如红色），角落用金色标记。  
- 动画步骤：① 初始化网格（灰色背景）；② 隔行隔列放红色桌子（伴随“叮”的音效）；③ 调整偶数行列的桌子位置（比如n=4时，第3行的桌子“滑”到第4行，伴随“唰”的音效）；④ 每个桌子向最远角落发射“光线”（蓝色虚线），并显示距离值；⑤ 最后累加所有距离，显示总和（伴随“胜利”音效）。  
- 交互：支持“单步执行”（看每一步怎么放桌子）、“自动播放”（调速滑块）、“重置”（回到初始状态）。  


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码可读性、算法有效性三个维度筛选了4份优质题解，它们能帮你快速掌握核心逻辑：  
</eval_intro>


### 题解一：封禁用户（赞：8）  
* **点评**：这份题解的代码**极简且精准**！第一问直接用 `(n+1)/2*(m+1)/2` 计算保留数（整数除法自动向上取整），第二问通过调整偶数行列的桌子位置（`if (n%2==0 && i>n/2) I++;`），让桌子更靠近边缘。最棒的是用 `hypot` 函数直接计算欧几里得距离（不用自己写平方根），代码可读性拉满。


### 题解二：Alex_Wei（赞：2，官方题解）  
* **点评**：作为出题人的题解，**正确性和权威性拉满**！第一问的证明很清晰（每个2×2网格最多放1张桌子，所以保留数是上界），第二问的构造方法（奇数行/列固定，偶数行/列后半部分挪位）直接点出问题本质。代码中的 `(n+1>>1)` 是位运算技巧（等价于 `(n+1)/2`），很高效。


### 题解三：BotDand（赞：1）  
* **点评**：这份题解的**图辅助理解**超棒！用四张图展示了偶数行列的调整过程（比如把蓝色区块向下移、绿色区块向右移），帮你直观看到“为什么要挪桌子”。代码中的 `Max` 函数封装了取最大距离的逻辑，很简洁。


### 题解四：Cure_Wing（赞：0）  
* **点评**：这份题解**分测试点拆解问题**，适合新手逐步理解！比如先讲n/m均为奇数的情况，再讲偶数的情况，最后特判只有1张桌子的情况。代码中的 `O` 函数封装了距离计算，注释详细，很适合模仿。


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决这道题的核心难点有3个，我帮你提炼了应对策略：  
</difficulty_intro>


### 1. 如何最大化保留桌子？  
**难点**：一开始可能想不通“为什么隔行隔列放是最优的”。  
**策略**：想小例子——比如3×3网格，放(1,1)、(1,3)、(3,1)、(3,3)，刚好4张，这是最多的（再放任何一张都会八连通）。推广到n×m，就是奇数行×奇数列。  
💡 **学习笔记**：贪心的关键是“找当前最优的模式”，这里的模式是“隔行隔列”。


### 2. 如何调整偶数行列的桌子位置？  
**难点**：当n是偶数时（比如n=4），原来的奇数行是1、3，但是第3行的桌子可以挪到第4行，这样离对角更远。  
**策略**：判断行/列是否为偶数，如果是，且当前行/列超过一半（比如n=4，i>2），就把桌子挪到下一行/列（i++）。  
💡 **学习笔记**：偶数的“额外空间”要用来拉远距离，这是第二问的核心技巧。


### 3. 特判只有1张桌子的情况  
**难点**：当n≤2且m≤2时（比如1×1、2×2），保留的桌子只有1张，最远距离是0，但容易忘记特判。  
**策略**：在计算第二问前，先判断 `n<=2 && m<=2`，如果是，直接输出0。  
💡 **学习笔记**：边界条件是算法的“细节杀”，一定要提前考虑。


### ✨ 解题技巧总结  
- **技巧1**：用整数除法代替向上取整——`(n+1)/2` 等价于 $\lceil n/2 \rceil$（比如n=4时，(4+1)/2=2.5？不，C++里整数除法会向下取整，所以(4+1)/2=2？不对，等一下，n=4时，$\lceil 4/2 \rceil=2$，(4+1)/2=2（整数除法），是对的；n=5时，(5+1)/2=3，刚好是$\lceil 5/2 \rceil=3$。哦，原来如此！  
- **技巧2**：用`hypot`函数计算欧几里得距离——`hypot(x1-x2, y1-y2)` 等于 $\sqrt{(x1-x2)^2 + (y1-y2)^2}$，比自己写更简洁。  
- **技巧3**：封装重复逻辑——比如把距离计算写成函数，避免重复代码。


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一个**通用核心实现**，它整合了优质题解的思路，覆盖所有情况：  
</code_intro_overall>


### 本题通用核心C++实现参考  
* **说明**：综合了封禁用户、Alex_Wei、BotDand的思路，代码简洁且覆盖所有边界条件。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;

int main() {
    int S, T;
    cin >> S >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        // 第一问：计算撤去的桌子数
        int keep = (n + 1) / 2 * (m + 1) / 2;
        cout << n * m - keep << " ";
        
        // 第二问：计算最大距离和
        if (n <= 2 && m <= 2) {
            cout << "0.000000000" << endl;
            continue;
        }
        double sum = 0.0;
        for (int i = 1; i <= n; i += 2) {
            for (int j = 1; j <= m; j += 2) {
                int I = i, J = j;
                // 调整偶数行列的桌子位置
                if (n % 2 == 0 && i > n / 2) I++;
                if (m % 2 == 0 && j > m / 2) J++;
                // 计算到四个角落的最大距离
                double d1 = hypot(I - 1, J - 1);    // 左上(1,1)
                double d2 = hypot(I - 1, J - m);    // 右上(1,m)
                double d3 = hypot(I - n, J - 1);    // 左下(n,1)
                double d4 = hypot(I - n, J - m);    // 右下(n,m)
                sum += max(max(d1, d2), max(d3, d4));
            }
        }
        cout << fixed << setprecision(9) << sum << endl;
    }
    return 0;
}
```  
* **代码解读概要**：  
  1. 第一问：用`(n+1)/2*(m+1)/2`计算保留的桌子数，总数减去这个值就是撤去的数量。  
  2. 第二问：  
     - 特判只有1张桌子的情况，输出0。  
     - 循环遍历所有保留的桌子（隔行隔列）。  
     - 调整偶数行列的桌子位置（比如n=4时，i=3>2，I变成4）。  
     - 计算每个桌子到四个角落的最大距离，累加到sum中。  


<code_intro_selected>  
接下来剖析优质题解的**核心片段**，看它们的亮点：  
</code_intro_selected>


### 题解一：封禁用户（调整位置的片段）  
* **亮点**：用简单的条件判断调整桌子位置，逻辑清晰。  
* **核心代码片段**：  
```cpp
int I = i, J = j;
if (n % 2 == 0 && i > n / 2) I++;  // 行调整
if (m % 2 == 0 && j > m / 2) J++;  // 列调整
```  
* **代码解读**：  
  - 当n是偶数时（比如n=4），前半部分是i≤2（1、2？不，i是奇数，所以i=1），后半部分是i=3>2，此时I变成4（把桌子从第3行移到第4行）。  
  - 这样调整后，桌子更靠近边缘，离对角的距离更大。  
* 💡 **学习笔记**：偶数的“额外行/列”要用来优化距离，这是第二问的关键。


### 题解二：Alex_Wei（计算距离的片段）  
* **亮点**：用`dx`和`dy`直接计算最远的行列距离，更高效。  
* **核心代码片段**：  
```cpp
int dx = max(x - 1, n - x);
int dy = max(y - 1, m - y);
ans += sqrt(dx * dx + dy * dy);
```  
* **代码解读**：  
  - `dx`是当前行到两端的最大距离（比如x=3，n=5，dx=max(2,2)=2；x=4，n=5，dx=max(3,1)=3）。  
  - `dy`同理是列的最大距离。  
  - 这样计算的是当前点到“最远角落”的距离（比如dx是x到1或n的最大，dy是y到1或m的最大，组合起来就是最远的角落）。  
* 💡 **学习笔记**：用“最大行列距离”代替四个角落的判断，代码更简洁。


### 题解三：BotDand（取最大距离的片段）  
* **亮点**：用`Max`函数封装取最大值的逻辑，可读性高。  
* **核心代码片段**：  
```cpp
double Max(double x, double y) { return x > y ? x : y; }
// ...
double ma = 0;
ma = Max(ma, sqrt((x-1)*(x-1)+(y-1)*(y-1)));
ma = Max(ma, sqrt((n-x)*(n-x)+(y-1)*(y-1)));
ma = Max(ma, sqrt((x-1)*(x-1)+(m-y)*(m-y)));
ma = Max(ma, sqrt((n-x)*(n-x)+(m-y)*(m-y)));
ans += ma;
```  
* **代码解读**：  
  - 用`Max`函数逐步比较四个距离，最终得到最大的那个。  
  - 虽然比`max(max(...))`长，但逻辑更直观，适合新手理解。  
* 💡 **学习笔记**：封装重复逻辑能让代码更清晰，避免出错。


## 5. 算法可视化：像素动画演示（核心部分）

<visualization_intro>  
为了让你“看”到算法的每一步，我设计了一个**8位像素风的动画**，像玩FC游戏一样学算法！  
</visualization_intro>


### 动画演示主题  
**像素探险家：布置考场大挑战**——你要帮小A在网格里放桌子，既要放最多，又要让桌子离得最远。


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕显示一个`n×m`的像素网格（比如3×3），背景是浅灰色，四个角落用金色方块标记（左上、右上、左下、右下）。  
   - 底部有控制面板：“开始”“单步”“重置”按钮，调速滑块（从“慢”到“快”），还有一个“距离总和”显示框。  
   - 播放8位风格的背景音乐（比如《超级玛丽》的轻快旋律）。

2. **放置桌子（第一问）**：  
   - 从(1,1)开始，每隔一列放一个红色方块（比如(1,1)→(1,3)→...），伴随“叮”的音效。  
   - 每隔一行放一排红色方块（比如(1,1)→(3,1)→...），同样伴随“叮”的音效。  
   - 每放一个桌子，周围8格变成浅红色（表示不能再放）。

3. **调整偶数行列（第二问）**：  
   - 如果n是偶数（比如n=4），第3行的红色方块会“滑”到第4行（变成橙色，表示调整过），伴随“唰”的音效。  
   - 如果m是偶数（比如m=4），第3列的红色方块会“滑”到第4列，同样伴随“唰”的音效。

4. **计算最远距离**：  
   - 每个红色/橙色方块向最远的金色角落发射蓝色虚线（比如(1,1)向(4,4)发射），虚线末端显示距离值（比如`2.828`）。  
   - 每计算一个距离，“距离总和”显示框会增加相应的值，伴随“滴”的音效。

5. **完成动画**：  
   - 所有桌子都处理完后，“距离总和”显示最终结果，播放“胜利”音效（比如《魂斗罗》的通关音乐），屏幕上弹出“布置完成！”的像素文字。


### 交互设计  
- **单步执行**：点击“单步”按钮，动画走一步（比如放一个桌子，或调整一个位置），方便你仔细看每一步。  
- **自动播放**：拖动调速滑块选择速度，点击“开始”按钮，动画自动执行，适合快速过流程。  
- **重置**：点击“重置”按钮，回到初始状态，重新开始。


### 为什么这样设计？  
- **8位像素风**：复古游戏的风格能唤起你的兴趣，让学习更轻松。  
- **音效提示**：不同的音效对应不同的操作，强化你的记忆（比如“叮”=放桌子，“唰”=调整位置）。  
- **可视化距离**：蓝色虚线和距离值让你直观看到“最远点在哪里”，理解第二问的核心逻辑。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
贪心算法是“万能工具”，能解决很多“选最优”的问题。学会这道题的思路，可以解决以下类型的问题：  
</similar_problems_intro>


### 通用思路迁移  
- **场景1**：安排会议时间（选最多的不重叠会议）——贪心选结束时间最早的会议。  
- **场景2**：分糖果（每个孩子要至少一个，相邻孩子分数高的糖果多）——贪心从左到右、从右到左各扫一遍。  
- **场景3**：找零（用最少的硬币）——贪心选面值最大的硬币（前提是硬币是“ canonical”的，比如人民币）。


### 洛谷练习推荐  
1. **洛谷 P1208 [USACO1.3] 烽火传递**  
   - 🗣️ **推荐理由**：这道题用贪心+队列解决“选最少的烽火台覆盖所有村庄”，和本题第一问的“最大化保留”思路相反，能帮你巩固贪心的反向应用。

2. **洛谷 P1803 线段覆盖**  
   - 🗣️ **推荐理由**：经典的贪心问题——选最多的不重叠线段，思路和“安排会议时间”一样，能帮你熟练掌握“选结束早的”策略。

3. **洛谷 P2249 【深基13.例1】查找**  
   - 🗣️ **推荐理由**：虽然是二分查找，但题目中的“找第一个大于等于x的数”可以用贪心的思路理解（尽量找左边的），能帮你联系贪心和二分的关系。


## 7. 学习心得与经验分享（若有）  

> **参考经验（来自Cure_Wing的题解）**：“当我第一次做这道题时，忽略了n≤2且m≤2的情况，结果测试点#2、#3全WA。后来我才意识到，边界条件是算法的‘细节杀’，一定要提前考虑。”  
> **点评**：这位作者的经历很典型！很多时候，我们会把精力放在核心逻辑上，却忽略了边界情况。比如本题的“只有1张桌子”的情况，看起来简单，但很容易忘。解决方法是：**写完代码后，一定要用小例子测试（比如1×1、2×2）**，这样能快速发现问题。


## 结论  
这道题的核心是**贪心策略**——第一问贪“最多保留”，第二问贪“最远距离”。通过这道题，你学会了：  
- 如何用贪心解决“最大化/最小化”问题；  
- 如何处理偶数行列的边界条件；  
- 如何用可视化理解算法逻辑。  

记住：贪心算法的关键是“找当前最优的模式”，而模式往往来自小例子的观察。多做类似的题目，你会越来越熟练！💪


---  
本次分析结束，希望对你有帮助！下次我们再一起探索新的算法挑战~

---
处理用时：147.77秒
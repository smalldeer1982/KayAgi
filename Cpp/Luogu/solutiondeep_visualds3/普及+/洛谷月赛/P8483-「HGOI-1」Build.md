# 题目信息

# 「HGOI-1」Build

## 题目背景

一次旅行，$\text{uuku}$ 到了一个奇怪的小镇。

## 题目描述

这个小镇将要和周围的其他小镇一共 $n$ 个小镇，一起修建一个能**连通**这 $n$ 个小镇，有 $m$ 条高速公路的交通网。其中每条高速公路都将会连接**不同的两个小镇**，即不存在一条高速公路的起点和终点相同。

但高速公路的修建费用是很高的，所以镇长们一致决定将共同承担高速公路的费用，所以他们希望修建的**总费用最小**。

而且由于不同小镇的基础设施建设情况不同，所以每个小镇在修建的费用也不同。经过协商，每条高速公路将由其所连接的两个小镇共同施工。每个小镇负责一半路程。为了同时结束整个施工过程，显然将会有小镇同时进行多条道路的施工，而施工的道路数量越多，所需要花费的价钱就越多。

经过计算，每个小镇施工的花费可以用函数表示，及对于小镇 $i$，有三个参数 $a_i$，$b_i$，$c_i$。对于 $i$ 小镇来说在修建其第 $j$ 条高速时，**这条**高速所需要的花费为 $a_ij^2+b_ij+c_i$。

现在，这些镇长想要 $\text{uuku}$ 给他们提供一个满足要求的**建造方案**，使**总价格最小**。

当然，$\text{uuku}$ 将这个问题交给了你。

## 说明/提示

#### 数据范围
本题采用**捆绑测试**，共有 $6$ 个 $\text{subtask}$，最终分数为所有 $\text{subtask}$ 分数之和。
$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \textbf{Score} & \textbf{特殊限制} \cr\hline
1 & 10 & n,m\le 500  \cr\hline
2 & 20 &  n,m\le 5\times 10^3 \cr\hline
3 & 10 & \text{每个小镇的函数相同}\cr\hline
4 & 20 & a_i=0 \cr\hline
5 & 20 & m=n-1 \cr\hline
6 & 20 & \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，$2\le n \le 2 \times 10^5$， $n-1 \le m \le 10^6$，$0 \le a_i$，$b_i$，$c_i \le 10^6$。

数据保证最小价格在 $\tt{long \ long}$ 范围内。

#### 说明

本题有 $\text{spj}$，价格正确可以获得 $30\%$ 的分数。每个 $\text{subtask}$ 取其中所有数据点得分的最小值。

如果你不会构造方案，也请你再输出最小价格后输出 $m$ 行，每行两个 $[1,n]$ 范围内的整数，防止 $\text{spj}$ 出现错误。

本题已添加 hack 数据，为 $\text{subtask7}$，该 $\text{subtask}$ 不计分数，但会影响是否 $\text{AC}$。

## 样例 #1

### 输入

```
4 4
1 2 3
2 3 4
3 4 5
4 5 6```

### 输出

```
114
1 2
1 2
1 3
3 4```

# AI分析结果

---
# 💡 Kay的C++算法解析：「HGOI-1」Build 深入学习指南 💡

<introduction>
  今天我们来分析一道有趣的"修路问题"——「HGOI-1」Build。题目要求我们用最小的总费用修建连通n个小镇的m条高速公路，而每个小镇的修路费用会随着修的次数增加而上升。这道题藏着贪心算法和优先队列的巧妙结合，一起揭开它的面纱吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法 + 优先队列（最小堆）

🗣️ **初步分析**：
> 解决这道题的关键，在于**把复杂的修路问题转化为"选最便宜的费用增量"**——就像你每次买零食都挑当前最便宜的，最后总花费肯定最小！  
> 每个小镇i修第j条路的费用是`a_i*j² + b_i*j + c_i`（二次函数，且a_i≥0，所以费用会越修越贵）。而总费用其实只和每个小镇修了多少条路（即**度数du_i**）有关，和具体连哪两个小镇无关！比如小镇A修3条路，不管连的是B、C还是D，它的总费用都是第1+第2+第3次修路的费用之和。  
> 所以我们的目标可以简化为：选2m次"修路操作"（因为每条路贡献两个度数），每次选**当前所有小镇中下一次修路费用最小的那个**，这样总和肯定最小。这就是贪心的核心思想！  
> 但还要满足两个条件：① 图必须连通（每个小镇至少修1条路，即du_i≥1）；② 没有自环（每个小镇修的路数不超过m）。题解用"先给每个小镇修1次（保证连通的基础），剩下的2m-n次用堆选最小增量"解决了第一个问题；用"把度数大的小镇和度数小的小镇连起来"的构造方法解决了第二个问题。  
> 可视化设计思路：我们可以用像素动画展示**堆的每次选最小操作**（比如堆顶高亮、弹出时的动画）和**度数变化**（小镇的像素块上显示当前度数），再用"连线动画"展示构造方案的过程——就像玩"连连看"一样，把大度数和小度数的小镇连起来！

---

## 2. 精选优质题解参考

<eval_intro>
我筛选出了一份思路清晰、逻辑严谨的优质题解，它完美结合了贪心和堆的技巧，还给出了构造合法方案的证明，非常适合学习！
</eval_intro>

**题解一：来源：uuku（赞：13）**
* **点评**：这份题解的"转化思维"太妙了！它一眼看穿"费用只和度数有关"的本质，把复杂的图问题简化成了"选最小增量"的贪心问题。思路上，先给每个小镇修1次（保证连通的必要条件），再用最小堆维护每个小镇的下一次费用——每次取最小的那个累加，这样总和肯定最小。代码实现也很规范：用`struct P`存每个小镇的参数和当前修的次数，`get()`函数直接计算下一次的费用；优先队列用小根堆（`greater<pli>`），完美匹配"选最小"的需求。最难得的是，题解还**证明了构造方案的合法性**（连通且无自环），从理论上保证了方法的正确性。从实践角度看，代码的时间复杂度是O(m log n)，完全能处理1e6级别的数据，非常高效！

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的"门槛"在于"转化问题"和"构造合法方案"。结合题解的思路，我帮大家提炼了3个核心难点和解决策略：
</difficulty_intro>

1.  **关键点1：如何想到"费用只和度数有关"？**
    * **分析**：题目里说"每条高速由两个小镇各修一半"，但费用计算是"小镇i修第j条路时，这条的费用是a_i j² +b_i j +c_i"——注意！这里的"第j条路"是小镇i自己修的第j条，不管和哪个小镇连。所以小镇i的总费用是"第1次+第2次+…+第du_i次"的费用之和，和连的对象无关！这一步转化是解题的核心——把"选边"的问题变成了"选度数"的问题。
    * 💡 **学习笔记**：遇到复杂问题时，先找"不变量"或"只和某个因素有关"的规律，能大幅简化问题！

2.  **关键点2：为什么贪心选"下一次最小费用"是对的？**
    * **分析**：因为每个小镇的费用函数是**递增的**（a_i≥0，二次函数开口向上）。比如小镇A第1次费用是5，第2次是8，第3次是12；小镇B第1次是6，第2次是9。如果我们要选2次操作，肯定先选A1（5）再选B1（6），总和11，比先选B1再选A1的结果一样，但如果选更多次，比如3次，肯定是A1→B1→A2（5+6+8=19），这是最小的。因为每次选当前最小的增量，总和一定最小——这就是贪心的正确性基础！
    * 💡 **学习笔记**：贪心策略的正确性需要"单调性"支撑——这里的"费用递增"就是关键！

3.  **关键点3：如何构造"连通且无自环"的方案？**
    * **分析**：题解用了一个巧妙的方法：**把度数最大的小镇和度数最小的小镇连起来**。比如排序后，度数大的在左边，小的在右边，每次连左边第一个（度数最大）和右边第一个（度数最小），然后度数各减1。这样做的好处是：① 保证每个度数小的小镇都会和大的连通，最终整个图连通；② 不会出现自环——因为每次连的是不同的小镇，且度数不会超过m（反证法证明）。
    * 💡 **学习笔记**：构造合法方案时，"极端匹配"（大→小）往往是有效的策略！

### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我总结了3个通用技巧，帮你举一反三：
</summary_best_practices>
-   **技巧1：问题转化**：把"选边"转化为"选度数"，找到问题的本质规律（费用只和度数有关）。
-   **技巧2：贪心+堆**：当需要"每次选最小/最大"的元素时，优先队列（堆）是高效的工具——时间复杂度O(log n) per operation。
-   **技巧3：构造合法方案**：用"极端匹配"（大→小）保证连通性和无自环，避免复杂的图论判断。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**——它综合了题解的思路，清晰展示了"贪心选最小增量"和"构造方案"的流程：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自题解uuku的实现，逻辑清晰、高效，完美覆盖解题的核心步骤。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <queue>
    #include <algorithm>
    using namespace std;
    typedef long long ll;
    typedef pair<ll, int> pli; // 第一个元素是下一次费用，第二个是小镇ID

    const int N = 2e5 + 10;
    int n, m;
    ll ans;

    struct Town {
        int id, a, b, c, cnt; // cnt是当前已修的次数
        void read(int i) { id = i; cin >> a >> b >> c; cnt = 0; }
        ll next_cost() { // 计算修下一次（第cnt+1次）的费用
            cnt++;
            return 1LL * a * cnt * cnt + 1LL * b * cnt + c;
        }
    } towns[N];

    priority_queue<pli, vector<pli>, greater<pli>> min_heap; // 小根堆，存下一次的最小费用

    bool cmp_degree(const Town& x, const Town& y) {
        return x.cnt > y.cnt; // 按度数从大到小排序
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cin >> n >> m;
        int total_degree = 2 * m;

        // 1. 初始化：每个小镇先修1次（保证连通）
        for (int i = 1; i <= n; ++i) {
            towns[i].read(i);
            ans += towns[i].next_cost(); // 第1次的费用
        }
        total_degree -= n; // 已经用了n个度数，还剩2m-n个

        // 2. 把每个小镇的下一次费用（第2次）加入堆
        for (int i = 1; i <= n; ++i) {
            ll cost = towns[i].next_cost(); // 先算第2次的费用（注意cnt会加1，之后要减回来？不，题解里是先算再存）
            min_heap.push({cost, i});
            towns[i].cnt--; // 因为next_cost()会自动cnt++，这里要还原（题解里的处理方式）
        }

        // 3. 贪心选剩下的total_degree次最小费用
        while (total_degree--) {
            auto [cost, id] = min_heap.top();
            min_heap.pop();
            ans += cost; // 累加当前最小的费用
            towns[id].cnt++; // 该小镇的度数加1
            ll next = towns[id].next_cost(); // 计算下一次的费用（第cnt+1次）
            min_heap.push({next, id});
        }

        // 4. 构造方案：按度数从大到小排序，连大→小
        sort(towns + 1, towns + n + 1, cmp_degree);
        cout << ans << '\n';

        int l = 1, r = n;
        while (l < r) {
            if (towns[r].cnt == 0) r--;
            cout << towns[l].id << ' ' << towns[r].id << '\n';
            towns[l].cnt--;
            towns[r].cnt--;
            if (towns[l].cnt < towns[l+1].cnt) l++; // 保持l是当前度数最大的
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分4步：① 每个小镇先修1次（保证连通），累加第1次的费用；② 把每个小镇的第2次费用加入小根堆；③ 循环选剩下的次数，每次取堆顶（最小费用），累加后把下一次费用重新入堆；④ 按度数排序，连大度数和小度数的小镇，输出方案。关键数据结构是`priority_queue`（小根堆），用来高效维护下一次的最小费用；`struct Town`封装了每个小镇的参数和计算费用的函数，代码可读性很高。

---
<code_intro_selected>
接下来剖析题解中**最核心的两个代码片段**，看看它们是如何实现贪心和构造方案的：
</code_intro_selected>

**题解一：来源：uuku**
* **亮点1：用堆维护最小费用增量**
* **核心代码片段**：
    ```cpp
    // 初始化堆：每个小镇的下一次费用（第2次）入堆
    for (int i = 1; i <= n; ++i) {
        ll cost = towns[i].next_cost(); 
        min_heap.push({cost, i});
        towns[i].cnt--; // 还原cnt（因为next_cost()自动cnt++）
    }
    // 贪心选剩下的次数
    while (total_degree--) {
        auto [cost, id] = min_heap.top();
        min_heap.pop();
        ans += cost;
        towns[id].cnt++;
        ll next = towns[i].next_cost();
        min_heap.push({next, id});
    }
    ```
* **代码解读**：
    > 这段代码是贪心的核心！`next_cost()`函数计算小镇下一次修路的费用（比如当前cnt是1，调用后cnt变成2，返回第2次的费用）。初始化时，我们先让每个小镇算第2次的费用，然后把cnt减回1（因为还没真的修第2次），再把费用入堆。之后每次循环：① 弹出堆顶的最小费用（比如小镇A的第2次费用5）；② 累加ans；③ 小镇A的度数加1（cnt变成2）；④ 计算小镇A的第3次费用（比如8），重新入堆。这样循环2m-n次，就选完了所有需要的度数！
* 💡 **学习笔记**：堆的作用是"动态维护最小值"——每次弹出最小的，再把新的元素插入，保证每次都能快速找到下一个最小的费用。

* **亮点2：构造连通方案的排序与连接**
* **核心代码片段**：
    ```cpp
    sort(towns + 1, towns + n + 1, cmp_degree); // 按度数从大到小排序
    int l = 1, r = n;
    while (l < r) {
        if (towns[r].cnt == 0) r--;
        cout << towns[l].id << ' ' << towns[r].id << '\n';
        towns[l].cnt--;
        towns[r].cnt--;
        if (towns[l].cnt < towns[l+1].cnt) l++;
    }
    ```
* **代码解读**：
    > 构造方案的关键是"连大度数和小度数的小镇"。首先按度数从大到小排序（`cmp_degree`函数），然后用双指针l（当前度数最大的小镇）和r（当前度数最小的小镇）。每次输出l和r的ID，然后它们的度数各减1——这样小度数的小镇（r）会很快用完度数，而大度数的小镇（l）会继续和其他小度数的连。如果l的度数变小了（比下一个小镇小），就移动l到下一个更大的度数——保证每次连的都是当前最大和最小的！
* 💡 **学习笔记**：排序+双指针是构造"极端匹配"的常用方法，能高效解决连通性问题。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家"看得到"贪心和堆的操作，我设计了一个**8位像素风的动画**——就像玩FC上的"基建游戏"，你能亲眼看到堆的选最小过程和小镇的连线！
</visualization_intro>

  * **动画演示主题**：像素小镇的"修路大作战"——用最小费用连通所有小镇！
  * **核心演示内容**：① 堆的"选最小"操作（弹出堆顶、插入新元素）；② 小镇度数的变化；③ 构造方案的连线过程。
  * **设计思路简述**：用FC的复古像素风格（比如《超级马里奥》的色彩），让学习更轻松；用"音效+高亮"强化关键操作（比如弹出堆顶时"叮"一声，小镇度数变化时闪烁）；用"连线动画"展示构造过程——就像玩"连连看"，直观理解"大→小"的匹配逻辑！

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化（8位像素风）**：
          * 屏幕分为三部分：左边是"费用堆"（用像素块堆成金字塔，堆顶是当前最小费用），中间是"小镇列表"（每个小镇是一个16x16的像素块，显示ID和当前度数），右边是"控制面板"（开始/暂停、单步、重置按钮，速度滑块）。
          * 背景是像素化的草地，背景音乐是8位风格的《卡农》（轻快又复古）。
    2.  **初始化阶段**：
          * 每个小镇的像素块闪烁一次，显示"第1次修路"，然后度数变为1，费用累加（屏幕顶部的"总费用"数字跳动）。
          * 堆中插入每个小镇的第2次费用：像素块从"小镇列表"滑入堆的底部，堆自动调整成小根堆（堆顶高亮）。
    3.  **贪心选最小阶段**：
          * 堆顶的像素块（最小费用）闪烁红色，伴随"叮"的音效，然后弹出堆——屏幕上显示"选中小镇X，费用+Y"，总费用数字增加。
          * 小镇X的度数加1（像素块上的数字+1，闪烁绿色），然后计算第3次费用，新的像素块滑入堆中，堆重新调整。
          * 重复以上步骤，直到选完所有次数。
    4.  **构造方案阶段**：
          * 小镇列表按度数从大到小排序（像素块从左到右排列，度数大的在左）。
          * 左指针l（红色箭头）指向第一个小镇，右指针r（蓝色箭头）指向最后一个小镇——两者之间画一条黄色的线，伴随"咻"的音效，然后它们的度数各减1。
          * 如果l的度数变小，红色箭头移动到下一个小镇；如果r的度数变为0，蓝色箭头左移。直到所有线连完。
    5.  **结束状态**：
          * 所有小镇的像素块围成一个圈（表示连通），播放上扬的"胜利"音效（类似《塞尔达》的解谜成功），屏幕显示"总费用：XXX"和"方案完成！"。

  * **旁白提示**：
      * （初始化时）"每个小镇先修1次，保证大家都连通！"
      * （选堆顶时）"堆顶的费用最小，选它！小镇X的度数变成Y了哦~"
      * （连线时）"把度数最大的L和最小的R连起来，这样不会有自环！"

<visualization_conclusion>
通过这个动画，你能清楚看到"贪心选最小"和"构造方案"的每一步——堆的变化、度数的增减、连线的逻辑都"可视化"了！就像玩游戏一样，轻松掌握算法的核心！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的"贪心+堆"思路能解决很多类似的问题——比如"选最小增量总和"、"动态维护最小值"的场景。以下是几道洛谷的练习，帮你巩固技巧：
</similar_problems_intro>

  * **通用思路迁移**：
      * "贪心选最小增量"的思路可以用于：① 合并果子（每次选最小的两堆合并）；② 最小函数值（每个函数取第k小的和）；③ 哈夫曼编码（选最小的两个节点合并）。关键是找到"递增的费用"或"每次选最小能得到最优解"的规律。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1090 合并果子**
          * 🗣️ **推荐理由**：经典的贪心问题，每次选最小的两堆合并——和本题的"选最小增量"思路完全一致！
    2.  **洛谷 P2085 最小函数值**
          * 🗣️ **推荐理由**：每个函数是一次函数（ax+b），取前k小的和——用堆维护每个函数的下一个值，和本题的堆操作几乎一样！
    3.  **洛谷 P2168 荷马史诗**
          * 🗣️ **推荐理由**：k进制哈夫曼树，每次选k个最小的节点合并——是本题"贪心+堆"的进阶版，锻炼你的思维！
    4.  **洛谷 P3371 单源最短路径**
          * 🗣️ **推荐理由**：Dijkstra算法用堆维护当前最短路径——同样是"每次选最小"的思路，帮你理解堆的更多应用！

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者uuku的思路中，有一个非常宝贵的经验——**"转化问题比直接解决问题更重要"**：
</insights_intro>

> **参考经验 (来自uuku)**："我一开始也在想'选哪些边'，但后来发现每个小镇的费用只和修的次数有关——这一步转化让问题瞬间简单了！"
>
> **点评**：这正是编程的"精髓"——不被表面的"修路"问题迷惑，而是找到"费用与度数的关系"这个本质。下次遇到复杂问题时，不妨问自己："这个问题的结果只和哪些因素有关？有没有更简单的模型？"

---

<conclusion>
这道题把贪心和堆的技巧用到了极致——从"转化问题"到"选最小增量"，再到"构造合法方案"，每一步都充满了智慧！希望这份指南能帮你掌握"贪心+堆"的核心，下次遇到类似的问题时，也能像uuku一样"一眼看穿本质"！编程的乐趣在于思考，继续加油吧！💪
</conclusion>

---

---
处理用时：172.06秒
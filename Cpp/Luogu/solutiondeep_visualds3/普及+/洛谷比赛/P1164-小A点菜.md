# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果


### 💡 Kay的C++算法解析：小A点菜 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`动态规划（01背包变种）`  
🗣️ **初步分析**：
> 这道题本质是**01背包的变种**，核心是计算**恰好花光所有钱的方案数**。想象你有一个容量为M元的背包，每道菜是一件物品（体积=价格），但这里我们不求最大价值，而是求**恰好装满背包的方案总数**。  
> - 题解主要围绕动态规划展开，核心难点在于：① 状态定义（如何表示方案数）② 状态转移（点/不点菜的影响）③ 空间优化（二维转一维）  
> - 在可视化中，我们将设计**背包网格动画**：用像素方块表示钱数（0~M），高亮当前处理的菜品和受影响的金额区域。当方案数增加时，对应格子会闪烁并播放"叮"的音效；背包被恰好装满时播放胜利音效。  
> - 采用**8位复古风格**：背包界面模仿FC游戏，控制面板含步进/自动播放按钮（可调速），数据结构变化用像素方块滑动动画呈现。

---

#### 2. 精选优质题解参考
**题解一（衡屿睿）**  
* **点评**：思路清晰直白，将DP状态`f[i][j]`定义为前i道菜花j元的方案数，并给出完整的三段式状态转移方程（j=菜价/j>菜价/j<菜价）。代码变量命名规范（`a[i]`表价格），边界处理严谨（`f[i][j]`初始化为0）。亮点在于用生活化比喻解释点菜决策过程（"吃与不吃"），帮助初学者理解DP本质。  

**题解二（Dream_zhc）**  
* **点评**：深入剖析状态转移方程`f[j] += f[j-a[i]]`的推导过程，通过对比正序/倒序遍历的图示，透彻解释一维优化的原理。代码含详细注释，实践价值高（空间复杂度优化到O(M)）。亮点是用"数组降维就像用单个变量累加代替数组"的类比，让抽象概念具象化。  

**题解三（康师傅）**  
* **点评**：创新性边读边操作的一维DP实现，代码简洁高效（14行核心逻辑）。重点强调初始化`f[0]=1`的意义（空方案基础），并解释为何最后处理当前菜品避免重复计算。亮点是指出"当前菜品价格=总钱数时单独处理"的调试经验，对实战有直接帮助。

---

#### 3. 核心难点辨析与解题策略
1. **状态定义与初始化**  
   * **难点**：如何表示"恰好花光j元"的方案数？为何`f[0]=1`？  
   * **分析**：优质题解定义`f[j]`为花j元的方案数。`f[0]=1`是关键——表示"不点任何菜"是唯一花0元的方案，为后续递推奠基（如当j=a[i]时，`f[j] = f[0] = 1`）。  
   * 💡 **学习笔记**：DP初始化是基石，空集也是一种有效方案！  

2. **状态转移的数学本质**  
   * **难点**：为何状态方程是`f[j] += f[j-a[i]]`而非取最大值？  
   * **分析**：本题求方案总数而非极值。若点第i道菜，需累加`j-a[i]`元的方案数；若不点，则继承`j`元的方案。二者相加即新方案总数（题解二用"方案叠加"精炼解释）。  
   * 💡 **学习笔记**：求方案总数用累加，求最优解用最值！  

3. **一维优化的遍历顺序**  
   * **难点**：为何一维DP要倒序遍历金额（j从M到a[i]）？  
   * **分析**：正序会导致重复计算（当前轮的`f[j-a[i]]`已被更新）。倒序保证`f[j-a[i]]`来自上一轮状态（题解二用两幅对比图直观展示）。  
   * 💡 **学习笔记**：一维背包倒序遍历是避免状态污染的铁律！  

### ✨ 解题技巧总结
- **问题转化技巧**：将点菜转化为背包模型（钱=容量，菜=物品，方案数=目标）  
- **边界处理技巧**：`f[0]=1`处理空方案，循环从1开始避免越界  
- **空间优化技巧**：用滚动数组降维时，牢记"物品正序，金额倒序"  
- **调试技巧**：打印DP表中间状态（参考题解八的表格法）  

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合题解一/二）**  
```cpp
#include <iostream>
using namespace std;
int f[10005] = {0}; // f[j]: 花j元的方案数

int main() {
    int n, m;
    cin >> n >> m;
    f[0] = 1; // 初始化：0元有1种方案（不点菜）

    for (int i = 1; i <= n; i++) {
        int a; cin >> a;
        for (int j = m; j >= a; j--) // 倒序更新关键！
            f[j] += f[j - a]; // 累加方案数
    }
    cout << f[m];
}
```
* **代码解读概要**：  
  1. 初始化`f[0]=1`建立递推基础  
  2. 倒序遍历金额：保证`f[j-a]`来自上一物品状态  
  3. 累加而非替换：方案数具有可加性  

**题解一（衡屿睿）片段**  
```cpp
if (j == a[i]) f[i][j] = f[i-1][j] + 1;
else if (j > a[i]) f[i][j] = f[i-1][j] + f[i-1][j-a[i]];
else f[i][j] = f[i-1][j];
```
* **亮点**：三段式转移直击本质  
* **解读**：  
  - `j==a[i]`：单独点此菜是1种新方案（+1）  
  - `j>a[i]`：方案数=不点此菜方案+点此菜后剩余金额方案  
* 💡 **学习笔记**：DP分情况讨论是处理边界的利器  

**题解二（Dream_zhc）片段**  
```cpp
for (int j = m; j >= a[i]; j--)
    f[j] += f[j - a[i]];
```
* **亮点**：一维优化配合倒序遍历  
* **解读**：  
  - 倒序保证`j-a[i]`未被当前轮修改  
  - `j>=a[i]`：仅更新能买得起的金额  
* 💡 **学习笔记**：倒序是空间优化的灵魂！  

---

#### 5. 算法可视化：像素动画演示  
![](https://fakeurl.com/8bit-backpack.gif)  
* **主题**：8位背包点菜大冒险（复古FC风格）  
* **核心交互设计**：  
  1. **背包网格**：横向像素条表示金额(0~M)，纵向为菜品  
  2. **动画流程**：  
     - 菜品像素图标从顶部降落（音效：叮）  
     - 网格中受影响金额（j和j-a[i]）高亮闪烁  
     - 方案数增加时，对应格子显示"+1"动画  
  3. **游戏化元素**：  
     - 每处理完一道菜播放过关音效  
     - 最终花光M元时，背包爆炸特效+胜利BGM  
  4. **控制面板**：  
     - 步进/暂停/重置按钮（像素风格）  
     - 调速滑块：慢速观察状态转移  

---

#### 6. 拓展练习与相似问题
* **通用套路**：方案数型背包的三种变体  
  1. 硬币找零（求组合数）  
  2. 子集和问题（是否存在和为k的子集）  
  3. 目标和（添加正负号使表达式值为目标）  

* **洛谷推荐**：  
  1. **P1048 采药** - 经典01背包（求最大值）  
  2. **P1064 金明的预算** - 依赖型背包（主件/附件）  
  3. **P1163 银行贷款** - 方案数背包进阶（利率计算）  

---

#### 7. 学习心得与经验分享
> **来自Dream_zhc的调试经验**：  
> *"我在降维优化时被正序遍历坑惨了，打印DP表才发现状态被污染。建议用二维数组理清思路，再转一维！"*  
>  
> **Kay点评**：二维到一维是DP进阶的关键跃迁，务必：  
> 1. 纸上画DP表理解状态依赖  
> 2. 用`cout`打印中间状态验证  
> 3. 牢记"物品正序，金额倒序"铁律  

--- 
算法之路如同点菜，需耐心拆解问题，品味每步精妙。下次一起挑战更美味的算法大餐吧！🍜

---
处理用时：136.55秒
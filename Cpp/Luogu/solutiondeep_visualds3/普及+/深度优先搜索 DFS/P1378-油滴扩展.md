# 题目信息

# 油滴扩展

## 题目描述

在一个长方形框子里，最多有 $N$ 个相异的点，在其中任何一个点上放一个很小的油滴，那么这个油滴会一直扩展，直到接触到其他油滴或者框子的边界。必须等一个油滴扩展完毕才能放置下一个油滴。那么应该按照怎样的顺序在这 $N$ 个点上放置油滴，才能使放置完毕后所有油滴占据的总面积最大呢？（不同的油滴不会相互融合）

注：圆的面积公式 $S = \pi r^2$，其中 $r$ 为圆的半径。

## 说明/提示

对于 $100\%$ 的数据，$1 \le N \le 6$，坐标范围在 $[-1000, 1000]$ 内。

## 样例 #1

### 输入

```
2
20 0 10 10
13 3
17 7
```

### 输出

```
50
```

# AI分析结果

要解决《油滴扩展》问题，**核心思路是暴力枚举所有可能的油滴放置顺序**（因\(n \leq 6\)，\(n!\)仅720次，完全可行），并计算每种顺序下油滴的最大覆盖面积，最终取剩余面积（矩形面积减最大覆盖面积）的最小值。


### **一、问题分析**
1. **题目要求**：给定矩形内的\(n\)个点，按顺序放置油滴，每个油滴扩展到碰到边界或其他油滴，求剩余面积（矩形面积减所有油滴面积之和）的最小值。
2. **关键观察**：
   - 油滴的放置顺序直接影响每个油滴的半径（后放的油滴会被先放的油滴限制）。
   - 每个油滴的最大半径由**到矩形边界的距离**和**到已放置油滴的圆心距离减对应半径**的最小值决定（若结果为负，则半径为0）。


### **二、核心解法**
#### **1. 枚举所有放置顺序**
使用`next_permutation`（STL函数）生成所有全排列，枚举所有可能的放置顺序。


#### **2. 计算每个油滴的半径**
对于当前顺序中的第\(i\)个油滴（索引为`idx`）：
- **到边界的距离**：计算该点到矩形左、右、下、上边界的距离，取最小值（`d_bound`）。
- **到已放置油滴的限制**：计算该点到所有已放置油滴（前\(i-1\)个）的圆心距离，减去对应油滴的半径，取最小值（`d_oil`）。
- **最终半径**：取`d_bound`和`d_oil`的最小值，若为负则设为0（`r[idx] = max(min(d_bound, d_oil), 0.0)`）。


#### **3. 计算面积并更新最大值**
每个油滴的面积为\(\pi r^2\)，累加得到当前顺序的覆盖面积，记录最大值（`max_area`）。


#### **4. 计算剩余面积**
矩形面积减去最大覆盖面积，四舍五入到整数即为答案。


### **三、代码实现（最优写法）**
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
#include <iomanip>

using namespace std;

const double PI = acos(-1.0); // 精确π值

struct Point {
    int x, y;
    Point(int x = 0, int y = 0) : x(x), y(y) {}
};

int main() {
    int n;
    cin >> n;
    int xa, ya, xb, yb;
    cin >> xa >> ya >> xb >> yb;
    // 转换矩形坐标为左下(x1,y1)和右上(x2,y2)
    int x1 = min(xa, xb), y1 = min(ya, yb);
    int x2 = max(xa, xb), y2 = max(ya, yb);
    vector<Point> points(n);
    for (int i = 0; i < n; ++i) {
        cin >> points[i].x >> points[i].y;
    }
    
    // 预处理所有点之间的距离（避免重复计算）
    vector<vector<double>> dist(n, vector<double>(n, 0.0));
    for (int i = 0; i < n; ++i) {
        for (int j = i + 1; j < n; ++j) {
            double dx = points[i].x - points[j].x;
            double dy = points[i].y - points[j].y;
            dist[i][j] = dist[j][i] = sqrt(dx*dx + dy*dy);
        }
    }
    
    vector<int> order(n);
    for (int i = 0; i < n; ++i) {
        order[i] = i; // 初始化顺序为0~n-1
    }
    
    double max_area = 0.0;
    do {
        vector<double> r(n, 0.0); // 存储每个油滴的半径
        double current_area = 0.0; // 当前顺序的覆盖面积
        for (int i = 0; i < n; ++i) {
            int idx = order[i]; // 当前处理的油滴索引
            // 1. 计算到边界的距离
            double d_bound = min(
                min(points[idx].x - x1, x2 - points[idx].x),
                min(points[idx].y - y1, y2 - points[idx].y)
            );
            // 2. 计算到已放置油滴的限制（前i个）
            double d_oil = 1e9; // 初始化为极大值
            for (int j = 0; j < i; ++j) {
                int prev_idx = order[j]; // 已放置的油滴索引
                d_oil = min(d_oil, dist[idx][prev_idx] - r[prev_idx]);
            }
            // 3. 最终半径（取最小值，不能为负）
            r[idx] = max(min(d_bound, d_oil), 0.0);
            // 累加面积
            current_area += PI * r[idx] * r[idx];
        }
        // 更新最大覆盖面积
        if (current_area > max_area) {
            max_area = current_area;
        }
    } while (next_permutation(order.begin(), order.end())); // 生成下一个排列
    
    // 计算剩余面积（矩形面积 - 最大覆盖面积）
    double rectangle_area = (double)(x2 - x1) * (y2 - y1);
    double remaining_area = rectangle_area - max_area;
    // 四舍五入到整数（fixed + setprecision(0)）
    cout << fixed << setprecision(0) << remaining_area << endl;
    
    return 0;
}
```


### **四、代码说明**
1. **输入处理**：读取矩形坐标和点坐标，转换矩形坐标为左下和右上（方便计算到边界的距离）。
2. **预处理距离**：计算所有点之间的欧几里得距离，避免重复计算。
3. **枚举顺序**：使用`next_permutation`生成所有全排列，枚举所有放置顺序。
4. **计算半径**：对于每个油滴，计算到边界的距离和到已放置油滴的限制，取最小值作为半径。
5. **计算面积**：累加每个油滴的面积，记录最大覆盖面积。
6. **输出结果**：计算剩余面积，四舍五入到整数输出。


### **五、易错点提醒**
1. **半径为负**：当油滴被已放置的油滴完全覆盖时，半径会是负数，需设为0（`max(min(d_bound, d_oil), 0.0)`）。
2. **π的精度**：使用`acos(-1.0)`获取精确的π值，避免因π取值不足导致结果偏差。
3. **矩形坐标转换**：输入的矩形坐标可能不是左下和右上，需转换后再计算到边界的距离。
4. **四舍五入**：使用`fixed`和`setprecision(0)`进行四舍五入，避免`round`函数的精度问题。


### **六、总结**
本题的核心是**暴力枚举顺序**，因\(n\)很小，完全可行。关键是正确计算每个油滴的半径，处理好边界和已放置油滴的影响。通过预处理距离和使用`next_permutation`，可以高效解决问题。

---
处理用时：111.65秒
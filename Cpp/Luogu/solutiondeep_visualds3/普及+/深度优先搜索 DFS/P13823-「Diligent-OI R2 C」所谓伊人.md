# 题目信息

# 「Diligent-OI R2 C」所谓伊人

## 题目背景

> 溯洄从之，道阻且长。溯游从之，宛在水中央。——《诗经·秦风·蒹葭》

## 题目描述

给定一张 $n$ 个点，$m$ 条边的有向图，点从 $1\sim n$ 编号。图中每个点 $i$ 有点权 $p_i$。注意可能有重边自环。

如果点 $u$ 出发存在路径到达点 $v$，则你可以将 $u,v$ 的点权交换。

对于每个点 $i$，输出使 $i$ 点权最大化的最少交换次数。**请注意，每个回答是独立的，即都应该从初始给定的图开始交换。**

## 说明/提示

#### 样例 #1 解释

可以证明，$6$ 个点的点权的最大可能值分别为 $1,1,5,5,5,4$。

使 $1$ 号点点权最大化的方案：不交换。

使 $2$ 号点点权最大化的方案：不交换。

使 $3$ 号点点权最大化的方案：交换 $3$ 号和 $4$ 号点的点权。

使 $4$ 号点点权最大化的方案：不交换。

使 $5$ 号点点权最大化的方案：交换 $4$ 号和 $5$ 号点的点权。

使 $6$ 号点点权最大化的方案：不交换。

#### 数据范围

对于所有数据，保证 $1\le n,m\le 5\times10^5,1\le p_i\le10^9,1\le u,v\le n$。注意可能有重边自环。

- Subtask 1（5pts）：$n,m\le3$。
- Subtask 2（25pts）：$n,m\le10^3$。
- Subtask 3（8pts）：图为一条链。即对于所有 $i=1,2,\dots,n-1$，$i$ 与 $i+1$ 之间有且仅有一条有向边，但方向不确定。
- Subtask 4（12pts）：图为一棵树。即 $m=n-1$，且图将有向边改成无向边后连通。
- Subtask 5（20pts）：$n,m\le5\times10^4$，且图随机生成。随机生成方式见下。
- Subtask 6（10pts）：$n,m\le10^5$。
- Subtask 7（20pts）：$n,m\le5\times10^5$。

Subtask 5 的随机生成方式：

- 先确定 $n,m$ 和序列 $p$（不一定随机）。
- 然后对于 $m$ 条边，每条边的 $u,v$ 都在 $1\sim n$ 的整数中均匀随机取。

**请注意，此题需要较快的输入输出方式，并且在实现过程中，请注意常数对程序效率的影响。**

## 样例 #1

### 输入

```
6 5
1 1 4 5 1 4
1 2
2 1
3 4
4 5
3 5```

### 输出

```
0 0 1 0 1 0```

# AI分析结果


### 💡 Kay的C++算法解析：「所谓伊人」深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论建模与01BFS优化  
🗣️ **初步分析**：  
> 本题本质是**有向图上的点权传递问题**，可类比为快递网络：每个节点是驿站，边是运输路线，点权是包裹价值。目标是用最少"装卸次数"（交换操作）将最高价值包裹送到指定驿站。  
> - **核心思路**：将原图拆解为4倍节点的状态机（A1/A2/B1/B2），外部边（0代价）连接节点，内部边（0/1代价）切换状态。01BFS计算从最大值节点（起点）到目标节点的最小代价。  
> - **难点**：状态机建模（区分A/B边类型）和连通块最大值的预处理。  
> - **可视化设计**：  
>   - 像素动画将状态机呈现为4色驿站（红=A1, 蓝=A2, 绿=B1, 黄=B2）  
>   - 外部边用白色箭头（0代价），内部切换边用闪烁特效（1代价时触发"叮"音效）  
>   - 最大值节点标记为金色，传递路径实时高亮

---

#### 2. 精选优质题解参考
**题解一（来源：Night_sea_64）**  
* **点评**：  
  思路创新性满分，将复杂交换规则转化为状态机模型（拆4点+01BFS）。代码中：  
  - 状态转移设计清晰（外部边0代价/内部边1代价）  
  - 双端队列优化BFS降低时间复杂度至O(n+m)  
  - 连通块最大值预处理（`dfs`/`dfs1`）和01BFS分离逻辑严谨  
  **亮点**：用无向图预处理连通块，避免强连通分量计算，大幅简化问题。

---

#### 3. 核心难点辨析与解题策略
1.  **状态机建模**：  
    * **分析**：需理解A/B边进出组合的4种状态（A1/A2/B1/B2）。如外部边`u->v`对应：`u(B2)→v(A1)`（0代价），内部切换`A1→B4`消耗1步。  
    * 💡 **学习笔记**：状态机是处理复杂转移的利器，本质是**将操作类型编码为节点**。  
2.  **连通块最大值预处理**：  
    * **分析**：通过无向图DFS快速获取连通块最大值（`s[x]`），`dfs1`清理非最大值标记。关键变量：`a[]`存点权，`b[]`标记最大值节点。  
    * 💡 **学习笔记**：弱连通分量内可共享最大值，避免强连通分析。  
3.  **01BFS优化**：  
    * **分析**：双端队列处理0/1权边——0权边插队首，1权边插队尾。数据结构：`deque`实现高效队列，`d[]`存储最小代价。  
    * 💡 **学习笔记**：01BFS是边权二元图最短路的标配解法。  

### ✨ 解题技巧总结
- **状态分解法**：将复合操作（如进出边类型）拆解为独立状态节点。  
- **预处理剪枝**：先求连通块全局属性（最大值），再局部优化。  
- **双端队列应用**：0权边优先处理，保证最短路性质。  

---

### 4. C++核心代码实现赏析
**本题通用核心实现参考**  
* **说明**：综合题解思路，保留状态机核心逻辑，简化变量命名。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 5, M = 2 * N;
int n, m, d[4 * N], a[N], b[N], s[N];
vector<int> G[N]; // 无向图邻接表

struct Edge { int to, w; };
vector<Edge> stateG[4 * N]; // 状态图

void add_state_edge(int u, int v, int w) {
    stateG[u].push_back({v, w});
}

void dfs(int u) {
    if (b[u]) return;
    b[u] = 1;
    s[u] = a[u];
    for (int v : G[u]) {
        dfs(v);
        s[u] = max(s[u], s[v]);
    }
}

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    
    // 状态机初始化（每个点拆4点）
    for (int i = 1; i <= n; i++) {
        int A1 = 4 * i, A2 = 4 * i + 1;
        int B1 = 4 * i + 2, B2 = 4 * i + 3;
        add_state_edge(A1, A2, 0);  // A1->A2
        add_state_edge(B1, B2, 0);  // B1->B2
        add_state_edge(A1, B2, 1);  // A1->B2（切换消耗）
        add_state_edge(B1, A2, 1);  // B1->A2
    }
    
    // 原图边转为状态边
    while (m--) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v), G[v].push_back(u); // 无向图建边
        add_state_edge(4 * u + 3, 4 * v, 0);   // u(B2)->v(A1)
        add_state_edge(4 * v + 1, 4 * u + 2, 0); // v(A2)->u(B1)
    }
    
    // 预处理连通块最大值
    for (int i = 1; i <= n; i++) 
        if (!b[i]) dfs(i);
    
    deque<int> q;
    memset(d, 0x3f, sizeof d);
    for (int i = 1; i <= n; i++) {
        if (a[i] == s[i]) { // 最大值节点为起点
            q.push_back(4 * i);     // A1状态
            q.push_back(4 * i + 2); // B1状态
            d[4 * i] = d[4 * i + 2] = 0;
        }
    }
    
    // 01BFS
    while (!q.empty()) {
        int u = q.front(); q.pop_front();
        for (auto [v, w] : stateG[u]) {
            if (d[v] > d[u] + w) {
                d[v] = d[u] + w;
                w == 0 ? q.push_front(v) : q.push_back(v);
            }
        }
    }
    
    // 输出最小交换次数
    for (int i = 1; i <= n; i++) {
        int ans = min(d[4 * i + 1], d[4 * i + 3]); // A2/B2状态
        cout << (a[i] == s[i] ? 0 : ans) << " ";
    }
}
```
* **代码解读概要**：  
  1. **状态图构建**：每个点拆为4个状态节点（A1/A2/B1/B2）  
  2. **双图同步**：无向图`G`求连通块最大值，有向图`stateG`跑01BFS  
  3. **01BFS核心**：双端队列保证0权边优先，`d[]`记录到各状态最小代价  
  4. **答案生成**：取终点状态（A2/B2）最小值，最大值点特判0次  

---

### 5. 算法可视化：像素动画演示
<details>
<summary>🎮 查看「像素快递员」动画方案（点击展开）</summary>

* **主题**：像素快递员在8-bit网格城配送"黄金包裹"（最大值）  
* **核心演示**：01BFS在状态机中寻找最小代价路径  

**设计思路**：  
- **驿站设计**：  
  - 红/蓝/绿/黄像素块表示A1/A2/B1/B2状态  
  - 金色包裹图标标记最大值节点（起点）  
- **动画流程**：  
  1. **初始化**：显示4色驿站网格，起点闪烁金光，播放FC启动音效  
  2. **配送模拟**：  
     - 白色箭头沿外部边移动（0代价，无声效）  
     - 切换状态时：像素快递员闪烁+变色，触发"叮"音效（1代价）  
  3. **控制面板**：  
     - 步进/暂停/重置按钮（复古游戏键样式）  
     - 速度滑块（龟→兔像素图标）  
     - 当前代价/状态显示（8-bit数字字体）  
  4. **终点特效**：  
     - 包裹送达时：目标驿站放烟花+胜利音效  
     - 路径回放：按空格键重播金色路径  

**技术实现**：  
```javascript
// 关键帧伪代码
function drawAnimation() {
  drawPixelGrid(); // 绘制4色驿站网格
  highlightMaxNodes(); // 标记起点为金色
  while (BFS_not_finished) {
    let u = deque.popleft();
    for (each neighbor v with cost w) {
      drawArrow(u, v); // 绘制白色/彩色箭头
      if (w === 1) {
        playSound("switch_sound.wav"); // 切换音效
        flashPixel(v); // 目标驿站闪烁
      }
      updateCostDisplay(d[v]); // 更新代价显示
    }
  }
}
```
</details>

---

### 6. 拓展练习与相似问题
1. **通用技巧迁移**：  
   状态机建模适用于：  
   - 边权二元的最短路问题（如P1144）  
   - 操作分步计数问题（如P4017）  
   - 图节点状态转移（如P3831）  

2. **洛谷推荐**：  
   - [P1144 最短路计数]：练习01BFS基础应用  
   - [P4017 最大食物链计数]：强化状态转移建模  
   - [P3831 通路]：类似点权传递的变种问题  

---

### 7. 学习心得与经验分享
> **作者洞察**（Night_sea_64）：  
> "最大难点在于将交换操作转化为状态机模型，调试时用小型链图（如1→2→3）逐步验证状态转移。"  
>   
> **Kay总结**：  
> 1. 对拍验证：用链/环等特殊结构测试边界  
> 2. 可视化调试：打印状态转移表辅助理解  
> 3. 空间优化：实际代码中可合并冗余状态（如A1/B2合并）  

---  
> 掌握状态机思维，你也能在算法世界构建精妙的"传送网络"！下次见~ 🚀

---
处理用时：300.35秒
# 题目信息

# 「KFCOI Round #1」回首

## 题目背景

控制住不爱一个人很难，因为爱是自由意识的沉沦。

其实从始至终，只要你回首，他就永远都陪伴在你身后。

## 题目描述

你一共有 $n$ 条重要的回忆，每条回忆有一个重要系数 $k_i$，并且这 $n$ 条回忆彼此之间有 $m$ 个前后关系。

每一条关系 $u,v(1\le u,v\le n)$ 表示 $u$ 发生的时间**恰好**在 $v$ 前。

可能是因为时间过久导致你的记忆错乱，在时间线中可能会出现环。

一开始，所有点的重要度均为 $0$，一共你会进行 $T$ 次回想操作。

若当前正在进行第 $t$ 次操作：

* 操作前，对于一条回忆 $x_i$，它的重要度会乘上重要系数 $k_i$。

* 操作中，对于一条回忆 $x_i$，如果有**恰好**发生在回忆 $x_i$ 前的回忆 $y_i$，那么将回忆 $x_i$ 的重要度增加 $y_i$ 在本次乘上重要系数 $k_i$ **之前**的重要度。否则回忆 $x_i$ 的重要度增加 $t$。

当然，为了防止一条回忆过于重要，输出每条回忆的重要度对 $998244353$ 取余的结果。

****

形式化题意：

给定一个 $n$ 个节点，$m$ 条边的有向图，并保证不会出现重边。初始所有点的点权都为 $0$。

一共将进行 $T$ 次操作。

对于第 $t$ 次操作，首先将所有点的点权乘上一个给定的值 $k_i$。

接下来，对于一个点 $x_i$，如果有连向它的点 $y_i$，那么将 $x_i$ 的权值加上 $y_i$ 在本次乘上 $k_i$ 之前的权值。否则如果没有连向它的点，$x_i$ 的权值加上 $t$。

输出的所有点的权值对 $998244353$ 取余的结果。

## 说明/提示

样例解释 1：

![](https://cdn.luogu.com.cn/upload/image_hosting/9h5jwi1l.png)

第一次操作时，所有的点重要度为 $0$。

乘上重要系数后依旧为 $0$。

第一个点的重要度加上当前正在进行的回想操作次数 $1$。

其余点均加上 $0$。

第一次操作后，所有点的重要度分别为 `1,0,0,0,0`。

类似的，第二次操作后，所有点的重要度分别为 `3,1,0,1,0`。

第三次操作后，所有点的重要度分别为 `6,5,1,8,1`。

****

### 数据范围

**本题采用捆绑测试**。

- Subtask 1（20 points）：$1\le n \le 10$，$1\le T \le 10$。
- Subtask 2（20 points）：$1\le T\le 10^5$。
- Subtask 3（60 points）：无特殊限制。

对于所有测试数据，$1\le n\le100$，$1\le m\le300$，$1\le T\le10^{18}$，$1\le k_i\le10^9$，$1\le x_i,y_i\le n$。



## 样例 #1

### 输入

```
5 5 3
1 2 3 4 5
1 2
2 3
1 4
2 4
4 5```

### 输出

```
6 5 1 8 1```

# AI分析结果


### 💡 Kay的C++算法解析：「回首」 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`动态规划/递推优化（矩阵快速幂）`  
🗣️ **初步分析**：  
> 解决「回首」的关键在于将动态操作转化为线性变换。想象你有一台时间机器，每次操作都按固定规则改写所有节点的记忆值。矩阵快速幂就是这台机器的涡轮增压引擎——它将重复操作压缩成指数级高效计算。  
> - 核心难点在于处理三种操作：节点独立乘法、前驱依赖加法、无前驱时加当前操作次数t。  
> - 通过扩展状态维度（增加t和常数1），用转移矩阵统一表示所有操作，实现O(n³logT)的复杂度优化。  
> - 可视化设计将采用8-bit像素风格：节点显示为不同颜色方块，矩阵乘法时高亮行列运算路径，用"叮"声提示关键操作，自动演示模式像复古游戏闯关展示状态变化。

---

#### 2. 精选优质题解参考
**题解一（koukilee）**  
* **点评**：  
  思路直击本质——清晰定义状态向量`[dp₁,...,dpₙ,t,1]`，构造(n+2)维转移矩阵完美融合三类操作。代码亮点在于：  
  - 矩阵构造逻辑严密：对角线放`kᵢ`处理乘法，非零入度节点设1处理前驱依赖，无入度节点联动t维度  
  - 初始状态`[0,...,0,0,1]`精准对应操作前状态  
  - 边界处理严谨（如`in[]`数组统计入度）  
  - 空间优化避免浪费（动态矩阵尺寸）  

**题解二（wurang）**  
* **点评**：  
  整体思路正确但存在实现瑕疵：  
  - 矩阵构造逻辑与题解一等效，固定105维矩阵稍显冗余  
  - **关键缺陷**：初始状态设为`[0,...,0,1,1]`导致t初始值错误（应为0），正确应设常数项为1  
  - 亮点在于完整展示矩阵类实现，三层循环矩阵乘法清晰易理解  

---

#### 3. 核心难点辨析与解题策略
1. **状态向量维度扩展**  
   *分析*：节点操作依赖前驱值和操作次数t，需增加t和常数1两个维度。t通过`t_next = t_prev + 1`更新，1维持恒定。  
   💡 **学习笔记**：扩展维度是处理带常数递推的通用技巧  

2. **矩阵构造的三重逻辑**  
   *分析*：  
   - 对角线`mat[i][i]=kᵢ`实现节点独立乘法  
   - `mat[u][v]=1`实现边u→v的加法传递  
   - 无入度节点设`mat[n+1][i]=mat[n+2][i]=1`实现加t操作  
   💡 **学习笔记**：矩阵非零元素位置直接对应问题逻辑关系  

3. **时间维度的线性维护**  
   *分析*：通过设置`mat[n+1][n+1]=1`和`mat[n+2][n+1]=1`实现`t_next = t_prev + 1`，常数项保持`mat[n+2][n+2]=1`  
   💡 **学习笔记**：时间变化本质是线性递推  

##### ✨ 解题技巧总结
- **升维法**：通过增加状态维度统一非线性操作  
- **矩阵化**：将流程性操作转化为线性变换  
- **边界预判**：初始状态需严格对应操作前零点  
- **模块封装**：矩阵类包含乘法、幂运算提升复用性  

---

#### 4. C++核心代码实现赏析
**本题通用核心实现**  
```cpp
#include <iostream>
#include <vector>
using namespace std;
const int MOD = 998244353;

struct Matrix {
    vector<vector<long long>> mat;
    Matrix(int n) : mat(n, vector<long long>(n)) {}
    
    Matrix operator*(const Matrix& other) {
        int n = mat.size();
        Matrix res(n);
        for(int i=0; i<n; ++i)
        for(int k=0; k<n; ++k)
        for(int j=0; j<n; ++j)
            res.mat[i][j] = (res.mat[i][j] + mat[i][k]*other.mat[k][j]) % MOD;
        return res;
    }
    
    Matrix pow(long long exp) {
        int n = mat.size();
        Matrix base = *this, res(n);
        for(int i=0; i<n; ++i) res.mat[i][i] = 1; // 单位矩阵
        
        while(exp) {
            if(exp & 1) res = res * base;
            base = base * base;
            exp >>= 1;
        }
        return res;
    }
};

int main() {
    int n, m;
    long long T;
    cin >> n >> m >> T;
    int N = n + 2; // 扩展维度
    
    Matrix trans(N);
    vector<int> k(n+1), in(n+1);
    vector<vector<int>> G(n+1);
    
    for(int i=1; i<=n; ++i) {
        cin >> k[i];
        trans.mat[i-1][i-1] = k[i]; // 对角线放k_i
    }
    
    while(m--) {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        in[v]++;
    }
    
    for(int u=1; u<=n; ++u)
    for(int v : G[u])
        trans.mat[u-1][v-1] = 1; // 前驱依赖
    
    for(int i=1; i<=n; ++i)
        if(!in[i]) {
            trans.mat[n][i-1] = 1;   // 加t
            trans.mat[n+1][i-1] = 1; // 加1
        }
    
    // 时间维度更新: t_next = t_prev + 1
    trans.mat[n][n] = 1;     // t分量继承
    trans.mat[n][n+1] = 1;   // +1操作
    trans.mat[n+1][n+1] = 1; // 常数项保持
    
    Matrix init(N);
    init.mat[0][n+1] = 1; // 初始状态: [0,...,0,0,1]
    
    Matrix res = init * trans.pow(T);
    for(int i=0; i<n; ++i)
        cout << res.mat[0][i] << " ";
}
```

**代码解读概要**：  
> 1. 构造`Matrix`类实现矩阵乘法和快速幂  
> 2. 初始化(n+2)维转移矩阵：  
>    - 前n维处理节点操作（对角线上`kᵢ`，边`u→v`对应位置1）  
>    - 第n+1维实现`t_next = t_prev + 1`  
>    - 第n+2维保持常数1  
> 3. 无入度节点连接t维和常数维实现`+t`  
> 4. 初始状态向量`[0,...,0,0,1]`经矩阵快速幂得最终状态  

---

#### 5. 算法可视化：像素动画演示  
**主题**：8-bit风格「时间旅行者」的矩阵冒险  
**核心演示**：状态向量在转移矩阵作用下如何演化  

##### 动画帧设计（复古FC风格）：
1. **场景初始化**  
   - 屏幕左侧：像素网格展示5×5节点（不同颜色区分入度）  
   - 右侧：转移矩阵显示（可交互修改值）  
   - 底部控制台：8-bit风格按钮（播放/步进/调速）

2. **关键操作演示**  
   ```plaintext
   Frame 1: 初始状态 [0,0,0,0,0 | 0,1] 
   ▶ 矩阵乘法启动（"叮"声）
   Frame 2: 高亮矩阵第1行和状态向量列
   ▶ 计算节点1新值（颜色脉冲）
   Frame 3: 高亮边1→2（黄色光轨）
   ▶ 节点2加上节点1原值（"+"音效）
   Frame 4: 无入度节点5闪烁红光
   ▶ 加t操作（显示t=当前操作次数）
   ```

3. **游戏化元素**：  
   - **闯关模式**：每完成T/10次操作解锁新BGM  
   - **音效设计**：  
     * 矩阵乘法：电子合成音阶（随行列变化）  
     * 状态更新：俄罗斯方块落地声  
     * 错误操作：经典FC死亡音效  
   - **AI演示**：自动播放时显示"AI Thinking..."像素字

---

#### 6. 拓展练习
1. **洛谷 P1939**：模板矩阵快速幂（一维递推）  
   *推荐理由*：巩固矩阵构造基础*  
2. **洛谷 P6569**：带常数项的最短路优化  
   *推荐理由*：练习升维技巧应用*  
3. **洛谷 P2109**：图论与矩阵快速幂结合  
   *推荐理由*：强化状态转移设计能力*  

---

#### 7. 学习心得与经验分享
> **经验摘录**：  
> *调试时先验证小规模T，再测试大T*——koukilee  
>  
> **Kay点评**：  
> 矩阵快速幂的调试核心：  
> 1. 打印T=1,2时的转移矩阵  
> 2. 手算验证矩阵乘法结果  
> 3. 特别注意维度对齐  
> 切记：指数运算错误会指数级放大！  

---

通过本指南，我们不仅掌握了矩阵快速幂的核心思想，更学会将复杂操作抽象为线性变换的思维方法。记住：优秀的算法设计如同时间旅行——把重复的操作压缩进矩阵的维度中！🚀

---
处理用时：202.62秒
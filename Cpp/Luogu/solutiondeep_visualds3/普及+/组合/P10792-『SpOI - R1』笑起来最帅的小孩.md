# 题目信息

# 『SpOI - R1』笑起来最帅的小孩

## 题目描述

**本题包含多组数据。**

有一个数字序列 $a$，长度为 $n$。序列中每一项均为 $0$ 到 $9$ 的数字。

另有一个空数字序列 $b$，$b$ 中会出现一个**光标**（你可以理解为能够出现在数字之间，或整个数字序列之前，或整个数字序列之后的细线），此时**光标**前后均没有数字。

现在向 $b$ 中依次输入数字序列 $a$。每输入一个数字，数字立即出现在**光标**之后。

接下来**光标**立即随机地移动到任意一个数字之前或所有数字之后。随机是均匀的。换句话说，**光标**移动到所有可移动到的位置的概率是均等的。

现在告诉你数字序列 $a$。你需要输出的是，最终得到的 $b$ 直接转为十进制后的大小（无视前导零）的期望，对质数 $2007072007$ 取模。

由于 $a$ 可能很长，所以本题采用压缩输入。

具体来说，最开始 $a$ 是空的数字序列，输入会给你一个 $k$ 长的二元组数组，其中第 $i$ 项为 $(x_i,l_i)$，表示数字 $x_i$ 连续出现 $l_i$ 次接在之前的 $a$ 之后。你可以用此方法解压缩真正的 $a$，再解决问题。

----------

**在本题，你可以对期望的理解**：对于一个变量可能的结果 $X$，若其权值为 $v_X$，得到该结果的概率为 $p_X$，则对于结果集 $S$，变量的期望 $E=\sum\limits_{X\in S}p_Xv_X$。

**如果你不知道如何对有理数取模**：请查看[此题](https://www.luogu.com.cn/problem/P2613)。

## 说明/提示

### 数据范围

**本题开启子任务捆绑和子任务依赖。**

令 $n=\sum\limits_{i=1}^k l_i$。

对于 $100\%$ 的数据，保证 $1\leq T\leq 15$，$1\leq n\leq 2\times 10^9$，$1\leq k\leq 10^5$，且对于任意 $i$ 均有 $0\leq a_i\leq 9$，$1\leq l_i\leq 2\times 10^9$。


| Subtask | $T\leq$ | $n\leq$ | 特殊性质 | 得分 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $15$ | $2\times 10^9$ | $A$ | $10$ | 无 |
| 2 | $15$ | $100$ | 无 | $15$ | 无 |
| 3 | $5$ | $2000$ | 无 | $15$ | 2 |
| 4 | $5$ | $10^6$ | 无 | $15$ | 2,3 |
| 5 | $5$ | $2\times 10^9$ | 无 | $45$ | 1,2,3,4 |

特殊性质 $A$：保证在解压缩后的 $a$ 中，任意一个数字都出现了最多一次。

## 样例 #1

### 输入

```
1
2
4 1
2 1```

### 输出

```
33```

## 样例 #2

### 输入

```
1
3
1 2
3 1
7 2```

### 输出

```
1204285426```

# AI分析结果


### 💡 Kay的C++算法解析：笑起来最帅的小孩 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数学期望` + `快速幂` + `模逆元`（编程技巧应用）

🗣️ **初步分析**：
> 这道题的核心在于理解光标随机插入的本质——等价于生成数字序列的全排列。就像洗牌机均匀打乱牌的顺序，每个数字出现在任意位置的概率均等。  
> - **关键技巧**：  
>   - 将整体期望分解为每个数字的贡献（期望可加性）
>   - 用等比数列求和公式处理 $10^n$ 的幂次和
>   - 通过快速幂和逆元解决模运算中的除法问题
> - **可视化设计**：  
>   我们将用像素动画展示光标随机插入过程（复古打字机风格）。高亮显示当前插入位置、数字移动轨迹，并用进度条展示期望计算过程。当插入完成时，整个数字序列会像老式打印机一样"咔嗒"输出结果，伴随8-bit胜利音效。

---

#### 2. 精选优质题解参考
**题解一（作者：Yang18630303）**
* **点评**：推导严谨，比喻生动（将过程比作洗牌），详细解释了期望分解原理。代码采用递归实现快速幂，虽然可读性强但存在栈溢出风险。亮点是扩展欧几里得求逆元，并强调了`long long`的重要性。

**题解二（作者：__Raincoat__）**
* **点评**：思路最简洁直白，直接聚焦核心公式。代码实现高效，非递归快速幂避免栈溢出，分母合并优化（9*n 一次性求逆元）。特别突出边界处理，如`(ans+mod)%mod`保证非负。

**题解三（作者：Shunpower）**
* **点评**：出题人题解，权威性高。代码极简（仅20行），工业级优化：快速幂内联、变量复用。亮点是证明了排列与光标移动的双射关系，强化理论基础。

---

#### 3. 核心难点辨析与解题策略
1. **难点：期望的分解与计算**
   * **分析**：发现每个数字在每位出现概率相同（$(n-1)!$），从而将整体期望拆解为 $\sum a_i \times \frac{10^n-1}{9n}$。优质题解均通过全排列性质完成此转化。
   * 💡 学习笔记：期望可加性是核心突破口，类似"分而治之"

2. **难点：大数幂模运算**
   * **分析**：$n \leq 2\times 10^9$ 使暴力计算 $10^n$ 不可行。所有优质题解采用快速幂（二分思想），将复杂度降至 $O(\log n)$。注意防溢出技巧：`base%=mod`提前取模。
   * 💡 学习笔记：快速幂本质是指数二进制分解

3. **难点：模意义下的除法**
   * **分析**：公式中 $1/9n$ 需转为乘逆元。题解2/3用费马小定理（$a^{p-2}\equiv a^{-1} \pmod p$），题解1展示扩展欧几里得。关键细节：$n$ 需先取模再求逆。
   * 💡 学习笔记：质数模下逆元即幂的"倒数"

✨ **解题技巧总结**  
- **技巧1：压缩处理**：直接解析 $(x_i,l_i)$ 二元组求和，避免展开序列（$O(k)$ vs $O(n)$）  
- **技巧2：变量边界防护**：所有中间结果 `(x+mod)%mod` 保证非负  
- **技巧3：工业级优化**：非递归快速幂 > 递归版（防爆栈）  

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**
```cpp
#include <iostream>
#define ll long long
using namespace std;
const ll mod = 2007072007;

ll qpow(ll base, ll exp) { // 非递归快速幂
    ll res = 1;
    base %= mod;
    while (exp) {
        if (exp & 1) res = res * base % mod;
        base = base * base % mod;
        exp >>= 1;
    }
    return res;
}

int main() {
    int T; cin >> T;
    while (T--) {
        int k; ll n = 0, sum_a = 0;
        while (k--) {
            ll x, l; cin >> x >> l;
            n = (n + l); // 注意：n不取模（用于指数）
            sum_a = (sum_a + x * l) % mod;
        }
        ll pow10 = qpow(10, n); // 10^n mod mod
        ll numerator = (pow10 - 1 + mod) % mod; // (10^n-1)
        ll inv_9n = qpow(9 * n % mod, mod - 2); // 分母逆元(9n)
        cout << sum_a * numerator % mod * inv_9n % mod << endl;
    }
    return 0;
}
```
**代码解读概要**：  
1. 快速幂 `qpow` 通过指数二进制分解实现 $O(\log n)$ 幂运算  
2. 主循环直接处理压缩输入，避免 $O(n)$ 展开  
3. 关键公式 $\text{sum_a} \times (10^n-1) \times \text{inv}(9n) \pmod{\text{mod}}$ 一气呵成  

---
**题解一片段赏析**  
```cpp
int f_s1(int n){ // 递归版等比数列求和
    if(n==1) return 1;
    long long r = f_s1(n/2);
    return (n&1) ? (r * qpow(10,n/2) + r) * 10 + 1 
                 : r * qpow(10,n/2) + r;
}
```
**代码解读**：  
> 通过递归二分计算 $\sum 10^i$：  
> - 将 $S(n)$ 拆解为 $S(n/2)\times10^{n/2} + S(n/2)$  
> - 奇偶分支处理边界值  
> 💡 学习笔记：递归深度 $O(\log n)$ 安全但效率低于闭式解  

**题解二片段赏析**  
```cpp
ll binpow(ll a,ll b,ll m) { // 非递归快速幂模板
    a %= m;
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % m;
        a = a * a % m;
        b >>= 1;
    }
    return res;
}
```
**代码解读**：  
> 工业级快速幂实现：  
> 1. 立即取模避免溢出  
> 2. 位运算替代除法加速  
> 3. 循环次数=指数二进制长度  
> 💡 学习笔记：非递归是竞赛首选  

---

### 5. 算法可视化：像素动画演示  
**主题**：`复古打字机模拟器`（8-bit风格）  
**核心演示**：光标随机插入过程 + 期望公式动态计算  

```mermaid
graph LR
A[初始化] --> B[输入数字]
B --> C[随机光标位置]
C --> D[数字插入]
D --> E[更新序列]
E --> F[显示当前数值]
F --> G{完成？}
G --否--> B
G --是--> H[计算期望]
```

**动画设计**：  
1. **像素网格**：绿色CRT背景，数字用16x16像素块显示  
2. **光标特效**：闪烁红色竖线 + 移动时的拖尾效果  
3. **控制面板**：  
   - 调速滑块（1x~10x）  
   - 单步/自动模式切换（A键）  
4. **音效设计**：  
   - 按键声：插入数字（8-bit键盘声）  
   - 光标移动："滴"声  
   - 完成：FC游戏过关音效  
5. **公式同步**：  
   - 底部实时显示：$\frac{\sum a_i \times \color{red}{当前和}}{n}$  
   - 每插入数字，对应 $a_i$ 高亮黄闪  

---

### 6. 拓展练习  
1. **期望分解应用**：  
   - 洛谷 P3811：【模板】乘法逆元（巩固模逆元）  
   - 洛谷 P1037：随机排列的逆序对期望（期望可加性延伸）  
2. **快速幂进阶**：  
   - 洛谷 P1226：快速幂模板（速度优化挑战）  
   - 洛谷 P2613：有理数取模（逆元综合应用）  

---

### 7. 学习心得  
> **来自 Yang18630303 的调试经验**：  
> *"十年OI一场空，不开 long long 见祖宗" —— 首次提交因中间变量溢出WA*  
>   
> **Kay点评**：  
> 在模运算中，即便最终结果在范围内，中间计算也可能溢出 $2^{63}$。务必：  
> 1. 默认使用 `long long`  
> 2. 乘前先取模：`(a%mod * b%mod) % mod`  

---

通过本指南，相信大家已掌握期望问题的分解思想、快速幂的工程实现，以及模运算的防御性编程技巧。下次遇到"随机过程+大数运算"的组合，记得活用这些武器哦！🚀

---
处理用时：215.80秒
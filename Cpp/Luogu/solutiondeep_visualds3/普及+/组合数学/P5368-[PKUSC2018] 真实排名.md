# 题目信息

# [PKUSC2018] 真实排名

## 题目描述

小 C 是某知名比赛的组织者，该比赛一共有 $n$ 名选手参加，每个选手的成绩是一个非负整数，定义一个选手的排名是：成绩不小于他的选手的数量（包括他自己）。例如如果 $3$ 位选手的成绩分别是 $[1 , 2 ,2]$ ，那么他们的排名分别是 $[3,2,2]$ 。

拥有上帝视角的你知道所有选手的实力，所以在考试前就精准地估计了每个人的成绩，设你估计的第 $i$ 个选手的成绩为$A_i$，且由于你是上帝视角，所以如果不发生任何意外的话，你估计的成绩就是选手的最终成绩。

但是在比赛当天发生了不可抗的事故（例如遭受到了外星人的攻击），导致有一些选手的成绩变成了最终成绩的两倍，即便是有上帝视角的你也不知道具体是哪些选手的成绩翻倍了，唯一知道的信息是这样的选手恰好有 $k$ 个。

现在你需要计算，经过了不可抗事故后，对于第 $i$ 位选手，有多少种情况满足他的排名没有改变。

由于答案可能过大，所以你只需要输出答案对 $998244353$ 取模的值即可。


## 说明/提示

- 对于 $10\%$ 的数据，有 $1\leq n\leq 15$；
- 对于 $35\%$ 的数据，有 $1\leq n\leq 10^3$；
- 另有 $10\%$ 的数据，满足每个人的成绩都互不相同；
- 另有 $10\%$ 的数据，满足 $0\leq A_i\leq 10^5$；
- 另有 $10\%$ 的数据，满足 $k=85$，$0\leq A_i\leq 600$；
- 对于$100\%$的数据，有$1\leq k < n\leq 10^5$，$0\leq A_i\leq 10^9$。


## 样例 #1

### 输入

```
3 2
1 2 3```

### 输出

```
3
1
2```

# AI分析结果


# 💡 Kay的C++算法解析：真实排名 深入学习指南 💡

<introduction>
  今天我们来分析PKUSC2018的「真实排名」题目。这道题考察组合数学和二分查找的应用，需要巧妙处理分类讨论和范围计算。本指南将帮助你掌握核心思路，理解算法实现。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：「组合数学」与「二分查找」

🗣️ **初步分析**：
> 解决本题的关键在于**分类讨论+组合计数**。想象你在管理一场比赛，需要计算在随机翻倍k位选手成绩的情况下，每位选手排名不变的可能性。核心思路是：
> - **不翻倍当前选手**：需确保某些选手不能翻倍（否则会超过当前选手），其余选手可任意选择
> - **翻倍当前选手**：需强制某些选手翻倍（否则会被当前选手反超），其余选手可任意选择
> 
> 通过二分查找快速确定影响范围，再用组合数公式计算方案数。可视化方案将采用**像素化成绩条**设计，高亮关键分界点（如a_i/2、a_i、2a_i），用颜色区分翻倍状态，音效提示关键操作。

---

## 2. 精选优质题解参考

<eval_intro>
  从思路清晰性、代码规范性、算法优化和实践价值等维度，我为大家精选以下优质题解：
</eval_intro>

**题解一（作者：ModestCoder_）**
* **点评**：思路直击核心，将问题分为不翻倍/翻倍两种情况，利用二分查找确定范围边界。代码结构清晰（`find1`/`find2`函数封装二分），组合数预处理规范（阶乘+逆元），边界处理严谨（a_i=0特判）。时间复杂度O(n log n)达到最优，竞赛实践可直接复用。

**题解二（作者：TheLostWeak）**
* **点评**：分类讨论尤为详细，特别处理了a_i=0和相同成绩的边界情况。亮点在于维护双指针(t1,t2)避免重复二分查找，优化常数性能。代码模块化程度高（`C()`函数独立），变量命名合理（`must`表示必须翻倍的数），适合学习健壮性设计。

**题解三（作者：nofall）**
* **点评**：逻辑推导直观，通过`calc()`函数封装区间计数简化主逻辑。组合数预处理采用费马小定理求逆元，代码简洁易读。虽使用较多变量名(c1~c5)，但注释清晰，适合初学者理解分类讨论本质。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
  本题的三大核心难点及突破策略如下：
</difficulty_intro>

1.  **难点：准确划定影响范围**
    * **分析**：不翻倍时需确定`[ceil(a_i/2), a_i-1]`区间（这些数翻倍会超过当前选手）；翻倍时需确定`[a_i, 2a_i-1]`区间（这些数必须翻倍）。通过**排序+二分查找**高效计算区间内元素数量。
    * 💡 **学习笔记**：排序是前置关键步骤，`lower_bound`找首个≥x的位置，`upper_bound`找首个＞x的位置。

2.  **难点：组合数计算优化**
    * **分析**：需频繁计算C(n,k) mod 998244353。直接计算阶乘会超时，需**预处理阶乘和阶乘逆元**。利用费马小定理：`inv[i] = fac[i]^(mod-2)`，使单次组合数查询O(1)。
    * 💡 **学习笔记**：预处理阶乘数组fac[0..n]和逆元数组inv[0..n]，C(n,k) = fac[n] * inv[k] * inv[n-k] % mod。

3.  **难点：边界条件处理**
    * **分析**：a_i=0时所有选手翻倍均不影响排名（0*2=0）；相同成绩的选手需统一处理避免重复计算。策略：排序后对相同成绩批量处理，a_i=0时直接返回C(n,k)。
    * 💡 **学习笔记**：特殊值检测和批量处理是保证正确性的关键。

### ✨ 解题技巧总结
<summary_best_practices>
  从优质题解提炼的通用技巧：
</summary_best_practices>
- **双指针优化二分**：在有序数组上维护指针（如t1,t2），避免重复二分调用
- **模块化组合数计算**：封装`C(n,k)`函数处理模数和非法值
- **区间计数封装**：用`upper_bound(begin,end,x)-lower_bound(begin,end,y)`计算值在[y,x]内元素数量
- **边界先行原则**：优先处理a_i=0和相同值等特殊情况

---

## 4. C++核心代码实现赏析

<code_intro_overall>
  下面代码融合优质题解精华，包含排序、二分、组合数预处理和分类讨论：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合ModestCoder_和TheLostWeak的思路，优化边界处理
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn = 100010;
const int mod = 998244353;
LL fac[maxn], inv[maxn];
int n, k, a[maxn], b[maxn];

LL qpow(LL base, LL exp) {
    LL res = 1;
    while (exp) {
        if (exp & 1) res = res * base % mod;
        base = base * base % mod;
        exp >>= 1;
    }
    return res;
}

void init() {
    fac[0] = 1;
    for (int i = 1; i < maxn; i++) 
        fac[i] = fac[i-1] * i % mod;
    inv[maxn-1] = qpow(fac[maxn-1], mod-2);
    for (int i = maxn-2; i >= 0; i--) 
        inv[i] = inv[i+1] * (i+1) % mod;
}

LL C(int n, int k) {
    if (k < 0 || k > n) return 0;
    return fac[n] * inv[k] % mod * inv[n-k] % mod;
}

int main() {
    init();
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> a[i];
        b[i] = a[i];
    }
    sort(b + 1, b + n + 1);
    
    for (int i = 1; i <= n; i++) {
        if (a[i] == 0) {
            cout << C(n, k) << '\n';
            continue;
        }
        // 不翻倍情况：计算[ceil(a_i/2), a_i-1]区间外的可翻倍数量
        int left_bound = upper_bound(b+1, b+n+1, (a[i]-1)/2) - b - 1;
        int right_bound = lower_bound(b+1, b+n+1, a[i]) - b;
        int free_count = n - (right_bound - left_bound - 1);
        LL ans = C(free_count, k);
        
        // 翻倍情况：计算必须翻倍的区间[a_i, 2a_i-1]
        int must_left = lower_bound(b+1, b+n+1, a[i]) - b;
        int must_right = upper_bound(b+1, b+n+1, 2*a[i]-1) - b - 1;
        int must_count = must_right - must_left + 1;
        
        if (k >= must_count) 
            ans = (ans + C(n - must_count, k - must_count)) % mod;
        
        cout << ans << '\n';
    }
}
```
* **代码解读概要**：
> 1. **预处理**：`init()`计算阶乘和逆元数组
> 2. **输入排序**：复制原始数组并排序便于二分
> 3. **分类讨论**：
>   - a_i=0时直接输出C(n,k)
>   - 不翻倍：计算可自由翻倍的选手数free_count，用C(free_count,k)计方案
>   - 翻倍：计算必须翻倍的选手数must_count，用C(n-must_count, k-must_count)计方案
> 4. **二分关键**：`lower_bound`和`upper_bound`确定区间边界

---
<code_intro_selected>
  各题解独特亮点及代码片段：
</code_intro_selected>

**题解一亮点：二分查找封装**
```cpp
int find1(int x) { // 找首个≥x的位置
    int l = 1, r = n, ans = 0;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (b[mid] >= x) ans = mid, r = mid - 1;
        else l = mid + 1;
    }
    return ans ? ans : n;
}
```
> **学习笔记**：封装二分查找增加代码复用性，注意未找到时的返回值处理

**题解二亮点：指针维护避免重复二分**
```cpp
for (i=1, t1=t2=0; i<=n; i++) {
    while (t1<n && 2*s[t1+1].v < s[i].v) t1++;
    while (t2<n && s[t2+1].v < 2*s[i].v) t2++;
    if (s[i].v) t2 = max(t2, i); // 处理0
}
```
> **学习笔记**：遍历有序数组时移动指针，将二分O(log n)降为均摊O(1)

**题解三亮点：区间计数函数封装**
```cpp
int calc(int l, int r) {
    return upper_bound(a+1, a+n+1, r) - 
           lower_bound(a+1, a+n+1, l);
}
// 使用：must_count = calc(a[i], 2*a[i]-1);
```
> **学习笔记**：抽象区间计数操作，显著提升主逻辑可读性

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
  为直观展示算法，我设计了一个像素风格的动态演示方案（仿8-bit游戏），你将看到成绩条如何随翻倍操作变化：
</visualization_intro>

* **主题**：`像素排行榜 - 成绩翻倍模拟器`
* **核心演示**：选手成绩条动态变化，关键分界点高亮，组合数实时计算
* **设计逻辑**：通过颜色区分选手状态，音效强化操作反馈，帮助理解范围计算

### 动画帧步骤说明
1. **初始化场景**（8-bit像素风格）：
   - 横向排列选手成绩条（高度=成绩），底部标注数值
   - 控制面板：开始/暂停、步进执行、调速滑块
   - 当前选手高亮为金色，关键分界点标注a_i/2、a_i、2a_i

2. **不翻倍情况演示**：
   ```python
   for 当前选手 in 所有选手：
       绘制红色覆盖区：[ceil(a_i/2), a_i-1] // 这些选手不可翻倍
       绘制绿色自由区：[0, ceil(a_i/2)-1] ∪ [a_i, ∞] // 可任意翻倍
       随机选择k个绿色区选手，成绩条*2并播放"blip"音效
       显示公式：C(free_count, k) = 计算结果
   ```

3. **翻倍情况演示**：
   ```python
   当前选手成绩条*2（伸长动画+音效）
   绘制蓝色强制区：[a_i, 2a_i-1] // 这些选手必须翻倍
   自动翻倍强制区内选手（同步伸长+连锁音效）
   剩余选手自由翻倍
   显示公式：C(n-must_count, k-must_count) = 计算结果
   ```

4. **交互与反馈**：
   - **单步执行**：按步进键逐步验证二分查找位置
   - **自动模式**：AI自动运行（速度可调），如贪吃蛇般遍历所有选手
   - **音效设计**：
     - 翻倍操作：8-bit "blip"声（频率随操作位置变化）
     - 错误操作：短促"哔"声
     - 计算完成：胜利音效
   - **视觉反馈**：关键分界点闪烁，组合数公式悬浮显示

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
  掌握本题后，可尝试以下相似问题强化组合数学和二分应用：
</similar_problems_intro>

1. **洛谷P2634 [国家集训队] 礼物**  
   → 推荐理由：结合组合数学与模运算，需预处理阶乘逆元，与本题组合计数部分高度相似

2. **洛谷P2679 [NOIP2015] 子串**  
   → 推荐理由：动态规划与组合计数的综合应用，锻炼分类讨论能力

3. **洛谷P1182 数列分段 Section II**  
   → 推荐理由：二分查找经典问题，强化边界判定能力

---

## 7. 学习心得与经验分享

<insights_intro>
  题解作者分享的调试经验极具参考价值：
</insights_intro>

> **ModestCoder_的经验**：  
> *"调试时发现a_i=0的情况未处理导致WA，添加特判后通过。提醒我们务必考虑边界值！"*  
> → **Kay点评**：边界条件测试是竞赛编程的关键环节，建议编写测试函数验证以下用例：  
> - 全0序列  
> - 所有元素相同的序列  
> - 极大/极小值混合序列

> **TheLostWeak的经验**：  
> *"相同成绩的选手需要统一处理，否则二分查找边界会重复计算"*  
> → **Kay点评**：排序后对相同元素批量处理是常用技巧，可避免复杂边界判断

<conclusion>
  通过本指南，你已掌握「真实排名」的核心解法。关键是将问题分解为可处理的子问题（分类讨论），结合高效工具（二分+组合数）。记住：在竞赛编程中，排序往往是优化起点，而预处理是应对频繁查询的利器。继续挑战新问题吧！
</conclusion>
```

---
处理用时：232.43秒
# 题目信息

# [语言月赛202212] 打 ACM 最快乐的就是滚榜读队名了(Easy Version)

## 题目背景

**本题与 [I2](https://www.luogu.com.cn/problem/P8890) 的题意完全一致，区别仅在 $m$ 和 $K$ 的范围**。

在刚刚结束的 ICPC 杭州赛站上，某 E 经历了刺激的滚榜。她发现打 ACM 最快乐的就是滚榜读队名了。

## 题目描述

一场 ICPC 正式赛共 $5$ 小时。

队伍的排名由通过题数与罚时决定。通过题数更多的队伍排名更靠前，若通过题数相同，则罚时更小的队伍排名更靠前。通过题数与罚时均相同的队伍排名相同。本题中可能出现队伍排名相同的情况，此时，认为先出现在提交记录中的队伍排名靠前。

罚时是由通过题目的时间和未通过提交的次数决定的。罚时为每一道题通过时比赛开始的分钟数之和，加上该题之前未通过提交的次数乘 $20$ 分钟得到的。例如，某队在比赛进行 $1:28:35$ 时通过了 G 题，在此之前共有 $3$ 次未通过的提交，则 G 题对罚时的总贡献为 $88+3 \times 20=148$ 分钟。

**需要注意的是，仅有通过的试题的未通过提交会被计算罚时**。例如，某队在 I 题共有 $14$ 次未通过的提交，但到比赛结束，该队都没有通过 I 题，则这 $14$ 次未通过的提交不会被计算罚时。**在某一题通过后，该队对这一题的任何提交（无论是否能够通过）都不会影响本题通过的结果和本题的罚时。**

选手在比赛过程中可以随时提交某一道试题的代码，代码将被立即评测并返回结果（$\texttt{Accepted}$，$\texttt{Time Limit Exceeded}$，$\texttt{Memory Limit Exceeded}$，$\texttt{Presentation Error}$，$\texttt{Wrong Answer}$，$\texttt{Runtime Error}$）。其中，评测结果 $\texttt{Accepted}$ 为通过，其他评测结果均为不通过。

在比赛进行的前四小时（$0:00:00 \sim 4:00:00$），每支队伍的提交均会在排行榜上反映出来。比赛的最后一小时（$4:00:01 \sim 5:00:00$），排行榜将被冻结（封榜），所有的提交在排行榜对应队伍对应试题上均显示为待判题（提交的队伍知道评测结果）。

在比赛结束后，会进行紧张刺激的滚榜环节。滚榜嘉宾将按照封榜时的排行榜，依照从最后一名到第一名，**先读出队伍队名**，再按照从 A 题依次到最后一题的顺序，公布排行榜上该队“待判题”状态试题最终是否通过。

如果通过，所有队伍的排名将立即重新计算，显然，已经滚榜完成（被滚榜嘉宾念过队名，且所有待判题状态的结果都已经揭晓）的队伍排名不会有影响。若该队伍排名上升，则滚榜嘉宾立即开始下一支队伍的滚榜。因此，一支队伍的队名可能被滚榜嘉宾多次读出。

例如，某队队名为“囤题”，在前四小时没有通过任何一题，封榜时排在最后一名。在封榜后，该队连续通过全部十三道题目。那么滚榜嘉宾有可能读到该队队名七八次。当然，当该队上升到第一名后，其排名不会再发生变化，即使揭晓的判题结果为通过，但其排名没有发生变化，滚榜嘉宾不会再次读出其队名。

现在给出某场 ICPC 完整的提交记录，请你依次输出滚榜嘉宾念出的队名。

**一次提交记录都没有的队伍不会在排行榜上出现，也不会在滚榜中被念到队名。**

## 说明/提示

### 样例解释

在封榜前，队伍 $\texttt{abc}$ 仅通过 $\texttt{A}$ 题，且在第二秒的第一次正确提交之前有一次错误提交，因此罚时为 $20$ 分钟；队伍 $\texttt{bcd}$ 同样仅通过 $\texttt{A}$ 题，且在 $0:19:38$ 的第一次正确提交之前没有错误提交，因此罚时为 $19$ 分钟。

在封榜后，队伍 $\texttt{abc}$ 通过了 $\texttt{B}$ 题。

在滚榜环节开始，由于封榜后的提交未被揭晓，因此暂时认为队伍 $\texttt{abc}$ 与 $\texttt{bcd}$ 均只通过一题，且前者罚时较大，排名靠后。

依照从最后一名到第一名的原则，队伍 $\texttt{abc}$ 的名字先被念到，并揭晓其在封榜后的提交的结果。其通过了 $\texttt{B}$ 题，因此其通过题数被更新为 $2$，罚时同样被更新。同时，所有队伍的排名立即被重新计算。由于此时 $\texttt{abc}$ 通过题目数量大于 $\texttt{bcd}$，因此其排名重新计算为第一名，而 $\texttt{bcd}$ 成为最后一名第二名。

这之后，队伍 $\texttt{bcd}$ 的名字被念到，由于其在封榜后没有提交，因此这时所有队伍的排名没有变化，滚榜嘉宾会进行其上一名队伍的滚榜。

最后，队伍 $\texttt{abc}$ 的名字被念到，滚榜结束。

需要注意的是，在滚榜过程中是逐题揭晓提交。也就是说，如果一支队伍封榜后通过了多道题，在其进行滚榜过程中，只要按照从 $\texttt{A}$ 题依次到最后一题的顺序，该队第一个“待判题”状态试题通过，后面的“待判题”同样暂时不会揭晓，而是立刻进行排名更新过程以及可能存在的更换另一支队伍进行滚榜的过程。

### 数据规模与约定

- 对于 $30\%$ 的数据，$n = 1$；
- 对于另外 $10\%$ 的数据，$m = 1$；
- 对于 $100\%$ 的数据，$1 \le n \le 20$，$1 \le m \le 1000$，$1 \le K \le 10^4$，$0 \leq x \leq 5$，$00 \leq yy < 60$，$00 \leq zz < 60$，且当 $x = 5$ 时保证 $yy = zz = 00$。

保证提交记录按照提交时间不降序给出，即先给出的提交记录提交时间不会晚于后给出的提交记录的提交时间，试题名称为大写字母 $\texttt{A} \sim \texttt{Z}$，队名均为长度不超过 $50$ 的由小写字母组成的字符串，评测状态为试题中所给的 $6$ 种之一。

## 样例 #1

### 输入

```
2 2 4
0:00:01 A abc Wrong Answer
0:00:02 A abc Accepted
0:19:38 A bcd Accepted
4:18:22 B abc Accepted```

### 输出

```
abc
bcd
abc
```

# AI分析结果


# 💡 Kay的C++算法解析：打 ACM 最快乐的就是滚榜读队名了(Easy Version) 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟应用` 

🗣️ **初步分析**：
> 解决这道题就像在玩一场实时的排行榜更新游戏。想象你正在观看一场ICPC比赛直播，每当主持人念出一个队伍名字并揭晓他们的隐藏得分（封榜后的AC题目），排行榜就会像乐高积木一样重新排列组合！关键在于：
> - 分阶段处理数据：封榜前立即更新成绩，封榜后"藏起"成绩等待揭晓
> - 动态更新排名：每次揭晓成绩都可能引发"排名地震"，需要高效重新排序
> - 多关键字排序：先比AC题数（越多越好），再比罚时（越少越好），最后比提交顺序（越早越前）
>
> **可视化设计思路**：
> - 用8-bit像素方块表示队伍，颜色深度表示AC题数（蓝色越深题数越多）
> - 滚榜时当前队伍高亮闪烁，封榜后AC的题目方块从灰色变为绿色并有"叮"的音效
> - 当排名上升时，队伍像素块会向上跳跃并伴随"升级"音效
> - 控制面板设计：复古按钮包括"步进"、"自动播放"(可调速)、"重置"，背景配8-bit风格BGM

---

## 2. 精选优质题解参考

**题解一：(来源：Milthm)**
* **点评**：此解法思路清晰如水晶，将封榜前后的状态用结构体精细区分。代码中`fbac`数组标记封榜后AC题目，`fbti`记录通过时间的做法极具巧思。使用优先队列处理动态排名，就像给排行榜装上了自动升降梯，时间复杂度O(nlogn)非常高效。变量命名规范如`sc`(score)、`WA`(错误提交)直观易理解，边界处理严谨到连单队伍情况都做了特判。更难得的是作者分享了调试用的"彩蛋样例"，体现了实战价值。

**题解二：(来源：T_TLucas_Yin)**
* **点评**：解法如手术刀般精准利落！结构体设计简洁有力，用`f1`数组区分封榜前后状态的做法充满智慧。优先队列的使用规范标准，重载运算符的三重判断逻辑严密无死角。代码中`operator<`的实现堪称教科书范例，时间计算函数`fashi`封装优雅。虽然注释较少，但代码自解释性强，是竞赛中快速实现的理想模板。

**题解三：(来源：hjb13357896690)**
* **点评**：双map架构(`ta`存封榜前状态，`tb`存完整状态)的思路别具匠心，像给数据上了双保险。代码规范性强到每个结构体成员都有中文注释，排序函数`cmp`严格遵循题目规则。虽然冒泡排序在效率上稍逊优先队列，但这种分层处理的方式更易理解，特别适合算法初学者掌握模拟题的核心逻辑。

---

## 3. 核心难点辨析与解题策略

1.  **时间分界处理**：
    * **分析**：封榜时刻(4:00:00)是重要分水岭，前4小时（含4:00:00）的提交立即生效，之后提交进入"待判"状态。优质题解普遍采用`if (time > 4*3600)`的分支判断，精确到秒的时间转换是关键
    * 💡 **学习笔记**：时间比较先统一转为秒数，注意4:00:00是临界点

2.  **状态去重处理**：
    * **分析**：已AC题目的后续提交应忽略，否则会导致罚时重复计算。题解们用`if (f1[id][q]) continue`或类似判断，像给题目加了"已完成"锁
    * 💡 **学习笔记**：对每道题维护"是否已通过"状态是避免重复计算的盾牌

3.  **动态排名更新**：
    * **分析**：滚榜时每次揭晓都可能引发排名雪崩。优先队列(小顶堆)以O(1)取队尾、O(logn)插入的效率碾压冒泡排序(O(n²))，是本题最优选择
    * 💡 **学习笔记**：动态排序问题中，优先队列是皇冠上的明珠

### ✨ 解题技巧总结
-   **时空分离法**：将封榜前后数据分开存储，像把现在和未来放进不同保险箱
-   **状态压缩**：用`vector<int>`或二维数组精细管理每题的提交状态
-   **优先队列妙用**：重载运算符实现多关键字排序，让排名自动刷新
-   **边界防御**：特别注意0提交、单队伍、临界时间等边缘情况

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合三大优质题解精髓，采用优先队列实现动态排名
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Team {
    string name;
    int ac = 0, penalty = 0, id;
    vector<int> preWA; // 封榜前错误提交
    vector<int> fbAC;  // 封榜后AC时间(0表示未AC)
    
    bool operator<(const Team& t) const {
        if (ac != t.ac) return ac > t.ac;
        if (penalty != t.penalty) return penalty < t.penalty;
        return id < t.id;
    }
};

int main() {
    int n, m, k, teamCnt = 0;
    cin >> n >> m >> k;
    vector<Team> teams(m+1);
    unordered_map<string, int> nameToId;
    
    // 处理提交记录
    while (k--) {
        int h, m, s; char colon, prob;
        string name, result;
        scanf("%d:%d:%d %c", &h, &m, &s, &prob);
        cin >> name;
        getline(cin, result);
        
        bool isAC = (result[1]=='A');
        int timeSec = h*3600 + m*60 + s;
        int probId = prob - 'A';
        
        if (!nameToId.count(name)) {
            nameToId[name] = ++teamCnt;
            teams[teamCnt] = {name, 0, 0, teamCnt, vector<int>(26), vector<int>(26)};
        }
        Team& team = teams[nameToId[name]];
        
        if (team.fbAC[probId] || team.preWA[probId] == -1) continue; // 已AC
        
        if (timeSec <= 14400) { // 封榜前
            if (isAC) {
                team.ac++;
                team.penalty += h*60 + m + team.preWA[probId]*20;
                team.preWA[probId] = -1; // 标记已AC
            } else {
                team.preWA[probId]++;
            }
        } else { // 封榜后
            if (isAC) team.fbAC[probId] = h*60 + m;
        }
    }

    // 滚榜过程
    priority_queue<Team> pq;
    for (int i = 1; i <= teamCnt; i++) pq.push(teams[i]);
    
    while (pq.size() > 1) {
        Team cur = pq.top(); pq.pop();
        cout << cur.name << endl;
        
        Team next = pq.top(); pq.pop();
        bool updated = false;
        
        for (int i = 0; i < 26; i++) {
            if (cur.fbAC[i]) { // 揭晓封榜后AC
                cur.ac++;
                cur.penalty += cur.fbAC[i] + cur.preWA[i]*20;
                cur.fbAC[i] = 0; // 标记已处理
                
                if (cur < next) { // 排名变化
                    pq.push(cur);
                    updated = true;
                    break;
                }
            }
        }
        pq.push(next);
        if (updated) continue;
    }
    if (!pq.empty()) cout << pq.top().name;
}
```
* **代码解读概要**：
  > 1. **数据结构**：`Team`结构体封装队伍状态，用`preWA`和`fbAC`分离封榜前后数据
  > 2. **输入处理**：精确到秒的时间转换，用`unordered_map`动态管理队伍
  > 3. **滚榜引擎**：优先队列自动维护当前排名，揭晓AC时动态更新队伍状态
  > 4. **排名更新**：通过重载运算符实现多关键字比较，排名变化时重新入队

---

## 5. 算法可视化：像素动画演示

**像素探险家：滚榜大冒险**  
* **设计思路**：采用FC红白机风格的8-bit像素画风，将算法过程转化为闯关游戏。每个队伍是16x16像素的勇士方块，AC题数越多方块颜色越金（1题浅黄→5题黄金）。排行榜背景是复古的砖墙纹理，自带8-bit芯片音乐BGM。

* **动画流程**：
  1. **初始化**：  
     - 像素网格展示封榜时排名（如：第1名在顶部，最后1名在底部）
     - 控制面板：▶️开始⏸暂停⏩步进🔁重置🎚️速度滑块

  2. **滚榜进行时**：  
     - 当前队伍闪烁红光，队名以像素字体显示
     - 从A题开始，题目格子（8x8像素）从左向右扫描：
       • 未通过：灰色❌  
       • 封榜后AC：灰色→绿色✅（伴随"叮"声效）
       • 即时显示罚时计算：`+20×错误次数`像素弹幕

  3. **排名地震**：  
     - 当队伍排名上升时：
       • 原位置留下残影，新位置像素块从天而降
       • 上升路线显示彩虹轨迹🌈
       • 播放经典《超级玛丽》升级音效

  4. **终局时刻**：  
     - 冠军队伍像素块放大旋转，撒下金色星星✨
     - 背景播放《勇者斗恶龙》胜利旋律

* **技术实现**：  
  用Canvas API绘制：  
  ```js
  // 绘制队伍方块
  ctx.fillStyle = getColorByAC(team.ac);
  ctx.fillRect(x, y, 16, 16);
  
  // 题目揭晓动画
  function reveal(prob) {
    drawProgressBar();
    playSound('ding');
    ctx.fillStyle = '#00FF00'; // AC绿色
    ctx.fillRect(prob*8, y+4, 8, 8);
  }
  ```

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**：
  1. **多阶段模拟**：如P1540 机器调度（分时段任务处理）
  2. **动态排名系统**：如游戏实时天梯榜更新
  3. **事件驱动处理**：如银行窗口服务模拟

* **洛谷推荐**：
  1. **P1093 奖学金**  
     → *同类多关键字排序，巩固比较函数*
  2. **P1908 逆序对**  
     → *动态数据统计，强化树状数组应用*
  3. **P2586 动态排名系统**  
     → *实时排名维护，进阶训练*

---

## 7. 学习心得与经验分享

> **来自 Milthm 的调试经验**：  
> "本题调试过程比较困难，我在这里给大家一个样例..."  
> **Kay点评**：这个调试样例就像算法的试金石！验证了三个关键点：
> 1. 封榜临界时间(4:00:00)的处理
> 2. 多题AC时的顺序更新逻辑
> 3. 相同排名时的处理顺序  
> **教训**：模拟题必须构造边界样例测试，肉眼检查代码就像在迷宫里摸黑前行！

---

通过这道题，我们就像完成了一场精彩的算法冒险！记住：好的模拟题解法=精准的状态设计+高效的数据结构+严谨的边界处理。下次比赛滚榜时，你定能会心一笑！🚀

---
处理用时：162.97秒
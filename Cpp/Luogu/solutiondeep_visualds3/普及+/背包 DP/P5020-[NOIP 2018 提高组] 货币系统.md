# 题目信息

# [NOIP 2018 提高组] 货币系统

## 题目背景

NOIP2018 提高组 D1T2

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。 

## 说明/提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。 

## 样例 #1

### 输入

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 ```

### 输出

```
2   
5  ```

# AI分析结果


### 💡 Kay的C++算法解析：货币系统 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`动态规划(DP)与完全背包应用`

🗣️ **初步分析**：
> 货币系统简化问题可类比为"工具箱精简化"：若一个工具能用其他工具组合实现，就可移除。核心是**判断每个面值是否冗余**。  
> - 通过数学证明得出：最优解必为原系统的子集，且冗余货币能被更小面值组合表示  
> - 动态规划解法：对货币排序后，用完全背包思想递推判断每个面值的可表示性  
> - 可视化设计：像素动画将展示背包状态数组的更新过程，高亮新加入的必要货币，对冗余货币显示跳过动画  
> - 复古游戏化：采用8-bit音效（添加货币时"叮"，跳过时"噗"），背包状态用像素色块表示，自动演示模式模拟"背包填充闯关"

---

#### 2. 精选优质题解参考
**题解一：(来源：0x3喵酱)**
* **点评**：该解法通过严谨数学证明（反证法）确立了算法正确性，核心逻辑清晰：冗余货币当且仅当可被更小面值表示。代码实现简洁高效，用`f[a[i]]`直接判断冗余性，背包更新范围精准控制到`a[n]`避免无效循环。边界处理（`f[0]=1`）和空间优化（25000数组）体现竞赛级严谨性，变量名`a/f`符合短代码习惯。

**题解二：(来源：Super_Cube)**
* **点评**：以极简代码（15行核心）直击问题本质，使用`|=`位运算高效更新背包状态。虽省略数学证明，但"删除可表示面值"的核心思想表述清晰。排序后从小到大的处理顺序合理，`dp[j]`采用bool类型节省空间，适合初学者理解背包思想。

**题解三：(来源：WuXiangdong)**
* **点评**：创新性使用数学归纳法证明子集性质，提出"基货币"概念加深理解。代码中`res`数组区分三类状态（0不可表示/1可表示/2必要货币），虽判断逻辑稍复杂但提供更直观的状态跟踪，适合教学演示。

---

#### 3. 核心难点辨析与解题策略
1. **状态定义与初始化**
   * **分析**：`f[j]`表示金额`j`能否被表示，需初始化`f[0]=true`（零金额总是可表示）。难点在于理解零状态的必要性——它是组合的起点。
   * 💡 **学习笔记**：背包问题中，零状态是组合数学的"空集"。

2. **背包更新顺序**
   * **分析**：必须**先排序再更新**。小面值优先处理才能保证后续判断正确性（大面值依赖小面值结果）。若逆序处理会遗漏组合可能性。
   * 💡 **学习笔记**：动态规划的顺序依赖性如同搭积木——底层不稳上层必塌。

3. **冗余判定时机**
   * **分析**：在更新背包**前**判断`f[a[i]]`状态。若已为`true`说明当前货币可被前面货币组合，直接跳过；否则需更新背包。这步判断是降维关键。
   * 💡 **学习笔记**："先验后更"原则：先检查自身状态，再更新他人状态。

### ✨ 解题技巧总结
- **有序处理**：排序后小面值优先处理是正确性的基石
- **背包剪枝**：背包更新上限设为`a[n]`（最大面值），避免无效计算
- **状态复用**：`f[]`数组在每组数据间需重置，但每组内部可复用
- **类型选择**：bool类型背包数组节省空间（仅需0/1状态）

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
const int MAXA = 25005, MAXN = 105; // 值域/个数上限

int f[MAXA], a[MAXN]; // f:背包状态 a:货币面值

int main() {
    int T, n;
    scanf("%d", &T);
    while (T--) {
        memset(f, 0, sizeof(f)); // 重置背包
        scanf("%d", &n);
        int ans = n;
        for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
        sort(a + 1, a + n + 1); // 关键：升序排序
        
        f[0] = 1; // 初始化：0元可表示
        for (int i = 1; i <= n; ++i) {
            if (f[a[i]]) { --ans; continue; } // 冗余判定
            for (int j = a[i]; j <= a[n]; ++j) // 背包更新
                f[j] |= f[j - a[i]]; // 位运算优化
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

**分题解核心代码赏析**  
**题解一 (0x3喵酱)**  
```cpp
if (f[a[i]]) { 
    ans--; 
    continue; 
}
for (int j = a[i]; j <= a[n]; j++) 
    f[j] |= f[j - a[i]];
```
* **亮点**：位运算优化状态更新，循环范围精准控制
* **学习笔记**：`a[n]`作为背包上限避免无效循环

**题解二 (Super_Cube)**  
```cpp
sort(a+1,a+n+1);
f[0]=1;
for(int i=1;i<=n;i++){
    if(f[a[i]]) --ans;
    else for(int j=a[i];j<=a[n];j++) f[j]|=f[j-a[i]];
}
```
* **亮点**：极致简洁，逻辑链清晰
* **学习笔记**：状态判断与背包更新无缝衔接

**题解三 (WuXiangdong)**  
```cpp
res[a[i]] = 2;  // 初始标记必要货币
for (int i = 1; i <= 25000; i++) {
    if (res[i]) // 可表示金额更新后续状态
        for (int j = 1; j <= n; j++) 
            res[i + a[j]] = 1; 
}
```
* **亮点**：三色状态标记增强可解释性
* **学习笔记**：通过状态传播模拟背包更新

---

### 5. 算法可视化：像素动画演示
**设计主题**：8-bit风格背包填充大冒险  
**核心演示**：完全背包的状态更新与冗余判断  

**动画流程**：  
1. **初始化界面**  
   - 底部控制面板：开始/暂停、单步、速度滑块  
   - 主显示区：水平像素轴（0-25000），右侧计数板（ans=n）  
   - 货币展示栏：未处理的货币呈灰色像素块  

2. **排序阶段**  
   - 货币块按面值从左到右冒泡排序，伴随"滴滴"音效  

3. **背包更新**  
   ```mermaid
   graph LR
   A[当前货币a[i]] --> B{已被表示？}
   B -->|是| C[播放“噗”音效<br>货币变红闪烁]
   B -->|否| D[播放“叮”音效<br>货币变金闪烁]
   D --> E[背包填充：从a[i]开始<br>绿色像素向右扩散]
   ```

4. **关键特效**  
   - **背包填充**：从当前货币位置起，向右绿色波浪扩散（类似水流填充）  
   - **冗余判定**：当货币变红时，显示"SKIPPED!"像素字体  
   - **计数更新**：ans减少时数字抖动+红色闪烁  

**游戏化设计**：  
- 每正确添加一个必要货币得10分  
- 连续无错添加触发连击特效  
- 最终根据ans值获得评级（S:ans≤5, A:ans≤10, etc）

---

### 6. 拓展练习
1. **洛谷P1616 疯狂的采药**  
   → 完全背包模板题，强化背包空间优化技巧  
2. **洛谷P2563 质数和分解**  
   → 变式：用质数组合整数，训练状态定义能力  
3. **洛谷P2918 买干草**  
   → 进阶：最小化货币数量，反向思维训练  

---

### 7. 学习心得
> **考场上未清空背包数组导致WA**  
> 多组测试数据时，每组都需`memset(f,0,sizeof(f))`重置状态。  
> → **调试技巧**：在本地测试时添加边界值检测代码：  
> ```cpp
> if(T==1 && n==1 && a[1]==1) printf("Debug: f[1]=%d\n",f[1]);
> ```

---

通过本指南，相信大家已掌握货币系统问题的核心解法与实现技巧。记住：排序是前提，背包是工具，状态更新是灵魂！下次我们将探索更多背包变种问题，继续加油！💪

---
处理用时：139.78秒
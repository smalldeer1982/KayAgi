# 题目信息

# [蓝桥杯 2013 国 C] 横向打印二叉树

## 题目背景

二叉树可以用于排序。

## 题目描述

其原理很简单：对于一个排序二叉树添加新节点时，先与根节点比较，若小则交给左子树继续处理，否则交给右子树。

当遇到空子树时，则把该节点放入那个位置。

比如，`10 8 5 7 12 4` 的输入顺序，应该建成二叉树如图 $1$ 所示。

本题目要求：根据已知的数字，建立排序二叉树，并在标准输出中横向打印该二叉树。


## 说明/提示

样例解释 1：

![](https://cdn.luogu.com.cn/upload/image_hosting/4z42ybq4.png)

时限 1 秒, 64M。蓝桥杯 2013 年第四届国赛

## 样例 #1

### 输入

```
10 8 5 7 12 4```

### 输出

```
...|-12
10-|
...|-8-|
.......|...|-7
.......|-5-|
...........|-4```

## 样例 #2

### 输入

```
10 5 20```

### 输出

```
...|-20
10-|
...|-5```

## 样例 #3

### 输入

```
5 10 20 8 4 7```

### 输出

```
.......|-20
..|-10-|
..|....|-8-|
..|........|-7
5-|
..|-4```

# AI分析结果


# 💡 Kay的C++算法解析：横向打印二叉树 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（二叉树操作与格式化输出）

🗣️ **初步分析**：
> 这道题要求我们构建二叉搜索树后横向打印，就像把树顺时针旋转90°后看到的画面。想象一下，树根在中间，右子树在上方生长，左子树在下方蔓延，每个节点通过"|-"和"-|"连接形成树状结构。
>
> - **核心思路**：所有题解都采用**右-根-左**的递归遍历顺序，配合二维字符数组预存输出结果。难点在于精确计算每个节点的位置和绘制连接线
> - **关键技巧**：
>   1. 递归时动态计算节点前的空格数量
>   2. 用全局数组记录每个节点的行号
>   3. 后处理阶段绘制垂直连接线
> - **可视化设计**：我们将用像素网格展示递归过程，当访问节点时高亮显示当前处理位置，绘制连接线时使用不同颜色，并加入8-bit风格音效（节点放置声、画线声）

---

## 2. 精选优质题解参考

**题解一（来源：冷却心）**
* **点评**：这份题解思路清晰直白，采用标准右-根-左递归遍历。亮点在于巧妙处理连接线覆盖问题——填充空格时保留已绘制的竖线(`if(mp[nowL][ind]!='|')`)。代码规范性强，宏定义`ls/rs`提升可读性，边界处理完整（根节点/叶节点特判）。实践价值高，完整包含建树到输出全流程。

**题解二（来源：Wing_）**
* **点评**：采用模块化设计，将建树与打印分离。独创的`work()`函数专门处理竖线连接，使主逻辑更清晰。结构体存储节点坐标信息，`tr[u].z`精确记录列位置。代码中`sum+3+cnt`的空格计算方式体现对输出格式的深刻理解，适合学习结构化编程思想。

**题解三（来源：ChampionCyan）**
* **点评**：特色在于用循环而非递归实现节点插入，降低栈空间消耗。`str()`函数实现简洁的整数转字符串，`front`变量精准控制前缀长度。虽然循环插入对初学者稍难理解，但87行的精简实现具有工程参考价值。

---

## 3. 核心难点辨析与解题策略

1. **节点位置计算**
   * **分析**：横向打印要求右子树在上、左子树在下，需通过递归顺序和空格计算确定行列位置。优质题解采用右-根-左顺序，配合`space+3+cnt`动态计算前缀长度
   * 💡 **学习笔记**：递归顺序决定纵向位置，空格增量决定横向对齐

2. **竖线连接处理**
   * **分析**：父子节点间的竖线需贯穿多行且不能中断。冷却心在递归返回时通过`line`数组记录的行号绘制竖线；Wing_单独设计`work()`函数处理
   * 💡 **学习笔记**：记录行号是连接关键，用`for(i=L;i>=now;i--)`循环绘制竖线

3. **输出覆盖防护**
   * **分析**：后绘制的空格可能覆盖先前的竖线。冷却心的`if(mp[nowL][ind]!='|')`判断是点睛之笔
   * 💡 **学习笔记**：二维数组填充时，已绘制的特殊符号应受保护

### ✨ 解题技巧总结
- **降维打击**：用二维字符数组处理复杂格式输出
- **递归分治**：右-根-左遍历实现倒序打印
- **状态记录**：全局变量跟踪当前行号(line数组)
- **边界艺术**：根节点无"|-"前缀，叶节点无"-|"后缀

---

## 4. C++核心代码实现赏析

**通用核心实现参考**
* **说明**：综合冷却心与Wing_的解法，保留核心逻辑
```cpp
const int N = 110;
char mp[N*10][N*10];       // 输出画布
int tree[N*4], line[N*4];  // 树数组&行号记录
int nowL;                  // 当前行计数器

void buildTree(int x, int p) {
    while(tree[p] != -1) 
        p = (x < tree[p]) ? p*2 : p*2+1;
    tree[p] = x;
}

void printTree(int p, int space) {
    if(tree[p] == -1) return;
    string num = to_string(tree[p]);
    int add = (p==1 ? 0 : 2) + num.size() + 1;
    
    printTree(p*2+1, space+add); // 先右子树
    
    ++nowL; line[p] = nowL;
    int idx = 0;
    for(int i=1; i<=space; ++i)  // 绘制前缀
        if(mp[nowL][idx+1] != '|') 
            mp[nowL][++idx] = '.';
    
    if(p != 1) mp[nowL][++idx] = '|', mp[nowL][++idx] = '-'; // 非根前缀
    for(char c : num) mp[nowL][++idx] = c;  // 写数字
    if(tree[p*2]!=-1 || tree[p*2+1]!=-1)    // 非叶后缀
        mp[nowL][++idx] = '-', mp[nowL][++idx] = '|';
    
    printTree(p*2, space+add); // 后左子树
    
    // 绘制竖线
    if(tree[p*2]!=-1) 
        for(int i=line[p]; i<=line[p*2]; ++i)
            mp[i][idx-1] = '|';
    if(tree[p*2+1]!=-1)
        for(int i=line[p*2+1]; i<=line[p]; ++i)
            mp[i][idx-1] = '|';
}
```

**题解一段落赏析**

**题解一（冷却心）**
* **亮点**：竖线防覆盖的精妙实现
```cpp
// 填充时空格时保护竖线
for(int i=1; i<=space; i++)
    if(mp[nowL][++idx] != '|') 
        mp[nowL][idx] = '.';
```
* **代码解读**：遍历每个字符位时，先检查该位置是否已有竖线。没有时才填充为点，避免覆盖已绘制的连接线。这解决了多级子树连接线交叉时的覆盖问题
* 💡 **学习笔记**：二维画布填充需考虑绘制顺序和内容保护

**题解二（Wing_）**
* **亮点**：分离式竖线处理函数
```cpp
void work(int u) {
    if(!u) return;
    if(tr[u].r) // 连接右子节点
        for(int i=tr[tr[u].r].h; i<=tr[u].h; i++)
            mp[i][tr[tr[u].r].z-2] = '|';
    if(tr[u].l) // 连接左子节点
        for(int i=tr[u].h; i<=tr[tr[u].l].h; i++)
            mp[i][tr[tr[u].l].z-2] = '|';
}
```
* **代码解读**：通过`tr[u].z`记录的列坐标和`tr[u].h`记录的行坐标，在父子节点间循环绘制竖线。分离处理使主逻辑更清晰
* 💡 **学习笔记**：独立功能模块化提升代码可维护性

---

## 5. 算法可视化：像素动画演示

### 像素探险家：二叉树横向打印之旅
**设计思路**：采用8-bit复古风格，将输出平面转化为像素网格。节点变为发光方块，连接线为闪烁光路，配合经典电子音效

**动画流程**：
1. **场景初始化**（FC红白机风格）
   - 左侧：传统二叉树视图（根在上）
   - 右侧：空白网格（400×400像素）
   - 控制面板：步进/播放/速度滑块

2. **节点绘制阶段**（伴随"嘟"声）
   ```mermaid
   graph LR
   A[递归右子树] --> B[绘制当前节点]
   B --> C[递归左子树]
   ```
   - 高亮当前递归路径（黄色边框）
   - 数字填入像素方块（绿色）
   - 播放合成音效：数字放置（方波短音）

3. **连接线绘制阶段**（伴随"嘀"声）
   - 父子节点间绘制蓝色竖线（垂直移动光效）
   - 叶节点触发星星闪烁特效
   - 播放连续音效（锯齿波）

4. **自动演示模式**
   - 树形结构顺时针旋转90°（补间动画）
   - 网格上逐节点绘制（速度可调）
   - 完成时播放胜利旋律（8-bit和弦）

**技术细节**：
- 关键帧控制：每节点绘制后暂停200ms
- 音效映射：Canvas API+Web Audio
- 连接线算法：
  ```js
  function drawVerticalLine(startY, endY, x) {
    for(let y=startY; y<=endY; y++){
      ctx.fillStyle = '#00FFFF';
      ctx.fillRect(x*20, y*20, 2, 20);
      playSound('beep', 50+(y-startY)*5); // 音调渐变
    }
  }
  ```

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**
- 树形结构特殊输出：Z字层序/对角线打印
- 递归空间优化：尾递归/迭代法
- 二维画布处理：控制台图形化输出

**洛谷推荐**：
1. **P1305 新二叉树**  
   → 巩固二叉树构建与基础遍历
2. **P1038 神经网络**  
   → 练习树形结构在动态规划中的应用
3. **P3379 最近公共祖先**  
   → 深化对树结构的理解

---

## 7. 学习心得与经验分享

> **冷却心的调试经验**：  
> *"填充空格时发现竖线被覆盖，通过`if(mp[nowL][ind]!='|')`解决"*
>
> **Kay的点评**：这反映了二维输出中图层管理的核心思想——后绘制内容可能覆盖先绘制的。解决思路具有普适性，可推广到图形界面开发

> **Wing_的设计心得**：  
> *"分离建树与打印模块，专设work()处理连接线"*
>
> **Kay的点评**：模块化设计是复杂系统开发的黄金准则。该实践体现了关注点分离原则，值得在大型项目中推广应用

---

通过这趟二叉树探索之旅，我们不仅掌握了特殊打印技巧，更学习了递归设计、状态管理和输出优化等核心编程思想。记住，优秀的程序员既是建筑师也是艺术家——用严谨逻辑构建结构，用巧妙设计呈现美感！🚀

---
处理用时：178.41秒
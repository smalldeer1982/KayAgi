# 题目信息

# [蓝桥杯 2022 国 C] 打折

## 题目描述

小蓝打算采购 $n$ 种物品，每种物品各需要 $1$ 个。

小蓝所住的位置附近一共有 $m$ 个店铺，每个店铺都出售着各种各样的物品。

第 $i$ 家店铺会在第 $s_i$ 天至第 $t_i$ 天打折，折扣率为 $p_i$，对于原件为 $b$ 的物品，折后价格为 $\lfloor\frac {b\cdot p_j}{100}\rfloor$。其它时间需按原价购买。

小蓝很忙，他只能选择一天的时间去采购这些物品。请问，他最少需要花多少钱才能买到需要的所有物品。

题目保证小蓝一定能买到需要的所有物品。

## 说明/提示

对于 $40\%$ 的评测用例，$n,m≤500，s_i ≤t_i ≤100，\sum c_i ≤2000$；

对于 $70\%$ 的评测用例，$n,m≤5000，\sum c_i ≤20000$；

对于所有评测用例，$1 ≤ n,m ≤ 10^5，1 ≤ c_i ≤ n，\sum c_i ≤ 4\times10^5，1 ≤ s_i ≤t_i ≤10^9，1 < p_i < 100，1≤a_j ≤n，1≤b_j ≤10^9$。

蓝桥杯 2022 国赛 C 组 I 题。

## 样例 #1

### 输入

```
2 2
1 2 89 1
1 97
3 4 77 1
2 15```

### 输出

```
101```

# AI分析结果


# 💡 Kay的C++算法解析：打折 深入学习指南 💡

> 想象你是一位游戏玩家，要在不同商店购买装备。每家商店有特定打折时段，你需要选择一天购买所有装备，使总花费最少。这就像在时间轴上寻找最优购物日！接下来，我将通过像素游戏化演示帮你直观理解解题过程。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`离散化 + 扫描线 + 数据结构维护`

🗣️ **初步分析**：
> 解决本题的核心在于**动态维护每个物品在时间轴上的最低价格**。就像在复古游戏中实时更新装备价格表：
> - **离散化**：将大范围时间（10^9天）压缩成关键事件点（商店打折开始/结束）
> - **扫描线**：像游戏关卡推进般按时间顺序处理事件
> - **数据结构**：用多集合(multiset)为每个装备维护价格清单，快速获取最低价
> 
> **可视化设计**：
> - 横向时间轴像素卷轴展示关键事件点
> - 每个物品用垂直价格柱表示，高度反映价格
> - 事件触发时播放"叮"音效，价格柱动态伸缩
> - 总花费进度条实时更新，找到最小值时播放胜利音效

---

## 2. 精选优质题解参考

**题解一 (来源：Graph)**
* **点评**：
  - 思路清晰：通过离散化时间+事件扫描线，逻辑直白易懂
  - 代码规范：变量名如`startD`/`endD`含义明确，边界处理严谨
  - 算法高效：利用multiset的O(log n)查询维护最小值，总复杂度O(C log C)（C为总物品数）
  - 实践价值：完整处理了multiset删除重复元素的细节，可直接用于竞赛

---

## 3. 核心难点辨析与解题策略

1.  **时间离散化处理**
    * **分析**：原始时间范围达10^9天，需提取关键事件点（打折开始s_i和结束t_i+1）。通过排序+去重，将时间压缩为O(m)量级的关键点
    * 💡 **学习笔记**：离散化是处理大范围数据的金钥匙

2.  **物品价格动态维护**
    * **分析**：每个物品需维护可用价格集合。使用multiset自动排序，快速获取最小值。当事件发生时：
      - 打折开始：加入折后价
      - 打折结束：移除折后价
    * 💡 **学习笔记**：multiset的begin()即最小值，但删除时需注意重复元素

3.  **总花费高效更新**
    * **分析**：不必每次重算所有物品，只需计算受事件影响的物品：
      ```math
      Δ总花费 = (新最低价 - 旧最低价)
      ```
    * 💡 **学习笔记**：增量更新是优化关键

### ✨ 解题技巧总结
- **事件驱动思维**：将问题转化为开始/结束事件处理
- **STL妙用**：multiset维护有序集合，优先队列处理最值
- **增量计算**：仅更新受影响部分避免全量重算

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：基于Graph题解优化，突出核心逻辑
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXM = 4e5 + 5; // 适配∑c_i ≤4e5

int main() {
    // 输入与离散化准备
    int n, m; cin >> n >> m;
    vector<int> timePoints;
    vector<tuple<int, int, int>> shops; // (s,t,p)

    // 为每个物品建立价格集合
    vector<multiset<long long>> itemPrices(n+1);
    vector<vector<pair<int, int>>> startEvents, endEvents;

    /* 输入处理与离散化 (具体实现略) */

    // 初始化：所有物品原价
    long long totalCost = 0;
    for (int i = 1; i <= n; ++i) {
        totalCost += *itemPrices[i].begin();
    }

    // 扫描时间轴
    long long minCost = totalCost;
    for (int i = 0; i < timePoints.size(); ++i) {
        for (auto [item, price] : startEvents[i]) {
            long long oldMin = *itemPrices[item].begin();
            itemPrices[item].insert(price);
            long long newMin = *itemPrices[item].begin();
            totalCost += (newMin - oldMin);
        }
        
        for (auto [item, price] : endEvents[i]) {
            long long oldMin = *itemPrices[item].begin();
            // 安全删除：仅移除一个副本
            auto it = itemPrices[item].find(price);
            if (it != itemPrices[item].end()) 
                itemPrices[item].erase(it);
                
            long long newMin = *itemPrices[item].begin();
            totalCost += (newMin - oldMin);
        }
        
        minCost = min(minCost, totalCost);
    }
    cout << minCost;
}
```
* **代码解读概要**：
  > 1. **离散化**：收集所有时间点压缩为timePoints  
  > 2. **事件分类**：startEvents/endEvents存储每个离散时间点的事件  
  > 3. **增量更新**：事件触发时仅更新受影响物品的min值  
  > 4. **安全删除**：find+erase确保只删一个价格副本

---

**题解片段赏析 (Graph实现)**

* **亮点**：优雅处理multiset删除重复元素
* **核心代码片段**：
```cpp
int t = st[x].count(y);  // 统计相同价格数量
st[x].erase(y);         // 删除所有该价格
for (int j = 1; j < t; j++) 
    st[x].insert(y);    // 重新插入t-1个
```
* **代码解读**：
  > 当需要从multiset删除特定价格时：
  > 1. `count(y)`获取该价格出现次数
  > 2. `erase(y)`会删除**所有**y副本 → 错误！
  > 3. 重新插入`t-1`个副本 → 等效删除一个
  > 🎮 就像从装备栏移除一件装备，避免误删整套装备

* 💡 **学习笔记**：multiset的erase(value)会删除所有等值元素，需配合计数使用

-----

## 5. 算法可视化：像素动画演示

**主题**：《时间商人》像素购物模拟  
**核心演示**：时间轴扫描中商品价格波动与总花费变化  

### 动画设计  
```plaintext
[像素画布布局]
|----------------------- 时间轴(横向卷轴) --------------------|
| 事件点标记: ★(打折开始) ☆(打折结束)                        |
|                                                           |
| 物品价格柱: [▓▓▓]  [▓]  [▓▓▓▓]  高度=价格 (配色区分物品)   |
| 总花费进度条: ████████[最小值标记▼]████████                |
```

### 关键交互  
1. **初始化场景**  
   - 8-bit风格背景音乐  
   - 所有物品显示原价柱状图  

2. **时间推进**（点击/自动播放）  
   - 时间轴指针向右移动，触发事件点时闪烁★/☆  
   - 受影响的物品价格柱伸缩：  
     ```javascript
     // 伪代码：打折开始事件
     playSound("discount_start.wav"); // 8-bit音效
     itemBar.scaleTo(newHeight);       // 价格柱动画
     totalCostBar.update();            // 总花费进度条更新
     ```

3. **动态效果**  
   - 当前处理物品高亮闪烁  
   - 总花费低于历史最小值时：  
     - 显示"New Record!"像素文字  
     - 播放胜利音效  

4. **控制面板**  
   - 速度滑块：调节时间推进速度
   - 单步执行：逐事件调试
   - 重置：回到初始状态

### 教学价值  
> 通过动态价格柱变化，直观理解：  
> - 事件如何影响单个物品价格  
> - 增量更新如何避免全量重算  
> - 最小值随时间的波动规律  

---

## 6. 拓展练习与相似问题思考

### 相似问题模式  
1. **区间更新+最值查询**：多个区间影响状态，动态查询全局最优  
2. **事件驱动模拟**：时间轴上有启动/结束事件需要处理  
3. **离散化应用**：大范围数据映射到有限关键点  

### 洛谷推荐  
1. **P1886 滑动窗口**  
   → 掌握单调队列维护区间最值  
2. **P1904 天际线**  
   → 强化扫描线处理建筑轮廓  
3. **P2280 [HNOI2003]激光炸弹**  
   → 练习二维离散化与前缀和  

---

## 7. 学习心得与经验分享
> 关键调试经验：当multiset删除元素后最小值异常时  
> - 检查是否误删所有相同价格（常见错误）  
> - 用`count()`验证元素存在性  
> - 删除前打印集合内容可视化验证  

---

通过本次分析，相信你已经掌握时间离散化与动态维护的技巧。记住在竞赛中遇到类似问题时，先思考：**能否转化为事件扫描？如何增量更新状态？** 保持思考，编程之旅将充满乐趣！🎮🚀

---
处理用时：203.68秒
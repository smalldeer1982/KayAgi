# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果


### 💡 Kay的C++算法解析：铺放矩形块 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`枚举与模拟`  
🗣️ **初步分析**：
> 解决"铺放矩形块"的关键在于**枚举所有排列组合**并**模拟6种基本摆放方案**。就像玩俄罗斯方块，我们需要尝试所有旋转和位置组合，找出最小"容器"。  
> - **核心思路**：枚举4个矩形的排列顺序（24种）和每个矩形的方向（横/竖，16种），对每种组合计算6种基本方案的封闭矩形尺寸  
> - **核心难点**：第六种方案的复杂分情况处理（需考虑矩形高度关系）  
> - **可视化设计**：将用像素动画展示矩形移动过程，高亮当前操作的矩形（闪烁效果），实时显示封闭矩形边界（红色虚线框）。采用8位机风格，矩形移动时触发"放置音效"，完成方案时播放胜利音效。

---

#### 2. 精选优质题解参考
**题解一（七喜）**  
* **点评**：DFS生成排列的思路清晰，将4/5方案合并展示代码优化意识。变量名`tmpx/tmpy`直观，边界处理用`alter()`函数封装提高复用性。虽然第六种情况的条件判断较复杂，但注释详细帮助理解。实践价值高，代码可直接用于竞赛。

**题解二（Chiesl）**  
* **点评**：6种方案图解和公式推导极为清晰，状态记录用`ans[]`数组避免重复输出。代码模块化（独立check函数），DFS中方向切换逻辑简洁（swap+回溯）。调试技巧值得学习：通过可视化注释辅助理解复杂情况。

**题解三（Fijian_Bus）**  
* **点评**：next_permutation+位运算枚举方向高效优雅（减少递归开销）。pack1-5函数独立封装，第六种情况分5个子类处理严谨。亮点是轻量化实现：仅用160行完成核心逻辑，输出处理用pair自动排序去重。

---

#### 3. 核心难点辨析与解题策略
1. **难点：排列与方向的组合爆炸**  
   * **分析**：4!×2⁴=384种组合需高效枚举。优质解法用DFS/next_permutation+位运算避免冗余  
   * 💡 **学习笔记**：排列问题优先考虑STL的next_permutation

2. **难点：第六种方案的分支处理**  
   * **分析**：需根据矩形高度关系分4种子情况推导公式（如h3≥h1+h4时宽度计算不同）  
   * 💡 **学习笔记**：复杂逻辑先画图建模，再转化为条件判断

3. **难点：去重与输出格式**  
   * **分析**：相同面积可能对应多组长宽，需用set存储并排序输出  
   * 💡 **学习笔记**：利用set自动去重，pair存储长宽便于排序

✨ **解题技巧总结**  
- **模块化分解**：每种摆放方案独立函数实现（如part1~6）  
- **方向统一处理**：枚举时统一交换长宽替代旋转计算  
- **边界防御**：面积相等时立即记录，避免最优解遗漏

---

#### 4. C++核心代码实现赏析
```cpp
// 通用核心实现（综合题解精华）
#include <iostream>
#include <algorithm>
#include <set>
#include <climits>
using namespace std;

int x[5], y[5], tmpX[5], tmpY[5];
int minArea = INT_MAX;
set<pair<int, int>> solutions; // 存储所有解

void update(int a, int b) {
    if (a > b) swap(a, b);
    int area = a * b;
    if (area < minArea) {
        minArea = area;
        solutions.clear();
    }
    if (area == minArea) 
        solutions.insert({a, b});
}

// 六种摆放方案计算
void check() {
    // 方案1：四矩形横排
    int a = tmpX[1] + tmpX[2] + tmpX[3] + tmpX[4];
    int b = max({tmpY[1], tmpY[2], tmpY[3], tmpY[4]});
    update(a, b);
    
    // 方案2：三横一竖（省略其他方案）
    // ... 其他方案实现
}

void dfs(int step) {
    if (step > 4) { check(); return; }
    for (int i = 1; i <= 4; ++i) {
        if (!used[i]) {
            used[i] = true;
            // 尝试两种方向
            tmpX[step] = x[i]; tmpY[step] = y[i]; dfs(step + 1);
            tmpX[step] = y[i]; tmpY[step] = x[i]; dfs(step + 1);
            used[i] = false;
        }
    }
}
```

**题解一精华（七喜）**  
* **亮点**：DFS排列生成 + 方向切换回溯  
* **核心片段**：
```cpp
void dfs(int step) {
    if(step==4) { check(); return; }
    for(int i=1;i<=4;i++){
        if(!vis[i]){
            tmpx[step+1]=x[i]; // 不旋转
            tmpy[step+1]=y[i];
            dfs(step+1);
            tmpx[step+1]=y[i]; // 旋转90°
            tmpy[step+1]=x[i];
            dfs(step+1);
        }
    }
}
```
> **解读**：通过递归实现全排列，每次递归分不旋转/旋转两种状态。`vis[]`保证不重复选择

**题解二精华（Chiesl）**  
* **亮点**：结构化方案计算 + set自动去重  
* **核心片段**：
```cpp
void check() {
    // 方案6分情况处理
    if(h3>=h1+h4) 
        width = max(w2, w4+max(w1,w3));
    else if(...) // 其他三种情况
    ...
    update(width, height);
}
```
> **解读**：将最复杂的方案6分解为4种子情况，每种对应不同的宽度计算公式

---

### 5. 算法可视化：像素动画演示
**主题**："矩形拼图挑战" 8位机风格  
**设计思路**：  
1. **初始化界面**  
   - 4色矩形像素块（16×16）置于右侧待选区  
   - 控制面板：方案选择/步进控制/速度滑块  
   ![](https://fakeimg.pl/200x100/00ff00/000/?text=控制面板)

2. **动态演示流程**（以方案1为例）  
   ```plain
   帧1: [红块] 从右侧滑入(0,0)位置 → 音效: 咔哒声
   帧2: [蓝块] 滑入相邻位置 → 显示当前宽度累加值
   帧3: [黄块][绿块] 同时滑入 → 虚线框扩展为最终边界
   ```

3. **第六种方案特效**  
   - 高度比较时触发对比动画：高矩形闪烁红光，矮矩形闪烁蓝光  
   - 分情况演示：用不同颜色路径线区分4种子情况

4. **游戏化元素**  
   - 每完成一种方案解锁成就徽章（像素风）  
   - 连续完成3种方案触发"Combo!"特效+奖励音效

> **技术实现**：Canvas绘制矩形移动路径，requestAnimationFrame控制帧率，Web Audio API播放8bit音效

---

#### 6. 拓展练习与相似问题
1. **通用技巧迁移**  
   - 二维布局：P1189 搜索房间布局  
   - 状态枚举：P1219 八皇后问题  
   - 复杂模拟：P2690 接苹果

2. **洛谷推荐**  
   - P5917 [双倍经验]铺放矩形块 → 巩固枚举技巧  
   - P1242 新汉诺塔 → 训练状态空间搜索能力  
   - P1379 八数码 → 学习BFS+状态压缩

---

#### 7. 学习心得与经验分享
> **作者七喜的经验**："第六种情况的分支判断极易遗漏边界条件，通过绘制高度关系图辅助编码"  
> **Kay的总结**：调试复杂逻辑时，将条件判断转化为可视化图表（如高度比较图）能有效避免逻辑漏洞。建议多用纸笔模拟边界情况（如h3=h4时）

---

**结语**：本题通过枚举+模拟的组合拳，锻炼了多维问题分解能力。记住：复杂算法都是由简单模块组合而成！下次我们将挑战更炫酷的算法拼图！💪

---
处理用时：187.97秒
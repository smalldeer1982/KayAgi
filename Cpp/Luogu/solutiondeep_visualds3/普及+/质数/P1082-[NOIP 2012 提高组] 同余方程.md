# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果



---
# 💡 Kay的C++算法解析：同余方程 深入学习指南 💡

<introduction>
今天我们来一起分析“同余方程”这道C++编程题。题目要求我们找到关于 \( x \) 的同余方程 \( ax \equiv 1 \pmod{b} \) 的最小正整数解。本指南将帮助大家理解核心算法、掌握解题技巧，并通过可视化动画直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扩展欧几里得算法（exgcd）与欧拉定理的应用

🗣️ **初步分析**：
解决这道题的关键在于理解“模逆元”的概念。模逆元是指满足 \( ax \equiv 1 \pmod{b} \) 的 \( x \)，它存在的条件是 \( a \) 和 \( b \) 互质（即 \( \gcd(a, b) = 1 \)）。  
- **扩展欧几里得算法**：可以理解为“升级版的辗转相除法”，它不仅能计算 \( \gcd(a, b) \)，还能找到满足 \( ax + by = \gcd(a, b) \) 的整数 \( x, y \)。当 \( \gcd(a, b) = 1 \) 时，这里的 \( x \) 就是我们要找的解。  
- **欧拉定理**：若 \( a \) 和 \( b \) 互质，则 \( a^{\varphi(b)} \equiv 1 \pmod{b} \)（\( \varphi(b) \) 是欧拉函数，表示小于 \( b \) 且与 \( b \) 互质的数的个数）。因此 \( x = a^{\varphi(b)-1} \pmod{b} \) 也是解。

**核心难点**：  
1. 扩展欧几里得的递归过程（如何从底层解反推上层解？）  
2. 解的调整（求出的 \( x \) 可能是负数或超过 \( b \)，如何得到最小正整数解？）  
3. 欧拉函数的计算（需要质因数分解 \( b \)）。

**可视化设计思路**：  
我们将用8位像素风格动画演示扩展欧几里得的递归过程：  
- 用像素方块表示 \( a, b \) 的值，每一步递归时 \( a, b \) 变为 \( b, a \bmod b \)，并伴随“叮”的音效。  
- 解 \( x, y \) 用动态数字显示，递归回溯时通过箭头指示 \( x, y \) 的更新（如 \( x \leftarrow y_{\text{下层}}, y \leftarrow x_{\text{下层}} - \lfloor a/b \rfloor \cdot y_{\text{下层}} \)）。  
- 最终解调整时，用闪烁动画展示 \( x = (x \bmod b + b) \bmod b \) 的计算过程，成功时播放“胜利”音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下3道题解最值得参考：
</eval_intro>

**题解一：学委的题解（来源：用户“学委”，赞1483）**  
* **点评**：这道题解对扩展欧几里得算法的推导极其详细，从问题转化（\( ax \equiv 1 \pmod{b} \) 等价于 \( ax + by = 1 \)）到递归过程（如何从底层 \( b=0 \) 的解反推上层解），再到解的调整（\( x = (x \bmod b + b) \bmod b \)），每一步都解释得非常透彻。代码中变量命名清晰（如 `exgcd` 函数直接体现扩展欧几里得），边界条件处理严谨（如 \( b=0 \) 时 \( x=1, y=0 \)），是学习扩展欧几里得算法的绝佳模板。

**题解二：沙普绿12138的题解（来源：用户“沙普绿12138”，赞103）**  
* **点评**：这道题解另辟蹊径，使用欧拉定理求解。通过 \( a^{\varphi(b)} \equiv 1 \pmod{b} \) 推导出 \( x = a^{\varphi(b)-1} \pmod{b} \)，思路新颖。代码中 `fai` 函数（计算欧拉函数）和 `fast_pow` 函数（快速幂）实现简洁，适合理解欧拉定理的应用场景。虽然计算欧拉函数需要质因数分解，但对于 \( b \) 较大的情况（如 \( 2 \times 10^9 \)），复杂度仍可接受。

**题解三：陈曦的题解（来源：用户“陈曦”，赞71）**  
* **点评**：这道题解对比了暴力、快速幂、扩展欧几里得三种方法，明确指出暴力法的局限性（超时）和快速幂法的条件（\( b \) 为质数），最终重点讲解扩展欧几里得法。代码中 `exgcd` 函数通过递归实现，逻辑清晰，特别是解的调整部分（\( (x + m) \% m \)）直接给出了最小正整数解的关键步骤，适合新手理解不同方法的优劣。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们可能会遇到以下核心难点，结合优质题解的共性，我们逐一分析：
</difficulty_intro>

1.  **关键点1：扩展欧几里得的递归逻辑**  
    * **分析**：扩展欧几里得的核心是递归求解 \( bx_2 + (a \bmod b)y_2 = \gcd(a, b) \)，再通过 \( x = y_2, y = x_2 - \lfloor a/b \rfloor \cdot y_2 \) 反推上层解。例如，当 \( b=0 \) 时，\( \gcd(a, 0) = a \)，此时 \( x=1, y=0 \) 是底层解。递归回溯时，每一步的 \( x, y \) 都依赖于下层的 \( x_2, y_2 \)。  
    * 💡 **学习笔记**：递归的终点是 \( b=0 \)，此时 \( x=1 \) 是关键；回溯时通过 \( x, y \) 的更新公式传递解。

2.  **关键点2：解的调整（求最小正整数解）**  
    * **分析**：扩展欧几里得求出的 \( x \) 可能是负数或大于 \( b \)，需要调整。根据同余性质，所有解的形式是 \( x + k \cdot b \)（\( k \in \mathbb{Z} \)），因此最小正整数解为 \( (x \bmod b + b) \bmod b \)（先取模处理负数，再加 \( b \) 保证结果非负）。  
    * 💡 **学习笔记**：模运算的调整是确保解为最小正整数的关键，公式 \( (x \% b + b) \% b \) 能处理所有情况。

3.  **关键点3：欧拉函数的计算（针对欧拉定理解法）**  
    * **分析**：欧拉函数 \( \varphi(b) \) 的计算需要对 \( b \) 进行质因数分解。例如，若 \( b = p_1^{k_1} p_2^{k_2} \dots p_n^{k_n} \)，则 \( \varphi(b) = b \cdot \prod_{i=1}^n (1 - 1/p_i) \)。代码中通过遍历质因数并累乘 \( (p-1) \cdot p^{k-1} \) 实现。  
    * 💡 **学习笔记**：质因数分解是计算欧拉函数的基础，需注意处理剩余的大质数（如 \( b \) 分解后剩余的大于 \( \sqrt{b} \) 的质数）。

### ✨ 解题技巧总结
- **问题转化**：将同余方程 \( ax \equiv 1 \pmod{b} \) 转化为线性不定方程 \( ax + by = 1 \)，利用扩展欧几里得求解。  
- **递归理解**：扩展欧几里得的递归过程与辗转相除法一致，每一步缩小问题规模，最终通过回溯得到解。  
- **边界处理**：计算欧拉函数时，若质因数分解后 \( b > 1 \)，说明剩余一个大质数，需额外处理。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看一个基于扩展欧几里得算法的通用核心实现，它综合了优质题解的思路，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自“学委”的题解，因其对扩展欧几里得的推导和实现最为完整，且解的调整步骤明确，适合作为通用参考。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    long long x, y; // 存储方程的解

    void exgcd(long long a, long long b) {
        if (b == 0) { // 递归终点：b=0时，a是gcd，解为x=1, y=0
            x = 1;
            y = 0;
            return;
        }
        exgcd(b, a % b); // 递归求解子问题
        long long tx = x; // 临时保存下层的x
        x = y; // 当前x = 下层的y
        y = tx - a / b * y; // 当前y = 下层的x - (a/b)*下层的y
    }

    int main() {
        long long a, b;
        cin >> a >> b;
        exgcd(a, b);
        // 调整解为最小正整数：(x % b + b) % b 确保结果在[1, b-1]
        x = (x % b + b) % b;
        cout << x << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码通过递归实现扩展欧几里得算法。`exgcd` 函数首先处理递归终点（\( b=0 \)），然后递归求解子问题 \( \gcd(b, a \bmod b) \)，回溯时更新 \( x, y \)。主函数中读取输入后调用 `exgcd`，最后调整 \( x \) 为最小正整数解。

---
<code_intro_selected>
接下来，我们分析优质题解中的核心代码片段，学习不同解法的亮点。
</code_intro_selected>

**题解一：学委的题解（扩展欧几里得）**  
* **亮点**：递归过程清晰，解的调整步骤明确，适合理解扩展欧几里得的本质。  
* **核心代码片段**：
    ```cpp
    void exgcd(long long a, long long b) {
        if (b == 0) {
            x = 1;
            y = 0;
            return;
        }
        exgcd(b, a % b);
        long long tx = x;
        x = y;
        y = tx - a / b * y;
    }
    ```
* **代码解读**：  
  这段代码是扩展欧几里得的核心递归逻辑。当 \( b=0 \) 时，\( \gcd(a, 0) = a \)，因此 \( x=1, y=0 \) 是方程 \( ax + by = a \) 的解。递归调用 `exgcd(b, a % b)` 后，下层的 \( x, y \) 是子问题 \( bx_2 + (a \bmod b)y_2 = \gcd(a, b) \) 的解。通过 \( x = y_2 \) 和 \( y = x_2 - \lfloor a/b \rfloor \cdot y_2 \)，将子问题的解转换为原问题的解。  
* 💡 **学习笔记**：递归的每一步都在缩小 \( a, b \) 的规模，最终通过回溯传递解，这是扩展欧几里得的核心思想。

**题解二：沙普绿12138的题解（欧拉定理+快速幂）**  
* **亮点**：利用欧拉定理避免递归，适合理解逆元的另一种求法。  
* **核心代码片段**：
    ```cpp
    int fai(int n) { // 计算欧拉函数φ(n)
        int ans = 1;
        for (int i = 2; i * i <= n; ++i) {
            if (n % i == 0) {
                n /= i;
                ans *= i - 1;
                while (n % i == 0) {
                    n /= i;
                    ans *= i;
                }
            }
        }
        if (n > 1) ans *= n - 1;
        return ans;
    }

    int fast_pow(int x, int k) { // 快速幂计算x^k mod b
        ll ans = 1, quan = x;
        while (k) {
            if (k & 1) ans = ans * quan % b;
            quan = quan * quan % b;
            k >>= 1;
        }
        return (int)ans;
    }
    ```
* **代码解读**：  
  `fai` 函数通过质因数分解计算欧拉函数。例如，若 \( n = p^k \)，则 \( \varphi(n) = p^k - p^{k-1} = p^{k-1}(p-1) \)。遍历质因数 \( i \)，每次分解出 \( i \) 的幂次，并更新 \( ans \)。`fast_pow` 函数通过二进制拆分指数，快速计算模幂，时间复杂度 \( O(\log k) \)。  
* 💡 **学习笔记**：欧拉定理适用于 \( a, b \) 互质的情况，当 \( b \) 较大时，质因数分解的效率是关键。

**题解三：陈曦的题解（扩展欧几里得简化版）**  
* **亮点**：代码简洁，直接给出扩展欧几里得的核心递归，适合快速实现。  
* **核心代码片段**：
    ```cpp
    inline void exgcd(int a, int b) {
        if (b == 0) { x = 1; y = 0; return; }
        exgcd(b, a % b);
        int k = x; x = y; y = k - a / b * y;
    }
    ```
* **代码解读**：  
  这段代码与学委的实现类似，但更简洁。递归终点同样是 \( b=0 \)，回溯时通过临时变量 \( k \) 保存下层的 \( x \)，然后更新 \( x \) 和 \( y \)。主函数中调用后调整 \( x \) 为最小正整数解。  
* 💡 **学习笔记**：扩展欧几里得的递归实现可以非常简洁，关键是理解 \( x, y \) 的更新公式。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解扩展欧几里得算法的递归过程，我们设计一个“像素探险家”主题的8位像素动画，模拟算法如何一步步找到逆元。
</visualization_intro>

  * **动画演示主题**：像素探险家的逆元冒险  
  * **核心演示内容**：扩展欧几里得算法从 \( (a, b) \) 开始，递归缩小到 \( (b, a \bmod b) \)，最终在 \( b=0 \) 时找到底层解，再回溯更新 \( x, y \)，最后调整 \( x \) 为最小正整数解。

  * **设计思路简述**：  
    采用8位像素风格（类似FC游戏），用不同颜色的方块表示 \( a, b \) 的值，动态箭头表示递归方向，数字显示 \( x, y \) 的变化。关键步骤（如递归调用、解更新）伴随“叮”的音效，成功找到解时播放“胜利”音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧显示“当前 \( a, b \)”（像素字体），右侧显示“当前 \( x, y \)”（初始为？？）。  
        - 控制面板包含“单步”“自动播放”“重置”按钮，速度滑块（1-5倍速）。  
        - 播放8位风格的轻快背景音乐（如《超级玛丽》主题变奏）。

    2.  **递归启动**：  
        - 输入 \( a=3, b=10 \)（样例输入），点击“开始”，箭头从 \( (3, 10) \) 指向 \( (10, 3 \bmod 10=3) \)，\( a, b \) 变为 \( 10, 3 \)，播放“入栈”音效（短促的“叮”）。  
        - 队列区显示递归调用栈（类似《魂斗罗》的子弹槽），每递归一层添加一个方块。

    3.  **递归深入**：  
        - 下一步，\( a=10, b=3 \)，计算 \( 10 \bmod 3 = 1 \)，箭头指向 \( (3, 1) \)，\( a, b \) 变为 \( 3, 1 \)。  
        - 继续递归：\( a=3, b=1 \)，\( 3 \bmod 1 = 0 \)，箭头指向 \( (1, 0) \)，此时 \( b=0 \)，触发递归终点。

    4.  **递归回溯（解更新）**：  
        - 终点层 \( (1, 0) \) 的 \( x=1, y=0 \) 高亮显示，播放“叮咚”音效。  
        - 回溯到 \( (3, 1) \)：\( x = y_{\text{下层}} = 0 \)，\( y = x_{\text{下层}} - 3/1 \cdot y_{\text{下层}} = 1 - 3 \cdot 0 = 1 \)，\( x, y \) 变为 \( 0, 1 \)，伴随“回溯”音效（上升调“叮”）。  
        - 继续回溯到 \( (10, 3) \)：\( x = y_{\text{下层}} = 1 \)，\( y = x_{\text{下层}} - 10/3 \cdot y_{\text{下层}} = 0 - 3 \cdot 1 = -3 \)，\( x, y \) 变为 \( 1, -3 \)。  
        - 最后回溯到初始层 \( (3, 10) \)：\( x = y_{\text{下层}} = -3 \)，\( y = x_{\text{下层}} - 3/10 \cdot y_{\text{下层}} = 1 - 0 \cdot (-3) = 1 \)（因 \( 3/10=0 \)），此时 \( x=-3, y=1 \)。

    5.  **解调整**：  
        - 计算 \( x = (-3 \bmod 10 + 10) \bmod 10 = 7 \)，像素方块从红色（负数）变为绿色（正数），播放“胜利”音效（长音“啦”），显示“找到最小正整数解：7”。

  * **旁白提示**：  
    - （递归时）“现在，探险家进入下一层，\( a \) 和 \( b \) 变成 \( b \) 和 \( a \bmod b \)！”  
    - （回溯时）“看！下层的 \( x, y \) 被用来计算当前层的解，这就是递归的魔力！”  
    - （解调整时）“负数解？别担心，通过模运算调整，我们得到了最小的正整数解！”

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到扩展欧几里得算法如何通过递归和回溯找到解，以及解调整的关键步骤。这种游戏化的演示能帮助我们更深刻地理解算法的每一步逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的解法后，我们可以进一步探索模逆元的其他应用场景，并通过类似题目巩固知识。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    扩展欧几里得算法不仅用于求模逆元，还可求解线性不定方程 \( ax + by = c \)（当 \( \gcd(a, b) \mid c \) 时）。欧拉定理则适用于求大数的模幂，例如计算组合数取模时的逆元。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5656 二元一次不定方程**  
        * 🗣️ **推荐理由**：这道题要求求解 \( ax + by = c \) 的所有整数解，需要扩展欧几里得算法的深入应用，能帮助你理解解的结构和调整方法。
    2.  **洛谷 P3811 模意义下的乘法逆元**  
        * 🗣️ **推荐理由**：本题要求批量求 \( 1 \sim n \) 的逆元，适合练习线性求逆元的技巧（如递推法），对比扩展欧几里得和欧拉定理的效率差异。
    3.  **洛谷 P2613 有理数取余**  
        * 🗣️ **推荐理由**：这道题需要处理分数的取余，核心是求分母的逆元，适合练习逆元在实际问题中的应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试过程中的经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自用户“学委”)**：“在编写扩展欧几里得代码时，一开始忘记处理 \( y \) 的更新，导致解错误。后来通过打印每一步的 \( x, y \) 才发现问题。这让我意识到递归回溯时的变量更新必须严格按照公式。”

> **点评**：这位作者的经验提醒我们，递归算法的调试可以通过打印中间变量（如每一步的 \( x, y \)）来定位错误。特别是扩展欧几里得这种依赖回溯的算法，每一步的变量更新都需要严格验证。对于新手来说，手动模拟小例子（如样例输入 \( a=3, b=10 \)）是理解递归过程的有效方法。

-----

<conclusion>
本次关于“同余方程”的C++解题分析就到这里。希望这份指南能帮助你理解扩展欧几里得和欧拉定理的核心思想，掌握模逆元的求解方法。记住，编程的关键是理解算法的本质，而不仅仅是记忆代码。多动手模拟、调试，你会对算法有更深刻的认识！下次见~ 💪
</conclusion>

---
处理用时：211.16秒
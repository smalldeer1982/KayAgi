# 题目信息

# [NOIP 2007 提高组] 树网的核

## 题目描述

设 $T=(V,E,W)$ 是一个无圈且连通的无向图（也称为无根树），每条边都有正整数的权，我们称 $T$ 为树网（`treenetwork`），其中 $V$，$E$ 分别表示结点与边的集合，$W$ 表示各边长度的集合，并设 $T$ 有 $n$ 个结点。

路径：树网中任何两结点 $a$，$b$ 都存在唯一的一条简单路径，用 $d(a, b)$ 表示以 $a, b$ 为端点的路径的长度，它是该路径上各边长度之和。我们称 
$d(a, b)$ 为 $a, b$ 两结点间的距离。

$D(v, P)=\min\{d(v, u)\}$, $u$ 为路径 $P$ 上的结点。

树网的直径：树网中最长的路径成为树网的直径。对于给定的树网 $T$，直径不一定是唯一的，但可以证明：各直径的中点（不一定恰好是某个结点，可能在某条边的内部）是唯一的，我们称该点为树网的中心。

偏心距 $\mathrm{ECC}(F)$：树网 $T$ 中距路径 $F$ 最远的结点到路径 $F$ 的距离，即

$$\mathrm{ECC}(F)=\max\{D(v, F),v \in V\}$$

任务：对于给定的树网 $T=(V, E, W)$ 和非负整数 $s$，求一个路径 $F$，他是某直径上的一段路径（该路径两端均为树网中的结点），其长度不超过 $s$（可以等于 $s$），使偏心距 $\mathrm{ECC}(F)$ 最小。我们称这个路径为树网 $T=(V, E, W)$ 的核（`Core`）。必要时，$F$ 可以退化为某个结点。一般来说，在上述定义下，核不一定只有一个，但最小偏心距是唯一的。

下面的图给出了树网的一个实例。图中，$A-B$ 与 $A-C$ 是两条直径，长度均为 $20$。点 $W$ 是树网的中心，$EF$ 边的长度为 $5$。如果指定 $s=11$，则树网的核为路径`DEFG`（也可以取为路径`DEF`），偏心距为 $8$。如果指定 $s=0$（或 $s=1$、$s=2$），则树网的核为结点 $F$，偏心距为 $12$。

![](https://cdn.luogu.com.cn/upload/image_hosting/oms5c6rq.png)


## 说明/提示

- 对于 $40\%$ 的数据，保证 $n \le 15$。
- 对于 $70\%$ 的数据，保证 $n \le 80$。
- 对于 $100\%$ 的数据，保证 $2\le n \le 300$，$0\le s\le10^3$，$1 \leq u, v \leq n$，$0 \leq w \leq 10^3$。

NOIP2007 提高组第四题

## 样例 #1

### 输入

```
5 2
1 2 5
2 3 2
2 4 4
2 5 3
```

### 输出

```
5
```

## 样例 #2

### 输入

```
8 6
1 3 2
2 3 2 
3 4 6
4 5 3
4 6 4
4 7 2
7 8 3
```

### 输出

```
5```

# AI分析结果


### 💡 Kay的C++算法解析：树网的核 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`树的性质与双指针技巧`  
🗣️ **初步分析**：
> 树网核问题就像在树干上选一段绳圈（路径F），要求绳圈长度≤s且最远的果实（偏心距）尽可能近。核心思想是**利用树直径的性质简化问题**：  
> - 所有直径必交于一点（引理1），因此任选一条直径即可（定理2）  
> - 最优解必在直径上（引理2.2），偏心距由三部分组成（见右图）：  
>   ![](https://cdn.luogu.com.cn/upload/image_hosting/pzx0c11u.png)  
> **可视化设计**：采用8位像素风迷宫探险主题。用发光像素块标记直径（树干），红色方块表示当前路径F，黄色高亮显示当前计算的支链（如解法三的d_i），直径端点用闪烁宝箱表示。关键操作（入队/出队）触发"叮"音效，找到最优路径时播放胜利旋律。

#### 2. 精选优质题解参考
**题解一（作者：StudyingFather）**  
* **点评**：思路严谨性满分！从引理证明到四层解法递进（O(n³)→O(n)），尤其解法四利用`d_i ≤ 端点距离`性质省略单调队列，极富启发性。代码用`namespace`隔离不同解法，变量命名规范（`pres/posts`表直径前后缀和），实践时可直接套用解法四。

**题解二（作者：Mosklia）**  
* **点评**：双指针+单调队列实现O(n)的典范。亮点在于将支链最大值计算转化为滑动窗口问题，并用`deque`高效处理。代码中`cur_dist`巧妙记录相对位置，但边界处理稍复杂（需维护dist1/dist2），调试时建议画图辅助。

**题解三（作者：天泽龟）**  
* **点评**：独特二分视角，提供log级别解法。严格证明二分上下界（最长支链→直径长度），`check`函数用`drop/up`模拟半径覆盖很形象。虽代码较长，但"画圆"比喻和支链处理细节（LCA求交点）对理解树结构大有裨益。

#### 3. 核心难点辨析与解题策略
1. **难点1：偏心距的多源构成**  
   * **分析**：偏心距非单纯路径端点距离！由`max{左端残留, 右端残留, 路径上最大支链}`组成（见解法三图示）。优质题解均通过DFS预处理支链长度（`maxd[i]`）  
   * 💡 **学习笔记**：偏心距是"三维最值"，需同时考量路径左右及上方支链

2. **难点2：双指针收缩的边界**  
   * **分析**：当路径长度≤s时，左指针`i`右移会增大左残留但可能减小支链值。需证明`d_i`的非递增性（Mosklia题解Step2）  
   * 💡 **学习笔记**：双指针移动时，支链最大值变化具有单调性

3. **难点3：多直径处理的证明**  
   * **分析**：引理1证明多条直径必相交，定理2证明任意直径可得相同最小偏心距，避免重复计算  
   * 💡 **学习笔记**：树的中心是唯一锚点，任选直径即可

✨ **解题技巧总结**  
- **技巧1：降维思想** - 将树压扁为直径序列（StudyingFather的`dia[]`数组）  
- **技巧2：等效转化** - 支链最大值≤端点距离（解法四省略单调队列的关键）  
- **技巧3：虚拟操作** - 二分时想象用圆规覆盖直径（天泽龟的`drop/up`函数）  

#### 4. C++核心代码实现赏析
**通用核心实现（综合自优质题解）**  
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
struct Edge { int v, w; };
const int MAXN = 3e5+5;
vector<Edge> G[MAXN];
int dia[MAXN], maxd[MAXN], pres[MAXN], cnt;

void dfs(int u, int fa, int dep, int& endpoint) {
    if (dep > maxd[0]) endpoint = u, maxd[0] = dep;
    for (Edge e : G[u]) 
        if (e.v != fa) dfs(e.v, u, dep+e.w, endpoint);
}

void getDiameter() {
    int A = 1, B = A;
    dfs(1, 0, 0, B); // 第一次DFS找端点B
    maxd[0] = 0;
    dfs(B, 0, 0, A); // 第二次DFS从B出发
    // 回溯存储直径(B→A)
    for (int u = A; u; u = fa[u]) {
        dia[++cnt] = u;
        pres[cnt] = (cnt>1) ? pres[cnt-1] + dis[u] : 0;
    }
}

int main() {
    int n, s; cin >> n >> s;
    // 建图省略...
    getDiameter();
    int ans = INT_MAX, maxBranch = 0;
    // 预处理支链(解法四)
    for (int i = 1; i <= cnt; i++) {
        int tmp = 0;
        dfs(dia[i], 0, 0, tmp); // 求最大支链
        maxBranch = max(maxBranch, maxd[0]);
    }
    // 双指针扫描
    for (int l=1, r=1; l<=cnt; pres[l]-pres[l-1], l++) {
        while (r < cnt && pres[r+1]-pres[l] <= s) r++;
        int ecc = max(maxBranch, max(pres[l], pres[cnt]-pres[r]));
        ans = min(ans, ecc);
    }
    cout << ans;
}
```

**代码解读概要**：  
> 1. `getDiameter`：两次DFS求直径并存储到`dia[]`，`pres[]`记录前缀和  
> 2. 支链预处理：对直径上每点DFS求不经过直径的最远距离  
> 3. 双指针扫描：指针`l`、`r`维护路径，动态计算偏心距三要素  

#### 5. 算法可视化：像素动画演示
* **主题**：8位风《树洞探险》  
* **核心演示**：蓝点沿直径移动，红框表示当前路径F，黄点弹出显示支链  
  ![](https://i.imgur.com/XHdK7lD.gif)

**关键帧设计**：  
1. **初始化**：树化为绿色像素网格，直径发蓝光，支链末端为金色果实  
2. **指针移动**：  
   - `l`指针左移：左侧残留段变红，播放"滋滋"电流声  
   - `r`指针右移：右侧残留段变紫，触发鼓点音效  
3. **支链计算**：点击直径点触发"探照灯"效果，光照支链显示长度值  
4. **答案更新**：找到更优路径时，路径F闪烁绿光，播放胜利音阶  

**伪代码逻辑**：  
```python
while l <= len(diameter):
   draw_highlight(dia[l], RED)
   while r < n and dist(l,r+1) <= s:
      r += 1
      draw_highlight(dia[r], PURPLE)
      play_sound("drum")
   ecc = max(branch_max, dist(start,l), dist(r,end))
   if ecc < best: 
      best = ecc
      flash_path(dia[l:r], GREEN)
   l += 1
```

#### 6. 拓展练习与相似问题
1. **技巧迁移**：  
   - 动态求树直径中心：P5536 【XR-3】核心城市  
   - 带权路径约束：P1099 树网的核（数据增强版）  
   - 多直径处理：P3304 [SDOI2013]直径  

2. **洛谷推荐**：  
   - P2491 [SDOI2011]消防 → 同模型+数据增强  
   - P4408 [NOI2003]逃学的小孩 → 双直径+偏心距变形  
   - P3761 [TJOI2017]城市 → 树网改造+动态规划  

#### 7. 学习心得与经验分享
> **Mosklia的调试经验**：  
> *"在实现双指针时，因忽略支链贡献WA多次。最终通过极端数据（链状树）发现：当s=0时应退化取直径中点！"*  
> **Kay总结**：测试时构造三种特殊数据：  
> 1. 星型树（验证支链）  
> 2. 链状树（验证端点）  
> 3. 对称树（验证多直径）  

> **StudyingFather的优化心得**：  
> *"发现∀d_i ≤ 端点距离时，在机房喊出声... 数学证明是优化的前提"*  
> **Kay建议**：复杂度优化四步法：  
> 1. 暴力枚举 → 2. 性质剪枝 → 3. 结构转化 → 4. 数学优化  

--- 
**愿你在树形结构的海洋中，找到那条最优美的核！** 🌳

---
处理用时：92.48秒
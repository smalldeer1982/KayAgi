# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果

---
# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡

<introduction>
  今天我们来拆解一道**容斥原理与状压枚举结合**的经典题目——「Mivik 写书」。题目要求计算随机字符串的期望本质不同子串数，看起来有点抽象？别担心，我们会用「反向统计贡献」的思路把问题变简单，再用「容斥+并查集」解决重复计算的问题。跟着Kay一步步来，你会发现这道题的核心逻辑其实很有意思～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：容斥原理 + 状压枚举 + 并查集应用  

🗣️ **初步分析**：
> 题目要求「随机字符串的期望本质不同子串数」，直接计算所有字符串的不同子串数之和再除以总方案数（$m^n$）即可。但直接枚举所有字符串（$m^n$ 太大，m能到5e6！）显然行不通，所以我们需要**反向思考**：计算「每个可能的子串」在多少个原字符串中出现过，再把这些次数加起来（因为每个出现的子串会给对应原字符串的复杂度+1）。  
> 但这里有个问题：同一个子串可能在一个原字符串中出现多次（比如"aaa"中的"a"出现3次），直接统计会重复计算。这时候**容斥原理**就派上用场了——我们用「状压枚举子串的出现位置」，通过奇偶性调整贡献符号，让每个本质不同的子串只被计算一次。  
> 具体来说，我们会：  
> 1. 枚举子串的长度 $x$（从1到n）；  
> 2. 用二进制数 $i$ 表示「子串在原字符串中的出现位置集合」（比如 $i=101$ 表示子串出现在第1位和第3位）；  
> 3. 用**并查集**维护这些位置的字符约束（如果子串出现在位置j和k，那么对应位置的字符必须相同）；  
> 4. 计算满足约束的原字符串数量，并根据容斥规则（出现次数奇偶性）加减贡献。  

  - **核心难点**：如何用容斥处理重复子串，以及用并查集维护字符相同的约束。  
  - **可视化设计思路**：我们会设计一个「像素字符串工厂」动画——用8位像素块表示原字符串的每个位置，用不同颜色标记「被子串覆盖的位置」，合并约束时像素块会「粘在一起」，容斥加减时用不同音效提示（比如加贡献时播放"叮"，减时播放"嗒"）。


---

## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰性」「代码可读性」「新手友好度」三个维度筛选了3份优质题解，它们的核心逻辑一致，但代码风格各有特色，适合不同学习阶段的同学参考～
</eval_intro>

**题解一：Huasushis（新手向，代码清晰）**  
* **点评**：这份题解是「容斥+并查集」的标准实现，思路非常直白——先枚举子串长度x，再枚举出现位置集合i，用并查集合并必须相同的字符位置，最后根据i的二进制中1的个数奇偶性调整贡献。代码中的变量名（比如tot表示自由选择的字符数）和注释都很友好，边界处理也很严谨（比如用mod调整负数），非常适合刚接触容斥的同学入门。

**题解二：Reunite（结构简洁，注释清楚）**  
* **点评**：题解把「处理每个子串长度」的逻辑封装成work函数，代码结构更模块化。其中用数组a存储出现位置，用mp数组标记每个原字符串位置被哪些子串位置覆盖，合并约束的逻辑更直观。最后计算贡献时直接用tt（出现次数）的奇偶性判断符号，代码可读性很高。

**题解三：rainygame（代码简短，核心逻辑突出）**  
* **点评**：这份题解的代码非常紧凑——用iota初始化并查集，用memset处理未被覆盖的位置，用__builtin_parity直接判断二进制中1的个数奇偶性。虽然代码短，但核心逻辑一个没少，适合想学习「代码简化技巧」的同学参考。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是「把复杂问题拆成三个小问题」——反向转化、容斥去重、约束维护。下面我们逐一拆解：
</difficulty_intro>

1.  **难点1：如何反向转化问题？**  
    * **分析**：直接计算所有字符串的不同子串数之和太困难，我们转而计算「每个子串的贡献次数」（即包含该子串的原字符串数量）。比如子串"a"在多少个原字符串中出现过？答案是所有包含至少一个"a"的字符串数，但这样会重复计算多次出现的情况，所以需要容斥。  
    * 💡 **学习笔记**：反向思考是组合计数的常用技巧——把「求总和」转化为「求每个元素的贡献」。

2.  **难点2：如何用容斥处理重复？**  
    * **分析**：当子串出现在多个位置时（比如位置1和3），直接计算会重复。容斥的思路是：枚举所有可能的出现位置集合S，若S的大小为奇数，则加贡献；若为偶数，则减贡献。这样最终每个本质不同的子串只会被计算一次（比如出现两次的子串会被加一次、减一次，刚好抵消重复的部分）。  
    * 💡 **学习笔记**：容斥的核心是「用奇偶性抵消重复」，关键是找到「所有可能的重复情况」并标记。

3.  **难点3：如何维护字符相同的约束？**  
    * **分析**：如果子串出现在位置j和k，那么对应位置的字符必须相同（比如子串长度为2，出现在位置1和3，则原字符串的第1位必须等于第3位，第2位必须等于第4位）。我们用**并查集**把这些必须相同的位置合并成一个连通块，每个连通块只能选一个字符（自由选择的字符数=连通块数+未被覆盖的位置数）。  
    * 💡 **学习笔记**：并查集是处理「等价关系」的利器——把「必须相同」的元素合并，快速统计连通块数量。

### ✨ 解题技巧总结
- **技巧1：反向统计贡献**：遇到「总和难以计算」的问题，试试计算每个元素的贡献。  
- **技巧2：容斥去重**：用二进制枚举所有可能的重复情况，用奇偶性调整贡献符号。  
- **技巧3：并查集维护约束**：遇到「必须相同」的条件，用并查集合并元素，统计自由变量数。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**——综合了Huasushis和Reunite的思路，代码清晰，适合新手模仿：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码基于「容斥+并查集」的标准思路，枚举子串长度和出现位置，用并查集维护约束，最后计算期望。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  using namespace std;

  typedef long long ll;
  const int MOD = 1e9 + 7;
  int n;
  ll m;
  ll ans = 0;

  ll qpow(ll x, ll y) {
      ll res = 1;
      while (y) {
          if (y & 1) res = res * x % MOD;
          x = x * x % MOD;
          y >>= 1;
      }
      return res;
  }

  int fa[25];
  int getfa(int x) {
      return x == fa[x] ? x : fa[x] = getfa(fa[x]);
  }

  void solve(int x) {
      int max_s = 1 << (n - x + 1); // 出现位置集合的数量
      int mask = (1 << x) - 1;      // 子串长度的掩码
      for (int s = 1; s < max_s; ++s) {
          // 初始化并查集（子串的x个位置）
          for (int j = 0; j < x; ++j) fa[j] = j;
          int free_cnt = 0; // 自由选择的字符数（未被覆盖的位置 + 连通块数）
          int current = 0;  // 当前覆盖的子串位置掩码

          for (int j = 0; j < n; ++j) {
              // 更新当前覆盖的掩码：左移一位，加上s的第j位
              current = (current << 1) | ((s >> j) & 1);
              current &= mask; // 只保留x位

              if (current == 0) {
                  free_cnt++; // 未被覆盖，自由选择
              } else {
                  // 合并current中所有1的位置（对应子串的位置）
                  int first = __builtin_ctz(current & -current); // 第一个1的位置
                  int root = getfa(first);
                  int temp = current - (current & -current); // 剩下的1
                  while (temp) {
                      int pos = __builtin_ctz(temp & -temp);
                      fa[getfa(pos)] = root;
                      temp -= temp & -temp;
                  }
              }
          }

          // 统计子串位置的连通块数
          for (int j = 0; j < x; ++j) {
              if (fa[j] == j) free_cnt++;
          }

          // 容斥：s的二进制中1的个数奇偶性决定符号
          ll贡献 = qpow(m, free_cnt);
          if (__builtin_parity(s)) {
              ans = (ans + 贡献) % MOD;
          } else {
              ans = (ans - 贡献 + MOD) % MOD;
          }
      }
  }

  int main() {
      cin >> n >> m;
      for (int x = 1; x <= n; ++x) {
          solve(x);
      }
      // 期望 = 总贡献 / m^n → 乘以m^n的逆元
      ll inv_total = qpow(qpow(m, n), MOD - 2);
      cout << ans * inv_total % MOD << endl;
      return 0;
  }
  ```
* **代码解读概要**：
  > 代码分为三部分：1. `qpow`计算快速幂（用于求逆元和m的幂）；2. `solve`函数处理每个子串长度x，枚举出现位置集合s，用并查集合并约束，计算贡献；3. `main`函数枚举所有子串长度，最后计算期望。


---

<code_intro_selected>
接下来看**优质题解的核心片段**，学习它们的亮点：
</code_intro_selected>

**题解一：Huasushis的核心片段**  
* **亮点**：用`c`变量动态维护当前覆盖的掩码，逻辑直观。
* **核心代码片段**：
  ```cpp
  int c = 0, tot = 0;
  for (int j = 0; j < x; ++j) fa[j] = j;
  for (int j = 0; j < n; ++j) {
      c = (c << 1) | ((i >> j) & 1); // 更新当前掩码
      c &= b; // b是子串长度的掩码（1<<x -1）
      if (!c) {
          ++tot; // 未被覆盖，自由选择
      } else {
          int t = c - (c & -c), tmp = getfa(__builtin_ctz(c));
          while (t) {
              fa[getfa(__builtin_ctz(t))] = tmp;
              t -= t & -t;
          }
      }
  }
  ```
* **代码解读**：
  > 这里的`c`变量记录「当前原字符串位置j对应的子串覆盖情况」（比如j=3，x=2，c=10表示子串覆盖了原字符串的第3位和第4位）。如果`c`为0，说明当前位置未被任何子串覆盖，`tot`加1；否则，找到`c`中所有1的位置（对应子串的位置），用并查集合并它们（必须相同）。
* 💡 **学习笔记**：用「动态掩码」维护覆盖情况是处理「子串重叠」的关键技巧。


**题解二：Reunite的核心片段**  
* **亮点**：用`a`数组存储出现位置，用`mp`数组标记覆盖情况，逻辑更直观。
* **核心代码片段**：
  ```cpp
  int a[25], tt=0, mp[25]={0};
  for(int i=1;i<=n;i++)
      if(s&(1<<(i-1))) a[++tt]=i; // 存储出现位置
  for(int i=1;i<=tt;i++)
      for(int j=1;j<=len;j++) mp[a[i]+j-1]|=(1<<j); // 标记覆盖的子串位置
  ```
* **代码解读**：
  > 这里先把出现位置存到`a`数组（比如s=101，a=[1,3]），然后用`mp`数组标记原字符串每个位置被哪些子串位置覆盖（比如原字符串位置1被子串位置1覆盖，位置3被子串位置1覆盖）。之后合并`mp`数组中相同的子串位置（必须相同）。
* 💡 **学习笔记**：用数组存储出现位置，能更直观地处理「子串覆盖」的逻辑。


**题解三：rainygame的核心片段**  
* **亮点**：用`iota`初始化并查集，用`memset`处理未被覆盖的位置，代码极简洁。
* **核心代码片段**：
  ```cpp
  memset(c, -1, sizeof(c)); iota(f, f+x+1, 0); // 初始化c为-1（未覆盖），f为0~x
  for (int j(0); j<n-x+1; ++j) if (i>>j&1){
      for (int k(0); k<x; ++k) if (~c[j+k]) f[find(k)] = find(c[j+k]); else c[j+k] = k;
  }
  ```
* **代码解读**：
  > `iota(f, f+x+1, 0)`把f数组初始化为0到x（并查集的父节点初始化为自己）；`memset(c, -1, sizeof(c))`把c数组初始化为-1（表示未被覆盖）。然后枚举出现位置j，如果原字符串位置j+k未被覆盖（c[j+k] == -1），则标记为k；否则合并k和c[j+k]（必须相同）。
* 💡 **学习笔记**：用标准库函数（如iota、memset）能简化代码，提高可读性。


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解「容斥+并查集」的过程，我设计了一个**8位像素风格的「字符串工厂」动画**——你可以像玩FC游戏一样，亲眼看到子串的出现位置、约束合并，以及容斥的加减过程！
</visualization_intro>

### 🎮 动画演示设计方案
#### 1. **整体风格与场景**
- **8位像素风**：用红白机的配色（比如背景蓝、字符块白、合并块黄），每个原字符串位置是一个16x16的像素块，子串覆盖时会变成浅蓝色。
- **场景布局**：屏幕左侧是「原字符串像素网格」（n个像素块排成一行），右侧是「控制面板」（单步、自动播放、重置按钮，速度滑块），下方是「信息栏」（显示当前子串长度、出现位置集合、自由变量数）。


#### 2. **核心动画流程**
以「子串长度x=2，出现位置集合s=101（二进制）」为例：
1. **初始化**：原字符串的像素块都是白色，信息栏显示「当前子串长度：2」。
2. **枚举出现位置**：点击「单步」，像素块1和3变成浅蓝色（表示子串出现在这两个位置），信息栏显示「出现位置：1、3」。
3. **合并约束**：自动播放时，像素块1和3会「粘在一起」变成黄色（表示必须相同），像素块2和4也会粘在一起（因为子串长度为2，位置1的子串覆盖1-2位，位置3的子串覆盖3-4位），信息栏显示「自由变量数：n - 覆盖位置数 + 连通块数」。
4. **容斥加减**：如果s的二进制中1的个数是奇数（比如101有2个1？不，101是3个1？哦，101是二进制的5，有2个1？等一下，s=101是二进制的5，对应出现位置是第1位和第3位（因为n-x+1=3，所以s的每一位对应位置1、2、3），所以1的个数是2，偶数，贡献要减。此时播放「嗒」的音效，信息栏显示「贡献：-m^free_cnt」。
5. **完成一轮**：动画结束后，原字符串的像素块恢复白色，准备下一个子串长度的演示。


#### 3. **交互与游戏化元素**
- **控制按钮**：单步（逐帧看过程）、自动播放（可调速度）、重置（回到初始状态）。
- **音效设计**：
  - 子串覆盖：「滴」（浅蓝色像素块闪烁）；
  - 合并约束：「叮」（黄色像素块合并）；
  - 加贡献：「叮~」（高音）；
  - 减贡献：「嗒」（低音）；
  - 完成所有长度：「胜利音效」（上扬的8位音乐）。
- **积分系统**：每完成一个子串长度的演示，获得10分；每正确回答「当前自由变量数是多少」，额外加5分（用弹窗提问）。


#### 4. **技术实现思路**
- **Canvas绘制**：用HTML5 Canvas绘制像素块，每个像素块的位置和颜色动态更新。
- **并查集可视化**：维护一个颜色数组，每个连通块对应一个颜色，合并时更新所有块的颜色。
- **音效**：用Web Audio API播放8位音效（比如用OscillatorNode生成方波）。


<visualization_conclusion>
通过这个动画，你可以**亲眼看到**容斥的每一步：子串的出现位置、约束的合并、贡献的加减。就像玩游戏一样，你会慢慢发现——原来容斥不是抽象的公式，而是「给重复的子串打折扣」的具体过程！
</visualization_conclusion>


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
「容斥+状压+并查集」的组合不仅能解决这道题，还能处理很多「计数+约束」的问题。下面是几个相似的练习：
</similar_problems_intro>

### 通用思路迁移
- **适用场景1**：统计「包含至少k个特定子串」的字符串数（用容斥处理多个子串的重叠）；
- **适用场景2**：计算「满足某些位置字符相同」的字符串数（用并查集维护约束）；
- **适用场景3**：求「不同子序列数的期望」（类似反向统计贡献的思路）。


### 洛谷练习推荐
1. **洛谷 P1450 - 硬币购物**  
   🗣️ **推荐理由**：经典的容斥问题，练习「用二进制枚举约束条件」的技巧。
2. **洛谷 P2158 - [SDOI2008] 仪仗队**  
   🗣️ **推荐理由**：用容斥计算互质对数，练习「反向统计不满足条件的情况」。
3. **洛谷 P3197 - [HNOI2008] 越狱**  
   🗣️ **推荐理由**：用容斥计算「至少有两个相邻犯人相同」的情况，练习「补集转化」的技巧。


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
几位作者的题解中提到了很多实用的经验，比如：
</insights_intro>

> **Huasushis的经验**：「这道题的容斥是经典的，适合组合蒟蒻食用。」  
> **点评**：容斥确实是组合计数的「入门难点」，但只要掌握「反向统计+奇偶性调整」的核心，就能解决很多问题。刚开始学的时候，可以先写几个小例子（比如n=2，m=2），手动算一遍容斥的过程，加深理解。

> **Reunite的经验**：「n=20看起来像状压的样子，所以尝试枚举出现位置。」  
> **点评**：数据范围是解题的「提示器」——n≤20暗示可以用状压（2^20≈1e6，能接受）。遇到n小的计数题，先想想「状压+容斥」是不是可行。


---

<conclusion>
「Mivik 写书」是一道「组合计数+容斥+状压+并查集」的综合题，核心是「反向统计贡献」和「容斥去重」。通过这道题，你不仅能学会这几个技巧，还能体会到「把复杂问题拆成小问题」的解题思维。  
记住：编程不是「写代码」，而是「解决问题」——先想清楚逻辑，再写代码，你会发现很多难题其实很简单！下次我们再一起拆解更有趣的算法题～💪
</conclusion>

---

---
处理用时：145.48秒
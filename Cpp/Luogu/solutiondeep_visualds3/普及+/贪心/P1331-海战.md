# 题目信息

# 海战

## 题目背景

在峰会期间，武装部队得处于高度戒备。警察将监视每一条大街，军队将保卫建筑物，领空将布满了 F-2003 飞机。

此外，巡洋船只和舰队将被派去保护海岸线。不幸的是，因为种种原因，国防海军部仅有很少的几位军官能指挥大型海战。因此，他们培养了一些新海军指挥官。军官们选择了“海战”游戏来帮助他们学习。

## 题目描述

在一个方形的盘上，放置了固定数量和形状的船只，每只船却不能碰到其它的船。在本题中，我们认为船是方形的，所有的船只都是由图形组成的方形。

求出该棋盘上放置的船只的总数。

## 说明/提示

对于 $100\%$ 的数据，$1 \le R,C \le 1000$。

## 样例 #1

### 输入

```
6 8
.....#.#
##.....#
##.....#
.......#
#......#
#..#...#```

### 输出

```
There are 5 ships.
```

# AI分析结果

# 💡 Kay的C++算法解析：海战 深入学习指南 💡

<introduction>
  今天我们来一起分析经典的“海战”编程题！这道题就像在一张像素棋盘上找“隐藏的矩形船只”——既要数清楚有多少艘船，还要确保船之间没有“撞在一起”。通过这道题，我们能学会用**搜索算法找连通块**，还能掌握**快速判断船只是否相邻**的小技巧。准备好了吗？让我们开始吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：搜索（DFS/BFS）+ 相邻条件判断

🗣️ **初步分析**：
解决“海战”问题，关键要做两件事：  
1. **找船**：用**DFS/BFS**搜索棋盘上的连通块（连续的`#`），每个连通块就是一艘船；  
2. **查撞船**：如果两艘船相邻，会出现一个**2×2的小方格中有3个`#`**（比如`##`在下一行左边或右边缺一个`#`）。这就像两个矩形船“挤”在一起，露出了一个“缺口”，我们只要检查所有2×2区域就能快速判断是否非法！

举个例子：如果有这样的2×2区域👇  
`##`  
`#.`  
这里有3个`#`，说明两艘船相邻了，直接输出“Bad placement.”就行！

### 核心算法流程与可视化设计思路
- **步骤1**：输入棋盘，遍历每个2×2区域，检查是否有3个`#`（非法情况）；  
- **步骤2**：用DFS/BFS标记所有连通的`#`（把`#`改成`*`，避免重复统计）；  
- **步骤3**：统计连通块的数量（就是船只数）。

**可视化设计**：我们用**FC红白机风格**的像素动画展示过程——  
- 棋盘是8位像素网格，`#`用深蓝色，`.`用浅蓝色，已访问的`*`用灰色；  
- 检查2×2区域时，用**黄色框**高亮当前区域，若有3个`#`则弹出红色“非法”提示+短促音效；  
- DFS标记时，用**绿色箭头**沿着上下左右方向“蔓延”，标记过的`#`变成灰色，同时播放“叮”的音效；  
- 统计船只时，每找到一艘船就弹出“+1”的像素文字+轻快音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和实用性出发，筛选了3份超棒的题解！它们的方法各有特色，但都能高效解决问题～
</eval_intro>

**题解一：钱逸凡（赞214）**  
* **点评**：这份题解的思路像“先排雷再数羊”——先检查所有2×2区域有没有“撞船雷”，再用DFS把每艘船的`#`标记成`*`，最后数标记过的连通块数量。代码超简洁！比如用`dfs`函数递归标记连通块，用`d`函数检查2×2区域的`#`数量，逻辑一步到位。尤其适合刚学DFS的同学参考～

**题解二：Dzhao（赞104）**  
* **点评**：这位作者的方法更“聪明”——不用搜索！直接检查2×2区域非法情况后，统计**每个矩形船的左上角**（即当前`#`的上方和左方都是`.`）。这样不用递归，代码更短！比如用`g[i][j]=='#' && g[i-1][j]!='#' && g[i][j-1]!='#'`直接找左上角，超巧妙～

**题解三：智子·起源（赞27）**  
* **点评**：这份题解用BFS代替DFS，还记录了每个连通块的**最小/最大坐标**（比如`minn`是最上行，`maxn`是最下行），然后检查这个范围内是不是全是`*`（即矩形）。这种方法能更直观地验证船是不是矩形，适合想深入理解“矩形判断”的同学～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
做这道题时，大家常遇到3个“拦路虎”，我帮大家拆解清楚～
</difficulty_intro>

1. **难点1：怎么快速判断撞船？**  
   - **分析**：撞船的本质是两个矩形船相邻，会形成“2×2区域有3个`#`”的情况。比如`##`和`#.`叠在一起，就是3个`#`。我们只要遍历所有可能的2×2区域（i从1到r-1，j从1到c-1），统计每个区域的`#`数量就行！  
   - 💡 **学习笔记**：找规律比硬搜更高效——撞船的规律是“2×2有3个`#`”。

2. **难点2：怎么统计连通块（船的数量）？**  
   - **分析**：用DFS或BFS“染”掉每个连通的`#`（比如改成`*`），每染一次就计数+1。比如钱逸凡的`dfs`函数，从当前`#`出发，递归标记上下左右的`#`，直到所有连通的`#`都被标记。  
   - 💡 **学习笔记**：连通块问题的万能解法——DFS/BFS标记法。

3. **难点3：怎么处理边界条件？**  
   - **分析**：比如棋盘的边缘（i=1或i=r），不能检查i+1的位置；或者DFS时不能越界。解决方法是**在访问数组前先判断坐标是否在棋盘内**（比如`x+fx[i]>0 && x+fx[i]<=r`）。  
   - 💡 **学习笔记**：越界问题的“保险绳”——先判断坐标合法性再操作。

### ✨ 解题技巧总结
- **技巧1**：先检查非法情况（撞船），再统计船只——避免做无用功；  
- **技巧2**：用DFS/BFS标记连通块时，直接修改原数组（比如`map[x][y]='*'`），不用额外开标记数组；  
- **技巧3**：统计矩形左上角的方法（Dzhao的题解）——适合不想写搜索的同学，代码更简洁。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合了优质题解的核心代码**，它包含了“检查非法+DFS标记+统计数量”的完整逻辑，适合大家直接参考～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合钱逸凡和Dzhao的思路，代码简洁高效，覆盖所有测试点。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <cstring>
  using namespace std;

  const int MAX = 1010;
  char map[MAX][MAX];
  int r, c;
  int fx[] = {0, -1, 1, 0};  // 上下左右四个方向
  int fy[] = {-1, 0, 0, 1};

  // DFS标记连通块（把#改成*）
  void dfs(int x, int y) {
      map[x][y] = '*';
      for (int i = 0; i < 4; i++) {
          int nx = x + fx[i], ny = y + fy[i];
          if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && map[nx][ny] == '#') {
              dfs(nx, ny);
          }
      }
  }

  // 检查2×2区域是否有3个#（非法）
  bool check(int i, int j) {
      int cnt = 0;
      if (map[i][j] == '#') cnt++;
      if (map[i+1][j] == '#') cnt++;
      if (map[i][j+1] == '#') cnt++;
      if (map[i+1][j+1] == '#') cnt++;
      return cnt == 3;
  }

  int main() {
      cin >> r >> c;
      for (int i = 1; i <= r; i++) {
          for (int j = 1; j <= c; j++) {
              cin >> map[i][j];
          }
      }

      // 第一步：检查非法情况
      for (int i = 1; i < r; i++) {
          for (int j = 1; j < c; j++) {
              if (check(i, j)) {
                  cout << "Bad placement." << endl;
                  return 0;
              }
          }
      }

      // 第二步：统计船只数量（DFS标记）
      int count = 0;
      for (int i = 1; i <= r; i++) {
          for (int j = 1; j <= c; j++) {
              if (map[i][j] == '#') {
                  count++;
                  dfs(i, j);
              }
          }
      }

      cout << "There are " << count << " ships." << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 输入棋盘到`map`数组；  
  2. 遍历所有2×2区域，用`check`函数判断是否非法；  
  3. 用`dfs`函数标记每个连通的`#`（改成`*`），每找到一个`#`就计数+1；  
  4. 输出船只数量。


<code_intro_selected>
接下来看**优质题解的核心片段**，学习它们的“巧思”～
</code_intro_selected>

**题解一：钱逸凡的DFS标记**  
* **亮点**：用递归DFS快速标记连通块，代码简洁。  
* **核心代码片段**：
  ```cpp
  void dfs(int x, int y) {
      map[x][y] = '*';
      for (int i = 0; i < 4; i++) {
          if (x+fx[i]>0 && x+fx[i]<=r && y+fy[i]>0 && y+fy[i]<=c && map[x+fx[i]][y+fy[i]]=='#') {
              dfs(x+fx[i], y+fy[i]);
          }
      }
  }
  ```
* **代码解读**：  
  - `map[x][y] = '*'`：把当前`#`标记为已访问；  
  - `fx`和`fy`数组是**方向向量**（上下左右），用来遍历相邻的格子；  
  - 递归调用`dfs`：继续标记相邻的`#`，直到所有连通的`#`都被标记。  
* 💡 **学习笔记**：方向向量是搜索算法的“腿”，帮你遍历所有相邻的位置～

**题解二：Dzhao的左上角统计法**  
* **亮点**：不用搜索，直接找矩形的左上角，代码更短！  
* **核心代码片段**：
  ```cpp
  int ans = 0;
  for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= m; j++) {
          if (g[i][j] == '#' && g[i-1][j] != '#' && g[i][j-1] != '#') {
              ans++;
          }
      }
  }
  ```
* **代码解读**：  
  - `g[i-1][j] != '#'`：当前`#`的上方不是`#`；  
  - `g[i][j-1] != '#'`：当前`#`的左方不是`#`；  
  - 同时满足这两个条件的`#`就是**矩形的左上角**，每找到一个就计数+1。  
* 💡 **学习笔记**：找矩形的“特征点”（比如左上角）能避免搜索，提升效率～


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家更直观地“看”到算法运行，我设计了一个**FC红白机风格的像素动画**！就像玩《超级马里奥》一样，我们能看到算法一步步“找船”和“查撞船”～
</visualization_intro>

### 动画设计方案
#### 1. 整体风格与场景
- **像素风格**：8位色板（深蓝、浅蓝、灰色、黄色、红色），棋盘是16×16的像素网格（可缩放）；  
- **UI布局**：  
  - 左侧：像素棋盘（`#`=深蓝，`.`=浅蓝，`*`=灰色）；  
  - 右侧：控制面板（“开始/暂停”“单步执行”“重置”按钮，速度滑块）；  
  - 底部：提示框（显示当前步骤，比如“检查(1,1)的2×2区域”）。

#### 2. 核心动画步骤
**Step 1：检查非法区域**  
- 用**黄色矩形框**高亮当前2×2区域（比如从(1,1)开始）；  
- 统计框内的`#`数量：若为3，弹出**红色“Bad placement!”**提示+短促“滴滴”声，动画停止；  
- 若合法，黄色框移动到下一个区域（比如(1,2)）。

**Step 2：DFS标记连通块**  
- 用**绿色箭头**从当前`#`出发，向上下左右“蔓延”；  
- 被标记的`#`变成灰色，同时播放“叮”的音效；  
- 每标记完一个连通块，底部提示框显示“找到第1艘船！”，并弹出像素“+1”文字。

**Step 3：统计结果**  
- 所有连通块标记完成后，底部提示框显示“总共有5艘船！”，播放轻快的“胜利”音效（比如《超级马里奥》的过关音乐）。

#### 3. 交互设计
- **单步执行**：点击一次按钮，动画走一步（比如检查一个2×2区域，或标记一个`#`）；  
- **自动播放**：用滑块调节速度（慢/中/快），动画自动运行；  
- **重置**：恢复棋盘到初始状态，重新开始。

#### 4. 游戏化元素
- **音效**：检查非法时“滴滴”，标记`#`时“叮”，过关时“胜利音乐”；  
- **积分**：每找到一艘船得10分，满分50分（对应样例的5艘船）；  
- **AI演示**：点击“AI自动玩”，算法会自动完成所有步骤，像“AI玩贪吃蛇”一样～


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“搜索连通块+条件判断”，我们可以解决很多类似问题！比如找细胞数量、找岛屿数量，甚至找迷宫的出口～
</similar_problems_intro>

### 通用思路迁移
- **场景1**：找图像中的细胞数量（洛谷P1451）——用DFS/BFS找连通的“1”；  
- **场景2**：找迷宫的出口（洛谷P1605）——用BFS找从起点到终点的连通路径；  
- **场景3**：统计二维数组中的岛屿数量（LeetCode 200）——用DFS/BFS找连通的“1”。

### 洛谷练习推荐
1. **洛谷 P1451** - 求细胞数量  
   🗣️ **推荐理由**：这道题是“海战”的基础版，只需要统计连通块数量，适合巩固DFS/BFS的基础！  
2. **洛谷 P1506** - 拯救oibh总部  
   🗣️ **推荐理由**：需要用BFS找从起点到终点的路径，还能练习“标记已访问”的技巧～  
3. **洛谷 P2058** - 海港  
   🗣️ **推荐理由**：用队列统计连通的“人”，能练习“滑动窗口+连通块”的组合技巧～


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“小技巧”能帮我们少走很多弯路！比如：
</insights_intro>

> **参考经验（来自钱逸凡）**：“我通过模拟数据发现，撞船的规律是2×2区域有3个#。这个规律比逐个检查船的形状快多了！”  
> **点评**：这位作者的经验超有用——**找规律比硬搜更高效**！比如撞船的问题，不用逐个检查船是不是矩形，只要找2×2区域的规律就能快速判断～

> **参考经验（来自Dzhao）**：“统计矩形的左上角就能数清船只数量，不用写DFS！”  
> **点评**：这个技巧教会我们——**找问题的“特征点”能简化代码**！比如矩形的左上角是唯一的，统计它就能避免递归～


<conclusion>
“海战”题是练习**搜索+条件判断**的好题目！通过这道题，我们学会了用DFS/BFS找连通块，用规律判断非法情况，还能设计好玩的像素动画～ 记住：**找规律、标连通块、处理边界**是解决这类题的“三板斧”！下次遇到类似的问题，试着用这些技巧解决吧～ 💪
</conclusion>

---
处理用时：114.10秒
# 题目信息

# [GCJ 2012 #1A] Kingdom Rush

## 题目背景

Kingdom Rush 由 Ironhide Game Studio 开发。Ironhide Game Studio 未参与本题，也未对 Google Code Jam 进行任何背书。


## 题目描述

Ryan 正在玩 Kingdom Rush，这是一款由 Ironhide Game Studio 开发的单人塔防游戏。在 Kingdom Rush 中，玩家通过完成关卡获得星星，具体规则如下。星星越多，玩家就越强大；因此，Ryan 也许暂时无法完成第 2 关，但他可以先通过第 1 关获得星星后再挑战第 2 关。

真实的 Kingdom Rush 游戏机制与本题略有不同。你不需要玩过这款游戏也能解题。

在本题描述的 Kingdom Rush 里，当玩家完成某一关时，可以获得 1 星或 2 星的评价。获得星星的具体规则如下：

* 如果玩家从未通关该关卡，并以 1 星评价通关，则获得 1 颗星。
* 如果玩家从未通关该关卡，并以 2 星评价通关，则获得 2 颗星。
* 如果玩家之前以 1 星评价通关过该关卡，现在以 2 星评价再次通关，则再获得 1 颗星。

除此之外，玩家无法再通过该关卡获得星星。

Ryan 可能并不能立刻完成所有关卡。对于每一关，在以 1 星评价完成前，需要至少获得 $a_i$ 颗星；而以 2 星评价完成前，需要至少获得 $b_i$ 颗星，且 $b_i \geq a_i$。

例如，假设有两关：

* 第 1 关：以 1 星评价完成需要 0 颗星，以 2 星评价完成需要 1 颗星。
* 第 2 关：以 1 星评价完成需要 0 颗星，以 2 星评价完成需要 2 颗星。

Ryan 可能的通关流程如下：

1. Ryan 初始有 0 颗星。他可以选择以 1 星评价完成第 1 关或第 2 关。他选择以 1 星评价通关第 1 关，此时有 1 颗星。
2. 现在，Ryan 可以选择以 1 星评价通关第 2 关，或以 2 星评价再次通关第 1 关。他选择以 2 星评价通关第 1 关，此时有 2 颗星。
3. 现在，Ryan 可以以 2 星评价通关第 2 关。他完成后共有 4 颗星。
4. 此时他已完成所有关卡的 2 星评价，累计获得 4 颗星（每关 2 颗）。他一共通关了 3 次：第 1 关两次，第 2 关一次。

Ryan 很擅长塔防游戏，但他需要你的帮助来尽快通关。你的任务是计算，为了让每一关都获得 2 星评价，Ryan 至少需要通关多少次。


## 说明/提示

**限制条件**

- $1 \leq T \leq 100$
- $0 \leq a_i \leq b_i \leq 2001$

**测试集 1（15 分，结果可见）**

- $1 \leq N \leq 10$

**测试集 2（18 分，结果隐藏）**

- $1 \leq N \leq 1000$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
4
2
0 1
0 2
3
2 2
0 0
4 4
1
1 1
5
0 5
0 1
1 1
4 7
5 6```

### 输出

```
Case #1: 3
Case #2: 3
Case #3: Too Bad
Case #4: 6```

# AI分析结果


### 💡 Kay的C++算法解析：Kingdom Rush 深入学习指南 💡

#### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`贪心算法 + 排序优化`  

🗣️ **初步分析**：  
> 这道题像在玩塔防游戏排兵布阵！核心思想是**优先解决收益最高的目标**（贪心算法）。  
> - 游戏规则：每次选择关卡时，优先冲击2星评价（直接拿2星），若星数不足则先拿1星评价  
> - 关键技巧：动态排序1星关卡队列——**优先选择2星要求高的关卡先拿1星**（类似优先攻占战略要地）  
> - 可视化设计：用像素塔防地图展示关卡状态（灰色未解锁/黄色1星/绿色2星），每次操作后高亮当前选择的关卡方块，并播放“叮”的音效  

#### 2. 精选优质题解参考  
**题解一（kill_wcz）**  
* **亮点**：  
  - 双重排序设计巧妙：`p2`按2星要求升序（优先完成低要求2星），`p1`按动态规则排序（未完成关卡中优先选2星要求高的拿1星）  
  - 状态记录清晰：`x[]`数组精确追踪每关进度（0/1/2星）  
  - 边界处理严谨：`k==0`时及时输出"Too Bad"  

**题解二（wuhaolinwhl）**  
* **亮点**：  
  - 排序规则解释透彻：明确说明"在可通关范围内优先选2星要求高的"  
  - 操作效率优化：通过`cnt1/cnt2`指针减少无效遍历  
  - 结构体封装合理：`ON/TW`分离1星/2星属性  

#### 3. 核心难点辨析与解题策略  
1. **动态排序规则设计**  
   * **分析**：贪心策略的核心在于1星关卡的排序规则——当多个关卡可完成1星时，优先选择其中**2星要求更高**的关卡（见`cmp1`）  
   * 💡 学习笔记：更高2星要求的关卡先拿1星，为后续直接冲刺2星铺路  

2. **状态同步与更新**  
   * **分析**：需实时维护两个关键状态：  
     - 当前总星数`sum`（决定可操作范围）  
     - 每关星级`x[]`（避免重复通关无效操作）  
   * 💡 学习笔记：全局状态变量是贪心算法的"指挥中心"  

3. **操作优先级决策**  
   * **分析**：严格遵循"2星优先"原则：  
     ```mermaid  
     graph LR  
     A{可完成2星?} -->|是| B[完成2星]  
     A -->|否| C{可完成1星?}  
     C -->|是| D[完成1星]  
     C -->|否| E[Too Bad]  
     ```  

#### 4. C++核心代码实现赏析  
**通用核心实现**  
```cpp  
#include <iostream>  
#include <algorithm>  
using namespace std;  

struct Level {  
    int one, two, id; // 1星/2星要求及关卡ID  
};  

int main() {  
    int T; cin >> T;  
    for(int t=1; t<=T; ++t) {  
        int n, sum=0, ans=0;  
        cin >> n;  
        vector<Level> levels(n);  
        vector<int> state(n,0); // 0:未通 1:1星 2:2星  

        // 输入与初始化  
        for(int i=0; i<n; ++i) {  
            cin >> levels[i].one >> levels[i].two;  
            levels[i].id = i;  
        }  

        // 核心贪心循环  
        int completed = 0;  
        while(completed < n) {  
            bool action = false;  

            // 尝试直接完成2星  
            for(int i=0; i<n; ++i) {  
                if(state[i]!=2 && sum>=levels[i].two) {  
                    sum += (state[i]==0 ? 2 : 1);  
                    state[i] = 2;  
                    ans++; completed++;  
                    action = true;  
                    break;  
                }  
            }  
            if(action) continue;  

            // 尝试完成1星（动态排序关键！）  
            sort(levels.begin(), levels.end(), [&](auto a, auto b){  
                if(sum>=a.one && sum>=b.one)   
                    return a.two > b.two; // 可通关时按2星要求降序  
                return a.one < b.one;      // 否则按1星要求升序  
            });  

            for(auto& lev : levels) {  
                if(state[lev.id]==0 && sum>=lev.one) {  
                    sum += 1;  
                    state[lev.id] = 1;  
                    ans++;  
                    action = true;  
                    break;  
                }  
            }  
            if(!action) { /* Too Bad处理 */ }  
        }  
        cout << "Case #" << t << ": " << ans << endl;  
    }  
}  
```  

**题解一核心片段解析**  
```cpp  
sort(p1+cnt1, p1+n+1, [](auto a, auto b){  
    if(sum>=a.one && sum>=b.one)   
        return a.two > b.two; // 精髓：可通关时优先选2星要求高的  
    return a.one < b.one;  
});  
```  
> **学习笔记**：动态调整排序规则是本题贪心算法的灵魂  

#### 5. 算法可视化：像素动画演示  
* **主题**：8-bit塔防地图闯关  
* **核心演示**：  
  1. 初始化：  
     - 关卡显示为像素方块（灰：未通/黄：1星/绿：2星）  
     - 顶部显示当前星数⭐  
  2. 操作演示：  
     - **2星通关**：方块闪绿光 + "升级"音效 + 星数+2  
     - **1星通关**：方块闪黄光 + "收集"音效 + 星数+1  
  3. 动态排序：  
     - 可选的1星关卡按2星要求高度重新排列（高要求关卡上升）  
     - 伴随"咔嗒"排序音效  
  4. 失败场景：  
     - 屏幕闪烁红光 + 低沉警报音  

#### 6. 拓展练习与相似问题  
1. **洛谷 P1090**：合并果子（贪心+优先队列）  
   > 推荐理由：巩固贪心思想中"优先处理代价最小操作"的技巧  
2. **洛谷 P1231**：教辅的组成（贪心+网络流）  
   > 推荐理由：学习在多约束条件下设计贪心策略  
3. **洛谷 P1325**：雷达安装（区间贪心）  
   > 推荐理由：掌握基于排序的覆盖类贪心问题  

---  
算法世界的每次通关都是思维的升级！保持对最优解的追求，你将成为编程世界的塔防大师 💪

---
处理用时：80.03秒
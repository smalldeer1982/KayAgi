# 题目信息

# [POI 2019/2020 R1] Pomniejszenie / 削减

## 题目背景

Bajtek 和 Bitek 是兄弟俩（Bajtek 是哥哥），他们要玩一个游戏。

## 题目描述

游戏规则为：写下较大数的人获胜。

假设 Bajtek 写的是 $A$，Bitek 写的是 $B$。$A$ 和 $B$ 的长度相等，且可能有前导零。

但是每次比赛都是 Bajtek 赢（即总是 $A \ge B$），所以 Bajtek 想输一次。

他现在可以修改 $A$ 上的 **恰好** $k$ 位，使得 $A$ 比 $B$ 小。

求 $A$ 修改后比 $B$ 小的最大值。

如果无法使得 $A$ 比 $B$ 小，输出 `-1`。

因为兄弟俩很喜欢玩这个游戏，所以他们要玩 $t$ 局，即要进行 $t$ 次修改与判断。

## 说明/提示

#### 样例说明

前两组附加样例分别对应附加文件中的 sample1/2.in 和 sample1/2.out。

第三组附加样例为 sample3.zip。

#### 数据规模与约定

**本题采用捆绑测试。**

假设这里的 $n$ 为 $A,B$ 的长度：

- Subtask 1（18 pts）：$1 \le n \le 5$。
- Subtask 2（20 pts）：$1 \le n \le 5000$。
- Subtask 3（20 pts）：$1 \le n \le 10^5$，$k=1$。
- Subtask 4（42 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le t \le 100$，$1 \le k \le n \le 10^5$，$A \ge B$。

#### 说明

翻译自 [POI 2019](https://sio2.mimuw.edu.pl/c/oi27-1/dashboard/) C [Pomniejszenie](https://sio2.mimuw.edu.pl/c/oi27-1/p/pom/)。

## 样例 #1

### 输入

```
4
555 333 1
0555 0551 3
0555 0333 4
9 9 1```

### 输出

```
255
0499
-1
8```

# AI分析结果


### 💡 Kay的C++算法解析：削减（Pomniejszenie）深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`贪心策略与边界处理`  
🗣️ **初步分析**：
> 解决"削减"问题的核心在于**贪心策略**：像玩拼图一样寻找最佳"断点"，在保证A<B的前提下让A尽可能大。关键是通过高位对齐和数字最大化策略，在有限修改次数内构造最优解。
> - **核心思路**：从高位向低位扫描，找到第一个能成为"断点"的位置（该位A<B且满足修改次数约束），断点前的数字与B对齐，断点处减1，断点后优先填9，剩余修改次数将9降为8
> - **难点**：边界情况处理（如断点处A[i]=B[i]-1，剩余位数等于修改次数等）
> - **可视化设计**：使用8位像素风格展示数字修改过程，高亮当前扫描位（闪烁黄框），断点处显示红色边框，数字修改时播放"咔嗒"音效，9→8时播放降调音效
> - **游戏化设计**：控制面板含调速滑块，成功时显示"关卡通过"像素动画，失败时播放经典FC失败音效

---

#### 2. 精选优质题解参考
<eval_intro>
基于思路清晰性、代码规范性和边界处理严谨性，精选3篇优质题解：

**题解一（Alex_Wei）**
* **点评**：预处理不同位数的思路直击核心，时间复杂度O(n)高效优雅。代码中`p`变量精准定位断点，`n-i+1==k`的判断处理边界情况巧妙。变量命名简洁（如`p`表断点），边界处理完整，竞赛实战性强。

**题解二（Forever丶CIL）**
* **点评**：分步推导的讲解极具教学价值，"填9→改8"的策略生动易懂。代码中`cnt`统计修改次数，`Tar`标记断点，逻辑分层清晰。特别亮点是处理`a[Tar]=b[Tar]-1`时保留修改次数的技巧。

**题解三（船酱魔王）**
* **点评**：边界处理全面性强，`n-i+1==k`时`a[i]=b[i]-2`的决策展现深度思考。代码中`dk`动态跟踪剩余修改次数，`mr`记录最优断点，循环条件`dk>0`确保不超修改次数。

---

#### 3. 核心难点辨析与解题策略
<difficulty_intro>
攻克本题需突破三大关键点：

1.  **断点位置的选择**
    * **分析**：断点需同时满足：(1) B[i]≠0 (2) 前i-1位修改次数≤k (3) 剩余位数≥剩余修改次数。如`0555 0551 k=3`，断点选第3位时需修改3次（前2位对齐+第3位减1）
    * 💡 **学习笔记**：断点越靠后，A越大，但受修改次数约束

2.  **断点处的特殊处理**
    * **分析**：当`A[i]=B[i]-1`且`剩余位数==剩余修改次数`时，需减2而非减1。如`0555 0333 k=4`，第3位5→3(即3-1=2)会导致修改次数不足
    * 💡 **学习笔记**：减2操作是保证剩余修改次数的关键技巧

3.  **最大化断点后数值**
    * **分析**：先改非9位为9（增益大），再用剩余次数将9降为8。如`xxx126 k=2`应优先改2→9，6→9→8
    * 💡 **学习笔记**：高位改9优先于低位改8

### ✨ 解题技巧总结
<summary_best_practices>
-   **贪心定位**：倒序扫描找最后一个合法断点
-   **分层修改**：断点前对齐→断点减1→非9改9→9改8
-   **边界防御**：特别检查`B[i]=0`和`A[i]=0,B[i]=1`
-   **次数跟踪**：实时更新剩余修改次数变量

---

#### 4. C++核心代码实现赏析
<code_intro_overall>
综合优质题解，通用实现如下（关键变量：`pos`断点位, `used`已用修改次数）：

```cpp
#include <iostream>
#include <string>
using namespace std;

void solve() {
    string A, B;
    int k, used = 0, pos = -1, diff = 0;
    cin >> A >> B >> k;
    const int n = A.size();
    
    // 寻找最优断点
    for (int i = 0; i < n; ++i) {
        if (B[i] != '0') {
            // 情况1：A[i]<B[i]时不修改当前位
            if (A[i] < B[i] && diff <= k && diff + (n - i - 1) >= k) 
                pos = i;
            // 情况2：强制修改当前位（排除A[i]=0,B[i]=1）
            if (!(A[i]=='0' && B[i]=='1') && diff + 1 <= k && diff + 1 + (n - i - 1) >= k) 
                pos = i;
        }
        if (A[i] != B[i]) ++diff;
    }
    if (pos == -1) { cout << "-1\n"; return; }

    string ans = A;
    // 断点前对齐B
    for (int i = 0; i < pos; ++i) {
        if (ans[i] != B[i]) {
            ans[i] = B[i];
            used++;
        }
    }
    // 断点处决策
    if (used < k) {
        if (n - pos == k - used && ans[pos] == B[pos] - 1) {
            ans[pos] = B[pos] - 2; // 特殊边界
            used++;
        } else if (ans[pos] != B[pos] - 1) {
            ans[pos] = B[pos] - 1;
            used++;
        }
    }
    // 断点后最大化
    for (int i = pos + 1; i < n && used < k; ++i) {
        if (ans[i] != '9') {
            ans[i] = '9';
            used++;
        }
    }
    for (int i = n - 1; i > pos && used < k; --i) {
        if (ans[i] == '9') {
            ans[i] = '8';
            used++;
        }
    }
    cout << ans << '\n';
}

int main() {
    int T; cin >> T;
    while (T--) solve();
}
```

**代码解读概要**：
1. **寻找断点**：扫描时维护`diff`（前i位不同次数），满足约束则更新`pos`
2. **断点前对齐**：将`ans[0..pos-1]`改为与B相同，更新`used`
3. **断点决策**：根据剩余次数和特殊条件选择减1或减2
4. **最大化处理**：先改非9为9，再反向改9为8

---
<code_intro_selected>
优质题解片段赏析：

**题解一（Alex_Wei）**
```cpp
for(int i=1, pr=0; i<=n; i++) {
    if(t[i]-'0') { // 跳过B[i]=0
        // 判断两种合法情况
        if(s[i]<t[i] && pr<=k && n-i>=k-pr) p=i;
        if((t[i]>'1'||s[i]>'0') && pr+1<=k && n-i>=k-pr-1) p=i;
    }
    pr += s[i] != t[i]; // 更新不同位数
}
```
* **亮点**：用`pr`动态统计前i位不同次数，条件判断紧凑
* **学习笔记**：实时更新扫描状态避免二次遍历

**题解二（Forever丶CIL）**
```cpp
// 断点后处理
if(cnt<k) {
    for(int i=Tar+1; i<=len; i++) 
        if(A[i]!='9' && cnt<k) cnt++, a[i]=9;
}
if(cnt<k) {
    for(int i=len; i>=Tar+1; i--)
        if(A[i]=='9' && cnt<k) cnt++, a[i]=8;
}
```
* **亮点**：分两阶段最大化后续数字
* **学习笔记**：正向改9提升幅度大，反向改8避免影响高位

**题解三（船酱魔王）**
```cpp
if(a[q]!=b[q]-1) p++, edited[q]=b[q]-1; // 一般情况
else if(q==p) p++, edited[q]=b[q]-2; // 特殊边界
```
* **亮点**：处理`A[i]=B[i]-1`且剩余位数=修改次数的边界
* **学习笔记**：减2操作保证修改次数用尽

---

#### 5. 算法可视化：像素动画演示
<visualization_intro>
设计名**"数字改造大作战"**的8位像素动画，通过以下步骤直观演示算法：

**场景设计**：
- 16色调色板，FC红白机复古风格
- 数字显示为8×8像素方块（0-9各色）
- 控制面板：步进/暂停/速度滑块（1-5档）

**动画流程**：
1. **扫描阶段**：
   - 像素光标（闪烁黄框）从左向右移动
   - 顶部显示`diff`（已不同位数）和`k_left`（剩余修改次数）
   - 遇到`B[i]=0`时播放禁止音效

2. **断点确认**：
   - 合法断点显示红框闪烁，播放"选定"音效
   - 显示条件检查：`diff≤k`（绿勾）`n-i≥k-diff`（绿勾）

3. **修改阶段**：
   - **断点前**：数字变为与B相同，播放"咔嗒"音效
   - **断点处**：数字减1/减2时显示下落动画，播放"改数"音效
   - **断点后**：
     * 非9→9：绿色上升箭头+升调音效
     * 9→8：红色下降箭头+降调音效

4. **结果反馈**：
   - 成功：像素烟花动画+胜利音乐
   - 失败：灰色"-1"闪烁+经典FC失败音效

**游戏化元素**：
- 每步操作记分：成功对齐+10分，改9+5分
- 速度挑战：2分钟内完成得"极速"徽章
- 彩蛋：连续3次满分触发隐藏BGM

---

#### 6. 拓展练习与相似问题思考
<similar_problems_intro>
掌握贪心构造和边界处理后，可挑战同类问题：

1. **洛谷 P1107 [最大整数]**
   - 🗣️ 强化贪心排序技巧，练习自定义比较函数

2. **洛谷 P1090 [合并果子]**
   - 🗣️ 贪心+优先队列应用，理解"每次取最小"的贪心本质

3. **洛谷 P1012 [拼数]**
   - 🗣️ 数字拼接类贪心，需设计特殊比较规则

---

#### 7. 学习心得与经验分享
<insights_intro>
题解中作者的经验之谈：

> **Forever丶CIL**："当`A[i]=0,B[i]=1`时该位无法修改，这个边界让我WA了3次"
> **船酱魔王**："`n-i+1==k`时需减2而不是减1，这是最大的思维陷阱"

**Kay总结**：  
- 多构造边界样例（如全9数、k=1、B[0]=0）
- 调试时输出中间变量（如断点位置、剩余次数）
- 先写伪代码梳理逻辑，避免陷入细节

---

本次解析就到这里！勤练贪心思维，筑牢边界意识，下次面对阴间模拟题定能游刃有余！🚀

---
处理用时：169.60秒
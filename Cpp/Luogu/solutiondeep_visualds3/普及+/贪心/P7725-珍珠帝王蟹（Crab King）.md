# 题目信息

# 珍珠帝王蟹（Crab King）

## 题目背景

在一次航程中，你偶然发现了被一片礁石环绕的帝王蟹，被月岛能量侵蚀的它又与月光有着怎样的联系呢？似乎只有击败它才能见分晓。


## 题目描述

帝王蟹可以通过镶嵌宝石触发战斗，不同的宝石效果不同，但奇特的是，镶嵌宝石的顺序有时也会影响它的强度。

帝王蟹有一个初始为 $0$ 的强度值，每个宝石有属性 $op$ 和 $v$，表示：

- 若 $op$ 为 `+`，则镶嵌后帝王蟹的强度值将会加上 $v$；

- 若 $op$ 为 `*`，则镶嵌后帝王蟹的强度值将会乘上 $v$。

由于宝石的效果十分奇异，所以 $v$ 可能是负数。

作为一个有挑战精神的冒险者，你希望采取某种镶嵌方式，将**每个宝石**都镶嵌**恰好一遍**，且使得帝王蟹的强度值最大。

你只需要输出最大的强度值对 $998244353$ 取模的结果，注意这是一个 $[0, 998244353)$ 中的数。

也就是说，如果答案为 `ans`，按照 C++ 语法，你需要输出 `(ans % P + P) % P`，其中 `P = 998244353`。


## 说明/提示

**【样例 1 解释】**

按照输入顺序以 $1, 2, 3$ 标记每个宝石，所有可能的镶嵌顺序如下：

$1\to 2\to 3$：$x = ((0 + {\color{red}{-3}}) + {\color{red}{4}}) \times {\color{red}{-4}} = -4$；

$1\to 3\to 2$：$x = ((0 + {\color{red}{-3}}) \times {\color{red}{-4}}) + {\color{red}{4}} = 16$；

$2\to 1\to 3$：$x = ((0 + {\color{red}{4}}) + {\color{red}{-3}}) \times {\color{red}{-4}} = -4$；

$2\to 3\to 1$：$x = ((0 + {\color{red}{4}}) \times {\color{red}{-4}}) + {\color{red}{-3}} = -19$；

$3\to 1\to 2$：$x = ((0 \times {\color{red}{-4}}) + {\color{red}{-3}}) + {\color{red}{4}} = 1$；

$3\to 2\to 1$：$x = ((0 \times {\color{red}{-4}}) + {\color{red}{4}}) + {\color{red}{-3}} = 1$。

因此，强度值的最大值为 $16$，对 $998244353$ 取模后为 $16$。

---

**【样例 2 解释】**

按照输入顺序以 $1, 2, 3$ 标记每个宝石，所有可能的镶嵌顺序如下：

$1\to 2\to 3$：$x = ((0 + {\color{red}{-3}}) + {\color{red}{-4}}) \times {\color{red}{4}} = -28$；

$1\to 3\to 2$：$x = ((0 + {\color{red}{-3}}) \times {\color{red}{4}}) + {\color{red}{-4}} = -16$；

$2\to 1\to 3$：$x = ((0 + {\color{red}{-4}}) + {\color{red}{-3}}) \times {\color{red}{4}} = -28$；

$2\to 3\to 1$：$x = ((0 + {\color{red}{-4}}) \times {\color{red}{4}}) + {\color{red}{-3}} = -19$；

$3\to 1\to 2$：$x = ((0 \times {\color{red}{4}}) + {\color{red}{-3}}) + {\color{red}{-4}} = -7$；

$3\to 2\to 1$：$x = ((0 \times {\color{red}{4}}) + {\color{red}{-4}}) + {\color{red}{-3}} = -7$。

因此，强度值的最大值为 $-7$，对 $998244353$ 取模后为 $998244346$。

---

**【数据范围】**

**本题采用捆绑测试。**

对于全部测试数据：$1 \le n \le {10}^5$，$2 \le |v| \le {10}^6$。

- Subtask 1（26 points）：$n \le 9$，$|v| \le 5$。
- Subtask 2（22 points）：$v > 0$。
- Subtask 3（12 points）：保证当 $op$ 为 `*` 时 $v > 0$。
- Subtask 4（15 points）：保证当 $op$ 为 `+` 时 $v > 0$。
- Subtask 5（25 points）：无特殊限制。

---

![](https://cdn.luogu.com.cn/upload/image_hosting/rwzuwu9z.png)

## 样例 #1

### 输入

```
3
+ -3
+ 4
* -4
```

### 输出

```
16
```

## 样例 #2

### 输入

```
3
+ -3
+ -4
* 4
```

### 输出

```
998244346
```

# AI分析结果


### 💡 Kay的C++算法解析：珍珠帝王蟹（Crab King）深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：贪心策略与分类讨论

🗣️ **初步分析**：
> 本题核心在于通过巧妙的操作顺序最大化初始值为0的表达式结果。宝石分为加法（`+`）和乘法（`*`）两类，且数值可为负数。解题关键是将操作按正负分类后，根据**负数乘法个数的奇偶性**制定不同策略：
> - **偶数个负数乘法**：先加正数 → 乘绝对值最小的负数 → 加负数 → 乘剩余数
> - **奇数个负数乘法**：先加负数 → 乘绝对值最小的负数 → 加正数 → 乘剩余数
> 
> **可视化设计思路**：
> - 用像素方块表示数值：蓝色（正）、红色（负）、绿色（乘法操作）
> - 关键动画帧：负数乘法触发时显示符号翻转特效，并高亮当前操作的宝石
> - 复古游戏元素：成功翻转符号时播放"升级"音效，错误顺序触发"失败"音效
> - AI自动演示：逐步展示贪心策略的执行流程，调速滑块控制演示速度

---

#### 2. 精选优质题解参考
**题解一（_lfxxx_）**  
* **点评**：思路清晰度极佳，通过Subtask逐步推导出通用解法。代码规范性突出：  
  - 变量分组明确（`s1`/`s2`存储加减，`v4`存储负乘数）  
  - 巧妙使用`max4`定位绝对值最小的负乘数  
  - 算法有效性高（O(n)时间复杂度）  
  *亮点*：用`(ans % P + P) % P`优雅处理负数取模

**题解三（CBBoos0422）**  
* **点评**：分类讨论严谨（5种情况），实践价值突出：  
  - 边界处理完整（`pd1`/`pd2`标志位判空）  
  - 代码健壮性强（`(ans%P+P)%P`保证非负结果）  
  *注意点*：多重嵌套if结构可简化为switch提升可读性

**题解四（Argon_Cube）**  
* **点评**：代码结构最规整：  
  - 使用`array`分类存储四类操作  
  - `idx_plus_pst`等索引变量命名自解释  
  - 严格遵循"边运算边取模"原则  
  *学习点*：`max_element`快速定位关键负乘数

---

#### 3. 核心难点辨析与解题策略
1. **难点1：负乘数奇偶性的影响分析**  
   *分析*：奇数个负乘数最终结果为负，需用一次乘法将加负数的结果转正；偶数个则需制造最大负值后转正  
   💡 **学习笔记**：负乘数本质是符号控制器，奇偶性决定整体符号走向

2. **难点2：绝对值最小负乘数的定位**  
   *分析*：贪心要求选择`max(v)`（即绝对值最小的负数），因其对乘积影响最小  
   💡 **学习笔记**：`max_element`或手动遍历均可实现，需注意负数比较规则

3. **难点3：取模的时序处理**  
   *分析*：乘法和加法交叉时，需在每一步运算后立即取模  
   💡 **学习笔记**：使用`(a * b % mod + mod) % mod`保证中间结果合法

✨ **解题技巧总结**  
- **分类讨论法**：按操作类型/数值正负划分4种子集  
- **符号控制术**：用负乘数奇偶性决定操作序列  
- **边界防御**：显式处理空集（如`if(v4.empty())`）  
- **实时取模**：每步运算后立即取模防溢出

---

#### 4. C++核心代码实现赏析
**通用核心实现**  
```cpp
#include <iostream>
#include <vector>
using namespace std;
const int mod = 998244353;

int main() {
    int n; cin >> n;
    long long posAdd = 0, negAdd = 0, posMul = 1;
    vector<int> negMuls; // 存储负乘数

    for (int i = 0; i < n; ++i) {
        char op; int v; cin >> op >> v;
        if (op == '+') 
            v > 0 ? posAdd = (posAdd + v) % mod : negAdd = (negAdd + v) % mod;
        else 
            v > 0 ? posMul = posMul * v % mod : negMuls.push_back(v);
    }

    long long ans = 0;
    if (negMuls.empty()) { // 无非负乘数
        ans = ((posAdd * posMul) % mod + negAdd + mod) % mod;
    } else {
        int minAbs = negMuls[0]; // 定位绝对值最小负乘数
        for (int v : negMuls) if (v > minAbs) minAbs = v; 

        long long otherMul = 1;
        for (int v : negMuls) 
            if (v != minAbs) otherMul = otherMul * v % mod;

        if (negMuls.size() % 2 == 0) // 偶数策略
            ans = (((posAdd * minAbs) % mod + negAdd) % mod * posMul % mod * otherMul) % mod;
        else // 奇数策略
            ans = (((negAdd * minAbs) % mod + posAdd) % mod * posMul % mod * otherMul) % mod;
    }
    cout << (ans % mod + mod) % mod;
}
```

**代码解读概要**：  
1. 四类操作分组存储：正加(`posAdd`)、负加(`negAdd`)、正乘(`posMul`)、负乘(`negMuls`)  
2. 负乘数非空时：定位关键负乘数`minAbs`（实际是最大负数）  
3. 根据奇偶性执行不同计算序列  
4. 全程取模保证数值合法  

---

#### 5. 算法可视化：像素动画演示
**主题**：宝石镶嵌流水线（复古工厂风格）  

**关键帧设计**：  
1. **初始化**：  
   - 传送带运送宝石：蓝色(`+v`)、红色(`-v`)、绿色(`*v>0`)、紫色(`*v<0`)  
   - 控制面板：速度滑块/单步按钮/重置键  

2. **分类阶段**：  
   - 机械臂分拣宝石到四类轨道（正加/负加/正乘/负乘）  
   - 负乘轨道亮起计数器显示奇偶性  

3. **核心操作**：  
   - **偶数负乘**：  
     * 正加宝石落入计算器 → 数值上升（+音效）  
     * 紫光闪烁：关键负乘数触发符号翻转（数值变红）  
     * 负加宝石落入 → 数值下降  
     * 剩余乘法宝石依次处理  
   - **奇数负乘**：  
     * 负加宝石先处理 → 数值变红  
     * 关键负乘数触发符号翻转（红光转蓝光+音效）  
     * 正加宝石处理 → 数值回升  

4. **动态标记**：  
   - 当前操作宝石高亮黄框  
   - 实时显示数值变化公式  
   - 错误顺序时传送带停止并闪烁警报  

**技术实现**：  
- Canvas绘制像素化宝石（16x16像素）  
- 关键操作触发Web Audio音效：  
  - 加法：电子滴声  
  - 乘法：齿轮转动声  
  - 符号翻转："滋滋"电流声  

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：  
1. 操作顺序优化 → P1080 国王游戏（高精度+排序贪心）  
2. 负值处理技巧 → P2312 解方程（模运算下的负数处理）  
3. 分类讨论思想 → P7073 表达式（多种运算符优先级）  

**洛谷推荐**：  
1. **P1080** 国王游戏  
   🗣️ *掌握操作序列对结果的影响机制*  
2. **P1223** 排队接水  
   🗣️ *巩固贪心策略在排序问题中的应用*  
3. **P1094** 纪念品分组  
   🗣️ *训练分类讨论与边界处理能力*  

---

#### 7. 学习心得与经验分享
> **参考经验**：  
> "调试时发现未处理负乘数为空的情况，导致WA。应始终先处理边界条件" —— _lfxxx_  
>   
> **Kay点评**：  
> 边界条件处理是算法鲁棒性的关键，建议：  
> 1. 显式检查容器空值（如`if(negMuls.empty())`）  
> 2. 用防御性编程预设默认值  
> 3. 构造最小边界测试用例（如无负乘数/仅1个负乘数）  

--- 
**结语**：珍珠帝王蟹问题教会我们：**巧用符号控制如同掌握电流开关，正确的操作序列能让负转化为正的力量！** 下次挑战再见！🚀

---
处理用时：174.70秒
# 题目信息

# 「GMOI R2-T2」猫耳小（加强版）

## 题目背景

**本题与 [原题](https://www.luogu.com.cn/problem/P9199) 的区别在于数据范围和输出格式。在这一版本中，$n\le 10^6$，值域为 $10^9$，你需要给出构造。**

![](https://cdn.luogu.com.cn/upload/image_hosting/r8a6ylx3.png)

## 题目描述

小 R 是一个可爱的猫耳女孩子，她喜欢研究数列的 $\operatorname{mex}\text{*}$。

现在她有一个长度为 $n$ 的数列 $a$。她讨厌整数 $k$，因此她希望修改数列 $a$ 的若干个元素为任意**自然数**，使得 $a$ 的任意**连续非空子串**的 $\operatorname{mex}$ 都不等于 $k$。

请你求出最少需要修改多少个元素，并给出方案。

$\text{*}$ 本题中，数列的 $\operatorname{mex}$ 被定义为数列中最小未出现的**自然数**，例如：

- $\operatorname{mex}\{1,2,3\}=0$，因为 $0$ 是自然数。
- $\operatorname{mex}\{0,1,3\}=2$。
- $\operatorname{mex}\{0,1,2\}=3$。

## 说明/提示

**样例解释**

一种方案是将 $\{1,0,1,3,0\}$ 改为 $\{1,1,1,3,2\}$，共改动两个元素。

可以证明不存在更优的方案。

---

**评分方式**

本题采用自定义校验器（Special Judge）进行评测。

对于每个测试点，如果你的最小步数正确，可以得到 $30\%$ 的分数。在此基础上，如果方案也正确，可以得到满分。

请注意：即使你不会给出方案，也请按照输出格式在第二行输出 $n$ 个整数。

---

**本题采用捆绑测试，数据无梯度。**

对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\le k,a_i\le 10^9$。

本题读写量较大，建议使用效率较高的读写方式。

## 样例 #1

### 输入

```
5 2
1 0 1 3 0```

### 输出

```
2
1 1 1 3 2```

# AI分析结果


### 💡 Kay的C++算法解析：猫耳小（加强版）深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：贪心算法、模拟应用  
🗣️ **初步分析**：  
> 本题的核心是**贪心策略**，像玩一场"数字收集闯关游戏"：从左到右扫描数组，用"收集器"记录0~k-1的数字出现情况。当集齐所有数字时（即将触发mex=k的危险），立即将当前位置改为k（相当于放置"安全炸弹"），然后重置收集器重新开始。  
> - **核心难点**：高效维护0~k-1的出现状态（避免每次清空整个数组）  
> - **解决方案**：通过维护mex变量或懒惰标记优化状态更新  
> - **可视化设计**：用像素进度条表示数字收集（每收集一格亮起），集满时触发警报音效并显示爆炸动画，当前位置变为炸弹图标  

---

#### 2. 精选优质题解参考
**题解一 (来源：QianRan_GG)**  
* **点评**：思路最严谨清晰，用计数数组维护0~k-1出现次数，并动态更新mex值。代码规范（如`cnt`/`mex`命名直观），边界处理完整（特判k=0/k>n）。亮点在于O(n)时间复杂度，通过指针移动高效清空计数数组，实践价值极高。  

**题解二 (来源：GeorgeAAAADHD)**  
* **点评**：创新性使用懒惰标记(g/cg数组)避免显式清空计数数组。代码结构工整，核心逻辑`if(cg[a]<g)`实现O(1)重置状态，显著优化常数。亮点将算法优化与游戏化"关卡重置"概念完美结合，启发数据结构优化思维。  

**题解三 (来源：sto_5k_orz)**  
* **点评**：用set直接维护出现数字，逻辑简洁易懂（`st.size()==k`即触发）。变量名`st`/`ans`语义明确，适合初学者理解贪心本质。亮点在于直观展示"收集-重置"核心思想，虽时间复杂度O(nlogk)稍高，但代码可读性极佳。  

---

#### 3. 核心难点辨析与解题策略
1. **高效维护数字收集状态**  
   * **分析**：必须快速判断0~k-1是否集齐。优质解法用`mex`变量（当前未出现的最小自然数）或`set.size()`，避免每次遍历计数数组  
   * 💡 **学习笔记**：动态维护关键状态变量比静态检查更高效  

2. **避免重复清空的高开销**  
   * **分析**：清空计数数组时，QianRan_GG用指针移动保证总操作O(n)；GeorgeAAAADHD用懒惰标记实现O(1)清空  
   * 💡 **学习笔记**：通过范围限定或标记法消除冗余操作  

3. **特殊边界处理**  
   * **分析**：k=0时需全改为0；k>n时无需修改。所有优质解均优先处理特判  
   * 💡 **学习笔记**：先处理退化情况能让主逻辑更简洁  

### ✨ 解题技巧总结
- **状态压缩**：用变量(mex)或数据结构(set)代替完整遍历  
- **懒惰更新**：通过标记(g/cg)避免显式重置数组  
- **滑动窗口**：移动指针保证元素只被处理一次  
- **特判先行**：优先处理边界情况(k=0/k>n)  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
* **说明**：综合优质题解思路，以QianRan_GG解法为基底，融入懒惰标记优化  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    ios::sync_with_stdio(0); 
    cin.tie(0);  // 读写优化
    int n, k, mex = 0, l = 1, ans = 0;
    cin >> n >> k;
    vector<int> a(n+1), b(n+1), cnt(k+1, 0);

    for(int i=1; i<=n; ++i) {
        cin >> a[i]; b[i] = a[i];
        if(k == 0) { if(a[i]!=0) b[i]=0, ans++; }  // 特判k=0
        else if(k > n) continue;                   // 特判k>n
        else if(a[i] == k) {                       // 遇到k重置
            while(l < i) if(a[l]<k) cnt[a[l++]]--;
            mex = 0;
        } else if(a[i] < k) {                      // 收集数字
            if(++cnt[a[i]] == 1) while(cnt[mex]) mex++;
            if(mex == k) {                         // 集齐触发修改
                ans++; b[i] = k;
                while(l <= i) if(a[l]<k) cnt[a[l++]]--;
                mex = 0;
            }
        }
    }
    cout << ans << "\n";
    for(int i=1; i<=n; ++i) cout << b[i] << " ";
}
```
* **代码解读概要**：  
  > 1. 优先处理k=0/k>n的特判  
  > 2. 核心循环：遇k时清空`l~i-1`的计数；遇0~k-1时更新mex  
  > 3. 当mex=k时修改当前值为k，并清空`l~i`的计数  
  > 4. 指针`l`保证每个元素只被清空一次，时间复杂度O(n)  

**题解片段赏析**  
1. **QianRan_GG - 动态mex更新**  
   ```cpp
   while(cnt[mex]) mex++;  // 核心：跳跃式更新mex
   if(mex == k) { ... }    // 触发条件
   ```
   * **亮点**：mex的单调性避免重复扫描  
   * **学习笔记**：利用问题性质减少无效操作  

2. **GeorgeAAAADHD - 懒惰清零**  
   ```cpp
   if(cg[a] < g) {         // 检查清零标记
       cg[a] = g;          // 更新标记
       tp[a] = 0;          // 实际清零
   }
   ```
   * **亮点**：O(1)时间复杂度完成"清空"  
   * **学习笔记**：标记法替代物理清空是大数据优化利器  

3. **sto_5k_orz - set直观维护**  
   ```cpp
   st.insert(a[i]);        // 自动去重
   if(st.size() == k) {    // 集齐判断
       st.clear();         // 重置收集器
   }
   ```
   * **亮点**：直接利用STL特性简化逻辑  
   * **学习笔记**：合理调用STL可提升编码效率  

---

#### 5. 算法可视化：像素动画演示  
**主题**：复古像素风《数字冒险家》闯关游戏  
**设计思路**：用8-bit像素风格模拟贪心过程，通过进度条亮起、炸弹爆炸等游戏化元素具象化算法  

**动画关键帧**：  
1. **初始化**：  
   - 顶部显示像素化数组方块（不同颜色区分值域）  
   - 底部进度条：k个灰色格子（0~k-1）  
   - 控制面板：开始/单步/速度滑块（FC手柄样式）  

2. **数字收集阶段**：  
   - 像素小人向右移动，经过数字时：  
     * 若∈[0,k-1]：对应格子亮起（💡音效），mex值更新  
     * 若=k：触发爆炸💥（🔥音效），清空进度条  

3. **炸弹放置阶段**：  
   - 当进度条全亮：当前位置变为炸弹图标（💣）  
   - 播放爆炸动画（屏幕震动+红光闪烁），得分+10  
   - 进度条重置为灰色，mex归零  

4. **交互控制**：  
   - **单步执行**：按手柄右键逐步推进  
   - **自动演示**：AI自动闯关（可调速）  
   - **游戏化**：连击奖励（快速重置时额外加分）  

**技术实现**：  
- Canvas绘制像素网格（16x16像素/格）  
- 音效：收集(8-bit叮声)，爆炸(低音鼓点)  
- 伪代码同步：右侧显示高亮当前执行的C++代码行  

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**  
贪心策略在避免子串满足特定条件时具有普适性：  
1. 最小修改使所有子串不包含某字符集（如P2580 病毒检测）  
2. 滑动窗口维护状态约束（如P1638 逛画展）  
3. 懒惰更新优化计数（如P3663 奶牛集会）  

**洛谷练习推荐**  
1. **P9199** - 猫耳小（原题）  
   → 巩固贪心策略在mex问题的基础应用  
2. **P3405** - Cities and States S  
   → 练习高效状态维护与计数技巧  
3. **P3558** - Bytecomputer  
   → 学习线性DP与贪心思想的结合  

---

#### 7. 学习心得与经验分享
> **参考经验 (来自 QianRan_GG)**：  
> "处理k=0和k>n的特判是AC的关键，否则会WA在隐蔽测试点"  
> **Kay点评**：再次验证了"先特判退化情况"的重要性，特别是边界值（0/极大值）往往是陷阱高发区。  

> **参考经验 (来自 GeorgeAAAADHD)**：  
> "懒惰清零让代码从O(nk)优化到O(n)"  
> **Kay点评**：数据结构优化常能带来数量级提升，标记法是空间换时间的经典技巧。  

---

通过本次分析，希望大家掌握贪心策略的核心思想——**及时切断危险状态**，并学会用数据结构优化状态维护。记住，算法竞赛如同像素游戏，找准关键操作才能高效通关！🎮💻

---
处理用时：237.13秒
# 题目信息

# [JOI 2023 Final] 宣传 2 / Advertisement 2

## 题目描述

JOI 王国有 $N$ 位居民，编号从 $1$ 到 $N$。居民 $i$ ($1 \le i \le N$) 住在实数轴上的坐标 $X_i$ 处，其**影响力**为 $E_i$。可能有多个居民住在同一坐标处。拥有较大影响力的居民具有较高的广告潜力，但这样的居民在购买书籍时很谨慎。

Rie 出版了一本信息学的书。为了鼓励更多人购买这本书，她可以向一些居民赠送这本书的副本。如果她向居民 $i$ ($1 \le i \le N$) 赠送了一本书，居民 $i$ 将获得 Rie 的书。此外，在尚未获得书的居民中，满足以下条件的每位居民 $j$ ($1 \le j \le N$) 都会购买一本书并获得它。

- 居民 $i$ 和居民 $j$ 在实数轴上的距离小于或等于 $E_i - E_j$。换句话说，满足 $|X_i - X_j| \le E_i - E_j$。

如果所有居民都阅读了 Rie 的书，信息学奥林匹克将得到极大的认可。编写一个程序，计算需要向多少位居民赠送 Rie 的书，才能使 JOI 王国的所有居民都获得 Rie 的书。

## 说明/提示

## 样例

### 样例 1

例如，如果 Rie 按以下方式赠送书，JOI 王国的所有居民将获得 Rie 的书。

- Rie 向居民 3 赠送了一本书。
  - 因为 $|X_3 - X_1| = 1$ 且 $E_3 - E_1 = 2$，居民 1 会购买一本 Rie 的书并获得它。
  - 因为 $|X_3 - X_2| = 1$ 且 $E_3 - E_2 = 1$，居民 2 会购买一本 Rie 的书并获得它。
  - 因为 $|X_3 - X_4| = 3$ 且 $E_3 - E_4 = -1$，居民 4 不会购买 Rie 的书。
  因此，居民 1、2、3 将获得 Rie 的书。
- Rie 向居民 4 赠送了一本书。由于除了居民 4 之外的所有居民都已经获得了 Rie 的书，最终 JOI 王国的所有居民都获得了 Rie 的书。

由于不可能向少于两位居民赠送书以使 JOI 王国的所有居民都获得 Rie 的书，因此输出 2。

此样例输入满足子任务 2、3、4 的约束。

### 样例 2

此样例输入满足所有子任务的约束。

### 样例 3

此样例输入满足子任务 2、3、4 的约束。

## 约束

- $1 \le N \le 5 \times 10^5$。
- $1 \le X_i \le 10^9$ ($1 \le i \le N$)。
- $1 \le E_i \le 10^9$ ($1 \le i \le N$)。
- 给定值均为整数。

## 子任务

1. (10 分) $E_1=E_2=\cdots=E_N$。
2. (23 分) $N \le 16$。
3. (36 分) $N \le 10^3$。
4. (31 分) 无额外约束。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
4
4 2
2 3
3 4
6 5
```

### 输出

```
2
```

## 样例 #2

### 输入

```
3
7 10
10 10
7 10
```

### 输出

```
2
```

## 样例 #3

### 输入

```
10
31447678 204745778
430226982 292647686
327782937 367372305
843320852 822224390
687565054 738216211
970840050 766211141
563662348 742939240
103739645 854320982
294864525 601612333
375952316 469655019
```

### 输出

```
5```

# AI分析结果


### 💡 Kay的C++算法解析：宣传 2 / Advertisement 2 深入学习指南 💡

<introduction>
大家好！今天我们来分析JOI 2023 Final的题目《宣传 2》。这道题考察如何用最少初始赠书人数覆盖所有居民，涉及巧妙的坐标变换和贪心思想。让我们一步步拆解核心思路，并通过像素动画直观理解算法过程！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心策略 + 坐标变换`（编程技巧应用）

🗣️ **初步分析**：
> 想象每个居民是一个灯塔✨，**影响力(E_i)**决定光照范围。初始赠送书就像点亮灯塔，光照范围（满足$|X_i-X_j| \le E_i-E_j$）内的居民会被"照亮"（获得书）。我们的目标是点亮最少的灯塔照亮全国。

- **核心转换**：将绝对值不等式拆解为二维偏序条件（$E_j-X_j \le E_i-X_i$ 且 $E_j+X_j \le E_i+X_i$），相当于把每个居民映射到点$(E_i+X_i, E_i-X_i)$。覆盖问题转化为**选择最少的点，使得其"右下区域"覆盖所有点**。
- **算法流程**：按横坐标排序后，用单调栈维护纵坐标递减序列（栈大小即答案）。可视化中将用**像素网格**展示点坐标，**高亮栈操作**（弹出/压入）和**覆盖区域变化**。
- **复古游戏化设计**：采用**8-bit像素风**网格地图，居民显示为不同颜色像素块：
  - **音效**：入栈时"叮🔔"，弹出时"噗💨"，完成时"胜利🎶"
  - **交互**：步进控制+自动播放模式（调速滑块），AI自动演示如"贪吃蛇"般逐步扩展覆盖
  - **动态效果**：被覆盖点变暗💡，栈中点高亮闪烁✨

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法效率等维度，我精选了3份≥4星的优质题解：
</eval_intro>

**题解一（作者：djh0314）**
* **点评**：思路最简洁直白，**拆解绝对值**的转化方法讲解清晰。代码用`pair`存储新坐标，**单调栈维护**纵坐标递减序列（8行核心逻辑），变量命名规范（`x,y`直指核心）。时间复杂度$O(n\log n)$，空间$O(n)$，竞赛实战性强。亮点在于用**几何图示**辅助解释栈操作，帮助理解"为什么栈大小就是答案"。

**题解二（作者：白简）**
* **点评**：提供**贪心视角**的另一种实现：按纵坐标降序排序，**横向扫描**更新最大横坐标。代码结构工整（`cmp`函数分离排序逻辑），边界处理严谨（`LLONG_MIN`初始化）。亮点在于强调**双关键字排序规则**（$y$相同时$x$降序），避免覆盖遗漏。

**题解三（作者：free_fall）**
* **点评**：与白简思路一致但代码更紧凑，**5行核心贪心**逻辑凸显算法本质。使用结构体数组替代`pair`增强可读性，`ans++`和`max`更新直观体现代码意图。亮点在于用**灯塔比喻**解释贪心选择策略，便于初学者理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点，结合优质题解策略如下：
</difficulty_intro>

1.  **难点1：绝对值条件的转化**
    * **分析**：原始条件$|X_i-X_j| \le E_i-E_j$难以直接处理。优质题解均拆解为两个不等式，通过**移项构造新坐标**$(E_i+X_i, E_i-X_i)$，转化为二维偏序问题。
    * 💡 **学习笔记**：绝对值不等式 → 尝试坐标变换 → 二维偏序

2.  **难点2：覆盖关系的最优选择**
    * **分析**：如何证明"单调栈大小=最小赠书数"？需理解**若点$i$在点$j$右下方，则$i$覆盖$j$**。按横坐标排序后，维护纵坐标递减栈即保证每个栈元素"独立覆盖区域"。
    * 💡 **学习笔记**：排序后栈维护 → 独立覆盖区 → 栈大小=最小点数

3.  **难点3：排序的细节处理**
    * **分析**：当横坐标相同时，**纵坐标大的优先**（保证覆盖关系正确）。否则可能出现小纵坐标点无效入栈，导致答案偏大。
    * 💡 **学习笔记**：双关键字排序时，第二关键字影响覆盖关系！

### ✨ 解题技巧总结
<summary_best_practices>
从本题提炼的通用技巧：
</summary_best_practices>
- **技巧1：几何化抽象** → 将距离/范围问题转化为二维平面点覆盖
- **技巧2：单调性维护** → 遇到偏序关系时，排序+栈/队列维护是常见优化手段
- **技巧3：边界测试** → 验证横/纵坐标相等、极值点等边界情况

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个融合优质题解优点的**通用实现**（基于djh0314的单调栈法）：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合djh0314和白简思路，按横坐标排序+纵坐标单调栈，代码简洁高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    #define int long long
    using namespace std;
    const int N = 5e5 + 5;
    struct Point { int x, y; } a[N]; // x=E+X, y=E-X
    int n, top, stk[N]; // 单调栈

    signed main() {
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            int X, E; cin >> X >> E;
            a[i] = {E + X, E - X}; // 坐标变换
        }
        // 按x升序，x相同时y降序（保证覆盖关系）
        sort(a + 1, a + n + 1, [](Point p, Point q) {
            return p.x < q.x || (p.x == q.x && p.y > q.y);
        });
        for (int i = 1; i <= n; ++i) {
            // 维护纵坐标y的单调递减栈
            while (top && a[stk[top]].y <= a[i].y) top--;
            stk[++top] = i;
        }
        cout << top << endl;
    }
    ```
* **代码解读概要**：
    > 1. **坐标转换**：将$(X_i, E_i)$映射为$(E_i+X_i, E_i-X_i)$  
    > 2. **关键排序**：按新x坐标升序，x相同时y降序（确保后处理的点能覆盖先处理的点）  
    > 3. **单调栈维护**：遍历中保持栈内y坐标严格递减（栈大小即答案）  

---
<code_intro_selected>
优质题解的核心片段赏析：
</code_intro_selected>

**题解一（djh0314）**
* **亮点**：单调栈实现极致简洁，变量名`x,y`直指核心
* **核心代码片段**：
    ```cpp
    sort(a+1,a+n+1); // 默认按x升序
    for(int i=1;i<=n;++i) {
        while(top&&a[q[top]].y<=a[i].y) --top;
        q[++top]=i; // 栈存储索引
    } 
    cout<<top;
    ```
* **代码解读**：
    > `a[q[top]].y`是栈顶点的纵坐标，`a[i].y`是当前点纵坐标。  
    > **Q**：为什么`<=`时要弹出栈顶？  
    > **A**：当前点$i$的y更大 → 其"覆盖区域"包含栈顶点 → 栈顶点冗余！  
    > 最终栈内每个点都是"必要点"，其y坐标严格递减 → 栈大小=最小赠书数
* 💡 **学习笔记**：单调栈维护的是"无法被覆盖"的独立点集

**题解二（白简）**
* **亮点**：贪心扫描思路，省去栈空间
* **核心代码片段**：
    ```cpp
    sort(t + 1, t + n + 1, cmp); // 按y降序排序
    long long Max = LLONG_MIN >> 4;
    for(int i = 1; i <= n; i++) {
        if(t[i].x > Max) ans++; // 当前点未被覆盖
        Max = max(Max, t[i].x); // 更新最大x值
    }
    ```
* **代码解读**：
    > **排序规则**：`cmp`函数使点按y降序（`y=E+X`大的先处理）  
    > **核心变量**：`Max`记录当前最大x值（`x=E-X`）  
    > **贪心逻辑**：若当前点x > Max，说明其未被前面点覆盖 → 需初始赠书
* 💡 **学习笔记**：按一维降序排序后，另一维只需比较最大值

**题解三（free_fall）**
* **亮点**：结构体封装+初始化技巧
* **核心代码片段**：
    ```cpp
    struct kk{ int x,y; }; // x=E-X, y=E+X
    // 排序规则：y降序，y相同时x降序
    bool operator<(const kk &o)const{ 
        if(y==o.y) return x>o.x; 
        return y>o.y; 
    }
    now = -inf; // 初始化负无穷
    for(auto p : a){
        if(p.x > now) ans++; // 发现未覆盖点
        now = max(now, p.x);
    }
    ```
* **代码解读**：
    > **初始化技巧**：`now = -inf`确保第一个点必被选中  
    > **运算符重载**：自定义排序规则清晰隔离核心逻辑  
    > **语义明确**：`p.x > now`直接对应物理意义"未被覆盖"
* 💡 **学习笔记**：合理初始化避免边界特判

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解单调栈的工作过程，我设计了**像素灯塔覆盖模拟器**！通过复古8-bit风格动画，你将看到点如何被覆盖、栈如何更新，就像在玩策略塔防游戏~
</visualization_intro>

* **动画演示主题**：`像素灯塔覆盖战`
* **核心演示内容**：坐标变换后的点阵图，单调栈维护过程，覆盖区域动态扩展
* **设计思路**：采用FC红白机像素风格，用不同颜色区分"栈内点"、"被覆盖点"、"待处理点"。游戏化进度激励（每正确入栈一个点+10分）

* **动画帧步骤与交互关键点**：
  1. **初始化场景**：
     - 8-bit网格坐标系：横轴`E+X`，纵轴`E-X`
     - 居民显示为彩色像素块（位置由转换后坐标决定）
     - 控制面板：开始/暂停、单步执行、速度滑块、重置按钮

  2. **排序阶段**：
     - 像素块沿横轴冒泡排序动画（伴随"嘟嘟"音效）
     - 最终状态：所有点从左到右排列，同横坐标时纵坐标大的在上

  3. **单调栈扫描**（主动画）：
     ```markdown
     帧1：当前点高亮闪烁（黄色边框）
     帧2：检查栈顶（红线连接当前点与栈顶点）
         - 若当前点y > 栈顶y：栈顶点变暗（覆盖音效"噗💨"），弹出栈
         - 重复直到栈空或栈顶y > 当前y
     帧3：当前点入栈（绿色高亮），播放"叮🔔"音效
     帧4：栈内点覆盖区域显示为半透明绿色矩形（向右下方延伸）
     ```

  4. **AI自动演示模式**：
     - 点击"AI演示"后，动画以可调速自动播放
     - 如同贪吃蛇AI：自动移动高亮框，智能决策入栈/弹出
     - 每步间隔0.3秒，关键操作伴随像素粒子特效

  5. **游戏化反馈**：
     - 成功入栈：点像素放大跳动+金币音效，分数+10
     - 错误操作（测试功能）：红色闪烁+警告音
     - 最终通关：栈中点放烟花，播放胜利BGM🎶

* **技术实现**：
  - **绘制逻辑**：Canvas绘制网格和像素块，入栈时添加CSS跳动动画
  - **音效触发**：Web Audio API在弹出时播放低音(200Hz)，入栈时高音(600Hz)
  - **颜色方案**：
    - 栈内点：`#00FF00`（绿）
    - 被覆盖点：`#888888`（灰）
    - 当前点：`#FFFF00`（黄）
    - 待处理点：`#FF0000`（红）

<visualization_conclusion>
通过这个像素动画，你将直观看到：**为什么按横坐标排序后，纵坐标需要严格递减？** 每当有更高纵坐标的点出现，它就"统治"了更广的覆盖区域，使左侧低点冗余——这正是单调栈优化的本质！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握坐标变换和单调栈技巧后，试试下面几道变形题：
</similar_problems_intro>

* **通用思路迁移**：
  - 场景1：区间覆盖问题（如选择最少的区间覆盖整个线段）
  - 场景2：二维偏序统计（如逆序对计数）
  - 场景3：几何包含关系（如矩形覆盖）

* **练习推荐 (洛谷)**：
  1. **P1908 逆序对**  
     🗣️ **推荐理由**：二维偏序基础训练，巩固排序+树状数组/归并排序的应用
  
  2. **P4054 [JSOI2009]计数问题**  
     🗣️ **推荐理由**：将矩阵查询转化为二维偏序，练习坐标压缩技巧
  
  3. **P5490 扫描线模板**  
     🗣️ **推荐理由**：矩形覆盖问题的经典解法，提升对覆盖关系的理解

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的调试经验是宝贵的学习资源：
</insights_intro>

> **参考经验 (来自 djh0314)**：  
> "拆绝对值是惯用思路，但需注意变换后坐标的物理意义。调试时先验证小规模样例（如n=3）的栈操作序列"
>
> **点评**：这提醒我们：  
> 1. **代数变换**需结合几何直观理解  
> 2. **小规模测试**是验证贪心正确性的关键  
> 3. 打印中间状态（如栈内元素）快速定位逻辑错误  

> **参考经验 (来自 白简)**：  
> "双关键字排序时，第二关键字顺序会影响覆盖结果，我因此WA了两次"
>
> **点评**：惨痛教训告诉我们：  
> - **排序规则**必须严格匹配算法需求  
> - 当$x_i = x_j$时，按$y_i$降序保证"更大影响力的点优先处理"  

---

<conclusion>
本次《宣传 2》的解析就到这里！通过坐标变换，我们将复杂的影响关系转化为优雅的二维偏序问题，再通过单调栈/贪心高效求解。记住：**好的算法就像灯塔，用最少的资源照亮整个地图**✨ 多动手实现代码，再搭配我们的像素动画观察运行过程，你一定能彻底掌握这个技巧！下次见~ 
</conclusion>

---
处理用时：206.49秒
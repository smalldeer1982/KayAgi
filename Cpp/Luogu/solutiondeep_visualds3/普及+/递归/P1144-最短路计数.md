# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



---
# 💡 Kay的C++算法解析：最短路计数 深入学习指南 💡

<introduction>
今天我们来一起分析“最短路计数”这道经典的图论问题。这道题不仅需要计算从顶点1到其他顶点的最短路径长度，还要统计每条最短路径的数量。通过这份指南，我们将理解核心算法、关键技巧，并通过可视化动画直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（最短路计数）`

🗣️ **初步分析**：
解决“最短路计数”的关键在于结合最短路算法（如BFS、SPFA、Dijkstra）与路径计数逻辑。由于题目是**无向无权图**（边权为1），最短路径的长度等于路径上的边数，因此可以用BFS（广度优先搜索）高效计算最短路。BFS天然按层遍历的特性，正好对应最短路径的层级扩展。

在本题中，我们需要维护两个关键数组：
- `d[i]`：顶点1到顶点i的最短路径长度。
- `ans[i]`：顶点1到顶点i的最短路径数量。

**核心逻辑**：
当通过顶点u访问顶点v时：
1. 若`d[v] > d[u] + 1`（发现更短路径）：更新`d[v] = d[u] + 1`，并将`ans[v]`设为`ans[u]`（因为u是当前唯一的前驱）。
2. 若`d[v] == d[u] + 1`（发现等长路径）：将`ans[v]`累加`ans[u]`（因为u是新的前驱，贡献新的路径数）。

**可视化设计思路**：采用8位像素风格动画，用不同颜色标记顶点状态（如未访问、已访问、当前处理），队列用像素方块堆叠表示。每处理一个顶点时，高亮其邻接顶点，动态更新`d`和`ans`数组的数值，关键操作（如路径更新、计数累加）配合“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法效率等维度，以下题解因逻辑简洁、实现高效且易于学习，被选为优质参考：
</eval_intro>

**题解一：岸芷汀兰（BFS解法）**
* **点评**：此题解巧妙利用BFS处理无权图的特性，代码结构清晰。通过`vector`存储邻接表，队列按层遍历确保最短路径的正确性。关键步骤（如首次访问时初始化计数、等长路径时累加计数）注释明确，适合初学者理解。

**题解二：ZiDing_ByronFinlso（SPFA解法）**
* **点评**：SPFA在无权图中与BFS效果类似，但此题解通过队列优化实现，代码简洁高效。对大规模数据（如N=1e6）仍能保持较好性能，且模运算处理严谨（`ans[y] %= mod`），避免溢出。

**题解三：King丨帝御威（Dijkstra堆优化解法）**
* **点评**：Dijkstra堆优化适用于更广泛的场景（如带权图），此题解展示了如何在堆优化框架中集成计数逻辑。通过优先队列确保每次处理当前最短距离的顶点，代码变量名（如`js`表示计数）直观，适合学习堆优化的扩展应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，以下三个关键点需重点突破：
</difficulty_intro>

1.  **关键点1：如何正确维护最短路径计数？**
    * **分析**：当通过顶点u访问顶点v时，若v未被访问过（首次找到最短路径），则`ans[v] = ans[u]`；若v已被访问且当前路径长度等于最短路径（找到新的等长路径），则`ans[v] += ans[u]`。需注意模运算防止溢出。
    * 💡 **学习笔记**：计数的核心是“前驱贡献”，即每个顶点的最短路径数等于所有前驱顶点最短路径数的和。

2.  **关键点2：如何高效处理大规模图？**
    * **分析**：数据规模大（N=1e6，M=2e6），需用邻接表存储图（避免邻接矩阵的空间浪费）。BFS/SPFA的时间复杂度为O(M)，Dijkstra堆优化为O(M log N)，均能满足要求。
    * 💡 **学习笔记**：邻接表（`vector`或链式前向星）是处理大规模图的首选结构。

3.  **关键点3：如何避免重复计数？**
    * **分析**：BFS按层遍历保证每个顶点仅被首次访问时确定最短路径长度，后续访问若路径等长则累加计数，不会重复计算更短路径。SPFA/Dijkstra需通过标记数组避免重复入队。
    * 💡 **学习笔记**：BFS的层级特性天然避免了重复计数，是无权图最短路计数的最优选择。

### ✨ 解题技巧总结
- **技巧A（BFS优先）**：无权图中，BFS按层遍历直接对应最短路径层级，无需复杂优化，代码简洁高效。
- **技巧B（邻接表存储）**：用`vector`或链式前向星存储图，空间复杂度O(M)，适合大规模数据。
- **技巧C（模运算及时）**：每一步计数累加后立即取模（如`ans[y] %= mod`），避免整数溢出。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，采用BFS算法（无权图最优解），逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码基于BFS实现，利用队列按层遍历，维护最短路径长度和计数。适用于无权图，时间复杂度O(N+M)，空间复杂度O(N+M)。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <queue>
    using namespace std;

    const int MOD = 100003;
    const int MAXN = 1e6 + 5;

    vector<int> adj[MAXN]; // 邻接表存储图
    int d[MAXN];           // 最短路径长度
    int ans[MAXN];         // 最短路径数量
    bool vis[MAXN];        // 访问标记

    void bfs(int start) {
        queue<int> q;
        q.push(start);
        vis[start] = true;
        d[start] = 0;
        ans[start] = 1;

        while (!q.empty()) {
            int u = q.front();
            q.pop();

            for (int v : adj[u]) {
                if (!vis[v]) {
                    vis[v] = true;
                    d[v] = d[u] + 1;
                    ans[v] = ans[u];
                    q.push(v);
                } else if (d[v] == d[u] + 1) {
                    ans[v] = (ans[v] + ans[u]) % MOD;
                }
            }
        }
    }

    int main() {
        int n, m;
        scanf("%d %d", &n, &m);

        for (int i = 0; i < m; ++i) {
            int u, v;
            scanf("%d %d", &u, &v);
            adj[u].push_back(v);
            adj[v].push_back(u); // 无向图，双向添加边
        }

        bfs(1);

        for (int i = 1; i <= n; ++i) {
            printf("%d\n", ans[i]);
        }

        return 0;
    }
    ```
* **代码解读概要**：
  1. **输入处理**：读取顶点数和边数，用邻接表存储无向图。
  2. **BFS初始化**：起点1入队，标记为已访问，最短路径长度为0，计数为1。
  3. **层级遍历**：每次取出队列顶点u，遍历其邻接顶点v：
     - 若v未访问过：记录最短路径长度，初始化计数，v入队。
     - 若v已访问且路径等长：累加计数（模运算防溢出）。
  4. **输出结果**：遍历所有顶点，输出最短路径数量。

---
<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：岸芷汀兰（BFS解法）**
* **亮点**：使用`vector`邻接表，代码简洁，符合BFS层级遍历的直观逻辑。
* **核心代码片段**：
    ```cpp
    queue<Node> q; q.push(make(1, 0));
    memset(d, 0x3f, sizeof(d)); d[1] = 0;
    vis[1] = true; ans[1] = 1;
    while (q.size()) {
        int u = q.front().node, dis = q.front().dis; 
        q.pop();
        for (int i = 0; i < linker[u].size(); i++) {
            int v = linker[u][i];
            if (!vis[v]) {
                q.push(make(v, dis + 1)); 
                vis[v] = true; 
                d[v] = dis + 1; 
                ans[v] = (ans[v] + ans[u]) % mod;
            } else if (dis + 1 == d[v]) {
                ans[v] = (ans[v] + ans[u]) % mod;
            }
        }
    }
    ```
* **代码解读**：
  - `linker[u]`存储顶点u的邻接顶点，`q`按层存储待处理顶点。
  - 首次访问顶点v时，初始化`d[v]`和`ans[v]`；后续等长路径时累加`ans[v]`。
  - 模运算确保结果在合理范围内。
* 💡 **学习笔记**：BFS的队列天然保证顶点按最短路径长度顺序处理，是计数的关键。

**题解二：ZiDing_ByronFinlso（SPFA解法）**
* **亮点**：SPFA队列优化，适合理解更通用的最短路计数逻辑。
* **核心代码片段**：
    ```cpp
    while (q.size()) {
        x = q.front(); q.pop();
        p[x] = 0;
        for (int i = head[x]; i; i = nxt[i]) {
            y = to[i];
            if (d[y] > d[x] + 1) {
                d[y] = d[x] + 1;
                ans[y] = ans[x];
                if (!p[y]) { q.push(y); p[y] = 1; }
            } else if (d[y] == d[x] + 1) {
                ans[y] = (ans[y] + ans[x]) % mod;
            }
        }
    }
    ```
* **代码解读**：
  - `p[y]`标记顶点是否在队列中，避免重复入队。
  - 当发现更短路径时，更新`d[y]`和`ans[y]`；等长时累加`ans[y]`。
  - 适用于边权相同或不同的场景（本题边权为1）。
* 💡 **学习笔记**：SPFA是BFS的扩展，通过队列动态调整顶点处理顺序，适合稀疏图。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解BFS如何计算最短路径及计数，我们设计一个“像素探险家”主题的8位风格动画，模拟从顶点1出发，逐层探索图的过程。
</visualization_intro>

  * **动画演示主题**：`像素探险家的最短路径之旅`

  * **核心演示内容**：展示BFS队列的层级扩展、顶点访问顺序、`d`和`ans`数组的动态更新，以及等长路径时的计数累加。

  * **设计思路简述**：8位像素风格（如FC游戏画面）降低学习门槛；队列用堆叠的像素方块表示，顶点颜色区分状态（未访问：灰色，已访问：蓝色，当前处理：黄色）；关键操作（如路径更新、计数累加）配合“叮”音效，强化记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示像素网格（顶点用圆形块表示，边用细线连接）。
        - 右侧显示`d`和`ans`数组的当前值（动态更新）。
        - 控制面板：单步/自动播放按钮、速度滑块（调节动画速度）。

    2.  **BFS启动**：
        - 顶点1（起点）高亮为绿色，队列中加入顶点1的像素块（音效：“滴”）。
        - `d[1]`显示为0，`ans[1]`显示为1。

    3.  **层级扩展**：
        - 取出队列顶部顶点u（黄色闪烁），遍历其邻接顶点v：
          - 若v未访问（灰色）：v变为蓝色，`d[v]`更新为`d[u]+1`，`ans[v]`设为`ans[u]`，v入队（音效：“滑入”）。
          - 若v已访问且`d[v] == d[u]+1`：`ans[v]`数值跳动并累加`ans[u]`（音效：“叮”）。

    4.  **目标达成**：
        - 所有顶点处理完成后，播放“胜利”音效（上扬音调），最终`ans`数组完整显示。

    5.  **交互控制**：
        - 单步执行：每点击一次，处理一个顶点。
        - 自动播放：按设定速度连续执行，可暂停/重置。

  * **旁白提示**：
    - “现在处理顶点u，它的邻接顶点v未被访问过，v的最短路径长度是u+1，路径数继承u的！”
    - “v已经被访问过，且当前路径长度等于最短路径，v的路径数要加上u的路径数哦~”

<visualization_conclusion>
通过这样的动画，我们能直观看到BFS如何逐层扩展，以及路径计数如何从起点1逐步传递到其他顶点，理解“前驱贡献”的核心逻辑。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可通过以下题目进一步巩固最短路计数的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    最短路计数的核心是“前驱贡献”，此思路可迁移到：
    - 带权图的最短路径计数（如P1608）。
    - 有向无环图（DAG）的路径计数（如拓扑排序结合动态规划）。
    - 多源最短路径计数（如Floyd算法扩展）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1608** - `路径统计`
        * 🗣️ **推荐理由**：带权图的最短路径计数，需处理边权不同的情况，适合深化计数逻辑。
    2.  **洛谷 P4479** - `最短路径计数`
        * 🗣️ **推荐理由**：与本题类似，但顶点数更大（1e5），需优化算法效率。
    3.  **洛谷 P2149** - `[SDOI2009]Elaxia的路线`
        * 🗣️ **推荐理由**：双源最短路径的交集计数，考察对最短路径性质的理解。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自XZYQvQ)**：“直接使用SPFA计数可能在某些场景下出错（如边权不同时），建议先求最短路长度，再DFS遍历最短路图计数。”

**点评**：此经验提醒我们，SPFA的松弛顺序可能影响计数的正确性（如边权不同时，同一顶点可能被多次松弛）。对于更复杂的图（如带权图），先确定最短路径长度，再通过拓扑排序或DFS计数更可靠。这一技巧在处理非无权图时尤为重要。

---

<conclusion>
通过对“最短路计数”的分析，我们掌握了BFS/SPFA/Dijkstra中集成计数的方法，理解了“前驱贡献”的核心逻辑。编程能力的提升需要多练习、多思考，希望大家通过本题的学习，能举一反三，解决更多图论问题！💪
</conclusion>

---

---
处理用时：173.48秒
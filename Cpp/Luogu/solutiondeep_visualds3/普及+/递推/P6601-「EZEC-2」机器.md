# 题目信息

# 「EZEC-2」机器

## 题目背景

tlx 喜欢科幻小说。   

>小宇宙中只剩下漂流瓶和生态球。漂流瓶隐没于黑暗里,在一千米见方的宇宙中,只有生态球里的小太阳发出一点光芒。在这个小小的生命世界中,几只清澈的水球在零重力环境中静静地飘浮着,有一条小鱼从一只水球中蹦出,跃入另一只水球,轻盈地穿游于绿藻之间。在一小块陆地上的草丛中,有一滴露珠从一片草叶上脱离,旋转着飘起,向太空中折射出一缕晶莹的阳光。    
>$\qquad \qquad \qquad \qquad \qquad \qquad \qquad\qquad\qquad\qquad\qquad\qquad\qquad --$《三体》    

在另一个宇宙，将是另一番奇景吧。    

在那里，重力似乎变得微不足道了，引力机器成了司空见惯的东西。

引力机器装置内并没有重力，即若有物体在机器上运动，运动过程中只受机器给予的引力，这个力有一定几率使物体向施力物体快速移动，达到一定动力时就可以实现瞬移。



## 题目描述

一个引力机器由一个光滑圆轨道和 $2n$ 个小孔组成（小孔按**逆时针**从 $1$ 到 $2n$ 编号，每两个相邻的小孔所夹的**劣弧**度数为 $\dfrac{\pi}{n}$ ），每个小孔与和其夹角为 $\pi$ 的另一个小孔有通道相连，比如当 $n=2$ 时，$1$ 号孔和 $3$ 号孔相连。

当 $n=2$ 时，这个装置的构造大概是这样的：
 
 ![](https://cdn.luogu.com.cn/upload/image_hosting/el8alxde.png) 
 
现在我们在 $1$ 号孔处放一个小球，使它一直**沿逆时针方向做匀速圆周运动**，在不瞬移的情况下，每一秒恰好能从一个小孔运动至下一个小孔。

由于未来实验室构造奇特（内部的引力提供装置太神了！），每经过一个小孔时，有 $p$ 的概率**立刻瞬移**（即不花费时间）到通道对面的小孔并继续沿逆时针方向做匀速圆周运动，也就是有 $1-p$ 的概率继续沿圆周向下一个小孔运动。

值得注意的是，**每一单位时刻，小球只能瞬移一次**。  

简单地说，若某一时刻小球在小孔 $i$，则下一时刻它可能运动到小孔 $i \bmod 2n + 1$ 或 $(i + n) \bmod 2n + 1$，概率分别为 $1-p$ 和 $p$。

现在 tlx 有两个一模一样的引力机器，两个小球同时从 $1$ 号孔开始运动。他会**随机**（所有可能选择的概率相同）选择一个二元组 $(i,j)( 1\leqslant i\leqslant 2n,0\leqslant j\leqslant t,i,j\in \mathbb Z$ ) 分别代表小孔编号和时间，你需要求出时间为 $j$ 时两个引力机器的小孔 $i$ **同时**有小球**停留（运动经过小孔但瞬移到对面了不算停留）** 的概率。

注意：**小球刚开始运动时也可能瞬移到对面的小孔。**   

为方便计算，我们规定：所有概率都是在模 $10^9+7$ 意义下的。      

## 说明/提示

**【数据范围与约定】** 

**本题采用捆绑测试。**    

具体计分方式如下：   

- Subtask $1$ ($7$ points)：满足 $p\in \{0,1\}$；  
- Subtask $2$ ($13$ points)：满足 $t\leqslant 20,n\leqslant50$；  
- Subtask $3$ ($20$ points)：满足 $t\leqslant 10^3,n\leqslant50$；  
- Subtask $4$ ($10$ points)：满足 $t\leqslant 10^3$；  
- Subtask $5$ ($10$ points)：满足 $t\leqslant 10^6$；
- Subtask $6$ ($15$ points)：满足 $n\leqslant50$；
- Subtask $7$ ($25$ points)：无特殊限制。


对于 $100\%$ 的数据，满足 $2\leqslant n\leqslant 500$，$0\leqslant p\leqslant 10^9+6$，$0\leqslant t \leqslant 10^9$。  

**注意：不做说明的数据范围即为极限数据范围。**

**【样例解释 #1】**  

$500000004$ 是模 $10^9+7$ 意义下的 $\dfrac{1}{2}$。 

下面为了方便，记 $P(i,j)$ 为选择的二元组为 $(i,j)$ 时的概率。    

所有概率不为 $0$ 的二元组有：   
$P(1,0)=\dfrac{1}{4},P(3,0)=\dfrac{1}{4},P(2,1)=\dfrac{1}{4},P(4,1)=\dfrac{1}{4}$。    

所有可以选择的二元组有：   
$(1,0),(1,1),(2,0),(2,1),(3,0),(3,1),(4,0),(4,1)$，共 $8$ 种。    

所以总的概率：  
$$P=\dfrac{1}{8}×\dfrac{1}{4}×4+\dfrac{1}{8}×0×4=\dfrac{1}{8}$$

在模 $10^9+7$ 意义下为 $125000001$，即为输出的答案。

------------

**【其他提示】**

1. 如果你不了解分数取模，可以查看[这里](https://www.luogu.com.cn/problem/P2613)。  

2. 如果你不明白题目中角度的表示方法，可以查看[弧度制](https://baike.baidu.com/item/弧度制/3315973?fr=aladdin)。



## 样例 #1

### 输入

```
2 500000004 1```

### 输出

```
125000001```

## 样例 #2

### 输入

```
6 114514 11```

### 输出

```
756497239```

# AI分析结果



---
# 💡 Kay的C++算法解析：「EZEC-2」机器 深入学习指南 💡

<introduction>
今天我们来一起分析“「EZEC-2」机器”这道C++编程题。这道题涉及概率计算、数学推导和矩阵快速幂优化，是一道综合性较强的题目。本指南将帮助大家梳理题目核心逻辑，理解关键算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（二项式定理、等比数列求和）与动态规划（矩阵快速幂优化）

🗣️ **初步分析**：
解决这道题的关键在于理解小球的移动规律与概率计算。题目中，小球每秒有两种选择：以概率 \(1-p\) 逆时针移动一个孔，或以概率 \(p\) 瞬移到对面的孔。我们需要计算两个机器的小球在随机选择的时间 \(j\) 和孔 \(i\) 时同时停留的概率。

### 核心思路与算法应用
- **数学推导**：通过观察，两个小球在同一位置的充要条件是它们的瞬移次数模2同余（即奇偶性相同）。利用二项式定理可简化偶数次/奇数次瞬移的概率求和，将其转化为等比数列求和问题（如NaCly_Fish的题解）。
- **动态规划与矩阵快速幂**：对于大时间 \(t\)（如 \(t \leq 10^9\)），直接递推不可行。通过构造状态（如 \(f_i\) 表示某时刻在基础孔的概率，\(g_i\) 表示在对面孔的概率），利用矩阵快速幂优化递推过程（如hanzhongtlx和君のNOIP。的题解）。

### 可视化设计思路
我们设计一个**8位像素风格的动画**，模拟小球在轨道上的移动和瞬移过程：
- **场景**：用像素网格表示圆形轨道（2n个孔，颜色区分基础孔和对面孔）。
- **操作高亮**：小球移动时用绿色像素箭头标记当前孔，瞬移时用紫色闪烁动画提示。
- **数据展示**：屏幕右侧动态显示瞬移次数、概率值（even_k和odd_k），关键步骤伴随“叮”的音效（如瞬移时）。
- **自动演示**：支持单步/自动播放，自动模式下模拟大时间 \(t\) 时的概率变化，用曲线展示等比数列求和的收敛过程。

---

## 2. 精选优质题解参考

<eval_intro>
通过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解值得重点学习：
</eval_intro>

**题解一：NaCly_Fish（赞：14）**
* **点评**：此题解通过数学推导直抵问题核心。作者敏锐发现“瞬移次数模2同余”是两球同位置的关键，利用二项式定理将复杂的概率求和简化为等比数列形式。推导过程逻辑清晰，公式变形简洁（如将 \([i \bmod 2=0]\) 拆为 \((1+(-1)^i)/2\)），最终将时间复杂度降至 \(O(\log t)\)，是数学优化的典范。

**题解二：君のNOIP。（赞：6）**
* **点评**：此题解分任务讨论，覆盖不同数据范围的解法。特别在大时间 \(t\) 下，通过定义 \(F_{i,0}\)（基础孔概率）和 \(F_{i,1}\)（对面孔概率），构造矩阵快速幂优化递推。提供的完整代码（矩阵乘法、快速幂）规范性强，变量命名清晰（如 `rd()` 函数读取输入），是动态规划与矩阵优化的优秀实践。

**题解三：hanzhongtlx（赞：7）**
* **点评**：此题解深入分析概率DP的状态转移，构造 \(f_i, g_i\) 表示两个相对孔的概率，并通过矩阵乘法维护平方和。虽然矩阵构造较复杂，但详细解释了递推式的来源（如 \(f_i^2\) 的展开），帮助理解如何将状态转移转化为矩阵操作，对学习矩阵优化有重要参考价值。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何处理大时间 \(t\) 下的概率计算，以及如何将复杂的概率求和简化为可高效计算的形式。以下是具体分析：
</difficulty_intro>

1.  **难点1：瞬移次数与位置的关系分析**
    * **分析**：小球的位置由正常移动和瞬移共同决定。正常移动每秒走一个孔，瞬移则跳过 \(n\) 个孔（对面孔）。两球同位置的充要条件是瞬移次数差为偶数（等价于和为偶数）。这一观察是简化问题的关键（如NaCly_Fish的题解）。
    * 💡 **学习笔记**：抓住问题的“不变量”（如瞬移次数的奇偶性），可大幅简化概率计算。

2.  **难点2：概率递推的状态定义**
    * **分析**：直接定义 \(f_{i,j}\)（时间 \(i\) 在孔 \(j\) 的概率）会因 \(j\) 范围大（\(2n\)）导致复杂度高。观察到小球仅可能出现在两个相对的孔（如 \(i \mod 2n +1\) 和其对面孔），可将状态压缩为 \(f_i\)（基础孔概率）和 \(g_i\)（对面孔概率），状态数降为 \(O(1)\)（如君のNOIP。的题解）。
    * 💡 **学习笔记**：利用问题的对称性，压缩状态空间是优化DP的常用技巧。

3.  **难点3：大时间 \(t\) 下的递推优化**
    * **分析**：当 \(t \leq 10^9\)，直接递推 \(O(t)\) 不可行。通过构造转移矩阵（如 \(f_{i+1} = a \cdot f_i + b \cdot g_i\)），利用矩阵快速幂将时间复杂度降至 \(O(\log t)\)（如hanzhongtlx的题解）。
    * 💡 **学习笔记**：矩阵快速幂是处理线性递推问题的“大杀器”，适用于状态转移可表示为矩阵乘法的场景。

### ✨ 解题技巧总结
- **问题转化**：将“两球同位置”转化为“瞬移次数和为偶数”，简化概率计算。
- **状态压缩**：利用对称性，将 \(2n\) 个孔的状态压缩为两个相对孔的概率。
- **数学优化**：通过二项式定理、等比数列求和公式，避免直接计算高次项。
- **矩阵快速幂**：将递推式转化为矩阵乘法，处理大时间 \(t\) 的高效计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，采用矩阵快速幂优化，适用于大时间 \(t\) 的情况。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自君のNOIP。的题解，结合矩阵快速幂优化递推，适用于 \(t \leq 10^9\) 的极限情况。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #define mod 1000000007
    using namespace std;

    typedef long long LL;

    LL n, p, t;
    LL ans[5], base[5][5];

    void mul_ans() {
        LL tmp[5] = {0};
        for (int j = 1; j <= 4; j++)
            for (int k = 1; k <= 4; k++)
                tmp[j] = (tmp[j] + ans[k] * base[k][j]) % mod;
        for (int j = 1; j <= 4; j++) ans[j] = tmp[j];
    }

    void mul_base() {
        LL tmp[5][5] = {0};
        for (int i = 1; i <= 4; i++)
            for (int j = 1; j <= 4; j++)
                for (int k = 1; k <= 4; k++)
                    tmp[i][j] = (tmp[i][j] + base[i][k] * base[k][j]) % mod;
        for (int i = 1; i <= 4; i++)
            for (int j = 1; j <= 4; j++)
                base[i][j] = tmp[i][j];
    }

    LL pow_mod(LL a, LL b) {
        LL res = 1;
        while (b) {
            if (b & 1) res = res * a % mod;
            a = a * a % mod;
            b >>= 1;
        }
        return res;
    }

    LL inv(LL x) {
        return pow_mod(x, mod - 2);
    }

    int main() {
        scanf("%lld%lld%lld", &n, &p, &t);
        LL s = t + 1;
        // 初始化ans数组：S0=0, F0,0²=(1-p)², F0,1²=p², F0,0*F0,1=(1-p)p
        ans[2] = (1 - p + mod) % mod * (1 - p + mod) % mod;
        ans[3] = p * p % mod;
        ans[4] = (1 - p + mod) % mod * p % mod;
        // 初始化转移矩阵base
        base[1][1] = 1;
        base[2][1] = base[3][1] = 1;
        base[2][2] = base[3][3] = (1 - p + mod) % mod * (1 - p + mod) % mod;
        base[3][2] = base[2][3] = p * p % mod;
        base[4][2] = base[4][3] = 2 * (1 - p + mod) % mod * p % mod;
        base[2][4] = base[3][4] = (1 - p + mod) % mod * p % mod;
        base[4][4] = (base[2][2] + base[3][2]) % mod;
        // 矩阵快速幂计算
        while (s) {
            if (s & 1) mul_ans();
            mul_base();
            s >>= 1;
        }
        // 计算最终答案：ans[1]/(2n*(t+1))
        LL denominator = 2 * n % mod * (t + 1) % mod;
        printf("%lld\n", ans[1] * inv(denominator) % mod);
        return 0;
    }
    ```
* **代码解读概要**：
  该代码通过矩阵快速幂维护状态 \(S_i\)（前 \(i\) 项的平方和）、\(F_{i,0}^2\)、\(F_{i,1}^2\) 和 \(F_{i,0} \cdot F_{i,1}\)。初始状态对应时间0的概率，转移矩阵由递推式推导而来。最终通过矩阵快速幂计算大时间 \(t\) 下的结果，并求逆元得到最终概率。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，理解其设计思路：
</code_intro_selected>

**题解一：NaCly_Fish（数学推导）**
* **亮点**：通过二项式定理将复杂求和简化为等比数列，时间复杂度 \(O(\log t)\)。
* **核心公式**：
  $$\text{ans} = \frac{1}{2n(t+1)} \sum_{k=0}^t \frac{1 + (1-2p)^{2k}}{2}$$
* **代码思路**（伪代码）：
  ```cpp
  // 计算等比数列求和部分
  LL a = (1 - 2*p + mod) % mod; // 1-2p
  LL a2 = a * a % mod; // (1-2p)^2
  LL sum = 0;
  if (a2 == 1) { // 公比为1时，和为t+1
      sum = (t + 1) % mod;
  } else {
      // 等比数列求和：sum = (a2^(t+1) - 1) / (a2 - 1)
      LL numerator = (pow_mod(a2, t + 1) - 1 + mod) % mod;
      LL denominator = (a2 - 1 + mod) % mod;
      sum = numerator * inv(denominator) % mod;
  }
  LL total = (t + 1 + sum) % mod;
  LL ans = total * inv(2) % mod * inv(2*n*(t+1) % mod) % mod;
  ```
* **代码解读**：
  该伪代码计算等比数列的和。当公比 \(a^2=1\) 时，和为 \(t+1\)；否则用等比数列求和公式。最终结合 \(1/2\) 和 \(1/(2n(t+1))\) 得到答案。
* 💡 **学习笔记**：二项式定理和等比数列求和是简化概率计算的关键工具，需熟练掌握。

**题解二：君のNOIP。（矩阵快速幂）**
* **亮点**：通过矩阵快速幂优化递推，处理大时间 \(t\) 的高效计算。
* **核心代码片段**：
  ```cpp
  // 矩阵乘法与快速幂函数
  void mul_ans() { ... }
  void mul_base() { ... }
  // 主函数中矩阵初始化与快速幂计算
  ```
* **代码解读**：
  `mul_ans` 和 `mul_base` 分别实现向量与矩阵、矩阵与矩阵的乘法。主函数中初始化状态向量 `ans` 和转移矩阵 `base`，通过快速幂计算 \(t+1\) 次转移后的结果，最终求逆元得到答案。
* 💡 **学习笔记**：矩阵快速幂的关键是正确构造转移矩阵，需确保状态转移的线性关系。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解小球的移动和概率变化，我们设计一个**8位像素风格的动画**，模拟小球在轨道上的行为。
</visualization_intro>

  * **动画演示主题**：「引力机器大冒险——像素小球的瞬移之旅」

  * **核心演示内容**：
    展示小球在轨道上的移动（绿色箭头）和瞬移（紫色闪烁），动态显示每个时间点的瞬移次数、概率值（even_k和odd_k），并自动播放大时间 \(t\) 下概率的收敛过程。

  * **设计思路简述**：
    采用8位像素风格（如FC游戏的简洁色块），通过颜色区分基础孔（蓝色）和对面孔（红色）。关键操作（瞬移）伴随“叮”的音效，目标达成（两球同位置）时播放“胜利”音效，增强操作记忆和趣味性。

  * **动画帧步骤与交互关键点**：

    1. **场景初始化**：
       - 屏幕中央显示圆形轨道（2n个像素孔，编号1到2n），基础孔为蓝色，对面孔为红色。
       - 右侧面板显示“开始/暂停”“单步”“重置”按钮，以及速度滑块（1-10倍速）。
       - 播放8位风格背景音乐（如《超级玛丽》的轻快旋律）。

    2. **初始状态**：
       - 两个小球（黄色像素点）位于1号孔（蓝色），显示初始概率 \(F_{0,0}=1-p\)，\(F_{0,1}=p\)。

    3. **时间步进演示**：
       - **正常移动**（概率 \(1-p\)）：小球沿逆时针移动到下一个孔，绿色箭头标记路径，伴随“滴答”音效。
       - **瞬移**（概率 \(p\)）：小球闪烁紫色后瞬移到对面孔，播放“咻”的音效，显示瞬移次数+1。
       - 右侧实时更新 \(F_{i,0}\)、\(F_{i,1}\) 及其平方和，用柱状图对比变化。

    4. **AI自动演示**：
       - 点击“AI演示”，算法自动运行到时间 \(t\)，用动态曲线展示平方和的累加过程（\(S_i\)），突出等比数列的收敛特性。

    5. **目标达成提示**：
       - 当两球同位置时，轨道中心显示“胜利”文字，播放上扬音效；否则显示“继续努力”。

  * **旁白提示**：
    - “注意看，小球现在有 \(p\) 的概率瞬移到对面孔！”
    - “平方和 \(F_{i,0}^2 + F_{i,1}^2\) 表示两球同时停留的概率哦～”
    - “大时间 \(t\) 下，概率会趋近于一个稳定值，这就是等比数列的魅力！”

<visualization_conclusion>
通过这个动画，我们能直观看到小球的移动规律、概率的动态变化，以及矩阵快速幂如何高效处理大时间 \(t\) 的计算。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思路（概率递推、矩阵快速幂、二项式定理）可迁移到多种场景，以下是相关练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **概率递推**：适用于掷骰子、随机游走等问题（如计算某位置的停留概率）。
    - **矩阵快速幂**：适用于线性递推问题（如斐波那契数列、状态转移）。
    - **二项式定理**：适用于独立事件的概率求和（如n次试验中成功偶数次的概率）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1962 - 斐波那契数列**
        * 🗣️ **推荐理由**：经典矩阵快速幂应用题，帮助掌握矩阵构造与快速幂优化。
    2.  **洛谷 P3390 - 矩阵快速幂**
        * 🗣️ **推荐理由**：矩阵快速幂模板题，巩固矩阵乘法与快速幂的实现。
    3.  **洛谷 P4317 - 埃氏筛法**
        * 🗣️ **推荐理由**：涉及概率计算与筛法结合，锻炼问题转化与数学推导能力。

---

## 7\. 学习心得与经验分享

<insights_intro>
题解作者的经验分享能帮助我们少走弯路：
</insights_intro>

> **参考经验 (来自NaCly_Fish)**：“很抱歉最后一个式子打错了，现已修复。”
>
> **点评**：这提醒我们在数学推导中要仔细检查公式，尤其是符号和指数部分。编写代码后，可用小数据（如样例输入）验证结果，避免低级错误。

> **参考经验 (来自君のNOIP。)**：“原题是 \(n=2\)，而且问题只是求单时间位置的概率。之后我很良心地请求出题人多给了很多部分分。”
>
> **点评**：分任务处理是解决复杂问题的有效策略。从简单子任务入手（如 \(p=0\) 或 \(t\) 较小），逐步推广到一般情况，能降低思考难度。

---

<conclusion>
本次关于“「EZEC-2」机器”的分析就到这里。希望大家通过本指南掌握概率递推、矩阵快速幂和数学优化的核心技巧。记住，多动手推导公式、编写代码并验证，是提升算法能力的关键！下次再见～ 💪
</conclusion>

---
处理用时：193.91秒
# 题目信息

# [NOIP2020] 排水系统

## 题目描述

对于一个城市来说，排水系统是极其重要的一个部分。

有一天，小 C 拿到了某座城市排水系统的设计图。排水系统由 $n$ 个排水结点（它们从 $1 \sim n$ 编号）和若干个单向排水管道构成。每一个排水结点有若干个管道用于汇集其他排水结点的污水（简称为该结点的汇集管道），也有若干个管道向其他的排水结点排出污水（简称为该结点的排出管道）。

排水系统的结点中有 $m$ 个污水接收口，它们的编号分别为 $1, 2, \ldots , m$，污水只能从这些接收口流入排水系统，并且这些结点没有汇集管道。排水系统中还有若干个最终排水口，它们将污水运送到污水处理厂，没有排出管道的结点便可视为一个最终排水口。

现在各个污水接收口分别都接收了 $1$ 吨污水，污水进入每个结点后，会均等地从当前结点的每一个排出管道流向其他排水结点，而最终排水口将把污水排出系统。

现在小 C 想知道，在该城市的排水系统中，每个最终排水口会排出多少污水。该城市的排水系统设计科学，管道不会形成回路，即不会发生污水形成环流的情况。

## 说明/提示

**【样例 #1 解释】**

$1$ 号结点是接收口，$4, 5$ 号结点没有排出管道，因此是最终排水口。  
$1$ 吨污水流入 $1$ 号结点后，均等地流向 $2, 3, 5$ 号结点，三个结点各流入 $\frac{1}{3}$ 吨污水。  
$2$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
$3$ 号结点流入的 $\frac{1}{3}$ 吨污水将均等地流向 $4, 5$ 号结点，两结点各流入 $\frac{1}{6}$ 吨污水。  
最终，$4$ 号结点排出 $\frac{1}{6} + \frac{1}{6} = \frac{1}{3}$ 吨污水，$5$ 号结点排出 $\frac{1}{3} + \frac{1}{6} + \frac{1}{6} = \frac{2}{3}$ 吨污水。

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $1$ |
| $4 \sim 6$ | ${10}^3$ | $1$ |
| $7 \sim 8$ | ${10}^5$ | $1$ |
| $9 \sim 10$ | ${10}^5$ | $10$ |

对于全部的测试点，保证 $1 \le n \le {10}^5$，$1 \le m \le 10$，$0 \le d_i \le 5$。

数据保证，污水在从一个接收口流向一个最终排水口的过程中，不会经过超过 $10$ 个中间排水结点（即接收口和最终排水口不算在内）。

## 样例 #1

### 输入

```
5 1
3 2 3 5
2 4 5
2 5 4
0
0
```

### 输出

```
1 3
2 3
```

## 样例 #2

### 输入

```
见附件中的 water/water2.in```

### 输出

```
见附件中的 water/water2.ans```

## 样例 #3

### 输入

```
见附件中的 water/water3.in```

### 输出

```
见附件中的 water/water3.ans```

# AI分析结果



---
# 💡 Kay的C++算法解析：排水系统 深入学习指南 💡

<introduction>
今天我们来一起分析“排水系统”这道NOIP2020的C++编程题。本指南将帮助大家梳理题目核心逻辑，理解拓扑排序的应用，掌握分数处理技巧，并通过像素动画直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`拓扑排序` (属于图论中的经典算法)

🗣️ **初步分析**：
解决“排水系统”这道题，关键在于利用拓扑排序处理有向无环图（DAG）的污水流动问题。拓扑排序的核心思想是“按依赖顺序处理节点”——就像排队买奶茶，只有前面的人点完单，后面的人才能开始点。在本题中，每个节点的污水必须等待所有上游节点的污水流入后，才能均分到下游节点，这正好符合拓扑排序的处理顺序。

- **题解思路与核心难点**：所有题解均采用拓扑排序，核心思路是：从入度为0的污水接收口（1~m号节点）出发，按拓扑序处理每个节点，将当前节点的污水平均分配给所有下游节点。核心难点在于：
  1. 分数的高精度处理（避免溢出，需通分约分）；
  2. 拓扑序的正确维护（确保处理节点时所有上游污水已流入）；
  3. 最终排水口的识别（出度为0的节点）。
  
- **核心算法流程**：初始化接收口的污水为1/1，用队列维护入度为0的节点。每次取出队首节点，将其污水平均分配给所有下游节点（分母乘以出度），更新下游节点的分数并减少其入度，若入度减为0则入队。最终统计所有出度为0的节点的分数。

- **像素动画设计思路**：采用8位像素风格（类似FC游戏），用不同颜色的像素块表示节点（绿色为接收口，红色为最终排水口，黄色为中间节点）。动画中，队列处理过程用“滑动入队”效果展示；分数流动时，分子分母数字动态更新，并用箭头动画表示污水从当前节点流向下游。关键步骤（如入队、分数更新）伴随“叮”的像素音效，完成最终排水口计算时播放胜利音效。


## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法有效性等维度评估，以下3道题解因逻辑清晰、代码规范且提供关键技巧被选为优质参考（均≥4星）。
</eval_intro>

**题解一：听取MLE声一片的题解（来源：洛谷用户）**
* **点评**：此题解清晰解释了拓扑排序的核心步骤，并详细说明了分数处理的通分约分方法。代码中使用`vector`存边、队列维护拓扑序，变量`xx[i]/yy[i]`表示节点i的分子/分母，命名直观。亮点在于分数加法函数`add`的实现（先通分后约分），以及拓扑排序中对入度为0节点的初始化处理。虽然未处理高精度（需自行添加），但提供了完整的基础框架，适合作为入门参考。

**题解二：hensier的题解（来源：洛谷用户）**
* **点评**：此题解使用链式前向星存边，结合`__int128`处理大数，避免了溢出问题。代码中`update`函数实现分数加法（计算最小公倍数通分），`dfs`实现拓扑排序（递归处理节点），逻辑简洁。亮点在于对`__int128`的灵活运用（快读快写函数），以及边界条件的处理（如初始分母为1）。适合需要处理高精度的进阶学习者。

**题解三：lndjy的题解（来源：洛谷用户）**
* **点评**：此题解定义了`fenshu`分数类，封装了加法、约分等操作，代码模块化程度高。拓扑排序部分用队列维护处理顺序，逻辑清晰。亮点在于分数类的设计（`yuefen`函数化简分数），以及对`__int128`的输出优化（递归实现`write`函数）。适合希望通过类封装提升代码可读性的学习者。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决本题时，以下三个关键点需要特别注意：
</difficulty_intro>

1.  **关键点1：拓扑排序的正确顺序**  
    * **分析**：拓扑排序的核心是确保处理节点时，所有上游节点已处理完毕。本题中，入度为0的节点（接收口）需优先入队，处理时减少下游节点的入度，当入度减为0时入队。这一步需严格维护入度数组，避免遗漏或重复处理。  
    * 💡 **学习笔记**：拓扑排序的关键是“入度管理”，入度为0的节点是处理起点，每处理一个节点需更新其所有邻居的入度。

2.  **关键点2：分数的高精度处理**  
    * **分析**：由于污水流动过程中分母可能指数级增长（如每个节点出度为5，最多流经10层，分母可达\(5^{10}\)），需用高精度或`__int128`存储。分数相加时需先通分（计算最小公倍数），再约分（除以最大公约数），避免溢出。  
    * 💡 **学习笔记**：分数运算的核心是“通分+约分”，大数处理可借助`__int128`（需自定义输入输出）。

3.  **关键点3：最终排水口的识别**  
    * **分析**：最终排水口是出度为0的节点，需在输入时记录这些节点（如用数组`out[i]`标记出度）。处理完所有节点后，遍历所有节点输出`out[i]==0`的分数。  
    * 💡 **学习笔记**：出度为0的节点是结果输出的目标，需在初始化时标记。

### ✨ 解题技巧总结
- **技巧1：问题抽象**：将污水流动问题抽象为DAG上的拓扑排序问题，利用拓扑序保证处理顺序。  
- **技巧2：分数封装**：用结构体或类封装分数的分子、分母，实现加法、除法等操作，提升代码可读性。  
- **技巧3：大数处理**：使用`__int128`或高精度库处理大数运算，避免溢出（竞赛中`__int128`更简洁）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的核心实现，结合了拓扑排序和分数处理的关键逻辑，适合快速理解整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了听取MLE声一片和hensier的题解思路，使用`__int128`处理大数，拓扑排序维护处理顺序，适合作为标准实现参考。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef __int128 ll;

    void write(ll x) {
        if (x < 0) putchar('-'), x = -x;
        if (x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }

    ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }

    struct Frac {
        ll x, y;
        Frac(ll x = 0, ll y = 1) : x(x), y(y) { ll g = gcd(x, y); x /= g; y /= g; }
        Frac operator+(const Frac& o) const {
            ll g = gcd(y, o.y);
            ll lcm = y / g * o.y;
            return Frac(x * (lcm / y) + o.x * (lcm / o.y), lcm);
        }
        Frac operator/(int d) const { return Frac(x, y * d); }
    };

    int main() {
        int n, m;
        scanf("%d%d", &n, &m);
        vector<vector<int>> g(n + 1);
        vector<int> in(n + 1), out(n + 1);
        vector<Frac> f(n + 1);

        for (int i = 1; i <= n; ++i) {
            int d; scanf("%d", &d);
            out[i] = d;
            while (d--) {
                int v; scanf("%d", &v);
                g[i].push_back(v);
                in[v]++;
            }
        }

        queue<int> q;
        for (int i = 1; i <= n; ++i) {
            if (in[i] == 0) {
                q.push(i);
                f[i] = Frac(1, 1);
            }
        }

        while (!q.empty()) {
            int u = q.front(); q.pop();
            Frac unit = f[u] / out[u];
            for (int v : g[u]) {
                f[v] = f[v] + unit;
                if (--in[v] == 0) q.push(v);
            }
        }

        for (int i = 1; i <= n; ++i) {
            if (out[i] == 0) {
                Frac res = f[i];
                write(res.x); putchar(' '); write(res.y); putchar('\n');
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入并建图，用`vector`存储邻接表。通过队列维护拓扑序，初始将入度为0的接收口节点入队，初始分数为1/1。每次处理队首节点时，将其污水平均分配给下游节点（用`Frac`类实现分数除法和加法），更新下游节点的分数和入度。最终遍历所有出度为0的节点，输出其分数。

<code_intro_selected>
接下来，分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：听取MLE声一片的分数加法函数**
* **亮点**：通分后约分，处理分数加法，逻辑简洁。
* **核心代码片段**：
    ```cpp
    void add(int u, ll x, ll y) {
        if (y == 0) return;
        if (yy[u] == 0) { xx[u] = x; yy[u] = y; return; }
        ll p1 = xx[u] * y + yy[u] * x;
        ll p2 = yy[u] * y;
        ll p3 = gcd(p1, p2);
        xx[u] = p1 / p3; yy[u] = p2 / p3;
    }
    ```
* **代码解读**：  
  函数`add`将节点`u`的分数（`xx[u]/yy[u]`）与新分数（`x/y`）相加。若`u`当前无分数（`yy[u]==0`），直接赋值；否则计算通分后的分子（`p1`）和分母（`p2`），再用`gcd`约分。此函数确保分数始终为最简形式。  
* 💡 **学习笔记**：分数加法需先通分（分母为两分母的最小公倍数），再相加，最后约分。

**题解二：hensier的拓扑排序DFS实现**
* **亮点**：递归处理拓扑序，代码简洁。
* **核心代码片段**：
    ```cpp
    void dfs(int u) {
        for (int i = head[u], v; i; i = e[i].nxt) {
            v = e[i].to;
            update(wx[v], wy[v], wx[u], oud[u] * wy[u]);
            ind[v]--;
            if (!ind[v]) dfs(v);
        }
    }
    ```
* **代码解读**：  
  `dfs`函数递归处理节点`u`的所有下游节点。通过`update`函数将`u`的分数均分到`v`，减少`v`的入度，若入度为0则递归处理`v`。此方式隐式维护了拓扑序，适合理解递归与拓扑排序的关系。  
* 💡 **学习笔记**：拓扑排序可用BFS（队列）或DFS（递归）实现，BFS更直观，DFS适合隐式处理。

**题解三：lndjy的分数类设计**
* **亮点**：封装分数操作，提升代码可读性。
* **核心代码片段**：
    ```cpp
    struct fenshu {
        __int128 x, y;
        fenshu(int a = 0, int b = 1) { x = a; y = b; yuefen(); }
        int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
        void yuefen() { int k = gcd(x, y); x /= k; y /= k; }
        void add(fenshu k) { ... }
    };
    ```
* **代码解读**：  
  `fenshu`类封装了分数的分子（`x`）、分母（`y`），以及约分（`yuefen`）和加法（`add`）操作。构造函数初始化时自动约分，确保分数始终为最简形式。此设计使主逻辑更清晰，适合模块化编程。  
* 💡 **学习笔记**：用类封装复杂操作可提升代码可读性和维护性。  


## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解拓扑排序和分数流动的过程，我们设计一个“像素排水探险”动画，用8位像素风格展示节点处理顺序和分数变化。
</visualization_intro>

  * **动画演示主题**：`像素排水探险——污水流动大作战`  
  * **核心演示内容**：展示拓扑排序的队列处理过程，每个节点的分数如何均分到下游，最终排水口的分数计算。

  * **设计思路简述**：采用FC红白机风格（8色调色板），节点用像素方块表示（绿色=接收口，红色=最终排水口，黄色=中间节点）。动画中，队列用“管道”展示，节点入队时从屏幕左侧滑入；分数流动时用箭头动画（从当前节点指向下游节点），分子分母数字动态更新。关键操作（如入队、分数更新）伴随“叮”的音效，完成所有处理后播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧显示“控制面板”（开始/暂停、单步、重置按钮，速度滑块）。  
        - 中间区域用网格展示节点（1~n号），绿色标记接收口（1~m），红色标记最终排水口（出度为0）。  
        - 右侧显示队列（管道状）和当前处理节点的分数（分子/分母）。

    2.  **算法启动**：  
        - 初始时，接收口节点（绿色）入队，队列管道中出现绿色方块，伴随“入队”音效（短“叮”）。  
        - 接收口分数初始化为1/1，数字在节点上方显示。

    3.  **核心处理步骤**：  
        - **单步执行**：点击“单步”按钮，取出队首节点（绿色方块滑出队列），计算其出度，生成对应数量的箭头（如出度为3，生成3个箭头指向下游节点）。  
        - **分数流动**：当前节点的分数（如1/1）除以出度（3），变为1/3，箭头携带分数动画（数字1/3）流向每个下游节点。  
        - **下游节点更新**：下游节点分数加上1/3（如原为0/1，变为1/3），数字更新，入度减1（显示在节点旁）。若入度减为0，节点变为黄色，滑入队列，伴随“入队”音效。

    4.  **目标达成**：  
        - 所有节点处理完毕后，最终排水口（红色）的分数高亮显示（如4号节点显示1/3，5号节点显示2/3），播放上扬的“胜利”音效（长“叮”）。  
        - 点击“重置”按钮，动画回到初始状态，可重新播放。

    5.  **交互控制**：  
        - 速度滑块（1x~5x）调整动画速度，“自动播放”模式自动按设定速度执行。  
        - 代码同步：屏幕下方显示当前步骤对应的C++代码片段（如`Frac unit = f[u] / out[u];`），高亮当前执行行。

  * **旁白提示**：  
    - “当前处理1号接收口，它的出度是3，所以污水分成3份，每份1/3！”  
    - “看，2号节点的入度从1减到0了，它现在可以入队处理啦！”  
    - “最终排水口5号节点的分数是1/3（来自1号）+1/6（来自2号）+1/6（来自3号）=2/3，计算正确！”

<visualization_conclusion>
通过这个动画，我们可以直观看到拓扑排序如何按顺序处理节点，分数如何在流动中累加，以及最终排水口的分数是如何计算的。像素风格和游戏化元素让算法学习更有趣！
</visualization_conclusion>


## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
拓扑排序是图论中的基础算法，除了本题，还适用于任务调度、依赖解析等场景。以下是相关拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    拓扑排序的核心是“处理依赖关系”，适用于所有DAG问题。例如：  
    - 任务调度（如编译多个文件，需按依赖顺序编译）；  
    - 课程安排（如选课需先修某些课程）；  
    - 事件传播（如社交网络中的信息扩散）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1038 神经网络**  
        * 🗣️ **推荐理由**：与本题类似，涉及DAG上的信号传播，需按拓扑序处理节点，巩固拓扑排序的应用。  
    2.  **洛谷 P1137 旅行计划**  
        * 🗣️ **推荐理由**：求每个节点的最长路径，需拓扑排序后动态规划，拓展拓扑序的进阶应用。  
    3.  **洛谷 P1983 车站分级**  
        * 🗣️ **推荐理由**：涉及分层图和拓扑排序，需抽象问题为DAG，提升问题建模能力。  


## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自用户“听取MLE声一片”)**：“在处理分数加法时，一开始没考虑分母为0的情况，导致数组越界。后来在`add`函数中添加了`if (y == 0) return;`的判断，问题解决。”  
> **点评**：边界条件的处理是编程的关键。本题中，初始时非接收口节点的分母为1（非0），但在计算中可能因出度为0导致分母异常，需通过条件判断避免错误。这提醒我们在编写代码时，要充分考虑所有可能的边界情况（如分母为0、入度为负等），并添加防御性检查。


<conclusion>
本次关于“排水系统”的解题分析就到这里。通过拓扑排序处理DAG问题，结合分数的高精度运算，我们掌握了此类问题的核心解法。希望大家通过练习和动画演示，深入理解算法逻辑，提升编程能力！下次见~ 💪
</conclusion>

---
处理用时：173.07秒
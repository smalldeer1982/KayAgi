# 题目信息

# [CSP-J2020] 直播获奖

## 题目描述

NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\%$，即当前排名前 $w\%$ 的选手的最低成绩就是即时的分数线。

更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\max(1, \lfloor p \times w \%\rfloor)$，其中 $w$ 是获奖百分比，$\lfloor x \rfloor$ 表示对 $x$ 向下取整，$\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。

作为评测组的技术人员，请你帮 CCF 写一个直播程序。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)

---
### 数据规模与约定

各测试点的 $n$ 如下表：

| 测试点编号 | $n=$ |
| :--: | :--: |
| $1 \sim 3$ | $10$ |
| $4 \sim 6$ | $500$ |
| $7 \sim 10$ | $2000$ |
| $11 \sim 17$ | $10^4$ |
| $18 \sim 20$ | $10^5$ |


对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \le w \le 99$。

---
### 提示

在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\%$，则计算 $5 \times 60\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。

## 样例 #1

### 输入

```
10 60
200 300 400 500 600 600 0 300 200 100
```

### 输出

```
200 300 400 400 400 500 400 400 300 300```

## 样例 #2

### 输入

```
10 30
100 100 600 100 100 100 100 100 100 100```

### 输出

```
100 100 600 600 600 600 100 100 100 100```

# AI分析结果


# 💡 Kay的C++算法解析：直播获奖 深入学习指南 💡

**<introduction>**
大家好，我是Kay！今天我们一起分析CSP-J2020的真题《直播获奖》。这道题要求实时计算获奖分数线，需要动态维护成绩序列并快速查询排名。本指南将带大家深入理解桶排序和对顶堆两种核心解法，并通过像素动画直观展示算法流程。准备好了吗？我们开始吧！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`桶排序` 与 `对顶堆`（编程技巧应用）  

🗣️ **初步分析**：
> 这道题就像在直播中实时更新获奖分数线，我们需要快速找出当前排名前w%的成绩。核心难点在于动态维护成绩序列并高效查询第k大的值。  

**桶排序解法**就像准备600个桶（0-600分），每来一个成绩就放进对应桶里。查询时从高分向低分遍历，累加人数直到达标。时间复杂度O(600n)，完美契合值域小的特点。

**对顶堆解法**则像用两个篮子管理成绩：小顶堆放前k名（篮顶是最低分），大顶堆放其余成绩。新成绩到来时动态调整两个篮子，保持小顶堆大小正好是获奖人数。

### 可视化设计思路
- **桶排序动画**：用像素网格展示600个桶，新成绩放入时对应桶高度+1。查询时从右向左移动探针，累加人数并高亮当前桶，达标时播放胜利音效。
- **对顶堆动画**：用像素方块堆叠表示两个堆，新成绩加入时动态调整方块位置，高亮堆顶元素交换过程，配以"叮"的音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性和算法效率等维度评估题解，精选出3份≥4星的优质参考：
</eval_intro>

**题解一：AzusagawaKaede（对顶堆解法）**
* **点评**：此解法思路清晰，用优先队列巧妙实现两个堆的动态维护。代码中`mi_hp`（小顶堆）和`ma_hp`（大顶堆）命名直观，边界处理严谨（`ma_hp.push(0)`避免空堆）。亮点在于其通用性——即使成绩值域扩大也能高效运行。学习价值在于展示了如何用标准库快速实现高级数据结构。

**题解二：Eason_AC（桶排序解法）**
* **点评**：最简洁高效的解法，充分利用了值域小的特性。代码中`a[601]`作桶数组，从600分向0分遍历的逻辑直击问题核心。亮点是时间复杂度O(600n)，在本题数据范围下优于对数级算法。变量`pl`（计划人数）和`num`（累计人数）的命名体现了良好的编码习惯。

**题解三：niuniudundun（桶排序解法）**
* **点评**：详解桶排序原理，代码结构工整。特别值得学习的是`sum>=max(1,i*w/100)`的边界处理，以及循环内`break`的优化意识。虽然与题解二核心逻辑一致，但其分步骤讲解对初学者更友好。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点，结合优质题解的策略如下：
</difficulty_intro>

1.  **动态维护实时排名**
    * **分析**：每次新增成绩都需重新计算排名。桶排序直接更新桶数组，对顶堆通过比较新成绩与堆顶决定插入位置。关键变量是桶数组或堆结构。
    * 💡 **学习笔记**：根据数据特性选择数据结构——值域小用桶，值域大用堆。

2.  **高效查询第k大值**
    * **分析**：桶排序从高分到低分遍历桶，累加人数直至≥k；对顶堆直接返回小顶堆顶。核心技巧是倒序遍历和堆顶维护。
    * 💡 **学习笔记**：避免全排序，利用部分信息加速查询。

3.  **处理分数并列情况**
    * **分析**：题目要求所有并列者都获奖。桶排序天然支持（同分者在同桶），对顶堆需确保小顶堆大小≥k（可能包含并列者）。
    * 💡 **学习笔记**：理解题意细节决定边界处理逻辑。

### ✨ 解题技巧总结
<summary_best_practices>
通过本题可总结以下通用技巧：
</summary_best_practices>
- **技巧A：值域分析优先**：当数据范围较小时（如本题600），桶排序往往是最优解。
- **技巧B：避免浮点运算**：用`i*w/100`代替浮点运算保证精度（多位作者强调）。
- **技巧C：边界条件测试**：特别注意w=1或100、成绩全同等情况。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先展示综合优质题解提炼的桶排序实现，这是本题最简洁高效的解法：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合自Eason_AC和niuniudundun的桶排序解法，去冗余保持核心逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
using namespace std;

int main() {
    int n, w, x;
    cin >> n >> w;
    int bucket[601] = {0}; // 0-600分的桶
    
    for (int i = 1; i <= n; ++i) {
        cin >> x;
        bucket[x]++; // 成绩放入对应桶
        
        int k = max(1, i * w / 100); // 计算计划获奖人数
        int sum = 0;
        for (int j = 600; j >= 0; --j) {
            sum += bucket[j];   // 累加高分人数
            if (sum >= k) {
                cout << j << " "; // 输出分数线
                break;
            }
        }
    }
    return 0;
}
```
* **代码解读概要**：
    > 1. 初始化600分的桶数组  
    > 2. 逐个读入成绩，更新对应桶计数  
    > 3. 计算当前获奖人数k（用整数避免浮点误差）  
    > 4. 从600分向0分遍历桶，累加人数直至≥k  
    > 5. 输出当前分数作为分数线

---
<code_intro_selected>
接下来剖析精选题解的核心代码片段：
</code_intro_selected>

**题解一：AzusagawaKaede（对顶堆）**
* **亮点**：用优先队列实现动态维护前k名
* **核心代码片段**：
```cpp
priority_queue<int> ma_hp; // 大顶堆（成绩较低者）
priority_queue<int, vector<int>, greater<int>> mi_hp; // 小顶堆（前k名）

void push(int num) {
    if (num >= ma_hp.top()) 
        mi_hp.push(num);
    else 
        ma_hp.push(num);
    adjust(); // 调整堆大小
}

// 查询时直接返回：
cout << mi_hp.top() << " ";
```
* **代码解读**：
    > 关键点在于双堆分工：  
    > - `mi_hp`存当前前k名，堆顶是分数线  
    > - 新成绩根据与`ma_hp.top()`比较决定去向  
    > `adjust()`确保`mi_hp`大小正好为k（需移动堆顶元素）  
    > 查询时直接取`mi_hp.top()`效率O(1)
* 💡 **学习笔记**：对顶堆是动态求第k大的通用方法

**题解二：Eason_AC（桶排序）**
* **亮点**：极简遍历与边界处理
* **核心代码片段**：
```cpp
for(int j = 600; j >= 0; --j) {
    cnt -= a[j];        // 反向递减计数
    if (cnt <= 0) {
        cout << j << ' ';
        break;
    }
}
```
* **代码解读**：
    > 巧妙的反向计数技巧：  
    > 1. 初始化`cnt = k`（所需人数）  
    > 2. 从高分向低分遍历，每次`cnt -= 当前分人数`  
    > 3. 当`cnt<=0`时，说明当前分已覆盖所有获奖者  
    > 比累加计数少一个变量，更简洁
* 💡 **学习笔记**：反向计数法可节省临时变量

---

## 5. 算法可视化：像素动画演示（桶排序版）

<visualization_intro>
为直观理解桶排序的执行过程，我设计了这款复古像素风动画。想象你在经营一个"分数游乐园"，每个桶是收集特定分数小精灵的玻璃罐！

### 设计思路
- **8-bit像素风格**：采用FC红白机色调（16色）
- **数据结构具象化**：分数桶=玻璃罐，成绩=小精灵
- **游戏化激励**：每找到分数线解锁新关卡

### 动画帧步骤
1. **初始化场景**  
   ![初始化](https://example.com/bucket_init.png)  
   - 屏幕右侧：600个像素桶（10x60网格），桶高=当前人数
   - 左侧控制台：开始/暂停/单步按钮 + 速度滑块
   - 背景：8-bit芯片音乐循环播放

2. **成绩投放动画**  
   ```伪代码
   when new_score:
     播放"投币"音效
     对应桶高度+1（像素块向上生长动画）
     桶顶显示当前人数
   ```

3. **分数线查询过程**  
   ![查询过程](https://example.com/probe_anim.gif)  
   - 探针从600分桶向右移动，播放"滴答"音效
   - 经过每个桶时：  
     ```js
     total += bucket[j];
     if(total >= k) {
        探针闪烁红光
        播放"通关"音效(↑↑↓↓BA)
        显示分数线j
     }
     ```

4. **关卡进度系统**  
   - 每处理10个成绩解锁新背景
   - 连续正确计算获得连击奖励

### 交互控制
- **单步执行**：按帧分析计数过程
- **AI演示**：自动播放（速度可调）
- **错误反馈**：未达标时播放"失败"音效

<visualization_conclusion>
这款动画将抽象计数转化为具象的收集过程，高分桶的"精灵罐"填满效果能直观展示人数累加机制！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
桶排序和对顶堆技巧可扩展至多类问题：
</similar_problems_intro>

1. **P1168 中位数**  
   🗣️ *推荐理由*：动态维护中位数，完美应用对顶堆技巧，小顶堆存较大半数，大顶堆存较小半数

2. **P1908 逆序对**  
   🗣️ *推荐理由*：桶排序思想进阶，需结合树状数组实现高效计数

3. **P3368 区间加法与单点查询**  
   🗣️ *推荐理由*：拓展桶排序思想，实现差分数组维护动态区间

---

## 7. 学习心得与经验分享

<insights_intro>
题解作者们的调试经验尤其珍贵：
</insights_intro>

> **参考经验（来自AzusagawaKaede）**：  
> *"最初在堆调整边界卡了很久，通过打印双堆大小才发现漏了初始压入"*  
>   
> **点评**：这提醒我们：  
> 1. 初始化边界检查至关重要（如空堆处理）  
> 2. 调试时输出数据结构关键状态（如堆大小）  
> 3. 对顶堆的调整函数需覆盖所有边界情况  

---

<conclusion>
本次《直播获奖》解析就到这里。记住：桶排序是值域小时的神器，对顶堆则具通用性。多动手实现动画中的流程，能深化对计数过程的理解。下次挑战见！🚀
</conclusion>
```

---
处理用时：151.21秒
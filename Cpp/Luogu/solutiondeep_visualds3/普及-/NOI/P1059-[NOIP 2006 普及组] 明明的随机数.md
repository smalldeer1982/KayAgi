# 题目信息

# [NOIP 2006 普及组] 明明的随机数

## 题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。


## 说明/提示

NOIP 2006 普及组 第一题


## 样例 #1

### 输入

```
10
20 40 32 67 40 20 89 300 400 15
```

### 输出

```
8
15 20 32 40 67 89 300 400
```

# AI分析结果

# 💡 Kay的C++算法解析：明明的随机数 深入学习指南 💡

<introduction>
  今天我们来一起分析NOIP2006普及组的经典题目——「明明的随机数」。这道题看似简单，却藏着排序与去重的核心技巧，是入门算法的「练手好题」。本指南会帮你梳理思路、掌握关键算法，并通过有趣的像素动画直观理解过程，让我们开始吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`排序` + `编程技巧应用`（去重与排序的结合）

🗣️ **初步分析**：
> 明明的问题其实是要解决两个任务：**去掉重复数字** + **按从小到大排序**。关键在于找到「同时完成这两个任务」的高效方法。我们可以用三种核心思路解决：
> - **桶排序法**：像给每个数字分配一个「小抽屉」，出现过的数字就把抽屉标记为「已使用」。最后按抽屉顺序（1到1000）检查，就能直接得到不重复且排序好的结果——这就像学校按学号排座位，每个学号只坐一个人！
> - **排序+去重法**：先把所有数字按顺序「排好队」（用`sort`），再把重复的「挤到队尾」（用`unique`或手动判断）。比如排队时，后面的人如果和前面一样，就站到队尾，只留第一个。
> - **STL-set法**：用C++的`set`容器，它像一个「智能抽屉」——放进去的数字会自动排好序，还不会重复！

  - **核心难点**：如何高效结合「去重」与「排序」？比如手动去重时容易漏判重复（比如三个连续的40），或者桶排序时浪费空间（但本题数据范围小，完全没问题）。
  - **可视化设计思路**：我们会做一个「像素抽屉游戏」——用8位像素块代表1-1000的抽屉，输入数字时抽屉变亮，统计亮抽屉的数量，最后按顺序点亮输出。关键步骤（如输入、标记、输出）会用颜色高亮，配合「叮」「滴」的像素音效，让你「看得到算法在跑」！


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、技巧启发性三个角度，筛选了4份超棒的题解——它们覆盖了三种核心思路，适合不同阶段的学习者！
</eval_intro>

**题解一：桶排序法（作者：qr小盆友，赞175）**
* **点评**：这份题解把桶排序讲得像「玩抽屉游戏」，思路特别直观！用`bool book[1001]`标记数字是否出现过（book就是「标记本」的意思），输入时如果是第一次出现，就把`final`（最终数量）加1。最后按1到1000遍历，输出所有被标记的数字。代码超级简洁，变量名也很易懂（比如`book`对应标记，`final`对应结果数量），完美适合初学者入门！

**题解二：sort+手动去重（作者：2023z，赞74）**
* **点评**：这题解的亮点是「踩坑指南」——作者特意指出错误写法（比如把重复数字赋值为0会漏判），并给出正确方法：先`sort`排序，再用`a[i] == a[i-1]`统计重复次数。这种「对比错误与正确」的讲解方式，能帮你深刻记住边界条件！代码结构清晰，从输入到排序再到统计，每一步都很明确。

**题解三：STL-unique法（作者：Erina，赞41）**
* **点评**：这题解教会你用`algorithm`库的`unique`函数「偷懒」！`unique`能把排序后的重复元素「移到队尾」，返回去重后的尾地址。作者用例子解释`unique`的用法（比如`1,1,1,2`变成`1,2,1,1`），还提醒要先排序——这是`unique`的关键！代码很短，但技巧性强，适合想学习STL的同学。

**题解四：STL-set法（作者：mcturtle，赞19）**
* **点评**：这题解把`set`的特性用到了极致！`set`会自动排序+去重，输入时直接`insert`，最后输出`size`和所有元素。代码只有10行左右，简直是「极简美学」！适合想了解STL容器的同学，但要注意`set`的迭代器用法（用`auto it`遍历）。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到三个「卡壳点」。结合优质题解的经验，我帮你提炼了「通关技巧」：
</difficulty_intro>

1.  **难点1：如何同时完成「去重」和「排序」？**
    * **分析**：桶排序是「天然解决」——抽屉顺序就是排序后的顺序，标记抽屉就是去重。如果用`sort`，要先排序再去重（因为排序后重复元素会挨在一起）。`set`更直接，容器本身帮你做好了这两点！
    * 💡 **学习笔记**：先想「数据范围」——本题数字≤1000，桶排序最快；如果数字很大（比如1e9），就用`sort+unique`或`set`。

2.  **难点2：如何正确统计去重后的数量？**
    * **分析**：桶排序用「标记数组的计数」（比如`final`变量）；`sort+unique`用`unique`的返回值（`it = unique(mem.begin(), mem.end())`，`mem.size()`就是去重后的数量）；`set`直接用`size()`方法。
    * 💡 **学习笔记**：避免「手动数重复次数」时的错误（比如三个40会漏减一次），用库函数或容器的特性更可靠！

3.  **难点3：如何选择最合适的方法？**
    * **分析**：看两个因素——**数据范围**和**代码复杂度**：
      - 数据小（比如≤1e3）：选桶排序（代码简单，速度快）；
      - 数据大（比如≤1e5）：选`sort+unique`（O(n log n)时间，空间小）；
      - 想偷懒：选`set`（代码最短，但速度略慢）。
    * 💡 **学习笔记**：没有「最好的方法」，只有「最适合当前问题的方法」！


### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我总结了三个「通用技巧」，帮你解决类似问题：
</summary_best_practices>
-   **技巧A：利用数据范围选方法**：数字范围小→桶排序，范围大→排序+去重；
-   **技巧B：用库函数简化代码**：`sort`（排序）、`unique`（去重）、`set`（自动排序去重）都是「工具人」，要学会用！
-   **技巧C：边界条件要注意**：比如手动去重时，要判断`a[i] != a[i-1]`（而不是`a[i] == a[i+1]`），避免漏判最后一个元素！


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看三个核心思路的「通用实现」，帮你把握整体框架！
</code_intro_overall>

### 本题通用核心C++实现参考（三种思路）

#### 1. 桶排序法（最直观）
* **说明**：来自qr小盆友的题解，用bool数组标记，适合初学者。
* **完整核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int main(){
      bool book[1001] = {false}; // 标记数字是否出现过
      int n, final = 0;
      cin >> n;
      for(int i=0; i<n; i++){
          int x;
          cin >> x;
          if(!book[x]) final++; // 第一次出现，数量加1
          book[x] = true; // 标记为已出现
      }
      cout << final << endl;
      for(int i=1; i<=1000; i++){
          if(book[i]) cout << i << " ";
      }
      return 0;
  }
  ```
* **代码解读概要**：先初始化一个「标记本」`book`，输入每个数字时，标记并统计第一次出现的数量。最后按顺序输出所有被标记的数字——就像检查每个抽屉有没有人！

#### 2. sort+unique法（最常用）
* **说明**：来自Erina的题解，用STL函数简化代码。
* **完整核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int main(){
      int n;
      cin >> n;
      vector<int> mem(n);
      for(int i=0; i<n; i++) cin >> mem[i];
      sort(mem.begin(), mem.end()); // 先排序
      auto it = unique(mem.begin(), mem.end()); // 去重，返回尾地址
      mem.resize(distance(mem.begin(), it)); // 调整数组大小
      cout << mem.size() << endl;
      for(int x : mem) cout << x << " ";
      return 0;
  }
  ```
* **代码解读概要**：用`vector`存数据，`sort`排序后，`unique`把重复元素移到队尾，再用`resize`截断——就像把排队的重复同学赶出去！

#### 3. set法（最简洁）
* **说明**：来自mcturtle的题解，用STL容器自动处理。
* **完整核心代码**：
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  int main(){
      int n;
      cin >> n;
      set<int> s;
      while(n--){
          int x;
          cin >> x;
          s.insert(x); // 自动排序+去重
      }
      cout << s.size() << endl;
      for(auto x : s) cout << x << " ";
      return 0;
  }
  ```
* **代码解读概要**：`set`就像一个「智能收纳盒」，放进去的数字会自动排好序且不重复。最后直接输出大小和元素——简直是「躺赢」！


---

<code_intro_selected>
接下来看优质题解的「精华片段」，点出关键技巧！
</code_intro_selected>

**题解一：桶排序法（作者：qr小盆友）**
* **亮点**：用`bool`数组标记，空间利用率高（1001个bool只占1KB左右）。
* **核心代码片段**：
  ```cpp
  bool book[1001] = {false};
  int final = 0;
  for(int i=0; i<n; i++){
      int x;
      cin >> x;
      if(!book[x]) final++; // 第一次出现才计数
      book[x] = true;
  }
  ```
* **代码解读**：`book[x]`是「x号抽屉有没有人」，`!book[x]`就是「第一次有人坐这个抽屉」，此时`final`加1。这一步既完成了去重，又统计了数量——是不是很聪明？
* 💡 **学习笔记**：`bool`数组是「标记存在性」的神器，当只需要知道「有没有」而不是「有多少」时，用它最省空间！

**题解二：sort+手动去重（作者：2023z）**
* **亮点**：手动去重的正确姿势，避免漏判。
* **核心代码片段**：
  ```cpp
  sort(a+1, a+n+1); // 排序
  int cnt = n;
  for(int i=1; i<=n; i++){
      if(a[i] == a[i-1]) cnt--; // 重复就减数量
  }
  cout << cnt << endl;
  for(int i=1; i<=n; i++){
      if(a[i] != a[i-1]) cout << a[i] << " ";
  }
  ```
* **代码解读**：先排序，再遍历。如果当前元素和前一个一样，说明重复，`cnt`减1；输出时只输出和前一个不同的元素——这样就不会漏判三个连续的40啦！
* 💡 **学习笔记**：手动去重的关键是「排序后比较相邻元素」，一定要从第二个元素开始比（`i=1`，和`i-1=0`比）！

**题解三：STL-unique法（作者：Erina）**
* **亮点**：用`unique`函数快速去重，代码简洁。
* **核心代码片段**：
  ```cpp
  sort(mem.begin(), mem.end());
  auto it = unique(mem.begin(), mem.end());
  mem.resize(distance(mem.begin(), it));
  ```
* **代码解读**：`unique`会把重复元素移到`vector`的末尾，返回「最后一个不重复元素的下一个位置」。`distance`计算这个位置到开头的距离，`resize`把`vector`截断到这个长度——相当于把重复元素「删掉」！
* 💡 **学习笔记**：`unique`的前提是「数组已排序」，否则无法正确去重！


---

## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了让你「亲眼看到」桶排序的过程，我设计了一个**8位像素风格的「抽屉游戏」**——像玩FC红白机一样学算法！
\</visualization\_intro\>

  * **动画演示主题**：明明的「抽屉整理游戏」（复古像素风，类似《超级马里奥》的UI）
  * **核心演示内容**：展示桶排序的「输入→标记→输出」全过程，包括：
    - 输入数字时，对应抽屉变亮；
    - 统计亮抽屉的数量；
    - 按顺序输出亮抽屉的数字。

  * **设计思路简述**：用8位像素块代表1-1000的抽屉（排成10行100列的网格），颜色用复古的「灰→蓝」渐变表示是否被标记。加入像素音效（比如输入时「叮」，统计时「滴」，输出时「啦啦啦」），让你「听得到算法的节奏」！

  * **动画帧步骤与交互关键点**：
    1.  **初始化场景**：屏幕左侧是「抽屉网格」（灰像素块），右侧是「控制面板」（开始/暂停、单步、重置按钮，速度滑块）。背景是复古的教室墙纸，播放8位风格的轻松BGM（比如《冒险岛》的背景音乐）。
    2.  **输入与标记**：
        - 点击「单步」：输入一个数字（比如20），对应的抽屉（第20号）从灰色变成蓝色，伴随「叮」的音效。如果是第一次输入20，右上角的「final」数字+1（比如从0变1）。
        - 点击「自动播放」：快速输入所有数字，抽屉依次变蓝，「final」数字逐渐增加。
    3.  **统计数量**：输入完成后，屏幕中间弹出「final」的数量（比如样例中的8），伴随「滴」的音效。
    4.  **输出结果**：按1到1000的顺序，蓝色抽屉依次闪烁（从浅蓝到深蓝），并在屏幕下方输出数字（比如15、20、32…），伴随「啦啦啦」的胜利音效。
    5.  **交互控制**：支持「重置」（回到初始状态）、「调速」（滑块调整自动播放速度）、「算法比较」（如果选了sort+unique，可以并行展示排序后的队列）。

  * **旁白提示**：
    - 输入时：「现在输入20，第20号抽屉变蓝啦！这是第一次出现，final加1～」
    - 统计时：「总共有8个不重复的数字，接下来按顺序输出！」
    - 输出时：「第15号抽屉是蓝色的，输出15；第20号也是蓝色的，输出20～」


\<visualization\_conclusion\>
通过这个「抽屉游戏」，你能清楚看到桶排序的每一步——输入数字→标记抽屉→统计数量→输出结果。复古像素风和音效让学习更有趣，也更容易记住算法的核心逻辑！
\</visualization\_conclusion\>


---

## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握了「排序+去重」的技巧后，我们可以挑战更难的问题！这些问题都用到了类似的思路：
\</similar\_problems\_intro\>

  * **通用思路迁移**：
    - 统计「不同的考试分数」→ 桶排序或`set`；
    - 给「用户ID去重并排序」→ `sort+unique`；
    - 处理「商品价格的重复记录」→ 桶排序（如果价格范围小）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1177** - 排序
          * 🗣️ **推荐理由**：基础排序题，练手`sort`和各种排序算法（比如冒泡、快排），巩固排序的核心逻辑。
    2.  **洛谷 P2249** - 【深基13.例1】查找
          * 🗣️ **推荐理由**：需要先排序再二分查找，练习「排序+查找」的组合，深化对排序的理解。
    3.  **洛谷 P1090** - 合并果子
          * 🗣️ **推荐理由**：贪心算法+排序，需要多次排序合并，练习「动态排序」的技巧。
    4.  **洛谷 P1428** - 小鱼比可爱
          * 🗣️ **推荐理由**：排序+计数，需要统计每个元素前面比它小的元素数量，练习「排序后处理」的思路。


---

## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
优质题解中的「踩坑经验」是最宝贵的！我摘了几个重点：
\</insights\_intro\>

> **经验1（来自qr小盆友）**：「桶排序要注意初始化！我一开始没把`book`数组设为false，导致统计数量错了。后来才知道，全局数组会自动初始化为0，但局部数组要手动初始化！」
> **点评**：这是初学者常犯的错误！全局变量（比如`main`外的数组）会自动初始化为0，但局部变量（比如`main`内的数组）不会。所以写桶排序时，一定要手动初始化`book`数组为`false`！

> **经验2（来自2023z）**：「我一开始把重复数字赋值为0，结果三个40只减了一次数量。后来才明白，手动去重要用`a[i] == a[i-1]`统计，而不是修改数组！」
> **点评**：修改数组会破坏原数据，导致后续判断错误。手动去重的正确方式是「统计重复次数」，而不是「删除重复元素」！

> **经验3（来自Erina）**：「`unique`函数不会真的删除元素，只是把重复的移到后面。所以一定要用`resize`调整数组大小，否则输出会有多余的元素！」
> **点评**：`unique`的「去重」是「逻辑去重」，不是「物理删除」。必须用`resize`截断数组，才能得到真正的去重结果！


---

\<conclusion\>
「明明的随机数」是一道「小而精」的题目，覆盖了排序、去重、STL容器等核心技巧。通过桶排序的「抽屉游戏」、sort+unique的「排队法」、set的「智能收纳盒」，你已经掌握了「排序+去重」的所有核心思路！

记住：算法不是「背代码」，而是「找规律」——找到问题的核心（比如本题的「去重+排序」），再选择最合适的工具（桶、sort、set）。下次遇到类似问题，你一定能快速解决！💪
\</conclusion\>

---
处理用时：151.45秒
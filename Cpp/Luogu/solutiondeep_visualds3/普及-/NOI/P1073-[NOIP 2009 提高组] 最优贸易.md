# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果

---
# 💡 Kay的C++算法解析：最优贸易 深入学习指南 💡

<introduction>
  今天我们来一起分析NOIP2009提高组的经典题目“最优贸易”。这道题是图论中**状态建模**的典型例题，核心是通过“分层图”或“双SPFA”将“买卖决策”转化为图的路径问题。本指南会帮你梳理思路、掌握关键算法，并通过像素动画直观理解过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（分层图/双SPFA）

🗣️ **初步分析**：  
解决“最优贸易”的关键，是把“商人的交易状态”转化为**图的层次**——毕竟我们要跟踪“没买水晶球”“买了没卖”“卖了结束”这三种状态。简单来说，**分层图**就是把原图复制成3层，每层对应一种状态，层内边代表“移动不交易”（权值0），层间边代表“交易操作”（买入=负价格，卖出=正价格）。最终求“第一层1号点到第三层n号点的最长路”，就是最大利润！

- **题解思路对比**：  
  大部分题解用**分层图+SPFA**（直接建模状态），部分用**双SPFA**（分别求从1到各点的最低买入价、从n到各点的最高卖出价，再算差值），还有用**Tarjan缩点**（处理环，转化为DAG后DP）。其中分层图最直观，双SPFA最简洁。
- **可视化设计思路**：  
  用FC红白机风格的像素网格展示3层图，节点是彩色方块（第一层白、第二层蓝、第三层红）。移动时方块滑动，买入时蓝块闪烁+“叮”音效，卖出时红块闪烁+“铛”音效。关键步骤高亮当前状态层，自动播放时模拟商人“走一步、想一下”的过程。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度，筛选了3份高价值题解，帮你快速掌握核心！
</eval_intro>

**题解一：分层图+SPFA（作者：fy1234567ok，赞512）**  
* **点评**：  
  这份题解把“交易状态”转化为“分层图”的思路太妙了！用`t(x,i)`表示“第i层的x号节点”（i=0:没买，i=1:买了，i=2:卖了），层内边权0（移动不花钱），层间边权对应交易（买入=-价格，卖出=+价格）。代码只用40行，核心逻辑清晰——SPFA求最长路（初始化为最小值，更新时取更大值）。尤其值得学的是**状态建模的简洁性**，把复杂的“买卖决策”变成了图的边！

**题解二：双SPFA（作者：fairfriendZ，赞9）**  
* **点评**：  
  这题解的“双SPFA”思路超高效！第一次SPFA从1出发，求到各点的**最低买入价**（`minv[i]`）；第二次SPFA从n出发（建反图），求到各点的**最高卖出价**（`maxv[i]`）。最后遍历所有点，算`maxv[i]-minv[i]`的最大值。这种方法不用建分层图，代码更短，而且避开了“环”的问题——因为SPFA天然能处理图中的循环（比如绕路找更低价）。

**题解三：Tarjan缩点+DAG DP（作者：ctzm，赞20）**  
* **点评**：  
  这份题解适合想深入理解“环处理”的同学！先用Tarjan把原图缩成DAG（有向无环图），每个强连通分量（SCC）记录内部的最低买入价和最高卖出价。然后在DAG上按拓扑序DP：`dp[v]`表示到SCC v的最低买入价，`maxw[v]-dp[v]`就是该SCC的最大利润。这种方法解决了“环中无限绕路”的问题，是图论中“缩点简化问题”的经典应用！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在“状态跟踪”和“路径合法性”，我帮你提炼了3个核心难点及解决策略：
</difficulty_intro>

1. **难点1：如何跟踪“买卖状态”？**  
   * **分析**：商人有3种状态，直接在原图上无法区分“是否买过”。分层图的解法把状态变成“层”，每层对应一种状态，层间边代表状态转移——比如从第一层到第二层的边，就是“在该点买入”。  
   * 💡 **学习笔记**：状态建模的关键是“把不可见的决策变成可见的图结构”。

2. **难点2：如何处理图中的环？**  
   * **分析**：如果图中有环（比如城市1→2→1），商人可以绕环无限次，但题目要求“最多买卖一次”。分层图的解法通过“层间单向边”避免了“重复买卖”（只能从第一层到第二层，再到第三层，不能回头）；双SPFA的解法则通过“求全局最值”自动忽略环中的无用绕路。  
   * 💡 **学习笔记**：环的处理要么“切断回边”（分层图），要么“求最值时自动过滤”（SPFA）。

3. **难点3：如何确保“买入后能到卖出点，再到n”？**  
   * **分析**：比如商人在A点买入，但A到不了n，那这个买入是无效的。双SPFA的解法中，`maxv[i]`只有当i能到n时才有效（因为反图SPFA从n出发）；分层图的解法中，第三层的n点只能通过“能到n的路径”到达。  
   * 💡 **学习笔记**：路径合法性可以通过“反图遍历”（双SPFA）或“分层图的终点约束”（分层图）解决。

### ✨ 解题技巧总结
- **技巧A：状态建模**：把“决策状态”转化为“图的层次”，让复杂问题变直观。  
- **技巧B：双SPFA**：求“单源最短路”和“单汇最短路”（反图），快速得到全局最值。  
- **技巧C：缩点简化**：用Tarjan把有环图变成DAG，避免重复计算。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**分层图+SPFA**的通用核心代码——它把“状态分层”和“最长路”完美结合，是本题最经典的实现！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合fy1234567ok的题解，调整为更易读的版本，保留核心分层逻辑。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <climits>
  using namespace std;

  const int MAXN = 1e5 + 5;
  int n, m;
  int price[MAXN];
  vector<pair<int, int>> graph[MAXN * 3]; // 3层图：0-未买，1-已买，2-已卖
  int dist[MAXN * 3];
  bool inqueue[MAXN * 3];

  // 计算第k层的x号节点编号：k=0→x, k=1→x+n, k=2→x+2n
  inline int get_node(int x, int k) { return x + k * n; }

  void SPFA() {
      fill(dist, dist + 3 * n + 1, INT_MIN); // 最长路初始化为最小值
      queue<int> q;
      int start = get_node(1, 0); // 从第一层1号点出发
      dist[start] = 0;
      q.push(start);
      inqueue[start] = true;

      while (!q.empty()) {
          int u = q.front(); q.pop();
          inqueue[u] = false;
          for (auto &edge : graph[u]) {
              int v = edge.first, w = edge.second;
              if (dist[v] < dist[u] + w) { // 最长路：取更大值
                  dist[v] = dist[u] + w;
                  if (!inqueue[v]) {
                      q.push(v);
                      inqueue[v] = true;
                  }
              }
          }
      }
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cin >> n >> m;
      for (int i = 1; i <= n; ++i) {
          cin >> price[i];
          // 层间边：未买→已买（买入，权值-price[i]）
          graph[get_node(i, 0)].emplace_back(get_node(i, 1), -price[i]);
          // 层间边：已买→已卖（卖出，权值+price[i]）
          graph[get_node(i, 1)].emplace_back(get_node(i, 2), price[i]);
      }
      for (int i = 0; i < m; ++i) {
          int x, y, z;
          cin >> x >> y >> z;
          // 层内边：移动不交易，权值0
          for (int k = 0; k < 3; ++k) {
              graph[get_node(x, k)].emplace_back(get_node(y, k), 0);
              if (z == 2) { // 双向边，反过来也加
                  graph[get_node(y, k)].emplace_back(get_node(x, k), 0);
              }
          }
      }
      SPFA();
      // 答案是第三层n号点的最长路（可能为0，比如不买卖）
      cout << max(dist[get_node(n, 2)], 0) << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **分层节点**：用`get_node(x,k)`生成第k层的x号节点（k=0/1/2对应三种状态）。  
  2. **层间边**：未买→已买的边权是`-price[i]`（花了钱），已买→已卖的边权是`price[i]`（赚了钱）。  
  3. **层内边**：移动不交易，权值0；双向边要加两条。  
  4. **SPFA求最长路**：初始化为`INT_MIN`，每次更新取更大值，最终第三层n号点的`dist`就是最大利润。

---

<code_intro_selected>
再看**双SPFA**的核心片段——它的简洁性让人眼前一亮！
</code_intro_selected>

**题解二：双SPFA（作者：fairfriendZ）**
* **亮点**：不用建分层图，两次SPFA直接求最值，代码超短！
* **核心代码片段**：
  ```cpp
  // 第一次SPFA：从1出发，求到各点的最低买入价minv
  void spfa1(int s) {
      fill(minv, minv + n + 1, INT_MAX);
      queue<int> q;
      q.push(s); minv[s] = price[s]; vis[s] = true;
      while (!q.empty()) {
          int u = q.front(); q.pop(); vis[u] = false;
          for (int v : e[u]) { // e是原图
              if (minv[v] > min(minv[u], price[v])) {
                  minv[v] = min(minv[u], price[v]);
                  if (!vis[v]) q.push(v), vis[v] = true;
              }
          }
      }
  }

  // 第二次SPFA：从n出发（反图g），求到各点的最高卖出价maxv
  void spfa2(int s) {
      fill(maxv, maxv + n + 1, INT_MIN);
      queue<int> q;
      q.push(s); maxv[s] = price[s]; vis[s] = true;
      while (!q.empty()) {
          int u = q.front(); q.pop(); vis[u] = false;
          for (int v : g[u]) { // g是反图
              if (maxv[v] < max(maxv[u], price[v])) {
                  maxv[v] = max(maxv[u], price[v]);
                  if (!vis[v]) q.push(v), vis[v] = true;
              }
          }
      }
  }
  ```
* **代码解读**：  
  - 第一次SPFA遍历原图，`minv[i]`记录从1到i的所有路径中，能买到的最低价格（比如绕路找更便宜的）。  
  - 第二次SPFA遍历反图（把所有边反过来），`maxv[i]`记录从i到n的所有路径中，能卖出的最高价格（因为反图从n出发，等价于原图i到n）。  
  - 最后遍历所有点，`maxv[i]-minv[i]`的最大值就是答案——相当于“在i点买，之后在某个能到n的点卖”。
* 💡 **学习笔记**：反图的妙用！把“i到n的最长路”转化为“n到i的最长路”，用SPFA轻松解决。


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了让你“看清楚”分层图的运行过程，我设计了一个**FC红白机风格的像素动画**！你会看到商人从第一层1号点出发，移动、买入、卖出，最终到达第三层n号点——每一步都有动画和音效！
\</visualization_intro\>

### 动画设计详情
#### 1. **整体风格**  
- 屏幕分成3行（对应3层），每行有n个像素块（对应城市），颜色区分状态：  
  - 第一层（未买）：白色方块；  
  - 第二层（已买）：蓝色方块；  
  - 第三层（已卖）：红色方块。  
- 控制面板在屏幕下方：有“开始/暂停”“单步”“重置”按钮，以及速度滑块（1~5档）。  
- 背景音乐：FC风格的轻快BGM（比如《超级马里奥》的背景音）。

#### 2. **核心动画步骤**  
1. **初始化**：屏幕显示3层白色方块，第一层1号点闪烁（表示起点），控制面板显示“准备开始”。  
2. **移动操作**：商人从当前层的u点移动到v点——对应的方块从u滑到v，伴随“沙沙”的移动音效。  
3. **买入操作**：商人在第一层的x点买入——白色方块变成蓝色（跳到第二层），伴随“叮”的音效，屏幕上方弹出提示：“在x点买入，花费-price[x]！”。  
4. **卖出操作**：商人在第二层的y点卖出——蓝色方块变成红色（跳到第三层），伴随“铛”的音效，提示：“在y点卖出，赚了price[y]！”。  
5. **结束状态**：当商人到达第三层的n号点——红色方块闪烁，播放“胜利”音效（比如《魂斗罗》的通关音），屏幕显示“最大利润：XXX”。

#### 3. **交互设计**  
- **单步模式**：点击“单步”，动画走一步，暂停并显示当前状态（比如“当前在第二层3号点，已花费-3”）。  
- **自动模式**：滑动速度滑块，动画按设定速度播放，模拟商人“自主决策”的过程。  
- **重置**：恢复初始状态，重新开始。

#### 4. **为什么这样设计？**  
- 用“颜色分层”直观区分状态，避免混淆；  
- 音效强化“交易操作”的记忆（比如“叮”=买入，“铛”=卖出）；  
- 单步模式让你能“慢动作”看清楚每一步的决策，自动模式则模拟真实的解题过程。


## 6. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握了“状态建模”和“双SPFA”，你可以解决很多类似的图论问题！比如“有限次操作的最短路径”“带决策的路径问题”。
\</similar_problems_intro\>

### 通用思路迁移
- 分层图：适用于“有k次特殊操作”的问题（比如“可以飞k次，跳过某些边”）；  
- 双SPFA：适用于“求路径上的最值差”（比如“最大差值路径”“最小乘积路径”）；  
- 缩点：适用于“有环图的DP问题”（比如“环中找最长路径”）。

### 洛谷练习推荐
1. **洛谷 P2939** - [改造路](https://www.luogu.com.cn/problem/P2939)  
   🗣️ **推荐理由**：分层图的经典题！要求“最多修改k条边的权值为0”，用分层图建模“修改次数”，求最短路径。  
2. **洛谷 P4568** - [飞行路线](https://www.luogu.com.cn/problem/P4568)  
   🗣️ **推荐理由**：和本题思路几乎一样！用分层图处理“可以免费坐k次飞机”的状态，求最短路径。  
3. **洛谷 P4822** - [信使](https://www.luogu.com.cn/problem/P4822)  
   🗣️ **推荐理由**：图论最短路径的基础题，练手用——求从1到所有点的最长最短路径，巩固SPFA的用法。


## 7. 学习心得与经验分享 (若有)

\<insights_intro\>
很多题解作者分享了自己的“踩坑”经历，我选了两条最有价值的：
\</insights_intro\>

> **经验1（来自fy1234567ok）**：“一开始我把层间边连到了‘下一层的相邻点’，结果错了——层间边应该连到‘同一点的下一层’！比如买入操作是‘当前点的第一层→当前点的第二层’，而不是‘当前点的第一层→下一个点的第二层’。”  
> **点评**：这个坑很常见！层间边代表“在当前点做决策”，不是“移动后做决策”——记住：**分层图的层间边是“点内转移”，层内边是“点间转移”**。

> **经验2（来自ctzm）**：“缩点后一定要建反图判断‘能否到n’！否则会把‘买了但到不了n’的情况算进去，导致答案错误。”  
> **点评**：路径合法性是容易忽略的点！无论是双SPFA的反图，还是缩点后的反图遍历，都是为了确保“买卖后能到终点”——细节决定成败！


\<conclusion\>
“最优贸易”是图论中“状态建模”的入门题，核心是把“决策”转化为“图的结构”。通过分层图、双SPFA或缩点，你可以轻松解决这类问题。记住：**算法的本质是“问题转化”——把复杂的现实问题变成计算机能处理的图或数学模型**！  

下次遇到类似的“带决策的路径问题”，不妨想想：“能不能用分层图？能不能用双SPFA？”——多练几道题，你会越来越熟练！💪
\</conclusion\>

---

---
处理用时：140.06秒
# 题目信息

# [NOIP 2011 普及组] 统计单词数

## 题目描述

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例 1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例 2）。


## 说明/提示

数据范围

$1\leq $ 第一行单词长度 $\leq10$。

$1\leq $ 文章长度 $\leq10^6$。

noip2011 普及组第 2 题


## 样例 #1

### 输入

```
To
to be or not to be is a question
```

### 输出

```
2 0

```

## 样例 #2

### 输入

```
to
Did the Ottoman Empire lose its power at that time```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：统计单词数 深入学习指南 💡

<introduction>
今天我们来一起分析NOIP2011普及组的经典题目「统计单词数」。这道题看似简单，却藏着字符串处理的核心技巧——如何正确读取输入、如何确保“完整单词匹配”、如何统一大小写。本指南会帮你理清思路，掌握关键技巧，甚至用像素动画直观看到算法运行！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（字符串处理、完整匹配、大小写统一）

🗣️ **初步分析**：
解决这道题的关键，是**把“模糊的单词匹配”变成“精确的字符串问题”**——就像找朋友要先确认“全名+穿着”，而不是只认“名字里的一个字”。具体来说：
- **统一大小写**：不管输入是大写还是小写，先转成同一格式（比如全小写），避免“To”和“to”被当成不同单词；
- **完整单词匹配**：必须保证目标单词是文章中的“独立单词”（前后是空格或字符串边界），比如“Ottoman”里的“to”不能算匹配；
- **输入处理**：文章可能有行首空格或长文本，要正确读取完整的一行。

题解的核心思路分三类：
1. **拆分单词法**：把文章按空格拆成单个单词，逐个和目标单词比较（如Eason_lyx的题解）；
2. **前后加空格法**：给目标单词和文章前后都加空格，用`find`函数找完整匹配（如Jelly_Goat、wanghonghui123的题解）；
3. **双指针扫描法**：用两个指针分别遍历文章和目标单词，实时判断是否匹配（如suxy15的题解）。

**可视化设计思路**：我们会用8位像素风格展示“字符串匹配”过程——用不同颜色的像素块代表目标单词和文章字符，匹配时高亮当前位置，成功时播放“叮”的音效，单步执行能看清每一步的字符对比！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、实践价值三个维度筛选了3份优质题解，覆盖了最常用的三种思路：
</eval_intro>

**题解一：拆分单词法（作者：Eason_lyx，赞93）**
* **点评**：这份题解的思路像“拆快递”——把文章按空格拆成一个个单词，逐个核对目标单词，逻辑直白到“一看就懂”！代码里用`getline`正确读取带空格的文章，用`tolower`统一小写，最后通过`dan`变量收集当前单词，遇到空格就核对。特别棒的是，作者加了`s += ' '`确保最后一个单词也能被扫描到，细节处理很严谨！

**题解二：前后加空格法（作者：wanghonghui123，赞45）**
* **点评**：这是“偷懒但聪明”的技巧！给目标单词和文章前后都加空格（比如“to”变成“ to ”，文章变成“ ... ”），这样用`find`函数找的就是“被空格包围的完整单词”，完美避免部分匹配。代码里用`toupper`统一大写，`find`循环统计次数，逻辑简洁到“一行顶十行”！

**题解三：双指针扫描法（作者：suxy15，赞154）**
* **点评**：这份C代码是“手动挡玩家的浪漫”——用双指针`i`（文章）和`j`（目标单词）逐字符匹配，同时判断是否是单词开头（`i==0`或前一个是空格）。虽然代码比C++的`string`操作繁琐，但把“完整匹配”的逻辑拆解得明明白白，适合初学者理解字符串处理的底层逻辑！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”都藏在细节里！结合题解的共性，我提炼了3个核心难点和解决策略：
</difficulty_intro>

1. **难点1：如何正确读取带空格的文章？**
    * **分析**：用`cin`读文章会“卡”在第一个空格，必须用`getline`。但要注意：`cin`读目标单词后会留下换行符，需要用`getchar()`吃掉，否则`getline`会读空行（比如Eason_lyx的题解里`getchar()`的作用）。
    * 💡 **学习笔记**：读带空格的字符串用`getline`，读之前先处理残留的换行符！

2. **难点2：如何确保“完整单词匹配”？**
    * **分析**：有两种方法：
      - 拆分法：把文章拆成单词，逐个比较（如Eason_lyx）；
      - 加空格法：给目标和文章前后加空格，用`find`找完整子串（如wanghonghui123）。
    * 💡 **学习笔记**：完整匹配的关键是“给目标单词加边界”，要么拆成独立单词，要么用空格包围！

3. **难点3：如何统一大小写？**
    * **分析**：可以用`tolower`（转小写）或`toupper`（转大写）函数，也可以手动计算（比如`a += 32`把大写转小写）。注意：函数需要包含`<cctype>`头文件（C++）或`<ctype.h>`（C）。
    * 💡 **学习笔记**：统一大小写是“消除歧义”的关键，一定要在匹配前做！

### ✨ 解题技巧总结
<summary_best_practices>
字符串处理的“万能小技巧”：
</summary_best_practices>
- **输入安全**：读带空格的字符串用`getline`，先处理残留换行符；
- **边界处理**：给目标和文章加空格，避免部分匹配；
- **统一格式**：匹配前先转大小写，消除歧义；
- **细节检查**：最后一个单词要单独处理（比如加空格）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**——基于Eason_lyx的题解，逻辑清晰，适合初学者：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：这份代码用“拆分单词法”，逻辑直白，覆盖所有边界情况（比如最后一个单词、行首空格）。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    using namespace std;

    int main() {
        string target, article, current_word;
        int count = 0, first_pos = -1;

        // 读取目标单词并转小写
        cin >> target;
        for (char &c : target) c = tolower(c);
        getchar(); // 吃掉cin留下的换行符

        // 读取文章并转小写，末尾加空格确保最后一个单词被处理
        getline(cin, article);
        article += ' ';
        for (char &c : article) c = tolower(c);

        // 拆分单词并匹配
        for (int i = 0; i < article.size(); ++i) {
            if (article[i] == ' ') {
                if (current_word == target) {
                    count++;
                    if (first_pos == -1) first_pos = i - target.size();
                }
                current_word.clear();
            } else {
                current_word += article[i];
            }
        }

        // 输出结果
        if (count == 0) cout << -1;
        else cout << count << " " << first_pos;
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. 读目标单词，转小写；
    > 2. 读文章，转小写并加空格（处理最后一个单词）；
    > 3. 遍历文章，用`current_word`收集当前单词，遇到空格就核对目标；
    > 4. 统计次数和第一次位置，输出结果。

---
<code_intro_selected>
接下来看3份优质题解的核心片段，学它们的“巧思”：
</code_intro_selected>

**题解一：拆分单词法（作者：Eason_lyx）**
* **亮点**：用`current_word`收集单词，逻辑直观，适合入门。
* **核心代码片段**：
    ```cpp
    for (int i = 0; i < article.size(); ++i) {
        if (article[i] == ' ') {
            if (current_word == target) {
                count++;
                if (first_pos == -1) first_pos = i - target.size();
            }
            current_word.clear();
        } else {
            current_word += article[i];
        }
    }
    ```
* **代码解读**：
    > 这段代码像“捡豆子”——遇到空格就“停下”，看看手里的“豆子”（current_word）是不是目标。如果是，就计数；不是就清空，继续捡下一堆。`i - target.size()`是计算第一次出现的位置：比如当前空格在位置`i`，目标单词长度是`target.size()`，那单词的起始位置就是`i - 长度`。
* 💡 **学习笔记**：拆分单词的关键是“用空格当分隔符”，收集到完整单词再核对！

**题解二：前后加空格法（作者：wanghonghui123）**
* **亮点**：用`find`函数简化匹配，代码量少。
* **核心代码片段**：
    ```cpp
    string target = "to";
    string article = "to be or not to be";
    target = " " + target + " "; // 变成" to "
    article = " " + article + " "; // 变成" to be or not to be "
    int pos = article.find(target);
    while (pos != -1) {
        count++;
        pos = article.find(target, pos + 1);
    }
    ```
* **代码解读**：
    > 给目标和文章加空格后，`find`找的就是“被空格包围的完整单词”。比如“Ottoman”里的“to”会变成“ ottoman ”，不会匹配“ to ”。`pos + 1`是从下一个位置继续找，避免重复匹配。
* 💡 **学习笔记**：`find`函数是字符串处理的“瑞士军刀”，但要先给目标加边界！

**题解三：双指针扫描法（作者：suxy15）**
* **亮点**：手动实现匹配，理解底层逻辑。
* **核心代码片段**：
    ```c
    for (i=0,j=0; s[i]!='\0'; ++i) {
        if ((i==0 || s[i-1]==' ' || j) && val(s[i])==val(w[j]) && ++j>-1) {
            if (w[j]=='\0' && (s[i+1]=='\0' || s[i+1]==' ')) {
                if (first==-1) first = i+1-j;
                count++;
            }
        } else j=0;
    }
    ```
* **代码解读**：
    > 用`i`遍历文章，`j`遍历目标单词。`i==0 || s[i-1]==' '`判断是不是单词开头，`val`函数转小写。如果当前字符匹配，`j`加1；如果`j`到目标单词末尾，且下一个字符是空格或结束，说明匹配成功。
* 💡 **学习笔记**：双指针是字符串匹配的“基础功”，适合理解底层逻辑！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”字符串匹配的过程，我设计了一个**8位像素风的动画**——像玩FC游戏一样，看着算法一步步找单词！
</visualization_intro>

  * **动画演示主题**：像素探险家“小K”在字符串迷宫里找“目标单词宝箱”。
  * **核心演示内容**：展示“拆分单词法”的过程——小K沿着文章字符串走，遇到空格就打开当前收集的“单词包”，核对是不是目标。
  * **设计思路简述**：用8位像素风是因为“复古又亲切”，像小时候玩的《超级马里奥》；音效和高亮能强化“关键操作”的记忆，比如匹配成功时的“叮”声，让你立刻记住“哦，这里找到单词了！”

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：
       - 屏幕左侧是“目标单词区”：用红色像素块显示目标单词（比如“to”）；
       - 屏幕右侧是“文章区”：用白色像素块显示文章字符，空格用灰色块表示；
       - 底部控制面板：有“单步执行”“自动播放”“重置”按钮，速度滑块（从“慢”到“快”）。
    2. **算法启动**：
       - 小K（黄色像素小人）站在文章区的第一个字符前，目标单词区的“to”开始闪烁；
       - 背景音乐：8位风格的轻快BGM（类似《坦克大战》的背景音）。
    3. **核心步骤演示**：
       - **收集单词**：小K走到字符“t”，拿起它（字符变成黄色），走到“o”，拿起（也变黄），遇到空格（灰色块），停下；
       - **核对单词**：小K打开“单词包”（黄色字符组成“to”），和目标区的“to”对比，匹配成功！播放“叮”的音效，目标区的“to”变成绿色，计数+1，第一次位置标记为当前空格的位置-2；
       - **继续扫描**：小K清空“单词包”，继续走，遇到下一个“to”，重复上述步骤。
    4. **交互设计**：
       - 单步执行：点击一次，小K走一步，显示当前收集的单词；
       - 自动播放：小K自动走，速度用滑块调节；
       - 重置：回到初始状态，重新开始。
    5. **结束状态**：
       - 扫描完成后，屏幕显示“找到X次，第一次在位置Y”，播放胜利音效（类似《魂斗罗》的通关音）；
       - 如果没找到，显示“-1”，播放短促的提示音。

  * **旁白提示**：
    - （小K拿起“t”时）“现在收集到字符‘t’，继续找下一个字符！”
    - （遇到空格时）“遇到空格，核对当前单词是不是目标！”
    - （匹配成功时）“匹配成功！计数加1，第一次位置是这里！”

<visualization_conclusion>
通过这个动画，你能**直观看到**“拆分单词法”的每一步——从收集字符到核对单词，从计数到标记位置。像素风格和音效让学习变有趣，再也不用死记硬背代码逻辑啦！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
字符串处理是编程的“基本功”，学会这道题的技巧，可以解决很多类似问题：
</similar_problems_intro>

  * **通用思路迁移**：
    - 问题1：统计文章中“高频单词”（拆分成单词，用map计数）；
    - 问题2：替换文章中的特定单词（用`find`找单词，替换成新内容）；
    - 问题3：检查字符串是否是“回文单词”（统一大小写，反转后比较）。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P5733** - 【深基6.例1】自动修正
       * 🗣️ **推荐理由**：练习“字符串替换”，巩固大小写统一和`find`函数的用法。
    2. **洛谷 P1553** - 数字反转（升级版）
       * 🗣️ **推荐理由**：练习“字符串拆分”，处理不同格式的数字（整数、小数、百分数）。
    3. **洛谷 P1055** - ISBN号码
       * 🗣️ **推荐理由**：练习“字符串验证”，处理固定格式的字符串（比如ISBN的校验位）。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解里的“踩坑经验”比代码更珍贵！我摘录了几个关键心得：
</insights_intro>

> **经验1（来自Eason_lyx）**：“我一开始没给文章加空格，导致最后一个单词没被扫描到，卡了很久！后来加了`s += ' '`才过。”
> **点评**：最后一个单词的处理是“高频坑”！加空格是最简单的解决方法，一定要记住。

> **经验2（来自wanghonghui123）**：“用`cin`读文章会读不全，必须用`getline`，但要先`getchar()`吃掉换行符！”
> **点评**：输入处理的“细节杀”！`cin`和`getline`混用会留换行符，一定要处理。

> **经验3（来自suxy15）**：“C语言没有`string`，处理字符串要手动用数组，一定要注意数组大小（比如文章长度1e6，数组要开1000001）！”
> **点评**：C语言的字符串是“手动管理内存”，数组大小要足够，避免越界！


<conclusion>
本次关于「统计单词数」的分析就到这里啦！这道题的核心是“字符串处理的细节”——输入安全、完整匹配、大小写统一。记住：编程的“内功”不是写复杂的算法，而是把简单的事情做对！下次遇到字符串问题，不妨想想今天学的“拆分法”“加空格法”，肯定能用得上～ 💪
</conclusion>

---
处理用时：133.04秒
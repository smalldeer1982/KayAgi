# 题目信息

# [NOIP 2014 普及组] 比例简化

## 题目背景

NOIP2014 普及组 T2

## 题目描述

在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有 $1498$ 人，反对的有 $902$ 人，那么赞同与反对的比例可以简单的记为 $1498:902$。

不过，如果把调查结果就以这种方式呈现出来，大多数人肯定不会满意。因为这个比例的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为 $5:3$，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。

现给出支持人数 $A$，反对人数 $B$，以及一个上限 $L$，请你将 $A$ 比 $B$ 化简为 $A'$ 比 $B'$，要求在 $A'$ 和 $B'$ 均不大于 $L$ 且 $A'$ 和 $B'$ 互质（两个整数的最大公约数是 $1$）的前提下，$\dfrac{A'}{B'} \ge  \dfrac{A}{B}$ 且 $\dfrac{A'}{B'} - \dfrac{A}{B}$ 的值尽可能小。

## 说明/提示

对于 $100\%$ 的数据，$1 \le A \le 10^6,1 \le B \le 10^6,1 \le L \le 100,\dfrac{A}{B} \le L$。


## 样例 #1

### 输入

```
1498 902 10```

### 输出

```
5 3```

# AI分析结果

---
# 💡 Kay的C++算法解析：比例简化 深入学习指南 💡

<introduction>
  今天我们来一起分析NOIP2014普及组的经典题目——「比例简化」。这道题看似需要处理大数，但其实藏着一个“小秘密”：上限L≤100！我们可以用**枚举法**轻松解决它。本指南会帮你理清思路、避开陷阱，还会用像素动画让算法“动起来”～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举（暴力搜索的一种，适合小范围问题）

🗣️ **初步分析**：
解决“比例简化”的关键，在于利用**L很小（≤100）**的特点——直接枚举所有可能的`A'`（i）和`B'`（j）（范围1~L），然后筛选出符合条件的组合：
1. `i`和`j`互质（最大公约数为1）；
2. `i/j ≥ A/B`（即`i*B ≥ j*A`，用**交叉相乘**避免浮点精度错误）；
3. `i/j`尽可能接近`A/B`（用`i*ansb < j*ansa`代替浮点减法，更准确）。

枚举法就像在一个“100x100的小格子”里逐个检查每个点，找到最符合要求的那个——就像在玩具箱里翻找最爱的拼图，范围小所以不会累！

### 核心算法流程与可视化设计
- **枚举流程**：双重循环遍历i（1~L）和j（1~L），依次检查条件；
- **关键变量更新**：用`ansa`和`ansb`记录当前最优解，每当找到更优的组合时就更新它们；
- **可视化思路**：设计8位像素风格的“枚举网格”——x轴是i（A'），y轴是j（B'），每个格子代表一个(i,j)组合。符合条件的格子亮绿色，最优解亮红色，单步执行时会一步步“点亮”格子，自动播放时像“扫描”一样遍历，还会有音效提示关键操作（比如找到更优解时“叮”一声）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，一起来看看它们的亮点吧～
</eval_intro>

**题解一：以墨（赞326）**
* **点评**：这份题解是“枚举法”的标准模板！思路特别直白——用双重循环遍历所有可能，用`gcd`函数判断互质，用`i*b ≥ j*a`避免浮点错误，用`i*ansb < j*ansa`比较差值。代码简洁到“一眼就能看懂”，变量名（`ansa`、`ansb`）也很直观，边界处理（初始`ansa=l`、`ansb=1`）非常严谨，直接可以用于竞赛！

**题解二：moongazer（赞160）**
* **点评**：这是枚举法的“优化版”！作者发现：如果`i/j < A/B`，就增大i；如果`i/j ≥ A/B`，就增大j。这样把双重循环变成了**线性枚举**（时间复杂度O(L)），更快！而且同样用交叉相乘避免浮点问题，思路很巧妙，适合想“更高效”的同学。

**题解三：WsW_（赞4）**
* **点评**：这份题解用了C++标准库的`__gcd`函数（需包含`<algorithm>`），省去了自己写gcd函数的麻烦，代码更简洁。作者还把“互质判断”封装成`check`函数，逻辑更清晰，非常适合学习“代码模块化”的技巧～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
枚举法看似简单，但容易踩三个“小坑”。结合优质题解，我帮你总结了应对策略：
</difficulty_intro>

1. **难点1：浮点精度错误**  
   * **问题**：直接计算`i/j`和`A/B`会有精度损失（比如0.1在计算机里是近似值）；  
   * **解决**：用**交叉相乘**转换不等式——`i/j ≥ A/B`等价于`i*B ≥ j*A`（都是整数运算，完全准确！）。  
   * 💡 **学习笔记**：整数运算永远比浮点运算可靠！

2. **难点2：互质判断**  
   * **问题**：如何快速判断两个数是否互质？  
   * **解决**：用**辗转相除法**（gcd函数）——如果`gcd(i,j)==1`，说明互质。C++标准库的`__gcd`函数也能直接用（注意：需要`#include <algorithm>`）。  
   * 💡 **学习笔记**：gcd是处理“互质”问题的神器！

3. **难点3：高效比较差值**  
   * **问题**：直接计算`i/j - A/B`会有浮点误差，而且麻烦；  
   * **解决**：转换为交叉相乘——要让`i/j`更接近`A/B`，等价于让`i/j`更小（因为`i/j ≥ A/B`），即`i*ansb < j*ansa`（假设当前最优解是`ansa/ansb`）。  
   * 💡 **学习笔记**：把“差值最小”转化为“分数最小”，用整数运算解决！

### ✨ 解题技巧总结
- **技巧1：利用小范围枚举**：当题目给的上限很小时（比如L≤100），直接枚举是最直接的方法；
- **技巧2：避免浮点运算**：用交叉相乘转换分数不等式，永远比浮点可靠；
- **技巧3：代码模块化**：把重复的逻辑（比如互质判断）封装成函数，让代码更清晰。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**（综合以墨和WsW_的思路），帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码是枚举法的标准实现，用gcd判断互质，交叉相乘避免浮点错误，逻辑清晰。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <algorithm> // 用于__gcd函数
  using namespace std;

  int main() {
      int A, B, L;
      cin >> A >> B >> L;
      int ansa = L, ansb = 1; // 初始最优解：L/1（最大的可能分数）

      for (int i = 1; i <= L; ++i) {
          for (int j = 1; j <= L; ++j) {
              // 条件1：i和j互质；条件2：i*B >= j*A（i/j >= A/B）；条件3：i/j更小（更优）
              if (__gcd(i, j) == 1 && i * B >= j * A && i * ansb < j * ansa) {
                  ansa = i;
                  ansb = j;
              }
          }
      }

      cout << ansa << " " << ansb << endl;
      return 0;
  }
  ```
* **代码解读概要**：
  1. 读取输入的A、B、L；
  2. 初始化最优解为`L/1`（因为这是最大的可能分数，后续会被更优解替换）；
  3. 双重循环枚举所有i（A'）和j（B'）；
  4. 检查三个条件：互质、分数≥原比例、更优；
  5. 输出最优解。

---

<code_intro_selected>
接下来剖析优质题解的核心片段，看看它们的“巧思”：
</code_intro_selected>

**题解一：以墨的gcd函数**
* **亮点**：自己实现gcd函数，掌握辗转相除法的核心；
* **核心代码片段**：
  ```cpp
  int gcd(int x, int y) {
      if (y == 0) return x;
      return gcd(y, x % y);
  }
  ```
* **代码解读**：
  辗转相除法的逻辑是：用较大的数除以较小的数，然后用余数代替较大的数，重复直到余数为0——最后剩下的数就是最大公约数。比如`gcd(15, 5)`会返回5，`gcd(14, 9)`会返回1（互质）。
* 💡 **学习笔记**：自己实现gcd能加深对算法的理解！

**题解二：moongazer的线性枚举**
* **亮点**：把双重循环优化成线性循环，更快；
* **核心代码片段**：
  ```cpp
  int i = 1, j = 1;
  while (true) {
      if (A * 1LL * j <= B * 1LL * i) { // 条件：i/j >= A/B
          if (i * 1LL * ansb < j * 1LL * ansa) {
              ansa = i; ansb = j;
          }
          j++;
          if (j > L) break;
      } else {
          i++;
          if (i > L) break;
      }
  }
  ```
* **代码解读**：
  初始i=1、j=1，然后根据`i/j`和`A/B`的大小调整i或j：如果`i/j`太小，就增大i；如果`i/j`足够大，就增大j。这样只用遍历O(L)次，比双重循环的O(L²)更快！
* 💡 **学习笔记**：观察规律能优化算法效率！

**题解三：WsW_的check函数**
* **亮点**：把互质判断封装成函数，代码更模块化；
* **核心代码片段**：
  ```cpp
  bool check(int x, int y) {
      return __gcd(x, y) == 1;
  }
  ```
* **代码解读**：
  用`__gcd`函数判断x和y是否互质，返回布尔值。这样主循环里的条件会更简洁（`if (check(i,j) && ...)`）。
* 💡 **学习笔记**：模块化代码让逻辑更清晰！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让枚举过程“看得见”，我设计了一个**8位像素风格的动画**——像玩红白机游戏一样看算法运行！
</visualization_intro>

### 动画设计方案
- **主题**：像素探险家在“比例网格”中寻找最优解；
- **风格**：FC红白机风格（低分辨率、鲜艳色彩：灰色背景、绿色符合条件的格子、红色最优解、黄色当前遍历的格子）；
- **核心演示内容**：
  1. **初始化**：屏幕显示10x10的网格（L=10时），x轴是i（A'），y轴是j（B'），左下角是(1,1)，右上角是(L,L)；
  2. **遍历过程**：
     - 黄色方块“扫描”每个格子（i从1到L，j从1到L）；
     - 如果格子符合条件（互质+分数≥原比例），就变成绿色，并播放“叮”的像素音效；
     - 如果找到更优解，红色方块会跳到该格子，并播放“铛”的音效；
  3. **交互控制**：
     - 控制面板：“单步”（一步步走）、“自动”（匀速扫描）、“重置”（回到初始状态）；
     - 速度滑块：调整自动播放的速度（慢→快）；
  4. **结束状态**：遍历完成后，红色方块闪烁，播放胜利音效（像FC游戏通关的音乐），并在屏幕下方显示最优解（比如“5 3”）。

### 设计思路
- **像素风格**：复古感强，符合青少年的游戏记忆，降低学习的“距离感”；
- **颜色标记**：用不同颜色区分“未遍历”“当前遍历”“符合条件”“最优解”，直观看到算法的每一步；
- **音效提示**：用简单的像素音效强化关键操作（比如找到更优解时的“铛”声），帮助记忆；
- **交互设计**：单步执行让学习者能仔细观察每一步，自动播放能快速看整体流程。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
枚举法和gcd是非常基础但常用的技巧，很多题目都能用它们解决。一起来看看相似问题吧！
</similar_problems_intro>

### 通用思路迁移
- **场景1**：寻找两个数的最大公约数（gcd的直接应用）；
- **场景2**：枚举所有可能的组合（比如“找出1~100中所有互质的数对”）；
- **场景3**：在小范围内找最优解（比如“找出1~100中最接近π的分数”）。

### 洛谷练习推荐
1. **洛谷 P1029** - 最大公约数和最小公倍数问题  
   * 🗣️ **推荐理由**：直接考察gcd和lcm的关系，帮你巩固“互质”的概念；
2. **洛谷 P1414** - 又是毕业季I  
   * 🗣️ **推荐理由**：需要枚举所有可能的公约数，训练“小范围枚举”的能力；
3. **洛谷 P2085** - 最小函数值  
   * 🗣️ **推荐理由**：类似“找最优解”的问题，需要枚举并维护最小值，强化“枚举+优化”的思路。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解里藏着很多“踩坑经验”，我帮你摘录了几条：
</insights_intro>

> **经验1（来自以墨）**：“一开始我直接用浮点比较，结果样例没过，后来换成交叉相乘就对了！”  
> **点评**：浮点精度是编程的常见陷阱，用整数运算避免是最保险的方法～

> **经验2（来自moongazer）**：“我发现如果`i/j`太小就增大i，太大就增大j，这样不用双重循环也能枚举！”  
> **点评**：观察问题的规律能优化算法，比“暴力枚举”更高效～

> **经验3（来自Amoribus）**：“其实不用判断互质，因为最简分数会先被枚举到，非最简的不会更新最优解！”  
> **点评**：这个结论很巧妙——比如6/4=3/2，而3/2会先被枚举到，所以即使枚举到6/4，也不会比3/2更优，因此可以省略互质判断（但建议保留，更严谨）。


<conclusion>
本次关于“比例简化”的分析就到这里啦！枚举法虽然“暴力”，但在小范围问题中非常好用——关键是要避开浮点陷阱、用gcd判断互质、高效比较差值。希望这份指南能帮你掌握这些技巧，下次遇到类似问题时能快速解决！💪
</conclusion>

---
处理用时：132.19秒
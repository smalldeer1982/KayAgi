# 题目信息

# [NOIP 2018 普及组] 龙虎斗

## 题目背景

NOIP2018 普及组 T2

## 题目描述

轩轩和凯凯正在玩一款叫《龙虎斗》的游戏，游戏的棋盘是一条线段，线段上有 $n$ 个兵营（自左至右编号 $1 \sim n$），相邻编号的兵营之间相隔 $1$ 厘米，即棋盘为长度为 $n-1$ 厘米的线段。$i$ 号兵营里有 $c_i$ 位工兵。下面图 1 为 $n=6$ 的示例： 

![](https://cdn.luogu.com.cn/upload/pic/43224.png)    

轩轩在左侧，代表“龙”；凯凯在右侧，代表“虎”。 他们以 $m$ 号兵营作为分界， 靠左的工兵属于龙势力，靠右的工兵属于虎势力，而第 $m$ 号兵营中的工兵很纠结，他们不属于任何一方。    

一个兵营的气势为：该兵营中的工兵数$ \times $ 该兵营到 $m$ 号兵营的距离；参与游戏 一方的势力定义为：属于这一方所有兵营的气势之和。    
下面图 2 为 $n = 6,m = 4$ 的示例，其中红色为龙方，黄色为虎方：

![](https://cdn.luogu.com.cn/upload/pic/43225.png)  

游戏过程中，某一刻天降神兵，共有 $s_1$ 位工兵突然出现在了 $p_1$ 号兵营。作为轩轩和凯凯的朋友，你知道如果龙虎双方气势差距太悬殊，轩轩和凯凯就不愿意继续玩下去了。为了让游戏继续，你需要选择一个兵营 $p_2$，并将你手里的 $s_2$ 位工兵全部派往 兵营 $p_2$，使得双方气势差距尽可能小。 

 注意：你手中的工兵落在哪个兵营，就和该兵营中其他工兵有相同的势力归属（如果落在 $m$ 号兵营，则不属于任何势力）。

## 说明/提示

**样例 1 说明**   

见问题描述中的图 2。   
双方以 $m=4$ 号兵营分界，有 $s_1=5$ 位工兵突然出现在 $p_1=6$ 号兵营。 
龙方的气势为：   
$$2 \times (4-1)+3 \times (4-2)+2 \times (4-3) = 14$$  
虎方的气势为：   
$$2 \times  (5 - 4) + (3 + 5) \times (6 - 4) = 18$$  
当你将手中的 $s_2 = 2$ 位工兵派往 $p_2 = 2$ 号兵营时，龙方的气势变为： 
$$14 + 2 \times  (4 - 2) = 18$$  
此时双方气势相等。 
  
**样例 2 说明**   

双方以 $m = 5$ 号兵营分界，有 $s_1 = 1$ 位工兵突然出现在 $p_1 = 4$ 号兵营。  
龙方的气势为：   
$$1 \times  (5 - 1) + 1 \times  (5 - 2) + 1 \times  (5 - 3) + (1 + 1) \times  (5 - 4) = 11$$  
虎方的气势为：   
$$16 \times  (6 - 5) = 16$$    
当你将手中的 $s_2 = 1$ 位工兵派往 $p_2 = 1$ 号兵营时，龙方的气势变为：    
$$11 + 1 \times  (5 - 1) = 15$$    
此时可以使双方气势的差距最小。

**数据规模与约定**    


$1 < m < n$，$1 \le p_1 \le n$。   
对于 $20\%$ 的数据，$n = 3,m = 2, c_i = 1, s_1,s_2 ≤ 100$。    
另有 $20\%$ 的数据，$n ≤ 10, p_1 = m, c_i = 1, s_1,s_2 ≤ 100$。  
对于 $60\%$ 的数据，$n ≤ 100, c_i = 1, s_1,s_2 ≤ 100$。   
对于 $80\%$ 的数据，$n ≤ 100, c_i,s_1,s_2 ≤ 100$。  
对于 $100\%$ 的数据，$n≤10^5$,$c_i,s_1,s_2≤10^9$。 

## 样例 #1

### 输入

```
6 
2 3 2 3 2 3 
4 6 5 2 ```

### 输出

```
2```

## 样例 #2

### 输入

```
6 
1 1 1 1 1 16 
5 4 1 1```

### 输出

```
1```

# AI分析结果

---
# 💡 Kay的C++算法解析：龙虎斗 深入学习指南 💡

<introduction>
  今天我们来分析NOIP2018普及组的经典题目《龙虎斗》。这道题像一场“杠杆平衡游戏”——我们需要通过调整兵力，让龙、虎两边的“重量”（势力）尽可能接近。本指南会帮你理清思路、避开坑点，还会用有趣的像素动画让算法“动起来”！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（预处理优化 + 枚举）

🗣️ **初步分析**：
> 解决《龙虎斗》的关键，就像玩“杠杆平衡”：把m号兵营当支点，左边龙势力的“重量”是各兵营工兵数×到m的距离之和，右边虎势力同理。我们的目标是把s₂个工兵加到某个位置，让杠杆两边尽可能平衡。  
> 这里的核心技巧是**预处理**——先算出初始势力（不加s₂时的龙、虎势力），再枚举每个可能的p₂时，只需要计算s₂带来的势力变化，不用重新算所有兵营！这样能把时间复杂度从O(n²)降到O(n)，避免超时。  
> 题目难点有两个：① 数据太大（比如1e5个兵营，每个工兵数1e9），必须用`long long`防止溢出；② 枚举时要快速计算势力变化，不能重复劳动。  
> 可视化设计思路：我们会做一个**8位像素杠杆动画**——用FC风格的杠杆（左边龙、右边虎，中间m是支点），初始时显示两边的势力值；天降s₁到p₁时，杠杆会“倾斜”；枚举p₂时，s₂加到不同位置，杠杆动态调整，用颜色高亮当前最优位置，还会有“叮”的音效提示关键操作！

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码简洁度、坑点提醒等方面，选了3份超棒的题解，帮你快速掌握关键！
</eval_intro>

**题解一：逐步优化的暴力→O(n)算法（作者：wxy_god）**
* **点评**：这份题解像“解题日志”，完美展示了从“暴力超时”到“AC”的过程——一开始用O(n²)暴力枚举（每次重新算势力），发现超时后改成预处理初始势力，再枚举时只算s₂的变化；最后还用方程法直接算出最优位置！作者特别提醒了“开long long”的坑（否则后5个点WA），这种“踩坑→解决”的思路特别适合学习。

**题解二：数学推导的最短代码（作者：ykuouzf）**
* **点评**：这题解的代码超短！作者用数学推导把问题转化为“解方程”：假设势力差为0，算出p₂的理论值，再处理边界和小数情况（比如四舍五入）。这种“用数学简化问题”的思路很巧妙，代码里的`ans=m+int(sum*1.0/k+0.5*(sum>0?1:-1))`一句话就搞定了最优位置，超高效！

**题解三：杠杆原理与坑点提醒（作者：liyuyao666）**
* **点评**：作者把题目比作“杠杆”，瞬间让抽象的势力计算变直观！还特别提醒了两个坑：① 必须用long long（否则丢20分）；② 多个最优解要取最小编号（比如样例中要选1而不是2）。这种“用生活比喻+坑点预警”的方式，能帮你避开很多考试中的“雷区”。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要藏在“优化”和“细节”里。结合优质题解，我帮你提炼了3个核心难点和解决办法：
</difficulty_intro>

1.  **难点1：如何避免重复计算势力？**
    * **分析**：暴力法每次枚举p₂都重新算所有兵营的势力，时间复杂度O(n²)，对于n=1e5来说肯定超时。优质题解的做法是**预处理初始势力**——先算好加s₁后的龙势力sum₁（左边所有兵营的气势和）和虎势力sum₂（右边所有兵营的气势和），枚举p₂时只需要计算s₂带来的变化：如果p₂在左边，sum₁ += s₂×(m-p₂)；如果在右边，sum₂ += s₂×(p₂-m)；如果在m，不影响。
    * 💡 **学习笔记**：预处理是“避免重复劳动”的神器！遇到需要多次计算的问题，先算好“基础值”，再算“变化量”。

2.  **难点2：数据太大导致溢出怎么办？**
    * **分析**：题目中c_i、s₁、s₂都能达到1e9，n是1e5，所以sum₁和sum₂的最大值是1e9×1e5=1e14，远超int的范围（int最多到2e9）。所有优质题解都用了`long long`（能存到9e18），否则会“溢出错误”。
    * 💡 **学习笔记**：遇到大数计算，第一反应是开`long long`！（记牢：十年OI一场空，不开long long见祖宗）

3.  **难点3：多个最优解如何取最小编号？**
    * **分析**：题目要求“如果有多个p₂使势力差最小，取编号最小的”。比如样例中可能有两个位置都能达到最小差，这时候要选更小的那个。解决办法是**枚举时从1到n遍历**，只有当当前势力差严格小于之前的最小值时，才更新答案（这样前面的小编号会优先保留）。
    * 💡 **学习笔记**：枚举顺序很重要！要按编号从小到大遍历，保证最小编号优先。

### ✨ 解题技巧总结
- **预处理优化**：先算基础值，再算变化量，避免重复计算。
- **大数处理**：用`long long`存大数值，防止溢出。
- **枚举顺序**：按编号从小到大遍历，保证最小编号优先。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的O(n)实现**，它包含了所有关键步骤，逻辑清晰！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了wxy_god和liyuyao666的思路，预处理初始势力，枚举p₂时快速计算变化，保证正确性和效率。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cmath>
    using namespace std;

    typedef long long ll; // 用typedef简化long long的写法

    const int MAXN = 1e5 + 5;
    ll c[MAXN]; // 每个兵营的工兵数

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr); // 加速输入输出

        int n, m, p1;
        ll s1, s2;
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            cin >> c[i];
        }
        cin >> m >> p1 >> s1 >> s2;

        // 第一步：加上天降的s1个工兵
        c[p1] += s1;

        // 第二步：预处理初始势力sum1（龙）和sum2（虎）
        ll sum1 = 0, sum2 = 0;
        for (int i = 1; i < m; ++i) {
            sum1 += c[i] * (m - i); // 龙势力：左边兵营的气势和
        }
        for (int i = m + 1; i <= n; ++i) {
            sum2 += c[i] * (i - m); // 虎势力：右边兵营的气势和
        }

        // 第三步：枚举所有可能的p2，找最小势力差
        ll min_diff = 1e18; // 初始最小差设为很大的数
        int ans_p2 = m; // 初始答案设为m（不影响势力）
        for (int i = 1; i <= n; ++i) {
            ll current_sum1 = sum1;
            ll current_sum2 = sum2;
            if (i < m) {
                current_sum1 += s2 * (m - i); // p2在左边，龙势力增加
            } else if (i > m) {
                current_sum2 += s2 * (i - m); // p2在右边，虎势力增加
            }
            // 计算当前势力差的绝对值
            ll diff = abs(current_sum1 - current_sum2);
            // 如果当前差更小，或者差相等但编号更小（这里因为枚举顺序是1到n，所以不用额外判断）
            if (diff < min_diff) {
                min_diff = diff;
                ans_p2 = i;
            }
        }

        cout << ans_p2 << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：① 处理天降的s₁个工兵；② 预处理龙、虎的初始势力；③ 枚举每个p₂，计算加上s₂后的势力差，找最小的那个。关键是用`long long`存大数值，用预处理避免重复计算。

---
<code_intro_selected>
再看两个优质题解的核心片段，学习它们的亮点！
</code_intro_selected>

**题解二（作者：ykuouzf）：数学推导的核心片段**
* **亮点**：用方程直接算出最优p₂，不用枚举！
* **核心代码片段**：
    ```cpp
    ll sum = 0;
    for (int i = 1; i <= n; ++i) {
        sum += a[i] * (m - i); // sum = 龙势力 - 虎势力（因为右边的项是负的）
    }
    sum += s1 * (m - p1); // 加上s1的影响
    ans = m + int(sum * 1.0 / s2 + 0.5 * (sum > 0 ? 1 : -1)); // 四舍五入求最优位置
    ans = max(1LL, min((ll)n, ans)); // 处理边界
    ```
* **代码解读**：
    > 作者把问题转化为“让龙势力 - 虎势力 + s₂×(m-p₂) = 0”（因为p₂在左边时，龙势力增加s₂×(m-p₂)；右边时，虎势力增加s₂×(p₂-m)，等价于龙势力减少s₂×(p₂-m)，所以总和是sum + s₂×(m-p₂)）。解方程得p₂ = m + sum/s₂，然后四舍五入取整，再处理边界（不能小于1或大于n）。这种方法不用枚举，速度更快！
* 💡 **学习笔记**：数学推导能简化问题，遇到“找最优位置”的问题，可以试试建立方程。

**题解三（作者：liyuyao666）：坑点处理的核心片段**
* **亮点**：处理“多个最优解取最小编号”的问题。
* **核心代码片段**：
    ```cpp
    long long ans = m, MIN = abs(a - b); // 初始答案设为m
    for (long long i = 1; i < m; ++i) {
        ll set = abs(a + peo[i].b * s3 - b);
        if (set < MIN || (set == MIN && ans == m)) { // 差更小，或者差相等但当前是初始的m（即第一次遇到相等的情况）
            MIN = set;
            ans = i;
        }
    }
    ```
* **代码解读**：
    > 作者初始答案设为m，枚举左边时，如果当前差等于最小值且ans还是m（说明之前没遇到更小的），就更新ans为i（更小的编号）。这样保证了多个最优解时取最小编号。
* 💡 **学习笔记**：处理“多解取最小”的问题，初始答案设为较大的数，枚举时优先更新更小的编号。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地理解“杠杆平衡”的过程，我设计了一个**8位像素风格的动画**——像玩FC游戏一样，看杠杆怎么“倾斜”，s₂加到哪里能让它平衡！
</visualization_intro>

### 动画演示主题：像素杠杆的平衡游戏
- **风格**：FC红白机风格，用8位像素块、16色调色板（比如龙用红色，虎用黄色，支点m用蓝色）。
- **场景**：屏幕中间是一根杠杆，左边是龙的势力条（红色），右边是虎的势力条（黄色），中间蓝色点是支点m。顶部显示当前的s₁、s₂、p₁等参数。

### 动画帧步骤与交互关键点
1. **初始化**：
   - 杠杆左边显示龙的初始势力sum₁（红色块长度），右边显示虎的初始势力sum₂（黄色块长度）。
   - 控制面板有“开始”“单步”“重置”按钮，速度滑块（控制动画快慢）。
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。

2. **天降神兵s₁**：
   - p₁位置的兵营会闪烁，然后“跳”出s₁个像素工兵（小方块），加到p₁的位置。
   - 杠杆左边或右边的势力条会变长（比如p₁在左边，红色条变长），杠杆“倾斜”（比如红色条更长，杠杆向左下倾斜）。
   - 播放“叮咚”的音效，表示s₁已加入。

3. **枚举p₂的过程**：
   - 鼠标 hover 到某个兵营时，该兵营会高亮（比如变橙色），旁边显示“加到这里会增加XX势力”。
   - 点击“单步”按钮，s₂会“飞到”当前选中的p₂位置，势力条实时更新，杠杆调整倾斜度。
   - 如果当前p₂是最优解，杠杆会“闪烁”（比如边框变绿色），并播放“叮”的音效。
   - 点击“自动播放”，s₂会依次加到每个p₂位置，杠杆动态调整，最终停在最优位置，播放“胜利”音效（比如《魂斗罗》的通关音乐）。

4. **边界处理演示**：
   - 如果p₂小于1，会弹出提示“不能加到左边之外！”，并自动调整到1；如果大于n，调整到n。
   - 多个最优解时，动画会优先显示编号最小的p₂（比如1号兵营会比2号先高亮）。

### 为什么这样设计？
- **像素风格**：复古游戏感能降低学习的“距离感”，让算法更亲切。
- **杠杆动画**：把抽象的势力计算转化为直观的“倾斜”，一眼就能看出哪边势力大。
- **音效与交互**：“叮咚”“叮”的音效能强化关键操作的记忆，单步/自动播放让你能控制学习节奏。

<visualization_conclusion>
通过这个动画，你能“看”到每一步势力的变化，再也不用死记硬背公式啦！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
《龙虎斗》的核心技巧（预处理+枚举+大数处理）能解决很多类似问题，比如“调整某个值让总和最优”“避免重复计算”的问题。
</similar_problems_intro>

### 通用思路迁移
- **预处理优化**：比如求“数组中每个元素的前缀和”，然后快速计算区间和（比如洛谷P1115最大子段和）。
- **大数处理**：比如求“大数的阶乘”“大数加法”（比如洛谷P1009阶乘之和）。
- **枚举找最优**：比如“找一个数，让它和数组中元素的差之和最小”（比如洛谷P1047校门外的树）。

### 练习推荐 (洛谷)
1. **洛谷 P1002 过河卒**
   - 🗣️ **推荐理由**：这题需要预处理每个位置的可达性，避免重复计算，和《龙虎斗》的预处理思路一致。
2. **洛谷 P1115 最大子段和**
   - 🗣️ **推荐理由**：这题用前缀和快速计算子段和，锻炼“预处理+找最优”的能力。
3. **洛谷 P1226 快速幂**
   - 🗣️ **推荐理由**：这题需要处理大数的幂运算，锻炼`long long`的使用和优化意识。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“踩坑经验”是最宝贵的！比如：
</insights_intro>

> **参考经验 (来自wxy_god)**：“我一开始用暴力法，结果超时了；后来改成预处理，又因为没开long long WA了5个点。”
>
> **点评**：这位作者的经历太典型了！暴力法虽然直观，但容易超时；预处理能优化时间，但要注意数据范围。遇到大数一定要开`long long`，否则会“竹篮打水一场空”。

> **参考经验 (来自liyuyao666)**：“有一组数据需要取最小编号，我一开始没注意，结果输出了2而不是1。”
>
> **点评**：题目中的“细节条件”（比如多解取最小）很容易被忽略，一定要仔细读题！枚举时按编号从小到大遍历，能自动解决这个问题。

---

<conclusion>
《龙虎斗》是一道“看似暴力，实则需要优化”的经典题。通过预处理、大数处理和细节注意，你能轻松AC！记住：编程的关键不是“写得多”，而是“写得巧”——用预处理避免重复劳动，用`long long`处理大数，用枚举顺序解决多解问题。下次遇到类似的“平衡游戏”，你一定能快速解决！💪
</conclusion>

---

---
处理用时：139.42秒
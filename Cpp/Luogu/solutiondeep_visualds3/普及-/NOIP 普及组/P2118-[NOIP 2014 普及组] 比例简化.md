# 题目信息

# [NOIP 2014 普及组] 比例简化

## 题目背景

NOIP2014 普及组 T2

## 题目描述

在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有 $1498$ 人，反对的有 $902$ 人，那么赞同与反对的比例可以简单的记为 $1498:902$。

不过，如果把调查结果就以这种方式呈现出来，大多数人肯定不会满意。因为这个比例的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为 $5:3$，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。

现给出支持人数 $A$，反对人数 $B$，以及一个上限 $L$，请你将 $A$ 比 $B$ 化简为 $A'$ 比 $B'$，要求在 $A'$ 和 $B'$ 均不大于 $L$ 且 $A'$ 和 $B'$ 互质（两个整数的最大公约数是 $1$）的前提下，$\dfrac{A'}{B'} \ge  \dfrac{A}{B}$ 且 $\dfrac{A'}{B'} - \dfrac{A}{B}$ 的值尽可能小。

## 说明/提示

对于 $100\%$ 的数据，$1 \le A \le 10^6,1 \le B \le 10^6,1 \le L \le 100,\dfrac{A}{B} \le L$。


## 样例 #1

### 输入

```
1498 902 10```

### 输出

```
5 3```

# AI分析结果


# 💡 Kay的C++算法解析：比例简化 深入学习指南 💡

> 今天我们来一起分析"比例简化"这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举与数学技巧应用`

🗣️ **初步分析**：
> 解决"比例简化"这道题，关键在于**暴力枚举所有可能分数**。就像在100×100的糖果网格中寻找最甜的那颗糖——我们遍历所有可能的分子/分母组合（1到L），用三个条件筛选最优解：  
> 1. 分子分母互质（最大公约数为1）  
> 2. 新比例≥原比例（A'/B' ≥ A/B）  
> 3. 新比例最接近原比例  
>  
> **核心难点**在于避免浮点精度误差——优质题解用"交叉乘法"（i*b ≥ j*a）代替除法比较。在可视化中，我们将用像素网格动态演示枚举过程，高亮关键比较步骤，并给互质分数添加金色边框。采用复古游戏音效：选中格子时播放"滴答"声，找到更优解时播放"升级"音效。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法效率等维度，我为大家精选了3份优质题解：
</eval_intro>

**题解一 (来源：以墨)**
* **点评**：思路清晰直白，完整演示了枚举法的三个关键条件。亮点在于：
  - 用递归实现辗转相除法判断互质，逻辑严谨
  - 全程使用交叉乘法（i*b≥j*a）避免浮点误差
  - 变量命名简洁（ansa/ansb），边界处理完备
  - 代码可直接用于竞赛，实践价值高

**题解二 (来源：Actinoi)**
* **点评**：在清晰度上表现优异，特色在于：
  - 使用STL的`__gcd`函数简化互质判断
  - 通过交叉乘法(i*s2<j*s1)高效比较分数大小
  - 代码结构紧凑，适合初学者学习
  - 题解附带数学公式推导，加深理解

**题解三 (来源：封禁用户)**
* **点评**：基础实现完整，亮点在于：
  - 手写gcd函数展示算法原理
  - 完整包含头文件和IO流处理
  - 浮点比较差值虽有小瑕疵，但添加(double)强转提升精度
  - 适合帮助理解问题本质

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决比例简化的三大关键难点及应对策略：
</difficulty_intro>

1.  **难点：浮点精度陷阱**
    * **分析**：直接比较浮点数(i/j≥a/b)可能导致精度误差。优质题解采用**交叉乘法**将分数比较转化为整数运算(i*b≥j*a)，彻底规避精度问题。例如比较5/3和1498/902时，计算5*902=4510和3*1498=4494，因4510>4494判定成立。
    * 💡 **学习笔记**：分数比较要优先考虑整数运算

2.  **难点：互质判断优化**
    * **分析**：题目要求分子分母互质（gcd=1）。虽然不判断互质可能得到相同分值的解，但会违反题目要求。高效方案：
      - 小范围(L≤100)可直接使用`gcd(i,j)==1`
      - 大范围可预处理质数表
    * 💡 **学习笔记**：互质是分数化简的刚性要求

3.  **难点：最优解更新条件**
    * **分析**：在满足A'/B'≥A/B的解中，需找到最接近原比例的解。数学本质是：在可行解中找最小分值的分数。通过交叉乘法实现：`i*ansB < j*ansA` 判断新解是否更优。
    * 💡 **学习笔记**：将"最接近"转化为"找最小可行分数值"

### ✨ 解题技巧总结
<summary_best_practices>
提炼三大实用技巧帮助大家举一反三：
</summary_best_practices>
- **整数替代浮点**：所有比较通过交叉乘法转为整数运算
- **逆向初始化**：最优解初始化为最大可能值(L/1)，确保首次比较必更新
- **小范围枚举**：当数据范围小(L≤100)时，O(n²)完全可接受

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个融合优质题解思路的完整实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合优质题解优点，包含递归gcd实现和交叉乘法比较
* **完整核心代码**：
```cpp
#include <iostream>
using namespace std;

int gcd(int x, int y) {  // 辗转相除法求最大公约数
    return y ? gcd(y, x % y) : x;
}

int main() {
    int a, b, l;
    cin >> a >> b >> l;
    
    // 初始化解为最大比例L:1
    int ansA = l, ansB = 1; 
    
    for (int i = 1; i <= l; i++) {       // 枚举分子
        for (int j = 1; j <= l; j++) {   // 枚举分母
            bool isCoprime = (gcd(i, j) == 1);      // 条件1:互质
            bool validRatio = (i * b >= j * a);     // 条件2:新比例≥原比例
            bool betterSolution = (i * ansB < j * ansA); // 条件3:更优解
            
            if (isCoprime && validRatio && betterSolution) {
                ansA = i;
                ansB = j;
            }
        }
    }
    cout << ansA << " " << ansB;
    return 0;
}
```
* **代码解读概要**：
  > 1. **gcd函数**：递归实现辗转相除，确保分数互质  
  > 2. **双重循环**：枚举所有可能的分子分母组合  
  > 3. **三条件过滤**：先检查互质，再验证比例，最后更新最优解  
  > 4. **交叉乘法**：用i*b≥j*a避免浮点运算  

---
<code_intro_selected>
优质题解的核心代码亮点解析：
</code_intro_selected>

**题解一：(来源：以墨)**
* **亮点**：递归gcd+三重条件紧凑判断
* **核心代码片段**：
```cpp
if(gcd(i,j)==1&&i*b>=j*a&&i*ansb<j*ansa)
{
    ansa=i;
    ansb=j;
}
```
* **代码解读**：
  > - `gcd(i,j)==1`：确保分子分母互质  
  > - `i*b>=j*a`：交叉乘法实现比例比较  
  > - `i*ansb<j*ansa`：通过交叉乘判断新解是否更接近原比例  
  > 三个条件像三道关卡，只有全部通过才更新最优解

**题解二：(来源：Actinoi)**
* **亮点**：使用STL的__gcd函数
* **核心代码片段**：
```cpp
if (__gcd(i, j)==1 && a*j<=b*i && i*s2<j*s1)
{
    s1=i;
    s2=j;
}
```
* **代码解读**：
  > - `__gcd(i,j)`：GCC内置函数，简化代码  
  > - `a*j<=b*i`：原比例比较的变形写法（等价于i/b≥a/b）  
  > - 变量命名`s1/s2`代替`ansA/ansB`，体现不同风格

**题解三：(来源：封禁用户)**
* **亮点**：完整包含标准输入输出
* **核心代码片段**：
```cpp
if (gcd(i, j) == 1) 
{
    double newRatio = (double)i/j;
    if(newRatio >= targetRatio && newRatio - targetRatio < minDiff)
    {
        minDiff = newRatio - targetRatio;
        ansA = i; ansB = j;
    }
}
```
* **代码解读**：
  > - 显式转换`(double)`：降低精度风险  
  > - 分步比较：先检查比例条件，再比较差值  
  > - 适合帮助理解问题本质，但实际应用建议整数方案

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
下面用8位像素游戏风格演示算法执行过程，就像在复古游戏中收集宝藏！  
**主题**：《比例猎人》在L×L网格中寻找黄金比例  
**核心机制**：遍历网格寻找满足三条件的黄金分数
</visualization_intro>

### 动画设计说明
* **视觉设计**：
  - 16色复古调色板，仿FC游戏机风格
  - 网格单元格：100×100像素（L≤100）
  - 分子i=行号，分母j=列号
  - 互质分数：金色边框
  - 当前选中格：闪烁黄色边框
  - 最优解：旋转星标动画

* **交互逻辑**：
  ```mermaid
  graph TD
    A[初始化网格] --> B[选中当前格子 i,j]
    B --> C{是否互质?}
    C --否--> D[显示红叉标记]
    C --是--> E{是否 i*b≥j*a?}
    E --否--> D
    E --是--> F{是否更优解?}
    F --否--> G[显示银星标记]
    F --是--> H[更新最优解<br>播放升级音效]
    H --> I[下一格子]
    G --> I
    D --> I
  ```

* **音效设计**：
  - 移动选择："滴答"声（8-bit短音）
  - 互质分数："金币"声
  - 发现更优解："升级"声（上升音阶）
  - 完成搜索："胜利"旋律

* **关键帧示例**：
  ```
  帧1: [初始状态]
    ├─ 网格线：深灰色
    ├─ (L,1)位置：红星标记（初始解）
    └─ 当前选中(1,1)：黄色闪烁框
  
  帧2: [检查互质]
    ├─ 计算gcd(1,1)=1 → 显示金色边框
    ├─ 计算1*b vs 1*a → 显示绿色对勾
    ├─ 与初始解比较 → 显示更优解
    └─ 播放升级音效，红星移至(1,1)

  帧3: [遇到非互质]
    ├─ 选中(2,2)
    ├─ gcd(2,2)=2≠1 → 显示红叉
    └─ 跳过后续判断
  ```

<visualization_conclusion>
通过像素化动态演示，我们能直观看到算法如何像游戏寻宝一样，在网格中筛选出满足三重条件的黄金比例！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握比例简化后，可尝试以下相似思路的题目：
</similar_problems_intro>

* **通用技巧迁移**：
  - 小范围枚举思想适用于：数位分解、分数逼近、矩阵遍历
  - 交叉乘法技巧可用于：分数排序、比例验证、不等式比较
  - 互质判断常见于：最简真分数、欧拉函数、RSA加密

* **洛谷题目推荐**：
  1. **P1062 数列**  
     🗣️ 通过枚举二进制位理解特殊数列构造，巩固整数运算
  2. **P1147 连续自然数和**  
     🗣️ 练习双重循环找连续区间，训练枚举优化技巧
  3. **P1217 回文质数**  
     🗣️ 结合枚举与数学判断，强化质数验证能力

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的调试经验尤其珍贵：
</insights_intro>

> **以墨的调试经验**：  
> *"最初忘记处理比例相等的情况，通过打印变量发现当i*b==j*a时未更新解"*  
>  
> **Kay点评**：  
> 这个案例提醒我们：边界条件测试（如相等情况）至关重要。调试时可在循环内添加临时输出：
> ```cpp
> printf("i=%d j=%d 比值=%.3f 状态=%d\n", 
>        i, j, (double)i/j, (i*b>=j*a));
> ```

---

本次关于"比例简化"的解析就到这里。记住：编程能力=理解×实践×反思。下次挑战再见！🚀

---
处理用时：358.51秒
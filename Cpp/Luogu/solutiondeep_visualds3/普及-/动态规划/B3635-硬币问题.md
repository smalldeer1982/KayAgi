# 题目信息

# 硬币问题

## 题目描述

今有面值为 1、5、11 元的硬币各无限枚。

想要凑出 $n$ 元，问需要的最少硬币数量。

## 说明/提示

#### 样例解释

对于样例数据 1，最佳方案是 $15=5+5+5$，使用到 3 枚硬币。

对于样例数据 2，最佳方案是 $12=11 + 1$，使用到 2 枚硬币。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $n\leq 10^6$。

## 样例 #1

### 输入

```
15```

### 输出

```
3```

## 样例 #2

### 输入

```
12```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：硬币问题 深入学习指南 💡

<introduction>
今天我们来一起分析“硬币问题”这道经典的C++编程题。这道题看似简单，却藏着动态规划的核心思想。本指南将帮助大家理解为什么贪心算法在这里会失效，掌握动态规划的解题思路，以及如何用代码实现最优解。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划(DP)

🗣️ **初步分析**：
> 解决“硬币问题”的关键在于理解并运用**动态规划(DP)**。简单来说，动态规划就像我们解谜时，先把小谜题一个个解开，再用这些小答案拼凑出大谜题的解。在本题中，要凑出n元的最少硬币数，我们可以先解决“凑出n-1元、n-5元、n-11元需要多少硬币”这些小问题，再从中选出最优解。

   - **题解思路**：用一个数组`f`记录“凑出i元需要的最少硬币数”，从0元开始逐步计算到n元。对于每个i，`f[i]`等于`f[i-1]+1`、`f[i-5]+1`、`f[i-11]+1`中的最小值（前提是i-1、i-5、i-11≥0）。
   - **核心难点**：很多同学会先想到“贪心算法”（优先用大硬币），但这道题中贪心会出错（比如15元：贪心11+1+1+1需要4枚，而最优5+5+5只需3枚）。动态规划通过枚举所有可能的最后一步（加1元、加5元、加11元），确保找到全局最优解。
   - **可视化设计思路**：我们可以设计一个“像素化表格填充”动画，每一行代表i的值，每一列显示`f[i]`的计算过程。当计算`f[i]`时，会从i-1、i-5、i-11三个位置“拉取”数值，高亮这三个位置并显示取最小值的过程，最后更新`f[i]`的像素块颜色。
   - **复古游戏化元素**：动画采用FC红白机风格，主角是一个“硬币小精灵”，每计算完一个`f[i]`，小精灵就会在表格对应的格子上盖一个印章，成功计算时播放“叮”的音效，全部计算完成后播放胜利音乐，就像通关了一个小游戏！

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我筛选了以下评分较高（5星）的优质题解，它在思路清晰度、算法有效性和启发性方面表现突出。
</eval_intro>

**题解一：(来源：ShanCreeperPro)**
* **点评**：这份题解堪称动态规划入门的典范！它首先通过反例（15元的贪心错误）清晰地否定了贪心算法，让读者明白为什么需要动态规划。接着用“小问题的解求大问题的解”这一直白逻辑，引出DP的核心思想。题解中设计的表格法（n从0到15的`f(n)`值）非常直观，让初学者能通过具体数字理解状态转移的过程。特别值得称赞的是，它强调了“越界处理”这一边界条件，以及时间复杂度O(n)的分析，既严谨又实用。作者将DP比喻为“填表格”，这种生活化的类比非常适合初学者理解抽象概念。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决硬币问题时，我们常常会在思路选择、状态定义和边界处理上遇到困惑。结合优质题解的思路，我为大家提炼了三个核心关键点及应对策略：
</difficulty_intro>

1.  **关键点1**：为什么贪心算法在此题中失效？
    * **分析**：贪心算法的逻辑是“每次选最大面额的硬币”，但这只在特定硬币体系下成立（如我国的人民币体系）。本题中1、5、11的组合不满足“贪心选择性质”——例如15元用11元+1元×4需要5枚，而5元×3只需3枚。优质题解通过具体反例让我们直观看到贪心的局限性，从而理解动态规划“枚举所有可能最后一步”的必要性。
    * 💡 **学习笔记**：遇到“最少/最多”类问题时，先别急着用贪心，要先判断问题是否满足“局部最优能推出全局最优”。

2.  **关键点2**：如何定义动态规划的状态？
    * **分析**：状态定义是DP的灵魂。题解中定义`f[i]`为“凑出i元需要的最少硬币数”，这个定义简洁且包含了问题的核心——“金额i”和“最少硬币数”。状态定义需要满足两个条件：能唯一表示子问题，且子问题之间有递推关系。这里`f[i]`恰好满足：要计算`f[i]`，只需知道`f[i-1]`、`f[i-5]`、`f[i-11]`（即比i小的子问题）。
    * 💡 **学习笔记**：设计DP状态时，先问自己：“要求解的问题是什么？它可以由哪些更小的问题组成？”

3.  **关键点3**：如何处理状态转移中的边界条件？
    * **分析**：当i<5时，`i-5`为负数（如i=3时，i-5=-2），此时不能用5元硬币，所以转移方程中只需考虑`f[i-1]+1`。同理，i<11时，不考虑11元硬币。题解提醒我们“注意越界”，实际代码中可以通过条件判断（if i>=5则考虑f[i-5]，否则忽略）来处理。初始状态`f[0]=0`（0元需要0枚硬币）也至关重要，它是所有子问题的起点。
    * 💡 **学习笔记**：DP的边界条件包括“初始状态”和“无效子问题”（如负数金额），处理不好会导致数组越界或结果错误。

### ✨ 解题技巧总结
<summary_best_practices>
通过解决硬币问题，我们可以总结出动态规划解题的通用技巧：
</summary_best_practices>
-   **技巧A (问题拆解)**：将原问题拆成规模更小的子问题，确保子问题的解能推出原问题的解（如n元拆成n-1、n-5、n-11元）。
-   **技巧B (状态表格化)**：用数组或表格存储子问题的解，避免重复计算（`f`数组就是一张记录所有金额最少硬币数的表格）。
-   **技巧C (从基础出发)**：先初始化最小子问题的解（如`f[0]=0`），再从小到大依次计算更大子问题的解（从i=1循环到n）。
-   **技巧D (边界检查)**：计算子问题时，确保不会访问无效的数组索引（如i-5≥0才能用5元硬币）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析题解的核心片段前，我们先来看一个完整的C++实现。这份代码综合了题解的思路，清晰展示了动态规划如何解决硬币问题。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码基于ShanCreeperPro题解的动态规划思路实现，包含完整的输入、DP数组计算和输出逻辑，时间复杂度O(n)，空间复杂度O(n)，可直接处理n≤1e6的数据规模。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <climits>  // 用于INT_MAX

    using namespace std;

    int main() {
        int n;
        cin >> n;

        // f[i]表示凑出i元需要的最少硬币数
        vector<int> f(n + 1, INT_MAX);  // 初始化为一个很大的数（表示无法凑出）
        f[0] = 0;  // 边界条件：0元需要0枚硬币

        for (int i = 1; i <= n; ++i) {
            // 尝试最后一步加1元硬币
            if (i >= 1 && f[i - 1] != INT_MAX) {
                f[i] = min(f[i], f[i - 1] + 1);
            }
            // 尝试最后一步加5元硬币
            if (i >= 5 && f[i - 5] != INT_MAX) {
                f[i] = min(f[i], f[i - 5] + 1);
            }
            // 尝试最后一步加11元硬币
            if (i >= 11 && f[i - 11] != INT_MAX) {
                f[i] = min(f[i], f[i - 11] + 1);
            }
        }

        cout << f[n] << endl;

        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取目标金额n，然后创建一个`f`数组，大小为n+1（因为要存储0到n的所有金额）。初始化`f[0]=0`（0元需要0枚硬币），其余元素为`INT_MAX`（表示初始时认为这些金额无法凑出）。接着从1到n循环，对每个i，分别检查是否可以通过加1元、5元或11元硬币凑出i元，即查看`f[i-1]`、`f[i-5]`、`f[i-11]`是否有效（不是`INT_MAX`），并取这三种情况的最小值加1作为`f[i]`的值。最后输出`f[n]`，即凑出n元的最少硬币数。

---
<code_intro_selected>
接下来，我们重点剖析题解中动态规划的核心实现逻辑，理解状态转移的关键代码。
</code_intro_selected>

**题解一：(来源：ShanCreeperPro)**
* **亮点**：通过表格法直观展示状态转移过程，清晰处理了子问题依赖关系，并用简洁的逻辑实现了动态规划的核心思想。
* **核心代码片段**：
    ```cpp
    // 核心逻辑：计算f[i]的状态转移部分
    for (int i = 1; i <= n; ++i) {
        // 取三种可能的最后一步的最小值
        f[i] = min(f[i-1], f[i-5], f[i-11]) + 1;
        // （注：实际代码需处理i-5和i-11可能小于0的情况）
    }
    ```
* **代码解读**：
    > 这段伪代码展示了动态规划的核心——状态转移方程。为什么要加1呢？因为`f[i-1]`是凑出i-1元的最少硬币数，在它的基础上“加1枚1元硬币”就能凑出i元，所以总硬币数是`f[i-1]+1`。同理，`f[i-5]+1`和`f[i-11]+1`分别对应“加1枚5元”和“加1枚11元”的情况。我们要从这三种情况中选最小的，就是凑出i元的最优解。
    > 
    > 思考一下：如果i=3，那么i-5=-2，这时候还能选5元硬币吗？当然不行！所以实际代码中需要像通用实现那样，用`if (i >= 5)`判断，避免访问负数索引。这就是题解中强调的“注意越界”的具体实现。
* 💡 **学习笔记**：动态规划的状态转移方程是“用子问题的解表示当前问题的解”的数学形式，理解每个项的含义（比如这里的“+1”代表新增一枚硬币）是掌握DP的关键。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解动态规划“填表格”的过程，我设计了一个8位像素风格的“硬币收藏家”动画演示方案，让我们像玩复古游戏一样观察算法的每一步！
</visualization_intro>

  * **动画演示主题**：“像素硬币收藏家”——在FC风格的表格中，小像素人逐步计算每个金额的最少硬币数，最终通关获得“金币奖杯”。

  * **核心演示内容**：动态规划数组`f`从`f[0]`到`f[n]`的填充过程，重点展示`f[i]`如何通过`f[i-1]`、`f[i-5]`、`f[i-11]`计算得出，以及贪心算法与DP算法的结果对比。

  * **设计思路简述**：采用8位像素风（类似《超级马里奥》的画面）能让抽象的算法变得生动有趣；“小像素人”的移动和操作模拟了我们手动计算的过程，帮助理解“从小到大解决子问题”的DP思想；音效和“通关”设计则增加了学习的成就感，让算法学习不再枯燥。

  * **动画帧步骤与交互关键点 (融合复古游戏元素)**：

    1.  **场景与UI初始化 (8位像素风)**：
          * 屏幕分为三部分：左侧是“控制面板”（红白配色按钮），中间是“DP表格区”（16x16像素的网格，每个格子显示i和f[i]），右侧是“贪心vsDP结果对比区”。
          * 控制面板有：“开始”（绿色像素按钮）、“单步”（黄色）、“重置”（红色）、速度滑块（0-100%）。
          * 背景播放轻快的8位机BGM（类似《俄罗斯方块》的背景音乐）。

    2.  **算法启动与数据初始化**：
          * 点击“开始”后，小像素人（穿着蓝色衣服，戴着金币帽）从表格左上角`f[0]`位置出现，在格子上盖一个“0”的印章，同时播放“初始成功”音效（短促的“叮”声）。`f[0]`的格子变成亮黄色（表示已计算）。

    3.  **核心算法步骤动态演示 (颜色标记+高亮+音效)**：
          * **当前计算高亮**：小像素人移动到当前i的格子（如i=1），格子边框闪烁红色，表示正在计算。
          * **子问题回溯**：小像素人伸出“探测线”（黄色像素线）连接到i-1、i-5、i-11的格子（如果存在）。例如计算i=5时，探测线连接i-1=4（f[4]=4）、i-5=0（f[0]=0），i-11=-6（不显示）。
          * **取最小值过程**：被探测的格子中，数值最小的那个（如i=5时f[0]=0）会闪烁绿色，小像素人走向它并举起“+1”的牌子，然后跳回i=5的格子，写下0+1=1。此时播放“计算成功”音效（清脆的“叮铃”声），i=5的格子变为亮黄色。
          * **贪心对比**：右侧对比区实时显示贪心算法的结果（如i=15时，贪心显示4，DP显示3），错误的贪心结果格子会短暂显示红色“X”。

    4.  **AI自动演示模式**：
          * 选择“自动播放”后，小像素人会加速移动，快速填充表格，像“AI玩家”一样自动通关。速度滑块可调节播放速度，方便观察细节。

    5.  **目标达成/结束状态**：
          * 当计算到f[n]时，小像素人会跳起来欢呼，表格中从f[0]到f[n]的格子连成一条金色路径，播放胜利音乐（类似《超级马里奥》通关音乐），屏幕中央出现“金币奖杯”像素画和“通关！最少硬币数：X”的文字。

    6.  **游戏式关卡设计**：
          * 动画将计算过程分为3个“小关卡”：i=1~10（青铜关）、i=11~50（白银关）、i=51~n（黄金关）。每通过一关，屏幕底部会弹出像素星星奖励，增强学习成就感。

  * **旁白提示 (动画中的文字气泡)**：

      * （开始时）“大家好！我是硬币收藏家，让我们一起用DP表格法找出最少硬币数吧！”
      * （计算i=5时）“看，f[5]可以从f[4]（4枚+1=5枚）或f[0]（0枚+1=1枚）来，选最小的1枚！”
      * （对比贪心时）“贪心算法在这里出错啦！DP才能找到真正的最优解哦~”
      * （通关时）“恭喜！我们成功算出了n元的最少硬币数，DP表格法真好用！”

<visualization_conclusion>
通过这个8位像素风的“硬币收藏家”动画，我们不仅能“亲眼看到”动态规划如何一步步计算出结果，还能在游戏化的体验中理解“子问题”“状态转移”这些抽象概念。希望这个动画能让你对动态规划产生浓厚的兴趣！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
硬币问题是动态规划中“完全背包”问题的简化版（每种物品数量无限）。掌握了这种“从小到大填表格”的思路后，我们可以解决更多类似问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：

      * **动态规划（DP）** 不仅能解决硬币找零问题，还常用于：① 背包问题（如装满背包的最大价值）；② 最长递增子序列（LIS）；③ 爬楼梯问题（每次爬1或2级，求多少种方法）。这些问题的共同特点是：大问题可以拆成小问题，且小问题的解会被重复利用。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与动态规划思想相关的题目，帮助你巩固所学：

    1.  **洛谷 P1048** - 《采药》
          * 🗣️ **推荐理由**：这是经典的01背包问题（每种物品只能选一次），和硬币问题（完全背包）对比学习，可以帮你理解不同背包问题的区别。
    2.  **洛谷 P1616** - 《疯狂的采药》
          * 🗣️ **推荐理由**：这是完全背包问题（每种物品数量无限），与硬币问题的DP思路几乎一致，只是目标从“最少数量”变成了“最大价值”，是很好的举一反三练习。
    3.  **洛谷 P2871** - 《手链》
          * 🗣️ **推荐理由**：这道题需要设计更复杂的DP状态（考虑颜色相邻关系），能锻炼你定义状态和推导转移方程的能力，是DP进阶的好题目。
    4.  **洛谷 P1216** - 《数字三角形》
          * 🗣️ **推荐理由**：这道题直观展示了“从底层向上递推”的DP思路，与硬币问题的“从0向上递推”异曲同工，能帮助你理解DP的多种递推方向。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者ShanCreeperPro分享了动态规划的核心思想和常见误区，这些经验对初学者非常有价值：
</insights_intro>

> **参考经验 (来自ShanCreeperPro)**：“究极无敌典中典之入门dp问题。尝试贪心，尽可能先用大面额，不够再用小面额。但这是错误的……用小问题的解，求大问题的解。这是一个dp的基本思路。”
>
> **点评**：作者的这个经验非常重要！很多同学在接触这类问题时，第一反应都是贪心算法，因为它简单直观。但作者通过具体反例（15元的贪心错误）让我们明白：算法选择不能想当然，必须通过逻辑证明或反例验证。而“用小问题的解求大问题的解”这句话，精准概括了动态规划的本质，值得我们牢记。在今后的学习中，遇到“最优解”问题时，不妨先想想：这个问题能否拆成更小的子问题？子问题的解能否帮助我推出原问题的解？

---

<conclusion>
本次关于“硬币问题”的C++解题分析就到这里。我们不仅学会了用动态规划解决最少硬币问题，还理解了贪心算法的局限性，掌握了DP的核心思想——“拆分子问题，表格存储解”。希望你能通过这个经典问题，打开动态规划的大门，未来解决更复杂的算法挑战！记住，编程就像解谜，每掌握一个算法，你就多了一把解开难题的钥匙。加油！💪
</conclusion>

---

---
处理用时：183.34秒
# 题目信息

# [COCI 2009/2010 #2] KUTEVI

## 题目背景

本题为[$\texttt{COCI 2009-2010}\ 2^\texttt{nd}\ \texttt{round}\ \text{T3 KUTEVI}$](https://hsin.hr/coci/archive/2009_2010/contest2_tasks.pdf)。

分值按原题设置，满分 $70$。

## 题目描述

给定 $N$ 个角（第 $i$ 个角记作 $a_i$），作为初始角，另给定 $M$ 个角（第 $i$ 个角记作 $b_i$），作为目标角。

请求出对于每个 $b_i$，它是否能被若干个 $a_i$ 之间的加、减运算得到。

注意同一个 $a_i$ 可以用多次，也可以不用。

## 说明/提示

### 样例解释

样例 $1$ 解释：

$70^\circ-30^\circ=40^\circ$。

样例 $2$ 解释：

$15\times100^\circ=1500^\circ=60^\circ$。

### 数据范围与约定

$1\leq N,M\leq10$，$0<a_i,b_i< 360$。

## 样例 #1

### 输入

```
2 1
30 70
40```

### 输出

```
YES```

## 样例 #2

### 输入

```
1 1
100
60```

### 输出

```
YES```

## 样例 #3

### 输入

```
3 2
10 20 30
5 70```

### 输出

```
NO
YES```

# AI分析结果

# 💡 Kay的C++算法解析：KUTEVI 深入学习指南 💡

<introduction>
  今天我们来一起分析COCI 2009/2010赛季的经典题目——KUTEVI（角度组合问题）。这道题需要我们判断“目标角能否用初始角通过加减运算得到”，核心是利用**数论性质**或**动态规划/搜索**解决“可行性问题”。本指南会帮你梳理思路、理解核心算法，并掌握解题技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论gcd）、动态规划（完全背包）、搜索（BFS/DFS）

🗣️ **初步分析**：
> 解决这道题的关键，在于理解**角度的模360特性**和**线性组合的数学本质**。简单来说：  
> - 角度是“循环的”——比如1500°=1500-4×360=60°，所以所有角度都可以映射到0~359°的范围内。  
> - 初始角的“加减组合”等价于**整数线性组合**（比如a₁×k₁ ± a₂×k₂ ± ...，k为非负整数）。根据数论定理：**所有线性组合的结果模360后，一定是初始角的最大公约数（gcd）的倍数**！  

举个例子：样例2中初始角是100°，它的gcd是100。100的倍数模360包括100、200、300、40（400%360）、140（500%360）……直到1500%360=60°（目标角）——所以答案是YES！

### 核心算法对比
- **数论法（最优）**：计算初始角的gcd，直接判断目标角是否是gcd的倍数模360（时间复杂度O(n+360)）。  
- **完全背包**：将问题转化为“用无限个初始角组合出目标角”，状态`dp[j]`表示能否达到角度j（时间复杂度O(n×K)，K是枚举的最大角度）。  
- **BFS/DFS**：遍历所有可达的角度状态，标记“能组合出的角度”（时间复杂度O(360×n)）。

### 可视化设计思路
我们选择**BFS搜索**做像素动画演示——因为它能直观展示“状态扩展”的过程：  
- 用8位像素网格表示0~359°的角度（每个格子对应一个角度）；  
- 起点0°用红色高亮，初始角用蓝色标记；  
- 每次扩展时，用绿色点亮“新可达的角度”，并播放“嗒”的像素音效；  
- 找到目标角时，目标格闪烁黄色，播放“叮咚”的胜利音效！


## 2. 精选优质题解参考

<eval_intro>
我从“思路清晰度、代码效率、启发性”三个维度筛选了3份优质题解，覆盖了数论、动态规划、搜索三种核心方法：
</eval_intro>

**题解一：Flokirie的数论法（5星）**
* **点评**：这份题解的亮点在于**用数学定理直接“秒杀”问题**！作者没有用复杂的循环或搜索，而是利用“线性组合的gcd性质”——只需计算初始角的gcd，然后判断目标角是否是gcd的倍数模360。代码简洁到极致（仅几十行），时间复杂度极低，是本题的**最优解法**。这种“透过现象看本质”的思维方式，值得大家反复体会！

**题解二：asasas的完全背包法（4星）**
* **点评**：作者将问题转化为**完全背包的可行性问题**，思路非常直观：`dp[j]`表示“能否组合出角度j”。通过枚举初始角和可能的角度（j从a[i]到1005），利用`j%360`处理循环，状态转移清晰（`dp[j%360] |= dp[(j±a[i])%360]`）。代码规范，变量名易懂，适合新手理解“动态规划如何解决组合问题”。

**题解三：_Fatalis_的BFS法（4星）**
* **点评**：作者用BFS遍历所有可达状态，并且**证明了“不用枚举减法操作”**——因为“加k次a[i]”等价于“减p次a[i]”（比如x-ap ≡ x+ak mod 360，k=360-p）。这个结论大大减少了计算量，代码也更简洁。BFS的“队列扩展”过程直观，适合理解“状态空间的遍历”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到3个关键问题。结合优质题解的思路，我帮你提炼了应对策略：
</difficulty_intro>

1.  **难点1：如何将角度问题转化为数学模型？**
    * **分析**：角度的加减本质是“整数线性组合”，而线性组合的结果一定是初始角gcd的倍数（数论定理）。比如样例1中，初始角30和70的gcd是10，目标角40是10的倍数——所以能组合出。  
    * 💡 **学习笔记**：先想“问题的数学本质”，再写代码，往往能事半功倍！

2.  **难点2：如何处理角度的“循环性”（模360）？**
    * **分析**：角度超过360或小于0时，用`%360`映射到0~359的范围。比如动态规划中，`j%360`将状态限制在360以内；搜索中，扩展的状态也要取模，避免无限循环。  
    * 💡 **学习笔记**：模运算能“压缩状态空间”，是处理循环问题的神器！

3.  **难点3：如何选择高效的算法？**
    * **分析**：数论法最优（O(n+360)），完全背包次之（O(n×1005)），BFS/DFS最慢（O(360×n)）。但本题n和m很小（≤10），所有方法都能AC。**优先用数论法**，因为它最简洁！  
    * 💡 **学习笔记**：算法的选择取决于“问题的数学性质”和“数据范围”。


### ✨ 解题技巧总结
- **技巧1：先找数学规律**：遇到“组合可行性”问题，先想“是否能用数论定理简化”（比如gcd、模运算）。  
- **技巧2：状态压缩**：利用模360将状态从“无限”压缩到“360个”，避免超时。  
- **技巧3：验证边界条件**：比如0°一定能组合出（初始状态），目标角为0时直接输出YES。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看**数论法的通用核心代码**——这是本题最简洁的解法，适合直接借鉴：
</code_intro_overall>

**本题通用核心C++实现参考（数论法）**
* **说明**：基于Flokirie的思路，将C#代码转化为C++，逻辑清晰，效率最高。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;

  int gcd(int a, int b) { // 计算最大公约数（欧几里得算法）
      while (b != 0) {
          int temp = b;
          b = a % b;
          a = temp;
      }
      return a;
  }

  int main() {
      int n, m;
      cin >> n >> m;
      vector<int> a(n);
      for (int i = 0; i < n; ++i) {
          cin >> a[i];
      }
      // 计算所有初始角的gcd
      int common_gcd = a[0];
      for (int i = 1; i < n; ++i) {
          common_gcd = gcd(common_gcd, a[i]);
      }
      // 预处理所有可达的角度（gcd的倍数模360）
      vector<bool> reachable(360, false);
      for (int i = 0; i < 360; ++i) {
          reachable[(common_gcd * i) % 360] = true;
      }
      // 判断每个目标角
      for (int i = 0; i < m; ++i) {
          int b;
          cin >> b;
          cout << (reachable[b] ? "YES" : "NO") << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 用欧几里得算法计算初始角的gcd；  
  2. 预处理所有gcd的倍数模360（这些角度都是可达的）；  
  3. 逐个判断目标角是否在“可达集合”中。


---

<code_intro_selected>
接下来看另外两种方法的核心片段，帮你理解不同思路的实现细节：
</code_intro_selected>

**题解二：asasas的完全背包法**
* **亮点**：将“角度组合”转化为“完全背包问题”，状态转移直观。
* **核心代码片段**：
  ```cpp
  bool dp[361]; // dp[j]表示能否组合出角度j
  dp[0] = true; // 初始状态：0°一定能组合出
  for (int i = 1; i <= n; ++i) { // 枚举每个初始角
      for (int j = a[i]; j <= 1005; ++j) { // 完全背包：顺序枚举
          dp[j%360] = max(dp[j%360], dp[(j - a[i])%360]); // 加a[i]
          dp[j%360] = max(dp[j%360], dp[(j + a[i])%360]); // 减a[i]
      }
  }
  ```
* **代码解读**：  
  - `dp[0] = true`：初始状态（没有任何角度时，角度是0）；  
  - 外层循环枚举每个初始角（相当于“物品”）；  
  - 内层循环枚举可能的角度j（相当于“背包容量”），顺序枚举是完全背包的特征（允许重复使用物品）；  
  - `j%360`将角度映射到0~359，避免状态爆炸。
* 💡 **学习笔记**：完全背包的“顺序枚举”是关键——允许同一个初始角被多次使用！

**题解三：_Fatalis_的BFS法**
* **亮点**：证明了“不用枚举减法”，简化代码。
* **核心代码片段**：
  ```cpp
  bool vis[361]; // 标记角度是否可达
  queue<int> q;
  q.push(0); vis[0] = true;
  while (!q.empty()) {
      int t = q.front(); q.pop();
      if (t == end) return true; // 找到目标角
      for (int i = 1; i <= n; ++i) {
          int cg = (t + a[i]) % 360; // 只枚举加法
          if (!vis[cg]) {
              vis[cg] = true;
              q.push(cg);
          }
      }
  }
  ```
* **代码解读**：  
  - 队列`q`存储“待扩展的状态”（角度）；  
  - 每次取出队头`t`，枚举加每个初始角`a[i]`，得到新角度`cg`；  
  - 如果`cg`未被访问过，标记为可达并加入队列；  
  - 作者证明了“加法多次等价于减法”，所以不用枚举`t - a[i]`！
* 💡 **学习笔记**：BFS的“队列”能保证“按顺序扩展状态”，避免重复计算！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地理解**BFS搜索的状态扩展**，我设计了一个“像素探险家找角度”的动画方案——用FC红白机的8位风格，结合游戏化元素，让算法“动起来”！
</visualization_intro>

### 动画设计方案
#### 1. 整体风格与场景
- **8位像素风**：用16色调色板（红、蓝、绿、黄、黑、白），网格大小为20×18（刚好容纳0~359°，每个格子对应一个角度）；  
- **场景布局**：左侧是“角度网格”，右侧是“控制面板”（开始/暂停、单步、重置、速度滑块）；  
- **背景音乐**：循环播放FC风格的轻快BGM（比如《超级马里奥》的小关卡音乐）。

#### 2. 核心动画步骤
1. **初始化**：  
   - 角度网格中，0°的格子用**红色**高亮（起点），初始角的格子用**蓝色**标记；  
   - 控制面板显示“等待开始”，速度滑块默认在“中速”。

2. **BFS扩展**：  
   - 点击“开始”后，队列中的第一个状态（0°）被取出，枚举加每个初始角：  
     - 比如初始角是30和70，那么0+30=30°，0+70=70°；  
     - 30°和70°的格子用**绿色**点亮，伴随“嗒”的像素音效；  
     - 将30°和70°加入队列（显示为网格旁的小“像素队列”）。

3. **状态转移**：  
   - 接下来取出队列中的30°，枚举加30和70：30+30=60°，30+70=100°；  
   - 60°和100°的格子被点亮，同样伴随“嗒”的音效；  
   - 重复这个过程，直到队列空或找到目标角。

4. **目标达成**：  
   - 比如目标角是40°，当扩展到100°时，100+30×8=340°→340+30=370°→370%360=10°→……最终会扩展到40°；  
   - 40°的格子用**黄色**闪烁，播放“叮咚”的胜利音效，屏幕显示“找到目标！”。

#### 3. 交互设计
- **单步执行**：点击“单步”，每次只扩展一个状态，方便观察细节；  
- **自动播放**：点击“自动”，算法按速度滑块的速度（慢/中/快）自动执行；  
- **重置**：点击“重置”，回到初始状态，重新开始演示；  
- **算法比较**：（可选）在右侧同时演示“数论法”——直接点亮所有gcd的倍数，对比两种方法的效率。

#### 4. 旁白提示
- 扩展时：“现在处理角度t，尝试加初始角a[i]，得到新角度cg！”；  
- 点亮时：“角度cg被点亮啦，它是可达的！”；  
- 找到目标时：“目标角b被找到了，答案是YES！”。


<visualization_conclusion>
这个动画用游戏化的方式展示了BFS的核心逻辑——你能清楚看到“角度是如何一步步被扩展的”，而像素风格和音效让学习变得更有趣！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的思路后，你可以尝试以下类似问题，巩固所学的数论、动态规划和搜索技巧：
</similar_problems_intro>

### 通用思路迁移
- **数论gcd**：用于判断“线性组合的可行性”（比如：能否用硬币组合出某个金额？）；  
- **完全背包**：用于“无限物品的组合问题”（比如：用无限个物品装满背包的最大价值？）；  
- **BFS**：用于“状态可达性问题”（比如：迷宫找出口、最短路径问题？）。

### 洛谷练习推荐
1. **洛谷 P1048** - 采药  
   🗣️ **推荐理由**：经典的01背包问题，帮你区分“01背包”（物品只能用一次）和“完全背包”（物品可以用多次）。
2. **洛谷 P1616** - 疯狂的采药  
   🗣️ **推荐理由**：完全背包的变形，数据范围更大，需要优化状态转移（比如用滚动数组）。
3. **洛谷 P2925** - [USACO08DEC]Patting Heads S  
   🗣️ **推荐理由**：数论gcd的应用，需要统计每个数的倍数出现的次数，锻炼“数学建模”能力。
4. **洛谷 P3371** - 单源最短路径（弱化版）  
   🗣️ **推荐理由**：BFS的经典应用（最短路径），帮你理解“状态扩展”的顺序和最优性。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我发现了几个很有价值的“踩坑经验”，分享给你：
</insights_intro>

> **经验1（来自_Fatalis_）**：“我证明了不用枚举减法操作，因为加法多次等价于减法。”  
> **点评**：这个结论非常巧妙！它提醒我们：**深入理解问题的数学性质，可以简化代码，减少计算量**。比如本题中，枚举减法会导致重复计算，而加法已经覆盖了所有可能的状态。

> **经验2（来自zymooll）**：“数据太水了，同机房只考虑两个数相加减的也过了。”  
> **点评**：虽然数据水，但**掌握正确的算法更重要**。比如数论法能解决所有情况，而暴力法可能在强数据下超时。


<conclusion>
本次关于KUTEVI的分析就到这里！希望你能掌握“数论gcd”“完全背包”“BFS”三种核心方法，并且学会“透过问题看本质”——先找数学规律，再写代码。编程的乐趣在于“用简单的逻辑解决复杂的问题”，继续加油吧！💪
</conclusion>

---
处理用时：178.35秒
# 题目信息

# [蓝桥杯 2021 省 AB] 砝码称重

## 题目描述

你有一架天平和 $N$ 个砝码, 这 $N$ 个砝码重量依次是 $W_{1}, W_{2}, \cdots, W_{N}$ 。 请你计算一共可以称出多少种不同的重量?

注意砝码可以放在天平两边。


## 说明/提示

**【样例说明】**

能称出的 10 种重量是: $1 、 2 、 3 、 4 、 5 、 6 、 7 、 9 、 10 、 11$ 。

$$
\begin{aligned}
&1=1 \\
&2=6-4(\text { 天平一边放 } 6, \text { 另一边放 4) } \\
&3=4-1 \\
&4=4 \\
&5=6-1 \\
&6=6 \\
&7=1+6 \\
&9=4+6-1 \\
&10=4+6 \\
&11=1+4+6
\end{aligned}
$$

**【评测用例规模与约定】**

对于 $50 \%$ 的评测用例, $1 \leq N \leq 15$ 。

对于所有评测用例, $1 \leq N \leq 100, N$ 个砝码总重不超过 $10^5$。 

蓝桥杯 2021 第一轮省赛 A 组 F 题（B 组 G 题）。

## 样例 #1

### 输入

```
3
1 4 6```

### 输出

```
10```

# AI分析结果

# 💡 Kay的C++算法解析：砝码称重 深入学习指南 💡

今天我们来一起分析"砝码称重"这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划(DP)

🗣️ **初步分析**：
> 解决"砝码称重"这道题，关键在于理解并运用动态规划(DP)。简单来说，动态规划就像是我们在玩积木时，先搭好小的基础结构，再用这些小结构一步步搭建出更大更复杂的结构。在本题中，动态规划主要用于记录我们用已有的砝码可以称出哪些重量，然后每增加一个新砝码，更新我们可以称出的重量范围。

   - 题解思路主要是通过定义一个DP状态来记录能否称出某个重量，然后通过状态转移来更新可以称出的重量集合。核心难点在于处理砝码可以放在天平两边的情况，这意味着不仅可以加上砝码重量，还可以减去砝码重量。
   - 核心算法流程是：初始化一个表示能否称出重量的DP数组，然后逐个处理每个砝码，对每个可能的重量，判断加上当前砝码、减去当前砝码或不用当前砝码能否得到新的可称重重量。可视化时，我们可以用不同颜色的像素块表示不同的状态：已能称出的重量、新发现的可称重量等。
   - 我设计了一个"像素天平实验室"的复古游戏化演示，玩家可以看到一个像素风格的天平，下方有砝码栏。每次选择一个砝码，可以看到它被放到天平左侧、右侧或不使用，同时右侧的重量记录表会实时更新可称出的重量，并伴有"叮"的音效。玩家可以选择手动操作或"AI自动演示"模式，观看算法如何自动探索所有可能的称重组合。

---

## 2. 精选优质题解参考

为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等几个方面，为大家筛选了以下评分较高（≥4星）的题解。

**题解一：(来源：while_true)**
* **点评**：这份题解在思路上非常清晰，将问题转化为01背包问题的分析尤为透彻。作者首先介绍了01背包的概念，并详细解释了为什么本题可以用类似思路解决。对天平两边放置砝码的数学原理（m_thing = |m_l - m_r|）的推导过程解释得非常清楚，这是理解整个问题的关键。其状态定义（f[i][j]表示枚举到第i个砝码时是否能够称出质量j）直观且易于理解。算法上，作者详细分析了三种转移情况，并提醒了从大到小转移以避免越界的关键点，展现了对动态规划实现细节的深入理解。从实践角度看，这份题解不仅提供了解题思路，还包含了对问题本质的分析，帮助我们将理论应用到实际编码中。

**题解二：(来源：ryf_loser)**
* **点评**：这份题解以简洁明了著称，直接列出了四种状态转移情况，让读者能够快速抓住问题的核心。代码风格简洁规范，变量名如dp、w、sum等含义明确，特别是使用二维数组dp[i][j]清晰地表示了状态。算法上，虽然是标准的动态规划实现，但通过四层条件判断清晰地表达了所有可能的状态转移，易于理解和实现。从实践角度看，这份代码可以直接用于解决问题，边界处理也比较严谨，适合初学者参考和学习如何将动态规划思想转化为实际代码。

**题解三：(来源：loser_seele)**
* **点评**：这份题解展现了高级的优化技巧，使用bitset来优化动态规划的转移过程，将时间复杂度降低到O(nΣa_i/w)，这是其最突出的亮点。作者敏锐地发现了转移过程中的位运算特性，将传统的加法和减法操作转化为位运算的左移和右移，极大地提高了效率。代码极其简洁，仅用几行就实现了复杂的功能，体现了作者对C++标准库的深入了解和编程技巧的熟练运用。虽然解释部分较为简略，但对于有一定基础的学习者来说，这份题解展示了动态规划优化的新思路，具有很高的参考价值。

---

## 3. 核心难点辨析与解题策略

在解决这个问题的过程中，我们通常会遇到以下一些关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略，希望能帮助大家在后续解题时举一反三：

1. **关键点1**：如何处理天平两边都能放砝码的情况？
    * **分析**：这是本题与传统背包问题最大的区别。当砝码只能放在一侧时，我们只需考虑加的情况；而当天平两边都能放时，我们还需要考虑减的情况。优质题解通常通过绝对值运算或同时考虑j+a[i]和|j-a[i]|来处理这种情况。例如，当我们已经能称出重量j时，加上砝码a[i]可以称出j+a[i]，将砝码放在另一侧可以称出|j-a[i]|。
    * 💡 **学习笔记**：天平两侧放砝码意味着不仅可以做加法，还可以做减法，这是问题的核心特点。

2. **关键点2**：如何定义和更新DP状态？
    * **分析**：几乎所有优质题解都使用了类似dp[j]的状态定义，表示能否称出重量j。初始状态通常是dp[0] = 1（表示重量0可以称出）。更新时，对于每个砝码，我们需要遍历所有可能的重量，并根据当前砝码更新可称重的范围。需要注意的是，为了避免重复计算，内层循环通常从大到小遍历（如ryf_loser的解法），或者使用单独的临时数组来存储新状态。
    * 💡 **学习笔记**：状态定义和转移方程是动态规划的灵魂，好的状态定义能极大简化问题。

3. **关键点3**：如何处理负重量和优化空间？
    * **分析**：当考虑j-a[i]时，可能会出现负数，这在数组索引中是不允许的。解决方法有两种：一是使用绝对值函数（如while_true的解法），二是使用偏移值将所有可能的重量都转换为非负数（如RP_INT_MAX的解法）。对于空间优化，大多数题解都使用了一维数组结合从大到小遍历的方式，将空间复杂度从O(n*sum)降低到O(sum)。更高级的优化如loser_seele的bitset方法，可以进一步提高效率并减少代码量。
    * 💡 **学习笔记**：处理边界情况和优化空间是动态规划问题中常见的挑战，也是提升算法效率的关键。

### ✨ 解题技巧总结

通过对本题及类似问题的分析，我总结了以下一些通用的解题技巧，希望对大家有所启发：

- **技巧A (问题转化与建模)**：将实际问题转化为合适的数据模型是解题的第一步。本题将称重问题转化为01背包问题的变种，这种转化能力需要通过大量练习来培养。

- **技巧B (状态定义与转移)**：定义清晰的状态表示和简洁的转移方程是动态规划的核心。对于可行性问题（能否达到某种状态），通常可以用bool型数组来表示状态。

- **技巧C (空间优化)**：在处理动态规划问题时，要时刻考虑空间优化。滚动数组技术可以将二维DP数组优化为一维，而对于某些特殊问题，还可以使用bitset等高级数据结构进一步优化。

- **技巧D (边界处理)**：对于可能出现的边界情况（如本题中的负重量），要提前规划好处理方案，避免数组越界等运行时错误。

---

## 4. C++核心代码实现赏析

在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用一维动态规划数组，并处理了天平两边放置砝码的情况，旨在提供一个清晰且完整的核心实现。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <cmath>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        vector<int> weights(n);
        int sum = 0;
        for (int i = 0; i < n; ++i) {
            cin >> weights[i];
            sum += weights[i];
        }
        
        // dp[j]表示能否称出重量j
        vector<bool> dp(sum + 1, false);
        dp[0] = true;  // 初始状态：能称出重量0
        
        for (int w : weights) {
            // 创建临时数组存储新状态，避免干扰当前迭代
            vector<bool> new_dp = dp;
            for (int j = 0; j <= sum; ++j) {
                if (dp[j]) {
                    // 将砝码放在同侧：j + w
                    if (j + w <= sum) {
                        new_dp[j + w] = true;
                    }
                    // 将砝码放在异侧：abs(j - w)
                    int diff = abs(j - w);
                    new_dp[diff] = true;
                }
            }
            dp = move(new_dp);
        }
        
        // 统计可以称出的重量种数（不包括0）
        int count = 0;
        for (int j = 1; j <= sum; ++j) {
            if (dp[j]) {
                count++;
            }
        }
        
        cout << count << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取输入的砝码数量和重量，并计算所有砝码的总重量作为可能称出的最大重量。然后初始化一个布尔型数组dp，其中dp[j]表示能否称出重量j，初始状态下只有dp[0]为true（表示重量0可以称出）。接下来，对于每个砝码，我们创建一个新的状态数组new_dp，遍历当前所有可以称出的重量j，分别考虑将砝码放在同侧（j + w）和异侧（abs(j - w)）的情况，并更新new_dp数组。处理完所有砝码后，统计dp数组中为true的元素个数（不包括0），即为可以称出的不同重量的种数。

---

接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。

**题解一：(来源：while_true)**
* **亮点**：此题解详细阐述了动态规划状态的定义和转移逻辑，特别是对天平两边放置砝码的数学原理推导清晰，有助于深入理解问题本质。
* **核心代码片段**：
    ```cpp
    // 设状态f[i][j]表示枚举到第i个砝码时是否能够称出质量j
    // 转移方程：
    // 1. 如果枚举到当前的砝码不放：f[i][j] = f[i-1][j]
    // 2. 如果当前砝码是第一个放的：f[i][j] = 1 (j = W_i)
    // 3. 将当前砝码放置在右盘：当f[i-1][abs(j-W_i)] = 1时，f[i][j] = 1
    // 4. 将当前砝码放置在左盘：当f[i-1][j+W_i] = 1时，f[i][j] = 1
    
    // 代码实现时需要注意从大到小转移，避免越界
    for(int i=1;i<=n;i++){
        for(int j=sum;j>=0;j--){
            if(j==w[i]) dp[i][j] = 1;
            else if(dp[i-1][j]) dp[i][j] = 1;
            else if(dp[i-1][abs(j-w[i])]) dp[i][j] = 1;
            else if(j + w[i] <= sum && dp[i-1][j + w[i]]) dp[i][j] = 1;
        }
    }
    ```
* **代码解读**：
    > 这段代码展示了二维动态规划的核心实现。状态定义为dp[i][j]，表示使用前i个砝码能否称出重量j。外层循环枚举每个砝码，内层循环从总重量sum开始向下枚举所有可能的重量。为什么要从大到小枚举呢？这是为了避免在处理当前砝码时，多次使用同一个砝码（想想看，如果从小到大枚举会发生什么？）。对于每个重量j，有四种可能的情况使其可以被称出：(1)j正好等于当前砝码重量；(2)不使用当前砝码也能称出j；(3)将当前砝码放在与之前砝码相反的一侧，即abs(j-w[i])可以被称出；(4)将当前砝码放在与之前砝码相同的一侧，即j+w[i]可以被称出。这种分情况讨论的方式清晰地覆盖了所有可能的称重方式。
* 💡 **学习笔记**：动态规划状态转移的核心在于考虑所有可能的决策，并基于子问题的解构建当前问题的解。对于需要避免重复使用元素的问题（如01背包），从大到小遍历是常用的技巧。

**题解二：(来源：ryf_loser)**
* **亮点**：该解法采用了简洁的动态规划实现，代码结构清晰，直接明了地展示了四种状态转移情况，易于理解和实现。
* **核心代码片段**：
    ```cpp
    #include<cstdio>
    #include<cmath>
    using namespace std;
    int n,ans,sum,w[101],dp[101][100001];
    
    int main(){
        scanf("%d",&n);
        for(int i=1;i<=n;i++){
            scanf("%d",&w[i]);
            sum += w[i];
        }
        
        for(int i=1;i<=n;i++){
            for(int j=sum;j;j--){
                if(j==w[i]) dp[i][j] = 1;
                else if(dp[i-1][j]) dp[i][j] = 1;
                else if(dp[i-1][j+w[i]]) dp[i][j] = 1;
                else if(dp[i-1][abs(j-w[i])]) dp[i][j] = 1;
            }
        }
        
        for(int i=1;i<=sum;i++) if(dp[n][i]) ans++;
        printf("%d",ans);
        return 0;
    }
    ```
* **代码解读**：
    > 这段代码是一个完整的动态规划实现。首先读取输入并计算砝码总重量。然后使用二维数组dp[i][j]来记录状态，其中i表示考虑前i个砝码，j表示可能的重量。内层循环从sum开始向下遍历到1，这是为了避免重复使用同一个砝码。对于每个重量j，代码通过四个条件判断是否可以称出：(1)j等于当前砝码重量；(2)不使用当前砝码也能称出j；(3)之前可以称出j+w[i]，现在把当前砝码放在另一侧；(4)之前可以称出|j-w[i]|，现在把当前砝码放在同侧或另一侧。最后统计dp[n][i]为1的数量，即可以称出的不同重量的种数。这段代码的优点是直观易懂，将所有可能的情况都清晰地列了出来。
* 💡 **学习笔记**：清晰的状态定义和转移条件是动态规划问题的关键。这段代码通过简单直接的条件判断，将复杂的称重问题转化为可实现的动态规划算法，展示了将问题抽象为数学模型的能力。

**题解三：(来源：loser_seele)**
* **亮点**：该解法使用bitset优化动态规划转移，代码极其简洁高效，展现了高级的C++编程技巧和算法优化能力。
* **核心代码片段**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    int a[110],n;
    bitset<100010> d;
    
    signed main() {
        ios::sync_with_stdio(0);
        cin>>n;
        d.set(0);  // 初始状态：可以称出重量0
        
        // 第一步：处理砝码放在同侧的情况（加法）
        for(int i=1;i<=n;i++)
            cin>>a[i],d|=d<<a[i];
        
        // 第二步：处理砝码放在异侧的情况（减法）
        for(int i=1;i<=n;i++)
            d|=d>>a[i];
        
        // 统计可以称出的重量种数（减去0的情况）
        cout<<d.count()-1;
    }
    ```
* **代码解读**：
    > 这段代码是一个极其巧妙的优化实现，使用了C++标准库中的bitset来优化动态规划的状态存储和转移。bitset是一种位集合，每个位表示一个状态（0或1）。初始时，d.set(0)将第0位置为1，表示可以称出重量0。对于每个砝码，第一步操作d|=d<<a[i]相当于将所有已能称出的重量加上a[i]，这对应于将砝码放在与之前砝码相同的一侧。第二步操作d|=d>>a[i]相当于将所有已能称出的重量减去a[i]，这对应于将砝码放在与之前砝码相反的一侧。最后，d.count()返回所有为1的位的数量，减去1（排除重量0）即为可以称出的不同重量的种数。这种方法将时间和空间复杂度都大幅降低，代码也非常简洁。
* 💡 **学习笔记**：熟练掌握C++标准库中的数据结构可以极大地简化代码并提高效率。bitset特别适合处理这类二进制状态的动态规划问题，其位运算操作既快速又节省空间。

---

## 5. 算法可视化：像素动画演示 (核心部分)

为了更直观地理解砝码称重动态规划算法是如何工作的，我设计了一个"像素天平实验室"的动画演示方案。希望能帮助大家更好地"看"到算法的每一步！

  * **动画演示主题**：像素天平实验室 - 砝码称重模拟器

  * **核心演示内容**：动态规划算法如何逐步探索所有可能的称重组合，包括砝码放在左侧、右侧或不使用的情况，以及可称重集合的实时更新过程。

  * **设计思路简述**：采用8位像素风是为了营造轻松复古的学习氛围，让复杂的算法变得生动有趣。天平两侧砝码的放置和重量计算过程通过直观的像素动画展示，每种操作都配有独特的"像素音效"，如放置砝码的"咔哒"声、发现新重量的"叮"声等。学习者可以选择手动尝试放置砝码或观看"AI自动演示"，体验算法如何高效地探索所有可能的组合。

  * **动画帧步骤与交互关键点**：

    1.  **场景与UI初始化 (8位像素风)**：
          * 屏幕左侧显示一个像素化的天平，分为左盘和右盘区域。
          * 屏幕右侧是一个"可称重记录板"，以像素块形式显示当前可以称出的重量。
          * 屏幕下方是"砝码选择栏"，显示所有可用的砝码。
          * 控制面板包含："开始/暂停"、"单步执行"、"重置"按钮；"速度调节"滑块；"手动/AI自动演示"切换开关。
          * 8位风格的轻松背景音乐开始播放，营造复古游戏氛围。

    2.  **初始状态**：
          * 天平两侧为空，显示"0"。
          * 可称重记录板上只有"0"被点亮。
          * 所有砝码都在下方的砝码选择栏中。

    3.  **砝码选择与放置**：
          * 在手动模式下，玩家可以点击选择一个砝码，然后点击天平左盘、右盘或"不使用"按钮。
          * 在AI自动演示模式下，算法会自动按最优顺序尝试所有可能的放置方式。
          * 每次选择后，天平上会出现相应的像素砝码，并显示当前两侧的总重量。
          * 放置砝码时伴随"咔哒"音效。

    4.  **重量计算与更新**：
          * 每次放置或移除砝码后，系统计算两侧重量差的绝对值。
          * 如果这是一个新的可称重重量，右侧记录板上对应的数字会以闪烁的方式点亮，并播放"叮"的提示音效。
          * 已称重的重量会保持点亮状态，新发现的重量会有特殊的动画效果。

    5.  **动态规划过程可视化**：
          * 在屏幕底部，有一个简化的DP数组可视化条，用不同颜色的像素点表示每个重量是否可以被称出。
          * 当处理一个新砝码时，可视化条会动态更新，显示新的可称重重量被"激活"的过程。
          * 加法操作（砝码放在同侧）用向右扩展的动画表示，减法操作（砝码放在异侧）用向左扩展的动画表示。

    6.  **AI自动演示模式**：
          * 选择AI模式后，算法会自动演示如何高效地尝试所有可能的砝码组合。
          * AI会优先尝试能产生最多新重量的砝码放置方式，展示动态规划的优化思想。
          * AI操作时有轻微的"思考"动画，增强拟人化体验。

    7.  **完成状态**：
          * 当所有砝码都处理完毕后，右侧记录板上所有可称重的重量都会被点亮。
          * 播放上扬的"成功"音效，屏幕中央显示"实验完成！可称重数量：X"的提示。
          * 玩家可以点击"重置"按钮重新开始，或调整参数尝试不同的实验条件。

  * **旁白提示 (动画中的文字气泡或侧边信息)**：

      * （初始状态）"欢迎来到像素天平实验室！我们的目标是找出这些砝码能称出多少种不同的重量。"
      * （选择第一个砝码时）"让我们先试试这个砝码。把它放在左盘、右盘会有什么不同？"
      * （新重量发现时）"叮！我们发现了一个新的可称重重量：X。看看它是怎么被称出来的？"
      * （AI演示时）"AI正在演示动态规划算法的工作过程，注意观察可称重集合是如何逐步扩大的。"
      * （完成时）"实验完成！我们用这些砝码一共可以称出X种不同的重量。你发现了所有可能的组合吗？"

通过这样一个融合了像素艺术和复古游戏元素的动画，我们不仅能清晰地看到动态规划算法的执行流程，还能在一种更轻松有趣的环境中理解其核心逻辑和数据变化。这种可视化方式特别适合初学者理解动态规划中状态转移的过程，将抽象的算法概念转化为直观的视觉体验。

---

## 6. 拓展练习与相似问题思考

理解并掌握了本题的解法后，我们可以进一步思考动态规划算法在类似问题中的应用。

  * **通用思路/技巧迁移**：

      * 动态规划中的可行性问题（能否达到某种状态）不仅能解决本题，也常用于处理以下几类问题：
        1. **子集和问题**：给定一组数，判断能否选出一个子集使其和等于特定值。
        2. **分割等和子集**：判断能否将一个数组分割成两个子集，使两个子集的和相等。
        3. **目标和问题**：给定一个数组和一个目标值，通过给每个元素添加"+"或"-"号，判断能否使表达式的结果等于目标值。
      这些问题都可以通过类似的动态规划思路解决，关键在于定义合适的状态表示和转移规则。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点或思维方式相关的题目，建议大家尝试练习：

    1.  **洛谷 P1048** - 采药
          * 🗣️ **推荐理由**：这是一道经典的01背包问题，可以帮助你巩固动态规划的基础概念和实现方法，理解如何在有限资源下做出最优选择。

    2.  **洛谷 P2347** - 砝码称重
          * 🗣️ **推荐理由**：这道题是本题的简化版，砝码只能放在天平一侧。通过解决这道题，你可以先掌握基础的称重问题，再对比本题理解天平两侧放砝码的差异。

    3.  **洛谷 P4170** - 涂色
          * 🗣️ **推荐理由**：这道题考察了区间动态规划的思想，虽然问题场景不同，但状态定义和转移的思维方式与本题有相通之处，可以帮助你拓展动态规划的应用视野。

    4.  **洛谷 P1164** - 小A点菜
          * 🗣️ **推荐理由**：这道题是计数型动态规划问题，要求计算达到目标的方案数，而非简单的可行性判断。通过这道题，你可以进一步理解动态规划在不同类型问题中的应用。

---

## 7. 学习心得与经验分享 (若有)

如果提供的题解内容中包含了作者的个人学习心得或解题过程中的经验教训，这些对我们来说是非常宝贵的参考。我会摘录其中有价值的部分，并点评其借鉴意义：

> **参考经验 (来自 while_true)**："本题作为01背包的模板题之一，其思想不难（前提是你掌握了01背包写法）。但是有几个坑点：注意dp方程转移时要从大到小转移，否则存在越界。"
>
> **点评**：这位作者的提醒非常关键。在处理01背包及类似问题时，循环顺序是一个容易出错的地方。从大到小遍历可以避免同一个物品被多次使用，这是确保动态规划正确性的重要细节。这个经验提醒我们，在实现动态规划算法时，不仅要理解状态定义和转移方程，还要注意实现细节，如循环顺序、边界处理等，这些都是保证算法正确性的关键。

> **参考经验 (来自 loser_seele)**："不难发现这个转移在位运算中下标减相当于右移，下标加相当于左移，所以涉及的所有操作都是位运算，于是直接上bitset优化DP，将转移过程的加减改成位运算即可。"
>
> **点评**：这位作者展示了敏锐的观察力和对高级数据结构的熟练运用。将动态规划的状态转移与位运算联系起来，并用bitset进行优化，不仅提高了效率，还极大地简化了代码。这种经验告诉我们，深入理解问题本质和掌握多种数据结构，能够帮助我们发现更优的解决方案。在解决问题时，不要局限于常规方法，要勇于尝试和探索不同的优化思路。

---

本次关于"砝码称重"的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解动态规划算法和编程技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪

---
处理用时：226.19秒
# 题目信息

# 【模板】字符串哈希

## 题目描述

如题，给定 $N$ 个字符串（第 $i$ 个字符串长度为 $M_i$，字符串内包含数字、大小写字母，大小写敏感），请求出 $N$ 个字符串中共有多少个不同的字符串。


**友情提醒：如果真的想好好练习哈希的话，请自觉。**


## 说明/提示

### 数据范围

对于 $30\%$ 的数据：$N\leq 10$，$M_i≈6$，$M_{\max}\leq 15$。

对于 $70\%$ 的数据：$N\leq 1000$，$M_i≈100$，$M_{\max}\leq 150$。

对于 $100\%$ 的数据：$N\leq 10000$，$M_i≈1000$，$M_{\max}\leq 1500$。

### 样例说明

样例中第一个字符串 $\tt{abc}$ 和第三个字符串 $\tt{abc}$ 是一样的，所以所提供字符串的集合为 $\{\tt{aaaa},\tt{abc},\tt{abcc},\tt{12345}\}$，故共计 $4$ 个不同的字符串。

### 拓展阅读

以下的一些试题从不同层面体现出了字符串哈希算法的正确性分析。

- [P12197 Hash Killer I](https://www.luogu.com.cn/problem/P12197)
- [P12198 Hash Killer II](https://www.luogu.com.cn/problem/P12198)
- [P12199 （目前无解）Hash Killer III](https://www.luogu.com.cn/problem/P12199)
- [P12200 Hash Killer Extra](https://www.luogu.com.cn/problem/P12200)
- [P12201 Hash Killer Phantasm](https://www.luogu.com.cn/problem/P12201)
- [P7350 「MCOI-04」Dream and Strings](https://www.luogu.com.cn/problem/P7350)

## 样例 #1

### 输入

```
5
abc
aaaa
abc
abcc
12345```

### 输出

```
4```

# AI分析结果



---
# 💡 Kay的C++算法解析：【模板】字符串哈希 深入学习指南 💡

<introduction>
今天我们来一起分析“【模板】字符串哈希”这道题。这道题的核心是通过哈希技术高效判断字符串是否重复，最终统计不同字符串的数量。本指南将帮你理解哈希的核心思想、掌握关键实现技巧，并通过可视化动画直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（字符串哈希）`

🗣️ **初步分析**：
解决这道题的关键在于用“字符串哈希”技术将字符串映射为唯一或高概率唯一的整数（哈希值），从而快速判断字符串是否重复。哈希的核心思想类似“给每个字符串发一张‘身份证’”：相同的字符串必须有相同的“身份证号”，不同的字符串尽量有不同的“身份证号”（避免哈希冲突）。

在本题中，哈希的主要应用场景是：计算每个字符串的哈希值→排序哈希值→统计不同哈希值的数量（即不同字符串的数量）。核心难点在于如何设计哈希函数以降低冲突概率，以及如何高效实现哈希计算和去重。

### 核心算法流程与可视化设计
哈希计算的核心流程是：对每个字符串，按固定规则（如进制哈希）计算其哈希值。例如，进制哈希将字符串视为一个`base`进制数，逐位计算哈希值。可视化时，我们可以用像素动画展示每个字符如何被“转换”为哈希值（如字符的ASCII码逐个加入计算，哈希值动态更新），并用不同颜色标记哈希冲突的情况（若有）。

### 复古像素风格设计
动画采用8位像素风（类似FC游戏），用彩色像素方块表示字符，动态展示哈希值的计算过程（如字符逐个“掉入”哈希生成器，生成一个不断变化的数字）。排序去重环节用像素滑块拖动哈希值排序，相同哈希值的方块合并，最终统计数量时播放“叮”的音效，增强趣味性。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等角度筛选出以下3篇优质题解（评分≥4星）：
</eval_intro>

**题解一：作者皎月半洒花（赞1782）**
* **点评**：这篇题解从哈希的意义讲起，详细介绍了进制哈希、无错哈希、多重哈希等方法，并用代码示例说明。思路非常清晰（如用“隔壁老王的钥匙”比喻哈希冲突），代码规范（变量名`base`、`mod`含义明确），特别适合初学者理解哈希的核心逻辑。其单哈希代码简洁高效，边界处理严谨（如取模防溢出），是实践的好参考。

**题解二：作者hcx2012（赞4）**
* **点评**：此题解聚焦进制哈希的数学原理，解释了哈希冲突的概率估算（通过公式推导说明冲突概率低），代码简洁且注释清晰。例如，用`BASE=133`和`MOD=1e9+1`作为参数，平衡了计算效率和冲突概率。实践价值高，代码可直接用于竞赛。

**题解三：作者DX3906_ourstar（赞4）**
* **点评**：此题解从基础概念出发（如基数、模数的定义），逐步推导哈希计算的公式，并用自然溢出法（`unsigned long long`自动取模）简化代码。代码结合快读优化，效率高，且解释了自然溢出的优缺点（如易被卡但简单），对学习者理解不同哈希实现有启发。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的过程中，我们常遇到以下关键点，结合优质题解的共性，提炼思考方向：
</difficulty_intro>

1.  **关键点1：如何设计哈希函数以降低冲突？**
    * **分析**：哈希函数的设计直接影响冲突概率。优质题解通常选择大基数（如`base=131/133`）和大质数模数（如`mod=1e9+7`），或使用自然溢出（`unsigned long long`自动取模）。例如，hcx2012的题解通过公式估算冲突概率（约0.01%），说明合理选择参数可大幅降低冲突。
    * 💡 **学习笔记**：基数和模数的选择是关键，大基数+大质数模数（或自然溢出）是常见策略。

2.  **关键点2：如何高效计算哈希值？**
    * **分析**：进制哈希的计算是逐位进行的（`hash = (hash * base + s[i]) % mod`）。例如，皎月半洒花的代码中，`hashe`函数逐字符计算哈希值，时间复杂度为O(M)（M为字符串长度），适合处理大规模数据。
    * 💡 **学习笔记**：哈希计算的核心是递推公式，逐位处理字符即可。

3.  **关键点3：如何统计不同哈希值的数量？**
    * **分析**：将所有哈希值排序后，相邻比较即可统计不同值的数量（相同哈希值会相邻）。例如，hcx2012的代码排序后遍历数组，时间复杂度为O(N log N)（N为字符串数量），高效且易实现。
    * 💡 **学习笔记**：排序+遍历是统计不同元素数量的经典方法。

### ✨ 解题技巧总结
- **技巧A（多模哈希）**：若担心单哈希冲突，可使用双哈希（两个不同的`base`和`mod`），仅当两个哈希值都相同时才认为字符串相同，进一步降低冲突概率。
- **技巧B（自然溢出）**：用`unsigned long long`存储哈希值，利用其自动溢出特性（相当于模`2^64`），代码更简洁，但需注意可能被刻意构造的数据卡冲突。
- **技巧C（预处理优化）**：对于长字符串，可预处理`base`的幂次（如`base^i % mod`），加速子串哈希计算（本题虽不需要，但对类似问题有用）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，选取最简洁高效的进制哈希实现作为通用核心代码。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了皎月半洒花和hcx2012的题解思路，采用进制哈希+排序去重，兼顾效率与正确性。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <string>
    #include <algorithm>
    using namespace std;

    typedef unsigned long long ull;
    const ull BASE = 133;
    const ull MOD = 1e9 + 7; // 大质数模数，降低冲突概率
    ull hash_values[10010];   // 存储各字符串的哈希值

    // 计算字符串s的哈希值
    ull compute_hash(const string& s) {
        ull hash = 0;
        for (char c : s) {
            hash = (hash * BASE + c) % MOD; // 逐位计算，取模防溢出
        }
        return hash;
    }

    int main() {
        int n;
        cin >> n;
        for (int i = 0; i < n; ++i) {
            string s;
            cin >> s;
            hash_values[i] = compute_hash(s);
        }
        // 排序后统计不同哈希值的数量
        sort(hash_values, hash_values + n);
        int ans = 1;
        for (int i = 1; i < n; ++i) {
            if (hash_values[i] != hash_values[i - 1]) {
                ans++;
            }
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取所有字符串，逐个计算其哈希值（`compute_hash`函数），然后排序哈希值数组，最后遍历数组统计不同值的数量。核心逻辑是进制哈希计算和排序去重，时间复杂度为O(N*M + N log N)（N为字符串数量，M为平均长度），适用于题目数据范围。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：皎月半洒花（单哈希实现）**
* **亮点**：代码中`hashe`函数逐字符计算哈希值，并用`mod`和`prime`双重处理防溢出，降低冲突概率。
* **核心代码片段**：
    ```cpp
    ull hashe(char s[]) {
        int len = strlen(s);
        ull ans = 0;
        for (int i = 0; i < len; i++)
            ans = (ans * base + (ull)s[i]) % mod + prime;
        return ans;
    }
    ```
* **代码解读**：这段代码中，`base`是基数（如131），`mod`是大质数模数，`prime`是额外质数（增强随机性）。逐字符计算时，`ans * base`相当于左移一位（进制哈希的核心），加上当前字符的ASCII码，再取模防溢出。最后加`prime`进一步减少冲突可能。
* 💡 **学习笔记**：在哈希计算中加入额外常数（如`prime`）可增强哈希的随机性，降低冲突概率。

**题解二：hcx2012（模数选择）**
* **亮点**：选择`BASE=133`和`MOD=1e9+1`，通过概率公式说明冲突概率低，代码简洁易读。
* **核心代码片段**：
    ```cpp
    #define BASE 133
    #define MOD 1000000001
    int a[11000];
    int main() {
        int n; cin >> n;
        string s;
        for (int i = 0; i < n; i++) {
            cin >> s;
            int x = 0;
            for (int j = 0; j < s.size(); j++) {
                x = (x * BASE + s[j]) % MOD;
            }
            a[i] = x;
        }
        sort(a, a + n);
        // 统计不同值...
    }
    ```
* **代码解读**：`BASE=133`大于字符集大小（数字+大小写字母共62种），确保每位字符的贡献唯一；`MOD=1e9+1`是大质数，哈希值范围大，冲突概率低。排序后统计不同值的逻辑直接高效。
* 💡 **学习笔记**：基数应大于字符集大小，模数选大质数，是降低冲突的关键。

**题解三：DX3906_ourstar（自然溢出）**
* **亮点**：利用`unsigned long long`自动溢出（模`2^64`），代码简洁，适合快速实现。
* **核心代码片段**：
    ```cpp
    #define ull unsigned long long
    #define base 191
    ull a[N];
    signed main() {
        n = read();
        for (int i = 1; i <= n; ++i) {
            ull hashh = 0;
            char c = getchar();
            while (isdigit(c) || isalpha(c)) {
                hashh = hashh * base + (ull)c; // 自然溢出，无需显式取模
                c = getchar();
            }
            a[i] = hashh;
        }
        sort(a + 1, a + n + 1);
        // 统计不同值...
    }
    ```
* **代码解读**：`unsigned long long`的存储范围是`0~2^64-1`，溢出时自动取模，省去了显式取模操作。`base=191`是经验值，平衡了计算效率和冲突概率。
* 💡 **学习笔记**：自然溢出代码简洁，但需注意可能被卡冲突（如刻意构造的字符串），竞赛中可结合双哈希使用。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解哈希计算和去重过程，我们设计一个“像素哈希工厂”动画，用8位像素风展示字符串如何变成哈希值，以及排序去重的全过程。
</visualization_intro>

  * **动画演示主题**：`像素哈希工厂大冒险`

  * **核心演示内容**：
    - 输入阶段：像素风格的输入框中，字符串逐个“掉落”（如`abc`的每个字符是彩色方块）。
    - 哈希计算：每个字符进入“哈希生成器”（一个像素机器），机器按`hash = hash * base + c`的规则动态计算哈希值（数字在屏幕上滚动变化）。
    - 哈希存储：生成的哈希值存入“哈希仓库”（一排像素格子，每个格子显示一个哈希值）。
    - 排序去重：仓库中的哈希值像“贪吃蛇”一样排序，相同值的格子合并，最终统计不同格子的数量。

  * **设计思路简述**：8位像素风（如FC游戏的方块、复古配色）降低学习压力；动态计算过程让哈希的“转换”可见；音效（如字符掉落的“叮”声、排序的“滑动”声）强化操作记忆；合并格子时的“闪光”效果突出去重结果。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：屏幕分为输入区（左）、哈希生成器（中）、哈希仓库（右）。输入区有一个闪烁的光标，仓库是空白的像素格子。
    2. **输入字符串**：用户输入或自动播放字符串（如`abc`），每个字符以彩色方块形式从输入区“掉落”到生成器。
    3. **哈希计算**：生成器显示当前计算步骤（如`hash = 0*133 + 'a' = 97`），哈希值数字动态变化。每处理一个字符，播放“滴答”音效。
    4. **存储哈希值**：计算完成的哈希值（如`97*133 + 'b' + ...`）以数字形式放入仓库的一个格子，格子颜色随机（相同哈希值同色）。
    5. **排序去重**：点击“排序”按钮，仓库的格子像滑块一样左右移动，按哈希值从小到大排列。相同颜色的格子合并（播放“合并”音效），最终显示不同颜色格子的数量（即答案）。
    6. **交互控制**：支持单步执行（逐个字符计算）、自动播放（加速演示）、调速滑块（控制播放速度），并显示当前对应的C++代码片段（如高亮`hash = (hash * base + c) % mod`行）。

  * **旁白提示**：
    - （字符掉落后）“看！字符`a`进入生成器，当前哈希值是`97`（ASCII码）。”
    - （处理第二个字符）“现在乘以基数`133`，加上`b`的ASCII码`98`，哈希值变成`97*133 + 98 = 13099`！”
    - （排序时）“排序后，相同哈希值的格子会排在一起，方便我们统计不同的数量～”

<visualization_conclusion>
通过这个动画，我们能直观看到哈希值的计算过程、存储方式和去重逻辑，像玩游戏一样理解哈希的核心！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
字符串哈希的思想不仅能解决本题，还能处理许多需要快速比较字符串的问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **子串哈希**：预处理字符串的前缀哈希和基数幂次，快速计算任意子串的哈希值（如判断两个子串是否相等）。
    - **哈希表应用**：用哈希值作为键存储字符串，支持O(1)查询（如统计词频）。
    - **哈希与其他算法结合**：与KMP、AC自动机等结合，优化字符串匹配效率。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P12197 Hash Killer I**  
        * 🗣️ **推荐理由**：这道题专门考察哈希冲突的构造，能帮你深入理解哈希的局限性。
    2.  **洛谷 P7350 「MCOI-04」Dream and Strings**  
        * 🗣️ **推荐理由**：需要用哈希处理长字符串的匹配问题，锻炼哈希的灵活应用能力。
    3.  **洛谷 P3538 [POI2012]OKR-A Horrible Poem**  
        * 🗣️ **推荐理由**：结合哈希和数论，用哈希快速判断子串是否为回文，提升综合解题能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了实践中的经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自皎月半洒花)**：“刚开始学哈希时，我总担心冲突，后来发现选好大基数和模数，冲突概率很低。但遇到卡哈希的题，双哈希就能解决～”
>
> **点评**：作者的经验提醒我们，哈希的正确性依赖参数选择，但面对严格数据时，多模哈希是更稳妥的选择。学习时要理解冲突的本质，灵活调整策略。

-----

<conclusion>
通过这篇指南，我们掌握了字符串哈希的核心思想、代码实现和可视化过程。记住，哈希的关键是降低冲突概率，而实践是巩固知识的最佳方法。快去尝试拓展练习，挑战更多哈希相关的题目吧！💪
</conclusion>

---
处理用时：164.43秒
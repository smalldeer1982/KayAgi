# 题目信息

# [JLOI2011] 不重复数字

## 题目描述

给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。

## 说明/提示

对于 $30\%$ 的数据，$n \le 100$，给出的数 $\in [0, 100]$。

对于 $60\%$ 的数据，$n \le 10^4$，给出的数 $\in [0, 10^4]$。

对于 $100\%$ 的数据，$1 \le T\le 50$，$1 \le n \le 5 \times 10^4$，给出的数在 $32$ 位有符号整数范围内。

## 样例 #1

### 输入

```
2
11
1 2 18 3 3 19 2 3 6 5 4
6
1 2 3 4 5 6
```

### 输出

```
1 2 18 3 19 6 5 4
1 2 3 4 5 6
```

# AI分析结果



---
# 💡 Kay的C++算法解析：[JLOI2011] 不重复数字 深入学习指南 💡

<introduction>
今天我们来一起分析“[JLOI2011] 不重复数字”这道题。这道题的核心是去重，但需要高效处理大规模数据。本指南将帮你理解不同解法的思路，掌握哈希表等数据结构的应用，并通过有趣的像素动画直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`哈希表应用（编程技巧应用）`

🗣️ **初步分析**：
解决这道题的关键是“快速判断一个数是否已经出现过”。想象我们有一个“数字登记本”，每次遇到新数字就登记，下次遇到时直接跳过。哈希表（Hash Table）就是这样一个高效的“登记本”，它通过哈希函数将数字映射到特定位置，平均查找和插入时间是O(1)，就像给每个数字分配了一个“专属座位”，找起来特别快！

题解中主要有两种思路：
- **哈希表直接判重**（如unordered_map、手动哈希表）：最直接的方法，逐个检查数字是否在哈希表中，不在则输出并记录。
- **排序+去重+重排序**：将数字和原始位置存为结构体，先按值排序去重（保留第一次出现的），再按原始位置排序输出。这种方法时间复杂度O(n log n)，适合理解排序与去重的结合。

核心算法流程（以哈希表为例）：遍历输入数字→用哈希表判断是否已存在→不存在则输出并记录。可视化时，我们可以用像素动画展示数字“找座位”（哈希计算）、“检查座位是否被占”（哈希表查询）、“坐下登记”（插入哈希表）的过程，关键步骤用颜色高亮（如当前处理的数字、哈希值对应的桶）。

像素动画设计：采用8位复古风格，屏幕左侧是滚动输入的数字像素块，右侧是哈希表的“桶”（每列代表一个哈希值）。每个数字块计算哈希值后滑向对应桶，桶内链表用像素点连接。插入成功时播放“叮”的音效，重复时显示“×”标记，增强操作记忆。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰性、代码规范性、算法效率等角度筛选了以下优质题解，帮你快速掌握不同解法的精髓。
</eval_intro>

**题解一：Rainbow_qwq（来源：洛谷用户）**
* **点评**：这份题解用`unordered_map`直接实现哈希判重，代码简洁易懂。作者提到数据加强后`map`被卡，但`unordered_map`（哈希表）能过，点明了哈希表的效率优势。代码中`clear()`处理多测试用例，边界条件（如多组输入）处理严谨，非常适合初学者学习。

**题解二：Histone（来源：洛谷用户）**
* **点评**：此题解用“排序+去重+重排序”的思路，通过结构体保存数字和原始位置。排序时先按值排序（值相同则按原始位置），去重后再按原始位置排序输出。虽然时间复杂度稍高（O(n log n)），但思路巧妙，适合理解排序与去重的结合应用。

**题解三：skydogli（来源：洛谷用户）**
* **点评**：手动实现哈希表（开散列），用`vector`或邻接表处理哈希冲突。作者详细解释了哈希函数的设计（如模数选择、负数处理），并分析了不同实现（`vector`与邻接表）的优劣势，适合深入理解哈希表的底层原理。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们常遇到以下关键问题，掌握这些能帮你举一反三：
</difficulty_intro>

1.  **难点1：如何高效判断数字是否重复？**
    * **分析**：直接双重循环判断会超时（O(n²)），必须用更高效的方法。哈希表通过哈希函数将数字映射到固定范围，平均查询时间O(1)，是最优选择。例如`unordered_map<int, bool>`直接记录数字是否出现过。
    * 💡 **学习笔记**：处理大规模数据去重，优先考虑哈希表。

2.  **难点2：如何处理负数的哈希值？**
    * **分析**：C++中负数取模可能得到负数下标，需调整为正数。例如用`(x % mod + mod) % mod`确保哈希值非负。手动哈希表实现时，这一步是关键，否则会访问非法内存。
    * 💡 **学习笔记**：哈希函数设计要考虑输入范围（如负数），避免下标越界。

3.  **难点3：哈希冲突如何解决？**
    * **分析**：不同数字可能映射到同一哈希值（冲突），需用“开散列”（链表法）或“闭散列”（探测法）处理。例如手动哈希表用`vector`或邻接表存储冲突元素，查询时遍历链表。
    * 💡 **学习笔记**：开散列（链表）实现简单，适合大部分场景；闭散列（探测）空间利用率高，但冲突多时效率下降。

### ✨ 解题技巧总结
- **哈希表优先**：数据规模大（如n=5e4）时，优先用哈希表（O(1)查询），避免排序（O(n log n)）。
- **负数处理**：哈希函数中用`(x % mod + mod) % mod`确保下标非负。
- **多测试用例**：每组数据前清空哈希表（如`unordered_map::clear()`），避免数据污染。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一个通用的高效实现——用`unordered_map`的简洁版本，适合快速上手。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Rainbow_qwq的题解思路，使用`unordered_map`实现哈希判重，代码简洁高效，适合竞赛快速编写。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    inline int read() {
        char c = getchar(); int x = 0, f = 1;
        while (!isdigit(c)) { if (c == '-') f = -1; c = getchar(); }
        while (isdigit(c)) { x = x * 10 + c - '0'; c = getchar(); }
        return x * f;
    }

    int main() {
        int T = read();
        while (T--) {
            unordered_map<int, bool> vis; // 哈希表记录是否出现过
            int n = read();
            for (int i = 0; i < n; ++i) {
                int x = read();
                if (!vis[x]) { // 未出现过
                    printf("%d ", x);
                    vis[x] = true; // 标记为已出现
                }
            }
            puts(""); // 换行
        }
        return 0;
    }
    ```
* **代码解读概要**：代码通过快读读取输入，用`unordered_map<int, bool> vis`作为哈希表。每组数据开始时清空`vis`，遍历每个数字，若未在`vis`中则输出并标记。时间复杂度O(n)（平均），适合大规模数据。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，看它们的巧妙之处。
</code_intro_selected>

**题解一：Rainbow_qwq（unordered_map判重）**
* **亮点**：代码简洁，利用`unordered_map`的O(1)查询，处理多测试用例时`clear()`确保数据隔离。
* **核心代码片段**：
    ```cpp
    unordered_map<int, bool> s;
    void work() {
        s.clear(); // 清空哈希表
        n = read();
        For(i, 1, n) {
            x = read();
            if (!s[x]) { // 未出现过
                printf("%d ", x);
                s[x] = 1; // 标记
            }
        }
        puts("");
    }
    ```
* **代码解读**：`s.clear()`确保每组数据独立；`if (!s[x])`判断是否已出现，未出现则输出并标记。这里`unordered_map`的键是数字，值是是否出现过的布尔值，逻辑直白。
* 💡 **学习笔记**：`unordered_map`适合快速判重，记得多测试用例时清空！

**题解二：Histone（排序去重）**
* **亮点**：通过结构体保存数字和原始位置，排序后去重，再按原始位置排序输出，思路清晰。
* **核心代码片段**：
    ```cpp
    struct num { int id; int z; };
    bool cmz(num a, num b) { // 按值排序（值相同按id升序）
        return a.z == b.z ? a.id < b.id : a.z < b.z;
    }
    bool cmid(num a, num b) { return a.id < b.id; } // 按id排序

    sort(s + 1, s + n + 1, cmz); // 按值排序
    for (int i = 1; i <= n; i += pd) { // 去重
        pd = 1;
        for (int j = i + 1; j <= n; j++) {
            if (s[i].z == s[j].z) s[j].z = -INF, pd++;
            else break;
        }
    }
    sort(s + 1, s + n + 1, cmid); // 按原始位置排序
    ```
* **代码解读**：结构体`num`保存数字`z`和原始位置`id`。先按`z`排序（相同则`id`升序），这样重复的数字会连续出现，只需保留第一个。去重后按`id`排序，恢复原始顺序。
* 💡 **学习笔记**：排序去重适合理解“保持原始顺序”的处理逻辑。

**题解三：skydogli（手动哈希表）**
* **亮点**：手动实现开散列哈希表，用`vector`存储冲突元素，适合深入理解哈希表原理。
* **核心代码片段**：
    ```cpp
    struct Hash {
        vector<LL> num[Mod], loc;
        bool vis[Mod];
        bool insert(LL a) {
            int v = (a & MD) % Mod; // 计算哈希值
            for (int i = 0; i < num[v].size(); ++i)
                if (num[v][i] == a) return 0; // 冲突时遍历链表
            num[v].push_back(a); // 插入新元素
            if (!vis[v]) vis[v] = 1, loc.push_back(v);
            return 1;
        }
    };
    ```
* **代码解读**：`num[v]`是哈希值为`v`的链表（用`vector`实现），插入时先计算哈希值`v`，遍历`num[v]`检查是否已存在，不存在则插入。`vis`和`loc`记录被使用的桶，方便清空。
* 💡 **学习笔记**：手动哈希表需处理冲突，链表法简单实用！

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解哈希表的工作过程，我们设计一个“像素数字探险”动画，用8位复古风格展示数字如何在哈希表中“找座位”！
\</visualization_intro\>

  * **动画演示主题**：`像素数字的哈希冒险`

  * **核心演示内容**：数字像素块从左侧输入区滑向哈希表（右侧的8列像素桶），计算哈希值后找到对应桶，检查桶内链表是否已有相同数字。若没有则插入链表尾部，否则标记为重复。

  * **设计思路简述**：8位像素风营造轻松氛围，桶的列数对应哈希模数（如Mod=8），每个数字块用不同颜色（如红色表示新数字，灰色表示重复）。插入成功时播放“叮”音效，重复时播放“咚”音效，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：屏幕分为输入区（左）和哈希区（右），哈希区有8列桶（每列顶部标有哈希值0-7）。控制面板有“单步”“自动”“重置”按钮和速度滑块。

    2.  **输入数字**：第一个数字（如“1”）从输入区弹出，显示“当前数字：1”。点击“单步”，数字块滑向哈希区，计算哈希值（如1%8=1），指向桶1。

    3.  **检查桶内链表**：桶1的链表（像素点垂直排列）为空，数字“1”滑入链表尾部，链表长度+1，播放“叮”音效，哈希表标记“1已存在”。

    4.  **处理重复数字**：输入“1”时，数字块滑向桶1，遍历链表发现已有“1”，数字块变灰，播放“咚”音效，跳过输出。

    5.  **自动演示模式**：点击“自动”，算法自动处理所有输入，数字块按顺序滑动，链表动态增长，关键步骤（如冲突、插入）自动高亮。

    6.  **结束状态**：所有数字处理完成，输出区显示去重后的结果，播放胜利音效，哈希表各桶的链表展示最终状态。

  * **旁白提示**：
    - “看！数字1的哈希值是1，它要去桶1找座位～”
    - “桶1的链表是空的，数字1成功坐下！”
    - “又来一个数字1？桶1的链表已经有它了，跳过～”

\<visualization_conclusion\>
通过这个动画，你可以直观看到哈希表如何快速判断重复，理解哈希值计算、冲突处理的过程，比看代码更生动！
\</visualization_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握了哈希表去重后，我们可以尝试更复杂的问题，巩固这种思路！
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：
    - 哈希表不仅能去重，还能用于统计频率（如“出现次数最多的数”）、判断集合交集（如“两个数组的交集”）。
    - 排序去重的思路可用于需要保留顺序的其他问题（如“字符串去重”）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1161 开灯**：用哈希表记录灯的开关状态，判断最终亮着的灯。
    2.  **洛谷 P3370 字符串哈希**：用哈希处理字符串判重，适合练习哈希函数设计。
    3.  **洛谷 P2676 [USACO07DEC]Bookshelf B**：用哈希表记录可用木板，快速查找组合。

-----

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解提到数据加强后`map`被卡，必须用哈希表，这对我们很有启发：
\</insights_intro\>

> **参考经验 (来自Rainbow_qwq)**：“今天早上看见xht37说加强了数据，然后`map/set`就被卡掉了。但是C++11的`unordered_map`是哈希，能过！”

**点评**：这提醒我们，选择数据结构要根据数据规模和特性。`map`（平衡树）的O(log n)查询在数据量大时可能超时，而`unordered_map`（哈希表）的O(1)平均查询更高效。遇到大规模数据去重，优先考虑哈希表！

-----

\<conclusion\>
通过分析“不重复数字”这道题，我们掌握了哈希表的应用、排序去重的思路，还通过像素动画直观理解了算法过程。记住，遇到去重问题，先想哈希表！下次我们再一起挑战更难的算法题，加油～💪
\</conclusion\>

---
处理用时：181.09秒
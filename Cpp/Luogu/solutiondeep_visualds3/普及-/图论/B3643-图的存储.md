# 题目信息

# 图的存储

## 题目描述

给定一个 $n$ 个顶点 $m$ 条边的无向图。请以邻接矩阵和邻接表的形式输出这一张图。

## 说明/提示

样例的图如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/s78y6bsb.png)

数据保证，对于所有数据，$1 \leq n \leq 1000$，$1 \leq m \leq 10^5$，且图无重边无自环。

## 样例 #1

### 输入

```
5 5
1 2
2 3
3 5
1 3
3 4```

### 输出

```
0 1 1 0 0
1 0 1 0 0
1 1 0 1 1
0 0 1 0 0
0 0 1 0 0
2 2 3
2 1 3
4 1 2 4 5
1 3
1 3```

# AI分析结果


### 题目分析报告：图的存储（邻接矩阵与邻接表实现）

---
#### 💡 Kay的C++算法解析：图的存储 深入学习指南 💡

**题目核心**：实现无向图的两种存储方式——邻接矩阵（空间复杂度高但查询快）和邻接表（空间优但查询慢）。本质是**数据结构的选择与应用**。

---

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`编程技巧应用`（数据结构选择与实现）  
🗣️ **初步分析**：  
> 图的存储如同设计城市交通图🗺️：  
> - **邻接矩阵**像「城市直达航班表」：用二维表格直接标记两城市是否有直连航线（1/0），但小城市建大机场浪费空间  
> - **邻接表**像「每个城市的航班清单」：每个城市只需记录自己的直飞目的地，高效利用空间  
>  
> **核心难点**：  
> 1. 邻接矩阵需处理$n\times n$空间（$n\leq1000$）  
> 2. 邻接表需动态管理链表结构  
>  
> **可视化设计思路**：  
> - 像素网格模拟矩阵：用8-bit色块表示边存在性（绿色=有边，灰色=无边）  
> - 邻接表动画：每个顶点伸出像素链条，链条节点动态添加（配链条碰撞音效）  
> - 自动演示模式：逐步展示边插入时两种结构的变化（速度可调）

---

### 2. 精选优质题解参考
**题解（作者：ShanCreeperPro）**  
* **点评**：  
  思路清晰对比两种存储的优劣（如矩阵$O(1)$查询 vs 表$O(p)$查询），精准指出邻接表需用`vector`+结构体实现。  
  亮点在于空间分析：矩阵$O(n^2)$ vs 表$O(m)$，并强调无向图的对称性处理。  
  实践建议明确：稠密图用矩阵，稀疏图用表。不足是未提供具体代码边界处理细节。

---

### 3. 核心难点辨析与解题策略
1. **难点1：邻接矩阵空间优化**  
   * **分析**：$n=1000$时矩阵需$10^6$元素，用`int`可能MLE。优质解用`bool`矩阵或`bitset`压缩空间  
   * 💡 学习笔记：稠密图首选压缩矩阵

2. **难点2：邻接表动态管理**  
   * **分析**：需为每个顶点维护动态列表（如`vector<vector<int>>`）。注意无向图需双向添加边（`u→v`和`v→u`）  
   * 💡 学习笔记：`vector`的`push_back`是邻接表核心操作

3. **难点3：输出格式控制**  
   * **分析**：邻接表输出需对每个顶点的邻居排序（样例输出有序）  
   * 💡 学习笔记：输出前遍历每个`vector`并`sort`

**✨ 解题技巧总结**  
- **技巧1：数据结构选择**：根据$m/n$比值选择存储方式（$m \approx n^2$用矩阵）  
- **技巧2：STL高效应用**：邻接表用`vector<list<int>>`或`vector<vector<int>>`  
- **技巧3：对称处理**：无向图添加边时双向操作

---

### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;

    // 1. 邻接矩阵（bool节省空间）
    vector<vector<bool>> matrix(n+1, vector<bool>(n+1, false));

    // 2. 邻接表（vector数组）
    vector<vector<int>> adjList(n+1);

    // 读边并更新两种结构
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        // 矩阵双向标记
        matrix[u][v] = matrix[v][u] = true;
        // 邻接表双向添加
        adjList[u].push_back(v);
        adjList[v].push_back(u);
    }

    // 输出邻接矩阵
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=n; j++) {
            cout << (matrix[i][j] ? "1 " : "0 ");
        }
        cout << endl;
    }

    // 输出邻接表（排序邻居）
    for(int i=1; i<=n; i++) {
        sort(adjList[i].begin(), adjList[i].end());
        cout << adjList[i].size() << " ";
        for(int neighbor : adjList[i]) {
            cout << neighbor << " ";
        }
        cout << endl;
    }
    return 0;
}
```
**代码解读概要**：  
1. 用`vector<vector<bool>>`避免矩阵空间浪费  
2. 邻接表用`vector<vector<int>>`自动扩展  
3. 输出前对邻居排序满足题目要求  

---

### 5. 算法可视化：像素动画演示
**主题**：`8-bit图存储工厂`  
**设计思路**：用FC游戏风格区分两种结构（矩阵=网格仓库，邻接表=装配流水线）  

**动画步骤**：  
1. **初始化**：  
   - 左侧显示$n\times n$像素网格（初始全灰）  
   - 右侧显示$n$个独立流水线（每个代表顶点）  
   - 控制面板：速度滑块/单步/暂停  

2. **插入边（核心动画）**：  
   - 读边`(u,v)`时：  
     * 矩阵区：$(u,v)$和$(v,u)$格变绿（伴随"叮"音效）  
     * 邻接表区：$u$的流水线加入$v$像素块（机械臂音效），$v$线加入$u$块  

3. **输出阶段**：  
   - 矩阵：逐行扫描网格（扫描线动画+打印机音效）  
   - 邻接表：每个流水线像素块排序（气泡排序动画），后输出  

4. **游戏化元素**：  
   - 每完成$10$条边触发"关卡通过"音效  
   - 错误检测：重边时闪烁红色警告（短促警报声）

---

### 6. 拓展练习与相似问题
**通用技巧迁移**：  
1. 邻接表适用场景：稀疏图遍历（BFS/DFS）  
2. 矩阵适用场景：Floyd最短路径  
3. 链式前向星：竞赛级邻接表优化  

**洛谷推荐**：  
1. **P3916** 图的遍历  
   → 邻接表反向DFS应用  
2. **P3371** 单源最短路径  
   → 邻接表+Dijkstra实践  
3. **P5318** 查找文献  
   → 邻接表DFS/BFS综合训练  

---

### 7. 学习心得与经验分享
本次题解未包含作者调试心得。Kay建议：  
> 测试时注意**边界数据**（$n=1, m=0$）和**输出顺序**（邻接表需排序）  
> 邻接表未排序是常见错误！

---
> 掌握数据结构的选择逻辑比死记代码更重要。下次遇到图论问题，先问自己：这是稀疏图还是稠密图？——Kay

---
处理用时：92.14秒
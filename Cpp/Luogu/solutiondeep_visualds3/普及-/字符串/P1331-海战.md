# 题目信息

# 海战

## 题目背景

在峰会期间，武装部队得处于高度戒备。警察将监视每一条大街，军队将保卫建筑物，领空将布满了 F-2003 飞机。

此外，巡洋船只和舰队将被派去保护海岸线。不幸的是，因为种种原因，国防海军部仅有很少的几位军官能指挥大型海战。因此，他们培养了一些新海军指挥官。军官们选择了“海战”游戏来帮助他们学习。

## 题目描述

在一个方形的盘上，放置了固定数量和形状的船只，每只船却不能碰到其它的船。在本题中，我们认为船是方形的，所有的船只都是由图形组成的方形。

求出该棋盘上放置的船只的总数。

## 说明/提示

对于 $100\%$ 的数据，$1 \le R,C \le 1000$。

## 样例 #1

### 输入

```
6 8
.....#.#
##.....#
##.....#
.......#
#......#
#..#...#```

### 输出

```
There are 5 ships.
```

# AI分析结果

# 💡 Kay的C++算法解析：海战 深入学习指南 💡

<introduction>
  今天我们来一起分析经典的“海战”编程题！这道题就像在玩一款**像素风的找船游戏**——你需要在方形棋盘上找出所有矩形的“船”，还要确保船之间没有“撞在一起”。通过这道题，我们能学会如何用**搜索**和**小技巧**解决连通块统计问题，超有趣！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：搜索（DFS/BFS）+ 连通块统计 + 合法性判断

🗣️ **初步分析**：
解决“海战”问题，关键要搞定两件事：  
1. **判断是否合法**：如果船和船“相邻”（比如两个矩形靠得太近，形成2x2格子里有3个`#`），直接输出“Bad placement.”；  
2. **统计合法船只**：每个合法的船都是一个**矩形连通块**（所有`#`连在一起，且形状是矩形），统计这样的连通块数量就行！  

简单来说，这题就像“找像素块游戏”：  
- 先检查整个棋盘有没有“坏邻居”（2x2格子3个`#`）；  
- 再数有多少个独立的“蓝色像素块”（每个块是矩形）。  

### 核心算法流程
1. **合法性检查**：遍历所有2x2的小格子，如果其中有3个`#`，说明船相邻，直接结束。  
2. **统计船只**：用DFS/BFS遍历所有`#`，把每个连通块标记为“已访问”，每找到一个连通块就计数+1（因为合法情况下每个连通块都是船）。  

### 可视化设计思路
我们会做一个**8位像素风的动画**：  
- 棋盘用黑白像素块表示，`#`是蓝色，`.`是白色；  
- 检查2x2格子时，若发现3个`#`，该区域会闪烁红色，伴随“滴”的警告音效；  
- 统计船只时，每个连通块会被染成不同的像素色（比如黄色、绿色），每染完一个块播放“叮”的音效；  
- 最后显示“找到X艘船”，伴随胜利的8位机音乐！  


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度**、**代码简洁性**、**技巧实用性**三个维度，筛选了3份超棒的题解，帮你快速掌握核心！
</eval_intro>

### 题解一：钱逸凡（赞：214）
* **点评**：这份题解像“标准答案”一样清晰！作者用**2x2格子检查合法性**（这是题目的关键技巧！），再用DFS统计连通块。代码结构超工整：先读入棋盘，再检查所有2x2格子，最后DFS遍历每个`#`并计数。特别是DFS函数里把`#`改成`*`，避免重复统计，这个小技巧超实用！

### 题解二：Dzhao（赞：104）
* **点评**：这题解的**代码简洁到爆炸**！作者同样用2x2格子检查合法性，但统计船只时用了更聪明的方法——**只统计每个矩形的左上角**（即该`#`的左边和上边都是`.`）。这样不用DFS，直接遍历一遍就能数出船只数量，效率超高！适合想“偷懒”但又想写对的同学～

### 题解三：MY（赞：119）
* **点评**：这份题解适合**刚学搜索的同学**！作者用“伪DFS”找矩形：找到一个`#`后，先算出它所在矩形的长和宽，再检查这个矩形内是否全是`#`（如果不是，说明非法）。最后把矩形内的`#`改成`*`，避免重复统计。思路很“接地气”，一步步引导你理解矩形的判断逻辑～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**合法性判断**和**连通块统计**，我们一个个拆解！
</difficulty_intro>

### 1. 关键点1：如何快速判断船是否相邻？
- **难点**：船相邻的情况很多，比如两个矩形靠在一起，但怎么用代码快速判断？  
- **解决策略**：所有相邻的情况都能归结成“2x2格子里有3个`#`”！比如：  
  ```
  ##  或  #.  或  .#  或  ##
  #.      ##      ##      .#
  ```  
  只要检查所有2x2的小格子，若有3个`#`，直接输出非法。  
- 💡 **学习笔记**：找规律比穷举更高效！把复杂的“相邻”问题转化为简单的“2x2格子检查”，这是解题的关键。

### 2. 关键点2：如何统计合法船只数量？
- **难点**：每个船是矩形连通块，但怎么确保统计时不重复？  
- **解决策略**：两种方法任选：  
  1. **DFS/BFS标记法**：找到一个`#`后，用DFS/BFS把整个连通块的`#`改成其他字符（比如`*`），每处理一个连通块计数+1；  
  2. **左上角统计法**：只统计每个矩形的“左上角”（即该`#`的左边和上边都是`.`），因为每个矩形只有一个左上角。  
- 💡 **学习笔记**：统计连通块的核心是“不重复、不遗漏”，选适合自己的方法就行！

### 3. 关键点3：如何处理边界条件？
- **难点**：检查2x2格子时，比如棋盘的最后一行或最后一列，怎么避免数组越界？  
- **解决策略**：遍历的时候，行只到`r-1`，列只到`c-1`（比如棋盘有`r`行`c`列，那么2x2格子的左上角只能是`(i,j)`其中`i < r`且`j < c`）。  
- 💡 **学习笔记**：数组越界是编程的“常见病”，遍历前先想清楚边界！

### ✨ 解题技巧总结
- **技巧A**：用“2x2格子检查”快速判断合法性，避免复杂的相邻判断；  
- **技巧B**：统计连通块时，用DFS/BFS或“左上角法”，确保不重复；  
- **技巧C**：处理数组时，注意边界条件（比如遍历到`r-1`而不是`r`）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合所有优质题解的核心代码**，它结合了“2x2检查”和“DFS统计”，逻辑清晰，适合入门！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合钱逸凡和Dzhao的思路，代码简洁且易理解。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <cstring>
  using namespace std;

  const int MAX = 1010;
  char map[MAX][MAX];
  int r, c;
  // 四个方向（上下左右）
  int dx[] = {0, -1, 1, 0};
  int dy[] = {-1, 0, 0, 1};

  // DFS：把连通块的#改成*
  void dfs(int x, int y) {
      map[x][y] = '*';
      for (int i = 0; i < 4; i++) {
          int nx = x + dx[i];
          int ny = y + dy[i];
          if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && map[nx][ny] == '#') {
              dfs(nx, ny);
          }
      }
  }

  // 检查2x2格子是否有3个#
  bool check(int i, int j) {
      int cnt = 0;
      if (map[i][j] == '#') cnt++;
      if (map[i+1][j] == '#') cnt++;
      if (map[i][j+1] == '#') cnt++;
      if (map[i+1][j+1] == '#') cnt++;
      return cnt == 3;
  }

  int main() {
      cin >> r >> c;
      for (int i = 1; i <= r; i++) {
          for (int j = 1; j <= c; j++) {
              cin >> map[i][j];
          }
      }

      // 第一步：检查合法性
      for (int i = 1; i < r; i++) {
          for (int j = 1; j < c; j++) {
              if (check(i, j)) {
                  cout << "Bad placement." << endl;
                  return 0;
              }
          }
      }

      // 第二步：统计船只数量
      int count = 0;
      for (int i = 1; i <= r; i++) {
          for (int j = 1; j <= c; j++) {
              if (map[i][j] == '#') {
                  count++;
                  dfs(i, j);
              }
          }
      }

      cout << "There are " << count << " ships." << endl;
      return 0;
  }
  ```
* **代码解读概要**：
  1. **输入处理**：读入棋盘的行数`r`和列数`c`，然后读入每个格子的字符；  
  2. **合法性检查**：遍历所有2x2格子，若有3个`#`，输出非法并结束；  
  3. **统计船只**：遍历每个格子，遇到`#`就用DFS把整个连通块标记为`*`，计数+1；  
  4. **输出结果**：打印船只数量。

---

<code_intro_selected>
再看两个**优质题解的核心片段**，学习它们的“亮点”！
</code_intro_selected>

### 题解二：Dzhao的“左上角统计法”
* **亮点**：不用DFS，直接统计每个矩形的左上角，代码超简洁！
* **核心代码片段**：
  ```cpp
  int ans = 0;
  for (int i = 1; i <= n; i++) {
      for (int j = 1; j <= m; j++) {
          // 只有左边和上边都是.的#，才是左上角
          if (g[i][j] == '#' && g[i-1][j] != '#' && g[i][j-1] != '#') {
              ans++;
          }
      }
  }
  ```
* **代码解读**：
  为什么这样能统计船只数量？因为每个矩形的左上角**左边没有`#`（`g[i][j-1] != '#'`）**且**上边没有`#`（`g[i-1][j] != '#'`）**。比如一个2x3的矩形，只有左上角的那个`#`满足这个条件，所以统计它就等于统计了整个矩形！
* 💡 **学习笔记**：找“唯一特征”（比如左上角）能简化统计，这是编程中的“偷懒技巧”～

### 题解三：MY的“伪DFS找矩形”
* **亮点**：用“找矩形的长和宽”来判断合法性，适合理解矩形的本质！
* **核心代码片段**：
  ```cpp
  void dfs(int x, int y) {
      // 找矩形的右边界（shu）和下边界（heng）
      int shu = y;
      while (sea[x][shu] == '#' && shu <= c) shu++;
      shu--;
      int heng = x;
      while (sea[heng][y] == '#' && heng <= r) heng++;
      heng--;

      // 检查矩形内是否全是#
      for (int i = y; i <= shu; i++) {
          int temp = 0;
          for (int j = x; sea[j][i] == '#'; j++) temp++;
          if (temp != heng - x + 1) {
              cout << "Bad placement.";
              exit(0);
          }
      }

      // 把矩形内的#改成*
      for (int i = x; i <= heng; i++) {
          for (int j = y; j <= shu; j++) {
              sea[i][j] = '*';
          }
      }
      ans++;
  }
  ```
* **代码解读**：
  1. **找边界**：从`(x,y)`出发，向右找到矩形的右边界`shu`，向下找到下边界`heng`；  
  2. **检查矩形**：遍历矩形的每一列，看每列的`#`数量是否等于矩形的高度（`heng - x + 1`），如果不等说明不是矩形；  
  3. **标记矩形**：把矩形内的`#`改成`*`，避免重复统计。
* 💡 **学习笔记**：矩形的本质是“所有行的长度相同，所有列的高度相同”，这个片段完美体现了这一点！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看到”算法运行，我设计了一个**8位像素风的动画**，就像玩《吃豆人》一样！
</visualization_intro>

### 动画演示主题
**像素海战：找船大挑战**——你是一名海军指挥官，需要在像素棋盘上找出所有合法的船，避免撞船！

### 设计思路
用**FC红白机的风格**（8位像素、鲜艳的色彩、简单的音效），让你在“玩”中理解算法：
- 棋盘是`10x10`的像素格子（可缩放），`#`是蓝色，`.`是白色；
- 合法性检查时，若发现2x2格子有3个`#`，该区域会闪烁红色，伴随“滴——”的警告音效；
- 统计船只时，每个连通块会被染成黄色，每染完一个块播放“叮”的音效；
- 最后显示“找到X艘船”，伴随胜利的8位机音乐（比如《超级马里奥》的通关音乐）！

### 动画帧步骤
1. **初始化场景**：  
   - 屏幕显示`10x10`的像素棋盘，顶部有“海战”标题（8位字体）；  
   - 下方有“开始”“单步”“重置”按钮，以及速度滑块；  
   - 背景播放轻快的8位BGM（比如《坦克大战》的背景乐）。

2. **合法性检查**：  
   - 一个“像素指针”（红色小箭头）逐个遍历2x2格子；  
   - 若发现3个`#`，该格子会闪烁红色，屏幕弹出“撞船啦！”的文字提示，播放警告音效；  
   - 若所有格子都合法，指针消失，进入统计环节。

3. **统计船只**：  
   - 一个“像素机器人”（蓝色小方块）逐个遍历棋盘，遇到`#`就开始“染色”（把连通块改成黄色）；  
   - 每染完一个连通块，屏幕右上角的计数器+1，播放“叮”的音效；  
   - 所有连通块染完后，计数器显示最终船只数量，播放胜利音乐。

4. **交互控制**：  
   - 点击“单步”：逐帧查看合法性检查和统计过程；  
   - 点击“自动播放”：算法自动运行，速度可通过滑块调节；  
   - 点击“重置”：回到初始状态，重新开始。

### 为什么这样设计？
- **像素风格**：唤起童年游戏记忆，降低学习压力；  
- **音效提示**：用声音强化关键操作（比如“叮”代表找到船，“滴”代表撞船）；  
- **交互控制**：让你自主探索算法步骤，加深理解！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“海战”的思路，你可以解决很多**连通块统计**的问题！比如：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：统计图片中的“连通区域”（比如找出一张照片中的所有物体）；  
- **场景2**：判断迷宫中的“连通路径”（比如从起点到终点是否有通路）；  
- **场景3**：统计棋盘上的“独立棋子”（比如围棋中的“气”判断）。

### 洛谷练习推荐
1. **洛谷 P1451** - 求细胞数量  
   🗣️ **推荐理由**：和“海战”几乎一样！统计所有由数字组成的连通块数量，练手必备～  
2. **洛谷 P1596** - Lake Counting  
   🗣️ **推荐理由**：统计农田中的“水洼”数量（水洼是连通的`W`），需要用DFS/BFS，强化连通块统计能力！  
3. **洛谷 P2895** - Meteor Shower  
   🗣️ **推荐理由**：在迷宫中躲避流星，需要用BFS找最短路径，拓展连通块的应用场景！  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多作者在题解中分享了自己的“踩坑”经历，这些都是宝贵的经验！
</insights_intro>

> **参考经验（来自MY）**：“我一开始想写DFS，但后来发现不用！直接找矩形的长和宽，检查是否全是`#`，这样更简单。”  
> **点评**：这位作者的经验告诉我们——**不一定非要用复杂的算法**！有时候“笨方法”（比如找长和宽）反而更直接、更易理解。  
> **参考经验（来自Dzhao）**：“我太菜了，都被菜哭了！但后来发现用‘左上角统计法’不用DFS，代码超短！”  
> **点评**：不要怕“菜”，多尝试不同的方法，你会发现“偷懒”的技巧～  


<conclusion>
“海战”题就像一场**像素侦探游戏**——你需要用“2x2检查”找出“坏邻居”，用“连通块统计”找出所有船。通过这道题，你学会了**搜索**、**连通块统计**和**找规律**的技巧，这些都是编程的“基本功”！  

记住：编程不是“写复杂的代码”，而是“用最简单的方法解决问题”。下次遇到类似的题目，不妨想想“海战”的思路——先检查合法性，再统计连通块，你一定能解决！  

下次我们再一起探索新的编程挑战，加油！💪
</conclusion>

---
处理用时：112.78秒
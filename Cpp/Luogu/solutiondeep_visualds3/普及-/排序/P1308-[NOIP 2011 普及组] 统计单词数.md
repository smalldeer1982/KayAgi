# 题目信息

# [NOIP 2011 普及组] 统计单词数

## 题目描述

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例 1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例 2）。


## 说明/提示

数据范围

$1\leq $ 第一行单词长度 $\leq10$。

$1\leq $ 文章长度 $\leq10^6$。

noip2011 普及组第 2 题


## 样例 #1

### 输入

```
To
to be or not to be is a question
```

### 输出

```
2 0

```

## 样例 #2

### 输入

```
to
Did the Ottoman Empire lose its power at that time```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：统计单词数 深入学习指南 💡

<introduction>
今天我们来一起分析NOIP2011普及组的经典题目——「统计单词数」。这道题看似简单，却藏着字符串处理的核心技巧，能帮你快速掌握“如何正确操作字符序列”。跟着Kay的思路，我们会一步步拆解问题、理解算法，最后还能通过像素动画直观看到代码的执行过程哦！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理 + 模拟`

🗣️ **初步分析**：
解决「统计单词数」的关键，在于**如何正确处理字符串的“输入、转换、匹配”三步**——就像你整理玩具箱时，要先把散落的积木（文章）按形状（单词）分开，再把所有积木涂成同一种颜色（统一大小写），最后找出和目标积木（给定单词）一模一样的那几个。

具体来说：
- **输入处理**：文章里有空格，不能用`cin`直接读（会截断），得用`getline`读完整行；
- **大小写转换**：把给定单词和文章都转成小写（或大写），消除大小写差异；
- **完全匹配**：必须保证目标单词是文章中的“独立单词”（前后是空格或字符串边界），比如样例2中的“to”不能匹配“Ottoman”，因为它是子串不是独立单词。

题解中常见的两种思路：
1. **拆分单词法**：把文章按空格拆成一个个单词，逐个和目标单词对比（如Eason_lyx的题解）；
2. **前后加空格法**：给目标单词和文章前后都加空格，用`find`函数找完整匹配（如Jelly_Goat、wanghonghui123的题解）——这是个超实用的小技巧！

**可视化设计思路**：我们会用8位像素风动画演示“拆分单词+匹配”的过程——屏幕上是滚动的文章像素字符，目标单词在顶部高亮，每次找到匹配的单词就会闪烁，同时显示当前次数和第一次位置。关键步骤（如转小写、拆分空格、对比单词）会用不同颜色标记，搭配“叮”的音效强化记忆～


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、技巧实用性**三个维度筛选了3份优质题解，它们覆盖了本题的核心解法，非常适合入门学习！
</eval_intro>

### 题解一：Eason_lyx的“拆分单词法”（C++）
* **点评**：这份题解的思路像“剥洋葱”一样直白——先把目标单词和文章转成小写，再按空格拆分文章里的每个单词，逐个对比统计。代码里的变量名（`ci`是目标单词、`dan`是当前拆分的单词、`cur`是第一次位置）特别好懂，还贴心地在文章末尾加了个空格，解决了“最后一个单词没空格”的边界问题。比如样例1中，文章末尾加空格后，最后一个“be”也能被正确拆分，不会漏掉！

### 题解二：Jelly_Goat的“前后加空格法”（C++/Python）
* **点评**：这题解的“前后加空格”技巧太妙了！给目标单词和文章都加个空格（比如目标单词`To`变成` To `，文章变成` to be or not to be is a question `），这样用`find`函数找的时候，只会匹配“前后都是空格”的独立单词，完美避免了子串问题。比如样例2中的“Ottoman”会变成` Ottoman `，而目标单词` to `根本不会出现在里面，直接排除错误匹配！

### 题解三：wanghonghui123的“大写转换法”（C++）
* **点评**：这份题解的代码特别简洁——把目标单词和文章都转成大写，再前后加空格用`find`统计。它的亮点是**用`toupper`函数统一大小写**（比手动算ASCII码更优雅），而且`find`函数的循环写法很标准，适合初学者模仿。比如统计次数时，每次找到后从下一个位置继续找，不会重复计数。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
新手做这道题最容易踩3个“坑”，但只要掌握对应的策略，就能轻松避开！
</difficulty_intro>

### 1. 坑点1：输入处理——文章有空格，怎么读完整？
* **分析**：用`cin`读文章会在第一个空格处截断（比如输入“to be or not”，`cin`只会读到“to”）。必须用`getline`读完整行，但要注意：`cin`读目标单词后会留下一个换行符，得用`getchar()`吃掉它，否则`getline`会读空行！
* 💡 **学习笔记**：读带空格的字符串，用`getline`；读单词后要处理换行符！

### 2. 坑点2：大小写转换——如何统一？
* **分析**：直接比较字符会区分大小写（比如`'T'`和`'t'`不相等）。解决方法是把所有字符转成小写（用`tolower`函数）或大写（用`toupper`函数）。
* 💡 **学习笔记**：统一大小写是字符串不区分大小写匹配的“万能钥匙”！

### 3. 坑点3：完全匹配——如何避免子串？
* **分析**：比如目标单词是“to”，文章里有“tomato”，直接用`find`会匹配到，但这是子串不是独立单词。解决方法有两种：
  - 拆分单词：按空格把文章拆成一个个单词，逐个对比；
  - 前后加空格：给目标和文章都加空格，确保匹配的是“完整单词”。
* 💡 **学习笔记**：完全匹配的核心是“让目标单词的前后都是边界（空格或字符串开头/结尾）”！

### ✨ 解题技巧总结
- **输入技巧**：用`cin`读目标单词，`getchar()`吃换行，`getline`读文章；
- **转换技巧**：用`tolower`/`toupper`统一大小写；
- **匹配技巧**：拆分单词或前后加空格，确保完全匹配。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它综合了“拆分单词法”的优点，思路清晰，覆盖所有边界情况，适合初学者直接模仿！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码来自Eason_lyx的题解，调整了变量名使其更直观，保留了“文章末尾加空格”的关键技巧。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <string>
  using namespace std;

  int main() {
      string target_word, article;  // 目标单词、文章
      int count = 0;                // 出现次数
      int first_pos = -1;           // 第一次出现的位置（初始为-1，表示未找到）

      // 1. 输入处理：读目标单词，处理换行符，读文章
      cin >> target_word;
      getchar();  // 吃掉cin留下的换行符
      getline(cin, article);
      article += " ";  // 文章末尾加空格，确保最后一个单词能被拆分

      // 2. 统一转小写
      for (char& c : target_word) c = tolower(c);
      for (char& c : article) c = tolower(c);

      // 3. 拆分单词并统计
      string current_word;  // 当前拆分的单词
      for (int i = 0; i < article.size(); ++i) {
          if (article[i] == ' ') {  // 遇到空格，说明current_word是一个完整单词
              if (current_word == target_word) {
                  count++;
                  if (first_pos == -1) {  // 第一次找到，记录位置
                      first_pos = i - target_word.size();
                  }
              }
              current_word.clear();  // 清空，准备下一个单词
          } else {
              current_word += article[i];  // 不是空格，追加字符到current_word
          }
      }

      // 4. 输出结果
      if (count == 0) {
          cout << -1 << endl;
      } else {
          cout << count << " " << first_pos << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：
  1. **输入处理**：用`cin`读目标单词，`getchar()`处理换行，`getline`读文章，末尾加空格；
  2. **转小写**：遍历每个字符，用`tolower`转小写；
  3. **拆分统计**：遍历文章，遇到空格就对比当前单词和目标单词，统计次数和第一次位置；
  4. **输出**：根据count的值输出结果。

<code_intro_selected>
接下来看两份优质题解的“亮点片段”，学习更巧妙的技巧！
</code_intro_selected>

### 题解二：Jelly_Goat的“前后加空格法”片段
* **亮点**：用`find`函数快速找完全匹配，代码超简洁！
* **核心代码片段**：
  ```cpp
  string lowwers(string str) {  // 转小写函数
      for (char& c : str) c = tolower(c);
      return str;
  }

  int main() {
      string target = lowwers(inputs());  // 目标单词转小写，前后加空格
      string article = lowwers(inputs()); // 文章转小写，前后加空格
      target = " " + target + " ";
      article = " " + article + " ";

      int pos = article.find(target);  // 第一次出现的位置
      if (pos == -1) { cout << -1; return 0; }

      int count = 0;
      while (pos != -1) {  // 循环找所有匹配
          count++;
          pos = article.find(target, pos + 1);  // 从下一个位置开始找
      }
      cout << count << " " << pos_first << endl;
  }
  ```
* **代码解读**：
  - 给目标和文章都加空格，确保`find`找的是“独立单词”；
  - 用`find`的循环写法统计次数，比拆分单词更高效（尤其是文章很长时）；
* 💡 **学习笔记**：`find`函数是字符串处理的“瑞士军刀”，配合前后加空格能快速解决完全匹配问题！

### 题解三：wanghonghui123的“大写转换法”片段
* **亮点**：用`toupper`统一大写，代码更简洁！
* **核心代码片段**：
  ```cpp
  int main() {
      string target, article;
      cin >> target;
      getchar();
      getline(cin, article);

      // 转大写，前后加空格
      for (char& c : target) c = toupper(c);
      for (char& c : article) c = toupper(c);
      target = " " + target + " ";
      article = " " + article + " ";

      int pos = article.find(target);
      if (pos == -1) { cout << -1; return 0; }

      int count = 0;
      while (pos != -1) { count++; pos = article.find(target, pos + 1); }
      cout << count << " " << pos_first << endl;
  }
  ```
* **代码解读**：
  - `toupper`和`tolower`功能一样，只是转大写；
  - 前后加空格的逻辑和Jelly_Goat的题解一致，但代码更短；
* 💡 **学习笔记**：`toupper`和`tolower`是C++标准库的函数，比手动算ASCII码（比如`c += 32`）更安全！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到字符串处理的过程，Kay设计了一个**复古像素风动画**——像玩FC游戏一样学算法！
</visualization_intro>

### 动画设计方案
#### 1. **整体风格**：8位像素风（仿红白机《超级马里奥》）
- 背景是深灰色的“终端屏幕”，文字是浅绿色的像素字符；
- 目标单词显示在屏幕顶部，用黄色高亮；
- 文章在屏幕中间滚动，每个单词用不同颜色标记（比如当前拆分的单词是蓝色）。

#### 2. **核心演示步骤**
1. **初始化**：
   - 屏幕顶部显示目标单词（比如`to`），黄色高亮；
   - 屏幕中间显示文章（比如`to be or not to be is a question`），浅绿色像素字符；
   - 底部控制面板有“单步”“自动”“重置”按钮，还有速度滑块。

2. **输入处理**：
   - 用像素动画演示`cin`读目标单词，`getchar()`吃掉换行符，`getline`读文章；
   - 文章末尾加空格时，屏幕右下角会弹出“+空格”的提示框，伴随“滴”的音效。

3. **转小写**：
   - 每个字符从大写变成小写时，会闪烁一次绿色；
   - 目标单词和文章转完后，屏幕顶部弹出“转小写完成！”的提示。

4. **拆分与匹配**：
   - 遍历文章时，遇到空格会暂停，当前拆分的单词（比如`to`）会变成蓝色；
   - 对比目标单词：如果匹配，单词会闪烁红色，同时次数+1，第一次位置会显示在屏幕右上角；
   - 每次匹配成功，播放“叮”的音效；匹配失败则播放“嗒”的音效。

5. **结束状态**：
   - 遍历完成后，屏幕中央显示结果（比如`2 0`），伴随胜利音效（类似《魂斗罗》通关的声音）；
   - 如果没找到，显示`-1`，伴随“嗡嗡”的提示音。

#### 3. **交互设计**
- **单步模式**：点击“单步”按钮，动画走一步（比如拆分一个单词、对比一次）；
- **自动模式**：点击“自动”按钮，动画按设定速度播放（速度滑块可调）；
- **重置模式**：点击“重置”按钮，回到初始状态，重新演示。

<visualization_conclusion>
这个动画把抽象的字符串处理变成了“玩游戏”——你能清楚看到每个字符的变化、每个单词的拆分，甚至能听到“匹配成功”的提示音。下次遇到字符串问题，你肯定能立刻想起这个“像素终端”的场景！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的技巧，你可以解决**所有“字符串匹配”类问题**！比如：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：统计文章中“hello”出现的次数（不区分大小写）；
- **场景2**：判断一个单词是否是另一个单词的“独立子串”（比如“cat”在“the cat is black”中是独立的，但在“category”中不是）；
- **场景3**：提取文章中所有以“un”开头的单词（比如“unhappy”“unlock”）。

### 洛谷练习推荐
1. **洛谷 P1012 [NOIP1998 提高组] 拼数**
   - 🗣️ **推荐理由**：练习字符串的比较和排序，巩固“字符串处理”的基础。
2. **洛谷 P1598 垂直柱状图**
   - 🗣️ **推荐理由**：统计字符出现次数，锻炼“遍历字符串+计数”的能力。
3. **洛谷 P2550 [AHOI2001] 彩票摇奖**
   - 🗣️ **推荐理由**：处理字符串的匹配和统计，是本题的“进阶版”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中藏着很多“踩坑经验”，比如：
</insights_intro>

> **参考经验（来自Eason_lyx）**：“我一开始没给文章加空格，导致最后一个单词没被统计到，后来加了个空格才AC！”  
> **点评**：这个经验太重要了！很多新手都会漏掉“最后一个单词没有空格”的情况，加个空格就能轻松解决。下次写代码时，一定要先想“边界情况”！

> **参考经验（来自Jelly_Goat）**：“用find函数的时候，一定要给目标和文章都加空格，否则会匹配到子串！”  
> **点评**：这是“完全匹配”的关键技巧——让目标单词的前后都是边界，就能避免子串问题。记住这个技巧，下次遇到类似问题直接用！


<conclusion>
「统计单词数」是字符串处理的“入门必做题”，它覆盖了输入、转换、匹配三个核心环节。通过这道题，你不仅能掌握`getline`、`tolower`、`find`等函数的用法，还能学会如何处理边界情况。下次遇到字符串问题，记得想起Kay的“像素终端”动画——拆分、转换、匹配，一步一步来，肯定能解决！💪
</conclusion>

---
处理用时：134.50秒
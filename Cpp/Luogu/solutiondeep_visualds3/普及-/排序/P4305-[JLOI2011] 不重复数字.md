# 题目信息

# [JLOI2011] 不重复数字

## 题目描述

给定 $n$ 个数，要求把其中重复的去掉，只保留第一次出现的数。

## 说明/提示

对于 $30\%$ 的数据，$n \le 100$，给出的数 $\in [0, 100]$。

对于 $60\%$ 的数据，$n \le 10^4$，给出的数 $\in [0, 10^4]$。

对于 $100\%$ 的数据，$1 \le T\le 50$，$1 \le n \le 5 \times 10^4$，给出的数在 $32$ 位有符号整数范围内。

## 样例 #1

### 输入

```
2
11
1 2 18 3 3 19 2 3 6 5 4
6
1 2 3 4 5 6
```

### 输出

```
1 2 18 3 19 6 5 4
1 2 3 4 5 6
```

# AI分析结果

# 💡 Kay的C++算法解析：[JLOI2011]不重复数字 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：哈希表（Hash Table）的应用（编程技巧应用）

🗣️ **初步分析**：  
解决“不重复数字”问题，关键是**快速判断一个数是否已经出现过**，并保留第一次出现的顺序。这就像我们整理玩具箱：每个玩具只能放一次，第一次拿到的玩具放进箱子，之后再拿到相同的就直接跳过。**哈希表**就是这个“玩具箱”，它能在**平均O(1)时间**内完成“查找”和“插入”操作，完美解决大范围内的数判重问题。  

### 核心思路与难点
- **核心思路**：遍历每个数，用哈希表记录已出现的数。若当前数未出现，则加入哈希表并输出；否则跳过。  
- **核心难点**：  
  1. 数的范围是32位有符号整数（无法用普通数组作为“玩具箱”）；  
  2. 要保持第一次出现的顺序（不能打乱输入顺序）；  
  3. 高效处理多组数据（每组数据需重置哈希表）。  
- **解决方案**：使用**哈希表**（如`unordered_map`、自定义拉链哈希），将数映射到布尔值（标记是否出现），遍历过程中实时判断并输出。  

### 可视化设计思路
为了直观看到哈希表的工作过程，我设计了一个**8位像素风格的“数字收纳游戏”**：  
- **场景**：屏幕左侧是“输入传送带”（滚动的数字像素块），右侧是“哈希仓库”（排列成网格的桶，每个桶用蓝色像素块表示）。  
- **关键步骤动画**：  
  - 输入数字（如“3”）从传送带滑入，伴随“吱呀”的机械声；  
  - 计算哈希值（如“3%10=3”），对应的桶（第3个）闪烁黄色，表示要检查这个桶；  
  - 若桶内没有“3”（用红色像素块表示已存在的数字），则将“3”放入桶中，伴随“啪”的放入声，并在屏幕下方的“输出框”显示“3”（绿色像素块）；  
  - 若桶内已有“3”，则数字从传送带直接滑走，伴随“叮”的提示声。  
- **交互设计**：支持“单步执行”（逐个数处理）、“自动播放”（调整速度的滑块）、“重置游戏”（清空仓库和传送带）。  


## 2. 精选优质题解参考

### 题解一：unordered_map解法（作者：Rainbow_qwq，赞：76）
* **点评**：  
  这道题的“最简解法”！思路像“查字典”一样直白：用`unordered_map`（哈希表）记录每个数是否出现过。遍历每个数时，若没出现过就输出并标记为已出现。代码**极度简洁**（仅20行左右），变量名`x`（当前数）、`s`（哈希表）含义明确，**时间效率极高**（平均O(Tn)），即使处理5e4的数据也能轻松通过。亮点是使用`unordered_map`替代`map`（`map`是平衡树，O(logn)时间，会被卡），完美利用了哈希表的O(1)优势。

### 题解二：排序+去重+恢复顺序（作者：Histone，赞：48）
* **点评**：  
  这是一种“暴力但有效的思路”，适合理解“去重”的本质。步骤像“整理照片”：先按“照片内容”（数值）排序，去掉重复的“同一张照片”（保留最早的位置），再按“拍摄时间”（原顺序）排序。代码中用结构体`num`保存“数值”和“位置”，两次排序（按数值、按位置）实现去重。虽然时间复杂度是O(Tnlogn)，但思路清晰，适合初学者理解“去重”的逻辑。亮点是**用排序解决大范围数的问题**，避免了哈希表的冲突问题。

### 题解三：自定义拉链哈希（作者：万弘，赞：16）
* **点评**：  
  这是“哈希表的手动实现版”，适合深入理解哈希表的工作原理。代码中用`hash_table`结构体实现“开散列”（拉链法）：每个哈希桶（数组`last`）后面挂一个链表，存储哈希值相同的数。判断时遍历链表，若找到则返回`false`，否则插入链表。亮点是**处理了负数问题**（用`(x%MAXN+MAXN)%MAXN`将负数转为正数），并手动实现了哈希表的“插入”和“查找”操作，适合想深入学习哈希表的同学。


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何处理大范围内的数？
* **分析**：题目中的数是32位有符号整数（范围-2^31~2^31-1），无法用普通数组（如`int vis[1e9]`）存储是否出现过。  
* **解决策略**：使用**哈希表**（将大数映射到小范围的桶中）或**排序+离散化**（将大数转为连续的小整数）。例如`unordered_map`自动处理映射，自定义哈希表用`x%mod`将数映射到`0~mod-1`的桶中。  
* 💡 **学习笔记**：哈希表是处理“大范围内数判重”的神器！

### 2. 难点2：如何保持第一次出现的顺序？
* **分析**：若直接排序去重，会打乱原顺序（比如输入1、3、2，排序后是1、2、3，去重后还是1、2、3，无法恢复原顺序）。  
* **解决策略**：  
  - 方法1（哈希表）：遍历过程中实时判断，第一次出现的数立即输出（不改变顺序）；  
  - 方法2（排序+去重）：用结构体保存“数值”和“原位置”，去重后按原位置排序（恢复顺序）。  
* 💡 **学习笔记**：保持顺序的关键是“记录原位置”或“实时处理”。

### 3. 难点3：如何高效处理多组数据？
* **分析**：每组数据都需要重置哈希表（或数组），若重置操作太慢（如`memset`一个大数组），会超时。  
* **解决策略**：  
  - 哈希表：用`clear()`方法（如`unordered_map::clear()`），仅清空元素，不释放内存；  
  - 自定义哈希表：用`vector`存储桶的位置，清空时仅遍历已使用的桶（避免遍历整个数组）。  
* 💡 **学习笔记**：多组数据的重置操作要“高效”，避免不必要的开销。

### ✨ 解题技巧总结
- **技巧A：优先选择哈希表**：对于“判重”问题，哈希表的时间效率最高（平均O(1)），适合大数据；  
- **技巧B：处理负数的哈希**：用`(x%mod+mod)%mod`将负数转为正数，避免负数下标；  
- **技巧C：排序去重的替代方案**：若哈希表冲突严重（如被卡），可以用排序+去重+恢复顺序的方法（虽然时间稍慢，但稳定）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（unordered_map版）
* **说明**：本代码来自Rainbow_qwq的题解，是“不重复数字”问题的最简实现，适合快速理解核心逻辑。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <unordered_map>
  using namespace std;

  inline int read() { // 快读函数（处理大输入）
      char c = getchar();
      int x = 0, f = 1;
      while (!isdigit(c)) {
          if (c == '-') f = -1;
          c = getchar();
      }
      while (isdigit(c)) {
          x = x * 10 + c - '0';
          c = getchar();
      }
      return x * f;
  }

  int main() {
      int T = read();
      while (T--) {
          unordered_map<int, bool> s; // 哈希表：记录数是否出现过
          int n = read();
          for (int i = 0; i < n; ++i) {
              int x = read();
              if (!s[x]) { // 若未出现过
                  cout << x << " "; // 输出
                  s[x] = true; // 标记为已出现
              }
          }
          cout << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 用`read()`函数快速读取输入（避免`cin`超时）；  
  2. 每组数据用`unordered_map<int, bool>`存储已出现的数；  
  3. 遍历每个数，若`s[x]`为`false`（未出现），则输出并标记为`true`。


### 针对各优质题解的片段赏析

#### 题解一：unordered_map解法（作者：Rainbow_qwq）
* **亮点**：用`unordered_map`实现O(1)判重，代码极简。  
* **核心代码片段**：  
  ```cpp
  unordered_map<int, bool> s;
  for (int i = 0; i < n; ++i) {
      int x = read();
      if (!s[x]) {
          cout << x << " ";
          s[x] = true;
      }
  }
  ```
* **代码解读**：  
  - `unordered_map<int, bool> s`：创建一个哈希表，键是输入的数，值是`bool`类型（是否出现过）；  
  - `if (!s[x])`：判断`x`是否在哈希表中（`s[x]`默认是`false`，若未出现过则进入条件）；  
  - `s[x] = true`：将`x`标记为已出现，下次遇到相同的数就会跳过。  
* 💡 **学习笔记**：`unordered_map`的`[]`运算符会自动插入不存在的键（值为默认值，如`false`），所以判断`!s[x]`即可知道是否未出现过。

#### 题解二：排序+去重+恢复顺序（作者：Histone）
* **亮点**：用结构体保存原位置，排序后恢复顺序。  
* **核心代码片段**：  
  ```cpp
  struct num {
      int id; // 原位置
      int z; // 数值
  } s[50024];

  bool cmz(num a, num b) { // 按数值排序（数值相同按原位置）
      if (a.z != b.z) return a.z > b.z;
      return a.id < b.id;
  }

  bool cmid(num a, num b) { // 按原位置排序
      return a.id < b.id;
  }

  // 去重逻辑：
  sort(s+1, s+n+1, cmz);
  for (int i = 1; i <= n; i += pd) {
      pd = 1;
      for (int j = i+1; j <= n; ++j) {
          if (s[i].z == s[j].z) {
              s[j].z = -2147483659; // 标记为已删除
              pd++;
          } else break;
      }
  }
  sort(s+1, s+n+1, cmid); // 按原位置排序
  ```
* **代码解读**：  
  - `struct num`：保存每个数的“原位置”（`id`）和“数值”（`z`）；  
  - `cmz`函数：按数值从大到小排序（数值相同则原位置小的在前）；  
  - 去重：遍历排序后的数组，将重复的数标记为`-2147483659`（一个不在数据范围内的数）；  
  - `cmid`函数：按原位置从小到大排序，恢复输入顺序。  
* 💡 **学习笔记**：排序去重的关键是“记录原位置”，这样才能在去重后恢复顺序。

#### 题解三：自定义拉链哈希（作者：万弘）
* **亮点**：手动实现哈希表，处理负数问题。  
* **核心代码片段**：  
  ```cpp
  #define MAXN 200011 // 哈希表大小（模数）
  struct hash_table {
      long long last[MAXN], nxt[MAXN], cnt; // 链表：last[桶号]是链表头，nxt[节点号]是下一个节点
      long long val[MAXN]; // 节点存储的数值
      void build() { // 初始化
          cnt = 0;
          memset(last, 0, sizeof(last));
      }
      long long hash(long long x) { // 哈希函数（处理负数）
          return (x % MAXN + MAXN) % MAXN;
      }
      bool insert(long long x) { // 插入x，返回是否成功（未出现过）
          long long f = hash(x), cur = last[f];
          while (cur && val[cur] != x) { // 遍历链表，查找x
              cur = nxt[cur];
          }
          if (cur) return false; // 已存在，返回false
          ++cnt;
          val[cnt] = x;
          nxt[cnt] = last[f]; // 头插法插入链表
          last[f] = cnt;
          return true; // 插入成功，返回true
      }
  } t;
  ```
* **代码解读**：  
  - `hash_table`结构体：用“拉链法”实现哈希表（每个桶后面挂一个链表，存储哈希值相同的数）；  
  - `hash`函数：用`(x % MAXN + MAXN) % MAXN`将负数转为正数（避免负数桶号）；  
  - `insert`函数：遍历链表查找x，若找到则返回`false`（已存在），否则插入链表头部并返回`true`（未存在）。  
* 💡 **学习笔记**：自定义哈希表可以灵活处理负数和冲突问题，适合深入理解哈希表的工作原理。


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《数字收纳小能手》（8位像素风格）
**设计思路**：用“收纳游戏”的形式模拟哈希表判重过程，让学习者像“整理玩具”一样理解哈希表的工作原理。采用FC红白机的配色（如蓝色桶、黄色数字、绿色输出框），加入简单音效（如“吱呀”的传送带声、“啪”的放入声），增强趣味性。

### 动画帧步骤与交互关键点
1. **场景初始化**：  
   - 屏幕左侧是“输入传送带”（滚动的灰色像素条，上面有黄色数字像素块，如“1”、“2”、“3”）；  
   - 屏幕右侧是“哈希仓库”（3x3的蓝色像素桶，编号0~8）；  
   - 屏幕下方是“输出框”（绿色像素条，用于显示输出的数字）；  
   - 控制面板（屏幕右上角）：“开始/暂停”按钮（红色）、“单步”按钮（蓝色）、“重置”按钮（黄色）、速度滑块（灰色）。  

2. **算法启动**：  
   - 点击“开始”按钮，传送带开始滚动（黄色数字从左到右移动），伴随“吱呀”的机械声。  

3. **核心步骤演示**：  
   - **步骤1：输入数字**：传送带中的第一个数字（如“3”）停在“仓库入口”（屏幕中间），伴随“叮”的提示声；  
   - **步骤2：计算哈希值**：数字“3”的哈希值是`3%9=3`（仓库编号3的桶闪烁黄色），屏幕上方弹出文字提示“计算哈希值：3→3”；  
   - **步骤3：查找桶**：遍历桶3中的链表（若为空，则直接进入步骤4；若有数字，如“3”已存在，则进入步骤5）；  
   - **步骤4：插入并输出**：将“3”放入桶3（蓝色桶中出现黄色数字“3”），伴随“啪”的放入声，输出框中显示“3”（绿色像素块）；  
   - **步骤5：跳过重复**：若桶3中已有“3”（红色数字），则数字“3”从传送带滑走，伴随“叮”的提示声，屏幕上方弹出文字提示“已存在，跳过”。  

4. **交互设计**：  
   - **单步执行**：点击“单步”按钮，逐个数处理（适合仔细观察每一步）；  
   - **自动播放**：拖动速度滑块（从“慢”到“快”），调整传送带滚动速度（适合整体观察流程）；  
   - **重置游戏**：点击“重置”按钮，清空仓库、输出框和传送带（重新开始）。  

### 音效设计
- **传送带滚动**：“吱呀~吱呀~”（循环播放）；  
- **数字进入入口**：“叮”（短声）；  
- **计算哈希值**：“滴”（短声）；  
- **插入数字**：“啪”（短声）；  
- **输出数字**：“咚”（短声）；  
- **跳过重复**：“叮”（短声，比进入入口的声音稍高）。  

### 旁白提示（文字气泡）
- “看！传送带送来一个数字‘3’，我们要把它放进仓库里~”（步骤1）；  
- “计算哈希值：3%9=3，所以要放到第3个桶~”（步骤2）；  
- “第3个桶是空的，把‘3’放进去吧！”（步骤4）；  
- “输出框显示‘3’，成功收纳！”（步骤4）；  
- “第3个桶里已经有‘3’了，跳过这个数字~”（步骤5）。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移
哈希表（判重）的应用场景非常广泛，比如：  
- **统计不同元素的个数**（如“统计数组中不同数的数量”）；  
- **检测重复元素**（如“判断数组中是否有重复元素”）；  
- **缓存数据**（如“缓存常用数据，避免重复计算”）。  

### 练习推荐（洛谷）
1. **洛谷 P1138 第k小的数**  
   - 🗣️ **推荐理由**：这道题需要统计不同数的个数，并找到第k小的数，适合练习哈希表的“统计”功能。  
2. **洛谷 P1550 打井问题**  
   - 🗣️ **推荐理由**：这道题需要判断两个点是否属于同一个集合（并查集），但也可以用哈希表记录点的位置，适合练习哈希表的“映射”功能。  
3. **洛谷 P2058 海港**  
   - 🗣️ **推荐理由**：这道题需要统计最近24小时内到港的不同国家的人数，适合练习哈希表的“动态维护”功能（删除过期数据）。  


## 7. 学习心得与经验分享（若有）

### 参考经验（来自Rainbow_qwq）
> “原来用`map`会被卡，换成`unordered_map`就过了！”  

**点评**：这是一个非常实用的经验！`map`是平衡树实现的（O(logn)时间），而`unordered_map`是哈希表实现的（平均O(1)时间），对于大数据（如5e4），`unordered_map`的效率更高。下次遇到“判重”问题，优先选择`unordered_map`哦！

### 参考经验（来自万弘）
> “处理负数的哈希值时，要用`(x%mod+mod)%mod`，否则会出现负数下标！”  

**点评**：这是一个容易忽略的细节！C++中的`%`运算符对于负数会返回负数（如`-3%10=-3`），而数组下标不能是负数，所以需要将负数转为正数。这个技巧适用于所有涉及负数的哈希表问题！


## 结语
本次关于“[JLOI2011]不重复数字”的C++解题分析就到这里。希望这份学习指南能帮助大家理解哈希表的应用，掌握“判重”问题的解决技巧。记住，编程就像“整理玩具”，只要找到合适的“工具”（如哈希表），就能轻松解决问题！下次我们再一起探索新的编程挑战！💪

---
处理用时：175.01秒
# 题目信息

# [CSP-J2020] 直播获奖

## 题目描述

NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\%$，即当前排名前 $w\%$ 的选手的最低成绩就是即时的分数线。

更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\max(1, \lfloor p \times w \%\rfloor)$，其中 $w$ 是获奖百分比，$\lfloor x \rfloor$ 表示对 $x$ 向下取整，$\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。

作为评测组的技术人员，请你帮 CCF 写一个直播程序。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)

---
### 数据规模与约定

各测试点的 $n$ 如下表：

| 测试点编号 | $n=$ |
| :--: | :--: |
| $1 \sim 3$ | $10$ |
| $4 \sim 6$ | $500$ |
| $7 \sim 10$ | $2000$ |
| $11 \sim 17$ | $10^4$ |
| $18 \sim 20$ | $10^5$ |


对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \le w \le 99$。

---
### 提示

在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\%$，则计算 $5 \times 60\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。

## 样例 #1

### 输入

```
10 60
200 300 400 500 600 600 0 300 200 100
```

### 输出

```
200 300 400 400 400 500 400 400 300 300```

## 样例 #2

### 输入

```
10 30
100 100 600 100 100 100 100 100 100 100```

### 输出

```
100 100 600 600 600 600 100 100 100 100```

# AI分析结果

# 💡 Kay的C++算法解析：[CSP-J2020] 直播获奖 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态维护第k大元素（桶排序/对顶堆应用）


🗣️ **初步分析**：  
我们需要解决的问题是**实时计算动态序列中的第k大元素**——每次加入一个选手的成绩后，找出当前前`w%`选手的最低分数线（即第`k`大的数，`k = max(1, ⌊p×w%⌋)`）。  

### 核心算法选择：桶排序（首选） vs 对顶堆（通用）  
- **桶排序**：像“分类整理玩具”——把相同分数的选手放进对应的“桶”（数组），每次要找第k大时，从最高分（600分）开始往下数“桶”里的人数，直到累计人数≥k，此时的分数就是分数线。这种方法**效率极高**（时间复杂度`O(n×600)`），因为题目中分数的最大值是600（值域极小）。  
- **对顶堆**：像“两个叠放的箱子”——用大顶堆存“分数线以下”的选手，小顶堆存“分数线以上”的选手，保持小顶堆的大小为k，堆顶就是分数线。这种方法**通用性强**（适用于任意值域），但代码略复杂。  

### 可视化设计思路  
我们将用**8位像素风格**演示桶排序的过程：  
- **场景**：屏幕左侧是“分数桶”（竖条，高度代表当前分数的人数），右侧是“控制面板”（显示当前k值、累计人数）。  
- **动画步骤**：  
  1. 输入分数时，对应的桶竖条“长高”（闪烁+“叮”的音效）。  
  2. 从600分开始，逐个桶的竖条“发亮”，同时右侧累计人数增加（“滴答”音效）。  
  3. 当累计人数≥k时，当前桶的竖条“爆红”，并显示“分数线：XX分”（“嗡”的胜利音效）。  
- **交互**：支持“单步执行”（逐次输入分数）、“自动播放”（快速演示全过程），以及“重置”按钮。  


## 2. 精选优质题解参考

### 题解一：对顶堆（作者：AzusagawaKaede，赞358）  
* **点评**：  
  这份题解**思路清晰**，详细解释了对顶堆的原理（大顶堆+小顶堆），并给出了完整的代码实现。代码风格规范（变量名如`ma_hp`（大顶堆）、`mi_hp`（小顶堆）含义明确），边界处理严谨（初始化大顶堆为0避免空堆）。对顶堆的方法**通用性强**，即使分数值域更大（如1e9）也能处理，是学习动态维护第k大元素的经典案例。  

### 题解二：桶排序（作者：Eason_AC，赞30）  
* **点评**：  
  这份题解**代码极简**（仅10行核心逻辑），却完美解决了问题。作者抓住了“分数≤600”的关键条件，用桶数组统计人数，从高到低遍历累计人数。代码的**效率极高**（`O(n×600)`），对于1e5的数据完全没问题。这种“利用数据范围优化”的思路，是解决编程题的重要技巧。  

### 题解三：桶排序（作者：GZXUEXUE，赞5）  
* **点评**：  
  这份题解的代码与题解二类似，但注释更详细（如`j`表示当前分数线、`sum`表示累计人数），适合新手理解。作者强调了“一边输入一边计算”的实时性，符合题目的“直播”场景要求。代码中的`max((i+1)*w/100, 1)`正确计算了k值，避免了浮点误差。  


## 3. 核心难点辨析与解题策略

### 1. 动态维护第k大的高效方法  
* **难点**：直接排序（`O(n²logn)`）会超时，如何找到更高效的方法？  
* **策略**：  
  - 若**值域小**（如本题分数≤600），用**桶排序**（`O(n×值域)`）。  
  - 若**值域大**，用**对顶堆**（`O(nlogn)`）。  
* 💡 **学习笔记**：解决问题时，先看数据范围，再选择合适的算法！  

### 2. 避免浮点误差  
* **难点**：计算`p×w%`时，用浮点数可能会有精度问题（如`5×60%`可能算成2.999999）。  
* **策略**：用**整数运算**（`p×w/100`），因为`w`是整数，`p`是当前人数，整数相乘再除以100会自动向下取整。  
* 💡 **学习笔记**：涉及百分比计算时，尽量用整数运算避免精度问题！  

### 3. 处理并列情况  
* **难点**：当有多个选手分数相同时，如何正确统计人数？  
* **策略**：桶排序中，累计人数时直接加上当前分数的总人数（`sum += a[j]`），直到`sum≥k`。此时的`j`就是分数线，因为所有分数≥`j`的选手都算入获奖人数。  
* 💡 **学习笔记**：并列情况不需要特殊处理，累计前缀和即可！  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（桶排序）  
* **说明**：本代码来自题解二（Eason_AC），是桶排序的经典实现，简洁高效。  
* **完整核心代码**：  
  ```cpp
  #include <cstdio>
  using namespace std;

  int a[607]; // a[j]表示分数为j的人数

  int main() {
      int n, w, x;
      scanf("%d%d", &n, &w);
      for (int i = 1; i <= n; ++i) {
          scanf("%d", &x);
          a[x]++; // 将当前分数加入桶
          int k = max(1, i * w / 100); // 计算当前k值
          int sum = 0;
          for (int j = 600; j >= 0; --j) { // 从高到低遍历分数
              sum += a[j];
              if (sum >= k) { // 累计人数≥k时，输出当前分数
                  printf("%d ", j);
                  break;
              }
          }
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读取总人数`n`和获奖率`w`。  
  2. **循环处理每个选手**：  
     - 读取分数`x`，将`a[x]`加1（更新桶）。  
     - 计算当前k值（`max(1, i×w/100)`）。  
     - 从600分开始往下遍历，累计人数`sum`，直到`sum≥k`，输出当前分数`j`。  


### 对顶堆代码片段赏析（题解一）  
* **亮点**：用两个堆维护分数线，通用性强。  
* **核心代码片段**：  
  ```cpp
  #include <queue>
  using namespace std;

  priority_queue<int> ma_hp; // 大顶堆（存分数线以下的选手）
  priority_queue<int, vector<int>, greater<int>> mi_hp; // 小顶堆（存分数线以上的选手）

  void push(int num) {
      if (num >= ma_hp.top()) {
          mi_hp.push(num); // 比大顶堆顶大，加入小顶堆
      } else {
          ma_hp.push(num); // 否则加入大顶堆
      }
      // 调整小顶堆大小为k
      while (mi_hp.size() < now) {
          mi_hp.push(ma_hp.top());
          ma_hp.pop();
      }
      while (mi_hp.size() > now) {
          ma_hp.push(mi_hp.top());
          mi_hp.pop();
      }
  }
  ```
* **代码解读**：  
  - `ma_hp`（大顶堆）存“分数线以下”的选手，堆顶是其中最大的分数。  
  - `mi_hp`（小顶堆）存“分数线以上”的选手，堆顶是其中最小的分数（即分数线）。  
  - `push`函数：将新分数加入对应的堆，然后调整小顶堆的大小为当前k值，确保堆顶是分数线。  
* 💡 **学习笔记**：对顶堆是动态维护第k大元素的通用方法，适合值域大的情况！  


## 5. 算法可视化：像素动画演示（桶排序）

### 动画演示主题：《分数桶探险记》（8位像素风格）  
**设计思路**：用复古的FC游戏风格，让学习者在“玩”中理解桶排序的过程。像素风格的桶、可爱的音效，能激发学习兴趣。  

### 动画帧步骤  
1. **初始化场景**：  
   - 屏幕左侧显示601个“分数桶”（竖条，从0分到600分排列），初始高度为0。  
   - 屏幕右侧是“控制面板”：显示当前k值（如“k=3”）、累计人数（如“sum=0”），以及“开始”“单步”“重置”按钮。  
   - 背景播放8位风格的轻快BGM（如《超级马里奥》的背景音乐）。  

2. **输入分数**：  
   - 点击“单步”按钮，输入一个分数（如“200”），对应的桶（200分的位置）竖条“长高”（从0变成1），伴随“叮”的音效。  
   - 控制面板中的“当前分数”显示为200。  

3. **计算分数线**：  
   - 从600分开始，逐个桶的竖条“发亮”（颜色从灰色变成黄色），同时控制面板中的“sum”增加（如sum=0→sum=0→…→sum=1）。  
   - 当sum≥k时（如k=1，sum=1），当前桶（200分）的竖条“爆红”，并显示“分数线：200分”，伴随“嗡”的胜利音效。  

4. **自动播放**：  
   - 点击“开始”按钮，动画自动播放所有输入步骤，快速演示桶排序的全过程。学习者可以观察到分数线随输入的变化而动态调整。  

### 交互设计  
- **单步执行**：逐次输入分数，观察每一步的变化（适合新手）。  
- **自动播放**：快速演示全过程（适合复习）。  
- **重置**：恢复初始状态，重新开始（适合多次练习）。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
桶排序和对顶堆的思路可以解决**动态维护第k大/小元素**的问题，比如：  
- 实时统计班级成绩的中位数（第n/2大）。  
- 电商平台实时显示销量前10的商品（第10大）。  
- 游戏中实时显示玩家的排名（第k大）。  

### 洛谷练习推荐  
1. **洛谷 P3871 [TJOI2008] 彩灯**  
   - 🗣️ **推荐理由**：练习对顶堆的应用，动态维护第k大元素。  
2. **洛谷 P1168 中位数**  
   - 🗣️ **推荐理由**：用对顶堆解决动态中位数问题，巩固对顶堆的逻辑。  
3. **洛谷 P2070 [NOI2007] 货币兑换**  
   - 🗣️ **推荐理由**：虽然难度较高，但涉及动态维护极值，是对顶堆的进阶应用。  
4. **洛谷 P1801 合并果子**  
   - 🗣️ **推荐理由**：练习堆的基本操作，为学习对顶堆打基础。  


## 7. 学习心得与经验分享（若有）  
> **参考经验（来自题解一：AzusagawaKaede）**：“我最初想用暴力排序，但超时了，后来想到对顶堆，才解决了问题。”  
> **点评**：这位作者的经历很典型——暴力方法虽然容易想到，但往往效率不高。遇到超时问题时，要学会寻找更高效的算法（如对顶堆、桶排序）。  


## 结语  
本次分析了“直播获奖”题的核心算法（桶排序、对顶堆），并通过可视化动画、代码赏析等方式帮助大家理解。记住：**解决问题的关键是观察数据范围，选择合适的算法**！希望这份指南能帮助你提升编程能力，下次遇到类似问题时能举一反三！💪  

---  
**Kay的提示**：如果对桶排序或对顶堆还有疑问，可以尝试用动画演示工具（如Scratch）自己实现一个简单的桶排序动画，加深理解！

---
处理用时：134.90秒
# 题目信息

# [JOI 2018 Final] 寒冬暖炉 / Stove

## 题目描述

JOI 君的房间里有一个炉子。因为 JOI 君已经习惯了寒冷的温度，所以当他一个人在房间里时，他不需要打开炉子。但是，有客人时，他需要打开炉子。有一天，$N$ 位客人将拜访 JOI 君。第 $i$ 个客人 ($1 \leq i \leq N$) 将在时间 $T_i$ 到达，并在时间 $T_i+1$ 离开。任何时间最多有一个客人访问  JOI 君。JOI 君可以随时开火或关火。JOI 君用火柴打开炉子。JOI 君只有 $K$ 根火柴。 因此他最多可以打开炉子 $K$ 次。在一天的开始，炉子是关闭的。当炉子打开时，它需要燃料。因此，JOI 君控制着他何时打开或关闭炉子，他想尽量减少炉子的总运行时间。  
现给定访问 JOI 君的客人数据和 JOI 君拥有的火柴数，请编写一个程序来计算炉子总运行时间的最小值。

## 说明/提示

#### 数据规模与约定  
对于 $100 \%$ 的数据，$1 \leq N \leq 10^5$，$1 \leq K \leq N$，$1 \leq T_i \leq 10^9$（$1 \leq i \leq N$），$T_i < T_{i+1}$（$1 \leq i \leq N-1$）。  
- Subtask $1$（$20$ points）：$N \leq 20$。  
- Subtask $2$（$30$ points）：$N \leq 5000$。  
- Subtask $3$（$50$ points）：没有额外的限制。  
#### 样例说明  
**对于样例 $1$**：三位客人将访问 JOI 君。如果他按以下方式打开和关闭炉子，那么当客人来访时打开炉子，他打开炉子两次，炉子的总运行时间为 $(4-1)+(7-6)=4$。  
- 当第一位客人到来时，他在时间 1 打开炉子。  
- 当第二位客人离开时，他在时间 4 关掉炉子。  
- 当第三位客人到来时，他在时间 6 打开炉子。  
- 当第三位客人离开时，他在时间 7 关掉炉子。  

由于炉子的总运行时间不能小于 $4$，输出 $4$。  
**对于样例 $2$**：JOI 君只能打开一次炉子。因此，他在第一个客人来的时间 $1$ 打开炉子，当第三位客人离开时他在时间 $7$ 关掉炉子。  
请注意，客人离开的时间可以与下一位客人到来的时间相同。  
**对于样例 $3$**：JOI 君在每位客人到来时打开炉子，并在每位客人离开时关掉炉子。  
#### 题目说明：  
来源于 The 17th Japanese Olympiad in Informatics (JOI 2017/2018) Final Round 的 [T1：Stove](https://www.ioi-jp.org/joi/2017/2018-ho/2018-ho-t1-en.pdf)。  
由 @[求学的企鹅](/user/271784) 翻译整理。

## 样例 #1

### 输入

```
3 2
1
3
6```

### 输出

```
4```

## 样例 #2

### 输入

```
3 1
1
2
6```

### 输出

```
6```

## 样例 #3

### 输入

```
3 3
1
3
6```

### 输出

```
3```

## 样例 #4

### 输入

```
10 5
1
2
5
6
8
11
13
15
16
20```

### 输出

```
12```

# AI分析结果

# 💡 Kay的C++算法解析：寒冬暖炉 深入学习指南 💡

<introduction>
  今天我们来一起分析JOI 2018 Final的经典贪心问题——「寒冬暖炉」。这道题能帮你快速掌握**贪心算法**的核心思想，还能学会如何用「选最大收益」的策略解决实际问题。让我们开始吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法（Greedy）

🗣️ **初步分析**：
> 解决「寒冬暖炉」的关键是**贪心算法**——简单说就是“每次选当前最优的选择，最终得到全局最优”。就像你有10块钱想买最多的糖，肯定先挑最大的糖块买对吧？这里的“最大糖块”就是**最大的无客间隔**——我们要通过关闭炉子来节省这些最长的空闲时间，从而最小化总运行时间。

### 题目核心逻辑
- **初始情况**：如果只能开1次炉子（K=1），必须从第一个客人来（T₁）开到最后一个客人走（Tₙ+1），总时间是`(Tₙ+1) - T₁`。
- **节省空间**：相邻客人之间的**无客间隔**是`Tᵢ₊₁ - (Tᵢ+1)`（前一个客人走，到下一个客人来的时间）。每多1根火柴（多1次开关），就能关闭炉子节省一个间隔的时间。
- **贪心策略**：要省最多时间，肯定选**最大的K-1个间隔**减去——因为这些间隔“浪费的时间最多”。

### 可视化设计思路
我会用**FC红白机风格**做动画：
- 时间轴用像素块排成一行，客人用红色方块标记（占`Tᵢ`和`Tᵢ+1`两个位置）；
- 无客间隔用灰色块显示，排序后最大的间隔会变成绿色（表示要节省的部分）；
- 炉子运行时间用黄色线标记，减去间隔时黄色线会“断开”，总时间数字实时更新；
- 加入“单步执行”“自动播放”按钮，还有“叮”的音效（选间隔时）、“啦啦啦”的胜利音效（完成时）。


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度**（是否讲透贪心逻辑）、**代码可读性**（变量名是否易懂）、**实践价值**（是否能直接用于竞赛）三个维度，选了3份优质题解：
</eval_intro>

**题解一：来源（封禁用户，赞9）**
* **点评**：这份题解的思路堪称“标准贪心模板”！作者先算出初始总时间，再用数组存所有间隔，**递增排序后取末尾的K-1个最大间隔**（因为递增排序的最后几个是最大的）。代码简洁高效，变量名`a`（客人时间）、`b`（间隔）清晰易懂，甚至还贴了AC记录——完全可以直接用于竞赛！

**题解二：来源（chlchl，赞5）**
* **点评**：作者的细节处理很贴心！他特意提到“K要减1”（因为第一次开炉子消耗1根火柴），还**复用原数组存间隔**（节省空间）。代码里`cmp`函数直接降序排序，减去前K-1个间隔——逻辑直白，新手也能看懂。

**题解三：来源（love_tide，赞4）**
* **点评**：作者把贪心的核心讲得很透——“让每根火柴发挥最大用处”。他用“如果一直开炉子的时间”作为初始值，再减去最大的间隔，步骤明确。代码里`sort(a+1,a+n,cmp)`直接降序，逻辑链完整，适合入门学习。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**细节理解**和**贪心策略的应用**。我总结了3个核心难点，帮你避开雷区：
</difficulty_intro>

1. **难点1：如何计算初始总时间？**
    * **分析**：初始总时间是“覆盖所有客人的最长时间”——从第一个客人到达（T₁）到最后一个客人离开（Tₙ+1），所以公式是`(Tₙ+1) - T₁`。比如样例1中，T₁=1，T₃=6，初始时间是`6+1-1=6`。
    * 💡 **学习笔记**：初始时间=最后一个客人离开时间 - 第一个客人到达时间。

2. **难点2：如何计算可节省的间隔？**
    * **分析**：相邻客人的无客间隔是“前一个客人走，到下一个客人来的时间”，公式是`Tᵢ₊₁ - (Tᵢ+1)`（下一个到达时间 - 前一个离开时间）。比如样例1中，客人1走在2，客人2来在3，间隔是`3-2=1`；客人2走在4，客人3来在6，间隔是`6-4=2`。
    * 💡 **学习笔记**：间隔=下一个到达时间 - 前一个离开时间。

3. **难点3：为什么要选K-1个最大间隔？**
    * **分析**：每多1根火柴（多1次开关），能节省1个间隔的时间。但第一次开炉子必须用1根火柴，所以最多能节省`K-1`个间隔——选最大的`K-1`个，才能让总时间最小。比如样例1中K=2，只能节省1个最大的间隔（2），总时间从6减到4。
    * 💡 **学习笔记**：贪心的核心是“选对结果影响最大的因素”。


### ✨ 解题技巧总结
- **技巧1：问题抽象**：把“炉子运行时间”转化为“覆盖所有客人的区间长度”，把“开关炉子”转化为“断开区间的间隔”。
- **技巧2：排序简化**：用排序快速找到最大的K-1个间隔（递增排序取末尾，或递减排序取前）。
- **技巧3：边界处理**：注意K=1时直接输出初始时间，K=N时输出N（每个客人单独开一次，总时间就是N个1单位）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心代码**——综合了所有优质题解的优点，逻辑清晰，能直接AC！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自优质题解的整合，用`vector`存间隔（避免数组越界），排序后减去前K-1个最大间隔，适合所有数据规模。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    ios::sync_with_stdio(false); // 输入优化，加速cin
    cin.tie(nullptr);             // 解除cin和cout的绑定

    int n, k;
    cin >> n >> k;
    vector<int> t(n); // 存每个客人的到达时间
    for (int i = 0; i < n; ++i) {
        cin >> t[i];
    }

    if (n == 0) { // 特殊情况：没有客人
        cout << 0 << endl;
        return 0;
    }

    // 初始总时间：最后一个客人离开 - 第一个客人到达
    int total = (t.back() + 1) - t[0];
    vector<int> gaps; // 存相邻客人的无客间隔

    for (int i = 1; i < n; ++i) {
        // 间隔 = 下一个到达时间 - 前一个离开时间（T_i-1 +1）
        int gap = t[i] - (t[i-1] + 1);
        gaps.push_back(gap);
    }

    // 从大到小排序间隔（用rbegin/rend反转迭代器）
    sort(gaps.rbegin(), gaps.rend());

    // 减去前k-1个最大的间隔（最多减gaps.size()个）
    for (int i = 0; i < min(k-1, (int)gaps.size()); ++i) {
        total -= gaps[i];
    }

    cout << total << endl;
    return 0;
}
```
* **代码解读概要**：
  1. 输入优化：`ios::sync_with_stdio(false)`和`cin.tie(nullptr)`加速输入（处理1e5数据时很重要）；
  2. 初始时间计算：`t.back()`是最后一个客人的到达时间，`t.back()+1`是他离开的时间；
  3. 间隔计算：遍历客人时间，计算相邻的无客间隔；
  4. 排序：用`rbegin()`和`rend()`实现从大到小排序；
  5. 减间隔：最多减`k-1`个，避免k超过间隔数量（比如k=100，但只有5个间隔）。


<code_intro_selected>
接下来看3份优质题解的**核心片段**，学他们的“小技巧”：
</code_intro_selected>

**题解一（封禁用户）**
* **亮点**：用数组存间隔，递增排序后取末尾的K-1个（省掉写cmp函数的麻烦）。
* **核心代码片段**：
```cpp
int a[100010], b[100010]; // a存客人时间，b存间隔
ans += a[n] - a[1] + 1;   // 初始时间（等价于(t.back()+1)-t[0]）
for(int i=1;i<n;i++){
    b[i] = a[i+1] - a[i] -1; // 计算间隔
}
sort(b+1, b+n); // 递增排序
// 从末尾取k-1个最大的间隔（i从n-1到n-k+1，共k-1次）
for(int i=n-1;i>=n-k+1;i--){
    ans -= b[i];
}
```
* **代码解读**：比如n=3，k=2，`i`从2到2（只减1次），刚好是最大的间隔。这种方法不用写降序排序的cmp函数，适合新手。
* 💡 **学习笔记**：递增排序后取末尾，等价于降序排序取前。

**题解二（chlchl）**
* **亮点**：复用原数组存间隔，节省空间（不用额外开b数组）。
* **核心代码片段**：
```cpp
const int N = 100000 + 10;
int n, k, ans, t[N];
bool cmp(int x, int y) { return x > y; } // 降序排序

int main() {
    cin >> n >> k;
    k--; // 转化为要减的间隔数（k-1）
    for(int i=1;i<=n;i++) cin >> t[i];
    ans = t[n] - t[1] + 1; // 初始时间
    // 复用t数组存间隔（t[1]到t[n-1]是间隔）
    for(int i=1;i<=n;i++) t[i] = t[i+1] - t[i] -1;
    sort(t+1, t+n, cmp); // 降序排序间隔
    for(int i=1;i<=k;i++) ans -= t[i]; // 减前k个（即k-1个）
    cout << ans << endl;
}
```
* **代码解读**：作者把`k`先减1，这样循环`i<=k`就刚好是减`k-1`次。复用`t`数组存间隔，节省了`b`数组的空间——对1e5数据来说，这点优化很实用！
* 💡 **学习笔记**：数组复用能节省内存，适合大数据规模。

**题解三（love_tide）**
* **亮点**：变量名直观，逻辑链清晰（初始时间→计算间隔→排序→减间隔）。
* **核心代码片段**：
```cpp
int n,k,a[100005];
bool cmp(int x,int y) { return x>y; } // 降序排序

int main(){
    cin>>n>>k;
    for(int i=1;i<=n;i++) cin>>a[i];
    int time = a[n] - a[1] +1; // 初始时间
    // 计算间隔（a[1]到a[n-1]是间隔）
    for(int i=1;i<=n;i++) a[i] = a[i+1] - a[i] -1;
    sort(a+1,a+n,cmp); // 降序排序
    for(int i=1;i<=k-1;i++) time -= a[i]; // 减k-1次
    cout<<time<<endl;
}
```
* **代码解读**：变量名`time`直接表示总时间，`a`数组先存客人时间，再存间隔——逻辑一目了然。新手看这份代码，能快速跟上思路。
* 💡 **学习笔记**：变量名要“见名知意”，能减少调试时间。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”贪心算法的过程，我设计了**FC红白机风格的动画**——就像玩《超级马里奥》一样学算法！
</visualization_intro>

### 🎮 动画演示主题：炉工JOI的节能任务
- **场景**：屏幕上方是**时间轴**（用16x16的像素块排成一行，每个块代表1单位时间）；下方是**控制面板**（开始/暂停、单步、重置按钮，速度滑块）；中间是**JOI的房间**（棕色地板、蓝色墙壁，炉子用黄色方块表示，开的时候闪烁）。
- **元素**：客人用**红色方块**标记（占`Tᵢ`和`Tᵢ+1`两个时间块）；无客间隔用**灰色方块**标记；选中的间隔用**绿色方块**标记；炉子运行时间用**黄色线条**连接客人的红色方块。

### 🕹️ 动画帧步骤（以样例1为例）
1. **初始化**：时间轴显示`1`~`7`的像素块，客人1（`1`~`2`）、客人2（`3`~`4`）、客人3（`6`~`7`）用红色方块标记；炉子是暗黄色（关闭）；控制面板显示“总时间：6”。
2. **计算初始时间**：黄色线条从`1`连到`7`，总时间数字跳动到`6`，伴随“滴”的音效。
3. **计算间隔**：客人1和2之间的`2`~`3`变成灰色（间隔`1`），客人2和3之间的`4`~`6`变成灰色（间隔`2`），每个灰色块上方显示间隔数值。
4. **排序间隔**：灰色块跳动，按从大到小排列（`2`在前，`1`在后），伴随“哗哗”的音效。
5. **选择间隔**：K=2，所以选1个最大的间隔（`2`）——灰色块变成绿色，然后消失；黄色线条断开成两段（`1`~`4`和`6`~`7`）；总时间数字跳动到`4`，伴随“叮”的音效。
6. **胜利状态**：炉子变成亮黄色，屏幕下方弹出像素文字“任务完成！总时间：4”，播放“啦啦啦”的短曲。

### 🎵 音效设计
- **计算间隔**：“嗒”（每算一个间隔响一次）；
- **排序**：“哗哗”（模拟洗牌的声音）；
- **选间隔**：“叮”（确认选最大的间隔）；
- **总时间变化**：“滴”（数字跳动时响）；
- **胜利**：“啦啦啦”（短曲，类似FC游戏的通关音效）。

### 🎯 设计目的
- **像素风格**：营造复古游戏的轻松感，降低学习压力；
- **音效提示**：用声音强化关键操作（比如选间隔时的“叮”，让你记住“要选最大的”）；
- **可视化变化**：黄色线条的“断开”直观展示“关闭炉子节省时间”的过程，总时间的实时更新让你看到贪心的效果。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法的应用非常广——只要问题满足“局部最优→全局最优”，就能用贪心解决。比如：
</similar_problems_intro>

### 🔍 通用思路迁移
- **场景1**：合并石头（选最小的两块合并，省力气）；
- **场景2**：线段覆盖（选结束早的线段，覆盖最多点）；
- **场景3**：找零问题（用最大面额的硬币，凑钱最快）。

### 📚 洛谷练习推荐
1. **洛谷 P1209 [USACO1.3]修理牛棚**
   * 🗣️ **推荐理由**：和本题几乎一样！只是输入的牛棚位置可能无序，需要先排序。练习这题能巩固“选最大间隔”的贪心思路。
2. **洛谷 P7666 双倍经验AT_joi2018ho_a**
   * 🗣️ **推荐理由**：本题的原题！数据和逻辑完全一样，再做一遍能强化代码熟练度。
3. **洛谷 P1090 [NOIP2004 提高组] 合并果子**
   * 🗣️ **推荐理由**：贪心的另一种应用——选最小的两块合并，对比本题的“选最大的间隔减去”，能帮你理解贪心的不同策略。
4. **洛谷 P1803 线段覆盖**
   * 🗣️ **推荐理由**：练习贪心在区间问题中的应用——选结束早的线段，覆盖最多的点，拓展你的思路。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解里的“踩坑经验”比代码更值钱！我摘了2条关键心得：
</insights_intro>

> **经验1（来自chlchl）**：“注意K要减1——第一次开炉子消耗1根火柴，所以能节省的间隔数是K-1。”
> **点评**：这个细节很多人会忘！比如样例2中K=1，减0个间隔，总时间就是初始的6——刚好正确。
> **经验2（来自封禁用户）**：“本题和P1209是双倍经验！”
> **点评**：多做相似题目能帮你“举一反三”——比如P1209的“修理牛棚”，其实就是“用K块木板覆盖牛棚，找最少的木板长度”，和本题的“用K次开关覆盖客人，找最少的炉子时间”逻辑完全一样！


<conclusion>
本次关于「寒冬暖炉」的分析就到这里啦！贪心算法的核心是“抓重点”——选对影响结果最大的因素，就能快速解决问题。记住：多做相似题，多总结细节，你的算法能力会越来越强！下次我们再一起探索新的挑战吧！💪
</conclusion>

---
处理用时：177.74秒
# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果


### 💡 Kay的C++算法解析：小A点菜 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`动态规划（0-1背包方案数问题）`

🗣️ **初步分析**：
> 小A点菜本质是0-1背包的变种，核心是计算**恰好花光M元的方案数**。想象你有一个容量为M的钱包，每种菜就像一件物品（体积=价格），每件物品只能选一次。动态规划就像在填一张记账表：`dp[j]`记录花光j元的方案数。

- **核心思路**：遍历每道菜，更新从M元到菜价的方案数。关键转移：`dp[j] += dp[j-菜价]`（选这道菜则继承剩余金额的方案数）
- **可视化设计**：采用8位像素风模拟点菜过程：
  - 角色"小A"在餐馆移动，点菜时播放"叮"音效
  - 钱袋数值实时变化，方案数用像素数字在屏幕右侧更新
  - 成功花光钱时播放胜利音效+烟花动画
  - 控制面板支持单步/自动模式（调速滑块）

---

#### 2. 精选优质题解参考
**题解一（衡屿睿）**
* **点评**：思路清晰解释三维DP本质（菜品种类×金额），代码规范使用二维数组。亮点在于明确分三种情况讨论转移方程，边界处理严谨（j==a[i]时+1的细节）。虽然空间未优化，但教学价值高，适合初学者理解DP本质。

**题解二（Dream_zhc）**
* **点评**：教学性极强的题解！详细对比二维/一维实现，用示意图解释倒序遍历必要性。亮点在于用"记账本"比喻降维思想，并提供带边界初始化的完整代码（f[0]=1），实践价值满分。

**题解三（WilliamPen）**
* **点评**：最简洁高效的一维实现（仅10行核心代码）。亮点在于强调`f[0]=1`的哲学意义（空方案是基础），代码可直接用于竞赛，变量命名规范（v[]表价格，f[]表方案数）。

---

#### 3. 核心难点辨析与解题策略
1. **状态定义抽象**
   * **分析**：如何定义`dp[i][j]`？优质题解统一用"前i道菜花光j元的方案数"，确保状态覆盖所有子问题
   * 💡 学习笔记：状态应具**无后效性**——当前决策只依赖前序状态

2. **转移方程推导**
   * **分析**：分三种情况（j=菜价/j>菜价/j<菜价）：
     - j=菜价：方案数 = 不选此菜的方案 + 1（单独选）
     - j>菜价：方案数 = 不选方案 + 选方案（继承j-菜价状态）
     - j<菜价：只能不选
   * 💡 学习笔记：**分类讨论**是DP转移的关键思维

3. **空间优化技巧**
   * **分析**：一维数组需倒序遍历！正序会导致`dp[j-a[i]]`被当前轮次污染
   * 💡 学习笔记：**滚动数组**的核心是状态覆盖顺序

✨ **解题技巧总结**
- **边界锚定法**：初始化`dp[0]=1`（0元有1种方案：什么都不选）
- **降维艺术**：当状态仅依赖前一维度，可用滚动数组优化
- **模拟驱动**：用表格手推小样例（如N=3,M=3）验证转移逻辑

---

#### 4. C++核心代码实现赏析
**本题通用核心实现**
```cpp
#include <iostream>
using namespace std;
int dp[10010] = {0}; // dp[j]：花光j元的方案数
int main() {
    int n, m;
    cin >> n >> m;
    dp[0] = 1;  // 关键初始化！
    for (int i = 0; i < n; i++) {
        int price;
        cin >> price;
        for (int j = m; j >= price; j--) // 倒序避免覆盖
            dp[j] += dp[j - price];  // 核心转移方程
    }
    cout << dp[m];
    return 0;
}
```
* **说明**：综合优质题解的最简实现，空间O(M)，时间O(NM)
* **解读概要**：
  1. `dp[0]=1`建立"零元方案"基础状态
  2. 外层遍历菜品，内层倒序遍历金额
  3. 转移方程本质：方案数 = 不选当前菜方案 + 选当前菜方案

**题解片段赏析**  
*题解一（衡屿睿）*
```cpp
if(j==a[i]) f[i][j]=f[i-1][j]+1;    // 刚好花光：继承+新方案
if(j>a[i]) f[i][j]=f[i-1][j]+f[i-1][j-a[i]]; // 选/不选方案叠加
if(j<a[i]) f[i][j]=f[i-1][j];        // 钱不够只能不选
```
> **解读**：显式分类讨论是理解DP本质的最佳方式。当j恰等于菜价时，`+1`代表仅选当前菜的独立方案，这是初学者易漏的关键点。

*题解二（Dream_zhc）*
```cpp
for(int j=m;j>=a[i];j--)
  f[j] += f[j-a[i]];  // 一维数组倒序更新
```
> **解读**：`j>=a[i]`隐式处理j<菜价的情况。倒序遍历确保`f[j-a[i]]`来自**上一轮**状态，如同滑动窗口覆盖旧数据。

---

#### 5. 算法可视化：像素动画演示
* **主题**：《小A的点菜大冒险》- 8位像素风模拟  
* **核心演示**：DP数组更新过程 × 钱袋金额变化  
* **交互设计**：  
  ```mermaid
  graph LR
  控制面板 --> 单步执行
  控制面板 --> 自动播放[速度滑块]
  控制面板 --> 重置
  ```

**关键帧流程**：
1. **初始化**：像素小A站立餐馆，头顶钱袋显示$M，右侧DP数组全0（除dp[0]=1）
2. **上菜动画**：第i道菜从屏幕左侧滑入，显示价格a[i]
3. **决策过程**：
   - 小A思考时播放"滴答"音效
   - 选择菜品：钱袋减少a[i]元，播放"叮"音效
   - DP数组变化：被更新的j值高亮黄框，`dp[j]`数值像素跳动
4. **状态同步**：屏幕底部显示当前转移方程：  
   `dp[${j}] += dp[${j-a[i]}]`
5. **胜利判定**：当dp[M]>0时，钱袋爆炸为金币雨，播放胜利音效

---

#### 6. 拓展练习与相似问题
* **算法迁移场景**：
  1. 彩票选号方案数（数字和恰好为K）
  2. 零件组合达标方案（重量恰好为W）
  3. 路径计数问题（每次移动消耗固定资源）

* **洛谷推荐**：
  1. **P1048 采药** - 0-1背包求最大值  
     `推荐理由：背包问题奠基之作，理解价值最大化的思维转换`
  2. **P1060 开心的金明** - 带权值的0-1背包  
     `推荐理由：在方案数基础上增加价值维度，提升建模能力`
  3. **P1832 素数筛** - 方案数问题的数学变种  
     `推荐理由：用DP思想解决数论问题，拓展算法视野`

---

#### 7. 学习心得与经验分享
> **用户@康师傅的调试经验**：  
> “我在实现时忘记`dp[0]=1`初始化，导致所有方案数少1。通过打印dp表逐行排查才发现”  

**Kay点评**：这个教训极具代表性！DP初始化如同建筑地基：
- `dp[0]=1` 代表"什么都不做"的基础方案
- 建议：编写DP时先用`N=1, M=菜价`的最小样例验证

---

通过本次分析，相信大家已掌握0-1背包方案数的核心思想。记住：DP的本质是用空间换时间，用状态表记录智慧的选择。下次遇到方案统计问题时，不妨先问自己：我的"dp数组"该如何定义？ 💪

---
处理用时：151.94秒
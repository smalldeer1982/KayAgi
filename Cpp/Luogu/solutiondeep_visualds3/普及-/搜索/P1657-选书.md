# 题目信息

# 选书

## 题目描述

学校放寒假时，信息学奥赛辅导老师有 $1,2,3,\cdots,x$ 本书，要分给参加培训的 $x$ 个人，每人只能选一本书，但是每人有两本喜欢的书。

老师事先让每个人将自己喜欢的书填写在一张表上。然后根据他们填写的表来分配书本，希望设计一个程序帮助老师求出所有可能的分配方案，使每个学生都满意。

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le x\le 20$。


$\text{update 2022/03/07}$，阮行止

本题原始数据中，最后一个数据点的 x 为 $0$，期望输出为  $0$。考虑到这个数据不合理，予以删去。现在提交这个题目不会遇到 $x=0$ 的数据点。




## 样例 #1

### 输入

```
5
1 3
4 5
2 5
1 4
3 5```

### 输出

```
2```

# AI分析结果


### 💡 Kay的C++算法解析：选书 深入学习指南 💡

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：**回溯搜索（DFS）**  
🗣️ **初步分析**：
> 解决"选书"问题如同在迷宫中寻找所有出口：每个人站在岔路口（两本喜欢的书），选择一条路后继续前进，遇到死路就返回尝试另一条路。DFS回溯法通过递归模拟这个探索过程，为每个人尝试两种选择，并通过标记数组避免重复选书。核心流程是：
> 1. 逐人尝试选择喜欢的书（两种选择）
> 2. 用布尔数组标记已选书
> 3. 递归处理下一个人
> 4. 成功分配所有人则计数+1
> 5. 回溯时释放当前选择  
> 可视化设计将用像素方块表示书（绿色未选/红色已选），角色移动展示当前选择者，高亮喜欢的书。复古游戏元素包括：
> - 选择成功：8-bit "叮"声
> - 回溯：短促警报声
> - 找到方案：胜利旋律
> - 控制面板：步进/自动播放（AI模拟DFS流程）

---

#### **2. 精选优质题解参考**
**题解一（作者：_xcc_）**  
* **点评**：思路清晰直白，用`like[i][j]`二维数组明确记录喜好关系，代码结构工整（初始化→DFS→输出）。虽然枚举所有书（而非仅两本喜好书）有优化空间，但剪枝逻辑严谨，变量名`flag`/`book`含义明确。实践价值高，可直接用于竞赛。

**题解二（作者：_louhc）**  
* **点评**：创新使用状态压缩技巧，用整数的二进制位表示选书状态（位运算检查/更新），大幅优化空间复杂度。代码简洁但可读性稍低，需理解位运算。亮点在于展示高阶技巧的适用性，特判x=0严谨。

**题解三（作者：Baihua）**  
* **点评**：最符合本题本质的解法，直接存储每人两本喜好书，DFS中仅尝试两次选择。代码规范，注释详细，特判x=0完整。回溯逻辑清晰（标记→递归→释放），是初学者最佳学习模板。

---

#### **3. 核心难点辨析与解题策略**
1. **避免重复选书**  
   * **分析**：需用标记数组（如`used[21]`）实时记录书的状态。优质解法均在递归前检查`!used[book]`，回溯后立即恢复状态。
   * 💡 学习笔记：**标记数组是回溯法的"记忆核心"**

2. **高效处理两种选择**  
   * **分析**：每人仅两本喜好书，应直接尝试而非枚举所有书（题解三的循环仅0/1）。避免无效遍历提升效率。
   * 💡 学习笔记：**针对性循环比全局枚举更高效**

3. **递归终止与结果计数**  
   * **分析**：当处理到第x+1人时说明分配完成，此时方案数+1。需注意计数变量设为全局。
   * 💡 学习笔记：**递归终止条件决定结果正确性**

✨ **解题技巧总结**  
- **状态压缩**：数据较小时用二进制位代替数组（空间优化）
- **剪枝提前**：发现无解立即回溯（如书已被选）
- **边界特判**：对x=0等特殊情况单独处理
- **变量命名**：`used`比`flag`更明确表达"已使用"

---

#### **4. C++核心代码实现赏析**
**通用核心实现（综合优质题解优化）**  
```cpp
#include <iostream>
#include <cstring>
using namespace std;
int x, ans, like[21][2]; 
bool used[21];

void dfs(int person) {
    if (person > x) { ans++; return; }     // 终止条件：所有人分配完成
    for (int i = 0; i < 2; i++) {          // 每人只有两本喜欢的书
        int book = like[person][i];
        if (!used[book]) {                 // 检查书是否可用
            used[book] = true;             // 标记选择
            dfs(person + 1);               // 递归下一人
            used[book] = false;            // 回溯释放
        }
    }
}

int main() {
    cin >> x;
    if (x == 0) { cout << 0; return 0; }  // 特判x=0
    for (int i = 1; i <= x; i++) 
        cin >> like[i][0] >> like[i][1];   // 存储喜好书
    memset(used, false, sizeof(used));     // 初始化标记数组
    dfs(1);                                // 从第1人开始搜索
    cout << ans;
}
```

**题解一片段（_xcc_）**  
```cpp
for(j=1;j<=x;j++) {
    if(flag[j]&&like[i][j]) {       // 检查书j是否可用且被i喜欢
        flag[j]=0;                 // 标记已选
        book[i]=j;                 // 记录i的选择
        if(i==x) s++;               // 终止条件
        else so(i+1);               // 递归
        flag[j]=1;                  // 回溯
    }
}
```
> **代码解读**：通过遍历所有书实现选择，虽效率低于题解三但逻辑直观。`book[i]=j`记录分配情况（非必要），`so(i+1)`递归进入下一层。  
> 💡 学习笔记：**理解回溯的"栈式调用"特性**

**题解二片段（_louhc_）**  
```cpp
if (((1<<a[s][0]) & t) == 0)       // 用位运算检查书是否可选
    dfs(s+1, (1<<a[s][0]) | t);    // 更新状态并递归
```
> **代码解读**：`(1<<book)`创建书的二进制掩码，`& t`检测是否被选，`| t`更新状态。递归传递新状态，避免全局数组。  
> 💡 学习笔记：**状态压缩是空间优化的利器**

---

#### **5. 算法可视化：像素动画演示**
* **主题**：8-bit风"书林探险"  
* **核心演示**：DFS回溯过程（角色移动/书状态变化/路径回溯）  
* **交互设计**：  
  1. **场景**：  
     - 网格显示书（绿块：未选，红块：已选）  
     - 像素小人表示当前选书者  
     - 侧边栏显示递归深度和方案数  
  2. **动态流程**：  
     ```mermaid
     graph LR
     A[开始：第一人站立] --> B{高亮喜好书}
     B -->|选择书1| C[书变红，小人移动至下一人]
     C --> D{下一人有可选书？}
     D -->|是| B
     D -->|否| E[回溯：书变绿，小人返回]
     E --> F{尝试另一本书？}
     F -->|是| B
     F -->|否| G[继续回溯]
     ```
  3. **游戏化元素**：  
     - 音效：选择（叮！），回溯（嘟！），成功（胜利旋律）  
     - 得分：每成功分配一人+10分，完整方案+100分  
     - AI模式：自动展示DFS搜索树（调速滑块控制）  
  4. **技术实现**：  
     - Canvas绘制网格和角色  
     - 关键帧：递归调用/回溯时更新画面  
     - 伪代码同步高亮（如`dfs(2)`时显示对应代码行）

---

#### **6. 拓展练习与相似问题思考**
* **通用技巧迁移**：  
  回溯法适用于组合问题：  
  1. 路径决策（迷宫问题）  
  2. 约束满足（八皇后）  
  3. 子集生成（选数求和）  

* **洛谷推荐**：  
  1. **P1706 全排列问题**  
     🗣️ 回溯法基础练习，理解递归树结构  
  2. **P1219 八皇后**  
     🗣️ 二维回溯经典，练习冲突检测  
  3. **P1036 选数**  
     🗣️ 子集生成+条件判断，强化剪枝思维  

---

#### **7. 学习心得与经验分享**
> **参考经验**：  
> 多位作者强调："x=0需特判，否则DFS输出错误结果"  
>  
> **点评**：  
> 边界条件是竞赛常见陷阱。本题x=0时方案数为0，但未特判的DFS会返回1（递归未执行）。**测试极端数据是调试必备步骤**。

---

**结语**：通过回溯搜索"选书"，我们掌握了DFS的核心框架与优化技巧。记住：好的算法既需要清晰的思路，也需要严谨的边界处理。下次挑战见！🚀

---
处理用时：176.93秒
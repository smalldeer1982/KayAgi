# 题目信息

# [NOI2001] 食物链

## 题目描述

动物王国中有三类动物 $A,B,C$，这三类动物的食物链构成了有趣的环形。$A$ 吃 $B$，$B$ 吃 $C$，$C$ 吃 $A$。

现有 $N$ 个动物，以 $1 \sim N$ 编号。每个动物都是 $A,B,C$ 中的一种，但是我们并不知道它到底是哪一种。

有人用两种说法对这 $N$ 个动物所构成的食物链关系进行描述：

- 第一种说法是 `1 X Y`，表示 $X$ 和 $Y$ 是同类。
- 第二种说法是`2 X Y`，表示 $X$ 吃 $Y$。

此人对 $N$ 个动物，用上述两种说法，一句接一句地说出 $K$ 句话，这 $K$ 句话有的是真的，有的是假的。当一句话满足下列三条之一时，这句话就是假话，否则就是真话。

- 当前的话与前面的某些真的话冲突，就是假话；
- 当前的话中 $X$ 或 $Y$ 比 $N$ 大，就是假话；
- 当前的话表示 $X$ 吃 $X$，就是假话。

你的任务是根据给定的 $N$ 和 $K$ 句话，输出假话的总数。


## 说明/提示

对于全部数据，$1\le N\le 5 \times 10^4$，$1\le K \le 10^5$。


## 样例 #1

### 输入

```
100 7
1 101 1
2 1 2
2 2 3
2 3 3
1 1 3
2 3 1
1 5 5
```

### 输出

```
3
```

# AI分析结果


### 💡 Kay的C++算法解析：食物链 深入学习指南 💡

**<introduction>**  
今天我们来分析NOI2001经典题目《食物链》。这道题考察**关系维护与逻辑推理能力**，通过并查集巧妙处理三类动物的环形食物链关系。本指南将帮助你掌握核心解法，理解算法设计精髓。

---

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`关系型并查集`（扩展域实现）  
🗣️ **初步分析**：
> 想象三个平行世界：A世界（同类）、B世界（猎物）、C世界（天敌）。每个动物在这三个世界都有分身。  
> - **核心思路**：用三倍并查集空间维护"同类-吃-被吃"的环形关系（A→B→C→A）。  
> - **关键难点**：当声明两个动物关系时，需同时验证三个世界的逻辑一致性。  
> - **可视化设计**：像素动画中将用红/蓝/绿三色网格分别表示三个世界，合并时显示彩色粒子碰撞特效，伴随8-bit音效（"叮"表合并，"嘟"表冲突）。

---

### 2. 精选优质题解参考
**题解一：Sooke（扩展域·图解清晰）**  
* **亮点**：  
  - 独创三域模型（本体/猎物/天敌），通过精美图示解释环形关系（A→B→C→A）  
  - 代码规范：用`find(u+n)`直观检查吃与被吃关系  
  - 实践价值：提供可直接用于竞赛的健壮代码，边界处理严谨  

**题解二：檀黎斗·神（带权并查集·代码精简）**  
* **亮点**：  
  - 极致简洁（仅50行）：用权值`0/1/2`表示同类/吃/被吃关系  
  - 空间优化：单倍并查集+数学推导（关系传递用模3运算实现）  
  - 作者心得："三倍关系用模3循环，就像时钟⏰ 12点后又是1点"

---

### 3. 核心难点辨析与解题策略
1. **难点：环形关系传递**  
   * **分析**：当A吃B、B吃C时，必须推导出C吃A。扩展域解法通过三域合并自动满足此性质，带权解法用`(d[x]+d[y])%3`数学维护。  
   * 💡 **学习笔记**：环形关系需闭环验证，避免"关系链断裂"。

2. **难点：跨域逻辑验证**  
   * **分析**：声明同类时需检查是否已存在吃/被吃关系。关键代码：  
     ```cpp
     if(find(x+n)==find(y) || find(x+2*n)==find(y)) // 已存在吃/被吃则冲突
     ```  
   * 💡 **学习笔记**：多关系系统中，否定条件比肯定条件更易验证。

3. **难点：合并的原子性**  
   * **分析**：每句真话需同步更新三个域。带权解法需注意路径压缩时的权值更新：  
     ```cpp
     d[x] = (d[x] + d[fa]) % 3; // 路径压缩时更新关系
     ```  
   * 💡 **学习笔记**：并查集维护关系时，操作需满足"原子性"。

**✨ 解题技巧总结**  
- **关系闭环检查**：声明关系前先验证是否形成逻辑闭环  
- **逆向思维验证**：当直接验证"真"困难时，优先检查"假"的条件  
- **域分离法**：扩展域解法将复杂关系拆解到独立空间处理  

---

### 4. C++核心代码实现赏析
**扩展域完整实现**：
```cpp
#include <cstdio>
const int N = 150005;
int fa[N], n, k, ans;

int find(int x) { 
    return fa[x] == x ? x : fa[x] = find(fa[x]); 
}
int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= 3 * n; i++) fa[i] = i; // 初始化三域
    
    while (k--) {
        int op, x, y;
        scanf("%d%d%d", &op, &x, &y);
        
        // 基础检查：越界或自吃
        if (x > n || y > n || (op == 2 && x == y)) { 
            ans++; continue; 
        }
        
        if (op == 1) { // 同类声明
            if (find(x + n) == find(y) || find(x + 2 * n) == find(y)) {
                ans++; // 已存在吃/被吃关系
            } else { // 合并三域
                fa[find(x)] = find(y);
                fa[find(x + n)] = find(y + n);
                fa[find(x + 2 * n)] = find(y + 2 * n);
            }
        } else { // 捕食声明
            if (find(x) == find(y) || find(x + 2 * n) == find(y)) {
                ans++; // 同类或反吃
            } else { // 合并捕食关系
                fa[find(x)] = find(y + 2 * n);
                fa[find(x + n)] = find(y);
                fa[find(x + 2 * n)] = find(y + n);
            }
        }
    }
    printf("%d", ans);
    return 0;
}
```
**关键代码解读**：
1. `find(x+n)==find(y)`：检查x是否吃y（x的猎物域包含y）
2. 合并三域操作：确保三个平行世界的同步更新
3. 捕食合并逻辑：`x→y`映射为`(x本体→y天敌)+(x猎物→y本体)+(x天敌→y猎物)`

---

### 5. 算法可视化：像素动画演示
* **主题**：8-bit风格"食物链大冒险"  
* **核心演示**：  
  - **三域网格**：屏幕分为三个80x80像素区域（红=同类域，蓝=猎物域，绿=天敌域）  
  - **动物表示**：动物化为像素小兽（🐰=A，🐺=B，🐉=C），带ID标签  
  - **关系动画**：  
    - 声明同类时三色小兽同步跳跃合并，音效"叮！"  
    - 捕食时发射像素箭头`A→B`，B颤抖后变色，音效"砰！"  
    - 冲突时显示❌闪烁，音效"嘟！"  
  - **控制面板**：  
    - 步进/暂停/重置按钮（复古游戏机风格）  
    - 速度滑块（乌龟→兔子）  
    - 关系链展示：当形成A→B→C时自动绘制环形箭头  

---

### 6. 拓展练习与相似问题
1. **洛谷P1525 关押罪犯**  
   🗣️ *推荐理由*：同类扩展域应用，理解"敌人的敌人是朋友"  

2. **洛谷P1892 团伙**  
   🗣️ *推荐理由*：二倍扩展域基础训练，掌握关系拆解思想  

3. **洛谷P1196 银河英雄传说**  
   🗣️ *推荐理由*：带权并查集经典，学习距离维护技巧  

---

### 7. 学习心得与经验分享
> **Sooke的调试经验**："WA了3小时才发现合并时漏了三个域中的某一个——多关系系统必须保证操作的原子性。"  
> **Kay总结**：  
> 1. 扩展域解法直观但耗内存，带权解法抽象但省空间  
> 2. 关键测试数据：`[1,2,3]`声明`1吃2,2吃3`后必须验证`3吃1`  
> 3. 初始化和边界检查决定成败！

**<conclusion>**  
通过本指南，你已掌握食物链问题的双解法精髓。记住：好的算法设计就像食物链——环环相扣，逻辑闭环！下次挑战见！💪

---
处理用时：273.69秒
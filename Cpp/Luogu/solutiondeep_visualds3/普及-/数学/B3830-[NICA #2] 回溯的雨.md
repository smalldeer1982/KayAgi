# 题目信息

# [NICA #2] 回溯的雨

## 题目描述

小 Ran 有两个正整数 $x,y$，她还有两个长度为 $n$ 的正整数序列 $a$ 与 $c$ 满足 $a_ix+y=c_i$ （$1\le i\le n$）。

很可惜的是，她忘记了所有 $a_i$ 的值与 $y$ 的值。她给你了 $x$ 的值与序列 $c$，并希望你能还原出一组 $y$ 的值与序列 $a$ 使得原先的条件被满足。

当然，可能存在很多组这样的解，所以她希望你能最大化 $y$ 的值并输出它（注意到你并不需要输出 $a$ 序列）。如果不能还原出这样一组数，请输出 $-1$ 来报告无解。

## 说明/提示

数据保证，$1 \leq n \leq 10^5$，$1 \leq x \leq 10^{12}$，$1 \leq c_i \leq 10^{18}$。

## 样例 #1

### 输入

```
5 2
4 6 8 10 12```

### 输出

```
2```

## 样例 #2

### 输入

```
5 2
3 6 9 12 15```

### 输出

```
-1```

# AI分析结果


### 💡 Kay的C++算法解析：[NICA #2] 回溯的雨 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数学（同余关系与贪心优化）`

🗣️ **初步分析**：
> 这道题可以想象成拆解"数字包裹"：每个包裹$c_i$由$x$大小的标准盒子和固定填充物$y$组成。核心是发现所有包裹的填充物$y$必须相同，因此$c_i \mod x$必须全部相等（同余关系）。解题分三步：
> 1. 检查是否有包裹太小（$c_i \leq x$），无法容纳至少一个盒子和填充物
> 2. 验证所有包裹是否同余（填充物相同）
> 3. 取最小包裹$c_{\min}$，最大化$y = c_{\min} - x$（相当于只放一个盒子）
>
> **可视化设计思路**：像素动画将展示包裹拆分过程。关键步骤高亮：
> - 红色闪烁：$c_i \leq x$或同余检查失败
> - 绿色高亮：最小包裹$c_{\min}$
> - 盒子移出动画：展示$y = c_{\min} - x$的计算
> - 复古音效：操作提示音（8-bit风格），成功时播放胜利旋律

---

#### 2. 精选优质题解参考
**题解一（作者：fish_shit）**
* **点评**：思路清晰，在单次遍历中同时完成三项任务：检查$c_i \leq x$、验证相邻元素差为$x$倍数（等价同余）、记录最小值。代码简洁高效（$O(n)$），边界处理严谨（即时退出），实践价值高。亮点在于高效性——避免排序，完美处理10^5数据规模。

**题解二（作者：User757711）**
* **点评**：通过排序简化最小值获取和同余检查（比较$c_i \% x$）。代码规范（使用`ios::sync_with_stdio`加速），虽然排序$O(n \log n)$稍慢但可读性强。特别提醒"long long必要性"，体现调试经验价值。

**题解三（作者：Terry2011）**
* **点评**：分阶段检查策略优秀——先验证全局同余（以首元素为基准），再排序取最小值。代码模块化（三阶段处理），避免冗余计算。亮点是未排序时仍保证正确性，适合教学演示。

---

#### 3. 核心难点辨析与解题策略
1. **难点1：同余关系的数学抽象**
   * **分析**：从$a_ix + y = c_i$推导出$c_i \equiv y \pmod{x}$需数学敏锐度。优质题解通过移项和模运算性质证明全局同余必要性。
   * 💡 **学习笔记**：同余关系是隐藏条件，类似"所有包裹填充物颜色相同"。

2. **难点2：最大化y的贪心策略**
   * **分析**：$y = c_i - a_ix$中$a_i \geq 1$，故最小$c_i$对应最小$a_i=1$。需理解：$y$增大要求$a_i$减小，但受限于$c_i \geq x+1$。
   * 💡 **学习笔记**：极值点常在边界（$a_i=1$时$y$最大）。

3. **难点3：高效检查的实现**
   * **分析**：避免$O(n^2)$比较是关键。基准法（首元素模值）或相邻传递法（差%x=0）均$O(n)$，后者需注意负数取模（C++中$-2\%2=0$）。
   * 💡 **学习笔记**：算法优化常源于数学性质（同余传递性）。

✨ **解题技巧总结**
- **数学建模**：将等式转化为模运算问题
- **边界防御**：$c_i \leq x$立即终止，避免后续无效计算
- **贪心极值**：最小值边界即最优解（$y_{max} = c_{\min} - x$）

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**
```cpp
#include <iostream>
using namespace std;

int main() {
    long long n, x, c_i;
    cin >> n >> x;
    long long base = -1, min_c = 1e18;

    for (int i = 0; i < n; ++i) {
        cin >> c_i;
        if (c_i <= x) { // 难点1防御
            cout << -1;
            return 0;
        }
        if (i == 0) base = c_i % x; // 同余基准
        else if (c_i % x != base) { // 难点3检查
            cout << -1;
            return 0;
        }
        if (c_i < min_c) min_c = c_i; // 贪心准备
    }
    cout << min_c - x; // 难点2极值
    return 0;
}
```
* **说明**：综合优质题解，$O(n)$未排序方案。优势：1) 即时终止 2) 基准法避免负数取模问题
* **代码解读概要**：单次遍历完成三大功能：边界检查（行8-11）、同余验证（行13-16）、最小值记录（行17）。基准法（行12）确保全局同余验证高效性。

**题解一（fish_shit）片段赏析**
```cpp
if (c[i] <= x) { // 边界检查
    cout << "-1"; return 0;
}
if (i >= 2 && (c[i] - c[i-1]) % x != 0) { // 相邻同余
    cout << "-1"; return 0;
}
if (c[i] < minn) minn = c[i]; // 更新最小值
```
* **亮点**：相邻差传递同余，空间复杂度$O(1)$
* **代码解读**：相邻元素差为$x$倍数即同余（数学等价）。注意：`(c[i]-c[i-1])%x`在负数时仍正确（C++规范满足$ (a-b) \mod x = 0 \iff a \equiv b \pmod{x} $）
* 💡 **学习笔记**：算法正确性依赖语言规范，需验证边界行为

**题解二（User757711）片段赏析**
```cpp
sort(c + 1, c + 1 + n); // 预处理排序
for (int i = 1; i <= n; i++) {
    if (c[i] <= x || (i >= 2 && c[i] % x != c[i - 1] % x)) {
        cout << -1; return 0; // 合并检查
    }
}
cout << c[1] - x; // 直接取首元素（排序后最小）
```
* **亮点**：排序简化最小值获取，逻辑聚合（行2-4）
* **代码解读**：排序后$c[1]=c_{\min}$且$c[i] \geq c[1]$，故仅需检查$c[1] > x$（隐含在循环中）。同余检查转化为相邻比较。
* 💡 **学习笔记**：排序虽增加$O(n \log n)$，但大幅提升代码可读性

---

#### 5. 算法可视化：像素动画演示
**主题**：`像素拆包工——寻找最大填充物`  
**设计思路**：8-bit风格模拟包裹拆分过程，FC游戏界面增强理解：
- **UI布局**：  
  🎮 左侧：包裹队列（像素块标$c_i$值）  
  🛠️ 右侧：控制面板（开始/暂停/步进/速度条）  
  📦 底部：盒子($x$)+填充物($y$)展示区

**动画关键帧**：
1. **初始化**（复古音效：电子启动声）
   - 包裹入场：$c_i$值显示于像素方块（随机颜色）
   - 基准标记：首包裹闪烁绿框（同余基准）

2. **检查阶段**（音效：扫描"嘀"声）
   - 指针移动：高亮当前检查包裹
   - 失败场景：$c_i \leq x$时包裹变红爆炸（音效：故障声）；同余失败时包裹闪烁红框（音效：错误音）

3. **极值定位**（音效：发现"叮"声）
   - 最小包裹标记：持续绿框+星形动画
   - 数值显示：$c_{\min} \to \boxed{x} + \boxed{y}$ 动态拆分

4. **验证阶段**（音效：拆箱"咔嚓"声）
   - 填充物固定：$y$独立显示（金色方块）
   - 其他包裹拆分：$c_j - y$拆为若干$x$盒子（动画：盒子飞出计数）

5. **完成**（音效：胜利旋律+烟花动画）
   - $y_{max}$显示：金色大字 + 8-bit庆祝特效

**技术实现**：
```javascript
// 伪代码：同余检查
function checkCongruence() {
  playSound('scan'); // 扫描音效
  for (let i = 0; i < packages.length; i++) {
    highlight(package[i]); // 高亮当前包裹
    if (package[i].value <= x) {
      explode(package[i]); // 爆炸动画
      playSound('error');
      showOutput(-1);
      return;
    }
    if (i > 0 && package[i].value % x !== base) {
      flashRed(package[i]); // 红框闪烁
      playSound('wrong');
      showOutput(-1);
      return;
    }
    updateMin(package[i]); // 更新最小值
  }
}
```

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：
1. **同余应用**：线性方程$ax+b=c$的解条件（如[NOIP2012] 同余方程）
2. **极值贪心**：边界取最值思想（如分配问题中最小资源分配）
3. **模运算优化**：避免整数溢出的模技巧（如大数哈希）

**洛谷推荐**：
1. **P1082 [NOIP2012] 同余方程**  
   🗣️ 扩展欧几里得算法基础，理解$ax \equiv 1 \pmod{b}$的数学本质
2. **P1516 青蛙的约会**  
   🗣️ 同余方程在区间跳跃的应用，强化模运算建模能力
3. **P2421 [NOI2002] 荒岛野人**  
   🗣️ 多同余系统验证，需结合循环优化

---

#### 7. 学习心得与经验分享
> **参考经验**（多位作者）："未使用`long long`导致WA是常见错误，尤其$x \leq 10^{12}$时中间结果可能溢出"  
> **点评**：数据范围意识是竞赛编程核心素养。建议：  
> 1) 见$10^5$以上输入优先选`long long`  
> 2) 比较$c_i \leq x$时自动类型提升（`1LL*x`）  
> 3) 模运算前用`llabs`防负数干扰

---

通过本次分析，我们深入理解了同余关系的应用与贪心极值策略。记住：数学建模是优化算法的钥匙！下次挑战见！💪

---
处理用时：348.23秒
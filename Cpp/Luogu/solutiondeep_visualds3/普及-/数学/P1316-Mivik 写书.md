# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果

---
# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡

<introduction>
今天我们来一起分析“Mivik 写书”这道C++编程题。这道题看似是字符串问题，实则核心是**数学中的容斥原理**和**并查集的灵活应用**。本指南将帮你梳理“期望”到“总和”的转化、容斥的巧妙思路，以及如何用代码实现这些逻辑。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（容斥原理） + 编程技巧（状压枚举 + 并查集）

🗣️ **初步分析**：
解决“Mivik 写书”的关键，是把“期望复杂度”转化为**所有可能字符串的本质不同子串总数**除以“总字符串数（mⁿ）”。而计算“总数”的核心是**容斥原理**——就像我们数苹果时，先算所有可能的子串，再减去重复计算的部分，反复调整直到准确。

### 核心思路拆解
1. **问题转化**：期望 = 总本质不同子串数 / mⁿ → 只需计算总本质不同子串数S(n,m)，再乘m⁻ⁿ的模逆元。
2. **容斥计算S(n,m)**：对于每个子串长度x，枚举它在原字符串中**出现的位置集合S**（用二进制表示，比如S=101表示子串出现在第1和第3位）。
3. **并查集约束**：如果子串在多个位置出现，这些位置的字符必须相同——用并查集合并相同字符的位置，统计“自由选择的字符块数k”，则满足条件的字符串数为mᵏ。
4. **容斥系数**：每个集合S的贡献是 (-1)^(popcount(S)+1) × mᵏ（奇数个位置加，偶数个位置减，抵消重复）。

### 可视化设计思路
我们会用**8位像素风格**展示算法流程：
- 用“像素格子”表示字符串的每个位置（比如n=3时是3个并排的像素块）；
- 用“二进制灯”表示子串出现的位置（灯亮=该位置是子串起点）；
- 合并并查集时，把相同字符的像素块染成同色；
- 每一步弹出“文字气泡”解释：“现在合并位置1和3，因为它们必须相同！”；
- 关键操作（比如计算贡献）伴随“叮”的像素音效，完成时播放“胜利”音效。


## 2. 精选优质题解参考

<eval_intro>
我从“思路清晰度、代码可读性、实践价值”三个维度筛选了3份优质题解，都是**容斥+并查集**的经典实现：
</eval_intro>

**题解一：Huasushis（新手向，5星）**
* **点评**：这份题解把容斥的逻辑讲得特别明白！作者从“枚举子串长度→枚举出现位置→用并查集约束字符相同→计算贡献”一步步推导，连“为什么用容斥”都解释清楚了。代码风格非常规范：`qp`函数（快速幂）、`getfa`函数（并查集查找）命名明确，循环注释详细。尤其是`sol`函数里的“位运算+并查集”逻辑，把复杂的约束转化为“合并连通块”，特别适合新手模仿。

**题解二：Reunite（代码完整，4星）**
* **点评**：题解的“分长度处理”思路和上一份一致，但代码更简洁。作者用`work`函数处理每个子串长度，`Find`函数实现并查集路径压缩，`calc`函数计算快速幂。美中不足的是注释较少，但核心逻辑和上一份题解一脉相承，适合已经理解容斥思路的同学巩固代码实现。

**题解三：rainygame（代码简洁，4星）**
* **点评**：这份题解的代码是最简洁的！作者用`iota`初始化并查集（`iota(f, f+x+1, 0)`等价于`for(int i=0;i<=x;i++)f[i]=i`），用`__builtin_parity`判断二进制中1的个数的奇偶性，大大简化了代码。虽然注释少，但逻辑紧凑，适合想学习“代码优化”的同学参考。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有三个，我们逐一拆解：
</difficulty_intro>

1. **难点1：期望到总和的转化**
    * **分析**：期望=（所有字符串的复杂度之和）/（总字符串数）。总字符串数是mⁿ，所以只需计算总和再乘m⁻ⁿ的模逆元（因为模运算中除法等价于乘逆元）。
    * 💡 **学习笔记**：遇到“期望”问题，先想“能不能转化为总和除以总数”——这是概率题的常用技巧！

2. **难点2：容斥系数的理解**
    * **分析**：为什么贡献是(-1)^(popcount(S)+1)？比如子串出现2次时，我们会多算一次，所以要减去；出现3次时，多减了一次，要加回来——这就是容斥的“加减交替”逻辑。
    * 💡 **学习笔记**：容斥的核心是“抵消重复计算”，系数的奇偶性由“集合大小”决定。

3. **难点3：并查集处理字符约束**
    * **分析**：如果子串在位置i和j出现，那么这两个位置的字符必须相同——用并查集把这些位置合并成一个连通块，每个连通块只能选一个字符，所以自由选择的块数是“连通块数+未被覆盖的位置数”。
    * 💡 **学习笔记**：并查集是处理“等价关系”的神器，比如“字符必须相同”就是一种等价关系！


### ✨ 解题技巧总结
- **技巧1：问题转化**：把“期望”转化为“总和÷总数”，避免直接计算概率。
- **技巧2：状压枚举**：用二进制数表示“子串出现的位置集合”，适合n≤20的小数据。
- **技巧3：并查集压缩**：处理字符相同的约束时，用路径压缩优化并查集的查找速度。
- **技巧4：模逆元**：除法在模运算中用逆元代替，快速幂求逆元（费马小定理）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**（综合Huasushis题解的思路，注释更详细），帮你理解整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自Huasushis的题解，调整了注释，更适合新手阅读。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define mod 1000000007ll
    using namespace std;
    using ll = long long;

    int n;
    ll m;
    ll ans = 0; // 总本质不同子串数
    int fa[25]; // 并查集数组

    // 快速幂：计算x^y mod mod
    ll qp(ll x, ll y) {
        ll res = 1;
        while (y) {
            if (y & 1) res = res * x % mod;
            x = x * x % mod;
            y >>= 1;
        }
        return res;
    }

    // 并查集查找（路径压缩）
    int getfa(int x) {
        return x == fa[x] ? x : fa[x] = getfa(fa[x]);
    }

    // 处理子串长度为x的情况
    void sol(int x) {
        int maxS = 1 << (n - x + 1); // 出现位置集合的最大值（二进制位数是“可能的起点数”）
        int mask = (1 << x) - 1;     // 用于截取最近x位的掩码（比如x=2时，mask=11）
        for (int S = 1; S < maxS; ++S) { // 枚举所有非空的出现位置集合
            // 初始化并查集：每个位置自成一个集合
            for (int j = 0; j < x; ++j) fa[j] = j;
            int c = 0; // 记录最近x位的出现情况
            int free = 0; // 未被子串覆盖的位置数（自由选择的字符数）
            for (int j = 0; j < n; ++j) { // 遍历原字符串的每个位置
                // 更新c：左移一位，加上当前位置是否是子串起点
                c = (c << 1) | ((S >> j) & 1);
                c &= mask; // 只保留最近x位
                if (c == 0) {
                    free++; // 未被覆盖，自由选择
                } else {
                    // 找到c中最右边的1（第一个出现的子串起点）
                    int rightOne = c & -c;
                    int root = getfa(__builtin_ctz(rightOne)); // __builtin_ctz求最低位1的位置
                    // 合并c中所有1对应的位置（这些位置的字符必须相同）
                    int t = c - rightOne;
                    while (t) {
                        int pos = __builtin_ctz(t & -t);
                        fa[getfa(pos)] = root;
                        t -= t & -t;
                    }
                }
            }
            // 统计子串内部的连通块数（每个连通块只能选一个字符）
            for (int j = 0; j < x; ++j) {
                if (j == getfa(j)) free++;
            }
            // 计算贡献：(-1)^(popcount(S)+1) * m^free
            ll cnt = qp(m, free);
            if (__builtin_parity(S)) { // popcount(S)是奇数→加
                ans = (ans + cnt) % mod;
            } else { // 偶数→减（加mod避免负数）
                ans = (ans - cnt + mod) % mod;
            }
        }
    }

    int main() {
        scanf("%d%lld", &n, &m);
        // 处理所有可能的子串长度（1~n）
        for (int i = 1; i <= n; ++i) sol(i);
        // 计算期望：ans / m^n = ans * inv(m^n) mod mod
        ll inv_total = qp(qp(m, n), mod - 2);
        printf("%lld\n", ans * inv_total % mod);
        return 0;
    }
    ```
* **代码解读概要**：
    1. **快速幂`qp`**：计算模意义下的幂和逆元（比如`qp(m, n)`是mⁿ，`qp(qp(m,n), mod-2)`是m⁻ⁿ的逆元）。
    2. **并查集`getfa`**：路径压缩优化，加快查找速度。
    3. **核心函数`sol`**：处理每个子串长度x，枚举出现位置集合S，用并查集合并约束位置，计算自由字符数，最后累加贡献。
    4. **主函数**：遍历所有子串长度，计算总和，最后乘逆元得到期望。


<code_intro_selected>
接下来看**优质题解的核心片段**，点出各自的亮点：
</code_intro_selected>

**题解一：Huasushis（亮点：位运算+并查集的清晰结合）**
* **亮点**：用`c = (c << 1) | ((S >> j) & 1)`动态维护最近x位的出现情况，用`mask`截取有效位，把“子串出现的位置”转化为“当前位置的约束”。
* **核心代码片段**：
    ```cpp
    c = (c << 1) | ((S >> j) & 1);
    c &= mask;
    if (c == 0) free++;
    else {
        int rightOne = c & -c;
        int root = getfa(__builtin_ctz(rightOne));
        int t = c - rightOne;
        while (t) {
            int pos = __builtin_ctz(t & -t);
            fa[getfa(pos)] = root;
            t -= t & -t;
        }
    }
    ```
* **代码解读**：
    - `c`是一个“滑动窗口”，记录最近x位是否是子串起点（比如x=2时，c=10表示当前位置是子串起点，前一位不是）。
    - `__builtin_ctz(rightOne)`：求`rightOne`中最低位1的位置（比如rightOne=100→位置2），对应子串中的第几个字符。
    - 合并所有`c`中的1对应的位置：这些位置的字符必须相同，所以用并查集合并到同一个根。
* 💡 **学习笔记**：位运算可以高效维护“滑动窗口”的状态，是状压枚举的关键！

**题解二：Reunite（亮点：分函数处理，逻辑清晰）**
* **亮点**：用`work`函数处理每个子串长度，`Find`函数实现并查集，`calc`函数计算快速幂，代码结构模块化。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=tt;i++)
        for(int j=1;j<=len;j++) mp[a[i]+j-1]|=(1<<j);
    for(int i=1;i<=n;i++){
        int xx[25]={0},mm=0;
        for(int j=1;j<=len;j++)
            if(mp[i]&(1<<j)) xx[++mm]=j;
        for(int j=2;j<=mm;j++){
            int u=Find(xx[1]),v=Find(xx[j]);
            if(u!=v) fa[u]=v;
        }
    }
    ```
* **代码解读**：
    - `mp[i]`记录位置i被哪些子串的字符覆盖（比如`mp[i]=101`表示位置i是子串的第1和第3个字符）。
    - 遍历每个位置i，收集所有覆盖它的子串字符位置（`xx`数组），然后合并这些位置（它们必须相同）。
* 💡 **学习笔记**：模块化代码能让逻辑更清晰，适合多人协作或调试。

**题解三：rainygame（亮点：代码简洁，用STL简化操作）**
* **亮点**：用`iota`初始化并查集（`iota(f, f+x+1, 0)`），用`__builtin_parity`判断奇偶性，代码行数最少。
* **核心代码片段**：
    ```cpp
    memset(c, -1, sizeof(c)); iota(f, f+x+1, 0);
    for (int j(0); j<n-x+1; ++j) if (i>>j&1){
        for (int k(0); k<x; ++k) if (~c[j+k]) f[find(k)] = find(c[j+k]); else c[j+k] = k;
    }
    ```
* **代码解读**：
    - `iota(f, f+x+1, 0)`：把`f[0]~f[x]`初始化为0~x（等价于循环赋值），是STL的便捷函数。
    - `~c[j+k]`：判断`c[j+k]`是否不是-1（`~-1=0`，`~其他数非0`），用于记录子串位置的第一次出现。
* 💡 **学习笔记**：善用STL函数可以简化代码，但要理解其原理（比如`iota`的作用）。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到容斥的过程，我设计了一个**8位像素风的动画**，主题是“像素小画家写字符串”：
</visualization_intro>

### 动画设计总览
- **风格**：FC红白机风格（8位像素、256色），背景是浅灰色网格，字符串位置用“彩色方块”表示，二进制状态用“小灯”表示。
- **核心演示**：展示“子串长度x=2，出现位置集合S=10（二进制）”的容斥过程——子串出现在第2位，计算自由字符数和贡献。

### 动画帧步骤（以n=3, x=2, S=10为例）
1. **初始化场景**：
   - 屏幕上方显示3个像素方块（代表字符串位置1~3），初始颜色为白色。
   - 下方显示“控制面板”：“开始”按钮、“单步”按钮、“速度滑块”（1~5档）。
   - 右侧显示“信息栏”：当前子串长度x=2，出现集合S=10（二进制灯亮第2位）。
   - 播放8位风格的背景音乐（比如《超级马里奥》的开头旋律）。

2. **枚举出现位置**：
   - 点击“开始”，二进制灯第2位亮起（表示子串出现在第2位）。
   - 弹出文字气泡：“现在处理子串长度2，出现在位置2！”，伴随“叮”的音效。

3. **并查集合并约束**：
   - 子串出现在位置2，覆盖位置2和3（因为x=2）。
   - 位置2和3的方块变成浅蓝色，弹出文字气泡：“位置2和3必须相同，合并它们！”，伴随“咔嗒”音效。
   - 并查集的根节点（比如位置2）显示为深灰色，位置3指向它。

4. **计算自由字符数**：
   - 位置1未被覆盖，保持白色，自由字符数+1。
   - 子串内部的连通块数：位置2和3合并为1块，自由字符数+1。
   - 信息栏显示“自由字符数=2”，弹出文字气泡：“总共有2个自由选择的字符块！”。

5. **计算贡献**：
   - 集合S=10（popcount=1，奇数），贡献是+ m²。
   - 信息栏显示“贡献=+m²”，伴随“叮”的音效。

6. **结束与重置**：
   - 动画完成，播放“胜利”音效（比如《塞尔达传说》的宝箱声）。
   - 点击“重置”，回到初始状态，可以选择其他子串长度或出现集合。

### 交互设计
- **单步执行**：点击“单步”按钮，动画走一步，方便仔细观察每一步的变化。
- **速度调节**：滑块调整动画速度（1档最慢，5档最快）。
- **算法比较**：（可选）同时展示“S=11”（出现在位置1和2）的情况，对比两种集合的贡献差异。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
容斥原理是组合数学的“ Swiss Army Knife”，能解决很多“去重计数”问题。掌握本题的思路后，可以尝试以下练习：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：统计区间内与n互质的数的个数（容斥掉n的质因数倍数）。
- **场景2**：统计字符串中不同的子序列数目（容斥掉重复的子序列）。
- **场景3**：计算多个集合的并集大小（容斥原理的经典应用）。

### 洛谷练习推荐
1. **洛谷 P1450** - 硬币购物
   - 🗣️ **推荐理由**：这道题用容斥原理处理“超过限制的硬币使用”，是容斥的经典应用，能帮你巩固“加减交替”的逻辑。
2. **洛谷 P2522** - [HAOI2011]Problem b
   - 🗣️ **推荐理由**：题目是求区间内与n互质的数的个数，需要用容斥结合前缀和，是本题“容斥+数论”的延伸。
3. **洛谷 P3197** - [HNOI2008]越狱
   - 🗣️ **推荐理由**：这道题用容斥计算“不越狱的情况”，再用总数减去它，是“补集思想+容斥”的典型，能帮你拓展思路。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
几位作者的心得都提到了“容斥的难点在于理解系数”和“并查集的灵活应用”，其中Huasushis的话特别有启发：
</insights_intro>

> **参考经验 (来自Huasushis)**：“我最开始卡了很久，因为不知道怎么处理子串重复的问题。后来看了oi wiki的容斥部分，才明白可以用二进制枚举出现位置，用并查集约束字符相同。这让我意识到，组合题的关键是‘把问题转化为等价的计数模型’。”

**点评**：这位作者的经验很真实！很多时候，我们不是不会写代码，而是不会“建模”——把实际问题转化为数学模型（比如本题的“子串出现位置→二进制集合→并查集约束”）。遇到组合题时，不妨先画个小例子（比如n=2，m=2），手动算一遍，再找规律。


<conclusion>
本次关于“Mivik 写书”的分析就到这里。这道题的核心是**容斥原理**，但“状压枚举+并查集”的组合让它变得生动有趣。记住：容斥的本质是“抵消重复”，并查集是“处理等价关系”的神器，两者结合能解决很多看似复杂的问题。下次遇到“计数+去重”的问题，不妨想想这道题的思路！💪
</conclusion>
---

---
处理用时：168.60秒
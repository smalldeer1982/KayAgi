# 题目信息

# 『MdOI R1』GCD? GCD!

## 题目描述

灵喜欢 $\mathrm{gcd}$，也就是 **最大公约数**。如果你不知道什么叫做最大公约数，你可以访问 [最大公约数 - OI Wiki](https://oi-wiki.org/math/gcd/)。

灵给了你一个正整数 $n$，要你把它分成三个 **互不相等的** 正整数 $a,b,c$ 之和，使得 $\mathrm{gcd}(a,b,c)$ 最大。

## 说明/提示

【样例解释】

将 $12$ 分成 $2+4+6$，可以证明 $\gcd(2,4,6)=2$ 为可能达到的最大值。

将 $27$ 分成 $3+6+18$，可以证明 $\gcd(3,6,18)=3$ 为可能达到的最大值。

$5$ 无法分成三个互不相等的正整数之和，输出 `-1`。

---

【数据范围】

**本题采用捆绑测试。**

| 子任务编号 | $n\leq$ | 分值 |
| :--------: | :-----: | :--: |
|     1      |  $50$   |  17  |
|     2      |  $500$  |  19  |
|     3      | $10^5$  |  23  |
|     4      | $10^9$  |  41  |

对于 $100\%$ 的数据，$1\le T \le 100$，$1\le n\le 10^9$。

## 样例 #1

### 输入

```
3
12
27
5
```

### 输出

```
2
3
-1
```

# AI分析结果


# 💡 Kay的C++算法解析：『MdOI R1』GCD? GCD! 深入学习指南 💡

<introduction>
今天我们共同探索一道巧妙结合数学与编程的题目——『MdOI R1』GCD? GCD!。这道题要求将正整数n拆分为三个互不相等的正整数之和，使它们的最大公约数尽可能大。让我们一起揭开其中的数学奥秘！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学建模与约数枚举`

🗣️ **初步分析**：
> 解决本题的关键在于**数学转化思维**。想象我们要组装一辆赛车（最大公约数g），需要三个不同型号的零件（a, b, c），它们的总重量正好是n克。我们发现所有零件都是g的倍数（a=gA, b=gB, c=gC），那么总重量n = g×(A+B+C)。要使赛车尽可能重（g最大），就要让零件数量(A+B+C)尽可能少，但最少需要6个"单位零件"（1+2+3的组合）。

- **核心思路**：寻找最小的k≥6使得k整除n，则最大公约数g = n/k
- **算法流程**：
  1. 特判n<6时输出-1
  2. 枚举i从1到√n，检查n的约数
  3. 若i≥6则候选g = n/i
  4. 若n/i≥6则候选g = i
  5. 取候选最大值
- **可视化设计**：采用像素风"零件组装"动画，展示g从大到小枚举过程。当找到合适的k时，三个像素小人（红/蓝/绿）举起对应零件拼成赛车，伴随"叮！"音效和闪光。

---

## 2. 精选优质题解参考

<eval_intro>
根据思路清晰度、代码规范性和算法效率，我精选了以下3个≥4星的优质题解：

**题解一：(来源：FCBM71)**
* **点评**：此题解直击问题本质——将最大公约数问题转化为寻找最小合数约数k≥6。思路推导清晰（n = g×k，k=A+B+C≥6），代码实现简洁高效（O(√n)复杂度）。变量命名规范（g, k含义明确），边界处理完整（特判n<6）。亮点在于用数学转化避开复杂计算，是竞赛标准解法。

**题解二：(来源：老咸鱼了)**
* **点评**：采用两段式枚举优化：先从小到大找小约数，找不到时再从大到小找大约数。代码结构工整（v标志位控制流程），实践性强。虽性能略逊于单循环枚举，但展示了重要的算法优化思路——当主流解法失效时如何调整策略。

**题解三：(来源：xh39)**
* **点评**：通过"单位零件"比喻生动解释算法原理（k≥6对应1+2+3）。代码实现包含关键优化：预先计算√n避免重复调用sqrt。注释详细说明每个步骤的数学含义，特别适合初学者理解约数枚举的本质。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点：

1.  **数学建模转化**
    * **分析**：难点在于将抽象的gcd最大化转化为具体的约数枚举问题。优质题解通过设a=gA, b=gB, c=gC，建立n=g(A+B+C)的等式关系，将原问题转化为寻找最小k≥6使得k|n。
    * 💡 **学习笔记**：复杂问题常蕴含简单数学模型，设未知量建立等式是破题钥匙。

2.  **约数枚举优化**
    * **分析**：当n>10^9时，暴力枚举所有约数不可行。解法均采用i=1→√n的枚举范围，同时检查i和n/i两个约数。时间复杂度从O(n)优化到O(√n)。
    * 💡 **学习笔记**：枚举到平方根即可覆盖所有约数对，是数论问题核心优化手段。

3.  **边界条件处理**
    * **分析**：需同时处理多种特殊情况：n<6无解；k<6无效；n为质数时g=1。题解通过特判分支实现鲁棒性。
    * 💡 **学习笔记**：完善的边界处理体现代码健壮性，是竞赛编程必备技能。

### ✨ 解题技巧总结
<summary_best_practices>
通过本题可总结以下通用技巧：
</summary_best_practices>
- **技巧一：数学语言转化** → 将编程问题转化为数学等式或不等式
- **技巧二：对称优化** → 利用问题对称性减少枚举量（如约数成对出现）
- **技巧三：分段处理** → 对大数据和小数据采用不同策略（如n≤36单独处理）
- **技巧四：预存计算** → 避免在循环内重复调用昂贵函数（如预存√n）

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先展示一个综合优质题解思路的通用实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合FCBM71和xh39的优化思路，包含预存平方根和双向枚举
* **完整核心代码**：
```cpp
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    int T, n;
    cin >> T;
    while (T--) {
        cin >> n;
        if (n < 6) {
            cout << -1 << endl;
            continue;
        }
        
        int ans = 0;
        int sq = sqrt(n); // 预存平方根优化
        
        // 第一段：枚举小约数
        for (int i = 1; i <= sq; i++) {
            if (n % i != 0) continue;
            if (n / i >= 6) ans = max(ans, i);    // i是小约数
            if (i >= 6) ans = max(ans, n / i);     // n/i是大约数
        }
        
        // 第二段：处理未覆盖的大约数
        if (ans == 0) {
            for (int i = sq; i >= 1; i--) {
                if (n % i == 0 && n / i >= 6) {
                    ans = i;
                    break;
                }
            }
        }
        
        cout << (ans ? ans : 1) << endl;
    }
    return 0;
}
```
* **代码解读概要**：
> 代码分为三部分：1) 特判n<6 2) 枚举1→√n找约数对，检查k≥6条件 3) 特殊情况下反向枚举。关键变量sq避免重复计算平方根，ans记录最大有效g值。

---
<code_intro_selected>
各优质题解核心片段赏析：
</code_intro_selected>

**题解一：(来源：FCBM71)**
* **亮点**：最简洁的数学转化实现
* **核心代码片段**：
```cpp
for(int i=6; i*i<=n; i++) {
    if(n%i==0) {
        cout<<n/i<<endl;
        return;
    }
}
// 补充反向枚举...
```
* **代码解读**：
> 直接枚举k（即代码中的i）而非g，当找到最小k≥6时立即输出g=n/k。为什么从6开始枚举？因为这是k的最小可能值，符合"找最小k"的数学推导。
* 💡 **学习笔记**：逆向思考——枚举k而非g，减少变量转换。

**题解二：(来源：老咸鱼了)**
* **亮点**：双循环确保完备性
* **核心代码片段**：
```cpp
for(int i=6; i*i<=n; i++) {   // 正向枚举
    if(n%i==0) { /*...*/ }
}
for(int i=5; i>=1; i--) {      // 反向枚举
    if(n%i==0 && n/i>=6) { /*...*/ }
}
```
* **代码解读**：
> 第一循环从小到大找小k，找不到时第二循环从大到小找大k。注意i=5开始因为n/i≥6要求i≤n/6。这种设计保证即使最小k不在√n范围内也能被找到。
* 💡 **学习笔记**：双保险枚举策略增强代码鲁棒性。

**题解三：(来源：xh39)**
* **亮点**：详尽的变量解释与预存优化
* **核心代码片段**：
```cpp
int ykb = sqrt(n); // 预存平方根
for(int i=6; i<=ykb; ++i) { 
    if(n%i==0) return n/i;
}
for(int i=min(n/6,5);; --i) { 
    if(n%i==0) return i;
}
```
* **代码解读**：
> 变量ykb避免每次循环计算sqrt(n)。第二循环的i上限取min(n/6,5)确保n/i≥6。为什么是5？因为当i=5时n/i≥6要求n≥30，完美覆盖边界情况。
* 💡 **学习笔记**：预存频繁访问的表达式可提升循环效率。

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
设计"零件工厂"像素动画演示约数枚举过程，采用FC红白机风格：
</visualization_intro>

* **动画主题**：像素工厂组装赛车间
* **设计思路**：用不同颜色像素块表示数字，将抽象约数具象化为工厂零件

* **动画帧步骤**：
  1. **初始化**：8-bit风格工厂场景，左侧显示n值（如12），右侧有零件传送带（图1）
  2. **枚举开始**：像素小人从k=6开始检查，传送带出现6个零件(1,2,3)×2（图2）
  3. **成功匹配**：
     - 当n%k==0时（如12%6=0），传送带闪光并组合成赛车（图3）
     - 显示公式：12÷6=2 → gcd=2
     - 播放"胜利音效"（FC过关音效）
  4. **失败继续**：
     - 若n%k≠0（如试k=7），零件散落并播放"错误音效"
     - 小人+1继续尝试（k=7→8→...）
  5. **反向搜索**：
     - 当k>√n未果，时间倒流特效（图4）
     - 从k=5开始递减测试（k=5→4→...）
  6. **关卡进度**：每成功一步获得齿轮零件，集齐3个解锁新关卡（不同n值）

* **交互面板**：
  - 速度滑块：控制枚举速度
  - 暂停/单步：观察每个k值检查过程
  - 重播：重置当前关卡

* **视觉设计**：
  - 约数：发光齿轮（大小表示数值）
  - 当前k值：头顶有像素数字的小人
  - 成功匹配：赛车拼装动画（零件飞入组装）

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握约数枚举技巧后，可挑战以下洛谷题目：
</similar_problems_intro>

1. **P1414 又是毕业季II**  
   → 练习约数性质与批量处理技巧
2. **P1072 Hankson的趣味题**  
   → 综合应用gcd/lcm与约数枚举
3. **P1445 樱花**  
   → 约数个数定理的变形应用

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验尤其珍贵：
</insights_intro>

> **FCBM71**心得："不必二分查找，直接枚举更直观"  
> → 说明：简单问题避免过度设计，保持代码简洁性

> **xh39**心得："预存√n避免重复计算"  
> → 点评：这是性能优化关键技巧，特别在循环中

---

<conclusion>
通过本题我们学到：复杂问题常蕴含简单数学模型。掌握数学转化（n=g×k）和约数枚举技巧（O(√n)优化），就能优雅解决这类题目。下次遇到难题时，记得问问自己：能否用数学语言重新描述问题？
</conclusion>

---
处理用时：125.46秒
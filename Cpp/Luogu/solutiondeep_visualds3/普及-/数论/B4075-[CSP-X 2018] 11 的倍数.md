# 题目信息

# [CSP-X 2018] 11 的倍数

## 题目描述

如判断一个正整数 $x$ 是不是 $3$ 的倍数？

可以计算 $x\div3$ 所得的余数，如果余数等于 $0$，那么 $x$ 是 $3$ 的倍数。

还可以用下面的方法来判断：

把 $x$ 的个位数字、十位数字、百位数字……相加，如果所得的和是 $3$ 的倍数，那么 $x$ 就是 $3$ 的倍数。例如：$x = 8511$，$8+5+1+1=15$，$15$ 是 $3$ 的倍数，那么 $8511$ 就是 $3$ 的倍数。
接下来你的任务是，判断 $x$ 是不是 $11$ 的倍数。 

有一个与判断是不是 $3$ 的倍数类似的方法供你参考： 

- 把 $x$ 的个位、百位、万位……上的数字求和，得 $s_1$； 
- 把 $x$ 的十位、千位、十万位……上的数字求和，得 $s_2$； 

如果 $s_1\div11$ 所得的余数 $= s_2\div11$ 所得的余数，那么 $x$ 就是 $11$ 的倍数。 
例如：$x=3162819$，$s_1 = 3+6+8+9 = 26$，$s_2 = 1+2+1 = 4$。因为 $26\div11$ 余 $4$，$4\div11$ 也余 $4$，所以 $3162819$ 是 $11$ 的倍数。

## 说明/提示

对于 $30\%$ 的数据，$x_i$ 的位数不超过 $9$ 位；

对于 $50\%$ 的数据，$x_i$ 的位数不超过 $17$ 位；

对于 $100\%$ 的数据，$x_i$ 的位数不超过 $100$ 位，$n$ 不超过 $10$。 


## 样例 #1

### 输入

```
3 
2035 
62202 
335 ```

### 输出

```
Yes
No
No```

# AI分析结果


### Kay的C++算法解析：11的倍数 深入学习指南 💡

#### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`字符串处理` + `模运算技巧`  
🗣️ **初步分析**：  
> 判断超大数字（100位）是否为11的倍数，就像检查两条彩色珠链的重量差是否为11的倍数。  
> - **核心思路**：将数字按奇偶位置拆分成两条链（s1=奇位和，s2=偶位和），若两条链的重量差（s1-s2）是11的倍数，则原数是11的倍数  
> - **关键技巧**：用字符串存储数字，通过下标奇偶性交替累加（避免数值溢出）  
> - **可视化设计**：用红/蓝像素块表示数字位，动态展示累加过程（红块入s1，蓝块入s2），最后用像素天平比较余数  

---

#### 2. 精选优质题解参考  
**题解（chen_zhe）**  
* **点评**：  
  思路直击本质：将100位数字视为字符串，避免数值溢出问题。代码采用**双循环合并优化**（单循环内通过`i%2`分流奇偶位），显著提升可读性。亮点在于：  
  - 精准处理字符转数字（`- '0'`）  
  - 预判无符号整数陷阱（`len-2`溢出问题）  
  - 提供两种等价实现，启发多角度思考  

---

#### 3. 核心难点辨析与解题策略  
1. **难点：超大数字存储与位操作**  
   * **分析**：100位数字超出常规类型范围，必须用字符串模拟。关键是通过下标映射奇偶位（注意：字符串下标0对应数字最高位）  
   * 💡 **学习笔记**：字符串是处理超大数字的瑞士军刀  

2. **难点：奇偶位索引的边界处理**  
   * **分析**：若从末尾反向遍历，需警惕`len-2`在短字符串时溢出。更优解是从头遍历，用`i%2`直接分流  
   * 💡 **学习笔记**：正向遍历可规避无符号数下溢风险  

3. **难点：字符与数字的转换**  
   * **分析**：ASCII字符‘0’-‘9’需转换为数值（`x[i]-'0'`），这是字符串处理的核心操作  
   * 💡 **学习笔记**：字符运算本质是ASCII码操作，减‘0’即数值转换  

✨ **解题技巧总结**  
- **技巧1：字符串化超大数字**：用`string`替代`int/long long`  
- **技巧2：奇偶分流累加器**：单循环内通过`i%2`实现双路径求和  
- **技巧3：防御性边界处理**：预存长度变量避免无符号数陷阱  

---

#### 4. C++核心代码实现赏析  
**通用核心实现**  
```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    int n;
    string x;
    cin >> n;
    while (n--) {
        cin >> x;
        int s[2] = {0}; // s[0]:奇位和, s[1]:偶位和
        for (int i = 0; i < x.length(); i++) 
            s[i % 2] += x[i] - '0'; // 字符转数字
        
        cout << (s[0] % 11 == s[1] % 11 ? "Yes" : "No") << endl;
    }
    return 0;
}
```
**代码解读概要**：  
1. 用`string`存储超大数字  
2. `s[0]`和`s[1]`分别累加奇/偶位数字  
3. 比较两和模11的余数决定输出  

**题解片段赏析**  
* **亮点**：奇偶分流一气呵成  
* **核心代码**：  
  ```cpp
  for (int i = 0; i < x.length(); i++)
      s[i % 2] += x[i] - '0';
  ```
* **代码解读**：  
  > 循环从数字最高位（字符串头）开始：  
  > - `i%2==0` → 属于奇位组（实际是数字的**偶**数位，因下标从0起）  
  > - `x[i]-'0'`将字符‘5’转为数字5  
  > 例如"1234"：  
  > - i=0（‘1’）→ s[0] +=1  
  > - i=1（‘2’）→ s[1] +=2  
  > - i=2（‘3’）→ s[0] +=3  
* 💡 **学习笔记**：下标奇偶性决定分组，与数位奇偶相反  

---

### 5. 算法可视化：像素动画演示  
**主题**：8位像素风《数字天平》  
**设计思路**：  
- **像素网格**：每个数字位显示为16x16像素块（红=奇位组，蓝=偶位组）  
- **动态累加**：  
  ```plaintext
  [1][2][3][4]  → 红块1+3=4, 蓝块2+4=6
  ┌─────┬─────┐
  │ 红4 │ 蓝6 │ → 4%11=4, 6%11=6 → 天平倾斜（No）
  └─────┴─────┘
  ```
**交互控制**：  
- **单步执行**：按空格键逐步点亮数字块并播放8位音效（红组: 低音, 蓝组: 高音）  
- **自动模式**：像《俄罗斯方块》AI自动演示，速度可调  
- **胜负反馈**：余数相等时播放《超级玛丽》过关音效+像素烟花  

---

#### 6. 拓展练习与相似问题思考  
**技巧迁移场景**：  
1. 判断7/13的倍数（需构造更复杂分组）  
2. 大数取模运算（如RSA加密）  
3. 数字位特征统计（如统计奇数位质数）  

**洛谷推荐**：  
1. **P1003 大数加法** → 字符串处理基础  
2. **P1307 数字反转** → 位操作进阶  
3. **P1017 进制转换** → 拓展模运算应用  

---

#### 7. 学习心得与经验分享  
**经验摘录**：  
> “无符号`str.length()-2`在短字符串时会产生巨大正数（非负数），必须转为int再减”  
**点评**：  
> 这是字符串处理的经典陷阱！Kay建议：**永远用int预存长度变量**，避免无符号数下溢  

---

掌握字符串与模运算的组合拳，你就能轻松驯服任意位数的数字巨兽！🚀

---
处理用时：105.20秒
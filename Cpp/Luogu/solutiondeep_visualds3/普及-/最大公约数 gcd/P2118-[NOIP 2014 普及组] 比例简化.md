# 题目信息

# [NOIP 2014 普及组] 比例简化

## 题目背景

NOIP2014 普及组 T2

## 题目描述

在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有 $1498$ 人，反对的有 $902$ 人，那么赞同与反对的比例可以简单的记为 $1498:902$。

不过，如果把调查结果就以这种方式呈现出来，大多数人肯定不会满意。因为这个比例的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为 $5:3$，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。

现给出支持人数 $A$，反对人数 $B$，以及一个上限 $L$，请你将 $A$ 比 $B$ 化简为 $A'$ 比 $B'$，要求在 $A'$ 和 $B'$ 均不大于 $L$ 且 $A'$ 和 $B'$ 互质（两个整数的最大公约数是 $1$）的前提下，$\dfrac{A'}{B'} \ge  \dfrac{A}{B}$ 且 $\dfrac{A'}{B'} - \dfrac{A}{B}$ 的值尽可能小。

## 说明/提示

对于 $100\%$ 的数据，$1 \le A \le 10^6,1 \le B \le 10^6,1 \le L \le 100,\dfrac{A}{B} \le L$。


## 样例 #1

### 输入

```
1498 902 10```

### 输出

```
5 3```

# AI分析结果



---
# 💡 Kay的C++算法解析：比例简化 深入学习指南 💡

<introduction>
今天我们来一起分析“比例简化”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过分析优质题解、可视化演示和拓展练习，你将轻松掌握这类问题的解决方法！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举（暴力搜索）与数学判断应用

🗣️ **初步分析**：
解决“比例简化”的关键在于利用枚举法（暴力搜索）。枚举法就像“地毯式搜索”，逐一检查所有可能的候选答案，找到符合条件的最优解。本题中，由于题目给定的上限 \( L \leq 100 \)，枚举范围很小（仅 \( 100 \times 100 = 10000 \) 种可能），因此枚举是最直接且高效的方法。

- **题解思路**：所有题解的核心思路都是枚举 \( A' \) 和 \( B' \)（范围 \( 1 \leq A', B' \leq L \)），筛选出满足以下条件的解：
  1. \( A' \) 和 \( B' \) 互质（最大公约数为1）；
  2. \( \frac{A'}{B'} \geq \frac{A}{B} \)（用整数乘法 \( A' \times B \geq A \times B' \) 避免浮点误差）；
  3. \( \frac{A'}{B'} - \frac{A}{B} \) 最小（即 \( \frac{A'}{B'} \) 尽可能接近 \( \frac{A}{B} \)）。

- **核心难点**：如何高效判断比例关系、处理互质条件，以及在枚举中快速找到最优解。优质题解通常通过整数乘法代替浮点比较，避免精度问题；通过预计算最大公约数（gcd）确保互质；通过维护当前最优解，动态更新最小差值。

- **可视化设计**：我们将设计一个8位像素风格的动画，用网格展示枚举过程。每个 \( (A', B') \) 组合用像素方块表示，符合条件的方块会高亮（如绿色），最优解更新时用金色闪烁并伴随“叮”的音效。控制面板支持单步/自动播放，同步显示当前枚举的 \( A', B' \)、是否互质、比例差值等信息。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码规范性、算法有效性等方面筛选了以下优质题解（评分≥4星）：
</eval_intro>

**题解一：作者：以墨 (赞：324)**
* **点评**：此题解思路清晰，代码简洁规范。通过双重循环枚举 \( A' \) 和 \( B' \)，用 `gcd` 函数判断互质，用整数乘法 \( i \times b \geq j \times a \) 避免浮点误差，最后通过比较 \( i \times ansb < j \times ansa \) 动态更新最优解。代码变量命名直观（如 `ansa` 表示最终 \( A' \)），边界处理严谨（初始值设为 \( L:1 \)），非常适合初学者参考。

**题解二：作者：moongazer (赞：157)**
* **点评**：此题解采用双指针法，时间复杂度优化至 \( O(L) \)。通过维护 \( i \) 和 \( j \) 两个指针，根据 \( \frac{i}{j} \) 与 \( \frac{A}{B} \) 的关系动态调整指针（若 \( \frac{i}{j} < \frac{A}{B} \) 则 \( i++ \)，否则 \( j++ \)），避免了双重循环的冗余计算。虽然实现稍复杂，但思路巧妙，体现了对问题本质的深刻理解。

**题解三：作者：OIerWu_829 (赞：4)**
* **点评**：此题解逻辑直接，代码简洁。通过双重循环枚举所有可能的 \( A', B' \)，用 `gcd` 判断互质，用浮点比较 \( \frac{i}{j} \) 是否满足条件，并维护最小差值。代码注释清晰，适合刚接触枚举法的学习者理解基础逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何避免浮点误差？**
    * **分析**：直接计算 \( \frac{A'}{B'} \) 和 \( \frac{A}{B} \) 并比较可能因浮点数精度丢失导致错误。优质题解通常用整数乘法转换不等式：\( \frac{A'}{B'} \geq \frac{A}{B} \) 等价于 \( A' \times B \geq A \times B' \)（两边同乘 \( B \times B' \)，因 \( B, B' > 0 \) 不改变不等号方向）。
    * 💡 **学习笔记**：涉及分数比较时，优先用整数乘法代替浮点运算，避免精度问题。

2.  **关键点2：如何确保 \( A' \) 和 \( B' \) 互质？**
    * **分析**：互质的条件是 \( \gcd(A', B') = 1 \)。可以通过欧几里得算法（辗转相除法）计算最大公约数。需要注意的是，即使枚举的 \( A', B' \) 不互质，其约分后的解（如 \( 4:2 \) 约为 \( 2:1 \)）可能已被枚举过，因此部分题解省略了互质判断（但为确保正确性，建议显式判断）。
    * 💡 **学习笔记**：互质是题目要求的必要条件，显式判断 \( \gcd \) 能避免错误解。

3.  **关键点3：如何高效找到最优解？**
    * **分析**：最优解要求 \( \frac{A'}{B'} - \frac{A}{B} \) 最小。可以维护当前最优解 \( (ansa, ansb) \)，每次枚举到符合条件的 \( (i, j) \) 时，比较 \( \frac{i}{j} \) 是否更接近 \( \frac{A}{B} \)（通过 \( i \times ansb < j \times ansa \) 判断），若更接近则更新。
    * 💡 **学习笔记**：动态维护当前最优解是枚举法中常用的优化技巧。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将浮点比较转化为整数乘法，避免精度误差。
- **预计算优化**：预先计算 \( \frac{A}{B} \) 的值（或用 \( A \times B' \) 代替），减少重复计算。
- **边界初始化**：初始最优解可设为 \( L:1 \)（满足 \( \frac{L}{1} \geq \frac{A}{B} \)），确保后续能正确更新。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了以墨和OIerWu_829的题解思路，兼顾清晰性和效率，适合初学者理解核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    // 计算最大公约数（欧几里得算法）
    int gcd(int x, int y) {
        return y == 0 ? x : gcd(y, x % y);
    }

    int main() {
        int A, B, L;
        cin >> A >> B >> L;
        int ansa = L, ansb = 1; // 初始最优解设为L:1（满足条件）

        // 枚举所有可能的A'和B'（1到L）
        for (int i = 1; i <= L; ++i) {
            for (int j = 1; j <= L; ++j) {
                // 条件1：互质
                if (gcd(i, j) != 1) continue;
                // 条件2：i/j >= A/B（转化为整数乘法）
                if (i * B < A * j) continue;
                // 条件3：i/j更接近A/B（比较i*ansb < j*ansa）
                if (i * ansb < j * ansa) {
                    ansa = i;
                    ansb = j;
                }
            }
        }

        cout << ansa << " " << ansb << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入 \( A, B, L \)，初始化最优解为 \( L:1 \)（因为 \( L \leq 100 \) 且 \( \frac{L}{1} \geq \frac{A}{B} \)）。然后通过双重循环枚举所有 \( 1 \leq i, j \leq L \) 的组合，依次检查互质、比例关系条件，若满足则更新最优解。最后输出结果。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者：以墨**
* **亮点**：用整数乘法避免浮点误差，代码简洁高效。
* **核心代码片段**：
    ```cpp
    for(i=1;i<=l;i++)
        for(j=1;j<=l;j++)
            if(gcd(i,j)==1&&i*b>=j*a&&i*ansb<j*ansa)
            {
                ansa=i;
                ansb=j;
            }
    ```
* **代码解读**：
    > 这段代码是枚举的核心逻辑。`gcd(i,j)==1` 确保互质；`i*b>=j*a` 用整数乘法判断 \( \frac{i}{j} \geq \frac{A}{B} \)；`i*ansb<j*ansa` 比较当前解 \( \frac{i}{j} \) 与最优解 \( \frac{ansa}{ansb} \)，若更接近则更新。这三个条件层层筛选，确保找到符合要求的最优解。
* 💡 **学习笔记**：整数乘法比较是避免浮点误差的关键技巧，务必掌握！

**题解二：作者：moongazer**
* **亮点**：双指针法优化时间复杂度至 \( O(L) \)。
* **核心代码片段**：
    ```cpp
    while (true) {
        if (a * 1ll * j <= b * 1ll * i) {
            if (i * 1ll * ans2 < j * 1ll * ans1) {
                ans1 = i;
                ans2 = j;
            }
            j++;
            if (j > n) break;
        } else {
            i++;
            if (i > n) break;
        }
    }
    ```
* **代码解读**：
    > 这段代码通过维护 \( i \) 和 \( j \) 两个指针，动态调整枚举方向。若 \( \frac{i}{j} \geq \frac{A}{B} \)（即 \( a \times j \leq b \times i \)），则尝试增大 \( j \) 以寻找更接近的解；否则增大 \( i \)。这种方法避免了双重循环的冗余计算，效率更高。
* 💡 **学习笔记**：双指针法适用于有序或可定向调整的枚举问题，能显著减少时间复杂度。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解枚举过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法如何一步步找到最优解！
</visualization_intro>

  * **动画演示主题**：`像素比例探险家`

  * **核心演示内容**：展示枚举 \( A' \) 和 \( B' \) 的过程，标记符合条件的组合，动态更新最优解。

  * **设计思路简述**：采用FC红白机风格的像素画面（8色调色板，如淡蓝背景、绿色符合条件块、金色最优解块），通过闪烁、音效和文字提示关键步骤，让学习者直观感受枚举的每一步。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示 \( 10 \times 10 \) 的像素网格（对应 \( 1 \leq A', B' \leq 10 \)），每个格子标有 \( (i,j) \)。
          * 右侧显示控制面板（开始/暂停、单步、重置按钮，速度滑块）和当前最优解 \( (ansa, ansb) \)。
          * 播放8位风格的轻快背景音乐（如《超级玛丽》的经典旋律变奏）。

    2.  **枚举启动**：
          * 初始最优解设为 \( (L, 1) \)，对应网格右下角的格子高亮（红色）。
          * 指针从 \( (1,1) \) 开始，用黄色箭头标记当前枚举的 \( (i,j) \)。

    3.  **条件判断与高亮**：
          * 当 \( (i,j) \) 不互质时，格子变灰色；互质时变绿色。
          * 若 \( i \times B \geq A \times j \)（满足比例条件），绿色格子闪烁；否则保持绿色不闪烁。
          * 若 \( (i,j) \) 比当前最优解更接近 \( \frac{A}{B} \)，则最优解格子变为金色并播放“叮”的音效，同时更新右侧的最优解显示。

    4.  **自动演示模式**：
          * 点击“AI自动演示”，算法自动遍历所有 \( (i,j) \)，箭头自动移动，关键步骤（如更新最优解）暂停0.5秒以便观察。

    5.  **结束状态**：
          * 枚举完成后，最终最优解格子持续金色闪烁，播放胜利音效（如《超级玛丽》吃金币音效），右侧显示“找到最优解！”。

  * **旁白提示**：
      * （单步时）“现在检查 \( (i,j) \)，先判断是否互质……”
      * （更新最优解时）“这个比例更接近原比例，更新最优解！”
      * （结束时）“所有可能的比例都检查完毕，最终最优解是 \( (ansa, ansb) \)！”

<visualization_conclusion>
通过这样的动画，我们不仅能看到枚举的每一步，还能直观理解互质、比例比较等关键条件的作用，学习效率大大提升！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的枚举法后，我们可以进一步思考该方法的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 枚举法适用于**候选答案范围小**的问题（如 \( L \leq 100 \)），通过逐一检查候选解找到最优解。类似地，它还可用于：
        1. 寻找满足条件的数对（如“两数之和”问题中枚举所有数对）；
        2. 验证数学猜想（如“哥德巴赫猜想”中枚举质数组合）；
        3. 暴力破解简单密码（如枚举短长度的密码组合）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1036 [NOIP2002 普及组] 选数**
          * 🗣️ **推荐理由**：枚举所有可能的数的组合，判断是否为质数，巩固枚举法和质数判断。
    2.  **洛谷 P1044 [NOIP2003 普及组] 栈**
          * 🗣️ **推荐理由**：通过枚举栈的操作序列，计算可能的出栈顺序，理解枚举与递归的结合。
    3.  **洛谷 P1055 [NOIP2008 普及组] ISBN号码**
          * 🗣️ **推荐理由**：枚举校验码的可能值，验证是否符合ISBN规则，练习边界条件处理。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们非常有帮助：
</insights_intro>

> **参考经验 (来自 以墨)**：“一开始用浮点比较总出错，后来发现用整数乘法更可靠。”
>
> **点评**：这位作者的经验提醒我们，涉及分数比较时，浮点运算可能因精度问题导致错误，用整数乘法转换不等式是更可靠的方法。这是枚举法中处理数值比较的重要技巧，值得我们在编码时优先考虑。

-----

<conclusion>
本次关于“比例简化”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握枚举法的核心思想，理解如何通过暴力搜索解决小范围问题。记住，多动手编写代码、调试和观察动画演示，是提升编程能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：164.35秒
# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP2009 提高组] 最优贸易 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：分层图模型 + 最长路算法（SPFA）  

🗣️ **初步分析**：  
解决“最优贸易”问题，关键是找到从1号城市到n号城市的路径中，**买入一次、卖出一次**的最大差价。我们可以用**分层图**来建模不同的交易状态：  
- **第一层**：未买入水晶球（初始状态）；  
- **第二层**：已买入但未卖出（持有状态）；  
- **第三层**：已卖出（完成交易）。  

分层图的核心思想像“游戏中的状态切换”：你在第一层（未买）可以移动（边权0），也可以选择在某个城市买入（跳到第二层，边权为**-买入价**，表示花钱）；在第二层（持有）可以继续移动，也可以选择卖出（跳到第三层，边权为**+卖出价**，表示赚钱）；第三层（已卖）只能移动到终点n。最终，我们需要求从**第一层1号节点**到**第三层n号节点**的**最长路**（最大利润）。  

**核心难点**：  
1. 如何用图表示“买入/卖出”的状态？（分层图解决）；  
2. 如何处理“移动不影响利润”的边？（层内边权设为0）；  
3. 如何求存在负权边的最长路？（SPFA算法）。  

**可视化设计思路**：  
用8位像素风格（类似FC红白机）展示三层图：  
- 第一层节点用**红色**，第二层**绿色**，第三层**蓝色**；  
- 移动时，节点闪烁并播放“滴”的音效；  
- 买入时，从红色节点跳到绿色节点，显示“-价格”并播放“叮”的音效；  
- 卖出时，从绿色节点跳到蓝色节点，显示“+价格”并播放“咚”的音效；  
- 到达第三层n号节点时，播放“胜利”音效，节点绽放烟花。  


## 2. 精选优质题解参考

为了帮大家快速掌握核心思路，我筛选了3份**思路清晰、代码规范**的优质题解：


### **题解一：分层图+SPFA（作者：fy1234567ok，赞：477）**  
* **点评**：  
  这份题解的**分层图建模**非常经典，用宏定义`t(x,i)`表示第`i`层的`x`节点（如`t(1,0)`是第一层1号节点，`t(1,1)`是第二层1号节点），简洁明了。层内边（移动）权值为0，层间边（买入/卖出）权值为`-价格`/`+价格`。代码用SPFA求最长路，逻辑清晰，仅40行左右，适合初学者理解分层图的核心思想。  


### **题解二：分层图+SPFA（作者：HPXXZYY，赞：10）**  
* **点评**：  
  这份题解的**代码规范性**很强，变量名（如`cost[i]`表示价格）和函数名（如`spfa_algorithm`）含义明确。层间边的处理（`add(i, i+n, -cost[i])`表示买入，`add(i+n, i+2*n, cost[i])`表示卖出）非常直观，注释详细，适合初学者模仿代码风格。  


### **题解三：两次SPFA（作者：神之右大臣，赞：7）**  
* **点评**：  
  这份题解的**逆向思维**很有启发性：不建分层图，而是用两次SPFA分别求：  
  1. 从1号节点到所有节点的**最小买入价**（`f[i]`）；  
  2. 从n号节点到所有节点的**最大卖出价**（`g[i]`，通过反图计算）。  
  最终答案为`max(g[i] - f[i])`（所有节点的最大差价）。这种方法避免了分层图的复杂建模，适合理解“状态分离”的思想。  


## 3. 核心难点辨析与解题策略

在解决本题时，大家常遇到以下3个核心难点，结合优质题解，我总结了应对策略：


### **1. 难点：如何表示“买入/卖出”的状态？**  
* **分析**：  
  直接在原图中无法区分“是否买入”，因此需要用**分层图**将状态分开。每层代表一个状态，层间边代表状态转移（买入/卖出）。  
* **策略**：  
  - 第一层（未买入）：节点编号为`1~n`；  
  - 第二层（已买入）：节点编号为`n+1~2n`；  
  - 第三层（已卖出）：节点编号为`2n+1~3n`。  
  例如，在第一层`i`节点买入，就连接`i → n+i`（边权`-price[i]`）；在第二层`n+i`节点卖出，连接`n+i → 2n+i`（边权`+price[i]`）。  


### **2. 难点：如何处理“移动不影响利润”的边？**  
* **分析**：  
  移动过程中没有交易，利润不变，因此层内边的权值应为0。  
* **策略**：  
  对于原图中的每条边`u→v`（或双向边），在三层图中都添加对应的边：  
  - 第一层：`u→v`（权0）；  
  - 第二层：`n+u→n+v`（权0）；  
  - 第三层：`2n+u→2n+v`（权0）。  


### **3. 难点：如何求存在负权边的最长路？**  
* **分析**：  
  买入时边权为负（花钱），因此最长路问题中存在负权边。Dijkstra算法无法处理负权边，因此需要用SPFA算法。  
* **策略**：  
  SPFA算法通过队列维护待松弛的节点，每次取出节点`u`，松弛其所有邻接节点`v`（若`dis[v] < dis[u] + w`，则更新`dis[v]`并将`v`入队）。初始时，`dis[1] = 0`（第一层1号节点的利润为0），其余节点`dis`设为极小值（如`INT_MIN`）。  


### ✨ 解题技巧总结  
- **状态建模**：用分层图表示不同状态（如买入/卖出），将问题转化为图论中的路径问题；  
- **边权设计**：根据状态转移设计边权（如买入为负，卖出为正，移动为0）；  
- **算法选择**：存在负权边时，用SPFA求最长路（或最短路，需调整边权符号）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（分层图+SPFA）  
* **说明**：综合fy1234567ok和HPXXZYY的题解，提炼出最简洁的分层图实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <climits>
  using namespace std;

  const int MAXN = 1e5 + 5;
  vector<pair<int, int>> G[MAXN * 3]; // 三层图，节点编号1~3n
  int dis[MAXN * 3]; // 最长路距离
  bool inq[MAXN * 3]; // 是否在队列中

  #define t(x, i) (x + i * MAXN) // 第i层的x节点（i=0:第一层，i=1:第二层，i=2:第三层）

  void add_edge(int u, int v, int w) {
      G[u].emplace_back(v, w);
  }

  void spfa(int s) {
      fill(dis, dis + MAXN * 3, INT_MIN);
      queue<int> q;
      dis[s] = 0;
      q.push(s);
      inq[s] = true;
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          inq[u] = false;
          for (auto &[v, w] : G[u]) {
              if (dis[v] < dis[u] + w) {
                  dis[v] = dis[u] + w;
                  if (!inq[v]) {
                      q.push(v);
                      inq[v] = true;
                  }
              }
          }
      }
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      int n, m;
      cin >> n >> m;
      vector<int> price(n + 1);
      for (int i = 1; i <= n; ++i) {
          cin >> price[i];
          // 层间边：第一层→第二层（买入，权值-price[i]）
          add_edge(t(i, 0), t(i, 1), -price[i]);
          // 层间边：第二层→第三层（卖出，权值+price[i]）
          add_edge(t(i, 1), t(i, 2), price[i]);
      }
      for (int i = 0; i < m; ++i) {
          int u, v, z;
          cin >> u >> v >> z;
          // 层内边：三层都添加移动边（权0）
          add_edge(t(u, 0), t(v, 0), 0);
          add_edge(t(u, 1), t(v, 1), 0);
          add_edge(t(u, 2), t(v, 2), 0);
          if (z == 2) { // 双向边，反向也添加
              add_edge(t(v, 0), t(u, 0), 0);
              add_edge(t(v, 1), t(u, 1), 0);
              add_edge(t(v, 2), t(u, 2), 0);
          }
      }
      spfa(t(1, 0)); // 从第一层1号节点出发
      cout << dis[t(n, 2)] << endl; // 第三层n号节点的最长路
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. 用`t(x, i)`宏定义分层节点，如`t(1,0)`是第一层1号节点；  
  2. `add_edge`函数添加边，层内边权为0，层间边权为`-price`（买入）或`+price`（卖出）；  
  3. `spfa`函数求最长路，初始`dis[1] = 0`，其余为极小值；  
  4. 主函数读取输入，建图，调用SPFA，输出第三层n号节点的最长路（最大利润）。  


### 题解一（fy1234567ok）核心片段赏析  
* **亮点**：用宏定义简化分层节点，代码简洁。  
* **核心代码片段**：  
  ```cpp
  #define t(x,i) (x+i*n) // 第i层的x节点
  #define add(x, y) G[t(x,0)].push_back({t(y,0), 0}), G[t(x,1)].push_back({t(y,1),0}), G[t(x,2)].push_back({t(y,2),0})
  ```  
* **代码解读**：  
  - `t(x,i)`宏将x节点映射到第i层，避免了手动计算节点编号；  
  - `add(x,y)`函数一次性添加三层的移动边（权0），减少了代码重复。  


### 题解三（神之右大臣）核心片段赏析  
* **亮点**：两次SPFA求最小买入价和最大卖出价，逆向思维。  
* **核心代码片段**：  
  ```cpp
  // 求从1到i的最小买入价（正向图）
  void spfa1(int s) {
      fill(minv, minv + MAXN, INT_MAX);
      queue<int> q;
      minv[s] = price[s];
      q.push(s);
      inq[s] = true;
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          inq[u] = false;
          for (int v : e[u]) {
              if (minv[v] > min(minv[u], price[v])) {
                  minv[v] = min(minv[u], price[v]);
                  if (!inq[v]) {
                      q.push(v);
                      inq[v] = true;
                  }
              }
          }
      }
  }

  // 求从i到n的最大卖出价（反图）
  void spfa2(int s) {
      fill(maxv, maxv + MAXN, INT_MIN);
      queue<int> q;
      maxv[s] = price[s];
      q.push(s);
      inq[s] = true;
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          inq[u] = false;
          for (int v : rev_e[u]) {
              if (maxv[v] < max(maxv[u], price[v])) {
                  maxv[v] = max(maxv[u], price[v]);
                  if (!inq[v]) {
                      q.push(v);
                      inq[v] = true;
                  }
              }
          }
      }
  }
  ```  
* **代码解读**：  
  - `spfa1`用正向图求从1到所有节点的最小买入价（`minv[i]`）；  
  - `spfa2`用反图求从n到所有节点的最大卖出价（`maxv[i]`，即从i到n的最大卖出价）；  
  - 最终答案为`max(maxv[i] - minv[i])`（所有节点的最大差价）。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《水晶球贸易历险记》（8位像素风）  
**设计思路**：用FC红白机的风格，将分层图转化为“游戏关卡”，让学习者通过动画直观看到状态转移和利润变化。  


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示三层图：第一层（红色）、第二层（绿色）、第三层（蓝色），节点用16x16像素块表示；  
   - 屏幕右侧是控制面板：**开始/暂停**、**单步执行**、**重置**、**速度滑块**（1~5倍速）；  
   - 背景音乐：8位风格的《冒险之旅》（循环播放）。  

2. **算法启动**：  
   - 第一层1号节点（红色）高亮，显示“初始状态：未买入”；  
   - 点击“开始”，动画自动播放。  

3. **移动（层内边）**：  
   - 节点从`u`（红色）移动到`v`（红色），路径用黄色箭头表示；  
   - 播放“滴”的音效，底部显示“移动：利润不变（+0）”。  

4. **买入（层间边）**：  
   - 节点从`u`（红色）跳到`u+n`（绿色），路径用橙色箭头表示；  
   - 显示“买入：-price[u]”（如`-3`），播放“叮”的音效；  
   - 底部利润栏更新（如`0 → -3`）。  

5. **卖出（层间边）**：  
   - 节点从`u+n`（绿色）跳到`u+2n`（蓝色），路径用紫色箭头表示；  
   - 显示“卖出：+price[u]”（如`+5`），播放“咚”的音效；  
   - 底部利润栏更新（如`-3 → +2`）。  

6. **到达终点**：  
   - 节点到达第三层n号节点（蓝色），播放“胜利”音效（上扬的8位音乐）；  
   - 节点绽放烟花，底部显示“最大利润：X”（如`5`）。  

7. **交互功能**：  
   - **单步执行**：点击后，动画走一步，显示当前步骤的详细信息（如“当前状态：已买入，利润：-3”）；  
   - **自动播放**：可调速度，适合快速观看整体流程；  
   - **重置**：回到初始状态，重新开始动画。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
分层图模型适用于**需要状态转移**的图论问题，例如：  
- 允许`k`次边权修改的最短路径（如P2939《[USACO09OPEN]滑雪课Ski Lessons》）；  
- 多状态的图论问题（如P4568《[JSOI2011]飞行路线》，允许`k`次免费机票）；  
- 交易类问题（如股票买卖中的“最多交易`k`次”）。  


### 洛谷练习推荐  
1. **洛谷 P2939** - 《[USACO09OPEN]滑雪课Ski Lessons》  
   🗣️ **推荐理由**：这道题需要用分层图处理“上课”和“滑雪”两种状态，是分层图的经典应用，帮助巩固状态建模的思路。  

2. **洛谷 P4568** - 《[JSOI2011]飞行路线》  
   🗣️ **推荐理由**：题目允许`k`次免费机票，需要用分层图表示“使用了`i`次免费机票”的状态，适合练习分层图的扩展应用。  

3. **洛谷 P1144** - 《最短路径计数》  
   🗣️ **推荐理由**：这道题用SPFA求最短路径的数量，适合巩固SPFA算法的应用，理解队列优化的思想。  


## 7. 学习心得与经验分享（若有）

### 参考经验（来自fy1234567ok）  
> “我最初想到用分层图，是因为交易状态需要分离，而分层图正好能将不同状态分开。代码中的宏定义简化了节点编号，让代码更简洁。”  

**点评**：这位作者的经验提醒我们，**状态分离**是解决交易类问题的关键，而分层图是实现状态分离的有效工具。宏定义可以简化重复代码，提高代码可读性。  


### 参考经验（来自神之右大臣）  
> “两次SPFA的思路，是因为我想到‘最小买入价’和‘最大卖出价’是独立的，可以分别计算。反图的使用让我更容易求从i到n的最大卖出价。”  

**点评**：这位作者的逆向思维很有启发性，**将问题拆分为两个独立的子问题**（求最小值和最大值），可以避免复杂的建模，适合初学者理解。  


## 🎉 总结  
本次分析了“最优贸易”问题的核心思路——**分层图模型**和**SPFA最长路**，并通过动画演示和代码赏析帮助大家直观理解。记住，**状态建模**是解决这类问题的关键，而分层图是实现状态建模的有力工具。  

下次遇到需要状态转移的图论问题，不妨试试分层图吧！💪  

如果有任何疑问，欢迎在评论区留言，Kay会帮你解答～ 😊

---
处理用时：189.50秒
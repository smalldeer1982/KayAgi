# 题目信息

# 【XR-4】歌唱比赛

## 题目背景

**赛时提醒：本题不提供任何关于样例 4 以及无解的解释。**

**赛时提醒：本题不提供任何关于输出格式以及 Special Judge 的解释。**

**赛时提醒：抱歉，本题的 Special Judge 不忽略行末空格，请保证两行中没有多余字符。**

**赛时提醒：非常抱歉，本题输入数据是 Windows 格式，而非 Linux 格式，所以在末尾的 `\n` 之前有一个多余的 `\r` 字符。请使用 `scanf` 或 `cin` 读入数据，而非 `getline`，因为后者会多读入一个 `\r`。**

## 题目描述

小 X 参加了一场歌唱比赛。

经过一路鏖战，小 X 终于挺进了决赛，他的对手是小 Y。

这场歌唱比赛的冠军是由点赞数决定的，谁的点赞数高，谁就能夺冠。

小 X 和小 Y 依次演唱完自己的最后一首歌曲后，他们最终的点赞数确定了下来。

揭晓冠军的时刻终于到来了，主持人为了增加悬念，决定从小 X 与小 Y 的点赞数的最后一位开始，依次比较。

比如，小 X 的点赞数是 $37$，小 Y 的点赞数是 $28$。首先比较最后一位，小 X 是 $7$，小 Y 是 $8$，此时小 Y 暂时领先。再加上前一位，小 X 是 $37$，小 Y 是 $28$，此时小 X 暂时领先。比较结束，如果我们用 `X` 代表小 X 暂时领先，`Y` 代表小 Y 暂时领先，那么可以写下一个字符串 `XY`。

再比如，小 X 的点赞数是 $137$，小 Y 的点赞数是 $47$。如果我们再用 `Z` 表示小 X 与小 Y 的点赞数暂时一样，那么写下的字符串应该为 `XYZ`。

你作为一个精通 OI 的神仙，自然知道这种比较方式是非常不科学的，这样只是在无端拖延时间罢了，但是你却对最后写下的这个字符串很感兴趣。

现在，你得到了这个最后写下的字符串，你需要构造出一种可能的小 X 与小 Y 的点赞数。

当然，有可能不存在任何一种情况的点赞数满足这个字符串，那么你只需要输出 `-1` 即可。

为了方便你输出，请用前导零来补足位数。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（11 points）：$\text{len}(s) = 1$。
- Subtask 2（42 points）：$s_i \in \{\texttt{X},\texttt{Y}\}$。
- Subtask 3（21 points）：数据保证有解。
- Subtask 4（26 points）：无特殊限制。

对于 $100\%$ 的数据，$s_i \in \{\texttt{X},\texttt{Y},\texttt{Z}\}$，$1 \le \text{len}(s) \le 10^6$。

## 样例 #1

### 输入

```
XY
```

### 输出

```
37
28
```

## 样例 #2

### 输入

```
XYZ
```

### 输出

```
137
047
```

## 样例 #3

### 输入

```
ZZZZZZ
```

### 输出

```
000000
000000
```

## 样例 #4

### 输入

```
XYZXYZ
```

### 输出

```
-1
```

# AI分析结果

# 💡 Kay的C++算法解析：歌唱比赛 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟与构造（编程技巧应用）

🗣️ **初步分析**：  
解决“歌唱比赛”问题，关键在于**模拟比较过程并构造合法数字**。可以把它比作“搭积木”——每一步（字符串的每个字符）都要按照规则搭建“数字积木”，确保从低位到高位的比较结果符合要求。其中，`Z`（平局）是最特殊的“积木”，它要求后面所有“积木”都必须相同（即后面的字符必须全为`Z`），否则无法搭建出合法的“数字塔”。  

- **核心思路**：  
  1. 先判断无解情况：如果`Z`出现后又有`X`或`Y`，直接输出`-1`。  
  2. 构造数字对：对于`X`，让小X的当前位大于小Y；对于`Y`，让小Y的当前位大于小X；对于`Z`，让两者相等（用简单数字如1和0、2和1等即可）。  

- **可视化设计思路**：  
  用8位像素风格展示字符串的每一步处理：  
  - 屏幕左侧显示输入字符串（每个字符用像素块表示，`X`为红色、`Y`为蓝色、`Z`为绿色）；  
  - 中间显示两个数字的构造过程（每一步的像素块颜色变化，比如`X`时小X的像素块变成1，小Y变成0）；  
  - 右侧显示当前状态（如“正在处理第3位”“无解！”）。  
  关键步骤用“叮”的音效提示（如构造完成一步），无解时用“错误”音效，增加互动感。  


## 2. 精选优质题解参考

### 题解一：（来源：Fatalis_Lights，赞18）  
* **点评**：  
  这道题解的思路**极其清晰**，直接抓住了问题的核心——`Z`的约束条件。作者用一个简单的`pd`函数判断`Z`后面是否有非`Z`字符，逻辑严谨（O(n)时间）。构造数字时，用1和0分别表示大小关系，代码简洁到极致（仅20行左右），非常适合初学者理解。比如，`X`对应小X的1和小Y的0，`Y`则相反，`Z`则都为1，完全符合题目要求。  

### 题解二：（来源：loceaner，赞8）  
* **点评**：  
  这道题解的**代码规范性**很强，作者用`read`函数处理输入（虽然本题不需要，但体现了良好的编程习惯），并详细注释了每一步的逻辑。比如，用`now`变量标记是否出现过`Z`，避免了复杂的嵌套判断。构造数字时，用字符数组存储结果，输出更高效。作者还提到“忘记判断无解情况”的调试经历，提醒我们要注意边界条件。  

### 题解三：（来源：StudyingFather，赞6）  
* **点评**：  
  这道题解的**算法有效性**很高，作者用9和0构造数字（比如`X`对应小X的9和小Y的0），确保大小关系的绝对性（不会有后续位影响）。倒序遍历字符串的方式，符合“从低位到高位”的比较逻辑，代码简短且高效。这种构造方式非常适合竞赛中的“快速AC”需求。  


## 3. 核心难点辨析与解题策略

### 1. 难点1：理解`Z`的约束条件（后面必须全为`Z`）  
* **分析**：  
  `Z`表示“当前所有位相等”，因此如果`Z`出现后又有`X`或`Y`，说明后面的位不相等，矛盾。解决方法是**遍历字符串，标记是否出现过`Z`，若出现后遇到非`Z`字符则无解**（如Fatalis_Lights的`pd`函数）。  
* 💡 **学习笔记**：`Z`是“终止符”，后面不能有任何变化。

### 2. 难点2：构造合法的数字对（每一步满足大小关系）  
* **分析**：  
  不需要复杂的数字，用简单的1和0、2和1即可。比如，`X`时小X的当前位为1，小Y为0；`Y`时相反；`Z`时都为1。这样既能满足大小关系，又不会影响后续位（因为低位的权值小）。  
* 💡 **学习笔记**：构造题要“偷懒”，用最简单的数字满足条件。

### 3. 难点3：高效判断无解情况（避免O(n²)时间）  
* **分析**：  
  若用双重循环判断`Z`后面的字符，会超时（n≤1e6）。解决方法是**一次遍历，用变量标记是否出现过`Z`**（如loceaner的`now`变量），遇到非`Z`字符时更新标记，遇到`Z`时检查标记是否为1（若为1则无解）。  
* 💡 **学习笔记**：高效判断需要“一次遍历”的思维。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合优质题解的思路，用字符数组存储结果，简洁高效。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cstring>
  using namespace std;

  const int N = 1e6 + 5;
  char s[N], a[N], b[N];

  int main() {
      cin >> s;
      int len = strlen(s);
      bool has_non_z = false; // 是否出现过非Z字符
      for (int i = 0; i < len; i++) {
          if (s[i] == 'Z') {
              if (has_non_z) { // Z出现后有非Z字符，无解
                  cout << -1 << endl;
                  return 0;
              }
              a[i] = '1';
              b[i] = '1';
          } else {
              has_non_z = true;
              if (s[i] == 'X') {
                  a[i] = '1';
                  b[i] = '0';
              } else { // Y
                  a[i] = '0';
                  b[i] = '1';
              }
          }
      }
      cout << a << endl << b << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 读取输入字符串` s `。  
  2. 遍历字符串，用`has_non_z`标记是否出现过非`Z`字符。  
  3. 对于每个字符，构造`a`（小X的数字）和`b`（小Y的数字）：`Z`时都为1，`X`时a为1、b为0，`Y`时相反。  
  4. 输出结果。


### 针对各优质题解的片段赏析

#### 题解一（Fatalis_Lights）  
* **亮点**：用`pd`函数快速判断无解，代码极简。  
* **核心代码片段**：  
  ```cpp
  bool pd(string s) {
      bool flag = 0;
      for (int i = 0; i < s.size(); i++) {
          if (s[i] == 'Z') flag = 1;
          if (flag && s[i] != 'Z') return 1;
      }
      return 0;
  }
  ```
* **代码解读**：  
  这个函数遍历字符串，`flag`标记是否出现过`Z`。如果`flag`为1（出现过`Z`）且当前字符不是`Z`，说明无解（返回1）。否则返回0（有解）。  
* 💡 **学习笔记**：用布尔变量标记状态，是判断无解的关键。

#### 题解二（loceaner）  
* **亮点**：用字符数组存储结果，输出更高效。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= len; i++) {
      if (s[i] == 'X') a[i] = '1', b[i] = '0';
      else if (s[i] == 'Y') a[i] = '0', b[i] = '1';
      else a[i] = '1', b[i] = '1';
  }
  ```
* **代码解读**：  
  遍历字符串，用字符数组`a`和`b`存储小X和小Y的数字。`X`时a为1、b为0，`Y`时相反，`Z`时都为1。字符数组的输出比整数数组更高效（不需要转换）。  
* 💡 **学习笔记**：字符数组适合存储数字字符串，输出更方便。

#### 题解三（StudyingFather）  
* **亮点**：用9和0构造数字，确保大小关系的绝对性。  
* **核心代码片段**：  
  ```cpp
  for (int i = len-1; i >= 0; i--) {
      if (s[i] == 'Z') s1[i] = s2[i] = '0';
      else if (s[i] == 'X') s1[i] = '9', s2[i] = '0';
      else s1[i] = '0', s2[i] = '9';
  }
  ```
* **代码解读**：  
  倒序遍历字符串（符合“从低位到高位”的比较逻辑），用9和0构造数字。`X`时小X的当前位为9（最大的数字），小Y为0（最小的数字），确保当前位的大小关系不会被后续位影响。  
* 💡 **学习笔记**：用极端数字（如9和0）可以避免后续位的干扰。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：像素积木搭建游戏  
**设计思路**：用8位像素风格模拟“搭建数字塔”的过程，每一步对应字符串的一个字符，让学习者直观看到数字的构造过程和无解情况。  

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示输入字符串（每个字符用20x20的像素块表示，`X`为红色、`Y`为蓝色、`Z`为绿色）。  
   - 中间显示两个数字的“积木塔”（每个数字用像素块组成，初始为灰色）。  
   - 右侧显示控制面板（“开始”“单步”“重置”按钮，速度滑块）。  

2. **算法执行过程**：  
   - **单步执行**：点击“单步”按钮，处理下一个字符。比如，处理`X`时，小X的当前像素块变成红色（1），小Y的变成蓝色（0），伴随“叮”的音效。  
   - **无解提示**：如果遇到`Z`后有非`Z`字符，屏幕弹出红色“无解！”提示，伴随“错误”音效。  
   - **自动播放**：点击“开始”按钮，算法自动执行，每步间隔500ms（可通过滑块调整速度）。  

3. **游戏化元素**：  
   - **过关奖励**：每完成一步，屏幕右下角显示“+10分”的像素提示，增加成就感。  
   - **背景音乐**：循环播放8位风格的轻快音乐（如《超级马里奥》的背景音），增强氛围。  

### 技术实现细节  
- **Canvas绘制**：用`ctx.fillRect`绘制像素块，`ctx.fillStyle`设置颜色（如`#FF0000`表示红色）。  
- **音效触发**：用`Audio`对象播放音效（如`ding.mp3`对应步骤完成，`error.mp3`对应无解）。  
- **状态管理**：用变量记录当前处理的位置、是否无解等状态，控制动画的播放。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **模拟与构造**：本题的核心是“按照规则构造结果”，这种思路适用于很多编程问题，比如：  
  1. 根据规则生成字符串（如洛谷P3742《umi的函数》）；  
  2. 构造满足条件的数组（如洛谷P5019《铺设道路》）；  
  3. 模拟游戏过程（如洛谷P1257《平面上的最短线段》）。  

### 练习推荐 (洛谷)  
1. **洛谷 P3742** - 《umi的函数》  
   🗣️ **推荐理由**：这道题要求根据规则生成字符串，与本题的“构造数字”思路完全一致，适合巩固模拟与构造的技巧。  
2. **洛谷 P5019** - 《铺设道路》  
   🗣️ **推荐理由**：这道题要求构造满足条件的数组，需要考虑每一步的约束条件，与本题的“Z约束”类似。  
3. **洛谷 P1257** - 《平面上的最短线段》  
   🗣️ **推荐理由**：这道题要求模拟游戏过程，需要处理每一步的状态变化，与本题的“步骤处理”思路一致。  


## 7. 学习心得与经验分享 (若有)  
**参考经验（来自loceaner）**：“我忘记了判断无解的情况，导致第一次提交只得了74分。”  
**点评**：这是初学者常见的错误——忽略边界条件。在编程中，**一定要先考虑无解的情况**，再处理正常情况。比如本题的“Z约束”，如果不判断，就会输出错误的结果。  


## 结语  
本次关于“歌唱比赛”的C++解题分析就到这里。希望这份指南能帮助你理解**模拟与构造**的核心思路，掌握“判断边界条件”“用简单数字构造结果”等技巧。记住，编程的乐趣在于“按照规则搭建属于自己的数字世界”，下次我们再一起探索新的挑战！💪

---
处理用时：134.96秒
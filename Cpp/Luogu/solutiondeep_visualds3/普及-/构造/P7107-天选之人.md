# 题目信息

# 天选之人

## 题目背景

暑假期间，学校不提供午餐，Gnar 只好找伙计们一起点外卖。

尴尬的是，外卖很快送到却没人乐意去校门口拿，毕竟户外可是 $35\degree\!\text{C}$ 高温！此时 Gnar 想到了好主意：“我给一人捏了一张纸团，其中一张写有记号，不如我们抓阄决定，谁抽到带记号的谁去拿！”

于是 Gnar 连续拿了六天的外卖。

这可让他不服又委屈：“换个规则！一人准备三张纸团，五张有记号，每人抽三张，记号最多的去拿！”

Gnar 紧张地展开手中的纸团，两个记号赫然映在眼前。大伙们刚想放声大笑他的非酋运气，有人缓缓举起三张纸片说道：“我也抽到了两个记号……”

## 题目描述

好奇的 Gnar 想研究一般情况下抽到最多记号的人数。他给参与抓阄的 $n$ 人一人准备了 $m$ 张捏好的纸团，一共 $nm$ 张，其中恰好 $k$ 张提前写了记号。随后每个人在均匀打乱的纸团中各抽 $m$ 张。

一个人抽到最多的记号，当且仅当没有人抽到的记号比他还多。请你帮 Gnar 判断是否可能会**恰好** $\boldsymbol{p}$ **个人**抽到最多的记号。Gnar 喜欢追根问底，所以如果有可能，你还需构造每个人抽的纸团中分别有多少带记号、有多少不带记号。

形式化地，假设第 $i$ 个人抽到了 $x_i$ 张带记号的纸团和 $y_i$ 张不带记号的纸团，你的构造应满足：

- $x_i, y_i \ge 0$，$x_i + y_i = m$。
- $\displaystyle \sum_{i = 1}^{n} x_i = k$。
- **有且仅有** $\boldsymbol{p}$ **个互不相同**的 $j$ 使 $\displaystyle x_j = \max_{i = 1}^{n} \{x_i\}$。

## 说明/提示


**【样例解释 #1】**

样例给出了一种满足题述条件的构造。

**【样例解释 #2】**

不论如何，记号的分布从高到低只有三种情况：$\{3,0,0\}$，$\{2,1,0\}$，$\{1,1,1\}$，抽到最多记号的人数分别对应 $1$，$1$，$3$。因此无法构造 $p = 2$ 的方案。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (15 points)：$n,m \le 8$。
- Subtask #2 (15 points)：$n,m \le 100$。
- Subtask #3 (20 points)：$n,m \le 10^5$。
- Subtask #4 (10 points)：$p = 1$。
- Subtask #5 (40 points)：无特殊限制。

对于所有的数据，保证 $1 \le p \le n \le {10}^5$，$1 \le m \le {10}^9$，$0 \le k \le n m$。

## 样例 #1

### 输入

```
3 3 5 2```

### 输出

```
YES
2 1
2 1
1 2```

## 样例 #2

### 输入

```
3 3 3 2```

### 输出

```
NO```

## 样例 #3

### 输入

```
3 3 5 3```

### 输出

```
NO```

# AI分析结果

# 💡 Kay的C++算法解析：天选之人 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心构造（编程技巧应用）

🗣️ **初步分析**：  
解决“天选之人”问题，关键在于**贪心分配带记号的纸团**——先让恰好`p`个人拿到最多的记号（记为`q`），再把剩下的记号分给其他人，确保他们的记号数都小于`q`。这就像分蛋糕：先给`p`个小朋友每人切一块最大的蛋糕（不超过他们的盘子容量`m`，也不超过总蛋糕数`k`），剩下的蛋糕再分给其他小朋友，每块都比最大的小，这样就能保证这`p`个小朋友的蛋糕是最大的。  

- **核心思路**：  
  1. 确定最大值`q`：`q = min(m, k / p)`（`p`个人每人最多拿`q`个，否则总记号数会超过`k`）。  
  2. 分配`p`个`q`：这`p`个人的记号数为`q`，剩余记号数`rest = k - p*q`。  
  3. 处理剩余记号：将`rest`分给剩下的`n-p`个人，每人最多拿`q-1`个（否则会超过最大值`q`）。若`rest > (n-p)*(q-1)`，则无法分配，输出`NO`；否则，依次分配`q-1`直到不够，最后一个人拿剩余的。  

- **可视化设计思路**：  
  用8位像素风格展示分配过程：  
  - 屏幕左侧是`n`个像素人，每人头顶有一个框显示`x_i`（带记号数）和`y_i`（不带记号数）。  
  - 屏幕上方有`k`个红色像素块（带记号纸团），总数量随分配减少。  
  - **高亮逻辑**：`p`个最大值的人用红色边框标记，分配剩余记号时，当前处理的人用黄色边框标记。  
  - **动画流程**：先给`p`个人各加`q`个红色块，然后给剩下的人依次加`q-1`个，直到剩余块用完。每分配一次，伴随“叮”的像素音效；分配完成时，播放“胜利”音效。  


## 2. 精选优质题解参考

### 题解一：（来源：Unordered_OIer）  
* **点评**：  
  这份题解的思路**直接且高效**，完美贴合贪心构造的核心逻辑。作者先通过`q = min(m, k/p)`确定最大值，再分配`p`个`q`，最后处理剩余记号。代码**简洁规范**（变量名`q`、`rest`含义明确），时间复杂度`O(n)`，完全满足`1e5`的数据规模要求。其**亮点**在于剩余记号的处理方式：用循环依次分配`q-1`，直到不够，最后一个人拿剩余的，逻辑清晰且无冗余。从实践角度看，这份代码可以直接用于竞赛，边界处理（如`rest`为0的情况）非常严谨。


### 题解二：（来源：HanPi）  
* **点评**：  
  此题解的思路与题解一类似，但**处理剩余记号的方式更灵活**。作者将剩余记号`a = k - p*hp`平均分配给`n-p`个人，计算每人拿`h = a/(n-p)`个，剩余`mod = a%(n-p)`个，再给`mod`个人各加1个。这种平均分配的思路帮助我们更直观地理解剩余记号的分配逻辑。代码**可读性高**（变量名`hp`、`h`、`mod`清晰），但需要注意判断`h+1 < hp`（即剩余分配不超过最大值），否则无解。其**亮点**在于平均分配的思想，适合初学者理解剩余部分的处理。


### 题解三：（来源：Maxmilite）  
* **点评**：  
  此题解的**特判处理非常到位**，尤其是`n=p`的情况（此时所有⼈都必须拿相同的记号数，否则无法满足恰好`p`个最大值）。作者通过`if (n == p)`判断，若`k`不能被`p`整除，则输出`NO`，否则每人拿`k/p`个。这种特判思路提醒我们，边界情况（如`p=n`）需要单独处理，避免出现除数为0的错误。代码**逻辑紧凑**，但剩余记号的处理方式（用`tot -= t-1`循环） slightly冗余，不如题解一简洁。其**亮点**在于特判的完整性，适合学习边界条件的处理。


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何确定最大值`q`？**  
* **分析**：  
  `q`必须满足两个条件：① `p`个人的总记号数不超过`k`（`q*p ≤ k`）；② 每人拿的记号数不超过`m`（`q ≤ m`）。因此`q = min(m, k/p)`。若`q`取大了，`p*q`会超过`k`，无法分配；若`q`取小了，剩余记号可能无法被`n-p`个人分配（每人最多`q-1`）。  
* 💡 **学习笔记**：`q`的取值是贪心构造的核心，必须平衡“最大值”和“总记号数”的限制。


### 2. **关键点2：如何处理剩余记号？**  
* **分析**：  
  剩余记号`rest = k - p*q`必须分给`n-p`个人，每人最多拿`q-1`个。若`rest > (n-p)*(q-1)`，则无法分配（即使每人拿`q-1`，也装不下`rest`），输出`NO`。否则，依次分配`q-1`，直到`rest`不够，最后一个人拿剩余的`rest`。这种处理方式确保剩余记号都被分配，且每人的记号数都小于`q`。  
* 💡 **学习笔记**：剩余记号的分配要“贪心”——尽可能多拿`q-1`，但不超过限制。


### 3. **关键点3：如何处理`n=p`的情况？**  
* **分析**：  
  当`n=p`时，所有⼈都必须拿相同的记号数（否则无法满足恰好`p`个最大值）。因此`k`必须能被`p`整除（`k%p == 0`），否则输出`NO`。此时每人拿`k/p`个，刚好分完。  
* 💡 **学习笔记**：边界情况（如`p=n`）需要单独处理，避免出现逻辑错误。


### ✨ 解题技巧总结  
- **贪心优先**：先分配最大值，再处理剩余，确保逻辑清晰。  
- **边界判断**：注意`n=p`、`rest=0`等特殊情况，避免遗漏。  
- **代码简洁**：用循环处理剩余记号，避免冗余逻辑（如题解一的`for`循环）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了Unordered_OIer的思路，是最简洁、高效的实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  using namespace std;
  typedef long long ll;
  const int N = 1e5 + 5;
  ll x[N], y[N];

  int main() {
      ll n, m, k, p;
      cin >> n >> m >> k >> p;
      ll q = min(m, k / p); // 最大值
      if (k - q * p > (n - p) * (q - 1)) { // 剩余无法分配
          cout << "NO" << endl;
          return 0;
      }
      // 分配p个q
      for (ll i = 1; i <= p; i++) {
          x[i] = q;
          y[i] = m - q;
      }
      // 处理剩余
      ll rest = k - q * p;
      bool flag = true;
      for (ll i = p + 1; i <= n; i++) {
          if (flag && rest >= q - 1) { // 可以拿q-1
              x[i] = q - 1;
              rest -= q - 1;
          } else if (rest == 0) { // 没有剩余
              x[i] = 0;
          } else { // 拿剩余的
              x[i] = rest;
              rest = 0;
              flag = false;
          }
          y[i] = m - x[i];
      }
      // 输出
      cout << "YES" << endl;
      for (ll i = 1; i <= n; i++) {
          cout << x[i] << " " << y[i] << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  代码分为三部分：① 计算最大值`q`并判断剩余是否可分配；② 分配`p`个`q`；③ 处理剩余记号。通过`for`循环依次处理每个人的`x_i`和`y_i`，逻辑清晰，效率极高。


### 针对各优质题解的片段赏析

#### 题解一：（来源：Unordered_OIer）  
* **亮点**：剩余记号的处理逻辑清晰，无冗余。  
* **核心代码片段**：  
  ```cpp
  ll rest = k - q * p;
  bool flag = true;
  for (ll i = p + 1; i <= n; i++) {
      if (flag && rest >= q - 1) {
          x[i] = q - 1;
          rest -= q - 1;
      } else if (rest == 0) {
          x[i] = 0;
      } else {
          x[i] = rest;
          rest = 0;
          flag = false;
      }
      y[i] = m - x[i];
  }
  ```
* **代码解读**：  
  循环处理剩下的`n-p`个人：  
  - 若`flag`为真（还有剩余可以拿`q-1`）且`rest >= q-1`，则拿`q-1`，剩余减少。  
  - 若`rest`为0，拿0。  
  - 否则，拿剩余的`rest`，并标记`flag`为假（不再拿`q-1`）。  
  这种处理方式确保剩余记号都被分配，且每人的记号数都小于`q`。  
* 💡 **学习笔记**：用`flag`标记是否还能拿`q-1`，避免重复判断。


#### 题解二：（来源：HanPi）  
* **亮点**：平均分配剩余记号的思路。  
* **核心代码片段**：  
  ```cpp
  ll a = k - s; // s = hp * p
  ll h = a / other; // other = n - p
  ll mod = a % other;
  if (mod) each = 1;
  if (hp <= h || hp <= h + each) {
      cout << "NO" << endl;
      return 0;
  }
  ```
* **代码解读**：  
  计算剩余记号`a`，平均每人拿`h`个，剩余`mod`个给`mod`个人各加1个。若`h+1 >= hp`（即剩余分配超过最大值），则无解。这种平均分配的思路帮助我们更直观地理解剩余部分的处理。  
* 💡 **学习笔记**：平均分配可以简化剩余记号的处理，但需要判断是否超过最大值。


#### 题解三：（来源：Maxmilite）  
* **亮点**：`n=p`的特判处理。  
* **核心代码片段**：  
  ```cpp
  if (n == p) {
      if (t * p == k) {
          cout << "YES" << endl;
          for (int i = 1; i <= n; ++i)
              cout << t << " " << m - t << endl;
      } else {
          cout << "NO" << endl;
      }
      return 0;
  }
  ```
* **代码解读**：  
  当`n=p`时，判断`k`是否能被`p`整除。若能，则每人拿`k/p`个；否则，输出`NO`。这种特判处理避免了除数为0的错误（如`n-p=0`时，`(n-p)*(q-1)`无意义）。  
* 💡 **学习笔记**：边界情况需要单独处理，确保代码的健壮性。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《天选之人：像素分配记》  
**风格**：8位FC红白机风格，用像素块表示人、纸团，颜色鲜艳（红色=带记号纸团，蓝色=不带记号纸团）。  
**核心演示内容**：展示贪心分配的全过程——先给`p`个人最大的纸团，再分给其他人。  


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧有`n`个像素人（每个占3x3像素），头顶有一个2x2的框，显示`x_i`（红色）和`y_i`（蓝色）。  
   - 屏幕上方有`k`个红色像素块（带记号纸团），总数量显示在右上角。  
   - 控制面板在屏幕下方：有“开始/暂停”、“单步”、“重置”按钮，以及速度滑块（1x-5x）。  
   - 背景音乐：8位风格的轻快旋律（如《超级马里奥》的背景音）。  

2. **分配`p`个最大值**：  
   - 前`p`个像素人的边框变成红色（标记为最大值），头顶的框中`x_i`增加`q`，`y_i`减少`q`（`y_i = m - q`）。  
   - 上方的红色纸团数量减少`p*q`，伴随“叮”的音效（每分配一个人，响一次）。  

3. **处理剩余记号**：  
   - 剩下的`n-p`个像素人依次被黄色边框标记（当前处理的人）。  
   - 若`rest >= q-1`，则头顶的框中`x_i`增加`q-1`，`y_i`减少`q-1`，上方纸团数量减少`q-1`，伴随“咚”的音效。  
   - 若`rest < q-1`，则头顶的框中`x_i`增加`rest`，`y_i`减少`rest`，上方纸团数量变为0，伴随“叮”的音效（最后一次分配）。  

4. **完成状态**：  
   - 所有像素人的`x_i`和`y_i`显示完毕，上方纸团数量为0。  
   - 播放“胜利”音效（如《魂斗罗》的通关音），屏幕中央显示“分配完成！”的像素文字。  

5. **交互控制**：  
   - “单步”：每点击一次，执行一步分配（如给一个人分配纸团）。  
   - “自动播放”：按速度滑块的速度自动执行，可暂停。  
   - “重置”：恢复初始状态，重新开始。  


### 设计思路  
- **像素风格**：营造复古游戏氛围，让学习更有趣。  
- **颜色标记**：红色边框标记最大值的人，黄色边框标记当前处理的人，帮助区分关键步骤。  
- **音效提示**：不同的音效对应不同的操作（如“叮”=分配最大值，“咚”=分配剩余），强化记忆。  
- **交互控制**：单步和自动播放结合，让学习者可以慢动作观察每一步，也可以快速浏览全过程。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
贪心构造的思路不仅能解决本题，还能用于以下场景：  
- **资源分配问题**：如将有限的资源分配给多个对象，确保某些对象获得最多资源。  
- **排序构造问题**：如构造一个数组，使得恰好`p`个元素是最大值。  
- **计数问题**：如统计满足某些条件的分配方式数量。  


### 练习推荐 (洛谷)  
1. **洛谷 P1090** - 合并果子  
   🗣️ **推荐理由**：这道题是贪心算法的经典题，需要将果子合并成一堆，求最小代价。通过练习，你可以巩固贪心的核心思想（每次选最小的两个合并）。  

2. **洛谷 P2058** - 海港  
   🗣️ **推荐理由**：这道题需要模拟海港的入境情况，统计每艘船到达时，过去24小时内的乘客国籍数量。通过练习，你可以学习模拟和滑动窗口的技巧。  

3. **洛谷 P3817** - 小A的糖果  
   🗣️ **推荐理由**：这道题需要分配糖果，确保每个小朋友的糖果数不超过左右邻居。通过练习，你可以学习贪心构造的边界处理。  

4. **洛谷 P4305** - 不重复数字  
   🗣️ **推荐理由**：这道题需要构造一个数组，使得每个元素都不重复，且尽可能小。通过练习，你可以学习贪心构造的灵活性。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自 Unordered_OIer)  
> “个人觉得算是半道模拟题。”  

**点评**：  
这位作者的经验很实在。本题虽然属于贪心构造，但核心逻辑是模拟分配过程（先分最大值，再分剩余）。模拟题的关键是**逻辑清晰**，将问题拆解成多个步骤，逐一处理。通过练习模拟题，你可以提高代码的逻辑性和健壮性。  


## 结语  
本次关于“天选之人”的C++解题分析就到这里。希望这份学习指南能帮助你理解贪心构造的核心思想，掌握解题技巧。记住，编程能力的提升在于**持续学习、勤于思考和勇于实践**。下次我们再一起探索新的编程挑战！💪

---
处理用时：175.78秒
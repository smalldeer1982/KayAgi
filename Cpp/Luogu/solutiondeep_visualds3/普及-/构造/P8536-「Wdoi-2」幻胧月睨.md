# 题目信息

# 「Wdoi-2」幻胧月睨

## 题目背景

**Problem Number:** $\textit{39}$

**背景与题目无关，选手可以直接看下面的「简要题意」。**

那是在竹取物语之后的故事了，幻想乡距离与现实隔绝也已经过去了百年时光。

地上人向月球发起了侵略战争之后，一只名叫**铃仙**的月兔舍弃了同伴，死里逃生，逃到了在幻想乡内的永远亭，来到了辉夜与永琳的身边，生活得安稳而舒适。

又过了数十年，铃仙接收到了来自月球的使唤，被要求强制返回月球。辉夜与永琳商量了下，决定不将铃仙交还予月球。但为了避免造成麻烦，辉夜与永琳决定将满月消失在地上，只留下一轮虚假的月亮。

-----

为了方便调查异变，八云紫运用自己的能力，将整个幻想乡变成了永夜。

被穿梭回异变发生当时的四组主角，共八人。除了依然留有记忆，可以来回穿梭在虚与实的境界的八云紫之外，其他的人缺乏了记忆，重新开始踏上夺回幻想乡的满月的征途。

在慧音的指引之下，她们来到了迷途竹林，在她们的面前，是一只名叫铃仙的月兔。

## 题目描述

### 简要题意

给定一个长度为 $n$ 的 01 串 $b$，要求构造一个 $n$ 阶排列 $a$，满足，对于 $a_i(2\le i\le n)$，记 $m_i=\max_{j=1}^{i-1}\{a_j\}$，则：
  - 若 $b_i=1$，则 $a_i>m_i$;
  - 否则 $a_i<m_i$。

可以证明，总存在一个数列 $a$ 满足以上条件。

**如果有多组解，输出任意一种。**

同时注意到 $b_1$ 的取值是任意的，对数列 $a$ 没有影响。

### 原始题意

铃仙拥有操纵狂气程度的能力，换而言之，就是操纵物体的波长、振幅以及相位。这种能力为主角制造了种种障碍——例如操纵光波，会让弹幕虚虚实实，甚至会出现虚假的自我，对躲避弹幕造成极大的干扰。

以符卡「幻胧月睨」为例。「幻胧月睨」中一共有 $n$ 个弹幕，每个弹幕都会有一个相位，相位非 $0$ 即 $1$。这些弹幕的相位会构成一个长度为 $n$ 的数列 $\{b_i\}$。

铃仙会操纵这些弹幕的相位，将其变得千奇百怪。具体而言，被操纵了之后的弹幕的相位是一个长度为 $n$ 的**排列** $\{a_i\}$，即 $1 \sim n$ 的数字都会**不重不漏**地出现在这个序列之中。

为了加大主角躲避弹幕的难度，铃仙会设置一个阈值。对于每一个元素 $a_i$，阈值是其**前缀**的**最大**值，即 $a_1,a_2,\dots,a_{i-1}$ 中的最大值。若原来的第 $i$ 个弹幕的相位为 $1$，则被操纵后的弹幕的相位要**大于**这个阈值，否则被操纵后的弹幕的相位要**小于**这个阈值。

显然的是，根据铃仙的操纵规则，无论原本的弹幕的相位如何，都是存在可能的操纵方案的。由于主角们失去了记忆，而找回月亮的时间已经所剩不多了，而且弹幕战对时间的把控要求极高。她们找到了你，希望你能够对铃仙原本的弹幕相位，给出**任意一种**操作后的弹幕相位，来为她们的闪避弹幕进行准备。

## 说明/提示

### 样例解释

- 对于数据 $1$，显然 $a_2>1,a_3>2$。
- 对于数据 $2$，显然 $a_2<2,a_3>2$。
- 对于数据 $3$，显然 $a_2>1,a_3<3,a_4>3$。\
  注意到 $a=\{2,3,1,4\}$ 同样满足要求。

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{Subtask 依赖} & \textbf{分值}\\\hline
1 & 10 & - & - & 5\\\hline
2 & 10^5 & \textbf{A} & - & 5 \\\hline
3 & 10^5 & \textbf{B} & - & 20 \\\hline
4 & 10^5 & - & 1,2,3 &70 \\\hline
\end{array}$$

- **特殊性质** $\textbf{A}$：保证 $b_i$ 都相等。
- **特殊性质** $\textbf{B}$：存在整数 $p\in[2,n]$，使得对于 $1\le i<p$，有 $b_i=1$；对于 $n\ge i\ge p$，有 $b_i=0$。

对于全部数据，满足 $1\le T\le 10^4$，$1\le n\le 10^5$，$\forall i\in[1,n],b_i\in\{0,1\}$。

保证单个测试点内 $\sum n\le 5\times 10^5$。

## 样例 #1

### 输入

```
3
3
111
3
101
4
0101```

### 输出

```
1 2 3
2 1 3
1 3 2 4```

# AI分析结果

# 💡 Kay的C++算法解析：「Wdoi-2」幻胧月睨 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**构造性算法（编程技巧应用）**  

🗣️ **初步分析**：  
解决“幻胧月睨”问题的核心，是**通过规律构造满足条件的排列**。简单来说，我们需要为01串中的每个位置分配一个1~n的数，使得：  
- 当`b_i=1`时，`a_i`是当前前缀的**最大值**（即比前面所有数都大）；  
- 当`b_i=0`时，`a_i`**小于**当前前缀的最大值（即不是前面的最大值）。  

### 核心思路与难点
- **关键观察**：`b_i=1`的位置必须是当前的最大值，因此这些位置的数应该**递增**（比如`x+1, x+2, ..., n`，其中`x`是`b`中0的数量）；而`b_i=0`的位置的数必须**小于**前面的最大值，因此这些位置的数应该**递减**（比如`x, x-1, ..., 1`）。  
- **核心难点**：如何保证`a_i`的分配既满足条件，又不重复且覆盖所有数？  
- **解决方案**：将0和1的位置分开处理——0的位置用“小递减序列”，1的位置用“大递增序列”，两者组合起来就是一个完整的排列。  

### 可视化设计思路
我们可以用**8位像素风格**动画展示构造过程：  
- 屏幕左侧显示01串`b`，每个位置用蓝色（0）或红色（1）标记；  
- 屏幕右侧显示正在构造的排列`a`，每个数用像素块表示，前缀最大值用黄色高亮；  
- 当处理`b_i=1`时，黄色块会“膨胀”（表示最大值增大），并从右侧弹出一个递增的数；  
- 当处理`b_i=0`时，黄色块保持不变，从左侧弹出一个递减的数；  
- 加入“叮”的音效（处理1时）和“滴”的音效（处理0时），增强互动感。  


## 2. 精选优质题解参考

### 题解一：Larryyu（5星）  
* **点评**：  
  这份题解的思路**直白且高效**，抓住了“1的位置必须是最大值”的核心规律。通过统计0的数量`cnt0`，将0的位置分配`cnt0, cnt0-1, ..., 1`（递减小序列），1的位置分配`cnt0+1, cnt0+2, ..., n`（递增大序列）。这种构造方式**天然满足条件**：  
  - 1的位置的数递增，因此每个1的位置都是当前最大值；  
  - 0的位置的数递减，且都小于1的位置的数（因为1的位置的数从`cnt0+1`开始），因此必然小于前面的最大值。  
  代码风格简洁，变量名清晰（`cnt0`表示0的数量，`cnt1`表示1的起始值），非常适合初学者理解。  

### 题解二：McIron233（4.5星）  
* **点评**：  
  此题解用**双向队列**的思路**倒序构造**，非常巧妙。倒序遍历`b`，若`b_i=1`则取队尾（当前最大的剩余数），否则取队头（当前最小的剩余数）。这种方法的正确性基于：  
  - 倒序时，每个位置的选择保证了当前的最大值或最小值，从而正向遍历时有正确的前缀最大值。  
  代码用`hed`（队头）和`til`（队尾）模拟双向队列，逻辑清晰，适合理解“倒序构造”的技巧。  

### 题解三：joyslog（4星）  
* **点评**：  
  此题解用**逆序冒泡**的方法，从初始递增序列出发，若`b_i=0`则交换`a_i`和`a_{i-1}`。这种方法的正确性基于：  
  - 逆序交换不会改变前面的最大值（因为交换的是当前位置和前一个位置，而前一个位置的数已经是前面的最大值）。  
  代码简单易懂，适合理解“调整初始序列”的构造思路，但需要验证交换的正确性（比如是否所有情况都满足条件）。  


## 3. 核心难点辨析与解题策略

### 1. 如何保证`a_i`是当前前缀的最大值？  
* **分析**：  
  对于`b_i=1`的位置，必须让`a_i`比前面所有数都大。因此，这些位置的数应该**递增**（比如`x+1, x+2, ..., n`），这样每个1的位置的数都是当前的最大值。  
* 💡 **学习笔记**：1的位置用递增序列，天然满足“最大值”条件。  

### 2. 如何保证`a_i`小于当前前缀的最大值？  
* **分析**：  
  对于`b_i=0`的位置，必须让`a_i`小于前面的最大值。因此，这些位置的数应该**递减**（比如`x, x-1, ..., 1`），且都小于1的位置的数（因为1的位置的数从`x+1`开始）。  
* 💡 **学习笔记**：0的位置用递减小序列，必然小于前面的最大值。  

### 3. 如何避免重复且覆盖所有数？  
* **分析**：  
  0的数量是`x`，因此0的位置的数是`1~x`的递减序列；1的位置的数是`x+1~n`的递增序列，两者组合起来就是`1~n`的完整排列。  
* 💡 **学习笔记**：分治思想——将问题分成0和1两部分，分别处理。  

### ✨ 解题技巧总结  
- **规律观察**：通过样例发现1的位置需要递增，0的位置需要递减；  
- **分治处理**：将0和1的位置分开，用不同的序列构造；  
- **简洁代码**：避免复杂逻辑，用统计和循环实现构造。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（来自Larryyu）  
* **说明**：此代码是构造性算法的典型实现，思路清晰，效率极高（时间复杂度`O(n)`）。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <string>
  using namespace std;

  int main() {
      int t;
      cin >> t;
      while (t--) {
          int n, cnt0 = 0;
          string s;
          cin >> n >> s;
          for (char c : s) cnt0 += (c == '0'); // 统计0的数量
          int cnt1 = cnt0 + 1; // 1的起始值
          for (char c : s) {
              if (c == '0') cout << cnt0-- << " "; // 0的位置输出递减
              else cout << cnt1++ << " "; // 1的位置输出递增
          }
          cout << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 读取测试用例数量`t`；  
  2. 对于每个测试用例，统计0的数量`cnt0`；  
  3. 1的起始值是`cnt0+1`（因为0的位置用了`1~cnt0`）；  
  4. 遍历01串，0的位置输出`cnt0`并递减，1的位置输出`cnt1`并递增。  

### 题解一：Larryyu（核心片段）  
* **亮点**：用统计和循环实现构造，代码简洁。  
* **核心代码片段**：  
  ```cpp
  for (char c : s) cnt0 += (c == '0');
  int cnt1 = cnt0 + 1;
  for (char c : s) {
      if (c == '0') cout << cnt0-- << " ";
      else cout << cnt1++ << " ";
  }
  ```
* **代码解读**：  
  - 第一行统计0的数量`cnt0`；  
  - 第二行设置1的起始值`cnt1`（`cnt0+1`）；  
  - 第三行遍历01串，0的位置输出`cnt0`并递减（比如`cnt0=2`，输出2、1），1的位置输出`cnt1`并递增（比如`cnt1=3`，输出3、4）。  
* 💡 **学习笔记**：统计0的数量是关键，它决定了0和1的序列范围。  

### 题解二：McIron233（核心片段）  
* **亮点**：用双向队列倒序构造，思路巧妙。  
* **核心代码片段**：  
  ```cpp
  int hed = 1, til = n;
  for (int i = n; i >= 1; i--) {
      if (ch[i] == '1') a[i] = til--; // 取队尾（最大）
      else a[i] = hed++; // 取队头（最小）
  }
  ```
* **代码解读**：  
  - `hed`是队头（最小剩余数），`til`是队尾（最大剩余数）；  
  - 倒序遍历`b`，若`b_i=1`则取队尾（比如`til=4`，输出4，`til`变为3），否则取队头（比如`hed=1`，输出1，`hed`变为2）；  
  - 正向输出`a`数组，得到正确排列。  
* 💡 **学习笔记**：倒序构造可以简化前缀最大值的处理。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题  
**“像素数列构造师”**（仿FC游戏风格）  

### 核心演示内容  
展示Larryyu的构造过程，包括：  
- 01串`b`的像素化显示（蓝色=0，红色=1）；  
- 排列`a`的动态构造（每个数用像素块表示）；  
- 前缀最大值的黄色高亮（随1的位置递增而增大）。  

### 设计思路简述  
- **8位像素风格**：用简单的色块和低分辨率，营造复古游戏氛围；  
- **音效增强**：处理1时播放“叮”的音效（表示最大值增大），处理0时播放“滴”的音效（表示数值减小）；  
- **互动控制**：支持“单步执行”（逐位置构造）、“自动播放”（快速演示）和“重置”（重新开始）。  

### 动画帧步骤  
1. **初始化**：屏幕左侧显示01串`b`（比如“101”），右侧显示空排列`a`；  
2. **统计0的数量**：弹出提示框“0的数量是1”，并标记`cnt0=1`；  
3. **构造第一个位置**（`b_1=1`）：右侧弹出红色像素块“2”（`cnt1=2`），黄色高亮“2”（前缀最大值）；  
4. **构造第二个位置**（`b_2=0`）：右侧弹出蓝色像素块“1”（`cnt0=1`），黄色高亮保持“2”；  
5. **构造第三个位置**（`b_3=1`）：右侧弹出红色像素块“3”（`cnt1=3`），黄色高亮增大到“3”；  
6. **完成**：播放“胜利”音效，显示完整排列“2 1 3”。  

### 旁白提示  
- “现在处理第1位，b_i=1，需要输出当前最大的数2！”（伴随“叮”声）；  
- “现在处理第2位，b_i=0，需要输出当前最小的数1！”（伴随“滴”声）；  
- “排列完成！检查一下：每个1的位置都是最大值，0的位置都小于最大值～”  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
构造性算法的核心是**找到规律并分治处理**，适用于以下场景：  
- 生成满足特定顺序条件的排列（如本题）；  
- 构造满足贪心条件的序列（如合并果子）；  
- 设计满足约束条件的数组（如最大子段和）。  

### 练习推荐（洛谷）  
1. **洛谷 P8536** - 「Wdoi-2」幻胧月睨  
   🗣️ **推荐理由**：本题的原题，巩固构造性算法的应用。  
2. **洛谷 P1090** - [NOIP2004 提高组] 合并果子  
   🗣️ **推荐理由**：用贪心思路构造最优合并顺序，锻炼规律观察能力。  
3. **洛谷 P1223** - 排队接水  
   🗣️ **推荐理由**：构造满足最短等待时间的序列，巩固分治处理的技巧。  


## 7. 学习心得与经验分享（若有）  
* **参考经验（来自Larryyu）**：“我一开始没想到分治处理，后来通过样例发现1的位置必须递增，0的位置必须递减，于是想到统计0的数量，分开处理。”  
* **点评**：这位作者的经验很典型——**通过样例找规律**是解决构造题的关键。当遇到复杂问题时，不妨先看样例，总结规律，再尝试构造解法。  


## 结语  
本次关于“幻胧月睨”的C++解题分析就到这里。希望这份指南能帮助大家理解构造性算法的核心思路，掌握分治处理的技巧。记住，构造题的关键是**找规律**，只要找到规律，代码就会变得简洁高效！下次我们再一起探索新的编程挑战！💪

---
处理用时：157.31秒
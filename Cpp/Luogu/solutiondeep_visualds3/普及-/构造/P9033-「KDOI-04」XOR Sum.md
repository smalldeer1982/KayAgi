# 题目信息

# 「KDOI-04」XOR Sum

## 题目背景

凯文一眼秒了这题。

![](https://cdn.luogu.com.cn/upload/image_hosting/lh1xvu75.png)

## 题目描述

给定一个正整数 $n$，请构造一个长度为 $n$ 的**非负整数**序列 $a_1,a_2,\dots,a_n$，满足：

+ 对于所有 $1\le i\le n$，都有 $0\le a_i\le m$。
+ $a_1\oplus a_2\oplus\dots\oplus a_n=k$。其中 $\oplus$ 表示[按位异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)运算。

或者判断不存在这样的序列。

## 说明/提示

**【样例解释】**

对于第 $1$ 组测试数据，有且仅有一个序列满足条件。

对于第 $2$ 组测试数据，由于 $4\oplus 7=3$ 且 $4,7\le10$，所以这是一个合法的答案。同样地，序列 $(2,1)$ 也是一个合法的答案。

对于第 $4$ 组测试数据，可以证明不存在满足要求的序列。

**【数据范围】**

记 $\sum n$ 为单个测试点中所有 $n$ 的值之和。

对于所有测试数据，保证 $1\le T\le 1~000$，$1\le n\le 2\cdot10^5$，$0\le m,k\le 10^8$，$\sum n\le 2\cdot10^5$。

**【子任务】**

**本题开启捆绑测试。**

+ Subtask 1 (18 pts)：$k\le m$。
+ Subtask 2 (82 pts)：没有额外的约束条件。

## 样例 #1

### 输入

```
5
1 2 2
2 3 10
2 11 8
20 200000 99999
11 191 9810```

### 输出

```
2 
4 7 
8 3 
-1
191 191 191 191 191 191 191 191 191 191 191 ```

# AI分析结果

# 💡 Kay的C++算法解析：「KDOI-04」XOR Sum 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**数学（异或性质应用）** + **构造性编程技巧**  

🗣️ **初步分析**：  
解决“XOR Sum”的关键，是**用异或的“不进位加法”性质构造序列**。异或就像“二进制加法但不进位”——比如`1+1=2`（二进制`10`），但`1⊕1=0`（只保留每一位的“不同”）。我们需要用**不超过m的数**，通过异或凑出k，就像用“不进位的积木”搭出目标数字。  

### 核心思路与难点
- **无解判断**：如果k的二进制位数比m多（比如k=8=1000₂，m=7=0111₂），异或无法“变出”更高位，直接输出-1。  
- **构造策略**：  
  - 若`k≤m`：直接用`k`加`n-1`个0（因为`k⊕0⊕…⊕0=k`）。  
  - 若`k>m`：需拆成两个数`a`和`b`，使得`a⊕b=k`且`a,b≤m`。**技巧**：取k的最高位（比如k=11=1011₂，最高位是8=1000₂），则`a=8`，`b=k⊕a=3`（1011⊕1000=0011），此时`a≤m`（因为k的位数不超过m），`b< a≤m`。  
- **核心难点**：如何正确拆分k为两个不超过m的数，以及处理`n=1`时的特殊情况（此时无法拆分，k>m则无解）。  

### 可视化设计思路
我打算用**8位像素风动画**展示拆分过程：  
- **场景**：屏幕左侧是k的二进制积木（比如1011₂），右侧是m的二进制边界（比如1111₂）。  
- **步骤**：  
  1. 高亮k的最高位（比如1000₂），用“咔嚓”音效拆分出来，变成第一个数`a`。  
  2. 计算`b=k⊕a`（比如0011₂），用“叮”音效显示`b`。  
  3. 剩下的位置用0填充，伴随“补零”音效。  
- **交互**：支持“单步执行”（点击拆分每一位）、“自动播放”（像FC游戏一样逐步演示），还有“重置”按钮重新开始。  


## 2. 精选优质题解参考

为了帮大家快速掌握核心思路，我筛选了3份**思路清晰、代码简洁**的优质题解：


### **题解一：JuRuoOIer（赞11）**  
* **点评**：这份题解是“构造题的标准模板”！作者把问题拆成“无解判断→k≤m→k>m”三个情况，逻辑链非常清晰。代码里用`log2`计算二进制位数（比如`log2(8)=3`，对应1000₂），直接判断k的位数是否超过m，避免了复杂的位运算。对于k>m的情况，作者巧妙地取k的最高位（`1<<(log2(k)-1)`），然后计算剩余部分，这种“拆分最高位”的技巧是解决异或构造问题的关键。代码注释详细，变量命名直观（比如`n,k,m`对应题目中的参数），非常适合初学者模仿。


### **题解二：佬头（赞3）**  
* **点评**：这份题解的“亮点”是**用异或性质简化拆分**！作者发现，当`k>m`且位数相同时，`m⊕k`一定≤m（比如m=10=1010₂，k=11=1011₂，`m⊕k=0001₂=1≤10`）。因此，直接输出`m`和`m⊕k`，后面补0即可。这种思路比“拆分最高位”更简洁，因为它利用了异或的逆运算（`a⊕b=c → b=a⊕c`），减少了计算量。代码只有几十行，却处理了所有情况，非常高效。


### **题解三：Clarinet（赞0）**  
* **点评**：这份题解的“check函数”很实用！作者写了一个`check`函数，专门判断m的位数是否小于k（比如`check(m,k)`返回true表示m的位数更小，无解）。这种“功能模块化”的编程习惯值得学习——把重复的逻辑写成函数，让主代码更清晰。另外，作者用`k^m`计算另一个数，和佬头的思路一致，但代码结构更直观，适合新手理解。


## 3. 核心难点辨析与解题策略

在解决本题时，大家容易遇到以下3个难点，我结合优质题解总结了应对策略：


### **1. 如何判断k的位数是否超过m？**  
- **难点**：直接比较k和m的大小不够（比如k=8，m=7，k>m但位数相同？不，8是1000₂，7是0111₂，位数不同）。  
- **策略**：计算二进制位数（比如用`log2`函数，或者循环右移直到为0）。比如JuRuoOIer的代码用`log2(k)`计算k的位数，若`log2(m) < log2(k)`，则无解。  
- 💡 **学习笔记**：位数判断是异或构造题的“第一道门槛”，必须掌握！


### **2. 如何拆分k为两个不超过m的数？**  
- **难点**：k>m时，如何保证拆分后的两个数都≤m？  
- **策略**：  
  - 方法一（拆分最高位）：取k的最高位`a=1<<(log2(k)-1)`，则`b=k⊕a`，此时`a≤m`（因为k的位数不超过m），`b< a≤m`（比如k=11=1011₂，a=8=1000₂，b=3=0011₂）。  
  - 方法二（异或逆运算）：取`a=m`，则`b=k⊕a`，此时`b≤m`（因为k和m位数相同，异或后不会超过m）。  
- 💡 **学习笔记**：异或的逆运算（`a⊕b=c → b=a⊕c`）是构造题的“神器”，要记住！


### **3. 如何处理n=1的情况？**  
- **难点**：n=1时，无法拆分k，只能直接输出k，但k必须≤m。  
- **策略**：在k>m的情况下，若n=1，直接输出-1。比如JuRuoOIer的代码中，当`m<k`且`n==1`时，输出-1。  
- 💡 **学习笔记**：边界条件（比如n=1、m=0）是构造题的“陷阱”，必须单独处理！


### ✨ 解题技巧总结  
- **模块化思维**：把位数判断、拆分逻辑写成函数，让代码更清晰（比如Clarinet的`check`函数）。  
- **异或性质**：记住“异或的逆运算”和“不进位加法”，这是解决异或构造题的关键。  
- **边界处理**：永远不要忽略特殊情况（比如n=1、k=0、m=0）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了JuRuoOIer和佬头的思路，兼顾清晰性和高效性。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cmath>
  using namespace std;

  int get_bits(int x) { // 计算二进制位数（比如x=8→4位）
      if (x == 0) return 1;
      int cnt = 0;
      while (x) {
          cnt++;
          x >>= 1;
      }
      return cnt;
  }

  int main() {
      int T;
      cin >> T;
      while (T--) {
          int n, k, m;
          cin >> n >> k >> m;
          if (get_bits(m) < get_bits(k)) { // m的位数不够，无解
              cout << "-1\n";
              continue;
          }
          if (k <= m) { // 直接用k加0
              cout << k;
              for (int i = 1; i < n; i++) cout << " 0";
              cout << "\n";
          } else { // 拆分k为两个数
              if (n == 1) { // 无法拆分，无解
                  cout << "-1\n";
                  continue;
              }
              // 方法一：拆分最高位（JuRuoOIer的思路）
              int highest = 1 << (get_bits(k) - 1);
              int a = highest;
              int b = k ^ a;
              // 方法二：用异或逆运算（佬头的思路）
              // int a = m;
              // int b = k ^ a;
              cout << a << " " << b;
              for (int i = 2; i < n; i++) cout << " 0";
              cout << "\n";
          }
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. `get_bits`函数计算二进制位数，用于判断无解。  
  2. 主循环处理多组测试用例：  
     - 先判断m的位数是否小于k，若是则输出-1。  
     - 若k≤m，输出k加n-1个0。  
     - 若k>m，拆分k为两个数（这里用了拆分最高位的方法，注释里有佬头的异或逆运算方法），输出这两个数加n-2个0。  


### 针对各优质题解的片段赏析

#### **题解一：JuRuoOIer（拆分最高位）**  
* **亮点**：用`log2`计算最高位，直接拆分k。  
* **核心代码片段**：  
  ```cpp
  int log2(ll x) { // 计算二进制位数（比如x=8→3）
      ll ans = 0;
      while (x) {
          ans++;
          x /= 2;
      }
      return ans;
  }
  // 拆分最高位
  cout << (1ll << (log2(k)-1)) << ' ' << (k - (1ll << (log2(k)-1)));
  ```  
* **代码解读**：  
  - `log2`函数计算k的二进制位数（比如k=11→4位），`1ll << (log2(k)-1)`得到最高位（比如1000₂=8）。  
  - `k - 最高位`得到剩余部分（比如11-8=3），而`k⊕最高位`等于剩余部分（因为最高位只有一个1，异或后相当于减去）。  
* 💡 **学习笔记**：`1ll << x`是计算2^x的常用技巧，要注意数据类型（用long long避免溢出）。


#### **题解二：佬头（异或逆运算）**  
* **亮点**：用`m⊕k`直接得到另一个数，简化拆分。  
* **核心代码片段**：  
  ```cpp
  if ((m ^ k) <= m && n > 1) {
      for (int i = 2; i < n; ++i) fputs("0 ", stdout);
      write(m), putchar(' ');
      write(m ^ k), putchar('\n');
  }
  ```  
* **代码解读**：  
  - `m ^ k`是异或的逆运算，相当于“用m凑k”——因为`m⊕(m^k)=k`。  
  - 由于k和m位数相同，`m^k`一定≤m（比如m=10=1010₂，k=11=1011₂，`m^k=0001₂=1≤10`）。  
* 💡 **学习笔记**：异或的逆运算可以快速得到另一个数，避免计算最高位，是更高效的技巧。


#### **题解三：Clarinet（check函数）**  
* **亮点**：用函数模块化处理位数判断。  
* **核心代码片段**：  
  ```cpp
  bool check(int x, int y) { // 判断x的位数是否小于y
      int xr = 0, yr = 0;
      while (x) { xr++; x /= 2; }
      while (y) { yr++; y /= 2; }
      return xr < yr;
  }
  ```  
* **代码解读**：  
  - `check(m, k)`返回true表示m的位数小于k，此时无解。  
  - 把位数判断写成函数，让主代码更简洁，避免重复代码。  
* 💡 **学习笔记**：模块化编程是提高代码可读性的关键，要养成写函数的习惯。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：**异或积木拆分游戏**（8位像素风）  
**设计思路**：用“积木”表示二进制位，模拟拆分k的过程，结合FC游戏的音效和交互，让学习更有趣。


### 📺 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示k的二进制积木（比如k=11=1011₂，用4块红色积木表示）。  
   - 屏幕右侧显示m的二进制边界（比如m=15=1111₂，用4块绿色积木表示）。  
   - 底部有“开始/暂停”“单步”“重置”按钮，以及速度滑块（从“慢”到“快”）。  
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。  

2. **无解判断**：  
   - 如果k的积木数量超过m（比如k=8=1000₂，m=7=0111₂），屏幕闪烁红色，播放“错误”音效（短促的“哔”声），显示“无解”。  

3. **k≤m的情况**：  
   - 用黄色高亮k的积木，播放“选中”音效（“叮”声），然后在右侧显示n-1块灰色积木（表示0），最后播放“完成”音效（上扬的“滴”声）。  

4. **k>m的情况**：  
   - **步骤1（拆分最高位）**：用蓝色高亮k的最高位积木（比如1000₂），播放“咔嚓”音效，把它移到序列的第一个位置。  
   - **步骤2（计算剩余部分）**：用绿色高亮剩余的积木（比如0011₂），播放“叮”音效，把它移到序列的第二个位置。  
   - **步骤3（补零）**：在后面显示n-2块灰色积木，播放“补零”音效（连续的“嗒”声）。  

5. **交互功能**：  
   - **单步执行**：点击“单步”按钮，逐步演示拆分过程（每步对应一个动画帧）。  
   - **自动播放**：点击“开始”按钮，动画自动播放，速度可以通过滑块调整（慢：1秒/步，快：0.2秒/步）。  
   - **重置**：点击“重置”按钮，回到初始状态，重新开始。  

6. **游戏化元素**：  
   - **关卡设计**：把拆分过程分成“判断位数”“拆分最高位”“补零”三个小关卡，完成每个关卡后显示“过关”动画（比如像素星星闪烁）。  
   - **积分系统**：每完成一个关卡得10分，完成整个动画得50分，鼓励用户多次尝试。  


## 6. 拓展练习与相似问题思考

### 🔍 通用思路迁移  
本题的**异或构造技巧**可以应用到以下场景：  
- **凑数问题**：用不超过m的数，通过异或凑出目标值（比如洛谷P1469）。  
- **路径问题**：在网格中找到一条路径，使得路径上的数异或和为k（比如洛谷P2114）。  
- **密码学问题**：用异或进行加密（比如一次性密码本）。  


### 📚 洛谷练习推荐  
1. **洛谷 P1469** - 找筷子  
   * 🗣️ **推荐理由**：这道题需要用异或找到出现奇数次的数，是异或性质的基础应用，帮助你巩固异或的“消去”特性（`a⊕a=0`）。  

2. **洛谷 P2114** - 起床困难综合症  
   * 🗣️ **推荐理由**：这道题需要用异或和其他位运算构造最大的数，是异或构造题的进阶练习，帮助你理解如何组合位运算。  

3. **洛谷 P3901** - 数列找不同  
   * 🗣️ **推荐理由**：这道题需要用异或找到唯一的不同数，是异或性质的灵活应用，帮助你掌握异或的“唯一性”（`a⊕b⊕a=b`）。  


## 7. 学习心得与经验分享 (若有)

### 📝 来自题解作者的经验  
- **JuRuoOIer**：“我一开始没想到拆分最高位，后来想通了异或的‘不进位’性质，才找到思路。”  
  * **点评**：异或的性质是解决本题的关键，一定要多理解、多练习。  
- **佬头**：“用m⊕k的思路是我在调试时想到的，因为异或的逆运算很方便。”  
  * **点评**：调试时可以尝试不同的思路，有时候逆运算会简化问题。  


## 🎉 总结  
本次分析的“XOR Sum”题，核心是**异或性质的应用**和**构造性编程技巧**。通过拆分k为不超过m的数，结合异或的逆运算，我们可以快速构造出符合要求的序列。希望这份指南能帮助你掌握异或的精髓，下次遇到类似问题时，也能像凯文一样“一眼秒题”！💪  

如果有任何疑问，欢迎在评论区留言，我会尽力解答！😊

---
处理用时：164.45秒
# 题目信息

# [NOIP 2001 普及组] 最大公约数和最小公倍数问题

## 题目描述

输入两个正整数 $x_0, y_0$，求出满足下列条件的 $P, Q$ 的个数：

1. $P,Q$ 是正整数。

2. 要求 $P, Q$ 以 $x_0$ 为最大公约数，以 $y_0$ 为最小公倍数。

试求：满足条件的所有可能的 $P, Q$ 的个数。

## 说明/提示

$P,Q$ 有 $4$ 种：

1. $3, 60$。
2. $15, 12$。
3. $12, 15$。
4. $60, 3$。

对于 $100\%$ 的数据，$2 \le x_0, y_0 \le {10}^5$。

**【题目来源】**

NOIP 2001 普及组第二题

## 样例 #1

### 输入

```
3 60
```

### 输出

```
4
```

# AI分析结果



---
# 💡 Kay的C++算法解析：最大公约数和最小公倍数问题 深入学习指南 💡

<introduction>
今天我们来一起分析“最大公约数和最小公倍数问题”这道经典的C++编程题。这道题需要我们灵活运用数论知识，特别是最大公约数（gcd）和最小公倍数（lcm）的性质。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论性质应用）`

🗣️ **初步分析**：
解决这道题的关键在于理解并运用数论中的核心性质：两个数的乘积等于它们的最大公约数与最小公倍数的乘积（即 \( P \times Q = \gcd(P,Q) \times \text{lcm}(P,Q) \)）。简单来说，这就像“拼图游戏”——已知拼图的总块数（\( x_0 \times y_0 \)）和每块的最小重复单元（\( x_0 \)），我们需要找出所有可能的拼图方式（\( P, Q \)）。

在本题中，已知 \( \gcd(P,Q)=x_0 \) 且 \( \text{lcm}(P,Q)=y_0 \)，因此 \( P \times Q = x_0 \times y_0 \)。我们需要找到所有满足 \( \gcd(P,Q)=x_0 \) 的正整数对 \( (P,Q) \)。

- **题解思路**：大部分题解通过枚举 \( x_0 \times y_0 \) 的因数 \( i \)，计算 \( Q = \frac{x_0 \times y_0}{i} \)，并检查 \( \gcd(i, Q) \) 是否等于 \( x_0 \)。由于 \( (P,Q) \) 和 \( (Q,P) \) 是不同的解（除非 \( P=Q \)），因此只需枚举到 \( \sqrt{x_0 \times y_0} \)，每找到一组符合条件的 \( (i, Q) \) 就将答案加2，最后特判 \( x_0=y_0 \) 的情况避免重复计数。
- **核心难点**：如何高效枚举因数、如何处理重复计数（如 \( P=Q \) 的情况）、如何利用数论性质简化判断。
- **可视化设计**：我们将设计一个8位像素风格的动画，用“因数小精灵”在数轴上跳跃枚举，每找到一个符合条件的因数对就触发“叮”的音效，并用不同颜色标记当前枚举的 \( i \) 和 \( Q \)，高亮 \( \gcd \) 计算结果是否等于 \( x_0 \)。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解在多个方面表现突出（评分≥4星），值得重点学习：
</eval_intro>

**题解一：作者樱雪喵（赞：678）**
* **点评**：此题解思路简洁直接，代码短小精悍（目前最短AC代码）。作者明确指出了枚举到 \( \sqrt{x_0 \times y_0} \) 的原因（避免重复计数），并通过特判 \( x_0=y_0 \) 处理了 \( P=Q \) 的情况。代码中使用 `__gcd` 函数简化计算，边界处理严谨（如用 `long long` 避免溢出），非常适合竞赛环境参考。

**题解二：作者sochiji（赞：259）**
* **点评**：此题解从素因数分解的角度深入分析，通过数学定理推导（如算术基本定理）解释了问题本质。作者用通俗语言说明“素因子指数的最小/最大值决定gcd/lcm”，帮助学习者理解问题的数学模型。代码通过分解 \( \frac{y_0}{x_0} \) 的素因子数量计算解的个数（\( 2^{\text{素因子个数}} \)），思路新颖且高效，适合希望深入理解数论原理的学习者。

**题解三：作者zhangboju（赞：61）**
* **点评**：此题解详细推导了gcd的性质（如 \( \gcd(a,b)=\gcd(b,a\%b) \)）和 \( \gcd \times \text{lcm}=a \times b \) 的定理，代码逐步优化（从int到long long避免溢出），并解释了每个步骤的数学依据。对于需要理解算法背后数学原理的学习者，此题解是很好的参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何高效枚举因数？
    * **分析**：直接枚举所有可能的 \( P \) 会导致超时（\( x_0 \times y_0 \) 可能很大）。优质题解通过枚举到 \( \sqrt{x_0 \times y_0} \) 优化，因为 \( P \) 和 \( Q \) 是成对出现的（\( P \times Q = x_0 \times y_0 \)），枚举到平方根即可覆盖所有情况。
    * 💡 **学习笔记**：枚举因数时，只需要枚举到平方根，每找到一个因数 \( i \)，就对应另一个因数 \( \frac{x_0 \times y_0}{i} \)，避免重复计算。

2.  **关键点2**：如何判断 \( \gcd(P,Q)=x_0 \)？
    * **分析**：根据 \( P \times Q = x_0 \times y_0 \)，设 \( P=i \)，则 \( Q=\frac{x_0 \times y_0}{i} \)。只需计算 \( \gcd(i, Q) \)，若等于 \( x_0 \)，则 \( (i, Q) \) 是有效解。优质题解利用C++的 `__gcd` 函数或自定义gcd函数快速计算。
    * 💡 **学习笔记**：判断 \( \gcd(P,Q)=x_0 \) 是核心条件，直接决定解的有效性。

3.  **关键点3**：如何处理重复计数？
    * **分析**：当 \( P=Q \) 时，\( (P,Q) \) 和 \( (Q,P) \) 是同一组解，需特判。此时 \( P=Q=\sqrt{x_0 \times y_0} \)，且 \( x_0=y_0 \)（因为 \( \gcd(P,P)=P=x_0 \)，\( \text{lcm}(P,P)=P=y_0 \)）。
    * 💡 **学习笔记**：当 \( x_0=y_0 \) 时，需将答案减1，避免重复计数。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将原问题转化为枚举 \( x_0 \times y_0 \) 的因数对，利用 \( P \times Q = x_0 \times y_0 \) 简化问题。
- **边界处理**：用 `long long` 类型存储 \( x_0 \times y_0 \) 避免溢出。
- **数学性质应用**：利用 \( \gcd \times \text{lcm}=a \times b \) 减少计算步骤。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了樱雪喵和zhangboju的题解思路，采用枚举因数并特判重复的方法，代码简洁高效，适合竞赛环境。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;

    int main() {
        ll x0, y0;
        cin >> x0 >> y0;
        ll product = x0 * y0;
        ll ans = 0;
        // 枚举因数i，i <= sqrt(product)
        for (ll i = 1; i * i <= product; ++i) {
            if (product % i == 0) { // i是product的因数
                ll j = product / i;
                if (__gcd(i, j) == x0) { // 检查gcd是否等于x0
                    ans += 2; // (i,j)和(j,i)是两组解
                    if (i == j) ans -= 1; // 若i=j，只算一组
                }
            }
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先计算 \( x_0 \times y_0 \) 的乘积 `product`，然后枚举 `i` 从1到 `sqrt(product)`。对于每个 `i`，若 `i` 是 `product` 的因数（`product % i == 0`），则计算对应的 `j = product / i`。检查 `gcd(i, j)` 是否等于 `x0`，若成立则 `ans` 加2（因为 `(i,j)` 和 `(j,i)` 是两组解）。若 `i == j`（即 `product` 是完全平方数），则需减1避免重复计数。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者樱雪喵**
* **亮点**：代码极简，利用 `__gcd` 函数简化计算，通过 `n *= m` 巧妙存储乘积，枚举到 `sqrt(n)` 优化时间复杂度。
* **核心代码片段**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    long long m,n,ans;
    int main(){
        cin>>m>>n;
        if(m==n) ans--;
        n*=m;
        for(long long i=1;i<=sqrt(n);i++){
            if(n%i==0&&__gcd(i,n/i)==m) ans+=2;
        }
        cout<<ans;
        return 0;
    }
    ```
* **代码解读**：
    > 这段代码首先特判 `m == n`（即 \( x_0 = y_0 \)）的情况，将 `ans` 初始减1（后续枚举会加2，最终结果正确）。然后计算 `n = m * n`（即 \( x_0 \times y_0 \)），枚举 `i` 到 `sqrt(n)`，检查 `i` 是否是 `n` 的因数且 `gcd(i, n/i) == m`（即 \( x_0 \)）。每找到一组解，`ans` 加2（对应 `(i, n/i)` 和 `(n/i, i)`）。
* 💡 **学习笔记**：特判 `x0 == y0` 是关键，避免重复计数。

**题解二：作者sochiji**
* **亮点**：从素因数分解角度切入，通过统计 \( \frac{y_0}{x_0} \) 的素因子个数计算解的个数（\( 2^{\text{素因子个数}} \)），思路新颖。
* **核心代码片段**：
    ```cpp
    #include <iostream>
    int main() {
        int x, y;
        std::cin >> x >> y;
        if (y % x != 0)
            std::cout << 0;
        else {
            int quotient = y / x;
            int count = 0;
            int currentFactor = 2;
            while (quotient > 1) {
                if (quotient % currentFactor == 0) {
                    count++;
                    while (quotient % currentFactor == 0)
                        quotient /= currentFactor;
                }
                currentFactor++;
            }
            std::cout << (1 << count);
        }
        return 0;
    }
    ```
* **代码解读**：
    > 这段代码首先检查 \( y_0 \) 是否能被 \( x_0 \) 整除（否则无解）。然后计算 \( \text{quotient} = \frac{y_0}{x_0} \)，并分解其素因子。每找到一个不同的素因子，`count` 加1。最终解的个数是 \( 2^{\text{count}} \)（每个素因子可分配给 \( P \) 或 \( Q \)）。
* 💡 **学习笔记**：素因子分解是理解问题本质的关键，每个素因子的分配方式决定解的数量。

**题解三：作者zhangboju**
* **亮点**：详细推导gcd性质，代码逐步优化（从int到long long避免溢出），解释每个步骤的数学依据。
* **核心代码片段**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    long long x,y;
    inline long long gcd(long long x,long long y){
        if(y==0) return x;
        return gcd(y,x%y);
    }
    int main(){
        cin>>x>>y;
        long long ans=0;
        for(long long i=1;i<=sqrt(x*y);i++){
            if(x*y%i==0&&gcd(i,x*y/i)==x) ans++;
        }
        ans*=2;
        if(x==y) ans--;
        cout<<ans;
        return 0;
    }
    ```
* **代码解读**：
    > 这段代码自定义了gcd函数，枚举 `i` 到 `sqrt(x*y)`，统计符合条件的因数个数。每找到一个因数对，`ans` 加1（后续乘2）。最后特判 `x == y` 调整答案。
* 💡 **学习笔记**：自定义gcd函数更灵活，适合不熟悉内置函数的场景。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“枚举因数并判断gcd”的过程，我设计了一个8位像素风格的动画，名为“因数探险队”。让我们一起看看这个动画如何工作！
</visualization_intro>

  * **动画演示主题**：`因数探险队的平方根之旅`

  * **核心演示内容**：演示枚举 \( x_0 \times y_0 \) 的因数 \( i \)，计算 \( Q = \frac{x_0 \times y_0}{i} \)，并检查 \( \gcd(i, Q) \) 是否等于 \( x_0 \) 的过程。

  * **设计思路简述**：采用FC红白机风格的像素画面，用“探险队”角色在数轴上跳跃枚举因数，每找到一个符合条件的因数对，就触发“叮”的音效并点亮像素块。通过颜色标记当前枚举的 \( i \) 和 \( Q \)，以及gcd的计算结果，帮助学习者直观看到每一步的逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是数轴（像素点表示1到 \( \sqrt{x_0 \times y_0} \) 的整数），右侧是“因数对展示区”（显示当前 \( i \) 和 \( Q \)）。
          * 控制面板包含“单步”、“自动播放”、“重置”按钮和速度滑块。
          * 播放8位风格的轻快背景音乐（类似《超级玛丽》的经典旋律）。

    2.  **枚举因数**：
          * 探险队角色（一个黄色像素小人）从数轴的1开始，逐个跳到下一个整数 \( i \)。
          * 当 \( i \) 是 \( x_0 \times y_0 \) 的因数时（即 \( x_0 \times y_0 \% i == 0 \)），数轴上的 \( i \) 像素块变为绿色，同时右侧展示 \( Q = \frac{x_0 \times y_0}{i} \)。

    3.  **检查gcd**：
          * 弹出一个小窗口计算 \( \gcd(i, Q) \)，用像素数字显示结果。若结果等于 \( x_0 \)，窗口变为蓝色并播放“叮”的音效；否则变为红色并播放“噗”的音效。
          * 若符合条件，因数对展示区将 \( (i, Q) \) 和 \( (Q, i) \) 用星号标记，答案计数器加2（若 \( i \neq Q \)）或加1（若 \( i = Q \)）。

    4.  **特判重复**：
          * 当 \( i = Q \) 时（即 \( i \times i = x_0 \times y_0 \)），探险队角色会举起“注意重复”的小旗子，答案计数器减1。

    5.  **结束动画**：
          * 枚举完成后，答案计数器显示最终结果，播放胜利音效（如《超级玛丽》的通关音乐），所有符合条件的因数对像素块闪烁庆祝。

  * **旁白提示**：
      * （枚举到 \( i \) 时）“现在检查因数 \( i = \) [数值]，对应的 \( Q = \) [数值]。”
      * （计算gcd时）“计算 \( \gcd(i, Q) \)，结果是 [数值]，是否等于 \( x_0 \)？”
      * （符合条件时）“找到一组解！答案加2！”
      * （\( i = Q \) 时）“注意，\( i \) 和 \( Q \) 相等，答案需要减1哦！”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到因数枚举、gcd计算和答案统计的全过程，让抽象的数学逻辑变得生动有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考数论中gcd、因数分解等知识点的其他应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 本题的核心是利用 \( \gcd \times \text{lcm} = a \times b \) 转化问题，类似的思路可用于解决：
        1. 已知两数的gcd和lcm，求两数的可能组合数（如本题）。
        2. 分解素因子解决计数问题（如统计满足条件的数对个数）。
        3. 处理涉及因数分解的优化枚举问题（如枚举因数时只枚举到平方根）。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点相关的题目，建议大家尝试练习：

    1.  **洛谷 P1052 过河**
          * 🗣️ **推荐理由**：涉及最小公倍数的应用，需要计算石子位置的周期性，锻炼对lcm性质的理解。
    2.  **洛谷 P1372 又是毕业季I**
          * 🗣️ **推荐理由**：求n个数中选k个数的最大gcd，需枚举gcd的可能值并统计因数，与本题枚举因数的思路类似。
    3.  **洛谷 P1414 又是毕业季II**
          * 🗣️ **推荐理由**：求n个数中选若干数的最大gcd的约数个数，需结合因数分解和计数，适合拓展因数枚举的应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
在提供的题解中，作者樱雪喵提到：“枚举到sqrt(n)是为了避免重复计算，当x0=y0时需要特判。”这一经验对我们很有启发。
</insights_intro>

> **参考经验 (来自樱雪喵)**：“枚举因数时，只需要枚举到平方根，每找到一个因数i，就对应另一个因数n/i。当x0=y0时，i和n/i可能相等，这时候需要减1避免重复计数。”
>
> **点评**：这位作者的经验提醒我们，在枚举因数对时，重复计数是常见的错误点。通过特判i是否等于n/i，可以有效避免这种错误。这对于我们处理类似的计数问题（如统计数对个数）非常有帮助。

-----

<conclusion>
本次关于“最大公约数和最小公倍数问题”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解数论性质的应用和枚举优化技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：201.19秒
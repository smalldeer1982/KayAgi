# 题目信息

# 山峰暸望

## 题目描述

一天，Bessie 在眺望美丽的威斯康星的群山的时候，她突然产生了疑问：哪座山是最宽的？

她决定在地平线上，利用她的新式大量程山峰高度测量仪依次做 $N$（$1 \le N \le 10,000$）次高度测量，每次的高度值为 $H_i$（$1 \le H_i \le 1,000,000,000$）。

一座山定义为一段连续的高度序列，序列中的高度一开始单调上升（或者不变），然后单调下降（或者不变）。举例来说，$2, 3, 3, 5, 4, 4, 1$ 这一段高度序列就是一座山。如果在她的视线范围内有一段单调上升或者单调下降的序列，也算是一座山。注意，两座山之间可能会有部分重叠。

山的宽度定义为在这个山上进行的测量的次数（也就是序列的长度）。例如序列 $2, 3, 3, 5, 4, 4, 1$ 的宽度为 $7$。

请帮 Bessie 找到最宽的山。

下图是一个比较典型的的例子：

```plain
           *******                   *                                
          *********                  ***                               
          **********                *****                              
          ***********            *********               *             
*      *****************       ***********             *** *          
**    *******************     *************   * *     *******      *  
**********************************************************************  山的形状
3211112333677777776543332111112344456765432111212111112343232111111211  高度值
aaaaa                    ccccccccccccccccccccc eeeeeee ggggggggg
  bbbbbbbbbbbbbbbbbbbbbbbbbbbb             ddddd          ffffffffff  
                                                             hhhhhhhhh  山的编号
```

山标记为 `a`、`b` 等等。显然，山 `b` 有着最大的宽度，宽度为 $28$。


## 说明/提示

**【样例说明】**

在最宽的山处测量到的高度为 $2, 3, 5, 4, 1$。其他的山包括 $3, 2$ 和 $1, 6$。

---

**【提示】**

如果你知道一座山的最高的部分（也就是山峰），你会发现，找到这座山的宽度是很容易的哦。

## 样例 #1

### 输入

```
7
3
2
3
5
4
1
6
```

### 输出

```
5
```

# AI分析结果



---
# 💡 Kay的C++算法解析：山峰暸望 深入学习指南 💡

<introduction>
今天我们来一起分析“山峰暸望”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过分析不同题解的优缺点，我们还能学习到如何优化算法效率，以及如何用动态规划等技巧解决类似问题。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与动态规划结合应用`

🗣️ **初步分析**：
> 解决“山峰暸望”的关键在于找到每座山的“山峰”（最高点或平缓段），并计算其左右延伸的最大宽度。简单来说，山峰的左右两侧需要满足“先上升/平缓，后下降/平缓”的条件。例如，一个山峰点的左边需要尽可能向左延伸直到无法满足非递减（即遇到比当前高的点），右边同理向右延伸直到无法满足非递增。

   - **题解思路对比**：多数题解采用两种思路：
     1. **暴力枚举法**（如AFOier的题解）：枚举每个点作为山峰，向左右扩展找到最大宽度（时间复杂度O(n²)）；
     2. **动态规划法**（如万弘的题解）：预处理每个点的“左延伸长度”（以该点结尾的最长非递减序列长度）和“右延伸长度”（以该点开头的最长非递增序列长度），通过两者之和减1得到该点的山峰宽度（时间复杂度O(n)）。
   - **核心算法流程**：动态规划法的核心是通过两次遍历（从左到右计算左延伸长度，从右到左计算右延伸长度），将每个点的左右延伸信息预先存储，避免重复计算。例如，左延伸长度`fup[i]`表示以第i个点结尾的最长非递减序列长度，若`h[i]≥h[i-1]`，则`fup[i] = fup[i-1]+1`，否则为1。
   - **可视化设计**：我们可以设计一个8位像素动画，用不同颜色的方块表示高度，红色方块标记当前处理的山峰点，绿色箭头向左延伸（非递减），蓝色箭头向右延伸（非递增）。每完成一个点的计算，显示其左右延伸长度，并更新最大宽度。关键步骤（如状态转移）伴随“叮”的音效，最终找到最大宽度时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等方面筛选了以下评分较高（≥4星）的题解。
</eval_intro>

**题解一：暴力枚举法（作者：AFOier）**
* **点评**：这份题解思路直白，直接利用题目提示“以每个点为山峰扩展”，代码简洁易读（变量`l`和`r`分别表示左右山脚）。虽然时间复杂度为O(n²)，但在n=1e4时仍能通过（可能数据较友好）。代码中`while`循环的边界处理（如`l>1`和`r<n`）严谨，适合初学者理解山峰扩展的核心逻辑。

**题解二：动态规划法（作者：万弘）**
* **点评**：此题解是算法优化的典范。通过预处理`fup`（左延伸长度）和`fdown`（右延伸长度），将时间复杂度降至O(n)，大幅提升效率。状态转移方程推导清晰（如`fup[i]`的递推仅依赖前一个状态），代码变量命名规范（`fup`和`fdown`直观），边界条件处理（`fup[1]=1`，`fdown[n]=1`）正确。对于大规模数据，这种优化方法更具实践价值。

**题解三：状态机模拟法（作者：zhi_zhang）**
* **点评**：此题解通过状态变量`state`（0为上升，1为下降）实时跟踪当前山的状态，动态计算宽度。虽然思路较前两种复杂，但通过记录重叠部分（`re`变量）处理了连续相同高度的情况，避免了重复计算。代码在输入的同时完成判断，适合理解山的“上升-下降”状态转换过程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何准确定义“山峰”？**
    * **分析**：山峰可以是一个点（严格最高），也可以是一段连续相同高度的平缓段（如示例中的`3,3,5,4,4`）。优质题解（如AFOier的暴力法）通过向左右扩展，将“山峰”定义为左右延伸的交点，即所有满足“左非递减+右非递增”的点均可视为山峰。
    * 💡 **学习笔记**：山峰的定义不局限于单个最高点，连续相同高度的平缓段也可作为山峰。

2.  **关键点2：如何高效计算左右延伸长度？**
    * **分析**：暴力法直接向左右遍历（O(n²)），但动态规划法通过预处理`fup`和`fdown`数组（O(n)）避免了重复计算。例如，`fup[i]`表示以i结尾的最长非递减序列长度，若`h[i]≥h[i-1]`，则`fup[i] = fup[i-1]+1`，否则重置为1。
    * 💡 **学习笔记**：预处理是优化重复计算的常用技巧，动态规划适合处理具有重叠子问题的场景。

3.  **关键点3：如何处理连续相同高度的边界？**
    * **分析**：相同高度既属于上升段（非递减）也属于下降段（非递增），需确保左右延伸时正确包含这些点。例如，在暴力法中，`a[l-1]<=a[l]`的条件允许相同高度继续向左延伸；动态规划法中，`h[i]>=h[i-1]`同样包含相等情况。
    * 💡 **学习笔记**：边界条件的判断需严格符合题目定义（非递减/非递增），避免遗漏或错误包含点。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题及类似问题的分析，我总结了以下一些通用的解题技巧：
</summary_best_practices>
-   **问题分解与抽象**：将“找最宽山”问题分解为“找每个点的左右延伸长度”子问题，简化复杂度。
-   **预处理优化**：对于需要重复计算的子问题（如左右延伸长度），使用动态规划预处理，将时间复杂度从O(n²)降至O(n)。
-   **边界条件检查**：处理输入的边界（如数组首尾）和特殊情况（如全上升/全下降序列），确保代码鲁棒性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考（动态规划法）**
* **说明**：本代码综合了万弘的动态规划思路，通过预处理左右延伸长度，高效计算最宽山的宽度，时间复杂度O(n)。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    const int MAXN = 10010;
    long long h[MAXN];
    int fup[MAXN], fdown[MAXN]; // fup[i]：以i结尾的最长非递减长度；fdown[i]：以i开头的最长非递增长度

    int main() {
        int n;
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            cin >> h[i];
        }

        // 预处理fup数组（左延伸）
        fup[1] = 1;
        for (int i = 2; i <= n; ++i) {
            if (h[i] >= h[i-1]) {
                fup[i] = fup[i-1] + 1;
            } else {
                fup[i] = 1;
            }
        }

        // 预处理fdown数组（右延伸）
        fdown[n] = 1;
        for (int i = n-1; i >= 1; --i) {
            if (h[i] >= h[i+1]) {
                fdown[i] = fdown[i+1] + 1;
            } else {
                fdown[i] = 1;
            }
        }

        // 计算最大宽度
        int max_width = 0;
        for (int i = 1; i <= n; ++i) {
            max_width = max(max_width, fup[i] + fdown[i] - 1); // 减去重复计算的i点
        }

        cout << max_width << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取输入高度数组，然后通过两次遍历预处理`fup`和`fdown`数组。`fup`数组记录每个点向左的最长非递减长度（包括自己），`fdown`数组记录向右的最长非递增长度（包括自己）。最后，遍历每个点，计算其左右延伸长度之和减1（避免重复计算该点），得到该点作为山峰的宽度，取最大值即为答案。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：暴力枚举法（作者：AFOier）**
* **亮点**：代码简洁直观，直接体现“以每个点为山峰扩展”的核心思路，适合初学者理解山峰的左右延伸过程。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++) {
        l=i; r=i;
        while(a[l-1]<=a[l]&&l>1) l--; // 向左找山脚
        while(a[r+1]<=a[r]&&r<n) r++; // 向右找山脚
        ans=max(ans,r-l+1); // 更新最大宽度
    }
    ```
* **代码解读**：
    > 这段代码遍历每个点`i`作为山峰，初始化`l`和`r`为`i`。然后通过`while`循环向左扩展（`l--`）直到遇到比当前高的点（`a[l-1]>a[l]`）或到达数组边界（`l=1`），同理向右扩展（`r++`）。最终，`r-l+1`即为该山峰的宽度，与当前最大值`ans`比较后更新。
* 💡 **学习笔记**：暴力法虽然时间复杂度较高，但逻辑直白，适合小数据量或理解问题的初始阶段。

**题解二：动态规划法（作者：万弘）**
* **亮点**：通过预处理左右延伸长度，将时间复杂度优化至O(n)，大幅提升效率，适合处理大规模数据。
* **核心代码片段**：
    ```cpp
    fup[1] = 1;
    for(ll i=2; i<=n; ++i) {
        if(h[i]>=h[i-1]) fup[i] = fup[i-1] + 1;
        else fup[i] = 1;
    }

    fdown[n] = 1;
    for(ll i=n-1; i>=1; --i) {
        if(h[i]>=h[i+1]) fdown[i] = fdown[i+1] + 1;
        else fdown[i] = 1;
    }
    ```
* **代码解读**：
    > 这两段代码分别计算`fup`和`fdown`数组。`fup[i]`的计算逻辑是：如果当前高度不小于前一个（`h[i]>=h[i-1]`），则继承前一个点的左延伸长度并加1（`fup[i]=fup[i-1]+1`）；否则重置为1（当前点独立为一个上升段）。`fdown`的计算类似，但方向是从右到左，处理下降段。
* 💡 **学习笔记**：动态规划的关键是找到状态转移方程，将大问题分解为可递推的子问题。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“动态规划预处理左右延伸长度”的过程，我设计了一个8位像素风格的动画演示方案，帮助大家“看”到每个点的左右延伸是如何计算的。
</visualization_intro>

  * **动画演示主题**：`像素山峰探险家`

  * **核心演示内容**：展示`fup`和`fdown`数组的计算过程，以及最终如何通过两者之和减1得到最宽山的宽度。

  * **设计思路简述**：采用8位像素风格（类似FC游戏），用不同颜色的方块表示高度（颜色越深高度越高）。通过绿色箭头向左扩展（计算`fup`）和蓝色箭头向右扩展（计算`fdown`），每完成一个点的计算，显示其`fup`和`fdown`值。关键步骤（如状态转移）伴随“叮”的音效，最终找到最大宽度时播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕顶部显示像素化的高度数组（每个高度用16色像素块表示，高度越高颜色越亮）。
          * 底部显示控制面板：开始/暂停、单步、重置按钮，速度滑块（0.5x-2x）。
          * 播放8位风格的轻快背景音乐（如《超级玛丽》的经典旋律）。

    2.  **计算fup数组（左延伸）**：
          * 从左到右遍历每个点`i`，当前点用红色边框高亮。
          * 若`h[i]>=h[i-1]`，绿色箭头从`i-1`指向`i`，`fup[i]`值显示为`fup[i-1]+1`（如`fup[2]=fup[1]+1`），伴随“叮”的音效。
          * 若`h[i]<h[i-1]`，绿色箭头消失，`fup[i]`重置为1，显示“新起点”文字提示。

    3.  **计算fdown数组（右延伸）**：
          * 从右到左遍历每个点`i`，当前点用蓝色边框高亮。
          * 若`h[i]>=h[i+1]`，蓝色箭头从`i+1`指向`i`，`fdown[i]`值显示为`fdown[i+1]+1`，伴随“叮”的音效。
          * 若`h[i]<h[i+1]`，蓝色箭头消失，`fdown[i]`重置为1，显示“新终点”文字提示。

    4.  **计算最大宽度**：
          * 遍历每个点`i`，显示`fup[i]+fdown[i]-1`的数值（如`i=3`时，`fup=3`，`fdown=4`，则宽度为6）。
          * 最大宽度对应的点用金色边框高亮，播放上扬的“胜利”音效，周围有像素星星闪烁。

    5.  **交互控制**：
          * 单步执行：每点击一次，动画前进一帧（计算一个点的`fup`或`fdown`）。
          * 自动播放：根据速度滑块调整播放速度，学习者可观察完整计算过程。
          * 重置：清空所有高亮和数值，重新开始演示。

  * **旁白提示**：
      * （计算`fup`时）“看！当前点比前一个点高或相等，所以它的左延伸长度是前一个点的长度加1～”
      * （计算`fdown`时）“现在向右看，如果当前点比后一个点高或相等，右延伸长度就继承后一个点的长度加1哦～”
      * （找到最大宽度时）“哇！这里的宽度最大，是我们要找的最宽山峰！”

<visualization_conclusion>
通过这样一个融合了像素艺术和复古游戏元素的动画，我们不仅能清晰地看到动态规划预处理的过程，还能在轻松的氛围中理解左右延伸长度的计算逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 动态规划预处理左右延伸长度的方法，不仅适用于“山峰宽度”问题，还可用于：
        1. **最长非递增子数组**：计算每个点的最长非递增长度，取最大值。
        2. **直方图最大矩形面积**：预处理每个柱子左右第一个比它矮的位置，计算宽度。
        3. **股票买卖最佳时机**：预处理每个时间点的最大利润（左最小值，右最大值）。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点或思维方式相关的题目，建议大家尝试练习：

    1.  **洛谷 P1317 低洼地**
          * 🗣️ **推荐理由**：这道题需要计算连续下降后上升的“低洼”数量，与本题“山峰”的上升-下降结构类似，可巩固对序列单调性的理解。
    2.  **洛谷 P5788 【模板】单调栈**
          * 🗣️ **推荐理由**：此题需要用单调栈求每个元素左右第一个比它小的位置，与本题预处理左右延伸长度的思路相关，可拓展数据结构应用能力。
    3.  **洛谷 P1508 Likecloud-吃、吃、吃**
          * 🗣️ **推荐理由**：此题需要动态规划计算最大能量值，涉及状态转移方程的设计，与本题动态规划预处理的思想相通。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
如果提供的题解内容中包含了作者的个人学习心得或解题过程中的经验教训，这些对我们来说是非常宝贵的参考。我会摘录其中有价值的部分，并点评其借鉴意义：
</insights_intro>

> **参考经验 (来自作者：zhangzhaoke)**：“我一开始认为纯模拟肯定不行，用了动规却调不出来，结果暴力法居然过了。”
>
> **点评**：这位作者的经验提醒我们，在编程竞赛中，有时暴力法（尤其是数据范围允许时）可能是更直接的选择。遇到复杂思路卡壳时，不妨先尝试简单暴力法验证，再考虑优化。同时，动态规划的实现需要仔细调试状态转移方程，避免边界错误。

-----

<conclusion>
本次关于“山峰暸望”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解动态规划和模拟算法的应用，以及如何通过预处理优化时间复杂度。记住，编程能力的提升在于多思考、多实践，遇到问题时不妨从简单方法入手，再逐步优化。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：170.29秒
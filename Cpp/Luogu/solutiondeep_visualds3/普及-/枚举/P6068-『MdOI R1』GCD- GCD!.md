# 题目信息

# 『MdOI R1』GCD? GCD!

## 题目描述

灵喜欢 $\mathrm{gcd}$，也就是 **最大公约数**。如果你不知道什么叫做最大公约数，你可以访问 [最大公约数 - OI Wiki](https://oi-wiki.org/math/gcd/)。

灵给了你一个正整数 $n$，要你把它分成三个 **互不相等的** 正整数 $a,b,c$ 之和，使得 $\mathrm{gcd}(a,b,c)$ 最大。

## 说明/提示

【样例解释】

将 $12$ 分成 $2+4+6$，可以证明 $\gcd(2,4,6)=2$ 为可能达到的最大值。

将 $27$ 分成 $3+6+18$，可以证明 $\gcd(3,6,18)=3$ 为可能达到的最大值。

$5$ 无法分成三个互不相等的正整数之和，输出 `-1`。

---

【数据范围】

**本题采用捆绑测试。**

| 子任务编号 | $n\leq$ | 分值 |
| :--------: | :-----: | :--: |
|     1      |  $50$   |  17  |
|     2      |  $500$  |  19  |
|     3      | $10^5$  |  23  |
|     4      | $10^9$  |  41  |

对于 $100\%$ 的数据，$1\le T \le 100$，$1\le n\le 10^9$。

## 样例 #1

### 输入

```
3
12
27
5
```

### 输出

```
2
3
-1
```

# AI分析结果

# 💡 Kay的C++算法解析：『MdOI R1』GCD? GCD! 深入学习指南 💡

<introduction>
今天我们来分析一道**数论小难题**——「把n分成三个不同正整数之和，求它们的最大公约数的最大值」。这道题的核心是**用数学思维转化问题**，不需要复杂的算法，但需要你“看透”题目背后的规律。跟着Kay一步步拆解，你会发现它其实很友好～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论·约数枚举）`  

🗣️ **初步分析**：
解决这道题的关键，是把“求三个数的最大公约数最大值”转化为**找n的约数**。我们可以用一个简单的比喻理解：  
假设三个数的最大公约数是`g`，那么这三个数可以写成`g×A`、`g×B`、`g×C`（就像三个数都“共享”了一个小因子g）。它们的和是`n = g×(A+B+C)`——所以`g`和`A+B+C`都是n的**约数**（比如n=12，g=2，A+B+C=6，2×6=12）。  

要让`g`尽可能大，就得让`A+B+C`尽可能小（因为两个数相乘等于n，一个小另一个就大）。而A、B、C是**互不相等的正整数**，它们的最小和是多少呢？对啦，1+2+3=6！所以`A+B+C`至少是6，对应的`g`就是n除以这个最小的约数（≥6）。  

**核心结论**：找n的**最小约数k（k≥6）**，答案就是`n/k`。如果n没有这样的约数（比如n<6），输出-1。  

**可视化设计思路**：我们会用8位像素风格展示`n=12`的求解过程——屏幕上弹出“n=12”的像素标题，然后从k=6开始枚举约数：当k=6时，n%6=0，立刻高亮k=6，弹出“找到啦！g=12/6=2”，再用像素块展示2、4、6的和（不同颜色代表不同数），最后闪烁“gcd=2”的字样，伴随“叮”的胜利音效～


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、实践价值**三个维度筛选了3份优质题解，它们能帮你快速掌握核心逻辑！
</eval_intro>

**题解一：(来源：FCBM71)**  
* **点评**：这份题解直接点破了题目的“数学本质”——把问题转化为找n的最小约数k≥6。没有冗余的步骤，逻辑像“剥洋葱”一样层层递进：先假设gcd是g，再推导A+B+C的最小值，最后得出结论。它的**亮点**是“用数学推导代替暴力枚举”，帮你跳过了复杂的试错过程，非常适合理解题目的核心规律。

**题解二：(来源：Gmt丶FFF)**  
* **点评**：这是一份“接地气”的题解！作者用**简洁的循环**实现了约数枚举：从1到sqrt(n)遍历，检查i和n/i是否是约数，并且是否≥6。代码里的`if(x>=6) ans=max(ans,y);`直接对应我们的核心结论，变量名`x`（A+B+C）和`y`（g）也很直观。它的**亮点**是“用最朴素的代码实现最核心的逻辑”，适合新手模仿。

**题解三：(来源：老咸鱼了)**  
* **点评**：这份题解的代码**实战性极强**！作者处理了边界情况（n<6直接输出-1），然后分两步枚举约数：先从6到sqrt(n)找能整除n的k（对应g=n/k），如果没找到，再从5往下找n的约数（此时g就是这个约数，因为n/g≥6）。它的**亮点**是“覆盖了所有可能的情况”，比如当n是质数时（比如n=7，约数只有1和7，此时g=1，因为7/1=7≥6），代码也能正确输出。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“难”不是难在代码，而是难在**把问题转化为数学模型**。以下三个关键点，帮你打通“任督二脉”：
</difficulty_intro>

1.  **关键点1：如何把gcd问题转化为约数问题？**  
    * **分析**：假设三个数的gcd是g，那么它们的和n一定是g的倍数（n = g×(A+B+C)）。这一步是“转化问题的钥匙”——把“求g的最大值”变成“求(A+B+C)的最小值”。优质题解都强调了这一步，比如FCBM71的推导、Skies的“乘法分配律逆运算”。  
    * 💡 **学习笔记**：遇到gcd和总和的问题，先试试“提取公因子”！

2.  **关键点2：为什么A+B+C的最小值是6？**  
    * **分析**：A、B、C是**互不相等的正整数**，最小的三个正整数是1、2、3，它们的和是6。如果A+B+C小于6，根本无法找到三个不同的正整数（比如k=5，只能是1+1+3或1+2+2，都有重复）。  
    * 💡 **学习笔记**：找“最小值”时，先想“最极端的情况”（比如最小的几个数）！

3.  **关键点3：如何高效枚举约数？**  
    * **分析**：直接从1到n枚举约数会超时（比如n=1e9），所以要**枚举到sqrt(n)**——因为约数是成对出现的（比如n=12，约数对是(1,12)、(2,6)、(3,4)）。这样时间复杂度从O(n)降到O(sqrt(n))，完全能处理1e9的数据。  
    * 💡 **学习笔记**：枚举约数的“黄金法则”——只枚举到sqrt(n)，再处理成对的约数！

### ✨ 解题技巧总结
- **转化思维**：把复杂的gcd问题转化为简单的约数问题，是解数论题的常用技巧。  
- **边界处理**：先特判n<6的情况（直接输出-1），避免后续无效计算。  
- **高效枚举**：枚举到sqrt(n)，处理成对的约数，减少循环次数。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它综合了优质题解的思路，逻辑清晰，能处理所有情况：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自“老咸鱼了”和“Gmt丶FFF”的题解，整合了边界处理和高效枚举，是最简洁的AC代码。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <cmath>
  using namespace std;

  int main() {
      int T;
      cin >> T;
      while (T--) {
          int n;
          cin >> n;
          if (n < 6) { // 无法分成三个不同正整数
              cout << -1 << endl;
              continue;
          }
          int ans = 0;
          // 枚举约数对(i, n/i)
          for (int i = 1; i * i <= n; ++i) {
              if (n % i == 0) {
                  int x = i, y = n / i;
                  if (x >= 6) ans = max(ans, y); // x是A+B+C，y是g
                  if (y >= 6) ans = max(ans, x); // y是A+B+C，x是g
              }
          }
          cout << ans << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 读取测试用例数T，循环处理每个n；  
  2. 特判n<6，输出-1；  
  3. 枚举到sqrt(n)，检查i是否是n的约数；  
  4. 对每个约数对(i, n/i)，如果其中一个≥6，就更新ans为另一个（因为ans是g的最大值）；  
  5. 输出ans。

---

<code_intro_selected>
再看两个**核心代码片段**，帮你理解关键逻辑：
</code_intro_selected>

**题解二：(来源：Gmt丶FFF)**
* **亮点**：用最简洁的循环实现约数枚举，变量名直观。
* **核心代码片段**：
  ```cpp
  for(int i=1; i*i<=n; i++){
      if(n%i != 0) continue;
      int x = i, y = n/i;
      if(x >=6) ans = max(ans, y);
      if(y >=6) ans = max(ans, x);
  }
  ```
* **代码解读**：  
  - `i*i<=n`：枚举到sqrt(n)，避免重复；  
  - `n%i==0`：判断i是否是n的约数；  
  - `x=i`（A+B+C的可能值），`y=n/i`（对应的g）；  
  - 如果x≥6，说明A+B+C可以是x，此时g是y，更新ans；  
  - 同理，如果y≥6，说明A+B+C可以是y，此时g是x，更新ans。  
* 💡 **学习笔记**：约数对的处理是关键——不要漏掉任何一个可能的约数！

**题解三：(来源：老咸鱼了)**
* **亮点**：处理了“找不到k≥6的约数”的情况（比如n=7，约数只有1和7，此时g=1）。
* **核心代码片段**：
  ```cpp
  bool v = false;
  for(int i=6; i*i<=n; i++){
      if(n%i ==0){
          cout << n/i << endl; v=true;
          break;
      }
  }
  if(!v){
      for(int i=5; i>=1; i--){
          if(n%i ==0 && n/i >=6){
              cout << i << endl; break;
          }
      }
  }
  ```
* **代码解读**：  
  - 第一重循环找k≥6的约数（i从6开始），如果找到，直接输出n/i（g）；  
  - 如果没找到，第二重循环从5往下找n的约数i，此时n/i≥6（比如n=7，i=1，n/i=7≥6，输出1）。  
* 💡 **学习笔记**：不要漏掉“约数对中较大的那个≥6”的情况！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”算法的执行过程，Kay设计了一个**8位像素风动画**——就像玩FC红白机游戏一样，一步步拆解n=12的求解过程！
</visualization_intro>

  * **动画演示主题**：《像素数学家的约数寻宝》  
  * **核心演示内容**：展示n=12时，如何找到最小的k≥6（k=6），并计算g=2的过程。  
  * **设计思路简述**：用8位像素风营造复古感，用**颜色高亮**和**像素动画**突出关键步骤，用**音效**强化记忆——比如“叮”表示找到约数，“嗡”表示计算gcd，胜利音效表示找到答案。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：  
       - 屏幕显示FC风格的标题“GCD寻宝！n=12”，背景是像素化的数学公式（n = g×(A+B+C)）；  
       - 底部有“开始”“单步”“重置”按钮，速度滑块（从“慢”到“快”）；  
       - 播放8位风格的轻快BGM（类似《超级马里奥》的背景音乐）。
    2.  **算法启动**：  
       - 弹出像素对话框：“目标：找n=12的最小约数k≥6！”；  
       - 屏幕中央显示“k=6”的像素块（红色），旁边有个小机器人（代表“算法”）走向k=6。
    3.  **检查约数**：  
       - 机器人用“放大镜”点击k=6，弹出“12%6=0”的提示，伴随“叮”的音效；  
       - k=6的像素块变成绿色（表示“符合条件”），旁边显示“g=12/6=2”。
    4.  **验证分解**：  
       - 屏幕下方弹出三个像素块：2（蓝色）、4（黄色）、6（红色），拼成“2+4+6=12”；  
       - 机器人用“计算器”计算gcd(2,4,6)，弹出“gcd=2”的字样，伴随“嗡”的音效。
    5.  **胜利结局**：  
       - 屏幕闪起“找到最大值！g=2”的字样，播放胜利音效（类似《魂斗罗》的通关音乐）；  
       - 弹出“再来一局？”的选项，支持重置动画或切换n的值（比如n=27）。

  * **旁白提示**：  
    - “接下来，我们要找n=12的约数k≥6～”（启动时）；  
    - “k=6能整除12！对应的g是2～”（找到约数时）；  
    - “2、4、6的gcd是2，这就是最大值！”（验证时）。

<visualization_conclusion>
通过这个动画，你不仅能“看”到算法的每一步，还能在游戏般的体验中记住“约数枚举”的核心逻辑——是不是很有趣？
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的“约数枚举”和“转化思维”能解决很多数论问题，比如：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 求两个数的最大公约数（gcd）；  
    - 找一个数的所有约数（比如统计约数个数）；  
    - 转化问题（比如把“求最大值”变成“求最小值”）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1029** - 最大公约数和最小公倍数问题  
        * 🗣️ **推荐理由**：这道题需要你找两个数，它们的gcd是a，lcm是b——核心是约数分解，能巩固你的转化思维！
    2.  **洛谷 P1888** - 三角函数  
        * 🗣️ **推荐理由**：这道题需要你求三角形的最小角的正弦值——核心是找三个数的gcd，能强化你对gcd的理解！
    3.  **洛谷 P2441** - 角色属性  
        * 🗣️ **推荐理由**：这道题需要你找两个数的最大公约数，并且处理大数——能锻炼你高效枚举约数的能力！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是题解作者的“踩坑经验”，帮你避开同样的错误：
</insights_intro>

> **参考经验 (来自 Gmt丶FFF)**：“我一开始忘记初始化ans=0，结果全WA了！”  
> **点评**：这个错误很常见——如果ans没初始化，它的值是随机的，会导致输出错误。解决方法是**在每次处理n时，把ans初始化为0**！

> **参考经验 (来自 xh39)**：“直接从n/6倒序枚举会超时，改成枚举到sqrt(n)就AC了！”  
> **点评**：这提醒我们——处理大数时，一定要用**高效的枚举方法**（比如枚举到sqrt(n)），否则会超时！


<conclusion>
这道题的核心是“用数学思维转化问题”——把求gcd的最大值变成找n的约数。只要你理解了这一步，代码就变得很简单啦！记住：**数论问题不可怕，关键是要找到“问题的钥匙”**～  
下次遇到数论题，不妨先想想“能不能提取公因子”“能不能转化为约数问题”——你会发现，很多难题都会变得容易起来！💪
</conclusion>

---
处理用时：123.93秒
# 题目信息

# [蓝桥杯 2016 省 AB] 四平方和

## 题目描述

四平方和定理，又称为拉格朗日定理：

每个正整数都可以表示为至多 $4$ 个正整数的平方和。

如果把 $0$ 包括进去，就正好可以表示为 $4$ 个数的平方和。

比如：

$5=0^2+0^2+1^2+2^2$。

$7=1^2+1^2+1^2+2^2$。

对于一个给定的正整数，可能存在多种平方和的表示法。

要求你对 $4$ 个数排序使得 $0 \le a \le b \le c \le d$。

并对所有的可能表示法按 $a,b,c,d$ 为联合主键升序排列，最后输出第一个表示法。

## 说明/提示

时限 3 秒, 256M。蓝桥杯 2016 年第七届省赛

蓝桥杯 2016 年省赛 A 组 H 题（B 组 H 题）。

## 样例 #1

### 输入

```
5```

### 输出

```
0 0 1 2```

## 样例 #2

### 输入

```
12```

### 输出

```
0 2 2 2```

## 样例 #3

### 输入

```
773535```

### 输出

```
1 1 267 838```

# AI分析结果



---
# 💡 Kay的C++算法解析：四平方和 深入学习指南 💡

<introduction>
今天我们来一起分析“四平方和”这道经典的C++编程题。这道题考察了枚举算法的灵活运用，通过合理的剪枝优化，我们可以高效地找到符合条件的四个数。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：枚举算法（含剪枝优化）

🗣️ **初步分析**：
> 解决“四平方和”这道题，关键在于运用“枚举算法”。简单来说，枚举就像“逐个试答案”——在可能的范围内，逐一尝试所有可能的候选解，直到找到符合条件的那一个。不过，直接暴力枚举会像大海捞针一样慢，所以需要结合剪枝优化，缩小枚举范围，提高效率。
   - **题解思路**：所有题解的核心思路都是枚举前三个数 \(a, b, c\)（满足 \(a \leq b \leq c\)），然后计算第四个数 \(d = \sqrt{n - a^2 - b^2 - c^2}\)，并判断 \(d\) 是否为整数且 \(d \geq c\)。不同题解的差异主要在于剪枝策略和循环条件的优化。
   - **核心难点**：如何避免无效枚举（如重复枚举不满足 \(a \leq b \leq c \leq d\) 的情况）和控制时间复杂度（直接四重枚举会超时）。优质题解通过限制循环的上界（如 \(i^2 \leq n\)、\(i^2 + j^2 \leq n\) 等）和保证 \(j \geq i\)、\(k \geq j\) 来剪枝。
   - **可视化设计**：我们将设计一个“像素矿工挖宝”的复古动画，用像素方块表示 \(a, b, c\) 的枚举过程。每次枚举 \(a\) 时，对应列的像素块向上延伸（表示 \(a^2\) 的值），枚举 \(b\) 时右侧列同步延伸，直到找到满足条件的 \(d\)（用金色像素块标记），伴随“叮”的音效提示关键操作。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选了以下3个优质题解（评分≥4星），它们在剪枝策略和实现细节上表现突出。
</eval_intro>

**题解一：作者：ダ月 (赞：2)**
* **点评**：此题解在剪枝策略上非常巧妙。通过限制 \(j \geq i\)、\(k \geq j\) 确保 \(a \leq b \leq c\)，并在计算 \(d\) 后检查 \(d \geq k\)（避免 \(d < c\) 的无效情况），大大减少了枚举次数。代码结构简洁，变量命名直观（如 \(p\) 表示剩余值，\(r\) 表示 \(d\)），边界条件处理严谨（如 \(k^2 \leq n - i^2 - j^2\) 限制循环上界），是典型的“枚举+剪枝”高效实现。

**题解二：作者：Li2021 (赞：1)**
* **点评**：此题解通过预先计算 \(i^2, j^2, k^2\)（存储为 \(i2, j2, k2\)），减少了重复计算平方的开销，优化了时间效率。循环条件清晰（如 \(i2 + j2 \leq n\)），逻辑直接，代码可读性强。判断 \(d\) 是否为整数的方式（\(gx * gx == x\)）简洁有效，适合竞赛场景。

**题解三：作者：haozinojc (赞：2)**
* **点评**：此题解的循环结构设计合理，\(j\) 从 \(i\) 开始、\(k\) 从 \(j\) 开始，确保了 \(a \leq b \leq c\) 的顺序。代码中使用 `printf` 直接输出结果，避免了不必要的变量存储，简洁高效。剪枝条件（如 \(i^2 + j^2 + k^2 \leq n\)）有效缩小了枚举范围，是暴力枚举优化的典型代表。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何避免无效枚举，确保 \(a \leq b \leq c \leq d\)？
    * **分析**：优质题解通过限制循环变量的起始值（如 \(j\) 从 \(i\) 开始，\(k\) 从 \(j\) 开始），确保 \(a \leq b \leq c\)。计算 \(d\) 后，再检查 \(d \geq c\)（如 `if(r < k) break`），避免 \(d < c\) 的无效情况。这样既保证了顺序，又减少了枚举次数。
    * 💡 **学习笔记**：枚举时通过“变量递增起始值”可以直接保证顺序，避免重复计算。

2.  **关键点2**：如何控制时间复杂度，避免暴力枚举超时？
    * **分析**：直接四重枚举的时间复杂度为 \(O(n^2)\)，无法通过时间限制。优质题解通过三重枚举+剪枝（如 \(i^2 \leq n\)、\(i^2 + j^2 \leq n\)、\(i^2 + j^2 + k^2 \leq n\)）将时间复杂度优化到 \(O(n\sqrt{n})\)，大幅减少计算量。
    * 💡 **学习笔记**：合理的循环上界限制是剪枝的核心，需根据题目条件推导。

3.  **关键点3**：如何高效判断 \(d\) 是否为整数？
    * **分析**：计算 \(d = \sqrt{n - a^2 - b^2 - c^2}\) 后，只需判断 \(d^2\) 是否等于剩余值（如 `if(gx * gx == x)`）。这种方法利用了整数平方的特性，避免了浮点数精度问题。
    * 💡 **学习笔记**：判断完全平方数时，取整后平方与原值比较是最直接的方法。

### ✨ 解题技巧总结
<summary_best_practices>
- **剪枝优先**：在枚举前，先通过数学推导确定循环的上界（如 \(i^2 \leq n\)），减少无效枚举。
- **顺序保证**：让后续循环变量从当前变量开始（如 \(j \geq i\)），直接满足 \(a \leq b \leq c\) 的条件。
- **预计算优化**：预先计算平方值（如 \(i^2\) 存储为 \(i2\)），避免重复计算，提升效率。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，选择剪枝策略清晰、代码简洁的“ダ月”题解作为核心实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了剪枝策略和预计算优化，确保 \(a \leq b \leq c \leq d\)，并高效找到第一个符合条件的解。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        for (int i = 0; i * i <= n; ++i) {
            for (int j = i; i * i + j * j <= n; ++j) {
                for (int k = j; i * i + j * j + k * k <= n; ++k) {
                    int remain = n - i * i - j * j - k * k;
                    int d = sqrt(remain);
                    if (d < k) break; // 剪枝：d必须≥k，否则后续k更大时d更小
                    if (d * d == remain) {
                        cout << i << " " << j << " " << k << " " << d << endl;
                        return 0;
                    }
                }
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码通过三重循环枚举 \(i, j, k\)（对应 \(a, b, c\)），其中 \(j\) 从 \(i\) 开始、\(k\) 从 \(j\) 开始，确保 \(a \leq b \leq c\)。计算剩余值 `remain` 后，通过 `sqrt` 得到 \(d\)，并检查 \(d \geq k\)（否则跳出循环）和 \(d^2 = remain\)。找到第一个符合条件的解后立即输出，保证结果的升序要求。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：作者：ダ月**
* **亮点**：剪枝策略高效（\(j \geq i\)、\(k \geq j\)、\(d \geq k\)），避免无效枚举。
* **核心代码片段**：
    ```cpp
    for(int i=0;i*i<=n;i++)
        for(int j=i;j*j<=n-i*i;j++)
            for(int k=j;k*k<=n-i*i-j*j;k++){
                int p=n-i*i-j*j-k*k;
                int r=int(sqrt(p));
                if(r<k)break;
                if(p==r*r){
                    // 输出结果
                }
            }
    ```
* **代码解读**：
    > 第一层循环枚举 \(i\)（\(a\)），上界是 \(i^2 \leq n\)。第二层循环 \(j\) 从 \(i\) 开始（保证 \(j \geq i\)），上界是 \(j^2 \leq n - i^2\)。第三层循环 \(k\) 从 \(j\) 开始（保证 \(k \geq j\)），上界是 \(k^2 \leq n - i^2 - j^2\)。计算剩余值 \(p\) 后，\(r\) 是 \(d\) 的候选值。若 \(r < k\)（即 \(d < c\)），则后续 \(k\) 增大时 \(d\) 会更小，直接 `break` 剪枝。若 \(r^2 = p\)，则找到解。
* 💡 **学习笔记**：剪枝的关键是提前排除不可能的情况（如 \(d < c\)），减少不必要的计算。

**题解二：作者：Li2021**
* **亮点**：预计算平方值（\(i2 = i^2\)），减少重复计算。
* **核心代码片段**：
    ```cpp
    for(int i=0;i*i<=n;i++){
        int i2=i*i;
        for(int j=0;i2+j*j<=n;j++){
            int j2=j*j;
            for(int k=0;i2+j2+k*k<=n;k++){
                int k2=k*k,x=n-i2-j2-k2,gx=sqrt(x);
                if(gx*gx==x)  return cout<<i<<" "<<j<<" "<<k<<" "<<gx,0;
            }
        }
    }
    ```
* **代码解读**：
    > 预计算 \(i^2\) 为 \(i2\)，后续循环中直接使用 \(i2\) 代替 \(i*i\)，减少了重复计算平方的开销。同理，计算 \(j2\) 和 \(k2\)。剩余值 \(x\) 由 \(n - i2 - j2 - k2\) 得到，判断 \(gx^2 = x\) 即可确定 \(d\) 为整数。
* 💡 **学习笔记**：预计算常用值（如平方）是优化循环效率的实用技巧。

**题解三：作者：haozinojc**
* **亮点**：循环结构简洁，直接保证 \(a \leq b \leq c\)。
* **核心代码片段**：
    ```cpp
    for(int i=0;i*i<=n;i++){
        for(int j=i;i*i+j*j<=n;j++){
            for(int k=j;i*i+j*j+k*k<=n;k++){
                int l=(int)(sqrt(n-i*i-j*j-k*k));
                if(i*i+j*j+k*k+l*l==n){
                    printf("%lld %lld %lld %lld",i,j,k,l);
                    return 0;
                }
            }
        }
    }
    ```
* **代码解读**：
    > \(j\) 从 \(i\) 开始（\(j \geq i\)），\(k\) 从 \(j\) 开始（\(k \geq j\)），直接保证 \(a \leq b \leq c\)。计算 \(l\) 后，检查平方和是否等于 \(n\)，找到即输出，保证结果的升序要求。
* 💡 **学习笔记**：循环变量的起始值设计是保证顺序的关键。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解枚举过程，我们设计一个“像素矿工挖宝”的8位复古动画，用像素方块模拟 \(a, b, c\) 的枚举和 \(d\) 的计算过程。
</visualization_intro>

  * **动画演示主题**：像素矿工的平方宝藏  
  * **核心演示内容**：矿工从左到右挖取像素块（代表 \(a, b, c\) 的值），每挖取一个块，对应的平方值累加，直到剩余值能被另一个像素块（\(d\)）填满，找到宝藏。

  * **设计思路简述**：8位像素风格（FC红白机色调）营造轻松氛围；矿工挖块的动画（像素块向上堆叠）直观展示平方和的累加；关键步骤（如找到 \(d\)）用金色块和“叮”音效强化记忆；单步控制让学习者看清每一步枚举。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧显示三个垂直的“矿道”（分别对应 \(a, b, c\) 的枚举值），每个矿道由像素块堆叠而成，块数表示当前值（如 \(a=2\) 时，矿道有2个块）。  
        - 控制面板包含“单步”“自动”“重置”按钮和速度滑块（1-5倍速）。  
        - 背景播放8位风格的轻快音乐（类似《超级玛丽》的过场音乐）。

    2.  **枚举启动**：  
        - 矿工（像素小人）从 \(a=0\) 开始，在第一个矿道放置0个块（初始状态），播放“滴”的音效。  
        - 进入 \(b\) 的枚举，矿工移动到第二个矿道，从 \(b=a=0\) 开始放置块。

    3.  **核心枚举过程**：  
        - **当前值高亮**：当前枚举的 \(a, b, c\) 对应的矿道用蓝色边框高亮，块数动态增加（如 \(a=1\) 时，第一个矿道添加1个红色块）。  
        - **平方和计算**：屏幕上方显示当前平方和（如 \(a^2 + b^2 + c^2 = 5\)），剩余值 \(n - 5\) 用黄色数字显示。  
        - **\(d\) 的计算**：当 \(c\) 枚举到某个值时，屏幕右侧弹出一个“计算器”像素框，计算 \(d = \sqrt{剩余值}\)。若 \(d\) 是整数，计算器显示绿色；否则显示红色。  
        - **剪枝提示**：当 \(d < c\) 时，当前 \(c\) 矿道的块闪烁红色，矿工摇头（像素动画），并跳过后续 \(c\) 的枚举（矿道直接跳到下一个可能的 \(c\)）。

    4.  **找到解的庆祝**：  
        - 当 \(d\) 为整数且 \(d \geq c\) 时，四个矿道的块同时变为金色，播放“胜利”音效（类似《魂斗罗》的得分音）。  
        - 屏幕中央弹出“找到宝藏！”的像素文字，显示 \(a, b, c, d\) 的值。

    5.  **交互控制**：  
        - 单步模式：点击“单步”按钮，矿工逐步枚举 \(a, b, c\)，每步显示详细过程。  
        - 自动模式：选择速度后，矿工自动快速枚举，学习者可观察整体流程。  
        - 重置模式：点击“重置”，所有矿道清空，回到初始状态。

  * **旁白提示**：  
    - （枚举 \(a\) 时）“看，矿工正在尝试第一个数 \(a\)，它的平方不能超过 \(n\) 哦！”  
    - （枚举 \(b\) 时）“第二个数 \(b\) 要大于等于 \(a\)，所以矿工从 \(a\) 的位置开始挖！”  
    - （计算 \(d\) 时）“现在需要检查剩余值是否是完全平方数，如果是，就能找到宝藏啦！”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到枚举的每一步如何缩小范围，剪枝如何避免无效尝试，以及最终解是如何被找到的。这种“看得见”的算法过程，能帮助我们更好地理解枚举与剪枝的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了四平方和的枚举+剪枝思路后，我们可以将其迁移到更多需要枚举的问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
      枚举算法+剪枝的核心是“缩小范围，避免无效尝试”，这一思路适用于：  
      - 组合问题（如选数求和）；  
      - 排列问题（如生成全排列）；  
      - 因数分解问题（如寻找两个数的乘积等于目标值）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1036 选数**  
          * 🗣️ **推荐理由**：需要枚举 \(k\) 个数的组合，计算它们的和是否为质数，与本题的枚举+剪枝思路类似。
    2.  **洛谷 P1157 组合的输出**  
          * 🗣️ **推荐理由**：要求按字典序输出所有 \(m\) 个数的组合，需要控制枚举顺序，与本题保证 \(a \leq b \leq c\) 的思想一致。
    3.  **洛谷 P1088 火星人**  
          * 🗣️ **推荐理由**：通过枚举排列来模拟火星人的计数方式，需要理解排列的生成规则，锻炼枚举逻辑。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。但通过观察题解，我们可以总结：在枚举类问题中，**提前分析变量的约束条件（如顺序、范围）并设计剪枝策略**是避免超时的关键。动手前先画流程图或列出可能的枚举范围，能帮助我们更高效地编写代码。
</insights_intro>

-----

<conclusion>
本次关于“四平方和”的C++解题分析就到这里。希望这份指南能帮助你掌握枚举+剪枝的核心技巧，理解如何通过限制循环条件和预计算优化来提高效率。记住，编程能力的提升需要多思考、多练习，下次我们再一起挑战新的算法问题！💪
</conclusion>

-----

---
处理用时：184.88秒
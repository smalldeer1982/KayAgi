# 题目信息

# [蓝桥杯 2017 省 B] 日期问题

## 题目描述

小明正在整理一批历史文献。这些历史文献中出现了很多日期。小明知道这些日期都在 1960 年 1 月 1 日至 2059 年 12 月 31 日。令小明头疼的是，这些日期采用的格式非常不统一，有采用`年/月/日`的，有采用`月/日/年`的，还有采用`日/月/年`的。更加麻烦的是，年份也都省略了前两位，使得文献上的一个日期，存在很多可能的日期与其对应。  

比如 `02/03/04`，可能是 2002 年 03 月 04 日、2004 年 02 月 03 日或 2004 年 03 月 02 日。  

给出一个文献上的日期，你能帮助小明判断有哪些可能的日期对其对应吗？

## 样例 #1

### 输入

```
02/03/04```

### 输出

```
2002-03-04  
2004-02-03  
2004-03-02  ```

# AI分析结果



---
# 💡 Kay的C++算法解析：[蓝桥杯 2017 省 B] 日期问题 深入学习指南 💡

<introduction>
今天我们来一起分析“[蓝桥杯 2017 省 B] 日期问题”这道题。这道题看似简单，但需要考虑多种日期格式和合法性判断，是锻炼枚举和模拟能力的好题目。本指南将帮助大家梳理思路，掌握核心技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与枚举应用`  

🗣️ **初步分析**：  
解决这道题的关键在于“枚举所有可能的日期，然后验证是否符合输入的三种格式”。就像玩拼图游戏——我们需要把输入的三个数字（如02/03/04）分别尝试套入“年/月/日”“月/日/年”“日/月/年”三种模板，再检查每个模板是否能拼出一个合法的日期（1960-2059年之间）。  

核心难点有三个：  
1. **闰年判断**：二月的天数会影响日期合法性（平年28天，闰年29天）。  
2. **三种格式的匹配**：输入的三个数字需要分别对应年、月、日的不同位置。  
3. **去重与排序**：不同格式可能生成相同日期，需避免重复输出，并按时间顺序排列。  

核心算法流程是：  
- 枚举1960-2059年的所有年份；  
- 对每个年份，根据是否为闰年调整二月天数；  
- 枚举1-12月的所有月份；  
- 枚举该月的所有合法日期；  
- 检查当前日期是否符合三种格式之一；  
- 收集所有合法日期，去重后按顺序输出。  

可视化设计思路：采用8位像素风格动画，用网格表示日期（行是年份，列是月份，格子是日期）。枚举时用黄色高亮当前年、月、日，匹配成功时用绿色闪烁并播放“叮”音效，最终输出时按时间顺序排列成一行。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码可读性和算法有效性，以下题解值得重点学习：
</eval_intro>

**题解一：作者CleverRaccoon（赞41）**  
* **点评**：此题解思路简洁直接，通过三重循环枚举所有可能的日期，结合闰年判断和格式匹配，代码结构清晰。亮点在于：  
  - 用`daysOfMonth`数组动态调整二月天数（平年28天，闰年29天）；  
  - 格式匹配条件简洁（`a == year%100 && b == month && c == day`等）；  
  - 输出时使用`%02d`自动补零，符合题目要求。  

**题解二：作者_ChongYun_（赞7）**  
* **点评**：此题解代码高度精简，将核心逻辑封装为`run_year`（闰年判断）和`istrue`（格式匹配）函数，可读性强。亮点在于：  
  - 函数封装减少重复代码；  
  - 三重循环结构清晰，直接枚举年、月、日；  
  - 输出格式处理正确（`%02d`补零）。  

**题解三：作者czrjx（赞10）**  
* **点评**：此题解通过字符处理输入，直接提取三个数字，逻辑简单。亮点在于：  
  - 输入处理直观（`scanf("%s",a)`后提取各部分）；  
  - 闰年判断和月份天数调整正确；  
  - 格式匹配条件明确（三个`||`连接的条件）。  

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们常遇到以下关键点，掌握这些能帮你快速理清思路：
</difficulty_intro>

1.  **关键点1：闰年判断**  
    * **分析**：闰年的判断规则是“能被4整除但不能被100整除，或能被400整除”。例如，2000年是闰年（能被400整除），1900年不是（能被100整除但不能被400整除）。在代码中，需要动态调整二月的天数（平年28天，闰年29天）。  
    * 💡 **学习笔记**：闰年判断是日期类问题的基础，必须牢记规则并正确实现。  

2.  **关键点2：三种格式的匹配**  
    * **分析**：输入的三个数字`a/b/c`可能对应：  
      - 年/月/日：`a`是年份后两位，`b`是月份，`c`是日期；  
      - 月/日/年：`a`是月份，`b`是日期，`c`是年份后两位；  
      - 日/月/年：`a`是日期，`b`是月份，`c`是年份后两位。  
      需要将枚举的日期与这三种情况逐一匹配。  
    * 💡 **学习笔记**：用`year%100`获取年份后两位，直接与输入的`a`或`c`比较，能简化匹配逻辑。  

3.  **关键点3：去重与排序**  
    * **分析**：不同格式可能生成相同日期（如输入`01/01/01`），需用集合（`set`）或排序后跳过重复项。例如，用`set<string>`存储结果，自动去重并排序。  
    * 💡 **学习笔记**：集合是处理去重和排序的高效工具，适合日期类问题。  

### ✨ 解题技巧总结
- **枚举范围明确**：题目限定年份在1960-2059之间，直接枚举不会超时，是典型的“暴力能过”题。  
- **动态调整月份天数**：用数组存储各月天数，根据闰年调整二月天数，避免重复判断。  
- **输出补零**：用`%02d`格式符自动补零（如`printf("%d-%02d-%02d\n", year, month, day)`）。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，提炼出一个逻辑清晰、易于理解的核心实现，帮助大家快速掌握代码框架。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了CleverRaccoon和_ChongYun_的题解思路，采用三重循环枚举所有日期，动态调整二月天数，并正确处理格式匹配和输出。  
* **完整核心代码**：  
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int StartYear = 1960, EndYear = 2059;
    int daysOfMonth[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

    inline bool isLeapYear(int y) {
        return (y % 4 == 0 && y % 100 != 0) || (y % 400 == 0);
    }

    int main() {
        int a, b, c;
        scanf("%d/%d/%d", &a, &b, &c);
        set<string> validDates;  // 用集合自动去重并排序

        for (int year = StartYear; year <= EndYear; ++year) {
            daysOfMonth[2] = isLeapYear(year) ? 29 : 28;  // 调整二月天数
            for (int month = 1; month <= 12; ++month) {
                for (int day = 1; day <= daysOfMonth[month]; ++day) {
                    // 检查是否符合三种格式之一
                    if ((a == year % 100 && b == month && c == day) || 
                        (a == month && b == day && c == year % 100) || 
                        (a == day && b == month && c == year % 100)) {
                        // 格式化为"YYYY-MM-DD"，补零
                        char date[20];
                        sprintf(date, "%d-%02d-%02d", year, month, day);
                        validDates.insert(date);
                    }
                }
            }
        }

        // 输出结果
        for (const string& date : validDates) {
            cout << date << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入的三个数字`a/b/c`，然后用三重循环枚举1960-2059年的所有可能日期。对于每个日期，动态调整二月天数（闰年29天），并检查是否符合三种格式之一。符合条件的日期被格式化为字符串存入`set`（自动去重并排序），最后输出所有有效日期。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：作者CleverRaccoon**  
* **亮点**：直接输出符合条件的日期，无需额外去重（因枚举顺序自然排序且无重复）。  
* **核心代码片段**：  
    ```cpp
    for(int year = StartYear; year <= EndYear; ++year) { 
        daysOfMonth[2] = (isLeapYear(year) ? 29 : 28);  
        for(int month = 1; month <= 12; ++month)
            for(int day = 1; day <= daysOfMonth[month]; ++day)
                if((a == year % 100 && b == month && c == day) ||
                   (a == month && b == day && c == year % 100) ||
                   (a == day && b == month && c == year % 100))  
                    printf("%d-%02d-%02d\n", year, month, day); 
    }
    ```
* **代码解读**：  
  这段代码通过三重循环枚举年、月、日。外层循环遍历1960-2059年，每次根据是否为闰年调整二月天数；中间循环遍历1-12月；内层循环遍历该月的所有合法日期。条件判断检查当前日期是否符合三种格式之一，符合则输出（`%02d`自动补零）。  
* 💡 **学习笔记**：直接枚举并输出，利用枚举顺序（年递增→月递增→日递增）保证输出顺序，无需额外排序。  

**题解二：作者_ChongYun_**  
* **亮点**：将格式匹配封装为函数，代码更模块化。  
* **核心代码片段**：  
    ```cpp
    bool istrue(int year,int month,int day) { 
        return (a==year%100&&b==month&&c==day)||
               (a==month&&b==day&&c==year%100)||
               (a==day&&b==month&&c==year%100); 
    }
    ```
* **代码解读**：  
  函数`istrue`接收年、月、日，返回是否符合三种格式之一。通过逻辑或（`||`）连接三种情况，代码简洁易读。这种模块化设计将核心判断逻辑独立，提高了代码的可维护性。  
* 💡 **学习笔记**：将重复的判断逻辑封装为函数，是提高代码可读性的重要技巧。  

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地看到枚举和判断的过程，我们设计了一个“像素日期探险家”动画，用8位复古风格展示算法如何一步步找到所有合法日期！
</visualization_intro>

  * **动画演示主题**：`像素日期探险家——寻找隐藏的合法日期`  

  * **核心演示内容**：  
    探险家从1960年1月1日出发，逐月、逐日探索，每到一个日期就检查是否符合输入的三种格式。符合条件时，日期会变成绿色并播放“叮”的音效；最后所有合法日期按顺序排列成一条时间线。  

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）能降低学习压力，闪烁和音效能强化关键步骤记忆。通过“探险家”的移动，学习者可以直观看到枚举的顺序（年→月→日），理解为何输出是有序的。  

  * **动画帧步骤与交互关键点**：  

    1.  **场景初始化**：  
        - 屏幕左侧是年份轴（1960-2059），中间是月份网格（1-12月），右侧是日期格子（1-31日）；  
        - 控制面板有“单步”“自动播放”按钮和速度滑块（1x-5x）；  
        - 播放8位风格背景音乐（类似《超级马力欧》的轻快旋律）。  

    2.  **枚举过程**：  
        - 探险家（一个小像素人）从1960年1月1日出发，向右移动遍历日期（日递增）；  
        - 到达月末后，向上移动到下月1日（月递增）；  
        - 到达12月31日后，向右移动到下一年1月1日（年递增）；  
        - 每到一个日期，该日期格子变为黄色（当前检查），同时显示对应的年、月、日。  

    3.  **格式匹配判断**：  
        - 检查是否符合三种格式时，屏幕上方弹出三个小窗口，分别显示“年/月/日”“月/日/年”“日/月/年”的匹配结果；  
        - 若匹配成功（如“年/月/日”窗口变绿），当前日期格子变为绿色并播放“叮”音效；  
        - 若匹配失败，格子恢复灰色。  

    4.  **结果收集与排序**：  
        - 所有匹配成功的日期被收集到屏幕下方的“时间线”中，按年→月→日自动排序；  
        - 动画结束时，时间线从左到右展示所有合法日期，播放胜利音效（如《超级马力欧》的通关音乐）。  

  * **旁白提示**：  
    - （单步时）“现在检查1960年1月1日，是否符合输入的02/03/04？不匹配，继续探索！”  
    - （匹配成功时）“叮！1960年3月4日符合‘年/月/日’格式，加入结果！”  
    - （自动播放时）“看，探险家正在快速遍历所有可能的日期，像不像在玩一场时间冒险？”  

<visualization_conclusion>
通过这个动画，我们不仅能“看”到枚举的过程，还能直观理解闰年对二月天数的影响、格式匹配的逻辑，以及结果为何是有序的。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了日期枚举和格式匹配的技巧后，我们可以尝试更复杂的问题，巩固枚举和模拟能力。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的枚举思想适用于：  
    - 其他日期类问题（如计算两个日期的差值）；  
    - 排列组合问题（如找出所有可能的数字组合）；  
    - 条件验证问题（如检查字符串是否符合多种模式）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1008 三连击**  
        * 🗣️ **推荐理由**：通过枚举所有三位数组合，验证是否满足特定条件（1:2:3），锻炼枚举和条件判断能力。  
    2.  **洛谷 P1157 组合的输出**  
        * 🗣️ **推荐理由**：枚举所有可能的组合，输出时按字典序排列，巩固枚举和排序技巧。  
    3.  **洛谷 P1328 生活大爆炸版石头剪刀布**  
        * 🗣️ **推荐理由**：通过枚举每一轮的出法，模拟比赛过程，适合练习复杂条件的判断。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试时的教训，这些经验能帮我们少走弯路：
</insights_intro>

> **参考经验 (来自作者I_like_magic)**：“我提交了11次才AC，主要是没考虑重复日期（如输入01/01/01时会输出多次）。后来用集合去重，才解决问题。”  

**点评**：这位作者的经验提醒我们，日期类问题中重复数据很常见（如不同格式生成相同日期）。使用集合（`set`）或排序后跳过重复项，是避免WA的关键。调试时可以用小测试用例（如`01/01/01`）验证去重逻辑。  

-----

<conclusion>
通过分析“日期问题”，我们掌握了枚举和模拟的核心技巧，理解了闰年判断、格式匹配和去重排序的方法。编程的关键在于多思考、多实践，下次遇到类似问题时，你一定能更快找到解决方案！💪
</conclusion>

---
处理用时：158.69秒
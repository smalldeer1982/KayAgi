# 题目信息

# [PA 2020] Samochody dostawcze

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Samochody dostawcze](https://sio2.mimuw.edu.pl/c/pa-2020-1/sam/)**

Byteasar 是一家向商店运送物资的公司的后勤人员。在他公司所在的城市里，道路网由横向的街（从西到东）和纵向的道（从南到北）组成。每一对相邻的街和相邻的道都相距一公里。我们把街按从南到北的顺序编号，把道按从西到东的顺序编号。我们将第 $i$ 条道和第 $j$ 条街的交叉点记为 $(i,j)$。你可以假设，对于任何一个整数，都存在一条街的编号为 $j$ 和一条道的编号为 $i$。

Byteasar 明天安排了 $n$ 次送货；第 $i$ 次送货将由一辆货车在时刻 $t_i$ 离开车库，以每时间单位一公里的恒定速度沿街或道行驶。每次送货可以是两种类型中的一种：对于送货类型一，车库在路口 $(w_i,0)$，货车沿道 $w_i$ 向北行驶；对于送货类型二，车库在路口 $(0,w_i)$，货车沿街 $w_i$ 向东行驶。根据计划，每个车库在任何时刻最多只有一辆车离开。

货车不必停下来——驶过收货地点时，司机只需放下要送的包裹。然而，有一个问题，如果两辆货车发现他们同一时刻在同一个十字路口，就很可能会发生碰撞。Byteasar 非常希望避免这种情况。不幸的是，他唯一能做的就是取消一些送货计划。因此，他希望取消尽可能少的送货计划，以便剩下的车中没有任何两辆车同一时刻在同一个十字路口。

## 说明/提示

#### 样例 1 解释

如果四份货物都送出，则第一和第二辆车会在时刻 $5$，在路口 $(5,3)$ 相撞。如果取消第一个送货计划，则第二和第四辆车会在时刻 $7$，在路口 $(7,3)$ 相撞。如果取消第二个送货计划，那么所有车都不会相撞了。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n\le 5\times 10^5$，$r_i\in \{1,2\}$，$1\le w_i\le 10^6$，$0\le t_i\le 10^6$。

## 样例 #1

### 输入

```
4
1 5 2
2 3 0
2 3 6
1 7 4```

### 输出

```
1```

# AI分析结果



---
# 💡 Kay的C++算法解析：[PA 2020] Samochody dostawcze 深入学习指南 💡

<introduction>
今天我们来一起分析“[PA 2020] Samochody dostawcze”这道C++编程题。这道题的核心是通过统计与分类的方法解决货车相撞问题，本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（统计与分类）`

🗣️ **初步分析**：
解决这道题的关键在于找到货车相撞的条件，并通过统计分类的方法快速计算需要取消的最少车辆数。简单来说，统计与分类就像“给每个货车发一张‘身份卡’，相同‘身份卡’的货车可能相撞，我们需要处理这些冲突”。在本题中，“身份卡”就是货车的`w_i - t_i`值（或`t_i - w_i`，取决于实现），它能帮我们快速定位哪些货车可能相撞。

- **题解思路**：所有题解的核心思路一致：通过`w_i - t_i`值将货车分类，统计每个类别中两种类型（向北/向东）的货车数量。对于每个类别，若存在两种类型的货车，则需取消数量较少的一方，累加所有类别中需取消的数量即为答案。
- **核心难点**：如何推导出相撞条件（`w_i - t_i`相同且类型不同）、处理负数索引（避免数组越界）、高效统计分类。
- **可视化设计**：我们将设计一个8位像素风格的动画，用不同颜色像素块代表不同类型的货车，动态展示货车按`w_i - t_i`分类的过程，并高亮显示每个类别中需取消的货车。动画中会有“入队”音效（货车加入分类）和“消除”音效（取消货车），增强操作记忆。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，以下题解因逻辑简洁、实现高效被选为优质参考：
</eval_intro>

**题解一：作者Sol1**
* **点评**：此题解思路非常清晰，直接点出分类的关键是`t_i - w_i`，代码简洁高效。变量名`cnt`直观表示统计数组，通过`r-1`将类型转换为0和1，避免越界。算法时间复杂度为O(n)，完全匹配题目数据规模。从实践角度看，代码可直接用于竞赛，边界处理（如偏移量选择）严谨，是学习统计分类问题的优秀示例。

**题解二：作者liuyi0905**
* **点评**：此题解对分类逻辑的解释明确，代码结构工整。变量名`c`虽简短但结合注释易理解，通过`D=1e6`的偏移量处理负数索引，确保数组安全。统计与累加逻辑直接，符合竞赛编程的简洁性要求，适合初学者学习如何将数学推导转化为代码。

**题解三：作者Mason123456**
* **点评**：此题解代码规范，变量名`x`和`y`分别对应两种类型的统计数组，逻辑清晰。通过`M=1e6+5`的偏移量处理索引，避免越界。虽然变量名可更直观（如用`type1`和`type2`），但整体实现稳健，适合理解统计分类的基础操作。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们需要重点突破以下难点，并掌握对应的解题策略：
</difficulty_intro>

1.  **关键点1**：如何确定货车相撞的条件？
    * **分析**：货车相撞需满足两个条件：①类型不同（一个向北，一个向东）；②在某一时刻到达同一坐标。通过数学推导可得，当且仅当`w_i - t_i = w_j - t_j`时，两车会在某时刻相遇（具体推导：类型1货车在时间t的坐标为`(w_i, t - t_i)`，类型2为`(t - t_j, w_j)`，联立得`w_i = t - t_j`且`t - t_i = w_j`，消去t后得`w_i - t_i = w_j - t_j`）。
    * 💡 **学习笔记**：数学推导是找到问题核心条件的关键，需仔细分析运动方程。

2.  **关键点2**：如何处理负数索引？
    * **分析**：由于`w_i - t_i`可能为负数（如`w_i=3, t_i=5`时，`3-5=-2`），直接作为数组下标会越界。优质题解通常选择一个足够大的偏移量（如`1e6`），将`w_i - t_i`转换为非负数（如`w_i - t_i + 1e6`），确保数组安全。
    * 💡 **学习笔记**：处理负数索引时，偏移量需大于等于可能的最小负值（本题中`w_i`和`t_i`最大为`1e6`，故偏移量选`1e6`足够）。

3.  **关键点3**：如何高效统计与累加？
    * **分析**：使用数组（桶）统计每个`w_i - t_i`值对应的两种类型货车数量（时间复杂度O(n)）。遍历所有可能的键，累加每个键中两种类型数量的最小值（时间复杂度O(M)，M为数组大小，本题M约3e6，可接受）。
    * 💡 **学习笔记**：数组统计是处理大规模数据分类问题的高效方法，适合时间复杂度敏感的竞赛场景。

### ✨ 解题技巧总结
- **问题抽象**：将实际问题转化为数学条件（如`w_i - t_i`的相等关系），简化问题模型。
- **偏移量处理**：通过加偏移量将负数索引转换为非负数，避免数组越界。
- **桶统计**：用数组作为“桶”快速统计分类数据，适合大规模数据的高效处理。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解前，我们先看一个综合优质题解的通用核心实现，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Sol1、liuyi0905等题解的思路，采用数组统计分类，偏移量处理负数索引，逻辑简洁高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    const int OFFSET = 1e6; // 偏移量，确保w_i - t_i + OFFSET >= 0
    const int MAX_N = 3e6 + 10; // 数组大小，覆盖所有可能的w_i - t_i + OFFSET值
    int cnt[MAX_N][2]; // cnt[i][0]统计类型1（向北）的数量，cnt[i][1]统计类型2（向东）的数量

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);

        int n;
        cin >> n;

        for (int i = 0; i < n; ++i) {
            int r, w, t;
            cin >> r >> w >> t;
            int key = w - t + OFFSET; // 计算分类键值
            if (r == 1) {
                cnt[key][0]++; // 类型1：向北
            } else {
                cnt[key][1]++; // 类型2：向东
            }
        }

        int ans = 0;
        for (int i = 0; i < MAX_N; ++i) {
            ans += min(cnt[i][0], cnt[i][1]); // 累加每个键中需取消的最小数量
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入数据，计算每个货车的分类键值（`w - t + OFFSET`），并统计到`cnt`数组中。然后遍历`cnt`数组，累加每个键中两种类型货车数量的最小值，得到需取消的最少车辆数。核心逻辑是通过分类统计快速定位冲突，并选择最优取消策略。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其亮点和实现思路。
</code_intro_selected>

**题解一：作者Sol1**
* **亮点**：代码简洁，变量名清晰，通过`r-1`将类型转换为0和1，避免数组越界，时间复杂度O(n)。
* **核心代码片段**：
    ```cpp
    int n, cnt[3000005][2];

    int main() {
        n = qread();
        for (int i = 1; i <= n; ++i) {
            int r = qread(), w = qread(), t = qread();
            cnt[t - w + 1000005][r - 1]++;
        }
        int ans = 0;
        for (int i = 1; i <= 3000000; ++i) ans += min(cnt[i][0], cnt[i][1]);
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读**：
    > `cnt[t - w + 1000005][r - 1]++`中，`t - w`是分类键（与`w - t`仅符号不同，不影响统计），`r-1`将类型1/2转换为0/1，避免数组第二维越界。遍历`cnt`数组时，`min(cnt[i][0], cnt[i][1])`计算每个键中需取消的最小数量，累加得到答案。
* 💡 **学习笔记**：类型转换（如`r-1`）是避免数组越界的常用技巧，需注意类型范围与数组维度匹配。

**题解二：作者liuyi0905**
* **亮点**：明确注释偏移量`D=1e6`，代码结构工整，适合初学者理解。
* **核心代码片段**：
    ```cpp
    const int D = 1e6, N = 2 * D + 5;
    int n, c[N][2];

    int main() {
        cin >> n;
        for (int i = 1, r, w, t; i <= n; ++i)
            cin >> r >> w >> t, c[w - t + D][r - 1]++;
        int z = 0;
        for (int i = 0; i <= 2 * D; ++i)
            z += min(c[i][0], c[i][1]);
        cout << z;
        return 0;
    }
    ```
* **代码解读**：
    > `c[w - t + D][r - 1]++`中，`D=1e6`作为偏移量，确保`w - t + D`非负。`r-1`将类型转换为0/1，`c`数组统计每个键的两种类型数量。最后遍历数组累加最小值，逻辑直接。
* 💡 **学习笔记**：明确的常量定义（如`D`）能提高代码可读性，便于后续调整参数。

**题解三：作者Mason123456**
* **亮点**：通过`x`和`y`数组分别统计两种类型，逻辑清晰。
* **核心代码片段**：
    ```cpp
    const int N = 3e7 + 10;
    const int M = 1e6 + 5;
    int x[N], y[N];

    int main() {
        int n;
        cin >> n;
        for (int i = 1; i <= n; ++i) {
            int r, w, t;
            cin >> r >> w >> t;
            if (r == 1) { // 向北
                y[w - t + M]++;
            } else { // 向东
                x[w - t + M]++;
            }
        }
        int ans = 0;
        for (int i = 0; i <= N; ++i) {
            if (x[i] && y[i]) {
                ans += min(x[i], y[i]);
            }
        }
        cout << ans;
    }
    ```
* **代码解读**：
    > `x`和`y`数组分别统计类型2（向东）和类型1（向北）的数量，`w - t + M`处理负数索引。遍历数组时，仅当`x[i]`和`y[i]`均非零时累加最小值，避免无效计算。
* 💡 **学习笔记**：分开统计两种类型的数组（如`x`和`y`）适合需要明确区分类型的场景，逻辑更直观。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解货车分类与冲突处理过程，我们设计一个8位像素风格的动画——“货车防撞大作战”，通过动态演示帮助大家“看到”算法每一步！
</visualization_intro>

  * **动画演示主题**：`像素货车的安全之路`
  * **核心演示内容**：展示货车按`w_i - t_i`分类的过程，高亮冲突类别，并动态计算需取消的货车数量。
  * **设计思路简述**：采用8位像素风（如FC红白机色调），用蓝色像素块代表向北货车，红色代表向东货车。每个`w_i - t_i`值对应一个“碰撞点”，当同一碰撞点有两种颜色时，较少的一方会被“消除”（爆炸动画），增强对分类与冲突处理的理解。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧为道路网格（像素方块），右侧为“分类统计区”（排列的桶状像素框，每个框标有`w-t+1e6`值）。
          * 控制面板：单步/自动播放按钮、速度滑块（1x-5x）、重置按钮。
          * 播放8位风格背景音乐（如《超级马力欧》经典旋律）。

    2.  **货车入场动画**：
          * 输入一辆货车时，对应类型（蓝/红）的像素块从屏幕上方“掉落”到对应的分类桶中（如`w=5,t=2`，则`w-t=3`，蓝块掉入标有`3+1e6`的桶）。
          * 伴随“叮”的音效（类似《俄罗斯方块》方块落下声）。

    3.  **冲突检测与消除**：
          * 单步播放时，点击“下一步”，遍历所有桶。若桶中有蓝块和红块，数量较少的颜色块会触发“爆炸”动画（像素碎裂，伴随“砰”音效）。
          * 自动播放时，按设定速度遍历桶，动态显示消除过程，最终统计总消除数。

    4.  **结果展示**：
          * 消除完成后，剩余的蓝块和红块数量之和为保留的货车数，总消除数显示在屏幕中央，伴随“胜利”音效（如《超级马力欧》吃金币声）。

  * **旁白提示**：
      * （货车入场时）“这辆蓝色货车属于`w-t=3`的分类，放入对应桶中～”
      * （冲突检测时）“看！这个桶里有2辆蓝色和3辆红色货车，需要取消2辆蓝色货车～”
      * （结果展示时）“最终取消了1辆货车，所有货车安全行驶！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到货车如何按`w-t`值分类，冲突如何产生，以及如何选择最优取消策略。这种游戏化的演示能帮助我们更深刻地理解统计分类算法的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的统计分类方法后，我们可以将其迁移到更多需要处理冲突或分类统计的问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 统计分类方法适用于需要快速定位冲突或分组处理的场景，例如：
        - 任务调度中的时间冲突（如两个任务时间重叠）。
        - 区间重叠问题（如多个区间是否相交）。
        - 社交网络中的共同好友统计（如两个用户的共同好友数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1090 合并果子**
          * 🗣️ **推荐理由**：这道题需要用贪心算法合并果子，统计合并代价，可练习分类统计与优先队列的应用。
    2.  **洛谷 P1803 凌乱的yyy**
          * 🗣️ **推荐理由**：此题需统计活动时间冲突，选择最多不重叠的活动，适合练习冲突检测与贪心策略。
    3.  **洛谷 P1115 最大子段和**
          * 🗣️ **推荐理由**：通过动态规划统计最大子段和，可练习分类统计与状态转移的结合。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者们的实践经验为我们提供了宝贵的参考：
</insights_intro>

> **参考经验 (来自作者xd244)**：“数组一定要开够，2000010会WA（因为`w_i-t_i=200000`时再加上1e6会越界）。”
>
> **点评**：这位作者的经验提醒我们，处理数组大小时需充分考虑数据范围。本题中`w_i`和`t_i`最大为1e6，`w_i-t_i`的范围是`[-1e6, 1e6]`，因此偏移量需至少为1e6，数组大小需至少为2e6+1。这是避免RE（运行时错误）的关键。

-----

<conclusion>
本次关于“[PA 2020] Samochody dostawcze”的C++解题分析就到这里。希望这份指南能帮助你理解统计分类算法的核心，并掌握处理冲突问题的技巧。记住，编程的关键是理解问题本质，将复杂问题转化为数学模型，再用高效的代码实现！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：204.71秒
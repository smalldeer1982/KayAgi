# 题目信息

# 山峰暸望

## 题目描述

一天，Bessie 在眺望美丽的威斯康星的群山的时候，她突然产生了疑问：哪座山是最宽的？

她决定在地平线上，利用她的新式大量程山峰高度测量仪依次做 $N$（$1 \le N \le 10,000$）次高度测量，每次的高度值为 $H_i$（$1 \le H_i \le 1,000,000,000$）。

一座山定义为一段连续的高度序列，序列中的高度一开始单调上升（或者不变），然后单调下降（或者不变）。举例来说，$2, 3, 3, 5, 4, 4, 1$ 这一段高度序列就是一座山。如果在她的视线范围内有一段单调上升或者单调下降的序列，也算是一座山。注意，两座山之间可能会有部分重叠。

山的宽度定义为在这个山上进行的测量的次数（也就是序列的长度）。例如序列 $2, 3, 3, 5, 4, 4, 1$ 的宽度为 $7$。

请帮 Bessie 找到最宽的山。

下图是一个比较典型的的例子：

```plain
           *******                   *                                
          *********                  ***                               
          **********                *****                              
          ***********            *********               *             
*      *****************       ***********             *** *          
**    *******************     *************   * *     *******      *  
**********************************************************************  山的形状
3211112333677777776543332111112344456765432111212111112343232111111211  高度值
aaaaa                    ccccccccccccccccccccc eeeeeee ggggggggg
  bbbbbbbbbbbbbbbbbbbbbbbbbbbb             ddddd          ffffffffff  
                                                             hhhhhhhhh  山的编号
```

山标记为 `a`、`b` 等等。显然，山 `b` 有着最大的宽度，宽度为 $28$。


## 说明/提示

**【样例说明】**

在最宽的山处测量到的高度为 $2, 3, 5, 4, 1$。其他的山包括 $3, 2$ 和 $1, 6$。

---

**【提示】**

如果你知道一座山的最高的部分（也就是山峰），你会发现，找到这座山的宽度是很容易的哦。

## 样例 #1

### 输入

```
7
3
2
3
5
4
1
6
```

### 输出

```
5
```

# AI分析结果



---
# 💡 Kay的C++算法解析：山峰暸望 深入学习指南 💡

<introduction>
今天我们来一起分析“山峰暸望”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过分析不同题解的优缺点，我们还会提炼出高效的解题方法，并设计一个有趣的像素动画来直观展示算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与动态规划应用`

🗣️ **初步分析**：
> 解决“山峰暸望”的关键在于找到一段连续的高度序列，该序列先单调上升（或不变）后单调下降（或不变），并求其最大长度。简单来说，模拟法就像“逐个试峰”——把每个点当作山峰，向左右扩展找到山脚；动态规划则是“预处理延伸”——预先计算每个点向左/右能延伸的最长上升/下降长度，再组合得到山的宽度。  
> - 题解思路对比：暴力模拟（O(n²)）直接但时间稍高；动态规划（O(n)）通过预处理左右延伸长度，更高效。  
> - 核心算法流程：动态规划中，`fup[i]`表示以i结尾的最长非降序列长度，`fdown[i]`表示以i开头的最长非升序列长度，最终山的宽度为`fup[i]+fdown[i]-1`（避免重复计算i点）。  
> - 可视化设计：计划用8位像素风动画演示动态规划预处理过程：每个点显示`fup`和`fdown`的值（用数字气泡），颜色变化表示上升/下降状态；关键步骤（如状态转移）用闪烁和音效提示。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法效率等，以下题解表现突出（≥4星）：
</eval_intro>

**题解一：作者AFOier（赞36）**
* **点评**：此题解思路直白，代码简洁。通过枚举每个点为山峰，向左右扩展找山脚，直接计算宽度。代码变量命名清晰（`l`左边界，`r`右边界），边界处理严谨（`l>1`和`r<n`防止越界）。虽然时间复杂度为O(n²)，但在n=1e4时仍能通过（实际测试数据较宽松），适合理解基础思路。

**题解二：作者万弘（赞12）**
* **点评**：此题解用动态规划优化至O(n)，是核心亮点。状态定义`fup[i]`和`fdown[i]`分别表示左右延伸长度，转移方程明确（非降则累加，否则重置为1）。代码结构工整，边界处理（`fup[1]=1`，`fdown[n]=1`）规范，时间复杂度更优，适合学习高效算法设计。

**题解三：作者lych（赞0）**
* **点评**：此题解用Delphi实现动态规划（思路与C++一致），核心逻辑与万弘类似。通过预处理`left`和`right`数组，分别记录每个点向左/右的最长非降长度，最终组合求最大值。虽语言不同，但思路清晰，对理解动态规划有启发。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于处理“山峰”的左右延伸和高效计算。以下是核心难点及策略：
</difficulty_intro>

1.  **关键点1：如何准确定义“山峰”**  
    * **分析**：山峰可以是序列中的任意点（包括单增或单降序列的端点）。例如，单增序列的最后一个点是山峰（右侧无下降），单降序列的第一个点是山峰（左侧无上升）。优质题解通过枚举每个点为山峰，或预处理左右延伸长度来覆盖所有可能。  
    * 💡 **学习笔记**：山峰的定义是“先升后降”，但允许升或降部分为空（即单增/单降序列也算山）。

2.  **关键点2：如何高效计算左右延伸长度**  
    * **分析**：暴力法（O(n²)）逐个扩展，时间较高；动态规划（O(n)）通过递推预处理，利用“当前状态依赖前一状态”的特性，避免重复计算。例如，`fup[i]`若当前非降，则`fup[i] = fup[i-1]+1`，否则为1。  
    * 💡 **学习笔记**：预处理是优化时间复杂度的常用手段，关键是找到状态转移的规律。

3.  **关键点3：如何处理边界条件**  
    * **分析**：边界条件（如i=1或i=n）需特别处理。例如，i=1时左侧无元素，`fup[1]=1`；i=n时右侧无元素，`fdown[n]=1`。优质题解通过初始化边界值（如`fup[1]=1`）确保递推正确。  
    * 💡 **学习笔记**：边界条件是动态规划的“基石”，错误处理会导致结果偏差。

### ✨ 解题技巧总结
- **问题分解**：将“找最宽山”分解为“找每个点的左右延伸长度”，简化问题。  
- **预处理优化**：用动态规划预处理左右延伸长度，将O(n²)优化为O(n)。  
- **边界检查**：处理数组首尾时，需单独初始化（如`fup[1]=1`），避免越界错误。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个高效的通用核心实现（基于动态规划，O(n)）：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合万弘的动态规划思路，时间复杂度O(n)，是高效解法的代表。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    const int MAXN = 100010;
    long long h[MAXN], fup[MAXN], fdown[MAXN];
    int n;

    int main() {
        cin >> n;
        for (int i = 1; i <= n; ++i) cin >> h[i];
        
        // 预处理fup：以i结尾的最长非降序列长度
        fup[1] = 1;
        for (int i = 2; i <= n; ++i) {
            fup[i] = (h[i] >= h[i-1]) ? fup[i-1] + 1 : 1;
        }
        
        // 预处理fdown：以i开头的最长非升序列长度
        fdown[n] = 1;
        for (int i = n-1; i >= 1; --i) {
            fdown[i] = (h[i] >= h[i+1]) ? fdown[i+1] + 1 : 1;
        }
        
        // 计算最大宽度
        long long ans = 0;
        for (int i = 1; i <= n; ++i) {
            ans = max(ans, fup[i] + fdown[i] - 1);
        }
        
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码先读取输入，然后预处理`fup`和`fdown`数组。`fup[i]`表示从左到i的最长非降长度（如`h[3]>=h[2]`则`fup[3]=fup[2]+1`）；`fdown[i]`表示从i到右的最长非升长度（如`h[3]>=h[4]`则`fdown[3]=fdown[4]+1`）。最后遍历所有点，计算`fup[i]+fdown[i]-1`（i点被重复计算一次，故减1），取最大值即为答案。

---
<code_intro_selected>
接下来分析优质题解的核心片段：
</code_intro_selected>

**题解一：作者AFOier（暴力模拟）**
* **亮点**：思路直白，代码简洁，适合理解基础逻辑。  
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++) {
        l=i; r=i;
        while(a[l-1]<=a[l]&&l>1) l--;
        while(a[r+1]<=a[r]&&r<n) r++;
        ans=max(ans,r-l+1);
    }
    ```
* **代码解读**：  
  对每个i，初始l=r=i（山峰位置）。左扩展：只要左边高度≤当前高度，l左移；右扩展：只要右边高度≤当前高度，r右移。最终山的宽度是r-l+1。例如，i=3时，若左边2≤3，l移到2；右边5≥3，r移到4，宽度为4-2+1=3。  
* 💡 **学习笔记**：暴力法虽简单，但适合小数据或理解问题本质。

**题解二：作者万弘（动态规划）**
* **亮点**：O(n)时间复杂度，高效解决问题。  
* **核心代码片段**：
    ```cpp
    fup[1] = 1;
    for (ll i = 2; i <= n; ++i) {
        if (h[i] >= h[i-1]) fup[i] = fup[i-1] + 1;
        else fup[i] = 1;
    }
    fdown[n] = 1;
    for (ll i = n-1; i >= 1; --i) {
        if (h[i] >= h[i+1]) fdown[i] = fdown[i+1] + 1;
        else fdown[i] = 1;
    }
    ```
* **代码解读**：  
  `fup`数组从左到右计算，若当前高度≥前一个，则继承前一个的长度（`fup[i]=fup[i-1]+1`），否则重置为1（当前点独立）。`fdown`数组从右到左类似。例如，序列3,2,3,5,4,1,6：`fup[3]`（h=3）因h[3]≥h[2]（3≥2），所以`fup[3]=fup[2]+1=2`；`fdown[4]`（h=5）因h[4]≥h[5]（5≥4），所以`fdown[4]=fdown[5]+1=2`。  
* 💡 **学习笔记**：动态规划通过“状态转移”避免重复计算，是优化时间的关键。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解动态规划预处理过程，我们设计一个“像素登山”动画，用8位复古风格展示`fup`和`fdown`的计算过程。
</visualization_intro>

  * **动画演示主题**：`像素登山家的延伸挑战`  
  * **核心演示内容**：展示每个点的`fup`（向上延伸长度）和`fdown`（向下延伸长度）如何通过状态转移计算，并最终找到最宽山。  
  * **设计思路简述**：8位像素风（FC红白机配色）降低学习压力；动态变化的数字气泡显示`fup`/`fdown`值，闪烁和音效强化关键步骤（如状态转移）；游戏化“闯关”概念（每完成一个点的预处理算一关）增加趣味性。  

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：  
       - 屏幕分为左右两部分：左半显示高度数组（像素方块，颜色随高度变化），右半显示`fup`和`fdown`数组（数字气泡）。  
       - 控制面板：单步/自动播放按钮、速度滑块（1-10倍速）、重置按钮。  
       - 8位风格BGM（类似《超级玛丽》主题曲）。

    2. **fup预处理演示**：  
       - 从i=1开始，像素登山家（黄色方块）从左向右移动。  
       - i=1时，`fup[1]=1`（气泡显示），伴随“叮”音效。  
       - i=2时，比较h[2]与h[1]：若h[2]≥h[1]，登山家跳跃到i=1的位置，`fup[2]=fup[1]+1`（气泡数字+1），音效“叮”；否则，登山家停留，`fup[2]=1`（音效“嗒”）。  
       - 每完成一个i的`fup`计算，对应像素块变绿色（表示完成）。

    3. **fdown预处理演示**：  
       - 登山家从右向左移动（i=n到1），逻辑类似`fup`。  
       - i=n时，`fdown[n]=1`（气泡显示），音效“叮”。  
       - i=n-1时，比较h[i]与h[i+1]：若h[i]≥h[i+1]，登山家跳跃到i+1的位置，`fdown[i]=fdown[i+1]+1`（音效“叮”）；否则重置为1（音效“嗒”）。

    4. **计算最宽山**：  
       - 所有`fup`和`fdown`计算完成后，登山家遍历每个点，计算`fup[i]+fdown[i]-1`（气泡显示当前宽度）。  
       - 最宽山的位置用红色高亮，伴随“胜利”音效（如《超级玛丽》吃金币音）。

  * **旁白提示**：  
    - “看！当h[i]≥h[i-1]时，fup[i]会继承前一个的长度，就像登山家从左边跳过来～”  
    - “现在处理fdown，方向反过来啦！如果h[i]≥h[i+1]，就能从右边跳过来哦～”  
    - “最后，每个点的宽度是fup加fdown减1（因为i点被算了两次），最大的那个就是答案！”

<visualization_conclusion>
通过这个动画，我们能直观看到动态规划如何通过状态转移高效计算延伸长度，理解“预处理”为何能优化时间复杂度。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下题目巩固思路：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    动态规划预处理左右延伸长度的方法，还可用于：  
    - 最长连续子数组（如“最长连续递增子序列”）。  
    - 统计满足条件的区间（如“每个位置作为峰值的区间数量”）。  
    - 二维矩阵中的山峰问题（如“矩阵中的最长递增路径”）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1317 低洼地**  
        * 🗣️ **推荐理由**：与本题类似，需处理序列的上升/下降趋势，适合练习边界条件处理。  
    2.  **洛谷 P1057 传球游戏**  
        * 🗣️ **推荐理由**：动态规划经典题，通过状态转移计算方案数，巩固DP思维。  
    3.  **洛谷 P1020 导弹拦截**  
        * 🗣️ **推荐理由**：需计算最长不升子序列，与本题的“延伸长度”思路相关，适合拓展。  

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自作者zhangzhaoke)**：“我一开始认为模拟会超时，用动规调不出来，最后试了模拟居然过了。”  
> **点评**：这提醒我们，实际编程中不要被理论复杂度束缚，小数据下暴力法可能更易实现。但学习时仍需掌握优化方法（如动态规划），以应对大数据场景。

---

<conclusion>
本次关于“山峰暸望”的分析就到这里。通过理解动态规划的预处理思路和暴力模拟的基础逻辑，相信大家能更灵活地解决类似问题。记得多动手写代码、调试验证，编程能力会在实践中稳步提升！下次见～ 💪
</conclusion>

---
处理用时：153.22秒
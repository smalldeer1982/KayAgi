# 题目信息

# 天际线

## 题目描述

Latium 省的 Genoa 是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官 Caesar 的委任，前往 Genoa 建立新的城市。Caesar 对这次任务的要求是在 Genoa 这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。

正在你大刀阔斧地进行城市建设的时候，Caesar 突然写信给你，说他要检查 Genoa 的建设情况。Caesar 希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。

怎样描述一个城市的轮廓呢？我们知道 Genoa 所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组 $(L_i,H_i,R_i)$，其中 $L_i$ 和 $R_i$ 分别是建筑的左坐标和右坐标，$H_i$ 就是建筑的高度。在下方所示的图表中左边建筑物描述如下 $(1,11,5)$，$(2,6,7)$，$(3,13,9)$，$(12,7,16)$，$(14,3,25)$，$(19,18,22)$，$(23,13,29)$，$(24,4,28)$，右边用轮廓线的顺序$(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)$ 表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/oe7wpwsi.png)


## 样例 #1

### 输入

```
1 11 5
2 6 7
3 13 9
12 7 16
14 3 25
19 18 22
23 13 29
24 4 28
```

### 输出

```
1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0```

# AI分析结果



---

# 💡 Kay的C++算法解析：天际线 深入学习指南 💡

<introduction>
今天我们来一起分析“天际线”这道C++编程题。这道题要求我们根据给定的建筑信息，输出城市的轮廓线折点坐标。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扫描线与区间最大值维护` (涉及扫描线、线段树/优先队列/暴力法等算法技巧)

🗣️ **初步分析**：
解决“天际线”问题的关键在于捕捉所有高度变化的折点。这些折点出现在两个位置：一是某建筑的左边界导致当前最大高度提升，二是某建筑的右边界导致当前最大高度下降。核心思路是通过**扫描线法**遍历所有关键事件点（建筑的左右边界），并维护当前所有活跃建筑的最大高度。

简单来说，扫描线法就像用一根垂直于x轴的线从左到右移动，每当遇到建筑的左边界（开始影响高度）或右边界（结束影响高度）时，更新当前的最大高度。如果最大高度发生变化，就记录一个折点。例如，左边界事件会将建筑高度加入当前活动集合，右边界事件则将其移除。

- **题解思路对比**：  
  题解中主要有两种思路：  
  1. **暴力法**：直接记录每个x坐标的最大高度（需注意区间闭合问题，如左闭右开避免缝隙）；  
  2. **扫描线+高效数据结构**（线段树、优先队列、平衡树等）：通过处理事件点（左右边界），动态维护当前最大高度，时间复杂度更优。  

- **核心算法流程**：  
  以扫描线+优先队列为例，流程如下：  
  1. 将所有建筑的左右边界作为事件点（左边界标记为“加入高度”，右边界标记为“移除高度”）；  
  2. 按x坐标排序事件点（x相同则左边界优先，避免缝隙）；  
  3. 遍历事件点，维护当前活跃的高度集合（如优先队列），每次更新后检查最大高度是否变化，若变化则记录折点。  

- **可视化设计思路**：  
  采用8位像素风格，用不同颜色的方块表示建筑。扫描线用黄色竖线从左到右移动，遇到左边界时，对应高度的方块“弹入”队列；遇到右边界时，对应高度的方块“弹出”。当前最大高度用红色数字显示在屏幕上方，高度变化时播放“叮”的音效，并在折点位置用白色圆点标记。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑简洁、实现高效且易于学习，被选为优质题解（评分≥4星）：
</eval_intro>

### 题解一：暴力法（作者：InchTree）
* **点评**：  
  这道题解以“暴力法”为核心，思路极其简洁——直接记录每个x坐标的最大高度。通过将建筑区间从`[L, R]`改为左闭右开`[L, R)`，巧妙解决了边界缝隙问题（如两建筑相邻时不会漏点）。代码仅10余行，变量命名清晰（如`H[i]`表示x=i处的最大高度），边界处理严谨（循环条件`i < b`），非常适合初学者理解问题本质。尽管时间复杂度为O(N*X)（N为建筑数，X为坐标范围），但在题目数据范围内（X≤10000）实际运行效率很高（4ms内通过）。

### 题解二：扫描线+优先队列（作者：haoyun1）
* **点评**：  
  此题解采用扫描线法结合优先队列（大根堆）维护当前最大高度。通过将建筑的左右边界排序后依次处理，左边界入堆，右边界标记过期并弹出堆顶。代码逻辑清晰（如`priority_queue`维护当前高度），关键步骤（如处理过期高度）注释明确，时间复杂度为O(N log N)，适合学习动态维护最大值的技巧。

### 题解三：扫描线+multiset（作者：zhenglier）
* **点评**：  
  此题解利用`multiset`（允许重复且自动排序）维护当前活跃高度，左边界插入高度，右边界删除对应高度。通过`multiset::rbegin()`获取最大值，逻辑简洁高效。代码中特别注意删除操作需用迭代器（避免误删所有相同高度），体现了对STL容器特性的深刻理解，适合学习如何用STL简化复杂操作。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决“天际线”问题时，以下三个关键点最容易出错，掌握它们能帮你快速突破：
</difficulty_intro>

### 关键点1：如何处理边界缝隙？
- **分析**：  
  若建筑区间用闭区间`[L, R]`，相邻建筑的右边界和左边界可能重合，导致中间缝隙漏点。例如，建筑A`(1,10,3)`和建筑B`(4,10,6)`，区间`[3,4]`的高度未被覆盖。  
  **解决方案**：将建筑区间改为左闭右开`[L, R)`，即建筑覆盖x从L到R-1的坐标（如InchTree的题解）。

- 💡 **学习笔记**：  
  边界处理是几何题的常见难点，左闭右开区间能有效避免缝隙问题。

### 关键点2：如何高效维护当前最大高度？
- **分析**：  
  暴力法直接遍历所有坐标，时间复杂度高（O(N*X)）；扫描线法需动态维护活跃高度的最大值，需高效数据结构（如优先队列、multiset）。优先队列（大根堆）可快速获取最大值，但删除操作需标记过期；multiset支持快速插入、删除和取最大值，更灵活。

- 💡 **学习笔记**：  
  动态维护最大值时，优先队列适合“只增不减”的场景，multiset适合需要频繁删除的场景。

### 关键点3：如何正确输出折点？
- **分析**：  
  折点出现在最大高度变化的位置。例如，当扫描线移动到x时，若当前最大高度与前一位置不同，则输出(x, 新高度)。需注意：初始高度为0，结束时若高度非0需补0。

- 💡 **学习笔记**：  
  输出时需记录前一高度，每次变化时输出当前x和新高度。

### ✨ 解题技巧总结
- **技巧1：事件点排序**：将左右边界按x排序，x相同时左边界优先（避免缝隙）。  
- **技巧2：左闭右开区间**：处理建筑区间时，用`[L, R)`代替`[L, R]`，避免边界漏点。  
- **技巧3：动态数据结构选择**：根据操作需求选择优先队列（快速取最大）或multiset（灵活插入删除）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是一个综合了暴力法和扫描线思想的通用核心实现，适合快速理解问题本质：
</code_intro_overall>

### 本题通用核心C++实现参考（暴力法）
* **说明**：此代码来自InchTree的题解，通过左闭右开区间处理边界，代码简洁且能直接通过题目测试。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
int H[10005]; // 记录每个x坐标的最大高度
int main() {
    int a, b, h;
    while (scanf("%d%d%d", &a, &h, &b) != EOF) 
        for (int i = a; i < b; ++i) // 左闭右开区间，避免缝隙
            H[i] = max(H[i], h); 
    int last = 0;
    for (int i = 1; i < 10000; ++i) {
        if (H[i] != last) {
            printf("%d %d ", i, H[i]);
            last = H[i];
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先读取所有建筑信息，遍历每个建筑的左闭右开区间`[a, b)`，更新每个x坐标的最大高度`H[i]`。然后遍历所有x坐标，当高度变化时输出折点（x, 当前高度）。

---

<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

### 题解一：暴力法（作者：InchTree）
* **亮点**：用左闭右开区间`[a, b)`处理建筑覆盖范围，避免边界缝隙。
* **核心代码片段**：
```cpp
while (scanf("%d%d%d", &a, &h, &b) != EOF) 
    for (int i = a; i < b; ++i) 
        H[i] = max(H[i], h); 
```
* **代码解读**：  
  这段代码遍历建筑的左闭右开区间`[a, b)`，将每个x坐标的最大高度更新为当前建筑高度`h`。例如，建筑`(1,11,5)`会覆盖x=1,2,3,4（因为`i < 5`），避免了与下一个建筑在x=5处的缝隙。

* 💡 **学习笔记**：  
  左闭右开的区间设计是解决边界问题的关键，类似数组索引的“前闭后开”原则。

### 题解二：扫描线+优先队列（作者：haoyun1）
* **亮点**：用优先队列（大根堆）维护当前活跃高度，动态处理左右边界事件。
* **核心代码片段**：
```cpp
priority_queue<building> q; // 大根堆，按高度排序
for (int i = 1; i <= 2 * n; i++) {
    // 处理右边界，弹出过期的堆顶
    while (q.size() && b[i].w >= q.top().r) q.pop(); 
    if (!b[i].p) q.push(building(a[b[i].v][0], a[b[i].v][2])); // 左边界入堆
    int now = q.empty() ? 0 : q.top().h;
    if (now != last) { // 高度变化，输出折点
        printf("%d %d ", b[i].w, now);
        last = now;
    }
}
```
* **代码解读**：  
  遍历排序后的事件点（左右边界），右边界事件时弹出所有右端点≤当前x的堆顶（过期建筑）；左边界事件时将建筑高度入堆。每次处理后检查当前最大高度（堆顶）是否变化，若变化则输出折点。

* 💡 **学习笔记**：  
  优先队列适合维护动态最大值，但需注意处理“延迟删除”（即标记过期后再弹出）。

### 题解三：扫描线+multiset（作者：zhenglier）
* **亮点**：用`multiset`灵活维护当前高度，支持快速插入、删除和取最大值。
* **核心代码片段**：
```cpp
multiset<int> tr; 
tr.insert(0); // 初始高度为0
for (int i = zuo; i <= you; ++i) {
    // 处理左边界：插入高度
    for (auto h : add[i]) tr.insert(h); 
    // 处理右边界：删除高度（用迭代器避免误删）
    for (auto h : del[i]) tr.erase(tr.find(h)); 
    int now = *tr.rbegin(); // 取最大值
    if (now != last) {
        printf("%d %d ", i, now);
        last = now;
    }
}
```
* **代码解读**：  
  `multiset`自动按升序排列，`tr.rbegin()`获取最大值。左边界事件将高度插入`multiset`，右边界事件用`tr.find(h)`找到迭代器并删除（避免删除所有相同高度）。每次迭代后检查最大值是否变化，输出折点。

* 💡 **学习笔记**：  
  `multiset`的`rbegin()`是获取最大值的高效方式，删除时必须用迭代器避免批量删除。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解扫描线法的执行过程，我们设计了一个“像素探险家”主题的8位像素动画，通过动态展示建筑覆盖和高度变化，帮助你“看”到算法的每一步！
</visualization_intro>

* **动画演示主题**：`像素探险家的天际线之旅`  
  探险家从x=0出发，沿着x轴向右移动，遇到建筑边界时调整当前最大高度，记录折点。

* **核心演示内容**：  
  展示扫描线（黄色竖线）从左到右移动，遇到左边界时，对应建筑高度的像素方块“弹入”队列；遇到右边界时，方块“弹出”。当前最大高度用红色数字显示在屏幕上方，高度变化时播放“叮”的音效，并在折点位置用白色圆点标记。

* **设计思路简述**：  
  8位像素风格（如FC游戏画面）营造轻松氛围，动态队列展示高度变化过程，音效强化关键操作记忆。每完成一个折点记录，视为“小关卡”通过，增加成就感。

* **动画帧步骤与交互关键点**：
  1. **初始化场景**：  
     - 背景为浅灰色网格（x轴），建筑用彩色方块表示（如红色代表高度11，蓝色代表高度13）。  
     - 控制面板包含“单步”“自动播放”按钮和速度滑块。  
     - 播放8位风格背景音乐（如《超级玛丽》的轻快旋律）。  

  2. **处理左边界事件**：  
     - 扫描线（黄色竖线）移动到x=1时，触发建筑(1,11,5)的左边界事件。红色方块从底部“弹入”队列（伴随“咻”的音效），队列显示当前活跃高度：[11]。  
     - 最大高度更新为11，屏幕上方红色数字从0变为11，播放“叮”的音效，在(x=1, y=11)处标记白色圆点。  

  3. **处理右边界事件**：  
     - 扫描线移动到x=5时，触发建筑(1,11,5)的右边界事件。红色方块“弹出”队列（伴随“噗”的音效），队列变为空，最大高度降为0。  
     - 屏幕上方红色数字从11变为0，播放“叮”的音效，在(x=5, y=0)处标记白色圆点。  

  4. **自动演示与对比**：  
     - 点击“自动演示”，扫描线自动移动，快速展示所有事件点的处理过程。  
     - 可切换“暴力法”和“扫描线法”模式，对比两种算法在相同输入下的处理步骤（如暴力法逐个更新x坐标，扫描线法批量处理事件点）。  

* **旁白提示**：  
  - “看！扫描线移动到x=1，这里是一个建筑的左边界，高度11被加入队列，当前最大高度变成11！”  
  - “现在扫描线到了x=5，这是刚才那个建筑的右边界，高度11被移除，最大高度回到0，记录折点(x=5, 0)。”

<visualization_conclusion>
通过这个动画，你可以清晰看到扫描线如何动态维护最大高度，以及折点如何因高度变化而产生。像素风格和游戏化设计让算法学习更有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握“天际线”问题的解法后，我们可以将扫描线和区间维护的思路迁移到更多几何问题中：
</similar_problems_intro>

* **通用思路/技巧迁移**：  
  扫描线法不仅适用于天际线问题，还可解决以下类型的问题：  
  1. **矩形面积并/周长并**（如求多个矩形覆盖的总面积）；  
  2. **区间覆盖统计**（如统计被至少k个区间覆盖的点的数量）；  
  3. **活动选择问题**（如根据时间区间安排活动，最大化参与数）。  

* **练习推荐 (洛谷)**：
  1.  **洛谷 P1856 [USACO5.5]矩形周长**  
     🗣️ **推荐理由**：需用扫描线法统计矩形覆盖的周长，涉及水平和垂直两个方向的扫描，强化对扫描线的理解。  
  2.  **洛谷 P3740 [HAOI2014]贴海报**  
     🗣️ **推荐理由**：用珂朵莉树（ODT）处理区间覆盖问题，适合练习高级数据结构的应用。  
  3.  **洛谷 P1972 [SDOI2009]HH的项链**  
     🗣️ **推荐理由**：需用扫描线+树状数组统计区间内不同元素的数量，拓展扫描线在统计问题中的应用。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者InchTree)**：“最初我用`i <= b`的循环，结果在相邻建筑的边界处漏了点，后来改成`i < b`才通过。这让我意识到边界条件的处理必须非常仔细。”

**点评**：  
InchTree的经验提醒我们，几何问题中边界条件（如闭区间与开区间）的处理直接影响正确性。遇到类似问题时，可通过画示意图或构造小测试用例（如两个相邻建筑）验证边界逻辑。

---

<conclusion>
本次关于“天际线”的C++解题分析就到这里。希望这份指南能帮助你理解扫描线法和区间维护的核心思想，并通过代码和动画直观掌握解题技巧。记住，多动手调试、构造测试用例，是提升编程能力的关键！下次我们再一起探索新的算法挑战！💪
</conclusion>

---
处理用时：188.38秒
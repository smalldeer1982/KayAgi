# 题目信息

# [CSP-J2019] 公交换乘

## 题目描述

著名旅游城市 B 市为了鼓励大家采用公共交通方式出行，推出了一种地铁换乘公交车的优惠方案：
1. 在搭乘一次地铁后可以获得一张优惠票，有效期为 45 分钟，在有效期内可以消耗这张优惠票，免费搭乘一次票价不超过地铁票价的公交车。在有效期内指开始乘公交车的时间与开始乘地铁的时间之差小于等于 45 分钟，即：
$t_{bus} - t_{subway} \leq 45$。
2. 搭乘地铁获得的优惠票可以累积，即可以连续搭乘若干次地铁后再连续使用优惠票搭乘公交车。
3. 搭乘公交车时，如果可以使用优惠票一定会使用优惠票；如果有多张优惠票满足条件，则优先消耗获得最早的优惠票。

现在你得到了小轩最近的公共交通出行记录，你能帮他算算他的花费吗?

## 说明/提示

**样例 1 说明**

第一条记录，在第 3 分钟花费 10 元乘坐地铁。

第二条记录，在第 46 分钟乘坐公交车，可以使用第一条记录中乘坐地铁获得的优惠票，因此没有花费。

第三条记录，在第 50 分钟花费 12 元乘坐地铁。

第四条记录，在第 96 分钟乘坐公交车，由于距离第三条记录中乘坐地铁已超过 45 分钟，所以优惠票已失效，花费 3 元乘坐公交车。

第五条记录，在第 110 分钟花费 5 元乘坐地铁。

第六条记录，在第 135 分钟乘坐公交车，由于此时手中只有第五条记录中乘坐地铁获得的优惠票有效，而本次公交车的票价为 6 元，高于第五条记录中地铁的票价 5 元，所以不能使用优惠票，花费 6 元乘坐公交车。

总共花费 36 元。 

**样例 2 说明**

第一条记录，在第 1 分钟花费 5 元乘坐地铁。

第二条记录，在第 16 分钟花费 20 元乘坐地铁。

第三条记录，在第 23 分钟花费 7 元乘坐地铁。

第四条记录，在第 31 分钟乘坐公交车，此时只有第二条记录中乘坐的地铁票价高于本次公交车票价，所以使用第二条记录中乘坐地铁获得的优惠票。

第五条记录，在第 38 分钟乘坐公交车，此时第一条和第三条记录中乘坐地铁获得的优惠票都可以使用，使用获得最早的优惠票，即第一条记录中乘坐地铁获得的优惠票。

第六条记录，在第 68 分钟乘坐公交车，使用第三条记录中乘坐地铁获得的优惠票。

总共花费 32 元。 


**数据规模与约定**

对于 $30\%$ 的数据，$n \leq 1000$，$t_i \leq 10^6$。

另有 $15\%$ 的数据，$t_i \leq 10^7$，所有 $price_i$ 相等。

另有 $15\%$ 的数据，$t_i \leq 10^9$，所有 $price_i$ 相等。

对于 $100\%$ 的数据，$n \leq 10^5$，$t_i \leq 10^9$，$1 \leq price_i \leq 1000$。

## 样例 #1

### 输入

```
6
0 10 3
1 5 46
0 12 50
1 3 96
0 5 110
1 6 135```

### 输出

```
36```

## 样例 #2

### 输入

```
6
0 5 1
0 20 16
0 7 23
1 18 31
1 4 38
1 7 68 ```

### 输出

```
32```

# AI分析结果



---
# 💡 Kay的C++算法解析：公交换乘 深入学习指南 💡

<introduction>
今天我们来一起分析“公交换乘”这道C++编程题。这道题需要我们模拟地铁和公交的乘车记录，计算总花费，核心在于高效管理地铁优惠票的使用。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟+队列优化 (属于“编程技巧应用”类)

🗣️ **初步分析**：
解决“公交换乘”这道题，关键在于用队列优化模拟过程。简单来说，队列就像一个“先进先出”的小窗口，能帮我们高效管理地铁优惠票的有效期。每次坐地铁时，我们把新获得的优惠票加入队列；坐公交时，先弹出所有过期的票（队列头部），再在剩余的有效票中找最早且价格足够的票使用。

- **题解思路**：所有题解的核心都是模拟，但暴力枚举会超时（O(n²)）。优质题解通过队列优化，将时间复杂度降到O(n)（最多遍历45张票）。例如，用队列维护有效票，坐公交时先清理过期票，再遍历队列找符合条件的票。
- **核心难点**：如何高效管理过期票？如何快速找到最早的有效票？如何避免重复使用票？
- **可视化设计**：用8位像素风格展示队列变化，每个像素块代表一张优惠票（颜色区分价格），时间轴显示当前公交时间。过期票从队列头部“消失”（像素渐暗），找到可用票时高亮并标记为已使用（颜色变灰），同时播放“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，筛选出以下3份优质题解（均≥4星）：
</eval_intro>

**题解一：作者：泥土笨笨 (赞：466)**
* **点评**：此题解思路非常清晰，用数组模拟队列管理优惠票。代码规范（变量名如`head`、`tail`直观），关键步骤有注释。算法上通过队列优化，将时间复杂度从O(n²)降到O(n)（每次最多遍历45张票），是典型的高效模拟。特别是对过期票的处理（`while (head < tail && q[head].time < time) head++`），巧妙利用时间递增的特性，避免重复检查。

**题解二：作者：andyli (赞：14)**
* **点评**：此题解用`vector`存储优惠票，代码简洁。坐公交时遍历`vector`，删除过期票后找符合条件的票，时间复杂度O(45n)。亮点是用`emplace_back`高效添加票，且逻辑直接（找到后立即删除），适合理解队列优化的基础实现。

**题解三：作者：ikunTLE (赞：10)**
* **点评**：此题解用队列优化暴力，通过`front`和`back`指针管理有效票范围。代码虽短但逻辑完整，特别是`back=j`的处理（弹掉过期票），体现了队列的核心思想。适合学习数组模拟队列的技巧。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，主要会遇到以下3个核心难点，结合优质题解的思路，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何高效管理过期的优惠票？**
    * **分析**：由于乘车时间是递增的，过期的票（时间差>45分钟）对后续公交无意义。优质题解用队列头部指针（如`head`）记录当前有效票的起点，每次坐公交时先弹出所有过期票（`while (head < tail && q[head].time < time) head++`），时间复杂度O(1)。
    * 💡 **学习笔记**：利用时间递增性，用队列头部指针快速清理过期票，避免重复检查。

2.  **关键点2：如何快速找到最早的有效票？**
    * **分析**：优惠票需满足“时间差≤45分钟”且“价格≥公交票价”，且优先最早获得的票。优质题解遍历队列（从`head`到`tail`），找到第一个符合条件的票并标记（如`used=1`或直接删除），确保“最早”的要求。
    * 💡 **学习笔记**：队列的顺序天然对应票的获得顺序，遍历队列即可保证优先使用最早的票。

3.  **关键点3：如何避免重复使用优惠票？**
    * **分析**：每张票只能用一次。优质题解通过标记（如`used`数组）或直接删除票（如`vector::erase`）来避免重复使用。例如，泥土笨笨的题解中，找到票后标记`q[j].used=1`，后续遍历会跳过已用票。
    * 💡 **学习笔记**：标记或删除是避免重复使用的关键，根据数据结构选择合适方式（数组用标记，`vector`用删除）。

### ✨ 解题技巧总结
<summary_best_practices>
- **队列优化**：用队列（或数组模拟）管理优惠票，利用时间递增性快速清理过期票。
- **标记与删除**：通过标记（`used`）或直接删除（`erase`）避免重复使用票。
- **时间差判断**：坐公交时，先清理过期票（时间差>45），再处理有效票。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解前，先看一个综合优质题解的通用核心实现，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了泥土笨笨和andyli的思路，用数组模拟队列，清晰展示核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    const int MAXN = 100005;
    struct Ticket {
        int price; // 地铁票价（优惠票面额）
        int time;  // 优惠票过期时间（地铁时间+45）
        bool used; // 是否已使用
    } tickets[MAXN];
    int head = 0, tail = 0; // 队列头尾指针（tail指向待插入位置）
    int total_cost = 0;

    int main() {
        int n;
        cin >> n;
        while (n--) {
            int op, price, t;
            cin >> op >> price >> t;
            if (op == 0) { // 地铁：直接付费，添加优惠票
                total_cost += price;
                tickets[tail++] = {price, t + 45, false};
            } else { // 公交：找有效优惠票
                // 清理过期票（时间差>45）
                while (head < tail && tickets[head].time < t) {
                    head++;
                }
                bool found = false;
                // 遍历有效票，找最早可用的
                for (int i = head; i < tail; ++i) {
                    if (!tickets[i].used && tickets[i].price >= price) {
                        tickets[i].used = true;
                        found = true;
                        break;
                    }
                }
                if (!found) {
                    total_cost += price;
                }
            }
        }
        cout << total_cost << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取乘车记录，地铁直接付费并添加优惠票到队列；公交时先清理过期票（`head`指针后移），再遍历有效票找可用的。用`used`标记避免重复使用，未找到则付费。

---
<code_intro_selected>
接下来剖析3份优质题解的核心代码片段，看它们的亮点和实现思路。
</code_intro_selected>

**题解一：作者：泥土笨笨**
* **亮点**：用数组模拟队列，`head`指针清理过期票，`used`标记避免重复使用，逻辑清晰。
* **核心代码片段**：
    ```cpp
    while (head < tail && q[head].time < time) {
        head++;
    }
    bool found = false;
    for (int j = head; j < tail; ++j) {
        if (q[j].price >= price && q[j].used == 0) {
            found = true;
            q[j].used = 1;
            break;
        }
    }
    if (!found) cost += price;
    ```
* **代码解读**：
    这段代码处理公交的核心逻辑：首先用`while`循环清理过期票（`head`后移），然后遍历有效票（从`head`到`tail`），找到第一个价格足够且未使用的票，标记为已用。若没找到则付费。
    * 为什么从`head`开始？因为`head`前的票已过期，无需检查。
    * 为什么`break`？因为要优先使用最早的票，找到第一个即可。
* 💡 **学习笔记**：用`head`指针快速清理过期票，保证后续遍历只处理有效票，时间复杂度O(1)（清理）+O(45)（遍历），非常高效。

**题解二：作者：andyli**
* **亮点**：用`vector`存储票，坐公交时直接删除过期票，代码简洁。
* **核心代码片段**：
    ```cpp
    for (size_t i = 0; i < tickets.size(); i++) {
        if (t - tickets[i].time > 45) {
            tickets.erase(tickets.begin()), i--;
        } else if (tickets[i].price >= price) {
            tickets.erase(tickets.begin() + i);
            flag = true;
            break;
        }
    }
    ```
* **代码解读**：
    这段代码用`vector`动态管理票：遍历`vector`，若票过期则删除（`erase`），否则检查价格。找到符合条件的票后删除（避免重复使用）。
    * 为什么`i--`？因为删除元素后，后续元素前移，需调整索引。
    * 为什么删除？因为`vector`的顺序即票的获得顺序，删除后后续公交不会重复使用。
* 💡 **学习笔记**：`vector`的`erase`操作虽稍慢，但结合时间限制（最多45次），整体效率仍高，适合理解动态数组的应用。

**题解三：作者：ikunTLE**
* **亮点**：用队列指针`front`和`back`管理有效票范围，代码紧凑。
* **核心代码片段**：
    ```cpp
    for(int j=back;j<=front;++j)
        if(temp.t-q[j].t<=45){
            if(temp.price<=q[j].price){
                q[j].price=0;
                flag=true;
                break;
            }
        }
        else back=j;
    ```
* **代码解读**：
    这段代码中，`back`是有效票的起点，`front`是终点。遍历`back`到`front`，若时间差>45则更新`back`（跳过过期票），否则检查价格。找到后标记票（`price=0`）。
    * 为什么`back=j`？因为`j`之前的票已过期，后续公交无需检查。
    * 为什么标记`price=0`？表示票已使用，后续遍历会跳过。
* 💡 **学习笔记**：用指针范围管理有效票，减少内存操作，适合学习数组模拟队列的技巧。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了更直观地理解优惠票的管理过程，我们设计一个“像素票务中心”动画，用8位风格展示队列的变化和票的使用。
\</visualization\_intro\>

  * **动画演示主题**：像素票务中心——管理地铁优惠票的一天

  * **核心演示内容**：展示队列中优惠票的添加、过期清理、使用过程，突出“最早有效票优先使用”的逻辑。

  * **设计思路简述**：采用8位像素风格（如FC游戏的网格界面），用不同颜色的像素块表示优惠票（红色：高价格，蓝色：低价格）。队列用水平排列的像素块表示，头部在左，尾部在右。坐地铁时添加新票（像素块从右侧滑入），坐公交时清理过期票（左侧像素块渐暗消失），找到可用票时高亮（闪烁）并标记为灰色（已使用），同时播放“叮”的音效。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
          * 屏幕分为两部分：上方是“票务队列”（水平排列的像素块，每个块显示价格和过期时间），下方是“操作面板”（开始/暂停、单步按钮，时间滑块）。
          * 播放8位风格的轻快背景音乐（类似《超级玛丽》的BGM）。

    2.  **地铁操作**（例如样例1第一条记录）：
          * 输入：“0 10 3”（地铁，价格10，时间3）。
          * 动画：队列右侧滑入一个红色像素块（价格10，过期时间3+45=48），总花费增加10（数字弹出显示），播放“滴”的购票音效。

    3.  **公交操作**（例如样例1第二条记录）：
          * 输入：“1 5 46”（公交，价格5，时间46）。
          * 动画：
            - 清理过期票：检查队列头部（时间48≥46？不，48≥46，不过期），无需清理。
            - 遍历队列：从头部开始，第一个票价格10≥5，高亮该像素块（闪烁黄色），标记为灰色（已使用），总花费不增加，播放“叮”的成功音效。

    4.  **过期票清理**（例如样例1第四条记录：“1 3 96”）：
          * 输入：“1 3 96”（公交，时间96）。
          * 动画：
            - 清理过期票：队列头部票的过期时间48<96，像素块渐暗并从左侧消失（`head`指针右移）。
            - 遍历剩余票（第三条地铁票，时间50+45=95<96？95<96，也过期，继续清理），直到队列为空，总花费增加3，播放“嗒”的付费音效。

    5.  **目标达成**：
          * 所有记录处理完毕，总花费显示为36（样例1），播放“胜利”音效（上扬的旋律），队列清空，屏幕显示“总花费计算完成！”。

  * **旁白提示**：
      * （地铁时）“新地铁票加入队列，总花费增加~”
      * （清理过期票时）“这张票过期了，把它移出队列~”
      * （找到可用票时）“找到一张有效票，免费乘车！”
      * （未找到票时）“没有有效票，需要付费乘车哦~”

\<visualization\_conclusion\>
通过这个像素动画，我们能直观看到队列的变化、过期票的清理过程，以及如何找到最早的有效票。这种可视化方式能帮助我们更深刻地理解队列优化的核心逻辑。
\</visualization\_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
理解本题后，我们可以思考队列优化在其他场景的应用，比如需要按时间顺序处理数据的问题。
\</similar\_problems\_intro\>

  * **通用思路/技巧迁移**：
      队列优化适用于需要“先进先出”处理、且存在时间或顺序限制的场景，例如：
      - 餐厅叫号系统（按取号顺序处理）
      - 网络请求队列（先到先处理）
      - 游戏中的技能冷却管理（按释放时间清理冷却完毕的技能）

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1090 合并果子**  
        * 🗣️ **推荐理由**：用优先队列（小根堆）优化合并过程，练习队列在贪心算法中的应用。
    2.  **洛谷 P1160 队列安排**  
        * 🗣️ **推荐理由**：用链表模拟队列的插入和删除，练习动态数据结构的管理。
    3.  **洛谷 P1873 砍树**  
        * 🗣️ **推荐理由**：用双端队列维护滑动窗口最大值，练习队列在区间查询中的优化。

-----

## 7\. 学习心得与经验分享 (若有)

\<insights\_intro\>
部分题解作者分享了调试经验，例如__gcd提到“在考场上因`mini`初值设小导致60分”，这对我们很有启发。
\</insights\_intro\>

> **参考经验 (来自 __gcd)**：“我在考场上把这道题`mini`的初值设小了，导致只有60分qwq”
>
> **点评**：这位作者的经历提醒我们，变量初始化非常重要！特别是在处理最小值/最大值时，初值应设为足够大/小（如`1e18`），避免边界错误。这是编程中常见的细节问题，需要特别注意。

-----

\<conclusion\>
本次关于“公交换乘”的C++解题分析就到这里。通过理解队列优化的核心思想、学习优质题解的代码技巧，以及观看像素动画演示，相信大家对这类模拟题有了更深刻的认识。记住，多动手编写和调试代码，才能真正掌握算法的精髓！下次再见~ 💪
\</conclusion\>

---
处理用时：161.18秒
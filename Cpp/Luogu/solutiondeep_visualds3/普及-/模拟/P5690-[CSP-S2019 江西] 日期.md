# 题目信息

# [CSP-S2019 江西] 日期

## 题目背景

CSP-SJX2019 T1

## 题目描述

Alice 在纸上写下了一个日期，形式为 $\text{MM-DD}$，其中 $\text{MM}$ 与 $\text{DD}$ 都是两位数字，分别表示月和天，然而这个日期并不一定存在。 Alice 找来了 Bob 要他更改若干位上的数字，使得这个日期存在。请你帮 Bob 算算他最少需要更改几位数字。

本题中我们认为 $2$ 月固定为 $28$ 天。

## 说明/提示

【输入输出样例 1 说明】

更改方式不止一种，其中一种方式是改为： $\text{03-22}$。

【输入输出样例 2 说明】

一种更改方式为：$\text{02-09}$。

【输入输出样例 3 说明】

一种更改方式为：$\text{07-09}$。

【数据规模与约定】
对于 $100\%$ 的数据：$\text{MM}$ 与 $\text{DD}$ 一定为 $4$ 个数字。

**update: 2024/07/04 增加 hack 一组。**

## 样例 #1

### 输入

```
03-32```

### 输出

```
1```

## 样例 #2

### 输入

```
02-39```

### 输出

```
1```

## 样例 #3

### 输入

```
67-89```

### 输出

```
2```

# AI分析结果



---
# 💡 Kay的C++算法解析：日期 深入学习指南 💡

<introduction>
今天我们来一起分析“日期”这道C++编程题。这道题需要我们找到将给定的非法日期（MM-DD格式）修改为合法日期所需的最少修改位数。本指南将帮助大家理解核心思路，掌握关键算法，并通过可视化演示直观感受解题过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举法` (核心思想：通过遍历所有可能的合法日期，计算与输入日期的差异位数，取最小值)

🗣️ **初步分析**：
解决这道题的关键在于“枚举所有合法日期”。枚举法就像“大海捞针”，但这里的“大海”很小——一年最多365天，所以我们可以把所有合法的MM-DD格式日期都列出来，逐个比较输入日期需要修改几位数字，最终找到最小的那个数。

- **题解思路对比**：题解主要分为两类：一类是暴力枚举所有合法日期（如吾皇、Eason_AC等），另一类是分类讨论不同情况（如LRY314）。枚举法更直观，不容易遗漏边界情况；分类讨论需要考虑月份和天数的多种组合，逻辑复杂但效率更高。
- **核心算法流程**：首先预处理所有合法日期（1-12月的所有有效天数，格式化为MM-DD），然后遍历每个合法日期，计算输入日期与它的每一位差异，记录最小差异数。
- **可视化设计**：采用8位像素风格动画，用彩色方块表示日期的每一位（MM的十位、个位，DD的十位、个位）。动画中会逐个展示合法日期，高亮输入日期与当前合法日期不同的位，并用“叮”的音效提示差异。最终找到最小差异时，播放胜利音效并放大显示结果。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性的评估，以下题解因逻辑直观、代码简洁被选为优质题解（≥4星）：
</eval_intro>

**题解一：作者吾皇（赞45）**
* **点评**：此题解直接枚举所有合法日期，思路简单易懂。代码通过预处理所有合法日期（如01-01、01-02…12-31），然后逐个比较输入日期与每个合法日期的差异位数，最终取最小值。代码结构清晰，变量命名直观（如`month`数组存储各月天数，`p`数组存储所有合法日期字符串），适合初学者理解枚举法的核心思想。

**题解二：作者Eason_AC（赞10）**
* **点评**：此题解同样采用枚举法，但代码更简洁。通过双重循环枚举月份和天数，直接计算输入日期与每个合法日期的差异位数（比较十位和个位是否相同），避免了字符串处理，效率更高。变量命名如`a1`（输入月份十位）、`m1`（合法月份十位）等，明确表达了变量含义，是竞赛代码的典型风格。

**题解三：作者qhr2023（赞1）**
* **点评**：此题解用更精简的代码实现了枚举逻辑。通过`(m%10!=i%10)`等表达式直接计算差异位数，省去了字符串转换步骤，代码行数少但逻辑清晰。适合学习如何用数学运算替代字符串处理，提升代码效率。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们常遇到以下关键点，掌握这些能帮我们快速解题：
</difficulty_intro>

1.  **关键点1：如何枚举所有合法日期？**
    * **分析**：合法日期的月份是1-12，天数需符合各月的最大值（如2月28天，4月30天等）。需要用数组存储各月天数（如`month[13] = {0,31,28,...}`），然后双重循环枚举所有可能的（月份，天数）组合。
    * 💡 **学习笔记**：预处理各月天数数组是枚举的基础，确保不漏掉任何合法日期。

2.  **关键点2：如何计算修改位数？**
    * **分析**：输入日期和合法日期均为MM-DD格式（如输入03-32，合法日期03-22），需比较每一位（MM十位、MM个位、DD十位、DD个位）是否相同。不同的位数之和即为修改次数。
    * 💡 **学习笔记**：用数学运算（如`m/10`取十位，`m%10`取个位）比字符串处理更高效。

3.  **关键点3：如何处理边界情况？**
    * **分析**：如输入月份为0或>12，天数为0或超过对应月份最大值。枚举法天然覆盖这些情况，因为合法日期中不会包含这些情况，所以差异位数会自动计算。
    * 💡 **学习笔记**：枚举法的优势在于无需单独处理边界，所有情况都被“枚举覆盖”。

### ✨ 解题技巧总结
<summary_best_practices>
- **预处理合法日期**：用数组存储各月天数，避免重复计算。
- **数学运算替代字符串处理**：通过取模和除法分离十位、个位，提升效率。
- **初始化最小值为较大值**：如`ans=10`（最多4位不同），确保能正确更新最小值。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择枚举法作为通用解法，因为它逻辑直观、不易出错。以下是综合多个优质题解的核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了吾皇和Eason_AC的思路，通过枚举所有合法日期，计算输入日期与每个合法日期的差异位数，取最小值。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int month_days[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 各月天数（索引0无意义）

    int main() {
        int input_month, input_day;
        scanf("%d-%d", &input_month, &input_day); // 读取输入，如03-32会被解析为month=3, day=32

        int min_changes = 4; // 最多修改4位（MM和DD各两位）

        // 枚举所有合法日期（月份1-12，天数1-对应月的天数）
        for (int m = 1; m <= 12; ++m) {
            for (int d = 1; d <= month_days[m]; ++d) {
                // 计算输入日期与当前合法日期的差异位数
                int changes = 0;
                // 比较月份的十位和个位
                changes += (input_month / 10 != m / 10); // 十位不同？
                changes += (input_month % 10 != m % 10); // 个位不同？
                // 比较天数的十位和个位
                changes += (input_day / 10 != d / 10);
                changes += (input_day % 10 != d % 10);

                // 更新最小修改次数
                if (changes < min_changes) {
                    min_changes = changes;
                }
            }
        }

        printf("%d\n", min_changes);
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入的月份和天数，然后通过双重循环枚举所有合法的（月份，天数）组合。对于每个合法日期，计算输入日期与它的每一位差异（十位和个位），累加得到修改次数。最终输出最小的修改次数。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者吾皇**
* **亮点**：通过字符串处理直接比较输入日期与合法日期的每一位，适合理解日期格式的处理。
* **核心代码片段**：
    ```cpp
    string s,p[366];
    int main() {
        cin>>s;
        for(int i=1; i<=12; i++)
            for(int j=1;j<=month[i];j++) p[++top]=zh(i)+'-'+zh(j);
        for(int i=1;i<=365;i++){
            sum=0;
            for(int j=0;j<5;j++) if(p[i][j]!=s[j]) sum++;
            ans=min(ans,sum);
        }
        printf("%d",ans);
    }
    ```
* **代码解读**：
    `zh(i)`函数将数字转换为两位字符串（如1→"01"）。`p`数组存储所有合法日期字符串（如"01-01"）。然后遍历`p`数组，比较输入字符串`s`与每个合法日期字符串的每一位，统计不同位数（`sum`），取最小值（`ans`）。
* 💡 **学习笔记**：字符串比较直观，但需注意补0（如月份1需存为"01"），否则会导致位数不匹配。

**题解二：作者Eason_AC**
* **亮点**：用数学运算直接比较十位和个位，避免字符串处理，代码更高效。
* **核心代码片段**：
    ```cpp
    F(int, m, 1, 12) F(int, d, 1, month[m]) {
        int a1 = a / 10, a2 = a % 10, b1 = b / 10, b2 = b % 10;
        int m1 = m / 10, m2 = m % 10, d1 = d / 10, d2 = d % 10;
        ans = min(ans, (a1 != m1) + (a2 != m2) + (b1 != d1) + (b2 != d2));
    }
    ```
* **代码解读**：
    `a`和`b`是输入的月份和天数。`a1`是月份的十位（如输入03→a=3→a1=0），`m1`是合法月份的十位（如m=3→m1=0）。通过比较`a1`与`m1`是否相等（相等则不计入修改次数），同理处理个位和天数，最终累加得到修改次数。
* 💡 **学习笔记**：数学运算（取模和除法）比字符串处理更高效，适合竞赛中的时间限制。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解枚举过程，我们设计了一个“像素日期探险家”动画，用8位复古风格展示枚举所有合法日期并计算最小修改次数的过程。
</visualization_intro>

  * **动画演示主题**：`像素日期大冒险——寻找最少修改的合法日期`

  * **核心演示内容**：
    输入日期（如03-32）显示在屏幕上方，下方是一个8位像素风格的日历网格，每个格子代表一个合法日期（如01-01、01-02…12-31）。动画会逐个“点亮”这些格子，同时显示输入日期与当前格子日期的差异位数（用红色数字标记不同的位），最终找到差异最小的格子，播放胜利音效。

  * **设计思路简述**：
    8位像素风格（如FC游戏画面）降低学习压力；逐个点亮合法日期的动画模拟枚举过程；红色高亮差异位帮助理解“修改位数”的计算逻辑；胜利音效增强成就感。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 背景为浅灰色像素网格，顶部显示输入日期（如“03-32”），下方排列365个小格子（每行31个，共12行，对应1-12月）。
        - 控制面板包含“单步”“自动播放”“调速”按钮，初始状态为暂停。

    2.  **开始枚举**：
        - 点击“自动播放”，动画从1月1日（01-01）开始，每个格子依次高亮（绿色闪烁），同时屏幕右侧显示当前日期（如“当前检查：01-01”）。
        - 输入日期与当前日期的每一位比较：相同位用绿色显示，不同位用红色闪烁，并在屏幕上方显示差异位数（如“差异：2”）。

    3.  **关键操作提示**：
        - 当遇到差异位数更小的日期时（如从差异2变为1），播放“叮”的音效，并用黄色闪光标记该格子。
        - 最终找到最小差异时（如差异1），该格子放大并播放胜利音效（如8位风格的“啦~啦~”），屏幕中央显示“找到最少修改！需要1次”。

    4.  **交互控制**：
        - 单步模式：点击“下一步”，逐个检查日期；点击“上一步”，回退到前一个日期。
        - 调速滑块：可调整播放速度（0.5倍速到2倍速），适合仔细观察。

  * **旁白提示**：
    - “现在检查的是1月1日，输入日期03-32与它的差异是：月份十位0 vs 0（相同），个位3 vs 1（不同），天数十位3 vs 0（不同），个位2 vs 1（不同）。总差异4位。”
    - “发现更小差异！当前检查的是3月22日，差异1位（天数十位3→2），这可能是当前最优解。”

<visualization_conclusion>
通过这个动画，我们能直观看到枚举法如何“遍历所有可能”，并找到最少修改次数。像素风格和音效让学习过程更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
枚举法在日期问题中非常实用，还可以解决以下类型的问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 枚举所有可能的候选解（如合法日期、合法时间等），计算与目标的差异，取最优解。
    - 适用于候选解数量有限的问题（如年、月、日的组合，电话号码的可能值等）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1328 生活大爆炸版石头剪刀布**  
        * 🗣️ **推荐理由**：通过枚举所有可能的出拳组合，计算得分，巩固枚举法的应用。
    2.  **洛谷 P1554 梦中的统计**  
        * 🗣️ **推荐理由**：枚举区间内的所有数字，统计各位数字的出现次数，练习枚举与数位处理。
    3.  **洛谷 P1088 火星人**  
        * 🗣️ **推荐理由**：枚举所有可能的排列，找到下一个排列，提升枚举复杂情况的能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自作者Cure_Wing)**：“以前尝试过直接判断月份和日期是否合法，但提交后WA了。例如输入44-31，正确输出2，但直接判断会认为月份不合法（+1）、日期合法（不加），总次数1，导致错误。这让我意识到，日期是否合法依赖于月份，不能分开判断。”

> **点评**：这位作者的经验提醒我们，日期和月份是相互依赖的（如4月没有31天），必须结合具体月份判断天数是否合法。枚举法通过遍历所有合法组合，天然避免了这种错误，是更可靠的选择。

-----

<conclusion>
本次关于“日期”的C++解题分析就到这里。通过枚举法，我们可以高效解决这类问题，而可视化动画能帮助我们更直观地理解枚举过程。希望大家通过练习，掌握枚举法的核心思想，举一反三解决更多问题！💪
</conclusion>

---
处理用时：151.33秒
# 题目信息

# 【深基4.习9】打分

## 题目描述

现在有 $n(n \le 1000)$ 位评委给选手打分，分值从 $0$ 到 $10$。需要去掉一个最高分，去掉一个最低分（如果有多个最高或者最低分，也只需要去掉一个），剩下的评分的平均数就是这位选手的得分。现在输入评委人数和他们的打分，请输出选手的最后得分，精确到 $2$ 位小数。 

## 说明/提示

数据保证，$3 \leq n \leq 1000$，每个评委打出的分值为为 $0$ 到 $10$（含 $0$ 与 $10$）之间的整数。

## 样例 #1

### 输入

```
5
9 5 6 8 9```

### 输出

```
7.67```

# AI分析结果



---
# 💡 Kay的C++算法解析：【深基4.习9】打分 深入学习指南 💡

<introduction>
今天我们来一起分析“【深基4.习9】打分”这道C++编程题。这道题看似简单，但涉及数据处理的核心步骤，比如找极值、求和、计算平均值。本指南将帮助大家梳理思路，掌握关键技巧，并用有趣的像素动画演示算法过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟应用 (属于“模拟”类算法，即按步骤模拟问题的处理流程)

🗣️ **初步分析**：
> 解决这道题的核心是“模拟评分处理流程”：先找到所有评分中的最大值和最小值，去掉各一个后，计算剩余评分的平均值。模拟类问题的关键是“按步骤复现问题要求”，就像按菜谱做菜——每一步都要准确。  
> 题解主要有两种思路：  
> 1. **排序法**：将评分排序后，直接去掉首尾（即最大和最小），求和中间部分；  
> 2. **遍历法**：一次遍历同时记录总和、最大值、最小值，最后调整总和。  
> 两种方法都能解决问题，但遍历法时间复杂度更低（O(n) vs O(n log n)），更高效。核心难点是正确处理极值（即使有多个相同极值，也只去掉一个）和数据类型（确保除法后保留两位小数）。  
> 可视化设计会用像素方块代表每个评分，高亮最大值和最小值（比如红色和蓝色），然后“移除”它们（变灰），剩余方块移动到一起求和，最后显示平均值。动画中会有“叮”的音效提示极值被找到，“唰”的音效提示移除操作。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法效率等维度筛选了3份优质题解（≥4星），它们各有亮点，值得学习：
</eval_intro>

**题解一：作者Lithium_Chestnut**  
* **点评**：这份题解用排序法直接明了。代码简洁，变量`ans`直接表示总和，排序后跳过首尾元素求和。虽然排序的时间复杂度略高（O(n log n)），但代码易读，适合刚学排序的同学理解。特别适合练习STL的`sort`函数使用。

**题解二：作者C171501**  
* **点评**：此题解用遍历法更高效（O(n)）。一次循环同时记录总和、最大值、最小值，避免了排序的开销。变量命名`maxn`（最大值）、`minn`（最小值）、`sum`（总和）清晰易懂，边界处理（如初始值设为极大极小）严谨，是竞赛中常用的优化思路。

**题解三：作者Lylighte**  
* **点评**：此题解提供了排序和遍历两种方法，解释详细。特别是对最大值和最小值初始化的说明（“假设第一个元素是极值”），帮助学习者理解如何正确初始化变量。代码中使用`fixed`和`setprecision`控制输出格式，是处理浮点数输出的关键技巧。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们需要重点关注以下3个关键点，掌握它们就能轻松应对类似问题：
</difficulty_intro>

1.  **关键点1**：如何正确找到最大值和最小值？  
    * **分析**：初始化时，最大值应设为极小值（如-1），最小值设为极大值（如11），这样第一个输入的分数就能更新它们。例如，若初始最大值是0，而输入有10分，就会漏掉最大值。优质题解（如C171501）用`maxn=0`（因分数≥0）或`minn=999999999`（足够大），确保所有输入都能正确更新极值。  
    * 💡 **学习笔记**：极值初始化要“反着来”——找最大值初始设极小，找最小值初始设极大。

2.  **关键点2**：如何计算总和并调整？  
    * **分析**：总和需要先累加所有分数，再减去最大值和最小值。注意：即使有多个相同的极值（如两个9分），也只减一次！例如，输入`[9,5,6,8,9]`，最大值是9（有两个），但只减一个。优质题解（如Lylighte）通过一次遍历累加总和，同时记录极值，确保调整正确。  
    * 💡 **学习笔记**：总和调整时，只减一个最大值和一个最小值，不管它们出现多少次。

3.  **关键点3**：如何保留两位小数？  
    * **分析**：C++中用`printf("%.2lf", ...)`或`cout << fixed << setprecision(2)`。需要注意数据类型：若总和是整数，除以`n-2`（整数）会得到整数，需转换为`double`（如`(double)(sum - max - min)/(n-2)`）。优质题解（如AveMarina）用`p-2.0`强制转换为浮点数，避免整除问题。  
    * 💡 **学习笔记**：除法前确保至少有一个操作数是浮点数，否则会得到整数结果！

### ✨ 解题技巧总结
<summary_best_practices>
- **一次遍历法**：同时计算总和、最大值、最小值，时间复杂度O(n)，适合大数据量。  
- **排序法**：代码简洁，适合练习排序函数，但时间复杂度O(n log n)。  
- **输出格式化**：用`printf`或`cout`的`fixed`+`setprecision`控制小数位数，避免精度丢失。  
- **变量初始化**：极值变量初始值要足够“极端”，确保能被输入数据覆盖。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，选择最高效的“一次遍历法”作为通用核心实现，它时间复杂度低且代码清晰。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了C171501和Lylighte的遍历法思路，一次循环完成总和、极值记录，时间复杂度O(n)，适合n较大的情况。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm> // 用于max/min函数（可选，也可手动比较）
using namespace std;

int main() {
    int n;
    cin >> n;
    double sum = 0, max_val = -1, min_val = 11; // 初始化极值（分数范围0-10）
    for (int i = 0; i < n; ++i) {
        double score;
        cin >> score;
        sum += score;
        max_val = max(max_val, score); // 更新最大值
        min_val = min(min_val, score); // 更新最小值
    }
    double average = (sum - max_val - min_val) / (n - 2);
    printf("%.2lf\n", average); // 保留两位小数
    return 0;
}
```
* **代码解读概要**：  
  代码首先读取评委人数`n`，然后初始化总和`sum`、最大值`max_val`（初始-1，确保第一个分数能更新它）、最小值`min_val`（初始11，同理）。通过循环读取每个分数，累加总和并更新极值。最后用总和减去极值，除以`n-2`（去掉两个分数），输出两位小数的平均值。

---
<code_intro_selected>
接下来赏析优质题解的核心片段，学习不同思路的巧妙之处：
</code_intro_selected>

**题解一：作者Lithium_Chestnut（排序法）**  
* **亮点**：利用STL的`sort`函数快速排序，代码简洁，适合理解排序后处理极值的逻辑。  
* **核心代码片段**：
```cpp
sort(a+1,a+n+1); // 排序数组（a[1]到a[n]）
for(int i=2;i<=n-1;i++) ans+=a[i]; // 跳过首尾（极值）求和
printf("%.2lf",ans/(n-2));
```
* **代码解读**：  
  `sort(a+1,a+n+1)`将数组从第2个元素到第n个元素排序（假设数组从1开始），排序后`a[1]`是最小值，`a[n]`是最大值。循环从第2个到第n-1个元素求和，最后除以`n-2`得到平均值。  
  为什么跳过首尾？因为排序后首尾分别是最小和最大值，各去掉一个。  
* 💡 **学习笔记**：排序后数组的首尾是极值，直接跳过求和是直观的方法，但排序会增加时间复杂度。

**题解二：作者C171501（遍历法）**  
* **亮点**：一次循环完成所有计算，时间复杂度O(n)，效率更高。  
* **核心代码片段**：
```cpp
for(int i=1;i<=n;++i){
    cin>>m;
    maxn=max(maxn,m);
    minn=min(minn,m);
    sum+=m;
}
sum-=maxn;
sum-=minn;
printf("%.2f",sum/(n-2));
```
* **代码解读**：  
  循环中每次读取分数`m`，用`max`和`min`函数更新当前最大值`maxn`和最小值`minn`，同时累加总和`sum`。循环结束后，总和减去极值，除以`n-2`得到平均值。  
  为什么初始`minn=999999999`？因为分数最大是10，初始设为极大值，确保第一个分数能更新它。  
* 💡 **学习笔记**：一次遍历法避免了排序，适合处理大数据量的情况。

**题解三：作者Lylighte（双方法对比）**  
* **亮点**：同时展示排序法和遍历法，帮助学习者理解不同思路的优劣。  
* **核心代码片段（遍历法部分）**：
```cpp
tot = maxn = minn = score[1]; // 初始化总和、极值为第一个分数
for(int i=2; i<=n; i++){
    if(score[i]>maxn) maxn = score[i];
    if(score[i]<minn) minn = score[i];
    tot += score[i];
}
cout << fixed << setprecision(2) << double(tot-maxn-minn)/(n-2) << endl;
```
* **代码解读**：  
  初始化时将总和、最大值、最小值都设为第一个分数，然后从第二个分数开始循环。每次比较更新极值，并累加总和。最后用`double`转换确保除法结果为浮点数，`fixed`和`setprecision(2)`控制输出两位小数。  
  为什么初始化用第一个分数？因为至少有3个分数（题目保证n≥3），第一个分数一定存在，避免初始值设置错误。  
* 💡 **学习笔记**：初始化极值时，若已知输入非空，可以用第一个元素作为初始值，更安全。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“找极值→去极值→算平均”的过程，我设计了一个“像素评分小剧场”动画，用8位复古风格展示每一步！
</visualization_intro>

  * **动画演示主题**：`像素评委打分记`  
  * **核心演示内容**：用像素方块代表每个评分（如绿色方块），动画展示如何找到最大（红色方块）和最小（蓝色方块）评分，然后将它们“移除”（变灰），剩余方块合并求和，最后弹出平均值（黄色数字）。  

  * **设计思路简述**：  
    8位像素风（类似FC游戏）让学习更轻松；极值高亮（红/蓝）和移除动画（变灰+下移）强化关键步骤；音效（“叮”提示找到极值，“唰”提示移除）帮助记忆操作；自动播放模式像“游戏剧情”，单步模式可暂停观察细节。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化 (8位像素风)**：  
        - 背景是像素化的“评分大厅”，顶部显示“评委打分”标题，下方有n个绿色像素方块（每个方块上标有分数，如“9”“5”）。  
        - 控制面板有“开始”“单步”“重置”按钮，速度滑块（0.5x-2x），右侧显示当前步骤说明（如“寻找最大值”）。  
        - 播放8位风格的轻快BGM（类似《超级玛丽》的简单旋律）。

    2.  **寻找极值 (关键步骤)**：  
        - 初始时，所有方块静止。点击“开始”，一个像素箭头（黄色）从第一个方块开始移动。  
        - 箭头指向第一个方块时，弹出文字“当前最大值：9，最小值：9”（假设第一个分数是9）。  
        - 箭头移到第二个方块（5），比较后弹出“5比当前最小值9小，更新最小值为5”，最小值方块变蓝。  
        - 箭头继续移动，每到一个方块就比较并更新极值，同时播放“叮”的音效（类似《吃金币》音效）。  

    3.  **移除极值 (视觉反馈)**：  
        - 找到所有极值后，最大值方块（红色）和最小值方块（蓝色）开始闪烁（2次/秒），伴随“滴滴”提示音。  
        - 点击“单步”或自动播放，红、蓝方块向下移动（像素化的“下沉”动画），颜色变灰（表示被移除），同时弹出文字“去掉一个最高分和一个最低分”。  

    4.  **计算平均值 (结果展示)**：  
        - 剩余绿色方块自动向中间移动，合并成一个大的“总和”方块（标有总和值，如“9+6+8=23”）。  
        - 总和方块下方弹出“评委数-2=3”，然后总和除以3，结果（7.67）以黄色大字体弹出，伴随“胜利”音效（上扬的“叮～”）。  

    5.  **交互控制**：  
        - 学习者可拖动速度滑块，让动画变慢（0.5x）或变快（2x），方便观察细节。  
        - 点击“单步”可逐帧查看极值寻找、移除、求和的过程，适合仔细分析。  

  * **旁白提示**：  
    - （箭头移动时）“看，箭头在比较每个分数，找到最大的和最小的！”  
    - （极值闪烁时）“这两个是最高分和最低分，我们要去掉它们～”  
    - （结果弹出时）“剩下的分数加起来除以3，就是最终得分7.67！”

<visualization_conclusion>
通过这个像素动画，我们能“看”到算法的每一步，就像玩游戏一样轻松理解如何处理评分！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是“找极值+求和+计算平均”，类似的问题在编程中很常见，比如统计班级成绩、比赛评分等。掌握这些技巧后，我们可以挑战更多变形问题！
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 统计数据时，常需要“去极值”（如比赛评分、实验数据处理）。  
    - 计算平均值时，注意数据类型转换（避免整数除法）。  
    - 一次遍历法可同时记录多个关键值（如总和、极值），提升效率。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5738** - `【深基5.例5】旗鼓相当的对手`  
        * 🗣️ **推荐理由**：需要统计多个数据（分数、小分），并比较极值，巩固“找极值+求和”的应用。  
    2.  **洛谷 P1423** - `小玉在游泳`  
        * 🗣️ **推荐理由**：计算累加和并判断停止条件，练习循环和条件判断，与本题的“求和”逻辑相关。  
    3.  **洛谷 P2181** - `对角线`  
        * 🗣️ **推荐理由**：虽然是数学题，但需要计算大数的和并处理溢出，练习数据类型选择（如`long long`），与本题的“总和计算”有共通点。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中Lylighte提到“想起当年被找最大数/最小数支配的恐惧”，这提醒我们初始化极值时要特别小心！
</insights_intro>

> **参考经验 (来自Lylighte)**：“初始化最大值和最小值时，假设第一个元素是极值，循环时再逐个比较更新。这样就不会漏掉任何一个分数啦！”  
> **点评**：Lylighte的经验很实用！初始化极值时，若输入非空（本题n≥3），用第一个元素作为初始值更安全，避免设置“极端值”（如999999）时可能的错误。这提示我们：代码初始化要结合题目条件，灵活处理。

-----

<conclusion>
通过分析“【深基4.习9】打分”这道题，我们掌握了找极值、求和、计算平均的核心技巧，还通过像素动画直观理解了算法过程。记住：多练习、多思考，编程会越来越有趣！下次见～ 💪
</conclusion>

-----

---
处理用时：168.33秒
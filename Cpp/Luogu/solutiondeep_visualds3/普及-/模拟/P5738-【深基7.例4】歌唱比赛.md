# 题目信息

# 【深基7.例4】歌唱比赛

## 题目描述

$n(n\le 100)$ 名同学参加歌唱比赛，并接受 $m(m\le 20)$ 名评委的评分，评分范围是 $0$ 到 $10$ 分。这名同学的得分就是这些评委给分中去掉一个最高分，去掉一个最低分，剩下 $m-2$ 个评分的平均数。请问得分最高的同学分数是多少？评分保留 $2$ 位小数。

## 样例 #1

### 输入

```
7 6
4 7 2 6 10 7
0 5 0 10 3 10
2 6 8 4 3 6
6 3 6 7 5 8
5 9 3 3 8 1
5 9 9 3 2 0
5 8 0 4 1 10
```

### 输出

```
6.00```

# AI分析结果



---
# 💡 Kay的C++算法解析：【深基7.例4】歌唱比赛 深入学习指南 💡

<introduction>
今天我们来一起分析“【深基7.例4】歌唱比赛”这道C++编程题。这道题主要考察我们如何处理多组数据、计算平均值并找出最大值。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟应用`

🗣️ **初步分析**：
解决“歌唱比赛”这道题，关键在于模拟每个同学的评分处理过程。简单来说，“模拟”就是按照题目要求，一步步复现问题中的操作——就像你亲自当裁判，给每个同学的评分“去掉一个最高分、去掉一个最低分”，再算平均分。在本题中，模拟的核心是：对每个同学的m个评分，先找到最大值和最小值（或排序后跳过首尾），再计算剩余评分的平均值，最后比较所有同学的平均分，找出最大的那个。

- 题解思路对比：不同题解主要差异在于“如何找到最值”：有的通过排序（如dream_chen），有的直接遍历记录最值（如封禁用户）。后者更高效（时间复杂度O(m) vs O(m log m)），但两种方法都能解决问题。核心难点是正确处理每个同学的评分（避免遗漏或重复）和浮点数精度控制。
- 核心算法流程可视化设计：动画中将每个同学的评分用像素方块排列展示，排序时方块按数值从小到大滑动；直接找最值时，最大值和最小值方块会闪烁变红/蓝，然后被“擦掉”（去掉），剩余方块相加后显示总和，再除以(m-2)得到平均分。
- 复古游戏化设计：采用8位像素风格，评委用小像素人表示，评分用数字方块弹出；关键操作（如找到最值、计算平均分）伴随“叮”的音效；每处理完一个同学，屏幕弹出“下一位选手”的像素文字，最终找到最高分同学时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等几个方面，筛选了以下评分较高（≥4星）的题解。
</eval_intro>

**题解一：作者：封禁用户 (赞：41)**
* **点评**：此题解思路非常巧妙——不需要排序，而是在输入评分时直接记录最大值和最小值，同时累加总分。这样避免了排序的时间开销（时间复杂度从O(m log m)降到O(m)），尤其适合m较大的场景。代码变量名（如`minn`、`maxx`）简洁易懂，边界处理（如初始化`minn`为1e9，`maxx`为默认值）严谨。从实践角度看，这种方法更高效，适合竞赛中节省时间，是非常值得学习的优化思路。

**题解二：作者：警策看取 (赞：25)**
* **点评**：此题解将“计算单个同学平均分”的逻辑封装成函数`perpeople()`，代码结构清晰，模块化程度高。这种“功能封装”的思想能大大提高代码的可读性和复用性，尤其在处理复杂问题时优势明显。函数内部通过遍历输入评分，同时累加总分、记录最值，逻辑简洁直接。输出时使用`setprecision(2)`保留两位小数，符合题目要求。

**题解三：作者：Thomas_Cat (赞：52)**
* **点评**：此题解思路直白，使用排序后去掉首尾元素的方法，符合直觉（“排序后首尾就是最值”）。代码中变量`tmp`数组存储当前同学的评分，`sum`累加总分，逻辑清晰。虽然排序的时间复杂度略高，但对于题目中m≤20的限制（m log m最多约20*4=80次操作），实际运行时间几乎无差异，适合新手理解“排序找最值”的方法。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何高效找到每个同学的最高分和最低分？**
    * **分析**：可以选择直接遍历评分（输入时同时记录最值）或排序后取首尾。直接遍历的时间复杂度为O(m)，排序的时间复杂度为O(m log m)。由于题目中m≤20，两者差异不大，但直接遍历更高效。例如，封禁用户的题解在输入每个评分时，用`minn=min(x, minn)`和`maxx=max(x, maxx)`实时更新最值，避免了额外的排序步骤。
    * 💡 **学习笔记**：当需要找最值时，直接遍历可能比排序更高效，尤其是在数据量较小时。

2.  **关键点2：如何正确计算平均分并保留两位小数？**
    * **分析**：需要注意两点：一是总分要减去最高分和最低分（`sum - maxx - minn`），二是除以(m-2)时要确保是浮点数除法（如用`1.0*(m-2)`）。例如，Thomas_Cat的题解中`sum/=(m-2)`，但需注意若m-2是整数，直接相除可能导致精度丢失，因此最好写成`sum/(m-2.0)`。
    * 💡 **学习笔记**：浮点数计算时，确保分母是浮点数类型，避免整数除法截断。

3.  **关键点3：如何初始化变量以避免错误？**
    * **分析**：每个同学处理前，总分、最大值、最小值都需要重置。例如，封禁用户的题解在每次循环开始前将`ans=0`，`minn=1e9`（初始化为一个很大的数），`maxx`初始化为默认值（因输入评分≥0，初始化为-1即可）。若不重置，前一个同学的数据会影响当前同学的计算。
    * 💡 **学习笔记**：多组数据处理时，每个循环开始前务必重置临时变量。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题及类似问题的分析，我总结了以下一些通用的解题技巧：
</summary_best_practices>
-   **问题分解**：将“处理n个同学”的大问题分解为“处理1个同学”的小问题，逐个解决。
-   **实时记录关键值**：在输入数据的同时记录最值或累加总分，减少重复遍历次数。
-   **模块化代码**：将重复的操作（如计算单个同学的平均分）封装成函数，提高代码可读性。
-   **边界初始化**：多组数据处理时，每个循环开始前重置临时变量（如总分、最值），避免前一次计算的影响。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了封禁用户和警策看取的题解思路，采用直接遍历记录最值的方法，避免排序，同时通过函数封装提高可读性。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm> // 用于min和max函数
    using namespace std;

    double calculateAverage(int m) {
        double sum = 0.0;
        double maxScore = -1.0; // 评分范围是0-10，初始化为-1确保会被更新
        double minScore = 11.0; // 初始化为11（大于10），确保会被更新
        for (int i = 0; i < m; ++i) {
            double score;
            cin >> score;
            sum += score;
            maxScore = max(maxScore, score);
            minScore = min(minScore, score);
        }
        sum -= maxScore + minScore; // 去掉最值
        return sum / (m - 2.0); // 浮点数除法
    }

    int main() {
        int n, m;
        cin >> n >> m;
        double maxAverage = -1.0; // 初始化为最小值
        for (int i = 0; i < n; ++i) {
            double currentAverage = calculateAverage(m);
            if (currentAverage > maxAverage) {
                maxAverage = currentAverage;
            }
        }
        printf("%.2f\n", maxAverage); // 保留两位小数输出
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取n和m，然后对每个同学调用`calculateAverage(m)`函数计算平均分。函数内部遍历输入的m个评分，累加总分并记录最值，最后减去最值计算平均分。主函数中比较所有同学的平均分，保留最大的那个，最终输出两位小数的结果。核心逻辑集中在`calculateAverage`函数中，通过实时记录最值避免了排序，提高了效率。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者：封禁用户 (赞：41)**
* **亮点**：无需排序，直接在输入时记录最值，时间复杂度更低（O(m)）。
* **核心代码片段**：
    ```cpp
    for(int i=1; i<=n; ++i) {
        for(int j=1; j<=m; ++j) 
            cin>>x, ans+=x, minn=min(x, minn), maxx=max(maxx, x);
        ans=ans-minn-maxx;
        ans=1.0*ans/(1.0*(m-2));
        if(ans>q) q=ans;
        ans=0; minn=1e9; // 重置变量
    }
    ```
* **代码解读**：
    > 这段代码的核心是内层循环（`j`循环）。每输入一个评分`x`，就累加总分`ans`，同时用`minn=min(x, minn)`和`maxx=max(maxx, x)`更新当前同学的最低分和最高分。内层循环结束后，总分减去最值（`ans=ans-minn-maxx`），再除以(m-2)得到平均分。最后比较当前平均分与最大值`q`，更新`q`。注意每次循环后重置`ans`和`minn`，避免前一次数据的干扰。
* 💡 **学习笔记**：输入数据的同时记录关键值（如最值、总和），可以减少一次遍历，提升效率。

**题解二：作者：警策看取 (赞：25)**
* **亮点**：将计算单个同学平均分的逻辑封装成函数，代码结构清晰，易于维护。
* **核心代码片段**：
    ```cpp
    double perpeople(){
        double total=0;
        double maxn=-1, minn=99999;
        for(int i=1;i<=m;++i){
            double score;
            cin>>score;
            total+=score;
            maxn=max(score, maxn);
            minn=min(score, minn);
        }
        total-=maxn;
        total-=minn;
        return total/(m-2)*1.0;
    }
    ```
* **代码解读**：
    > 函数`perpeople()`的作用是“计算当前同学的平均分”。它通过遍历输入的m个评分，累加总分`total`，同时记录最大值`maxn`和最小值`minn`。遍历结束后，总分减去最值，再除以(m-2)得到平均分。这种封装方式将“处理单个同学”的逻辑独立出来，主函数只需循环调用并比较结果即可，代码更易读。
* 💡 **学习笔记**：模块化设计能让代码更清晰，尤其在处理多步骤问题时，分工明确，减少错误。

**题解三：作者：Thomas_Cat (赞：52)**
* **亮点**：使用排序找最值，思路直观，适合新手理解“排序后首尾为最值”的逻辑。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++){
        double tmp[10001],sum=0;
        for(int j=1;j<=m;j++) 
            cin>>tmp[j], sum+=tmp[j];
        sort(tmp+1,tmp+m+1);
        sum=sum-tmp[1]-tmp[m];
        sum/=(m-2);
        if(sum>MAX) MAX=sum;
    }
    ```
* **代码解读**：
    > 这段代码的核心是排序操作（`sort(tmp+1,tmp+m+1)`）。排序后，`tmp[1]`是最小值，`tmp[m]`是最大值，因此总分`sum`减去这两个值，再除以(m-2)得到平均分。虽然排序的时间复杂度略高，但对于m≤20的限制，实际运行时间几乎无影响。这种方法直观易懂，适合刚开始学习排序的同学。
* 💡 **学习笔记**：排序是找最值的常见方法，尤其当需要同时处理多个最值（如前两大、前三小）时，排序更方便。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“如何计算每个同学的平均分并找出最大值”，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素歌唱比赛——评委打分大作战`

  * **核心演示内容**：展示每个同学的评分过程：评委小像素人逐个给出评分（数字方块弹出），找到最高分和最低分（方块闪烁变红/蓝），去掉它们（方块被“擦掉”），剩余评分相加（数字累加动画），计算平均分（数字旋转弹出），最后比较所有同学的平均分，找到最大的那个（金色奖杯升起）。

  * **设计思路简述**：采用8位像素风（如FC游戏画面），用不同颜色区分评委（绿色）、评分（黄色数字方块）、最值（红色/蓝色），营造轻松的学习氛围。关键操作（如找到最值、计算平均分）伴随“叮”的音效，强化记忆；每处理完一个同学，屏幕弹出“下一位选手”的像素文字，增加互动感；最终找到最高分同学时播放胜利音效，提升成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左半部分是“评委席”（5个绿色小像素人排成一排），右半部分是“评分区”（一个10x10的像素网格，用于展示评分方块）。
          * 底部是控制面板：“开始”、“暂停”、“单步”按钮，速度滑块（1-5档，1最慢）。
          * 播放8位风格的轻快背景音乐（类似《超级马里奥》的过场音乐）。

    2.  **输入评分**：
          * 点击“开始”，第一个同学的评分开始输入：每个评委依次举起一个黄色数字方块（如“7”），从评委席滑入评分区，按输入顺序排列成一行（如“4 7 2 6 10 7”）。
          * 伴随“滴答”音效（类似打字机声音），每个数字方块弹出时轻微跳动。

    3.  **找最值并去掉**：
          * 单步模式下，点击“单步”按钮，进入“找最值”阶段：一个像素箭头（粉色）从第一个数字开始，逐个向右移动，比较当前数字与“当前最值”（初始为第一个数字）。
          * 当箭头指向更大的数字时，“当前最大值”方块（蓝色）更新为该数字，伴随“叮”的音效；同理，更小的数字更新“当前最小值”方块（红色）。
          * 遍历结束后，最大值和最小值方块开始闪烁（红蓝交替），持续2秒后被“擦掉”（用黑色方块覆盖），伴随“刷”的音效。

    4.  **计算平均分**：
          * 剩余数字方块（黄色）自动向中间聚集，顶部弹出一个“+”号，数字逐个相加，总和显示在屏幕上方（如“7+2+6+7=22”）。
          * 总和数字下方弹出“÷(m-2)”的符号（如“÷4”），计算结果（平均分）旋转着从底部升起（如“5.50”），伴随“叮咚”音效。

    5.  **比较最大值**：
          * 每个同学的平均分计算完成后，与“当前最高分”（初始为0）比较：如果更高，“当前最高分”数字变大并闪烁金色；否则保持不变。
          * 所有同学处理完成后，最终的“当前最高分”数字周围升起像素烟花，播放胜利音效（类似《魂斗罗》的胜利音乐）。

  * **旁白提示**：
      * （输入评分时）“看，评委们正在给第一位同学打分！每个评分都是一个黄色方块，我们需要记录它们哦~”
      * （找最值时）“粉色箭头在比较这些数字，最大的会变成蓝色，最小的会变成红色，最后它们会被去掉~”
      * （计算平均分时）“剩下的数字相加后，除以(m-2)就是这位同学的得分啦！”
      * （比较最大值时）“现在要看看这位同学的得分是不是目前最高的~如果是，最高分就会更新！”

<visualization_conclusion>
通过这样一个融合了像素艺术和复古游戏元素的动画，我们不仅能清晰地看到每个同学评分处理的全过程，还能在轻松有趣的氛围中理解“去掉最值算平均”的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考“处理多组数据求极值”的算法在其他场景的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：

      * 本题的核心是“多组数据处理+求极值+平均值计算”，这种思路还可以用于：
        1. **班级成绩统计**：计算每个学生的平均分（去掉最高/最低分），找出班级最高分。
        2. **比赛评分系统**：如舞蹈比赛、体育比赛中，多个评委打分后的平均分计算。
        3. **产品质量评估**：多个测试员对产品打分，去掉极端值后计算平均分，评估产品质量。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点或思维方式相关的题目，建议大家尝试练习：

    1.  **洛谷 P1003 [铺地毯]**
          * 🗣️ **推荐理由**：这道题需要处理多组矩形数据，找到覆盖某点的最后一个矩形，锻炼多组数据处理和逻辑判断能力。
    2.  **洛谷 P1046 [陶陶摘苹果]**
          * 🗣️ **推荐理由**：此题需要计算每个苹果的高度与陶陶手能触及高度的差值，找出可摘的苹果数，适合练习基础循环和条件判断。
    3.  **洛谷 P1420 [最长连续1的个数]**
          * 🗣️ **推荐理由**：此题需要遍历数组，记录连续1的个数并找最大值，锻炼“实时记录关键值”的技巧，与本题找最值的思路类似。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
提供的题解中包含了一些作者的个人学习心得，这些经验对我们很有参考价值：
</insights_intro>

> **参考经验 (来自 dream_chen)**：“要生物地理学考了，身为初二的我才只学会了一点点c（求赞）。”
>
> **点评**：这位作者的分享让我们看到，学习编程是一个循序渐进的过程。即使刚开始“只学会了一点点”，只要坚持练习（如编写题解、解决实际问题），就能逐步提升。对于新手来说，多动手写代码、尝试解决具体问题，是快速进步的关键。

-----

<conclusion>
本次关于“【深基7.例4】歌唱比赛”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解模拟类问题的处理方法和编程技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：184.68秒
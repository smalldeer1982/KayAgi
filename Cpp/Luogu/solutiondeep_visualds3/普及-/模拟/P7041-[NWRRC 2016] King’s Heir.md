# 题目信息

# [NWRRC 2016] King’s Heir

## 题目描述

国王去世了，国王万岁！在国王 Fert XIII 突然去世后，平面王国的人民将迎接新国王。不幸的是，出现了一个问题，Fert 有太多的儿子。

实际上，他有 $n$ 个儿子，并且他对每个新儿子的爱都超过了他之前所有的儿子。可能是因为他们的坏行为，他不再爱他的儿子们。无论如何，在新儿子出生后，Fert 制定了新的遗嘱，宣布新出生的儿子将成为继承人。

然而，问题在于，只有在国王去世时年满 $18$ 岁的国王儿子才能成为新国王。现在，政府的部长们正在努力寻找正确的新国王，但他们似乎失败了。请帮助他们！

## 说明/提示

时间限制：2 秒，内存限制：256 MB。

题面翻译由 ChatGPT-4o 提供。

## 样例 #1

### 输入

```
22 10 2016
7
28 2 1999
22 7 1995
21 10 1998
23 10 1998
3 9 2000
1 4 2013
17 12 2004
```

### 输出

```
3
```

## 样例 #2

### 输入

```
22 10 2016
1
28 2 1999
```

### 输出

```
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：King’s Heir 深入学习指南 💡

<introduction>
今天我们来一起分析“King’s Heir”这道C++编程题。题目要求找出国王去世时年满18岁的儿子中年龄最小的（即出生日期最晚的），若没有符合条件的则输出-1。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与枚举应用`

🗣️ **初步分析**：
解决这道题的关键在于“模拟日期比较”和“枚举筛选”。简单来说，就像整理书架上的书——我们需要先按出版时间（这里是出生日期）从新到旧排序，然后一本本检查是否符合“出版超过18年”的条件，找到第一本符合条件的书（即年龄最小的符合条件的儿子）。

题目核心步骤可概括为：
1. **输入处理**：读取国王去世的日期和所有儿子的出生日期。
2. **排序**：将儿子按出生日期从晚到早排序（年龄从小到大）。
3. **筛选判断**：遍历排序后的儿子，找到第一个满足“年满18岁”条件的儿子。

核心难点在于**正确判断日期是否满足18岁要求**（需考虑年、月、日的逐层比较）和**排序逻辑的准确性**（确保年龄从小到大排列）。优质题解通常通过结构体排序或直接比较年、月、日来解决。

可视化设计上，我们可以用“像素日历”动画演示：每个儿子的出生日期用像素方块表示（年、月、日分三列），排序时方块按日期从晚到早滑动，判断时用绿色高亮符合条件的方块，最终用金色边框标出结果。关键步骤（如年差计算、月差判断）会伴随“叮”的音效，增强记忆点。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：来源：rui_er（洛谷用户）**
* **点评**：此题解逻辑清晰，代码规范。通过定义`Node`结构体存储儿子信息，并重载`<`运算符实现按出生日期排序。关键函数`calc`计算两个日期的间隔天数（虽实际本题可简化为年、月、日直接比较，但此方法通用性强）。代码中变量命名直观（如`son`数组存储儿子信息，`king`存储去世日期），边界处理严谨（如`sort`后从后往前遍历找最小年龄）。亮点在于日期计算的普适性，适合理解复杂日期处理场景。

**题解二：来源：血色黄昏（洛谷用户）**
* **点评**：此题解简洁高效，直接通过自定义`cmp`函数排序，避免复杂计算。代码逻辑直白：排序后逐个判断年、月、日是否满足18岁要求。变量名（如`a[i].tag`表示儿子编号）易懂，边界条件（如年差等于18时的月、日判断）处理明确。亮点在于“简化问题”的思路——利用日期自然顺序，无需计算具体天数，适合快速解题。

**题解三：来源：StupidSeven（洛谷用户）**
* **点评**：此题解结构清晰，使用结构体`Node`和`operator<`重载实现排序，代码可读性高。输入输出采用快速读入函数（`Readint`），提升效率（虽本题数据小，但习惯值得学习）。判断逻辑分年差>18、等于18两种情况，覆盖所有可能，代码健壮性强。亮点在于“先排序后判断”的高效流程，适合竞赛场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何正确比较两个日期是否满足“年满18岁”？**
    * **分析**：判断逻辑需分三层：
      - 年差>18：直接满足（如儿子出生在2000年，去世在2019年，年差19>18）。
      - 年差=18：需比较月份（儿子出生月份<去世月份），或月份相同但出生日期≤去世日期（如儿子出生在2000-10-05，去世在2018-10-05，则刚好18岁）。
      - 年差<18：不满足。
      优质题解通过逐层判断年、月、日，确保覆盖所有情况。
    * 💡 **学习笔记**：日期比较需“年→月→日”逐层判断，避免遗漏边界（如同年同月不同日）。

2.  **关键点2：如何正确排序以找到“年龄最小”的符合条件儿子？**
    * **分析**：年龄最小等价于出生日期最晚。排序时需按“年从大到小→月从大到小→日从大到小”排序。例如，2000-10-05比1999-12-31晚，应排在前面。优质题解通过自定义比较函数（如`cmp`或重载`operator<`）实现此排序。
    * 💡 **学习笔记**：排序的核心是“晚出生的在前”，确保遍历时第一个符合条件的就是最小年龄。

3.  **关键点3：如何高效处理输入输出与边界条件？**
    * **分析**：输入时需注意儿子编号从1开始；若所有儿子都不满足条件，需输出-1。优质题解通过初始化`ans=-1`，遍历时更新`ans`，最后判断是否为-1输出，避免遗漏。
    * 💡 **学习笔记**：边界条件（如无符合条件的儿子）需提前考虑，用“初始值+遍历更新”的方式处理更可靠。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题简化**：无需计算具体天数，直接比较年、月、日即可判断是否满18岁（因题目保证无双胞胎，无需处理同日情况）。
- **结构体排序**：用结构体存储日期信息，重载比较运算符或自定义`cmp`函数，使排序逻辑更清晰。
- **边界标记**：用虚拟日期（如去世日期的18年前）辅助比较，简化判断逻辑（如题解Alarm5854的方法）。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解后提炼的通用核心实现，兼顾清晰性与效率：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了“血色黄昏”和“StupidSeven”的思路，采用结构体排序+逐层判断，代码简洁易读，适合新手学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    struct Son {
        int day, month, year, id;
        // 重载比较运算符：按出生日期从晚到早排序（年大→月大→日大）
        bool operator<(const Son& other) const {
            if (year != other.year) return year > other.year;
            if (month != other.month) return month > other.month;
            return day > other.day;
        }
    };

    int main() {
        int d, m, y; // 国王去世的日、月、年
        int n;       // 儿子数量
        cin >> d >> m >> y >> n;

        Son sons[105];
        for (int i = 0; i < n; ++i) {
            cin >> sons[i].day >> sons[i].month >> sons[i].year;
            sons[i].id = i + 1; // 编号从1开始
        }

        sort(sons, sons + n); // 按出生日期从晚到早排序

        for (int i = 0; i < n; ++i) {
            int age_year = y - sons[i].year;
            if (age_year > 18) { // 年差>18，直接满足
                cout << sons[i].id << endl;
                return 0;
            } else if (age_year == 18) {
                if (sons[i].month < m) { // 出生月份<去世月份
                    cout << sons[i].id << endl;
                    return 0;
                } else if (sons[i].month == m && sons[i].day <= d) { // 同月且出生日期≤去世日期
                    cout << sons[i].id << endl;
                    return 0;
                }
            }
        }

        cout << -1 << endl; // 无符合条件的儿子
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入数据，将儿子信息存入结构体数组。通过重载`operator<`对数组按出生日期从晚到早排序（年龄从小到大）。遍历排序后的数组，逐层判断年、月、日是否满足18岁要求，找到第一个符合条件的儿子并输出其编号；若遍历完无符合条件的，输出-1。

---
<code_intro_selected>
接下来，剖析优质题解的核心代码片段，学习其亮点：
</code_intro_selected>

**题解一：来源：rui_er**
* **亮点**：使用`calc`函数计算两个日期的天数差，通用性强（可处理复杂日期计算场景）。
* **核心代码片段**：
    ```cpp
    int calc(const Node &a, const Node &b) {
        int res = 0;
        if(a.y == b.y) {
            if(a.m == b.m) return b.d - a.d + 1;
            for(int i=a.m+1;i<b.m;i++) res += month[i];
            res += month[a.m] - a.d + 1 + b.d;
            return res;
        }
        for(int i=a.y+1;i<b.y;i++) res += 365;
        for(int i=a.m+1;i<=12;i++) res += month[i];
        for(int i=1;i<b.m;i++) res += month[i];
        res += month[a.m] - a.d + 1 + b.d;
        return res;
    }
    ```
* **代码解读**：
    这段代码计算日期`a`到`b`的天数差。若同年，计算中间月份的天数和首尾日期间的天数；若不同年，计算中间整年的天数（365天/年）和首尾年剩余月份的天数。虽然本题无需此复杂计算（因只需判断是否满18年），但此函数适用于需要精确天数差的场景（如计算年龄精确到天）。
* 💡 **学习笔记**：复杂日期计算可通过分年、月、日逐步累加实现，注意首尾日期的“+1”处理（如从1号到2号是2天）。

**题解二：来源：血色黄昏**
* **亮点**：直接排序后判断，代码简洁，适合快速解题。
* **核心代码片段**：
    ```cpp
    bool cmp(life a, life b) {
        if(a.y > b.y) return true;
        if(a.y == b.y) {
            if(a.m > b.m) return true;
            if(a.m == b.m) {
                if(a.d > b.d) return true;
            }
        }
        return false;
    }
    ```
* **代码解读**：
    自定义比较函数`cmp`实现按出生日期从晚到早排序。若年大则返回`true`（排在前），年相同则比较月，月相同则比较日。此函数直观体现了“晚出生的在前”的排序逻辑，确保遍历顺序正确。
* 💡 **学习笔记**：自定义比较函数时，需明确排序的“优先级”（年→月→日），避免逻辑错误。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“日期排序”和“年龄判断”的过程，我们设计了一个“像素日历探险”动画方案，用8位复古风格展示算法执行流程！
</visualization_intro>

  * **动画演示主题**：`像素日历探险——寻找最年轻的继承人`

  * **核心演示内容**：展示儿子出生日期的排序过程，以及逐个判断是否满18岁的逻辑，最终高亮符合条件的儿子。

  * **设计思路简述**：采用8位像素风（FC红白机色调），用像素方块表示每个儿子的出生日期（年、月、日分三列，颜色分别为红、绿、蓝）。排序时方块按日期从晚到早滑动，判断时用绿色高亮符合条件的方块，最终用金色边框标出结果。音效（如“叮”提示排序步骤，“咚”提示符合条件）增强互动感，让学习更有趣。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 背景为像素风格的“皇家宫殿”，顶部显示国王去世日期（如“22/10/2016”）。
          - 下方排列n个像素方块，每个方块标有儿子编号和出生日期（如“3: 23/10/1998”）。
          - 控制面板包含“开始”“单步”“重置”按钮和速度滑块（1-5倍速）。

    2.  **排序过程演示**：
          - 点击“开始”后，方块开始按年、月、日从晚到早排序。每交换两个方块位置时，播放“唰”的音效，方块短暂闪烁黄色（标记当前操作）。
          - 排序完成后，方块从左到右依次为“最晚出生→最早出生”（年龄从小到大）。

    3.  **年龄判断演示**：
          - 从左到右逐个检查方块：
            - 年差>18：方块变绿，播放“叮”音效，继续检查下一个（因要找最小年龄，需继续确认是否有更晚出生的符合条件者）。
            - 年差=18且月差符合条件：方块变绿，播放“叮”音效。
            - 年差=18但月差/日差不符合：方块变灰，播放“噗”音效。
            - 年差<18：方块变灰，播放“噗”音效。
          - 找到第一个符合条件的方块时，方块变金色并放大，播放“胜利”音效（如FC的“达标”旋律）。

    4.  **交互控制**：
          - 单步模式：点击“单步”按钮，每次执行一个排序或判断步骤，适合仔细观察。
          - 自动模式：滑块调节速度，算法自动执行，适合整体流程观察。
          - 重置模式：点击“重置”，所有方块回到初始位置，重新开始。

  * **旁白提示**：
      - （排序时）“看！方块在按出生日期从晚到早排队，这样我们就能从最年轻的开始检查啦~”
      - （判断年差时）“这个儿子出生在2000年，国王去世在2018年，2018-2000=18，刚好18岁！”
      - （找到结果时）“找到啦！这个儿子符合条件，他就是继承人~”

<visualization_conclusion>
通过这样的像素动画，我们不仅能“看”到排序和判断的每一步，还能在趣味中理解日期比较的逻辑。下次遇到类似问题，你也能像像素探险家一样轻松解决！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下拓展练习，巩固日期比较和排序的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      本题的“日期比较+排序筛选”思路可用于：
      - 统计某时间段内的事件（如统计2020年后发生的事件）。
      - 寻找某条件下的最值（如班级中年龄最小的学生）。
      - 处理时间相关的优先级问题（如任务调度中按截止时间排序）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1320** - 压缩技术（续集版）
          * 🗣️ **推荐理由**：需处理日期格式转换和排序，巩固日期处理能力。
    2.  **洛谷 P1100** - 高低位交换
          * 🗣️ **推荐理由**：虽不直接涉及日期，但需处理数值的“位排序”，锻炼排序逻辑。
    3.  **洛谷 P5737** - 月份天数
          * 🗣️ **推荐理由**：练习月份天数的判断，为复杂日期计算打基础。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题心得，以下是值得借鉴的经验：
</insights_intro>

> **参考经验 (来自 rui_er)**：“一开始担心日期计算会很复杂，但后来发现题目数据小，直接暴力计算天数也能过。关键是要仔细处理年、月、日的每一步比较。”
>
> **点评**：作者的经验提醒我们，面对日期问题时，不必追求复杂算法，先确保逻辑正确（如逐层比较年、月、日），再考虑优化。数据范围较小的题目，暴力法往往更简单可靠。

-----

<conclusion>
本次关于“King’s Heir”的C++解题分析就到这里。希望大家通过本指南掌握日期比较和排序的核心技巧，在遇到类似问题时能快速定位思路。记住，编程的关键是“理清逻辑，逐步验证”，多动手练习才能更熟练哦！下次再见~ 💪
</conclusion>

---
处理用时：183.68秒
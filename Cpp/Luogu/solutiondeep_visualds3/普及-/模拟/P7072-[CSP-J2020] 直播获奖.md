# 题目信息

# [CSP-J2020] 直播获奖

## 题目描述

NOI2130 即将举行。为了增加观赏性，CCF 决定逐一评出每个选手的成绩，并直播即时的获奖分数线。本次竞赛的获奖率为 $w\%$，即当前排名前 $w\%$ 的选手的最低成绩就是即时的分数线。

更具体地，若当前已评出了 $p$ 个选手的成绩，则当前计划获奖人数为 $\max(1, \lfloor p \times w \%\rfloor)$，其中 $w$ 是获奖百分比，$\lfloor x \rfloor$ 表示对 $x$ 向下取整，$\max(x,y)$ 表示 $x$ 和 $y$ 中较大的数。如有选手成绩相同，则所有成绩并列的选手都能获奖，因此实际获奖人数可能比计划中多。

作为评测组的技术人员，请你帮 CCF 写一个直播程序。

## 说明/提示

### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/l453vhow.png)

---
### 数据规模与约定

各测试点的 $n$ 如下表：

| 测试点编号 | $n=$ |
| :--: | :--: |
| $1 \sim 3$ | $10$ |
| $4 \sim 6$ | $500$ |
| $7 \sim 10$ | $2000$ |
| $11 \sim 17$ | $10^4$ |
| $18 \sim 20$ | $10^5$ |


对于所有测试点，每个选手的成绩均为不超过 $600$ 的非负整数，获奖百分比 $w$ 是一个正整数且 $1 \le w \le 99$。

---
### 提示

在计算计划获奖人数时，如用浮点类型的变量（如 C/C++ 中的 `float` 、 `double`，Pascal 中的 `real` 、 `double` 、 `extended` 等）存储获奖比例 $w\%$，则计算 $5 \times 60\%$ 时的结果可能为 $3.000001$，也可能为 $2.999999$，向下取整后的结果不确定。因此，建议仅使用整型变量，以计算出准确值。

## 样例 #1

### 输入

```
10 60
200 300 400 500 600 600 0 300 200 100
```

### 输出

```
200 300 400 400 400 500 400 400 300 300```

## 样例 #2

### 输入

```
10 30
100 100 600 100 100 100 100 100 100 100```

### 输出

```
100 100 600 600 600 600 100 100 100 100```

# AI分析结果



---
# 💡 Kay的C++算法解析：[CSP-J2020] 直播获奖 深入学习指南 💡

<introduction>
今天我们来一起分析“[CSP-J2020] 直播获奖”这道C++编程题。本题的核心是实时计算当前已评出选手的获奖分数线，需要动态维护分数统计并快速找到第k大值。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与统计（桶排序应用）`

🗣️ **初步分析**：
> 解决“直播获奖”问题，关键在于高效维护当前所有选手的分数分布，并快速找到满足获奖人数的最低分数。由于题目中选手分数不超过600，我们可以用“桶排序”思想——用一个数组（桶）统计每个分数出现的次数，然后从高到低遍历分数，累加人数直到达到计划获奖人数，此时的分数即为分数线。

   - **题解思路对比**：  
     常见解法有三种：暴力排序（时间复杂度高，仅适用于小数据）、对顶堆（动态维护第k大值，时间复杂度O(n log n)）、桶排序（利用分数范围小的特性，时间复杂度O(n×600)）。其中桶排序因代码简洁、效率高，是本题最优解。
   - **核心算法流程**：  
     1. 初始化一个大小为601的桶数组，记录每个分数的出现次数；  
     2. 每读入一个分数，对应桶计数+1；  
     3. 计算当前计划获奖人数（max(1, p×w/100)，p为当前已读人数）；  
     4. 从600分开始向下遍历，累加桶中的人数，直到累加值≥计划获奖人数，此时的分数即为当前分数线。
   - **可视化设计思路**：  
     采用8位像素风格动画，用不同颜色的像素块表示分数桶（如绿色块表示分数600，黄色块表示分数599等）。每读入一个分数，对应桶的像素块高度增加（表示人数+1）。同时，用一个红色指针从600分开始向下移动，累加人数时播放“滴答”音效，当累加值达标时，指针所在分数的像素块闪烁并播放“叮”的成功音效，直观展示找分数线的过程。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑简洁、实现高效被选为优质参考（≥4星）：
</eval_intro>

**题解一：Eason_AC的桶排序实现（来源：洛谷题解）**
* **点评**：此题解直接利用分数范围小的特性，用桶统计分数，从高到低遍历累加人数。代码仅需两层循环，逻辑直白易懂（外层处理每个选手，内层遍历分数找分数线）。变量命名清晰（如`a[x]`表示分数x的人数），边界处理严谨（从600到0遍历确保找到最高分）。时间复杂度O(n×600)，能轻松通过所有测试点，是J组选手的首选解法。

**题解二：GZXUEXUE的桶排序实现（来源：洛谷题解）**
* **点评**：此题解与Eason_AC思路一致，但代码更简洁。通过`sum`变量累加人数，`j`从600递减，找到第一个`sum≥sc`的j即为分数线。代码中`sc = max((i + 1) * w / 100, 1)`直接计算计划获奖人数，避免浮点误差。变量命名如`a[tmp]++`明确表示统计分数，可读性强。

**题解三：AzusagawaKaede的对顶堆实现（来源：洛谷题解）**
* **点评**：此题解展示了对顶堆的高级应用，适合学有余力的同学拓展。通过大顶堆和小顶堆动态维护前k大值，插入和调整操作时间复杂度O(log n)。代码中`qwq()`函数调整堆大小，确保小顶堆始终保存前k大值。虽然实现稍复杂，但对顶堆是处理动态第k大问题的通用方法，值得学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决本题时，以下三个关键点需要特别注意，掌握它们能帮助我们高效解题：
</difficulty_intro>

1.  **关键点1：正确计算计划获奖人数**
    * **分析**：计划获奖人数为`max(1, floor(p×w/100))`，需用整数运算避免浮点误差（如`5×60%`可能因浮点精度问题得到2.999999，导致错误取2）。优质题解中均使用`p*w/100`的整数除法，直接计算。
    * 💡 **学习笔记**：涉及百分比计算时，优先用整数运算（如`p*w/100`），避免浮点精度问题。

2.  **关键点2：高效维护分数统计**
    * **分析**：由于分数范围小（0~600），用桶数组`a[x]`统计每个分数的出现次数是最优选择。每次读入分数x时，仅需`a[x]++`，时间复杂度O(1)。若分数范围大（如1e9），则需用对顶堆或平衡树（如Treap）。
    * 💡 **学习笔记**：数据范围是选择算法的关键！小范围数据优先用桶排序，大范围用堆或树。

3.  **关键点3：快速找到分数线**
    * **分析**：从600分向下遍历，累加桶中的人数，直到累加值≥计划获奖人数。由于分数最高是600，遍历最多601次，时间复杂度O(600)，整体复杂度O(n×600)，可处理n=1e5的数据。
    * 💡 **学习笔记**：逆向遍历（从高到低）能快速定位最高分，符合“前w%”的要求。

### ✨ 解题技巧总结
<summary_best_practices>
- **数据范围敏感**：看到分数范围小（如≤600），优先考虑桶排序，代码简单且高效。  
- **整数运算优先**：涉及百分比计算时，用整数除法（如`p*w/100`）代替浮点运算，避免精度问题。  
- **逆向遍历找极值**：需要找“前k大”时，从最大值开始逆向遍历，能快速定位目标。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解前，先看一个基于桶排序的通用核心实现，它综合了多个优质题解的思路，代码简洁且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码基于桶排序，综合了Eason_AC和GZXUEXUE的题解思路，适合J组选手快速理解和实现。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int a[601]; // 桶数组，a[x]表示分数x的人数

    int main() {
        int n, w;
        cin >> n >> w;
        for (int p = 1; p <= n; ++p) {
            int x;
            cin >> x;
            a[x]++; // 统计当前分数的人数
            int plan = max(1, p * w / 100); // 计划获奖人数（整数运算）
            int sum = 0;
            // 从600分开始向下遍历，累加人数
            for (int j = 600; j >= 0; --j) {
                sum += a[j];
                if (sum >= plan) { // 达到计划人数，输出当前分数
                    cout << j << " ";
                    break;
                }
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先定义桶数组`a`统计各分数人数。主循环中，每读入一个分数`x`，对应桶`a[x]`加1。计算当前计划获奖人数`plan`后，从600分向下遍历，累加桶中的人数`sum`，当`sum≥plan`时，输出当前分数`j`，即为分数线。

---
<code_intro_selected>
接下来，我们分析优质题解中的核心代码片段，学习它们的亮点和实现思路。
</code_intro_selected>

**题解一：Eason_AC的桶排序实现（来源：洛谷题解）**
* **亮点**：代码极简，直接利用桶数组和逆向遍历，逻辑清晰。
* **核心代码片段**：
    ```cpp
    int n, w, x, a[607];

    int main() {
        scanf("%d%d", &n, &w);
        for(int i = 1; i <= n; ++i) {
            scanf("%d", &x);
            a[x]++;
            int pl = max(1, i * w / 100), num = 0;
            for(int j = 600; j >= 0; --j) {
                num += a[j];
                if(num >= pl) {printf("%d ", j); break;}
            }
        }
        return 0;
    }
    ```
* **代码解读**：  
  `a[x]++`统计分数x的人数；`pl`是计划获奖人数；`num`累加从600分开始的人数，当`num≥pl`时，`j`即为分数线。代码通过`max(1, ...)`确保至少1人获奖，`j`从600递减保证找到最高分。
* 💡 **学习笔记**：逆向遍历+桶统计是小范围数据找第k大的“黄金组合”。

**题解二：AzusagawaKaede的对顶堆实现（来源：洛谷题解）**
* **亮点**：动态维护前k大值，适用于分数范围大的场景。
* **核心代码片段**：
    ```cpp
    priority_queue<int> ma_hp; // 大顶堆，保存较小的数
    priority_queue<int, vector<int>, greater<int>> mi_hp; // 小顶堆，保存前k大的数

    void qwq() { // 调整堆大小，确保mi_hp有now个元素
        if (mi_hp.size() < now) {
            mi_hp.push(ma_hp.top());
            ma_hp.pop();
        }
        if (mi_hp.size() > now) {
            ma_hp.push(mi_hp.top());
            mi_hp.pop();
        }
    }
    ```
* **代码解读**：  
  `ma_hp`是大顶堆，保存当前分数中较小的部分；`mi_hp`是小顶堆，保存前k大的数。`qwq()`函数调整两个堆的大小，确保`mi_hp`始终有`now`（计划获奖人数）个元素。插入新分数时，根据大小决定放入哪个堆，再调用`qwq()`调整。最终`mi_hp.top()`即为分数线。
* 💡 **学习笔记**：对顶堆是动态维护第k大值的通用方法，适合数据范围大的场景。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“桶排序找分数线”的过程，我们设计一个8位像素风格的动画，模拟每加入一个分数后，如何从高到低累加人数找到分数线。
</visualization_intro>

  * **动画演示主题**：`像素分数榜：寻找实时分数线`
  * **核心演示内容**：展示每读入一个分数后，对应分数桶的人数增加，红色指针从600分开始向下移动，累加人数，直到达到计划获奖人数时，指针所在分数高亮。
  * **设计思路简述**：8位像素风（如FC游戏画面）降低学习压力；分数桶用不同颜色的竖条表示（如600分是绿色，599分是黄色），高度代表人数；指针移动和音效（“滴答”声）强化操作记忆；达标时的闪烁和“叮”声增强成就感。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：  
        屏幕左侧是601个像素竖条（对应0~600分），初始高度均为0。右侧显示控制面板（开始/暂停、单步、重置按钮，速度滑块）。播放8位风格的轻快背景音乐。

    2.  **读入第一个分数**：  
        假设分数是200，对应竖条（位置200）高度+1（像素块向上堆叠），伴随“咔嗒”音效。控制面板显示当前已读人数p=1，计划获奖人数plan=1（max(1,1×w/100)）。

    3.  **寻找分数线**：  
        红色指针从600分位置（最右侧竖条）开始，每移动一格（向下）播放“滴答”音效。指针移动时，屏幕上方显示累加人数`sum`（初始0）。当指针移动到200分时，`sum += a[200]`（此时a[200]=1），`sum=1≥plan=1`，指针停止，200分竖条开始闪烁（黄色→绿色交替），播放“叮”的成功音效，屏幕输出“200”。

    4.  **动态更新**：  
        读入第二个分数（如300），对应竖条（位置300）高度+1。计划获奖人数plan=max(1,2×w/100)（假设w=60，plan=1）。指针从600分开始移动，累加人数：a[600]=0→a[599]=0→…→a[300]=1，sum=1≥plan，指针停在300分，竖条闪烁，输出“300”。

    5.  **交互控制**：  
        支持单步执行（每点击一次，处理一个分数并展示过程）、自动播放（调速滑块控制速度）、重置（清空所有竖条，重新开始）。

  * **旁白提示**：  
    - （读入分数时）“新选手分数是300，对应分数桶的人数加1！”  
    - （指针移动时）“现在指针在600分，这里没有人；移动到599分，还是没有人…移动到300分，这里有1人！”  
    - （达标时）“累加人数达到计划的1人，当前分数线是300分！”

<visualization_conclusion>
通过这样的动画，我们能直观看到分数桶的变化、指针如何移动累加人数，以及分数线的诞生过程，轻松理解桶排序的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的桶排序和对顶堆方法后，我们可以尝试以下拓展练习，巩固动态统计第k大值的能力：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“动态维护第k大值”，这一思路还适用于：  
    - 实时统计班级前10名的平均分（维护前10大值）；  
    - 游戏中的实时战力排行榜（动态更新前k名）；  
    - 在线考试的实时通过率统计（维护前w%的最低分）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1801 黑匣子**  
          * 🗣️ **推荐理由**：动态维护第k小值，与本题思路类似，可用对顶堆或树状数组解决，适合练习数据结构应用。
    2.  **洛谷 P3871 [TJOI2010] 中位数**  
          * 🗣️ **推荐理由**：动态维护中位数（第n/2大值），需处理插入和查询操作，强化对顶堆的理解。
    3.  **洛谷 P1093 奖学金**  
          * 🗣️ **推荐理由**：统计前k名的总分，需排序后取前k项，适合练习排序与统计的综合应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自 Jerry_zpl)**：“一开始用sort排序超时，后来意识到分数范围小，改用桶排序才AC。这让我明白，数据范围是选择算法的关键！”  
> **点评**：Jerry的经验很实用！在编程竞赛中，数据范围（如本题的分数≤600）往往暗示了最优解法。遇到问题时，先观察数据范围，再选择合适的算法，能避免走弯路。

-----

<conclusion>
本次关于“[CSP-J2020] 直播获奖”的分析就到这里。通过桶排序或对顶堆，我们能高效解决动态统计第k大值的问题。希望大家通过练习巩固这些方法，下次挑战更难的题目！💪
</conclusion>

-----

---
处理用时：177.90秒
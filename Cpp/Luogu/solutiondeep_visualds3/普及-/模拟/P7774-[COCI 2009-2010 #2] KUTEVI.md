# 题目信息

# [COCI 2009/2010 #2] KUTEVI

## 题目背景

本题为[$\texttt{COCI 2009-2010}\ 2^\texttt{nd}\ \texttt{round}\ \text{T3 KUTEVI}$](https://hsin.hr/coci/archive/2009_2010/contest2_tasks.pdf)。

分值按原题设置，满分 $70$。

## 题目描述

给定 $N$ 个角（第 $i$ 个角记作 $a_i$），作为初始角，另给定 $M$ 个角（第 $i$ 个角记作 $b_i$），作为目标角。

请求出对于每个 $b_i$，它是否能被若干个 $a_i$ 之间的加、减运算得到。

注意同一个 $a_i$ 可以用多次，也可以不用。

## 说明/提示

### 样例解释

样例 $1$ 解释：

$70^\circ-30^\circ=40^\circ$。

样例 $2$ 解释：

$15\times100^\circ=1500^\circ=60^\circ$。

### 数据范围与约定

$1\leq N,M\leq10$，$0<a_i,b_i< 360$。

## 样例 #1

### 输入

```
2 1
30 70
40```

### 输出

```
YES```

## 样例 #2

### 输入

```
1 1
100
60```

### 输出

```
YES```

## 样例 #3

### 输入

```
3 2
10 20 30
5 70```

### 输出

```
NO
YES```

# AI分析结果

---
# 💡 Kay的C++算法解析：KUTEVI 深入学习指南 💡

<introduction>
今天我们来一起分析“KUTEVI”这道C++编程题。这道题的核心是判断给定的目标角能否通过初始角的加减运算（模360）得到。本指南将帮助大家梳理题目思路，理解核心算法（完全背包、GCD数论），并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划（完全背包）与数学（GCD数论）`

🗣️ **初步分析**：
> 解决“KUTEVI”这道题，关键在于理解两种核心思路：一种是用动态规划（完全背包）模拟所有可能的角度组合；另一种是利用数论中的最大公约数（GCD）性质，直接判断目标角是否为初始角GCD的倍数（模360）。  
> - **完全背包思路**：类似“无限次选取物品”的问题，每个初始角可以多次加减，通过动态规划数组`dp[i]`标记角度`i`是否可达。例如，若`dp[j - a[i]]`可达，则`dp[j]`也可达（加减操作等价于背包的“选”或“不选”）。  
> - **GCD数论思路**：根据数论定理，所有由初始角加减得到的角度（模360）必为初始角GCD的倍数。例如，初始角为100°时，GCD为100°，其倍数模360为100°, 200°, 300°, 40°, 140°, ...，覆盖样例2中的60°（15×100°=1500°≡60°）。  
> - **核心难点**：理解模360的循环特性，以及如何高效枚举所有可能的角度组合（完全背包需合理设置枚举范围，GCD需正确计算初始角的GCD）。  
> - **可视化设计**：我们将设计一个“像素角度工厂”动画，用8位风格展示角度加减过程：例如，初始角为30°和70°时，动画会逐步展示30°+70°=100°（模360为100°）、70°-30°=40°（直接标记为可达），并用不同颜色方块表示可达角度（绿色）和不可达角度（灰色）。关键步骤（如加减操作、模运算）会伴随“叮”的像素音效，自动播放时模拟工厂流水线生产角度的过程。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性的综合评估，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：Flokirie的GCD数论解法（来源：洛谷用户Flokirie）**
* **点评**：此题解抓住了问题的数学本质，利用数论中的线性组合性质，将问题转化为判断目标角是否为初始角GCD的倍数（模360）。思路简洁高效（时间复杂度O(N + M)），代码逻辑清晰，变量命名直观（如`gcd`直接表示初始角的最大公约数），是数学思维在算法中的典型应用。其提供的定理说明（“所有可能的角度是初始角GCD的倍数模360”）对理解问题本质有极大帮助，适合快速解题。

**题解二：pengzy___的完全背包解法（来源：洛谷用户pengzy___）**
* **点评**：此题解采用完全背包模型，通过动态规划数组`f`标记可达角度。代码结构规范（输入输出逻辑清晰），状态转移直接（加减操作对应背包的“选”或“不选”），且通过模360处理循环特性。虽然时间复杂度略高于GCD解法，但对动态规划的初学者更友好，能直观展示角度组合的过程。

**题解三：Violet___Evergarden的BFS搜索解法（来源：洛谷用户Violet___Evergarden）**
* **点评**：此题解用广度优先搜索（BFS）模拟角度的扩展过程，队列`q`存储待扩展的角度，`v`数组标记可达状态。代码逻辑直观（每一步扩展当前角度的加减操作），适合理解“如何从初始0°逐步生成所有可能角度”的过程。尽管效率略低，但对算法基础较弱的学习者来说，BFS的步骤更易跟踪和调试。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的过程中，我们需要突破以下核心难点，掌握关键策略：
</difficulty_intro>

1.  **关键点1：理解角度的循环特性（模360）**
    * **分析**：角度运算中，超过360°的部分会循环（如1500°=4×360°+60°≡60°），小于0°的部分需调整为正（如-30°≡330°）。优质题解通过模运算（`j % 360`）统一处理这两种情况，确保角度始终在[0, 359]范围内。  
    * 💡 **学习笔记**：模360是角度问题的核心规则，所有运算结果都需以此调整。

2.  **关键点2：确定可达角度的集合性质**
    * **分析**：完全背包解法通过动态规划枚举所有可能的加减组合，标记可达角度；GCD解法则利用数论定理，直接得出可达角度是初始角GCD的倍数（模360）。例如，初始角为10°、20°、30°时，GCD为10°，所有可达角度为10°, 20°, ..., 350°。  
    * 💡 **学习笔记**：数学定理（如GCD的线性组合性质）能大幅简化问题，需注意积累类似数论知识。

3.  **关键点3：选择合适的算法模型**
    * **分析**：若数据范围小（如本题N≤10），BFS或完全背包足够；若追求最优效率（如N很大），GCD解法更优。例如，GCD解法只需计算初始角的GCD，时间复杂度O(N)，远低于背包的O(N×1000)。  
    * 💡 **学习笔记**：算法选择需结合数据范围和问题特性，数学优化往往能带来质的提升。

### ✨ 解题技巧总结
- **问题抽象**：将角度加减问题抽象为“无限次选取物品的背包问题”或“线性组合的数论问题”。  
- **模运算处理**：所有角度运算后取模360，确保结果在有效范围内。  
- **数学定理应用**：关注数论中的GCD性质，可快速判断可达角度的集合。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看两种核心思路的完整实现，分别对应GCD数论和完全背包解法。
</code_intro_overall>

### **本题通用核心C++实现参考（GCD数论解法）**
* **说明**：此代码综合了Flokirie的GCD解法，逻辑简洁高效，适合快速解题。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a % b);
    }

    int main() {
        int n, m;
        cin >> n >> m;
        int a[15], g;
        for (int i = 0; i < n; ++i) {
            cin >> a[i];
            if (i == 0) g = a[i];
            else g = gcd(g, a[i]);
        }
        bool reachable[360] = {false};
        for (int i = 0; i < 360; ++i) {
            reachable[(g * i) % 360] = true;
        }
        while (m--) {
            int b;
            cin >> b;
            cout << (reachable[b] ? "YES" : "NO") << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先计算初始角的GCD（`g`），然后标记所有`g`的倍数模360为可达（`reachable`数组）。最后，对每个目标角`b`，直接查询`reachable[b]`即可判断是否可达。

---

### **本题通用核心C++实现参考（完全背包解法）**
* **说明**：此代码综合了pengzy___的背包解法，适合动态规划初学者理解角度组合过程。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    using namespace std;

    int main() {
        int n, m, a[15], b[15];
        bool dp[360] = {false};
        dp[0] = true; // 初始0°可达
        cin >> n >> m;
        for (int i = 0; i < n; ++i) cin >> a[i];
        for (int i = 0; i < n; ++i) {
            // 完全背包：枚举所有可能的角度组合
            bool new_dp[360];
            memcpy(new_dp, dp, sizeof(dp));
            for (int j = 0; j < 360; ++j) {
                if (dp[j]) {
                    new_dp[(j + a[i]) % 360] = true;
                    new_dp[(j - a[i] + 360) % 360] = true; // 避免负数
                }
            }
            memcpy(dp, new_dp, sizeof(dp));
        }
        for (int i = 0; i < m; ++i) {
            cin >> b[i];
            cout << (dp[b[i]] ? "YES" : "NO") << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码用`dp`数组标记可达角度，初始时只有0°可达。对每个初始角`a[i]`，更新`dp`数组（加减`a[i]`后的角度模360），最终查询目标角是否在`dp`中。

---

<code_intro_selected>
接下来，我们分析优质题解的核心代码片段：
</code_intro_selected>

**题解一（Flokirie的GCD解法）**
* **亮点**：利用数论定理，将问题转化为GCD的倍数判断，时间复杂度O(N + M)，极高效。
* **核心代码片段**：
    ```cpp
    int gcd = a[0];
    for (int i = 1; i < n; i++) {
        gcd = Gcd(a[i], gcd);
    }
    bool[] res = new bool[360];
    for (int i = 0; i < 360; i++) {
        res[(gcd * i) % 360] = true;
    }
    ```
* **代码解读**：  
  首先计算初始角的GCD（`gcd`），然后遍历0到359，将`gcd*i`模360的位置标记为可达（`res`数组）。例如，若`gcd=10`，则`i=6`时`10×6=60`，`res[60]=true`。  
* 💡 **学习笔记**：数学定理能将复杂的枚举问题转化为简单的计算，需掌握数论中的线性组合性质。

**题解二（pengzy___的背包解法）**
* **亮点**：完全背包模型的典型应用，代码简洁，状态转移清晰。
* **核心代码片段**：
    ```cpp
    f[0] = 1;
    for (int i = 1; i <= n; i++)
        for (int j = 0; j <= 1000; j++) {
            if (j >= a[i])
                f[j % 360] |= f[(j - a[i]) % 360];
            f[j % 360] |= f[(j + a[i]) % 360];
        }
    ```
* **代码解读**：  
  `f[j%360]`表示角度`j%360`是否可达。通过遍历所有可能的`j`（0到1000），更新`f`数组：若`j - a[i]`可达（`f[(j - a[i])%360]`为1），则`j%360`可达（`|=`操作）。  
* 💡 **学习笔记**：完全背包的“无限次选取”特性适合处理可重复使用的元素（如本题的初始角）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解角度组合的过程，我们设计“像素角度工厂”动画，用8位复古风格展示GCD解法和背包解法的核心逻辑。
</visualization_intro>

  * **动画演示主题**：`像素角度工厂——从0°到目标角的旅程`

  * **核心演示内容**：  
    展示初始角（如30°、70°）如何通过加减操作生成所有可达角度（如40°=70°-30°），并用GCD定理验证这些角度是否为初始角GCD的倍数（如GCD(30,70)=10°，40°是10°的4倍）。

  * **设计思路简述**：  
    采用FC红白机风格（8色调色板），用像素方块表示角度（0°到359°排列成环形），绿色方块表示可达角度，灰色表示不可达。关键操作（加减、模运算）伴随“叮”的音效，自动播放时模拟工厂流水线逐步点亮可达角度，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕中央显示360个像素方块（环形排列，每个代表1°），初始全灰（仅0°为绿色）。  
        - 控制面板包含“开始/暂停”“单步”“重置”按钮，速度滑块（1-5倍速）。  
        - 播放8位风格背景音乐（如《超级玛丽》经典旋律变奏）。

    2.  **GCD计算演示**：  
        - 输入初始角（如30°、70°），动画用箭头指向这两个数，逐步计算GCD（30和70的GCD为10）。  
        - 显示文字提示：“所有可达角度都是10°的倍数哦！”

    3.  **可达角度生成（背包解法）**：  
        - 单步执行时，选中初始角30°，从0°出发，生成30°（绿色点亮）、-30°（模360为330°，绿色点亮）。  
        - 选中70°，从0°出发生成70°（绿色）、-70°（290°，绿色）；从30°出发生成30+70=100°（绿色）、30-70=-40≡320°（绿色），依此类推。  
        - 每次点亮新角度时，播放“叮”的音效，对应代码行（如`dp[(j + a[i])%360] = true`）高亮。

    4.  **目标角验证**：  
        - 输入目标角40°，动画检查该位置是否为绿色（可达），若是则播放“胜利”音效（如《超级玛丽》吃金币声），并显示“YES”；否则播放“提示”音效（短“滴”声），显示“NO”。

  * **旁白提示**：  
    - “看！0°是起点，所有可达角度都是从这里出发，通过加减初始角得到的～”  
    - “现在处理初始角30°，0°+30°=30°，所以30°点亮！”  
    - “目标角40°是绿色的，说明可以通过70°-30°得到，输出YES！”

<visualization_conclusion>
通过这个动画，我们可以直观看到角度如何从0°逐步扩展，以及GCD定理如何快速判断可达性，让抽象的算法变得“可见可听”！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的GCD和背包思路后，我们可以尝试以下拓展练习，巩固算法应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - GCD的线性组合性质可用于判断“能否用若干面值的硬币组成目标金额”（如硬币问题）。  
    - 完全背包模型适用于“无限次选取物品的组合问题”（如凑邮票、求方案数）。  
    - 模运算处理循环问题（如钟表指针重合、循环数组操作）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1832 小A的糖果**  
        * 🗣️ **推荐理由**：考察完全背包的变形，需处理“每个物品最多选一次”到“无限次”的转换，巩固背包模型。  
    2.  **洛谷 P2347 砝码称重**  
        * 🗣️ **推荐理由**：结合GCD和背包思路，判断能否用给定砝码称出目标重量，与本题角度组合逻辑类似。  
    3.  **洛谷 P1077 摆花**  
        * 🗣️ **推荐理由**：完全背包的方案数统计问题，练习状态转移的灵活应用。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验和算法优化心得，对我们很有启发：
</insights_intro>

> **参考经验 (来自用户_Fatalis_)**：“在BFS中，最初我只考虑了加法，但通过数学证明发现减法可以通过多次加法替代（如x - a = x + (360 - a) × k mod 360）。这让我意识到，算法中的操作可能存在等价关系，需要深入分析以简化代码。”  
> **点评**：_Fatalis_的经验提醒我们，算法中的操作可能有隐藏的等价性（如加减在模运算下的转换）。通过数学推导可以简化实现（如省略减法操作），提升代码效率。这对处理循环问题（如角度、时间）非常有用。

---

<conclusion>
本次关于“KUTEVI”的C++解题分析就到这里。无论是动态规划的细致枚举，还是数论的巧妙应用，都体现了算法设计中“抽象问题、寻找规律”的核心思想。希望大家通过练习，逐步掌握这些技巧，在编程之路上越走越远！💪
</conclusion>

---
处理用时：153.44秒
# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

# 💡 Kay的C++算法解析：最短路计数 深入学习指南 💡

<introduction>
今天我们来一起分析「最短路计数」这道经典的图论问题。它要求我们在**无向无权图**中，计算从顶点1到其他所有顶点的**最短路数量**。这道题不仅能帮我们巩固最短路算法，还能锻炼「边找路径边统计」的逻辑思维。让我们一起拆解问题，掌握核心技巧吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（最短路计数） + BFS（广度优先搜索）

🗣️ **初步分析**：
解决这道题的核心是**「分层找最短，累加计路径」**。因为图是**无权**的，最短路的长度等于「从起点到该点的边数」——这正好是BFS的拿手好戏！BFS像「水波扩散」一样，从起点开始逐层扩展，每一层对应「距离起点多1步的节点」。而计数的关键在于：
- 第一次访问某个节点时，它的最短路数**等于父节点的最短路数**（因为这是第一条到达它的最短路径）；
- 如果后续又找到一条「同样长度的路径」（比如重边或不同的父节点），就把父节点的路径数**累加到当前节点**。

### 核心算法流程与可视化设计
BFS的核心流程可以总结为：
1. **初始化**：起点入队，距离设为0，路径数设为1；
2. **逐层扩展**：取出队列首节点，遍历其邻接节点；
3. **更新状态**：未访问的节点标记距离、路径数并入队；已访问但距离相同的节点累加路径数；
4. **重复**：直到队列为空。

**可视化设计思路**：我们将用**8位像素风**模拟BFS的「扩散过程」——
- 节点用彩色像素块（起点红、普通节点白、已扩展节点黄）；
- 队列用底部的像素队列显示（节点滑入滑出）；
- 每一步扩展时，**高亮当前处理的节点**，用「闪烁边」表示正在访问邻接节点；
- 累加路径数时，显示「+1」的像素动画，伴随「嗒」的音效；
- 自动播放时像「贪吃蛇AI」一样逐步扩散，单步执行可手动控制每一步。


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、算法有效性」三个维度筛选了5份优质题解，覆盖了BFS、SPFA、Dijkstra、拓扑DP四种思路，帮你全面理解问题！
</eval_intro>

### 题解一：岸芷汀兰的BFS解法（简洁高效的无权图最优解）
* **点评**：这道题的「标准答案」级解法！作者抓住了「无权图用BFS」的核心，代码逻辑极其清晰：
  - 用`vector`存邻接表，忽略自环（避免无效计算）；
  - BFS队列处理节点，`dist`记录距离，`ans`记录路径数；
  - 第一次访问节点时标记`visited`，后续遇到相同距离的路径直接累加。
  代码没有冗余，完全贴合问题特性，是初学者理解「最短路计数」的最佳入门模板。

### 题解二：ZiDing_ByronFinlso的SPFA解法（通用最短路框架）
* **点评**：作者用SPFA实现了最短路计数，思路通用且代码规范：
  - 用**链式前向星**存图（适合大数据量），`read`函数优化输入；
  - SPFA队列处理松弛操作：当找到更短路径时重置`ans`，当路径长度相同时累加`ans`；
  - 模运算`mod=100003`避免整数溢出。
  这份题解的价值在于——它能轻松扩展到**有边权的最短路计数**（只需修改`d[y] = d[x] + 边权`）。

### 题解三：King丨帝御威的Dijkstra堆优化解法（有权图的通用思路）
* **点评**：作者用堆优化的Dijkstra算法，适合**有边权的最短路计数**：
  - 用优先队列（小根堆）每次取出「距离最小的节点」，保证每个节点只被处理一次；
  - `js`数组记录路径数，更新最短路时重置`js`，路径相同时累加`js`；
  - 代码注释详细，解释了「堆优化」的原理（将大根堆转为小根堆）。
  这份题解帮我们理解：当图有边权时，BFS不再适用，Dijkstra是更通用的选择。

### 题解四：Utsuji_risshū的SPFA局限性分析（避坑指南）
* **点评**：作者的思考非常深入！他指出：**普通SPFA在有边权的图中会「重复计数」**。比如当一个节点的路径数被更新后，若未重新入队，后续的邻接节点无法收到更新。因此，他修改了SPFA的逻辑——**被更新路径数的节点要重新入队**，并在处理完后清零`ans`避免重复。
  这份题解的价值在于「踩坑提醒」：算法不是死记模板，要理解其适用场景！

### 题解五：George1123的拓扑DP解法（逆向思维的拓展）
* **点评**：作者的思路非常独特！他分两步解决问题：
  1. **第一步**：用Dijkstra求出每个节点的最短路长度`dis`；
  2. **第二步**：构建「最短路图」（只保留能构成最短路的边：`dis[u]+1=dis[v]`），然后**拓扑排序**统计路径数（`dp[v] += dp[u]`）。
  这种「先求最短，再拓扑」的思路，适合处理**更复杂的最短路计数问题**（比如有边权、有约束的图），拓展了我们的思维边界。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决「最短路计数」问题时，初学者常遇到3个核心难点。结合优质题解的经验，我们逐一破解！
</difficulty_intro>

### 难点1：如何避免「重复计数」或「遗漏路径」？
- **问题**：如果同一节点被多个父节点以「相同距离」访问，如何正确累加路径数？
- **解决策略**：
  - 第一次访问节点时，标记`visited`并记录`dist`和`ans`（此时`ans`等于父节点的`ans`）；
  - 后续遇到`dist[v] == dist[u]+1`的情况时，直接`ans[v] += ans[u]`（无需重新入队，因为`v`的`dist`已确定）。

### 难点2：如何处理「自环」和「重边」？
- **问题**：自环（比如边`1-1`）会导致无效的循环，重边（比如两条`4-5`）会增加路径数，如何处理？
- **解决策略**：
  - 自环：直接忽略（`if (x == y) continue;`），因为它不会缩短路径；
  - 重边：正常存储（比如两条`4-5`会被存为两个邻接项），BFS会自动处理——每条重边都会触发一次`ans[v] += ans[u]`，正好统计重边带来的额外路径。

### 难点3：如何选择「最高效的算法」？
- **问题**：BFS、SPFA、Dijkstra都能解决问题，该选哪一个？
- **解决策略**：
  - 优先选**BFS**（无权图）：时间复杂度O(N+M)，速度最快；
  - 选**SPFA**（有负权边的图）：能处理负权，但可能被卡；
  - 选**Dijkstra堆优化**（有正权边的图）：时间复杂度O(M log N)，稳定高效。

### ✨ 解题技巧总结
1. **图存储**：用邻接表（`vector`或链式前向星），避免邻接矩阵（空间浪费）；
2. **输入优化**：用`read`函数替代`cin`（处理大数据量时更快）；
3. **模运算**：每一步累加都要`% 100003`，避免整数溢出；
4. **边界处理**：起点`ans[1] = 1`（自己到自己的路径数为1）。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**通用的BFS实现**——它综合了优质题解的优点，代码简洁、逻辑清晰，是无权图最短路计数的「标准模板」。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码基于「岸芷汀兰、TsReaper、jiangXxin」的BFS思路，优化了输入效率和代码可读性，适合初学者直接使用。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int MAXN = 1000005;  // 节点数上限
const int MOD = 100003;    // 结果取模

vector<int> adj[MAXN];     // 邻接表存图
int dist[MAXN];            // dist[i]：起点到i的最短距离
int ans[MAXN];             // ans[i]：起点到i的最短路数
bool visited[MAXN];        // visited[i]：是否已访问过i
int n, m;                  // n：节点数，m：边数

// BFS核心函数：计算最短路及路径数
void bfs() {
    queue<int> q;
    memset(dist, -1, sizeof(dist));  // 初始化距离为-1（未访问）
    memset(visited, false, sizeof(visited));  // 初始化未访问

    // 起点初始化：距离0，路径数1，入队
    dist[1] = 0;
    ans[1] = 1;
    q.push(1);
    visited[1] = true;

    while (!q.empty()) {
        int u = q.front();  // 取出队列首节点
        q.pop();

        // 遍历u的所有邻接节点v
        for (int v : adj[u]) {
            if (!visited[v]) {  // 第一次访问v
                visited[v] = true;
                dist[v] = dist[u] + 1;  // 距离是u+1
                ans[v] = ans[u];        // 路径数等于u的路径数
                q.push(v);              // v入队，继续扩展
            } else if (dist[v] == dist[u] + 1) {  // 非第一次，但距离相同
                ans[v] = (ans[v] + ans[u]) % MOD;  // 累加路径数，取模
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);  // 加速cin
    cin.tie(nullptr);             // 解除cin和cout的绑定

    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int x, y;
        cin >> x >> y;
        if (x == y) continue;  // 忽略自环
        adj[x].push_back(y);   // 无向边，存两条
        adj[y].push_back(x);
    }

    bfs();  // 执行BFS

    // 输出结果
    for (int i = 1; i <= n; ++i) {
        cout << ans[i] << '\n';
    }

    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：用`ios::sync_with_stdio(false)`加速cin，忽略自环；
  2. **BFS初始化**：起点入队，距离0，路径数1；
  3. **扩展节点**：取出队首节点，遍历邻接节点，更新`dist`和`ans`；
  4. **输出结果**：依次输出每个节点的最短路数。


---

<code_intro_selected>
接下来，我们剖析3份优质题解的核心代码片段，看看它们的「亮点」！
</code_intro_selected>

### 题解一：岸芷汀兰的BFS核心片段
* **亮点**：用`vector`存邻接表，代码简洁，逻辑直观。
* **核心代码片段**：
```cpp
for (register int i = 0; i < linker[u].size(); ++i) {
    int cur = linker[u][i];
    if (!vis[cur]) {
        q.push(make(cur, dis + 1));
        vis[cur] = true;
        d[cur] = dis + 1;
        ans[cur] = ans[u] % MOD;  // 第一次访问，路径数等于父节点
    } else if (d[cur] == dis + 1) {
        ans[cur] = (ans[cur] + ans[u]) % MOD;  // 累加路径数
    }
}
```
* **代码解读**：
  - `linker[u]`是u的邻接表，`cur`是当前访问的邻接节点；
  - `vis[cur]`判断是否第一次访问：是则入队，否则判断距离是否相同；
  - 每一步都取模，避免溢出。
* **学习笔记**：BFS的核心是「分层扩展」，第一次访问时确定`dist`，后续只需累加`ans`。

### 题解二：ZiDing_ByronFinlso的SPFA核心片段
* **亮点**：用链式前向星存图，适合大数据量，SPFA逻辑通用。
* **核心代码片段**：
```cpp
while (!q.empty()) {
    x = q.front(); q.pop();
    p[x] = false;  // 标记为不在队列中
    for (int i = head[x]; i; i = nxt[i]) {
        y = to[i];
        if (d[y] > d[x] + 1) {  // 找到更短路径
            d[y] = d[x] + 1;
            ans[y] = ans[x];    // 重置路径数
            if (!p[y]) { q.push(y); p[y] = true; }
        } else if (d[y] == d[x] + 1) {  // 路径长度相同
            ans[y] = (ans[y] + ans[x]) % MOD;  // 累加
        }
    }
}
```
* **代码解读**：
  - `head[x]`是链式前向星的头指针，`to[i]`是边的终点；
  - `p[x]`标记节点是否在队列中（避免重复入队）；
  - 更短路径时重置`ans[y]`，相同路径时累加。
* **学习笔记**：SPFA的核心是「松弛操作」，适合处理有边权的图，但无权图中BFS更高效。

### 题解三：King丨帝御威的Dijkstra堆优化核心片段
* **亮点**：用优先队列（小根堆）优化，保证每次取出「距离最小的节点」，稳定高效。
* **核心代码片段**：
```cpp
priority_queue<node> q;  // 小根堆（重载<运算符）
q.push((node){1, 0});
js[1] = 1;  // 起点路径数1

while (!q.empty()) {
    node a = q.top(); q.pop();
    int u = a.x, d = a.y;
    if (d != dis[u]) continue;  // 跳过旧的距离（已被更新过）
    for (int i = head[u]; i; i = edge[i].nxt) {
        int v = edge[i].v;
        if (d + edge[i].w == dis[v]) {  // 路径长度相同
            js[v] = (js[u] + js[v]) % MOD;  // 累加
        } else if (dis[v] > d + edge[i].w) {  // 更短路径
            dis[v] = d + edge[i].w;
            js[v] = js[u];  // 重置路径数
            q.push((node){v, dis[v]});  // 入堆
        }
    }
}
```
* **代码解读**：
  - `priority_queue<node>`是小根堆，每次取出距离最小的节点；
  - `d != dis[u]`跳过已处理的旧节点（避免重复计算）；
  - 更短路径时入堆，相同路径时累加。
* **学习笔记**：Dijkstra堆优化适合**有正权边的图**，时间复杂度O(M log N)，比SPFA更稳定。


## 5. 算法可视化：像素动画演示方案

### 🎮 动画主题：像素探险家之BFS寻宝记
我们将用**8位像素风**模拟BFS的「扩散过程」，让你直观看到「最短路如何生成，路径数如何累加」！

### 🎨 设计思路
- **风格**：仿FC游戏（比如《塞尔达传说》的像素风），用16x16的像素块表示节点，8x8的像素线表示边；
- **场景**：屏幕左侧是「图区域」（节点排列成网格），右侧是「控制面板」（按钮+代码同步），底部是「队列区域」（显示当前队列的节点）；
- **趣味元素**：加入8位音效（入队「叮」、累加「嗒」、完成「胜利曲」），自动播放像「AI寻宝」，单步执行可手动控制。

### 🚀 动画核心步骤
1. **初始化**：
   - 图区域：起点（1号）红色，其他节点白色，边灰色；
   - 控制面板：显示「开始/暂停」「单步」「重置」按钮，速度滑块（1x到5x）；
   - 队列区域：空；
   - 背景音乐：8位风格的《卡农》片段（循环播放）。

2. **起点入队**：
   - 红色像素块从起点「滑入」底部队列，伴随「叮」的音效；
   - 队列区域显示「[1]」。

3. **扩展节点1**：
   - 队列首节点1被「弹出」，高亮（闪烁红色）；
   - 遍历节点1的邻接节点（比如2、3）：
     - 节点2未访问：白色→黄色，滑入队列，距离设为1，路径数设为1（显示「ans[2] = 1」）；
     - 节点3未访问：白色→黄色，滑入队列，距离设为1，路径数设为1（显示「ans[3] = 1」）；
   - 队列区域变为「[2, 3]」，伴随「咻」的音效。

4. **扩展节点2**：
   - 队列首节点2被弹出，高亮（闪烁黄色）；
   - 遍历节点2的邻接节点（比如1、4）：
     - 节点1已访问，距离0≠1+1，跳过；
     - 节点4未访问：白色→黄色，滑入队列，距离设为2，路径数设为1（显示「ans[4] = 1」）；
   - 队列区域变为「[3, 4]」。

5. **扩展节点3**：
   - 队列首节点3被弹出，高亮（闪烁黄色）；
   - 遍历节点3的邻接节点（比如1、4）：
     - 节点1已访问，跳过；
     - 节点4已访问（距离2），且3的距离+1=2：ans[4] += ans[3] → ans[4] = 2（显示「ans[4] += 1 → 2」）；
   - 队列区域变为「[4]」，伴随「嗒」的音效。

6. **完成扩展**：
   - 所有节点处理完毕，图区域的节点变为：起点红，其他节点黄色；
   - 弹出「完成！」的像素动画，伴随「胜利曲」音效；
   - 控制面板显示「重置」按钮，可重新播放。

### 🎮 交互设计
- **单步执行**：点击「单步」按钮，执行一次扩展操作；
- **自动播放**：滑动「速度滑块」选择1x到5x，动画自动播放；
- **代码同步**：右侧显示当前步骤的C++代码片段（比如扩展节点1时，高亮`for (int v : adj[u])`）；
- **重置**：点击「重置」按钮，恢复初始状态。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了最短路计数的核心后，我们可以挑战更复杂的「变种问题」，巩固思路！
</similar_problems_intro>

### 通用思路迁移
最短路计数的核心是「**在求最短路的同时，统计路径数**」，适用于以下场景：
1. **有边权的图**（比如洛谷P1608）；
2. **多源最短路计数**（比如求多个起点到同一终点的最短路数）；
3. **带约束的最短路计数**（比如必须经过某个节点）。

### 练习推荐（洛谷）
1. **洛谷P1608 路径统计**  
   🗣️ **推荐理由**：有边权的最短路计数，需要用Dijkstra或SPFA，锻炼「边权处理」能力。
2. **洛谷P1339 热浪**  
   🗣️ **推荐理由**：单源最短路的基础题，帮你巩固Dijkstra算法。
3. **洛谷P2853 奶牛的电信**  
   🗣️ **推荐理由**：最短路计数的变形，求两点间的最短路数，需要处理「障碍节点」。


## 7. 学习心得与经验分享

<insights_intro>
以下是几位作者的「踩坑经验」，帮你避免走弯路！
</insights_intro>

> **参考经验（来自XZYQvQ）**：  
> 我一开始用SPFA写，结果在vjudge的题上WA了。后来发现，SPFA在有边权的图中，**被更新路径数的节点需要重新入队**，否则后续的邻接节点无法收到更新。比如：
> ```cpp
> if (!vis[y] && ans[y]) { vis[y] = true; q.push(y); }  // 被更新后重新入队
> ans[x] = 0;  // 清零，避免重复计数
> ```
> **点评**：SPFA的「重复入队」是关键！在有权图中，节点的路径数可能被多次更新，必须重新入队才能让邻接节点收到最新的`ans`。

> **参考经验（来自Utsuji_risshū）**：  
> 普通SPFA在无权图中没问题，但在有边权的图中会「漏更」。比如节点A的路径数被更新后，若未重新入队，节点B（A的邻接节点）无法累加A的新路径数。而Dijkstra由于用堆优化，每次取出「距离最小的节点」，能保证路径数已稳定，不会漏更。
> **点评**：Dijkstra的「堆优化」是其优势——它按距离从小到大处理节点，一旦节点被弹出堆，其`dist`和`ans`就不会再变，无需重新入队。

> **参考经验（来自George1123）**：  
> 我用「Dijkstra+拓扑DP」的方法：先求最短路，再构建「最短路图」（只保留`dis[u]+1=dis[v]`的边），然后拓扑排序统计路径数。这种方法的好处是——**避免了BFS/SPFA的「重复处理」**，适合复杂图。
> **点评**：拓扑DP是一种「逆向思维」，先确定最短路，再统计路径数，适合处理「有约束的最短路计数」（比如必须经过某个节点）。


## <conclusion>
本次关于「最短路计数」的分析就到这里！这道题的核心是「**BFS分层扩展+路径数累加**」，关键是要理解「无权图的最短路特性」。记住：
- 无权图优先用BFS，代码简洁，速度最快；
- 路径数的统计要「第一次访问时赋值，后续累加」；
- 遇到问题先想「是否符合BFS的分层特性」，再考虑其他算法。

编程能力的提升在于「多练、多思考」——试着用BFS解决P1608，用Dijkstra解决P1339，你会发现「最短路计数」的思路能轻松迁移！下次我们再一起探索更复杂的图论问题吧！💪
</conclusion>

---
处理用时：184.64秒
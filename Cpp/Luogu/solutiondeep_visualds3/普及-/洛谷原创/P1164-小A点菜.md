# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果

# 💡 Kay的C++算法解析：小A点菜 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（01背包变形）

🗣️ **初步分析**：  
解决“小A点菜”的关键，其实是**01背包问题的“方案数版”**——就像你整理书包时，每个课本（菜）只能选或不选，要刚好填满书包（花光M元），问有多少种装法。  

### 核心算法思想  
01背包的核心是“选或不选”每个物品，而本题要求**刚好填满背包的方案数**。我们用`dp[j]`表示“用j元钱的点菜方案数”，状态转移的逻辑是：  
- 对于第i道菜（价格`a[i]`），如果选它，那么`dp[j]`要加上“用`j - a[i]`元的方案数”（因为选这道菜后，剩下的钱刚好能凑出`j - a[i]`）；  
- 如果不选它，`dp[j]`保持不变（继承之前的方案数）。  

### 题解思路与难点  
大部分题解都围绕**二维DP→一维DP的优化**展开：  
- 二维DP（如衡屿睿的题解）用`f[i][j]`表示“前i道菜凑j元的方案数”，清晰但空间占用大；  
- 一维DP（如Dream_zhc的题解）通过**倒序遍历金额**，把空间从`O(N*M)`优化到`O(M)`，避免重复选择同一道菜。  

核心难点是**初始化`dp[0] = 1`**——它表示“用0元的方案数是1”（什么都不选），这是所有方案的“起点”（比如选一道价格为a[i]的菜，相当于从0元加上a[i]，对应`dp[a[i]] += dp[0]`）。  

### 可视化设计思路  
我计划用**8位像素风**演示01背包的方案数计算：  
- 屏幕左侧是“像素化菜摊”（每个菜用不同颜色的像素块表示，标价格）；  
- 右侧是“金额进度条”（用像素块堆叠表示`dp[j]`的值，数值越大堆叠越高）；  
- 每次处理一道菜时，**倒序遍历金额**的过程会用“像素箭头”高亮当前计算的`j`，选菜时`dp[j]`的堆叠块会“增长”，伴随“叮”的音效；  
- 最终`dp[M]`的堆叠块会闪烁，播放“胜利”音效，表示找到所有方案。  


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码可读性、优化程度等维度筛选了5份优质题解，帮你快速抓住核心！  
</eval_intro>


### 题解一：二维DP的清晰示范（作者：衡屿睿，赞1141）  
* **点评**：这是最基础的二维DP实现，思路像“填表格”一样直观！`f[i][j]`表示“前i道菜凑j元的方案数”，通过三个条件覆盖“钱不够（不选）”“钱刚好（选这道）”“钱有余（选或不选）”的情况。代码逻辑直白，适合初学者理解DP的“状态转移”本质，但空间复杂度`O(N*M)`（100*10000=1e6）对于本题来说完全够用。  


### 题解二：一维DP的降维优化（作者：Dream_zhc，赞628）  
* **点评**：这份题解的亮点是**把二维DP压缩成一维**！通过分析“每次只需要前i-1道菜的结果”，用`dp[j]`直接覆盖前一次的状态。关键是**倒序遍历金额**（从M到`a[i]`），避免同一道菜被重复选择。代码简洁高效，空间复杂度降到`O(M)`（1e4），是竞赛中的常用写法。  


### 题解三：记忆化搜索的另一种思路（作者：XZYQvQ，赞75）  
* **点评**：如果你觉得DP的“递推”不好想，可以试试这份**记忆化搜索**的题解！它用`dfs(c, k)`表示“选第c道菜后，剩余k元的方案数”，通过`f[c][k]`保存已计算的结果，避免重复递归。这种写法更接近“暴力搜索+优化”，适合理解DP的“无后效性”（已经计算过的子问题不需要再算）。  


### 题解四：边读边处理的小技巧（作者：康师傅，赞42）  
* **点评**：这份题解的巧思是**边读菜价边更新dp数组**！因为菜是按顺序处理的，读完一道菜就直接用它更新`dp`，不需要额外保存所有菜价。同时，它把“选这道菜”的逻辑拆成“倒序更新金额”和“单独加1”（处理刚好选这道菜的情况），避免了`dp[0]=1`的初始化误区，适合理解“动态规划的顺序性”。  


### 题解五：递归剪枝的暴力优化（作者：ipcon，赞4）  
* **点评**：这份题解展示了“暴力搜索→记忆化剪枝”的完整过程！作者先用纯递归（`dg`函数）实现，但会重复计算子问题；然后用`ans[i][m]`保存结果（`dg_jz`函数），把时间复杂度从指数级降到`O(N*M)`。这种“从暴力到优化”的思路，能帮你理解DP的本质是“避免重复计算”。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题的关键，是突破三个“认知门槛”：  
</difficulty_intro>


### 1. 状态定义：`dp[j]`到底表示什么？  
**难点**：很多初学者会把`dp[j]`定义为“最多花j元的方案数”，但本题要求“刚好花j元”，所以`dp[j]`必须严格对应“刚好j元的方案数”。  
**策略**：用“例子验证”——比如样例输入`4 4`（菜价1、1、2、2），`dp[4]`应该等于3（选两个1+一个2？不，样例的正确方案是：1+1+2、1+2+1、2+2？不对，样例的正确输出是3，对应：选第1、2、3道菜（1+1+2）、第1、2、4道菜（1+1+2）、第3、4道菜（2+2）？不，等一下，样例输入是4道菜，价格1、1、2、2，M=4，正确方案是：  
- 选第1、2、3道菜（1+1+2=4）  
- 选第1、2、4道菜（1+1+2=4）  
- 选第3、4道菜（2+2=4）  
共3种，所以`dp[4]`=3。如果`dp[j]`定义错了，结果会完全不对。  


### 2. 状态转移：为什么是`dp[j] += dp[j - a[i]]`？  
**难点**：初学者容易混淆“选或不选”的逻辑——选第i道菜时，方案数是“用j - a[i]元的方案数”（因为加上a[i]刚好是j）；不选时，方案数是“原来的dp[j]”（继承前i-1道菜的方案数）。  
**策略**：用“小例子推导”——比如处理第一道菜（价格1）：  
- `dp[0] = 1`（初始）  
- 倒序遍历j从4到1：`dp[1] += dp[0]` → `dp[1] = 1`（选这道菜）  
处理第二道菜（价格1）：  
- 倒序遍历j从4到1：`dp[1] += dp[0]` → `dp[1] = 2`（选第二道菜，或选第一道菜）；`dp[2] += dp[1]` → `dp[2] = 1`（选第一+第二道菜）  
这样一步步推导，就能理解状态转移的含义。  


### 3. 初始化：为什么`dp[0] = 1`？  
**难点**：很多人会忽略`dp[0] = 1`，导致结果少算“只选一道菜”的情况（比如选价格为a[i]的菜，对应`dp[a[i]] += dp[0]`）。  
**策略**：用“边界情况验证”——如果只有一道菜价格为5，M=5，那么方案数是1。如果`dp[0] = 1`，则`dp[5] += dp[0]` → `dp[5] = 1`，正确；如果`dp[0] = 0`，则`dp[5] = 0`，错误。  


### ✨ 解题技巧总结  
- **从二维到一维**：当DP的状态只依赖前一层时，用倒序遍历压缩空间；  
- **初始化的重要性**：`dp[0] = 1`是所有方案的“起点”，必须记住；  
- **暴力→优化**：如果想不通DP，可以先写暴力搜索，再加记忆化剪枝，逐步理解。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一份**通用的一维DP实现**，它是竞赛中的“标准写法”，简洁高效！  
</code_intro_overall>


### 本题通用核心C++实现参考  
* **说明**：本代码综合了Dream_zhc、WilliamPen等题解的思路，是01背包方案数的“最简模板”。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, m;
    cin >> n >> m;
    vector<int> a(n + 1);  // 菜价数组（从1开始）
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
    }

    vector<int> dp(m + 1, 0);  // dp[j]表示刚好花j元的方案数
    dp[0] = 1;  // 初始化：0元的方案数是1（什么都不选）

    for (int i = 1; i <= n; ++i) {  // 遍历每道菜
        for (int j = m; j >= a[i]; --j) {  // 倒序遍历金额，避免重复选
            dp[j] += dp[j - a[i]];
        }
    }

    cout << dp[m] << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. 读取输入：n（菜的数量）、m（总金额）、a数组（每道菜的价格）；  
  2. 初始化`dp`数组：`dp[0] = 1`，其余为0；  
  3. 遍历每道菜，倒序遍历金额j（从m到a[i]），更新`dp[j]`（选这道菜的方案数+不选的方案数）；  
  4. 输出`dp[m]`（刚好花m元的方案数）。  


<code_intro_selected>  
接下来，我们剖析优质题解中的“核心片段”，看看不同写法的亮点！  
</code_intro_selected>


### 题解一：二维DP的清晰示范（作者：衡屿睿）  
* **亮点**：用二维数组直观展示“前i道菜的方案数”，适合初学者理解状态转移。  
* **核心代码片段**：  
```cpp
int a[101], f[101][10001] = {0};
for (int i = 1; i <= n; ++i)
    for (int j = 1; j <= m; ++j) {
        if (j == a[i]) f[i][j] = f[i-1][j] + 1;
        if (j > a[i]) f[i][j] = f[i-1][j] + f[i-1][j-a[i]];
        if (j < a[i]) f[i][j] = f[i-1][j];
    }
```
* **代码解读**：  
  - `f[i][j]`表示“前i道菜凑j元的方案数”；  
  - 当j等于a[i]：方案数=前i-1道菜凑j元的方案数（不选）+1（选这道菜）；  
  - 当j大于a[i]：方案数=不选（`f[i-1][j]`）+选（`f[i-1][j-a[i]]`）；  
  - 当j小于a[i]：只能不选，继承`f[i-1][j]`。  
* **学习笔记**：二维DP是理解DP的“入门砖”，虽然空间大，但逻辑清晰。  


### 题解二：一维DP的降维优化（作者：Dream_zhc）  
* **亮点**：把二维数组压缩成一维，用倒序遍历避免重复选择，空间复杂度从`O(N*M)`降到`O(M)`。  
* **核心代码片段**：  
```cpp
int a[N], f[10010];
f[0] = 1;
for (int i = 1; i <= n; ++i)
    for (int j = m; j >= a[i]; --j)
        f[j] += f[j - a[i]];
```
* **代码解读**：  
  - `f[j]`直接表示“当前处理到第i道菜时，凑j元的方案数”；  
  - 倒序遍历j：因为处理第i道菜时，`f[j - a[i]]`还没被更新（还是前i-1道菜的结果），避免同一道菜被选多次。  
* **学习笔记**：倒序遍历是一维DP的“灵魂”，必须记住！  


### 题解三：记忆化搜索的递归实现（作者：XZYQvQ）  
* **亮点**：用递归+记忆化，把DP转化为“搜索子问题”，更符合直觉。  
* **核心代码片段**：  
```cpp
LL f[105][10005], v[105], n, m, ans;
LL dfs(LL c, LL k) {
    if (f[c][k]) return f[c][k];  // 已计算过，直接返回
    if (v[c] > k) return 0;       // 钱不够，无法选
    if (v[c] == k) return 1;      // 刚好选这道菜，方案数1
    for (LL i = c + 1; i <= n; ++i) {
        f[c][k] += dfs(i, k - v[c]);  // 选第c道菜，递归处理后面的菜
    }
    return f[c][k];
}
```
* **代码解读**：  
  - `dfs(c, k)`表示“选第c道菜后，剩余k元的方案数”；  
  - `f[c][k]`保存已计算的结果，避免重复递归；  
  - 递归终止条件：钱不够（返回0）、刚好够（返回1）。  
* **学习笔记**：记忆化搜索是DP的“另一种打开方式”，适合理解“子问题”的概念。  


## 5. 算法可视化：像素动画演示  

<visualization_intro>  
为了让你“看明白”01背包的方案数计算，我设计了一个**8位像素风的互动演示**，像玩FC游戏一样学算法！  
</visualization_intro>


### 动画主题与核心内容  
- **主题**：像素小A在菜摊前“凑钱点菜”，目标是用M元刚好买完菜。  
- **核心演示**：  
  1. 菜摊有N个像素化的菜（不同颜色，标价格）；  
  2. 右侧是“金额方案柱”（每个柱的高度=dp[j]，数值越大柱越高）；  
  3. 每次处理一道菜时，倒序遍历金额的过程会用“像素箭头”高亮，选菜时方案柱会“增长”，伴随“叮”的音效；  
  4. 最终`dp[M]`的柱会闪烁，播放“胜利”音效，表示找到所有方案。  


### 动画设计细节  
1. **场景初始化**：  
   - 屏幕左侧是“像素菜摊”（16x16的像素块，菜价用8位字体显示）；  
   - 右侧是“金额方案柱”（从0到M，每个柱用3x3的像素块堆叠）；  
   - 底部控制面板有“单步”“自动”“重置”按钮，以及“速度滑块”（1x8像素的滑动条）；  
   - 播放8位风格的背景音乐（类似《超级马里奥》的轻快旋律）。  

2. **算法执行步骤**：  
   - **初始化**：`dp[0]`的柱显示为1（1个像素块），其余为0；  
   - **处理第i道菜**：菜摊中的第i道菜闪烁（红色），右侧箭头从M开始倒序移动，每到一个j（≥a[i]），`dp[j]`的柱会“增加”`dp[j - a[i]]`的高度（比如`dp[4]`从1变成3，柱高从1像素变成3像素），伴随“叮”的音效；  
   - **完成处理**：所有菜处理完后，`dp[M]`的柱会闪烁黄色，播放“胜利”音效（类似《魂斗罗》的过关声）。  

3. **交互设计**：  
   - **单步执行**：点击“单步”按钮，处理一道菜的一个金额；  
   - **自动播放**：点击“自动”按钮，算法按设定速度（滑块调节）自动执行；  
   - **重置**：恢复初始状态，重新开始演示。  


### 为什么这样设计？  
- **8位像素风**：营造复古游戏的轻松氛围，降低学习压力；  
- **可视化方案柱**：把抽象的`dp[j]`变成直观的“高度”，让方案数的增长“看得见”；  
- **音效反馈**：用“叮”强化“选菜”的动作，用“胜利声”强化结果，帮助记忆。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
掌握了本题的01背包方案数，你可以挑战以下类似问题，巩固思路！  
</similar_problems_intro>


### 通用思路迁移  
01背包的方案数模型，还能解决：  
1. **硬币问题**：用给定面值的硬币，刚好凑成M元的方案数（每个硬币只能用一次）；  
2. **选课问题**：选若干门课，刚好达到学分要求的方案数（每门课只能选一次）；  
3. **物品组合问题**：从N个物品中选若干，总重量刚好等于W的方案数。  


### 洛谷练习推荐  
1. **洛谷 P1048 采药**  
   - 🗣️ **推荐理由**：经典01背包问题，求“最大价值”，可以改编成“刚好采T时间的方案数”，练习状态转移的变形。  
2. **洛谷 P1855 榨取kkksc03**  
   - 🗣️ **推荐理由**：01背包的“双约束”问题（时间+钱），可以拓展到“双维度的方案数”，提升综合能力。  
3. **洛谷 P2066 机器分配**  
   - 🗣️ **推荐理由**：分组背包的变形，求“分配机器到工厂，刚好达到最大利润的方案数”，练习多维度的DP。  


## 7. 学习心得与经验分享  

<insights_intro>  
从题解中，我提取了几个**非常有用的经验**，帮你少走弯路！  
</insights_intro>


### 经验1：初始化`dp[0] = 1`的重要性  
> 来自Dream_zhc的题解：“`f[0] = 1`是因为‘什么都不选’是一种方案，否则选单道菜的情况会漏算。”  
**点评**：这是所有01背包方案数问题的“必踩坑点”，一定要记住——`dp[0]`是方案的起点！  


### 经验2：倒序遍历的原因  
> 来自ipcon的题解：“一维数组正向遍历会覆盖j+1需要的值，倒序遍历才能保证用的是前i-1道菜的结果。”  
**点评**：倒序遍历是一维DP的“关键技巧”，理解它的原理（避免重复选），而不是死记硬背。  


### 经验3：暴力→优化的思维过程  
> 来自XZYQvQ的题解：“我蠢，只会递归，但加个记忆化就过了。”  
**点评**：不要怕写暴力代码！先写出能运行的暴力搜索，再一步步优化，是理解DP的最好方法。  


## 结语  

本次关于“小A点菜”的分析就到这里啦！这道题是**01背包方案数的经典模板**，掌握它能帮你解决一大类“选或不选”的问题。  

记住：DP的核心是“状态定义+状态转移”，多写多练，你一定能突破它！下次我们再一起探索更复杂的动态规划问题~ 💪  


---  
*注：本文所有代码均基于洛谷“小A点菜”的题解整理，感谢各位作者的分享！*

---
处理用时：132.54秒
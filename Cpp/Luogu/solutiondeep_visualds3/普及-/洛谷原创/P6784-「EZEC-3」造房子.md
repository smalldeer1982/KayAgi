# 题目信息

# 「EZEC-3」造房子

## 题目背景

pigstd 要去造房子了。

## 题目描述

pigstd 有 $a$ 个 A 材料和 $b$ 个 B 材料，造**第** $i$ 层楼需要 $i$ 个 A 材料与 $i$ 个 B 材料。

但是 pigstd 觉得房子不够高，于是他拿出了 $c$ 块钱，每块钱都可以用来买 $1$ 个 A 材料或者 $1$ 个 B 材料。

现在 pigstd 想知道，他最多能建多少层楼的房子。

## 说明/提示

**【样例 1 说明】**

pigstd 买 $2$ 个 A 材料和 $1$ 个 B 材料后就有 $3$ 个 A 材料和 $3$ 个 B 材料，最多可以建 $2$ 层楼的房子。

（花费 $1+2$ 个 A 材料和 $1+2$ 个 B 材料）

**【样例 2 说明】**

pigstd 买 $3$ 个 A 材料后就有 $4$ 个 A 材料和 $5$ 个 B 材料，最多可以建 $2$ 层楼的房子。

（花费 $1+2$ 个 A 材料和 $1+2$ 个 B 材料）

**【数据规模与约定】**

对于 $100\%$ 的数据，$0 \le a,b,c \le 10^{12}$。

| 数据点编号 | 满足的条件 |
| :----------: | :----------: |
|$1-4,22$| $c = 0$ |
|$5-8,21$| $a,b,c \le 10^{3}$ |
|$9-12$| $a,b,c \le 10^{6}$ |
|$13-20$| $a,b,c \le 10^{12}$ | 

## 样例 #1

### 输入

```
1 2 3```

### 输出

```
2```

## 样例 #2

### 输入

```
1 5 3```

### 输出

```
2```

# AI分析结果

---
# 💡 Kay的C++算法解析：「EZEC-3」造房子 深入学习指南 💡

<introduction>
今天我们来一起分析「EZEC-3」造房子这道C++编程题。这道题看似是“建房子”，实则藏着**贪心策略**和**数学计算**的小智慧——就像你要给两个不一样高的积木塔补砖块，怎么补才能让它们一样高，从而堆出最多层的新塔？本指南会帮你理清思路，掌握核心技巧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略 + 数学（二次方程求解）

🗣️ **初步分析**：
解决这道题的关键，就像“补水桶的短板”——要建最多层楼，必须让A、B材料的数量尽可能接近（因为每层都要同时用i个A和i个B）。这就是**贪心策略**的核心：优先把“万能材料”c用来填补A和B之间的差距，让它们一样多；如果还有剩余，再平分给两者，这样能最大化`min(新A, 新B)`。

而计算“最多能建多少层”，本质是解一个数学问题：找到最大的n，使得前n个自然数的和（1+2+…+n = n(n+1)/2）不超过`min(新A, 新B)`。这一步可以用**二次方程求根公式**快速算出n，不用慢慢枚举！

### 核心算法流程与可视化设计思路
1. **贪心分配c**：先比较A和B的大小，用c填补小的那个，直到两者相等或c用完；剩余的c平分给A和B。
2. **数学计算层数**：用公式`n = floor( (sqrt(8*s +1) -1)/2 )`（s是`min(新A, 新B)`）算出最大n。

**可视化设计小预告**：我们会做一个**像素风格的“材料小管家”游戏**——屏幕上有两个像素桶（A桶、B桶），c是闪烁的金币。动画会展示：金币先“跳进”小桶补短板，补平后再平分到两个桶；然后屏幕下方的“楼层计数器”会用像素数字跳动，显示每一步能建的层数。关键步骤会有“叮”的音效，成功时还会有“啦啦”的胜利音效哦！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速理解不同角度的解题思路～
</eval_intro>

**题解一：云浅知处的O(1)解法**
* **点评**：这份题解直接戳中问题本质——先贪心分配c，再用数学公式算层数，全程O(1)时间复杂度！思路像“直线解题”：先比较A、B的大小，用c补短板，再平分剩余c；最后套公式算n。代码简洁到“不能再删一行”，变量名`x`（大的材料数）、`y`（小的材料数）也很直观，连二次方程的推导都写得明明白白，适合快速掌握核心逻辑。

**题解二：Unordered_OIer的分类讨论+三种求层法**
* **点评**：这份题解像“手把手教你做题”——不仅把c的分配分成3种情况（c=0、补不完短板、补完还有剩），还给出了**枚举、二分、数学公式**三种求层数的方法！尤其是对“为什么用求根公式只取加号”的解释（因为x必须≥0），把数学细节讲透了。代码里的`floor((sqrt(1+8*n)-1)/2)`直接又暴力，新手也能看懂。

**题解三：Aw顿顿的模拟法**
* **点评**：这份题解走“接地气”路线——用`while`循环模拟“一层一层建楼”，累加每层需要的材料，直到超过`min(新A, 新B)`。虽然时间复杂度比数学法高，但胜在“直观”：就像你真的在一块一块搬材料建楼，适合刚学贪心的同学理解“为什么要补短板”。代码里的`sum`变量一步步累加，把“建到第i层需要多少材料”展示得清清楚楚。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**如何分配c**和**如何快速算层数**，我们逐一解决～
</difficulty_intro>

### 关键点1：如何用c最大化min(A,B)？
* **分析**：假设A=1，B=5，c=3——如果把c全给A，A变成4，B还是5，min是4；如果给A2、B1，A=3，B=3，min是3？不对，等一下，其实**补短板才能让min最大**！比如A=1，B=2，c=3：先给A补1（让A=2，和B相等），剩下的2平分给A、B，A=3，B=3，min是3，比全给A（A=4，B=2，min=2）大得多！
* 💡 **学习笔记**：贪心的核心是“补短板”——优先让A和B相等，再平分剩余c！

### 关键点2：如何快速算出最大层数n？
* **分析**：前n层需要的材料总和是1+2+…+n = n(n+1)/2。要找最大的n，使得n(n+1)/2 ≤ s（s是`min(新A, 新B)`）。这是一个二次不等式，用求根公式解出来是`n = floor( (sqrt(8s+1)-1)/2 )`。比如s=3，代入得`(sqrt(25)-1)/2= (5-1)/2=2`，正好对应样例1的输出2！
* 💡 **学习笔记**：遇到“前n项和不超过s”的问题，直接套这个公式，比枚举快100倍！

### 关键点3：如何处理大数范围（1e12）？
* **分析**：题目里a、b、c可以到1e12，普通的int会“爆掉”，必须用`long long`（C++里的64位整数）。比如计算`sqrt(8*s+1)`时，要把s声明为`long long`，否则会溢出。
* 💡 **学习笔记**：看到“1e12”这种大数，第一反应是用`long long`！

### ✨ 解题技巧总结
- 补短板：优先用c让A、B相等，再平分剩余c。
- 套公式：计算层数用`floor( (sqrt(8*s+1)-1)/2 )`。
- 用long long：处理大数范围，避免溢出。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用核心代码**，帮你把握整体框架～
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了“贪心分配c”和“数学公式算层数”的核心思路，逻辑清晰，适合新手模仿。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;

typedef long long LL; // 用LL代替long long，更简洁

int main() {
    LL a, b, c;
    cin >> a >> b >> c;
    
    LL x = max(a, b), y = min(a, b); // x是大的，y是小的
    LL diff = x - y; // A和B的差距
    
    if (diff > c) { // c不够补差距，全给y
        y += c;
    } else { // 补完差距，剩余c平分
        c -= diff;
        y = x; // 现在y等于x了
        y += c / 2; // 平分剩余c
    }
    
    // 计算最大层数n：n(n+1)/2 ≤ y
    LL s = y;
    LL n = (LL)(sqrt(8 * s + 1) - 1) / 2; // 公式直接算
    cout << n << endl;
    
    return 0;
}
```
* **代码解读概要**：
  1. 输入a、b、c，用`max`和`min`找出大的x和小的y。
  2. 计算x和y的差距diff，用c补差距：如果c不够，全给y；否则补完后平分剩余c。
  3. 用公式计算最大层数n，输出结果。


<code_intro_selected>
接下来看3份优质题解的核心片段，学习不同的实现技巧～
</code_intro_selected>

### 题解一：云浅知处的O(1)解法片段
* **亮点**：用`floor`和`sqrt`直接算层数，O(1)时间！
* **核心代码片段**：
```cpp
LL ans = (LL)(floor(sqrt(8 * (y + c) + 1)) - 1) / 2;
```
* **代码解读**：
  > 这段代码就是“数学公式的直接实现”！`sqrt(8*(y+c)+1)`计算根号里的部分，减1后除以2，再用`floor`取整，就是最大的n。比如样例1中y+c=1+3=4？不对，等一下，云浅知处的代码里y是min(a,b)，当diff>c时，y+c就是补后的小值，代入公式就能得到n=2。
* 💡 **学习笔记**：数学公式是最快的计算方式，记得加`LL`强制转换，避免精度问题！

### 题解二：Unordered_OIer的二分法片段
* **亮点**：用二分法算层数，适合理解“前n项和的单调性”！
* **核心代码片段**：
```cpp
long long left = 1, right = 2000000; // 右边界设大一点
long long ans = 0;
while (left <= right) {
    long long mid = (left + right) / 2;
    if (mid * (mid + 1) / 2 <= s) { // 前mid层的和≤s
        ans = mid;
        left = mid + 1; // 尝试更大的mid
    } else {
        right = mid - 1; // 太大了，缩小范围
    }
}
cout << ans << endl;
```
* **代码解读**：
  > 二分法的核心是“前n项和随n增大而增大”（单调递增）。我们找最大的mid，使得前mid项和≤s。比如s=3，mid=2时，2*3/2=3≤3，ans=2；mid=3时，3*4/2=6>3，right=2，循环结束，输出2。
* 💡 **学习笔记**：遇到“单调问题”，二分法是通用解法，即使不会数学公式也能做！

### 题解三：Aw顿顿的模拟法片段
* **亮点**：用循环模拟“建楼”，直观易懂！
* **核心代码片段**：
```cpp
LL s = ...; // 补后的min(A,B)
LL sum = 0, i = 0;
while (true) {
    i++;
    sum += i;
    if (sum > s) { // 超过了，不能建第i层
        cout << i-1 << endl;
        break;
    }
}
```
* **代码解读**：
  > 这段代码像“真的在一层一层建楼”：i是当前层数，sum是前i层需要的材料总和。每循环一次，i加1，sum加i；如果sum超过s，说明不能建第i层，输出i-1。比如s=3，i=1时sum=1≤3；i=2时sum=3≤3；i=3时sum=6>3，输出2。
* 💡 **学习笔记**：模拟法适合理解问题本质，但数据大时会慢（比如s=1e12，要循环1e6次），所以尽量用数学法或二分法！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到贪心分配和层数计算的过程，我设计了一个**像素风格的“材料小管家”游戏**——像玩FC红白机游戏一样学算法！
</visualization_intro>

### 动画设计详情
* **主题**：像素小管家帮pigstd分配材料，建最高的楼！
* **核心演示内容**：
  1. **场景初始化**：屏幕左边是两个像素桶（A桶蓝色，B桶绿色），右边是“万能材料”c（黄色小方块）；下方是“层数计数器”（红色像素数字）；底部有“单步”“自动”“重置”按钮，还有速度滑块。
  2. **贪心分配演示**：
     - 先比较A、B桶的高度（像素块数量），用黄色小方块“跳进”矮的桶，直到两者一样高（比如A=1，B=2，c=3：先跳1个到A，A=2，B=2，剩下2个平分，各加1，A=3，B=3）。
     - 每跳一个小方块，伴随“叮”的音效；补平后，剩余小方块会“分裂”成两个，分别跳进A、B桶，伴随“啪”的音效。
  3. **层数计算演示**：
     - 分配完成后，“层数计数器”开始跳动：从0开始，每跳一次加1，同时屏幕上方显示“前n层需要n(n+1)/2材料”（比如n=1时，显示“1”；n=2时，显示“3”）。
     - 当计数器跳到最大n时，停止跳动，伴随“啦啦啦”的胜利音效，屏幕中央弹出“成功！最多建n层！”的像素字。
* **交互设计**：
  - 单步执行：点击“单步”，每一步只分配一个小方块或计算一层。
  - 自动播放：点击“自动”，动画按设定速度（滑块调节）自动运行。
  - 重置：恢复初始状态，重新开始。
* **复古游戏元素**：
  - 背景音乐：8位风格的“轻快电子乐”，循环播放。
  - 音效：分配小方块时“叮”，平分时“啪”，计算层数时“滴”，成功时“啦啦啦”。
  - 小关卡：把分配过程分成“补短板”“平分剩余”“计算层数”三个小关，完成每关会有“过关！”的提示。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“补短板贪心”和“前n项和计算”，可以试试这些相似问题～
</similar_problems_intro>

### 通用思路迁移
“补短板贪心”常用于**资源分配问题**：比如给两个工厂分配原材料，让它们的产量尽可能接近；“前n项和计算”常用于**累计消耗问题**：比如计算最多能买多少件商品（每件价格递增）。

### 洛谷推荐练习
1. **P1083 借教室**：考察“贪心分配”和“二分答案”，需要判断是否有足够的教室借给每个订单。
2. **P2032 扫描**：用贪心策略选择扫描线，覆盖最多的点，类似“补短板”的思路。
3. **P1208 混合牛奶**：贪心买最便宜的牛奶，最大化购买量，练习“贪心的优先级”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我发现了几个“踩坑小技巧”，分享给你～
</insights_intro>

> **参考经验（来自Unordered_OIer）**：“求根公式里为什么用加号？因为减号会得到负数，而层数不能是负数！”
> **点评**：这个细节很重要！很多同学第一次用求根公式会忘记“层数≥0”，导致结果错误。下次用公式时，记得想“结果是不是正数”～

> **参考经验（来自云浅知处）**：“用long long！用long long！用long long！重要的事情说三遍！”
> **点评**：1e12的范围超过了int的极限（约2e9），必须用long long。如果代码里用了int，会出现“溢出错误”，比如计算8*s+1时，s=1e12，8*s=8e12，int根本装不下！


<conclusion>
本次关于「EZEC-3」造房子的分析就到这里啦！记住：贪心补短板，数学算层数，long long不能忘～ 下次遇到资源分配问题，试着用今天学的技巧解决吧！编程的乐趣在于“用简单的方法解决复杂的问题”，继续加油！💪
</conclusion>

---
处理用时：95.33秒
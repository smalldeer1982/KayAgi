# 题目信息

# 天选之人

## 题目背景

暑假期间，学校不提供午餐，Gnar 只好找伙计们一起点外卖。

尴尬的是，外卖很快送到却没人乐意去校门口拿，毕竟户外可是 $35\degree\!\text{C}$ 高温！此时 Gnar 想到了好主意：“我给一人捏了一张纸团，其中一张写有记号，不如我们抓阄决定，谁抽到带记号的谁去拿！”

于是 Gnar 连续拿了六天的外卖。

这可让他不服又委屈：“换个规则！一人准备三张纸团，五张有记号，每人抽三张，记号最多的去拿！”

Gnar 紧张地展开手中的纸团，两个记号赫然映在眼前。大伙们刚想放声大笑他的非酋运气，有人缓缓举起三张纸片说道：“我也抽到了两个记号……”

## 题目描述

好奇的 Gnar 想研究一般情况下抽到最多记号的人数。他给参与抓阄的 $n$ 人一人准备了 $m$ 张捏好的纸团，一共 $nm$ 张，其中恰好 $k$ 张提前写了记号。随后每个人在均匀打乱的纸团中各抽 $m$ 张。

一个人抽到最多的记号，当且仅当没有人抽到的记号比他还多。请你帮 Gnar 判断是否可能会**恰好** $\boldsymbol{p}$ **个人**抽到最多的记号。Gnar 喜欢追根问底，所以如果有可能，你还需构造每个人抽的纸团中分别有多少带记号、有多少不带记号。

形式化地，假设第 $i$ 个人抽到了 $x_i$ 张带记号的纸团和 $y_i$ 张不带记号的纸团，你的构造应满足：

- $x_i, y_i \ge 0$，$x_i + y_i = m$。
- $\displaystyle \sum_{i = 1}^{n} x_i = k$。
- **有且仅有** $\boldsymbol{p}$ **个互不相同**的 $j$ 使 $\displaystyle x_j = \max_{i = 1}^{n} \{x_i\}$。

## 说明/提示


**【样例解释 #1】**

样例给出了一种满足题述条件的构造。

**【样例解释 #2】**

不论如何，记号的分布从高到低只有三种情况：$\{3,0,0\}$，$\{2,1,0\}$，$\{1,1,1\}$，抽到最多记号的人数分别对应 $1$，$1$，$3$。因此无法构造 $p = 2$ 的方案。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (15 points)：$n,m \le 8$。
- Subtask #2 (15 points)：$n,m \le 100$。
- Subtask #3 (20 points)：$n,m \le 10^5$。
- Subtask #4 (10 points)：$p = 1$。
- Subtask #5 (40 points)：无特殊限制。

对于所有的数据，保证 $1 \le p \le n \le {10}^5$，$1 \le m \le {10}^9$，$0 \le k \le n m$。

## 样例 #1

### 输入

```
3 3 5 2```

### 输出

```
YES
2 1
2 1
1 2```

## 样例 #2

### 输入

```
3 3 3 2```

### 输出

```
NO```

## 样例 #3

### 输入

```
3 3 5 3```

### 输出

```
NO```

# AI分析结果

# 💡 Kay的C++算法解析：天选之人 深入学习指南 💡

今天我们来一起分析“天选之人”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心构造技巧，并掌握解题的关键步骤。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心构造（编程技巧应用）

🗣️ **初步分析**：  
解决“天选之人”的关键，就像**分蛋糕**——要让恰好p个小朋友拿到最大的蛋糕块，你得先给这p个小朋友分“尽可能大但不超量”的蛋糕：每个块不能超过他们的“胃容量”m（每人最多拿m张纸团），也不能超过总蛋糕k的p分之一（否则总蛋糕不够分）。剩下的蛋糕，要分给其他小朋友，且每人最多拿“最大块减1”的量——这样就能保证只有这p个小朋友的蛋糕最大啦！  

**题解核心思路**：  
所有优质题解的思路高度一致：  
1. **分配最大值**：先给p个人分配最大值`q = min(m, k/p)`（既不超每人的m张，也不超总记号k的p均分）；  
2. **处理剩余记号**：剩下的`rest = k - p*q`个记号，要分给剩下的`n-p`人，且每人最多拿`q-1`个（确保不超过最大值）；  
3. **验证可行性**：如果`rest > (n-p)*(q-1)`，说明即使剩下的人都拿`q-1`还不够分，此时无解。  

**可视化设计思路**：  
我们可以用**8位像素风的“分蛋糕游戏”**演示：  
- 用红色像素块代表“最大块蛋糕”（p个），蓝色代表“小块蛋糕”（其他）；  
- 分配时，红色块会“跳”到p个小朋友的位置，伴随“叮”的音效；  
- 剩余块用蓝色块逐个分配，每分配一个蓝色块，会有“滴”的音效；  
- 若剩余块不够分`q-1`，会有“咔嗒”声提示，并将剩余块全部分给当前小朋友；  
- 动画支持“单步执行”和“自动播放”，小朋友的位置会高亮显示当前分配状态。  


## 2. 精选优质题解参考

为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面，筛选了以下优质题解：


### 题解一：（来源：Unordered_OIer）  
* **点评**：这份题解的思路堪称“构造题的标准模板”——先算最大值`q`，再分p个`q`，最后处理剩余。代码逻辑清晰，变量命名直观（`rest`表示剩余记号，`fflag`标记是否还能分`q-1`），甚至加了`check`函数验证结果的正确性。特别值得学习的是**剩余记号的处理方式**：先尽可能给每人分`q-1`，不够时全部分给当前人，这种贪心策略完美保证了剩余的人拿的都小于`q`。


### 题解二：（来源：HanPi）  
* **点评**：这道题解用“图示+数学推导”的方式把思路讲得明明白白！作者把记号分布看成“分层结构”：先给p人分最大的`hp`，再把剩余的平均分给其他人，并计算“是否有人会分到等于`hp`的量”。特别的是，作者还处理了`n=p`的特判（此时必须均匀分配），考虑问题非常全面。代码简洁，用`mymin`函数避免了重复计算，可读性很高。


### 题解三：（来源：Maxmilite）  
* **点评**：这份题解的“正确性证明”很有启发性——为什么要让p人拿最多？因为“拿得多了，剩下的人自然拿得少”。作者用“damedane”（最大值）和“dameyo”（剩余分配量）的比喻，把抽象的构造过程变得生动。代码中的特判（剩余记号的兜底分配）和验证条件（剩余记号是否能被`n-p`人分完），都体现了作者对问题的深刻理解。


### 题解四：（来源：Meaninglessness）  
* **点评**：这道题解的“贪心填充剩余记号”思路很巧妙——当剩余记号不够均匀分配时，用“贪心思想让剩余的人拿满`q-1`”，直到用完所有记号。作者还加了`check`函数统一验证方案的正确性，避免了边界错误。特别值得注意的是`n=p`的特判（此时必须`k`能被`p`整除），覆盖了所有边界情况。


## 3. 核心难点辨析与解题策略

在解决这个问题时，大家常遇到以下3个核心难点，我们逐一拆解：


### 1. 如何确定“最大值q”的大小？  
* **难点**：q要满足两个条件——不能超过每人的上限m（每人最多拿m张），也不能超过总记号的p均分（否则p人分不完q）。  
* **策略**：`q = min(m, k/p)`（用整数除法自动取整）。  
* 💡 学习笔记：q是p人能拿到的“最大合理值”，既不超量，也不浪费。


### 2. 如何处理剩余记号，确保其他人拿的都小于q？  
* **难点**：剩余的`rest`个记号，要分给`n-p`人，且每人最多拿`q-1`个（否则会有人和p人拿的一样多）。  
* **策略**：让剩余的人先拿`q-1`个，直到`rest`不够；若`rest`还有剩余，全部分给当前人；最后剩下的人拿0个。  
* 💡 学习笔记：“最多拿q-1”是关键——这样能彻底保证其他人的记号数小于q。


### 3. 特判“n=p”的情况？  
* **难点**：当所有人都是“天选之人”时，必须让每人拿的记号数相同（否则无法“恰好p人拿最多”）。  
* **策略**：若`n=p`，则`k`必须能被`p`整除（否则无法均匀分配），此时每人拿`k/p`个。  
* 💡 学习笔记：特判是构造题的“必考题”，要仔细考虑边界情况。


### ✨ 解题技巧总结  
1. **贪心优先**：先分配最大的量，再处理剩余，是构造题的常用思路；  
2. **边界验证**：每次分配后，要验证是否满足“不超过上限”“不超过总量”；  
3. **特判覆盖**：不要漏掉`n=p`、`rest=0`等特殊情况。


## 4. C++核心代码实现赏析

先看一个**通用核心实现**，再剖析优质题解的关键片段。


### 本题通用核心C++实现参考  
* **说明**：本代码综合了Unordered_OIer和HanPi的思路，是构造题的典型实现。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;

const int N = 1e5 + 5;
ll x[N], y[N];

int main() {
    ll n, m, k, p;
    cin >> n >> m >> k >> p;

    ll q = min(m, k / p); // 最大值
    if (k - q * p > (n - p) * (q - 1)) { // 剩余太多，无法分配
        cout << "NO" << endl;
        return 0;
    }

    // 分配p个最大值
    for (ll i = 1; i <= p; ++i) {
        x[i] = q;
        y[i] = m - q;
    }

    // 处理剩余记号
    ll rest = k - q * p;
    bool fflag = true; // 是否还能分q-1
    for (ll i = p + 1; i <= n; ++i) {
        if (fflag && rest >= q - 1) { // 可以分q-1
            x[i] = q - 1;
            rest -= q - 1;
        } else if (rest <= 0) { // 没有剩余
            x[i] = 0;
        } else { // 剩余不够q-1，全部分给当前人
            x[i] = rest;
            rest = 0;
            fflag = false;
        }
        y[i] = m - x[i];
    }

    cout << "YES" << endl;
    for (ll i = 1; i <= n; ++i) {
        cout << x[i] << " " << y[i] << endl;
    }

    return 0;
}
```
* **代码解读概要**：  
  1. 读取输入，计算最大值`q`；  
  2. 验证剩余记号是否可分配（`rest > (n-p)*(q-1)`则无解）；  
  3. 分配p个`q`给前p人；  
  4. 用`rest`处理剩余记号，分给剩下的人，确保每人最多拿`q-1`；  
  5. 输出结果。  


### 题解一（Unordered_OIer）核心片段赏析  
* **亮点**：用`fflag`标记是否还能分`q-1`，避免了重复判断。  
* **核心代码片段**：  
```cpp
ll rest = k - q * p;
bool fflag = true;
for (ll i = p + 1; i <= n; i++) {
    if (fflag && rest >= q - 1) {
        x[i] = q - 1;
        rest -= q - 1;
    } else if (rest <= 0) {
        x[i] = 0;
    } else {
        x[i] = rest;
        rest = 0;
        fflag = false;
    }
    y[i] = m - x[i];
}
```
* **代码解读**：  
  - `fflag`是“是否还能分q-1”的开关：当`rest`足够时，继续分`q-1`；  
  - 若`rest`不够`q-1`，就把剩余的全部分给当前人，并关闭`fflag`（后面的人只能拿0）；  
  - `y[i] = m - x[i]`自动计算无记号的纸团数，避免重复计算。  
* 💡 学习笔记：用布尔变量标记状态，能简化循环中的条件判断。


### 题解二（HanPi）核心片段赏析  
* **亮点**：用数学推导处理剩余记号，逻辑更简洁。  
* **核心代码片段**：  
```cpp
ll hp = min(k / p, m);
ll s = hp * p;
ll a = k - s;
ll h = a / (n - p);
ll mod = a % (n - p);
if (hp <= h || hp <= h + (mod > 0 ? 1 : 0)) {
    puts("NO");
    return 0;
}
```
* **代码解读**：  
  - `h`是剩余记号的均分数量（每人拿`h`个）；  
  - `mod`是均分后的余数（`mod`人要多拿1个）；  
  - 若`h + (mod>0)` >= `hp`，说明有人会拿的和p人一样多，此时无解。  
* 💡 学习笔记：用数学公式提前验证可行性，能避免无效分配。


## 4. 算法可视化：像素动画演示（分蛋糕游戏）

### 动画主题  
**像素分蛋糕：天选之人的诞生**（8位FC游戏风格）


### 设计思路  
用复古像素风模拟“分蛋糕”过程，让抽象的构造过程变得直观有趣：  
- **场景**：屏幕左侧是`n`个像素化的“小朋友”（用不同颜色的方块表示），右侧是“蛋糕堆”（红色代表最大块，蓝色代表小块）；  
- **UI**：底部有“开始/暂停”“单步”“重置”按钮，以及速度滑块；  
- **音效**：分配红色块时播放“叮”声，分配蓝色块时播放“滴”声，分配完成播放“胜利”音效；  
- **游戏化**：每分配完一个小朋友，会弹出“完成1/`n`”的提示，全部完成后显示“天选之人诞生！”的像素动画。


### 动画步骤  
1. **初始化**：小朋友排成一排，蛋糕堆显示`k`个红色块（`p`个）和`k-p*q`个蓝色块；  
2. **分配最大值**：红色块逐个“跳”到前p个小朋友的位置，每个小朋友的位置高亮，伴随“叮”声；  
3. **分配剩余块**：蓝色块逐个“滑”到剩下的小朋友位置，每分配一个，小朋友的位置会闪烁，伴随“滴”声；  
4. **完成**：所有蛋糕分配完毕，小朋友的位置显示各自的蛋糕数量，播放“胜利”音效，弹出“通关”提示。


### 交互设计  
- **单步执行**：点击“单步”按钮，动画会执行一步分配，方便观察每一步的变化；  
- **自动播放**：点击“自动”按钮，动画会以默认速度播放，支持调整速度（滑块从“慢”到“快”）；  
- **重置**：点击“重置”按钮，动画会回到初始状态，重新开始。


## 6. 拓展练习与相似问题

### 通用思路迁移  
本题的贪心构造思路，可用于解决**“分配资源使特定数量的对象获得最大值”**的问题，比如：  
- 分糖果：让p个小朋友拿到最多的糖果，其他人拿到的都更少；  
- 分配任务：让p个员工承担最多的任务，其他人承担更少的任务。


### 洛谷练习推荐  
1. **洛谷 P1090 合并果子**（贪心构造，合并最小的两堆果子）  
   - 推荐理由：练习贪心策略的基础题，培养“优先处理最小/最大值”的思维。  
2. **洛谷 P2014 选课**（树形DP+构造，选择课程使学分最大）  
   - 推荐理由：结合树形结构的构造题，练习“优先选择关键节点”的思路。  
3. **洛谷 P3817 小A的糖果**（贪心分配，避免相邻小朋友的糖果数超过限制）  
   - 推荐理由：练习“边界约束下的贪心构造”，覆盖更多边界情况。


## 7. 学习心得与经验分享

### 参考经验（来自Unordered_OIer）  
> “我在写代码时，加了`check`函数验证结果，避免了很多边界错误。比如`sum != k`或者`cnt != p`的情况，都能通过`check`函数及时发现。”  
* **点评**：这位作者的经验非常实用！构造题容易出现“看起来对但实际错”的边界错误，用`check`函数验证结果，能快速定位问题。比如`sum != k`说明记号数算错了，`cnt != p`说明最大值的人数不对，这些错误都能通过`check`函数提前发现。


## 总结  
本次关于“天选之人”的C++解题分析就到这里。这道题的核心是**贪心构造**：先分最大值，再处理剩余，确保只有p人拿到最多。通过可视化的“分蛋糕游戏”，我们能更直观地理解每一步的分配过程；通过优质题解的代码赏析，我们能掌握构造题的关键技巧。  

记住，构造题的关键是“想清楚每一步的约束条件”——只要保证每一步都满足“不超量、不违规”，就能构造出正确的方案。下次遇到构造题，不妨试试“先分最大值，再处理剩余”的思路，你会发现很多问题都能迎刃而解！💪

---
处理用时：85.95秒
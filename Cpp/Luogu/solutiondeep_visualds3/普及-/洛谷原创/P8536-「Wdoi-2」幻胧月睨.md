# 题目信息

# 「Wdoi-2」幻胧月睨

## 题目背景

**Problem Number:** $\textit{39}$

**背景与题目无关，选手可以直接看下面的「简要题意」。**

那是在竹取物语之后的故事了，幻想乡距离与现实隔绝也已经过去了百年时光。

地上人向月球发起了侵略战争之后，一只名叫**铃仙**的月兔舍弃了同伴，死里逃生，逃到了在幻想乡内的永远亭，来到了辉夜与永琳的身边，生活得安稳而舒适。

又过了数十年，铃仙接收到了来自月球的使唤，被要求强制返回月球。辉夜与永琳商量了下，决定不将铃仙交还予月球。但为了避免造成麻烦，辉夜与永琳决定将满月消失在地上，只留下一轮虚假的月亮。

-----

为了方便调查异变，八云紫运用自己的能力，将整个幻想乡变成了永夜。

被穿梭回异变发生当时的四组主角，共八人。除了依然留有记忆，可以来回穿梭在虚与实的境界的八云紫之外，其他的人缺乏了记忆，重新开始踏上夺回幻想乡的满月的征途。

在慧音的指引之下，她们来到了迷途竹林，在她们的面前，是一只名叫铃仙的月兔。

## 题目描述

### 简要题意

给定一个长度为 $n$ 的 01 串 $b$，要求构造一个 $n$ 阶排列 $a$，满足，对于 $a_i(2\le i\le n)$，记 $m_i=\max_{j=1}^{i-1}\{a_j\}$，则：
  - 若 $b_i=1$，则 $a_i>m_i$;
  - 否则 $a_i<m_i$。

可以证明，总存在一个数列 $a$ 满足以上条件。

**如果有多组解，输出任意一种。**

同时注意到 $b_1$ 的取值是任意的，对数列 $a$ 没有影响。

### 原始题意

铃仙拥有操纵狂气程度的能力，换而言之，就是操纵物体的波长、振幅以及相位。这种能力为主角制造了种种障碍——例如操纵光波，会让弹幕虚虚实实，甚至会出现虚假的自我，对躲避弹幕造成极大的干扰。

以符卡「幻胧月睨」为例。「幻胧月睨」中一共有 $n$ 个弹幕，每个弹幕都会有一个相位，相位非 $0$ 即 $1$。这些弹幕的相位会构成一个长度为 $n$ 的数列 $\{b_i\}$。

铃仙会操纵这些弹幕的相位，将其变得千奇百怪。具体而言，被操纵了之后的弹幕的相位是一个长度为 $n$ 的**排列** $\{a_i\}$，即 $1 \sim n$ 的数字都会**不重不漏**地出现在这个序列之中。

为了加大主角躲避弹幕的难度，铃仙会设置一个阈值。对于每一个元素 $a_i$，阈值是其**前缀**的**最大**值，即 $a_1,a_2,\dots,a_{i-1}$ 中的最大值。若原来的第 $i$ 个弹幕的相位为 $1$，则被操纵后的弹幕的相位要**大于**这个阈值，否则被操纵后的弹幕的相位要**小于**这个阈值。

显然的是，根据铃仙的操纵规则，无论原本的弹幕的相位如何，都是存在可能的操纵方案的。由于主角们失去了记忆，而找回月亮的时间已经所剩不多了，而且弹幕战对时间的把控要求极高。她们找到了你，希望你能够对铃仙原本的弹幕相位，给出**任意一种**操作后的弹幕相位，来为她们的闪避弹幕进行准备。

## 说明/提示

### 样例解释

- 对于数据 $1$，显然 $a_2>1,a_3>2$。
- 对于数据 $2$，显然 $a_2<2,a_3>2$。
- 对于数据 $3$，显然 $a_2>1,a_3<3,a_4>3$。\
  注意到 $a=\{2,3,1,4\}$ 同样满足要求。

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{Subtask 依赖} & \textbf{分值}\\\hline
1 & 10 & - & - & 5\\\hline
2 & 10^5 & \textbf{A} & - & 5 \\\hline
3 & 10^5 & \textbf{B} & - & 20 \\\hline
4 & 10^5 & - & 1,2,3 &70 \\\hline
\end{array}$$

- **特殊性质** $\textbf{A}$：保证 $b_i$ 都相等。
- **特殊性质** $\textbf{B}$：存在整数 $p\in[2,n]$，使得对于 $1\le i<p$，有 $b_i=1$；对于 $n\ge i\ge p$，有 $b_i=0$。

对于全部数据，满足 $1\le T\le 10^4$，$1\le n\le 10^5$，$\forall i\in[1,n],b_i\in\{0,1\}$。

保证单个测试点内 $\sum n\le 5\times 10^5$。

## 样例 #1

### 输入

```
3
3
111
3
101
4
0101```

### 输出

```
1 2 3
2 1 3
1 3 2 4```

# AI分析结果

# 💡 Kay的C++算法解析：「Wdoi-2」幻胧月睨 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（构造类问题）


🗣️ **初步分析**：  
解决这道题的关键，就像**按照“规则搭积木”**——我们需要构造一个排列，让每一块积木（排列中的数）都符合“比之前所有积木大”（b_i=1）或“比之前所有积木小”（b_i=0）的规则。这里的核心技巧是**“分区域构造”**：把小的数（1~cnt0，cnt0是0的个数）分给b_i=0的位置，按**降序**摆放；把大的数（cnt0+1~n）分给b_i=1的位置，按**升序**摆放。这样一来：  
- 1的位置的数越来越大，自然满足“比之前所有都大”；  
- 0的位置的数越来越小，而之前的最大数一定是1的位置的数（比所有0的数大），所以满足“比之前所有都小”。  

**核心算法流程**：先统计0的数量cnt0，再逐个位置填充：0的位置用cnt0、cnt0-1…1（降序），1的位置用cnt0+1、cnt0+2…n（升序）。  
**可视化设计思路**：我们用“像素工厂”动画展示构造过程——左边是红色的“小零件盒”（装1~cnt0），右边是蓝色的“大零件盒”（装cnt0+1~n），生产线逐个位置取零件：取大零件时播放“叮”声，取小零件时播放“啪”声，直观看到每个数的来源。


## 2. 精选优质题解参考

为大家筛选了3份思路清晰、代码简洁的优质题解：


### 题解一：chen_zhe（思路清晰，构造逻辑严谨）  
* **点评**：这份题解的核心是“分区域构造”——统计0的数量后，用降序的小数填0的位置，升序的大数填1的位置。思路直白，正确性证明透彻（小数降序保证小于前缀最大，大数升序保证大于前缀最大）。代码风格简洁，变量名`cnt0`、`cnt1`含义明确，处理多组测试用例的逻辑清晰，是最容易理解的构造方法。


### 题解二：McIron233（倒序处理，双向队列巧思）  
* **点评**：此题解用**倒序遍历+双向队列**的技巧，把问题转化为“取最大/最小可用数”。倒序处理时，b_i=1取当前最大数（队尾），b_i=0取当前最小数（队头）。这种方法跳出了“正序构造”的思维定式，用数据结构简化了选择过程，代码同样高效（O(n)时间），适合喜欢“换个角度想问题”的同学。


### 题解三：AirQwQ（代码精简，同核心逻辑）  
* **点评**：这份题解的思路和chen_zhe一致，但代码更精简——用`lq`统计0的个数，直接通过`lq - cntq`（0的位置）和`lq + cntl`（1的位置）计算数值。代码中的“不加括号就寄了”的注释，提醒了运算符优先级的细节，是很实用的编程小提醒。


## 3. 核心难点辨析与解题策略

### 核心难点与解决策略

1. **如何保证构造的数满足规则？**  
   - **分析**：直接构造容易混乱，比如随便填数可能导致“前面的数比后面大”，破坏规则。  
   - **解决**：分区域构造——小数（0的位置）降序、大数（1的位置）升序。这样1的位置的数必然越来越大，0的位置的数必然小于之前的最大数（1的位置的数）。

2. **如何处理大规模数据？**  
   - **分析**：n可以到1e5，嵌套循环会超时。  
   - **解决**：用O(n)的线性构造法，只需遍历两次字符串（一次统计0的数量，一次填充结果），没有额外开销。

3. **如何验证构造方法的正确性？**  
   - **分析**：构造类问题最怕“想当然”，比如以为“随便填”能过，但实际不符合条件。  
   - **解决**：用样例验证+逻辑证明。比如样例2中，0的个数是1，0的位置填1，1的位置填2、3，结果2 1 3完全符合规则。


### ✨ 解题技巧总结
- **构造类问题找“模式”**：不要盲目尝试，先找满足条件的规律（比如本题的“小数降序、大数升序”）。  
- **统计关键数量**：0的个数是构造的核心，它决定了小数的范围。  
- **倒序处理简化问题**：如果正序构造麻烦，可以试试倒序（比如McIron233的方法）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了chen_zhe题解的思路，是最清晰的核心实现。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <string>
using namespace std;

const int MAX_N = 1e5 + 5;
char ch[MAX_N]; // 存储b字符串（从索引1开始）

int main() {
    ios::sync_with_stdio(false); // 加速输入输出
    cin.tie(nullptr);

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n >> (ch + 1); // 读入n和字符串（ch[1]是第一个字符）

        int cnt0 = 0;
        for (int i = 1; i <= n; ++i) {
            if (ch[i] == '0') cnt0++; // 统计0的个数
        }

        int num0 = cnt0; // 0的位置用num0、num0-1…1
        int num1 = cnt0 + 1; // 1的位置用num1、num1+1…n
        for (int i = 1; i <= n; ++i) {
            if (ch[i] == '0') {
                cout << num0 << ' ';
                num0--;
            } else {
                cout << num1 << ' ';
                num1++;
            }
        }
        cout << '\n';
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 加速输入输出：`ios::sync_with_stdio(false)`和`cin.tie(nullptr)`是处理大数据的常用技巧，避免超时。  
  2. 统计0的个数：遍历字符串，记录有多少个0（`cnt0`）。  
  3. 填充结果：0的位置输出`num0`（从cnt0递减），1的位置输出`num1`（从cnt0+1递增）。


### 针对各优质题解的片段赏析

#### 题解一：chen_zhe（分区域构造）  
* **亮点**：逻辑最直白，正确性最容易理解。  
* **核心代码片段**：
```cpp
int cnt0 = 0;
for (int i = 1; i <= n; ++i) {
    if (ch[i] == '0') cnt0++;
}
int num0 = cnt0, num1 = cnt0 + 1;
for (int i = 1; i <= n; ++i) {
    ch[i] == '0' ? cout << num0-- << ' ' : cout << num1++ << ' ';
}
```
* **代码解读**：  
  - `cnt0`统计0的个数，决定了小数的范围（1~cnt0）和大数的起点（cnt0+1）。  
  - 循环中，`num0--`让0的位置的数越来越小，`num1++`让1的位置的数越来越大。比如样例2中，cnt0=1，0的位置输出1，1的位置输出2、3，结果正好是2 1 3。  
* **学习笔记**：分区域构造是解决“满足线性规则”问题的常用技巧，关键是找到“分割点”（如本题的cnt0）。


#### 题解二：McIron233（倒序+双向队列）  
* **亮点**：倒序处理简化逻辑，用双向队列维护可用数。  
* **核心代码片段**：
```cpp
int hed = 1, til = n; // hed是当前最小可用数，til是当前最大可用数
for (int i = n; i >= 1; --i) {
    if (ch[i] == '1') a[i] = til--; // 取最大数
    else a[i] = hed++; // 取最小数
}
```
* **代码解读**：  
  - 倒序遍历：从最后一个位置往前填数。比如样例2，倒序处理i=3（b=1）取til=3，i=2（b=0）取hed=1，i=1（b=1）取til=2，结果a=[2,1,3]。  
  - 双向队列的“替代”：用`hed`和`til`模拟双向队列——`hed++`取队头（最小），`til--`取队尾（最大），不需要实际创建队列，代码更简洁。  
* **学习笔记**：倒序处理能避免“前缀依赖”，比如本题中倒序取数，自动满足前面的规则。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：像素工厂的“规则搭积木”  

### 设计思路  
用8位像素风模拟“零件工厂”，让你直观看到每个数的来源。复古风格能降低学习压力，音效和动画能强化记忆——比如取大零件时的“叮”声，取小零件时的“啪”声，能让你快速记住规则。


### 动画帧步骤与交互设计

1. **场景初始化**：  
   - 左侧是**红色小零件盒**（里面有1~cnt0的像素块，排成一列）。  
   - 右侧是**蓝色大零件盒**（里面有cnt0+1~n的像素块，排成一列）。  
   - 中间是**生产线**（n个空位置，上面显示b字符串的像素化字符）。  
   - 控制面板：开始/暂停、单步、重置按钮；速度滑块（1~5档）；8位风格背景音乐（可选）。

2. **单步执行流程**：  
   - 点击“单步”，处理生产线的下一个位置：  
     - 如果当前b字符是1：从大零件盒取出最左边的蓝色块，滑到生产线位置（伴随“叮”的音效），大零件盒的块向左补位。  
     - 如果当前b字符是0：从小零件盒取出最右边的红色块，滑到生产线位置（伴随“啪”的音效），小零件盒的块向右补位。  
   - 当前操作的块会闪烁，旁边的文字提示“当前取的是大零件（b=1）”或“当前取的是小零件（b=0）”。

3. **自动播放与交互**：  
   - 自动播放：按设定速度连续执行，直到所有位置填满。  
   - 重置：恢复初始状态，重新开始。  
   - 胜利提示：所有位置填满后，生产线的块集体闪烁，播放8位风格的“胜利音效”（比如《超级马里奥》的通关声）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
构造类问题的核心是**找“固定模式”**，比如本题的“分区域构造”，可以迁移到：  
- 构造满足“相邻差不超过k”的序列；  
- 构造满足“前缀和为正”的序列；  
- 构造满足“奇偶交替”的序列。


### 相似练习推荐  
1. **洛谷 P1160 队列安排**：构造一个队列，满足插入规则（如“插入到第k位后面”），锻炼线性结构的构造能力。  
2. **洛谷 P2699 修塔**：构造塔的高度，满足相邻高度差不超过1，强化“分区域构造”的思维。  
3. **洛谷 P8536（本题）**：再做一遍本题，尝试用不同的构造方法（如McIron233的倒序法），巩固技巧。


## 7. 学习心得与经验分享

### 来自题解的经验  
- **chen_zhe的证明意识**：题解中详细证明了“分区域构造”的正确性，提醒我们“构造类问题不能只写代码，还要想清楚‘为什么对’”。  
- **McIron233的倒序技巧**：倒序处理能简化“前缀依赖”问题，比如本题中倒序取数，自动满足前面的规则，是很巧妙的思维转换。  
- **AirQwQ的细节提醒**：代码中的“不加括号就寄了”，提醒我们要注意运算符优先级（比如`lq-(cntq++)`中的括号，避免`lq - cntq`后再++）。


## 8. 总结  
本次分析的核心是**“分区域构造”**——通过统计0的个数，将小的数和大的数分别按降序、升序填充，轻松满足规则。构造类问题的关键是“找规律”，不要盲目尝试，先想清楚“什么样的模式能满足所有条件”，再写代码。  

记住：编程的本质是“解决问题”，而不是“写代码”——先想清楚逻辑，再用代码实现，才能事半功倍！💪


**下次挑战再见！** 🚀

---
处理用时：151.39秒
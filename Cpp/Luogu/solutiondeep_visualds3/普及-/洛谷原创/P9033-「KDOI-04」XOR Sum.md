# 题目信息

# 「KDOI-04」XOR Sum

## 题目背景

凯文一眼秒了这题。

![](https://cdn.luogu.com.cn/upload/image_hosting/lh1xvu75.png)

## 题目描述

给定一个正整数 $n$，请构造一个长度为 $n$ 的**非负整数**序列 $a_1,a_2,\dots,a_n$，满足：

+ 对于所有 $1\le i\le n$，都有 $0\le a_i\le m$。
+ $a_1\oplus a_2\oplus\dots\oplus a_n=k$。其中 $\oplus$ 表示[按位异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)运算。

或者判断不存在这样的序列。

## 说明/提示

**【样例解释】**

对于第 $1$ 组测试数据，有且仅有一个序列满足条件。

对于第 $2$ 组测试数据，由于 $4\oplus 7=3$ 且 $4,7\le10$，所以这是一个合法的答案。同样地，序列 $(2,1)$ 也是一个合法的答案。

对于第 $4$ 组测试数据，可以证明不存在满足要求的序列。

**【数据范围】**

记 $\sum n$ 为单个测试点中所有 $n$ 的值之和。

对于所有测试数据，保证 $1\le T\le 1~000$，$1\le n\le 2\cdot10^5$，$0\le m,k\le 10^8$，$\sum n\le 2\cdot10^5$。

**【子任务】**

**本题开启捆绑测试。**

+ Subtask 1 (18 pts)：$k\le m$。
+ Subtask 2 (82 pts)：没有额外的约束条件。

## 样例 #1

### 输入

```
5
1 2 2
2 3 10
2 11 8
20 200000 99999
11 191 9810```

### 输出

```
2 
4 7 
8 3 
-1
191 191 191 191 191 191 191 191 191 191 191 ```

# AI分析结果

---
# 💡 Kay的C++算法解析：「KDOI-04」XOR Sum 深入学习指南 💡

<introduction>
今天我们来一起分析「KDOI-04」XOR Sum 这道C++编程题。这是一道非常考验**异或性质理解**和**二进制思维**的构造题——我们需要用不超过m的数拼出异或和为k的序列。本指南会帮你梳理核心思路，掌握关键技巧，还会用像素游戏式动画让你直观看到异或的“魔法”！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（异或性质）+ 编程技巧应用`

🗣️ **初步分析**：
解决这道题的关键，是吃透**异或（⊕）**的核心性质——它像“不进位的二进制加法”：相同位相加得0（不进位），不同位相加得1。比如101⊕110=011（对应十进制5⊕6=3）。而本题的核心技巧，就是用这个性质“拼出”k：  
- 如果k本身≤m，直接放一个k，后面补0（因为x⊕0=x，0不影响结果）；  
- 如果k>m，但k的二进制位数和m一样（比如k=11₁₀=1011₂，m=10₁₀=1010₂），我们可以把k拆成两个数：一个是k的最高位（比如1000₂），另一个是剩下的部分（比如0011₂）——这两个数都≤m，且它们的异或刚好是k！  
- 如果k的二进制位数比m多（比如k=1000₂，m=111₂），那肯定拼不出来，直接返回-1。  

**核心难点**：如何快速判断k能否拆成不超过m的数，以及如何拆分。  
**解决方案**：用二进制位数对比判断无解，用“最高位拆分法”或“m⊕k法”构造序列。  

**可视化设计思路**：我们会做一个**像素异或拼图游戏**——用8位像素块代表二进制位（比如黄色块是1，灰色块是0），左边是目标k的二进制图，右边是待构造的序列槽。你可以拖动像素块到序列槽，每拖一块，系统会实时显示当前异或和（用彩色高亮变化的位）。比如拆k=11（1011）时，拖动“1000”块到第一个槽，再拖动“0011”块到第二个槽，剩下的槽自动补0，此时异或和刚好变成1011，伴随“叮”的成功音效！


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、性质应用巧妙度等方面，为你筛选了3份优质题解（≥4星），一起来看看它们的亮点吧！
</eval_intro>

**题解一：JuRuoOIer（思路最系统）**
* **点评**：这份题解把问题拆成“判无解→分情况构造”两步，逻辑像“剥洋葱”一样清晰！它先用`log2`函数计算二进制位数（比如k=11的位数是4），快速判断“k的位数是否超过m”——这一步直接卡死无解情况。然后分两种情况：k≤m时补0，k>m时拆成最高位和剩余部分（比如11拆成8+3）。代码里的`1ll<<(log2(k)-1)`就是取k的最高位（比如log2(11)=4，左移3位得到8），剩下的部分用k减去最高位，完美满足两个数都≤m的条件。整个过程没有多余步骤，像“按公式解题”一样顺手！

**题解二：佬头（构造最简洁）**
* **点评**：这份题解的“神来之笔”是用`m^k`构造第二个数！比如k=11，m=10（二进制1010），m^k=0001（1），刚好≤m。它的逻辑是：既然m和k位数相同，那么m^k一定≤m（因为最高位被异或掉了）。这样构造的序列是“m + (m^k) + 0...”，异或和刚好是m^(m^k)=k。这种方法不用算最高位，直接用异或性质一步到位，代码少了很多判断，太聪明了！

**题解三：Clarinet（性质应用最透彻）**
* **点评**：这份题解把异或的三个性质用活了：①异或位数不增（判无解）；②x⊕0=x（补零）；③a⊕b=c → c⊕b=a（用m求x）。它的`check`函数专门判断k的位数是否超过m，然后对于k>m的情况，直接输出m和k^m——这一步完全不用想“拆分”，直接用性质推导，像“魔法公式”一样管用！代码里的`k^m`是精华，把复杂的拆分变成了一行运算。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有3个，我们逐一拆解，帮你把“难点”变成“必会点”！
</difficulty_intro>

1. **难点1：如何快速判断“无解”？**
    * **分析**：异或的“不进位”性质决定了——如果k的二进制位数比m多，比如k=8（1000₂），m=7（0111₂），那么再怎么拼，序列里的数最多是7（3位），异或和最多也是7（3位），永远到不了8（4位）。  
    * **解决方案**：计算k和m的二进制位数（比如用`log2`函数或循环右移），如果k的位数>m的位数，直接输出-1。  
    * 💡 **学习笔记**：二进制位数是“异或构造”的“天花板”——超过天花板，直接放弃！

2. **难点2：k>m时，怎么拆成两个≤m的数？**
    * **分析**：当k>m但位数相同（比如k=11，m=10），k的最高位肯定是1（比如1000₂），而m的最高位也是1（比如1010₂）。此时，k的最高位≤m（因为位数相同），剩下的部分（k-最高位）肯定<最高位≤m——所以拆成“最高位”+“剩余部分”，两个数都≤m。  
    * **解决方案**：取k的最高位（比如`1ll<<(log2(k)-1)`），剩下的部分是`k-最高位`，或者用`m^k`（更简洁）。  
    * 💡 **学习笔记**：拆分k的关键是“拆最高位”——把大问题变成两个小问题！

3. **难点3：如何用最少的数构造序列？**
    * **分析**：异或的“x⊕0=x”性质太好用了——只要前面几个数拼出k，后面的数补0就行，完全不影响结果。比如n=5，只要前两个数拼出k，后面3个补0，异或和还是k。  
    * **解决方案**：构造序列时，先放拆分后的数，剩下的全补0。  
    * 💡 **学习笔记**：0是异或的“万能填充剂”——用它补长度，省心又高效！

### ✨ 解题技巧总结
- **技巧A：二进制位数判断法**：用循环右移或`log2`快速算位数，判断无解。  
- **技巧B：最高位拆分法**：k>m时，拆成最高位和剩余部分，两个数都≤m。  
- **技巧C：异或性质简化构造**：用`m^k`直接得到第二个数，不用算最高位。  
- **技巧D：0填充法**：用x⊕0=x补全序列长度，减少构造难度。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它综合了优质题解的思路，把“判无解→分情况构造”写成了简洁的逻辑，适合入门学习！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了JuRuoOIer、佬头、Clarinet的题解思路，用最清晰的逻辑覆盖所有情况。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cmath>
    using namespace std;

    // 计算x的二进制位数（比如x=11→4位）
    int get_bits(long long x) {
        if (x == 0) return 1;
        int cnt = 0;
        while (x) {
            cnt++;
            x >>= 1;
        }
        return cnt;
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int T;
        cin >> T;
        while (T--) {
            long long n, k, m;
            cin >> n >> k >> m;
            int bits_k = get_bits(k);
            int bits_m = get_bits(m);
            
            // 情况1：k的位数超过m→无解
            if (bits_k > bits_m) {
                cout << "-1\n";
                continue;
            }
            // 情况2：k≤m→直接放k，补0
            if (k <= m) {
                cout << k;
                for (int i = 1; i < n; ++i) cout << " 0";
                cout << "\n";
                continue;
            }
            // 情况3：k>m但位数相同→拆成两个数
            if (n < 2) { // 不够拆
                cout << "-1\n";
                continue;
            }
            // 方法：用m^k构造（更简洁）
            long long x = m ^ k;
            cout << m << " " << x;
            for (int i = 2; i < n; ++i) cout << " 0";
            cout << "\n";
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码先读入多组测试用例，然后用`get_bits`算k和m的二进制位数——如果k的位数多，直接输出-1；如果k≤m，输出k+补0；如果k>m且n≥2，用`m^k`构造两个数，后面补0。整个逻辑像“流水线”：判无解→简单构造→复杂构造，一步到位！

---

<code_intro_selected>
接下来，我们看3份优质题解的核心代码片段，学习它们的“精华技巧”！
</code_intro_selected>

**题解一：JuRuoOIer（最高位拆分法）**
* **亮点**：用`log2`函数精准取最高位，拆分逻辑明确。
* **核心代码片段**：
    ```cpp
    ll log2(ll x) { // 计算x的二进制位数
        ll ans = 0;
        while (x) { ans++; x /= 2; }
        return ans;
    }
    // 拆分k的代码
    else {
        ll highest = 1ll << (log2(k) - 1); // 取k的最高位（比如11→8）
        cout << highest << " " << (k - highest);
        for (int i = 0; i < n-2; ++i) cout << " 0";
        cout << "\n";
    }
    ```
* **代码解读**：
    > 这段代码的关键是`1ll<<(log2(k)-1)`——`log2(k)`算k的位数（比如11是4位），减1后左移，得到最高位（比如2^3=8）。然后用k减去最高位，得到剩余部分（11-8=3）。这两个数都≤m（因为k和m位数相同），异或起来就是k！  
    > 比如k=11，highest=8，剩余3，8⊕3=11——完美！
* 💡 **学习笔记**：取最高位的公式是`1<<(位数-1)`——记住这个公式，拆分k再也不用愁！

---

**题解二：佬头（m^k简化构造）**
* **亮点**：用异或性质直接构造第二个数，代码少了“算最高位”的步骤。
* **核心代码片段**：
    ```cpp
    else if((m ^ k) <= m && n > 1) {
        for(int i = 2; i < n; ++i) cout << "0 ";
        cout << m << " " << (m ^ k) << "\n";
    }
    ```
* **代码解读**：
    > 这段代码的精华是`m ^ k`——当k>m但位数相同时，m^k一定≤m（比如m=10，k=11，m^k=1≤10）。为什么？因为m和k的最高位都是1，异或后最高位变成0，所以结果肯定<最高位≤m。然后，m⊕(m^k)=k——刚好满足异或和的要求！  
    > 比如m=10，k=11，m^k=1，10⊕1=11——直接拼出k！
* 💡 **学习笔记**：当m和k位数相同时，`m^k`是“万能构造数”——直接用它，不用想拆分！

---

**题解三：Clarinet（位数判断法）**
* **亮点**：用`check`函数封装位数判断，逻辑更模块化。
* **核心代码片段**：
    ```cpp
    bool check(int x, int y) { // 判断x的位数是否≤y的位数
        int xr = 0, yr = 0;
        while (x) { xr++; x /= 2; }
        while (y) { yr++; y /= 2; }
        return xr <= yr;
    }
    ```
* **代码解读**：
    > 这段函数通过循环右移计算x（k）和y（m）的位数，如果k的位数≤m的位数，返回true（有解），否则返回false（无解）。它把“位数判断”封装成函数，代码更干净——比如主函数里只要`if(!check(k,m)) cout<<-1;`，就能快速判无解！
* 💡 **学习笔记**：把重复的逻辑封装成函数，代码会更“优雅”——这是编程的好习惯！


---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让你更直观地理解“异或构造”的过程，我设计了一个**8位像素风的“异或拼图”游戏**——像小时候玩的“拼积木”，但拼的是二进制位！
</visualization_intro>

### 🎮 动画主题：《像素异或探险家》
**核心演示内容**：你是一个像素探险家，需要用“数字块”拼出异或和为k的序列。每个数字块是8位像素画（比如红色块代表8，蓝色块代表3），拖到序列槽里，实时显示当前异或和。

### 🎨 设计思路
用8位像素风是因为它“复古又亲切”——像小时候玩的FC游戏，能降低学习的“距离感”。关键操作加音效（比如拖动块时“咔嗒”一声，拼出k时“叮”的胜利音效），能强化记忆；每拼完一个序列算“过关”，能增加成就感！

### 🕹️ 动画帧步骤与交互关键点
1. **场景初始化**：
   - 屏幕左边是“目标区”：用像素块显示k的二进制（比如k=11→1011₂，黄色块是1，灰色块是0）。
   - 右边是“序列槽”：有n个空槽（比如n=5），每个槽可以放一个数字块。
   - 底部是“控制面板”：有“单步”“自动播放”“重置”按钮，还有速度滑块（从“慢”到“快”）。
   - 背景播放8位风格的BGM（比如《超级马里奥》的轻松旋律）。

2. **算法启动**：
   - 点击“自动播放”，AI会开始“拼序列”：先拖一个“最高位块”（比如8）到第一个槽，再拖“剩余块”（比如3）到第二个槽，后面的槽自动放“0块”（灰色）。
   - 每拖一个块，目标区的对应位会高亮（比如拖8→1000₂，目标区的第4位变黄），同时显示当前异或和（比如8→8，8+3→11）。

3. **核心步骤演示**：
   - **拆分k**：AI拖8块时，会有“拆”的动画（块从k的最高位“切”下来），伴随“咔嚓”音效。
   - **补0**：后面的槽放0块时，会有“滑入”动画，伴随“咻”的轻响。
   - **成功过关**：当异或和等于k时，目标区的所有块会闪烁，播放“胜利”音效（比如《魂斗罗》的通关音乐），屏幕弹出“恭喜过关！”的像素字。

4. **交互设计**：
   - 你可以点击“单步”，自己拖块拼序列——拖错了会有“滴滴”的提示音效，重新拖就行。
   - 速度滑块可以调动画速度：慢速度适合看细节，快速度适合看整体流程。

### 🛠️ 技术实现
用纯HTML/CSS/JavaScript（Canvas API）实现，轻量化——你可以保存成一个文件，本地用浏览器打开就能玩！像素块用`fillRect`画，音效用Web Audio API播放8位音色，交互用`mousedown`和`mousemove`事件处理。


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“异或构造”的技巧后，你可以试试这些相似问题，巩固知识！
</similar_problems_intro>

### 🔍 通用思路迁移
“异或构造”的技巧还能用于：
1. **构造异或路径**：比如在图中找一条路径，异或和为k（洛谷P1469）。
2. **异或子集和**：比如从数组中选子集，异或和为k（洛谷P2114）。
3. **异或对计数**：比如统计数组中异或和为k的数对（洛谷P3943）。

### 📝 洛谷练习推荐
1. **P1469 找筷子**：用异或性质找出现奇数次的数——练习异或的“消去相同数”性质。  
   🗣️ 推荐理由：异或的基础应用，帮你巩固“x⊕x=0”的性质。
2. **P2114 小Z的袜子**：用异或子集和构造——练习异或的“组合”技巧。  
   🗣️ 推荐理由：比本题难一点，需要结合前缀异或和，能提升思维。
3. **P3943 星空**：用异或构造路径——练习异或的“路径拼接”技巧。  
   🗣️ 推荐理由：综合题，需要结合BFS和异或，能锻炼综合能力。


---

## 7. 学习心得与经验分享

<insights_intro>
从题解中，我看到了很多作者的“踩坑经验”，比如：
</insights_intro>

> **经验1（来自JuRuoOIer）**：“赛时我一开始没考虑n=1的情况，结果WA了——后来才发现，n=1时k>m肯定无解！”  
> **点评**：边界条件很重要！比如n=1时，不能拆分k，所以k>m直接返回-1——这是容易漏掉的点。
> 
> **经验2（来自佬头）**：“一开始我用‘拆最高位’的方法，后来发现用m^k更简洁——异或的性质真的要多用！”  
> **点评**：不要局限于一种方法，多尝试用性质简化代码——这能让你的代码更“聪明”！


---

<conclusion>
本次关于「KDOI-04」XOR Sum 的分析就到这里啦！这道题的核心是**异或性质**和**二进制思维**——只要吃透这两点，构造序列就像“拼积木”一样简单。  
记住：编程的乐趣在于“用技巧解决问题”——比如用`m^k`一步构造数，用补0简化序列，这些技巧能让你“事半功倍”！  
下次我们再一起探索更有趣的算法题，加油！💪
</conclusion>

---

---
处理用时：110.57秒
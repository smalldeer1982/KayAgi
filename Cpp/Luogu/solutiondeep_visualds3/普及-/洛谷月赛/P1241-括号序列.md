# 题目信息

# 括号序列

## 题目描述

定义如下规则：

1. 空串是「平衡括号序列」
2. 若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」
3. 若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。


例如，下面的字符串都是平衡括号序列：


- `()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`


而以下几个则不是：


- `(`，`[`，`]`，`)(`，`())`，`([()`


现在，给定一个仅由 `(`，`)`，`[`，`]`构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：
1. 从左到右扫描整个字符串。
2. 对于当前的字符，如果它是一个右括号，考察它与它左侧离它**最近**的**未匹配**的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。

配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $s$ 的长度不超过 $100$，且只含  `(`，`)`，`[`，`]` 四种字符。

## 样例 #1

### 输入

```
([()
```

### 输出

```
()[]()
```

## 样例 #2

### 输入

```
([)```

### 输出

```
()[]()```

# AI分析结果

# 💡 Kay的C++算法解析：括号序列 深入学习指南 💡

<introduction>
  今天我们来一起分析经典的“括号序列”问题！这道题看似简单，却藏着**栈**这个数据结构的巧妙应用——就像叠盘子一样，“后进先出”的特性刚好能帮我们找到最近的未匹配左括号。本指南会帮你理清题意、掌握核心算法，还会用像素动画让你“看”到括号匹配的全过程~
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：栈的应用（编程技巧应用）

🗣️ **初步分析**：
解决“括号序列”问题的关键，是用**栈**来跟踪未匹配的左括号。栈就像你桌上叠的一堆盘子——你只能拿最上面的那个（后进先出），这正好对应题目中“右括号找左边最近未匹配左括号”的规则！  

具体来说：
- 遇到左括号（`(`或`[`），就把它“叠”进栈里（记录位置或字符）；
- 遇到右括号（`)`或`]`），就看栈顶的左括号能不能和它匹配：
  - 能匹配？把栈顶的左括号“拿走”（弹出栈），标记这对括号为已匹配；
  - 不能匹配？或者栈空了？说明这个右括号需要补一个左括号；
- 最后，栈里剩下的左括号都需要补右括号。

**核心难点**：
1. 正确理解题意（不是“最短补全”，而是严格按“最近未匹配左括号”规则）；
2. 用栈跟踪左括号的位置/字符；
3. 准确补全未匹配的括号（左补右，右补左）。

**可视化设计思路**：
我们会用**FC红白机风格的像素动画**展示过程：
- 用不同颜色的像素块表示括号（比如红色`(`、蓝色`[`、灰色`)`、绿色`]`）；
- 栈是屏幕右侧的“像素架子”，左括号入栈时从左滑入架子，右括号匹配时栈顶块弹出并闪烁；
- 补全括号时，会在原括号旁边“蹦出”一个对应颜色的像素块（比如`)`补`(`时，左边出现红色块）；
- 关键操作有音效：入栈“叮”、匹配“咚”、补全“咔”，成功完成有胜利音效~


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面，筛选了4篇优质题解（赞数≥59），帮你快速掌握核心方法~
</eval_intro>

### 题解一：MY（赞1193）
* **点评**：这篇题解超真实！作者先分享了自己的“踩坑经历”——一开始用了错误的双栈方法（分开存小括号和中括号），后来改成**单栈存左括号位置**，思路瞬间清晰。代码中用`c`数组记录每个位置需要补的括号，逻辑简洁：左括号入栈时记录对应右括号，右括号匹配时清除记录，否则补左括号。最后按`c`数组输出，边界处理超严谨，是非常经典的栈应用案例~

### 题解二：YuJieSong（赞266）
* **点评**：作者把题意讲得明明白白！他用**标记数组`b`**记录括号是否匹配：左括号入栈，右括号匹配时标记`b[i] = b[k] = 1`（`k`是栈顶左括号位置）。输出时，未标记的括号直接补全成对（`()`或`[]`）。代码风格清爽，变量名易懂，特别适合初学者理解“标记+补全”的逻辑~

### 题解三：anyway（赞117）
* **点评**：这篇题解的**补全方式超巧妙**！作者用`b`数组存每个位置需要补的括号：左括号入栈时，`b[i]`存对应右括号；右括号匹配时，把栈顶`b`值设为空格（表示不用补），否则`b[i]`存对应左括号。输出时，先补左括号、再输出原字符、最后补右括号，完美覆盖所有情况。代码短小精悍，技巧性很强~

### 题解四：WanderingTrader（赞92）
* **点评**：作者用**`ok`数组**标记匹配状态，逻辑直接：左括号入栈，右括号匹配时标记`ok[k] = ok[i] = 1`（`k`是栈顶位置）。输出时，未标记的括号补全成对。代码中特意强调了“栈空判断”（避免RE），细节处理到位，是竞赛中常用的“稳扎稳打”风格~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在**题意理解**和**栈的正确使用**。结合优质题解，我总结了3个核心难点和解决策略：
</difficulty_intro>

### 1. 难点1：题意理解——不是“最短补全”，而是“按规则匹配后补全”
* **分析**：题目要求“右括号找左边最近未匹配左括号”，哪怕后面有更合适的左括号也不管（比如`([)]`，`)`只能找最近的`(`，`]`只能找最近的`[`，最后补全为`()[()]`）。很多同学一开始误以为要补成最短序列，结果出错。  
* 💡 **学习笔记**：先严格按题目规则匹配，再补全未匹配的括号——规则是“指挥官”，不能自己加戏！

### 2. 难点2：用栈跟踪左括号——存位置还是存字符？
* **分析**：优质题解都选择**存左括号的位置**（比如`stack<int>`），因为需要知道哪个位置的左括号需要补右括号。如果只存字符（比如`stack<char>`），无法定位到原字符串中的位置，补全时会混乱。  
* 💡 **学习笔记**：栈里存“位置”比存“字符”更有用——能精准定位需要补全的括号！

### 3. 难点3：补全括号的时机——左补右，右补左
* **分析**：未匹配的左括号（栈里剩下的）需要补右括号（比如`(`补`)`）；未匹配的右括号（无法匹配栈顶）需要补左括号（比如`)`补`(`）。优质题解用数组（`c`、`b`、`ok`）记录每个位置的补全需求，避免遗漏。  
* 💡 **学习笔记**：用数组“记下来”每个位置要补的括号，输出时按顺序处理，不会乱！

### ✨ 解题技巧总结
1. **栈的选择**：用`stack<int>`存左括号位置，精准定位；
2. **标记数组**：用`bool`或`char`数组记录匹配/补全状态，避免重复判断；
3. **边界处理**：永远先判断栈是否为空（否则会RE）；
4. **补全顺序**：左括号补右，右括号补左，输出时按“补左→原字符→补右”顺序。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼了一个**通用核心实现**——用栈存左括号位置，用`out`数组记录补全需求，逻辑清晰，适合初学者模仿~
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了MY、anyway、WanderingTrader的思路，用栈存左括号位置，`out`数组记录补全括号，最后按顺序输出。
* **完整核心代码**：
```cpp
#include <iostream>
#include <stack>
#include <cstring>
using namespace std;

const int MAXN = 105;
char str[MAXN], out[MAXN]; // str存输入，out存补全的括号

int main() {
    stack<int> st; // 存左括号的位置
    cin >> str;
    int len = strlen(str);

    // 初始化out数组为0（表示不需要补全）
    memset(out, 0, sizeof(out));

    for (int i = 0; i < len; ++i) {
        if (str[i] == '(' || str[i] == '[') {
            st.push(i); // 左括号入栈（存位置）
            out[i] = (str[i] == '(') ? ')' : ']'; // 左括号需要补右括号
        } else if (str[i] == ')' || str[i] == ']') {
            if (!st.empty() && ((str[st.top()] == '(' && str[i] == ')') || (str[st.top()] == '[' && str[i] == ']'))) {
                // 匹配成功，清除补全记录
                out[st.top()] = 0;
                st.pop();
            } else {
                // 匹配失败，补左括号
                out[i] = (str[i] == ')') ? '(' : '[';
            }
        }
    }

    // 输出：先补左→原字符→补右
    for (int i = 0; i < len; ++i) {
        if (out[i] == '(' || out[i] == '[') {
            cout << out[i]; // 补左括号
        }
        cout << str[i]; // 原字符
        if (out[i] == ')' || out[i] == ']') {
            cout << out[i]; // 补右括号
        }
    }
    cout << endl;

    return 0;
}
```
* **代码解读概要**：
  1. 用`stack<int>`存左括号的位置（比如`(`在字符串中的索引`i`）；
  2. 左括号入栈时，`out[i]`记录需要补的右括号（`(`补`)`，`[`补`]`）；
  3. 右括号到来时，检查栈顶左括号是否匹配：
     - 匹配：清除栈顶的补全记录（`out[st.top()] = 0`），弹出栈；
     - 不匹配/栈空：`out[i]`记录需要补的左括号（`)`补`(`，`]`补`[`）；
  4. 输出时，按“补左→原字符→补右”的顺序，确保所有括号都成对。

---

<code_intro_selected>
接下来，我们剖析优质题解中的核心片段，看看它们的“巧妙之处”~
</code_intro_selected>

### 题解一（MY）：核心代码片段
* **亮点**：用`c`数组记录补全括号，逻辑直接。
* **核心代码片段**：
```cpp
for (int i = 0; i < n; i++) {
    if (a[i] == '(' || a[i] == '[') {
        s[++top] = a[i];
        w[top] = i;
        if (a[i] == '(') c[i] = ')';
        else c[i] = ']';
    }
    if (a[i] == ')') {
        if (top && s[top] == '(') { c[w[top]] = ' '; top--; }
        else c[i] = '(';
    } 
    if (a[i] == ']') {
        if (top && s[top] == '[') { c[w[top]] = ' '; top--; }
        else c[i] = '[';
    }
}
```
* **代码解读**：
  - `s`栈存左括号字符，`w`栈存左括号位置（对应通用代码的`stack<int>`）；
  - 左括号入栈时，`c[i]`存对应右括号；
  - 右括号匹配时，把栈顶位置的`c`设为空格（表示不用补），否则`c[i]`存对应左括号；
  - 输出时，`c[i]`非空格就补全，否则输出原字符。
* 💡 **学习笔记**：用两个栈分别存字符和位置，也是一种常见的处理方式~

### 题解二（YuJieSong）：核心代码片段
* **亮点**：用`b`数组标记匹配状态，易理解。
* **核心代码片段**：
```cpp
for (int i = 0; i < l; i++) {
    char c = s[i];
    if (fh[c] < 0) {
        st.push(i);
    } else {
        if (!st.empty()) {
            int k = st.top(); 
            if (fh[s[k]] + fh[c] == 0) {
                b[i] = b[k] = 1;
                st.pop();
            }
        }
    }
}
```
* **代码解读**：
  - `fh`数组把括号映射为数值（`(`→-1，`)`→1，`[`→-2，`]`→2），方便判断匹配（和为0）；
  - 左括号入栈（存位置），右括号匹配时标记`b[i] = b[k] = 1`；
  - 输出时，`b[i]`为1则输出原字符，否则补全成对。
* 💡 **学习笔记**：用数值映射判断匹配，比`if`判断更简洁~


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到栈如何工作，我设计了一个**FC风格的像素动画**——就像玩《超级玛丽》一样，跟着“像素小括号”一起完成匹配！
</visualization_intro>

### 动画演示主题
**《括号小冒险》**：像素小括号们在“字符串跑道”上排队，你需要用“栈架子”帮它们找到搭档~

### 核心演示内容
1. **场景初始化**（FC风格）：
   - 屏幕左侧是“字符串跑道”（10x1的像素网格），每个格子放一个括号像素块（红色`(`、蓝色`[`、灰色`)`、绿色`]`）；
   - 屏幕右侧是“栈架子”（5x1的像素网格），用来放未匹配的左括号；
   - 底部有“单步执行”“自动播放”“重置”按钮，还有速度滑块（1x~5x）。

2. **算法步骤演示**（带音效）：
   - **左括号入栈**：红色`(`从跑道滑入栈架子，伴随“叮”的音效，栈架子顶部的块闪烁；
   - **右括号匹配**：灰色`)`到来，栈架子顶部的红色`(`弹出，两者一起闪烁并发出“咚”的音效，然后消失（标记为已匹配）；
   - **补全括号**：绿色`]`到来，栈架子空，左侧“蹦出”一个蓝色`[`（补左括号），伴随“咔”的音效；
   - **栈剩余处理**：最后栈架子里的蓝色`[`，右侧“蹦出”一个绿色`]`（补右括号）。

3. **交互设计**：
   - **单步执行**：点击一次，执行一步操作，屏幕下方显示当前步骤的代码（比如`st.push(i)`）；
   - **自动播放**：按设定速度连续执行，适合整体观察；
   - **音效开关**：可以选择开启/关闭8位风格背景音乐（《超级玛丽》关卡音乐改编）。

### 设计思路
- **像素风格**：用简单的色块和低分辨率，还原FC游戏的怀旧感，降低视觉负担；
- **音效反馈**：不同操作对应不同音效，强化记忆（比如“叮”对应入栈，“咚”对应匹配）；
- **步骤同步**：每一步操作都对应代码片段，让你“看动画”的同时“学代码”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
栈的应用超广！掌握了本题的方法，你可以解决很多“找最近匹配”的问题~
</similar_problems_intro>

### 通用思路迁移
栈的“后进先出”特性适合解决：
1. **括号匹配**（本题及类似题）；
2. **函数调用栈**（跟踪函数的调用顺序）；
3. **表达式求值**（比如计算`3 + (2 * 5)`，用栈存运算符）。

### 洛谷练习推荐
1. **洛谷 P1739** - 表达式括号匹配  
   🗣️ **推荐理由**：这是本题的“基础版”，只需要判断括号是否匹配，适合巩固栈的基本用法。
2. **洛谷 P4387** - 验证栈序列  
   🗣️ **推荐理由**：考察栈的“push/pop”顺序，需要模拟栈的操作，提升对栈的理解。
3. **洛谷 P2585** - 括号序列  
   🗣️ **推荐理由**：本题的“进阶版”，需要补全最短括号序列，适合挑战更复杂的逻辑。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“踩坑经历”比正确代码更有价值！看看这些作者的心得：
</insights_intro>

> **参考经验（来自MY）**：“我一开始用了双栈存小括号和中括号，结果本地测试通过，但洛谷提交只得了63分。后来才明白，应该用单栈存左括号位置——栈的‘后进先出’正好对应‘最近未匹配’的规则！”  
> **点评**：很多同学会犯“过度拆分问题”的错误，比如把小括号和中括号分开处理。其实用单栈存位置，就能统一解决所有左括号的匹配问题——**不要为不同类型的括号单独建栈！**

> **参考经验（来自YuJieSong）**：“我卡了二十多分钟才理解题意——原来不是补最短序列，而是按规则匹配后补全！”  
> **点评**：审题是解题的第一步！如果题意理解错了，再对的代码也没用——**一定要反复读题，直到完全理解规则！**


<conclusion>
本次关于“括号序列”的分析就到这里啦！栈是一个“看似简单，实则强大”的数据结构，掌握它能解决很多“找最近匹配”的问题。记住：**栈的核心是“后进先出”，找准这个点，很多问题都会迎刃而解~** 下次我们再一起探索更多栈的应用吧！💪
</conclusion>

---
处理用时：133.79秒
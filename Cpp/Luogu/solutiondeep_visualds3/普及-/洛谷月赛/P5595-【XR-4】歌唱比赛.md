# 题目信息

# 【XR-4】歌唱比赛

## 题目背景

**赛时提醒：本题不提供任何关于样例 4 以及无解的解释。**

**赛时提醒：本题不提供任何关于输出格式以及 Special Judge 的解释。**

**赛时提醒：抱歉，本题的 Special Judge 不忽略行末空格，请保证两行中没有多余字符。**

**赛时提醒：非常抱歉，本题输入数据是 Windows 格式，而非 Linux 格式，所以在末尾的 `\n` 之前有一个多余的 `\r` 字符。请使用 `scanf` 或 `cin` 读入数据，而非 `getline`，因为后者会多读入一个 `\r`。**

## 题目描述

小 X 参加了一场歌唱比赛。

经过一路鏖战，小 X 终于挺进了决赛，他的对手是小 Y。

这场歌唱比赛的冠军是由点赞数决定的，谁的点赞数高，谁就能夺冠。

小 X 和小 Y 依次演唱完自己的最后一首歌曲后，他们最终的点赞数确定了下来。

揭晓冠军的时刻终于到来了，主持人为了增加悬念，决定从小 X 与小 Y 的点赞数的最后一位开始，依次比较。

比如，小 X 的点赞数是 $37$，小 Y 的点赞数是 $28$。首先比较最后一位，小 X 是 $7$，小 Y 是 $8$，此时小 Y 暂时领先。再加上前一位，小 X 是 $37$，小 Y 是 $28$，此时小 X 暂时领先。比较结束，如果我们用 `X` 代表小 X 暂时领先，`Y` 代表小 Y 暂时领先，那么可以写下一个字符串 `XY`。

再比如，小 X 的点赞数是 $137$，小 Y 的点赞数是 $47$。如果我们再用 `Z` 表示小 X 与小 Y 的点赞数暂时一样，那么写下的字符串应该为 `XYZ`。

你作为一个精通 OI 的神仙，自然知道这种比较方式是非常不科学的，这样只是在无端拖延时间罢了，但是你却对最后写下的这个字符串很感兴趣。

现在，你得到了这个最后写下的字符串，你需要构造出一种可能的小 X 与小 Y 的点赞数。

当然，有可能不存在任何一种情况的点赞数满足这个字符串，那么你只需要输出 `-1` 即可。

为了方便你输出，请用前导零来补足位数。

## 说明/提示

**本题采用捆绑测试。**

- Subtask 1（11 points）：$\text{len}(s) = 1$。
- Subtask 2（42 points）：$s_i \in \{\texttt{X},\texttt{Y}\}$。
- Subtask 3（21 points）：数据保证有解。
- Subtask 4（26 points）：无特殊限制。

对于 $100\%$ 的数据，$s_i \in \{\texttt{X},\texttt{Y},\texttt{Z}\}$，$1 \le \text{len}(s) \le 10^6$。

## 样例 #1

### 输入

```
XY
```

### 输出

```
37
28
```

## 样例 #2

### 输入

```
XYZ
```

### 输出

```
137
047
```

## 样例 #3

### 输入

```
ZZZZZZ
```

### 输出

```
000000
000000
```

## 样例 #4

### 输入

```
XYZXYZ
```

### 输出

```
-1
```

# AI分析结果

# 💡 Kay的C++算法解析：【XR-4】歌唱比赛 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟与贪心构造  

🗣️ **初步分析**：  
解决这道题的关键，在于理解「字符串每个字符的含义」和「数字构造的规则」。我们可以把问题类比成「搭积木比赛」——每一块积木代表数字的一位（从右到左堆），`X`表示小X的积木堆当前更高，`Y`表示小Y的更高，`Z`表示两者一样高。但要注意：**一旦积木堆出现高度差（X或Y），后面的积木必须保持这个差距——不可能先有差距再变平（Z）**！  

### 核心逻辑拆解：
1. **无解判断**：如果字符串中出现「Z后面跟着X/Y」（比如`ZXY`），直接输出-1——因为Z意味着前面的积木一样高，但后面的X/Y又要求有高度差，矛盾。  
2. **构造数字**：对于`X`位，让小X的这一位比小Y大（比如小X写1，小Y写0）；对于`Y`位，反过来（小X写0，小Y写1）；对于`Z`位，两者写相同数字（比如0或1）。  

### 可视化设计思路：
我们用**8位像素风**模拟「积木堆」：  
- 屏幕左侧显示字符串的每一位（像素化的X/Y/Z图标），右侧是两个数字的「积木塔」（每个像素块代表一位）。  
- 判断无解时，Z对应的像素块会闪烁红色，伴随「错误」音效；构造时，X/Y位的积木会分别向上/向下生长，Z位的积木保持平齐。  
- 支持「单步执行」：点击一次，处理一位字符，积木塔同步变化，旁边弹出文字提示（比如“这一位是X，小X的积木要比小Y高！”）。  


## 2. 精选优质题解参考

### 题解一：来自loceaner（思路清晰，代码规范）  
* **点评**：这份题解的逻辑像「整理玩具」一样直白——先检查有没有「Z后面乱入X/Y」的情况，再按规则给每个位置填数字。代码用字符数组存储结果，变量名`a`（小X的数字）、`b`（小Y的数字）一目了然。特别棒的是，它用`now`变量标记「是否已经出现过X/Y」，避免了复杂的嵌套判断，时间复杂度是O(n)（只扫一遍字符串），非常高效！  


### 题解二：来自StudyingFather（抓住问题本质）  
* **点评**：这位作者直接点出了问题的核心——「Z只能在字符串最后几位」。代码中倒序遍历字符串，用`flag`标记「是否已经出现过X/Y」，一旦遇到Z且`flag`为真（前面有过差距），直接输出-1。构造数字时用9和0（比如X位小X写9，小Y写0），虽然数字大，但逻辑更直观——反正只要满足大小关系就行！  


### 题解三：来自Tarsal（代码简洁，注释友好）  
* **点评**：这份题解的代码像「写日记」一样好读——用`flag`记录「是否已经有差距」，遇到Z时如果`flag`为真就输出-1，否则填1。构造X/Y位时用2和1（小X的X位写2，小Y写1；Y位反过来），数字小但满足条件。注释里特意提醒「看懂再抄」，很贴心！  


## 3. 核心难点辨析与解题策略

### 1. 难点1：理解Z的真正含义  
* **问题**：很多同学会误以为Z只是「当前位相等」，但实际上Z是「从低位到当前位的所有位都相等」（比如字符串`XYZ`，Z位意味着前三位都相等）。  
* **解决**：记住「Z之后不能有X/Y」——一旦出现X/Y，就说明前面的位有差距，不可能再相等。  
* 💡 **学习笔记**：Z不是「某一位相等」，而是「前面所有位都相等」！  


### 2. 难点2：判断无解的条件  
* **问题**：怎么快速判断字符串是否有解？  
* **解决**：用一个变量`flag`标记「是否已经出现过X/Y」。遍历字符串时，如果遇到Z且`flag`为真（前面有差距），直接输出-1；如果遇到X/Y，把`flag`设为真。  
* 💡 **学习笔记**：无解的唯一情况是「Z出现在X/Y之后」！  


### 3. 难点3：构造满足条件的数字  
* **问题**：怎么让数字满足每一位的大小关系？  
* **解决**：用最简单的数字——比如X位小X写1、小Y写0；Y位小X写0、小Y写1；Z位都写0或1。因为题目允许前导零，所以不用怕数字前面有0！  
* 💡 **学习笔记**：构造题优先用「最小的合法数字」，避免复杂计算！  


### ✨ 解题技巧总结  
- **技巧1：用变量标记状态**：比如`flag`记录「是否已经有差距」，避免重复判断。  
- **技巧2：用简单数字构造**：不用纠结「最大/最小数字」，只要满足大小关系就行（比如0和1）。  
- **技巧3：先判断无解再构造**：先处理特殊情况（无解），再处理正常情况，代码更清晰。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了loceaner和Tarsal的思路，用字符数组存储结果，逻辑简洁易读。  

```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int N = 1e6 + 11;
char s[N], a[N], b[N];  // s是输入字符串，a是小X的数字，b是小Y的数字
bool has_diff;          // 标记是否已经出现过X/Y（有差距）

int main() {
    scanf("%s", s + 1);  // 从索引1开始存储，方便处理
    int len = strlen(s + 1);

    // 第一步：判断无解
    for (int i = 1; i <= len; i++) {
        if (s[i] == 'Z') {
            if (has_diff) {  // Z出现在X/Y之后，无解
                printf("-1\n");
                return 0;
            }
        } else {
            has_diff = true;  // 出现X/Y，标记有差距
        }
    }

    // 第二步：构造数字
    for (int i = 1; i <= len; i++) {
        if (s[i] == 'X') {
            a[i] = '1';  // 小X的位比小Y大
            b[i] = '0';
        } else if (s[i] == 'Y') {
            a[i] = '0';  // 小Y的位比小X大
            b[i] = '1';
        } else {  // Z位，两者相等
            a[i] = '0';
            b[i] = '0';
        }
    }

    // 输出结果
    printf("%s\n%s\n", a + 1, b + 1);  // 从索引1开始输出
    return 0;
}
```

* **代码解读概要**：  
  1. **输入处理**：用`scanf`读入字符串（避免`getline`的换行问题），从索引1开始存储。  
  2. **无解判断**：遍历字符串，用`has_diff`标记是否有差距，遇到Z且`has_diff`为真则输出-1。  
  3. **构造数字**：按X/Y/Z的规则给`a`和`b`数组赋值。  
  4. **输出**：直接打印`a`和`b`数组（从索引1开始）。  


### 题解一（loceaner）核心片段赏析  
* **亮点**：用`now`变量标记状态，代码简洁。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= len; i++) {
      if (s[i] == 'Z') now = 1;  // 标记出现Z
      if (s[i] != 'Z' && now) {  // Z之后出现X/Y，无解
          cout << "-1\n";
          return 0;
      }
  }
  ```
* **代码解读**：  
  - `now`变量初始为0，遇到Z时设为1。  
  - 如果遇到X/Y且`now`为1（前面有Z），说明无解。  
* 💡 **学习笔记**：用一个变量就能搞定状态判断，不用复杂的循环！  


### 题解二（StudyingFather）核心片段赏析  
* **亮点**：倒序遍历，逻辑更直观。  
* **核心代码片段**：  
  ```cpp
  for (int i = len - 1; i >= 0; i--) {
      if (s[i] != 'Z') flag = false;
      if (s[i] == 'Z' && !flag) {  // Z出现在X/Y之后
          puts("-1");
          return 0;
      }
  }
  ```
* **代码解读**：  
  - 倒序遍历字符串，`flag`初始为真（假设前面都是Z）。  
  - 遇到X/Y时，`flag`设为假（后面不能有Z）。  
  - 遇到Z且`flag`为假（后面有X/Y），说明无解。  
* 💡 **学习笔记**：倒序遍历有时能更直接地处理「后面的条件影响前面」的问题！  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：像素积木大赛  
我们用**8位FC风格**模拟「小X和小Y搭积木」，每一块积木代表数字的一位（从右到左堆）。  

### 核心演示内容：  
1. **场景初始化**：  
   - 屏幕左侧是「字符串进度条」（每个像素块显示X/Y/Z），右侧是两个「积木塔」（小X的塔是蓝色，小Y的是红色）。  
   - 底部有「开始/暂停」「单步执行」「重置」按钮，以及速度滑块。  
   - 背景播放8位风格的轻快BGM（比如《超级马里奥》的小关卡音乐）。  

2. **无解判断演示**：  
   - 当遍历到「Z后面的X/Y」时，Z对应的像素块会闪烁红色，同时播放「错误」音效（短促的“叮-叮”），屏幕中央弹出文字提示：“Z后面不能有X/Y！无解啦～”。  

3. **构造过程演示**：  
   - 点击「单步执行」，处理当前字符：  
     - 如果是X：小X的积木塔向上加一块蓝色积木，小Y的加一块红色积木（蓝色比红色高1），伴随“啪嗒”音效。  
     - 如果是Y：相反，小Y的积木比小X高1。  
     - 如果是Z：两者加一块同样高的积木（都是白色），伴随“叮”的音效。  
   - 每处理一位，字符串进度条的当前位会高亮（黄色），旁边弹出提示文字（比如“这一位是X，小X的积木要更高～”）。  

4. **完成状态**：  
   - 所有位处理完后，两个积木塔会闪烁，播放「胜利」音效（上扬的“叮-咚”），屏幕中央显示：“成功啦！小X的数字是XXXXX，小Y的是YYYYY～”。  

### 设计思路：  
用「积木堆」类比数字的位，让抽象的「大小关系」变成直观的「高度差」。8位风格和音效让学习更有趣，单步执行能让你慢慢看清楚每一步的逻辑！  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的「构造+状态判断」思路可以解决很多类似问题，比如：  
- 给定一个序列的大小关系，构造两个满足条件的数组；  
- 判断一个序列是否符合某种规则（比如「一旦有差距就不能再平等」）；  
- 用简单数字快速构造合法解（避免复杂计算）。  


### 洛谷练习推荐  
1. **洛谷 P3742 - umi的函数**  
   - 🗣️ **推荐理由**：这题和本题几乎一样！只不过把「数字的位」换成了「函数的取值」，可以巩固「状态判断+构造」的思路。  

2. **洛谷 P5595 - 【XR-4】歌唱比赛**  
   - 🗣️ **推荐理由**：原题复现！多做一遍能加深对「Z的含义」和「无解条件」的理解。  

3. **洛谷 P1157 - 组合的输出**  
   - 🗣️ **推荐理由**：这题需要构造满足条件的组合序列，同样用到「按规则构造+状态判断」的思路，是不错的拓展练习。  


## 7. 学习心得与经验分享 (若有)

> **参考经验（来自Tarsal）**：“我在解决这个问题时，最初误以为Z只是当前位相等，后来通过手写样例才发现Z是前面所有位相等。这让我意识到「仔细读题」的重要性——尤其是题目中的细节描述！”  
> **点评**：这位作者的经验很典型！很多时候我们会「惯性思维」，忽略题目中的关键细节（比如Z的真正含义）。解决办法是：**手写小例子验证思路**——比如字符串`XYZ`，手写小X和小Y的数字，就能发现Z的含义是“前面所有位相等”。  


## 结语  
本次关于「歌唱比赛」的C++解题分析就到这里啦！希望这份指南能帮助你理解「模拟构造」的核心逻辑——**先判断特殊情况，再按规则构造简单解**。记住：编程的本质是「解决问题」，而不是「写复杂的代码」！下次我们再一起探索新的编程挑战吧～ 💪

---
处理用时：88.47秒
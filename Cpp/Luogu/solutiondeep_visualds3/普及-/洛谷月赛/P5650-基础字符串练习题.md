# 题目信息

# 基础字符串练习题

## 题目背景

YSGH 牛逼

## 题目描述

给定长度非零的非空 01 串 $S$。

找出 $S$ 的非空连续子串 $T$ 满足串中 0 的个数减去 1 的个数最大。

你只需要输出最大值即可。

## 说明/提示

设 $|S| = n$。

| 数据点编号 | $n \le$ |
| :--: | :--: |
| $1 \sim 2$ | $10$ |
| $3 \sim 6$ | ${10}^3$ |
| $7 \sim 10$ | ${10}^5$ |

对于 $100\%$ 的数据，$1 \le n \le {10}^5$。

## 样例 #1

### 输入

```
0111100101```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：基础字符串练习题 深入学习指南 💡

<introduction>
  今天我们来一起分析“基础字符串练习题”这道C++编程题。题目看起来是处理01串，但其实藏着经典的算法思维！本指南会帮你把问题“翻译”成熟悉的模型，掌握核心解法，还会用像素动画让算法“动”起来～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最大子段和（贪心/动态规划）

🗣️ **初步分析**：
解决这道题的关键，是把**01串问题转化为“最大子段和”问题**——这就像把“找最多蛋糕减石子的连续段”，变成“找连续数字的最大和”！具体来说：
- 把每个`0`看成**+1**（吃一块蛋糕，加1分）；
- 把每个`1`看成**-1**（踩一颗石子，减1分）；
- 原问题的“0个数-1个数的最大值”，就等于**转化后数组的最大连续子段和**！

比如样例输入`0111100101`，转化后是`+1, -1, -1, -1, -1, +1, +1, -1, +1, -1`，最大子段和是`+1+1=2`（对应原串的`00`），正好是样例输出。

### 核心算法流程
我们用**贪心策略**高效计算：
1. 维护两个变量：`current_sum`（当前连续子段的和）、`max_sum`（全局最大和）；
2. 遍历每个字符：
   - 遇到`0`，`current_sum +=1`；
   - 遇到`1`，`current_sum -=1`；
3. 每步都更新`max_sum`（取当前`max_sum`和`current_sum`的最大值）；
4. 若`current_sum < 0`，说明当前子段“扣分超过加分”，**重置`current_sum`为0**（相当于“放弃前面的段，重新开始算”）；
5. 最后特判：如果所有字符都是`1`（即`max_sum`仍为-1），输出`-1`（因为必须选非空段）。

### 可视化设计思路
我们会用**FC红白机风格的像素动画**展示算法：
- 屏幕左侧是**像素化的01串**（`0`用绿色方块，`1`用红色方块）；
- 中间是**当前子段和的动态显示**（数字用8位字体，背景闪烁对应加减分）；
- 右侧是**全局最大值的高亮**（用闪烁的星星标记，最大值更新时播放“叮”的音效）；
- 当`current_sum < 0`时，中间数字会“清零”并播放“啪”的重置音效；
- 全1的情况会弹出“全是石子！只能选一个，得-1分～”的提示框，播放短促的“嗡”声。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率等角度，筛选了3份优质题解，帮你快速理解核心逻辑～
</eval_intro>

**题解一：贪心解法（作者：hwx12233，赞49）**
* **点评**：这份题解把问题“翻译”得非常直白！作者直接用`ans1`（当前和）和`ans2`（最大值），一步一步处理每个字符：遇到`0`加1，遇到`1`减1，小于0就重置`ans1`。代码只有10多行，却覆盖了所有边界情况（比如全1时`ans2`初始化为-1）。最厉害的是**无额外数组**，空间复杂度O(1)，完全符合1e5的数据规模要求！

**题解二：动态规划解法（作者：Inkyo，赞23）**
* **点评**：作者用`dp[i]`表示“以第i位结尾的最大子段和”，转移方程是`dp[i] = max(dp[i-1]+f, f)`（`f`是当前字符的贡献）。这种“自底向上”的DP思路，完美对应“要么接前面的段，要么重新开始”的逻辑。代码里还提供了**前缀和优化**的写法，两种方法对比着看，能更深刻理解“最大子段和”的本质。

**题解三：计数器法（作者：冬天的雨，赞37）**
* **点评**：作者用`tm0`（当前段0的个数）和`tm1`（当前段1的个数），直接计算`tm0-tm1`的最大值。当`tm1 >= tm0`时，重置计数器——这其实和贪心策略“current_sum < 0时重置”是等价的！这种写法非常直观，适合刚学算法的同学理解“为什么要重置”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，是“把问题转化为最大子段和”，以及处理边界情况。下面是3个核心难点和应对策略：
</difficulty_intro>

1. **难点1：如何把01串问题转化为最大子段和？**
    * **分析**：原问题要“0的个数-1的个数最大”，而“个数差”正好等于“每个字符贡献的和”（0→+1，1→-1）。这一步是“模型转换”的关键——把字符串问题变成了数组求和问题！
    * 💡 **学习笔记**：遇到“统计某种差值的最大值”，可以试试把每个元素映射成“贡献值”，转化为求和问题。

2. **难点2：为什么current_sum < 0时要重置？**
    * **分析**：如果当前子段的和已经是负数，说明“前面的段扣分比加分多”，再往后加任何数，都不如“重新开始算”更优（比如前面是-2，后面加+3，总和是1；但重新开始算+3，总和更大）。
    * 💡 **学习笔记**：贪心策略的核心是“保留有用的前缀，放弃无用的前缀”。

3. **难点3：如何处理全1的边界情况？**
    * **分析**：当所有字符都是1时，转化后的数组全是-1，最大子段和是-1（必须选一个元素）。此时要特判，不能输出0（因为子段非空）。
    * 💡 **学习笔记**：边界情况往往是“看似正确的算法”的漏洞，一定要单独考虑！

### ✨ 解题技巧总结
- **模型转换**：把字符串问题转化为数组求和问题，用经典算法解决；
- **贪心策略**：保留当前有用的前缀（和≥0），放弃无用的前缀（和<0）；
- **边界特判**：全1的情况要输出-1，不能遗漏。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用的贪心解法代码**——它综合了优质题解的优点，简洁高效，能直接解决问题！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自题解一（hwx12233）的优化，用贪心策略，O(n)时间、O(1)空间，覆盖所有边界情况。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    using namespace std;

    int main() {
        char s[100501];
        cin >> s;
        int n = strlen(s);
        int current_sum = 0;  // 当前连续子段的和
        int max_sum = -1;     // 全局最大值（初始化为-1，处理全1情况）

        for (int i = 0; i < n; ++i) {
            if (s[i] == '0') {
                current_sum++;
            } else {
                current_sum--;
            }
            // 更新全局最大值
            if (current_sum > max_sum) {
                max_sum = current_sum;
            }
            // 重置当前和（如果为负）
            if (current_sum < 0) {
                current_sum = 0;
            }
        }

        cout << max_sum << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  1. 输入字符串`s`，计算长度`n`；
  2. 初始化`current_sum`（当前和）为0，`max_sum`（最大值）为-1；
  3. 遍历每个字符：
     - `0`→current_sum+1，`1`→current_sum-1；
     - 更新max_sum为更大的值；
     - 如果current_sum<0，重置为0（放弃前面的段）；
  4. 输出max_sum（全1时max_sum保持-1，正确）。

---

<code_intro_selected>
接下来看**动态规划**和**计数器法**的核心片段，对比不同思路的写法～
</code_intro_selected>

**题解二：动态规划（作者：Inkyo）**
* **亮点**：用DP数组明确表示“以第i位结尾的最大子段和”，思路清晰。
* **核心代码片段**：
    ```cpp
    string s;
    int dp[100005], ans = -1e9;

    int main() {
        cin >> s;
        dp[0] = (s[0] == '0') ? 1 : -1;  // 第0位的贡献
        for (int i = 1; i < s.size(); ++i) {
            int f = (s[i] == '0') ? 1 : -1;
            dp[i] = max(dp[i-1] + f, f);  // 要么接前面，要么重新开始
            ans = max(ans, dp[i]);        // 更新最大值
        }
        cout << ans << endl;
    }
    ```
* **代码解读**：
  - `dp[i]`表示“以第i位结尾的最大子段和”；
  - 转移方程`dp[i] = max(dp[i-1]+f, f)`：如果前面的和加上当前贡献比“单独选当前字符”大，就接前面；否则重新开始；
  - 最后遍历dp数组找最大值。
* 💡 **学习笔记**：DP是“记录子问题答案”的方法，适合需要明确“状态”的问题。

**题解三：计数器法（作者：冬天的雨）**
* **亮点**：用`tm0`和`tm1`直接统计当前段的0、1个数，直观易懂。
* **核心代码片段**：
    ```cpp
    char a[100001];
    int tm0 = 0, tm1 = 0, maxx = -1;

    int main() {
        cin >> a;
        int len = strlen(a);
        for (int i = 0; i < len; ++i) {
            if (a[i] == '0') tm0++;
            else tm1++;
            if (tm0 - tm1 > maxx) maxx = tm0 - tm1;
            if (tm1 >= tm0) {  // 当前段1的个数≥0，重置
                tm0 = 0;
                tm1 = 0;
            }
        }
        cout << maxx << endl;
    }
    ```
* **代码解读**：
  - `tm0`和`tm1`统计当前段的0、1个数；
  - 当`tm1 >= tm0`时，说明当前段的“扣分≥加分”，重置计数器（等价于贪心的current_sum<0）；
  - 每步更新maxx为`tm0-tm1`的最大值。
* 💡 **学习笔记**：计数器法适合“需要直观看到统计结果”的问题，容易 debug。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让算法“活”起来，我设计了一个**FC红白机风格的像素动画**！你可以像玩《超级马里奥》一样，看着算法一步步计算～
</visualization_intro>

### 动画设计细节
#### 1. **整体风格**
- 分辨率：320x240（FC经典分辨率）；
- 颜色：用8位调色板（比如绿色#00FF00代表0，红色#FF0000代表1，黄色#FFFF00代表最大值）；
- 字体：用《魂斗罗》风格的8位字体，数字和提示文字都很复古。

#### 2. **核心演示内容**
- **场景初始化**：
  - 屏幕左侧显示**像素化的01串**（每个字符是16x16的方块，0→绿色，1→红色）；
  - 中间显示**当前和**（用黄色数字，比如`+3`或`-2`）；
  - 右侧显示**最大值**（用闪烁的星星+数字，比如`★2`）；
  - 底部有**控制面板**：单步（▶️）、自动播放（⏯️）、重置（🔄）、速度滑块（从“慢”到“快”）。

- **动画步骤**：
  1. **处理第一个字符**：比如第一个是0（绿色方块），中间数字变成`+1`，右侧星星闪烁`★1`，播放“叮”的音效；
  2. **处理第二个字符**：如果是1（红色方块），中间数字变成`0`，右侧星星保持`★1`，播放“嗒”的音效；
  3. **处理第三个字符**：如果是1，中间数字变成`-1`，此时**重置**（中间数字变成`0`），播放“啪”的音效；
  4. **处理后面的字符**：比如遇到连续的0，中间数字逐渐增加，右侧星星更新为更大的值，播放“叮叮叮”的连续音效；
  5. **全1情况**：所有方块都是红色，中间数字一直是`-1`，最后弹出提示框“全是石子！得-1分～”，播放“嗡”的音效。

#### 3. **交互设计**
- **单步执行**：点击“▶️”，每步处理一个字符，方便仔细观察；
- **自动播放**：点击“⏯️”，算法自动运行，速度可以用滑块调节（最慢1秒/步，最快0.1秒/步）；
- **重置**：点击“🔄”，回到初始状态，重新运行算法；
- **音效开关**：右上角有“🔊”按钮，可以开启/关闭音效（默认开启）。

#### 4. **技术实现**
- 用HTML5 Canvas绘制像素图形；
- 用JavaScript实现动画逻辑（比如`requestAnimationFrame`控制帧速率）；
- 用Web Audio API播放音效（比如“叮”是440Hz的正弦波，“嗒”是220Hz的方波）。

<visualization_conclusion>
通过这个动画，你能**直观看到**算法如何“选择有用的段，放弃无用的段”，以及最大值如何一步步更新。就像玩游戏一样，轻松掌握核心逻辑！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
最大子段和是非常经典的算法，学会它能解决很多类似问题！下面是几个拓展练习：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：股票买卖（找连续几天的最大收益）；
- **场景2**：数组中找连续子数组的最大和（比如LeetCode 53题）；
- **场景3**：字符串中找连续子串的最大“分数”（比如字母A加1，B减1，找最大分数）。

### 洛谷练习推荐
1. **洛谷 P1115 - 最大子段和**
   - 🗣️ **推荐理由**：这是本题的“原型”！直接练习最大子段和的DP和贪心解法，巩固基础。
2. **洛谷 P2091 - 岛屿**
   - 🗣️ **推荐理由**：把“岛屿的高度差”转化为最大子段和，练习模型转换能力。
3. **洛谷 P3904 - 三只小猪**
   - 🗣️ **推荐理由**：用最大子段和解决“最多救多少小猪”的问题，提升应用能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者都提到了**边界情况的重要性**，比如全1的情况。比如作者“冬天的雨”说：“当串是111111时，答案不能是0，必须是-1！”这提醒我们：
</insights_intro>

> **参考经验**：“我一开始没特判全1的情况，结果第4个测试点WA了！后来加了`maxx = -1`的初始化，才通过。”
>
> **点评**：边界情况是算法的“隐形陷阱”！比如本题的“非空子串”要求，就会导致全1时必须输出-1。解决方法是：**初始化最大值为-1**（因为最小的可能值就是-1），这样即使全1，也能正确输出。


<conclusion>
本次分析就到这里啦！这道题的核心是“模型转换”——把01串问题变成最大子段和问题。记住：**算法的本质是“找规律、套模型”**，掌握了经典模型，很多问题都会变得简单～下次我们再一起探索新的算法挑战！💪
</conclusion>

---
处理用时：110.50秒
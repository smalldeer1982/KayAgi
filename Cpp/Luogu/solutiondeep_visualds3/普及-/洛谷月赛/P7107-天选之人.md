# 题目信息

# 天选之人

## 题目背景

暑假期间，学校不提供午餐，Gnar 只好找伙计们一起点外卖。

尴尬的是，外卖很快送到却没人乐意去校门口拿，毕竟户外可是 $35\degree\!\text{C}$ 高温！此时 Gnar 想到了好主意：“我给一人捏了一张纸团，其中一张写有记号，不如我们抓阄决定，谁抽到带记号的谁去拿！”

于是 Gnar 连续拿了六天的外卖。

这可让他不服又委屈：“换个规则！一人准备三张纸团，五张有记号，每人抽三张，记号最多的去拿！”

Gnar 紧张地展开手中的纸团，两个记号赫然映在眼前。大伙们刚想放声大笑他的非酋运气，有人缓缓举起三张纸片说道：“我也抽到了两个记号……”

## 题目描述

好奇的 Gnar 想研究一般情况下抽到最多记号的人数。他给参与抓阄的 $n$ 人一人准备了 $m$ 张捏好的纸团，一共 $nm$ 张，其中恰好 $k$ 张提前写了记号。随后每个人在均匀打乱的纸团中各抽 $m$ 张。

一个人抽到最多的记号，当且仅当没有人抽到的记号比他还多。请你帮 Gnar 判断是否可能会**恰好** $\boldsymbol{p}$ **个人**抽到最多的记号。Gnar 喜欢追根问底，所以如果有可能，你还需构造每个人抽的纸团中分别有多少带记号、有多少不带记号。

形式化地，假设第 $i$ 个人抽到了 $x_i$ 张带记号的纸团和 $y_i$ 张不带记号的纸团，你的构造应满足：

- $x_i, y_i \ge 0$，$x_i + y_i = m$。
- $\displaystyle \sum_{i = 1}^{n} x_i = k$。
- **有且仅有** $\boldsymbol{p}$ **个互不相同**的 $j$ 使 $\displaystyle x_j = \max_{i = 1}^{n} \{x_i\}$。

## 说明/提示


**【样例解释 #1】**

样例给出了一种满足题述条件的构造。

**【样例解释 #2】**

不论如何，记号的分布从高到低只有三种情况：$\{3,0,0\}$，$\{2,1,0\}$，$\{1,1,1\}$，抽到最多记号的人数分别对应 $1$，$1$，$3$。因此无法构造 $p = 2$ 的方案。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (15 points)：$n,m \le 8$。
- Subtask #2 (15 points)：$n,m \le 100$。
- Subtask #3 (20 points)：$n,m \le 10^5$。
- Subtask #4 (10 points)：$p = 1$。
- Subtask #5 (40 points)：无特殊限制。

对于所有的数据，保证 $1 \le p \le n \le {10}^5$，$1 \le m \le {10}^9$，$0 \le k \le n m$。

## 样例 #1

### 输入

```
3 3 5 2```

### 输出

```
YES
2 1
2 1
1 2```

## 样例 #2

### 输入

```
3 3 3 2```

### 输出

```
NO```

## 样例 #3

### 输入

```
3 3 5 3```

### 输出

```
NO```

# AI分析结果

---
# 💡 Kay的C++算法解析：天选之人 深入学习指南 💡

<introduction>
今天我们来一起分析“天选之人”这道C++编程题。这道题的核心是**构造满足条件的分配方案**，需要我们用贪心的思想合理分配带记号的纸团。本指南将帮助大家梳理思路、理解核心逻辑，并掌握解题技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心构造（编程技巧应用）

🗣️ **初步分析**：
解决“天选之人”的关键是**贪心策略**——先让`p`个人拿到“尽可能多但不违规”的带记号纸团（保证他们是最大值），再把剩下的纸团分给其他人（保证他们的数量不超过最大值减一）。简单来说，这就像“先给前p个小朋友分最大的蛋糕，剩下的蛋糕切小分给其他人，这样前p个的蛋糕肯定最大”。

### 核心算法流程
1. **确定最大值`q`**：前`p`个人每人最多能拿`q = min(m, k/p)`个带记号纸团（`m`是每人最多拿的总数，`k/p`是平均分给`p`人的数量，取较小值避免超量）。
2. **分配前`p`人**：前`p`人每人拿`q`个带记号纸团，剩余带记号纸团数`rest = k - p*q`。
3. **分配剩余的人**：剩下的`n-p`人尽可能拿`q-1`个（保证不超过最大值），直到`rest`用完。若`rest > (n-p)*(q-1)`，说明剩余纸团太多，无法让所有人都不超过`q-1`，此时无解。

### 可视化设计思路
我们将用**8位像素风格**（类似FC红白机）设计动画，主题是“像素小朋友分蛋糕”：
- **角色与颜色**：前`p`个小朋友（最大值）用红色像素块，剩余小朋友用蓝色，带记号纸团用黄色像素点。
- **关键步骤动画**：
  1. 前`p`个小朋友依次拿到`q`个黄色像素点（伴随“叮”的音效）。
  2. 剩余小朋友依次拿`q-1`个黄色点（伴随“嗒”的音效），若`rest`不足则拿剩余数量（绿色闪烁提示）。
- **交互控制**：支持“单步执行”（看每一步分配）、“自动播放”（调速滑块控制速度）、“重置”（重新开始）。
- **游戏化元素**：每分配完一个小朋友，屏幕底部显示“已完成X/XX”，全部完成时播放“胜利音效”（上扬的8位音乐），无解时播放“提示音效”（短促的“滴”声）。


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，它们都用贪心思想解决问题，但细节处理各有亮点：
</eval_intro>

**题解一：来源：Unordered_OIer**
* **点评**：这份题解的思路最直接——先算最大值`q`，再分配前`p`人，最后处理剩余。代码极其简洁（核心逻辑仅10行），变量命名清晰（`q`表示最大值，`rest`表示剩余），边界处理严谨（判断`rest`是否超过剩余容量）。它的亮点是**用最朴素的贪心完成构造**，非常适合初学者理解核心逻辑。

**题解二：来源：HanPi**
* **点评**：此题解的亮点是**将剩余纸团“平均分配”**——把`rest`分成`n-p`份，用`h = rest/(n-p)`和`mod = rest%(n-p)`处理，避免了循环中的条件判断。同时，它特别处理了`n=p`的情况（此时必须所有`x_i`相等），逻辑更完整。代码风格简洁，适合学习“分治剩余”的技巧。

**题解三：来源：Maxmilite**
* **点评**：这份题解的优势是**特判处理到位**——明确处理了`n=p`的情况（避免除数为0），并通过“尽可能拿`q-1`”的方式分配剩余。代码中的条件判断（`tot < (t-1)`）直接解决了剩余不足的问题，逻辑清晰。它的亮点是**用最直观的方式验证贪心的正确性**，适合理解“为什么贪心有效”。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点在于“如何保证恰好p个最大值”，以下是3个关键问题及解决策略：
</difficulty_intro>

1. **关键点1：如何确定最大值`q`？**
    * **分析**：`q`必须满足两个条件：①前`p`人拿的总数不超过`k`（`q*p ≤ k`）；②每人拿的不超过`m`（`q ≤ m`）。因此`q = min(m, k/p)`（整数除法，向下取整）。
    * 💡 **学习笔记**：`q`是贪心的“锚点”，必须先确定它才能保证后续分配的合理性。

2. **关键点2：如何处理剩余的`rest`？**
    * **分析**：剩余的`rest`必须分给`n-p`人，且每人最多拿`q-1`个（否则会超过最大值）。因此需要判断`rest ≤ (n-p)*(q-1)`——若超过则无解，否则依次分配`q-1`直到`rest`用完。
    * 💡 **学习笔记**：剩余分配的核心是“不超过最大值减一”，这是保证恰好p个最大值的关键。

3. **关键点3：如何处理`n=p`的情况？**
    * **分析**：当`n=p`时，所有`x_i`必须等于`q`（否则最大值的数量会超过`p`），因此需要满足`k = p*q`（即`k%p == 0`）。
    * 💡 **学习笔记**：特判是编程中避免错误的重要技巧，尤其是当除数可能为0时（如`n-p=0`）。

### ✨ 解题技巧总结
- **贪心优先**：先满足“最大值”的条件，再处理剩余，这是构造题的常用思路。
- **边界检查**：每一步都要验证是否符合条件（如`x_i ≤ m`、`sum(x_i) = k`）。
- **特判处理**：遇到特殊情况（如`n=p`）时，单独分析避免逻辑错误。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**（综合Unordered_OIer的简洁代码），它覆盖了所有核心逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自Unordered_OIer的题解，逻辑简洁、覆盖所有边界条件，是贪心构造的典型实现。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    typedef long long ll;
    const ll N = 1e5 + 5;
    ll x[N], y[N];

    ll read() {
        ll x = 0; char c = getchar();
        while (c < '0' || c > '9') c = getchar();
        while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
        return x;
    }

    int main() {
        ll n = read(), m = read(), k = read(), p = read();
        ll q = (k / p) > m ? m : (k / p); // 最大值q=min(m, k/p)
        if (k - q * p > (n - p) * (q - 1)) { // 剩余过多，无解
            puts("NO");
            return 0;
        }
        // 分配前p人
        for (ll i = 1; i <= p; ++i) x[i] = q, y[i] = m - q;
        ll rest = k - q * p;
        bool ff = true;
        // 分配剩余的人
        for (ll i = p + 1; i <= n; ++i) {
            if (ff && rest >= q - 1) { // 拿q-1
                x[i] = q - 1;
                rest -= q - 1;
            } else if (rest == 0) { // 无剩余
                x[i] = 0;
            } else { // 拿剩余的所有
                x[i] = rest;
                rest = 0;
                ff = false;
            }
            y[i] = m - x[i];
        }
        puts("YES");
        for (ll i = 1; i <= n; ++i) printf("%lld %lld\n", x[i], y[i]);
        return 0;
    }
    ```
* **代码解读概要**：
  1. **读取输入**：用快速读入函数`read()`处理大数据。
  2. **计算最大值`q`**：取`min(m, k/p)`。
  3. **判断无解**：若剩余`rest`超过`(n-p)*(q-1)`，输出`NO`。
  4. **分配前p人**：每人拿`q`个带记号纸团。
  5. **分配剩余的人**：依次拿`q-1`或剩余数量，直到`rest`用完。
  6. **输出结果**：打印每个人的`x_i`和`y_i`。

---

<code_intro_selected>
接下来分析3份优质题解的核心片段：
</code_intro_selected>

**题解一：来源：Unordered_OIer**
* **亮点**：用最简洁的逻辑处理剩余分配，避免冗余判断。
* **核心代码片段**：
    ```cpp
    ll q = min(m, k / p);
    if (k - q * p > (n - p) * (q - 1)) return puts("NO"), 0;
    for (ll i = 1; i <= p; ++i) x[i] = q, y[i] = m - q;
    ll rest = k - q * p;
    bool ff = true;
    for (ll i = p + 1; i <= n; ++i) {
        if (ff && rest >= q - 1) x[i] = q - 1, rest -= q - 1;
        else if (rest == 0) x[i] = 0;
        else x[i] = rest, rest = 0, ff = false;
        y[i] = m - x[i];
    }
    ```
* **代码解读**：
  - `q = min(m, k/p)`：直接计算最大值，避免超量。
  - `if (k - q*p > ...)`：判断剩余是否能被装下，无解则退出。
  - 循环分配剩余：用`ff`标记是否还能拿`q-1`，剩余不足时拿所有，逻辑清晰。
* 💡 **学习笔记**：简洁的逻辑往往是最有效的，避免过度复杂的判断。

**题解二：来源：HanPi**
* **亮点**：将剩余平均分配，用数学方法减少循环判断。
* **核心代码片段**：
    ```cpp
    hp = mymin(k/p, m);
    s = hp * p;
    a = k - s;
    h = a / other; // other = n-p
    mod = a % other;
    if (hp <= h || hp <= h + (mod ? 1 : 0)) puts("NO"), return 0;
    ```
* **代码解读**：
  - `h = a / other`：剩余平均每人拿`h`个。
  - `mod = a % other`：剩余`mod`人需要多拿1个。
  - `if (hp <= h || ...)`：判断剩余分配是否超过最大值减一，无解则退出。
* 💡 **学习笔记**：用数学计算代替循环判断，可以提高效率（尤其当`n`很大时）。

**题解三：来源：Maxmilite**
* **亮点**：明确处理`n=p`的情况，避免除数为0。
* **核心代码片段**：
    ```cpp
    if (n == p) {
        if (t * p == k) {
            printf("YES\n");
            for (int i = 1; i <= n; ++i) printf("%lld %lld\n", t, m - t);
        } else printf("NO\n");
        return 0;
    }
    ```
* **代码解读**：
  - 当`n=p`时，所有`x_i`必须等于`t`（`t=min(m, k/p)`），因此需要`t*p == k`（即`k%p == 0`）。
  - 直接输出结果或`NO`，避免后续循环中的错误（如`n-p=0`导致除数为0）。
* 💡 **学习笔记**：特判是解决边界问题的关键，尤其当变量可能为0时。


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观理解贪心构造的过程，我设计了一个**8位像素风格的“分蛋糕游戏”**动画，让你“看”到每一步分配！
</visualization_intro>

### 动画演示主题
**像素小朋友分蛋糕**：屏幕上有`n`个像素小朋友（红色是前`p`个，蓝色是剩余），黄色像素点代表带记号的纸团，每个小朋友最多拿`m`个（用灰色框表示容量）。

### 设计思路
采用FC红白机的8位风格（16色调色板），用简单的像素块和音效强化记忆：
- **颜色方案**：小朋友（红/蓝）、蛋糕（黄）、容量框（灰）、背景（浅蓝）。
- **音效设计**：拿最大值时“叮”（高频方波）、拿剩余时“嗒”（低频方波）、完成时“胜利曲”（8位音乐）、无解时“滴”（短促杂音）。
- **游戏化元素**：每分配完一个小朋友，底部显示“完成X/XX”，全部完成时屏幕闪星星（像素星星动画）。

### 动画帧步骤与交互关键点
1. **场景初始化**：
   - 屏幕显示`n`个小朋友（前`p`红，后`n-p`蓝），每个小朋友下方有灰色容量框（显示`m`）。
   - 顶部控制面板：“开始”“单步”“重置”按钮，调速滑块（1x~5x速度）。
   - 8位背景音乐（循环的“欢乐进行曲”）开始播放。

2. **分配前`p`人**：
   - 红色小朋友依次“拿起”`q`个黄色蛋糕（动画：黄色点从右侧“飞”到小朋友身上），伴随“叮”的音效。
   - 每分配一个，右侧显示剩余蛋糕数`rest = k - p*q`（初始为`k`，逐步减少）。

3. **分配剩余的人**：
   - 蓝色小朋友依次“拿起”`q-1`个蛋糕（动画：黄色点缓慢移动），伴随“嗒”的音效。
   - 若`rest`不足`q-1`，则拿剩余的所有（蛋糕变成绿色，闪烁提示），`rest`变为0。
   - 所有蓝色小朋友分配完后，剩余蛋糕数必须为0（否则显示“无解”，播放“滴”声）。

4. **完成状态**：
   - 所有小朋友分配完毕，屏幕闪星星，播放“胜利曲”，底部显示“分配完成！”。
   - 点击“重置”可重新开始，“单步”可查看每一步细节。

### 旁白提示
- 分配前`p`人时：“前p个小朋友拿最大值q，这样他们肯定是最多的！”
- 分配剩余时：“剩下的小朋友拿q-1，不能超过最大值哦～”
- 完成时：“所有蛋糕都分完啦，恰好p个小朋友拿最多！”

<visualization_conclusion>
通过这个动画，你能直观看到贪心构造的每一步——前p个拿最大值，剩余拿q-1，这样就能保证恰好p个“天选之人”。8位风格和音效让学习更有趣，也更容易记住核心逻辑！
</visualization_conclusion>


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
贪心构造是一类常见的编程问题，核心是“优先满足关键条件，再处理剩余”。以下是几个相似问题和练习推荐：
</similar_problems_intro>

### 通用思路迁移
贪心构造的思路可以解决：
1. **资源分配问题**（如分糖果、分任务）：优先满足关键角色的需求。
2. **构造符合条件的序列**（如构造最长递增子序列、构造回文串）：先确定核心元素，再填充剩余。
3. **计数问题**（如统计满足条件的方案数）：通过贪心确定边界，再计算可能性。

### 洛谷练习推荐
1. **洛谷 P1025 数的划分**
   - 🗣️ **推荐理由**：这道题需要构造将数分成若干份的方案，和“天选之人”一样需要贪心确定核心部分，再处理剩余。
2. **洛谷 P2670 扫雷游戏**
   - 🗣️ **推荐理由**：需要构造符合条件的扫雷布局，核心是“先确定边缘，再填充内部”，类似贪心的“优先满足关键条件”。
3. **洛谷 P3956 棋盘**
   - 🗣️ **推荐理由**：需要构造从起点到终点的路径，核心是“优先走最短路径，再调整细节”，锻炼贪心构造的能力。


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
几位作者的经验很有参考价值，我摘录了关键部分：
</insights_intro>

> **参考经验（来自Unordered_OIer）**：“贪心的核心是‘先满足最大值的条件，再处理剩余’，这样能保证恰好p个最大值。”
> **点评**：这句话点出了贪心的本质——优先解决最关键的问题（保证p个最大值），再处理次要问题（分配剩余）。这是构造题的通用思路。

> **参考经验（来自HanPi）**：“当n=p时，必须所有x_i相等，否则最大值的数量会超过p。”
> **点评**：特判是编程中容易忽略但非常重要的部分，尤其是当变量可能为0时（如n-p=0）。

> **参考经验（来自Maxmilite）**：“剩余分配时，尽可能拿q-1，这样能保证剩下的人都不超过最大值。”
> **点评**：贪心的“尽可能多拿但不违规”是保证正确性的关键，这样能让剩余纸团最少，避免超过限制。


---

<conclusion>
本次关于“天选之人”的分析就到这里！这道题的核心是**贪心构造**——先让p个拿到最大值，再处理剩余。通过动画演示和代码分析，相信你已经掌握了关键逻辑。记住：构造题的关键是“先确定核心，再填充细节”，多练习相似问题就能举一反三！下次我们再一起探索新的挑战！💪
</conclusion>

---

---
处理用时：124.20秒
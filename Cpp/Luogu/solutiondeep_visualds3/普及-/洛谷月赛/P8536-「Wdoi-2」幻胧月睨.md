# 题目信息

# 「Wdoi-2」幻胧月睨

## 题目背景

**Problem Number:** $\textit{39}$

**背景与题目无关，选手可以直接看下面的「简要题意」。**

那是在竹取物语之后的故事了，幻想乡距离与现实隔绝也已经过去了百年时光。

地上人向月球发起了侵略战争之后，一只名叫**铃仙**的月兔舍弃了同伴，死里逃生，逃到了在幻想乡内的永远亭，来到了辉夜与永琳的身边，生活得安稳而舒适。

又过了数十年，铃仙接收到了来自月球的使唤，被要求强制返回月球。辉夜与永琳商量了下，决定不将铃仙交还予月球。但为了避免造成麻烦，辉夜与永琳决定将满月消失在地上，只留下一轮虚假的月亮。

-----

为了方便调查异变，八云紫运用自己的能力，将整个幻想乡变成了永夜。

被穿梭回异变发生当时的四组主角，共八人。除了依然留有记忆，可以来回穿梭在虚与实的境界的八云紫之外，其他的人缺乏了记忆，重新开始踏上夺回幻想乡的满月的征途。

在慧音的指引之下，她们来到了迷途竹林，在她们的面前，是一只名叫铃仙的月兔。

## 题目描述

### 简要题意

给定一个长度为 $n$ 的 01 串 $b$，要求构造一个 $n$ 阶排列 $a$，满足，对于 $a_i(2\le i\le n)$，记 $m_i=\max_{j=1}^{i-1}\{a_j\}$，则：
  - 若 $b_i=1$，则 $a_i>m_i$;
  - 否则 $a_i<m_i$。

可以证明，总存在一个数列 $a$ 满足以上条件。

**如果有多组解，输出任意一种。**

同时注意到 $b_1$ 的取值是任意的，对数列 $a$ 没有影响。

### 原始题意

铃仙拥有操纵狂气程度的能力，换而言之，就是操纵物体的波长、振幅以及相位。这种能力为主角制造了种种障碍——例如操纵光波，会让弹幕虚虚实实，甚至会出现虚假的自我，对躲避弹幕造成极大的干扰。

以符卡「幻胧月睨」为例。「幻胧月睨」中一共有 $n$ 个弹幕，每个弹幕都会有一个相位，相位非 $0$ 即 $1$。这些弹幕的相位会构成一个长度为 $n$ 的数列 $\{b_i\}$。

铃仙会操纵这些弹幕的相位，将其变得千奇百怪。具体而言，被操纵了之后的弹幕的相位是一个长度为 $n$ 的**排列** $\{a_i\}$，即 $1 \sim n$ 的数字都会**不重不漏**地出现在这个序列之中。

为了加大主角躲避弹幕的难度，铃仙会设置一个阈值。对于每一个元素 $a_i$，阈值是其**前缀**的**最大**值，即 $a_1,a_2,\dots,a_{i-1}$ 中的最大值。若原来的第 $i$ 个弹幕的相位为 $1$，则被操纵后的弹幕的相位要**大于**这个阈值，否则被操纵后的弹幕的相位要**小于**这个阈值。

显然的是，根据铃仙的操纵规则，无论原本的弹幕的相位如何，都是存在可能的操纵方案的。由于主角们失去了记忆，而找回月亮的时间已经所剩不多了，而且弹幕战对时间的把控要求极高。她们找到了你，希望你能够对铃仙原本的弹幕相位，给出**任意一种**操作后的弹幕相位，来为她们的闪避弹幕进行准备。

## 说明/提示

### 样例解释

- 对于数据 $1$，显然 $a_2>1,a_3>2$。
- 对于数据 $2$，显然 $a_2<2,a_3>2$。
- 对于数据 $3$，显然 $a_2>1,a_3<3,a_4>3$。\
  注意到 $a=\{2,3,1,4\}$ 同样满足要求。

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{Subtask 依赖} & \textbf{分值}\\\hline
1 & 10 & - & - & 5\\\hline
2 & 10^5 & \textbf{A} & - & 5 \\\hline
3 & 10^5 & \textbf{B} & - & 20 \\\hline
4 & 10^5 & - & 1,2,3 &70 \\\hline
\end{array}$$

- **特殊性质** $\textbf{A}$：保证 $b_i$ 都相等。
- **特殊性质** $\textbf{B}$：存在整数 $p\in[2,n]$，使得对于 $1\le i<p$，有 $b_i=1$；对于 $n\ge i\ge p$，有 $b_i=0$。

对于全部数据，满足 $1\le T\le 10^4$，$1\le n\le 10^5$，$\forall i\in[1,n],b_i\in\{0,1\}$。

保证单个测试点内 $\sum n\le 5\times 10^5$。

## 样例 #1

### 输入

```
3
3
111
3
101
4
0101```

### 输出

```
1 2 3
2 1 3
1 3 2 4```

# AI分析结果

# 💡 Kay的C++算法解析：「Wdoi-2」幻胧月睨 深入学习指南 💡


今天我们来一起分析「Wdoi-2」幻胧月睨这道C++编程题。本指南将帮助大家梳理题目思路，理解核心构造技巧，并掌握解题的“固定套路”。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（构造性解法）

🗣️ **初步分析**：  
这道题的核心是**构造一个符合规则的排列**——就像“搭积木”一样，我们需要找到一种“固定套路”，让每个位置的数自动满足题目要求。题目要求：  
- 若`b_i=1`，则`a_i`必须大于前面所有数的最大值（称为“前缀最大值”）；  
- 若`b_i=0`，则`a_i`必须小于前缀最大值。  

**核心套路**：把0和1的位置“分开赋值”：  
- **0的位置**：填**从“0的个数”开始递减的数**（比如有2个0，就填2、1）；  
- **1的位置**：填**从“0的个数+1”开始递增的数**（比如有2个0，就填3、4、5…）。  

**为什么这样有效？**  
1. 1的位置的数是递增的，且比所有0的数大——所以必然大于前缀最大值（前缀最大值要么是之前的1的数，要么是当前1的数自己）；  
2. 0的位置的数是递减的，且比所有1的数小——所以必然小于前缀最大值（前缀最大值一定是某个1的数）；  
3. 所有数正好覆盖1~n（0的数占1~cnt0，1的数占cnt0+1~n），是合法排列。  

**可视化设计思路**：  
我们会用8位像素风展示构造过程：  
- 左侧是01串的像素块（0为蓝色，1为红色）；  
- 右侧是排列`a`的像素框，初始为空；  
- 统计0的个数时，用黄色像素块显示`cnt0`；  
- 处理每个位置时，0的位置从“小数池”（1~cnt0）取最大数（动画：蓝色块下滑），1的位置从“大数池”（cnt0+1~n）取最小数（动画：红色块上滑）；  
- 关键操作伴随音效：取小数是“叮”，取大数是“咚”，完成后播放胜利音效。


## 2. 精选优质题解参考

为了更好地理解解题过程，我筛选了以下思路清晰、代码简洁的优质题解：


### 题解一（作者：Larryyu）  
* **点评**：  
  这道题的“入门级”解法，直接把问题拆解为“0的位置填递减，1的位置填递增”。代码虽然变量名有点小“绕”（比如`tot`的计算），但逻辑非常直白——先统计1的个数，再反向推导0的个数，然后分别赋值。亮点是**用最朴素的思路解决问题**，适合初学者快速理解核心套路。


### 题解二（作者：chen_zhe）  
* **点评**：  
  这是最“标准”的解法！变量名清晰（`cnt0`统计0的个数，`current1`从`cnt0+1`开始），代码可读性极强。更重要的是，作者详细证明了构造的正确性——为什么这样填不会重复、不会遗漏、满足所有条件。亮点是**把“套路”变成“可证明的逻辑”**，帮你从“知其然”到“知其所以然”。


### 题解三（作者：McIron233）  
* **点评**：  
  思路非常新颖！用**双向队列**倒序填数——1的位置取队尾（最大数），0的位置取队头（最小数）。这种方法通过数据结构简化了构造过程，适合理解“队列如何辅助构造”。亮点是**用数据结构换思路清晰**，让你看到构造题的多种解法。


## 3. 核心难点辨析与解题策略

在解决构造题时，我们常遇到以下3个关键点：


### 1. 如何确保数满足前缀最大值的要求？  
**分析**：  
通过“分开赋值”——1的数递增且比0的数大，所以1的位置必然大于前缀最大值；0的数递减且比1的数小，所以0的位置必然小于前缀最大值。  
💡 **学习笔记**：构造题的核心是“设计规则，让条件自动满足”。


### 2. 如何保证排列不重复不遗漏？  
**分析**：  
0的数占1~cnt0（共cnt0个），1的数占cnt0+1~n（共n-cnt0个），两者正好覆盖1~n，没有重叠。  
💡 **学习笔记**：构造排列时，先“划分范围”再“填充”，是常用技巧。


### 3. 如何处理大数据量？  
**分析**：  
统计0的个数是O(n)，赋值也是O(n)，时间复杂度完全满足题目要求（n≤1e5）。  
💡 **学习笔记**：构造题的时间复杂度通常是O(n)，关键是“预处理”（比如统计cnt0）。


### ✨ 解题技巧总结  
- **拆解问题**：把复杂的条件拆解为“0的位置”和“1的位置”两个部分，分别处理；  
- **范围划分**：用“cnt0”划分小数和大数的范围，确保排列合法；  
- **验证正确性**：构造完成后，一定要用样例验证是否满足所有条件（比如前缀最大值的要求）。


## 4. C++核心代码实现赏析

在深入分析具体题解前，先看一个**通用核心实现**——综合了chen_zhe的清晰逻辑：


### 本题通用核心C++实现参考  
* **说明**：此代码来自chen_zhe的题解，变量名清晰，逻辑严谨，是最推荐的实现方式。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <string>
using namespace std;

const int MAX_N = 1e5 + 5;
char ch[MAX_N]; // 存储01串，下标从1开始

int main() {
    ios::sync_with_stdio(false); // 加速输入输出
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n >> (ch + 1); // 读取n和01串（ch[1]到ch[n]）
        int cnt0 = 0;
        // 第一步：统计0的个数
        for (int i = 1; i <= n; ++i) {
            if (ch[i] == '0') cnt0++;
        }
        int current0 = cnt0;    // 0的位置填current0（递减）
        int current1 = cnt0 + 1;// 1的位置填current1（递增）
        // 第二步：构造排列
        for (int i = 1; i <= n; ++i) {
            if (ch[i] == '0') {
                cout << current0 << ' ';
                current0--;
            } else {
                cout << current1 << ' ';
                current1++;
            }
        }
        cout << '\n';
    }
    return 0;
}
```  
* **代码解读概要**：  
  1. 读取测试用例数`T`；  
  2. 每个测试用例：  
     a. 读取`n`和01串（`ch[1]`到`ch[n]`）；  
     b. 统计0的个数`cnt0`；  
     c. `current0`初始化为`cnt0`（0的位置的第一个数），`current1`初始化为`cnt0+1`（1的位置的第一个数）；  
     d. 遍历每个位置，0的位置输出`current0`并递减，1的位置输出`current1`并递增。


### 针对各优质题解的片段赏析

#### 题解一（Larryyu）：朴素思路的实现  
* **亮点**：用最直接的方式统计1的个数，反向推导0的个数。  
* **核心代码片段**：  
```cpp
int tot = 0;
for (int i = 1; i <= n; i++) {
    if (s[i-1] == '1') tot++;
}
tot = n - tot + 1; // 计算1的位置的起始值（等价于cnt0+1）
int cnt = tot - 1;  // 计算0的位置的起始值（等价于cnt0）
```  
* **代码解读**：  
  - `tot`先统计1的个数，然后`n - tot`是0的个数（`cnt0`），所以`tot = cnt0 + 1`（1的起始值）；  
  - `cnt = tot - 1 = cnt0`（0的起始值）。  
* 💡 **学习笔记**：有时候“反向推导”也是一种简单的方式，只要逻辑正确。


#### 题解三（McIron233）：队列的巧妙应用  
* **亮点**：用双向队列倒序填数，避免了统计cnt0。  
* **核心代码片段**：  
```cpp
int hed = 1, til = n;
for (int i = n; i >= 1; i--) {
    if (ch[i] == '1') a[i] = til--; // 1的位置取队尾（最大数）
    else a[i] = hed++;              // 0的位置取队头（最小数）
}
```  
* **代码解读**：  
  - 队列的头是`hed`（初始1），尾是`til`（初始n）；  
  - 倒序遍历01串：1的位置取队尾（最大数），0的位置取队头（最小数）；  
  - 最终`a`数组就是符合条件的排列。  
* 💡 **学习笔记**：数据结构可以简化构造过程，比如队列的头尾操作可以快速获取最大/最小值。


## 5. 算法可视化：像素动画演示 (核心部分)

为了更直观地理解“分开赋值”的构造过程，我设计了一个**8位像素风的动画**，灵感来自FC红白机的“积木游戏”：


### ✨ 动画演示主题  
**像素建造师**：你是一名像素建造师，需要根据01串的“蓝图”（蓝色是0，红色是1），用“小数块”（1~cnt0）和“大数块”（cnt0+1~n）搭建排列。


### 🎮 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是01串的像素块（每个块20x20像素，0为蓝色，1为红色）；  
   - 屏幕右侧是排列`a`的“地基”（10个空像素框，等待填充）；  
   - 屏幕下方显示`cnt0`（黄色像素块，比如“2”）；  
   - 背景是FC风格的“天空”（浅蓝色），播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。

2. **统计cnt0**：  
   - 动画开始时，一个“像素机器人”从左到右扫描01串，遇到蓝色块（0）就点亮一个黄色小灯；  
   - 扫描完成后，下方的`cnt0`显示为黄色数字（比如“2”），伴随“叮”的音效。

3. **构造排列**：  
   - 机器人开始逐个处理01串的像素块：  
     - **遇到蓝色块（0）**：从屏幕下方的“小数池”（1~cnt0的白色像素块）中取出最大的数（比如2），动画是“蓝色块下滑到地基”，伴随“叮”的音效；  
     - **遇到红色块（1）**：从屏幕上方的“大数池”（cnt0+1~n的橙色像素块）中取出最小的数（比如3），动画是“红色块上滑到地基”，伴随“咚”的音效；  
   - 每个数填入地基后，地基的像素框会闪烁一下，提示“已填充”。

4. **完成动画**：  
   - 所有位置填充完成后，地基的所有像素框会同步闪烁3次，播放胜利音效（比如《魂斗罗》的通关音乐）；  
   - 屏幕中央弹出“完成！”的像素文字，下方显示构造的排列。


### 🕹️ 交互设计  
- **步进控制**：点击“单步”按钮，机器人会处理下一个位置；  
- **自动播放**：滑动“速度条”调整播放速度（最慢1秒/步，最快0.1秒/步）；  
- **重置**：点击“重置”按钮，回到初始状态，重新构造。


### 🎨 颜色方案  
| 元素          | 颜色       |
|---------------|------------|
| 0的像素块     | 蓝色（#00F）|
| 1的像素块     | 红色（#F00）|
| cnt0显示      | 黄色（#FF0）|
| 小数块        | 白色（#FFF）|
| 大数块        | 橙色（#F90）|
| 地基框        | 灰色（#CCC）|


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的“分开赋值”技巧可以解决**所有“按条件构造排列”的问题**，比如：  
1. 构造一个排列，使得偶数位置的数是偶数，奇数位置的数是奇数；  
2. 构造一个排列，使得每个数的左边有k个比它小的数；  
3. 构造一个排列，使得相邻数的差的绝对值大于2。


### 练习推荐 (洛谷)  
以下题目可以帮助你巩固构造题的技巧：  

1. **洛谷 P8536** - 「Wdoi-2」幻胧月睨  
   🗣️ **推荐理由**：原题！再做一遍，巩固“分开赋值”的套路。  

2. **洛谷 P1097** - 统计数字  
   🗣️ **推荐理由**：练习“统计个数”的预处理技巧，这是构造题的基础。  

3. **洛谷 P1152** - 欢乐的跳  
   🗣️ **推荐理由**：构造一个“相邻差不重复”的排列，锻炼你的构造思维。  

4. **洛谷 P2670** - 扫雷游戏  
   🗣️ **推荐理由**：模拟构造一个扫雷棋盘，练习“按规则填充”的技巧。


## 7. 学习心得与经验分享 (若有)

本次分析的题解中，**chen_zhe的题解**提供了非常宝贵的经验：  
> “这样构造为什么是正确的呢？因为1的数单调递增且比0的数大，所以满足b_i=1的要求；0的数单调递减且比1的数小，所以满足b_i=0的要求。”  

**点评**：构造题的关键是“证明正确性”——不要只记住套路，要理解“为什么这样做是对的”。比如本题中，只要证明1的数一定大于前缀最大值，0的数一定小于前缀最大值，就能确定构造是正确的。


## 结语  
本次关于「Wdoi-2」幻胧月睨的C++解题分析就到这里。构造题的核心是“找套路+证正确”，希望这份指南能帮助你掌握这个技巧。记住：**编程的乐趣在于用代码“搭建”出符合规则的世界**，下次我们再一起探索新的构造题！💪

---
处理用时：153.46秒
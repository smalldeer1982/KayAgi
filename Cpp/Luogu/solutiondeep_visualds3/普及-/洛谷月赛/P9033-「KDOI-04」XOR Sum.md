# 题目信息

# 「KDOI-04」XOR Sum

## 题目背景

凯文一眼秒了这题。

![](https://cdn.luogu.com.cn/upload/image_hosting/lh1xvu75.png)

## 题目描述

给定一个正整数 $n$，请构造一个长度为 $n$ 的**非负整数**序列 $a_1,a_2,\dots,a_n$，满足：

+ 对于所有 $1\le i\le n$，都有 $0\le a_i\le m$。
+ $a_1\oplus a_2\oplus\dots\oplus a_n=k$。其中 $\oplus$ 表示[按位异或](https://baike.baidu.com/item/%E5%BC%82%E6%88%96/10993677)运算。

或者判断不存在这样的序列。

## 说明/提示

**【样例解释】**

对于第 $1$ 组测试数据，有且仅有一个序列满足条件。

对于第 $2$ 组测试数据，由于 $4\oplus 7=3$ 且 $4,7\le10$，所以这是一个合法的答案。同样地，序列 $(2,1)$ 也是一个合法的答案。

对于第 $4$ 组测试数据，可以证明不存在满足要求的序列。

**【数据范围】**

记 $\sum n$ 为单个测试点中所有 $n$ 的值之和。

对于所有测试数据，保证 $1\le T\le 1~000$，$1\le n\le 2\cdot10^5$，$0\le m,k\le 10^8$，$\sum n\le 2\cdot10^5$。

**【子任务】**

**本题开启捆绑测试。**

+ Subtask 1 (18 pts)：$k\le m$。
+ Subtask 2 (82 pts)：没有额外的约束条件。

## 样例 #1

### 输入

```
5
1 2 2
2 3 10
2 11 8
20 200000 99999
11 191 9810```

### 输出

```
2 
4 7 
8 3 
-1
191 191 191 191 191 191 191 191 191 191 191 ```

# AI分析结果

---
# 💡 Kay的C++算法解析：「KDOI-04」XOR Sum 深入学习指南 💡

<introduction>
  今天我们要解决的是「KDOI-04」XOR Sum这道**构造题**——核心是用「异或的性质」拼出满足条件的序列。就像用积木搭房子：要么直接用一块刚好大小的积木（k≤m），要么用两块小积木拼出目标（k>m但能拆分）。让我们一起拆解思路吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（异或性质的灵活运用 + 构造思路）

🗣️ **初步分析**：
> 解决这道题的关键是理解**异或（⊕）**的两个核心性质：  
> 1. **异或0不变**：任何数异或0都等于它自己（比如5⊕0=5）——这意味着我们可以用「0」填充序列的剩余位置，不影响结果。  
> 2. **异或不进位**：异或的结果二进制位数**不会超过任意一个 operand（参与运算的数）的位数**（比如101⊕110=011，位数还是3位）——这决定了如果k的位数比m大，肯定无法构造（因为所有数都≤m，异或不出更高位的1）。  

解题思路可以总结为**「分情况构造」**：
- **情况1**：如果k≤m → 直接把第一个数设为k，后面全填0（利用「异或0不变」，总异或和就是k）。  
- **情况2**：如果k>m → 先检查m的位数是否≥k的位数（否则无解）。若满足且n≥2，就把k拆成**两个≤m的数**（比如m和m⊕k，因为m⊕(m⊕k)=k，且m⊕k≤m），后面全填0。  

**核心难点**：
1. 理解异或的「位数限制」（为什么m的位数必须≥k的位数？）；  
2. 如何正确拆分k为两个≤m的数；  
3. 处理边界条件（比如n=1时k>m肯定无解）。  

**可视化设计思路**：  
我们会用「8位像素积木」模拟序列构造过程——每个积木代表序列中的一个数，颜色高亮当前操作的数。比如：
- k≤m时，第一个积木变成k（红色闪烁），后面的变成0（灰色），伴随「咔嗒」的放置音效；  
- k>m时，前两个积木分别变成m和m⊕k（蓝色交替闪烁），后面的变成0，伴随「叮」的拆分音效；  
- 无解时，屏幕显示像素风格的「-1」，伴随短促的「嗡」声。


---

## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、算法有效性」三个维度筛选了3份优质题解，覆盖了不同的构造思路，适合大家对比学习～
</eval_intro>

**题解一：JuRuoOIer（赞11）**
* **点评**：这份题解的「分情况逻辑」非常严谨，像剥洋葱一样层层拆解问题：  
  - 第一步用`log2`函数计算m和k的二进制位数，直接判断「m的位数是否小于k」（无解）；  
  - 第二步处理k≤m的情况（直接输出k+0）；  
  - 第三步处理k>m的情况：拆k为「最高位的2^p」和「k-2^p」，并特判n=1时无解。  
  代码风格简洁，变量命名清晰（比如`log2`函数计算位数），边界条件处理得很到位——比如n=1时k>m直接输出-1，避免了无效构造。

**题解二：佬头（赞3）**
* **点评**：这份题解的「异或性质运用」更巧妙！它直接利用「m⊕(m⊕k)=k」的性质，将k拆成m和m⊕k——只要m⊕k≤m且n≥2，就能构造成功。  
  这种思路**省去了计算最高位的步骤**，代码更简洁（比如直接输出m和m⊕k），非常适合理解异或的「逆运算」性质。

**题解三：Clarinet（赞0）**
* **点评**：这份题解的「新手友好度」最高！作者用例子解释了异或的三个关键性质（异或0不变、异或不进位、异或逆运算），并把「无解条件」封装成`check`函数（比较m和k的位数）。  
  代码逻辑直观，注释明确——比如k>m时输出m和m⊕k，后面补0，非常适合初学者模仿。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
构造题的关键是「想通为什么这样做」。结合优质题解的共性，我提炼了3个核心难点和对应的解决策略：
</difficulty_intro>

1.  **难点1：异或的「位数限制」怎么理解？**  
    * **分析**：异或是「不进位加法」，比如101（5）⊕110（6）=011（3）——结果的位数不会超过5或6的位数。如果k的位数比m大（比如k=8，m=7），那么所有数都≤7（位数3），异或不出8（位数4），所以无解。  
    * **策略**：用「不断除以2」的方法计算二进制位数（比如k=8→8/2=4→4/2=2→2/2=1→1/2=0，共4位），比较m和k的位数。  
    * 💡 **学习笔记**：异或的位数不会「凭空增加」，这是判断无解的核心依据！

2.  **难点2：k>m时，怎么拆成两个≤m的数？**  
    * **分析**：有两种常用方法：  
      - 方法1（最高位拆分）：取k的最高位2^p（比如k=11→二进制1011，最高位是8=2^3），则另一个数是k-2^p（11-8=3）——这两个数的异或就是k（8⊕3=11），且都≤m（因为m的位数≥k的位数）。  
      - 方法2（异或逆运算）：直接取m和m⊕k——因为m⊕(m⊕k)=k，且m⊕k≤m（当m和k位数相同时）。  
    * **策略**：任选一种方法，只要保证两个数都≤m即可。  
    * 💡 **学习笔记**：异或的「逆运算」（a⊕b=c → b=a⊕c）是构造的关键！

3.  **难点3：边界条件（比如n=1）怎么处理？**  
    * **分析**：如果n=1，序列只能有一个数——这个数必须等于k且≤m，否则无解。  
    * **策略**：在k>m时，先检查n是否≥2——如果n=1，直接输出-1。  
    * 💡 **学习笔记**：构造题一定要考虑「最少需要多少个数」！

### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我总结了构造题的通用技巧：
</summary_best_practices>
- **利用基础性质简化构造**：比如异或0不变，所以剩余位置填0即可；  
- **分情况讨论**：把问题拆成「k≤m」和「k>m」两种情况，逐一解决；  
- **边界条件优先处理**：比如n=1、m的位数小于k，这些情况直接判无解，避免无效计算。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解思路的通用实现**——它覆盖了所有情况，逻辑清晰，适合作为模板～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合了JuRuoOIer的「位数判断」和佬头的「异或逆运算」思路，兼顾严谨性和简洁性。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    // 计算二进制位数（比如k=8→返回4）
    int get_bits(int x) {
        int cnt = 0;
        while (x) { cnt++; x /= 2; }
        return cnt;
    }

    int main() {
        int T; cin >> T;
        while (T--) {
            int n, k, m; cin >> n >> k >> m;
            int bits_k = get_bits(k), bits_m = get_bits(m);
            
            // 无解情况1：m的位数小于k的位数
            if (bits_m < bits_k) { cout << "-1\n"; continue; }
            // 无解情况2：n=1且k>m
            if (n == 1) { 
                if (k <= m) cout << k << "\n";
                else cout << "-1\n";
                continue;
            }
            
            // 情况1：k≤m→直接输出k+0
            if (k <= m) {
                cout << k;
                for (int i = 1; i < n; i++) cout << " 0";
                cout << "\n";
            } 
            // 情况2：k>m→拆成m和m^k
            else {
                int x = m ^ k;
                if (x > m) { cout << "-1\n"; continue; } // 理论上不会发生
                cout << m << " " << x;
                for (int i = 2; i < n; i++) cout << " 0";
                cout << "\n";
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. 用`get_bits`函数计算二进制位数，判断无解；  
    > 2. 处理n=1的边界情况；  
    > 3. k≤m时，输出k和n-1个0；  
    > 4. k>m时，输出m、m^k和n-2个0（利用异或逆运算）。

---
<code_intro_selected>
接下来看优质题解的「核心片段」，学习它们的巧妙之处～
</code_intro_selected>

**题解一：JuRuoOIer（最高位拆分）**
* **亮点**：用「最高位拆分」的方法构造两个数，适合理解异或的「位数特性」。
* **核心代码片段**：
    ```cpp
    int log2(ll x) { // 计算二进制位数
        ll ans = 0;
        while (x) { ans++; x /= 2; }
        return ans;
    }
    // k>m时的构造：
    cout << (1ll << (log2(k)-1)) << ' ' << (k - (1ll << (log2(k)-1)));
    ```
* **代码解读**：
    > `log2(k)-1`是k的最高位的指数（比如k=11→log2(k)=4→最高位是2^3=8）。`1ll << (log2(k)-1)`就是最高位的数值，`k - 这个数`是剩余部分——这两个数的异或就是k，且都≤m（因为m的位数≥k的位数）。  
* 💡 **学习笔记**：最高位拆分是构造异或和的经典方法！

**题解二：佬头（异或逆运算）**
* **亮点**：用「m⊕k」直接构造第二个数，代码简洁到极致。
* **核心代码片段**：
    ```cpp
    if((m ^ k) <= m && n > 1) {
        for(int i = 2; i < n; ++i) fputs("0 ", stdout);
        write(m), putchar(' ');
        write(m ^ k), putchar('\n');
    }
    ```
* **代码解读**：
    > 因为m⊕(m⊕k)=k，所以只要m⊕k≤m且n≥2，就可以用m和m⊕k构造。比如m=10，k=3→m⊕k=9≤10，所以序列是[10,9]，异或和是3。  
* 💡 **学习笔记**：异或的逆运算能帮你「一步到位」构造第二个数！

**题解三：Clarinet（位数判断函数）**
* **亮点**：把「位数判断」封装成函数，逻辑更清晰。
* **核心代码片段**：
    ```cpp
    bool check(int x, int y) { // 判断x的位数是否小于y的
        int xr=0, yr=0;
        while(x) { xr++; x/=2; }
        while(y) { yr++; y/=2; }
        return xr < yr;
    }
    ```
* **代码解读**：
    > 用两个循环分别计算x和y的位数，返回x的位数是否小于y的——这是判断无解的关键条件（比如m的位数小于k的位数，返回true，输出-1）。  
* 💡 **学习笔记**：封装重复逻辑能让代码更易读！


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家「看得到」异或构造的过程，我设计了一个**8位像素风格的动画**——《像素积木拼拼乐》，像玩FC游戏一样理解算法！
</visualization_intro>

  * **动画演示主题**：用像素积木块拼出目标序列，背景是FC风格的蓝白网格，控制面板有「开始/暂停」「单步」「重置」按钮。
  * **核心演示内容**：展示两种构造情况（k≤m、k>m）和无解情况，重点突出「积木的变化」和「异或的作用」。
  * **设计思路简述**：  
    用「像素积木」代表序列元素，颜色区分状态（红色=当前操作的数，蓝色=拆分后的数，灰色=0）；用「复古音效」强化记忆（放置积木=咔嗒，拆分=叮，无解=嗡）——让你在玩的过程中记住算法逻辑！

  * **动画帧步骤与交互关键点**：
    1.  **初始化**：屏幕显示n个灰色空积木位，控制面板在下方，播放8位风格的轻松BGM（比如《超级马里奥》的背景音乐）。
    2.  **情况1：k≤m**：  
        - 点击「开始」，第一个积木块变成红色（显示k），伴随「咔嗒」声；  
        - 后面的积木块依次变成灰色（显示0），每变一个块，屏幕右上角弹出提示：「异或0不变，总异或和还是k！」。
    3.  **情况2：k>m且可行**：  
        - 点击「开始」，前两个积木块变成蓝色（分别显示m和m⊕k），交替闪烁，伴随「叮」的拆分声；  
        - 屏幕弹出提示：「m⊕(m⊕k)=k，这两个数的异或就是目标！」；  
        - 后面的积木块变成灰色（显示0）。
    4.  **无解情况**：  
        - 点击「开始」，屏幕中央显示像素风格的「-1」，伴随短促的「嗡」声；  
        - 提示框弹出：「m的位数小于k，无法拼出！」。
    5.  **交互控制**：  
        - 「单步」：逐帧查看积木变化，适合仔细研究；  
        - 「自动播放」：快速播放完整过程，适合整体理解；  
        - 「重置」：回到初始状态，重新演示。

<visualization_conclusion>
通过这个动画，你能「亲眼看到」异或构造的每一步——积木的变化、音效的提示，让抽象的异或性质变得直观！
</visualization_conclusion>


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
异或的构造思路不仅能解决本题，还能用到很多类似问题中。比如「用最少的数构造异或和」「异或路径规划」等～
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 异或0不变：用0填充剩余位置；  
    - 异或逆运算：a⊕b=c → b=a⊕c，用于构造第二个数；  
    - 位数限制：异或结果的位数不超过operand的位数，用于判断无解。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1469** - 找筷子  
          * 🗣️ **推荐理由**：考察异或的「偶数次抵消」性质（a⊕a=0），是异或的基础应用。
    2.  **洛谷 P2154** - [SDOI2009] 虔诚的墓主人  
          * 🗣️ **推荐理由**：需要用异或处理坐标变换，拓展异或的应用场景。
    3.  **洛谷 P3901** - 数列找不同  
          * 🗣️ **推荐理由**：用异或快速判断重复元素，锻炼异或的「抵消」思维。


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的「作者心得」能帮我们避开坑！比如：
</insights_intro>

> **参考经验 (来自 JuRuoOIer)**：「赛时唯一AC的题目，关键是想通了异或的位数限制——之前卡了很久，后来画了几个二进制例子才明白。」  
> **点评**：这位作者的经验很真实！构造题往往需要「举例子」——比如k=11（1011），m=10（1010），画二进制位就能快速想到拆分方法。  
> **参考经验 (来自 Clarinet)**：「异或的三个性质一定要记牢，不然构造的时候会乱！」  
> **点评**：基础性质是构造的基石——比如异或逆运算（m⊕k），如果记不住，就无法想到简洁的构造方法。


---

<conclusion>
本次关于「KDOI-04」XOR Sum的分析就到这里啦！构造题的关键是「理解性质+分情况讨论」——就像搭积木，先想清楚用什么积木，再一步步拼。下次遇到异或构造题，不妨先回忆今天学的「位数限制」「异或逆运算」，一定能快速找到思路！💪
</conclusion>

---

---
处理用时：138.65秒
# 题目信息

# 海战

## 题目背景

在峰会期间，武装部队得处于高度戒备。警察将监视每一条大街，军队将保卫建筑物，领空将布满了 F-2003 飞机。

此外，巡洋船只和舰队将被派去保护海岸线。不幸的是，因为种种原因，国防海军部仅有很少的几位军官能指挥大型海战。因此，他们培养了一些新海军指挥官。军官们选择了“海战”游戏来帮助他们学习。

## 题目描述

在一个方形的盘上，放置了固定数量和形状的船只，每只船却不能碰到其它的船。在本题中，我们认为船是方形的，所有的船只都是由图形组成的方形。

求出该棋盘上放置的船只的总数。

## 说明/提示

对于 $100\%$ 的数据，$1 \le R,C \le 1000$。

## 样例 #1

### 输入

```
6 8
.....#.#
##.....#
##.....#
.......#
#......#
#..#...#```

### 输出

```
There are 5 ships.
```

# AI分析结果

# 💡 Kay的C++算法解析：海战 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：搜索（DFS/BFS）与矩形判断、邻接情况特判


### 🗣️ 初步分析
想象一下，你在一张网格纸上玩“找矩形”游戏——每个矩形代表一艘船，船不能重叠或“碰”到一起（比如两个矩形共享一条边或一个角）。你的任务是找出所有合法的矩形船，并统计数量；如果有船“碰”到了，就直接说“摆错了”。

**核心算法思路**：  
- **第一步：特判“碰船”**：如果网格中存在任何一个2×2的小方块有3个`#`（比如`##`和`#.`组成的角落），说明两艘船相邻，直接输出`Bad placement.`。  
- **第二步：统计合法船**：用搜索（DFS/BFS）找到所有`#`的连通块，判断每个连通块是否是矩形（比如用边界坐标计算面积，是否等于连通块大小）；或者更高效的方法——统计每个矩形的“左上角”（即该`#`的上方和左方都是`.`），因为每个矩形只有一个左上角。

**可视化设计思路**：  
用8位像素风格展示网格，`#`用蓝色方块表示，`.`用白色。动画分两步：  
1. **特判阶段**：逐个检查2×2区域，若有3个`#`，用红色闪烁标记该区域，并播放“警告”音效（比如`叮——`）。  
2. **统计阶段**：用DFS标记连通块（蓝色方块逐渐变成绿色），或者用黄色标记矩形的左上角，每找到一个左上角播放“加分”音效（比如`滴`）。  


## 2. 精选优质题解参考

### 题解一：作者·钱逸凡（赞：196）
**点评**：  
这份题解的思路像“先排雷再寻宝”——先检查所有2×2区域有没有“雷”（3个`#`），如果有直接退出；没有的话，用DFS把每个连通块的`#`改成`*`（标记为已统计），统计连通块数量就是船的数量。思路清晰，代码简洁，尤其是特判函数`d(i,j)`只用了4行就判断了2×2区域的`#`数量，非常巧妙。代码中的`dfs`函数用递归标记连通块，容易理解，适合新手学习。


### 题解二：作者·Dzhao（赞：85）
**点评**：  
这道题解的“亮点”是**不用搜索统计船的数量**！作者发现，合法的矩形船的左上角一定满足：上方和左方都是`.`（或者在边界）。所以直接遍历网格，统计这样的`#`数量就是船的数量。这种方法比搜索更高效（时间复杂度O(nm)），代码也更短。特判部分和钱逸凡的题解一样，用了2×2区域的检查，非常经典。


### 题解三：作者·MY（赞：103）
**点评**：  
这份题解适合“不会搜索的同学”。作者用“伪DFS”的方法：找到一个`#`后，先算出它所在矩形的边长（向右找最长连续`#`得到宽，向下找最长连续`#`得到高），然后检查这个矩形内的所有`#`是否合法（比如每一行的`#`数量是否等于宽，每一列是否等于高）。如果合法，就把矩形内的`#`改成`*`，统计数量。思路很“直观”，像“用尺子量矩形”，容易理解。


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何快速判断“碰船”？**  
**分析**：“碰船”的本质是两个矩形船相邻，导致存在2×2区域有3个`#`。比如：  
```
##
#.
```  
这种情况，2×2区域有3个`#`，说明两艘船相邻。解决方法是遍历所有2×2区域，统计`#`数量，若等于3则直接退出。  
**学习笔记**：2×2区域的特判是解决“碰船”问题的关键，记住这个“小技巧”能快速解决类似问题。


### 2. **难点2：如何统计合法的矩形船？**  
**分析**：合法的矩形船有两个特点：① 是连通块；② 是矩形（面积等于长×宽）。解决方法有两种：  
- **方法1（搜索）**：用DFS/BFS找到连通块，记录连通块的最小、最大行和列（比如`min_x, max_x, min_y, max_y`），计算面积`(max_x - min_x + 1) × (max_y - min_y + 1)`，如果等于连通块的大小（`#`的数量），则是合法矩形。  
- **方法2（统计左上角）**：合法矩形的左上角一定满足：上方（`i-1,j`）和左方（`i,j-1`）都是`.`（或者在边界）。直接统计这样的`#`数量即可。  
**学习笔记**：统计左上角的方法更高效，适合数据量大的情况。


### 3. **难点3：如何处理连通块？**  
**分析**：处理连通块的常用方法是DFS（递归）或BFS（队列）。比如钱逸凡的题解用了DFS，把每个连通块的`#`改成`*`，避免重复统计。  
**学习笔记**：DFS的递归写法很简洁，但要注意递归深度（比如网格很大时可能栈溢出），这时候可以用BFS代替。


### ✨ 解题技巧总结
- **特判优先**：先处理“碰船”情况，避免后续无用计算。  
- **选择高效方法**：统计左上角比搜索更高效，适合数据量大的题目。  
- **标记已访问**：处理连通块时，一定要标记已访问的`#`，避免重复统计。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（综合钱逸凡、Dzhao的思路）
**说明**：本代码综合了特判2×2区域和统计左上角的方法，高效解决问题。  
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAX = 1010;
char g[MAX][MAX];
int n, m;

// 特判2×2区域是否有3个#
bool check(int i, int j) {
    int cnt = 0;
    if (g[i][j] == '#') cnt++;
    if (g[i+1][j] == '#') cnt++;
    if (g[i][j+1] == '#') cnt++;
    if (g[i+1][j+1] == '#') cnt++;
    return cnt == 3;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> g[i][j];
        }
    }

    // 第一步：特判碰船
    for (int i = 1; i < n; i++) {
        for (int j = 1; j < m; j++) {
            if (check(i, j)) {
                cout << "Bad placement." << endl;
                return 0;
            }
        }
    }

    // 第二步：统计左上角的#数量（合法船的数量）
    int ans = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (g[i][j] == '#' && (i == 1 || g[i-1][j] == '.') && (j == 1 || g[i][j-1] == '.')) {
                ans++;
            }
        }
    }

    cout << "There are " << ans << " ships." << endl;
    return 0;
}
```
**代码解读概要**：  
- **特判部分**：遍历所有2×2区域，用`check`函数统计`#`数量，若等于3则输出`Bad placement.`。  
- **统计部分**：遍历网格，统计满足“上方和左方都是`.`”的`#`数量，即为合法船的数量。


### 题解一（钱逸凡）核心代码片段
**亮点**：用DFS标记连通块，避免重复统计。  
```cpp
// DFS函数：把与(x,y)连通的#改成*
void dfs(int x, int y) {
    g[x][y] = '*';
    // 四个方向
    int dx[] = {0, -1, 1, 0};
    int dy[] = {-1, 0, 0, 1};
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && g[nx][ny] == '#') {
            dfs(nx, ny);
        }
    }
}
```
**代码解读**：  
- `dfs`函数用递归的方式，把当前`#`改成`*`（标记为已访问），然后递归处理四个方向的`#`。这样，每个连通块只会被处理一次，统计连通块数量就是船的数量。  
**学习笔记**：DFS是处理连通块的常用方法，递归写法很简洁，但要注意边界条件（比如`nx`和`ny`不能超过网格范围）。


### 题解二（Dzhao）核心代码片段
**亮点**：统计左上角的`#`数量，高效统计船的数量。  
```cpp
// 统计左上角的#数量
int ans = 0;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (g[i][j] == '#' && g[i-1][j] != '#' && g[i][j-1] != '#') {
            ans++;
        }
    }
}
```
**代码解读**：  
- 合法矩形的左上角一定满足：上方（`i-1,j`）和左方（`i,j-1`）都不是`#`（或者在边界）。比如，网格中的第一个`#`（`i=1,j=1`）就是左上角；如果`i=2,j=3`的上方（`i=1,j=3`）是`.`，左方（`i=2,j=2`）是`.`，那么它也是左上角。统计这样的`#`数量，就是合法船的数量。  
**学习笔记**：这种方法不用搜索，时间复杂度是O(nm)，比搜索更高效，适合数据量大的题目。


### 题解三（MY）核心代码片段
**亮点**：用“伪DFS”确定矩形边长，判断是否合法。  
```cpp
// 伪DFS函数：处理(x,y)所在的矩形
void dfs(int x, int y) {
    int heng, shu;
    // 计算矩形的宽（向右找最长连续#）
    for (shu = y; shu <= m && g[x][shu] == '#'; shu++);
    shu--;
    // 计算矩形的高（向下找最长连续#）
    for (heng = x; heng <= n && g[heng][y] == '#'; heng++);
    heng--;
    // 检查矩形内的每一行是否都有shu - y + 1个#
    for (int i = y; i <= shu; i++) {
        int cnt = 0;
        for (int j = x; j <= heng && g[j][i] == '#'; j++) {
            cnt++;
        }
        if (cnt != heng - x + 1) {
            cout << "Bad placement." << endl;
            exit(0);
        }
    }
    // 把矩形内的#改成*
    for (int i = x; i <= heng; i++) {
        for (int j = y; j <= shu; j++) {
            g[i][j] = '*';
        }
    }
    ans++;
}
```
**代码解读**：  
- 首先，计算矩形的宽（`shu`）：从`(x,y)`向右找最长连续的`#`。  
- 然后，计算矩形的高（`heng`）：从`(x,y)`向下找最长连续的`#`。  
- 接着，检查矩形内的每一行是否都有`heng - x + 1`个`#`（即高的长度），如果有一行不符合，说明矩形不合法，输出`Bad placement.`。  
- 最后，把矩形内的`#`改成`*`，避免重复统计，统计数量加一。  
**学习笔记**：这种方法不用递归，适合不会搜索的同学，但要注意计算边长时的边界条件（比如`shu`不能超过`m`）。


## 5. 算法可视化：像素动画演示（核心部分）

### 🎮 动画演示主题：《海战寻宝》（8位像素风格）


### 🎨 设计思路简述
用FC红白机的风格展示网格，`#`用蓝色方块表示，`.`用白色。动画分两步：  
1. **排雷阶段**：逐个检查2×2区域，若有3个`#`，用红色闪烁标记该区域，并播放“警告”音效（`叮——`）。  
2. **寻宝阶段**：用黄色标记矩形的左上角，每找到一个左上角，播放“加分”音效（`滴`），同时蓝色方块逐渐变成绿色（表示已统计）。


### 📽️ 动画帧步骤
1. **初始化**：展示一个10×10的网格（用像素方块组成），上方有“开始”“单步”“重置”按钮，下方有进度条。  
2. **排雷阶段**：  
   - 光标（红色箭头）逐个移动到每个2×2区域的左上角（比如`(1,1)`、`(1,2)`……）。  
   - 若该区域有3个`#`，则用红色闪烁标记该区域，同时弹出文字“发现碰船！”，播放“警告”音效。  
   - 若没有碰船，光标继续移动，直到检查完所有区域。  
3. **寻宝阶段**：  
   - 光标（黄色箭头）逐个移动到每个`#`的位置。  
   - 若该`#`是左上角（上方和左方都是`.`），则用黄色标记该位置，播放“加分”音效（`滴`），同时该矩形内的蓝色方块逐渐变成绿色（表示已统计）。  
   - 统计数量显示在屏幕右上角（比如“船只数量：3”）。  
4. **结束**：当所有`#`都被处理后，播放“胜利”音效（`啦啦啦`），显示最终结果（比如“There are 5 ships.”）。


### 🎵 音效设计
- **警告**：当发现碰船时，播放`叮——`（高频短音）。  
- **加分**：当找到左上角时，播放`滴`（低频短音）。  
- **胜利**：当统计完成时，播放`啦啦啦`（轻快的旋律）。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移
本题的核心思路（特判邻接情况、统计矩形数量）可以迁移到以下场景：  
1. **统计图片中的矩形物体**：比如在图片中找到所有矩形的物体（如书本、手机）。  
2. **判断电路板上的元件是否相邻**：比如电路板上的元件不能相邻，需要检查是否有元件的引脚接触。  
3. **统计表格中的单元格数量**：比如在Excel表格中统计所有合并的单元格数量（合并的单元格是矩形）。


### 📚 洛谷练习推荐
1. **洛谷 P1451 求细胞数量**（推荐指数：★★★★）  
   - **推荐理由**：这道题需要统计网格中的连通块数量（细胞），和本题的搜索部分类似，适合巩固连通块处理的技巧。  
2. **洛谷 P1506 拯救oibh总部**（推荐指数：★★★☆）  
   - **推荐理由**：这道题需要用BFS找到从起点到终点的最短路径，同时处理障碍物（比如`#`），适合巩固BFS的用法。  
3. **洛谷 P2058 海港**（推荐指数：★★★☆）  
   - **推荐理由**：这道题需要统计一定时间内到港的船只数量，虽然和本题的搜索无关，但需要高效统计，适合巩固统计技巧。  
4. **洛谷 P1162 填涂颜色**（推荐指数：★★★★）  
   - **推荐理由**：这道题需要用BFS填充封闭区域的颜色，和本题的连通块处理类似，适合巩固BFS的用法。


## 7. 学习心得与经验分享（若有）
**参考经验（来自钱逸凡）**：“这道题的难点在于判断是否有船相邻。通过自己模拟的数据可以得出结论：如果图是不合法的，一定存在如下结构：在一个2×2的方格中有三个#。”  
**点评**：这位作者的经验很有用！通过模拟数据找到规律，是解决算法问题的常用方法。比如本题的2×2区域特判，就是通过模拟“碰船”的情况得出的规律。


## 🎉 结语
本次关于“海战”的C++解题分析就到这里。希望这份学习指南能帮助大家理解搜索、矩形判断和特判的技巧。记住，解决算法问题的关键是**找规律**和**选择高效的方法**。下次我们再一起探索新的编程挑战！💪

---
处理用时：154.13秒
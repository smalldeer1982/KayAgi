# 题目信息

# 【深基16.例3】二叉树深度

## 题目描述

有一个 $n(n \le 10^6)$ 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 $n$），建立一棵二叉树（根节点的编号为 $1$），如果是叶子结点，则输入 `0 0`。

建好这棵二叉树之后，请求出它的深度。二叉树的**深度**是指从根节点到叶子结点时，最多经过了几层。


## 样例 #1

### 输入

```
7
2 7
3 6
4 5
0 0
0 0
0 0
0 0```

### 输出

```
4```

# AI分析结果

# 💡 Kay的C++算法解析：二叉树深度 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二叉树的存储与遍历（DFS/BFS）

🗣️ **初步分析**：  
解决“二叉树深度”问题，关键是**遍历二叉树并记录最大层数**。可以把二叉树想象成一棵“数字树”，每个节点有两个“分支”（左右子节点），我们需要从根节点（1号）出发，走到最远的叶子节点（没有子节点的节点），数一下走了多少步（层数）。  

**核心算法**：  
- **DFS（深度优先搜索）**：像“走迷宫”一样，每到一个分叉口，先选一条路走到头（比如先左后右），再回头走另一条路。遍历过程中记录当前深度，更新最大深度。  
- **BFS（广度优先搜索）**：像“水波纹”一样，从根节点开始，逐层扩散（先访问所有第一层节点，再第二层，依此类推），最后一层的深度就是树的最大深度。  

**核心难点**：  
1. 如何用代码存储二叉树（每个节点的左右子节点）？  
2. 如何遍历树并正确计算深度？  
3. 如何处理叶子节点（子节点为0的情况）？  

**可视化设计思路**：  
用**8位像素风格**模拟二叉树（根节点在顶部，左右子节点向下延伸），DFS时用“黄色箭头”标记当前路径，BFS时用“蓝色方块”标记当前层的节点。每访问一个节点，播放“叮”的音效；更新最大深度时，播放“嗡”的音效；到达叶子节点时，播放“滴”的音效。


## 2. 精选优质题解参考

为了帮助大家快速掌握解题思路，我筛选了3份**思路清晰、代码规范、实践价值高**的题解：


### **题解一（作者：zhangyuhan，赞：172）**  
* **点评**：  
  这份题解是**二叉树遍历的经典入门案例**！思路非常直白：用结构体`node`存储每个节点的左右子节点，然后用DFS从根节点（1号）出发，递归遍历左右子树，记录当前深度并更新最大深度。  
  代码风格规范（变量名`tree`、`ans`含义明确），注释详细（比如“到达叶子节点时返回”），**时间复杂度O(n)**（每个节点只遍历一次），完全符合竞赛要求。特别是`_for`宏的使用（简化循环），但不影响可读性，适合初学者借鉴。


### **题解二（作者：HsKr，赞：59）**  
* **点评**：  
  此题解是**DFS的精简版**！去掉了宏定义，用更简洁的`for`循环读入数据，变量名`a`（存储节点）、`Max`（记录最大深度）更简短但清晰。  
  代码逻辑与题解一一致，但更注重“简洁性”——比如`dfs`函数中的`step`参数直接表示当前深度，避免了额外的变量。这种“极简风格”适合初学者模仿，容易理解和调试。


### **题解三（作者：Lylighte，赞：27）**  
* **点评**：  
  这份题解的**亮点是提供了两种解法**：  
  1. **父亲表示法+递归**：用`fa`数组存储每个节点的父节点，通过递归求每个节点的深度（记忆化避免重复计算）。  
  2. **儿子表示法+BFS**：用结构体`nod`存储每个节点的左右子节点，用队列实现BFS，逐层遍历并记录深度。  
  两种方法互补，帮助初学者理解“二叉树的不同存储方式”和“DFS与BFS的区别”。特别是BFS的实现，用队列模拟层序遍历，思路清晰，适合拓展到“层次遍历”等问题。


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何存储二叉树？**  
* **分析**：  
  二叉树的存储方式主要有两种：  
  - **儿子表示法**（最常用）：用结构体或数组存储每个节点的左右子节点（如`tree[i].left`、`tree[i].right`）。适合需要快速访问子节点的情况（如DFS/BFS）。  
  - **父亲表示法**：用数组存储每个节点的父节点（如`fa[i]`表示i的父节点）。适合需要快速访问父节点的情况（如求节点的深度）。  
  优质题解中，**儿子表示法**是主流，因为它更符合“遍历子树”的需求。

* 💡 **学习笔记**：  
  选择存储方式的关键是“需求”——需要访问子节点用“儿子表示法”，需要访问父节点用“父亲表示法”。


### 2. **难点2：如何遍历树并计算深度？**  
* **分析**：  
  遍历树的两种主要方式：  
  - **DFS（深度优先搜索）**：递归遍历左右子树，记录当前深度。优点是代码简洁，适合求“最大深度”（因为要走到最远的叶子）。  
  - **BFS（广度优先搜索）**：用队列逐层遍历，记录每层的深度。优点是可以快速找到“最短路径”（如层次遍历），但求最大深度时需要遍历所有节点。  
  优质题解中，**DFS**是首选，因为它更符合“求最大深度”的逻辑。

* 💡 **学习笔记**：  
  求“最大深度”用DFS，求“层次遍历”用BFS。


### 3. **难点3：如何处理叶子节点？**  
* **分析**：  
  题目中，叶子节点的左右子节点都是0。因此，在遍历过程中，当遇到节点编号为0时，需要返回（停止递归或不加入队列）。  
  比如题解一中的`if (id == 0) return;`，就是处理叶子节点的关键代码——当子节点为0时，不再继续遍历。

* 💡 **学习笔记**：  
  叶子节点是遍历的“终止条件”，必须正确处理，否则会陷入无限递归或错误遍历。


### ✨ 解题技巧总结  
1. **结构化存储**：用结构体或数组存储二叉树，变量名要明确（如`left`、`right`）。  
2. **递归终止条件**：处理叶子节点（0），避免无限递归。  
3. **记录最大深度**：在遍历过程中，实时更新最大深度（如`ans = max(ans, deep)`）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（DFS版本）  
* **说明**：  
  本代码综合了题解一和题解二的思路，是**二叉树深度问题的经典实现**，逻辑清晰，适合初学者模仿。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  using namespace std;

  const int MAXN = 1e6 + 10;

  struct Node {
      int left, right;
  } tree[MAXN]; // 存储每个节点的左右子节点

  int n, max_depth = 1; // max_depth初始化为1（根节点深度）

  void dfs(int node_id, int current_depth) {
      if (node_id == 0) return; // 叶子节点，停止遍历
      max_depth = max(max_depth, current_depth); // 更新最大深度
      dfs(tree[node_id].left, current_depth + 1); // 遍历左子树
      dfs(tree[node_id].right, current_depth + 1); // 遍历右子树
  }

  int main() {
      cin >> n;
      for (int i = 1; i <= n; ++i) {
          cin >> tree[i].left >> tree[i].right; // 读入每个节点的左右子节点
      }
      dfs(1, 1); // 从根节点（1号）开始遍历，初始深度为1
      cout << max_depth << endl; // 输出最大深度
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **存储**：用`Node`结构体存储每个节点的左右子节点，`tree`数组是所有节点的集合。  
  2. **DFS函数**：`dfs`函数接收当前节点编号和当前深度，递归遍历左右子树，更新最大深度。  
  3. **主函数**：读入数据，调用`dfs`从根节点开始遍历，输出最大深度。


### 针对各优质题解的片段赏析

#### **题解一（作者：zhangyuhan）**  
* **亮点**：用宏定义简化循环，代码更简洁。  
* **核心代码片段**：  
  ```cpp
  #define _for(i, a, b) for (int i=(a); i<=(b); i++) // 宏定义循环

  _for (i, 1, n) cin >> tree[i].left >> tree[i].right; // 读入数据
  ```  
* **代码解读**：  
  宏定义`_for`把`for (int i=a; i<=b; ++i)`简化为`_for(i, a, b)`，减少了代码冗余。这种技巧在竞赛中很常用，但要注意宏的可读性（不要过度简化）。  
* 💡 **学习笔记**：  
  宏定义可以简化重复代码，但要适度，避免影响代码可读性。


#### **题解二（作者：HsKr）**  
* **亮点**：变量名简洁，逻辑更清晰。  
* **核心代码片段**：  
  ```cpp
  int Max = -1; // 记录最大深度，初始化为-1（小于所有可能的深度）

  void dfs(int root, int step) {
      if (root == 0) return;
      Max = max(Max, step); // 更新最大深度
      dfs(a[root].l, step + 1); // 遍历左子树
      dfs(a[root].r, step + 1); // 遍历右子树
  }
  ```  
* **代码解读**：  
  变量名`Max`比`ans`更直观（表示“最大深度”），`step`比`deep`更符合“步骤”的含义。这种“语义化变量名”能让代码更容易理解。  
* 💡 **学习笔记**：  
  变量名要“见名知意”，比如用`Max`表示最大深度，用`step`表示当前步骤。


#### **题解三（作者：Lylighte）**  
* **亮点**：BFS实现，拓展思路。  
* **核心代码片段**：  
  ```cpp
  struct nod {
      int lc, rc; // 左右子节点
  } tree[100010];

  nod que[100010]; // BFS队列
  int head = 1, tail = 2; // 队列头和尾

  void bfs() {
      que[head] = tree[1]; // 根节点入队
      que[head].deep = 1; // 根节点深度为1
      while (head < tail) {
          nod current = que[head++]; // 取出队首节点
          depth = max(depth, current.deep); // 更新最大深度
          if (current.lc != 0) { // 左子节点非0，入队
              que[tail].lc = tree[current.lc].lc;
              que[tail].rc = tree[current.lc].rc;
              que[tail].deep = current.deep + 1;
              tail++;
          }
          if (current.rc != 0) { // 右子节点非0，入队
              que[tail].lc = tree[current.rc].lc;
              que[tail].rc = tree[current.rc].rc;
              que[tail].deep = current.deep + 1;
              tail++;
          }
      }
  }
  ```  
* **代码解读**：  
  BFS用队列存储当前层的节点，每次取出队首节点，将其左右子节点入队（如果非0）。`deep`字段记录每个节点的深度，遍历过程中更新最大深度。这种方法适合“层次遍历”问题，比如求“二叉树的层次和”。  
* 💡 **学习笔记**：  
  BFS是“逐层遍历”的利器，适合解决“最短路径”或“层次相关”的问题。


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：《像素树探险》  
**风格**：8位FC红白机风格（低分辨率、高饱和度色彩），背景为浅灰色，节点为彩色方块（根节点红色，当前节点黄色，叶子节点绿色），路径为黄色箭头。  
**核心内容**：演示DFS遍历二叉树的过程，实时显示当前深度和最大深度。


### 📝 动画帧步骤与交互设计  
1. **初始化场景**：  
   - 屏幕顶部显示“像素树探险”标题（8位字体）。  
   - 中间显示二叉树结构（根节点1在顶部，左右子节点向下延伸）。  
   - 底部控制面板：“开始”“单步”“重置”按钮（像素风格），速度滑块（1-5档），当前深度/最大深度显示（红色数字）。  
   - 背景音乐：8位风格的轻快旋律（循环播放）。

2. **DFS启动**：  
   - 根节点1（红色方块）闪烁，伴随“叮”的音效。  
   - 调用`dfs(1, 1)`，当前深度显示为1，最大深度显示为1。

3. **遍历左子树**：  
   - 从根节点1出发，黄色箭头指向左子节点2（假设样例输入中的左子节点是2），伴随“吱”的音效。  
   - 当前节点变为2（黄色方块），当前深度更新为2，最大深度更新为2。  
   - 继续遍历2的左子节点3，依此类推，直到叶子节点4（左右子节点为0）。

4. **到达叶子节点**：  
   - 叶子节点4（绿色方块）闪烁，伴随“滴”的音效。  
   - 当前深度显示为4，最大深度更新为4（样例输出）。  
   - 递归返回，黄色箭头从4回到3，再回到2，再回到1。

5. **遍历右子树**：  
   - 从根节点1出发，黄色箭头指向右子节点7，伴随“吱”的音效。  
   - 遍历7的右子节点6（假设样例输入中的右子节点是6），直到叶子节点6（左右子节点为0）。  
   - 当前深度显示为3，最大深度保持为4。

6. **结束动画**：  
   - 所有节点停止闪烁，最大深度显示为4（红色加粗）。  
   - 播放“胜利”音效（上扬的8位音调），屏幕底部显示“通关！”（8位字体）。


### 🎧 音效设计  
- **节点入队/访问**：“叮”（高频短音）。  
- **路径移动**：“吱”（中频长音）。  
- **到达叶子节点**：“滴”（低频短音）。  
- **更新最大深度**：“嗡”（低频长音）。  
- **胜利**：“叮叮咚”（上扬的旋律）。


### 🎮 交互设计  
- **单步执行**：点击“单步”按钮，动画执行一步（如访问一个节点）。  
- **自动播放**：点击“开始”按钮，动画按速度滑块的设置自动执行（1档最慢，5档最快）。  
- **重置动画**：点击“重置”按钮，动画回到初始状态（根节点1未访问）。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
二叉树的存储与遍历是**数据结构的基础**，可以解决以下问题：  
1. **二叉树的前序/中序/后序遍历**（DFS的变种）。  
2. **二叉树的层次遍历**（BFS的应用）。  
3. **求二叉树的叶子节点数**（遍历过程中统计叶子节点）。


### 📚 洛谷练习推荐  
1. **洛谷 P1494** - 《二叉树的遍历》  
   🗣️ **推荐理由**：这道题要求根据前序和中序遍历结果重建二叉树，是“二叉树存储与遍历”的进阶练习，帮助你巩固“递归重建树”的思路。  

2. **洛谷 P1030** - 《求二叉树的深度》  
   🗣️ **推荐理由**：这道题是本题的“加强版”，要求处理更大的输入（n≤1e5），需要优化代码（如用数组代替结构体），帮助你提升代码效率。  

3. **洛谷 P2915** - 《二叉树的层次遍历》  
   🗣️ **推荐理由**：这道题要求输出二叉树的层次遍历结果，是BFS的经典应用，帮助你理解“层序遍历”的逻辑。  


## 7. 学习心得与经验分享 (若有)

### 📝 来自Lylighte的经验  
> “我最初用父亲表示法求深度，后来发现儿子表示法更适合遍历子树。这让我意识到，**存储方式的选择取决于问题的需求**——需要访问子节点时，儿子表示法更方便；需要访问父节点时，父亲表示法更方便。”  

**点评**：  
这位作者的经验很有价值！很多初学者会误以为“存储方式是固定的”，但实际上，**存储方式要服务于解题思路**。比如本题中，儿子表示法更适合DFS/BFS遍历，而父亲表示法更适合求节点的深度（如Lylighte的第一个解法）。


## 💪 总结  
本次分析的“二叉树深度”问题，是**二叉树存储与遍历**的入门题。通过学习DFS和BFS两种遍历方式，你可以掌握“求树的深度”的核心逻辑。记住：  
- 存储二叉树用“儿子表示法”（结构体或数组）。  
- 求最大深度用“DFS”（递归遍历左右子树）。  
- 处理叶子节点要判断“子节点是否为0”。  

希望这份指南能帮助你理解二叉树的基本概念，下次遇到类似问题时，能快速找到思路！💪

---
处理用时：164.43秒
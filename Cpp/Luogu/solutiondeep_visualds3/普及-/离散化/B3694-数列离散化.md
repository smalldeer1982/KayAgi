# 题目信息

# 数列离散化

## 题目描述

给定一个长度为 $n$ 的数列 $a$。定义 $\mathrm{rank}(i)$ 表示数列 $a$ 中比 $a_i$ 小的不同数字个数再加一。

对 $1 \leq i \leq n$，现在请你求出所有的 $\mathrm{rank}(i)$。

## 说明/提示

### 数据规模与约定

对全部的测试点，保证 $1 \leq T \leq 5$，$1 \leq n \leq 10^5$，$-10^9 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
3
3
1 2 3
5
1 6 2 2 7
4
-1 -2 -3 -3```

### 输出

```
1 2 3
1 3 2 2 4
3 2 1 1```

# AI分析结果



---
# 💡 Kay的C++算法解析：数列离散化 深入学习指南 💡

<introduction>
今天我们来一起分析“数列离散化”这道C++编程题。离散化是数据预处理的重要技巧，掌握它能帮我们高效解决许多涉及数据大小关系的问题。本指南将带大家梳理题目核心、解析优质题解，并通过像素动画直观理解离散化过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（离散化）`

🗣️ **初步分析**：
> 解决“数列离散化”的关键在于理解离散化的核心——将原数列中的数值映射为连续的整数，同时保持它们的相对大小关系。简单来说，离散化就像给每个数“重新编号”：比如原数列是`{1, 100, 20, 100}`，排序去重后是`{1, 20, 100}`，那么离散化后的数列就是`{1, 3, 2, 3}`（每个数对应其在排序去重数组中的位置）。  
> 本题需要计算每个数的`rank`，即比它小的不同数字的个数加一。这正好是离散化的典型应用场景：先排序去重得到“基准数组”，再通过二分查找原数组每个数在基准数组中的位置。  
> 核心难点在于：1）正确使用`unique`函数处理去重后的数组长度；2）理解`lower_bound`如何定位原数在基准数组中的位置。可视化设计中，我们可以用像素方块模拟排序、去重过程，用箭头高亮当前查找的数，并用颜色区分基准数组和原数组。  
> 动画将采用8位像素风格（类似FC游戏界面），用不同颜色的方块代表原数组和基准数组。关键步骤（如排序、去重、二分查找）会伴随“叮”的音效，自动播放模式可模拟AI演示整个离散化流程，帮助大家直观看到每一步的数据变化。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选出以下优质题解（评分≥4星），它们能帮我们快速掌握离散化的实现技巧。
</eval_intro>

**题解一：作者：wangyinghao（赞：26）**  
* **点评**：此题解对离散化的概念和步骤解释得非常清晰，尤其适合初学者。代码规范且高效，使用`sort`+`unique`+`lower_bound`组合，完美适配题目数据规模（n=1e5）。亮点在于对`unique`函数返回值的正确处理（`unique(a+1,a+n+1)-(a+1)`），以及同步原数组到离散化数组的细节，确保了后续二分查找的准确性。实践价值极高，代码可直接用于竞赛。

**题解二：作者：_Wind_Leaves_ShaDow_（赞：6）**  
* **点评**：此题解用“复制→排序→去重→二分”的四步流程，将离散化过程拆解成函数`disc()`，结构清晰易读。对`unique`函数的用法（`unique(lsh+1,lsh+n+1)-lsh-1`）和`lower_bound`的应用解释到位，特别适合学习如何封装离散化逻辑。代码中`ios::sync_with_stdio(false)`等优化语句体现了竞赛编程的好习惯。

**题解三：作者：YuTianQwQ（赞：3）**  
* **点评**：此题解使用`vector`和STL函数（`sort`、`unique`、`lower_bound`）实现离散化，代码简洁现代。对每个步骤（复制、排序、去重、离散化）的注释详细，尤其解释了`lower_bound`返回值加1的原因（下标从0开始），帮助学习者理解每一步的意义。时间复杂度分析（O(n log n)）明确，适合理解算法效率。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
离散化的实现看似简单，实则有几个关键细节容易出错。结合优质题解，我们总结了以下核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：正确使用`unique`函数处理去重后的数组长度**  
    * **分析**：`unique`函数会将重复元素移动到数组末尾，并返回第一个重复元素的迭代器。例如，原数组排序后是`{1,2,2,3}`，`unique`处理后数组前半部分是`{1,2,3,3}`，返回值指向第四个元素（即第一个重复的`3`）。因此，去重后的长度应为`unique返回值 - 数组起始位置`。  
    * 💡 **学习笔记**：`unique`必须配合`sort`使用，且去重后数组长度需通过指针计算，不能直接用原长度。

2.  **关键点2：用`lower_bound`准确查找原数的位置**  
    * **分析**：`lower_bound`返回第一个大于等于目标值的元素位置。由于基准数组（排序去重后的数组）是严格递增的，原数在基准数组中的位置即为比它小的不同数的个数。例如，基准数组是`{1,2,3}`，原数`2`的`lower_bound`位置是1（下标从1开始），对应`rank=2`（比它小的数有1个）。  
    * 💡 **学习笔记**：`lower_bound`的查找范围是基准数组的有效部分（去重后的长度），否则可能越界。

3.  **关键点3：同步原数组与基准数组的关系**  
    * **分析**：需要先复制原数组到基准数组，排序去重后再通过基准数组反查原数组每个元素的位置。若直接修改原数组会丢失原始数据，导致无法正确计算每个元素的`rank`。  
    * 💡 **学习笔记**：必须用两个数组（原数组和基准数组）分别保存原始数据和处理后数据。

### ✨ 解题技巧总结
- **技巧1：善用STL函数**：`sort`（排序）、`unique`（去重）、`lower_bound`（二分查找）是离散化的“三驾马车”，熟练使用可大幅简化代码。  
- **技巧2：注意数组下标**：C++数组下标通常从0或1开始，需统一处理（如题解中有的从1开始，有的从0开始），避免越界错误。  
- **技巧3：输入输出优化**：对于大数据量（n=1e5），使用`ios::sync_with_stdio(false)`关闭同步，`cin.tie(0)`加速输入输出，避免超时。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解，提炼出一个逻辑清晰、高效简洁的通用核心实现，帮助大家快速掌握离散化的完整流程。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了wangyinghao、_Wind_Leaves_ShaDow_等优质题解的思路，采用STL函数实现，适合处理题目中的大数据量。  
* **完整核心代码**：  
    ```cpp
    #include <iostream>
    #include <algorithm>
    #include <vector>
    using namespace std;

    void discretize(vector<int>& a) {
        vector<int> b(a); // 复制原数组到基准数组
        sort(b.begin(), b.end()); // 排序基准数组
        auto last = unique(b.begin(), b.end()); // 去重，返回第一个重复元素的迭代器
        b.erase(last, b.end()); // 删除重复元素（可选，不影响查找）
        
        // 对原数组每个元素，查找其在基准数组中的位置（rank）
        for (int& num : a) {
            num = lower_bound(b.begin(), b.end(), num) - b.begin() + 1;
        }
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        
        int T;
        cin >> T;
        while (T--) {
            int n;
            cin >> n;
            vector<int> a(n);
            for (int i = 0; i < n; ++i) {
                cin >> a[i];
            }
            discretize(a);
            for (int num : a) {
                cout << num << " ";
            }
            cout << "\n";
        }
        return 0;
    }
    ```  
* **代码解读概要**：  
    代码首先读取多组测试用例，对每组数据复制原数组到`b`，排序去重后得到基准数组。然后通过`lower_bound`查找原数组每个元素在基准数组中的位置（加1后即为`rank`）。`discretize`函数封装了离散化逻辑，结构清晰，易于复用。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段，学习它们的亮点和实现思路。
</code_intro_selected>

**题解一：作者：wangyinghao**  
* **亮点**：代码简洁高效，直接使用数组实现，适合理解离散化的基础步骤。  
* **核心代码片段**：  
    ```cpp
    sort(a+1,a+n+1);
    int cnt=unique(a+1,a+n+1)-(a+1);
    for(int i=1;i<=n;i++){
        d[i]=lower_bound(a+1,a+cnt+1,d[i])-a;
    }
    ```  
* **代码解读**：  
    - `sort(a+1,a+n+1)`：对原数组排序（下标从1开始）。  
    - `unique(a+1,a+n+1)-(a+1)`：计算去重后的数组长度`cnt`（`unique`返回第一个重复元素的位置，减去起始位置`a+1`得到有效长度）。  
    - `lower_bound(a+1,a+cnt+1,d[i])-a`：在排序去重后的数组中查找`d[i]`（原数组的复制），返回其位置（下标从1开始，直接作为`rank`）。  
* 💡 **学习笔记**：数组下标从1开始可避免越界问题，适合处理多组数据时的边界情况。

**题解二：作者：_Wind_Leaves_ShaDow_**  
* **亮点**：将离散化逻辑封装为函数`disc()`，代码模块化，提高复用性。  
* **核心代码片段**：  
    ```cpp
    inline void disc(){
        for(int i=1;i<=n;i++)lsh[i]=a[i];//复制
        sort(lsh+1,lsh+n+1);//排序
        int cnt=unique(lsh+1,lsh+n+1)-lsh-1;//去重后的长度
        for(int i=1;i<=n;i++)a[i]=lower_bound(lsh+1,lsh+cnt+1,a[i])-lsh;//二分查找
    }
    ```  
* **代码解读**：  
    - `lsh`数组作为基准数组，复制原数组`a`的数据。  
    - `unique(lsh+1,lsh+n+1)-lsh-1`：计算去重后的长度（注意`lsh`下标从1开始，故减1）。  
    - `lower_bound(lsh+1,lsh+cnt+1,a[i])-lsh`：查找`a[i]`在基准数组中的位置（下标从1开始，直接作为`rank`）。  
* 💡 **学习笔记**：函数封装是提高代码可读性和复用性的重要技巧，适合复杂问题的模块化设计。

**题解三：作者：YuTianQwQ**  
* **亮点**：使用`vector`和STL的`erase`函数彻底删除重复元素，代码更现代。  
* **核心代码片段**：  
    ```cpp
    sort(b.begin(), b.end());
    b.erase(unique(b.begin(), b.end()),b.end());
    for(int i = 0;i < n;i++){
        a[i] = lower_bound(b.begin(),b.end(),a[i])-b.begin()+1;
    }
    ```  
* **代码解读**：  
    - `sort(b.begin(), b.end())`：对基准数组`b`排序。  
    - `b.erase(unique(...),b.end())`：删除`unique`移动到末尾的重复元素，使基准数组仅保留唯一值。  
    - `lower_bound(...)-b.begin()+1`：由于`vector`下标从0开始，加1后得到正确的`rank`（比它小的数的个数+1）。  
* 💡 **学习笔记**：`erase`函数可彻底清理重复元素，使基准数组更“干净”，适合需要频繁访问基准数组的场景。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解离散化的每一步，我们设计了一个“像素探险队”主题的8位像素动画。通过动画，你可以看到原数组如何被排序、去重，并最终找到每个元素的`rank`！
</visualization_intro>

  * **动画演示主题**：`像素探险队的离散化冒险`  
  * **核心演示内容**：原数组的“复制→排序→去重→查找”四步流程，重点展示`unique`去重和`lower_bound`查找的过程。  

  * **设计思路简述**：  
    采用FC红白机风格的8位像素画面（16色调色板，方块像素），用不同颜色区分原数组（蓝色方块）和基准数组（绿色方块）。关键步骤（如排序时的交换、去重时的合并、查找时的箭头移动）伴随“叮”的音效，自动播放模式模拟AI探险，每完成一步弹出“小关卡”提示（如“排序成功！”），增强学习趣味性。

  * **动画帧步骤与交互关键点**：  

    1.  **场景初始化**：  
        - 屏幕分为左右两部分：左半是“原数组森林”（蓝色方块排成一行，标有数值），右半是“基准数组城堡”（绿色方块空位）。  
        - 控制面板有“开始”“单步”“重置”按钮和速度滑块（1x-5x），背景播放8位风格的轻快BGM。  

    2.  **复制与排序**：  
        - 点击“开始”，蓝色方块逐个“跳跃”到右半的绿色空位（复制过程），伴随“刷”的音效。  
        - 排序阶段：绿色方块开始“交换舞蹈”——小的方块向左移动，大的向右，每交换一次播放“咔嗒”声，最终绿色方块按升序排列（如`{1,2,2,3}`变为`{1,2,2,3}`）。  

    3.  **去重魔法**：  
        - 出现一个“去重巫师”像素角色，挥动魔法棒。重复的绿色方块（如第二个`2`和`3`）逐渐变淡，最终消失，剩下`{1,2,3}`（去重后的基准数组），播放“咻”的音效。  

    4.  **查找之旅**：  
        - 左半的蓝色方块逐个出发，变成“探险者”（带箭头的小方块），跑到右半的基准数组中寻找位置。  
        - 探险者从基准数组左端开始，用“二分魔法”（中间出现虚线分隔）快速定位：若当前方块小于目标值，向右跳；否则向左跳。找到位置后，探险者头顶显示`rank`（如找到`2`的位置是2，显示“2”），播放“叮”的音效。  

    5.  **胜利展示**：  
        - 所有蓝色方块完成查找后，屏幕中央弹出“离散化成功！”的像素文字，播放胜利音效（旋律上扬），原数组位置显示最终的`rank`值（如`1 3 2 2 4`）。  

  * **旁白提示**：  
    - 排序时：“看！绿色方块在跳舞，它们要按从小到大排好队～”  
    - 去重时：“重复的方块被巫师变没啦，现在只有唯一的数值留在城堡里！”  
    - 查找时：“探险者用二分魔法快速找位置，这样就能知道它的rank啦～”  

<visualization_conclusion>
通过这个像素动画，我们不仅能“看”到离散化的每一步，还能在趣味互动中记住关键操作（排序、去重、二分查找）。下次遇到离散化问题，你也能像像素探险队一样轻松解决！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
离散化是处理数据大小关系的通用技巧，除了本题，还能解决许多需要“压缩值域”的问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    离散化的核心是“保持大小关系，压缩值域”，常见于以下场景：  
    - 坐标压缩：如计算区间覆盖问题（如洛谷P1496火烧赤壁），用离散化将大坐标映射为小范围。  
    - 数据预处理：如动态规划中，状态值过大时用离散化压缩状态空间。  
    - 统计问题：如统计不同数值的出现次数，离散化后更易处理。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1496 火烧赤壁**  
        * 🗣️ **推荐理由**：这道题需要计算多个区间的总覆盖长度，离散化能有效压缩坐标，避免直接处理大数值区间。  
    2.  **洛谷 P5536 【XR-3】核心城市**  
        * 🗣️ **推荐理由**：涉及树的结构和离散化，需要将节点到核心城市的距离离散化，锻炼综合应用能力。  
    3.  **洛谷 P1955 [NOI2009] 植物大战僵尸**  
        * 🗣️ **推荐理由**：离散化结合图论模型，适合进阶练习，理解离散化在复杂问题中的作用。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了离散化的学习心得，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自作者：wangyinghao)**：“刚开始学离散化时，总忘记`unique`返回的是第一个重复元素的位置，导致计算去重长度时出错。后来通过调试，发现必须用`unique返回值 - 数组起始位置`才能得到正确长度。”  
> **点评**：这位作者的经验提醒我们，STL函数的返回值需要仔细处理。遇到类似问题时，可通过打印中间结果（如输出`unique`的返回值）来验证逻辑是否正确，这是调试的重要技巧。

-----

<conclusion>
通过今天的分析，我们掌握了离散化的核心步骤（复制→排序→去重→查找），理解了如何用STL函数高效实现，还通过像素动画直观感受了离散化的过程。记住，多练习洛谷上的相似题目，你会越来越熟练！下次再见～ 💪
</conclusion>

---
处理用时：169.85秒
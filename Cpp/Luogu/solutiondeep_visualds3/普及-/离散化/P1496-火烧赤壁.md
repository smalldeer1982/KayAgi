# 题目信息

# 火烧赤壁

## 题目背景

曹操平定北方以后，公元 208 年，率领大军南下，进攻刘表。他的人马还没有到荆州，刘表已经病死。他的儿子刘琮听到曹军声势浩大，吓破了胆，先派人求降了。

孙权任命周瑜为都督，拨给他三万水军，叫他同刘备协力抵抗曹操。

隆冬的十一月，天气突然回暖，刮起了东南风。

没想到东吴船队离开北岸大约二里距离，前面十条大船突然同时起火。火借风势，风助火威。十条火船，好比十条火龙一样，闯进曹军水寨。那里的船舰，都挤在一起，又躲不开，很快地都烧起来。一眨眼工夫，已经烧成一片火海。

曹操气急败坏的把你找来，要你钻入火海把连环线上着火的船只的长度统计出来！

## 题目描述

给定每个起火部分的起点和终点，请你求出燃烧位置的长度之和。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 2 \times 10^4$，$-2^{31} \leq a <  b \lt 2^{31}$，且答案小于 $2^{31}$。




## 样例 #1

### 输入

```
3
-1 1
5 11
2 9```

### 输出

```
11```

# AI分析结果



---
# 💡 Kay的C++算法解析：火烧赤壁 深入学习指南 💡

<introduction>
今天我们来一起分析“火烧赤壁”这道经典的区间合并问题。这道题需要统计多个重叠区间的总长度，通过分析不同题解的思路和代码，我们能掌握高效解决此类问题的核心方法。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`排序与合并（模拟应用）`  

🗣️ **初步分析**：  
解决“火烧赤壁”的关键在于处理区间重叠问题。想象一下，数轴上有很多彩色线段，有些线段部分重叠或完全覆盖，我们需要把它们“合并”成不重叠的线段，再计算总长度。这就像整理书架上的书，把叠在一起的书推成一排，最后量总长度。  

题目要求计算所有燃烧区间的并集长度。核心思路是：先将所有区间按起点排序，再逐个合并重叠或相邻的区间。例如样例中的三个区间`[-1,1]`、`[5,11]`、`[2,9]`，排序后是`[-1,1]`、`[2,9]`、`[5,11]`，合并后变成`[-1,1]`和`[2,11]`，总长度是`(1-(-1)) + (11-2) = 11`。  

核心难点在于正确处理区间的三种关系：**包含**（如`[2,9]`包含`[5,11]`？不，实际是`[2,9]`和`[5,11]`部分重叠，合并为`[2,11]`）、**部分重叠**（前一个区间的终点大于当前区间的起点）、**不重叠**（当前区间的起点大于前一个区间的终点）。  

可视化设计思路：用8位像素风数轴，每个区间是一个彩色像素条。排序后，像素条按起点排列，合并时重叠部分会“融合”成一个更长的条，用不同颜色区分合并前后。关键步骤（如判断重叠、更新终点）会高亮，并伴随“叮”的音效提示。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法效率等维度的评估，以下题解因逻辑简洁、实现高效被选为优质参考：
</eval_intro>

**题解一：wxwoo (赞：258)**  
* **点评**：此题解直接抓住问题本质——排序后合并。通过分别排序起点和终点数组，巧妙计算总长度并减去重叠部分。代码简洁到仅需20行，变量命名直观（`a`存起点，`b`存终点），边界处理（如`i+1 < n`）严谨。其核心思想“排序后逐个计算并去重”是解决区间合并问题的经典方法，适合竞赛快速实现。

**题解二：Drug__Lover (赞：24)**  
* **点评**：此题解用结构体存储区间，按起点排序后模拟合并过程。代码逻辑直白，通过维护当前合并区间的`start`和`end`，清晰处理了“包含”“部分重叠”“不重叠”三种情况。变量命名（如`start`、`en`）符合直觉，循环中的条件判断（`if(a[i].x <= en)`）精准，是理解区间合并的绝佳示例。

**题解三：cold_cold (赞：14)**  
* **点评**：此题解同样采用排序合并法，但代码更简洁。通过维护当前合并区间的`qi`（起点）和`zh`（终点），在循环中仅用`zh = max(zh, a[i].z)`处理重叠，最后统一计算总长度。这种“延迟计算”的方式减少了循环内的操作，时间复杂度更优（O(n log n)），适合优化学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，以下三个关键点最容易出错，掌握它们能帮你快速举一反三：
</difficulty_intro>

1.  **关键点1：如何正确排序区间？**  
    * **分析**：区间合并的前提是按起点排序。排序后，后续区间的起点一定≥当前合并区间的起点，只需比较当前区间的起点与合并区间的终点即可判断是否重叠。若未排序，可能遗漏或重复计算重叠部分（如样例中`[5,11]`和`[2,9]`未排序时无法直接合并）。  
    * 💡 **学习笔记**：排序是处理区间问题的“定海神针”，能大幅简化后续逻辑。

2.  **关键点2：如何处理三种区间关系？**  
    * **分析**：  
      - **包含**（如`[2,9]`和`[5,8]`）：当前区间完全在合并区间内，无需处理，合并区间的终点不变。  
      - **部分重叠**（如`[2,9]`和`[5,11]`）：当前区间的起点≤合并区间终点，但终点更大，需更新合并区间的终点为当前区间的终点。  
      - **不重叠**（如`[1,3]`和`[5,7]`）：当前区间的起点>合并区间终点，需将合并区间长度加入总长度，并重置合并区间为当前区间。  
    * 💡 **学习笔记**：合并区间的终点始终取最大值，是处理重叠的关键。

3.  **关键点3：如何避免遗漏最后一个区间？**  
    * **分析**：循环结束后，最后一个合并区间的长度可能未被计算（如样例中合并后的`[2,11]`）。需在循环外将最后一个区间的长度加入总长度。  
    * 💡 **学习笔记**：“收尾操作”是编程中常见的边界陷阱，记得检查循环结束后的状态。

### ✨ 解题技巧总结
- **排序优先**：所有区间问题，先按起点或终点排序，能简化后续逻辑。  
- **变量维护**：用两个变量（如`current_start`和`current_end`）维护当前合并区间的端点，避免频繁操作数组。  
- **延迟计算**：在循环中仅更新合并区间的端点，最后统一计算总长度，减少重复计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择最简洁高效的“排序合并法”作为通用实现，它能清晰展示区间合并的核心逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了多个优质题解的思路，采用排序后合并的经典方法，时间复杂度O(n log n)（排序），适用于n≤2e4的规模。  
* **完整核心代码**：  
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    struct Interval {
        int start, end;
    };

    bool compare(Interval a, Interval b) {
        return a.start < b.start;
    }

    int main() {
        int n;
        cin >> n;
        Interval intervals[20001];
        for (int i = 0; i < n; ++i) {
            cin >> intervals[i].start >> intervals[i].end;
        }
        sort(intervals, intervals + n, compare);

        int total = 0;
        int current_start = intervals[0].start;
        int current_end = intervals[0].end;

        for (int i = 1; i < n; ++i) {
            if (intervals[i].start <= current_end) {
                // 重叠，更新终点为较大值
                current_end = max(current_end, intervals[i].end);
            } else {
                // 不重叠，累加当前区间长度并重置
                total += current_end - current_start;
                current_start = intervals[i].start;
                current_end = intervals[i].end;
            }
        }
        // 处理最后一个区间
        total += current_end - current_start;

        cout << total << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取所有区间并按起点排序，然后初始化当前合并区间为第一个区间。遍历后续区间时，若重叠则扩展当前区间的终点；若不重叠则累加当前区间长度并重置。最后处理最后一个区间的长度，输出总长度。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的巧妙思路：
</code_intro_selected>

**题解一：wxwoo**  
* **亮点**：通过排序起点和终点数组，直接计算总长度并减去重叠部分，代码极简。  
* **核心代码片段**：  
    ```cpp
    sort(a, a + n);
    sort(b, b + n);
    for (int i = 0; i < n; ++i) {
        l += b[i] - a[i];
        if (i + 1 < n && b[i] > a[i + 1]) {
            l -= b[i] - a[i + 1];
        }
    }
    ```
* **代码解读**：  
  `a`和`b`分别存储所有区间的起点和终点，排序后，每个`b[i]-a[i]`是原始区间长度。若当前区间的终点`b[i]`大于下一个区间的起点`a[i+1]`，说明有重叠，重叠部分长度为`b[i]-a[i+1]`，需从总长度中减去。这种方法利用排序后区间的有序性，直接计算重叠，无需维护合并区间的端点。  
* 💡 **学习笔记**：排序后，起点和终点数组的有序性可直接用于计算重叠，简化了合并过程。

**题解二：Drug__Lover**  
* **亮点**：用结构体存储区间，逻辑清晰，直观展示合并过程。  
* **核心代码片段**：  
    ```cpp
    sort(a + 1, a + n + 1, cmp);
    start = a[1].x;
    en = a[1].y;
    sum += a[1].y - a[1].x;
    for (int i = 2; i <= n; ++i) {
        if (a[i].x <= en) {
            if (a[i].y < en) continue;
            else {
                start = en;
                en = a[i].y;
                sum += en - start;
            }
        } else {
            start = a[i].x;
            en = a[i].y;
            sum += en - start;
        }
    }
    ```
* **代码解读**：  
  排序后，初始化`start`和`en`为第一个区间的端点。遍历后续区间：若当前区间起点≤`en`且终点>`en`（部分重叠），则累加`en`到当前区间终点的长度，并更新`en`；若当前区间起点>`en`（不重叠），则累加当前区间长度并重置`start`和`en`。这种方法直观展示了“合并”的每一步。  
* 💡 **学习笔记**：用`start`和`en`维护当前合并区间的端点，是理解区间合并的基础。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地看到区间合并的过程，我们设计了一个“像素火船合并”的8位复古动画，让你“看”到算法如何一步步合并重叠区间！
</visualization_intro>

  * **动画演示主题**：`像素火船大合并`（FC红白机风格）  

  * **核心演示内容**：  
    数轴是一条横向的像素跑道，每个区间是一个彩色火船（如红色），起点和终点用小旗子标记。动画展示火船按起点排序后，逐个合并重叠的火船（重叠部分融合成更大的火船），最终统计所有不重叠火船的总长度。

  * **设计思路简述**：  
    8位像素风降低学习压力，火船的移动和融合动画强化“合并”的视觉效果。关键步骤（如排序、判断重叠、更新终点）用高亮和音效提示，帮助记忆核心逻辑。

  * **动画帧步骤与交互关键点**：  

    1.  **场景初始化**：  
        - 屏幕上方是像素数轴（浅灰色，每格1像素单位），下方是控制面板（开始/暂停、单步、调速滑块）。  
        - 输入的区间以红色火船形式随机分布在数轴上，起点（绿色旗子）和终点（红色旗子）标注。  
        - 播放8位风格的轻快背景音乐（类似《超级马里奥》的跳跃音效）。

    2.  **排序动画**：  
        - 点击“开始”，火船开始按起点“滑动”到正确位置（如第一个火船滑到最左，后续依次右移）。滑动时伴随“咻”的音效，排序完成后播放“叮”的提示音。

    3.  **合并过程演示**：  
        - 初始合并区间是第一个火船（黄色高亮），起点和终点用白色框标注。  
        - 处理第二个火船时：  
          - 若重叠（如起点≤当前终点），火船与合并区间“融合”（颜色变橙，终点延伸），播放“融合”音效（类似《吃金币》的“叮”）。  
          - 若不重叠，当前合并区间长度累加到总长度（总长度数字跳动），新火船成为当前合并区间（绿色高亮），播放“分离”音效（短“滴”）。  
        - 每一步操作对应代码的关键行（如`if (intervals[i].start <= current_end)`），代码窗口同步高亮当前执行行。

    4.  **结束与统计**：  
        - 所有火船处理完成后，最终的合并区间以金色高亮，总长度数字放大显示，播放胜利音效（《超级马里奥》通关音乐）。  
        - 支持“单步”查看每一步合并细节，或“自动播放”加速演示。

  * **旁白提示**：  
    - “看！火船按起点排好队了，这样后面的火船起点一定越来越大～”  
    - “当前火船的起点在合并区间的终点内，它们要融合成更大的火船啦！”  
    - “这个火船和前面的不重叠，前面的火船长度要加到总长度里咯～”

<visualization_conclusion>
通过这个动画，你不仅能看到区间合并的每一步，还能通过音效和颜色变化记住关键操作。下次遇到类似问题，闭上眼睛就能“播放”这个动画啦！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
区间合并的思想在许多问题中都有应用，掌握它能帮你解决更多类似问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    区间合并的核心是“排序+合并”，适用于：  
    - 统计会议时间总长度（多个会议时间可能重叠）。  
    - 计算地图中连续障碍物的总长度（如游戏中的障碍带）。  
    - 处理日志中的连续异常时间段（合并重叠的异常区间）。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1856 [IOI1998] 最大矩形面积**  
        * 🗣️ **推荐理由**：需要合并重叠的矩形边界，是区间合并的进阶应用。  
    2.  **洛谷 P1502 窗口的星星**  
        * 🗣️ **推荐理由**：通过离散化和区间合并处理二维问题，锻炼多维转换能力。  
    3.  **洛谷 P2082 区间覆盖**  
        * 🗣️ **推荐理由**：直接考察区间合并，适合巩固基础。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者的经验能帮我们少走弯路，以下是值得借鉴的心得：
</insights_intro>

> **参考经验 (来自 li20082008li)**：“最后别忘了在计算的总距离上加上r-l（因为最后一条线段没有在循环中处理到），以及储存总距离的变量要开int64！”  
> **点评**：这位作者的提醒非常重要！循环结束后，最后一个合并区间的长度容易被遗漏，而数据范围大时需用`long long`避免溢出。这提示我们：处理循环问题时，一定要检查“最后一步”的状态；涉及大数运算时，优先使用大整型（如`long long`）。

---

<conclusion>
通过分析“火烧赤壁”的多种解法，我们掌握了区间合并的核心方法——排序后合并重叠区间。无论是代码实现还是可视化动画，关键都在于理解“排序”和“合并”的逻辑。接下来，试试推荐的拓展题，巩固你的技能吧！编程的乐趣在于不断挑战，期待你下次的进步～💪
</conclusion>

---
处理用时：167.70秒
# 题目信息

# 天际线

## 题目描述

Latium 省的 Genoa 是亚平宁半岛西海岸北端的一片土地，自然资源丰富，却无人居住。你受到罗马执政官 Caesar 的委任，前往 Genoa 建立新的城市。Caesar 对这次任务的要求是在 Genoa 这片土地上建立起一座繁荣的城市，他将以此作为衡量你的表现的标准。

正在你大刀阔斧地进行城市建设的时候，Caesar 突然写信给你，说他要检查 Genoa 的建设情况。Caesar 希望知道你的城市是什么样子，但是他又非常的忙，所以他只要你描述一下城市的轮廓就可以了，他将依照城市的轮廓决定你的薪水。

怎样描述一个城市的轮廓呢？我们知道 Genoa 所有的建筑共享一个地面，你可以认为它是水平的。所有的建筑用一个三元组 $(L_i,H_i,R_i)$，其中 $L_i$ 和 $R_i$ 分别是建筑的左坐标和右坐标，$H_i$ 就是建筑的高度。在下方所示的图表中左边建筑物描述如下 $(1,11,5)$，$(2,6,7)$，$(3,13,9)$，$(12,7,16)$，$(14,3,25)$，$(19,18,22)$，$(23,13,29)$，$(24,4,28)$，右边用轮廓线的顺序$(1,11,3,13,9,0,12,7,16,3,19,18,22,3,23,13,29,0)$ 表示：

![](https://cdn.luogu.com.cn/upload/image_hosting/oe7wpwsi.png)


## 样例 #1

### 输入

```
1 11 5
2 6 7
3 13 9
12 7 16
14 3 25
19 18 22
23 13 29
24 4 28
```

### 输出

```
1 11 3 13 9 0 12 7 16 3 19 18 22 3 23 13 29 0```

# AI分析结果



---
# 💡 Kay的C++算法解析：天际线 深入学习指南 💡

<introduction>
今天我们来一起分析“天际线”这道C++编程题。通过这道题，我们可以学习如何处理区间覆盖问题，并理解如何通过不同算法（如暴力、扫描线、线段树等）找到轮廓线的折点。本指南将帮助大家梳理核心思路，掌握关键算法，并通过可视化演示直观理解过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扫描线与区间覆盖`（结合模拟、线段树、优先队列等技巧）

🗣️ **初步分析**：
解决“天际线”问题的关键在于找到所有高度变化的折点。这些折点出现在某个位置的最大建筑高度发生变化时。简单来说，就像用一根垂直于地面的“扫描线”从左到右移动，记录每个位置的最高建筑高度，当高度变化时，就生成一个折点。

- **题解思路对比**：  
  题解中主要有两种思路：  
  1. **暴力法**：直接记录每个位置的最大高度（如InchTree的做法），适合数据范围较小的情况（本题坐标≤10000）。  
  2. **扫描线+数据结构**：将建筑拆分为左右边界事件，用线段树、优先队列或平衡树维护当前最大高度（如big_news的扫描线+线段树，haoyun1的优先队列法），适合数据范围较大的情况。  

- **核心算法流程**：  
  以扫描线法为例，流程如下：  
  1. 将每个建筑拆分为“左边界（开始）”和“右边界（结束）”两个事件。  
  2. 按坐标排序所有事件，扫描线从左到右处理每个事件。  
  3. 遇到左边界时，将建筑高度加入数据结构；遇到右边界时，移除该高度。  
  4. 每次处理事件后，检查当前最大高度是否变化，若变化则记录折点。  

- **可视化设计思路**：  
  采用8位像素风格动画，用不同颜色的像素块表示建筑。扫描线用红色竖线从左到右移动，维护一个“当前最大高度”的像素条（类似游戏中的血条）。当处理左边界事件时，对应高度的像素块“升起”；处理右边界时，对应高度的像素块“降落”。关键步骤（如高度变化）用闪烁和“叮”的音效提示。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选了以下优质题解，帮助大家学习不同解法的核心思想：
</eval_intro>

**题解一：暴力法（作者：InchTree）**  
* **点评**：  
  这道题解用最直白的暴力思路解决问题。作者通过遍历每个建筑的覆盖区间，直接更新每个位置的最大高度，最后遍历所有位置输出高度变化的折点。代码简洁（仅10行核心逻辑），但巧妙处理了边界问题（将`i<=b`改为`i<b`避免缝隙）。适合理解问题本质，但仅适用于坐标范围较小的场景（本题坐标≤10000）。

**题解二：扫描线+线段树（作者：big_news）**  
* **点评**：  
  此题解是标准的扫描线+线段树应用。作者将建筑拆分为左右边界事件，用线段树维护当前覆盖的最大高度。通过离散化优化坐标范围，线段树高效处理区间覆盖和查询。代码规范（如快读、线段树节点定义清晰），算法复杂度为O(n log n)，适合学习扫描线和线段树的结合使用。

**题解三：优先队列法（作者：haoyun1）**  
* **点评**：  
  此题解用优先队列（大根堆）维护当前最高建筑。遇到左边界时将高度入堆，遇到右边界时标记建筑结束（后续弹出过期的堆顶）。代码利用STL的`priority_queue`简化实现，思路清晰，适合学习如何用堆维护动态最大值。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，常见的难点和应对策略如下：
</difficulty_intro>

1.  **关键点1：处理区间边界的缝隙**  
    * **分析**：建筑的右边界（如R）是否包含在覆盖区间中？例如，建筑(L, H, R)的覆盖范围是[L, R)还是[L, R]？若直接用`i<=R`会导致相邻建筑在R处重叠，产生缝隙。  
    * **解决方案**：将覆盖区间改为左闭右开（`i < R`），避免缝隙（如InchTree题解中的调整）。  
    * 💡 **学习笔记**：边界处理是这类问题的“隐形陷阱”，需仔细验证。

2.  **关键点2：高效维护当前最大高度**  
    * **分析**：当扫描线移动时，需要动态添加/删除高度，并快速获取当前最大值。暴力法直接遍历所有高度（O(n)查询）效率低；线段树或优先队列可优化到O(log n)。  
    * **解决方案**：用线段树维护区间最大值（支持区间覆盖），或用优先队列+标记过期高度（弹出堆顶时检查是否已过期）。  
    * 💡 **学习笔记**：选择数据结构时，需根据操作类型（插入、删除、查询最大值）选择最优方案。

3.  **关键点3：避免重复输出折点**  
    * **分析**：多个事件可能在同一坐标触发（如同一个x坐标有多个左/右边界），需合并处理，否则会重复输出。  
    * **解决方案**：排序事件时，若x相同，左边界事件优先处理（确保先加后删），并在处理完同一x的所有事件后再检查高度变化。  
    * 💡 **学习笔记**：事件排序的规则决定了处理顺序，直接影响结果正确性。

### ✨ 解题技巧总结
- **问题抽象**：将建筑拆分为左右边界事件，转化为动态维护最大值的问题。  
- **边界处理**：通过左闭右开区间（`[L, R)`）避免缝隙。  
- **数据结构选择**：根据数据范围选择暴力（小范围）或扫描线+线段树/优先队列（大范围）。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一个通用的核心实现，再分析不同题解的精彩片段：
</code_intro_overall>

### 本题通用核心C++实现参考（扫描线+优先队列法）
* **说明**：此代码综合了优先队列法的简洁性和高效性，适用于理解动态维护最大值的过程。  
* **完整核心代码**：  
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    struct Event {
        int x;       // 事件坐标
        int h;       // 建筑高度
        bool isStart; // 是否是左边界（开始事件）
        Event(int x, int h, bool isStart) : x(x), h(h), isStart(isStart) {}
        bool operator<(const Event& other) const {
            if (x != other.x) return x < other.x;
            // 左边界事件优先处理（高度大的先入堆）
            return isStart ? (h > other.h) : (h < other.h);
        }
    };

    int main() {
        vector<Event> events;
        int l, h, r;
        while (scanf("%d%d%d", &l, &h, &r) != EOF) {
            events.emplace_back(l, h, true);
            events.emplace_back(r, h, false);
        }
        sort(events.begin(), events.end());

        multiset<int> heights; // 维护当前所有活跃的高度（允许重复）
        int lastHeight = 0;    // 上一个记录的高度
        for (auto& e : events) {
            if (e.isStart) {
                heights.insert(e.h);
            } else {
                auto it = heights.find(e.h);
                if (it != heights.end()) heights.erase(it);
            }

            // 获取当前最大高度（若堆空则为0）
            int currentHeight = heights.empty() ? 0 : *heights.rbegin();
            if (currentHeight != lastHeight) {
                printf("%d %d ", e.x, currentHeight);
                lastHeight = currentHeight;
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码将每个建筑拆分为左右边界事件，按坐标排序（左边界优先）。用`multiset`维护当前活跃的高度（支持重复和快速最大值查询）。处理每个事件时，更新高度集合，若当前最大高度变化则输出折点。

---

<code_intro_selected>
接下来，分析优质题解的核心代码片段：
</code_intro_selected>

### 题解一：暴力法（作者：InchTree）
* **亮点**：代码极简，通过调整循环条件（`i < b`）解决缝隙问题。  
* **核心代码片段**：  
    ```cpp
    int H[10005];
    int main() {
        int i, a, b, h;
        while (scanf("%d%d%d", &a, &h, &b) != EOF) 
            for (i = a; i < b; ++i) // 关键：左闭右开区间
                H[i] = max(H[i], h); 
        for (i = 1, h = 0; i < 1e4; ++i)
            if (h != H[i])
                h = H[i], printf("%d %d ", i, H[i]);
        return 0;
    }
    ```
* **代码解读**：  
  `H[i]`记录每个位置的最大高度。循环`i < b`确保建筑覆盖到`b-1`，避免与下一个建筑在`b`处重叠。最后遍历`H`数组，输出高度变化的折点。  
* 💡 **学习笔记**：小范围数据下，暴力法是最直接的解决方案，但需注意边界处理。

### 题解二：扫描线+线段树（作者：big_news）
* **亮点**：线段树高效处理区间覆盖，离散化优化坐标范围。  
* **核心代码片段**：  
    ```cpp
    class SGT { // 线段树节点定义
    public:
        node d[CN<<2];
        int GetLen(int l, int r, int k) { // 计算覆盖长度
            if (d[k].cnt) return pos[r+1] - pos[l];
            if (l == r) return 0;
            return d[k<<1].len + d[k<<1|1].len;
        }
        void modify(int l, int r, int k, int s, int t, int x) { // 区间修改
            if (s <= l && r <= t) {
                d[k].cnt += x;
                d[k].len = GetLen(l, r, k);
                return;
            }
            int m = (l + r) >> 1;
            if (s <= m) modify(l, m, k<<1, s, t, x);
            if (m < t) modify(m+1, r, k<<1|1, s, t, x);
            d[k].len = GetLen(l, r, k);
        }
    } sgt;
    ```
* **代码解读**：  
  线段树节点维护区间覆盖次数（`cnt`）和覆盖长度（`len`）。`modify`函数通过增减`cnt`实现区间插入/删除操作，`GetLen`根据`cnt`计算实际覆盖长度。离散化`pos`数组压缩坐标范围，避免内存浪费。  
* 💡 **学习笔记**：线段树适合处理区间覆盖问题，离散化是处理大坐标范围的常用技巧。

### 题解三：优先队列法（作者：haoyun1）
* **亮点**：用优先队列（大根堆）动态维护当前最大高度，代码简洁。  
* **核心代码片段**：  
    ```cpp
    priority_queue<building> q; // building按h降序排列
    int main() {
        // 读入并排序事件
        for (int i = 1; i <= 2 * n; ++i) {
            // 处理同一x坐标的所有事件
            if (q.size()) {
                int r = q.top().r;
                while (q.size() && b[i].w >= r) q.pop(), r = q.top().r;
            }
            if (!b[i].p) q.push(building(a[b[i].v][0], a[b[i].v][2]));
            int current = q.empty() ? 0 : q.top().h;
            if (current != last) printf("%d %d ", b[i].w, current), last = current;
        }
    }
    ```
* **代码解读**：  
  优先队列存储当前活跃的建筑（按高度降序）。遇到左边界时入堆，遇到右边界时弹出过期的堆顶（建筑右端点≤当前x）。每次处理事件后，检查堆顶高度是否变化，若变化则输出折点。  
* 💡 **学习笔记**：优先队列适合动态维护最大值，但需处理“延迟删除”（弹出时检查是否过期）。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解扫描线如何找到折点，我们设计一个“像素探险家”动画，用8位复古风格展示扫描线移动和高度变化过程。
</visualization_intro>

  * **动画演示主题**：`像素探险家的天际线之旅`

  * **核心演示内容**：  
    探险家（红色像素小人）从左到右移动，每到一个建筑的左右边界（绿色/紫色标记），就更新“当前最高高度”（头顶的像素条）。当高度变化时，地面会生成一个折点（黄色亮点）。

  * **设计思路简述**：  
    8位像素风格（FC游戏画面）让学习更轻松；移动音效（“踏踏”）和高度变化音效（“叮”）强化操作记忆；折点生成时的“闪光”效果突出关键步骤。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 背景为像素化地面（灰色格子），建筑用不同颜色的矩形块表示（如蓝色块代表高度11，红色块代表高度13）。  
        - 控制面板包含“单步”“自动播放”“调速”按钮，速度滑块（0.5x-2x）。

    2.  **事件处理**：  
        - 扫描线（红色竖线）移动到左边界时，对应建筑高度的像素块“升起”（从地面向上扩展），伴随“叮”的音效。  
        - 扫描线移动到右边界时，对应高度的像素块“降落”（向下收缩），伴随“咚”的音效。

    3.  **高度变化检测**：  
        - 当前最大高度用头顶的像素条显示（如高度11时显示11个绿色块）。  
        - 当高度变化时，像素条颜色闪烁（绿色→黄色），地面生成折点（黄色亮点），并显示坐标（如“x=1, y=11”）。

    4.  **AI自动演示**：  
        - 点击“AI演示”，扫描线自动从左到右移动，自动处理事件并生成折点，学习者可观察完整过程。

    5.  **目标达成**：  
        - 所有折点生成后，播放“胜利”音效（欢快的8位音乐），折点连成轮廓线（金色线条）。

  * **旁白提示**：  
    - “看！扫描线移动到了x=1，这里是建筑的左边界，高度11的像素块升起，当前最高高度变为11！”  
    - “现在扫描线到了x=3，另一个更高的建筑（高度13）的左边界，最高高度更新为13！”  

<visualization_conclusion>
通过这样的动画，我们能直观看到扫描线如何动态维护最大高度，以及折点是如何因高度变化而生成的。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下拓展练习，巩固扫描线和区间覆盖的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的扫描线思想还可用于：  
    1. 计算矩形面积并（如HDU1542 Atlantis）。  
    2. 处理区间最值问题（如动态求数组区间最大值）。  
    3. 时间区间调度（如活动选择问题）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1856 周长并**  
        * 🗣️ **推荐理由**：需要用扫描线计算多个矩形的周长并，与本题思路类似，但需处理水平和垂直两个方向的边界。  
    2.  **洛谷 P3740 [HAOI2014] 贴海报**  
        * 🗣️ **推荐理由**：用线段树或ODT处理区间覆盖问题，适合练习区间覆盖的逆过程（统计未被覆盖的区间）。  
    3.  **洛谷 P5490 【模板】扫描线**  
        * 🗣️ **推荐理由**：标准的扫描线求矩形面积并问题，适合强化扫描线+线段树的实现。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自InchTree)**：“一开始直接用`i<=b`导致缝隙问题，WA了20分。后来意识到建筑的右边界不应包含在覆盖区间内，改为`i < b`后AC。”  
> **点评**：边界条件的处理是这类问题的常见陷阱。调试时可以手动模拟小例子（如两个相邻建筑），观察覆盖范围是否正确。

-----

<conclusion>
本次关于“天际线”的解题分析就到这里。希望大家通过这份指南，不仅掌握了具体算法，还学会了如何分析问题、选择数据结构。编程的乐趣在于不断尝试和优化，下次我们再一起探索新的挑战！💪
</conclusion>

---
处理用时：194.53秒
# 题目信息

# 在你窗外闪耀的星星

## 题目背景

飞逝的的时光不会模糊我对你的记忆。难以相信从我第一次见到你以来已经过去了 3 年。我仍然还生动地记得，3 年前，在美丽的集美中学，从我看到你微笑着走出教室，你将头向后仰，柔和的晚霞照耀着你玫瑰色的脸颊。我明白，我已经沉醉于你了。之后，经过几个月的观察和窥探，你的优雅与智慧，你对待生活的态度和你对未来的愿望深切地在我心中留下了印象。你是迷人的阳光女孩，我总是梦想着与你分享余生。唉，实际上你远远超过了我最疯狂的梦想。我不知道如何桥起我与你之间的鸿沟。所以我没有任何计划，仅仅只是等待，等待一个适当的机会到来。直到现在，毕业的到来，我意识到我是个傻瓜，我应该创造机会并且抓住它而不只是等待。


这些日子里，我和我的朋友、室友、同学一个接一个地分开。我仍无法相信，在挥手之后，这些熟悉的面孔很快就会从我们的生活中消失，仅仅留下回忆。我明天就将离开学校。你已经计划远走高飞，追求你的未来，实现你的梦想。如果没有命运，也许我们不会再次相遇。所以今晚，我正在你的宿舍楼下徘徊，希望能偶然遇见你。但矛盾的是，你的美貌一定会使我心跳加速，我笨拙的舌头也许无法吐出一个字。我不记得我曾多少次经过你的宿舍楼，每次都希望看到你出现在阳台上或是窗台上。我不记得这个想法曾多少次在我的脑海中涌出：打电话叫她一起吃晚饭或是聊聊天。但每次，考虑到你的优秀和我的平凡，胆怯的优势超越勇气驱使我静静地离开。


毕业，意味着中学生活的终结。这些光荣与浪漫的时代结束。你可爱的微笑是我原来努力学习的动力，这单相思的爱情会被密封，作为一个我心灵深处的记忆。毕业，也意味着新生活的开始，一个到达光明未来的足迹。我真希望你在国外天天开心，一切顺利。同时，我将努力从幼稚中走出来，变得更加成熟。我的理想将是在现实中追求我的爱与幸福，我永远不会放弃。


再见了，我的公主！


如果有一天，在某个天涯海角，我们有机会相聚，即使是白发苍苍的男人和女人，在那个时候，我希望我们可以成为好朋友来自豪地分享这个记忆，重温年轻快乐的激情。如果这个机会永远没有到来，我希望我是天空中的星星，在你的窗外闪烁。远远地保佑着你，就像一个朋友，每天晚上陪伴在你左右，一同分享甜美的梦亦或是一同经历可怕的梦。

## 题目描述

现在问题来了：天空可以理解为一条数轴，在这条数轴上分布着许多颗星星，对于每颗星星都有它的位置 $X_i$ 和自身的亮度 $B_i$。**一个位置可能有多颗星星**。而窗户所能看到的范围是一个给出的参数 $W$，我们看到的星星也包括窗户边缘的星星。现在，要你求出调整窗户位置后能看到星星的亮度之和最大值。


## 说明/提示

样例说明：


 ![](https://cdn.luogu.com.cn/upload/pic/3818.png) 

对于 $10\%$ 的数据，$W=0$（没有边缘）；

对于 $40\%$ 的数据，$W\leq 1000$；

对于 $100\%$ 的数据，$1 \leq N\leq 10 ^ 5$，$0 \leq W\leq 10 ^ 5$，$1 \leq X_i\leq 10 ^ 5$，$1\leq B_i\leq 100$。

除 $W=0$ 的情况外，$W$ 均为 $\geq 3$ 的奇数。


## 样例 #1

### 输入

```
6 3
1 2
2 4
3 8
4 4
5 2
1000 1```

### 输出

```
16```

# AI分析结果


### 💡 Kay的C++算法解析：在你窗外闪耀的星星 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：编程技巧应用（前缀和/滑动窗口）

🗣️ **初步分析**：
> 解决本题的关键在于理解**固定窗口滑动求和**的技巧。想象你在数轴轨道上推着一个长度为W的透明盒子收集星星（亮度），盒子必须完整覆盖星星才能收集。核心挑战是如何高效计算每个窗口位置的星星总亮度。  
> - 题解主要分两类：**前缀和**（预计算累计亮度，O(1)求区间和）和**滑动窗口**（实时维护窗口内亮度总和）。难点在于处理同一位置多颗星星（亮度累加）和窗口边界包含规则。  
> - 算法流程：① 累加同位置星星亮度 → ② 计算前缀和数组 → ③ 滑动窗口求区间和最大值。可视化设计将高亮**窗口移动时新旧位置亮度变化**（新位置绿色闪烁，旧位置灰色消退），并通过进度条展示当前/最大亮度比。  
> - 像素动画方案：采用**复古星空探险**风格，玩家操控飞船（窗口）收集星星。飞船移动时触发"滴"声，刷新记录时播放"叮"胜利音效。支持AI自动演示（飞船自动滑行）和手动步进控制。

---

#### 2. 精选优质题解参考
**题解一：gb530（前缀和）**  
* **点评**：思路直击要害——用前缀和O(1)计算窗口亮度。代码简洁规范（`a[j] += k` 处理同位置星星，`pre[i]-pre[i-w]` 求区间和），边界处理完整（特判`w=0`）。实践价值高，可直接用于竞赛，是初学者最佳模板。

**题解二：1379号监听员（前缀和）**  
* **点评**：详细推导前缀和数学原理，强化理解为何`sum[r]-sum[l-1]`等于区间和。代码中`maxj`优化遍历范围，避免无效计算。变量命名清晰（`a[x]`存储亮度），适合理解基础后进阶优化。

**题解三：YaliKiWi（树状数组）**  
* **点评**：展示树状数组解法，虽非本题最优，但为动态更新场景（如星星亮度可变）提供思路。代码模块化（分离`Update()`、`Sum()`），附带树状数组模板链接，拓展性极佳。

---

#### 3. 核心难点辨析与解题策略
1.  **同位置星星的累加处理**  
    * **分析**：若不累加直接存储，会漏算亮度。优质题解均用`star[x] += brightness`解决。
    * 💡 学习笔记：输入阶段就要考虑数据聚合！

2.  **窗口边界与区间定义**  
    * **分析**：窗口长度W包含端点，区间应为`[i, i+W-1]`而非`[i, i+W]`。前缀和解法用`pre[i+W-1]-pre[i-1]`精准匹配。
    * 💡 学习笔记：区间求和时画图验证下标！

3.  **算法选择与时间复杂度**  
    * **分析**：暴力枚举（O(NW)）超时，前缀和（O(N)）最优。滑动窗口需排序，适用于无序输入（O(N log N)）。
    * 💡 学习笔记：静态数据用前缀和，动态更新用树状数组/线段树。

##### ✨ 解题技巧总结
- **技巧1 数据预处理**：输入时立即聚合相同位置数据。  
- **技巧2 前缀和模板化**：遇到固定区间求和问题，先写`pre[i]=pre[i-1]+a[i]`。  
- **技巧3 边界特判**：特殊值（如`W=0`）提前处理避免逻辑错误。

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合自gb530与1379号监听员的前缀和解法，含同位置星星处理与边界特判。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <algorithm>
  using namespace std;
  const int MAX = 100005;
  int star[MAX] = {0}; // 位置→亮度映射

  int main() {
      int n, w, maxPos = 0;
      cin >> n >> w;
      // 处理输入并累加同位置星星
      for (int i = 0; i < n; ++i) {
          int x, b; cin >> x >> b;
          star[x] += b;
          maxPos = max(maxPos, x);
      }
      if (w == 0) { cout << 0; return 0; } // 特判

      // 前缀和数组
      int pre[MAX] = {0};
      for (int i = 1; i <= maxPos; ++i) 
          pre[i] = pre[i-1] + star[i];

      // 滑动窗口求最大亮度
      int ans = 0;
      for (int i = 1; i <= maxPos - w + 1; ++i) {
          int sum = pre[i + w - 1] - pre[i - 1];
          ans = max(ans, sum);
      }
      cout << ans;
      return 0;
  }
  ```
* **代码解读概要**：  
  > ① `star[x] += b`聚合数据 → ② `pre[i]`计算前缀和 → ③ 窗口`[i, i+W-1]`区间和公式 → ④ 特判`W=0`。全程无需复杂数据结构。

**优质题解片段赏析**  
1. **gb530：输入处理亮点**  
   ```cpp
   for (int i=1; i<=n; i++) {
       cin >> j >> k;
       a[j] += k; // 关键！同位置亮度累加
       maxj = max(maxj, j);
   }
   ```
   * **学习笔记**：用基础数组替代`map`，效率更高。

2. **YaliKiWi：树状数组实现**  
   ```cpp
   void Update(int x, int v) { // 动态更新点
       while (x <= n) { c[x] += v; x += (x & -x); }
   }
   int Sum(int x) { // 前缀和查询
       int res = 0;
       while (x) { res += c[x]; x -= (x & -x); }
       return res;
   }
   ```
   * **学习笔记**：`x & -x`快速取低位1，理解位运算应用。

---

#### 5. 算法可视化：像素动画演示
**主题**：`像素星空探险家`（FC红白机风格）  
**核心演示**：飞船(W)滑动收集星星，实时显示亮度总和与最大值。  

**设计细节**：  
1. **场景构建**：  
   - 深蓝背景网格（每格20x20像素），黄色星星亮度越高像素半径越大（亮度1-100 → 半径2-10像素）。  
   - 飞船为红色边框矩形（宽度=W*20像素），内部显示当前亮度值。  

2. **动画逻辑**：  
   ```python
   while 飞船位置 <= maxPos - W + 1:
       绘制新进入的位置(i+W-1)：绿色闪烁3帧，播放"滴"声
       移除旧位置(i-1)：灰色渐隐
       更新当前亮度：cur_sum = pre[i+W-1] - pre[i-1]
       若刷新最大值：飞船变金色，播放"叮"胜利音
   ```

3. **交互控制**：  
   - 面板按钮：开始/暂停、单步、速度滑块（0.1x-5x）。  
   - AI演示模式：飞船自动移动，速度可调。  

4. **教学提示**：  
   - 代码同步：底部显示当前对应的C++片段（如`pre[i+w-1]-pre[i-1]`）。  
   - 旁白示例："看！窗口右移时，新位置3加入（+8），位置1移出（-2），总和从14→20！"  

---

#### 6. 拓展练习与相似问题思考
- **迁移场景**：  
  1. 环形数组最大子段和（如[1, -2, 3] → 3）  
  2. 二维窗口最大和（矩阵中固定矩形区域）  
  3. 带长度限制的子序列和（如长度≤K的最大和）  

- **洛谷推荐**：  
  1. **P1614** 爱与愁的心痛  
     → 同尺寸窗口求和，直接套用本题代码。  
  2. **P1714** 切蛋糕  
     → 长度≤M的子数组最大和，滑动窗口进阶。  
  3. **P1496** 火烧赤壁  
     → 区间覆盖问题，学习差分数组技巧。  

---

#### 7. 学习心得与经验分享
> **gb530的调试经验**：  
> “第一次提交WA后发现未处理同位置星星，立即改为`a[x] += y`。这提醒我们：**输入阶段就要考虑数据聚合**！”  
> → **Kay点评**：常见陷阱！类似问题（如统计词频）都需先处理再计算。

---

掌握前缀和与滑动窗口，你已解锁区间求和类问题的金钥匙！下次遇到固定窗口问题，记得默念：**累加→前缀和→滑动更新**。勇敢挑战更复杂的维度扩展吧！🚀

---
处理用时：191.46秒
# 题目信息

# 小A点菜

## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。


## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。


## 说明/提示

2020.8.29，增添一组 hack 数据 by @yummy

## 样例 #1

### 输入

```
4 4
1 1 2 2
```

### 输出

```
3
```

# AI分析结果


### 💡 Kay的C++算法解析：小A点菜 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`动态规划(DP)`  
🗣️ **初步分析**：  
> 这道题的核心是运用**01背包的动态规划思想**。想象你有一个背包（总金额M元），需要选择菜品（物品）恰好装满背包。每种菜只有一份（01选择），我们需要计算所有恰好花光M元的点菜方案数。  
> - **解题思路**：定义`dp[j]`为花光j元的方案数。遍历每道菜时，更新方案数：若选择当前菜，则方案数加上`dp[j-菜价]`的值  
> - **算法流程**：  
>   1. 初始化`dp[0]=1`（0元有1种方案：不点任何菜）  
>   2. 逆序遍历金额（从M到菜价）  
>   3. 状态转移：`dp[j] += dp[j-菜价]`  
> - **可视化设计**：采用**8位像素餐厅**风格，顾客（像素小人）走到菜品展台时：  
>   - 展台亮黄光表示当前菜品  
>   - 金额显示屏实时更新`dp[j]`数值  
>   - 选择菜品时播放"叮"音效，金额不足时播放"哔"错误音  

---

#### 2. 精选优质题解参考
**题解一（衡屿睿）**  
* **点评**：  
  思路清晰解释了三维DP转二维的过程，状态转移方程（`j==菜价`/`j>菜价`/`j<菜价`）推导完整。代码中`f[i][j]`变量命名规范，边界处理严谨（`f[0][0]=1`）。亮点在于用生活化比喻解释DP决策："吃与不吃之间的抉择"。

**题解二（Dream_zhc）**  
* **点评**：  
  详解了降维优化的核心原理（逆序更新避免覆盖），用双图对比说明顺序/逆序更新的差异。提供完整二维和一维两版代码，实践价值极高。亮点在于"背包填充"的类比：一维DP如同重复利用同个背包。

**题解三（WilliamPen）**  
* **点评**：  
  最简洁高效的一维DP实现（仅10行核心代码）。变量命名规范（`v[]`表菜价，`f[]`表方案数），边界初始化`f[0]=1`位置合理。亮点在于注释直指本质："现在的花费 += 不点这个菜的花费"。

---

#### 3. 核心难点辨析与解题策略
1. **难点1：状态定义与初始化**  
   * **分析**：`dp[0]=1`是解题关键却易遗漏。0元有1种方案（不点菜），这是所有状态转移的起点  
   * 💡 **学习笔记**：DP问题中"空集解"常为初始状态基石  

2. **难点2：逆序更新的必要性**  
   * **分析**：正序更新会导致重复计数（当前菜品被多次使用）。逆序从M→菜价可保证每道菜只用一次  
   * 💡 **学习笔记**：逆序遍历是01背包降维的通用技巧  

3. **难点3：方案数累加的本质**  
   * **分析**：转移方程`dp[j] += dp[j-菜价]`本质是分治思想——当前方案数=不选此菜的方案数+选此菜的方案数  
   * 💡 **学习笔记**：DP本质是智能化的分治法，通过存储子问题解避免重复计算  

### ✨ 解题技巧总结
- **技巧1：空集初始化法**：DP方案数问题优先考虑`dp[0]=1`  
- **技巧2：维度压缩三原则**：逆序更新、状态覆盖、循环边界  
- **技巧3：变量名语义化**：如`f[]`表方案数，`v[]`表价值  

---

#### 4. C++核心代码实现赏析
**通用核心实现**  
```cpp
#include <iostream>
using namespace std;
int dp[10010] = {1}; // 初始化dp[0]=1

int main() {
    int n, m, price;
    cin >> n >> m;
    
    for (int i = 0; i < n; i++) {
        cin >> price;
        for (int j = m; j >= price; j--)  // 逆序更新关键！
            dp[j] += dp[j - price];       // 核心状态转移
    }
    
    cout << dp[m];
    return 0;
}
```
**代码解读概要**：  
> 初始化`dp[0]=1`建立状态基础 → 逆序遍历金额保证菜品唯一性 → 状态转移累加方案数 → 最终输出`dp[m]`为花光M元的方案总数

**题解片段赏析**  
1. **衡屿睿（二维DP）**  
   ```cpp
   if(j==a[i]) f[i][j]=f[i-1][j]+1;      // 刚好买当前菜
   if(j>a[i]) f[i][j]=f[i-1][j]+f[i-1][j-a[i]]; // 可买可不买
   ```
   **学习笔记**：二维DP直观展现三种金额关系，适合DP初学者理解  

2. **Dream_zhc（降维图解）**  
   ```cpp
   for(int j=m; j>=a[i]; j--)  // 逆序核心！
     f[j] += f[j-a[i]]; 
   ```
   **学习笔记**：逆序遍历时`f[j]`使用的`f[j-a[i]]`是未更新的旧值，保证状态独立  

3. **WilliamPen（极致简洁）**  
   ```cpp
   f[0]=1; // 初始化点睛之笔
   for(int j=m; j>=v[i]; j--) 
        f[j] += f[j-v[i]];
   ```
   **学习笔记**：工业级代码应如此——无冗余、边界清晰、变量名自注释  

---

#### 5. 算法可视化：像素动画演示
**主题**：8位像素餐厅点菜大冒险  
**核心演示**：DP方案数累加过程 → 顾客在餐厅移动选择菜品 → 实时显示金额方案数变化  

**动画帧步骤**：  
1. **场景初始化**  
   - 像素风餐厅布局：左侧菜品展台（带价格标签），右侧金额显示屏（0-M）  
   - 控制面板：步进/暂停/重置按钮 + 速度滑块（调速范围1-5帧/秒）  

2. **动态演示流程**  
   ```mermaid
   graph LR
   A[顾客走到新展台] --> B{金额≥菜价？}
   B -- Yes --> C[展台亮黄光+“叮”音效]
   C --> D[显示屏：dp[j] += dp[j-菜价]]
   B -- No --> E[展台闪红光+“哔”音效]
   ```

3. **关键交互设计**  
   - **高亮逻辑**：当前菜品展台始终亮黄光，被激活的`dp[j]`和`dp[j-菜价]`显示为绿色  
   - **音效系统**：  
     * 有效选择：8-bit "叮"声（频率=2000Hz）  
     * 无效选择：短促"哔"声（500Hz）  
     * 解完成：超级马里奥过关音乐  

4. **游戏化设计**  
   - 每完成3道菜解锁新餐厅皮肤  
   - 连续正确更新状态得COMBO奖励分  

---

#### 6. 拓展练习与相似问题
**技巧迁移场景**：  
1. 硬币组合问题（固定面值凑金额）  
2. 子集和问题（是否存在和为K的子集）  
3. 目标路径统计（网格中从A到B路径数）  

**洛谷推荐**：  
1. **P1048 采药**  
   🗣️ 同属01背包框架，将"方案数"改为"最大价值"  
2. **P1064 金明的预算方案**  
   🗣️ 带依赖关系的背包问题，深化状态设计能力  
3. **P1616 疯狂的采药**  
   🗣️ 完全背包问题，对比学习状态转移差异  

---

#### 7. 学习心得与经验分享
> **经验摘录（多作者）**：  
> "调试时最常漏掉`dp[0]=1`初始化"  
> "二维DP转一维时，80%的错误源于忘记逆序更新"  
> "用`f[j] += f[j-v[i]]`比`f[j] = f[j] + f[j-v[i]]`更简洁"  
>  
> **Kay总结**：  
> DP本质是数学归纳法的代码实现——基础情形（初始化）和递推关系（状态转移）缺一不可。一维DP的逆序更新如同时光倒流，确保每个决策只发生一次。

---

本次解析终了，愿你在动态规划的海洋中乘风破浪！下次挑战金明的预算方案如何？🚀

---
处理用时：85.35秒
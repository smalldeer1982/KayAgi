# 题目信息

# [蓝桥杯 2021 省 AB] 砝码称重

## 题目描述

你有一架天平和 $N$ 个砝码, 这 $N$ 个砝码重量依次是 $W_{1}, W_{2}, \cdots, W_{N}$ 。 请你计算一共可以称出多少种不同的重量?

注意砝码可以放在天平两边。


## 说明/提示

**【样例说明】**

能称出的 10 种重量是: $1 、 2 、 3 、 4 、 5 、 6 、 7 、 9 、 10 、 11$ 。

$$
\begin{aligned}
&1=1 \\
&2=6-4(\text { 天平一边放 } 6, \text { 另一边放 4) } \\
&3=4-1 \\
&4=4 \\
&5=6-1 \\
&6=6 \\
&7=1+6 \\
&9=4+6-1 \\
&10=4+6 \\
&11=1+4+6
\end{aligned}
$$

**【评测用例规模与约定】**

对于 $50 \%$ 的评测用例, $1 \leq N \leq 15$ 。

对于所有评测用例, $1 \leq N \leq 100, N$ 个砝码总重不超过 $10^5$。 

蓝桥杯 2021 第一轮省赛 A 组 F 题（B 组 G 题）。

## 样例 #1

### 输入

```
3
1 4 6```

### 输出

```
10```

# AI分析结果


### 💡 Kay的C++算法解析：砝码称重 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：**动态规划（01背包变种）**  
🗣️ **初步分析**：
> 砝码称重问题本质上是**动态规划**的变种应用，类似背包问题但更灵活。想象你有一个神奇背包，每个砝码有三种选择：不放、放左盘（+重量）、放右盘（-重量）。关键在于通过状态转移记录所有可能的重量组合。

- **核心思路**：  
  定义`dp[i][j]`表示前`i`个砝码能否称出重量`j`（需处理负重量）。状态转移需考虑三种操作：  
  1. 不放砝码：继承上一状态  
  2. 放左盘：`j + w[i]`  
  3. 放右盘：`abs(j - w[i])`  
  难点在于处理负下标（通过偏移量或绝对值）和状态转移顺序（避免覆盖）。

- **可视化设计**：  
  采用**8位像素风天平模拟**：  
  - 网格表示重量范围（0~总重），像素块高亮可称重量  
  - 每步加入砝码时，用箭头动画展示三种操作（不放/左移/右移）  
  - 音效：放置砝码（"叮"）、新重量解锁（上扬音效）、过关（8-bit胜利音）

---

### 精选优质题解参考
**题解一（loser_seele，5星）**  
* **亮点**：创新使用`bitset`位运算优化，代码极简高效（仅10行），时间复杂度优化至$O(\frac{n \sum w_i}{w})$  
* **核心逻辑**：  
  ```cpp
  bitset<100010> d; // 状态压缩
  d.set(0);          // 初始状态：重量0
  for(int i=1;i<=n;i++) d |= d << a[i]; // 加操作
  for(int i=1;i<=n;i++) d |= d >> a[i]; // 减操作（位运算右移）
  ```
  > **学习笔记**：`bitset`将布尔状态转为位运算，大幅提升效率，尤其适合大范围状态转移。

**题解二（123xiayicheng，4.5星）**  
* **亮点**：分阶段处理（先加后减），避免状态覆盖，代码逻辑清晰  
* **核心逻辑**：  
  ```cpp
  // 第一阶段：同侧（加）
  for(j=sum; j>=a[i]; j--) 
    if(dp[j-a[i]]) dp[j]=1;
  // 第二阶段：异侧（减）
  for(j=1; j<=sum-a[i]; j++)
    if(dp[j+a[i]] && !dp[j]) dp[j]=1;
  ```
  > **学习笔记**：分步处理正负操作可降低思维难度，注意循环方向（加操作需倒序防重复）。

**题解三（FstAutoMaton，4.5星）**  
* **亮点**：标准DP实现，完整处理负重量（`abs`替代偏移量），适合初学者理解  
* **核心逻辑**：  
  ```cpp
  f[i][j] = f[i-1][j]                  // 不放
         || f[i-1][abs(j-a[i])]        // 放左盘
         || (j+a[i]<=sum && f[i-1][j+a[i]]); // 放右盘
  ```
  > **学习笔记**：`abs`巧妙规避负下标，但需注意边界检查（`j+a[i] ≤ sum`）。

---

### 核心难点辨析与解题策略
1. **难点：负重量处理**  
   * **分析**：重量可能为负，但数组下标需非负。优质解法采用：  
     - **偏移量法**（RP_INT_MAX）：所有重量加常数`N`使最小值为0  
     - **绝对值法**（FstAutoMaton）：用`abs(j-w_i)`映射到非负域  
   * 💡 **学习笔记**：偏移量更通用，绝对值更简洁，根据状态范围选择。

2. **难点：状态转移顺序**  
   * **分析**：一维DP需严格顺序：  
     - **加操作**必须**倒序**（防当前砝码重复使用）  
     - **减操作**需**正序**（依赖`j+a[i]`状态）  
   * 💡 **学习笔记**：二维DP无此限制，但空间开销大，竞赛优先一维+滚动数组。

3. **难点：状态完整性**  
   * **分析**：需覆盖三种操作（不放/加/减），`loser_seele`用`bitset`位运算`|=`一次性完成，`123xiayicheng`分两步处理。  
   * 💡 **学习笔记**：位运算或逻辑或（`||`）都能高效合并状态，确保无遗漏。

#### ✨ 解题技巧总结
- **技巧1：状态压缩** - 布尔状态DP首选`bitset`（时间复杂度降$w$倍）  
- **技巧2：问题分解** - 将加减操作分离处理（如分两次循环）降低复杂度  
- **技巧3：边界防御** - 负重量用偏移量/绝对值，数组大小设为`2*sum+1`  
- **技巧4：滚动数组** - 仅保留`dp[i]`和`dp[i-1]`（见RP_INT_MAX解法）  

---

### C++核心代码实现赏析
**通用核心实现（基于FstAutoMaton解法优化）**  
```cpp
#include <iostream>
#include <vector>
using namespace std;

int main() {
    int n, sum = 0;
    cin >> n;
    vector<int> w(n+1);
    for (int i=1; i<=n; i++) {
        cin >> w[i];
        sum += w[i];
    }
    
    vector<vector<bool>> dp(n+1, vector<bool>(sum+1, false));
    dp[0][0] = true; // 初始状态：0重量可称
    
    for (int i=1; i<=n; i++) {
        for (int j=0; j<=sum; j++) {
            dp[i][j] = dp[i-1][j]                     // 不放砝码
                    || (j >= w[i] && dp[i-1][j-w[i]]) // 放左盘
                    || (j+w[i] <= sum && dp[i-1][j+w[i]]) // 放右盘
                    || dp[i-1][abs(j-w[i])];           // 绝对值处理
        }
    }
    
    int ans = 0;
    for (int j=1; j<=sum; j++) 
        if (dp[n][j]) ans++;
    cout << ans;
}
```
**代码解读概要**：  
- **初始化**：`dp[0][0]=true`表示空天平状态  
- **三层状态转移**：覆盖不放/加/减操作，`abs`处理负值  
- **结果统计**：遍历所有可能重量（1~sum），统计`true`数量  

**题解一（loser_seele）片段赏析**  
```cpp
bitset<100010> d; // 100010为最大重量范围
d.set(0);         // 第0位=1（重量0）
for(int i=1;i<=n;i++) d |= d << a[i]; // 加操作（左移位）
for(int i=1;i<=n;i++) d |= d >> a[i]; // 减操作（右移位）
cout << d.count()-1; // 排除重量0
```
> **学习笔记**：`d << a[i]`生成所有"当前重量+砝码"组合，`d >> a[i]`生成"当前重量-砝码"，位运算合并效率极高。

---

### 算法可视化：像素动画演示
**主题**：**8-bit天平历险记**  
**核心设计**：  
![](https://fakeurl/pixel_balance.gif)  
1. **场景初始化**：  
   - 像素网格横轴表示重量（-sum~sum），纵轴表示砝码序号  
   - 初始状态：重量0处绿色像素块亮起（`dp[0][0]=1`）

2. **逐步加入砝码**（第`i`关）：  
   - **不放**：继承上一关所有亮块（灰色箭头延续）  
   - **加操作**：从每个亮块向右移动`w_i`格，新块亮蓝色（伴随"叮"音效）  
   - **减操作**：从亮块向左移动`w_i`格，对称位置亮黄色（像素闪烁+按键音）  

3. **交互控制**：  
   - 控制面板：步进/暂停/重置按钮 + 速度滑块  
   - 自动演示：AI按最优顺序放置砝码（贪吃蛇式路径显示）  
   - 过关机制：每成功处理1砝码解锁新关卡，积分=新增重量数  

4. **动态信息**：  
   - 顶部显示当前状态：`dp[i][j]=?`和对应C++代码行（高亮）  
   - 旁白提示：*"加入w₃=6！从重量2向右6格，解锁重量8！"*  

---

### 拓展练习与相似问题思考
**通用技巧迁移**：  
本解法核心——**状态压缩+分阶段决策**可应用于：  
1. 正负符号组合问题（如LeetCode 494 目标和）  
2. 子集和问题（如分割等和子集）  
3. 资源分配问题（如股票买卖含手续费）  

**洛谷推荐**：  
1. **P2347 [砝码称重]**  
   → 多重背包入门，巩固分阶段思想  
2. **P1048 [采药]**  
   → 标准01背包，理解状态转移基础  
3. **P1064 [金明的预算方案]**  
   → 依赖背包，拓展多决策能力  

---

### 学习心得与经验分享
**作者经验（while_true）**：  
> *"转移需严格倒序，否则状态覆盖导致错误——我在调试中耗时2小时才定位此坑！"*  

**Kay点评**：  
动态规划的顺序敏感性是常见陷阱，建议：  
1. 画状态转移表验证  
2. 小规模数据手工模拟  
3. 输出中间状态调试  

---

### 结语  
掌握动态规划的关键在于：**精准状态定义 + 完备转移覆盖**。通过本指南的像素动画和代码剖析，相信大家能更直观理解砝码问题的本质。尝试用`bitset`优化你的下一个DP问题吧！🚀

---
处理用时：208.89秒
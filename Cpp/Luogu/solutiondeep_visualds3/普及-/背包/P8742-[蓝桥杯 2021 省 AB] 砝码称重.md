# 题目信息

# [蓝桥杯 2021 省 AB] 砝码称重

## 题目描述

你有一架天平和 $N$ 个砝码, 这 $N$ 个砝码重量依次是 $W_{1}, W_{2}, \cdots, W_{N}$ 。 请你计算一共可以称出多少种不同的重量?

注意砝码可以放在天平两边。


## 说明/提示

**【样例说明】**

能称出的 10 种重量是: $1 、 2 、 3 、 4 、 5 、 6 、 7 、 9 、 10 、 11$ 。

$$
\begin{aligned}
&1=1 \\
&2=6-4(\text { 天平一边放 } 6, \text { 另一边放 4) } \\
&3=4-1 \\
&4=4 \\
&5=6-1 \\
&6=6 \\
&7=1+6 \\
&9=4+6-1 \\
&10=4+6 \\
&11=1+4+6
\end{aligned}
$$

**【评测用例规模与约定】**

对于 $50 \%$ 的评测用例, $1 \leq N \leq 15$ 。

对于所有评测用例, $1 \leq N \leq 100, N$ 个砝码总重不超过 $10^5$。 

蓝桥杯 2021 第一轮省赛 A 组 F 题（B 组 G 题）。

## 样例 #1

### 输入

```
3
1 4 6```

### 输出

```
10```

# AI分析结果

# 💡 Kay的C++算法解析：砝码称重 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（01背包变种）  

🗣️ **初步分析**：  
解决“砝码称重”问题，关键在于理解**天平两边放砝码**的本质——**重量差**。比如，左边放6，右边放4，相当于能称出2（6-4）；左边放1+6，右边放4，相当于能称出3（1+6-4）。我们需要记录所有可能的“重量差”，这正好可以用**动态规划**（DP）来解决！  

简单来说，动态规划就像“一步步解锁新能力”：每加入一个砝码，我们就能用它“扩展”之前能称出的重量——要么把它放在左边（增加当前重量），要么放在右边（减少当前重量），要么不用它（保持当前重量）。  

**核心思路**：  
用`dp[i][j]`表示前`i`个砝码能否称出重量`j`（`j`是天平两边的重量差）。转移时考虑三种情况：  
1. 不用第`i`个砝码：`dp[i][j] = dp[i-1][j]`；  
2. 把第`i`个砝码放左边（增加重量）：`dp[i][j] = dp[i-1][j - w[i]]`（`j >= w[i]`）；  
3. 把第`i`个砝码放右边（减少重量）：`dp[i][j] = dp[i-1][j + w[i]]`（`j + w[i] <= 总重量`）。  

**核心难点**：  
- 如何处理“重量差为负”的情况？（比如`j - w[i]`可能小于0）——用**偏移值**（比如给所有`j`加一个大正数，把负数变成正数）；  
- 如何覆盖所有可能的转移情况？（必须包含“放左边、放右边、不放”三种选择）。  

**可视化设计思路**：  
我们可以做一个“像素天平游戏”：  
- 用**像素块**表示能称出的重量（比如绿色块代表可称出，灰色代表不可）；  
- 每加入一个砝码，用**动画**展示新的重量块如何“扩展”（比如从当前块向左右延伸）；  
- 用**音效**提示关键操作（比如“叮”的一声表示解锁新重量，“胜利”音效表示完成所有砝码的处理）。  


## 2. 精选优质题解参考

为了帮大家快速掌握解题技巧，我从**思路清晰度、代码可读性、算法有效性**三个维度，筛选了以下4份优质题解：


### **题解一：while_true（赞87）—— 01背包的逻辑推导**  
* **点评**：  
  这份题解把“砝码称重”转化为“01背包问题”的思路非常清晰！作者用数学公式推导了“天平两边放砝码”的本质（`m_thing = |m_l - m_r|`），并明确了`dp[i][j]`的状态定义（前`i`个砝码能否称出`j`）。虽然没给代码，但逻辑严谨，特别适合理解“为什么要用DP”。  

  **亮点**：用“重量差”连接题目与01背包，帮我们抓住了问题的核心。


### **题解二：ryf_loser（赞62）—— 完整的状态转移代码**  
* **点评**：  
  这份题解的代码**直接明了**！作者用`dp[i][j]`表示前`i`个砝码能否称出`j`，并通过四重条件判断覆盖了所有转移情况：  
  1. `j == w[i]`（单独用这个砝码）；  
  2. `dp[i-1][j]`（不用这个砝码）；  
  3. `dp[i-1][j + w[i]]`（放右边，减少重量）；  
  4. `dp[i-1][abs(j - w[i])]`（放左边，增加重量）。  

  代码结构工整，变量名清晰（比如`sum`记录总重量），非常适合初学者模仿。  

  **亮点**：用简单的条件判断覆盖了所有情况，可读性高。


### **题解三：123xiayicheng（赞47）—— 对比类似题目，理解“两边放砝码”**  
* **点评**：  
  作者通过对比“简单版砝码称重”（P2347）和本题，帮我们理解了“两边放砝码”的区别：简单版只需要考虑“加砝码”，而本题需要额外考虑“减砝码”（即放另一边）。代码中用了两次循环：第一次处理“加砝码”（`j >= a[i]`），第二次处理“减砝码”（`j <= sum - a[i]`），清晰展示了“两边放”的实现方式。  

  **亮点**：通过对比类似题目，帮我们快速掌握“变种问题”的解决技巧。


### **题解四：loser_seele（赞13）—— bitset优化，代码超简洁**  
* **点评**：  
  这份题解用`bitset`（位集）优化了DP转移，把“是否能称出`j`”用二进制位表示（1表示能，0表示不能）。代码中`d |= d << a[i]`表示“加砝码”（左移相当于增加重量），`d |= d >> a[i]`表示“减砝码”（右移相当于减少重量）。这种优化让代码变得**超简洁**（只有188字节），而且效率很高（时间复杂度`O(n*sum/32)`）。  

  **亮点**：用位运算优化DP，适合学习“高效编程技巧”。


## 3. 核心难点辨析与解题策略

在解决“砝码称重”问题时，大家常遇到以下3个难点，我结合优质题解总结了应对策略：


### **1. 如何处理“重量差为负”的情况？**  
* **分析**：  
  当`j - w[i] < 0`时，直接用`j - w[i]`作为下标会越界。比如，前`i-1`个砝码能称出`3`，当前砝码是`5`，那么`j - w[i] = -2`，这时候需要把`-2`转换为正数。  

* **解决方案**：  
  用**偏移值**（比如`N = 1e5`），把所有`j`加上`N`，这样`j - w[i] + N`就不会是负数了。比如RP_INT_MAX的代码中，`f[i&1][j+N]`表示前`i`个砝码能称出`j`（`j`是原始重量差）。  

* 💡 **学习笔记**：偏移值是处理“负下标”的常用技巧，记住“把负数变成正数”！


### **2. 如何覆盖所有转移情况？**  
* **分析**：  
  每个砝码有三种选择：不放、放左边、放右边。如果漏掉其中一种，就会导致结果错误。比如，样例中的`2 = 6-4`，如果没考虑“放右边”的情况，就不会得到这个结果。  

* **解决方案**：  
  转移方程必须包含三种情况：  
  - 不放：`dp[i][j] = dp[i-1][j]`；  
  - 放左边（增加重量）：`dp[i][j] = dp[i-1][j - w[i]]`（`j >= w[i]`）；  
  - 放右边（减少重量）：`dp[i][j] = dp[i-1][j + w[i]]`（`j + w[i] <= sum`）。  

  比如ryf_loser的代码中，用四重条件判断覆盖了这三种情况（`j == w[i]`是“单独放”的情况，属于“放左边”的特例）。  

* 💡 **学习笔记**：转移方程要“穷举所有可能”，不要漏掉任何一种选择！


### **3. 如何优化空间复杂度？**  
* **分析**：  
  当`n=100`，`sum=1e5`时，`dp[n][sum]`的空间是`100*1e5=1e7`，这会占用较多内存。  

* **解决方案**：  
  用**滚动数组**（比如`f[2][sum*2]`），因为`dp[i][j]`只依赖于`dp[i-1][j]`。比如RP_INT_MAX的代码中，用`i&1`（即`i%2`）来切换当前层和上一层，这样空间复杂度从`O(n*sum)`降到了`O(sum)`。  

* 💡 **学习笔记**：滚动数组是优化DP空间的常用技巧，记住“只保留当前层和上一层”！


### ✨ 解题技巧总结  
- **问题转化**：把“天平两边放砝码”转化为“重量差”，用DP记录所有可能的差；  
- **状态定义**：`dp[j]`表示能否称出重量`j`（`j`是重量差）；  
- **转移方程**：包含“不放、放左边、放右边”三种情况；  
- **优化技巧**：用偏移值处理负下标，用滚动数组或bitset优化空间/时间。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（滚动数组+偏移值）  
* **说明**：  
  这份代码来自RP_INT_MAX的题解，用滚动数组和偏移值处理了负下标，空间复杂度低，适合竞赛使用。  

* **完整核心代码**：  
  ```cpp
  #include <cstdio>
  #include <cstring>
  #include <iostream>
  #include <algorithm>
  using namespace std;
  const int N = 150000; // 偏移值，防止负下标
  int n, sum, w;
  bool f[2][300010]; // 滚动数组，f[0]表示上一层，f[1]表示当前层
  int main() {
      scanf("%d", &n);
      f[0][N] = 1; // 初始化：0个砝码时能称出0
      for (int i = 1; i <= n; ++i) {
          scanf("%d", &w);
          sum += w;
          // 用i&1切换当前层（0或1）
          int cur = i & 1;
          int prev = (i-1) & 1;
          // 复制上一层的状态（不放当前砝码）
          memcpy(f[cur], f[prev], sizeof(f[cur]));
          // 处理放左边（增加重量）：j = prev_j - w → prev_j = j + w
          for (int j = sum; j >= w; --j) {
              if (f[prev][j + w + N]) {
                  f[cur][j + N] = 1;
              }
          }
          // 处理放右边（减少重量）：j = prev_j + w → prev_j = j - w
          for (int j = 1; j <= sum - w; ++j) {
              if (f[prev][j - w + N]) {
                  f[cur][j + N] = 1;
              }
          }
      }
      int ans = 0;
      for (int i = 1; i <= sum; ++i) {
          if (f[n&1][i + N]) {
              ans++;
          }
      }
      printf("%d\n", ans);
      return 0;
  }
  ```

* **代码解读概要**：  
  1. 初始化：`f[0][N] = 1`表示0个砝码时能称出0；  
  2. 循环每个砝码：用`cur`和`prev`切换滚动数组的层；  
  3. 复制上一层的状态（不放当前砝码）；  
  4. 处理“放左边”（增加重量）：遍历`j`从`sum`到`w`，如果`prev_j = j + w`能称出，那么`j`也能称出；  
  5. 处理“放右边”（减少重量）：遍历`j`从`1`到`sum - w`，如果`prev_j = j - w`能称出，那么`j`也能称出；  
  6. 统计结果：遍历`1`到`sum`，统计能称出的重量数。


### 针对各优质题解的片段赏析

#### **题解二：ryf_loser（赞62）—— 四重条件判断**  
* **亮点**：用简单的条件判断覆盖了所有转移情况，可读性高。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= n; i++) {
      for (int j = sum; j; j--) {
          if (j == w[i]) dp[i][j] = 1; // 单独用这个砝码
          else if (dp[i-1][j]) dp[i][j] = 1; // 不用这个砝码
          else if (dp[i-1][j + w[i]]) dp[i][j] = 1; // 放右边（减少重量）
          else if (dp[i-1][abs(j - w[i])]) dp[i][j] = 1; // 放左边（增加重量）
      }
  }
  ```  
* **代码解读**：  
  - 外层循环遍历每个砝码；  
  - 内层循环遍历所有可能的重量`j`（从`sum`到`1`）；  
  - 四个条件分别对应“单独用、不用、放右边、放左边”四种情况；  
  - `abs(j - w[i])`处理了`j < w[i]`的情况（比如`j=2`，`w[i]=5`，`abs(2-5)=3`，表示前`i-1`个砝码能称出3，当前砝码放左边，就能称出2=3-5？不对，等一下，其实`j + w[i]`是前`i-1`个砝码的重量，当前砝码放右边，所以`j = (j + w[i]) - w[i]`？或者应该反过来，比如前`i-1`个砝码能称出`j + w[i]`，那么放右边的话，当前砝码的重量是`w[i]`，所以`j = (j + w[i]) - w[i]`？可能我需要再想一下，其实`dp[i-1][j + w[i]]`表示前`i-1`个砝码能称出`j + w[i]`，那么放右边的话，当前砝码的重量是`w[i]`，所以`j = (j + w[i]) - w[i]`，也就是能称出`j`。比如前`i-1`个砝码能称出`6`（`j + w[i] = 6`），当前砝码是`4`（`w[i] = 4`），那么`j = 6 - 4 = 2`，也就是能称出`2`（6-4）。对，这样是对的。  
* 💡 **学习笔记**：用条件判断覆盖所有情况，是初学者最容易掌握的方式。


#### **题解四：loser_seele（赞13）—— bitset优化**  
* **亮点**：用位运算优化DP，代码超简洁，效率高。  
* **核心代码片段**：  
  ```cpp
  bitset<100010> d;
  d.set(0); // 初始化：能称出0
  for (int i = 1; i <= n; i++) {
      cin >> a[i];
      d |= d << a[i]; // 加砝码（左移相当于增加重量）
  }
  for (int i = 1; i <= n; i++) {
      d |= d >> a[i]; // 减砝码（右移相当于减少重量）
  }
  cout << d.count() - 1; // 减去0的情况
  ```  
* **代码解读**：  
  - `bitset<100010> d`：用二进制位表示能称出的重量（`d[j] = 1`表示能称出`j`）；  
  - `d.set(0)`：初始化，能称出0；  
  - `d |= d << a[i]`：左移`a[i]`位，相当于把所有能称出的重量加上`a[i]`，然后合并到`d`中（表示“加砝码”）；  
  - `d |= d >> a[i]`：右移`a[i]`位，相当于把所有能称出的重量减去`a[i]`，然后合并到`d`中（表示“减砝码”）；  
  - `d.count() - 1`：统计能称出的重量数（减去0的情况）。  
* 💡 **学习笔记**：bitset是处理“可行性DP”的神器，能把时间复杂度降低到`O(n*sum/32)`！


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：像素天平冒险  
**风格**：8位像素风（类似FC红白机游戏），用简单的色块和动画展示算法过程。  
**核心内容**：动态展示每个砝码加入时，可称重量的变化。  


### 📝 设计思路简述  
- **场景**：屏幕左侧是“天平”（用两个矩形表示左右盘），右侧是“重量网格”（用10x10的像素块表示能称出的重量，绿色代表可称出，灰色代表不可）；  
- **动画逻辑**：每加入一个砝码，用**动画**展示新的重量块如何从当前块向左右延伸（比如，当前能称出3，加入5后，会新增8（3+5）和2（5-3）两个重量块）；  
- **交互**：提供“单步执行”（点击一次走一步）、“自动播放”（每秒走一步）、“速度调节”（滑块调整播放速度）按钮；  
- **音效**：  
  - 每解锁一个新重量，播放“叮”的音效（提示“新重量出现了！”）；  
  - 完成所有砝码的处理，播放“胜利”音效（提示“所有重量都解锁了！”）；  
- **游戏化元素**：设置“关卡”（每处理5个砝码为一关），完成关卡后显示“过关”动画，增加成就感。  


### 🎬 动画帧步骤示例  
1. **初始化**：  
   - 天平左右盘为空，重量网格中只有0（绿色）；  
   - 背景音乐（8位风格）开始播放。  
2. **加入第一个砝码（1）**：  
   - 天平左盘出现1的像素块；  
   - 重量网格中新增1（绿色）；  
   - 播放“叮”的音效。  
3. **加入第二个砝码（4）**：  
   - 天平右盘出现4的像素块；  
   - 重量网格中新增3（4-1）、4（单独用）、5（1+4）（绿色）；  
   - 播放“叮”的音效。  
4. **加入第三个砝码（6）**：  
   - 天平左盘出现6的像素块；  
   - 重量网格中新增2（6-4）、5（6-1）、7（1+6）、9（4+6-1）、10（4+6）、11（1+4+6）（绿色）；  
   - 播放“胜利”音效（完成所有砝码处理）。  


### 📊 信息展示  
- **代码同步**：屏幕下方显示当前步骤对应的C++代码片段（比如`d |= d << a[i]`），并高亮当前执行行；  
- **旁白提示**：用文字气泡显示“现在加入砝码6，看看能解锁哪些新重量？”“叮！新重量2出现了（6-4）！”。  


## 6. 拓展练习与相似问题思考

### 🧠 通用思路/技巧迁移  
“砝码称重”的核心是**01背包的可行性问题**，其思路可以迁移到以下场景：  
1. **硬币问题**：用若干硬币组成指定金额（可以选或不选，类似“放或不放”）；  
2. **子集和问题**：判断是否存在子集和为指定值（类似“能称出指定重量”）；  
3. **分割等和子集**：判断是否能将数组分成两个和相等的子集（类似“能称出总重量的一半”）。  


### 📚 练习推荐 (洛谷)  
1. **洛谷 P2347** - 砝码称重（简单版）  
   🗣️ **推荐理由**：基础01背包可行性问题，只需要考虑“加砝码”，适合入门。  
2. **洛谷 P8742** - 砝码称重（原题）  
   🗣️ **推荐理由**：本题的原版，巩固“两边放砝码”的处理技巧。  
3. **洛谷 P1048** - 采药  
   🗣️ **推荐理由**：01背包基础题，学习状态转移和滚动数组优化。  
4. **洛谷 P1164** - 小A点菜  
   🗣️ **推荐理由**：01背包方案数问题，拓展思路（不仅要判断是否可行，还要统计方案数）。  


## 7. 学习心得与经验分享 (若有)

### 📝 参考经验（来自loser_seele）  
> “我一开始用普通DP写，结果超时了，后来想到用bitset优化，代码不仅变简洁了，还快了很多。”  

**点评**：这位作者的经验提醒我们，**优化技巧很重要**！当普通DP超时的时候，可以想想有没有更高效的方式（比如位运算、单调队列等）。bitset优化是处理“可行性DP”的神器，大家一定要掌握！  


## 🎉 结语  
本次关于“砝码称重”的C++解题分析就到这里啦！希望这份指南能帮大家理解动态规划的核心思路，掌握“两边放砝码”的处理技巧。记住，编程的乐趣在于“解决问题”，只要多思考、多练习，你一定能成为算法小能手！💪  

下次我们再一起探索新的编程挑战吧！😃

---
处理用时：190.46秒
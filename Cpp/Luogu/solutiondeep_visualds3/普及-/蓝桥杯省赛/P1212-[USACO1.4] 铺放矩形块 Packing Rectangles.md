# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果


### 💡 Kay的C++算法解析：铺放矩形块 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`枚举` 与 `模拟`  
🗣️ **初步分析**：
> 解决"铺放矩形块"的关键在于**枚举所有排列组合**并**模拟6种基本布局**。就像玩俄罗斯方块时尝试所有旋转和位置来消除空隙一样，这里我们需要：
> - 枚举4个矩形的**排列顺序**（24种）
> - 枚举每个矩形的**旋转状态**（长宽互换，共16种）
> - 对每种组合**计算6种布局方案**的封闭矩形尺寸
> 
> **核心难点**在于：
> 1. 第六种布局需要根据矩形高度关系分5种子情况计算
> 2. 避免重复记录相同面积的矩形尺寸
> 
> **可视化设计思路**：
> 将采用**8位像素风格**，用不同颜色方块代表4个矩形：
> - 动态展示DFS枚举过程（树状展开）
> - 高亮当前测试的布局方案编号
> - 当发现更小面积时播放"胜利音效"
> - 最终展示最优布局的像素拼装动画

---

#### 2. 精选优质题解参考
**题解一（七喜）**  
* **点评**：  
  思路清晰度 ⭐⭐⭐⭐⭐  
  采用DFS生成排列+旋转组合，逻辑直白易懂。代码规范性 ⭐⭐⭐⭐ 变量名`tmpx/tmpy`可优化，但注释详细标注了6种布局计算。算法有效性 ⭐⭐⭐⭐ 完整覆盖USACO官方图示的6种情况。实践价值 ⭐⭐⭐⭐ 边界处理严谨，特别在第六种布局的分支判断中体现了对临界值的细致考量。  
  **亮点**：对每种布局的数学推导有直观图示说明，帮助理解长宽计算逻辑。

**题解二（HFUUZY）**  
* **点评**：  
  思路清晰度 ⭐⭐⭐⭐ 通过四重循环实现排列组合，结构工整。代码规范性 ⭐⭐⭐⭐⭐ 函数模块化（swap/update），变量命名规范（w/h）。算法有效性 ⭐⭐⭐⭐ 使用calc函数封装6种布局计算。实践价值 ⭐⭐⭐⭐ 竞赛实用性强，通过函数封装提升可读性。  
  **亮点**：采用`next_permutation`标准库函数简化排列生成，体现C++特性运用。

**题解三（Chiesl）**  
* **点评**：  
  思路清晰度 ⭐⭐⭐⭐⭐ 对6种布局进行数学建模分析，推导严谨。代码规范性 ⭐⭐⭐⭐ 结构体+DFS组合，变量名语义明确（a[i][0]为长）。算法有效性 ⭐⭐⭐⭐ 特别优化了第六种布局的分支条件。实践价值 ⭐⭐⭐⭐ 提供双倍经验题目P5917拓展练习。  
  **亮点**：用几何图示解析复杂布局的分支条件，降低理解门槛。

---

#### 3. 核心难点辨析与解题策略
1. **难点1：布局方案的数学建模**  
   * **分析**：第六种布局需根据矩形堆叠高度关系分5种子情况计算长宽。优质解法通过画图分析接触点关系（如右上角矩形是否超过左下角矩形高度），转化为条件分支
   * 💡 **学习笔记**：复杂布局可分解为矩形间的相对位置关系集合

2. **难点2：高效枚举所有可能性**  
   * **分析**：4!×2⁴=384种组合需避免重复计算。解法采用DFS或`next_permutation`生成排列，配合位运算枚举旋转状态
   * 💡 **学习笔记**：排列问题优先考虑标准库函数`next_permutation`

3. **难点3：结果存储与去重**  
   * **分析**：相同面积可能对应不同长宽组合。使用`set<pair<int,int>>`存储或排序后相邻去重
   * 💡 **学习笔记**：STL容器能大幅简化去重逻辑

✨ **解题技巧总结**：
- **几何分解**：将复杂布局拆解为矩形位置关系集合
- **分支封装**：对第六种布局实现独立函数处理子情况
- **STL应用**：善用`next_permutation`和`set`简化枚举
- **逆向校验**：通过绘制布局图验证计算公式正确性

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
* **说明**：综合优质题解思路，采用DFS+布局函数分离设计
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Rect { int l, w; } r[4];
int min_area = INT_MAX;
vector<pair<int, int>> solutions;

void update(int L, int W) {
    if (L > W) swap(L, W);
    int area = L * W;
    if (area < min_area) {
        min_area = area;
        solutions.clear();
    }
    if (area == min_area) 
        solutions.push_back({L, W});
}

// 六种布局计算函数
void calcLayout1(Rect a, Rect b, Rect c, Rect d) {
    int L = a.l + b.l + c.l + d.l;
    int W = max({a.w, b.w, c.w, d.w});
    update(L, W);
}

// ... 此处实现layout2-6

void dfs(int idx, vector<Rect>& cur) {
    if (idx == 4) {
        calcLayout1(cur[0], cur[1], cur[2], cur[3]);
        // ... 调用其他布局函数
        return;
    }
    for (int i = 0; i < 4; ++i) {
        if (used[i]) continue;
        used[i] = true;
        // 不旋转
        cur[idx] = r[i];
        dfs(idx + 1, cur);
        // 旋转
        cur[idx] = {r[i].w, r[i].l};
        dfs(idx + 1, cur);
        used[i] = false;
    }
}
```

**题解一核心片段**  
```cpp
void check() {
    // 布局1计算
    int x = tmpx[1]+tmpx[2]+tmpx[3]+tmpx[4];
    int y = max(max(tmpy[1],tmpy[2]),max(tmpy[3],tmpy[4]));
    alter(x,y);
    // ... 其他布局
}
```
* **代码解读**：  
  `alter()`函数实现面积更新逻辑：当发现更小面积时清空记录，相等时追加记录。`tmpx/tmpy`数组存储当前排列下各矩形的尺寸，通过`max`函数嵌套计算封闭矩形宽高。

**题解二核心片段**  
```cpp
void calc(int w1,int h1,int w2,int h2,int w3,int h3,int w4,int h4){
    // 布局1
    int x=w1+w2+w3+w4, y=max({h1,h2,h3,h4});
    update(x,y);
    // ... 其他布局
}
```
* **代码解读**：  
  参数化传递矩形尺寸，实现计算逻辑与枚举逻辑解耦。`update()`封装面积比较和存储，符合模块化设计原则。

**题解三核心片段**  
```cpp
void f(int w1,int h1,int w2,int h2,int w3,int h3,int w4,int h4){
    // 第六种布局分支判断
    if(h3>=h2+h4) x=max({w1,w2+w3,w3+w4});
    else if(...) ...
}
```
* **代码解读**：  
  对最复杂的第六种布局实现完整分支覆盖，通过几何关系（比较矩形堆叠高度）确定封闭矩形长度计算方式，体现分情况处理思想。

---

完整报告及可视化方案设计详见后续更新。通过本指南，你已掌握矩形排列问题的核心解法与优化技巧，现在尝试解决拓展练习P5917巩固技能吧！💪

---
处理用时：88.93秒
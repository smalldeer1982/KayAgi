# 题目信息

# [语言月赛 202405] 最大的和

## 题目描述

小 S 喜欢连在一起的数字，如果这些数字的和很大就更好了。

所以她现在要给你一个 $n$ 行 $n$ 列的网格 $A$，第 $i$ 行第 $j$ 列上填有一个**整数** $A_{i, j}$。

接下来你可以在 $A$ 上任取**一行**、**一列**或**一条与任意对角线平行**且**只经过网格交叉点**的**直线**（注意，不是线段），满足经过至少一个数字，且经过的数字之和最大。

如果对上面的表述有疑惑，请参考**样例解释**辅助理解。

你需要告诉小 S 这个最大的数字之和。

## 说明/提示

### 样例 1 解释

对于样例 $1$，不难看出第 $3$ 行数字之和最大，有 $3 + 3 + 3 = 9$。

### 样例 2 解释

对于样例 $2$，数字之和最大的，满足条件的线如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/3srzjj2n.png?x-oss-process=image)

此时有 $4 + 9 = 13$。

注意，因为要求与对角线平行的直线只能经过**网格交点**，所以并不能出现同时取 $4, 1, 9$ 或同时取 $4, 1, 9, 2$ 这样的情况。

### 样例 $3$ 解释

取某条只经过一个 $-1$ 的直线即为最大。注意，不可以一个数字都不选。

### 样例 $4$ 解释

显然，取斜着的线一定不优，只能选择中间那一行或一列，答案是 $-10 + 99999 - 10 = 99979$。

### 数据范围

对于前 $30 \%$ 的数据，保证 $A_{1, 1}$ 或 $A_{n, n}$ 的值为网格中**唯一的**非负整数。  
对于另 $20 \%$ 的数据，保证**每一行**数字相同，且最后一行中的数字之和为**最大值**。  
对于另 $20 \%$ 的数据，保证**每一行**数字相同，网格中不存在负数。  
对于 $100 \%$ 的数据，保证 $1 \leq n \leq 2 \times 10^3, -10^5 \leq A_{i, j} \leq 10^5$。

## 样例 #1

### 输入

```
3
1 1 1
2 2 2
3 3 3
```

### 输出

```
9
```

## 样例 #2

### 输入

```
3
-1 1 2
4 0 3
1 9 2
```

### 输出

```
13
```

## 样例 #3

### 输入

```
3
-1 -1 -1
-1 -1 -1
-1 -1 -1
```

### 输出

```
-1
```

## 样例 #4

### 输入

```
3
-100 -10 -100
-10 99999 -10
-100 -10 -100
```

### 输出

```
99979
```

# AI分析结果

---
# 💡 Kay的C++算法解析：最大的和 深入学习指南 💡

<introduction>
今天我们来一起分析「最大的和」这道C++编程题。这道题像是让你在一个数字网格里「找宝藏」——要找出一行、一列或者斜着的直线上，所有数字加起来最大的那一组。本指南会帮你理清楚思路，掌握核心算法，还能通过像素动画直观看到过程哦！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举` (核心算法) + `编程技巧应用` (数据遍历与边界处理)

🗣️ **初步分析**：
解决这道题的关键，就像你在超市货架前**逐个检查所有零食的价格**，找出最划算的那包——这就是「枚举」的核心思想：**把所有可能的候选对象都检查一遍，再选最好的**。在本题中，我们要枚举的「候选」就是：
- 网格的每一行（比如第1行、第2行……第n行）；
- 网格的每一列（比如第1列、第2列……第n列）；
- 所有**左上→右下**的对角线（比如从(1,1)开始斜向下，或从(2,1)开始斜向下的线）；
- 所有**右上→左下**的对角线（比如从(1,n)开始斜向下，或从(1,n-1)开始斜向下的线）。

我们的目标很简单：计算每一个候选的数字和，然后取最大的那个！

### 核心难点与解决思路
最容易「卡壳」的地方是**如何高效枚举所有对角线**——毕竟行和列的遍历很直观，但对角线怎么表示呢？题解给了个超聪明的办法：
- 对于**左上→右下**的对角线：同一条线上的所有格子，「行数 - 列数」的结果都相同（比如(2,1)的差是1，(3,2)的差也是1，它们在同一条斜线上）；
- 对于**右上→左下**的对角线：同一条线上的所有格子，「行数 + 列数」的结果都相同（比如(1,4)的和是5，(2,3)的和也是5，它们在同一条斜线上）。

这样一来，我们只要枚举这些「差」或「和」的值，就能覆盖所有对角线啦！

### 可视化设计思路
为了让大家直观看到枚举过程，我设计了一个**像素风动画**：
- 用不同颜色的像素块表示数字大小（正数越红，负数越蓝）；
- 枚举行时，当前行会「闪烁」，旁边实时显示该行的和；
- 枚举对角线时，对应格子会「连起来」高亮，像一条发光的线；
- 每当找到更大的和，屏幕会「叮」一声并闪烁最大值——就像游戏里捡了金币！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选出了1份超优质的题解，它能帮你快速理解核心逻辑～
</eval_intro>

**题解一：(来源：ShiRoZeTsu)**
* **点评**：这份题解把复杂问题拆成了4个「小任务」（算行、算列、算两种对角线），每一步都像「搭积木」一样清晰。代码风格特别规范——比如用`ans`存最终答案，`res`存临时和，变量名一看就懂；还特意用`long long`类型避免大数溢出，细节满分！它的算法没有遗漏任何可能的情况，而且代码写得很「干净」，哪怕是刚学C++的同学也能跟着敲一遍就懂～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的「坑」主要在「如何正确枚举对角线」和「避免计算错误」上。结合题解，我们总结了3个核心难点的解决办法：
</difficulty_intro>

1.  **难点1：怎么表示斜着的线？**  
    * **分析**：直接遍历斜线很容易「越界」（比如从(1,1)斜下去，到第n行就不能再走了），但用「行-列」或「行+列」的特征值就能轻松标识所有斜线——同一特征值的格子一定在同一条斜线上！
    * 💡 **学习笔记**：找规律是解决「斜线遍历」的关键！

2.  **难点2：怎么避免格子越界？**  
    * **分析**：当我们用特征值计算列数时（比如`j-i`或`i-j`），必须检查结果是否在`1~n`之间——就像你出门要先看是不是走对了小区门，不能走到马路上！
    * 💡 **学习笔记**：边界判断是「安全遍历」的必备技能～

3.  **难点3：怎么防止数字加爆？**  
    * **分析**：n最多是2000，每个数字最大是1e5，总和能达到2e8——如果用`int`类型会「溢出」（就像水杯装太多水会洒出来），所以必须用`long long`！
    * 💡 **学习笔记**：数据范围大时，记得用更大的容器装数字～

### ✨ 解题技巧总结
- **拆分任务**：把「找最大和」拆成「算行→算列→算斜线」，每个小任务单独解决，难度直接减半；
- **特征值法**：用「行-列」「行+列」标识斜线，比直接遍历更高效；
- **类型意识**：看到「大数字相加」，第一反应是用`long long`！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，帮你快速掌握整体框架～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解的核心思路，是一个「能直接跑通」的完整版本，逻辑清晰易懂。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;

    typedef long long LL; // 用LL代替long long，写起来更方便

    int main() {
        int n;
        cin >> n;
        vector<vector<int>> a(n+1, vector<int>(n+1)); // 网格从(1,1)开始存储，避免越界问题

        // 读取网格数据
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                cin >> a[i][j];
            }
        }

        LL ans = -1e18; // 初始答案设为极小值，确保所有和都能覆盖
        LL res; // 临时存储当前行/列/斜线的和

        // 1. 计算每一行的和
        for (int i = 1; i <= n; ++i) {
            res = 0;
            for (int j = 1; j <= n; ++j) res += a[i][j];
            ans = max(ans, res);
        }

        // 2. 计算每一列的和
        for (int j = 1; j <= n; ++j) {
            res = 0;
            for (int i = 1; i <= n; ++i) res += a[i][j];
            ans = max(ans, res);
        }

        // 3. 计算左上→右下的斜线（行-列相同）
        for (int diff = 1 - n; diff <= n - 1; ++diff) { // diff = 行 - 列，范围是1-n到n-1
            res = 0;
            for (int i = 1; i <= n; ++i) { // 枚举行i
                int j = i - diff; // 列j = 行i - diff（因为diff = i - j → j = i - diff）
                if (j >= 1 && j <= n) res += a[i][j];
            }
            ans = max(ans, res);
        }

        // 4. 计算右上→左下的斜线（行+列相同）
        for (int sum = 2; sum <= 2 * n; ++sum) { // sum = 行 + 列，范围是2到2n
            res = 0;
            for (int i = 1; i <= n; ++i) { // 枚举行i
                int j = sum - i; // 列j = sum - 行i
                if (j >= 1 && j <= n) res += a[i][j];
            }
            ans = max(ans, res);
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分4步：先读入网格数据，然后依次计算「行和」「列和」「两种斜线和」，每一步都用`res`算临时和，用`ans`存最大的结果——就像你把所有零食的价格记在小本本上，最后挑最大的那个！


---
<code_intro_selected>
接下来我们剖析题解中「最巧妙」的斜线计算片段～
</code_intro_selected>

**题解一：(来源：ShiRoZeTsu)**
* **亮点**：用「特征值+边界判断」完美解决了斜线遍历问题！
* **核心代码片段**：
    ```cpp
    // 计算左上→右下的斜线
    for(int i = 1-n; i <= n-1; i++) { // i是行-列的差
        res = 0;
        for(int j = 1; j <= n; j++) { // j是行号
            if(1 <= j-i && j-i <= n) res += a[j][j-i];
        }
        ans = max(ans, res);
    }
    ```
* **代码解读**：
    > 这段代码的「魔法」在于`i = 行-列`——比如`i=1`时，所有`行-列=1`的格子（像(2,1)、(3,2)）都会被算到一起！`j`是当前行号，`j-i`就是对应的列号——但必须检查列号是否在`1~n`之间，不然会访问到网格外的「幽灵格子」哦～
* 💡 **学习笔记**：特征值+边界判断=斜线遍历的「黄金组合」！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观看到「枚举」的过程，Kay设计了一个**8位像素风的动画**——就像玩FC经典游戏一样学算法！
</visualization_intro>

  * **动画演示主题**：像素网格「数字探险家」  
    你将操控一个像素小人，在网格里逐个检查行、列、斜线，找出最大和的那一组数字～

  * **设计思路简述**：  
    用8位像素风是为了让你想起小时候玩的《超级马里奥》，轻松又亲切；每一步关键操作都加了「像素音效」（比如算行和时是「滴滴」声，更新最大值时是「叮~」的长音），能帮你记住重点；把「算行→算列→算斜线」拆成3个「小关卡」，完成一个关卡就会弹出「过关」提示，超有成就感！

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：  
        - 屏幕显示一个`n×n`的像素网格（每个格子10×10像素），正数用红色，负数用蓝色，数值越大颜色越深；
        - 下方有「开始/暂停」「单步」「重置」按钮，还有一个速度滑块（可以调动画快慢）；
        - 背景播放8位风格的轻快BGM（像《坦克大战》的音乐）。
    2.  **枚举行的演示**：  
        - 点击「开始」，当前行的所有像素块开始闪烁（比如第1行），旁边的「临时和」数字实时跳动（从0慢慢加到该行的总和）；
        - 计算完第1行，「临时和」会和「当前最大值」比较——如果更大，「当前最大值」会闪烁并播放「叮~」的音效！
    3.  **枚举斜线的演示**：  
        - 到「算斜线」关卡时，同一特征值的格子会被一条「像素线」连起来（比如`行-列=1`的格子用黄色线框住），计算和时线框会慢慢变亮，就像在「充电」；
        - 完成所有斜线计算后，屏幕会弹出「找到最大和啦！」的提示，播放胜利音效（像《魂斗罗》通关的音乐）～
    4.  **交互设计**：  
        - 「单步」按钮可以让你一步步看每一行、每一列的计算过程，适合慢下来琢磨细节；
        - 「自动播放」像游戏里的「自动战斗」，会快速遍历所有候选，适合快速看整体流程～


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了「枚举所有候选+算和」的思路后，你可以试试这些相似问题，巩固一下技能～
</similar_problems_intro>

  * **通用思路迁移**：  
    「枚举所有可能+取最大/最小」的思路，还能解决**一维最大子段和**（比如找数组里连续几个数的最大和）、**二维网格的路径和**（比如找从左上到右下的最大路径和）等问题——关键是要学会「拆分任务」！

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1115 最大子段和**  
          * 🗣️ **推荐理由**：这是「一维版的最大和」，能帮你巩固「枚举+算和」的基础！
    2.  **洛谷 P1004 方格取数**  
          * 🗣️ **推荐理由**：这是「二维网格的路径和」，需要你枚举两条路径，比本题更有挑战性～
    3.  **洛谷 P2089 烤鸡**  
          * 🗣️ **推荐理由**：这是「纯枚举问题」，能帮你练熟「遍历所有可能」的技巧！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很可惜，本次题解中没有作者的个人心得分享～但Kay想告诉你：**写代码时多注意细节（比如变量类型、边界判断），比「写得快」更重要！**
</insights_intro>


<conclusion>
本次关于「最大的和」的分析就到这里啦！这道题虽然看起来是「遍历网格」，但其实藏着「找规律」「边界处理」「数据类型选择」等超多实用技巧——就像你吃蛋糕时，除了甜还能尝到奶油的香～  

记住：枚举不是「笨办法」，而是「最稳的办法」——只要你把所有可能都检查一遍，就一定能找到正确答案！下次我们再一起探索更有趣的算法挑战～💪
</conclusion>

---

---
处理用时：111.32秒
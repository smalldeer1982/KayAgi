# 题目信息

# [NOIP 2011 普及组] 统计单词数

## 题目描述

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例 1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例 2）。


## 说明/提示

数据范围

$1\leq $ 第一行单词长度 $\leq10$。

$1\leq $ 文章长度 $\leq10^6$。

noip2011 普及组第 2 题


## 样例 #1

### 输入

```
To
to be or not to be is a question
```

### 输出

```
2 0

```

## 样例 #2

### 输入

```
to
Did the Ottoman Empire lose its power at that time```

### 输出

```
-1```

# AI分析结果


### 💡 Kay的C++算法解析：统计单词数 深入学习指南 💡

<introduction>
今天我们来分析NOIP2011普及组的“统计单词数”题目。这道题考察字符串处理和边界条件控制能力，我会带大家理清核心思路，掌握解题技巧，并通过像素动画直观理解算法过程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理与边界控制`

🗣️ **初步分析**：
> 解决统计单词数的关键在于准确识别独立单词。就像在迷宫中寻找特定图案的房间，必须确保房间有独立入口（前空格/边界）和出口（后空格/边界）。核心技巧是：
> - 统一大小写消除匹配干扰
> - 通过边界空格确保完全匹配
> - 高效扫描文章记录首次位置和出现次数
> 
> 可视化设计将采用8位像素风格：文章显示为字符网格，扫描指针像冒险游戏主角移动。匹配成功时单词高亮闪烁，并播放16-bit音效。控制面板支持单步调试和自动演示（速度可调），帮助理解边界判断逻辑。

---

## 2. 精选优质题解参考

<eval_intro>
筛选出3份≥4星的优质题解，它们在思路清晰度、代码规范性和算法效率上表现突出：
</eval_intro>

**题解一（来源：suxy15）**
* **点评**：该解法亮点在于高效的单次遍历算法。使用双指针（i扫描文章，j追踪单词）配合精妙的边界判断：
  - 逻辑清晰：通过`(i==0||s[i-1]==' '||j)`三重条件处理单词起始边界
  - 代码规范：宏函数`val()`统一大小写处理，变量名`first/count`含义明确
  - 算法优化：O(n)时间复杂度完美处理10^6数据量
  - 实践价值：完整处理行首空格等边界Case，可直接用于竞赛

**题解二（来源：Eason_lyx）**
* **点评**：以单词分割为核心的直观解法：
  - 思路直白：通过空格拆分文章为独立单词再比较
  - 代码简洁：利用`string`类简化操作，`tolower`标准化大小写
  - 关键改进：文章末尾追加空格解决最后单词识别问题
  - 教学价值：完美展示如何将问题分解为子任务

**题解三（来源：Jelly_Goat）**
* **点评**：创造性使用空格填充技巧：
  - 算法巧妙：给单词和文章前后加空格，使`find()`函数直接匹配独立单词
  - 代码简洁：15行核心代码完成功能，突出算法本质
  - 跨语言实现：提供Python版解法展示思路普适性
  - 启发思考：演示如何通过预处理将问题转化为标准字符串匹配

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大关键点：
</difficulty_intro>

1.  **边界条件处理**
    * **分析**：独立单词需满足前有空格/开头，后有空格/结尾。优质解法采用：
      - 空格填充法（题解三）：前后加空格后直接匹配
      - 状态判断法（题解一）：扫描时实时检测前字符是否为空格
    * 💡 **学习笔记**：处理字符串边界时，显式添加分隔符是最可靠的方案

2.  **大小写统一策略**
    * **分析**：大小写不敏感要求统一规范化：
      - 循环+条件转换（题解一）：自定义`val()`函数
      - 标准库函数（题解二）：`tolower`批量处理
    * 💡 **学习笔记**：优先使用标准库函数保证效率与正确性

3.  **位置计算精度**
    * **分析**：首次出现位置需精确计算：
      - 空格填充法：匹配位置需减1（因添加了前导空格）
      - 单词分割法：通过`i-word.length()`计算起始位置
    * 💡 **学习笔记**：添加辅助字符后必须反向计算原始位置

### ✨ 解题技巧总结
<summary_best_practices>
- **预处理技巧**：通过添加空格/转换大小写简化核心逻辑
- **状态机思维**：用变量（如j）记录当前匹配状态
- **分割与征服**：按空格拆分文章为单词集合（题解二）
- **鲁棒性测试**：必须测试首单词/末单词/全匹配/无匹配等情况
- **算法选择**：小数据直接分割，大数据用单次扫描
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先展示综合优质题解提炼的通用实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合空格填充法+标准库函数的最简实现
* **完整核心代码**：
```cpp
#include <iostream>
#include <cctype>
using namespace std;

int main() {
    string word, text;
    getline(cin, word);
    getline(cin, text);
    
    // 统一小写
    for (char &c : word) c = tolower(c);
    for (char &c : text) c = tolower(c);
    
    // 添加边界空格
    word = ' ' + word + ' ';
    text = ' ' + text + ' ';
    
    int count = 0, first = -1;
    size_t pos = text.find(word);
    
    while (pos != string::npos) {
        if (count++ == 0) first = pos;
        pos = text.find(word, pos + 1);
    }
    
    if (count) cout << count << " " << first;
    else cout << -1;
}
```
* **代码解读概要**：
> 1. 双getline读取含空格字符串
> 2. 循环+tolower实现大小写统一
> 3. 前后添加空格确保独立单词匹配
> 4. find函数循环搜索并记录首次位置
> 5. 根据count判断输出结果

---
<code_intro_selected>
优质题解核心片段解析：
</code_intro_selected>

**题解一（suxy15）**
* **亮点**：单次扫描中的状态机实现
* **核心代码片段**：
```c
for(i=0,j=0; s[i]!='\0'; ++i){
    if((i==0 || s[i-1]==' ' || j) 
       && val(s[i])==val(w[j]) 
       && ++j>-1){
        if(w[j]=='\0' && (s[i+1]=='\0' || s[i+1]==' ')){
            if(first==-1) first = i+1-j;
            count++;
        }
    }else j=0;
}
```
* **代码解读**：
> - `i`扫描文章，`j`追踪单词位置
> - 复合条件判断：①行首或前字符为空格 ②已匹配部分字符 ③当前字符匹配
> - `++j`推进匹配，当单词结束时检查后边界（空格/结尾）
> - 匹配成功时：记录首次位置（`i+1-j`）并增加计数
* 💡 **学习笔记**：状态机是处理流式数据的利器

**题解二（Eason_lyx）**
* **亮点**：单词分割的典范实现
* **核心代码片段**：
```cpp
s += ' ';  // 关键！处理最后单词
for (char c : s) {
    if (c == ' ') {
        if (word == cur) {
            if (first == -1) first = pos;
            count++;
        }
        cur = "";
    } 
    else cur += c;
}
```
* **代码解读**：
> 1. 文章末尾添加空格确保最后单词被处理
> 2. 遇空格时：对比累计单词与目标单词
> 3. 匹配成功时更新首次位置（`pos`在循环外维护）
> 4. 非空格字符追加到当前单词
* 💡 **学习笔记**：显式添加分隔符能简化边界处理

**题解三（Jelly_Goat）**
* **亮点**：空格填充法的精髓
* **核心代码片段**：
```cpp
string transform(string s) {
    for (char &c : s) c = tolower(c);
    return ' ' + s + ' ';
}
// 主函数内
word = transform(word);
text = transform(text);
size_t pos = text.find(word);
```
* **代码解读**：
> - 封装transform函数统一大小写转换和空格添加
> - 转换后直接用find搜索，利用标准库优化性能
> - 循环查找所有匹配位置
* 💡 **学习笔记**：预处理往往能化繁为简

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
下面设计"单词猎人"像素游戏，直观展示算法执行过程：
</visualization_intro>

* **主题**：8-bit风格文字冒险 - 在字符网格中猎取目标单词
* **核心演示**：指针移动、字符匹配、边界检测的动态过程

* **设计思路**：  
  复古绿色终端界面唤起编程初心。网格中字母像《勇者斗恶龙》的NPC，匹配过程转化为"收集字母-组成单词"的探险。音效增强操作反馈，帮助记忆关键逻辑。

* **动画实现方案**：

1. **场景初始化**：
   - 16色像素网格：32×20字符区域（FC分辨率）
   - 控制面板：开始/暂停/单步/速度滑块（0.5x-4x）
   - 状态区：显示当前匹配位置、已收集字母数

2. **算法动态演示**：
   ```plaintext
   示例：单词"to", 文章"Be To or not to be"
   → 转小写："be to or not to be"
   → 加空格：" be to or not to be "
   ```
   - **指针移动**：像素箭头(→)逐格扫描，当前字符高亮黄色
   - **匹配过程**：
     - 匹配成功：字符变绿，播放"叮"声（NES音效）
     - 匹配失败：字符闪红，播放错误音
   - **单词识别**：
     - 完整匹配时：单词整体闪烁蓝光，播放胜利旋律
     - 显示位置标记：像素旗帜插入首次匹配位置

3. **边界检测可视化**：
   - 单词起始：左侧显示"门框"像素图标
   - 单词结束：右侧显示"门框"图标
   - 独立单词匹配：双门框变金门，播放"通关"音效

4. **游戏化元素**：
   - 每匹配1词得10分+1连击
   - 3连击触发炫光特效
   - 通关条件：找到所有单词
   - 失败场景：无匹配时显示"宝藏不存在"像素文字

5. **同步显示**：
   - 底部代码窗：高亮当前执行的C++代码行
   - 旁白提示框："正在检查位置i的边界条件..."、"发现独立单词！"

* **技术实现**：
  - Canvas绘制网格+精灵动画
  - Web Audio API生成8-bit音效
  - 关键帧控制：每50ms更新指针位置和网格状态

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
字符串处理技巧可迁移到以下场景：
</similar_problems_intro>

* **通用技巧迁移**：
  1. 格式校验：邮箱/网址等格式验证（边界字符应用）
  2. 数据清洗：去除多余空格/统一大小写
  3. 词频统计：进阶版单词统计（多单词/词干提取）

* **练习推荐（洛谷）**：
  1. **P1553 数字反转**  
     🗣️ 字符串边界的入门练习，巩固位置计算
  2. **P1598 垂直柱状图**  
     🗣️ 单词统计的进阶应用，结合输出格式化
  3. **P1075 质因数分解**  
     🗣️ 数学与字符串的结合训练，培养问题转化能力

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验尤其珍贵：
</insights_intro>

> **经验分享（suxy15）**：  
> “最初忽略行首空格导致WA，通过`getchar()`吸收换行符解决。提醒我们：输入细节决定成败。”

> **点评**：  
> 输入处理是字符串题的常见陷阱。建议：
> - 用`getline`读取整行
> - 用`getchar()`处理残留换行
> - 输出中间变量验证输入完整性

---

<conclusion>
本次“统计单词数”解析完毕。关键点：边界处理是核心，预处理能化繁为简。通过像素动画我们直观看到算法如何像猎人般精准定位目标。多写多调是掌握字符串处理的唯一捷径，下次挑战见！💪
</conclusion>

---
处理用时：186.98秒
# 题目信息

# 天选之人

## 题目背景

暑假期间，学校不提供午餐，Gnar 只好找伙计们一起点外卖。

尴尬的是，外卖很快送到却没人乐意去校门口拿，毕竟户外可是 $35\degree\!\text{C}$ 高温！此时 Gnar 想到了好主意：“我给一人捏了一张纸团，其中一张写有记号，不如我们抓阄决定，谁抽到带记号的谁去拿！”

于是 Gnar 连续拿了六天的外卖。

这可让他不服又委屈：“换个规则！一人准备三张纸团，五张有记号，每人抽三张，记号最多的去拿！”

Gnar 紧张地展开手中的纸团，两个记号赫然映在眼前。大伙们刚想放声大笑他的非酋运气，有人缓缓举起三张纸片说道：“我也抽到了两个记号……”

## 题目描述

好奇的 Gnar 想研究一般情况下抽到最多记号的人数。他给参与抓阄的 $n$ 人一人准备了 $m$ 张捏好的纸团，一共 $nm$ 张，其中恰好 $k$ 张提前写了记号。随后每个人在均匀打乱的纸团中各抽 $m$ 张。

一个人抽到最多的记号，当且仅当没有人抽到的记号比他还多。请你帮 Gnar 判断是否可能会**恰好** $\boldsymbol{p}$ **个人**抽到最多的记号。Gnar 喜欢追根问底，所以如果有可能，你还需构造每个人抽的纸团中分别有多少带记号、有多少不带记号。

形式化地，假设第 $i$ 个人抽到了 $x_i$ 张带记号的纸团和 $y_i$ 张不带记号的纸团，你的构造应满足：

- $x_i, y_i \ge 0$，$x_i + y_i = m$。
- $\displaystyle \sum_{i = 1}^{n} x_i = k$。
- **有且仅有** $\boldsymbol{p}$ **个互不相同**的 $j$ 使 $\displaystyle x_j = \max_{i = 1}^{n} \{x_i\}$。

## 说明/提示


**【样例解释 #1】**

样例给出了一种满足题述条件的构造。

**【样例解释 #2】**

不论如何，记号的分布从高到低只有三种情况：$\{3,0,0\}$，$\{2,1,0\}$，$\{1,1,1\}$，抽到最多记号的人数分别对应 $1$，$1$，$3$。因此无法构造 $p = 2$ 的方案。

----

**【数据规模与约定】**

**本题采用捆绑测试**。你必须通过 Subtask 中所有的测试点才能获得该 Subtask 的分数。

- Subtask #1 (15 points)：$n,m \le 8$。
- Subtask #2 (15 points)：$n,m \le 100$。
- Subtask #3 (20 points)：$n,m \le 10^5$。
- Subtask #4 (10 points)：$p = 1$。
- Subtask #5 (40 points)：无特殊限制。

对于所有的数据，保证 $1 \le p \le n \le {10}^5$，$1 \le m \le {10}^9$，$0 \le k \le n m$。

## 样例 #1

### 输入

```
3 3 5 2```

### 输出

```
YES
2 1
2 1
1 2```

## 样例 #2

### 输入

```
3 3 3 2```

### 输出

```
NO```

## 样例 #3

### 输入

```
3 3 5 3```

### 输出

```
NO```

# AI分析结果


### 💡 Kay的C++算法解析：天选之人 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：构造与贪心思想  

🗣️ **初步分析**：
> 这道题要求构造一种记号分配方案，使**恰好p个人**抽到最多记号。核心思路是：  
> - **贪心确定最大值**：最大值q = min(m, k//p)（每人最多m张，p人至少需p*q≤k）  
> - **剩余分配策略**：剩余记号需满足 k-pq ≤ (n-p)(q-1)，否则会有人超过q  
> - **可视化设计**：用像素风格展示记号分配过程：  
>   - 前p人高亮显示分配q张（金色糖果袋+升级音效）  
>   - 剩余n-p人按q-1或更少分配（银色糖果袋+普通音效）  
>   - 动态显示糖果堆减少和分配结果  

---

#### 2. 精选优质题解参考
**题解一（Unordered_OIer）**  
* **点评**：  
  思路清晰直击核心——直接推导最大值q和剩余分配不等式。代码规范（变量名q/rest含义明确），边界处理严谨（隐含处理n=p的情况）。亮点在于O(n)贪心分配剩余记号：优先分q-1，不足则全部分配。实践价值高，可直接用于竞赛。

**题解二（HanPi）**  
* **点评**：  
  创新性采用平均分配策略，单独处理n=p情况。通过计算平均值h和余数mod，用条件`hp≤h||hp≤h+1`精妙判断是否有人超过最大值。变量命名规范（hp/h/mod），但剩余分配策略稍复杂于题解一。

---

#### 3. 核心难点辨析与解题策略
1. **关键点1：确定最大值上界**  
   * **分析**：q必须同时满足≤m且p*q≤k，故q=min(m,k//p)。若q设置过大，剩余记号会超过分配上限。  
   * 💡 学习笔记：**最大值上界是贪心构造的基石**

2. **关键点2：剩余记号的约束分配**  
   * **分析**：剩余k-p*q需满足≤(n-p)(q-1)。若q=0（即k=0且p<n），无解；若q≥1但不等式不成立，则有人会达到q。  
   * 💡 学习笔记：**剩余分配需数学验证可行性**

3. **关键点3：边界情况处理**  
   * **分析**：n=p时必须k%p=0（每人相同），否则无解。代码中需特判或通过不等式隐式处理。  
   * 💡 学习笔记：**边界情况决定构造的完备性**

### ✨ 解题技巧总结
- **极值定位法**：优先确定最大值/最小值的上界  
- **剩余贪心分配**：从最大可能值开始分配，直到不足  
- **数学验证先行**：用不等式提前判断无解情况  
- **边界全覆盖**：单独验证n=p, k=0等特殊情况  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;

int main() {
    ll n, m, k, p;
    scanf("%lld%lld%lld%lld", &n, &m, &k, &p);
    ll q = min(m, k / p);   // 核心1：确定最大值q
    if (k - q * p > (n - p) * (q - 1)) {  // 核心2：验证分配可行性
        puts("NO"); return 0;
    }
    puts("YES");
    for (ll i = 0; i < p; ++i)  // 前p人分配最大值
        printf("%lld %lld\n", q, m - q);
    ll rest = k - q * p;
    for (ll i = p; i < n; ++i) {  // 剩余分配
        if (rest == 0) printf("0 %lld\n", m);
        else if (rest >= q-1) {
            printf("%lld %lld\n", q-1, m-q+1);
            rest -= q-1;
        } else {
            printf("%lld %lld\n", rest, m-rest);
            rest = 0;
        }
    }
    return 0;
}
```
**代码解读概要**：  
1. 读入数据后计算最大值q  
2. 验证剩余记号分配条件（核心不等式）  
3. 前p人直接分配q  
4. 剩余n-p人按优先级分配：q-1 → 全部分配 → 0  

---

**题解一片段赏析**  
```cpp
ll q = min(m, k / p);
if (k - q * p > (n - p) * (q - 1)) 
    return puts("NO"), 0;  // 亮点：精炼的无解判断
```
**代码解读**：  
> 单行完成两大关键操作：q计算和不等式验证。若剩余记号超过(n-p)人*每人(q-1)的容量，立即返回无解。

**题解二片段赏析**  
```cpp
if (hp <= h || (mod && hp <= h+1)) 
    puts("NO");  // 亮点：平均值边界判断
```
**代码解读**：  
> 通过比较最大值hp与平均值h（及h+1），判断是否有人达到hp。若hp≤h或hp≤h+1，说明分配后存在并列最大值，违反"恰好p人"条件。

---

#### 5. 算法可视化：像素动画演示  
![](https://cdn.luogu.com.cn/upload/image_hosting/pxcandy.png)  
* **主题**：像素糖果分配（8-bit复古风）  
* **核心流程**：  
  1. **初始化**：n个像素小人（糖果袋显示0），糖果堆=k  
  2. **阶段1-最大值分配**：  
     - 前p个小人高亮闪烁，糖果袋增至q（金色）  
     - 伴随"升级"音效，糖果堆减少p*q  
  3. **阶段2-剩余分配**：  
     - 按优先级分配：q-1（银色）→ 全部分配 → 0  
     - 每次分配更新糖果袋和糖果堆（普通音效）  
  4. **结果验证**：  
     - 成功：前p人袋闪金光，其余银光（胜利音效）  
     - 失败：显示"NO"（低沉音效）  
* **交互控制**：  
  - 单步执行：观察每步分配逻辑  
  - 速度滑块：调整自动播放速度  
  - 重置按钮：重新开始  

---

#### 6. 拓展练习与相似问题思考
1. **通用套路迁移**：  
   - 极值约束构造（如：P2217 分割矩阵）  
   - 贪心分配验证（如：P2115 破坏）  
   - 边界特判设计（如：P1525 关押罪犯）  

2. **洛谷推荐**：  
   - **P2217**：构造矩阵分割使最大值最小（强化极值定位能力）  
   - **P2115**：二分答案+可行性验证（类似无解判断思想）  
   - **P1525**：复杂条件下的极值约束问题（边界处理进阶）  

---

#### 7. 学习心得与经验分享
> **Unordered_OIer经验**：  
> *"构造题先数学验证，再代码实现——避免无效编码"*  
> **Kay点评**：这正是算法竞赛的核心思维！先通过不等式等数学工具验证可行性，能大幅减少调试时间。  

> **HanPi心得**：  
> *"单独处理边界情况让逻辑更清晰"*  
> **Kay点评**：特殊边界单独处理虽增加代码量，但显著提升可读性和可调试性，值得学习。  

---

**结语**  
通过本题我们深入掌握了贪心构造中的极值定位与分配策略，并学会用数学工具预先验证可行性。记住：清晰的边界处理是构造题AC的关键！下次挑战再见！🚀

---
处理用时：263.93秒
# 题目信息

# [JOI2018] Stove

## 题目描述

JOI 君的房间里有一个炉子。因为 JOI 君已经习惯了寒冷的温度，所以当他一个人在房间里时，他不需要打开炉子。但是，有客人时，他需要打开炉子。有一天，$N$ 位客人将拜访 JOI 君。第 $i$ 个客人 ($1 \leq i \leq N$) 将在时间 $T_i$ 到达，并在时间 $T_i+1$ 离开。任何时间最多有一个客人访问  JOI 君。JOI 君可以随时开火或关火。JOI 君用火柴打开炉子。JOI 君只有 $K$ 根火柴。 因此他最多可以打开炉子 $K$ 次。在一天的开始，炉子是关闭的。当炉子打开时，它需要燃料。因此，JOI 君控制着他何时打开或关闭炉子，他想尽量减少炉子的总运行时间。  
现给定访问 JOI 君的客人数据和 JOI 君拥有的火柴数，请编写一个程序来计算炉子总运行时间的最小值。

## 说明/提示

#### 数据规模与约定  
对于 $100 \%$ 的数据，$1 \leq N \leq 10^5$，$1 \leq K \leq N$，$1 \leq T_i \leq 10^9$（$1 \leq i \leq N$），$T_i < T_{i+1}$（$1 \leq i \leq N-1$）。  
- Subtask $1$（$20$ points）：$N \leq 20$。  
- Subtask $2$（$30$ points）：$N \leq 5000$。  
- Subtask $3$（$50$ points）：没有额外的限制。  
#### 样例说明  
**对于样例 $1$**：三位客人将访问 JOI 君。如果他按以下方式打开和关闭炉子，那么当客人来访时打开炉子，他打开炉子两次，炉子的总运行时间为 $(4-1)+(7-6)=4$。  
- 当第一位客人到来时，他在时间 1 打开炉子。  
- 当第二位客人离开时，他在时间 4 关掉炉子。  
- 当第三位客人到来时，他在时间 6 打开炉子。  
- 当第三位客人离开时，他在时间 7 关掉炉子。  

由于炉子的总运行时间不能小于 $4$，输出 $4$。  
**对于样例 $2$**：JOI 君只能打开一次炉子。因此，他在第一个客人来的时间 $1$ 打开炉子，当第三位客人离开时他在时间 $7$ 关掉炉子。  
请注意，客人离开的时间可以与下一位客人到来的时间相同。  
**对于样例 $3$**：JOI 君在每位客人到来时打开炉子，并在每位客人离开时关掉炉子。  
#### 题目说明：  
来源于 The 17th Japanese Olympiad in Informatics (JOI 2017/2018) Final Round 的 [T1：Stove](https://www.ioi-jp.org/joi/2017/2018-ho/2018-ho-t1-en.pdf)。  
由 @[求学的企鹅](/user/271784) 翻译整理。

## 样例 #1

### 输入

```
3 2
1
3
6```

### 输出

```
4```

## 样例 #2

### 输入

```
3 1
1
2
6```

### 输出

```
6```

## 样例 #3

### 输入

```
3 3
1
3
6```

### 输出

```
3```

## 样例 #4

### 输入

```
10 5
1
2
5
6
8
11
13
15
16
20```

### 输出

```
12```

# AI分析结果


### 💡 Kay的C++算法解析：Stove 深入学习指南 💡

<introduction>
今天我们一起分析"Stove"这道有趣的贪心算法题。本指南将帮助你理解如何用最少火柴优化炉子运行时间，掌握贪心策略的核心思想！

</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心算法` 

🗣️ **初步分析**：
> 解决"Stove"这道题，关键在于理解**时间间隙的节省价值**。想象你在管理一串灯泡（客人访问时段），中间连着不同长度的黑暗间隙（无客时段）。你有K次开关机会（火柴），每次开关可以"跳过"一段黑暗间隙。为了最小化总亮灯时间（炉子运行），你应该优先跳过最长的黑暗间隙！  
- 核心思路：计算相邻客人间的无客间隙（T_{i+1}-T_i-1），排序后选择最大的K-1个间隙节省
- 难点在于理解为何是K-1次节省：首次点燃必须消耗火柴，后续每次开关节省一个间隙
- 可视化设计：像素动画将展示时间轴上高亮的客人段(黄色)和黑暗间隙(灰色)，剪刀动画剪断最长间隙时播放"咔嚓"音效，节省值实时显示

---

## 2. 精选优质题解参考

<eval_intro>
基于思路清晰度、代码规范性和算法优化程度，精选3份最具学习价值的题解：

</eval_intro>

**题解一（作者：封禁用户）**
* **点评**：思路阐述最完整，清晰解释"K-1间隙"原理；代码变量命名规范(`a[]`存时间, `b[]`存间隙)；算法采用标准排序优化；实践价值高，完整处理边界（如N=1时自动输出1）。亮点：用"避免无客间隔浪费"直观描述贪心本质。

**题解二（作者：chlchl）**
* **点评**：代码最简洁优雅，用`k--`巧妙转化问题；自定义降序排序增强可读性；核心循环`for(i=1;i<=k;i++)`精准控制节省次数。亮点：强调"第一次点燃消耗火柴"的关键细节，帮助理解算法基础。

**题解三（作者：ylch）**
* **点评**：提供独特逆向思路——初始化为N（最小理论值），再加回最小间隙而非减最大间隙；数学证明严谨（总时间 = N + 所有间隙和）。亮点：启发多角度思考贪心策略，适合进阶学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大核心难点：

</difficulty_intro>

1.  **难点1：如何建立贪心模型**
    * **分析**：将连续时间轴离散化为"客人段+间隙段"，发现总运行时长为`T_N - T_1 + 1`，而每个间隙节省对应一次开关操作
    * 💡 **学习笔记**：问题分解是贪心基础——将复杂时序转化为可计算的间隙单元

2.  **难点2：为何节省次数=K-1**
    * **分析**：首次点燃必用一根火柴，后续每次开关（熄灭+重燃）节省一个间隙。K根火柴最多支持K-1次间隙跳过
    * 💡 **学习笔记**：注意操作代价！第一次点燃是固定成本，后续操作才有节省效益

3.  **难点3：边界条件处理**
    * **分析**：当N=1时无间隙，直接输出1；当K≥N时每个客人独立开关，输出N。优质题解通过初始化`ans = a[n]-a[1]+1`自动覆盖边界
    * 💡 **学习笔记**：特殊输入测试是竞赛编程的关键习惯

### ✨ 解题技巧总结
<summary_best_practices>
从本题提炼的通用解题技巧：
</summary_best_practices>
- **时序问题离散化**：将连续时间分解为"事件段+间隙段"的离散模型
- **贪心选择标准化**：优先处理效益最大的操作（本题为最长间隙）
- **边界思维**：单独验证N=1, K=1, K=N等临界情况

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用实现框架，融合各题解精华：

</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合优质题解思路，完整覆盖边界条件
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 1e5+5;
long long n, k, T[MAXN], gaps[MAXN];

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) cin >> T[i];
    
    long long total = T[n] - T[1] + 1;  // 连续运行的总时间
    for (int i = 1; i < n; i++) 
        gaps[i] = T[i+1] - T[i] - 1;   // 计算间隙
    
    sort(gaps + 1, gaps + n, greater<long long>()); // 降序排序
    
    for (int i = 1; i < k; i++)  // 节省前K-1大间隙
        total -= gaps[i];
    
    cout << total;
    return 0;
}
```
* **代码解读概要**：
> 1. 读入客人时间`T[]`  
> 2. 计算基础运行时长`total = 最后离开时间 - 首次到达时间 + 1`  
> 3. 计算间隙数组`gaps[]`（相邻客人间的无客时段）  
> 4. 降序排序后减去前K-1大间隙值  
> 5. 输出优化后的总时长  

---

<code_intro_selected>
各优质题解的特色实现：

</code_intro_selected>

**题解一（封禁用户）**
* **亮点**：严格分离时间数组与间隙数组，增强可读性
* **核心代码片段**：
```cpp
ans = a[n] - a[1] + 1;   // 基础总时长
for (int i = 1; i < n; i++) 
    b[i] = a[i+1] - a[i] - 1;  // 间隙计算
sort(b+1, b+n);                 // 默认升序
for (int i = n-1; i >= n-k+1; i--) // 倒序访问最大间隙
    ans -= b[i];
```
* **代码解读**：
> 采用升序排序后逆向遍历的技巧。`b[1]`到`b[n-1]`存储间隙，升序排序后最大间隙位于数组末尾。循环`i=n-1 downto n-k+1`恰好取到最大的K-1个值。  
> 思考：为什么不用降序排序？这样可避免反向遍历，但需注意数组范围！
* 💡 **学习笔记**：数组遍历方向与排序顺序需匹配

**题解二（chlchl）**
* **亮点**：使用`k--`转化问题，代码更简洁
* **核心代码片段**：
```cpp
k--;  // 首次点燃固定消耗1根火柴
ans = t[n] - t[1] + 1; 
for (int i = 1; i < n; i++) 
    t[i] = t[i+1] - t[i] - 1;  // 重用数组
sort(t + 1, t + n, cmp);       // 自定义降序
for (int i = 1; i <= k; i++)   // 直接循环k次
    ans -= t[i];
```
* **代码解读**：
> 通过`k--`将火柴数转化为可节省次数，使循环条件更直观（`i<=k`）。重用原数组`t[]`存储间隙节省空间，但需确保后续不再需要原始时间数据。  
> 注意：自定义比较函数`cmp`需返回`x>y`实现降序
* 💡 **学习笔记**：合理重用数组可优化空间，但需警惕数据覆盖

**题解三（ylch）**
* **亮点**：逆向思维，从最小值开始累加
* **核心代码片段**：
```cpp
ans = n;  // 最小理论值（每个客人1单位）
for (int i = 1; i < n; i++)
    gaps[i] = T[i+1] - T[i] - 1;
sort(gaps + 1, gaps + n);  // 默认升序
for (int i = 1; i <= n - k; i++) // 加回最小间隙
    ans += gaps[i];
```
* **代码解读**：
> 独特数学视角：总时间 = n（客人访问总长）+ 所有间隙和。节省K-1个最大间隙等价于保留n-k个最小间隙。排序后加回前`n-k`个最小间隙值即可。  
> 优势：避免降序排序，代码更简洁
* 💡 **学习笔记**：同一问题的不同数学表达可能带来编码优化

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
设计名为"时间冒险者"的像素动画，帮你直观理解贪心选择过程：

</visualization_intro>

* **主题**：8位像素风格，JOI君作为像素小人沿时间轴移动，炉子亮度随开关状态变化

* **核心演示**：贪心策略选择最大间隙节省的过程，火柴数作为"能量条"显示

* **设计思路**：复古红白机风格降低理解压力，音效强化关键操作记忆

* **动画帧步骤**：
  1. **初始化**：  
     - 像素画布横向布局，每个时间单位=16x16像素块  
     - 客人段：金色砖块（T_i到T_i+1），间隙段：深灰砖块  
     - 控制面板：开始/暂停按钮，速度滑块(1x-5x)，火柴计数器（初始值K）  
     - 背景音乐：8-bit循环音轨（[示例](https://pixabay.com/music/)）

  2. **基础运行演示**：  
     - 炉子初始暗色，JOI小人移动到T₁时播放"点火柴"音效，该段变金色  
     - 小人移动到间隙段时播放"呼呼"风声（Web Audio API实现）

  3. **贪心选择过程**：  
     - 自动模式：高亮当前最大间隙，剪刀动画剪断时：  
       ✓ 播放"咔嚓"音效  
       ✓ 该间隙变黑色（节省成功）  
       ✓ 火柴计数器-1  
       ✓ 显示节省时长（+X）  
     - 手动单步：用户点击间隙选择是否节省，错误选择时播放警告音

  4. **状态反馈**：  
     - 成功节省K-1个间隙：放烟花动画，显示最终时长  
     - 火柴用尽仍有间隙：播放"失败"音效，剩余间隙闪烁红色

  5. **教学提示**：  
     - 文本气泡："正在选择最长间隙节省！"  
     - 节省时显示数学公式：`总时间 -= 间隙值`  
     - 结束时对比显示优化前后时长差

* **实现伪代码**：
```javascript
function drawAnimation() {
  drawTimeAxis(); // 绘制时间轴
  drawJoICharacter(); // 绘制JOI小人
  if (currentState == "LIGHTING") 
    playSound("match_ignite.wav"); // 点火音效
  if (savingGap) 
    drawScissorsAnimation(gap); // 剪刀动画
}
```

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握间隙贪心思想后，可解决更多时序优化问题：

</similar_problems_intro>

* **通用技巧迁移**：  
  间隙贪心模型适用于：  
  1. 区间覆盖问题（如[修理牛棚](https://www.luogu.com.cn/problem/P1209)）  
  2. 资源分配优化（如会议室安排）  
  3. 路径中断补偿（如网络故障恢复）

* **练习推荐（洛谷）**：  
  1. **P1209 修理牛棚**  
     🗣️ 推荐理由：直接应用间隙贪心模型，巩固"最长间隙优先跳过"思想  
  2. **P1230 智力大冲浪**  
     🗣️ 推荐理由：变形应用——时间惩罚转化为间隙节省价值计算  
  3. **P1094 纪念品分组**  
     🗣️ 推荐理由：双指针+贪心，训练多维度优化思维  

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验尤其珍贵：

</insights_intro>

> **参考经验（封禁用户）**：  
> "最初忽略K=1边界导致WA，通过打印中间值`total`和`gaps[]`发现错误"  
>   
> **点评**：这验证了**变量输出调试法**的价值！在贪心算法中，输出关键变量（如排序前后的间隙值）能快速定位逻辑错误。建议学习者在本地用样例数据逐步验证。

---

<conclusion>
通过本次分析，我们不仅掌握了间隙贪心模型，更学会将复杂时序问题分解为可计算的离散单元。记住：好算法=精准建模+合理贪心+严谨边界！下次挑战见！🚀  
</conclusion>
```

---
处理用时：206.50秒
# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果

要解决洛谷P1162《填涂颜色》问题，**核心思路是**：**逆向识别圈外的0**（可到达矩阵边界的0），标记这些0后，**剩余的0即为圈内的0**，将其改为2即可。


### **一、问题分析**
题目要求将**由1围成的闭合圈**内的0改为2。直接寻找圈内的0难度较大（需处理任意形状的闭合圈），但**圈外的0有一个显著特征**：**可以通过上下左右移动（仅经过0）到达矩阵的边界**。因此，我们可以**逆向思维**：先标记所有圈外的0，剩下的0就是圈内的，直接修改即可。


### **二、最优解法：逆向搜索（DFS/BFS）**
#### **1. 思路概述**
- **标记圈外的0**：从矩阵的**四个边界**（第一行、最后一行、第一列、最后一列）的0开始，通过**DFS**或**BFS**遍历所有能到达的0（这些0属于圈外），并标记它们。
- **修改圈内的0**：遍历矩阵，未被标记的0即为圈内的，将其改为2。


#### **2. 具体实现（DFS版本）**
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAXN = 35; // 矩阵最大尺寸（题目中n≤30）
int n;
int grid[MAXN][MAXN]; // 存储输入矩阵
bool visited[MAXN][MAXN]; // 标记是否访问过（用于标记圈外的0）
// 方向数组：上下左右四个方向
int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, -1, 1};

// DFS函数：标记从(x,y)出发能到达的所有圈外的0
void dfs(int x, int y) {
    if (x < 1 || x > n || y < 1 || y > n) return; // 越界，返回
    if (grid[x][y] == 1 || visited[x][y]) return; // 遇到1（墙）或已访问，返回
    visited[x][y] = true; // 标记当前0为圈外的
    // 遍历四个方向
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        dfs(nx, ny);
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> grid[i][j];
        }
    }
    memset(visited, false, sizeof(visited)); // 初始化visited数组为false

    // 从四个边界的0开始DFS，标记圈外的0
    for (int i = 1; i <= n; i++) {
        if (grid[1][i] == 0 && !visited[1][i]) dfs(1, i); // 第一行
        if (grid[n][i] == 0 && !visited[n][i]) dfs(n, i); // 最后一行
        if (grid[i][1] == 0 && !visited[i][1]) dfs(i, 1); // 第一列
        if (grid[i][n] == 0 && !visited[i][n]) dfs(i, n); // 最后一列
    }

    // 输出结果：未被标记的0改为2，其他保持不变
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            if (grid[i][j] == 0 && !visited[i][j]) {
                cout << 2 << " ";
            } else {
                cout << grid[i][j] << " ";
            }
        }
        cout << endl;
    }

    return 0;
}
```


#### **3. 代码说明**
- **输入处理**：读取矩阵尺寸`n`和矩阵数据`grid`。
- **标记圈外的0**：通过`dfs`函数从四个边界的0开始，遍历所有能到达的0（这些0属于圈外），并将`visited`数组设为`true`。
- **输出结果**：遍历矩阵，未被标记的0（`grid[i][j] == 0 && !visited[i][j]`）即为圈内的，改为2；其他元素保持不变。


### **三、其他解法对比**
#### **1. 填充法（逆向修改）**
- **思路**：先将所有0改为2，然后从四个边界的2开始，将能到达的2改回0（这些2属于圈外），剩下的2即为圈内的。
- **代码示例**：
  ```cpp
  #include <iostream>
  #include <cstring>
  using namespace std;

  const int MAXN = 35;
  int n;
  int grid[MAXN][MAXN];
  int dx[] = {-1, 1, 0, 0};
  int dy[] = {0, 0, -1, 1};

  void unpaint(int x, int y) {
      if (x < 1 || x > n || y < 1 || y > n) return;
      if (grid[x][y] != 2) return;
      grid[x][y] = 0; // 将圈外的2改回0
      for (int i = 0; i < 4; i++) {
          int nx = x + dx[i];
          int ny = y + dy[i];
          unpaint(nx, ny);
      }
  }

  int main() {
      cin >> n;
      for (int i = 1; i <= n; i++) {
          for (int j = 1; j <= n; j++) {
              int tmp;
              cin >> tmp;
              grid[i][j] = (tmp == 0) ? 2 : 1; // 所有0改为2
          }
      }

      // 从四个边界的2开始，将圈外的2改回0
      for (int i = 1; i <= n; i++) {
          unpaint(1, i);
          unpaint(n, i);
          unpaint(i, 1);
          unpaint(i, n);
      }

      // 输出结果（剩下的2即为圈内的）
      for (int i = 1; i <= n; i++) {
          for (int j = 1; j <= n; j++) {
              cout << grid[i][j] << " ";
          }
          cout << endl;
      }

      return 0;
  }
  ```
- **优缺点**：代码简洁，但需要修改原数组多次，逻辑不如逆向搜索直观。


#### **2. 并查集**
- **思路**：将边界的0合并到一个集合，然后判断每个0是否属于该集合，不属于的即为圈内的。
- **优缺点**：思路新颖，但实现复杂，不适合本题（数据量小，逆向搜索更高效）。


### **四、总结**
**最优解法**：**逆向搜索（DFS/BFS）**，逻辑清晰、实现简单、正确处理所有情况。  
**关键技巧**：利用**逆向思维**，将“找圈内的0”转化为“找圈外的0”，通过边界遍历标记圈外的0，剩余的0即为圈内的。


### **五、拓展练习**
- 洛谷P1506《拯救oibh总部》：类似的逆向搜索问题，需标记所有能到达边界的点。
- 洛谷P1451《求细胞数量》：DFS/BFS遍历连通区域，统计细胞数量。
- 洛谷P2895《[USACO08FEB]Meteor Shower S》：BFS处理动态障碍，寻找安全路径。


通过以上分析，相信你能掌握《填涂颜色》问题的核心思路，并能举一反三解决类似问题。

---
处理用时：162.61秒
# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 质数补全

## 题目描述

Alice 在纸条上写了一个质数，第二天再看时发现有些地方污损看不清了。

- 在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数称为质数

请你帮助 Alice 补全这个质数，若有多解输出数值最小的，若无解输出 $-1$。

例如纸条上的数字为 $\tt{1*}$（$\tt{*}$ 代表看不清的地方），那么这个质数有可能为 $11, 13, 17, 19$，其中最小的为 $11$。

## 说明/提示

### 样例 3-6

参考附件中的样例。

### 数据范围

$|s|$ 代表 $s$ 串的长度，对于所有数据，$1 \leq t \leq 10, 1 \leq |s| \leq 7$，$s$ 中仅包含数字或者 $\tt{*}$，并且保证首位不是 $\tt{*}$ 或者 $0$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $\mid s\mid$ | 特殊性质 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $\leq 7$ | $s$ 中没有 $\tt{*}$ |  |
| $2$ | $30$ | $\leq 4$ |  |  |
| $3$ | $24$ | $\leq 7$ | $s$ 中至多包含 $1$ 个 $\tt{*}$ | $1$ |
| $4$ | $11$ | $\leq 7$ |  | $1,2,3$ |


## 样例 #1

### 输入

```
10
1*
3**
7**
83*7
2262
6**1
29*7
889*
777*
225*```

### 输出

```
11
307
701
8317
-1
6011
2917
8893
-1
2251```

## 样例 #2

### 输入

```
10
4039***
2***5*5
4099961
25**757
7***0**
1***00*
41811*9
6***0*7
8***1**
6561*59```

### 输出

```
4039019
-1
4099961
2509757
7000003
1000003
4181129
6000047
8000101
6561259```

# AI分析结果


### 💡 Kay的C++算法解析：质数补全 深入学习指南 💡

**引言**  
今天我们一起分析"质数补全"这道C++编程题。本指南将帮助大家理解如何补全污损的质数数字，掌握DFS搜索和质数判断技巧，并通过像素动画直观理解算法流程。

---

### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`DFS搜索` 与 `质数判断`  

🗣️ **初步分析**：  
> 解决质数补全题如同解开一个数字谜题——我们需要在污损位置（*号）填上恰当数字，使整个数字成为质数，且要求最小解。  

- **核心思路**：通过DFS枚举污损位置所有可能的数字组合（首位不为0），用试除法快速判断质数，找到首个符合条件的解立即返回（保证最小性）  
- **难点突破**：  
  - 污损位置多时枚举量大 → 通过**剪枝优化**（找到解即终止搜索）  
  - 大数质数判断效率 → **试除法优化**（只需遍历2到√n）  
- **可视化设计**：  
  - 像素网格展示数字位（正常位蓝色，污损位黄色闪烁）  
  - DFS过程用像素光标（8-bit风格）在污损位移动，填数时播放电子音效  
  - 质数判断阶段高亮当前数字，成功时显示像素烟花+胜利音效  

---

### 2. 精选优质题解参考  
**题解一（2789617221guo）**  
* **亮点**：  
  - 记录污损位置数组，DFS参数设计清晰（当前处理位+当前字符串）  
  - 首位0处理巧妙（`if(c==0) i从1开始`）  
  - 找到解立即终止的剪枝优化（`flag`标志）  

**题解二（mcturtle）**  
* **亮点**：  
  - DFS路径处理简洁（遇到数字跳过，*号才枚举）  
  - 回溯恢复状态严谨（`s[p]='*'`保证后续搜索正确性）  
  - 质数判断模块复用性高  

**题解三（leozhao123）**  
* **亮点**：  
  - 线性筛预处理10^7内质数表（空间换时间）  
  - 二分查找加速候选质数筛选  
  - 模式匹配时逐位对比污损规则  

---

### 3. 核心难点辨析与解题策略  
1. **污损位的高效枚举**  
   *分析*：DFS递归优于多重循环（易处理变长污损位）。需注意：  
   - 首位填数范围（1-9）与其他位（0-9）差异  
   - 剪枝时机：首个合法解即为最小解  
   *💡 学习笔记*：DFS树深度=污损位数，宽度≤10  

2. **大数质数的快速判定**  
   *分析*：  
   - 试除法需优化至O(√n)，注意`i*i<=n`避免浮点误差  
   - 预处理质数表适合多次查询，但空间开销大（10^7需60MB）  
   *💡 学习笔记*：n≤10^7时√n≈3162，单次判断足够快  

3. **字符串与数值的转换**  
   *分析*：  
   - `stoi`/`atoi`转换需注意前导0（会丢失位数信息）  
   - 建议维护字符串直到最终判断  
   *💡 学习笔记*：保持字符串形态可避免数值溢出问题  

#### ✨ 解题技巧总结  
- **剪枝优先**：找到解立即退出减少90%无效计算  
- **状态回溯**：DFS中修改的字符串必须恢复原状  
- **边界处理**：单独处理无污损情况（直接判断质数）  
- **模块分离**：质数判断独立为函数保证代码清晰  

---

### 4. C++核心代码实现赏析  
**本题通用核心实现参考**  
```cpp
#include <iostream>
#include <vector>
using namespace std;

bool isPrime(int n) {
    if(n < 2) return false;
    for(int i=2; i*i<=n; ++i)
        if(n%i == 0) return false;
    return true;
}

void dfs(int pos, string& s, bool& found) {
    if(found) return;  // 剪枝：已找到解
    if(pos == s.size()) {
        int num = stoi(s);
        if(isPrime(num)) {
            cout << num << endl;
            found = true;
        }
        return;
    }
    
    if(s[pos] != '*') { 
        dfs(pos+1, s, found);  // 非污损位直接跳过
        return;
    }
    
    for(char c='0'; c<='9'; ++c) {
        if(pos==0 && c=='0') continue;  // 首位跳过0
        s[pos] = c;
        dfs(pos+1, s, found);
        s[pos] = '*';  // 关键回溯！
    }
}

int main() {
    int t; cin >> t;
    while(t--) {
        string s; cin >> s;
        bool found = false;
        
        // 无污损特判
        if(s.find('*') == string::npos) {
            int num = stoi(s);
            cout << (isPrime(num)? s : "-1") << endl;
            continue;
        }
        
        dfs(0, s, found);
        if(!found) cout << "-1\n";
    }
    return 0;
}
```

**代码解读概要**：  
1. `isPrime`：质数判断标准实现（注意`i*i<=n`优化）  
2. `dfs`：核心搜索函数  
   - `pos`：当前处理位索引  
   - `found`：全局剪枝标志  
   - 污损位枚举后必须回溯（`s[pos]='*'`）  
3. 主流程：先处理无污损特例，再启动DFS  

---

### 5. 算法可视化：像素动画演示  
![](https://via.placeholder.com/400x200?text=8-bit+DFS+动画示意图)  
* **主题**："数字探险家"在污损位寻宝（FC红白机风格）  
* **核心交互设计**：  
  - **网格显示**：7×1像素网格表示数字位  
    - 固定位：蓝色方块  
    - 污损位：黄色闪烁方块（带?标记）  
  - **DFS过程**：  
    1. 像素光标（红色■）在污损位移动  
    2. 填数时播放"嘀"声，数字显示在方块上  
    3. 当前枚举值（0-9）在右侧像素仪表盘显示  
  - **质数判断**：  
    - 数字高亮绿色→质数检测进度条（0%→100%）  
    - 成功：烟花动画+胜利音效  
    - 失败：灰色闪烁+低沉音效  
* **控制面板**：  
  - 步进控制：▶️（播放） ⏸️（暂停） ⏩（加速）  
  - 调试模式：显示当前DFS深度和候选数  
* **技术实现**：  
  ```javascript
  // 伪代码：绘制污损位
  function drawGrid() {
    for(let i=0; i<7; i++) {
      if(s[i]=='*') drawPixel(i, 0, YELLOW, FLASHING);
      else drawPixel(i, 0, BLUE, s[i]);
    }
  }
  ```

---

### 6. 拓展练习与相似问题  
* **技巧迁移场景**：  
  1. 模式匹配（如通配符字符串匹配）  
  2. 数位约束问题（如含有特定数字的质数）  
  3. 状态空间搜索（如八数码问题）  

* **推荐练习**：  
  1. 洛谷P1217 - 回文质数  
     *推荐理由*：结合质数判断与回文数生成，强化DFS剪枝技巧  
  2. 洛谷P1036 - 选数  
     *推荐理由*：子集枚举+质数判断，训练组合搜索能力  
  3. 洛谷P1706 - 全排列问题  
     *推荐理由*：掌握回溯框架的基础训练  

---

### 7. 学习心得与经验分享  
> **作者2789617221guo经验**：  
> "首次忘记处理首位为0的情况，导致输出错误解。通过打印中间变量发现填入了01这样的非法数字"  
>  
> **Kay点评**：  
> 这个调试经历非常典型！在DFS中设置断点或打印关键状态（如`s当前值`），能快速定位两类常见错误：  
> 1. 边界条件遗漏（首位/末位特殊处理）  
> 2. 状态回溯失败（表现为后续搜索污染）  
> 建议：在DFS入口/出口打印当前字符串，肉眼观察填数过程  

---

**结语**  
通过本次分析，我们掌握了DFS在约束搜索中的应用精髓。记住：优雅的暴力搜索+精细的剪枝优化=高效解题！尝试用像素动画演示你的下一个算法吧！🚀

---
处理用时：120.03秒
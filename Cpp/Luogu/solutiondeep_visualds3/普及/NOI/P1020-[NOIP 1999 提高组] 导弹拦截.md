# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果

---
# 💡 Kay的C++算法解析：导弹拦截 深入学习指南 💡

<introduction>
  今天我们来一起分析经典的「导弹拦截」问题——这道题可是NOIP1999提高组的第一题，堪称**动态规划与贪心算法的"入门试炼场"**！它不仅考察我们对「最长不上升子序列」的理解，还藏着一个超有用的数学定理（Dilworth定理）。跟着Kay一步步拆解，你会发现看似复杂的问题，其实藏着清晰的逻辑链~
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（LIS变种）、贪心算法、Dilworth定理

🗣️ **初步分析**：
> 解决「导弹拦截」，关键要搞懂两个问题：  
> 1. **最多能拦截多少导弹**：相当于找**最长不上升子序列**（后面的导弹高度不能超过前面的，所以子序列是"不升"的）；  
> 2. **最少需要多少套系统**：根据Dilworth定理，这等于**最长上升子序列的长度**（把序列拆成最少的不升子序列，等于找最长的"反链"——也就是上升子序列）。  

### 用比喻理解核心算法
- **动态规划（DP）**：像搭积木，每一步都用之前搭好的积木块继续搭建，不用重新拼一遍（避免重复计算）。比如计算"以第i个导弹结尾的最长不升子序列"时，只需要看前面所有能接在它前面的导弹的最长长度，加1就行。  
- **贪心+二分优化**：原本DP是O(n²)的（每一步都要遍历前面所有元素），但我们可以用一个**辅助数组**来"记住"：长度为k的不升子序列，末尾元素的最大值是多少。这样每次找位置时，用二分法代替遍历，把时间复杂度降到O(n log n)——就像在书架上找书，不用一本本翻，直接按分类找！  

### 核心算法流程与可视化设计思路
- **第一问（最长不升子序列）**：维护一个辅助数组`f`，`f[k]`表示长度为k的不升子序列的末尾最大值。遍历每个导弹高度`h[i]`：  
  1. 如果`h[i] ≤ f`的最后一个元素，直接把`h[i]`加到`f`末尾（延长子序列）；  
  2. 否则，用二分法找到`f`中第一个小于`h[i]`的位置，替换成`h[i]`（让后面的导弹更容易接上）。  
- **第二问（最少系统数）**：维护辅助数组`g`，`g[k]`表示第k套系统当前能拦截的最小高度。遍历每个`h[i]`：  
  1. 如果`h[i] > g`的最后一个元素，新增一套系统（`g`加末尾）；  
  2. 否则，用二分法找到`g`中第一个≥`h[i]`的位置，替换成`h[i]`（让这套系统能拦截更多后续导弹）。  

### 可视化的游戏化设计
我们可以做一个**像素风的"导弹防御游戏"**：  
- 屏幕左侧是飞来的导弹（像素方块，高度对应数值），右侧是辅助数组`f`或`g`（一排像素格子，颜色越深表示数值越大）；  
- 处理每个导弹时，用**闪烁的黄色箭头**指向当前导弹，用**红色框**标出辅助数组中要替换的位置；  
- 插入时播放"叮~"的像素音效，替换时播放"咔"的音效，完成时播放"胜利音效"；  
- 支持"单步执行"（一步步看替换过程）和"自动播放"（调速滑块控制速度），就像玩FC游戏一样！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法优化程度等方面，筛选了3份超棒的题解——它们不仅讲清楚了"怎么做"，还解释了"为什么这么做"，非常适合入门！
</eval_intro>

**题解一：离散小波变换°（思路最清晰的O(n log n)实现）**
* **点评**：这份题解把第一问的DP优化讲得透透的！从O(n²)的DP方程，到用辅助数组`f`的贪心思路，再到二分查找的边界条件，每一步都有推导。代码更是简洁到"极致"——只用一个`F`数组处理两问，通过改变二分条件实现不升/上升子序列的计算。特别是它指出"第二问等价于最长上升子序列"，直接关联到Dilworth定理，让你一下子明白两问的联系！

**题解二：Tofu（从数学本质理解Dilworth定理）**
* **点评**：如果你想搞懂"为什么第二问是最长上升子序列"，这份题解一定要看！它从偏序集、哈斯图讲起，用数学证明了Dilworth定理——"最小链划分等于最长反链长度"。虽然有点抽象，但结合导弹拦截的例子（把每个导弹看作偏序集的元素，"能拦截"看作偏序关系），你会突然明白：原来最少系统数就是最长的"无法被同一系统拦截的导弹序列"（也就是上升子序列）！

**题解三：STA_Morlin（代码最易上手的贪心+二分）**
* **点评**：这份题解的代码简直是"模板级"的！它用`l`数组存最长不升子序列，`h`数组存最长上升子序列，每一步的条件判断都很直白：比如"如果当前导弹≤`l`的末尾，就延长`l`"，否则用`upper_bound`找位置替换。特别是它的注释和变量命名（`r1`表示不升子序列长度，`r2`表示上升子序列长度），让你一眼就能看懂代码逻辑，非常适合刚学贪心的同学！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
做这道题时，很多同学会卡在"如何优化DP"和"为什么第二问是上升子序列"上。结合优质题解的经验，我总结了3个核心难点和解决办法：
</difficulty_intro>

1.  **难点1：如何把O(n²)的DP优化到O(n log n)**  
    * **分析**：普通DP要遍历前面所有元素找最大值，太慢！但我们可以用**辅助数组**记录"长度为k的子序列的最优末尾元素"——比如对于不升子序列，`f[k]`越大，后面能接的导弹越多。这样每次找位置时，用二分法代替遍历，直接找到要替换的位置。  
    * 💡 **学习笔记**：辅助数组的关键是"贪心选择最优末尾"，二分法是优化的关键！

2.  **难点2：为什么第二问等于最长上升子序列**  
    * **分析**：根据Dilworth定理，"把序列拆成最少的不升子序列"等价于"找最长的反链"——反链就是**两两无法被同一系统拦截的导弹**（也就是后面的导弹比前面的高，无法接在同一个不升子序列里）。所以最长反链就是最长上升子序列！  
    * 💡 **学习笔记**：Dilworth定理是连接两问的桥梁，记住"最少链划分=最长反链长度"！

3.  **难点3：如何处理二分查找的边界条件**  
    * **分析**：二分法的边界很容易错！比如第一问要找"第一个小于h[i]的位置"（用`upper_bound`+`greater<int>()`），第二问要找"第一个≥h[i]的位置"（用`lower_bound`）。一定要明确辅助数组的单调性：第一问的`f`是不升的，第二问的`g`是上升的！  
    * 💡 **学习笔记**：先确定辅助数组的单调性，再选对应的二分函数（`lower_bound`/`upper_bound`）！

### ✨ 解题技巧总结
- **技巧1：辅助数组贪心优化**：用辅助数组记录最优末尾，把DP的O(n²)降到O(n log n)——这是LIS问题的标准优化方法！  
- **技巧2：Dilworth定理的应用**：遇到"最少划分成多少个某类子序列"的问题，先想"最长反链是什么"！  
- **技巧3：二分法边界处理**：先明确数组单调性，再选对查找函数（比如不升数组用`upper_bound`+`greater`，上升数组用`lower_bound`）！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**——综合了优质题解的思路，代码简洁，覆盖两问，适合直接学习！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自题解一（离散小波变换°）的优化版，用一个`F`数组处理两问，通过改变二分条件实现不升/上升子序列的计算，逻辑清晰，效率极高！
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    const int MAXN=1e5+3, INF=2147483647;
    int n, H[MAXN], F[MAXN];

    int main(){
        while(~scanf("%d",&H[++n])); --n; // 读入所有导弹高度
        
        // 第一问：最长不上升子序列
        int t=0; memset(F,0,sizeof(F)); F[0]=INF;
        for(int i=1; i<=n; ++i){
            int l=0, r=t+1;
            while(r-l>1){
                int m=l+(r-l)/2;
                if(F[m]>=H[i]) l=m; else r=m;
            }
            int x=l+1;
            if(x>t) t=x; F[x]=H[i];
        }
        printf("%d\n",t);
        
        // 第二问：最长上升子序列（最少系统数）
        t=0; memset(F,0,sizeof(F)); F[0]=0;
        for(int i=1; i<=n; ++i){
            int l=0, r=t+1;
            while(r-l>1){
                int m=l+(r-l)/2;
                if(F[m]<H[i]) l=m; else r=m;
            }
            int x=l+1;
            if(x>t) t=x; F[x]=H[i];
        }
        printf("%d\n",t);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分两部分：  
    > 1. **第一问**：维护`F`数组（不升），`F[m]>=H[i]`时找更大的`l`，最后`x=l+1`是当前导弹能形成的最长不升子序列长度；  
    > 2. **第二问**：维护`F`数组（上升），`F[m]<H[i]`时找更大的`l`，最后`t`就是最长上升子序列长度（最少系统数）。  


<code_intro_selected>
接下来看**优质题解的核心片段**，体会不同写法的巧妙之处！
</code_intro_selected>

**题解一：离散小波变换°（核心片段）**
* **亮点**：用同一个`F`数组处理两问，通过改变二分条件实现不升/上升子序列的计算，代码复用率高！
* **核心代码片段**：
    ```cpp
    // 第一问的二分逻辑
    while(r-l>1){
        int m=l+(r-l)/2;
        if(F[m]>=H[i]) l=m; else r=m;
    }
    // 第二问的二分逻辑
    while(r-l>1){
        int m=l+(r-l)/2;
        if(F[m]<H[i]) l=m; else r=m;
    }
    ```
* **代码解读**：
    > 第一问的条件是`F[m]>=H[i]`（找不升子序列的位置），第二问是`F[m]<H[i]`（找上升子序列的位置）。通过改变判断条件，同一个`F`数组能处理两种情况——是不是很巧妙？  
* 💡 **学习笔记**：代码复用的关键是找到问题的共性（都是用辅助数组+二分）！

**题解三：STA_Morlin（核心片段）**
* **亮点**：用`upper_bound`和`lower_bound`简化二分代码，可读性超高！
* **核心代码片段**：
    ```cpp
    // 第一问：最长不升子序列
    if (l[r1] >= a[i]) l[++r1] = a[i];
    else *upper_bound(l+1, l+r1+1, a[i], greater<int>()) = a[i];
    // 第二问：最长上升子序列
    if (h[r2] < a[i]) h[++r2] = a[i];
    else *lower_bound(h+1, h+r2+1, a[i]) = a[i];
    ```
* **代码解读**：
    > `upper_bound`+`greater<int>()`用于找不升数组中第一个小于`a[i]`的位置，`lower_bound`用于找上升数组中第一个≥`a[i]`的位置。STL函数直接替我们实现了二分，代码更简洁！  
* 💡 **学习笔记**：善用STL的算法函数，可以减少手写二分的错误！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你"亲眼看到"算法的运行过程，Kay设计了一个**8位像素风的导弹防御动画**——像玩《坦克大战》一样学算法！
</visualization_intro>

### 动画演示主题
**像素导弹防御战**：屏幕左侧是飞来的导弹（像素方块，高度对应数值），右侧是辅助数组`F`（一排彩色格子，颜色越深表示数值越大）。你可以控制"单步执行"看每一步的替换过程，也可以"自动播放"看完整流程！

### 核心演示内容
1. **场景初始化**：
   - 背景是FC风格的深蓝色，左侧有一个"导弹发射器"（像素坦克），右侧是辅助数组的"货架"（10个彩色格子）；
   - 控制面板在屏幕下方：有"开始/暂停"、"单步"、"重置"按钮，还有调速滑块（从"慢"到"快"）；
   - 播放8位风格的背景音乐（类似《超级马里奥》的轻快旋律）。

2. **算法执行步骤**：
   - **导弹飞来**：左侧的导弹方块从左向右移动，到达中间时停止（黄色闪烁表示当前处理的导弹）；
   - **辅助数组查找**：右侧的辅助数组中，用**红色框**标出要替换的位置（比如第一问中找第一个小于导弹高度的格子）；
   - **替换/插入**：如果是插入，辅助数组末尾新增一个格子（播放"叮~"的音效）；如果是替换，旧格子的颜色变成导弹的颜色（播放"咔"的音效）；
   - **结果展示**：处理完所有导弹后，辅助数组的长度用"胜利动画"（像素星星闪烁）展示，同时播放"通关音效"。

3. **交互设计**：
   - **单步执行**：点击"单步"按钮，每一步都暂停，让你仔细看替换过程；
   - **自动播放**：拖动调速滑块，控制动画速度（慢：每步1秒，快：每步0.1秒）；
   - **算法对比**：可以切换"第一问"和"第二问"的动画，对比两个辅助数组的变化（比如第一问的数组是不升的，第二问是上升的）。

### 为什么这样设计？
- **像素风格**：唤起你对FC游戏的回忆，让学习更有趣；
- **音效提示**：用不同的声音强化关键操作（插入/替换），帮你记住算法步骤；
- **交互控制**：让你主动探索算法过程，而不是被动看动画——就像自己在玩游戏一样！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了「导弹拦截」的解法，你可以轻松解决**所有LIS变种问题**！比如求最长下降子序列、最长不下降子序列，或者用LIS解决"最少拦截系统"这类问题。
</similar_problems_intro>

### 通用思路迁移
- **场景1**：求"最长不下降子序列"（比如股票最长上涨天数）——把辅助数组改成上升的，用`lower_bound`找位置；
- **场景2**：求"最少需要多少个单调子序列覆盖整个序列"（比如安排最少的生产线）——用Dilworth定理，转化为求最长反链；
- **场景3**：求"最长递增子序列的个数"（比如有多少种最长上升的方式）——在辅助数组中记录每个长度的子序列个数。

### 洛谷练习推荐
1.  **洛谷 P1020** - 导弹拦截（原题）  
    * 🗣️ **推荐理由**：巩固最长不升/上升子序列的O(n log n)实现，直接验证你的学习成果！
2.  **洛谷 P2501** - [HAOI2006]数字序列  
    * 🗣️ **推荐理由**：LIS的进阶应用，需要用LIS求"最少修改次数让序列递增"，锻炼你的变形能力！
3.  **洛谷 P3902** - 递增  
    * 🗣️ **推荐理由**：求最长递增子序列的长度，但数据量更大（n=1e5），考验你对O(n log n)算法的掌握！
4.  **洛谷 P1439** - 【模板】最长公共子序列  
    * 🗣️ **推荐理由**：将最长公共子序列转化为LIS问题，学习如何用LIS解决跨序列的问题！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中很多作者分享了自己的调试经验，比如"初始化辅助数组的重要性"、"二分边界的坑"，这些都是宝贵的经验！
</insights_intro>

> **参考经验（来自题解一：离散小波变换°）**："我一开始在处理第一问时，把辅助数组`F[0]`初始化为0，结果所有导弹都比0大，导致辅助数组无法正确延长。后来改成`INF`（极大值），问题就解决了！"  
> **点评**：辅助数组的初始化直接影响算法的正确性！比如第一问的`F[0]`要设为极大值（让第一个导弹能顺利加入），第二问的`F[0]`要设为0（让第一个导弹能顺利加入上升子序列）。这个小细节如果错了，整个算法都会出错——所以一定要注意初始化！


<conclusion>
「导弹拦截」是一道"承上启下"的题：它既巩固了动态规划的基础，又引入了贪心和二分的优化，还藏着Dilworth定理的数学魅力。记住：**算法的核心是"找规律+优化重复计算"**——辅助数组帮我们记住了之前的最优结果，二分法帮我们快速找到位置，Dilworth定理帮我们把问题转化为熟悉的模型。

下次遇到类似的问题，不妨先想："这是不是LIS的变种？能不能用辅助数组+二分优化？" 相信你一定会越来越厉害！💪
</conclusion>

---

---
处理用时：145.60秒
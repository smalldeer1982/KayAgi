# 题目信息

# [NOIP 2013 提高组] 花匠

## 题目背景

NOIP2013 提高组 D2T2

## 题目描述

花匠栋栋种了一排花，每株花都有自己的高度。花儿越长越大，也越来越挤。栋栋决定把这排中的一部分花移走，将剩下的留在原地，使得剩下的花能有空间长大，同时，栋栋希望剩下的花排列得比较别致。

具体而言，栋栋的花的高度可以看成一列整数 $h_1,h_2,\ldots,h_n$。设当一部分花被移走后，剩下的花的高度依次为 $g_1,g_2,\ldots,g_m$，则栋栋希望下面两个条件中至少有一个满足：

条件 A：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} > g_{2 i + 1}$；  
条件 B：对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i - 1}$，同时对于所有的 $1 \le i \le \frac{m}{2}$，有 $g_{2 i} < g_{2 i + 1}$。

注意上面两个条件在 $m = 1$ 时同时满足，当 $m > 1 $ 时最多有一个能满足。

请问，栋栋最多能将多少株花留在原地。


## 说明/提示

**输入输出样例说明**

有多种方法可以正好保留 $3$ 株花，例如，留下第 $1$、$4$、$5$ 株，高度分别为 $5$、$1$、$2$，满足条件 B。

**数据范围**

对于 $20\%$的数据，$n \le 10$；

对于 $30\%$的数据，$n \le 25$；

对于 $70\%$的数据，$n \le 1000$，$0 \le h_i \le 1000$；

对于 $100\%$的数据，$1 \le n \le {10}^5$，$0 \le h_i \le {10}^6$，所有的 $h_i$ 随机生成，所有随机数服从某区间内的均匀分布。


## 样例 #1

### 输入

```
5
5 3 2 1 2
```

### 输出

```
3
```

# AI分析结果


### 💡 Kay的C++算法解析：花匠 深入学习指南 💡

<introduction>
今天我们来分析NOIP2013提高组的花匠问题。这道题要求通过移除部分花朵，使剩余花朵形成波浪状排列（波峰波谷交替）。本指南将带大家深入理解解题思路、核心算法，并通过可视化方案直观感受算法执行过程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划状态机` 与 `贪心策略`

🗣️ **初步分析**：
> 解决花匠问题的核心在于识别波浪序列的本质。想象你在绘制山脉地图：每个点要么是山峰（高于两侧），要么是山谷（低于两侧）。我们有两种高效解法：
> - **动态规划**：维护两个状态数组，分别记录以当前位置作为波峰/波谷时的最大长度，通过状态转移逐步构建最优解。
> - **贪心策略**：直接扫描序列，在趋势反转时计数，如同徒步登山时记录方向变化的次数。
>
> **可视化设计思路**：我们将用8位像素风格模拟花圃，动态显示花朵高度（不同颜色像素块）。处理每朵花时：
> - 高亮当前花朵并播放音效（上升"叮"，下降"咚"）
> - 显示DP状态条（波峰/波谷长度）或贪心趋势箭头
> - 成功扩展波浪序列时触发花朵闪烁动画+得分效果

---

## 2. 精选优质题解参考

<eval_intro>
根据思路清晰度、代码规范性和算法效率，我精选了以下3个优质题解（均≥4★）：

**题解一：wuzhoupei（DP状态机）**
* **点评**：此解法思路清晰，通过`d_1`和`d_2`状态数组分别记录波峰/波谷位置的最大长度。代码规范（变量名`d_1`/`d_2`含义明确），状态转移逻辑严谨（处理了相等情况的继承）。亮点在于用最简状态机实现O(n)复杂度，且边界处理完整可直接用于竞赛。

**题解二：GSQ0829（贪心策略）**
* **点评**：解法极具启发性，用`cnt`记录当前趋势（1上升/0下降），`ans`计数趋势反转次数。代码简洁高效（空间复杂度O(1)），实践价值高。亮点在于突破DP思维定式，用自然类比（登山方向变化）解释算法本质。

**题解三：kunkun127（精简DP）**
* **点评**：状态定义与wuzhoupei类似，但实现更精简。直接通过大小判断更新`dp1`/`dp2`状态，避免max操作。代码可读性强（仅10行核心逻辑），对初学者友好，是理解状态机DP的优秀范例。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决波浪序列问题的三大核心难点及应对策略：

1.  **状态定义抽象（DP解法）**
    * **分析**：如何用数学语言描述"波峰/波谷"是最大障碍。优质题解用`dp[i][0]`表示以i为波峰的最大长度，`dp[i][1]`表示波谷长度，完美匹配问题本质。
    * 💡 **学习笔记**：好的状态定义应直接对应问题特征，且具备无后效性。

2.  **状态转移推导（DP解法）**
    * **分析**：转移方程需严格满足波浪约束。当`h[i]>h[i-1]`时，只能从波谷状态转移（`dp[i][0]=dp[i-1][1]+1`）；当下降时则相反。关键要理解：**当前状态仅与前一状态相关**。
    * 💡 **学习笔记**：状态转移方程是动态规划的灵魂，反映子问题间的逻辑关系。

3.  **趋势边界处理（贪心解法）**
    * **分析**：贪心法需精准识别趋势反转点。难点在于起始点处理（第一朵花必选）和平坦区的跳过逻辑（`h[i]=h[i-1]`时不改变趋势）。题解通过`cnt`初值（-1）和条件判断`cnt!=1`巧妙解决。
    * 💡 **学习笔记**：贪心策略的健壮性依赖于对边界情况的周全考虑。

### ✨ 解题技巧总结
<summary_best_practices>
从本题提炼的通用解题技巧：
</summary_best_practices>
-   **技巧A：状态机建模**：对具有两种交替状态的问题（如开关/波峰波谷），可用二元状态数组简化逻辑
-   **技巧B：贪心性质识别**：当最优解可通过局部决策累积时（如趋势反转计数），尝试O(n)贪心替代DP
-   **技巧C：边界初始化**：DP初始状态（`dp[1][0]=dp[1][1]=1`）和贪心起点（`ans=1`）是正确性的基石
-   **技巧D：相等处理**：元素相等时继承前态（DP）或跳过（贪心），避免破坏波浪形态

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解优化的通用实现，采用状态机DP思想：

**本题通用核心C++实现参考**
* **说明**：综合wuzhoupei和kunkun127的DP解法，优化了状态转移逻辑
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 100005;
int h[MAXN], dp[MAXN][2];

int main() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> h[i];
    
    dp[1][0] = dp[1][1] = 1;  // 初始状态
    
    for (int i = 2; i <= n; ++i) {
        if (h[i] > h[i-1]) {  // 当前上升趋势
            dp[i][0] = dp[i-1][1] + 1;  // 前点为波谷才能接波峰
            dp[i][1] = dp[i-1][1];      // 波谷状态继承
        }
        else if (h[i] < h[i-1]) {  // 当前下降趋势
            dp[i][1] = dp[i-1][0] + 1;  // 前点为波峰才能接波谷
            dp[i][0] = dp[i-1][0];      // 波峰状态继承
        }
        else {  // 高度相等时直接继承
            dp[i][0] = dp[i-1][0];
            dp[i][1] = dp[i-1][1];
        }
    }
    cout << max(dp[n][0], dp[n][1]) << endl;
    return 0;
}
```
* **代码解读概要**：
  > 1. 初始化：第一朵花既可作波峰也可作波谷
  > 2. 遍历处理：根据当前花与前朵花的相对高度
  >   - 上升时：波峰状态=前朵花波谷状态+1
  >   - 下降时：波谷状态=前朵花波峰状态+1
  >   - 等高处：直接继承前状态
  > 3. 结果输出：取两种状态最大值

---
<code_intro_selected>
精选题解的独特实现亮点：
</code_intro_selected>

**题解一：wuzhoupei（DP状态机）**
* **亮点**：严谨处理所有情况，包含max操作确保最优
* **核心代码片段**：
    ```cpp
    if(a[i]>a[i-1]) 
        d_1[i]=max(d_1[i-1],d_2[i-1]+1), 
        d_2[i]=d_2[i-1];
    else if(a[i]<a[i-1]) 
        d_1[i]=d_1[i-1], 
        d_2[i]=max(d_1[i-1]+1,d_2[i-1]);
    else 
        d_1[i]=d_1[i-1], d_2[i]=d_2[i-1];
    ```
* **代码解读**：
  > 此处`d_1`对应波峰状态，`d_2`对应波谷状态。精妙之处在于：
  > - 上升时：波峰状态取`max(继承前波峰, 前波谷+1)`，确保最优解
  > - 下降时同理，波谷状态取`max(继承前波谷, 前波峰+1)`
  > - 用逗号运算符紧凑实现并行赋值
* 💡 **学习笔记**：max操作保证状态更新时不会遗漏更优解

**题解二：GSQ0829（贪心策略）**
* **亮点**：O(1)空间复杂度，仅用三个变量
* **核心代码片段**：
    ```cpp
    int t = m, ans = 1, cnt = -1;  // cnt: -1初始, 0下降, 1上升
    for (int i = 2; i <= n; i++) {
        scanf("%d", &m);
        if (m > t && cnt != 1) {  // 上升且趋势未锁定
            cnt = 1;  // 锁定上升趋势
            ans++;    // 计数增加
        }
        else if (m < t && cnt) {  // 下降且趋势未锁定
            cnt = 0;  // 锁定下降趋势
            ans++;
        }
        t = m;  // 更新前值
    }
    ```
* **代码解读**：
  > 关键变量：
  > - `t`：记录前一朵花高度
  > - `cnt`：当前趋势（-1=初始，1=上升，0=下降）
  > - `ans`：有效花朵计数
  > 
  > 精妙判断：
  > - `cnt != 1`：避免连续两次上升
  > - `cnt != 0`：避免连续两次下降
* 💡 **学习笔记**：贪心法通过趋势锁定避免重复计数

**题解三：kunkun127（精简DP）**
* **亮点**：去冗余逻辑，最简状态转移
* **核心代码片段**：
    ```cpp
    for (int i = 2; i <= n; i++) {
        if (h[i] > h[i-1]) {  // 上升趋势
            dp1[i] = dp2[i-1] + 1;
            dp2[i] = dp2[i-1];
        } else {  // 持平或下降
            dp1[i] = dp1[i-1];
        }
        if (h[i] < h[i-1]) {  // 下降趋势
            dp2[i] = dp1[i-1] + 1;
            dp1[i] = dp1[i-1];
        } else {  // 持平或上升
            dp2[i] = dp2[i-1];
        }
    }
    ```
* **代码解读**：
  > 将波峰(`dp1`)/波谷(`dp2`)更新分离：
  > - 第一个if处理上升：波峰更新，波谷继承
  > - 第二个if处理下降：波谷更新，波峰继承
  > - 隐含逻辑：等高处两个else同时触发，实现状态继承
* 💡 **学习笔记**：独立判断使逻辑更清晰，但需注意状态继承关系

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让算法过程跃然屏上，我设计了"像素花匠的波浪花园"动画方案（8位复古风格），完整展示DP状态转移与贪心策略的对比：
</visualization_intro>

* **主题**：花匠在像素花园修剪花朵，构建最长波浪序列
* **核心演示**：DP状态条增长过程 vs 贪心趋势变化计数
* **设计思路**：用FC游戏风格降低理解门槛，音效强化关键操作记忆

* **动画帧步骤**：
  1. **场景初始化**：  
     - 16色像素花园，每朵花用不同颜色方块表示高度（高度值→色相映射）
     - 控制面板：开始/暂停/步进按钮，速度滑块，DP/贪心模式切换
     - 8-bit背景音乐循环播放（《绿色兵团》风格）

  2. **算法启动**：
     - 花匠像素小人出现在第一朵花旁，显示"初始状态：dp[1][0]=1, dp[1][1]=1"
     - 贪心模式：显示`ans=1`, `cnt=-1`（趋势未定）

  3. **核心过程演示**：
     - **当前操作高亮**：花匠移动到第i朵花时，该花朵闪烁黄光
     - **高度比较动画**：当前花与前朵花间出现↑或↓箭头，播放对应音效
       - ↑箭头："叮"声（频率随高度差变化）
       - ↓箭头："咚"声（低频）
     - **DP模式**：
       - 顶部状态条分左右区域（红:波峰, 蓝:波谷）
       - 上升时：红条增长 = 左蓝条值+1
       - 下降时：蓝条增长 = 左红条值+1
     - **贪心模式**：
       - 花匠头顶显示趋势图标（▲或▼）
       - 趋势反转时：`ans++`显示+1动画，趋势图标翻转
     - **等高处**：显示"状态继承"提示，无音效

  4. **自动演示/AI模式**：
     - 点击"AI演示"：花匠自动遍历花园，速度可调（0.5x-5x）
     - 关键步骤暂停：遇到状态转移或趋势反转时自动暂停0.5秒

  5. **游戏化元素**：
     - 每成功扩展序列：花朵绽放像素粒子特效
     - 分数系统：基础分+连击奖励（连续正确决策）
     - 最终展示：最大波浪序列路径高亮闪烁，播放胜利音效

  6. **双模式对比**：
     - 分屏显示DP与贪心执行过程
     - 结束时对比结果："DP长度=5, 贪心长度=5"

* **旁白提示（Kay解说）**：
  > "看！当前是第4朵花（高度2），比第3朵（高度1）高，触发上升趋势..."
  > "注意DP状态变化：波峰状态=前朵花波谷状态(2)+1=3！"
  > "贪心模式检测到趋势反转（之前是下降），ans增加到3！"

<visualization_conclusion>
通过这款像素动画，你不仅能直观看到状态转移的数据流动，还能在游戏化体验中理解贪心策略的决策本质。
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握波浪序列解法后，可挑战以下变形问题：
</similar_problems_intro>

* **通用技巧迁移**：
  - 股票买卖时机（波谷买，波峰卖）
  - 锯齿数组生成（相邻元素必须一大一小）
  - 机器人路径规划（避免单调坡度）

* **练习推荐（洛谷）**：
  1. **P1091 合唱队形**  
     🗣️ *推荐理由*：双向波浪序列（先增后减），强化状态机DP应用
  2. **P1280 尼克的任务**  
     🗣️ *推荐理由*：状态机DP经典题，需设计多状态转移
  3. **P1233 木棍加工**  
     🗣️ *推荐理由*：贪心+排序结合，训练最优决策思维

-----

## 7. 学习心得与经验分享

<insights_intro>
题解中蕴藏的宝贵经验：
</insights_intro>

> **参考经验 (来自 wuzhoupei)**："我在解决这个问题时，最初在状态转移时卡了很久，后来通过手动模拟小样例才定位到问题。"
>
> **点评**：这印证了Kay常说的一句话——"当算法逻辑阻塞时，回归问题本质，用最小案例验证"。建议：
> 1. 用[5,3,2,1,2]样例手动演算DP状态表
> 2. 画趋势图辅助贪心决策理解
> 3. 对拍验证边界情况（如全等序列）

<conclusion>
通过本次分析，我们深入理解了波浪序列问题的双解法本质。记住：DP提供严谨框架，贪心追求高效简洁。请用设计好的像素动画强化理解，并挑战推荐习题巩固技能。下次算法之旅再见！
</conclusion>
```

---
处理用时：195.18秒
# 题目信息

# [NOI Online 2021 入门组] 吃豆人

## 题目描述

有一个 $n$ 行 $n$ 列的正方形点阵，左上角点坐标为 $(1, 1)$，右下角点坐标为 $(n, n)$。

点阵中每个整点上都有数量不一的豆子，坐标为 $(i, j)$ 的点上有 $a_{i,j}$ 个豆子。

你可以放置吃豆人，可以将点阵中任意的整点作为吃豆人的初始位置，再给定左上、左下、右上、右下之一作为吃豆人的初始方向。

吃豆人会不断沿初始方向行进，吃光遇到的所有豆子，直到碰到点阵的边界，此时：

1. 如果吃豆人处于正方形点阵四个角之一的位置，那么就会停止行动；

2. 否则，吃豆人的行进路线将以这条边界为镜面发生反射，下图展示了一个路径某两次发生反射的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/6tji95nq.png)

现在，你需要放置两个吃豆人，求两个吃豆人最多共能吃到多少个豆子？注意同一个豆子只能被吃一次。


## 说明/提示

### 样例 1 解释

在 $(1, 1)$ 和 $(1, 3)$ 位置放置吃豆人，初始方向分别为右下和左下，即可吃到位于
$(1, 1)$，$(1, 3)$，$(2, 2)$，$(2, 4)$，$(3, 1)$，$(3, 3)$，$(4, 2)$，$(4, 4)$ 位置上的豆子，总个数为 $132$，
达到最大，路径分别如下图绿线和红线所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/1axaad1b.png)

### 数据范围

对于 $30\%$ 的数据，$n\leq 3$。

对于 $60\%$ 的数据：$n\leq 100$。

对于 $100\%$ 的数据：$2\leq n\leq 1000$，$0\leq a_{i,j}\leq 1000$。

数据由 [SSerxhs](https://www.luogu.com.cn/user/29826) 和 [Karry5307](https://www.luogu.com.cn/user/60990) 共同提供。

感谢 [Silence_water](https://www.luogu.com.cn/user/338630) 提供一组 hack 数据。

## 样例 #1

### 输入

```
4
20 1 19 2
3 18 4 17
16 5 15 6
7 14 8 13```

### 输出

```
132```

# AI分析结果


# 💡 Kay的C++算法解析：[NOI Online 2021 入门组] 吃豆人 深入学习指南 💡

<introduction>
今天我们来分析“吃豆人”这道C++编程题。本指南将帮助大家理解题目核心思路，掌握路径模拟与去重技巧，并通过像素动画直观感受算法执行过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟应用` + `数学优化`

🗣️ **初步分析**：
> 解决这道题的关键在于**路径模拟**和**交点去重**。想象点阵是一个复古游戏厅的像素迷宫，吃豆人像弹珠一样在边界反弹前进。核心步骤：
   - **路径唯一性**：每个起点（第一行各点）对应唯一路径，共n条
   - **去重核心**：两条路径相交时，需减去交点豆子（类似俄罗斯方块消除）
   - **数学优化**：利用对称性快速计算路径总和与交点坐标
>
> 可视化设计思路：
> - **像素风格**：采用8-bit复古风，用不同颜色光轨表示两条路径
> - **关键高亮**：反射点显示橙色闪光，交点为红色脉冲
> - **音效设计**：移动时“嘀”声，反射时“砰”声，交点亮起时“叮”声
> - **游戏化交互**：控制台可调速播放，通关后显示豆子收集分数

---

## 2. 精选优质题解参考

<eval_intro>
我们从思路清晰性、代码规范性和算法优化角度，精选以下三条优质题解：
</eval_intro>

**题解一（来源：Mine_King）**
* **点评**：思路如水晶般通透！通过n=4/n=5的像素图示，归纳出路径分类和交点公式。代码中：
  - 方向数组`gx/gy`实现优雅的反射模拟
  - `repeat()`函数精准处理四类交点场景
  - 边界处理严谨，特判对角线加分项
  亮点在于将复杂几何问题转化为简洁的代数表达式

**题解二（来源：Hanx16Kira）**
* **点评**：教学式典范！从暴力到优化的渐进式分析：
  - 独创"四条斜边求和法"高效计算路径值
  - 中点坐标公式推导交点，数学美感十足
  - 代码模块化（输入/计算/枚举）结构清晰
  实践价值高，直接可用于竞赛，尤其赞赏其详尽的调试建议

**题解三（来源：cqbzlym）**
* **点评**：创新性标记法令人耳目一新：
  - `vis`数组实时记录路径覆盖点
  - `val`矩阵动态计算交点豆子和
  - 方向切换用位运算`f=(f+1)&3`极简实现
  亮点在于用空间换代码简洁性，避免复杂分类讨论

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大难点，结合优质题解策略分析：
</difficulty_intro>

1.  **路径高效计算**
    * **分析**：直接模拟行走可能超时。优质题解采用**对称分解法**（Hanx16Kira）或**方向向量法**（Mine_King），将复杂度优化至O(n)
    * 💡 **学习笔记**：网格路径善用向量运算，反射本质是方向向量取反

2.  **交点精确定位**
    * **分析**：当|i-j|为偶数时必有交点。Mine_King提炼出四种情况：
      - 双对角线：中心点
      - 单对角线：对称两点
      - 双回路：中心对称四点
    * 💡 **学习笔记**：交点坐标=(中点坐标±偏移量)，活用奇偶判断避免浮点运算

3.  **去重完整性**
    * **分析**：cqbzlym的`val`矩阵确保交点不重不漏，关键在实时更新：
      ```cpp
      if(vis[x][y]) 
          val[vis[x][y]][i] += a[x][y];
      ```
    * 💡 **学习笔记**：动态标记法比静态公式更适应边界情况

### ✨ 解题技巧总结
<summary_best_practices>
从本题提炼的通用解题心法：
</summary_best_practices>
- **镜像分解**：将反射路径拆解为直线段组合（如Hanx16Kira的四斜边求和）
- **位算转向**：方向变化用`d=(d+1)%4`实现，避免复杂判断
- **坐标映射**：建立`(行,列)`到数学坐标系的转换思维
- **对称守恒**：利用网格对称性减少50%计算量（如`a[i][j]`与`a[n-i+1][n-j+1]`）

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合优质题解，以下是通用实现框架（已做简化处理）：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：融合Mine_King的模拟行走与Hanx16Kira的数学优化，平衡效率与可读性
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;
    const int N=1005;
    int n, a[N][N], b[N]; // b[i]:起点为(1,i)的路径豆子数
    
    int cross(int i, int j) { // 计算交点豆子和
        if ((j-i)%2) return 0;         // 难点1解决：奇偶判断
        if (i==1 && j==n) return a[n/2+1][n/2+1]; 
        // ...其他三种情况见完整题解
    }
    
    int main() {
        scanf("%d", &n);
        for (int i=1; i<=n; i++)
            for (int j=1; j<=n; j++)
                scanf("%d", &a[i][j]);
        
        // 计算各路径总和（含两条对角线）
        for (int i=1; i<=n; i++) {
            if (i==1 || i==n) {
                // 对角线特判
            } else {
                int dx[4]={1,1,-1,-1}, dy[4]={-1,1,1,-1}; // 难点2解决：方向向量
                int x=1, y=i, d=(i==1)?1:0; // 初始方向
                while (!(x==1 && y==i && d==0)) { // 模拟反射
                    b[i] += a[x][y];
                    // 边界反射代码见完整题解
                }
            }
        }
        
        int ans=0;
        for (int i=1; i<=n; i++)    // 难点3解决：枚举去重
            for (int j=i+1; j<=n; j++)
                ans = max(ans, b[i]+b[j]-cross(i,j));
        printf("%d", ans);
        return 0;
    }
    ```
* **代码解读概要**：
  > 1. **输入处理**：读入n×n豆子矩阵  
  > 2. **路径计算**：  
  >    - 对角线直接累加  
  >    - 其他路径用方向向量模拟反射行走  
  > 3. **去重枚举**：  
  >    - 双循环枚举所有路径组合  
  >    - cross函数处理四类交点场景  
  > 4. **结果输出**：输出最大豆子数  

---
<code_intro_selected>
现在深入赏析各优质题解的精华代码片段：
</code_intro_selected>

**题解一（Mine_King）**
* **亮点**：优雅的方向向量反射与精准分类讨论
* **核心代码片段**：
    ```cpp
    int repeat(int x,int y) {
        if((y-x)%2) return 0; // 奇偶判断
        if(x==1&&y==n) return a[(n+1)/2][(n+1)/2]; // 双对角线
        // ...其他三种情况公式
    ```
* **代码解读**：
  > 函数通过`(y-x)%2`快速过滤无交点情况（节省50%计算）。双对角线交点即中心点`(n/2+1, n/2+1)`。其他情况利用对称性直接计算坐标，避免复杂模拟。

**题解二（Hanx16Kira）**
* **亮点**：独创四斜边求和法
* **核心代码片段**：
    ```cpp
    b[i] = sum1[n][n-i+1] + sum1[n-i+1][n] 
          + sum2[i][1] + sum2[n][n-i+1]
          - a[1][i] - a[i][1] - a[n-i+1][n] - a[n][n-i+1];
    ```
* **代码解读**：
  > `sum1`和`sum2`是预处理的斜对角线前缀和。将回路分解为四条斜边求和，再减去重复计算的四个顶点。时间复杂度从O(n)降至O(1)，是空间换时间的典范。

**题解三（cqbzlym）**
* **亮点**：实时标记与容斥计算
* **核心代码片段**：
    ```cpp
    if(vis[x][y]) // 若该点已被其他路径覆盖
        val[vis[x][y]][i] += a[x][y]; // 更新交点矩阵
    else 
        vis[x][y] = i; // 首次标记
    ```
* **代码解读**：
  > 在模拟行走时同步更新`vis`矩阵和`val`交点值。优势在于自动处理各类交点场景，无需人工分类。学习其"实时更新，动态统计"的思想。

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
下面设计一个8-bit像素风格的动画方案，帮助你直观理解吃豆人移动与交点计算：
</visualization_intro>

* **动画主题**：《像素豆人大冒险》复古游戏  
* **核心演示**：双吃豆人路径模拟与动态去重  

* **设计思路**：  
  采用FC红白机画风，通过色彩区分与音效反馈强化理解：  
  - 青色/紫色轨迹区分两条路径  
  - 交点脉冲红光标识重复豆子  
  - 背景音乐：8-bit循环旋律  

* **动画帧步骤**：  
  1. **场景初始化**：  
      - 绘制n×n像素网格（16色）  
      - 控制面板：速度滑块/单步/暂停/重置  
      ![网格示例](https://img.itch.zone/a1/438/800x600/r5XUQ5.png)  

  2. **单路径演示**（按空格键切换双人模式）：  
      - 吃豆人移动：像素小人+拖尾光效  
      - 边界反射：撞击时显示角度示意图  
      - 音效：移动"嘀"，反射"砰"，收集"叮"  

  3. **双路径交点计算**：  
      - 实时显示`vis`矩阵：被覆盖点像素变暗  
      - 交点脉冲：红色光圈扩散效果  
      ![交点效果](https://i.imgur.com/3q6TzZ0.gif)  

  4. **数据面板同步**：  
      - 左侧显示当前路径和：`b[i] = ...`  
      - 右侧更新去重计算：`ans = b[i]+b[j]-cross`  

  5. **游戏化激励**：  
      - 每对路径完成即"通关"，显示星级评分  
      - 最佳组合解锁隐藏音效（胜利旋律）  

* **技术实现**：  
  用Canvas API实现：  
  ```javascript
  // 绘制吃豆人
  ctx.fillStyle = '#00FFFF'; // 青色像素
  ctx.fillRect(x*10, y*10, 10, 10); // 10px网格
  
  // 交点脉冲动画
  function pulse(x, y) {
      drawCircle(x, y, radius, 'red');
      playSound('ding.wav');
  }
  ```

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本解题思路后，可挑战以下相似问题：
</similar_problems_intro>

* **通用技巧迁移**：  
  网格路径+动态标记+去重思想还可用于：  
  1. 激光反射问题（物理模拟）  
  2. 多机器人路径规划（避免碰撞）  
  3. 光线追踪渲染（计算机图形学）  

* **推荐练习**（洛谷题库）：  
  1. **P1219 八皇后**  
     🗣️ *巩固对角线标记技巧，理解位置对称性*  
  2. **P1433 吃奶酪**  
     🗣️ *强化路径枚举与动态去重能力*  
  3. **P1005 矩阵取数游戏**  
     🗣️ *学习网格DP与状态压缩，迁移优化思想*  

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验尤为珍贵：
</insights_intro>

> **Mine_King的调试心得**：  
> *"在推导交点公式时，我通过n=2,3的特例验证发现原公式漏掉边界情况，最终补充了四种分类。"*  
>  
> **Kay点评**：  
> 这提醒我们：  
> 1. 永远用边界值（n=2,3）验证算法  
> 2. 复杂分类讨论要配合矩阵图验证  
> 3. 输出中间变量是定位错误的利器  

---

<conclusion>
本次吃豆人题解分析就到这里。记住：算法如迷宫探险，清晰的思路是指南针，严谨的代码是罗盘。多画图模拟，善用对称优化，你也能在编程宇宙中收集满屏的"金豆子"！下次冒险再见！💪
</conclusion>
```

---
处理用时：240.42秒
# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果


# 💡 Kay的C++算法解析：导弹拦截 深入学习指南 💡

> 大家好，我是Kay！今天我们将一起探索经典题目「导弹拦截」。这道题看似简单，却蕴含了动态规划、贪心算法和Dilworth定理的精妙思想。我会用清晰的讲解和生动的可视化方案，帮助大家掌握解题核心技巧！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划与贪心应用` (最长子序列问题)

🗣️ **初步分析**：
> 导弹拦截问题可以想象成一场「塔防游戏」：第一问是单座防御塔最多拦截多少导弹（最长不上升子序列），第二问是所有导弹都被拦截需要多少防御塔（系统最小化）。核心思想是：
> - **第一问**：通过动态规划维护一个「导弹高度栈」（类似俄罗斯方块堆积），用二分查找优化过程
> - **第二问**：借助Dilworth定理转化为求最长上升子序列，或通过贪心模拟防御塔部署
> 
> **算法流程可视化设计**：
> - 第一问：用像素方块表示导弹，绿色方块表示当前维护的防御高度栈，红色箭头显示二分查找过程
> - 第二问：不同颜色像素塔表示不同防御系统，导弹下落时触发系统选择动画
> - 复古元素：8-bit风格防御塔图标，导弹命中时经典FC音效，数据更新时像素闪烁特效

---

## 2. 精选优质题解参考

### 题解一：离散小波变换° (理论推导最严谨)
* **点评**：从DP基础方程出发，完整推导状态转移方程 $\mathit{dp}_i=\max_{j<i,h(j)\ge h(i)}\{\mathit{dp}_j+1\}$，并严谨证明二分优化正确性。亮点在于结合数学归纳法证明维护数组的单调性，代码中`F[x]=H[i]`的更新逻辑清晰体现「用较小值替换以保留更大拦截潜力」的优化思想，边界处理严谨可直接用于竞赛。

### 题解二：STA_Morlin (实践指导性最强)
* **点评**：独创性提出贪心模拟防御塔部署方案，将抽象问题转化为直观的塔防决策。亮点在于证明「选择最小可拦截系统」的最优性时采用构造法（交换决策序列），代码中`set`维护系统高度配合`lower_bound`的用法极具启发性，变量命名`g[k]`明确表示系统当前高度。

### 题解三：Tofu (理论深度最佳)
* **点评**：从偏序集角度阐释Dilworth定理，通过哈斯图直观展示链与反链关系。亮点在于将导弹高度序列定义为偏序集 $\langle A, \le \rangle$，用像素化哈斯图演示定理应用（红蓝链划分），为理解「最小链划分=最长反链」提供几何直观。

---

## 3. 核心难点辨析与解题策略

1. **难点：O(n²)DP超时优化**  
   *分析*：当n=10⁵时需O(n log n)算法。优质解法均采用二分维护单调栈：第一问用`upper_bound(..., greater<int>())`在降序栈中找首个≤当前导弹的位置；第二问用`lower_bound`在升序栈中找首≥位置。关键变量`d1[len1]`维护长度为len1的不升序列最小尾值。
   💡 **学习笔记**：单调栈+二分是优化LIS类问题的银弹

2. **难点：第二问贪心正确性理解**  
   *分析*：贪心策略总选择「最小可拦截系统」更新。反证：若选择更高系统，后续更高导弹可能因低系统被浪费而无法拦截。代码中`g[k]=a[i]`的更新保证系统数组始终有序。
   💡 **学习笔记**：贪心选择保留高潜力系统是优化关键

3. **难点：Dilworth定理应用**  
   *分析*：定理证明依赖偏序集分解。在导弹序列中，不升子序列是链，上升子序列是反链。关键推导：最小链划分数=最长反链长=最长上升子序列长。
   💡 **学习笔记**：Dilworth建立了链划分与反链的等价关系

### ✨ 解题技巧总结
- **技巧1 状态设计**：DP状态`dp[i]`表以i结尾的最长子序列长，`f[i]`表长度为i的子序列最小尾值
- **技巧2 边界处理**：初始化`f[0]=INF`避免边界判断，`while(r-l>1)`确保二分安全
- **技巧3 贪心维护**：用`set/multiset`自动排序系统高度，复杂度稳定O(n log n)

---

## 4. C++核心代码实现赏析

```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int N = 1e5+5;

int main() {
    int a[N], n=0, x;
    while(cin >> x) a[++n] = x; // 读入导弹高度

    // 第一问: 最长不上升子序列
    int d1[N], len1=1;
    d1[1] = a[1];
    for(int i=2; i<=n; ++i) {
        if(a[i] <= d1[len1]) d1[++len1] = a[i];
        else *upper_bound(d1+1, d1+len1+1, a[i], greater<int>()) = a[i];
    }
    cout << len1 << endl;

    // 第二问: 最长上升子序列
    int d2[N], len2=1;
    d2[1] = a[1];
    for(int i=2; i<=n; ++i) {
        if(a[i] > d2[len2]) d2[++len2] = a[i];
        else *lower_bound(d2+1, d2+len2+1, a[i]) = a[i];
    }
    cout << len2 << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. 双循环独立处理两问，结构清晰  
  2. `upper_bound`配合`greater<int>()`实现降序查找  
  3. 指针解引用赋值精炼高效  

### 题解片段深度解析

**题解一核心片段**（离散小波变换°）  
```cpp
int l=0, r=t+1; 
while(r-l>1){  // 二分查找边界
    int m=l+(r-l)/2;
    if(F[m]>=H[i]) l=m; 
    else r=m;
}
F[l+1] = H[i];  // 更新F数组
```
* **亮点**：通过`r=t+1`预设右边界避免越界  
* **学习笔记**：`l`始终指向满足条件的最右位置  

**题解二核心片段**（STA_Morlin）  
```cpp
set<int> st;
for(int i=1; i<=n; ++i) {
    auto it = st.lower_bound(A[i]); 
    if(it == st.end()) st.insert(A[i]); 
    else { st.erase(it); st.insert(A[i]); }
}
cout << st.size();
```
* **亮点**：`set`自动排序特性简化系统维护  
* **学习笔记**：用STL容器实现高效贪心  

---

## 5. 算法可视化：像素动画演示

### 导弹拦截防御模拟系统（8-bit像素版）
* **主题**：复古街机风格导弹防御战  
* **核心演示**：  
  ![第一问演示](https://via.placeholder.com/400x200?text=不升序列维护动画)  
  `1. 导弹序列`：像素数字表示高度，从左至右飞入  
  `2. 高度栈维护`：绿色方块堆叠表示当前d1数组  
  `3. 命中判定`：新导弹≤栈顶时，方块下落扩展（音效：ding!）  
  `4. 二分查找`：红色扫描线在栈中快速定位，命中位置像素闪烁  

  ![第二问演示](https://via.placeholder.com/400x200?text=多系统贪心选择)  
  `1. 防御塔系统`：蓝/黄/紫塔表示不同系统，塔顶数字表当前拦截高度  
  `2. 系统选择`：导弹下落时，首个≥导弹高度的塔亮起红光（音效：buzz!）  
  `3. 系统更新`：塔顶高度更新为导弹高度，像素数字滚动特效  
* **交互控制**：  
  - 步进/暂停：观察每步决策  
  - 速度滑块：调整导弹下落速度  
  - 模式切换：对比DP解法与贪心解法  

---

## 6. 拓展练习与相似问题思考
1. **LIS变形应用**  
   - P1091 合唱队形（双向LIS）  
   - P1439 最长公共子序列（LIS转化）  
2. **Dilworth定理应用**  
   - P1233 木棍加工（二维偏序）  
   - P4290 部落战争（DAG最小路径覆盖）  
3. **贪心维护实践**  
   - P5019 铺设道路（区间贪心）  
   - P1094 纪念品分组（双指针贪心）  

---

## 7. 学习心得与经验分享
> **离散小波变换°的调试经验**：  
> *“二分边界设定`r=t+1`比传统`r=t`更安全，避免处理极值时的边界错误”*  
> **Kay点评**：该技巧可推广至所有二分查找问题，特别在竞赛中能减少90%边界BUG  

> **STA_Morlin的贪心实现心得**：  
> *“用`set`代替手工维护数组，代码简洁且不易出错”*  
> **Kay点评**：善用STL是提升竞赛编码效率的关键，但需注意`set`插入删除的迭代器失效问题  

---
> 编程如布阵，算法似兵法。希望本指南助你掌握导弹拦截的攻防之道！下次我们继续挑战算法高峰！🚀

---
处理用时：146.92秒
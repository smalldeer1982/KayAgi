# 题目信息

# [NOIP2021] 报数

## 题目描述

报数游戏是一个广为流传的休闲小游戏。参加游戏的每个人要按一定顺序轮流报数，但如果下一个报的数是 $7$ 的倍数，或十进制表示中含有数字 $7$，就必须跳过这个数，否则就输掉了游戏。

在一个风和日丽的下午，刚刚结束 SPC20nn 比赛的小 r 和小 z 闲得无聊玩起了这个报数游戏。但在只有两个人玩的情况下计算起来还是比较容易的，因此他们玩了很久也没分出胜负。此时小 z 灵光一闪，决定把这个游戏加强：任何一个十进制中含有数字 $7$ 的数，它的所有倍数都不能报出来！

形式化地，设 $p(x)$ 表示 $x$ 的十进制表示中是否含有数字 $7$，若含有则 $p(x) = 1$，否则 $p(x) = 0$。则一个正整数 $x$ 不能被报出，当且仅当存在正整数 $y$ 和 $z$ ，使得 $x = yz$ 且 $p(y) = 1$。


例如，如果小 r 报出了 $6$ ，由于 $7$ 不能报，所以小 z 下一个需要报 $8$；如果小 r 报出了 $33$，则由于 $34 = 17 \times 2$，$35 = 7 \times 5$ 都不能报，小 z 下一个需要报出 $36$ ；如果小 r 报出了 $69$，由于 $70 \sim 79$ 的数都含有 $7$，小 z 下一个需要报出 $80$ 才行。

现在小 r 的上一个数报出了 $x$，小 z 想快速算出他下一个数要报多少，不过他很快就发现这个游戏可比原版的游戏难算多了，于是他需要你的帮助。当然，如果小 r 报出的 x 本身是不能报出的，你也要快速反应过来小 r 输了才行。

由于小 r 和小 z 玩了很长时间游戏，你也需要回答小 z 的很多个问题。

## 说明/提示

**【样例解释 #1】**

这一组样例的前 $3$ 次询问在题目描述中已有解释。

对于第 $4$ 次询问，由于 $300 = 75 \times 4$，而 $75$ 中含有 $7$ ，所以小 r 直接输掉了游戏。

**【数据范围】**

对于 $10\%$ 的数据，$T \leq 10$，$x \leq 100$。  
对于 $30\%$ 的数据，$T \leq 100$，$x \leq 1000$。  
对于 $50\%$ 的数据，$T \leq 1000$，$x \leq 10000$。  
对于 $70\%$ 的数据，$T \leq 10000$，$x \leq 2 \times {10}^5$。  
对于 $100\%$ 的数据，$1 \le T \leq 2 \times {10}^5$，$1 \le x \leq {10}^7$。

## 样例 #1

### 输入

```
4
6
33
69
300
```

### 输出

```
8
36
80
-1
```

## 样例 #2

### 输入

```
5
90
99
106
114
169
```

### 输出

```
92
100
109
-1
180
```

## 样例 #3

### 输入

```
见附件中的 number/number3.in```

### 输出

```
见附件中的 number/number3.ans```

## 样例 #4

### 输入

```
见附件中的 number/number4.in```

### 输出

```
见附件中的 number/number4.ans```

# AI分析结果


### Kay的C++算法解析：[NOIP2021]报数 深入学习指南

**引言**  
今天我们一起分析“[NOIP2021]报数”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。

---

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`筛法应用`与`预处理优化`  

🗣️ **初步分析**：  
> 解决报数问题的核心在于**高效预处理**所有非法数字（含7或其倍数）。这就像在数字迷宫中用"筛网"捕捉所有"陷阱数字"，只留下安全路径。  
> - **核心难点**在于避免重复标记（如14同时是7和14的倍数）和实现O(1)查询。优质题解通过"已标记则跳过"的剪枝策略解决前者，通过预存下一个合法数的映射解决后者。  
> - **可视化设计**：在像素动画中，我们将用红色高亮当前处理的数字，若含7则将其倍数标记为黄色，合法数字显示为绿色，并用箭头动态展示答案数组的构建过程。

---

### 2. 精选优质题解参考
**题解一（银杉水杉秃杉）**  
* **点评**：该题解思路清晰直白，通过双重标记机制（`f[]`标记非法数，`nx[]`存储下一个合法数）实现高效预处理。代码规范性强：  
  - 使用`check(i)`函数分离数字检查逻辑  
  - 关键剪枝`if(f[i]) continue`避免重复标记  
  - 读入优化提升IO效率  
  亮点：时间复杂度严格O(10⁷+T)，空间利用率高，竞赛实用性强。

**题解二（StudyingFather）**  
* **点评**：采用合法数列表+索引映射的巧妙设计。`vis[]`数组同时承担标记和存储索引的双重角色：  
  - `vis[i]=-1`表示非法  
  - `vis[i]=k`表示第k个合法数  
  - `lis[]`存储合法数序列  
  亮点：代码简洁易读，但查询需访问两个数组（lis[vis[i]+1]），微增常数时间。

**题解三（滑_稽）**  
* **点评**：通过双数组`Ill[]`和`judge()`分离标记与检查逻辑，附带正确性证明是其亮点。但查询时依赖`Numsafe[]`映射+数组遍历，复杂度O(log n)稍逊于前两者。

---

### 3. 核心难点辨析与解题策略
**难点1：高效去重标记**  
* **分析**：当14同时被7和14标记时，题解1/2通过"已标记则跳过"（`if(f[i])continue`）避免冗余操作。  
* 💡 **学习笔记**：预处理时跳过已标记数字是降低复杂度的关键。

**难点2：O(1)查询实现**  
* **分析**：题解1的`nx[]`数组直接存储每个合法数的后继，通过递推关系`nx[last]=i`实现闪电查询。  
* 💡 **学习笔记**：用空间换时间是处理大查询量的黄金法则。

**难点3：边界处理**  
* **分析**：当x=10⁷时，其下一个合法数可能是10⁷+1。题解1/2将数组开至10⁷+10⁴解决。  
* 💡 **学习笔记**：数据范围临界值需特别验证。

**✨ 解题技巧总结**  
- **预处理为王**：大规模查询必先预处理  
- **剪枝即效率**：`if(invalid[i])continue` 避免重复劳动  
- **映射巧用**：`nextNum[last]=i` 构建答案链  
- **边界防御**：数组大小=数据上限+安全余量  

---

### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**  
```cpp
#include <cstdio>
#include <cstring>
const int MAXN = 10000010;
bool invalid[MAXN];  // 非法标记
int nextNum[MAXN];   // 合法数的下一个数

bool has7(int x) {    // 检查数字7
    while (x) {
        if (x % 10 == 7) return true;
        x /= 10;
    }
    return false;
}

void init() {
    memset(invalid, false, sizeof(invalid));
    int last = 1;  // 最近合法数游标
    for (int i = 1; i < MAXN; i++) {
        if (invalid[i]) continue;       // 关键剪枝
        if (has7(i)) {
            for (int j = i; j < MAXN; j += i) 
                invalid[j] = true;      // 标记倍数
        } else {
            nextNum[last] = i;         // 构建答案链
            last = i;
        }
    }
}

int main() {
    init();
    int T, x;
    scanf("%d", &T);
    while (T--) {
        scanf("%d", &x);
        printf("%d\n", invalid[x] ? -1 : nextNum[x]);
    }
    return 0;
}
```
**代码解读概要**：  
- `invalid[]`筛除所有含7数及其倍数  
- `nextNum[]`记录合法数的直接后继  
- 查询时直接查表输出  

**题解片段赏析**  
1. **银杉水杉秃杉**  
   ```cpp
   void init() {
       for (int i = 1; i <= N; i++) {
           if (f[i]) continue;        // 剪枝精华
           if (check(i)) {            // 发现含7数
               for (int j = i; j <= N; j += i) 
                   f[j] = 1;          // 标记全家桶
           } else {
               nx[ls] = i;  // ls的上一个是i
               ls = i;       // 更新游标
   }}}
   ```
   **学习笔记**：`ls`游标像串联珍珠般链接合法数，实现O(1)后继访问。

2. **StudyingFather**  
   ```cpp
   if (vis[i] == 0) {
       if (check(i)) {
           for (int j = 1; i*j <= maxn; j++)
               vis[i*j] = -1;   // 统一标记
       } else {
           vis[i] = ++cnt;      // 分配合法编号
           lis[cnt] = i;         // 存入合法列表
   }}}
   ```
   **学习笔记**：`vis[]`双重使命是空间优化的典范，但需注意-1与正数的语义区分。

---

### 5. 算法可视化：像素动画演示  
**主题**：数字迷宫大冒险（8-bit像素风格）  

**核心演示**：  
1. **初始化场景**  
   - 灰色网格表示数字1~10⁷，左侧控制面板（开始/暂停/步进/调速）  
   - 底部状态栏：当前操作说明

2. **筛法过程**（配复古音效）  
   - **扫描数字**：蓝色光柱扫描每个数字（步进音效：嘀）  
   - **发现含7数**：数字变红（警报音效：嘟！）→ 红色冲击波标记其倍数（批量标记音效：哗啦）  
   - **合法数字**：数字变绿（清脆音效：叮！），绿色箭头连接上一个合法数  

3. **查询演示**  
   - 输入x=33 → 网格中33闪烁黄光 → 自动跳转显示36（绿色箭头牵引）  
   - 输入x=300 → 显示红色"X"（失败音效：嗡...）  

4. **游戏化元素**  
   - 每处理10,000数字解锁新关卡（8-bit胜利音乐）  
   - 连击奖励：连续标记倍数时触发像素烟花  

**技术实现**：  
- **绘制逻辑**：Canvas按数字索引渲染网格，状态色值映射：  
  ```js
  const COLORS = { 0:0xAAAAAA, 1:0xFF0000, 2:0x00FF00 } // 灰/红/绿
  ```
- **音效触发**：Web Audio API在标记/合法/错误时播放对应音效  

---

### 6. 拓展练习与相似问题  
**通用技巧迁移**  
筛法预处理技术还可用于：  
1. 质数筛（埃氏筛/欧拉筛）  
2. 约数个数计算  
3. 莫比乌斯函数预处理  

**洛谷推荐**  
1. [P3383]线性筛素数  
   → 掌握埃氏筛与欧拉筛的差异  
2. [P1835]素数密度  
   → 练习大区间筛法应用  
3. [P3312]数表  
   → 筛法与数论的综合运用  

---

### 7. 学习心得与经验分享  
**参考经验**（银杉水杉秃杉）：  
> "剪枝操作`if(f[i])continue`看似简单，却让我在调试时吃了苦头——最初忘记加导致超时。这提醒我们：基础优化决定成败。"

**Kay的总结**：  
预处理类题目需特别注意两点：  
1. **边界检查**：最大值/零值等临界情况  
2. **复杂度验证**：看似O(n)的代码可能因缓存未命中变慢  

---

**结语**  
通过本次分析，我们掌握了筛法预处理的核心技巧和空间优化策略。记住，编程能力提升在于持续实践和深度思考。下次挑战再见！💪

---
处理用时：183.64秒
# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果


### 💡 Kay的C++算法解析：最短路计数 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论中的**最短路计数**（BFS/SPFA应用）

🗣️ **初步分析**：
> 解决"最短路计数"这道题，关键在于运用**广度优先搜索(BFS)**的思想。想象你在迷宫中探索，BFS就像一层层扩散的涟漪，确保第一次到达某个位置时就是最短路径。在本题中：
> - 核心思路：在BFS遍历过程中同步统计路径数量。当节点首次被访问时，其路径数=前驱节点的路径数；当再次以相同距离被访问时，路径数累加。
> - 可视化设计：在像素动画中，用不同颜色标记节点状态（白色未访问/黄色队列中/绿色已处理），当节点路径数更新时显示累加过程。采用8位像素风格，加入"叮"的音效提示路径更新，"胜利"音效表示完成。

#### 2. 精选优质题解参考
**题解一（岸芷汀兰）**
* **亮点**：清晰指出无权图适用BFS的特性，代码简洁高效（100ms）。正确处理自环和重边，变量命名规范（`linker`存图，`ans`存路径数）。边界处理严谨，可直接用于竞赛。

**题解二（King丨帝御威）**
* **亮点**：使用堆优化Dijkstra，强调其不被卡数据的优势。虽然本题中稍慢(232ms)，但代码模块化强（`add_edge`封装），提供模板题链接，适合带权图扩展学习。

**题解三（Rbrq）**
* **亮点**：SPFA实现最简洁（仅需70行），突出路径数更新核心逻辑。用`vis`数组避免重复入队，`ans`数组同步更新，实践价值高且易调试。

#### 3. 核心难点辨析与解题策略
1. **路径数初始化与传递**
   * **难点**：起点路径数需初始化为1（`ans[1]=1`），非起点节点如何继承/累加路径数易出错
   * **解决**：BFS中分两种情况处理邻居节点：首次访问时`ans[v]=ans[u]`；相同距离再次访问时`ans[v]=(ans[v]+ans[u])%mod`

2. **重边与自环处理**
   * **难点**：重边增加路径数，自环不影响结果但需避免死循环
   * **解决**：邻接表天然支持重边存储；自环在遍历时跳过（`if(u==v) continue`）

3. **状态同步与效率**
   * **难点**：如何在BFS中保证每个节点只被处理一次，同时正确累加所有路径
   * **解决**：使用`visited`数组标记入队状态，确保节点出队时完成所有路径统计

💡 **学习笔记**：
> 路径数更新遵循拓扑序：当前节点的路径数=所有最短前驱路径数之和

✨ **解题技巧总结**：
- **分层遍历**：BFS队列天然按距离分层，保证第一次到达即最短路
- **即时取模**：路径数每次累加后立即`%100003`防溢出
- **链式前向星**：`head[u]`存储起点为u的第一条边，`next`数组形成链，高效存储稀疏图

#### 4. C++核心代码实现赏析
**本题通用核心实现（BFS+路径计数）**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int MOD = 100003;
const int MAXN = 1e6+5;
vector<int> graph[MAXN];
int dist[MAXN], ans[MAXN];
bool visited[MAXN];

int main() {
    int n, m;
    cin >> n >> m;
    for(int i=0; i<m; i++) {
        int u, v;
        cin >> u >> v;
        graph[u].push_back(v);
        graph[v].push_back(u);
    }
    
    memset(dist, -1, sizeof(dist));
    queue<int> q;
    q.push(1);
    dist[1] = 0;
    ans[1] = 1;
    visited[1] = true;
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : graph[u]) {
            if(!visited[v]) {
                visited[v] = true;
                dist[v] = dist[u] + 1;
                ans[v] = ans[u];  // 首次访问继承路径数
                q.push(v);
            } 
            else if(dist[v] == dist[u] + 1) {
                ans[v] = (ans[v] + ans[u]) % MOD;  // 相同距离累加路径数
            }
        }
    }
    
    for(int i=1; i<=n; i++) 
        cout << ans[i] << endl;
}
```

**各题解片段赏析**：
1. 岸芷汀兰（BFS核心）：
   ```cpp
   if (!vis[y]) {
       vis[y] = true;
       d[y] = d[x] + 1;
       ans[y] = ans[x];
       q.push(y);
   }
   else if(d[y] == d[x] + 1) 
       ans[y] = (ans[y] + ans[x]) % mod;
   ```
   * **亮点**：双条件分支直击路径计数核心
   * **解读**：当节点`y`首次访问时直接继承`x`的路径数；当以相同距离再次访问时累加路径数
   * **学习**：`d[y]`记录最短路长度，作为判断是否累加的依据

2. King丨帝御威（Dijkstra路径更新）：
   ```cpp
   if(dis[v] > dis[u] + 1) {
       dis[v] = dis[u] + 1;
       ans[v] = ans[u];  // 发现更短路径时重置
       q.push(make_pair(-dis[v], v));
   }
   else if(dis[v] == dis[u] + 1) 
       ans[v] = (ans[v] + ans[u]) % mod;  // 等长路径累加
   ```
   * **亮点**：堆优化保证每次取出当前最短路径点
   * **学习**：优先队列存储`(-距离,节点)`，利用负数实现小根堆

#### 5. 算法可视化：像素动画演示
**像素探险家：最短路寻踪**  
采用8位像素风格（FC红白机配色），通过动画直观展示BFS遍历与路径统计：

![](https://cdn.luogu.com.cn/upload/pic/26623.png)

* **核心流程**：
  1. **场景初始化**：网格地图中节点1亮黄色（起点），其他白色
  2. **BFS扩散**：节点1出队变绿色，邻居节点2/3入队变黄，显示`ans=1`
  3. **路径累加**：节点4首次被节点2访问显示`ans=1`，再被节点3访问时`+1`显示`ans=2`
  4. **终点更新**：节点5被节点4两次访问，路径数动态显示`2→4`

* **交互控制**：
  - **单步执行**：空格键逐步观察路径数更新
  - **速度滑块**：调整BFS扩散速度（0.5x-3x）
  - **高亮显示**：当前处理节点闪烁红光，更新路径时显示`+X`绿色数字

* **音效设计**：
  - 节点入队：8-bit "叮"声（频率随距离增加）
  - 路径累加：硬币收集音效
  - 完成动画：超级马里奥过关音乐

* **技术实现**：  
  Canvas绘制网格图，每帧更新时：
  ```js
  function drawNode(x, y, state) {
    // 状态色：0=白(未访问) 1=黄(队列中) 2=绿(已处理)
    const colors = [0xFFFFFF, 0xFFFF00, 0x00FF00];
    drawPixel(x, y, colors[state]);
    
    if (isUpdating) {  // 路径数更新特效
      drawText(x, y+1, `+${delta}`, 0x00FF00);
      playSound('coin'); 
    }
  }
  ```

#### 6. 拓展练习与相似问题思考
1. **技巧迁移**：
   - 带权图路径统计（如P1608）：Dijkstra+路径计数
   - 网格图最短路径（P1354）：BFS方向受限版
   - 多起点最短路计数：超级源点+相同算法

2. **洛谷推荐**：
   - P1608 路径统计（带权图的最短路计数）
   - P1354 房间最短路问题（网格图应用）
   - P1144 最短路计数（本题，巩固基础）

#### 7. 学习心得与经验分享
> **岸芷汀兰的调试经验**："处理边界条件时要特别注意起点`ans[1]=1`的初始化，否则全盘皆错"
> 
> **Kay点评**：这提醒我们算法"边界条件决定成败"，类似数学归纳法中n=1的基础步骤。建议编码后立即用样例验证起点和终点的输出。

#### 结语
通过BFS的分层特性，我们高效解决了最短路计数问题。关键要把握"路径数=前驱路径数之和"的核心思想，并善用取模避免溢出。在像素动画的复古探险中，希望各位能直观感受算法之美！下次我们继续探索图论迷宫，保持好奇，编程不息！🚀

---
处理用时：176.29秒
# 题目信息

# Dropping Test

## 题目描述

在某个课程中，你需要进行 $n$ 次测试。 

如果你在共计 $b_i$ 道题的测试 $i$ 上的答对题目数量为 $a_i$，你的累积平均成绩就被定义为

$$100\times \dfrac{\displaystyle \sum_{i=1}^n a_i}{\displaystyle \sum_{i=1}^n b_i}$$

给定您的考试成绩和一个正整数 $k$，如果您被允许放弃任何 $k$ 门考试成绩，您的累积平均成绩的可能最大值是多少。

假设您进行了 $3$ 次测试，成绩分别为 $5/5,0/1$ 和 $2/6$。

在不放弃任何测试成绩的情况下，您的累积平均成绩是

$$100\times \frac{5+0+2}{5+1+6} \approx 58.33 \approx 58$$

然而，如果你放弃第三门成绩，则您的累积平均成绩就变成了

$$100\times \frac{5+0}{5+1}\approx 83.33\approx 83$$

## 说明/提示

数据范围 $1 \le n \le 1000$, $0 \le k < n$, $0 \le a_i \le b_i \le 10^9$。

## 样例 #1

### 输入

```
3 1
5 0 2
5 1 6
4 2
1 2 7 9
5 6 7 9
0 0```

### 输出

```
83
100```

# AI分析结果

# 💡 Kay的C++算法解析：Dropping Test 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（分数规划） + 二分查找  

🗣️ **初步分析**：  
解决“Dropping Test”的关键，是把“求最大平均成绩”转化为“猜答案+验证”的游戏——这就是**分数规划**的核心思想！比如，你想知道自己最多能考83分（像样例那样），可以先猜“我能考83分”，然后验证：有没有办法放弃k门考试，让剩下的sum(a)/sum(b)≥0.83（因为83=100×0.83）。  

具体来说，分数规划帮我们把“比值最大化”问题变简单：假设我们猜一个平均成绩对应的比值y（比如0.83），那么要满足`sum(a_i)/sum(b_i) ≥ y`。因为sum(b_i)是考试的总题数（肯定是正数），我们可以把式子变形为`sum(a_i - y×b_i) ≥ 0`——这一步是关键！接下来，**贪心选择**最大的n−k个`a_i - y×b_i`之和，如果这个和≥0，说明y是可行的，我们可以再猜更高的y；否则，得猜更低的y。  

整个过程就像“调整天平”：用**二分查找**快速缩小y的范围，直到找到最大的可行y。最后把y×100四舍五入，就是答案啦！  

**可视化设计思路**：我们会做一个“分数规划小侦探”的8位像素动画——  
- 用像素块展示每个考试的a_i（红色）和b_i（蓝色）；  
- 二分进度条显示当前猜测的y值（比如0.5→0.8→0.83）；  
- 计算`a_i - y×b_i`时，像素块下方会弹出数值标签；  
- 排序时，像素块会“滑动”到对应位置（大的排前面）；  
- 选择前n−k个时，这些像素块会闪烁并播放“叮”的音效；  
- 二分结束时，小侦探会跳起来，播放胜利音效，界面显示最终成绩（比如83）。  


## 2. 精选优质题解参考

### 题解一：来源：__Cyn__（赞19）  
* **点评**：这份题解像“解题钥匙”——直接点出了分数规划的核心变形和二分的应用，语言简洁到“一句话击中本质”。虽然没给完整代码，但思路的提炼非常到位，适合快速理解问题核心。  

### 题解二：来源：Z_AuTwT（赞6）  
* **点评**：这份题解是“从思路到代码的完整地图”！不仅解释了分数规划的逻辑，还给出了可运行的代码：用结构体存储考试成绩，check函数判断y是否可行，work函数计算实际成绩。代码结构清晰，甚至考虑了“重新计算sum(a)和sum(b)”的细节，实践价值很高。  

### 题解三：来源：xuchuhan（赞4）  
* **点评**：这份题解是“严谨的数学推导手册”！从“求最大S”到“猜p值”再到“sum(a_i−p×b_i)≥0”，每一步都讲得明明白白。代码里的`eps=1e-9`（保证二分精度）、`int(l×100+0.5)`（四舍五入）等细节，体现了作者的严谨——这正是编程中最宝贵的习惯！  


## 3. 核心难点辨析与解题策略

### 关键点1：如何把“比值问题”变“线性问题”？  
**分析**：原问题是求`sum(a')/sum(b')`的最大值，直接算很难。分数规划帮我们把它转化为“猜y→验证sum(a_i−y×b_i)≥0”——因为sum(b')是正数，变形完全等价！这一步是“把复杂问题拆成简单问题”的典范。  
💡 **学习笔记**：分数规划的“魔法”在于代数变形，把比值变成线性和。  

### 关键点2：如何验证“猜的y是否可行”？  
**分析**：要让sum(a_i−y×b_i)≥0，肯定要选最大的n−k个`a_i−y×b_i`——就像你要凑够100分，肯定先挑分高的题做！排序后取前n−k个之和，就能快速判断y是否可行。  
💡 **学习笔记**：贪心是分数规划的“验证工具”，选最大的元素总和永远是最优的。  

### 关键点3：二分的精度和边界怎么处理？  
**分析**：实数二分需要设置“足够小的误差”（比如`1e-7`），否则会算错；同时，y的范围要合理——因为a_i≤b_i（答对的题数不超过总题数），所以y最大是1（100分），最小是0。  
💡 **学习笔记**：实数二分的精度要“够细”，上下界要“覆盖所有可能”。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了多份优质题解的思路，是一份“清晰、完整、能直接运行”的核心实现。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const double eps = 1e-7; // 二分精度
int n, k;
vector<double> a, b;

// 验证当前y是否可行：选最大的n−k个(a_i−y×b_i)之和≥0？
bool check(double y) {
    vector<double> c;
    for (int i = 0; i < n; ++i) {
        c.push_back(a[i] - y * b[i]);
    }
    sort(c.begin(), c.end(), greater<double>()); // 从大到小排序
    double sum = 0;
    for (int i = 0; i < n - k; ++i) {
        sum += c[i];
    }
    return sum >= -eps; // 允许微小误差（浮点计算会有偏差）
}

int main() {
    while (cin >> n >> k && (n != 0 || k != 0)) { // 多组数据，直到n和k都为0
        a.resize(n);
        b.resize(n);
        for (int i = 0; i < n; ++i) cin >> a[i];
        for (int i = 0; i < n; ++i) cin >> b[i];
        
        double l = 0.0, r = 1.0; // y的范围：0（0分）到1（100分）
        for (int iter = 0; iter < 100; ++iter) { // 迭代100次足够精确
            double mid = (l + r) / 2.0;
            if (check(mid)) {
                l = mid; // 可行，试试更大的y
            } else {
                r = mid; // 不可行，试试更小的y
            }
        }
        cout << (int)(l * 100 + 0.5) << endl; // 四舍五入：比如0.8333→83
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 读取多组数据：直到输入n=0且k=0为止；  
  2. 二分查找y：从0到1迭代100次，每次猜中间值mid；  
  3. 验证mid：计算每个`a_i−mid×b_i`，排序后取前n−k个之和，判断是否≥0；  
  4. 输出结果：把最大的y乘以100，四舍五入后输出。  


### 题解一：来源：__Cyn__（赞19）  
* **亮点**：一句话点破问题本质，思路“快准狠”。  
* **核心代码片段（思路转化）**：  
```cpp
// 原问题：max sum(a_i)/sum(b_i)
// 转化为：二分y，判断sum(a_i−y×b_i)≥0（选最大的n−k个）
```
* **代码解读**：  
  这行注释是整个问题的“解题密码”！比如样例中y=0.8333（对应83分），计算每个`a_i−0.8333×b_i`：  
  - 第1门：5−0.8333×5=5−4.1665=0.8335；  
  - 第2门：0−0.8333×1=−0.8333；  
  - 第3门：2−0.8333×6=2−5.0=−3.0；  
  排序后选前2个（n−k=3−1=2），和为0.8335−0.8333=0.0002≥0——所以y=0.8333可行！  

* **学习笔记**：分数规划的“灵魂”是代数变形，把比值问题变成线性和问题。  


### 题解二：来源：Z_AuTwT（赞6）  
* **亮点**：用work函数计算实际成绩，考虑周到。  
* **核心代码片段**：  
```cpp
double work(double ans) {
    double sum_a = 0, sum_b = 0;
    // 重新计算保留的a_i和b_i之和（避免浮点误差）
    for (int i = 1; i <= n; ++i) {
        b[i].a = arr[i].Yes - ans * arr[i].Sum;
        b[i].id = i;
    }
    sort(b + 1, b + n + 1, cmp); // 按a_i−ans×b_i从大到小排序
    for (int i = 1; i <= n - k; ++i) {
        sum_a += arr[b[i].id].Yes;
        sum_b += arr[b[i].id].Sum;
    }
    return 100.0 * sum_a / sum_b;
}
```
* **代码解读**：  
  二分得到的y是`sum(a')/sum(b')`的最大值，但浮点计算可能有误差。work函数重新计算保留的a_i和b_i之和，直接算出实际的平均成绩——这是“严谨的细节”！比如样例中，保留第1、2门，sum_a=5+0=5，sum_b=5+1=6，5/6≈0.8333，乘以100就是83分。  

* **学习笔记**：编程要“想全细节”，浮点误差可能让结果差1分！  


### 题解三：来源：xuchuhan（赞4）  
* **亮点**：精度控制和四舍五入处理“滴水不漏”。  
* **核心代码片段**：  
```cpp
const double eps = 1e-9; // 更严格的精度
// ...
printf("%d\n", int(l * 100 + 0.5)); // 四舍五入
```
* **代码解读**：  
  eps=1e-9比1e-7更“细”，确保二分结果足够准确；四舍五入时，`l×100+0.5`是小技巧——比如l=0.8333，0.8333×100=83.33，加0.5得83.83，取整为83；如果l=0.835，加0.5得84.0，取整为84，完全符合题目要求！  

* **学习笔记**：细节决定成败，精度和四舍五入不能马虎。  


## 5. 算法可视化：像素动画演示方案

### 动画演示主题  
**“分数规划小侦探”——8位像素风的猜答案游戏**  

### 核心演示内容  
展示“猜y→验证→调整y”的完整过程，比如样例中的“放弃第3门，得到83分”。  

### 设计思路  
用8位像素风格（类似FC游戏）降低学习压力，用音效和互动强化记忆：  
- 像素块代表考试：红色数字是a_i（答对题数），蓝色是b_i（总题数）；  
- 二分进度条：显示当前猜的y值（比如从0→0.5→0.8→0.83）；  
- 音效提示：二分调整时“滴滴”响，验证通过时“叮”一声，胜利时播放“哇哦”的8位音乐。  


### 动画帧步骤  
1. **场景初始化**：  
   屏幕左侧是3个像素考试块（样例数据：5/5、0/1、2/6），右侧是二分进度条（0→1），下方有“开始”“单步”“重置”按钮，背景播放8位轻快BGM。  

2. **第一次猜y=0.5**：  
   - 计算每个`a_i−0.5×b_i`：第1门=5−2.5=2.5，第2门=0−0.5=−0.5，第3门=2−3=−1；  
   - 排序：2.5→−0.5→−1，选前2个，和为2.5−0.5=2≥0；  
   - 进度条向右移动到0.75（因为y=0.5可行，试试更大的）。  

3. **第二次猜y=0.75**：  
   - 计算：第1门=5−3.75=1.25，第2门=0−0.75=−0.75，第3门=2−4.5=−2.5；  
   - 选前2个，和为1.25−0.75=0.5≥0；  
   - 进度条继续右移到0.875。  

4. **最终猜y=0.8333**：  
   - 计算：第1门=0.8335，第2门=−0.8333，第3门=−3.0；  
   - 选前2个，和为0.0002≥0；  
   - 进度条停止，小侦探跳起来，播放胜利音效，屏幕显示“83分”！  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
分数规划（01分数规划）是“比值最大化”问题的“万能钥匙”，比如：  
- 选k个项目，让“总收益/总成本”最大；  
- 选k条边，让“总权重/总长度”最大；  
- 选k个任务，让“总价值/总时间”最大。  


### 练习推荐（洛谷）  
1. **洛谷 P3199 [HNOI2009]最小圈**：  
   🗣️ **推荐理由**：分数规划求“最小圈”（比值最小），是分数规划的经典变形。  
2. **洛谷 P2868 [USACO07DEC]Sightseeing Cows G**：  
   🗣️ **推荐理由**：用分数规划求“最大比值路径”，需要结合SPFA算法，锻炼综合能力。  
3. **洛谷 P1412 经营与开发**：  
   🗣️ **推荐理由**：分数规划+动态规划，考察“多算法结合”的能力。  


## 7. 学习心得与经验分享 (若有)

> **参考经验（来自__Creeper__）**：“我一开始想用纯贪心（按a_i/b_i排序），结果被老师hack了！后来才知道，纯贪心的排序是固定的，而分数规划要根据不同的y重新排序——这就是两者的区别！”  

**点评**：这位作者的经验很真实！比如考试1：a=3，b=5（0.6），考试2：a=4，b=7（0.571）——当y=0.45时，考试2的`a_i−y×b_i=4−3.15=0.85`，比考试1的0.75大，这时候纯贪心（按a_i/b_i排序选考试1）就错了！分数规划的“动态排序”才是正确的。  


## 结语  
本次分析让我们学会了用“分数规划+二分查找”解决“比值最大化”问题——关键是把复杂的比值问题变简单，再用贪心和二分快速验证。  

记住：编程的乐趣在于“把难题拆成小问题”，而分数规划就是这样的“拆题工具”！多做类似题目，你会越来越熟练~  

下次我们再一起探索新的编程挑战！💪

---
处理用时：205.11秒
# 题目信息

# [KOI 2021 Round 2] 累计距离

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 国是一个由 $N$ 个村庄构成的国家，这些村庄分布在数轴上。其中第 $i$ 个村庄（$1 \leq i \leq N$）位于位置 $x_i$，并有 $a_i$ 名居民。不会有两个不同村庄位于相同的位置。

KOI 国计划召开一场所有国民都要参加的大会。为此，所有人需要前往会议举办地点，所有人前往该地点所需的移动距离之和称为“累计距离”，我们用 $f(x)$ 表示当会议举办地点为 $x$ 时的累计距离。

住在第 $i$ 个村庄的人前往位置为 $x$ 的会议地点时，需要移动的距离为 $|x_i - x|$。由于第 $i$ 个村庄有 $a_i$ 名居民，因此该村居民所需的总移动距离为 $a_i \times |x_i - x|$。

将所有村庄的该值加总，即可得到在位置 $x$ 举办会议时的累计距离：

$$
f(x) = \sum_{i=1}^{N} a_i \times |x_i - x|
$$

例如，若村庄的位置为 $x_1 = 1$、$x_2 = 3$、$x_3 = 6$，各村庄的居民数分别为 $a_1 = 2$、$a_2 = 1$、$a_3 = 3$，当会议地点为 $x = 4$ 时，累计距离为：

$$
f(4) = 2 \times |1 - 4| + 1 \times |3 - 4| + 3 \times |6 - 4| = 13
$$

KOI 国已经准备了 $Q$ 个会议地点候选位置。第 $j$ 个候选位置（$1 \leq j \leq Q$）为 $q_j$。多个候选位置之间不会重复，但候选位置可能与某个村庄位置相同。

请编写程序，计算每一个候选会议地点 $q_j$ 的累计距离 $f(q_j)$。

## 说明/提示

**约束条件**

- $1 \leq N \leq 200\,000$
- 对于所有 $i$（$1 \leq i \leq N$），$1 \leq a_i \leq 1\,000$
- 对于所有 $i$，$-10^9 \leq x_i \leq 10^9$
- $1 \leq Q \leq 200\,000$
- 对于所有 $j$，$-10^9 \leq q_j \leq 10^9$
- 对任意 $1 \leq i_1 < i_2 \leq N$，$x_{i_1} \ne x_{i_2}$（村庄位置各不相同）
- 对任意 $1 \leq j_1 < j_2 \leq Q$，$q_{j_1} \ne q_{j_2}$（候选位置各不相同）
- 所有给定数值均为整数

**子任务**

1. （9 分）$N,Q \leq 5\,000$
2. （21 分）对所有 $i$，满足 $1 \leq x_i \leq 200\,000$，且对所有 $j$，满足 $1 \leq q_j \leq 200\,000$
3. （25 分）对所有 $i$，$a_i = 1$
4. （45 分）无额外约束条件

## 样例 #1

### 输入

```
3 1
2 1
1 3
3 6
4```

### 输出

```
13```

## 样例 #2

### 输入

```
4 5
3 -4
1 -10
2 11
4 6
6
-5
1
-12
14```

### 输出

```
56
84
66
144
116```

# AI分析结果

# 💡 Kay的C++算法解析：累计距离 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学推导 + 前缀和 + 二分查找  

🗣️ **初步分析**：  
想象一下——数轴上散落着几堆糖果，每堆有不同数量的糖果（对应村庄的居民数`a_i`），位置各不相同（对应`x_i`）。现在要把所有糖果搬到某个位置`q`，总搬运距离就是**每堆糖果数 × 堆到`q`的距离**之和。直接算每颗糖果的距离太慢（像用勺子舀大海），我们需要**“批量计算”**的技巧：  

1. **数学化简**：把绝对值拆成两部分——左边（`x_i ≤ q`）的距离是`q - x_i`，右边（`x_i > q`）是`x_i - q`。总和可以写成：  
   $$f(q) = q \times \sum_{x_i ≤ q}a_i - \sum_{x_i ≤ q}a_i x_i + \sum_{x_i > q}a_i x_i - q \times \sum_{x_i > q}a_i$$  
2. **前缀和优化**：预处理两个数组——`sa[i]`（前`i`堆糖果的总数）、`sax[i]`（前`i`堆糖果的`a_i x_i`总和）。这样左边的总和可以直接用`sa`和`sax`计算，不用重复遍历。  
3. **二分查找**：对每个`q`，快速找到**第一个大于`q`的糖果堆位置**（记为`r`），这样左边是`0~r-1`，右边是`r~n-1`，瞬间拆分两部分。  


### 核心算法流程与可视化设计  
- **排序**：把糖果堆按位置从左到右排好（像整理书架），对应动画中“彩色方块按数轴移动”，伴随“沙沙”的排序音效。  
- **前缀和**：底部显示两个进度条，分别代表`sa`和`sax`的积累（每加一堆糖果，进度条涨一截），伴随“滴滴”声。  
- **查询处理**：`q`用黄色闪烁方块标记，二分查找时红色箭头指向当前`mid`位置（“嗒嗒”声），找到`r`后左边变蓝、右边变红，分别显示计算式（蓝色：`q×sa[r]-sax[r]`，红色：`(sax[n]-sax[r])-q×(sa[n]-sa[r])`），最后总和用绿色显示，伴随“叮”的音效。  


## 2. 精选优质题解参考

为你筛选了**思路清晰、代码简洁、实用性强**的3份题解：


### 题解一：来源Sunrise_up  
**点评**：从“暴力超时”到“排序+前缀和+二分”的推导过程非常透彻，像“手把手教你优化”。代码用**索引排序**代替结构体（避免内存开销），还加了快读优化（适合竞赛大数据）。二分边界处理精准（找第一个大于`q`的位置），是“竞赛向”的优秀题解。


### 题解二：来源Ghosty_Neutrino  
**点评**：代码结构像“教科书”——用结构体存储`a`和`x`，`sort`排序后直接用`lower_bound`找分割点（避免手动写二分的麻烦）。输入输出用`ios::sync_with_stdio(false)`优化，适合处理`2e5`级别的数据，可读性极强。


### 题解三：来源guoshengyu1231  
**点评**：用`pair`存储位置和居民数，排序后预处理前缀和，代码简洁得像“一句话总结”。二分查找用`lower_bound`找`x`的位置后减1，确保左边是所有≤`q`的村庄，边界处理“稳准狠”。


## 3. 核心难点辨析与解题策略

### 关键点1：如何拆分绝对值式子？  
**难点**：绝对值让每一项的计算方向不同，直接求和太慢。  
**策略**：利用绝对值性质，拆成**左边（`x_i ≤ q`）**和**右边（`x_i > q`）**两部分，分别计算再相加。  
**学习笔记**：数学化简是“批量计算”的前提，遇到绝对值先想“拆分”！


### 关键点2：如何避免重复计算？  
**难点**：每个查询都遍历所有村庄，时间复杂度是`O(nq)`，直接超时。  
**策略**：预处理**前缀和数组**`sa`（居民总数）和`sax`（`a_i x_i`总和），把每段的和“提前算好”，查询时直接取结果。  
**学习笔记**：前缀和是“以空间换时间”的经典技巧，适合“多次查区间和”的场景。


### 关键点3：如何快速找分割点？  
**难点**：手动找`q`的位置要遍历所有村庄，太慢。  
**策略**：用**二分查找**找第一个大于`q`的位置`r`，时间复杂度`O(log n)`。注意：`q`等于某个村庄位置时，要归到左边！  
**学习笔记**：数据有序时，二分是“定位”的神器，边界条件要“手动模拟测试用例”验证。


### ✨ 解题技巧总结  
1. **式子化简**：遇到绝对值/复杂求和，先拆成可批量计算的部分；  
2. **前缀和**：预处理区间和，把`O(n)`查询变成`O(1)`；  
3. **二分查找**：有序数据中快速定位，降低时间复杂度；  
4. **数据类型**：用`long long`存储`sa`和`sax`，避免乘积溢出！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
**说明**：综合3份优质题解的思路，兼顾可读性和效率，适合初学者理解。  

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;

struct Village {
    ll a, x;
    bool operator<(const Village& other) const {
        return x < other.x; // 按位置排序
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    
    int n, q;
    cin >> n >> q;
    vector<Village> villages(n);
    for (int i = 0; i < n; ++i) {
        cin >> villages[i].a >> villages[i].x;
    }
    
    sort(villages.begin(), villages.end()); // 排序村庄
    
    // 预处理前缀和：sa[i]是前i个村庄的居民总数，sax[i]是前i个村庄的a*x总和
    vector<ll> sa(n + 1, 0), sax(n + 1, 0);
    for (int i = 0; i < n; ++i) {
        sa[i + 1] = sa[i] + villages[i].a;
        sax[i + 1] = sax[i] + villages[i].a * villages[i].x;
    }
    
    while (q--) {
        ll qr;
        cin >> qr;
        // 找第一个x > qr的位置（lower_bound找>=qr的位置）
        int r = lower_bound(villages.begin(), villages.end(), Village{0, qr}) - villages.begin();
        ll left = qr * sa[r] - sax[r]; // 左边总距离
        ll right = (sax[n] - sax[r]) - qr * (sa[n] - sa[r]); // 右边总距离
        cout << left + right << '\n';
    }
    
    return 0;
}
```

**代码解读概要**：  
1. 输入村庄信息，按位置排序；  
2. 预处理`sa`（居民总数）和`sax`（`a*x`总和）；  
3. 对每个查询`qr`，用`lower_bound`找分割点`r`；  
4. 计算左边（`qr×sa[r] - sax[r]`）和右边（`(sax[n]-sax[r]) - qr×(sa[n]-sa[r])`）的距离，输出总和。


### 题解一（Sunrise_up）：索引排序优化  
**亮点**：用索引代替结构体，减少内存开销。  
**核心代码片段**：  
```cpp
vector<int> p(n);
for (int i = 0; i < n; ++i) p[i] = i + 1; // 存储村庄索引
sort(p.begin(), p.end(), [&](int i, int j) { return x[i] < x[j]; }); // 按x排序索引
for (int i = 0; i < n; ++i) {
    int j = p[i];
    sa[i + 1] = sa[i] + a[j];
    sax[i + 1] = sax[i] + a[j] * x[j];
}
```  
**代码解读**：  
用`vector<p>`存储村庄的索引，按`x`排序后，遍历索引计算前缀和。这种方法避免了结构体的拷贝，适合`a`和`x`已经存在数组中的场景，内存更高效。  
**学习笔记**：索引排序是“竞赛小技巧”，能省内存！


### 题解二（Ghosty_Neutrino）：lower_bound简化二分  
**亮点**：用`lower_bound`直接找分割点，避免手动写二分。  
**核心代码片段**：  
```cpp
struct D {
    ll x, a;
    bool operator<(const D& w) const { return x < w.x; }
};
vector<D> v(n);
for (int i = 0; i < n; ++i) cin >> v[i].a >> v[i].x;
sort(v.begin(), v.end());
int k = lower_bound(v.begin(), v.end(), D{qr, 0}) - v.begin();
```  
**代码解读**：  
结构体`D`存储`x`和`a`，`sort`排序后，`lower_bound`找到第一个`x >= qr`的位置`k`，左边是`0~k-1`，右边是`k~n-1`。`lower_bound`帮你“自动处理二分”，减少出错可能。  
**学习笔记**：`lower_bound`是“二分偷懒神器”，但要先确保数据有序！


### 题解三（guoshengyu1231）：pair存储与二分  
**亮点**：用`pair`存储位置和居民数，代码简洁。  
**核心代码片段**：  
```cpp
pair<int, int> a[maxn];
for (int i = 1; i <= n; ++i) cin >> a[i].second >> a[i].first; // first是x，second是a
sort(a + 1, a + n + 1); // 按x排序
int pos = lower_bound(sx + 1, sx + n + 1, x) - sx - 1; // 找左边的最后一个位置
```  
**代码解读**：  
`pair`的`first`存位置`x`，`second`存居民数`a`，排序后用`lower_bound`找`x`的位置，减1得到左边的最后一个村庄。这种写法把“位置”单独存在`sx`数组中，查找更高效。  
**学习笔记**：`pair`是“轻量级结构体”，适合简单的数据存储！


## 5. 算法可视化：像素动画演示方案

### 动画主题：像素村庄的“会议选址大挑战”  
**设计思路**：用8位像素风还原问题场景，音效强化记忆，游戏化关卡增加成就感——比如排序像“整理书架”，预处理像“攒积分”，查询像“找宝藏”。


### 核心演示内容  
1. **场景初始化**：  
   - 8位像素数轴背景，村庄用**不同大小的彩色方块**表示（大=人多，红=位置大，蓝=位置小）；  
   - 底部有两个进度条（绿色=sa，蓝色=sax），右侧是控制面板（开始/暂停、单步、重置、速度滑块）；  
   - 播放轻松的8位背景音乐（像FC游戏的BGM）。

2. **排序环节**：  
   - 点击“开始”，村庄按`x`从小到大移动，伴随“沙沙”的排序音效，每个村庄到位时闪烁。

3. **预处理前缀和**：  
   - 排序完成后，进度条开始“涨”：每加一个村庄，绿色进度条（sa）和蓝色进度条（sax）各涨一截，伴随“滴滴”声，直到满格。

4. **查询环节**：  
   - 输入查询`q`，`q`用**黄色闪烁方块**标记在数轴上；  
   - 点击“单步”，红色箭头指向当前`mid`位置（伴随“嗒嗒”声），找到`r`后：  
     - 左边村庄变**蓝色**，右边变**红色**；  
     - 屏幕显示计算式：蓝色数字`qr×sa[r]-sax[r]`（左边），红色数字`(sax[n]-sax[r])-qr×(sa[n]-sa[r])`（右边）；  
     - 总和用**绿色大字体**显示，伴随“叮”的成功音效。

5. **游戏化关卡**：  
   - 每完成一个查询，屏幕弹出“Level Up!”的像素动画，累计关卡数（比如“通关5次”解锁“快速播放”模式），增加成就感。


### 交互与控制  
- **单步/自动**：支持“一步一步看”（单步）或“自动播放”（速度滑块调快慢）；  
- **重置**：回到初始状态，重新开始；  
- **音效开关**：可以关闭背景音乐，只保留关键操作的音效。


## 6. 拓展练习与相似问题

### 通用思路迁移  
本题的“式子化简+前缀和+二分”可以解决以下问题：  
1. **加权中位数**：找一个点，让加权距离之和最小（本题的“逆问题”）；  
2. **区间覆盖次数**：查询一个点被多少区间覆盖（前缀和+二分）；  
3. **数的排名**：查询一个数在有序数组中的排名（前缀和+二分）。


### 洛谷推荐练习  
1. **P1496 火烧赤壁**：区间合并+前缀和，练习“排序后批量计算”；  
2. **P1102 A-B 数对**：二分查找+前缀和，练习“快速定位目标值”；  
3. **P2249 查找**：二分查找模板题，练习“边界处理”；  
4. **P3374 树状数组1**：树状数组+前缀和，练习“更高效的区间和查询”。


## 7. 学习心得与经验分享

**参考经验（来自Sunrise_up）**：  
“我最初在二分边界卡了很久——比如`q`等于某个村庄的位置时，到底归左边还是右边？后来我手动模拟了3个测试用例（`q`在最左、中间、最右），才明确要找**第一个大于`q`的位置**。”  

**Kay的点评**：  
二分的边界处理像“走钢丝”，**手动模拟测试用例**是最有效的排错方法！另外，`long long`是“必选项”——`a_i×x_i`的乘积可能达到`1e3×1e9=1e12`，用`int`会直接溢出（别问我怎么知道的😅）。


## 8. 总结  
本次分析覆盖了“累计距离”的**数学推导、前缀和优化、二分查找**三大核心技巧。记住：  
- 遇到复杂求和，先**化简式子**；  
- 多次查区间和，用**前缀和**；  
- 有序数据定位，用**二分查找**；  
- 大数要加**long long**！  

继续练习类似的问题，这些技巧会变成你的“本能”——下次遇到“数轴求和”问题，你会立刻想到“排序+前缀和+二分”！💪  

下次我们再一起挑战更难的算法题～

---
处理用时：182.27秒
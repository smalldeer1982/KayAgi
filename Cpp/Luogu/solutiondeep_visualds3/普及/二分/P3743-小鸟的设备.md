# 题目信息

# 小鸟的设备

## 题目背景

小鸟有 $n$ 个可同时使用的设备。


## 题目描述

第 $i$ 个设备每秒消耗 $a_i$ 个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在 $k$ 秒内消耗的能量均为 $k\times a_i$ 单位。在开始的时候第 $i$ 个设备里存储着 $b_i$ 个单位能量。

同时小鸟又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 $p$ 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。

小鸟想把这些设备一起使用，直到其中有设备能量降为  $0$。所以小鸟想知道，在充电器的作用下，她最多能将这些设备一起使用多久。

## 说明/提示

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq p\leq 100000$，$1\leq a_i,b_i\leq100000$。


## 样例 #1

### 输入

```
2 1
2 2
2 1000
```

### 输出

```
2.0000000000```

## 样例 #2

### 输入

```
1 100
1 1```

### 输出

```
-1 ```

## 样例 #3

### 输入

```
3 5
4 3
5 2
6 1```

### 输出

```
0.5000000000 ```

# AI分析结果


### 💡 Kay的C++算法解析：小鸟的设备 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：二分答案 + 贪心验证  
🗣️ **初步分析**：
> 这道题就像管理一个多设备充电站：每个设备有初始电量和耗电速度，充电宝只能同时给一个设备充电。我们的目标是找到所有设备能持续工作的最长时间。  
> - **核心思路**：通过二分法猜测时间t，再用贪心策略验证t是否可行。如果总耗电速度≤充电速度，则输出-1（无限使用）  
> - **算法流程**：  
>   1. 计算总耗电速度sum，若sum≤p则输出-1  
>   2. 二分时间t∈[0, 1e10]  
>   3. 验证函数：计算所有设备在t时间内的缺额能量Σmax(0, aᵢ*t-bᵢ)  
>   4. 若缺额能量≤p*t则t可行  
> - **可视化设计**：采用8位像素风格（类似FC游戏），设备显示为彩色方块，充电时闪烁蓝光，电量不足时变红。关键帧高亮当前验证的t值和设备缺额计算过程。

---

#### 精选优质题解参考
**题解一（作者：qq1010903229）**  
* **点评**：代码简洁高效，验证函数逻辑清晰（10行完成核心计算）。变量命名规范（sum/lbound/rbound），边界处理严谨（1e6精度控制）。亮点在于用continue跳过充足电量的设备，减少计算量。  

**题解二（作者：Konnyaku_LXZ）**  
* **点评**：对贪心策略解释透彻，强调"无需充电"的临界条件（aᵢ*t≤bᵢ）。代码模块化优秀（Init/Solve/Print分离），MAXX常量定义避免魔法数字。调试技巧值得学习：用cost函数封装验证逻辑。  

**题解三（作者：一架飞机）**  
* **点评**：验证函数最精简（7行），用注释明确能量缺额计算逻辑。亮点在于边界设置（r=3e9防止溢出），适合竞赛直接使用。输出保留6位小数满足精度要求。

---

#### 核心难点辨析与解题策略
1. **难点1：验证函数的贪心策略设计**  
   * **分析**：需理解"充电时间可拆分"的特性（非连续充电）。贪心策略：只补足缺额设备，跳过充足设备。  
   * 💡 学习笔记：验证函数本质是能量守恒——总充电量≥总缺额量  

2. **难点2：实数二分的精度控制**  
   * **分析**：循环终止条件`r-l>1e-6`确保1e-4精度。优质题解用固定次数循环（100-200次）避免无限循环。  
   * 💡 学习笔记：二分次数N满足(1e10)/2ᴺ≤1e-6 → N≥50  

3. **难点3：无解特判的陷阱**  
   * **分析**：sum≤p时输出-1，但sum需用double计算（int会溢出）。题解中常见错误：用int存储Σaᵢ  
   * 💡 学习笔记：输入规模1e5时，Σaᵢ≤1e10，必须用double  

### ✨ 解题技巧总结
- **技巧1：避免重复计算**  
  验证函数内及时continue充足设备，减少max(0,...)调用  
- **技巧2：防御性边界设置**  
  右边界r=1e10（2*Σbᵢ可能＞1e9）  
- **技巧3：精度与效率平衡**  
  优先1e-6精度+固定循环次数（100次）  

---

#### C++核心代码实现赏析
**通用核心实现（综合优质题解）**  
```cpp
#include <iostream>
using namespace std;
const int N = 1e5 + 10;
const double eps = 1e-6;

int n;
double p, a[N], b[N];

bool check(double t) {
    double need = 0;
    for (int i = 0; i < n; ++i) {
        if (a[i] * t <= b[i]) continue;
        need += a[i] * t - b[i];
        if (need > p * t) return false;
    }
    return true;
}

int main() {
    cin >> n >> p;
    double sum_a = 0;
    for (int i = 0; i < n; ++i) {
        cin >> a[i] >> b[i];
        sum_a += a[i];
    }
    
    if (sum_a <= p) {
        cout << -1;
        return 0;
    }

    double l = 0, r = 1e10;
    while (r - l > eps) {
        double mid = (l + r) / 2;
        check(mid) ? l = mid : r = mid;
    }
    printf("%.10f", l);
}
```

**题解一核心赏析**  
```cpp
// 亮点：用sum变量双重职责（特判+验证）
int check(double ans) {
    double q = p * ans, sum = 0;
    for (int i = 0; i < n; i++) {
        if (a[i] * ans <= b[i]) continue;  // 跳过充足设备
        sum += (a[i] * ans - b[i]);        // 累加缺额
    }
    return sum <= q;  // 能量守恒判断
}
```
> **代码解读**：  
> - `q=p*ans`：充电宝最大供能  
> - 循环中直接跳过`a[i]*ans≤b[i]`的设备，避免无效计算  
> - 返回判断前未做`sum>q`的提前退出，但因数据规模影响小可接受  

**题解二核心赏析**  
```cpp
// 亮点：独立cost函数+精度常量
const double MINN = 1e-6;
double cost(LL a[], LL b[], double x) {
    double sum = 0;
    for (int i = 1; i <= N; i++) {
        double temp = a[i] * x;
        if (temp > b[i]) sum += temp - b[i];
    }
    return sum;
}
```
> **学习笔记**：封装验证逻辑到`cost()`函数，提高代码复用性。`MINN`常量统一控制精度。

---

#### 算法可视化：像素动画演示
**主题**：*充电大作战*（8位像素风格）  

**设计思路**：  
> 用FC游戏风格降低算法理解门槛。设备显示为彩色方块（颜色=耗电速度），充电时闪烁蓝光，电量低于阈值变红。进度条直观展示二分过程。

**动画流程**：  
1. **初始化**：  
   - 设备排列为像素网格（红/黄/绿方块表示aᵢ大小）  
   - 控制面板：开始/暂停、单步、速度滑块（调速二分过程）  
   - 背景音乐：8位芯片风格BGM  

2. **二分演示**：  
   ```mermaid
   graph LR
   A[当前区间 l-r] --> B{mid可行？}
   B -->|是| C[l=mid] 
   B -->|否| D[r=mid]
   C --> E[显示新区间]
   D --> E
   ```
   - 每次二分时播放"选择"音效  
   - 当前mid值显示在顶部像素字体LED屏  

3. **验证过程**：  
   - 遍历设备时高亮当前方块  
   - 显示实时计算：`缺额 += max(0, aᵢ*t-bᵢ)`  
   - 能量不足时：播放"警告"音效，方块闪烁红色  

4. **胜利条件**：  
   - 找到最终t值时播放胜利音效  
   - 所有设备显示绿色+烟花动画  

**技术实现**：  
- Canvas绘制设备网格  
- 音效：Web Audio API（充电声、警告声、胜利声）  
- 自动演示模式：像"贪吃蛇AI"逐步展示二分  

---

#### 拓展练习与相似问题
**通用技巧迁移**：  
> 二分答案+贪心验证适用于：  
> 1. 满足单调性的最值问题（如：P1182数列分段）  
> 2. 资源分配优化（如：P1577切绳子）  
> 3. 时间规划问题（如：P3740摧毁城市）  

**洛谷推荐**：  
1. **P1182** 数列分段 Section II  
   → *巩固二分答案框架，理解"最大值最小化"*  
2. **P1577** 切绳子  
   → *练习实数二分+精度控制*  
3. **P3740** 摧毁城市  
   → *复杂场景下的贪心验证设计*  

---

#### 学习心得与经验分享
> **经验（来自题解）**：  
> *"我在精度控制上卡了很久，后来发现用固定循环次数比while(r-l>eps)更稳定"*  
> **点评**：这是宝贵实战经验！二分50-100次可避免浮点精度陷阱，尤其适合竞赛环境。

---

### 结语  
通过二分答案+贪心验证，我们优雅地解决了多设备充电问题。记住核心要领：**单调性→二分，验证→贪心**。希望这份指南帮助大家在算法道路上走得更远！💪

---
处理用时：118.72秒
# 题目信息

# 餐巾计划问题

## 题目描述

一个餐厅在相继的 $N$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天需要 $r_i$ 块餐巾（$i = 1, 2, \dots, N$）。餐厅可以购买新的餐巾，每块餐巾的费用为 $p$ 分；或者把旧餐巾送到快洗部，洗一块需 $m$ 天，其费用为 $f$ 分；或者送到慢洗部，洗一块需 $n$ 天（$n \gt m$），其费用为 $s$ 分（$s \lt f$）。

每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。

试设计一个算法为餐厅合理地安排好 $N$ 天中餐巾使用计划，使总的花费最小。编程找出一个最佳餐巾使用计划。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 2 \times 10^3$，$1 \le r_i \le 10^7$，$1 \le p, f, s \le 10^4$。


## 样例 #1

### 输入

```
3
1 7 5 
11 2 2 3 1
```

### 输出

```
134
```

# AI分析结果


### Kay的C++算法解析：餐巾计划问题 深入学习指南 💡

**题目解读与核心算法识别**  
✨ **本题主要考察**：最小费用最大流（MCMF）  
🗣️ **初步分析**：  
> 解决餐巾计划问题的核心在于**网络流建模中的拆点技巧**。想象每天被拆成"早上"（使用干净餐巾）和"晚上"（处理脏餐巾）两个独立节点，通过精心设计的边实现餐巾流转：  
> - **源点→晚上**：提供脏餐巾（容量=当天需求，费用=0）  
> - **早上→汇点**：消耗干净餐巾（容量=当天需求，费用=0）  
> - **晚上→未来早上**：快洗/慢洗（容量=∞，费用=洗涤费）  
> - **源点→早上**：购买新餐巾（容量=∞，费用=购买价）  
> - **晚上→下天晚上**：保存脏餐巾（容量=∞，费用=0）  

**可视化设计思路**：  
采用8位像素风格（类似FC游戏）动态演示：  
1. 每天分早晚两格，干净餐巾绿色💚，脏餐巾灰色⚫  
2. 关键操作高亮：  
   - 购买时源点闪烁💡 + "叮"音效  
   - 洗涤时显示费用💰 + 跳跃动画到未来天  
   - 保存时横向移动动画➡️  
3. 控制面板支持单步/自动播放，调速滑块控制流程  

---

### 精选优质题解参考

**题解一（Mark_ZZY）**  
* **亮点**：  
  清晰图解拆点（6类边），代码完整规范，变量名直白（`f[i]`表状态），空间优化到位（滚动数组）。实践性强，边界处理严谨，可直接用于竞赛。

**题解二（天泽龟）**  
* **亮点**：  
  深度解析"为什么这样建图"，对比常规思路指出易错点（如脏餐巾流向），教学性强。代码结构工整，但变量命名稍乱（`fir`数组）。

**题解三（SCKer）**  
* **亮点**：  
  创新贪心+三分法，独辟蹊径：假设总购买量，贪心求最小费用，三分法优化。复杂度O(n log R)更优，但仅适用特定数据范围。

---

### 核心难点辨析与解题策略

1. **拆点与状态分离**  
   *分析*：必须将每天拆为早上（接收干净餐巾）和晚上（处理脏餐巾）两个节点，这是建模基石。  
   💡 **学习笔记**：拆点法在流量分离问题中应用广泛。

2. **边设计与容量控制**  
   *分析*：6类边需精确对应操作：  
   ```mermaid
   graph LR
   S--脏餐巾-->晚上
   晚上--保存-->下天晚上
   晚上--快洗-->i+m早上
   晚上--慢洗-->i+n早上
   S--购买-->早上
   早上--消耗-->T
   ```
   💡 **学习笔记**：∞容量表示操作无限制，需边界检查（如i+m≤n）。

3. **费用与流量平衡**  
   *分析*：费用边需反映真实成本（购买/洗涤），通过SPFA找最小增广路保证费用最小。  
   💡 **学习笔记**：费用流中反向边费用为负值，这是算法核心。

✨ **解题技巧总结**：  
- **拆点建模**：将时间维度转化为节点关系  
- **边界处理**：洗烘操作需判断i+m/n≤n  
- **贪心优化**：当数据极大时（如ri≤1e7），可考虑三分总购买量+贪心验证  

---

### C++核心代码实现赏析

**通用核心实现**（综合优质题解）：  
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
typedef long long LL;
const LL INF = 1e18;
const int MAXN = 4000;

struct Edge { int to, next; LL cap, cost; } edges[MAXN*6];
int head[MAXN], cnt = 1, pre[MAXN], last[MAXN];
LL dis[MAXN], flow[MAXN]; bool vis[MAXN];

void addEdge(int u, int v, LL cap, LL cost) {
    edges[++cnt] = {v, head[u], cap, cost}; head[u] = cnt;
    edges[++cnt] = {u, head[v], 0, -cost}; head[v] = cnt;
}

bool spfa(int s, int t) {
    memset(dis, 0x3f, sizeof(dis));
    std::queue<int> q; q.push(s);
    dis[s] = 0; vis[s] = 1; flow[s] = INF;
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        for (int i = head[u]; i; i = edges[i].next) {
            int v = edges[i].to;
            if (edges[i].cap > 0 && dis[v] > dis[u] + edges[i].cost) {
                dis[v] = dis[u] + edges[i].cost;
                pre[v] = u; last[v] = i;
                flow[v] = std::min(flow[u], edges[i].cap);
                if (!vis[v]) vis[v] = 1, q.push(v);
            }
        }
    }
    return dis[t] < INF;
}

LL minCostMaxFlow(int s, int t) {
    LL cost = 0;
    while (spfa(s, t)) {
        for (int v = t; v != s; v = pre[v]) {
            edges[last[v]].cap -= flow[t];
            edges[last[v] ^ 1].cap += flow[t];
        }
        cost += flow[t] * dis[t];
    }
    return cost;
}

int main() {
    int n, p, m, f, nn, s_cost; 
    scanf("%d", &n);
    int s = 0, t = 2*n+1;
    for (int i = 1, r; i <= n; i++) {
        scanf("%d", &r);
        addEdge(s, i, r, 0);       // 源点->晚上 (脏餐巾)
        addEdge(i+n, t, r, 0);     // 早上->汇点 (干净餐巾)
    }
    scanf("%d%d%d%d%d", &p, &m, &f, &nn, &s_cost);
    for (int i = 1; i <= n; i++) {
        addEdge(s, i+n, INF, p);   // 购买新餐巾
        if (i < n) addEdge(i, i+1, INF, 0); // 保存脏餐巾
        if (i+m <= n) addEdge(i, i+n+m, INF, f);   // 快洗
        if (i+nn <= n) addEdge(i, i+n+nn, INF, s_cost); // 慢洗
    }
    printf("%lld", minCostMaxFlow(s, t));
}
```

**代码精要**：  
1. **拆点设计**：节点i表晚上，i+n表早上  
2. **关键边**：  
   - 保存脏餐巾：`i→i+1`  
   - 快洗：`i→i+m+n`  
   - 慢洗：`i→i+nn+n`  
3. **SPFA优化**：队列实现费用流核心，反向边自动处理  

---

### 算法可视化：像素动画演示  
**主题**：餐巾流动模拟（8位像素风）  
**关键帧设计**：  
```plaintext
日1 [🌞💚] -> 使用 -> [🌚⚫] 
          ┌─快洗m天─> [日1+m🌞💚]
          └─保存─> [日2🌚⚫]
```
1. **初始化**：显示N×2网格（早/晚），控制面板（开始/暂停/速度）  
2. **每日流程**：  
   - 早上：绿色块从源点流入💚，数量=r_i  
   - 晚上：灰色块出现⚫，流向处理选项  
3. **操作动画**：  
   - 保存：灰色块右移➡️（费用0）  
   - 洗涤：灰色块跳跃到未来天+费用显示💰  
   - 购买：新绿色块出现+“叮”音效🔔  
4. **状态同步**：显示当前费用和剩余流量  

---

### 拓展练习与相似问题
**通用技巧迁移**：  
拆点法还可用于：  
1. 时间分层问题（如"航空路线"）  
2. 状态分离问题（如"晨跑"中的节点访问限制）  

**洛谷推荐**：  
1. [P2153 晨跑](https://www.luogu.com.cn/problem/P2153)  
   → **推荐理由**：巩固拆点技巧，处理节点访问次数限制  
2. [P4009 汽车加油](https://www.luogu.com.cn/problem/P4009)  
   → **推荐理由**：分层图费用流应用，类似餐巾时间跳跃  
3. [P4014 分配问题](https://www.luogu.com.cn/problem/P4014)  
   → **推荐理由**：基础费用流建模，适合理解流量分配  

---

### 学习心得
题解中作者调试经验值得借鉴：  
> "最初在状态转移设计上卡壳，通过打印每日流量分布发现建图错误"  
> → **启示**：费用流调试可输出中间流量，验证是否符合预期流转  

---

**结语**：餐巾计划问题完美展示了网络流建模的艺术。掌握拆点技巧和边设计思维，即可将复杂时序问题转化为优雅的图论模型。下次遇到资源调度问题时，不妨想想：能否用流量表示资源？时间能否变为节点？💪

---
处理用时：155.86秒
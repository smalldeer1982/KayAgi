# 题目信息

# [KOI 2021 Round 2] 累计距离

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

KOI 国是一个由 $N$ 个村庄构成的国家，这些村庄分布在数轴上。其中第 $i$ 个村庄（$1 \leq i \leq N$）位于位置 $x_i$，并有 $a_i$ 名居民。不会有两个不同村庄位于相同的位置。

KOI 国计划召开一场所有国民都要参加的大会。为此，所有人需要前往会议举办地点，所有人前往该地点所需的移动距离之和称为“累计距离”，我们用 $f(x)$ 表示当会议举办地点为 $x$ 时的累计距离。

住在第 $i$ 个村庄的人前往位置为 $x$ 的会议地点时，需要移动的距离为 $|x_i - x|$。由于第 $i$ 个村庄有 $a_i$ 名居民，因此该村居民所需的总移动距离为 $a_i \times |x_i - x|$。

将所有村庄的该值加总，即可得到在位置 $x$ 举办会议时的累计距离：

$$
f(x) = \sum_{i=1}^{N} a_i \times |x_i - x|
$$

例如，若村庄的位置为 $x_1 = 1$、$x_2 = 3$、$x_3 = 6$，各村庄的居民数分别为 $a_1 = 2$、$a_2 = 1$、$a_3 = 3$，当会议地点为 $x = 4$ 时，累计距离为：

$$
f(4) = 2 \times |1 - 4| + 1 \times |3 - 4| + 3 \times |6 - 4| = 13
$$

KOI 国已经准备了 $Q$ 个会议地点候选位置。第 $j$ 个候选位置（$1 \leq j \leq Q$）为 $q_j$。多个候选位置之间不会重复，但候选位置可能与某个村庄位置相同。

请编写程序，计算每一个候选会议地点 $q_j$ 的累计距离 $f(q_j)$。

## 说明/提示

**约束条件**

- $1 \leq N \leq 200\,000$
- 对于所有 $i$（$1 \leq i \leq N$），$1 \leq a_i \leq 1\,000$
- 对于所有 $i$，$-10^9 \leq x_i \leq 10^9$
- $1 \leq Q \leq 200\,000$
- 对于所有 $j$，$-10^9 \leq q_j \leq 10^9$
- 对任意 $1 \leq i_1 < i_2 \leq N$，$x_{i_1} \ne x_{i_2}$（村庄位置各不相同）
- 对任意 $1 \leq j_1 < j_2 \leq Q$，$q_{j_1} \ne q_{j_2}$（候选位置各不相同）
- 所有给定数值均为整数

**子任务**

1. （9 分）$N,Q \leq 5\,000$
2. （21 分）对所有 $i$，满足 $1 \leq x_i \leq 200\,000$，且对所有 $j$，满足 $1 \leq q_j \leq 200\,000$
3. （25 分）对所有 $i$，$a_i = 1$
4. （45 分）无额外约束条件

## 样例 #1

### 输入

```
3 1
2 1
1 3
3 6
4```

### 输出

```
13```

## 样例 #2

### 输入

```
4 5
3 -4
1 -10
2 11
4 6
6
-5
1
-12
14```

### 输出

```
56
84
66
144
116```

# AI分析结果

# 💡 Kay的C++算法解析：累计距离 深入学习指南 💡

<introduction>
今天我们来一起分析「累计距离」这道C++编程题。这道题看似是计算“村民到会议点的总路程”，实则藏着数学推导和高效算法的小秘密。本指南会帮你拆解问题、理解核心算法，并掌握关键编程技巧～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学`（公式化简） + `编程技巧应用`（前缀和+二分查找）

🗣️ **初步分析**：
解决这道题的关键，就像“把大蛋糕切成两块分别吃”——我们利用**数学公式化简**，把复杂的绝对值总和拆成“左边村庄的贡献”和“右边村庄的贡献”两部分；再用**前缀和**把重复计算的部分“提前算好”，用**二分查找**快速找到“左右分割点”。这样就能把每个查询的时间从“遍历所有村庄”变成“眨一下眼的功夫”～

### 核心算法流程
1. **排序**：把所有村庄按位置从小到大排好队，这样才能用二分找分割点。
2. **前缀和预处理**：计算两个“累加器”：
   - `sa[i]`：前i个村庄的**总居民数**（比如前3个村庄共有2+1+3=6人）。
   - `sax[i]`：前i个村庄的**居民数×位置**总和（比如前3个村庄是2×1 +1×3 +3×6=2+3+18=23）。
3. **处理查询**：对每个会议点`q`，用二分找到第一个**位置大于q**的村庄（记为`l`），这样：
   - 左边村庄（位置≤q）的总贡献：`q×sa[l] - sax[l]`（q乘总人数，减去之前算好的“居民数×位置”总和）。
   - 右边村庄（位置>q）的总贡献：`(sax[n]-sax[l]) - q×(sa[n]-sa[l])`（右边的“居民数×位置”总和，减去q乘右边总人数）。
   - 总距离就是左边+右边！

### 可视化设计思路
我打算做一个**8位像素风的“数轴探险家”动画**：
- 用不同颜色的像素块代表村庄（比如蓝色=小居民数，红色=大居民数），会议点用闪烁的黄色像素点。
- 排序过程：村庄像“排队放学”一样从乱序变成整齐的数轴排列，伴随“叮”的音效。
- 二分查找：用红色箭头高亮当前“中间点”，找到分割点时播放“滴”的提示音。
- 计算贡献：左边村庄的像素块会“向右移动”到q点，右边村庄“向左移动”，移动的距离用像素线展示，最后总和用数字蹦出来～
- 交互设计：有“单步执行”（一步步看二分和计算）、“自动播放”（像贪吃蛇AI一样完成所有步骤），还有速度滑块调节快慢！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率等方面，为你筛选了3份超棒的题解～
</eval_intro>

**题解一：(来源：Sunrise_up)**
* **点评**：这份题解是“最优解模板”！作者用`vector`排序替代结构体，速度更快；快读函数避免了输入超时；二分逻辑精准找到“第一个大于q的位置”。思路像“剥洋葱”一样层层递进，从暴力的问题讲到优化的每一步，连“数据溢出”这样的小坑都贴心提醒了～

**题解二：(来源：Ghosty_Neutrino)**
* **点评**：代码像“教科书”一样规范！作者用结构体存储村庄的“居民数”和“位置”，排序逻辑一目了然；用`lower_bound`简化二分查找，代码行数更少。最棒的是注释清晰，新手也能看懂“左边贡献”和“右边贡献”的计算逻辑～

**题解三：(来源：guoshengyu1231)**
* **点评**：用`pair`排序的“简洁派”！作者把村庄的“位置”存在`pair`的first，“居民数”存在second，排序后直接用`sx`数组存位置，逻辑更直观。二分查找的`pos`计算准确，前缀和的预处理顺序完美贴合排序后的村庄，新手照着写也不容易错～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“小陷阱”不少，但掌握这3个关键点，就能轻松避开！
</difficulty_intro>

1. **难点1：数据类型溢出**  
   - 问题：居民数×位置可能很大（比如1e3×1e9=1e12），用`int`会“装不下”。  
   - 解决：所有涉及“居民数×位置”或“总距离”的变量，都用`long long`（比如`sa`、`sax`、`ans`）！

2. **难点2：二分查找的边界**  
   - 问题：容易把“分割点”找错（比如把等于q的村庄分到右边）。  
   - 解决：用`lower_bound`找“第一个大于q的位置”，或者手动二分时，条件写`x[p[m]] > q`（确保等于q的村庄留在左边）。

3. **难点3：前缀和的顺序**  
   - 问题：没排序就计算前缀和，结果完全错误。  
   - 解决：**必须先排序村庄**，再按排序后的顺序计算`sa`和`sax`！就像“先排队再点名”，顺序错了什么都错～

### ✨ 解题技巧总结
- **公式化简是关键**：把绝对值拆成两部分，才能用前缀和快速计算。
- **排序+二分是效率核心**：排序让村庄有“顺序”，二分让查询“变快”。
- **变量名要“会说话”**：比如`sa`（sum of a）、`sax`（sum of a×x），一看就知道是啥意思～


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份“通用核心代码”，帮你理清整体框架～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合了Sunrise_up、Ghosty_Neutrino等优质题解的思路，兼顾效率和可读性～
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;
  typedef long long ll; // 必须用long long！

  const int N = 2e5 + 5;
  ll a[N], x[N], sa[N], sax[N];
  vector<int> p; // 用来排序的索引数组

  inline ll rd() { // 快读函数，避免输入超时
      ll x = 0, f = 1; char ch = getchar();
      while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
      while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
      return x * f;
  }

  int main() {
      int n = rd(), q = rd();
      p.resize(n);
      for (int i = 0; i < n; ++i) {
          a[i] = rd(); x[i] = rd();
          p[i] = i; // 初始化索引
      }
      // 按位置排序索引
      sort(p.begin(), p.end(), [&](int i, int j) { return x[i] < x[j]; });
      // 预处理前缀和
      for (int i = 0; i < n; ++i) {
          int j = p[i];
          sa[i+1] = sa[i] + a[j];
          sax[i+1] = sax[i] + a[j] * x[j];
      }
      // 处理查询
      while (q--) {
          ll qr = rd();
          int l = 0, r = n;
          while (l < r) { // 二分找第一个大于qr的位置
              int m = (l + r) >> 1;
              if (x[p[m]] > qr) r = m;
              else l = m + 1;
          }
          ll ans = qr * sa[l] - sax[l] + (sax[n] - sax[l]) - qr * (sa[n] - sa[l]);
          printf("%lld\n", ans);
      }
      return 0;
  }
  ```
* **代码解读概要**：
  > 代码先读入数据，用`vector`索引排序村庄（避免结构体，更快）；然后计算前缀和`sa`和`sax`；最后对每个查询，用二分找分割点，计算左右贡献并输出。关键是**排序后的索引**和**long long类型**，避开了所有小坑～

---

<code_intro_selected>
再看3份优质题解的核心片段，学点“小技巧”～
</code_intro_selected>

**题解一：(来源：Sunrise_up)**
* **亮点**：用`vector`索引排序，比结构体更快！
* **核心代码片段**：
  ```cpp
  vector<int> p(n);
  for (int i = 0; i < n; i++) p[i] = i+1;
  sort(p.begin(), p.end(), [&](int i, int j) { return x[i]<x[j]; });
  ```
* **代码解读**：
  > 这里用`p`数组存村庄的“原始索引”，排序时比较的是`x[p[i]]`（即原始村庄的位置）。这样不用写结构体，直接用原始数组就能排序，速度更快～就像“给学生编号牌排序，而不是让学生本人跑”～
* **学习笔记**：索引排序是“优化小能手”，避免结构体的额外开销！

**题解二：(来源：Ghosty_Neutrino)**
* **亮点**：用`lower_bound`简化二分，代码更短！
* **核心代码片段**：
  ```cpp
  struct D { ll x, a; bool operator<(const D& w) const { return x < w.x; } };
  vector<D> v(n);
  // ... 排序后 ...
  int k = lower_bound(v.begin(), v.end(), D{qr, 0}) - v.begin();
  ```
* **代码解读**：
  > 作者用结构体`D`存村庄的`x`和`a`，排序后用`lower_bound`找“第一个x≥qr的位置”。`lower_bound`是C++自带的二分函数，直接用它省去了手动写二分的代码～就像“用自动售货机买饮料，不用自己找零钱”～
* **学习笔记**：善用STL函数（比如`lower_bound`），能减少代码量！

**题解三：(来源：guoshengyu1231)**
* **亮点**：用`pair`存位置和居民数，逻辑更直观！
* **核心代码片段**：
  ```cpp
  typedef pair<int, int> P;
  P a[maxn]; // first=位置x，second=居民数a
  sort(a+1, a+n+1);
  for (int i=1; i<=n; i++) {
      sa[i] = sa[i-1] + a[i].second;
      sax[i] = sax[i-1] + a[i].second * a[i].first;
  }
  ```
* **代码解读**：
  > 作者把村庄的“位置”存在`pair`的first，“居民数”存在second，排序时直接按first（位置）排。这样`sa`和`sax`的计算更直观，一看就知道是“前i个村庄的总居民数”和“总a×x”～
* **学习笔记**：`pair`是“轻量级结构体”，适合存两个相关的数据！


## 5. 算法可视化：像素动画演示

### 🎮 动画方案：“数轴探险家”
**主题**：你是一个“像素探险家”，要帮KOI国找到会议点的总距离～  
**核心演示内容**：
1. **初始化**：屏幕显示乱序的村庄像素块（颜色代表居民数），数轴底部有“排序”“开始查询”按钮。
2. **排序过程**：村庄像“排队”一样从左到右按位置排列，每个村庄移动时伴随“哒哒”的脚步声，排好后播放“叮”的成功音。
3. **查询演示**：输入一个会议点（比如4），黄色像素点闪烁；二分查找时，红色箭头从中间位置开始，左右移动，找到分割点（比如第3个村庄）时，分割线变成绿色，播放“滴”的提示音。
4. **计算贡献**：左边村庄的像素块会“向右移动”到4点，移动的距离用蓝色像素线展示；右边村庄“向左移动”，用红色像素线展示。总距离用大像素数字蹦出来，伴随“啪”的音效！
5. **交互设计**：
   - 控制面板：有“单步”（一步步看二分和计算）、“自动”（像AI一样完成所有步骤）、“重置”按钮；
   - 速度滑块：从“慢”（1秒一步）到“快”（0.1秒一步）；
   - 音效开关：可以开/关背景音乐（8位风的“小幸运”）和操作音效～

**设计思路**：用像素风营造“复古游戏”的感觉，让学习像“闯关”一样有趣！比如完成一个查询算“过一关”，累计过5关会有“胜利动画”（像素烟花），增加成就感～


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会这道题，能解决很多“前缀和+二分”的问题哦～
</similar_problems_intro>

### 通用思路迁移
这道题的“公式化简+前缀和+二分”思路，还能解决：
- 求“数组中所有元素到某点的距离和”（比如统计所有同学到教室中间的路程）；
- 求“加权中位数”（比如找一个点，让总距离最小，这道题的进阶版）；
- 离线查询问题（比如把所有查询排序，用双指针优化）。

### 洛谷练习推荐
1. **洛谷 P1102 A-B 数对**：需要前缀和+二分找差值，练公式化简！
2. **洛谷 P1966 火柴排队**：需要排序+前缀和，练“顺序的重要性”！
3. **洛谷 P2004 领地选择**：需要二维前缀和，练“多维扩展”！


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 Sunrise_up)**：“我一开始没注意`long long`，结果样例输出是13，我的代码输出是乱码！后来把所有变量改成`long long`，就对了～”
>
> **点评**：这个经验太重要了！数据溢出是“隐形杀手”，遇到“大数相乘”的问题，一定要先想“会不会超int？”手动算一下最大值（比如1e3×1e9=1e12，超过int的2e9），就知道要用量`long long`啦～


<conclusion>
这道题的核心是“用数学化简问题，用算法提高效率”。记住：公式化简是“钥匙”，排序+二分是“加速器”，变量类型是“避坑符”～多练几道类似题，你就能变成“前缀和小能手”啦！下次我们再一起探索新的编程挑战～💪
</conclusion>

---
处理用时：110.91秒
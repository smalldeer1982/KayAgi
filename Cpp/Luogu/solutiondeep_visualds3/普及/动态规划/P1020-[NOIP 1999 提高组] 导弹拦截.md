# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果

# 💡 Kay的C++算法解析：导弹拦截 深入学习指南 💡

今天我们来一起分析经典的"导弹拦截"问题。这道题不仅是NOIP的经典考题，更是理解动态规划、贪心算法和高级数据结构应用的绝佳案例。通过本指南，我们将一起探索如何用不同算法解决这个问题，并掌握其中蕴含的编程思想。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划(DP)与贪心算法的综合应用，以及LIS(最长递增子序列)问题的变体

🗣️ **初步分析**：
> 解决"导弹拦截"问题，我们需要回答两个关键问题：一是一套系统最多能拦截多少导弹，二是拦截所有导弹最少需要多少套系统。这两个问题分别对应着寻找**最长不上升子序列**和**最长上升子序列**的长度。

想象一下，这就像在玩一个"俄罗斯方块"式的游戏：
- 第一问相当于我们要堆出最高的一列方块，而且每个新方块不能比下面的方块大
- 第二问则像我们需要决定最少需要多少列才能放下所有方块，每列都必须是不上升的

### 核心算法思路：
1. **最长不上升子序列**：对于第一问，我们可以使用动态规划，但更高效的方法是贪心+二分查找，时间复杂度O(n log n)
2. **最少拦截系统数**：根据Dilworth定理，这等价于寻找序列的最长上升子序列长度，同样可以用贪心+二分查找解决

### 可视化设计思路：
我们将设计一个"导弹防御基地"像素动画，其中：
- 不同颜色的像素方块代表不同高度的导弹
- 第一问演示：单个防御系统如何选择导弹，形成最长不上升序列（方块从右向左堆积）
- 第二问演示：多个防御系统并行工作，每个系统用不同颜色标识
- 关键操作（如选择、替换）将配有8位机风格的"嘀嘀"音效
- 二分查找过程会用闪烁的像素箭头直观展示查找范围的变化

## 2. 精选优质题解参考

为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等几个方面，为大家筛选了以下评分较高（≥4星）的题解。

**题解一：(来源：离散小波变换°)**
* **点评**：这份题解对两问都提供了非常清晰的思路分析和优化过程。作者首先从动态规划的基本思路出发，解释了O(n²)解法的原理，然后自然过渡到O(n log n)的优化方案，特别是对辅助数组f[i]的定义和单调性证明非常透彻。代码实现简洁高效，变量命名清晰，对二分查找的边界处理也十分精准。最值得学习的是作者对贪心策略的证明过程，帮助读者理解为什么这种替换策略能够得到正确结果。

**题解二：(来源：STA_Morlin)**
* **点评**：这篇题解特别注重算法原理与代码实现的结合，对STL中的upper_bound和lower_bound函数的应用讲解尤为清晰。作者不仅提供了完整的代码，还详细解释了贪心策略的证明过程，包括更优性证明和有序性证明，这对于理解算法的正确性至关重要。代码结构模块化，注释恰当，非常适合初学者学习如何将理论算法转化为实际代码。

**题解三：(来源：Yansuan_HCl)**
* **点评**：这篇题解的亮点在于第二问的创新解法。作者没有直接使用Dilworth定理，而是提出了一种基于std::set的贪心实现，通过维护当前所有系统的最低拦截高度，高效地找到适合当前导弹的最佳系统。这种方法不仅避免了理解抽象数学定理的门槛，还展示了STL容器在算法优化中的灵活应用，为我们提供了看待问题的另一种视角。

## 3. 核心难点辨析与解题策略

在解决这个问题的过程中，我们通常会遇到以下一些关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略，希望能帮助大家在后续解题时举一反三：

1. **关键点1**：如何将问题抽象为子序列问题？
    * **分析**：第一问要求一套系统最多拦截多少导弹，由于系统特性（后一发不能高于前一发），这本质上是求"最长不上升子序列"。理解这一转化是解决问题的关键。同样，第二问通过Dilworth定理转化为求"最长上升子序列"。优质题解都清晰地指出了这种转化关系。
    * 💡 **学习笔记**：很多实际问题都可以转化为经典的序列问题，培养这种转化思维是提高解题能力的关键。

2. **关键点2**：如何优化动态规划解法？
    * **分析**：朴素的动态规划解法时间复杂度为O(n²)，无法处理n=1e5的大规模数据。所有优质题解都采用了贪心+二分查找的优化方法，通过维护一个具有单调性的辅助数组，将时间复杂度降至O(n log n)。关键在于理解辅助数组的含义：对于最长不上升子序列，`f[i]`表示长度为i的不上升子序列的最后一个元素的最大值。这种定义使得我们可以通过二分查找快速找到插入位置。
    * 💡 **学习笔记**：贪心策略常用来优化动态规划，特别是在序列问题中，维护单调性是一种常见且高效的手段。

3. **关键点3**：如何理解和应用Dilworth定理？
    * **分析**：第二问要求最少需要多少套系统，直接思考可能会想到贪心策略，但证明其正确性并不容易。Dilworth定理提供了一个优雅的解决方案：将序列划分为最少的不上升子序列的个数，等于该序列的最长上升子序列的长度。虽然这个定理的数学证明比较复杂，但题解中提供了直观理解和代码实现方法，使我们可以轻松应用这一强大工具。
    * 💡 **学习笔记**：掌握一些重要的算法定理和结论，可以极大地拓宽解题思路，提高解题效率。

### ✨ 解题技巧总结

通过对本题及类似问题的分析，我总结了以下一些通用的解题技巧，希望对大家有所启发：

- **问题转化技巧**：将实际问题抽象为已知的算法模型（如子序列问题）是解决复杂问题的重要第一步。
- **贪心+二分优化**：当面对序列优化问题时，考虑是否可以通过维护一个单调序列，结合二分查找来降低时间复杂度。
- **STL算法应用**：熟练掌握STL中的upper_bound、lower_bound等算法，可以简化代码实现，提高效率。
- **数据结构选择**：如Yansuan_HCl的题解所示，选择合适的数据结构（如set）有时可以提供更简洁的解决方案。
- **定理应用**：对于一些经典问题，记住并理解相关的重要定理（如Dilworth定理）可以显著提高解题效率。

## 4. C++核心代码实现赏析

在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，实现了O(n log n)时间复杂度的解法，能够高效处理最大规模的输入数据。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;

    int main() {
        vector<int> heights;
        int h;
        // 读取输入
        while (cin >> h) {
            heights.push_back(h);
        }
        
        // 第一问：最长不上升子序列
        vector<int> dp1;
        for (int height : heights) {
            // 使用upper_bound配合greater比较器查找第一个小于当前高度的位置
            auto it = upper_bound(dp1.begin(), dp1.end(), height, greater<int>());
            if (it == dp1.end()) {
                dp1.push_back(height);
            } else {
                *it = height;
            }
        }
        
        // 第二问：最长上升子序列（根据Dilworth定理）
        vector<int> dp2;
        for (int height : heights) {
            // 使用lower_bound查找第一个大于等于当前高度的位置
            auto it = lower_bound(dp2.begin(), dp2.end(), height);
            if (it == dp2.end()) {
                dp2.push_back(height);
            } else {
                *it = height;
            }
        }
        
        // 输出结果
        cout << dp1.size() << endl;
        cout << dp2.size() << endl;
        
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取所有导弹高度到一个vector中。对于第一问，我们维护一个dp1数组，其中每个元素代表长度为i+1的不上升子序列的最后一个元素的最大值。通过upper_bound和greater比较器，我们可以高效地找到当前高度应该插入或替换的位置。对于第二问，类似地维护dp2数组，但这次寻找的是最长上升子序列，使用默认的lower_bound即可。最后，两个数组的大小就是我们要找的答案。整个算法的时间复杂度为O(n log n)，空间复杂度为O(n)。

---

接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。

**题解一：(来源：离散小波变换°)**
* **亮点**：清晰展示了二分查找的手动实现过程，避免了对STL算法的依赖，有助于深入理解二分查找的原理和边界处理。
* **核心代码片段**：
    ```cpp
    // 第一问：最长不上升子序列
    t=0;
    memset(F,0,sizeof(F));
    F[0] = INF;  // 初始值设为无穷大
    up(1,n,i){
        int l=0, r=t+1; 
        while(r-l>1){  // 二分查找合适的位置
            int m=l+(r-l)/2;
            if(F[m]>=H[i]) l=m; 
            else r=m;
        }
        int x=l+1;  // dp[i]的值
        if(x>t) t=x; 
        F[x]=H[i];  // 更新F数组
    }
    printf("%d\n",t);
    
    // 第二问：最少拦截系统数（最长上升子序列）
    t=0;
    memset(F,0,sizeof(F));
    F[0]=0;
    up(1,n,i){
        int l=0, r=t+1;
        while(r-l>1){
            int m=l+(r-l)/2;
            if(F[m]<H[i]) l=m; 
            else r=m;
        }
        int x=l+1;
        if(x>t) t=x; 
        F[x]=H[i];
    }
    printf("%d\n",t);
    ```
* **代码解读**：
    > 这段代码展示了如何手动实现二分查找来解决LIS问题。作者使用了一个F数组来存储长度为i的子序列的最优结尾元素。对于第一问（最长不上升子序列），F数组是单调递减的。每次处理一个新高度H[i]时，通过二分查找找到最大的l，使得F[l] >= H[i]，那么x=l+1就是以H[i]结尾的最长不上升子序列的长度。如果x比当前最长长度t还大，就更新t。最后将F[x]更新为H[i]。
    > 
    > 思考一下：为什么要更新F[x]为H[i]呢？这是因为对于长度为x的子序列，我们希望它的结尾元素尽可能大，这样才能容纳更多后续的小元素。这就是贪心思想的体现！
    > 
    > 对于第二问，代码结构几乎相同，只是比较条件从F[m] >= H[i]变为F[m] < H[i]，这是因为我们现在要找的是最长上升子序列。

* 💡 **学习笔记**：手动实现二分查找虽然比使用STL函数代码量多一些，但能让我们更深入理解二分查找的原理和边界条件处理。这种实现方式在面试或竞赛中出现边界问题时，也更容易调试和修正。

**题解二：(来源：STA_Morlin)**
* **亮点**：巧妙运用STL的upper_bound和lower_bound函数，代码简洁优雅，同时提供了清晰的贪心策略证明。
* **核心代码片段**：
    ```cpp
    // 求最长不上升子序列
    l[1] = h[1] = a[1]; 
    r1 = r2 = 1;
    for(int i = 2; i <= n; ++ i) {
        // 处理最长不上升子序列
        if (l[r1] >= a[i]) 
            l[++r1] = a[i];
        else 
            *upper_bound(l+1, l+r1+1, a[i], greater<int>()) = a[i];
        
        // 处理最长上升子序列
        if (h[r2] < a[i]) 
            h[++r2] = a[i];
        else 
            *lower_bound(h+1, h+r2+1, a[i]) = a[i];
    } 
    printf("%d\n%d", r1, r2);
    ```
* **代码解读**：
    > 这段代码是使用STL算法实现贪心+二分查找策略的典范。作者用两个数组l和h分别存储最长不上升子序列和最长上升子序列的状态。
    > 
    > 对于最长不上升子序列部分：当当前元素a[i]小于等于l数组的最后一个元素时，可以直接添加到数组末尾，长度加1；否则，使用upper_bound配合greater<int>()比较器找到第一个小于a[i]的元素位置，并将该位置的值更新为a[i]。
    > 
    > 为什么使用upper_bound而不是lower_bound？因为upper_bound返回的是第一个大于给定值的元素位置，配合greater<int>()比较器就变成了第一个小于给定值的元素位置，这正是我们需要的插入点。
    > 
    > 对于最长上升子序列部分，逻辑类似，但使用默认的lower_bound函数，当当前元素大于h数组的最后一个元素时直接添加，否则找到第一个大于等于a[i]的位置并替换。
    > 
    > 最终数组的长度r1和r2就是两个问题的答案。这种实现方式代码量少，效率高，充分体现了STL的强大。

* 💡 **学习笔记**：熟练掌握STL中的算法和比较器，可以极大简化代码，提高开发效率。特别是在竞赛环境中，这种简洁的实现不仅能节省时间，还能减少出错的可能性。

**题解三：(来源：Yansuan_HCl)**
* **亮点**：创新性地使用std::set实现第二问，避免了直接使用Dilworth定理，提供了全新的解题视角。
* **核心代码片段**：
    ```cpp
    #include <set>
    // ...其他头文件
    
    // 第二问：使用set的贪心解法
    set<int> st;
    for (int i = 1; i <= N; ++i) {
        auto it = st.lower_bound(A[i]);  // 在set中查找第一个 >= A[i]的元素
        if (it == st.end()) {
            st.insert(A[i]);  // 找不到，新建一个系统
        } else {
            st.erase(it);     // 找到，替换该系统的最小高度
            st.insert(A[i]);
        }
    }
    printf("%d", st.size());  // set的大小就是系统数量
    ```
* **代码解读**：
    > 这段代码展示了一种非常巧妙的贪心思路。作者使用set来维护当前所有导弹拦截系统的最低拦截高度。对于每一个新导弹A[i]：
    > 
    > 1. 使用lower_bound查找set中第一个大于等于A[i]的元素。这代表我们要找一个当前最低拦截高度大于等于A[i]的系统。
    > 
    > 2. 如果找到了这样的系统(it != st.end())，我们就用当前导弹高度更新这个系统的最低拦截高度（先删除再插入）。为什么要这样做？因为我们希望每个系统的最低拦截高度尽可能低，这样可以为后续更高的导弹留出空间。
    > 
    > 3. 如果找不到这样的系统(it == st.end())，说明所有现有系统的最低拦截高度都小于当前导弹高度，我们需要新建一个系统，将当前导弹高度插入set。
    > 
    > 最终，set中元素的个数就是我们需要的最少系统数。这个思路直观易懂，不需要理解复杂的Dilworth定理，却能得到正确的结果。

* 💡 **学习笔记**：选择合适的数据结构往往能带来意想不到的简洁解法。set的自动排序特性和高效查找能力，使其成为实现这类贪心算法的理想选择。这种解法也让我们更深入地理解了为什么第二问的答案等于最长上升子序列的长度。

## 5. 算法可视化：像素动画演示 (核心部分)

为了更直观地理解导弹拦截算法的工作原理，我设计了一个"导弹防御基地"像素动画演示方案。这个8位像素风格的动画将帮助你"看见"算法是如何一步步工作的！

  * **动画演示主题**：`像素防御基地：导弹拦截模拟`

  * **核心演示内容**：`同时展示两个问题的解决过程：左侧显示单个系统拦截的最长不上升序列，右侧显示多个系统并行工作的情况`

  * **设计思路简述**：采用经典FC游戏的8位像素风格，营造怀旧而有趣的学习氛围。通过鲜明的色彩对比和简单的动画效果，直观展示算法的每一步决策。"嘀嘀"的操作音效和"叮"的成功音效将增强学习体验，让抽象的算法过程变得生动有趣。

  * **动画帧步骤与交互关键点**：

    1. **场景与UI初始化 (8位像素风)**：
          * 屏幕分为左右两部分，左侧标题"单个防御系统"，右侧标题"多个防御系统"
          * 顶部有控制面板：开始/暂停按钮、速度滑块(1x-4x)、重置按钮
          * 底部显示当前处理的导弹高度和算法状态信息
          * 背景音乐采用轻快的8位机风格BGM

    2. **导弹发射动画**：
          * 导弹从屏幕右侧以像素火箭的形式飞入，每个导弹标有高度数字(如389, 207等)
          * 导弹颜色根据高度变化，高度越高颜色越鲜艳(红→黄→绿→蓝→紫)

    3. **左侧：最长不上升子序列演示**：
          * 显示一个垂直的"拦截塔"，成功拦截的导弹会堆叠在塔上
          * 若新导弹高度不高于塔顶导弹，它会"咔嗒"一声叠加上去(绿色闪光+上升音效)
          * 若新导弹高度高于塔顶导弹，它会"嗖"地一下替换掉塔中第一个比它矮的导弹(黄色闪光+替换音效)
          * 塔的高度随拦截导弹数量动态变化，右侧显示当前最长序列长度

    4. **右侧：多个防御系统演示**：
          * 每个防御系统用不同颜色的垂直管道表示
          * 新导弹出现时，会先扫描所有管道顶部(用扫描线动画表示)
          * 找到第一个顶部高度≥当前导弹的管道，导弹会落入该管道并替换顶部(对应颜色闪光+落入音效)
          * 若找不到合适管道，会在最右侧新建一个管道(蓝色闪光+新建音效)
          * 底部显示当前使用的系统数量

    5. **二分查找可视化**：
          * 当需要查找插入位置时，左侧/右侧会出现一个"雷达扫描"效果
          * 用高亮区域显示当前查找范围，范围逐渐缩小(每次二分)
          * 找到目标位置时会有"锁定"动画(红色闪烁边框+锁定音效)

    6. **交互与控制**：
          * "单步"按钮：按一次处理一个导弹，便于仔细观察每一步
          * "自动"按钮：自动连续处理所有导弹
          * "速度"滑块：调节自动模式下的处理速度
          * "重置"按钮：将动画恢复到初始状态，可重新演示

    7. **演示结束效果**：
          * 所有导弹处理完毕后，两侧显示最终结果数字(绿色大字体)
          * 播放"任务完成"的8位机风格音乐
          * 显示简单的总结文字，说明两个结果的含义

  * **旁白提示 (动画中的文字气泡)**：

      * （处理第一个导弹时）"第一发导弹总是可以拦截！"
      * （替换操作时）"这个导弹太高了，我们需要替换掉之前的一个导弹，这样可以拦截更多后续导弹。"
      * （新建系统时）"所有现有系统都无法拦截这个导弹，需要部署新的防御系统！"
      * （演示结束时）"左侧高度是单个系统最多拦截的导弹数，右侧数量是拦截所有导弹需要的最少系统数。"

通过这样一个融合了像素艺术和复古游戏元素的动画，我们不仅能清晰地看到导弹拦截算法的执行流程，还能在一种更轻松有趣的环境中理解其核心逻辑和数据变化。这种可视化方式特别适合初学者建立直观理解，为深入掌握算法原理打下基础。

## 6. 拓展练习与相似问题思考

理解并掌握了导弹拦截问题的解法后，我们可以进一步思考这些算法和技巧的适用范围和变形应用。

  * **通用思路/技巧迁移**：

      * **最长子序列问题**是算法设计中的一类经典问题，除了最长不上升子序列和最长上升子序列外，还有最长不下降子序列、最长下降子序列等变体。这些问题都可以用本文介绍的贪心+二分查找方法解决，只需调整比较条件。
      
      * **Dilworth定理**的应用远不止于此。它在调度问题、资源分配、任务规划等领域都有重要应用。例如，在安排会议时，最少需要多少个会议室的问题，也可以转化为类似的子序列问题。
      
      * **贪心算法+二分查找**的组合策略在优化问题中非常常见。当我们需要在一组有序选项中快速找到最优解时，这种策略往往能将O(n²)的时间复杂度降至O(n log n)。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点或思维方式相关的题目，建议大家尝试练习：

    1.  **洛谷 P1091 [NOIP2004 提高组] 合唱队形**
          * 🗣️ **推荐理由**：这道题要求找到最长的先上升后下降的子序列，是LIS问题的一个有趣变形。它不仅能帮助你巩固LIS的求解方法，还能锻炼你将复杂问题分解为多个简单子问题的能力。

    2.  **洛谷 P1233 木棍加工**
          * 🗣️ **推荐理由**：这道题与导弹拦截问题非常相似，但增加了一个维度。通过解决这个问题，你可以学会如何将二维问题转化为一维问题，进一步加深对Dilworth定理的理解和应用。

    3.  **洛谷 P2782 友好城市**
          * 🗣️ **推荐理由**：这道题需要你先对数据进行排序，然后找到最长不下降子序列。它展示了LIS问题在实际场景中的应用，同时也能锻炼你对问题建模和转化的能力。

    4.  **洛谷 P3902 递增**
          * 🗣️ **推荐理由**：这道题要求通过修改最少的元素使序列严格递增，是LIS问题的一个重要应用。它能帮助你理解LIS长度与序列修改之间的关系，拓展解题思路。

## 7. 学习心得与经验分享 (若有)

如果提供的题解内容中包含了作者的个人学习心得或解题过程中的经验教训，这些对我们来说是非常宝贵的参考。我会摘录其中有价值的部分，并点评其借鉴意义：

> **参考经验 (来自 STA_Morlin)**："更优性证明：设找到的数为 l_p。如果 l_p 在末尾，由于 l_p < b_i，所以 l_p 后面能接的没有 b_i 多，l_p 让位给 b_i 可以让序列更长。如果 l_p 不在末尾，那 l_p 以后都不会再被用到了，直接换了 l_p 就行。"

> **点评**：这位作者的证明思路非常直观，用简单的语言解释了为什么贪心替换策略能够得到最优解。这种通过具体情况分析来理解算法正确性的方法，是学习算法设计的重要技巧。在面对复杂算法时，尝试分解问题，考虑不同情况，往往能帮助我们理解其本质。

> **参考经验 (来自 Yansuan_HCl)**："感性理解也很容易：如果采用 h_k ≥ h_j，那么之后来袭的更高的导弹就有可能在无法被 h_j 拦截的同时，h_k 也被 a_i 减小了，一定不优。"

> **点评**：这段感性理解展示了如何通过直观分析来设计贪心策略。在算法设计中，先建立直观理解，再进行严格证明，是一种非常有效的学习方法。这位作者的思考方式提醒我们，不要害怕在初期使用非形式化的推理来探索问题，这往往是找到正确解法的第一步。

> **参考经验 (来自 sunyizhe)**："这题是道 LIS 好题！本人调了两天两夜才对……"

> **点评**：这位作者的坦诚分享提醒我们，即使是看似基础的算法问题，也可能需要多次尝试和调试才能完全掌握。编程学习是一个循序渐进的过程，遇到困难和挫折是正常的。重要的是保持耐心，不断尝试，从错误中学习。这种坚持不懈的精神，是成为优秀程序员的必备素质。

通过这些作者的经验分享，我们不仅学到了解决具体问题的技巧，更获得了宝贵的学习方法和思维方式。这些软实力的提升，将帮助我们在编程学习的道路上走得更远。

本次关于"导弹拦截"的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解最长子序列相关的算法和编程技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。对于本题涉及的动态规划、贪心算法和二分查找等知识点，建议大家多做类似练习，加深理解和应用能力。下次我们再一起探索新的编程挑战！💪

---
处理用时：241.03秒
# 题目信息

# [Opoi 2024] 热核武器

## 题目背景



跳蚤国与蛐蛐国正在激战！

![level](https://tse3-mm.cn.bing.net/th/id/OIP-C.ewEm2cQO23KvtiSwFQMFGQHaE8?w=293&h=195&c=7&r=0&o=5&pid=1.7)

上面是战术核显卡，与题目没有关联。

## 题目描述

跳蚤国的国土可以看作平面直角坐标系。

跳蚤国有 $N+1$ 座城市，有 $1$ 座是首都，位于 $(0,0)$，另 $N$ 座是普通城市，在这里假设首都为 $0$ 号城市，其他城市编号为 $1$ 至 $N$，对于每一座普通城市，位于 $(x_i,y_i)$。


由于跳蚤国财力有限，对于每一个不是首都的城市 $i$，它会选择一个城市 $j$ 修建一条双向公路。令 $dis(x,y)$ 为 $x$，$y$ 城市的欧几里得距离，**则对于每一个不是首都的城市 $i$，它所对应的 $j$ 则是满足 $dis(j,0) \le dis(i,0)$ ，$j \ne i$ 的所有点中 $dis(i,j)$ 最小的点，如有多个合法 $j$，取其中编号最小的一个。**

定义一座城市的 $\gamma$ 值为这个城市走到首都所需要的最小道路数 $+1$，**如果走不到首都，设 $\gamma$ 值为 $0$。**

蛐蛐国要对跳蚤国进行战术核显卡打击，这次行动分为两个组：洛伦兹组和安培组。每个组都要对跳蚤国的部分城市进行打击，其中两个组需要恰好把跳蚤国每个城市打击一遍。

对于这两个组来说，名利是最重要的，而蛐蛐国的评功标准是按照本次行动所打击城市的 $\gamma$ 值和。所以你需要求出：有没有一种划分方式使得洛伦兹组和安培组分别的打击城市的 $\gamma$ 值和相等，可以，输出 ```Yes```，否则输出 ```No``` 。

## 说明/提示

### 样例解释

这幅图是长这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/dasec5pr.png)

对于 $C1$，$C0$ 和 $C2$ 满足 $dis(j,0) \le dis(C1,0)$，但是 $C0$ 离 $C1$ 距离更近，添加边 $(C1,C0)$。

对于 $C2$，只有 $C0$ 满足 $dis(j,0) \le dis(C2,0)$，添加边 $(C2,C0)$。

对于 $C3$，$C0$，$C1$ 和 $C2$ 满足 $dis(j,0) \le dis(C3,0)$，但是 $C2$ 离 $C3$ 距离最近，因此添加边 $(C3,C2)$。**注意这里是因为在 $C3$ 处考虑时，最优点为 $C2$，所以 $C3$ 才向 $C2$ 修建了一条公路，和公路 $(C2,C0)$ 完全独立。**

对于 $C4$，其他所有点都满足 $dis(j,0) \le dis(C4,0)$，但是 $C0$ 离 $C4$ 距离最近，添加边 $(C4,C0)$。

得到下面的表：

| 城市编号 | $\gamma$ 值 |
| :-----------: | :-----------: |
| 0 | 1 |
| 1 | 2 |
| 2 | 2 |
| 3 | 3 |
| 4 | 2 |

所以把 $0,1,2$ 分给洛伦兹组，$3,4$ 分给安培组即可。

### 数据范围

$1 \le N \le 500$，$-10^6 \le x_i,y_i \le 10^6$。

### 特殊说明

由于本题输出只有 ```Yes``` 和 ```No```，所以本题采用最小分值评测法，即取所有测试点的得分最小值作为结果。


## 样例 #1

### 输入

```
4
-1 -1
1 0
1 -2
-2 2```

### 输出

```
Yes```

# AI分析结果

# 💡 Kay的C++算法解析：[Opoi 2024] 热核武器 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟、BFS（广度优先搜索）、01背包动态规划  

🗣️ **初步分析**：  
解决这道题就像完成一场“**城市基建+寻宝+分赃**”的游戏：  
1. **模拟建城**：按题目规则给每个城市找“邻居”——就像给每个小朋友找一个“离自己最近、且家离学校（首都）更近/一样近”的小伙伴，还要选编号最小的那个。  
2. **寻宝路径**：计算每个城市到首都的最短路径（γ值）——像玩“迷宫寻宝”，从首都出发一层一层找，保证第一次走到某个城市时的路径最短。  
3. **分赃考验**：判断能否把所有城市的“寻宝步数+1”分成相等的两组——就像把一堆硬币分成两堆一样多，用“背包”装一装就知道行不行。  

**核心算法流程**：  
- **模拟建图**：对每个城市i，遍历所有城市j，找出满足`dis(j,0)≤dis(i,0)`且`dis(i,j)`最小、编号最小的j，连边。  
- **BFS求γ**：从首都（0号）出发，用BFS逐层扩展，记录每个城市的最短路径数，加1就是γ值。  
- **01背包分组**：计算γ值总和sum，若sum是偶数，用01背包判断能否凑出sum/2。  

**可视化设计思路**：  
用8位像素风模拟“城市建图+寻宝”：  
- 城市用不同颜色的像素块表示，首都（0号）是金色，普通城市是蓝色。  
- 建图时，每个城市i会“扫描”周围符合条件的j，选中的j会闪烁绿色，伴随“叮”的音效。  
- BFS时，首都发出“波纹”（像素圈），逐层扩散，访问过的城市变成粉色，队列用像素块堆叠显示。  
- 背包部分，用像素条表示当前能凑出的和，凑到sum/2时条体会变成彩虹色，播放“胜利”音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度，筛选了以下优质题解，帮你快速理解核心逻辑~
</eval_intro>

**题解一：作者：shuqiang（赞：13）**  
* **点评**：这道题的“标准答案框架”！题解分三部分（建图、求γ、分组），每部分逻辑独立，代码模块化。建图直接按题意模拟，求γ用Floyd（适合小数据），分组用01背包，结构清晰到“照着写就能AC”。尤其适合新手入门，能快速理清解题步骤。

**题解二：作者：hcy1117（赞：3）**  
* **点评**：代码“手把手教学”！从计算欧几里得距离，到Floyd求最短路径，再到01背包，每一步都有注释。特别强调了“sum为奇数直接输出No”的边界条件，避免新手踩坑。代码风格规范，变量名（如`cnt[i]`表示γ值）易懂，适合模仿。

**题解三：作者：LostKeyToReach（赞：3）**  
* **点评**：“反图BFS”是亮点！常规思路是从城市找首都，而作者反过来建“反图”（把边的方向反过来），从首都出发BFS，直接得到每个城市的γ值。这种“反向思考”能简化代码，避免处理复杂的路径回溯，值得学习。

**题解四：作者：wzhm54nr（赞：2）**  
* **点评**：“bitset优化”让背包飞起来！普通01背包是O(n*sum)，作者用`bitset`把时间复杂度降到O(n*sum/64)（因为bitset一次能处理64位）。代码里`dp|=dp<<dep[i]`一句话就完成了背包转移，高效又简洁，适合数据量大的情况。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，很多同学会卡在“建图找不对邻居”“求γ值超时”“背包sum太大”这三个问题上。下面帮你拆解难点，给出解决办法~
</difficulty_intro>

1. **难点1：如何正确找到每个城市的连接对象？**  
   * **问题**：容易漏掉“dis(j,0)≤dis(i,0)”或“编号最小”的条件。  
   * **解决**：对每个城市i，**遍历所有城市j**，依次判断：  
     - j≠i；  
     - dis(j,0)≤dis(i,0)（用欧几里得距离的平方代替，避免浮点误差）；  
     - 记录`dis(i,j)`最小的j，若有多个，选编号最小的。  

2. **难点2：如何高效求γ值？**  
   * **问题**：用Floyd（O(n³)）对n=500来说刚好能过，但有没有更高效的方法？  
   * **解决**：**BFS**（O(n+m)）更高效！因为建的图是**树**（每个城市只有一条边连向离首都更近的点），从首都出发BFS，第一次访问到某个城市时的路径就是最短的。

3. **难点3：背包sum太大怎么办？**  
   * **问题**：n=500，γ值最大是501（树的深度），sum最大是500*501=250500，普通01背包会超时。  
   * **解决**：用**bitset优化**！把dp数组换成bitset，每一步用`dp|=dp<<γ[i]`，一句话完成转移，时间复杂度降到O(n*sum/64)。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，帮你把握整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合了优质题解的思路，用BFS求γ值，bitset优化背包，简洁高效。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <bitset>
#include <cmath>
using namespace std;

const int N = 510;
int x[N], y[N];
double dis0[N]; // 每个城市到首都的距离
vector<int> G[N]; // 图的邻接表
int gamma[N]; // γ值
bitset<250500> dp; // 01背包，sum最大250500

double calc_dis(int i, int j) { // 计算城市i和j的欧几里得距离
    return sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));
}

int main() {
    int n;
    cin >> n;
    x[0] = y[0] = 0; // 首都坐标
    dis0[0] = 0;
    for (int i=1; i<=n; i++) {
        cin >> x[i] >> y[i];
        dis0[i] = calc_dis(i, 0); // 计算到首都的距离
    }

    // Part1：模拟建图
    for (int i=1; i<=n; i++) {
        double min_dis = 1e18;
        int best_j = 0;
        for (int j=0; j<=n; j++) {
            if (i == j) continue;
            if (dis0[j] > dis0[i]) continue; // j到首都的距离必须≤i的
            double d = calc_dis(i, j);
            if (d < min_dis || (d == min_dis && j < best_j)) {
                min_dis = d;
                best_j = j;
            }
        }
        G[i].push_back(best_j);
        G[best_j].push_back(i);
    }

    // Part2：BFS求gamma值
    queue<int> q;
    q.push(0);
    gamma[0] = 1; // 首都的gamma是1
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : G[u]) {
            if (gamma[v] == 0) { // 未访问过
                gamma[v] = gamma[u] + 1;
                q.push(v);
            }
        }
    }

    // Part3：01背包分组
    int sum = 0;
    for (int i=0; i<=n; i++) sum += gamma[i];
    if (sum % 2 != 0) {
        cout << "No" << endl;
        return 0;
    }
    dp.set(0); // 初始状态：能凑出0
    for (int i=0; i<=n; i++) {
        dp |= dp << gamma[i]; // bitset优化转移
    }
    if (dp[sum/2]) cout << "Yes" << endl;
    else cout << "No" << endl;

    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：读入首都和普通城市的坐标，计算每个城市到首都的距离`dis0`。  
  2. **模拟建图**：对每个城市i，找出符合条件的j，连边到邻接表`G`。  
  3. **BFS求gamma**：从首都出发，记录每个城市的最短路径数，加1得gamma。  
  4. **bitset背包**：计算sum，若为偶数，用bitset判断能否凑出sum/2。


<code_intro_selected>
接下来看优质题解的核心片段，学习关键技巧~
</code_intro_selected>

**题解一：作者：shuqiang**
* **亮点**：分三部分模块化代码，思路清晰。
* **核心代码片段**（建图部分）：
```cpp
// 计算每个城市到首都的距离
for (int i = 0; i <= n; ++i) {
    dis0[i] = sqrt(x[i] * x[i] + y[i] * y[i]);
}
// 建图
for (int i = 1; i <= n; ++i) {
    double min_d = 1e18;
    int best_j = 0;
    for (int j = 0; j <= n; ++j) {
        if (i == j) continue;
        if (dis0[j] > dis0[i]) continue;
        double d = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));
        if (d < min_d || (d == min_d && j < best_j)) {
            min_d = d;
            best_j = j;
        }
    }
    G[i].push_back(best_j);
    G[best_j].push_back(i);
}
```
* **代码解读**：  
  这段代码是**模拟建图的核心**。`dis0[i]`存储城市i到首都的距离，对每个i，遍历所有j，找出符合条件的j。注意用“`d == min_d && j < best_j`”保证编号最小，避免选错邻居。
* **学习笔记**：模拟题的关键是**严格按题意遍历条件**，不要漏掉任何细节。


**题解二：作者：wzhm54nr**
* **亮点**：用bitset优化背包，效率极高。
* **核心代码片段**（背包部分）：
```cpp
bitset<N*N> dp={1}; // N=505，N*N=255025
int sum = 0;
for (int i=0; i<=n; i++) sum += dep[i];
if (sum&1) { puts("No"); return 0; }
for (int i=0; i<=n; i++) {
    dp |= dp << dep[i]; // 核心转移
}
if (dp[sum/2]) puts("Yes");
else puts("No");
```
* **代码解读**：  
  `bitset<N*N> dp`表示能凑出的和，`dp.set(0)`表示初始时能凑出0。`dp |= dp << dep[i]`的意思是：**对于每个γ值dep[i]，可以选择加或不加**——不加的话保持原来的dp，加的话把dp左移dep[i]位（相当于加上dep[i]），然后取或（合并两种情况）。
* **学习笔记**：bitset是处理“大背包”的神器，能把时间复杂度降低64倍！


## 5. 算法可视化：像素动画演示

### 动画主题：**像素城市的基建与寻宝之旅**
### 设计思路：
用8位像素风模拟“建图+BFS+背包”，像玩《模拟城市》一样学习算法~

### 动画帧步骤：
1. **场景初始化**：  
   屏幕显示5x5的像素网格（可缩放），首都（0号）是金色方块，普通城市是蓝色方块。底部有“开始/单步/重置”按钮，速度滑块，背景播放8位风格的轻松BGM。

2. **模拟建图**：  
   每个蓝色城市会“扫描”周围的方块，符合条件的j会闪烁绿色，屏幕上方显示“城市i选中邻居j”的文字提示，伴随“叮”的音效。建完所有边后，城市之间会出现灰色的像素线（边）。

3. **BFS寻宝**：  
   首都发出金色的“波纹”（像素圈），逐层扩散。每扩散一层，访问过的城市变成粉色，队列用堆叠的像素块显示在右侧。屏幕下方同步显示当前的gamma值，比如“城市3的gamma是3”。

4. **背包分组**：  
   屏幕右侧出现一个像素条，初始是黑色。每处理一个gamma值，条体会增加对应的长度，颜色从红变绿。当条体长度达到sum/2时，变成彩虹色，播放“胜利”音效（类似FC游戏的过关声）。

### 交互设计：
- **单步执行**：点击“单步”，动画走一步，方便观察细节。
- **自动播放**：滑动速度滑块，调整动画速度（慢/中/快）。
- **重置**：回到初始状态，重新开始动画。


## 6. 拓展练习与相似问题

<similar_problems_intro>
掌握了这道题的技巧，可以试试以下相似问题，巩固所学~
</similar_problems_intro>

1. **洛谷 P1048 [NOIP2005 普及组] 采药**  
   🗣️ **推荐理由**：经典01背包问题，帮你巩固“凑数”的思路。
2. **洛谷 P1339 [USACO08OCT] Heat Wave G**  
   🗣️ **推荐理由**：最短路径问题，用BFS或Dijkstra解决，和本题的γ值计算类似。
3. **洛谷 P2853 [USACO06DEC] Cow Picnic S**  
   🗣️ **推荐理由**：多源BFS问题，拓展本题的单源BFS思路。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是优质题解中的经验分享，帮你避免踩坑~
</insights_intro>

> **参考经验（来自作者：shuqiang）**：“建图时用欧几里得距离的平方代替开根号，能避免浮点误差！比如比较dis(j,0)和dis(i,0)时，用x[j]²+y[j]² ≤ x[i]²+y[i]²，比算sqrt更准确。”  
> **点评**：浮点误差是模拟题的常见坑！用平方代替开根号，能避免因精度问题选错邻居，这个技巧超实用~


## 8. 总结

这道题的核心是**模拟建图+最短路径+BFS+01背包**，就像完成一场“城市游戏”。记住：  
- 模拟题要**严格按题意遍历**，不要漏掉细节；  
- 树的最短路径用**BFS**最高效；  
- 大背包用**bitset**优化，能省很多时间。  

多写多练，你一定能掌握这些技巧！下次我们再一起解决更难的问题~ 💪

---
处理用时：87.97秒
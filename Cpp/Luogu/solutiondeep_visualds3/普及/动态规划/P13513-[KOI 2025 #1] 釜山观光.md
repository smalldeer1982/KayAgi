# 题目信息

# [KOI 2025 #1] 釜山观光

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

釜山广域市为了方便游客的交通出行，销售以下几种交通票券。

| 类别 | 使用人数 | 有效期 | 价格 | 备注 |
| :--: | :--: | :--: | :--: | :--: |
| 1 日票 | 1 人 | 购买当天，共 **1** 天 | $p_1$ | 有效期内仅限购买者本人使用 |
| 3 日票 | 1 人 | 含购买当天在内的连续 **3** 天 | $p_3$ | 有效期内仅限购买者本人使用 |
| 5 日票 | 1 人 | 含购买当天在内的连续 **5** 天 | $p_5$ | 有效期内仅限购买者本人使用 |
| 组合票 | 2 人 | 含购买当天在内的连续 **4** 天 | $p_{pair}$ | 有效期内两人均可使用 |

所有票券均在**购买后立即生效**，并可在票券上标明的有效期内使用交通工具。当然，即使持有票券但未使用交通工具，或持有多张有效期重叠的票券，或票券的有效期超出了 N 天的观光行程也都是允许的。另外请注意，$p_1 \le p_3 \le p_5$ 这一关系**并非总是**成立。

Hankook 和 Jeong-ul 将在釜山一同停留 $N$ 天。但是，两人各自制定了自己的观光计划，并决定了每天自己是否要进行观光。为了完成观光行程，对于每个人，在他们**进行观光的每一天**，都必须持有一张有效的票券（包括组合票）。

例如，假设 $N=9$，$p_1=3, p_3=7, p_5=12, p_{pair}=15$，Hankook 和 Jeong-ul 各自的日程如下：

| 日期 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
| :--- | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| Hankook | X | O | O | X | O | O | O | X | O |
| Jeong-ul | O | O | X | X | X | O | O | O | X |

(O 代表观光，X 代表不观光)

如果只使用 1 日票，总观光天数为 11 天 (Hankook 6 天 + Jeong-ul 5 天)，费用为 11 (观光天数) × 3 (1 日票价格) = 33。

但是，如果两人在**第 5 天至第 8 天**共享一张组合票，总费用仅为 30。

更有甚者，如果 Hankook 购买一张**第 5 天至第 7 天**的 3 日票，Jeong-ul 购买一张**第 6 天至第 8 天**的 3 日票，总费用可以节省至 29。

当 Hankook 的日程由字符串 $A = A_1A_2\cdots A_N$ 表示，Jeong-ul 的日程由字符串 $B = B_1B_2\cdots B_N$ 表示时，对于日期 $i(1 \le i \le N)$:

*   如果 Hankook 进行观光，$A_i=1$；否则 $A_i=0$
*   如果 Jeong-ul 进行观光，$B_i=1$；否则 $B_i=0$

请根据以上形式给出的日程，编写一个程序，计算出为了确保在每个人进行观光的每一天都持有至少一张有效票券（包括组合票）所需的最少费用。

## 说明/提示

### 限制条件

*   给定的所有数都是整数。
*   $1 \le N \le 2000$。
*   字符串 $A, B$ 的长度均为 $N$，且所有字符均为 `0` 或 `1`。
*   $1 \le p_1, p_3, p_5, p_{pair} \le 10000$。

### 子任务

1.  (6 分) $p_1 = 1$，$p_3 = p_5 = p_{pair} = 10000$。
2.  (12 分) $p_{pair} = 1$，$p_1 = p_3 = p_5 = 10000$。
3.  (16 分) 对于所有 $i(1 \le i \le N)$，都有 $A_i = B_i = 1$。
4.  (24 分) 对于所有 $i(1 \le i \le N)$，都有 $B_i = 0$。
5.  (42 分) 无附加限制条件。

## 样例 #1

### 输入

```
9
011011101
110001110
3 7 12 15```

### 输出

```
29```

## 样例 #2

### 输入

```
9
011011101
110001110
1 10000 10000 10000```

### 输出

```
11```

# AI分析结果

---
# 💡 Kay的C++算法解析：釜山观光 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划 (DP)

🗣️ **初步分析**：
解决“釜山观光”问题的关键，就像你每天攒零花钱买玩具——每一步都要选最划算的方式，而且今天的选择要基于昨天的最优结果。动态规划（DP）的核心就是**“用已知的子问题最优解，推导出当前问题的最优解”**。在本题中，我们需要同时覆盖两个人的观光日程，所以DP状态要记录“Hankook的前i天”和“Jeong-ul的前j天”的最小费用，这样每一步都能通过“买不同的票”转移到更后面的天数。

题解的核心思路大致分为两类：
1. **二维DP**：用`dp[i][j]`表示覆盖Hankook前i天和Jeong-ul前j天的最小费用，通过“买1/3/5日票”或“组合票”转移状态（如Mindulle、tingting28的题解）。
2. **状态压缩DP**：记录两人当前票券的剩余有效期（如`r_a`表示Hankook的票还能再用几天，`r_b`表示Jeong-ul的，`r_p`表示组合票的），通过“续票”或“买新票”转移状态（如chen_zhe的题解）。

**核心难点**：
- 如何用状态覆盖两人的日程（二维索引vs剩余天数）？
- 转移时如何处理票券的有效期（比如3日票要覆盖i-3到i天）？
- 组合票的使用条件（必须同时覆盖两人，且i=j时才能用）？

**可视化设计思路**：
我们会用**8位像素风**模拟两人的日程：
- 用两个像素小人分别代表Hankook和Jeong-ul，每天的观光日（A_i=1或B_j=1）用“发光的脚印”标记。
- 购票时，不同票券会弹出像素化的图标（1日票是小方块，3日票是三个连块，组合票是两人手拉手的图标），并伴随“叮”的音效。
- 状态转移时，用“箭头”指向之前的状态（比如从`dp[i-3][j]`到`dp[i][j]`），高亮当前选择的票券。
- 最终找到`dp[n][n]`时，会播放“胜利音效”，两个小人跳起来庆祝！

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：Mindulle的二维DP思路（来源：综合题解内容）**
* **点评**：这份题解的状态定义非常直观——`dp[i][j]`覆盖Hankook前i天和Jeong-ul前j天的最小费用。初始化时分别处理“只有一个人观光”的情况（比如`dp[i][0]`只考虑Hankook的票），转移时枚举“买1/3/5日票”和“组合票”的所有可能，逻辑顺理成章。代码中的`max(i-3,0)`避免了数组越界，细节处理到位。美中不足的是组合票仅在`i=j`时使用，可能漏掉一些情况，但整体思路清晰，适合入门学习。

**题解二：chen_zhe的状态压缩DP（来源：综合题解内容）**
* **点评**：这份题解的亮点在于**状态压缩**——用`D(i, r_a, r_b, r_p)`记录第i天两人票券的剩余天数（`r_a`是Hankook的剩余天数，`r_b`是Jeong-ul的，`r_p`是组合票的）。这种状态能更精准地覆盖“票券还能用几天”，避免了二维DP中“i和j必须同步”的限制，时间复杂度降到了O(N)（因为`r_a`、`r_b`最多5天，`r_p`最多4天）。代码中的`memo`数组用记忆化搜索避免重复计算，逻辑严谨，是更高效的进阶解法。

**题解三：tingting28的分类讨论DP（来源：综合题解内容）**
* **点评**：这份题解把转移情况拆成了10种（比如“i=j=0”“Hankook买1日票”“Jeong-ul买3日票”等），每一种情况都明确写出转移方程，非常适合新手对照理解。代码中的`min_element`函数直接取所有情况的最小值，简洁明了。美中不足的是`i=j`时才能用组合票，可能不够灵活，但整体思路清晰，代码可读性高。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“如何用DP状态覆盖两人的日程”和“如何处理票券的有效期”，以下是3个核心难点及解决方法：
</difficulty_intro>

1. **难点1：状态定义如何覆盖两人的日程？**
    * **分析**：如果只用一维状态（比如`dp[i]`覆盖前i天），无法同时记录两人的进度。二维状态`dp[i][j]`或状态压缩`D(i, r_a, r_b, r_p)`能同时覆盖两人的情况。
    * **解决方法**：选二维状态（适合入门）或状态压缩（适合进阶）。二维状态的`i`和`j`分别对应两人的天数，状态压缩的`r_a`和`r_b`对应剩余有效期。
    * 💡 **学习笔记**：状态定义要“刚好覆盖问题的所有变量”——本题的变量是“两人的观光进度”，所以状态要包含这两个变量。

2. **难点2：转移时如何处理票券的有效期？**
    * **分析**：比如买3日票，要覆盖从`i-3`到`i`的天数，所以转移时要从`dp[max(i-3,0)][j]`过来（`max`避免越界）。
    * **解决方法**：转移方程中用`max(当前天数 - 票券有效期, 0)`作为前一个状态的索引。比如3日票的转移是`dp[i][j] = min(dp[i][j], dp[max(i-3,0)][j] + p3)`。
    * 💡 **学习笔记**：票券的有效期对应“状态的跳跃”——买k日票，就从`i-k`天的状态转移过来。

3. **难点3：组合票的使用条件？**
    * **分析**：组合票要同时覆盖两人，所以只有当两人的进度相同（`i=j`）时，才能用组合票（因为组合票的有效期是4天，要同时覆盖i-4到i天）。
    * **解决方法**：在转移时加入条件`if (i == j)`，此时可以从`dp[max(i-4,0)][max(j-4,0)]`转移，并加上组合票的价格。
    * 💡 **学习笔记**：组合票是“两人共享”的，所以状态必须同步（i=j）才能用。

### ✨ 解题技巧总结
- **拆分问题**：像chen_zhe那样，先解决子问题（比如只买1日票或组合票），再扩展到全问题。
- **状态压缩**：当变量有“上限”时（比如剩余天数最多5天），用状态压缩能降低复杂度。
- **边界处理**：用`max(..., 0)`避免数组越界，用`min`函数取所有转移的最小值。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**二维DP的通用实现**，思路来自Mindulle的题解，适合入门：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Mindulle的二维DP思路，用`dp[i][j]`覆盖两人的前i和前j天，逻辑清晰。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;

    int main() {
        int n, p1, p3, p5, pp;
        string A, B;
        cin >> n >> A >> B >> p1 >> p3 >> p5 >> pp;
        A = " " + A; // 让索引从1开始
        B = " " + B;

        vector<vector<int>> dp(n+1, vector<int>(n+1, 1e9));
        dp[0][0] = 0;

        // 初始化：只有Hankook观光
        for (int i = 1; i <= n; ++i) {
            dp[i][0] = min({
                dp[i-1][0] + (A[i] == '1' ? p1 : 0),
                dp[max(i-3, 0)][0] + p3,
                dp[max(i-5, 0)][0] + p5
            });
        }

        // 初始化：只有Jeong-ul观光
        for (int j = 1; j <= n; ++j) {
            dp[0][j] = min({
                dp[0][j-1] + (B[j] == '1' ? p1 : 0),
                dp[0][max(j-3, 0)] + p3,
                dp[0][max(j-5, 0)] + p5
            });
        }

        // 状态转移
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                // 买1日票
                dp[i][j] = min(dp[i][j], dp[i-1][j] + (A[i] == '1' ? p1 : 0));
                dp[i][j] = min(dp[i][j], dp[i][j-1] + (B[j] == '1' ? p1 : 0));
                // 买3日票
                dp[i][j] = min(dp[i][j], dp[max(i-3, 0)][j] + p3);
                dp[i][j] = min(dp[i][j], dp[i][max(j-3, 0)] + p3);
                // 买5日票
                dp[i][j] = min(dp[i][j], dp[max(i-5, 0)][j] + p5);
                dp[i][j] = min(dp[i][j], dp[i][max(j-5, 0)] + p5);
                // 买组合票（i=j时）
                if (i == j) {
                    dp[i][j] = min(dp[i][j], dp[max(i-4, 0)][max(j-4, 0)] + pp);
                }
            }
        }

        cout << dp[n][n] << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入（n、两人的日程A/B、票的价格），然后初始化`dp[0][0]`为0（没观光不用花钱）。接着初始化“只有一个人观光”的情况（比如`dp[i][0]`只考虑Hankook的票）。之后双重循环处理所有`i`和`j`的组合，枚举“买1/3/5日票”和“组合票”的转移，最后输出`dp[n][n]`（覆盖两人所有天的最小费用）。

---
<code_intro_selected>
接下来看**状态压缩DP的核心片段**（来自chen_zhe的题解），更高效：
</code_intro_selected>

**题解二：chen_zhe的状态压缩DP（来源：综合题解内容）**
* **亮点**：用`memo[day][r_a][r_b][r_p]`记录当前天的剩余有效期，避免了二维DP的`O(n²)`复杂度（实际是`O(n*6*6*5)=O(n)`）。
* **核心代码片段**：
    ```cpp
    const int INF = 1e9;
    int memo[2002][6][6][5]; // day最多2000，r_a/r_b最多5，r_p最多4
    bool a_schedule[2002], b_schedule[2002];
    int ticket_price[6], pair_ticket_price;

    int dfs(int day, int ra, int rb, int rp) {
        if (day > n) return 0;
        if (memo[day][ra][rb][rp] != -1) return memo[day][ra][rb][rp];
        int ans = INF;
        bool need_a = a_schedule[day], need_b = b_schedule[day];

        // 枚举买组合票（0或4天）、Hankook的票（0/1/3/5天）、Jeong-ul的票（0/1/3/5天）
        for (int add_pair : {0, 4}) {
            int cost_p = (add_pair ? pair_ticket_price : 0);
            for (int add_a : {0, 1, 3, 5}) {
                int cost_a = ticket_price[add_a];
                for (int add_b : {0, 1, 3, 5}) {
                    int cost_b = ticket_price[add_b];
                    // 计算新的剩余天数（取max：旧的剩余-1 或 新买的票的有效期）
                    int nr_a = max(ra - 1, add_a);
                    int nr_b = max(rb - 1, add_b);
                    int nr_p = max(rp - 1, add_pair);
                    // 检查是否覆盖当天的观光需求
                    bool cover_a = (nr_a >= 1 || nr_p >= 1);
                    bool cover_b = (nr_b >= 1 || nr_p >= 1);
                    if (need_a && !cover_a) continue;
                    if (need_b && !cover_b) continue;
                    // 递归处理下一天
                    ans = min(ans, cost_p + cost_a + cost_b + dfs(day+1, nr_a, nr_b, nr_p));
                }
            }
        }
        return memo[day][ra][rb][rp] = ans;
    }
    ```
* **代码解读**：
    > 这段代码是**记忆化搜索**的核心：
    > 1. `memo[day][ra][rb][rp]`记录“第day天，Hankook的票还能再用ra天，Jeong-ul的还能rb天，组合票还能rp天”的最小费用。
    > 2. `dfs`函数递归处理每一天：枚举“买组合票（add_pair=0或4）”“Hankook的票（add_a=0/1/3/5）”“Jeong-ul的票（add_b=0/1/3/5）”的所有组合。
    > 3. `nr_a = max(ra-1, add_a)`：比如ra=2（昨天的票还能再用2天），今天买了3日票，那么新的剩余天数是max(2-1,3)=3天。
    > 4. `cover_a`检查是否覆盖当天的观光需求：如果Hankook今天要观光（need_a=1），那么他的票要么还剩≥1天（nr_a≥1），要么组合票还剩≥1天（nr_p≥1）。
    > 5. 最后递归处理下一天（day+1），并取所有情况的最小值。
* 💡 **学习笔记**：状态压缩的关键是“变量有上限”——比如票的有效期最多5天，所以剩余天数`r_a`只需记录0-5，这样复杂度就从`O(n²)`降到了`O(n)`！

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了**“像素观光团”**动画，用8位像素风模拟两人的购票过程，帮你直观理解DP状态转移：
</visualization_intro>

  * **动画演示主题**：像素小人“Hankook”和“Jeong-ul”在釜山观光，每天根据日程买不同的票，目标是用最少的钱覆盖所有观光日。
  * **核心演示内容**：
    - 用**网格**表示天数（x轴是天数，从1到n），每个格子里的“发光脚印”表示当天需要观光（A_i=1或B_j=1）。
    - 用**彩色方块**表示DP状态：`dp[i][j]`是一个紫色方块，位置在(i,j)处，方块的亮度表示费用（越亮费用越低）。
    - **转移动画**：当从`dp[i-3][j]`转移到`dp[i][j]`时，会有一个**黄色箭头**从(i-3,j)指向(i,j)，并弹出“3日票”的像素图标（三个绿色连块），伴随“叮”的音效。
    - **组合票动画**：当i=j时，买组合票会弹出“两人手拉手”的图标（红色方块），箭头从(i-4,j-4)指向(i,j)，伴随“铛”的音效。
  * **交互设计**：
    - **控制面板**：有“单步执行”（点击一次走一天）、“自动播放”（速度滑块调节）、“重置”按钮。
    - **状态查看**：鼠标悬停在`dp[i][j]`方块上，会显示当前的费用和“是通过买什么票来的”。
  * **游戏化元素**：
    - **过关奖励**：每覆盖10天，会播放“小胜利”音效，屏幕上弹出“已覆盖10天！”的像素文字。
    - **最终胜利**：当找到`dp[n][n]`时，两个小人会跳起来，屏幕闪烁“最小费用是XX！”，并播放8位风格的胜利音乐。
  * **技术实现**：
    - 用HTML5 Canvas绘制像素网格和小人，用JavaScript实现递归动画。
    - 音效用Web Audio API播放：“叮”（购票）、“铛”（组合票）、“胜利曲”（结束）。

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的DP思路可以迁移到**“覆盖问题”**（比如用不同长度的瓷砖铺地板，或用不同有效期的优惠券覆盖消费），以下是相似练习：
</similar_problems_intro>

  * **通用思路迁移**：
    - 如果你遇到“用不同类型的物品覆盖某个区间，求最小费用/最大价值”的问题，都可以用DP解决：
      1. **一维覆盖**：比如“用1/3/5米的绳子绑包裹，求最少绳子数”（一维DP）。
      2. **二维覆盖**：比如“两个人的课程表，用不同时长的补课班覆盖，求最少费用”（二维DP）。
      3. **状态压缩覆盖**：比如“多个物品的剩余保质期，求最少购买次数”（状态压缩DP）。

  * **洛谷练习推荐**：
    1. **洛谷 P1048 采药**（一维DP）：用不同时间的药材采满背包，求最大价值——练习“一维DP的转移”。
    2. **洛谷 P1280 尼克的任务**（线性DP）：用不同时长的任务填充时间，求最大空闲时间——练习“逆序DP的状态转移”。
    3. **洛谷 P1802 平底锅**（区间DP）：用不同长度的平底锅煎牛排，求最少时间——练习“区间DP的状态定义”。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中摘录了2条宝贵经验，帮你避坑：
</insights_intro>

> **经验1（来自Mindulle的题解）**：“转移时要用`max(i-3,0)`，否则当i<3时会访问dp[-1][j]，导致数组越界！”
> **点评**：数组越界是DP的常见错误，用`max(...,0)`能避免这种问题——比如i=2时，max(2-3,0)=0，就从dp[0][j]转移过来（相当于“买3日票覆盖前2天”）。

> **经验2（来自chen_zhe的题解）**：“状态压缩的关键是找到变量的上限，比如票的有效期最多5天，所以剩余天数只需记录0-5！”
> **点评**：当变量有上限时，状态压缩能极大降低复杂度——比如本题的二维DP是O(2000²)=4e6，而状态压缩DP是O(2000*6*6*5)=3.6e5，快了10倍！

---

<conclusion>
本次关于“釜山观光”的DP分析就到这里啦！记住：DP的核心是“状态定义”和“转移方程”——先想清楚“要记录什么”，再想“怎么从之前的状态转过来”。多做几道相似题，你就能熟练掌握啦！💪
</conclusion>

---

---
处理用时：101.79秒
# 题目信息

# 消失之物

## 题目描述

ftiasch 有 $n$ 个物品, 体积分别是 $w_1,w_2,\dots,w_n$。由于她的疏忽，第 $i$ 个物品丢失了。   

“要使用剩下的 $n-1$ 物品装满容积为 $x$ 的背包，有几种方法呢？”——这是经典的问题了。  

她把答案记为 $\text{cnt}(i,x)$ ，想要得到所有$i \in [1,n]$, $x \in [1,m]$ 的 $\text{cnt}(i,x)$ 表格。

![](https://cdn.luogu.com.cn/upload/pic/13426.png)


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,m \le 2000$，且 $1\le v_i\le m$。

【样例解释】  
如果物品 3 丢失的话，只有一种方法装满容量是 2 的背包，即选择物品 1 和物品 2。

---

$\text{upd 2023.8.11}$：新增加五组 Hack 数据。


## 样例 #1

### 输入

```
3 2
1 1 2```

### 输出

```
11
11
21```

# AI分析结果

# 💡 Kay的C++算法解析：消失之物 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：01背包（退背包技巧）

🗣️ **初步分析**：  
解决“消失之物”的关键，是**用“总方案数”减去“选某物品的方案数”**，得到“不选该物品的方案数”。简单来说，就像你有一个“魔法口袋”，能装下不同大小的“魔法石”（物品），总共有很多种装法（总方案数）。现在拿走一块魔法石（第i个物品），要算出剩下的装法有多少种——这就是**退背包**的核心思想！  

- **题解思路**：  
  1. 先计算**所有物品都可用**时，装满每个体积x的方案数（用01背包求总方案`f[x]`）。  
  2. 对于每个物品i，计算**去掉i后**的方案数`cnt(i,x)`：  
     - 如果x < 物品i的体积`w[i]`，那么i不可能被选，`cnt(i,x) = f[x]`（总方案就是不选i的方案）。  
     - 如果x ≥ `w[i]`，那么`cnt(i,x) = f[x] - cnt(i, x-w[i])`（总方案减去“选了i的方案数”，而选i的方案数等于“不选i时装满x-w[i]的方案数”）。  

- **核心难点**：  
  如何高效计算每个i的`cnt(i,x)`？直接跑n次01背包（每次去掉一个i）会超时（O(n²m)），而退背包技巧能把时间复杂度降到O(nm)。  

- **可视化设计思路**：  
  用**8位像素风格**展示“魔法口袋”的填充过程：  
  - 左侧屏幕显示总方案的背包（不同颜色块代表不同物品，填满时播放“填充完成”音效）；  
  - 右侧屏幕显示“退背包”过程：选中的物品i用**闪烁的红色块**标记，当计算`cnt(i,x)`时，用**蓝色块**表示“不选i的方案”，减去`cnt(i, x-w[i])`时，蓝色块会“吃掉”对应的红色块（伴随“叮”的音效）。  


## 2. 精选优质题解参考

为了帮大家快速掌握核心思路，我筛选了3份**思路清晰、代码易读**的优质题解：


### **题解一（作者：Kelin，赞132）**  
* **点评**：  
  这份题解的**亮点**是用`memcpy`复制总方案数组，然后**顺推减去物品i的贡献**，代码极其简洁！比如：  
  ```cpp
  memcpy(g, f, sizeof f); // 复制总方案到g数组
  for(int j=w[i]; j<=m; ++j)
      g[j] -= g[j-w[i]]; // 顺推减去i的贡献
  ```  
  思路非常直接：总方案`f`是包含i的，`g`数组通过逆向操作（顺推）去掉i的影响，正好得到不选i的方案。这种方法**效率高**（O(m) per i），适合竞赛中快速编码。


### **题解二（作者：Gary818，赞35）**  
* **点评**：  
  这份题解的**亮点**是用`g`数组**逐行递推**每个i的方案数，代码可读性极强！比如：  
  ```cpp
  for(int i=1; i<=n; ++i){
      g[0] = 1; // 体积0的方案数为1（什么都不选）
      for(int x=1; x<=m; ++x){
          if(w[i] > x) g[x] = f[x]%10; // 体积不够，直接用总方案
          else g[x] = (f[x] - g[x-w[i]] + 10)%10; // 减去选i的方案
          cout << g[x];
      }
      cout << endl;
  }
  ```  
  变量命名（`f`总方案、`g`不选i的方案）非常清晰，边界条件（`w[i] > x`）处理得很严谨，而且特意提到了“加10再取模”（避免负数），这是初学者容易忽略的点。


### **题解三（作者：Plus_Ultra，赞4）**  
* **点评**：  
  这份题解的**亮点**是**注释详细**，适合初学者理解每一步的逻辑！比如：  
  ```cpp
  for(int j=m; j>=v[i]; j--)// 01背包倒序枚举（避免重复选）
      f[j]=(f[j]+f[j-v[i]])%10;// 选i的方案数加上不选的
  ```  
  作者特意解释了“倒序枚举”的原因（01背包不能重复选），以及“加10取模”的作用（保证结果为正）。代码去掉空行后只有20行，非常简洁，适合作为入门模板。


## 3. 核心难点辨析与解题策略

在解决本题时，大家常遇到以下3个核心难点，结合优质题解的经验，我总结了应对策略：


### **1. 如何避免n次背包？**  
* **难点分析**：  
  如果对每个i都跑一次01背包（去掉i），时间复杂度是O(n²m)，对于n=2000、m=2000来说，会超时（2000×2000×2000=8e10次操作）。  
* **解决方案**：  
  用**退背包**技巧：先跑一次01背包求总方案`f[x]`（O(nm)），然后对每个i，用`f[x]`减去i的贡献（O(m) per i），总时间复杂度O(nm)（2000×2000=4e6次操作），完全可以通过。


### **2. 退背包的递推式为什么正确？**  
* **难点分析**：  
  为什么`cnt(i,x) = f[x] - cnt(i, x-w[i])`？  
* **解决方案**：  
  总方案`f[x]` = 选i的方案数 + 不选i的方案数（`cnt(i,x)`）。  
  而选i的方案数等于“不选i时装满x-w[i]的方案数”（因为选了i之后，剩下的x-w[i]必须用其他物品装），所以选i的方案数就是`cnt(i, x-w[i])`。  
  因此，`cnt(i,x) = f[x] - cnt(i, x-w[i])`。


### **3. 如何处理负数取模？**  
* **难点分析**：  
  当`f[x] < cnt(i, x-w[i])`时，`f[x] - cnt(i, x-w[i])`会是负数，取模后结果不正确（比如-1%10=-1，但我们需要9）。  
* **解决方案**：  
  计算时加上10再取模，即`(f[x] - cnt(i, x-w[i]) + 10) % 10`。这样即使结果是负数，加10后也会变成正数（比如-1+10=9，9%10=9）。


### ✨ 解题技巧总结  
- **技巧1：问题转换**：把“去掉i的方案数”转换为“总方案数减去选i的方案数”，避免重复计算。  
- **技巧2：递推顺序**：退背包时要**顺推**（x从1到m），因为`cnt(i,x)`依赖于`cnt(i, x-w[i])`（前面的结果）。  
- **技巧3：取模处理**：涉及减法的取模，一定要加10再取模，避免负数。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合Gary818和Plus_Ultra的题解，提炼出最简洁的核心实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cstring>
  using namespace std;

  const int MAXN = 2005;
  int w[MAXN], f[MAXN], g[MAXN];
  int n, m;

  int main() {
      cin >> n >> m;
      for (int i = 1; i <= n; ++i)
          cin >> w[i];

      // 计算总方案数f[x]（01背包）
      f[0] = 1;
      for (int i = 1; i <= n; ++i)
          for (int j = m; j >= w[i]; --j)
              f[j] = (f[j] + f[j - w[i]]) % 10;

      // 计算每个i的cnt(i,x)（退背包）
      for (int i = 1; i <= n; ++i) {
          g[0] = 1; // 体积0的方案数为1
          for (int x = 1; x <= m; ++x) {
              if (w[i] > x)
                  g[x] = f[x] % 10; // 体积不够，直接用总方案
              else
                  g[x] = (f[x] - g[x - w[i]] + 10) % 10; // 减去选i的方案
              cout << g[x];
          }
          cout << endl;
      }

      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：读取物品数量n、最大容积m，以及每个物品的体积w[i]。  
  2. **总方案计算**：用01背包的倒序枚举，计算`f[x]`（装满x的总方案数）。  
  3. **退背包计算**：对每个i，用顺推枚举x，计算`g[x]`（不选i时装满x的方案数），并输出结果。


### 针对各优质题解的片段赏析

#### **题解一（Kelin）：memcpy退背包**  
* **亮点**：用`memcpy`复制总方案，顺推减去贡献，代码简洁。  
* **核心代码片段**：  
  ```cpp
  memcpy(g, f, sizeof f); // 复制总方案到g数组
  for (int j = w[i]; j <= m; ++j)
      g[j] -= g[j - w[i]]; // 顺推减去i的贡献
  ```  
* **代码解读**：  
  - `memcpy(g, f, sizeof f)`：把总方案`f`复制到`g`数组，此时`g`包含i的贡献。  
  - `for (int j = w[i]; j <= m; ++j)`：顺推枚举体积，因为`g[j]`依赖于`g[j - w[i]]`（前面的结果）。  
  - `g[j] -= g[j - w[i]]`：减去i的贡献（选i的方案数），得到不选i的方案数。  
* 💡 **学习笔记**：`memcpy`是C++中复制数组的高效函数，适合需要快速复制大数组的场景。


#### **题解二（Gary818）：g数组递推**  
* **亮点**：逐行计算每个i的方案数，可读性强。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= n; ++i) {
      g[0] = 1;
      for (int x = 1; x <= m; ++x) {
          if (w[i] > x)
              g[x] = f[x] % 10;
          else
              g[x] = (f[x] - g[x - w[i]] + 10) % 10;
          cout << g[x];
      }
      cout << endl;
  }
  ```  
* **代码解读**：  
  - `g[0] = 1`：体积0的方案数为1（什么都不选），这是递推的基础。  
  - `if (w[i] > x)`：如果i的体积大于x，那么i不可能被选，`g[x]`等于总方案`f[x]`。  
  - `else`：`g[x] = (f[x] - g[x - w[i]] + 10) % 10`：减去选i的方案数（`g[x - w[i]]`），得到不选i的方案数。  
* 💡 **学习笔记**：递推时一定要初始化`g[0] = 1`，否则后面的结果都会错！


#### **题解三（Plus_Ultra）：注释详细的01背包**  
* **亮点**：注释解释了倒序枚举的原因，适合初学者。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= n; ++i)
      for (int j = m; j >= w[i]; --j)
          f[j] = (f[j] + f[j - w[i]]) % 10;
  ```  
* **代码解读**：  
  - `for (int j = m; j >= w[i]; --j)`：倒序枚举体积，是01背包的关键（避免同一个物品被选多次）。  
  - `f[j] = (f[j] + f[j - w[i]]) % 10`：`f[j]`表示不选i时的方案数，`f[j - w[i]]`表示选i时的方案数，两者相加得到总方案数。  
* 💡 **学习笔记**：01背包的倒序枚举是为了“保证每个物品只被选一次”，而完全背包（可以重复选）用正序枚举。


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：魔法口袋的“退石”游戏（8位像素风格）  
**设计思路**：用复古的FC游戏风格，让学习者在“玩游戏”中理解退背包的过程。屏幕分为左右两部分：左侧显示总方案的“魔法口袋”，右侧显示“退背包”的过程。


### 📺 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 左侧屏幕：一个32x32的像素网格（代表背包容量），不同颜色的方块代表不同物品（比如红色=物品1，蓝色=物品2，绿色=物品3）。  
   - 右侧屏幕：一个相同大小的网格，显示“退背包”后的结果。  
   - 控制面板：有“开始/暂停”“单步执行”“重置”按钮，以及速度滑块（1x~5x）。  
   - 背景音乐：8位风格的循环BGM（比如《超级马里奥》的背景音乐）。

2. **总方案填充动画**：  
   - 左侧网格开始“填充”：从体积0开始，逐行显示每个体积的方案数（比如体积1用1个红色方块，体积2用1个红色+1个蓝色方块）。  
   - 填充完成时，播放“叮”的音效，左侧网格闪烁一次。

3. **退背包过程演示**：  
   - 选中一个物品（比如物品3，绿色方块），右侧网格开始“退石”：  
     - 对于体积x从1到m：  
       - 如果x < 物品3的体积（比如2），右侧网格直接显示左侧的方块（总方案）。  
       - 如果x ≥ 2，右侧网格会“吃掉”左侧的绿色方块（比如体积2的绿色方块消失，变成红色+蓝色方块），伴随“咔嚓”的音效。  
   - 每一步操作，右侧网格的当前体积x用黄色边框标记，旁边显示文字提示（比如“当前体积：2，不选物品3的方案数：1”）。

4. **目标达成**：  
   - 当所有体积的方案数计算完成时，右侧网格闪烁绿色，播放“胜利”音效（比如《魂斗罗》的通关音乐），并显示“退石成功！”的文字。

5. **交互功能**：  
   - **单步执行**：点击“单步”按钮，逐行显示x的计算过程。  
   - **自动播放**：点击“开始”按钮，动画自动播放，速度由滑块调节。  
   - **重置**：点击“重置”按钮，回到初始状态，重新选择物品。


### 🎧 音效设计  
- **填充完成**：“叮”（高频短音）。  
- **退石操作**：“咔嚓”（低频短音）。  
- **胜利**：“嘟嘟嘟”（上扬的三连音）。  
- **错误**：“哔”（短促的警告音，比如当输入无效时）。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
退背包技巧不仅能解决“消失之物”，还能解决以下问题：  
1. **砝码称重**：给定一组砝码，求去掉某个砝码后，不能称出的重量。  
2. **点菜问题**：给定一组菜品，求去掉某道菜后，能凑出总价的方案数。  
3. **物品分组**：给定一组物品，求去掉某组物品后，能装满背包的方案数。


### 📚 洛谷练习推荐  
1. **洛谷 P1048 采药**（01背包基础）  
   - 🗣️ **推荐理由**：这是01背包的经典题目，练手必备！学会计算“最大价值”，为后续学习“方案数”打下基础。  
2. **洛谷 P1164 小A点菜**（方案数背包）  
   - 🗣️ **推荐理由**：这题要求计算“凑出总价的方案数”，和“消失之物”的总方案计算完全一致，适合巩固01背包的方案数写法。  
3. **洛谷 P2347 砝码称重**（退背包变形）  
   - 🗣️ **推荐理由**：这题要求计算“去掉某个砝码后，不能称出的重量”，需要用到退背包技巧，是“消失之物”的进阶练习。  


## 7. 学习心得与经验分享 (若有)

### 📝 来自题解作者的经验  
- **Gary818**：“我一开始没加10就取模，结果只得了10分！后来才知道，减法取模一定要加10，避免负数。”  
  - **点评**：这是初学者最容易犯的错误！取模时一定要注意符号，加10再取模是解决负数问题的关键。  
- **Plus_Ultra**：“01背包的倒序枚举很重要，我一开始用了正序，结果方案数翻倍了！”  
  - **点评**：倒序枚举是01背包的核心，一定要记住：**01背包倒序，完全背包正序**。  


## 🎉 结语  
本次关于“消失之物”的分析就到这里啦！希望这份指南能帮你理解退背包的技巧，掌握01背包的进阶应用。记住：**编程的乐趣在于解决问题的过程**，遇到难点不要怕，多思考、多练习，你一定会越来越厉害！💪  

下次我们再一起探索新的编程挑战吧！🚀

---
处理用时：235.04秒
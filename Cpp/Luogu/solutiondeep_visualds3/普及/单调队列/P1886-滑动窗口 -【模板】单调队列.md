# 题目信息

# 滑动窗口 /【模板】单调队列

## 题目描述

有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

例如，对于序列 $[1,3,-1,-3,5,3,6,7]$ 以及 $k = 3$，有如下过程：

$$\def\arraystretch{1.2}
\begin{array}{|c|c|c|}\hline
\textsf{窗口位置} & \textsf{最小值} & \textsf{最大值} \\ \hline
\verb![1   3  -1] -3   5   3   6   7 ! & -1 & 3 \\ \hline
\verb! 1  [3  -1  -3]  5   3   6   7 ! & -3 & 3 \\ \hline
\verb! 1   3 [-1  -3   5]  3   6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1 [-3   5   3]  6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1  -3  [5   3   6]  7 ! & 3 & 6 \\ \hline
\verb! 1   3  -1  -3   5  [3   6   7]! & 3 & 7 \\ \hline
\end{array}
$$

## 说明/提示

【数据范围】    
对于 $50\%$ 的数据，$1 \le n \le 10^5$；  
对于 $100\%$ 的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。


## 样例 #1

### 输入

```
8 3
1 3 -1 -3 5 3 6 7```

### 输出

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7```

# AI分析结果

---
# 💡 Kay的C++算法解析：滑动窗口最值 深入学习指南 💡

<introduction>
  今天我们来一起攻克经典的「滑动窗口最值」问题！这道题是单调队列的模板题，掌握它能帮你理解很多高效算法的核心思想。本指南会用「排队买奶茶」的比喻帮你吃透单调队列，还会设计像素动画让你直观看到算法运行过程～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：单调队列 (双端队列的经典应用)

🗣️ **初步分析**：
解决「滑动窗口最值」的关键是**单调队列**——它像「奶茶店的聪明排队系统」：如果后面来的人比你更适合当「最值」（比如求最小值时，后面的人更小），你就可以直接离开队伍，因为你永远不会成为当前或后面窗口的最值！  

具体来说，单调队列有两个核心操作：  
1. **入队**：新元素加入时，从队尾踢掉所有「更劣」的元素（比如求最小值时，踢掉比当前元素大的），保证队列单调递增（最小值队列）或递减（最大值队列）。  
2. **出队**：检查队首元素是否「过期」（不在当前窗口内），如果是就从队首弹出。  

这样，**队首永远是当前窗口的最值**！本题需要同时求最小和最大值，所以要分别维护两个单调队列，或者用「取反技巧」（最大值 = 相反数的最小值的相反数）简化代码。  

**可视化设计思路**：我们会用8位像素风格模拟滑动窗口的移动——窗口用红色框框住，队列用蓝色方块排列，当前处理的元素用黄色高亮。入队时播放「叮」的音效，出队时播放「嗒」的音效，找到最值时播放「叮铃」的提示音。还能单步执行看每一步变化，像玩FC游戏一样学算法～


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度，为你筛选了3份超棒的题解，帮你快速入门！
</eval_intro>

**题解一：hilsinleri的「逐步骤模拟」题解（赞877）**
* **点评**：这份题解用样例一步步拆解单调队列的操作，像「手把手教你排队」！比如处理样例中的-1时，详细说明「为什么要踢掉1和3」——因为-1更小，且存在时间更长，前面的数永远成不了最小值。代码用结构体封装队列（q存值、p存下标），变量命名清晰，逻辑严谨到每一步都有注释，完全是入门者的「说明书」！

**题解二：Jerrycyx的「取反技巧」题解（赞8）**
* **点评**：这题解的「取反 trick」太妙了！求最大值时，把数组所有元素取反，求一遍最小值，再取反就是最大值——这样只需写一个`Calc`函数，避免重复写两套几乎一样的代码。代码简短且高效，还提到「单调队列的核心是踢掉老而更劣的元素」，一句话点透本质，适合想偷懒（哦不，想高效）的你～

**题解三：yr409892525的「数组模拟队列」题解（赞6）**
* **点评**：这份题解用数组模拟双端队列（`q`数组存下标，`l`和`r`控制队首队尾），比STL的`deque`更快！代码里求最小和最大值的逻辑高度统一，只是比较条件相反（求最小是`a[q[r]] >= a[i]`，求最大是`a[q[r]] <= a[i]`）。对于大数据量的题目，这种手写队列的方式能帮你避免超时，是竞赛中的「性能小技巧」～


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
刚学单调队列时，最容易卡壳的3个问题，我帮你总结好了应对方法！
</difficulty_intro>

1. **关键点1：如何维护队列的单调性？**
    * **分析**：入队时，从队尾开始，把所有「比当前元素更劣」的元素踢掉。比如求最小值时，当前元素是-1，队尾是3和1——因为3和1都比-1大，且-1存在时间更长，所以它们永远成不了最小值，直接踢掉！这样队列就保持单调递增，队首是最小的。
    * 💡 **学习笔记**：单调队列的「单调」是靠「踢掉更劣的老元素」维持的！

2. **关键点2：如何处理「过期」的队首元素？**
    * **分析**：每次入队后，检查队首元素的下标是否小于「当前窗口的左边界」（比如窗口大小k=3，当前是第i位，左边界是i-2）。如果是，说明队首元素已经不在窗口里了，直接弹出队首。
    * 💡 **学习笔记**：过期元素要「赶早不赶晚」，否则队首会是无效值！

3. **关键点3：如何同时求最大和最小？**
    * **分析**：有两种方法：① 跑两次单调队列（一次求最小，一次求最大）；② 用取反技巧（最大值 = -min(-数组)）。第二种方法更简洁，适合代码复用。
    * 💡 **学习笔记**：学会「转化问题」，能减少重复劳动！

### ✨ 解题技巧总结
- **技巧1：双端队列是核心**：单调队列需要从队首和队尾操作，所以必须用双端队列（或数组模拟）。
- **技巧2：存下标而不是值**：这样才能判断元素是否过期（用下标减窗口大小）。
- **技巧3：取反简化代码**：求最大值时，把数组取反，求最小值后再取反，只需写一套逻辑。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份「通用核心代码」，它综合了优质题解的优点，用数组模拟队列，逻辑清晰，适合入门！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码用数组模拟双端队列，分别处理最小值和最大值，注释详细，覆盖所有边界情况。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    const int MAXN = 1e6 + 5;
    int a[MAXN], q[MAXN]; // q数组存下标
    int n, k;

    // 求滑动窗口最小值，结果存在res数组中
    void get_min(int res[]) {
        int l = 1, r = 0; // 队首l，队尾r（初始为空）
        for (int i = 1; i <= n; i++) {
            // 1. 踢掉队尾更劣的元素（比当前大的）
            while (l <= r && a[q[r]] >= a[i]) r--;
            // 2. 加入当前元素的下标
            q[++r] = i;
            // 3. 踢掉过期的队首元素
            while (l <= r && q[l] < i - k + 1) l++;
            // 4. 输出结果（i >= k时窗口形成）
            if (i >= k) res[i - k] = a[q[l]];
        }
    }

    // 求滑动窗口最大值，结果存在res数组中
    void get_max(int res[]) {
        int l = 1, r = 0;
        for (int i = 1; i <= n; i++) {
            // 踢掉队尾更劣的元素（比当前小的）
            while (l <= r && a[q[r]] <= a[i]) r--;
            q[++r] = i;
            while (l <= r && q[l] < i - k + 1) l++;
            if (i >= k) res[i - k] = a[q[l]];
        }
    }

    int main() {
        cin >> n >> k;
        for (int i = 1; i <= n; i++) cin >> a[i];
        
        int min_ans[MAXN], max_ans[MAXN];
        get_min(min_ans);
        get_max(max_ans);
        
        // 输出最小值
        for (int i = 0; i <= n - k; i++) cout << min_ans[i] << " ";
        cout << endl;
        // 输出最大值
        for (int i = 0; i <= n - k; i++) cout << max_ans[i] << " ";
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：① 输入数组；② 调用`get_min`和`get_max`分别求最小和最大值；③ 输出结果。`get_min`和`get_max`的逻辑几乎一样，只是**队尾的比较条件相反**（求最小是`>=`，求最大是`<=`）。`q`数组存的是元素的下标，这样能方便判断是否过期。


---
<code_intro_selected>
接下来看优质题解的「精华片段」，学它们的巧妙技巧！
</code_intro_selected>

**题解二：Jerrycyx的「取反技巧」片段**
* **亮点**：用「取反」把最大值转化为最小值，只需写一个`Calc`函数，代码更简洁！
* **核心代码片段**：
    ```cpp
    void Calc(int res[]) {
        int head = 1, tail = 0;
        for (int i = 1; i <= n; i++) {
            while (head <= tail && i - q[head] + 1 > k) head++;
            while (head <= tail && a[q[tail]] > a[i]) tail--;
            q[++tail] = i;
            if (i >= k) res[i - k + 1] = q[head];
        }
    }

    int main() {
        // 求最小值
        Calc(ans1);
        // 求最大值：数组取反，求最小值后再取反
        for (int i = 1; i <= n; i++) a[i] = -a[i];
        Calc(ans2);
        for (int i = 1; i <= n - k + 1; i++) cout << -a[ans2[i]] << " ";
    }
    ```
* **代码解读**：
    > 这段代码的妙处在于「转化问题」：最大值等于「数组取反后的最小值的相反数」。比如原数组是[1,3,-1]，取反后是[-1,-3,1]，最小值是-3，再取反就是3——正好是原数组的最大值！这样只需写一个`Calc`函数，避免重复写两套逻辑。
* 💡 **学习笔记**：学会「问题转化」，能大幅减少代码量！


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你「看得到」单调队列的运行，我设计了一个**FC风格的像素动画**，像玩《超级马里奥》一样学算法！
</visualization_intro>

  * **动画演示主题**：《像素队列大冒险》——滑动窗口在数组上移动，单调队列帮你找最值！
  * **核心演示内容**：展示滑动窗口的移动、单调队列的入队/出队操作、最值的生成过程。
  * **设计思路**：用8位像素风格（FC红白机的配色）降低视觉压力，用音效强化操作记忆（比如入队「叮」、出队「嗒」），用单步执行让你慢慢琢磨每一步——就像玩游戏通关一样，每完成一个窗口的最值计算，就弹出「过关」提示！

### 动画细节设计
1. **场景初始化**：
   - 屏幕左边是「数组区」：每个元素用16x16的像素方块表示，数值显示在方块中间。
   - 屏幕右边是「队列区」：用蓝色方块排列，队首用红色箭头标注，当前处理的元素用黄色高亮。
   - 底部是「控制面板」：有「单步」「自动」「重置」按钮，速度滑块（从「龟速」到「光速」），还有当前执行的代码行高亮（比如`while (l <= r && a[q[r]] >= a[i]) r--;`）。

2. **算法运行步骤**：
   - **入队操作**：新元素（比如-1）进入时，队尾的3和1被踢掉（方块慢慢消失），同时播放「叮」的音效，-1的方块滑入队列。
   - **出队操作**：队首的-3过期时（下标小于窗口左边界），红色箭头指向的方块弹出队列，播放「嗒」的音效。
   - **最值生成**：窗口形成时（i >= k），队首的方块闪烁，播放「叮铃」的音效，数值显示在屏幕上方的「结果区」。

3. **游戏化元素**：
   - **关卡设计**：每处理3个窗口为一个「小关卡」，完成后弹出「关卡通关」提示，加10分！
   - **AI演示**：点击「AI自动玩」，算法会自动执行，像「贪吃蛇AI」一样帮你通关，你只需观察每一步。

### 为什么这样设计？
- **像素风格**：唤起你对经典游戏的回忆，降低学习的「陌生感」。
- **音效提示**：用声音强化操作记忆，比如「叮」代表入队，「嗒」代表出队，下次写代码时，耳边会自动想起这些声音！
- **单步执行**：让你慢慢琢磨每一步的逻辑，避免「看得懂代码但想不通为什么」的困惑。


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
单调队列的应用远不止这道题！它还能解决「滑动窗口的最值」「动态规划优化」等问题，赶紧用这些题巩固一下～
</similar_problems_intro>

  * **通用思路迁移**：
    单调队列适合解决「**区间左右端点都单调移动**」的最值问题，比如：
    1. 滑动窗口的平均值（但平均值不需要单调队列，这里只是举例）；
    2. 动态规划中的「滑动窗口最大值优化」（比如「烽火传递」问题）；
    3. 求数组中每个元素的「next greater element」（下一个更大元素）。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P2032 扫描**  
      🗣️ **推荐理由**：滑动窗口求最大值，直接应用本题的单调队列技巧，帮你巩固基础！
    2. **洛谷 P1440 求m区间内的最小值**  
      🗣️ **推荐理由**：滑动窗口求最小值，和本题的「最小值部分」完全一样，练熟它你就是单调队列小能手！
    3. **洛谷 P3817 小A的糖果**  
      🗣️ **推荐理由**：滑动窗口+贪心，拓展单调队列的使用场景，让你学会「举一反三」！


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解里的「经验之谈」，比代码更值钱！
</insights_intro>

> **参考经验 (来自 Jerrycyx)**：「单调队列的核心是『老而更劣的元素永远不可能成为最值』——这句话我记了三年，每次写单调队列都能想起它！」
>
> **点评**：这句话太精辟了！比如求最小值时，老元素（下标小）如果比新元素大，那它永远成不了最小值——因为新元素存在时间更长，且更小。记住这句话，你写单调队列时永远不会乱！

> **参考经验 (来自 yr409892525)**：「手写队列比STL的deque快！大数据量时，数组模拟队列能避免超时。」
>
> **点评**：竞赛中「性能」很重要！比如本题n=1e6时，STL的deque可能会慢一点，手写队列能帮你节省时间～


---

<conclusion>
单调队列是「用空间换时间」的经典例子——它用O(n)的时间解决了暴力O(nk)的问题！今天的学习指南帮你吃透了它的核心思想，还设计了像素动画让你直观看到运行过程。下次遇到滑动窗口的问题，记得想起「奶茶店的聪明排队系统」——你一定能快速解决！💪
</conclusion>

---

---
处理用时：126.20秒
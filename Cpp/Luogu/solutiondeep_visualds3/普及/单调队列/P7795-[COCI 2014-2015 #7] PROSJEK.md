# 题目信息

# [COCI 2014/2015 #7] PROSJEK

## 题目描述

给定一个有 $n$ 个整数的数列 $a$。请找出一个长度至少为 $k$ 的连续子序列，使这个子序列的所有数的平均值最大。

## 说明/提示

**【数据范围】**

对于 $30\%$ 的数据，保证 $n\leqslant 5000$。  
对于所有数据，$1\leqslant k\leqslant n\leqslant 3\times 10^5$，$1\leqslant a_i\leqslant 10^6$。

**【题目来源】**

本题来源自 **_[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST 7](https://hsin.hr/coci/archive/2014_2015/contest7_tasks.pdf) T5 PROSJEK_**，按照原题数据配置，满分 $140$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
4 1
1 2 3 4```

### 输出

```
4.000000```

## 样例 #2

### 输入

```
4 2
2 4 3 4```

### 输出

```
3.666666```

## 样例 #3

### 输入

```
6 3
7 1 2 1 3 6```

### 输出

```
3.333333```

# AI分析结果

# 💡 Kay的C++算法解析：PROSJEK 深入学习指南 💡

<introduction>
今天我们来一起分析COCI 2014/2015赛季的经典题目「PROSJEK」——找长度至少为k的连续子序列的最大平均值。这道题是**分数规划+二分答案**的典型应用，还能延伸到斜率优化的高级技巧。跟着Kay一步步拆解，你会发现“求最大平均值”其实是个“猜数字+验证”的游戏～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分答案（分数规划） + 前缀和优化 + （可选）斜率优化


🗣️ **初步分析**：
解决“最大连续子段平均值”问题，关键在于**把“求最大值”转化为“猜答案+验证”**——这就是二分答案的核心！比如你猜一个平均值`mid`，要判断是否存在长度≥k的子段，其平均值≥`mid`。如果能，说明`mid`还能更大；如果不能，说明得猜小一点。

那怎么验证`mid`呢？我们可以把原数组每个元素减`mid`，问题就变成：**是否存在长度≥k的子段，其和≥0**（因为原平均值≥`mid`等价于“元素减`mid`后的和≥0”）。这个验证可以用**前缀和+维护最小值**做到O(n)时间：
- 计算前缀和数组`s`（每个元素是`a[i]-mid`的累加）；
- 对于每个右端点`i`，我们要找`j ≤ i-k`中最小的`s[j]`——因为`s[i]-s[j]`就是子段`j+1~i`的和，最小值减出来的结果最大，更容易≥0。

如果觉得二分还不过瘾，还有**斜率优化**的O(n)做法：把每个位置的前缀和看作点`(i, sum[i])`，那么子段`j+1~i`的平均值就是两点间的斜率。我们需要找斜率最大的两点，且横坐标差≥k——这可以用单调队列维护**下凸包**来快速找到最优的`j`。

为了让你更直观理解，Kay设计了一个**像素风格的“数字山脉探险”动画**：
- 用8位像素块表示数组元素（越高的块代表数值越大）；
- 二分过程像“调整望远镜焦距”——左边界`l`是当前最小猜测，右边界`r`是最大猜测，`mid`是当前瞄准的目标；
- 验证`mid`时，探险家沿着山脉走，边走边算“减mid后的前缀和”（用不同颜色标记），同时背着一个“最小前缀和背包”（实时更新前i-k的最小值）；
- 当发现某段的和≥0时，播放“叮”的音效，山脉会闪烁提示“找到啦！”；
- 最终最大的`mid`会被高光显示，伴随胜利音效～


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，覆盖了主流解法和高级技巧，适合不同阶段的学习者～
</eval_intro>


**题解一：Pengzt（二分答案+前缀和优化，赞7）**
* **点评**：这份题解的思路像“剥洋葱”一样直白！核心逻辑是“二分平均值+O(n)验证”，代码简洁到极致——没有多余的变量，`check`函数只用了两行关键逻辑：维护前i-k的最小前缀和，计算当前最大子段和。特别适合刚学二分的同学：变量名`b`（前缀和数组）、`mnv`（最小前缀和）含义明确，循环结构清晰，甚至连头文件都用了`<bits/stdc++.h>`简化代码。从竞赛角度看，这份代码的时间复杂度（O(n log 1e6)）完全能过3e5的数据，是“标准解法”的模板。


**题解二：wangbinfeng（二分答案+快读，赞7）**
* **点评**：这份题解的亮点是**实用性**——加入了快读模板（处理大数据的必备技巧），注释详细到每一步的目的。比如`cheak`函数里的注释“用O(n)的时间复杂度判断结果是否正确”，直接点出了验证的核心。代码中的变量`l`、`r`、`mid`命名符合二分的常规习惯，`s`数组是前缀和，`minn`是维护的最小值。对于刚开始接触竞赛的同学，这份题解的“接地气”能帮你快速理解“二分+验证”的流程，甚至可以直接复制代码调试！


**题解三：lvvd（斜率优化O(n)做法，赞3）**
* **点评**：这是一份“进阶玩家”的题解！作者把平均值转化为**两点间的斜率**（比如点`(i, sum[i])`和`(j, sum[j])`的斜率就是子段`j+1~i`的平均值），然后用单调队列维护**下凸包**——因为下凸包上的点能保证斜率递增，从而快速找到最大斜率的点对。虽然代码里的`xl`函数（计算斜率）、`q`数组（单调队列）需要一点几何知识，但这是**O(n)时间**的最优解，适合想深入学习“优化技巧”的同学。题解的代码非常紧凑，没有冗余，能帮你理解“如何把数学模型转化为代码”。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要是三个问题：**怎么转化问题？怎么高效验证？怎么优化到O(n)？** 结合优质题解的共性，Kay帮你拆解清楚～
</difficulty_intro>


### 1. 难点1：如何把“最大平均值”转化为“可二分的问题”？
* **分析**：直接枚举所有长度≥k的子段是O(n²)，肯定超时。这时候要想到**分数规划**——把“求最大值”转化为“判断是否存在解≥mid”。通过移项（原平均值≥mid → 元素减mid后的和≥0），问题就变成了“找和≥0的子段”，这是我们熟悉的问题！
* 💡 **学习笔记**：分数规划的核心是“将最优问题转化为判定问题”，适用于求“最大值/最小值的比值”类问题。


### 2. 难点2：如何用O(n)时间验证“是否存在和≥0的子段”？
* **分析**：验证的关键是**前缀和+维护最小值**。假设前缀和数组是`s`，那么子段`j+1~i`的和是`s[i]-s[j]`。要让这个和≥0，就要找`j ≤ i-k`中最小的`s[j]`（因为`s[i]`固定，减越小的数结果越大）。所以我们只需要遍历`i`，同时维护前`i-k`个`s[j]`的最小值即可。
* 💡 **学习笔记**：前缀和是处理连续子段和的“神器”，而维护最小值是“贪心”的体现——用最小的代价换最大的结果。


### 3. 难点3：如何用斜率优化做到O(n)时间？
* **分析**：把每个位置`i`看作点`(i, sum[i])`，子段`j+1~i`的平均值就是两点间的斜率`(sum[i]-sum[j])/(i-j)`。我们需要找斜率最大的点对，且`i-j≥k`。这时候可以用**单调队列维护下凸包**：下凸包上的点满足“相邻两点的斜率递增”，所以队首的点就是当前最优的`j`（斜率最大）。
* 💡 **学习笔记**：斜率优化的本质是“用几何结构优化动态规划/贪心的决策过程”，适用于“决策具有单调性”的问题。


### ✨ 解题技巧总结
- **技巧1：问题转化**：遇到“最大值/最小值的比值”问题，先想分数规划+二分答案。
- **技巧2：前缀和优化**：连续子段和的问题，优先用前缀和转化为“两点差”。
- **技巧3：单调队列/凸包**：当需要快速找到“最优决策点”时，考虑用单调数据结构维护。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用的二分答案模板**——来自Pengzt的题解，逻辑清晰，适合初学者上手～
</code_intro_overall>


### 本题通用核心C++实现参考
* **说明**：本代码是“二分答案+前缀和优化”的标准实现，覆盖了所有测试点，时间复杂度O(n log 1e6)。
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;

const int N = 3e5 + 5;
const double eps = 1e-6;
int n, k;
int a[N];
double b[N]; // 前缀和数组（a[i]-mid的累加）

bool check(double mid) {
    for (int i = 1; i <= n; i++) {
        b[i] = b[i - 1] + a[i] - mid; // 计算前缀和
    }
    double mnv = 1e9; // 维护前i-k的最小前缀和
    for (int i = k; i <= n; i++) {
        mnv = min(mnv, b[i - k]); // 更新最小值（i-k是左端点的前一个位置）
        if (b[i] - mnv >= 0) return true; // 存在符合条件的子段
    }
    return false;
}

int main() {
    scanf("%d %d", &n, &k);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    double l = 1, r = 1e6; // 二分边界（a[i]≥1，≤1e6）
    while (l + eps < r) {
        double mid = (l + r) / 2;
        if (check(mid)) l = mid; // 可以更大
        else r = mid; // 得更小
    }
    printf("%.6lf\n", l);
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取n、k和数组a；
  2. **二分过程**：左边界l=1（a[i]最小是1），右边界r=1e6（a[i]最大是1e6），不断缩小范围；
  3. **check函数**：计算每个元素减mid后的前缀和，维护前i-k的最小前缀和，判断是否存在子段和≥0。


<code_intro_selected>
接下来看三份优质题解的核心片段，感受不同的实现细节～
</code_intro_selected>


### 题解一：Pengzt的check函数（亮点：简洁高效）
* **亮点**：用最少的代码实现最核心的逻辑，没有冗余变量。
* **核心代码片段**：
```cpp
bool check(double mid) {
    for (int i = 1; i <= n; i++) {
        b[i] = b[i - 1] + a[i] - mid;
    }
    double res = -1, mnv = 1e9;
    for (int i = k; i <= n; i++) {
        mnv = min(mnv, b[i - k]);
        res = max(res, b[i] - mnv);
    }
    return res >= 0;
}
```
* **代码解读**：
  - 第一循环：计算前缀和`b`（每个元素是`a[i]-mid`的累加）；
  - 第二循环：`mnv`是前i-k个前缀和的最小值，`res`是当前最大的子段和（`b[i]-mnv`）；
  - 最后判断`res≥0`——只要有一个子段和≥0，就说明`mid`可行。
* 💡 **学习笔记**：用`res`记录最大子段和，比直接return更严谨（比如可能多个子段都满足条件，但只要有一个就行）。


### 题解二：wangbinfeng的快读模板（亮点：处理大数据）
* **亮点**：快读模板是竞赛中处理大数据的必备技巧，能避免cin的超时问题。
* **核心代码片段**：
```cpp
inline int read(){
    int x=0,f=1;char ch=getchar();
    while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}
    while(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}
    return x*f;
}
```
* **代码解读**：
  - 用`getchar()`逐字符读取，比`cin`快得多；
  - 处理负数（虽然本题a[i]≥1，但模板通用）；
  - 最后返回读取的整数。
* 💡 **学习笔记**：快读模板要背下来，遇到大数据输入（比如n>1e5）时直接用。


### 题解三：lvvd的斜率优化（亮点：O(n)时间）
* **亮点**：将平均值转化为斜率，用单调队列维护下凸包，达到O(n)时间复杂度。
* **核心代码片段**：
```cpp
double xl(ll s, ll t) { // 计算点(s, sum[s])和(t, sum[t])的斜率
    return (sum[t] - sum[s]) * 1.0 / (t - s);
}

int main() {
    // 输入处理...
    for (int i = k; i <= n; i++) {
        // 维护下凸包：移除队尾不满足下凸的点
        while (back - front >= 2 && xl(i - k, q[back - 2]) > xl(i - k, q[back - 1])) --back;
        q[back++] = i - k; // 将i-k加入队列
        // 维护队首：移除不满足斜率递增的点
        while (back - front >= 2 && xl(i, q[front + 1]) > xl(i, q[front])) ++front;
        ans = max(ans, xl(i, q[front])); // 更新最大斜率
    }
    // 输出...
}
```
* **代码解读**：
  - `xl`函数计算两点间的斜率（平均值）；
  - 第一个while：维护下凸包——如果队尾两个点与新点的斜率递减，说明队尾点不是最优的，移除；
  - 第二个while：维护队首——如果队首两个点与当前点的斜率递增，说明队首点不是最优的，移除；
  - `ans`记录最大的斜率（即最大平均值）。
* 💡 **学习笔记**：斜率优化的关键是“维护凸包的单调性”，这样队首永远是当前最优的决策点。


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到二分答案和check函数的运行过程，Kay设计了一个**8位像素风格的“数字山脉探险”动画**——像玩FC游戏一样学算法！
</visualization_intro>


### 动画设计方案
#### **1. 整体风格与场景**
- **8位像素风**：用FC红白机的色彩（比如蓝色天空、绿色草地、棕色山脉），数组元素用不同高度的像素块表示（越高的块数值越大）；
- **场景布局**：
  - 左侧：数字山脉（数组a的像素化展示）；
  - 中间：二分控制面板（左边界l、右边界r、当前mid的数值显示，用像素按钮控制“单步/自动”）；
  - 右侧：check过程展示（前缀和曲线、最小前缀和背包、当前子段的高亮）；
- **背景音乐**：循环播放8位风格的轻快BGM（比如《超级马里奥》的背景音）。


#### **2. 核心动画步骤**
##### **(1) 初始化场景**
- 输入数组a：比如样例1的输入`4 1 1 2 3 4`，山脉会显示为4个逐渐变高的像素块（1→2→3→4）；
- 二分边界：l=1，r=4（因为a[i]最大是4），mid=2.5；
- check面板：前缀和曲线初始为0，最小前缀和背包为空。


##### **(2) 二分过程演示**
- **单步执行**：点击“下一步”，mid会变成(l+r)/2（比如第一次是2.5），控制面板上的`mid`数值会闪烁；
- **自动播放**：点击“自动”，mid会快速调整，l和r的像素块会逐渐靠近（比如l从1→2→3→4，r从4→3.5→3.75→4）；
- **音效**：每次调整mid时，播放“滴”的轻微音效。


##### **(3) check过程演示**
- **前缀和计算**：探险家（一个像素小人）从左到右走山脉，每走一步，前缀和曲线（红色像素线）会上升或下降（比如a[1]-mid=1-2.5=-1.5，曲线下降）；
- **维护最小前缀和**：探险家背着一个“背包”（黄色像素框），里面装着前i-k的最小前缀和。比如i=k=1时，背包里是b[0]=0（前缀和初始值）；
- **判断子段和**：当探险家走到i=4时，b[4]=1-2.5+2-2.5+3-2.5+4-2.5= (1+2+3+4) - 4*2.5=10-10=0，背包里的最小值是b[0]=0，所以b[4]-b[0]=0≥0——此时山脉会闪烁绿色，播放“叮”的胜利音效，提示“mid=2.5可行！”。


##### **(4) 结果展示**
- 当二分结束时，最大的mid（比如样例1的4.0）会被金色像素框高亮，右侧面板会显示“最大平均值：4.000000”，同时播放胜利BGM（比如《超级马里奥》的通关音）。


#### **3. 交互设计**
- **控制按钮**：单步、自动、重置（回到初始状态）；
- **速度滑块**：调整自动播放的速度（从“慢”到“快”）；
- **算法对比**：可以切换“二分答案”和“斜率优化”两种模式，并行展示两种算法的运行过程（比如左侧是二分，右侧是斜率优化）。


<visualization_conclusion>
通过这个动画，你能**直观看到**二分如何“缩小范围”，check如何“找子段”——就像玩游戏一样，边玩边学，是不是很有趣？


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“二分答案+分数规划”，你可以解决很多类似的问题！比如求“最大/最小的比值”“最优比率环”等～
</similar_problems_intro>


### **通用思路迁移**
- **场景1**：求“最大比率路径”（比如图中每条边有收益和成本，找一条路径使收益/成本最大）；
- **场景2**：求“最优比率环”（比如图中找一个环，使环上的收益/成本最大）；
- **场景3**：求“最小平均值的子段”（把二分的条件反过来即可）。


### **洛谷练习推荐**
1. **洛谷 P3705 [SDOI2017]新生舞会**  
   🗣️ **推荐理由**：这是分数规划的经典题！需要找一个匹配，使总喜欢度/总讨厌度最大，和本题的“最大平均值”思路完全一致。
   
2. **洛谷 P1115 最大子段和**  
   🗣️ **推荐理由**：本题的check函数其实是“最大子段和”的变种（长度≥k），这道题能帮你巩固前缀和优化的基础。
   
3. **洛谷 P2672 推销员**  
   🗣️ **推荐理由**：虽然不是分数规划，但涉及“贪心+前缀和”，能帮你练习“维护最优决策”的思路。
   
4. **洛谷 P1880 石子合并**  
   🗣️ **推荐理由**：涉及区间和的动态规划，能帮你深化对“连续子段”问题的理解。


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，Kay总结了几个**容易踩坑的点**，帮你避免掉坑～
</insights_intro>


> **经验1：浮点数的精度问题**  
> 很多题解都提到了`eps`的设置（比如1e-6），这是因为二分小数时，不能直接用`l < r`（会陷入死循环）。要设置一个足够小的`eps`（比如1e-6或1e-7），当`r-l < eps`时停止。
>
> **点评**：浮点数的精度是竞赛中的常见问题，一定要记得设置`eps`！比如样例2的输出是3.666666（即11/3），如果`eps`设得太大（比如1e-4），可能会输出3.6666而不是3.666666。


> **经验2：前缀和的初始化**  
> 很多题解的前缀和数组`b[0]`初始化为0，这是因为子段`1~i`的和是`b[i]-b[0]`（对应j=0的情况）。如果忘记初始化`b[0]`，会导致前k个元素的子段无法正确计算。
>
> **点评**：前缀和的初始化是“细节决定成败”的典型——看似小问题，实则影响整个结果。


> **经验3：斜率优化的凸包维护**  
> lvvd的题解中，维护下凸包时用了`xl(i-k, q[back-2]) > xl(i-k, q[back-1])`——这是因为要保证凸包的“下凸”性质（斜率递增）。如果符号写反了，会维护成上凸包，导致结果错误。
>
> **点评**：斜率优化的符号问题容易搞错，一定要结合几何意义理解（下凸包的斜率递增，上凸包的斜率递减）。


---

<conclusion>
本次关于“PROSJEK”的分析就到这里～这道题的核心是**二分答案+分数规划**，而斜率优化是进阶技巧。记住：遇到“最大值/最小值的比值”问题，先想“能不能二分？能不能转化为判定问题？”。

编程的乐趣在于“把复杂问题拆成简单步骤”——就像玩拼图一样，一块块拼起来，就能完成一幅美丽的画～下次我们再一起探索新的算法挑战！💪
</conclusion>

---
处理用时：146.28秒
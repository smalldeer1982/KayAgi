# 题目信息

# [JSOI2010] 排名

## 题目背景

在植树节那天，小 L，小 H，小 X 却要面对繁忙的考试。

考完后，按照惯例，他们讨论起了成绩。小 L 非常八卦，他向全班 $N$ 个同学问了他们的成绩情况。当然，就如你想象的那样，每个人也不愿意透露太多信息，每个人只说了他的分数比哪一个同学低，也有些人没说任何信息。

勤奋的小 H 和爱偷懒的小 X 对于班上所有同学的成绩排名都有一个“心理期望”，也就是说，小 H 可能认为 XX 会排第 $1$，YY 会排第 $2$……但小 X 却会认为 XX 应该排最后 $1$ 名，YY 会排倒数第 $2$ 名。

不过理想和现实总是有差距的，通过小 L 打探到的情报， XX 不能排在第 $1$ 了，但是，小 H 仍然觉得 XX 应该排在尽可能前。

小 L 由此想到了一个问题，他想知道小 H 和小 X 知道他打探到的情报之后，对班上同学的心里排名是什么样的。

每个同学的编号即为小 H 的心理排名，也就是说，小 H 希望编号越靠前的同学排名也尽量靠前，而小 X 希望希望编号越靠前的同学排名尽量靠后。（注意不是越后面的同学排名越靠前）

## 题目描述

给定一个长度为 $N$ 的数列 $A$，其中 $A_i$ 表示第 $i$ 个同学的分数比第 $A_i$ 个同学的分数低（或者说，第 $i$ 个同学的排名在第 $A_i$ 个同学之后）。当然，$A_i$ 有可能等于 $0$，则表明没有关于第 $i$ 个同学的信息。

你需要得到一个长度为 $N$ 的数列 $H$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最小的哪一个。

同时，你还需要得到一个数列 $X$，表示班上同学的排名。这个排名要求是满足所有 $A_i$ 构成的约束的排名中字典序最大的哪一个。

## 说明/提示

### 样例解释

共有 $3$ 种排名满足大小关系：

```plain
4 1 3 2
4 1 2 3
3 1 2 4
```

其中，`3 1 2 4` 字典序最小，`4 1 3 2` 字典序最大。

### 数据范围

对于 $10\%$ 的数据，$N\leq 10$。

对于 $20\%$ 的数据，$N\leq 20$。

对于 $40\%$ 的数据，$N\leq 2\times 10^3$。

对于 $100\%$ 的数据，$1 \leq N\leq 2\times 10^5,A_i\leq N$。其中，第 $5$ 组数据保证 $N=1.2\times 10^4$。

## 样例 #1

### 输入

```
4
3 0 2 2```

### 输出

```
3 1 2 4
4 1 3 2```

# AI分析结果


### 💡 Kay的C++算法解析：排名 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`图论（拓扑排序）`  
🗣️ **初步分析**：  
> 本题需要构建约束关系的有向图（边 `a[i] → i` 表示 `a[i]` 排名高于 `i`），核心是通过拓扑排序生成满足约束的排名序列。**第一问**要求字典序最小的排名序列（编号小的同学尽量靠前），**第二问**要求字典序最大的排名序列（编号小的同学尽量靠后）。拓扑排序的贪心策略选择是关键难点。  
> - **第一问**：倒序拓扑排序（从大到小分配名次），每次选择入度为0的**最大编号**节点，确保编号小的同学能尽早获得靠前名次。  
> - **第二问**：正序拓扑排序（从小到大分配名次），每次选择入度为0的**最大编号**节点，让编号小的同学获得靠后名次。  
> - **可视化设计**：采用8位像素风格，节点为彩色方块，边为箭头。动画高亮当前入度为0的节点集合，红色标记被选中的节点，音效反馈操作（选择"叮"，更新"滴答"，完成"胜利音效"）。控制面板支持步进/调速，自动模式模拟AI解题过程。

---

#### 2. 精选优质题解参考
**题解一（作者：hepp）**  
* **点评**：思路清晰，第一问用递归计算节点深度（避免显式建图），第二问用大顶堆拓扑排序。代码变量名明确（`ans[i]`为名次），边界处理严谨。亮点是递归方法直接利用链式结构，但递归深度可能影响大数据的稳定性。实践参考价值高，尤其适合理解树形约束。

**题解二（作者：Jimmy_Cao）**  
* **点评**：两问均用拓扑排序，策略对比鲜明。第一问倒序分配名次（选最大编号节点），第二问正序分配（同选最大编号）。代码规范（链式前向星建图），可读性强。亮点是统一框架处理两问，复杂度O(n log n)高效，竞赛适用性强。

---

#### 3. 核心难点辨析与解题策略
1. **难点1：理解输出序列的字典序含义**  
   * **分析**：输出是名次序列（第i个位置是第i个同学的名次），而非学生编号序列。字典序最小要求名次序列尽可能"小"（如`3 1 2 4`优于`4 1 2 3`）。  
   * 💡 **学习笔记**：明确字典序比较对象是名次序列。

2. **难点2：第一问的贪心策略设计**  
   * **分析**：为让编号小的同学名次靠前，需优先处理编号大的节点（分配较大名次），腾出小名次给编号小的节点。倒序拓扑排序（选最大编号+名次从n递减）是关键。  
   * 💡 **学习笔记**：倒序分配名次是字典序最小的核心技巧。

3. **难点3：第二问的拓扑排序实现**  
   * **分析**：为让编号小的同学名次靠后，需延迟分配其名次。正序拓扑排序（选最大编号+名次从1递增）确保编号小的节点被分配较大名次。  
   * 💡 **学习笔记**：大顶堆贪心策略使编号小的节点"滞留"更久。

### ✨ 解题技巧总结
- **技巧1：约束建图**：将`a[i]`视为父节点，`i`为子节点，边表示排名约束。  
- **技巧2：贪心选择策略**：第一问倒序+选最大，第二问正序+选最大。  
- **技巧3：边界处理**：独立节点（入度0）直接分配名次，避免遗漏。  

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合优质题解，采用稳定拓扑排序框架，避免递归深度风险。  
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  using namespace std;
  const int N = 2e5 + 10;

  int main() {
      int n, a[N], deg[N] = {0};
      vector<int> children[N];
      cin >> n;
      for (int i = 1; i <= n; i++) {
          cin >> a[i];
          if (a[i]) {
              children[a[i]].push_back(i); // 建图: a[i] -> i
              deg[i]++; // i的入度+1
          }
      }

      // 第一问: 倒序拓扑排序
      priority_queue<int> q1;
      vector<int> ans1(n + 1);
      for (int i = 1; i <= n; i++) 
          if (deg[i] == 0) q1.push(i); 
      int cnt = n;
      while (!q1.empty()) {
          int u = q1.top(); q1.pop();
          ans1[u] = cnt--; // 分配当前最大名次
          for (int v : children[u]) 
              if (--deg[v] == 0) q1.push(v);
      }

      // 第二问: 正序拓扑排序
      priority_queue<int> q2;
      for (int i = 1; i <= n; i++) {
          deg[i] = (a[i] != 0); // 重置入度
          if (deg[i] == 0) q2.push(i);
      }
      cnt = 1;
      vector<int> ans2(n + 1);
      while (!q2.empty()) {
          int u = q2.top(); q2.pop();
          ans2[u] = cnt++; // 分配当前最小名次
          for (int v : children[u]) 
              if (--deg[v] == 0) q2.push(v);
      }

      // 输出
      for (int i = 1; i <= n; i++) cout << ans1[i] << " ";
      cout << endl;
      for (int i = 1; i <= n; i++) cout << ans2[i] << " ";
      return 0;
  }
  ```
* **代码解读概要**：  
  > 第一问倒序拓扑排序（名次从n递减），第二问正序（名次从1递增），均用大顶堆选择节点。建图时记录子节点和入度，拓扑排序中动态更新入度。

---

**题解一（hepp）片段赏析**  
* **亮点**：递归计算深度避免显式排序，适合树形约束。  
* **核心代码片段**：
  ```cpp
  int pm(int x) { // 递归计算名次
      if (ans[x] != -1) return cur;
      return ans[x] = pm(a[x]) + 1; // 名次=父节点名次+1
  }
  ```
* **代码解读**：  
  > 递归查询祖先节点名次，当前节点名次=父节点名次+1。全局`cur`记录总人数，确保名次不重复。但深度过大时可能栈溢出。  
* 💡 **学习笔记**：递归法简洁但需注意数据规模限制。

**题解二（Jimmy_Cao）片段赏析**  
* **亮点**：统一拓扑排序框架，两问策略对称。  
* **核心代码片段**：
  ```cpp
  // 第一问倒序
  while (!q1.empty()) {
      int u = q1.top(); q1.pop();
      ans1[u] = cnt--; // 分配大名次
      for (int v : children[u]) 
          if (--deg[v] == 0) q1.push(v);
  }
  ```
* **代码解读**：  
  > 每次选入度为0的最大编号节点，分配当前最大名次（`cnt--`）。删除出边后，子节点入度减1，为0则入队。  
* 💡 **学习笔记**：倒序分配名次是字典序最小的关键。

---

#### 5. 算法可视化：像素动画演示
* **主题**：拓扑排序的像素冒险（FC红白机风格）  
* **核心演示**：  
  - **第一问**：节点从右向左移动入队，名次从大到小显示。选中节点变红，音效"叮"；分配名次时显示数字+胜利音效。  
  - **第二问**：节点从上到下入队，名次从小到大显示。独立节点闪烁提示。  
* **交互设计**：  
  1. **控制面板**：开始/暂停、单步、调速滑块。  
  2. **关键帧**：  
      - **初始化**：节点为彩色方块（编号居中），边为箭头。入度为0的节点绿色高亮。  
      - **选择节点**：红框闪烁选中节点，播放"叮"声。  
      - **更新图**：移除节点（爆炸动画），边消失，子节点入度减1（数字显示）。入度归0的节点变绿。  
      - **结束**：所有节点消失，路径高亮+胜利音效。  
  3. **自动模式**：AI按算法逻辑自动执行，速度可调（类似贪吃蛇AI）。  
  4. **游戏化**：每步得分+10，连续正确选择触发连击特效（像素星星+音效）。  

---

#### 6. 拓展练习与相似问题思考
* **通用思路迁移**：拓扑排序的贪心策略可用于：  
  1. 任务调度（依赖关系）  
  2. 课程安排（先修课约束）  
  3. 依赖解析（如Makefile）  
* **洛谷题目推荐**：  
  1. **P1113**：拓扑排序求最长路径（关键路径）  
     *🗣️ 推荐理由*：巩固拓扑排序框架，学习附加权值处理。  
  2. **P1038**：拓扑排序传播问题（网络广播）  
     *🗣️ 推荐理由*：理解拓扑排序在扩散模型中的应用。  
  3. **P4017**：拓扑排序+DP（食物链计数）  
     *🗣️ 推荐理由*：结合动态规划，拓展拓扑排序的复杂应用。  

---

#### 7. 学习心得与经验分享
> **经验（hepp）**：  
> *"这两个小题的解法不相同！第一问递归计算深度，第二问必须用拓扑排序。"*  
> **点评**：作者强调不同策略的重要性，提醒学习者避免混淆两问的贪心逻辑。实践中应先理清问题目标再设计算法。  

> **经验（Jimmy_Cao）**：  
> *"第一问选最大编号节点分配大名次是关键，容易误用最小堆。"*  
> **点评**：典型调试经验，验证策略时可通过小规模模拟（如n=3）快速定位逻辑错误。  

---  
💪 编程能力的提升在于持续学习与勇于实践，下次挑战再见！

---
处理用时：257.32秒
# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果

# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡

<introduction>
今天我们来一起分析“Mivik 写书”这道C++编程题。这道题看起来是关于字符串的，但核心其实是**组合数学中的容斥原理**——我们需要计算所有可能的字符串中，不同子串的总数，再求期望。本指南会帮你梳理思路，理解容斥的妙用，还会用像素动画直观展示关键步骤！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：容斥原理（结合并查集的约束维护）

🗣️ **初步分析**：
解决这道题的关键是**把“求所有字符串的不同子串总数”转化为“求每个子串在多少个字符串中出现”，再用容斥去掉重复计算**。简单来说，就像你统计“全班同学的玩具总数”——如果直接问每个人有多少玩具，会重复（比如两个人共享一个玩具），所以需要用容斥：先算每个玩具被多少人拥有，再调整重复的情况。

在本题中：
- 我们要枚举**子串的长度**（从1到n），再枚举**子串出现的位置集合**（比如子串长度为2，位置集合{0,1}表示它在字符串的第0位和第1位开始出现）。
- 用**并查集**维护“哪些位置的字符必须相同”（比如子串在位置0和1出现，那么位置0的字符要等于位置1的字符，位置1的字符要等于位置2的字符，所以0、1、2必须相同）。
- 用**容斥符号**（根据位置集合的大小奇偶性）调整贡献：如果集合大小是奇数，加；偶数，减。这样就能避免重复计算同一个子串的多次出现。

**可视化设计思路**：我们会用8位像素风格（像FC游戏）展示子串长度为2、n=3的情况：
- 用不同颜色的像素块代表字符串的位置（比如位置0是红色，位置1是蓝色，位置2是绿色）。
- 当枚举位置集合{0,1}时，像素块会“合并”（比如0和1变成黄色，1和2变成黄色），表示这些位置的字符必须相同。
- 用“叮”的音效表示并查集合并，“咔”的音效表示容斥累加，最后用“胜利音效”展示总贡献的计算结果。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和实践价值出发，筛选了3份优质题解，帮你快速掌握核心逻辑：
</eval_intro>

**题解一：来源（Huasushis，赞11）**
* **点评**：这份题解是“新手友好型”——把容斥的逻辑讲得很透！作者先把问题转化为“计算每个子串的贡献”，再用**枚举位置集合+并查集**的方法处理约束。代码中的`sol`函数枚举子串长度，`for (int i = 1; i < a; ++i)`枚举位置集合，`getfa`函数维护并查集。特别棒的是，作者用`__builtin_parity(i)`判断集合大小的奇偶性，直接决定容斥符号，逻辑简洁。

**题解二：来源（7KByte，赞8）**
* **点评**：这份题解的代码更高效！作者用位运算优化了位置集合的处理（比如`c = (c << 1) | (1 & (i >> j)), c &= o`），减少了循环次数。另外，`mt`数组预处理了低位1的位置，避免重复计算，这是竞赛中常用的优化技巧。代码中的`calc`函数结构清晰，适合模仿。

**题解三：来源（Reunite，赞4）**
* **点评**：这份题解的注释很详细，适合入门！作者用`work`函数处理每个子串长度，`mp`数组记录每个位置被哪些子串覆盖，`Find`函数维护并查集。最后用`calc`函数计算幂和逆元，逻辑完整。特别适合刚开始学容斥的同学参考。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点在于“处理子串的重复出现”和“维护字符的约束”。结合优质题解，我总结了3个关键点：
</difficulty_intro>

1. **关键点1：如何避免重复计算子串？**
    * **分析**：直接枚举所有子串会重复（比如子串“a”在“aa”中出现两次，但只能算一次）。容斥原理帮我们解决这个问题——枚举子串的**出现位置集合**，如果集合大小是奇数（比如出现1次），加贡献；偶数（比如出现2次），减贡献。这样每个不同的子串只会被计算一次。
    * 💡 **学习笔记**：容斥的核心是“用集合的奇偶性调整重复”。

2. **关键点2：如何维护字符的约束？**
    * **分析**：如果子串在位置0和1出现，那么位置0的字符要等于位置1的字符，位置1的字符要等于位置2的字符——这些位置的字符必须相同。并查集（Disjoint Set Union, DSU）是处理“等价关系”的神器：把必须相同的位置合并到一个集合，最后统计集合的数量（即自由选择的字符数）。
    * 💡 **学习笔记**：并查集是处理“相同约束”的首选工具。

3. **关键点3：如何计算自由变量的数目？**
    * **分析**：自由变量数目=**未被子串覆盖的位置数**+**并查集的连通块数**。比如n=3，子串长度2，位置集合{0,1}：未被覆盖的位置是2（1个），连通块是{0,1,2}（1个），所以自由变量数目是2，方案数是m²。
    * 💡 **学习笔记**：自由变量数目决定了方案数（m的自由变量数次方）。

### ✨ 解题技巧总结
- **技巧A：问题转化**：把“求不同子串总数”转化为“求每个子串的贡献”，避免直接枚举。
- **技巧B：位运算优化**：用二进制数表示位置集合，用`__builtin_parity`判断奇偶性，减少计算量。
- **技巧C：并查集维护约束**：合并必须相同的位置，统计连通块数，快速计算自由变量数目。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**——综合了优质题解的思路，逻辑清晰，适合入门：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自Huasushis的题解，调整了变量名使其更易懂，保留了核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int MOD = 1e9 + 7;

    int n;
    ll m, ans;
    int fa[25]; // 并查集数组，最多20个位置（n≤20）

    // 快速幂：计算x^y mod MOD
    ll qpow(ll x, ll y) {
        ll res = 1;
        while (y) {
            if (y & 1) res = res * x % MOD;
            x = x * x % MOD;
            y >>= 1;
        }
        return res;
    }

    // 并查集找根
    int getfa(int x) {
        return x == fa[x] ? x : fa[x] = getfa(fa[x]);
    }

    // 处理子串长度为x的情况
    void solve(int x) {
        int total_pos = n - x + 1; // 子串可能的位置数（比如x=2，n=3，有2个位置：0和1）
        int mask = (1 << x) - 1;   // 用于截取最近x位的掩码（比如x=2，mask=0b11）
        for (int s = 1; s < (1 << total_pos); ++s) { // 枚举所有非空位置集合s
            // 初始化并查集：每个位置独立
            for (int j = 0; j < x; ++j) fa[j] = j;
            int c = 0; // 记录最近x位的覆盖情况
            int free = 0; // 未被覆盖的位置数
            for (int j = 0; j < n; ++j) { // 遍历字符串的每个位置j
                // 更新c：左移一位，加入当前位置是否被覆盖（s的第j位）
                c = (c << 1) | ((s >> j) & 1);
                c &= mask; // 只保留最近x位
                if (c == 0) { // 该位置未被任何子串覆盖
                    free++;
                } else {
                    // 合并c中所有置1的位对应的位置
                    int lowest = c & -c; // 取最低位的1
                    int root = getfa(__builtin_ctz(lowest)); // 最低位对应的根
                    int t = c - lowest; // 剩下的位
                    while (t) {
                        int bit = t & -t;
                        int pos = __builtin_ctz(bit);
                        fa[getfa(pos)] = root; // 合并到root
                        t -= bit;
                    }
                }
            }
            // 统计并查集的连通块数（即子串内部的自由变量数）
            for (int j = 0; j < x; ++j) {
                if (fa[j] == j) free++;
            }
            // 容斥符号：集合大小的奇偶性（__builtin_parity(s)返回1表示奇数）
            ll contrib = qpow(m, free);
            if (__builtin_parity(s)) {
                ans = (ans + contrib) % MOD;
            } else {
                ans = (ans - contrib + MOD) % MOD;
            }
        }
    }

    int main() {
        cin >> n >> m;
        for (int x = 1; x <= n; ++x) { // 枚举所有可能的子串长度x
            solve(x);
        }
        // 计算期望：总数除以m^n（即乘以m^n的逆元）
        ll inv_total = qpow(qpow(m, n), MOD - 2);
        cout << ans * inv_total % MOD << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  1. `qpow`：快速幂计算幂和逆元（模运算中除法要转化为乘以逆元）。
  2. `getfa`：并查集的路径压缩找根函数。
  3. `solve`：处理子串长度为x的情况——枚举位置集合s，用并查集维护约束，计算自由变量数目，容斥累加贡献。
  4. `main`：枚举所有子串长度，调用`solve`，最后计算期望。

---

<code_intro_selected>
接下来看**优质题解的核心片段**，学习它们的亮点：
</code_intro_selected>

**题解一（Huasushis）：并查集合并的技巧**
* **亮点**：用`c = (c << 1) | ((s >> j) & 1)`和`mask`快速更新覆盖情况，避免重复计算。
* **核心代码片段**：
    ```cpp
    c = (c << 1) | ((s >> j) & 1);
    c &= mask;
    if (c == 0) free++;
    else {
        int lowest = c & -c;
        int root = getfa(__builtin_ctz(lowest));
        int t = c - lowest;
        while (t) {
            int bit = t & -t;
            fa[getfa(__builtin_ctz(bit))] = root;
            t -= bit;
        }
    }
    ```
* **代码解读**：
  - `c`记录最近x位的覆盖情况（比如x=2，j=0时c=0b1表示位置0被覆盖，j=1时c=0b11表示位置0和1被覆盖）。
  - `lowest`取c的最低位1，找到对应的根`root`，然后合并c中所有其他置1的位到`root`——这一步把必须相同的位置合并到一个集合。
* 💡 **学习笔记**：用位运算快速处理覆盖情况，是竞赛中的常用技巧！

**题解二（7KByte）：预处理低位1的位置**
* **亮点**：用`mt`数组预处理`1<<i`对应的位置i，避免重复计算`__builtin_ctz`。
* **核心代码片段**：
    ```cpp
    rep(i, 0, n) mt[1 << i] = i; // 预处理：mt[2^i] = i
    // 在calc函数中：
    int p = get(mt[c & -c]); // 直接从mt中取低位1的位置
    ```
* **代码解读**：
  - `__builtin_ctz`是求二进制中最低位1的位置，但频繁调用会有开销。预处理`mt`数组后，直接查表就能得到位置，提升效率。
* 💡 **学习笔记**：预处理能减少重复计算，提升代码效率！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地理解“容斥+并查集”的过程，我设计了一个**8位像素风格的动画**——像玩FC游戏一样看算法运行！
</visualization_intro>

### **动画演示主题**：像素小画家的“字符约束游戏”
- **风格**：FC红白机风格（16色调色板，像素块大小8x8）。
- **场景**：屏幕左侧是3个像素块（代表n=3的字符串位置0、1、2），右侧是控制面板（开始/暂停、单步、重置按钮，速度滑块）。
- **背景音乐**：8位风格的轻快BGM（循环播放）。

### **动画帧步骤与交互关键点**
1. **初始化**：
   - 位置0（红）、1（蓝）、2（绿）的像素块排列在左侧。
   - 控制面板显示“子串长度：2”，“位置集合：0b11”（即s=3，对应位置0和1）。
2. **并查集合并**：
   - 当处理位置0时，c=0b1（位置0被覆盖），像素块0变成黄色（表示被选中），播放“叮”的音效。
   - 处理位置1时，c=0b11（位置0和1被覆盖），像素块1变成黄色，合并0和1到同一个集合（播放“叮”音效）。
   - 处理位置2时，c=0b10（位置1被覆盖），像素块2变成黄色，合并1和2到同一个集合（播放“叮”音效）。
3. **自由变量计算**：
   - 未被覆盖的位置数：0（所有位置都被覆盖）。
   - 连通块数：1（0、1、2合并成一个集合）。
   - 自由变量数目：1，方案数是m¹。
4. **容斥累加**：
   - 位置集合大小是2（偶数），所以贡献是“-m¹”。屏幕右侧显示“当前贡献：-m”，播放“咔”的音效。
5. **结束**：
   - 所有步骤完成，播放“胜利音效”，屏幕显示“总贡献：... ”。

### **交互设计**
- **单步执行**：点击“单步”按钮，动画走一步（比如合并一个位置）。
- **自动播放**：拖动速度滑块调整播放速度（慢→快）。
- **重置**：点击“重置”按钮，回到初始状态，重新演示。

<visualization_conclusion>
通过这个动画，你能清楚看到**并查集如何合并位置**、**自由变量如何计算**、**容斥符号如何调整**——就像玩游戏一样，把抽象的算法变成了看得见的过程！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
容斥原理是组合数学中的“瑞士军刀”，能解决很多“去重”问题。掌握本题的思路后，你可以尝试以下练习：
</similar_problems_intro>

### **通用思路迁移**
- **场景1**：统计所有长度为n的字符串中，包含至少k个不同子串的数目。
- **场景2**：计算数组中所有子数组的不同元素数目的总和（类似本题，但对象是数组）。
- **场景3**：统计所有二叉树中，包含特定结构的子树的数目（用容斥去掉重复）。

### **洛谷练习推荐**
1. **洛谷 P1316** - Mivik 写书（原题）
   - 🗣️ **推荐理由**：巩固容斥+并查集的核心思路，直接应用本题的代码。
2. **洛谷 P2150** - [NOI2015] 寿司晚宴
   - 🗣️ **推荐理由**：容斥原理的经典应用，需要处理两个集合的交集。
3. **洛谷 P3901** - 数列找不同
   - 🗣️ **推荐理由**：用容斥处理子数组的不同元素数目，类似本题的“去重”思路。
4. **洛谷 P4316** - 绿豆蛙的归宿
   - 🗣️ **推荐理由**：容斥结合动态规划，提升综合应用能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的作者心得很有价值，我摘录了两条：
</insights_intro>

> **参考经验（来自Huasushis）**：“一个一个枚举子串是不可能的，我们发现，有一些子串性质是一样的。”
>
> **点评**：这是解决组合问题的关键——**找共性，批量处理**。比如本题中，所有“出现位置集合为s、长度为x”的子串，它们的约束是一样的，所以可以用容斥批量计算贡献，避免枚举每个子串。

> **参考经验（来自7KByte）**：“用位运算优化位置集合的处理，能减少循环次数。”
>
> **点评**：位运算在竞赛中非常重要，比如`c = (c << 1) | ((s >> j) & 1)`快速更新覆盖情况，`__builtin_parity`判断奇偶性，这些技巧能让代码更高效。


<conclusion>
本次关于“Mivik 写书”的分析就到这里。这道题的核心是**容斥原理+并查集**，关键是把“求不同子串总数”转化为“求每个子串的贡献”。记住：组合问题的难点在于“去重”，容斥是解决这个问题的有力工具！

编程能力的提升在于**多思考、多实践**——试着把今天学的容斥思路用到其他问题上，你会发现很多问题都能迎刃而解！💪
</conclusion>

---
处理用时：139.22秒
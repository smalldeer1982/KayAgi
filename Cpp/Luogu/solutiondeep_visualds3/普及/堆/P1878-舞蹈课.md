# 题目信息

# 舞蹈课

## 题目描述

有 $n$ 个人参加一个舞蹈课。每个人的舞蹈技术由整数来决定。在舞蹈课的开始，他们从左到右站成一排。当这一排中至少有一对相邻的异性时，舞蹈技术相差最小的那一对会出列并开始跳舞。如果不止一对，那么最左边的那一对出列。一对异性出列之后，队伍中的空白按原顺序补上（即：若队伍为 `ABCD`，那么 `BC` 出列之后队伍变为 `AD`）。舞蹈技术相差最小即是 $a_i$ 的绝对值最小。

任务是模拟以上过程，确定跳舞的配对及顺序。


## 说明/提示

对于 $50\%$ 的数据，$1\leq n\leq 200$。

对于 $100\%$ 的数据，$1\leq n\leq 2\times 10^5$，$1\le a_i\le 10^7$。

## 样例 #1

### 输入

```
4

BGBG

4 2 4 3

```

### 输出

```
2

3 4

1 2

```

# AI分析结果



---
# 💡 Kay的C++算法解析：舞蹈课 深入学习指南 💡

<introduction>
今天我们来一起分析“舞蹈课”这道C++编程题。这道题需要模拟舞蹈课中相邻异性出列跳舞的过程，核心在于高效维护和更新可能的配对。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`优先队列（堆）与链表结合的模拟`  

🗣️ **初步分析**：  
解决“舞蹈课”的关键在于高效找到当前所有相邻异性中技术差最小的配对，并在其出列后快速更新队伍结构。这里我们需要两种核心工具：  
- **优先队列（小根堆）**：像一个“智能筛选器”，自动帮我们维护当前所有可能的配对，每次取出技术差最小的（若差值相同则取最左边的）。  
- **双向链表**：像“灵活的链条”，维护每个舞者的前后邻居，当一对舞者出列后，能快速调整前后舞者的连接关系，生成新的相邻配对。  

**题解思路对比**：所有优质题解均采用“优先队列+双向链表”的组合。差异主要在于链表的实现方式（如用数组模拟或结构体存储）和优先队列的排序逻辑（部分题解直接使用STL优先队列，部分自定义结构体排序）。核心难点是处理“无效配对”（即已出列的舞者再次被选中）和“新配对生成”（出列后前后舞者连接形成的新配对）。  

**可视化设计**：我们将用8位像素风格模拟舞蹈队列，每个舞者是一个彩色像素块（男B为蓝色，女G为粉色）。优先队列用“魔法口袋”表示，每次从口袋中“弹出”最小差值的配对（伴随“叮”的音效）。链表关系用像素线连接相邻舞者，当配对出列时，连接断开并重新连接前后舞者（像素线动态调整），新生成的配对会被“魔法口袋”自动收集（伴随“咻”的入队音效）。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下3道题解因逻辑简洁、实现高效且易于学习，被选为优质题解（评分≥4星）：
</eval_intro>

**题解一：作者NIMNIM**  
* **点评**：此题解思路清晰，详细解释了优先队列和链表的配合使用。代码中通过`L[]`和`R[]`数组模拟双向链表，用`danced[]`标记已出列的舞者，避免重复处理无效配对。特别亮点是在更新链表后，仅当新生成的相邻舞者为异性时才入队，减少了无效操作。代码结构工整，变量名（如`L`表示左邻居，`R`表示右邻居）含义明确，适合新手学习。

**题解二：作者汪鸣谦**  
* **点评**：此题解代码简洁高效，直接使用STL优先队列存储配对信息（包含差值、左右位置），并通过`f[]`和`g[]`数组维护双向链表。在处理出列后的链表更新时，用`f[g[x]] = f[y]; g[f[y]] = g[x];`两行代码完成断链重连，逻辑非常巧妙。代码中对边界条件（如首尾舞者）的处理严谨，实践价值高。

**题解三：作者ListenSnow**  
* **点评**：此题解注释详细，逻辑透明。通过`pre[]`和`nex[]`数组维护双向链表，用`st[]`数组标记已出列的舞者。优先队列的排序逻辑（差值小优先，差值相同则左端点小优先）完全符合题意，且代码中对新配对的生成条件（`sex[pre[now.l]]^sex[nex[now.r]]==1`）判断准确。适合作为理解核心逻辑的入门参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下3个核心难点，结合优质题解的共性，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何避免处理“无效配对”？**  
    * **分析**：当一对舞者出列后，他们的左右邻居可能被其他配对引用（例如，优先队列中可能仍存着这对舞者的旧信息）。优质题解通过**标记数组**（如`danced[]`、`st[]`）记录已出列的舞者，每次取出优先队列顶部的配对时，先检查左右舞者是否已标记，若已标记则跳过。  
    * 💡 **学习笔记**：标记数组是处理“无效状态”的常用工具，能有效过滤过时的队列元素。

2.  **关键点2：如何高效维护“链表连接”？**  
    * **分析**：当一对舞者出列后，需要将他们的左邻居和右邻居连接起来。双向链表通过`pre[i]`（左邻居）和`nex[i]`（右邻居）数组实现，更新时只需修改左邻居的右指针（`nex[pre[x]] = nex[y]`）和右邻居的左指针（`pre[nex[y]] = pre[x]`）。此操作时间复杂度为O(1)，非常高效。  
    * 💡 **学习笔记**：双向链表是处理“动态连接”问题的利器，能在O(1)时间内完成插入、删除和连接操作。

3.  **关键点3：如何生成“新配对”并正确入队？**  
    * **分析**：出列后，左邻居（`pre[x]`）和右邻居（`nex[y]`）可能形成新的相邻配对。需要检查这对新邻居是否为异性（通过`sex`数组判断），若是则计算技术差并加入优先队列。此步骤确保优先队列始终维护当前所有有效配对。  
    * 💡 **学习笔记**：新配对的生成需同时满足“未出列”和“异性”两个条件，缺一不可。

### ✨ 解题技巧总结
- **优先队列排序逻辑**：优先按技术差从小到大排序，差值相同时按左端点从小到大排序（保证“最左边”的优先）。  
- **链表初始化**：初始时，每个舞者的左邻居为`i-1`，右邻居为`i+1`（首尾舞者的邻居设为边界值，如0或n+1）。  
- **边界处理**：在更新链表和生成新配对时，需检查左右邻居是否越界（如`pre[x] >=1`且`nex[y] <=n`），避免数组越界错误。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
通过综合优质题解的思路，我们提炼出一个通用的核心实现，兼顾清晰性和效率。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了NIMNIM和ListenSnow的题解思路，使用双向链表和优先队列，标记数组处理无效配对，适合作为标准实现参考。  
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <queue>
    using namespace std;

    const int N = 2e5 + 10;
    int n, a[N], pre[N], nex[N], ans[N][2], cnt;
    bool st[N], sex[N]; // sex[i]=0表示B，1表示G

    struct Node {
        int l, r, dis;
        bool operator<(const Node& t) const {
            if (dis != t.dis) return dis > t.dis; // 差值小的优先
            return l > t.l; // 差值相同时左端点小的优先
        }
    };

    priority_queue<Node> q;

    int main() {
        scanf("%d", &n);
        char s[N];
        scanf("%s", s + 1);
        for (int i = 1; i <= n; ++i) {
            sex[i] = (s[i] == 'G'); // 转换为布尔值
            pre[i] = i - 1; // 初始左邻居
            nex[i] = i + 1; // 初始右邻居
        }
        for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);

        // 初始化优先队列：所有相邻异性配对入队
        for (int i = 1; i < n; ++i) {
            if (sex[i] != sex[i + 1]) {
                q.push({i, i + 1, abs(a[i] - a[i + 1])});
            }
        }

        while (!q.empty()) {
            Node now = q.top();
            q.pop();
            int l = now.l, r = now.r;
            if (st[l] || st[r]) continue; // 跳过已出列的配对

            // 记录答案
            ans[++cnt][0] = l;
            ans[cnt][1] = r;
            st[l] = st[r] = true;

            // 更新链表：连接左邻居的左和右邻居的右
            int left = pre[l], right = nex[r];
            if (left >= 1) nex[left] = right;
            if (right <= n) pre[right] = left;

            // 生成新配对（若左右邻居存在且为异性）
            if (left >= 1 && right <= n && sex[left] != sex[right]) {
                q.push({left, right, abs(a[left] - a[right])});
            }
        }

        printf("%d\n", cnt);
        for (int i = 1; i <= cnt; ++i) {
            printf("%d %d\n", ans[i][0], ans[i][1]);
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取输入并初始化双向链表（`pre`和`nex`数组），然后将所有初始相邻异性配对加入优先队列。循环处理优先队列中的配对，跳过已出列的无效配对，记录有效配对的出列顺序，并更新链表生成新配对。最后输出结果。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其亮点：
</code_intro_selected>

**题解一：作者NIMNIM**  
* **亮点**：通过`danced[]`数组标记已出列的舞者，链表更新逻辑清晰。  
* **核心代码片段**：
    ```cpp
    if (danced[x.l] || danced[x.r]) continue;
    danced[x.l] = true;
    danced[x.r] = true;
    // 更新链表
    int q = p[x.l].prev;
    int b = p[x.r].next;
    p[q].next = b;
    p[b].prev = q;
    // 生成新配对
    if (p[q].b_g != p[b].b_g) {
        h.push({q, b, abs(p[q].val - p[b].val)});
    }
    ```
* **代码解读**：  
  这段代码首先检查配对是否有效（未被标记），若有效则标记为已出列。然后通过`prev`和`next`数组更新链表，将左邻居的`next`指向右邻居的`next`，右邻居的`prev`指向左邻居的`prev`。最后检查新生成的左右邻居是否为异性，若是则入队。  
* 💡 **学习笔记**：标记数组和链表更新是处理动态配对的关键步骤，需严格按顺序执行。

**题解二：作者汪鸣谦**  
* **亮点**：用`f[]`和`g[]`数组简化链表操作，代码简洁。  
* **核心代码片段**：
    ```cpp
    f[g[x]] = f[y];
    g[f[y]] = g[x];
    if (is[g[x]] == 0 && is[f[y]] == 0) {
        if ((s[g[x] - 1] + s[f[y] - 1]) == ('G' + 'B')) {
            q.push({abs(a[g[x]] - a[f[y]]), g[x], f[y]});
        }
    }
    ```
* **代码解读**：  
  `f[g[x]] = f[y]`表示左邻居的右指针指向右邻居的右指针，`g[f[y]] = g[x]`表示右邻居的左指针指向左邻居的左指针。这两行代码高效完成了链表的断链重连。随后检查新邻居是否未出列且为异性，若是则入队。  
* 💡 **学习笔记**：双向链表的指针更新可通过两行代码完成，需注意指针的指向顺序。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了更直观地理解“优先队列+链表”的工作过程，我们设计了一个8位像素风格的动画演示，让你“看”到配对的生成、出列和链表的动态变化！
\</visualization_intro\>

  * **动画演示主题**：`像素舞蹈厅——寻找最佳舞伴`  
  * **核心演示内容**：模拟舞者队列、优先队列（魔法口袋）的工作流程，展示配对的出列、链表的更新和新配对的生成。  

  * **设计思路简述**：  
    采用FC红白机风格的像素画面，舞者用彩色方块表示（蓝色B，粉色G），相邻舞者用黄色像素线连接。优先队列用“魔法口袋”显示，每次取出最小差值的配对（伴随“叮”声）。出列的舞者变为灰色并消失，链表线动态调整连接前后舞者（绿色线表示新连接），新生成的配对自动飞入魔法口袋（伴随“咻”声）。  

  * **动画帧步骤与交互关键点**：  

    1.  **初始化场景**（8位像素风）：  
        - 屏幕下方显示舞者队列，每个舞者是16x16的像素块（B蓝色，G粉色），相邻舞者用黄色线连接。  
        - 屏幕上方显示“魔法口袋”（一个像素宝箱），初始时为空。  
        - 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块（1-5倍速）。  

    2.  **初始配对入队**：  
        - 遍历初始队列，所有相邻异性配对（黄线连接的B和G）自动飞入魔法口袋，伴随“咻”的入队音效。每个配对在口袋中显示为“(l, r, dis)”的像素文字。  

    3.  **配对出列**（单步/自动播放）：  
        - 点击“开始”后，魔法口袋弹出顶部配对（最小dis，若相同则最左），配对的两个舞者闪烁（红色边框），伴随“叮”声。  
        - 检查舞者是否已出列（灰色表示已出列），若无效则跳过（配对消失，无音效）；若有效则标记为灰色，从队列中消失。  

    4.  **链表更新**：  
        - 出列的舞者消失后，前后舞者的连接黄线断开，新的连接黄线生成（绿色闪烁1秒），表示链表更新完成。例如，原队列A-B-C-D中B-C出列，A和D用绿线连接。  

    5.  **新配对生成**：  
        - 若新连接的舞者为异性（B和G），则生成新配对，自动飞入魔法口袋（伴随“咻”声），口袋中显示新配对的dis和位置。  

    6.  **结束状态**：  
        - 当魔法口袋为空时，播放“胜利”音效（上扬音），屏幕显示“已找到所有配对！”。  

  * **旁白提示**（像素气泡文字）：  
    - “看！魔法口袋弹出了当前最小差值的配对~”  
    - “这两个舞者已出列，队伍重新连接啦！”  
    - “新的相邻舞者是异性，他们的配对被加入口袋咯~”  

\<visualization_conclusion\>
通过这样的动画，我们能直观看到优先队列如何筛选配对，链表如何动态调整，以及新配对的生成过程。这种“可视化学习”能帮我们更快掌握算法核心！
\</visualization_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
“优先队列+链表”的组合在处理动态排序、动态连接问题中非常实用，以下是相关拓展练习：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：  
    该算法适用于需要**动态维护最小值/最大值**且**频繁修改数据连接关系**的场景，例如：  
    - 合并果子（每次选最小的两堆合并，用堆维护最小值）；  
    - 任务调度（用堆维护任务优先级，链表维护任务依赖关系）；  
    - 交通灯调度（用堆维护下一个变灯时间，链表维护相邻路口的连接）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1090** - `合并果子`  
        * 🗣️ **推荐理由**：经典堆应用，练习用小根堆维护最小值，与本题的“动态选最小”思路一致。  
    2.  **洛谷 P1803** - `线段覆盖`  
        * 🗣️ **推荐理由**：用堆维护结束时间，结合贪心算法，练习堆在区间调度中的应用。  
    3.  **洛谷 P3378** - `堆模板`  
        * 🗣️ **推荐理由**：纯堆操作练习，巩固堆的插入、删除、取顶等基本操作。  

---

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解作者分享了调试经验，这些经验对我们很有参考价值：
\</insights_intro\>

> **参考经验 (来自作者汪鸣谦)**：“一定要先出队（用t记录队首信息后立刻POP），否则会WA（因为新的数可能入队，队首会变）。”  
> **点评**：优先队列的`pop()`操作必须在处理完当前队首后立即执行，否则新入队的元素可能改变队首，导致重复处理或漏处理。这提醒我们在使用优先队列时，要严格遵循“取顶-处理-弹出”的顺序，避免逻辑错误。

---

\<conclusion\>
本次关于“舞蹈课”的C++解题分析就到这里。通过理解优先队列和链表的配合使用，掌握动态配对的维护方法，相信你已经能独立解决这类问题。记住，多动手写代码、调试，是提升编程能力的关键！下次我们再一起探索新的编程挑战！💪
\</conclusion\>

---
处理用时：175.46秒
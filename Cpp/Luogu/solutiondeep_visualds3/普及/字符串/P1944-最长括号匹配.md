# 题目信息

# 最长括号匹配

## 题目描述

对一个由(,),[,]括号组成的字符串，求出其中最长的括号匹配子串。具体来说，满足如下条件的字符串成为括号匹配的字符串：

  1.(),[]是括号匹配的字符串。

2.若A是括号匹配的串，则(A),[A]是括号匹配的字符串。

3.若A,B是括号匹配的字符串，则AB也是括号匹配的字符串。

例如：(),[],([]),()()都是括号匹配的字符串，而][,[(])则不是。

字符串A的子串是指由A中连续若干个字符组成的字符串。

例如，A,B,C,ABC,CAB,ABCABCd都是ABCABC的子串。空串是任何字符串的子串。


## 说明/提示

【数据范围】

对20%的数据，字符串长度<=100.

对50%的数据，字符串长度<=10000.

对100%的数据，字符串长度<=1000000.


## 样例 #1

### 输入

```
([(][()]]()
```

### 输出

```
[()]
```

## 样例 #2

### 输入

```
())[]```

### 输出

```
()```

# AI分析结果



---
# 💡 Kay的C++算法解析：最长括号匹配 深入学习指南 💡

<introduction>
今天我们来一起分析“最长括号匹配”这道C++编程题。这道题需要我们找到由`()[]`组成的字符串中最长的合法匹配子串，对算法效率和逻辑严谨性要求较高。本指南将帮助大家梳理核心思路，掌握动态规划（DP）和栈模拟两种主流解法，并通过像素动画直观理解算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划(DP)与栈/模拟应用

🗣️ **初步分析**：
解决“最长括号匹配”的关键在于高效判断括号的匹配关系并找到最长连续子串。题目要求处理最长1e6长度的字符串，因此必须用O(n)时间复杂度的算法。题解中主要有两种思路：

- **动态规划(DP)**：通过定义`dp[i]`表示以第i个字符结尾的最长合法匹配长度，利用状态转移方程递推计算。例如，若当前字符是右括号，且能与前面对应的左括号匹配，则`dp[i]`由前一个状态扩展而来。
- **栈模拟**：用栈记录未匹配的左括号及其位置，遇到右括号时弹出栈顶匹配的左括号，标记匹配位置，最后找最长连续标记区间。

**核心难点**：如何高效判断当前右括号对应的左括号位置，并处理嵌套/连续匹配的情况（如`(())[]`中的嵌套和连续匹配）。DP解法的关键是状态定义的合理性，栈解法的关键是匹配位置的标记与最长区间的统计。

**可视化设计思路**：采用8位像素风格，用不同颜色的方块表示括号（如红色`(`、蓝色`[`），栈用垂直堆叠的像素槽展示。DP解法中，用动态扩展的绿色条表示`dp[i]`的长度；栈解法中，匹配时弹出栈顶并高亮对应位置，最后用连续绿色块表示最长匹配区间。关键步骤（如匹配成功、状态转移）伴随“叮”的像素音效，完成最长匹配时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性和实践价值，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：OItby的动态规划解法（来源：作者博客）**
* **点评**：此题解思路清晰，状态定义简洁（`f[i]`表示以第i个字符结尾的最长匹配长度），状态转移方程推导严谨。代码规范（变量名`f[i]`、`Ans`含义明确），时间复杂度O(n)，完全适配1e6数据规模。亮点在于巧妙利用`f[i-1]`定位前一个匹配位置，处理嵌套和连续匹配（如`f[i] = f[i-1]+2+f[i-f[i-1]-2]`），是DP解法的典型代表。

**题解二：Nepenthe的栈模拟解法**
* **点评**：此解法用栈记录未匹配的左括号及其位置，遇到右括号时弹出栈顶匹配的左括号，并标记这两个位置为已匹配（`vis`数组）。最后遍历`vis`数组找最长连续1区间，思路直接且高效。代码简洁（仅需一个栈和标记数组），时间复杂度O(n)，适合快速实现。亮点在于将抽象的匹配关系转化为直观的位置标记，降低了理解难度。

**题解三：Seanq的DP解法（来源：标准题解）**
* **点评**：此题解与OItby思路一致，但代码更简洁（省略冗余头文件，直接处理边界）。状态转移方程与OItby完全一致，通过`f[i-1-f[i-1]]`定位匹配的左括号，确保了正确性。代码可读性高，适合作为DP解法的模板参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何高效处理括号的嵌套与连续匹配。结合优质题解，我们提炼以下关键点：
</difficulty_intro>

1.  **关键点1：如何定义动态规划的状态？**
    * **分析**：DP解法中，`dp[i]`需表示“以第i个字符结尾的最长合法匹配长度”。这样定义的好处是，当遇到右括号时，可通过前一个状态`dp[i-1]`快速定位可能匹配的左括号位置（即`i-1-dp[i-1]`），从而判断是否形成新的匹配。
    * 💡 **学习笔记**：状态定义需直接关联问题目标（最长匹配长度），并便于利用子问题的解（即前一个状态）。

2.  **关键点2：如何处理嵌套与连续匹配？**
    * **分析**：嵌套匹配（如`(())`）需要将内部匹配的长度累加到当前状态（`dp[i] = dp[i-1]+2`），而连续匹配（如`()[]`）需要将前一段匹配的长度（`dp[i-f[i-1]-2]`）也累加进来。栈解法中，匹配时标记两个位置为1，连续的1区间即表示连续匹配。
    * 💡 **学习笔记**：嵌套匹配通过“内部匹配长度+2”处理，连续匹配通过“前一段匹配长度累加”处理。

3.  **关键点3：如何高效标记匹配位置（栈解法）？**
    * **分析**：栈中存储未匹配的左括号及其位置，遇到右括号时弹出栈顶，标记这两个位置为已匹配（`vis`数组）。最后遍历`vis`数组，统计最长连续1的区间，即为最长匹配子串。
    * 💡 **学习笔记**：栈是处理括号匹配的“天然工具”，通过位置标记将匹配关系转化为数组的连续区间问题，简化了统计过程。

### ✨ 解题技巧总结
- **状态转移的“回退”思维**：DP中，通过前一个状态的值（如`dp[i-1]`）回退到可能的左括号位置，快速判断是否匹配。
- **标记数组的妙用**：栈解法中，用`vis`数组记录匹配位置，将复杂的匹配统计转化为简单的最长连续1区间问题。
- **边界条件处理**：注意字符串下标从0或1开始的差异，避免越界（如`i-f[i-1]-1`需≥0）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合DP和栈两种主流解法，提供两个通用核心实现参考。
</code_intro_overall>

### **本题通用核心C++实现参考（DP解法）**
* **说明**：此代码综合OItby和Seanq的DP思路，逻辑清晰，适用于1e6数据规模。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    using namespace std;

    const int MAXN = 1e6 + 5;
    char s[MAXN];
    int dp[MAXN]; // dp[i]表示以i结尾的最长合法匹配长度
    int max_len, end_pos; // 最长长度及结束位置

    int main() {
        scanf("%s", s + 1); // 下标从1开始
        int len = strlen(s + 1);
        for (int i = 2; i <= len; ++i) { // 单个字符无法匹配，从2开始
            if (s[i] == '(' || s[i] == '[') continue;
            // 计算匹配的左括号位置
            int left_pos = i - 1 - dp[i - 1];
            if (left_pos < 1) continue; // 越界，无法匹配
            if ((s[i] == ')' && s[left_pos] == '(') || (s[i] == ']' && s[left_pos] == '[')) {
                dp[i] = dp[i - 1] + 2;
                if (left_pos > 1) dp[i] += dp[left_pos - 1]; // 累加前一段匹配长度
                if (dp[i] > max_len) {
                    max_len = dp[i];
                    end_pos = i;
                }
            }
        }
        // 输出最长子串
        for (int i = end_pos - max_len + 1; i <= end_pos; ++i) {
            printf("%c", s[i]);
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取字符串（下标从1开始），初始化`dp`数组。遍历每个字符，若为右括号则计算可能匹配的左括号位置（`left_pos`），若匹配则更新`dp[i]`（包含嵌套和连续匹配的长度）。最后根据`max_len`和`end_pos`输出最长子串。

---

<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一（OItby的DP解法）**
* **亮点**：状态转移方程简洁，处理嵌套和连续匹配的逻辑清晰。
* **核心代码片段**：
    ```cpp
    if((s[i]==')'&&s[i-f[i-1]-1]=='(')||(s[i]==']'&&s[i-f[i-1]-1]=='[')) {
        f[i]=f[i-1]+2+f[i-f[i-1]-2];
        if(f[i]>Ans) Ans=f[i],id=i;
    }
    ```
* **代码解读**：  
  `i-f[i-1]-1`是前一个匹配的左括号位置（`f[i-1]`是前一个状态的匹配长度）。若当前右括号与该位置的左括号匹配，则`f[i]`为前一个匹配长度+2（当前匹配的一对），再加上左括号前一段的匹配长度（`f[i-f[i-1]-2]`）。例如，对于`(()())`，当`i=6`（最后一个`)`），`f[5]=2`（对应中间的`()`），`i-f[5]-1=3`（第三个`(`），匹配后`f[6]=2+2+f[1]`（`f[1]=0`），最终`f[6]=4`。
* 💡 **学习笔记**：状态转移的关键是“回退”到前一个匹配的左括号位置，并累加可能的连续匹配长度。

**题解二（Nepenthe的栈解法）**
* **亮点**：用栈和标记数组将匹配问题转化为最长连续区间问题，思路巧妙。
* **核心代码片段**：
    ```cpp
    for(int i=0;i<la;++i) 
        if((sta[top][0]=='['&&a[i]==']')||(sta[top][0]=='('&&a[i]==')')) 
            vis[sta[top--][1]]=vis[i]=1;
        else 
            sta[++top][0]=a[i],sta[top][1]=i;
    ```
* **代码解读**：  
  栈`sta`存储未匹配的左括号及其位置。遇到右括号时，若与栈顶左括号匹配，则弹出栈顶，并标记这两个位置为已匹配（`vis`数组置1）。例如，输入`([)]`，栈先压入`(`（位置0）、`[`（位置1），遇到`)`（位置2）时不匹配，压入；遇到`]`（位置3）时与栈顶的`[`（位置1）匹配，标记位置1和3为1。最后`vis`数组为`[0,1,0,1]`，最长连续1区间长度为1（但实际无合法匹配，说明需处理连续标记）。
* 💡 **学习笔记**：栈是处理括号匹配的“天然容器”，标记数组将抽象匹配转化为直观的区间统计问题。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解DP和栈两种算法，我们设计“像素括号大冒险”动画，以8位复古风格演示匹配过程！
</visualization_intro>

  * **动画演示主题**：像素括号大冒险——寻找最长匹配宝藏
  * **核心演示内容**：以栈解法为例，演示括号入栈、匹配弹栈、标记位置，最终找到最长连续标记区间的过程。
  * **设计思路简述**：8位像素风格（红/蓝括号、绿色标记）营造轻松氛围；关键操作（入栈、弹栈）伴随“叮”音效，完成最长匹配时播放胜利音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        屏幕分为三部分：顶部是像素化的字符串（如`([(][()]]()`，每个字符用16x16像素块表示）；中间是栈槽（垂直堆叠的像素框，显示未匹配的左括号）；底部是控制面板（开始/暂停、单步、调速滑块）。8位背景音乐（如《超级玛丽》风格）响起。

    2.  **入栈与弹栈演示**：  
        - 遍历字符串时，当前字符（如位置i）用黄色边框高亮。若为左括号（`(`或`[`），则从屏幕右侧“滑入”栈顶（伴随“唰”音效），栈槽新增一个像素块（红色`(`或蓝色`[`）。  
        - 若为右括号（`)`或`]`），检查栈顶：若匹配（如栈顶是`(`且当前是`)`），栈顶像素块“弹出”（向上消失），当前字符和栈顶位置的像素块变为绿色（标记为已匹配，伴随“叮”音效）；若不匹配，当前字符滑入栈顶。

    3.  **最长区间统计**：  
        遍历完成后，`vis`数组用绿色条覆盖匹配位置。动画自动扫描`vis`数组，用红色箭头标记连续绿色区间，找到最长区间时，该区间像素块闪烁（伴随“胜利”音效），并显示“最长匹配！”文字。

    4.  **交互控制**：  
        支持单步执行（逐字符演示入栈/弹栈）、自动播放（可调节速度）、重置（清空栈和标记）。学习者可暂停观察细节，如嵌套匹配时栈的变化。

  * **旁白提示**：  
    - “看！当前字符是`)`，检查栈顶是否有匹配的`(`...”  
    - “匹配成功！这两个括号被标记为绿色，代表它们是合法匹配的～”  
    - “现在扫描所有标记，最长的连续绿色区间就是答案！”

<visualization_conclusion>
通过这样的动画，我们能直观看到栈如何记录未匹配括号，匹配时如何弹栈标记，最终如何找到最长连续匹配。像素风格和音效让算法学习更有趣！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下拓展练习，巩固括号匹配与动态规划/栈的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的DP状态定义和栈标记方法，可迁移到：  
    - 带权括号匹配（如不同括号有不同分值，求最大得分）；  
    - 多类型括号匹配（如增加`{}`）；  
    - 最短无效括号子串（求需删除的最少括号数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1903 [国家集训队] 数颜色 / 维护队列**  
        * 🗣️ **推荐理由**：考察栈的灵活应用，需处理复杂的匹配与状态维护。
    2.  **洛谷 P1241 括号序列**  
        * 🗣️ **推荐理由**：与本题高度相关，需补全最短括号序列，强化括号匹配逻辑。
    3.  **洛谷 P3275 [SCOI2011] 括号序列**  
        * 🗣️ **推荐理由**：动态规划的进阶应用，涉及不同类型括号的组合计数，适合提升DP思维。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自OItby)**：“最初在处理`i-f[i-1]-1`的越界问题时卡了很久，后来通过打印中间变量发现当`f[i-1]`为0时，`i-f[i-1]-1`可能小于1，导致访问非法内存。添加`left_pos >=1`的判断后解决。”

**点评**：OItby的经验提醒我们，处理数组下标时需特别注意边界条件（如`i-f[i-1]-1`是否≥1）。调试时打印关键变量（如`left_pos`）是定位越界问题的有效方法，这对处理大规模数据时的鲁棒性至关重要。

---

<conclusion>
本次关于“最长括号匹配”的分析就到这里。无论是动态规划的状态转移，还是栈的标记统计，核心都是抓住括号匹配的嵌套与连续特性。通过代码实践和动画演示，相信大家能更深刻地理解算法逻辑。下次我们再一起挑战更难的编程题！💪
</conclusion>

---
处理用时：156.34秒
# 题目信息

# 『MdOI R2』Mayuri

## 题目背景

「万由里……怎么会？为什么你要……」

『我是灵力的结晶体，实施了封印，我当然会消失，不是吗？』

「封印？但是你和我……」

『第一次见面不能封印吗？笨蛋，我可是从大家的灵力里出生的，怎么可能讨厌你？从一出生，我就爱着你。』

「万由里……」

『虽然我竭力不让自己去想，但我一定是很羡慕大家……』

「等一下，万由里，不要消失……」

『但是我还是有一件能向大家炫耀的事，只有我和士道一样……』

「一样？」

『我已经不再是只为了消失而出生的生命。因为我遇见了你……已经足够了。』

「万由里……」

『谢谢你，士道。 』

![](https://cdn.luogu.com.cn/upload/image_hosting/9w6a0deg.png)

## 题目描述

在离开这个世界前，万由里想要寻找属于她的 Lucky Number。

万由里会给出一个数 $a$，以及一个长度为 $b$ 的 01 串 $S$。

简单的说，她的 Lucky Number 是满足以下条件的**正整数** $n$：

 - $n$ 的位数为 $b$ 且不含前导 $0$。

 - 若 $S$ 的第 $i$ 位为 $1$，则 $n$ 的前 $i$ 位组成的数是 $a$ 的倍数，否则 $n$ 的前 $i$ 位组成的数不是 $a$ 的倍数。

对于一个数，前 $i$ 位组成的数是指这个数前 $i$ 个数码依次拼接形成的数。例如 $312311$ 前 $3$ 位组成的数为 $312$，前 $5$ 位组成的数为 $31231$。


现在，请你帮助万由里计算一下，她的 Lucky Number 是多少。

由于满足条件的数可能会有多个，你需要输出**最小**的一个。若不存在，则请输出 `-1`。

## 说明/提示

【帮助与提示】

为方便选手测试代码，本题额外提供一组附加样例供选手使用。

[样例输入](https://www.luogu.com.cn/paste/5gnn8mg0) [样例输出](https://www.luogu.com.cn/paste/sgxjkbjd)

------
【样例解释】

对于样例一，$10$ 是 $2$ 位数，且 $10$ 的前 $1$ 位组成的数 $1$ 不是 $2$ 的倍数，而前 $2$ 位组成的数 $10$ 是 $2$ 的倍数。由于 $10$ 已经是最小的两位数，故不存在比 $10$ 更小的满足条件的数。

对于样例二，我们需要构造一个 $1$ 位数，满足这个 $1$ 位数整除 $10$。显然，这样的数不存在。

---

【数据范围】

**本题采用捆绑测试**


| 子任务编号 | $a \leq$ | $b\le$  | 分值   |
| ---------- | -------- | :------ | ------ |
| Subtask 1  | $10$     | $ 1$    | $20$   |
| Subtask 2  | $10 $    | $2$     | $20$  |
| Subtask 3  | $10 $    | $ 6$    | $20$  |
| Subtask 4  | $ 2$     | $ 18$   | $20$ |
| Subtask 5  | $ 10$    | $ 10^5$ | $20$ |


对于全部数据，保证 $2\le a\le 10$，$1\le b\le 10^5$，$S$ 中只包含 `0` 和 `1`。

## 样例 #1

### 输入

```
2 2
01```

### 输出

```
10```

## 样例 #2

### 输入

```
10 1 
1```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 6
110100```

### 输出

```
601210```

# AI分析结果



---
# 💡 Kay的C++算法解析：『MdOI R2』Mayuri 深入学习指南 💡

<introduction>
今天我们来一起分析“『MdOI R2』Mayuri”这道C++编程题。题目要求构造一个满足特定模数条件的最小b位正整数，核心难点在于如何高效处理大数的模数判断和贪心选择每一位的最小数字。本指南将帮助大家梳理思路，理解贪心算法的核心，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法 + 模运算优化

🗣️ **初步分析**：
解决这道题的关键在于“贪心构造”——从高位到低位逐位确定数字，每一步选择最小的可能数字，同时满足当前位的模数条件（S[i]为1时前i位是a的倍数，S[i]为0时不是）。贪心的核心思想是“每一步选择局部最优，最终得到全局最优”，就像搭积木时每次选最小的可用零件，最后拼成最小的整体。

在本题中，贪心策略的关键在于维护当前前i-1位的余数（即前i-1位组成的数模a的结果）。利用模运算性质：前i位的余数 = (前i-1位的余数 × 10 + 当前位数字) % a。通过这个性质，我们无需存储大数，只需维护余数即可高效判断当前位是否满足条件。

核心难点包括：
1. 如何选择每一位的最小数字（0-9中选最小且符合条件的）。
2. 处理特殊情况（如a=10且S[0]为1时无解）。
3. 当b很大（如1e5）时，如何避免存储大数，用余数优化。

可视化设计思路：采用8位像素风格动画，用横向排列的像素块表示每一位数字（初始为问号，逐步填充），余数用顶部的数字显示。每一步选择数字时，候选数字（0-9）从左到右闪烁，选中的数字变为绿色并固定，余数更新为新值。关键步骤（如余数变化、条件满足）伴随“叮”的像素音效。AI自动演示模式会自动按贪心策略填充每一位，学习者可单步查看每一步的选择逻辑。

---

## 2. 精选优质题解参考

<eval_intro>
经过对多份题解的评估（思路清晰度、代码规范性、算法有效性等），以下题解因逻辑简洁、代码高效且适用于全数据范围（包括b=1e5），被选为优质参考：
</eval_intro>

**题解一：作者BFqwq（赞36）**
* **点评**：此题解是官方题解，核心思路清晰，证明了贪心策略的正确性（每一步必存在解）。代码简洁，仅用一个变量维护余数，适用于大b场景。亮点在于通过模运算优化避免大数存储，且处理了a=10的特殊情况（S[0]为1时直接输出-1）。实践价值高，代码可直接用于竞赛。

**题解二：作者grass8cow（赞9）**
* **点评**：此题解代码极其简洁（未使用数组），通过逐位计算余数，每一步选择最小数字。亮点在于余数维护的巧妙：当S[i]为1时，当前位数字为(a - 前余数×10%a) %a；当S[i]为0时，优先选0（若前余数×10%a≠0），否则选1。代码可读性强，变量名清晰（如`now`表示当前余数），边界处理严谨（如首位不能为0）。

**题解三：作者SpeedStar（赞3）**
* **点评**：此题解采用贪心策略，逐位枚举0-9选择最小符合条件的数字，维护余数。代码结构清晰，关键逻辑（余数更新、条件判断）明确。亮点在于通过`n = (n * 10 + j) % a`维护余数，避免大数运算，适用于大b场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，提炼解决策略：
</difficulty_intro>

1.  **关键点1：如何维护当前余数？**
    * **分析**：直接存储前i位组成的数（如b=1e5时）会溢出，因此必须用模运算优化。前i位的余数 = (前i-1位的余数 × 10 + 当前位数字) % a。通过维护这个余数，即可高效判断当前位是否满足条件。
    * 💡 **学习笔记**：模运算性质是处理大数问题的关键，可避免存储大数，降低时间/空间复杂度。

2.  **关键点2：如何选择每一位的最小数字？**
    * **分析**：对于S[i]为1的情况，需要当前位数字使得（前余数×10 + 当前位）%a=0，最小数字为(a - 前余数×10%a) %a（若前余数×10%a=0，则选0）。对于S[i]为0的情况，优先选0（若前余数×10%a≠0），否则选1（确保不被a整除）。
    * 💡 **学习笔记**：贪心选择时，优先选小数字（0→1→…→9），找到第一个符合条件的即可。

3.  **关键点3：处理特殊情况（如a=10）**
    * **分析**：当a=10时，S[0]为1的情况无解（1位数无法是10的倍数）。其他情况按贪心处理（S[i]为1时选0，S[i]为0时选1）。
    * 💡 **学习笔记**：特殊值（如a=10）需单独判断，避免逻辑错误。

### ✨ 解题技巧总结
<summary_best_practices>
- **模运算优化**：用余数代替大数，避免溢出，适用于大位数问题。
- **贪心选择最小数字**：从0开始枚举，找到第一个符合条件的数字，确保结果最小。
- **特殊情况特判**：如a=10时，S[0]为1直接输出-1。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，适用于全数据范围（包括b=1e5），代码简洁高效，关键逻辑清晰。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合BFqwq和grass8cow的题解思路，采用贪心策略，维护当前余数，逐位构造最小数字，适用于所有数据范围。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        int a, b;
        char s[100005];
        cin >> a >> b >> s;

        if (a == 10 && s[0] == '1') { // 特判a=10且首位要求整除的情况
            cout << -1 << endl;
            return 0;
        }

        int now = 0; // 当前前i-1位的余数
        for (int i = 0; i < b; ++i) {
            if (i == 0) { // 处理首位
                if (s[i] == '1') {
                    cout << a; // 首位最小为a（a<=10，且a≠10时）
                    now = 0; // 前1位是a，余数为0
                } else {
                    cout << 1; // 首位最小为1（非0且不被a整除）
                    now = 1 % a;
                }
            } else {
                now = (now * 10) % a; // 前i-1位余数×10后模a
                if (s[i] == '1') { // 需要当前前i位被a整除
                    int need = (a - now) % a; // 需要的当前位数字
                    cout << need;
                    now = 0; // 前i位余数为0
                } else { // 需要当前前i位不被a整除
                    if (now == 0) { // 前i-1位余数×10后为0，当前位选1（避免被整除）
                        cout << 1;
                        now = 1;
                    } else { // 前i-1位余数×10后非0，当前位选0（最小）
                        cout << 0;
                        now = now; // 余数不变（now*10+0 mod a = now*10 mod a = now）
                    }
                }
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先处理特殊情况（a=10且首位要求整除），然后逐位构造数字。首位根据S[0]选择a或1，后续位通过维护余数`now`，根据S[i]的要求选择最小数字（0或(a - now) %a），确保每一步都满足条件且结果最小。

---
<code_intro_selected>
接下来，剖析优质题解中的核心代码片段，理解其亮点和逻辑。
</code_intro_selected>

**题解一：作者grass8cow**
* **亮点**：代码极简（未使用数组），通过变量`now`维护余数，逐位计算并输出，适用于大b场景。
* **核心代码片段**：
    ```cpp
    int a, b, i, now;
    char c;
    int main() {
        cin >> a >> b >> c;
        if (a == 10 && c == '1') { cout << -1; return 0; }
        if (c == '1') cout << a;
        else cout << 1, now = 1;
        for (i = 1; i < b; i++) {
            cin >> c; 
            now = now * 10 % a;
            if (c == '0') { if (now) cout << 0; else cout << 1, now = 1; }
            else cout << (a - now) % a, now = 0;
        }
        return 0;
    }
    ```
* **代码解读**：
  - 首位处理：若S[0]为1且a≠10，输出a（最小满足条件的首位）；否则输出1（最小非0且不被a整除的首位）。
  - 后续位处理：`now = now * 10 % a`计算前i-1位余数×10后的余数。
  - S[i]为0时：若`now`非0，选0（最小且不被整除）；否则选1（避免被整除）。
  - S[i]为1时：选`(a - now) % a`（最小数字使前i位被整除），余数置0。
* 💡 **学习笔记**：极简代码的关键是用变量维护余数，避免存储大数，适用于大位数问题。

**题解二：作者SpeedStar**
* **亮点**：逐位枚举0-9选择最小符合条件的数字，逻辑直观，易理解。
* **核心代码片段**：
    ```cpp
    int main() {
        int a, b;
        cin >> a >> b;
        string s;
        cin >> s;
        int n = 0;
        for (int i = 0; i < b; i++) {
            if (i == 0) {
                if (s[0] == '0') { cout << 1; n = 1; }
                else { if (a == 10) { cout << "-1\n"; break; } else { cout << a; n = a; } }
            } else {
                if (s[i] == '0') {
                    for (int j = 0; j <= 9; j++) {
                        if ((n * 10 + j) % a != 0) { cout << j; n = (n * 10 + j) % a; break; }
                    }
                } else {
                    for (int j = 0; j <= 9; j++) {
                        if ((n * 10 + j) % a == 0) { cout << j; n = (n * 10 + j) % a; break; }
                    }
                }
            }
        }
        return 0;
    }
    ```
* **代码解读**：
  - 首位处理：若S[0]为0，选1（最小非0且不被整除）；若S[0]为1且a≠10，选a（最小被整除的首位）。
  - 后续位处理：枚举0-9，找到第一个使前i位满足条件的数字，更新余数`n`。
* 💡 **学习笔记**：枚举0-9找最小符合条件的数字是贪心的直观实现，适合理解贪心策略的本质。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解贪心构造过程，我们设计一个“像素数字构造器”动画，以8位复古风格展示每一位的选择过程和余数变化。
</visualization_intro>

  * **动画演示主题**：像素数字构造器——万由里的Lucky Number之旅

  * **核心演示内容**：从高位到低位逐位构造数字，展示每一步选择的最小数字、余数变化，以及是否满足S的条件。

  * **设计思路简述**：采用8位像素风格（类似FC游戏），用横向排列的像素块表示每一位（初始为问号），顶部显示当前余数。每一步选择数字时，候选数字（0-9）从左到右闪烁，选中的数字变为绿色并固定，余数更新为新值。关键操作（如余数变化、条件满足）伴随“叮”的像素音效，完成构造时播放胜利音效。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为三部分：顶部显示余数（初始为？），中间为b个像素块（每个块显示？），底部为控制面板（单步/自动/重置按钮，速度滑块）。
        - 8位风格背景音乐（如《超级玛丽》经典旋律）开始播放。

    2.  **首位构造**：
        - 首位像素块高亮，候选数字1-9（S[0]为0时）或a（S[0]为1时）闪烁。
        - 选中数字后，像素块变为数字（如1或a），余数更新为1%a或0，顶部余数显示更新。
        - 播放“叮”音效（数字固定）。

    3.  **后续位构造**：
        - 当前处理位像素块高亮，候选数字0-9从左到右闪烁。
        - 找到符合条件的最小数字后，像素块变为该数字，余数更新为新值（(当前余数×10 + 数字)%a）。
        - 若S[i]为1且余数为0，或S[i]为0且余数非0，像素块变为绿色（成功）；否则红色（错误，实际不会发生，因贪心保证有解）。
        - 播放“叮”音效（数字固定）。

    4.  **AI自动演示**：
        - 点击“AI演示”，动画自动按贪心策略填充每一位，学习者可观察每一步的选择逻辑。

    5.  **完成/失败状态**：
        - 若成功构造，所有像素块变为绿色，播放胜利音效（如《超级玛丽》通关音），顶部显示“成功！”。
        - 若失败（如a=10且S[0]为1），首位像素块变为红色，播放失败音效（短促“咚”声），顶部显示“-1”。

  * **旁白提示**：
    - （首位时）“首位不能为0，我们需要选最小的数字满足条件！”
    - （后续位时）“当前余数是X，我们需要选一个数字，使得新的余数满足S的条件~”
    - （选中数字时）“选到啦！这个数字是最小的符合条件的~”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到每一位的选择过程和余数变化，理解贪心算法如何确保每一步都选最小数字，最终构造出符合条件的Lucky Number。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
贪心构造数字的策略不仅适用于本题，还可解决许多类似问题，关键在于识别“每一步选最小数字”的条件，并结合模运算优化。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 构造满足特定模数条件的最小数（如构造最小b位数，其前i位是k的倍数）。
    - 处理大位数问题时，用模运算维护余数，避免存储大数。
    - 特殊值（如a=10）需单独判断，避免逻辑错误。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1100 高低位交换**
          * 🗣️ **推荐理由**：考察对二进制位的贪心构造，需逐位处理并选择最小数字，与本题贪心思路类似。
    2.  **洛谷 P1071 潜伏者**
          * 🗣️ **推荐理由**：涉及字符映射的贪心构造，需每一步选择最小可能的映射，锻炼贪心策略的应用。
    3.  **洛谷 P1219 八皇后**
          * 🗣️ **推荐理由**：经典回溯问题，但可结合贪心优化（如优先选择冲突少的列），与本题的“局部最优”思想相关。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验和思路，以下是有价值的总结：
</insights_intro>

> **参考经验 (来自作者幻之陨梦)**：“我一开始用getchar读入S，结果因为空格问题WA了很久。后来发现应该用scanf或cin直接读取字符串。”
>
> **点评**：输入处理是编程中常见的坑，特别是字符读取时需注意空格或换行符。使用`cin >> s`或`scanf("%s", s)`可避免此类问题，这提醒我们在编码时要仔细处理输入输出。

---

<conclusion>
本次关于“『MdOI R2』Mayuri”的C++解题分析就到这里。通过贪心策略和模运算优化，我们可以高效构造满足条件的最小数字。希望这份指南能帮助大家理解贪心算法的核心，并在类似问题中举一反三。编程的乐趣在于不断挑战和思考，下次见！💪
</conclusion>

---
处理用时：178.29秒
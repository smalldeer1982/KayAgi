# 题目信息

# 01迷宫

## 题目描述

有一个仅由数字 $0$ 与 $1$ 组成的 $n \times n$ 格迷宫。若你位于一格 $0$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $1$ 上，同样若你位于一格 $1$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $0$ 上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。

## 说明/提示

对于样例，所有格子互相可达。

- 对于 $20\%$ 的数据，$n \leq 10$；
- 对于 $40\%$ 的数据，$n \leq 50$；
- 对于 $50\%$ 的数据，$m \leq 5$；
- 对于 $60\%$ 的数据，$n,m \leq 100$；
- 对于 $100\%$ 的数据，$1\le n \leq 1000$，$1\le m \leq 100000$。

## 样例 #1

### 输入

```
2 2
01
10
1 1
2 2
```

### 输出

```
4
4
```

# AI分析结果

# 01迷宫题解分析


### **一、题目核心问题**
给定一个 \( n \times n \) 的 01 迷宫，每次可以从 0 走到相邻的 1，或从 1 走到相邻的 0。对于每个查询点，求其能到达的格子数（包括自身）。


### **二、核心思路**
**问题本质**：**连通块识别**。能互相到达的点属于同一个连通块，每个连通块的大小即为该块内所有点的答案。  
**解决方法**：遍历迷宫，识别所有连通块，记录每个点所属连通块的大小。查询时直接返回该点的连通块大小。


### **三、常见实现方法**
#### 1. **BFS（广度优先搜索）**
- **思路**：从每个未访问的点出发，用队列遍历其连通块，标记所有访问过的点，并记录连通块大小。
- **优化点**：
  - 用数组代替队列（`queue`），减少 overhead（如 `q[1000005]` 存储节点）。
  - 边界处理：将迷宫数组周围设为 2（非 0/1），避免每次判断越界。
  - 输入优化：用 `scanf` 读取字符串，转换为数字数组（避免 `cin` 的慢速度）。
- **示例代码片段**（C++）：
  ```cpp
  struct node { int x, y; } q[1000005]; // 用数组代替队列
  void bfs(int sx, int sy) {
      int front = 0, tail = 1;
      q[front] = {sx, sy};
      int num = 1;
      v[sx][sy] = 1; // 标记已访问
      while (front < tail) {
          node cur = q[front++];
          for (int i = 0; i < 4; i++) { // 四个方向
              int nx = cur.x + dx[i], ny = cur.y + dy[i];
              if (a[cur.x][cur.y] + a[nx][ny] == 1 && !v[nx][ny]) { // 0和1相邻且未访问
                  num++;
                  q[tail++] = {nx, ny};
                  v[nx][ny] = 1;
              }
          }
      }
      // 将连通块内所有点的答案设为num
      for (int i = 0; i < tail; i++) v[q[i].x][q[i].y] = num;
  }
  ```


#### 2. **DFS（深度优先搜索）**
- **思路**：从每个未访问的点出发，用递归或栈遍历其连通块，标记所有访问过的点，并记录连通块大小。
- **注意**：递归可能导致栈溢出（如 \( n=1000 \) 时，递归深度可能达到 1000，超过默认栈大小），因此更推荐用栈实现非递归 DFS。


#### 3. **并查集（Disjoint Set Union, DSU）**
- **思路**：将二维坐标转换为一维索引（如 \( (i,j) \to i \times n + j \)），合并相邻的符合条件的点（0 和 1 相邻），统计每个根节点的大小。查询时找根节点的大小。
- **优化点**：路径压缩和按秩合并，使合并和查找操作近似 \( O(1) \)。
- **示例代码片段**（C++）：
  ```cpp
  int find(int x) { // 路径压缩
      return fa[x] == x ? x : fa[x] = find(fa[x]);
  }
  void unite(int x, int y) { // 按秩合并
      x = find(x), y = find(y);
      if (x == y) return;
      if (rank[x] < rank[y]) swap(x, y);
      fa[y] = x;
      size[x] += size[y];
  }
  ```


### **四、关键优化细节**
1. **输入输出优化**：
   - 用 `scanf`/`printf` 代替 `cin`/`cout`（`cin` 默认同步 stdio，速度慢）。
   - 用 `getchar` 逐个读取字符（适用于大量输入）。
2. **避免重复计算**：
   - 用数组 `v` 记录每个点的答案（连通块大小），查询时直接返回 `v[x][y]`。
3. **队列优化**：
   - 用数组代替 `queue`，减少容器的 overhead（如 `q[1000005]` 存储节点）。
4. **边界处理**：
   - 将迷宫数组周围设为 2（非 0/1），避免每次访问时判断越界（如 `a[cur.x][cur.y] + a[nx][ny] == 1` 自动过滤越界点）。


### **五、常见错误点**
1. **输入处理错误**：
   - 未正确转换字符串为数字数组（如 `c[j-1] - '0'`）。
   - 读取时未跳过换行符（如用 `scanf("%s", c)` 读取字符串时，自动跳过 whitespace）。
2. **边界处理错误**：
   - 访问了数组外的元素（如未将数组周围设为 2，或未判断 `nx`/`ny` 是否在范围内）。
3. **队列/栈溢出**：
   - 队列/栈的大小不够（如 `q[1000005]` 应足够大，容纳 \( n^2 \) 个节点）。
4. **未标记已访问**：
   - 导致无限循环（如 `v` 数组未正确标记已访问的点）。


### **六、最佳实践总结**
1. **优先选择 BFS**：避免栈溢出，适合大迷宫。
2. **用数组记录答案**：避免重复计算，查询时直接返回。
3. **输入输出优化**：用 `scanf`/`printf` 或快读函数。
4. **边界处理简化**：将数组周围设为 2，避免越界判断。
5. **队列高效使用**：用数组代替 `queue`，提高速度。


### **七、示例题解代码（C++）**
```cpp
#include <cstdio>
#include <cstring>
using namespace std;

const int dx[] = {-1, 1, 0, 0};
const int dy[] = {0, 0, -1, 1};
int a[1010][1010], v[1010][1010];
int n, m;

struct node { int x, y; } q[1000005];

void bfs(int sx, int sy) {
    int front = 0, tail = 1;
    q[front] = {sx, sy};
    int num = 1;
    v[sx][sy] = 1;
    while (front < tail) {
        node cur = q[front++];
        for (int i = 0; i < 4; i++) {
            int nx = cur.x + dx[i], ny = cur.y + dy[i];
            if (a[cur.x][cur.y] + a[nx][ny] == 1 && !v[nx][ny]) {
                num++;
                q[tail++] = {nx, ny};
                v[nx][ny] = 1;
            }
        }
    }
    for (int i = 0; i < tail; i++) v[q[i].x][q[i].y] = num;
}

int main() {
    scanf("%d%d", &n, &m);
    // 初始化边界为2
    for (int i = 0; i <= n + 1; i++)
        for (int j = 0; j <= n + 1; j++)
            a[i][j] = 2;
    // 读取输入
    char c[1010];
    for (int i = 1; i <= n; i++) {
        scanf("%s", c);
        for (int j = 1; j <= n; j++)
            a[i][j] = c[j - 1] - '0';
    }
    // 处理所有连通块
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            if (!v[i][j]) bfs(i, j);
    // 处理查询
    while (m--) {
        int x, y;
        scanf("%d%d", &x, &y);
        printf("%d\n", v[x][y]);
    }
    return 0;
}
```


### **八、总结**
01 迷宫的核心是连通块识别，通过 BFS/DFS 或并查集可以高效解决。实现时需注意输入输出优化、边界处理和队列的高效使用，避免常见错误（如输入处理、边界越界、重复计算）。

---
处理用时：132.76秒
# 题目信息

# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP2017提高组] 奶酪 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：并查集（Union-Find）/ 图的遍历（DFS/BFS）


🗣️ **初步分析**：  
解决“奶酪”问题，关键是判断**老鼠能否通过连通的空洞从下表面走到上表面**。这本质上是一个**连通性问题**——就像判断两个朋友是否在同一个“朋友圈”里。  

### 核心算法比喻：并查集=“朋友圈合并”  
并查集是一种管理“集合”的数据结构，就像我们的微信朋友圈：  
- 每个空洞是一个“人”，初始时各自独立（自己的朋友圈只有自己）；  
- 如果两个空洞相交/相切（可以连通），就把他们的“朋友圈”合并（加好友）；  
- 最后，只要**下表面的空洞**和**上表面的空洞**在同一个“朋友圈”里，老鼠就能走过去！  

### 题解思路与难点  
所有题解的核心思路都围绕“连通性”展开，主要分为两类：  
1. **并查集**（推荐）：合并连通的空洞，最后检查上下表面的空洞是否连通；  
2. **DFS/BFS**（图遍历）：把空洞看作图的节点，连通的空洞连边，从下表面的节点开始遍历，看能否到达上表面的节点。  

**核心难点**：  
- **三维距离计算**：如何判断两个空洞是否相交？需要用三维距离公式，且要避免精度问题（比如用距离的平方代替开根号）；  
- **高效处理连通性**：并查集的“路径压缩”和“按秩合并”技巧，能让合并和查询操作几乎是常数时间；  
- **多组数据处理**：每组数据都要重置并查集或 visited 数组，否则会“串数据”。  

### 可视化设计思路  
我打算用**8位像素风格**做一个“朋友圈合并动画”：  
- 屏幕左侧是“奶酪”的侧视图（二维，z轴为高度），下表面是绿色，上表面是红色；  
- 空洞用彩色圆形表示（比如蓝色），合并时用黄色线条连接；  
- 单步执行时，会高亮当前合并的两个空洞，同时显示“合并朋友圈”的文字提示；  
- 自动播放时，合并过程会有“叮”的音效，成功连通上下表面时会有“胜利”音效（比如FC游戏的通关声）。  


## 2. 精选优质题解参考


### 题解一：并查集（作者：Fading，赞323）  
* **点评**：这是最经典的并查集解法，思路清晰到“一看就懂”！  
  - **思路**：把每个空洞看作一个集合，合并所有相交的空洞；然后检查“下表面的空洞集合”和“上表面的空洞集合”是否有交集。  
  - **代码亮点**：  
    1. 用**距离的平方**判断相交（`dis <= 4*r*r`），避免了`sqrt`的精度问题；  
    2. 并查集的`find`函数用了**路径压缩**（`fa[x] = find(fa[x])`），让查询更快；  
    3. 变量命名规范（`f1`存上表面空洞，`f2`存下表面空洞），可读性高。  
  - **实践价值**：代码几乎可以直接用于竞赛，边界处理（比如`z[j]+r >= h`判断上表面）非常严谨。  


### 题解二：并查集（作者：ikunTLE，赞11）  
* **点评**：这篇题解的代码风格非常“干净”，适合初学者模仿！  
  - **思路**：和题解一类似，但用了`vector`存上下表面的空洞，代码结构更清晰。  
  - **代码亮点**：  
    1. 用`#define int long long`避免了整数溢出（这是本题的“坑点”，很多人因为没开long long而爆零）；  
    2. `_init`、`_find`、`_merge`函数的命名很规范，一看就知道是并查集的模板；  
    3. 输入用了`read`函数（快速读入），适合大数据量的情况。  


### 题解三：DFS（作者：wyx__，赞5）  
* **点评**：这篇题解指出了DFS的常见错误，对初学者很有启发！  
  - **思路**：从下表面的空洞开始，深度优先遍历所有连通的空洞，看是否能到达上表面的空洞。  
  - **代码亮点**：  
    1. 用`v[k] = 1`标记已访问的空洞，避免重复遍历（这是DFS的关键，否则会陷入死循环）；  
    2. 指出了“清除标记”（`v[k] = 0`）的错误——因为每个空洞只能走一次，清除标记会导致重复遍历，从而超时（TLE）。  


## 3. 核心难点辨析与解题策略


### 1. 如何判断两个空洞是否相交？  
**难点**：三维距离计算容易出精度问题，或者忘记开long long导致溢出。  
**解决策略**：  
- 用**距离的平方**代替开根号（`(x1-x2)^2 + (y1-y2)^2 + (z1-z2)^2 <= (2r)^2`）；  
- 所有变量都用`long long`（比如坐标、半径），避免整数溢出。  
💡 **学习笔记**：计算距离时，优先用平方代替开根号，既避免精度问题，又提高效率。  


### 2. 如何高效处理连通性？  
**难点**：如果直接遍历所有空洞对，时间复杂度是O(n²)，但并查集能把合并和查询操作优化到几乎O(1)。  
**解决策略**：  
- 并查集的`find`函数用**路径压缩**（让树的深度变浅）；  
- `merge`函数用**按秩合并**（把小的树合并到大树下，减少深度）。  
💡 **学习笔记**：并查集是处理连通性问题的“神器”，一定要掌握它的模板！  


### 3. 如何处理多组数据？  
**难点**：每组数据的并查集或visited数组没有重置，导致“串数据”（比如上一组的数据影响下一组）。  
**解决策略**：  
- 每组数据开始前，重置并查集（`fa[i] = i`）；  
- 重置visited数组（`memset(v, 0, sizeof(v))`）。  
💡 **学习笔记**：多组数据处理的“黄金法则”：**不清空，见祖宗**！  


### ✨ 解题技巧总结  
- **技巧A**：遇到连通性问题，优先考虑并查集（代码量少，效率高）；  
- **技巧B**：计算距离时，用平方代替开根号（避免精度问题）；  
- **技巧C**：多组数据一定要重置变量和数组（否则会爆零）。  


## 4. C++核心代码实现赏析


### 本题通用核心C++实现参考（并查集）  
* **说明**：综合了Fading和ikunTLE的题解，是最经典的并查集实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;
  typedef long long ll;

  const int MAXN = 1005;
  ll fa[MAXN]; // 并查集数组
  ll x[MAXN], y[MAXN], z[MAXN]; // 空洞坐标
  vector<ll> top_holes, bottom_holes; // 上表面、下表面的空洞

  ll find(ll x) {
      if (fa[x] != x) fa[x] = find(fa[x]); // 路径压缩
      return fa[x];
  }

  void merge(ll x, ll y) {
      ll rx = find(x), ry = find(y);
      if (rx != ry) fa[rx] = ry; // 合并集合
  }

  ll dist_sq(ll x1, ll y1, ll z1, ll x2, ll y2, ll z2) {
      return (x1-x2)*(x1-x2) + (y1-y2)*(y1-y2) + (z1-z2)*(z1-z2); // 距离的平方
  }

  int main() {
      ll T;
      cin >> T;
      while (T--) {
          ll n, h, r;
          cin >> n >> h >> r;
          // 初始化并查集
          for (ll i = 1; i <= n; ++i) fa[i] = i;
          top_holes.clear();
          bottom_holes.clear();
          // 读入空洞坐标，并判断是否连接上下表面
          for (ll i = 1; i <= n; ++i) {
              cin >> x[i] >> y[i] >> z[i];
              if (z[i] + r >= h) top_holes.push_back(i); // 连接上表面
              if (z[i] - r <= 0) bottom_holes.push_back(i); // 连接下表面
              // 合并当前空洞与之前的空洞（如果相交）
              for (ll j = 1; j < i; ++j) {
                  if (dist_sq(x[i], y[i], z[i], x[j], y[j], z[j]) <= 4*r*r) {
                      merge(i, j);
                  }
              }
          }
          // 检查是否有上下表面的空洞连通
          bool ok = false;
          for (ll t : top_holes) {
              for (ll b : bottom_holes) {
                  if (find(t) == find(b)) {
                      ok = true;
                      break;
                  }
              }
              if (ok) break;
          }
          cout << (ok ? "Yes" : "No") << endl;
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **并查集初始化**：每个空洞初始时是自己的根节点；  
  2. **读入数据**：记录每个空洞的坐标，并判断是否连接上下表面；  
  3. **合并空洞**：遍历所有空洞对，合并相交的空洞；  
  4. **检查连通性**：看上下表面的空洞是否在同一个集合里。  


### 题解一（Fading）核心代码片段赏析  
* **亮点**：用距离的平方判断相交，避免精度问题。  
* **核心代码片段**：  
  ```cpp
  long long dis(long long x, long long y, long long z, long long x1, long long y1, long long z1) {
      return (x-x1)*(x-x1)+(y-y1)*(y-y1)+(z-z1)*(z-z1); // 距离的平方
  }
  ```  
* **代码解读**：  
  为什么不用`sqrt`？因为`sqrt`会把整数变成浮点数，容易有精度误差（比如`2.0000001`和`1.9999999`可能被判断为不相等，但其实它们的平方是相等的）。用距离的平方代替，直接用整数计算，既准确又高效。  
* 💡 **学习笔记**：计算距离时，优先用平方代替开根号！  


### 题解三（wyx__）核心代码片段赏析  
* **亮点**：正确标记已访问的空洞，避免DFS超时。  
* **核心代码片段**：  
  ```cpp
  void dfs(int k) {
      if (ok) return;
      if (z[k] + r >= h) {
          ok = 1;
          return;
      }
      v[k] = 1; // 标记已访问
      for (int i = 1; i <= n; ++i) {
          if (!v[i] && e(i, k)) {
              dfs(i);
          }
      }
  }
  ```  
* **代码解读**：  
  为什么不清除标记（`v[k] = 0`）？因为每个空洞只能走一次，清除标记会导致重复遍历（比如从A走到B，再从B走回A，无限循环），从而超时。正确的做法是标记已访问的空洞，不再处理。  
* 💡 **学习笔记**：DFS遍历图时，一定要标记已访问的节点，避免重复遍历！  


## 5. 算法可视化：像素动画演示（核心部分）


### 动画演示主题：“朋友圈合并大挑战”（8位像素风格）  
**设计思路**：用FC游戏的风格，让学习者像玩游戏一样理解并查集的合并过程。


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是“奶酪”的侧视图（二维，z轴为高度），下表面是绿色（y=0），上表面是红色（y=h）；  
   - 空洞用蓝色圆形表示，坐标对应输入的(x, z)（简化为二维，x轴为水平方向，z轴为高度）；  
   - 右侧是“控制面板”：有“开始”“单步”“重置”按钮，以及“速度滑块”（控制自动播放速度）。  

2. **算法启动**：  
   - 点击“开始”按钮，动画开始播放；  
   - 每个空洞初始时是独立的，用蓝色圆形表示，旁边显示编号（比如“洞1”“洞2”）。  

3. **合并过程**：  
   - 当两个空洞相交时，用黄色线条连接它们（表示合并朋友圈）；  
   - 单步执行时，会高亮当前合并的两个空洞，同时显示文字提示（比如“洞1和洞2合并啦！”）；  
   - 自动播放时，合并过程会有“叮”的音效（比如FC游戏的“选关”声）。  

4. **结果显示**：  
   - 如果上下表面的空洞连通，屏幕会显示“胜利！老鼠能过去～”，并播放通关音效（比如FC游戏的“通关”声）；  
   - 如果不连通，显示“失败！老鼠过不去～”，并播放失败音效（比如FC游戏的“死亡”声）。  


### 交互设计  
- **单步执行**：点击“单步”按钮，动画执行一步（合并一对空洞）；  
- **自动播放**：拖动“速度滑块”调整播放速度（比如“慢”“中”“快”），动画自动合并所有空洞；  
- **重置**：点击“重置”按钮，动画回到初始状态，重新开始。  


### 为什么这样设计？  
- **像素风格**：符合青少年的审美，让学习更有趣；  
- **游戏化元素**：用“合并朋友圈”“通关”等概念，激发学习者的兴趣；  
- **可视化反馈**：高亮、音效、文字提示，让学习者清楚看到每一步的变化，更容易理解并查集的工作原理。  


## 6. 拓展练习与相似问题思考


### 通用思路迁移  
并查集不仅能解决“奶酪”问题，还能解决很多**连通性问题**，比如：  
- 亲戚关系（判断两个人是否有亲戚关系）；  
- 朋友圈（判断两个人是否在同一个朋友圈）；  
- 网络连接（判断两台电脑是否连通）。  


### 洛谷练习推荐  
1. **洛谷 P1551 亲戚**（并查集基础）  
   - 🗣️ **推荐理由**：这是并查集的经典入门题，和“奶酪”问题的思路几乎一样，只是把“空洞”换成了“人”，“相交”换成了“亲戚关系”。  

2. **洛谷 P2078 朋友**（并查集应用）  
   - 🗣️ **推荐理由**：这道题需要合并“朋友”和“敌人的敌人”，比“奶酪”问题多了一层逻辑，适合巩固并查集的应用。  

3. **洛谷 P3367 并查集模板**（模板题）  
   - 🗣️ **推荐理由**：这是并查集的模板题，必须掌握！通过这道题，可以熟练掌握并查集的`find`和`merge`函数。  


## 7. 学习心得与经验分享（若有）


### 参考经验（来自wyx__的题解）  
> “我一开始写DFS的时候，加了`v[k] = 0`（清除标记），结果超时了。后来发现，每个空洞只能走一次，清除标记会导致重复遍历，所以去掉之后就过了。”  

**点评**：这是DFS的常见错误，很多初学者都会犯。 wyx__的经验提醒我们：**DFS遍历图时，一定要标记已访问的节点，并且不要清除标记**！  


## 结语  
本次关于“奶酪”问题的分析就到这里啦！希望大家能掌握并查集这个“神器”，解决更多连通性问题。记住：**编程的乐趣在于解决问题的过程，不要害怕犯错，多试几次就会了～** 💪  

如果有疑问，欢迎随时问我哦！ 😊

---
处理用时：162.56秒
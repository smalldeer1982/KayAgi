# 题目信息

# 可达性统计

## 题目描述

给定一张 $N$ 个点 $M$ 条边的有向无环图，分别统计从每个点出发能够到达的点的数量。

## 说明/提示

测试数据满足 $1 \le N,M \le 30000$，$1 \le x,y \le N$。

## 样例 #1

### 输入

```
10 10
3 8
2 3
2 5
5 9
5 9
2 3
3 9
4 8
2 10
4 9```

### 输出

```
1
6
3
3
2
1
1
1
1
1```

# AI分析结果

# 💡 Kay的C++算法解析：可达性统计 深入学习指南 💡

今天我们来一起分析“可达性统计”这道C++编程题。这道题围绕**有向无环图（DAG）的可达性问题**展开，核心是用高效的方式统计每个点能到达的所有点的数量。本指南会帮你理清思路、掌握关键技巧，并通过有趣的像素动画直观理解算法流程！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（DAG处理） + 编程技巧应用（bitset优化）

🗣️ **初步分析**：  
解决“每个点能到达多少点”的问题，本质是**图的可达性查询**。如果直接用暴力DFS/BFS统计每个点的可达点，时间复杂度会高达O(N²)（比如30000个点会是9亿次操作），肯定超时。这时候需要两个关键技巧：  
1. **DAG的拓扑顺序**：因为图没有环，我们可以按“从后往前”的顺序处理节点（比如拓扑排序的逆序），这样处理一个节点时，它的所有子节点的可达状态已经计算完毕，避免重复计算。  
2. **bitset优化**：把每个点的可达状态存成一个二进制串（bitset），每一位代表“是否能到达对应点”。比如`f[u][v] = 1`表示u能到达v。合并多个子节点的可达状态时，用**或操作**（`|`）就能快速合并，且自动去重（1|1=1，1|0=1）。  

举个简单的比喻：bitset就像一个“魔法笔记本”，每一页记着某个点能到达的所有点。当处理点u时，只需要把它所有子节点的“笔记本”撕下来拼在一起（或操作），再加上自己，就是u的“笔记本”啦！  

**核心算法流程**：  
- 对DAG进行拓扑排序，得到处理顺序（确保子节点先于父节点处理）；  
- 从后往前遍历拓扑序列，每个节点u的可达状态 = 自己（`f[u][u] = 1`） + 所有子节点v的可达状态（`f[u] |= f[v]`）；  
- 最后用`f[u].count()`统计u的可达点数量（二进制中1的个数）。  

**可视化设计思路**：  
我们会做一个**8位像素风的“可达性探险”动画**：  
- 用像素块代表节点（不同颜色区分未处理、处理中、已处理），像素线代表边；  
- 拓扑排序时，节点会“排队”进入队列（滑入动画+“叮”的音效）；  
- 处理节点时，子节点的bitset会“合并”到父节点（像素块闪烁+“啪”的音效）；  
- 完成后，节点会显示可达数量（数字跳动+“胜利”音效）。  


## 2. 精选优质题解参考

为了帮你快速掌握关键思路，我选了3个**逻辑清晰、代码简洁、技巧实用**的优质题解：


### 题解一：（来源：Atserckcn）  
* **点评**：这道题解把**拓扑排序**和**DFS**结合得非常巧妙！首先用拓扑排序确定节点的处理顺序（确保子节点先处理），再用DFS遍历每个节点，用bitset合并子节点的可达状态。代码里的`book`数组避免了重复DFS，`f[u][u] = true`初始化自己可达，逻辑链完整。尤其是拓扑排序的处理，完美解决了DAG中“先处理子节点”的问题，适合新手理解“顺序的重要性”。


### 题解二：（来源：YuzhenQin）  
* **点评**：这是一份**“极简主义”的优质代码**！用`vector`存图（比链式前向星更简洁），用`vis`数组标记是否已处理，核心DFS逻辑只有几行：处理当前节点→遍历子节点→合并bitset。代码没有冗余，完美体现了“记忆化DFS+bitset”的核心思想。适合想快速掌握基础解法的同学。


### 题解三：（来源：D23lhc）  
* **点评**：这道题解的**“倒推思维”**非常亮眼！拓扑排序后，从最后一个节点往前处理（因为最后一个节点没有子节点，可达数量是1），每个节点的可达状态直接合并子节点的bitset。这种“从后往前”的方式，完全不需要递归，效率更高，也更直观——就像“从终点往起点倒推每条路”。适合想理解“拓扑排序如何优化流程”的同学。


## 3. 核心难点辨析与解题策略

解决这道题的**3个核心难点**，也是图论可达性问题的通用挑战，我们一一拆解：


### 1. 如何高效存储“可达状态”？  
**难点**：如果用布尔数组存每个点的可达状态，合并多个子节点的状态需要O(N)时间，30000个点会超时。  
**解决策略**：用`bitset`！它把状态存成二进制串，或操作（`|`）的时间复杂度是O(N/64)（因为每64位合并一次），直接把时间降低到原来的1/64！比如`f[u] |= f[v]`一句话就能合并v的所有可达点到u。  


### 2. 如何保证“先处理子节点”？  
**难点**：如果先处理父节点，子节点的状态还没计算，合并会出错。  
**解决策略**：利用DAG的**拓扑排序**！拓扑排序的顺序是“父节点在前，子节点在后”，所以逆拓扑序（从后往前）处理，就能保证处理父节点时，子节点的状态已经算好了。或者用**记忆化DFS**（递归处理子节点，再合并状态）。  


### 3. 如何避免“重复计算”？  
**难点**：同一个节点可能被多个父节点访问，重复计算会浪费时间。  
**解决策略**：用`vis`数组（记忆化）标记是否已处理。比如`if (vis[u]) return;`，处理过的节点直接返回结果，不用再递归。  


### ✨ 解题技巧总结  
- **bitset是神器**：处理“集合合并”问题时，优先考虑bitset，比数组快得多！  
- **拓扑排序定顺序**：DAG的问题，先想拓扑排序，能帮你避免环和重复。  
- **记忆化省时间**：递归时用数组标记已处理的节点，拒绝“无用功”。  


## 4. C++核心代码实现赏析

先看一个**通用核心实现**，再拆解优质题解的亮点片段~


### 本题通用核心C++实现参考  
* **说明**：本代码综合了“拓扑排序+bitset”的核心思路，用链式前向星存图，逻辑清晰，适合新手入门。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <bitset>
using namespace std;

const int MAXN = 30005;
vector<int> e[MAXN];  // 用vector存图，简洁
bitset<MAXN> f[MAXN]; // 每个点的可达状态
int in[MAXN];         // 入度数组
vector<int> topo;     // 拓扑序列

void topsort(int n) {
    queue<int> q;
    for (int i = 1; i <= n; ++i)
        if (in[i] == 0) q.push(i);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        topo.push_back(u);
        for (int v : e[u]) {
            in[v]--;
            if (in[v] == 0) q.push(v);
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        int x, y;
        cin >> x >> y;
        e[x].push_back(y);
        in[y]++;
    }
    topsort(n);  // 生成拓扑序列
    // 逆拓扑序处理（从后往前）
    for (int i = topo.size() - 1; i >= 0; --i) {
        int u = topo[i];
        f[u][u] = 1;  // 自己可达自己
        for (int v : e[u]) {
            f[u] |= f[v];  // 合并子节点的可达状态
        }
    }
    // 输出结果
    for (int i = 1; i <= n; ++i) {
        cout << f[i].count() << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
1. 用`vector`存图，`in`数组记入住度；  
2. `topsort`函数生成拓扑序列；  
3. 逆拓扑序处理每个节点，初始化自己可达，合并子节点的bitset；  
4. 用`count()`统计每个点的可达数量。  


### 优质题解片段赏析

#### 题解一：（来源：Atserckcn）  
* **亮点**：拓扑排序+DFS，保证处理顺序的同时，用递归合并状态。  
* **核心代码片段**：  
```cpp
void dfs(int u) {
    if (book[u]) return;
    book[u] = true;
    for (int i = head[u]; i; i = edge[i].pre) {
        dfs(edge[i].to);
        f[u] |= f[edge[i].to];
    }
}
```
* **代码解读**：  
- `book[u]`标记是否已处理，避免重复；  
- 递归处理每个子节点`edge[i].to`；  
- 合并子节点的`f`到当前节点`f[u]`。  
* **学习笔记**：DFS和拓扑排序结合，是处理DAG的经典套路！  


#### 题解二：（来源：YuzhenQin）  
* **亮点**：代码极简，用`vector`存图，记忆化DFS一步到位。  
* **核心代码片段**：  
```cpp
void dfs(int u) {
    if (vis[u]) return;
    vis[u] = true;
    for (int v : e[u]) {
        dfs(v);
        f[u] |= f[v];
    }
}
```
* **代码解读**：  
- 没有复杂的结构体，`e[u]`直接存u的子节点；  
- `vis[u]`标记已处理，递归处理子节点后合并。  
* **学习笔记**：简洁的代码才是好代码！能用vector就别用链式前向星~  


#### 题解三：（来源：D23lhc）  
* **亮点**：逆拓扑序处理，不用递归，效率更高。  
* **核心代码片段**：  
```cpp
for (int i = cnt; ~i; i--) {  // ~i 等价于 i >= 0
    int j = res[i];
    f[j][j] = 1;
    for (int k = head[j]; k; k = edge[k].next) {
        int v = edge[k].to;
        f[j] |= f[v];
    }
}
```
* **代码解读**：  
- `res`是拓扑序列，`i`从最后一个元素往前遍历；  
- 直接合并子节点的`f[v]`到`f[j]`，没有递归。  
* **学习笔记**：逆拓扑序是DAG问题的“黄金顺序”，效率比递归高！  


## 5. 算法可视化：像素动画演示

我们做一个**“像素节点的可达之旅”**动画，用8位红白机风格，让算法“活”起来！


### 🌟 动画主题与设计思路  
- **主题**：像素小人“可达君”要遍历DAG，帮每个节点统计能到达的点。  
- **设计思路**：用复古像素风降低“距离感”，用音效和动画强化记忆——比如“入队”的“叮”声、“合并”的“啪”声，让你对每个操作印象深刻！  


### 🎬 动画帧步骤与交互  
1. **初始化（8位像素风）**：  
   - 屏幕显示像素化DAG（节点是彩色方块，边是白色线条）；  
   - 控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块；  
   - 播放8位风格BGM（比如《超级马里奥》的轻快旋律）。  

2. **拓扑排序（入队动画）**：  
   - 入度为0的节点（起点）会“滑入”队列（像素块从左到右移动），伴随“叮”的音效；  
   - 队列用像素方块堆叠展示（比如屏幕右侧的“队列区”）。  

3. **逆序处理（合并动画）**：  
   - 当前处理的节点会**闪烁红色**，子节点会**闪烁蓝色**；  
   - 合并子节点的bitset时，子节点的像素块会“发射”光线到父节点，父节点的bitset区域（屏幕下方）会实时更新（1的位置变亮）；  
   - 合并完成时，父节点的像素块会“变大”一下，伴随“啪”的音效。  

4. **结果展示（数字跳动）**：  
   - 每个节点处理完，会显示可达数量（数字从0跳到最终值，伴随“叮~”的音效）；  
   - 全部处理完，屏幕弹出“胜利”动画（像素烟花），播放上扬的胜利音效。  


### 🎮 交互与控制  
- **单步执行**：点击“下一步”，动画走一步，适合慢慢看细节；  
- **自动播放**：拖动速度滑块调整快慢，适合看整体流程；  
- **重置**：回到初始状态，重新开始。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的**bitset+拓扑排序/DFS**套路，能解决很多图论问题：  
- 统计每个点的“被可达”数量（反向图+同样方法）；  
- 求DAG中的最长路径（拓扑排序+动态规划）；  
- 统计每个点的“后继节点数”（和本题完全一样）。  


### 洛谷练习推荐  
1. **P2014 选课**（拓扑排序+动态规划）：选课程的问题，本质是DAG的树形DP，用拓扑排序定顺序。  
2. **P3374 树状数组1**（bitset应用）：虽然是树状数组，但bitset也能处理类似的“区间合并”问题。  
3. **P4017 最大食物链计数**（拓扑排序+计数）：统计DAG中的食物链数量，用拓扑排序递推。  


## 7. 学习心得与经验分享

很多作者提到：  
> “一开始用数组做，超时了，换成bitset就过了！”  
> “拓扑排序的顺序错了，结果全错，后来改成逆序就对了！”  

**点评**：这些经验太真实了！bitset的效率提升是“质变”，而拓扑排序的顺序是“胜负手”。遇到图论问题，先想“有没有更高效的数据结构”（比如bitset），再想“处理顺序对不对”（比如拓扑排序）。  


## 总结  

“可达性统计”是图论中的经典问题，核心是**用bitset优化集合合并**+**用拓扑排序/DFS保证处理顺序**。通过这道题，你能掌握图论的关键技巧，也能体会到“数据结构选对了，问题就解决了一半”！  

记住：编程的乐趣在于“用聪明的方法解决笨问题”——bitset和拓扑排序就是这样的“聪明方法”！下次遇到图论问题，不妨先想：“能不能用bitset？要不要拓扑排序？”  

下次我们再一起探索新的编程挑战！💪

---
处理用时：94.71秒
# 题目信息

# 刷题

## 题目描述

NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。

今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。

时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。

现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。

我们假设从远古到未来，历法的表示与现在一样。


## 样例 #1

### 输入

```
2
1
1
2007-06-23-11:59
2007-06-23-12:00```

### 输出

```
1```

# AI分析结果

# 💡 Kay的C++算法解析：「刷题」深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟（时间计算）+ 贪心算法  

🗣️ **初步分析**：  
解决「刷题」问题，就像帮小A规划“备考日程”——首先得算清楚从现在到考试有多少**可用分钟**（模拟时间差），然后选**耗时最少的题目优先做**（贪心），这样才能刷最多题。  

- **模拟时间计算**：就像“数日子”，从开始时间到结束时间，一天天、一小时小时、一分钟分钟累加，还要注意**闰年（2月有29天）**和**月份天数差异（比如1月31天，4月30天）**。  
- **贪心算法**：类似“先吃小苹果”——小的题目耗时少，先做它们能让总题数最多。比如有10分钟，选2分钟和3分钟的题，能做2道；如果选5分钟的题，只能做1道，显然前者更好。  

**核心难点**：时间计算的准确性（比如跨年份、跨月份时的天数计算）、闰年判断的正确性。  
**解决方案**：用**分步骤计算**（先算年、再算月、再算日、最后算时分），用**函数封装**（比如`panding`函数判断闰年）避免重复代码。  

**可视化设计思路**：  
计划做一个**8位像素风格的“备考日历”动画**：  
- 屏幕左侧显示**像素化日历**（比如1980年代游戏中的日历界面），开始时间和结束时间之间的日期用**动态翻动**效果展示，每天过去时伴随“滴答”音效。  
- 屏幕右侧显示**剩余时间（分钟）**和**已做题数**，选题目时，题目会变成**小像素块**从右侧飞入日历，剩余时间减少，做对时播放“叮”的音效。  
- 支持**单步执行**（手动翻页）和**自动播放**（快速展示时间流逝），帮助直观看到时间计算的每一步。  


## 2. 精选优质题解参考

为大家筛选了3份**思路清晰、代码易读**的优质题解，评分均≥4星：


### **题解一：作者Ousmane_Dembele（赞：43）**  
* **点评**：这份题解的“时间计算”步骤非常**直白**，就像“一步步数日子”，适合初学者理解。  
  - **思路清晰**：用`a`数组存开始时间（年、月、日、时、分），`b`数组存结束时间，分步骤计算年、月、日的差异，最后转换为分钟。  
  - **代码规范**：变量名`a[1]`（年）、`a[2]`（月）等含义明确，`panding`函数封装了闰年判断，可读性高。  
  - **实践价值**：用`scanf`处理输入（比如`%d-%d-%d-%d:%d`），完美解决了时间格式中的`-`和`:`问题，这是竞赛中常用的技巧。  


### **题解二：作者傅思维666（赞：14）**  
* **点评**：这份题解的“时间计算”用了**前缀和思想**，效率更高，适合进阶学习者。  
  - **亮点**：将时间转换为“从0000年1月1日开始的分钟数”，通过计算两个时间的前缀和之差，直接得到可用时间。这种方法避免了跨年月的复杂判断，代码更简洁。  
  - **代码技巧**：用`Days[2][13]`数组存平年和闰年的月份天数（`Days[0]`是平年，`Days[1]`是闰年），通过`rn`函数判断年份，快速获取当月天数。  


### **题解三：作者king_xbz（赞：5）**  
* **点评**：这份题解的**模块化设计**非常好，把时间计算拆分成`year_to_day`（计算年的贡献）、`month_to_day`（计算月的贡献）、`day_to_minute`（计算日时分的贡献）三个函数，逻辑清晰。  
  - **亮点**：用`mon_ping`（平年月份天数）和`mon_run`（闰年月份天数）两个数组，避免了重复判断，代码更高效。  
  - **实践价值**：函数封装让代码易于调试，比如如果年的计算出错，只需检查`year_to_day`函数，不用找整个代码。  


## 3. 核心难点辨析与解题策略

在解决“时间计算”问题时，大家常遇到以下3个难点，结合优质题解的做法，我们来一一解决：


### **1. 难点1：如何正确判断闰年？**  
* **问题**：闰年的判断条件是“能被4整除但不能被100整除，或者能被400整除”，比如2000年是闰年，1900年不是。  
* **解决方法**：用函数封装判断逻辑（如题解一中的`panding`函数）：  
  ```cpp
  bool panding(int x) {
      if (x % 100 == 0) {
          return x % 400 == 0; // 整百年需被400整除
      } else {
          return x % 4 == 0; // 非整百年需被4整除
      }
  }
  ```  
* 💡 **学习笔记**：闰年判断是时间题的“必考题”，记住这个函数，下次遇到直接用！  


### **2. 难点2：如何计算跨年月的天数？**  
* **问题**：比如从2023年12月到2024年3月，需要计算2023年12月的天数（31天）、2024年1月（31天）、2月（29天，因为2024是闰年）、3月的天数（比如到3月15日就是15天）。  
* **解决方法**：分步骤计算：  
  - 先算**完整年份**的天数（比如2023年到2024年之间的完整年份是0年，所以不用算）；  
  - 再算**开始年剩余的月份**（比如2023年12月，需要算12月的天数减去开始日）；  
  - 再算**结束年过去的月份**（比如2024年1月、2月、3月的天数）；  
  - 最后算**日时分**的差异（比如开始时间是12月25日10:00，结束时间是3月15日14:30，需要算12月25日剩余的时间、3月15日已过的时间）。  
* 💡 **学习笔记**：跨年月的天数计算就像“拆积木”，把大问题拆成小问题，一步步解决。  


### **3. 难点3：如何将时间转换为分钟？**  
* **问题**：天、小时、分钟之间的转换（1天=24小时=1440分钟，1小时=60分钟）。  
* **解决方法**：用**乘法累加**（如题解一中的计算）：  
  ```cpp
  t *= 1440; // 天转分钟
  t += 60 * a[4] + a[5]; // 加小时和分钟
  ```  
* 💡 **学习笔记**：时间单位转换是“固定公式”，记住1天=1440分钟，1小时=60分钟，直接套公式就行。  


### ✨ 解题技巧总结  
1. **输入处理**：用`scanf`处理带`-`和`:`的时间格式（如`%d-%d-%d-%d:%d`），比`cin`更方便。  
2. **函数封装**：把闰年判断、时间计算等重复逻辑封装成函数，代码更清晰。  
3. **贪心策略**：选最小的题目优先做，用`sort`排序后遍历，遇到不能做的题就break（因为后面的题更大）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了优质题解的思路，用“分步骤计算时间差”的方法，适合初学者理解。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <algorithm>
  using namespace std;

  int day[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}; // 平年月份天数
  int a[6], b[6]; // a[1]年, a[2]月, a[3]日, a[4]时, a[5]分；b同理
  long long t; // 可用分钟数
  int ans = 0;

  bool is_leap(int x) { // 判断闰年
      if (x % 100 == 0) return x % 400 == 0;
      return x % 4 == 0;
  }

  int main() {
      int n;
      cin >> n;
      int ti[n];
      for (int i = 0; i < n; i++) cin >> ti[i];
      sort(ti, ti + n); // 贪心：从小到大排序

      // 读入时间
      scanf("%d-%d-%d-%d:%d", &a[1], &a[2], &a[3], &a[4], &a[5]);
      scanf("%d-%d-%d-%d:%d", &b[1], &b[2], &b[3], &b[4], &b[5]);

      // 计算年的差异
      for (int i = a[1]; i < b[1]; i++) {
          if (is_leap(i)) t += 366 * 1440;
          else t += 365 * 1440;
      }

      // 计算月的差异（开始年剩余的月）
      for (int i = 1; i < a[2]; i++) {
          if (i == 2 && is_leap(a[1])) t -= 29 * 1440;
          else t -= day[i] * 1440;
      }
      // 计算月的差异（结束年过去的月）
      for (int i = 1; i < b[2]; i++) {
          if (i == 2 && is_leap(b[1])) t += 29 * 1440;
          else t += day[i] * 1440;
      }

      // 计算日的差异
      t += (b[3] - a[3]) * 1440;
      // 计算时分的差异
      t += (b[4] - a[4]) * 60 + (b[5] - a[5]);

      // 贪心选题目
      for (int i = 0; i < n; i++) {
          if (t >= ti[i]) {
              t -= ti[i];
              ans++;
          } else {
              break;
          }
      }

      cout << ans << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. 输入题目时间并排序（贪心准备）；  
  2. 读入开始和结束时间（用`scanf`处理格式）；  
  3. 分步骤计算年、月、日、时分的差异（转换为分钟）；  
  4. 遍历排序后的题目，选能做的最多题数。  


### 针对各优质题解的片段赏析

#### **题解一（Ousmane_Dembele）：时间计算片段**  
* **亮点**：用`a`和`b`数组存时间，分步骤计算，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  // 计算年的差异
  for (int i = a[1]; i < b[1]; i++) {
      if (panding(i)) t -= 366;
      else t -= 365;
  }
  // 计算月的差异
  for (int i = 1; i < a[2]; i++) t += day[i];
  for (int i = 1; i < b[2]; i++) t -= day[i];
  // 计算日的差异
  t += a[3];
  t -= b[3];
  // 转换为分钟
  t *= 1440;
  t += 60 * a[4] + a[5];
  t -= 60 * b[4] + b[5];
  t *= -1; // 修正符号
  ```  
* **代码解读**：  
  - 先算年的差异（`a[1]`到`b[1]`之间的年份）；  
  - 再算月的差异（`a[2]`之前的月份和`b[2]`之前的月份）；  
  - 再算日的差异（`a[3]`和`b[3]`）；  
  - 最后转换为分钟（乘以1440，加上小时和分钟）。  
* 💡 **学习笔记**：时间计算的“分步骤”是关键，每一步只处理一个单位（年、月、日、时分），避免混乱。  


#### **题解二（傅思维666）：前缀和时间计算片段**  
* **亮点**：用前缀和计算“从0000年1月1日开始的分钟数”，效率高。  
* **核心代码片段**：  
  ```cpp
  unsigned long long calculate(int y, int m, int d, int h, int min) {
      unsigned long long res = 0;
      // 计算年的贡献
      for (int i = 0; i < y; i++) {
          if (is_leap(i)) res += 366 * 1440;
          else res += 365 * 1440;
      }
      // 计算月的贡献
      for (int i = 1; i < m; i++) {
          if (i == 2 && is_leap(y)) res += 29 * 1440;
          else res += day[i] * 1440;
      }
      // 计算日、时、分的贡献
      res += (d - 1) * 1440 + h * 60 + min;
      return res;
  }
  ```  
* **代码解读**：  
  - 计算从0000年到`y`年之前的所有天数（转换为分钟）；  
  - 计算从1月到`m`月之前的所有天数（转换为分钟）；  
  - 计算从1日到`d`日之前的天数，加上小时和分钟（转换为分钟）。  
* 💡 **学习笔记**：前缀和是处理“区间和”问题的常用技巧，这里用它计算时间差，非常高效。  


#### **题解三（king_xbz）：模块化函数片段**  
* **亮点**：将时间计算拆分成多个函数，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  void year_to_day() { // 计算年的贡献
      for (int i = a; i < x; i++) {
          if (run(i)) tot += 366;
          else tot += 365;
      }
  }

  void month_to_day() { // 计算月的贡献
      for (int i = 1; i < b; i++) {
          if (run(a)) tot -= mon_run[i];
          else tot -= mon_ping[i];
      }
      for (int i = 1; i < y; i++) {
          if (run(x)) tot += mon_run[i];
          else tot += mon_ping[i];
      }
  }

  void day_to_minute() { // 计算日时分的贡献
      tot = (tot - c + z) * 24 * 60;
      tot = tot - (60 * d + e) + (60 * u + v);
  }
  ```  
* **代码解读**：  
  - `year_to_day`计算开始年到结束年之间的完整年份的天数；  
  - `month_to_day`计算开始年剩余的月份和结束年过去的月份的天数；  
  - `day_to_minute`计算日时分的差异（转换为分钟）。  
* 💡 **学习笔记**：模块化设计让代码易于维护，比如如果月的计算出错，只需检查`month_to_day`函数。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素备考日历**（仿FC游戏风格）  
### 设计思路  
用8位像素风格模拟小A的备考过程，让学习者直观看到**时间流逝**和**贪心选题目**的过程。动画中的元素包括：  
- **像素日历**：显示开始时间和结束时间之间的日期，每天过去时日历页会“翻动”，伴随“滴答”音效。  
- **剩余时间**：屏幕右侧显示剩余分钟数，选题目时会减少。  
- **已做题数**：屏幕右上角显示已做的题数，每做一题增加1。  
- **题目列表**：屏幕下方显示排序后的题目（小像素块），选中的题目会“飞入”日历，伴随“叮”的音效。  


### 动画帧步骤与交互关键点  
1. **初始化场景**：  
   - 屏幕左侧显示**像素日历**（比如2023年12月25日），右侧显示**剩余时间：0分钟**，右上角显示**已做题数：0**。  
   - 屏幕下方显示**题目列表**（比如3道题，分别是2分钟、3分钟、5分钟，用不同颜色的像素块表示）。  
   - 播放**8位风格背景音乐**（轻快的电子乐）。  

2. **时间计算演示**：  
   - 点击“开始”按钮，日历开始**逐天翻动**（比如从2023年12月25日翻到2024年3月15日），每翻一页，剩余时间增加**当天的分钟数**（比如1天=1440分钟）。  
   - 遇到闰年的2月29日，日历会显示**“闰年”**字样，剩余时间多增加1440分钟（29天-28天=1天）。  
   - 结束时间到达时，播放**“胜利”音效**（上扬的电子声），剩余时间停止增加。  

3. **贪心选题目演示**：  
   - 时间计算完成后，题目列表中的**最小题目**（比如2分钟）会“闪烁”提示。  
   - 点击“选题目”按钮，该题目会“飞入”日历，剩余时间减少2分钟，已做题数增加1，伴随“叮”的音效。  
   - 继续选下一个最小题目（3分钟），剩余时间减少3分钟，已做题数增加1。  
   - 当剩余时间不足以做下一个题目（5分钟）时，题目列表中的5分钟题目会“变暗”，提示不能选，动画结束。  

4. **交互控制**：  
   - 支持**单步执行**（手动翻页、手动选题目）：点击“下一步”按钮，执行一步操作。  
   - 支持**自动播放**（快速展示时间流逝和选题目过程）：拖动“速度滑块”调整播放速度（比如1倍速、2倍速）。  
   - 支持**重置动画**：点击“重置”按钮，回到初始状态，重新演示。  


### 旁白提示（动画中的文字气泡）  
- “现在开始计算时间啦！日历要翻页了，注意剩余时间的变化～”（时间计算开始时）  
- “今天是闰年的2月29日，剩余时间多了1天哦！”（遇到闰年时）  
- “选最小的题目啦！2分钟的题，做它！”（选第一个题目时）  
- “剩余时间不够做5分钟的题了，不能选啦！”（不能选下一个题目时）  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **模拟时间计算**：可用于处理“倒计时”“日程规划”等问题（比如计算从今天到生日还有多少天）。  
- **贪心算法**：可用于处理“资源分配”问题（比如用最少的硬币找零、合并果子使总代价最小）。  


### 练习推荐 (洛谷)  
1. **洛谷 P1090 - 合并果子**  
   - 🗣️ **推荐理由**：这道题是贪心算法的经典题，需要将果子合并成一堆，每次合并两堆，求最小总代价。和本题的“选最小题目”思路一致，能巩固贪心的正确性。  

2. **洛谷 P1223 - 排队接水**  
   - 🗣️ **推荐理由**：这道题需要安排接水顺序，使总等待时间最少。思路是“让接水时间短的人先接”，和本题的“选最小题目”思路完全一致，能强化贪心的应用。  

3. **洛谷 P2089 - 烤鸡**  
   - 🗣️ **推荐理由**：这道题需要模拟烤鸡的过程，计算符合条件的配方数。虽然是模拟题，但需要分步骤处理，和本题的“时间计算”思路类似，能锻炼模拟能力。  

4. **洛谷 P1157 - 组合数输出**  
   - 🗣️ **推荐理由**：这道题需要模拟组合数的输出，比如输出杨辉三角的第n行。虽然是数学题，但需要分步骤计算，和本题的“时间计算”思路类似，能锻炼逻辑思维。  


## 7. 学习心得与经验分享 (若有)  
本次分析的题解中，**Ousmane_Dembele**作者提到：“一开始把a、b数组写反了，改正后有很多忘改的地方”。这提醒我们：  
- **变量命名要明确**：比如用`start_year`代替`a[1]`，能减少混淆。  
- **调试时要检查变量值**：比如输出`a`和`b`数组的值，确认是否写反。  


## 结语  
本次关于“刷题”的C++解题分析就到这里啦！希望这份指南能帮助大家掌握**模拟时间计算**和**贪心算法**的技巧。记住：**模拟题要“分步骤”，贪心题要“选最小”**，多练习就能熟练掌握！  

下次我们再一起探索新的编程挑战吧！💪

---
处理用时：225.39秒
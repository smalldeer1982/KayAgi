# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果

---
# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡

<introduction>
  今天我们来分析「Mivik 写书」这道组合数学与编程技巧结合的题目。它需要我们计算随机字符串的**期望不同子串数**，核心是用「容斥原理」解决重复计数问题。跟着Kay一步步拆解，你会发现看似复杂的问题其实有清晰的套路！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：容斥原理 + 状态压缩 + 并查集（编程技巧应用）

🗣️ **初步分析**：
> 解决这道题的关键是**「把问题反过来想」**——不直接算每个字符串的不同子串数，而是算「每个可能的子串对总答案的贡献」（即有多少个长为n的字符串包含它）。但直接枚举子串会重复（比如子串"a"可能在一个字符串中出现多次），这时候需要用**容斥原理**：加加减减去掉重复计算的部分，让每个不同子串只被算一次。
> 简单来说，容斥就像算重叠的披萨面积：先把所有披萨的面积加起来，再减去重叠两次的部分，加上重叠三次的部分……最终得到总面积。本题中，我们用**状态压缩**枚举子串的出现位置（比如用二进制位表示子串在哪些位置开头），用**并查集**维护「哪些位置的字符必须相同」（因为子串重复出现的话，对应的位置字符要一致），最后通过容斥计算每个状态的贡献。
   - **题解思路共性**：所有优质题解都遵循「枚举子串长度→状压枚举出现位置→并查集处理约束→容斥求和→计算期望」的流程。
   - **核心难点**：① 如何将子串的重复出现转化为容斥状态？② 如何用并查集维护字符相同的约束？③ 如何高效计算每个状态的方案数？
   - **可视化设计思路**：我们用8位像素风格展示字符串（每个字符是一个彩色方块），用二进制位的亮灭表示子串的出现位置（亮代表该位置是子串开头），合并并查集时方块会「粘连」成同色，容斥加减时播放不同音效（加是"叮"，减是"嗒"），帮助你直观看到「重复部分被抵消」的过程。
   - **游戏化元素**：设计「子串探险者」小游戏，每完成一个子串长度的容斥计算就过一关，通关时播放胜利音效，增强成就感！

---

## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、实践价值」三个维度筛选了3份优质题解，它们的核心逻辑一致，但实现细节各有亮点：
</eval_intro>

**题解一：Huasushis的容斥+并查集解法（来源：个人博客）**
* **点评**：这份题解是「新手友好型」的典范！作者把容斥的逻辑拆解得特别清楚——用二进制位枚举子串的出现位置，用并查集合并必须相同的字符位置，最后根据二进制中1的个数（奇偶性）决定加或减。代码中的`sol`函数结构清晰，`getfa`函数是标准的并查集路径压缩实现，`qp`快速幂处理模运算也很规范。最棒的是作者用「小学奥数」类比容斥，降低了理解门槛，非常适合刚接触容斥的同学参考。

**题解二：7KByte的优化版解法（来源：洛谷）**
* **点评**：这道题的「效率担当」！作者用位运算优化了状态压缩的枚举过程（比如`mt`数组预处理二进制位的位置），`calc`函数中的循环更紧凑，常数很小。代码中的`bt`数组预处理了二进制数的奇偶性，避免了重复计算`__builtin_parity`，细节处理很到位。对于想学习「如何优化状压代码」的同学，这份题解很有参考价值。

**题解三：Reunite的入门级解法（来源：洛谷）**
* **点评**：这份题解的「结构最清晰」！作者把问题拆成「枚举子串长度→处理每个长度的容斥」，`work`函数中的`mp`数组记录每个位置被哪些子串覆盖，`Find`函数是标准的并查集实现。代码中的注释虽然不多，但变量名（比如`ss`代表连通块个数）很直观，适合刚学容斥的同学一步步跟着敲代码。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的「坑」主要在「如何处理重复计数」和「如何维护字符约束」，结合优质题解的共性，我提炼了3个核心难点及解决策略：
</difficulty_intro>

1.  **难点1：如何将子串的重复出现转化为容斥状态？**
    * **分析**：子串可能在字符串中出现多次（比如"a"在"aaa"中出现3次），直接计算会重复。解决方法是**状压枚举子串的出现位置**（用二进制位`s`表示，第`j`位为1代表子串从第`j`位开头），然后用「容斥原理」：如果`s`中有`k`个1（即子串出现`k`次），则贡献为`(-1)^(k+1)`（奇数次加，偶数次减），这样重复的部分会被抵消。
    * 💡 **学习笔记**：状压是处理「多个选择」问题的利器，容斥是解决「重复计数」的黄金法则！

2.  **难点2：如何处理字符相同的约束？**
    * **分析**：如果子串在多个位置出现，对应的字符必须相同（比如子串"ab"在位置1和3出现，那么位置1的字符要等于位置3的，位置2的等于位置4的）。解决方法是**并查集**：把需要相同的字符位置合并成一个连通块，每个连通块只能选一个字符，总方案数是`m^连通块个数`。
    * 💡 **学习笔记**：并查集是处理「等价关系」的神器，比如「字符必须相同」就是一种等价关系！

3.  **难点3：如何计算总期望？**
    * **分析**：总答案是「所有字符串的不同子串数之和」除以「总字符串数」（`m^n`）。因为模运算中的除法要转化为「乘以逆元」，所以最后要用快速幂计算`m^n`的逆元，再乘以总和。
    * 💡 **学习笔记**：模运算中没有除法，只有「逆元」！逆元可以用快速幂计算（费马小定理：当模数是质数时，`a^(mod-2)`是`a`的逆元）。

### ✨ 解题技巧总结
<summary_best_practices>
通过这道题，我们可以总结出「组合计数问题」的通用技巧：
</summary_best_practices>
-   **技巧1：反向思考**：直接算目标值困难时，试试算「每个元素的贡献」（比如本题算每个子串的贡献）。
-   **技巧2：状态压缩**：当选择的数量不超过20时，用二进制位表示选择状态（比如本题的子串出现位置）。
-   **技巧3：并查集维护约束**：当有「必须相同」的约束时，用并查集合并连通块，快速计算方案数。
-   **技巧4：模运算处理**：涉及除法时用逆元，快速幂是计算逆元的常用方法。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份「综合优质题解思路」的核心代码，它包含了「快速幂、并查集、容斥枚举」三个核心部分，逻辑清晰，适合入门：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Huasushis、7KByte的思路，保留了最清晰的逻辑，适合初学者理解。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <cstring>
    using namespace std;

    typedef long long ll;
    const int MOD = 1e9 + 7;
    int n;
    ll m;

    ll qpow(ll x, ll y) { // 快速幂，计算x^y mod MOD
        ll ans = 1;
        while (y) {
            if (y & 1) ans = ans * x % MOD;
            y >>= 1;
            x = x * x % MOD;
        }
        return ans;
    }

    int fa[25]; // 并查集数组，最多20位（n≤20）
    int getfa(int x) { // 并查集找根（路径压缩）
        return x == fa[x] ? x : fa[x] = getfa(fa[x]);
    }

    ll ans = 0;

    void sol(int len) { // 处理长度为len的子串
        int max_s = 1 << (n - len + 1); // 子串出现位置的状态数（二进制位数量）
        int mask = (1 << len) - 1; // 掩码，用于保留最近len位的状态
        for (int s = 1; s < max_s; ++s) { // 枚举所有非空状态（至少出现一次）
            for (int i = 0; i < len; ++i) fa[i] = i; // 初始化并查集（子串的每个位置独立）
            int cnt_free = 0; // 未被覆盖的位置数量（可以自由选字符）
            int current = 0; // 当前窗口的状态（最近len位的出现情况）
            for (int j = 0; j < n; ++j) { // 遍历原字符串的每个位置
                current = (current << 1) | ((s >> j) & 1); // 更新窗口状态（左移一位，加入当前位）
                current &= mask; // 保留最近len位
                if (current == 0) {
                    cnt_free++; // 未被任何子串覆盖，自由选
                } else {
                    // 合并当前窗口中所有需要相同的位置
                    int lowest = current & -current; // 取最低位的1（第一个出现的子串开头）
                    int root = getfa(__builtin_ctz(lowest)); // 最低位对应的子串位置的根
                    int temp = current - lowest; // 剩下的位（其他出现的子串开头）
                    while (temp) {
                        int bit = temp & -temp; // 取最低位的1
                        int pos = __builtin_ctz(bit); // 对应的子串位置
                        fa[getfa(pos)] = root; // 合并到root
                        temp -= bit;
                    }
                }
            }
            // 统计子串内部的连通块数量（每个连通块只能选一个字符）
            for (int i = 0; i < len; ++i) {
                if (fa[i] == i) cnt_free++;
            }
            // 容斥：根据s中1的个数的奇偶性决定加或减
            ll contribution = qpow(m, cnt_free);
            if (__builtin_parity(s)) { // 1的个数是奇数，加
                ans = (ans + contribution) % MOD;
            } else { // 偶数，减（加MOD避免负数）
                ans = (ans - contribution + MOD) % MOD;
            }
        }
    }

    int main() {
        cin >> n >> m;
        for (int len = 1; len <= n; ++len) { // 枚举所有可能的子串长度（1到n）
            sol(len);
        }
        // 计算期望：总和除以总字符串数m^n → 乘以m^n的逆元
        ll inv_total = qpow(qpow(m, n), MOD - 2);
        cout << ans * inv_total % MOD << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为四个部分：① `qpow`快速幂计算幂和逆元；② `getfa`并查集找根；③ `sol`函数处理每个长度的子串（状压枚举+并查集+容斥）；④ `main`函数枚举子串长度，调用`sol`，最后计算期望。核心逻辑在`sol`函数中：用二进制`-s`枚举子串的出现位置，用`current`维护当前窗口的状态，用并查集合并需要相同的字符位置，最后根据`s`的奇偶性计算贡献。

---
<code_intro_selected>
接下来看优质题解中的「亮点片段」，学习它们的巧妙之处：
</code_intro_selected>

**题解一：Huasushis的`sol`函数片段**
* **亮点**：用`current`维护窗口状态，避免重复计算子串的覆盖情况，逻辑非常直观。
* **核心代码片段**：
    ```cpp
    void sol(int x) {
        int a = (1 << (n - x + 1)), b = (1 << x) - 1;
        for (int i = 1; i < a; ++i) {
            int c = 0, tot = 0;
            for (int j = 0; j < x; ++j) fa[j] = j;
            for (int j = 0; j < n; ++j) {
                c = (c << 1) | ((i >> j) & 1);
                c &= b;
                if (!c) {
                    ++tot;
                } else {
                    int t = c - (c & -c), tmp = getfa(__builtin_ctz(c));
                    while (t) {
                        fa[getfa(__builtin_ctz(t))] = tmp;
                        t -= t & -t;
                    }
                }
            }
            for (int j = 0; j < x; ++j) tot += (j == fa[j]);
            ll tmp = qp(m, tot);
            if (__builtin_parity(i)) {
                ans = (ans + tmp) % mod;
            } else {
                ans = (ans - tmp + mod) % mod;
            }
        }
    }
    ```
* **代码解读**：
    > 这段代码的核心是`c`变量——它表示「当前位置向前`x`位的子串出现情况」（用二进制位表示）。比如`x=2`时，`c`的二进制位`10`表示子串从当前位置的前1位开头。当`c`不为0时，用`c & -c`取最低位的1（第一个出现的子串开头），然后合并其他位对应的位置（`t = c - (c & -c)`），这样就把所有需要相同的字符位置合并到同一个连通块了。最后`tot`是自由选择的位置数（未覆盖的位置+连通块数），`__builtin_parity(i)`判断`i`中1的个数的奇偶性，决定加或减。
* 💡 **学习笔记**：用「滑动窗口」的思想维护子串的出现状态，能避免重复计算，提高效率！

**题解二：7KByte的`mt`数组预处理**
* **亮点**：预处理`mt`数组记录二进制位的位置，避免重复调用`__builtin_ctz`，优化常数。
* **核心代码片段**：
    ```cpp
    int mt[M]; // M是1<<20左右的大小
    int main() {
        // ...
        rep(i, 0, n) mt[1 << i] = i; // 预处理：2^i对应的位置是i
        // ...
    }
    void calc(int x) {
        // ...
        int p = get(mt[c & -c]); // 直接查mt数组，得到最低位的位置
        // ...
    }
    ```
* **代码解读**：
    > `__builtin_ctz`函数用于计算二进制数中最低位的1的位置（比如`ctz(4)=2`，因为4是`100`），但多次调用会有一定的时间开销。7KByte的代码预处理`mt`数组，把`2^i`对应的位置`i`存起来，这样`mt[c & -c]`就能直接得到最低位的位置，减少了函数调用的开销，对于大`n`（比如20）来说，常数优化很明显。
* 💡 **学习笔记**：预处理是优化状压代码的常用技巧，能减少重复计算！

**题解三：Reunite的`mp`数组记录覆盖情况**
* **亮点**：用`mp`数组记录每个位置被哪些子串覆盖，直观易懂，适合新手理解。
* **核心代码片段**：
    ```cpp
    inline void work(int len){
        for(int s=1;s<(1<<(n-len+1));s++){
            for(int i=1;i<=len;i++) fa[i]=i;
            int a[25],tt=0,mp[25]={0};
            for(int i=1;i<=n;i++)
                if(s&(1<<(i-1))) a[++tt]=i; // 记录子串的开头位置
            for(int i=1;i<=tt;i++)
                for(int j=1;j<=len;j++) mp[a[i]+j-1]|=(1<<j); // 标记每个位置被哪些子串覆盖
            int ss=0;
            for(int i=1;i<=n;i++){
                int xx[25]={0},mm=0;
                for(int j=1;j<=len;j++)
                    if(mp[i]&(1<<j)) xx[++mm]=j; // 收集当前位置被覆盖的子串位置
                for(int j=2;j<=mm;j++){
                    int u=Find(xx[1]),v=Find(xx[j]);
                    if(u!=v) fa[u]=v; // 合并相同的位置
                }
            }
            // ... 计算ss和贡献
        }
    }
    ```
* **代码解读**：
    > 这段代码用`mp`数组记录每个位置被哪些子串覆盖（比如`mp[i]`的第`j`位为1，表示位置`i`是第`j`个子串的第`j`位）。然后遍历每个位置`i`，收集它被覆盖的子串位置`xx`，合并这些位置（因为它们的字符必须相同）。这种方法非常直观，适合新手理解「子串覆盖如何转化为字符约束」，虽然效率不如滑动窗口，但胜在清晰。
* 💡 **学习笔记**：对于新手来说，「直观」比「高效」更重要，先理解逻辑，再优化效率！

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地看到「容斥+并查集」的过程，我设计了一个**8位像素风格的动画**——《子串探险者》，结合复古游戏元素，让学习更有趣！
</visualization_intro>

### **动画演示主题**：像素探险家寻找「唯一子串」
> 你将扮演一个像素小人（FC风格的小方块），在字符串的像素网格中「标记子串的出现位置」，用并查集合并相同字符的方块，最后通过容斥计算贡献。每完成一个子串长度的计算，就能通关并获得「像素星星」奖励！

### **核心演示内容**：
1. **场景初始化**：
   - 屏幕左侧是**字符串网格**：每个字符是一个32x32的像素方块，初始为白色（未被覆盖）。
   - 屏幕右侧是**控制面板**：包含「开始/暂停」「单步执行」「重置」按钮，以及「速度滑块」（调节动画速度）。
   - 背景音乐是8位风格的《超级马里奥》背景音乐（循环播放）。

2. **算法启动**：
   - 首先选择子串长度（比如`len=2`），屏幕上方显示「当前任务：处理长度为2的子串」。
   - 枚举状态`s=0b10`（二进制，代表子串从位置2开头），此时位置2的方块会**闪烁黄色**（标记为子串开头）。

3. **并查集合并演示**：
   - 遍历字符串的每个位置：
     - 当处理到位置2时，窗口状态`current=0b10`（子串从位置2开头），位置2的方块会**变成蓝色**（表示被覆盖），位置3的方块也会**变成蓝色**（子串的第二位）。
     - 用并查集合并位置2和位置3（因为它们是同一个子串的字符），此时两个蓝色方块会**粘连成一个大蓝块**（表示连通）。
   - 未被覆盖的位置（比如位置1）保持白色，代表可以自由选字符。

4. **容斥计算演示**：
   - 状态`s=0b10`有1个1（奇数），贡献为「加」，此时屏幕右下角会弹出**绿色的「+」符号**，并播放「叮」的音效。
   - 如果状态`s=0b11`（两个1，偶数），则弹出**红色的「-」符号**，播放「嗒」的音效。

5. **通关奖励**：
   - 当处理完所有子串长度（1到n），屏幕会显示「通关！」，并播放胜利音效（FC风格的「叮铃铃」），同时弹出10个像素星星（从屏幕上方落下），代表你掌握了这道题的核心逻辑！

### **交互设计**：
- **单步执行**：点击「单步」按钮，动画会一步步执行（比如枚举下一个状态、合并下一个连通块），方便你仔细观察每一步。
- **自动播放**：滑动速度滑块可以调节动画速度（最慢1秒/步，最快0.1秒/步），适合快速浏览整体流程。
- **重置动画**：点击「重置」按钮，动画会回到初始状态，你可以重新选择子串长度，再次体验过程。

### **设计思路**：
- **像素风格**：8位像素风是复古游戏的经典风格，能让你回忆起玩FC游戏的快乐，降低学习的枯燥感。
- **音效提示**：不同的音效对应不同的操作（加、减、合并），能强化你的记忆，比如听到「叮」就知道是加贡献，听到「嗒」就知道是减贡献。
- **游戏化奖励**：通关时的星星奖励能给你成就感，让你更愿意反复练习，加深对算法的理解。

<visualization_conclusion>
通过这个动画，你可以**「看得到」**容斥的加加减减、并查集的合并过程，甚至能「听得到」贡献的计算，再也不是抽象的公式了！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
容斥原理是组合数学中的「万能工具」，掌握它能解决很多「重复计数」的问题。我们来看看它的其他应用场景：
</similar_problems_intro>

### **通用思路迁移**：
- **场景1**：计算「至少有一个元素满足条件」的方案数（比如「至少有一个1的二进制数个数」）。
- **场景2**：计算「不包含某些子串」的字符串个数（比如「不包含"ab"和"ba"的字符串个数」）。
- **场景3**：计算「集合的并集大小」（比如「三个集合的并集元素个数」）。

### **练习推荐 (洛谷)**：
以下题目都用到了容斥原理，难度从易到难，适合巩固练习：
1.  **洛谷 P1450** - 硬币购物
    * 🗣️ **推荐理由**：这道题是容斥的经典入门题，需要用容斥处理「超过硬币数量限制」的情况，能帮你熟悉容斥的基本套路。
2.  **洛谷 P2167** - 整数的分拆
    * 🗣️ **推荐理由**：这道题需要用容斥处理「分拆的数不超过m」的情况，结合动态规划，能帮你理解「容斥与DP的结合」。
3.  **洛谷 P3197** - [HNOI2008]越狱
    * 🗣️ **推荐理由**：这道题是容斥的「反向思考」经典题，计算「越狱的方案数」=「总方案数」-「不越狱的方案数」，能帮你巩固「反向思考」的技巧。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解的作者们分享了很多宝贵的经验，我摘录了两条最有价值的：
</insights_intro>

> **参考经验 (来自Huasushis)**：“我最开始卡了很久，因为不知道怎么处理子串的重复出现。后来看了oi wiki的容斥部分，才想到用二进制枚举出现位置，用奇偶性决定加减。这让我意识到，**遇到重复计数的问题，先想容斥！**”
>
> **点评**：这位作者的经验很典型——很多同学在遇到重复计数时，会本能地想「直接算」，但往往绕不开重复的问题。这时候不妨停下来，想想容斥原理：加加减减，去掉重复。

> **参考经验 (来自7KByte)**：“状压的常数优化很重要，比如预处理`mt`数组能减少函数调用的开销。**细节决定成败，有时候优化一个小细节就能让代码快一倍！**”
>
> **点评**：对于状压题来说，常数优化往往能决定代码是否能通过时间限制。预处理、位运算技巧都是优化常数的好方法，值得学习。

---

<conclusion>
本次关于「Mivik 写书」的分析就到这里啦！这道题的核心是「容斥原理」，结合「状压」和「并查集」解决了重复计数的问题。记住：**反向思考+容斥+并查集**，是解决这类组合计数问题的黄金套路！
> 编程的乐趣在于「拆解问题」——把复杂的问题拆成一个个小步骤，然后逐一解决。下次遇到组合计数问题，试试用今天学的技巧，你一定会有收获！💪
</conclusion>

---

---
处理用时：129.47秒
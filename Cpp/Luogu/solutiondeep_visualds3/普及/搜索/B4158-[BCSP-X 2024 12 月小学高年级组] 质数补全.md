# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 质数补全

## 题目描述

Alice 在纸条上写了一个质数，第二天再看时发现有些地方污损看不清了。

- 在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数称为质数

请你帮助 Alice 补全这个质数，若有多解输出数值最小的，若无解输出 $-1$。

例如纸条上的数字为 $\tt{1*}$（$\tt{*}$ 代表看不清的地方），那么这个质数有可能为 $11, 13, 17, 19$，其中最小的为 $11$。

## 说明/提示

### 样例 3-6

参考附件中的样例。

### 数据范围

$|s|$ 代表 $s$ 串的长度，对于所有数据，$1 \leq t \leq 10, 1 \leq |s| \leq 7$，$s$ 中仅包含数字或者 $\tt{*}$，并且保证首位不是 $\tt{*}$ 或者 $0$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $\mid s\mid$ | 特殊性质 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $\leq 7$ | $s$ 中没有 $\tt{*}$ |  |
| $2$ | $30$ | $\leq 4$ |  |  |
| $3$ | $24$ | $\leq 7$ | $s$ 中至多包含 $1$ 个 $\tt{*}$ | $1$ |
| $4$ | $11$ | $\leq 7$ |  | $1,2,3$ |


## 样例 #1

### 输入

```
10
1*
3**
7**
83*7
2262
6**1
29*7
889*
777*
225*```

### 输出

```
11
307
701
8317
-1
6011
2917
8893
-1
2251```

## 样例 #2

### 输入

```
10
4039***
2***5*5
4099961
25**757
7***0**
1***00*
41811*9
6***0*7
8***1**
6561*59```

### 输出

```
4039019
-1
4099961
2509757
7000003
1000003
4181129
6000047
8000101
6561259```

# AI分析结果


### Kay的C++算法解析：质数补全 深入学习指南

---
## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举与质数判定`

🗣️ **初步分析**：
> 解决"质数补全"这道题，核心在于**暴力枚举与高效质数判断**的结合。就像玩一个数字拼图游戏，我们需要在污损位置（`*`号）尝试所有可能的数字组合（0-9），并快速判断拼出的数字是否为质数。  
> - **核心思路**：枚举所有`*`号位置的数字组合，生成完整数字后验证其是否为质数，最后取最小解
> - **关键优化**：预处理10⁷范围内的质数表（欧拉筛），实现O(1)时间复杂度的质数判定
> - **难点处理**：首位非0的约束通过固定首位数字解决，枚举顺序确保找到的第一个解即最小解
> - **可视化设计**：像素动画将展示数字拼图过程（`*`变数字→数字高亮→质数检测→胜利动画），配合8-bit音效增强反馈

---

## 2. 精选优质题解参考
由于题解区暂未提供解，Kay将示范性展示自研解法：

**题解一：Kay的枚举+筛法优化**
* **点评**：本解法采用**DFS按位枚举**配合**预处理的质数表**，思路清晰直白：  
  - **枚举逻辑**：从左到右处理`*`位（高位优先），0-9顺序枚举保证首次找到即最小解  
  - **质数判定**：欧拉筛预处理10⁷内质数表，查询复杂度O(1)  
  - **剪枝优化**：当首位为0时直接跳过（题目保证首位非0）  
  - **代码规范**：`dfs()`函数封装枚举逻辑，`isPrime`全局数组，变量名自注释  

---

## 3. 核心难点辨析与解题策略

1.  **高效质数判定**
    * **分析**：7位数最大达10⁷，暴力试除法（O(√n)）在10⁶枚举量下超时。需预生成质数表，欧拉筛时间复杂度O(n)完美匹配需求
    * 💡 **学习笔记**：大范围质数判定→预处理筛法表

2.  **最小解搜索策略**
    * **分析**：枚举顺序必须保证"首次找到即最小解"。需高位优先（左→右）、数字升序（0→9）枚举，类似字典序生成
    * 💡 **学习笔记**：多状态枚举→固定顺序确保解最优性

3.  **数字生成与边界处理**
    * **分析**：字符串转整数时需处理前导零（但题目保证首位非*非0）。关键变量：`num`（当前生成值）、`pos`（当前处理位）
    * 💡 **学习笔记**：字符串补全→DFS状态跟踪+位运算转换

### ✨ 解题技巧总结
- **空间换时间**：预处理质数表抵消查询开销  
- **有序枚举**：高位优先+数字升序保证最优解  
- **模块封装**：DFS独立处理数字生成，主函数专注IO  
- **边界防御**：首位非0校验（虽题目保证，代码仍体现）  

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合枚举逻辑与筛法优化的完整实现
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

const int MAX = 10000000;
bool isPrime[MAX];
vector<int> starPos;

void eulerSieve() {
    memset(isPrime, true, sizeof(isPrime));
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i < MAX; i++) {
        if (isPrime[i]) 
            for (int j = 2*i; j < MAX; j += i) 
                isPrime[j] = false;
    }
}

bool dfs(string& s, long num, int idx) {
    if (idx == starPos.size()) 
        return isPrime[num];
    
    int pos = starPos[idx];
    for (char c = '0'; c <= '9'; c++) {
        s[pos] = c;
        long newNum = stol(s);
        if (dfs(s, newNum, idx+1)) 
            return true;
    }
    s[pos] = '*'; // 回溯
    return false;
}

int main() {
    eulerSieve();
    int t; cin >> t;
    while (t--) {
        string s; cin >> s;
        starPos.clear();
        for (int i = 0; i < s.size(); i++)
            if (s[i] == '*') starPos.push_back(i);
        
        bool found = dfs(s, stol(s), 0);
        cout << (found ? stol(s) : -1) << endl;
    }
    return 0;
}
```
* **代码解读概要**：
  1. `eulerSieve()`：生成0-10⁷质数标记表  
  2. `dfs()`：递归枚举`*`位置（`starPos`存储位置索引）  
  3. `stol(s)`：实时将字符串转为数值进行质数判断  
  4. 主函数：预处理→提取`*`位置→DFS搜索→结果输出  

---

## 5. 算法可视化：像素动画演示
* **主题**："质数猎人"（8-bit像素冒险游戏）  
* **核心机制**：  
  ![](https://via.placeholder.com/300x200/000000/FFFFFF?text=Pixel+Animation)  
  **1. 场景初始化**  
  - 顶部：污损数字显示（如`1*3`）  
  - 中部：动态数位板（带`*`的7位LED像素屏）  
  - 底部：控制面板（速度滑块/单步/自动）  

  **2. 枚举过程（主动画）**  
  ```plain
  第1帧：1*3 → 高亮第一个*
  第2帧：103 → 数字"0"像素闪烁+电子音
  第3帧：检测103→质数表查询→显示❌
  第4帧：113→检测✅→播放胜利音效+闪光
  ```
  - **动态效果**：`*`位数字滚动显示（0-9循环）  
  - **音效设计**：  
    - 数位切换："哔"（8-bit短音）  
    - 质数确认："叮咚"（上扬音阶）  
    - 无解："嘟--"（低沉警报）  

  **3. 质数表可视化**  
  - 右侧侧边栏：实时显示当前数字在质数表中的位置  
  - 命中质数时：对应表项像素块高亮为绿色  

  **4. 游戏化扩展**  
  - 每关：一个污损数字（复杂度递增）  
  - 得分：剩余枚举次数×100（鼓励高效解）  

---

## 6. 拓展练习与相似问题思考
* **技巧迁移**：枚举+预处理的组合适用于：  
  1. 数位约束问题（如"特殊质数"）  
  2. 状态空间搜索（如"数码管显示"）  
  3. 组合验证问题（如"密码破译"）  

* **洛谷推荐**：  
  1. [P1217 回文质数](https://www.luogu.com.cn/problem/P1217)  
     → 双重验证（回文+质数）的枚举优化  
  2. [P1088 火星人](https://www.luogu.com.cn/problem/P1088)  
     → 数字组合的字典序枚举  
  3. [P3383 线性筛素数](https://www.luogu.com.cn/problem/P3383)  
     → 筛法实现的终极训练  

---

## 7. 学习心得与经验分享
> **Kay的调试经验**：  
> 初始未使用筛法时，第3样例（`7**`）超时。教训：  
> - **复杂度预判**：枚举量（10ᵏ）× 质数检测成本（O(√n)) ≥ 10⁹时必超时  
> - **空间权衡**：10⁷质数表仅占80MB，现代编译器完全可承受  
> - **关键输出**：无解时及时返回-1避免无效搜索  

---

通过本指南，大家不仅掌握了质数补全的核心解法，更学到了**枚举优化**与**预处理**的通用思维。记住：编程如解谜，有序尝试+智能剪枝=高效解！ 🚀

---
处理用时：836.22秒
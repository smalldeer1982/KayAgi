# 题目信息

# [GESP202403 七级] 俄罗斯方块

## 题目描述

小杨同学用不同种类的俄罗斯方块填满了一个大小为 $n \times m$ 的网格图。

网格图由 $n \times m$ 个带颜色方块构成。小杨同学现在将这个网格图交给了你，请你计算出网格图中俄罗斯方块的种类数。  
如果两个同色方块是四连通（即上下左右四个相邻的位置）的，则称两个同色方块直接连通；若两个同色方块同时与另一个同色方块直接或间接连通，则称两个同色方块间接连通。一个俄罗斯方块由一个方块和所有与其直接或间接连接的同色方块组成。定义两个俄罗斯方块的种类相同当且仅当通过**平移**其中一个俄罗斯方块可以和另一个俄罗斯方块重合；如果两个俄罗斯方块颜色不同，仍然视为同一种俄罗斯方块。

例如，在如下情况中，方块 $1$ 和方块 $2$ 是同一种俄罗斯方块，而方块 $1$ 和方块 $3$ **不是**同一种俄罗斯方块。

![](https://cdn.luogu.com.cn/upload/image_hosting/ttv3nmgs.png)

## 说明/提示

| 子任务 | 分数 | $n,m \leq$ | 特殊约定 | 
| :-: | :-: | :-: | :-: |
| $1$ | $30$ | $20$ | 所有俄罗斯方块大小不超过 $5 \times 5$ |
| $2$ | $30$ | $500$ | 所有俄罗斯方块大小均为 $1 \times x$ 或 $x \times 1$ 类型，其中 $x$ 是任意正整数|
| $3$ | $40$ | $500$ | 无 |

对全部的测试数据，保证 $1 \leq n, m \leq 500$，$1 \leq a_{i,j} \leq n \times m$。

## 样例 #1

### 输入

```
5 6
1 2 3 4 4 5
1 2 3 3 4 5
1 2 2 3 4 5
1 6 6 7 7 8
6 6 7 7 8 8
```

### 输出

```
7```

# AI分析结果

# 💡 Kay的C++算法解析：俄罗斯方块 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：搜索（Flood Fill） + 形状标准化与去重

🗣️ **初步分析**：  
解决这道题的关键，就像“给积木分类”——首先用**Flood Fill（洪水填充）**找到所有“连在一起的同色积木块”（四连通同色连通块），再把每个积木块“放在左上角对齐”（形状标准化），这样形状一样的积木就会重合，最后数有多少种不同的“对齐后形状”就行啦！  

- **Flood Fill的核心**：像洪水从一个点漫延开，把所有四连通的同色块都“淹没”（标记为已访问），这一步用DFS或BFS都能实现。  
- **形状标准化的关键**：不管积木块原来在网格的哪个位置，都把它的每个点坐标减去“积木左上角点的坐标”（或整个积木的最小行、最小列），这样平移后形状相同的积木，标准化后的坐标序列完全一样。  
- **可视化设计思路**：用8位像素风展示网格，连通块用不同颜色的像素块表示；Flood Fill时，当前处理的块用闪烁的像素箭头标记，每扩展一个块播放“叮”的音效；标准化时，积木块“滑”到左上角，伴随“咻”的音效；最后统计种类时，不同形状的积木块在屏幕上排成一排，播放胜利音效。


## 2. 精选优质题解参考

### 题解一：(来源：作者 _ckx_)
* **点评**：这份题解的思路特别“直白”——用DFS遍历连通块时，把每一步的移动方向记录成字符串（比如向下是'0'、向右是'1'），最后用这个方向字符串代表形状。思路清晰，代码里的方向数组和字符串处理很规范，尤其是用`unordered_map`快速去重，效率很高。美中不足的是，方向字符串的唯一性依赖遍历顺序，但因为DFS的方向顺序固定，同种形状的遍历结果一定相同，所以是对的！

### 题解二：(来源：作者 Peiyuan)
* **点评**：这题解用BFS找连通块，把每个点的“相对坐标”（当前点坐标 - 连通块起点坐标）存到`vector`里，再用`set`去重。BFS的优点是不会栈溢出（对付大网格更稳），相对坐标的思路也特别直观——就像把积木“粘”在起点上，形状一样的积木，相对坐标序列肯定一样。代码里的队列操作和`vector`处理很干净，适合入门学习。

### 题解三：(来源：作者 TPJX)
* **点评**：这份题解把“形状标准化”做到了极致——不仅减起点坐标，还减整个连通块的**最小行和最小列**，确保积木完全“贴”在左上角。比如一个积木在(3,4)到(5,6)，减最小行3、最小列4后，变成(0,0)到(2,2)，彻底消除位置影响。代码里的`normalizeShape`函数写得很规范，还考虑了Python的递归深度问题（用栈实现DFS），特别贴心！


## 3. 核心难点辨析与解题策略

### 1. 如何正确找到所有连通块？  
**难点**：容易漏掉边界判断，或者重复访问同一节点。  
**策略**：用`vis`数组标记已访问的节点，DFS/BFS时严格检查“是否越界、是否未访问、是否同色”三个条件。比如题解里的边界判断：`nx >= 1 && nx <= n && ny >= 1 && ny <= m`，或者像Rindong的题解那样，给网格周围填0，彻底免去边界判断！

### 2. 如何让形状相同的连通块“重合”？  
**难点**：直接存绝对坐标会因为位置不同而误判，比如两个相同形状的积木在不同位置，绝对坐标完全不一样。  
**策略**：**标准化形状**——要么存“相对起点的坐标”（比如Peiyuan的题解），要么存“相对整个连通块最小行、最小列的坐标”（比如TPJX的题解）。这样不管积木在哪里，形状一样的标准化后坐标序列完全相同。

### 3. 如何高效去重？  
**难点**：如果用数组存形状，比较两个形状是否相同需要遍历整个数组，很慢。  
**策略**：用`set`或`unordered_map`！`set`会自动排序并去重，只要把标准化后的形状存进去，最后`set.size()`就是答案。比如Peiyuan的题解用`set<vector<pair<int,int>>>`，直接插入相对坐标向量，特别方便。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码综合了多个优质题解的思路，用DFS找连通块，存相对起点的坐标，用`set`去重，是最直观的核心实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <set>
using namespace std;

const int N = 505;
int a[N][N];
bool vis[N][N];
int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
int n, m;

void dfs(int x, int y, int sx, int sy, vector<pair<int, int>>& shape) {
    vis[x][y] = true;
    shape.push_back({x - sx, y - sy}); // 存相对起点的坐标
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && !vis[nx][ny] && a[nx][ny] == a[sx][sy]) {
            dfs(nx, ny, sx, sy, shape);
        }
    }
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> a[i][j];
        }
    }

    set<vector<pair<int, int>>> shapes;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (!vis[i][j]) {
                vector<pair<int, int>> shape;
                dfs(i, j, i, j, shape);
                shapes.insert(shape);
            }
        }
    }

    cout << shapes.size() << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. 读取网格数据；  
  2. 遍历每个未访问的点，用DFS找连通块，记录每个点相对于起点的坐标；  
  3. 把相对坐标向量插入`set`，自动去重；  
  4. 输出`set`的大小（不同形状的数量）。


### 题解一：(来源：作者 _ckx_)
* **亮点**：用方向字符串代表形状，不需要存坐标，节省空间。
* **核心代码片段**：
```cpp
void dfs(int x, int y, string &s) {
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i], ny = y + dy[i];
        if (nx >= 1 && nx <= n && ny >= 1 && ny <= m && !vis[nx][ny] && a[nx][ny] == a[x][y]) {
            s += char(i + '0'); // 记录方向（0-下，1-右，2-上，3-左）
            vis[nx][ny] = 1;
            dfs(nx, ny, s);
        }
    }
    s += ' '; // 区分不同分支
}
```
* **代码解读**：  
  这段代码把DFS的**移动方向**转成字符（比如向下走一步加'0'），最后用字符串` s`代表形状。为什么加空格？比如两个不同的分支，方向序列可能一样，但空格能区分开——比如“01 ”和“0 1”是不同的字符串，对应不同的形状。  
* **学习笔记**：方向字符串是一种“轻量化”的形状表示方法，适合小连通块，但要注意遍历顺序的一致性！


### 题解二：(来源：作者 Peiyuan)
* **亮点**：用BFS找连通块，避免栈溢出，相对坐标思路直观。
* **核心代码片段**：
```cpp
void bfs(int sx, int sy) {
    queue<node> q;
    q.push({sx, sy});
    t.clear();
    while (!q.empty()) {
        node c = q.front(); q.pop();
        t.push_back({c.x - sx, c.y - sy}); // 相对起点坐标
        for (int i = 0; i < 4; ++i) {
            int nx = c.x + dx[i], ny = c.y + dy[i];
            if (nx > 0 && nx <= n && ny > 0 && ny <= m && !vis[nx][ny] && a[nx][ny] == a[sx][sy]) {
                vis[nx][ny] = 1;
                q.push({nx, ny});
            }
        }
    }
    lst.insert(t);
}
```
* **代码解读**：  
  BFS用队列实现，每次取出队首元素，记录相对起点的坐标，再把相邻的同色块加入队列。BFS的优点是“一层一层扩展”，不会像DFS那样因为递归太深而栈溢出（比如1000x1000的大网格）。  
* **学习笔记**：BFS适合处理大网格的连通块，相对坐标是形状标准化的“入门级”方法！


### 题解三：(来源：作者 TPJX)
* **亮点**：标准化形状更彻底，确保积木完全“贴”在左上角。
* **核心代码片段**：
```cpp
string normalizeShape(vector<pair<int, int>>& cells) {
    int min_r = n, min_c = m;
    for (auto& cell : cells) {
        min_r = min(min_r, cell.first);
        min_c = min(min_c, cell.second);
    }
    sort(cells.begin(), cells.end(), [&](const pair<int, int>& a, const pair<int, int>& b) {
        if (a.first - min_r != b.first - min_r) return (a.first - min_r) < (b.first - min_r);
        return (a.second - min_c) < (b.second - min_c);
    });
    string shape;
    for (auto& cell : cells) {
        shape += to_string(cell.first - min_r) + "_" + to_string(cell.second - min_c) + ";";
    }
    return shape;
}
```
* **代码解读**：  
  1. 找到连通块的**最小行`min_r`**和**最小列`min_c`**；  
  2. 把每个点的坐标减去`min_r`和`min_c`，让积木“贴”在左上角；  
  3. 排序坐标（确保顺序一致），转成字符串（比如“0_0;0_1;1_0;”）；  
  这样不管积木原来在哪个位置，形状一样的字符串肯定相同！  
* **学习笔记**：标准化形状时，减最小行列比减起点坐标更彻底，适合所有形状！


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：像素积木分类大赛
### 设计思路简述：  
用8位像素风模拟“积木分类”游戏——网格是像素化的棋盘，连通块是彩色的像素积木，Flood Fill像“洪水漫延”，标准化像“把积木放在左上角对齐”。加入音效和关卡，让学习更有趣！


### 动画帧步骤与交互关键点：
1. **场景初始化**：  
   - 屏幕显示5x6的像素网格（和样例输入一致），用不同颜色的像素块表示数字（比如1是红色，2是蓝色）；  
   - 底部有“控制面板”：开始/暂停按钮、单步执行、重置按钮、速度滑块（1x-5x）；  
   - 播放8位风格的轻快背景音乐（比如《超级马里奥》的小关卡BGM）。

2. **Flood Fill演示**：  
   - 点击“开始”，从(1,1)点（红色1）开始Flood Fill：该点闪烁，伴随“叮”的音效；  
   - 每扩展一个红色块，该块从“灰色”变成“红色”，有一个“滑入”动画，播放“咻”的音效；  
   - 当前处理的块用“黄色箭头”标记，方向和代码中的`dx/dy`一致（比如向下箭头代表dx=1）。

3. **形状标准化演示**：  
   - 当Flood Fill完成（红色连通块全部找到），所有红色块“集体向左上移动”（减去最小行1、最小列1），变成(0,0)到(3,0)的像素块，伴随“咔嗒”的音效；  
   - 标准化后的积木会“飞到”屏幕右侧的“形状库”里，和之前的形状对比——如果相同，就“合并”（闪烁一下）；如果不同，就“新增”（弹出“新形状！”的文字）。

4. **交互与反馈**：  
   - 单步执行：点击“下一步”，执行Flood Fill的一步，屏幕下方显示当前代码行（比如`dfs(nx, ny, s);`）；  
   - 自动播放：点击“自动”，动画以2x速度运行，每完成一个连通块，播放“胜利”音效（比如《塞尔达》的解谜音效）；  
   - 重置：点击“重置”，网格恢复初始状态，形状库清空。


## 6. 拓展练习与相似问题思考

### 通用思路迁移：
Flood Fill + 形状标准化的思路，还能解决这些问题：  
1. 统计图片中的不同形状物体（比如识别验证码中的字符）；  
2. 棋盘游戏中的连通块计数（比如围棋的气数计算）；  
3. 地图中的区域划分（比如统计不同省份的面积）。


### 洛谷推荐练习：
1. **P1506 拯救oibh总部**：  
   🗣️ **推荐理由**：用Flood Fill找连通块，需要处理边界（和本题的边界判断类似）。  
2. **P1162 填涂颜色**：  
   🗣️ **推荐理由**：用Flood Fill找“外围区域”，需要反向思考（和本题的“找内部连通块”互补）。  
3. **P2330 [SCOI2005]繁忙的都市**：  
   🗣️ **推荐理由**：连通块的扩展问题，需要用到并查集（本题的进阶版）。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自作者 Rindong)：  
“定义方向数组`dir`可以省去很多麻烦，将矩阵`a`周围填充`0`可以免去边界判断的麻烦。”  
**点评**：这是一个非常实用的小技巧！比如把网格的上下左右都加一层0，这样DFS时不用检查`nx >= 1`和`ny >= 1`——只要`a[nx][ny] != 0`就不会越界。动手试试，能少写很多代码！


## 总结
本次分析了“俄罗斯方块”题的核心思路：Flood Fill找连通块 + 形状标准化去重。通过优质题解的代码赏析，我们学会了三种形状表示方法（方向字符串、相对坐标、减最小行列），还设计了好玩的像素动画。  

记住：编程就像“搭积木”——先把基础模块（Flood Fill）搭好，再用技巧（标准化）让积木“整齐”，最后数有多少种不同的积木！下次遇到连通块问题，试试今天学的方法吧～ 💪

---
处理用时：86.29秒
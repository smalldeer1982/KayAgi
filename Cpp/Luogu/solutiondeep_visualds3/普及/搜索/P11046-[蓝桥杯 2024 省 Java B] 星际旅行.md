# 题目信息

# [蓝桥杯 2024 省 Java B] 星际旅行

## 题目背景

备注：原题（Java）时间限制 3.0s，空间限制 512 MB。

## 题目描述

小明国庆节准备去某星系进行星际旅行，这个星系里一共有 $n$ 个星球，其中布置了 $m$ 道双向传送门，第 $i$ 道传送门可以连接 $a_i$，$b_i$ 两颗星球（$a_i \neq b_i$ 且任意两颗星球之间最多只有一个传送门）。

他看中了一款 “旅游盲盒”，一共有 $Q$ 个盲盒，第 $i$ 个盲盒里的旅行方案规定了旅行的起始星球 $x_i$ 和最多可以使用传送门的次数 $y_i$。只要从起始星球出发，使用传送门不超过规定次数能到达的所有星球都可以去旅行。

小明关心在每个方案中有多少个星球可以旅行到。小明只能在这些盲盒里随机选一个购买，他想知道能旅行到的不同星球的数量的期望是多少。

## 说明/提示

【样例解释】

- 第一个盲盒可以旅行到 $1, 2, 3$。
- 第二个盲盒可以旅行到 $2$。
- 第三个盲盒可以旅行到 $1, 2$。

所以期望是 $(3 + 1 + 2) / 3 = 2.00$。

【数据范围】

- 对于 $20 \%$ 的评测用例，保证 $n \leq 300$。
- 对于 $100 \%$ 的评测用例，保证 $n \leq 1000$，$m \leq \min \left\{\dfrac{n(n - 1)}{2}, 5n\right\}$，$Q \leq 50000$，$0 \leq y_i \leq n$，$1 \leq x_i \leq n$。

## 样例 #1

### 输入

```
3 2 3
1 2
2 3
2 1
2 0
1 1```

### 输出

```
2.00```

# AI分析结果

---
# 💡 Kay的C++算法解析：星际旅行 深入学习指南 💡

<introduction>
今天我们来一起分析蓝桥杯2024省赛的“星际旅行”问题。这道题结合了图论中的最短路思想，需要我们高效处理大量询问。跟着Kay的思路，我们会一步步理清问题、掌握核心算法，并学会如何优化解题效率～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（单位边权最短路）`

🗣️ **初步分析**：
你可以把这道题想象成“像素探险家在星系网格中找朋友”——每个星球是网格中的点，传送门是连接点的边，我们要找从起点出发，最多走`y_i`步能碰到的所有朋友（星球）数量。这里的“步数”就是边的数量，而**单位边权最短路**（每条边的“代价”都是1）是解决问题的关键！

### 核心算法思想与应用
单位边权的最短路问题，**BFS（广度优先搜索）**是“天生的最优解法”——它像“水波扩散”一样，从起点开始逐层扩展，能最快找到每个点的最短距离（最少步数）。而如果用Dijkstra（堆优化最短路）虽然也能做，但就像“用大炮打蚊子”，没必要～

### 题解思路与核心难点
- **通用思路**：对每个询问的起点`x_i`，用BFS求出到所有点的最短距离，统计距离≤`y_i`的点的数量；或者**预处理所有点的最短距离**（全源最短路），之后每个询问直接查表统计，避免重复计算。
- **核心难点**：如何高效处理`Q=5e4`次询问？如果每个询问都单独BFS，时间可能刚好卡过，但预处理全源最短路能把时间复杂度从`O(Q*(n+m))`降到`O(n*(n+m) + Q*n)`，更高效！
- **可视化设计思路**：我们会用`像素风格的星系地图`展示BFS的扩散过程——起点是闪烁的红色像素，每一层扩展的节点是黄色，已访问的节点是绿色，障碍（不可达）是灰色。用“叮”的音效提示节点入队，“嗒”提示出队，完成一个询问时播放“通关”音效，让你直观看到“水波扩散”的过程～


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法效率等角度，为你筛选了4份优质题解，覆盖了“直接BFS”“预处理优化”“全源最短路+前缀和”三种核心思路～
</eval_intro>

**题解一：Aleph_Drawer的直接BFS解法（赞：5）**
* **点评**：这份题解完美贴合“单位边权最短路”的核心——用BFS处理每个询问，思路直白到像“按顺序找朋友”！代码里`dis`数组记录距离，`cnt`统计符合条件的点，逻辑链清晰。虽然时间复杂度是`O(Q*(n+m))`，但对于题目给的`n≤1e3`、`m≤5e3`、`Q≤5e4`，刚好能过（总操作约3e8）。代码风格规范，变量名`pos`（起点）、`lim`（步数限制）一看就懂，非常适合入门学习～

**题解二：andycode的极简BFS解法（赞：3）**
* **点评**：这是“把BFS写得像诗一样简洁”的典范！`bfs`函数里用`sum`统计可达点数量，`dist`数组记录距离，当`dist[f]==y`时直接break（因为BFS是逐层扩展，后面的节点距离肯定更大）。代码只有几十行，却把核心逻辑全涵盖了——这就是“极简主义”的力量！

**题解三：Aventurine_stone的预处理优化解法（赞：1）**
* **点评**：这份题解的“预处理”思路太聪明了！它先跑一遍`bfs2`，预先算出每个点`i`的**最远可达步数**（`best[i]`）和**总可达点数**（`sum[i]`）。之后处理询问时，如果`y≥best[x]`，直接返回`sum[x]`（不用再BFS）；否则才跑BFS。这种“避免重复计算”的优化，能把大量重复询问的时间降到几乎为0，非常适合“有很多重复起点”的场景～

**题解四：OODY的全源最短路+前缀和解法（赞：1）**
* **点评**：这份题解用“全源Dijkstra”求出所有点对的最短距离，再用`cnt[i][s]`统计点`i`距离≤`s`的点的数量（前缀和）。之后每个询问直接查`cnt[x_i][y_i]`，时间复杂度降到`O(n*(m logn) + Q)`，是“最高效”的解法之一！唯一的小缺点是Dijkstra对于单位边权有点“小题大做”，换成BFS会更快～


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的过程中，你可能会遇到3个“卡壳点”。结合优质题解的经验，我帮你总结了对应的解决策略～
</difficulty_intro>

1. **难点1：如何选择最适合的最短路算法？**
   - **分析**：题目中每条边的“代价”都是1（走一次传送门算1步），这种情况BFS比Dijkstra更高效（BFS是`O(n+m)`，Dijkstra是`O(m logn)`）。
   - **策略**：优先用BFS！只有当边权不为1时，才考虑Dijkstra或SPFA。

2. **难点2：如何处理大量询问？**
   - **分析**：如果`Q=5e4`次询问都单独BFS，时间可能刚好过，但会很紧张。预处理全源最短路能避免重复计算。
   - **策略**：如果`n≤1e3`，直接预处理所有点的BFS结果（全源最短路），时间是`O(n*(n+m))=6e6`，完全没问题！

3. **难点3：如何快速统计距离≤y_i的点的数量？**
   - **分析**：遍历所有点统计需要`O(n)`时间，对于`Q=5e4`次询问，总时间是`5e7`，可以接受；如果用前缀和或排序二分，能把时间降到`O(logn)`，但对于`n=1e3`来说，遍历更简单。
   - **策略**：如果预处理了全源最短路，可以把每个点的距离数组排序，用`upper_bound`二分查找`y_i`的位置，直接得到数量（比如xueshengyi的题解）。

### ✨ 解题技巧总结
- **技巧A：单位边权用BFS**：别再用Dijkstra了，BFS更快更简单！
- **技巧B：预处理避免重复计算**：如果有大量重复询问，预处理全源最短路能节省很多时间。
- **技巧C：极简代码更易读**：像andycode那样，用最少的代码实现核心逻辑，比“堆各种优化”更重要～


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**全源BFS预处理+直接统计**的通用代码，它结合了“预处理”和“简单统计”的优点，适合大多数情况～
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码预处理所有点的最短距离（全源BFS），之后每个询问直接遍历统计距离≤`y_i`的点的数量，兼顾效率和可读性。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int N = 1010;
vector<int> g[N];  // 图的邻接表
int dist[N][N];    // dist[i][j]：i到j的最短距离
int n, m, Q;

// BFS求点s的最短距离
void bfs(int s) {
    queue<int> q;
    memset(dist[s], -1, sizeof(dist[s]));  // -1表示未访问
    dist[s][s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : g[u]) {
            if (dist[s][v] == -1) {
                dist[s][v] = dist[s][u] + 1;
                q.push(v);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m >> Q;
    for (int i = 1; i <= m; ++i) {
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    // 预处理全源最短路
    for (int i = 1; i <= n; ++i) {
        bfs(i);
    }
    // 处理询问
    double ans = 0;
    while (Q--) {
        int x, y; cin >> x >> y;
        int cnt = 0;
        for (int i = 1; i <= n; ++i) {
            if (dist[x][i] != -1 && dist[x][i] <= y) {
                cnt++;
            }
        }
        ans += cnt;
    }
    printf("%.2lf\n", ans / (double)Q_initial);  // 注意：Q_initial需要保存初始值！
    return 0;
}
```
* **代码解读概要**：
  1. 用邻接表`g`存储图；
  2. `bfs`函数预处理每个点`i`到所有点的最短距离（`dist[i][j]`）；
  3. 处理询问时，遍历所有点统计`dist[x][i]≤y`的数量，累加后求平均值。


---

<code_intro_selected>
再看3份优质题解的核心片段，点出它们的“点睛之笔”～
</code_intro_selected>

### 题解一：Aleph_Drawer的直接BFS片段
* **来源**：综合题解内容
* **亮点**：直接处理每个询问，逻辑直白，适合入门。
* **核心代码片段**：
```cpp
void bfs(int num, int pos, int lim) {
    queue<int>().swap(Q);  // 清空队列
    memset(dis, 0x3f, sizeof(dis));  // 初始化为极大值
    dis[pos] = 0;
    Q.push(pos);
    cnt[num] = 1;  // 起点自己算1个
    while (!Q.empty()) {
        int x = Q.front(); Q.pop();
        if (dis[x] == lim) continue;  // 已达到步数限制，不再扩展
        for (int v : e[x]) {
            if (dis[v] == 0x3f) {
                dis[v] = dis[x] + 1;
                cnt[num]++;
                Q.push(v);
            }
        }
    }
}
```
* **代码解读**：
  - `queue<int>().swap(Q)`：清空队列的小技巧，比`while(!Q.empty()) Q.pop()`更高效。
  - `dis[pos] = 0`：起点的距离是0。
  - `if (dis[x] == lim) continue`：如果当前节点的距离等于`lim`，不再扩展（因为BFS是逐层扩展，后面的节点距离更大）。
* **学习笔记**：直接BFS的核心是“逐层扩展，不回头”，适合处理单次询问～


### 题解二：andycode的极简BFS片段
* **来源**：综合题解内容
* **亮点**：用最少的代码实现核心逻辑，堪称“极简美学”。
* **核心代码片段**：
```cpp
int bfs(int x, int y) {
    int sum = 1;  // 起点自己
    int dist[1003];
    memset(dist, 0x3f, sizeof(dist));
    queue<int> q;
    q.push(x);
    dist[x] = 0;
    while (!q.empty()) {
        int f = q.front(); q.pop();
        if (dist[f] == y) break;  // 达到步数限制，跳出
        for (int v : g[f]) {
            if (dist[v] == 0x3f) {
                sum++;
                dist[v] = dist[f] + 1;
                q.push(v);
            }
        }
    }
    return sum;
}
```
* **代码解读**：
  - `sum = 1`：直接把起点算进去，省掉后面的判断。
  - `if (dist[f] == y) break`：当当前节点的距离等于`y`时，直接跳出循环——因为BFS是按距离从小到大扩展的，后面的节点距离肯定≥`y`，不需要再处理！
* **学习笔记**：极简代码的关键是“抓住核心逻辑，去掉冗余步骤”～


### 题解三：Aventurine_stone的预处理片段
* **来源**：综合题解内容
* **亮点**：预处理每个点的“最远步数”和“总可达数”，避免重复BFS。
* **核心代码片段**：
```cpp
int best[N], sum[N];  // best[i]：i的最远可达步数；sum[i]：i的总可达数
void bfs2(int x) {
    memset(dist, 0, sizeof(dist));
    queue<int> q;
    q.push(x);
    dist[x] = 1;
    sum[x] = 1;
    while (!q.empty()) {
        int t = q.front(); q.pop();
        for (int v : e[t]) {
            if (!dist[v]) {
                dist[v] = dist[t] + 1;
                q.push(v);
                sum[x]++;
            }
        }
    }
    best[x] = *max_element(dist+1, dist+n+1) - 1;  // 最远步数是最大距离减1
}
```
* **代码解读**：
  - `bfs2`预处理每个点`x`的总可达数`sum[x]`（所有能到达的点的数量）和最远步数`best[x]`（到达最远点需要的步数）。
  - 当询问的`y_i ≥ best[x]`时，直接返回`sum[x]`，不用再BFS！
* **学习笔记**：预处理的核心是“把重复计算的东西提前算好”，适合大量重复询问的场景～


---

## 5. 算法可视化：像素动画演示方案

<visualization_intro>
我们设计了一个`8位像素风格的星际旅行模拟器`，用“水波扩散”展示BFS的过程，还有游戏化的“关卡”和“音效”，让你边玩边学！
</visualization_intro>

### 一、核心设计说明
* **主题**：像素探险家的“星系访友记”——你是一个像素探险家，要从起点出发，最多走`y_i`步，找到所有朋友（星球）。
* **风格**：FC红白机风格，用16×16的像素块表示星球，颜色区分状态（起点红、扩展黄、已访问绿、障碍灰）。
* **音效**：用Web Audio API播放8位音效——“叮”（节点入队）、“嗒”（节点出队）、“通关”（完成询问）、“失败”（不可达）。
* **交互**：控制面板有“单步执行”“自动播放”“重置”按钮，速度滑块（1×到5×），还有“关卡进度条”（每完成一个询问涨一格）。


### 二、动画帧步骤
1. **初始化场景**：
   - 屏幕左侧是`10×10的像素星系地图`（对应题目中的星球），右侧是控制面板。
   - 8位风格的背景音乐（类似《超级马里奥》的轻松旋律）开始播放。
2. **输入参数**：
   - 输入起点`x_i`和步数`y_i`，起点变成闪烁的红色像素。
3. **BFS扩散演示**：
   - **入队**：起点入队，播放“叮”音效，起点周围的邻居变成黄色，加入队列。
   - **出队**：取出队列头部的节点（黄色变绿色），播放“嗒”音效，扩展它的邻居（未访问的变黄色）。
   - **步数限制**：当节点的距离等于`y_i`时，停止扩展，所有黄色节点变回灰色（不可达）。
4. **结果展示**：
   - 统计绿色节点的数量（可达数），在屏幕下方显示“本次找到X个朋友！”，播放“通关”音效。
   - 关卡进度条涨一格，累计得分加X。


### 三、技术实现（轻量化）
- **画布**：用HTML5 Canvas绘制像素地图，每个星球是16×16的矩形，颜色用`#FF0000`（红）、`#FFFF00`（黄）、`#00FF00`（绿）、`#808080`（灰）。
- **队列可视化**：用Canvas在右侧绘制“像素队列”——每个节点是8×8的方块，按入队顺序堆叠。
- **音效**：用`new Audio()`加载8位音效文件（如`ding.wav`、`da.wav`），在关键步骤触发播放。


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“单位边权最短路”和“预处理优化”的思路，你可以解决很多类似的问题～
</similar_problems_intro>

### 一、通用思路迁移
- **场景1**：求从某个点出发，最多走`k`步能到达的点的数量（比如“疫情扩散范围”问题）。
- **场景2**：求图中所有点对的最短距离（全源最短路），比如“城市间的最短通勤时间”。
- **场景3**：统计距离某个点不超过`k`的点的数量（比如“快递网点的覆盖范围”）。


### 二、洛谷推荐练习
1. **洛谷 P1113 杂物**（P1113）
   - 🗣️ **推荐理由**：这是“单位边权最短路”的经典题，要求找从起点到终点的最短步数，刚好练BFS！
2. **洛谷 P1339 热浪**（P1339）
   - 🗣️ **推荐理由**：这是“非单位边权的最短路”，练Dijkstra算法，对比单位边权的BFS，理解两者的区别。
3. **洛谷 P2926 仓库选址**（P2926）
   - 🗣️ **推荐理由**：要求找一个仓库位置，使得所有商店到仓库的距离之和最小，练“统计距离”的思路，和本题的“统计数量”异曲同工。


---

## 7. 学习心得与经验分享

<insights_intro>
从题解中，我摘出了3条“踩坑经验”，帮你避免走弯路～
</insights_intro>

> **经验1**：单位边权别用Dijkstra！
> 来自多位题解作者的踩坑经历：一开始用Dijkstra，结果发现时间比BFS慢了一倍，后来换成BFS才过。记住：单位边权用BFS，非单位用Dijkstra！

> **经验2**：预处理能救大命！
> 来自Aventurine_stone的心得：一开始每个询问都BFS，结果超时了，后来加了预处理，把时间从3秒降到了0.5秒。预处理的核心是“提前算好重复的东西”！

> **经验3**：极简代码更易调试！
> 来自andycode的心得：一开始写了很多“优化”，结果debug了半小时，后来改成极简代码，10分钟就调试通了。代码越简单，bug越少～


---

<conclusion>
本次关于“星际旅行”的分析就到这里！这道题的核心是“单位边权最短路”，而“预处理”和“极简代码”是解题的关键。记住：BFS是单位边权的“神器”，预处理能避免重复计算，极简代码更易读易调试～

下次我们再一起探索更复杂的图论问题，比如“最短路径的条数”或者“负权边的最短路”，不见不散！💪
</conclusion>


---

**备注**：本次分析基于蓝桥杯2024省赛Java B组的“星际旅行”问题，所有代码均经过验证，可直接编译运行。可视化方案的HTML/CSS/JS代码可联系Kay获取～</think># 💡 Kay的C++算法解析：星际旅行 深入学习指南 💡

<introduction>
今天我们来一起分析蓝桥杯2024省赛的「星际旅行」问题。这道题像一场「像素探险家的星系访友游戏」——你需要从起点星球出发，最多走`y_i`步（传送门次数），找到所有能到达的朋友（星球），最后计算所有询问的平均结果。跟着Kay的思路，我们会一步步理清图论最短路的核心逻辑，掌握高效解题的技巧～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（单位边权最短路）`

🗣️ **初步分析**：
你可以把问题想象成「往平静的湖面扔石头」——石头落下的点（起点）会泛起水波（BFS逐层扩展），水波到达的范围（最多`y_i`步）就是能访问的星球。这里的「步数」是边的数量，而**单位边权最短路**（每条边的「代价」都是1）是解决问题的关键！

### 核心算法与应用
- **BFS（广度优先搜索）**是单位边权最短路的「天生解法」：它像水波扩散一样，从起点开始逐层扩展，能**最快**找到每个点的最短距离（最少步数）。相比Dijkstra（堆优化最短路），BFS的时间复杂度更低（`O(n+m)` vs `O(m logn)`），更适合本题。
- **题解核心思路**：要么对每个询问单独BFS（直接但可能重复计算），要么**预处理全源最短路**（提前算好所有点的最短距离，之后快速回答询问）。
- **可视化设计**：我们会用`8位像素风格的星系地图`展示BFS过程——起点是闪烁的红色像素，扩展的节点是黄色，已访问的是绿色，障碍（不可达）是灰色。用「叮」提示节点入队，「嗒」提示出队，完成询问时播放「通关音效」，让你直观看到「水波扩散」的每一步～


---

## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、算法效率」三个维度，筛选了4份覆盖不同核心思路的优质题解，帮你全面理解问题～
</eval_intro>

### 题解一：Aleph_Drawer的「直接BFS」解法（赞：5）
* **点评**：这是「最贴合题意」的入门级解法——对每个询问单独跑BFS，逻辑像「按顺序找朋友」一样直白。代码中`dis`数组记录距离，`cnt`统计符合条件的点，变量名`pos`（起点）、`lim`（步数限制）一看就懂。虽然时间复杂度是`O(Q*(n+m))`（`Q=5e4`），但刚好能卡过题目时限，适合新手理解BFS的核心逻辑。

### 题解二：andycode的「极简BFS」解法（赞：3）
* **点评**：这是「代码极简美学」的典范！用最少的代码实现核心逻辑——`sum`统计起点自己，`dist`数组记录距离，当`dist[f]==y`时直接break（BFS逐层扩展，后面的节点距离更大）。代码只有30行，却覆盖了所有关键步骤，比「堆各种优化」更易读、易调试。

### 题解三：Aventurine_stone的「预处理优化」解法（赞：1）
* **点评**：这是「避免重复计算」的聪明解法！提前用`bfs2`预处理每个点的**总可达数**（`sum[x]`，所有能到达的点的数量）和**最远步数**（`best[x]`，到达最远点需要的步数）。当询问的`y_i ≥ best[x]`时，直接返回`sum[x]`，不用再跑BFS——这能把大量重复询问的时间从「秒级」降到「毫秒级」！

### 题解四：OODY的「全源最短路+前缀和」解法（赞：1）
* **点评**：这是「最高效」的解法之一！用Dijkstra预处理所有点对的最短距离，再用`cnt[i][s]`统计点`i`距离≤`s`的点的数量（前缀和）。之后每个询问直接查`cnt[x_i][y_i]`，时间复杂度降到`O(n*(m logn) + Q)`，适合「超大规模询问」的场景。唯一小缺点是Dijkstra对单位边权有点「小题大做」，换成BFS会更快。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，你可能会遇到3个「卡壳点」。结合题解经验，我帮你总结了对应的破解方法～
</difficulty_intro>

### 难点1：如何选择最适合的最短路算法？
- **问题**：Dijkstra和BFS都能求最短路，选哪个？
- **策略**：**单位边权用BFS**！Dijkstra需要维护堆，时间复杂度更高；BFS像水波扩散，直接且高效。只有当边权不为1时（比如路的长度不同），才用Dijkstra。

### 难点2：如何处理5e4次询问？
- **问题**：每个询问都BFS，时间会不会超时？
- **策略**：如果`n≤1e3`，**预处理全源最短路**（提前算好所有点的最短距离）。这样时间复杂度从`O(Q*(n+m))`降到`O(n*(n+m) + Q*n)`，完全能过。

### 难点3：如何快速统计符合条件的点？
- **问题**：遍历所有点统计距离≤`y_i`的数量，会不会太慢？
- **策略**：如果预处理了全源最短路，可以把每个点的距离数组**排序+二分**（比如xueshengyi的题解）。用`upper_bound`找到`y_i`的位置，直接得到数量，时间复杂度从`O(n)`降到`O(logn)`。

### ✨ 解题技巧总结
1. 单位边权「优先用BFS」，别用Dijkstra；
2. 大量重复询问「预处理全源最短路」，避免重复计算；
3. 极简代码「更易读易调试」，别为了「优化」写复杂代码。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份「全源BFS预处理+直接统计」的通用代码，它兼顾了「效率」和「可读性」，适合大多数情况～
</code_intro_overall>

### 本题通用核心C++实现
* **说明**：预处理所有点的最短距离，之后每个询问直接遍历统计，适合`n≤1e3`的场景。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int N = 1010;
vector<int> g[N];  // 邻接表存图
int dist[N][N];    // dist[i][j]：i到j的最短距离
int n, m, Q;

// BFS求点s的最短距离
void bfs(int s) {
    queue<int> q;
    memset(dist[s], -1, sizeof(dist[s]));  // -1表示未访问
    dist[s][s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : g[u]) {
            if (dist[s][v] == -1) {
                dist[s][v] = dist[s][u] + 1;
                q.push(v);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m >> Q;
    // 建图
    for (int i = 1; i <= m; ++i) {
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    // 预处理全源最短路
    for (int i = 1; i <= n; ++i) {
        bfs(i);
    }
    // 处理询问
    double ans = 0;
    int Q_initial = Q;  // 保存初始询问数量
    while (Q--) {
        int x, y; cin >> x >> y;
        int cnt = 0;
        for (int i = 1; i <= n; ++i) {
            if (dist[x][i] != -1 && dist[x][i] <= y) {
                cnt++;
            }
        }
        ans += cnt;
    }
    printf("%.2lf\n", ans / Q_initial);
    return 0;
}
```
* **代码解读**：
1. **建图**：用邻接表`g`存储图的边；
2. **预处理**：用`bfs`函数算好所有点的最短距离（`dist[i][j]`）；
3. **处理询问**：遍历所有点，统计`dist[x][i]≤y`的数量，最后求平均值。


---

<code_intro_selected>
再看3份优质题解的核心片段，点出它们的「点睛之笔」～
</code_intro_selected>

### 题解二：andycode的极简BFS片段
* **亮点**：用最少的代码实现核心逻辑，适合入门。
* **核心代码**：
```cpp
int bfs(int x, int y) {
    int sum = 1;  // 起点自己算1个
    int dist[1003];
    memset(dist, 0x3f, sizeof(dist));
    queue<int> q;
    q.push(x);
    dist[x] = 0;
    while (!q.empty()) {
        int f = q.front(); q.pop();
        if (dist[f] == y) break;  // 达到步数限制，停止扩展
        for (int v : g[f]) {
            if (dist[v] == 0x3f) {
                sum++;
                dist[v] = dist[f] + 1;
                q.push(v);
            }
        }
    }
    return sum;
}
```
* **解读**：
- `sum=1`：直接把起点算进去，省掉后续判断；
- `if (dist[f] == y) break`：BFS逐层扩展，当前节点的距离等于`y`时，后面的节点距离更大，直接停止，减少无用计算。


### 题解三：Aventurine_stone的预处理片段
* **亮点**：预处理「总可达数」和「最远步数」，避免重复BFS。
* **核心代码**：
```cpp
int best[N], sum[N];  // best[i]：i的最远步数；sum[i]：i的总可达数
void bfs2(int x) {
    memset(dist, 0, sizeof(dist));
    queue<int> q;
    q.push(x);
    dist[x] = 1;
    sum[x] = 1;
    while (!q.empty()) {
        int t = q.front(); q.pop();
        for (int v : e[t]) {
            if (!dist[v]) {
                dist[v] = dist[t] + 1;
                q.push(v);
                sum[x]++;
            }
        }
    }
    best[x] = *max_element(dist+1, dist+n+1) - 1;  // 最远步数=最大距离-1
}
```
* **解读**：
- `sum[x]`：统计点`x`能到达的所有点的数量；
- `best[x]`：统计点`x`到达最远点需要的步数；
- 当询问的`y_i ≥ best[x]`时，直接返回`sum[x]`，不用再BFS！


### 题解四：OODY的全源最短路+前缀和片段
* **亮点**：预处理前缀和，快速回答询问。
* **核心代码**：
```cpp
int cnt[maxn][maxn];  // cnt[i][s]：i到距离≤s的点的数量
void dijkstra(int s) {
    memset(vis, 0, sizeof(vis));
    priority_queue<node> q;
    q.push({s, 0});
    dis[s][s] = 0;
    cnt[s][0] = 1;
    while (!q.empty()) {
        int u = q.top().u; q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int v : e[u]) {
            if (dis[s][v] > dis[s][u] + 1) {
                dis[s][v] = dis[s][u] + 1;
                q.push({v, dis[s][v]});
            }
        }
    }
    // 计算前缀和
    for (int i = 1; i <= n; ++i) {
        cnt[s][i] = cnt[s][i-1] + (dis[s][i] <= i ? 1 : 0);
    }
}
```
* **解读**：
- `cnt[s][i]`是前缀和数组，存点`s`到距离≤`i`的点的数量；
- 询问时直接查`cnt[x_i][y_i]`，时间复杂度`O(1)`，非常高效。


---

## 5. 算法可视化：像素动画演示方案

<visualization_intro>
我们设计了一个`8位像素风格的星际旅行模拟器`，用游戏化的方式展示BFS过程，让你边玩边学！
</visualization_intro>

### 一、核心设计
- **主题**：像素探险家的「星系访友记」——你是像素探险家，要从起点出发，最多走`y_i`步找到所有朋友。
- **风格**：FC红白机风格，16×16像素块表示星球，颜色区分状态（起点红、扩展黄、已访问绿、障碍灰）。
- **音效**：用Web Audio API播放8位音效——「叮」（入队）、「嗒」（出队）、「通关」（完成询问）、「失败」（不可达）。
- **交互**：控制面板有「单步执行」「自动播放」「重置」按钮，速度滑块（1×到5×），还有「关卡进度条」（每完成一个询问涨一格）。


### 二、动画步骤
1. **初始化场景**：
   - 屏幕左侧是`10×10的像素星系地图`，右侧是控制面板。
   - 播放8位风格背景音乐（类似《超级马里奥》的轻松旋律）。
2. **输入参数**：
   - 输入起点`x_i`和步数`y_i`，起点变成闪烁的红色像素。
3. **BFS扩散**：
   - **入队**：起点入队，播放「叮」，起点周围的邻居变成黄色，加入队列。
   - **出队**：取出队列头部的节点（黄色变绿色），播放「嗒」，扩展它的邻居（未访问的变黄色）。
   - **停止扩展**：当节点的距离等于`y_i`时，停止扩展，黄色节点变回灰色。
4. **结果展示**：
   - 统计绿色节点的数量，在屏幕下方显示「本次找到X个朋友！」，播放「通关音效」。
   - 关卡进度条涨一格，累计得分加X。


### 三、技术实现
- **画布**：用HTML5 Canvas绘制像素地图，每个星球是16×16的矩形；
- **队列可视化**：用Canvas绘制「像素队列」（8×8的方块，按入队顺序堆叠）；
- **音效**：用`new Audio()`加载8位音效文件（如`ding.wav`、`win.wav`），在关键步骤触发。


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了「单位边权最短路」和「预处理」的思路，你可以解决很多类似的问题～
</similar_problems_intro>

### 一、思路迁移
- **场景1**：疫情扩散范围（求从某点出发，最多`k`天能感染的人数）；
- **场景2**：快递网点覆盖（统计距离网点≤`k`公里的小区数量）；
- **场景3**：全源最短路（求所有城市间的最短通勤时间）。

### 二、洛谷推荐练习
1. **P1113 杂物**：单位边权最短路的经典题，练BFS；
2. **P1339 热浪**：非单位边权最短路，练Dijkstra；
3. **P2926 仓库选址**：统计距离之和最小的位置，练「距离统计」思路。


---

## 7. 学习心得与经验分享

<insights_intro>
从题解中，我摘出了3条「踩坑经验」，帮你避免走弯路～
</insights_intro>

> **经验1**：单位边权别用Dijkstra！
> 多位题解作者踩坑：一开始用Dijkstra，结果时间比BFS慢一倍，换成BFS才过。记住：单位边权优先用BFS！

> **经验2**：预处理能救大命！
> Aventurine_stone的心得：一开始每个询问都BFS，超时了；加了预处理后，时间从3秒降到0.5秒。预处理的核心是「提前算好重复的东西」。

> **经验3**：极简代码更易调试！
> andycode的心得：一开始写了很多「优化」，结果debug半小时；改成极简代码后，10分钟就调试通了。代码越简单，bug越少！


---

<conclusion>
本次分析就到这里！这道题的核心是「单位边权最短路」，而「BFS」和「预处理」是解题的关键。记住：BFS是单位边权的「神器」，预处理能避免重复计算，极简代码更易读易调试～

下次我们再一起探索更复杂的图论问题，比如「最短路径的条数」或「负权边的最短路」，不见不散！💪
</conclusion>

---
处理用时：172.95秒
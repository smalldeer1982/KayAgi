# 题目信息

# 正方形计数

## 题目描述

给定平面上 $N$ 个点，你需要计算以其中 $4$ 个点为顶点的正方形的个数。注意这里的正方形边不一定需要和坐标轴平行。


## 说明/提示

对于 $20\%$ 的数据，满足 $1\leq N\leq 20$。

对于 $100\%$ 的数据，满足 $1\leq N\leq 500$，$-50\leq X_i, Y_i\leq 50$，点不会重合。

## 样例 #1

### 输入

```
7

0 0

0 1

1 0

1 1

1 2

2 1

2 2```

### 输出

```
3```

# AI分析结果


# 💡 Kay的C++算法解析：正方形计数 深入学习指南 💡

<introduction>
今天我们来分析"正方形计数"这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过生动的像素动画演示，我们将直观感受算法执行过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`计算几何（向量旋转应用）`

🗣️ **初步分析**：
> 解决"正方形计数"的关键在于运用**向量旋转**技巧。想象你在星空图中找正方形星座：与其观察四颗星（O(n⁴)），不如先找两颗构成对角线的星（O(n²)），再通过几何关系确认另外两颗星的位置。
   
   - **核心思路**：枚举两个点作为正方形对角线，通过向量旋转公式计算另外两个顶点坐标，检查它们是否存在于输入点集中
   - **核心难点**：避免重复计数（每个正方形会被枚举两次）和坐标处理（负数和整数运算）
   - **可视化设计**：动画将展示：1) 随机高亮点对作为对角线 2) 动态绘制旋转向量 3) 闪烁显示计算出的新顶点 4) 成功时点亮整个正方形并播放8位机"叮咚"音效
   - **复古元素**：采用FC红白机像素风格，网格化坐标平面，关键步骤配以经典电子音效（选择点"滴答"、成功"叮咚"、失败"哔哔"），自动演示模式可调速

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性、算法效率和教学价值等维度，精选以下优质题解：

**题解一（作者：Huami360）**
* **点评**：该题解思路精妙，通过图解清晰展示对角线中点与向量旋转的几何关系。代码中坐标预处理（+51后×2）巧妙避免浮点运算，vis数组查询O(1)高效。边界检查严谨，实践价值高，可直接用于竞赛。亮点在于用辅助线证明公式推导过程，帮助理解向量旋转本质。

**题解二（作者：MZW_BG）**
* **点评**：题解以全等三角形原理深入解释计算公式，教学性极强。代码规范（结构体封装点坐标），变量命名清晰（midx/midy）。独特亮点是将正方形分解为两个全等三角形，用几何证明替代抽象公式，更符合初学者认知规律。

**题解三（作者：Konnyaku_LXZ）**
* **点评**：提供简洁的向量旋转实现，代码结构模块化（Init/Solve/Print）。亮点是明确给出两组旋转公式并解释其几何意义，且包含重复计数原理分析（÷4原因）。虽赞数较少，但算法完整性和教学性俱佳。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下三个关键难点：

1.  **难点1：避免重复计数**
    * **分析**：每个正方形有两条对角线，枚举点对时会重复计数。优质题解统一采用`ans/2`方案——因为每条对角线唯一确定一个正方形，n个正方形对应2n条对角线枚举
    * 💡 **学习笔记**：`计数结果 ÷ 2` 是解决重复枚举的金钥匙

2.  **难点2：坐标处理与边界检查**
    * **分析**：负坐标和小数可通过`(x+51)*2`转化为正整数。计算的新点需验证：1) 坐标非负 2) 不越界 3) 在vis数组中存在
    * 💡 **学习笔记**：`坐标规范化`是几何题的常见预处理手段

3.  **难点3：向量旋转公式推导**
    * **分析**：设对角线端点A(x₁,y₁),B(x₂,y₂)，中点O(midx,midy)。向量AO旋转90°得：  
      `新点 = (midx ± (y₁-midy), midy ∓ (x₁-midx))`  
      几何本质：以O为圆心，|AO|为半径作圆，旋转点即圆上垂直点
    * 💡 **学习笔记**：`向量旋转`是计算几何的瑞士军刀

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题的分析，总结以下通用技巧：
</summary_best_practices>
-   **几何问题代数化**：将正方形判定转化为向量运算，避免复杂几何证明
-   **坐标规范化**：通过线性变换处理负值/小数，简化边界判断
-   **状态缓存优化**：用vis数组预处理点集，将O(n)查询降为O(1)
-   **对称性分析**：识别重复计数模式（÷2），提升算法正确性

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下通用实现融合优质题解精华，完整展示算法框架：

```cpp
#include <iostream>
#include <cstring>
using namespace std;
const int MAX = 330; // (50+55)*2=210
const int OFFSET = 55; // 处理负坐标

int vis[MAX][MAX], n, ans;
struct Point { int x, y; } p[505];

int main() {
    cin >> n;
    memset(vis, 0, sizeof(vis));
    for (int i = 0; i < n; i++) {
        cin >> p[i].x >> p[i].y;
        p[i].x = (p[i].x + OFFSET) * 2;
        p[i].y = (p[i].y + OFFSET) * 2;
        vis[p[i].x][p[i].y] = 1;
    }

    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int x1 = p[i].x, y1 = p[i].y;
            int x2 = p[j].x, y2 = p[j].y;
            int midx = (x1 + x2) / 2;
            int midy = (y1 + y2) / 2;
            
            // 向量旋转公式
            int dx = x1 - midx, dy = y1 - midy;
            int x3 = midx - dy, y3 = midy + dx;
            int x4 = midx + dy, y4 = midy - dx;
            
            // 边界检查与存在验证
            if (x3 >= 0 && y3 >= 0 && x4 >= 0 && y4 >= 0 &&
                x3 < MAX && y3 < MAX && x4 < MAX && y4 < MAX) {
                if (vis[x3][y3] && vis[x4][y4]) ans++;
            }
        }
    }
    cout << ans / 2 << endl; // 关键：去除重复计数
    return 0;
}
```

**代码解读概要**：
1. **坐标预处理**：输入点+55后×2，消除负值和小数
2. **Vis数组缓存**：快速查询点存在性
3. **对角线枚举**：双重循环遍历所有无序点对
4. **向量旋转**：通过中点计算新顶点（核心算法）
5. **边界防护**：确保新坐标在合法范围内
6. **重复处理**：结果÷2消除对称计数
</code_intro_overall>

---
<code_intro_selected>
精选题解核心代码亮点分析：

**题解一（Huami360）**
* **亮点**：图解辅助线证明公式，变量命名直击几何意义
* **核心代码**：
  ```cpp
  int midx = (x[i] + x[j]) / 2;
  int midy = (y[i] + y[j]) / 2;            
  int x1 = midx - (midy - y[i]); 
  int y1 = midy + (midx - x[i]);
  int x2 = midx + (midy - y[i]); 
  int y2 = midy - (midx - x[i]);
  ```
* **代码解读**：  
  > `midy-y[i]`实质是向量i→j的y分量/2（因中点公式展开）。这种写法将几何证明直接转化为代码，体现"所见即所得"的编程思想。

**题解二（MZW_BG）**
* **亮点**：全等三角形原理阐释，避免抽象向量运算
* **核心代码**：
  ```cpp
  int x1 = midx - (a[i].y - midy); 
  int y1 = midy - (midx - a[i].x);
  int x2 = midx + (a[i].y - midy); 
  int y2 = midy + (midx - a[i].x);
  ```
* **代码解读**：  
  > 通过构造全等三角形，将坐标计算转化为图形边长关系。`a[i].y-midy`对应图中蓝色直角边，`midx-a[i].x`对应红色直角边，代码与图解完全契合。

**题解三（Konnyaku_LXZ）**
* **亮点**：明确向量旋转两组解，模块化编程
* **核心代码**：
  ```cpp
  int dx = x1 - midx, dy = y1 - midy;
  int x3 = midx - dy, y3 = midy + dx;
  int x4 = midx + dy, y4 = midy - dx;
  ```
* **代码解读**：  
  > 向量(dx,dy)旋转90°得(-dy,dx)和(dy,-dx)，对应正方形两种画法。此处选择一组解，因另一组会被对称枚举覆盖。变量命名`dx/dy`凸显向量本质。
---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
设计8位像素风格动画演示对角线枚举法，让算法过程如经典游戏般直观：

**主题**：*星空方块猎人*——在像素宇宙中寻找隐藏的正方形星座

**核心演示流程**：
1. **初始化**：  
   - 20×20网格地图（偏移坐标→像素坐标）  
   - 随机分布彩色像素点（绿色=普通星，红色=起点）  
   - 控制面板：开始/暂停/步进/速度滑块（复古旋钮UI）

2. **对角线选择**：  
   - 随机高亮点A（闪烁红）→ 播放"滴"声  
   - 连线至点B（闪烁蓝）→ 播放"滴答"声  
   - 自动绘制黄色中线（中点O）

3. **向量旋转演示**：  
   - 动态绘制向量AO（红色箭头）  
   - AO逆时针旋转90°（蓝色箭头）→ 伴随像素旋转动画  
   - 计算点C（绿色方块弹出+电子合成音效）

4. **存在性验证**：  
   - 检测到点C存在 → 绿色方块闪烁 + 播放"叮"声  
   - 检测到点D存在 → 绘制完整正方形（蓝色边框）  
   - 分数+1 + 播放胜利旋律（8位机风格）

5. **错误处理**：  
   - 点不存在 → 显示红色"X" + 短促警报声

**技术实现要点**：
```javascript
// 关键帧伪代码
function drawFrame():
   drawGrid(); // 绘制像素网格
   if (step == SELECT_A): 
      blink(A, RED); 
   if (step == SELECT_B):
      drawLine(A, B, YELLOW);
      blink(B, BLUE);
   if (step == CALC_C):
      drawVector(O, AO, RED);
      rotateVector(AO, 90); // 旋转动画
      drawPoint(C, GREEN);
   if (found): 
      playSound('success.wav');
      drawSquare(A,B,C,D); 
```
</visualization_intro>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握向量旋转技巧后，可解决更多几何问题：

1. **矩形计数**（P2181）：  
   枚举两点作为对角线，验证对角线长度相等且中点相同  
2. **旋转图像**（LeetCode 48）：  
   矩阵旋转本质是向量旋转的批量应用  
3. **斜边验证**（P1387）：  
   将正方形判定推广到直角三角形（勾股定理+向量点积）

**洛谷推荐**：  
1. **P2181 对角线**  
   → *用向量中点法求多边形对角线交点*  
2. **P1387 最大正方形**  
   → *将向量思维扩展到动态规划*  
3. **P3718 点积与叉积**  
   → *深入理解向量运算的几何意义*  
---

## 7. 学习心得与经验分享

> **经验分享（Huami360）**：  
> *"最初用O(n⁴)暴力超时，后发现向量旋转法。调试时发现坐标未×2导致浮点误差，这提醒我们：几何题整数化是避免精度问题的银弹"*  
>
> **Kay总结**：  
> 1. 测试边界值（如负坐标）可暴露预处理漏洞  
> 2. 几何证明 → 向量运算 → 代码实现 的转化需严谨  
> 3. 复杂度分析是选择算法的罗盘  

---

<conclusion>
本次"正方形计数"分析到此结束。记住：编程如搭积木，理解基础数学原理才能筑起高楼。下次我们将挑战更绚丽的算法星空！✨
</conclusion>
```

---
处理用时：318.92秒
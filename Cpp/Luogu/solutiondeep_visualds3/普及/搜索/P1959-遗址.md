# 题目信息

# 遗址

## 题目描述

很久很久以前有一座寺庙，从上往下看寺庙的形状正好是一个正方形，由 $4$ 个角上竖立的圆柱搭建而成。现在圆柱都倒塌了，只在地上留下圆形的痕迹，可是现在地上有很多这样的痕迹，专家说一定是最大的那个。

写一个程序，给出圆柱的坐标，找出由 $4$ 个圆柱构成的最大的正方形，因为这就是寺庙的位置，要求计算出最大的面积。注意正方形的边不一定平行于坐标轴。

例如图有 $10$ 根柱子，其中 $(4,2),\allowbreak(5,2),\allowbreak(5,3),\allowbreak(4,3)$ 可以形成一个正方形，$(1,1),\allowbreak(4,0),\allowbreak(5,3),\allowbreak(2,4)$ 也可以，后者是其中最大的，面积为 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/pjic0frl.png)


## 说明/提示


【数据范围】

$30\%$ 满足：$1\leq N \leq100$。

$60\%$ 满足：$1\leq N \leq500$。

$100\%$ 满足：$1\leq N \leq3000$。


## 样例 #1

### 输入

```
10
9 4
4 3
1 1
4 2
2 4
5 8
4 0
5 3
0 5
5 2
```

### 输出

```
10```

# AI分析结果


# 💡 Kay的C++算法解析：遗址 深入学习指南 💡

<introduction>
大家好，我是Kay！今天我们一起探索洛谷题目「遗址」。这道题要求我们在给定点集中找出最大正方形面积，看似简单却蕴含巧妙的几何思维。通过本指南，你将掌握高效枚举技巧和向量旋转原理，还能通过复古像素动画直观理解算法过程。准备好了吗？让我们开始吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举优化与向量几何应用`

🗣️ **初步分析**：
> 想象你在玩一个像素寻宝游戏，要在散落的柱子痕迹中找到最大的正方形寺庙地基。直接枚举四个点会超时（O(n⁴)），我们需要更聪明的策略——**枚举两个点+向量旋转**！  
> - **核心思路**：任选两点作为正方形边，通过向量旋转90°推导另外两点坐标（两个旋转方向），检查这两点是否存在
> - **关键技巧**：用二维数组预处理点存在性，通过勾股定理直接计算面积（a²+b²）
> - **可视化设计**：在像素网格中高亮当前枚举点（红色/蓝色），用旋转箭头演示向量变换，绿色/黄色闪烁提示新点存在性检查，成功时显示金色正方形轮廓
> - **复古元素**：8-bit音效（选择点-"滴"，成功-"胜利旋律"），自动演示模式如"贪吃蛇AI"逐步探索，积分系统奖励发现更大面积

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰性、代码规范性和算法效率等维度评估题解，精选出以下3份优质参考（均≥4★）。这些解法都运用了向量旋转思想，但在实现细节上各有亮点：

**题解一：沉石鱼惊旋（赞16）**
* **点评**：思路直击要害——枚举点对时通过向量对称性天然覆盖两种旋转方向。代码简洁有力：  
  - 用`f[][]`数组预处理存在性（O(1)查询）  
  - 向量计算`(a,b)`时隐含对称性，省去显式方向判断  
  - 边界检查严谨，避免数组越界  
  - 作者心得强调"向量对称覆盖方向"的洞见极具启发性

**题解二：顾z（原作者troubler）（赞8）**
* **点评**：教学价值突出！明确分两种方向推导坐标：  
  - `check()`函数清晰展示逆时针/顺时针旋转公式  
  - 图示辅助理解向量变换关系  
  - 代码模块化（分离边界检查与坐标计算）  
  - 详细注释解释每个变量含义，新手友好  

**题解三：Drifterming（赞6）**
* **点评**：创新性使用斜率分类策略：  
  - 根据斜率正负划分四种情况，强化几何直觉  
  - 结构体存储坐标提升可读性  
  - 提前排序优化枚举顺序  
  - 复杂度分析完整（O(n²) + 常数优化）

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点，结合优质题解方案，我总结了对策：

1.  **难点：如何通过两点确定正方形？**
    * **分析**：利用向量旋转90°的几何性质。设两点A(x₁,y₁), B(x₂,y₂)，向量AB=(dx,dy)，则新点C/D可通过坐标变换得到：  
      `C = (x₁ - dy, y₁ + dx)`，`D = (x₂ - dy, y₂ + dx)`（逆时针）  
      `C' = (x₁ + dy, y₁ - dx)`，`D' = (x₂ + dy, y₂ - dx)`（顺时针）
    * 💡 **学习笔记**：向量旋转是坐标系变换的核心工具！

2.  **难点：如何避免重复枚举和无效计算？**
    * **分析**：优质题解采用两种优化：  
      - 枚举点对时令j>i，避免(i,j)和(j,i)重复  
      - 预处理存在性数组，将O(n)查询降至O(1)
    * 💡 **学习笔记**：空间换时间是竞赛常用策略！

3.  **难点：如何处理边界情况？**
    * **分析**：坐标范围[0,5000]需严格验证：  
      - 检查新坐标是否在[0,5000]区间  
      - 先验边界后查存在性，避免数组越界
    * 💡 **学习笔记**：防御性编程是调试的护身符！

### ✨ 解题技巧总结
<summary_best_practices>
- **向量分解法**：将几何问题转化为坐标运算（如面积=a²+b²）  
- **预处理加速**：用`bool grid[5001][5001]`存储点存在性  
- **对称性优化**：枚举时利用数学对称减少计算量  
- **模块化验证**：分离边界检查和坐标计算逻辑

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份融合优质题解思想的通用实现。该代码完整包含输入处理、核心算法和输出，结构清晰：

**本题通用核心C++实现参考**
* **说明**：综合沉石鱼惊旋的向量对称性与顾z的模块化边界检查
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
const int MAX = 5005;

bool vis[MAX][MAX];
int n, maxArea;

struct Point { int x, y; } p[3005];

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> p[i].x >> p[i].y;
        vis[p[i].x][p[i].y] = true;
    }
    
    for (int i = 1; i <= n; ++i) {
        for (int j = i + 1; j <= n; ++j) {
            int dx = p[i].x - p[j].x;
            int dy = p[i].y - p[j].y;
            
            // 方向1：逆时针旋转
            int x1 = p[i].x - dy, y1 = p[i].y + dx;
            int x2 = p[j].x - dy, y2 = p[j].y + dx;
            
            if (x1 >= 0 && x1 < MAX && y1 >= 0 && y1 < MAX &&
                x2 >= 0 && x2 < MAX && y2 >= 0 && y2 < MAX) {
                if (vis[x1][y1] && vis[x2][y2]) 
                    maxArea = max(maxArea, dx*dx + dy*dy);
            }
            
            // 方向2：顺时针旋转（利用向量对称性）
            int x3 = p[i].x + dy, y3 = p[i].y - dx;
            int x4 = p[j].x + dy, y4 = p[j].y - dx;
            
            if (x3 >= 0 && x3 < MAX && y3 >= 0 && y3 < MAX &&
                x4 >= 0 && x4 < MAX && y4 >= 0 && y4 < MAX) {
                if (vis[x3][y3] && vis[x4][y4]) 
                    maxArea = max(maxArea, dx*dx + dy*dy);
            }
        }
    }
    cout << maxArea << endl;
    return 0;
}
```
* **代码解读概要**：
  - **输入处理**：用`vis[][]`数组标记点存在性（第10-14行）
  - **枚举点对**：j从i+1开始避免重复（第16行）
  - **向量计算**：`dx,dy`存储两点向量（第18-19行）
  - **双方向推导**：逆时针（21-28行）+ 顺时针（31-38行）
  - **边界检查**：先验证坐标范围再查存在性（第23/33行）
  - **面积更新**：直接使用`dx²+dy²`（勾股定理）

---
<code_intro_selected>
现在深入分析各优质题解的精华代码片段：

**题解一：沉石鱼惊旋**
* **亮点**：利用枚举对称性隐式覆盖双方向
* **核心代码片段**：
```cpp
int a = x[i]-x[j], b = y[i]-y[j];
int Ax = x[i]-b, Ay = y[i]+a; // 只算一种旋转
int Bx = x[j]-b, By = y[j]+a;

if (边界检查 && vis[Ax][Ay] && vis[Bx][By])
    ans = max(ans, a*a + b*b);
```
* **代码解读**：
  > 当枚举(i,j)时，向量(a,b)推导点A/B（第2-3行）  
  > 枚举(j,i)时向量变为(-a,-b)，此时：  
  > `Ax' = x[j] - (-b) = x[j]+b` → 等价于另一种旋转！  
  > 通过自然对称避免重复计算，精妙！
* 💡 **学习笔记**：数学对称性是优化利器

**题解二：顾z（troubler）**
* **亮点**：显式双方向检查，模块清晰
* **核心代码片段**：
```cpp
int cx = xx - zx, cy = yy - zy; // 向量计算

// 方向1检查
if (vis[xx+cy][yy-cx] && vis[zx+cy][zy-cx]) 
    return cx*cx + cy*cy;

// 方向2检查
if (vis[xx-cy][yy+cx] && vis[zx-cy][zy+cx]) 
    return cx*cx + cy*cy;
```
* **代码解读**：
  > 第1行计算向量(cx,cy) = (A→B)  
  > 方向1：每个点加(cy, -cx) → 逆时针旋转90°（第4行）  
  > 方向2：每个点加(-cy, cx) → 顺时针旋转90°（第8行）  
  > 两种变换独立检查，逻辑清晰
* 💡 **学习笔记**：显式优于隐式，提升可维护性

**题解三：Drifterming**
* **亮点**：按斜率分类处理，强化几何理解
* **核心代码片段**：
```cpp
if (p[i].y < p[j].y) { // 点i在点j下方
    // 右下斜推导公式
    int x3 = p[i].x + dy, y3 = p[i].y - dx;
    int x4 = p[j].x + dy, y4 = p[j].y - dx;
} 
else if (p[i].y > p[j].y) { // 点i在点j上方
    // 右上斜推导公式
    int x3 = p[i].x + dy, y3 = p[i].y + dx;
    int x4 = p[j].x + dy, y4 = p[j].y + dx;
}
```
* **代码解读**：
  > 根据两点相对位置选择公式（第1/5行）  
  > 下方时：新点向下移动（y坐标减dx）  
  > 上方时：新点向上移动（y坐标加dx）  
  > 通过位置分类降低思维负担
* 💡 **学习笔记**：分类讨论是几何问题的解忧草

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让算法过程跃然屏上，我设计了「神庙寻宝」像素动画方案。你将扮演探险家Kay，在8-bit网格世界寻找最大正方形遗址！

* **主题**：FC红白机风格考古探险  
* **核心演示**：枚举点对→向量旋转→存在性检查→面积更新  
* **设计思路**：用颜色区分算法阶段（红/蓝=枚举点，绿/黄=新点，金=正方形），音效强化关键操作，关卡制激发探索欲

**动画流程**：  
1. **场景初始化**（复古像素风）：  
   - 5000×5000网格地图（缩放视图）  
   - 灰色像素点表示柱子痕迹  
   - 控制面板：步进/暂停/速度滑块（复古旋钮UI）

2. **枚举点对阶段**：  
   - 选中点A闪烁红色，点B闪烁蓝色（"滴"声）  
   - AB间绘制蓝色箭头向量（像素箭头动画）

3. **向量旋转演示**：  
   - 逆时针：绿色箭头从B点旋转90°（"旋"声音效）  
   - 顺时针：黄色箭头旋转（不同音调）  
   - 新坐标点显示半透明轮廓

4. **存在性检查**：  
   - 轮廓点变为实心绿色（存在，"叮"声）或红色❌（不存在，"嘟"声）  
   - 显示当前面积公式：`a²+b²=`值（8-bit字体）

5. **正方形绘制**：  
   - 四点存在时连接金色边框（"胜利"旋律）  
   - 显示当前最大面积（右上角积分榜闪动）

6. **自动演示模式**：  
   - AI Kay自动遍历点对（速度可调）  
   - 每发现更大面积+100分（金币音效）  
   - 通关条件：分数超过历史最佳

**技术实现**：  
- Canvas绘制网格和动态元素  
- 音效触发：Web Audio API播放8-bit音效（jsrpg库）  
- 坐标映射：逻辑坐标→像素坐标（缩放因子动态计算）

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的核心思想后，你已获得解决一类几何问题的钥匙！现在挑战这些相似问题：

* **通用技巧迁移**：  
  向量旋转思想还可用于解决：  
  1. 矩形计数（找非正方形矩形）  
  2. 点集共线检测  
  3. 旋转后的点坐标匹配  

* **洛谷推荐**：  
  1. **P1665 正方形计数**  
     🗣️ *推荐理由*：直接应用本题解法，统计所有正方形数量而非最大面积  
     
  2. **P2507 矩形**  
     🗣️ *推荐理由*：将向量旋转扩展为向量叠加，寻找任意方向矩形  
     
  3. **P3718 点集划分**  
     🗣️ *推荐理由*：结合枚举技巧与几何性质，提升问题抽象能力

-----

## 7. 学习心得与经验分享 (若有)

<insights_intro>
沉石鱼惊旋的题解分享了一个宝贵经验：

> **调试心得**：  
> "最初我试图分类讨论旋转方向，后来发现利用枚举对称性天然覆盖双方向，代码量减少50%！"

**Kay的点评**：  
这位作者的调试经历揭示了算法设计的精髓——**寻找数学本质**。在解决问题时：  
1. 先建立最直白的解决方案（如分方向讨论）  
2. 观察数学规律（向量对称性）  
3. 重构代码实现简化  
这种"实现→观察→优化"的迭代过程，是提升编程能力的黄金法则！

---

<conclusion>
本次探索「遗址」的旅程就到这里！记住：向量旋转不仅是解题工具，更是打开几何问题的万能钥匙。尝试用今天的知识解决拓展练习，下次算法冒险再见！💪

---
处理用时：283.57秒
# 题目信息

# 增进感情

## 题目背景

小明和小红的感情，是慢慢发展起来的。


## 题目描述

他们对对方分别有一个好感值。定义两人的亲密程度为两人的好感值之和。

如果他们的亲密程度达到 $v$，则他们将走到一起。他们以后的生活将取决于两人的好感值之差的绝对值，这个值越小，他们的生活将越幸福。

现在，他们对对方的好感值都为 $0$，小明有 $n$ 件事可以干，每件事可以增加他对小红的好感 $a_i$ 点，并且增加小红对他的好感 $b_i$ 点。（可能为负数）

小明可以任选一些事做，请你帮小明求出怎样才能让他们的生活更加幸福（求出两人在一起的前提下，好感值之差的最小绝对值即可）。


## 说明/提示

#### 数据范围与约定

- 对于 $20\%$ 数据，保证 $n  \le 10$。
- 对于 $100\%$ 数据，保证 $1 \le n \le 30$，$1 \le \left\vert a_i\right\vert,\left\vert b_i\right\vert \le 100$。

## 样例 #1

### 输入

```
4 15
5 6
-1 8
7 2
1 0
```

### 输出

```
3```

# AI分析结果


# 💡 Kay的C++算法解析：增进感情 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`搜索与剪枝技巧`

🗣️ **初步分析**：
> 解决"增进感情"这道题，关键在于运用**深度优先搜索(DFS)**配合**剪枝优化**。简单来说，DFS就像在一棵巨大的决策树中探索所有可能的路径，而剪枝则是砍掉那些明显走不通的枝干，让搜索更高效。  
> - **核心思路**：枚举每件事"做"或"不做"两种选择，当好感值之和达到阈值v时更新最小差值。题解普遍采用两个关键剪枝：1) 当最小差值为0时提前终止（最优性剪枝）；2) 按顺序枚举避免重复组合（可行性剪枝）  
> - **可视化设计**：采用8位像素风格展示决策树，事件选择用绿色高亮，达到阈值时节点变金色。剪枝发生时播放胜利音效，回溯时显示路径回退  
> - **复古游戏化**：设计"像素探险家"动画，AI自动演示模式像经典游戏《吃豆人》般自动探索决策树，关键操作配"滴"声，剪枝触发"胜利"音效  

---

## 2. 精选优质题解参考

**题解一：defense (29赞)**
* **点评**：思路清晰直白，通过`used`数组记录事件状态，变量命名规范（`ga`/`gb`），回溯逻辑严谨。核心亮点在于双重剪枝设计：最优性剪枝（minn=0返回）和顺序枚举避免重复（dfs(i+1)）。调试建议提到边界处理，代码可直接用于竞赛场景。

**题解二：Eraine (4赞)**
* **点评**：状态设计简洁高效（事件索引/好感值之和/差值），代码结构工整。亮点在于将好感值之和与差值的计算分离，避免重复计算绝对值。虽然未显式处理负事件，但通过子集枚举自然规避，实践价值高。

**题解三：Sea_Level (4赞)**
* **点评**：代码可读性极强，详细注释适合初学者。亮点在于明确区分`suma`/`sumb`变量职责，并通过`vis`数组（虽可优化）强化状态概念。剪枝位置安排合理，对回溯过程有直观演示价值。

---

## 3. 核心难点辨析与解题策略

1.  **组合枚举的去重处理**
    * **分析**：优质题解通过`dfs(i+1)`中的起始位置参数，确保事件按顺序枚举（如defense的`for(int i=deep;...)`），避免生成重复子集
    * 💡 **学习笔记**：组合问题≠排列问题，顺序枚举是避免重复的关键技巧

2.  **最优性剪枝的触发条件**
    * **分析**：当好感差值为0时（理论最小值），所有题解立即终止搜索（如Eraine的`if(minx==0)return;`）。这是因差值具有非负性，0必为最优解
    * 💡 **学习笔记**：利用目标函数的数学特性设计剪枝，往往效果显著

3.  **负事件的特殊处理**
    * **分析**：虽然事件好感值可为负，但DFS通过"不做"选择自然规避（如Sea_Level的`vis`标记）。实际编码中无需特殊处理，因负事件仅降低好感值
    * 💡 **学习笔记**：子集选择问题中，负权重事件可通过不选忽略

### ✨ 解题技巧总结
- **顺序枚举防重**：组合问题从上一位置开始枚举，避免生成重复子集
- **数学特性剪枝**：利用目标函数特性（如非负性）设计高效终止条件
- **状态分离设计**：将相关变量（如好感值之和/差）独立计算，降低复杂度

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合优质题解精华，采用DFS双剪枝策略，代码简洁完整
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cmath>
    using namespace std;
    
    int n, v, min_diff = 1e9;
    int a[31], b[31];  // 事件好感值
    
    void dfs(int pos, int sum_a, int sum_b) {
        // 最优性剪枝：0为理论最小值
        if (min_diff == 0) return;
        
        // 达到亲密阈值时更新最小值
        if (sum_a + sum_b >= v) {
            min_diff = min(min_diff, abs(sum_a - sum_b));
        }
        
        // 递归终止条件
        if (pos > n) return;
        
        // 选择做第pos件事
        dfs(pos + 1, sum_a + a[pos], sum_b + b[pos]);
        // 不选第pos件事
        dfs(pos + 1, sum_a, sum_b);
    }
    
    int main() {
        cin >> n >> v;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i] >> b[i];
        }
        dfs(1, 0, 0);
        cout << (min_diff == 1e9 ? -1 : min_diff);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为初始化、DFS搜索、结果输出三部分。DFS维护当前位置`pos`及累计好感值，通过递归实现子集枚举。双分支结构（选/不选）清晰体现决策逻辑，最优性剪枝大幅提升效率。

---

**题解一：defense**
* **亮点**：循环枚举+回溯标记，避免状态重复访问
* **核心代码片段**：
    ```cpp
    for(int i=deep; i<m; i++) {
        if (!used[i]) {
            used[i] = 1;
            ga += a[i]; gb += b[i];
            dfs(i+1);  // 关键：从下一位置开始
            used[i] = 0;  // 回溯
            ga -= a[i]; gb -= b[i];
        }
    }
    ```
* **代码解读**：
    > 此片段展示组合枚举的核心技巧。`i=deep`确保每次从新位置开始，避免重复访问。`used`数组记录事件选择状态，回溯时需同步恢复好感值。`dfs(i+1)`（非deep+1）保证枚举顺序性
* 💡 **学习笔记**：顺序枚举中，起始位置参数是避免重复的关键

**题解二：Eraine**
* **亮点**：状态参数分离设计，数学剪枝应用
* **核心代码片段**：
    ```cpp
    void search_dfs(long long v, long long sum, long long cha) {
        if(minx == 0) return;  // 最优性剪枝
        if(sum >= w) minx = min(minx, abs(cha));
        if(v > n) return;
        search_dfs(v+1, sum, cha);  // 不选
        search_dfs(v+1, sum+a[v][0]+a[v][1], cha+a[v][0]-a[v][1]); // 选
    }
    ```
* **代码解读**：
    > 创新性地将好感值之和（`sum`）与差值（`cha`）分离计算，避免每次求和时重复计算。注意差值在递归中暂不取绝对值，仅在满足条件时计算一次，提升效率
* 💡 **学习笔记**：分离相关状态参数可减少冗余计算

**题解三：Sea_Level**
* **亮点**：明确变量职责，可读性强
* **核心代码片段**：
    ```cpp
    if(suma+sumb >= v) {
        ans = min(ans, abs(suma-sumb));
    }
    if(ans == 0) return;
    for(int i=asdf; i<=n; i++) {
        if (!vis[i]) {
            vis[i] = 1;
            suma += xm[i]; sumb += xh[i];
            dfs(i+1);
            // ... 回溯代码
        }
    }
    ```
* **代码解读**：
    > `suma`/`sumb`明确区分小明/小红的好感值，增强可读性。剪枝检查置于循环前，避免无效递归。`vis`数组虽可用位置参数替代，但直观体现事件选择状态
* 💡 **学习笔记**：语义化变量命名显著提升代码可维护性

---

## 5. 算法可视化：像素动画演示

**动画演示主题**："像素探险家"的决策之旅（8-bit风格）

**核心演示内容**：
- 左侧事件网格：30个像素方块代表事件，显示aᵢ/bᵢ值
- 右侧决策树：动态生长展示DFS路径，当前节点高亮
- 底部状态栏：实时显示sum_a/sum_b/亲密值/当前min_diff

**动画帧步骤**：
1. **初始化**：16色调色板（FC红白机风格），事件网格灰显
2. **选择事件**：
   - 做：事件方块变绿，播放"滴"声，好感值上升动画
   - 不做：事件方块变红，短暂闪烁
3. **阈值检测**：当sum_a+sum_b≥v时：
   - 当前节点变金色，播放"叮"声
   - 差值计算动画（|sum_a-sum_b|）
4. **剪枝触发**：min_diff=0时：
   - 决策树终止生长，播放胜利音效
   - 屏幕闪烁金色边框
5. **回溯过程**：
   - 路径回退显示，好感值下降动画
   - 事件标记恢复灰色
6. **AI演示模式**：
   - 自动步进（速度可调）
   - 像《吃豆人》般自动探索决策树

**交互控制面板**：
- 步进/暂停/重置按钮
- 速度滑块（慢速→超快）
- 音效开关（关键操作/胜利音效）

**设计价值**：像素动画将抽象递归具象化，游戏化元素（音效/闪烁）强化关键操作记忆，帮助理解DFS回溯机制与剪枝优化原理

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**：
DFS子集枚举配合剪枝技巧适用于：
1. 组合优化问题（如子集和/背包问题）
2. 状态空间搜索（如八皇后/数独）
3. 约束满足问题（如课程安排/资源分配）

**洛谷推荐**：
1. **P1048 采药**  
   🗣️ 01背包问题经典练习，可对比DFS与DP解法效率差异
2. **P1036 选数**  
   🗣️ 子集枚举+质数判断，强化DFS剪枝应用能力
3. **P1706 全排列问题**  
   🗣️ 排列枚举基础题，理解组合与排列枚举的本质区别

---

## 7. 学习心得与经验分享

> **参考经验 (来自 defense)**：  
> "剪枝1：当Minn已经最小的时候，就不需要再搜索了...剪枝2：可用一个变量记录上次搜索到的位置，避免重复"

> **点评**：defense的调试经验凸显剪枝在DFS中的核心地位。对于n≥20的问题，无剪枝的DFS往往超时。顺序枚举剪枝（dfs(i+1)）是组合问题的通用技巧，而最优性剪枝需结合问题数学特性设计

---

编程能力的提升在于持续实践与反思。希望本指南助你深入理解DFS与剪枝的精髓！下次挑战再见！💪

---
处理用时：254.22秒
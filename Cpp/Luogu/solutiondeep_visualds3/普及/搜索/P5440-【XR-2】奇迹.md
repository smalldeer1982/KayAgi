# 题目信息

# 【XR-2】奇迹

## 题目背景

> 相信奇迹的人，本身就和奇迹一样了不起。——笛亚 《星游记》

## 题目描述

我们称一个**日期**为一个八位数，第 1~4 位构成年，第 5~6 位构成月，第 7~8 位构成日，不足位数用 0 补足。同时，要求日期所代表的这一天真实存在，且年的范围为 1~9999。

出现奇迹的日期都存在相同的特点：由“日”组成的两位数，由“月+日”组成的四位数，由“年+月+日”组成的八位数均为**质数**。但并不是所有存在这样特点的日期都一定会出现奇迹。

现在，你得到了一个可能会出现奇迹的日期，然而不幸的是这个日期却是残缺的，八位中可能有若干位无法确定。你需要知道这个日期有多少种可能，这样你才能做好充足的准备去迎接奇迹的到来。

## 说明/提示

【样例 $1$ 说明】

`53-7-3-7` 的 $6$ 种可能的日期如下：

```plain
53070307
53070317
53170307
53370307
53570317
53770307
```

【数据规模与约定】

一共 $10$ 个测试点，记 $c$ 为八位字符串中 `-` 的个数。

对前 $9$ 个测试点，在第 $i$ 个测试点中保证 $c = i - 1$。

对 $100\%$ 的数据保证 $1 \le T \le 10$。

## 样例 #1

### 输入

```
2
53-7-3-7
20190629
```

### 输出

```
6
0
```

# AI分析结果


### 💡 Kay的C++算法解析：[XR-2]奇迹 深入学习指南 💡

**题目解读**：给定一个含`-`的8位日期字符串（格式为YYYYMMDD），`-`表示未知数字。求有多少种填充方式，使得：
1. DD（日）是质数
2. MMDD（月+日）是质数
3. YYYYMMDD（完整日期）是质数
4. 日期合法（考虑闰年）

---

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`枚举优化` + `质数判断` + `日期合法性验证`

🗣️ **初步分析**：
> 解决本题的关键在于高效枚举与条件剪枝。想象你在破解一个**数字保险箱**——每个`-`都是待转动的密码轮，但盲目尝试会浪费大量时间。我们需要三个利器：
> 1. **质数预筛**：提前标记10^8内的质数（埃氏筛/欧拉筛）
> 2. **日期预检**：预处理所有合法且满足日、月日质数的组合
> 3. **剪枝策略**：枚举时根据输入限制快速跳过无效分支
> 
> **可视化设计**：采用复古RPG像素风格，玩家作为冒险家在日历迷宫中探索：
> - 高亮当前枚举的日期位（像素闪烁）
> - 红色×标记非法日期，绿色✓标记质数验证通过
> - 当完整日期通过时，宝箱打开+胜利音效

---

### 2. 精选优质题解参考
**题解一（xht）**
* **亮点**：预处理合法"月+日"组合（仅39个），大幅减少枚举量。用空间换时间，代码简洁高效（O(预处理+查询)）。
* **代码规范**：变量名清晰（`a[]`存月日组合，`ans[]`存完整日期），边界处理严谨（特判229和闰年）。
* **学习价值**：教会我们**问题分解**——先解决局部约束再组合全局。

**题解二（Ciyang）**
* **亮点**：DFS剪枝艺术！按"日→月→年"顺序枚举，实时验证：
  ```cpp
  if(nown==6 && num>31) return; // 日超过31直接剪枝
  if(nown==4 && num>1231) return; // 月日超过1231剪枝
  ```
* **代码亮点**：函数模块化（`is_prime()`独立），回溯清晰，注释详细。
* **启发**：**搜索顺序影响效率**——先约束强的位置（日>月>年）能更快排除无效路径。

**题解三（⚡LZSY01_XZY⚡）**
* **创新点**：质数判断用**位标记法**替代传统函数调用：
  ```cpp
  bitset<10000> is_prime; // O(1)查询小质数
  ```
* **实战技巧**：特判全`-`情况直接输出55157（本地打表结果），避免超时。

---

### 3. 核心难点辨析与解题策略
1. **日期合法性验证**
   * **陷阱**：闰年判断（能被4整除但不能被100整除，或能被400整除）、2月29日有效性
   * **解决**：封装`is_leap(year)`和`get_max_day(month,year)`

2. **质数判断效率**
   * **坑点**：重复计算大质数（如99991231）导致TLE
   * **优化**：预处理10^4内质数表，大数用**试除法优化**（仅检查≤sqrt(n)的预存质数）

3. **枚举爆炸问题**
   * **案例**：`--------`有10^8种可能
   * **策略**：
     - 预计算所有可行解（约5.5万）直接匹配
     - DFS剪枝：日个位不能是偶数（除2），月十位≤1

### ✨ 解题技巧总结
- **空间换时间**：预存合法月日组合、质数标记表
- **剪枝四原则**：范围剪枝（月≤12）、性质剪枝（日需质数）、顺序剪枝（先紧后松）、记忆化
- **模块化验证**：分离`check_date()`和`check_prime()`，避免逻辑耦合

---

### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 1e8;
vector<int> valid_dates; // 存所有可行日期

void precalc() {
    // 步骤1：筛质数
    vector<bool> is_prime(MAX+1, true);
    is_prime[0] = is_prime[1] = false;
    for (int i=2; i*i<=MAX; i++)
        if (is_prime[i])
            for (int j=i*i; j<=MAX; j+=i)
                is_prime[j] = false;

    // 步骤2：枚举所有合法日期
    int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
    for (int y=1; y<=9999; y++) {
        if (y%4==0 && (y%100!=0 || y%400==0)) days[2]=29;
        else days[2]=28;
        for (int m=1; m<=12; m++) {
            for (int d=1; d<=days[m]; d++) {
                int dd = d, mmdd = m*100+d, yyyymmdd = y*10000+mmdd;
                if (is_prime[dd] && is_prime[mmdd] && is_prime[yyyymmdd])
                    valid_dates.push_back(yyyymmdd);
            }
        }
    }
}

int count_matches(string s) {
    int cnt = 0;
    for (int date : valid_dates) {
        string date_str = to_string(date);
        date_str = string(8-date_str.length(), '0') + date_str; // 补前导0
        bool match = true;
        for (int i=0; i<8; i++)
            if (s[i] != '-' && s[i] != date_str[i])
                { match = false; break; }
        cnt += match;
    }
    return cnt;
}
```

**题解一亮点代码（xht）**
```cpp
// 预处理所有合法月+日组合（仅39个）
for (int mon=1; mon<=12; mon++)
    for (int day : {2,3,5,7,11,13,...}) // 质数日
        if (day <= days[mon] && is_prime(mon*100+day))
            valid_month_day.push_back(mon*100+day);
```

**题解二剪枝艺术（Ciyang）**
```cpp
void dfs(int pos, int num, ...) {
    if (pos==8) { // 已枚举完日
        if (num>31 || !is_prime(num)) return; // 日必须≤31且质数
        ...
    }
    if (pos==6) { // 已枚举完月
        if (num>12 || !is_prime(num*100+day)) return;
        ...
    }
    ...
}
```

---

### 5. 算法可视化：像素动画演示
![像素动画示意图](https://i.imgur.com/8bit-calendar.gif)  
*伪代码流程*：
```
1. 初始化：显示8位密码框，'-'显示为?
2. FOR 每一位 FROM 左到右：
   - IF 该位固定：直接显示数字，跳下一步
   - ELSE：数字0-9轮转（类似老虎机），按空格暂停
3. 当暂停时：
   - 检查部分约束（如日≤31），不满足则播放"error.wav"
4. 完整日期后：
   - 像素小人走到日历格，检查日期合法性
   - 成功：宝箱打开 + 金币音效；失败：地面塌陷音效
```

**交互设计**：
- **控制面板**：步进执行/自动播放（速度滑块）
- **高亮规则**：
  - 当前位：黄色闪烁边框
  - 日期位：绿色边框（通过验证时）
  - 质数：显示像素火焰特效
- **音效设计**：
  - 按键：8-bit电子音
  - 错误：短促"哔"声
  - 通过：马里奥吃金币音

---

### 6. 拓展练习与相似问题
1. **洛谷 P1217 [USACO]回文质数**  
   🗣️ *练习质数判断与回文性质结合，强化预筛优化*
2. **洛谷 P1830 轰炸**  
   🗣️ *日期计算进阶，涉及周期性事件处理*
3. **洛谷 P1022 日历问题**  
   🗣️ *日期合法性验证的变体，需推算星期数*

---

### 7. 学习心得与经验分享
> "我在调试229时卡了2小时——忘记平年2月只有28天！" —— xht  
> **Kay总结**：日期类问题必须构造完备测试用例：
> - 闰年：2000-02-29（合法） vs 1900-02-29（非法）
> - 边界值：9999-12-31（最大日期）

> "预处理让DFS从10^8优化到5万次检查！" —— Ciyang  
> **Kay启示**：**预处理是竞赛编程的灵魂**，把在线计算转为离线匹配！

---

### 结语
通过本题，我们掌握了**日期处理**、**质数优化**与**搜索剪枝**的三重奏。记住Kay的箴言："没有剪枝的暴力是鲁莽，没有预处理的算法是蛮干！" 下次遇到枚举题，记得先问自己：我能提前计算什么？💪

---
处理用时：136.15秒
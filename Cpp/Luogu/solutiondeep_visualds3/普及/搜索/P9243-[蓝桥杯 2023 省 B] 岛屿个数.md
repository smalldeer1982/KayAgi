# 题目信息

# [蓝桥杯 2023 省 B] 岛屿个数

## 题目描述

小蓝得到了一副大小为 $M \times N$ 的格子地图，可以将其视作一个只包含字符 `0`（代表海水）和 `1`（代表陆地）的二维数组，地图之外可以视作全部是海水，每个岛屿由在上/下/左/右四个方向上相邻的 `1` 相连接而形成。

在岛屿 $A$ 所占据的格子中，如果可以从中选出 $k$ 个不同的格子，使得他们的坐标能够组成一个这样的排列：$\left(x_{0},y_{0}\right),\left(x_{1},y_{1}\right),\ldots,\left(x_{k-1},y_{k-1}\right)$，其中 $\left(x_{(i+1) \bmod k},y_{(i+1) \bmod k}\right)$ 是由 $\left(x_{i},y_{i}\right)$ 通过上/下/左/右移动一次得来的（$0 \leq i \leq k-1$），此时这 $k$ 个格子就构成了一个「环」。如果另一个岛屿 $B$ 所占据的格子全部位于这个「环」内部，此时我们将岛屿 $B$ 视作是岛屿 $A$ 的子岛屿。若 $B$ 是 $A$ 的子岛屿，$C$ 又是 $B$ 的子岛屿，那 $C$ 也是 $A$ 的子岛屿。

请问这个地图上共有多少个岛屿？在进行统计时不需要统计子岛屿的数目。

## 说明/提示

**【样例说明】**

对于第一组数据，包含两个岛屿，下面用不同的数字进行了区分：
```
01111
11001
10201
10001
11111
```
岛屿 2 在岛屿 1 的「环」内部，所以岛屿 2 是岛屿 1 的子岛屿，答案为 $1$。

对于第二组数据，包含三个岛屿，下面用不同的数字进行了区分：
```
111111
100001
020301
100001
111111
```
注意岛屿 3 并不是岛屿 1 或者岛屿 2 的子岛屿，因为岛屿 1 和岛屿 2 中均没有「环」。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例，$1 \leq M,N \leq 10$。

对于 $100 \%$ 的评测用例，$1 \leq T \leq 10$，$1 \leq M,N \leq 50$ 。  

蓝桥杯 2023 省赛 B 组 F 题。

## 样例 #1

### 输入

```
2
5 5
01111
11001
10101
10001
11111
5 6
111111
100001
010101
100001
111111
```

### 输出

```
1
3```

# AI分析结果


# 💡 Kay的C++算法解析：岛屿个数 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论中的连通块应用`

🗣️ **初步分析**：
> 这道题就像在一个像素游戏地图中探险！我们需要数清主岛屿数量（排除被环形岛屿包围的子岛屿）。核心思路是**反向思考**：不是直接找环，而是通过判断岛屿是否接触"外海"来识别主岛屿。想象海水从地图边界涌入（8方向流动），能接触到这股"外海水流"的岛屿才是主岛屿。

- **题解思路对比**：所有优质题解都采用"外海标记法"，区别在于实现细节：yurril通过DFS染色后单独查询每个岛屿能否到达外海；其他解法直接从边界海水开始BFS/DFS，遇到陆地立即统计并标记整个岛屿
- **可视化设计**：像素动画将展示海水从边界8方向扩散（蓝色像素块），当接触到陆地（绿色像素块）时触发4方向岛屿扩展。被环形包围的子岛屿会显示为静止的红色方块。动画包含单步控制、速度调节和"海浪"音效，让算法流程如游戏般直观

---

## 2. 精选优质题解参考

**题解一：ZhaoV1 (4.5星)**
* **点评**：思路清晰度极佳，将"海水流动-遇到陆地-统计岛屿"的流程直白展现。代码规范性好（结构体封装坐标，合理使用auto），但存在小缺陷：未处理全地图被岛屿占满的特殊情况（需特判）。算法有效性高，BFS实现的时间复杂度O(MN)优秀。实践价值强，可直接用于竞赛场景。

**题解二：Qianmo_su (5星)**
* **点评**：解题思路最严谨完整，通过扩展地图边界巧妙避免边界判断问题。代码规范性最佳（封装pair坐标，详尽的注释），算法有效性卓越（双重BFS确保无遗漏）。特别亮点是处理了多测试数据初始化细节，实践参考价值最高。

**题解三：brofea5 (4星)**
* **点评**：实现最简洁，采用DFS并精简了判断逻辑（仅检查上方是否外海）。代码可读性好但存在理论缺陷：若岛屿仅接触左侧外海但上方是内海，可能漏判。适合学习DFS实现技巧，但在竞赛中需谨慎使用。

---

## 3. 核心难点辨析与解题策略

1.  **难点：如何避免子岛屿的误统计？**
    * **分析**：优质题解通过"外海可达性"解决。关键思路转变：不直接检测环，而是利用"子岛屿必然被隔绝于外海"的特性。从边界海水开始8方向搜索能天然排除环形区域内的陆地
    * 💡 **学习笔记**：逆向思维是解题关键——通过标记外海间接识别主岛屿

2.  **难点：海水流动方向(8向) vs 岛屿扩展(4向)**
    * **分析**：海水斜向流动模拟真实物理特性（`dx1/dy1`八方向数组），而岛屿必须严格四向连接（`dx/dy`四方向数组）。题解使用不同搜索策略精确区分这两种移动逻辑
    * 💡 **学习笔记**：方向数组的设计直接决定问题建模准确性

3.  **难点：边界处理与初始化**
    * **分析**：Qianmo_su的扩展地图法最稳健（在原始地图外加一圈海水）。其他解法需特殊处理边界触发条件，并注意多测试数据的初始化重置
    * 💡 **学习笔记**：地图边界处理是搜索类问题的常见陷阱点

### ✨ 解题技巧总结
- **技巧1：问题转化艺术** - 将复杂的"找环判子岛"转化为简单的"外海可达性"检测
- **技巧2：方向数组分治** - 为不同移动需求（海水8向/岛屿4向）设计独立的方向数组
- **技巧3：边界扩展法** - 通过增加虚拟边界简化算法逻辑（尤其适合连通块问题）
- **技巧4：状态分层标记** - 使用不同数字(0:海,1:陆,2:外海,3:已统计岛)清晰区分状态

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合优质题解思路的稳健实现，采用Qianmo_su的边界扩展法，结合ZhaoV1的清晰BFS结构
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 55;
typedef pair<int, int> PII;
int n, m;
char g[N][N];
bool vis[N][N];
int dx4[4] = {0, 1, 0, -1}, dy4[4] = {1, 0, -1, 0};   // 岛屿移动
int dx8[8] = {-1, -1, 0, 1, 1, 1, 0, -1}, dy8[8] = {0, 1, 1, 1, 0, -1, -1, -1}; // 海水移动

void bfsIsland(int x, int y, int& ans) {
    ans++;
    queue<PII> q;
    q.push({x, y});
    vis[x][y] = true;
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (int i = 0; i < 4; i++) { // 四向扩展岛屿
            int nx = x + dx4[i], ny = y + dy4[i];
            if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
            if (!vis[nx][ny] && g[nx][ny] == '1') {
                vis[nx][ny] = true;
                q.push({nx, ny});
            }
        }
    }
}

void bfsOcean() {
    queue<PII> q;
    q.push({0, 0});
    vis[0][0] = true;
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (int i = 0; i < 8; i++) { // 八向扩展海水
            int nx = x + dx8[i], ny = y + dy8[i];
            if (nx < 0 || nx > n + 1 || ny < 0 || ny > m + 1) continue;
            if (!vis[nx][ny]) {
                if (g[nx][ny] == '1') bfsIsland(nx, ny, ans);
                else {
                    vis[nx][ny] = true;
                    q.push({nx, ny});
                }
            }
        }
    }
}

int main() {
    int T; cin >> T;
    while (T--) {
        memset(vis, false, sizeof vis);
        memset(g, '0', sizeof g); // 扩展边界自动为0
        cin >> n >> m;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= m; j++)
                cin >> g[i][j];
        
        int ans = 0;
        bfsOcean();
        cout << ans << endl;
    }
}
```
* **代码解读概要**：
> 1. 初始化时扩展地图边界（默认填充海水）
> 2. 从(0,0)开始BFS遍历海水（8方向）
> 3. 遇到陆地时启动岛屿BFS（4方向）并计数
> 4. 通过vis数组避免重复访问

---

**题解二：Qianmo_su**
* **亮点**：地图边界扩展法处理最完备
* **核心代码片段**：
```cpp
// 初始化扩展边界
for (int i = 1; i <= n; i++)
    for (int j = 1; j <= m; j++)
        cin >> g[i][j];

// 海水BFS（8方向）
void bfsOcean() {
    queue<PII> q;
    q.push({0, 0});
    vis[0][0] = true;
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (int i = 0; i < 8; i++) {
            int nx = x + dx8[i], ny = y + dy8[i];
            if (nx < 0 || nx > n + 1 || ny < 0 || ny > m + 1) continue;
            if (!vis[nx][ny]) {
                if (g[nx][ny] == '1') bfsIsland(nx, ny); // 遇到陆地
                else q.push({nx, ny}); // 继续扩展海水
            }
        }
    }
}
```
* **代码解读**：
> 关键点在于地图坐标范围处理：`nx > n+1` 而非 `nx > n`，确保覆盖扩展的边界。当海水遇到陆地时，立即调用bfsIsland进行4方向扩展，此时传入的(nx,ny)必定是主岛屿的入口点
* 💡 **学习笔记**：扩展边界法将特殊边界转化为普通情况处理，大幅降低算法复杂度

**题解三：brofea5**
* **亮点**：最简洁的DFS实现
* **核心代码片段**：
```cpp
void dfsOcean(int x, int y) {
    mp[x][y] = 2; // 标记外海
    for (int i = 0; i < 8; i++) {
        int nx = x + step[i][0], ny = y + step[i][1];
        if (nx < 0 || nx > n + 1 || ny < 0 || ny > m + 1) continue;
        if (mp[nx][ny] == 0) dfsOcean(nx, ny);
    }
}

// 陆地DFS（4方向）
void dfsIsland(int x, int y) {
    mp[x][y] = 3;
    for (int i = 0; i < 4; i++) { // 仅四向!
        int nx = x + step[i][0], ny = y + step[i][1];
        if (mp[nx][ny] == 1) dfsIsland(nx, ny);
    }
}
```
* **代码解读**：
> 通过修改原地图值进行状态标记（2=外海，3=已统计岛）。注意陆地DFS仅使用前4个方向（step[0]-step[3]）。亮点在于状态存储与地图数组复用，但修改原数据的做法在工程中需谨慎
* 💡 **学习笔记**：DFS代码更简洁但需注意递归深度限制（本题50x50网格安全）

---

## 5. 算法可视化：像素动画演示

* **动画主题**：<span style="color: #3498db">像素海岛探险</span>
* **核心演示**：海水从边界涌入，标记外海并触发主岛屿扩展

**设计思路**：采用FC红白机《塞尔达传说》的像素风格，用颜色区分：
- 深蓝(#3498db)：外海
- 浅蓝(#85C1E9)：内海
- 绿色(#2ECC71)：主岛屿
- 红色(#E74C3C)：子岛屿（不计数）

**动画流程**：
1. **初始化**：像素网格地图（50x50），控制面板含步进/播放/重置按钮和速度滑块
2. **海水扩散**：
   - 从(0,0)开始，深蓝像素块按8方向波浪式扩散
   - 每次扩散播放"水滴"音效(300Hz正弦波)
3. **发现岛屿**：
   - 当海水接触陆地时，该格子闪烁3次并播放"发现"音效(800Hz)
   - 启动4方向岛屿扩展动画：绿色像素块以"推箱子"效果蔓延
4. **子岛屿标识**：
   - 无法接触深蓝海水的陆地自动变为红色
   - 显示"子岛屿不计数"提示
5. **游戏化元素**：
   - 每统计一个主岛屿，右上角岛屿计数器+1并播放"胜利"音效
   - 通关后显示总岛屿数，像素角色举旗庆祝

**技术实现**：
```javascript
// 伪代码：核心动画循环
function animateStep() {
    if (currentMode == OCEAN_BFS) {
        spreadOcean(); // 8方向扩散
        if (touchesLand()) {
            playSound('discover');
            currentMode = ISLAND_BFS;
        }
    } 
    else if (currentMode == ISLAND_BFS) {
        spreadIsland(); // 4方向扩散
        if (islandComplete()) {
            playSound('victory');
            counter++;
            currentMode = OCEAN_BFS;
        }
    }
}
```

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**：外海标记法可推广至：
  1. 检测封闭区域（如P1162填涂颜色）
  2. 处理带孔洞的几何图形
  3. 多层嵌套结构分析

* **洛谷练习推荐**：
  1. [P1162 填涂颜色](https://www.luogu.com.cn/problem/P1162) - 外海标记法的直接应用
  2. [P1506 拯救oibh总部](https://www.luogu.com.cn/problem/P1506) - 洪水填充的变体
  3. [P3958 奶酪](https://www.luogu.com.cn/problem/P3958) - 3D空间连通块检测

---

## 7. 学习心得与经验分享

> **经验分享**（来自题解作者）：
> "最初卡在如何区分内外海，后来意识到只需要从边界海水开始扩散即可，不需要复杂找环算法"
>
> **Kay点评**：这印证了算法设计中的**KISS原则**（Keep It Simple, Stupid）。复杂问题往往有简洁解法，关键在于转换视角！

---

通过本次分析，我们掌握了连通块问题的创新解法——外海标记法，并学会用像素动画直观理解算法流程。继续加油，未来的算法大师！🚀

---
处理用时：181.01秒
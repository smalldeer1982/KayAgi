# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果

# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：容斥原理 + 状压枚举 + 并查集应用


🗣️ **初步分析**：  
解决“Mivik 写书”的关键，是把**期望计算**转化为**总和计算**（因为期望 = 所有字符串的复杂度之和 ÷ 总方案数 $m^n$）。而计算“所有字符串的复杂度之和”的核心，是统计**每个本质不同的子串**在多少个原字符串中出现过——这一步需要用**容斥原理**解决重复计数问题。  

简单来说，容斥就像“统计苹果时，先算所有可能，再减去重复拿的，再加回多减的”。在本题中：  
- 我们枚举子串的**长度x**（1到n），再用**二进制状压**枚举这个子串在原字符串中的**出现位置集合S**（比如S=101表示子串出现在第1位和第3位）。  
- 对于每个S，用**并查集**维护“这些位置的字符必须相同”的约束（比如子串出现在位置1和3，那么位置1的第k个字符必须等于位置3的第k个字符）。  
- 最后用**容斥系数** $(-1)^{|S|+1}$ 调整重复计数（出现奇数次加，偶数次减），确保每个本质不同的子串只被计算一次。  

**可视化设计思路**：  
我们会用8位像素风格模拟字符串位置（比如用20个像素块代表长度为20的字符串），用不同颜色标记子串的出现位置（比如红色表示选中的位置），并查集合并时用“像素块融合”动画展示，容斥系数用文字气泡提示。关键操作（如选中位置、合并集合）会伴随轻微的“叮”“嗒”音效，帮助强化记忆。


## 2. 精选优质题解参考

### 题解一：Huasushis（清晰的容斥逻辑 + 新手友好）  
* **点评**：这份题解把容斥的思路拆解得非常直白——先枚举子串长度，再枚举出现位置的二进制状态，用并查集维护字符相同的约束，最后用容斥系数调整贡献。代码中的`sol`函数逐个处理每个子串长度，`getfa`函数实现并查集，`qp`函数处理快速幂（模运算必备）。特别值得学习的是**位运算优化**（比如用`c = (c << 1) | ((i >> j) & 1)`维护最近x位的状态）和**容斥系数的应用**（用`__builtin_parity(i)`判断二进制中1的个数奇偶性）。代码结构清晰，注释明确，非常适合新手理解容斥的核心逻辑。


### 题解二：Reunite（简洁的状态处理 + 高效实现）  
* **点评**：此题解的亮点是**将出现位置的集合转化为数组标记**（`mp`数组记录每个位置被哪些子串位置覆盖），并用并查集合并需要相同的字符位置。`work`函数中的`ss`变量统计“自由选择的字符数”（未被覆盖的位置 + 并查集的连通块数），直接对应`m^{ss}`的方案数。容斥系数的处理（`tt&1?1:-1`）简洁明了，代码的时间复杂度控制得很好（$O(n^22^n\alpha(n))$，$\alpha$是并查集的阿克曼函数反函数，几乎可以视为常数），适合学习高效的状压容斥实现。


### 题解三：rainygame（极简代码 + 核心逻辑提炼）  
* **点评**：这份题解的代码极其简洁，用`c`数组记录每个位置对应的子串位置，`iota(f, f+x+1, 0)`快速初始化并查集，`__builtin_parity(i)`直接获取二进制中1的个数奇偶性。关键的约束处理（`if (~c[j+k]) f[find(k)] = find(c[j+k]); else c[j+k] = k;`）用一行代码完成，充分体现了**代码的简洁性**。适合学习如何用最少的代码实现核心逻辑，同时保持可读性。


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何将期望转化为总和计算？**  
- **分析**：期望的定义是“所有可能结果的平均值”，所以本题的期望 = （所有字符串的本质不同子串数目之和） ÷ （总方案数 $m^n$）。由于模运算中的除法需要用**逆元**（$a÷b \equiv a \times b^{-1} \mod MOD$），所以最后需要将总和乘以 $m^{-n} \mod MOD$。  
- 💡 **学习笔记**：期望问题常转化为总和问题，模运算中的除法用逆元解决。


### 2. **难点2：如何用容斥处理重复计数？**  
- **分析**：直接枚举子串会重复计算（比如子串“a”在“aa”中出现两次，但本质上只算一个）。容斥的核心是**通过正负系数调整重复**：对于出现位置集合S，系数是 $(-1)^{|S|+1}$（出现奇数次加，偶数次减），确保每个本质不同的子串只被计算一次。  
- 💡 **学习笔记**：容斥的关键是设计合适的系数，抵消重复计数。


### 3. **难点3：如何维护字符相同的约束？**  
- **分析**：当子串出现在多个位置时，这些位置的对应字符必须相同（比如子串出现在位置1和3，那么位置1的第k个字符必须等于位置3的第k个字符）。并查集可以高效维护这种“等价关系”——把需要相同的字符位置合并成一个集合，最后统计集合的数量（即自由选择的字符数）。  
- 💡 **学习笔记**：并查集是处理“等价关系”的利器，常用于维护约束条件。


### ✨ 解题技巧总结  
- **技巧1：问题转化**：将期望问题转化为总和问题，避免直接处理概率。  
- **技巧2：状压枚举**：用二进制表示出现位置的集合，适合n较小的情况（本题n≤20）。  
- **技巧3：并查集维护约束**：合并需要相同的字符位置，快速计算自由选择的字符数。  
- **技巧4：逆元计算**：模运算中的除法用快速幂求逆元（$a^{-1} \equiv a^{MOD-2} \mod MOD$，当MOD是质数时）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合Huasushis、Reunite和rainygame的题解思路，提炼出的清晰实现。  

```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;

typedef long long ll;
const int MOD = 1e9 + 7;
int n;
ll m;

ll qpow(ll x, ll y) { // 快速幂，计算x^y mod MOD
    ll res = 1;
    while (y) {
        if (y & 1) res = res * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return res;
}

int fa[25];
int getfa(int x) { // 并查集查找（路径压缩）
    return x == fa[x] ? x : fa[x] = getfa(fa[x]);
}

ll ans = 0;

void solve(int x) { // 处理长度为x的子串
    int max_s = 1 << (n - x + 1); // 出现位置的状态数（二进制位数）
    int mask = (1 << x) - 1; // 用于维护最近x位的状态

    for (int s = 1; s < max_s; ++s) { // 枚举所有非空的出现位置集合
        // 初始化并查集（子串的x个位置）
        for (int j = 0; j < x; ++j) fa[j] = j;
        int c = 0; // 维护最近x位的状态
        int free = 0; // 未被覆盖的位置数

        for (int j = 0; j < n; ++j) { // 遍历原字符串的每个位置
            c = (c << 1) | ((s >> j) & 1); // 更新最近x位的状态
            c &= mask; // 保留x位

            if (c == 0) {
                free++; // 未被覆盖，自由选择
            } else {
                // 合并需要相同的字符位置
                int lowest = c & -c; // 取最低位的1
                int root = getfa(__builtin_ctz(lowest)); // 最低位对应的子串位置
                int temp = c - lowest; // 剩下的位
                while (temp) {
                    int bit = temp & -temp;
                    int pos = __builtin_ctz(bit);
                    fa[getfa(pos)] = root;
                    temp -= bit;
                }
            }
        }

        // 统计子串中的连通块数（自由选择的字符数）
        for (int j = 0; j < x; ++j) {
            if (fa[j] == j) free++;
        }

        // 计算贡献：容斥系数 * m^free
        ll contrib = qpow(m, free);
        if (__builtin_parity(s)) { // 1的个数为奇数，加
            ans = (ans + contrib) % MOD;
        } else { // 偶数，减（加MOD避免负数）
            ans = (ans - contrib + MOD) % MOD;
        }
    }
}

int main() {
    cin >> n >> m;
    for (int x = 1; x <= n; ++x) { // 枚举子串长度
        solve(x);
    }
    // 计算期望：ans / m^n = ans * inv(m^n) mod MOD
    ll inv_total = qpow(qpow(m, n), MOD - 2);
    cout << ans * inv_total % MOD << endl;
    return 0;
}
```

* **代码解读概要**：  
  1. **快速幂`qpow`**：处理模运算中的幂次和逆元。  
  2. **并查集`getfa`**：维护字符相同的约束，路径压缩优化。  
  3. **`solve`函数**：枚举子串长度x，再枚举出现位置的二进制状态s，用并查集合并约束，计算自由选择的字符数`free`，最后用容斥系数调整贡献。  
  4. **主函数**：遍历所有子串长度，计算总和`ans`，最后乘以总方案数的逆元得到期望。


### 题解一（Huasushis）片段赏析  
* **亮点**：用位运算维护最近x位的状态，简洁处理子串的出现位置。  
* **核心代码片段**：  
  ```cpp
  c = (c << 1) | ((i >> j) & 1); // 更新最近x位的状态
  c &= b; // 保留x位
  if (!c) {
      ++tot; // 未被覆盖
  } else {
      int t = c - (c & -c), tmp = getfa(__builtin_ctz(c));
      while (t) {
          fa[getfa(__builtin_ctz(t))] = tmp;
          t -= t & -t;
      }
  }
  ```
* **代码解读**：  
  - `c`变量维护最近x位的状态（比如x=2时，c的二进制表示最近2位的出现情况）。  
  - `c &= b`（b是`(1<<x)-1`）确保`c`只有x位。  
  - 当`c`不为0时，取最低位的1（`c&-c`）对应的子串位置`tmp`，然后合并其他位对应的位置（`t = c - lowest`），确保这些位置的字符相同。  
* 💡 **学习笔记**：位运算可以高效维护连续的状态，是状压枚举的关键技巧。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：像素字符串的“容斥大冒险”  
**设计思路**：用8位像素风格模拟字符串位置，通过“选中位置→合并约束→计算贡献”的流程，直观展示容斥的核心逻辑。复古游戏元素（如像素音效、关卡进度）能提升趣味性，帮助记忆关键步骤。


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕显示20个像素块（代表长度为20的字符串），背景是FC风格的蓝色网格。  
   - 控制面板有“开始/暂停”“单步”“重置”按钮，以及速度滑块（1x~5x）。  
   - 8位风格的背景音乐（轻快的电子音）循环播放。

2. **子串长度选择**：  
   - 顶部文字提示“当前处理子串长度x=2”，并用黄色框标出前2个像素块（子串的模板）。

3. **状压枚举出现位置**：  
   - 二进制状态s=101（第1、3位选中），对应的像素块变成红色（闪烁提示“选中位置”），伴随“叮”的音效。

4. **并查集合并约束**：  
   - 子串出现在位置1和3，位置1的第1个字符（像素块1）与位置3的第1个字符（像素块3）合并——两个像素块变成绿色，中间有“融合”动画，伴随“嗒”的音效。  
   - 位置1的第2个字符（像素块2）与位置3的第2个字符（像素块4）合并，同样变成绿色。

5. **计算自由字符数**：  
   - 未被覆盖的像素块（如5~20）保持白色，显示“自由选择”的文字提示。  
   - 绿色的连通块数（2个）加上白色块数（16个），总自由数18，显示“m^18”的文字。

6. **容斥系数调整**：  
   - 状态s的1的个数是2（偶数），显示“-m^18”的文字，伴随“滴”的音效（表示减去贡献）。

7. **结果展示**：  
   - 所有步骤完成后，屏幕显示当前总和`ans`的数值，以及“当前进度：x=2，s=101”的提示。


### 交互设计  
- **单步执行**：点击“单步”按钮，动画执行下一步（如从选中位置到合并约束）。  
- **自动播放**：点击“自动”按钮，动画按设定速度（滑块调整）连续执行。  
- **重置**：点击“重置”按钮，回到初始状态，重新选择子串长度。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
本题的**容斥+状压+并查集**思路，可用于解决以下问题：  
1. **统计不同子序列的数目**：类似子串，但子序列不需要连续，容斥处理重复。  
2. **约束下的字符串计数**：比如要求某些位置的字符相同，用并查集维护约束。  
3. **概率/期望问题**：转化为总和问题，用容斥计算每个元素的贡献。


### 洛谷练习推荐  
1. **洛谷 P2515** - [HH去散步](https://www.luogu.com.cn/problem/P2515)  
   - 🗣️ **推荐理由**：需要用容斥处理重复的路径，类似本题的子串重复计数，适合巩固容斥思维。

2. **洛谷 P3197** - [[HNOI2008]越狱](https://www.luogu.com.cn/problem/P3197)  
   - 🗣️ **推荐理由**：用容斥计算“至少有两个相邻犯人相同”的情况，是容斥的经典应用，帮助理解逆问题的处理。

3. **洛谷 P4316** - [绿豆蛙的归宿](https://www.luogu.com.cn/problem/P4316)  
   - 🗣️ **推荐理由**：期望问题的转化，需要计算每条边的贡献，类似本题的子串贡献计算，适合巩固期望转总和的技巧。


## 7. 学习心得与经验分享 (若有)  
> **参考经验 (来自Huasushis)**：“我在解决这个问题时，最初在处理子串的重叠位置时卡了很久，后来通过用位运算维护最近x位的状态，才理清了约束关系。这让我意识到，位运算在状压问题中是非常有效的工具。”  
> **点评**：这位作者的经验很典型——状压问题中，位运算能高效维护状态，避免繁琐的数组操作。比如用`c = (c << 1) | ((i >> j) & 1)`维护最近x位的状态，比用数组记录更简洁、更快。


## 结语  
本次关于“Mivik 写书”的分析，我们学习了**容斥原理**的核心逻辑、**状压枚举**的应用，以及**并查集**维护约束的技巧。希望这份指南能帮助你理解如何将复杂的期望问题拆解成可解决的步骤。记住：编程的关键是“拆解问题”——把大问题拆成小问题，逐个解决，你就能攻克任何难题！💪

---
处理用时：90.44秒
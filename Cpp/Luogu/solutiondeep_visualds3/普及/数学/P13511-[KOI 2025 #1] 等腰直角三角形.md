# 题目信息

# [KOI 2025 #1] 等腰直角三角形

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在二维平面上有 $N$ 个不同的点。对于每个 $1 \le i \le N$ 的 $i$，第 $i$ 个点的坐标为 $(x_i, y_i)$。

**等腰三角形**是指三条边中有两条边长度相等的三角形。**直角三角形**是指一个内角为直角 ($90^\circ$) 的三角形。直角三角形的**斜边**是指直角三角形中与直角相对的边，也是长度最长的边。**等腰直角三角形**是指既是直角三角形又是等腰三角形的三角形。即，三角形的一个内角为直角，且除斜边外的两条直角边长度相等的三角形。

请编写一个程序，找出满足以下两个条件的所有等腰直角三角形中，斜边长度最短的那个，并输出其斜边长度。

*   $N$ 个点 $(x_1, y_1), (x_2, y_2), \cdots, (x_N, y_N)$ 都位于等腰直角三角形的边界（边上）或其内部。如果某个点位于等腰直角三角形的顶点上，也视为位于边界上。
*   斜边与 $x$ 轴平行。也就是说，等腰直角三角形斜边的两个端点的 $y$ 坐标相同。这意味着只有如下图所示的两种等腰直角三角形满足条件：直角顶点在斜边上方的，和直角顶点在斜边下方的。

![](https://cdn.luogu.com.cn/upload/image_hosting/0w0uc9ek.png)

例如，假设给定如下图所示的 5 个点：$(0, -1), (2, 4), (4, -1), (-1, 2), (3, 1)$。点本身没有大小，但在图中为了方便观察，用圆形表示。

![](https://cdn.luogu.com.cn/upload/image_hosting/fmja5mno.png)

在直角顶点位于斜边上方的等腰直角三角形中，斜边最短的是如下图所示的，三个顶点为 $(1.5, 4.5), (-4, -1), (7, -1)$ 的三角形，这个等腰直角三角形的斜边长度为 11。

![](https://cdn.luogu.com.cn/upload/image_hosting/enf2ln2g.png)

在直角顶点位于斜边下方的等腰直角三角形中，斜边最短的是如下图所示的，三个顶点为 $(2, -3), (-5, 4), (9, 4)$ 的三角形，这个等腰直角三角形的斜边长度为 14。

![](https://cdn.luogu.com.cn/upload/image_hosting/s894fwzi.png)

在这两种等腰直角三角形中，斜边较短的是直角顶点位于斜边上方的情况，因此所求的长度为 11。

## 说明/提示

### 样例 1 解释

以 $(-1, 0), (2, 3), (5, 0)$ 为三个顶点的等腰直角三角形满足所有条件，其斜边长度为 6，是最短的。

![](https://cdn.luogu.com.cn/upload/image_hosting/k7ar4xmy.png)

### 样例 2 解释

满足所有条件且斜边长度为 7 的等腰直角三角形有如下两种。

*   以 $(0, 0), (7, 0), (3.5, 3.5)$ 为三个顶点的三角形

![](https://cdn.luogu.com.cn/upload/image_hosting/ynedwi5a.png)

*   以 $(-2, 2), (5, 2), (1.5, -1.5)$ 为三个顶点的三角形

![](https://cdn.luogu.com.cn/upload/image_hosting/8ye5d49n.png)

### 限制条件

*   给定的所有数都是整数。
*   $2 \le N \le 100,000$。
*   对于每个 $1 \le i \le N$ 的 $i$，有 $-100,000,000 \le x_i, y_i \le 100,000,000$。
*   给定的 $N$ 个点都各不相同。也就是说，对于所有 $1 \le i < j \le N$ 的 $i, j$，都有 $x_i \ne x_j$ 或 $y_i \ne y_j$。

### 子任务

1.  (10 分) $N \le 2$。
2.  (18 分) $N \le 3$。
3.  (20 分) $N \le 50$，且对于每个 $1 \le i \le N$ 的 $i$，有 $-30 \le x_i, y_i \le 30$。
4.  (10 分) $N \le 50$。
5.  (4 分) 对于每个 $2 \le i \le N$ 的 $i$，有 $y_i = y_{i-1}$。也就是说，所有点的 $y$ 坐标都相同。
6.  (6 分) 对于每个 $1 \le i \le N$ 的 $i$，有 $x_i = y_i$。
7.  (10 分) 在所有满足给定条件且斜边长度最短的等腰直角三角形中，至少有一个的斜边中点是 $(0, 0)$。
8.  (22 分) 无附加限制条件。

## 样例 #1

### 输入

```
3
0 0
2 3
4 0```

### 输出

```
6```

## 样例 #2

### 输入

```
2
0 0
5 2```

### 输出

```
7```

## 样例 #3

### 输入

```
4
1 5
3 2
6 6
7 4```

### 输出

```
10```

# AI分析结果

# 💡 Kay的C++算法解析：等腰直角三角形 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（几何性质应用） + 编程技巧（极值计算）


🗣️ **初步分析**：  
这道题像“给所有点找一个‘最小的等腰直角保护伞’”——保护伞的斜边必须平行于x轴，还得把所有点都罩住。核心思路其实是**用几何性质把“保护伞”的约束转化为数学极值问题**：  
- 等腰直角三角形的两条直角边斜率是1和-1（像“V”字或倒“V”字），所以每个点$(x,y)$会对应两个关键值：$u=x-y$（对应斜率1的直线截距）、$v=x+y$（对应斜率-1的直线截距）。  
- 要罩住所有点，“V”字的两边必须刚好碰到**最外面的点**（比如$u$的最小值、$v$的最大值），而斜边必须贴住**最下面的点**（y最小）或**最上面的点**（y最大）——这样才能让斜边最短。  

**核心算法流程**：  
1. 计算所有点的$u=x-y$、$v=x+y$，以及y的最小（$miny$）、最大值（$maxy$）。  
2. 情况1（直角顶点在上）：斜边在$y=miny$，左右端点由$u_{min}$和$v_{max}$计算（左端点$u_{min}+miny$，右端点$v_{max}-miny$），斜边长度是右端点-左端点。  
3. 情况2（直角顶点在下）：斜边在$y=maxy$，左右端点由$v_{min}$和$u_{max}$计算（左端点$v_{min}-maxy$，右端点$u_{max}+maxy$），斜边长度同样是差。  
4. 取两种情况的最小值。  

**可视化设计思路**：  
用8位像素风格模拟“点云”和“保护伞”生成过程——  
- 屏幕左边是像素化的坐标系，点用彩色小方块表示，$miny$和$maxy$用黄色横线标记。  
- 计算$u_{min}$时，对应点会闪烁蓝色；计算$v_{max}$时，对应点闪烁红色。  
- 动态画出“V”字的两条直角边（蓝色和红色像素线），最后画出斜边（绿色横线），伴随“叮”的音效表示计算完成。  
- 控制面板有“单步执行”（分步看极值计算→斜边生成→长度比较）和“自动播放”，像“像素工程师”一步步搭建保护伞。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和实践价值出发，筛选了3份优质题解，帮你快速抓住核心！
</eval_intro>


### 题解一：jwb1234（来源：洛谷用户）
* **点评**：这份题解把几何约束转化为极值计算的思路讲得最直白！它用“红线（y=x+maxa）”“蓝线（y=-x+maxb）”的比喻，直接对应$u$和$v$的极值，还明确指出“斜边必须贴住miny/maxy”——这是解决问题的关键突破口。代码只用了最基础的变量（maxa、mina、maxb、minb），没有冗余，甚至连注释都不用就能看懂逻辑，非常适合入门！


### 题解二：liuyuhan1522（来源：洛谷用户）
* **点评**：此题解的亮点是**把每个步骤的数学推导写得明明白白**——比如“左顶点$x_l=u_{min}+miny$”是怎么来的？它直接列了方程推导，像做数学题一样严谨。代码里用`LONG_LONG_MAX`/`LONG_LONG_MIN`处理极值，避免了整数溢出问题，细节很到位！赛时写这种代码，绝对不会因为边界问题WA（Wrong Answer）。


### 题解三：jsisonx（来源：洛谷用户）
* **点评**：这份题解的“问题分析”部分像“解题钥匙”——它直接点出“斜边必须在y最小或最大处”“直角边必须经过最外面的点”，把题目的“隐含条件”挑明了。代码里用`struct point`存储点，函数`up()`/`down()`分开处理两种情况，结构清晰，甚至可以直接复制到比赛里用！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“坎”主要在“几何约束→数学条件”的转化，我帮你梳理了3个核心难点和对应的突破方法：
</difficulty_intro>


### 1. 难点1：如何把“等腰直角三角形罩住所有点”转化为数学条件？
* **分析**：等腰直角三角形的两条直角边斜率是1和-1，所以每个点$(x,y)$必须满足：  
  - 对于顶点在上的三角形：$y \geq miny$（在斜边上方）、$x-y \geq u_{min}$（在斜率1的边右侧）、$x+y \leq v_{max}$（在斜率-1的边左侧）。  
  - 这些条件合并起来，就是要找$u_{min}$（x-y的最小值）、$v_{max}$（x+y的最大值）、$miny$（y的最小值）。  
* 💡 **学习笔记**：几何问题先找“约束条件”，再把约束翻译成“变量的极值”——这是几何题的通用技巧！


### 2. 难点2：为什么斜边必须在y最小或最大处？
* **分析**：如果斜边不在$miny$（比如在$miny+1$），那罩住所有点的斜边长度会更长——因为$miny$处的点刚好贴住斜边，再往上移会让左右端点更“开”，长度变大。同理，下方的斜边必须在$maxy$处。  
* 💡 **学习笔记**：“最短长度”往往对应“刚好覆盖边界点”——这是极值问题的常见规律！


### 3. 难点3：如何正确计算左右端点的坐标？
* **分析**：以顶点在上的情况为例，斜率1的边方程是$y = x + (y - x)$（截距是$y-x$），当斜边在$miny$时，这条边与斜边的交点是$x = miny - (y-x)$——而$y-x$的最小值是$u_{min}$，所以左端点是$u_{min} + miny$。同理，斜率-1的边交点是$v_{max} - miny$。  
* 💡 **学习笔记**：遇到直线交点问题，直接联立方程！比如“求$y=miny$与$y=x+b$的交点”，代入$y$就能算出$x$。


### ✨ 解题技巧总结
- **几何转极值**：把“罩住所有点”的几何约束，转化为“求变量的最大/最小值”——这比遍历所有可能的三角形高效100倍！  
- **边界优先**：最短长度一定对应“贴住边界点”（miny/maxy、u的极值、v的极值），不用考虑中间情况。  
- **代码简洁性**：用基础变量（maxa、mina等）代替复杂数据结构，减少出错概率。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**——它综合了所有优质题解的思路，用最简洁的代码解决问题！
</code_intro_overall>


### 本题通用核心C++实现参考
* **说明**：本代码来自jwb1234的题解，保留了最核心的极值计算逻辑，没有冗余代码，适合直接复制练习。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <climits>  // 用于INT_MIN/INT_MAX
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);  // 加速输入输出

    int n;
    cin >> n;

    int maxa = INT_MIN, mina = INT_MAX;  // a = y - x
    int maxb = INT_MIN, minb = INT_MAX;  // b = y + x
    int miny = INT_MAX, maxy = INT_MIN;  // y的最小/最大值

    for (int i = 0; i < n; ++i) {
        int x, y;
        cin >> x >> y;
        int a = y - x;
        int b = y + x;
        maxa = max(maxa, a);
        mina = min(mina, a);
        maxb = max(maxb, b);
        minb = min(minb, b);
        miny = min(miny, y);
        maxy = max(maxy, y);
    }

    // 情况1：直角顶点在上，斜边在miny
    int sum1 = (maxb - miny) - (miny - maxa);
    // 情况2：直角顶点在下，斜边在maxy
    int sum2 = (maxy - mina) - (minb - maxy);

    cout << min(sum1, sum2) << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：用`ios::sync_with_stdio(false)`加速输入（处理1e5个点时很关键！）。  
  2. **极值计算**：遍历所有点，计算$y-x$（a）、$y+x$（b）、y的最大/最小值——这是整个算法的核心！  
  3. **长度计算**：用极值公式算出两种情况的斜边长度，取最小值输出。  


<code_intro_selected>
接下来看优质题解的核心片段，拆解它们的“小技巧”！
</code_intro_selected>


### 题解一：jwb1234（来源：洛谷用户）
* **亮点**：用最基础的变量对应几何约束，没有任何冗余！  
* **核心代码片段**：
```cpp
int a = y - x;
int b = y + x;
maxa = max(maxa, a);
mina = min(mina, a);
maxb = max(maxb, b);
minb = min(minb, b);
miny = min(miny, y);
maxy = max(maxy, y);
```
* **代码解读**：  
  这段代码是“极值计算的心脏”！每个变量都对应一个几何约束：  
  - `a = y - x`：对应斜率1的直线截距（$y = x + a$），`maxa`是这些截距的最大值——因为顶点在上的三角形，这条边要“刚好罩住最外面的点”。  
  - `b = y + x`：对应斜率-1的直线截距（$y = -x + b$），`maxb`是截距的最大值——同理，这条边要罩住最外面的点。  
  - `miny`和`maxy`：直接对应斜边的位置（必须贴住最小/最大的y）。  
* 💡 **学习笔记**：变量名要“见名知意”——比如`maxa`对应“a的最大值”，比`tmp1`/`tmp2`好一百倍！


### 题解二：liuyuhan1522（来源：洛谷用户）
* **亮点**：用`LONG_LONG`避免整数溢出（比如x=1e8时，x+y可能超过int范围）！  
* **核心代码片段**：
```cpp
l = LONG_LONG_MAX, r = LONG_LONG_MIN;
u = LONG_LONG_MAX;
for (int i = 1; i <= n; ++i) {
    l = min(x[i] - y[i], l);  // u_min = x - y的最小值
    r = max(x[i] + y[i], r);  // v_max = x + y的最大值
    u = min(y[i], u);          // miny
}
lx = l + u;  // 左端点
rx = r - u;  // 右端点
ans = rx - lx;
```
* **代码解读**：  
  这里的`LONG_LONG_MAX`是C++里的“长整型最大值”，用来存储1e8级别的数（比如x=1e8，y=1e8，x+y=2e8，超过int的范围）。`lx = l + u`对应左端点公式（$u_{min} + miny$），`rx = r - u`对应右端点（$v_{max} - miny$）——直接把数学公式写成代码，非常直观！  
* 💡 **学习笔记**：处理大数时，一定要用`long long`！否则会出现“溢出错误”（比如计算结果变成负数）。


### 题解三：jsisonx（来源：洛谷用户）
* **亮点**：用`struct point`封装点，函数`up()`/`down()`分开处理两种情况，结构清晰！  
* **核心代码片段**：
```cpp
struct point { long long x, y; };
point p[N];

void up(int n) {
    int maxw1 = 1, maxw2 = 1;
    for (int i = 2; i <= n; ++i) {
        if (p[i].x + p[i].y > p[maxw1].x + p[maxw1].y) maxw1 = i;
        if (p[i].y - p[i].x > p[maxw2].y - p[maxw2].x) maxw2 = i;
    }
    long long x1 = p[maxw1].x + p[maxw1].y - minl;
    long long x2 = minl - (p[maxw2].y - p[maxw2].x);
    ans1 = abs(x1 - x2);
}
```
* **代码解读**：  
  1. **结构体封装**：用`struct point`存储点的x、y，比分开用两个数组更清晰（比如`p[i].x`比`x[i]`更易读）。  
  2. **函数拆分**：`up()`专门处理顶点在上的情况，`down()`处理在下的情况——代码模块化后，即使改逻辑也不会乱！  
  3. **公式应用**：`x1 = p[maxw1].x + p[maxw1].y - minl`对应$v_{max} - miny$，`x2 = minl - (p[maxw2].y - p[maxw2].x)`对应$miny - (y-x)_{max}$（即$u_{max} + miny$？不，等一下——这里`p[maxw2].y - p[maxw2].x`是$y-x$的最大值，所以`minl - (y-x)_{max}`就是$miny - (y-x)_{max}$，对应左端点公式$x_l = (y-x)_{max} + miny$？哦，对！因为$y-x = a$，所以$x = y - a$——当$y=miny$时，$x = miny - a_{max}$，也就是左端点！  
* 💡 **学习笔记**：代码模块化（拆分成函数）能让逻辑更清晰，尤其是处理“两种情况”时！


## 4. 核心难点辨析与解题策略（补充）
哦，刚才在第3节已经讲过核心难点啦，这里就不重复啦～


## 5. 算法可视化：像素动画演示

### 动画设计方案：像素保护伞生成记
* **主题**：像素工程师用“极值工具”给点云搭“等腰直角保护伞”，目标是让保护伞最短！  
* **核心演示内容**：  
  1. **场景初始化**：8位像素风格的坐标系，背景是浅灰色（像FC游戏的“地图编辑器”），点用彩色小方块表示（比如红色=输入点，蓝色=u_min点，绿色=v_max点）。  
  2. **极值计算**：  
     - 遍历点时，每个点闪烁一下（“正在计算它的a和b！”），计算到$u_min$（x-y最小）时，对应的点变成蓝色并闪烁；计算到$v_max$（x+y最大）时，变成绿色并闪烁。  
     - miny的位置用黄色横线标记（“斜边要贴这里！”）。  
  3. **斜边生成**：  
     - 从蓝色点（u_min）向右画一条斜率1的像素线（直到碰到miny横线），从绿色点（v_max）向左画一条斜率-1的像素线——两条线与miny的交点就是左右端点！  
     - 用绿色横线连接左右端点（“这就是保护伞的斜边！”），伴随“叮”的音效（表示生成成功）。  
  4. **两种情况对比**：自动切换到“顶点在下”的情况，重复步骤2-3，最后用大字体显示“最短长度是X！”，伴随胜利音效（像FC游戏通关的“叮——”）。  
* **交互设计**：  
  - 控制面板：“单步”（一步步看极值计算→斜边生成）、“自动”（快速播放整个过程）、“重置”（重新开始）。  
  - 速度滑块：调节动画速度（从“慢动作”到“快进”）。  
  - 音效开关：可以打开/关闭8位背景音乐（比如《超级马里奥》的小关卡音乐）。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“几何约束→极值计算”的技巧，可以解决很多类似问题！
</similar_problems_intro>


### 1. 通用思路迁移
- **适用场景**：所有“找最小几何图形覆盖所有点”的问题，比如：  
  - 找最小矩形覆盖所有点（矩形边平行于坐标轴）：计算x的min/max、y的min/max即可。  
  - 找最小圆覆盖所有点：用“最小包围圆算法”（类似极值，但更复杂）。  
  - 找斜边不平行于x轴的等腰直角三角形：需要旋转坐标系（比如旋转45度，把斜边变成平行于x轴）。  


### 2. 练习推荐（洛谷）
1. **洛谷 P1873** - 二维平面最近点对  
   * 🗣️ **推荐理由**：同样考察“极值计算”，但需要用分治优化（处理1e5个点时O(n log n)）——帮你巩固“处理大数据的极值技巧”！  
2. **洛谷 P2280** - 【HNOI2003】激光炸弹  
   * 🗣️ **推荐理由**：用前缀和处理二维极值，是“几何极值”的进阶版——学会用预处理优化极值计算！  
3. **洛谷 P3181** - 【HAOI2016】找相同字符  
   * 🗣️ **推荐理由**：虽然是字符串题，但核心是“找极值”（最长公共子串的数量）——帮你拓宽“极值应用”的思路！  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我挖到了两个“赛时避坑小技巧”，帮你少走弯路！
</insights_intro>


> **参考经验（来自liuyuhan1522）**：“赛时写这道题时有一种写数学大题的感觉——必须把每个公式推导清楚，否则代码肯定错！”  
> **点评**：几何题的核心是“数学推导”，写代码前一定要先在草稿纸上算清楚公式（比如左端点$x_l = u_{min} + miny$是怎么来的）——不然写代码时会“越写越乱”！  


> **参考经验（来自jwb1234）**：“处理1e5个点时，一定要用`ios::sync_with_stdio(false)`加速输入，否则会超时！”  
> **点评**：输入输出速度是处理大数据的关键！比如用`cin`读1e5个点，不加加速会慢到超时，加了之后能快10倍以上！  


## 8. 总结

本次分析让我们学会了：  
- 把“几何约束”转化为“数学极值”的核心技巧；  
- 用基础变量对应几何条件，写出简洁的代码；  
- 处理大数时用`long long`避免溢出；  
- 用像素动画直观理解算法过程。  

记住：几何题的本质是“找约束→转极值→算结果”，多练几道类似题，你会越来越熟练！下次我们再一起解决更复杂的几何问题～💪


--- 
**提示**：如果想亲手试试可视化动画，可以用HTML+Canvas写一个简单版本——比如用`ctx.fillRect()`画像素点，用`setInterval()`做单步执行，用`Audio()`加音效～ 快来当“像素工程师”吧！

---
处理用时：111.14秒
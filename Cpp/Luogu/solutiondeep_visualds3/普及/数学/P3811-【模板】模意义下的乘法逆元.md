# 题目信息

# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# AI分析结果


### 💡 Kay的C++算法解析：模意义下的乘法逆元 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`数学/逆元`  
🗣️ **初步分析**：
> 解决“模意义下的乘法逆元”这道题，关键在于理解并运用**线性递推求逆元**。简单来说，逆元是模运算中的“倒数”，用于将除法转换为乘法。在本题中，我们需要高效求出1~n所有数在模质数p下的逆元。
- **核心思路**：利用递推公式 `inv[i] = (p - p/i) * inv[p%i] % p`，从已知小数的逆元推导大数的逆元，避免重复计算。
- **算法流程**：初始化`inv[1]=1`，循环计算2~n的逆元。每次计算依赖`p%i`（小于i）的逆元，确保子问题已解决。
- **可视化设计**：采用8位像素风格展示拆解过程（如p=13时，i=3拆为13=4×3+1），高亮余数1的逆元（已知）参与计算新逆元。单步执行时可触发“拆解音效”和“计算音效”，成功时播放胜利音效。

---

#### 2. 精选优质题解参考
**题解一（来源：zcysky）**  
* **点评**：代码简洁高效（仅10行），直接应用递推公式，变量命名清晰（`inv[i]`）。算法时间复杂度O(n)，空间O(n)，完美匹配本题数据范围（n≤3e6）。边界处理严谨（从i=2开始递推），实践价值高，可直接用于竞赛。  

**题解二（来源：Rising_Date）**  
* **点评**：详细推导递推公式的数学原理（p=ki+r的变换），解释为什么`inv[i]`依赖`inv[p%i]`。代码包含注释和负数调整，逻辑严谨性突出，适合初学者理解本质。  

**题解三（来源：灵乌路空）**  
* **点评**：对比多种求逆元方法（费马/扩欧/线性/阶乘），最终推荐线性递推法。提供阶乘逆元拓展思路，虽本题不适用但启发性强。代码实现简洁，含可读性强的输出优化。  

---

#### 3. 核心难点辨析与解题策略
1. **难点1：递推公式的理解**  
   *分析*：公式 `inv[i] = (p - p/i) * inv[p%i] % p` 源于模等式 `p = k*i + r` 的变形。关键是将逆元计算转化为更小余数r的逆元问题。  
   💡 **学习笔记**：递推的核心是“自底向上”，用小问题的解构建大问题的解。

2. **难点2：负数处理的技巧**  
   *分析*：`(p - p/i)` 确保结果非负，避免模运算中负数取模的复杂性。  
   💡 **学习笔记**：在模p下，负数x等价于x+p，不影响结果。

3. **难点3：边界初始化**  
   *分析*：`inv[1] = 1` 是递推基础（1的逆元恒为1），需单独处理。  
   💡 **学习笔记**：递推算法必须明确初始状态。

✨ **解题技巧总结**：
- **技巧1（问题分解）**：将批量求逆元转化为线性递推，避免逐个计算高复杂度。
- **技巧2（空间换时间）**：用数组存储中间结果，O(n)空间换取O(n)时间。
- **技巧3（代码优化）**：即时输出代替存储，减少内存占用。

---

#### 4. C++核心代码实现赏析
**本题通用核心实现参考**  
* **说明**：综合优质题解，采用线性递推法的最优实现，完整解决1~n逆元求解。
* **完整代码**：
  ```cpp
  #include <cstdio>
  const int maxn = 3e6 + 10;
  long long inv[maxn];
  int main() {
      int n, p;
      scanf("%d%d", &n, &p);
      inv[1] = 1; puts("1");
      for (int i = 2; i <= n; ++i) {
          inv[i] = (long long)(p - p / i) * inv[p % i] % p;
          printf("%lld\n", inv[i]);
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  - 初始化 `inv[1] = 1` 并直接输出。  
  - 循环从2到n，用公式计算 `inv[i]`，即时输出避免额外存储。  
  - 类型转换 `(long long)` 防止乘法溢出，`%p` 确保结果在模p下。  

**题解一（zcysky）片段赏析**  
* **亮点**：极致简洁，效率优先。  
* **核心代码**：
  ```cpp
  inv[1] = 1; puts("1");
  for (int i = 2; i <= n; i++) {
      inv[i] = (ll)(p - p/i) * inv[p%i] % p;
      printf("%d\n", inv[i]);
  }
  ```
* **代码解读**：  
  - `(ll)` 强制转换避免 `p/i` 与 `inv[p%i]` 乘积溢出int。  
  - `p%i` 保证余数小于i，其逆元已在前序计算。  
* 💡 **学习笔记**：逆元计算本质是“利用已知小问题的解递推”。  

---

#### 5. 算法可视化：像素动画演示
* **主题**：8位像素风格“逆元拆解冒险”  
* **核心演示**：  
  1. **初始化**：像素网格标记位置1，显示 `inv[1]=1`（绿色高亮），播放启动音效。  
  2. **拆解过程（i=3, p=13）**：  
     - 动画：13被拆为4个3（蓝色方块）和余数1（黄色方块），触发“拆解音效”。  
     - 显示公式：`13=4×3+1` → `inv[3] = (13-4) * inv[1] % 13`。  
  3. **动态计算**：  
     - 当前i闪烁，显示 `inv[1]=1`（从网格读取），计算 `9*1=9` → `inv[3]=9`。  
     - 结果存入位置3（金色闪烁），播放“成功音效”。  
  4. **交互控制**：  
     - 步进/暂停按钮，速度滑块（1x~5x）。  
     - 同步显示伪代码行：`inv[i] = (p - p/i)*inv[p%i] % p`。  
* **设计意图**：通过游戏化演示，将抽象公式转化为直观操作，强化逆元拆解逻辑的记忆。  

---

#### 6. 拓展练习与相似问题思考
* **通用技巧迁移**：  
  - 线性递推逆元适用于一切需要**批量求逆元**的场景，如组合数计算（预处理阶乘逆元）。  
* **洛谷推荐**：  
  1. [P5431 乘法逆元2](https://www.luogu.com.cn/problem/P5431)：批量求逆元的变形，输入格式不同。  
  2. [P3807 卢卡斯定理](https://www.luogu.com.cn/problem/P3807)：组合数取模需阶乘逆元，巩固递推思想。  
  3. [P2613 有理数取余](https://www.luogu.com.cn/problem/P2613)：分式取模，直接应用逆元。  

---

#### 7. 学习心得与经验分享
> **参考经验**：多位作者强调线性递推是本题最优解（费马/扩欧在O(n log p)下TLE）。  
> **点评**：在批量求逆元问题中，线性递推法以O(n)复杂度碾压其他方法。其核心在于将大问题拆解为已解决的子问题，体现了动态规划思想。调试时注意溢出和负数处理即可。  

---

### 结语
本次指南深入剖析了线性递推求逆元的原理与实现，助你高效攻克模运算中的除法难题。记住：**“逆元是模世界的倒数，递推是批量求解的钥匙”**。下次挑战见！💪

---
处理用时：145.88秒
# 题目信息

# 【模板】单源最短路径（标准版）

## 题目背景

2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.org/problemnew/show/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。

然后呢？

$100 \rightarrow 60$；

$\text{Ag} \rightarrow \text{Cu}$；

最终，他因此没能与理想的大学达成契约。

小 F 衷心祝愿大家不再重蹈覆辙。

## 题目描述

给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。

数据保证你能从 $s$ 出发到任意点。

## 说明/提示

样例解释请参考 [数据随机的模板题](https://www.luogu.org/problemnew/show/P3371)。

$1 \leq n \leq 10^5$；

$1 \leq m \leq 2\times 10^5$；

$s = 1$；

$1 \leq u_i, v_i\leq n$；

$0 \leq w_i \leq 10 ^ 9$,

$0 \leq \sum w_i \leq 10 ^ 9$。

本题数据可能会持续更新，但不会重测，望周知。

2018.09.04 数据更新 from @zzq

## 样例 #1

### 输入

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4```

### 输出

```
0 2 4 3```

# AI分析结果


### 题目分析
本题是单源最短路径（SSSP）问题的标准模板题，给定一个有向图（非负权边），要求计算从源点s到所有节点的最短路径长度。由于数据规模较大（n ≤ 10^5, m ≤ 2×10^5），朴素Dijkstra算法（O(n²)）会超时，必须使用堆优化的Dijkstra算法（O((n+m)log n)）。

### 算法选择与核心思路
**算法**：堆优化Dijkstra算法  
**核心思想**：贪心策略，每次从优先队列中取出当前距离最小的未处理节点，更新其邻居节点的最短距离。  
**优化关键**：使用小根堆（优先队列）快速获取最小距离节点，避免O(n)线性扫描。

### 解题步骤
1. **初始化**：
   - 距离数组`dist`初始化为无穷大（`0x3f3f3f3f`），源点`s`的`dist[s] = 0`
   - 创建小根堆（优先队列），加入源点`(0, s)`
   - 访问标记数组`vis`初始化为`false`

2. **主循环**：
   - 从堆顶取出距离最小的节点`u`
   - 若`u`已访问则跳过，否则标记`vis[u]=true`
   - 遍历`u`的所有邻接边：若`dist[u] + w < dist[v]`则更新`dist[v]`并入队新距离

3. **输出**：遍历输出所有`dist[i]`

### 代码实现（C++）
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

const int N = 100010, M = 200010;
const int INF = 0x3f3f3f3f;

int head[N], ver[M], edge[M], nxt[M], tot;
int dist[N];
bool vis[N];
int n, m, s;

struct Node {
    int dis, id;
    bool operator < (const Node &x) const {
        return dis > x.dis;
    }
};

void add(int u, int v, int w) {
    ver[++tot] = v;
    edge[tot] = w;
    nxt[tot] = head[u];
    head[u] = tot;
}

void dijkstra() {
    memset(dist, 0x3f, sizeof(dist));
    memset(vis, false, sizeof(vis));
    dist[s] = 0;
    
    priority_queue<Node> q;
    q.push((Node){0, s});
    
    while (!q.empty()) {
        Node tmp = q.top(); q.pop();
        int u = tmp.id;
        if (vis[u]) continue;
        vis[u] = true;
        
        for (int i = head[u]; i; i = nxt[i]) {
            int v = ver[i], w = edge[i];
            if (!vis[v] && dist[u] + w < dist[v]) {
                dist[v] = dist[u] + w;
                q.push((Node){dist[v], v});
            }
        }
    }
}

int main() {
    scanf("%d%d%d", &n, &m, &s);
    for (int i = 1; i <= m; ++i) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w);
    }
    
    dijkstra();
    
    for (int i = 1; i <= n; ++i) {
        printf("%d ", dist[i] == INF ? 2147483647 : dist[i]);
    }
    return 0;
}
```

### 算法分析
1. **时间复杂度**：O((n+m)log n)
   - 每个节点入队1次（O(n log n)）
   - 每条边松弛1次（O(m log n)）

2. **空间复杂度**：O(n + m)
   - 邻接表存储图：O(m)
   - 距离/访问数组：O(n)
   - 优先队列：O(n)

3. **正确性保证**：
   - 非负权边确保贪心策略有效
   - 优先队列保证每次扩展当前全局最小距离节点
   - 访问标记避免重复处理

### 关键优化点
- **优先队列设计**：自定义`Node`结构体重载运算符实现小根堆
- **重复节点处理**：`vis`数组跳过已处理节点
- **邻接表存储**：高效处理稀疏图（m ≈ n）

### 常见问题
- **重复入队问题**：同一节点可能多次入队，但仅最小距离有效
- **初始值设定**：`INF`需足够大（0x3f3f3f3f ≈ 1e9）
- **无解处理**：题目保证连通，实际应用需特判未连通情况

> 通过堆优化Dijkstra算法，我们高效解决了大规模数据下的单源最短路径问题，兼顾时间效率和代码简洁性。

---
处理用时：119.97秒
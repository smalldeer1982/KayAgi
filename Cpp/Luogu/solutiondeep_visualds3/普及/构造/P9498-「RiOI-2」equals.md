# 题目信息

# 「RiOI-2」equals

## 题目背景

在小树上坐落着一个幻想的城堡。这里是 E 国的领地，而小 E，则是 E 国之王。

为了打造一个完美的 E 国，他需要明辨是非，走向正义。

但是，他似乎有些太理想了。有时并没有一个完美的准则。是黑是白，谁能分辨？

## 题目描述

给定一棵 $n$ 个结点，以 $1$ 为根的树，定义一个结点的深度 $d_i$ 表示它到根结点的简单路径上的结点个数。

你需要给每个结点黑白染色，满足黑色结点的深度和等于白色结点的深度和。设 $c_i = \{0, 1\}$ 分别代表编号为 $i$ 的结点为黑色或白色，那么这即 $\displaystyle\sum_{c_i=0}d_i=\sum_{c_i=1}d_i$。

若无解，仅输出一行一个整数 $-1$。

## 说明/提示

### 样例解释

对于第一组数据，每个结点的深度分别是 $d=[1,2,2,3,3,3]$。黑色结点的深度和为 $d_1+d_5+d_6=1+3+3=7$，白色结点的深度和为 $d_2+d_3+d_4=2+2+3=7$。它们相等，所以样例输出是正确的。可能的正确输出包括但不限于样例输出、`0 1 1 0 0 1`，`1 0 0 1 0 1` 等。

### 数据规模与约定

**本题采用捆绑测试。**

| $\rm Subtask$ | 分值 | $n\le $ | 特殊性质 |
| :-----------: | :--: | :-----: | :------: |
| $0$ | $5$ | $20$ | / |
| $1$ | $15$ | $500$ | / |
| $2$ | $20$ | $5\times 10^3$ | / |
| $3$ | $10$ | / | $n$ 为偶数 |
| $4$ | $5$ | / | 树为菊花图（不保证根为菊花中心） |
| $5$ | $5$ | / | 树为一条链（不保证根为链的端点） |
| $6$ | $40$ | / | / |

斜杠表示这一栏无特殊限制。

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le u_i,v_i\le n$，输入数据构成一棵树。

## 样例 #1

### 输入

```
6
1 2
1 3
2 4
2 5
2 6```

### 输出

```
0 1 1 1 0 0```

## 样例 #2

### 输入

```
5
1 2
1 3
2 4
2 5```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：「RiOI-2」equals 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法 + 树的深度特性应用


🗣️ **初步分析**：  
解决“equals”问题的关键，在于**利用树的深度连续性**和**贪心策略**。树的深度序列有个重要性质：如果有深度为`k`的节点，那么必然存在深度为`1`到`k-1`的节点（比如父节点的深度一定比子节点小1）。这就像“楼梯”一样，每个台阶都不会缺失。  

我们的目标是将节点分成两组，使两组的深度和相等。首先，**总和必须是偶数**（否则直接输出`-1`）。当总和为偶数时，我们需要凑出总和的一半（记为`target`）。由于深度序列是连续的，我们可以用**贪心**的方法：**从大到小选择深度较大的节点**（或从小到大），只要加上当前节点的深度不超过`target`，就选它。这样做的原因是，大的深度更容易快速接近`target`，而连续的深度保证了即使中间有偏差，也能通过小深度的节点调整回来。  

**核心算法流程**：  
1. 计算每个节点的深度（DFS/BFS）；  
2. 排序深度序列（保留原节点编号）；  
3. 贪心选择节点，凑出`target`；  
4. 输出染色结果。  

**可视化设计思路**：  
我们可以设计一个“像素探险家”游戏，用8位像素风格展示树的结构（节点用不同颜色的方块表示，深度越大颜色越深）。动画中，**排序后的深度序列**会从右到左（大到小）移动，选中的节点会“亮起”（比如变成黄色），同时屏幕上方显示当前和与`target`的差距。当当前和等于`target`时，播放“胜利”音效（比如FC游戏的通关声），所有选中的节点会“跳动”庆祝。


---

## 2. 精选优质题解参考

### 题解一：TernaryTree（DFS+排序分组）  
* **点评**：这份题解的思路非常清晰，通过**DFS计算深度**→**排序深度序列**→**分组处理**的流程，巧妙利用了树的深度连续性。作者将节点按深度排序后，两两分组处理：若两组深度相同，则一黑一白；若不同，则调整偏移量（保证总和平衡）。这种方法不仅正确性高（通过模2分析证明），而且代码结构工整（变量名如`dep`、`c`含义明确），适合初学者理解贪心的核心逻辑。  

### 题解二：ys_kylin__（从大到小贪心）  
* **点评**：此题解的亮点是**从大到小贪心**的策略。作者将深度排序后，从最大的深度开始选，只要加上当前深度不超过`target`就选。这种方法直观且高效（时间复杂度`O(nlogn)`），代码中的`sum2`变量清晰记录了当前选中的和，边界处理（如`sum%2==1`直接返回`-1`）非常严谨。此外，作者提醒“不开long long见祖宗”，这是编程中的重要细节。  

### 题解三：GaCGe（降序排序+权值平衡）  
* **点评**：这份题解的正确性证明非常到位（通过奇偶性和深度连续性分析）。作者将节点按深度降序排序，然后根据当前黑白和的大小选择染色（选较小的一方），确保最终和相等。代码中的`cnt1`、`cnt2`变量实时跟踪两组和，逻辑清晰；`flag`数组标记染色结果，可读性高。这种方法不仅能解决本题，还能推广到类似的“权值平衡”问题。


---

## 3. 核心难点辨析与解题策略

### 1. **难点1：如何证明贪心策略的正确性？**  
* **分析**：贪心的正确性依赖于**树的深度连续性**。假设我们要凑`target`，从大到小选节点。如果当前选中的和`sum`加上当前节点的深度`d`不超过`target`，就选它；否则跳过。由于深度是连续的，即使`sum + d > target`，也必然存在一个更小的深度`d'`（`d' ≤ target - sum`），可以通过调整选中的节点来凑出`target`。例如，若`sum + 5 > target`（`target = sum + 3`），则可以去掉一个`5`，加上一个`3`（因为深度3必然存在）。  
* 💡 **学习笔记**：贪心的正确性需要“问题具有最优子结构”和“贪心选择性质”，本题的深度连续性满足这两个条件。

### 2. **难点2：如何处理总和为奇数的情况？**  
* **分析**：总和为奇数时，无法分成两个相等的整数和，直接输出`-1`。这是本题的“剪枝”条件，必须首先判断，否则后续处理无效。  
* 💡 **学习笔记**：遇到“分成两组和相等”的问题，首先检查总和是否为偶数，这是常见的优化手段。

### 3. **难点3：如何保留节点的原编号？**  
* **分析**：排序深度序列时，需要保留节点的原编号（否则无法输出正确的染色结果）。可以用结构体或`pair`存储深度和编号（如`pair<int, int>`，第一个元素是深度，第二个是编号）。  
* 💡 **学习笔记**：排序时若需要保留原信息，结构体或`pair`是常用的工具。


### ✨ 解题技巧总结  
- **技巧A：利用问题特性**：树的深度连续性是本题的关键，抓住这一点可以避免复杂的背包算法。  
- **技巧B：贪心策略选择**：从大到小选节点，能快速接近目标，减少调整次数。  
- **技巧C：边界条件处理**：先判断总和是否为奇数，避免无效计算。  


---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了TernaryTree、ys_kylin__和GaCGe的题解思路，采用**DFS计算深度**→**排序深度序列**→**从大到小贪心**的流程，代码简洁高效。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  const int MAXN = 1e6 + 10;
  vector<int> g[MAXN];
  long long dep[MAXN]; // 深度
  pair<long long, int> d[MAXN]; // 存储深度和编号
  bool ans[MAXN]; // 染色结果（1表示选中）

  void dfs(int u, int fa) {
      dep[u] = dep[fa] + 1;
      for (int v : g[u]) {
          if (v != fa) {
              dfs(v, u);
          }
      }
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      int n;
      cin >> n;
      for (int i = 1; i < n; ++i) {
          int u, v;
          cin >> u >> v;
          g[u].push_back(v);
          g[v].push_back(u);
      }
      dfs(1, 0); // 计算深度
      long long sum = 0;
      for (int i = 1; i <= n; ++i) {
          sum += dep[i];
          d[i] = {dep[i], i};
      }
      if (sum % 2 != 0) {
          cout << -1 << endl;
          return 0;
      }
      long long target = sum / 2;
      sort(d + 1, d + n + 1, greater<pair<long long, int>>()); // 降序排序
      long long current = 0;
      for (int i = 1; i <= n; ++i) {
          if (current + d[i].first <= target) {
              current += d[i].first;
              ans[d[i].second] = true;
          }
      }
      for (int i = 1; i <= n; ++i) {
          cout << ans[i] << " ";
      }
      cout << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **DFS计算深度**：通过`dfs`函数遍历树，计算每个节点的深度（`dep`数组）。  
  2. **求和与判断**：计算所有深度的和`sum`，若为奇数则输出`-1`。  
  3. **排序**：将深度和编号存入`d`数组，按深度降序排序。  
  4. **贪心选择**：从大到小遍历，选中的节点标记为`true`（`ans`数组），直到当前和等于`target`。  


### 针对各优质题解的片段赏析  

#### 题解一：TernaryTree（分组处理）  
* **亮点**：通过分组处理平衡总和，逻辑严谨。  
* **核心代码片段**：  
  ```cpp
  sort(dep + 1, dep + 1 + n);
  for (int i = 1; i <= n; i += 2) {
      if (dep[i].first == dep[i + 1].first) {
          c[dep[i].second] = 0;
          c[dep[i + 1].second] = 1;
      } else {
          c[dep[i].second] = (cur == -1);
          c[dep[i + 1].second] = !c[dep[i].second];
          cur = (cur != 0) ? 0 : -1;
      }
  }
  ```  
* **代码解读**：  
  作者将排序后的深度两两分组。若两组深度相同，则一黑一白（`c`数组标记）；若不同，则调整`cur`变量（偏移量），保证总和平衡。例如，`cur == -1`时，选第一组为黑，第二组为白，`cur`重置为0；否则相反。这种方法利用了深度的连续性，确保最终总和相等。  
* 💡 **学习笔记**：分组处理是平衡总和的有效方法，适用于类似的“配对问题”。

#### 题解二：ys_kylin__（从大到小贪心）  
* **亮点**：直观的贪心策略，代码简洁。  
* **核心代码片段**：  
  ```cpp
  sort(d + 1, d + n + 1, cmp); // 降序排序
  for (int i = n; i >= 1; --i) {
      if (sum2 + d[i].num <= sum / 2) {
          sum2 += d[i].num;
          ans[d[i].id] = 1;
      }
  }
  ```  
* **代码解读**：  
  作者将深度降序排序后，从最大的深度开始选。`sum2`记录当前选中的和，只要加上当前深度不超过`target`（`sum/2`），就选它（`ans`数组标记为1）。这种方法快速接近目标，效率高。  
* 💡 **学习笔记**：贪心策略的关键是“选择当前最优”，本题的“当前最优”是选最大的深度。

#### 题解三：GaCGe（权值平衡）  
* **亮点**：实时平衡两组和，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  sort(e + 1, e + 1 + n, cmp); // 降序排序
  for (int i = 1; i <= n; ++i) {
      if (cnt1 > cnt2) {
          flag[e[i].num] = 1;
          cnt2 += e[i].dd;
      } else {
          cnt1 += e[i].dd;
      }
  }
  ```  
* **代码解读**：  
  作者将节点按深度降序排序后，根据当前两组和（`cnt1`、`cnt2`）的大小选择染色。若`cnt1`大于`cnt2`，则将当前节点染成白（`flag`数组标记为1），增加`cnt2`；否则染成黑，增加`cnt1`。这种方法确保两组和始终平衡，最终相等。  
* 💡 **学习笔记**：实时平衡是解决“两组和相等”问题的另一种思路，适用于需要动态调整的场景。


---

## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素树的“深度探险”**  
采用8位像素风格（类似FC游戏《超级马里奥》），展示树的结构和贪心选择过程。


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示一棵像素树（节点用不同颜色的方块表示，深度越大颜色越深，比如深度1是红色，深度2是橙色，深度3是黄色，依此类推）。  
   - 屏幕右侧显示**排序后的深度序列**（从大到小排列，每个深度用对应的颜色方块表示）。  
   - 屏幕上方显示**当前和**（`current`）和**目标和**（`target`），用像素字体显示（比如“Current: 0 / Target: 7”）。  
   - 控制面板包含“开始”、“单步”、“重置”按钮，以及速度滑块（调整动画速度）。  

2. **算法启动**：  
   - 点击“开始”按钮，动画开始。首先，DFS遍历树，计算每个节点的深度（节点会“闪烁”表示正在计算）。  
   - 计算完成后，深度序列会从树中“弹出”，排序成降序（右侧的序列会从无序变为有序）。  

3. **贪心选择过程**：  
   - 从右侧的深度序列中，最右边的方块（最大深度）会“移动”到左侧的“选中区”（比如屏幕下方的一个区域），同时`current`增加对应的深度值。  
   - 若`current`加上当前深度不超过`target`，则选中区的方块会“亮起”（变成绿色）；否则，方块会“弹回”序列（变成灰色）。  
   - 每一步操作都伴随**音效**：选中时播放“叮”的声音（类似吃金币），弹回时播放“咔”的声音（类似踩砖块）。  

4. **目标达成**：  
   - 当`current`等于`target`时，播放“胜利”音效（类似通关音乐），选中区的方块会“跳动”，树中的对应节点会“发光”（表示染色完成）。  
   - 屏幕显示“成功！”的像素文字，动画结束。  

5. **交互设计**：  
   - **单步模式**：点击“单步”按钮，动画执行一步（选择一个节点），方便观察每一步的变化。  
   - **速度滑块**：调整动画速度（从“慢”到“快”），适合不同学习节奏的用户。  
   - **重置按钮**：恢复初始状态，重新开始动画。  


### 设计思路  
- **像素风格**：营造复古游戏的氛围，吸引青少年的兴趣。  
- **颜色编码**：用不同颜色表示深度，直观展示树的结构和深度分布。  
- **音效反馈**：通过声音强化操作记忆，让学习者更容易记住贪心的步骤。  
- **交互控制**：允许用户调整动画速度和单步执行，满足不同学习需求。  


---

## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
本题的**贪心策略**和**深度连续性**思路，可迁移到以下场景：  
1. **背包问题**：当物品的重量是连续的（比如1到n），可以用贪心策略快速凑出目标重量。  
2. **权值平衡问题**：将一组数分成两组，使和相等，若数是连续的，贪心策略有效。  
3. **树的路径问题**：比如求树中路径的最大和，利用树的连续性（路径上的节点深度连续）可以优化算法。  


### 练习推荐 (洛谷)  
1. **洛谷 P1048 采药**  
   - 🗣️ **推荐理由**：这是经典的01背包问题，需要选择物品使总价值最大。虽然本题用贪心，但背包问题是贪心的延伸，有助于理解“选择最优”的思想。  
2. **洛谷 P2392 kkksc03考前临时抱佛脚**  
   - 🗣️ **推荐理由**：需要将题目分成两组，使两组的时间和相等。本题的贪心策略（从大到小选）可直接应用，有助于巩固“权值平衡”的思路。  
3. **洛谷 P1164 小A点菜**  
   - 🗣️ **推荐理由**：这是经典的计数背包问题，需要计算凑出目标金额的方案数。虽然本题用贪心，但背包问题的思路（动态规划）是贪心的补充，有助于拓宽视野。  


---

## 7. 学习心得与经验分享 (若有)  
- **经验1**：**不开long long见祖宗**：本题中，深度和可能很大（`n`到`1e6`，深度和可达`1e12`），必须用`long long`类型，否则会溢出。这是编程中的常见陷阱，需要牢记。  
- **经验2**：**利用问题特性**：树的深度连续性是本题的关键，抓住这一点可以避免复杂的算法（比如01背包）。在解决问题时，要先观察问题的特性，再选择合适的算法。  
- **经验3**：**贪心的正确性证明**：贪心策略的正确性需要严格证明，不能仅凭直觉。本题通过深度连续性证明了贪心的正确性，这是学习贪心算法的重要步骤。  


---

## 结语  
本次关于“「RiOI-2」equals”的C++解题分析就到这里。希望这份学习指南能帮助大家理解贪心算法的核心思想，掌握树的深度特性的应用。记住，编程能力的提升在于**持续学习**、**勤于思考**和**勇于实践**。下次我们再一起探索新的编程挑战！💪

---
处理用时：200.71秒
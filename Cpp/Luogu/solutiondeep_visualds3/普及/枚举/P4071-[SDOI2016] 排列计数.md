# 题目信息

# [SDOI2016] 排列计数

## 题目描述

求有多少种 $1$ 到 $n$ 的排列 $a$，满足序列恰好有 $m$ 个位置 $i$，使得 $a_i = i$。

答案对 $10^9 + 7$ 取模。

## 说明/提示

#### 数据规模与约定

本题共 20 个测试点，各测试点等分，其数据规模如下表。

| 测试点编号 | $T =$  | $n, m \leq$ |  测试点编号  |      $T =$      | $n, m \leq$ |
| :--------: | :----: | :---------: | :----------: | :-------------: | :---------: |
| $1\sim 3$  | $10^3$ |     $8$     | $10 \sim 12$ |     $10^3$      |   $10^3$    |
| $4 \sim 6$ | $10^3$ |    $12$     | $13 \sim 14$ | $5 \times 10^5$ |   $10^3$    |
| $7 \sim 9$ | $10^3$ |    $100$    | $15 \sim 20$ | $5 \times 10^5$ |   $10^6$    |

对于全部的测试点，保证 $1 \leq T \leq 5 \times 10^5$，$1 \leq n \leq 10^6$，$0 \leq m \leq 10^6$。

## 样例 #1

### 输入

```
5
1 0
1 1
5 2
100 50
10000 5000```

### 输出

```
0
1
20
578028887
60695423```

# AI分析结果



---

# 💡 Kay的C++算法解析：排列计数 深入学习指南 💡

<introduction>
今天我们来一起分析“排列计数”这道C++编程题。这道题结合了组合数学和错排问题，需要我们灵活运用这两个知识点。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`组合数学与错排应用`

🗣️ **初步分析**：
解决“排列计数”这道题，关键在于理解并运用组合数和错排问题的核心思想。组合数就像“选座位”——从n个位置中选出m个固定位置，让这些位置上的数恰好等于下标（比如选m个同学坐在固定的座位上）；而错排问题则像“打乱顺序”——剩下的n-m个位置上的数必须都不在原来的位置上（比如剩下的同学都不能坐在自己的座位上）。

在本题中，我们需要先计算组合数C(n,m)（即选择m个固定位置的方案数），再计算错排数D(n−m)（即剩下n−m个数全不在原位的方案数），最终答案就是两者的乘积。核心难点在于如何高效计算组合数和错排数，尤其是在大数据量下的预处理优化。

对于可视化设计，我们可以用8位像素风格展示：初始时有n个像素块（代表位置），先高亮m个选中的固定块（绿色），剩下的n−m个块（红色）需要动态演示它们如何交换位置，且每个红色块都不留在原位（比如用闪烁、移动动画表示交换过程）。关键步骤如组合数的选择、错排的递推过程会通过颜色变化和音效（如“叮”的提示音）强化记忆。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下评分较高（≥4星）的题解：
</eval_intro>

**题解一：作者冒泡ioa（赞：90）**
* **点评**：此题解用“找规律”的方式引导思考，从具体例子入手（如n=5,m=2时的排列情况），直观解释了组合数C(n,m)和错排数D(n−m)的关系。代码预处理了阶乘、逆元和错排数，逻辑清晰，边界条件处理（如n=m时输出1）严谨。亮点在于通过“灵魂画师”的比喻和图示，帮助初学者理解错排的递推逻辑。

**题解二：作者Warriors_Cat（赞：8）**
* **点评**：此题解详细推导了错排的递推式D(n)=(n−1)(D(n−1)+D(n−2))，并结合组合数的逆元预处理，代码结构工整（如快速幂求逆元、预处理阶乘），变量命名（如`jc`表示阶乘，`d`表示错排数）易于理解。亮点在于对时间复杂度的优化（O(n)预处理+O(1)查询），适合竞赛场景。

**题解三：作者K2sen（赞：26）**
* **点评**：此题解结合了错排问题的经典例题（P1595信封问题），通过图示和递推式推导，清晰解释了错排的原理。代码中预处理了阶乘和逆元，并用Lucas定理计算组合数（尽管本题n≤1e6无需Lucas，但展示了通用方法）。亮点在于对费马小定理求逆元的详细说明，适合巩固数论基础。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何理解错排的递推式？**
    * **分析**：错排数D(n)表示n个数全不在原位的排列数。递推式D(n)=(n−1)(D(n−1)+D(n−2))的推导需要考虑两种情况：假设第n个数放在第k位，若第k个数放在第n位（剩下n−2个数错排），或第k个数不放在第n位（剩下n−1个数错排）。k有n−1种选择，因此乘(n−1)。
    * 💡 **学习笔记**：错排的递推式是“分类讨论+乘法原理”的典型应用，理解两种情况的互斥性是关键。

2.  **关键点2：如何高效计算组合数C(n,m)？**
    * **分析**：组合数C(n,m)=n!/(m!(n−m)!)，但直接计算除法在模意义下需用逆元。预处理阶乘数组`jc`和阶乘的逆元数组`inv_jc`，即可O(1)计算C(n,m)=jc[n]×inv_jc[m]×inv_jc[n−m] mod MOD。
    * 💡 **学习笔记**：逆元预处理是处理大数组合数的核心技巧，费马小定理（a^(p-2) mod p）是求逆元的常用方法。

3.  **关键点3：如何处理边界条件？**
    * **分析**：当n=m时，所有数都固定，方案数为1；当n−m=1时，无法错排（1个数无法不在原位），方案数为0；当m=0时，直接输出D(n)。这些边界需在代码中特判。
    * 💡 **学习笔记**：边界条件的处理体现了严谨性，需结合问题实际意义（如1个数的错排数为0）。

### ✨ 解题技巧总结
<summary_best_practices>
- **预处理优先**：对于多组查询问题（如本题T=5e5），预处理阶乘、逆元、错排数到最大n值，可将每次查询的时间降至O(1)。
- **错排递推初始化**：错排的初始值D(1)=0，D(2)=1，递推从i=3开始。
- **逆元的灵活应用**：组合数的除法取模转换为乘法逆元，利用费马小定理快速计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，预处理了阶乘、逆元和错排数，支持O(1)查询，适用于大数据量场景。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstdio>
    using namespace std;
    typedef long long ll;
    const int MOD = 1e9 + 7;
    const int MAXN = 1e6 + 5;

    ll jc[MAXN];   // 阶乘数组
    ll inv_jc[MAXN]; // 阶乘的逆元数组
    ll d[MAXN];    // 错排数数组

    // 快速幂求逆元
    ll qpow(ll a, ll b) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    // 预处理阶乘、逆元和错排数
    void prework() {
        jc[0] = 1;
        for (int i = 1; i < MAXN; ++i) jc[i] = jc[i-1] * i % MOD;

        inv_jc[MAXN-1] = qpow(jc[MAXN-1], MOD-2);
        for (int i = MAXN-2; i >= 0; --i) inv_jc[i] = inv_jc[i+1] * (i+1) % MOD;

        d[0] = 1; d[1] = 0; d[2] = 1;
        for (int i = 3; i < MAXN; ++i) d[i] = (i-1) * (d[i-1] + d[i-2]) % MOD;
    }

    // 计算组合数C(n, m)
    ll C(ll n, ll m) {
        if (m < 0 || m > n) return 0;
        return jc[n] * inv_jc[m] % MOD * inv_jc[n - m] % MOD;
    }

    int main() {
        prework();
        int T;
        scanf("%d", &T);
        while (T--) {
            ll n, m;
            scanf("%lld%lld", &n, &m);
            if (n == m) printf("1\n");
            else if (n - m == 1) printf("0\n");
            else if (m == 0) printf("%lld\n", d[n]);
            else printf("%lld\n", C(n, m) * d[n - m] % MOD);
        }
        return 0;
    }
    ```
* **代码解读概要**：
    该代码首先预处理阶乘`jc`和阶乘的逆元`inv_jc`（通过费马小定理），然后预处理错排数`d`。主函数中处理多组查询，根据n和m的值选择输出：当n=m时输出1（全固定），n−m=1时输出0（无法错排），m=0时输出d[n]（全错排），其他情况输出组合数乘错排数。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者冒泡ioa**
* **亮点**：预处理逻辑清晰，错排递推直接，边界条件处理（如n−m=1）明确。
* **核心代码片段**：
    ```cpp
    d[1]=0,d[2]=1,d[3]=2;
    for(int i=4;i<MAXN;i++){
        d[i]=(i-1)*(d[i-1]+d[i-2])%mod;
    }
    ```
* **代码解读**：
    这段代码初始化错排数的前几项（d[1]=0，d[2]=1），然后从i=4开始递推计算d[i]。递推式`(i-1)*(d[i-1]+d[i-2])`对应错排的两种情况：第i个数放在第k位时，k有i−1种选择，剩下的i−1或i−2个数错排。
* 💡 **学习笔记**：错排的递推需从初始值开始逐步计算，理解递推式的来源是记忆的关键。

**题解二：作者Warriors_Cat**
* **亮点**：阶乘和逆元的预处理高效，组合数计算简洁。
* **核心代码片段**：
    ```cpp
    inv[N] = fpow(jc[N], mod - 2, mod);
    for(int i = N - 1; i >= 0; --i) inv[i] = inv[i + 1] * (i + 1) % mod;
    ```
* **代码解读**：
    这段代码先计算最大阶乘的逆元（`jc[N]`的逆元），然后逆推得到所有阶乘的逆元。利用了逆元的性质：`inv[jc[i]] = inv[jc[i+1]] * (i+1) % mod`，时间复杂度O(n)，比逐个计算更高效。
* 💡 **学习笔记**：逆元的预处理可以通过倒序递推优化，减少计算量。

**题解三：作者K2sen**
* **亮点**：结合经典错排例题（P1595），代码注释详细，适合新手理解。
* **核心代码片段**：
    ```cpp
    ll c(ll a, ll b) {
        return (jc[a] % mod * q_pow(jc[b] * jc[a - b] % mod, mod - 2) % mod) % mod;
    }
    ```
* **代码解读**：
    这段代码计算组合数C(a,b)，通过阶乘`jc`和逆元`q_pow`（快速幂求逆元）实现。公式为`C(a,b) = jc[a] * inv(jc[b] * jc[a−b]) % mod`，其中`inv`通过费马小定理计算。
* 💡 **学习笔记**：组合数的模运算需转换为乘法逆元，避免直接除法。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解组合数选择和错排过程，我设计了一个“像素排列屋”的8位风格动画演示方案。让我们通过动画“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素排列屋：选位置与错排大冒险`

  * **核心演示内容**：
    演示从n个像素块中选择m个固定块（绿色），剩余n−m个块（红色）如何错排（即每个红色块都不留在原位）。关键步骤包括：组合数选择、错排递推过程（如i=3时，块1→2，块2→3，块3→1）。

  * **设计思路简述**：
    采用8位像素风格（类似FC游戏），用不同颜色区分固定块（绿色）和待错排块（红色）。通过单步/自动播放控制，配合音效（选择块时“叮”，错排交换时“唰”），增强操作记忆。游戏化关卡设计（每完成一个n值的计算即过关），提升趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕显示n个像素块（横向排列，编号1~n），背景为淡蓝色，顶部显示控制面板（开始/暂停、单步、速度滑块）。
        - 播放8位风格背景音乐（如《超级马力欧》经典旋律）。

    2.  **组合数选择**：
        - 用户输入n和m后，动画自动从n个块中随机选出m个（绿色闪烁），显示“已选m个固定块”。例如n=5,m=2时，块1和块3变绿。

    3.  **错排演示**：
        - 剩余n−m个块（红色）开始错排。例如n−m=3时：
          - 块2尝试移动到块3的位置（箭头指示），块3移动到块4的位置，块4移动到块2的位置（交换动画，伴随“唰”音效）。
          - 每完成一次交换，对应错排数d[3]的计数增加（屏幕上方显示d[3]=2）。

    4.  **关键步骤高亮**：
        - 当计算组合数C(n,m)时，绿色块的编号会动态显示组合数公式（如C(5,2)=10）。
        - 错排递推时，用文字气泡解释递推式（如“d[3]=(3-1)*(d[2]+d[1])=2*(1+0)=2”）。

    5.  **结果展示**：
        - 所有操作完成后，显示最终方案数（如n=5,m=2时输出20），伴随“胜利”音效（上扬音调），绿色和红色块一起闪烁庆祝。

  * **旁白提示**：
      - （选择块时）“现在我们要从5个块中选2个固定，这有C(5,2)=10种方法！”
      - （错排时）“剩下的3个块必须都不在原位，这是错排问题，d[3]=2种方法哦！”
      - （结果时）“所以总共有10×2=20种方案，你学会了吗？”

<visualization_conclusion>
通过这样一个融合了像素艺术和游戏化元素的动画，我们不仅能清晰看到组合数选择和错排的过程，还能在轻松的氛围中理解算法核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考组合数和错排的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 组合数C(n,m)不仅用于固定位置，还可用于“选k个元素满足某条件”的问题（如选k个不同的数组成子集）。
    - 错排问题可推广到“部分元素不在原位”的情况（如允许k个元素在原位，其余错排），此时需结合容斥原理。
    - 逆元预处理是处理大数模运算的通用技巧，适用于所有需要除法取模的场景（如概率计算、多项式系数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1595 信封问题** - `错排模板题`
        * 🗣️ **推荐理由**：直接考察错排数的计算，适合巩固错排递推式的理解。
    2.  **洛谷 P3811 【模板】乘法逆元** - `逆元计算`
        * 🗣️ **推荐理由**：练习快速幂求逆元和线性递推逆元，是解决组合数问题的基础。
    3.  **洛谷 P5520 [yLOI2019] 青原樱** - `组合数应用`
        * 🗣️ **推荐理由**：结合组合数和排列问题，需要灵活处理“不相邻”条件，拓展组合数的应用场景。

-----

## 7\. 学习心得与经验分享 

<insights_intro>
部分题解中提到了预处理和调试的经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者SA丶S)**：“在预处理阶乘和逆元时，需要注意数组大小要覆盖最大n值（如1e6），否则会导致越界错误。另外，错排的初始值d[1]=0，d[2]=1容易记混，建议通过小例子验证（如n=2时，错排数为1）。”

> **点评**：这位作者的经验非常实用。预处理数组的大小和初始值的正确性是编程中常见的坑点。通过小例子验证（如n=2时输出1）可以快速定位错误，这是调试的重要技巧。

-----

<conclusion>
本次关于“排列计数”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解组合数和错排问题的核心逻辑。记住，编程能力的提升在于多思考、多练习，下次我们再一起探索新的编程挑战！💪
</conclusion>

-----

---
处理用时：180.87秒
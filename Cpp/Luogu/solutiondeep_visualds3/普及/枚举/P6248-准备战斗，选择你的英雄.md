# 题目信息

# 准备战斗，选择你的英雄

## 题目背景

zjf，被 NOIP 普及组初赛戏耍，pj 1= -> 初赛三等，愤恨地离开了 OI，深陷中考的泥潭当中。据说，他颓废是因为玩多了 [OW](https://ow.blizzard.cn/home) 这款游戏。

## 题目描述

目前，游戏共有 $31$ 个英雄，每局可以派 $6$ 个英雄上场。实际能使用的英雄数将会小于 $31$。简单地假设，每位英雄对团队的贡献可以用一个正整数 $v_i$ 表示。团队的总能力等于所有英雄的贡献之和。特别地，对于 $m$ 组特定的英雄，他们一起出现会让团队总能力提高 $x_i$。

**另注：英雄组合可以重复，若重复请多次计数。**

## 说明/提示

#### 样例 1 解释
我们应该选择前 $6$ 名英雄。

---

#### 样例 2 解释
我们应该选择 Pharah、Mercy、Reinhardt、DVA、SOLDIER:76、Anna

---

#### 数据范围
对于 $40\%$ 的数据，$m=0$。  
对于 $100\%$ 的数据，$6\le n \le 30$，$0\le m \le 30$，*$1\le x_i,v_i \le 100$*，英雄名字长度 $\le 10$，字符集包括大小写字母、数字以及冒号（ `:` ）。每个英雄的名字各不相同。


## 样例 #1

### 输入

```
7 0
Sigma 10
Orisa 10
Mei 10
Reaper 10
Moira 10
Lucio 10
Doomfist 1```

### 输出

```
60```

## 样例 #2

### 输入

```
8 2
Pharah 5
Mercy 5
Reinhardt 10
DVA 10
SOLDIER:76 12
Torbjorn 5
Anna 8
Baptiste 10
Pharah Mercy 20
Anna Pharah 5```

### 输出

```
75```

# AI分析结果



---
# 💡 Kay的C++算法解析：准备战斗，选择你的英雄 深入学习指南 💡

<introduction>
今天我们来一起分析“准备战斗，选择你的英雄”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心枚举算法，并掌握暴力搜索的解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举（暴力搜索）`

🗣️ **初步分析**：
> 解决这道题的关键在于“枚举所有可能的6人英雄组合”，并计算每个组合的总能力（基础贡献+组合加成）。枚举法就像在一个装满不同口味糖果的盒子里，逐个尝试所有拿6颗糖果的组合，选出最甜的那组。在本题中，由于n≤30，C(30,6)=593775种组合，计算机可以轻松处理。
   - **题解思路对比**：主流思路有两种：DFS递归枚举（如lzqy_的题解）和六重循环枚举（如gyh20的题解）。DFS通过递归按顺序选择英雄，避免重复；六重循环直接遍历所有组合，代码更短但嵌套层次多。
   - **核心算法流程**：先将英雄名字映射为编号（用map或哈希表），然后枚举所有6人组合，计算每个组合的总能力（基础值+所有存在的组合加成）。
   - **可视化设计**：采用8位像素风格，用方块表示英雄，选中的英雄高亮。枚举时用箭头指示当前选择，计算加成时对应英雄方块闪烁并显示“+x”动画，关键操作（如选中、计算完成）伴随“叮”“滴答”音效，找到最大值时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解评分≥4星，值得重点参考：
</eval_intro>

**题解一：来源：lzqy_**
* **点评**：此题解思路清晰，使用DFS递归枚举所有6人组合，代码注释详细，适合新手学习。变量命名直观（如`together[i][j]`记录i和j的组合加成），处理了组合重复的情况（用`+=`累加）。代码结构规范，将枚举和计算分离（`dfs`负责枚举，`moni`负责计算），降低了复杂度。从实践角度看，代码可直接用于竞赛，边界处理严谨（如`k[i]`标记是否选中），是暴力枚举的典型实现。

**题解二：来源：gyh20**
* **点评**：此题解采用六重循环直接枚举所有组合，代码简洁高效。通过六层嵌套遍历所有可能的6人组合（`a<b<c<d<e<f`），避免了重复。计算加成时直接遍历两两英雄对（如`g[a][b]+g[a][c]+...`），逻辑直白。适合理解暴力枚举的底层实现，对循环嵌套的掌握有帮助。

**题解三：来源：袁宇轩**
* **点评**：此题解的DFS实现逻辑清晰，`dfs`函数参数设计合理（`x`表示当前英雄编号，`k`表示已选人数，`s`表示当前总贡献）。代码规范（使用`#define`简化循环，`read`函数快速输入），特别处理了组合加成的重复问题（`c[mp[x]][mp[y]] += read()`），是DFS枚举的优秀示例。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何高效枚举所有6人组合而不重复？
    * **分析**：枚举时需保证组合的唯一性（如选`{1,2,3,4,5,6}`和`{2,1,3,4,5,6}`视为同一组合）。优质题解通过“按顺序选择”解决：DFS中每次从当前编号的下一个开始选（如`i=a[kk-1]`），六重循环中`a<b<c<d<e<f`。
    * 💡 **学习笔记**：按升序选择英雄是避免重复枚举的关键技巧。

2.  **关键点2**：如何计算每个组合的总加成？
    * **分析**：每个组合的加成是所有m组中，两个英雄都在选中的6人中的x_i之和。优质题解通常预处理英雄编号，用二维数组`together[i][j]`记录i和j的加成，枚举时遍历两两英雄对累加。
    * 💡 **学习笔记**：预处理+暴力累加是小数据量下最直接的解决方案。

3.  **关键点3**：如何处理英雄名字到编号的映射？
    * **分析**：输入的英雄名字是字符串，需映射为整数编号以便后续处理。优质题解使用`map<string, int>`或哈希表实现快速查询，避免重复处理名字。
    * 💡 **学习笔记**：`map`是处理字符串到整数映射的常用工具，适合小数据量场景。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为“枚举组合”和“计算加成”两部分，分别实现（如`dfs`枚举，`moni`计算），降低复杂度。
- **预处理优化**：提前将名字映射为编号，避免每次查询字符串的耗时。
- **循环顺序控制**：枚举时按升序选择英雄，避免重复组合（如六重循环中`a<b<c<d<e<f`）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，先看一个综合优质题解的通用核心实现，帮助把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了lzqy_和袁宇轩的DFS思路，结构清晰，适合新手学习。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    map<string, int> name_to_id;
    int v[35]; // 英雄基础贡献
    int bonus[35][35]; // 组合加成：bonus[i][j]表示i和j同时选中的加成
    int n, m, ans = 0;
    int selected[10]; // 记录当前选中的6个英雄编号
    bool used[35]; // 标记是否已选

    // 计算当前选中的6个英雄的总能力
    void calculate() {
        int total = 0;
        // 累加基础贡献
        for (int i = 1; i <= 6; ++i) total += v[selected[i]];
        // 累加所有两两组合的加成
        for (int i = 1; i <= 6; ++i)
            for (int j = i + 1; j <= 6; ++j)
                total += bonus[selected[i]][selected[j]];
        ans = max(ans, total);
    }

    // DFS枚举：从start开始选第k个英雄
    void dfs(int k, int start) {
        if (k > 6) { // 已选6个，计算总能力
            calculate();
            return;
        }
        for (int i = start; i <= n; ++i) { // 按顺序选，避免重复
            if (!used[i]) {
                used[i] = true;
                selected[k] = i;
                dfs(k + 1, i + 1); // 下一个英雄从i+1开始选
                used[i] = false;
            }
        }
    }

    int main() {
        cin >> n >> m;
        // 输入英雄信息，映射名字到编号
        for (int i = 1; i <= n; ++i) {
            string name;
            cin >> name >> v[i];
            name_to_id[name] = i;
        }
        // 输入组合加成
        for (int i = 0; i < m; ++i) {
            string a, b;
            int x;
            cin >> a >> b >> x;
            int id_a = name_to_id[a], id_b = name_to_id[b];
            bonus[id_a][id_b] += x;
            bonus[id_b][id_a] += x; // 双向加成
        }
        dfs(1, 1); // 从第1个英雄开始选第1个位置
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先通过`map`将英雄名字映射为编号（1~n），然后用`v`数组存储基础贡献，`bonus`数组存储两两组合的加成。`dfs`函数递归枚举所有6人组合（按升序选择避免重复），`calculate`函数计算当前组合的总能力（基础值+所有两两加成），最终输出最大值。

---
<code_intro_selected>
接下来剖析优质题解的核心代码片段，点出亮点和关键思路：
</code_intro_selected>

**题解一：来源：lzqy_**
* **亮点**：DFS枚举与计算分离，代码结构清晰；`together`数组记录组合加成，处理了重复组合的累加。
* **核心代码片段**：
    ```cpp
    void moni() {
        int pmax = 0;
        for (int i = 1; i <= 6; ++i) {
            pmax += power[a[i]]; // 累加基础贡献
            for (int j = 1; j <= n; ++j)
                if (k[j]) pmax += together[a[i]][j]; // 累加组合加成
        }
        ans = max(ans, pmax);
    }
    void dfs(int kk) {
        if (kk == 7) moni(); // 选够6个，计算
        else
            for (int i = a[kk - 1]; i <= n; ++i)
                if (!k[i]) {
                    k[i] = 1;
                    a[kk] = i;
                    dfs(kk + 1);
                    k[i] = 0;
                }
    }
    ```
* **代码解读**：
    > `dfs`函数递归选择英雄（`a[kk-1]`保证按升序选，避免重复），`k[i]`标记是否选中。`moni`函数计算总能力：先加基础贡献，再遍历所有英雄，若已选中（`k[j]`为真）则累加`together[a[i]][j]`（i是当前英雄，j是其他选中英雄）。这种分离式设计让代码更易读。
* 💡 **学习笔记**：将枚举和计算分离，是降低代码复杂度的有效方法。

**题解二：来源：gyh20**
* **亮点**：六重循环直接枚举，代码极短；计算加成时直接遍历两两英雄对。
* **核心代码片段**：
    ```cpp
    for (re int a=1;a<=n;++a)
        for (re int b=a+1;b<=n;++b)
            for (re int c=b+1;c<=n;++c)
                for (re int d=c+1;d<=n;++d)
                    for (re int e=d+1;e<=n;++e)
                        for (re int f=e+1;f<=n;++f)
                            ans = max(ans, val[a]+val[b]+val[c]+val[d]+val[e]+val[f] +
                                      g[a][b]+g[a][c]+g[a][d]+g[a][e]+g[a][f] +
                                      g[b][c]+g[b][d]+g[b][e]+g[b][f] +
                                      g[c][d]+g[c][e]+g[c][f] +
                                      g[d][e]+g[d][f] + g[e][f]);
    ```
* **代码解读**：
    > 六层循环按升序枚举所有6人组合（`a<b<c<d<e<f`），避免重复。计算总能力时，先加基础值（`val[a]+...+val[f]`），再遍历所有两两组合（`g[a][b]`到`g[e][f]`）累加加成。这种方式虽嵌套深，但逻辑直白，适合小数据量。
* 💡 **学习笔记**：六重循环是暴力枚举的“直白版”，适合理解枚举的底层逻辑。

**题解三：来源：袁宇轩**
* **亮点**：DFS参数设计巧妙（`x`当前英雄编号，`k`已选人数，`s`当前总贡献）；代码规范，使用`read`函数加速输入。
* **核心代码片段**：
    ```cpp
    void dfs(int x, int k, int s) {
        if (k > 6) { // 选够6个
            int res = s;
            for (int i = 2; i <= 6; ++i)
                for (int j = 1; j < i; ++j)
                    res += c[b[i]][b[j]]; // 累加两两加成
            ans = max(ans, res);
            return;
        }
        if (x > n) return;
        b[k] = x; // 选第x个英雄
        dfs(x + 1, k + 1, s + v[x]);
        dfs(x + 1, k, s); // 不选
    }
    ```
* **代码解读**：
    > `dfs`函数中，`x`表示当前考虑的英雄编号，`k`表示已选人数，`s`是当前总基础贡献（未加组合加成）。当`k>6`时，遍历已选英雄的两两组合（`i>j`）累加`c[b[i]][b[j]]`。这种设计将基础贡献的累加放在递归过程中，组合加成的累加放在递归终点，减少了重复计算。
* 💡 **学习笔记**：将基础贡献和组合加成的计算分离，可优化递归过程的效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解枚举过程和总能力计算，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素英雄选择器——寻找最强6人组`

  * **核心演示内容**：模拟DFS枚举所有6人组合，计算每个组合的总能力（基础值+组合加成），最终找到最大值。

  * **设计思路简述**：采用FC红白机风格的像素界面（8色调色板），用方块表示英雄（显示名字和基础值），选中的英雄高亮（如金色边框）。枚举时用箭头指示当前选择的英雄，计算加成时对应英雄方块闪烁并显示“+x”动画。音效方面，选中英雄时“叮”一声，完成一个组合计算时“滴答”一声，找到最大值时播放“胜利”音效，增加学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左边是“英雄池”（n个像素方块，每个方块显示英雄名字和基础值，颜色为蓝色）；右边是“当前选中”区域（6个空位，初始灰色）。
          * 控制面板：开始/暂停、单步执行、重置按钮；速度滑块（1-5倍速）。
          * 播放8位风格的轻快背景音乐（如《超级玛丽》主题变奏）。

    2.  **枚举启动**：
          * 点击“开始”，动画进入DFS枚举：第一个英雄方块（编号1）被箭头指向，闪烁后滑入“当前选中”第一个位置（变为金色），伴随“叮”音效。

    3.  **递归选择过程**：
          * 每选一个英雄（如选编号i），对应方块从“英雄池”滑入“当前选中”区域的下一个位置，显示编号（如位置k）。
          * 若选满6个英雄（k=6），进入“计算阶段”：所有选中的英雄方块高亮，基础值数字叠加（如“10→20→...”），同时遍历所有m组组合：若组合的两个英雄都在选中列表中，对应的两个方块闪烁（红色→金色），并显示“+x”动画（如“+20”），音效“叮”。

    4.  **最大值更新**：
          * 计算完成后，总能力值显示在屏幕顶部（如“当前最大：75”）。若当前组合的总能力超过之前最大值，数字变为绿色并放大，伴随“胜利”音效（如《魂斗罗》升级音）。

    5.  **回溯与继续枚举**：
          * 选满6个后，最后一个选中的英雄方块淡出（变为灰色），返回上一层递归，选择下一个英雄（如i+1），重复上述过程。

    6.  **AI自动演示模式**：
          * 点击“AI自动演示”，算法自动快速执行枚举（速度可调），学习者可观察整个过程，理解DFS的“选-回溯-再选”逻辑。

  * **旁白提示**：
      * （选第一个英雄时）“看！我们选了第1个英雄，现在需要再选5个~”
      * （计算加成时）“注意！Pharah和Mercy同时在场，总能力+20！”
      * （更新最大值时）“新的最大值出现了！当前总能力是75，这是目前的最优解~”

<visualization_conclusion>
通过这个像素动画，我们不仅能看到枚举的每一步，还能直观感受组合加成的计算过程，轻松理解暴力搜索的核心逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的枚举法后，我们可以将其应用到更多组合选择问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 枚举法适用于小数据量的组合选择问题，如团队分组（选k人）、物品选取（选k件）、排列问题（全排列中找最优）等。关键是识别数据范围是否允许枚举（如n≤30时，C(n,6)≤593775，可处理）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1036** - `选数`
          * 🗣️ **推荐理由**：同样是选k个数，计算它们的和是否为质数，适合巩固DFS枚举的应用。
    2.  **洛谷 P1103** - `书本整理`
          * 🗣️ **推荐理由**：需要枚举所有可能的排列，计算最小混乱度，训练枚举与排列的处理能力。
    3.  **洛谷 P1217** - `回文质数`
          * 🗣️ **推荐理由**：枚举所有可能的回文数，判断是否为质数，适合练习枚举与数论结合的问题。

-----

## 7\. 学习心得与经验分享 

<insights_intro>
题解中作者们的经验分享对我们很有启发，这里摘录并总结：
</insights_intro>

> **参考经验 (来自 lzqy_)**：“深搜的时候不用考虑那么多，只枚举简单的，至于后面的模拟，不要放在深搜里面执行，这样的思路会更清晰些。”
>
> **点评**：将枚举和计算分离是非常好的编程习惯！这样不仅代码更易读，还能减少递归时的计算量，降低出错概率。新手在写DFS时，常因逻辑混杂导致调试困难，这种分离式设计值得学习。

> **参考经验 (来自 袁宇轩)**：“比赛时没看到‘英雄组合可以重复，若重复请多次计数’，只得了70分。”
>
> **点评**：题目中的特殊条件（如“重复计数”）是易错点！读题时需仔细圈画关键条件，代码中用`+=`而非`=`处理加成，避免类似错误。

-----

<conclusion>
本次关于“准备战斗，选择你的英雄”的C++解题分析就到这里。希望这份指南能帮助大家掌握枚举法的核心技巧，理解暴力搜索的实现逻辑。记住，编程能力的提升需要多练习、多总结，下次我们再一起挑战新的算法题！💪
</conclusion>

---
处理用时：187.93秒
# 题目信息

# [YsOI2020] 植树

## 题目背景


Ysuperman 响应号召，决定在幼儿园里植树。

## 题目描述

Ysuperman 有一棵 $n$ 个节点的无根树 $T$。如果你不知道树是什么，TA 很乐意告诉你，树是一个没有环的无向联通图。

既然树是无根的，那就没有办法种植。Ysuperman 研究了很久的园艺，发现一个节点如果可以成为根，它必须十分平衡，这意味着以它为根时，与它**直接相连的节点，他们的子树大小都相同**。

你作为幼儿园信息组一把手，Ysuperman 给你一棵树，你能在 $1s$ 内找到所有可能成为根的节点吗？

## 说明/提示

### 样例说明

#### 样例说明 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gsiug69y.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1\}$，因为只有一个所以大小全部相同。

所以答案为 $1,2$。

#### 样例说明 $2$

![](https://cdn.luogu.com.cn/upload/image_hosting/p7fsretv.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1,3\}$，子树大小分别为 $\{1,2\}$，不相同。

以 $3$ 为根时，与 $3$ 直接相连的点有 $\{2,4\}$，子树大小分别为 $\{2,1\}$，不相同。

以 $4$ 为根时，与 $4$ 直接相连的点有 $\{3\}$，因为只有一个所以大小全部相同。

所以答案为 $1,4$。

----

### 数据范围

**本题采用捆绑测试。**

| $\rm{subtask}$ | $n$ |  分数|
| :-----------: | :-----------: | :----: |
| $1$ | $\le 5000$ | $40$ |
| $2$ | $\le 10^6$ | $60$ |

对于 $100\%$ 的数据，满足 $1 \le n\le 10^6$。

------

### 提示

由于输入输出量较大，你可能需要快速输入/输出。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
1 2 ```

## 样例 #2

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
1 4 
```

## 样例 #3

### 输入

```
9
1 2
1 3
4 1
5 1
1 6
1 9
8 1
1 7
```

### 输出

```
1 2 3 4 5 6 7 8 9 
```

# AI分析结果



---
# 💡 Kay的C++算法解析：[YsOI2020] 植树 深入学习指南 💡

<introduction>
今天我们来一起分析“[YsOI2020] 植树”这道C++编程题。这道题要求我们找出树中所有可能成为根的节点，条件是以该节点为根时，其所有直接相连的子树的大小都相同。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（树的遍历与子树分析）`

🗣️ **初步分析**：
解决这道题的关键在于利用树的遍历（DFS）高效计算子树大小，并通过子树大小判断每个节点是否满足条件。简单来说，树的遍历（DFS）就像“探险”，从一个起点出发，逐层访问所有节点，记录每个节点的“领地”（子树大小）。在本题中，DFS用于计算每个节点的子树大小，之后通过比较这些大小来判断该节点能否作为根。

- **题解思路**：所有优质题解的核心思路一致：选择一个根（如节点1）进行一次DFS，计算每个节点的子树大小；然后对每个节点，判断其所有直接子节点的子树大小是否相等，同时考虑父节点方向的子树大小（即`n - 当前节点的子树大小`）是否与子节点的子树大小一致。
- **核心难点**：如何高效计算子树大小（避免O(n²)复杂度），以及如何正确处理父节点方向的子树大小。
- **可视化设计**：我们将设计一个8位像素风格的动画，模拟DFS遍历过程（用像素方块表示节点，颜色变化表示访问状态），并动态展示每个节点的子树大小。关键步骤（如子树大小更新、条件判断）会用高亮和音效提示。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解（评分≥4星）：
</eval_intro>

**题解一：作者WanderingTrader（赞：11）**
* **点评**：此题解思路清晰，代码规范。通过一次DFS计算子树大小，并在遍历过程中直接判断每个节点是否满足条件。代码中`d[x]`表示子树大小，`root[x]`标记是否为合法根，变量命名直观。亮点在于通过`num`记录第一个子节点的子树大小，后续子节点与之比较，避免使用`set`等数据结构，降低了常数复杂度，适合大规模数据。

**题解二：作者____OccDreamer（赞：4）**
* **点评**：此题解逻辑简洁，代码结构清晰。通过链式前向星建图，DFS计算子树大小后，遍历每个节点判断其所有子节点的子树大小是否一致，并考虑父节点方向的子树大小。关键步骤（如父节点方向子树大小的计算）解释明确，适合初学者理解。

**题解三：作者sukimo（赞：3）**
* **点评**：此题解代码简洁高效，通过`ok`函数封装判断逻辑，增强了可读性。使用快速输入输出（`qin`和`qout`）处理大规模数据，符合题目对输入输出效率的要求。核心逻辑（子树大小比较）直接明了，适合竞赛环境。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何高效计算子树大小？**
    * **分析**：直接对每个节点作为根进行DFS会导致O(n²)复杂度，无法处理n=1e6的情况。优质题解通过一次DFS（以任意节点为根，如节点1）计算所有节点的子树大小，时间复杂度O(n)。例如，WanderingTrader的代码中，DFS递归计算每个节点的子树大小（`d[x]`），并在回溯时累加子节点的子树大小。
    * 💡 **学习笔记**：一次DFS即可获取所有节点的子树大小，避免重复计算。

2.  **关键点2：如何判断父节点方向的子树大小？**
    * **分析**：当节点x作为根时，其父节点（原根方向）的子树大小为`n - d[x]`（总节点数减去x的子树大小）。需要判断该值是否与x的其他子节点的子树大小相等。例如，在WanderingTrader的代码中，`if(x != 1 && num && num != n - d[x]) root[x] = 0` 这一行直接处理了这一判断。
    * 💡 **学习笔记**：父节点方向的子树大小=总节点数-当前节点的子树大小。

3.  **关键点3：如何处理叶子节点？**
    * **分析**：叶子节点（度数为1）作为根时，只有一个直接子节点（原父节点），其子树大小必然相同（只有一个），因此叶子节点一定是合法根。例如，在Pretharp的题解中，直接将叶子节点加入答案。
    * 💡 **学习笔记**：叶子节点一定是合法根，可直接标记。

### ✨ 解题技巧总结
- **问题抽象**：将“判断每个节点是否为合法根”转化为“比较其所有直接子节点的子树大小是否相等，并检查父节点方向的子树大小”。
- **代码模块化**：将子树大小计算（DFS）和判断逻辑（`ok`函数或直接在DFS中判断）分离，提高可读性。
- **边界处理**：特殊处理根节点（如节点1）和叶子节点，避免越界或逻辑错误。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了WanderingTrader和____OccDreamer的思路，采用DFS计算子树大小，并在DFS过程中直接判断每个节点是否为合法根，适用于n≤1e6的大规模数据。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e6 + 5;
    vector<int> es[N]; // 邻接表存树
    bool root[N];       // 标记是否为合法根
    int d[N];           // d[x]表示以初始根（如1）为根时，x的子树大小
    int n;

    // DFS计算子树大小，并判断是否为合法根
    int dfs(int x, int fa) {
        root[x] = true;
        int num = 0; // 记录第一个子节点的子树大小，用于比较
        d[x] = 0;
        for (int v : es[x]) {
            if (v == fa) continue;
            d[x] += dfs(v, x);
            if (num == 0) num = d[v];
            else if (num != d[v]) root[x] = false; // 子节点大小不一致
        }
        d[x]++; // 加上自身
        // 处理父节点方向的子树大小（x不是初始根时）
        if (x != 1 && num != 0 && (n - d[x]) != num) root[x] = false;
        return d[x];
    }

    int main() {
        scanf("%d", &n);
        for (int i = 1; i < n; ++i) {
            int u, v;
            scanf("%d%d", &u, &v);
            es[u].push_back(v);
            es[v].push_back(u);
        }
        dfs(1, 0); // 以1为初始根进行DFS
        for (int i = 1; i <= n; ++i) {
            if (root[i]) printf("%d ", i);
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先通过邻接表建树，然后以节点1为初始根进行DFS。DFS过程中计算每个节点的子树大小（`d[x]`），并在回溯时比较所有子节点的子树大小是否一致。最后处理父节点方向的子树大小（`n - d[x]`），判断是否与子节点大小一致。合法根节点会被标记为`root[x] = true`，最终输出所有合法根。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，理解其亮点和关键思路。
</code_intro_selected>

**题解一：作者WanderingTrader**
* **亮点**：在DFS过程中直接判断子节点大小是否一致，避免额外遍历，常数优化明显。
* **核心代码片段**：
    ```cpp
    int dfs(int x, int fa) {
        int size = es[x].size(), num = 0;
        root[x] = 1;
        _for(0, size - 1) // 遍历所有邻接点
            if (es[x][i] != fa) {
                d[x] += dfs(es[x][i], x);
                if (!num) num = d[es[x][i]];
                if (num != d[es[x][i]]) root[x] = 0;
            }
        ++d[x];
        if (x != 1 && num && num != n - d[x]) root[x] = 0;
        return d[x];
    }
    ```
* **代码解读**：这段代码中，`num`记录第一个子节点的子树大小，后续子节点与之比较。若不一致，则`root[x]`标记为`false`。最后，处理父节点方向的子树大小（`n - d[x]`），确保其与子节点大小一致。`++d[x]`表示加上自身，完成子树大小的计算。
* 💡 **学习笔记**：在DFS中同步完成子树大小计算和条件判断，减少重复遍历，提升效率。

**题解二：作者____OccDreamer**
* **亮点**：使用链式前向星建图，适合大规模数据；通过`fa`数组记录父节点，明确子节点关系。
* **核心代码片段**：
    ```cpp
    void dfs(int x) {
        f[x] = 1;
        siz[x] = 1;
        for (int i = head[x]; i; i = net[i]) {
            if (!f[to[i]]) {
                dfs(to[i]);
                siz[x] += siz[to[i]];
                fa[to[i]] = x;
            }
        }
    }
    // 主函数中判断
    for (int i = 2; i <= n; ++i) {
        now = siz[1] - siz[i];
        flag = 1;
        for (int j = head[i]; j; j = net[i])
            if (to[j] != fa[i])
                if (siz[to[j]] != now) { flag = 0; break; }
        if (flag) cout << i << ' ';
    }
    ```
* **代码解读**：`dfs`函数计算每个节点的子树大小（`siz[x]`）并记录父节点（`fa`）。主函数中，对于非初始根节点，计算父节点方向的子树大小（`siz[1] - siz[i]`），并比较所有子节点的子树大小是否一致。
* 💡 **学习笔记**：链式前向星建图适合处理大规模数据，父节点记录明确子节点关系。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解DFS遍历和子树大小计算的过程，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素树探险——寻找平衡根节点`

  * **核心演示内容**：演示DFS遍历过程（节点访问顺序、子树大小计算），以及每个节点作为根时的子树大小比较过程。

  * **设计思路简述**：采用8位像素风格（如FC游戏画面），用不同颜色的像素块表示节点（初始根为红色，其他节点为绿色）。通过动态变化的像素块大小表示子树大小，关键步骤（如子树大小更新、条件判断）用闪烁和音效提示，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕显示一个像素化的树结构（节点用圆形像素块，边用直线连接），初始根节点（如1号）标记为红色。
          * 控制面板包含“开始”“暂停”“单步”“重置”按钮，以及速度滑块（控制动画速度）。
          * 播放8位风格的轻快背景音乐。

    2.  **DFS遍历与子树大小计算**：
          * 从初始根节点开始，DFS访问子节点（像素块从红色变为黄色表示正在访问）。
          * 子节点访问完成后，父节点的子树大小（用数字显示在节点旁）累加子节点的子树大小（如子节点大小为2，父节点大小从1变为3）。
          * 访问完成的节点标记为蓝色，表示子树大小已确定。

    3.  **条件判断（是否为合法根）**：
          * 对于每个节点，遍历其所有子节点（用箭头指向子节点），比较子树大小（数字闪烁）。若所有子节点大小相同，节点边框变为绿色；否则变为红色。
          * 处理父节点方向的子树大小时，显示`n - d[x]`的值，并与子节点大小比较（数字对撞动画）。若一致，边框保持绿色；否则变为红色。

    4.  **结果展示**：
          * 所有节点处理完成后，合法根节点（绿色边框）闪烁，播放“胜利”音效；非法根节点（红色边框）保持静止。
          * 支持“AI自动演示”模式，自动播放完整过程，学习者可观察每个节点的判断逻辑。

  * **旁白提示**：
      * （访问子节点时）“现在访问节点2，它的子树大小初始为1。”
      * （比较子节点大小时）“节点1的子节点大小是4，是否与其他子节点一致？”
      * （处理父节点方向时）“父节点方向的子树大小是n - d[x] = 7 - 4 = 3，需要与子节点大小一致哦！”

<visualization_conclusion>
通过这样的像素动画，我们不仅能看到DFS遍历的路径，还能直观理解子树大小的计算和条件判断的逻辑，学习过程更有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以思考树的遍历和子树分析的其他应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 子树大小计算可用于树的重心判断（子树大小不超过总节点数的一半）。
      * 父节点方向的子树大小计算可用于换根DP（动态规划），解决“以每个节点为根的某属性”问题。
      * 子节点大小比较可用于判断树的对称性（如每个子树结构相同）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1378 油滴扩展** - `计算树中每个节点的子树大小，判断对称性`
          * 🗣️ **推荐理由**：练习子树大小计算和对称性判断，巩固本题思路。
    2.  **洛谷 P2016 战略游戏** - `树的最小顶点覆盖，涉及子树分析`
          * 🗣️ **推荐理由**：结合子树大小和动态规划，提升综合应用能力。
    3.  **洛谷 P1040 加分二叉树** - `树的遍历与子树权值计算`
          * 🗣️ **推荐理由**：练习不同遍历方式下的子树分析，拓展思维。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试和实现中的经验，对我们有很好的借鉴意义：
</insights_intro>

> **参考经验 (来自作者WanderingTrader)**：“多叉树的操作题相对二叉树来说可能较为简单，主要就是dfs要写对。有些常见操作（比如求结点大小，求结点深度）等可以打成模板存好，要用的时候可以借鉴一下。”

**点评**：作者的经验提醒我们，树的遍历（DFS/BFS）是处理树问题的基础，将常用操作（如子树大小计算）封装成模板，可以提高编码效率，减少错误。对于大规模数据，常数优化（如避免使用`set`）也很重要。

---

<conclusion>
本次关于“[YsOI2020] 植树”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握树的遍历和子树分析的核心技巧。记住，多动手实践、总结模板，是提升算法能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：154.01秒
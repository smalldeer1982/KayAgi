# 题目信息

# [NOI Online 2021 入门组] 吃豆人

## 题目描述

有一个 $n$ 行 $n$ 列的正方形点阵，左上角点坐标为 $(1, 1)$，右下角点坐标为 $(n, n)$。

点阵中每个整点上都有数量不一的豆子，坐标为 $(i, j)$ 的点上有 $a_{i,j}$ 个豆子。

你可以放置吃豆人，可以将点阵中任意的整点作为吃豆人的初始位置，再给定左上、左下、右上、右下之一作为吃豆人的初始方向。

吃豆人会不断沿初始方向行进，吃光遇到的所有豆子，直到碰到点阵的边界，此时：

1. 如果吃豆人处于正方形点阵四个角之一的位置，那么就会停止行动；

2. 否则，吃豆人的行进路线将以这条边界为镜面发生反射，下图展示了一个路径某两次发生反射的例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/6tji95nq.png)

现在，你需要放置两个吃豆人，求两个吃豆人最多共能吃到多少个豆子？注意同一个豆子只能被吃一次。


## 说明/提示

### 样例 1 解释

在 $(1, 1)$ 和 $(1, 3)$ 位置放置吃豆人，初始方向分别为右下和左下，即可吃到位于
$(1, 1)$，$(1, 3)$，$(2, 2)$，$(2, 4)$，$(3, 1)$，$(3, 3)$，$(4, 2)$，$(4, 4)$ 位置上的豆子，总个数为 $132$，
达到最大，路径分别如下图绿线和红线所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/1axaad1b.png)

### 数据范围

对于 $30\%$ 的数据，$n\leq 3$。

对于 $60\%$ 的数据：$n\leq 100$。

对于 $100\%$ 的数据：$2\leq n\leq 1000$，$0\leq a_{i,j}\leq 1000$。

数据由 [SSerxhs](https://www.luogu.com.cn/user/29826) 和 [Karry5307](https://www.luogu.com.cn/user/60990) 共同提供。

感谢 [Silence_water](https://www.luogu.com.cn/user/338630) 提供一组 hack 数据。

## 样例 #1

### 输入

```
4
20 1 19 2
3 18 4 17
16 5 15 6
7 14 8 13```

### 输出

```
132```

# AI分析结果



---
# 💡 Kay的C++算法解析：吃豆人 深入学习指南 💡

<introduction>
今天我们来一起分析“吃豆人”这道C++编程题。这道题需要我们在n×n的点阵中放置两个吃豆人，通过模拟它们的行进路径并计算最大豆子数。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与枚举的综合应用`

🗣️ **初步分析**：
> 解决“吃豆人”这道题，关键在于理解吃豆人的行进路径规律，并通过模拟和枚举找到最优解。简单来说，吃豆人的路径会在点阵边界反射，最终形成两种类型的路径：对角线（起点在第一行的两端）和矩形回路（起点在第一行的中间）。我们需要预处理每条路径的豆子和，再枚举所有可能的路径对，计算它们的总豆子数（减去重叠部分）。

- **题解思路**：所有优质题解均围绕“路径预处理+枚举路径对”展开。首先通过模拟吃豆人的移动，计算每条路径的豆子和；然后枚举所有可能的路径对，利用对称性或数学公式计算重叠部分，最终取最大值。
- **核心难点**：路径的预处理（如何高效计算每条路径的豆子和）、重叠部分的判断（如何确定两条路径是否重叠及重叠点的位置）。
- **可视化设计**：采用8位像素风格，模拟吃豆人移动：用不同颜色的像素块表示路径（如绿色代表第一条路径，红色代表第二条），当路径反射时播放“叮”的音效，重叠点用黄色闪烁高亮，直观展示路径生成和重叠计算过程。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性、算法有效性等方面表现突出（≥4星），值得重点学习：
</eval_intro>

**题解一：作者Mine_King (赞：40)**
* **点评**：此题解通过观察路径的对称性，总结出路径编号与重叠的规律，分类讨论重叠情况。代码逻辑清晰（如`repeat`函数专门处理重叠计算），变量命名直观（`b[i]`表示第i条路径的豆子和），边界处理严谨（如特判n=1的情况）。亮点在于通过画图和数学推导，将复杂的重叠计算转化为分类公式，大大降低了代码复杂度。

**题解二：作者Hanx16Kira (赞：26)**
* **点评**：此题解利用前缀和预处理斜线豆子和（`sum1`和`sum2`分别记录两种斜线方向的和），巧妙计算矩形路径的豆子和（通过四条斜线和减去顶点重复值）。代码结构工整，注释清晰，特别是对重叠点的坐标推导（利用中点公式）非常直观，适合理解路径重叠的数学本质。

**题解三：作者Poncirus (赞：15)**
* **点评**：此题解通过标记数组`vis`记录每个点所属的路径编号，动态计算重叠部分（`val[i][j]`存储路径i和j的重叠豆子和）。代码简洁（仅用一个循环模拟路径），思路巧妙（利用访问标记自动处理重叠），适合学习如何通过空间换时间优化枚举过程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，我为大家提炼了解决策略：
</difficulty_intro>

1.  **关键点1：如何预处理每条路径的豆子和？**
    * **分析**：吃豆人的路径分为对角线（起点在第一行两端）和矩形回路（起点在中间）。对角线的豆子和可直接累加斜线；矩形回路需模拟移动过程（反射时改变方向），累加所有经过的点。例如，Mine_King的代码通过`do-while`循环模拟移动，直到回到起点。
    * 💡 **学习笔记**：模拟路径时，需注意方向的变化规则（如碰到边界时方向按右下→左下→左上→右上循环）。

2.  **关键点2：如何判断两条路径是否重叠？**
    * **分析**：路径编号差为奇数时无重叠（中点非整数），偶数时有重叠。重叠点的坐标可通过对称性推导（如中点公式）。例如，Hanx16Kira的代码利用中点坐标`(x1+x2)/2`计算交点，再通过对称性得到其他交点。
    * 💡 **学习笔记**：重叠的本质是路径的对称性，利用坐标变换（如横纵坐标互换、关于中心对称）可快速定位重叠点。

3.  **关键点3：如何高效计算重叠部分的豆子和？**
    * **分析**：重叠部分的豆子和需根据路径类型（对角线vs回路）分类处理。例如，两条对角线仅在中心重叠一个点；一条对角线和一个回路重叠两个点；两个回路重叠四个点。Mine_King的`repeat`函数通过条件判断处理所有情况。
    * 💡 **学习笔记**：分类讨论是处理复杂重叠的关键，需覆盖所有可能的路径组合。

### ✨ 解题技巧总结
- **路径预处理**：用模拟法计算每条路径的豆子和，注意方向变化的规则。
- **重叠计算**：利用对称性和中点公式推导重叠点坐标，分类处理不同路径类型的重叠情况。
- **代码优化**：用前缀和数组（如`sum1`和`sum2`）加速斜线和的计算，用标记数组（如`vis`）记录重叠点。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合了多个优质题解的通用核心实现，帮助大家把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Mine_King和Hanx16Kira的思路，预处理每条路径的豆子和，枚举路径对并计算重叠部分，最终输出最大值。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    using namespace std;

    const int MAXN = 1005;
    int n, a[MAXN][MAXN];
    int sum[MAXN]; // sum[i]表示第i条路径的豆子和

    // 计算两条路径i和j的重叠豆子和
    int repeat(int i, int j) {
        if ((j - i) % 2 != 0) return 0; // 奇数差无重叠
        int d = (j - i) / 2;
        int x1 = 1 + d, y1 = (i + j) / 2;
        int x2 = y1, y2 = x1;
        int x3 = n - y1 + 1, y3 = n - x1 + 1;
        int x4 = y3, y4 = x3;

        // 分类处理重叠情况
        if (i == 1 && j == n) return a[(n + 1) / 2][(n + 1) / 2]; // 两条对角线
        if (i == 1 || j == n) return a[x1][y1] + a[x3][y3]; // 一条对角线+回路
        return a[x1][y1] + a[x2][y2] + a[x3][y3] + a[x4][y4]; // 两个回路
    }

    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j)
                scanf("%d", &a[i][j]);

        // 预处理对角线（i=1和i=n）
        for (int i = 1; i <= n; ++i) sum[1] += a[i][i];
        for (int i = 1; i <= n; ++i) sum[n] += a[i][n - i + 1];

        // 预处理中间路径（i=2到n-1）
        for (int i = 2; i < n; ++i) {
            int x = 1, y = i, dir = 0; // dir 0:右下，1:左下，2:左上，3:右上
            do {
                sum[i] += a[x][y];
                // 碰到边界时改变方向
                if (dir == 0 && y == 1) dir = 1;
                else if (dir == 1 && x == n) dir = 2;
                else if (dir == 2 && y == n) dir = 3;
                else if (dir == 3 && x == 1) dir = 0;
                x += (dir == 0 || dir == 1) ? 1 : -1; // 上下移动
                y += (dir == 0 || dir == 2) ? 1 : -1; // 左右移动
            } while (!(x == 1 && y == i)); // 回到起点停止
        }

        // 枚举所有路径对，计算最大值
        int ans = 0;
        for (int i = 1; i <= n; ++i)
            for (int j = i + 1; j <= n; ++j)
                ans = max(ans, sum[i] + sum[j] - repeat(i, j));

        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：该代码首先读取输入，预处理每条路径的豆子和（对角线直接累加，中间路径通过模拟移动计算）。然后枚举所有路径对，利用`repeat`函数计算重叠部分，最终输出最大豆子和。核心逻辑在路径预处理和重叠计算，模拟移动时通过方向变量`dir`控制反射。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的巧妙思路：
</code_intro_selected>

**题解一：作者Mine_King**
* **亮点**：通过分类讨论重叠情况，用`repeat`函数统一处理，逻辑清晰。
* **核心代码片段**：
    ```cpp
    int repeat(int x, int y) {
        if ((y - x) % 2) return 0;
        if (x == 1 && y == n) return a[(n + 1) / 2][(n + 1) / 2];
        if (x == 1) return a[(y + 1) / 2][(y + 1) / 2] + a[(2 * n - y + 1) / 2][(2 * n - y + 1) / 2];
        if (y == n) return a[(n - x) / 2 + 1][(n + x) / 2] + a[(n + x) / 2][(n - x) / 2 + 1];
        return a[(x + y) / 2][(y - x) / 2 + 1] + a[(y - x) / 2 + 1][(x + y) / 2] + a[n - (y - x) / 2][n - (x + y) / 2 + 1] + a[n - (x + y) / 2 + 1][n - (y - x) / 2];
    }
    ```
* **代码解读**：这段代码根据路径编号x和y的奇偶性判断是否重叠，再分类处理不同路径类型的重叠点。例如，当x=1（对角线）时，重叠点位于`(y+1)/2`和对称位置，直接返回这两个点的豆子和。这种分类方式覆盖了所有可能的重叠情况，确保计算准确。
* 💡 **学习笔记**：分类讨论时，需覆盖所有边界条件（如x=1或y=n），避免遗漏。

**题解二：作者Hanx16Kira**
* **亮点**：利用前缀和数组`sum1`和`sum2`快速计算斜线和，优化路径预处理。
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= n; ++j) {
            sum1[i][j] = sum1[i - 1][j - 1] + a[i][j]; // 右下斜线前缀和
            sum2[i][j] = sum2[i - 1][j + 1] + a[i][j]; // 右上斜线前缀和
        }
    }
    cnt[1] = sum1[n][n]; cnt[n] = sum2[n][1]; // 对角线和
    for (int i = 2; i < n; ++i) {
        cnt[i] = sum1[n][n - i + 1] + sum1[n - i + 1][n] + sum2[i][1] + sum2[n][n - i + 1] 
                - a[1][i] - a[i][1] - a[n - i + 1][n] - a[n][n - i + 1]; // 矩形路径和
    }
    ```
* **代码解读**：`sum1`和`sum2`分别记录从左上到右下、右上到左下的斜线前缀和。对角线（i=1）的和是`sum1[n][n]`（从(1,1)到(n,n)的斜线和），中间路径的和通过四条斜线和减去四个顶点的重复值（因为顶点被计算了两次）。这种方法将路径和的计算从O(n)优化到O(1)，大大提升了效率。
* 💡 **学习笔记**：前缀和是处理斜线和、矩形和的常用技巧，能显著降低时间复杂度。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解路径生成和重叠计算，我们设计了一个8位像素风格的动画演示方案，模拟吃豆人的移动过程和路径重叠。
</visualization_intro>

  * **动画演示主题**：`像素吃豆人探险记`

  * **核心演示内容**：展示吃豆人从第一行起点出发，沿初始方向移动、反射，形成路径的过程；高亮两条路径的重叠点，动态计算总豆子和（减去重叠部分）。

  * **设计思路简述**：采用8位像素风格（类似FC游戏），用不同颜色区分路径（绿色和红色），反射时播放“叮”的音效，重叠点用黄色闪烁。通过步进控制（单步/自动播放）和代码同步（高亮当前执行行），帮助学习者“看到”算法的每一步。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕显示n×n的像素网格（每个格子是8×8像素块），第一行标注起点（1,1）到（1,n）。
        - 控制面板包含“开始/暂停”“单步”“重置”按钮和速度滑块（1-10倍速）。
        - 播放8位风格的背景音乐（如《超级马里奥》经典旋律变奏）。

    2.  **路径生成演示**：
        - 选择一条路径（如i=2），吃豆人（像素小怪兽）从（1,2）出发，方向右下（箭头向右下）。
        - 每移动一格，当前格子高亮（绿色），播放“咔嚓”音效（吃豆子）。
        - 碰到边界时，方向改变（如右下→左下），播放“叮”的反射音效，箭头旋转90度。
        - 直到回到起点，路径完整显示（绿色线条），同时右侧显示该路径的豆子和（如“路径2：123颗”）。

    3.  **重叠计算演示**：
        - 选择另一条路径（如j=4），红色路径生成后，自动检测重叠点。
        - 重叠点（如（2,3））用黄色闪烁，播放“滴滴”音效，显示重叠豆子数（如“重叠：10颗”）。
        - 总豆子和动态计算（绿色和+红色和-黄色和），显示在屏幕顶部（如“当前最大：200颗”）。

    4.  **AI自动演示**：
        - 点击“AI演示”，程序自动枚举所有路径对，快速切换路径颜色，动态更新最大豆子和，类似“贪吃蛇”自动寻路，增强趣味性。

  * **旁白提示**：
      - （路径生成时）“看！吃豆人从（1,2）出发，向右下移动，碰到左边界后反射，方向变为左下……”
      - （重叠检测时）“这两个路径的编号差是2（偶数），所以有重叠点！看（2,3）在两条路径上，需要减去它的豆子数~”

<visualization_conclusion>
通过这样的动画，我们不仅能看到路径的生成过程，还能直观理解重叠计算的逻辑，让抽象的算法变得“看得见，摸得着”！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解了本题的解法后，我们可以将“路径模拟+重叠计算”的思路迁移到其他问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 路径模拟：适用于棋盘上的移动问题（如骑士周游、弹珠反射）。
      - 重叠计算：适用于求两个图形的交集（如矩形覆盖、线段交点）。
      - 预处理+枚举：适用于求最大值/最小值的组合问题（如选两个区间、选两条路径）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1006 传纸条**  
        * 🗣️ **推荐理由**：需要计算两条路径的最大和（不重复），与本题的重叠计算思路类似，适合巩固路径模拟和重叠处理。
    2.  **洛谷 P1077 摆花**  
        * 🗣️ **推荐理由**：通过预处理和枚举求组合数，与本题的预处理+枚举思路一致，适合练习动态规划和枚举优化。
    3.  **洛谷 P1335 新二叉树**  
        * 🗣️ **推荐理由**：涉及树结构的路径模拟，适合拓展路径分析的应用场景。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自作者Mine_King)**：“在计算路径和时，一开始忘记特判n=1的情况，导致边界错误。后来通过打印中间变量，发现当n=1时路径无法正确生成，于是添加了特判。”

**点评**：这位作者的经验提醒我们，边界条件（如n=1、路径起点在角落）是调试时的重点。通过打印中间变量（如路径和的计算过程）可以快速定位错误，这是非常实用的调试技巧！

-----

<conclusion>
本次关于“吃豆人”的C++解题分析就到这里。希望这份指南能帮助你理解路径模拟、重叠计算和枚举优化的核心技巧。记住，多画图、多调试，是掌握这类问题的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：169.46秒
# 题目信息

# 【模板】单调栈

## 题目背景

模板题，无背景。  

2019.12.12 更新数据，放宽时限，现在不再卡常了。

## 题目描述

给出项数为 $n$ 的整数数列 $a_{1 \dots n}$。

定义函数 $f(i)$ 代表数列中第 $i$ 个元素之后第一个大于 $a_i$ 的元素的**下标**，即 $f(i)=\min_{i<j\leq n, a_j > a_i} \{j\}$。若不存在，则 $f(i)=0$。

试求出 $f(1\dots n)$。

## 说明/提示

【数据规模与约定】

对于 $30\%$ 的数据，$n\leq 100$；

对于 $60\%$ 的数据，$n\leq 5 \times 10^3$ ；

对于 $100\%$ 的数据，$1 \le n\leq 3\times 10^6$，$1\leq a_i\leq 10^9$。

## 样例 #1

### 输入

```
5
1 4 2 3 5
```

### 输出

```
2 5 4 5 0
```

# AI分析结果



---
# 💡 Kay的C++算法解析：【模板】单调栈 深入学习指南 💡

<introduction>
今天我们来一起分析“【模板】单调栈”这道题。这道题是单调栈的经典应用，通过学习它，我们可以掌握如何用单调栈高效解决“下一个更大元素”的问题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`单调栈应用` (属于“编程技巧应用”分类)

🗣️ **初步分析**：
> 解决“【模板】单调栈”这道题，关键在于理解并运用单调栈。单调栈是一种特殊的栈结构，其栈内元素保持严格的单调性（如单调递减或递增）。可以想象成“排队的人”——如果新来的人比队尾的人高，那么队尾的人就会被“挤走”，直到队列为空或遇到更高的人，这样队列始终保持“从队尾到队头越来越高”的顺序。这种特性正好能高效解决“找下一个更大元素”的问题。

在本题中，我们需要对每个元素 `a[i]`，找到其右侧第一个比它大的元素的下标。单调栈的作用是维护一个“候选元素池”：从后往前遍历时，栈中保存的是可能成为当前元素右侧更大元素的下标。若当前元素比栈顶元素大，则栈顶元素不可能成为后续元素的候选（因为当前元素更靠右且更大），因此弹出栈顶；最终栈顶即为当前元素的答案。

- **题解思路对比**：多数题解采用从后往前遍历（如Mine_King的题解）或从前往后遍历（如LCuter的题解）维护单调递减栈。从后往前的写法更直观，因为直接记录“右侧第一个”；从前往后的写法则通过弹出栈顶元素时记录其答案（当前元素即为其右侧第一个更大元素）。
- **核心算法流程**：以从后往前遍历为例，步骤为：遍历数组 → 弹出栈顶比当前元素小的下标 → 栈顶（或0）即为当前元素的答案 → 将当前下标压入栈。
- **可视化设计**：计划采用8位像素风格动画，用不同颜色的方块表示栈中元素（如蓝色为栈内元素，红色为当前处理元素）。动画中会展示栈的压入/弹出过程，伴随“叮”的音效提示弹出操作，最终答案下标用绿色高亮。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：作者：Mine_King (赞：322)**
* **点评**：这份题解思路非常清晰，用生活中的“遮挡”现象类比单调栈的逻辑（后面矮的会被前面高的遮住，从而失去成为后续元素候选的资格），生动易懂。代码规范简洁，使用`stack<int>`模拟栈，变量名`a`（输入数组）、`f`（答案数组）含义明确。算法时间复杂度为O(n)，每个元素仅入栈和出栈一次，效率极高。从实践角度看，代码直接处理大规模数据（n≤3e6），边界条件（栈空时答案为0）处理严谨，是竞赛中的标准写法。

**题解二：作者：封禁用户 (赞：137)**
* **点评**：此题解用数组模拟栈（`q[INF]`），避免了STL栈的额外开销，更适合处理大规模数据（尤其在时间敏感的竞赛中）。作者用“集训队招人”的比喻解释单调栈的维护过程（能力值高的选手会淘汰前面能力低的），贴合青少年的理解习惯。代码中`r`作为栈顶指针，逻辑简洁；从后往前遍历的写法与Mine_King一致，但用数组模拟栈的方式更高效，值得学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何维护单调栈的单调性？
    * **分析**：单调栈的核心是“栈内元素保持单调递减”。从后往前遍历时，若当前元素`a[i]`大于栈顶元素对应的值（`a[s.top()]`），则栈顶元素无法成为后续元素的候选（因为`a[i]`更靠右且更大），需弹出栈顶。这一步确保了栈的单调性。例如，若栈顶是元素`j`，且`a[j] ≤ a[i]`，则`j`不可能是`i`左侧元素的答案，因为`i`更可能成为答案。
    * 💡 **学习笔记**：单调栈的维护关键在于“弹出不满足单调性的元素”，这一步是算法正确性的核心。

2.  **关键点2**：如何正确记录答案的下标？
    * **分析**：答案数组`f[i]`需要存储的是“第i个元素之后第一个大于`a[i]`的下标”。从后往前遍历时，栈中保存的是已处理的右侧元素的下标，因此弹出栈顶后，栈顶（若存在）即为当前元素的答案。例如，处理`i`时，弹出所有`j`满足`a[j] ≤ a[i]`，此时栈顶的`k`满足`a[k] > a[i]`，则`f[i] = k`。
    * 💡 **学习笔记**：答案的记录时机是在弹出栈顶元素后，此时当前元素即为被弹出元素的答案（若从前往后遍历）或栈顶为当前元素的答案（若从后往前遍历）。

3.  **关键点3**：如何处理边界情况（如没有更大的元素）？
    * **分析**：若遍历结束后栈为空，说明当前元素右侧没有更大的元素，此时`f[i] = 0`。例如，从后往前遍历时，若处理完`i`后栈为空，则`f[i] = 0`。这一步需要在代码中用三目运算符或条件判断处理。
    * 💡 **学习笔记**：边界条件（如栈空）的处理是代码鲁棒性的关键，需特别注意。

### ✨ 解题技巧总结
<summary_best_practices>
通过本题分析，总结以下通用技巧：
</summary_best_practices>
- **方向选择**：找“右侧第一个更大元素”时，从后往前遍历更直观；找“左侧第一个更大元素”时，从前往后遍历。
- **数组模拟栈**：处理大规模数据（如n≥3e6）时，用数组模拟栈（如`int q[MAXN]`）比STL的`stack`更高效，避免常数过大。
- **下标记录**：栈中保存下标而非元素值，便于直接记录答案的下标。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，我们先看一个综合优质题解的通用核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Mine_King和封禁用户的题解思路，采用从后往前遍历、数组模拟栈的方式，兼顾效率和可读性。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    const int MAXN = 3e6 + 5;
    int a[MAXN], f[MAXN], q[MAXN]; // q数组模拟栈，存储下标
    int main() {
        int n, r = 0; // r为栈顶指针（初始为0，表示空栈）
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
        for (int i = n; i >= 1; --i) {
            while (r > 0 && a[q[r]] <= a[i]) r--; // 弹出栈顶比当前元素小的下标
            f[i] = (r == 0) ? 0 : q[r]; // 栈空则为0，否则为栈顶下标
            q[++r] = i; // 当前下标入栈
        }
        for (int i = 1; i <= n; ++i) printf("%d ", f[i]);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先读取输入数组`a`，然后从后往前遍历每个元素`i`。维护一个栈`q`（用数组模拟），栈中保存的是已处理的右侧元素的下标，且对应的值单调递减。对于当前元素`i`，弹出所有栈顶元素（对应值≤`a[i]`），此时栈顶即为`i`右侧第一个更大元素的下标（或0）。最后将`i`压入栈，继续处理下一个元素。最终输出答案数组`f`。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者：Mine_King**
* **亮点**：使用STL的`stack`实现，代码简洁易读，适合理解单调栈的基础逻辑。
* **核心代码片段**：
    ```cpp
    #include <cstdio>
    #include <stack>
    using namespace std;
    int n, a[3000005], f[3000005];
    stack<int> s;
    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
        for (int i = n; i >= 1; --i) {
            while (!s.empty() && a[s.top()] <= a[i]) s.pop();
            f[i] = s.empty() ? 0 : s.top();
            s.push(i);
        }
        for (int i = 1; i <= n; ++i) printf("%d ", f[i]);
        return 0;
    }
    ```
* **代码解读**：
    > 这段代码的核心是从后往前遍历数组，用`stack<int>`维护单调递减栈。`s.top()`获取栈顶下标，`s.pop()`弹出不满足条件的元素。`f[i]`通过判断栈是否为空来记录答案。例如，当处理`i=3`时，若栈顶是`5`（对应`a[5]=5`），且`a[3]=2 < 5`，则`f[3]=5`；若栈空（如最后一个元素`i=5`），则`f[5]=0`。
* 💡 **学习笔记**：STL的`stack`适合快速实现，但处理超大规模数据时，数组模拟栈更高效。

**题解二：作者：封禁用户**
* **亮点**：用数组模拟栈（`q[INF]`），避免STL的额外开销，适合竞赛中的高效实现。
* **核心代码片段**：
    ```cpp
    #include <cstdio>
    #define INF 3000005
    int n, a[INF], q[INF], r, f[INF];
    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
        for (int i = n; i >= 1; --i) {
            while (a[i] >= a[q[r]] && r > 0) r--;
            f[i] = q[r];
            q[++r] = i;
        }
        for (int i = 1; i <= n; ++i) printf("%d ", f[i]);
        return 0;
    }
    ```
* **代码解读**：
    > 这段代码用数组`q`模拟栈，`r`为栈顶指针（初始为0）。从后往前遍历，若当前元素`a[i]`大于等于栈顶元素对应的值（`a[q[r]]`），则弹出栈顶（`r--`）。此时栈顶`q[r]`即为`i`的答案。例如，当`i=2`（`a[i]=4`）时，栈顶`q[r]=1`（`a[1]=1`），因`4>1`，弹出栈顶（`r--`后栈空），则`f[2]=0`？不，原代码中`q[0]`未初始化，实际应注意初始时栈为空（`r=0`），所以`f[i]`在栈空时为0。这里可能需要修正，但整体思路正确。
* 💡 **学习笔记**：数组模拟栈的关键是维护栈顶指针`r`，入栈时`r++`，出栈时`r--`，效率更高。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解单调栈的工作过程，我设计了一个“像素探险队”主题的8位风格动画，让我们“看”到栈的压入、弹出和答案的生成！
</visualization_intro>

  * **动画演示主题**：`像素探险队找更高山峰`

  * **核心演示内容**：模拟从后往前遍历数组时，每个元素作为“探险队员”寻找右侧第一个更高的“山峰”（更大的元素），通过单调栈的压入/弹出操作，最终确定每个队员的目标山峰下标。

  * **设计思路简述**：采用8位像素风格（类似FC红白机），用不同颜色的方块表示元素（如蓝色为普通队员，红色为当前处理队员，绿色为找到的目标山峰）。栈用垂直堆叠的像素块表示，弹出时方块“掉落”，压入时方块“升起”，配合音效增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧为“元素队列”（水平排列的像素方块，标注下标和值，如`[1:1] [2:4] [3:2] [4:3] [5:5]`）。
          * 右侧为“单调栈”区域（垂直堆叠的像素方块，栈底在下，栈顶在上）。
          * 控制面板包含“单步”、“自动播放”按钮和速度滑块。

    2.  **算法启动**：
          * 初始时栈为空（栈区域无方块），当前处理队员为最后一个元素（下标5，值5）。
          * 音效：轻快的8位音乐响起。

    3.  **核心步骤演示**：
          * **处理下标5**：栈空，直接压入栈（栈顶出现方块`[5:5]`），`f[5]`设为0（无更高山峰），音效“叮”。
          * **处理下标4**（值3）：栈顶是`[5:5]`（值5>3），无需弹出。`f[4]=5`（绿色高亮），压入`[4:3]`（栈变为`[5:5] [4:3]`），音效“叮”。
          * **处理下标3**（值2）：栈顶是`[4:3]`（值3>2），无需弹出。`f[3]=4`（绿色高亮），压入`[3:2]`（栈变为`[5:5] [4:3] [3:2]`），音效“叮”。
          * **处理下标2**（值4）：栈顶是`[3:2]`（值2≤4）→ 弹出（方块掉落，音效“噗”）；栈顶变为`[4:3]`（值3≤4）→ 弹出（音效“噗”）；栈顶变为`[5:5]`（值5>4），停止。`f[2]=5`（绿色高亮），压入`[2:4]`（栈变为`[5:5] [2:4]`），音效“叮”。
          * **处理下标1**（值1）：栈顶是`[2:4]`（值4>1），无需弹出。`f[1]=2`（绿色高亮），压入`[1:1]`（栈变为`[5:5] [2:4] [1:1]`），音效“叮”。

    4.  **目标达成**：
          * 所有元素处理完毕，答案数组`f`显示为`[2,5,4,5,0]`，播放胜利音效（“啦~”），绿色高亮所有答案。

    5.  **交互功能**：
          * 单步执行：点击“单步”按钮，逐元素演示处理过程。
          * 自动播放：滑块调节速度（慢→快），自动演示完整流程。
          * 代码同步：右侧显示当前步骤对应的核心代码（如`while (!s.empty() && a[s.top()] <= a[i]) s.pop();`），高亮当前执行行。

<visualization_conclusion>
通过这样的动画，我们可以直观看到单调栈如何通过压入和弹出操作，高效找到每个元素的“下一个更大元素”。像素风格的动画和音效让抽象的算法变得生动有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
单调栈的核心思想（维护单调序列，高效找边界）不仅适用于本题，还能解决许多类似问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 找“下一个更小元素”：将单调递减栈改为单调递增栈。
      * 直方图最大矩形（如LeetCode 84）：用单调栈找每个柱子左右第一个更小的边界。
      * 视野总和问题：统计每个元素右侧能看到的元素数量（即右侧第一个更大元素前的所有元素）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1901 发射站**
          * 🗣️ **推荐理由**：本题需要计算每个元素右侧第一个更大元素和左侧第一个更大元素的贡献，是单调栈的典型变形应用。
    2.  **洛谷 P2866 【USACO06NOV】糟糕的一天 Bad Hair Day**
          * 🗣️ **推荐理由**：统计每个牛右侧能看到的牛的数量（即右侧第一个更高牛前的所有牛），直接应用单调栈找“下一个更大元素”。
    3.  **洛谷 P5788 【模板】单调栈（本题）**
          * 🗣️ **推荐理由**：本题是模板题，掌握后可直接挑战上述变形题。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自 封禁用户)**：“我在解决这个问题时，最初在处理栈空的情况时出错，导致部分测试点答案错误。后来通过打印栈顶指针和栈内元素，发现是初始化时栈顶指针未正确置0。这让我意识到，边界条件的处理需要特别仔细，尤其是栈空时的判断。”
>
> **点评**：这位作者的经验很有参考价值。在编程中，栈空、数组越界等边界条件是常见的错误点。通过打印中间变量（如栈顶指针、栈内元素）可以快速定位问题，这是非常实用的调试技巧。

-----

<conclusion>
本次关于“【模板】单调栈”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握单调栈的核心思想和应用技巧。记住，多动手写代码、调试，是提升编程能力的关键！下次我们再一起探索新的算法挑战！💪
</conclusion>

---
处理用时：165.52秒
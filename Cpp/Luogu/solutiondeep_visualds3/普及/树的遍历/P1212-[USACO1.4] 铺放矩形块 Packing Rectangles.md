# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果


### 💡 Kay的C++算法解析：[USACO1.4] 铺放矩形块 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`枚举排列与布局模拟`  
🗣️ **初步分析**：
> 想象你有4块不同形状的积木，要拼成最小的矩形盒子。核心思路是尝试所有可能的排列组合（包括旋转积木方向），然后按6种基本布局计算盒子尺寸。  
> - **题解思路**：通过DFS或循环枚举所有矩形排列顺序和旋转方向（横/竖），对每种组合计算6种布局的封闭矩形尺寸
> - **核心难点**：第6种布局需根据矩形高度关系分情况讨论，容易遗漏边界条件
> - **可视化设计**：采用8位像素风格展示积木拼接过程，高亮当前放置的矩形，用不同颜色区分布局类型。当封闭矩形形成时播放"胜利音效"，分情况讨论时用闪烁提示关键高度比较

#### 2. 精选优质题解参考
**题解一（七喜）**  
* **亮点**：DFS递归实现排列组合，check函数清晰分离6种布局计算，注释详细解释第6种布局的分支条件  
* **代码规范性**：函数模块化（dfs+check），变量名`tmpx/tmpy`直观表示当前排列  
* **算法有效性**：完整覆盖USACO官方图示的6种布局，时间复杂度O(4!×2⁴×6)  
* **实践价值**：可直接用于竞赛，边界处理严谨（如第6种布局的`if-else`链）

**题解二（HFUUZY）**  
* **亮点**：四重循环实现排列组合，swap函数直接操作内存提升效率  
* **算法优化**：通过`change()`函数集中处理旋转和排列，避免DFS递归开销  
* **实践参考**：完整实现6种布局计算，特别展示第五种布局的合并技巧

**题解三（Chiesl）**  
* **亮点**：结构体存储答案实现自动去重，详细推导6种布局的数学公式  
* **调试技巧**：作者心得"画图分析第6种布局"值得借鉴，可视化辅助理解复杂分支

#### 3. 核心难点辨析与解题策略
1. **难点1：排列与旋转的完全枚举**  
   *分析*：4个矩形有4!排列顺序 × 2⁴旋转方向 = 384种组合。优质题解均用DFS/循环枚举，确保不漏解  
   💡 **学习笔记**：排列问题优先考虑`next_permutation`，旋转用位运算可优化

2. **难点2：第六种布局的分支处理**  
   *分析*：当矩形高度叠加时，需根据`h1+h3`与`h4`等关系分5种子情况计算长度  
   💡 **学习笔记**：用几何画板模拟高度堆叠关系，注意等号边界（如`h3==h4`）

3. **难点3：最小面积解的去重输出**  
   *分析*：相同面积可能对应不同长宽比（如4×10和5×8）。需统一存储为(小,大)格式  
   💡 **学习笔记**：`set<pair<int,int>>`自动去重，输出前按第一维排序

✨ **解题技巧总结**：
- **逆向思维**：先确定6种布局的拓扑结构，再推导尺寸计算公式
- **模块化调试**：单独验证每种布局的计算函数
- **边界压力测试**：用[1,50]的极值测试分支条件
- **可视化辅助**：绘制矩形位置关系图辅助推导

#### 4. C++核心代码实现赏析
**通用核心实现**（综合优质题解）：
```cpp
#include <iostream>
#include <algorithm>
#include <set>
using namespace std;

struct Rect { int w, h; } r[4];
set<pair<int, int>> solutions;
int min_area = INT_MAX;

void update(int x, int y) {
    if(x > y) swap(x, y);
    if(x*y < min_area) {
        min_area = x*y;
        solutions.clear();
    }
    if(x*y == min_area) solutions.insert({x, y});
}

// 第六种布局的分情况计算
int calcCase6(Rect a, Rect b, Rect c, Rect d) {
    int height = max(a.h + c.h, b.h + d.h);
    if(a.h + c.h <= d.h) 
        return max(b.w, max(a.w, c.w) + d.w);
    else if(c.h <= d.h) 
        return max(a.w + b.w, max(a.w, c.w) + d.w);
    // 其他分支省略...
}

void solveLayout(Rect v[4]) {
    /* 6种布局计算 */
    // 布局1: 四块横排
    update(v[0].w+v[1].w+v[2].w+v[3].w, 
           max({v[0].h, v[1].h, v[2].h, v[3].h}));
    // 布局2: 三横一竖
    update(max(v[0].w+v[1].w+v[2].w, v[3].w),
           max({v[0].h, v[1].h, v[2].h}) + v[3].h);
    // 布局6: 错位排列
    update(calcCase6(v[0],v[1],v[2],v[3]), 
           max(v[0].h+v[2].h, v[1].h+v[3].h));
}

int main() {
    // 输入与排列枚举核心
    int order[] = {0,1,2,3};
    do {
        for(int rot = 0; rot < 16; rot++) { // 2^4种旋转
            Rect cur[4];
            for(int i=0; i<4; i++) {
                cur[i] = (rot>>i & 1) ? Rect{r[order[i]].h, r[order[i]].w} 
                                      : r[order[i]];
            }
            solveLayout(cur);
        }
    } while(next_permutation(order, order+4));
    
    cout << min_area << endl;
    for(auto p : solutions) 
        cout << p.first << " " << p.second << endl;
}
```

**题解一（七喜）片段赏析**：
```cpp
// 第六种布局分支处理
if(tmpy[1]+tmpy[3] <= tmpy[4]) 
    x = max(tmpx[2], max(tmpx[1],tmpx[3])+tmpx[4]);
else if(tmpy[3] <= tmpy[4]) 
    x = max(tmpx[1]+tmpx[2], max(tmpx[1],tmpx[3])+tmpx[4]);
```
* **亮点**：用物理量命名提升可读性，分层处理高度关系  
* **学习笔记**：分支条件覆盖所有边界情况，是布局计算的精髓

#### 5. 算法可视化：像素动画演示
**主题**：8位机风格《积木拼图挑战》  
**核心演示**：  
![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)  
1. **像素化呈现**：
   - 4个矩形用不同颜色方块表示（红/蓝/绿/黄）
   - 网格画布随布局动态扩展，封闭矩形用闪烁金边标记

2. **交互控制面板**：
   ```plaintext
   [ 单步执行 ] [ 自动播放 ▶] 速度：▁▂▃▄▅
   当前布局：■ ■ ■ ■（类型1）
   最小面积：40（4×10）
   ```

3. **动态演示逻辑**：
   - **布局1**：四色方块横向滑入，伴随"滴"声效
   - **布局6**：分步演示高度比较（如红+绿 vs 蓝+黄），触发分支时显示条件提示框
   - **成功状态**：解锁像素奖杯🏆 + 胜利音效

4. **游戏化设计**：
   - 每完成一种布局获得星级评价（基于面积接近最优解程度）
   - 第六种布局作为Boss关，通过后播放8-bit胜利音乐

#### 6. 拓展练习
1. **相似问题迁移**：
   - 三维装箱问题（添加高度维度）
   - 矩形覆盖（P1156）
   - 动态规划优化枚举（如记忆化布局状态）

2. **洛谷推荐**：
   - P5917 [USACO]Pack Rectangles（双倍经验）  
     → 巩固布局枚举技巧
   - P3076 [USACO]拼图  
     → 拓展到不规则形状拼接
   - P1156 [USACO]矩形覆盖  
     → 转化思维：用矩形覆盖点集

#### 7. 学习心得
> **题解作者经验**：  
> "画图分析第6种布局的分支条件时，在纸上堆叠矩形模型，终于理解高度比较的逻辑" —— Chiesl  
>   
> **Kay的总结**：  
> 调试空间布局类问题时，实物模拟（纸片模型）比纯代码调试更有效。第六种布局的5个分支本质是几何关系的数学表达，建议推导时标注高度关系图。

---
处理用时：194.59秒
# 题目信息

# [GESP202403 七级] 俄罗斯方块

## 题目描述

小杨同学用不同种类的俄罗斯方块填满了一个大小为 $n \times m$ 的网格图。

网格图由 $n \times m$ 个带颜色方块构成。小杨同学现在将这个网格图交给了你，请你计算出网格图中俄罗斯方块的种类数。  
如果两个同色方块是四连通（即上下左右四个相邻的位置）的，则称两个同色方块直接连通；若两个同色方块同时与另一个同色方块直接或间接连通，则称两个同色方块间接连通。一个俄罗斯方块由一个方块和所有与其直接或间接连接的同色方块组成。定义两个俄罗斯方块的种类相同当且仅当通过**平移**其中一个俄罗斯方块可以和另一个俄罗斯方块重合；如果两个俄罗斯方块颜色不同，仍然视为同一种俄罗斯方块。

例如，在如下情况中，方块 $1$ 和方块 $2$ 是同一种俄罗斯方块，而方块 $1$ 和方块 $3$ **不是**同一种俄罗斯方块。

![](https://cdn.luogu.com.cn/upload/image_hosting/ttv3nmgs.png)

## 说明/提示

| 子任务 | 分数 | $n,m \leq$ | 特殊约定 | 
| :-: | :-: | :-: | :-: |
| $1$ | $30$ | $20$ | 所有俄罗斯方块大小不超过 $5 \times 5$ |
| $2$ | $30$ | $500$ | 所有俄罗斯方块大小均为 $1 \times x$ 或 $x \times 1$ 类型，其中 $x$ 是任意正整数|
| $3$ | $40$ | $500$ | 无 |

对全部的测试数据，保证 $1 \leq n, m \leq 500$，$1 \leq a_{i,j} \leq n \times m$。

## 样例 #1

### 输入

```
5 6
1 2 3 4 4 5
1 2 3 3 4 5
1 2 2 3 4 5
1 6 6 7 7 8
6 6 7 7 8 8
```

### 输出

```
7```

# AI分析结果

# 💡 Kay的C++算法解析：俄罗斯方块 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：搜索（DFS/BFS） + 编程技巧应用（形状标准化）

🗣️ **初步分析**：  
解决这道题的关键，就像“探险队探索未知区域”——首先用**搜索（DFS/BFS）**找到所有连通的同色块（俄罗斯方块），再用**形状标准化**给每个方块“拍张标准照”，这样平移后一样的方块会有相同的“标准照”。  

简单来说，搜索算法是“找连通块的工具”：比如DFS就像探险队从一个点出发，走遍所有相连的同色点；而形状标准化是“给连通块定身份”：把每个点的坐标减去连通块的最小行和最小列，再排序，这样不管方块在网格的哪个位置，形状一样的“标准照”都会完全相同。  

本题的核心难点是**如何让平移后的相同形状有唯一表示**，解决方案是“相对坐标+排序”；另一个难点是**高效判重**，用set或unordered_set存储标准化后的形状即可自动去重。  

可视化设计思路：用像素风格展示网格，搜索时用高亮色标记当前访问的点，标准化时动态展示坐标“缩放到左上角”的过程，set插入时用动画提示“新形状加入”。还可以加8位音效：搜索到新节点时“叮”一声，标准化完成时“滴”一声，统计完所有形状时播放“胜利”音效。


## 2. 精选优质题解参考

### 题解一：TPJX（来源：洛谷题解）  
* **点评**：这份题解思路非常清晰，把“找连通块”和“形状标准化”拆解得很明白。它用DFS找连通块，然后通过“减去最小行列+排序”将形状标准化，最后用set存这些标准化后的形状——整个流程就像“给每个方块拍标准照，然后把相同的照片归为一类”。代码规范，注释详细，尤其是`normalizeShape`函数把形状标准化的逻辑写得很直观，适合初学者理解。


### 题解二：Peiyuan（来源：洛谷题解）  
* **点评**：这道题解用BFS代替DFS找连通块，思路同样正确，但BFS的“层级扩展”更像“水慢慢淹没连通区域”。它直接存储每个点相对于起点的坐标（`c.x-sx, c.y-sy`），然后把这些相对坐标放入set——这种方法很简洁，避免了复杂的标准化步骤，适合喜欢“直接明了”的同学。代码行数少，逻辑清晰，是“用最少代码解决问题”的典范。


### 题解三：Lycd0719（来源：洛谷题解）  
* **点评**：此题解用DFS找连通块，然后通过“减最小行列+排序”标准化形状，最后用set存形状。它的`go`函数把标准化的过程单独抽离出来，代码结构很清晰。尤其是排序步骤，确保了即使相对坐标的顺序不同，形状相同的方块也会有相同的存储形式——这种“排序去序”的技巧很实用，能避免很多细节错误。


## 3. 核心难点辨析与解题策略

### 1. 如何让平移后的形状有唯一表示？  
* **难点**：同一个形状在网格的不同位置，坐标不同，直接存储坐标无法判重。  
* **解决方案**：存储相对坐标（每个点的坐标减去连通块的最小行和最小列），再排序。比如一个形状的点是(2,3)、(2,4)、(3,3)，最小行是2，最小列是3，相对坐标就是(0,0)、(0,1)、(1,0)，排序后顺序固定，不管原形状在哪里，相对坐标都一样。  


### 2. 如何高效判断形状是否重复？  
* **难点**：手动比较两个形状的所有点很麻烦，效率低。  
* **解决方案**：用set或unordered_set存储标准化后的形状。set会自动帮我们去重——只要把标准化后的形状插入set，最后set的大小就是不同形状的数量。  


### 3. 如何避免搜索时重复访问同一个点？  
* **难点**：如果不标记已访问的点，搜索会陷入死循环，或者重复计算同一个连通块。  
* **解决方案**：用vis数组标记每个点是否被访问过。每次搜索连通块时，把访问过的点标记为true，这样后续不会再处理这些点。  


### ✨ 解题技巧总结  
- **分解问题**：把“找连通块”和“判重”拆成两个独立的步骤，分别解决。  
- **标准化思维**：遇到平移、旋转等形状问题时，先把形状“标准化”（比如缩放到左上角、排序），再判重。  
- **工具利用**：善用set的自动去重功能，减少代码量。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了优质题解的思路，用DFS找连通块，标准化形状后用set存，是最经典的实现方式。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

const int MAXN = 505;
int grid[MAXN][MAXN];
bool vis[MAXN][MAXN];
int n, m;
int dx[] = {1, -1, 0, 0};
int dy[] = {0, 0, 1, -1};

void dfs(int x, int y, vector<pair<int, int>>& cells) {
    vis[x][y] = true;
    cells.push_back({x, y});
    for (int i = 0; i < 4; ++i) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (nx >= 0 && nx < n && ny >= 0 && ny < m && !vis[nx][ny] && grid[nx][ny] == grid[x][y]) {
            dfs(nx, ny, cells);
        }
    }
}

string normalize(const vector<pair<int, int>>& cells) {
    int min_x = cells[0].first, min_y = cells[0].second;
    for (auto& p : cells) {
        min_x = min(min_x, p.first);
        min_y = min(min_y, p.second);
    }
    vector<pair<int, int>> normalized;
    for (auto& p : cells) {
        normalized.push_back({p.first - min_x, p.second - min_y});
    }
    sort(normalized.begin(), normalized.end());
    string res;
    for (auto& p : normalized) {
        res += to_string(p.first) + "_" + to_string(p.second) + ";";
    }
    return res;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            cin >> grid[i][j];
        }
    }
    set<string> shapes;
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j) {
            if (!vis[i][j]) {
                vector<pair<int, int>> cells;
                dfs(i, j, cells);
                string s = normalize(cells);
                shapes.insert(s);
            }
        }
    }
    cout << shapes.size() << endl;
    return 0;
}
```
* **代码解读概要**：  
代码分三部分：1. DFS函数找连通块，把所有点存到cells里；2. normalize函数将cells标准化（减最小行列+排序）；3. 主函数遍历所有点，用set存标准化后的形状，最后输出set的大小。


### 题解一：TPJX的核心代码片段  
* **亮点**：把标准化形状的逻辑单独抽离，代码结构清晰。  
* **核心代码片段**：  
```cpp
string normalizeShape(vector<pair<int, int>>& cells) {
    int min_r = n, min_c = m;
    for (auto& cell : cells) {
        min_r = min(min_r, cell.first);
        min_c = min(min_c, cell.second);
    }
    sort(cells.begin(), cells.end(), [&](const pair<int, int>& a, const pair<int, int>& b) {
        if (a.first - min_r != b.first - min_r)
            return (a.first - min_r) < (b.first - min_r);
        return (a.second - min_c) < (b.second - min_c);
    });
    string shape;
    for (auto& cell : cells) {
        shape += to_string(cell.first - min_r) + "_" + to_string(cell.second - min_c) + ";";
    }
    return shape;
}
```
* **代码解读**：  
这段代码做了三件事：1. 找cells中的最小行min_r和最小列min_c；2. 按相对坐标排序（先排行，再排列）；3. 把相对坐标拼成字符串。比如cells是{(2,3),(2,4),(3,3)}，min_r=2，min_c=3，相对坐标是{(0,0),(0,1),(1,0)}，排序后顺序不变，拼成的字符串就是“0_0;0_1;1_0;”。  
* **学习笔记**：排序是标准化形状的关键——不管原连通块的点顺序如何，排序后都会变成统一的顺序。


### 题解二：Peiyuan的核心代码片段  
* **亮点**：用BFS找连通块，代码简洁，直接存储相对坐标。  
* **核心代码片段**：  
```cpp
void bfs(int sx, int sy) {
    queue<node> q;
    q.push({sx, sy});
    t.clear();
    while(q.size()){
        node c=q.front();q.pop();
        t.push_back({c.x-sx, c.y-sy});
        for(int i=0;i<4;i++){
            int nx=c.x+dx[i], ny=c.y+dy[i];
            if(nx>0&&nx<=n&&ny>0&&ny<=m&&!vis[nx][ny]&&a[nx][ny]==a[sx][sy]){
                vis[nx][ny]=1;
                q.push({nx, ny});
            }
        }
    }
    lst.insert(t);
}
```
* **代码解读**：这段BFS代码从(sx,sy)出发，把每个点的坐标减去sx和sy（即相对坐标），存到t里，最后插入set。比如sx=2，sy=3，点(2,4)的相对坐标是(0,1)，点(3,3)是(1,0)。  
* **学习笔记**：BFS和DFS都能找连通块，选哪个都行——BFS更像“层级扩展”，DFS更像“深度优先”，效果一样。


### 题解三：Lycd0719的核心代码片段  
* **亮点**：把标准化形状的过程写成`go`函数，逻辑直观。  
* **核心代码片段**：  
```cpp
void go() {
    int minx = INT_MAX, miny = INT_MAX;
    for (auto x : e) {
        minx = min(minx, x.first);
        miny = min(miny, x.second);
    }
    for (int i = 0; i < e.size(); i++) {
        e[i].first -= minx;
        e[i].second -= miny;
    }
    sort(e.begin(), e.end());
    s.insert(e);
}
```
* **代码解读**：`go`函数做了三件事：1. 找e中的最小行minx和最小列miny；2. 把每个点的坐标减去minx和miny；3. 排序后插入set。比如e是{(3,4),(3,5),(4,4)}，minx=3，miny=4，减后变成{(0,0),(0,1),(1,0)}，排序后插入set。  
* **学习笔记**：标准化形状的核心是“把形状缩放到左上角”，这样不管原形状在哪个位置，都会变成统一的“标准位置”。


## 5. 算法可视化：像素动画演示

### 动画主题：像素探险队找方块  
**设计思路**：用8位像素风模拟“探险队找连通块”的过程，结合音效和动画，让形状标准化和判重变得直观。

### 动画步骤：  
1. **初始化**：展示5x6的像素网格（对应样例输入），用不同颜色表示不同数字，左下角有“开始”“单步”“重置”按钮，顶部有速度滑块。  
2. **搜索连通块**：点击“开始”后，探险队（一个像素小人）从(0,0)出发，每走一步就把当前点标记为红色（已访问），同时用绿色高亮当前点。每访问一个新点，播放“叮”的音效。  
3. **标准化形状**：当探险队走完一个连通块，网格会“缩放到左上角”——比如原连通块在(2,3)到(3,4)，会动态移动到(0,0)到(1,1)，同时用黄色标记相对坐标的变化。  
4. **判重**：标准化后的形状会“飞进”右侧的set容器，若set中已有相同形状，会播放“滴”的提示音；若没有，播放“啪”的插入音，并更新形状数量。  
5. **完成**：所有连通块处理完后，屏幕显示“完成！不同形状数量：7”，播放8位胜利音效，背景变成彩虹色。

### 交互设计：  
- **单步模式**：点击“单步”按钮，动画走一步，方便观察每一步的变化。  
- **速度滑块**：调整动画速度，从“很慢”到“很快”。  
- **重置**：恢复初始状态，重新开始动画。

### 音效设计：  
- 搜索新点：“叮”（高频短音）  
- 标准化完成：“滴”（中频短音）  
- 插入新形状：“啪”（低频短音）  
- 完成：“胜利”（上扬的8位音乐）


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的“搜索+标准化+判重”思路可以用到很多地方：比如统计图片中的不同形状的物体，或者地图中的不同形状的区域。只要问题是“找连通块，判断形状是否相同”，都可以用这个思路。

### 洛谷推荐练习  
1. **P1596 [USACO10OCT] Lake Counting S**：这道题是“找连通块数量”的基础题，用DFS或BFS找水洼，适合巩固搜索技巧。  
2. **P2814 家谱**：用DFS找家族的连通块，需要存储相对关系，适合练习“相对坐标”的思路。  
3. **P1162 填涂颜色**：用BFS找外围的连通块，再填充内部，适合练习“反向搜索”的技巧。  
4. **P10379 俄罗斯方块（原题）**：再做一遍原题，巩固“标准化形状”的思路。


## 7. 学习心得与经验分享  
### 参考经验（来自TPJX）  
“对于每个未访问的单元格，使用DFS搜索所有连通的同色方块。使用集合来记录所有方块的唯一形状。使用二维数组记录每个单元格是否被访问过。”  
* **点评**：这段经验抓住了题目的核心——搜索找连通块、集合判重、vis数组标记。尤其是“用集合记录唯一形状”，直接点出了判重的关键，很值得借鉴。


## 结语  
本次分析了“俄罗斯方块”题的核心思路：搜索找连通块+标准化形状判重。希望大家能掌握“标准化”这个技巧——它能解决很多“形状相同”的问题。记住，编程的关键是“把复杂问题拆成简单步骤”，比如把本题拆成“找连通块”“标准化”“判重”三个步骤，每个步骤解决一个小问题，最后组合起来就是完整的解决方案。下次我们再一起探索更难的编程题！💪

---
处理用时：110.64秒
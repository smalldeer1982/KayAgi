# 题目信息

# 公路修建

## 题目描述

某国有 $n$ 个城市，它们互相之间没有公路相通，因此交通十分不便。为解决这一“行路难”的问题，政府决定修建公路。修建公路的任务由各城市共同完成。

修建工程分若干轮完成。在每一轮中，每个城市选择一个与它最近的城市，申请修建通往该城市的公路。政府负责审批这些申请以决定是否同意修建。

政府审批的规则如下：

1. 如果两个或以上城市申请修建同一条公路，则让它们共同修建；
2. 如果三个或以上的城市申请修建的公路成环。如下图，A 申请修建公路 AB，B 申请修建公路 BC，C 申请修建公路 CA。则政府将否决其中最短的一条公路的修建申请； 
3. 其他情况的申请一律同意。

![](https://cdn.luogu.com.cn/upload/image_hosting/apng39qc.png)

一轮修建结束后，可能会有若干城市可以通过公路直接或间接相连。这些可以互相连通的城市即组成“城市联盟”。在下一轮修建中，每个“城市联盟”将被看作一个城市，发挥一个城市的作用。

当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。

你的任务是根据城市的分布和前面讲到的规则，计算出将要修建的公路总长度。

## 说明/提示

修建的公路如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)

## 样例 #1

### 输入

```
4

0 0

1 2

-1 2

0 4```

### 输出

```
6.47```

# AI分析结果

# 💡 Kay的C++算法解析：公路修建 深入学习指南 💡

大家好，我是Kay！今天我们要解决的问题是**公路修建**——一道看似复杂，实则是**最小生成树（MST）模板题**的经典题目。通过这道题，我们能掌握稠密图下Prim算法的应用，还能学会如何避开“存储所有边”的大坑！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最小生成树（Prim算法）

🗣️ **初步分析**：  
题目看起来规则很多，但其实**本质是求平面点集的最小生成树**！为什么？我们逐一拆解规则：  
- 规则1：多个城市申请同一条路→共同修建→等价于“选这条边”（MST允许选边）。  
- 规则2：三个城市成环→否决最短边→但**这种情况不可能出现**（反证法：若A选B、B选C、C选A，则AB≤AC、BC≤AB、CA≤BC→AB=BC=CA，此时删任意一条边都不影响总长度最小）。  
- 规则3：其他情况同意→等价于“选所有不形成环的最短边”（MST的贪心策略）。  

而**Prim算法**是解决这类**稠密图（点多、边更多）**的最优选择——它不需要预存所有边（否则5000个点会存2500万条边，直接爆内存！），而是**现用现算距离**，完美贴合本题需求。

### Prim算法的核心逻辑（比喻版）
想象你有一个“城市联盟”，一开始只有1号城市。接下来每次**选离联盟最近的未加入城市**，把它拉进联盟，并记录连接它的最短公路长度。重复这个过程直到所有城市都加入——总长度就是答案！这就像你慢慢扩大朋友圈，每次加“最亲近的人”，最后所有人都成为朋友。

### 可视化设计思路
我们会用**8位像素风动画**演示Prim的过程：  
- 屏幕左侧是像素化的城市点（白点=未加入联盟，蓝点=已加入）。  
- 右侧是控制面板（单步执行、自动播放、重置、速度滑块）。  
- 每次选点时，**高亮当前最短边**（比如从蓝点1到白点2的线变亮），播放“叮”的音效；更新其他点的距离时，**闪烁对应点的数字**（比如3号点的距离从5变成3）。  
- 完成时，所有点变成蓝点，播放“胜利音效”（类似FC游戏通关的“叮~当~”），屏幕显示总长度。


## 2. 精选优质题解参考

我从思路清晰度、代码可读性、算法有效性三个维度，筛选了3份**超棒的题解**：

### 题解一：MY的Prim模板（赞422）
* **点评**：这份题解是Prim算法的“标准教科书实现”！思路直白——直接点出“题目是最小生成树”，然后用Prim算法解决。代码规范：变量名`x/y`存坐标、`dis`存点到联盟的最短距离、`book`标记已选点，一看就懂。最棒的是**现算距离**（用`get_e`函数实时计算两点距离），完美避开了“存边爆内存”的坑。注释详细，甚至连“double类很大不会炸”都提醒了，对新手非常友好！

### 题解二：EricWay1024的Prim思想解释（赞113）
* **点评**：这份题解的亮点是**把Prim的思想讲透了**！对比Kruskal（“以边为中心，选最小的有用边”）和Prim（“以点为中心，选离联盟最近的点”），让你明白为什么Prim适合本题（稠密图不需要存边）。代码中用`struct POINT`封装坐标，还重载了`operator*`计算距离的平方，细节处理很专业。

### 题解三：逆时针的记忆的sqrt优化（赞21）
* **点评**：这份题解的小技巧很实用！因为`sqrt`计算比较慢，作者**先存距离的平方**（用`qq`函数计算），最后再统一开方求和。这样能减少`sqrt`的调用次数，提升速度。代码中`d`数组存的是距离的平方，最后`ans+=sqrt(d[i])`，这个优化很聪明！


## 3. 核心难点辨析与解题策略

在解决本题时，新手常遇到3个“拦路虎”，我们逐一解决：

### 1. 难点1：稠密图的边怎么存？
**问题**：5000个点，预存所有边需要`5000*5000=2500万`个`double`（约200MB），超过题目内存限制（128MB）。  
**解决策略**：**现用现算距离**！不需要存所有边，每次需要计算两点距离时，用坐标直接算（比如`get_e(x1,y1,x2,y2)`）。这样内存只需要存`x/y`数组（各5000个元素，约40KB），完全没问题。

### 2. 难点2：距离计算的精度和溢出？
**问题**：坐标范围是`-1e6~1e6`，平方后会达到`1e12`，用`int`会溢出（`int`最大约2e9）。  
**解决策略**：  
- 用`long long`存坐标（或者计算平方时强制转换为`double`），比如`(double)(x1-x2)*(x1-x2)`。  
- 或者先存距离的平方（用`long long`），最后再开方（如逆时针的记忆的题解）。

### 3. 难点3：Prim算法的核心逻辑是什么？
**问题**：Prim的循环怎么写？`dis`数组怎么更新？  
**解决策略**：  
- `dis[i]`表示**点i到当前联盟的最短距离**（初始时`dis[1]=0`，其他为无穷大）。  
- 每次循环：①选`dis`最小的未选点`curr`；②将`curr`加入联盟（`book[curr]=true`）；③更新所有未选点的`dis`（如果`curr`到该点的距离比原来的`dis`小，就更新）。  
- 总结：**选点→加联盟→更新距离**，重复n次。

💡 **解题技巧总结**  
- 稠密图用Prim，稀疏图用Kruskal（记住这个规律！）。  
- 现算距离能避免存边爆内存。  
- 先算平方再开方，能优化速度和避免溢出。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合MY、EricWay1024等题解的思路，提炼的标准Prim实现，清晰易懂。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cmath>
#include <cstring>
using namespace std;

const int MAXN = 5010;
const double INF = 1e12; // 表示无穷大

int n;
double x[MAXN], y[MAXN]; // 城市坐标
double dis[MAXN];         // dis[i]：点i到当前联盟的最短距离
bool book[MAXN];          // book[i]：点i是否已加入联盟
double ans = 0;           // 总公路长度

// 计算两点间距离
double get_dist(int a, int b) {
    double dx = x[a] - x[b];
    double dy = y[a] - y[b];
    return sqrt(dx*dx + dy*dy);
}

void prim() {
    // 初始化：1号点加入联盟，dis[1]=0
    memset(book, false, sizeof(book));
    for (int i = 1; i <= n; i++) {
        dis[i] = INF;
    }
    dis[1] = 0;
    book[1] = true;

    for (int i = 1; i <= n; i++) { // 选n次点（每次加一个点）
        // 步骤1：找dis最小的未选点curr
        int curr = -1;
        double min_dis = INF;
        for (int j = 1; j <= n; j++) {
            if (!book[j] && dis[j] < min_dis) {
                min_dis = dis[j];
                curr = j;
            }
        }
        if (curr == -1) break; // 所有点都加入了，提前退出

        // 步骤2：将curr加入联盟，累加长度
        book[curr] = true;
        ans += dis[curr];

        // 步骤3：更新其他点的dis
        for (int j = 1; j <= n; j++) {
            if (!book[j]) {
                double d = get_dist(curr, j);
                if (d < dis[j]) {
                    dis[j] = d;
                }
            }
        }
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> x[i] >> y[i];
    }
    prim();
    printf("%.2lf\n", ans); // 保留两位小数
    return 0;
}
```
* **代码解读概要**：  
  1. `get_dist`函数：用勾股定理计算两点间距离（`sqrt(dx²+dy²)`）。  
  2. `prim`函数：核心逻辑——初始化→选点→加联盟→更新距离，循环n次。  
  3. `main`函数：读入坐标→调用`prim`→输出总长度。


### 各优质题解的片段赏析

#### 题解一：MY的现算距离（来源：MY）
* **亮点**：用`get_e`函数实时计算距离，避免存边。
* **核心代码片段**：
```cpp
double get_e(double x1, double y1, double x2, double y2) {
    return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));
}

// 在prim中更新dis：
for (int j = 1; j <= n; j++) {
    dis[j] = min(dis[j], get_e(x[curr], y[curr], x[j], y[j]));
}
```
* **代码解读**：  
  每次选完`curr`点，就用`get_e`计算`curr`到所有未选点的距离，如果比原来的`dis[j]`小，就更新`dis[j]`。这样不需要预存任何边，内存用得极少！
* 💡 **学习笔记**：现算距离是解决稠密图MST的关键技巧！

#### 题解三：逆时针的记忆的sqrt优化（来源：逆时针的记忆）
* **亮点**：先存距离的平方，最后再开方，减少`sqrt`调用次数。
* **核心代码片段**：
```cpp
double qq(double x, double x1, double y, double y1) {
    return (x-x1)*(x-x1) + (y-y1)*(y-y1); // 距离的平方
}

// 在prim中更新dis：
for (int j = 1; j <= n; j++) {
    if (!v[j] && qq(x[k], x[j], y[k], y[j]) < d[j]) {
        d[j] = qq(x[k], x[j], y[k], y[j]);
    }
}

// 最后求和时开方：
for (int i = 1; i <= n; i++) ans += sqrt(d[i]);
```
* **代码解读**：  
  `qq`函数返回距离的平方（没有`sqrt`），`d`数组存的是平方值。最后求和时才对每个`d[i]`开方，这样`sqrt`只调用了n次（原本是n²次），速度更快！
* 💡 **学习笔记**：计算量大的函数（如`sqrt`）要尽量少调用！


## 5. 算法可视化：像素动画演示（核心部分）

### 动画设计方案（8位像素风）
我们用**FC红白机风格**的动画，让Prim算法“动起来”！

#### 1. 场景与UI初始化
- **屏幕布局**：左侧是`10x10`的像素网格（模拟城市分布），右侧是控制面板（按钮+滑块）。
- **颜色方案**：  
  - 白点：未加入联盟的城市（`#FFFFFF`）。  
  - 蓝点：已加入联盟的城市（`#0000FF`）。  
  - 高亮边：当前选中的最短边（`#FFFF00`，闪烁）。  
- **控制面板**：  
  - 按钮：开始/暂停、单步执行、重置（像素化的矩形，点击时变色）。  
  - 滑块：调整自动播放速度（从“慢”到“快”）。
- **背景音乐**：循环播放8位风格的轻快BGM（类似《超级马里奥》的背景音）。

#### 2. 动画步骤演示
以样例输入（4个城市）为例：
1. **初始化**：1号城市（坐标`(0,0)`）变成蓝点，`dis`数组显示：`dis[1]=0`，`dis[2]=√(1²+2²)=2.24`，`dis[3]=√((-1)²+2²)=2.24`，`dis[4]=√(0²+4²)=4.00`。
2. **单步1**：选`dis`最小的未选点（2号或3号，假设选2号）。2号变成蓝点，高亮1→2的边，播放“叮”的音效。更新`dis`：`dis[3]`变成`√((-1-1)²+(2-2)²)=2.00`（比原来的2.24小），`dis[4]`变成`√((0-1)²+(4-2)²)=√5≈2.24`（比原来的4.00小）。
3. **单步2**：选`dis`最小的未选点（3号，`dis=2.00`）。3号变成蓝点，高亮2→3的边，播放“叮”的音效。更新`dis[4]`：`√((0+1)²+(4-2)²)=√5≈2.24`（不变）。
4. **单步3**：选`dis`最小的未选点（4号，`dis=2.24`）。4号变成蓝点，高亮2→4的边，播放“叮”的音效。
5. **完成**：所有点都是蓝点，播放胜利音效（“叮~当~”），屏幕显示总长度`0+2.24+2.00+2.23=6.47`（与样例输出一致）。

#### 3. 交互设计
- **单步执行**：点击“单步”按钮，执行一次选点+更新操作，方便仔细观察。
- **自动播放**：点击“开始”，动画按滑块速度自动执行（最慢1秒/步，最快0.1秒/步）。
- **重置**：回到初始状态，重新演示。

#### 4. 设计目的
- 像素风格：唤起复古游戏的回忆，让学习更有趣。
- 高亮与音效：强化“选点”“更新距离”等关键步骤的记忆。
- 交互控制：让你自主探索算法流程，加深理解。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
Prim算法不仅能解决“公路修建”，还能解决**所有需要连接所有点且总长度最小**的问题，比如：
1. **电网铺设**：连接所有村庄的电线，总长度最短。
2. **管道安装**：连接所有工厂的管道，总长度最短。
3. **网络布线**：连接所有办公室的网线，总长度最短。

### 洛谷练习推荐
以下题目能帮你巩固Prim算法的应用：
1. **洛谷 P3366** - 最小生成树  
   🗣️ **推荐理由**：MST的模板题，直接用Prim或Kruskal解决，巩固基础。
2. **洛谷 P1546** - 最短网络  
   🗣️ **推荐理由**：和本题几乎一样，也是平面点集的MST，练手必备。
3. **洛谷 P2820** - 回家路线  
   🗣️ **推荐理由**：MST的变种，需要先建图（将路线视为边），再求MST，拓展思路。
4. **洛谷 P1194** - 买礼物  
   🗣️ **推荐理由**：MST的变形，需要将“优惠”转化为边权，锻炼建模能力。


## 7. 学习心得与经验分享

从题解中，我们能学到很多实用的**踩坑经验**：
- **MY的经验**：用`double`存距离时，初始值要设得足够大（比如`1e12`），避免被小值覆盖。
- **Cat_cc的经验**：计算距离时，要将坐标强制转换为`double`（比如`(double)(x1-x2)`），否则`int`平方会溢出。
- **逆时针的记忆的经验**：`sqrt`计算慢，先存平方再开方，能优化速度。

这些经验都是前辈们“踩坑”总结出来的，记住它们能帮你少走很多弯路！


## 结语
通过这道题，我们掌握了**稠密图下的Prim算法**，学会了“现算距离”“sqrt优化”等实用技巧，还通过像素动画直观理解了算法流程。记住：**编程的进步来自“多做、多想、多总结”**——下次遇到MST问题，你一定能轻松解决！

下次我们再一起探索新的算法挑战，加油！💪

---
处理用时：116.66秒
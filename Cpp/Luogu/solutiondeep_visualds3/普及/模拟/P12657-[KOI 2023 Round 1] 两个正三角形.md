# 题目信息

# [KOI 2023 Round 1] 两个正三角形

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

如图所示，第 1 行有 1 个数，第 2 行有 2 个数，……，第 $N$ 行有 $N$ 个数，构成一个正三角形。给定两个这样的正三角形 $A$ 和 $B$，每个位置上的数为 0 或 1。

![](https://cdn.luogu.com.cn/upload/image_hosting/9z381rzh.png)

你可以对正三角形进行顺时针或逆时针方向的 $120^\circ$ 旋转，也可以进行左右对称变换。

例如，将图中的正三角形 $A$ 进行旋转后可以得到如下的正三角形。

![](https://cdn.luogu.com.cn/upload/image_hosting/gt35kinw.png)

将 $A$ 进行对称变换后可以得到如下的正三角形。

![](https://cdn.luogu.com.cn/upload/image_hosting/uf9lbcxb.png)

两个正三角形的“差异”定义为：将它们重叠后，数值不同的位置的数量。

例如，若将正三角形 $A$ 和 $B$ 重叠，在第 2 行最左侧，以及第 3 行的最左侧和最右侧位置的数值不同，因此 $A$ 和 $B$ 的差异为 3。

但若将 $A$ 逆时针旋转 $120^\circ$ 后再与 $B$ 重叠，仅在第 3 行从左起第 2 个位置的数值不同，这时差异为 1。

给定两个正三角形 $A$ 和 $B$。你可以对 $A$ 进行任意次数的旋转或对称操作。你也可以选择不进行任何变换。操作次数不限。

请将 $A$ 变换为与 $B$ 差异最小的形态，并输出此时的最小差异值。

## 说明/提示

**样例 1 说明**

将 $A$ 逆时针旋转 $120^\circ$ 后，仅有一个位置与 $B$ 不同，差异为 1。还有其他方式也可以使差异为 1。

**限制条件**

- 所有给定的数值均为整数。
- $1 \leq N \leq 10$
- $A$ 和 $B$ 中每个位置的数值仅为 0 或 1。

**子问题**

1. （5 分）$A$ 中所有数值相同。换言之，$A$ 中所有位置均为 0 或均为 1。
2. （10 分）$N \leq 2$
3. （40 分）仅考虑旋转操作即可得到最优解。
4. （45 分）无额外限制。

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
3
0
1 0
1 0 0
0
0 0
0 0 1```

### 输出

```
1```

## 样例 #2

### 输入

```
4
0
1 1
1 0 0
1 0 0 0
0
0 0
0 0 1
1 1 1 0```

### 输出

```
0```

## 样例 #3

### 输入

```
4
0
1 0
0 0 1
1 1 0 0
0
0 1
0 0 0
0 1 1 1```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：两个正三角形 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：模拟  

🗣️ **初步分析**：  
解决这道题就像玩“积木匹配游戏”——我们有一个积木（三角形A），可以把它旋转、翻转，摆出最多6种不同的样子，然后看哪一种和目标积木（三角形B）长得最像（差异最小）。**模拟**的核心就是“枚举所有可能的状态，逐一验证”——在这里，我们需要把A的所有可能变换形态都“摆出来”，计算每个形态与B的差异，最后选最小的那个。  

### 核心思路与难点
- **题解思路**：所有题解的核心都是**生成A的6种可能形态**（原形态、顺时针转120°、转240°、对称、对称后转120°、对称后转240°），然后计算每个形态与B的差异，取最小值。  
- **核心难点**：**正确实现旋转和对称的坐标变换**——三角形的行是“下一行比上一行多一个元素”，不是矩形，所以每个位置的变换需要找对规律（比如旋转120°时，原第i行第j列的元素要跑到哪里？）。  
- **解决方案**：通过观察三角形的结构，总结出变换的坐标公式（比如1-based的旋转公式：原(i,j)→新(j',i')，其中j'是从下往上数的行，i'是该行的列；对称公式是每行左右翻转，即(i,j)→(i,i-j+1)）。  

### 可视化设计思路
我们会做一个**8位像素风的三角形模拟器**：  
- 每个位置用16x16的像素块表示（0是浅蓝，1是浅红），B的像素块固定在右侧，A的变换形态在左侧动态展示。  
- 变换时，比如旋转120°，每个像素块会从原位置“滑”到新位置（伴随“咻”的像素音效）；对称时，左右的像素块会“交换位置”（伴随“叮”的音效）。  
- 每个形态展示后，差异的位置会闪烁黄色，屏幕下方实时显示当前差异值。最后所有形态播放完，高亮差异最小的形态，伴随“胜利”的上扬音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了以下3个优质题解，帮大家快速理解解题关键：
</eval_intro>

**题解一：(来源：syh110213)**  
* **点评**：这份题解的思路像“列清单”一样清晰——直接生成A的6种形态（原、转1、转2、对称、对称转1、对称转2），每个形态用单独的数组存储，然后逐一计算差异。代码变量命名明确（比如`a1`是转一次的结果，`c`是对称的结果），`contrast`函数专门计算差异，逻辑非常直白。特别适合刚学模拟的同学，一眼就能看懂“每一步在做什么”。  

**题解二：(来源：XuZile)**  
* **点评**：此题解的思路是“循环变换+比较”——通过`round`函数旋转，`turn`函数对称，然后重复多次变换来覆盖所有形态。虽然思路有点绕（比如`turn`函数里先对称再比较），但代码能正确解决问题。需要注意的是，这种“循环尝试”的方式要确保覆盖所有6种形态，避免遗漏。  

**题解三：(来源：枫原万叶)**  
* **点评**：这份题解的亮点是**函数封装**——把旋转和对称写成独立函数（`fun1`旋转120°，`fun2`对称），并明确给出了坐标变换公式（比如旋转时`d[i][j] = s[n-1-j][i-j]`）。这种“模块化”的写法让代码更易维护，也帮我们理解“变换的本质是坐标映射”。适合想深入理解变换规律的同学。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“把变换做对”和“把差异算准”，以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **难点1：正确实现旋转的坐标变换**  
    * **分析**：三角形的行是“第i行有i个元素”，旋转120°时，原位置(i,j)（1-based）的元素要转到哪里？比如样例中n=3，原第3行第1列的元素，旋转后会到第1行第1列吗？需要找对规律。  
    * **策略**：通过**小例子推导公式**——比如n=3时，原(i,j)→新(x,y)的规律：  
      - 旋转120°（顺时针）：原第i行第j列 → 新第j行第(i-j+1)列？或者反过来？可以用样例验证：比如样例1中的A旋转后，原第3行第1列的1（行i=3，j=1），旋转后到第1行第1列吗？看样例1的输入，A的第3行是1 0 0，旋转后第1行是0（原A的第3行第1列？不对，可能需要用0-based更方便：题解三的公式是`d[i][j] = s[n-1-j][i-j]`（0-based），比如n=3，i=2（第3行），j=0（第1列），则n-1-j=2-0=2？可能需要实际代入验证。  
    * 💡 **学习笔记**：变换的核心是“坐标映射”，用小例子推导公式比死记硬背更有效！

2.  **难点2：覆盖所有可能的变换形态**  
    * **分析**：旋转三次会回到原形态（120°×3=360°），对称后再旋转两次也能覆盖所有可能，所以总共有6种不同的形态（原、转1、转2、对称、对称转1、对称转2）。如果遗漏任何一种，可能得不到最小差异。  
    * **策略**：**枚举所有6种形态**——不管题目中的操作次数多少，最终有效的形态只有这6种。直接生成这6种，不需要循环多次变换（比如旋转三次以上是多余的）。  
    * 💡 **学习笔记**：有时候“枚举所有可能”比“循环尝试”更高效，因为变换是有周期的！

3.  **难点3：高效计算两个三角形的差异**  
    * **分析**：三角形有`1+2+...+n = n(n+1)/2`个位置，每个位置都要比较0/1是否相同。如果n=10，总共有55个位置，计算量很小，直接遍历即可。  
    * **策略**：写一个**通用的差异计算函数**（比如题解一的`contrast`函数），输入两个三角形数组，遍历每个位置累加不同的数量。这样代码更简洁，也避免重复写相同的逻辑。  
    * 💡 **学习笔记**：重复的逻辑要封装成函数，既省代码又不容易错！


### ✨ 解题技巧总结
<summary_best_practices>
通过本题，我总结了3个模拟题的通用技巧：
</summary_best_practices>
- **技巧1：枚举所有可能状态**：如果变换有周期（比如旋转3次回到原态），直接枚举所有有效状态，不用循环多次。  
- **技巧2：封装重复逻辑**：比如差异计算、变换操作，写成函数，代码更清晰。  
- **技巧3：用小例子推导公式**：变换的坐标公式不要死记，用n=2或n=3的小例子代入，找规律更靠谱！  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，综合了三个题解的优点——用函数封装变换，生成所有6种形态，计算最小差异。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解三的函数封装和题解一的清晰结构，用1-based坐标，直接生成所有6种形态，逻辑简洁。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <climits>
    using namespace std;

    const int MAXN = 15;
    int A[MAXN][MAXN], B[MAXN][MAXN];
    int n;

    // 计算两个三角形的差异
    int calc_diff(int a[MAXN][MAXN]) {
        int diff = 0;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                diff += (a[i][j] != B[i][j]);
        return diff;
    }

    // 旋转120度（顺时针）：把src转成dest
    void rotate(int src[MAXN][MAXN], int dest[MAXN][MAXN]) {
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= i; ++j) {
                // 1-based旋转公式：原(i,j) → 新(j, i-j+1)？不，需要调整，这里用题解一的正确实现：
                // 题解一的旋转代码：for(j=n,x=1;j>=1;j--,x++) for(i=j,y=1;i<=n;i++,y++) a1[x][y]=a[i][j];
                // 所以调整rotate函数为：
                // 注意：题解一的旋转是逆时针？需要确认，但这里直接用题解一的正确旋转代码
                // 重新实现旋转（按题解一的方式）：
                // 原a转成a1的代码是：for(j=n,x=1;j>=1;j--,x++) for(i=j,y=1;i<=n;i++,y++) a1[x][y]=a[i][j];
                // 所以rotate函数应该接收src，生成dest：
                // 但为了通用，我们重新写rotate函数，按题解一的逻辑：
                // 抱歉，刚才的函数封装可能有误，直接用题解一的正确旋转代码：
                // 正确的旋转实现应该是：
                // 比如，对于src数组，生成旋转后的dest数组：
                // 这里需要重新调整，因为题解一的旋转是正确的，所以直接用题解一的旋转逻辑：
                // 原a转成a1的代码是：
                // for(int j=n,x=1;j>=1;j--,x++) 
                //     for(int i=j,y=1;i<=n;i++,y++) 
                //         a1[x][y] = a[i][j];
                // 所以rotate函数应该是：
                int x = 1;
                for (int jj = n; jj >= 1; --jj) {
                    int y = 1;
                    for (int ii = jj; ii <= n; ++ii) {
                        dest[x][y] = src[ii][jj];
                        y++;
                    }
                    x++;
                }
            }
        }
    }

    // 对称变换：每行左右翻转
    void flip(int src[MAXN][MAXN], int dest[MAXN][MAXN]) {
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                dest[i][j] = src[i][i - j + 1];
    }

    int main() {
        cin >> n;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                cin >> A[i][j];
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= i; ++j)
                cin >> B[i][j];

        int min_diff = INT_MAX;
        int tmp[MAXN][MAXN], tmp2[MAXN][MAXN];

        // 1. 原形态
        min_diff = min(min_diff, calc_diff(A));

        // 2. 旋转1次
        rotate(A, tmp);
        min_diff = min(min_diff, calc_diff(tmp));

        // 3. 旋转2次
        rotate(tmp, tmp2);
        min_diff = min(min_diff, calc_diff(tmp2));

        // 4. 对称形态
        flip(A, tmp);
        min_diff = min(min_diff, calc_diff(tmp));

        // 5. 对称后旋转1次
        rotate(tmp, tmp2);
        min_diff = min(min_diff, calc_diff(tmp2));

        // 6. 对称后旋转2次
        rotate(tmp2, tmp); // 旋转tmp2得到对称转2次的结果
        min_diff = min(min_diff, calc_diff(tmp));

        cout << min_diff << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取A和B的输入，然后依次生成6种形态：  
  - 原形态：直接计算差异；  
  - 旋转1次：用`rotate`函数生成；  
  - 旋转2次：对旋转1次的结果再旋转；  
  - 对称形态：用`flip`函数生成；  
  - 对称后旋转1次：对对称结果旋转；  
  - 对称后旋转2次：对对称旋转1次的结果再旋转。  
  每个形态都用`calc_diff`计算差异，最后取最小值输出。  


<code_intro_selected>
接下来看三个题解的核心片段，重点分析“变换的实现”：
</code_intro_selected>

**题解一：(来源：syh110213)**  
* **亮点**：直接用循环实现旋转，逻辑直白，不需要记公式。
* **核心代码片段**：
    ```cpp
    // 旋转一次：把a转成a1
    for(int j=n,x=1;j>=1;j--,x++) 
        for(int i=j,y=1;i<=n;i++,y++) 
            a1[x][y] = a[i][j];
    // 对称变换：把a转成c
    for(int i=1;i<=n;i++) 
        for(int j=1;j<=i;j++) 
            c[i][j] = a[i][i-j+1];
    ```
* **代码解读**：  
  - 旋转的循环：`j`从n往下到1（代表从最后一列往前），`x`是新的行号（从1开始）；`i`从`j`到n（代表原三角形中第`j`列的所有行），`y`是新的列号。这样就把原三角形的“列”转成了新三角形的“行”，实现旋转120°。  
  - 对称的循环：`i`是行号，`j`是原列号，新列号是`i-j+1`（比如第3行第1列→第3行第3列，第3行第2列→第3行第2列，第3行第3列→第3行第1列），实现每行左右翻转。
* 💡 **学习笔记**：旋转不一定需要公式，用循环遍历原数组的“列”，转成新数组的“行”，也能正确实现！

**题解三：(来源：枫原万叶)**  
* **亮点**：用函数封装变换，给出了清晰的坐标公式。
* **核心代码片段**：
    ```cpp
    // 旋转120度（0-based）
    void fun1(int s[10][10], int d[10][10]) {
        for (int i = 0; i < n; i++)
            for (int j = 0; j <= i; j++)
                d[i][j] = s[n - 1 - j][i - j];
    }
    // 对称变换（0-based）
    void fun2(int src[10][10], int d[10][10]) {
        for (int i = 0; i < n; i++)
            for (int j = 0; j <= i; j++)
                d[i][j] = src[i][i - j];
    }
    ```
* **代码解读**：  
  - 旋转公式（0-based）：`d[i][j] = s[n-1-j][i-j]`——原数组`s`的第`n-1-j`行第`i-j`列的元素，转到新数组`d`的第`i`行第`j`列。比如n=3（0-based行是0、1、2），原`s[2][0]`（第3行第1列）会转到`d[0][0]`（第1行第1列），符合旋转的规律。  
  - 对称公式（0-based）：`d[i][j] = src[i][i-j]`——原行`i`的列`j`转到新行`i`的列`i-j`，比如第2行（0-based）的列0→列2，列1→列1，列2→列0，实现左右翻转。
* 💡 **学习笔记**：用0-based坐标写公式更简洁，适合推导变换规律！


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素三角形的“变身大赛”  
我们设计一个**FC红白机风格的动画**，模拟A的6种变换，目标是找到“和B最像的形态”。


### 🎯 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示A的原始形态（浅蓝=0，浅红=1），右侧显示B的固定形态；  
   - 下方控制面板有“单步”“自动”“重置”按钮，以及速度滑块（1~5倍速）；  
   - 背景播放8位风格的轻快BGM（比如《超级马里奥》的小关卡音乐）。

2. **变换演示**：  
   - **旋转120°**：A的每个像素块从原位置“滑”到新位置（比如第3行第1列的像素块滑到第1行第1列），伴随“咻”的音效；  
   - **对称变换**：A的每行左右像素块交换位置（比如第3行第1列和第3列的像素块交换），伴随“叮”的音效；  
   - **差异提示**：每个形态显示后，差异的位置闪烁黄色，屏幕下方显示当前差异值（比如“差异：1”）。

3. **结果展示**：  
   - 所有形态播放完后，差异最小的形态会持续闪烁，同时弹出“恭喜！最小差异是X”的文字，伴随“胜利”的上扬音效；  
   - 如果有多个形态差异相同，会同时闪烁这些形态。


### 🛠️ 交互设计  
- **单步模式**：点击“单步”按钮，手动切换下一个形态，适合慢慢观察变换细节；  
- **自动模式**：点击“自动”按钮，动画按设定速度播放（滑块可调整速度），适合快速浏览所有形态；  
- **重置模式**：点击“重置”按钮，回到初始状态，重新播放。


### 🎵 音效设计  
- 旋转：“咻”（高频短音）；  
- 对称：“叮”（中高频）；  
- 差异提示：“嗒”（低频短音）；  
- 胜利：“当当当”（三连音，上扬调）；  
- BGM：循环播放《坦克大战》的背景音（轻快，不干扰思考）。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
模拟的核心是“枚举所有可能状态，逐一验证”——这种思路还能解决：  
- 棋盘游戏的状态模拟（比如《井字棋》的所有可能走法）；  
- 物体的形态变换（比如正方形的旋转和翻转）；  
- 简单的物理模拟（比如小球的碰撞轨迹）。


### 📚 相似练习推荐（洛谷）  
1. **洛谷 P1097 统计数字**：模拟数字的出现次数，练习“枚举+统计”；  
2. **洛谷 P1328 生活大爆炸版石头剪刀布**：模拟手势的变换和胜负判断，练习“状态枚举+规则判断”；  
3. **洛谷 P1563 玩具谜题**：模拟玩具的方向变换，练习“坐标/方向的模拟”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
三个题解都提到了“变换的正确性”是解题的关键，以下是有价值的经验：
</insights_intro>

> **参考经验 (来自 枫原万叶)**：“旋转的坐标公式不要死记，用n=2的小例子代入推导更靠谱。比如n=2时，原(1,1)（1-based）旋转后应该到(1,1)吗？不对，实际代入后发现应该是(2,1)，所以公式要调整。”  
> **点评**：这位作者的经验非常实用！变换的公式不是“天生的”，而是通过小例子“试”出来的。当你不确定公式是否正确时，用最小的n代入验证，能快速找到错误。


## 💪 结语  
本次关于“两个正三角形”的模拟题分析就到这里啦！模拟题的关键是“把问题拆成一步步的动作，然后用代码实现每一步”。记住：**复杂的变换，拆成简单的循环就能解决**！下次遇到模拟题，不妨先列个“动作清单”，然后逐一实现——你会发现，其实没那么难！  

下次我们再一起挑战更有趣的算法问题吧！🚀

---
处理用时：130.92秒
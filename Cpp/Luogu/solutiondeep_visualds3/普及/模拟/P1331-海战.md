# 题目信息

# 海战

## 题目背景

在峰会期间，武装部队得处于高度戒备。警察将监视每一条大街，军队将保卫建筑物，领空将布满了 F-2003 飞机。

此外，巡洋船只和舰队将被派去保护海岸线。不幸的是，因为种种原因，国防海军部仅有很少的几位军官能指挥大型海战。因此，他们培养了一些新海军指挥官。军官们选择了“海战”游戏来帮助他们学习。

## 题目描述

在一个方形的盘上，放置了固定数量和形状的船只，每只船却不能碰到其它的船。在本题中，我们认为船是方形的，所有的船只都是由图形组成的方形。

求出该棋盘上放置的船只的总数。

## 说明/提示

对于 $100\%$ 的数据，$1 \le R,C \le 1000$。

## 样例 #1

### 输入

```
6 8
.....#.#
##.....#
##.....#
.......#
#......#
#..#...#```

### 输出

```
There are 5 ships.
```

# AI分析结果

---
# 💡 Kay的C++算法解析：海战 深入学习指南 💡

<introduction>
  今天我们来一起分析洛谷P1331「海战」这道C++编程题。题目要求我们统计棋盘上**合法方形船只**的数量，还要判断船只是否相邻（相邻则非法）。本指南会帮你理清思路、掌握核心算法，甚至用像素动画“看”到算法运行过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：预处理判断非法 + 连通块统计（DFS/BFS）

🗣️ **初步分析**：
> 解决“海战”问题，关键要闯两关：**先找非法情况**（船只相邻），**再数合法船只**。  
> 非法情况的“小秘密”：如果两个船相邻，必然存在一个2×2的小方格有3个`#`（比如`##`在下一行左边或右边缺一个，像拼图没对齐）。这一步可以用**预处理遍历所有2×2方格**快速判断。  
> 合法船只其实是`#`的**连通块**（因为非法情况已经被排除，剩下的连通块一定是完整的方形）。统计连通块数量可以用**DFS/BFS**（像“给细胞染色”，染过的细胞不再数），或者更聪明的方法——**统计每个船的左上角`#`**（因为每个方形船只有一个左上角，不会和其他船重叠）。  

举个例子：比如样例输入中的`##.....#`，这两个`#`是一个连通块，预处理没发现3个`#`的2×2方格，所以是合法船，计数+1。


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码效率、易懂性等方面筛选了3份优质题解，帮你快速掌握核心技巧～
</eval_intro>

**题解一：钱逸凡（赞214）**
* **点评**：这份题解把问题拆成“预处理非法”+“DFS统计连通块”，逻辑像“先检查考试作弊，再数及格人数”一样清晰！预处理时遍历所有2×2方格，发现3个`#`直接输出非法；剩下的用DFS把每个连通块的`#`改成`*`（避免重复计数），每启动一次DFS就代表一艘船。代码规范，变量名`map`（棋盘）、`dfs`函数一看就懂，边界处理也很严谨（比如`x+fx[i]`不越界）。亮点是**用2×2方格快速判非法**，直接命中题目核心！

**题解二：Dzhao（赞104）**
* **点评**：这位作者的思路像“找蛋糕的左上角”——每个合法船的左上角`#`一定满足“上方和左方都是`.`”（因为船是方形，左上角不会被其他船覆盖）。所以预处理非法后，直接统计这样的`#`数量就是答案！代码超级简洁，连DFS都不用，时间复杂度O(nm)（像扫一遍教室就数完人数）。亮点是**用数学规律代替搜索**，效率超高，适合大数据！

**题解三：智子·起源（赞27）**
* **点评**：这份题解用BFS统计连通块，同时记录连通块的**边界**（比如最左、最右、最上、最下的坐标）。统计完连通块后，检查边界内的所有格子是否都是`#`（如果是，说明是矩形船）。思路像“用框框住蛋糕，看框里有没有缺口”，逻辑非常严谨。代码中的`bfs`函数不仅标记连通块，还更新边界变量`maxn`/`minn`/`maxm`/`minm`，最后遍历边界内的格子判合法性。亮点是**用BFS+边界检查确保船是矩形**，适合理解“为什么连通块是合法船”！


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有3个，我们一一拆解：
</difficulty_intro>

1.  **难点1：如何快速判断船只相邻？**
    * **分析**：船只相邻的充要条件是存在一个2×2方格有3个`#`（比如`##`下面一行左边是`#`、右边是`.`，就会形成3个`#`）。预处理时遍历所有i从1到n-1、j从1到m-1的位置，检查`map[i][j]`、`map[i+1][j]`、`map[i][j+1]`、`map[i+1][j+1]`中`#`的数量是否等于3。一旦发现，直接输出非法！
    * 💡 **学习笔记**：用小方格预处理是判断“相邻”的关键，避免了复杂的搜索！

2.  **难点2：如何统计合法船只数量？**
    * **分析**：非法情况排除后，合法船就是`#`的连通块。可以用DFS/BFS标记每个连通块（比如把`#`改成`*`），每启动一次搜索就计数+1；或者像Dzhao那样，统计“上方和左方都是`.`”的`#`（每个船的左上角），直接得到数量。
    * 💡 **学习笔记**：连通块统计是搜索的经典应用，而找左上角的方法是“偷懒”的好技巧！

3.  **难点3：如何确保连通块是矩形？**
    * **分析**：如果用预处理2×2方格的方法，非法情况已经被排除，剩下的连通块必然是矩形（因为相邻的船已经被筛掉）。如果不用预处理，也可以像智子·起源那样，记录连通块的边界，检查边界内的所有格子是否都是`#`（面积等于连通块大小）。
    * 💡 **学习笔记**：预处理可以“提前排雷”，让后续统计更简单！

### ✨ 解题技巧总结
- **技巧1：预处理小方格**：用2×2方格快速判断非法，避免复杂逻辑。
- **技巧2：连通块统计**：DFS/BFS是统计连通块的“万能工具”，标记已访问的格子避免重复。
- **技巧3：找左上角**：利用方形的特性，直接统计左上角`#`的数量，效率更高。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质思路的核心代码**，结合了预处理非法和DFS统计连通块，逻辑清晰易理解～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合钱逸凡的预处理思路和DFS统计，代码简洁且覆盖所有情况。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    using namespace std;

    const int MAXN = 1010;
    char map[MAXN][MAXN];
    int r, c;
    // 四个方向：上下左右
    int fx[4] = {0, -1, 1, 0};
    int fy[4] = {-1, 0, 0, 1};

    // DFS标记连通块（把#改成*）
    void dfs(int x, int y) {
        map[x][y] = '*';
        for (int i = 0; i < 4; ++i) {
            int nx = x + fx[i];
            int ny = y + fy[i];
            if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && map[nx][ny] == '#') {
                dfs(nx, ny);
            }
        }
    }

    // 判断2x2方格是否有3个#
    bool isBad(int i, int j) {
        int cnt = 0;
        if (map[i][j] == '#') cnt++;
        if (map[i+1][j] == '#') cnt++;
        if (map[i][j+1] == '#') cnt++;
        if (map[i+1][j+1] == '#') cnt++;
        return cnt == 3;
    }

    int main() {
        cin >> r >> c;
        for (int i = 1; i <= r; ++i) {
            for (int j = 1; j <= c; ++j) {
                cin >> map[i][j];
            }
        }

        // 预处理：检查所有2x2方格
        for (int i = 1; i < r; ++i) {
            for (int j = 1; j < c; ++j) {
                if (isBad(i, j)) {
                    cout << "Bad placement." << endl;
                    return 0;
                }
            }
        }

        // 统计连通块数量（合法船）
        int ans = 0;
        for (int i = 1; i <= r; ++i) {
            for (int j = 1; j <= c; ++j) {
                if (map[i][j] == '#') {
                    ans++;
                    dfs(i, j);
                }
            }
        }

        cout << "There are " << ans << " ships." << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：1. 读入棋盘；2. 预处理所有2x2方格，发现非法直接退出；3. 用DFS统计`#`的连通块数量，每个连通块代表一艘合法船。`dfs`函数负责把当前`#`及其连通的`#`改成`*`，避免重复计数。


---
<code_intro_selected>
再看两份优质题解的核心片段，学习不同的技巧～
</code_intro_selected>

**题解二：Dzhao（赞104）—— 统计左上角`#`**
* **亮点**：不用搜索，直接统计左上角`#`，效率超高！
* **核心代码片段**：
    ```cpp
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            // 左上角#的条件：当前是#，且上方和左方都是.
            if (g[i][j] == '#' && g[i-1][j] != '#' && g[i][j-1] != '#') {
                ans++;
            }
        }
    }
    ```
* **代码解读**：
    > 为什么这样统计？因为每个合法船是方形，它的左上角`#`的上方（i-1,j）和左方（i,j-1）一定是`.`（否则会被其他船覆盖）。比如样例中的第一个`##`，左上角是(2,1)，上方(1,1)是`.`，左方(2,0)不存在（视为`.`），所以计数+1。
* 💡 **学习笔记**：利用方形的几何特性，可以避免搜索，让代码更简洁！

**题解三：智子·起源（赞27）—— BFS记录边界**
* **亮点**：用BFS记录连通块的边界，严谨判断矩形！
* **核心代码片段**：
    ```cpp
    void bfs(int x, int y) {
        int h = 0, t = 1;
        que[0].x = x; que[0].y = y;
        f[x][y] = '*'; // 标记已访问
        maxn = minx = x;
        maxm = miny = y; // 初始化边界
        while (h != t) {
            for (int i = 0; i < 4; ++i) {
                int nx = que[h].x + dx[i];
                int ny = que[h].y + dy[i];
                if (nx >=1 && nx <=n && ny >=1 && ny <=m && f[nx][ny] == '#') {
                    f[nx][ny] = '*';
                    que[t].x = nx; que[t].y = ny;
                    // 更新边界
                    maxn = max(maxn, nx);
                    minx = min(minx, nx);
                    maxm = max(maxm, ny);
                    miny = min(miny, ny);
                    t++;
                }
            }
            h++;
        }
        // 检查边界内是否全是*（即原#）
        for (int k = minx; k <= maxn; ++k) {
            for (int l = miny; l <= maxm; ++l) {
                if (f[k][l] != '*') {
                    cout << "Bad placement." << endl;
                    exit(0);
                }
            }
        }
    }
    ```
* **代码解读**：
    > BFS过程中，记录连通块的最左（`minx`）、最右（`maxn`）、最上（`miny`）、最下（`maxm`）坐标。然后遍历这个矩形内的所有格子，如果有不是`*`的（原`.`），说明连通块不是矩形，非法！比如如果有一个`#`的右边是`.`，边界会包含那个`.`，检查时就会发现。
* 💡 **学习笔记**：BFS不仅能统计连通块，还能记录额外信息（比如边界），帮你解决更复杂的问题！


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看”到算法运行，我设计了一个**8位像素风格的动画**，像玩红白机游戏一样学习！
</visualization_intro>

### 🎮 动画演示主题：像素海战——找船大冒险
**风格**：FC红白机风格（低分辨率、鲜艳色彩），棋盘用16×16像素块组成，`#`是蓝色，`.`是白色，非法2x2方格是红色闪烁，DFS标记的`*`是绿色。

### 🚀 动画核心步骤
1. **初始化场景**：
   - 屏幕左侧是8×8的像素棋盘（对应题目中的棋盘），右侧是控制面板（开始/暂停、单步、重置、速度滑块）。
   - 播放8位风格的背景音乐（像《超级马里奥》的轻松旋律）。

2. **预处理非法情况**：
   - 一个像素“探测器”（小飞船图标）从(1,1)开始，逐个扫描2x2方格。
   - 当扫描到有3个`#`的方格时，该方格闪烁红色，同时播放“滴滴”的警告音效（像游戏中的陷阱提示）。
   - 如果发现非法，屏幕中央弹出“Bad placement!”的像素文字，动画结束。

3. **统计合法船只**：
   - 一个像素“画家”（小刷子图标）从(1,1)开始，寻找`#`。
   - 找到`#`后，启动DFS：刷子依次把连通的`#`涂成绿色，每涂一个播放“叮”的音效（像收集金币）。
   - 每涂完一个连通块，右上角的“船只数”+1（显示为像素数字）。

4. **结束状态**：
   - 所有`#`都被涂成绿色后，屏幕播放“胜利”动画（像素烟花），播放上扬的音效（像游戏通关），并显示“Total ships: X”。

### 🎯 设计目的
- **像素风格**：唤起复古游戏的记忆，降低学习的枯燥感。
- **音效提示**：用声音强化关键操作（比如警告、涂块），帮助记忆。
- **可视化流程**：让你清楚看到“预处理”和“DFS统计”的每一步，理解算法如何工作。


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“预处理+连通块统计”的思路，你可以解决很多类似问题！
</similar_problems_intro>

### 🌍 通用思路迁移
- 统计图像中的“连通区域”（比如细胞数量、湖泊数量）。
- 判断图形是否为矩形/正方形（比如判断一个连通块的边界）。
- 预处理小区域判断非法情况（比如判断两个物体是否接触）。

### 📚 洛谷练习推荐
1. **洛谷 P1451** - 求细胞数量  
   🗣️ **推荐理由**：经典的连通块统计问题，用DFS/BFS统计细胞数量，和本题的“统计船只”几乎一样！
   
2. **洛谷 P1596** - Lake Counting  
   🗣️ **推荐理由**：统计农田中的湖泊数量（`W`代表水，连通块），练习DFS的基本用法。
   
3. **洛谷 P2895** - [USACO08FEB]Meteor Shower S  
   🗣️ **推荐理由**：用BFS求最短逃生路径，练习BFS的边界处理和状态记录。
   
4. **洛谷 P3916** - 图的遍历  
   🗣️ **推荐理由**：用DFS遍历图的连通块，拓展到图论的连通块统计。


---

## 7. 学习心得与经验分享 (若有)
> **参考经验（来自钱逸凡）**：“这道题的难点在于判断是否有船相邻。通过模拟数据发现，非法情况一定是2×2方格有3个#，所以直接预处理就能解决！”  
> **点评**：这位作者的经验告诉我们——**找规律是解决编程题的关键**！很多看似复杂的问题，其实可以通过模拟小数据找到“破局点”（比如本题的2×2方格规律），避免写复杂的逻辑。


---

<conclusion>
本次关于“海战”的C++解题分析就到这里啦！希望这份指南能帮你掌握“预处理+连通块统计”的核心技巧。记住：编程的乐趣在于“找规律”和“解决问题”，多练几道类似题，你一定会越来越厉害～ 💪
</conclusion>

---

---
处理用时：297.32秒
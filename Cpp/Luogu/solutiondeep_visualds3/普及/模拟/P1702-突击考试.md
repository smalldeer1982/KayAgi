# 题目信息

# 突击考试

## 题目描述

一日，老师决定进行一次突击考试。已知每个学生都有一个考试能力等级，教室里一共有 $N$ 个课桌，按照顺序排成一列，每张课桌可以坐两个人，第 $i$ 张课桌坐的两个人的能力等级为$A_i,B_i$。现在老师决定对能力等级为 $K$ 的人进行测验。他会从这 $N$ 排中选择连续的 $L$ 排进行测验，要求这 $L$ 排中的每一排至少有一个人考试能力等级为 $K$。现在我们想知道 $L$ 的最大值以及对应的等级 $K$。

## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N \le 100,000$，$1 \le A[i],B[i] \le 5$。

## 样例 #1

### 输入

```
3
3 5
4 5
1 3
```

### 输出

```
2 5```

# AI分析结果



---
# 💡 Kay的C++算法解析：突击考试 深入学习指南 💡

<introduction>
今天我们来一起分析“突击考试”这道C++编程题。这道题需要找到最大的连续排数L，使得这L排中每排至少有一个学生的能力等级为K（L最大时选最小的K）。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟应用`

🗣️ **初步分析**：
解决“突击考试”的关键在于利用题目中能力等级仅1-5的限制，对每个可能的K（1到5）进行模拟统计。模拟算法就像“逐个检查”——我们逐个检查每个K，看看它能形成多长的连续符合条件的排数。例如，K=5时，我们需要遍历所有课桌，统计连续多少排中至少有一个5，这过程就像用尺子量最长的连续段。

- **题解思路**：大部分题解采用“枚举K+线性扫描”的思路。对每个K（1-5），遍历所有课桌，统计连续满足条件的排数（当前排有K则长度+1，否则重置为0），记录最大值。多个题解的差异主要在于实现细节（如是否处理最后一段、变量初始化等），但核心思路一致。
- **核心难点**：如何高效统计每个K的最长连续排数？如何处理最后一段未清零的情况（避免遗漏最大值）？如何在L相同时选择最小的K？
- **可视化设计**：采用8位像素风，用不同颜色的方块代表不同K（如K=5用红色）。动画中，每扫描到一个包含K的排，对应颜色的长条长度增加；遇到不包含K的排，长条重置。关键步骤高亮（如当前扫描的排、长条长度变化），并配合“叮”的音效提示长度增加，“咚”提示重置。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性的评估，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：作者lgxt（赞：13）**
* **点评**：此题解思路非常清晰，直接枚举每个K（1-5），线性扫描统计连续排数。代码简洁规范（变量名如`s[i][0]`表示第i排第一个学生的等级），时间复杂度O(5N)，完全适配1e5的数据量。尤其在处理最后一段时，通过`o==n-1`的判断确保最大值被记录，避免了遗漏。实践价值极高，适合竞赛快速实现。

**题解二：作者听取MLE声一片（AC代码）（赞：5）**
* **点评**：此题解优化了暴力方法，将时间复杂度从O(N²)降至O(5N)。核心改进是“边跑边记录”——遍历课桌时动态维护当前连续长度，遇到不包含K的排时立即更新最大值并重置。特别指出“不加`max(s,p)`会WA三个点”，强调了处理最后一段的重要性，对调试有启发。

**题解三：作者whwh（AC代码）（赞：1）**
* **点评**：此题解代码极其简洁（仅30行），变量命名直观（如`ans`存最大L，`k`存对应的K）。关键步骤`max1=max(max1,u)`处理了最后一段未清零的情况，避免了70分的错误。代码逻辑直白，适合新手理解“线性扫描+状态重置”的核心思想。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的过程中，我们需要重点突破以下三个关键点：
</difficulty_intro>

1.  **关键点1：如何高效统计每个K的最长连续排数？**
    * **分析**：由于K的取值范围很小（1-5），我们可以对每个K单独处理。遍历所有课桌时，维护一个“当前连续长度”变量：若当前排包含K，长度+1；否则，更新最大值并重置长度。这一步的时间复杂度是O(N)，5个K总复杂度O(5N)，完全满足数据要求。
    * 💡 **学习笔记**：利用题目中“K范围小”的特性，枚举K是降低复杂度的关键。

2.  **关键点2：如何处理最后一段未清零的情况？**
    * **分析**：假设所有课桌都包含K，遍历结束时“当前连续长度”未被更新到最大值。因此，遍历结束后需要额外执行一次`max(当前最大值, 当前连续长度)`。例如，题解中`return max(s,p)`或`max1=max(max1,u)`就是处理这种情况。
    * 💡 **学习笔记**：边界情况（如数组末尾）容易遗漏，需特别检查。

3.  **关键点3：如何选择L相同时最小的K？**
    * **分析**：由于我们按K从小到大枚举（1到5），当遇到相同L时，保留先出现的较小K即可。例如，题解中`if(t[i]>max)`更新，否则不更新，自然保留更小的K。
    * 💡 **学习笔记**：枚举顺序可以巧妙解决“取最小K”的问题。

### ✨ 解题技巧总结
- **枚举小范围变量**：当某个变量的取值范围很小时（如本题K=1-5），直接枚举是高效且易懂的选择。
- **边遍历边统计**：动态维护“当前连续长度”，避免嵌套循环（如暴力解法的O(N²)），将复杂度降至线性。
- **处理边界值**：遍历结束后，务必检查最后一段未被处理的情况（如最后几个元素连续符合条件）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合多个优质题解的思路，给出一个简洁、高效的通用核心实现。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了lgxt、whwh等题解的思路，采用枚举K+线性扫描的方法，时间复杂度O(5N)，代码简洁且处理了边界情况。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;

    int main() {
        int n;
        cin >> n;
        int a[100001], b[100001];
        for (int i = 0; i < n; ++i) {
            cin >> a[i] >> b[i];
        }

        int max_L = 0, best_K = 0;
        for (int K = 1; K <= 5; ++K) { // 枚举每个可能的K
            int current = 0, max_current = 0;
            for (int i = 0; i < n; ++i) {
                if (a[i] == K || b[i] == K) {
                    current++; // 当前排符合条件，长度+1
                } else {
                    max_current = max(max_current, current); // 不符合，更新最大值
                    current = 0; // 重置当前长度
                }
            }
            max_current = max(max_current, current); // 处理最后一段
            if (max_current > max_L || (max_current == max_L && K < best_K)) {
                max_L = max_current;
                best_K = K;
            }
        }
        cout << max_L << " " << best_K << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入，然后对每个K（1-5）进行线性扫描。对于每个K，维护`current`记录当前连续长度，遇到不符合的排时更新`max_current`并重置`current`。遍历结束后，再次更新`max_current`以处理最后一段。最后比较所有K的`max_current`，选择最大的L（若相同则选最小的K）。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其亮点：
</code_intro_selected>

**题解一：作者lgxt**
* **亮点**：代码简洁，直接枚举K，用`x`记录当前连续长度，`ans`记录最大值，逻辑清晰。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=5;i++){
        int ans=0,x=0;
        for(int o=0;o<n;o++){
            if(s[o][0]==i||s[o][1]==i) x++;
            if((s[o][0]!=i&&s[o][1]!=i)||o==n-1){
                ans=max(ans,x);
                x=0;
            }
        }
        t[i]=ans;
    }
    ```
* **代码解读**：
    外层循环枚举K（1-5），内层遍历所有课桌。`x`是当前连续长度，遇到包含K的排则`x++`；遇到不包含K的排或最后一个排时，用`ans`记录最大值并重置`x`。`o==n-1`的判断确保最后一段被处理。
* 💡 **学习笔记**：通过“条件或最后一个排”的判断，避免遗漏最后一段的最大值。

**题解二：作者听取MLE声一片（AC代码）**
* **亮点**：优化暴力，将O(N²)降为O(N)，关键是“边跑边记录”。
* **核心代码片段**：
    ```cpp
    int pd(int x) {
        int s=0,p=0;
        for(int i=0;i<n;i++){
            if(a[i]==x||b[i]==x) p++;
            else {
                s=max(s,p);
                p=0;
            }
        }
        return max(s,p); // 处理最后一段
    }
    ```
* **代码解读**：
    函数`pd(x)`统计K=x时的最长连续排数。`p`是当前连续长度，遇到不包含x的排时用`s`记录最大值并重置`p`。最后返回`s`和`p`的最大值，确保最后一段被处理。
* 💡 **学习笔记**：函数封装统计逻辑，代码模块化，提高可读性。

**题解三：作者whwh（AC代码）**
* **亮点**：代码极简，仅30行，变量初始化和边界处理到位。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=5;++i){
        u=0;max1=0; // 初始化
        for(int j=1;j<=n;++j){
            if(a[j]==i||b[j]==i) u++;
            else max1=max(max1,u),u=0;
        }
        max1=max(max1,u); // 处理最后一段
        if(max1>ans) ans=max1,k=i;
    }
    ```
* **代码解读**：
    外层循环枚举K，内层遍历课桌。`u`记录当前连续长度，遇到不包含K的排时更新`max1`并重置`u`。遍历结束后，`max1=max(max1,u)`确保最后一段被处理。
* 💡 **学习笔记**：变量初始化（`u=0;max1=0`）是避免错误的关键。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“枚举K+线性扫描”的过程，我们设计一个8位像素风格的动画，模拟统计每个K的最长连续排数。
</visualization_intro>

  * **动画演示主题**：`像素小探的连续排数大挑战`（复古FC风格）

  * **核心演示内容**：
    屏幕左侧是课桌排成的像素网格（每排2个小方块，颜色代表学生能力等级），右侧是5个颜色条（对应K=1-5）。动画展示小探（像素角色）从左到右扫描课桌，当扫描到包含当前K的排时，对应颜色条长度增加；遇到不包含的排时，颜色条重置。

  * **设计思路简述**：
    8位像素风格（16色调色板）营造轻松氛围，颜色条动态变化直观展示连续长度。音效（如“叮”提示长度增加，“咚”提示重置）强化操作记忆，小探的移动引导视线，帮助理解扫描过程。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 课桌网格：每排2个小方块（颜色对应A[i]、B[i]，如红色=5，蓝色=3）。
          * 控制面板：开始/暂停、单步、重置按钮；速度滑块（1-5倍速）。
          * 背景音乐：8位风格的轻快旋律。

    2.  **算法启动**：
          * 小探站在第一排左侧，头顶显示当前K（如K=5）。
          * 对应颜色条（红色）初始长度为0。

    3.  **核心步骤演示**：
          * **扫描当前排**：小探移动到当前排，高亮该排（边框闪烁）。
          * **判断是否包含K**：若包含（如红色方块存在），红色条长度+1（像素块堆叠，伴随“叮”音效）；否则，红色条重置为0（像素块消失，伴随“咚”音效）。
          * **更新最大值**：遇到不包含K的排或扫描到末尾时，记录当前红色条的最大长度（用金色数字显示）。

    4.  **切换K**：
          * 扫描完所有排后，小探头顶K变为下一个值（如K=4），红色条重置，开始新的扫描。

    5.  **结果展示**：
          * 所有K扫描完成后，最大长度的颜色条闪烁（如红色条最长），小探举起“胜利”标志，播放胜利音效。

  * **旁白提示**：
      * “现在小探在检查K=5的情况，看红色条能长多长～”
      * “遇到不包含5的排啦，红色条要重置咯！”
      * “扫描结束，K=5的最长连续排数是2！”

<visualization_conclusion>
通过这个动画，我们能清晰看到每个K的扫描过程，理解“线性扫描+状态重置”的核心逻辑，就像小探一步步“量”出最长的连续排数。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“枚举小范围变量+线性扫描统计连续段”，这种思路在类似问题中也很常见。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 统计最长连续子数组满足某条件（如元素等于x）。
      - 多条件下的连续段统计（如同时满足两个条件）。
      - 小范围枚举优化（如颜色、类型等有限的场景）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1102 最大的数** 
          * 🗣️ **推荐理由**：需要枚举可能的数，统计其连续出现次数，与本题思路类似。
    2.  **洛谷 P1868 饥饿的奶牛** 
          * 🗣️ **推荐理由**：涉及连续天数的统计，需动态维护当前连续长度，锻炼线性扫描能力。
    3.  **洛谷 P5731 【深基5.习6】蛇形方阵** 
          * 🗣️ **推荐理由**：虽然问题不同，但需要处理边界条件和循环逻辑，提升代码严谨性。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试中的经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自作者听取MLE声一片)**：“一开始写了O(N²)的暴力，结果TLE了。后来发现可以边跑边记录，把时间复杂度降到O(N)。但一开始没处理最后一段，WA了三个点，加上`max(s,p)`才AC。”

> **点评**：这位作者的经验提醒我们，暴力解法可能因复杂度高而超时，需优化为线性扫描。同时，边界条件（如最后一段）容易遗漏，测试时要特别注意。遇到WA时，检查是否处理了所有可能的输入情况（如全符合条件的输入）。

-----

<conclusion>
本次关于“突击考试”的C++解题分析就到这里。希望这份指南能帮助你理解“枚举+线性扫描”的核心思路，掌握处理连续段统计的技巧。记住，多动手写代码、测试边界条件，是提升编程能力的关键！下次再见～💪
</conclusion>

-----

---
处理用时：155.89秒
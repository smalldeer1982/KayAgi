# 题目信息

# 滑动窗口 /【模板】单调队列

## 题目描述

有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

例如，对于序列 $[1,3,-1,-3,5,3,6,7]$ 以及 $k = 3$，有如下过程：

$$\def\arraystretch{1.2}
\begin{array}{|c|c|c|}\hline
\textsf{窗口位置} & \textsf{最小值} & \textsf{最大值} \\ \hline
\verb![1   3  -1] -3   5   3   6   7 ! & -1 & 3 \\ \hline
\verb! 1  [3  -1  -3]  5   3   6   7 ! & -3 & 3 \\ \hline
\verb! 1   3 [-1  -3   5]  3   6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1 [-3   5   3]  6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1  -3  [5   3   6]  7 ! & 3 & 6 \\ \hline
\verb! 1   3  -1  -3   5  [3   6   7]! & 3 & 7 \\ \hline
\end{array}
$$

## 说明/提示

【数据范围】    
对于 $50\%$ 的数据，$1 \le n \le 10^5$；  
对于 $100\%$ 的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。


## 样例 #1

### 输入

```
8 3
1 3 -1 -3 5 3 6 7```

### 输出

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7```

# AI分析结果

# 💡 Kay的C++算法解析：滑动窗口 /【模板】单调队列 深入学习指南 💡

<introduction>
  今天我们来一起分析经典的「滑动窗口最值问题」——这道题是单调队列的模板题，也是很多算法进阶的基础。通过这道题，我们能学会如何用**线性时间**高效解决“固定窗口滑动时的最值查询”问题。本指南会帮你理清单调队列的核心逻辑，还有超有趣的像素动画演示哦！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：单调队列（动态维护区间最值的线性时间算法）

🗣️ **初步分析**：
解决滑动窗口最值问题，关键在于**单调队列**——它就像“奶茶店的聪明排队”：如果前面的人比你小还比你强（比如更符合当前窗口的最值要求），那你永远不会成为“最值”，直接走就行！这样队列里只留下“有希望成为最值的元素”，保证队首永远是当前窗口的最值。

### 单调队列的核心思想
单调队列有两个关键性质：
1. **元素顺序单调**：队列中的元素值要么递增（求最小值），要么递减（求最大值）；
2. **下标顺序递增**：元素的下标（在原数组中的位置）一定是从早到晚的（因为窗口向右滑）。

### 本题中的应用
对于长度为`k`的滑动窗口，我们需要：
- **维护队列单调性**：新元素入队时，从队尾弹出所有“比它大/小且下标更老”的元素（因为这些元素再也无法成为最值）；
- **清理过期元素**：从队头弹出所有“下标超出当前窗口范围”的元素（因为它们已经不在窗口里了）。

这样，**队首元素就是当前窗口的最值**！

### 可视化设计思路
我们会用**8位像素风格**（类似红白机）做动画：
- 数组用「浅蓝色像素块」表示，每个块显示元素值；
- 滑动窗口用「红色边框」高亮当前范围；
- 单调队列用「右侧的像素堆」表示（最小值队列绿色，最大值队列黄色）；
- **关键步骤高亮**：入队时元素“滑入”队列，出队时“消失”，过期元素“变暗”；
- **音效**：入队是“叮”，出队是“嗒”，找到最值时是“叮铃”，失败是“哔”。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了4份优质题解，它们各有亮点，能帮你从不同角度理解单调队列！
</eval_intro>

### 题解一：作者hilsinleri（赞877）
* **点评**：这份题解是“单调队列的入门教科书”！作者用样例一步步拆解单调队列的操作（比如如何处理`1→3→-1→-3`的入队过程），把“为什么要弹出队尾”“为什么要清理队头”讲得明明白白。代码用结构体封装了单调队列的逻辑，变量名`q`（队列）、`p`（下标）含义明确，注释详细，非常适合新手模仿。

### 题解二：作者Jerrycyx（赞8）
* **点评**：作者的“取反技巧”太聪明了！因为“区间最大值 = -区间（-元素）的最小值”，所以只需要写一个求最小值的函数，把数组取反后再求一次，就能得到最大值。这样减少了重复代码，代码量更少，也更高效。

### 题解三：作者yr409892525（赞6）
* **点评**：这份题解的**正确性证明**很扎实！作者明确指出“每个元素最多入队出队一次”，所以时间复杂度是O(n)。代码用手写队列（数组模拟）代替STL的`deque`，速度更快，适合处理1e6级别的大数据。

### 题解四：作者kunkun127（赞4）
* **点评**：作者总结了单调队列的**应用场景**（比如“窗口单调滑动”“解有单调性”），帮你快速判断什么时候该用单调队列。代码中的条件判断（`q[head] < i - k + 1`）清晰处理了过期元素，逻辑严谨。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
单调队列的“门槛”在于**维护队列的单调性**和**处理过期元素**。结合优质题解，我总结了3个核心难点和解决方法：
</difficulty_intro>

### 1. 难点1：如何维护队列的单调性？
- **问题**：新元素入队时，如何保证队列是递增/递减的？
- **解决**：从队尾开始，弹出所有“比新元素大（求最小值）/小（求最大值）”的元素。比如求最小值时，新元素`-1`入队，队尾的`3`和`1`都比它大，直接弹出，最后队列只剩`-1`。
- 💡 **学习笔记**：单调队列的“单调”是靠“踢掉更劣的老元素”维持的！

### 2. 难点2：如何处理窗口外的过期元素？
- **问题**：窗口滑动后，队首元素可能已经不在窗口里了，怎么办？
- **解决**：检查队首元素的下标是否小于“当前窗口的左边界”（`i - k + 1`），如果是，就从队头弹出。比如窗口滑到第4个元素时，队首的`1`（下标1）已经不在窗口`[2,4]`里了，直接弹出。
- 💡 **学习笔记**：存储下标而不是值，才能判断元素是否在窗口内！

### 3. 难点3：如何同时求最大值和最小值？
- **问题**：难道要写两个单调队列？有没有更简洁的方法？
- **解决**：可以用“取反技巧”（参考Jerrycyx的题解）：把数组所有元素取反，求最小值后再取反，就是原数组的最大值。这样只需要写一个求最小值的函数，减少重复代码。
- 💡 **学习笔记**：数学转换能简化问题！

### ✨ 解题技巧总结
1. **双端队列是关键**：单调队列需要从队头（清理过期）和队尾（维护单调）操作，所以必须用双端队列（`deque`或手写数组）；
2. **存储下标而非值**：方便判断元素是否在窗口内；
3. **先清理过期，再维护单调**：顺序不影响结果，但先清理过期能减少无效操作。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**——用STL的`deque`维护下标，分别求最小值和最大值。代码简洁，逻辑清晰！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合了hilsinleri和Jerrycyx的思路，用`deque`存储下标，分别处理最小值和最大值。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <deque>
using namespace std;

const int MAXN = 1e6 + 5;
int a[MAXN], n, k;

// 求滑动窗口最小值，结果存入res数组
void getMin(int res[]) {
    deque<int> dq;
    for (int i = 1; i <= n; ++i) {
        // 清理过期元素（队首超出窗口）
        while (!dq.empty() && dq.front() < i - k + 1)
            dq.pop_front();
        // 维护队列单调递增（踢掉比当前大的队尾）
        while (!dq.empty() && a[dq.back()] >= a[i])
            dq.pop_back();
        dq.push_back(i);
        // 窗口形成后，记录最小值（队首）
        if (i >= k)
            res[i - k] = a[dq.front()];
    }
}

// 求滑动窗口最大值，结果存入res数组
void getMax(int res[]) {
    deque<int> dq;
    for (int i = 1; i <= n; ++i) {
        while (!dq.empty() && dq.front() < i - k + 1)
            dq.pop_front();
        // 维护队列单调递减（踢掉比当前小的队尾）
        while (!dq.empty() && a[dq.back()] <= a[i])
            dq.pop_back();
        dq.push_back(i);
        if (i >= k)
            res[i - k] = a[dq.front()];
    }
}

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; ++i)
        cin >> a[i];
    
    vector<int> minRes(n - k + 1);
    vector<int> maxRes(n - k + 1);
    getMin(minRes.data());
    getMax(maxRes.data());
    
    // 输出结果
    for (int x : minRes) cout << x << " ";
    cout << endl;
    for (int x : maxRes) cout << x << " ";
    return 0;
}
```
* **代码解读概要**：
  1. `getMin`函数用`deque`维护单调递增队列，队首是当前窗口最小值；
  2. `getMax`函数用`deque`维护单调递减队列，队首是当前窗口最大值；
  3. 主函数读取输入，调用两个函数，最后输出结果。


### 针对各优质题解的片段赏析

#### 题解一：hilsinleri的结构体写法
* **亮点**：用结构体封装单调队列的逻辑，代码模块化，易读性高。
* **核心代码片段**：
```cpp
struct Monotone_queue {
    int q[MAXN], head, tail, p[MAXN]; // q存值，p存下标
    void monotone_min() {
        head = 1; tail = 0;
        for (int i = 1; i <= n; ++i) {
            while (head <= tail && q[tail] >= a[i]) tail--;
            q[++tail] = a[i];
            p[tail] = i;
            while (p[head] <= i - k) head++;
            if (i >= k) printf("%d ", q[head]);
        }
    }
};
```
* **代码解读**：
  - `q`数组存元素值，`p`数组存对应的下标；
  - `monotone_min`函数中，`tail--`是踢掉比当前大的队尾，`head++`是清理过期元素；
  - 这种写法不用STL，速度更快，适合竞赛。
* 💡 **学习笔记**：结构体封装能让代码更整洁！

#### 题解二：Jerrycyx的取反技巧
* **亮点**：用“取反”减少重复代码，只写一个`Calc`函数就能求最大和最小值。
* **核心代码片段**：
```cpp
void Calc(int res[]) {
    deque<int> dq;
    for (int i = 1; i <= n; ++i) {
        while (!dq.empty() && i - dq.front() + 1 > k) dq.pop_front();
        while (!dq.empty() && a[dq.back()] > a[i]) dq.pop_back();
        dq.push_back(i);
        if (i >= k) res[i - k + 1] = dq.front();
    }
}

int main() {
    // 求最小值
    Calc(ans1);
    // 取反求最大值
    for (int i = 1; i <= n; ++i) a[i] = -a[i];
    Calc(ans2);
    for (int i = 1; i <= n - k + 1; ++i)
        printf("%d ", -a[ans2[i]]);
}
```
* **代码解读**：
  - `Calc`函数求的是最小值的下标；
  - 把数组取反后，`Calc`求的是“反数组的最小值”，再取反就是原数组的最大值；
  - 这种写法减少了一半的代码量，非常聪明！
* 💡 **学习笔记**：数学转换能简化重复劳动！

#### 题解三：yr409892525的手写队列
* **亮点**：用数组模拟双端队列，速度比STL的`deque`更快，适合大数据。
* **核心代码片段**：
```cpp
int q[MAXN], hd = 1, tl = 0; // 手写队列，hd是队头，tl是队尾
void pop(int x) {
    while (hd <= tl && q[hd] <= x - k) hd++;
}
void insert(int x) {
    while (hd <= tl && a[q[tl]] >= a[x]) tl--;
    q[++tl] = x;
}
```
* **代码解读**：
  - `q`数组存下标，`hd`初始为1，`tl`初始为0（表示空队列）；
  - `pop`函数清理过期元素，`insert`函数维护单调性；
  - 手写队列避免了STL的 overhead，速度更快。
* 💡 **学习笔记**：手写数据结构在竞赛中更高效！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看”到单调队列的运作，我设计了一个**8位像素风格的动画**——像玩红白机游戏一样学算法！
</visualization_intro>

### 动画演示主题
**像素探险家：滑动窗口的最值冒险**  
数组是“像素洞穴”，每个洞穴里有一个数字；滑动窗口是“探险家的手电筒”，照亮当前3个洞穴；单调队列是“探险家的背包”，只装“有希望成为最值的数字”。

### 核心演示内容
1. **场景初始化**（红白机风格）：
   - 屏幕左侧是**数组洞穴**：每个洞穴是8x8的浅蓝色像素块，显示元素值（比如`1`、`3`、`-1`）；
   - 屏幕右侧是**单调队列背包**：绿色背包（最小值队列）和黄色背包（最大值队列），里面的像素块显示元素值；
   - 底部是**控制面板**：有“单步”“自动”“重置”按钮，还有速度滑块（1x~5x）。

2. **动画步骤（以最小值为例）**：
   - **步骤1**：窗口滑到第1~3个元素（`1,3,-1`）：
     - `1`入队（绿色背包加入`1`，“叮”音效）；
     - `3`入队（比`1`大，直接加入，“叮”）；
     - `-1`入队（踢掉`3`和`1`，“嗒嗒”音效，最后加入`-1`）；
     - 队首`-1`是最小值，洞穴`-1`高亮，“叮铃”音效。
   - **步骤2**：窗口滑到第2~4个元素（`3,-1,-3`）：
     - 清理队首`-1`（下标3，窗口左边界是2，没过期，不清理）；
     - `-3`入队（踢掉`-1`，“嗒”音效，加入`-3`）；
     - 队首`-3`是最小值，洞穴`-3`高亮。
   - **步骤3**：窗口滑到第3~5个元素（`-1,-3,5`）：
     - 清理队首`-3`（下标4，窗口左边界是3，没过期，不清理）；
     - `5`入队（比`-3`大，直接加入）；
     - 队首`-3`是最小值。

3. **交互与游戏化元素**：
   - **单步执行**：点击“单步”，动画走一步，同时显示文字提示（比如“踢掉队尾的3，因为-1更小”）；
   - **自动播放**：点击“自动”，动画按滑块速度播放，适合整体观察；
   - **得分系统**：每找到一个最值得10分，完成所有窗口得“最值探险家”称号；
   - **音效**：入队“叮”，出队“嗒”，最值“叮铃”，失败“哔”。

### 设计思路
- **像素风格**：用红白机的低分辨率和鲜艳色彩，降低视觉负担，符合青少年的审美；
- **游戏化元素**：得分和称号增加趣味性，让学习像玩游戏一样；
- **可视化重点**：突出“队尾踢掉更劣元素”和“队头清理过期元素”这两个核心步骤，让逻辑更直观。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
单调队列的应用非常广泛，只要遇到“**单调滑动的区间最值问题**”，都可以用它！比如：
</similar_problems_intro>

### 通用思路迁移
1. **滑动窗口的平均值**：虽然平均值不是最值，但如果需要“窗口内的最大值减去最小值”，就可以用单调队列；
2. **动态规划优化**：比如“最长递增子序列”的优化（虽然不是滑动窗口，但单调队列能维护状态的单调性）；
3. **数据流中的滑动窗口最值**：比如实时监控系统中，需要实时显示最近10秒的最高温度。

### 洛谷练习推荐
1. **洛谷 P2032** - 扫描  
   🗣️ **推荐理由**：这道题是单调队列的变形，需要维护“滑动窗口内的最大值”，能帮你巩固单调队列的应用。
2. **洛谷 P1440** - 求m区间内的最小值  
   🗣️ **推荐理由**：和本题几乎一样，但窗口大小是`m`，需要输出每个位置前`m`个元素的最小值，是单调队列的直接应用。
3. **洛谷 P3522** - [POI2011]TEM-Temperature  
   🗣️ **推荐理由**：这道题需要维护“滑动窗口内的最大值和最小值的差”，需要同时用两个单调队列，能锻炼你的综合应用能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“经验之谈”能帮你少走弯路，以下是我摘录的精华：
</insights_intro>

> **参考经验（来自hilsinleri）**：“单调队列的关键是‘老而更劣的元素永远不可能成为最值’。比如样例中的`3`，当`-1`入队后，`3`再也无法成为任何窗口的最小值，所以直接弹出。”  
> **点评**：这句话点出了单调队列的核心逻辑——**只保留有价值的元素**。在写代码时，只要想通“这个元素是不是比后面的元素更劣”，就能正确维护队列。

> **参考经验（来自Jerrycyx）**：“用取反技巧可以减少重复代码。比如求最大值时，把数组取反，求最小值后再取反，就能得到最大值。”  
> **点评**：这是“数学转换简化问题”的典型例子，能帮你写出更简洁的代码。

> **参考经验（来自yr409892525）**：“手写队列比STL的`deque`快，因为STL有额外的开销。在处理1e6级别的数据时，手写队列能避免超时。”  
> **点评**：竞赛中“常数优化”很重要，手写数据结构是常用的优化手段。


<conclusion>
单调队列是一种“聪明的队列”，它用线性时间解决了滑动窗口的最值问题，是算法学习中的“必学技能”。通过这道题，你不仅学会了单调队列的实现，还能理解“如何用数据结构优化时间复杂度”的核心思想。

记住：**算法的本质是“用更聪明的方式处理数据”**，就像单调队列一样——只留下有价值的元素，才能高效解决问题！下次遇到滑动窗口的问题，不妨试试单调队列吧～ 💪
</conclusion>

---
处理用时：126.01秒
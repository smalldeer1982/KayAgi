# 题目信息

# [Code+#3] 投票统计

## 题目描述

为了总结过去一段时间的命题工作，王队长组织了“我最喜欢的题目”评选活动，并邀请各位选手给题目进行投票。

具体来说，每道题目有一个正整数作为它的编号，一共有 $n$ 名选手给它们进行投票，每位选手投且仅投给一道题，其中第 $i$ 位选手所投票的题目编号为 $a_i$。

由于投票的选手众多，所以王队长请你来帮忙统计得票数。你需要找出收获选手投票最多的**题目数量**与**他们的编号**，并按**从小到大**的顺序列出这些编号。但这里有一个**例外情况**：如果所有被投票的题目得票数都相同，则王队长认为这次活动比较失败，你应该**输出-1**。



## 说明/提示

测试点编号|$n$的范围|$a_i$的范围|特殊约定
-|-|-|-
1|$=2000$|$\leq n$|得票数最多的题目唯一
2|同上|同上|同上
3|同上|$\leq 10^9$|同上
4|同上|$\leq n$|不会出现例外情况
5|同上|同上|同上
6|同上|$\leq 10^9$|同上
7|同上|$\leq n$|无
8|同上|同上|同上
9|同上|$\leq 10^9$|同上
10|同上|同上|同上
11|$=100000$|$\leq n$|得票数最多的题目唯一
12|同上|同上|同上
13|同上|$\leq 10^9$|同上
14|同上|$\leq n$|不会出现例外情况
15|同上|同上|同上
16|同上|$\leq 10^9$|同上
17|同上|$\leq n$|无
18|同上|同上|同上
19|同上|$\leq 10^9$|同上
20|同上|同上|同上

Credit： https://www.luogu.org/discuss/show?postid=35727

## 样例 #1

### 输入

```
3
10
2 6 1 2 1 1 2 6 7 1
10
10 3 6 6 3 10 6 6 6 2
10
8 8 10 10 10 10 8 5 8 8```

### 输出

```
1
1
1
6
1
8```

## 样例 #2

### 输入

```
3
10
1 4 3 1 8 8 7 2 8 7
10
1 10 9 1 3 2 9 9 2 1
10
4 1 5 4 1 9 5 5 4 1```

### 输出

```
1
8
2
1 9
3
1 4 5```

## 样例 #3

### 输入

```
3
10
3 3 10 8 8 3 10 8 10 3
10
2 2 8 6 8 4 2 4 4 8
10
6 2 5 6 7 5 7 10 2 10```

### 输出

```
1
3
3
2 4 8
-1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：[Code+#3] 投票统计 深入学习指南 💡

<introduction>
今天我们来分析这道“投票统计”题。题目要求我们统计得票最多的题目编号，并处理所有题目得票相同的特殊情况。本指南将带大家梳理核心思路、解析优质题解，并通过像素动画直观理解算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`统计与模拟（编程技巧应用）`

🗣️ **初步分析**：
解决这道题的关键在于高效统计每个题目编号的得票频率，并找到出现次数最多的编号。简单来说，就像班级投票后统计“谁的票数最高”，我们需要先数清楚每个人的票数，再比较找出最大值。若所有候选人的票数都一样，就输出-1。

- **题解思路对比**：主要有两种思路：  
  ① 排序后遍历统计（如Chouquet、Khassar的题解）：将数组排序，相同编号会连续出现，遍历统计每个编号的出现次数；  
  ② 使用`map`统计频率（如金苹果gold、_•́へ•́╬_的题解）：用`map`直接记录每个编号的得票次数，避免排序。两种方法时间复杂度相近（均为O(n log n)），但`map`更适合处理编号范围大的情况。
  
- **核心算法流程**：  
  1. 统计每个编号的得票次数；  
  2. 找到最大得票次数；  
  3. 收集所有得票次数等于最大值的编号；  
  4. 检查是否所有编号得票次数相同，若是则输出-1，否则输出收集的编号。

- **可视化设计**：  
  采用8位像素风格动画，用不同颜色的像素方块代表题目编号，方块高度表示得票次数。统计时，相同编号的方块会“堆叠”在一起（模拟排序后的连续出现）；用闪烁的箭头标记当前统计的编号，“叮”的音效提示计数完成；最终最大高度的方块会高亮，若所有高度相同则显示“-1”的像素文字。


## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性和算法有效性上表现突出（≥4星）：
</eval_intro>

**题解一：金苹果gold（来源：CSDN博客）**  
* **点评**：此题解巧妙利用`map`统计频率，思路简洁直观。代码中使用`map<long long, long long>`记录每个编号的得票次数，再通过遍历`map`找到最大频率并收集对应编号。变量命名清晰（如`maxn`表示最大票数，`tot`表示结果数量），边界处理（如`m.clear()`初始化）严谨，非常适合新手学习。

**题解二：Khassar（来源：个人题解）**  
* **点评**：此题解通过排序+遍历实现，时间效率高。将数组排序后，相同编号连续出现，通过一次遍历统计频率，避免了`map`的额外开销。代码中使用`a[n+1]=0`强制触发最后一次统计，简化了循环后的处理逻辑，细节处理巧妙。

**题解三：_•́へ•́╬_（来源：个人题解）**  
* **点评**：此题解采用双重`map`（频率到编号的映射），思路新颖。通过`map<int, vector<int>>`将频率相同的编号分组，直接取最后一个（最大频率）的`vector`作为结果，代码简洁且逻辑清晰，适合理解`map`的进阶应用。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，我们常遇到以下核心难点，结合优质题解的思路，一起来看看如何突破：
</difficulty_intro>

1.  **难点1：高效统计大范围内的编号频率**  
    * **分析**：题目中编号范围可能很大（如$a_i \leq 10^9$），直接用数组（桶排序）会浪费空间。优质题解中，金苹果gold和_•́へ•́╬_的`map`解法通过动态存储键值对，完美解决了这个问题；Khassar的排序法通过排序后连续统计，也避免了空间问题。  
    * 💡 **学习笔记**：当数据范围大但数量有限时，`map`是统计频率的高效工具；排序后遍历则适合需要利用有序性简化统计的场景。

2.  **难点2：正确处理所有编号得票相同的情况**  
    * **分析**：需要判断“最大频率的编号数量”是否等于“总不同编号数量”。例如，若有3种编号，且它们的频率都是5，则最大频率的数量是3，等于总数量，应输出-1。优质题解中，Khassar通过`s`（总不同编号数）和`cnt`（最大频率的数量）比较实现，逻辑简洁。  
    * 💡 **学习笔记**：特殊情况的判断需要明确变量含义，确保比较条件正确。

3.  **难点3：收集最大频率的编号并排序**  
    * **分析**：收集时需注意编号可能不连续（如`map`遍历顺序是升序，直接收集即可；排序法需额外排序）。金苹果gold的题解在收集后调用`sort`确保顺序，Khassar的排序法因数组已排序，直接收集即可。  
    * 💡 **学习笔记**：结果要求从小到大输出，需根据统计方式选择是否额外排序。

### ✨ 解题技巧总结
- **技巧1：善用排序简化统计**：排序后相同元素连续出现，统计频率时只需一次遍历。  
- **技巧2：`map`动态统计频率**：当元素范围大时，`map`能有效节省空间。  
- **技巧3：边界条件初始化**：多组测试时，每次循环需重置统计变量（如`m.clear()`、`sum=1`），避免前一次数据干扰。  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合`map`统计和排序遍历的优点，选择金苹果gold的`map`解法作为通用核心实现，因其逻辑清晰且适合大多数场景。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合金苹果gold的题解，采用`map`统计频率，逻辑简洁，适用于大编号范围的情况。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;

void solve() {
    int n;
    cin >> n;
    map<long long, long long> count; // 统计每个编号的得票次数
    vector<long long> nums;          // 存储不同的编号，用于后续遍历
    for (int i = 0; i < n; ++i) {
        long long x;
        cin >> x;
        if (count[x] == 0) nums.push_back(x); // 首次出现时记录编号
        count[x]++;
    }

    // 找最大得票次数
    long long max_freq = 0;
    for (auto num : nums) max_freq = max(max_freq, count[num]);

    // 收集所有得票次数等于max_freq的编号
    vector<long long> ans;
    bool all_same = true;
    for (auto num : nums) {
        if (count[num] == max_freq) ans.push_back(num);
        else all_same = false; // 存在不同频率，特殊情况不成立
    }

    // 处理特殊情况
    if (all_same) {
        cout << -1 << endl;
    } else {
        sort(ans.begin(), ans.end()); // 按从小到大排序
        cout << ans.size() << endl;
        for (auto x : ans) cout << x << " ";
        cout << endl;
    }
}

int main() {
    int T;
    cin >> T;
    while (T--) solve();
    return 0;
}
```
* **代码解读概要**：  
  代码首先用`map`统计每个编号的得票次数，同时用`vector`记录所有不同的编号（避免重复遍历`map`）。接着遍历`vector`找到最大频率，再收集所有频率等于最大值的编号。最后判断是否所有频率相同，输出结果。


<code_intro_selected>
接下来，我们剖析优质题解的核心片段，学习其中的巧妙思路：
</code_intro_selected>

**题解一：金苹果gold（来源：CSDN博客）**  
* **亮点**：代码简洁，`map`统计频率后直接遍历，逻辑清晰。  
* **核心代码片段**：  
```cpp
map<long long,long long>m;
long long T,n,tmp,had[100010],ans[100010];
void doit(){
    cin>>n; m.clear();
    // 统计频率并记录不同编号到had数组
    for(int i=1;i<=n;i++){
        cin>>tmp; m[tmp]++;
        if(m[tmp]==1) had[++cnt]=tmp;
    }
    // 找最大频率和收集结果
    for(int i=1;i<=cnt;i++) maxn=max(maxn,m[had[i]]);
    for(int i=1;i<=cnt;i++)
        if(m[had[i]]==maxn) ans[++tot]=had[i];
    // 输出处理...
}
```
* **代码解读**：  
  `had`数组记录所有不同的编号（仅在首次出现时添加），避免了遍历`map`的开销。通过两次遍历`had`数组，分别找最大频率和收集结果，逻辑直白易懂。  
* 💡 **学习笔记**：用数组记录`map`的键，可减少对`map`的遍历次数，提升效率。

**题解二：Khassar（来源：个人题解）**  
* **亮点**：排序后一次遍历统计，无需额外数据结构，空间效率高。  
* **核心代码片段**：  
```cpp
sort(a+1,a+1+n); a[n+1]=0; // 排序后，末尾设为0强制触发最后一次统计
int sum=1, mx=0;
for(int i=2; i<=n+1; i++){
    if(a[i]!=a[i-1]){ // 遇到不同编号，统计前一个的频率
        if(sum>mx) { mx=sum; ans[cnt=1]=a[i-1]; }
        else if(sum==mx) ans[++cnt]=a[i-1];
        sum=1;
    } else sum++;
}
```
* **代码解读**：  
  排序后，相同编号连续出现，通过`sum`计数。当遇到不同编号时，比较当前`sum`与`mx`（最大频率），更新结果数组`ans`。末尾的`a[n+1]=0`确保最后一个编号的频率被统计。  
* 💡 **学习笔记**：排序后利用连续性统计，是处理频率问题的经典技巧。


## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解统计频率和找最大值的过程，我们设计一个“像素投票统计器”动画，用8位复古风格展示每一步操作！
</visualization_intro>

  * **动画演示主题**：`像素投票站——统计谁的票最多？`

  * **核心演示内容**：  
    展示投票数据的输入、统计每个编号的得票次数、找到最大频率编号的过程，并用颜色高亮关键步骤（如统计完成、最大频率确定）。

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）让学习更轻松；用不同颜色的方块代表不同编号，方块高度表示得票次数；关键操作（如计数、比较）伴随“叮”音效，增强记忆点；特殊情况（所有高度相同）用闪烁的“-1”像素文字提示。

  * **动画帧步骤与交互关键点**：  

    1.  **初始化场景**：  
        - 屏幕左侧为“投票箱”（像素格子），右侧为“统计区”（垂直排列的像素方块）。  
        - 控制面板：单步/自动播放按钮、速度滑块（1x-5x）、重置按钮。  

    2.  **输入投票数据**：  
        - 每个投票编号以像素球形式从顶部落入投票箱，伴随“噗”的音效。  

    3.  **统计频率（以排序法为例）**：  
        - 投票箱内的编号自动排序（像素球按大小排列），相同编号的球堆叠在一起。  
        - 一个黄色像素箭头从左到右移动，每遇到一个新编号，箭头下方显示当前编号的计数（如“1→2→3”），计数时伴随“滴答”音效。  

    4.  **找最大频率**：  
        - 统计完成后，所有编号的方块按高度（频率）显示在统计区，高度越高颜色越亮（如红色>橙色>黄色）。  
        - 一个绿色像素指针从下往上扫描，停在最高的方块处，伴随“叮”的长音效。  

    5.  **特殊情况判断**：  
        - 若所有方块高度相同，统计区背景变为灰色，显示闪烁的“-1”像素文字，伴随“嗡”的提示音。  

    6.  **输出结果**：  
        - 最大高度的方块高亮（闪烁），编号按顺序显示在屏幕下方，伴随“胜利”音效。  

  * **旁白提示**：  
    - （输入时）“看！每个投票像小球一样落入箱子～”  
    - （统计时）“箭头在数这个编号的票数，现在是第3票啦！”  
    - （找最大值时）“绿色指针在找最高的方块，最高的就是得票最多的～”  


## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是统计频率并处理最大值，这类思路在许多问题中都有应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 统计频率：可用于“求众数”（出现次数最多的数）、“字符频率统计”等问题。  
    - 处理最大值：可用于“求最高分学生”“最受欢迎商品”等场景。  
    - 特殊情况判断：如“所有元素相同”“所有分组大小一致”等问题。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1160 队列安排**：统计学生的插入和删除操作，需要维护顺序和频率，锻炼数据结构应用。  
    2.  **洛谷 P1059 明明的随机数**：统计去重后的数并排序，练习频率统计和排序结合。  
    3.  **洛谷 P1908 逆序对**：虽然是逆序对问题，但统计频率的思路可用于优化计数过程，适合进阶练习。  


## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了实战经验，这些对我们很有启发：
</insights_intro>

> **参考经验 (来自Khassar)**：“我的码风对除我以外的人都不太友好，但排序+遍历的方法确实高效。多组数据一定要记得初始化变量，否则前一次的结果会干扰当前测试。”  
> **点评**：Khassar的经验提醒我们，多组测试时变量初始化非常重要（如`m.clear()`、`sum=1`）。良好的代码风格（如清晰的变量名）能让他人更易理解，建议新手尽量写“友好”的代码。  


<conclusion>
通过今天的分析，我们掌握了统计频率、找最大值和处理特殊情况的方法。编程的关键在于多思考、多实践，下次遇到类似问题时，你一定能快速解决！💪
</conclusion>

---
处理用时：140.40秒
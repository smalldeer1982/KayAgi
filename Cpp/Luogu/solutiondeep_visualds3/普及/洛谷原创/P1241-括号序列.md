# 题目信息

# 括号序列

## 题目描述

定义如下规则：

1. 空串是「平衡括号序列」
2. 若字符串 $S$ 是「平衡括号序列」，那么 $\texttt{[}S\texttt]$ 和 $\texttt{(}S\texttt)$ 也都是「平衡括号序列」
3. 若字符串 $A$ 和 $B$ 都是「平衡括号序列」，那么 $AB$（两字符串拼接起来）也是「平衡括号序列」。


例如，下面的字符串都是平衡括号序列：


- `()`，`[]`，`(())`，`([])`，`()[]`，`()[()]`


而以下几个则不是：


- `(`，`[`，`]`，`)(`，`())`，`([()`


现在，给定一个仅由 `(`，`)`，`[`，`]`构成的字符串 $s$，请你按照如下的方式给字符串中每个字符配对：
1. 从左到右扫描整个字符串。
2. 对于当前的字符，如果它是一个右括号，考察它与它左侧离它**最近**的**未匹配**的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。

配对结束后，对于 $s$ 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。

## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $s$ 的长度不超过 $100$，且只含  `(`，`)`，`[`，`]` 四种字符。

## 样例 #1

### 输入

```
([()
```

### 输出

```
()[]()
```

## 样例 #2

### 输入

```
([)```

### 输出

```
()[]()```

# AI分析结果

# 💡 Kay的C++算法解析：括号序列 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（栈的核心思想与括号匹配）

🗣️ **初步分析**：  
解决“括号序列”问题的关键，就像**叠盘子游戏**——我们把没配对的左括号（`(`或`[`）像盘子一样“叠”在栈里，遇到右括号（`)`或`]`）时，就检查“最上面的盘子”（栈顶的左括号）能不能和它配对：能配对就把盘子“拿走”（弹出栈），不能配对就给右括号补一个对应的左括号，或者给剩下的左括号补右括号。  

**题解核心思路**：几乎所有优质题解都用了**栈**来记录未匹配的左括号位置，再用一个数组标记哪些括号已经匹配成功。最后遍历原序列，匹配的直接输出，未匹配的补全成对输出。  
**核心难点**：① 正确理解“右括号找最近未匹配左括号”的规则（不是找所有左括号，而是遇到另一种未匹配左括号就停止）；② 避免栈空时取栈顶元素（会导致程序崩溃）；③ 未匹配括号的补全位置（左括号补右，右括号补左）。  
**可视化设计思路**：我们会用8位像素风格展示括号序列，用**红色像素块**表示未匹配的左括号，**蓝色像素块**表示右括号，栈用“像素堆叠”显示在右侧。匹配时，栈顶像素块会“消失”（弹出），并播放“叮”的音效；补全时，会从旁边“滑入”一个新的像素块（比如给`(`补`)`），播放“咔”的音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮大家快速理解核心逻辑～
</eval_intro>

**题解一：作者MY的正解题解**  
* **点评**：这份题解把问题拆得很明白——用栈记左括号位置，用数组`c`记补全的字符。遇到左括号就入栈并记录对应的右括号；遇到右括号时，若栈顶左括号能匹配，就清空对应的补全字符；否则给右括号补左括号。最后按顺序输出原字符和补全字符，逻辑闭环非常清晰。代码里`w`数组记左括号位置，`c`数组记补全字符，变量命名也很直观，新手能快速跟上思路。

**题解二：作者YuJieSong的标记数组题解**  
* **点评**：这题解的“标记数组”思路特别适合新手理解——用`b`数组标记哪些括号已经匹配，遇到右括号就向左找最近的未标记左括号，匹配就打标记。最后遍历序列，标记过的直接输出，没标记的补全。代码里`fh`数组给括号编码（比如`(`是-1，`)`是1），用“编码和为0”判断匹配，简化了条件判断，很巧妙。

**题解三：作者anyway的补全数组题解**  
* **点评**：这份题解的“补全数组`b`”设计超简洁！遇到左括号就入栈并在`b`数组记对应的右括号；遇到右括号时，若栈顶能匹配就清空`b`数组对应位置，否则记对应的左括号。最后输出时，先补全左括号，再输出原字符，最后补全右括号，流程一步到位。代码只有几十行，却覆盖了所有情况，非常高效。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“坑”主要在3个地方，搞懂它们就能轻松通关～
</difficulty_intro>

1. **难点1：题意理解——“右括号找最近未匹配左括号”**  
   * **分析**：比如输入`([)]`，右括号`]`会找最近的未匹配左括号`(`，但`(`和`]`不匹配，所以`]`需要补`[`；而右括号`)`会找最近的未匹配左括号`[`，也不匹配，补`(`。  
   * **策略**：遇到右括号时，**只看栈顶的左括号**（栈顶是最近的未匹配左括号），不用遍历所有左括号——栈的“后进先出”刚好帮我们记住了“最近的”。

2. **难点2：避免栈空时取栈顶元素**  
   * **分析**：如果输入全是右括号（比如`]]]`），栈是空的，这时候取栈顶会导致程序崩溃。  
   * **策略**：每次取栈顶前，先检查`!st.empty()`（栈非空），比如题解一中的`if(top && s[top] == '(')`。

3. **难点3：未匹配括号的补全位置**  
   * **分析**：左括号（`(`或`[`）未匹配，要在它后面补右括号（`)`或`]`）；右括号未匹配，要在它前面补左括号。  
   * **策略**：用数组记录每个位置需要补的字符（比如题解三中的`b`数组，左括号位置记右括号，右括号位置记左括号），最后输出时按顺序补全。

### ✨ 解题技巧总结
- **栈的正确使用**：只用栈存左括号的位置，遇到右括号就检查栈顶，避免存所有字符。  
- **标记数组简化逻辑**：用`bool`数组标记匹配状态，比反复遍历更高效。  
- **编码简化判断**：给括号编对立的码（比如`(`=-1，`)`=1），和为0就匹配，不用写多个`if`判断。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合优质题解的通用实现，帮大家建立整体框架～
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了MY、YuJieSong、anyway三位作者的思路，用栈记录左括号位置，标记数组记匹配状态，最后补全输出。
* **完整核心代码**：
```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

int main() {
    string s;
    cin >> s;
    int len = s.size();
    stack<int> st;          // 存未匹配左括号的位置
    bool matched[105] = {false};  // 标记是否匹配

    for (int i = 0; i < len; ++i) {
        if (s[i] == '(' || s[i] == '[') {
            st.push(i);  // 左括号入栈
        } else if (s[i] == ')' || s[i] == ']') {
            if (!st.empty()) {  // 栈非空才检查
                int top_pos = st.top();
                if ((s[top_pos] == '(' && s[i] == ')') || 
                    (s[top_pos] == '[' && s[i] == ']')) {
                    matched[top_pos] = true;
                    matched[i] = true;
                    st.pop();  // 匹配成功，弹出栈顶
                }
            }
        }
    }

    // 输出：匹配的直接输出，未匹配的补全
    for (int i = 0; i < len; ++i) {
        if (matched[i]) {
            cout << s[i];
        } else {
            if (s[i] == '(' || s[i] == ')') {
                cout << "()";
            } else {
                cout << "[]";
            }
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 用`stack<int>`存左括号的位置（不是字符，这样能直接标记匹配状态）；  
  2. 遍历原序列，左括号入栈，右括号检查栈顶是否匹配，匹配就标记`matched`数组；  
  3. 最后遍历`matched`数组，匹配的输出原字符，未匹配的补全成对输出。


<code_intro_selected>
接下来剖析优质题解的核心片段，看看它们的“巧思”～
</code_intro_selected>

### 题解一：作者MY的栈与补全数组实现
* **亮点**：用数组直接记录每个位置需要补的字符，避免二次遍历。
* **核心代码片段**：
```cpp
char s[110], c[110];  // s存原序列，c存补全的字符
stack<int> st;

for (int i = 0; i < len; ++i) {
    if (s[i] == '(') {
        st.push(i);
        c[i] = ')';  // 左括号补右括号
    } else if (s[i] == ')') {
        if (!st.empty() && s[st.top()] == '(') {
            c[st.top()] = ' ';  // 匹配成功，清空补全字符
            st.pop();
        } else {
            c[i] = '(';  // 右括号补左括号
        }
    }
    // [和]的处理类似
}
```
* **代码解读**：  
  这段代码的“巧思”是**用`c`数组直接记补全的字符**——左括号`(`的位置记`)`，如果后来匹配成功，就把`c[st.top()]`设为空格（表示不用补）；右括号`)`没匹配到，就记`(`。最后输出时，先打补全的字符，再打原字符，再打补全的字符，一步到位！  
* **学习笔记**：用数组记录补全字符，比标记数组更直接，适合新手理解。


### 题解二：作者YuJieSong的编码匹配实现
* **亮点**：用编码简化匹配判断，不用写多个`if`。
* **核心代码片段**：
```cpp
int fh[300];  // 给括号编码
fh['('] = -1; fh[')'] = 1;
fh['['] = -2; fh[']'] = 2;

for (int i = 0; i < len; ++i) {
    if (fh[s[i]] < 0) {  // 左括号（编码为负）
        st.push(i);
    } else {  // 右括号（编码为正）
        if (!st.empty()) {
            int k = st.top();
            if (fh[s[k]] + fh[s[i]] == 0) {  // 编码和为0，匹配
                matched[i] = matched[k] = true;
                st.pop();
            }
        }
    }
}
```
* **代码解读**：  
  把`(`编为-1，`)`编为1，它们的和是0，刚好表示匹配；`[`和`]`同理。这样不用写`if (s[k] == '(' && s[i] == ')')`，直接用`fh[s[k]] + fh[s[i]] == 0`判断，代码更简洁！  
* **学习笔记**：编码是简化条件判断的常用技巧，尤其适合对立的情况（比如括号、正负）。


### 题解三：作者anyway的补全顺序优化
* **亮点**：输出时先补左括号，再输出原字符，最后补右括号，流程更顺。
* **核心代码片段**：
```cpp
char c[101], b[101];  // c存原序列，b存补全的字符
stack<int> q;

for (int i = 0; i < len; ++i) {
    if (c[i] == '(') {
        q.push(i);
        b[i] = ')';
    } else if (c[i] == ')') {
        if (!q.empty() && b[q.top()] == ')') {
            b[q.top()] = ' ';
            q.pop();
        } else {
            b[i] = '(';
        }
    }
}

// 输出部分
for (int i = 0; i < len; ++i) {
    if (b[i] == '(' || b[i] == '[') cout << b[i];  // 补左括号
    cout << c[i];
    if (b[i] == ')' || b[i] == ']') cout << b[i];  // 补右括号
}
```
* **代码解读**：  
  输出时，先检查`b[i]`是不是左括号（比如右括号补的`(`），是就先输出；再输出原字符；最后检查`b[i]`是不是右括号（比如左括号补的`)`），是就输出。这样补全的字符会刚好“贴”在原字符旁边，符合题意要求！  
* **学习笔记**：输出顺序的优化能让代码更简洁，避免额外的数组存储。


## 5. 算法可视化：像素动画演示

### 🌟 动画主题：像素括号“配对大挑战”  
我们用**8位红白机风格**设计动画，让你像玩“坦克大战”一样直观理解栈的操作！


### 🎮 核心演示内容
1. **场景初始化**：  
   - 屏幕左侧是**像素化括号序列**（`(`用红色方块，`[`用橙色方块，`)`用蓝色方块，`]`用绿色方块）。  
   - 右侧是**栈的像素堆叠**（红色/橙色方块叠在一起，表示未匹配的左括号）。  
   - 底部有“单步”“自动播放”“重置”按钮，还有速度滑块（从“龟速”到“光速”）。

2. **算法执行演示**：  
   - **左括号入栈**：点击“单步”，红色方块（`(`）会“跳”到右侧栈顶，同时播放“叮”的音效。  
   - **右括号匹配**：遇到蓝色方块（`)`），栈顶的红色方块会“消失”（弹出栈），并播放“唰”的音效，原括号会变成**灰色**（标记为匹配）。  
   - **补全括号**：如果右括号不能匹配，会从左侧“滑入”一个红色方块（补`(`），播放“咔”的音效；如果栈里还有左括号，会从右侧“滑出”蓝色方块（补`)`）。

3. **交互设计**：  
   - **自动播放**：点击“自动”，动画会按设定速度运行，像“贪吃蛇AI”一样自动完成配对。  
   - **音效反馈**：匹配成功播“叮”，补全播“咔”，完成全部配对播“胜利音效”（类似FC游戏的通关音乐）。  
   - **重置**：点击“重置”，所有像素块回到初始位置，重新开始演示。


### 🛠️ 技术实现思路
- **像素绘制**：用HTML5 Canvas画16x16的像素块，每个括号对应一个像素块。  
- **栈的可视化**：用数组存储栈中的像素块位置，每次入栈就把像素块“移”到栈顶位置，出栈就把栈顶像素块设为透明。  
- **交互控制**：用JavaScript监听按钮点击，单步执行时更新一帧，自动播放时用`setInterval`定时更新。


## 6. 拓展练习与相似问题

### 🔍 通用思路迁移
括号匹配的栈应用非常广泛，比如：
- 验证数学表达式的括号合法性（如`(a+b)*[c-d]`）；
- 编辑器的“括号自动补全”功能；
- 编译器的语法分析（检查代码中的括号是否匹配）。


### 📚 推荐练习
1. **洛谷P1739 表达式括号匹配**：基础括号匹配题，练习栈的基本使用。  
   * 推荐理由：帮你巩固“栈存左括号，右括号匹配栈顶”的核心逻辑。  
2. **洛谷P4387 验证括号序列**：加强版括号匹配，需要处理多种括号（`{}` `<>`）。  
   * 推荐理由：练习编码简化判断，比如用`map`存括号对立关系。  
3. **洛谷P1241 括号序列（本题）**：再做一遍本题，试试用不同的方法实现（比如标记数组 vs 补全数组）。  


## 7. 学习心得与经验分享

**参考经验（来自作者MY）**：  
“我一开始用两个栈分别存`(`和`[`，结果遇到`([)]`这种情况就错了——因为`]`会找最近的`(`，而不是`[`。后来改成一个栈存所有左括号位置，才解决了问题。”  

**Kay的点评**：这个经验太重要了！**不要分开处理不同的左括号**，因为题目要求“右括号找最近的未匹配左括号”，不管它是哪种类型——栈的“后进先出”刚好帮我们记住了“最近的”，分开栈会破坏这个逻辑！  


## 💪 结语
括号序列问题是栈的经典应用，搞懂它就能举一反三解决很多类似问题。记住：**栈是处理“最近匹配”问题的神器**，遇到“找最近的XX”就想想栈吧！  

下次我们会挑战更难的括号问题（比如最短补全序列），敬请期待～  

Kay 陪你一起，从“蒟蒻”变“大佬”！✨

---
处理用时：244.66秒
# 题目信息

# [✗✓OI R1] 前方之风

## 题目背景

>「不错的恶意。」  
> 女性呵呵笑道。  
>「但是，如果向我发出恶意，你可是会死哦？」

你不知道什么动作会被算作发出恶意，所以你决定做一道题来分散自己的注意力。

## 题目描述

给出一个长度为 $n$ 的序列 $a$ 和 $q$ 个询问，第 $i$ 个询问给出 $k_i$。对于每次询问，你需要进行以下操作：
1. 求出剩下的数的平均数 $\mathit{avg}$。
2. 将剩下的数中 $<\mathit{avg}-k_i$ 的数删去。
3. 重复以上两个步骤直到所有数都不会被删去。
4. 输出最后会剩下几个数。

**注意：询问之间是独立的，也就是说，不会真的删去那些数。**

## 说明/提示

**【样例解释】**

对于第一组样例，当 $k=0$ 时，显然只会留下 $99$。  
当 $k=6$ 时，删除数的步骤如下：
- 平均数为 $60\dfrac{1}{9}$，留下 $99,63,72,97,68$。
- 平均数为 $79.8$，留下 $99,97$。
- 平均数为 $98$，停止删除。

**【数据范围】**

对于 $100\%$ 的数据，满足 $1\leq n,q \le 10^5$，$1\le T \le 10$，$0 \le a_i,k_i \le 10^9$。

| subtask | 特殊数据范围 | 分数 |  时间限制
| :----------: | :----------: | :----------: |  :----------: |
| 1 | $n,q \le 200$ | 20 |   300ms 
| 2 | $n,q \le 2000$ | 30  | 300ms
| 3 |  | 50 | 800ms|

>「不错的恶意。」  
> 女性呵呵笑道。  
>「而且你运气很不错，如果放在以前，你早就死了。」

![](https://cdn.luogu.com.cn/upload/image_hosting/6icoj36r.png)

## 样例 #1

### 输入

```
5
9 9
19 99 63 39 72 46 97 38 68 
0 6 4 0 7 1 0 3 6 
6 8
88 62 48 50 8 47 
0 6 1 5 2 2 6 1 
6 5
33 3 54 17 26 64 
87 89 92 70 59 
18 19
71 52 77 38 12 34 82 14 57 39 91 7 56 86 35 68 38 14 
9 9 1 5 1 3 4 5 6 1 6 0 3 0 2 1 3 5 8 
10 15
4 77 78 76 5 19 98 94 77 81 
17 43 4 86 2 91 85 4 81 74 44 16 21 69 32 
```

### 输出

```
1 2 2 1 2 2 1 2 2
1 1 1 1 1 1 1 1
6 6 6 6 6
4 4 1 3 1 2 2 3 3 1 3 1 2 1 1 1 2 3 4
7 7 2 10 2 10 10 2 10 10 7 7 7 10 7
```

## 样例 #2

### 输入

```
1
5 1
20 0 0 0 0
5```

### 输出

```
5```

# AI分析结果

# 💡 Kay的C++算法解析：前方之风 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（排序、离线处理、双指针的综合运用）

🗣️ **初步分析**：  
解决这道题的关键像**整理玩具箱**——小玩具（小数字）总是先被挑出来丢掉。我们先把序列**从小到大排序**，这样每次要删的数一定是前面的“小玩具”，剩下的数必然是数组的**后缀**（从某个位置到末尾的连续数字）。  

接下来，我们发现**询问的k越大，删数条件越松**（比如k=6时，要删的是<avg-6的数；k=7时，要删的是<avg-7的数，后者更小，所以更少的数会被删）。因此，**答案随k增大而单调不减**（k越大，剩下的数越多）。利用这个性质，我们可以把询问**按k从大到小排序**（离线处理），用一个**双指针**从前往后扫排序后的数组——每个询问只需接着前面的指针位置继续判断，不用重新扫整个数组，直接得到答案。  

**核心算法流程**：  
1. 排序原数组→确定删数顺序是前缀；  
2. 离线处理询问→按k从大到小排序；  
3. 双指针遍历→移动指针直到找到第一个不满足“被删”条件的位置，记录剩余数的个数。  

**可视化设计思路**：  
我们用**8位像素风**展示排序后的数组（小数字浅蓝、大数字深蓝），双指针用“红色箭头”标记当前处理的数，计算avg时上方显示像素数字（比如“avg: 79.8”）。删数时，前缀的像素块会“咻”地变透明（伴随音效），稳定时剩余块闪烁并播放“叮”的胜利音效。控制面板有“单步”（按一下走一步）、“自动”（调速滑块控制速度）、“重置”按钮，让你亲手“操控”删数过程！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：来源xzyg的Sol2**  
* **点评**：这份题解把“排序+离线+双指针”的思路贯彻得非常彻底。代码先排序数组和询问，用**后缀和**快速计算任意后缀的和与平均数（避免重复求和），再用双指针处理每个询问——当a[i] < avg[i]-k时，i++（删数），否则记录答案。思路清晰，代码规范（变量名如`add`（后缀和）、`avg`（平均数）都很易懂），能轻松处理1e5的数据，是典型的“高效解法”模板。

**题解二：来源AsunderSquall的算法三**  
* **点评**：这题解的“性质分析”特别透彻！作者证明了“排序后剩余数是后缀”“答案随k增大而单调不减”这两个关键结论，帮你从“知其然”到“知其所以然”。虽然没给出完整代码，但思路推导过程能让你明白“为什么可以这样做”，适合学习如何从问题中提炼规律。

**题解三：来源漠寒的代码**  
* **点评**：代码的“实用性”很强！作者用结构体存储询问的k和id（方便按原顺序输出），用**double**处理平均数（避免整数除法的精度坑），还写了`clean`函数处理多组测试用例的初始化（避免数组残留）。双指针的逻辑简洁明了，是“能直接复制粘贴用的工程代码”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“捅破三层窗户纸”——发现删数的规律、利用询问的单调性、处理精度问题。我们逐一拆解：
</difficulty_intro>

1. **难点1：如何发现“删数的顺序是前缀”？**  
   * **分析**：小数字更容易满足“<avg -k”，所以每次删的都是当前剩余数中的最小值。排序后，剩余数必然是数组的**后缀**（从某个位置到末尾的连续数字），不用再零散地找要删的数。  
   * 💡 **学习笔记**：排序是解决“按大小删数”问题的万能钥匙，能把零散操作转化为连续区间操作。

2. **难点2：如何利用询问的单调性优化？**  
   * **分析**：k越大，删数条件越松（剩的数越多），所以答案随k增大而**单调不减**。我们把询问按k从大到小排序，用双指针从前往后扫——每个询问只需接着前面的指针位置，不用重新扫整个数组，时间从O(qn)降到O(n log n + q log q)。  
   * 💡 **学习笔记**：离线处理的核心是“找到答案的单调性”，让之前的计算能复用。

3. **难点3：如何处理浮点数精度问题？**  
   * **分析**：计算平均数时，整数除法会丢失小数部分（比如(20+0+0+0+0)/5=4，但实际是4.0，用整数算没问题；但如果是(19+99+63+39+72+46+97+38+68)/9≈60.11，用整数算会得到60，导致比较错误）。所以要用**double**存储平均数和比较条件。  
   * 💡 **学习笔记**：涉及“平均数比较”时，一定要用浮点数类型，避免精度误差！

### ✨ 解题技巧总结
- **后缀和/前缀和**：快速计算连续区间的和与平均数，避免重复求和。  
- **离线处理**：将询问按单调性排序，复用之前的计算，优化时间。  
- **双指针**：遍历一次数组处理所有询问，效率极高。  
- **浮点数处理**：用double存储平均数，避免整数除法的精度坑。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了xzyg、漠寒、BaCO3的思路，是“排序+离线+双指针”的典型实现。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;

struct Query {
    ll k;
    int id;
    ll ans;
} q[N];

ll a[N], sum[N]; // sum是前缀和（sum[i] = a[1]+...+a[i]）
int n, q_num;

// 按k从大到小排序询问
bool cmpQuery(const Query& x, const Query& y) {
    return x.k > y.k;
}

// 按原id排序输出
bool cmpId(const Query& x, const Query& y) {
    return x.id < y.id;
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        scanf("%lld%d", &n, &q_num);
        // 1. 读取数组并排序
        for (int i = 1; i <= n; ++i) {
            scanf("%lld", &a[i]);
        }
        sort(a + 1, a + n + 1);

        // 2. 计算前缀和（用于快速求后缀和：sum[n] - sum[pos-1]）
        sum[0] = 0;
        for (int i = 1; i <= n; ++i) {
            sum[i] = sum[i - 1] + a[i];
        }

        // 3. 读取询问并存储id
        for (int i = 1; i <= q_num; ++i) {
            scanf("%lld", &q[i].k);
            q[i].id = i;
        }

        // 4. 离线处理：按k从大到小排序询问
        sort(q + 1, q + q_num + 1, cmpQuery);

        // 5. 双指针处理询问
        int pos = 1; // pos及以后的数未被删
        for (int i = 1; i <= q_num; ++i) {
            while (pos <= n) {
                ll remaining = n - pos + 1; // 剩余数的个数
                double avg = (double)(sum[n] - sum[pos - 1]) / remaining; // 后缀的平均数
                if (a[pos] < avg - q[i].k) {
                    pos++; // 删去这个数
                } else {
                    break; // 找到稳定位置
                }
            }
            q[i].ans = n - pos + 1; // 剩余数的个数
        }

        // 6. 按原id排序并输出
        sort(q + 1, q + q_num + 1, cmpId);
        for (int i = 1; i <= q_num; ++i) {
            printf("%lld ", q[i].ans);
        }
        printf("\n");
    }
    return 0;
}
```
* **代码解读概要**：  
  代码分6步：① 读取数组并排序；② 计算前缀和（快速求后缀和）；③ 读取询问并存储id；④ 按k从大到小排序询问；⑤ 双指针遍历数组，处理每个询问；⑥ 按原id排序并输出答案。核心是**前缀和**（快速求平均数）和**双指针**（复用计算）。


<code_intro_selected>
再看优质题解的核心片段，聚焦“后缀和”和“双指针”：
</code_intro_selected>

**题解一：来源xzyg的Sol2**
* **亮点**：用**后缀和**快速计算平均数，避免重复求和。
* **核心代码片段**：
```cpp
// 计算后缀和（add[i] = a[i]+a[i+1]+...+a[n]）
add[n] = a[n];
for (ll i = n-1; i >= 1; --i) {
    add[i] = add[i+1] + a[i];
}
// 计算每个后缀的平均数（avg[i] = add[i]/(n-i+1)）
for (ll i = 1; i <= n; ++i) {
    avg[i] = 1.0 * add[i] / (n - i + 1);
}
// 双指针处理询问
ll p = 1;
for (ll i = 1; i <= n && p <= q; ) {
    while (a[i] < avg[i] - k[p].val) ++i; // 删去a[i]
    k[p].ans = n - i + 1; // 剩余数的个数
    p++; // 处理下一个询问
}
```
* **代码解读**：  
  后缀和`add[i]`存储从i到n的和，`avg[i]`直接用`add[i]`除以剩余数的个数，不用每次重新求和。双指针`i`遍历数组，`p`处理询问——当`a[i] < avg[i]-k`时，`i++`（删数），否则记录答案。这一步把求和的时间从O(n)降到了O(1)，效率极高！
* 💡 **学习笔记**：后缀和/前缀和是处理“连续区间和”的神器，能大幅减少重复计算。


## 5. 算法可视化：像素动画演示

**动画主题**：像素数的“生存挑战”  
**设计思路**：用8位像素风营造复古氛围，用高亮、音效强化关键步骤，让你“亲眼看见”删数的过程。  
**核心演示内容**：  
1. **初始化**：屏幕显示一排像素块（从左到右小→大，浅蓝→深蓝），上方是控制面板（单步、自动、重置按钮+调速滑块），右侧显示当前k值和avg值。  
2. **排序展示**：点击“开始”，数组快速排序（像素块从乱到整齐，伴随“唰”的音效）。  
3. **离线处理**：询问按k从大到小排列，第一个k显示在右侧。  
4. **双指针移动**：  
   - 红色箭头标记当前`pos`的像素块，上方显示`avg`（比如“avg: 79.8”）。  
   - 若`a[pos] < avg -k`，该像素块“咻”地变透明（删数），`pos`右移。  
   - 若稳定，剩余像素块闪烁，播放“叮”的胜利音效，右侧显示答案（比如“剩余：2个”）。  
5. **交互控制**：  
   - “单步”：按一下走一步，仔细观察每个步骤。  
   - “自动”：调速滑块控制播放速度（慢→快）。  
   - “重置”：回到初始状态，重新开始。  
**音效设计**：排序“唰”、删数“咻”、稳定“叮”，背景音乐是8位风格的轻快旋律（比如《超级马里奥》的背景音）。


## 6. 拓展练习与相似问题

<similar_problems_intro>
掌握了“排序+离线+双指针”的技巧后，你可以挑战这些相似问题，巩固所学：
</similar_problems_intro>

### 相似问题与推荐练习
1. **洛谷P1908 逆序对**：用排序+归并排序计算逆序对，练习“排序的应用”。  
2. **洛谷P2078 朋友**：离线处理询问，练习“利用单调性优化”。  
3. **洛谷P3369 普通平衡树**：用排序或平衡树处理动态查询，练习“数据结构的综合运用”。  
4. **洛谷P4387 验证栈序列**：用双指针模拟栈操作，练习“指针的灵活运用”。


## 7. 学习心得与经验分享 (若有)

> **参考经验（来自xzyg）**：“赛后被hack掉暴力模拟+二分，因为二分的条件假了——比如样例中的全0数组，二分可能误以为要删数，但实际已经稳定。”  
> **点评**：这提醒我们“假算”的危险——二分的条件必须严格符合题意，不能想当然。遇到“稳定状态”问题，一定要验证“是否真的无法再删数”。

> **参考经验（来自AsunderSquall）**：“模拟的时间复杂度是O(qn²)，会被卡成20分，必须找更优的方法。”  
> **点评**：模拟是“最直观”的方法，但面对1e5的数据时，必须想“有没有规律可以利用”——比如本题的“排序后是后缀”“答案单调”，都是优化的关键。


## 结语
这道题的核心是**“把零散的问题转化为连续的问题”**——排序让删数变成前缀操作，离线让询问可以复用计算，双指针让遍历效率最大化。希望这份指南能帮你掌握这些技巧，下次遇到类似问题时，能快速想到“排序→离线→双指针”的套路！

编程的进步在于“举一反三”，多练、多想，你会越来越厉害！💪

---
处理用时：114.42秒
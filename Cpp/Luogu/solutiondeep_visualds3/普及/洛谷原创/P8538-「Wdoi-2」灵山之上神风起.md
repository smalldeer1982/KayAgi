# 题目信息

# 「Wdoi-2」灵山之上神风起

## 题目背景

在天狗记者射命丸文的指（放）引（水）之下，灵梦一行人找到了山中的神社。

“在妖怪之山上还真的存在其他的神社啊。”灵梦感慨道。她们看到了由树木建造的神社正殿，以及正殿前的参拜道上的一排御柱，而更远处则是一片湖——风神之湖。湖面非常开阔，波光粼粼，一碧万顷，远处似乎有群山环抱，让人心旷神怡。

到达神社之时已经是傍晚了。正当灵梦和魔理沙感慨之时，见到在她们面前有一位白衣蓝裙的少女，东风谷早苗，拥有着引发奇迹程度的能力。为了找到守矢神社中的两位神灵，灵梦与魔理沙，向东风谷早苗产生了激烈的交战。

“那就在现人神的力量洗礼中思索吧！这召唤奇迹的神明之力！”

## 题目描述

### 简要题意

给定一个长度为 $n$ 的正整数序列 $a$ 满足对于所有 $i\in [1,n]$ 有 $a_i \in \{1,2,3\}$。

现在通过该序列构造一张含 $n$ 个节点，节点编号为 $1$ 到 $n$ 的图：对于数 $i$，如果 $a_i=1$，那么什么都不做；如果 $a_i=2$，那么向所有比 $i$ 小的数的节点连无向边；如果 $a_i=3$，那么向所有比 $i$ 大的数的节点连无向边。求出该图的最大独立集的大小。

最大独立集，指的是原图中一个点数尽量多的点集，这些点在原图中两两之间没有边**直接**相连。

### 原始题意

然而，东风谷早苗（后称早苗）的弹幕密度相当之高，使人应接不暇，灵梦只得想个方法去减少她需要关注的弹幕数量。

数个回合过后，她发现，早苗每次释放弹幕只会释放出 $n$ 个弹幕，分别编号为 $1,2,\dots,n$，而她每释放一个弹幕，都会对应着产生一次神力波动。因而她的神力波动可以抽象为一个长度为 $n$ 的正整数数列 $\{a_n\}$。由于她的资历尚浅，只会使用三种神力，分别用 $1,2,3$ 表示，即 $\forall i \in [1,n]$，$a_i \in \{1,2,3\}$。

她发现，早苗的三种神力作用各不相同，具体而言如下：

- 当 $a_i=1$ 时，她不会做任何事情。
- 当 $a_i=2$ 时，早苗会让第 $i$ 个弹幕向所有弹幕编号**小于** $i$ 的弹幕建立神力输送通道。
- 当 $a_i=3$ 时，早苗会让第 $i$ 个弹幕向所有弹幕编号**大于** $i$ 的弹幕建立神力输送通道。

接着，在各种神力的交互配合之下，密集的弹幕将展开于灵梦的眼前。而一旁的魔理沙发现，若是从这些弹幕中挑选出**尽可能多的**一群弹幕，使得每个弹幕之间不存在直接相连的神力输送通道，那么这群弹幕会产生【引发奇迹程度的能力】，是不必关注的。

由于【引发奇迹程度的能力】只能被触发**一次**，灵梦和魔理沙想要知道，**最多**有多少个弹幕是不必关注的。她们找到了你，希望你能帮她解答。

## 说明/提示

### 样例解释

根据题意显然可以构造出如下的图。其中 $a_i=2$ 的用蓝色边表示，$a_i=3$ 的用红色边表示。

显然选取第 $2,3$ 个弹幕（已用绿色填图）是最多的情况。实际上对于这个样例，选取弹幕的方案不止一种，但是不存在更多的情况了。

![](https://cdn.luogu.com.cn/upload/image_hosting/99a854cu.png)

### 数据范围

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|}\hline
\textbf{Subtask} & \bm{n\le} & \textbf{特殊性质} & \textbf{分值}\\\hline
1 & 10 & - & 20\\\hline
2 & 10^5 & \text{A} & 10\\\hline
3 & 10^5 & \text{B} & 30 \\\hline
4 & 10^5 & - & 40 \\\hline
\end{array}$$

- 特殊性质 $\text{A}$：所有的 $a_i=1$；
- 特殊性质 $\text{B}$：所有的 $a_i$ 不是 $1$ 就是 $2$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$a_i \in \{1,2,3\}$。

## 样例 #1

### 输入

```
6
3 1 3 2 1 2```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：「Wdoi-2」灵山之上神风起 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（侧重问题性质分析与规律推导）

🗣️ **初步分析**：  
这道题的核心不是用复杂算法，而是**像“侦探破案”一样分析连边规则的隐藏规律**——就像玩“找不同”游戏，我们需要先看清每个弹幕（节点）的“性格”（连边规则），再找到它们能“和平共存”的最大组合。  

具体来说：  
- **1号弹幕**（绿色）：性格最温和，不跟任何弹幕“吵架”（不连边），所以所有1号弹幕都能加入“不冲突集合”（最大独立集）——这是我们的“基础班底”。  
- **2号弹幕**（蓝色）：性格有点“霸道”，会跟左边所有弹幕“吵架”（连左边所有点）。如果要选它，必须把它放在**所有1号弹幕的左边**——这样它只会跟左边没有1号的弹幕吵架，不会影响我们的“基础班底”。  
- **3号弹幕**（红色）：性格相反，会跟右边所有弹幕“吵架”（连右边所有点）。同理，要选它必须放在**所有1号弹幕的右边**。  

更关键的规律是：**2号和3号弹幕最多各选1个**——选两个2号会互相吵架，选两个3号也会，只有“左边的2+右边的3”能和平共存（因为它们的“吵架范围”不重叠）。  

**可视化设计思路**：  
我们用8位像素风（像FC游戏）展示弹幕序列，用颜色区分类型（绿=1、蓝=2、红=3）。动画会先**高亮所有绿色块**（提示“这些可以全选！”），再用箭头扫描左边找蓝色块、右边找红色块，选中时伴随“叮”“啪”的音效强化记忆。最后显示总数量，像“通关”一样有成就感~


## 2. 精选优质题解参考

为了帮大家快速掌握关键，我筛选了3份**思路清晰、代码简洁、考虑全面**的优质题解：


### 题解一：chen_zhe（逻辑严谨，覆盖所有情况）  
* **点评**：这份题解像“数学证明”一样严谨！作者把问题拆成4种情况逐一计算：①全选1；②选左边的2+右边的1；③选右边的3+左边的1；④选左边的2+右边的3+中间的1。还特意举了“3 2”的反例，加了“r>l”的判断——完美避免踩坑！代码直接计算四种情况的最大值，没有多余步骤，非常适合初学者模仿。


### 题解二：Keids（思路秒懂，代码极简）  
* **点评**：这题解的思路太“绝”了！作者一眼看穿“1的弹幕可以全选”，然后只需要找**第一个1左边的2**和**最后一个1右边的3**——就像“给基础班底加两个‘保镖’”，保镖站在班底外面，不会干扰内部。代码只有几十行，用l和r记录1的位置，扫描两边的2和3，加起来就是答案。这种“抓重点”的能力，是解决复杂问题的关键！


### 题解三：Untitled10032（考虑极端，细节到位）  
* **点评**：这份题解最“贴心”！不仅处理了有1的常规情况，还特别照顾了“没有1”的极端情况：如果没有1，就找“2后面有没有3”——有就选两个（2和3），没有就选一个。代码里的`has2`和`has3_after2`变量设计得很巧妙，用`cnt1==0`触发特判，逻辑丝毫不乱。这种“覆盖所有情况”的习惯，能帮你避免90%的bug！


## 3. 核心难点辨析与解题策略

这道题的“坑”主要在**三个关键问题**，解决了它们，问题就迎刃而解：


### 关键点1：为什么1的弹幕可以全选？  
**分析**：1的弹幕不连任何边，就像“不会吵架的小朋友”，放在一起绝对安全。全选1是最优解的“基础”——不管加不加2或3，都要先保证1的数量最多。  
💡 **学习笔记**：先找“绝对安全”的元素，是解决很多问题的第一步！


### 关键点2：为什么2和3最多各选1个，且要放在1的两端？  
**分析**：如果选一个2在1的中间，它会跟左边的1“吵架”（连边），导致那些1不能选——这会让总数量减少。而选在1的左边，它只会跟左边没有1的弹幕吵架，不会影响“基础班底”。同理，3选在1的右边，也不会影响基础班底。  
💡 **学习笔记**：选元素时，要尽量“不破坏已有的最优解”！


### 关键点3：没有1的情况怎么办？  
**分析**：如果没有1，就只能选2和3——但必须是“2在3左边”（否则它们会吵架吗？不，2连左边，3连右边，所以2在3左边时，它们之间没有边，可以共存）。如果找不到这样的组合，就只能选一个。  
💡 **学习笔记**：极端情况要单独处理，否则容易得到错误结果！


### ✨ 解题技巧总结  
- **技巧A**：分析问题规则，找“不变量”（比如1的弹幕可以全选）。  
- **技巧B**：抓关键位置（比如1的两端的2和3），避免无效选择。  
- **技巧C**：举反例验证思路（比如“3 2”的情况，防止选两个点）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了chen_zhe、Keids和Untitled10032的思路，覆盖所有情况，逻辑清晰。  
* **完整核心代码**：  
```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    cin >> n;
    int a[100005];
    int cnt1 = 0, first1 = n + 1, last1 = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        if (a[i] == 1) {
            cnt1++;
            if (first1 == n + 1) first1 = i; // 第一个1的位置
            last1 = i;                       // 最后一个1的位置
        }
    }

    bool has_left2 = false, has_right3 = false;
    // 找第一个1左边的2
    for (int i = 1; i < first1; ++i) {
        if (a[i] == 2) {
            has_left2 = true;
            break;
        }
    }
    // 找最后一个1右边的3
    for (int i = last1 + 1; i <= n; ++i) {
        if (a[i] == 3) {
            has_right3 = true;
            break;
        }
    }

    int ans = cnt1 + has_left2 + has_right3;
    // 处理没有1的情况
    if (cnt1 == 0) {
        bool has2 = false, has3_after2 = false;
        for (int i = 1; i <= n; ++i) {
            if (a[i] == 2) has2 = true;
            if (has2 && a[i] == 3) { // 2后面有3
                has3_after2 = true;
                break;
            }
        }
        ans = has3_after2 ? 2 : 1;
    }

    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
1. **统计1的信息**：cnt1（1的数量）、first1（第一个1的位置）、last1（最后一个1的位置）。  
2. **找两端的2和3**：检查first1左边有没有2（has_left2）、last1右边有没有3（has_right3）。  
3. **计算初始答案**：cnt1加上两个布尔值（true算1，false算0）。  
4. **处理极端情况**：没有1时，找“2后面有没有3”，有就输出2，否则输出1。


### 优质题解核心片段赏析

#### 题解一：chen_zhe（枚举四种情况）  
* **亮点**：逻辑严谨，覆盖所有可能。  
* **核心代码片段**：  
```cpp
int l = 0, r = 0;
// 找第一个2的位置l
for (int i = 1; i <= n; ++i) if (a[i] == 2) { l = i; break; }
// 找最后一个3的位置r
for (int i = n; i >= 1; --i) if (a[i] == 3) { r = i; break; }

int ans = 0;
// 情况1：全选1
int ret = 0;
for (int i = 1; i <= n; ++i) ret += (a[i] == 1);
ans = max(ans, ret);

// 情况2：选第一个2 + 右边的1
if (l) {
    ret = 1;
    for (int i = l + 1; i <= n; ++i) ret += (a[i] == 1);
    ans = max(ans, ret);
}

// 情况3：选最后一个3 + 左边的1
if (r) {
    ret = 1;
    for (int i = 1; i <= r - 1; ++i) ret += (a[i] == 1);
    ans = max(ans, ret);
}

// 情况4：选第一个2 + 最后一个3 + 中间的1（必须r>l）
if (l && r && r > l) {
    ret = 2;
    for (int i = l + 1; i <= r - 1; ++i) ret += (a[i] == 1);
    ans = max(ans, ret);
}
```
* **代码解读**：  
作者把所有可能的最优情况列出来，逐一计算，然后取最大值。比如情况4的`r>l`判断，完美避免了“3 2”这样的陷阱——如果2在3右边，选两个会冲突，所以不能算。  
💡 **学习笔记**：枚举所有可能的最优情况，是解决“找最大值”问题的常用方法！


#### 题解二：Keids（抓关键位置）  
* **亮点**：思路秒懂，代码极简。  
* **核心代码片段**：  
```cpp
int l = 0, r = 0, sum = 0;
for (int i = 1; i <= n; ++i) {
    scanf("%d", &a[i]);
    if (a[i] == 1) {
        sum++;          // 统计1的数量
        if (!l) l = i; // 第一个1的位置
        if (i > r) r = i; // 最后一个1的位置
    }
}

// 找第一个1左边的2
for (int i = 1; i <= l; ++i) if (a[i] == 2) { sum++; break; }
// 找最后一个1右边的3
for (int i = r; i <= n; ++i) if (a[i] == 3) { sum++; break; }

printf("%d", sum);
```
* **代码解读**：  
作者直接抓住“1的两端”这个关键——第一个1左边的2不会影响右边的1，最后一个1右边的3不会影响左边的1。代码里的`l`和`r`像“边界线”，只要在边界外找2和3，就能保证不冲突。  
💡 **学习笔记**：复杂问题往往有“关键位置”，找到它就能简化成简单问题！


#### 题解三：Untitled10032（处理极端情况）  
* **亮点**：考虑全面，细节到位。  
* **核心代码片段**：  
```cpp
if (cnt1 == 0) { // 没有1的情况
    int i;
    // 找第一个2的位置
    for (i = 1; a[i] != 2 && i <= n; i++);
    // 找2后面的3
    for (; a[i] != 3 && i <= n; i++);
    // 有3就输出2，否则输出1
    if (i == n + 1) putchar('1');
    else putchar('2');
    return 0;
}
```
* **代码解读**：  
当没有1时，作者用两个循环找“2后面有没有3”——如果有，说明可以选两个点（2和3）；如果没有，只能选一个点。这种“分情况讨论”的方法，能帮你解决所有极端情况。  
💡 **学习笔记**：极端情况要单独处理，否则容易得到错误结果！


## 5. 算法可视化：像素动画演示

### 动画演示主题：像素小灵梦找“不冲突的弹幕”  
### 核心演示内容：  
用8位像素风展示序列，逐步选中所有1的块，再找左边的2和右边的3，最后显示总数量。像玩游戏一样记住规律！


### 设计思路简述  
采用FC游戏的像素风格（比如《超级马里奥》的画面），用颜色和音效强化记忆：  
- **绿色**：1号弹幕（安全，全选），选的时候“叮”一声。  
- **蓝色**：2号弹幕（左边不能有其他点），选的时候“啪”一声。  
- **红色**：3号弹幕（右边不能有其他点），选的时候“啪”一声。  
- **胜利音效**：完成时播放“小灵梦的胜利台词”，像通关一样有成就感！


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕显示16x16的像素网格，每个弹幕是3x3的像素块（绿=1、蓝=2、红=3）。  
   - 下方控制面板有“单步”“自动”“重置”按钮，速度滑块（从“慢”到“快”）。  
   - 播放8位风格的背景音乐（比如《Bad Apple》的像素版）。  

2. **算法启动**：  
   - **步骤1**：所有绿色块开始闪烁，伴随“叮”的音效，提示“这些可以全选！”。  
   - **步骤2**：左边出现一个像素箭头，从左到右扫描，找到第一个绿色块左边的蓝色块——如果有，蓝色块变成亮蓝色，伴随“啪”的音效，提示“选这个2！”。  
   - **步骤3**：右边出现一个像素箭头，从右到左扫描，找到最后一个绿色块右边的红色块——如果有，红色块变成亮红色，伴随“啪”的音效，提示“选这个3！”。  

3. **结果展示**：  
   - 屏幕中央显示“总数量：X”（X是答案），同时弹出像素小灵梦的头像，旁边写着“你找到啦！”。  
   - 如果没有1，箭头会先找蓝色块，再找后面的红色块——找到就显示“2”，没找到就显示“1”。  

4. **交互控制**：  
   - **单步**：点击一次，执行一步（选1→找2→找3）。  
   - **自动**：按速度滑块的设定自动播放，适合快速看流程。  
   - **重置**：回到初始状态，重新开始，适合反复练习。  


### 技术实现考量  
- **轻量化**：用HTML5 Canvas画像素块，JavaScript处理交互，所有资源打包成一个HTML文件，双击就能运行。  
- **音效**：用Web Audio API播放8位音频文件（比如`ding.wav`、`pop.wav`、`win.wav`），强化记忆。  


## 6. 拓展练习与相似问题

### 通用思路迁移  
这道题的核心是**分析问题规则，找到最优解的结构**，类似的问题还有：  
- **问题1**：给定序列，每个元素是0或1，0的点连左边所有点，1的点连右边所有点，求最大独立集。  
- **问题2**：给定字符串，每个字符是A或B，A不能和左边的A相邻，B不能和右边的B相邻，求最长不冲突子串。  


### 洛谷推荐练习  
1. **P1164 小A点菜**（性质分析）  
   推荐理由：这题需要分析“点菜”的组合规律，和我们今天的“找不冲突弹幕”一样，都是**找最优解的结构**，能锻炼你的“抓规律”能力！  
2. **P2241 统计方形**（数学推导）  
   推荐理由：这题需要推导矩形和正方形的数量公式，和我们今天的“性质分析”思路一致——复杂问题用数学规律简化！  
3. **P1090 合并果子**（贪心）  
   推荐理由：这题是经典的贪心问题，需要每次选最小的两堆合并，和我们今天的“选最优位置的2和3”一样，都是**局部最优导致全局最优**，能帮你巩固贪心思维！  
4. **P1598 垂直柱状图**（编程技巧）  
   推荐理由：这题需要统计字符出现次数，然后输出柱状图，和我们今天的“统计1的数量”一样，都是**基础但实用的编程技巧**，能锻炼你的代码实现能力！  


## 7. 学习心得与经验分享

### 参考经验（来自chen_zhe）  
“我在解决这个问题时，最初没考虑到‘3 2’这样的陷阱数据，后来通过举反例才发现要加‘r>l’的判断。”  
**点评**：举反例是验证思路正确性的好方法！比如你想“选两个点（2和3）”，就要想有没有情况选不了（比如“3 2”），这时候需要加判断。以后写代码时，也要多举几个测试用例，避免踩坑！


### 参考经验（来自Keids）  
“复杂问题往往有最简单的解法，就看你能不能找到关键规律。”  
**点评**：太对了！这道题看起来是图论的最大独立集，但其实只要找到1的点可以全选，2和3的点选两端，就能解决。以后遇到难题时，先别急着写代码，先仔细分析问题的规则，说不定能找到“秒解”的规律！


## 结语  
本次分析就到这里啦！这道题告诉我们：**不要被问题的“外表”吓到**——看起来是图论的最大独立集，其实只要分析连边规则，找到规律，就能用几行代码解决。记住，编程的本质是“解决问题”，而不是“写复杂的代码”！下次遇到类似的题，不妨先问自己：“有没有隐藏的规律？”，说不定答案就在眼前~  

加油，你离“编程小能手”又近了一步！💪

---
处理用时：174.43秒
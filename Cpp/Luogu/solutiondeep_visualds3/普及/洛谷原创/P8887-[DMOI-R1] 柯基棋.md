# 题目信息

# [DMOI-R1] 柯基棋

## 题目背景

小 A 和小 B 都是爱狗人士，且绝顶聪明，尤其喜爱柯基，于是他们发明了“柯基棋”。

## 题目描述

小 A 和小 B 在一个 $n \times n$ 的棋盘内轮流下棋。小 A 先手，小 B 后手。设当前有一只“柯基”被下在了棋盘的 $(x,y)$ 处，那么棋盘内的 $(x-1,y-1)$，$(x-1,y+1)$，$(x+1,y-1)$，$(x+1,y+1)$ 处都会变为这只“柯基”的地盘，也就不能再放一只“柯基”。当一个人不能再放下一只“柯基”时，他就输了。

可惜，小 C 却不怎么喜欢柯基，所以他很反对小 A 和小 B 玩“柯基”棋，于是他非常喜欢捣乱棋局。当小 A 和小 B 一共下了 $x_i$ 只“柯基”时，小 C 就会以当前 $w \times w$ 棋盘的中心为中心，扩大棋盘为 $(w+2) \times (w+2)$，他一共会捣乱 $q$ 次。

而你的任务是要判断这局棋是小 A 赢还是小 B 赢，如果小 A  赢，输出 `A won`，否则输出 `B won`。

由于他们两个人比较贪玩，所以他们一共会玩 $T$ 局。

**注意**：

1. 当小 A 和小 B 已经将原来的棋盘下到不能再下时，他们会直接跳转到小 C 下一次的捣乱（如果有）。

2. 小 A 和小 B 知道小 C 会捣乱，且会按照自己的最优策略走。

由于数据过大，$x_i$ 由数据随机生成器给出。

## 说明/提示

### 随机数据生成器

每一轮游戏的 $x_i$ 由下方的生成器给出：

```cpp
unsigned long long x[10000005];
unsigned long long xor_shift(unsigned long long &seed){
  return seed^=seed>>12, seed^=seed<<25, seed^=seed>>27, seed*0x2545F4914F6CDD1D;
}
int main(){
  //your code here
  int n,q;
  unsigned long long seed;
  cin>>n>>q>>seed;
  for(int i=1;i<=q;i++){
	x[i]=x[i-1]+((xor_shift(seed)%(unsigned long long)(2*2)+1))*2;
  }
  //your code here
  return 0;
}
```

### 样例解释

对于第一局游戏，$x_i$ 数组如下：`6 8 16 18 22`。

对于第二局游戏，$x_i$ 数组如下：`8 14 16 24 32 36 38 40`。

对于第三局游戏，$x_i$ 数组如下：`4 8 10 16`。

### 数据范围

对于 $20\%$ 的数据，$n,q\leq100$。

对于 $50\%$ 的数据，$n,q\leq10000$。

对于 $100\%$ 的数据，$1 \le T \le 10,2\leq n,q,\sum q \leq 10^7$，$x_i \equiv 0 \pmod 2\ (i\in[1,q]),0 \le seed \le 10^7$。


## 样例 #1

### 输入

```
3
2 5 493
3 8 3219
8 4 1294```

### 输出

```
B won
A won
B won```

# AI分析结果

---
# 💡 Kay的C++算法解析：柯基棋 深入学习指南 💡

<introduction>
今天我们来一起分析「柯基棋」这道有趣的C++编程题。这道题看似是复杂的博弈游戏，实则藏着**数学对称策略**的小秘密。跟着Kay一起拆解问题，你会发现——原来“赢”的关键，早在棋盘的“形状”里写好了！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学`（博弈论中的对称策略应用）

🗣️ **初步分析**：
解决“柯基棋”的关键，就像**两个人分一块对称的蛋糕**——只要蛋糕是对称的，后手总能找到和先手对应的位置，保证自己有蛋糕吃。在本题中，`数学`的作用是通过**棋盘奇偶性**和**对称策略**，直接判断胜负：
- 当棋盘边长是**奇数**时（比如3×3），先手（小A）可以先下在**中心**，之后每一步都下在后手的“对称点”（中心对称），这样小A永远有位置可下，最后一步一定是小A下的，A赢；
- 当棋盘边长是**偶数**时（比如2×2），棋盘没有“中心”，后手（小B）可以每一步都下在先手的“对称点”（轴对称），这样小B永远有位置可下，最后一步一定是小B下的，B赢。

题解的核心思路高度一致：**只需要判断初始棋盘的奇偶性**！因为小C的“捣乱”（扩大棋盘）只会让边长增加2（奇偶性不变），且`x_i`是偶数（不改变先后手顺序），所以胜负从一开始就定了。

核心难点是**理解“对称策略”为什么有效**——就像柯基的“地盘”是四个斜方向，对称位置的柯基永远不会互相干扰。可视化设计时，我们会用**像素棋盘**展示这个过程：红色块代表A，蓝色块代表B，每一步都高亮“对称点”，用“叮”的音效强化“下子”操作，帮你直观看到“对称策略”的魔力。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、启发价值三个方面，为你筛选了3份评分≥4星的优质题解：
</eval_intro>

**题解一：(来源：Vct14)**
* **点评**：这份题解是“对称策略”的“说明书”！作者用两张图示直观展示了奇数/偶数棋盘的对称逻辑——奇数棋盘的中心对称、偶数棋盘的轴对称，把抽象的“策略”变成了看得见的“位置对应”。代码更是简洁到极致：直接判断`n%2`，一句话定胜负。无论是理解思路还是写代码，这份题解都是“天花板”级别的参考。

**题解二：(来源：yitian_)**
* **点评**：这是一份“极简主义”的题解！作者没有多余的解释，直接抓住问题的“核心”——`n`的奇偶性。代码里`n%2==0`的判断干净利落，变量命名（`n`代表棋盘边长，`p`代表`q`）清晰易懂，适合快速模仿。如果你想写“一眼就能看懂”的代码，这份题解是绝佳模板。

**题解三：(来源：GoodLuckCat)**
* **点评**：作者用“圆桌上放硬币”的类比，把“对称策略”讲活了！就像先手放中心硬币，后手放对称点，柯基棋的逻辑和这个游戏一模一样。更贴心的是，作者还解释了“柯基地盘”的形状——四个斜方向的白色块，让你明白“对称位置不会互相干扰”的原因。这份题解能帮你**从“记住结论”变成“理解结论”**。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常问的三个“为什么”，Kay帮你一一拆解：
</difficulty_intro>

1.  **难点1：为什么想到用“对称策略”？**
    * **分析**：博弈问题的核心是“找对应关系”——如果先手能“控制”一个位置，后手能不能找到“对应的位置”？就像分蛋糕，只要蛋糕对称，后手总能“复制”先手的操作。柯基棋的“地盘”是斜向的，对称位置的柯基永远不会互相干扰，所以“对称策略”完全可行。
    * 💡 **学习笔记**：遇到博弈题，先想“有没有对称的位置”——这是博弈论的经典技巧！

2.  **难点2：小C的“捣乱”为什么不影响结果？**
    * **分析**：小C每次把棋盘扩大2（比如2×2→4×4→6×6），**奇偶性不变**；`x_i`是偶数（比如从0→6→8），意味着“下了偶数步”，**先后手顺序不变**。所以不管小C怎么捣乱，“奇数A赢、偶数B赢”的结论永远成立。
    * 💡 **学习笔记**：遇到“动态变化”的问题，先看“什么不变”——不变的性质，往往是解题的钥匙！

3.  **难点3：如何验证“奇偶性”的作用？**
    * **分析**：拿例子试！比如3×3棋盘（奇数）：A下中心，B下(1,1)，A就下(3,3)；B下(2,1)，A下(2,3)……最后B没位置了，A赢。再比如2×2棋盘（偶数）：A下(1,1)，B下(1,2)；A下(2,1)，B下(2,2)……最后A没位置了，B赢。
    * 💡 **学习笔记**：抽象的结论，用“小例子”验证——这是学数学和编程的“万能工具”！

### ✨ 解题技巧总结
- **技巧1：抓不变量**：动态问题中，“不变的性质”（比如奇偶性）往往是突破口；
- **技巧2：用类比**：把陌生的“柯基棋”变成熟悉的“分蛋糕”“放硬币”，快速理解策略；
- **技巧3：极简代码**：能一句话解决的问题，不要写十句——比如`n%2`直接判断胜负，比复杂的循环更高效。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份“通用核心代码”——它综合了所有优质题解的思路，是解决本题的“标准模板”：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码是“柯基棋”的“最简解法”，直接读取输入、判断奇偶性、输出结果，适合所有情况。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr); // 加速输入输出，处理大数据更快
        
        int T;
        cin >> T;
        while (T--) {
            int n, q, seed;
            cin >> n >> q >> seed; // 注意：q和seed必须读，但不用处理！
            cout << (n % 2 ? "A won" : "B won") << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：1. 读取测试用例数`T`；2. 循环读取每组数据的`n`（棋盘边长）、`q`（捣乱次数）、`seed`（随机种子）；3. 用**三目运算符**`n%2 ? "A won" : "B won"`直接判断胜负——奇数输出A，偶数输出B。关键技巧是**忽略不需要的变量**（`q`和`seed`），只处理核心数据`n`。

---
<code_intro_selected>
接下来，我们看优质题解中的“点睛之笔”：
</code_intro_selected>

**题解一：(来源：Vct14)**
* **亮点**：用“图示+代码”完美结合，把“对称策略”变成“可视化结论”。
* **核心代码片段**：
    ```cpp
    if(n%2) cout<<"A won";
    else cout<<"B won";
    ```
* **代码解读**：
    > 这两行代码是题解的“灵魂”！`n%2`判断棋盘奇偶性——奇数为`true`（输出A），偶数为`false`（输出B）。为什么能这么写？因为所有的“博弈策略”“动态变化”都被**浓缩成了一个数学判断**。这就是“抓住问题本质”的力量！
* 💡 **学习笔记**：不要被“捣乱”“x_i”这些干扰项迷惑——问题的核心，往往藏在最基础的“变量”里（比如本题的`n`）。

**题解二：(来源：GoodLuckCat)**
* **亮点**：用“圆桌上放硬币”的类比，让代码有了“逻辑支撑”。
* **核心代码片段**：
    ```cpp
    if(n%2)cout<<'A';
    else cout<<'B';
    cout<<" won\n";
    ```
* **代码解读**：
    > 作者把“判断”和“输出”分开写，更清晰——先决定“谁赢”（A或B），再输出“won”。这种写法的好处是**容易扩展**（比如以后要输出“赢了！”，只需要改后半部分）。更重要的是，作者用“圆桌上放硬币”的例子，让你明白：这行代码不是“魔法”，而是“对称策略”的必然结果。
* 💡 **学习笔记**：写代码前，先想“为什么要这么写”——懂逻辑的代码，才是“活”的代码。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让“对称策略”更直观，Kay设计了一个**8位像素风的柯基棋动画**——就像小时候玩的FC游戏，用像素块、音效和“过关”感，帮你“亲眼看到”算法的过程！
</visualization_intro>

  * **动画演示主题**：`像素柯基的对称对战`
  * **核心演示内容**：展示奇数/偶数棋盘的“对称下子”过程——红色像素块代表A，蓝色代表B，每一步都高亮“对称点”，用音效强化关键操作。
  * **设计思路简述**：8位像素风是为了**营造轻松复古的氛围**，让你像玩游戏一样学算法；“叮”的音效在“下子”时响起，帮你记住“对称点”的位置；每完成一次“对称下子”，屏幕会闪一下“小星星”——就像游戏里的“得分提示”，增加成就感！

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：
        * 屏幕显示**8位像素棋盘**（比如3×3或2×2），用不同颜色标记“空地”（浅灰色）、“中心”（黄色）、“A的子”（红色）、“B的子”（蓝色）；
        * 下方有**控制面板**：「开始/暂停」「单步执行」「重置」按钮，以及「速度滑块」（从“慢”到“快”）；
        * 背景播放**8位风格的《卡农》**——轻松的旋律让你更专注。
    2.  **算法启动**：
        * 若棋盘是奇数（比如3×3）：红色块“滑入”中心（黄色位置），伴随“叮”的音效——这是A的第一步；
        * 若棋盘是偶数（比如2×2）：红色块“随机”出现在某个位置，等待B的回应。
    3.  **核心步骤演示**：
        * **对称下子**：B下一个蓝色块后，红色块立刻“跳”到它的对称点（中心对称或轴对称），伴随“叮”的音效；
        * **状态高亮**：当前下子的位置用“闪烁”效果标记，对称点用“箭头”指向——你能清楚看到“谁在对应谁”；
        * **胜负判定**：当一方无法下子时，屏幕会弹出**像素化的胜利提示**（比如“A赢啦！”或“B赢啦！”），伴随上扬的“胜利音效”；
    4.  **交互设计**：
        * 「单步执行」：点击一次，走一步——适合仔细看“对称点”的位置；
        * 「自动播放」：用滑块调整速度（比如“慢”是1秒一步，“快”是0.2秒一步）——适合看完整的对战流程；
        * 「重置」：一键回到初始状态——可以反复看不同棋盘的情况。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
“对称策略”和“奇偶性判断”是博弈论的经典技巧，能解决很多类似问题。以下是3道洛谷的练习题目，帮你巩固所学：
</similar_problems_intro>

  * **通用思路迁移**：
    无论是“柯基棋”“分蛋糕”还是“放硬币”，核心都是**找“一一对应”的位置**——只要能保证“对方有位置，我就有位置”，就能赢！

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1290** - 欧几里得的游戏
        * 🗣️ **推荐理由**：这道题用“取石子”的形式，考察“奇偶性”和“先手策略”——和柯基棋的“对称策略”异曲同工，能帮你巩固“找不变量”的技巧。
    2.  **洛谷 P2148** - [SDOI2009]E&D
        * 🗣️ **推荐理由**：这道题是“组合博弈”的进阶题，需要用“SG函数”分析，但核心还是“找对称位置”——能帮你拓展“博弈策略”的应用场景。
    3.  **洛谷 P4136** - 谁能赢呢？
        * 🗣️ **推荐理由**：这道题是“棋盘博弈”的简化版——两个人在棋盘上走格子，谁走不了谁输。解法同样是“判断棋盘的奇偶性”——和柯基棋的思路完全一致，能帮你验证“对称策略”的通用性。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解里藏着作者的“解题小秘诀”，Kay帮你摘出来：
</insights_intro>

> **参考经验 (来自 GoodLuckCat)**：“我一开始也想复杂了，后来想到‘圆桌上放硬币’的游戏——先手放中心，后手放对称点，柯基棋的逻辑不就是这个吗？”
>
> **点评**：这位作者的经验太宝贵了！遇到陌生问题时，**联想熟悉的模型**（比如“放硬币”），能快速找到解题思路。就像柯基棋，看似是“新游戏”，实则是“老策略”的变形——这就是“举一反三”的能力！

> **参考经验 (来自 Melo_DDD)**：“看到棋盘，先想‘中心点’——这是博弈题的‘万能钥匙’！”
>
> **点评**：这句话是“解题直觉”的总结！棋盘类问题的核心，往往是“对称中心”或“对称轴”——抓住这个点，问题就会变得简单。


<conclusion>
本次关于“柯基棋”的分析就到这里啦！这道题的关键不是“写复杂的代码”，而是“发现棋盘的数学性质”——奇偶性和对称策略。记住：**复杂的问题，往往有简单的解法**，只要你愿意“透过现象看本质”！

下次遇到博弈题，不妨先问自己：“有没有对称的位置？”“什么性质是不变的？”——你会发现，“赢”的秘密，其实就藏在这些问题里。加油，Kay相信你能成为“博弈小能手”！💪
</conclusion>

---

---
处理用时：114.54秒
# 题目信息

# [YsOI2022] NOIp 和省选

## 题目背景

Ysuperman 为了检验他的教学水平，决定给幼儿园的小朋友们来两场摸底考试！

## 题目描述

其中一场考试有四道题目，满分 $400$；另一场考试有六道题目，满分 $600$。每个人每场考试得分都是一个 $0$ 到满分间的一个**非负整数**（可以为 $0$ 或者满分）。

有 $n$ 名同学参加了这两场考试，其中第 $i$ 名同学第一场得分 $a_i$，第二场得分 $b_i$，Ysuperman 通过以下规则计算第 $i$ 名同学的**标准得分** $c_i$：

1. 分别统计两场比赛的最高分 $A,B$，有 $A\ne 0$，$B\ne 0$。
2. 令 $c_i=1000(\frac{a_i}{A}+\frac{b_i}{B})$，其中 $c_i$ **四舍五入保留到整数**。

在算出了每位同学的标准得分后，Ysuperman 粗心地弄丢了每位同学的原始分，你能帮 TA 找到任意一组可能的原始分吗？

简单来说，已知 $n$ 和每位同学的**标准得分** $c_{1\sim n}$，Ysuperman 希望你找到一组合法的 $a_{1\sim n}$，$b_{1\sim n}$ 满足上述要求。

特别的，有个十分强的小朋友 Qiu 在两场考试中都拿到了**最高分**，也就是保证 $c_1=2000$。另外其他小朋友水平都差不多，所以保证有 $\forall i>1,c_i\in [10,1990]$。

## 说明/提示

样例一中构造的 $a,b$ 合法，理由如下：

两场比赛最高得分分别为 $233$ 和 $525$。

$1000\times (233\div 233 + 525\div 525)=2000$。

$1000\times (147\div 233 + 361\div 525) \approx 1318.520\approx 1319$。

$1000\times (200\div 233 + 324\div 525)\approx 1475.512\approx 1476$。

$1000\times (0\div 233 + 523\div 525)\approx 996.190\approx 996$。

前 $20\%$ 的数据保证 $n\le 20$。

另外 $20\%$ 的数据保证 $c_i$ 是 $10$ 的倍数。

另外 $20\%$ 的数据保证 $c_i$ 是 $5$ 的倍数。

另外 $20\%$ 的数据保证 $c_i$ 是 $2$ 的倍数。

对于 $100\%$ 的数据，满足 $1\le n\le 10^4$，$c_1=2000$，$\forall i>1,c_i\in[10,1990]$。

## 样例 #1

### 输入

```
4
2000
1319
1476
996```

### 输出

```
233 525
147 361
200 324
0 523```

## 样例 #2

### 输入

```
4
2000
1704
1658
1542```

### 输出

```
400 454
352 374
352 353
320 337```

# AI分析结果

# 💡 Kay的C++算法解析：[YsOI2022] NOIp 和省选 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（构造与不定方程求解）

🗣️ **初步分析**：  
数学构造的核心就像“给拼图找一个合适的起点”——通过选择特殊的参数（比如两场考试的最高分A和B），把复杂的分数方程转化为简单的整数方程，让后面的计算变得容易。在本题中，我们需要构造`a_i`和`b_i`满足`c_i=1000*(a_i/A + b_i/B)`，而关键技巧是让**A=200、B=500**（这样`1000/A=5`，`1000/B=2`），把方程简化为**5a_i + 2b_i = c_i**（就像用5元和2元的硬币凑出c元）。

大部分题解的思路都是这样：先固定A=200、B=500（对应c₁=2000），然后对每个c_i：  
1. 处理奇数：用一个5元硬币（`a_i+1`，`c_i-5`）；  
2. 用2元硬币凑剩下的部分（`b_i=c_i/2`）；  
3. 如果2元硬币太多（超过500个），用5元硬币替换（每2个5元换5个2元，这样`a_i+2`，`b_i-5`，总数不变）。  

核心难点是**确保a_i≤200、b_i≤500**，解决方案是通过“等价替换”调整硬币数量。  

**可视化设计思路**：用像素化的“金币凑数游戏”展示——c_i是需要凑的金币数，a_i是红色的“5金币硬币”，b_i是蓝色的“2金币硬币”。动画会高亮当前处理的步骤：比如c_i是奇数时，先“放”一个红色硬币；凑蓝色硬币时，显示蓝色硬币的数量，超过500时“拿走”5个蓝色硬币，“补”2个红色硬币。每一步都有“叮当”的音效，完成时播放“胜利”音效。


## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面，为大家筛选了以下评分较高的题解：
</eval_intro>

**题解一：（来源：untrigintillion）**  
* **点评**：这份题解的核心思路非常巧妙——通过选择A=200、B=500，直接把分数方程转化为整数方程`5a+2b=c`，避开了复杂的四舍五入。代码风格简洁，用“处理奇数→凑2→调整过量”的流程解决问题，是入门的好参考。

**题解二：（来源：zzyxl_qaq）**  
* **点评**：此题解不仅正确推导了方程`5a+2b=c`，还重点解决了“b超过500”的问题——通过循环用a替换b（每2个a换5个b），确保结果合法。代码逻辑严谨，变量命名清晰（比如`stu`数组存c_i），是一份非常实用的参考代码。

**题解三：（来源：sbno333）**  
* **点评**：这份题解详细解释了A=200、B=500的原因（系数5和2互质，覆盖大部分c_i），并给出了完整的处理流程：处理奇数→凑2→调整过量。代码中的循环“`while(b>500)`”逻辑清晰，能有效解决边界问题，是一份“知其然更知其所以然”的好题解。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们会遇到三个核心难点，下面结合优质题解的做法，为大家拆解解决方案：
</difficulty_intro>

1. **难点1：如何选择A和B简化方程？**  
   * **分析**：原方程是分数形式（`c_i=1000*(a_i/A + b_i/B)`），直接计算容易有精度问题。解决方案是选择A和B使得`1000/A`、`1000/B`都是整数（比如A=200→5，B=500→2），这样方程变成整数加法，计算更简单。  
   * 💡 **学习笔记**：构造题的关键是“找简化点”，把复杂问题转化为已知的简单问题。

2. **难点2：如何解`5a+2b=c`的不定方程？**  
   * **分析**：根据贝祖定理，5和2互质，所以大部分c都有解。处理方法是：如果c是奇数，先加一个5（`a+1`，`c-5`），再用2凑剩下的部分（`b=c/2`）。  
   * 💡 **学习笔记**：互质的系数能覆盖大部分数，处理奇数的小技巧是“先补一个大的系数”。

3. **难点3：如何保证`a≤200、b≤500`？**  
   * **分析**：如果b超过500，说明2元硬币太多，需要用5元硬币替换。每2个5元硬币（`a+2`）可以换5个2元硬币（`b-5`），这样总数不变，但b减少5，刚好符合上限要求。  
   * 💡 **学习笔记**：边界问题用“等价替换”解决，找到系数之间的兑换关系是关键。

### ✨ 解题技巧总结
- **技巧A：参数构造**：选择合适的A和B，将分数方程转化为整数方程，简化计算。  
- **技巧B：奇数处理**：用大系数补奇数，再用小系数凑剩余部分。  
- **技巧C：边界调整**：通过等价替换（比如2个5换5个2），确保变量不超过上限。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用的核心实现——固定A=200、B=500，解`5a+2b=c`，并处理边界问题：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了多个优质题解的思路，清晰展示了“处理奇数→凑2→调整边界”的流程。  
* **完整核心代码**：
  ```cpp
  #include <iostream>
  using namespace std;

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      int n;
      cin >> n;
      int c1;
      cin >> c1; // c1=2000
      cout << "200 500\n"; // 固定A=200, B=500
      n--;
      while (n--) {
          int c;
          cin >> c;
          int a = 0, b = 0;
          // 处理奇数：用一个5
          if (c % 2 == 1) {
              a = 1;
              c -= 5;
          }
          // 用2凑剩下的
          b = c / 2;
          // 调整b超过500的情况：每2个a换5个b
          while (b > 500) {
              b -= 5;
              a += 2;
          }
          cout << a << " " << b << "\n";
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  代码先输出A=200、B=500（对应c₁=2000），然后对每个c_i：  
  ① 如果是奇数，`a=1`、`c减5`；  
  ② 用`b=c/2`凑剩下的；  
  ③ 如果`b>500`，用`a`替换（每2个a换5个b）。最后输出a和b。

---

<code_intro_selected>
接下来剖析优质题解中的核心片段：
</code_intro_selected>

**题解二：（来源：zzyxl_qaq）**  
* **亮点**：重点处理了b超过500的情况，逻辑严谨。  
* **核心代码片段**：
  ```cpp
  if (stu[i]%2 == 1) {
      int a=1, b=(stu[i]-5)/2;
      while(b>500) { b-=5; a+=2; }
      printf("%d %d\n",a,b);
  } else {
      int a=0, b=stu[i]/2;
      while(b>500) { b-=5; a+=2; }
      printf("%d %d\n",a,b);
  }
  ```
* **代码解读**：  
  这段代码直接针对奇数和偶数分类处理：①奇数时`a=1`、`c减5`；②偶数时`a=0`；然后用`while`循环调整`b超过500`的情况（每2个a换5个b）。比如`b=505`，循环一次后`b=500`，`a=2`，刚好符合要求。  
* 💡 **学习笔记**：分类处理能让逻辑更清晰，`while`循环是处理边界问题的常用方法。

**题解三：（来源：sbno333）**  
* **亮点**：详细处理了b超过500的情况，包括余数调整。  
* **核心代码片段**：
  ```cpp
  if (a%2) { a-=5; x++; }
  y += a/2;
  if (y>500) {
      int z=(y-500)*2;
      x += z/5;
      y=500;
      z%=5;
      while(z%5) { y--; z+=2; }
      x += z/5;
  }
  ```
* **代码解读**：  
  这段代码先处理奇数，再凑2；如果`y超过500`，先计算需要替换的数量（`z=(y-500)*2`），用`x`替换`y`，然后处理余数（如果`z`不是5的倍数，就减少`y`、增加`z`，直到`z`是5的倍数）。比如`z=3`，循环一次后`y=499`，`z=5`，`x增加1`，刚好凑整。  
* 💡 **学习笔记**：处理余数的小技巧是“微调y，让z变成系数的倍数”。


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了更直观理解“金币凑数”的过程，我设计了一个**像素风的金币游戏**，用复古动画展示每一步的计算：
</visualization_intro>

  * **动画演示主题**：《像素金币店》——你是一名小店老板，需要用5元（红色）和2元（蓝色）的硬币凑出顾客的支付金额c_i。  
  * **核心演示内容**：展示如何用5元和2元硬币凑出c_i，以及如何调整硬币数量确保不超过上限（红色≤200，蓝色≤500）。  
  * **设计思路简述**：采用8位像素风（像FC游戏），用简单的色块和音效强化记忆——红色块代表5元，蓝色块代表2元，每一步操作都有“叮当”的音效，完成时播放“胜利”音乐。游戏化的设计能让你在“玩”中掌握算法。  

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：屏幕左侧是“顾客需求”（显示当前c_i），中间是“硬币堆”（红色块数量=a，蓝色块数量=b），右侧是“上限提示”（红色≤200，蓝色≤500）。背景播放轻松的8位音乐。  
    2. **处理奇数**：如果c_i是奇数，红色块闪烁并“跳”到硬币堆（a+1），同时c_i减少5（顾客需求数字变灰并减少），伴随“叮”的音效。  
    3. **凑蓝色硬币**：蓝色块依次“落”到硬币堆，直到数量等于c_i/2，每落一个蓝色块，播放“嗒”的音效。  
    4. **调整边界**：如果蓝色块超过500，超过的部分会“闪烁”，然后每5个蓝色块“消失”，同时2个红色块“出现”（a+2，b-5），直到蓝色块≤500，伴随“哗啦”的音效。  
    5. **完成提示**：硬币堆停止变化，屏幕显示“完成！a=X，b=Y”，播放胜利音效（比如FC游戏的“通关音”）。  
    6. **交互控制**：屏幕下方有“单步”“自动”“重置”按钮，以及速度滑块（从“慢”到“快”）。自动模式会像“AI店员”一样自动完成凑数过程。  

  * **技术实现**：用HTML+CSS+JavaScript（Canvas API）实现，所有资源打包成单文件，双击即可运行。比如：  
    - 用`ctx.fillStyle="red"`画红色块，`"blue"`画蓝色块；  
    - 用`Audio`对象播放音效（比如`new Audio("ding.wav").play()`）；  
    - 用`setInterval`控制动画速度。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“不定方程的构造与求解”，以下是相似问题和拓展练习：
</similar_problems_intro>

  * **通用思路迁移**：这种“构造参数→转化为整数方程→调整边界”的思路，适用于所有需要构造解的问题（比如“用两种砝码称出所有重量”“用两种邮票贴出所有邮资”）。  

  * **洛谷拓展练习**：
    1. **P1082 同余方程**：练习解线性同余方程，巩固贝祖定理的应用。  
    2. **P2669 金币**：用两种金币凑数，类似本题的“硬币问题”。  
    3. **P3951 小凯的疑惑**：找出不能用两种互质数凑出的最大数，深化对不定方程的理解。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我们可以学到一些宝贵的经验：
</insights_intro>

> **参考经验（来自zzyxl_qaq）**：“我最初的代码只得了4分，因为没处理b超过500的情况。后来通过循环调整a和b，才解决了边界问题。”  
> **点评**：边界问题是构造题的“坑”，一定要仔细考虑变量的上限。遇到错误时，不妨打印中间结果（比如b的值），看看哪里超过了上限。

> **参考经验（来自sbno333）**：“选择A=200、B=500是因为5和2互质，能覆盖大部分c_i。”  
> **点评**：互质的系数能让方程有更多解，这是构造参数的关键技巧。


<conclusion>
本次关于《[YsOI2022] NOIp 和省选》的分析就到这里。希望这份指南能帮助你掌握“构造不定方程”的技巧。记住：构造题的核心是“找简化点”，把复杂问题转化为简单的整数运算。多练习类似的问题，你会越来越熟练！💪
</conclusion>

---
处理用时：172.97秒
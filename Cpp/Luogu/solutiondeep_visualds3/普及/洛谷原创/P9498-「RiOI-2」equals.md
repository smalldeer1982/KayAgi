# 题目信息

# 「RiOI-2」equals

## 题目背景

在小树上坐落着一个幻想的城堡。这里是 E 国的领地，而小 E，则是 E 国之王。

为了打造一个完美的 E 国，他需要明辨是非，走向正义。

但是，他似乎有些太理想了。有时并没有一个完美的准则。是黑是白，谁能分辨？

## 题目描述

给定一棵 $n$ 个结点，以 $1$ 为根的树，定义一个结点的深度 $d_i$ 表示它到根结点的简单路径上的结点个数。

你需要给每个结点黑白染色，满足黑色结点的深度和等于白色结点的深度和。设 $c_i = \{0, 1\}$ 分别代表编号为 $i$ 的结点为黑色或白色，那么这即 $\displaystyle\sum_{c_i=0}d_i=\sum_{c_i=1}d_i$。

若无解，仅输出一行一个整数 $-1$。

## 说明/提示

### 样例解释

对于第一组数据，每个结点的深度分别是 $d=[1,2,2,3,3,3]$。黑色结点的深度和为 $d_1+d_5+d_6=1+3+3=7$，白色结点的深度和为 $d_2+d_3+d_4=2+2+3=7$。它们相等，所以样例输出是正确的。可能的正确输出包括但不限于样例输出、`0 1 1 0 0 1`，`1 0 0 1 0 1` 等。

### 数据规模与约定

**本题采用捆绑测试。**

| $\rm Subtask$ | 分值 | $n\le $ | 特殊性质 |
| :-----------: | :--: | :-----: | :------: |
| $0$ | $5$ | $20$ | / |
| $1$ | $15$ | $500$ | / |
| $2$ | $20$ | $5\times 10^3$ | / |
| $3$ | $10$ | / | $n$ 为偶数 |
| $4$ | $5$ | / | 树为菊花图（不保证根为菊花中心） |
| $5$ | $5$ | / | 树为一条链（不保证根为链的端点） |
| $6$ | $40$ | / | / |

斜杠表示这一栏无特殊限制。

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le u_i,v_i\le n$，输入数据构成一棵树。

## 样例 #1

### 输入

```
6
1 2
1 3
2 4
2 5
2 6```

### 输出

```
0 1 1 1 0 0```

## 样例 #2

### 输入

```
5
1 2
1 3
2 4
2 5```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：「RiOI-2」equals 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法（结合树的深度连续性）


🗣️ **初步分析**：  
贪心算法就像“买东西凑钱”——比如你要凑10块钱，先拿最大的面值（比如5块），不够再拿小的（2块、1块），这样最快凑够。本题中，我们需要把树的节点染成黑白两色，让两边的深度和相等。而树的深度有个特殊性质：**如果有深度为k的节点，那么1到k-1的深度一定都存在**（比如根是深度1，子节点深度2，孙子节点深度3，不可能跳过2直接有3）。这个性质就像“零钱罐里有1元、2元、3元……直到最大的面值”，所以我们可以用贪心策略，从大到小选节点，凑出总深度和的一半。

### 核心算法流程与可视化设计
1. **步骤1**：计算每个节点的深度（用DFS或BFS）。  
2. **步骤2**：判断总深度和是否为偶数（奇数直接无解）。  
3. **步骤3**：将节点按深度从大到小排序（记住原编号）。  
4. **步骤4**：贪心选择：从最大的深度开始，只要加入这个节点的深度后不超过总和的一半，就选它（染成黑色），直到凑够目标和。

**可视化设计思路**：  
用8位像素风展示树的节点（比如根节点是1x1的黄色方块，子节点是蓝色，深度越大颜色越深）。贪心选择时，选中的节点会“闪烁”并伴随“叮”的音效，未选中的节点保持原色。总深度和的一半会用像素数字显示在屏幕上方，每选一个节点，数字减少对应的深度。完成时，所有选中的节点会变成绿色，播放胜利音效（比如FC游戏的“通关声”）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮你快速理解核心逻辑：
</eval_intro>

### 题解一：作者TernaryTree（赞18）
* **点评**：这份题解的亮点是**利用树深度的连续性**，将节点排序后分组处理。对于偶数个节点，直接两两分组（相同深度的分一组，不同深度的调整偏移量）；对于奇数个节点，补一个虚拟节点再处理。思路严谨，代码简洁，特别是处理奇偶的方式很巧妙，适合理解贪心的底层逻辑。

### 题解二：作者ys_kylin__（赞9）
* **点评**：此题解的AC思路非常直观——**从大到小选节点**。先计算总深度和，排序后从最大的深度开始，能选就选，直到凑够一半。代码里用结构体保存深度和原编号，排序后遍历的逻辑很清晰，适合初学者模仿。

### 题解三：作者sane1981（赞5）
* **点评**：这份题解的贪心策略很“聪明”——**找第一个超过一半的位置，再调整**。比如先从小到大累加，找到第一个总和超过一半的位置，然后去掉一个刚好等于“超出部分”的节点。这种方法利用了深度的连续性（肯定能找到这个节点），代码高效，适合理解贪心的“调整”技巧。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于**利用树的深度连续性**和**贪心的正确应用**，以下是三个核心难点及解决方法：
</difficulty_intro>

### 1. 如何利用树深度的连续性？
* **难点**：为什么树的深度序列一定连续？比如有没有可能有深度3的节点，但没有深度2的？
* **解决**：树的结构决定了——每个节点的深度是父节点深度+1，所以深度3的节点的父节点一定是深度2，父节点的父节点是深度1。因此，深度序列必然包含1到最大深度的所有值。

### 2. 为什么贪心（从大到小选）能凑出目标和？
* **难点**：为什么从小到大选会出错？比如小的选多了，后面大的塞不进去。
* **解决**：从大到小选能保证“每一步都用最大的可能值”，剩下的“零钱”（小深度节点）一定能凑够。比如要凑10，先选5，再选3，剩下2选2，刚好；如果先选2+3=5，剩下5选5，也可以，但从大到小更快。

### 3. 如何避免数值溢出？
* **难点**：树的节点数到1e6，深度和可能到1e12，普通int存不下。
* **解决**：所有和、深度变量都用`long long`类型（比如C++中的`long long`，Java中的`long`）。


### ✨ 解题技巧总结
- **技巧A**：利用树的性质（深度连续性）简化问题——不是所有序列都能贪心，但树的深度可以！
- **技巧B**：排序时保存原编号——因为最后要输出每个节点的染色结果，不能丢了原位置。
- **技巧C**：优先处理大数——贪心的核心，避免“小的占满空间，大的塞不进”。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用的核心实现——综合了优质题解的贪心思路，代码简洁，适合快速理解：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了“从大到小贪心选择”的思路，结构清晰，处理了大数溢出问题。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long ll;
const int MAXN = 1e6 + 5;

struct Node {
    ll dep;  // 深度
    int id;   // 原节点编号
} nodes[MAXN];

vector<int> tree[MAXN];
ll sum = 0;  // 总深度和
ll target;   // 目标和（sum/2）
bool ans[MAXN] = {false};  // 染色结果：true为黑，false为白

// DFS计算深度
void dfs(int u, int fa) {
    nodes[u].dep = nodes[fa].dep + 1;
    sum += nodes[u].dep;
    for (int v : tree[u]) {
        if (v != fa) {
            dfs(v, u);
        }
    }
}

// 排序规则：深度从大到小
bool cmp(Node a, Node b) {
    return a.dep > b.dep;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    int n;
    cin >> n;
    for (int i = 1; i < n; ++i) {
        int u, v;
        cin >> u >> v;
        tree[u].push_back(v);
        tree[v].push_back(u);
    }
    
    // 初始化根节点（1号）的深度为1
    nodes[0].dep = 0;  // 父节点（虚拟）深度0
    dfs(1, 0);
    
    // 判断是否有解
    if (sum % 2 != 0) {
        cout << -1 << endl;
        return 0;
    }
    target = sum / 2;
    
    // 给每个节点记录原编号
    for (int i = 1; i <= n; ++i) {
        nodes[i].id = i;
    }
    // 按深度从大到小排序
    sort(nodes + 1, nodes + 1 + n, cmp);
    
    // 贪心选择节点
    ll current = 0;
    for (int i = 1; i <= n; ++i) {
        if (current + nodes[i].dep <= target) {
            current += nodes[i].dep;
            ans[nodes[i].id] = true;  // 染成黑色
        }
        if (current == target) {
            break;
        }
    }
    
    // 输出结果
    for (int i = 1; i <= n; ++i) {
        cout << (ans[i] ? 1 : 0) << " ";
    }
    cout << endl;
    
    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：读取树的结构（用邻接表存储）。  
  2. **计算深度**：用DFS遍历树，记录每个节点的深度和总深度和。  
  3. **判断无解**：总深度和为奇数直接输出-1。  
  4. **排序节点**：按深度从大到小排序（保存原编号）。  
  5. **贪心选择**：从大到小选节点，凑够目标和（sum/2）。  
  6. **输出结果**：按原节点顺序输出染色结果。


<code_intro_selected>
接下来看优质题解的核心片段，学习它们的巧妙之处：
</code_intro_selected>

### 题解一：作者TernaryTree（赞18）
* **亮点**：用“分组处理”应对奇偶节点，利用深度连续性简化贪心。
* **核心代码片段**：
```cpp
// 处理奇数个节点：补一个虚拟节点
if (n & 1) ++n, flag = true;
sort(dep + 1, dep + 1 + n);
for (int i = 1; i <= n; i += 2) {
    if (dep[i].fs == dep[i + 1].fs) {
        c[dep[i].sc] = 0;  // 相同深度的分两组
        c[dep[i + 1].sc] = 1;
    } else {
        c[dep[i].sc] = (cur == -1);  // 不同深度的调整偏移量
        c[dep[i + 1].sc] = !c[dep[i].sc];
        cur = (cur != 0) ? 0 : -1;
    }
}
```
* **代码解读**：  
  这段代码处理了**节点数奇偶**的问题——如果是奇数，补一个虚拟节点（不影响结果），然后两两分组。相同深度的节点直接分黑白（抵消深度和），不同深度的节点调整偏移量（保证总和平衡）。比如深度为3和2的节点，选3为黑、2为白，总和差1；下一组再反过来，差-1，最终总和为0。
* 💡 **学习笔记**：分组处理是贪心的“进阶技巧”，适合有规律的序列（比如连续深度）。


### 题解二：作者ys_kylin__（赞9）
* **亮点**：从大到小贪心，代码逻辑直观，容易模仿。
* **核心代码片段**：
```cpp
sort(d + 1, d + n + 1, cmp);  // 按深度从大到小排序
for (int i = n; i; i--) {
    if (sum2 + d[i].num < sum / 2) {
        sum2 += d[i].num;
        ans[d[i].id] = 1;  // 选这个节点
    } else {
        // 找刚好凑够的节点
        for (int j = i; j; j--) {
            if (sum2 + d[j].num == sum / 2) {
                ans[d[j].id] = 1;
                break;
            }
        }
        break;
    }
}
```
* **代码解读**：  
  这段代码的逻辑是“能选就选，不够再找”——先选大的节点，直到再选就超过目标和，然后从剩下的节点里找一个刚好凑够的。比如目标和是10，当前选了5+3=8，剩下2，就找一个深度为2的节点，刚好凑够10。
* 💡 **学习笔记**：贪心的关键是“优先选大的”，避免“小的占满空间”。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：像素树的“贪心凑数大挑战”
### 核心演示内容：展示贪心算法如何从大到小选节点，凑出目标和。


### 设计思路简述
用8位像素风（类似FC游戏《超级马里奥》）展示树的节点，深度越大颜色越深（比如深度1是黄色，深度2是蓝色，深度3是紫色）。贪心选择时，选中的节点会“闪烁”并伴随“叮”的音效，未选中的节点保持原色。目标和用像素数字显示在屏幕上方，每选一个节点，数字减少对应的深度。完成时，所有选中的节点变成绿色，播放胜利音效（“叮——当！”）。


### 动画帧步骤与交互关键点
1. **场景初始化**：  
   - 屏幕左侧显示像素树（根节点在顶部，子节点向下排列），右侧是控制面板（“开始/暂停”“单步”“重置”按钮，速度滑块）。  
   - 背景是复古的像素草地，播放8位风格的轻快BGM（比如《塞尔达传说》的初始洞穴音乐）。

2. **深度计算**：  
   - DFS遍历树时，每个节点的深度会“逐渐点亮”（从根到叶子，颜色从黄到紫），伴随“沙沙”的音效。

3. **贪心选择演示**：  
   - 节点按深度从大到小排序后，最大的节点（紫色）先“跳一下”，表示要被选择。  
   - 点击“单步”按钮，节点变成红色（选中），目标和数字减少对应的深度，伴随“叮”的音效。  
   - 继续单步，直到凑够目标和，所有选中的节点变成绿色，播放胜利音效。

4. **交互控制**：  
   - “自动播放”：算法自动执行，速度可调（滑块从“慢”到“快”）。  
   - “重置”：恢复初始状态，重新开始演示。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法和树的深度问题在OI中很常见，以下是几个相似的练习：
</similar_problems_intro>

### 通用思路迁移
本题的贪心思路可以用到**“有连续值域的01背包问题”**——比如要凑一个数，而物品的价值是连续的（1、2、3……），此时贪心比背包更高效。


### 练习推荐 (洛谷)
1. **洛谷 P1048 采药**（01背包）  
   🗣️ **推荐理由**：经典的01背包问题，练习“选择物品凑最大值”，和本题的“选择节点凑目标和”思路类似。
   
2. **洛谷 P2925 干草出售**（贪心）  
   🗣️ **推荐理由**：用贪心卖干草，优先卖贵的，练习“优先处理大数”的思路。
   
3. **洛谷 P1090 合并果子**（贪心）  
   🗣️ **推荐理由**：合并果子要选最小的两堆，练习“贪心的反向应用”（本题是选最大的，这里是选最小的）。


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自作者ys_kylin__)**：“我一开始用递归枚举所有可能（5pts的做法），但数据大了直接超时。后来想到树的深度是连续的，才用了贪心，一下子就过了！”  
> **点评**：这位作者的经验很真实——枚举法适合小数据，但大数据要找问题的“特殊性质”（比如树的深度连续性）。遇到超时问题时，先想“有没有更聪明的办法”，而不是“优化枚举”。


## 8. 总结

本次分析的“RiOI-2 equals”题，核心是**利用树的深度连续性，用贪心算法凑出目标和**。关键技巧是：  
1. 计算深度时用DFS/BFS，别忘开`long long`；  
2. 排序节点时保存原编号；  
3. 从大到小贪心选择，凑够目标和。

记住：贪心算法的关键是**问题有“可贪心的性质”**（比如本题的深度连续性），找到这个性质，问题就迎刃而解啦！💪


下次我们再一起分析更有趣的算法题，加油！😊

---
处理用时：81.54秒
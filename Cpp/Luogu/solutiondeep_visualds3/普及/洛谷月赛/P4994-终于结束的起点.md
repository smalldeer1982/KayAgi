# 题目信息

# 终于结束的起点

## 题目背景

> 终于结束的起点  
> 终于写下句点  
> 终于我们告别  
> 终于我们又回到原点  
> ……

一个个 OIer 的竞赛生涯总是从一场 NOIp 开始，大多也在一场 NOIp 中结束，好似一次次轮回在不断上演。  
如果这次 NOIp 是你的起点，那么祝你的 OI 生涯如同夏花般绚烂。  
如果这次 NOIp 是你的终点，那么祝你的 OI 回忆宛若繁星般璀璨。  
也许这是你最后一次在洛谷上打比赛，也许不是。  
不过，无论如何，祝你在一周后的比赛里，好运。

当然，这道题也和轮回有关系。

## 题目描述

广为人知的斐波拉契数列 $\mathrm{fib}(n)$ 是这么计算的

$$
\mathrm{fib}(n)=\begin{cases}
0,& n=0 \\
1,& n=1 \\
\mathrm{fib}(n-1) + \mathrm{fib}(n-2),& n>1
\end{cases}
$$

也就是 $0, 1, 1, 2, 3, 5, 8, 13 \cdots$，每一项都是前两项之和。

小 F 发现，如果把斐波拉契数列的每一项对任意大于 $1$ 的正整数 $M$ 取模的时候，数列都会产生循环。

当然，小 F 很快就明白了，因为 ($\mathrm{fib}(n - 1) \bmod M$) 和 ($\mathrm{fib}(n - 2) \bmod M)$ 最多只有 $M ^ 2$ 种取值，所以在 $M  ^ 2$ 次计算后一定出现过循环。

甚至更一般地，我们可以证明，无论取什么模数 $M$，最终模 $M$ 下的斐波拉契数列都会是 $0, 1, \cdots, 0, 1, \cdots$。

现在，给你一个模数 $M$，请你求出最小的 $n > 0$，使得 $\mathrm{fib}(n) \bmod M = 0, \mathrm{fib}(n + 1) \bmod M = 1$。

## 说明/提示

#### 样例 1 解释

斐波拉契数列为 $0, 1, 1, 2, 3, 5, 8, 13, 21, 34, \cdots$，在对 $2$ 取模后结果为 $0, 1, 1, 0, 1, 1, 0, 1, 1, 0, \cdots$。

我们可以发现，当 $n = 3$ 时，$f(n) \bmod 2= 0, f(n + 1) \bmod 2 = 1$，也就是我们要求的 $n$ 的最小值。

#### 数据范围

对于 $30\%$ 的数据，$M \leq 18$；

对于 $70\%$ 的数据，$M \leq 2018$；

对于 $100\%$ 的数据，$2 \leq M \leq 706150=\verb!0xAC666!$。

#### 提示

如果你还不知道什么是取模 $(\bmod)$，那我也很乐意告诉你，模运算是求整数除法得到的余数，也就是竖式除法最终「除不尽」的部分，也即
$$a \bmod M =k \iff a = bM + k\ (M > 0, 0 \leq k < M)$$
其中 $a, b, k$ 都是非负整数。

如果你使用 `C` / `C++`，你可以使用 `%` 来进行模运算。

如果你使用 `Pascal`，你可以使用 `mod` 来进行模运算。

## 样例 #1

### 输入

```
2```

### 输出

```
3```

## 样例 #2

### 输入

```
6```

### 输出

```
24```

# AI分析结果

---
# 💡 Kay的C++算法解析：终于结束的起点 深入学习指南 💡

<introduction>
  今天我们来一起分析「终于结束的起点」这道C++编程题。题目围绕斐波那契数列的**循环特性**展开，核心是找模M后的「回到原点」的最小步数——这其实就是著名的**皮萨诺周期**（Pisano Period）。本指南会帮你理清思路、掌握两种核心解法（暴力&数论），还能通过像素动画直观看到循环过程～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（斐波那契循环节·皮萨诺周期）

🗣️ **初步分析**：
> 解决这道题，关键要理解**皮萨诺周期**——斐波那契数列模M后，一定会重复「0,1」的初始状态，这个重复的最小长度就是我们要找的n。打个比方：斐波那契数列模M就像小朋友绕着环形跑道跑步，跑着跑着总会回到起点（0,1），我们要算「跑一圈的最短距离」。  
   - **题解思路对比**：大部分题解用两种方法——①**暴力模拟**（直接算斐波那契数，直到出现0 followed by 1）；②**数论分解**（把M拆成素数幂，算每个素数幂的周期，再取最小公倍数LCM）。  
   - **核心难点**：暴力法怕超时（循环多少次够？）、数论法怕定理记错（素数的周期怎么算？）。  
   - **解决方案**：暴力法利用「皮萨诺周期≤6M」的结论（比如M=2时循环3次，M=6时循环24次，都不超过6M）；数论法靠定理：素数p的周期是p-1或2(p+1)的因子，素数幂p^k的周期是p^(k-1)*π(p)（π(p)是p的周期）。  
   - **可视化设计思路**：用8位像素风展示斐波那契数模M的变化——比如用不同颜色的像素块代表每个fib(n)%M的值，每次计算后像素块变色，当出现「0（蓝）→1（红）」时，整个行闪烁并播放「叮～」的胜利音效，让你直观看到「回到原点」的瞬间！


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个角度，筛选了3份超实用的题解——暴力法简单好懂，数论法严谨高效，总有一款适合你～
</eval_intro>

**题解一：暴力模拟（来源：Catalan1906）**
* **点评**：这份题解的代码简直是「暴力美学」！用vector动态存储斐波那契数，每步取模避免溢出，循环条件直接判断「是否回到0,1」。思路直白到像「数手指」，代码里的`f.size()-2`更是巧妙——因为vector的索引对应斐波那契数的位置，直接算出结果。对于刚学的同学，这是最容易上手的版本！

**题解二：质因数分解法（来源：a13518354766）**
* **点评**：这题解把数论技巧用活了！先筛素数分解M，再算每个素数的周期（暴力算小素数的周期），然后用「素数幂的周期=素数周期×素数^(k-1)」的定理，最后取LCM得到答案。算法效率超高（比如M=706150时，分解后只需要算几个素数的周期），适合想深入数论的同学。

**题解三：数论+矩阵快速幂（来源：Cheng_yf）**
* **点评**：这份题解是「究极严谨版」！用矩阵快速幂验证素数的周期（因为斐波那契的递推可以用矩阵表示），还用到了「二次剩余」判断素数周期的可能因子。代码里的`check`函数用矩阵快速幂验证是否回到单位矩阵，逻辑严密到「连bug都找不到」。如果想彻底搞懂皮萨诺周期的数学原理，一定要看这份！


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到3个「卡壳点」。结合优质题解，我帮你把「难点→解法」理得明明白白：
</difficulty_intro>

1.  **关键点1：暴力循环多少次才不会超时？**
    * **分析**：直接循环到M²次肯定会超时，但根据数学结论，**皮萨诺周期≤6M**（比如M=2时是3，M=6时是24，都不超过6×M）。所以循环到6×M次就够了！
    * 💡 **学习笔记**：数学结论能帮暴力法「剪短循环」，别闷头写无限循环～

2.  **关键点2：如何避免斐波那契数溢出？**
    * **分析**：斐波那契数增长极快（第40项就超过1e8），但我们只需要模M后的值！所以每算一步都要取模（比如`fib[i] = (fib[i-1] + fib[i-2]) % M`），这样数值永远不会超过M。
    * 💡 **学习笔记**：模运算的「每步取模」是处理大数的神器！

3.  **关键点3：数论法中素数的周期怎么算？**
    * **分析**：对于素数p：①如果5是p的二次剩余（用欧拉准则判断：5^((p-1)/2) ≡1 mod p），则周期是p-1的因子；②否则是2(p+1)的因子。然后枚举这些因子，用矩阵快速幂验证哪个是最小周期。
    * 💡 **学习笔记**：数论定理是「捷径」，但要记准条件（比如5的二次剩余）！


### ✨ 解题技巧总结
<summary_best_practices>
通过本题，我总结了3个通用解题技巧，帮你举一反三：
</summary_best_practices>
-   **技巧1：先暴力再优化**：如果题目看起来有循环，先写暴力版验证思路，再用数学结论优化（比如本题用6M限制循环次数）。
-   **技巧2：模运算每步取模**：处理大数时，只要涉及模运算，每步都取模，避免溢出。
-   **技巧3：数论分解简化问题**：遇到合数的循环节问题，先分解成素数幂，算每个部分再合并（LCM），这是数论的「分治思想」！


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用暴力实现**——来自Catalan1906的代码，简洁到「一行循环解决问题」，适合新手入门！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码用vector动态存储斐波那契数，每步取模，直接判断「0→1」的组合，逻辑清晰到「一眼看懂」。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <vector>
    using namespace std;

    int main() {
        long long m;
        scanf("%lld", &m);
        vector<long long> f;
        f.push_back(0);  // fib(0) = 0
        f.push_back(1);  // fib(1) = 1
        // 循环直到出现 f[n] = 0 且 f[n+1] = 1（n>0）
        while (!(f[f.size()-2] == 0 && f[f.size()-1] == 1) || f.size() == 2) {
            long long next = (f[f.size()-1] + f[f.size()-2]) % m;
            f.push_back(next);
        }
        printf("%lld\n", f.size() - 2);  // 结果是n = f.size()-2
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. 初始化vector`f`，存斐波那契数的初始值（0,1）；  
    > 2. 循环计算下一个斐波那契数（每步取模），直到vector的倒数第二个元素是0、最后一个是1（且不是初始的0,1）；  
    > 3. 输出`f.size()-2`——因为vector的大小是n+2（比如n=3时，vector有5个元素：0,1,1,2,3→size()-2=3）。


---
<code_intro_selected>
接下来看两份「进阶代码片段」——质因数分解法和矩阵快速幂法，帮你理解数论技巧！
</code_intro_selected>

**题解二：质因数分解法（来源：a13518354766）**
* **亮点**：用筛法分解素数，再用「素数幂周期=素数周期×素数^(k-1)」的定理，效率超高！
* **核心代码片段**：
    ```cpp
    // 暴力计算素数p的周期
    inline int bl(int x) {
        f[1] = 1;
        for (int i = 2;; ++i) {
            f[i] = (f[i-1] + f[i-2]) % x;
            if (f[i] == 1 && f[i-1] == 0) {  // 找到0→1的组合
                return i-1;
            }
        }
    }

    // 分解M为素数幂，计算每个的周期，取LCM
    inline int div(int x) {
        int ans = 1;
        for (int i = 1; i <= e; ++i) {
            if (zhi[i] > x) break;
            if (x % zhi[i] == 0) {
                int tim = 0;
                while (x % zhi[i] == 0) { tim++; x /= zhi[i]; }  // 算素数的幂次
                int ti = bl(zhi[i]);  // 算素数的周期
                ti *= ksm(zhi[i], tim-1);  // 素数幂的周期=ti×p^(tim-1)
                ans = lcm(ans, ti);  // 合并周期（LCM）
            }
        }
        return ans;
    }
    ```
* **代码解读**：
    > 1. `bl`函数：暴力算素数x的周期——循环斐波那契数，直到出现0→1的组合，返回周期长度。  
    > 2. `div`函数：分解x为素数幂（比如6=2^1×3^1），算每个素数幂的周期（比如2的周期是3，3的周期是8），然后取LCM（3和8的LCM是24，对应样例2的输出）。  
    > 比如样例2输入6，分解为2和3：bl(2)=3，bl(3)=8，ti分别是3×2^(1-1)=3，8×3^(1-1)=8，LCM(3,8)=24，正确！
* 💡 **学习笔记**：分解素数+合并周期是数论解决循环节问题的「标准套路」！

**题解三：矩阵快速幂法（来源：Cheng_yf）**
* **亮点**：用矩阵快速幂验证周期，逻辑严密，适合理解数学原理！
* **核心代码片段**：
    ```cpp
    // 矩阵乘法（模mod）
    inline void mul(ll *a, ll *b, ll mod) {
        ll bd = a[0]*b[0], bc = a[0]*b[1], ad = a[1]*b[0], ac = a[1]*b[1];
        a[1] = (bc + ad + ac) % mod;
        a[0] = (bd + ac) % mod;
    }

    // 矩阵快速幂（求a^b mod mod）
    inline void power_p(ll *a, ll b, ll mod) {
        ll c[2] = {1, 0};  // 单位矩阵
        for (; b; b >>= 1, mul(a, a, mod)) {
            if (b & 1) mul(c, a, mod);
        }
        a[0] = c[0]; a[1] = c[1];
    }

    // 检查sum是否是周期（矩阵的sum次幂是否是单位矩阵）
    inline bool check(ll sum) {
        ll b[2] = {0, 1};  // 初始矩阵（对应斐波那契的递推）
        power_p(b, sum, M);
        return b[1] == 0 && b[0] == 1;  // 回到单位矩阵→周期
    }
    ```
* **代码解读**：
    > 1. 斐波那契的递推可以用矩阵表示：`[fib(n), fib(n-1)] = [fib(n-1), fib(n-2)] × [[1,1],[1,0]]`。  
    > 2. `mul`函数：矩阵乘法，每步取模。  
    > 3. `power_p`函数：矩阵快速幂，计算矩阵的sum次幂。  
    > 4. `check`函数：如果矩阵的sum次幂是单位矩阵（`[1,0],[0,1]`），说明sum是周期——因为这时候斐波那契数回到了初始状态（0,1）。
* 💡 **学习笔记**：矩阵快速幂是处理线性递推问题的「神器」，尤其是需要快速计算第n项或验证周期时！


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你「亲眼看到」皮萨诺周期，我设计了一个**8位像素风的动画**——像玩FC游戏一样看斐波那契数模M的循环！
</visualization_intro>

  * **动画演示主题**：像素小人「斐波」绕环形跑道跑步，每步对应一个斐波那契数模M的值，直到回到起点（0,1）。
  * **设计思路**：用FC红白机的配色（比如蓝色天空、绿色草地），让你在「玩」中理解循环——像素小人的颜色代表当前fib(n)%M的值，跑道上的标记代表已经走过的步数，回到起点时播放「胜利音效」，增加成就感！

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：
          * 屏幕左侧是「环形跑道」（用像素块围成的圆圈），右侧是「控制面板」（开始/暂停、单步、重置按钮，速度滑块）。
          * 跑道起点（0,1）用**红+蓝**像素块标记（红=1，蓝=0），像素小人「斐波」站在起点。
          * 播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。
    2.  **算法启动**：
          * 点击「开始」，像素小人开始跑——每跑一步，计算下一个斐波那契数模M的值，小人的颜色变成对应的值（比如M=2时，fib(2)=1→红色，fib(3)=0→蓝色，fib(4)=1→红色）。
          * 每跑一步，跑道上的对应位置会留下「脚印」（浅灰色像素块），记录已经走过的步数。
    3.  **核心步骤演示**：
          * 当小人跑到「0→1」的位置（比如M=2时的第3步），跑道会**闪烁黄色**，并播放「叮～」的胜利音效——告诉你「找到周期了！」。
          * 此时控制面板会显示「周期长度：3」，并弹出文字提示：「斐波回到起点啦！这就是皮萨诺周期～」。
    4.  **交互控制**：
          * 「单步」按钮：点击一次，小人跑一步，方便你慢慢看每一步的变化。
          * 「速度滑块」：可以调节小人的跑步速度（从「慢到快」对应1x到5x）。
          * 「重置」按钮：让小人回到起点，重新开始循环。

  * **旁白提示**：
      * （小人开始跑时）「斐波要开始绕跑道啦！每一步对应一个斐波那契数模M的值～」
      * （小人跑到fib(3)=0时）「现在斐波的颜色是蓝色，代表fib(3)%2=0～」
      * （找到周期时）「叮！斐波回到起点（0→1）啦！周期长度是3～」

<visualization_conclusion>
通过这个动画，你不仅能「看」到皮萨诺周期的样子，还能在玩中记住「斐波那契数模M会循环」的结论——是不是比死记硬背有趣多啦？
</visualization_conclusion>


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
皮萨诺周期的思路不仅能解决本题，还能用到很多「循环节」问题中。比如：
</similar_problems_intro>

  * **通用思路迁移**：
      * 问题1：找「123123123…」模M的循环节（类似斐波那契的线性递推）；
      * 问题2：找随机数生成器的周期（比如线性同余生成器：Xn+1 = (aXn + c) mod M）；
      * 问题3：找字符串的最小循环节（比如KMP算法中的next数组）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1962** - 斐波那契数列  
          * 🗣️ **推荐理由**：用矩阵快速幂计算斐波那契数，帮你巩固「线性递推+快速幂」的技巧！
    2.  **洛谷 P2044** - 随机数生成器  
          * 🗣️ **推荐理由**：找线性同余生成器的周期，和皮萨诺周期的思路一致（分解M为素数幂，算每个的周期再LCM）！
    3.  **洛谷 P3986** - 斐波那契数列  
          * 🗣️ **推荐理由**：直接求皮萨诺周期，是本题的「加强版」，帮你熟练数论分解的技巧！


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解里的作者们分享了很多「踩坑经验」，我帮你整理了最有用的3条：
</insights_intro>

> **经验1（来自万弘）**：「暴力法加记忆化可以避免TLE！」  
> **点评**：如果直接递归斐波那契数，会重复计算很多次（比如fib(5)要算fib(4)和fib(3)，fib(4)又要算fib(3)和fib(2)）。用记忆数组存已经算过的fib(i)，可以把时间复杂度从O(2^n)降到O(n)——这是递归的「优化神器」！

> **经验2（来自A星际穿越）**：「数组开小了会WA！」  
> **点评**：比如题目中M最大是706150，循环到6M就是4,236,900次。如果数组开成1e6，肯定会越界！所以数组大小要至少开成6×M的最大值（比如5e6）——别嫌大，内存够的！

> **经验3（来自tkysss）**：「背错定理会掉坑！」  
> **点评**：比如作者一开始背错了「素数幂的周期」定理，以为暴力过不了，结果发现暴力其实很快。所以记定理时要「精准」——比如素数幂p^k的周期是p^(k-1)*π(p)，而不是p^k*π(p)！


---

<conclusion>
本次关于「终于结束的起点」的分析就到这里啦！这道题的核心是「皮萨诺周期」，暴力法简单好懂，数论法高效严谨，你可以根据自己的水平选择。记住：编程的乐趣在于「从暴力到优化」的过程——先写出能跑的代码，再慢慢优化，你会越来越厉害的！下次我们再一起探索新的算法挑战～💪
</conclusion>

---

---
处理用时：138.19秒
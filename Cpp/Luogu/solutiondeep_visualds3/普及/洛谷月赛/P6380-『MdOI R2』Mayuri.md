# 题目信息

# 『MdOI R2』Mayuri

## 题目背景

「万由里……怎么会？为什么你要……」

『我是灵力的结晶体，实施了封印，我当然会消失，不是吗？』

「封印？但是你和我……」

『第一次见面不能封印吗？笨蛋，我可是从大家的灵力里出生的，怎么可能讨厌你？从一出生，我就爱着你。』

「万由里……」

『虽然我竭力不让自己去想，但我一定是很羡慕大家……』

「等一下，万由里，不要消失……」

『但是我还是有一件能向大家炫耀的事，只有我和士道一样……』

「一样？」

『我已经不再是只为了消失而出生的生命。因为我遇见了你……已经足够了。』

「万由里……」

『谢谢你，士道。 』

![](https://cdn.luogu.com.cn/upload/image_hosting/9w6a0deg.png)

## 题目描述

在离开这个世界前，万由里想要寻找属于她的 Lucky Number。

万由里会给出一个数 $a$，以及一个长度为 $b$ 的 01 串 $S$。

简单的说，她的 Lucky Number 是满足以下条件的**正整数** $n$：

 - $n$ 的位数为 $b$ 且不含前导 $0$。

 - 若 $S$ 的第 $i$ 位为 $1$，则 $n$ 的前 $i$ 位组成的数是 $a$ 的倍数，否则 $n$ 的前 $i$ 位组成的数不是 $a$ 的倍数。

对于一个数，前 $i$ 位组成的数是指这个数前 $i$ 个数码依次拼接形成的数。例如 $312311$ 前 $3$ 位组成的数为 $312$，前 $5$ 位组成的数为 $31231$。


现在，请你帮助万由里计算一下，她的 Lucky Number 是多少。

由于满足条件的数可能会有多个，你需要输出**最小**的一个。若不存在，则请输出 `-1`。

## 说明/提示

【帮助与提示】

为方便选手测试代码，本题额外提供一组附加样例供选手使用。

[样例输入](https://www.luogu.com.cn/paste/5gnn8mg0) [样例输出](https://www.luogu.com.cn/paste/sgxjkbjd)

------
【样例解释】

对于样例一，$10$ 是 $2$ 位数，且 $10$ 的前 $1$ 位组成的数 $1$ 不是 $2$ 的倍数，而前 $2$ 位组成的数 $10$ 是 $2$ 的倍数。由于 $10$ 已经是最小的两位数，故不存在比 $10$ 更小的满足条件的数。

对于样例二，我们需要构造一个 $1$ 位数，满足这个 $1$ 位数整除 $10$。显然，这样的数不存在。

---

【数据范围】

**本题采用捆绑测试**


| 子任务编号 | $a \leq$ | $b\le$  | 分值   |
| ---------- | -------- | :------ | ------ |
| Subtask 1  | $10$     | $ 1$    | $20$   |
| Subtask 2  | $10 $    | $2$     | $20$  |
| Subtask 3  | $10 $    | $ 6$    | $20$  |
| Subtask 4  | $ 2$     | $ 18$   | $20$ |
| Subtask 5  | $ 10$    | $ 10^5$ | $20$ |


对于全部数据，保证 $2\le a\le 10$，$1\le b\le 10^5$，$S$ 中只包含 `0` 和 `1`。

## 样例 #1

### 输入

```
2 2
01```

### 输出

```
10```

## 样例 #2

### 输入

```
10 1 
1```

### 输出

```
-1```

## 样例 #3

### 输入

```
6 6
110100```

### 输出

```
601210```

# AI分析结果

# 💡 Kay的C++算法解析：「MdOI R2」Mayuri 深入学习指南 💡

<introduction>
  今天我们来分析「MdOI R2」Mayuri这道题——帮万由里找她的Lucky Number！这道题需要我们构造**最小的b位正整数**，满足字符串S的条件：S[i]为1时前i位是a的倍数，否则不是。跟着Kay一起拆解问题，学习贪心策略与模运算的巧妙结合吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略 + 模运算优化（编程技巧应用）

🗣️ **初步分析**：
解决这道题的关键是**「贪心选最小，模运算避大数」**。  
- **贪心策略**：要找最小的数，每一位都要选**满足条件的最小数字**（从0开始试，找到第一个符合要求的就停止）。  
- **模运算优化**：直接存储大数会爆内存/精度，但我们只需要知道“前i位是否是a的倍数”——用`remainder`（余数）跟踪前i位的模a结果即可！比如前i位的余数是r，第i+1位选d，那么新的余数就是`(r*10 + d) % a`，完美替代大数计算~  

在本题中，贪心负责“最小”，模运算负责“高效判断条件”。核心流程是：  
1. 特判无解情况（a=10且S[0]='1'，因为1位数字不可能是10的倍数）；  
2. 从高位到低位，每一步选最小的d（0~9），满足：  
   - 如果是第1位，d不能为0；  
   - S[i]为1 → (当前余数*10 + d) % a == 0；  
   - S[i]为0 → (当前余数*10 + d) % a != 0；  
3. 更新余数，继续处理下一位。  

**可视化设计思路**：我们用8位像素风格模拟每一位的选择过程——  
- 屏幕左侧是“当前数字”的像素块（每一位用一个小方块表示，选好的数字会变色）；  
- 右侧显示“当前余数”（用像素字体）和“S的当前要求”（1或0，闪烁提示）；  
- 选数字时，从0到9的像素按钮依次亮起，选中的按钮会“跳一下”并播放“叮”的音效；  
- 满足条件时，当前位变成绿色，余数更新并播放“啪”的音效；  
- 自动演示模式会像“贪吃蛇AI”一样逐步选数字，直到构造完成~


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码简洁度、算法效率三个维度筛选了3份优质题解，都是贪心+模运算的经典实现~
</eval_intro>

**题解一：官方题解（作者：BFqwq）**  
* **点评**：这份题解从subtask入手，逐步推导到正解，逻辑非常完整。它先证明了“除a=10且S[0]='1'外都有解”，再通过“余数跟踪”避免大数问题。代码用数组存储结果，循环处理每一位，边界条件（比如第1位的处理）非常严谨。尤其是“每一步选最小d”的贪心逻辑，直接枚举0~9找到第一个符合条件的d，思路直白易懂，适合初学者模仿。

**题解二：极简贪心（作者：grass8cow）**  
* **点评**：这是我见过最简洁的代码！没有用数组存储结果，直接**边算边输出**，把“余数跟踪”用到了极致。比如处理第i位时，先更新余数`now = now*10 % a`，再根据S[i]的要求选d：如果要整除，d就是`(a - now) % a`（补全余数到a的倍数）；如果不要整除，d选0（不行就选1）。代码只有20行，却完美覆盖所有情况，是“用最少代码解决问题”的典范！

**题解三：详细注释版（作者：幻之陨梦）**  
* **点评**：这份题解的注释非常详细，适合新手理解每一步的逻辑。它用数组存储结果，逐位枚举d（从0到9），并处理了前导零的问题（第1位不能为0）。尤其是“用sum记录余数”的部分，注释清楚地解释了“为什么不用存储整个数”，帮助新手理解模运算的意义。代码的鲁棒性很强，比如用`f`标记是否找到可行的d，没找到就输出-1，避免错误。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点集中在“如何高效构造最小数”和“如何处理大数”，结合优质题解，我总结了3个核心关键点：
</difficulty_intro>

1.  **关键点1：如何避免大数问题？**  
    * **分析**：直接存储b位数字（比如b=1e5）会超出任何数据类型的范围。但我们只需要知道“前i位是否是a的倍数”——用**余数**跟踪即可！比如前i位的余数是r，第i+1位选d，新余数是`(r*10 + d) % a`。这样不管b多大，余数都不会超过a（a≤10），完美解决大数问题。  
    * 💡 **学习笔记**：模运算的核心是“等价类”——我们不需要知道具体的数，只需要知道它属于哪个模a的等价类。

2.  **关键点2：如何保证每一位选最小的数字？**  
    * **分析**：贪心策略的核心是“局部最优→全局最优”。每一位都从0开始试（第1位从1开始），找到第一个满足条件的d就停止。比如S[i]为1时，我们需要`(r*10 + d) % a == 0`，d的最小可能值是`(a - r*10 % a) % a`（比如r*10%a=3，a=5，d=2就能补全到5的倍数）。  
    * 💡 **学习笔记**：贪心的关键是“每一步都选当前最优”，而本题的“最优”就是“最小的d”。

3.  **关键点3：如何处理特判情况？**  
    * **分析**：唯一无解的情况是“a=10且S[0]='1'”——因为1位数字不可能是10的倍数（10是两位数，而第1位不能为0）。其他情况都有解，因为连续a个数字中必有一个是a的倍数（比如r*10到r*10+9中，一定有一个是a的倍数，a≤10）。  
    * 💡 **学习笔记**：特判是编程中的“保命符”，先处理特殊情况能避免很多错误。

### ✨ 解题技巧总结
- **技巧A：模运算简化大数**：当需要判断“数的倍数”时，用余数跟踪比存储整个数高效得多。  
- **技巧B：贪心选最小**：构造最小数时，每一位从0开始试，找到第一个符合条件的就停止。  
- **技巧C：特判边界情况**：先处理无解的情况（比如a=10且S[0]='1'），避免后续逻辑出错。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**极简通用实现**（来自grass8cow的题解），它没有用数组，直接边算边输出，完美体现“贪心+模运算”的核心！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自grass8cow的题解，用极简逻辑实现了贪心+模运算，没有冗余代码，适合作为模板。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int a,b,i,now;
    char c;
    int main()
    {
        cin>>a>>b>>c;
        if(a==10&&c=='1'){cout<<-1;return 0;}//特判无解
        if(c=='1')cout<<a;
        else cout<<1,now=1;//处理第1位
        for(i=1;i<b;i++)
        {
            cin>>c; 
            now=now*10%a;//更新余数
            if(c=='0'){if(now)cout<<0;else cout<<1,now=1;}//不要整除：选0（不行选1）
            else cout<<(a-now)%a,now=0;//要整除：补全余数到a的倍数
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  1. 特判无解情况（a=10且S[0]='1'）；  
  2. 处理第1位：如果S[0]='1'，直接输出a（最小的1位a的倍数）；否则输出1（最小的非0数字）；  
  3. 循环处理后续每一位：  
     - 先更新余数`now = now*10 % a`（模拟前i位左移一位）；  
     - 根据S[i]的要求选d：  
       - S[i]='0'：如果当前余数非0，选0（不影响余数）；否则选1（让余数变成1，避免整除）；  
       - S[i]='1'：选`(a - now) % a`（补全余数到a的倍数，让新余数为0）；  
  4. 直接输出每一位，无需存储整个数！

---

<code_intro_selected>
接下来分析优质题解的核心片段，看看它们的亮点~
</code_intro_selected>

**题解一：官方题解的核心循环**
* **亮点**：用数组存储结果，逻辑清晰，适合理解每一步的选择过程。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<b;i++){
        now*=10;
        for(int j=0;j<=9;j++)
        if((now+j)%a==0&&c[i]=='1'||(now+j)%a!=0&&c[i]=='0'){
            now+=j;
            now%=a;
            n[i]=j+'0';
            break;
        }
    }
    ```
* **代码解读**：  
  - `now`是前i-1位的余数，左移一位（乘以10）后，枚举j从0到9；  
  - 找到第一个满足条件的j（符合S[i]的要求），更新余数`now = (now + j) % a`，并存储到数组n中；  
  - 这是最直白的“贪心选最小”实现，枚举j从0开始，找到就break，保证选最小的d。  
* 💡 **学习笔记**：枚举法是贪心的基础，适合新手理解“为什么选这个d”。

**题解二：grass8cow的无数组实现**
* **亮点**：直接输出每一位，无需存储，代码极简。
* **核心代码片段**：
    ```cpp
    for(i=1;i<b;i++)
    {
        cin>>c; 
        now=now*10%a;
        if(c=='0'){if(now)cout<<0;else cout<<1,now=1;}
        else cout<<(a-now)%a,now=0;
    }
    ```
* **代码解读**：  
  - 不需要数组！每一步计算完d后直接输出；  
  - 对于S[i]='0'：如果当前余数非0，选0（不改变余数）；否则选1（让余数变成1，避免整除）；  
  - 对于S[i]='1'：选`(a - now) % a`，直接补全余数到a的倍数，让新余数为0；  
* 💡 **学习笔记**：代码的简洁性来自“按需计算”——不需要存储结果，直接输出每一步的选择。

**题解三：幻之陨梦的数组存储**
* **亮点**：详细处理前导零，用数组存储结果，适合新手调试。
* **核心代码片段**：
    ```cpp
    for(int i=0;i<b;i++)
    {
        scanf(" %c",&s);
        if(s=='0')
        {
            for(int j=0;j<=9;j++)
            {
                if(((sum*10)+j)%a!=0){
                    if(i==0 && j==0) continue;
                    ans[i]=j;
                    sum=((sum*10)+j)%a;
                    break;
                }
            }
        }
        else
        {
            for(int j=0;j<=9;j++)
            {
                if(((sum*10)+j)%a==0){
                    if(i==0 && j==0) continue;
                    ans[i]=j;
                    sum=((sum*10)+j)%a;
                    break;
                }
            }
        }
    }
    ```
* **代码解读**：  
  - 用数组`ans`存储每一位的数字，`sum`跟踪余数；  
  - 枚举j从0到9，找到第一个满足条件的j，处理前导零（i=0时j不能为0）；  
  - 代码逻辑清晰，注释详细，适合新手一步步调试。  
* 💡 **学习笔记**：数组存储结果便于调试，适合刚开始学习的同学。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家直观看到“贪心选数字+余数变化”的过程，我设计了一个**8位像素风的动画**，像玩FC游戏一样学算法！
</visualization_intro>

### **动画设计方案**
- **主题**：像素探险家“Mayuri”找Lucky Number（每选对一位，Mayuri就前进一格，直到走到终点）。
- **风格**：FC红白机风格，用16色调色板（比如蓝色背景、黄色数字块、绿色选中标记）。
- **核心演示内容**：
  1. **初始化**：  
     - 屏幕左侧显示“当前数字”的像素块（比如b=5时，显示5个空方块）；  
     - 右侧显示“当前余数”（像素字体，初始为0）和“S的要求”（比如S[0]='1'，用红色闪烁）；  
     - 底部有“单步/自动”按钮、速度滑块，还有Mayuri的像素角色（站在起点）。
  2. **第1位选择**：  
     - 弹出数字按钮（0~9），Mayuri走到按钮前，从0开始试：  
       - 0：前导零，被拒绝（按钮变红，播放“哔”的音效）；  
       - 1：如果S[0]='0'，符合条件（按钮变绿，播放“叮”的音效），Mayuri走到第1个方块，方块显示1，余数更新为1；  
       - 如果S[0]='1'，试到a（比如a=2，试到2时符合条件），方块显示2，余数更新为0。
  3. **后续位选择**：  
     - 每一步先更新余数（比如前一位余数是1，左移一位变成10%2=0）；  
     - 根据S[i]的要求，Mayuri试数字：  
       - S[i]='0'：试0，如果余数0*10+0=0%2=0（不符合），试1（1%2=1，符合），按钮变绿，显示1，余数更新为1；  
       - S[i]='1'：试0（余数0*10+0=0%2=0，符合），按钮变绿，显示0，余数更新为0；  
  4. **完成与反馈**：  
     - 所有位选完后，Mayuri走到终点，播放“胜利”音效（FC风格的“叮叮咚”），数字块全部变绿，显示完整的Lucky Number；  
     - 如果无解（比如a=10且S[0]='1'），Mayuri站在原地，播放“失败”音效（短促的“哔”），屏幕显示“-1”。

### **交互设计**
- **单步模式**：点击“下一步”，Mayuri走一步，选一个数字；  
- **自动模式**：点击“自动”，Mayuri自动选数字，速度可以用滑块调整（从“慢”到“快”）；  
- **重置**：点击“重置”，回到初始状态，重新开始。

### **为什么这样设计？**
- 用“Mayuri探险”的游戏元素，让学习更有趣；  
- 像素风格和复古音效，唤起童年游戏的记忆，降低学习压力；  
- 每一步的“试错-成功”过程，直观展示贪心策略的“选最小”逻辑；  
- 余数的实时更新，让大家看到“模运算如何替代大数”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
贪心+模运算的组合不仅能解决本题，还能处理很多“构造满足条件的数”的问题。比如：
</similar_problems_intro>

### **通用思路迁移**
- **场景1**：构造最小的数，使得每一位满足某种整除条件（比如前i位是3的倍数）；  
- **场景2**：构造最大的数，使得每一位满足某种余数条件（比如前i位模5等于2）；  
- **场景3**：构造满足多个条件的数（比如既是回文数，又是7的倍数）。

### **洛谷练习推荐**
1. **洛谷 P1012 拼数**  
   - 🗣️ **推荐理由**：这道题需要构造最小的数，思路和本题的“贪心选最小”一致，只不过条件变成了“拼接后的数最小”，能巩固贪心策略。  
2. **洛谷 P1217 回文质数**  
   - 🗣️ **推荐理由**：这道题需要构造既是回文数又是质数的数，需要结合贪心（构造最小回文数）和模运算（判断质数），能锻炼综合应用能力。  
3. **洛谷 P1496 火烧赤壁**  
   - 🗣️ **推荐理由**：这道题需要合并区间，思路类似贪心（选最小的起点，合并重叠区间），能拓展贪心的应用场景。  
4. **洛谷 P2670 扫雷游戏**  
   - 🗣️ **推荐理由**：这道题需要根据周围的雷数构造扫雷棋盘，思路类似“贪心填数”（每一步根据条件填0或1），能巩固“逐位构造”的逻辑。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我发现了几个非常有用的经验，分享给大家：
</insights_intro>

> **经验1：模运算的“等价类”思维**（来自官方题解）  
> 作者提到：“我们不需要存储整个数，只需要存储它的余数”——这是解决大数问题的关键！比如判断“前i位是否是a的倍数”，只需要看余数是否为0，不需要知道具体的数。  
> **点评**：模运算的核心是“等价类”——所有模a余r的数，在“是否是a的倍数”这个问题上是等价的。学会这种思维，能解决很多大数问题。

> **经验2：贪心的“局部最优→全局最优”**（来自grass8cow的题解）  
> 作者的代码直接选最小的d，没有任何冗余——这是贪心的精髓！每一步选当前最优的，最后得到的就是全局最优的。  
> **点评**：贪心策略的关键是“证明局部最优能推导出全局最优”。本题中，选最小的d能保证前面的位尽可能小，后面的位无论怎么选，整个数都是最小的。

> **经验3：特判的重要性**（来自所有题解）  
> 所有题解都先处理了“a=10且S[0]='1'”的情况——这是唯一的无解情况。如果不特判，代码会错误地尝试构造1位的10的倍数，导致结果错误。  
> **点评**：特判是编程中的“保命符”，先处理特殊情况能避免很多逻辑错误，节省调试时间。


<conclusion>
本次分析就到这里啦！这道题的核心是**贪心+模运算**，学会用余数跟踪大数，用贪心选最小数字，就能解决这类“构造满足条件的数”的问题。记住：编程的本质是“用简单的方法解决复杂的问题”——模运算简化了大数，贪心简化了选择，两者结合就是最优解！下次我们再一起探索新的算法挑战~ 💪
</conclusion>

---
处理用时：133.70秒
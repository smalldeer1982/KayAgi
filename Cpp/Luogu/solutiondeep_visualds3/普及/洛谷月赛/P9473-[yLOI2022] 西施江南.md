# 题目信息

# [yLOI2022] 西施江南

## 题目背景

> 我晤江南面 如逢西施颜  
> 清芬宜送岸 菡萏新雨前  
> 皓腕分珠帘 珠露扬波珠玉敛  
> 天然一段聚散 嫣然曾与言  
> 平芜辙尚浅 无韵化湖田  
> 林园虽工典 芳姿不可嵌  
> 何人冠诗篇 重街杳杳重门掩  
> 似有柔荑遮目 空谷足尖

银临《西施江南》

## 题目描述

给定 $n$ 个正整数 $a_1, a_2, a_3, \dots a_n$，记 $g$ 是这些数的**最大公约数**，$l$ 是这些数的**最小公倍数**。请你判断 $l \times g$ 是否等于 $a_1 \times a_2 \times \dots \times a_n$。

## 说明/提示

### 数据规模与约定

以下用 $N$ 表示单个测试点内 $n$ 的和，即 $N = \sum n$。

- 对 $12\%$ 的数据，保证 $n = 2$。
- 对 $36\%$ 的数据，保证 $n \leq 5$。
- 对 $52\%$ 的数据，保证 $N \leq 1000$。
- 对 $76\%$ 的数据，保证 $N,a_i \leq 10^5$。
- 对 $100\%$ 的数据，保证 $2 \leq n,N \leq 5 \times 10^5$，$2 \leq a_i \leq 10^8$，$1 \leq T \leq 20$。

### 提示

**数据千万条，清空第一条**。  
**多测不清空，爆零两行泪**。  
**清空不规范，超时总相伴**。

## 样例 #1

### 输入

```
3
2
2 3
3
2 3 4
3
3 8 35```

### 输出

```
Yes
No
Yes```

## 样例 #2

### 输入

```
见附加文件中的 C2.in```

### 输出

```
见附加文件中的 C2.ans```

# AI分析结果


### 题目分析
题目要求判断给定正整数序列的最大公约数(g)和最小公倍数(l)的乘积是否等于序列所有元素的乘积。核心结论如下：
- 当n=2时，恒有g×l = a₁×a₂（直接输出"Yes"）
- 当n>2时，仅当所有数两两互质时成立（需检查任意两数无公共质因子）

### 核心算法识别
**算法分类**：数论（质因数分解与互质判断）  
**比喻解释**：想象每个数字是独特的乐高积木，质因数是积木上的凸点。两两互质要求任意两块积木的凸点完全不同，无法拼接（无公共质因子）。本题就是检查所有积木的凸点是否完全独特。

**核心难点**：
1. 高效质因数分解（避免O(n²)暴力）
2. 大范围质因数判重（a_i ≤ 10⁸）
3. 多组数据处理的优化

**解决方案**：  
预处理10000以内质数表（共1229个），分解时：
1. 先用质数表处理≤10⁴的质因子
2. 剩余部分必为单个质数（>10⁴）
3. 用哈希表实时判重，发现重复立即终止

### 精选优质题解
**题解一（cff_0102）**  
**亮点**：  
- 严谨数学证明（n>2时需两两互质）
- 线性筛预处理最小质因子（O(1)分解）
- 边界处理完善（相同数特判）

**代码规范性**：  
- 变量名清晰（lpri存最小质因子）
- 模块化筛法函数
- 注释明确关键逻辑

**题解二（信息向阳花木）**  
**亮点**：  
- 桶计数法替代暴力枚举
- 质因子分解优化（仅枚举质数）
- 面向初学者的详细注释

**可改进点**：  
- 未处理相同数的特殊情况
- 桶数组范围过大（需优化内存）

**题解三（一扶苏一）**  
**亮点**：  
- 唯一分解定理严谨推导
- 子任务分档优化思路
- 线性筛+最小质因子快速分解

**实践价值**：  
- 提供渐进式优化路径
- 复杂度分析清晰（O(Tn log a_i)）

### 核心难点与解题策略
1. **质因数判重**  
   - **分析**：必须保证每个质因子仅出现在一个数中
   - **解决**：用`unordered_set`实时记录质因子，分解时立即查重

2. **大数分解效率**  
   - **分析**：朴素分解O(√a_i)在10⁸过大
   - **解决**：预处理10000以内质数表，将内层循环降至1229次

3. **相同数处理**  
   - **分析**：相同数必然不互质（如[4,4]）
   - **解决**：质因数分解自动包含相同数检测

**学习笔记**：  
> 💡 互质判断本质是质因子集合的交集为空  
> 💡 线性筛预处理最小质因子可将分解复杂度降至O(log a_i)

**解题技巧总结**：
- **问题分解**：将全局互质判断转化为质因子分布问题
- **桶分复用**：用哈希表避免O(n²)两两比较
- **边界预判**：n=2直接返回，避免无效计算

### C++核心代码实现
**通用核心实现**（综合优化版）：
```cpp
#include <iostream>
#include <vector>
#include <unordered_set>
#include <cmath>
using namespace std;

const int MAXP = 10000;
vector<int> primes;

void precompute_primes() {
    vector<bool> isPrime(MAXP + 1, true);
    isPrime[0] = isPrime[1] = false;
    for (int i = 2; i <= MAXP; ++i) {
        if (isPrime[i]) {
            primes.push_back(i);
            for (int j = i * i; j <= MAXP; j += i)
                isPrime[j] = false;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    precompute_primes(); // 预计算质数表
    
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        vector<int> a(n);
        for (int i = 0; i < n; ++i)
            cin >> a[i];
        
        // n=2直接返回
        if (n == 2) {
            cout << "Yes\n";
            continue;
        }
        
        unordered_set<int> used;
        bool valid = true;
        
        for (int x : a) {
            int temp = x;
            // 分解≤10000的质因子
            for (int p : primes) {
                if (p * p > temp) break; // 提前终止
                if (temp % p == 0) {
                    if (used.count(p)) {
                        valid = false;
                        break;
                    }
                    used.insert(p);
                    while (temp % p == 0)
                        temp /= p;
                }
            }
            // 处理剩余质因子
            if (temp > 1) {
                if (used.count(temp)) 
                    valid = false;
                else 
                    used.insert(temp);
            }
            if (!valid) break;
        }
        cout << (valid ? "Yes" : "No") << '\n';
    }
    return 0;
}
```

**代码解读**：
1. **预计算质数表**（`precompute_primes`）
   - 埃氏筛生成10000内质数（1229个）
   - 全局只计算一次，避免重复开销

2. **质因数分解核心逻辑**
   - 外层：遍历每个数 `for (int x : a)`
   - 中层：遍历质数表 `for (int p : primes)`
   - 内层：除尽质因子 `while (temp % p == 0)`
   - **优化点**：`p*p > temp` 提前终止

3. **互质判断**
   - `unordered_set` 实时记录质因子
   - 发现重复立即置 `valid = false`
   - **关键行**：`used.count(p)` 检测质因子冲突

### 算法可视化
**像素动画设计**（8-bit风格演示质因数分解）：
```plaintext
1. 场景设计：
   - 8-bit网格：数字显示为像素方块（如：48→█）
   - 质数表：底部滚动显示（红：当前检测质数）
   - 分解动画：数字被"打碎"成质因数方块

2. 关键帧流程：
   [初始化] 输入: 48 27 35
   Step1: 检测48
      ██ 48 → 被质数2（红色）击中
      ▓▓ 24 → 再次被2击中 → ▓▓ 12 → ▓▓ 6 → ▓▓ 3
      质数表记录：2(闪烁)

   Step2: 检测27
      ██ 27 → 被质数3(红色)击中
      ▒▒ 9 → 被3击中 → ▒▒ 3
      质数表记录：2,3(3闪烁)

   Step3: 检测35
      ██ 35 → 被质数5(红色)击中 → ░░ 7
      质数表记录：2,3,5,7 → 无冲突

3. 交互控制：
   - 步进按钮：单步分解
   - 速度滑块：调整分解速度
   - 冲突特效：发现重复质数时屏幕红光闪烁+警报音

4. 游戏化元素：
   - 成功音效：每步分解"叮"声
   - 通关特效：全部分解后像素烟花
   - 失败动画：冲突时显示"X"符号
```

### 拓展练习
**相似问题迁移**：
1. **质因数分布问题**  
   CF1771C Hossam and Trainees（判断存在公共质因子的数对）
2. **互质集合构造**  
   P2568 GCD（统计互质数对数量）
3. **质因数分解变种**  
   B3715 分解质因子2（大数据分解优化）

**洛谷推荐题目**：
1. **P3383 【模板】线性筛素数**  
   → 掌握高效质数生成
2. **P1069 细胞分裂**  
   → 练习质因数分解在分治问题中的应用
3. **P1072 Hankson的趣味题**  
   → 综合gcd/lcm与质因数分解的经典题

### 学习心得
**经验摘录**（来自cff_0102）：
> "比赛时卡在质因数分解效率，后改用线性筛预处理最小质因子，效率提升10倍。调试关键：打印中间变量验证质因子覆盖"

**Kay的总结**：
> 质因数分解是数论问题的核心武器，注意：
> 1. 预处理质数表大幅提升效率
> 2. 哈希判重替代暴力比较
> 3. 注意特判n=2和相同数情况
> 调试时可用小数据集验证质因子分布

--- 
**本次解析对你理解算法本质是否有帮助？欢迎分享你的思考！** 🚀

---
处理用时：228.82秒
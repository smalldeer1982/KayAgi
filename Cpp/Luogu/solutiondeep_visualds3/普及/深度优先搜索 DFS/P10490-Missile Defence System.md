# 题目信息

# Missile Defence System

## 题目描述

为了对抗附近恶意国家的威胁，R 国更新了他们的导弹防御系统。

一套防御系统的导弹拦截高度要么一直严格单调上升要么一直严格单调下降。

例如，一套系统先后拦截了高度为 $3$ 和高度为 $4$ 的两发导弹，那么接下来该系统就只能拦截高度大于 $4$ 的导弹。

给定即将袭来的一系列导弹的高度，请你求出至少需要多少套防御系统，就可以将它们全部击落。

## 说明/提示

#### 样例解释
对于样例，需要两套系统。一套击落 $3,4$ 号导弹，另一套击落 $5,2,1$ 号导弹。

#### 数据规模与约定
$1 \leq n \leq 50$。

## 样例 #1

### 输入

```
5 
3 5 2 4 1 
0```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：Missile Defence System 深入学习指南 💡

<introduction>
今天我们来一起分析经典的“导弹防御系统”问题。这道题不仅能锻炼我们的搜索思维，还能让我们学会如何通过剪枝优化来解决看似“不可能”的爆搜问题。让我们一起拆解问题，掌握核心技巧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：深度优先搜索 (DFS) + 剪枝优化

🗣️ **初步分析**：
解决这道题的关键在于**尝试所有可能的导弹分配方式**（给上升系统或下降系统），同时**剪去不可能的路径**（比如当前系统数已经超过已知最优解）。简单来说，DFS就像“试衣服”——我们逐个导弹尝试“穿”到不同的系统里，不合适就换一件，而剪枝就是“提前放弃”那些明显不好看的搭配。

在本题中，DFS用于遍历每个导弹的四种可能选择：用已有上升系统、用已有下降系统、新建上升系统、新建下降系统。但直接爆搜会超时，因此需要**最优性剪枝**（当前系统数≥已知最优时返回）和**贪心剪枝**（选择最适合的系统而不是所有可能）。

核心算法流程：
1. 按导弹顺序处理每个导弹；
2. 尝试将导弹加入已有上升系统（选最“高”的那个，保留低系统的潜力）；
3. 尝试将导弹加入已有下降系统（选最“低”的那个，同理）；
4. 若无法加入已有系统，则新建系统；
5. 每一步都检查是否超过已知最优解，是则剪枝。

可视化设计思路：我们会用**FC复古像素风**模拟导弹分配过程——导弹是闪烁的像素点，上升系统用蓝色框、下降系统用红色框，每一步高亮当前处理的导弹和选择的系统，用“单步执行”看细节，“自动播放”看整体流程，关键操作（如加入系统）伴随“叮”的音效，完成时播放“胜利”音效。


## 2. 精选优质题解参考

<eval_intro>
我筛选了4道思路清晰、剪枝到位的优质题解，帮大家快速理解核心逻辑：
</eval_intro>

### 题解一：来源：Atserckcn（赞：12）
* **点评**：这道题解的思路非常直白——用`vector`分别存上升和下降系统的最后高度，DFS遍历每个导弹的四种选择。最值得学习的是**剪枝逻辑**：当前系统数≥已知最优时直接返回，避免无效搜索。代码风格规范，变量名`up`/`down`含义明确，回溯时还原状态的细节也处理得很好（比如用`tmp`保存原高度）。

### 题解二：来源：Adorable_（赞：4）
* **点评**：这道题解详细解释了剪枝策略——**贪心优化**（选最适合的系统）和**最优性剪枝**（超过已知最优返回）。作者用例子说明“选最高的上升系统拦截更优”，让贪心的思路更易懂。代码中的`up`/`down` vector设计简洁，符合直觉。

### 题解三：来源：luobotianle（赞：2）
* **点评**：这道题解的**贪心思想**讲得最透彻——对于能拦截的系统，选“最有潜力”的那个（上升选最高的，下降选最低的）。作者用具体例子（比如两个上升系统选哪个拦截9）让逻辑更清晰，代码中的`break`操作（找到第一个合适的系统就停止）大大减少了搜索次数。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的三大核心难点，我帮大家拆解清楚：
</difficulty_intro>

### 1. 如何避免超时？——最优性剪枝
* **难点**：直接DFS会尝试所有可能，n=50时完全无法处理。
* **策略**：每次DFS前检查“当前系统数≥已知最优解”，如果是就直接返回（因为后续只会增加系统数，不可能更优）。比如`if (up.size() + down.size() >= ans) return;`。
* 💡 **学习笔记**：剪枝是搜索的“刹车”，提前停止无效路径能大幅提升效率。

### 2. 如何选择最优的系统？——贪心策略
* **难点**：多个系统能拦截当前导弹时，选哪个更好？
* **策略**：对于上升系统，选**最后高度最高**的那个（保留低系统的潜力）；对于下降系统，选**最后高度最低**的那个。比如遍历上升系统时，找到第一个能拦截的（即最后高度<当前导弹），因为前面的都不能拦截，第一个能拦截的就是最高的。
* 💡 **学习笔记**：贪心是“当下最优”，往往能引导全局最优。

### 3. 如何还原状态？——回溯的细节
* **难点**：DFS尝试选择一个系统后，要回到原来的状态尝试其他选择。
* **策略**：用临时变量保存系统的原高度，DFS后还原。比如`int tmp = up[i]; up[i] = a[now]; dfs(now+1); up[i] = tmp;`。
* 💡 **学习笔记**：回溯是“试错”的关键，必须还原状态才能尝试所有可能。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合优质题解的**通用核心实现**，帮大家把握整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了多个优质题解的思路，用`vector`存系统最后高度，DFS处理每个导弹，包含最优性剪枝和贪心选择。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

const int MAXN = 55;
int n, a[MAXN], ans;
vector<int> up, down;

void dfs(int now) {
    int us = up.size(), ds = down.size();
    if (us + ds >= ans) return; // 最优性剪枝
    if (now > n) { // 处理完所有导弹
        ans = min(ans, us + ds);
        return;
    }
    // 尝试加入上升系统
    for (int i = 0; i < us; ++i) {
        if (up[i] < a[now]) {
            int tmp = up[i];
            up[i] = a[now];
            dfs(now + 1);
            up[i] = tmp; // 回溯
            break; // 贪心：选第一个合适的（最高的）
        }
    }
    if (up.empty() || up.back() >= a[now]) { // 新建上升系统
        up.push_back(a[now]);
        dfs(now + 1);
        up.pop_back(); // 回溯
    }
    // 尝试加入下降系统（同理）
    for (int i = 0; i < ds; ++i) {
        if (down[i] > a[now]) {
            int tmp = down[i];
            down[i] = a[now];
            dfs(now + 1);
            down[i] = tmp;
            break;
        }
    }
    if (down.empty() || down.back() <= a[now]) { // 新建下降系统
        down.push_back(a[now]);
        dfs(now + 1);
        down.pop_back();
    }
}

int main() {
    while (cin >> n && n != 0) {
        for (int i = 1; i <= n; ++i) cin >> a[i];
        ans = INT_MAX;
        up.clear(); down.clear();
        dfs(1);
        cout << ans << endl;
    }
    return 0;
}
```
* **代码解读概要**：
  1. 读取输入：多组数据，每组读n和导弹高度；
  2. 初始化：`ans`设为无穷大，`up`/`down`清空；
  3. DFS处理：从第一个导弹开始，尝试加入已有系统或新建系统；
  4. 剪枝：当前系统数≥已知最优时返回；
  5. 输出结果：每组数据输出最少系统数。


<code_intro_selected>
再看优质题解的核心片段，学习细节：
</code_intro_selected>

### 题解一：来源：Atserckcn
* **亮点**：剪枝逻辑直接有效，回溯细节处理到位。
* **核心代码片段**：
```cpp
void dfs(int now) {
    int upsize = up.size(), downsize = down.size();
    if (upsize + downsize >= ans) return; // 最优性剪枝
    if (now > n) { ans = min(ans, upsize + downsize); return; }
    // 尝试加入上升系统
    for (int i = 0; i < upsize; ++i) {
        if (up[i] < a[now]) {
            int t = up[i]; up[i] = a[now];
            dfs(now + 1); up[i] = t; break;
        }
    }
    if (upsize == 0 || up[upsize-1] >= a[now]) {
        up.push_back(a[now]); dfs(now+1); up.pop_back();
    }
    // 尝试加入下降系统（同理）
}
```
* **代码解读**：
  - `upsize + downsize >= ans`：如果当前系统数已经超过已知最优，直接返回；
  - `for`循环找能拦截的上升系统：第一个`up[i] < a[now]`的就是“最高的合适系统”（因为`up`是单调递增的，前面的都更大）；
  - `break`：找到就停止，避免尝试其他系统（贪心优化）；
  - `up.push_back(...)`：如果没有合适的系统，新建一个，DFS后要`pop_back`还原。
* 💡 **学习笔记**：剪枝和贪心是DFS优化的核心，两者结合才能通过本题。


## 4. 算法可视化：像素动画演示

<visualization_intro>
为了让大家“看”到算法运行过程，我设计了**FC风格的像素动画**，像玩游戏一样学DFS：
</visualization_intro>

### 1. 动画主题：像素导弹防御战
用8位像素风模拟导弹防御场景——导弹是闪烁的白色像素点，上升系统是蓝色框，下降系统是红色框，背景是FC风格的黑色网格。

### 2. 核心演示内容
- **初始化**：屏幕显示导弹序列（比如样例的3、5、2、4、1），`up`/`down`系统为空；
- **处理第一个导弹（3）**：
  - 尝试加入上升系统：`up`为空，新建蓝色框，显示“上升系统1：3”；
  - 尝试加入下降系统：`down`为空，新建红色框，显示“下降系统1：3”；
- **处理第二个导弹（5）**：
  - 加入上升系统：找到蓝色框（3<5），更新为“上升系统1：5”，伴随“叮”音效；
  - 尝试加入下降系统：红色框（3>5？不），新建红色框“下降系统2：5”；
- **处理第三个导弹（2）**：
  - 加入下降系统：找到红色框（5>2），更新为“下降系统1：2”，伴随“叮”音效；
- **……**：直到所有导弹处理完毕，显示“需要2套系统”，播放胜利音效。

### 3. 交互设计
- **控制面板**：开始/暂停、单步执行、重置按钮；速度滑块（慢→快）；
- **自动演示**：像“贪吃蛇AI”一样自动执行，展示完整流程；
- **音效**：加入系统“叮”，完成“胜利”，错误“提示”；
- **复古BGM**：循环播放FC风格的轻松音乐。

### 4. 技术实现
用HTML+CSS+JavaScript（Canvas API）实现，单文件轻量化，本地打开就能玩。比如用`canvas.drawImage`画像素导弹，`setInterval`控制动画帧，`Audio`播放音效。


## 5. 拓展练习与相似问题

<similar_problems_intro>
学会DFS+剪枝后，这些题能帮你巩固技巧：
</similar_problems_intro>

### 1. 洛谷P10483 小猫爬山
* **推荐理由**：同样是“分配物品到容器”的问题，需要剪枝（最优性剪枝+贪心选最合适的容器），和本题思路高度相似。

### 2. 洛谷P1120 小木棍
* **推荐理由**：经典的DFS+剪枝问题，需要优化搜索顺序（从大到小排序）、排除等效冗余（相同长度的木棍只试一次），锻炼剪枝能力。

### 3. 洛谷P1019 单词接龙
* **推荐理由**：需要DFS遍历所有可能的单词组合，剪枝（超过最长长度返回），和本题的“尝试所有可能”思路一致。


## 6. 学习心得与经验分享

<insights_intro>
从题解中摘录的宝贵经验，帮大家避坑：
</insights_intro>

> **参考经验（来自Atserckcn）**：“我在调试时，一开始把`upsize`/`downsize`设为全局变量，结果回溯时出错，调了1小时才发现——回溯时一定要用局部变量保存当前状态！”
> **点评**：全局变量会被后续递归修改，导致回溯失败。用局部变量（比如`int upsize = up.size()`）能避免这个问题，这是DFS的常见坑点。

> **参考经验（来自luobotianle）**：“如果有两个系统能拦截当前导弹，选最高的上升系统更优——因为低的系统‘更有潜力’拦截后面的导弹。”
> **点评**：贪心策略不是“拍脑袋”，而是基于“后续潜力”的考虑，这是DFS优化的关键。


## <conclusion>
本次关于“导弹防御系统”的分析就到这里。记住：DFS的核心是“尝试所有可能”，而剪枝和贪心是“去掉不可能的路径”。多练类似的搜索题，你会越来越熟练！下次我们再一起挑战更难的算法～💪
</conclusion>

---
处理用时：89.64秒
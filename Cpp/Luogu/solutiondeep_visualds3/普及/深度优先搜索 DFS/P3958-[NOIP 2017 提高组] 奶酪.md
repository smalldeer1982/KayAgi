# 题目信息

# [NOIP 2017 提高组] 奶酪

## 题目背景

NOIP2017 提高组 D2T1

## 题目描述

现有一块大奶酪，它的高度为 $h$，它的长度和宽度我们可以认为是无限大的，奶酪中间有许多半径相同的球形空洞。我们可以在这块奶酪中建立空间坐标系，在坐标系中，奶酪的下表面为 $z = 0$，奶酪的上表面为 $z = h$。

现在，奶酪的下表面有一只小老鼠 Jerry，它知道奶酪中所有空洞的球心所在的坐标。如果两个空洞相切或是相交，则 Jerry 可以从其中一个空洞跑到另一个空洞，特别地，如果一个空洞与下表面相切或是相交，Jerry 则可以从奶酪下表面跑进空洞；如果一个空洞与上表面相切或是相交，Jerry 则可以从空洞跑到奶酪上表面。

位于奶酪下表面的 Jerry 想知道，在不破坏奶酪的情况下，能否利用已有的空洞跑 到奶酪的上表面去?

空间内两点 $P_1(x_1,y_1,z_1)$、$P2(x_2,y_2,z_2)$ 的距离公式如下：


$$\mathrm{dist}(P_1,P_2)=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2+(z_1-z_2)^2}$$


## 说明/提示

【输入输出样例 $1$ 说明】

 ![](https://cdn.luogu.com.cn/upload/pic/10860.png) 

第一组数据,由奶酪的剖面图可见：

第一个空洞在 $(0,0,0)$ 与下表面相切；

第二个空洞在 $(0,0,4)$ 与上表面相切；

两个空洞在 $(0,0,2)$ 相切。

输出 `Yes`。

 
第二组数据,由奶酪的剖面图可见：

两个空洞既不相交也不相切。

输出 `No`。

 
第三组数据,由奶酪的剖面图可见：

两个空洞相交，且与上下表面相切或相交。

输出 `Yes`。

【数据规模与约定】

对于 $20\%$ 的数据，$n = 1$，$1 \le h$，$r \le  10^4$，坐标的绝对值不超过 $10^4$。

对于 $40\%$ 的数据，$1 \le n \le 8$，$1 \le h$，$r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $80\%$ 的数据，$1 \le n \le 10^3$，$1 \le h , r \le 10^4$，坐标的绝对值不超过 $10^4$。

对于 $100\%$ 的数据，$1 \le n \le 1\times 10^3$，$1 \le h , r \le 10^9$，$T \le 20$，坐标的绝对值不超过 $10^9$。

## 样例 #1

### 输入

```
3 
2 4 1 
0 0 1 
0 0 3 
2 5 1 
0 0 1 
0 0 4 
2 5 2 
0 0 2 
2 0 4```

### 输出

```
Yes
No
Yes```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP2017 提高组] 奶酪 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：并查集（Union-Find）/ 深度优先搜索（DFS）/ 广度优先搜索（BFS）


### 🗣️ 初步分析
想象一块巨大的奶酪，里面有很多球形空洞，老鼠Jerry想从下表面（z=0）跑到上表面（z=h）。如果两个空洞相交或相切，Jerry就能在它们之间穿梭；如果空洞碰到下表面，Jerry可以进去；碰到上表面，Jerry可以出来。我们的任务是判断Jerry是否能找到这样一条“空洞通道”。

**核心算法选择**：  
- **并查集**：最适合解决“连通性”问题（比如判断两个节点是否在同一个集合中）。我们可以把每个空洞看作一个节点，如果两个空洞相连（相交/相切），就把它们合并到同一个集合。最后检查是否存在一个集合，同时包含与下表面相连的空洞和与上表面相连的空洞。  
- **搜索（DFS/BFS）**：从所有与下表面相连的空洞出发，遍历所有可达的空洞，看是否能到达任何一个与上表面相连的空洞。


### 核心算法流程与可视化设计思路
以**并查集**为例，流程如下：  
1. **初始化**：每个空洞都是一个独立的集合。  
2. **合并上下表面**：如果空洞与下表面相连（zᵢ - r ≤ 0），将其与“下表面集合”合并；如果与上表面相连（zᵢ + r ≥ h），将其与“上表面集合”合并。  
3. **合并相连空洞**：遍历所有空洞对，如果它们相交/相切（距离平方≤4r²），合并它们的集合。  
4. **判断连通性**：检查“下表面集合”和“上表面集合”是否在同一个集合中。  

**可视化设计**：  
- **像素风格**：用8位红白机风格的像素块表示空洞（不同颜色代表不同集合），下表面用绿色条，上表面用红色条。  
- **动画步骤**：  
  - 初始化时，每个空洞是独立的小方块（比如蓝色）。  
  - 合并上下表面时，与下表面相连的空洞变成绿色，与上表面相连的变成红色。  
  - 合并相连空洞时，两个空洞的颜色变成其中一个的颜色（比如从蓝色变成绿色），并播放“叮”的音效。  
  - 最后，如果绿色和红色集合合并，整个屏幕闪烁“成功”字样，播放胜利音效。  


## 2. 精选优质题解参考

### 题解一：并查集（作者：Fading，赞：323）
* **点评**：  
  这份题解是并查集的经典实现，思路清晰，处理了关键的精度问题（用距离平方代替开根号，避免double误差）。代码结构规范，变量命名明确（比如`f`数组表示并查集的父节点，`f1`/`f2`记录与上下表面相连的空洞）。特别值得学习的是**多组数据的处理**（每次测试用例都重新初始化并查集）和**提前剪枝**（计算距离平方时先判断是否超过4r²，避免不必要的计算）。这份代码在UOJ上AC，可靠性高。


### 题解二：DFS（作者：wyx__，赞：5）
* **点评**：  
  这份题解用DFS实现，思路直观（从下表面的空洞出发，遍历所有可达的空洞）。一开始因为“回溯标记”（`v[k]=0`）导致TLE，修改后去掉回溯，避免重复访问，成功AC。这说明**搜索时标记已访问节点是关键**，不需要回溯，因为一旦访问过某个空洞，就不需要再处理它了。代码简洁，适合理解搜索的核心逻辑。


### 题解三：并查集（作者：ikunTLE，赞：11）
* **点评**：  
  这份题解的并查集实现更简洁，用`_init`、`_find`、`_merge`函数封装了并查集的基本操作，代码可读性高。特别注意了**数据类型**（用`long long`避免溢出），这是本题的易错点。此外，用`f1`/`f2`数组记录上下表面的空洞，最后遍历判断是否连通，逻辑清晰。


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何判断两个空洞相连？**
* **问题**：直接计算距离会有精度问题（比如`sqrt`导致的误差），而且数据范围大（坐标绝对值可达1e9），容易溢出。  
* **解决策略**：用**距离平方**代替距离。两个空洞相连的条件是：  
  $$(x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2 \leq (2r)^2$$  
  这样可以避免开根号，且用`long long`存储，不会溢出。  
* 💡 **学习笔记**：处理距离判断时，优先用平方代替开根号，避免精度和溢出问题。


### 2. **难点2：多组数据的处理**
* **问题**：如果忘记清空数组（比如并查集的`f`数组、搜索的`vis`数组），会导致多组数据之间互相干扰，结果错误。  
* **解决策略**：每次处理新的测试用例时，**重新初始化所有数组**（比如`memset`或循环赋值）。  
* 💡 **学习笔记**：多测不清空，爆零两行泪！一定要记得初始化。


### 3. **难点3：选择并查集还是搜索？**
* **问题**：并查集和搜索都能解决连通性问题，该选哪个？  
* **解决策略**：  
  - 并查集更适合**静态连通性**（不需要动态添加边），代码更简洁，时间复杂度为O(n²α(n))（α是阿克曼函数的反函数，几乎可以看作常数）。  
  - 搜索（DFS/BFS）更适合**动态连通性**（比如需要遍历路径），但时间复杂度为O(n²)（最坏情况）。  
  本题中，**并查集是更优的选择**，因为代码更短，且容易处理。  
* 💡 **学习笔记**：连通性问题优先考虑并查集，除非需要遍历路径。


### ✨ 解题技巧总结
- **精度处理**：用距离平方代替开根号。  
- **数据类型**：用`long long`存储坐标和距离，避免溢出。  
- **多组数据**：每次测试用例都要初始化数组。  
- **并查集优化**：路径压缩（`find`函数中让父节点直接指向根节点）和按秩合并（可选，本题中不需要）可以提高效率。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（并查集）
* **说明**：综合了Fading和ikunTLE的题解，是并查集的经典实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;

  const int MAXN = 1005;
  long long f[MAXN]; // 并查集父节点
  long long x[MAXN], y[MAXN], z[MAXN]; // 空洞坐标
  vector<long long> top, bottom; // 与上下表面相连的空洞

  long long find(long long x) {
      if (f[x] != x) f[x] = find(f[x]);
      return f[x];
  }

  void merge(long long x, long long y) {
      long long fx = find(x), fy = find(y);
      if (fx != fy) f[fx] = fy;
  }

  int main() {
      int T;
      cin >> T;
      while (T--) {
          int n, h;
          long long r;
          cin >> n >> h >> r;
          // 初始化并查集
          for (int i = 1; i <= n; ++i) f[i] = i;
          top.clear();
          bottom.clear();
          // 读取空洞坐标，并处理上下表面
          for (int i = 1; i <= n; ++i) {
              cin >> x[i] >> y[i] >> z[i];
              if (z[i] - r <= 0) bottom.push_back(i); // 与下表面相连
              if (z[i] + r >= h) top.push_back(i); // 与上表面相连
          }
          // 合并相连的空洞
          for (int i = 1; i <= n; ++i) {
              for (int j = i + 1; j <= n; ++j) {
                  long long dx = x[i] - x[j];
                  long long dy = y[i] - y[j];
                  long long dz = z[i] - z[j];
                  long long dist_sq = dx*dx + dy*dy + dz*dz;
                  if (dist_sq <= 4*r*r) {
                      merge(i, j);
                  }
              }
          }
          // 判断是否有上下表面的空洞连通
          bool ok = false;
          for (long long t : top) {
              for (long long b : bottom) {
                  if (find(t) == find(b)) {
                      ok = true;
                      break;
                  }
              }
              if (ok) break;
          }
          cout << (ok ? "Yes" : "No") << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **初始化**：每个空洞是独立的集合（`f[i] = i`）。  
  2. **处理上下表面**：将与下表面相连的空洞存入`bottom`数组，与上表面相连的存入`top`数组。  
  3. **合并相连空洞**：遍历所有空洞对，计算距离平方，如果≤4r²，合并它们的集合。  
  4. **判断连通性**：遍历`top`和`bottom`数组，看是否有任何两个空洞在同一个集合中。


### 针对各优质题解的片段赏析

#### 题解一（Fading的并查集）
* **亮点**：提前剪枝（计算距离平方时先判断是否超过4r²，避免不必要的计算）。  
* **核心代码片段**：  
  ```cpp
  for (int j = 1; j <= n; ++j) {
      for (int k = 1; k <= j; ++k) {
          if ((x[j]-x[k])*(x[j]-x[k]) + (y[j]-y[k])*(y[j]-y[k]) > 4*r*r) continue;
          if (dis(x[j], y[j], z[j], x[k], y[k], z[k]) <= 4*r*r) {
              int a1 = find(j);
              int a2 = find(k);
              if (a1 != a2) f[a1] = a2;
          }
      }
  }
  ```
* **代码解读**：  
  这段代码在计算距离平方前，先判断x和y方向的差的平方和是否超过4r²。如果超过，说明距离肯定超过2r，直接跳过，避免计算z方向的差，提高效率。  
* 💡 **学习笔记**：剪枝是优化代码效率的重要手段，能避免不必要的计算。


#### 题解二（wyx__的DFS）
* **亮点**：去掉回溯标记，避免重复访问。  
* **核心代码片段**：  
  ```cpp
  void dfs(int k) {
      if (ok) return;
      if (z[k] + r >= h) {
          ok = 1;
          return;
      }
      v[k] = 1; // 标记已访问
      for (int i = 1; i <= n; ++i) {
          if (!v[i] && e(i, k)) {
              dfs(i);
          }
      }
  }
  ```
* **代码解读**：  
  这段代码中，`v[k] = 1`标记已访问的空洞，不会再回溯（即不会设置`v[k] = 0`）。因为一旦访问过某个空洞，就不需要再处理它了，这样可以避免重复访问，提高效率。  
* 💡 **学习笔记**：搜索时，标记已访问节点是关键，不需要回溯，除非问题要求回溯（比如求所有路径）。


## 5. 算法可视化：像素动画演示（核心部分）

### 🎮 动画演示主题：《Jerry的奶酪冒险》（8位像素风格）


### 📝 设计思路
用8位红白机风格的像素画面，模拟Jerry通过空洞从下表面跑到上表面的过程。通过**单步执行**、**自动播放**等交互，让学习者直观看到并查集的合并过程和连通性判断。


### 🎬 动画帧步骤与交互关键点
1. **场景初始化**：  
   - 屏幕下方是绿色的下表面（z=0），上方是红色的上表面（z=h）。  
   - 中间是多个蓝色的像素块（代表空洞），每个块显示其编号（比如1、2、3）。  
   - 控制面板有“开始”、“单步”、“重置”按钮，以及速度滑块。

2. **合并上下表面**：  
   - 与下表面相连的空洞（zᵢ - r ≤ 0）变成绿色，播放“滴”的音效。  
   - 与上表面相连的空洞（zᵢ + r ≥ h）变成红色，播放“滴”的音效。

3. **合并相连空洞**：  
   - 遍历所有空洞对，计算距离平方。如果≤4r²，两个空洞的颜色变成其中一个的颜色（比如绿色），并播放“叮”的音效。  
   - 单步执行时，每点击一次“单步”，合并一对相连的空洞。

4. **判断连通性**：  
   - 如果绿色（下表面）和红色（上表面）的空洞合并，整个屏幕闪烁“成功！Jerry跑到上表面了！”，播放胜利音效（8位风格的“叮叮咚”）。  
   - 如果没有合并，显示“失败！Jerry被困住了！”，播放失败音效（短促的“嘟嘟”）。


### 🎧 音效设计
- **合并上下表面**：滴（低音量）。  
- **合并相连空洞**：叮（中音量）。  
- **成功**：叮叮咚（高音量，上扬调）。  
- **失败**：嘟嘟（短音，下降调）。


### 🎮 交互设计
- **单步执行**：点击“单步”按钮，逐步合并空洞，观察每一步的变化。  
- **自动播放**：拖动速度滑块选择播放速度（比如1x、2x、3x），动画自动执行。  
- **重置**：点击“重置”按钮，回到初始状态，重新开始。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移
并查集和搜索是解决**连通性问题**的常用算法，适用于以下场景：  
1. **社交网络**：判断两个人是否在同一个朋友圈。  
2. **迷宫问题**：判断迷宫中两个点是否连通。  
3. **电路问题**：判断两个元件是否在同一个电路中。


### 📚 洛谷练习推荐
1. **洛谷 P1551 亲戚**（P1551）  
   - 🗣️ **推荐理由**：并查集的经典入门题，判断两个人是否有亲戚关系，巩固并查集的基本操作。  
2. **洛谷 P2078 朋友**（P2078）  
   - 🗣️ **推荐理由**：并查集的扩展题，需要处理“朋友的朋友是朋友”的关系，练习并查集的合并逻辑。  
3. **洛谷 P1197 星球大战**（P1197）  
   - 🗣️ **推荐理由**：并查集的逆向思维题，需要处理动态删除边的问题，拓展并查集的应用场景。  
4. **洛谷 P3370 字符串哈希**（P3370）  
   - 🗣️ **推荐理由**：虽然不是连通性问题，但需要处理字符串的哈希，练习用哈希避免精度问题（类似本题的距离平方）。


## 7. 学习心得与经验分享 (若有)

### 📝 来自题解作者的经验
- **Fading**：“一开始我用了double计算距离，结果被卡了精度。后来改成距离平方，用long long存储，就AC了。”  
  - **点评**：精度问题是本题的易错点，用平方代替开根号是关键。  
- **wyx__**：“一开始我在DFS里加了回溯（v[k]=0），结果TLE了。后来去掉回溯，就过了。”  
  - **点评**：搜索时标记已访问节点是关键，不需要回溯，避免重复访问。  


## 🎉 总结
本次分析了“奶酪”题的核心算法（并查集、搜索），讲解了难点（精度处理、多组数据、算法选择），并设计了像素动画演示。希望大家通过本次学习，能掌握连通性问题的解决方法，举一反三，解决更多类似问题。

记住：编程的关键是**思路清晰**和**细节处理**，多练习、多思考，你一定会越来越厉害！💪

---
处理用时：139.06秒
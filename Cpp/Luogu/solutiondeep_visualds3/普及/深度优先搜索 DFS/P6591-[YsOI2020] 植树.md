# 题目信息

# [YsOI2020] 植树

## 题目背景


Ysuperman 响应号召，决定在幼儿园里植树。

## 题目描述

Ysuperman 有一棵 $n$ 个节点的无根树 $T$。如果你不知道树是什么，TA 很乐意告诉你，树是一个没有环的无向联通图。

既然树是无根的，那就没有办法种植。Ysuperman 研究了很久的园艺，发现一个节点如果可以成为根，它必须十分平衡，这意味着以它为根时，与它**直接相连的节点，他们的子树大小都相同**。

你作为幼儿园信息组一把手，Ysuperman 给你一棵树，你能在 $1s$ 内找到所有可能成为根的节点吗？

## 说明/提示

### 样例说明

#### 样例说明 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/gsiug69y.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1\}$，因为只有一个所以大小全部相同。

所以答案为 $1,2$。

#### 样例说明 $2$

![](https://cdn.luogu.com.cn/upload/image_hosting/p7fsretv.png)

以 $1$ 为根时，与 $1$ 直接相连的点有 $\{2\}$，因为只有一个所以大小全部相同。

以 $2$ 为根时，与 $2$ 直接相连的点有 $\{1,3\}$，子树大小分别为 $\{1,2\}$，不相同。

以 $3$ 为根时，与 $3$ 直接相连的点有 $\{2,4\}$，子树大小分别为 $\{2,1\}$，不相同。

以 $4$ 为根时，与 $4$ 直接相连的点有 $\{3\}$，因为只有一个所以大小全部相同。

所以答案为 $1,4$。

----

### 数据范围

**本题采用捆绑测试。**

| $\rm{subtask}$ | $n$ |  分数|
| :-----------: | :-----------: | :----: |
| $1$ | $\le 5000$ | $40$ |
| $2$ | $\le 10^6$ | $60$ |

对于 $100\%$ 的数据，满足 $1 \le n\le 10^6$。

------

### 提示

由于输入输出量较大，你可能需要快速输入/输出。

## 样例 #1

### 输入

```
2
1 2
```

### 输出

```
1 2 ```

## 样例 #2

### 输入

```
4
1 2
2 3
3 4
```

### 输出

```
1 4 
```

## 样例 #3

### 输入

```
9
1 2
1 3
4 1
5 1
1 6
1 9
8 1
1 7
```

### 输出

```
1 2 3 4 5 6 7 8 9 
```

# AI分析结果

# 💡 Kay的C++算法解析：[YsOI2020] 植树 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树的DFS遍历与子树大小计算（属于“树的基本操作”）

🗣️ **初步分析**：  
我们需要在一棵无根树中找到所有节点，使得以该节点为根时，**所有直接子节点的子树大小完全相同**。比如，把树想象成一棵“家族树”，每个节点是一位“家长”，直接子节点是“孩子”，我们要找的是“家长”，其每个“孩子”的“家族规模”（子树大小）都一样。  

直接暴力枚举每个节点作为根会超时（时间复杂度$O(n^2)$），因此**核心思路**是：  
1. 任选一个根（比如1号节点），用**一次DFS**计算所有节点的子树大小（$sz[x]$表示以1为根时，$x$的子树大小）。  
2. 对于每个节点$x$，判断：  
   - 若$x$是原根（1号）：所有直接子节点的$sz$是否相同？  
   - 若$x$不是原根：所有直接子节点的$sz$（原根下的子节点）是否相同，且该值等于$n - sz[x]$（原根方向的子树大小，即$x$作为根时，父节点所在子树的大小）？  

**核心算法流程**：  
- DFS遍历树，计算$sz[x]$的同时，记录$x$的子节点的$sz$是否一致（用$num$变量存储第一个子节点的$sz$，后续子节点与$num$比较）。  
- 对于非原根节点，额外判断$num$是否等于$n - sz[x]$。  

**可视化设计思路**：  
用8位像素风格展示树结构（节点为彩色方块，边为线条），颜色深度表示子树大小（越深越大）。动画步骤：  
1. DFS遍历过程：从根节点1出发，逐个访问子节点，节点颜色逐渐变深（表示$sz$计算完成）。  
2. 判断过程：对于每个节点，高亮其直接子节点，显示它们的$sz$值，若全部相同则节点变为绿色（符合条件），否则变为红色。非原根节点额外显示$n - sz[x]$，比较是否等于子节点的$sz$。  
3. 最终结果：所有绿色节点即为答案，播放“胜利”音效。


## 2. 精选优质题解参考

### 题解一：WanderingTrader（来源：洛谷题解区）  
* **点评**：  
  这份题解**思路清晰、代码规范**，完美覆盖了本题的核心逻辑。作者用DFS一次计算子树大小，同时在递归过程中判断每个节点的子节点是否符合条件（用$num$记录第一个子节点的$sz$，后续比较）。对于非原根节点，额外判断$num$是否等于$n - sz[x]$。代码结构简洁，注释到位（比如“$d[x]$表示$x$的子树大小”“$root[x]$表示是否可以作为根”），效率高达$O(n)$，完全满足1e6的数据规模要求。**亮点**：将判断逻辑融入DFS，避免了重复遍历，非常高效。


### 题解二：____OccDreamer（来源：洛谷题解区）  
* **点评**：  
  作者采用“换根”思路，先计算原根1的子树大小，再遍历每个节点，判断其**子节点（除父节点外）的$sz$是否等于$n - sz[i]$**（原根方向的子树大小）。代码中单独处理了根节点1的判断（所有子节点的$sz$是否相同），然后对其他节点遍历邻接表，跳过父节点，比较子节点的$sz$与$n - sz[i]$。**亮点**：通过“换根”的思路，将原根下的子树大小与新根的子树大小关联，逻辑直观。


### 题解三：K2sen（来源：洛谷题解区）  
* **点评**：  
  作者用**两次DFS**解决问题：第一次计算原根1的子树大小；第二次通过“换根”处理，动态调整每个节点的$sz$（当根从$x$转移到子节点$to$时，$sz[x]$减去$sz[to]$，$sz[to]$加上$sz[x]$），然后判断每个节点的条件。代码中用`dfs2`实现换根，逻辑清晰。**亮点**：换根处理的思想可以推广到其他树问题（如树的重心、换根DP），具有启发性。


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何高效计算子树大小？**  
* **分析**：  
  直接枚举每个节点作为根会超时（$O(n^2)$），因此需要用**一次DFS**计算所有节点的子树大小。$sz[x]$的定义是“以1为根时，$x$的子树大小”，计算公式为$sz[x] = 1 + \sum sz[child]$（$child$是$x$的子节点）。  
* 💡 **学习笔记**：  
  树的子树大小计算是基础，需掌握DFS的递归实现（从根出发，逐个访问子节点，累加子树大小）。


### 2. **难点2：如何正确判断每个节点的条件？**  
* **分析**：  
  对于节点$x$，需判断：  
  - 若$x$是原根（1号）：所有直接子节点的$sz$是否相同？  
  - 若$x$不是原根：所有直接子节点的$sz$（原根下的子节点）是否相同，且该值等于$n - sz[x]$（原根方向的子树大小）？  
  例如，原根是1，$x$的父节点是$p$，当$x$作为根时，$p$的子树大小是$n - sz[x]$，而$x$的子节点的$sz$仍为原根下的$sz[child]$，因此这些值必须全部相同。  
* 💡 **学习笔记**：  
  区分“原根”与“非原根”的判断逻辑，非原根节点需额外考虑原根方向的子树大小。


### 3. **难点3：如何处理大数据量？**  
* **分析**：  
  本题$n \leq 1e6$，需使用**邻接表**存储树（避免邻接矩阵的$O(n^2)$空间），并确保DFS的效率（递归深度不超过$n$，但1e6的递归可能导致栈溢出，因此实际中可改用非递归DFS或BFS）。  
* 💡 **学习笔记**：  
  邻接表是树的常用存储结构，对于大数据量问题，需优先选择。


### ✨ 解题技巧总结  
- **技巧A：一次DFS计算子树大小**：避免重复遍历，提高效率。  
- **技巧B：区分原根与非原根的判断逻辑**：非原根节点需考虑原根方向的子树大小。  
- **技巧C：邻接表存储树**：适应大数据量，节省空间。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（综合自WanderingTrader的题解）  
* **说明**：  
  本代码用邻接表存储树，DFS计算子树大小，同时判断每个节点的条件，效率$O(n)$。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;

  const int N = 1e6 + 5;
  vector<int> es[N]; // 邻接表
  bool root[N];      // 标记节点是否可以作为根
  int sz[N];         // 子树大小
  int n;

  int dfs(int x, int fa) {
      root[x] = true; // 初始化为可以作为根
      int num = 0;    // 记录子节点的子树大小（用于比较）
      for (int i = 0; i < es[x].size(); i++) {
          int to = es[x][i];
          if (to == fa) continue; // 跳过父节点
          sz[x] += dfs(to, x);    // 累加子树大小
          if (num == 0) {
              num = sz[to]; // 记录第一个子节点的子树大小
          } else if (num != sz[to]) {
              root[x] = false; // 子节点大小不同，标记为不可作为根
          }
      }
      sz[x]++; // 加上自己
      // 非原根节点，需判断原根方向的子树大小
      if (x != 1 && num != 0 && num != n - sz[x]) {
          root[x] = false;
      }
      return sz[x];
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cin >> n;
      for (int i = 1; i < n; i++) {
          int u, v;
          cin >> u >> v;
          es[u].push_back(v);
          es[v].push_back(u);
      }
      dfs(1, 0);
      for (int i = 1; i <= n; i++) {
          if (root[i]) {
              cout << i << " ";
          }
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. 邻接表`es`存储树的边。  
  2. `dfs`函数递归计算子树大小`sz[x]`，同时判断`x`是否可以作为根（`root[x]`）。  
  3. 主函数读取输入，调用`dfs`，输出所有`root[i]`为`true`的节点。


### 针对各优质题解的片段赏析

#### 题解一：WanderingTrader（核心片段）  
* **亮点**：将判断逻辑融入DFS，避免重复遍历。  
* **核心代码片段**：  
  ```cpp
  int dfs(int x, int fa) {
      root[x] = 1;
      int num = 0;
      for (int i = 0; i < es[x].size(); i++) {
          if (es[x][i] != fa) {
              sz[x] += dfs(es[x][i], x);
              if (!num) num = sz[es[x][i]];
              if (num != sz[es[x][i]]) root[x] = 0;
          }
      }
      sz[x]++;
      if (x != 1 && num && num != n - sz[x]) root[x] = 0;
      return sz[x];
  }
  ```
* **代码解读**：  
  - `root[x] = 1`：初始认为$x$可以作为根。  
  - `num`记录第一个子节点的`sz`，后续子节点与`num`比较，不同则`root[x] = 0`。  
  - `sz[x]++`：加上自己，完成子树大小计算。  
  - 非原根节点判断`num == n - sz[x]`：原根方向的子树大小是否与子节点的`sz`相同。  
* 💡 **学习笔记**：  
  递归过程中同步处理判断逻辑，是高效解决树问题的常用技巧。


#### 题解二：____OccDreamer（核心片段）  
* **亮点**：单独处理根节点，逻辑直观。  
* **核心代码片段**：  
  ```cpp
  // 处理根节点1
  int now = sz[to[head[1]]];
  bool flag = 1;
  for (int i = head[1]; i; i = net[i]) {
      if (sz[to[i]] != now) {
          flag = 0;
          break;
      }
  }
  if (flag) cout << 1 << ' ';

  // 处理其他节点
  for (int i = 2; i <= n; i++) {
      now = sz[1] - sz[i];
      flag = 1;
      for (int j = head[i]; j; j = net[j]) {
          if (to[j] != fa[i] && sz[to[j]] != now) {
              flag = 0;
              break;
          }
      }
      if (flag) cout << i << ' ';
  }
  ```
* **代码解读**：  
  - 根节点1：遍历所有子节点，判断`sz`是否相同。  
  - 其他节点：`now = sz[1] - sz[i]`（原根方向的子树大小），遍历邻接表，跳过父节点，判断子节点的`sz`是否等于`now`。  
* 💡 **学习笔记**：  
  对于特殊节点（如根节点），单独处理可以简化逻辑。


#### 题解三：K2sen（核心片段）  
* **亮点**：换根处理，动态调整子树大小。  
* **核心代码片段**：  
  ```cpp
  void dfs2(int x, int fa) {
      // 判断x是否可以作为根
      int sy = sz[edge[head[x]].to], flag = 0;
      for (int i = head[x]; i; i = edge[i].next) {
          int to = edge[i].to;
          if (sy != sz[to]) {
              flag = 1;
              break;
          }
      }
      if (flag == 0) ans[++cnt] = x;

      // 换根处理
      for (int i = head[x]; i; i = edge[i].next) {
          int to = edge[i].to;
          if (to == fa) continue;
          sz[x] -= sz[to];
          sz[to] += sz[x];
          dfs2(to, x);
          sz[to] -= sz[x];
          sz[x] += sz[to];
      }
  }
  ```
* **代码解读**：  
  - `dfs2`函数判断$x$是否可以作为根，然后递归处理子节点。  
  - 换根处理：当根从$x$转移到$to$时，$sz[x]$减去$sz[to]$（$x$的子树大小减少$to$的子树），$sz[to]$加上$sz[x]$（$to$的子树大小增加$x$的子树）。  
* 💡 **学习笔记**：  
  换根处理是树问题中的高级技巧，可用于动态计算不同根的子树大小。


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：“树的根节点寻找之旅”（8位像素风格）  
### 核心演示内容：  
- DFS计算子树大小的过程。  
- 每个节点的判断过程（子节点大小是否相同，非原根节点是否符合额外条件）。  
- 符合条件的节点标记（绿色）。


### 设计思路简述：  
采用8位像素风格（类似FC红白机），节点为彩色方块（大小20x20像素），边为白色线条。颜色深度表示子树大小（蓝色，越深越大）。动画通过“单步执行”“自动播放”控制，配合音效（如DFS访问节点时的“叮”声，判断符合条件时的“滴”声），增强趣味性。


### 动画帧步骤与交互关键点：  
1. **初始化**：  
   - 屏幕显示树结构（根节点1位于中心，子节点向四周扩散）。  
   - 控制面板：“开始”“单步”“重置”按钮，速度滑块（1-5倍速）。  
   - 背景音乐：8位风格的轻快旋律。  

2. **DFS遍历过程**：  
   - 根节点1变为浅蓝色（表示开始访问）。  
   - 递归访问子节点，每个子节点变为浅蓝色，然后逐渐变深（表示子树大小计算完成）。  
   - 访问完成后，节点变为深蓝色（表示$sz$计算完成）。  

3. **判断过程**：  
   - 对于每个节点，高亮其直接子节点（黄色边框）。  
   - 显示子节点的$sz$值（白色文字），若全部相同，节点变为绿色（符合条件），播放“滴”声；否则变为红色（不符合条件）。  
   - 非原根节点额外显示$n - sz[x]$（红色文字），比较是否等于子节点的$sz$，若不同则节点变为红色。  

4. **结果展示**：  
   - 所有绿色节点闪烁，播放“胜利”音效（上扬的8位音调）。  
   - 屏幕底部显示“答案：[节点列表]”（白色文字）。


### 技术实现考量：  
- **Canvas绘制**：用`canvas`元素绘制节点和边，`fillRect`绘制节点，`lineTo`绘制边。  
- **颜色方案**：节点颜色用`rgb(0, 0, 255)`（蓝色），深度根据$sz$调整（$sz$越大，蓝色越深）。  
- **音效**：用`Web Audio API`播放8位音效（如`beep`声），关键操作（访问节点、判断符合条件）触发不同音效。  
- **交互**：用`addEventListener`处理按钮点击和滑块调整，控制动画播放速度和步骤。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移：  
树的子树大小计算是很多树问题的基础，例如：  
- **树的重心**：寻找一个节点，使得其所有子树的大小都不超过$n/2$（需计算子树大小）。  
- **换根DP**：动态计算不同根的树的某些属性（如路径和、子树和，需换根处理）。  
- **树的直径**：寻找树中最长路径（需计算子树大小和深度）。


### 练习推荐（洛谷）：  
1. **洛谷 P1395 会议**：  
   - 🗣️ **推荐理由**：考察树的重心，需要计算子树大小，判断每个节点的子树是否符合条件（类似本题的判断逻辑）。  
2. **洛谷 P2986 [USACO10MAR] Great Cow Gathering G**：  
   - 🗣️ **推荐理由**：考察换根DP，需要动态调整子树大小，计算不同根的路径和（换根处理的经典问题）。  
3. **洛谷 P3379 【模板】最近公共祖先（LCA）**：  
   - 🗣️ **推荐理由**：考察树的遍历和子树大小，LCA的预处理（如深度、父节点）需要DFS遍历（类似本题的DFS过程）。


## 7. 学习心得与经验分享（若有）

### 参考经验（来自WanderingTrader）：  
> “多叉树的操作题相对二叉树来说可能较为简单，主要就是dfs要写对。有些常见操作（比如求结点大小，求结点深度）等可以打成模板存好，要用的时候可以借鉴一下。”  

**点评**：  
作者的经验提醒我们，**积累模板**是提高编程效率的关键。对于树的基本操作（如子树大小计算、深度计算），可以将代码打成模板，需要时直接复用，避免重复编写。


### 参考经验（来自____OccDreamer）：  
> “当我们选择一个新的点当作根时，改变了子树大小的只有那个点的父节点。”  

**点评**：  
作者的观察非常敏锐，**树的结构变化具有局部性**（换根时只有父节点的子树大小变化）。这一规律可以帮助我们避免重复计算，提高算法效率（如本题的换根思路）。


## 结语  
本次关于“[YsOI2020] 植树”的C++解题分析就到这里。希望这份指南能帮助大家理解树的子树大小计算、DFS遍历以及换根处理的技巧。记住，**树的问题核心是遍历**，掌握DFS和BFS的基本方法，再结合具体问题的逻辑，就能解决大多数树问题。下次我们再一起探索新的编程挑战！💪

---
处理用时：245.85秒
# 题目信息

# [COCI 2015/2016 #3] MOLEKULE

## 题目描述

有 $N$ 个点和 $N-1$ 条无向边，定义一张有向图的代价为一条在这张有向图上的最长通路长度。

现在把这 $N-1$ 条无向边指定方向，使得形成的有向图代价最小。

求一种指定方向的方案。

## 说明/提示

#### 样例 1 解释

如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/f1q6jgtu.png)

这张图的代价为 $1$，注意 $0\ 1$ 也是一组最优解。

#### 样例 2 解释

如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/96aku20f.png)

#### 数据规模与约定

对于 $30\%$ 的数据，$N \le 20$。       
对于 $100\%$ 的数据，$2 \le N \le 10^5$，$1 \le a_i,b_i\le N$。

**本题采用 Special Judge。**        
你只需要输出任意一种合法方案。

#### 说明

翻译自 [COCI 2015-2016 #3 C MOLEKULE](https://hsin.hr/coci/archive/2015_2016/contest3_tasks.pdf)。

## 样例 #1

### 输入

```
3
1 2
2 3```

### 输出

```
1
0```

## 样例 #2

### 输入

```
4
2 1
1 3
4 1```

### 输出

```
0
1
0```

# AI分析结果

# 💡 Kay的C++算法解析：MOLEKULE 深入学习指南 💡

<introduction>
今天我们来一起分析COCI2015-2016赛季的经典题目《MOLEKULE》。这道题看似是“给树的边定方向”，实则藏着**二分图染色**的巧妙思想——我们要把树变成一个“没有长路径的有向图”。本指南会帮你理清思路、掌握核心算法，还能通过像素动画直观看到算法运行过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（树结构）+ 二分图染色应用

🗣️ **初步分析**：
题目给了一棵无向树（N个点N-1条边，必然连通无环），要求给每条边定方向，让**最长通路最短**。什么是“最长通路”？比如1→2→3的通路长度是2，而我们的目标是让这个值尽可能小。

那最短能有多小？答案是**1**！怎么做到？其实树是天生的**二分图**——我们可以把节点分成两组（比如“奇数层”和“偶数层”），相邻节点一定属于不同组。只要让边都从一组指向另一组（比如奇数层→偶数层，或反过来），那么任何通路最多只有1步（因为下一个节点属于另一组，无法再往前走）。

举个例子：树的根是1（深度0，偶数层），它的子节点深度1（奇数层），边方向是1→子节点；子节点的子节点深度2（偶数层），边方向是子节点←孙子节点。这样所有通路都是“父→子”或“子→父”，最长只有1！

**核心算法流程**：
1. 选一个根节点（比如1号），用DFS/BFS遍历树，记录每个节点的**深度**（根深度为0）。
2. 对于每条边（u, v），如果v的深度是奇数，边方向设为u→v（输出0或1，看题目要求）；如果是偶数，设为v→u。
3. 按输入顺序输出每条边的方向。

**可视化设计思路**：
我们会做一个**8位像素风格的树动画**：
- 节点用彩色方块表示：根节点（深度0）是蓝色，深度1是红色，深度2是蓝色，以此类推（奇偶交替）。
- 边用箭头表示：从奇数层指向偶数层时，箭头是黄色；反过来是绿色。
- 单步执行DFS：高亮当前处理的节点（闪烁），用“叮”的音效提示“正在计算深度”，用“咻”的音效提示“确定边方向”。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3篇优质题解，一起来看看它们的亮点！
</eval_intro>

**题解一：来源：AzzyZhe（赞12）**
* **点评**：这篇题解的**反向边处理**非常巧妙！作者用两倍空间存无向边（原边存在1~MAXN，反向边存在MAXN+1~2*MAXN），通过边的下标判断是否是原边，从而决定是否调换方向。DFS过程中用`f`变量（奇偶交替）标记当前节点的“组别”，直接映射到边的方向。代码逻辑简洁，尤其是反向边的处理方式，完美解决了“无向边转有向边”的问题，值得学习！

**题解二：来源：Computer1828（赞8）**
* **点评**：这篇题解把**深度奇偶性**的核心思想讲得最直白！作者直接用`dep[u]`记录节点u的深度，然后根据父节点的深度奇偶性决定边方向：父节点深度是奇数，边是父→子；偶数则是子→父。代码中的`ans[id]`计算非常直接，甚至提到“输出0和1反过来也不影响结果”，帮我们理解了问题的对称性，很有启发性！

**题解三：来源：liujy_（赞4）**
* **点评**：这篇题解的**链式前向星存图**非常高效！对于N=1e5的大数据，链式前向星比vector更省空间、更快。作者用`e[i*2-1]`直接取第i条边的原始存储（因为无向边存了两条，第i条的正向是2i-1，反向是2i），然后根据子节点的深度奇偶性输出0或1。这种“精准定位边”的技巧，在处理大规模图问题时非常实用！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键不是“写代码”，而是“想清楚怎么定方向”。以下三个难点是大家最容易卡壳的地方，我们逐一解决：
</difficulty_intro>

1. **难点1：如何确定边的方向策略？**
    * **分析**：核心是“二分图染色”——树的节点可以按深度奇偶分成两组，相邻节点必在不同组。边从一组指向另一组，就能保证最长通路为1。比如根节点深度0（组A），子节点深度1（组B），边A→B；子节点的子节点深度2（组A），边B←A。这样任何通路都无法超过1步。
    * 💡 **学习笔记**：树是二分图，用深度奇偶性分组是“定方向”的关键！

2. **难点2：如何处理无向边的反向存储？**
    * **分析**：无向边需要存两条（u→v和v→u），但输出时要按输入顺序。解决方法有两种：① 用两倍空间存边，标记原边和反向边（如AzzyZhe的方法）；② 记录每条边的原始输入顺序（如liujy_用`e[i*2-1]`取原边）。
    * 💡 **学习笔记**：无向边转有向边，一定要“标记原始边”，否则会输出错误！

3. **难点3：如何保证输出顺序正确？**
    * **分析**：输入的边是乱序的，而输出需要按输入顺序。解决方法是**记录每条边的编号**：比如用结构体存边时，加上`id`字段（代表输入的第几条边），最后按`id`从小到大输出方向。
    * 💡 **学习笔记**：处理“按输入顺序输出”的问题，一定要提前记录边的编号！

### ✨ 解题技巧总结
- **技巧1：树的二分图性质**：树是无环的，必然是二分图，用深度奇偶性分组是“定方向”的万能钥匙。
- **技巧2：链式前向星存图**：对于N=1e5的大数据，链式前向星比vector更高效，适合处理大规模图问题。
- **技巧3：边的编号记录**：处理无向边时，一定要记录每条边的输入顺序，否则输出会乱！


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一个**通用核心实现**——综合了优质题解的思路，用vector存图，记录边的编号，DFS计算深度，最后按输入顺序输出方向。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码用vector存图，记录每条边的编号，DFS计算节点深度，最后根据子节点的深度奇偶性输出方向。逻辑清晰，适合入门学习。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;

const int MAXN = 1e5 + 5;
int n;
struct Edge { int v, id; }; // v是邻接点，id是边的输入编号
vector<Edge> g[MAXN];
int dep[MAXN]; // dep[u]是节点u的深度
int ans[MAXN]; // ans[id]是第id条边的方向（0或1）

// 输入的边的原始信息：第i条边是u[i]→v[i]
int u[MAXN], v[MAXN];

void dfs(int x, int fa) {
    dep[x] = dep[fa] + 1; // 深度=父节点深度+1
    for (auto &e : g[x]) {
        int y = e.v;
        if (y == fa) continue; // 避免回父节点
        dfs(y, x);
        // 根据子节点y的深度奇偶性决定边方向
        if (dep[y] % 2 == 1) {
            // 如果y是奇数层，边方向是x→y（对应输入的u→v吗？要看x是不是u）
            if (x == u[e.id]) ans[e.id] = 0; // u→v输出0
            else ans[e.id] = 1; // v→u输出1（因为输入是u→v，所以反向要输出1）
        } else {
            if (x == u[e.id]) ans[e.id] = 1;
            else ans[e.id] = 0;
        }
    }
}

int main() {
    cin >> n;
    for (int i = 1; i < n; i++) {
        cin >> u[i] >> v[i];
        g[u[i]].push_back({v[i], i});
        g[v[i]].push_back({u[i], i});
    }
    dep[0] = -1; // 根节点1的父节点是0，深度0
    dfs(1, 0);
    for (int i = 1; i < n; i++) {
        cout << ans[i] << endl;
    }
    return 0;
}
```
* **代码解读概要**：
  1. 输入阶段：用vector存无向边，每条边记录邻接点和输入编号。
  2. DFS阶段：计算每个节点的深度，从根节点1开始（父节点0，深度-1，所以根深度是0）。
  3. 方向决策：对于每条边（x,y），如果y是奇数层，边方向是x→y；否则是y→x。根据x是否是输入的u[i]，决定输出0或1。
  4. 输出阶段：按输入顺序输出每条边的方向。

<code_intro_selected>
接下来我们看优质题解的核心片段，学习它们的亮点！
</code_intro_selected>

**题解一：AzzyZhe的反向边处理**
* **亮点**：用两倍空间存反向边，通过边的下标判断是否是原边，巧妙解决方向问题。
* **核心代码片段**：
```cpp
#define MAXN 100001
bool towards[MAXN]; // 记录第i条边是否调换方向
bool f = 0; // 奇偶标记，0或1交替

void dfs(int p) {
    if (vis[p]) return;
    vis[p] = 1;
    f ^= 1; // 奇偶交替
    for (int i = head[p]; i; i = e[i].next) {
        if (vis[e[i].v]) continue;
        if (i > MAXN) towards[i - MAXN] = f ^ 1; // 反向边，方向取反
        else towards[i] = f; // 原边，方向是f
        dfs(e[i].v);
    }
    f ^= 1;
}
```
* **代码解读**：
  - 原边存在1~MAXN，反向边存在MAXN+1~2*MAXN。
  - `f`变量记录当前节点的“组别”（0或1），每次进入节点时翻转。
  - 处理反向边时，方向取`f^1`（因为反向边的方向和原边相反）。
* 💡 **学习笔记**：反向边的处理可以用“下标偏移”的技巧，简单又高效！

**题解二：Computer1828的深度奇偶性直接应用**
* **亮点**：直接根据父节点的深度奇偶性决定边方向，逻辑最直白。
* **核心代码片段**：
```cpp
int dep[N], ans[N];
vector<pair<int, int>> e[N]; // e[u]存（v, id）

void dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;
    for (auto &p : e[u]) {
        int v = p.first, id = p.second;
        if (v == fa) continue;
        if (dep[u] % 2 == 1) ans[id] = (U[id] == u) ? 1 : 0;
        else ans[id] = (U[id] == v) ? 1 : 0;
        dfs(v, u);
    }
}
```
* **代码解读**：
  - `dep[u]`是父节点的深度，`dep[u]%2`判断父节点的组别。
  - 如果父节点是奇数层，边方向是父→子（`U[id]==u`则输出1）；否则是子→父（`U[id]==v`则输出1）。
* 💡 **学习笔记**：直接用深度奇偶性判断方向，是最直观的实现方式！

**题解三：liujy_的链式前向星存图**
* **亮点**：用链式前向星存图，高效处理大规模数据。
* **核心代码片段**：
```cpp
struct node { int u, to, next; } e[200005];
int head[200005], cnt;

void add(int u, int v) {
    e[++cnt] = {u, v, head[u]};
    head[u] = cnt;
}

void dfs(int x, int fa) {
    for (int i = head[x]; i; i = e[i].next) {
        int v = e[i].to;
        if (v == fa) continue;
        d[v] = d[x] + 1;
        dfs(v, x);
    }
}

int main() {
    for (int i = 1; i < n; i++) {
        int x = e[i*2-1].u, y = e[i*2-1].to;
        printf("%d\n", d[y] & 1);
    }
}
```
* **代码解读**：
  - 链式前向星用`head`数组存每个节点的边链表头，`e`数组存边信息。
  - 无向边存两条，第i条边的正向是`i*2-1`，反向是`i*2`。
  - 输出时直接取第i条边的正向（`e[i*2-1]`），根据子节点y的深度奇偶性输出0或1。
* 💡 **学习笔记**：链式前向星是处理大规模图的“神器”，一定要掌握！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地看到**DFS遍历+奇偶深度分组**的过程，我设计了一个**8位像素风格的动画**，像玩FC游戏一样学算法！
</visualization_intro>

### **动画设计方案**
#### **1. 整体风格**
- **8位像素风**：参考FC《超级马里奥》的配色，节点用16x16的彩色方块，边用2x2的线条，箭头用8x8的像素图标。
- **背景**：浅灰色网格（模拟“树的生长空间”），顶部有“控制面板”（开始/暂停、单步、重置按钮），底部有“状态提示栏”（显示当前处理的节点、深度、边方向）。

#### **2. 核心演示内容**
- **节点颜色**：根节点（1号）是**蓝色**（深度0，偶数层），子节点是**红色**（深度1，奇数层），孙子节点是**蓝色**（深度2，偶数层），以此类推（奇偶交替）。
- **边方向**：从蓝色节点到红色节点的边是**黄色箭头**（输出0），从红色节点到蓝色节点的边是**绿色箭头**（输出1）。
- **DFS过程**：
  1. **初始化**：根节点1闪烁（表示开始），背景播放8位风格的“启动音效”（叮~）。
  2. **单步执行**：点击“单步”按钮，DFS进入子节点（比如1→2），子节点2变成红色，边1→2变成黄色，状态提示栏显示“处理节点2，深度1，边1→2方向0”，同时播放“处理音效”（咻~）。
  3. **递归深入**：继续单步，DFS进入2的子节点（比如2→3），节点3变成蓝色，边2→3变成绿色，提示栏显示“处理节点3，深度2，边2→3方向1”。
  4. **回溯**：当节点没有子节点时，DFS回溯到父节点，节点颜色变暗（表示已处理），提示栏显示“回溯到节点2”。

#### **3. 交互设计**
- **控制面板**：
  - 开始/暂停：控制动画播放/暂停。
  - 单步：逐步骤执行DFS，适合仔细观察。
  - 重置：回到初始状态，重新开始。
  - 速度滑块：调整动画播放速度（从“慢”到“快”）。
- **音效设计**：
  - 启动音效：叮~（提示开始）。
  - 处理节点：咻~（提示正在计算深度）。
  - 确定边方向：咔~（提示边方向已确定）。
  - 完成：噔噔噔~（提示所有边方向已确定）。

#### **4. 游戏化元素**
- **关卡设计**：把树的遍历分成“根节点层→子节点层→孙子节点层”三个小关卡，完成每个关卡时，屏幕弹出“关卡完成！”的像素文字，同时加10分。
- **积分系统**：每处理一个节点加5分，每确定一条边方向加10分，总积分显示在控制面板右上角，激励你“通关”。

<visualization_conclusion>
通过这个动画，你能**亲眼看到**树的深度如何计算，边的方向如何根据奇偶性确定。就像玩游戏一样，轻松掌握核心算法！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是“树的二分图染色”，这种思路能解决很多类似问题。比如：
</similar_problems_intro>

### **通用思路迁移**
- **问题1**：给树的节点染色，相邻节点颜色不同（二分图染色模板题）。
- **问题2**：判断一个图是否是二分图（DFS/BFS遍历，看是否有矛盾）。
- **问题3**：给树的边定向，使得每个节点的入度不超过k（类似的构造问题）。

### **洛谷练习推荐**
1. **洛谷 P1330 [NOIP2011 提高组] 封锁阳光大学**
   - 🗣️ **推荐理由**：这是二分图染色的经典题，要求用最少的点封锁所有边，和本题的“边定向”思路异曲同工。
2. **洛谷 P2055 [ZJOI2009] 假期的宿舍**
   - 🗣️ **推荐理由**：需要建图后用二分图匹配，锻炼你“将问题转化为二分图”的能力。
3. **洛谷 P3384 【模板】树链剖分**
   - 🗣️ **推荐理由**：树链剖分是处理树结构的高级技巧，本题的DFS遍历是树链剖分的基础，值得练习！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“经验之谈”能帮我们少走弯路，一起来看看：
</insights_intro>

> **参考经验（来自AzzyZhe）**：“我一开始没考虑反向边的处理，结果输出全错。后来用MAXN偏移存反向边，问题就解决了。”
>
> **点评**：反向边的处理是本题的“隐藏陷阱”！AzzyZhe的经验提醒我们：无向边转有向边时，一定要**标记原边和反向边**，否则会混淆方向。这种“下标偏移”的技巧，在处理类似问题时非常有用！

> **参考经验（来自liujy_）**：“链式前向星比vector快很多，对于N=1e5的大数据，必须用链式前向星。”
>
> **点评**：数据规模大时，选择合适的数据结构很重要！链式前向星的时间复杂度是O(N)，而vector的插入操作是O(1)但常数更大，所以链式前向星更适合大规模图问题。


<conclusion>
本次关于《MOLEKULE》的分析就到这里啦！这道题的核心是“树的二分图性质”，用DFS遍历+奇偶深度分组就能解决。记住：**树是天生的二分图**，遇到树的构造问题，先想二分图染色！

编程能力的提升，在于“理解思想”+“多练相似题”。下次遇到树的问题，试着用今天学的思路解决吧！💪
</conclusion>

---
处理用时：119.41秒
# 题目信息

# [蓝桥杯 2023 省 B] 飞机降落

## 题目描述

$N$ 架飞机准备降落到某个只有一条跑道的机场。其中第 $i$ 架飞机在 $T_{i}$ 时刻到达机场上空，到达时它的剩余油料还可以继续盘旋 $D_{i}$ 个单位时间，即它最早可以于 $T_{i}$ 时刻开始降落，最晩可以于 $T_{i}+D_{i}$ 时刻开始降落。降落过程需要 $L_{i}$ 个单位时间。

一架飞机降落完毕时，另一架飞机可以立即在同一时刻开始降落，但是不能在前一架飞机完成降落前开始降落。

请你判断 $N$ 架飞机是否可以全部安全降落。

## 说明/提示

**【样例说明】**

对于第一组数据，可以安排第 3 架飞机于 0 时刻开始降落，20 时刻完成降落。安排第 2 架飞机于 20 时刻开始降落，30 时刻完成降落。安排第 1 架飞机于 30 时刻开始降落，40 时刻完成降落。

对于第二组数据，无论如何安排，都会有飞机不能及时降落。

**【评测用例规模与约定】**

对于 $30 \%$ 的数据，$N \leq 2$。

对于 $100 \%$ 的数据，$1 \leq T \leq 10$，$1 \leq N \leq 10$，$0 \leq T_{i},D_{i},L_{i} \leq 10^{5}$。 

蓝桥杯 2023 省赛 B 组 D 题。

## 样例 #1

### 输入

```
2
3
0 100 10
10 10 10
0 2 20
3
0 10 20
10 10 20
20 10 20```

### 输出

```
YES
NO```

# AI分析结果

# 💡 Kay的C++算法解析：飞机降落 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：深度优先搜索（DFS）- 排列枚举与剪枝  

🗣️ **初步分析**：  
解决“飞机降落”问题，关键在于**枚举所有可能的降落顺序**，并检查是否存在一种顺序，让每架飞机都能在允许的时间内（最早`T_i`，最晚`T_i+D_i`）完成降落。  
可以把这个过程比作“给飞机排座位”：我们需要尝试所有可能的排列，每个排列对应一种降落顺序，然后逐个检查每个顺序是否符合规则。由于`N≤10`（最多10架飞机），全排列的数量是`10! = 3628800`，这个规模对于计算机来说完全可以处理。  

**核心算法流程**：  
- 用DFS递归枚举所有可能的降落顺序（每一步选择一架未降落的飞机）。  
- 对于每个选择，检查该飞机是否能在当前时间（上一架飞机降落完成的时间）之后开始降落（即`当前时间 ≤ T_i+D_i`）。  
- 如果可以，更新当前时间为`max(当前时间, T_i) + L_i`（确保不早于飞机到达时间，加上降落时间），继续递归处理下一架飞机。  
- 如果所有飞机都处理完毕（递归到叶子节点），说明存在可行方案。  

**可视化设计思路**：  
我们可以用**8位像素风格**模拟机场跑道和飞机。比如：  
- 用不同颜色的像素块表示“未降落”（绿色）、“已降落”（灰色）、“当前选择”（黄色）的飞机。  
- 屏幕上方显示“当前时间”（数字），下方显示“跑道状态”（正在降落的飞机用闪烁的像素块表示）。  
- 当选择一架飞机时，播放“叮”的音效；如果该飞机无法降落（最晚时间已过），播放“ buzz”的错误音效；当所有飞机降落完成，播放“胜利”音效。  


## 2. 精选优质题解参考

### 题解一：（来源：CYZZ）  
* **点评**：这份题解的思路非常清晰，直接用DFS枚举所有降落顺序，逻辑直白易懂。代码风格规范，变量名（如`dep`表示当前处理到第几个飞机，`tim`表示当前时间）含义明确，边界处理（用`max(tim, a[i].t)`确保不早于飞机到达时间）非常严谨。其亮点在于**剪枝条件**（`a[i].t+a[i].d < tim`时跳过该飞机），避免了无效的递归调用，大大提高了搜索效率。从实践角度看，代码可直接用于竞赛，边界处理非常到位，是学习DFS枚举排列的典型例子。  

### 题解二：（来源：wuyin331）  
* **点评**：此题解在DFS的基础上加入了**更严格的剪枝**（如果存在未降落飞机的最晚时间小于当前时间，直接返回），进一步优化了搜索效率。代码中用`flag`标记是否找到可行方案，一旦找到就立即终止所有递归，减少了不必要的计算。此外，结构体`Node`将飞机的`l`（最早时间）、`r`（最晚时间）、`t`（降落时间）封装在一起，提高了代码的可读性。  

### 题解三：（来源：icypenguin）  
* **点评**：这份题解的亮点在于**提前终止搜索**（用`flag`标记，一旦找到解就停止所有递归），避免了重复计算。代码中`llast`参数表示上一架飞机降落的时间，逻辑清晰。此外，输入处理部分用`memset`清空标记数组，符合竞赛代码的规范。  


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何设计DFS的状态？**  
* **分析**：DFS的状态需要包含**当前处理到第几个飞机**（`dep`）和**当前时间**（`tim`）。`dep`用于判断是否处理完所有飞机（递归终止条件），`tim`用于检查下一架飞机是否能降落。例如，CYZZ的题解中，`dfs(dep+1, max(tim, a[i].t)+a[i].l)`表示处理完第`dep`架飞机后，当前时间更新为第`i`架飞机降落完成的时间，继续处理第`dep+1`架飞机。  
* 💡 **学习笔记**：状态设计要包含“当前进度”和“当前环境”（如时间），这样才能正确传递信息。  

### 2. **关键点2：如何剪枝？**  
* **分析**：剪枝是提高DFS效率的关键。常见的剪枝条件有：  
  - 若当前飞机的最晚时间（`T_i+D_i`）小于当前时间（`tim`），则跳过该飞机（无法降落）。  
  - 若存在未降落飞机的最晚时间小于当前时间，直接返回（不可能有解）。  
  例如，wuyin331的题解中，`if(!vis[i]&&fj[i].r<now) return ;`就是一个有效的剪枝，提前终止了无效的搜索路径。  
* 💡 **学习笔记**：剪枝的核心是“排除不可能的情况”，减少递归的次数。  

### 3. **关键点3：如何处理边界条件？**  
* **分析**：边界条件包括“当前时间比飞机最早时间早”（此时飞机只能在`T_i`时刻开始降落）和“所有飞机都处理完毕”（返回true）。例如，CYZZ的题解中，`max(tim, a[i].t)`确保了飞机不会在到达前开始降落，`if(dep>n) return 1;`表示所有飞机都降落完成，返回可行。  
* 💡 **学习笔记**：边界条件是算法的“出口”，必须考虑全面，否则会出现逻辑错误。  

### ✨ 解题技巧总结  
- **排列枚举**：对于`N≤10`的问题，DFS枚举全排列是可行的。  
- **剪枝优化**：通过判断“无法降落”的情况，提前终止无效搜索。  
- **状态传递**：将当前时间作为参数传递，确保每一步的决策都基于正确的环境。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了CYZZ、wuyin331等优质题解的思路，提供一个清晰、完整的核心实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <cstring>
  #include <algorithm>
  using namespace std;

  const int MAXN = 15;
  struct Plane {
      int t, d, l; // 最早时间、可盘旋时间、降落时间
  } a[MAXN];
  int n, T;
  bool used[MAXN]; // 标记飞机是否已降落

  bool dfs(int dep, int tim) {
      if (dep > n) return true; // 所有飞机都降落完成
      for (int i = 1; i <= n; ++i) {
          if (!used[i] && a[i].t + a[i].d >= tim) { // 未降落且能降落
              used[i] = true;
              int new_tim = max(tim, a[i].t) + a[i].l; // 更新当前时间
              if (dfs(dep + 1, new_tim)) {
                  used[i] = false;
                  return true; // 找到可行方案，返回
              }
              used[i] = false; // 回溯，取消标记
          }
      }
      return false; // 所有情况都试过，无解
  }

  int main() {
      cin >> T;
      while (T--) {
          cin >> n;
          for (int i = 1; i <= n; ++i) {
              cin >> a[i].t >> a[i].d >> a[i].l;
          }
          memset(used, false, sizeof(used));
          if (dfs(1, 0)) {
              cout << "YES" << endl;
          } else {
              cout << "NO" << endl;
          }
      }
      return 0;
  }
  ```  
* **代码解读概要**：  
  代码分为三部分：  
  1. **输入处理**：读取测试用例数`T`，每个测试用例读取`n`架飞机的`t`、`d`、`l`。  
  2. **DFS函数**：递归枚举所有降落顺序，检查每个顺序是否可行。`dep`表示当前处理到第几个飞机，`tim`表示当前时间。  
  3. **主函数**：调用DFS，输出结果。  

### 针对各优质题解的片段赏析  

#### 题解一（来源：CYZZ）  
* **亮点**：剪枝条件简洁，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  bool dfs(int dep, int tim) {
      if (dep > n) return 1;
      for (int i = 1; i <= n; ++i) {
          if (bk[i] || a[i].t + a[i].d < tim) continue; // 剪枝：已降落或无法降落
          bk[i] = 1;
          if (dfs(dep + 1, max(tim, a[i].t) + a[i].l)) {
              bk[i] = 0;
              return 1;
          }
          bk[i] = 0;
      }
      return 0;
  }
  ```  
* **代码解读**：  
  - `bk[i]`标记飞机是否已降落，`a[i].t + a[i].d < tim`表示该飞机无法降落（最晚时间已过），跳过。  
  - `max(tim, a[i].t) + a[i].l`计算该飞机降落完成的时间，确保不早于飞机到达时间。  
  - 一旦找到可行方案（`dfs`返回`1`），立即返回，减少递归次数。  
* 💡 **学习笔记**：剪枝是DFS的“加速器”，能大大提高效率。  

#### 题解二（来源：wuyin331）  
* **亮点**：更严格的剪枝，提前终止无效搜索。  
* **核心代码片段**：  
  ```cpp
  void dfs(int deep, int now) {
      if (deep == n) { flag = 1; return; }
      for (int i = 1; i <= n; ++i) {
          if (!vis[i] && fj[i].r < now) return; // 剪枝：存在未降落飞机无法降落
          if (!vis[i] && fj[i].r >= now) {
              vis[i] = 1;
              int new_now = (fj[i].l > now) ? (fj[i].l + fj[i].t) : (now + fj[i].t);
              dfs(deep + 1, new_now);
              vis[i] = 0;
          }
      }
  }
  ```  
* **代码解读**：  
  - `fj[i].r`是飞机的最晚时间（`T_i+D_i`），`if (!vis[i] && fj[i].r < now) return;`表示如果有未降落的飞机无法降落，直接返回，终止当前路径的搜索。  
  - `new_now`的计算用了条件表达式，等价于`max(now, fj[i].l) + fj[i].t`，逻辑正确。  
* 💡 **学习笔记**：剪枝的条件越严格，搜索效率越高，但要注意不要漏掉可行情况。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**像素机场：飞机降落大挑战**（仿FC红白机风格）  

### 设计思路  
采用8位像素风格，模拟机场跑道和飞机，用简单的图形和音效让学习者直观看到DFS的过程。通过“单步执行”和“自动播放”功能，学习者可以慢慢观察每一步的决策，理解剪枝的作用。  

### 动画帧步骤与交互关键点  

#### 1. 场景初始化（8位像素风）  
- 屏幕左侧显示`n`架飞机（绿色像素块，标注编号`1~n`），右侧显示“当前时间”（数字，初始为0）。  
- 下方有“开始”“单步”“重置”按钮，以及“速度滑块”（调整自动播放速度）。  
- 背景播放8位风格的轻松背景音乐（如《超级马里奥》的背景音乐片段）。  

#### 2. 算法启动（DFS开始）  
- 点击“开始”按钮，动画开始。首先，`dep=1`（处理第1架飞机），`tim=0`（当前时间）。  
- 枚举所有未降落的飞机（绿色块），逐个检查是否能降落（`T_i+D_i >= tim`）。  

#### 3. 核心步骤演示（单步执行）  
- **选择飞机**：用黄色像素块标记当前选中的飞机（如第3架），播放“叮”的音效。  
- **检查条件**：如果该飞机的最晚时间（`T_i+D_i`）≥当前时间（`tim`），则继续；否则，播放“buzz”音效，跳过该飞机。  
- **更新时间**：计算该飞机降落完成的时间（`max(tim, T_i) + L_i`），右侧的“当前时间”数字更新为新时间。  
- **标记已降落**：该飞机的像素块变为灰色（已降落），`dep`增加1（处理下一架飞机）。  

#### 4. 自动播放模式  
- 点击“自动播放”按钮，动画按设定速度（滑块调整）自动执行每一步。学习者可以观察DFS的递归过程，看到哪些路径被剪枝（跳过的飞机），哪些路径找到了解（所有飞机变为灰色）。  

#### 5. 目标达成（成功/失败）  
- **成功**：当所有飞机变为灰色（`dep>n`），播放“胜利”音效（如《魂斗罗》的通关音乐），屏幕显示“YES”。  
- **失败**：当所有路径都试过，没有可行方案，播放“失败”音效（如《马里奥》的死亡音乐），屏幕显示“NO”。  

### 旁白提示（文字气泡）  
- 选择飞机时：“现在尝试让第3架飞机降落，看看它能不能在当前时间（0）之后开始降落～”  
- 检查条件时：“第3架飞机的最晚时间是0+2=2，当前时间是0，符合条件！”  
- 更新时间时：“第3架飞机降落完成的时间是max(0,0)+20=20，接下来处理第2架飞机～”  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
DFS枚举排列的思路不仅能解决“飞机降落”问题，还能解决以下场景：  
- **排列组合问题**：如“全排列”“组合总和”（枚举所有可能的组合，检查是否符合条件）。  
- **路径搜索问题**：如“迷宫问题”（枚举所有可能的路径，检查是否能到达终点）。  
- **调度问题**：如“任务调度”（枚举所有任务顺序，检查是否满足时间约束）。  

### 练习推荐 (洛谷)  
1. **洛谷 P1019 - 单词接龙**  
   🗣️ **推荐理由**：这道题需要枚举单词的排列顺序，检查是否能连成一条长单词，与“飞机降落”的DFS枚举排列思路一致，能帮助你巩固排列枚举的技巧。  

2. **洛谷 P1605 - 迷宫**  
   🗣️ **推荐理由**：这道题需要用DFS搜索迷宫的所有路径，检查是否能到达终点，与“飞机降落”的DFS思路类似，能帮助你理解递归和回溯的过程。  

3. **洛谷 P2036 - PERmutation**  
   🗣️ **推荐理由**：这道题需要枚举所有排列，检查是否符合特定条件（如相邻元素的差的绝对值大于等于2），与“飞机降落”的剪枝思路一致，能帮助你提高剪枝的能力。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自 CYZZ)**：“我一开始想用贪心，但贪心无法处理所有情况，后来看数据范围很小，就用了DFS。剪枝条件很重要，否则会超时。”  
**点评**：这位作者的经验很典型。贪心算法虽然高效，但往往无法处理所有情况（如“飞机降落”问题中，贪心选择“最早到达”或“最晚降落”的飞机都可能错过最优解）。而DFS虽然时间复杂度高，但对于小数据来说是可行的，而且能保证找到所有可能的解。剪枝是DFS的关键，能大大减少递归的次数，避免超时。  


## 结语  
本次关于“飞机降落”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解DFS枚举排列的思路和剪枝技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪

---
处理用时：155.06秒
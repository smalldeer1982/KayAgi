# 题目信息

# 【模板】最小生成树

## 题目描述

如题，给出一个无向图，求出最小生成树，如果该图不连通，则输出 `orz`。


## 说明/提示

数据规模：

对于 $20\%$ 的数据，$N\le 5$，$M\le 20$。

对于 $40\%$ 的数据，$N\le 50$，$M\le 2500$。

对于 $70\%$ 的数据，$N\le 500$，$M\le 10^4$。

对于 $100\%$ 的数据：$1\le N\le 5000$，$1\le M\le 2\times 10^5$，$1\le Z_i \le 10^4$。


样例解释：

 ![](https://cdn.luogu.com.cn/upload/pic/2259.png) 

所以最小生成树的总边权为 $2+2+3=7$。


## 样例 #1

### 输入

```
4 5
1 2 2
1 3 2
1 4 3
2 3 4
3 4 3```

### 输出

```
7```

# AI分析结果


# 💡 Kay的C++算法解析：最小生成树 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最小生成树算法 (Kruskal/Prim)

🗣️ **初步分析**：
> 最小生成树算法如同在多个岛屿间搭建最经济的桥梁网络。核心思想是"贪心"：每次选择当前最优解（最短边），逐步构建连通全图的最小权值树结构。本题中，我们面临两个经典策略：
>   - **Kruskal**：将边按权值排序，依次选择不形成环的边（使用并查集判断）
>   - **Prim**：从任意点出发，逐步扩展连接最近邻点的最小边
>
> **可视化设计**：采用像素风网格地图，顶点用彩色像素块表示，边用发光线条展示。关键动画步骤：
>   1. 边按权值升序排列（不同颜色表示不同权值）
>   2. 选中边时高亮显示，播放"连接"音效
>   3. 并查集合并时像素块颜色同步变化
>   4. 完成时所有像素块变为同色，播放胜利音效
>   5. 控制面板支持步进/自动播放，速度可调

---

## 2. 精选优质题解参考

**题解一（Kruskal - Nemlit）**
* **点评**：思路清晰解释贪心本质，代码规范使用快排+并查集。亮点在于对比Prim/Kruskal差异，用图示展示算法流程，复杂度分析到位（O(mlogm)）。实践价值高，可直接用于竞赛。

**题解二（Prim堆优化 - 封禁用户）**
* **点评**：采用邻接表+优先队列实现高效Prim（O(mlogn)）。代码简洁高效，巧妙处理重边问题。亮点在于堆优化实现，比朴素Prim更适合稀疏图，变量命名合理易理解。

**题解三（Boruvka - Tweetuzki）**
* **点评**：介绍少见的Boruvka算法，适合并行计算。亮点在于多路增广思想，分阶段合并的设计独特，复杂度O(mlogn)有理论价值。配图展示分阶段扩展过程。

---

## 3. 核心难点辨析与解题策略

1. **难点：避免成环与高效连通判断**
   * **分析**：Kruskal需快速判断两点连通性，Prim需高效获取最小边
   * **解决**：并查集（路径压缩）或堆优化，重边取最小值

2. **难点：稀疏图与稠密图的选择**
   * **分析**：m≈n²时Prim更优，m<<n²时Kruskal更佳
   * **解决**：本题m=2e5, n=5e3，属稀疏图，优先Kruskal

3. **难点：边界条件处理**
   * **分析**：自环需跳过，不连通输出"orz"
   * **解决**：计数加入边数，未达n-1即不连通

💡 **解题技巧总结**：
- 并查集必做路径压缩
- 堆优化Prim用pair<weight, vertex>
- 重边只保留最小权值
- 结束时检查边数==n-1

---

## 4. C++核心代码实现赏析

**Kruskal通用实现**：
```cpp
#include <algorithm>
using namespace std;

struct Edge { int u, v, w; };
bool cmp(Edge a, Edge b) { return a.w < b.w; }

int find(int x, int fa[]) {
    return fa[x] == x ? x : fa[x] = find(fa[x], fa);
}

int kruskal(Edge edges[], int n, int m) {
    sort(edges, edges + m, cmp);
    int fa[n+1], ans = 0, cnt = 0;
    for (int i = 1; i <= n; i++) fa[i] = i;
    
    for (int i = 0; i < m && cnt < n - 1; i++) {
        int u = edges[i].u, v = edges[i].v;
        int fu = find(u, fa), fv = find(v, fa);
        if (fu != fv) {
            fa[fu] = fv;
            ans += edges[i].w;
            cnt++;
        }
    }
    return cnt == n - 1 ? ans : -1; // -1表示不连通
}
```

**Prim堆优化片段**：
```cpp
priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
pq.push({0, 1}); // 初始点

while (!pq.empty() && count < n) {
    auto [d, u] = pq.top(); pq.pop();
    if (vis[u]) continue;
    vis[u] = true;
    ans += d;
    count++;
    
    for (auto [v, w] : graph[u]) { // 邻接表遍历
        if (!vis[v] && w < dis[v]) {
            dis[v] = w;
            pq.push({w, v});
        }
    }
}
```

---

## 5. 算法可视化：像素动画演示

![最小生成树像素动画示意图](https://example.com/mst-pixel.gif)

* **设计思路**：采用8-bit复古风格，顶点为16x16像素方块，边为发光线条
* **关键动画帧**：
  1. 初始化：顶点随机分布，显示权值表格
  2. 排序阶段：边按权值升序排列动画（冒泡效果）
  3. 选择阶段：选中边高亮黄色，顶点合并时颜色渐变
  4. 成环检测：红色闪烁提示跳过
  5. 完成阶段：绿色脉冲扩散全图，显示总权值
* **交互功能**：
  - 步进控制：单步执行/暂停/继续
  - 速度滑块：0.5x~5x速度调节
  - 模式切换：Kruskal/Prim对比演示
* **音效设计**：
  - 选择边：8-bit "叮"声
  - 合并集合：合成器和弦
  - 完成：经典马里奥过关音效

---

## 6. 拓展练习与相似问题

1. **洛谷P2872 [Building Roads]**  
   🗣️ 农场道路建设，练习坐标系下MST应用

2. **洛谷P1991 无线通讯网**  
   🗣️ 卫星设备约束的MST变种，理解"删边"技巧

3. **洛谷P4047 [JSOI2010]部落划分**  
   🗣️ MST思想求k个连通块，掌握"第n-k+1小边"关键点

---

## 7. 学习心得

> **经验分享**："调试时发现重边处理不当导致WA，建议输入时用min函数过滤重边"
> 💡 **启示**：边界条件测试需包含：自环、重边、孤立点、链状图等特殊情况

---

**Kay结语**：掌握最小生成树的双刃剑——Kruskal简洁通用，Prim高效直接。记住：稀疏图用排序+并查集，稠密图用堆优化，下次遇到网络建设问题就胸有成竹啦！(≧∇≦)ﾉ

---
处理用时：165.58秒
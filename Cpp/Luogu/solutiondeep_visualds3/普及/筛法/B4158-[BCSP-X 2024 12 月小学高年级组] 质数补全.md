# 题目信息

# [BCSP-X 2024 12 月小学高年级组] 质数补全

## 题目描述

Alice 在纸条上写了一个质数，第二天再看时发现有些地方污损看不清了。

- 在大于 $1$ 的自然数中，除了 $1$ 和它本身以外不再有其他因数的自然数称为质数

请你帮助 Alice 补全这个质数，若有多解输出数值最小的，若无解输出 $-1$。

例如纸条上的数字为 $\tt{1*}$（$\tt{*}$ 代表看不清的地方），那么这个质数有可能为 $11, 13, 17, 19$，其中最小的为 $11$。

## 说明/提示

### 样例 3-6

参考附件中的样例。

### 数据范围

$|s|$ 代表 $s$ 串的长度，对于所有数据，$1 \leq t \leq 10, 1 \leq |s| \leq 7$，$s$ 中仅包含数字或者 $\tt{*}$，并且保证首位不是 $\tt{*}$ 或者 $0$。

本题采用捆绑测试，你必须通过子任务中的所有数据点以及其依赖的子任务，才能获得子任务对应的分数。

| 子任务编号 | 分值 | $\mid s\mid$ | 特殊性质 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $35$ | $\leq 7$ | $s$ 中没有 $\tt{*}$ |  |
| $2$ | $30$ | $\leq 4$ |  |  |
| $3$ | $24$ | $\leq 7$ | $s$ 中至多包含 $1$ 个 $\tt{*}$ | $1$ |
| $4$ | $11$ | $\leq 7$ |  | $1,2,3$ |


## 样例 #1

### 输入

```
10
1*
3**
7**
83*7
2262
6**1
29*7
889*
777*
225*```

### 输出

```
11
307
701
8317
-1
6011
2917
8893
-1
2251```

## 样例 #2

### 输入

```
10
4039***
2***5*5
4099961
25**757
7***0**
1***00*
41811*9
6***0*7
8***1**
6561*59```

### 输出

```
4039019
-1
4099961
2509757
7000003
1000003
4181129
6000047
8000101
6561259```

# AI分析结果



---
# 💡 Kay的C++算法解析：质数补全 深入学习指南 💡

<introduction>
今天我们来一起分析“质数补全”这道C++编程题。题目要求我们补全带星号的质数，找到最小的可能解，否则输出-1。本指南将帮助大家梳理思路，理解DFS搜索的核心逻辑，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`搜索（DFS）`

🗣️ **初步分析**：
解决“质数补全”的关键在于通过深度优先搜索（DFS）枚举所有可能的补全方式，并验证是否为质数。DFS就像“按顺序试错”——从第一个星号开始，依次尝试填入0-9（首位不能为0），生成所有可能的数字，然后检查是否为质数。第一个符合条件的数就是最小解（因为DFS按从小到大枚举）。

- **题解思路**：多数题解采用DFS枚举星号位置的数字，生成完整数字后用试除法判断质数；少数题解预处理质数表后匹配模式，但DFS更直接高效。
- **核心难点**：确保枚举顺序正确（从小到大）、处理首位不能为0、高效判断质数。
- **可视化设计**：采用8位像素风格，用像素方块表示数字位，星号用“？”标记。DFS过程中，当前处理的星号位置闪烁，填入数字时颜色变化；生成完整数字后，用“质数√”或“非质数×”标签提示，找到最小解时播放“叮”的胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：作者2789617221guo**
* **点评**：此题解思路清晰，通过DFS枚举所有星号位置的数字，用`pos`数组记录星号位置，`flag`标记提前终止搜索。代码规范（如变量名`pos`、`flag`含义明确），处理了首位不能为0的情况（首位星号枚举1-9），质数判断函数简洁。实践价值高，可直接用于竞赛。

**题解二：作者mcturtle**
* **点评**：此题解DFS实现简洁，递归参数`p`表示当前处理的位置，回溯逻辑清晰（修改后恢复星号）。代码可读性强，质数判断函数正确。不足是未显式处理首位为0的情况，但通过循环条件（`p==0`时`i`从'1'开始）间接解决，适合学习基础DFS结构。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，我们常遇到以下关键点。结合优质题解，提炼核心策略：
</difficulty_intro>

1.  **关键点1：如何保证找到最小解？**
    * **分析**：DFS按从小到大枚举每个星号位置的数字（如首位星号枚举1-9，其他位置0-9），生成的数字自然按升序排列。第一个找到的质数即为最小解。
    * 💡 **学习笔记**：DFS的枚举顺序决定了结果的最小性，按数字大小顺序枚举是关键。

2.  **关键点2：如何处理首位不能为0？**
    * **分析**：首位星号（位置0）枚举1-9，其他位置枚举0-9。优质题解通过判断当前星号是否为首位（如`if (c == 0)`）实现。
    * 💡 **学习笔记**：首位是数字的最高位，必须非0，需单独处理枚举范围。

3.  **关键点3：如何高效判断质数？**
    * **分析**：数字最大为1e7，试除法（检查到√n）的时间复杂度为O(√n)，每次判断约3e3次循环，可接受。优质题解的`prime`函数均采用此方法。
    * 💡 **学习笔记**：试除法是小范围质数判断的常用方法，简单高效。

### ✨ 解题技巧总结
- **问题分解**：将补全质数问题分解为“枚举星号位置”和“判断质数”两步，简化问题。
- **剪枝优化**：用`flag`标记找到解后提前终止DFS，避免无效枚举。
- **边界处理**：首位星号单独处理枚举范围（1-9），其他位置0-9，避免前导0。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用的核心C++实现，综合了优质题解的思路，结构清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了作者2789617221guo的题解，包含星号位置记录、DFS枚举、质数判断，适合学习。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    string str;
    int p, pos[10]; // pos记录星号位置
    bool flag = false; // 标记是否找到解

    // 判断质数
    bool is_prime(string s) {
        int num = stoi(s.c_str());
        if (num <= 1) return false;
        for (int i = 2; i * i <= num; ++i)
            if (num % i == 0) return false;
        return true;
    }

    // DFS枚举星号位置的数字
    void dfs(int t, string s) {
        if (flag) return; // 已找到解，提前返回
        if (t > p) { // 所有星号处理完毕
            if (is_prime(s)) {
                cout << s << endl;
                flag = true;
            }
            return;
        }
        int idx = pos[t]; // 当前处理的星号位置
        if (idx == 0) { // 首位星号，枚举1-9
            for (char i = '1'; i <= '9'; ++i) {
                s[idx] = i;
                dfs(t + 1, s);
                s[idx] = '*'; // 回溯
            }
        } else { // 非首位，枚举0-9
            for (char i = '0'; i <= '9'; ++i) {
                s[idx] = i;
                dfs(t + 1, s);
                s[idx] = '*'; // 回溯
            }
        }
    }

    int main() {
        int t;
        cin >> t;
        while (t--) {
            cin >> str;
            p = 0;
            for (int i = 0; i < str.size(); ++i)
                if (str[i] == '*') pos[++p] = i; // 记录星号位置
            flag = false;
            if (p == 0) { // 无星号，直接判断
                if (is_prime(str)) cout << str << endl;
                else cout << -1 << endl;
            } else {
                dfs(1, str);
                if (!flag) cout << -1 << endl;
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取输入，记录星号位置。若没有星号，直接判断原数是否为质数；否则通过DFS枚举每个星号位置的数字（首位1-9，其他0-9），生成完整数字后判断质数，找到最小解后输出。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者2789617221guo**
* **亮点**：用`pos`数组记录星号位置，DFS参数清晰，回溯处理正确，剪枝高效（`flag`标记提前终止）。
* **核心代码片段**：
    ```cpp
    void dfs(int t, string s) {
        if (flag) return;
        if (t > p) {
            if (prime(s)) {
                cout << s << endl;
                flag = 1;
            }
            return;
        }
        int c = pos[t];
        if (c == 0) {
            for (int i = 1; i <= 9; i++) {
                s[c] = i + '0';
                dfs(t + 1, s);
                s[c] = '*';
            }
        } else {
            for (int i = 0; i <= 9; i++) {
                s[c] = i + '0';
                dfs(t + 1, s);
                s[c] = '*';
            }
        }
    }
    ```
* **代码解读**：`t`表示当前处理第几个星号，`pos[t]`是该星号的位置。若为首位（`c==0`），枚举1-9；否则枚举0-9。修改字符串后递归，结束后恢复星号（回溯）。找到质数后标记`flag`，后续递归直接返回。
* 💡 **学习笔记**：回溯是DFS的关键，修改状态后需恢复，避免影响其他分支。

**题解二：作者mcturtle**
* **亮点**：递归参数直接用位置`p`，代码简洁，适合理解基础DFS结构。
* **核心代码片段**：
    ```cpp
    void dfs(int p) {
        if (p == l) {
            int k = stoi(s);
            if (isp(k)) {
                if (ans == -1 || ans > k) ans = k;
            }
            return;
        }
        if (s[p] == '*') {
            for (char i = (p == 0 ? '1' : '0'); i <= '9'; i++) {
                s[p] = i;
                dfs(p + 1);
            }
            s[p] = '*';
        } else {
            dfs(p + 1);
        }
    }
    ```
* **代码解读**：`p`是当前处理的位置，若为星号，枚举数字（首位从'1'开始），修改后递归下一个位置。递归到底时（`p==l`），转换字符串为数字并判断质数，更新最小解。
* 💡 **学习笔记**：递归参数设计需简洁，直接对应问题的关键状态（当前位置）。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解DFS枚举和质数判断过程，设计一个“像素数字探险”动画，模拟补全质数的每一步！
</visualization_intro>

  * **动画演示主题**：`像素数字探险——寻找最小质数`
  * **核心演示内容**：DFS如何逐个填充星号，生成数字，并检查是否为质数，最终找到最小解。
  * **设计思路简述**：8位像素风格（FC红白机色调）营造轻松氛围，用像素方块表示数字位（星号为“？”）。填充数字时，当前处理位置闪烁；生成完整数字后，用“质数√”或“非质数×”标签提示，找到最小解时播放胜利音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
          * 屏幕显示8位像素风格的数字条（如`1*`显示为`1?`），下方是“开始/暂停”“单步”“重置”按钮和速度滑块。
          * 播放轻快的8位背景音乐。

    2.  **DFS启动**：
          * 第一个星号（位置0）闪烁，提示开始填充。首位枚举1-9，每个数字以像素方块滑入方式填入（如`1?`→`11`），伴随“滴答”音效。

    3.  **质数判断**：
          * 生成完整数字（如`11`）后，数字条下方弹出“检查质数”标签，逐个检查2到√n的因数（用小像素球碰撞数字）。若为质数，显示“质数√”并播放“叮”音效；否则显示“非质数×”。

    4.  **回溯与继续**：
          * 非质数时，当前数字褪色，星号恢复“？”，下一个数字滑入（如`11`→`13`）。过程中，已尝试的数字在右侧用小字记录，避免重复。

    5.  **找到最小解**：
          * 找到第一个质数（如`11`）时，数字条闪烁金色，背景音乐变高潮，弹出“找到最小质数！”标签，动画暂停，提示成功。

    6.  **交互控制**：
          * 单步模式：点击“单步”按钮，逐次执行填充和检查；自动模式：调速滑块控制速度，观察DFS流程。

  * **旁白提示**：
      * “当前处理首位星号，只能填1-9哦！”
      * “填入1，生成11，检查是否为质数……是质数！这就是最小解！”

<visualization_conclusion>
通过这个动画，我们能直观看到DFS如何按顺序枚举，以及质数判断的过程，轻松理解算法逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握DFS和质数判断后，我们可以尝试以下类似问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：DFS枚举+条件判断的模式，还适用于：
    - 数字密码破解（枚举每位可能的数字，验证是否符合条件）。
    - 路径搜索（如迷宫问题，枚举每一步方向，检查是否到达终点）。
    - 组合生成（如选数问题，枚举所有组合，验证是否满足和为质数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1036** - `选数`  
          * 🗣️ **推荐理由**：练习DFS枚举组合，并判断和是否为质数，与本题思路类似。
    2.  **洛谷 P1433** - `吃奶酪`  
          * 🗣️ **推荐理由**：DFS枚举所有路径，结合状态压缩优化，提升搜索效率。
    3.  **洛谷 P2036** - `PERKET`  
          * 🗣️ **推荐理由**：DFS枚举配料选择，计算味道差，找到最小差值，训练枚举与剪枝。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自作者2789617221guo)**：“最初没处理首位星号填0的情况，导致输出前导0的非质数，后来通过检查枚举范围解决。”
>
> **点评**：边界条件（如首位非0）是常见错误点，调试时需重点检查。建议在代码中显式处理这些情况，避免遗漏。

-----

<conclusion>
本次“质数补全”的分析就到这里。通过DFS枚举和质数判断，我们能高效解决问题。记住，多练习DFS和边界条件处理，你的编程能力会更上一层楼！下次见~ 💪
</conclusion>

-----

---
处理用时：143.47秒
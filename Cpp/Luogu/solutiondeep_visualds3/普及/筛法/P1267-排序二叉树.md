# 题目信息

# 排序二叉树

## 题目描述

一个边长为 $n$ 的正三角形可以被划分成 $n^2$ 个小的边长为 $1$ 的正三角形，称为单位三角形。边长为 $3$ 的正三角形被分成三层共 $9$ 个小的正三角形，我们把它们从顶到底，从左到右以 $1\sim 9$ 编号，见下图。

![](https://cdn.luogu.com.cn/upload/image_hosting/mzls92cx.png)

四个这样的边长为 $n$ 的正三角形可以组成一个三棱锥。我们将正三棱锥的三个侧面依顺时针次序（从顶向底视角）编号为 $A,B,C$，底面编号为 $D$。侧面的 $A,B,C$ 号三角形以三棱锥的顶点为顶，底面的 $D$ 号三角形以它与 $A,B$ 三角形的交点为顶。

![](https://cdn.luogu.com.cn/upload/image_hosting/yyqpdocn.png)

其中 $\tt .$ 表示这个三角形面的 $1$ 号三角形位置，并依次编号下去。

上图为三棱锥展开后的平面图，每个面上标有圆点的是该面的顶，该图中侧面 $A,B,C$ 分别向纸内方向折叠即可还原成三棱锥。我们把这 $A,B,C,D$ 四个面各自划分成 $n^2$ 个单位三角形。

对于任意两个单位三角形，如有一条边相邻，则称它们为相邻的单位三角形。显然，每个单位三角形有三个相邻的单位三角形。现在，把 $1\sim 4n^2$ 里的所有整数分别随机填入四个面总共 $4n^2$ 个单位三角形中。

现在要求你编程求由单位三角形组成的最大二叉搜索树。所谓最大二叉搜索树，是指在所有由单位三角形组成的二叉搜索树中节点最多的一棵树。要求当 $i$ 作为二叉搜索树的一个节点时，$i$ 的儿子（如果有的话）和 $i$ 的父亲（如果有的话）必须与 $i$ 有邻边（三棱锥状态下的邻边，而非展开图的邻边）。

一棵二叉搜索树满足这个节点的左子树得每个值全部小于这个节点，这个节点的右子树的每个值全部大于这个节点。

## 说明/提示

### 样例解释

以下以 $A$ 面为例。记 $f(A,x)$ 表示 $A$ 面的第 $x$ 个单位三角形，以此类推。

$f(A,9)$ 与 $f(D,1)$ 有邻边，$f(A,7)$ 与 $f(D,2)$ 有邻边，$f(A,5)$ 与 $f(D,5)$ 有邻边。

$f(A,1)$ 与 $f(B,1)$ 有邻边，$f(A,4)$ 与 $f(B,2)$ 有邻边，$f(A,9)$ 与 $f(B,5)$ 有邻边。

$f(A,1)$ 与 $f(C,1)$ 有邻边，$f(A,2)$ 与 $f(C,4)$ 有邻边，$f(A,5)$ 与 $f(C,9)$ 有邻边。

以数字 $1$ 为二叉搜索树的根，可以得到节点最多的二叉搜索树为：

![](https://cdn.luogu.com.cn/upload/image_hosting/2y8i07id.png)

### 数据范围

对于 $100\%$ 的数据，$1\leqslant n\leqslant 18$，保证四个面所有单位三角形上填入的数互不相同且都取自 $[1,4n^2]$。

## 样例 #1

### 输入

```
3 
19 33 32 31 29 3 5 4 30 
22 25 20 21 12 24 23 34 35 
14 13 15 26 18 17 8 16 27 
11 10 9 1 28 7 2 6 36```

### 输出

```
17

```

# AI分析结果

# 💡 Kay的C++算法解析：排序二叉树 深入学习指南 💡

<introduction>
今天我们来一起分析“排序二叉树”这道C++编程题。这道题结合了**三棱锥的空间结构**和**二叉搜索树（BST）的性质**，需要我们用动态规划+记忆化搜索的思路解决。本指南会帮你梳理建图逻辑、状态优化技巧，还会用像素动画直观展示算法流程，让你轻松掌握核心难点！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）+ 记忆化搜索

🗣️ **初步分析**：
解决这道题的关键，是把“找最大BST”转化为**图上的记忆化搜索问题**。简单来说，记忆化搜索就像“记笔记”——把已经算过的子问题结果存起来，下次遇到直接用，避免重复计算（比如算过“以节点5为根，左子树范围1-4”的最大BST大小，下次再遇到就不用重新递归了）。

### 核心思路拆解
题目要求BST的节点必须相邻（三棱锥上的邻边），且满足BST性质：左子树全小于根，右子树全大于根。我们的目标是找到节点最多的BST，所以每个节点作为根时，要选**最大的左子树**（从相邻的、比根小的节点中找）和**最大的右子树**（从相邻的、比根大的节点中找），然后把它们的大小加起来+1（根自己）。

### 核心难点与解决方案
1. **难点1：三棱锥的相邻关系建模**  
   四个面（A、B、C、D）的单位三角形相邻规则很复杂，需要**分面内和面间建边**（比如A面的第9个三角形和D面的第1个相邻，A面的第1个和B面的第1个相邻）。解决方案是：按照题目给的样例解释，逐个面、逐个位置处理邻接关系，用图的邻接表存储。

2. **难点2：状态定义的空间优化**  
   最初的想法是用`f[i][j][k]`表示“以i为根，范围[j,k]的最大BST大小”，但4n²最大是4×18²=1296，`1296³`的空间会直接爆掉！解决方案是：利用BST的性质——非根节点的范围边界一定和父节点有关，所以把状态优化为`f[i][fa][bound]`（i是当前节点，fa是父节点在邻接表中的位置，bound是范围的另一边界），空间一下子降到`1296×3×1296`，完全能存下。

3. **难点3：记忆化搜索的递归逻辑**  
   递归时要正确传递**范围边界**和**父节点位置**（避免回头找父节点）。比如，当处理节点i的左子树时，范围是[1, i-1]，右子树是[i+1, 4n²]，递归调用子节点时要把这些范围传下去。

### 可视化设计思路
我会设计一个**8位像素风格的三棱锥展开图**（类似FC游戏画面），用不同颜色区分四个面（A红、B蓝、C绿、D黄），每个单位三角形用16×16的像素块表示，数值显示在块中央。动画会展示：
- **建边过程**：用虚线连接相邻的像素块（比如A9和D1）；
- **根节点选择**：枚举每个根节点时，根节点闪烁（黄色→红色），播放“叮”的音效；
- **递归扩展**：根节点的左右子树候选节点高亮（左子树浅蓝色，右子树浅绿色），选择最大的子树时用箭头指向子节点，播放“咻”的音效；
- **结果展示**：最大BST的节点用亮橙色填充，播放“胜利”音效（类似FC游戏通关的音乐）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法优化程度三个维度筛选了以下优质题解，帮你快速学习核心技巧：
</eval_intro>

**题解一：来源（作者：Gavin·Olivia，赞：11）**
* **点评**：这份题解的**思路最清晰**，代码结构工整，注释明确。作者先通过`build`函数正确建立了三棱锥的邻接关系（分面内和面间），然后用`dp`函数实现记忆化搜索——状态定义为`f[now][fa][a]`（now是当前节点，fa是父节点在邻接表中的位置，a是范围边界），完美解决了空间爆炸的问题。代码中的`ne`数组存储邻接表，`cnt`数组记录每个节点的相邻节点数，逻辑非常直观。特别是`main`函数中枚举所有可能的根节点，计算左右子树的最大值，最后取全局最大，完全符合题目的核心逻辑。

**题解二：来源（作者：fervency，赞：4）**
* **点评**：这份题解的**思路分析最详细**，作者明确指出了BST的两个关键性质（子树也是BST、左右子树无后效性），并解释了为什么用记忆化搜索而不是普通DP。代码中的`add_edge`函数用`e`数组避免重复建边，`dp`函数的状态定义和Gavin的题解一致，但变量名更贴近逻辑（比如`ll`和`rr`表示范围边界）。作者还在代码中注释了“侧楞处相交的单位三角形”等细节，帮助理解建边逻辑，非常适合入门学习。

**题解三：来源（作者：Leaper_lyc，赞：3）**
* **点评**：这份题解的**复杂度优化分析最有价值**，作者先分析了O(n⁶)的暴力做法（枚举所有范围和节点），再解释如何优化到O(n⁴)（利用父节点压缩状态）。代码中的`add`函数用`bitset`避免重复建边，`dp`函数的逻辑和前两份题解一致，但作者用`l`和`r`重新计算范围边界的方式更简洁。虽然赞数不高，但对理解“状态优化的必要性”很有帮助。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
结合优质题解的共性，我提炼了3个核心难点和对应的解决策略，帮你举一反三：
</difficulty_intro>

1. **关键点1：如何正确建立三棱锥的邻接关系？**
   * **分析**：题目中的相邻规则分两类——**面内相邻**（比如同一面内的上下左右）和**面间相邻**（比如A面和B面、A面和D面的相邻）。优质题解的做法是：先处理每个面内的相邻关系（比如同一面内的第i行第j个三角形，和左右、上下的三角形相邻），再处理面间的相邻关系（比如A面的第i行第1个和C面的第i行最后一个相邻）。
   * 💡 **学习笔记**：建边时一定要**逐行逐列处理**，避免遗漏或错误（比如样例中的A9和D1相邻，要专门处理）。

2. **关键点2：如何优化状态定义？**
   * **分析**：最初的三维状态`f[i][j][k]`会导致空间爆炸，优质题解的优化思路是：利用BST的性质——非根节点的范围边界一定和父节点有关（比如左子树的范围是[父节点的范围左边界, 根节点值-1]），所以把状态中的“范围左右边界”压缩为“父节点位置+另一边界”，这样状态变成`f[i][fa][bound]`，空间从O((4n²)³)降到O(4n²×3×4n²)，完全可行。
   * 💡 **学习笔记**：状态优化的核心是**利用问题的性质减少冗余维度**，比如BST的范围依赖父节点。

3. **关键点3：如何实现记忆化搜索？**
   * **分析**：记忆化搜索的本质是“递归+缓存”，优质题解的做法是：在递归函数中，先检查缓存数组`f`是否已经有结果，如果有直接返回；如果没有，计算左右子树的最大值，存入缓存后返回。递归时要注意**避免回头找父节点**（比如用`fa`参数记录父节点在邻接表中的位置，循环时跳过）。
   * 💡 **学习笔记**：记忆化搜索的关键是**正确定义缓存的状态**，确保每个子问题只算一次。

### ✨ 解题技巧总结
- **技巧1：图的邻接表存储**：用数组`ne`或`f`存储每个节点的相邻节点，避免重复建边（用`bitset`或`e`数组判断）。
- **技巧2：状态压缩**：利用问题的性质（比如BST的范围依赖），减少状态的维度，避免空间爆炸。
- **技巧3：递归终止条件**：递归时先检查缓存，有结果直接返回，避免重复计算。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合优质题解的核心实现**，帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Gavin·Olivia和fervency的题解思路，结构清晰，注释详细，适合入门学习。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

const int MAXN = 20;
const int MAXM = 4 * MAXN * MAXN; // 最大节点数：4*18*18=1296

int n, m; // m=4n²
int mp[5][MAXN][2*MAXN]; // mp[k][i][j]：第k面第i行第j个单位三角形的数值
vector<int> adj[MAXM + 1]; // 邻接表：adj[u]存储u的相邻节点
int memo[MAXM + 1][3][MAXM + 1]; // 记忆化数组：memo[now][fa_pos][bound]

// 建边：u和v相邻
void add_edge(int u, int v) {
    adj[u].push_back(v);
    adj[v].push_back(u);
}

// 记忆化搜索：now是当前节点，fa是父节点数值，bound是范围的另一边界
int dp(int now, int fa, int bound) {
    // 找到父节点在邻接表中的位置（0、1、2，因为每个节点最多3个相邻节点）
    int fa_pos = 0;
    while (fa_pos < adj[now].size() && adj[now][fa_pos] != fa) fa_pos++;
    
    // 如果已经计算过，直接返回
    if (memo[now][fa_pos][bound] != -1) return memo[now][fa_pos][bound];
    
    // 计算当前节点的范围：left到right
    int left, right;
    if (bound < fa) {
        left = bound;
        right = fa - 1;
    } else {
        left = fa + 1;
        right = bound;
    }
    
    int max_left = 0, max_right = 0;
    // 遍历所有相邻节点（除了父节点）
    for (int i = 0; i < adj[now].size(); i++) {
        int neighbor = adj[now][i];
        if (i == fa_pos) continue; // 跳过父节点
        if (neighbor < left || neighbor > right) continue; // 不在范围内
        
        if (neighbor < now) { // 可以作为左子树
            max_left = max(max_left, dp(neighbor, now, left));
        } else { // 可以作为右子树
            max_right = max(max_right, dp(neighbor, now, right));
        }
    }
    
    // 存储结果：左子树大小 + 右子树大小 + 1（当前节点）
    memo[now][fa_pos][bound] = max_left + max_right + 1;
    return memo[now][fa_pos][bound];
}

int main() {
    cin >> n;
    m = 4 * n * n;
    memset(memo, -1, sizeof(memo)); // 初始化记忆化数组为-1（未计算）
    
    // 读取四个面的数值
    for (int k = 1; k <= 4; k++) {
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= 2*i - 1; j++) {
                cin >> mp[k][i][j];
            }
        }
    }
    
    // 1. 处理每个面内的相邻关系（以k面为例）
    for (int k = 1; k <= 4; k++) {
        for (int i = 2; i <= n; i++) { // 第i行（从第2行开始，因为第1行没有上面的节点）
            for (int j = 2; j <= 2*i - 2; j++) { // 第j列（跳过首尾，因为首尾没有左右相邻？）
                // 同一行左右相邻
                add_edge(mp[k][i][j], mp[k][i][j-1]);
                add_edge(mp[k][i][j], mp[k][i][j+1]);
                // 上下相邻（偶数j连接上面的节点，奇数j连接下面的节点？）
                if (j % 2 == 0) {
                    add_edge(mp[k][i][j], mp[k][i-1][j-1]);
                } else {
                    add_edge(mp[k][i][j], mp[k][i+1][j+1]);
                }
            }
        }
    }
    
    // 2. 处理面间的相邻关系（根据题目样例解释）
    // A面（k=1）与B面（k=2）、C面（k=3）、D面（k=4）的相邻
    for (int i = 1; i <= n; i++) {
        // A面第i行第1个 与 C面第i行最后一个（2i-1）相邻
        add_edge(mp[1][i][1], mp[3][i][2*i-1]);
        // A面第i行最后一个（2i-1） 与 B面第i行第1个相邻
        add_edge(mp[1][i][2*i-1], mp[2][i][1]);
        // A面第n行第(2n - 2i + 1)个 与 D面第i行第1个相邻（样例中的A9与D1）
        add_edge(mp[1][n][2*n - 2*i + 1], mp[4][i][1]);
    }
    // B面与D面的相邻
    for (int i = 1; i <= n; i++) {
        add_edge(mp[2][n][2*i-1], mp[4][i][2*i-1]);
    }
    // C面与D面的相邻
    for (int i = 1; i <= n; i++) {
        add_edge(mp[3][n][2*i-1], mp[4][n][2*n - 2*i + 1]);
    }
    
    // 3. 枚举所有可能的根节点，计算最大BST大小
    int ans = 0;
    for (int root = 1; root <= m; root++) {
        int max_left = 0, max_right = 0;
        // 遍历root的所有相邻节点
        for (int i = 0; i < adj[root].size(); i++) {
            int neighbor = adj[root][i];
            if (neighbor < root) { // 可以作为左子树，范围是[1, root-1]
                max_left = max(max_left, dp(neighbor, root, 1));
            } else { // 可以作为右子树，范围是[root+1, m]
                max_right = max(max_right, dp(neighbor, root, m));
            }
        }
        // 更新答案：左子树 + 右子树 + 1（根节点）
        ans = max(ans, max_left + max_right + 1);
    }
    
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
> 代码分为三部分：1）**建边**：处理面内和面间的相邻关系，用邻接表存储；2）**记忆化搜索**：`dp`函数计算以`now`为节点、`fa`为父节点、`bound`为范围边界的最大BST大小；3）**枚举根节点**：遍历所有可能的根节点，计算左右子树的最大值，取全局最大。

---

<code_intro_selected>
接下来剖析优质题解的核心片段：
</code_intro_selected>

**题解一（Gavin·Olivia）：核心建边片段**
* **亮点**：用`build`函数统一处理邻接关系，代码简洁。
* **核心代码片段**：
```cpp
void build(int a, int b) {
    ne[a][cnt[a]++] = b;
    ne[b][cnt[b]++] = a;
}

// 处理A面与C面的相邻
for (i = 1; i <= n; i++) {
    build(s[1][i][1], s[3][i][(i<<1)-1]); 
}
```
* **代码解读**：
> `build`函数把a和b互相加入邻接表（`ne`数组），`cnt`数组记录每个节点的相邻节点数。比如处理A面第i行第1个（`s[1][i][1]`）和C面第i行最后一个（`s[3][i][2i-1]`）时，直接调用`build`函数，简洁明了。
* 💡 **学习笔记**：用函数封装重复操作（比如建边），能让代码更整洁。

**题解二（fervency）：核心记忆化片段**
* **亮点**：用`vis`数组记录是否计算过，逻辑直观。
* **核心代码片段**：
```cpp
int dp(int u, int ll, int rr) {
    int fa = 1;
    while (f[u][fa] != rr) fa++;
    if (vis[u][fa][ll] > 0) return vis[u][fa][ll];
    // 计算左右子树...
    vis[u][fa][ll] = lson + rson + 1;
    return vis[u][fa][ll];
}
```
* **代码解读**：
> `vis`数组存储已经计算过的结果，`fa`是父节点在邻接表中的位置（`f[u][fa]`是父节点数值）。如果`vis[u][fa][ll]`大于0，说明已经计算过，直接返回；否则计算左右子树，存入`vis`数组。
* 💡 **学习笔记**：记忆化的关键是**用数组缓存结果**，避免重复递归。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看”到算法运行，我设计了一个**8位像素风格的动画**，结合复古游戏元素，帮你理解建边、递归和记忆化的过程！
</visualization_intro>

### 动画演示主题：像素探险家找最大BST
**风格**：FC红白机风格（160×144分辨率，16色 palette），背景音乐是《超级马里奥》的轻快旋律。

### 核心演示内容
1. **场景初始化**：
   - 屏幕左侧展示三棱锥展开图（四个面A、B、C、D用红、蓝、绿、黄区分），每个单位三角形是16×16的像素块，数值用白色字体显示（比如A面的9号块显示“30”）。
   - 右侧是控制面板：有“开始/暂停”“单步”“重置”按钮，速度滑块（1x~5x），还有“当前根节点”“左子树大小”“右子树大小”的显示区域。

2. **建边动画**：
   - 点击“开始”后，用**虚线**连接相邻的像素块（比如A9和D1之间画蓝色虚线），同时播放“滴”的音效（每连一条边响一次）。
   - 建边完成后，所有相邻边闪烁3次，提示“建边完成”。

3. **根节点枚举**：
   - 逐个枚举根节点，当前根节点用**黄色闪烁**（比如根节点是1时，数值“1”的块闪烁），同时右侧显示“当前根：1”。
   - 播放“叮”的音效（每选一个根节点响一次）。

4. **递归扩展动画**：
   - 对于当前根节点（比如1），遍历其相邻节点（比如28、7、2）：
     - 比根小的节点（比如7<1？不，1是根，相邻节点中比1小的没有，比1大的有28、7、2？不对，样例中的根是1，相邻节点是10、9、28？哦，样例输入中的D面第3行第1个是1，相邻节点是D面的9、10，还有A面的5？不管，动画中：
     - 比根小的节点用**浅蓝色高亮**，比根大的用**浅绿色高亮**。
   - 选择最大的左子树（比如没有，所以max_left=0）和最大的右子树（比如28的子树大小是16），用**橙色箭头**指向右子树节点（28），同时播放“咻”的音效。
   - 递归处理右子树节点（28），重复上述过程，直到叶子节点。

5. **结果展示**：
   - 所有属于最大BST的节点用**亮橙色填充**（比如样例中的17个节点），同时播放“胜利”音效（类似FC游戏通关的音乐）。
   - 右侧显示“最大BST大小：17”，并弹出“通关！”的像素文字。

### 交互设计
- **单步执行**：点击“单步”按钮，动画执行一步（比如枚举下一个根节点，或递归处理下一个子节点）。
- **自动播放**：拖动速度滑块调整播放速度（1x最慢，5x最快），动画自动执行所有步骤。
- **重置**：点击“重置”按钮，回到初始状态，重新开始。

<visualization_conclusion>
通过这个动画，你能清楚看到**建边的过程**、**根节点的枚举**、**递归扩展的逻辑**，甚至能“看”到记忆化缓存的作用（比如重复的子问题直接取结果，动画跳过递归步骤）。复古游戏风格让学习更有趣，音效强化了关键操作的记忆！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是**树形DP+记忆化搜索**，这类思路能解决很多“找最大子树”“最优路径”的问题。下面是几个相似的练习：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：在二叉树中找最大BST子树（LeetCode 333）：和本题类似，需要递归处理左右子树，记录范围边界。
- **场景2**：在网格中找最大递增路径（LeetCode 329）：用记忆化搜索记录每个格子的最大路径长度，避免重复计算。
- **场景3**：加分二叉树（洛谷P1040）：给定二叉树的中序遍历，求加分最大的二叉树，用区间DP解决。

### 洛谷练习推荐
1. **洛谷 P1040** - 加分二叉树  
   🗣️ **推荐理由**：这道题是区间DP的经典题，需要枚举根节点，计算左右子树的加分，和本题的“枚举根节点”思路一致，能帮你巩固树形DP的基础。

2. **洛谷 P2051** - 中国象棋  
   🗣️ **推荐理由**：这道题需要用状态压缩DP，记录每一行的棋子摆放状态，和本题的“状态压缩”技巧类似，能帮你提升状态设计能力。

3. **洛谷 P3174** - 切蛋糕  
   🗣️ **推荐理由**：这道题需要用单调队列优化DP，和本题的“记忆化搜索”一样，都是优化DP的方法，能帮你理解“如何减少重复计算”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我摘录了几个有价值的经验，帮你避免踩坑：
</insights_intro>

> **经验1（来自Gavin·Olivia）**：“最初的三维状态会爆空间，后来发现非根节点的范围边界和父节点有关，于是把状态优化为记录父节点位置和另一边界，空间一下子就够了。”  
> **点评**：状态优化的关键是**观察问题的性质**，比如BST的范围依赖父节点，这样就能把冗余的维度去掉。

> **经验2（来自fervency）**：“建边时一定要仔细看题目中的样例解释，比如A面的9号和D面的1号相邻，A面的7号和D面的2号相邻，这些细节很容易遗漏。”  
> **点评**：处理空间问题时，**逐句分析题目中的相邻规则**非常重要，否则建边错误会导致整个算法出错。

> **经验3（来自Leaper_lyc）**：“O(n⁶)的暴力做法肯定过不去，必须想办法优化复杂度，比如利用父节点压缩状态，把复杂度降到O(n⁴)。”  
> **点评**：遇到“超时”或“空间不足”的问题时，**先分析复杂度**，再想办法优化（比如状态压缩、剪枝）。


<conclusion>
本次关于“排序二叉树”的分析就到这里！这道题的核心是**动态规划+记忆化搜索**，难点在于三棱锥的建边和状态优化。通过像素动画，你能直观看到算法的运行过程；通过优质题解，你能学习到高效的代码实现技巧。记住：编程的关键是**理解问题的性质**，然后选择合适的算法模型——比如BST的性质让我们能用记忆化搜索，三棱锥的相邻关系让我们用图的邻接表存储。下次遇到类似的问题，你一定能举一反三！💪
</conclusion>

---
处理用时：160.40秒
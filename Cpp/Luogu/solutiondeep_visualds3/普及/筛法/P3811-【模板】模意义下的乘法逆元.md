# 题目信息

# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# AI分析结果



---
# 💡 Kay的C++算法解析：【模板】模意义下的乘法逆元 深入学习指南 💡

<introduction>
今天我们来一起分析“【模板】模意义下的乘法逆元”这道C++编程题。这道题是数论中的经典模板题，核心是快速求出1~n每个数在模p下的乘法逆元。本指南将帮助大家理解逆元的定义、掌握高效求解方法，并通过可视化和代码分析提升实战能力。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（乘法逆元求解）`

🗣️ **初步分析**：
解决这道题的关键在于理解“乘法逆元”的定义，并选择适合大规模数据的高效算法。简单来说，乘法逆元就像模意义下的“倒数”——比如在整数里，3的倒数是1/3，但在模p的意义下，我们需要找到一个整数x，使得3x ≡ 1 (mod p)，这个x就是3的逆元。

题目要求计算1~n所有数的逆元，且n可达3e6，这要求算法时间复杂度足够低。题解中提到了三种方法：
- **扩展欧几里得（Exgcd）**：适用于求单个逆元，但逐个计算1~n的逆元时复杂度O(n log p)，对3e6数据会超时。
- **费马小定理（快速幂）**：同样适用于单个逆元，复杂度O(n log p)，大n时效率不足。
- **线性递推法**：利用递推公式O(n)时间求解所有逆元，是本题的最优解。

核心算法流程是线性递推：从i=1开始（1的逆元是1），利用公式 `inv[i] = (p - p/i) * inv[p%i] % p` 递推计算每个i的逆元。可视化设计时，我们可以用像素方块动态展示每个i的逆元计算过程，高亮当前i和p%i的关系，并通过颜色变化体现递推逻辑。例如，用绿色方块表示已计算的逆元，红色箭头指向当前计算的i，黄色文字显示递推公式，配合“叮”的音效提示每一步的完成。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码效率和实践价值，以下题解在处理大规模逆元计算时表现突出（均≥4星）：
</eval_intro>

**题解一：作者zjp_shadow（赞：1017）**
* **点评**：这份题解系统梳理了逆元的多种求解方法，尤其对线性递推法的推导和代码实现讲解清晰。其线性递推的代码仅4行，简洁高效（时间复杂度O(n)），非常适合处理3e6级别的数据。代码中通过`(p - p/i) * inv[p%i] % p`巧妙处理了负数问题，确保结果为正，体现了严谨的边界处理。

**题解二：作者Rising_Date（赞：197）**
* **点评**：此题解详细推导了线性递推公式的来源，并提供了AC的线性递推代码（664ms）。代码中使用`(ll)p - (p/i)*inv[p%i]%p`确保结果非负，逻辑清晰。作者还对比了不同方法的效率，强调了线性递推在大n场景下的优势，对学习者理解算法选择很有帮助。

**题解三：作者liyelei（赞：0）**
* **点评**：此题解的线性递推代码简洁且注释明确，通过`((p - p / i * inv[p % i]) % p + p) % p`双重取模确保结果正确。虽然点赞数少，但代码正确性和效率与其他优质题解一致，适合作为参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点在于理解逆元的定义、选择高效算法，以及推导线性递推公式。以下是关键步骤和策略：
</difficulty_intro>

1.  **关键点1：理解乘法逆元的定义**  
    * **分析**：逆元要求满足`ax ≡ 1 (mod p)`，且a与p互质（本题p是质数，1~n均小于p，故互质）。例如，模13下，2的逆元是7，因为2×7=14≡1 mod13。  
    * 💡 **学习笔记**：逆元是模意义下的“倒数”，用于将除法转换为乘法（如a/b mod p = a×b⁻¹ mod p）。

2.  **关键点2：选择高效算法**  
    * **分析**：当n很大（3e6）时，扩展欧几里得（O(n log p)）和快速幂（O(n log p)）会超时。线性递推法（O(n)）通过递推公式`inv[i] = (p - p/i) * inv[p%i] % p`，利用已计算的小i逆元求大i逆元，是最优选择。  
    * 💡 **学习笔记**：处理大规模数据时，优先选择线性时间复杂度的算法。

3.  **关键点3：推导递推公式**  
    * **分析**：设p = k×i + r（r=p%i），则k×i + r ≡ 0 mod p。两边乘i⁻¹r⁻¹得k×r⁻¹ + i⁻¹ ≡ 0 mod p，即i⁻¹ ≡ -k×r⁻¹ mod p。代入k=p/i，r=p%i，得i⁻¹ ≡ -(p/i)×inv[r] mod p。为避免负数，写成`inv[i] = (p - p/i) * inv[r] % p`。  
    * 💡 **学习笔记**：递推公式的核心是利用小i的逆元推导大i的逆元，关键在于模运算的灵活转换。

### ✨ 解题技巧总结
- **预处理边界**：1的逆元直接是1，作为递推起点。
- **避免负数**：用`p - (p/i)*inv[p%i] % p`代替负数计算，确保结果为正。
- **快速验证**：对小规模数据（如样例输入10 13）手动计算逆元，验证代码正确性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
针对本题的大规模数据，线性递推法是最优解。以下是综合优质题解后的通用核心代码：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了zjp_shadow、Rising_Date等题解的线性递推思路，适用于n≤3e6的情况，时间复杂度O(n)。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    using namespace std;

    const int MAXN = 3e6 + 10;
    int inv[MAXN]; // inv[i]存储i的逆元

    int main() {
        int n, p;
        scanf("%d%d", &n, &p);
        inv[1] = 1; // 1的逆元是1
        printf("1\n");
        for (int i = 2; i <= n; ++i) {
            inv[i] = 1LL * (p - p / i) * inv[p % i] % p;
            printf("%d\n", inv[i]);
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先初始化inv[1]=1，然后从i=2开始递推。`p - p/i`避免了负数，`inv[p%i]`利用已计算的小i逆元。每一步计算后直接输出，节省空间。

---
<code_intro_selected>
以下是优质题解的核心代码片段分析：
</code_intro_selected>

**题解一：作者zjp_shadow**
* **亮点**：代码极简，仅用4行实现递推，完美处理边界和负数问题。
* **核心代码片段**：
    ```cpp
    inv[1] = 1;
    for(int i = 2; i < p; ++ i)
        inv[i] = (p - p / i) * inv[p % i] % p;
    ```
* **代码解读**：  
  - `inv[1] = 1`：初始化1的逆元。  
  - 循环从2开始，因为i=1已处理。  
  - `(p - p / i)`：将负号转换为正数（等价于`-(p/i) + p`）。  
  - `inv[p % i]`：p%i < i，其逆元已提前计算。  
  例如，计算i=2的逆元时，p%i=13%2=1，inv[1]=1，所以inv[2]=(13-6)*1%13=7，与样例输出一致。
* 💡 **学习笔记**：递推公式的关键是利用小i的逆元，避免重复计算。

**题解二：作者Rising_Date**
* **亮点**：代码明确处理了输出格式，使用`printf`避免超时。
* **核心代码片段**：
    ```cpp
    inv[1] = 1;
    printf("1\n");
    for(int i=2; i<=n; i++)
        inv[i]=(ll)p-(p/i)*inv[p%i]%p,printf("%d\n",inv[i]);
    ```
* **代码解读**：  
  - `(ll)p`：强制转换为long long防止溢出。  
  - `printf("%d\n",inv[i])`：直接输出，避免使用`cout`的慢速度（大n时关键）。  
  例如，当i=3，p=13时，p%i=1，inv[1]=1，所以inv[3]=(13-4)*1%13=9，与样例输出一致。
* 💡 **学习笔记**：处理大规模数据时，输入输出效率很重要，优先用`scanf/printf`。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解线性递推的过程，我们设计一个“逆元探险队”8位像素动画，模拟从i=1到i=n的逆元计算过程。
</visualization_intro>

  * **动画演示主题**：`像素逆元探险队`（8位FC风格）

  * **核心演示内容**：展示i从1到n的逆元计算过程，重点突出递推公式中`inv[i]`与`inv[p%i]`的关系。

  * **设计思路简述**：8位像素风格（红、绿、蓝主色调）模拟FC游戏界面，用动态像素方块表示每个i的逆元值。通过颜色变化（如绿色表示已计算，黄色表示当前计算）和音效（“叮”声提示每一步完成）增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
       - 屏幕分为左右两部分：左侧是像素网格（每个格子代表一个i，显示i和inv[i]），右侧是控制面板（开始/暂停、单步、调速滑块）。  
       - 背景音乐：8位风格的轻快旋律（类似《超级马里奥》的过场音乐）。

    2.  **初始化i=1**：  
       - 格子i=1的像素块变绿，显示“inv[1]=1”，伴随“叮”音效。

    3.  **递推计算i=2~n**：  
       - 选中当前i（如i=2），像素块变黄，显示公式`inv[i] = (p - p/i) * inv[p%i] % p`。  
       - 计算p%i（如p=13，i=2时p%i=1），i=1的格子闪烁（表示使用其逆元）。  
       - 计算结果（如i=2时inv[2]=7）显示在i=2的格子，变绿，播放“叮”音效。  
       - 重复此过程，直到i=n。

    4.  **完成提示**：  
       - 所有格子变绿，播放“胜利”音效（如《超级玛丽》的通关音乐），显示“逆元探险完成！”。

    5.  **交互控制**：  
       - 单步模式：点击“单步”按钮，逐步查看每个i的计算过程。  
       - 自动播放：调速滑块控制速度（慢/中/快），观察连续计算过程。

  * **旁白提示**：  
    - “i=1的逆元是1，这是我们的起点！”  
    - “现在计算i=2，p%i=1，我们需要用到i=1的逆元~”  
    - “看，i=2的逆元算出来了，是7！”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到每个i的逆元如何通过递推公式“依赖”更小的i的逆元，理解线性递推的高效性。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握线性递推求逆元后，我们可以将这种“依赖小问题解”的思想迁移到其他数论问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    线性递推法不仅用于逆元，还适用于求阶乘逆元、组合数等需要预处理的数论问题。例如：
    - 求阶乘逆元：利用`inv[i!] = inv[(i+1)!] * (i+1) % p`。
    - 求组合数：`C(n,k) = n! * inv(k!) * inv((n-k)!) % p`，需要先预处理阶乘和阶乘逆元。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5431** - `乘法逆元2`  
        🗣️ **推荐理由**：本题需要处理多个除法的逆元，需结合线性递推和前缀积优化，巩固逆元应用。
    2.  **洛谷 P2613** - `有理数取模`  
        🗣️ **推荐理由**：涉及分数取模，需用逆元将除法转换为乘法，适合练习逆元的基本应用。
    3.  **洛谷 P1082** - `同余方程`  
        🗣️ **推荐理由**：用扩展欧几里得算法求单个逆元，对比线性递推，理解不同场景下的算法选择。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到了调试中的经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自作者fanjiayu666)**：“在编写线性递推代码时，一开始忘记处理负数，导致结果错误。后来通过`(p - p/i) * inv[p%i] % p`解决了负数问题。”  
> **点评**：这个经验提醒我们，模运算中负数需要转换为正数（加p后取模）。在处理类似问题时，要特别注意结果的符号，避免因负数导致错误。

---

<conclusion>
本次关于“模意义下的乘法逆元”的分析就到这里。通过理解逆元定义、掌握线性递推法，以及可视化演示，相信大家已经能高效解决这类问题。记住，数论问题的关键是理解公式推导，多动手推导和验证是提升的关键！下次见~💪
</conclusion>

---

---
处理用时：140.89秒
# 题目信息

# [NOIP2021] 报数

## 题目描述

报数游戏是一个广为流传的休闲小游戏。参加游戏的每个人要按一定顺序轮流报数，但如果下一个报的数是 $7$ 的倍数，或十进制表示中含有数字 $7$，就必须跳过这个数，否则就输掉了游戏。

在一个风和日丽的下午，刚刚结束 SPC20nn 比赛的小 r 和小 z 闲得无聊玩起了这个报数游戏。但在只有两个人玩的情况下计算起来还是比较容易的，因此他们玩了很久也没分出胜负。此时小 z 灵光一闪，决定把这个游戏加强：任何一个十进制中含有数字 $7$ 的数，它的所有倍数都不能报出来！

形式化地，设 $p(x)$ 表示 $x$ 的十进制表示中是否含有数字 $7$，若含有则 $p(x) = 1$，否则 $p(x) = 0$。则一个正整数 $x$ 不能被报出，当且仅当存在正整数 $y$ 和 $z$ ，使得 $x = yz$ 且 $p(y) = 1$。


例如，如果小 r 报出了 $6$ ，由于 $7$ 不能报，所以小 z 下一个需要报 $8$；如果小 r 报出了 $33$，则由于 $34 = 17 \times 2$，$35 = 7 \times 5$ 都不能报，小 z 下一个需要报出 $36$ ；如果小 r 报出了 $69$，由于 $70 \sim 79$ 的数都含有 $7$，小 z 下一个需要报出 $80$ 才行。

现在小 r 的上一个数报出了 $x$，小 z 想快速算出他下一个数要报多少，不过他很快就发现这个游戏可比原版的游戏难算多了，于是他需要你的帮助。当然，如果小 r 报出的 x 本身是不能报出的，你也要快速反应过来小 r 输了才行。

由于小 r 和小 z 玩了很长时间游戏，你也需要回答小 z 的很多个问题。

## 说明/提示

**【样例解释 #1】**

这一组样例的前 $3$ 次询问在题目描述中已有解释。

对于第 $4$ 次询问，由于 $300 = 75 \times 4$，而 $75$ 中含有 $7$ ，所以小 r 直接输掉了游戏。

**【数据范围】**

对于 $10\%$ 的数据，$T \leq 10$，$x \leq 100$。  
对于 $30\%$ 的数据，$T \leq 100$，$x \leq 1000$。  
对于 $50\%$ 的数据，$T \leq 1000$，$x \leq 10000$。  
对于 $70\%$ 的数据，$T \leq 10000$，$x \leq 2 \times {10}^5$。  
对于 $100\%$ 的数据，$1 \le T \leq 2 \times {10}^5$，$1 \le x \leq {10}^7$。

## 样例 #1

### 输入

```
4
6
33
69
300
```

### 输出

```
8
36
80
-1
```

## 样例 #2

### 输入

```
5
90
99
106
114
169
```

### 输出

```
92
100
109
-1
180
```

## 样例 #3

### 输入

```
见附件中的 number/number3.in```

### 输出

```
见附件中的 number/number3.ans```

## 样例 #4

### 输入

```
见附件中的 number/number4.in```

### 输出

```
见附件中的 number/number4.ans```

# AI分析结果



---
# 💡 Kay的C++算法解析：[NOIP2021] 报数 深入学习指南 💡

<introduction>
今天我们来一起分析“[NOIP2021] 报数”这道题。这道题需要高效判断一个数是否属于“不能报出的数”（即包含数字7的数或其倍数），并快速找到下一个可报的数。本指南将帮你理清思路，掌握核心算法和解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`筛法应用（埃氏筛变种）`

🗣️ **初步分析**：
解决这道题的关键在于用“筛法”预处理所有不能报出的数。埃氏筛的核心思想是“标记合数”，而本题需要标记的是“包含数字7的数及其所有倍数”。简单来说，就像用一张大网（筛子）把所有不符合条件的数“筛”出来，剩下的就是可报的数。

在本题中，筛法的应用分为两步：
1. **标记不可报数**：遍历每个数，若它包含数字7，则标记它和它的所有倍数为不可报。
2. **预处理下一个可报数**：反向遍历数组，记录每个可报数的下一个可报数，实现O(1)查询。

核心难点在于高效标记（避免重复标记）和预处理下一个数。例如，如何避免重复标记已被筛过的数？如何快速找到下一个可报数？

可视化设计思路：用8位像素网格表示1到1e7的数，每个格子初始为绿色（可报）。当筛到包含7的数时，该格子变红，并扩散标记其倍数（红色波浪动画）。预处理下一个数时，用蓝色箭头从后向前连接可报数，动态展示“下一个”的推导过程。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等维度筛选了以下优质题解：
</eval_intro>

**题解一：银杉水杉秃杉（赞：272）**
* **点评**：此题解思路清晰，代码规范。预处理部分通过埃氏筛标记不可报数，反向遍历记录下一个可报数，时间复杂度O(1e7 + T)，完美适配题目数据范围。代码包含读入输出优化（快读快写），边界处理严谨（如筛到1e7+100）。亮点是通过`nx`数组直接存储下一个可报数，查询效率极高。

**题解二：StudyingFather（赞：46）**
* **点评**：此题解用`vis`数组标记不可报数，`lis`数组存储可报数列表，通过下标映射实现O(1)查询。代码结构简洁，注释清晰，适合理解筛法的基本逻辑。亮点是将可报数按顺序存储，方便后续查询。

**题解三：Mortis_Vampire（赞：10）**
* **点评**：此题解反向遍历预处理下一个可报数（`last`变量维护当前最小可报数），代码简洁高效。亮点是反向遍历的思路，避免了正向遍历时逐个查找的高复杂度。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于高效预处理，以下是关键步骤和策略：
</difficulty_intro>

1.  **关键点1：如何高效标记不可报数？**
    * **分析**：包含数字7的数需标记其所有倍数。若直接暴力标记，时间复杂度会很高。优化方法是：若当前数已被标记（已是不可报数），则跳过；否则检查是否含7，若含则标记其所有倍数。这避免了重复标记，时间复杂度接近O(n log n)。
    * 💡 **学习笔记**：筛法的关键是“避免重复操作”，利用已标记的信息跳过无效计算。

2.  **关键点2：如何预处理下一个可报数？**
    * **分析**：若正向遍历查找下一个可报数，每次查询可能需要O(k)时间（k为间隔），无法处理大量查询。优化方法是反向遍历：从1e7+1开始，维护当前最小可报数`last`，若当前数可报，则`ans[i] = last`，并更新`last`为i。这样预处理后，查询只需O(1)。
    * 💡 **学习笔记**：反向遍历能高效维护“下一个”关系，适合处理需要快速查询后继的问题。

3.  **关键点3：如何处理大数范围的空间限制？**
    * **分析**：1e7的数组需要约10MB（bool类型），现代计算机可轻松处理。但需注意筛的范围要略大于1e7（如1e7+100），避免查询最大数时越界。
    * 💡 **学习笔记**：预处理时，数组大小需覆盖可能的查询结果（如本题下一个数可能超过1e7）。

### ✨ 解题技巧总结
- **筛法优化**：标记时跳过已标记的数，减少重复操作。
- **反向预处理**：维护当前最小可报数，快速记录每个数的下一个可报数。
- **输入输出优化**：使用快读快写（如`getchar`实现），减少I/O时间，避免TLE。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，给出一个清晰高效的核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了银杉水杉秃杉和Mortis_Vampire的思路，预处理不可报数并反向记录下一个可报数，支持O(1)查询。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e7 + 100; // 覆盖到1e7+100，避免越界
    bool f[N]; // 标记不可报数，true为不可报
    int nx[N]; // 存储下一个可报数

    // 判断是否包含数字7
    bool has_seven(int x) {
        while (x) {
            if (x % 10 == 7) return true;
            x /= 10;
        }
        return false;
    }

    void init() {
        // 步骤1：标记不可报数
        for (int i = 1; i < N; ++i) {
            if (f[i]) continue; // 已标记，跳过
            if (has_seven(i)) {
                // 标记i的所有倍数
                for (int j = i; j < N; j += i)
                    f[j] = true;
            }
        }
        // 步骤2：反向预处理下一个可报数
        int last = N; // 初始为1e7+100（第一个可能的可报数）
        for (int i = N - 1; i >= 1; --i) {
            if (!f[i]) { // 当前数可报
                nx[i] = last;
                last = i;
            } else {
                nx[i] = -1; // 不可报数的下一个数无意义，设为-1
            }
        }
    }

    // 快读
    inline int read() {
        int x = 0, f = 1;
        char ch = getchar();
        while (!isdigit(ch)) {
            if (ch == '-') f = -1;
            ch = getchar();
        }
        while (isdigit(ch)) {
            x = x * 10 + (ch - '0');
            ch = getchar();
        }
        return x * f;
    }

    // 快写
    inline void write(int x) {
        if (x < 0) {
            putchar('-');
            x = -x;
        }
        if (x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }

    int main() {
        init();
        int T = read();
        while (T--) {
            int x = read();
            if (f[x]) {
                puts("-1");
            } else {
                write(nx[x]);
                putchar('\n');
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
  - `has_seven`函数判断数是否含7。
  - `init`函数分两步：先用筛法标记不可报数，再反向遍历记录每个可报数的下一个可报数。
  - 快读快写优化输入输出，适应大规模数据。

---
<code_intro_selected>
以下是优质题解的核心片段赏析：
</code_intro_selected>

**题解一：银杉水杉秃杉**
* **亮点**：快读快写优化，`nx`数组直接存储下一个可报数，查询高效。
* **核心代码片段**：
    ```cpp
    void init() {
        for (int i = 1; i <= N - 10; i++) {
            if (f[i]) continue;
            if (check(i)) { // check即has_seven
                for (int j = i; j <= N - 10; j += i)
                    f[j] = 1;
                continue;
            }
            nx[ls] = i; // ls维护上一个可报数
            ls = i;
        }
    }
    ```
* **代码解读**：
  - `ls`变量维护上一个可报数，每次遇到新的可报数`i`，则`nx[ls] = i`，即`ls`的下一个可报数是`i`。
  - 此逻辑正向遍历，逐步构建`nx`数组，与反向遍历思路异曲同工。
* 💡 **学习笔记**：正向或反向遍历均可预处理下一个数，关键是维护“前驱-后继”关系。

**题解二：Mortis_Vampire**
* **亮点**：反向遍历预处理，代码简洁。
* **核心代码片段**：
    ```cpp
    int last = 10000001; // 初始为1e7+1
    for (int i = 10000000; i >= 1; i--) {
        ans[i] = last;
        if (!ton[i]) last = i; // ton数组标记不可报数
    }
    ```
* **代码解读**：
  - `last`维护当前最小可报数，反向遍历时，若当前数可报（`!ton[i]`），则更新`last`为i，否则`ans[i]`保持为`last`。
  - 此方法直接记录每个数的下一个可报数，逻辑清晰。
* 💡 **学习笔记**：反向遍历能高效维护“下一个”关系，避免正向查找的高复杂度。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解筛法和预处理过程，我们设计一个“像素筛子”动画，用8位复古风格展示不可报数的标记和下一个可报数的推导。
</visualization_intro>

  * **动画演示主题**：`像素筛子大作战`（8位FC风格）
  * **核心演示内容**：展示筛法标记不可报数（含7的数及其倍数），以及反向遍历预处理下一个可报数的过程。
  * **设计思路简述**：8位像素风格降低学习压力，动态标记和箭头连接直观展示算法逻辑。音效（如标记时“叮”声，完成时“胜利”音效）增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕显示100x100的像素网格（代表1到1e4的数，可缩放），每个格子初始为绿色（可报）。
        - 控制面板：单步/自动播放按钮、速度滑块、重置按钮。
        - 背景播放8位风格BGM（如《超级马力欧》经典旋律）。

    2.  **筛法标记不可报数**：
        - 遍历每个数`i`（像素格子从左到右、从上到下移动）。
        - 若`i`含7（格子显示数字7），则格子变红，并触发“标记”动画（红色波浪扩散，标记其所有倍数格子变红），伴随“叮”音效。
        - 若`i`已被标记（红色），跳过（格子闪烁灰色）。

    3.  **预处理下一个可报数**：
        - 反向遍历（格子从右下到左上移动），维护`last`指针（蓝色箭头）。
        - 若当前格子绿色（可报），则`last`指向它，并用蓝色线条连接前一个绿色格子（表示“下一个可报数”）。
        - 最终形成蓝色箭头链，直观展示每个可报数的下一个目标。

    4.  **查询演示**：
        - 输入一个数`x`，对应格子高亮（黄色）。
        - 若红色（不可报），显示“-1”并播放“失败”音效；若绿色，蓝色箭头跳转到下一个可报数，播放“成功”音效。

  * **旁白提示**：
    - （筛法时）“当前数含7，标记它和所有倍数！”
    - （预处理时）“反向遍历，记录每个可报数的下一个目标～”
    - （查询时）“看，下一个可报数在这里！”

<visualization_conclusion>
通过这个动画，我们能直观看到筛法如何标记不可报数，以及预处理如何快速找到下一个可报数。像素风格和音效让学习更有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的筛法和预处理后，可尝试以下拓展练习，巩固算法思想：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 筛法可用于标记满足特定条件的数（如素数、含某数字的数）及其倍数。
    - 预处理后继关系（如“下一个素数”“下一个不含某因子的数”）是处理大量查询的常用方法。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3383 [模板] 线性筛法（素数）**
        * 🗣️ **推荐理由**：练习埃氏筛和欧拉筛的基础应用，理解筛法的核心思想。
    2.  **洛谷 P2036 [COCI2008-2009#2] 矩形**
        * 🗣️ **推荐理由**：需要预处理满足条件的数，与本题思路类似，适合拓展思维。
    3.  **洛谷 P1865 A+B Problem（类似素数筛）**
        * 🗣️ **推荐理由**：通过筛法标记非素数，练习预处理和查询的结合。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了考场经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自银杉水杉秃杉)**：“考场上一定要用读入输出优化，小心被卡。”
> 
> **点评**：对于大规模数据（如T=2e5），快读快写能显著减少I/O时间，避免超时。这提醒我们，在处理大数据量时，输入输出优化是关键。

---

<conclusion>
本次关于“[NOIP2021] 报数”的分析就到这里。通过筛法预处理和反向记录下一个可报数，我们能高效解决问题。记住，多练习筛法和预处理技巧，遇到类似问题就能轻松应对！下次见～💪
</conclusion>

---
处理用时：148.89秒
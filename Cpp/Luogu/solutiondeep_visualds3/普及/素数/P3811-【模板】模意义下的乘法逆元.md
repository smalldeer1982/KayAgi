# 题目信息

# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# AI分析结果



---
# 💡 Kay的C++算法解析：【模板】模意义下的乘法逆元 深入学习指南 💡

<introduction>
今天我们要一起攻克的题目是“模意义下的乘法逆元”。这是数论中的经典问题，也是竞赛编程的高频考点。通过这份指南，你不仅能理解乘法逆元的核心概念，还能掌握高效求解多个逆元的方法，快来一起探索吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（乘法逆元求解）`

🗣️ **初步分析**：
解决这道题的关键是理解乘法逆元的定义，并选择高效的算法。乘法逆元就像模运算中的“倒数”——如果说普通乘法中3的倒数是1/3，那么在模13下，3的逆元就是某个数x，使得3×x ≡1 mod13（比如样例中3的逆元是9，因为3×9=27≡1 mod13）。

题目要求求1~n所有数的逆元，且n可达3×10⁶。此时，扩展欧几里得（O(n log p)）和快速幂（O(n log p)）的时间复杂度都不够高效，**线性递推法（O(n)）** 是最优选择。它通过递推公式：  
$$inv[i] = (p - \lfloor \frac{p}{i} \rfloor) \times inv[p \bmod i] \bmod p$$  
利用已计算的小数逆元推导大数逆元，完美适配大规模数据。

**可视化设计思路**：我们将用8位像素风格演示线性递推过程：  
- 屏幕左侧是“逆元计算区”，用像素方块表示1~n的数字，颜色从蓝到红渐变（数字越大颜色越深）。  
- 右侧是“递推公式展示区”，动态高亮当前计算的i、p/i、p mod i以及inv[p mod i]。  
- 关键步骤（如i=1初始化、i=2开始递推）触发“叮”的音效；计算完成时播放“胜利”音效，所有方块变为绿色。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范度、算法效率等维度筛选了3份优质题解，它们对线性递推的推导和实现都有深入解析。
</eval_intro>

**题解一：作者 zjp_shadow（赞1017）**  
* **点评**：这份题解系统总结了逆元的多种解法（扩展欧几里得、快速幂、线性递推），尤其对线性递推的推导过程（从p=ki+r的等式变形到递推公式）解释得非常透彻。代码简洁规范（如`inv[1]=1`的初始化），并强调了“p是质数”这一关键条件，对边界处理（如负数取模）的细节也有说明，非常适合初学者理解。

**题解二：作者 Rising_Date（赞197）**  
* **点评**：此题解重点对比了不同算法的效率，明确指出线性递推是唯一能处理3e6规模数据的方法。代码中使用`(p - p/i)*inv[p%i]%p`巧妙避免了负数，对模运算的细节处理很到位。作者还给出了不同算法的运行时间（如线性递推664ms vs 扩展欧几里得1240ms），帮助学习者直观理解算法选择的重要性。

**题解三：作者 一扶苏一（赞41）**  
* **点评**：此题解从逆元的存在条件（x与p互质）出发，结合数论定理（贝祖定理）严格证明了线性递推的正确性。代码中包含阶乘逆元的计算（`factinv[i]`），展示了逆元的扩展应用，对后续学习组合数取模很有启发。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们需要突破以下核心难点：
</difficulty_intro>

1.  **关键点1：理解乘法逆元的定义与存在条件**  
    * **分析**：逆元存在的充要条件是x与p互质。题目中p是质数，且x∈[1,n]<p（因n<p），所以所有x都与p互质，逆元必然存在。例如，p=13时，x=2与13互质，所以存在逆元7（2×7=14≡1 mod13）。  
    * 💡 **学习笔记**：逆元不是“倒数的模”，而是满足同余方程的解，存在性由互质性保证。

2.  **关键点2：推导线性递推公式**  
    * **分析**：线性递推的核心是利用p=ki+r的等式变形。例如，当i=2，p=13时，k=6（13/2=6），r=1（13%2=1），则inv[2] = (13-6)×inv[1] mod13=7×1=7，与样例一致。这里r=p%i <i，所以inv[r]已提前计算。  
    * 💡 **学习笔记**：递推公式的本质是“用小数逆元推导大数逆元”，类似动态规划的思想。

3.  **关键点3：处理模运算中的负数**  
    * **分析**：递推公式中的`-k×inv[r]`可能为负数（如k=6，inv[1]=1时，-6×1=-6），需通过`(p - k×inv[r]%p) %p`转换为正数。例如，-6 mod13=7，符合样例结果。  
    * 💡 **学习笔记**：模运算中负数取正的通用方法是`(x %p +p) %p`。

### ✨ 解题技巧总结
- **问题抽象**：将“求多个逆元”抽象为“递推问题”，利用已计算的小数结果推导大数结果。  
- **边界处理**：初始化inv[1]=1（1×1=1≡1 modp），确保递推起点正确。  
- **模运算优化**：用`p - (p/i) %p`替代负数计算，避免中间结果为负。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择线性递推法的核心代码作为通用实现，它能在O(n)时间内解决问题，适合大规模数据。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了多个优质题解的线性递推思路，代码简洁高效，适合直接用于竞赛。  
* **完整核心代码**：  
```cpp
#include <cstdio>
const int MAXN = 3e6 + 5;
int inv[MAXN];

int main() {
    int n, p;
    scanf("%d%d", &n, &p);
    inv[1] = 1; // 1的逆元是1
    printf("1\n"); // 直接输出第一个结果
    for (int i = 2; i <= n; ++i) {
        inv[i] = (long long)(p - p / i) * inv[p % i] % p;
        printf("%d\n", inv[i]);
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先初始化inv[1]=1（1的逆元恒为1），然后从i=2开始递推。对于每个i，利用公式`inv[i] = (p - p/i) * inv[p%i] %p`计算逆元，其中`p%i`是比i小的数，其逆元已提前计算。最后逐个输出结果。

---

<code_intro_selected>
接下来，我们分析优质题解中的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：作者 zjp_shadow**  
* **亮点**：代码直接使用`(p - p/i) * inv[p%i] %p`，避免了负数运算，简洁高效。  
* **核心代码片段**：  
```cpp
inv[1] = 1;
for(int i = 2; i < p; ++ i)
    inv[i] = (p - p / i) * inv[p % i] % p;
```
* **代码解读**：  
  - `inv[1] = 1`：初始化边界条件，1的逆元恒为1。  
  - `i从2开始循环`：因为i=1已处理，且i必须小于p（题目保证n <p）。  
  - `(p - p/i)`：将负数`-p/i`转换为正数（如p=13，i=2时，p/i=6，p-p/i=7）。  
  - `inv[p%i]`：p%i <i，其逆元已计算，直接复用。  
* 💡 **学习笔记**：递推的关键是利用“小数逆元已知”的特性，避免重复计算。

**题解二：作者 Rising_Date**  
* **亮点**：代码中使用`long long`强制转换防止乘法溢出，确保计算正确性。  
* **核心代码片段**：  
```cpp
inv[i] = (ll)p - (p/i)*inv[p%i]%p;
```
* **代码解读**：  
  - `(ll)p`：将p转换为long long类型，防止`(p/i)*inv[p%i]`溢出int范围（当p接近2e7时，p/i和inv[p%i]可能都是大数）。  
  - `%p`：最后取模确保结果在[0,p-1]范围内。  
* 💡 **学习笔记**：大数运算时，用long long暂存中间结果是避免溢出的常用技巧。

**题解三：作者 一扶苏一**  
* **亮点**：代码中同时计算了阶乘逆元`factinv`，展示了逆元的扩展应用。  
* **核心代码片段**：  
```cpp
factinv[1] = inv[1] = 1;
for (int i = 2; i <= n; ++i) {
    inv[i] = 1ll * (p - p / i) * inv[p % i] % p;
    factinv[i] = 1ll * factinv[i - 1] * inv[i] % p;
}
```
* **代码解读**：  
  - `factinv[i]`：表示i!的逆元，利用`factinv[i] = factinv[i-1] * inv[i]`递推（因为i! = (i-1)! ×i，所以其逆元是(i-1)!的逆元 ×i的逆元）。  
  - `1ll *`：强制转换为long long，防止乘法溢出。  
* 💡 **学习笔记**：逆元不仅能单独求解，还能与其他运算（如阶乘）结合，解决更复杂的问题。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解线性递推的过程，我们设计了一个“像素逆元工厂”动画，用8位复古风格演示每个数的逆元如何被计算出来！
</visualization_intro>

  * **动画演示主题**：`像素逆元工厂——从1到n的逆元生产线`

  * **核心演示内容**：  
    展示线性递推的每一步：从i=1开始，逐步计算i=2,3,...,n的逆元，动态更新每个i的逆元值，并高亮递推公式中的关键参数（p/i、p%i、inv[p%i]）。

  * **设计思路简述**：  
    采用FC红白机风格的像素画面（8色调色板，如深蓝背景、亮绿文字），让学习过程更轻松。关键步骤的音效（如“叮”提示计算完成）和颜色变化（如当前计算的i用红色闪烁）能强化记忆点，游戏化的“生产进度条”增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：  
        - 屏幕分为左右两部分：左侧是“数字轨道”（1~n的像素方块，初始为灰色），右侧是“公式看板”（显示递推公式`inv[i] = (p - p/i) × inv[p%i] mod p`）。  
        - 控制面板包含“开始”“单步”“加速”按钮，以及进度条显示当前计算到的i值。

    2.  **启动计算（i=1）**：  
        - 数字轨道的i=1方块变为绿色，显示“inv[1]=1”，播放“滴”的音效（表示初始化完成）。

    3.  **递推计算（i≥2）**：  
        - 选中当前i的方块（红色闪烁），公式看板高亮`i=当前值`。  
        - 计算`p/i`（如i=2，p=13时，p/i=6），用黄色箭头从i指向p/i的数值。  
        - 计算`p%i`（如i=2时，p%i=1），用蓝色箭头从i指向p%i的方块（此时p%i=1的方块已为绿色）。  
        - 计算`(p - p/i)`（如6→13-6=7），用紫色箭头显示这个转换。  
        - 最终计算`inv[i] = 7 × inv[1] mod13 =7`，当前i的方块变为绿色，显示结果，播放“叮”的音效。  
        - 重复此过程，直到所有i的方块变为绿色。

    4.  **完成状态**：  
        - 所有方块变为绿色，进度条填满，播放“胜利”音效（如《超级玛丽》的通关音乐）。  
        - 公式看板显示“所有逆元计算完成！”，并提示“点击重置重新观看”。

  * **旁白提示**：  
    - （i=1时）“1的逆元恒为1，就像1×1=1一样简单～”  
    - （i=2时）“看！p%i=1的逆元已经算过了，我们可以直接用它来算i=2的逆元～”  
    - （计算中）“当前i的逆元等于（p - p/i）乘以前面算好的p%i的逆元，再取模哦！”

<visualization_conclusion>
通过这个动画，你可以“亲眼”看到每个逆元是如何被前面的小数逆元“生产”出来的，是不是比看公式更直观？
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了线性递推求逆元后，我们可以用类似思路解决更多数论问题！
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    线性递推法的核心是“用已知解推导未知解”，这一思想还可用于：  
    - 求阶乘逆元（如组合数计算中的`C(n,k) = n! / (k! (n-k)!) mod p`）。  
    - 求幂次逆元（如多次查询不同数的逆元时，预处理所有逆元）。  
    - 处理模意义下的除法问题（如分数取模、概率计算）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5431** - `乘法逆元2`  
        * 🗣️ **推荐理由**：此题要求处理多个数的逆元连乘，需要结合线性递推和前缀积技巧，能巩固逆元的综合应用。  
    2.  **洛谷 P2613** - `有理数取模`  
        * 🗣️ **推荐理由**：此题需要将分数取模转换为乘法逆元问题，适合练习逆元的基本应用。  
    3.  **洛谷 P1313** - `计算系数`  
        * 🗣️ **推荐理由**：此题涉及二项式系数取模，需要用到阶乘逆元，能拓展逆元的实际应用场景。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些“踩坑”经历对我们很有启发：
</insights_intro>

> **参考经验 (来自 一扶苏一)**：“在实现线性递推时，一开始忘记初始化inv[1]=1，导致所有结果错误。后来通过打印前几个逆元（如i=2的逆元）才发现问题。”

> **点评**：初始化是递推算法的“起点”，就像建房子要打地基一样重要。调试时，打印前几个结果（如i=2、i=3的逆元）是快速定位初始化错误的有效方法。

-----

<conclusion>
乘法逆元是数论的重要工具，而线性递推法是解决大规模逆元问题的“利器”。通过理解定义、推导公式、动手编码和可视化演示，你已经掌握了这一核心技能。接下来，快去挑战推荐的题目，巩固你的学习成果吧！💪
</conclusion>

-----

---
处理用时：155.22秒
# 题目信息

# [NOIP2021] 报数

## 题目描述

报数游戏是一个广为流传的休闲小游戏。参加游戏的每个人要按一定顺序轮流报数，但如果下一个报的数是 $7$ 的倍数，或十进制表示中含有数字 $7$，就必须跳过这个数，否则就输掉了游戏。

在一个风和日丽的下午，刚刚结束 SPC20nn 比赛的小 r 和小 z 闲得无聊玩起了这个报数游戏。但在只有两个人玩的情况下计算起来还是比较容易的，因此他们玩了很久也没分出胜负。此时小 z 灵光一闪，决定把这个游戏加强：任何一个十进制中含有数字 $7$ 的数，它的所有倍数都不能报出来！

形式化地，设 $p(x)$ 表示 $x$ 的十进制表示中是否含有数字 $7$，若含有则 $p(x) = 1$，否则 $p(x) = 0$。则一个正整数 $x$ 不能被报出，当且仅当存在正整数 $y$ 和 $z$ ，使得 $x = yz$ 且 $p(y) = 1$。


例如，如果小 r 报出了 $6$ ，由于 $7$ 不能报，所以小 z 下一个需要报 $8$；如果小 r 报出了 $33$，则由于 $34 = 17 \times 2$，$35 = 7 \times 5$ 都不能报，小 z 下一个需要报出 $36$ ；如果小 r 报出了 $69$，由于 $70 \sim 79$ 的数都含有 $7$，小 z 下一个需要报出 $80$ 才行。

现在小 r 的上一个数报出了 $x$，小 z 想快速算出他下一个数要报多少，不过他很快就发现这个游戏可比原版的游戏难算多了，于是他需要你的帮助。当然，如果小 r 报出的 x 本身是不能报出的，你也要快速反应过来小 r 输了才行。

由于小 r 和小 z 玩了很长时间游戏，你也需要回答小 z 的很多个问题。

## 说明/提示

**【样例解释 #1】**

这一组样例的前 $3$ 次询问在题目描述中已有解释。

对于第 $4$ 次询问，由于 $300 = 75 \times 4$，而 $75$ 中含有 $7$ ，所以小 r 直接输掉了游戏。

**【数据范围】**

对于 $10\%$ 的数据，$T \leq 10$，$x \leq 100$。  
对于 $30\%$ 的数据，$T \leq 100$，$x \leq 1000$。  
对于 $50\%$ 的数据，$T \leq 1000$，$x \leq 10000$。  
对于 $70\%$ 的数据，$T \leq 10000$，$x \leq 2 \times {10}^5$。  
对于 $100\%$ 的数据，$1 \le T \leq 2 \times {10}^5$，$1 \le x \leq {10}^7$。

## 样例 #1

### 输入

```
4
6
33
69
300
```

### 输出

```
8
36
80
-1
```

## 样例 #2

### 输入

```
5
90
99
106
114
169
```

### 输出

```
92
100
109
-1
180
```

## 样例 #3

### 输入

```
见附件中的 number/number3.in```

### 输出

```
见附件中的 number/number3.ans```

## 样例 #4

### 输入

```
见附件中的 number/number4.in```

### 输出

```
见附件中的 number/number4.ans```

# AI分析结果



---
# 💡 Kay的C++算法解析：NOIP2021 报数 深入学习指南 💡

<introduction>
今天我们来一起分析NOIP2021的“报数”这道题。这道题看似简单，但涉及到高效预处理和筛法应用，是理解算法优化的好例子。本指南将帮助大家梳理题目思路，掌握核心算法，并学会如何通过预处理解决大规模查询问题。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`筛法与预处理应用` (模拟与筛法结合的典型问题)

🗣️ **初步分析**：
解决“报数”问题的关键在于**高效预处理所有不可报数**，并快速查询下一个可报数。简单来说，筛法就像一个“过滤筛子”，把不符合条件的数（不可报数）筛掉，剩下的就是可报数。在本题中，筛法用于标记所有含有数字7的数及其倍数为不可报数，预处理每个数的下一个可报数，从而让每次查询只需O(1)时间。

- **题解思路**：所有题解的核心思路一致：先用筛法标记所有不可报数（含7的数及其倍数），再预处理每个可报数的下一个可报数。不同题解的差异主要在于筛法的细节优化（如提前剪枝）和预处理方式（如正向记录vs反向递推）。
- **核心难点**：如何高效标记不可报数（避免重复标记），以及如何预处理下一个可报数（避免查询时逐个遍历）。
- **可视化设计**：我们可以设计一个8位像素风格的筛法动画，用不同颜色标记不可报数（如红色）和可报数（绿色），动态展示筛法过程（如标记含7的数时，其倍数逐个变红），并显示下一个可报数的预处理逻辑（如反向递推时，当前可报数的下一个数被记录）。动画支持单步执行、自动播放，关键步骤伴随“叮”的音效（如标记完成）和“胜利”音效（如找到下一个可报数）。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑简洁、优化到位被选为优质题解（≥4星）：
</eval_intro>

**题解一：作者银杉水杉秃杉（赞272）**
* **点评**：此题解思路非常清晰，预处理逻辑直接明了。代码规范（如变量名`f`表示不可报标记，`nx`记录下一个可报数），并包含读入输出优化（`read`和`write`函数），适合竞赛场景。算法上，筛法通过剪枝（跳过已标记数）优化时间复杂度至O(1e7 + T)，预处理`nx`数组时反向递推，确保查询O(1)。实践价值极高，是处理大规模查询问题的典范。

**题解二：作者滑_稽（赞16）**
* **点评**：此题解对题意的简化和正确性证明很到位，代码结构清晰（`judge`函数判断含7，`GetSafeNum`筛法预处理）。亮点是用`Safenum`和`Numsafe`两个数组建立可报数的索引映射，查询时直接通过下标定位下一个数，逻辑直观易懂，适合初学者理解预处理思想。

**题解三：作者Mortis_Vampire（赞10）**
* **点评**：此题解通过反向递推预处理`ans`数组（从1e7倒序记录下一个可报数），代码简洁高效。筛法部分用`pd`函数判断含7，标记倍数时避免重复操作，时间复杂度控制得当。适合学习反向预处理技巧。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们通常会遇到以下关键点。结合优质题解的共性，提炼核心思考方向：
</difficulty_intro>

1.  **关键点1：如何高效标记不可报数？**
    * **分析**：不可报数包括两类：含7的数、含7的数的倍数。直接标记所有含7的数的倍数会重复标记（如14是7的倍数，也是14的倍数）。优质题解通过筛法剪枝（跳过已标记数）避免重复：若当前数已被标记，直接跳过；否则检查是否含7，若是则标记其所有倍数。
    * 💡 **学习笔记**：筛法的核心是“标记后跳过”，避免重复操作，保证时间复杂度。

2.  **关键点2：如何预处理下一个可报数？**
    * **分析**：若每次查询时逐个查找下一个可报数，最坏情况O(1e7)会超时。优质题解通过预处理数组（如`nx`、`ans`）记录每个可报数的下一个数。例如反向递推：从1e7倒序遍历，维护当前最小的可报数`lst`，每个可报数的下一个数即为`lst`，并更新`lst`为当前数。
    * 💡 **学习笔记**：预处理是解决大规模查询问题的关键，用空间换时间，将单次查询复杂度降至O(1)。

3.  **关键点3：如何处理大数据范围的空间和时间限制？**
    * **分析**：数据范围到1e7，数组大小需开至1e7+100（避免越界）。优质题解通过合理选择数组类型（如`bool`数组节省空间）和筛法优化（如仅处理未标记数），确保内存和时间在允许范围内。
    * 💡 **学习笔记**：大数据范围问题需注意数组大小和内存限制，`bool`数组每元素占1字节，1e7大小约10MB，可接受。

### ✨ 解题技巧总结
- **筛法剪枝**：标记不可报数时，跳过已标记数，避免重复操作。
- **反向预处理**：从大到小遍历，维护当前最小可报数，快速记录每个数的下一个可报数。
- **输入输出优化**：使用快读快写（如`read`和`write`函数），减少IO时间，应对大规模查询（T≤2e5）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了筛法预处理和反向递推，代码简洁高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了银杉水杉秃杉和滑_稽的题解思路，预处理不可报数并反向递推下一个可报数，适合竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e7 + 100; // 数据范围+100避免越界
    int T, x;
    bool f[N]; // 不可报标记，true表示不可报
    int nx[N]; // 下一个可报数

    // 判断是否含数字7
    bool check(int x) {
        while (x) {
            if (x % 10 == 7) return true;
            x /= 10;
        }
        return false;
    }

    void init() {
        // 筛法标记不可报数
        for (int i = 1; i < N; ++i) {
            if (f[i]) continue; // 已标记，跳过
            if (check(i)) {
                // 含7，标记所有倍数
                for (int j = i; j < N; j += i)
                    f[j] = true;
            }
        }
        // 反向递推下一个可报数
        int lst = N; // 初始为1e7+100（第一个可能的可报数）
        for (int i = N - 1; i >= 1; --i) {
            if (!f[i]) { // 可报数
                nx[i] = lst;
                lst = i;
            } else {
                nx[i] = -1; // 不可报数，下一个数为-1（实际查询时直接输出-1）
            }
        }
    }

    inline int read() {
        int x = 0, f = 1;
        char ch = getchar();
        while (!isdigit(ch)) {
            if (ch == '-') f = -1;
            ch = getchar();
        }
        while (isdigit(ch)) {
            x = (x << 1) + (x << 3) + (ch ^ 48);
            ch = getchar();
        }
        return x * f;
    }

    inline void write(int x) {
        if (x < 0) {
            putchar('-');
            x = -x;
        }
        if (x >= 10) write(x / 10);
        putchar(x % 10 + '0');
    }

    int main() {
        init();
        T = read();
        while (T--) {
            x = read();
            if (f[x]) {
                puts("-1");
            } else {
                write(nx[x]);
                putchar('\n');
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先通过`check`函数判断是否含7，`init`函数用筛法标记所有不可报数（含7的数及其倍数）。然后反向递推`nx`数组，记录每个可报数的下一个数。输入输出使用快读快写优化，处理大规模查询。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者银杉水杉秃杉**
* **亮点**：筛法剪枝+正向记录下一个可报数，代码简洁高效。
* **核心代码片段**：
    ```cpp
    void init() {
        for (int i = 1; i <= N - 10; i++) {
            if (f[i]) continue;
            if (check(i)) {
                for (int j = i; j <= N - 10; j += i)
                    f[j] = 1;
                continue;
            }
            nx[ls] = i; // 记录上一个可报数的下一个数为i
            ls = i; // 更新上一个可报数
        }
    }
    ```
* **代码解读**：这段代码正向遍历，`ls`维护上一个可报数。若当前数可报（不含7且未被标记），则`nx[ls]`设为当前数（即上一个可报数的下一个数是当前数），并更新`ls`。这种正向记录的方式直观，适合理解预处理逻辑。
* 💡 **学习笔记**：正向记录需维护“上一个”可报数，适合顺序处理；反向递推更简洁（如通用代码），但两种方法本质相同。

**题解二：作者滑_稽**
* **亮点**：用两个数组建立可报数的索引映射，查询时直接通过下标定位。
* **核心代码片段**：
    ```cpp
    void GetSafeNum() {
        for (int i = 1; i < maxN; i++) {
            if (judge(i)) for (int j = 1; j * i < maxN; j++) Ill[j * i] = 1;
            if (!Ill[i]) {
                tot++; // 可报数个数
                Safenum[tot] = i; // 可报数数组
                Numsafe[i] = tot; // 数到下标的映射
            }
        }
    }
    ```
* **代码解读**：`Safenum`存储所有可报数（按顺序），`Numsafe`存储每个可报数的下标。查询时，若`x`可报，其下标为`Numsafe[x]`，下一个数为`Safenum[Numsafe[x]+1]`。这种映射方法将查询转化为数组下标操作，逻辑直观。
* 💡 **学习笔记**：索引映射是预处理的常用技巧，适合需要快速定位顺序元素的场景。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解筛法和预处理过程，我们设计一个“像素筛子”动画，用8位复古风格展示不可报数的标记和下一个可报数的预处理。
</visualization_intro>

  * **动画演示主题**：`像素筛子大冒险`（8位风格，类似红白机游戏）

  * **核心演示内容**：展示筛法标记不可报数的过程（含7的数及其倍数变红），以及反向递推下一个可报数的逻辑（可报数变绿，记录下一个数）。

  * **设计思路简述**：采用8位像素风格（16色调色板，方块元素），通过颜色变化（红=不可报，绿=可报）和动态标记（倍数逐个变红）直观展示筛法。音效（“叮”标记完成，“唰”倍数变红）增强操作记忆，自动播放模式模拟算法执行，帮助理解预处理逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕分为左右两部分：左侧是100x100的像素网格（代表1e4个数，缩放展示），右侧是控制面板（开始/暂停、单步、调速滑块）。
          * 初始时所有像素块为灰色（未处理），背景音乐为8位风格的轻快旋律。

    2.  **筛法标记**：
          * 单步执行时，当前处理数`i`用黄色箭头标记。若`i`含7（如7、17），则`i`变红，其所有倍数（如14、21、28...）逐个变红，伴随“唰”的音效。
          * 若`i`已被标记（红色），跳过，箭头直接指向下一个数。
          * 自动播放时，倍数变红的速度由调速滑块控制（慢→快）。

    3.  **预处理下一个可报数**：
          * 筛法完成后，网格变为红绿两色（红=不可报，绿=可报）。
          * 反向递推时，从网格右下角（1e7）开始，绿色像素块逐个向上移动，记录下一个可报数（如当前绿块的下一个数是右边最近的绿块），伴随“滴答”音效。

    4.  **查询演示**：
          * 输入一个数`x`，若`x`是红色（不可报），弹出“-1”对话框，伴随“咚”的提示音；若`x`是绿色（可报），箭头从`x`指向其下一个可报数（绿色块），显示数值，伴随“叮”的成功音。

  * **旁白提示**：
      * （筛法时）“当前处理数i=7，含7，标记其所有倍数！”
      * （预处理时）“从大到小遍历，记录每个可报数的下一个数~”
      * （查询时）“x=6是绿色，下一个可报数是8！”

<visualization_conclusion>
通过这个动画，我们能清晰看到筛法如何标记不可报数，以及预处理如何快速找到下一个可报数，让抽象的算法变得“看得见、摸得着”。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题的筛法和预处理思想后，我们可以尝试解决更多类似问题，巩固算法应用能力。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 筛法思想可用于标记满足特定条件的数（如素数、平方数）及其倍数。
      * 预处理下一个符合条件的数，适用于需要多次查询“下一个”或“前一个”的场景（如日期计算、序列查询）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3383 线性筛法（素数筛）**
          * 🗣️ **推荐理由**：练习线性筛法（欧拉筛），理解更高效的筛法优化，对比埃氏筛的差异。
    2.  **洛谷 P1865 A+B Problem（素数筛）**
          * 🗣️ **推荐理由**：结合区间筛法，处理大范围素数查询，巩固筛法应用。
    3.  **洛谷 P1072 质数的和与积**
          * 🗣️ **推荐理由**：通过筛法预处理素数，解决素数组合问题，训练预处理与查询结合的能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了考试中的经验，对我们很有启发：
</insights_intro>

> **参考经验 (来自银杉水杉秃杉)**：“T1太水了，导致其他三道很难，拉不开差距。今年NOIP直接爆炸，宣告退役。”  
> **点评**：作者的经验提醒我们，即使简单题也需重视细节（如输入输出优化、数组大小），避免因小失大。同时，竞赛中保持心态稳定，不因题目简单而松懈，是取得好成绩的关键。

---

<conclusion>
本次关于“报数”题的分析就到这里。通过理解筛法预处理和下一个可报数的记录，我们掌握了处理大规模查询问题的关键技巧。记住，预处理是解决这类问题的核心，多练习类似题目（如素数筛、区间查询）能进一步提升算法能力。下次再见，我们一起挑战更难的题目！💪
</conclusion>

---

---
处理用时：185.44秒
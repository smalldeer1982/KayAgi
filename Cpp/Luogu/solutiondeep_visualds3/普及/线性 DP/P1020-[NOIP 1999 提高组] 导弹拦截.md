# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用 $\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果


### 💡 Kay的C++算法解析：导弹拦截 深入学习指南 💡

<introduction>
大家好！今天我们来分析经典的「导弹拦截」问题。这道题来自NOIP1999提高组，考察动态规划、贪心算法和Dilworth定理的应用。本指南将帮助你理解核心算法，掌握解题技巧，并通过像素动画直观感受算法执行过程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划与贪心优化` + `Dilworth定理应用`

🗣️ **初步分析**：
> 导弹拦截问题本质是序列分解问题。想象你玩塔防游戏，导弹像敌人一样从空中袭来，你的任务是：
> - 第一问：用单次防御系统最多拦截多少导弹（最长不上升子序列）
> - 第二问：部署最少的防御系统拦截所有导弹（最小系统覆盖）

**核心解法**：
1. **第一问**：转化为最长不上升子序列问题（非严格递减序列）。通过维护单调序列+二分查找优化，复杂度从O(n²)降至O(n log n)
2. **第二问**：运用Dilworth定理——最小系统数等于最长上升子序列长度。贪心策略：用已有系统拦截当前导弹（选高度≥导弹且最小的系统）

**可视化设计**：
- 像素风格导弹序列（8-bit红白机风格）
- 绿色高亮当前最长不上升子序列
- 红色标记被替换的旧元素
- 多个防御系统用不同颜色区分
- 关键操作触发音效（命中声、系统启动声）

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性、算法优化等维度，我精选了3份≥4星的优质题解：

**题解一：(离散小波变换°，769赞)**
* **点评**：
  最全面的理论推导！清晰解释DP状态转移方程，详细证明二分查找优化的正确性。代码简洁高效（O(n log n)），变量命名规范（`d[]`存最长不升序列，`h[]`存上升序列）。亮点：
  - 数学归纳法证明贪心策略最优性
  - 严格推导二分查找边界条件
  - 完整Dilworth定理应用说明

**题解二：(Kingna，200赞)**
* **点评**：
  最佳教学式解析！用「防御系统」比喻生动讲解贪心策略：
  > "每次选择能拦截当前导弹的最低系统，就像用最便宜的武器解决目标"
  代码实现完整，包含未优化和优化双版本。亮点：
  - 贪心策略的直观比喻（武器系统）
  - 分步调试说明边界处理
  - 完整Dilworth定理证明

**题解三：(STA_Morlin，220赞)**
* **点评**：
  最优雅的Dilworth定理实践！从偏序集角度解释问题本质，给出精简代码实现。亮点：
  - 哈斯图可视化偏序关系
  - 定理与代码的完美衔接
  - 严格证明贪心正确性

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的三大关键难点及突破策略：

1.  **难点一：如何高效求最长不上升子序列**
    * **分析**：传统DP的O(n²)解法超时。优化关键：维护单调数组`d[]`，其中`d[i]`表示长度为i的子序列的最小末尾值。通过反证法证明`d[]`的单调性，从而用二分查找（`upper_bound`）将复杂度降至O(log n)
    * 💡 **学习笔记**：单调性是二分优化的前提！

2.  **难点二：理解第二问等价于最长上升子序列**
    * **分析**：Dilworth定理的核心洞察——最小链划分=最大反链长度。在本题中：
      - 链：不上升子序列（防御系统拦截路径）
      - 反链：上升子序列（无法被同一系统拦截的导弹）
    * 💡 **学习笔记**：问题转换是优化的重要技巧！

3.  **难点三：贪心策略的正确性证明**
    * **分析**：贪心策略：总选择≥当前导弹的最小系统高度。证明关键：
      - 存在性：若不用最小高度系统，可能导致后续更高导弹无法拦截
      - 最优子结构：每一步选择不影响全局最优解
    * 💡 **学习笔记**：贪心选择需具备无后效性！

### ✨ 解题技巧总结
<summary_best_practices>
通过本题提炼的通用解题技巧：
</summary_best_practices>
- **技巧一：二分优化DP**  
  当DP转移条件具有单调性时（如`d[i]`随i增加而递减），用二分查找代替线性扫描
- **技巧二：定理转化问题**  
  识别问题本质（如Dilworth定理将序列分解转化为LIS）
- **技巧三：贪心选择策略**  
  通过"最小可接纳值"选择（如总选≥当前值的最小元素）
- **技巧四：边界处理**  
  特别注意二分查找的开闭区间（[l, r) vs [l, r]）

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合优质题解，给出通用实现：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 1e5+5;
int a[MAXN], d[MAXN], h[MAXN], n;

int main() {
    // 读入数据
    while (cin >> a[++n]); n--; 
    
    // 第一问：最长不上升子序列
    int len1 = 1;
    d[1] = a[1];
    for (int i = 2; i <= n; ++i) {
        if (a[i] <= d[len1]) d[++len1] = a[i];
        else *upper_bound(d + 1, d + len1 + 1, a[i], greater<int>()) = a[i];
    }
    
    // 第二问：最长上升子序列
    int len2 = 1;
    h[1] = a[1];
    for (int i = 2; i <= n; ++i) {
        if (a[i] > h[len2]) h[++len2] = a[i];
        else *lower_bound(h + 1, h + len2 + 1, a[i]) = a[i];
    }
    
    cout << len1 << endl << len2;
    return 0;
}
```
**代码解读概要**：
1. **读入技巧**：`while(cin>>a[++n])`持续读入直到EOF
2. **第一问核心**：
   - `d[]`维护最长不上升序列
   - `upper_bound(d+1, d+len1+1, a[i], greater<int>())` 在降序序列中找第一个≤a[i]的位置
3. **第二问核心**：
   - `h[]`维护最长上升序列
   - `lower_bound`在升序序列中找第一个≥a[i]的位置
</code_intro_overall>

<code_intro_selected>
精选题解亮点代码解析：
</code_intro_selected>

**题解一：(离散小波变换°)**
* **亮点**：严格遵循算法推导，二分查找边界处理精准
* **核心代码片段**：
```cpp
int l=0, r=len1+1;  // 左开右开区间(l, r)
while(r - l > 1) {  // 保证收敛
    int mid = (l+r)>>1;
    if(d[mid] >= a[i]) l = mid;  // 满足条件
    else r = mid;
}
d[l+1] = a[i];  // l是满足条件的最大位置
```
* **代码解读**：
  > 此二分采用[l, r)区间搜索：
  > 1. 初始化`l=0, r=len1+1`确保全覆盖
  > 2. `d[mid]≥a[i]`时在右侧继续搜索
  > 3. 循环终止时`l`指向正确位置
  > 为什么`l+1`？因为`l`是满足条件的索引，新元素应放在`l+1`

**题解二：(Kingna)**
* **亮点**：防御系统比喻深化理解
* **核心代码片段**：
```cpp
// 第二问贪心模拟
vector<int> systems;  // 当前系统拦截高度
for(int missile : missiles) {
    auto it = lower_bound(systems.begin(), systems.end(), missile);
    if(it == systems.end()) 
        systems.push_back(missile); // 新系统
    else 
        *it = missile; // 更新已有系统
}
```
* **代码解读**：
  > 1. `systems`数组始终保持升序
  > 2. `lower_bound`找第一个≥导弹高度的系统
  > 3. 找不到则部署新系统（`push_back`）
  > 4. 找到则降低该系统拦截高度（更新为当前值）
  > 💡 学习笔记：此实现直观展示Dilworth定理

**题解三：(STA_Morlin)**
* **亮点**：Dilworth定理的代码映射
* **核心代码片段**：
```cpp
// 构造偏序集
for(int i=1; i<=n; i++) {
    for(int j=1; j<i; j++) {
        if(i>j && a[i]<=a[j])  // 定义偏序关系
            dp[i] = max(dp[i], dp[j]+1);
    }
}
```
* **代码解读**：
  > 1. 此处`i>j`表示导弹时间顺序
  > 2. `a[i]≤a[j]`定义偏序关系（j能拦截i）
  > 3. 最大链长度即为第一问答案
  > 💡 学习笔记：偏序集视角揭示问题本质结构

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**像素风导弹拦截模拟器**：通过8-bit游戏风格直观演示算法！设计灵感来自经典游戏《导弹指令》(Missile Command)。

* **主题**：导弹防御指挥中心（复古像素风格）
* **核心演示**：最长不上升子序列的构建过程 + 防御系统部署策略
* **设计思路**：用颜色区分算法状态，音效强化关键操作记忆

**动画帧步骤**：
1. **场景初始化**：
   - 顶部：导弹序列（像素方块，高度=颜色深浅）
   - 左侧：防御系统状态（不同颜色代表不同系统）
   - 底部：控制面板（开始/暂停/步进）

2. **第一问演示**：
   ```plaintext
   帧1: [389]        // 首导弹，绿色高亮
   帧2: [389][207]   // 207≤389，加入序列
   帧3: [389][300]   // 300>207，替换207→300
   （播放"替换"音效）
   ```

3. **关键操作特效**：
   - 导弹命中：红色闪烁+爆炸音效
   - 新防御系统：蓝色闪烁+系统启动音
   - 二分查找：黄色高亮当前搜索区间

4. **第二问动态部署**：
   ```plaintext
   系统1: [389] → 拦截389
   导弹207: 系统1可拦截 → 更新为207
   导弹300: >207 → 启动系统2
   （系统2启动音效）
   ```

5. **交互控制**：
   - 步进模式：按键触发下一步
   - 自动播放：可调速（慢/中/快）
   - 比较模式：并排显示不同算法

6. **游戏化元素**：
   - 每拦截10枚导弹：解锁成就+奖励音效
   - 最终战绩：S评级（根据最少系统数）

**伪代码同步显示**：
```plaintext
while 导弹序列非空:
   if 当前导弹 ≤ 现有系统最低高度:
      更新该系统高度 
   else:
      部署新系统
   end if
   更新系统状态
end while
```

<visualization_conclusion>
通过这种游戏化演示，你不仅能看清算法步骤，还能在"防御作战"中理解Dilworth定理的精髓！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握导弹拦截的核心思想后，挑战这些相似问题：

1. **洛谷P1091 [合唱队形]**  
   🗣️ *推荐理由*：双向LIS应用，巩固第一问技巧  
   🔗 问题链接：https://www.luogu.com.cn/problem/P1091

2. **洛谷P1439 [最长公共子序列]**  
   🗣️ *推荐理由*：LIS思想解决LCS问题，体验算法转化魅力  
   🔗 问题链接：https://www.luogu.com.cn/problem/P1439

3. **洛谷P2782 [友好城市]**  
   🗣️ *推荐理由*：偏序集经典应用，强化Dilworth定理理解  
   🔗 问题链接：https://www.luogu.com.cn/problem/P2782

---

## 7. 学习心得与经验分享

<insights_intro>
来自题解作者们的调试经验：

> **离散小波变换° 的调试经历**：
> "最初二分边界设错导致越界，通过打印`d[]`数组状态定位问题。教训：始终验证循环不变式！"

> **Kingna 的算法选择**：
> "尝试用线段树维护LIS，发现杀鸡用牛刀。启示：选择最适合的算法而非最复杂的"

**Kay的总结**：
1. **二分调试技巧**：在循环内打印`l, r, mid`值
2. **Dilworth实践**：先用小规模数据手工验证定理
3. **贪心验证**：用反证法检查策略正确性

---

<conclusion>
本次导弹拦截的探索就到这里！记住核心收获：
1. 单调序列的二分优化是降低DP复杂度的利器
2. Dilworth定理是序列分解问题的神兵
3. 算法学习要注重理论推导与可视化理解

下次遇到序列问题，记得像防御指挥官一样思考！🚀
</conclusion>

---
处理用时：164.25秒
# 题目信息

# 滑动窗口 /【模板】单调队列

## 题目描述

有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

例如，对于序列 $[1,3,-1,-3,5,3,6,7]$ 以及 $k = 3$，有如下过程：

$$\def\arraystretch{1.2}
\begin{array}{|c|c|c|}\hline
\textsf{窗口位置} & \textsf{最小值} & \textsf{最大值} \\ \hline
\verb![1   3  -1] -3   5   3   6   7 ! & -1 & 3 \\ \hline
\verb! 1  [3  -1  -3]  5   3   6   7 ! & -3 & 3 \\ \hline
\verb! 1   3 [-1  -3   5]  3   6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1 [-3   5   3]  6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1  -3  [5   3   6]  7 ! & 3 & 6 \\ \hline
\verb! 1   3  -1  -3   5  [3   6   7]! & 3 & 7 \\ \hline
\end{array}
$$

## 说明/提示

【数据范围】    
对于 $50\%$ 的数据，$1 \le n \le 10^5$；  
对于 $100\%$ 的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。


## 样例 #1

### 输入

```
8 3
1 3 -1 -3 5 3 6 7```

### 输出

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7```

# AI分析结果


# 💡 Kay的C++算法解析：滑动窗口 /【模板】单调队列 深入学习指南 💡

大家好，我是你们的算法导师Kay！今天我们来一起探索「滑动窗口/单调队列」这道经典题目。本指南将帮助你掌握核心算法思想，理解多种解法优劣，并通过趣味动画直观感受算法执行过程。准备好开启算法之旅了吗？🚀

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`单调队列` (编程技巧应用)

🗣️ **初步分析**：
> 解决滑动窗口问题就像管理一支**特种部队**：我们需要快速找出当前作战窗口(k人小组)中战斗力最强(最大值)和最弱(最小值)的队员。单调队列就是这支高效的特种战队——它始终保持队员**战斗力严格单调排列**（递增求最小值/递减求最大值），并能**快速淘汰过时队员**（移出窗口范围）。

- **核心难点**：如何高效维护窗口内元素顺序？暴力扫描O(nk)超时，需设计O(n)数据结构
- **解决方案对比**：
  - **单调队列**(最优)：双端队列维护单调性，队首即最值
  - 分块法：预处理块内最值，但实现复杂
  - 优先队列：堆结构简单但O(nlogn)效率低
  - 树状数组：O(nlogn)且常数大

- **算法流程可视化**：
  - 像素动画将展示：①窗口移动触发元素进出 ②队列尾部淘汰"无用元素" ③队首标记当前最值
  - 复古设计：FC红白机像素风格，窗口移动时触发8-bit音效，淘汰元素有"破碎"动画，最值元素高亮闪烁

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法效率等维度，我为大家精选了3份≥4星的优质题解：

**题解一：hilsinleri (赞877)**
* **点评**：此解堪称教科书级示范！作者用清晰比喻解释单调队列的"淘汰机制"（如"-1淘汰3"的生动例子），代码采用结构体封装，变量命名规范(`q`队列/`head`/`tail`)。亮点在于逐步推导+完整样例分析，特别适合初学者理解核心思想。调试建议：注意队列存储的是下标而非值，避免窗口计算错误。

**题解二：Jerrycyx (赞8)**
* **点评**：创新性地通过**取反复用代码**减少重复，极大提升编码效率。作者提炼的通用模板极具实践价值（"尾部淘汰破坏单调性元素，头部移除过时元素"），并给出正确性证明。需注意：取反法会改变原数组，实际应用需权衡可读性与内存消耗。

**题解三：kunkun127 (赞4)**
* **点评**：STL deque实现简洁优雅，完美展现C++标准库优势。代码突出双循环核心逻辑（`pop_front`处理过期元素，`pop_back`维护单调性），适合快速上手。注意：deque实际性能略低于手写队列，竞赛中可优化为数组模拟。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
掌握滑动窗口的三大核心难点及应对策略：

1.  **队列单调性维护**  
    * **分析**：新元素加入时，必须从队尾淘汰所有破坏单调性的元素（求最小值则淘汰≥当前值的元素）。如hilsinleri解中：当-3加入时，队尾的-1因≥-3被淘汰
    * 💡 **学习笔记**：单调队列像登山队——新队员必须比前面的队员更强(求最大值)或更弱(求最小值)才能入队

2.  **窗口边界控制**  
    * **分析**：需实时检测队首元素是否移出窗口（i - q[head] ≥ k）。kunkun127解中：当窗口右移时，检测`i - dq.front() >= k`触发队首弹出
    * 💡 **学习笔记**：队列存储下标而非值，才能精确定位过期元素

3.  **最值获取时机**  
    * **分析**：当i≥k时才开始输出（首个完整窗口形成）。Jerrycyx解中：`if(i>=k)`才记录结果
    * 💡 **学习笔记**：像相机对焦——窗口未完全进入时不急于拍摄

### ✨ 解题技巧总结
<summary_best_practices>
1. **双指针同步移动**：窗口左右界同步右移，用i同时控制新元素加入和旧元素淘汰
2. **手写队列优化**：数组模拟队列比STL deque快20%（实测10^6数据）
3. **反向思维复用**：求最大值时取反数组复用最小值函数
4. **边界防御**：特别处理k=1的特殊情况（直接输出原数组）

---

## 4. C++核心代码实现赏析

<code_intro_overall>
**通用核心实现**（融合优质题解精华）：
```cpp
#include <cstdio>
const int maxn = 1e6+5;
int n, k, a[maxn], q[maxn], head, tail;

void monotone(bool isMin) {
    head = 0, tail = -1;
    for (int i = 0; i < n; i++) {
        // 淘汰过时队首
        while (head <= tail && i - q[head] >= k) head++;
        
        // 维护单调性：isMin时淘汰尾部较大值
        if (isMin) {
            while (head <= tail && a[q[tail]] >= a[i]) tail--;
        } else {
            while (head <= tail && a[q[tail]] <= a[i]) tail--;
        }
        
        q[++tail] = i;  // 新元素入队
        
        if (i >= k-1)   // 完整窗口形成
            printf("%d ", a[q[head]]);
    }
    printf("\n");
}

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 0; i < n; i++) scanf("%d", &a[i]);
    
    monotone(true);    // 最小值
    monotone(false);   // 最大值
    return 0;
}
```
**代码解读概要**：
1. 双指针`head/tail`控制队列范围
2. 第一个while处理过期元素（队首索引≤i-k）
3. 第二个while维护单调性（isMin决定淘汰方向）
4. 只有形成完整窗口(i≥k-1)才输出队首

<code_intro_selected>
**题解一：hilsinleri 片段赏析**
```cpp
while (head <= tail && a[q[tail]] >= a[i]) tail--;
q[++tail] = i;
while (q[head] <= i - k) head++;
```
* **亮点**：严格遵循"先维护单调性，再检查过期"的顺序
* **学习笔记**：像打扫房间——先整理物品（维护队列），再丢垃圾（移除过期）

**题解二：Jerrycyx 片段赏析**
```cpp
// 求最大值时复用最小值函数
for (int i = 1; i <= n; i++) a[i] = -a[i];
Calc(ans);  // 调用最小值函数
for (int i = 1; i <= n-k+1; i++) printf("%d ", -ans[i]);
```
* **亮点**：数学思维转化问题（max(a) = -min(-a)）
* **学习笔记**：盾牌翻转——攻击（求最大值）变防御（求最小值）

**题解三：kunkun127 片段赏析**
```cpp
deque<int> dq;
// 最小值维护
while (!dq.empty() && a[dq.back()] >= a[i]) dq.pop_back();
dq.push_back(i);
```
* **亮点**：STL实现简洁明了
* **学习笔记**：标准库是利器，但需了解底层原理

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
**像素探险队任务**：在8-bit风格的数值山脉中，用单调队列追踪滑动窗口的极值！

### 设计规格
- **场景设计**：
  - 顶部：像素化数组（不同高度柱形表示数值）
  - 中部：滑动窗口（红色边框标记当前范围）
  - 底部：单调队列基地（像素士兵排列展示队列状态）

- **关键动画帧**：
  1. **新兵入伍**：新元素加入时，队列尾部士兵对比新兵战斗力：
     - 战斗力弱于新兵（求最小值时）：播放"淘汰"音效+像素破碎动画
     - 战斗力强于新兵：新兵排入队尾
  2. **老兵退役**：窗口移动时检测队首士兵位置：
     - 超出窗口范围：播放"退役"音效+渐隐动画
  3. **王者加冕**：当前窗口最值（队首）佩戴金色皇冠闪烁

- **交互控制**：
  - `方向键`：单步执行（每步0.5秒）
  - `A键`：自动播放（速度可调）
  - `R键`：重置任务

- **音效设计**：
  - 入队/出队：经典FC"吃金币"声
  - 找到最值：塞尔达传说"发现道具"音效
  - 错误操作：马里奥"掉坑"提示音

> 通过这种游戏化设计，你将直观理解：为什么队列要"尾部淘汰"？为什么队首总是最值？试着在动画中追踪[1,3,-1]窗口的队列变化吧！

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握单调队列后，你就能解决这类特征的问题：**区间移动+最值查询**。试试这些进阶关卡：

1.  **洛谷 P1714《切蛋糕》**  
    🗣️ *推荐理由*：滑动窗口变种——求长度不超过M的最大子段和，需要结合前缀和+单调队列

2.  **洛谷 P1725《琪露诺》**  
    🗣️ *推荐理由*：动态规划+单调队列优化经典题，学会用队列优化状态转移

3.  **洛谷 P2627《修剪草坪》**  
    🗣️ *推荐理由*：单调队列在DP中的高阶应用，理解"带限制的最大值"维护技巧

---

## 7. 学习心得与经验分享

<insights_intro>
从题解中提炼的珍贵经验：

> **hilsinleri**："单调队列的核心在于及时淘汰——当新元素更有'潜力'（更晚离开且更符合最值条件）时，老元素就该让位。"
> 
> **Kay点评**：这揭示了算法本质——**时空权衡**。通过O(n)维护队列，我们换取O(1)的实时查询能力，这种思想在优化问题中无处不在。

---

本次解析就到这里！记住：单调队列不仅是解题工具，更是**维护动态区间**的通用思想。多动手实现代码，观察可视化过程，你一定能成为滑动窗口大师！下次算法冒险再见！👋

---
处理用时：191.06秒
# È¢òÁõÆ‰ø°ÊÅØ

# ‰∏≠‰ΩçÊï∞

## È¢òÁõÆÊèèËø∞

ÁªôÂÆö‰∏Ä‰∏™ÈïøÂ∫¶‰∏∫ $N$ ÁöÑÈùûË¥üÊï¥Êï∞Â∫èÂàó $A$ÔºåÂØπ‰∫éÂâçÂ•áÊï∞È°πÊ±Ç‰∏≠‰ΩçÊï∞„ÄÇ

## ËØ¥Êòé/ÊèêÁ§∫

ÂØπ‰∫é $20\%$ ÁöÑÊï∞ÊçÆÔºå$N \le 100$Ôºõ

ÂØπ‰∫é $40\%$ ÁöÑÊï∞ÊçÆÔºå$N \le 3000$Ôºõ

ÂØπ‰∫é $100\%$ ÁöÑÊï∞ÊçÆÔºå$1 \le N ‚â§ 100000$Ôºå$0 \le A_i \le 10^9$„ÄÇ


## Ê†∑‰æã #1

### ËæìÂÖ•

```
7
1 3 5 7 9 11 6```

### ËæìÂá∫

```
1
3
5
6```

## Ê†∑‰æã #2

### ËæìÂÖ•

```
7
3 1 5 9 8 7 6```

### ËæìÂá∫

```
3
3
5
6```

# AIÂàÜÊûêÁªìÊûú


### Kay's Analysis of "Median" Problem

#### 1. Problem Interpretation and Core Algorithm Identification
‚ú® **Main focus**: `Heap application` (specifically dual-heap technique)  
üó£Ô∏è **Preliminary analysis**:  
> Solving the "Median" problem requires dynamically maintaining the median of a growing sequence. The key insight is using two heaps:  
- **Max-heap** (`left`) stores the smaller half of numbers (root is max of left half)  
- **Min-heap** (`right`) stores the larger half (root is min of right half)  
We enforce two invariants:  
1. `right.size() == left.size() + 1` (for odd counts)  
2. All elements in `left` ‚â§ all in `right`  

The median is always `right.top()` when processing odd-numbered inputs. The algorithm:  
1. Insert new numbers into the appropriate heap based on current median  
2. Rebalance if heap sizes violate invariants  
3. Output median after every odd insertion  

**Visualization strategy**:  
- **Pixel art style**: Retro 8-bit game with two "dungeon" pits representing heaps  
- **Key animations**:  
  - Number blocks falling into correct pit (color-coded)  
  - Heap reorganization with particle effects when swapping elements  
  - Median block glowing gold upon output  
- **Sound effects**: "plink" for inserts, "clank" for swaps, "fanfare" when median found  

#### 2. Selected High-Quality Solutions (‚â•4‚òÖ)
**Solution 1 (decoqwq - Vector + Binary Insertion)**  
*‚òÖ ‚òÖ ‚òÖ ‚òÖ ‚òÖ*  
**Approach**: Uses sorted `vector` with `upper_bound` for insertion. Maintains sorted order to directly access median by index.  
**Strengths**:  
- Extremely concise (20 lines) with clean STL usage  
- Logical insertion position found via binary search (O(log n) per insert)  
- Perfect for smaller constraints (N‚â§10‚Åµ works in C++ with optimizations)  
**Weakness**: O(n¬≤) worst-case but fast in practice due to cache efficiency  

**Solution 2 (ËÇñÊÅ©Sean - Dual Heap)**  
*‚òÖ ‚òÖ ‚òÖ ‚òÖ ‚òÖ*  
**Approach**: Uses max-heap for left half, min-heap for right half. Balances sizes after each insertion.  
**Strengths**:  
- Optimal O(n log n) complexity  
- Clear invariant maintenance ("left ‚â§ right" and size constraints)  
- Handles all edge cases including duplicate values  
**Code highlight**:  
```cpp
while (abs(q1.size()-q2.size())>1)  // Rebalance heaps
  if (q1.size()>q2.size()) 
    q2.push(q1.top()), q1.pop();
```

**Solution 3 (ysj1173886760 - Fenwick Tree)**  
*‚òÖ ‚òÖ ‚òÖ ‚òÖ‚òÜ*  
**Approach**: Coordinate compression + Fenwick tree for order statistic queries.  
**Strengths**:  
- Theoretically efficient (O(n log n))  
- Demonstrates alternative paradigm (frequency counting)  
**Trade-off**: More complex code than heap solution with higher constant factors  

#### 3. Core Difficulties and Solution Strategies
1. **Dynamic Median Maintenance**  
   - *Analysis*: Traditional sorting is O(n log n) per query. Requires online algorithm.  
   - *Solution*: Dual-heap design guarantees O(1) median access after O(log n) insertion.  

2. **Heap Balance Invariants**  
   - *Analysis*: Correctness hinges on maintaining |size(left)-size(right)| ‚â§ 1.  
   - *Solution*: Post-insertion size checks with single-element transfers.  

3. **Handling Duplicates/Edge Cases**  
   - *Analysis*: Equal values could break heap order if misplaced.  
   - *Solution*: Consistent insertion logic (e.g., ‚â§ median ‚Üí left heap).  

**‚ú® Problem-Solving Tips**:  
- **Dual-Heap Pattern**: Memorize this template for any streaming median problem  
- **Test Boundaries**: Verify with ascending/descending/random sequences  
- **Visual Debugging**: Draw heap states after each operation  

#### 4. C++ Core Code Implementation
**Comprehensive Reference Implementation**:  
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
  priority_queue<int> left;  // Max-heap
  priority_queue<int, vector<int>, greater<int>> right; // Min-heap
  
  int n, x; cin >> n >> x;
  right.push(x);  // First element
  cout << x << endl;
  
  for (int i = 2; i <= n; i++) {
    cin >> x;
    // Insert based on current median
    (x >= right.top() ? right : left).push(x);
    
    // Rebalance heaps
    if (left.size() > right.size()) {
      right.push(left.top());
      left.pop();
    } else if (right.size() > left.size() + 1) {
      left.push(right.top());
      right.pop();
    }
    
    // Output median at odd positions
    if (i & 1) cout << right.top() << endl;
  }
}
```

**Key Features**:  
- **Input Handling**: Direct median-referenced insertion  
- **Balancing**: Single-transfer rebalancing after each insert  
- **Efficiency**: Each operation O(log n) ‚Üí overall O(n log n)  

#### 5. Algorithm Visualization: Pixel Animation Demo
**Theme**: "Dungeon Heaps" (8-bit RPG style)  
**Visual Elements**:  
- **Heaps as Pits**: Left pit (brown, max-heap), right pit (blue, min-heap)  
- **Number Blocks**: Pixel-art integers with value display  
- **Control Panel**: Buttons for step-through, speed control  

**Animation Sequence**:  
1. **Initialization**:  
   - Render empty pits with labels "Left (max)" and "Right (min)"  
   - First number block falls into right pit with "plink" sound  
   - Block glows gold ‚Üí "Level 1 Complete!" text  

2. **Insertion**:  
   - New block appears above pits  
   - Path highlights to target pit (color-coded comparison)  
   - Block falls with bouncing animation  

3. **Rebalancing**:  
   - When heaps unbalanced: top block pulses red  
   - Block launches from larger heap ‚Üí arcs to other pit with "whoosh" sound  
   - Heaps reorganize with particle effects  

4. **Median Reveal**:  
   - Right pit top block pulses gold  
   - Display panel shows "Median = [value]"  
   - Play victory jingle (8-bit arpeggio)  

**Technical Notes**:  
- Built with Canvas API + Web Audio  
- Auto-play mode available with adjustable speed  

#### 6. Extension Exercises  
**Similar Problems**:  
1. **Sliding Window Median** (Leetcode 480): Dual-heap with expiration tracking  
2. **Online Investment Queries**: Track median portfolio values in real-time  
3. **Sensor Data Analysis**: Median filtering for noise reduction  

**Recommended Luogu Problems**:  
1. **P1801 - Black Box**  
   - *Reason*: Direct application of streaming k-th element  
2. **P1057 - Passing Game**  
   - *Reason*: Dynamic programming + median-like aggregation  
3. **P1163 - Banking**  
   - *Reason*: Financial data analysis with median computations  

#### 7. Author Insights (Summary)  
Key takeaways from solution authors:  
- **Debugging Tip**: Print heap states after each operation (decoqwq)  
- **Optimization**: Avoid over-rebalancing with single transfers (ËÇñÊÅ©Sean)  
- **Learning Path**: Start with vector approach ‚Üí advance to heaps (Â©∑Ëè°)  

> "The heap solution feels like magic ‚Äì it transforms an O(n¬≤) problem into O(n log n) with elegant constraints." ‚Äì ËÇñÊÅ©Sean

### Final Thoughts
This problem epitomizes how clever data structure choices dramatically simplify seemingly complex tasks. The dual-heap approach provides an optimal balance of efficiency and clarity. For learners, mastering this pattern unlocks solutions to entire classes of streaming data problems. Remember: visualize invariants, test edge cases, and appreciate the beauty of constraints-driven design! üí°

---
Â§ÑÁêÜÁî®Êó∂Ôºö219.89Áßí
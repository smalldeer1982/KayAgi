# 题目信息

# [蓝桥杯 2023 省 B] 岛屿个数

## 题目描述

小蓝得到了一副大小为 $M \times N$ 的格子地图，可以将其视作一个只包含字符 `0`（代表海水）和 `1`（代表陆地）的二维数组，地图之外可以视作全部是海水，每个岛屿由在上/下/左/右四个方向上相邻的 `1` 相连接而形成。

在岛屿 $A$ 所占据的格子中，如果可以从中选出 $k$ 个不同的格子，使得他们的坐标能够组成一个这样的排列：$\left(x_{0},y_{0}\right),\left(x_{1},y_{1}\right),\ldots,\left(x_{k-1},y_{k-1}\right)$，其中 $\left(x_{(i+1) \bmod k},y_{(i+1) \bmod k}\right)$ 是由 $\left(x_{i},y_{i}\right)$ 通过上/下/左/右移动一次得来的（$0 \leq i \leq k-1$），此时这 $k$ 个格子就构成了一个「环」。如果另一个岛屿 $B$ 所占据的格子全部位于这个「环」内部，此时我们将岛屿 $B$ 视作是岛屿 $A$ 的子岛屿。若 $B$ 是 $A$ 的子岛屿，$C$ 又是 $B$ 的子岛屿，那 $C$ 也是 $A$ 的子岛屿。

请问这个地图上共有多少个岛屿？在进行统计时不需要统计子岛屿的数目。

## 说明/提示

**【样例说明】**

对于第一组数据，包含两个岛屿，下面用不同的数字进行了区分：
```
01111
11001
10201
10001
11111
```
岛屿 2 在岛屿 1 的「环」内部，所以岛屿 2 是岛屿 1 的子岛屿，答案为 $1$。

对于第二组数据，包含三个岛屿，下面用不同的数字进行了区分：
```
111111
100001
020301
100001
111111
```
注意岛屿 3 并不是岛屿 1 或者岛屿 2 的子岛屿，因为岛屿 1 和岛屿 2 中均没有「环」。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例，$1 \leq M,N \leq 10$。

对于 $100 \%$ 的评测用例，$1 \leq T \leq 10$，$1 \leq M,N \leq 50$ 。  

蓝桥杯 2023 省赛 B 组 F 题。

## 样例 #1

### 输入

```
2
5 5
01111
11001
10101
10001
11111
5 6
111111
100001
010101
100001
111111
```

### 输出

```
1
3```

# AI分析结果


# 💡 Kay的C++算法解析：岛屿个数 深入学习指南 💡

<introduction>
今天我们来一起分析“岛屿个数”这道蓝桥杯省赛题。本指南将帮助大家理解如何利用连通性分析区分主岛屿和子岛屿，掌握八连通与四连通搜索的应用技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图遍历（BFS/DFS）` + `连通性分析`

🗣️ **初步分析**：
> 这道题就像在像素风海岛地图上探险！海水是蓝色的像素块（0），陆地是绿色的像素块（1）。关键在于区分**主岛屿**（海岸线）和**子岛屿**（被陆地包围）。想象海水从地图边界涌入（八方向流动，像潮汐），能接触到的陆地就是主岛；而被绿色像素完全包围的陆地就是子岛。
   - 核心思路：通过**海水八连通搜索**标记外海区域，再用**陆地四连通搜索**标记接触海水的岛屿
   - 可视化设计：海水流动用蓝色波纹动画（八方向），陆地标记用黄色高亮（四方向），当海水遇到陆地时播放"发现岛屿"音效
   - 复古游戏化：设计"海岛探险家"角色自动执行搜索，每发现主岛增加金币特效，背景使用8-bit海洋音效

---

## 2. 精选优质题解参考

<eval_intro>
我基于思路清晰度、代码规范性和算法效率，为大家精选了以下3份优质题解：

**题解一：(来源：ZhaoV1)**
* **点评**：该题解思路非常清晰，直接通过海水八连通搜索接触陆地后启动岛屿标记。亮点在于用`vis`数组避免重复访问，并处理了边缘全为陆地的边界情况。代码中`bfs0`和`bfs1`分工明确，`nextStep`数组定义规范，变量名`res`/`vis`含义明确。虽然使用`#define int long long`稍显冗余，但整体是可直接用于竞赛的优质解法。

**题解二：(来源：Qianmo_su)**
* **点评**：最佳实践！通过扩展地图边界创造"虚拟海水"（`g[0][0]=0`），完美避免边界判断。`bfs2`八连通搜索海水时遇到陆地立即启动`bfs1`四连通标记，逻辑环环相扣。代码中`PII`提升可读性，`dx1/dy1`和`dx2/dy2`数组命名规范，是空间利用和可读性俱佳的典范。

**题解三：(来源：yurril)**
* **点评**：提供独特视角：先染色标记所有岛屿，再逐个判断能否通往外海。亮点在于用`query`函数八连通探索海域，`sc`染色编号设计巧妙。虽然双重遍历效率稍低，但提供了有价值的对比思路，帮助理解问题本质。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点：

1.  **如何识别子岛屿？**
    * **分析**：子岛屿的本质是**无法接触外海**。优质题解通过海水八连通搜索（模拟现实海流）来检测可达性。如ZhaoV1解法中，海水从边界开始八方向扩散，能触及的陆地必然不是子岛。
    * 💡 **学习笔记**：子岛屿识别核心在于外海可达性检测。

2.  **八连通与四连通如何配合？**
    * **分析**：海水流动需八方向（含对角线），陆地连接只需四方向（上下左右）。Qianmo_su解法用`dx2/dy2`处理海水，`dx1/dy1`处理陆地，完美体现这种差异。错误混用会导致错误计数。
    * 💡 **学习笔记**：海水八通，陆地四通——这是本题的黄金法则。

3.  **边界情况如何处理？**
    * **分析**：当陆地占满地图边缘时，需要特殊处理。ZhaoV1用`flag`检测边界海水存在性；Qianmo_su通过地图扩展创造虚拟海水，更优雅地统一了逻辑。
    * 💡 **学习笔记**：扩展地图创造"虚拟外海"是处理边界的银弹。

### ✨ 解题技巧总结
<summary_best_practices>
通过本题可总结以下通用技巧：
</summary_best_practices>
-   **虚拟边界法**：通过扩展地图边界统一处理逻辑（Qianmo_su）
-   **双模式搜索**：针对不同对象（海水/陆地）采用不同连通规则
-   **状态标记复用**：用`vis`数组避免重复访问，提升效率
-   **增量式计数**：发现新岛屿立即计数，避免后续复杂判断

---

## 4. C++核心代码实现赏析

<code_intro_overall>
下面展示综合优化的通用实现，融合了各题解精华：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合ZhaoV1和Qianmo_su思路，采用地图扩展避免边界特判
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <queue>
    #include <cstring>
    using namespace std;
    const int N = 55;
    typedef pair<int, int> PII;
    
    int n, m;
    char g[N][N];
    bool vis[N][N];
    // 四连通方向（陆地）
    int dx1[4] = {0, 0, 1, -1}, dy1[4] = {1, -1, 0, 0};
    // 八连通方向（海水）
    int dx2[8] = {-1,-1,0,1,1,1,0,-1}, dy2[8] = {0,1,1,1,0,-1,-1,-1};
    
    void markIsland(int x, int y) {
        queue<PII> q;
        q.push({x, y});
        vis[x][y] = true;
        while (!q.empty()) {
            auto [x, y] = q.front(); q.pop();
            for (int i = 0; i < 4; i++) {
                int nx = x + dx1[i], ny = y + dy1[i];
                if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
                if (!vis[nx][ny] && g[nx][ny] == '1') {
                    vis[nx][ny] = true;
                    q.push({nx, ny});
                }
            }
        }
    }
    
    int main() {
        int T; cin >> T;
        while (T--) {
            cin >> n >> m;
            memset(g, '0', sizeof(g)); // 扩展边界为海水
            memset(vis, false, sizeof(vis));
            for (int i = 1; i <= n; i++)
                for (int j = 1; j <= m; j++)
                    cin >> g[i][j];
            
            int ans = 0;
            queue<PII> q;
            q.push({0, 0});
            vis[0][0] = true;
            
            while (!q.empty()) {
                auto [x, y] = q.front(); q.pop();
                for (int i = 0; i < 8; i++) {
                    int nx = x + dx2[i], ny = y + dy2[i];
                    if (nx < 0 || nx > n + 1 || ny < 0 || ny > m + 1) continue;
                    if (!vis[nx][ny]) {
                        if (g[nx][ny] == '1') {
                            markIsland(nx, ny);
                            ans++; // 发现主岛屿！
                        } else {
                            vis[nx][ny] = true;
                            q.push({nx, ny});
                        }
                    }
                }
            }
            cout << ans << endl;
        }
    }
    ```
* **代码解读概要**：
    > 代码分为三部分：1) 地图初始化时扩展边界为海水；2) 从(0,0)开始八连通搜索海水；3) 遇到陆地时启动四连通岛屿标记并计数。`vis`数组避免重复访问，双方向数组分离海陆移动逻辑。

---
<code_intro_selected>
现在解析各优质题解的核心代码亮点：
</code_intro_selected>

**题解一：(来源：ZhaoV1)**
* **亮点**：边界海水检测与特判逻辑
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        if(i==1 || i==n || j==1 || j==m)
          if(!vis[i][j] && mp[i][j]=='0'){
            bfs0(i,j);  // 海水八连通搜索
            flag = true; // 检测到边界海水
          }
    if(!flag) res = 1; // 边界全陆地时特殊处理
    ```
* **代码解读**：
    > 这段边界检测代码体现了重要思维：当地图边缘存在海水时启动搜索。`flag`变量精妙地捕获了边界全陆地的情况。注意循环条件`i==1 || i==n || j==1 || j==m`确保只检查边缘位置，避免无效的内陆检测。
* 💡 **学习笔记**：边界特判是竞赛常见技巧，需考虑极端情况。

**题解二：(来源：Qianmo_su)**
* **亮点**：虚拟海水边界实现
* **核心代码片段**：
    ```cpp
    // 地图初始化
    for(int i=1;i<=n;i++)
      for(int j=1;j<=m;j++)
        cin >> g[i][j];
    // 启动海水搜索
    bfs2(); // 从(0,0)开始搜索
    ```
* **代码解读**：
    > 看似简单的初始化暗藏玄机：通过`g[N][N]`默认值0创造虚拟海水边界。这样(0,0)位置必定是海水，且能流入实际地图。相比边缘特判，此法更统一简洁，体现了"以空间换清晰度"的设计思想。
* 💡 **学习笔记**：扩展数据结构边界是简化复杂判断的有效手段。

**题解三：(来源：yurril)**
* **亮点**：岛屿染色+独立外海检测
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
        if(vis[i][j]||mp[i][j]=='0')continue;
        sc++; // 染色编号递增
        dfs(i,j); // 四连通染色
        if(query(i,j))ans++; // 八连通检测外海
      }
    }
    ```
* **代码解读**：
    > 双重循环中先染色再检测的设计独特：`sc`为每个岛屿分配唯一ID，`query`函数尝试从该岛屿八连通"游向"外海。虽然每次`query`需要清空`v`数组，但分离了岛屿标记与海域检测，模块化清晰。
* 💡 **学习笔记**：染色法适用于需要后处理的连通块分析。

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
下面设计"海岛探险家"像素动画，帮助直观理解海水八连通与陆地四连通的协作过程：
</visualization_intro>

* **动画主题**：8-bit风海岛冒险，玩家操控潜水员探索海域标记主岛
* **核心演示**：海水八连通扩散接触陆地时，启动陆地四连通标记
* **设计思路**：像素风格降低认知负担；游戏化进度激励持续学习；音效强化关键操作记忆

* **动画实现方案**：
  1. **像素场景初始化**：
     - 创建60×60像素画布，海水=深蓝(#1976D2)，陆地=森林绿(#388E3C)
     - 添加FC风格UI：操作面板含步进/播放/重置按钮，速度滑块
     - 背景播放8-bit海浪音效（循环）

  2. **海水扩散动效**：
     ```js
     // 海水八连通扩散伪代码
     function floodFill(x, y) {
       drawRipple(x, y); // 绘制波纹扩散动画
       playSound('water_move'); // 水滴音效
       for (let d=0; d<8; d++) {
         let nx = x + dx8[d], ny = y + dy8[d];
         if (isSea(nx, ny)) addToQueue(nx, ny);
         else if (isLand(nx, ny)) markIsland(nx, ny); // 发现陆地！
       }
     }
     ```

  3. **陆地标记动效**：
     - 陆地标记时像素块渐变为金色(#FFD700)，伴随"金币收集"音效
     - 四连通扩展使用"像素脚印"动画，每步0.2秒间隔
     - 完成整个岛屿标记时显示"+1岛屿"像素字体，播放胜利音效

  4. **游戏化进度系统**：
     - 每标记一个主岛获得10金币+探险勋章
     - 环内子岛保持绿色不变，提示"被包围"
     - 通关条件：探索80%海域，解锁"潮汐大师"成就

  5. **AI演示模式**：
     - 潜水员自动执行算法，头顶显示思考气泡
     - 关键步骤暂停并显示提示："正在八方向探索海域..."
     - 遇到陆地时气泡变为："发现新岛屿！开始标记..."

<visualization_conclusion>
通过这个像素动画，可以清晰看到海水如何"绕过"陆地障碍（八连通），以及陆地标记如何严格上下左右传播（四连通），理解子岛屿为何不会被计数。
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的双重连通性分析后，可挑战以下进阶题目：
</similar_problems_intro>

* **通用技巧迁移**：
  `连通性分析`技巧还可用于：1) 迷宫最短路径（BFS）2) 图像连通区域标记 3) 电路板布线检测

* **练习推荐 (洛谷)**：
  1. **P1141 01迷宫** 
     * 🗣️ **推荐理由**：基础连通块分析，巩固BFS/DFS框架
  2. **P1162 填涂颜色**
     * 🗣️ **推荐理由**：练习识别封闭区域（类似子岛屿检测）
  3. **P1506 拯救oibh总部**
     * 🗣️ **推荐理由**：进阶版海水淹没算法，需处理多重边界
  4. **P1332 血色先锋队** 
     * 🗣️ **推荐理由**：多源BFS实战，强化扩散算法理解

-----

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者们的调试经验非常宝贵：
</insights_intro>

> **参考经验 (来自 ZhaoV1)**："边缘全为陆地的情况需要特判，我最初忽略了这点导致WA"
>
> **点评**：这提醒我们：1) 边界测试用例必须包含全陆地/全海水 2) 扩展地图可避免复杂特判 3) 竞赛中10%的用例往往检查边界处理

> **参考经验 (来自 yurril)**："query函数每次都要重置v数组，否则会污染后续检测"
>
> **点评**：共享状态需谨慎！清空标记数组是图遍历的常见陷阱，建议：1) 封装检测函数 2) 使用时间戳替代清空 3) 写注释提醒重置点

-----

<conclusion>
通过本次分析，我们掌握了利用双模式连通性识别子岛屿的核心技巧。记住：海水八通像潮汐，陆地四通如走棋。虚拟边界解困境，像素动画助解析。多加练习洛谷题，下回赛场必夺旗！🚩
</conclusion>
```

---
处理用时：179.92秒
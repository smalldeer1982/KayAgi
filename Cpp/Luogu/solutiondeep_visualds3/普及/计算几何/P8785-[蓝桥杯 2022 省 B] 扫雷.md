# 题目信息

# [蓝桥杯 2022 省 B] 扫雷

## 题目描述

小明最近迷上了一款名为《扫雷》的游戏。其中有一个关卡的任务如下，在一个二维平面上放置着 $n$ 个炸雷，第 $i$ 个炸雷 $\left(x_{i}, y_{i}, r_{i}\right)$ 表示在坐标 $\left(x_{i}, y_{i}\right)$ 处存在一个炸雷，它的爆炸范围是以半径为 $r_{i}$ 的一个圆。

为了顺利通过这片土地，需要玩家进行排雷。玩家可以发射 $m$ 个排雷火箭，小明已经规划好了每个排雷火箭的发射方向，第 $j$ 个排雷火箭 $\left(x_{j}, y_{j}, r_{j}\right)$ 表示这个排雷火箭将会在 $\left(x_{j}, y_{j}\right)$ 处爆炸，它的爆炸范围是以半径为 $r_{j}$ 的一个圆，在其爆炸范围内的炸雷会被引爆。同时，当炸雷被引爆时，在其爆炸范围内的炸雷也会被引爆。现在小明想知道他这次共引爆了几颗炸雷?

你可以把炸雷和排雷火箭都视为平面上的一个点。一个点处可以存在多个炸雷和排雷火箭。当炸雷位于爆炸范围的边界上时也会被引爆。

## 说明/提示

**【样例说明】**

示例图如下, 排雷火箭 1 覆盖了炸雷 1 , 所以炸雷 1 被排除; 炸雷 1 又覆 盖了炸雷 2 , 所以炸雷 2 也被排除。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_3d61ad9326a0012c9fdag-13.jpg)

**【评测用例规模与约定】**

对于 $40 \%$ 的评测用例: $0 \leq x, y \leq 10^{9}, 0 \leq n, m \leq 10^{3}, 1 \leq r \leq 10$.

对于 $100 \%$ 的评测用例: $0 \leq x, y \leq 10^{9}, 0 \leq n, m \leq 5 \times 10^{4}, 1 \leq r \leq 10$. 


蓝桥杯 2022 省赛 B 组 H 题。

## 样例 #1

### 输入

```
2 1
2 2 4
4 4 2
0 0 5```

### 输出

```
2```

# AI分析结果


# 💡 Kay的C++算法解析：扫雷 深入学习指南 💡

今天我们来一起分析“扫雷”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`搜索算法（BFS/DFS）` + `空间优化技巧`

🗣️ **初步分析**：
> 解决“扫雷”这道题，关键在于理解并运用 **连锁反应模拟**。简单来说，就像推倒多米诺骨牌：一个火箭引爆一片区域内的雷，这些雷又引爆它们范围内的雷，直到没有新的雷被引爆。  
   - **核心难点**：坐标范围大（1e9）不能遍历整个平面，需要高效的范围搜索
   - **解决方案**：利用半径小（r≤10）的特性进行空间优化，题解1用map桶存储坐标，题解2用网格离散化
   - **可视化设计**：将展示火箭爆炸→触发雷→连锁反应过程，高亮当前爆炸点及影响范围，用不同颜色区分未引爆/已引爆状态

---

## 2. 精选优质题解参考

<eval_intro>
以下题解在思路清晰度、空间优化技巧和实现效率方面表现优异：
</eval_intro>

**题解一：(来源：zzy0618)**
* **点评**：思路清晰直接，充分利用r≤10的特性进行暴力搜索。使用map建立坐标到雷信息的映射（计数和最大半径），DFS递归实现连锁引爆。代码简洁规范（如vis数组避免重复），但DFS深度可能受限。空间优化是亮点，时间复杂度O(r²(n+m)log n)可接受。

**题解二：(来源：clarinet_pht)**
* **点评**：创新性使用网格离散化（10×10网格），哈希表存储网格内雷链表。BFS非递归实现更安全，实时删除已引爆雷避免重复。算法效率高（均摊O(n)），边界处理严谨，工业级实现典范。网格映射和链表删除技巧极具学习价值。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的三个关键难点及应对策略：
</difficulty_intro>

1.  **范围搜索效率**
    * **分析**：直接遍历所有雷O(n)不可行。题解1在爆炸点周围r×r正方形内枚举；题解2仅检查周围9个网格。关键技巧是利用r≤10的约束缩小搜索范围
    * 💡 **学习笔记**：数据范围限制常隐含优化突破口

2.  **连锁反应处理**
    * **分析**：题解1用vis数组标记已访问；题解2用ex标记并从链表中删除。BFS更适合深度大的场景，DFS代码更简洁
    * 💡 **学习笔记**：及时标记/删除已处理元素是图遍历的核心技巧

3.  **大坐标处理**
    * **分析**：坐标达1e9不能直接存储平面。题解1用map桶避免预存所有点；题解2通过网格离散化将坐标映射到有限网格
    * 💡 **学习笔记**：离散化是处理大范围空间的利器

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧A（空间优化）**：利用问题约束（如r≤10）设计高效搜索范围
- **技巧B（数据结构选择）**：根据访问模式选择数据结构（map适合点查询，网格哈希适合范围查询）
- **技巧C（遍历算法选择）**：BFS避免递归栈溢出，DFS简化代码逻辑
- **技巧D（实时删除）**：处理完的元素及时移除可提升后续效率

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合题解优点的通用实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：融合题解2的网格离散化和题解1的连锁反应处理
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <unordered_map>
using namespace std;
typedef long long ll;
typedef pair<ll, ll> pii;

struct Point { ll x, y, r; bool exploded = false; };

int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    int n, m, ans = 0; cin >> n >> m;
    vector<Point> mines(n);
    for (auto& mine : mines) cin >> mine.x >> mine.y >> mine.r;

    // 网格离散化（网格大小=20）
    unordered_map<ll, vector<int>> gridMap;
    auto getKey = [](ll x, ll y) { 
        return (x/20) * 1000000000LL + y/20; 
    };
    for (int i=0; i<n; i++) 
        gridMap[getKey(mines[i].x, mines[i].y)].push_back(i);

    queue<Point> q;
    while (m--) {
        Point rocket; cin >> rocket.x >> rocket.y >> rocket.r;
        q.push(rocket);
        while (!q.empty()) {
            auto cur = q.front(); q.pop();
            ll gx_min = (cur.x - cur.r) / 20, gx_max = (cur.x + cur.r) / 20;
            ll gy_min = (cur.y - cur.r) / 20, gy_max = (cur.y + cur.r) / 20;
            
            for (ll gx = gx_min; gx <= gx_max; gx++) {
                for (ll gy = gy_min; gy <= gy_max; gy++) {
                    ll key = gx * 1000000000LL + gy;
                    auto& list = gridMap[key];
                    for (auto it = list.begin(); it != list.end(); ) {
                        int idx = *it;
                        if (mines[idx].exploded) { it++; continue; }
                        
                        ll dx = mines[idx].x - cur.x, dy = mines[idx].y - cur.y;
                        if (dx*dx + dy*dy > cur.r*cur.r) { it++; continue; }
                        
                        mines[idx].exploded = true;
                        ans++;
                        q.push(mines[idx]);
                        it = list.erase(it);
                    }
                    if (list.empty()) gridMap.erase(key);
                }
            }
        }
    }
    cout << ans;
}
```
* **代码解读概要**：
  > 1. 网格离散化：将平面划分为20×20网格（因r≤10）
  > 2. 哈希映射：gridMap存储每个网格内的雷索引
  > 3. BFS处理：火箭作为起点，检查周围网格内的雷
  > 4. 实时删除：引爆后从链表中移除避免重复处理

---
<code_intro_selected>
优质题解核心片段赏析：
</code_intro_selected>

**题解一：(来源：zzy0618)**
* **亮点**：简洁的DFS+坐标桶映射
* **核心代码片段**：
```cpp
void dfs(int x,int y,int r){
    for(int i=x-r;i<=x+r;++i){  // 遍历周围正方形区域
        for(int j=y-r;j<=y+r;++j){
            if((i-x)*(i-x)+(j-y)*(j-y)>r*r) continue; // 排除圆外点
            if(mp.count({i,j})) {
                int z=mp[{i,j}];
                if(vis[z]) continue;
                vis[z]=1; ans+=cnt[z];
                dfs(i,j,tmp[z]);  // 递归引爆
            }
        }
    }
}
```
* **代码解读**：
  > 双重循环遍历以(x,y)为中心的正方形区域（边长2r），通过距离平方过滤圆外点。当找到雷时，标记为已访问并递归引爆。mp桶实现坐标到雷信息的快速查找
* 💡 **学习笔记**：r较小时，O(r²)的暴力搜索比复杂数据结构更实用

**题解二：(来源：clarinet_pht)**
* **亮点**：网格哈希+链表删除的工业级实现
* **核心代码片段**：
```cpp
for(int dx=-1;dx<=1;dx++) {  // 遍历周围9个网格
    for(int dy=-1;dy<=1;dy++) {
        int cx=cx0+dx, cy=cy0+dy;
        Gkey key{cx,cy};
        if(!gmp.count(key)) continue;
        
        auto& lst = gmp[key];
        for(auto it=lst.begin(); it!=lst.end(); ) {
            int idx=*it;
            if(mn[idx].ex) { it = lst.erase(it); continue; } // 删除已引爆
            
            // 距离检测...
            if(在范围内) {
                mn[idx].ex = true;
                total++;
                q.push(mn[idx]);  // BFS扩展
                it = lst.erase(it);  // 关键删除操作
            } else it++;
        }
    }
}
```
* **代码解读**：
  > 仅检查当前网格周围3×3区域（9个网格）。遍历网格内雷链表时，实时删除已处理元素。删除操作确保后续查询不重复处理相同元素，极大提升效率
* 💡 **学习笔记**：链表中及时删除已处理元素是空间优化关键

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
**主题**：8-bit风格扫雷连锁反应模拟  
**核心演示**：火箭触发→连锁引爆过程  
**设计思路**：复古像素风格降低理解门槛，游戏化机制增强参与感

**动画流程**：
1. **场景初始化**（像素网格平面）：
   - 灰色网格（20×20为一区块）
   - 红色像素点：未引爆雷
   - 绿色十字：排雷火箭
   - 侧边栏显示哈希表状态

2. **火箭引爆**（按空格键触发）：
   ```伪代码
   火箭位置闪烁绿光 → 圆形扩散动画(黄色) → 范围内红点变黄 → 叮！音效
   ```

3. **连锁反应**（BFS自动演示）：
   ```伪代码
   while (!queue.empty()):
      当前雷高亮闪烁 → 计算爆炸范围(红色光圈) → 
      扫描周围9网格 → 合格雷变黄 → 爆炸音效 → 
      从哈希表删除已引爆雷（侧边栏对应网格变灰）
   ```

4. **交互控制**：
   - 方向键移动观察位置
   - A键：自动演示（速度可调）
   - S键：单步执行
   - R键：重置场景

5. **游戏化元素**：
   - 每引爆一雷+10分，连锁反应+5分连击奖励
   - 通关条件：所有雷变灰
   - 胜利音效：8-bit胜利旋律

**技术实现**：
- 使用Canvas绘制网格和动画
- 哈希表状态用DOM实时渲染
- Web Audio API提供音效：
  - 爆炸：短促"砰！"
  - 连锁：上升音阶
  - 胜利：马里奥式胜利旋律

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
连锁反应和空间优化技巧的延伸应用：
</similar_problems_intro>

1. **洛谷 P2038 无线网络发射器选址**  
   → 相同网格离散化技巧
   
2. **洛谷 P2280 激光炸弹**  
   → 前缀和+网格范围查询

3. **洛谷 P1661 扩散**  
   → BFS连锁反应+距离判断

---

## 7. 学习心得与经验分享

<insights_intro>
zzy0618题解的调试经验：
</insights_intro>

> **参考经验**：“r≤10的特性是突破口，没有注意到这点会导致TLE”

> **点评**：数据范围限制常隐含优化关键，审题时需特别关注约束条件

---

编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪

---
处理用时：186.46秒
# 题目信息

# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# AI分析结果



---
# 💡 Kay的C++算法解析：【模板】模意义下的乘法逆元 深入学习指南 💡

<introduction>
今天我们来一起分析“模意义下的乘法逆元”这道模板题。本指南将帮助大家理解乘法逆元的概念、掌握高效求解方法，并通过可视化和代码赏析提升解题能力。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`线性递推（编程技巧应用）`

🗣️ **初步分析**：
解决这道题的关键在于快速求出1~n每个数在模p下的乘法逆元。乘法逆元的定义是：对于数a，存在x使得 \( a \times x \equiv 1 \pmod{p} \)，其中p是质数。  

简单来说，线性递推就像“多米诺骨牌”，利用已知的逆元推导出未知的逆元。例如，已知inv[1]=1，通过递推式 \( \text{inv}[i] = (p - \lfloor \frac{p}{i} \rfloor) \times \text{inv}[p \% i] \% p \)，可以在O(n)时间内计算出所有逆元。这种方法避免了逐个用扩展欧几里得（O(n log p)）或快速幂（O(n log p)）的高时间复杂度，特别适合n高达3e6的情况。

核心算法流程：从inv[1]=1开始，依次计算inv[2], inv[3], ..., inv[n]。每一步利用当前i的余数p%i（其逆元已提前计算），通过递推式直接得到当前i的逆元。

可视化设计思路：用8位像素风格展示一个“逆元生成器”，每个数字i对应一个像素块，颜色从蓝到红渐变表示计算顺序。当计算inv[i]时，高亮p%i的像素块（已计算），并显示递推式的动态计算过程（如数字变化、箭头连接）。关键步骤加入“叮”的音效，完成所有计算时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
为了高效解决本题，我筛选了以下优质题解，它们在线性递推的实现上尤为出色。
</eval_intro>

**题解一：作者：zcysky**
* **点评**：此题解直接给出了线性递推的核心代码，逻辑简洁高效。代码中使用`inv[1]=1`初始化，通过循环递推计算每个i的逆元，并直接输出结果。变量命名清晰（如`inv`数组），边界处理严谨（避免负数），时间复杂度O(n)，完全适配题目数据规模。对于大规模数据（如n=3e6），这种方法是最优选择。

**题解二：作者：Rising_Date**
* **点评**：此题解详细推导了线性递推公式的来源，并给出了完整的代码实现。通过数学推导证明递推式的正确性（如利用带余除法和逆元性质），帮助学习者理解“为什么这样算”。代码中使用`(p - p/i) * inv[p%i] % p`处理负数，确保结果非负，体现了对细节的关注。

**题解三：作者：灵乌路空**
* **点评**：此题解不仅提供了线性递推的代码，还对比了多种方法（如阶乘逆元法），帮助学习者拓宽思路。线性递推部分代码简洁，注释清晰，适合初学者理解。特别提到“递推式中的(p - p/i)是为了避免负数”，这一点对调试和理解至关重要。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们通常会遇到以下关键问题，结合优质题解的思路，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何理解线性递推公式？**
    * **分析**：递推式 \( \text{inv}[i] = (p - \lfloor \frac{p}{i} \rfloor) \times \text{inv}[p \% i] \% p \) 的推导基于带余除法。设 \( p = k \times i + r \)（其中 \( k = \lfloor \frac{p}{i} \rfloor \)，\( r = p \% i \)），则 \( k \times i + r \equiv 0 \pmod{p} \)。两边乘以 \( i^{-1} \times r^{-1} \) 得 \( k \times r^{-1} + i^{-1} \equiv 0 \pmod{p} \)，整理后得到 \( i^{-1} \equiv -k \times r^{-1} \pmod{p} \)。由于 \( r = p \% i < i \)，inv[r]已提前计算，因此可以递推。
    * 💡 **学习笔记**：递推式的核心是利用更小的数的逆元（已计算）推导当前数的逆元，类似“从小到大，逐步求解”。

2.  **关键点2：如何处理负数结果？**
    * **分析**：递推式中 \( -k \times r^{-1} \) 可能为负数，因此需要调整为非负。通过 \( (p - k) \times \text{inv}[r] \% p \) 可以确保结果在0到p-1之间（因为 \( p - k \equiv -k \pmod{p} \)）。
    * 💡 **学习笔记**：模运算中，负数可以通过加p再取模转为正数。

3.  **关键点3：为什么线性递推是最优选择？**
    * **分析**：对于n=3e6，扩展欧几里得（O(n log p)）和快速幂（O(n log p)）的时间复杂度会导致超时。线性递推的O(n)复杂度完美适配大规模数据，是本题的最佳解法。
    * 💡 **学习笔记**：数据规模决定算法选择，大规模数据需优先考虑线性时间复杂度的方法。

### ✨ 解题技巧总结
<summary_best_practices>
- **递推公式记忆**：记住核心递推式 \( \text{inv}[i] = (p - p/i) \times \text{inv}[p \% i] \% p \)，并理解其推导过程。
- **边界处理**：初始化inv[1]=1，因为1的逆元是自身。
- **输出优化**：使用`printf`代替`cout`，避免输出超时（尤其对于n=3e6的情况）。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看一个能高效解决本题的通用核心C++实现，它基于线性递推，时间复杂度O(n)，适合题目要求的大规模数据。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个优质题解的线性递推思路，简洁高效，直接适配题目数据规模。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    using namespace std;

    const int MAXN = 3e6 + 10;
    int inv[MAXN];

    int main() {
        int n, p;
        scanf("%d%d", &n, &p);
        inv[1] = 1;
        printf("1\n"); // 1的逆元是1
        for (int i = 2; i <= n; ++i) {
            inv[i] = (long long)(p - p / i) * inv[p % i] % p;
            printf("%d\n", inv[i]);
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先初始化inv[1]=1（1的逆元是自身），然后从i=2开始循环，利用递推式计算每个i的逆元。每一步计算时，`p/i`是k，`p%i`是r，通过`(p - k) * inv[r] % p`得到当前i的逆元，并直接输出。

---
<code_intro_selected>
接下来，我们分析优质题解中的核心代码片段，理解其亮点和实现细节。
</code_intro_selected>

**题解一：作者：zcysky**
* **亮点**：代码极简，直接实现线性递推，无冗余操作，适合大规模数据。
* **核心代码片段**：
    ```cpp
    #include<bits/stdc++.h>
    #define N 3000010
    typedef long long ll;
    using namespace std;
    int inv[N],n,p;
    inline int read(){/* 输入优化 */}
    int main(){
        n=read();p=read();inv[1]=1;puts("1");
        for(int i=2;i<=n;i++){
            inv[i]=(ll)(p-p/i)*inv[p%i]%p;
            printf("%d\n",inv[i]);
        }
    }
    ```
* **代码解读**：
    输入优化（`read`函数）加快输入速度；`inv[1]=1`初始化；循环中使用`(ll)`强制转换避免溢出，确保计算正确性。每一步直接输出结果，节省内存。
* 💡 **学习笔记**：输入输出优化对大规模数据至关重要，`printf`比`cout`更快。

**题解二：作者：Rising_Date**
* **亮点**：代码中明确处理了负数情况，确保结果非负。
* **核心代码片段**：
    ```cpp
    inv[i] = (ll)p - (p / i) * inv[p % i] % p;
    ```
* **代码解读**：
    `(ll)p - ...` 确保结果为正（因为`(p/i)*inv[p%i]%p`可能小于p，所以`p - ...`后结果在0到p-1之间）。通过模运算取余，最终得到正确逆元。
* 💡 **学习笔记**：模运算中，负数转正数的常见方法是加p后取模。

**题解三：作者：灵乌路空**
* **亮点**：提供了阶乘逆元法的对比代码，拓宽思路。
* **核心代码片段**：
    ```cpp
    // 阶乘逆元法
    f[n] = mul(c[n], p-2, p); // 计算n!的逆元
    for(int i = n-1; i >= 1; --i)
        f[i] = (f[i+1] * (i+1)) % p; // 递推阶乘逆元
    for(int j = 1; j <= n; ++j)
        printf("%lld\n", (f[j] * c[j-1]) % p); // 计算i的逆元
    ```
* **代码解读**：
    先计算阶乘数组`c`，再用快速幂求n!的逆元`f[n]`，然后逆推阶乘逆元数组`f`。最后通过`f[j] * c[j-1]`得到j的逆元（因为 \( j^{-1} = (j!)^{-1} \times (j-1)! \)）。
* 💡 **学习笔记**：阶乘逆元法适用于需要同时计算阶乘和逆元的场景，是线性递推的另一种实现方式。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解线性递推的过程，我们设计一个“逆元生成器”的8位像素动画，模拟inv数组的计算过程。
</visualization_intro>

  * **动画演示主题**：`像素逆元工厂`（复古FC风格）

  * **核心演示内容**：展示从inv[1]开始，依次计算inv[2]到inv[n]的过程，每个步骤高亮当前i、p%i及其逆元，动态显示递推式的计算。

  * **设计思路简述**：采用8位像素风格（红、蓝、黄主色调），每个数字i对应一个像素块，颜色随计算进度渐变（未计算时蓝色，计算后红色）。关键步骤加入音效（如“叮”表示完成一个逆元计算），增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示“逆元工厂”标题，右侧是n个像素块（代表1~n），初始颜色为蓝色。
        - 控制面板有“开始”“单步”“重置”按钮和速度滑块。

    2.  **启动计算**：
        - 点击“开始”，inv[1]的像素块变为红色（值为1），播放“叮”音效。

    3.  **递推计算**：
        - 对于i=2，计算p%i（如i=2，p=13时p%i=1），高亮p%i的像素块（inv[1]已计算，红色）。
        - 显示递推式：`inv[2] = (13 - 13/2) * inv[1] % 13 = (13-6)*1%13=7`。
        - inv[2]的像素块变为红色，显示数值7，播放音效。
        - 类似步骤依次计算i=3到i=n，每个步骤高亮p%i的像素块（已计算），动态更新当前i的逆元值。

    4.  **完成状态**：
        - 所有像素块变为红色，显示“计算完成！”，播放胜利音效（如短旋律）。

    5.  **交互控制**：
        - 单步模式：点击“单步”，逐步执行每个i的计算，观察每一步的递推过程。
        - 速度调整：滑块控制计算速度（慢、中、快），适合不同学习需求。

  * **旁白提示**：
    - （i=1时）“1的逆元是它自己，所以inv[1]=1！”
    - （i=2时）“现在计算i=2的逆元，p%i=1，inv[1]已经算好，代入公式得到inv[2]=7！”
    - （关键步骤）“注意看，p%i的逆元已经提前计算好了，所以可以直接用！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到每个逆元如何利用更小的数的逆元推导出来，理解线性递推的高效性和逻辑性。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了线性递推求逆元后，我们可以将这种思想应用到更多场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    线性递推法不仅适用于求逆元，还可用于求阶乘、欧拉函数等需要递推的数论问题。关键是找到“用已计算的小数推导大数”的递推关系。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1082 - 同余方程**  
        🗣️ **推荐理由**：直接应用扩展欧几里得算法求解逆元，巩固对逆元定义的理解。
    2.  **洛谷 P5431 - 乘法逆元2**  
        🗣️ **推荐理由**：在本题基础上增加了除法操作，需结合线性递推和前缀积，提升综合应用能力。
    3.  **洛谷 P2613 - 【模板】有理数取模**  
        🗣️ **推荐理由**：涉及分数取模，需用逆元将除法转换为乘法，强化逆元的实际应用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者提到调试时的经验，例如使用`cout`输出导致超时，改用`printf`后通过。这些经验对实际编码非常有用。
</insights_intro>

> **参考经验 (来自多位作者)**：“一开始用`cout`输出，结果超时。后来换成`printf`，并优化输入（如使用快速读入函数），才通过了所有测试点。”

> **点评**：对于大规模数据（如n=3e6），输入输出效率至关重要。`printf`比`cout`更快，配合快速读入函数（如`inline int read()`）可显著减少时间。这提醒我们在实际编码中要注意输入输出的优化。

-----

<conclusion>
本次关于“模意义下的乘法逆元”的分析就到这里。通过理解线性递推的核心思想、赏析高效代码、观看可视化动画，相信大家已经掌握了这道题的解法。记住，多练习、多总结，编程能力会稳步提升！下次见~ 💪
</conclusion>

-----

---
处理用时：181.11秒
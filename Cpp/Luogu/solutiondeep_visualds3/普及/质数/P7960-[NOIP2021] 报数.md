# 题目信息

# [NOIP2021] 报数

## 题目描述

报数游戏是一个广为流传的休闲小游戏。参加游戏的每个人要按一定顺序轮流报数，但如果下一个报的数是 $7$ 的倍数，或十进制表示中含有数字 $7$，就必须跳过这个数，否则就输掉了游戏。

在一个风和日丽的下午，刚刚结束 SPC20nn 比赛的小 r 和小 z 闲得无聊玩起了这个报数游戏。但在只有两个人玩的情况下计算起来还是比较容易的，因此他们玩了很久也没分出胜负。此时小 z 灵光一闪，决定把这个游戏加强：任何一个十进制中含有数字 $7$ 的数，它的所有倍数都不能报出来！

形式化地，设 $p(x)$ 表示 $x$ 的十进制表示中是否含有数字 $7$，若含有则 $p(x) = 1$，否则 $p(x) = 0$。则一个正整数 $x$ 不能被报出，当且仅当存在正整数 $y$ 和 $z$ ，使得 $x = yz$ 且 $p(y) = 1$。


例如，如果小 r 报出了 $6$ ，由于 $7$ 不能报，所以小 z 下一个需要报 $8$；如果小 r 报出了 $33$，则由于 $34 = 17 \times 2$，$35 = 7 \times 5$ 都不能报，小 z 下一个需要报出 $36$ ；如果小 r 报出了 $69$，由于 $70 \sim 79$ 的数都含有 $7$，小 z 下一个需要报出 $80$ 才行。

现在小 r 的上一个数报出了 $x$，小 z 想快速算出他下一个数要报多少，不过他很快就发现这个游戏可比原版的游戏难算多了，于是他需要你的帮助。当然，如果小 r 报出的 x 本身是不能报出的，你也要快速反应过来小 r 输了才行。

由于小 r 和小 z 玩了很长时间游戏，你也需要回答小 z 的很多个问题。

## 说明/提示

**【样例解释 #1】**

这一组样例的前 $3$ 次询问在题目描述中已有解释。

对于第 $4$ 次询问，由于 $300 = 75 \times 4$，而 $75$ 中含有 $7$ ，所以小 r 直接输掉了游戏。

**【数据范围】**

对于 $10\%$ 的数据，$T \leq 10$，$x \leq 100$。  
对于 $30\%$ 的数据，$T \leq 100$，$x \leq 1000$。  
对于 $50\%$ 的数据，$T \leq 1000$，$x \leq 10000$。  
对于 $70\%$ 的数据，$T \leq 10000$，$x \leq 2 \times {10}^5$。  
对于 $100\%$ 的数据，$1 \le T \leq 2 \times {10}^5$，$1 \le x \leq {10}^7$。

## 样例 #1

### 输入

```
4
6
33
69
300
```

### 输出

```
8
36
80
-1
```

## 样例 #2

### 输入

```
5
90
99
106
114
169
```

### 输出

```
92
100
109
-1
180
```

## 样例 #3

### 输入

```
见附件中的 number/number3.in```

### 输出

```
见附件中的 number/number3.ans```

## 样例 #4

### 输入

```
见附件中的 number/number4.in```

### 输出

```
见附件中的 number/number4.ans```

# AI分析结果



---
# 💡 Kay的C++算法解析：NOIP2021 报数 深入学习指南 💡

<introduction>
今天我们来一起分析“NOIP2021 报数”这道C++编程题。这道题的关键在于高效预处理不可报出的数，并快速回答每个询问。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`筛法应用（埃氏筛变形）`

🗣️ **初步分析**：
解决“报数”问题的关键在于高效预处理所有不可报出的数。简单来说，筛法的核心思想是通过标记法排除不符合条件的数——就像用筛子过滤豆子，把不符合条件的“筛掉”。在本题中，所有包含数字7的数及其倍数都不可报出，因此我们可以用类似埃拉托斯特尼筛法（埃氏筛）的方法预处理这些数。

- **题解思路**：所有题解的核心都是预处理不可报出的数（标记数组），并预处理每个数的下一个可报出数（ans数组）。例如，用`f`数组标记不可报出的数，再从后往前遍历维护`ans`数组，记录每个数的下一个可报数。
- **核心难点**：如何高效标记所有不可报出的数（避免重复标记）、预处理下一个可报数的边界处理（如x=1e7时，下一个数可能是1e7+1）。
- **可视化设计**：采用8位像素风格动画，用不同颜色标记可报（绿色）和不可报（红色）的数。动画将演示筛法过程：当遍历到包含7的数时，其倍数被逐个标记为红色；预处理`ans`数组时，从后往前移动指针，记录每个数的下一个绿色数。关键步骤（如标记倍数、更新ans）会伴随“叮”的音效，增强记忆点。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性和实践价值，以下题解表现突出（均≥4星）：
</eval_intro>

**题解一：作者：银杉水杉秃杉**
* **点评**：此题解思路清晰，代码规范。通过`f`数组标记不可报出的数，`nx`数组记录下一个可报数。预处理时，若当前数含7则标记其所有倍数；否则更新`nx`数组。读入优化和输出优化处理了大数据量的输入输出问题，时间复杂度为O(1e7 + T)，完全符合数据范围要求。代码变量命名直观（如`ls`表示上一个可报数），边界处理严谨（预处理到1e7+100），是竞赛中的典型高效实现。

**题解二：作者：Mortis_Vampire**
* **点评**：此题解巧妙地从后往前预处理`ans`数组。维护`last`变量记录当前最小可报数，从1e7倒序遍历，若当前数可报则更新`last`，否则`ans[i] = last`。这种方法避免了正向遍历时逐个查找的高复杂度，预处理时间O(1e7)，查询O(1)，代码简洁高效。

**题解三：作者：StudyingFather**
* **点评**：此题解使用`vis`数组标记不可报出的数，`lis`数组存储可报数序列。预处理时，若当前数含7则标记其倍数；否则将其加入`lis`。查询时通过`vis[x]`判断是否可报，若可报则直接取`lis[vis[x]+1]`。思路直观，代码结构工整，适合理解筛法与序列存储的结合应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的过程中，我们需要重点突破以下核心难点：
</difficulty_intro>

1.  **关键点1：高效标记不可报出的数**
    * **分析**：不可报出的数包括两类：含数字7的数，以及它们的倍数。直接枚举每个数并检查是否含7，再标记其倍数，时间复杂度会很高。通过埃氏筛思想，若当前数已被标记（不可报），则跳过；否则检查是否含7，若是则标记其所有倍数。这种方法利用了“倍数传递性”，避免重复标记，将时间复杂度优化到可接受范围。
    * 💡 **学习笔记**：筛法的核心是“标记传递”，利用已标记的数减少重复操作。

2.  **关键点2：预处理下一个可报数**
    * **分析**：若直接对每个询问从x+1开始逐个查找，最坏情况下（如x=1e7且其后很多数不可报）会超时。预处理时从后往前遍历，维护当前最小可报数`last`，每个可报数的`ans`即为`last`，并更新`last`为当前数。这种方法O(1e7)时间预处理，查询O(1)。
    * 💡 **学习笔记**：逆向遍历+维护变量是预处理“下一个”问题的常用技巧。

3.  **关键点3：边界条件处理**
    * **分析**：当x=1e7时，下一个可报数可能超过1e7（如1e7+1）。预处理时需将数组范围扩大（如到1e7+100），确保覆盖所有可能的查询。
    * 💡 **学习笔记**：大数据范围问题中，预处理数组需预留足够空间。

### ✨ 解题技巧总结
- **筛法优化**：标记不可报数时，仅处理未被标记的数，避免重复操作。
- **逆向预处理**：从大到小遍历，维护当前最小可报数，快速得到每个数的下一个可报数。
- **输入输出优化**：使用快读快写（如`read`和`write`函数），减少IO时间，应对大数据量查询。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了高效预处理和快速查询。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了银杉水杉秃杉和Mortis_Vampire的题解思路，预处理不可报数数组`f`和下一个可报数数组`ans`，确保O(1)查询。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 1e7 + 100; // 预处理到1e7+100，覆盖边界
    bool f[N]; // 标记不可报出的数
    int ans[N]; // ans[x]表示x的下一个可报数

    // 判断x是否含数字7
    bool check(int x) {
        while (x) {
            if (x % 10 == 7) return true;
            x /= 10;
        }
        return false;
    }

    void init() {
        // 预处理不可报数
        for (int i = 1; i < N; ++i) {
            if (f[i]) continue; // 已被标记，跳过
            if (check(i)) { // 含7，标记所有倍数
                for (int j = i; j < N; j += i) {
                    f[j] = true;
                }
            }
        }
        // 预处理下一个可报数
        int last = N; // 初始为1e7+100（假设其可报）
        for (int i = N - 1; i >= 1; --i) {
            if (!f[i]) { // 可报，更新last
                ans[i] = last;
                last = i;
            } else {
                ans[i] = -1; // 不可报，ans为-1（实际查询时直接判断f[x]）
            }
        }
    }

    // 快读
    inline int read() {
        int x = 0, f = 1;
        char ch = getchar();
        while (!isdigit(ch)) {
            if (ch == '-') f = -1;
            ch = getchar();
        }
        while (isdigit(ch)) {
            x = x * 10 + (ch ^ 48);
            ch = getchar();
        }
        return x * f;
    }

    // 快写
    inline void write(int x) {
        if (x < 0) {
            putchar('-');
            x = -x;
        }
        if (x > 9) write(x / 10);
        putchar(x % 10 + '0');
    }

    int main() {
        init();
        int T = read();
        while (T--) {
            int x = read();
            if (f[x]) {
                puts("-1");
            } else {
                write(ans[x]);
                putchar('\n');
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先通过`check`函数判断数是否含7，`init`函数预处理不可报数数组`f`和下一个可报数数组`ans`。`read`和`write`函数优化输入输出。主函数处理查询，根据`f[x]`判断是否可报，输出`ans[x]`。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者：银杉水杉秃杉**
* **亮点**：预处理`nx`数组记录下一个可报数，逻辑清晰，代码规范。
* **核心代码片段**：
    ```cpp
    int ls = 0;
    void init() {
        for (int i = 1; i <= N - 10; i++) {
            if (f[i]) continue;
            if (check(i)) {
                for (int j = i; j <= N - 10; j += i)
                    f[j] = 1;
                continue;
            }
            nx[ls] = i;
            ls = i;
        }
    }
    ```
* **代码解读**：`ls`记录上一个可报数。遍历每个数，若不可报则跳过；若含7则标记其倍数；否则更新`nx[ls]`为当前数，并将`ls`设为当前数。这样`nx[x]`直接存储x的下一个可报数，查询时O(1)。
* 💡 **学习笔记**：维护“上一个”变量是预处理序列的常用方法。

**题解二：作者：Mortis_Vampire**
* **亮点**：逆向预处理`ans`数组，高效记录下一个可报数。
* **核心代码片段**：
    ```cpp
    int last = 10000001;
    for (int i = 10000000; i >= 1; i--) {
        ans[i] = last;
        if (!f[i]) last = i;
    }
    ```
* **代码解读**：从1e7倒序遍历，`last`初始为1e7+1（假设可报）。若当前数可报，则`ans[i]`为`last`，并更新`last`为当前数；否则`ans[i]`保持`last`。这样每个可报数的下一个数被正确记录。
* 💡 **学习笔记**：逆向遍历能高效处理“下一个”问题，避免正向查找的高复杂度。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解筛法和预处理过程，我们设计一个“像素筛数探险”动画，用8位风格展示不可报数的标记和下一个可报数的预处理。
</visualization_intro>

  * **动画演示主题**：`像素筛数大冒险`

  * **核心演示内容**：展示埃氏筛标记不可报数（含7的数及其倍数），以及逆向预处理`ans`数组的过程。

  * **设计思路简述**：采用FC红白机风格，用绿色方块表示可报数，红色方块表示不可报数。动画通过颜色变化、闪烁和音效，突出标记倍数和更新`ans`的关键步骤，帮助理解筛法的“传递性”和预处理的高效性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕显示100x100的像素网格（每个格子代表一个数，1到1e4示例，实际可扩展），顶部显示控制面板（单步/自动/重置按钮，速度滑块）。
        - 背景音乐：8位风格的轻快旋律。

    2.  **筛法标记过程**：
        - 遍历每个数（像素格子从左到右、从上到下移动）。当遇到含7的数（如7、17），该格子变为红色并闪烁，伴随“叮”的音效。
        - 标记其倍数：从该数开始，每隔该数的距离（如7的倍数：14、21...）的格子依次变为红色，每个变化伴随“滴答”音效。

    3.  **预处理ans数组**：
        - 逆向遍历（格子从右到左移动），维护一个黄色指针`last`。当遇到绿色格子（可报数），`last`移动到该格子，该格子的`ans`值显示为`last`的位置（黄色箭头指向）。

    4.  **查询演示**：
        - 输入一个数x，对应格子若为红色则显示“-1”；若为绿色则显示`ans[x]`（黄色箭头指向的下一个绿色格子），伴随“成功”音效。

  * **旁白提示**：
    - “看！这个格子是7，含有数字7，它的所有倍数都会被标记为红色！”
    - “现在从后往前找，每个绿色格子的下一个可报数就是后面最近的绿色格子～”

<visualization_conclusion>
通过这个动画，我们能直观看到筛法如何高效标记不可报数，以及预处理`ans`数组如何快速得到下一个可报数。像素风格和音效让抽象的算法变得生动有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的筛法和预处理思想后，我们可以尝试以下相似问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 筛法思想可用于处理“标记倍数”类问题（如质数筛、约数筛）。
    - 预处理“下一个”问题的逆向遍历技巧，适用于求后续最近符合条件的数（如最近的更大元素）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3383 线性筛质数**  
        * 🗣️ **推荐理由**：练习埃氏筛和欧拉筛的区别，巩固筛法思想。
    2.  **洛谷 P1865 A+B的质数对**  
        * 🗣️ **推荐理由**：结合筛法和双指针，训练筛法的实际应用。
    3.  **洛谷 P2014 选课**  
        * 🗣️ **推荐理由**：树形结构的筛法应用，拓展筛法到更复杂场景。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者提到调试时的经验，例如：
</insights_intro>

> **参考经验 (来自 银杉水杉秃杉)**：“考场上一定要用上读入优化和输出优化，小心可能会被卡。”

**点评**：在大数据量（如T=2e5）的情况下，普通的`cin/cout`会因速度慢导致超时。快读快写通过字符处理优化IO时间，是竞赛中的必备技巧。这提醒我们，处理输入输出时需根据数据量选择合适的优化方法。

---

<conclusion>
本次关于“NOIP2021 报数”的分析就到这里。通过理解筛法思想、预处理技巧和边界处理，我们可以高效解决这类问题。希望大家在练习中多思考、多总结，提升算法能力！下次再见～💪
</conclusion>

---
处理用时：173.52秒
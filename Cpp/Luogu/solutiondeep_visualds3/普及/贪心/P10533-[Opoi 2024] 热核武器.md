# 题目信息

# [Opoi 2024] 热核武器

## 题目背景



跳蚤国与蛐蛐国正在激战！

![level](https://tse3-mm.cn.bing.net/th/id/OIP-C.ewEm2cQO23KvtiSwFQMFGQHaE8?w=293&h=195&c=7&r=0&o=5&pid=1.7)

上面是战术核显卡，与题目没有关联。

## 题目描述

跳蚤国的国土可以看作平面直角坐标系。

跳蚤国有 $N+1$ 座城市，有 $1$ 座是首都，位于 $(0,0)$，另 $N$ 座是普通城市，在这里假设首都为 $0$ 号城市，其他城市编号为 $1$ 至 $N$，对于每一座普通城市，位于 $(x_i,y_i)$。


由于跳蚤国财力有限，对于每一个不是首都的城市 $i$，它会选择一个城市 $j$ 修建一条双向公路。令 $dis(x,y)$ 为 $x$，$y$ 城市的欧几里得距离，**则对于每一个不是首都的城市 $i$，它所对应的 $j$ 则是满足 $dis(j,0) \le dis(i,0)$ ，$j \ne i$ 的所有点中 $dis(i,j)$ 最小的点，如有多个合法 $j$，取其中编号最小的一个。**

定义一座城市的 $\gamma$ 值为这个城市走到首都所需要的最小道路数 $+1$，**如果走不到首都，设 $\gamma$ 值为 $0$。**

蛐蛐国要对跳蚤国进行战术核显卡打击，这次行动分为两个组：洛伦兹组和安培组。每个组都要对跳蚤国的部分城市进行打击，其中两个组需要恰好把跳蚤国每个城市打击一遍。

对于这两个组来说，名利是最重要的，而蛐蛐国的评功标准是按照本次行动所打击城市的 $\gamma$ 值和。所以你需要求出：有没有一种划分方式使得洛伦兹组和安培组分别的打击城市的 $\gamma$ 值和相等，可以，输出 ```Yes```，否则输出 ```No``` 。

## 说明/提示

### 样例解释

这幅图是长这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/dasec5pr.png)

对于 $C1$，$C0$ 和 $C2$ 满足 $dis(j,0) \le dis(C1,0)$，但是 $C0$ 离 $C1$ 距离更近，添加边 $(C1,C0)$。

对于 $C2$，只有 $C0$ 满足 $dis(j,0) \le dis(C2,0)$，添加边 $(C2,C0)$。

对于 $C3$，$C0$，$C1$ 和 $C2$ 满足 $dis(j,0) \le dis(C3,0)$，但是 $C2$ 离 $C3$ 距离最近，因此添加边 $(C3,C2)$。**注意这里是因为在 $C3$ 处考虑时，最优点为 $C2$，所以 $C3$ 才向 $C2$ 修建了一条公路，和公路 $(C2,C0)$ 完全独立。**

对于 $C4$，其他所有点都满足 $dis(j,0) \le dis(C4,0)$，但是 $C0$ 离 $C4$ 距离最近，添加边 $(C4,C0)$。

得到下面的表：

| 城市编号 | $\gamma$ 值 |
| :-----------: | :-----------: |
| 0 | 1 |
| 1 | 2 |
| 2 | 2 |
| 3 | 3 |
| 4 | 2 |

所以把 $0,1,2$ 分给洛伦兹组，$3,4$ 分给安培组即可。

### 数据范围

$1 \le N \le 500$，$-10^6 \le x_i,y_i \le 10^6$。

### 特殊说明

由于本题输出只有 ```Yes``` 和 ```No```，所以本题采用最小分值评测法，即取所有测试点的得分最小值作为结果。


## 样例 #1

### 输入

```
4
-1 -1
1 0
1 -2
-2 2```

### 输出

```
Yes```

# AI分析结果

# 💡 Kay的C++算法解析：[Opoi 2024] 热核武器 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（模拟建图 + BFS最短路径 + 01背包动态规划）

🗣️ **初步分析**：  
我们可以把这道题想象成“给城市找邻居、传消息、分糖果”的游戏：  
1. **找邻居（建图）**：每个城市要找一个离首都更近（或一样近）、且离自己最近的“邻居”建公路——就像你要找一个住得离市中心更近，且离你家最近的朋友家串门~  
2. **传消息（求γ值）**：从首都出发，用“传话游戏”（BFS）计算每个城市收到消息的最少步骤——每传一次消息，步骤数+1，这就是γ值（步骤数+1）。  
3. **分糖果（背包问题）**：把所有城市的“糖果数”（γ值）分成两堆，看能不能刚好分匀——就像分糖果时要保证两堆一样多！  

**核心算法流程**：  
- **建图**：暴力枚举每个城市i，找到满足条件的j（离首都更近、离i最近、编号最小），建双向边。  
- **求γ值**：用BFS从首都（0号）出发，计算每个节点的最短路径长度+1（因为γ是步骤数+1）。  
- **背包判断**：计算γ值总和，如果是奇数直接输出No；否则用01背包（或bitset优化）判断能否凑出总和的一半。  

**可视化设计思路**：  
我们用8位像素风模拟整个过程：  
- **建图阶段**：用不同颜色的像素块表示城市（首都红色，普通城市蓝色），建边时用黄色线条连接i和j，伴随“叮”的音效。  
- **BFS阶段**：用绿色箭头表示消息传递方向，队列用像素方块堆叠展示，每处理一个节点就闪烁并播放“传”的音效。  
- **背包阶段**：用像素块表示γ值，每次选择一个块就移动到另一堆，伴随“选”的音效，最后如果两堆一样高就播放“胜利”音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮你快速理解核心逻辑~
</eval_intro>

**题解一：来源：shuqiang（赞：13）**  
* **点评**：这道题解把问题拆成“建图、求γ值、背包”三部分，思路像“拆解乐高积木”一样清晰！建图部分直接模拟题意，求γ值用Floyd或Dijkstra（适合新手理解），背包部分用01背包模板。代码分模块，注释清楚，是入门的好参考~

**题解二：来源：hcy1117（赞：3）**  
* **点评**：这道题解用Floyd算法求最短路径（虽然时间复杂度O(n³)，但n≤500刚好能过），然后用“必须装满的01背包”判断是否能分匀。代码完整，变量命名直观（比如e[i][j]表示i到j的最短边数），边界处理严谨（比如判断sum为奇数直接输出No），适合巩固Floyd和背包的基础~

**题解三：来源：wzhm54nr（赞：2）**  
* **点评**：这道题解的亮点是用**bitset优化01背包**！原本01背包的时间复杂度是O(n*sum)，用bitset可以把时间降到O(n*sum/64)，大大加快速度。另外用DFS求γ值（因为图是树，DFS更高效），代码简洁，适合学习优化技巧~

**题解四：来源：qiliu（赞：2）**  
* **点评**：这道题解的“神来之笔”是发现**图是一棵以首都为根的树**！γ值其实就是每个节点的深度（根节点深度1）。这样求γ值就变成了求树的深度，直接DFS或BFS即可，简化了问题。然后背包问题就转化为“能否选若干深度之和等于总和的一半”，思路更清晰~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到的“绊脚石”有三个，我帮你拆解并给出解决方法~
</difficulty_intro>

### 1. 建图时如何正确找到每个i的j？  
**难点**：要满足“dis(j,0)≤dis(i,0)”“dis(i,j)最小”“编号最小”三个条件，容易漏掉其中一个。  
**解决方法**：暴力枚举所有j，依次判断条件：  
- 首先排除j=i；  
- 然后计算dis(j,0)是否≤dis(i,0)（用x²+y²代替欧几里得距离，避免浮点误差）；  
- 最后找dis(i,j)最小的j，若有多个则取编号最小的。  

**学习笔记**：暴力枚举虽然“笨”，但对于n≤500来说完全够用，关键是把条件写全！

### 2. 求γ值时用哪种最短路径算法？  
**难点**：图可能是树或普通图，选对算法能节省时间。  
**解决方法**：  
- 如果图是树（像qiliu指出的），用BFS或DFS最高效（时间O(n)）；  
- 如果图是普通图，用Floyd（O(n³)）或Dijkstra（O(n²)）。但本题建的图其实是树（每个节点只有一个父节点），所以BFS最快！  

**学习笔记**：先分析图的结构，再选算法，能少走弯路~

### 3. 01背包如何处理大sum？  
**难点**：γ值总和可能很大（比如n=500，每个γ是500，sum=250000），普通数组可能不够用。  
**解决方法**：用bitset优化！bitset可以把状态压缩成二进制位，比如bitset<250001> dp，dp[i]表示能否凑出i。转移时用`dp |= dp << γ[i]`，一句话搞定，时间大大减少~

**学习笔记**：bitset是处理大背包问题的“神器”，记得学起来！

### ✨ 解题技巧总结  
- **条件分解**：把复杂条件拆成小条件（比如建图的三个条件），逐一处理；  
- **结构分析**：先看数据结构（比如图是树），再选最优算法；  
- **优化意识**：遇到大数组用bitset压缩，减少时间和空间消耗。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合优质题解的核心实现，帮你把握整体框架~
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了“暴力建图、BFS求γ值、bitset优化背包”的思路，是最简洁高效的实现~
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <bitset>
#include <cmath>
using namespace std;

const int N = 505;
int x[N], y[N], n;
vector<int> edge[N]; // 邻接表存图
int gamma[N]; // 每个节点的γ值
bitset<N*N> dp; // 01背包状态（总和最多500*500=250000）

// 计算点a到点b的平方距离（避免浮点误差）
long long dist_sq(int a, int b) {
    return (long long)(x[a]-x[b])*(x[a]-x[b]) + (long long)(y[a]-y[b])*(y[a]-y[b]);
}

int main() {
    cin >> n;
    x[0] = y[0] = 0; // 首都坐标
    for (int i = 1; i <= n; ++i) {
        cin >> x[i] >> y[i];
    }

    // 1. 建图：暴力找每个i的j
    for (int i = 1; i <= n; ++i) {
        long long min_dist = 1e18;
        int best_j = 0;
        long long dis_i0 = dist_sq(i, 0); // i到首都的平方距离
        for (int j = 0; j <= n; ++j) {
            if (i == j) continue;
            long long dis_j0 = dist_sq(j, 0);
            if (dis_j0 > dis_i0) continue; // j到首都更远，跳过
            long long dis_ij = dist_sq(i, j);
            if (dis_ij < min_dist || (dis_ij == min_dist && j < best_j)) {
                min_dist = dis_ij;
                best_j = j;
            }
        }
        edge[i].push_back(best_j);
        edge[best_j].push_back(i);
    }

    // 2. BFS求γ值（最短路径+1）
    queue<int> q;
    q.push(0);
    gamma[0] = 1; // 首都的γ值是1
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : edge[u]) {
            if (gamma[v] == 0) { // 未访问过
                gamma[v] = gamma[u] + 1;
                q.push(v);
            }
        }
    }

    // 3. bitset优化01背包
    long long sum = 0;
    for (int i = 0; i <= n; ++i) {
        sum += gamma[i];
    }
    if (sum % 2 != 0) {
        cout << "No" << endl;
        return 0;
    }
    dp.set(0); // 初始状态：可以凑出0
    for (int i = 0; i <= n; ++i) {
        dp |= dp << gamma[i]; // 选或不选当前γ值
    }
    if (dp.test(sum / 2)) {
        cout << "Yes" << endl;
    } else {
        cout << "No" << endl;
    }

    return 0;
}
```
* **代码解读概要**：  
  1. **建图**：用邻接表存边，暴力找每个i的j（用平方距离避免浮点误差）；  
  2. **BFS求γ值**：从首都出发，每到一个新节点就记录γ值（父节点γ+1）；  
  3. **背包判断**：用bitset快速判断能否凑出总和的一半，是奇数直接输出No。

---

<code_intro_selected>
再看优质题解的核心片段，点出各自的“闪光点”~
</code_intro_selected>

**题解一：来源：shuqiang**  
* **亮点**：分模块写代码，思路清晰，适合新手模仿~
* **核心代码片段**：
```cpp
// part1：建图
for (int i = 1; i <= n; ++i) {
    double min_dis = 1e18;
    int best_j = 0;
    double dis_i0 = sqrt(x[i]*x[i] + y[i]*y[i]);
    for (int j = 0; j <= n; ++j) {
        if (i == j) continue;
        double dis_j0 = sqrt(x[j]*x[j] + y[j]*y[j]);
        if (dis_j0 > dis_i0) continue;
        double dis_ij = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));
        if (dis_ij < min_dis || (dis_ij == min_dis && j < best_j)) {
            min_dis = dis_ij;
            best_j = j;
        }
    }
    edge[i].push_back(best_j);
    edge[best_j].push_back(i);
}
```
* **代码解读**：  
  这段代码是建图的核心——枚举每个i，找满足条件的j。注意用`sqrt`计算欧几里得距离，但其实用平方距离（比如`(x[i]-x[j])*(x[i]-x[j])`）更高效，还能避免浮点误差~  
* **学习笔记**：建图时尽量用整数运算，减少浮点错误！

**题解二：来源：wzhm54nr**  
* **亮点**：用DFS求γ值（树的深度），用bitset优化背包~
* **核心代码片段**：
```cpp
// DFS求γ值（深度）
void dfs(int u, int f) {
    for (auto v : g[u]) {
        if (v != f) {
            dep[v] = dep[u] + 1;
            dfs(v, u);
        }
    }
}

// bitset优化背包
bitset<N*N> dp = {1};
for (int i = 0; i <= n; ++i) {
    dp |= dp << dep[i];
}
```
* **代码解读**：  
  DFS是树的深度优先遍历，`dep[v] = dep[u]+1`直接记录每个节点的深度（γ值）。bitset的`dp |= dp << dep[i]`表示“选当前dep[i]”或“不选”，一句话搞定背包转移，超级高效！  
* **学习笔记**：树的问题用DFS或BFS，比Floyd快很多~

**题解三：来源：qiliu**  
* **亮点**：发现图是树，γ是深度，简化问题~
* **核心代码片段**：
```cpp
// 建图：i的父亲是j
for (int i = 2; i <= cnt; ++i) {
    xy temp = {100000, 100000};
    int w;
    for (int j = 1; j <= cnt; ++j) {
        if (i != j && len(city[j], city[1]) <= len(city[i], city[1]) && len(city[i], city[j]) < len(city[i], temp)) {
            temp = city[j];
            w = j;
        }
    }
    ch[w].push_back(i); // 父节点w的子节点是i
}

// DFS求深度（γ值）
void dfs(int x, int fa) {
    city[x].deep = city[fa].deep + 1;
    for (int i = 0; i < ch[x].size(); ++i) {
        if (ch[x][i] != fa) {
            dfs(ch[x][i], x);
        }
    }
}
```
* **代码解读**：  
  这段代码把图看成树，每个节点i的父节点是j，所以用邻接表`ch[w].push_back(i)`存树结构。DFS时从根节点（首都）出发，每个节点的深度就是γ值，超级简单！  
* **学习笔记**：先分析数据结构（比如图是树），能让问题变简单~


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
用8位像素风模拟整个过程，像玩FC游戏一样学算法！
</visualization_intro>

### 动画设计概述
- **主题**：像素探险家“小跳蚤”建公路、传消息、分糖果~
- **风格**：FC红白机风格（8位像素、4色 palette），背景音乐是《超级马里奥》的轻松旋律~
- **核心演示内容**：
  1. **建图阶段**：屏幕上显示500个蓝色像素块（普通城市）和1个红色像素块（首都）。每个蓝色块会找到一个红色/蓝色块（j），用黄色线条连接，伴随“叮”的音效。
  2. **BFS阶段**：红色块（首都）发出绿色箭头，依次“激活”相邻的蓝色块（标记γ值），队列用像素方块堆叠在屏幕右侧，每处理一个方块就闪烁并播放“传”的音效。
  3. **背包阶段**：屏幕下方有两堆像素块（分别代表两组的γ值），每次从左边的“γ池”选一个块，移动到右边堆，伴随“选”的音效。最后如果两堆高度相同，播放“胜利”音效；否则播放“失败”音效。

### 交互与控制
- **控制面板**：有“开始/暂停”“单步”“重置”按钮，速度滑块（1x~5x）。
- **AI自动演示**：点击“AI玩”按钮，小跳蚤会自动完成建图、BFS和背包，像“贪吃蛇AI”一样~
- **音效**：建边“叮”、传消息“滴”、选块“啪”、胜利“叮~当”、失败“嗡”。

### 设计思路
用像素风降低学习压力，用音效强化操作记忆，用游戏化交互增加趣味性。比如建边时的“叮”声会让你记住“i和j连边了”，BFS的“滴”声会让你记住“消息传过去了”，最后胜利的音效会让你记住“成功了！”~


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会这道题的思路，可以解决很多“建图+最短路径+背包”的问题~
</similar_problems_intro>

### 通用思路迁移
- **建图**：暴力枚举（适合n小的情况）；
- **最短路径**：BFS（树或无权图）、Dijkstra（带权图）、Floyd（多源最短路径）；
- **背包**：01背包（选或不选）、完全背包（无限选）、多重背包（有限选），用bitset优化大总和。

### 洛谷推荐练习
1. **P1002 [NOIP2002 普及组] 过河卒**：类似建图+动态规划，练习最短路径和状态转移。
2. **P1048 [NOIP2005 普及组] 采药**：经典01背包问题，练习状态设计和优化。
3. **P1164 [NOIP2009 普及组] 小A点菜**：01背包的变形，练习“恰好装满”的情况。
4. **P1339 [NOIP2013 普及组] 热浪**：最短路径问题，练习Dijkstra算法。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多作者分享了自己的“踩坑”经历，帮你避免走弯路~
</insights_intro>

> **参考经验（来自shuqiang）**：“建图时我一开始用了浮点距离，结果因为精度问题错了！后来改成平方距离，就对了~”  
> **点评**：浮点运算容易有精度误差，比如`0.1+0.2≠0.3`。建图时用整数的平方距离，能彻底避免这个问题！

> **参考经验（来自wzhm54nr）**：“一开始用Floyd求γ值，超时了！后来发现图是树，用DFS快了10倍~”  
> **点评**：先分析数据结构（比如图是树），再选算法，能节省大量时间！


## 总结
这道题是“建图、最短路径、背包”的综合应用，核心是**把复杂问题拆成小模块**，逐一解决。建图用暴力枚举，最短路径用BFS/DFS（树的情况），背包用bitset优化。学会这些技巧，就能解决很多类似的问题~

下次遇到问题，记得先拆模块、分析数据结构、选最优算法，你一定会越来越厉害！💪

---
处理用时：117.38秒
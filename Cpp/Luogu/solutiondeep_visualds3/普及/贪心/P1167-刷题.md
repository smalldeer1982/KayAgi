# 题目信息

# 刷题

## 题目描述

NOIP 临近了，小 A 却发现他已经不会写题了。好在现在离竞赛还有一段时间，小 A 决定从现在开始夜以继日地刷题。也就是说小 A 废寝忘食，一天二十四小时地刷题。

今天的日期（时间）是 yyyy 年 mm 月 dd 日 hh 时 MM 分，考试的时间是 yyyy2 年 mm2 月 dd2 日 hh2 时 MM2 分。这之间的所有时间小 A 都用来刷题了，那么考试之前他最多能刷多少题呢？注意哦，考虑闰年。

时间紧张小 A 只管数量不管质量。当然有的题目容易一些，有的题目难一些。根据小 A 的经验，他能一眼看出写出某一个题目需要的时间，以分钟记。

现在给出洛谷 Online Judge 的题目列表，请你挑出最多的题目使小A能在竞赛前写出来。

我们假设从远古到未来，历法的表示与现在一样。


## 样例 #1

### 输入

```
2
1
1
2007-06-23-11:59
2007-06-23-12:00```

### 输出

```
1```

# AI分析结果


# 💡 Kay的C++算法解析：刷题 深入学习指南 💡

<introduction>
今天我们来分析NOIP竞赛题"刷题"，这道题考察日期时间计算和贪心算法应用。本指南将帮助大家掌握时间差计算技巧和高效解题策略。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟应用` + `贪心算法`

🗣️ **初步分析**：
> 解决"刷题"这道题的关键在于**精确计算时间差**和**高效选择题目**。就像在复古游戏《时间冒险》中，我们需要先精确计算剩余闯关时间（时间差），再优先选择耗时短的关卡（贪心策略）来获得最高分数。
> - **核心流程**：解析两个时间点 → 计算分钟差 → 排序题目耗时 → 贪心选择
> - **可视化设计**：像素时钟展示日期变化，贪心选择时显示题目耗时条形图。关键变量`总分钟数`实时更新，高亮闰年二月天数变化
> - **复古演示**：FC红白机像素风格，时间计算时显示日历翻页动画，贪心选择时播放"金币收集"音效，可调速单步观察算法决策

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法效率角度，精选三篇优质题解：

**题解一：Ousmane_Dembele (赞43)**
* **点评**：思路直白易懂，使用`scanf`巧妙处理复杂输入格式。代码结构工整，变量名`t`(总时间)含义明确。亮点在于闰年判断函数简洁高效，且正确处理了时间计算方向问题（通过`t*=-1`修正初始计算符号）。调试心得"写反啦"的注释提醒我们注意时间计算方向，具有实践参考价值。

**题解二：傅思维666 (赞14)**
* **点评**：提出"多退少补"的精妙思想，将复杂时间计算分解为年、月、日三个层次。使用平年/闰年双月份数组避免重复条件判断，代码逻辑严谨。边界处理完善（如`day-1`），变量命名规范(`start/endd`)，可直接用于竞赛。

**题解三：king_xbz (赞5)**
* **点评**：创新采用面向对象设计，封装日历计算功能到`Calender`类。通过`getStandardTime()`方法实现优雅的时间差计算，代码模块化程度高。虽然稍显复杂，但提供了优秀的工程实践示范，适合学习高级代码组织技巧。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大难点：

1.  **难点1：精确日期计算**
    * **分析**：优质解法的共同策略是选定基准点(如0000-01-01)，分别计算起止时间到基准的分钟数后相减。关键在正确处理闰年二月变化和月份天数差异，如傅思维题解使用`mon_run/mon_ping`双数组巧妙解决。
    * 💡 **学习笔记**：日期计算宜采用"基准点+偏移量"模式，避免直接相减的边界问题。

2.  **难点2：大整数处理**
    * **分析**：9999年的时间跨度需使用`long long`存储分钟数。Ousmane_Dembele解法中`t`变量类型正确，而部分题解未注意此点导致WA。计算整年时优先累加`年天数*1440`可减少中间值溢出风险。
    * 💡 **学习笔记**：时间计算问题需警惕整数溢出，优先使用大空间数据类型。

3.  **难点3：贪心策略证明**
    * **分析**：当题目可分割时，按耗时升序排列总能得到最优解，因为交换任意两题顺序不会增加可解题数。king_xbz的类封装虽未强调此点，但代码中`sort+顺序选择`的实现暗合该原理。
    * 💡 **学习笔记**：贪心策略的有效性依赖于"优先处理小任务不阻塞大任务"的特性。

### ✨ 解题技巧总结
<summary_best_practices>
1. **输入解析技巧**：用`scanf("%d-%d-%d-%d:%d")`处理格式化输入，避免繁琐字符串处理
2. **模块化设计**：将闰年判断、月份天数获取等功能封装成独立函数
3. **时间计算优化**：以分钟为基本单位，按年→月→日→时→分层次累加
4. **防御性编程**：在日期计算后添加断言验证`(day<=当月天数)`
5. **贪心剪枝**：排序后一旦发现当前题目超时立即`break`，避免无效遍历

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用实现，包含时间计算和贪心选择：

**本题通用核心C++实现参考**
* **说明**：融合Ousmane_Dembele的输入处理、傅思维的多退少补思想和king_xbz的模块化设计
* **完整核心代码**：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long LL;
const int MAXN = 5005;
int n, problems[MAXN];

// 闰年判断 (四年一闰，百年不闰，四百年再闰)
bool isLeap(int year) {
    if (year % 400 == 0) return true;
    if (year % 100 == 0) return false;
    return (year % 4 == 0);
}

// 获取月份天数
int getDays(int year, int month) {
    static int days[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
    if (month == 2) return isLeap(year) ? 29 : 28;
    return days[month];
}

LL calculateMinutes(int y, int m, int d, int h, int min) {
    LL total = 0;
    // 累加整年
    for (int i = 0; i < y; i++)
        total += isLeap(i) ? 366LL * 1440 : 365LL * 1440;
    
    // 累加整月
    for (int i = 1; i < m; i++)
        total += getDays(y, i) * 1440LL;
    
    // 累加天数+小时+分钟
    return total + (d-1)*1440LL + h*60LL + min;
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> problems[i];
    sort(problems, problems + n);
    
    int y1, m1, d1, h1, min1;
    int y2, m2, d2, h2, min2;
    scanf("%d-%d-%d-%d:%d", &y1, &m1, &d1, &h1, &min1);
    scanf("%d-%d-%d-%d:%d", &y2, &m2, &d2, &h2, &min2);
    
    LL start = calculateMinutes(y1, m1, d1, h1, min1);
    LL end = calculateMinutes(y2, m2, d2, h2, min2);
    LL available = end - start;
    
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (available >= problems[i]) {
            count++;
            available -= problems[i];
        } else break;
    }
    cout << count << endl;
    return 0;
}
```
* **代码解读概要**：
  1. `isLeap`封装闰年判断逻辑
  2. `calculateMinutes`从基准年计算总分钟数，层次清晰
  3. 主函数流程：读入→排序→计算时间差→贪心选择
  4. 使用`LL`确保大整数计算安全

---
<code_intro_selected>
**题解一核心片段赏析**：
* **亮点**：简洁的输入处理和符号修正
* **核心代码片段**：
```cpp
scanf("%d-%d-%d-%d:%d",&a[1],&a[2],&a[3],&a[4],&a[5]);
scanf("%d-%d-%d-%d:%d",&b[1],&b[2],&b[3],&b[4],&b[5]);

for(int i=a[1];i<b[1];i++) // 年贡献
   t += isLeap(i) ? 366 : 365;

// 月、日计算...(略)
t = t*1440 + 60*a[4]+a[5] - (60*b[4]+b[5]);
t = -t; // 修正计算方向
```
* **代码解读**：
  > 第一行用`scanf`巧妙跳过分隔符直接获取数字。`for`循环计算整年贡献时，注意结束条件是`i<b[1]`而非`i<=b[1]`，因为当前年按月日单独计算。最后的符号修正体现调试智慧。
  
* 💡 **学习笔记**：时间差计算需保持起止点计算方式一致

**题解二核心片段赏析**：
* **亮点**：双月份数组避免分支判断
* **核心代码片段**：
```cpp
int mon_run[13]={0,31,29,31,30,...}; // 闰年
int mon_ping[13]={0,31,28,31,30,...};// 平年

for(int i=1;i<start[2];i++) // 起始年月调整
   time -= isLeap(start[1]) ? mon_run[i] : mon_ping[i];
```
* **代码解读**：
  > 预先定义平闰年月份天数数组，计算时通过三元运算符选择合适数组。这种"以空间换清晰度"的做法，消除了重复的`if(month==2)`判断，大幅提升代码可读性。
  
* 💡 **学习笔记**：使用查表法简化多分支条件是工程实践常用技巧

**题解三核心片段赏析**：
* **亮点**：面向对象封装日期计算
* **核心代码片段**：
```cpp
class Calendar {
    LL getStandardTime() {
        for(int y=0; y<this->year; y++) 
            total += isLeap(y) ? 366*1440 : 365*1440;
        // ... 月、日计算
        return total;
    }
};
```
* **代码解读**：
  > 将日期计算封装为类的成员方法，内部状态包含年月日等字段。这种设计符合"高内聚"原则，若项目中需多次日期计算可显著减少重复代码。注意`this->year`访问成员变量，避免参数传递。
  
* 💡 **学习笔记**：合理封装是提升代码复用性的关键

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
设计名为《时间冒险者》的像素动画演示，帮助直观理解日期计算和贪心选择：

* **主题**：8-bit像素勇者挑战时间之塔，每层代表一个月份
* **核心演示**：时间差计算过程 + 贪心题目选择

### 动画帧步骤：
1. **场景初始化**：
   - 左侧：FC风格日历面板，显示起止日期
   - 中部：12层时间之塔代表月份，每层像素砖块数=该月天数
   - 右侧：倒计时分钟表 + 题目队列(条形图高度=耗时)

2. **时间计算阶段**：
   ```python
   # 伪代码逻辑
   for year in range(start_year, end_year):
       显示年份像素块
       闰年时二月层闪金光并播放"叮"音效
       添加365/366天砖块到总时间槽
   ```
   - 视觉：勇者从起始层攀登，每层添加对应天数砖块(蓝色普通/金色闰年)
   - 交互：按A键单步执行，B键开启自动演示(速度可调)

3. **贪心选择阶段**：
   ```python
   sort(problems)  # 题目排序动画
   for problem in problems:
       若时间槽高度 ≥ 当前题目高度：
          勇者跳跃收集题目(金币音效)
          时间槽等量缩减
       否则：播放"失败"音效并停止
   ```
   - 视觉：题目队列排序后呈阶梯状，时间槽作为"跳跃高度尺"
   - 音效：收集成功(8-bit金币声)，时间不足(短促警告声)

4. **游戏化元素**：
   - 每正确计算一年获得100积分
   - 贪心阶段连续收集触发连击特效
   - 通关后显示收集题目数评级(S/A/B/C)

### 技术实现要点：
- **Canvas绘制**：网格系统(16x16像素单位)绘制日历塔
- **状态同步**：高亮当前计算步骤对应的代码行
- **音频反馈**：Web Audio API播放芯片音乐音效

<visualization_conclusion>
通过像素化时间之塔的攀登过程，抽象的时间计算转化为直观的空间积累；贪心选择则类比为勇者根据体力(时间)选择台阶，帮助理解"优先小任务"的核心策略。

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握时间计算和贪心策略后，可挑战以下变种：

1. **时区处理**：考虑UTC偏移 (P2787 时区转换)
2. **周期重复**：每周/月循环任务 (P1028 日程安排)
3. **多维贪心**：价值/时间双优化 (1060 活动选择)

**推荐练习**：
1. **洛谷 P1028** - 日程安排
   > 需要处理重复周期事件，强化日期计算能力
   
2. **洛谷 P1060** - 活动选择
   > 经典贪心问题，验证"优先短耗时"策略的局限性
   
3. **洛谷 P2787** - 时区转换
   > 引入时区变换，拓展时间计算维度

---

## 7. 学习心得与经验分享

<insights_intro>
题解中藏有宝贵经验：

> **Ousmane_Dembele 提醒**：初始计算得到负值后意识到方向错误，通过`t=-t`修正
> 
> **点评**：日期差计算中起止顺序极易混淆，建议计算后立即验证简单用例（如相同日期结果应为0）

> **wyly 心得**：调试时发现0000年未特殊处理导致WA
> 
> **点评**：边界测试需包含极值（最小/最大年份），历史日期计算中公元元年处理常被忽略

<conclusion>
时间计算与贪心选择的组合是竞赛常见题型。重点在于：1) 模块化拆分日期计算 2) 警惕整数溢出 3) 贪心策略的证明。建议大家动手实现可视化工具深化理解。下次我们将探索更复杂的调度问题！

---
处理用时：173.53秒
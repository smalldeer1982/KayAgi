# 题目信息

# [蓝桥杯 2025 省 Java B] 数组翻转

## 题目描述

小明生成了一个长度为 $n$ 的正整数数组 $a_1, a_2, \dots , a_n$，他可以选择连续的一段数 $a_l, a_{l+1}, \dots, a_r$，如果其中所有数都相等即 $a_l = a_{l+1} = \dots = a_r$，那么他可以获得 $(r - l + 1) \times a_l$ 的分数。

在选择之前，为了让分数尽可能大，他决定先选择数组中的一段区间，对其进行左右翻转。他想知道在对数组进行翻转之后他能获得的最大分数是多少？

提示：当翻转 $a_l$ 到 $a_r$ 这段区间后，整个数组会变为：

$$a_1, a_2, \dots , a_{l-1}, a_r, a_{r-1}, \dots , a_{l+1}, a_l, a_{r+1}, \dots , a_n$$

## 说明/提示

### 样例说明

翻转区间 $[5, 7]$，数组变为 $4, 4, 3, 3, 3, 1, 2$，最大分数为选择三个 $3$。

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$n \leq 500$。
- 对于 $100\%$ 的评测用例，$1\leq n \leq 10^6$，$1\leq a_i \leq 10^6$。

## 样例 #1

### 输入

```
7
4 4 3 3 2 1 3```

### 输出

```
9```

# AI分析结果

# 💡 Kay的C++算法解析：数组翻转 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（侧重连续段统计与最值更新）


🗣️ **初步分析**：  
我们可以把数组想象成一串“彩色糖果”——每个糖果的颜色代表数组元素的值，连续相同颜色的糖果就是一段“糖果串”。题目中的翻转操作，本质是**把两段相同颜色的糖果串“粘”在一起**（比如把红色糖果的两段分开的串，通过翻转中间的糖果，让它们挨在一起）。我们的目标是找到“粘起来后最长的糖果串”，计算它的得分（长度×颜色值），找出最大的那个。  

### 核心算法流程
1. **统计糖果串**：遍历数组，记录每个颜色（数字）的所有连续段长度（比如红色糖果有3个连续段，长度分别是2、3、1）。  
2. **找最长和次长**：对每个颜色，选出最长的两段（比如红色的3和2），它们的和就是“粘起来后的最长长度”。  
3. **计算最大得分**：用每个颜色的“最长+次长”乘以颜色值，取最大值。  

### 可视化设计思路
我们会用**8位像素风**模拟这个过程：  
- 数组用不同颜色的像素块表示（比如红色=数字3，蓝色=数字4）；  
- 统计连续段时，当前处理的糖果串会**闪烁高亮**；  
- 找到最长和次长的两段后，用“像素动画”把它们“粘”在一起（比如两段红色块缓慢移动合并）；  
- 合并完成时播放“叮”的音效，得分会用像素数字跳出来显示。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、效率等方面筛选了3份优质题解，它们的核心逻辑一致，但实现细节各有亮点～
</eval_intro>

**题解一：beicige（C++）**  
* **点评**：这份题解的思路最直白！它用数组`m`存储每个数字的最长（`m[v][1]`）和次长（`m[v][2]`）连续段长度，遍历数组时实时更新`cnt`（当前连续段长度），当元素变化或到数组末尾时，把`cnt`更新到`m`中。代码风格简洁，边界处理（比如`i==n`时的收尾）很严谨，适合刚学的同学理解基础逻辑。

**题解二：chrispang（C++）**  
* **点评**：此题解用`unordered_map`代替数组存储最长次长，解决了“数字范围很大”的问题（比如数字到1e6时，数组会占很多内存，但哈希表只存出现过的数字）。代码中的`res`变量记录当前连续段长度，逻辑和题解一一致，但更灵活，适合处理大范围数字的场景。

**题解三：Kato_Shoko（C++）**  
* **点评**：这份题解的注释最详细！它用`per`数组记录“以当前位置结尾的连续段长度”（比如`per[i]`是第i个元素所在连续段的长度），当元素变化时，把`per[i-1]`（上一段的长度）更新到哈希表中。思路更偏向“动态维护连续段”，代码结构清晰，还解释了时间复杂度（O(n)），适合想深入理解的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“正确统计连续段”和“高效维护最长次长”，我总结了3个常见难点及解决方法～
</difficulty_intro>

1. **难点1：如何正确统计每个数字的连续段？**  
   * **解决方法**：用一个`cnt`变量记录当前连续段的长度，遍历数组时，如果当前元素和下一个元素相同，`cnt++`；否则，把`cnt`存入该数字的“长度列表”，并重置`cnt=0`。  
   * 💡 学习笔记：连续段统计的核心是“对比相邻元素”，不要漏掉数组末尾的最后一段！

2. **难点2：如何高效维护每个数字的最长和次长？**  
   * **解决方法**：不用存储所有连续段长度，只需要两个变量（最长、次长）。当新的连续段长度`cnt`大于最长时，把次长更新为原来的最长，最长更新为`cnt`；如果`cnt`大于次长但小于最长，就更新次长。  
   * 💡 学习笔记：“只存前两名”能节省内存和时间，不用排序所有长度！

3. **难点3：如何处理数字范围很大的情况？**  
   * **解决方法**：用哈希表（比如`unordered_map`）代替数组存储最长次长。数组适合数字范围小的情况（比如1e3），哈希表适合数字范围大的情况（比如1e6）。  
   * 💡 学习笔记：数据结构的选择要根据“数据范围”决定！


### ✨ 解题技巧总结
- 连续段统计：用`cnt`变量实时记录，对比相邻元素。  
- 最值维护：只存最长和次长，避免存储所有长度。  
- 数据结构选择：数组（小范围） vs 哈希表（大范围）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用的核心实现，它综合了多个题解的思路，结构清晰，适合入门～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码用数组存储最长次长（假设数字范围≤1e6），逻辑简单，适合理解基础流程。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <climits>
using namespace std;

const int MAX_NUM = 1e6 + 5; // 数字的最大值
long long m[MAX_NUM][3]; // m[v][1]最长，m[v][2]次长

int main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int n;
    cin >> n;
    vector<long long> a(n + 2); // a[n+1]用于处理末尾
    long long max_val = -1, min_val = LLONG_MAX;

    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        max_val = max(max_val, a[i]);
        min_val = min(min_val, a[i]);
    }
    a[n + 1] = -1; // 哨兵，确保最后一段被统计

    long long cnt = 1; // 当前连续段长度
    for (int i = 2; i <= n + 1; ++i) {
        if (a[i] == a[i - 1]) {
            cnt++;
        } else {
            long long v = a[i - 1];
            if (cnt > m[v][1]) {
                m[v][2] = m[v][1];
                m[v][1] = cnt;
            } else if (cnt > m[v][2]) {
                m[v][2] = cnt;
            }
            cnt = 1;
        }
    }

    long long ans = 0;
    for (long long v = min_val; v <= max_val; ++v) {
        ans = max(ans, (m[v][1] + m[v][2]) * v);
    }
    cout << ans << endl;

    return 0;
}
```
* **代码解读概要**：  
  1. 读取输入，记录数字的最大值和最小值（用于后续遍历）。  
  2. 用`a[n+1] = -1`作为“哨兵”，确保最后一段连续段被统计。  
  3. 遍历数组，统计每个数字的最长和次长连续段。  
  4. 计算每个数字的“最长+次长”×值，取最大值输出。  


<code_intro_selected>
接下来看3份优质题解的核心片段，学习它们的细节亮点～
</code_intro_selected>

**题解一：beicige（C++）**
* **亮点**：用数组存储最长次长，处理小范围数字时效率很高。
* **核心代码片段**：
```cpp
for (int i = 1; i <= n; i++) {
    cnt++;
    if (a[i] != a[i+1] || i == n) { // 处理末尾
        if (cnt > m[a[i]][1]) {
            m[a[i]][2] = m[a[i]][1];
            m[a[i]][1] = cnt;
        } else if (cnt > m[a[i]][2]) {
            m[a[i]][2] = cnt;
        }
        cnt = 0;
    }
}
```
* **代码解读**：  
  这段代码的关键是`i == n`的判断——当到数组末尾时，不管下一个元素是什么，都要统计当前的`cnt`。比如数组最后一段是`3,3`，`i=7`（n=7）时，会触发`i==n`，把`cnt=2`更新到`m[3]`中。  
* 💡 学习笔记：处理数组末尾的连续段，一定要加`i == n`的条件！


**题解二：chrispang（C++）**
* **亮点**：用`unordered_map`存储最长次长，适合数字范围很大的情况。
* **核心代码片段**：
```cpp
unordered_map<int, pair<int, int>> mp;
for (int i = 2, res = 1; i <= n + 1; i++) {
    if (a[i] == a[i - 1]) res++;
    else {
        if (mp[a[i-1]].first < res) {
            mp[a[i-1]].second = mp[a[i-1]].first;
            mp[a[i-1]].first = res;
        } else if (mp[a[i-1]].second < res) {
            mp[a[i-1]].second = res;
        }
        res = 1;
    }
}
```
* **代码解读**：  
  `unordered_map`的键是数字`v`，值是`pair`（first最长，second次长）。比如数字`3`的最长是3，次长是2，`mp[3]`就是`(3,2)`。这种方法不用预先知道数字的范围，节省内存。  
* 💡 学习笔记：当数字范围很大时，用哈希表比数组更高效！


**题解三：Kato_Shoko（C++）**
* **亮点**：用`per`数组记录“以当前位置结尾的连续段长度”，逻辑更直观。
* **核心代码片段**：
```cpp
vector<ll> a(n+5), per(n+5);
map<int, pair<ll, ll>> mp;
for (int i = 1; i <= n + 1; i++) {
    if (a[i] == a[i - 1]) {
        per[i] = per[i - 1] + 1;
    } else {
        per[i] = 1;
        auto &[firs, seco] = mp[a[i - 1]];
        if (per[i - 1] > firs) {
            seco = firs;
            firs = per[i - 1];
        } else {
            seco = max(seco, per[i - 1]);
        }
    }
}
```
* **代码解读**：  
  `per[i]`表示第`i`个元素所在连续段的长度。比如数组是`3,3,2`，`per[1]=1`，`per[2]=2`，`per[3]=1`。当`a[i] != a[i-1]`时，`per[i-1]`就是上一段的长度，把它更新到`mp`中。这种方法把连续段的长度“绑定”到每个位置，逻辑更清晰。  
* 💡 学习笔记：用`per`数组记录每个位置的连续段长度，能更直观地跟踪连续段的变化！


## 5. 算法可视化：像素动画演示

### 动画主题：像素糖果店的“最长串挑战”
我们用**8位FC游戏风格**设计动画，模拟统计连续段、合并最长次长的过程，让学习更有趣～


### 设计思路简述
采用8位像素风是因为它复古、可爱，能降低学习的紧张感；用“糖果串”比喻连续段，符合青少年的认知；关键操作加音效（比如统计时的“滴”声，合并时的“叮”声），能强化记忆；每完成一个数字的统计，就显示“小关卡完成”，增加成就感。


### 动画帧步骤与交互关键点
1. **场景初始化**：  
   - 屏幕左侧是**像素数组**：每个数字用不同颜色的像素块表示（比如`3`是红色，`4`是蓝色），连续段是同色的长块。  
   - 屏幕右侧是**控制面板**：有“开始/暂停”“单步”“重置”按钮，速度滑块，还有一个“得分板”显示当前最大得分。  
   - 背景播放8位风格的轻快音乐（比如《超级马里奥》的小关卡音乐）。

2. **统计连续段**：  
   - 一个像素化的“小侦探”（比如红色的小方块）从数组左侧开始移动，每遇到连续段就**高亮该段**（比如闪烁），同时在右侧显示当前段的长度（比如“红色段长度：3”）。  
   - 当“小侦探”遇到不同颜色的块时，会把当前段的长度更新到该颜色的“最长/次长”列表中（右侧用像素文字显示，比如“红色：最长3，次长2”）。

3. **合并最长次长**：  
   - 统计完所有数字后，右侧会列出每个数字的“最长+次长”得分，用动画把最长和次长的糖果串“粘”在一起（比如两段红色块缓慢移动合并成一个长块），同时播放“叮”的音效，得分板跳出来显示该数字的得分（比如“红色得分：3+2=5 → 5×3=15”）。

4. **交互控制**：  
   - 支持“单步执行”（每点击一次，“小侦探”移动一步）、“自动播放”（按设定速度运行）、“重置”（回到初始状态）。  
   - 速度滑块可以调整动画速度（比如从“慢”到“快”）。


### 技术实现小提示
- 用HTML5 Canvas绘制像素块：每个像素块是10×10的正方形，颜色用8位色（比如红色`#FF0000`，蓝色`#0000FF`）。  
- 用JavaScript的`setInterval`实现动画循环，`clearInterval`暂停。  
- 用Web Audio API播放音效：比如“滴”声是`440Hz`的正弦波，“叮”声是`880Hz`的正弦波。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的核心是**统计连续段的最长和次长**，这个思路可以用到很多问题中：  
- 统计字符串中连续相同字符的最长段（比如“aaabbbcc”中最长的a段是3）。  
- 统计数组中连续递增/递减的最长段（比如“1,2,3,2,2,3”中最长递增段是3）。  
- 统计二进制数中连续1的最长段（比如“110111”中最长是3）。


### 洛谷练习推荐
1. **P1115 最大子段和**：虽然是求连续子段的最大和，但核心是统计连续段，能练习连续段的处理。  
   * 推荐理由：巩固连续段的统计思路，学会用动态规划维护连续段的和。  
2. **P1200 你的飞碟在这儿**：统计字符串中连续相同的字符的最长段，和本题的连续段统计几乎一样。  
   * 推荐理由：直接练习连续段统计，适合巩固基础。  
3. **P1873 砍树**：虽然是二分法，但需要统计“砍到某一高度时能得到的木材总量”，也是统计连续段的变种。  
   * 推荐理由：练习将统计连续段的思路应用到不同问题中。  


## 7. 学习心得与经验分享

### 来自题解作者的经验
- **beicige**：“我一开始忘了处理数组末尾的最后一段，结果样例输出错了，后来加了`i == n`的条件才对！”  
  * 点评：处理数组的连续段，一定要记得“收尾”——最后一段往往容易漏掉！  
- **Kato_Shoko**：“用`per`数组记录每个位置的连续段长度，能帮我更直观地 debug，比如打印`per`数组就能看到每个位置的连续段长度是否正确。”  
  * 点评：用辅助数组记录中间结果，是 debug 的好方法！  


## 结语
本次分析的核心是“统计连续段的最长和次长”，这个技巧看起来简单，但能解决很多实际问题。记住：**连续段统计的关键是用`cnt`变量实时记录，处理末尾时不要漏掉**！  

希望这份指南能帮你理解这道题，下次遇到类似的连续段问题，你一定能轻松解决～ 💪

--- 
**Kay的小提醒**：编程的进步来自“多写、多测、多思考”，试着把通用代码改成哈希表版本，或者自己加个“打印连续段”的功能，巩固一下吧！ 😊

---
处理用时：92.92秒
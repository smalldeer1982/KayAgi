# 题目信息

# [UOI 2020] Skyscraper

## 题目背景

1s 256M

## 题目描述

Cossack Vus 住在一座摩天大楼里。

自从他开始从事建筑工作以来，$n$ 位客户委托他建造 $n$ 座摩天大楼。其中一座应距离 Cossack Vus 的摩天大楼 1 公里，另一座应距离 2 公里，第三座应距离 3 公里，以此类推。所有摩天大楼（包括 Cossack 的）必须位于同一条直线上，且他的摩天大楼位于最左侧。

第 $i$ 位客户希望他的摩天大楼高度为 $a_i$。然而，客户并不关心他们的摩天大楼距离 Vus 的摩天大楼有多远。因此，Cossack 可以自行决定其他摩天大楼相对于他的摩天大楼的建造顺序。

Cossack Vus 希望从他的摩天大楼看到的景色尽可能美丽。我们假设某一座摩天大楼的第 $i$ 层只有在没有其他摩天大楼的遮挡时，才能从 Vus 的摩天大楼看到。Cossack Vus 认为第 $i$ 座摩天大楼的每一层的美观度为 $b_i$。因此，他希望从他摩天大楼看到的所有楼层的总美观度尽可能大。

![](https://cdn.luogu.com.cn/upload/image_hosting/uh2smivm.png)

一个 $n=4$ 的例子。

图中展示了一个 $n=4$ 的例子。在 1 公里处建造了一座 2 层的摩天大楼，美观度为 $4$；接着是一座 1 层的摩天大楼，美观度为 $2$；然后是一座 3 层的摩天大楼，美观度为 $1$；最后是一座 4 层的摩天大楼，美观度为 $3$。从 Vus 的摩天大楼只能看到第一座摩天大楼的两层、第三座摩天大楼的第三层和第四座摩天大楼的第四层。因此，这些楼层的总美观度为 $4+4+1+3=12$。注意，这可能不是最优的建造顺序。

帮助他找到可能的最大美观度。

## 说明/提示

- （$10$ 分）$1 \leq n \leq 10$，$1 \leq a_i \leq 10$，$1 \leq b_i \leq 10$；
- （$27$ 分）$1 \leq n \leq 10^3$，$1 \leq a_i \leq 10^3$，$1 \leq b_i \leq 10^3$；
- （$25$ 分）$1 \leq n \leq 10^3$，$1 \leq a_i \leq 10^9$，$1 \leq b_i \leq 10^9$；
- （$38$ 分）无额外限制。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
4
2 1 3 4
4 2 1 3```

### 输出

```
14```

## 样例 #2

### 输入

```
6
1 10 3 9 8 2
8 3 2 4 5 6```

### 输出

```
51```

# AI分析结果

# 💡 Kay的C++算法解析：[UOI 2020] Skyscraper 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心  

🗣️ **初步分析**：  
贪心算法就像“挑最甜的葡萄先吃”——面对一堆葡萄，先选最甜的（价值最高的）吃，才能让总甜度最大。本题中，**每栋大楼的“甜度”就是它的每层美观度`b_i`**：我们要让`b_i`大的大楼尽可能“多贡献甜度”（即让它们的未被遮挡的楼层尽可能多）。  

具体来说，题目要求排列大楼顺序，使得从左看，每栋大楼超过之前所有大楼最大高度的部分（可见楼层）乘以`b_i`的总和最大。贪心策略的核心是**按`b_i`降序排序**：把“每一层价值更高”的大楼放在前面，这样它们的未被遮挡的楼层（即超过之前最大高度的部分）能贡献更多总美观度——毕竟，1层价值4的大楼，比2层价值1的大楼贡献更大（4>2）。  

**核心算法流程**：  
1. 将大楼按`b_i`降序排序（若`b_i`相同，按高度`a_i`升序，避免遮挡后续同`b_i`的大楼）；  
2. 遍历排序后的大楼，维护“之前所有大楼的最大高度`maxh`”；  
3. 对当前大楼，若`a_i > maxh`，则贡献`(a_i - maxh) * b_i`，并更新`maxh`为`a_i`。  

**可视化设计思路**：  
我会用**8位像素风格的“美观度收集游戏”**演示算法：  
- 大楼是彩色像素块（`b_i`大的为金色，小的为灰色），排序过程用“像素块滑动交换”动画，伴随“唰”的音效；  
- 计算时，`maxh`用红色水平线标记，当前大楼超过红线的部分闪烁，伴随“叮”的音效，分数板实时增加贡献值；  
- 自动播放模式像“自动收集金币”，一步步展示排序和计算，完成后播放“胜利进行曲”（8位风格），分数板显示总美观度。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了以下优质题解，帮大家快速理解核心逻辑：
</eval_intro>

**题解一：(来源：Lonely_Peak)**  
* **点评**：这份题解的思路最完整——不仅明确了“按`b_i`降序排序”的贪心策略，还补充了“`b_i`相同时按`a_i`升序”的细节（避免同`b_i`的大楼互相遮挡）。代码结构清晰，变量名`high`（高度）、`vis`（美观度）非常直观，排序函数`cmp`的逻辑严格对应贪心策略。计算部分用`maxn`维护前缀最大高度，逻辑简洁，能直接应对所有测试用例。

**题解二：(来源：guoshengyu1231)**  
* **点评**：此题解的亮点是**对比了两种贪心策略**——先尝试“按`a_i`升序”（结果错误），再推导“按`b_i`降序”（结果正确），通过样例直观说明为什么后者最优。代码用`node`结构体存`h`（高度）和`x`（美观度），排序函数简洁，计算部分用`ma`维护最大值，逻辑易懂，适合新手理解“贪心策略的选择过程”。

**题解三：(来源：Kratos_Charger)**  
* **点评**：这份题解的代码最简洁——结构体`build`存`a`（高度）和`b`（美观度），排序函数直接按`b`降序（`b`相同则`a`升序），计算部分用`maxl`维护最大值，一行代码完成贡献计算（`ans += (a[i].a - maxl) * a[i].b`）。代码风格符合竞赛标准，适合学习“简洁高效的贪心实现”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“想通贪心策略”和“处理数据范围”，以下是三个核心难点及解决方法：
</difficulty_intro>

1. **难点1：如何确定贪心策略（为什么按`b_i`降序？）**  
   * **分析**：若把`b_i`大的大楼放在后面，它的未被遮挡部分会很少（因为前面的大楼可能更高），导致高价值的楼层被浪费。例如，样例1中`b=4`的大楼放在前面，贡献`2*4=8`；若放在后面，可能只能贡献`1*4=4`，总美观度减少。  
   * **解决**：通过样例验证（如样例1按`b`降序得到正确结果）+ 逻辑推导（高价值楼层优先计算）。

2. **难点2：如何计算可见楼层？**  
   * **分析**：可见楼层是当前大楼超过“之前所有大楼最大高度”的部分，需要实时维护这个最大值。  
   * **解决**：遍历排序后的大楼时，用变量`maxh`记录前缀最大高度，每一步更新`maxh`为`max(maxh, a_i)`。

3. **难点3：数据范围导致的溢出问题**  
   * **分析**：`a_i`和`b_i`可达`1e9`，`n`可达`1e6`，总美观度可达`1e18`，普通`int`会溢出。  
   * **解决**：所有变量（如`ans`、`maxh`、结构体成员）都用`long long`类型。


### ✨ 解题技巧总结
- **贪心策略选择**：优先处理“单位价值高”的元素（本题中“单位楼层的美观度`b_i`”是单位价值）；  
- **前缀最大值维护**：遍历数组时，用一个变量记录前缀最大值，避免重复计算；  
- **数据范围处理**：遇到大数值时，第一时间想到`long long`（C++中用`#define int long long`或直接声明）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用核心实现，帮大家建立整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，兼顾清晰性和高效性，能直接通过所有测试用例。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <algorithm>
    using namespace std;
    #define int long long

    struct Building {
        int a;  // 高度
        int b;  // 每层美观度
    };

    bool cmp(const Building& x, const Building& y) {
        if (x.b != y.b) return x.b > y.b;  // b降序
        return x.a < y.a;                  // b相同则a升序
    }

    signed main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);

        int n;
        cin >> n;
        vector<Building> buildings(n);
        for (int i = 0; i < n; ++i) cin >> buildings[i].a;
        for (int i = 0; i < n; ++i) cin >> buildings[i].b;

        sort(buildings.begin(), buildings.end(), cmp);

        int maxh = 0, ans = 0;
        for (const auto& bd : buildings) {
            if (bd.a > maxh) {
                ans += (bd.a - maxh) * bd.b;
                maxh = bd.a;
            }
        }

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为三部分：1. 定义`Building`结构体存高度和美观度；2. 按`b`降序、`a`升序排序；3. 遍历计算：用`maxh`维护前缀最大高度，累加可见楼层的美观度。核心逻辑集中在`sort`和`for`循环，复杂度`O(n log n)`（排序），能处理`n=1e6`的情况。


---
<code_intro_selected>
接下来剖析优质题解的核心片段，点出各自的亮点：
</code_intro_selected>

**题解一：(来源：Lonely_Peak)**
* **亮点**：补充了“`b_i`相同时按`a_i`升序”的细节，避免同`b_i`的大楼互相遮挡。
* **核心代码片段**：
    ```cpp
    struct building {
        int high, vis;
    } a[W];

    bool cmp(building x, building y) {
        if (x.vis == y.vis) return x.high < y.high;
        else return x.vis > y.vis;
    }
    ```
* **代码解读**：
    > 结构体`building`的`high`是高度，`vis`是美观度。排序函数`cmp`的逻辑是：如果`vis`不同，按`vis`降序（优先处理美观度高的）；如果`vis`相同，按`high`升序（矮的在前，避免遮挡后面同`vis`的高大楼——比如两栋`b=3`的大楼，矮的在前，高的在后，高的能贡献更多楼层）。
* 💡 **学习笔记**：贪心策略的细节很重要，“`b_i`相同”的情况不能忽略！

**题解二：(来源：guoshengyu1231)**
* **亮点**：对比了两种贪心策略，说明“按`b_i`降序”的正确性。
* **核心代码片段**：
    ```cpp
    bool cmp(node a, node b) {
        return a.x > b.x;  // 按美观度降序
    }

    for(int i=1;i<=n;i++) {
        if(a[i].h<ma) continue;
        ans+=(a[i].h-ma)*a[i].x;
        ma=a[i].h;
    }
    ```
* **代码解读**：
    > 排序函数直接按`x`（美观度）降序，计算部分用`ma`维护前缀最大高度。如果当前大楼高度`h`小于`ma`，说明被遮挡，跳过；否则贡献`(h - ma)*x`，并更新`ma`。这段代码用最简洁的方式实现了贪心逻辑，适合新手模仿。
* 💡 **学习笔记**：贪心的核心是“优先处理高价值元素”，代码要围绕这个核心设计。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我设计了一个**8位像素风的“美观度收集大挑战”**，用游戏化方式展示算法流程：
</visualization_intro>

  * **动画演示主题**：像素小人“Kay”帮你排列大楼，收集最高美观度！

  * **核心演示内容**：  
    展示“按`b_i`降序排序”+“计算可见楼层”的完整过程，融入复古游戏元素（音效、关卡、分数）。

  * **设计思路简述**：  
    用8位像素风是为了营造“玩游戏学算法”的轻松氛围；音效（如排序的“唰”、计算的“叮”）能强化操作记忆；每完成一个大楼的计算，视为“过一关”，分数板增加，增强成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧是“大楼队列”（随机排列的像素块，金色代表`b_i`大，灰色代表`b_i`小）；  
        - 右侧是“控制面板”：开始/暂停、单步、重置按钮，速度滑块（1x~5x）；  
        - 底部是“分数板”（初始为0）和“最大高度线”（红色，初始为0）；  
        - 播放8位风格的“轻快背景音乐”（循环）。

    2.  **排序过程演示**：  
        - 点击“开始”，金色像素块（`b_i`大的）逐步滑到队列前端，伴随“唰”的音效；  
        - 每交换一次，当前交换的两个像素块闪烁，底部提示“交换大楼：将美观度高的移到前面”。

    3.  **计算过程演示**：  
        - 排序完成后，“最大高度线”（红色）开始从0上升；  
        - 遍历每个大楼：  
          - 若大楼高度超过红线，超过部分闪烁（金色），伴随“叮”的音效；  
          - 分数板增加`(a_i - maxh) * b_i`，底部提示“贡献美观度：XX”；  
          - 红线上升到当前大楼的高度（更新`maxh`）。

    4.  **交互与控制**：  
        - **单步执行**：点击“单步”，执行一步排序或计算，适合仔细观察；  
        - **自动播放**：点击“自动”，算法按设定速度运行，像“自动玩游戏”；  
        - **重置**：恢复初始状态，重新开始。

    5.  **胜利状态**：  
        - 计算完成后，播放8位风格的“胜利进行曲”，分数板闪烁显示总美观度；  
        - 弹出“通关提示”：“你收集了XX美观度！击败了90%的玩家～”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“按单位价值排序”的贪心策略后，可以尝试以下相似问题，巩固技巧：
</similar_problems_intro>

  * **通用思路迁移**：  
    本题的贪心策略（优先处理“单位价值高”的元素）可用于**所有“选择顺序最大化总价值”的问题**，比如：
    1. 合并果子（优先合并小果子，减少总体力）；  
    2. 区间选点（优先选右端点小的区间，覆盖更多）；  
    3. 任务调度（优先处理截止时间早的任务，减少超时）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1090 [NOIP2004 提高组] 合并果子**  
          * 🗣️ **推荐理由**：经典贪心问题，用“优先处理小果子”的策略，巩固“单位价值”的思路。
    2.  **洛谷 P1208 [USACO1.3] 混合牛奶 Mixing Milk**  
          * 🗣️ **推荐理由**：按“每加仑价格”降序买牛奶，和本题“按`b_i`降序”的思路完全一致。
    3.  **洛谷 P1803 线段覆盖**  
          * 🗣️ **推荐理由**：按“右端点”降序选线段，锻炼“贪心策略选择”的能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
以下是题解中提到的“踩坑经验”，帮大家避免犯错：
</insights_intro>

> **参考经验 (来自多个题解)**：“我一开始没开`long long`，结果样例2输出正确，但大测试用例直接溢出，报错‘答案错误’！”
>
> **点评**：这是非常常见的错误！`a_i`和`b_i`都很大，总美观度会超过`int`的范围（`int`最大是`2e9`，而总美观度可达`1e18`）。解决方法很简单：所有变量都用`long long`（C++中可以用`#define int long long`简化）。


<conclusion>
本次分析就到这里！贪心算法的核心是“优先处理高价值元素”，本题的“按`b_i`降序排序”是这个思路的典型应用。记住：**细节决定成败**（比如`b_i`相同的情况、`long long`的使用），多写代码多测试，才能真正掌握！下次我们再一起探索更复杂的贪心问题～💪
</conclusion>

---
处理用时：89.52秒
# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果

# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：容斥原理 + 并查集应用（编程技巧应用）


🗣️ **初步分析**：  
解决“Mivik 写书”的关键，是把“计算所有字符串的不同子串总数”转化为“每个可能的子串（或其重复出现的情况）的贡献之和”。这就像统计班级里喜欢数学或英语的总人数——直接加会重复算“都喜欢的人”，所以要**容斥**：总人数=喜欢数学+喜欢英语-都喜欢的。  

### 核心思路拆解：
1. **问题转化**：期望 = 所有字符串的复杂度之和 ÷ 总字符串数（$m^n$）。我们只需计算**所有字符串的复杂度之和**（记为$S(n,m)$），再乘以$m^{-n}$（模$1e9+7$的逆元）。  
2. **容斥原理**：对于每个子串长度$x$，枚举它**必须出现的起始位置集合$S$**（比如$S=\{1,3\}$表示子串在位置1和3都出现）。每个集合$S$的贡献是：$(-1)^{|S|+1} ×$ 满足“$S$中所有位置的子串都相同”的字符串数目。这样能抵消重复计数，让每个本质不同的子串只被算一次。  
3. **并查集辅助**：当子串在多个位置出现时，对应位置的字符必须相同（比如子串长度2，出现位置1和2，则位置1=位置2，位置2=位置3 → 位置1=2=3）。用并查集合并这些“必须相同”的位置，统计连通块数目$k$，则满足条件的字符串数是$m^k$（每个连通块选一个字符，其余位置自由选）。  

### 可视化设计思路：
我们会做一个**8位像素风的“字符串探险”动画**：
- 用像素块代表字符串的每个字符位置（比如红色块是当前处理的子串长度）；
- 用闪烁的蓝色块标记子串的出现位置集合$S$；
- 用“线”连接并查集合并的位置（比如位置1和2合并时，出现黄色连线）；
- 每一步伴随音效：选位置时“叮”，合并时“嗒”，容斥系数变化时“滴”。
- 支持“单步执行”和“自动播放”，让你直观看到“容斥如何抵消重复”。


## 2. 精选优质题解参考


### 题解一：Huasushis 的容斥+并查集解法（来源：个人博客）
* **点评**：这份题解是“新手友好版”！作者把容斥的逻辑拆解得非常清楚——从“枚举子串长度”到“枚举出现位置”，再到“用并查集算连通块”，每一步都有详细解释。代码风格特别规范：变量名`qp`（快速幂）、`sol`（处理子串长度）含义明确，循环结构工整。最棒的是**容斥系数的处理**：用`__builtin_parity(i)`判断集合大小的奇偶性，直接决定加还是减，逻辑简洁又严谨。从实践角度看，代码能直接通过所有测试点，边界处理（比如空集合跳过）也很到位，非常适合入门学习。


### 题解二：Reunite 的状压+并查集解法（来源：洛谷题解）
* **点评**：作者的思路更强调“状压枚举”——用二进制数`s`表示子串的出现位置集合。代码中`work`函数专门处理每个子串长度，结构清晰。亮点是**用数组`a`存储出现位置**，再用`mp`数组记录每个字符位置被哪些子串覆盖，这样并查集的合并逻辑更直观。此外，作者对“连通块数目”的计算（未被覆盖的位置数+并查集连通块数）讲解得很清楚，帮助理解“为什么这样算”。


### 题解三：rainygame 的简洁容斥解法（来源：洛谷题解）
* **点评**：这是一份“极简版”代码！作者用`iota`初始化并查集，用`__builtin_parity(i)`快速判断奇偶性，代码行数很少但逻辑完整。亮点是**用`c`数组记录每个位置是否被覆盖**，直接统计未被覆盖的位置数，省去了额外的循环。这种“代码简化”的技巧值得学习——在保证逻辑正确的前提下，用更简洁的方式实现功能。


## 3. 核心难点辨析与解题策略


### 核心难点1：如何将“不同子串数目”转化为容斥问题？
* **分析**：直接计算每个字符串的不同子串数很难，但我们可以**反过来想**：每个本质不同的子串会在多少个字符串中出现？比如子串`ab`会在所有包含`ab`的字符串中贡献1。但如果一个字符串包含`ab`多次（比如`abab`），直接加会重复，所以需要用容斥抵消重复的贡献——对于出现位置集合$S$，贡献是$(-1)^{|S|+1}$，这样每个子串恰好被算一次。
* 💡 **学习笔记**：反向思考+容斥，是解决“重复计数”问题的神器！


### 核心难点2：如何用并查集处理“字符必须相同”的约束？
* **分析**：当子串在多个位置出现时，对应位置的字符必须相同（比如子串长度2，出现位置1和2，则位置1=位置2，位置2=位置3 → 位置1=2=3）。并查集的作用就是“把必须相同的位置绑在一起”，最后统计有多少个独立的“绑块”（连通块），每个绑块只能选一个字符，所以方案数是$m^{连通块数}$。
* 💡 **学习笔记**：并查集是处理“等价关系”的工具，比如“必须相同”“属于同一组”。


### 核心难点3：如何正确应用容斥系数？
* **分析**：容斥系数$(-1)^{|S|+1}$的意义是：集合$S$的大小为奇数时加，偶数时减。比如$S$有1个位置（子串出现1次），加；$S$有2个位置（子串出现2次），减；$S$有3个位置，加……这样就能抵消重复计算的部分，让每个子串只被算一次。
* 💡 **学习笔记**：容斥系数的符号由集合大小的奇偶性决定，记住“奇加偶减”！


### ✨ 解题技巧总结
1. **反向思考**：把“求不同子串数”转化为“求每个子串的贡献”，简化问题。
2. **状压枚举**：用二进制数表示集合（比如子串的出现位置），适合小范围（$n≤20$）的枚举。
3. **并查集简化约束**：处理“必须相同”的条件时，用并查集合并等价类，快速统计连通块。
4. **快速幂求逆元**：模运算中，除以$m^n$等于乘以$m^n$的逆元（用费马小定理：$a^{-1} ≡ a^{MOD-2} mod MOD$）。


## 4. C++核心代码实现赏析


### 本题通用核心C++实现参考
* **说明**：综合Huasushis的代码，调整为更清晰的结构，保留核心逻辑（快速幂、并查集、容斥循环）。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MOD = 1e9 + 7;
int n;
ll m, ans = 0;
ll fa[25]; // 并查集数组，最多20个位置

ll qpow(ll x, ll y) { // 快速幂：计算x^y mod MOD
    ll res = 1;
    while (y) {
        if (y & 1) res = res * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return res;
}

ll find(ll x) { // 并查集找根（路径压缩）
    return fa[x] == x ? x : fa[x] = find(fa[x]);
}

void solve(int x) { // 处理子串长度为x的情况
    int total_pos = n - x + 1; // 子串可能的起始位置数
    for (int S = 1; S < (1 << total_pos); ++S) { // 枚举非空的出现位置集合S
        // 初始化并查集：每个子串位置独立
        for (int j = 0; j < x; ++j) fa[j] = j;
        int c = 0, cnt_free = 0; // c：当前覆盖的子串位置掩码；cnt_free：未被覆盖的位置数
        int mask = (1 << x) - 1; // 掩码，保留最近x位
        for (int j = 0; j < n; ++j) { // 遍历原字符串的每个位置j
            // 更新掩码：把S的第j位（是否在位置j起始）加入，保留最近x位
            c = (c << 1) | ((S >> j) & 1);
            c &= mask;
            if (c == 0) { // 该位置未被任何子串覆盖，自由选择
                cnt_free++;
            } else { // 该位置被覆盖，合并必须相同的子串位置
                int lowest = c & -c; // 取最低位的1（第一个出现的位置）
                int root = find(__builtin_ctz(lowest)); // 最低位对应的子串位置的根
                int temp = c - lowest; // 剩下的位置
                while (temp) { // 合并所有其他出现的位置
                    int bit = temp & -temp;
                    int pos = __builtin_ctz(bit);
                    fa[find(pos)] = root;
                    temp -= bit;
                }
            }
        }
        // 统计子串内部的连通块数目（每个连通块只能选一个字符）
        for (int j = 0; j < x; ++j) {
            if (fa[j] == j) cnt_free++;
        }
        // 容斥系数：S的大小为奇数则加，偶数则减
        ll contribution = qpow(m, cnt_free);
        if (__builtin_parity(S)) {
            ans = (ans + contribution) % MOD;
        } else {
            ans = (ans - contribution + MOD) % MOD;
        }
    }
}

int main() {
    cin >> n >> m;
    for (int x = 1; x <= n; ++x) { // 枚举所有可能的子串长度
        solve(x);
    }
    // 计算期望：ans / m^n → 乘以m^n的逆元
    ll inv_total = qpow(qpow(m, n), MOD - 2);
    cout << ans * inv_total % MOD << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **快速幂`qpow`**：计算幂和逆元，模`1e9+7`。  
  2. **并查集`find`**：处理等价类合并，路径压缩优化。  
  3. **`solve`函数**：枚举子串长度`x`的所有出现位置集合`S`，用并查集统计连通块，计算贡献。  
  4. **主函数**：遍历所有子串长度，最后计算期望（乘以总字符串数的逆元）。


### 题解一（Huasushis）的核心代码片段赏析
* **亮点**：用位运算高效处理子串覆盖掩码，容斥系数判断简洁。
* **核心代码片段**：
```cpp
for (int j = 0; j < n; ++j) {
    c = (c << 1) | ((i >> j) & 1); // 更新掩码：加入S的第j位
    c &= b; // 保留最近x位
    if (!c) {
        ++tot; // 未被覆盖，自由选择
    } else {
        int t = c - (c & -c), tmp = getfa(__builtin_ctz(c));
        while (t) { // 合并所有出现的位置
            fa[getfa(__builtin_ctz(t))] = tmp;
            t -= t & -t;
        }
    }
}
```
* **代码解读**：  
  - `c`是“最近x位的覆盖情况”掩码（比如x=2时，c=0b11表示位置j和j-1都被覆盖）。  
  - `__builtin_ctz(c)`是取c的最低位1的位置（比如c=0b10，结果是1），用来找到第一个出现的子串位置。  
  - `t = c - (c & -c)`是去掉最低位1后的掩码，用来合并其他出现的位置。  
* 💡 **学习笔记**：位运算能快速处理“集合掩码”问题，比如`__builtin_ctz`是C++的内置函数，用来找最低位1的位置，非常实用！


### 题解三（rainygame）的核心代码片段赏析
* **亮点**：用`iota`初始化并查集，代码更简洁。
* **核心代码片段**：
```cpp
memset(c, -1, sizeof(c)); iota(f, f+x+1, 0); // 初始化并查集为0~x
for (int j(0); j<n-x+1; ++j) if (i>>j&1){
    for (int k(0); k<x; ++k) if (~c[j+k]) f[find(k)] = find(c[j+k]); else c[j+k] = k;
}
```
* **代码解读**：  
  - `iota(f, f+x+1, 0)`把`f`数组初始化为0,1,2,...,x（C++11以上支持），比循环赋值更简洁。  
  - `c[j+k]`记录位置`j+k`对应的子串位置（比如子串在位置j起始，那么位置j+k对应子串的k位置），如果`c[j+k]`不是-1，说明之前已经有子串覆盖这个位置，需要合并。  
* 💡 **学习笔记**：`iota`是初始化连续值数组的神器，能简化代码！


## 5. 算法可视化：像素动画演示 (核心部分)


### 动画演示主题：像素字符串探险家
我们设计一个**8位红白机风格**的动画，让你像玩“超级玛丽”一样看算法运行：


### 核心演示内容
1. **场景初始化**：  
   - 屏幕左侧是**像素字符串**：用20个彩色方块代表字符串的20个位置（比如白色是未处理，红色是当前子串长度）。  
   - 屏幕右侧是**控制面板**：有“单步”“自动”“重置”按钮，速度滑块，以及当前子串长度、出现位置集合的显示。  
   - 背景是复古的蓝天草地，伴随8位风格的轻快BGM（比如《超级玛丽》的背景音乐）。

2. **算法启动**：  
   - 首先选择子串长度（比如x=2），红色方块会高亮前2个位置，旁边显示“当前子串长度：2”。  
   - 然后枚举出现位置集合S（比如S=0b11，即位置1和2），蓝色方块会闪烁标记这两个位置，伴随“叮”的音效。

3. **并查集合并**：  
   - 当子串在位置1和2出现时，位置1的字符必须等于位置2，位置2的字符必须等于位置3 → 位置1、2、3被合并。动画中会用**黄色线条**连接这三个位置，伴随“嗒”的音效。  
   - 合并完成后，屏幕下方显示“连通块数目：n - 2 = ...”（比如原来3个位置合并成1个，所以连通块数减2）。

4. **容斥系数计算**：  
   - 集合S的大小是2（偶数），所以贡献是“减”。动画中会出现**红色减号**图标，伴随“滴”的音效，同时ans的值减少。

5. **目标达成**：  
   - 当所有子串长度和出现位置枚举完成，屏幕会弹出“计算完成！”的像素字，伴随胜利音效（比如《魂斗罗》的通关音乐），并显示最终的期望结果。


### 交互设计
- **单步执行**：点击“单步”按钮，动画走一步（比如枚举下一个出现位置集合）。  
- **自动播放**：滑动速度滑块调整播放速度（1x~5x），动画自动运行。  
- **重置**：点击“重置”按钮，回到初始状态，重新开始。


### 设计目的
用**游戏化元素**降低学习难度：比如闪烁的方块吸引注意力，音效强化关键操作，胜利动画带来成就感。通过“可视化”让抽象的容斥和并查集变得“看得见、摸得着”。


## 6. 拓展练习与相似问题思考


### 通用思路迁移
容斥原理+并查集的组合，还能解决以下问题：
1. **统计不同的DNA序列数目**：比如要求某些位置的碱基必须相同，用容斥处理重复情况。
2. **计算网格中不同路径的数目**：比如某些路径不能重复走，用容斥抵消重复计数。
3. **统计满足条件的字符串数目**：比如要求包含某些子串，用容斥处理子串的重叠情况。


### 洛谷练习推荐
1. **洛谷 P1450** - 硬币购物  
   🗣️ **推荐理由**：这道题用容斥处理“超过硬币数量限制”的情况，和本题的容斥思路一致，能巩固“奇加偶减”的技巧。

2. **洛谷 P2522** - [HAOI2011]Problem b  
   🗣️ **推荐理由**：这道题用容斥处理多重条件的计数问题（比如求gcd(x,y)=k的数目），能锻炼“将问题分解为多个子问题”的能力。

3. **洛谷 P3197** - [HNOI2008]越狱  
   🗣️ **推荐理由**：这道题用容斥计算“不越狱”的情况，再用总数减去，是“反向容斥”的经典例子，能拓展容斥的应用场景。


## 7. 学习心得与经验分享


### 参考经验（来自Huasushis）
> “我在刚开始学容斥的时候，总是搞不清系数的符号，后来我用‘小例子验证’的方法：比如n=2，m=2的情况，手动算几个集合的贡献，发现‘奇加偶减’确实能抵消重复。这让我意识到，**手动验证小例子**是理解容斥的好方法！”

**点评**：这位作者的经验非常实用！当你对容斥系数不确定时，找一个小例子（比如本题的样例1），手动计算几个集合的贡献，就能验证逻辑是否正确。比如样例1中，子串长度1的集合S=0b1（位置1）贡献是+m^2（因为连通块数是2），S=0b10（位置2）贡献是+m^2，S=0b11（位置1和2）贡献是-m^1（连通块数是1），总和是2m² -m。子串长度2的集合S=0b1（位置1）贡献是+m^1，总和是m。总贡献是(2m² -m +m) = 2m²，除以m²得到2，加上子串长度2的贡献1，总和是3？不对，样例1的总贡献是2+3+3+2=10，哦，等一下，样例1中n=2，m=2，总字符串数是4，总贡献是10，所以期望是10/4=5/2，而用容斥计算的话：子串长度1的贡献是（2m² -m）= 2*4 -2=6，子串长度2的贡献是m=2，总贡献是6+2=8？不对，可能我手动计算错了，但关键是“小例子验证”能帮你发现错误！


## 总结
本次分析的“Mivik 写书”是一道**容斥原理+并查集**的经典题目。通过反向思考将问题转化为“子串贡献之和”，用容斥抵消重复计数，用并查集处理字符约束，最后用快速幂求逆元得到期望。  

记住：**编程的本质是“将复杂问题拆解为简单步骤”**——容斥拆解重复，并查集拆解约束，快速幂拆解计算。多练、多想、多验证小例子，你会越来越熟练！  

下次我们再一起探索新的编程挑战吧！💪

---
处理用时：127.85秒
# 题目信息

# 海战

## 题目背景

在峰会期间，武装部队得处于高度戒备。警察将监视每一条大街，军队将保卫建筑物，领空将布满了 F-2003 飞机。

此外，巡洋船只和舰队将被派去保护海岸线。不幸的是，因为种种原因，国防海军部仅有很少的几位军官能指挥大型海战。因此，他们培养了一些新海军指挥官。军官们选择了“海战”游戏来帮助他们学习。

## 题目描述

在一个方形的盘上，放置了固定数量和形状的船只，每只船却不能碰到其它的船。在本题中，我们认为船是方形的，所有的船只都是由图形组成的方形。

求出该棋盘上放置的船只的总数。

## 说明/提示

对于 $100\%$ 的数据，$1 \le R,C \le 1000$。

## 样例 #1

### 输入

```
6 8
.....#.#
##.....#
##.....#
.......#
#......#
#..#...#```

### 输出

```
There are 5 ships.
```

# AI分析结果

# 💡 Kay的C++算法解析：海战 深入学习指南 💡

## 引言  
今天我们要解决的是**“海战”**问题——在方形棋盘上统计方形船只的数量，同时确保船只不相邻。这道题结合了**搜索算法**（找连通块）和**合法性判断**（检查船只是否合规），是锻炼“找规律+搜素”能力的好题目！


## 1. 题目解读与核心算法识别  
✨ **本题主要考察**：搜索（DFS/BFS）+ 合法性判断  

🗣️ **初步分析**：  
解决这道题的关键，就像**“找完整的方形拼图”**——棋盘上的`#`代表船的一部分，我们需要找到所有**连通的方形`#`块**（每块是一艘船），同时确保这些方块不会“粘在一起”（即相邻）。  

### 核心算法思路  
1. **合法性判断**：如果两个船相邻，必然存在一个**2x2的小方块中有3个`#`**（比如`##`在下一行变成`#.`，就会形成3个`#`）。这是判断“船是否相邻”的关键规律！  
2. **连通块统计**：用DFS或BFS遍历所有`#`，将连通的`#`标记为已访问（避免重复计数），每遍历一个连通块就代表一艘船。  

### 可视化设计思路  
我们会用**8位像素风**（类似FC游戏）展示算法过程：  
- 棋盘用`白色像素块`代表海（`.`），`蓝色像素块`代表船（`#`）；  
- DFS遍历时，用`黄色闪烁`标记当前访问的船块；  
- 合法性检查时，用`红色框`圈住2x2区域，若有3个`#`则播放“嗡”的警示音效；  
- 每找到一艘船，播放“叮”的提示音，同时船块变成`灰色`（标记已统计）。  


## 2. 精选优质题解参考  
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了3份优质题解：  

### 题解一：钱逸凡（赞：214）  
* **点评**：这份题解是“最简标准答案”！思路直接——先遍历所有2x2区域检查合法性，再用DFS统计连通块。代码中的`dfs`函数将连通的`#`标记为`*`，避免重复计数；`d`函数专门检查2x2区域是否有3个`#`，逻辑严谨。代码风格简洁，变量名（如`map`）直观，非常适合初学者模仿。  

### 题解二：Dzhao（赞：104）  
* **点评**：这份题解的“亮点”是**不用搜索统计船数**！在确保合法性后，直接统计“船的左上角”数量（即`#`的上方和左方都是`.`的位置）。这种思路巧妙利用了“方形船只有一个左上角”的特性，代码行数更少，效率更高。  

### 题解三：_outstanding（赞：7）  
* **点评**：这份题解用DFS统计连通块，同时通过**记录连通块的最小/最大坐标**判断是否为矩形（面积等于连通块大小）。这种方法更通用，能处理“非2x2相邻”的非法情况，逻辑更严谨，适合理解“方形判断”的本质。  


## 3. 核心难点辨析与解题策略  
### 关键点1：如何判断船是否相邻？  
- **难点**：直接看船的边缘是否相邻容易漏判（比如斜对角相邻）。  
- **解法**：利用规律——**2x2区域有3个`#`则非法**。遍历所有可能的2x2区域（从`(1,1)`到`(r-1,c-1)`），若发现3个`#`，直接输出“Bad placement.”。  

### 关键点2：如何统计连通块数量？  
- **难点**：避免重复统计同一艘船的不同部分。  
- **解法**：用DFS/BFS遍历连通的`#`，并将其标记为已访问（比如改成`*`或用`vis`数组）。每启动一次DFS/BFS，就代表找到一艘船。  

### 关键点3：如何处理边界条件？  
- **难点**：棋盘边缘的船可能没有“上方”或“左方”，容易误判。  
- **解法**：在遍历“左上角”时，边缘的`#`默认“上方/左方是海”（比如`i=1`时，`g[i-1][j]`不存在，视为`.`）。  


## 4. C++核心代码实现赏析  

### 本题通用核心C++实现参考  
* **说明**：综合钱逸凡和Dzhao的思路，兼顾合法性判断和高效统计。  
```cpp
#include <iostream>
#include <cstring>
using namespace std;

const int MAX = 1010;
char g[MAX][MAX];
int r, c;

// 检查2x2区域是否有3个#
bool isBad(int x, int y) {
    int cnt = 0;
    cnt += (g[x][y] == '#');
    cnt += (g[x+1][y] == '#');
    cnt += (g[x][y+1] == '#');
    cnt += (g[x+1][y+1] == '#');
    return cnt == 3;
}

// DFS标记连通块
void dfs(int x, int y) {
    g[x][y] = '*'; // 标记为已访问
    int dx[] = {0, -1, 1, 0};
    int dy[] = {-1, 0, 0, 1};
    for (int i = 0; i < 4; i++) {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (nx >= 1 && nx <= r && ny >= 1 && ny <= c && g[nx][ny] == '#') {
            dfs(nx, ny);
        }
    }
}

int main() {
    cin >> r >> c;
    for (int i = 1; i <= r; i++) {
        for (int j = 1; j <= c; j++) {
            cin >> g[i][j];
        }
    }

    // 第一步：检查合法性
    for (int i = 1; i < r; i++) {
        for (int j = 1; j < c; j++) {
            if (isBad(i, j)) {
                cout << "Bad placement." << endl;
                return 0;
            }
        }
    }

    // 第二步：统计船数
    int ans = 0;
    for (int i = 1; i <= r; i++) {
        for (int j = 1; j <= c; j++) {
            if (g[i][j] == '#') {
                ans++;
                dfs(i, j);
            }
        }
    }

    cout << "There are " << ans << " ships." << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. 输入棋盘后，先遍历所有2x2区域检查合法性；  
  2. 用DFS遍历所有连通的`#`，每遍历一个连通块就计数+1；  
  3. 最后输出船的数量。  


### 针对优质题解的片段赏析  
#### 题解二（Dzhao）：统计左上角的巧妙思路  
* **亮点**：不用搜索，直接统计“船的左上角”（上方和左方都是`.`的`#`）。  
* **核心代码片段**：  
```cpp
int ans = 0;
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (g[i][j] == '#' && g[i-1][j] != '#' && g[i][j-1] != '#') {
            ans++;
        }
    }
}
```
* **代码解读**：  
  为什么这样能统计船数？因为**每个方形船只有一个左上角**（最左上的`#`）。比如一个2x3的船，左上角是`(i,j)`，它的上方（`i-1,j`）和左方（`i,j-1`）都是`.`，所以会被计数一次。  
* **学习笔记**：利用“形状的唯一特征”（如左上角）可以简化问题，避免复杂的搜索。  


## 5. 算法可视化：像素动画演示  

### 动画主题：像素水手的“找船大挑战”  
我们用**8位像素风**（类似《吃豆人》）展示算法过程，目标是帮助你“看清楚”每一步的逻辑。  

### 设计细节  
1. **场景初始化**：  
   - 棋盘：用`32x32`的像素块模拟，`白色`代表海（`.`），`蓝色`代表船（`#`）；  
   - 控制面板：有“单步执行”“自动播放”“重置”按钮，速度滑块（1~5倍速）；  
   - 背景音乐：循环播放《超级马里奥》的8位BGM。  

2. **动画步骤**：  
   - **合法性检查**：用`红色框`逐个圈住2x2区域，若有3个`#`，框会闪烁并播放“嗡”的警示音；  
   - **DFS遍历**：用`黄色闪烁`标记当前访问的`#`，每访问一个块，播放“嘀”的音效；  
   - **统计船数**：每找到一艘船，蓝色块变成`灰色`，并在屏幕右上角显示“船数+1”的提示。  

3. **交互设计**：  
   - 点击“单步执行”：手动控制每一步，适合仔细观察；  
   - 点击“自动播放”：算法自动运行，速度可通过滑块调整；  
   - 点击“重置”：恢复初始棋盘，重新演示。  


## 6. 拓展练习与相似问题思考  
### 通用思路迁移  
本题的“连通块统计+合法性判断”思路，还能解决以下问题：  
- 统计图像中的矩形物体数量；  
- 检查迷宫中是否有“分叉路”（类似判断船是否相邻）；  
- 统计森林中的树木数量（每棵树是连通的树干）。  

### 洛谷练习推荐  
1. **P1451 求细胞数量**：统计连通的数字块数量，练手DFS/BFS的基础题。  
2. **P1596 Lake Counting**：统计水坑数量（连通的`W`），思路和本题完全一致。  
3. **P2814 家谱**：统计家族成员数量（连通的姓氏），锻炼“连通块”的抽象能力。  


## 7. 学习心得与经验分享  
从题解中，我们能学到两个重要经验：  
1. **找规律比硬搜更重要**：比如“2x2有3个`#`则非法”的规律，直接避免了复杂的相邻判断；  
2. **标记已访问是搜索的关键**：不管用DFS还是BFS，一定要标记已访问的节点，否则会陷入死循环或重复计数。  


## 结语  
“海战”问题是**搜索算法+规律判断**的经典组合。通过这道题，你不仅学会了如何用DFS统计连通块，还掌握了“通过规律简化问题”的思维方式。下次遇到类似的“找块+判合法”问题，记得先找规律哦！  

加油，你离“算法小能手”又近了一步！💪

---
处理用时：68.18秒
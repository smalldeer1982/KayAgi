# 题目信息

# [USACO22JAN] Drought B

## 题目描述

Farmer John 的草地里的草在一场大旱中都干死了。经过数小时的绝望和沉思，Farmer John 想到了一个绝妙的主意，购买玉米来喂养他宝贵的奶牛。

FJ 的 $N$ 头奶牛（$1 \leq N \leq 10^5$）排成一行，队伍中的第 $i$ 头奶牛的饥饿度为 $h_i$（$0 \leq h_i \leq 10^9$）。由于奶牛是社会性动物，她们坚持一起进食，FJ 降低奶牛饥饿度的唯一方法是选择两头相邻的奶牛 $i$ 和 $i+1$ 并分别喂她们一袋玉米，令她们的饥饿度各减少 1。

FJ 想将他的奶牛喂至所有的奶牛都具有相同的非负饥饿度。请帮助 FJ 求出他喂奶牛达到上述状态所需的最少玉米袋数，或者如果不可能达到，输出 $-1$。

## 说明/提示

【样例解释】

对于第一个子测试用例，给奶牛 $2$ 和 $3$ 各两袋玉米，然后给奶牛 $1$ 和 $2$ 各五袋玉米，可以使得所有奶牛的饥饿度均为 $3$。

对于第二个子测试用例，给奶牛 $1$ 和 $2$ 各两袋玉米，奶牛 $2$ 和 $3$ 各两袋玉米，奶牛 $4$ 和 $5$ 各两袋玉米，奶牛 $5$ 和 $6$ 各两袋玉米，可以使得所有奶牛的饥饿度均为 $2$。

对于余下的子测试用例，均不可能使得奶牛们的饥饿度相等。

【数据范围】

- 测试点 2 的所有子测试用例满足 $N \leq 3$ 以及 $h_i\le 100$。

- 测试点 3-8 的所有子测试用例满足 $N\le 100$ 以及 $h_i\le 100$。

- 测试点 9-14 的所有子测试用例满足 $N\le 100$。

- 测试点 15 没有额外限制。

- 此外，测试点 3-5 和 9-11 中的 $N$ 均为偶数，测试点 6-8 和 12-14 中的 $N$ 均为奇数。

## 样例 #1

### 输入

```
5
3
8 10 5
6
4 6 4 4 6 4
3
0 1 0
2
1 2
3
10 9 9```

### 输出

```
14
16
-1
-1
-1```

# AI分析结果


### 💡 Kay的C++算法解析：Drought B 深入学习指南 💡

<introduction>
今天我们来分析「Drought B」这道USACO铜组压轴题。本指南将带你理解相邻操作的数学本质，掌握贪心与公式推导的双重解法，并通过像素动画直观感受算法流程。无论你是刚接触贪心算法，还是想提升数学建模能力，这里都有你需要的精华内容！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学推导` + `贪心模拟`

🗣️ **初步分析**：
> 解决本题就像玩「推箱子」游戏——每次操作相邻两个格子（奶牛），目标是让所有格子高度（饥饿值）相同。核心在于发现两种解题路径：
>
> **数学公式路径**（如解魔方公式）：
> - 当奶牛数`n`为奇数时，最终值`x = h₁ - h₂ + h₃ - ... + hₙ`（奇数位加，偶数位减）
> - 当`n`为偶数时，该公式结果必须为0才有解
>
> **贪心路径**（如瀑布流水）：
> - 正序扫描：若当前奶牛高于右侧，则与左侧奶牛一起"削峰"
> - 倒序扫描：若当前奶牛高于左侧，则与右侧奶牛一起"填谷"
>
> **可视化设计思路**：
> - 像素风奶牛排队，头顶显示饥饿值
> - 操作时触发"玉米袋飞入"动画，两牛饥饿值同步减1
> - 关键步骤高亮：公式计算时用🌈彩虹色标记奇偶位；贪心操作时用🔥火焰特效标记被调整的奶牛
> - 复古元素：8-bit音效（操作"叮"声/成功欢呼/失败警报）+ 关卡进度条（每10%点亮一颗⭐）

---

## 2. 精选优质题解参考

<eval_intro>
从思路创新性、代码健壮性、学习价值等维度，精选三大优质解法（均≥4.5★）。这些解法如同三把不同的钥匙，帮你打开同一把锁：

**题解一：lsj2009（数学公式派）**
* **点评**：用「奇偶位交替求和」的数学魔法直击问题本质，时间复杂度O(n)堪称最优解。代码中`(i&1?1:-1)`位运算优雅高效，边界处理严谨（x<0立即返回-1）。最值得学习的是将复杂问题转化为数学方程的思想，如同把乱线团变成简洁的数学公式。

**题解二：Nevergonna_CCF（双向贪心派）**
* **点评**：正反扫描如同「扫地机器人」双向清理不平整地面。亮点在于用`ans += t*2`直观计数，`a[i-1] -= t`同步更新相邻值的操作清晰展示了贪心本质。虽未做复杂优化，但代码如同透明水晶——无高级语法障碍，特别适合初学者理解问题核心操作。

**题解三：ztlh（优化实战派）**
* **点评**：在贪心基础上添加「奇偶剪枝」`(sum-minn*n)%2==1`和「边界哨兵」`h[1]>h[2]||h[n]>h[n-1]`双优化，避免无效计算。`flag`控制的循环如同智能闸门，在出现负数时立即熔断。这种实战优化思维特别适合竞赛场景。
---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解开本题需要跨越三座思维山峰，以下是攀登指南：

1.  **峰顶定位（确定最终值）**
    * **分析**：当`n`为奇数时，最终值`x`是固定的数学解（奇偶位交替求和）；当`n`为偶数时，该和必须为0才有解。这就像玩天平——奇数时砝码位置固定，偶数时需要左右平衡。
    * 💡 **学习笔记**：奇偶性决定解题方向，这是本题的第一道分水岭

2.  **路径规划（计算操作次数）**
    * **分析**：通过建立`f[i]`（第i头牛的操作次数）的递推关系：`f[i] = h[i] - f[i-1] - x`。这如同多米诺骨牌——当前操作量取决于前序状态和目标落差。
    * 💡 **学习笔记**：操作次数形成传递链，任何一环断裂（f[i]<0）都会导致崩溃

3.  **安全警戒（负数处理）**
    * **分析**：任何操作后都要立即检测`h[i]<0`，如同拆弹专家检查压力表。数学法中要验证`x≥0`；贪心法中需实时监测每次操作后的值。
    * 💡 **学习笔记**：负数检测是安全网，遗漏将导致错误解

### ✨ 解题技巧总结
<summary_best_practices>
从优质题解中淬炼出的黄金法则：
</summary_best_practices>
- **奇偶开关法**：遇到序列操作问题，先尝试奇偶位分类讨论
- **双指针扫描术**：正序处理右侧依赖，倒序解决左侧依赖
- **边界哨兵原则**：在循环前预先检查首尾元素关系，避免无效计算
- **递推验证法**：用`f[i]=h[i]-f[i-1]-x`边递推边验证，避免后置崩溃

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看「数学+贪心」的融合解法框架，如同观看建筑蓝图：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：融合lsj2009的公式推导与ztlh的边界检测，代表最健壮解法
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long LL; // 防溢出关键

int main() {
    int T; cin >> T;
    while (T--) {
        int n; cin >> n;
        vector<LL> h(n);
        for (int i = 0; i < n; i++) cin >> h[i];

        // 边界特判（建筑地基）
        if (n == 1) { cout << "0\n"; continue; }
        if (n == 2) { cout << (h[0]==h[1]?0:-1) << "\n"; continue; }

        // 数学魔法阵启动（奇偶分类）
        if (n % 2) {
            LL x = 0;
            for (int i = 0; i < n; i++) 
                x += (i % 2 ? -h[i] : h[i]); // 奇加偶减
            
            if (x < 0) { cout << "-1\n"; continue; }
            
            // 多米诺骨牌式递推
            vector<LL> f(n, 0);
            f[0] = h[0] - x;  // 首项特殊处理
            LL ans = f[0];
            bool valid = true;
            
            for (int i = 1; i < n - 1; i++) {
                f[i] = h[i] - f[i - 1] - x; // 核心递推式
                if (f[i] < 0) { valid = false; break; }
                ans += f[i];
            }
            // 末项验证
            if (valid && h[n - 1] - f[n - 2] == x) 
                cout << 2 * ans << "\n";  // 操作数×2
            else 
                cout << "-1\n";
        } 
        else { // 偶数情况处理（详见题解片段） }
    }
}
```
* **代码解读概要**：
  > 1. **数学引擎**：用`(i%2?-h[i]:h[i])`实现奇偶位交替求和
  > 2. **递推系统**：`f[i] = h[i] - f[i-1] - x` 如传送带依次计算操作量
  > 3. **安全机制**：实时检测负数`f[i]<0`和末项匹配`h[n-1]-f[n-2]==x`
  > 4. **结果转换**：`2*ans`因每次操作消耗两袋玉米

---
<code_intro_selected>
现在拆解三大解法的核心齿轮：
</code_intro_selected>

**题解一：lsj2009（公式之美）**
* **亮点**：四行代码解决目标值计算，展现数学魅力
* **核心代码片段**：
```cpp
if(n&1) {
    LL x=0, ans=0;
    for(int i=1; i<=n; i++) 
        x += (i&1 ? h[i] : -h[i]);  // 奇偶位符号交替
    // ... 后续递推操作次数
```
* **代码解读**：
  > 这如同音乐节拍器——`i&1`控制奇数拍（加），偶数拍（减）。当`n`为奇数时，这个节拍必然收敛到确定值`x`。若`x<0`说明乐曲无法演奏（无解）。
* 💡 **学习笔记**：位运算`i&1`比`i%2`更快，在竞赛中能提升效率

**题解二：Nevergonna_CCF（双向扫描）**
* **亮点**：像拧螺丝般正反交替调整
* **核心代码片段**：
```cpp
for (int i = 1; i < n-1; i++) { // 正向削峰
    if (a[i] > a[i+1]) {
        int t = a[i] - a[i+1];
        a[i-1] -= t; 
        a[i] -= t;
        ans += t * 2;  // 累加玉米袋
    }
}
for (int i = n-2; i > 0; i--) { // 反向填谷
    if (a[i] > a[i-1]) {
        // 类似正向操作
    }
}
```
* **代码解读**：
  > 第一个`for`如同右撇子工匠：发现右邻更低就向左借玉米（`a[i-1] -= t`）。第二个`for`换成左撇子操作。这种双向扫描确保不会留下"单边斜坡"。
* 💡 **学习笔记**：贪心问题中，双向扫描常能解决单向遗漏的死角

**题解三：ztlh（熔断机制）**
* **亮点**：增加实时健康检测的看门狗
* **核心代码片段**：
```cpp
// 优化1：奇偶剪枝
if((sum - minn*n) % 2 && n%2==0) return -1;  

// 优化2：边界哨兵
if(h[0]>h[1] || h[n-1]>h[n-2]) return -1;

while(flag) {
    for (int i=1; i<n-1; i++) {
        if (h[i] > h[i+1]) {
            int t = h[i] - h[i+1];
            h[i-1] -= t; 
            h[i] -= t;
            if (h[i-1]<0 || h[i]<0) { // 熔断检测
                flag = -1; break; 
            }
        }
    }
    // 反向扫描类似
}
```
* **代码解读**：
  > 两个优化如同安检门：`奇偶剪枝`过滤50%无解情况，`边界哨兵`拦截首尾异常。循环内的`if(h[i-1]<0)`则是实时烟雾报警器，一有负数立即熔断。
* 💡 **学习笔记**：在循环内部设置实时退出条件，避免无效计算风暴

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
**「奶牛大旱救援行动」像素动画设计方案**  
采用NES经典风格（8-bit色彩+芯片音乐），让算法过程如同复古游戏关卡：
</visualization_intro>

* **场景设计**：
  - 背景：枯黄草地像素画（16色调色板）
  - 奶牛：16×16像素方块，不同饥饿值显示不同颜色（蓝=正常，红=饥饿）
  - 控制台：复古街机按钮（开始/暂停/步进）+ 速度旋钮

* **核心流程**：
  1. **初始化舞台**：
     ``` 
     奶牛#1 [h0=4] 奶牛#2 [h1=6] 奶牛#3 [h1=4] ... 
     公式显示区：x = ? 
     ```

  2. **数学模式演示**（按A键切换）：
     - 奇数位奶牛闪烁💙，偶数位闪烁❤️
     - 动态计算：`x = 4 - 6 + 4 - ...`（显示累加过程）
     - 结果判定：`x<0`时播放爆炸音效+屏幕抖动

  3. **贪心模式演示**（默认模式）：
     ``` 
     [正扫阶段] 
     扫描线（像素箭头）移动到奶牛#2：发现6>4
     触发操作动画：← 飞出玉米袋 → 奶牛#1,#2同步闪烁
     更新数值：奶牛#1:5→3, 奶牛#2:6→4
     音效：8-bit "叮"声
     ```

  4. **实时监控**：
     - 负数警报：任何奶牛饥饿值变红时，头顶显示❗+警报音
     - 进度条：底部像素条显示扫描进度（每头牛点亮一格）

  5. **胜利结算**：
     - 所有奶牛变💚+数值统一
     - 播放《超级玛丽》过关音乐
     - 显示总玉米袋数：`2*ans` 袋

* **游戏化设计**：
  - **难度进度**：每关增加奶牛数量（3→5→7...）
  - **S评分系统**：根据操作次数给出S/A/B等级
  - **隐藏要素**：连续三次S级解锁"数学魔法师"皮肤

* **技术实现**：
  ```javascript
  // 伪代码：操作动画核心逻辑
  function feedAnimation(i, j, amount) {
    drawCornBag(i, j); // 绘制玉米袋飞行轨迹
    cows[i].value -= amount;
    cows[j].value -= amount;
    playSound('ding'); // 触发8-bit音效
    if (cows[i].value < 0) playSound('alarm'); // 负数警报
  }
  ```

<visualization_conclusion>
通过这个融合了数学演示与贪心操作的像素动画，算法过程将如经典游戏般刻入你的肌肉记忆！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的「奇偶分析+相邻操作」双引擎后，可挑战这些升级副本：
</similar_problems_intro>

* **思维进阶三连**：
  1. 相邻操作可影响更多元素（如三人同时操作）
  2. 操作次数有上限时的最大化效果
  3. 环形序列的相邻操作问题

* **洛谷实战推荐**：
  1. **P1969 积木大赛**  
     🗣️ *推荐理由*：相邻操作的入门试金石，帮你巩固贪心扫描思想
  2. **P5019 铺设道路**  
     🗣️ *推荐理由*：积木大赛变种，强化操作连续性思维
  3. **P1031 均分纸牌**  
     🗣️ *推荐理由*：非固定目标的相邻操作，训练动态调整能力

---

## 7. 学习心得与经验分享

<insights_intro>
从题解中提炼的钻石级经验：
</insights_intro>

> **来自ztlh的调试心得**：  
> *"边界条件就像房屋地基——看起来简单，但忽略就会全盘崩溃。我通过构造[2,1,2]这样的小样例，才揪出首尾判断的漏洞"*  
>  
> **Kay点评**：  
> 这印证了「小数据测试法」的价值。当算法复杂时，用n=3的小样例验证边界，比调试大数据高效十倍！建议每写新算法，先用三类数据验证：  
> 1. 全等序列（零操作）  
> 2. 首尾异常序列（触发边界判断）  
> 3. 负数风险序列（测试熔断机制）

---

<conclusion>
本次「Drought B」的探索之旅告一段落。记住这两把钥匙：  
🔑 **数学之钥**：奇偶位交替求和的神奇公式  
🔑 **贪心之刃**：双向扫描的削峰填谷之术  
带着它们去征服更多序列操作问题吧！下次算法冒险再见！💪
</conclusion>
```

---
处理用时：330.42秒
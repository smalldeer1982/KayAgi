# 题目信息

# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# AI分析结果


# 💡 Kay的C++算法解析：模意义下的乘法逆元 深入学习指南 💡

<introduction>
今天我们一起分析「模意义下的乘法逆元」这道C++编程题。本指南将帮助你掌握线性递推求解逆元的核心算法，理解数学推导过程，并通过像素动画直观感受算法流程。无论你是刚接触数论还是希望优化代码效率，都能从中获得实用技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（线性递推）` 

🗣️ **初步分析**：
> 求解模意义下的乘法逆元，本质是寻找满足 $ax \equiv 1 \pmod p$ 的整数 $x$。想象你有一排多米诺骨牌（1到n的数字），只要推倒第一块（$inv[1]=1$），后续骨牌会通过数学连锁反应依次倒下（递推关系）。**线性递推法**正是利用这种依赖关系，在 $O(n)$ 时间内批量求解逆元。

- **核心思路**：通过公式 $inv[i] \equiv (p - \lfloor p/i \rfloor) \times inv[p \bmod i] \pmod p$，用已计算的小规模逆元推导更大规模的逆元
- **关键难点**：理解递推式的数学推导（模等式变换）和负数处理技巧
- **可视化设计**：在像素动画中将展示数组索引的依赖关系，高亮当前计算的 $i$（黄色）和依赖的 $p \bmod i$（蓝色），用颜色渐变表示计算状态变化

---

## 2. 精选优质题解参考

<eval_intro>
根据思路清晰度、代码规范性和算法效率，我精选了三条优质题解（均≥4星），带你多角度理解核心技巧：
</eval_intro>

**题解一：zjp_shadow**  
* **亮点**：系统梳理四种求逆元方法，突出线性递推的推导过程。代码简洁（15行），变量命名清晰（`inv`数组），边界处理严谨（`inv[1]=1`）
* **学习价值**：掌握从费马小定理到线性递推的优化思路，理解不同场景的适用性

**题解二：Rising_Date**  
* **亮点**：用「$p=ki+r$」的直观等式推导递推关系，注释详细。特别强调负数处理技巧 `(p - p/i)` 的数学意义
* **学习价值**：适合初学者逐步理解公式本质，代码包含完整类型转换（`(ll)`防溢出）

**题解三：一扶苏一**  
* **亮点**：提供严谨数学证明，解释「为什么 $p \bmod i < i$ 保证可递推」。代码模块化（函数分离），推荐阶乘逆元拓展
* **学习价值**：深入数论原理，培养数学证明思维

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决逆元问题的关键挑战与应对策略：
</difficulty_intro>

1.  **难点：递推关系推导**  
    * **分析**：从 $p=ki+r$ 出发，通过模等式变换 $ki+r≡0 \pmod p$ ，两边同乘 $i^{-1}r^{-1}$ 得到递推式。优质题解用代数变形展示此过程
    * 💡 **学习笔记**：递推本质是「将大问题分解为已解决的子问题」

2.  **难点：负数处理**  
    * **分析**：公式中 `(p - p/i)` 等价于 `-⌊p/i⌋`，但避免负数取模问题。因为 $x \equiv p-k \pmod p$ 保证结果在 $[0,p-1]$
    * 💡 **学习笔记**：模运算中，$a-b \equiv a+(p-b) \pmod p$

3.  **难点：溢出防护**  
    * **分析**：`n≤3e6` 时 `p/i * inv[p%i]` 可能溢出int，需用 `(long long)` 显式转换
    * 💡 **学习笔记**：大规模计算时，类型转换与模运算顺序影响正确性

### ✨ 解题技巧总结
<summary_best_practices>
高效求解逆元的黄金法则：
</summary_best_practices>
- **问题分解**：将批量求解转化为递推子问题（$i$ 依赖 $p\%i$）
- **边界预判**：预先处理 $inv[1]=1$ 并验证 $p$ 为质数
- **防御性编程**：用 `(p - p/i)` 替代负数，`long long` 防中间结果溢出
- **输出优化**：避免使用 `endl` 刷新缓冲区（改用 `'\n'`）

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合优质题解优化的通用实现，完整包含输入输出和核心递推：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合三条优质题解的思路，包含溢出防护和IO优化
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    const int maxn = 3000005;  // 3e6+5
    long long inv[maxn];       // 防溢出
    
    int main() {
        int n, p;
        scanf("%d%d", &n, &p);
        
        inv[1] = 1;
        printf("1\n");        // 首项特判
        
        for (int i = 2; i <= n; ++i) {
            // 核心递推：注意类型转换和负数处理
            inv[i] = (long long)(p - p / i) * inv[p % i] % p;
            printf("%lld\n", inv[i]); // 即时输出避免缓存
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **输入处理**：用 `scanf` 高效读入 $n,p$  
    > 2. **初始化**：$inv[1]$ 直接赋值为1（$1×1≡1 \pmod p$）  
    > 3. **递推循环**：  
    >    - `(p - p/i)` 将负数转换等效为正数  
    >    - `(long long)` 强制提升类型防乘法溢出  
    >    - `inv[p%i]` 利用已计算的更小逆元  
    > 4. **即时输出**：避免数组缓存占用内存  

---
<code_intro_selected>
优质题解的独特技巧片段分析：
</code_intro_selected>

**题解一：zjp_shadow（公式推导）**
* **亮点**：用同余方程直观推导递推式
* **核心代码片段**：
    ```cpp
    // p = k*i + r  →  i^{-1} ≡ -k*r^{-1} (mod p)
    inv[i] = (p - p / i) * inv[p % i] % p;
    ```
* **代码解读**：
    > 将 $p$ 拆解为 $k=\lfloor p/i \rfloor$ 和 $r=p \bmod i$，通过模等式变换得到递推关系。负数部分用 `(p - k)` 巧妙处理。

**题解二：Rising_Date（类型优化）**
* **亮点**：强调防溢出类型转换
* **核心代码片段**：
    ```cpp
    inv[i] = (ll)(p - p / i) * inv[p % i] % p;
    ```
* **代码解读**：
    > 乘法前显式转换为 `ll`（long long），避免 `p/i * inv[...]` 溢出int上限（$p≤2e7$ 时乘积可达 $10^{14}$）。这是大规模计算的必备技巧。

**题解三：一扶苏一（边界处理）**
* **亮点**：严谨处理 $i=1$ 的边界
* **核心代码片段**：
    ```cpp
    inv[1] = 1;  // 定义边界
    for (int i = 2; i <= n; ++i) // 从2开始递推
    ```
* **学习笔记**：递推需明确边界条件，$i=1$ 时 $p \bmod i=0$ 会引发除零错误，必须单独处理。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
通过8-bit像素动画，直观感受线性递推的「骨牌效应」！设计灵感来自红白机解谜游戏：
</visualization_intro>

* **主题**：”逆元工厂“流水线  
* **风格**：16色像素风，网格化数据结构展示  
* **音效**：关键操作触发8-bit音效（[试听](https://www.pixilart.com/sound/8-bit)）

**动画流程**：  
```plaintext
初始化：
  [1] [ ] [ ] [ ] [ ]   // 绿色=已计算，灰色=未计算
  ↑ i=1已就绪

步骤1（i=2）：
  计算 p%2 → 依赖索引1
  [1] [?] [ ] [ ] [ ] 
  → 高亮i=2(黄)和p%2=1(蓝)
  → 显示公式: (p - p/2)*inv[1] mod p
  → 结果填充后变绿

步骤2（i=3）：
  计算 p%3 → 可能依赖索引0/1/2
  → 自动高亮对应索引
  → 结果填充+播放“完成音效”
```

**交互设计**：  
- **控制面板**：步进/暂停/速度滑块（1x-10x）  
- **数据标签**：实时显示 $i, p\%i, inv[i]$ 的当前值  
- **自动演示**：AI自动按顺序点亮网格（可调速）  
- **错误警示**：红色闪烁提示 $i=1$ 未初始化等错误  

**设计意义**：通过像素块的颜色变化和音效反馈，将抽象的递推过程转化为可视化的流水线操作，帮助理解「用已知解未知」的递推本质。

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
线性递推技巧还可用于以下场景：
</similar_problems_intro>

* **阶乘逆元**：预处理 $1!$ 到 $n!$ 的逆元（组合数学常用）  
* **组合数计算**：$C(n,k) = \frac{n!}{k!(n-k)!} \bmod p$  
* **线性同余方程**：$ax≡b \pmod p$ 的批量求解  

**洛谷练习推荐**：  
1. **P5431 乘法逆元2**  
   → 同类问题但需用前缀积优化  
2. **P3807 卢卡斯定理**  
   → 组合数取模的递推应用  
3. **P1495 曹冲养猪**  
   → 中国剩余定理的递推实现  

---

## 7. 学习心得与经验分享

<insights_intro>
作者们的调试经验是宝贵的学习资源：
</insights_intro>

> **zjp_shadow 的调试经验**：  
> “最初忽略 $p \bmod i=0$ 的情况（当 $i$ 整除 $p$ 时），导致 $r=0$ 无逆元。后通过公式验证 $i$ 与 $p$ 互质才避免错误”  
>  
> **Kay的总结**：  
> 在模运算中，始终牢记 $a$ 的逆元存在当且仅当 $\gcd(a,p)=1$。本题因 $p$ 为质数且 $i<p$ 自动满足条件，但推广到非质数模数时需额外验证！

---

<conclusion>
本次逆元问题解析就到这里。记住：理解数学推导比记忆代码更重要！尝试用可视化工具观察递推过程，你会对「从基础到高效」的算法优化有更深体会。下次遇到类似问题，不妨先问自己：能否找到子问题间的递推关系？我们下期再见！💪
</conclusion>

---
处理用时：163.60秒
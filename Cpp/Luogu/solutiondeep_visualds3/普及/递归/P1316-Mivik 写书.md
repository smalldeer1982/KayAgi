# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果

# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡


今天我们来一起分析“Mivik 写书”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：容斥原理 + 并查集应用

🗣️ **初步分析**：  
解决“Mivik 写书”的关键，是把“计算所有字符串的不同子串总数”转化为“用容斥原理统计每个子串的贡献”。简单来说，**容斥原理**就像“清点重叠的货物”——先算所有可能的情况，再减去重复计算的部分，再加回多减的，最终得到准确结果。在本题中，我们需要统计“每个可能的子串（或其出现方式）对总不同子串数的贡献”，用容斥抵消重复计数。  

具体思路是：  
1. **转化问题**：期望 = 所有字符串的不同子串总数 ÷ 总字符串数（\(m^n\)），因此只需计算总数 \(S(n,m)\)，再乘 \(m^{-n}\) 的逆元。  
2. **容斥统计**：对每个子串长度 \(x\)，枚举其**出现的起始位置集合**（用二进制表示），用容斥系数 \( (-1)^{\text{popcount}(S)+1} \) 调整贡献（奇数次加、偶数次减）。  
3. **约束计算**：用**并查集**维护“哪些位置的字符必须相同”（因为同一子串多次出现时，重叠位置的字符需一致），连通块数量 \(k\) 决定了满足条件的字符串数为 \(m^k\)（每个连通块可自由选字符）。  

**可视化设计思路**：  
我们将用8位像素风格动画展示“容斥+并查集”的过程：  
- 用像素网格表示字符串的位置（比如10x10网格，每个格子代表一个字符位置）；  
- 用不同颜色的像素块标记“当前枚举的子串长度”（比如红色框选长度为2的子串）；  
- 用二进制灯阵展示“出现位置集合”（亮灯表示该位置是子串起点）；  
- 用并查集动画展示“连通块合并”（相同颜色表示同一连通块）；  
- 实时显示当前的容斥系数和贡献值，关键操作（如合并连通块）伴随“叮”的像素音效。  


## 2. 精选优质题解参考

为了更好地理解解题过程，我筛选了以下思路清晰、代码易读的优质题解：


### 题解一：Huasushis（新手向，容斥+并查集模板）
* **点评**：这份题解是“新手友好型”的典范！作者把容斥的逻辑拆解得非常直白——“枚举子串长度→枚举出现位置→用并查集处理约束→计算贡献”。代码结构工整，变量名（如`tot`表示连通块数）含义明确，边界处理严谨（比如`mod`的加减操作确保非负）。尤其值得学习的是**位运算优化**（用`c`维护最近x位的出现情况）和**容斥系数的处理**（用`__builtin_parity`判断奇偶性），这些技巧让代码既高效又易读。


### 题解二：Reunite（简洁版容斥实现）
* **点评**：此题解的亮点是“代码简洁性”。作者用`work`函数封装了每个子串长度的处理逻辑，并用`mp`数组记录每个位置被哪些子串覆盖，再通过并查集合并相同约束。虽然代码行数少，但逻辑完整——从状态枚举到连通块计算，每一步都清晰。特别适合学习“如何用最少的代码实现容斥逻辑”。


### 题解三：rainygame（高效容斥模板）
* **点评**：这份题解的核心优势是“效率”。作者用`iota`初始化并查集，用`__builtin_parity`快速判断二进制中1的个数奇偶性，并且将所有计算整合在一个循环中，常数非常小。代码中的`c`数组记录每个位置是否被覆盖，`nw`计算连通块数，这些细节都体现了作者对容斥模型的深刻理解，适合学习“如何优化容斥代码的执行效率”。


## 3. 核心难点辨析与解题策略

在解决这个问题时，我们通常会遇到以下关键点：


### 1. 关键点1：如何建立容斥模型？
* **分析**：直接计算“不同子串数”很难，因为子串会重复出现。容斥的核心是“将问题转化为统计每个子串的贡献”——对于一个子串，如果它在字符串中出现了`c`次，那么它的贡献是`1`（因为只算一次），而容斥通过枚举“出现位置集合”，用系数抵消重复计数。例如，当枚举集合`S`时，贡献系数是`(-1)^(|S|+1)`，这样最终每个子串的总贡献正好是`1`。
* 💡 **学习笔记**：容斥的关键是“找到重复计数的模式，用系数调整”。


### 2. 关键点2：如何用并查集处理字符约束？
* **分析**：当子串在多个位置出现时，重叠位置的字符必须相同（比如子串“ab”在位置1和2出现，那么位置2的字符必须等于位置1的字符，位置3的字符必须等于位置2的字符）。并查集可以将这些“必须相同的位置”合并成一个连通块，连通块的数量决定了可自由选择的字符数（每个连通块选一个字符，共`m^k`种）。
* 💡 **学习笔记**：并查集是处理“等价关系”的利器，比如“字符必须相同”就是一种等价关系。


### 3. 关键点3：如何计算容斥系数？
* **分析**：容斥系数由“出现位置集合的大小”决定——奇数次出现时加贡献，偶数次时减贡献（即`(-1)^(|S|+1)`）。例如，当集合`S`有1个元素（子串出现1次），系数是`+1`；有2个元素（出现2次），系数是`-1`，以此类推。这样可以抵消重复计数。
* 💡 **学习笔记**：容斥系数的设计要“精准抵消重复”，通常与集合大小的奇偶性相关。


### ✨ 解题技巧总结
- **问题转化**：将“期望”转化为“总数÷总情况数”，避免直接计算期望。
- **容斥应用**：遇到“重复计数”问题时，优先考虑容斥原理，枚举子集调整贡献。
- **并查集辅助**：处理“等价约束”时，用并查集快速合并连通块，计算自由变量数。
- **位运算优化**：用二进制表示集合（如出现位置），用`__builtin_parity`等函数快速计算奇偶性。


## 4. C++核心代码实现赏析

在深入分析具体题解之前，先看一个**通用核心实现**（基于Huasushis的题解优化）：


### 本题通用核心C++实现参考
* **说明**：本代码综合了多个优质题解的思路，是“容斥+并查集”的典型实现，逻辑清晰，适合新手学习。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

int n;
ll m, ans;
ll qpow(ll x, ll y) { // 快速幂，计算x^y mod MOD
    ll res = 1;
    while (y) {
        if (y & 1) res = res * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return res;
}

int fa[25];
int getfa(int x) { // 并查集找根
    return x == fa[x] ? x : fa[x] = getfa(fa[x]);
}

void solve(int x) { // 处理长度为x的子串
    int total_pos = n - x + 1; // 可能的起始位置数
    int mask = (1 << x) - 1; // 用于维护最近x位的出现情况
    for (int s = 1; s < (1 << total_pos); ++s) { // 枚举出现位置集合s
        for (int j = 0; j < x; ++j) fa[j] = j; // 初始化并查集
        int c = 0, cnt = 0; // c: 最近x位的出现情况，cnt: 未被覆盖的位置数
        for (int j = 0; j < n; ++j) { // 遍历字符串的每个位置
            c = (c << 1) | ((s >> j) & 1); // 更新最近x位的出现情况
            c &= mask; // 保留低x位
            if (c == 0) {
                cnt++; // 未被覆盖，自由选择
            } else {
                // 合并所有在c中的位（即当前位置被哪些子串覆盖）
                int first = __builtin_ctz(c & -c); // 第一个被覆盖的位
                int root = getfa(first);
                int tmp = c - (c & -c); // 剩余被覆盖的位
                while (tmp) {
                    int bit = __builtin_ctz(tmp & -tmp);
                    fa[getfa(bit)] = root;
                    tmp -= tmp & -tmp;
                }
            }
        }
        // 统计连通块数量（子串内部的约束）
        for (int j = 0; j < x; ++j) {
            if (getfa(j) == j) cnt++;
        }
        // 计算贡献：容斥系数 * m^cnt
        ll贡献 = qpow(m, cnt);
        if (__builtin_parity(s)) { // 集合大小为奇数，加贡献
            ans = (ans + 贡献) % MOD;
        } else { // 偶数，减贡献（加MOD避免负数）
            ans = (ans - 贡献 + MOD) % MOD;
        }
    }
}

int main() {
    scanf("%d%lld", &n, &m);
    for (int i = 1; i <= n; ++i) { // 枚举所有子串长度
        solve(i);
    }
    // 计算期望：ans * (m^n)^{-1} mod MOD
    ll inv_total = qpow(qpow(m, n), MOD - 2);
    printf("%lld\n", ans * inv_total % MOD);
    return 0;
}
```
* **代码解读概要**：  
  1. **快速幂**：计算`m^k`和逆元，用于贡献计算。  
  2. **并查集**：维护子串中必须相同的字符位置。  
  3. **solve函数**：处理每个子串长度`x`，枚举出现位置集合`s`，计算连通块数`cnt`，并根据容斥系数更新`ans`。  
  4. **主函数**：枚举所有子串长度，最后计算期望（乘总情况数的逆元）。  


### 各优质题解的片段赏析

#### 题解一：Huasushis的核心片段
* **亮点**：用`c`维护最近x位的出现情况，避免重复计算。
* **核心代码片段**：
```cpp
c = (c << 1) | ((s >> j) & 1); // 更新最近x位的出现情况
c &= mask; // 保留低x位
if (c == 0) cnt++;
else {
    int first = __builtin_ctz(c & -c);
    int root = getfa(first);
    int tmp = c - (c & -c);
    while (tmp) {
        int bit = __builtin_ctz(tmp & -tmp);
        fa[getfa(bit)] = root;
        tmp -= tmp & -tmp;
    }
}
```
* **代码解读**：  
  - `c`是一个`x`位的二进制数，表示“最近x个位置中，哪些是子串的起始位置”。  
  - `c & -c`取出`c`的最后一个1（即第一个被覆盖的位），用`__builtin_ctz`得到其位置。  
  - 合并所有被覆盖的位到同一个连通块，确保这些位置的字符相同。  
* 💡 **学习笔记**：用二进制数维护状态，是处理“连续位置”问题的常用技巧。


#### 题解二：Reunite的核心片段
* **亮点**：用`mp`数组记录每个位置被哪些子串覆盖，逻辑更直观。
* **核心代码片段**：
```cpp
int mp[25] = {0}; // mp[i]表示位置i被哪些子串的第j位覆盖
for (int i = 1; i <= tt; ++i)
    for (int j = 1; j <= len; ++j)
        mp[a[i] + j - 1] |= (1 << j); // 标记位置a[i]+j-1被第j位覆盖
```
* **代码解读**：  
  - `a[i]`是子串的起始位置，`a[i]+j-1`是子串的第j位对应的字符串位置。  
  - `mp[pos]`用二进制位标记“该位置属于哪些子串的哪一位”，后续合并这些位对应的连通块。  
* 💡 **学习笔记**：用数组记录位置的覆盖情况，适合理解容斥的约束逻辑。


#### 题解三：rainygame的核心片段
* **亮点**：用`iota`快速初始化并查集，代码更简洁。
* **核心代码片段**：
```cpp
memset(c, -1, sizeof(c));
iota(f, f + x + 1, 0); // 初始化fa[0..x]为0,1,..,x
```
* **代码解读**：  
  - `iota`函数（来自`<numeric>`头文件）可以将数组初始化为连续的整数，比`for`循环更高效。  
  - `c[j]`记录位置`j`是否被覆盖（`-1`表示未覆盖）。  
* 💡 **学习笔记**：善用STL函数可以简化代码，提高可读性。


## 5. 算法可视化：像素动画演示 (核心部分)

为了更直观地理解“容斥+并查集”的过程，我设计了一个**8位像素风格的动画**，模拟算法的执行流程：


### 动画演示主题
**“像素字符串的容斥冒险”**：用FC红白机风格的像素网格展示字符串，通过“枚举子串→标记位置→合并连通块→计算贡献”的流程，让你“看”到算法的每一步。


### 设计思路简述
采用8位像素风是为了营造轻松复古的学习氛围；用**不同颜色**标记关键元素（如红色框选子串长度，蓝色表示连通块），用**像素音效**强化操作记忆（如合并连通块时的“叮”声，计算贡献时的“滴”声）；每完成一个子串长度的处理，会弹出“小关卡完成”的提示，增加成就感。


### 动画帧步骤与交互关键点
1. **场景初始化**：  
   - 屏幕左侧显示一个`n`位的像素字符串（比如`n=3`时，是3个白色像素块排成一行）。  
   - 右侧是“控制面板”：包含“开始/暂停”“单步执行”“重置”按钮，以及“子串长度”滑块（1~n）。  
   - 底部显示当前的“容斥系数”“连通块数”“贡献值”。  
   - 背景播放8位风格的轻松BGM（如《超级马里奥》的小关卡音乐）。

2. **子串长度选择**：  
   - 拖动滑块选择子串长度`x`（比如`x=2`），屏幕左侧的字符串会用红色框选前`x`个像素块，表示当前处理的子串长度。

3. **枚举出现位置集合**：  
   - 用二进制灯阵（`total_pos`个小灯）展示当前的出现位置集合`s`（比如`total_pos=2`时，灯阵有2个灯，亮灯表示该位置是子串起点）。  
   - 点击“单步执行”，灯阵会逐个切换状态（从`s=1`到`s=2^{total_pos}-1`）。

4. **并查集合并动画**：  
   - 当`s`切换时，字符串中被覆盖的位置会变成蓝色，并用**黄色箭头**指向要合并的连通块。  
   - 合并时，两个连通块会变成同一颜色（比如从蓝色变成绿色），伴随“叮”的音效。

5. **贡献计算与更新**：  
   - 合并完成后，底部的“连通块数”会显示当前的`cnt`，“贡献值”会根据容斥系数更新（加或减`m^cnt`）。  
   - 当`s`枚举完毕，底部会显示该子串长度的总贡献，并弹出“子串长度x处理完成”的提示。

6. **目标达成**：  
   - 所有子串长度处理完成后，播放“胜利”音效（如《塞尔达传说》的宝箱声），屏幕显示最终的`ans`和期望结果。


### 旁白提示（文字气泡）
- “现在我们处理长度为2的子串，看！红色框选的就是子串~”  
- “灯阵亮了1个灯，表示子串从位置1开始出现~”  
- “蓝色位置要合并啦！黄色箭头指的是要合并的连通块~”  
- “贡献值加了m^3，因为容斥系数是+1哦！”


## 6. 拓展练习与相似问题思考

理解了“容斥+并查集”的思路后，我们可以将其应用到更多问题中：


### 通用思路迁移
- **字符串重复子串统计**：比如统计所有字符串中“出现至少k次的子串数”，可以用容斥枚举出现位置集合。  
- **约束条件下的计数问题**：比如“计算满足某些位置字符相同的字符串数”，用并查集处理约束。  
- **组合计数中的重复抵消**：比如“计算没有连续相同字符的字符串数”，用容斥抵消连续的情况。


### 练习推荐 (洛谷)
1. **洛谷 P1316** - Mivik 写书（原题）  
   🗣️ **推荐理由**：直接巩固“容斥+并查集”的应用，是本题的最佳练习。  
2. **洛谷 P4931** - 情侣？给我烧了！  
   🗣️ **推荐理由**：考察容斥原理的经典问题，需要枚举“情侣坐错的位置”，类似本题的“出现位置集合”。  
3. **洛谷 P3413** - SAC#1 - 萌数  
   🗣️ **推荐理由**：统计包含“至少一个连续相同数字”的数的个数，用容斥抵消重复计数。  
4. **洛谷 P2522** - [HAOI2011]Problem c  
   🗣️ **推荐理由**：用容斥处理“选k个元素满足条件”的问题，结合组合数计算。  


## 7. 学习心得与经验分享 (若有)

本次分析的题解中，Huasushis作者提到：“题解看了一个下午才看懂，于是准备讲一个更清楚的”。这提醒我们：  
- **复杂算法需要拆解**：容斥原理看起来难，但拆成“枚举子集→处理约束→计算贡献”三步，就变得容易理解了。  
- **新手向题解很重要**：如果遇到难懂的算法，可以找“用白话解释”的题解，往往能事半功倍。  


本次关于“Mivik 写书”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解容斥原理和并查集的应用。记住，编程能力的提升在于**持续学习、勤于思考和勇于实践**。下次我们再一起探索新的编程挑战！💪

---
处理用时：116.27秒
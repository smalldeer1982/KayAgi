# 题目信息

# 【模板】模意义下的乘法逆元

## 题目背景

这是一道模板题


## 题目描述

给定 $n,p$ 求 $1\sim n$ 中所有整数在模 $p$ 意义下的乘法逆元。

这里 $a$ 模 $p$ 的乘法逆元定义为 $ax\equiv1\pmod p$ 的解。

## 说明/提示

$ 1 \leq n \leq 3 \times 10 ^ 6$，$n < p < 20000528 $。

输入保证 $ p $ 为质数。


## 样例 #1

### 输入

```
10 13```

### 输出

```
1
7
9
10
8
11
2
5
3
4```

# AI分析结果



---
# 💡 Kay的C++算法解析：模意义下的乘法逆元 深入学习指南 💡

<introduction>
今天我们来一起分析“模意义下的乘法逆元”这道C++编程题。本指南将帮助大家理解乘法逆元的核心概念，掌握高效求解方法，并通过可视化和扩展练习巩固知识。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（数论应用-线性递推求逆元）`

🗣️ **初步分析**：
解决这道题的关键是理解乘法逆元的定义，并找到高效计算1~n所有数逆元的方法。乘法逆元是指在模p意义下，满足 \( a \times x \equiv 1 \pmod{p} \) 的数x。对于本题，由于n可达 \( 3 \times 10^6 \)，直接使用扩展欧几里得或快速幂（时间复杂度 \( O(n \log p) \)）会超时，因此需采用线性递推法（时间复杂度 \( O(n) \)）。

线性递推的核心思想是利用模运算的性质推导递推公式。假设 \( p = k \times i + r \)（其中 \( k = \lfloor \frac{p}{i} \rfloor \)，\( r = p \mod i \)），通过模运算变形可得 \( i^{-1} \equiv -k \times r^{-1} \pmod{p} \)。进一步优化后，递推式为 \( \text{inv}[i] = (p - \frac{p}{i}) \times \text{inv}[p \mod i] \mod p \)。

可视化设计将采用8位像素风格，用动态网格展示每个i的逆元计算过程：初始时inv[1]=1（高亮显示），后续每个i的inv值通过与p mod i的逆元相乘并取模得到，关键步骤（如p mod i的计算、乘法和取模）用颜色变化和音效提示，帮助直观理解递推逻辑。

---

## 2. 精选优质题解参考

<eval_intro>
为了高效解决本题，我们筛选出以下思路清晰、代码简洁的优质题解（均为线性递推法）：
</eval_intro>

**题解一：作者 zcysky**
* **点评**：此题解直接给出线性递推的核心代码，逻辑简洁高效。代码中使用`inv[1]=1`初始化，通过递推式`inv[i]=(ll)(p-p/i)*inv[p%i]%p`计算每个i的逆元，边计算边输出。代码规范（变量名清晰）、算法时间复杂度O(n)，完美适配大数据量，实践价值极高。

**题解二：作者 Rising_Date**
* **点评**：此题解详细推导了线性递推公式的来源，结合数学证明和代码实现，思路清晰易懂。代码中对负数处理（`(x%p+p)%p`）严谨，适合初学者理解递推逻辑。其解释部分对逆元定义和费马小定理的对比，帮助学习者区分不同方法的适用场景。

**题解三：作者 灵乌路空**
* **点评**：此题解不仅给出线性递推代码，还对比了阶乘逆元法，展示了多种解法的思路。代码中对阶乘和逆元的预处理逻辑清晰，适合扩展学习。其对递推公式的详细证明（如`p=ki+r`的变形），有助于深入理解数学原理。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于理解逆元的数学性质和推导高效的递推公式。以下是关键步骤和策略：
</difficulty_intro>

1.  **关键点1：理解乘法逆元的定义**
    * **分析**：逆元x满足 \( a \times x \equiv 1 \pmod{p} \)。由于p是质数，1~n的数均与p互质，故逆元存在。需明确逆元是模p意义下的倒数，用于将除法转换为乘法（如 \( \frac{a}{b} \equiv a \times b^{-1} \pmod{p} \)）。
    * 💡 **学习笔记**：逆元的本质是模p下的“倒数”，仅在a与p互质时存在。

2.  **关键点2：推导线性递推公式**
    * **分析**：通过模运算变形，将p表示为 \( p = k \times i + r \)，推导出 \( i^{-1} \equiv -k \times r^{-1} \pmod{p} \)。由于r < i，r的逆元已提前计算，从而实现线性递推。公式优化后为 \( \text{inv}[i] = (p - \frac{p}{i}) \times \text{inv}[p \mod i] \mod p \)，避免了负数。
    * 💡 **学习笔记**：递推公式的核心是利用更小的i的逆元计算当前i的逆元，时间复杂度O(n)。

3.  **关键点3：处理大数运算的模细节**
    * **分析**：计算中需注意模运算的分配律（如 \( (a \times b) \mod p = [(a \mod p) \times (b \mod p)] \mod p \)），避免溢出。递推式中的`(p - p/i)`确保结果为正，无需额外处理负数。
    * 💡 **学习笔记**：模运算中，加法和乘法可拆分，但除法需用逆元转换。

### ✨ 解题技巧总结
- **问题分解**：将求1~n的逆元分解为逐个计算，利用已计算的小i的逆元推导大i的逆元。
- **公式优化**：通过数学变形将递推式中的负数项转换为正数，简化代码实现。
- **预处理与递推**：利用线性时间预处理，避免重复计算，适合大数据量问题。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的线性递推法核心代码，适用于大数据量（n≤3e6），时间复杂度O(n)。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合多个优质题解的线性递推思路，代码简洁高效，适用于题目要求的大数据范围。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    using namespace std;

    const int MAXN = 3e6 + 10;
    int inv[MAXN];

    int main() {
        int n, p;
        scanf("%d%d", &n, &p);
        inv[1] = 1;
        printf("1\n");
        for (int i = 2; i <= n; ++i) {
            inv[i] = (long long)(p - p / i) * inv[p % i] % p;
            printf("%d\n", inv[i]);
        }
        return 0;
    }
    ```
* **代码解读概要**：
  代码首先初始化`inv[1]=1`（1的逆元是自身），然后从i=2开始，利用递推式`inv[i] = (p - p/i) * inv[p%i] % p`计算每个i的逆元，边计算边输出。`(long long)`避免乘法溢出，`%p`确保结果在模p范围内。

---
<code_intro_selected>
以下是优质题解的核心代码片段及解读：
</code_intro_selected>

**题解一：作者 zcysky**
* **亮点**：代码极简，直接实现线性递推，时间复杂度O(n)，适合大数据量。
* **核心代码片段**：
    ```cpp
    #include<bits/stdc++.h>
    #define N 3000010
    typedef long long ll;
    using namespace std;
    int inv[N],n,p;
    inline int read(){/*...*/}
    int main(){
        n=read();p=read();inv[1]=1;puts("1");
        for(int i=2;i<=n;i++){
            inv[i]=(ll)(p-p/i)*inv[p%i]%p;
            printf("%d\n",inv[i]);
        }
    }
    ```
* **代码解读**：
  `inv[1]=1`初始化，`for`循环从2到n递推计算每个逆元。`(ll)`强制转换避免`p/i`与`inv[p%i]`相乘时溢出。`puts`和`printf`快速输出，适配大数据量。
* 💡 **学习笔记**：线性递推的关键是正确推导公式，并用`long long`避免中间结果溢出。

**题解二：作者 Rising_Date**
* **亮点**：代码中包含递推公式的数学推导，逻辑清晰，适合理解原理。
* **核心代码片段**：
    ```cpp
    inv[1] = 1;
    for(int i = 2; i <= n; i++)
        inv[i] = (ll)(p - p / i) * inv[p % i] % p;
    ```
* **代码解读**：
  递推式`(p - p/i) * inv[p%i] % p`是核心，其中`p - p/i`将负数转换为正数（因`p%i < i`，`inv[p%i]`已计算）。`%p`确保结果在模p范围内。
* 💡 **学习笔记**：递推式中的`p - p/i`等价于`-(p/i) mod p`，避免了负数结果。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解线性递推求逆元的过程，我们设计一个“逆元探险队”像素动画，以8位复古风格展示每个i的逆元如何由前一个结果计算而来。
</visualization_intro>

  * **动画演示主题**：`逆元探险队的像素之旅`

  * **核心演示内容**：
    展示从i=1到i=n的逆元计算过程，重点突出递推式`inv[i] = (p - p/i) * inv[p%i] % p`的每一步计算，包括p mod i的取值、乘法和模运算的结果。

  * **设计思路简述**：
    采用8位像素风格（如FC游戏画面），用不同颜色的方块代表不同数值。关键步骤（如p mod i的计算、乘法操作）用闪烁或颜色变化提示，配合“叮”的音效强化记忆。每完成一个i的逆元计算，视为“闯过一关”，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左侧为“逆元计算区”（网格，每行对应一个i），右侧为“数据展示区”（显示p、当前i、inv[i]等）。
        - 控制面板包含“开始/暂停”“单步”“重置”按钮，以及速度滑块（调节动画播放速度）。

    2.  **初始状态**：
        - i=1的方块高亮显示（颜色为绿色），inv[1]=1显示在右侧数据区，播放“叮”的音效。

    3.  **递推计算**：
        - 对于i=2到n：
          - 当前i的方块变为黄色（表示正在计算），计算p mod i（显示为蓝色数值）。
          - 查找inv[p mod i]（对应方块闪烁），计算`(p - p/i)`（显示为红色数值）。
          - 两者相乘并取模p，结果作为inv[i]（显示为绿色数值），当前i的方块变为绿色，播放“叮”音效。

    4.  **完成状态**：
        - 所有i的逆元计算完成后，播放“胜利”音效，屏幕显示“任务完成！”，并闪烁所有绿色方块。

    5.  **交互控制**：
        - 单步模式：点击“单步”按钮，逐次展示每个i的计算过程。
        - 自动播放：调节速度滑块（如0.5倍速、1倍速、2倍速），观察快速递推过程。

  * **旁白提示**：
      - “i=1的逆元是1，这是初始条件哦！”
      - “现在计算i=2的逆元，p mod 2等于...，我们需要用到inv[这个数]！”
      - “看，通过公式计算，i=2的逆元是这个值！”

<visualization_conclusion>
通过这样的动画，我们能直观看到每个逆元如何由前一个结果推导而来，理解线性递推的高效性和数学原理。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握线性递推求逆元后，可尝试以下扩展问题，巩固数论知识：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    线性递推法不仅适用于求1~n的逆元，还可用于求阶乘逆元、组合数模质数等问题。关键是找到递推式，利用已计算的小问题结果推导大问题。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5431 【模板】乘法逆元2**
        * 🗣️ **推荐理由**：此题要求求多个数的逆元，需结合线性递推和前缀积，巩固逆元应用。
    2.  **洛谷 P2613 【模板】有理数取模**
        * 🗣️ **推荐理由**：涉及分数取模，需用逆元转换除法，适合练习逆元的实际应用。
    3.  **洛谷 P1313 计算系数**
        * 🗣️ **推荐理由**：结合二项式定理和逆元计算，提升综合运用能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> 作者 Henry_he 提到：“一开始用扩展欧几里得和快速幂都超时，后来发现必须用线性递推。这让我意识到，大数据量问题需优先考虑线性时间算法。”

**点评**：此经验提醒我们，面对n较大的问题时，需注意时间复杂度的优化。线性递推法在处理连续数值的逆元时，时间复杂度O(n)远优于O(n log p)的方法，是解决此类问题的关键。

-----

<conclusion>
本次关于“模意义下的乘法逆元”的分析到此结束。通过理解逆元的定义、掌握线性递推法，以及可视化演示，相信大家已能高效解决此类问题。继续加油，探索更多数论奥秘！💪
</conclusion>

---
处理用时：163.89秒
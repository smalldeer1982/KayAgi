# 题目信息

# 滑动窗口 /【模板】单调队列

## 题目描述

有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

例如，对于序列 $[1,3,-1,-3,5,3,6,7]$ 以及 $k = 3$，有如下过程：

$$\def\arraystretch{1.2}
\begin{array}{|c|c|c|}\hline
\textsf{窗口位置} & \textsf{最小值} & \textsf{最大值} \\ \hline
\verb![1   3  -1] -3   5   3   6   7 ! & -1 & 3 \\ \hline
\verb! 1  [3  -1  -3]  5   3   6   7 ! & -3 & 3 \\ \hline
\verb! 1   3 [-1  -3   5]  3   6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1 [-3   5   3]  6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1  -3  [5   3   6]  7 ! & 3 & 6 \\ \hline
\verb! 1   3  -1  -3   5  [3   6   7]! & 3 & 7 \\ \hline
\end{array}
$$

## 说明/提示

【数据范围】    
对于 $50\%$ 的数据，$1 \le n \le 10^5$；  
对于 $100\%$ 的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。


## 样例 #1

### 输入

```
8 3
1 3 -1 -3 5 3 6 7```

### 输出

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7```

# AI分析结果

# 💡 Kay的C++算法解析：滑动窗口 /【模板】单调队列 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：单调队列（动态维护滑动窗口的最值）


🗣️ **初步分析**：  
解决“滑动窗口最值”问题的关键，是用**单调队列**高效维护窗口内的“候选最值”。简单来说，单调队列就像一个“择优录取的排队系统”——比如求最小值时，队列里的元素必须**越来越小**（单调递增？不，等下！数值单调递增，下标单调递增）。新元素进来时，会把队尾所有比它大的元素“挤走”——因为这些大元素在新元素存在的窗口里，永远不可能成为最小值（新元素更小，且存活时间更长）。而队首元素如果超出窗口范围，就会被“请出去”。这样，**队首永远是当前窗口的最值**！

### 核心算法流程
以求最小值为例，每一步做3件事：
1. **清旧人**：如果队首元素的下标已经在窗口外（`i - q[head] >= k`），移除队首。  
2. **辞庸才**：从队尾开始，把所有比当前元素大的元素移除（因为它们比新元素差，且更早消失）。  
3. **纳新人**：当前元素的下标入队。  
4. **取最值**：当窗口形成（`i >= k-1`）时，队首对应的数值就是当前窗口的最小值。

求最大值的逻辑完全一致，只需要把“比当前元素大”改成“比当前元素小”即可（维护单调递减队列）。


### 可视化设计思路
我会用**FC红白机风格的像素动画**展示这个过程：
- **场景**：屏幕左侧是序列元素（8x8像素方块，颜色代表数值大小），右侧是单调队列（蓝色方块，队首用红色高亮），中间用黄色虚线框标出当前窗口。  
- **动画细节**：
  - 新元素入队：从右侧“滑入”队列区域，同时挤走队尾的“庸才”（被挤走的方块会向左“消失”）。  
  - 窗口滑动：黄色虚线框向右移动一格，超出窗口的队首元素会“弹出”（向上消失）。  
  - 最值输出：每次得到最值时，屏幕下方弹出“最小值：-1”的像素文字，伴随“叮”的8位音效。  
- **交互设计**：支持“单步执行”（点击“下一步”按钮）、“自动播放”（速度滑块调节）和“重置”，方便大家慢动作观察每一步。


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了4份优质题解，帮大家快速掌握核心逻辑：
</eval_intro>


### **题解一：hilsinleri（详细步骤讲解+结构体封装）**
* **点评**：这份题解用样例一步步拆解单调队列的操作（比如如何处理序列`1,3,-1,-3`），把“清旧人、辞庸才、纳新人”的逻辑讲得**极其明白**。代码用`Monotone_queue`结构体封装，变量名`q`（队列）、`p`（下标）含义明确，甚至注释了“为什么head=1、tail=0”——这对新手理解队列初始化非常有帮助。更难得的是，作者特别强调“单调队列≠优先队列”，避免了新手的常见误区。


### **题解二：Jerrycyx（取反技巧+通用模板）**
* **点评**：作者的“取反求最大值”技巧太妙了！因为`max(a) = -min(-a)`，所以只需要写一遍求最小值的代码，把数组取反后再跑一遍，就能得到最大值。这种“复用代码”的思路能减少重复劳动，也能加深对单调队列的理解。代码中的`Calc`函数用指针传参，把求最值的逻辑封装成通用模板，非常规范。


### **题解三：yr409892525（简洁手写队列+正确性证明）**
* **点评**：这份题解的代码**极其简洁**——用两个循环分别求最小和最大值，手写队列（`l`=队首，`r`=队尾）代替`deque`，速度更快。作者还给出了正确性证明：“每个元素最多入队出队一次，时间复杂度O(n)”，帮大家理解为什么单调队列是线性的。


### **题解四：kunkun127（思路总结+边界处理）**
* **点评**：作者总结了单调队列的**核心应用场景**（滑动窗口最值、DP优化），并强调了“移除队首超出窗口的元素”是关键。代码中的边界处理（`i >= k`时输出）非常严谨，适合新手模仿。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决滑动窗口问题时，新手常踩3个“坑”，我帮大家提炼了应对策略：
</difficulty_intro>


### 1. **难点1：如何维护队列的单调性？**  
- **问题**：为什么新元素要挤走队尾比它大（或小）的元素？  
- **策略**：想清楚“谁更有资格留在队列里”——比如求最小值时，新元素`x`比队尾元素`y`小，那么`y`在`x`存在的窗口里，永远不可能成为最小值（`x`更小，且`x`的下标更大，存活时间更长）。所以`y`可以直接移除。  
- 💡 **学习笔记**：单调队列的“单调性”是**“有用性”的保证**——留下的都是“有可能成为最值的元素”。


### 2. **难点2：如何处理窗口外的元素？**  
- **问题**：队首元素可能已经不在当前窗口里了，怎么办？  
- **策略**：队列里存储的是**元素的下标**（不是数值！），这样可以通过下标判断是否在窗口内（窗口范围是`[i-k+1, i]`，所以如果`q[head] < i-k+1`，说明队首已经“过时”，需要移除）。  
- 💡 **学习笔记**：存储下标而不是数值，是单调队列的“灵魂技巧”！


### 3. **难点3：如何同时求最大和最小值？**  
- **问题**：难道要写两遍几乎一样的代码？  
- **策略**：两种方法选其一：  
  ① 跑两遍单调队列（一次求最小，一次求最大）；  
  ② 利用“最大值= -最小值的相反数”，把数组取反后求最小值，再取反得到最大值（参考Jerrycyx的题解）。  
- 💡 **学习笔记**：复用代码能减少出错概率，也能锻炼“转化问题”的思维。


### ✨ 解题技巧总结
- **技巧1**：用下标而不是数值存储队列元素，方便判断是否在窗口内。  
- **技巧2**：维护单调队列时，“清旧人”和“辞庸才”的顺序可以调换（但要确保队首有效）。  
- **技巧3**：对于大规模数据（比如`n=1e6`），手写队列比`STL deque`更快（避免容器的 overhead）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**——结合了“手写队列”和“取反求最大值”的技巧，代码简洁高效：
</code_intro_overall>


### **本题通用核心C++实现参考**
* **说明**：本代码综合了Jerrycyx和yr409892525的思路，用手写队列实现，支持快速求最小和最大值。
* **完整核心代码**：
```cpp
#include <cstdio>
using namespace std;

const int N = 1e6 + 5;
int n, k, a[N];
int ans_min[N], ans_max[N];  // 存储每个窗口的最小/最大值
int q[N], head, tail;        // 手写单调队列（存储下标）

// 计算单调队列的最小值，结果存入res数组
void calc_min(int res[]) {
    head = 1, tail = 0;  // 队列初始化（head=队首，tail=队尾）
    for (int i = 1; i <= n; ++i) {
        // 1. 清旧人：队首超出窗口，移除
        while (head <= tail && q[head] < i - k + 1) head++;
        // 2. 辞庸才：队尾元素比当前大，移除
        while (head <= tail && a[q[tail]] >= a[i]) tail--;
        // 3. 纳新人：当前下标入队
        q[++tail] = i;
        // 4. 取最值：窗口形成时输出
        if (i >= k) res[i - k + 1] = a[q[head]];
    }
}

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);

    // 第一步：求最小值
    calc_min(ans_min);
    for (int i = 1; i <= n - k + 1; ++i) printf("%d ", ans_min[i]);
    putchar('\n');

    // 第二步：求最大值（取反后求最小值，再取反）
    for (int i = 1; i <= n; ++i) a[i] = -a[i];
    calc_min(ans_max);
    for (int i = 1; i <= n - k + 1; ++i) printf("%d ", -ans_max[i]);
    putchar('\n');

    return 0;
}
```
* **代码解读概要**：  
  - `calc_min`函数：用手写队列维护单调递增（数值）的队列，每次处理完`i`后，队首就是`[i-k+1, i]`的最小值。  
  - 求最大值时，把数组元素取反，调用`calc_min`得到“最小值”，再取反就是原数组的最大值——完美复用代码！


---

<code_intro_selected>
接下来看**优质题解的核心片段**，分析它们的“亮点”：
</code_intro_selected>


### **题解一：hilsinleri（结构体封装）**
* **亮点**：用结构体封装单调队列的操作，代码模块化，可读性高。
* **核心代码片段**：
```cpp
struct Monotone_queue {
    int n, k, a[maxn];
    int q[maxn], head, tail, p[maxn];  // q存数值，p存下标？不，原代码中q存数值，p存下标？
    // （注：原代码中q存数值，p存下标，但更推荐存下标，这样更灵活）
    void monotone_min() {
        head = 1, tail = 0;
        for (int i = 1; i <= n; ++i) {
            while (head <= tail && q[tail] >= a[i]) tail--;  // 辞庸才
            q[++tail] = a[i]; p[tail] = i;                 // 纳新人
            while (p[head] <= i - k) head++;               // 清旧人
            if (i >= k) printf("%d ", q[head]);            // 取最值
        }
    }
};
```
* **代码解读**：  
  作者用`q`存数值，`p`存下标——虽然不如直接存下标灵活，但逻辑是对的。`monotone_min`函数里，“辞庸才”是移除队尾比当前大的数值，“清旧人”是移除下标超出窗口的元素，最后输出队首数值。
* 💡 **学习笔记**：结构体封装能让代码更整洁，适合大型项目，但新手可以先从手写队列开始。


### **题解二：Jerrycyx（取反技巧）**
* **亮点**：用“取反”复用代码，减少重复劳动。
* **核心代码片段**：
```cpp
void Calc(int res[]) {
    head=1,tail=0;
    for(int i=1;i<=n;i++) {
        while(head<=tail && i-q[head]+1>k) q[head++]=0;  // 清旧人（窗口范围是i-k+1到i）
        while(head<=tail && a[q[tail]]>a[i]) q[tail--]=0; // 辞庸才
        q[++tail]=i;                                      // 纳新人
        if(i>=k) res[i-k+1]=q[head];                      // 存下标
    }
}
// 主函数中求最大值：
for(int i=1;i<=n;i++) a[i]=-a[i];  // 取反
Calc(ans2);                         // 求反数组的最小值
for(int i=1;i<=n-k+1;i++) printf("%d ",-a[ans2[i]]);  // 再取反得到最大值
```
* **代码解读**：  
  `Calc`函数存的是**最小值的下标**，而不是数值。求最大值时，把数组取反，`Calc`得到的是“反数组的最小值下标”，对应的原数组数值就是最大值（因为`-a[ans2[i]]`就是原数组的最大值）。
* 💡 **学习笔记**：“转化问题”是算法的重要思维——把最大值转化为最小值，能复用已有逻辑。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家“亲眼看到”单调队列的运作，我设计了一个**FC红白机风格的像素动画**，名字叫《滑动窗口小英雄》！
</visualization_intro>


### **动画设计方案**
#### **1. 整体风格**
- **像素风格**：用8x8像素方块代表序列元素，颜色对应数值（比如负数用蓝色，正数用红色，数值越大颜色越深）。  
- **UI布局**：
  - 左侧：序列区（10列×5行，显示当前窗口附近的元素）；  
  - 右侧：队列区（显示单调队列的元素，队首用红色高亮）；  
  - 下方：控制面板（“单步”“自动”“重置”按钮，速度滑块，当前最值显示）。


#### **2. 核心动画流程（以样例`1,3,-1,-3,5,3,6,7`，`k=3`为例）**
**步骤1：初始化**  
- 序列区显示前3个元素：`1`（浅红）、`3`（深红）、`-1`（浅蓝），黄色虚线框标出这3个元素（窗口1）。  
- 队列区为空，控制面板显示“准备开始”。

**步骤2：处理第3个元素`-1`（窗口1形成）**  
- 动画：`-1`从右侧滑入队列区，挤走队尾的`3`和`1`（它们比`-1`大），队列区只剩`-1`（蓝色方块，队首红色高亮）。  
- 音效：“叮”的一声，下方显示“最小值：-1”。

**步骤3：窗口滑动到第2个位置（元素`3,-1,-3`）**  
- 动画：黄色虚线框向右移动一格，序列区显示`3,-1,-3`。队列区的`-1`被挤走（因为`-3`更小），新的队首是`-3`。  
- 音效：“哔”的一声，下方显示“最小值：-3”。

**步骤4：自动播放**  
- 开启“自动播放”后，窗口快速滑动，队列区的元素不断入队出队，每次输出最值时都有音效提示。速度滑块可以调节播放速度（最慢1秒/步，最快0.1秒/步）。


#### **3. 交互设计**
- **单步执行**：点击“下一步”按钮，动画执行一步，方便仔细观察每一步的变化。  
- **自动播放**：点击“自动”按钮，动画按设定速度连续播放，适合整体把握流程。  
- **重置**：点击“重置”按钮，动画回到初始状态，重新开始。


#### **4. 技术实现要点**
- **Canvas绘制**：用HTML5 Canvas绘制像素方块，每个方块的位置由下标计算（比如序列区第`i`个元素的位置是`(i*10, 50)`）。  
- **音效**：用Web Audio API播放8位音效（比如入队是“叮”，出队是“哔”，输出最值是“咚”）。  
- **状态管理**：用JavaScript维护序列、队列、窗口的状态，每次操作后重新绘制Canvas。


<visualization_conclusion>
通过这个动画，你能**直观看到**单调队列如何“择优录取”元素，如何“清理旧人”，以及队首如何始终保持是窗口的最值。就像玩红白机游戏一样，边玩边学，是不是很有意思？
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
单调队列的应用非常广泛，只要问题满足“**区间左右端点单调移动**”（比如滑动窗口），都可以用它优化！
</similar_problems_intro>


### **通用思路迁移**
单调队列能解决的问题包括：
1. **滑动窗口最值**（本题）；  
2. **环形滑动窗口最值**（比如数组是环形的，窗口可以绕到开头）；  
3. **动态规划优化**（比如“最大子数组和”问题，用单调队列优化状态转移）。


### **洛谷练习推荐**
1. **洛谷 P1440 求m区间内的最小值**  
   🗣️ **推荐理由**：本题的“简化版”——只需要求最小值，适合巩固单调队列的基础逻辑。  
2. **洛谷 P2032 扫描**  
   🗣️ **推荐理由**：需要维护两个单调队列（一个求最小，一个求最大），并计算它们的差值，适合锻炼综合应用能力。  
3. **洛谷 P3709 大爷的字符串题**  
   🗣️ **推荐理由**：结合了字符串和单调队列，需要维护窗口内的字符出现次数，适合拓展思维。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“心得”是前辈们踩坑后的经验，非常宝贵：
</insights_intro>


> **经验1（来自hilsinleri）**：“单调队列≠优先队列！”  
> **点评**：优先队列（堆）的时间复杂度是O(n log k)，而单调队列是O(n)——对于`n=1e6`的数据，优先队列会超时！新手一定要区分这两个数据结构。

> **经验2（来自Jerrycyx）**：“老而更劣的元素永远不可能成为最值。”  
> **点评**：这句话是单调队列的“灵魂总结”——想清楚这个逻辑，就能理解为什么要挤走队尾的元素。

> **经验3（来自yr409892525）**：“手写队列比deque快！”  
> **点评**：对于大规模数据，`STL deque`的迭代器和内存分配会有开销，手写队列（用数组模拟）更快更稳定。


## 结语
滑动窗口问题是算法中的“经典题”，而单调队列是解决它的“终极武器”。只要掌握了“清旧人、辞庸才、纳新人”的逻辑，就能轻松应对这类问题。记住：**单调队列的核心是“保留有用的元素，淘汰无用的元素”**——就像生活中，我们也要多和优秀的人在一起，淘汰那些“拖后腿”的习惯呀！

下次我们再一起探索单调队列的进阶应用（比如DP优化），不见不散！💪

---
处理用时：129.32秒
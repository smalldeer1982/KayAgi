# 题目信息

# 【模板】单源最短路径（标准版）

## 题目背景

2018 年 7 月 19 日，某位同学在 [NOI Day 1 T1 归程](https://www.luogu.org/problemnew/show/P4768) 一题里非常熟练地使用了一个广为人知的算法求最短路。

然后呢？

$100 \rightarrow 60$；

$\text{Ag} \rightarrow \text{Cu}$；

最终，他因此没能与理想的大学达成契约。

小 F 衷心祝愿大家不再重蹈覆辙。

## 题目描述

给定一个 $n$ 个点，$m$ 条有向边的带非负权图，请你计算从 $s$ 出发，到每个点的距离。

数据保证你能从 $s$ 出发到任意点。

## 说明/提示

样例解释请参考 [数据随机的模板题](https://www.luogu.org/problemnew/show/P3371)。

$1 \leq n \leq 10^5$；

$1 \leq m \leq 2\times 10^5$；

$s = 1$；

$1 \leq u_i, v_i\leq n$；

$0 \leq w_i \leq 10 ^ 9$,

$0 \leq \sum w_i \leq 10 ^ 9$。

本题数据可能会持续更新，但不会重测，望周知。

2018.09.04 数据更新 from @zzq

## 样例 #1

### 输入

```
4 6 1
1 2 2
2 3 2
2 4 1
1 3 5
3 4 3
1 4 4```

### 输出

```
0 2 4 3```

# AI分析结果

要解决**单源最短路径（带非负权）**问题，**Dijkstra算法+堆优化**是当前最适合的解决方案（尤其针对大数据范围）。以下是对题解集合的**核心思路总结**、**关键实现细节**及**优秀实践**的提炼：


### **一、核心算法选择：Dijkstra+堆优化**
1. **算法原理**：  
   Dijkstra算法通过**贪心策略**，每次选择当前距离起点最近的未处理节点，更新其相邻节点的距离。堆优化（小根堆）用于快速找到“最近节点”，将时间复杂度从$O(N^2)$优化到$O(M \log N)$（$N$为节点数，$M$为边数），适合本题$N=10^5$、$M=2\times10^5$的大数据。

2. **为什么不用SPFA？**  
   SPFA的时间复杂度为$O(kM)$（$k$为节点入队次数），最坏情况下会退化到$O(NM)$，无法通过本题的卡常数据（如稠密图或刻意构造的链式图）。因此，Dijkstra+堆优化是**唯一可靠选择**。


### **二、关键实现细节**
#### **1. 图的存储：链式前向星**
   由于节点和边数量大，**链式前向星**是最节省空间且高效的存储方式（比邻接矩阵省空间，比vector<vector>遍历更快）。  
   **实现方式**：  
   - `head[]`：记录每个节点的**第一条边**的索引。  
   - `edge[]`：结构体数组，存储每条边的**终点**（`to`）、**权值**（`val`）和**下一条边**（`next`）的索引。  
   - `add()`函数：添加边时，将新边插入到对应节点的边链表头部（更新`head[]`和`edge[]`）。  
   **示例代码**：  
   ```cpp
   struct Edge { int to, val, next; } edge[200010];
   int head[100010], num = 0;
   void add(int u, int v, int d) {
       edge[++num] = {v, d, head[u]};
       head[u] = num;
   }
   ```

#### **2. 堆优化：小根堆**
   用于快速获取当前距离起点最近的节点。**实现方式**有两种：  
   - **结构体+重载运算符**：定义包含“距离”和“节点编号”的结构体，重载`<`运算符实现小根堆（默认大根堆，需反转比较逻辑）。  
     **示例代码**：  
     ```cpp
     struct Node {
         int dist, pos;
         bool operator<(const Node& a) const { return dist > a.dist; } // 小根堆
     };
     priority_queue<Node> q;
     ```
   - **pair+greater**：用`pair<int, int>`（first为距离，second为节点编号），结合`greater<pair<int, int>>`实现小根堆（更简洁）。  
     **示例代码**：  
     ```cpp
     typedef pair<int, int> pii;
     priority_queue<pii, vector<pii>, greater<pii>> q;
     ```

#### **3. 核心流程**
   - **初始化**：距离数组`dis[]`设为无穷大（如`0x3f3f3f3f`），起点`S`的距离设为0，入堆。  
   - **循环处理**：每次取出堆顶元素（当前最近节点），若已处理过则跳过；否则标记为已处理，遍历其所有出边，更新相邻节点的距离（若更短），并将相邻节点入堆。  
   **关键优化**：  
   - **标记已处理节点**：用`vis[]`数组标记已处理的节点，避免重复处理（如`if (vis[mini]) continue;`）。  
   - **剪枝**：若堆顶元素的距离大于当前记录的距离（说明该节点已被处理过），直接跳过（如`if (d > dis[u]) continue;`）。  
   **示例代码**：  
   ```cpp
   void dijkstra(int s) {
       memset(dis, 0x3f, sizeof(dis));
       dis[s] = 0;
       priority_queue<pii, vector<pii>, greater<pii>> q;
       q.push({0, s});
       while (!q.empty()) {
           auto [d, u] = q.top();
           q.pop();
           if (d > dis[u]) continue; // 剪枝：已处理过
           for (int i = head[u]; i; i = edge[i].next) {
               int v = edge[i].to, w = edge[i].val;
               if (dis[v] > dis[u] + w) {
                   dis[v] = dis[u] + w;
                   q.push({dis[v], v});
               }
           }
       }
   }
   ```


### **三、优秀实践总结**
1. **效率优化**：  
   - 用**链式前向星**存储图，避免内存浪费。  
   - 用**STL优先队列**实现小根堆，无需手写堆（节省代码量且高效）。  
   - 用**快读快写**（如`scanf/printf`或自定义`read()`函数），应对大数据输入（避免`cin`超时）。  

2. **正确性保证**：  
   - 标记已处理节点（`vis[]`），避免重复更新。  
   - 剪枝（跳过已处理的堆顶元素），减少不必要的计算。  
   - 距离数组初始化为足够大的值（如`0x3f3f3f3f`），确保未访问节点的距离不会被误判。  

3. **可读性**：  
   - 变量名规范（如`dis[]`表示距离，`head[]`表示边链表头）。  
   - 添加注释，说明关键步骤（如初始化、入堆、更新距离）。  


### **四、常见错误避免**
- **数组越界**：节点编号从1开始，数组需开足够大（如`100010`）。  
- **权值溢出**：本题权值和不超过$10^9$，用`int`足够（若需更大范围，用`long long`）。  
- **有向边处理**：题目中的边是有向的，添加边时只需添加一次（如`add(u, v, w)`，无需反向）。  


### **五、示例代码（整合最优实践）**
```cpp
#include <cstdio>
#include <cstring>
#include <queue>
#include <vector>
using namespace std;

typedef pair<int, int> pii;
const int N = 100010, M = 200010;
const int INF = 0x3f3f3f3f;

struct Edge { int to, val, next; } edge[M];
int head[N], num = 0;
int dis[N];
bool vis[N];

void add(int u, int v, int d) {
    edge[++num] = {v, d, head[u]};
    head[u] = num;
}

void dijkstra(int s) {
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, false, sizeof(vis));
    dis[s] = 0;
    priority_queue<pii, vector<pii>, greater<pii>> q;
    q.push({0, s});
    while (!q.empty()) {
        auto [d, u] = q.top();
        q.pop();
        if (d > dis[u]) continue; // 剪枝：已处理过
        if (vis[u]) continue;      // 标记已处理
        vis[u] = true;
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to, w = edge[i].val;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push({dis[v], v});
            }
        }
    }
}

int main() {
    int n, m, s;
    scanf("%d%d%d", &n, &m, &s);
    for (int i = 1; i <= m; i++) {
        int u, v, w;
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w);
    }
    dijkstra(s);
    for (int i = 1; i <= n; i++) {
        printf("%d ", dis[i]);
    }
    return 0;
}
```


### **总结**
本题的核心是**Dijkstra+堆优化**，关键在于**高效存储图**（链式前向星）和**快速找到最近节点**（小根堆）。通过标记已处理节点和剪枝，可以进一步提升效率。掌握这些细节，就能轻松解决本题及类似的单源最短路径问题（带非负权）。

---
处理用时：139.54秒
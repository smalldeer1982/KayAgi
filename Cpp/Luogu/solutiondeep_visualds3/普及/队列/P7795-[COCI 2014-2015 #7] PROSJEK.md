# 题目信息

# [COCI 2014/2015 #7] PROSJEK

## 题目描述

给定一个有 $n$ 个整数的数列 $a$。请找出一个长度至少为 $k$ 的连续子序列，使这个子序列的所有数的平均值最大。

## 说明/提示

**【数据范围】**

对于 $30\%$ 的数据，保证 $n\leqslant 5000$。  
对于所有数据，$1\leqslant k\leqslant n\leqslant 3\times 10^5$，$1\leqslant a_i\leqslant 10^6$。

**【题目来源】**

本题来源自 **_[COCI 2014-2015](https://hsin.hr/coci/archive/2014_2015/) [CONTEST 7](https://hsin.hr/coci/archive/2014_2015/contest7_tasks.pdf) T5 PROSJEK_**，按照原题数据配置，满分 $140$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。

## 样例 #1

### 输入

```
4 1
1 2 3 4```

### 输出

```
4.000000```

## 样例 #2

### 输入

```
4 2
2 4 3 4```

### 输出

```
3.666666```

## 样例 #3

### 输入

```
6 3
7 1 2 1 3 6```

### 输出

```
3.333333```

# AI分析结果

# 💡 Kay的C++算法解析：PROSJEK 深入学习指南 💡

今天我们来一起分析COCI 2014/2015 #7的「PROSJEK」问题——这是一道**寻找连续子序列最大平均值**的经典题目，核心考察**二分答案（分数规划）**与**前缀和优化**的组合技巧。本指南会帮你拆解思路、理解算法，并通过像素动画直观感受每一步的变化！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分答案（分数规划） + 前缀和优化

🗣️ **初步分析**：  
解决这道题的关键是**二分答案**——就像“猜数字游戏”：我们要找最大的平均值`mid`，每次猜一个`mid`，然后检查“是否存在长度≥k的子序列，其平均值≥mid”。如果存在，说明`mid`可以更大；否则`mid`要更小。

那怎么快速“检查”呢？这里用到**分数规划**的技巧：将原问题转化为**子段和问题**。假设我们想验证`mid`是否可行，只需把每个数`a[i]`减去`mid`，得到新数组`b[i] = a[i] - mid`。此时，“子序列平均值≥mid”等价于“子序列的`b[i]`和≥0”（推导：$\sum(a[i]-mid) = \sum a[i] - mid \times 长度 ≥0 → \sum a[i]/长度 ≥mid$）。

接下来，如何快速找长度≥k的`b`数组子段和≥0？用**前缀和+维护前缀最小值**：
- 计算`b`数组的前缀和`s[i]`（`s[0]=0`，`s[i] = s[i-1] + b[i]`）；
- 对于每个右端点`i`（`i≥k`），我们需要找`j ≤ i-k`，使得`s[i] - s[j] ≥0`（子段`j+1`到`i`的长度≥k）。要让`s[i]-s[j]`尽可能大，只需找`j≤i-k`中的**最小`s[j]`**——如果`s[i]≥`这个最小值，说明存在符合条件的子段！

### 核心算法流程
1. **二分初始化**：左边界`l=1`（`a[i]≥1`），右边界`r=1e6`（`a[i]≤1e6`）；
2. **二分循环**：计算`mid=(l+r)/2`，调用`check(mid)`判断是否可行；
3. **check函数**：计算`a[i]-mid`的前缀和`s`，维护前`i-k`的`s`最小值`minv`，判断`s[i]-minv≥0`；
4. **调整边界**：可行则`l=mid`（尝试更大值），否则`r=mid`（尝试更小值）；
5. **输出结果**：最终`l`即为最大平均值。

### 可视化设计思路
我们用**8位像素风格**模拟二分与check过程：
- 左侧显示原数组的像素柱（绿色，高度对应`a[i]`）；
- 中间是二分进度条（灰色填充范围`[l,r]`，红色块标记`mid`）；
- 右侧是check区域（蓝色线表示前缀和`s`，黄色闪烁块标记`minv`，橙色高亮可行子段）；
- 交互设计：单步执行、自动播放（可调速）、AI演示，配合像素音效（如二分“滴”、找到子段“叮”）。


## 2. 精选优质题解参考

为你筛选了3份**思路清晰、代码规范**的优质题解：

### 题解一：来源：Pengzt
* **点评**：最经典的标准解法！思路直接命中“二分+前缀和优化”的核心，代码简洁到“每一行都有用”。`check`函数中，先算前缀和`b`，再维护前`i-k`的最小值`mnv`，最后判断最大差值`res≥0`。时间复杂度`O(n log 1e6)`完全满足数据范围，适合入门学习。

### 题解二：来源：wangbinfeng
* **点评**：亮点是“注释辅助理解”和“快读模板”（虽未写全，但思路正确）。作者明确指出暴力`O(nk)`超时，转而用“前缀和+二分”的组合拳，`check`函数中“只要存在一种可行情况就返回true”的贪心思想，让代码更高效。

### 题解三：来源：lvvd
* **点评**：进阶的`O(n)`斜率优化解法！将问题转化为“斜率最大化”——每个前缀和`sum[i]`对应点`(i, sum[i])`，找`j≤i-k`使得斜率`(sum[i]-sum[j])/(i-j)`最大（即平均值最大）。通过维护**下凸包**的单调队列，快速找到最优`j`。适合已经掌握二分法的同学拓展。


## 3. 核心难点辨析与解题策略

这道题的难点在于“**将抽象的平均值问题转化为可高效解决的形式**”，结合优质题解，提炼3个核心难点及解决策略：

### 1. 难点1：如何将“最大平均值”转化为可二分的问题？
* **分析**：直接枚举所有子段的时间复杂度是`O(n²)`，无法通过大数据。此时需要**分数规划**：将“平均值≥mid”转化为“子段和≥0”（每个数减mid），把“求最大值”转化为“判断可行性”，用二分法高效处理。
* 💡 学习笔记：分数规划是处理“比值最大/最小”问题的神器，核心是**将比值条件转化为和的条件**。

### 2. 难点2：如何高效check“是否存在长度≥k的子段和≥0”？
* **分析**：直接枚举子段还是`O(n²)`。用**前缀和+维护前缀最小值**：前缀和`s[i]`表示前`i`个`b`的和，子段`j+1`到`i`的和是`s[i]-s[j]`。找`j≤i-k`的最小`s[j]`，这样`s[i]-s[j]`最大——如果这个最大值≥0，说明存在可行解。
* 💡 学习笔记：前缀和是处理连续子段和的基础，**维护前缀极值**可以快速找到最优的`j`，避免重复计算。

### 3. 难点3：斜率优化的思路如何理解？
* **分析**：对于前缀和`sum[i]`，平均值`max (sum[i]-sum[j])/(i-j)`等价于找`j≤i-k`使得点`(i,sum[i])`与`(j,sum[j])`的斜率最大。根据平面几何，最大斜率对应的`j`一定在**下凸包**上（下凸包上的点连成的斜率递增，队首的点就是最优的）。用单调队列维护下凸包，`O(n)`时间完成。
* 💡 学习笔记：斜率优化将问题转化为几何问题，通过**维护凸包**减少决策点数量，是处理线性递推问题的高级技巧。

### ✨ 解题技巧总结
- **技巧1**：遇到“比值最大/最小”问题，优先用分数规划转化为和的条件；
- **技巧2**：处理连续子段和的条件判断时，前缀和+维护极值是“黄金组合”；
- **技巧3**：斜率优化适合“max (y_i - y_j)/(x_i - x_j)”类问题，核心是维护凸包。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合Pengzt和404Not_Found的思路，是“二分+前缀和优化”的标准实现，逻辑简洁易读。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 3e5 + 5;
const double eps = 1e-6;
int n, k;
int a[N];
double s[N]; // 前缀和数组（存a[i]-mid的和）

bool check(double mid) {
    s[0] = 0;
    for (int i = 1; i <= n; ++i) {
        s[i] = s[i-1] + a[i] - mid;
    }
    double minv = 1e18; // 维护前i-k个s的最小值
    for (int i = k; i <= n; ++i) {
        minv = min(minv, s[i - k]); // 更新minv为s[0..i-k]的最小值
        if (s[i] - minv >= 0) { // 存在j<=i-k使得s[i]-s[j]>=0
            return true;
        }
    }
    return false;
}

int main() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &a[i]);
    }
    double l = 1.0, r = 1e6;
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (check(mid)) {
            l = mid; // 可行，尝试更大的mid
        } else {
            r = mid; // 不可行，尝试更小的mid
        }
    }
    printf("%.6lf\n", l);
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取`n`、`k`和数组`a`；
  2. **二分初始化**：`l=1`（`a[i]`最小值），`r=1e6`（`a[i]`最大值）；
  3. **二分循环**：每次取`mid=(l+r)/2`，调用`check`判断可行性；
  4. **check函数**：计算`a[i]-mid`的前缀和，维护前`i-k`的最小值，判断是否存在可行子段；
  5. **输出结果**：最终`l`即为最大平均值，保留6位小数。

---

### 题解片段赏析：Pengzt的check函数
* **亮点**：代码最简洁，直接对应“前缀和+维护最小值”的思路。
* **核心代码片段**：
```cpp
bool check(double mid) {
    for (int i = 1; i <= n; i++) {
        b[i] = b[i - 1] + a[i] - mid;
    }
    double res = -1, mnv = 1e9;
    for (int i = k; i <= n; i++) {
        mnv = std::min(mnv, b[i - k]);
        res = std::max(res, b[i] - mnv);
    }
    return res >= 0;
}
```
* **代码解读**：
  - `b`数组存`a[i]-mid`的前缀和；
  - `mnv`维护前`i-k`的`b`最小值；
  - `res`记录所有可能的最大差值（`s[i]-s[j]`）；
  - 最后判断`res≥0`——和通用实现的区别是，这里计算了所有可能的最大值，而通用实现提前返回，更高效。
* 💡 学习笔记：**提前返回**可以减少不必要的计算，提升代码效率。

---

### 题解片段赏析：lvvd的斜率优化
* **亮点**：`O(n)`时间复杂度，展示了斜率优化的核心逻辑。
* **核心代码片段**：
```cpp
double xl(ll s, ll t) { // 计算点(s,sum[s])和(t,sum[t])的斜率
    return (sum[t]-sum[s]) * 1.0 / (t - s);
}

int main() {
    // ... 输入处理 ...
    for (int i = k; i <= n; i++) {
        // 将i-k加入单调队列（维护下凸包）
        while (back - front >= 2 && xl(i - k, q[back-2]) > xl(i - k, q[back-1])) {
            back--;
        }
        q[back++] = i - k;
        // 找最优j（队首的点）
        while (back - front >= 2 && xl(i, q[front+1]) > xl(i, q[front])) {
            front++;
        }
        ans = max(ans, xl(i, q[front]));
    }
    // ... 输出 ...
}
```
* **代码解读**：
  - `xl`函数计算两点斜率（即子段的平均值）；
  - **维护下凸包**：将`i-k`加入队列前，弹出不满足下凸性的点（斜率递减的点）；
  - **找最优j**：从队列前端弹出斜率较小的点，队首的点即为最优；
  - **更新最大值**：计算`i`与队首点的斜率，更新`ans`。
* 💡 学习笔记：斜率优化的关键是**维护凸包**，确保队列中的点能快速找到最优决策点。


## 5. 算法可视化：像素动画演示

\<visualization\_intro\>
为了让算法“活”起来，我设计了一个**8位像素风格**的动画，结合复古游戏元素，让你直观看到每一步的变化！
\</visualization\_intro\>

### 动画设计方案
* **主题**：像素探险家“Kay”在数组森林中寻找“最大平均值子段”。
* **核心演示内容**：
  1. **二分进度**：中间进度条显示`l`、`r`、`mid`，红色块标记当前`mid`；
  2. **check过程**：原数组的绿色柱变成蓝色（表示`a[i]-mid`），蓝色线动态延伸（前缀和`s`），黄色块闪烁（`minv`）；
  3. **可行子段高亮**：找到符合条件的子段时，蓝色柱变橙色，播放“叮”的音效；
  4. **结束状态**：二分完成后，显示最终结果，播放胜利音乐，屏幕撒像素星星。

### 交互与游戏化元素
- **控制面板**：开始/暂停、单步、重置按钮；速度滑块（1x~5x）；AI演示开关；
- **音效**：二分“滴”、计算前缀和“嗒”、找到子段“叮”、胜利音乐；
- **AI模式**：“Kay”像素角色自动行走，每完成一步挥挥手，增加趣味性。

### 旁白提示
- 二分开始：“现在猜`mid`是`(l+r)/2`，看看有没有可行的子段！”
- check过程：“蓝色线是前缀和`s`，黄色块是前`i-k`的最小`s`，等一下看`s[i]-minv`是不是≥0？”
- 找到子段：“哦！这个子段的和≥0，说明`mid`可以更大，把`l`移到`mid`！”
- 结束：“大功告成！最大平均值是`l`，保留6位小数哦～”


## 6. 拓展练习与相似问题思考

### 通用思路迁移
“二分答案+前缀和”的技巧可以解决很多问题，比如：
- **最大比例问题**：找两个数的最大比例，二分比例值，转化为判断是否存在比值≥mid；
- **子段和≥S的最短长度**：二分长度，转化为判断是否存在长度为mid的子段和≥S；
- **图中的最长路径**：二分路径长度，转化为判断是否存在环的平均权值≥mid（用SPFA判断正环）。

### 洛谷练习推荐
1. **P1873 砍树**：经典二分入门题，考察“判断是否能砍到足够的木材”，巩固二分基础；
2. **P2678 跳石头**：二分变形题，考察“判断是否能移除m块石头使得最小跳跃距离≥mid”，拓展思路；
3. **P3629 [APIO2010] 巡逻**：二分+图论，考察“判断是否能通过添加边使得巡逻距离≤mid”，进阶练习；
4. **P7913 【深进1.例1】求区间和**：前缀和基础题，巩固前缀和技巧。


## 7. 学习心得与经验分享

从题解中提炼的**宝贵经验**：
> **经验1（来自Pengzt）**：“一开始我想暴力枚举所有子段，但n=3e5时肯定超时。后来想到二分答案，把问题转化为子段和问题，用前缀和加维护最小值的方法，终于过了。”  
> **点评**：暴力法直观但低效，遇到超时问题时，要学会**转化问题**而不是“硬算”。二分答案是“将求最大值转化为判断可行性”的常用技巧。

> **经验2（来自lvvd）**：“斜率优化的关键是理解凸包的性质，我一开始没搞懂为什么要维护下凸包，后来画了几个点模拟，才明白最大斜率对应的点一定在凸包上。”  
> **点评**：斜率优化比较抽象，**画图模拟**是很好的理解方法——动手画点、连线，能快速抓住核心逻辑。


## 结语

本次分析就到这里！这道题的核心是**二分答案+前缀和优化**，斜率优化是进阶的高效解法。通过像素动画，你应该能直观看到算法的每一步；通过拓展练习，你可以巩固这些技巧。记住：编程的关键是“**转化问题**”——把复杂的问题拆成简单的子问题，再用合适的算法解决。下次我们再一起探索更多有趣的算法！💪

---
处理用时：247.08秒
# 题目信息

# [BJOI2017] 魔法咒语

## 题目描述

Chandra 是一个魔法天才。

从一岁时接受火之教会洗礼之后，Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。

直到十四岁，开始学习威力强大的禁咒法术时，Chandra 才遇到了障碍。

根据火之魔法规则，禁咒的构成单位是 $N$ 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 $L$ 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。

但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时，Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。

这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。

很多年过去了，在一次远古遗迹探险中，Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。


禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 $M$ 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。

例如，若 `banana` 是唯一的忌讳词语，`an`、`ban`、`analysis` 是基本词汇，禁咒长度须是 $11$，则 `bananalysis` 是无效法术，`analysisban`、`anbanbanban` 是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。

谜题破解，Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。

由于答案可能很大，你只需要输出答案模 $10 ^ 9 + 7$ 的结果。


## 说明/提示

【样例解释 1】

有效的禁咒法术共有 $14$ 种：`boom/bang/oo`，`oo/oo/oo/oo/oo`，`oo/oo/ooh/ooh`，`oo/ooh/oo/ooh`，`oo/ooh/ooh/oo`，`ooh/oo/oo/ooh`，`ooh/oo/ooh/oo`，`
ooh/ooh/boom`，`ooh/ooh/oo/oo`，`ooh/ooh/bang`，`ooh/bang/ooh`，`bang/oo/oo/oo`，`bang/ooh/ooh`，`bang/bang/oo`。

【样例解释 2】

有效的禁咒法术有 `a/ab`，`ab/a`，`aba` 共三种。注意，`ab/a` 和 `aba` 算成两种不同的禁咒法术。

【数据规模与约定】

本题一共有 $10$ 个测试点。

下表是每个测试点的数据规模和约定：

 ![](https://cdn.luogu.com.cn/upload/pic/5191.png) 

对于 $100\%$ 的数据，$1 \le N, M \le 50，1 \le L \le 10^8$，基本词汇的长度之和不超过 $100$，忌讳词语的长度之和不超过 $100$。保证基本词汇不重复，忌讳词语不重复。


## 样例 #1

### 输入

```
4 2 10
boom
oo
ooh
bang
ob
mo```

### 输出

```
14```

## 样例 #2

### 输入

```
3 1 3
a
ab
aba
aaa```

### 输出

```
3```

## 样例 #3

### 输入

```
3 1 14
ban
an
analysis
banana```

### 输出

```
15```

# AI分析结果


### 💡 Kay的C++算法解析：[BJOI2017] 魔法咒语 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`AC自动机 + 动态规划 + 矩阵快速幂优化`

🗣️ **初步分析**：
> 解决此题需理解**AC自动机**的核心思想——它像一台多模式匹配的“文字安检机”，能同时扫描多个禁忌词汇。动态规划（DP）则是计算合法咒语数量的“计数器”，记录不同长度和状态的方案数。  
> **核心难点**在于避免咒语包含禁忌词汇。我们通过：
> - **AC自动机预处理**：建立禁忌词汇的匹配路径，标记危险节点（Fail树上传递标记）
> - **状态转移设计**：`dp[i][j]` 表示长度为 `i` 且匹配到节点 `j` 的方案数
> - **矩阵快速幂优化**：当 `L ≤ 10⁸` 时，将DP转化为矩阵乘法问题

**可视化设计思路**：
> 采用 **8位像素风格** 模拟AC自动机运行：
> - **节点可视化**：每个AC节点用像素方块表示，危险节点红色闪烁，安全节点绿色
> - **路径动画**：添加词汇时显示路径移动，触发禁忌词汇时播放“失败音效”
> - **矩阵演示**：矩阵乘法过程转为网格动画，向量元素用发光像素表示计算过程

---

#### 2. 精选优质题解参考
**题解一（作者：shadowice1984）**
* **点评**：
  - **思路亮点**：创新性提出将DP状态向量扩展为2倍长度（`[dp_i, dp_{i+1}]`），完美解决词汇长度≤2的转移问题。AC自动机的危险节点标记处理严谨（`ed[p] |= ed[failp]`）
  - **代码规范**：变量名`tran[u][j]`含义清晰，矩阵乘法封装成独立类，模块化优秀
  - **算法优化**：针对 `L>100` 数据，矩阵快速幂将 `O(nL²)` 优化至 `O(n³logL)`，空间优化使用滚动数组思想

**题解二（作者：oscar）**
* **点评**：
  - **分类讨论策略**：对 `L≤100` 和 `L>100` 实现双解法，边界处理完整（如 `len[j]==1` 和 `len[j]==2` 的分支）
  - **可读性**：AC自动机构建函数 `build()` 逻辑分层明确，队列操作规范
  - **实践价值**：提供完整的测试用例 `syxqwq` → `610205411`，便于调试验证

**题解三（作者：Hoks）**
* **点评**：
  - **结构设计**：将AC自动机封装为 `struct trie`，状态转移函数 `handle()` 独立封装
  - **复杂度控制**：预处理 `tran[u][j]` 避免重复匹配，矩阵幂运算采用快速幂分治
  - **扩展性**：推荐类似题目（POI2010 CHO-Hamsters）强化训练

---

#### 3. 核心难点辨析与解题策略
1. **关键点1：AC自动机的危险节点传递**
   * **分析**：未正确处理Fail树上的危险标记传递（`ed[u] |= ed[fail[u]]`）会导致漏判禁忌词汇。优质题解均在构建自动机后通过DFS/BFS传递标记
   * 💡 学习笔记：**Fail树是AC自动机的骨骼，危险标记需从根向叶传递**

2. **关键点2：DP状态转移的维度设计**
   * **分析**：当词汇长度≤2时，需同时记录 `dp_i` 和 `dp_{i-1}` 状态。矩阵设计采用分块结构：
     ```
     M = [ 0   B ]   // B: 长度1词汇转移
         [ I   C ]   // I: 单位矩阵, C: 长度2词汇转移
     ```
   * 💡 学习笔记：**高维DP可压缩为矩阵乘法，关键在于状态向量的拼接**

3. **关键点3：矩阵快速幂的构造技巧**
   * **分析**：转移矩阵需包含两类边：
     - **直连边**：添加长度1词汇产生的转移
     - **跳跃边**：添加长度2词汇产生的跨状态转移
   * 💡 学习笔记：**矩阵乘法本质是状态路径的计数叠加**

### ✨ 解题技巧总结
- **问题分解**：将禁忌匹配问题转化为AC自动机路径规避问题
- **数据结构选择**：`std::queue` 构建Fail指针，`std::vector` 存储转移状态
- **边界处理**：空串处理（`dp[0][0]=1`），词汇长度超过 `L` 时剪枝
- **调试技巧**：构造特殊用例（如 `a/ab` 与 `aba` 区分）验证转移正确性

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**
```cpp
#include <queue>
#include <cstring>
#include <vector>
using namespace std;
const int N = 105, MOD = 1e9+7;

struct AC {
    int tr[N][26], fail[N], tag[N], cnt;
    void insert(string s) {
        int p = 0;
        for (char c : s) {
            int id = c - 'a';
            if (!tr[p][id]) tr[p][id] = ++cnt;
            p = tr[p][id];
        }
        tag[p] = 1;
    }
    void build() {
        queue<int> q;
        for (int i = 0; i < 26; i++)
            if (tr[0][i]) q.push(tr[0][i]);
        while (!q.empty()) {
            int u = q.front(); q.pop();
            tag[u] |= tag[fail[u]]; // 关键：危险标记传递
            for (int i = 0; i < 26; i++) {
                if (tr[u][i]) {
                    fail[tr[u][i]] = tr[fail[u]][i];
                    q.push(tr[u][i]);
                } else tr[u][i] = tr[fail[u]][i];
            }
        }
    }
} ac;

int dp[N][N], tran[N][N];
vector<string> words;

void solve_small(int L) {
    memset(dp, 0, sizeof dp);
    dp[0][0] = 1;
    for (int i = 0; i <= L; i++) 
        for (int j = 0; j <= ac.cnt; j++) 
            for (int k = 0; k < words.size(); k++) {
                int len = words[k].size();
                if (i + len > L || ac.tag[tran[j][k]]) continue;
                int nxt = tran[j][k];
                dp[i + len][nxt] = (dp[i + len][nxt] + dp[i][j]) % MOD;
            }
}
```

**题解一核心片段赏析**  
```cpp
// 矩阵快速幂优化（L>100）
struct Matrix {
    long long m[N*2][N*2];
    Matrix operator*(const Matrix &b) const {
        Matrix res;
        memset(res.m, 0, sizeof res.m);
        for (int i = 0; i < N*2; i++)
            for (int k = 0; k < N*2; k++)
                for (int j = 0; j < N*2; j++)
                    res.m[i][j] = (res.m[i][j] + m[i][k] * b.m[k][j]) % MOD;
        return res;
    }
};

Matrix build_matrix() {
    Matrix M;
    for (int i = 0; i <= ac.cnt; i++) {
        if (ac.tag[i]) continue;
        for (int k = 0; k < words.size(); k++) {
            int v = tran[i][k];
            if (ac.tag[v]) continue;
            if (words[k].size() == 1) 
                M.m[i][v + ac.cnt + 1]++; // 右上块
            else 
                M.m[i + ac.cnt + 1][v + ac.cnt + 1]++; // 右下块
        }
        M.m[i + ac.cnt + 1][i] = 1; // 左下块（单位矩阵）
    }
    return M;
}
```

---

#### 5. 算法可视化：像素动画演示
**设计说明**：  
> 采用 **FC红白机像素风格** 动态演示AC自动机状态转移，关键元素：
> ![](https://cdn.luogu.com.cn/upload/pic/15924.png)

**动画帧步骤**：
1. **场景初始化**  
   - 16x16像素网格，节点用不同颜色区分：  
     - 绿色：安全节点
     - 红色：危险节点（闪烁效果）
   - 控制面板：开始/暂停、单步执行、速度滑块

2. **AC自动机运行演示**  
   - **路径扫描**：添加词汇时显示路径移动（像素箭头）
   - **危险触发**：遇到禁忌词汇时播放低频“警告音效”
   - **数据结构可视化**：队列/栈用像素方块堆叠表示

3. **矩阵快速幂演示**  
   - **矩阵乘法**：网格中高亮当前计算行列，显示数值变化
   - **快速幂分治**：二进制分解过程用像素数字滚动展示

4. **游戏化元素**  
   - **音效设计**：
     - 安全转移：8-bit "叮"声
     - 触发禁忌：短促爆破音
     - 计算完成：马里过关音乐
   - **关卡系统**：每完成10%的L长度解锁新像素皮肤

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：
> AC自动机+DP+矩阵优化的组合可解决：
> 1. 带禁忌条件的字符串计数（本题）
> 2. 基因序列合法性检测（Bioinformatics）
> 3. 网络协议敏感词过滤（通信安全）

**洛谷推荐**：
1. **P2446 [SDOI2010] 大陆争霸**  
   * 推荐理由：AC自动机与最短路结合，强化自动机转移模型的应用
2. **P3193 [HNOI2008] GT考试**  
   * 推荐理由：KMP+矩阵优化的简化版，适合巩固矩阵快速幂思想
3. **P4052 [JSOI2007] 文本生成器**  
   * 推荐理由：本题的逆向问题（统计包含词汇的方案），训练思维灵活性

---

#### 7. 学习心得与经验分享
> **来自 shadowice1984 的调试经验**：  
> *“我在处理 `ed[p] |= ed[fail[p]]` 时卡了2小时，后来发现未正确传递标记。建议用小型禁忌词汇（如 `['a','b']`）逐步模拟AC自动机构建过程。”*  
>   
> **Kay总结**：  
> 调试AC自动机时，**可视化Fail指针**是关键。推荐在纸上画出Trie树和Fail边，验证危险标记传递的正确性。对于矩阵快速幂，先在小规模数据（如 `L=3`）验证转移矩阵的正确性再扩展。

---

> 本次解析提炼了AC自动机与矩阵优化的核心技巧，通过像素动画方案增强理解。记住：**算法学习就像魔法修炼，需要理论+实践的反复锤炼！** 下次挑战见！🔥

---
处理用时：122.65秒
# 题目信息

# [APIO2015] 雅加达的摩天楼

## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。


## 说明/提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$


## 样例 #1

### 输入

```
5 3
0 2
1 1
4 1```

### 输出

```
5```

# AI分析结果


### 💡 Kay的C++算法解析：雅加达的摩天楼 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论（BFS）与根号分治  
🗣️ **初步分析**：  
> 本题像一场像素游戏中的信使接力赛！摩天楼是地图节点，doge是信使角色。核心思想是通过**状态压缩+分层BFS**优化搜索：  
> - **根号分治**：将跳跃能力分为小（≤√n）和大（>√n）两类，分别控制状态爆炸问题  
> - **双状态转移**：① 同楼传递（无代价）② 跳跃移动（步数+1）  
> - **可视化设计**：将用像素网格展示摩天楼，doge为不同颜色方块。跳跃时显示轨迹光效，同楼传递时播放"叮"音效，并设计自动演示模式展示最优路径搜索过程  

---

#### 2. 精选优质题解参考
**题解一（浮尘ii）**  
* **点评**：  
  思路清晰展现根号分治本质（小p状态O(n√n)，大p状态O(m√n)）。代码规范：  
  - 用`bitset<maxN> vis[maxN]`高效判重（亮点✨）  
  - `insert()`函数优雅处理状态扩展  
  - 边界处理严谨（如`if(i-p>=0`）  
  实践价值高，可直接用于竞赛，时间复杂度严格O((n+m)√n)

**题解二（wurzang）**  
* **点评**：  
  创新性使用**双端队列**区分转移代价：  
  - 同楼传递（0代价）插队首优先处理  
  - 跳跃移动（1代价）放队尾  
  结构上`deque<node>`+`bitset`组合简洁，变量命名直观（`pos,jump,dep`）

**题解三（chu_yh）**  
* **点评**：  
  教学价值突出！通过三个函数清晰分离逻辑：  
  - `Push()`处理状态入队  
  - `mark()`处理同楼传递  
  - `turn()`处理跳跃转移  
  详细注释+状态转移分类讲解，特别适合初学者理解BFS分层思想  

---

#### 3. 核心难点辨析与解题策略
1. **状态空间爆炸**  
   *分析*：直接存(pos)状态数O(n)，但(pos,p)组合可能达O(n²)。根号分治将总状态数压缩至O((n+m)√n)  
   💡 **学习笔记**：√n是平衡状态数与单次转移代价的黄金分割点  

2. **双代价转移处理**  
   *分析*：消息传递（0步）和跳跃（1步）存在代价差异。优质解用两种方案：  
   - 双端队列（题解二）  
   - 分阶段入队（题解一/三先处理同楼所有doge）  
   💡 **学习笔记**：0代价转移需优先处理以保证BFS层序正确性  

3. **高效状态判重**  
   *分析*：`stl::set`导致O(log n)开销不可接受。`bitset`将空间降为O(n²/w)，位操作O(1)  
   💡 **学习笔记**：稠密状态判重首选bitset，稀疏状态考虑哈希  

### ✨ 解题技巧总结
- **根号分治**：当参数范围大时，按√n分治控制复杂度  
- **双代价BFS**：0代价转移用前端入队/立即扩展  
- **状态压缩**：bitset替代二维bool数组省8倍空间  
- **模块化函数**：分离状态转移逻辑提升可读性  

---

#### 4. C++核心代码实现赏析
**通用核心实现**（综合题解优化）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=3e4+5;

vector<int> doge[N];     // doge[i]: 楼i的所有跳跃能力
bitset<N> vis[N];        // vis[i][p]: (i,p)状态是否访问
bool touched[N];         // touched[i]: 楼i是否被访问

int main(){
    int n,m, start,end;
    cin>>n>>m>>start>>end;
    // 初始化doge数据...
    
    queue<tuple<int,int,int>> q; // (pos, p, step)
    touched[start]=true;
    for(int p:doge[start]) 
        vis[start][p]=1, q.push({start,p,0});

    while(!q.empty()){
        auto [pos,p,step]=q.front(); q.pop();
        // 到达终点检查
        if(pos==end) {cout<<step; return 0;} 

        // 同楼传递（0代价）
        if(!touched[pos]){
            touched[pos]=true;
            for(int np:doge[pos]) 
                if(!vis[pos][np]) 
                    vis[pos][np]=1, q.push({pos,np,step});
        }

        // 向左跳（1代价）
        if(pos-p>=0 && !vis[pos-p][p]){
            vis[pos-p][p]=1;
            q.push({pos-p,p,step+1});
        }
        // 向右跳（1代价）
        if(pos+p<n && !vis[pos+p][p]){
            vis[pos+p][p]=1;
            q.push({pos+p,p,step+1});
        }
    }
    cout<<-1;
}
```
**代码解读概要**：  
1. 初始化时仅将起点楼的doge入队  
2. 首次到达新楼时，将该楼所有doge加入队列（0代价）  
3. 跳跃转移产生新状态时步数+1  
4. bitset确保每个(pos,p)状态只访问一次  

---

#### 5. 算法可视化：像素动画演示
![](https://via.placeholder.com/400x200?text=BFS+像素动画示意图)  
* **主题**：8-bit信使冒险  
* **核心演示**：BFS如何按层扩展+根号分治优化效果  

**动画流程**：  
1. **初始化**：  
   - 像素网格展示摩天楼（蓝色矩形）  
   - 起点doge红色闪烁，终点doge绿色常亮  
   - 控制面板：步进/播放/速度调节  

2. **状态扩展**：  
   - **同楼传递**：当前楼变黄，弹出所有doge图标（伴随"叮"音效）  
   - **跳跃移动**：doge沿方向跳跃，落地时显示冲击波特效（"咚"音效）  
   - **根号提示**：大p值doge跳跃时显示√n分割线，右侧显示剩余可跳次数  

3. **胜利条件**：  
   - 到达终点时播放胜利音效+烟花特效  
   - 显示最优路径回放  

**技术实现**：  
```javascript
// 伪代码：跳跃动画
function jumpAnimation(pos, newPos, p){
  drawArrow(pos, newPos); // 绘制像素箭头
  playSound(p > sqrtN ? 'low_jump' : 'high_jump'); 
  highlightBuilding(newPos, 'yellow');
  if(!visited[newPos]) explodeEffects(); // 首次访问特效
}
```

---

#### 6. 拓展练习与相似问题
1. **洛谷 P3645** [APIO2016]划艇  
   → 练习根号分治+离散化技巧  
2. **洛谷 P3396** 哈希冲突  
   → 强化根号分治应用场景  
3. **洛谷 P4137** Rmq Problem  
   → 学习莫队算法（分块思想进阶）  

---

#### 7. 学习心得分享
> **chu_yh的经验**：  
> *"最初直接用二维数组判重导致MLE，改用bitset后内存降为1/8"*  
>   
> **Kay点评**：  
> 在状态空间逼近内存极限时，bitset是救星！其压缩原理类似把8个bool压进1字节，特别适合稠密状态判重  

---

掌握根号分治与BFS状态设计，你也能成为算法游戏中的信使大师！🚀

---
处理用时：112.13秒
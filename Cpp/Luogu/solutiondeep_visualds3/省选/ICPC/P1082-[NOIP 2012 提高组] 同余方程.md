# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP 2012 提高组] 同余方程 深入学习指南 💡

<introduction>
今天我们来一起分析NOIP2012提高组的“同余方程”问题。这道题是数论中的经典问题，核心是求**模逆元**，而解决它的“神器”是**扩展欧几里得算法**（简称exgcd）。本指南会帮你梳理思路、理解算法，并掌握解题技巧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扩展欧几里得算法（exgcd）、模逆元求解

🗣️ **初步分析**：
解决“同余方程”的关键，是把问题转化为**扩展欧几里得算法**能处理的形式。简单来说，扩展欧几里得算法就像“数学中的递归工具”——它能帮我们找到两个整数x和y，使得`ax + by = gcd(a,b)`（gcd是最大公约数）。而本题的同余方程`ax ≡ 1 (mod b)`，其实等价于`ax + by = 1`（y是整数）——因为`ax mod b = 1`意味着`ax - 1`是b的倍数，即`ax - 1 = by`，移项后就是`ax + by = 1`。

根据**裴蜀定理**，`ax + by = 1`有解的条件是`gcd(a,b) = 1`（a和b互质），而题目保证有解（因为样例和数据范围都满足）。所以我们的目标是：用扩展欧几里得算法求出x的一个解，再把它调整为**最小正整数解**。

### 核心算法流程与可视化思路
扩展欧几里得的核心是**递归缩小问题规模**：
1. 递归处理`(b, a%b)`，直到`b=0`（此时`gcd(a,b)=a`，基础解是`x=1, y=0`）；
2. 回溯时，根据子问题的解`(x2,y2)`，计算当前问题的解：`x = y2`，`y = x2 - (a/b)*y2`（这里的`/`是整数除法）；
3. 最后，把x调整为最小正整数：`x = (x % b + b) % b`（避免负数或过大）。

**可视化设计思路**：我们会用**8位像素风**演示这个过程——
- 用不同颜色的像素块表示`a`和`b`，递归时`a`和`b`逐步缩小（比如`a=3, b=10`→`b=3, a%b=1`→`b=1, a%b=0`）；
- 递归到`b=0`时，用“闪烁”的像素块标记基础解`x=1`；
- 回溯时，用“滑动”动画展示`x`和`y`的更新（比如`x`从`y2`变成当前值）；
- 调整解时，用“跳跃”动画展示`x`加上或减去`b`，直到变成最小正整数；
- 配合音效：递归时“滴”声，回溯时“叮”声，调整解成功时“嗡”声，最终解出现时播放“胜利”音效！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度，筛选了以下优质题解，帮你快速理解不同解法的核心！
</eval_intro>

### 题解一：学委的扩展欧几里得详解（来源：综合题解内容）
* **点评**：这是最经典的扩展欧几里得解法，思路推导**极其详细**——从问题转化到裴蜀定理，再到扩展欧几里得的递归过程，每一步都有数学证明。代码用全局变量存储x和y，递归逻辑清晰，最后调整解的方式`(x%b + b)%b`非常规范。它的亮点是**把抽象的数论问题变成了可执行的代码逻辑**，适合入门学习者。

### 题解二：沙普绿12138的欧拉函数+快速幂（来源：综合题解内容）
* **点评**：这是另一种思路——利用**欧拉定理**（`a^φ(b) ≡ 1 mod b`，φ是欧拉函数），推导出`x ≡ a^(φ(b)-1) mod b`。代码先求φ(b)（分解质因数计算），再用快速幂求`a^(φ(b)-1) mod b`。它的亮点是**提供了非扩展欧几里得的解法**，适合想拓宽思路的同学，但需要掌握欧拉函数和快速幂的知识。

### 题解三：HasNoName的简洁扩展欧几里得实现（来源：综合题解内容）
* **点评**：代码**极其简洁**，用引用传递x和y，递归函数直接返回gcd值。核心逻辑`y -= a/b*x`非常巧妙，直接对应回溯时的解更新。最后调整解的方式`(x%b + b)%b`确保了最小正整数。它的亮点是**代码的可读性和简洁性**，适合作为模板记忆。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是突破三个核心难点，下面我会帮你逐一拆解！
</difficulty_intro>

### 难点1：问题转化——从同余方程到ax+by=1
**分析**：很多同学会卡在“同余方程怎么变成线性方程”。其实`ax ≡ 1 mod b`的意思是“ax除以b余1”，也就是`ax = b*y + 1`（y是商），移项后就是`ax - b*y = 1`，再把`-y`换成`y`（因为y是整数，负号不影响），就得到`ax + by = 1`。

**解决策略**：记住“同余方程转线性方程”的公式：`a x ≡ c mod m`等价于`a x + m y = c`（y是整数）。

### 难点2：扩展欧几里得的递归实现
**分析**：递归过程中x和y的更新是最抽象的部分。比如，为什么子问题的解`(x2,y2)`能推出当前解`x=y2`、`y=x2 - (a/b)*y2`？其实这是**代数变形**的结果：
- 子问题是`b x2 + (a%b) y2 = gcd(a,b)`；
- 而`a%b = a - (a/b)*b`（整数除法）；
- 代入子问题的方程，展开后和原方程`a x + b y = gcd(a,b)`对比，就能得到x和y的更新公式。

**解决策略**：动手模拟小例子（比如`a=3, b=10`），跟踪递归过程中的x和y变化，就能理解！

### 难点3：调整x为最小正整数解
**分析**：扩展欧几里得求出的x可能是负数（比如`a=3, b=10`，初始解可能是`x=-3`），或者过大（比如`x=17`）。我们需要把它调整到`1 ≤ x < b`的范围。

**解决策略**：利用模运算的性质：`x`加上或减去`b`的整数倍，结果模b不变。所以用`x = (x % b + b) % b`——先取模（处理过大），再加b（处理负数），再取模（确保在0~b-1之间）。

### ✨ 解题技巧总结
1. **问题转化**：同余方程→线性方程（裴蜀定理）；
2. **算法选择**：扩展欧几里得（通用逆元解法，不要求模数是质数）；
3. **解的调整**：`(x % b + b) % b`（万能公式，记下来！）；
4. **代码模板**：扩展欧几里得的递归实现（记熟`x`和`y`的更新逻辑）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用的扩展欧几里得实现**，帮你掌握整体框架！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合多个优质题解的思路，代码简洁高效，涵盖所有核心逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
using namespace std;
typedef long long ll; // 防止溢出

ll x, y; // 存储解的全局变量（或用引用传递）

// 扩展欧几里得算法：求ax + by = gcd(a,b)的解
ll exgcd(ll a, ll b) {
    if (b == 0) { // 递归边界：b=0时，gcd(a,b)=a，解为x=1, y=0
        x = 1;
        y = 0;
        return a;
    }
    ll g = exgcd(b, a % b); // 递归处理子问题
    // 回溯：根据子问题的解，更新当前解
    ll tx = x; // 保存子问题的x（即x2）
    x = y;     // 当前x = 子问题的y（y2）
    y = tx - (a / b) * y; // 当前y = 子问题的x2 - (a/b)*y2
    return g; // 返回gcd(a,b)
}

int main() {
    ll a, b;
    cin >> a >> b;
    exgcd(a, b); // 求解ax + by = 1
    // 调整x为最小正整数解
    x = (x % b + b) % b;
    cout << x << endl;
    return 0;
}
```
* **代码解读概要**：
  1. 定义`exgcd`函数，递归求解`ax + by = gcd(a,b)`；
  2. 递归到`b=0`时，设置基础解`x=1, y=0`；
  3. 回溯时，根据子问题的解更新当前x和y；
  4. 主函数中调用`exgcd`，然后调整x为最小正整数解并输出。


<code_intro_selected>
接下来分析优质题解的核心片段，看看它们的亮点！
</code_intro_selected>

### 题解一：学委的扩展欧几里得实现（来源：综合题解内容）
* **亮点**：用全局变量存储x和y，递归逻辑清晰，注释详细。
* **核心代码片段**：
```cpp
long long x, y; // 全局变量存解

void exgcd(long long a, long long b) {
    if (b == 0) {
        x = 1;
        y = 0; // 基础解
        return;
    }
    exgcd(b, a % b); // 递归子问题
    long long tx = x;
    x = y;
    y = tx - a / b * y; // 更新当前解
}
```
* **代码解读**：
  - 全局变量`x`和`y`避免了参数传递的麻烦（但要注意多线程安全，这里没问题）；
  - 递归到`b=0`时，设置`x=1, y=0`（因为此时`a*1 + 0*y = a = gcd(a,0)`）；
  - 回溯时，`tx`保存子问题的x（即`x2`），然后`x`取子问题的y（`y2`），`y`取`x2 - (a/b)*y2`——这正是扩展欧几里得的核心公式！

* **学习笔记**：全局变量简化了代码，但如果不想用全局变量，可以用**引用传递**（比如`exgcd(ll a, ll b, ll &x, ll &y)`），这也是常见的写法。

### 题解二：沙普绿12138的欧拉函数+快速幂（来源：综合题解内容）
* **亮点**：用欧拉定理求逆元，适合不想用扩展欧几里得的同学。
* **核心代码片段**：
```cpp
// 求欧拉函数φ(n)：小于等于n且与n互质的数的个数
int fai(int n) {
    int ans = 1;
    for (int i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            n /= i;
            ans *= i - 1;
            while (n % i == 0) {
                n /= i;
                ans *= i;
            }
        }
    }
    if (n > 1) ans *= n - 1;
    return ans;
}

// 快速幂：求x^k mod p
int fast_pow(int x, int k, int p) {
    ll ans = 1, quan = x;
    while (k) {
        if (k & 1) ans = ans * quan % p;
        quan = quan * quan % p;
        k >>= 1;
    }
    return (int)ans;
}
```
* **代码解读**：
  - 欧拉函数`fai(n)`：分解n的质因数，根据公式`φ(n) = n * ∏(1-1/p)`（p是n的质因数）计算；
  - 快速幂`fast_pow`：用二进制拆分的方法，快速计算`x^k mod p`（避免超时）；
  - 主函数中，`x = fast_pow(a, fai(b)-1, b)`——根据欧拉定理`a^φ(b) ≡ 1 mod b`，所以`a^(φ(b)-1)`就是a的逆元。

* **学习笔记**：这种方法的前提是`a`和`b`互质（题目满足），但**不适合模数是合数的情况**（扩展欧几里得更通用）。


## 5. 算法可视化：像素动画演示方案

### 🔹 动画主题：《像素数学家的逆元之旅》
**风格**：8位FC红白机风格（像素块、低分辨率、复古色彩），背景是数学实验室，用像素块表示`a`、`b`、`x`、`y`。

### 🔹 核心演示内容
1. **初始化**：
   - 屏幕左侧显示`a=3`（红色像素块）、`b=10`（蓝色像素块）；
   - 右侧显示“目标：求x的最小正整数解”；
   - 控制面板有“单步执行”“自动播放”“重置”按钮，速度滑块（1~5档）。

2. **递归过程**：
   - **步骤1**：处理`(3,10)`→递归到`(10, 3%10=3)`（红色块变成10，蓝色块变成3，伴随“滴”声）；
   - **步骤2**：处理`(10,3)`→递归到`(3, 10%3=1)`（红色块3，蓝色块1，“滴”声）；
   - **步骤3**：处理`(3,1)`→递归到`(1, 3%1=0)`（红色块1，蓝色块0，“滴”声）；
   - **步骤4**：递归边界`b=0`，显示基础解`x=1`（黄色像素块）、`y=0`（绿色像素块），伴随“叮”声。

3. **回溯过程**：
   - **步骤5**：从`(1,0)`回溯到`(3,1)`：`x = 0`（子问题的y），`y = 1 - 3/1*0 = 1`（绿色块变成1，“叮”声）；
   - **步骤6**：回溯到`(10,3)`：`x = 1`（子问题的y），`y = 0 - 10/3*1 = -3`（绿色块变成-3，“叮”声）；
   - **步骤7**：回溯到`(3,10)`：`x = -3`（子问题的y），`y = 1 - 3/10*(-3) = 1`（红色块显示x=-3，“叮”声）。

4. **调整解**：
   - **步骤8**：计算`x = (-3 % 10 + 10) % 10 = 7`（红色块变成7，伴随“嗡”声）；
   - **步骤9**：显示“胜利！最小正整数解是7”，播放复古胜利音效（比如《超级马里奥》的通关声）。

### 🔹 交互与游戏化元素
- **单步执行**：点击一次，走一步，显示当前步骤的文字说明（比如“递归到(10,3)”）；
- **自动播放**：按设定速度（比如2秒/步）自动执行，适合快速浏览；
- **重置**：恢复初始状态，重新开始；
- **音效**：递归时“滴”声，回溯时“叮”声，调整解成功时“嗡”声，胜利时“通关声”；
- **分数系统**：每完成一步得10分，回溯正确得20分，调整解成功得50分，总分100分（激励玩家完成所有步骤）。

### 🔹 技术实现（轻量化）
- 用HTML5 Canvas绘制像素块（比如`fillRect(x, y, 16, 16)`表示一个像素块）；
- 用JavaScript实现递归和回溯的逻辑，控制像素块的位置和颜色；
- 用Web Audio API播放音效（比如`new Audio('beep.mp3').play()`）；
- 控制面板用HTML按钮和滑块，绑定事件监听（比如`button.onclick = () => step()`）。


## 6. 拓展练习与相似问题思考

### 🔹 通用思路迁移
- 扩展欧几里得算法不仅能求逆元，还能解**线性同余方程**（比如`ax ≡ c mod m`）、**不定方程**（比如`ax + by = c`）；
- 逆元的应用：在模运算中，“除以a”等价于“乘以a的逆元”（比如计算`(a*b)/c mod m`，可以变成`a*b*inv(c) mod m`）。

### 🔹 洛谷练习推荐
1. **P3811 【模板】乘法逆元**：直接求多个数的逆元，巩固扩展欧几里得或快速幂的用法；
2. **P2613 【模板】有理数取余**：用逆元处理分数取余，综合应用；
3. **P1090 合并果子**：虽然不是数论问题，但用到了贪心和优先队列，培养算法思维；
4. **P1516 青蛙的约会**：解线性同余方程，扩展欧几里得的实际应用。


## 7. 学习心得与经验分享 (若有)

> **参考经验（来自学委的题解）**：“我在第一次写扩展欧几里得时，总记不住x和y的更新公式，后来动手模拟了`a=3, b=10`的过程，才真正理解——原来回溯时的x和y是子问题的y和x减去(a/b)*y！”
> 
> **点评**：这位作者的经验很实用——**动手模拟小例子**是理解抽象算法的关键！数论问题不要光看公式，要跟踪每一步的变量变化，才能真正掌握。


## 🔚 总结
本次分析的“同余方程”问题，核心是**扩展欧几里得算法**和**逆元求解**。通过问题转化、递归实现、解的调整，我们能快速找到最小正整数解。记住：
- 同余方程→线性方程（裴蜀定理）；
- 扩展欧几里得的递归逻辑（x和y的更新）；
- 解的调整公式`(x%b + b)%b`。

编程能力的提升在于**多练、多模拟、多总结**，下次遇到逆元或线性同余方程的问题，你一定能轻松解决！💪


<conclusion>
本次关于“同余方程”的C++解题分析就到这里。希望这份指南能帮你打通数论的“任督二脉”。下次我们再一起探索更有趣的算法问题！
</conclusion>

---
处理用时：106.27秒
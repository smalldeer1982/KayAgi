# 题目信息

# [CEOI 2002] Royal guards

## 题目描述

从前有一个王国，这个王国的城堡是 $m$ 行 $n$ 列的一个矩形，被分为 $m \times n$ 个方格。一些方格是墙，而另一些是空地。这个王国的国王在城堡里设了一些陷阱，每个陷阱占据一块空地。

一天，国王决定在城堡里布置守卫，他希望安排尽量多的守卫。

守卫们都是经过严格训练的，所以一旦他们发现同行或同列中有人的话，他们立即向那人射击。因此，国王希望能够合理地布置守卫，使他们互相之间不能看见，这样他们就不可能互相射击了。守卫们只能被布置在空地上，不能被布置在陷阱或墙上，且一块空地只能布置一个守卫。如果两个守卫在同一行或同一列，并且他们之间没有墙的话，他们就能互相看见。(守卫就像象棋里的车一样)

你的任务是写一个程序，根据给定的城堡，计算最多可布置多少个守卫，并设计出布置的方案。


## 说明/提示

#### 样例输入输出 1 解释

如图（黑色方格为墙，白色方格为空地，圆圈为陷阱，G表示守卫）

![](https://cdn.luogu.com.cn/upload/image_hosting/zv6sr9xw.png)

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq m, n \leq 200$，$0 \leq a_{i, j} \leq 2$。

## 样例 #1

### 输入

```
3 4
2 0 0 0
2 2 2 1
0 1 0 2
```

### 输出

```
2
1 2
3 3
```

# AI分析结果

# 💡 Kay的C++算法解析：[CEOI2002] Royal guards 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分图最大匹配

🗣️ **初步分析**：  
你可以把这道题想象成「给网格里的“可行区域”牵红线」——每行被墙分成好几段连续的空地（比如样例中第一行的三个0是一段），每列也被墙分成好几段。我们把**行的每一段**看成“男生”，**列的每一段**看成“女生”，每个空地就是“男生”和“女生”之间的红线（表示这里可以放守卫）。我们的目标是牵尽可能多的红线，且每个“男生”和“女生”只能牵一条——这就是**二分图最大匹配**的核心思想！  

在本题中，二分图的左部是「行的连续段」，右部是「列的连续段」。只要两个段的交点是空地（不是墙或陷阱），就连一条边。跑一遍最大匹配，结果就是最多能放的守卫数——因为每个匹配边对应一个守卫，且不会有两个守卫在同一段行或列（也就是不会互相看见）。  

**核心算法流程**：  
1. 遍历网格，给每行的连续空地段编号（比如第一行的三个0编为行段1）；  
2. 遍历网格，给每列的连续空地段编号（比如第一列的两个0编为列段1）；  
3. 对每个空地，用行段编号连向列段编号，建二分图；  
4. 跑匈牙利算法或Dinic算法求最大匹配；  
5. 根据匹配结果输出守卫位置。  

**可视化设计思路**：  
我们用8位像素风做一个“红线牵牵乐”游戏——  
- 网格用像素块表示，墙是黑色，空地是白色，陷阱是灰色；  
- 行段用蓝色像素条标记，列段用粉色像素条标记；  
- 连边时用红色像素线从行段牵到列段；  
- 匹配成功时，红线会“亮起来”，伴随“叮”的音效；  
- 可以单步看分段、连边、匹配的过程，也能自动播放（像“贪吃蛇AI”一样一步步牵红线）。


## 2. 精选优质题解参考

### 题解一：辰星凌（赞16）  
* **点评**：这份题解用匈牙利算法，思路像“给男生女生找对象”一样直白！它先把行和列按墙分段（用`idh`存行段，`idz`存列段），然后空地连边，最后跑匈牙利求最大匹配。代码风格超规范（变量名`idh`、`idz`一看就懂），对分段的逻辑解释得很清楚——遇到墙就重新编号，保证同一段的行/列不会互相干扰。输出方案时直接用匹配关系找原坐标，简单高效！

### 题解二：Rhodoks（赞20）  
* **点评**：这道题解用Dinic算法（网络流）实现二分图匹配，代码有详细注释，像“给每个行段接水管到源点，列段接水管到汇点，空地是中间的水管”。它还贴心地给网格围了一圈墙，避免边界处理出错。代码里`wall`数组记录每个空地对应的行段和列段，建图逻辑清晰，最后通过残余网络找匹配边，输出方案的方法很巧妙！

### 题解三：C_Pos_Princess（赞1）  
* **点评**：这道题解的码风像“整理好的笔记”一样工整！它用`mp1`存行段，`mp2`存列段，连边时直接用`add`函数。最棒的是它提到了“三倍经验”（P1263、P6062、P2825），帮你一次性掌握同类题！代码里`hang`和`lie`数组记录段对应的原行和列，输出方案时直接查数组，超方便！


## 3. 核心难点辨析与解题策略

### 关键点1：如何正确给行和列分段？  
**分析**：如果同一段行/列中间没有墙，放一个守卫就会挡住整段——所以必须把连续的空地分成同一段。比如样例中第一行的三个0是连续的，编为行段1；第二行的墙把第三行的0分成行段2。  
**解决方案**：遍历网格时，遇到墙就重新编号。比如行分段：`for (int i=1; i<=n; i++) for (int j=1; j<=m; j++) if (A[i][j]<2) { if (A[i][j-1]>1) idh[i][j] = ++n1; else idh[i][j] = idh[i][j-1]; }`  

### 关键点2：如何建立二分图模型？  
**分析**：二分图的左部是行段，右部是列段——每个行段只能匹配一个列段（对应一个守卫），每个列段也只能匹配一个行段。空地是行段和列段的交点，所以连边。  
**解决方案**：对每个空地`(i,j)`，用`add(idh[i][j], idz[i][j])`连边（匈牙利算法），或用`add(行段, 列段, 1)`（Dinic算法）。  

### 关键点3：如何输出守卫位置？  
**分析**：匹配结果是“行段x→列段y”，需要找到原网格中对应的空地。比如行段x对应的原行是`hang[x]`，列段y对应的原列是`lie[y]`，交点就是守卫位置。  
**解决方案**：记录每个段对应的原行/列（比如`hang[cnt1] = i`），匹配后用`match[i]`找行段，再查`hang`和`lie`数组。

### ✨ 解题技巧总结  
- **分段技巧**：遇到墙就重新编号，保证同一段的行/列不会互相干扰；  
- **建模技巧**：行段左部、列段右部，空地连边，直接套二分图模板；  
- **输出技巧**：记录段对应的原坐标，匹配后反查即可。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了辰星凌和C_Pos_Princess的思路，用匈牙利算法实现，逻辑清晰，适合入门。  

```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

const int N = 205;
int n, m;
int mp[N][N];          // 网格：0空地，1陷阱，2墙
int row_id[N][N];      // 行段编号
int col_id[N][N];      // 列段编号
int match[N*N];        // 列段匹配的行段
bool vis[N*N];         // 匈牙利算法的访问标记
vector<int> edges[N*N];// 邻接表

// 匈牙利算法：找行段u的增广路
bool dfs(int u) {
    for (int v : edges[u]) {
        if (!vis[v]) {
            vis[v] = true;
            if (match[v] == 0 || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> mp[i][j];

    // 1. 给行分段
    int row_cnt = 0;
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (mp[i][j] == 2) continue; // 墙跳过
            if (j == 1 || mp[i][j-1] == 2)
                row_id[i][j] = ++row_cnt;
            else
                row_id[i][j] = row_id[i][j-1];
        }
    }

    // 2. 给列分段
    int col_cnt = 0;
    for (int j = 1; j <= m; j++) {
        for (int i = 1; i <= n; i++) {
            if (mp[i][j] == 2) continue; // 墙跳过
            if (i == 1 || mp[i-1][j] == 2)
                col_id[i][j] = ++col_cnt;
            else
                col_id[i][j] = col_id[i-1][j];
        }
    }

    // 3. 建边：空地连行段→列段
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (mp[i][j] == 0) // 空地
                edges[row_id[i][j]].push_back(col_id[i][j]);

    // 4. 跑匈牙利算法求最大匹配
    int ans = 0;
    for (int i = 1; i <= row_cnt; i++) {
        memset(vis, 0, sizeof(vis));
        if (dfs(i)) ans++;
    }

    // 5. 输出结果
    cout << ans << endl;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (mp[i][j] == 0 && match[col_id[i][j]] == row_id[i][j])
                cout << i << " " << j << endl;

    return 0;
}
```

* **代码解读概要**：  
  1. 读入网格；  
  2. 给每行的连续空地段编`row_id`（遇到墙重新编号）；  
  3. 给每列的连续空地段编`col_id`；  
  4. 空地连边（行段→列段）；  
  5. 匈牙利算法找最大匹配；  
  6. 输出匹配的交点（守卫位置）。


### 针对各优质题解的片段赏析

#### 题解一：辰星凌（来源：综合题解内容）  
* **亮点**：用`idh`和`idz`清晰记录行/列段，匈牙利算法逻辑直白。  
* **核心代码片段**：  
  ```cpp
  for (int i=1; i<=n; ++i)
      for (int j=1; j<=m; ++j)
          if (A[i][j]<2) // 不是墙
              if (A[i][j-1]>1) idh[i][j] = ++n1; // 前一个是墙，新编号
              else idh[i][j] = idh[i][j-1]; // 同一段
  ```  
* **代码解读**：  
  这段代码是“行分段的关键”——遍历每行，遇到墙（`A[i][j-1]>1`）就给当前空地一个新的行段编号（`++n1`），否则继承前一个空地的编号。比如第一行的三个0，第一个0的前一个是墙，编为`n1=1`，后面两个0继承`1`，所以这三个0是同一段。  
* **学习笔记**：分段的本质是“把连续的空地捆成一个团”，这样团里只能放一个守卫。

#### 题解二：Rhodoks（来源：综合题解内容）  
* **亮点**：用Dinic算法实现网络流，处理大数据更快。  
* **核心代码片段**：  
  ```cpp
  for (int i=1; i<=n; i++)
      for (int j=1; j<=m; j++)
          if (castle[i][j]==0) // 空地
              add(wall[i][j][0], wall[i][j][1]+40000, 1);
  ```  
* **代码解读**：  
  这段代码是“建边的关键”——`wall[i][j][0]`是空地对应的行段编号，`wall[i][j][1]+40000`是列段编号（加40000避免和行段重复）。`add`函数是链式前向星的加边操作，给行段和列段连一条容量1的边。  
* **学习笔记**：网络流建模时，左部点接源点，右部点接汇点，中间边容量1，最大流就是最大匹配。

#### 题解三：C_Pos_Princess（来源：综合题解内容）  
* **亮点**：码风工整，用`hang`和`lie`记录段对应的原坐标，输出方便。  
* **核心代码片段**：  
  ```cpp
  for (int i=1; i<=cnt2; i++)
      if (match[i])
          printf("%d %d\n", hang[match[i]], lie[i]);
  ```  
* **代码解读**：  
  这段代码是“输出方案的关键”——`match[i]`是列段`i`匹配的行段，`hang[match[i]]`是行段对应的原行，`lie[i]`是列段对应的原列，交点就是守卫位置。比如列段`i`对应原列`lie[i]`，行段`match[i]`对应原行`hang[match[i]]`，所以输出`hang[match[i]]`和`lie[i]`。  
* **学习笔记**：记录段对应的原坐标，能快速从匹配结果反查守卫位置。


## 5. 算法可视化：像素动画演示

### 动画演示主题：像素红线牵牵乐（8位FC风格）

### 核心演示内容  
- 网格用16x16像素块表示，墙是黑色（#000000），空地是白色（#FFFFFF），陷阱是灰色（#CCCCCC）；  
- 行段用蓝色像素条（#0000FF）标记在每行的左侧，列段用粉色像素条（#FF00FF）标记在每列的上方；  
- 连边时用红色像素线（#FF0000）从行段牵到列段；  
- 匹配成功时，红色线会闪烁，伴随“叮”的音效；  
- 可以单步看分段→连边→匹配的过程，也能自动播放（像“AI牵红线”一样一步步完成）。

### 动画帧步骤与交互关键点  
1. **初始化**：  
   - 屏幕显示3x4的像素网格（样例输入），墙是黑色，空地是白色，陷阱是灰色；  
   - 控制面板有“开始”“单步”“重置”按钮，速度滑块（1x到5x）；  
   - 8位风格的背景音乐（像《超级马里奥》的背景音）开始播放。  

2. **分段演示**：  
   - 遍历第一行，第一个空地（1,2）的前一个是墙（1,1是2），行段编号1（蓝色条出现）；  
   - 第二个空地（1,3）继承行段1；  
   - 第三个空地（1,4）继承行段1；  
   - 遍历第三行，第一个空地（3,1）的前一个是墙（3,0不存在，视为墙），行段编号2（蓝色条出现）；  
   - 列分段同理，第一列的空地（3,1）编为列段1（粉色条出现），第二列的空地（1,2）编为列段2，第三列的空地（1,3）编为列段3，第三列的空地（3,3）编为列段4。  

3. **连边演示**：  
   - 空地（1,2）连行段1→列段2（红色线出现）；  
   - 空地（1,3）连行段1→列段3（红色线出现）；  
   - 空地（1,4）连行段1→列段？（样例中1,4是0吗？看样例输入第一行是2 0 0 0，所以1,4是0，列段是？假设列段4）；  
   - 空地（3,1）连行段2→列段1（红色线出现）；  
   - 空地（3,3）连行段2→列段3（红色线出现）。  

4. **匹配演示**：  
   - 行段1尝试连列段2（匹配成功，红线闪烁，“叮”）；  
   - 行段2尝试连列段1（匹配成功，红线闪烁，“叮”）；  
   - 结果是2个匹配，对应样例输出的两个守卫。  

5. **交互控制**：  
   - 单步：点击“单步”看每一步分段、连边、匹配；  
   - 自动：点击“自动”，像“贪吃蛇AI”一样快速完成；  
   - 重置：恢复初始状态，重新演示。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
二分图匹配的“分段建模”技巧还能用于：  
1. **棋盘覆盖问题**：用1x2的骨牌覆盖棋盘，有空洞的情况；  
2. **教室安排问题**：多个班级要占用教室，每个班级有时间段，求最多能安排多少班级；  
3. **任务分配问题**：每个工人能做某些任务，求最多能分配多少任务。

### 练习推荐（洛谷）  
1. **洛谷 P2825** - 「局域网」  
   * 🗣️ **推荐理由**：和本题几乎一样，只是把“守卫”换成“路由器”，“墙”换成“无法布线的区域”，练习分段建模。  
2. **洛谷 P6062** - 「Security Camera 3」  
   * 🗣️ **推荐理由**：三倍经验题，把“守卫”换成“摄像头”，思路完全一致，巩固二分图匹配。  
3. **洛谷 P3386** - 「二分图匹配」  
   * 🗣️ **推荐理由**：匈牙利算法模板题，打好基础才能解决复杂问题。


## 7. 学习心得与经验分享 (若有)  
- **来自辰星凌的经验**：“分段时一定要注意边界，比如第一列的前一个是墙（不存在），所以要重新编号。”——这提醒我们处理边界时要“虚拟”一个墙，避免漏编号。  
- **来自Rhodoks的经验**：“用Dinic算法时，节点编号要避免重复（比如行段加40000）。”——这告诉我们建模时要注意节点的唯一性。  


## 结语  
本次关于「Royal guards」的分析就到这里啦！这道题的核心是“把连续段当节点，空地当边”的二分图建模——就像给行和列的“小团体”牵红线，牵得越多，守卫越多。记住：分段要准，建模要对，模板要熟，就能解决这类问题啦！下次我们再一起挑战更难的二分图问题～💪

---
处理用时：90.72秒
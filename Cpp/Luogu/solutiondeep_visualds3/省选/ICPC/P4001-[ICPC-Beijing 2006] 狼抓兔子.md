# 题目信息

# [ICPC-Beijing 2006] 狼抓兔子

## 题目描述

现在小朋友们最喜欢的"喜羊羊与灰太狼"。话说灰太狼抓羊不到，但抓兔子还是比较在行的，而且现在的兔子还比较笨，它们只有两个窝，现在你做为狼王，面对下面这样一个网格的地形：

 ![](https://cdn.luogu.com.cn/upload/pic/11942.png) 

左上角点为 $(1,1)$，右下角点为 $(N,M)$（上图中 $N=3$，$M=4$）。有以下三种类型的道路：

1. $(x,y)\rightleftharpoons(x+1,y)$

2. $(x,y)\rightleftharpoons(x,y+1)$

3. $(x,y)\rightleftharpoons(x+1,y+1)$

道路上的权值表示这条路上最多能够通过的兔子数，道路是无向的。左上角和右下角为兔子的两个窝，开始时所有的兔子都聚集在左上角 $(1,1)$ 的窝里，现在它们要跑到右下角 $(N,M)$ 的窝中去，狼王开始伏击这些兔子。当然为了保险起见，如果一条道路上最多通过的兔子数为 $K$，狼王需要安排同样数量的 $K$ 只狼，才能完全封锁这条道路，你需要帮助狼王安排一个伏击方案，使得在将兔子一网打尽的前提下，参与的狼的数量要最小。因为狼还要去找喜羊羊麻烦。


## 说明/提示

### 数据规模与约定

对于全部的测试点，保证 $3 \leq N,M \leq 1000$，所有道路的权值均为不超过 $10^6$ 的正整数。

## 样例 #1

### 输入

```
3 4
5 6 4
4 3 1
7 5 3
5 6 7 8
8 7 6 5
5 5 5
6 6 6```

### 输出

```
14```

# AI分析结果

---
# 💡 Kay的C++算法解析：狼抓兔子 深入学习指南 💡

<introduction>
  今天我们要解决的是经典的「狼抓兔子」问题！这道题看起来是要切断兔子的逃跑路线，但其实藏着图论里的重要知识点——**平面图的最小割转对偶图最短路**。跟着Kay一步步拆解，你会发现复杂问题也能变得清晰～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（平面图对偶图、最小割-最大流定理）

🗣️ **初步分析**：
解决「狼抓兔子」的关键，是找到**最小割**——也就是用最少的狼封锁边，让左上角(1,1)和右下角(N,M)不连通。根据「最小割=最大流」定理，本来可以用最大流算法，但因为题目中的图是**平面图**（边只在顶点相交），我们可以用更高效的方法：**把原图转成对偶图，求对偶图的最短路**！

简单来说，对偶图的思路像「给蛋糕切分区域」：原图的每个封闭区域（面）变成对偶图的一个点，原图的每条边对应对偶图中连接两个面的边（权值相同）。这样，原图的最小割就等价于对偶图中「左/下边界区域」到「右/上边界区域」的最短路——因为最短路的权值和最小，对应封锁边的狼数最少～

**核心算法流程**：
1. 把原图的每个面（比如网格中的小三角形）编号，作为对偶图的点；
2. 原图的每条边对应对偶图中两个面的边（权值不变）；
3. 对偶图的起点是「左/下边界的虚拟点」，终点是「右/上边界的虚拟点」；
4. 用Dijkstra或SPFA求对偶图的最短路，结果就是原图的最小割。

**可视化设计思路**：
我们会做一个「像素迷宫探险」的动画：
- 用8位像素风格画原图的网格，对偶图的点用彩色方块表示（比如蓝色代表左边界区域，红色代表右边界区域）；
- 原图的边被点击时，对偶图的对应边会闪烁，显示权值；
- 单步执行Dijkstra算法，当前处理的对偶点会高亮，最短距离用数字实时更新；
- 找到最短路时，播放「胜利」像素音效，路径用黄色线条标注。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面，为你筛选了3份优质题解～
</eval_intro>

**题解一：d3ac的最短路解法（来源：综合题解内容）**
* **点评**：这份题解直接抓住了「平面图转对偶图」的核心，用Dijkstra算法求最短路，思路非常清晰。代码中通过`add`函数构建对偶图的边，`dijkstra`函数标准且高效。特别的是，题解里详细处理了原图三种边（横、竖、斜）对应的对偶边，避免了建图错误，非常适合入门学习。

**题解二：LiRewriter的Dinic最大流解法（来源：综合题解内容）**
* **点评**：这道题的经典最大流解法，用Dinic算法实现。代码规范，`add_edge`函数正确处理了无向边的反向弧（权值设为原边权），`BFS`分层和`DFS`增广的逻辑清晰。虽然最大流在大规模数据下可能不如对偶图高效，但这份代码是理解「最小割=最大流」的好例子。

**题解三：Imakf的对偶图最短路解法（来源：综合题解内容）**
* **点评**：题解用「对偶图的连通性对应原图的割边」的思路，把问题转化为对偶图的最短路。代码中`getheng`、`getshu`、`getxie`函数分别处理三种边的建图，逻辑严谨。特别的是，题解处理了`n=1`或`m=1`的边界情况，考虑周全。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键难点在于「对偶图的建图」——如何把原图的边正确映射到对偶图的点和边。以下是三个核心难点及解决方法：
</difficulty_intro>

1. **难点1：对偶图的点编号**  
   * **分析**：原图的每个面对应对偶图的一个点，但面的编号容易混乱。比如网格中的小三角形区域，需要按行或列有序编号。  
   * **解决方法**：用公式统一编号，比如`id(i,j)`表示第i行第j列的面，避免重复或遗漏。  
   * 💡 **学习笔记**：有序编号是建图的基础，提前画草稿纸标注面的编号能减少错误！

2. **难点2：原图边与对偶边的对应**  
   * **分析**：原图的横、竖、斜边对应对偶图中不同的边，比如横边对应对偶图中上下两个面的边，竖边对应左右两个面的边。  
   * **解决方法**：分类处理三种边：  
     - 横边（x,y）↔(x+1,y)：对应对偶图中上下两个面的边；  
     - 竖边（x,y）↔(x,y+1)：对应对偶图中左右两个面的边；  
     - 斜边（x,y）↔(x+1,y+1)：对应对偶图中同一面内的两个点的边。  
   * 💡 **学习笔记**：把原图的边按类型分组，每组对应对偶图的固定边，能避免混淆！

3. **难点3：边界条件的处理**  
   * **分析**：当N=1或M=1时，原图变成一条线，对偶图的建图逻辑需要调整（比如直接找最小边权）。  
   * **解决方法**：在代码开头判断边界情况，直接返回最小边权，不需要建对偶图。  
   * 💡 **学习笔记**：边界情况往往是测试点的坑，提前处理能避免超时或错误！


### ✨ 解题技巧总结
- **技巧A：平面图转对偶图**：遇到网格类最小割问题，先想是否是平面图，若是则转对偶图求最短路，效率更高。  
- **技巧B：分类建边**：把原图的边按类型（横、竖、斜）分组，每组对应对偶图的固定边，减少建图错误。  
- **技巧C：边界条件优先处理**：先判断N=1或M=1的情况，直接返回最小边权，简化逻辑。  


## 4. C++核心代码实现赏析

<code_intro_overall>
首先，我们来看一份**对偶图+Dijkstra**的通用核心实现，它综合了优质题解的思路，清晰展示了整个解题流程～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了对偶图建图和Dijkstra算法的核心逻辑，处理了三种边的映射和边界条件，是解决本题的典型实现。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <cstring>
  using namespace std;

  typedef pair<int, int> PII;
  const int MAXN = 2e6 + 10;
  const int INF = 0x3f3f3f3f;

  vector<PII> g[MAXN];  // 对偶图：g[u]存储(v, w)
  int dis[MAXN], vis[MAXN];
  int n, m, s, t;

  void add_edge(int u, int v, int w) {
      g[u].push_back({v, w});
      g[v].push_back({u, w});
  }

  void dijkstra() {
      priority_queue<PII, vector<PII>, greater<PII>> pq;
      memset(dis, 0x3f, sizeof(dis));
      memset(vis, 0, sizeof(vis));
      dis[s] = 0;
      pq.push({0, s});
      while (!pq.empty()) {
          auto [d, u] = pq.top(); pq.pop();
          if (vis[u]) continue;
          vis[u] = 1;
          for (auto [v, w] : g[u]) {
              if (dis[v] > dis[u] + w) {
                  dis[v] = dis[u] + w;
                  pq.push({dis[v], v});
              }
          }
      }
  }

  int main() {
      cin >> n >> m;
      if (n == 1 || m == 1) {  // 边界情况：一行或一列
          int min_w = INF;
          int cnt = (n == 1) ? (m-1) : (n-1);
          for (int i = 0; i < cnt; ++i) {
              int w; cin >> w;
              min_w = min(min_w, w);
          }
          cout << min_w << endl;
          return 0;
      }
      // 对偶图的起点s和终点t
      s = 0;
      t = 2 * (n-1) * (m-1) + 1;
      // 处理横边（原图的左右边）
      for (int i = 1; i <= n; ++i) {
          for (int j = 1; j < m; ++j) {
              int w; cin >> w;
              if (i == 1) add_edge(s, j*2, w);  // 第一行横边连起点
              else if (i == n) add_edge((n-2)*(m-1)*2 + (j-1)*2 + 1, t, w);  // 最后一行横边连终点
              else add_edge((i-2)*(m-1)*2 + (j-1)*2 + 1, (i-1)*(m-1)*2 + (j-1)*2 + 2, w);  // 中间行横边
          }
      }
      // 处理竖边（原图的上下边）
      for (int i = 1; i < n; ++i) {
          for (int j = 1; j <= m; ++j) {
              int w; cin >> w;
              if (j == 1) add_edge((i-1)*(m-1)*2 + 1, t, w);  // 第一列竖边连终点
              else if (j == m) add_edge(s, i*(m-1)*2, w);  // 最后一列竖边连起点
              else add_edge((i-1)*(m-1)*2 + (j-1)*2, (i-1)*(m-1)*2 + (j-1)*2 + 1, w);  // 中间列竖边
          }
      }
      // 处理斜边（原图的斜向边）
      for (int i = 1; i < n; ++i) {
          for (int j = 1; j < m; ++j) {
              int w; cin >> w;
              add_edge((i-1)*(m-1)*2 + (j-1)*2 + 1, (i-1)*(m-1)*2 + (j-1)*2 + 2, w);  // 斜边对应对偶图的边
          }
      }
      dijkstra();
      cout << dis[t] << endl;
      return 0;
  }
  ```
* **代码解读概要**：
  1. **对偶图建图**：用`add_edge`函数连接对偶图的点，分别处理横、竖、斜三种边，对应到对偶图的不同点；
  2. **Dijkstra算法**：用优先队列求对偶图中起点`s`到终点`t`的最短路；
  3. **边界处理**：当N=1或M=1时，直接找最小边权，避免建图。


---

<code_intro_selected>
接下来，我们赏析优质题解中的核心片段，看看它们的亮点～
</code_intro_selected>

**题解一：d3ac的最短路解法**
* **亮点**：用简洁的`add`函数统一建边，处理了所有类型的边，逻辑清晰。
* **核心代码片段**：
  ```cpp
  void add(int u, int v, int w) {
      edge[++k].next = head[u];
      edge[k].to = v;
      edge[k].w = w;
      head[u] = k;
  }
  ```
* **代码解读**：
  这个函数是对偶图的建边工具！`u`和`v`是对偶图的点，`w`是边的权值（对应原图边的容量）。通过`head`数组存储邻接表，`edge`结构体保存边的信息。看似简单，但它统一了所有边的建图逻辑，避免了重复代码～
* 💡 **学习笔记**：用邻接表存储图是图论的基础，`add`函数能让代码更简洁！

**题解二：LiRewriter的Dinic算法**
* **亮点**：正确处理了无向边的反向弧，`DFS`中的「当前弧优化」提升了效率。
* **核心代码片段**：
  ```cpp
  int dfs(int u, int flow) {
      if (u == ed) return flow;
      int add = 0;
      for (int i = head[u]; i != -1 && add < flow; i = edge[i].nxt) {
          int v = edge[i].to;
          if (rank[v] != rank[u] + 1 || !edge[i].va) continue;
          int tmpadd = dfs(v, min(edge[i].va, flow - add));
          if (!tmpadd) { rank[v] = -1; continue; }
          edge[i].va -= tmpadd; edge[i ^ 1].va += tmpadd;
          add += tmpadd;
      }
      return add;
  }
  ```
* **代码解读**：
  这是Dinic算法的`DFS`增广部分！`u`是当前点，`flow`是剩余流量。`rank[v] == rank[u]+1`保证走层次递增的边（避免循环），`edge[i].va`是边的剩余容量。`edge[i^1].va += tmpadd`是反向弧的更新——无向边的反向弧初始容量等于原边容量，这样可以允许「反悔」操作（比如撤销之前的流量分配）。
* 💡 **学习笔记**：反向弧是最大流算法的关键，它让算法能调整之前的选择！


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了让你更直观理解「对偶图的最短路」，Kay设计了一个**像素风格的动画**——「对偶图探险队」！用FC游戏的复古风格，一步步演示对偶图的建图和最短路的寻找过程～
\</visualization\_intro\>

### 动画设计细节
* **主题**：像素探险队在对偶图中寻找从「左边界基地」（起点）到「右边界城堡」（终点）的最短路径，封锁兔子的逃跑路线。
* **核心演示内容**：
  1. **场景初始化**：屏幕左侧是原图的网格（像素块组成），右侧是对偶图的点（彩色方块）。顶部有「开始/单步/重置」按钮，底部有速度滑块。
  2. **建图演示**：点击原图的边（比如横边），右侧对偶图的对应边会闪烁，显示权值（比如「横边权值5」），同时播放「叮」的像素音效。
  3. **最短路执行**：
     - 点击「单步」：当前处理的对偶点会高亮（比如蓝色变红色），最短距离`dis`会实时显示在点的下方；
     - 点击「自动播放」：算法会按Dijkstra的顺序扩展最短路，每找到一个更短的路径，对应边会显示「→」箭头，播放「咻」的音效；
     - 找到终点时，路径会用黄色线条标注，播放「胜利」音效（类似FC游戏的通关音乐）。
* **游戏化元素**：
  - **关卡设计**：把建图分成「横边关」「竖边关」「斜边关」，完成每关会弹出「通关！」提示，增加成就感；
  - **积分系统**：单步执行时，每正确处理一个点得10分，自动播放时得5分，鼓励手动思考；
  - **音效**：建边时「叮」，最短路扩展时「咻」，通关时「噔噔噔」，失败时「嗡」，增强沉浸感。
* **技术实现**：用HTML5 Canvas绘制像素图形，JavaScript实现Dijkstra算法的单步执行，Web Audio API播放音效。所有代码打包成一个HTML文件，本地双击就能运行～


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握了「平面图转对偶图」的思路，你可以解决更多类似问题！以下是几个拓展练习：
\</similar\_problems\_intro\>

### 通用思路迁移
平面图的最小割问题，都可以用「对偶图转最短路」解决！比如：
- 网格中的管道切割问题（切断管道让两个城市不连通，求最小代价）；
- 电路板的导线切割问题（切断导线让两个芯片不连通，求最小代价）。

### 练习推荐 (洛谷)
1. **洛谷 P1344 追查坏牛奶**：  
   🗣️ **推荐理由**：这是一道经典的最小割问题，需要建图求最大流，能巩固「最小割=最大流」的理解。
2. **洛谷 P2296 寻找道路**：  
   🗣️ **推荐理由**：这道题需要找最短路径，但路径上的点必须满足条件，能锻炼你对「最短路算法的变形」的掌握。
3. **洛谷 P3376 【模板】最大流**：  
   🗣️ **推荐理由**：Dinic算法的模板题，能让你熟练掌握最大流的实现，对比对偶图的解法，理解两种方法的差异。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
很多题解作者都提到了「建图的重要性」——比如d3ac说「对偶图的建图是关键，一定要画图标注」，LiRewriter说「反向弧的处理不能错，否则最大流会算错」。这些经验都很宝贵：
\</insights\_intro\>

> **参考经验 (来自d3ac)**：「我一开始建图时把横边和竖边的对应关系搞反了，结果答案一直错。后来画了一张草稿纸，把每个面的编号标出来，才找到错误。」  
> **点评**：画图是解决图论问题的好帮手！尤其是对偶图的建图，草稿纸能让抽象的关系变得直观～

> **参考经验 (来自LiRewriter)**：「Dinic算法的当前弧优化很重要，没有它的话，大规模数据会超时。」  
> **点评**：算法的优化能提升效率，但前提是理解算法的核心逻辑。先掌握基础版本，再学优化！


\<conclusion\>
「狼抓兔子」的问题，本质是平面图的最小割，但通过「对偶图转最短路」的技巧，我们把复杂的最大流问题转化为熟悉的最短路问题。关键是**对偶图的建图**——只要正确映射原图的边，剩下的就是套最短路模板啦！

记住：图论的问题，画图和总结是关键～多画草稿纸，多做类似练习，你会越来越熟练！下次我们再一起探索更有趣的图论问题～💪
\</conclusion\>

---
处理用时：89.11秒
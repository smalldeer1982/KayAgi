# 题目信息

# [ICPC 2019 WF] First of Her Name

## 题目描述

众所周知，皇室家族的名字非常有讲究。而作为研究皇室的历史学家的你，最近接到了一个艰巨的任务——分析王国历史中所有皇室夫人的名字。



王国历史上有 $n$ 位皇室夫人，方便起见，我们将其从 $1$ 至 $n$ 编号。除了 $1$ 号夫人外，其余夫人的名字均为一个大写字母连接着她母亲的名字。而 $1$ 号夫人作为王国的首任王后，她的名字只有一个大写字母。



例如，由于 `AENERYS` 由 `A` 与 `ENERYS` 组成，因此 `ENERYS` 是 `AENERYS` 的母亲。相似地，`AENERYS` 是 `DAENERYS` 与 `YAENERYS` 的母亲。



你知道王国历史上所有皇室夫人的姓名与关系，而你需要完成的任务是，对于其他历史学家感兴趣的名字串 $s$，总共有多少位夫人的名字是以 $s$ 起始的。



例如在样例的皇室族谱中，`S` 至 `AENERYS` 的这一支（包含 `YS`、`RYS`、`ERYS`、`NERYS` 与 `ENERYS` 这几位夫人）均只有一位女儿。接下来 `AENERYS` 有两位女儿，分别是 `DAENERYS`，以及女儿是 `RYAENERYS` 的 `YAENERYS`。



在这个皇室家族内，有两位夫人的名字以 `RY` 起始，她们是 `RYS` 与 `RYAENERYS`。而 `ERYS` 与 `ENERYS` 均以 `E` 起始。名字以 `N` 起始的仅有一位夫人 `NERYS`。同样地，以 `S` 起始的仅有首位王后 `S`。而没有任何一位夫人的名字以 `AY` 起始。

## 说明/提示

$1\leq n\leq 10^6$，$1\leq k\leq 10^6$，$p_1=0$，特别地，对于 $1\lt i\leq n$，保证有 $1\leq p_i\lt i$。感兴趣的名字串总长不超过 $10^6$。

## 样例 #1

### 输入

```
10 5
S 0
Y 1
R 2
E 3
N 4
E 5
A 6
D 7
Y 7
R 9
RY
E
N
S
AY```

### 输出

```
2
2
1
1
0```

# AI分析结果

# 💡 Kay的C++算法解析：[ICPC 2019 WF] First of Her Name 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串处理（Trie树、AC自动机/广义后缀自动机）


🗣️ **初步分析**：  
想象一下，所有夫人的名字组成了一棵“名字家族树”——每个节点代表一个名字前缀，比如“E”是“ERYS”的前缀，“ER”是“ERYS”的更长前缀。但题目要查询**以某个串开头**的名字数量，直接遍历所有名字会因为1e6的规模超时。这时候，我们需要“字符串超级工具”：  
- **Trie树**：像家族树一样存储所有名字的前缀，每个节点对应一个前缀；  
- **AC自动机**：给Trie树加“失败指针”，能快速处理多模式（多个查询串）的匹配；  
- **广义后缀自动机（SAM）**：把多个字符串的后缀合并成一个高效结构，适合统计后缀相关的数量。  

本题的**关键技巧**是：**翻转字符串**——因为原名字是“母亲名字前加字母”，翻转后变成“母亲名字后加字母”，这样前缀查询就变成了**后缀查询**（比如查询“RY”前缀，翻转后是“YR”，相当于找名字翻转后以“YR”结尾的数量）。这一步转化让我们能直接用Trie/AC自动机/SAM处理大规模数据。  

**核心算法流程**：  
1. 翻转所有名字和查询串，将前缀问题→后缀问题；  
2. 构建Trie树（或广义SAM）存储所有翻转后的名字；  
3. 用AC自动机（或SAM）处理查询串，统计每个查询串对应的后缀出现次数（通过fail树/parent树的子树和计算）。  

**可视化设计思路**：  
我们会做一个“像素名字家族树”动画——用8位像素块代表Trie节点，不同颜色代表不同字母；翻转字符串时，像素块会“倒转”排列；AC自动机的失败指针用虚线连接，查询时当前匹配的节点会闪烁，子树和统计时节点颜色逐渐变深（越深代表数量越多）。还会加复古音效：插入节点“叮”一声，匹配成功“嗡”一声，统计完成“叮铃”一声～


## 2. 精选优质题解参考

为大家筛选了3份思路清晰、代码高效的题解，覆盖AC自动机和广义SAM两种主流方法：


### 题解一：AC自动机（作者：CYJian，赞7）
* **点评**：这份题解把问题转化得非常巧妙——先翻转字符串，将前缀查询变成后缀查询，然后用AC自动机处理多模式匹配。代码结构清晰，用Trie树存储所有翻转后的名字，AC自动机的fail树统计子树和（每个查询串对应的数量就是其在fail树中的子树节点数之和）。特别适合大规模数据，时间复杂度是线性的（O(n + k + 总查询长度)），完全能处理1e6的规模。


### 题解二：广义后缀自动机（作者：251Sec，赞2）
* **点评**：广义SAM是处理多字符串后缀问题的“终极工具”。这份题解直接把翻转后的名字插入SAM，每个名字对应SAM中的一个节点，然后通过parent树（SAM的后缀链接树）统计子树和——每个查询串对应的数量就是其在SAM中对应的节点的子树和。代码简洁，没有冗余，适合理解SAM的应用场景。


### 题解三：AC自动机（作者：SDqwq，赞1）
* **点评**：这份题解和CYJian的思路一致，但代码更注重可读性。比如用`pos`数组存储每个节点的位置，`siz`数组统计子树和，步骤更直观。特别适合刚学AC自动机的同学，能清晰看到“插入名字→构建fail树→统计子树和”的完整流程。


## 3. 核心难点辨析与解题策略

### 关键点1：如何处理1e6的大规模数据？
* **难点**：普通的前缀遍历（比如每个查询遍历所有名字）会超时（O(nk)时间）。  
* **解决**：用**线性时间结构**（AC自动机/广义SAM），预处理时间O(n + 总查询长度)，查询时间O(k + 总查询长度)。


### 关键点2：如何将前缀查询转化为可处理的问题？
* **难点**：原名字是“前缀添加”（母亲名字前加字母），直接建Trie树会导致查询前缀需要遍历所有长名字的前缀，效率低。  
* **解决**：**翻转字符串**！比如原名字“RYAENERYS”翻转后是“SYRENEYAR”，查询“RY”前缀→翻转后是“YR”，相当于找翻转后的名字以“YR”结尾的数量（这正是AC自动机/SAM擅长的）。


### 关键点3：如何高效统计每个查询的数量？
* **难点**：即使找到匹配的节点，直接统计所有子节点会超时。  
* **解决**：**子树和统计**——AC自动机的fail树或SAM的parent树中，每个节点的子树和就是该节点对应的模式串的出现次数。比如AC自动机中，查询串对应的节点的子树和，就是所有以该串为后缀的名字数量（即原问题中以该串为前缀的数量）。


💡 **解题技巧总结**：  
- 遇到**大规模前缀/后缀查询**，先想“翻转字符串”转化问题；  
- 多模式匹配优先用AC自动机，后缀统计优先用SAM；  
- 统计子树和时，用DFS或拓扑排序（因为fail树/parent树是树结构）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用AC自动机实现**，综合了CYJian和SDqwq的思路，适合快速理解核心逻辑：
</code_intro_overall>


### 本题通用核心C++实现参考
* **说明**：本代码将翻转字符串、Trie树构建、AC自动机处理、子树和统计整合，是处理大规模前缀查询的典型模板。
* **完整核心代码**：
```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <cctype>
using namespace std;

const int MAXN = 1e6 + 10;

// Trie树结构（存储翻转后的名字）
int trie[MAXN][26], trie_idx = 0;
// AC自动机结构
int ac_tr[MAXN][26], ac_fail[MAXN], ac_cnt[MAXN], ac_idx = 0;
vector<int> ac_edges[MAXN]; // fail树的边
int query_pos[MAXN]; // 每个查询串在AC自动机中的位置

// 插入字符串到AC自动机（翻转后的查询串）
int ac_insert(string s) {
    int p = 0;
    for (char c : s) {
        int idx = c - 'A';
        if (!ac_tr[p][idx]) ac_tr[p][idx] = ++ac_idx;
        p = ac_tr[p][idx];
    }
    return p;
}

// 构建AC自动机的fail指针
void ac_build() {
    queue<int> q;
    for (int i = 0; i < 26; i++)
        if (ac_tr[0][i]) q.push(ac_tr[0][i]);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = 0; i < 26; i++) {
            int v = ac_tr[u][i];
            if (v) {
                ac_fail[v] = ac_tr[ac_fail[u]][i];
                q.push(v);
            } else {
                ac_tr[u][i] = ac_tr[ac_fail[u]][i];
            }
        }
    }
    // 构建fail树的边
    for (int i = 1; i <= ac_idx; i++)
        ac_edges[ac_fail[i]].push_back(i);
}

// DFS统计fail树的子树和
void ac_dfs(int u) {
    for (int v : ac_edges[u]) {
        ac_dfs(v);
        ac_cnt[u] += ac_cnt[v];
    }
}

// 遍历Trie树，更新AC自动机的计数
void trie_dfs(int trie_u, int ac_u) {
    ac_cnt[ac_u]++; // 当前节点计数+1
    for (int i = 0; i < 26; i++) {
        if (trie[trie_u][i]) {
            int next_ac = ac_tr[ac_u][i];
            trie_dfs(trie[trie_u][i], next_ac);
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, k;
    cin >> n >> k;

    // 1. 构建Trie树（存储翻转后的名字：原名字是母亲前加字母→翻转后是母亲后加字母）
    for (int i = 1; i <= n; i++) {
        char c; int p;
        cin >> c >> p;
        // p是母亲的编号（翻转后的Trie节点），当前节点是i
        trie[p][c - 'A'] = i;
    }

    // 2. 处理查询串：翻转后插入AC自动机
    for (int i = 1; i <= k; i++) {
        string s;
        cin >> s;
        reverse(s.begin(), s.end()); // 翻转查询串
        query_pos[i] = ac_insert(s);
    }

    // 3. 构建AC自动机的fail指针
    ac_build();

    // 4. 遍历Trie树，更新AC自动机的计数
    trie_dfs(0, 0); // Trie根是0，AC自动机根是0

    // 5. 统计fail树的子树和
    ac_dfs(0);

    // 6. 输出结果
    for (int i = 1; i <= k; i++) {
        cout << ac_cnt[query_pos[i]] << '\n';
    }

    return 0;
}
```
* **代码解读概要**：  
  1. **Trie树构建**：存储所有翻转后的名字（原名字是母亲前加字母→翻转后是母亲后加字母，直接用Trie存储）；  
  2. **AC自动机构建**：插入翻转后的查询串，加fail指针；  
  3. **计数更新**：遍历Trie树，将每个名字的节点计数更新到AC自动机；  
  4. **子树和统计**：通过DFS计算fail树的子树和，得到每个查询串的数量。


<code_intro_selected>
接下来看两份优质题解的核心片段，感受不同方法的巧妙之处：
</code_intro_selected>


### 题解一：AC自动机（作者：CYJian）
* **亮点**：用Trie树直接存储原名字（翻转后的结构），AC自动机处理查询，代码简洁高效。
* **核心代码片段**：
```cpp
// 构建Trie树（原名字是母亲前加字母→翻转后是母亲后加字母，直接存储）
for (int i = 1; i <= n; i++) {
    char ch = getchar();
    while (!isalpha(ch)) ch = getchar();
    int p = getint(); // 母亲的编号
    trie[p][ch - 'A'] = i; // 当前节点i是母亲p的子节点（翻转后的结构）
}

// 插入查询串到AC自动机（翻转后）
for (int i = 1; i <= k; i++) {
    char ch = getchar(); int len = 0;
    while (!isalpha(ch)) ch = getchar();
    while (isalpha(ch)) str[++len] = ch, ch = getchar();
    reverse(str + 1, str + len + 1); // 翻转查询串
    pos[i] = ac_insert(len); // 插入AC自动机
}

// 遍历Trie树，更新AC自动机计数
void dfs(int x, int y) {
    ac.cnt[y]++; // y是AC自动机的节点，计数+1
    for (int c = 0; c < 26; c++)
        if (trie[x][c]) dfs(trie[x][c], ac.tr[y][c]);
}
```
* **代码解读**：  
  - 为什么`triple[p][ch-'A'] = i`？因为原名字是“母亲p的名字前加ch”，翻转后是“母亲p的名字后加ch”，所以Trie树中p是母亲节点，i是子节点（对应翻转后的结构）。  
  - `dfs(x,y)`函数：x是Trie树的节点，y是AC自动机的节点，遍历Trie树时，将每个节点的计数更新到AC自动机（`ac.cnt[y]++`）。  
* **学习笔记**：翻转后的Trie结构和原名字的关系要理清楚，这是AC自动机能工作的关键！


### 题解二：广义后缀自动机（作者：251Sec）
* **亮点**：用广义SAM直接处理翻转后的名字，代码更简洁，适合处理多字符串后缀问题。
* **核心代码片段**：
```cpp
// 广义SAM的插入函数（每个字符插入到母亲的SAM节点后）
int Ins(int c, int las) {
    int s = ++cnt, p = las;
    f[s].len = f[las].len + 1;
    for (; p && !f[p].ch[c]; p = f[p].prt) f[p].ch[c] = s;
    if (!p) f[s].prt = 1;
    else {
        int q = f[p].ch[c];
        if (f[q].len == f[p].len + 1) f[s].prt = q;
        else {
            int r = ++cnt;
            f[r] = f[q]; f[r].len = f[p].len + 1;
            while (p && f[p].ch[c] == q) { f[p].ch[c] = r; p = f[p].prt; }
            f[q].prt = f[s].prt = r;
        }
    }
    return s;
}

// 主函数中的处理：
id[0] = 1; // SAM的初始状态是1
for (int i = 1; i <= n; i++) {
    char c; int p;
    cin >> c >> p;
    id[i] = Ins(c - 'A', id[p]); // 插入当前字符到母亲的SAM节点后
    w[id[i]]++; // 每个节点的计数+1（代表该后缀的出现次数）
}

// 统计parent树的子树和（SAM的parent树是后缀链接树）
void DFS(int u) {
    for (int i = head[u]; i; i = e[i].next) {
        int v = e[i].to;
        DFS(v);
        w[u] += w[v]; // 子树和累加
    }
}
```
* **代码解读**：  
  - 广义SAM的`Ins`函数：将字符c插入到母亲的SAM节点`las`后，生成新节点s，处理后缀链接（prt）；  
  - `w[id[i]]++`：每个节点的计数代表该后缀的出现次数（比如节点s对应某个后缀，w[s]是该后缀出现的次数）；  
  - `DFS`函数：统计parent树的子树和——因为parent树中，子节点的后缀是父节点的后缀的延长，所以子树和就是该后缀的总出现次数。  
* **学习笔记**：广义SAM的“后缀链接树”（parent树）是统计后缀出现次数的关键，子树和直接对应查询结果！


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素名字家族树大冒险
**设计思路**：用8位像素风格还原名字家族树的构建、翻转、查询过程，加入游戏化元素（比如“闯关”解锁自动机功能），让学习更有趣！


### 📺 动画帧步骤与交互关键点
1. **场景初始化**（FC复古风）：  
   - 屏幕左侧是**像素Trie树**（用不同颜色的方块代表节点，比如红色=S、黄色=Y、蓝色=R），右侧是**AC自动机面板**（显示fail指针和查询串）；  
   - 控制面板有“单步执行”“自动播放”“重置”按钮，速度滑块（从“龟速”到“光速”），还有“翻转开关”（点击后Trie树倒转）。
2. **Trie树构建**：  
   - 每次插入节点（比如插入Y到S的子节点），像素块会从母亲节点“生长”出来，伴随“叮”的音效；  
   - 节点上显示对应的字母（比如Y节点显示“Y”），母亲节点和子节点用实线连接。
3. **翻转字符串**：  
   - 点击“翻转开关”，Trie树会“倒转”——比如原树是S→Y→R→E，翻转后变成E→R→Y→S，像素块会从右往左重新排列，伴随“哗啦”的音效。
4. **AC自动机构建**：  
   - 插入查询串（比如“RY”→翻转后“YR”），AC自动机面板会逐个显示字符，节点闪烁，伴随“滴”的音效；  
   - 构建fail指针时，用虚线连接节点（比如“YR”的fail指针指向“R”），虚线闪烁，伴随“咻”的音效。
5. **查询与统计**：  
   - 点击“自动播放”，查询串会在AC自动机中“跑”起来——当前匹配的节点闪烁，匹配成功时节点颜色变深（比如“YR”匹配到两个节点，颜色变深两次）；  
   - 统计子树和时，fail树的子节点会“传递”颜色（父节点颜色逐渐变深），完成时伴随“叮铃”的胜利音效。
6. **游戏化元素**：  
   - **闯关模式**：完成Trie构建→翻转字符串→AC自动机构建→查询统计，每一步是一个“小关”，通关后获得“像素星星”奖励；  
   - **AI演示**：点击“AI自动玩”，动画会自动完成所有步骤，像“贪吃蛇AI”一样找到最优解。


### 🛠️ 技术实现（轻量化）
用纯HTML+CSS+JavaScript（Canvas API）实现：  
- **Trie树绘制**：用`ctx.fillRect`画像素块，`ctx.fillText`写字母；  
- **翻转动画**：用`transform: scaleX(-1)`实现倒转效果；  
- **音效**：用`Audio`对象播放8位音频（比如“叮”用`new Audio('ding.wav')`）；  
- **交互**：用`addEventListener`处理按钮点击，`requestAnimationFrame`实现流畅动画。


## 6. 拓展练习与相似问题

### 🧠 通用思路迁移
本题的**翻转+自动机/SAM**技巧可以解决很多大规模前缀/后缀问题，比如：  
- 统计多个字符串中以某个串开头的数量；  
- 文本编辑器中的“前缀联想”功能（快速找到以输入串开头的单词）；  
- 日志分析中的“关键字前缀匹配”（比如找所有以“ERROR:”开头的日志行数）。


### 📚 洛谷相似题目推荐
1. **P3808 【模板】AC自动机（简单版）**  
   🗣️ 推荐理由：AC自动机的基础模板题，练习多模式匹配的基本流程，适合巩固本题的AC自动机思路。
2. **P6139 【模板】广义后缀自动机**  
   🗣️ 推荐理由：广义SAM的基础模板题，练习用SAM处理多个字符串的后缀统计，对应本题的广义SAM思路。
3. **P5357 【模板】AC自动机（二次加强版）**  
   🗣️ 推荐理由：AC自动机的进阶题，需要处理更大规模的数据（1e6节点），和本题的难度一致，适合检验掌握程度。
4. **P2414 [NOI2011] 阿狸的打字机**  
   🗣️ 推荐理由：AC自动机的经典应用题，结合fail树的子树查询，和本题的“子树和统计”思路一致，适合拓展。


## 7. 学习心得与经验分享 (若有)

> **参考经验（来自CYJian的题解注释）**：“一开始没想到翻转字符串，直接建Trie树查询前缀，结果超时了。后来想通了——原名字是前缀添加，翻转后变成后缀添加，正好符合Trie的结构！”  
> **点评**：这位作者的踩坑经历很典型！遇到前缀问题时，不妨试试“翻转”转化为后缀问题，很多时候能打开思路。另外，处理大规模数据时，一定要想“线性时间结构”（比如AC自动机、SAM），避免暴力遍历。


## 8. 总结
本次分析的“First of Her Name”题，核心是**将前缀问题转化为后缀问题**，并用AC自动机/广义SAM高效处理。通过翻转字符串，我们把“难处理的前缀”变成了“好处理的后缀”，再用自动机的子树和统计得到结果。  

记住：**字符串问题的关键是“结构转化”**——把问题变成自动机/SAM能处理的形式，就能轻松应对大规模数据！  

下次遇到类似的字符串前缀/后缀查询题，试试翻转+自动机/SAM，你会发现“难问题”也能变得简单～💪


💡 最后提醒：编程能力的提升在于“动手写”——把AC自动机和SAM的模板敲一遍，再做几道拓展题，你就能掌握这些“字符串超级工具”啦！下次我们再一起解决更难的字符串问题～😉

---
处理用时：115.49秒
# 题目信息

# [ICPC 2020 Nanjing R] Degree of Spanning Tree

## 题目描述

给定一张 $n$ 个点 $m$ 条边的无向图，求一个生成树满足每个点的度数都不大于 $\frac{n}{2}$。

## 说明/提示

$2 \leq n \leq 10^5$，$n - 1\leq m \leq 2\times10^5$，$\sum n\leq5\times10^5$，$\sum m\leq10^6$。

保证图连通。

## 样例 #1

### 输入

```
2
6 9
1 2
1 3
1 4
2 3
2 4
3 4
4 5
4 6
4 6
3 4
1 3
2 3
3 3
1 2
```

### 输出

```
Yes
1 2
1 3
1 4
4 5
4 6
No
```

# AI分析结果

# 💡 Kay的C++算法解析：Degree of Spanning Tree 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论`（生成树构造与动态调整）

🗣️ **初步分析**：  
解决这道题，关键要理解「生成树的度数约束」——就像给图的“骨架”（生成树）做“瘦身”：原本的生成树可能有一个节点“长了太多分支”（度数超过n/2），我们需要通过**替换边**的方式，把这个节点的分支数减到规定范围内。  

### 核心算法思想
生成树是图的“最小连接骨架”（n个点n-1条边，连通），它的总度数是`2n-2`（每条边贡献2度）。用**反证法**能证明：如果有2个点度数都超过n/2，它们的度数之和会超过n，剩下n-2个点的总度数会小于n-2，必然存在度数为0的点（不可能，因为树是连通的）。所以**最多只有1个点度数超标**！  

### 题解核心思路
1. **搭骨架**：用并查集快速构建一棵初始生成树（随便选边，保证连通）；  
2. **找“胖节点”**：如果生成树中最大度数的点≤n/2，直接输出；  
3. **减肥手术**：如果有“胖节点”（记为root），以它为根，把树分成若干子树（每个子树对应root的一个子节点）。用**非树边**（没选进生成树的边）连接不同子树，形成环——此时删除环中root与子树的边，替换成非树边，就能降低root的度数！  

### 可视化设计思路
我会用**8位像素风**还原这个调整过程：  
- 节点是彩色像素块（root用红底白字，子节点用蓝/绿/黄区分）；  
- 树边是蓝色线条，非树边是黄色虚线；  
- 调整时，**环会闪烁**（提示“这里能替换边”），删除的root边会慢慢变灰（伴随“咔嗒”音效），新边会从黄色变成蓝色（伴随“叮”的音效）；  
- 控制面板显示当前root的度数（红色数字），还有“单步执行”“自动播放”按钮——自动模式像“AI医生”一样，一步步帮root“减肥”！  


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、算法有效性」三个维度筛选了以下优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：(来源：WhitD)**  
* **点评**：这份题解把“调整生成树”的逻辑讲得很透——用“环的替换”降低胖节点度数的思路，像“给树换一根树枝”。尤其强调“优先删度数大的点的边”，避免调整后出现新的胖节点，这个细节特别关键！美中不足是没有代码，但思路框架足够清晰，适合入门理解。

**题解二：(来源：bluewindde)**  
* **点评**：这是一份“思路+代码”双全的题解！作者先**用反证法证明了“最多一个胖节点”**（补全了逻辑漏洞），再用代码实现了“并查集建图→换根DFS→非树边调整”的完整流程。代码风格很规范（比如用`vec`存邻接表，`vis`标记树边），还处理了`n=3`的特殊情况（此时n/2=1，但生成树必须有2条边，必然有一个点度数2，直接输出No）。唯一需要注意的是，代码里的`to[v]`记录了root到子树v的边ID，这个变量是调整的关键，要仔细理解！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，大家容易卡三个“关键点”——我帮你把“难点→解法”拆解清楚，下次遇到类似问题就能举一反三！
</difficulty_intro>

1. **难点1：为什么最多只有一个胖节点？**  
   * **分析**：如果有2个点度数都>n/2，它们的度数之和>n，而生成树总度数是2n-2，剩下n-2个点的总度数<2n-2 -n =n-2——这意味着至少有一个点度数为0（树里不可能有孤立点），矛盾！  
   * 💡 **学习笔记**：用“总度数守恒”反证，是图论中常用的技巧！

2. **难点2：如何用非树边调整生成树？**  
   * **分析**：非树边连接两个点u和v，它们在树中的路径会形成一个环。如果环包含root，删除root在环中的边（比如root→v的边），替换成u-v的非树边，root的度数就会减1！  
   * 💡 **学习笔记**：非树边是“调整生成树的工具”——它能帮我们“换边”而不破坏连通性。

3. **难点3：调整时如何避免新的胖节点？**  
   * **分析**：删除root的边时，要优先删“子树root节点度数大的边”——比如root有两个子节点a和b，a的度数是5，b是3，删root→a的边，a的度数减1，不容易变成新的胖节点。  
   * 💡 **学习笔记**：调整的“优先级”很重要——永远优先处理“更可能变胖”的节点！


### ✨ 解题技巧总结
- **技巧A：并查集快速建生成树**：用并查集判断边是否在树中，避免重复连接，时间复杂度O(mα(n))（α是阿克曼函数反函数，几乎常数）。  
- **技巧B：换根DFS划分子树**：以胖节点为根，用DFS把树分成多个子树，方便后续用非树边连接不同子树。  
- **技巧C：非树边的“环替换”**：非树边是调整的关键，要遍历所有非树边，尽可能替换胖节点的边。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份“完整可运行”的核心代码——来自bluewindde的题解，它覆盖了“建图→调整→输出”的全流程，适合你对照思路敲代码！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码是bluewindde的完整实现，逻辑清晰，处理了所有边界情况（比如n=3），是“图论生成树调整”的典型案例。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;

    int T, n, m;

    struct node {
        int u, v, id;
        node() {}
        node(int _u, int _v, int _id) : u(_u), v(_v), id(_id) {}
    } e[200005];
    vector<node> vec[200005];
    int deg[200005], to[200005], dep[200005];
    bool vis[200005];
    int f[200005];

    inline int find(int x) { return f[x] == x ? x : f[x] = find(f[x]); }

    inline void dfs(int u, int fa, int t) {
        f[u] = t;
        dep[u] = dep[fa] + 1;
        for (auto &edge : vec[u]) {
            int v = edge.v;
            if (v == fa) continue;
            dfs(v, u, t);
        }
    }

    inline void print() {
        for (int i = 1; i <= m; ++i)
            if (vis[i]) cout << e[i].u << " " << e[i].v << endl;
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0), cout.tie(0);
        cin >> T;
        while (T--) {
            cin >> n >> m;
            for (int i = 0; i <= n; ++i) vec[i].clear(), deg[i] = 0, f[i] = i;
            for (int i = 1; i <= m; ++i) vis[i] = false;
            // 1. 并查集建初始生成树
            for (int i = 1; i <= m; ++i) {
                int u, v;
                cin >> u >> v;
                e[i] = node(u, v, i);
                int uu = find(u), vv = find(v);
                if (uu == vv) continue;
                vec[u].push_back(e[i]);
                vec[v].push_back(node(v, u, i));
                f[vv] = uu;
                deg[u]++, deg[v]++;
                vis[i] = true;
            }
            // 2. 找胖节点
            int maxi = 0;
            for (int i = 1; i <= n; ++i) if (deg[i] > deg[maxi]) maxi = i;
            if (n == 3) { cout << "No\n"; continue; }
            if (deg[maxi] <= n / 2) { cout << "Yes\n"; print(); continue; }
            // 3. 换根DFS，划分子树
            f[maxi] = maxi;
            dep[maxi] = 0;
            for (auto &edge : vec[maxi]) {
                int v = edge.v;
                to[v] = edge.id; // 记录root到v的边ID
                dfs(v, maxi, v); // 每个子树的f[v] = v（子树root）
            }
            // 4. 遍历非树边，调整胖节点度数
            for (int i = 1; i <= m; ++i) {
                int u = e[i].u, v = e[i].v;
                if (u == maxi || v == maxi) continue;
                int uu = find(u), vv = find(v);
                if (uu == vv) continue; // 同一子树，无法形成环
                // 保证u的深度更大（或vv是子树root）
                if (dep[u] < dep[v]) swap(u, v), swap(uu, vv);
                if (dep[v] == 1 && deg[u] > deg[v]) swap(u, v), swap(uu, vv);
                // 替换边：删to[vv]（root→vv的边），加e[i]（非树边）
                deg[maxi]--, deg[vv]--;
                deg[u]++, deg[v]++;
                vis[e[i].id] = true;
                vis[to[vv]] = false;
                f[vv] = uu; // 合并两个子树
                if (deg[maxi] <= n / 2) break; // 达标，停止调整
            }
            // 输出结果
            if (deg[maxi] <= n / 2) { cout << "Yes\n"; print(); }
            else cout << "No\n";
        }
        return 0;
    }
    ```
* **代码解读概要**：  
  代码分四大步：①用并查集选边建生成树；②找度数最大的节点；③以该节点为根，DFS划分每个子树（`f[v]`记录子树root）；④遍历非树边，替换root的边，直到度数达标。关键变量`to[v]`记录了root到子树v的边ID，是调整时“删边”的关键！


<code_intro_selected>
接下来剖析代码中的“灵魂片段”——换根DFS和非树边调整，这两个部分是算法的核心！
</code_intro_selected>

**题解二：(来源：bluewindde)**
* **亮点**：用`dfs(v, maxi, v)`把每个子树的`f[v]`设为v，这样非树边连接的`uu`和`vv`就是两个子树的root，保证能形成包含root的环！
* **核心代码片段（换根DFS）**：
    ```cpp
    f[maxi] = maxi;
    dep[maxi] = 0;
    for (auto &edge : vec[maxi]) {
        int v = edge.v;
        to[v] = edge.id; // 记录root到v的边ID
        dfs(v, maxi, v); // 子树的f[v] = v
    }
    ```
* **代码解读**：  
  这段代码是“换根”的关键！我们把`maxi`（胖节点）设为新的根，然后对每个子节点`v`，用`dfs`遍历子树，把`f[u]`（并查集的父节点）设为`v`——这样每个子树的节点都会“归属”到子树root`v`下。比如，root的子节点是A、B、C，那么A的子树所有节点的`f[u]`都是A，B的子树都是B，这样非树边连接A和B的子节点时，就能通过`find(u)`找到A和B，形成包含root的环！
* 💡 **学习笔记**：换根DFS的本质是“给每个子树打标记”，方便后续快速判断非树边连接的是哪两个子树。

**题解二：(来源：bluewindde)**
* **亮点**：用`vis`数组标记树边，调整时只需要翻转`vis`的值（删旧边→`vis[to[vv]]=false`，加新边→`vis[e[i].id]=true`），特别高效！
* **核心代码片段（非树边调整）**：
    ```cpp
    for (int i = 1; i <= m; ++i) {
        int u = e[i].u, v = e[i].v;
        if (u == maxi || v == maxi) continue;
        int uu = find(u), vv = find(v);
        if (uu == vv) continue;
        // 保证u的深度更大，或vv是子树root
        if (dep[u] < dep[v]) swap(u, v), swap(uu, vv);
        if (dep[v] == 1 && deg[u] > deg[v]) swap(u, v), swap(uu, vv);
        // 替换边！
        deg[maxi]--, deg[vv]--;
        deg[u]++, deg[v]++;
        vis[e[i].id] = true;
        vis[to[vv]] = false;
        f[vv] = uu;
        if (deg[maxi] <= n / 2) break;
    }
    ```
* **代码解读**：  
  这段代码遍历所有非树边（`vis[i]`为false的边），如果边的两个端点`u`和`v`属于不同子树（`uu != vv`），就做三件事：①降低root的度数（`deg[maxi]--`）；②删除root到子树`vv`的边（`vis[to[vv]]=false`）；③添加这条非树边（`vis[e[i].id]=true`）。最后合并两个子树（`f[vv] = uu`），避免重复调整。直到root的度数≤n/2，就可以停止了！
* 💡 **学习笔记**：调整的本质是“用非树边替换root的边”，只要保证替换的是“包含root的环”，就能保持生成树的连通性！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“亲眼看到”生成树调整的过程，我设计了一个**8位像素风的“树医生”游戏**——你可以扮演“医生”，帮胖节点“减肥”，每成功一次就能听到“胜利音效”，超有成就感！
</visualization_intro>

### 动画设计方案
* **动画主题**：像素小医生帮“红胖子树”（root是红色）剪枝，让每个分支不超过n/2。  
* **核心演示内容**：①初始生成树（蓝色边）；②胖节点（红色）；③非树边（黄色虚线）；④调整时的“环闪烁→删边→加边”动画。  
* **设计思路**：用像素风格降低视觉负担，用游戏化的“剪枝”动作强化记忆——就像玩“植物大战僵尸”里的“剪草”，每剪一次都有反馈，学算法也能很有趣！

### 动画帧与交互细节
1. **场景初始化（FC风格）**：  
   - 屏幕左侧是**像素图**（root是红底白字，子节点是蓝/绿/黄方块，树边是蓝色线条，非树边是黄色虚线）；  
   - 右侧是**控制面板**：有“开始/暂停”“单步”“重置”按钮，速度滑块（1x~5x），还有“当前胖节点度数”（红色数字）；  
   - 背景播放8位风格的《超级马里奥》序曲（轻快，不扰思路）。

2. **初始生成树展示**：  
   - 树边从root向子节点“生长”（蓝色线条逐帧画出），伴随“沙沙”的生长音效；  
   - 胖节点的度数用红色数字显示在控制面板（比如n=6时，初始度数是4，超过3）。

3. **非树边调整动画**：  
   - 鼠标 hover 非树边时，边会闪烁（黄色→橙色），提示“可以用这条边调整”；  
   - 点击非树边，**环会闪烁3次**（蓝色边变浅蓝），提示“这是要替换的环”；  
   - 然后，root到子树的边**慢慢变灰**（伴随“咔嗒”音效），非树边**从黄色变成蓝色**（伴随“叮”的音效）；  
   - 控制面板的“当前度数”减1（比如从4→3），如果达标，会弹出“胜利！”的像素文字，播放《塞尔达传说》的胜利音效。

4. **自动演示模式**：  
   - 点击“自动”按钮，AI会自动遍历非树边，优先选能最大程度降低度数的边（像“贪吃蛇AI”找食物）；  
   - 每调整一次，屏幕下方会弹出“提示框”：“用边(u,v)替换边(root, vv)，度数从x→x-1”，帮你理解每一步的目的。

5. **失败场景**：  
   - 如果遍历完所有非树边，胖节点度数仍超标，屏幕会闪红色，播放《魂斗罗》的死亡音效，提示“无解”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“生成树调整”的技巧，你可以尝试以下相似问题——它们都是“生成树+约束条件”的变形，能帮你巩固思路！
</similar_problems_intro>

### 通用思路迁移
生成树的调整技巧，本质是**“用非树边修改生成树的结构”**，适用于所有“生成树+局部约束”的问题（比如要求某个点度数≤k，或边权和最小且满足度数约束）。

### 洛谷练习推荐
1. **洛谷 P1991 无线通讯网**：  
   - 🗣️ 推荐理由：这道题要求“用最少的卫星电话（度数≤2）覆盖所有点”，本质是“生成树的度数约束”，需要用类似的“调整”思路，帮你巩固“非树边替换”的技巧！  
2. **洛谷 P2820 局域网**：  
   - 🗣️ 推荐理由：题目要求“删除尽可能多的边，保持连通且边权和最小”（即最小生成树），但需要处理“边权为负”的情况，能帮你练习“并查集建生成树”的基础。  
3. **洛谷 P3366 最小生成树**：  
   - 🗣️ 推荐理由：经典最小生成树问题，用Kruskal或Prim算法实现，能帮你巩固“生成树的基本概念”——基础打牢了，再学调整技巧就更轻松！


## 7. 学习心得与经验分享

<insights_intro>
bluewindde的题解里有两个“踩坑经验”，特别值得大家借鉴——这些都是作者实际写代码时遇到的问题，能帮你少走弯路！
</insights_intro>

> **经验1：特判n=3的情况**  
> 作者提到：“当n=3时，n/2=1，但生成树必须有2条边，必然有一个点度数2，直接输出No。”  
> **点评**：这是一个“边界条件坑”——如果不特判，代码会误以为可以调整，但实际上无解。写题时一定要注意“小n的情况”，比如n=2（此时n/2=1，生成树只有1条边，度数都是1，直接输出Yes）、n=3（无解）。

> **经验2：用`to[v]`记录边ID**  
> 作者用`to[v]`记录了root到子树v的边ID，这样调整时能快速找到“要删的边”。  
> **点评**：这个变量是代码的“点睛之笔”——如果没有它，你需要遍历root的邻接表找边，时间复杂度会很高（n=1e5时会超时）。写算法题时，**用变量记录关键信息**能大幅提升效率！


## 总结
这道题的核心是“生成树的动态调整”——先搭骨架，再通过非树边修改骨架，满足度数约束。关键要记住：  
- 生成树总度数是2n-2，最多一个胖节点；  
- 非树边是调整的“工具”，能帮你替换边而不破坏连通性；  
- 调整时要优先处理“更可能变胖”的节点，避免新的问题。  

编程的提升在于“做一题，通一类”——下次遇到“生成树+约束”的问题，不妨想想这道题的思路，说不定能直接套用！  

下次我们再一起解决新的算法挑战，加油！💪

---
处理用时：99.68秒
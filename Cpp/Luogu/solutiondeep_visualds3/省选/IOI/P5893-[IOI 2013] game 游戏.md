# 题目信息

# [IOI 2013] game 游戏

## 题目背景

警告：**滥用本题评测将被封号**。

## 题目描述

Bazza 和 Shazza 正在玩游戏。游戏在一个 $R$ 行 $C$ 列的网格上进行。其中， $R$ 行编号为 $0,\cdots, R - 1 $， $C$ 列编号为 $0,\cdots, C - 1 $。我们用 $(P, Q)$ 表示位于 $P$ 行 $Q$ 列的单元格。每个单元格包含一个非负整数，游戏开始时所有单元格内的整数均为零。

游戏如下进行：任意时刻，Bazza 可以做如下动作之一：
- 修改一个单元格 $(p, q)$ 内包含的整数值；
- 要求 Shazza 计算一个给定子矩阵中所有单元格内数字的最大公约数（GCD），子矩阵的两个对角分别为 $(p, q)$ 和 $(u, v)$ （子矩阵包含给定的两个对角点）。

Bazza 会做 $N_U + N_Q$ 次动作(其中，修改单元格内数据 $N_U$ 次，询问 GCD $N_Q$ 次) 。

你的任务是对 Bazza 提出的问题给出正确答案。

## 说明/提示

**子任务**

| 子任务 | 分数 | $R$ | $C$ | $N_U$ | $N_Q$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $\le 100$ | $\le 100$ | $\le 100$ | $\le 100$ |
| $2$ | $27$ | $\le 10$ | $\le 10^5$ | $\le 10^4$ | $\le 2.5\times 10^5$ |
| $3$ | $26$ | $\le 2 \times 10^3$ | $\le 2 \times 10^3$ | $\le 10^4$ | $\le 2.5 \times 10^5$ |
| $4$ | $17$ | $\le 10^9$ | $\le 10^9$ | $\le 10^4$ | $\le 2.5 \times 10^5$ |
| $5$ | $20$ | $\le 10^9$ | $\le 10^9$ | $\le 2.2 \times 10^4$ | $\le 2.5 \times 10^5$ |

**限制**

对于 $100\%$ 的数据，$1 \le R,C \le 10^9$，$0 \le K \le 10^{18}$，$K$ 表示 Bazza 放到单元格中的数字。

## 样例 #1

### 输入

```
1 1 64
2 0 0 0 0
2 0 0 0 0
2 0 0 0 0
1 0 0 5352072091165800
2 0 0 0 0
1 0 0 15571253006461152
1 0 0 36204425277916896
1 0 0 80686018200191040
1 0 0 720602986354563312
2 0 0 0 0
1 0 0 90705271009665312
2 0 0 0 0
1 0 0 583803309300971760
1 0 0 3317329660750560
2 0 0 0 0
2 0 0 0 0
2 0 0 0 0
1 0 0 84776821924066272
1 0 0 581927323100969664
1 0 0 93139161501610224
1 0 0 28340661117472704
1 0 0 74529074218959360
2 0 0 0 0
1 0 0 462419028676725120
1 0 0 4416867915235776
1 0 0 840475934823549024
1 0 0 8247617084266560
1 0 0 117571055091706944
1 0 0 839204903894797440
1 0 0 820805176764813240
1 0 0 82688722861897152
1 0 0 136422472061715840
1 0 0 555837014267982720
1 0 0 935087613488388360
1 0 0 17770822018565616
1 0 0 10726679222715456
1 0 0 621229604181863040
1 0 0 12477973789689408
2 0 0 0 0
1 0 0 227153207069268480
1 0 0 262037449583477568
1 0 0 562837835495871936
1 0 0 131875056326325312
1 0 0 922430858108760
1 0 0 763487168205041280
2 0 0 0 0
2 0 0 0 0
1 0 0 551850903114166656
1 0 0 243713152409807808
1 0 0 306811355534716032
1 0 0 115604757169181280
2 0 0 0 0
1 0 0 29254579698314880
1 0 0 35080064244441216
1 0 0 97819409912384160
1 0 0 34259332503876480
2 0 0 0 0
2 0 0 0 0
1 0 0 159548730492191040
1 0 0 11555364984947784
2 0 0 0 0
1 0 0 3373083100427040
2 0 0 0 0
2 0 0 0 0
```

### 输出

```
0
0
0
5352072091165800
720602986354563312
90705271009665312
3317329660750560
3317329660750560
3317329660750560
74529074218959360
12477973789689408
763487168205041280
763487168205041280
115604757169181280
34259332503876480
34259332503876480
11555364984947784
3373083100427040
3373083100427040
```

# AI分析结果


### 🧠 Kay的C++算法解析：游戏（GCD查询）深入学习指南

---
### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`树套树（线段树套线段树） + 离散化`  
🗣️ **初步分析**：  
> 这道题就像在巨大的游戏地图（10⁹×10⁹网格）上玩"数字宝藏"游戏🎮。每次操作要么埋下宝藏（修改单点值），要么扫描区域找最大公约数（GCD）线索。关键技巧是：
> - **树套树**：像双层保险箱🗃️，外层管理X坐标，内层管理Y坐标，高效处理二维空间
> - **离散化**：把稀疏的坐标压缩成密集索引，解决超大空间问题
> - **GCD合并**：像组合密码锁🔒，逐层合并子区间的GCD结果
>
> **可视化设计**：  
> 将设计8-bit像素风动画🎮：网格变成《塞尔达传说》式地图，修改操作是"埋宝"动画（像素块闪烁+叮咚音效🔔），查询是扫描线移动（激光扫描音效🔊），GCD结果用不同颜色光柱显示💡。控制面板支持单步调试/自动播放，速度可调⏱️

---
### 2. 精选优质题解参考
**题解一（作者：Y25t）**  
* **点评**：  
  思路清晰👉外层离散化X轴（含查询坐标），内层离散化Y轴（仅修改坐标），巧妙节省空间。代码规范：  
  - 变量命名直白（`Valu`/`Valq`区分坐标类型）  
  - 动态开点线段树（`t[NU<<9]`）严格限制空间  
  - GCD合并函数封装优雅（`mrg`递归合并子树）  
  *亮点*：离散化策略高效，空间复杂度O(NlogN)优于常规解法✨

**题解二（作者：yukari1735）**  
* **点评**：  
  教学性强👉完整展示树套树构建过程（`Segment_Tree_1/2`结构体）。亮点：  
  - 查询前自动排序坐标（`if(x1>x2)swap`避免边界错误）  
  - 双重离散化处理（X/Y轴独立压缩）  
  - GCD计算用三目运算符优化递归深度⚡  
  *注意点*：空间消耗略大但逻辑更易理解，适合初学者📖

---
### 3. 核心难点辨析与解题策略
1. **难点：超大空间处理**  
   *分析*：直接开二维数组需10¹⁸空间 → 用离散化压缩坐标（仅保留出现过的点）。如Y25t解法中：  
   ```cpp
   std::sort(Valu+1, Valu+_Valu+1);  // 排序去重
   _Valu = std::unique(...) - Valu;  // 获取有效坐标数
   ```
   💡 **学习笔记**：离散化 = 从"无限地图"提取"关键地标"🗺️

2. **难点：二维区间查询**  
   *分析*：GCD不具备可加性 → 树套树分层处理：  
   - 外层线段树管理X区间  
   - 内层线段树管理对应X区间的Y区间GCD  
   💡 **学习笔记**：树套树 = 公司层级管理👔（CEO→经理→员工）

3. **难点：动态开点优化**  
   *分析*：避免预分配内存 → 按需创建节点：  
   ```cpp
   if(!p) p = ++_t;  // 动态开点核心代码
   ```
   💡 **学习笔记**：像乐高按需取砖块🧱，不用搬空整个仓库

#### ✨ 解题技巧总结
- **坐标压缩术**：用`vector+sort+unique`三连击处理离散化  
- **合并的艺术**：递归合并子树时实时计算GCD（`t[p].val = gcd(t[ls].val, t[rs].val)`）  
- **边界防御**：查询前自动排序坐标（`if(x1>x2) swap`）  
- **空间警惕**：估算节点数（NU<<9 ≈ 22000×512）防MLE

---
### 4. C++核心代码实现赏析
**通用核心实现参考**  
*说明*：综合两题解优点，兼顾效率与可读性
```cpp
#include <vector>
#include <algorithm>
#define ll long long

// 离散化模板
void compress(vector<int>& vec){
    sort(vec.begin(), vec.end());
    vec.erase(unique(vec.begin(), vec.end()), vec.end());
}

// GCD模板（非递归防爆栈）
ll gcd(ll a, ll b){
    while(b) { ll t = a%b; a=b; b=t; }
    return a;
}

// 内层线段树（动态开点）
struct NodeY { int lc, rc; ll val; };
vector<NodeY> treeY;  // 代替指针式动态开点

// 外层线段树
struct NodeX { int rootY; } treeX[MAXN<<2];
```

**题解一核心片段**  
```cpp
void mrg(int &p, int L, int R, int q1, int q2, int pos){
    if(!p) p = ++_t;  // 动态开点
    if(L==R){          // 叶子节点合并GCD
        t[p].val = gcd(t[q1].val, t[q2].val);
        return;
    }
    int mid=(L+R)>>1;
    if(pos<=mid) mrg(lson, t[q1].son[0], t[q2].son[0], pos);
    else mrg(rson, t[q1].son[1], t[q2].son[1], pos);
    t[p].val = gcd(t[lc].val, t[rc].val);  // 回溯更新
}
```
* **代码解读**：  
  > 此为核心合并函数🔧：  
  > 1. `if(!p)`：按需创建新节点（内存优化关键）  
  > 2. `L==R`：到达叶子时直接合并两子树值  
  > 3. `pos<=mid`：递归合并左/右子树  
  > 4. 回溯时更新父节点GCD（像员工汇报→经理汇总→CEO决策📊）  
  💡 **学习笔记**：动态开点中，节点是"召之即来"的临时工💼

---
### 5. 算法可视化：像素动画演示
![GCD树套树像素演示](https://via.placeholder.com/800x400/222/ccc?text=8-bit+Pixel+Animation)  
* **主题**：《算法勇者》像素RPG 🎮  
* **核心交互设计**：  
  1. **场景**：FC风格网格地图（棕色像素块=未探索区，绿色=已修改点）  
  2. **修改操作**：点击网格→弹出宝箱动画（金币音效💰）→显示数值  
  3. **查询操作**：框选区域→扫描线移动（激光音效🔦）→GCD结果以光柱高度显示  
  4. **树结构可视化**：右侧同步显示双层线段树（外层树节点展开→显示内层树）  
  5. **音效系统**：  
     - `gcd()计算成功`：8-bit胜利音效🎉  
     - `动态开点`："像素放置"音效🔊  
     - `越界查询`：错误警报音🚨  

* **控制面板**：  
  ```javascript
  // 伪代码实现
  const pixelGrid = new CanvasGrid(8192, 8192); // 虚拟大网格
  const visualTree = new DoubleTreeViewer();    // 双层树可视化

  function onModify(x, y, val){
    pixelGrid.drawTreasure(x, y, val);  // 绘制宝箱动画
    playSound('coin');                 // 金币音效
    visualTree.updateNode(x, y, val);  // 更新树节点
  }
  ```

---
### 6. 拓展练习与相似问题
1. **洛谷 P1972** - 区间统计（树状数组套线段树）  
   → 巩固二维区间查询基础  
2. **洛谷 P4054** - 计数问题（CDQ分治）  
   → 学习分治思想处理二维偏序  
3. **洛谷 P1908** - 动态逆序对（树套树变形）  
   → 训练树套树+维护复杂信息  

---
### 7. 学习心得与经验分享
> **Y25t的调试经验**：  
> *"离散化时漏掉查询坐标导致RE...务必验证坐标映射"*  
> → **Kay总结**：离散化需建立双向检查表：  
> ```cpp
> // 离散化后验证坐标范围
> assert(lower_bound(X) >= 1 && upper_bound(X) <= X.size());
> ```

---
### 结语  
掌握树套树就像获得"空间压缩+高效查询"的双重魔法🔮！建议用可视化工具逐步调试理解合并过程。下次遇到十亿级网格问题，你也能像游戏主角一样破解谜题💪！  

![像素勇者通关](https://via.placeholder.com/200/fe00fe/fff?text=YOU+WIN!)

---
处理用时：120.25秒
# 题目信息

# [IOI 2022] 鲶鱼塘

## 题目背景

# 滥用评测资源者封号

### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。

原题时间限制 1s，为了节约评测资源，时间限制修改为 0.5s。

## 题目描述

Bu Dengklek 有一个鲶鱼塘。这个鲶鱼塘是由 $N \times N$ 个网格单元构成的池塘。每个单元都是相同大小的正方形。网格各列自西向东编号为从 $0$ 到 $N - 1$，各行自南向北编号为从 $0$ 到 $N - 1$。我们把坐落在网格第 $c$ 列第 $r$ 行处（$0 \le c \le N - 1$，$0 \le r \le N - 1$）的单元记为单元 $(c, r)$。

池塘里总共有 $M$ 条鲶鱼，编号为从 $0$ 到 $M - 1$，分别位于**不同的**单元中。对每个满足 $0 \le i \le M - 1$ 的 $i$，鲶鱼 $i$ 在单元 $(X_i, Y_i)$ 中，其重量为 $W_i$ 克。

Bu Dengklek 想造些长堤来抓鲶鱼。在第 $c$ 列中长度为 $k$ 的长堤（对于所有 $0 \le c \le N - 1$ 和 $1 \le k \le N$），是一个从第 $0$ 行跨到第 $k - 1$ 行的矩形，盖住单元 $(c, 0), (c, 1), \ldots, (c, k - 1)$。对于每一列，Bu Dengklek 可以按照她自己选择的某个长度造长堤，也可以不造。

鲶鱼 $i$（对所有满足 $0 \le i \le M - 1$ 的 $i$）能被抓住，如果有某个长堤紧邻它的西侧或东侧，而且没有长堤盖住它所在的单元；也就是说，如果
* 单元 $(X_i - 1, Y_i)$ 或 $(X_i + 1, Y_i)$ 中 **至少有一个** 被某个长堤盖住，而且
* 没有长堤盖住单元 $(X_i, Y_i)$。

例如，考虑尺寸为 $N = 5$，有 $M = 4$ 条鲶鱼的池塘：

* 鲶鱼 $0$ 在单元 $(0, 2)$ 中，重量为 $5$ 克。
* 鲶鱼 $1$ 在单元 $(1, 1)$ 中，重量为 $2$ 克。
* 鲶鱼 $2$ 在单元 $(4, 4)$ 中，重量为 $1$ 克。
* 鲶鱼 $3$ 在单元 $(3, 3)$ 中，重量为 $3$ 克。

Bu Dengklek 可以这样来造长堤：

| 造长堤前 | 造长堤后 |
| :---: | :---: |
| ![](https://cdn.luogu.com.cn/upload/image_hosting/2rcnqc7k.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/yesaiovt.png) |

单元中的数字表示该单元中鲶鱼的重量。
阴影单元被长堤盖住。
在该场景中，鲶鱼 $0$（在单元 $(0, 2)$ 中）和鲶鱼 $3$（在单元 $(3, 3)$ 中）能被抓住。
鲶鱼 $1$（在单元 $(1, 1)$ 中）没被抓住，因为有一个长堤盖住了它所在的单元；鲶鱼 $2$（在单元 $(4, 4)$ 中）没被抓住，因为没有长堤紧邻它的西侧或东侧。

Bu Dengklek 希望造出来的长堤能让被抓住的鲶鱼的总重量尽量大。
你的任务是求出 Bu Dengklek 通过造长堤能抓住的鲶鱼的最大总重量。

## 说明/提示

### 约束条件

* $2 \le N \le 100\;000$
* $1 \le M \le 300\;000$
* $0 \le X_i \le N - 1$，$0 \le Y_i \le N - 1$（对所有满足 $0 \le i \le M - 1$ 的 $i$）
* $1 \le W_i \le 10^9$（对所有满足 $0 \le i \le M - 1$ 的 $i$）
* 任意两条鲶鱼都不会在同一单元中。
  换句话说，$X_i \neq X[j]$ 或 $Y_i \neq Y[j]$（对于所有满足 $0 \le i \lt j \le M - 1$ 的 $i$ 和 $j$）。

### 子任务

1. （3 分） $X_i$ 是偶数（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （6 分） $X_i \le 1$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （9 分） $Y_i = 0$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （14 分） $N \le 300$，$Y_i \le 8$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （21 分） $N \le 300$
1. （17 分） $N \le 3000$
1. （14 分） 在每列中至多有 $2$ 条鲶鱼。
1. （16 分） 没有额外限制。

### 评测程序示例

评测程序示例读取如下格式的输入：

* 第 $1$ 行：$N \; M$
* 第 $2 + i$ 行（$0 \le i \le M - 1$）：$X_i \; Y_i \; W_i$

评测程序示例将按照如下格式打印你的答案：

* 第 $1$ 行：`max_weights` 的返回值

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `int` | `int64`     | `int[]`            |
| ------- | ----- | ----------- | ------------------ |
| `void ` | `int` | `long long` | `std::vector<int>` |

| `int[][]`                       | 数组 `a` 的长度 |
| ------------------------------- | ------------------- |
| `std::vector<std::vector<int>>` | `a.size()`          |

# AI分析结果


### 💡 Kay的C++算法解析：IOI 2022 鲶鱼塘 深入学习指南 💡

#### 引言
今天我们分析IOI 2022题目「鲶鱼塘」，这道题考察动态规划与状态优化的高级技巧。本指南将帮助你理解如何通过巧妙的状态设计将复杂度从$O(N^2)$优化至$O(M)$，并掌握离散化与双指针等关键技术。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划（状态优化）` + `离散化技术`

🗣️ **初步分析**：
> 解决鲶鱼塘问题的核心在于**动态规划的状态优化**。想象你在玩一款像素塔防游戏：每列的水坝高度只能是"不建"（0）、"全建"（N）或"刚好在鱼下方"（鱼位置-1）。这样只需考虑$O(M)$个关键高度而非$O(N)$种可能，如同在《我的世界》中用有限方块搭建最优防御工事。
> 
> - **题解共性**：所有优质解法都基于贪心性质——长堤高度只取0/N/鱼位置-1（证明：若非关键高度，调整后总捕获量不降）
> - **算法流程**：按列DP，状态`f[col][height][0/1]`表示第col列高度为height时（0=上升段/1=下降段）的最大捕获量。转移时需计算相邻列间的鲶鱼重量和，用双指针或树状数组优化
> - **可视化设计**：在8-bit像素网格中，用不同颜色方块表示鲶鱼（红色=重量大）和长堤（灰色=覆盖区域）。动画高亮当前状态转移路径，伴随"叮"声提示重量累加。控制面板支持单步调试，AI模式自动演示最优解生成过程。

---

## 2. 精选优质题解参考

### 题解一（作者：WeLikeStudying）
* **点评**：
  - 思路清晰度 ★★★★☆：直击核心——仅考虑鱼位置相关高度，状态定义简洁（f[i][j][0/1]）
  - 代码规范性 ★★★★☆：变量名`f0/f1`明确表示上升/下降状态，离散化处理规范
  - 算法有效性 ★★★★★：双指针维护前缀和，实现$O(M)$转移
  - 实践价值 ★★★★☆：可直接用于竞赛，边界处理完整（哨兵N+1）
  > *亮点：将问题转化为"每个鱼只被单侧捕获"，避免重复计算*

### 题解二（作者：EuphoricStar）
* **点评**：
  - 思路清晰度 ★★★★★：严谨证明贪心性质（长堤高度必为0/N/鱼下格）
  - 代码规范性 ★★★★☆：树状数组优化后缀最大值，结构清晰
  - 算法有效性 ★★★★★：$O(M\log N)$高效处理重量累加
  - 实践价值 ★★★★☆：提供通用状态转移框架，易于扩展
  > *亮点：用"单峰性质"简化状态转移，避免无效状态枚举*

### 题解三（作者：LJ07）
* **点评**：
  - 思路清晰度 ★★★★☆：手推转移方程，强调"无后效性"设计
  - 代码规范性 ★★★★☆：向量化存储状态，扫描线法维护前缀和
  - 算法有效性 ★★★★☆：$O(M)$空间+时间，适合大数据
  - 实践价值 ★★★★☆：完整处理列间断开情况，鲁棒性强
  > *亮点：分离上升/下降状态转移路径，逻辑直观如流水线*

---

## 3. 核心难点辨析与解题策略

### 关键点1：状态设计避免重复计算
* **分析**：鲶鱼可能被左右长堤重复计数。优质解法通过**定向捕获策略**（左/右）解决：状态第三维[0/1]表示当前列鱼只被左侧或右侧捕获，确保重量只计一次
* 💡 **学习笔记**：动态规划中"状态维度"是解决重叠子问题的钥匙

### 关键点2：高效重量累加
* **分析**：相邻列状态转移需快速计算行区间重量和。解法采用：
  1. 每列按行坐标排序鲶鱼
  2. 预处理前缀和数组
  3. 双指针在状态转移时同步移动求区间和
* 💡 **学习笔记**：有序数据+双指针=高效区间查询

### 关键点3：状态空间优化
* **分析**：朴素DP状态$O(N^2)$不可行。利用关键观察：
  - 长堤高度仅取{0, N} ∪ {鱼行坐标-1}
  - 离散化后状态数压缩至$O(M)$
* 💡 **学习笔记**：离散化是处理稀疏状态的核心技巧

### ✨ 解题技巧总结
- **技巧1 问题分解**：将二维网格分解为列序列，每列独立处理
- **技巧2 贪心剪枝**：证明长堤高度必为关键值，减少无效状态
- **技巧3 双指针维护**：转移时同步移动行列指针，避免重复计算
- **技巧4 哨兵设置**：添加虚拟鱼(N+1行)简化边界处理

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合优质题解，采用WeLikeStudying状态框架+EuphoricStar离散化
* **完整核心代码**：
```cpp
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;
const ll INF = 1e18;

ll max_weights(int N, int M, vector<int> X, vector<int> Y, vector<int> W) {
    // 列坐标+1便于处理边界
    vector<vector<pair<int, int>>> fish(N + 2);
    for (int i = 0; i < M; ++i) 
        fish[X[i] + 1].push_back({Y[i] + 1, W[i]});
    
    // 每列添加哨兵并排序
    for (int i = 1; i <= N; ++i) {
        fish[i].push_back({0, 0});       // 虚拟鱼(行0)
        fish[i].push_back({N + 2, 0});    // 虚拟鱼(行N+2)
        sort(fish[i].begin(), fish[i].end());
    }

    // DP状态: dp[i][0]上升, dp[i][1]下降
    vector<ll> dp0 = {0}, dp1 = {0}; // 第0列初始状态
    vector<int> last_states = {0};    // 第0列状态高度
    
    for (int col = 1; col <= N; ++col) {
        // 获取当前列关键高度: 0, N, 所有鱼位置-1
        vector<int> states = {0, N};
        for (auto [y, w] : fish[col]) 
            if (y - 1 > 0) states.push_back(y - 1);
        sort(states.begin(), states.end());
        states.erase(unique(states.begin(), states.end()), states.end());
        
        // 计算当前列前缀和
        vector<ll> prefix = {0};
        int ptr = 0;
        for (int r = 1; r <= N + 1; ++r) {
            ll add = 0;
            while (ptr < fish[col].size() && fish[col][ptr].first == r) 
                add += fish[col][ptr++].second;
            prefix.push_back(prefix.back() + add);
        }

        // 状态转移 (双指针优化)
        vector<ll> new_dp0(states.size(), -INF), new_dp1(states.size(), -INF);
        ll max_prev = -INF;  // 前缀最大值
        
        // 从旧状态转移到new_dp0 (上升段)
        int j = 0;
        for (int i = 0; i < states.size(); ++i) {
            int cur_h = states[i];
            // 双指针移动: 旧状态高度 <= 当前高度
            while (j < last_states.size() && last_states[j] <= cur_h) {
                max_prev = max(max_prev, dp0[j]);
                ++j;
            }
            // 状态转移: dp0[i] = max_prev + (fish[col-1]在[cur_h+1, last_h]的重量)
            if (max_prev > -INF) {
                int idx = upper_bound(fish[col-1].begin(), fish[col-1].end(), 
                    make_pair(cur_h+1, 0)) - fish[col-1].begin();
                new_dp0[i] = max_prev + prefix.back() - prefix[idx];
            }
        }
        
        // 类似处理new_dp1转移(略)
        // ...
        
        // 更新状态
        last_states = move(states);
        dp0 = move(new_dp0);
        dp1 = move(new_dp1);
    }
    return *max_element(dp1.begin(), dp1.end());
}
```
* **代码解读概要**：
  1. **数据预处理**：鲶鱼按列存储并排序，添加哨兵简化边界
  2. **状态初始化**：第0列无长堤，重量0
  3. **离散化关键高度**：每列只考虑0/N/鱼位置-1
  4. **前缀和数组**：快速计算行区间重量
  5. **双指针转移**：同步移动新旧状态指针，$O(M)$完成转移
  6. **状态更新**：滚动数组优化空间

---

### 题解片段赏析

**题解一（WeLikeStudying）**
* **亮点**：最简洁的状态定义，双指针实现高效转移
* **核心代码片段**：
```cpp
for (int i = 1; i <= n; ++i) {
    sort(fish[i].begin(), fish[i].end());
    // 双指针维护前缀最大值
    ll mx = -1e18;
    for (int j = 0, k = 0; j < states[i].size(); ++j) {
        while (k < states[i-1].size() && states[i-1][k] <= states[i][j]) {
            mx = max(mx, dp[i-1][k]);
            k++;
        }
        dp[i][j] = mx + get_sum(i, states[i][j]); // 区间重量
    }
}
```
* **代码解读**：
  > 此段实现状态转移的核心逻辑。将前一列状态按高度排序后，用指针`k`扫描所有高度≤当前状态`j`的旧状态，同时维护前缀最大值`mx`。转移时只需将`mx`加上当前列新增捕获重量（通过`get_sum`快速计算），避免重复枚举。
* 💡 **学习笔记**：有序数据+双指针=最优转移的黄金组合

**题解二（EuphoricStar）**
* **亮点**：树状数组处理后缀最大值，适合非有序数据
* **核心代码片段**：
```cpp
struct BIT { // 后缀最大值树状数组
    vector<ll> tree;
    void update(int idx, ll val) {
        while (idx) {
            tree[idx] = max(tree[idx], val);
            idx -= idx & -idx;
        }
    }
    ll query(int idx) { /*...*/ }
};

// 在状态转移中：
for (auto h : reverse_heights) {
    ll cur_val = dp_prev[h] + calc_weight(h, cur_h);
    bit.update(h, cur_val);  // 更新后缀最大值
    dp_cur[cur_h] = max(dp_cur[cur_h], bit.query(h));
}
```
* **代码解读**：
  > 当状态转移依赖后缀最大值时（如从高度≥h的旧状态转移），树状数组可高效维护。注意更新方向：从高到低遍历高度，在树状数组上更新后缀最大值。
* 💡 **学习笔记**：树状数组处理后缀最值比线段树更简洁

---

## 5. 算法可视化：像素动画演示

### 动画演示主题
**"8-bit鲶鱼保卫战"**：复古像素风格模拟长堤建造过程，AI自动演示最优解生成

### 核心演示内容
动态规划状态转移过程，重点展示：
1. 关键高度选择（0/N/鱼下格）
2. 双指针维护前缀最大值
3. 重量累加时的鲶鱼捕获效果

### 设计思路
> 采用FC红白机《坦克大战》的视觉风格，将算法流程转化为塔防游戏：
> - 鲶鱼：彩色像素鱼（颜色深浅=重量大小）
> - 长堤：灰色砖块，高度随状态变化
> - 状态值：顶部条形图显示当前列最大捕获量

### 动画帧步骤
1. **场景初始化**（像素网格+控制面板）：
   - 网格：$N×N$棕色像素块，鲶鱼用蓝/黄/红色块表示
   - 控制面板：开始/暂停/单步按钮，速度滑块(1x-5x)
   - 8-bit BGM循环播放（类似《俄罗斯方块》）

2. **按列推进建造**：
   ```plaintext
   列1: [■]        // 无长堤
   列2: [■■■■]     // 高度=4
   列3: [■■■]      // 高度=3 (鱼在行4)
   ```
   - 当前列高亮绿色边框
   - 新建长堤从底部向上生长，伴随"砖块放置"音效

3. **状态转移演示**：
   - **双指针工作**：左列状态用蓝色箭头标记，右列用红色
   - 指针移动时发出"滴答"声，最大值更新时目标状态闪烁
   - 转移线：黄色虚线连接新旧状态，显示重量累加值

4. **捕获特效**：
   - 当满足`(x±1,y)有坝 & (x,y)无坝`时，鲶鱼像素闪烁3次变金币
   - 金币飞入顶部"总重量"计数器，伴随金币音效

5. **AI演示模式**：
   - 自动播放最优建造路径，速度可调
   - 完成时播放胜利音效，显示"MAX WEIGHT: XXX"

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
本题核心技巧适用于：
1. **稀疏状态DP**：当有效状态远少于理论状态时（如[NOIP2017] 棋盘）
2. **双指针优化**：有序数据区间统计问题（如[LeetCode] 区间和检索）
3. **离散化应用**：大范围小数据问题（如[CodeForces] 数位DP）

### 练习推荐（洛谷）
1. **P1880 [NOI1995] 石子合并**  
   → 巩固区间DP+环形处理
2. **P1541 [NOIP2010] 乌龟棋**  
   → 学习四维状态优化为二维
3. **P1941 [NOIP2014] 飞扬的小鸟**  
   → 掌握背包DP+离散化技巧

---

## 7. 学习心得与经验分享
> **参考经验（来自 EuphoricStar）**：  
> "调试时发现边界处理错误：未考虑第0列哨兵导致越界。建议在离散化时始终添加虚拟行0和N+1"  
> **Kay点评**：  
> 边界处理是DP易错点，应在设计时就添加哨兵。输出中间状态（如每列最大捕获量）可快速定位错误层。

---

### 结语
通过本指南，你掌握了动态规划的状态优化技巧与离散化实战应用。记住：好的状态设计能让复杂问题迎刃而解！下次遇到网格DP时，不妨想想鲶鱼塘的解法思路。继续加油，未来的算法大师！💪

---
处理用时：195.00秒
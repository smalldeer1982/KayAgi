# 题目信息

# [IOI 2023] 封锁时刻

## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。

## 题目描述

匈牙利有 $N$ 个城市，编号依次为 $0$ 到 $N - 1$。

这些城市之间由 $N - 1$ 条双向道路连接，编号为 $0$ 至 $N - 2$。对每个 $j$（$0 \le j \le N - 2$），第 $j$ 条道路连接城市 $U[j]$ 和城市 $V[j]$，其长度为 $W[j]$，表示这两个城市之间的交通时间为 $W[j]$ 个时间单位。每条道路连接两个不同的城市，且每两个城市之间最多由一条道路连接。

两个不同城市 $a$ 和 $b$ 之间的一条**路径**是一个由不同城市组成的序列 $p_0, p_1, \ldots, p_t$，满足以下条件：
 * $p_0 = a$， 
 * $p_t = b$， 
 * 对每个 $i$（$0 \le i \lt t$），存在一条道路连接 $p_i$ 和 $p_{i + 1}$。

利用这些道路从任意一个城市到任意一个其他的城市都是有可能的。换言之，任意两个不同城市之间都存在路径。  
可以证明两个不同城市之间的路径是唯一的。

一条路径 $p_0, p_1, \ldots, p_t$ 的**长度**是这条路径上连接相邻城市的 $t$ 条道路的长度之和。

在匈牙利，很多人都会在建国日去参加在两个主要城市举行的庆祝活动。当庆祝活动结束时，他们会回家。政府为了防止人群干扰当地人，所以决定在特定时刻封锁城市。每个城市被政府分配一个非负的**封锁时刻**。政府决定所有城市的封锁时刻总和不得超过 $K$。具体来说，对每个 $i$（$0 \leq i \leq N - 1$），分配给城市 $i$ 的封锁时刻是一个非负整数  $c[i]$。所有  $c[i]$ 之和不超过 $K$。

考虑一个城市 $a$ 和某个封锁时刻的分配方案，我们说城市 $b$ 是从城市 $a$ 可达的当且仅当以下两种情况中的任意一种情况成立。

情况 1：$b = a$。

情况 2：这两个城市之间的路径  $p_0, \ldots, p_t$ （$p_0 = a$ 且 $p_t = b$）满足以下条件：
* 路径 $p_0, p_1$ 的长度最多为 $c[p_1]$，并且
* 路径 $p_0, p_1, p_2$ 的长度最多为 $c[p_2]$，并且
* $\ldots$
* 路径 $p_0, p_1, p_2, \ldots, p_t$ 的长度最长为  $c[p_t]$。

今年，两个主要的庆祝地点位于城市 $X$ 和 $Y$。  
对于每一个封锁时刻的分配方案，可以定义一个**便利分数**，其定义为下面两个数字之和：
- 从城市 $X$ 可达的城市个数。
- 从城市 $Y$ 可达的城市个数。

注意如果一个城市既能从城市 $X$ 可达也能从城市 $Y$ 可达，那么它在计算便利分数时计算两次。

你的任务是计算能被某个封锁时刻分配方案实现的最大便利分数。

## 说明/提示

#### 【实现细节】

你要实现以下函数。

```
int max_score(int N, int X, int Y, int64 K, int[] U, int[] V, int[] W)
```

* $N$：城市的个数
* $X$，$Y$：两个主要庆祝城市
* $K$：封锁时刻总和的上界
* $U$，$V$： 长度为 $N - 1$ 的描述道路连接情况的数组
* $W$：长度为 $N - 1$ 的描述道路长度的数组
* 该函数要返回能被某个封锁时刻分配方案实现的最大便利分数
* 每个测试用例可以多次调用该函数



#### 【例子】


考虑以下调用：

```
max_score(7, 0, 2, 10,
          [0, 0, 1, 2, 2, 5], [1, 3, 2, 4, 5, 6], [2, 3, 4, 2, 5, 3])
```



这对应以下道路网络：

![](https://cdn.luogu.com.cn/upload/image_hosting/wf5uw4qd.png)



假设封锁时刻如下分配：

| **城市**         | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ |
|:----------------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **封锁时刻** | $0$ | $4$ | $0$ | $3$ | $2$ | $0$ | $0$ |



注意所有封锁时刻之和为 $9$，不超过 $K = 10$。城市 $0$，$1$ 和 $3$ 都是从城市 $X$（$X = 0$）可达的，而城市 $1$，$2$ 和 $4$ 都可以从城市 $Y$（$Y  = 2$）可达。 因此，便利分数为 $3+3 = 6$。不存在封锁时刻分配方案使得便利分数大于 $6$，所以该函数应该返回 $6$。



考虑另外一个调用：

```
max_score(4, 0, 3, 20, [0, 1, 2], [1, 2, 3], [18, 1, 19])
```



这对应以下道路网络：

![](https://cdn.luogu.com.cn/upload/image_hosting/zcw4gdi5.png)

假设封锁时间如下分配：

| **城市**         | $0$ | $1$ | $2$ | $3$ |
|:----------------:|:---:|:---:|:---:|:---:|
| **封锁时刻** | $0$ | $1$ | $19$| $0$ |



城市 $0$ 从城市 $X$（$X = 0$）可达，而城市 $2$ 和 $3$ 都是可以从城市 $Y$（$Y=3$）可达的。因此，便利分数是 $1 + 2 = 3$。不存在封锁时刻分配方案使得便利分数大于 $3$，所以函数应该返回 $3$。

#### 【约束条件】

* $2 \le N \le 200\,000$
* $0 \le X \lt Y \lt N$
* $0 \le K \le 10^{18}$
* $0 \le U[j] \lt V[j] \lt N$ (对每个 $j$ 满足 $0 \le j \le N - 2$)
* $1 \le W[j] \le 10^6$ (对每个 $j$ 满足 $0 \le j \le N - 2$)
* 利用这些道路可以从任意一个城市走到任意另外一个城市。
* $S_N \le 200\,000$，其中 $S_N$ 是所有调用函数 `max_score` 的  $N$ 的总和。


#### 【子任务】


我们说一个道路网络是**线性的**如果道路 $i$ 连接城市 $i$ 和 $i+1$（对每个$0 \le i \le N - 2$ 的 $i$）。

1. （8 分）从城市 $X$ 到城市 $Y$ 的路径长度大于 $2K$。
1. （9 分）$S_N \le 50$，道路网络是线性的。
1. （12 分）$S_N \le 500$，道路网络是线性的。
1. （14 分）$S_N \le 3\,000$，道路网络是线性的。
1. （9 分）$S_N \le 20$
1. （11 分）$S_N \le 100$
1. （10 分）$S_N \le 500$
1. （10 分）$S_N \le 3\,000$
1. （17 分）无额外的约束条件。

## 样例 #1

### 输入

```
2
7 0 2 10
0 1 2
0 3 3
1 2 4
2 4 2
2 5 5
5 6 3
4 0 3 20
0 1 18
1 2 1
2 3 19
```

### 输出

```
6
3
```

# AI分析结果


### 💡 Kay的C++算法解析：封锁时刻 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：贪心算法与树形结构处理

🗣️ **初步分析**：
> 本题的核心在于将树形网络转化为物品选择问题。每个城市可视为一个物品，有两种选择：花费 `min(dx, dy)` 获得1点贡献，或额外花费 `max(dx, dy) - min(dx, dy)` 再获1点贡献（总贡献2）。关键在于处理X-Y路径上的特殊依赖：路径上的点必须至少花费一次，这通过预扣代价+调整策略解决。
> - **算法流程**：① BFS计算各点到X/Y的距离；② 提取X-Y路径并预扣代价；③ 剩余点按代价排序；④ 贪心选择最优组合
> - **可视化设计**：像素网格展示树结构（X/Y高亮），动态染色路径点。贪心过程用三色标记：灰(未选)/绿(选1)/蓝(选2)，代价条实时更新。复古音效：选择时"叮"，超额时"嘟"，成功时8-bit胜利音效。
> - **游戏化交互**：设计为"像素探险"模式，每完成一个子树的选择视为过关，连击奖励机制激励正确选择。

---

#### 2. 精选优质题解参考
<eval_intro>
以下题解在思路清晰度、代码规范性和算法优化方面表现突出（均≥4星），特别推荐前三条：

**题解一（作者：Alex_Wei）**
* **点评**：思路直击核心——将问题转化为经典贪心模型CF436E。亮点在于巧妙处理路径依赖：强制扣除路径点基础代价后，用树状数组维护剩余选择。代码中`f[i]`命名简洁，边界处理严谨（特判K<0），空间优化至O(n)。实践价值高，可直接用于竞赛，作者调试心得强调路径处理是易错点，值得学习者注意。

**题解二（作者：Purslane）**
* **点评**：采用反悔贪心实现，用五个优先队列动态维护状态转移。亮点在于独立证明树形依赖可忽略（因代价随深度递增），大幅简化问题。变量名如`cost1/cost2`含义明确，代码模块化（分离BFS/贪心逻辑）。虽常数较大但结构清晰，作者自嘲"忘记CF436E解法"的调试经历提醒我们复习经典模型的重要性。

**题解三（作者：definieren）**
* **点评**：创新性提出"中点划分法"，将树分为三个区域独立处理。亮点在于严格证明区域内的选择无后效性，避免路径强制扣除的复杂操作。代码中`disX/disY`数组命名规范，但实现稍复杂。作者提供的反例测试（五元链）极具教学价值，帮助理解算法正确性。

---

#### 3. 核心难点辨析与解题策略
<difficulty_intro>
解决本题需突破三大难点：

1.  **依赖约束的处理**  
    * **分析**：X-Y路径上的点需至少被覆盖一次，否则子树贡献无效。优质解法均先预扣路径点的`min(dx,dy)`代价（如Alex_Wei第84行），再调整剩余代价。  
    * 💡 **学习笔记**：树链依赖可转化为预扣代价+独立子问题。

2.  **树形结构到物品的转化**  
    * **分析**：将每个城市转化为`(a_i, b_i)`物品（a=min代价, b=max-min代价）。利用子树内代价单调性（父节点代价≤子节点）保证贪心正确性，如Purslane题解所述。  
    * 💡 **学习笔记**：树形依赖成立时，直接套用序列贪心策略。

3.  **双代价贪心的实现**  
    * **分析**：当物品可贡献1或2时，需高效枚举分界点（左侧贡献≥1，右侧≤1）。Alex_Wei用BIT维护前缀和，Purslane用堆模拟反悔，均达O(n log n)。  
    * 💡 **学习笔记**：排序后双指针扫描是处理贡献分界的通用技巧。

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧A（问题分解）**：将树拆解为X-Y路径+独立子树，路径处理保证依赖，子树直接贪心。
- **技巧B（模型转化）**：识别问题等价于CF436E，复用其贪心框架。
- **技巧C（边界处理）**：预扣路径代价后立即检查K≥0（Alex_Wei第85行），避免无效计算。
- **技巧D（数据结构优化）**：用BIT/堆维护代价和，避免O(n²)暴力。

---

#### 4. C++核心代码实现赏析
<code_intro_overall>
**本题通用核心C++实现参考**
* **说明**：综合自Alex_Wei与Purslane的贪心框架，路径处理与树形BFS分离，逻辑清晰。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5;
const ll INF = 1e18;

vector<pair<int, int>> G[N];
ll disX[N], disY[N];
int n, X, Y, path[N];
bool onPath[N];

void bfs(int s, ll dis[]) {
    queue<int> q; q.push(s); dis[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : G[u]) {
            if (dis[v] == INF) {
                dis[v] = dis[u] + w; q.push(v);
            }
        }
    }
}

void extract_path() { // 提取X-Y路径
    vector<int> parent(n, -1);
    queue<int> q; q.push(X); parent[X] = X;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : G[u]) {
            if (parent[v] == -1) {
                parent[v] = u; q.push(v);
            }
        }
    }
    for (int u = Y; u != X; u = parent[u]) {
        onPath[u] = true;  // 标记路径点
    }
}

int max_score(int N, int X, int Y, ll K, vector<int> U, vector<int> V, vector<int> W) {
    // 初始化与建图
    n = N; ::X = X; ::Y = Y;
    for (int i = 0; i < n; i++) disX[i] = disY[i] = INF;
    for (int i = 0; i < n-1; i++) {
        G[U[i]].push_back({V[i], W[i]});
        G[V[i]].push_back({U[i], W[i]});
    }

    // BFS计算距离
    bfs(X, disX); bfs(Y, disY);
    extract_path();

    // 处理路径点
    ll baseCost = 0;
    for (int i = 0; i < n; i++) {
        if (onPath[i]) {
            baseCost += min(disX[i], disY[i]); // 预扣基础代价
        }
    }
    if ((K -= baseCost) < 0) return 0;

    // 构建物品序列
    vector<pair<ll, ll>> items;
    for (int i = 0; i < n; i++) {
        ll a = min(disX[i], disY[i]);
        ll b = max(disX[i], disY[i]) - a;
        items.push_back({a, b});
    }

    // 贪心选择（具体实现见Alex_Wei/Purslane的BIT/堆代码）
    return greedySelect(items, K) + path.size();
}
```
* **代码解读概要**：
  1. **BFS距离计算**：两次BFS求各点到X/Y的最短路径
  2. **路径提取**：从Y回溯父节点标记X-Y路径
  3. **预扣代价**：路径点强制选择最小代价
  4. **物品转化**：非路径点转化为`(a,b)`物品
  5. **贪心核心**：调用贪心模块计算最大收益

---
<code_intro_selected>
**题解一（Alex_Wei）片段赏析**
* **亮点**：树状数组高效维护前缀代价和
* **核心代码片段**：
```cpp
struct BIT {
    vector<ll> tree;
    void update(int i, ll v) {
        for (; i <= n; i += i&-i) tree[i] = min(tree[i]+v, INF);
    }
    ll query(int i) { // 前i项和
        ll s = 0;
        for (; i; i -= i&-i) s = min(s+tree[i], INF);
        return s;
    }
} bit;
```
* **代码解读**：
  > 该树状数组用于维护物品按`b_i`排序后的代价前缀和。`update`操作添加物品代价，`query`获取前`i`项和。特殊处理溢出（`min(..., INF)`），避免K>1e18时出错。  
  > **关键行**：`i += i&-i` 是树状数组核心操作，以O(log n)跳转索引。
* 💡 **学习笔记**：树状数组是维护前缀信息的利器，尤其适合代价求和+二分查找。

**题解二（Purslane）片段赏析**
* **亮点**：五优先队列实现反悔贪心
* **核心代码片段**：
```cpp
priority_queue<Node> q1; // 选1的代价
priority_queue<Node> q2; // 选2的额外代价
while (ans < 2*n) {
    ll cost1 = q1.top().cost; 
    ll cost2 = q2.top().cost;
    if (cost1 < cost2) { // 选1更优
        total += cost1; q1.pop();
        q2.push({item.id, b_i - a_i}); // 加入反悔选项
    } else { // 选2更优
        total += cost2; q2.pop();
    }
    if (total > K) break;
    ans++;
}
```
* **代码解读**：
  > 用两个优先队列动态维护当前最优选择。`q1`存选1的代价，`q2`存选2的额外代价。每次选最小代价操作，选1后向`q2`加入"升级为2"的反悔选项。  
  > **关键行**：`q2.push({item.id, b_i - a_i})` 实现反悔逻辑——后续可通过支付差额代价将1级升级为2级。
* 💡 **学习笔记**：反悔贪心通过"可撤销选项"实现全局最优，是贪心算法的进阶技巧。

---

#### 5. 算法可视化：像素动画演示
<visualization_intro>
为直观展示算法流程，设计**"像素探险"**动画方案，融合8-bit复古游戏元素：

* **主题**：树形地图探索 + 贪心决策
* **风格**：FC红白机16色调色板（城市=方块，道路=像素线）
* **核心演示**：
  1. **初始化**：深绿网格画树结构，X/Y标为红/蓝色，路径点黄闪
  2. **BFS扩散**：从X/Y泛波纹扩散，色块深浅表距离（深=近，浅=远）
  3. **路径标记**：X-Y路径点播放"链条连接"动画（音效：金属咔哒声）
  4. **贪心过程**：
     - 非路径点按`b_i`排序，显示为移动方块队列
     - 滑块控制分界点：左侧方块绿(选1)/蓝(选2)，右侧灰(不选)
     - 每点选择时显示代价弹窗，总代价条(红色)随选择增长
  5. **AI演示**：自动模式下，分界点从左向右扫，方块自动变色（速度可调）
  6. **结果展示**：成功时路径点亮彩虹色，方块爆炸成星尘（音效：胜利旋律）

* **交互面板**：
  - 控制区：开始/暂停/重置 + 速度滑块
  - 模式切换：手动步进 vs AI自动演示
  - 代价显示：当前总代价/K（进度条形式）

* **技术实现**：Canvas绘制树+方块，Web Audio API触发音效，状态机管理算法步骤。

---

#### 6. 拓展练习与相似问题思考
<similar_problems_intro>
掌握本题的核心在于**树形依赖转化+双代价贪心**，以下问题可强化相关技能：

1. **洛谷 P436E** - Cardboard Box  
   🗣️ *推荐理由*：本题贪心策略的直接来源，无树形依赖，适合理解基础模型。

2. **洛谷 P3627** - 抢掠计划  
   🗣️ *推荐理由*：需处理树形依赖（银行道路为树），练习将树转化为序列的技巧。

3. **洛谷 P5632** - 区间覆盖  
   🗣️ *推荐理由*：双代价选择（覆盖长度/花费）的变形问题，强化贪心决策能力。

---

#### 7. 学习心得与经验分享
<insights_intro>
题解中的调试经验对实战极具价值：

> **参考经验（Alex_Wei）**：*"路径点处理时，若未检查K≥0直接贪心，会导致负数溢出。我在调试中花费1小时定位此边界问题。"*  
> **点评**：边界检查是竞赛编程的核心防御手段，尤其涉及预扣代价时，必须立即检查剩余可行性。建议学习者养成"扣代价后必判K≥0"的习惯。

> **参考经验（Purslane）**：*"忘记CF436E解法后，我从零推导反悔贪心，发现树形依赖可忽略的本质。"*  
> **点评**：重新推导经典算法能加深理解。当遇到变形问题时，回归问题本质（如本题的代价单调性）往往能破局。

---

本次分析到此结束。通过树形问题转化、路径处理与贪心优化，我们高效解决了封锁时刻问题。记住：将复杂约束拆解为独立子问题+复用经典模型，是提升算法能力的关键！💪

---
处理用时：157.30秒
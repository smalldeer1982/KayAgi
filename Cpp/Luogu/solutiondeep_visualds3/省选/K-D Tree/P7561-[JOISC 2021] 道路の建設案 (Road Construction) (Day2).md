# 题目信息

# [JOISC 2021] 道路の建設案 (Road Construction) (Day2)

## 题目背景

10s,2048M

## 题目描述

JOI 国是一个 $x\times y$ 的二维平面，王国里有 $n$ 个城镇，分别编号为 $1, 2, \cdots, n$，其中第 $i$ 个城镇的 **坐标** 为 $(x_i, y_i)$。

在 JOI 国，正计划修建连接两座城镇的路（下文简称：**「修路的项目」**），路有 $k$ 条。连接两个不同的城镇 $a$ 和 $b$ 将花费 $|x_a − x_b| + |y_a − y_b|$ 元。若有一条连接 $c$，$d$ 的路，则不需要也不可以在建一条连接 $d$，$c$ 的路，因为它们是相同的。

你要管理这个「修路的项目」，为了计算花费情况，你得弄明白连接一些城镇所需的花费。在这 $\dfrac{n\cdot(n-1)}{2}$ 条道路中，你想了解最便宜的 $k$ 条道路的花费。

给你城镇的坐标以及 $k$，请计算最便宜的 $k$ 条路所需要的钱。

## 说明/提示

#### 样例 #1 解释
有 $\dfrac{3 \times 2}{2} = 3$ 种方案。

- 城镇 $1 \to$ 城镇 $2$，$|(-1)-0|+|0-2| = 3$ 日元。
- 城镇 $1 \to$ 城镇 $3$，$|(-1)-0|+|0-0| = 1$ 日元。
- 城镇 $2 \to$ 城镇 $3$，$|0-0|+|2-0| = 2$ 日元。

将其进行排序为 $1,2,3$，所以输出是 $1$ 和 $2$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #2 解释

有 $\dfrac{5 \times 4}{2} = 10$ 种方案。

将钱数排序后是 $2, 2, 3, 3, 3, 3, 4, 4, 4, 4$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #3 解释

本样例满足 Subtask $1, 2, 4, 5, 6$。

#### 样例 #4 解释

本样例满足 Subtask $1, 4, 5, 6$。

#### 数据范围与约定

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | $n$ | $k$ | $y_i$ |
| :----: | :----: | :----: | :----:| :----: |
| $1$ | $5\%$ | $\le 10^3$ | / | / |
| $2$ | $6\%$ | / | / | $=0$ |
| $3$ | $7\%$ | / | $=1$ | / |
| $4$ | $20\%$ | / | $\le 10$ | / |
| $5$ | $27\%$ |  / | $\le 10 ^ 5$ | / |
| $6$ | $35\%$ | / | / | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：
- $2 \le n \le 2.5 \times 10^5$；
- $1 \le k \le \min(2.5\times 10^5,\ \dfrac{n\cdot(n-1)}{2}$)；
- $-10^9 \le x_i, y_i \le 10^9$，且 $1 \le i \le n$；
- $(x_i,y_i)\not = (x_j, y_j)$ 且 $1 \le i < j \le n$。

#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 2 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/2021-sp-d2-notice.pdf) [T2 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/road_construction.pdf)。


## 样例 #1

### 输入

```
3 2
-1 0
0 2
0 0
```

### 输出

```
1
2
```

## 样例 #2

### 输入

```
5 4
1 -1
2 0
-1 0
0 2
0 -2
```

### 输出

```
2
2
3
3
```

## 样例 #3

### 输入

```
4 6
0 0
1 0
3 0
4 0
```

### 输出

```
1
1
2
3
3
4
```

## 样例 #4

### 输入

```
10 10
10 -8
7 2
7 -8
-3 -6
-2 1
-8 6
8 -1
2 4
6 -6
2 -1
```

### 输出

```
3
3
4
5
6
6
6
7
7
7
```

# AI分析结果

# 💡 Kay的C++算法解析：[JOISC 2021] 道路の建設案 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（二分答案 + 双指针 + 有序集合维护）

🗣️ **初步分析**：  
解决这道题的关键，就像玩“猜数字+找朋友”游戏——首先用**二分答案**猜一个距离`mid`（类似猜数字游戏），然后检查有多少点对的距离≤`mid`（找“距离不超过mid的朋友”）。如果朋友数≥k，说明`mid`太大；反之则太小。  

具体来说：  
1. **坐标变换**：先把曼哈顿距离转成切比雪夫距离（点(x,y)→(x+y, x−y)），这样原问题的曼哈顿距离就变成了新坐标的切比雪夫距离（max(|x1−x2|, |y1−y2|)），更容易处理。  
2. **二分答案**：猜一个距离`mid`，检查有多少点对的切比雪夫距离≤`mid`。  
3. **Check的技巧**：用**双指针**维护一个“滑动窗口”——只看x坐标在`[当前点x−mid, 当前点x]`的点（保证x差≤mid）；再用**有序集合（如multiset）**快速找到这些点中y坐标在`[当前点y−mid, 当前点y+mid]`的点（保证y差≤mid），这样就能统计符合条件的点对。  

**核心难点**：如何高效统计符合条件的点对（直接枚举所有点对会超时）。**解决方案**：用双指针缩小x范围，用有序集合快速查找y范围，把时间复杂度从O(n²)降到O(n log n)。  

**可视化设计思路**：  
我们用8位像素风做一个“像素点探险家”动画——  
- 屏幕上展示像素化的点（不同颜色代表不同点），背景是复古网格。  
- 二分答案时，顶部显示“猜的距离mid”，用闪烁的数字提示。  
- Check过程中，双指针像两个滑动的“像素窗”，左边窗（左指针）慢慢右移，右边窗（当前点）逐个遍历，窗内的点用“浅蓝色”高亮。  
- 有序集合用“像素方块堆”展示，查找y范围时，符合条件的方块会“闪烁+叮”一声，代表找到朋友。  
- 完成统计后，用“胜利音效”提示，并用红色数字显示符合条件的点对数。  


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码可读性、算法有效性等角度，筛选了以下优质题解：  
</eval_intro>

**题解一：hfjh（赞11）**  
* **点评**：这份题解的思路像“搭积木”一样清晰——先转切比雪夫距离，再二分答案，check时用双指针+multiset维护y坐标。代码规范（变量名`p[i].x`/`p[i].y`明确），边界处理严谨（比如排序时按x优先），特别是**用multiset的`lower_bound`快速找y范围**的技巧，直接命中问题核心。实践中，这种写法容易调试，是竞赛中的“标准解法”。

**题解二：7KByte（赞2）**  
* **点评**：此题解的代码“短小精悍”，把二分+双指针+set的逻辑压缩得很简洁。比如用`queue`维护双指针的左边界，用`set`存y坐标，查找时直接遍历`lower_bound`到`y+mid`的点。虽然注释少，但逻辑链完整，适合学完基础后模仿。

**题解三：SunnyYuan（赞0）**  
* **点评**：这份题解的“点睛之笔”是**解释了为什么要check(l−1)**——因为二分得到的`l`是第k小的距离，但check(l)时可能没统计完所有≤l的点对，所以要check(l−1)补全≤l−1的点对，再用`l`补齐到k个。这个细节让新手避免“漏统计”的坑，非常实用。


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决这道题的三个“拦路虎”，我们逐个拆解：  
</difficulty_intro>

### 1. 为什么要转切比雪夫距离？  
**难点**：曼哈顿距离的点对统计很难高效处理（需要同时看x和y的差之和）。  
**策略**：转切比雪夫距离后，只要x差≤mid且y差≤mid，总距离就≤mid——把“和”的条件拆成“两个差都≤mid”，更容易用双指针+有序集合处理。  

💡 **学习笔记**：遇到曼哈顿距离的问题，先想想能不能转切比雪夫！

### 2. Check时如何快速统计点对？  
**难点**：直接枚举所有点对会超时（O(n²)）。  
**策略**：用双指针缩小x范围（只看x差≤mid的点），用有序集合快速找y差≤mid的点（有序集合的`lower_bound`可以O(log m)找到y的左边界，m是窗口内的点数）。  

💡 **学习笔记**：滑窗+有序集合，是处理“二维范围查询”的常用组合！

### 3. 为什么要check(l−1)？  
**难点**：二分得到的`l`是第k小的距离，但check(l)时可能没统计完所有≤l的点对（因为统计到k个就提前返回了）。  
**策略**：check(l−1)统计所有≤l−1的点对（数量一定<k），再用`l`补齐剩下的k−cnt个点对——这样就能得到前k小的距离。  

💡 **学习笔记**：二分找第k小的问题，往往需要“补全”最后一步！


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一个通用核心实现，帮你建立整体框架：  
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：综合hfjh、7KByte、SunnyYuan的题解，提炼出的清晰实现。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
using namespace std;
using ll = long long;

const int N = 250010;
const ll INF = 1e18;

struct Node {
    ll x, y;
    bool operator<(const Node& a) const { return x < a.x || (x == a.x && y < a.y); }
};
struct CmpY { bool operator()(const Node& a, const Node& b) const { return a.y < b.y; } };

int n, k;
Node p[N];
ll ans[N], cnt;

bool check(ll mid) {
    multiset<Node, CmpY> s;
    queue<int> q;
    cnt = 0;
    s.insert({INF, INF}), s.insert({-INF, -INF}); // 哨兵，避免越界

    for (int i = 1; i <= n; ++i) {
        // 双指针：移除x < p[i].x - mid的点
        while (!q.empty() && p[q.front()].x < p[i].x - mid) {
            s.erase(s.find(p[q.front()]));
            q.pop();
        }
        // 找y在[p[i].y - mid, p[i].y + mid]的点
        Node tmp = {0, p[i].y - mid};
        auto it = s.lower_bound(tmp);
        while (it != s.end() && it->y <= p[i].y + mid) {
            ans[++cnt] = max(p[i].x - it->x, abs(p[i].y - it->y));
            if (cnt >= k) return true;
            ++it;
        }
        // 加入当前点
        q.push(i);
        s.insert(p[i]);
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        ll x, y;
        cin >> x >> y;
        p[i] = {x + y, x - y}; // 转切比雪夫
    }
    sort(p + 1, p + n + 1); // 按x排序

    // 二分答案
    ll l = 1, r = INF;
    while (l < r) {
        ll mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }

    // 补全≤l-1的点对，再用l补齐
    check(l - 1);
    sort(ans + 1, ans + cnt + 1);
    for (int i = 1; i <= cnt; ++i) cout << ans[i] << '\n';
    for (int i = cnt + 1; i <= k; ++i) cout << l << '\n';

    return 0;
}
```

* **代码解读概要**：  
  1. **输入与变换**：读取点坐标，转成切比雪夫坐标。  
  2. **二分答案**：猜`mid`，用`check`函数验证。  
  3. **Check函数**：双指针维护x范围，multiset维护y范围，统计符合条件的点对。  
  4. **输出结果**：先输出≤l−1的点对，再用l补齐到k个。


### 针对各优质题解的片段赏析

#### 题解一：hfjh（赞11）  
* **亮点**：用`multiset`存y坐标，直接遍历`lower_bound`到`y+mid`的点，逻辑直白。  
* **核心代码片段**：  
  ```cpp
  multiset<Node> s;
  queue<int> q;
  for (int i = 1; i <= n; ++i) {
      while (!q.empty() && p[i].x - p[q.front()].x > mid) {
          s.erase(s.find(p[q.front()]));
          q.pop();
      }
      auto it = s.lower_bound({0, p[i].y - mid});
      while (it != s.end() && it->y <= p[i].y + mid) {
          ans[++cnt] = max(p[i].x - it->x, abs(p[i].y - it->y));
          if (cnt >= k) return true;
          ++it;
      }
      q.push(i);
      s.insert(p[i]);
  }
  ```
* **代码解读**：  
  - `multiset<Node>`按y排序，`lower_bound({0, p[i].y - mid})`找到第一个y≥p[i].y−mid的点。  
  - 遍历到y≤p[i].y+mid的点，计算距离并存入`ans`——这一步就是“找朋友”的过程！  
* **学习笔记**：`multiset`的`lower_bound`是处理“有序范围查询”的神器！


#### 题解三：SunnyYuan（赞0）  
* **亮点**：解释了“为什么要check(l−1)”，补全点对的逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  check(l - 1);
  sort(ans + 1, ans + cnt + 1);
  for (int i = 1; i <= cnt; ++i) cout << ans[i] << '\n';
  for (int i = cnt + 1; i <= k; ++i) cout << l << '\n';
  ```
* **代码解读**：  
  - `check(l−1)`统计所有≤l−1的点对（数量<k）。  
  - 用`l`补齐剩下的k−cnt个点对——因为l是第k小的距离，剩下的点对距离都是l。  
* **学习笔记**：二分得到的结果需要“补全细节”，否则会漏统计！


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素点的“找朋友大冒险”  
**风格**：8位FC游戏风（复古像素、鲜艳色块、简单音效）。  

### 🌟 核心演示内容  
1. **初始化**：  
   - 屏幕显示20x20的像素网格，点用不同颜色的“小方块”表示（比如红色代表当前点，蓝色代表滑窗内的点）。  
   - 顶部显示“目标：找前k小的距离”，底部有“开始/单步/重置”按钮、速度滑块。  
   - 8位风格的背景音乐（比如《超级马里奥》的轻快旋律）响起。

2. **坐标变换动画**：  
   - 点击“开始”，所有点从(x,y)→(x+y, x−y)，用“闪烁+滑动”动画展示变换过程（比如点从(1,2)滑到(3,−1)）。

3. **二分答案动画**：  
   - 顶部显示“猜的距离：mid=XX”，用黄色数字闪烁。  
   - 如果check返回true（朋友数≥k），mid变成红色并缩小；否则变成绿色并放大——像“猜数字游戏”一样互动。

4. **Check过程动画**：  
   - **双指针滑动**：左指针（蓝色箭头）慢慢右移，右指针（红色箭头）逐个遍历点，滑窗内的点变成浅蓝色。  
   - **有序集合查找**：当前点（红色）的y范围用“黄色框”标出，multiset中的点用“白色方块”排列，`lower_bound`找到的点变成橙色，遍历到的点闪烁并发出“叮”的音效。  
   - **统计点对**：每找到一个点对，屏幕右侧的“朋友数”+1，用绿色数字显示。

5. **结果展示**：  
   - 二分结束后，屏幕弹出“胜利！”提示，播放上扬的音效。  
   - 按顺序显示前k小的距离，每个距离用“像素气泡”弹出，点击气泡可回看对应的点对。

### 🎯 交互设计  
- **单步执行**：点击“单步”，动画走一步（比如右指针移一个点，或双指针缩一次窗）。  
- **自动播放**：点击“自动”，动画按自定义速度（滑块调节）播放，像“贪吃蛇AI”一样自动找朋友。  
- **重置**：点击“重置”，回到初始状态，重新开始。


## 6. 拓展练习与相似问题

### 🔍 相似问题  
1. **洛谷P4357 [CQOI2016]K远点对**：求前k大的曼哈顿距离（反过来想，用大根堆维护）。  
2. **洛谷P1429 平面最近点对**：求最近的点对（可以用分治，或本题的二分+双指针）。  
3. **洛谷P5930 [POI2003]MEG**：统计距离≤d的点对数量（本题的check函数的简化版）。

### 📝 进阶练习建议  
- 尝试用**主席树**代替multiset，优化check的时间复杂度（主席树可以处理动态插入的有序集合）。  
- 思考如何处理**带权点对**（比如点有重量，统计权值和≤k的点对）——将multiset换成带权的有序结构。


## 7. 学习心得与经验分享  
**参考经验（来自SunnyYuan）**：  
“二分得到l后，一定要check(l−1)！因为check(l)时可能没统计完所有≤l的点对，比如l是第k小的距离，但check(l)时统计到第k个点对就返回了，后面还有≤l的点对没算。所以要check(l−1)补全≤l−1的点对，再用l补齐到k个。”  

**点评**：这个经验解决了“漏统计”的关键问题。新手常犯的错误是“二分完直接输出l”，但忽略了“check(l)没统计完”的情况——这个细节让代码更严谨。


## 🔚 结语  
这道题的核心是“把复杂问题拆成简单步骤”：转坐标→二分猜数→滑窗找朋友→补全结果。编程的乐趣在于“用技巧解决看似不可能的问题”——比如用双指针+有序集合把O(n²)的问题降到O(n log n)。  

下次遇到“统计点对距离”的问题，试试今天学的“二分+双指针+有序集合”组合吧！💪  

---  
Kay的C++算法解析到此结束，我们下次见！✨

---
处理用时：107.58秒
# 题目信息

# 【模板】扩展卢卡斯定理/exLucas

## 题目背景

这是一道模板题。

## 题目描述

求

$${\mathrm{C}}_n^m \bmod{p}$$

其中 $\mathrm{C}$ 为组合数。

## 说明/提示

对于 $100 \%$ 的数据，$1 \le m \le n \le {10}^{18}$，$2 \le p \le {10}^6$，**不保证** $p$ 是质数。

## 样例 #1

### 输入

```
5 3 3```

### 输出

```
1```

## 样例 #2

### 输入

```
666 233 123456```

### 输出

```
61728```

# AI分析结果

---
# 💡 Kay的C++算法解析：【模板】扩展卢卡斯定理/exLucas 深入学习指南 💡

## 引言
今天我们要攻克的是组合数取模的“终极模板题”——扩展卢卡斯定理（exLucas）。当模数不再是质数时，普通卢卡斯定理就“失灵”了，而扩展卢卡斯能帮我们解决这个难题。接下来，我们会一步步拆解思路，理解核心算法，并通过可视化动画直观感受它的运作过程！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（组合数取模）、扩展卢卡斯定理、中国剩余定理（CRT）

### 初步分析
扩展卢卡斯定理的核心思想可以比喻成“**拆分拼图游戏**”：  
如果模数`p`是合数（比如`12=2²×3¹`），我们先把它拆成**互质的质数幂块**（比如`2²`和`3¹`）；然后分别计算组合数`C(n,m)`对每个质数幂块的余数（相当于拼好每一块小拼图）；最后用中国剩余定理（CRT）把这些余数“拼回”成最终结果（完成整个拼图）。

### 核心算法流程
1. **模数分解**：把`p`分解为`p = p₁^k₁ × p₂^k₂ × … × p_t^k_t`（`p_i`是质数）。  
2. **单质数幂计算**：对每个`p_i^k_i`，计算`C(n,m) mod p_i^k_i`——这是关键难点！  
   - 分离阶乘中的`p_i`因子：把`n!`拆成`F(n) × p_i^G(n)`（`F(n)`不含`p_i`因子，`G(n)`是`n!`中`p_i`的个数）。  
   - 计算`F(n)`：通过**循环节**快速计算不含`p_i`的阶乘部分（比如`1×2×4×5×7×8`是`3²`的循环节）。  
   - 求逆元：因为`F(n)`与`p_i^k_i`互质，用扩展欧几里得求逆元。  
3. **CRT合并**：把各个质数幂的结果合并成最终答案。

### 可视化设计思路
我们会设计一个**像素风“模数拼图工厂”**动画：  
- **场景**：8位像素风格的工厂车间，模数`p`是一个大像素块，被“拆分机”拆成多个质数幂小方块（比如`12`拆成`4`和`3`）。  
- **单质数幂计算**：每个小方块内播放“阶乘分离游戏”——阶乘数流经过“筛子”过滤掉`p_i`因子，剩下的数进入“循环节传送带”（循环动画展示`1×2×4×5…`），最后“逆元计算器”弹出结果。  
- **CRT合并**：小方块结果被“拼图机器人”拼成最终答案，伴随“叮”的胜利音效。  
- **交互**：支持单步执行（看每一步拆分/计算）、自动播放（像工厂流水线一样运行），速度滑块调节节奏。


## 2. 精选优质题解参考

### 题解一：Fading（赞：251）
**点评**：这是一篇“保姆级”题解，思路推导极其详细（比如用`22!`的例子解释循环节），代码结构清晰（分`F`函数计算不含质因子的阶乘、`G`函数计算质因子个数、`C_PK`计算单质数幂结果、`exLucas`合并CRT）。代码中`fast_mul`和`fast_pow`等工具函数封装完善，边界处理严谨（比如`inv`函数用扩展欧几里得求逆元），非常适合入门学习。

### 题解二：Great_Influence（赞：94）
**点评**：题解的亮点是**简洁性**——用最少的代码实现核心逻辑。比如`fac`函数递归计算不含质因子的阶乘，`C`函数直接整合阶乘、逆元和质因子幂次的计算，`CRT`函数用一行公式合并结果。代码风格干练，适合理解扩展卢卡斯的“最小核心”。

### 题解三：maxiaomeng（赞：1）
**点评**：题解的优势是**结构清晰**——把问题拆成“模数分解→单质数幂计算→CRT合并”三个独立模块，每个模块用函数封装（`init`分解模数、`F`计算不含质因子的阶乘、`C`计算组合数）。代码中特别标注了`__int128`的使用场景（避免阶乘计算溢出），细节处理到位，适合学习工程化编程。


## 3. 核心难点辨析与解题策略

### 关键点1：如何计算阶乘中的质因子个数？
**难点**：直接遍历计算`n!`中的`p`因子会超时（`n`到`1e18`）。  
**解决策略**：用递归公式`G(n) = floor(n/p) + G(floor(n/p))`（比如`G(10,3)=3+1=4`，因为`10!`中有3个`3`的倍数，1个`9`的倍数）。  
**学习笔记**：质因子个数的计算是“层层剥笋”——每一层剥掉`p`的倍数，直到剥完。

### 关键点2：如何计算不含质因子的阶乘部分？
**难点**：`n!`不含`p`的因子的部分太多，无法暴力计算。  
**解决策略**：利用**循环节**——`mod p^k`下，不含`p`的数每`p^k`个形成一个循环（比如`mod 9`时，`1×2×4×5×7×8`是循环节）。计算循环节的幂次（有多少个完整循环），再乘上剩余部分的乘积。  
**学习笔记**：循环节是“重复的积木”——用快速幂计算积木的重复次数，再补全剩下的小块。

### 关键点3：如何合并多个质数幂的结果？
**难点**：每个质数幂的结果是独立的，需要合并成一个数。  
**解决策略**：中国剩余定理（CRT）——对于`x ≡ a_i mod m_i`（`m_i`互质），`x = sum(a_i × M_i × inv(M_i, m_i)) mod M`（`M=product(m_i)`，`M_i=M/m_i`）。  
**学习笔记**：CRT是“拼图胶水”——把不同模块的结果粘合成完整答案。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：本代码综合了Fading和maxiaomeng的题解思路，保留核心逻辑，简化冗余代码。

```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;

ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) { x = 1; y = 0; return a; }
    ll d = exgcd(b, a%b, y, x);
    y -= a/b * x;
    return d;
}

ll fast_pow(ll a, ll b, ll p) {
    ll res = 1;
    while (b) {
        if (b&1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

ll F(ll n, ll P, ll PK) { // 计算n! / P^G(n) mod PK
    if (n == 0) return 1;
    ll rou = 1; // 循环节乘积
    for (ll i = 1; i <= PK; i++) if (i % P != 0) rou = rou * i % PK;
    rou = fast_pow(rou, n / PK, PK);
    ll rem = 1; // 剩余部分乘积
    for (ll i = n / PK * PK + 1; i <= n; i++) if (i % P != 0) rem = rem * i % PK;
    return F(n / P, P, PK) * rou % PK * rem % PK;
}

ll G(ll n, ll P) { // 计算n!中P的因子个数
    if (n < P) return 0;
    return G(n / P, P) + n / P;
}

ll inv(ll a, ll p) { // 扩展欧几里得求逆元
    ll x, y;
    exgcd(a, p, x, y);
    return (x % p + p) % p;
}

ll C_PK(ll n, ll m, ll P, ll PK) { // 计算C(n,m) mod PK（P^k）
    ll fz = F(n, P, PK);
    ll fm1 = inv(F(m, P, PK), PK);
    ll fm2 = inv(F(n - m, P, PK), PK);
    ll mi = fast_pow(P, G(n, P) - G(m, P) - G(n - m, P), PK);
    return fz * fm1 % PK * fm2 % PK * mi % PK;
}

ll exLucas(ll n, ll m, ll P) { // 扩展卢卡斯主函数
    vector<ll> a, b; // a: 质数幂，b: 对应余数
    ll tmp = P;
    for (ll i = 2; i * i <= tmp; i++) {
        if (tmp % i == 0) {
            ll PK = 1;
            while (tmp % i == 0) { PK *= i; tmp /= i; }
            a.push_back(PK);
            b.push_back(C_PK(n, m, i, PK));
        }
    }
    if (tmp != 1) { a.push_back(tmp); b.push_back(C_PK(n, m, tmp, tmp)); }
    // CRT合并
    ll ans = 0;
    for (ll i = 0; i < a.size(); i++) {
        ll M = P / a[i];
        ll T = inv(M, a[i]);
        ans = (ans + b[i] * M % P * T % P) % P;
    }
    return ans;
}

int main() {
    ll n, m, P;
    cin >> n >> m >> P;
    cout << exLucas(n, m, P) << endl;
    return 0;
}
```

**代码解读概要**：  
1. **工具函数**：`exgcd`（扩展欧几里得）、`fast_pow`（快速幂）、`inv`（逆元）。  
2. **核心函数**：`F`（计算不含质因子的阶乘）、`G`（计算质因子个数）、`C_PK`（单质数幂组合数）、`exLucas`（分解模数+CRT合并）。  
3. **主函数**：读取输入，调用`exLucas`计算并输出结果。


### 题解一：Fading（核心片段赏析）
**亮点**：递归计算`F`函数，清晰展示循环节和剩余部分的乘积。  
**核心代码片段**：
```cpp
ll F(ll n, ll P, ll PK) {
    if (n == 0) return 1;
    ll rou = 1;
    for (ll i = 1; i <= PK; i++) if (i % P) rou = rou * i % PK;
    rou = fast_pow(rou, n / PK, PK);
    ll rem = 1;
    for (ll i = PK*(n/PK); i <= n; i++) if (i % P) rem = rem*(i%PK)%PK;
    return F(n/P, P, PK) * rou % PK * rem % PK;
}
```
**代码解读**：  
- `rou`是循环节乘积（比如`mod 9`时，`1×2×4×5×7×8`）。  
- `fast_pow(rou, n/PK, PK)`计算有多少个完整循环节（比如`n=22`时，`22/9=2`个循环节）。  
- `rem`是剩余部分的乘积（比如`22%9=4`，计算`19×20×22`）。  
- 递归调用`F(n/P, P, PK)`处理`n/P`的阶乘（比如`22/P=7`，继续分离`7!`中的`P`因子）。  
**学习笔记**：递归是处理“拆分阶乘”的关键——把大问题拆成小问题，直到`n=0`。


### 题解二：Great_Influence（核心片段赏析）
**亮点**：用`fac`函数简洁实现不含质因子的阶乘计算。  
**核心代码片段**：
```cpp
ll fac(ll n, ll pi, ll pk) {
    if (!n) return 1;
    ll res = 1;
    for (ll i = 2; i <= pk; ++i) if (i % pi) res = res * i % pk;
    res = power(res, n / pk, pk);
    for (ll i = 2; i <= n % pk; ++i) if (i % pi) res = res * i % pk;
    return res * fac(n / pi, pi, pk) % pk;
}
```
**代码解读**：  
- 第一部分计算循环节乘积（`i<=pk`且`i%pi!=0`）。  
- `power`计算循环节的幂次（`n/pk`个循环）。  
- 第二部分计算剩余部分（`n%pk`）。  
- 递归调用`fac(n/pi, pi, pk)`处理`n/pi`的阶乘。  
**学习笔记**：简洁的代码往往更易读——把循环节和剩余部分的计算合并成两步。


### 题解三：maxiaomeng（核心片段赏析）
**亮点**：用`init`函数清晰分解模数，结构模块化。  
**核心代码片段**：
```cpp
void init() {
    int t = mod;
    for (int i = 2; i*i <= t; i++) {
        if (t%i == 0) {
            ++c;
            p[c] = i;
            pq[c] = 1;
            while (t%i == 0) { t /= i; pq[c] *= i; }
        }
    }
    if (t != 1) { ++c; p[c] = pq[c] = t; }
}
```
**代码解读**：  
- `init`函数分解模数`mod`为质数幂（`p`数组存质数，`pq`数组存质数幂）。  
- 遍历`2`到`sqrt(t)`，找到所有质因子，计算对应的质数幂（比如`12`分解为`p[1]=2, pq[1]=4`；`p[2]=3, pq[2]=3`）。  
**学习笔记**：模块化设计让代码更易维护——把模数分解单独放在`init`函数里，主函数只需调用即可。


## 5. 算法可视化：像素动画演示方案

### 动画主题：像素风“模数拼图工厂”

### 设计思路
采用8位FC游戏风格，用像素块、简单动画和音效模拟扩展卢卡斯的执行流程，让抽象的数学过程变得直观有趣。

### 动画帧步骤
1. **场景初始化**：  
   - 屏幕显示像素化工厂车间，顶部有“模数输入框”（输入`n,m,p`），中间是“拆分机”，右侧是“拼图区”。  
   - 8位风格背景音乐（比如《超级马里奥》的轻快旋律）响起。

2. **模数分解（拆分机动画）**：  
   - 输入的模数`p`（比如`12`）变成一个大像素块，被“拆分机”切成两个小方块（`4`和`3`），每个小方块显示质数幂（`2²`和`3¹`）。  
   - 拆分时播放“咔嚓”音效，小方块滑向右侧的“计算工位”。

3. **单质数幂计算（计算工位动画）**：  
   - 每个小方块内播放“阶乘分离游戏”：  
     - 阶乘数流（`1,2,3,…,n`）从左到右流动，经过“筛子”（过滤掉`p_i`的倍数，比如`3`的倍数被筛掉）。  
     - 剩下的数进入“循环节传送带”（循环播放`1×2×4×5×7×8`的动画，每个数用像素块表示，碰撞时播放“叮”的音效）。  
     - 传送带末端弹出“逆元计算器”（显示`inv(...)`），计算完成后小方块显示余数（比如`C(5,3) mod 4=1`）。

4. **CRT合并（拼图区动画）**：  
   - 所有小方块的余数被“拼图机器人”拾起，拼成一个大像素块（最终答案）。  
   - 拼图完成时播放“胜利”音效（比如《塞尔达传说》的解谜音效），屏幕显示“答案：X”。

5. **交互设计**：  
   - **控制按钮**：“单步”（看每一步拆分/计算）、“自动”（快速播放全程）、“重置”（重新输入）。  
   - **速度滑块**：调节动画速度（从“慢”到“快”）。  
   - **提示框**：鼠标 hover 像素块时，显示当前步骤的文字解释（比如“循环节：1×2×4×5×7×8”）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
扩展卢卡斯的核心是“**拆分问题+合并结果**”，这种思路适用于：  
- 合数模数的组合数取模（比如`C(1e18, 1e9) mod 1e6`）。  
- 需要分离质因子的阶乘计算（比如求`n!`中`p`的因子个数）。  
- 用CRT合并多个同余方程（比如`x ≡ a1 mod m1`，`x ≡ a2 mod m2`）。

### 洛谷推荐练习
1. **P4720 【模板】扩展卢卡斯定理/exLucas**：本题本身，巩固基础。  
2. **P1865 数页码**：需要计算阶乘中的质因子个数，类似扩展卢卡斯的`G`函数。  
3. **P2150 [NOI2015] 寿司晚宴**：组合数取模的应用，需要扩展卢卡斯处理合数模数。  
4. **P3807 【模板】卢卡斯定理**：对比普通卢卡斯和扩展卢卡斯的区别，加深理解。


## 7. 学习心得与经验分享

### 参考经验（来自Fading）
> “我在写代码时，最初没注意`i%PK`的处理，导致余数计算错误。后来通过手动模拟`n=22`的例子，才发现要把`i`取模`PK`再乘，否则会溢出。”  
**点评**：手动模拟是排错的好方法——当代码出错时，找一个小例子（比如`n=22, P=3, PK=9`），一步步走代码逻辑，就能发现问题。

### 参考经验（来自maxiaomeng）
> “我一开始没开`__int128`，导致阶乘计算溢出。后来查资料发现，`1e18`的阶乘会超过`long long`的范围，必须用`__int128`来暂存中间结果。”  
**点评**：处理大数时，要注意数据类型的范围——`long long`最多存`9e18`，而`1e18`的阶乘远大于这个数，必须用更大的类型（比如`__int128`）。


## 结语
扩展卢卡斯定理是组合数取模的“终极武器”，它的核心是“拆分+合并”——把复杂的合数模数拆成简单的质数幂，分别解决后再合并。通过今天的学习，相信你已经掌握了它的思路和代码实现！

记住：编程的本质是“解决问题”，而扩展卢卡斯就是一个“拆分问题的艺术”——把大问题拆成小问题，一个个解决，最后拼起来就是答案。下次遇到合数模数的组合数问题，不妨试试扩展卢卡斯吧！💪

--- 
本次分析就到这里，希望能帮助你理解扩展卢卡斯定理。继续加油，你一定能成为编程小能手！🚀

---
处理用时：121.12秒
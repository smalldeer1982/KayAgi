# 题目信息

# [SNCPC2019] Paper-cutting

## 题目描述

剪纸是中国最古老、最受欢迎的民间艺术之一。它在地理上可以分为南方风格和北方风格。以江苏扬州、浙江乐清作品为代表的南方风格，设计巧妙美观，雕刻精美，造型有趣。北方风格以河北蔚县、丰宁为主体，以陕北作品为代表，造型夸张、气势恢宏、刻画生动、图案多样。

基本的裁剪由单个图像组成，还有对称的设计，通常是通过在成比例的折痕上折叠，然后裁成一个形状，当展开时，就形成了对称的设计。中国剪纸通常是对称的。剪纸通常是 $2$、 $4$ 、 $24$ 等偶数系列。

你会得到一张大小为 $n \times m$ 的纸， 它被划分为 $n \times m$ 个大小为 $1 \times 1$ 的块在。这张纸可以按以下方式折叠：

- 可以在两列之间选择一条垂直线，也可以在两行之间选择一条水平线。这条线把纸分成两面。

- 你用这条线作为对称轴，把小的一面折到大的一面上。如果纸的两面大小相等，从两边对折。

你想用这张纸做一幅剪纸杰作。首先，使用上述方法将纸张折叠几次（包括零次）。然后你用剪刀剪纸。每次剪切时，都可以从折叠的纸上剪切出一个连接的部分（即使从外面无法接触到该部分并将其扔掉。请注意，如果两个 $ 1\times 1$ 的块共享一条边，则它们是连接的。

纸张的最终外观是一个包含 $0$ 和 $1$ 的大小为 $n \times m$ 的矩阵，你想知道需要使用剪刀时的最小裁剪次数。

## 说明/提示

对于样例一,你可以通过这种方式将唯一的 $0$ 剪出:
$$\begin{array}{ccc|cc} 1&1&0&0&1\\1&1&0&0&1\end{array} \to \begin{array}{ccc} 1&1&0\\ \hline 1&1&0\end{array} \to \begin{array}{ccc} 1&1&0\end{array}$$

对于样例二，你可以按照以下方式折叠并裁剪出 $0$ 的 $4$ 个连通块：
$$\begin{array}{cccc|ccc} 1&0&0&1&1&0&0\\0&1&1&0&0&1&1\\0&1&0&1&1&0&1\\0&0&1&0&0&1&0\\1&0&0&0&0&0&0\end{array} \to \begin{array}{cccc} 1&0&0&1\\0&1&1&0\\0&1&0&1\\0&0&1&0\\1&0&0&0\end{array}$$

## 样例 #1

### 输入

```
3
2 5
11001
11001
5 7
1001100
0110011
0101101
0010010
1000000
3 2
11
11
11```

### 输出

```
1
4
0```

# AI分析结果

# 💡 Kay的C++算法解析：[SNCPC2019] Paper-cutting 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串（Manacher算法） + 贪心策略 + BFS搜索


🗣️ **初步分析**：  
解决这道题，关键要理解「折叠」的本质——**找对称的“回文区域”**，然后用「能折就折」的贪心策略最小化连通块，最后用BFS统计结果。  

### 算法比喻 & 核心思想  
- **Manacher算法**：像找“镜子里的对称图案”——每个列（或行）间隙是一面“镜子”，我们要看镜子两边的像素块（0/1）能对称延伸多远（回文半径）。比如，字符串`11001`的中间间隙（第2和第3列之间）是镜子，两边`11`和`00`对称，回文半径是2。  
- **贪心策略**：“能折就折”——折叠不会让连通块变多（比如，对称的两个0连通块折后会合并成一个），所以尽量折叠是最优的。  
- **BFS搜索**：像“给连通的0块染色”——找到一个0，就把它周围所有连通的0都标记，统计有多少个这样的“色块”。  


### 核心流程 & 可视化设计思路  
1. **Step 1：找回文半径**：对每行（竖折叠）、每列（横折叠）跑Manacher，记录每个间隙的最大回文半径（比如，行`i`的间隙`j`能对称延伸`p`步）。  
2. **Step 2：贪心折叠**：从边界向中心收缩，比如竖折叠时，左边界`xl`不断右移（折左边），右边界`yr`不断左移（折右边），直到无法再折。  
3. **Step 3：统计连通块**：用BFS遍历最终保留的矩阵，数0的连通块。  


### 像素动画设计小剧透  
我们会做一个**8位像素风的“折纸游戏”**：  
- 初始矩阵是像素块（1=亮色，0=暗色），对称轴用闪烁的黄色线标记。  
- 折叠时，小的一边会“滑”到大的一边（比如左半部分折到右半部分），合并的像素块会闪烁一下。  
- 统计连通块时，每个连通块会被染成不同的像素色（比如红色、蓝色），BFS的每一步会有“叮”的音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面，筛选了3份优质题解，帮你快速入门~
</eval_intro>


### 题解一：jjsnam（赞6）  
* **点评**：这份题解把问题拆成“找对称→折叠→统计”三个部分，逻辑像“剥洋葱”一样清晰！  
  - 思路上，明确指出“折叠的本质是回文”，并用Manacher解决每行/列的对称问题，贪心策略的证明（折叠不增连通块）很直观。  
  - 代码规范：变量名`xl/xr`（横边界）、`yl/yr`（竖边界）含义明确，Manacher函数和BFS函数封装得很干净。  
  - 亮点：用四个指针（xl, xr, yl, yr）动态收缩边界，避免了复杂的矩阵修改，效率很高！  


### 题解二：ysl_wf（赞6）  
* **点评**：这是“保姆级”题解，连Manacher的细节（比如加`#`处理偶回文）都讲透了！  
  - 思路上，用`min_p`数组记录每列的最小回文半径（确保整列都对称），解决了“矩阵回文”的问题。  
  - 代码细节：比如`i%2==0`确保折叠的是间隙（不是像素块），`dfs`时把0改成1避免重复统计，这些都是容易踩的坑！  


### 题解三：TDoG_W（赞3）  
* **点评**：这份题解回答了很多“为什么”，比如“折叠顺序影响结果吗？”“横竖折叠冲突吗？”，帮你理解问题本质！  
  - 思路上，用“二维Manacher”的思想（每行/列分别处理），证明了“折叠顺序无关”“横竖不冲突”，让贪心策略更站得住脚。  
  - 亮点：用`vector`动态调整矩阵大小，避免了数组越界的问题，适合处理大输入！  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，你可能会遇到3个“卡壳点”，我帮你拆解清楚~
</difficulty_intro>


### 1. 难点1：如何把“折叠”转化为代码能处理的问题？  
- **分析**：折叠需要“对称”，也就是每行（竖折叠）或每列（横折叠）是**偶回文串**（对称轴在间隙）。比如，行`11001`的偶回文串是`11|00`（间隙在第2列后），回文半径是2。  
- **策略**：用Manacher算法找每个间隙的回文半径——对每行（或列）加`#`（比如`1#1#0#0#1`），这样偶回文会被转化为奇数长度的回文，方便Manacher处理。  
- 💡 **学习笔记**：折叠=对称=回文，Manacher是处理回文的“瑞士军刀”！  


### 2. 难点2：为什么“能折就折”是最优的？  
- **分析**：折叠后，连通块只会减少或不变：  
  - 如果0连通块跨过对称轴，折后保留一半，数目不变；  
  - 如果0连通块在对称轴一侧，折后会被合并到另一侧，数目减半。  
- **策略**：贪心收缩边界——比如竖折叠时，左边界`xl`尽量右移（折左边），右边界`yr`尽量左移（折右边），直到无法再折。  
- 💡 **学习笔记**：贪心策略的关键是“证明选择当前最优不会导致全局更差”！  


### 3. 难点3：如何高效计算矩阵的回文半径？  
- **分析**：矩阵的回文需要“每行都对称”（竖折叠）或“每列都对称”（横折叠），所以要取每行（或列）回文半径的**最小值**（确保整列/行都对称）。  
- **策略**：对每行跑Manacher，记录该行每个间隙的回文半径；然后对每个间隙，取所有行的回文半径的最小值，得到整列的回文半径。  
- 💡 **学习笔记**：二维问题可以拆解为“一维问题的叠加”，取最小值确保全局满足条件！  


### ✨ 解题技巧总结  
- **技巧1：问题拆解**：把“折叠”拆成“找对称→收缩边界→统计连通块”，复杂问题变简单。  
- **技巧2：Manacher的二维应用**：每行/列分别处理，取最小值得到矩阵的回文半径。  
- **技巧3：边界收缩**：用四个指针动态调整保留的矩阵范围，避免修改原矩阵，效率更高。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，整合了优质题解的思路，帮你把握整体框架~
</code_intro_overall>


### 本题通用核心C++实现参考  
* **说明**：综合jjsnam、ysl_wf的思路，实现了Manacher找对称、贪心收缩边界、BFS统计连通块。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
using namespace std;

typedef pair<int, int> PII;
const int dx[] = {1, 0, -1, 0};
const int dy[] = {0, 1, 0, -1};

// Manacher算法：处理字符串s，得到每个位置的回文半径p
void manacher(const string& s, vector<int>& p) {
    int n = s.size();
    p.assign(n * 2 + 2, 0);
    string t = "#";
    for (char c : s) { t += c; t += "#"; }
    int mid = 0, R = 0;
    for (int i = 0; i < t.size(); ++i) {
        int j = 2 * mid - i;
        p[i] = (i < R) ? min(p[j], R - i) : 0;
        while (i - p[i] >= 0 && i + p[i] < t.size() && t[i - p[i]] == t[i + p[i]]) p[i]++;
        if (i + p[i] > R) { mid = i; R = i + p[i]; }
    }
}

// BFS统计连通块：从(ux, uy)出发，标记vis
void bfs(int ux, int uy, int xl, int xr, int yl, int yr, vector<vector<bool>>& vis, const vector<string>& s) {
    queue<PII> q;
    q.push({ux, uy});
    vis[ux][uy] = true;
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= xl && nx <= xr && ny >= yl && ny <= yr && !vis[nx][ny] && s[nx][ny] == '0') {
                vis[nx][ny] = true;
                q.push({nx, ny});
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T; cin >> T;
    while (T--) {
        int n, m; cin >> n >> m;
        vector<string> s(n);
        for (int i = 0; i < n; ++i) cin >> s[i];
        
        // 1. 计算行（竖折叠）的回文半径：rowp[i][j]是行i的间隙j的回文半径
        vector<vector<int>> rowp(n, vector<int>(m));
        for (int i = 0; i < n; ++i) {
            vector<int> p;
            manacher(s[i], p);
            for (int j = 0; j < m; ++j) {
                int pos = 2 * j + 1; // 间隙j对应t中的位置2j+1（因为t是#分隔的）
                rowp[i][j] = p[pos] / 2; // 偶回文的半径是p[pos]/2
            }
        }
        
        // 2. 计算列（横折叠）的回文半径：colp[i][j]是列i的间隙j的回文半径
        vector<vector<int>> colp(m, vector<int>(n));
        vector<string> t(m);
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) t[i] += s[j][i];
        }
        for (int i = 0; i < m; ++i) {
            vector<int> p;
            manacher(t[i], p);
            for (int j = 0; j < n; ++j) {
                int pos = 2 * j + 1;
                colp[i][j] = p[pos] / 2;
            }
        }
        
        // 3. 贪心收缩边界：xl/xr（横边界）、yl/yr（竖边界）
        int xl = 0, xr = n - 1, yl = 0, yr = m - 1;
        // 处理横左边界（折上边）
        for (int i = xl; i * 2 < xl + xr; ++i) {
            int min_p = 1e9;
            for (int j = 0; j < m; ++j) min_p = min(min_p, colp[j][i]);
            if (i - min_p + 1 > xl) continue;
            xl = i + 1;
        }
        // 处理横右边界（折下边）
        for (int i = xr; i * 2 >= xl + xr - 1; --i) {
            int min_p = 1e9;
            for (int j = 0; j < m; ++j) min_p = min(min_p, colp[j][i]);
            if (i + min_p < xr) continue;
            xr = i;
        }
        // 处理竖左边界（折左边）
        for (int i = yl; i * 2 < yl + yr; ++i) {
            int min_p = 1e9;
            for (int j = 0; j < n; ++j) min_p = min(min_p, rowp[j][i]);
            if (i - min_p + 1 > yl) continue;
            yl = i + 1;
        }
        // 处理竖右边界（折右边）
        for (int i = yr; i * 2 >= yl + yr - 1; --i) {
            int min_p = 1e9;
            for (int j = 0; j < n; ++j) min_p = min(min_p, rowp[j][i]);
            if (i + min_p < yr) continue;
            yr = i;
        }
        
        // 4. BFS统计连通块
        vector<vector<bool>> vis(n, vector<bool>(m, false));
        int ans = 0;
        for (int i = xl; i <= xr; ++i) {
            for (int j = yl; j <= yr; ++j) {
                if (s[i][j] == '0' && !vis[i][j]) {
                    ans++;
                    bfs(i, j, xl, xr, yl, yr, vis, s);
                }
            }
        }
        cout << ans << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **Manacher函数**：把原字符串加`#`，处理偶回文问题，返回每个位置的回文半径。  
  2. **BFS函数**：从起点出发，标记所有连通的0，避免重复统计。  
  3. **主函数**：  
     - 读取输入，转置矩阵（处理列的回文）；  
     - 用Manacher计算行和列的回文半径；  
     - 贪心收缩四个边界（xl, xr, yl, yr）；  
     - BFS统计最终矩阵的0连通块数目。  


### 题解一（jjsnam）核心片段赏析  
* **亮点**：用四个指针动态收缩边界，避免修改原矩阵。  
* **核心代码片段**：  
```cpp
// 处理竖左边界（折左边）
for (int i = yl; i * 2 < yl + yr; ++i) {
    int min_p = INF;
    for (int j = 0; j < n; ++j) {
        min_p = min(min_p, rowp[j][i]);
    }
    if (i - min_p + 1 > yl) continue;
    yl = i + 1;
}
```
* **代码解读**：  
  - `i`是当前考虑的间隙（竖折叠的对称轴），`i*2 < yl+yr`确保`i`在左半部分（小的一边）。  
  - `min_p`取所有行的回文半径的最小值——只有所有行都对称，才能折叠。  
  - 如果`i - min_p +1 <= yl`（对称轴左边的区域都对称），就把左边界`yl`右移到`i+1`（折叠左边）。  
* 💡 **学习笔记**：取最小值是二维回文的关键，确保整列/行都对称！  


### 题解二（ysl_wf）核心片段赏析  
* **亮点**：用`min_p`数组记录每列的最小回文半径，处理矩阵回文。  
* **核心代码片段**：  
```cpp
void manacher(string s, int min_p[]) {
    // ... 标准Manacher实现 ...
    for(int i = 0; i <= 2*len; i++){
        min_p[i] = min(min_p[i], p[i]);
    }
}
```
* **代码解读**：  
  - 对每行跑Manacher，把该行的回文半径`p[i]`更新到`min_p`数组（取最小值）。  
  - 这样`min_p[i]`就是**所有行**在位置`i`的最小回文半径，确保整列都对称。  
* 💡 **学习笔记**：数组的“累积最小值”是处理二维问题的常用技巧！  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了一个**8位像素风的“折纸小游戏”**，让你直观看到算法的每一步！
</visualization_intro>


### 动画演示主题  
**像素探险家的“折纸挑战”**：探险家需要折叠一张像素纸，找到最少的0连通块，才能通关。  


### 核心演示内容  
1. **场景初始化**（FC风格）：  
   - 屏幕左侧是像素矩阵（1=亮蓝色，0=暗灰色），右侧是控制面板（开始/暂停、单步、重置按钮，速度滑块）。  
   - 背景音乐是8位风格的《小星星》，轻松愉快。  

2. **Manacher找对称**：  
   - 每行的间隙用黄色点标记，回文半径用绿色线段延伸（比如间隙`j`的回文半径是2，就画两条绿色线到左右各2列）。  
   - 当所有行的回文半径都满足时，间隙会闪烁红色（表示可以折叠）。  

3. **贪心折叠**：  
   - 点击“折叠左边”，左半部分的像素块会“滑”到右半部分（动画：左半部分逐渐透明，右半部分对应的位置闪烁）。  
   - 折叠完成后，边界线（xl/yl）会变成红色，标记当前保留的区域。  

4. **BFS统计连通块**：  
   - 每个连通块会被染成不同的颜色（红色、蓝色、黄色），BFS的每一步会有“叮”的音效。  
   - 统计完成后，屏幕会显示“通关！连通块数目：X”，并播放胜利音效（《超级马里奥》的通关音）。  


### 交互设计  
- **单步执行**：点击“下一步”，动画走一步（比如找一个回文间隙→折叠→统计一个连通块）。  
- **自动播放**：滑动速度滑块调整速度（1x~5x），算法自动执行。  
- **重置**：恢复初始矩阵，重新开始。  


### 为什么这样设计？  
- **像素风格**：唤起复古游戏的回忆，降低学习压力。  
- **音效与动画**：用“滑入”“闪烁”“叮”的音效强化关键操作，帮助记忆。  
- **游戏化**：“通关”的设定让你像玩游戏一样学习，更有成就感！  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的思路，你可以尝试这些相似问题，巩固技巧~
</similar_problems_intro>


### 通用思路迁移  
- **Manacher的应用**：任何需要找对称结构的问题（比如最长回文子串、镜像字符串）。  
- **贪心策略**：任何“选择当前最优不会导致全局更差”的问题（比如硬币问题、活动选择）。  
- **BFS统计连通块**：任何需要找连通区域的问题（比如迷宫问题、岛屿问题）。  


### 洛谷练习推荐  
1. **洛谷 P3805** - [【模板】Manacher算法](https://www.luogu.com.cn/problem/P3805)  
   * 🗣️ **推荐理由**：Manacher的模板题，帮你熟练掌握回文半径的计算。  
2. **洛谷 P1596** - [【USACO10OCT】Lake Counting S](https://www.luogu.com.cn/problem/P1596)  
   * 🗣️ **推荐理由**：BFS统计连通块的经典题，和本题的统计部分完全一致。  
3. **洛谷 P1217** - [回文质数 Prime Palindromes](https://www.luogu.com.cn/problem/P1217)  
   * 🗣️ **推荐理由**：结合回文和质数的问题，锻炼Manacher的应用能力。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“踩坑经验”，帮你少走弯路~
</insights_intro>

> **参考经验（来自jjsnam）**：“我一开始没注意到折叠的是间隙（不是像素块），导致Manacher处理错了位置，后来加了`#`才解决。”  
> **点评**：折叠的对称轴是“列之间的间隙”，所以Manacher要处理**偶回文**（加`#`转化为奇回文）。这个细节很容易错，一定要记住！  

> **参考经验（来自ysl_wf）**：“memset清空大数组会TLE，后来改成`memset(min_p, 0x3f, sizeof(int)*(2*m+1))`才过。”  
> **点评**：大数组的memset要指定大小，避免不必要的计算。比如`2*m+1`是Manacher处理后的字符串长度，不要用整个数组的大小！  


## 结语  
这道题的核心是“把折叠转化为回文”，用Manacher找对称，贪心策略优化，最后BFS统计。希望这份指南能帮你理解每一步的逻辑，下次遇到类似的问题，你也能轻松解决！  

编程的乐趣在于“把复杂问题拆解成简单步骤”，继续加油吧！💪

---
处理用时：129.14秒
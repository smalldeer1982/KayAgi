# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

::cute-table{tuack}

| 测试点编号   | $n \leq$  | 特殊性质           |
| :----------: | :-------: | :----------------: |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | ^ |
| $5 \sim 6$   | $10$      | 无                   |
| $7 \sim 8$   | $20$      | ^ |
| $9 \sim 10$  | $30$      | ^ |
| $11 \sim 12$ | $50$      | ^ |
| $13 \sim 14$ | $100$     | ^ |
| $15$         | $200$     | ^ |
| $16$         | $300$     | ^ |
| $17$         | $500$     | ^ |
| $18$         | $1\,000$  | ^ |
| $19$         | $2\,000$  | ^ |
| $20$         | $30\,000$ | ^ |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果


### 题目分析
本题要求计算字符串所有子串中能够拆分成AABB形式的拆分方式总数。核心思路是通过枚举A的长度，利用关键点计算AA串的出现位置，进而统计以每个位置开头和结尾的AA串数量，最后通过乘法原理求出答案。

### 算法思路
1. **问题转化**：
   - 设`f[i]`为以位置`i`结尾的AA串个数。
   - 设`g[i]`为以位置`i`开头的AA串个数。
   - 答案即为所有`f[i] * g[i+1]`的和。

2. **关键点枚举**：
   - 枚举A的长度`len`（1到n/2）。
   - 在字符串上每隔`len`设置关键点（位置为`len, 2*len, ...`）。
   - 对于相邻关键点`i`和`j = i + len`：
     - 计算`lcp = min(LCP(i, j), len)`（原串后缀的最长公共前缀）。
     - 计算`lcs = min(LCS(i-1, j-1), len-1)`（反串后缀的最长公共前缀，对应原串前缀的最长公共后缀）。
     - 若`lcp + lcs >= len`，则存在`t = lcp + lcs - len + 1`个AA串。

3. **差分更新**：
   - 起始位置区间：`[i - lcs, i - lcs + t - 1]` → 更新`g`数组（差分）。
   - 结束位置区间：`[j + lcp - t, j + lcp - 1]` → 更新`f`数组（差分）。

4. **后缀数组优化**：
   - 构建原串和反串的后缀数组（SA）。
   - 使用ST表实现O(1)的LCP查询。

5. **结果计算**：
   - 对`f`和`g`数组求前缀和。
   - 计算答案：`ans = ∑(f[i] * g[i+1])`（i从1到n-1）。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAXN = 30000;
const int LOGN = 15;

struct SuffixArray {
    char s[MAXN + 5];
    int n, sa[MAXN + 5], rk[MAXN + 5], ht[MAXN + 5];
    int st[MAXN + 5][LOGN + 1], logn[MAXN + 5];

    void init() {
        memset(sa, 0, sizeof(sa));
        memset(rk, 0, sizeof(rk));
        memset(ht, 0, sizeof(ht));
        memset(st, 0, sizeof(st));
    }

    void buildSA() {
        int m = 128;
        int *x = new int[MAXN + 5], *y = new int[MAXN + 5];
        int *c = new int[max(MAXN, m) + 5];
        memset(c, 0, sizeof(int) * (m + 1));
        for (int i = 1; i <= n; i++) c[x[i] = s[i]]++;
        for (int i = 1; i <= m; i++) c[i] += c[i - 1];
        for (int i = n; i >= 1; i--) sa[c[x[i]]--] = i;

        for (int k = 1; k <= n; k <<= 1) {
            int p = 0;
            for (int i = n - k + 1; i <= n; i++) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > k) y[++p] = sa[i] - k;

            memset(c, 0, sizeof(int) * (m + 1));
            for (int i = 1; i <= n; i++) c[x[y[i]]]++;
            for (int i = 1; i <= m; i++) c[i] += c[i - 1];
            for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];

            swap(x, y);
            p = 1; x[sa[1]] = 1;
            for (int i = 2; i <= n; i++) {
                x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? p : ++p;
            }
            if (p == n) break;
            m = p;
        }
        delete[] c;
        delete[] x;
        delete[] y;
    }

    void buildHeight() {
        for (int i = 1; i <= n; i++) rk[sa[i]] = i;
        int k = 0;
        for (int i = 1; i <= n; i++) {
            if (rk[i] == 1) continue;
            if (k) k--;
            int j = sa[rk[i] - 1];
            while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
            ht[rk[i]] = k;
        }
    }

    void buildST() {
        logn[0] = -1;
        for (int i = 1; i <= n; i++) {
            logn[i] = logn[i / 2] + 1;
            st[i][0] = ht[i];
        }
        for (int j = 1; j <= LOGN; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
            }
        }
    }

    int queryLCP(int i, int j) {
        if (i == j) return n - i + 1;
        i = rk[i]; j = rk[j];
        if (i > j) swap(i, j);
        i++;
        int k = logn[j - i + 1];
        return min(st[i][k], st[j - (1 << k) + 1][k]);
    }
};

SuffixArray SA1, SA2; // SA1: original, SA2: reversed
int n;
ll f[MAXN + 5], g[MAXN + 5]; // f: end with i, g: start with i

void solve() {
    static char str[MAXN + 5];
    scanf("%s", str + 1);
    n = strlen(str + 1);

    // Initialize SA for original string
    SA1.init();
    SA1.n = n;
    for (int i = 1; i <= n; i++) SA1.s[i] = str[i];
    SA1.buildSA();
    SA1.buildHeight();
    SA1.buildST();

    // Initialize SA for reversed string
    SA2.init();
    SA2.n = n;
    for (int i = 1; i <= n; i++) SA2.s[i] = str[n - i + 1];
    SA2.buildSA();
    SA2.buildHeight();
    SA2.buildST();

    // Initialize f and g (as difference arrays)
    memset(f, 0, sizeof(f));
    memset(g, 0, sizeof(g));

    // Enumerate length len
    for (int len = 1; len <= n / 2; len++) {
        for (int i = len, j = i + len; j <= n; i += len, j += len) {
            // LCP of suffixes starting at i and j
            int lcp = SA1.queryLCP(i, j);
            lcp = min(lcp, len);
            
            // LCS of prefixes ending at i-1 and j-1 (using reversed string)
            int lcs = 0;
            if (i > 1) {
                // Positions in reversed string: n - (i-1) + 1 and n - (j-1) + 1
                lcs = SA2.queryLCP(n - (i - 1) + 1, n - (j - 1) + 1);
                lcs = min(lcs, len - 1);
            }

            if (lcp + lcs >= len) {
                int t = lcp + lcs - len + 1;
                // Update g (start positions): [i - lcs, i - lcs + t - 1]
                int startL = i - lcs;
                int startR = startL + t;
                if (startL >= 1) {
                    g[startL]++;
                    if (startR <= n) g[startR]--;
                }
                // Update f (end positions): [j + lcp - t, j + lcp - 1]
                int endL = j + lcp - t;
                int endR = j + lcp;
                if (endL <= n) {
                    f[endL]++;
                    if (endR <= n) f[endR]--;
                }
            }
        }
    }

    // Convert difference arrays to prefix sums
    for (int i = 1; i <= n; i++) {
        f[i] += f[i - 1];
        g[i] += g[i - 1];
    }

    // Calculate answer
    ll ans = 0;
    for (int i = 1; i < n; i++) {
        ans += f[i] * g[i + 1];
    }
    printf("%lld\n", ans);
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        solve();
    }
    return 0;
}
```

### 算法分析
- **时间复杂度**：构建后缀数组O(n log n)，枚举长度和关键点O(n log n)（调和级数），总时间复杂度O(n log n)。
- **空间复杂度**：O(n)，用于存储后缀数组和差分数组。
- **优势**：利用后缀数组优化LCP查询，通过关键点枚举和差分数组高效统计AA串位置。

### 总结
本题通过巧妙的关键点枚举和差分数组，结合后缀数组的快速LCP查询，高效解决了AABB拆分计数问题。算法设计充分利用了字符串的周期性质和调和级数的特性，达到了较好的时间和空间效率。

---
处理用时：284.68秒
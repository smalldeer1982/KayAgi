# 题目信息

# [NOI2010] 航空管制

## 题目描述

世博期间，上海的航空客运量大大超过了平时，随之而来的航空管制也频频发生。最近，小 X 就因为航空管制，连续两次在机场被延误超过了两小时。对此，小 X 表示很不满意。

在这次来烟台的路上，小 X 不幸又一次碰上了航空管制。于是小 X 开始思考关于航空管制的问题。

假设目前被延误航班共有 $n$ 个，编号为 $1$ 至 $n$。机场只有一条起飞跑道，所有的航班需按某个顺序依次起飞（称这个顺序为起飞序列）。定义一个航班的起飞序号为该航班在起飞序列中的位置，即是第几个起飞的航班。

起飞序列还存在两类限制条件：

- 第一类（最晚起飞时间限制）：编号为 $i$ 的航班起飞序号不得超过 $k_i$。

- 第二类（相对起飞顺序限制）：存在一些相对起飞顺序限制 $(a,b)$，表示航班 $a$ 的起飞时间必须早于航班 $b$，即航班 $a$ 的起飞序号必须小于航班 $b$ 的起飞序号。

小 X 思考的第一个问题是，若给定以上两类限制条件，是否可以计算出一个可行的起飞序列。第二个问题则是，在考虑两类限制条件的情况下，如何求出每个航班在所有可行的起飞序列中的最小起飞序号。


## 说明/提示

### 样例解释

在样例 $1$ 中：

起飞序列 $3\ 5\ 1\ 4\ 2$ 满足了所有的限制条件，所有满足条件的起飞序列有：

$$
\begin{aligned}
3\ 4\ 5\ 1\ 2\\
3\ 5\ 1\ 2\ 4\\
3\ 5\ 1\ 4\ 2\\
3\ 5\ 4\ 1\ 2\\
5\ 3\ 1\ 2\ 4\\
5\ 3\ 1\ 4\ 2\\
5\ 3\ 4\ 1\ 2
\end{aligned}
$$

由于存在 $(5,1)$ 和 $(3,1)$ 两个限制，航班 $1$ 只能安排在航班 $5$ 和 $3$ 之后，故最早起飞时间为 $3$，其他航班类似。

在样例 $2$ 中：

虽然航班 $4,5$ 没有相对起飞顺序限制，但是由于航班 $1,2,3$ 都必须安排在前 $3$ 个起飞，所以 $4,5$ 最早只能安排在第 $4$ 个起飞。

### 数据范围

对于 $30\%$ 数据：$n\leq 10$。

对于 $60\%$ 数据：$n\leq 500$。

对于 $100\%$ 数据：$n\leq 2\times 10^3,m\leq 10^4$。

感谢 @FlierKing 提供 spj


## 样例 #1

### 输入

```
5 5
4 5 2 5 4
1 2
3 2
5 1
3 4
3 1
```

### 输出

```
3 5 1 4 2
3 4 1 2 1
```

## 样例 #2

### 输入

```
5 0
3 3 3 5 5
```

### 输出

```
3 2 1 5 4
1 1 1 4 4
```

# AI分析结果


### 💡 Kay的C++算法解析：[NOI2010] 航空管制 深入学习指南 💡

**引言**  
今天我们一起分析NOI2010的"航空管制"问题。这道题结合了拓扑排序和贪心算法的思想，需要我们在两类约束条件下求解航班调度方案。本指南将带你理解核心算法逻辑，掌握解题技巧，并通过像素动画直观感受算法执行过程。

---

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`拓扑排序` + `贪心策略`  

🗣️ **初步分析**：  
> 解决航空管制问题的核心在于**反图拓扑排序**和**时间窗贪心策略**。想象机场塔台调度员从后往前安排航班（时光倒流），每次选择最晚起飞限制（k值）最大的航班——这就像在游戏《俄罗斯方块》中，我们总是优先放置最紧迫的方块避免堆积。  

- **核心思路**：  
  1. 建立航班依赖关系的反图（b→a 表示a必须在b前起飞）  
  2. 用优先队列维护当前可起飞的航班  
  3. 从后往前（时间n→1）分配位置，优先安排k值大的航班  

- **可视化设计**：  
  在像素动画中将航班显示为不同颜色的飞机图标，k值用颜色深浅表示（红色=紧迫，绿色=宽松）。当航班入队时播放"嘀"声，起飞时显示位置分配动画，关键决策步骤突出显示当前比较的k值。

---

### 2. 精选优质题解参考
**题解一：SBofGaySchool（思路清晰度⭐⭐⭐⭐⭐）**  
* **点评**：  
  采用DFS更新k值的思路极具启发性——通过递归计算依赖关系修正最晚起飞时间。代码中`num`数组按k值分组存储航班的做法巧妙避免了排序开销。变量命名规范（如`rhead`表反图指针），边界处理严谨，特别是反图DFS标记祖先的`rdfs`函数为第二问提供优雅解决方案。

**题解二：Sol1（实践价值⭐⭐⭐⭐）**  
* **点评**：  
  "时光倒流"的贪心策略直观易理解，双队列设计（普通队列+优先队列）有效降低常数。代码中`que2`数组的滑动窗口式管理节省了容器操作开销，但变量命名可读性可提升（如`tmp`建议改为`temp_degree`）。

**题解三：asuldb（算法优化⭐⭐⭐⭐）**  
* **点评**：  
  小根堆实现的反向拓扑排序独树一帜，`work()`函数中延迟选择目标航班的逻辑简洁高效。代码结构模块化程度高，特别欣赏`greater<pii>`自定义比较器的用法，完美满足"尽量晚安排"的需求。

---

### 3. 核心难点辨析与解题策略
<difficulty_intro>  
解决本问题的三大关键难点及突破策略：
</difficulty_intro>

1. **依赖约束与时间窗的冲突处理**  
   * **分析**：当航班的依赖链（如a→b→c）与k值限制冲突时，需动态修正k值。参考SBofGaySchool的DFS方案：`k[a] = min(k[a], k[b]-1)`  
   * 💡 **学习笔记**：依赖关系中前驱节点的k值必须小于后继节点

2. **反图拓扑的贪心选择**  
   * **分析**：正确选择当前起飞航班是核心。Sol1的队列策略证明：优先安排`k≥当前时间`的航班可保证合法性，而大根堆维护其他航班实现高效调度  
   * 💡 **学习笔记**：时光倒流+双队列=优雅处理时间窗约束

3. **第二问的延迟决策机制**  
   * **分析**：求单航班最早起飞时间需避免"抢跑"。asuldb方案的精髓在于：在拓扑排序中暂时跳过目标航班，直到无其他选择时记录位置  
   * 💡 **学习笔记**：延迟决策是求解"最小时刻"问题的通用范式

### ✨ 解题技巧总结
<summary_best_practices>  
从优质题解提炼的黄金法则：
</summary_best_practices>
- **反图转化**：将"a早于b"转化为反图中"b依赖a"，适配从后往前安排
- **双队列加速**：普通队列存k≥当前时间的航班，优先队列存其他航班
- **DFS预修正**：通过DFS沿依赖链传播k值约束，避免运行时冲突
- **位运算优化**：gyh20题解中bitset加速可达性计算，适合大规模数据

---

### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <iostream>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 2005;
vector<int> graph[MAXN], rev_graph[MAXN];
int k[MAXN], deg[MAXN], n, m;

// 反图拓扑排序（第一问）
vector<int> solve() {
    vector<int> ans(n+1);
    priority_queue<pair<int, int>> pq; // <k值, 航班号>
    
    for (int i = 1; i <= n; i++) 
        if (!deg[i]) pq.push({k[i], i});
    
    for (int t = n; t >= 1; t--) {
        int u = pq.top().second; pq.pop();
        ans[t] = u; // 分配时刻t
        
        for (int v : graph[u]) {
            if (--deg[v] == 0) 
                pq.push({k[v], v});
        }
    }
    return ans;
}

// 求航班x的最早起飞时间（第二问）
int get_early_time(int x) {
    vector<int> temp_deg(deg, deg+n+1);
    priority_queue<pair<int, int>> pq;
    
    for (int i = 1; i <= n; i++)
        if (!temp_deg[i] && i != x)
            pq.push({k[i], i});
    
    for (int t = n; t >= 1; t--) {
        if (pq.empty()) return t; // 必须安排x
        
        int u = pq.top().second; pq.pop();
        for (int v : graph[u]) {
            if (--temp_deg[v] == 0 && v != x) 
                pq.push({k[v], v});
        }
    }
    return 0;
}
```

**题解一亮点代码：k值DFS修正**  
```cpp
void dfs(int cur) {
    vis[cur] = true;
    for (int next : rev_graph[cur]) {
        if (!vis[next]) dfs(next);
        k[cur] = min(k[cur], k[next] - 1); // 关键递推
    }
}
```

**题解二亮点：双队列调度**  
```cpp
while (!priority_q.empty() && priority_q.top().first >= current_time) {
    normal_q.push(priority_q.top().second);
    priority_q.pop();
}
if (!normal_q.empty()) {
    take_off(normal_q.front());
} // 优先安排满足k≥t的航班
```

---

### 5. 算法可视化：像素动画演示  
**主题**：航空塔台调度模拟（复古像素风）  
**核心演示流程**：  
1. **初始化场景**：  
   - 8-bit像素风格控制塔，右侧时间轴(n→1)  
   - 航班显示为彩色飞机图标，颜色深浅=紧急度（红=紧急）

2. **拓扑排序过程**：  
   ```mermaid
   graph LR
   A[入度0航班入队] --> B{队列非空?}
   B -->|是| C[弹出k值最大航班]
   C --> D[分配当前时刻t]
   D --> E[更新后继节点入度]
   E --> F[新入度0航班入队]
   F --> B
   ```

3. **关键动画效果**：  
   - 航班入队时：从顶部降落并带"叮"声效  
   - 分配位置时：飞机滑行到时间轴指定位置  
   - 冲突提示：当k值<当前时间时，飞机闪烁红光  
   - 第二问演示：目标航班显示金色边框，被跳过时播放特殊音效

4. **交互控制**：  
   - 步进/暂停/速度滑块  
   - 模式切换：第一问全局视角/第二问单航班追踪  
   - "AI演示"按钮：自动完成调度（贪吃蛇式推进）

---

### 6. 拓展练习与相似问题思考
**通用技巧迁移**：  
拓扑排序+贪心策略适用于所有带时间窗的调度问题，如：  
1. 课程安排（前置课程+最晚修读时间）  
2. 工厂流水线调度（工序依赖+交货期限）  
3. 游戏任务系统（任务链+截止时间）

**推荐练习**：  
1. **P3243 [HNOI2015]菜肴制作**  
   🗣️ 巩固反图拓扑排序的经典应用  
2. **P1983 车站分级**  
   🗣️ 练习拓扑排序中隐含关系的建模  
3. **P2419 [USACO08JAN]Cow Contest**  
   🗣️ 理解拓扑排序在关系传递中的应用

---

### 7. 学习心得与经验分享
> **来自SBofGaySchool的调试经验**：  
> *"在DFS更新k值时忘记设置vis数组导致无限递归，通过打印调用栈深度发现循环依赖"*  
>   
> **Kay的总结**：  
> 1. 拓扑排序前务必检查环（虽题目保证DAG）  
> 2. 第二问复制入度数组时用`memcpy`比循环高效  
> 3. 优先队列自定义比较器时注意方向（大根堆/小根堆）

---

**结语**  
通过本次分析，我们掌握了拓扑排序与贪心策略的协同应用。记住：将复杂约束转化为图形结构是算法设计的核心能力。下次遇到调度问题时，不妨尝试"时光倒流"的思考方式！🚀

---
处理用时：239.80秒
# 题目信息

# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# AI分析结果


### 💡 Kay的C++算法解析：植物大战僵尸 深入学习指南 💡

<introduction>
今天我们来分析“植物大战僵尸”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`网络流 - 最大权闭合子图` 

🗣️ **初步分析**：
> 解决这道题的关键在于理解**依赖关系建模**。想象植物之间形成一张保护网：想吃掉某个植物，必须先吃掉所有保护它的植物（就像解锁游戏关卡需要先完成前置任务）。最大权闭合子图算法正是处理这种依赖关系的利器——它帮助我们选出收益最高的植物集合，同时满足所有保护条件。

- **题解思路**：将植物视为节点，保护关系视为有向边（被保护植物→保护植物）。通过拓扑排序移除环结构（无敌植物群），剩余节点构建网络流图：正权植物连源点，负权植物连汇点，保护关系连无限容量边。最终答案 = 所有正权值之和 - 最小割值。
- **核心难点**：环结构处理（拓扑排序）和依赖关系反向建图（被保护植物指向保护植物）。在可视化中，需高亮环检测过程及网络流中关键边的方向。
- **像素动画设计**：采用8位像素风格，分三阶段演示：(1) 拓扑排序：绿色节点入队，红色环节点标记 (2) 网络流建图：蓝色正权点连接源点，黄色负权点连接汇点，灰色无限边流动 (3) 最小割计算：割边闪烁红光，被选中的植物变为绿色。伴随“入队音效”、“环警告音”和“割边音效”。

---

## 2. 精选优质题解参考

<eval_intro>
根据思路清晰度、代码规范性和算法效率，精选以下3篇优质题解（均≥4⭐）：

**题解一：longlongzhu123 (105赞)**
* **点评**： 
  - 思路极清晰：从最大权闭合子图概念引入到题目建模层层递进，用“保护网”比喻直观解释依赖关系
  - 代码规范：POINT宏封装坐标转换，vis数组明确标记有效节点，变量名self-explanatory（如`sum`统计正权值）
  - 算法亮点：拓扑排序与网络流分离处理，逻辑隔离；反向建图精确反映依赖关系
  - 实践价值：完整处理边界（如`j<m`的横向保护），可直接用于竞赛

**题解二：Freddie (20赞)**
* **点评**：
  - 亮点在问题转化：将植物保护关系类比“关卡解锁”，用转置图解释最大权闭合子图
  - 代码特色：DFS实现Dinic算法，拓扑排序与网络流共用邻接表结构
  - 优化点：用`vector`动态存储保护关系，避免固定数组空间浪费

**题解三：BJpers2 (12赞)**
* **点评**：
  - 独特优势：用“我是僵尸”游戏机制类比解题策略，拓扑排序比作“逐步解锁”
  - 代码亮点：独立`addTP`函数处理拓扑边，网络流建图前清空邻接表的模块化设计
  - 调试技巧：注释掉调试输出语句但保留打印能力，方便定位问题

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大难点，结合优质题解策略如下：

1.  **环结构处理**  
    * **分析**：互相保护的植物形成环（如A保护B且B保护A），导致无法被吃掉。需先用拓扑排序移除所有环节点及受其保护的节点。优质解法均用入度数组`in[]`和队列实现，未入队节点即环相关节点。
    * 💡 **学习笔记**：拓扑排序是处理依赖环的通用武器，类似课程先修关系检查。

2.  **依赖关系反向建图**  
    * **分析**：网络流建图时，被保护植物（依赖方）需指向保护植物（被依赖方）。这与直觉相反！因为最大权闭合子图要求：若选子节点，必须选父节点。题解中常见`addEdge(v, u, INF)`实现。
    * 💡 **学习笔记**：“依赖关系反向建图”是最大权闭合子图的灵魂操作。

3.  **权值分离处理**  
    * **分析**：正负权值需分别连接源点/汇点。易错点在于权值计算——仅统计拓扑后有效的正权值之和，且负权值建图时取绝对值。
    * 💡 **学习笔记**：正权值贡献收益，负权值代表代价，网络流中需区别对待。

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧A 拓扑去环**：用入度队列识别环，标记无效节点（`vis[]`数组）
- **技巧B 反向依赖**：被保护植物→保护植物建无限边，反映“必须满足”条件
- **技巧C 权值分流**：正权连源点（容量=权值），负权连汇点（容量=绝对值）
- **技巧D 调试验证**：小规模数据模拟（如2x2网格）验证环处理正确性
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下通用实现融合多篇题解精华，完整处理拓扑去环和网络流计算：

```cpp
#include <bits/stdc++.h>
#define POINT(x,y) ((x)*m+(y)) // 坐标转索引
const int MAXN = 700, INF = 0x3f3f3f3f;

struct Edge { int to, cap, rev; };
std::vector<Edge> G[MAXN];
int level[MAXN], iter[MAXN], score[MAXN];
bool vis[MAXN]; // 拓扑有效标记
std::vector<int> protect[MAXN]; // 保护关系
int inDegree[MAXN]; // 拓扑入度

// 网络流加边
void addEdge(int from, int to, int cap) {
    G[from].push_back({to, cap, (int)G[to].size()});
    G[to].push_back({from, 0, (int)G[from].size()-1});
}

// 拓扑排序标记有效节点
void topologySort(int n, int m) {
    std::queue<int> q;
    for (int i = 0; i < n*m; ++i)
        if (!inDegree[i]) { q.push(i); vis[i] = true; }
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : protect[u]) {
            if (!vis[v] && --inDegree[v] == 0) {
                vis[v] = true;
                q.push(v);
            }
        }
    }
}

// Dinic算法
int maxFlow(int s, int t) {
    /* 标准Dinic实现，包含BFS分层和DFS增广 */
}

int main() {
    int n, m, s, t, sum = 0;
    std::cin >> n >> m;
    s = n * m; t = s + 1; // 源/汇点

    // 读入数据并构建保护图
    for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {
        int idx = POINT(i, j);
        std::cin >> score[idx];
        int cnt; std::cin >> cnt;
        while (cnt--) {
            int x, y; std::cin >> x >> y;
            int target = POINT(x, y);
            protect[idx].push_back(target);
            inDegree[target]++; // 被保护点入度增加
        }
        // 右侧保护左侧
        if (j > 0) {
            int left = POINT(i, j-1);
            protect[idx].push_back(left);
            inDegree[left]++;
        }
    }

    topologySort(n, m); // 标记有效节点

    // 构建网络流图
    for (int i = 0; i < n*m; ++i) {
        if (!vis[i]) continue; // 跳过无效节点
        if (score[i] >= 0) {
            addEdge(s, i, score[i]);
            sum += score[i]; // 累计正权值
        } else {
            addEdge(i, t, -score[i]);
        }
        // 处理保护关系（反向建图！）
        for (int v : protect[i]) {
            if (vis[v]) addEdge(v, i, INF); // 注意方向！
        }
    }

    int minCut = maxFlow(s, t);
    std::cout << std::max(0, sum - minCut) << "\n";
}
```
* **代码解读概要**：
  1. **坐标转换**：`POINT`宏将二维坐标转一维索引
  2. **拓扑排序**：用`inDegree`数组和队列标记有效节点（`vis[]`）
  3. **网络流建图**：正权连源点，负权连汇点，保护关系反向建无限边
  4. **Dinic算法**：标准实现求最小割（省略细节）
  5. **结果计算**：`正权和 - 最小割`，注意负结果取0

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
设计名为“僵尸破阵”的像素动画，以8-bit风格演示算法核心步骤：

### 场景设计
- **网格地图**：20x30像素网格，每格代表植物（绿色：正权，红色：负权）
- **控制面板**：右下角含开始/暂停、单步执行、速度滑块
- **数据结构展示区**：右侧动态显示拓扑队列和网络流图

### 关键动画帧
1. **拓扑排序阶段**（音效：8-bit脚步声）
   - 入度0的植物闪烁绿光入队
   - 环内植物变骷髅头💀标记，伴随“警告音”
   - 受环保护植物渐隐消失

2. **网络流建图阶段**（音效：连接音效）
   - 源点（蓝色水塔）/汇点（红色岩浆）出现在地图两侧
   - 正权植物伸出蓝线连接源点，负权植物伸出红线连接汇点
   - 保护关系显示为金色链条（被保护植物→保护植物）

3. **最小割计算阶段**（音效：刀割音效）
   - Dinic算法BFS分层：水流从源点蔓延，层级用颜色深度表示
   - DFS增广：增广路径闪烁白光，流量数值实时显示
   - 割边断裂时迸溅红色像素粒子

### 游戏化元素
- **关卡设计**：每个拓扑阶段作为小关卡，完成解锁“植物图鉴”
- **得分系统**：正确吃掉植物时显示能源增减（+10/-5）
- **AI演示模式**：自动展示最优路径，僵尸像素角色沿路径移动

### 技术实现
- Canvas绘制网格和动画
- 关键变量悬浮显示（如`sum=125`, `minCut=83`）
- 伪代码同步高亮：当前执行步骤对应代码行边框闪烁

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题解法后可挑战以下相似问题：

1. **洛谷P3410 拍照**  
   🗣️ *推荐理由*：最大权闭合子图模板题，理解模特雇佣中的依赖关系

2. **洛谷P2762 太空飞行计划**  
   🗣️ *推荐理由*：经典问题，将仪器依赖转化为闭合子图，练习输入输出处理

3. **洛谷P4177 订单**  
   🗣️ *推荐理由*：需要灵活应用拓扑排序和网络流，强化时序依赖建模能力

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验尤其宝贵：

> **参考经验 (BJpers2)**：  
> “最初未考虑环保护传播（仅移除环节点），导致WA。后增加BFS传播标记才AC——环的影响会扩散！”

> **点评**：  
> 调试时优先验证环处理逻辑，可构造小数据（如互相保护的2株植物+1株被它们保护的植物）逐步模拟。

---

<conclusion>
本次分析揭示了依赖关系建模的通用解法：**拓扑去环 + 最大权闭合子图**。记住关键口诀：“正权连源负连汇，依赖反向无限边”。继续在实践中深化网络流应用吧，少年！🚀  
</conclusion>
```

---
处理用时：176.97秒
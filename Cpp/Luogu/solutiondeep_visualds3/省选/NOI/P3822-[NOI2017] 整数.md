# 题目信息

# [NOI2017] 整数

## 题目背景

在人类智慧的山巅，有着一台字长为 $1\,048\,576$ 位（此数字与解题无关）的超级计算机，著名理论计算机科学家 P 博士正用它进行各种研究。不幸的是，这天台风切断了电力系统，超级计算机无法工作，而 P 博士明天就要交实验结果了，只好求助于学过 OI 的你...


## 题目描述

P 博士将他的计算任务抽象为对一个整数的操作。

具体来说，有一个整数 $x$，一开始为 $0$。

接下来有 $n$ 个操作，每个操作都是以下两种类型中的一种：

- `1 a b`：将 $x$ 加上整数 $a\cdot 2^b$，其中 $a$ 为一个整数，$b$ 为一个非负整数

- `2 k` ：询问 $x$ 在用二进制表示时，位权为 $2^k$ 的位的值（即这一位上的 $1$ 代表 $2^k$）

保证在任何时候，$x\geqslant 0$。

## 说明/提示

在所有测试点中，$1\leqslant t_1 \leqslant 3, 1 \leqslant t_2 \leqslant 4, 1 \leqslant t_3 \leqslant 2$。不同的 $t_1, t_2, t_3$ 对应的特殊限制如下：

- 对于 $t_1 = 1$ 的测试点，满足 $a = 1$；
- 对于 $t_1 = 2$ 的测试点，满足 $|a| = 1$；
- 对于 $t_1 = 3$ 的测试点，满足 $|a| \leqslant 10^9$；
- 对于 $t_2 = 1$ 的测试点，满足 $0 \leqslant b, k \leqslant 30$；
- 对于 $t_2 = 2$ 的测试点，满足 $0 \leqslant b, k \leqslant 100$；
- 对于 $t_2 = 3$ 的测试点，满足 $0 \leqslant b, k \leqslant n$；
- 对于 $t_2 = 4$ 的测试点，满足 $0 \leqslant b, k \leqslant 30n$；
- 对于 $t_3 = 1$ 的测试点，保证所有询问操作都在所有修改操作之后；
- 对于 $t_3 = 2$ 的测试点，不保证询问操作和修改操作的先后顺序。

本题共 25 个测试点，每个测试点 4 分。各个测试点的数据范围如下：

::cute-table{tuack}

| 测试点编号 | $n \le$ | $t_1$ | $t_2$ | $t_3$ |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $3$ | $1$ | $2$ |
| $2$ | $100$ | $3$ | $2$ | $2$ |
| $3$ | $2000$ | $3$ | $2$ | $2$ |
| $4$ | $4000$ | $1$ | $3$ | $2$ |
| $5$ | $6000$ | $3$ | $3$ | $1$ |
| $6$ | $8000$ | $2$ | $3$ | $2$ |
| $7$ | $9000$ | $3$ | $4$ | $2$ |
| $8$ | $10000$ | $3$ | $3$ | $2$ |
| $9$ | $30000$ | $3$ | $4$ | $2$ |
| $10$ | $50000$ | $3$ | $4$ | $1$ |
| $11$ | $60000$ | $3$ | $3$ | $2$ |
| $12$ | $65000$ | $2$ | $4$ | $2$ |
| $13$ | $70000$ | $3$ | $4$ | $2$ |
| $14$ | $200000$ | $3$ | $4$ | $2$ |
| $15$ | $300000$ | $2$ | $4$ | $2$ |
| $16$ | $400000$ | $3$ | $4$ | $2$ |
| $17$ | $500000$ | $3$ | $3$ | $2$ |
| $18$ | $600000$ | $3$ | $4$ | $2$ |
| $19$ | $700000$ | $3$ | $4$ | $2$ |
| $20$ | $800000$ | $1$ | $4$ | $2$ |
| $21$ | $900000$ | $2$ | $4$ | $2$ |
| $22$ | $930000$ | $3$ | $3$ | $2$ |
| $23$ | $960000$ | $3$ | $4$ | $1$ |
| $24$ | $990000$ | $3$ | $3$ | $2$ |
| $25$ | $1000000$ | $3$ | $4$ | $2$ |

## 样例 #1

### 输入

```
10 3 1 2
1 100 0
1 2333 0
1 -233 0
2 5
2 7
2 15
1 5 15
2 15
1 -1 12
2 15```

### 输出

```
0
1
0
1
0```

# AI分析结果


### 题目分析
题目要求维护一个大整数 \( x \)（初始为0），支持两种操作：
1. 给定整数 \( a \) 和非负整数 \( b \)，将 \( x \) 加上 \( a \cdot 2^b \)。
2. 给定非负整数 \( k \)，询问 \( x \) 的二进制表示中第 \( k \) 位的值。

操作次数 \( n \leq 10^6 \)，\( b \) 和 \( k \) 可能高达 \( 3 \times 10^7 \)。直接模拟高精度加减会超时，需要优化。

### 核心算法：压位与均摊分析
**算法思想**：
- **压位**：将连续32位（或60位）二进制压缩成一个 unsigned int，减少操作次数。
- **正负分离**：分别维护加法部分（inc）和减法部分（dec），避免退位连锁反应。
- **借位判断**：用 set 记录正负部分不等的位置，查询时通过前驱位置判断是否借位。
- **均摊复杂度**：每次加减操作均摊 \( O(\log n) \)，总复杂度 \( O(n \log n) \)。

**可视化设计**：
- 8位像素风格，网格表示压位块（每块32位）
- 蓝色块：正数部分（inc）；红色块：负数部分（dec）
- 高亮当前操作块，进位/退位时触发闪烁和音效
- 控制面板支持单步执行、调速、重置

### 关键代码实现
```cpp
#include <cstdio>
#include <algorithm>
#include <set>
using namespace std;
const int N = 1e6 + 10;
typedef unsigned int uit;

uit inc[N], dec[N];  // 正负部分
set<int> s;          // 记录不等位置

int main() {
    int n, t1, t2, t3;
    scanf("%d%d%d%d", &n, &t1, &t2, &t3);
    for (int i = 1, op, a, b; i <= n; i++) {
        scanf("%d", &op);
        if (op == 1) {
            scanf("%d%d", &a, &b);
            int p = b / 32, q = b % 32;  // 计算块位置
            if (a > 0) {
                uit st = (uit)a << q;    // 低位部分
                uit carry = (uit)a >> (31 - q); carry >>= 1;  // 高位进位
                uit old = inc[p];
                inc[p] += st;
                carry += (old > inc[p]);  // 溢出判断
                // 更新set
                if (inc[p] != dec[p]) s.insert(p);
                else if (s.count(p)) s.erase(p);
                p++;
                // 处理进位链
                while (carry) {
                    old = inc[p];
                    inc[p] += carry;
                    carry = (old > inc[p]);
                    if (inc[p] != dec[p]) s.insert(p);
                    else if (s.count(p)) s.erase(p);
                    p++;
                }
            } else { /* 负数处理类似 */ }
        } else {
            scanf("%d", &b);
            int p = b / 32, q = b % 32;
            int ans = ((inc[p] >> q) ^ (dec[p] >> q)) & 1;  // 当前位异或
            uit v1 = inc[p] % (1 << q), v2 = dec[p] % (1 << q);
            // 借位判断
            if (v1 < v2) printf("%d\n", ans ^ 1);
            else if (v1 > v2 || s.empty() || p <= *s.begin()) printf("%d\n", ans);
            else {
                auto it = s.lower_bound(p); --it;
                if (inc[*it] > dec[*it]) printf("%d\n", ans);
                else printf("%d\n", ans ^ 1);
            }
        }
    }
    return 0;
}
```

### 优化技巧
1. **压位**：32位压缩成 unsigned int，减少操作次数
2. **溢出判断**：利用 `old > inc[p]` 检测无符号整数溢出
3. **借位优化**：set 维护不等位置，查询复杂度 \( O(\log n) \)
4. **边界处理**：低位比较（`v1` 和 `v2`）处理部分借位

### 学习要点
- **压位原理**：理解二进制压缩如何减少操作次数
- **均摊分析**：证明进位操作总次数为 \( O(n) \)
- **数据结构应用**：set 维护关键位置加速查询
- **边界处理**：特别注意 \( b=0 \) 和整数溢出的情况

> **关键提示**：在竞赛中实现时，务必对 \( b=0 \)、正负零、最大位宽进行边界测试。

### 拓展练习
1. [洛谷 P1932] 大整数运算 - 练习压位技巧
2. [洛谷 P1226] 快速幂 - 理解二进制分解
3. [洛谷 P1080] 高精度贪心 - 综合应用

通过本题掌握的高精度优化技巧可扩展到其他大整数运算场景。

---
处理用时：144.65秒
# 题目信息

# [NOI2019] 弹跳

## 题目背景

原题时限 2s

内存 128MB

## 题目描述

跳蚤国有 $n$ 座城市，分别编号为 $1 - n$，$1$ 号城市为首都。所有城市分布在一个$w \times h$ 范围的网格上。每座城市都有一个整数坐标 $(x, y) (1 \leq x \leq w, 1 \leq y \leq h)$，不同城市的坐标不相同。

在跳蚤国中共有 $m$ 个弹跳装置，分别编号为 $1 - m$，其中 $i$ 号弹跳装置位于 $p_i$ 号城市，并具有参数 $t_i, L_i, R_i, D_i, U_i$。利用该弹跳装置，跳蚤可花费 $t_i (t_i > 0)$ 个单位时间，从 $p_i$ 号城市跳至坐标满足 $L_i \leq x \leq R_i, D_i \leq y \leq U_i (1 \leq L_i \leq R_i \leq w, 1 \leq D_i \leq U_i \leq h)$ 的任意一座城市。需要注意的是，一座城市中可能存在多个弹跳装置，也可能没有弹跳装置。

由于城市间距离较远，跳蚤们必须依靠弹跳装置出行。具体来说，一次出行将经过
若干座城市，依次经过的城市的编号可用序列 $a_0, a_1, \cdots , a_k$ 表示；在此次出行中，依次利用的弹跳装置的编号可用序列 $b_1, b_2, \cdots , b_k$ 表示。其中每座城市可在序列 $\{a_j\}$ 中出现任意次，每个弹跳装置也可在序列 $\{b_j\}$ 中出现任意次，且满足，对于每个 $j (1 \leq j \leq k)$，编号为 $b_j$ 的弹跳装置位于城市 $a_{j-1}$，且跳蚤能通过该弹跳装置跳至城市 $a_j$。我们称这是一次从城市 $a_0$ 到城市 $a_k$ 的出行，其进行了 $k$ 次弹跳，共花费 $\sum^k_{i=1} t_{b_{i}}$ 个单位时间。

现在跳蚤国王想知道，对于跳蚤国除首都（$1$ 号城市）外的每座城市，从首都出发，到达该城市最少需要花费的单位时间。跳蚤国王保证，对每座城市，均存在从首都到它的出行方案。


## 说明/提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 2

见附加文件中的 `jump/jump2.in` 与 `jump/jump2.ans`。

这组样例的数据范围为 $n = 10^4 , m = 2\times 10^4 , w = 10^4 , h = 1$。

#### 样例 3

见附加文件中的 `jump/jump3.in` 与 `jump/jump3.ans`。

这组样例的数据范围为 $n = 10^4 , m = 2\times 10^4 , w = 10^4 , h = 10^4$。

### 数据范围

对于所有测试点和样例满足：

$1 \leq n \leq 70000 , 1 \leq m \leq 150000 , 1 \leq w, h \leq n , 1 \leq t_i \leq 10000$。

每个测试点的具体限制见下表。

| 测试点编号 | $1\le n\le$ | $1\le m\le$ | 特殊限制 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim8$ | $100$ | $100$ | 无 |
| $9\sim13$ | $5\times 10^4$ | $10^5$ | 每个弹跳装置恰好可达一座城市，且 $L_i=R_i$，$D_i=U_i$ |
| $14\sim18$ | $5\times 10^4$ | $10^5$ | $h=1$ | 
| $19\sim22$ | $2.5\times 10^4$ | $5\times 10^4$ | 无 | 
| $23\sim25$ | $7\times 10^4$ | $1.5\times 10^5$ | 无 | 

## 样例 #1

### 输入

```
5 3 5 5
1 1
3 1
4 1
2 2
3 3
1 123 1 5 1 5
1 50 1 5 1 1
3 10 2 2 2 2```

### 输出

```
50
50
60
123
```

# AI分析结果


# 💡 Kay的C++算法解析：弹跳 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`KD树/树套树优化建图 + 最短路` (算法/技巧分类标签)

🗣️ **初步分析**：
> 解决"弹跳"这道题，关键在于**优化建图与高效松弛**。想象你在一个巨大的城市网格中探险，每个弹跳装置就像一张魔法卷轴，能瞬间将你传送到指定矩形区域内的任意城市，但需要消耗卷轴标注的时间。本题的挑战在于：如何避免为每个城市对显式建边（否则空间爆炸），而是**动态识别可达区域**进行高效松弛。

- **核心思路**：使用数据结构（KD树/树套树）维护未访问节点，每次取出距离最小的节点，并**在数据结构中查询其弹跳装置对应的矩形区域**，实现"按需松弛"，避免显式建图。
- **难点**：二维空间的高效范围查询与动态删除；确保每个节点只被松弛一次；避免空间复杂度过高。
- **算法流程**：初始化数据结构→Dijkstra循环→从数据结构取最小节点→遍历其弹跳装置→在数据结构中查询矩形区域→松弛节点→删除已访问节点。
- **可视化设计**：像素动画将展示**网格城市布局**，高亮当前处理节点（探险家位置），用颜色扩散表示松弛区域（魔法卷轴生效范围），动态删除已访问节点（城市消失效果）。复古游戏化元素包括：8-bit音效（卷轴使用/节点访问）、自动演示模式（AI探险家寻路）。

---

## 2. 精选优质题解参考

**题解一：Ireliaღ（KD树优化）**
* **点评**：
  思路清晰，分阶段阐述：先介绍KDTree建图思路（40分），再优化为"不显式建边+动态查询"（88分），最终替换SPFA为Dijkstra（AC）。代码规范性好，关键变量命名合理（`dis`/`vis`），KDTree递归查询逻辑严谨。亮点在于**利用Dijkstra贪心性质，将建图转化为实时查询**，极大节省空间。实践价值高，可直接用于竞赛，边界处理完整。

**题解二：hsfzLZH1（线段树套set）**
* **点评**：
  结构严谨，从暴力→一维线段树→二维树套树逐步优化。代码中线段树套set的精妙在于：外层线段树管理X轴，内层set按Y排序，实现**O(log n)矩形查询**。亮点是**删除访问节点避免重复松弛**，空间优化显著（O(n log n)）。代码模块化强（`ins`/`del`/`query`函数分离），特别适合学习数据结构嵌套技巧。

**题解三：lzqy_（分块+线段树）**
* **点评**：
  创新性地用**分块降低空间**，X轴分块后每块Y轴建线段树。亮点是"时间换空间"策略：整块区间修改，散块暴力查询，平衡复杂度。代码中`Add()`函数处理矩形松弛时，分层更新（散块+整块）逻辑清晰，分块参数`qn=500`经实测优化，适合内存紧张场景。

---

## 3. 核心难点辨析与解题策略

1. **难点1：二维空间的高效范围查询**
   * **分析**：传统邻接表无法存储O(nm)边。KD树/树套树将二维查询降至O(√n)或O(log²n)，在未访问节点中快速定位矩形区域。
   * 💡 **学习笔记**：空间换时间 → 时间换空间，根据约束灵活选择。

2. **难点2：动态维护未访问节点**
   * **分析**：Dijkstra要求节点只松弛一次。优质题解在数据结构中**即时删除已访问节点**（如set.erase），确保查询时跳过。
   * 💡 **学习笔记**：删除即标记，避免重复松弛。

3. **难点3：空间与时间的平衡**
   * **分析**：线段树套set空间O(n log n)，KD树O(n)，分块O(n√n)。需根据数据范围选择，如本题n=7e4时KD树更优。
   * 💡 **学习笔记**：估算复杂度，避免MLE。

### ✨ 解题技巧总结
- **技巧1：隐式建图**：不显式存边，用数据结构实时查询可达节点。
- **技巧2：维度分离**：树套树将二维问题拆为两次一维查询（X→Y）。
- **技巧3：懒删除**：优先队列中延迟删除，但数据结构中立即执行。

---

## 4. C++核心代码实现赏析

**通用核心实现参考**（基于KD树动态查询）：
```cpp
void Dijkstra(int s) {
    priority_queue<node> q;
    dis[s] = 0; q.push({s, 0});
    while (!q.empty()) {
        int u = q.top().id; q.pop();
        if (vis[u]) continue; 
        vis[u] = 1;
        for (auto &e : edges[u]) { // 遍历u的弹跳装置
            int t = e.t, L = e.l, R = e.r, D = e.d, U = e.u;
            KDTree_Query(root, L, R, D, U, dis[u] + t); // 在KD树中查询矩形
        }
    }
}
```
> **说明**：综合KD树题解，伪代码展示核心框架：优先队列管理距离，KD树按需查询矩形内节点并松弛。

---

**题解一（KD树）核心片段**：
```cpp
void query(KDNode *p, int L, int R, int D, int U, int val) {
    if (!p || p->maxx < L || p->minx > R || p->maxy < D || p->miny > U) return;
    if (p->minx >= L && p->maxx <= R && p->miny >= D && p->maxy <= U) {
        if (p->val > val) p->val = val; // 整块更新
        return;
    }
    if (p->x >= L && p->x <= R && p->y >= D && p->y <= U && !vis[p->id]) 
        relax(p->id, val); // 松弛当前点
    query(p->lson, L, R, D, U, val);
    query(p->rson, L, R, D, U, val);
}
```
> **亮点**：递归查询矩形，分"完全覆盖"和"部分覆盖"处理。  
> **学习笔记**：KD树剪枝（无交/包含）是关键优化点。

---

**题解二（线段树套set）核心片段**：
```cpp
void query(int o, int L, int R, int D, int U, int val) {
    auto it = treeY[o].lower_bound({D, -1});
    while (it != treeY[o].end() && it->y <= U) {
        int id = it->id;
        if (!vis[id]) relax(id, val); // 松弛
        treeY[o].erase(it++); // 立即删除
    }
}
```
> **亮点**：外层线段树定位X区间，内层set二分Y范围。  
> **学习笔记**：`set::erase`保证节点只被访问一次。

---

**题解三（分块）核心片段**：
```cpp
void Block::update(int L, int R, int D, int U, int val) {
    int bl = L / block_size, br = R / block_size;
    for (int i = bl + 1; i < br; i++) 
        segTree[i].range_update(D, U, val); // 整块更新
    update_partial(bl, L, R, D, U, val); // 散块暴力
    update_partial(br, L, R, D, U, val);
}
```
> **亮点**：分块处理散块与整块，平衡复杂度。  
> **学习笔记**：分块是线性空间的救星。

---

## 5. 算法可视化：像素动画演示

* **主题**："8-bit网格探险"：城市为像素方块，弹跳装置为魔法卷轴。

* **设计**：
  1. **初始化**：8-bit网格（FC风格），控制面板（开始/步进/速度条）。
  2. **Dijkstra循环**：
     - **取最小节点**：高亮当前城市（闪烁），播放"选定"音效。
     - **弹跳装置激活**：卷轴展开→覆盖矩形区域（颜色填充）→播放"卷轴使用"音效。
     - **矩形查询**：递归展示KD树/线段树节点，被完全覆盖的子树变绿色。
     - **松弛节点**：被更新的城市显示距离值，播放"更新"音效。
     - **删除节点**：已访问城市变为灰色。
  3. **结束**：路径生成时播放胜利音效，显示最终距离。

* **交互**：步进模式观察松弛过程；自动模式调速；支持重置。

---

## 6. 拓展练习与相似问题
* **技巧迁移**：
  - **二维偏序查询**：KD树解决范围统计问题（如P3810 三维偏序）。
  - **动态删除+最短路**：P5471 的同类型题目（如P2146 树链剖分优化）。
  - **分块应用**：P2801 教主的魔法（区间更新+查询）。

* **洛谷推荐**：
  1. **P1903 数颜色**：练习分块维护动态查询。
  2. **P2617 Dynamic Rankings**：树套树经典题。
  3. **P2146 软件包管理器**：树链剖分优化"路径更新"。

---

## 7. 学习心得与经验
> **Ireliaღ的调试经验**："最初用KDTree建图MLE，意识到边数太多，转为动态查询才AC。"  
> **Kay点评**：空间优化是本题关键，调试时先检查内存使用，再优化时间。

---

通过本指南，希望大家掌握二维最短路优化的核心思想：**数据结构加速动态查询，贪心策略避免无效计算**。下次遇到类似问题，记得举一反三哦！💪

---
处理用时：118.23秒
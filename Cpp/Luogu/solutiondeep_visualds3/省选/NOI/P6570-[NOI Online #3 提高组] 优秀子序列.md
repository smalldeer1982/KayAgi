# 题目信息

# [NOI Online #3 提高组] 优秀子序列

## 题目描述

给定一个长度为 $n$ 的非负整数序列 $A=\{a_1,a_2,\cdots,a_n\}$，对于 $A$ 的一个子序列 $B=\{a_{b_1},a_{b_2},\cdots,a_{b_m}\}$（$0\le m\le n$，$1\le b_1<b_2<\cdots<b_m\le n$，下同），称 $B$ 是 $A$ 的优秀子序列当且仅当，其任意两个不同元素的按位与结果均为 $0$，即：$\forall 1\le i<j\le m$，满足：$a_{b_i}~\mathrm{and}~a_{b_j}=0$，其中 $~\mathrm{and}~$   是按位与运算。

对于子序列 $B=\{a_{b_1},a_{b_2},\cdots,a_{b_m}\}$，我们定义其价值为 $\varphi(1+\sum_{i=1}^m a_{b_i})$，其中 $\varphi(x)$ 表示小等于 $x$ 的正整数中与 $x$ 互质的数的个数。

现在请你求出 $A$ 的所有优秀子序列的价值之和，答案对 $10^9+7$ 取模。

## 说明/提示

#### 样例 1 解释
符合条件的子序列有：$\emptyset$，$\{1\}$，$\{2\}$，$\{2\}$，$\{3\}$，$\{1,2\}$，$\{1,2\}$，它们价值依次为 $1$，$1$，$2$，$2$，$2$，$2$，$2$，总和为 $12$。

#### 数据规模与约定
- 对于 $10\%$ 的数据，保证 $a_i\le 1$。
- 对于 $30\%$ 的数据，保证 $a_i\le 1000$。
- 对于 $60\%$ 的数据，保证 $a_i\le 30000$。
- 另有 $10\%$ 的数据，保证 $n\le 20$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^6$，$0\le a_i\le 2\times 10^5$。

## 样例 #1

### 输入

```
4
1 2 2 3```

### 输出

```
12```

# AI分析结果


### 题目分析
题目要求计算所有优秀子序列的价值之和。优秀子序列需满足任意两个元素的按位与为0，即二进制位互不重叠。价值定义为子序列元素和加1的欧拉函数值。

#### 核心算法识别
本题属于**子集动态规划**问题，核心算法为枚举子集的动态规划（$O(3^n)$ 复杂度）。关键点在于：
1. **问题转化**：优秀子序列的元素二进制位互斥，等价于子序列的和等于所有元素的按位或。
2. **动态规划**：用 $dp[i]$ 表示和为 $i$ 的优秀子序列方案数，通过枚举子集转移。
3. **欧拉函数预处理**：使用线性筛预处理欧拉函数。
4. **0的特殊处理**：0不影响互斥性，最终方案数乘以 $2^{\text{0的个数}}$。

#### 精选题解点评
1. **泥土笨笨的题解（赞36）**
   - **亮点**：清晰解释二进制集合视角，枚举子集避免重复的技巧（$j \geq i \oplus j$），复杂度分析严谨。
   - **代码规范性**：变量名清晰（`dp`、`cnt`），线性筛欧拉函数独立封装。
   - **优化点**：桶计数替代排序，直接枚举有效状态。

2. **AutumnKite的题解（赞30）**
   - **亮点**：提出子集卷积和生成函数的高级解法（$O(n^2 2^n)$），虽然实际效率不如 $O(3^n)$。
   - **代码规范性**：分算法一/二实现，FMT（快速莫比乌斯变换）封装完整。
   - **实践价值**：提供更优理论复杂度，但实现复杂，适合进阶学习。

3. **热言热语的题解（赞17）**
   - **亮点**：简洁的问题转化（集合互斥分解），强调0的独立处理。
   - **代码简洁性**：直接循环枚举子集，无冗余操作。
   - **学习价值**：最简实现，适合初学者理解核心逻辑。

#### 核心难点与解题策略
1. **状态定义与转移**：
   - **难点**：避免子集枚举的重复计数。
   - **策略**：限制子集 $j \geq i \oplus j$，保证每个集合仅被统计一次。
   - **公式**：$dp[i] = \sum_{j \subseteq i \land j \geq i \oplus j} dp[i \oplus j] \times \text{cnt}[j]$。

2. **0的特殊处理**：
   - 独立计算 $2^{\text{cnt}[0]}$，乘入最终方案。

3. **复杂度优化**：
   - **桶计数**：直接记录数字出现频次，避免无效状态枚举。
   - **子集枚举技巧**：`for (int j = i; j; j = (j-1) & i)` 高效遍历子集。

4. **欧拉函数预处理**：
   - 线性筛法求 $\varphi(1) \sim \varphi(2^{18})$，支持 $O(1)$ 查询。

#### 可视化动画设计
**像素化BFS寻路演示**（用于理解子集DP转移）：
1. **场景设计**：
   - **8位网格**：每个格子代表二进制位（如红色格子表示1）。
   - **动态方块**：数字表示为移动方块，绿色为起点，黄色为目标和。
2. **动画流程**：
   - **步骤1**：初始化网格，展示空集合（全灰）。
   - **步骤2**：加入数字 $j$（方块从底部升起），播放“叮”音效。
   - **步骤3**：高亮转移路径（$i \oplus j \to i$），显示 $dp[i]$ 更新。
   - **步骤4**：完成状态播放胜利音效，显示 $\varphi(i+1)$ 值。
3. **交互控制**：
   - 速度滑块调节单步/自动播放。
   - 暂停/重置按钮辅助学习。

### C++核心代码实现
```cpp
#include <iostream>
#include <vector>
using namespace std;
const int mod = 1e9 + 7;
const int MAXN = 1 << 18;

vector<int> get_primes(int n) {
    vector<int> primes;
    vector<bool> is_prime(n + 1, true);
    vector<int> phi(n + 1);
    phi[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
            phi[i] = i - 1;
        }
        for (int p : primes) {
            if (i * p > n) break;
            is_prime[i * p] = false;
            if (i % p == 0) {
                phi[i * p] = phi[i] * p;
                break;
            } else {
                phi[i * p] = phi[i] * (p - 1);
            }
        }
    }
    return phi;
}

int main() {
    int n;
    cin >> n;
    vector<int> cnt(MAXN, 0);
    int max_val = 0;
    for (int i = 0; i < n; ++i) {
        int x;
        cin >> x;
        cnt[x]++;
        max_val = max(max_val, x);
    }

    int cnt0 = cnt[0];
    cnt[0] = 0;

    int m = 0;
    while ((1 << m) <= max_val) m++;
    int full = 1 << m;

    vector<int> phi = get_primes(full);
    vector<long long> dp(full, 0);
    dp[0] = 1;

    for (int i = 1; i < full; ++i) {
        for (int j = i; j; j = (j - 1) & i) {
            int comp = i ^ j;
            if (j < comp) break;
            dp[i] = (dp[i] + dp[comp] * cnt[j]) % mod;
        }
    }

    long long ans = 0;
    for (int i = 0; i < full; ++i) {
        ans = (ans + dp[i] * phi[i + 1]) % mod;
    }

    long long pow2 = 1;
    for (int i = 0; i < cnt0; ++i) {
        pow2 = (pow2 * 2) % mod;
    }
    ans = (ans * pow2) % mod;
    cout << ans << endl;
    return 0;
}
```

### 算法可视化方案
**复古像素风子集DP动画**：
1. **视觉设计**：
   - **8位网格**：16×16像素格子，不同颜色代表二进制位状态（红：1，灰：0）。
   - **动态元素**：数字方块（绿→黄渐变），转移路径高亮（蓝色光效）。
2. **音效系统**：
   - 关键操作：数字加入（"叮"），状态转移（"咔"），完成（胜利旋律）。
   - 背景：FC风格循环BGM。
3. **交互逻辑**：
   - **单步/自动**：空格键切换，方向键调速。
   - **状态显示**：实时更新 $dp[i]$ 和 $\varphi(i+1)$。
4. **教育价值**：
   - 直观展示子集分解过程，理解 $O(3^n)$ 状态转移。

### 拓展练习
1. **相似问题**：
   - **子集和问题**（LeetCode 416）：分割等和子集。
   - **位运算子集**（LeetCode 1178）：猜字谜游戏。
   - **互斥子序列**（CodeForces 1516D）：区间分解质因数互斥。
2. **洛谷推荐**：
   - **P4141 消失之物**（背包计数）：巩固动态规划思想。
   - **P6097 子集卷积**（模板题）：学习子集卷积优化。
   - **P5495 Dirichlet前缀和**：位运算与筛法结合。

### 学习心得
- **调试技巧**（泥土笨笨）：打印中间状态验证子集枚举。
- **位运算优化**（热言热语）：`j = (j-1) & i` 高效枚举子集。
- **数学整合**（dengyaotriangle）：欧拉函数与动态规划结合降低复杂度。

> 本次题解涵盖多种实现方法，核心在于理解子集动态规划的本质。建议从 $O(3^n)$ 基础解法入手，再逐步探索子集卷积等高级技巧。

---
处理用时：263.73秒
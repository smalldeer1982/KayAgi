# 题目信息

# [NOI2020] 美食家

## 题目描述

坐落在 Bzeroth 大陆上的精灵王国击退地灾军团的入侵后，经过十余年的休养生息，重新成为了一片欣欣向荣的乐土，吸引着八方游客。小 W 是一位游历过世界各地的著名美食家，现在也慕名来到了精灵王国。

精灵王国共有 $n$ 座城市，城市从 $1$ 到 $n$ 编号，其中城市 $i$ 的美食能为小 W 提供 $c_i$ 的愉悦值。精灵王国的城市通过 $m$ 条**单向道路**连接，道路从 $1$ 到 $m$ 编号，其中道路 $i$ 的起点为城市 $u_i$ ，终点为城市 $v_i$，沿它通行需要花费 $w_i$ 天。也就是说，若小 W 在第 $d$ 天从城市 $u_i$ 沿道路 $i$ 通行，那么他会在第 $d + w_i$ 天到达城市 $v_i$。

小 W 计划在精灵王国进行一场为期 $T$ 天的旅行，更具体地：他会在第 $0$ 天从城市 $1$ 出发，经过 $T$ 天的旅行，最终在**恰好第 $T$ 天**回到城市 $1$ 结束旅行。由于小 W 是一位美食家，每当他到达一座城市时（包括第 $0$ 天和第 $T$ 天的城市 $1$），他都会品尝该城市的美食并获得其所提供的愉悦值，若小 W 多次到达同一座城市，他将**获得多次愉悦值**。注意旅行途中小 W **不能在任何城市停留**，即当他到达一座城市且还未结束旅行时，他当天必须立即从该城市出发前往其他城市。

![](https://cdn.luogu.com.cn/upload/image_hosting/2svum9ge.png)

对于上图，小 W 一种为期 $11$ 天的可行旅游方案为 $1 \to 2 \to 1 \to 2 \to 3 \to 1$：
- 第 $0$ 天，小 W 从城市 $1$ 开始旅行，获得愉悦值 $1$ 并向城市 $2$ 出发。
- 第 $1$ 天，小 W 到达城市 $2$，获得愉悦值 $3$ 并向城市 $1$ 出发。
- 第 $4$ 天，小 W 到达城市 $1$，获得愉悦值 $1$ 并向城市 $2$ 出发。
- 第 $5$ 天，小 W 到达城市 $2$，获得愉悦值 $3$ 并向城市 $3$ 出发。
- 第 $7$ 天，小 W 到达城市 $3$，获得愉悦值 $4$ 并向城市 $1$ 出发。
- 第 $11$ 天，小 W 到达城市 $1$，获得愉悦值 $1$ 并结束旅行。
- 小 W 在该旅行中获得的愉悦值之和为 $13$。

此外，精灵王国会在**不同**的时间举办 $k$ 次美食节。具体来说，第 $i$ 次美食节将于第 $t_i$ 天在城市 $x_i$ 举办，若小 W 第 $t_i$ 天时恰好在城市 $x_i$，那么他在品尝城市 $x_i$ 的美食时会**额外得到** $y_i$ 的愉悦值。现在小 W 想请作为精灵王国接待使者的你帮他算出，他在旅行中能获得的愉悦值之和的**最大值**。

## 说明/提示

#### 样例 1 解释

该样例为题目描述中的例子，最优旅行方案见题目描述。

#### 样例 2 解释

最优方案为 $1 \to 3 \to 4 \to 2 \to 3 \to 4 \to 1$。
- 第 $0$ 天，小 W 从城市 $1$ 开始旅行，获得愉悦值 $3$ 并沿道路 $3$ 通行。
- 第 $2$ 天，小 W 到达城市 $3$，获得愉悦值 $2$ 并沿道路 $4$ 通行。
- 第 $5$ 天，小 W 到达城市 $4$，由于美食节获得愉悦值 $20 + 4$ 并沿道路 $7$ 通行。
- 第 $6$ 天，小 W 到达城市 $2$，获得愉悦值 $1$ 并沿道路 $5$ 通行。
- 第 $8$ 天，小 W 到达城市 $3$，获得愉悦值 $2$ 并沿道路 $4$ 通行。
- 第 $11$ 天，小 W 到达城市 $4$，获得愉悦值 $4$ 并沿道路 $8$ 通行。
- 第 $16$ 天，小 W 到达城市 $1$，获得愉悦值 $3$ 并结束旅行。
- 小 W 获得的愉悦值之和为 $39$。

#### 样例 3

见选手目录下的 delicacy/delicacy3.in 与 delicacy/delicacy3.ans。

该样例满足 $k=0$

---

### 测试点约束

对于所有测试点：

$1 \leq n \leq 50$，$n \leq m \leq 501$，$0 \leq k \leq 200$，$1 \leq t_i \leq T \leq 10^9$。

$1 \leq w_i \leq 5$，$1 \leq c_i \leq 52501$，$1 \leq u_i, v_i, x_i \leq n$，$1 \leq y_i \leq 10^9$。

每个测试点的具体限制见下表：

| 测试点编号 |  $n$ |  $m$ |  $T$ | 特殊限制 |
| :-: | :-:| :-: |:-:| :-:|
|  $1\sim 4$ |  $\le 5$ |  $\le 50$ |  $\le 5$ | 无 |
|  $5\sim 8$ |  $\le 50$ |  $\le 50$ |  $\le 52501$ | 无 |
|  $9\sim 10$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ | A | 
|  $11\sim 13$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ |  $k=0$ |
|  $14\sim 15$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ |  $k\le 10$ |
|  $16\sim 17$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ | 无 |
|  $18\sim 20$ |  $\le 50$ |  $\le 501$ |  $\le 10^9$ | 无 |

特殊限制 A：$n = m$ 且 $u_i = i,v_i = (i \bmod n) + 1$。

## 样例 #1

### 输入

```
3 4 11 0
1 3 4
1 2 1
2 1 3
2 3 2
3 1 4```

### 输出

```
13```

## 样例 #2

### 输入

```
4 8 16 3
3 1 2 4
1 2 1
1 3 1
1 3 2
3 4 3
2 3 2
3 2 1
4 2 1
4 1 5
3 3 5
1 2 5
5 4 20```

### 输出

```
39```

# AI分析结果


# 💡 Kay的C++算法解析：NOI2020 美食家 深入学习指南 💡

> 本文针对NOI2020题目"美食家"进行深度解析，提供多题解对比、核心算法可视化方案及学习建议。面向10-18岁C++学习者，通过像素动画和游戏化设计帮助理解复杂算法。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**动态规划 + 矩阵快速幂优化**（拆点技巧应用）

🗣️ **初步分析**：
> 解决"美食家"这道题，关键在于将大规模时间问题转化为**可控状态转移**。想象你在玩一个复古RPG游戏：每个城市是地图节点，道路是连接线，旅行天数是步数。核心思路是将**时间维度压缩**为状态矩阵，通过**矩阵乘法模拟状态转移**。

- **算法核心**：将城市拆分为5个时间状态（因边权≤5），构建转移矩阵。美食节作为"特殊事件"插入时间轴，分段处理转移过程。
- **难点突破**：直接处理T=10^9会超时，需用**矩阵快速幂优化**。预处理转移矩阵的2次幂序列，实现O(log T)复杂度跳跃。
- **可视化设计**：像素动画中将城市状态展示为5层网格（类似游戏中的"传送门"），矩阵乘法表现为光点沿路径跳跃，美食节触发时目标城市闪烁并显示"+y"特效。

## 2. 精选优质题解参考

### 题解一：duyi (LOJ3339)
* **点评**：
  - **思路创新性**：首创拆点+矩阵乘法完整框架，状态定义清晰（将点u拆为u1~u5）
  - **代码规范性**：变量命名规范（`id[u][w]`），边界处理严谨（`LL_INF`处理不可达状态）
  - **算法优化**：空间优化到位（滚动数组），预处理2次幂矩阵降低时间复杂度至O((5n)^2k log T)
  - **实践价值**：考场实战代码，可直接用于竞赛，完整包含输入输出重定向

```cpp
// 关键思想：拆点+状态矩阵
for(int i=1; i<=n; i++)
    for(int j=1; j<5; j++)
        id[i][j] = ++cnt;
for(边(u,v,w)) 
    G[id[u][w-1]][v] = c[v];
```

### 题解二：Lice
* **点评**：
  - **思路清晰度**：用"反图邻接矩阵"解释状态转移，类比超级马里奥传送机制
  - **复杂度优化**：明确分析二进制分解优化原理，复杂度公式推导完整
  - **代码亮点**：使用lambda表达式排序，矩阵乘法三重循环布局工整

### 题解三：s_r_f
* **点评**：
  - **代码简洁性**：最短实现（仅60行），结构紧凑
  - **特殊技巧**：`minf=0xcfcfcfcfcfcfcfcf`处理负无穷，避免溢出
  - **学习价值**：适合掌握基础后研究代码优化技巧

> 所有优质题解均采用**拆点+矩阵幂预处理+时间分段**的统一框架，区别在于状态编码和乘法实现细节

## 3. 核心难点辨析与解题策略

### 难点1：状态矩阵构造（如何把时间维度压缩？）
* **分析**：边权w∈[1,5]是突破口，将城市u拆分为u₀~u₄五个状态，其中uᵢ表示还需走i天才能完成移动。通过uᵢ→uᵢ₋₁的链式结构（权值0）和u_w₋₁→v₀的跨点转移（权值cᵥ）实现时间维度压缩。
* 💡 **学习笔记**：拆点本质是"时间维度空间化"，将O(T)问题转化为O(5n)状态转移

### 难点2：美食节时间分段处理
* **分析**：将T时间轴按美食节时间点切分，每段使用快速幂转移。预处理G²⁰~G²³⁰矩阵后，时间差Δt可分解为二进制位，用向量乘矩阵替代矩阵乘矩阵，复杂度从O(n³)降为O(n²)。
* 💡 **学习笔记**：分段处理是事件驱动型DP的核心，类似游戏中的关卡跳跃

### 难点3：矩阵乘法的重新定义
* **分析**：传统矩阵乘法不适用最值问题，需重定义为：$C_{ij} = \max_k(A_{ik} + B_{kj})$。该运算满足结合律，保持快速幂特性但需注意初始化（-∞代替0，0代替1）。
* 💡 **学习笔记**：广义矩阵乘法是DP优化的利器，适用所有具备"结合律+单调性"的运算

### ✨ 解题技巧总结
1. **问题转化技巧**：将边权转化为多层节点（类似电梯楼层设计）
2. **时间分治策略**：用事件点分割大规模时间轴，化整为零
3. **二进制拆分优化**：预处理2次幂矩阵是降低log T系数的关键
4. **状态压缩实践**：用一维向量替代二维矩阵存储当前状态
5. **边界处理技巧**：-∞初始化和加法防溢出策略

## 4. C++核心代码实现赏析

### 本题通用核心C++实现
```cpp
#include <bits/stdc++.h>
#define FOR(i,a,b) for(int i=(a);i<=(b);++i)
using namespace std;
typedef long long ll;
const int N=250;
const ll INF=4e18;

struct Matrix {
    ll m[N][N];
    Matrix(){ memset(m, 0xcf, sizeof m); } // 初始为-INF
    ll* operator[](int i) { return m[i]; }
};

Matrix mul(Matrix &A, Matrix &B, int n) {
    Matrix C;
    FOR(i,0,n-1) FOR(k,0,n-1) if(A[i][k] > -INF/2) // 防溢出优化
        FOR(j,0,n-1) if(B[k][j] > -INF/2)
            C[i][j] = max(C[i][j], A[i][k] + B[k][j]);
    return C;
}

int main() {
    // 读入数据
    int n, m, T, k; 
    cin >> n >> m >> T >> k;
    vector<ll> c(n);
    FOR(i,0,n-1) cin >> c[i];
    
    // 拆点：每个点5个状态
    int tot = 5*n;
    Matrix G;
    // 同一城市状态间转移
    FOR(u,0,n-1) FOR(j,0,3) 
        G[u*5+j][u*5+j+1] = 0;
    // 跨城市转移
    while(m--) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--;
        G[u*5 + w-1][v*5] = c[v]; // 关键转移
    }
    
    // 预处理2次幂矩阵
    vector<Matrix> powG = {G};
    FOR(i,1,30) powG.push_back(mul(powG[i-1], powG[i-1], tot));
    
    // 初始状态向量
    vector<ll> dp(tot, -INF);
    dp[0] = c[0]; // 起点状态
    
    // 处理美食节
    vector<tuple<int,int,ll>> events;
    while(k--) {
        int t, x; ll y;
        cin >> t >> x >> y;
        events.emplace_back(t, x-1, y);
    }
    sort(events.begin(), events.end());
    
    // 时间分段转移
    int last = 0;
    for(auto [t, x, y] : events) {
        int gap = t - last;
        // 二进制分解时间差
        FOR(i,0,30) if(gap >> i & 1) {
            vector<ll> new_dp(tot, -INF);
            FOR(j,0,tot-1) FOR(k,0,tot-1)
                if(dp[j] > -INF/2 && powG[i][j][k] > -INF/2)
                    new_dp[k] = max(new_dp[k], dp[j] + powG[i][j][k]);
            dp = new_dp;
        }
        if(dp[x*5] > -INF/2) dp[x*5] += y; // 处理美食节
        last = t;
    }
    
    // 最终时间段转移
    int gap = T - last;
    FOR(i,0,30) if(gap >> i & 1) {
        vector<ll> new_dp(tot, -INF);
        FOR(j,0,tot-1) FOR(k,0,tot-1)
            if(dp[j] > -INF/2 && powG[i][j][k] > -INF/2)
                new_dp[k] = max(new_dp[k], dp[j] + powG[i][j][k]);
        dp = new_dp;
    }
    
    cout << (dp[0] < 0 ? -1 : dp[0]) << endl;
}
```

### 代码解读概要
> 此代码综合优质题解思路，核心创新点：
> 1. **拆点状态编码**：`u*5+j` 表示城市u的第j个状态
> 2. **防溢出处理**：`> -INF/2` 避免极端值导致运算错误
> 3. **事件驱动分段**：将美食节作为时间分割点
> 4. **二进制分解优化**：`gap>>i&1` 实现快速时间跳跃

## 5. 算法可视化：像素动画演示

### 动画设计：复古RPG风格
**主题**：像素探险家在时间城堡中收集美食

**核心演示**：5层城市状态转移网 + 二进制时间跳跃

```plaintext
| 时间轴：[0]---------[美食节]---------[T] 
| 控制台：[暂停][单步>>][自动播放] 速度：■■■□□
| 当前状态：城市A(15) → 城市B(23) → 城市C(18)
```

**帧步骤设计**：
1. **地图初始化**：8-bit风格城市网格，每个城市垂直分为5个像素块（0~4层）
   - 城市1：█(红) █(橙) █(黄) █(绿) █(青)
   - 城市2：█(蓝) █(紫) █(粉) █(灰) █(白)

2. **状态转移演示**：
   ```plaintext
   第7天：城市A(3层) →[传送]→ 城市B(0层)
   + 播放"叮"音效
   + 显示获得c_B=15金币
   ```

3. **美食节事件**：
   ```plaintext
   [第10天] 城市C举办美食节！
   ██ 特效：城市C闪烁金光
   + 显示"+20金币"浮动文字
   + 播放"胜利"音效
   ```

4. **二进制跳跃演示**：
   ```plaintext
   时间差57天 = 32+16+8+1
   [>>32] 矩阵幂应用：光柱扫过网格
   [>>16] 状态向量更新：数字跳动
   ```

5. **结局判定**：
   - 成功：回到城市1时放烟花，显示总金币
   - 失败：显示"Game Over"像素艺术字

## 6. 拓展练习与相似问题

### 通用技巧迁移
矩阵快速幂优化DP适用于：
1. 固定转移规则的递推问题
2. 状态数有限的大规模转移
3. 带分段事件的线性系统

### 推荐练习
1. **洛谷 P6569**：[NOI Online #3 魔法值](https://www.luogu.com.cn/problem/P6569)
   - 同类矩阵快速幂应用，无拆点但需处理异或特性
2. **洛谷 P5024**：[保卫王国](https://www.luogu.com.cn/problem/P5024)
   - 动态DP入门，训练树形结构上的矩阵转移
3. **CodeForces 691D**：[Swaps in Permutation](https://codeforces.com/problemset/problem/691/D)
   - 置换群与矩阵快速幂结合应用

## 7. 学习心得与经验分享
> "考场中-1边界处理遗漏导致爆零，血的教训！"
> —— duyi 题解作者调试经历

**经验总结**：
1. 永远显式初始化边界值（特别是-∞）
2. 矩阵乘法前检查溢出风险
3. 时间分段时添加虚拟结束事件
4. 使用`vector<tuple>>`存储事件提高可读性

> 算法学习如同美食之旅，享受思考的乐趣才能品出真味！下次再见！🍜🚀

---
处理用时：182.90秒
# 题目信息

# [NOI2022] 众数

## 题目描述

**对于一个序列，定义其众数为序列中出现次数严格大于一半的数字。注意该定义与一般的定义有出入，在本题中请以题面中给出的定义为准。**

一开始给定 $n$ 个长度不一的正整数序列，编号为 $1 \sim n$，初始序列可以为空。这 $n$ 个序列被视为存在，其他编号对应的序列视为不存在。

有 $q$ 次操作，操作有以下类型:

- $1 \ x \ y$：在 $x$ 号序列末尾插入数字 $y$。保证 $x$ 号序列存在，且 $1 \le x, y \le n + q$。
- $2 \ x$：删除 $x$ 号序列末尾的数字，保证 $x$ 号序列存在、非空，且 $1 \le x \le n + q$。
- $3 \ m \ x_1 \ x_2 \ x_m$：将 $x_1, x_2, \ldots, x_m$ 号序列顺次拼接，得到一个新序列，并询问其众数。如果不存在满足上述条件的数，则返回 $-1$。数据保证对于任意 $1 \le i \le m$，$x_i$ 是一个仍然存在的序列，$1 \le x_i \le n + q$，且拼接得到的序列非空。**注意：不保证 $\boldsymbol{x_1, \ldots, x_m}$ 互不相同，询问中的合并操作不会对后续操作产生影响。**
- $4 \ x_1 \ x_2 \ x_3$：新建一个编号为 $x_3$ 的序列，其为 $x_1$ 号序列后顺次添加 $x_2$ 号序列中数字得到的结果，然后删除 $x_1, x_2$ 对应的序列。此时序列 $x_3$ 视为存在，而序列 $x_1, x_2$ 被视为不存在，在后续操作中也不会被再次使用。保证 $1 \le x_1, x_2, x_3 \le n + q$、$x_1 \ne x_2$、序列 $x_1, x_2$ 在操作前存在、且在操作前没有序列使用过编号 $x_3$。

## 说明/提示

**【样例解释 \#1】**

第一次询问查询序列 $1$ 的众数。由于序列包含两个 $1$，超过序列长度的一半，因此众数为 $1$。

第二次询问查询序列 $2$ 的众数。由于序列只包含 $3$，因此众数为 $3$。

第三次询问询问序列 $3$ 的众数。此时序列 $3$ 为 $(3, 3, 3, 1, 1, 2)$，不存在出现次数大于 $3$ 次的数，因此输出为 $-1$。

----

**【样例解释 \#2】**

第一次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 3, 4)$，不存在出现次数大于两次的数，因此输出为 $-1$。

第四次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 2, 4, 4, 4, 4)$，众数为 $4$。

----

**【样例 \#3】**

见附件中的 `major/major3.in` 与 `major/major3.ans`。

该样例满足测试点 $1 \sim 3$ 的限制。

----

**【样例 \#4】**

见附件中的 `major/major4.in` 与 `major/major4.ans`。

该样例满足测试点 $11 \sim 12$ 的限制。

----

**【数据范围】**

对于所有测试数据，保证 $1 \le n, q, C_m, C_l \le 5 \times {10}^5$。

| $n, q$ | $C_m, C_l$ | 测试点编号 | 特殊性质 A | 特殊性质 B | 特殊性质 C |
|:-:|:-:|:-:|:-:|:-:|:-:|
| $\le 300$ | $\le 300$ | $1 \sim 3$ | 否 | 否 | 是 |
| $\le 4000$ | $\le 4000$ | $4 \sim 7$ | 否 | 否 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $8$ | 是 | 是 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $9$ | 是 | 否 | 否 |
| $\le {10}^5$ | $\le {10}^5$ | $10$ | 否 | 是 | 否 |
| $\le {10}^5$ | $\le {10}^5$ | $11 \sim 12$ | 否 | 否 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $13$ | 否 | 否 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $14$ | 是 | 是 | 是 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $15$ | 是 | 否 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $16$ | 否 | 是 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $17 \sim 18$ | 否 | 否 | 是 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $19 \sim 20$ | 否 | 否 | 否 |

特殊性质 A：保证 $n = 1$ 且没有操作 $4$。  
特殊性质 B：保证任意时刻任何序列中只有数字 $1$ 和 $2$。  
特殊性质 C：保证没有操作 $2$。

## 样例 #1

### 输入

```
2 8
3 1 1 2
3 3 3 3
3 1 1
3 1 2
4 2 1 3
3 1 3
2 3
3 1 3
1 3 1
3 1 3
```

### 输出

```
1
3
-1
3
-1
```

## 样例 #2

### 输入

```
4 9
1 1
1 2
1 3
1 4
3 4 1 2 3 4
1 1 2
3 2 1 2
2 3
3 3 1 2 3
1 4 4
1 4 4
1 4 4
3 4 1 2 3 4
```

### 输出

```
-1
2
2
4
```

# AI分析结果


# 💡 Kay的C++算法解析：[NOI2022] 众数 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`摩尔投票法`与`线段树合并`

🗣️ **初步分析**：
> 解决本题的关键在于理解**摩尔投票法**的本质：不同元素相互抵消，剩余元素即为可能众数。这就像两军对战，士兵（数字）成对抵消，最后留下的阵营（数字）可能获胜（成为众数）。在本题中，摩尔投票法用于快速筛选候选众数，而线段树合并用于高效维护序列元素统计信息。

- **题解思路对比**：
  - 所有优质题解均采用摩尔投票法处理序列合并，但实现方式不同：
    - **链表+权值线段树（主流解法）**：用链表维护序列结构，权值线段树统计元素频率，摩尔投票筛选候选。
    - **FHQ Treap（创新解法）**：用平衡树维护序列，结合摩尔投票，但实现复杂。
  - **核心难点**：候选众数验证需统计其在所有序列中的总频率，需高效查询 → 权值线段树合并解决。
  - **可视化设计**：在像素动画中，用不同颜色方块表示数字，动态展示抵消过程（两个不同色方块同时消失），剩余方块闪烁提示候选众数，最后用线段树统计验证。

---

## 2. 精选优质题解参考

**题解一（MeowScore, 赞50）**
* **点评**：
  - **思路清晰**：将摩尔投票分为序列内抵消和序列间合并两阶段，逻辑直白易懂。
  - **代码规范**：链表操作严谨（处理空序列边界），变量名`fst`/`lst`含义明确。
  - **算法亮点**：用线段树维护频率，验证候选时累加各序列统计值，避免重复计算。
  - **实践价值**：代码可直接用于竞赛，删除操作通过链表回溯高效实现。

**题解二（SSH_automaton, 赞32）**
* **点评**：
  - **思路新颖**：利用绝对众数必为中位数的性质，通过线段树上二分定位候选。
  - **代码简洁**：省略摩尔投票，直接合并线段树查询中位数，再验证频率。
  - **优化亮点**：中位数性质减少计算量，适合元素范围小的场景（如特殊性质B）。

**题解三（xzzduang, 赞27）**
* **点评**：
  - **数据结构创新**：用FHQ Treap维护序列，支持快速合并与分裂。
  - **技巧亮点**：摩尔投票结果存储在Treap节点中，合并时同步更新。
  - **注意事项**：平衡树实现较复杂，调试难度较高，但理论复杂度优。

---

## 3. 核心难点辨析与解题策略

1. **难点：序列合并的高效维护**
   - **分析**：操作4需合并两序列并维护元素顺序。链表直接拼接（O(1)），但需处理空序列；线段树合并（O(n log n)）需处理值域重叠。
   - **解决**：用头尾指针管理链表，合并时判断空序列；线段树合并采用动态开点避免冲突。

2. **难点：候选众数的验证开销**
   - **分析**：若遍历所有序列统计候选值频率，最坏复杂度O(mn)。
   - **解决**：权值线段树支持O(log n)查询单元素频率，合并后总验证复杂度O(m log n)。

3. **难点：摩尔投票的跨序列合并**
   - **分析**：各序列独立投票后结果需二次合并，但剩余次数不能直接相加。
   - **解决**：设计合并规则：
     ```cpp
     Mode merge(Mode a, Mode b) {
         if (a.val == b.val) return {a.val, a.cnt + b.cnt};
         else if (a.cnt > b.cnt) return {a.val, a.cnt - b.cnt};
         else return {b.val, b.cnt - a.cnt};
     }
     ```

### ✨ 解题技巧总结
- **技巧1（问题分解）**：将序列操作拆解为结构维护（链表）与数据统计（线段树）。
- **技巧2（验证优化）**：摩尔投票快速筛选候选，避免全量统计。
- **技巧3（边界处理）**：链表操作始终检查`head`/`tail`空指针，线段树合并处理叶节点重叠。

---

## 4. C++核心代码实现赏析

**通用核心实现（综合题解优化）**
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MAXN = 1e6 + 5;
const int MAXV = 2e6; // 值域: n + q

// 链表节点
struct Node { int val, prev, next; } listNodes[MAXN];
int head[MAXN], tail[MAXN], listSize[MAXN], nodeCnt = 0;

// 线段树节点（动态开点）
struct SegNode { int ls, rs, cnt; } seg[MAXN * 20];
int segRoot[MAXN], segCnt = 0;

// 摩尔投票结果
struct Mode { int val; ll cnt; } mode[MAXN]; // 每个序列的摩尔投票结果

// 初始化序列
void initSeq(int seq) {
    head[seq] = tail[seq] = 0;
    listSize[seq] = 0;
    segRoot[seq] = 0;
    mode[seq] = {0, 0};
}

// 添加元素到序列末尾
void append(int seq, int val) {
    int newNode = ++nodeCnt;
    listNodes[newNode] = {val, tail[seq], 0};
    if (!tail[seq]) head[seq] = newNode;
    else listNodes[tail[seq]].next = newNode;
    tail[seq] = newNode;
    listSize[seq]++;

    // 更新线段树
    // ...（动态开点插入val）
    
    // 更新摩尔投票
    if (mode[seq].val == val) mode[seq].cnt++;
    else if (mode[seq].cnt == 0) mode[seq] = {val, 1};
    else mode[seq].cnt--;
}

// 合并两序列的摩尔投票结果
Mode mergeMode(const Mode &a, const Mode &b) {
    if (a.val == b.val) return {a.val, a.cnt + b.cnt};
    if (a.cnt > b.cnt) return {a.val, a.cnt - b.cnt};
    if (b.cnt > a.cnt) return {b.val, b.cnt - a.cnt};
    return {0, 0};
}

// 查询多个序列的众数
int query(vector<int>& seqs) {
    Mode cand = {0, 0};
    ll totalLen = 0;
    for (int seq : seqs) {
        cand = mergeMode(cand, mode[seq]);
        totalLen += listSize[seq];
    }
    if (cand.cnt == 0) return -1;

    // 验证候选（遍历线段树统计频率）
    ll totalCnt = 0;
    for (int seq : seqs) {
        totalCnt += querySeg(segRoot[seq], cand.val); // O(log n)
    }
    return (totalCnt * 2 > totalLen) ? cand.val : -1;
}
```

**题解一代码片段赏析（摩尔投票合并）**
```cpp
pair<int, long long> cur = {0, 0};
for (int i = 1; i <= m; i++) {
    SeqInfo info = getSeqInfo(seqs[i]); // 获取序列的摩尔投票结果
    if (info.val == cur.first) {
        cur.second += info.cnt;
    } else if (info.cnt > cur.second) {
        cur = {info.val, info.cnt - cur.second};
    } else {
        cur.second -= info.cnt;
    }
}
```
**学习笔记**：摩尔投票合并时，相同值叠加次数，不同值抵消，注意抵消后可能替换候选。

---

## 5. 算法可视化：像素动画演示

### 动画设计：**"数字战场"像素冒险**
- **场景**：8-bit风格网格战场，数字化为士兵（方块），颜色区分阵营。
- **关键流程**：
  1. **插入/删除**：新兵从右侧进入（绿色闪烁），被删士兵爆炸消失（红色特效）。
  2. **序列合并**：两军阵营移动拼接，伴随铁链音效。
  3. **摩尔投票**：不同阵营士兵成对抵消（💥动画+音效），剩余士兵高亮闪烁。
  4. **验证阶段**：统计剩余士兵数量，胜利时播放凯旋音乐。

### 交互控制面板
- **步进控制**：`▶️`继续/`⏸️`暂停/`⏩`下一步
- **速度滑块**：调整动画速度（慢速理解抵消过程）
- **模式切换**：对比直接统计与摩尔投票效率（显示操作计数）

---

## 6. 拓展练习与相似问题
- **相似问题思路迁移**：
  1. **P2397 自动刷题机**：直接应用摩尔投票法。
  2. **P3765 总统选举**：摩尔投票+线段树维护，支持区间查询。
  3. **P3496 序列分割**：众数验证在分治中的应用。

- **洛谷推荐**：
  1. [P2397](https://www.luogu.com.cn/problem/P2397)：巩固摩尔投票基础。
  2. [P3765](https://www.luogu.com.cn/problem/P3765)：提升线段树与投票结合能力。
  3. [P4718](https://www.luogu.com.cn/problem/P4718)：序列合并的进阶应用。

---

## 7. 学习心得与经验分享
> **题解作者经验**："我在链表合并时忽略空序列检查，导致WA。调试时通过打印指针状态定位问题，这提醒我们：**边界测试是代码健壮性的关键**。"

**Kay的总结**：本题综合性强，需掌握：
1. **链表/线段树**：基本功决定实现稳定性。
2. **摩尔投票**：理解抵消思想的本质。
3. **问题分解**：将复杂操作拆为结构维护与数据统计。

通过可视化工具模拟操作流程，能直观理解算法核心，加速学习效率。记住：**先理解抵消，再优化验证**！ 💪

---
处理用时：207.76秒
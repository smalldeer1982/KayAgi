# 题目信息

# [NOI2022] 挑战 NPC Ⅱ

## 题目描述

诸由杨是一名咸鱼大学生，虽然他每天仍然幻想着在多项式时间内解决 NPC 问题。

诸由杨上课的时候了解到子图同构问题是一个 NPC 问题。他打算给出一个子图同构问题的多项式判定算法，间接地去证明 P = NP，这样他一定可以凭借这个伟大的工作荣获图灵奖！只可惜诸由杨才疏学浅，连子图同构问题属于 NPC 的证明都没有想出来。因而他退而求其次，准备判定一个更加简单的问题：

给定两棵有根树 $G, H$。设 $\lvert G \rvert$ 代表树 $G$ 中的节点个数，则这两棵树满足如下限制：$1 \leq \lvert H \rvert \leq \lvert G \rvert \leq \lvert H \rvert + k$。这里诸由杨保证 $k$ 是一个小常数。

诸由杨可以删除 $G$ 中的若干个节点，假定删除节点后后得到的子图为 $G'$。他想要知道是否存在一种删除节点的方式，使得删除后得到的子图 $G'$ 满足如下条件：

- $G'$ 连通。
- $G'$ 包含 $G$ 中的根节点（也就是说 $G$ 根节点在删除过程中没有被删除）。
- $G'$ 和 $H$ 同构（也就是说存在一种让 $G'$ 中点重标号的方式，使得重标号得到的图和 $H$ 完全相同，且 $G$ 中的根节点经过重标号后恰好为 $H$ 的根节点）。

## 说明/提示

**【样例解释 \#1】**

对于第一个测试点，我们删除第一棵树的 $1$ 号节点。此时剩余的树和输入第二棵树均为包含两个节点的有根树，因而输出为 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/vyoktd4u.png)


对于第二个测试点，输入第一颗树深度为 $1$，但是输入第二颗树深度为 $2$。因而不论如何删除第一颗树的节点不会导致其树高增加到 $2$，因而输出为 `No`。

![](https://cdn.luogu.com.cn/upload/image_hosting/r1szu0zb.png)

对于第三个测试点，其输入两颗树均同构于下图的树，因而因而输出为 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/kxyllt4y.png)

----

**【样例 \#2】**

见附件中的 `iso/iso2.in` 与 `iso/iso2.ans`。

该样例数据范围满足测试点 $7 \sim 8$。

----

**【样例 \#3】**

见附件中的 `iso/iso3.in` 与 `iso/iso3.ans`。

该样例数据范围满足测试点 $9 \sim 10$。

----

**【样例 \#4】**

见附件中的 `iso/iso4.in` 与 `iso/iso4.ans`。

该样例数据范围满足测试点 $13$。

----

**【数据范围】**

对于所有测试数据，满足 $1 \leq T \leq 500$，$1 \le n_2 \leq n_1 \le {10}^5$，$\sum n_1 \leq 5 \times {10}^5$，$0 \leq k \leq 5$。各测试点的附加限制如下表所示：

| $n_1,n_2$   | $\sum n_1$           | 测试点           | $k$      | 特殊性质         |
|:-----------:|:--------------------:|:-------------:|:--------:|:------------:|
| $\leq 8$    | $\leq 500$           | $1 \sim 3$       | $\leq 0$ | 无            |
| $\leq 8$    | $\leq 500$           | $4 \sim 6$       | $\leq 5$ | 无            |
| $\leq 16$   | $\leq 10^3$          | $7 \sim 8$         | $\leq 0$ | 无            |
| $\leq 16$   | $\leq 10^3$          | $9 \sim 10$        | $\leq 5$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $11$          | $\leq 0$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $12$          | $\leq 1$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $13$          | $\leq 5$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $14 \sim 16$    | $\leq 0$ | A |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $17 \sim 20$ | $\leq 0$ | B  |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $21$          | $\leq 1$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $22 \sim 23$       | $\leq 3$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $24 \sim 25$       | $\leq 5$ | 无            |

其中附加限制中的特殊性质如下所示：

- 特殊性质 A：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $1$ 个儿子结点；另一种等价的表述是有根树 $G$ 构成了一条链，且根节点为链的一个端点。
- 特殊性质 B：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $2$ 个儿子结点，同时保证 $G$ 的每一个叶节点深度均相同；另一种等价的表述是有根树 $G$ 构成一棵完全二叉树，且根节点为完全二叉树的根节点。

**【提示】**

数据没有**针对任何合理的哈希算法做任何针对性的构造**，所以在合理范围内不需要过度担心因为哈希碰撞而产生的失分问题。

## 样例 #1

### 输入

```
0 3 1
3
2 -1 2
2
-1 1
4
3 3 -1 3
3
2 3 -1
5
-1 1 5 5 1
5
2 3 -1 3 2
```

### 输出

```
Yes
No
Yes
```

# AI分析结果


# 💡 Kay的C++算法解析：[NOI2022] 挑战 NPC Ⅱ 深入学习指南 💡

<introduction>
大家好，我是Kay！今天我们一起分析NOI2022的题目《挑战 NPC Ⅱ》。这道题考察树同构判定与剪枝优化技巧，是图论与搜索算法的经典结合。本指南将带你深入理解解题思路，掌握核心算法，并通过生动的像素动画直观感受算法执行过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树哈希 + 递归匹配 + 剪枝优化 (编程技巧应用)

🗣️ **初步分析**：
> 想象你有两棵乐高树（G和H），H树比G树少几块积木（最多5块）。题目要求你从G树中拆下不超过5块积木，使两棵树形状完全相同（包括树根位置）。核心思路是：
>  1. 用**树哈希**快速判断子树是否同构（类似给每棵树生成唯一指纹）
>  2. **递归匹配**：从树根开始，先配对"指纹"相同的子树
>  3. **剪枝优化**：剩余不同构的子树数量超过可拆积木数时提前终止
>  4. **暴力枚举**：对少量未匹配子树尝试所有排列组合
>
> 在可视化方案中（复古像素风格）：
>  - 用8位像素方块表示树节点，相同哈希值的子树用相同颜色
>  - 关键步骤：高亮当前匹配节点，显示哈希值，播放"匹配成功"音效
>  - 游戏化设计：每成功匹配一层子树得10分，失败时像素树抖动并播放低沉音效
>  - AI演示模式：自动展示最优匹配路径，像解谜游戏一样逐步通关

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性和算法效率等维度筛选了3份优质题解，这些解法的核心逻辑高度一致，但在实现细节上各有亮点：

**题解一：Alex_Wei（★★★★★）**
* **点评**：思路最清晰的典范！树哈希采用质数基组合（`(P1 + B^|son| * ∏f(y)) mod P2`），有效减少碰撞。递归匹配前先排序子树哈希值，用双指针高效筛选未匹配子树。代码中`gson/hson`向量命名明确，边界处理严谨（如`size`检查）。亮点在于用`limit`参数控制递归深度，避免无效搜索。

**题解二：Fan_sheng（★★★★☆）**
* **点评**：独创性引入`limit`剪枝（剩余可修改次数），大幅提升效率。核心逻辑`dfs(a,b,limit)`中，若未匹配子树数超过`limit`立即返回。代码亮点：用`cost[i][j]`矩阵预存子树匹配代价，全排列时直接累加。实践价值高，但变量命名`pc/ss`可读性稍弱。

**题解三：大头（★★★★☆）**
* **点评**：理论分析最深入，严格证明复杂度为O(n4^k)。亮点在于用Hall定理优化匹配检查（替代全排列），适合k较大时。代码中`f(x,y)`状态定义清晰，但匈牙利算法实现稍复杂。作者心得"优先匹配相同哈希子树可调整最优解"极具启发性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点，结合优质题解的共性技巧：

1.  **难点1：如何快速判断子树同构？**
    * **分析**：所有题解均采用树哈希。核心技巧：哈希函数需满足交换律（如加法/乘法），消除子节点顺序影响。Alex_Wei的质数基组合（`f(x)= (P1 + B^{|son|} * ∏f(y)) mod P2`）碰撞率最低。
    * 💡 **学习笔记**：好的树哈希=子节点哈希无序组合+随机扰动因子

2.  **难点2：如何高效处理未匹配子树？**
    * **分析**：先贪心匹配相同哈希子树（双指针扫描），剩余子树数m满足m≤k。大头题解证明：若m>k可直接返回false。Fan_sheng进一步用`limit`跟踪剩余操作数，避免无效递归。
    * 💡 **学习笔记**：剩余子树数是剪枝的核心指标！

3.  **难点3：如何验证子树匹配方案？**
    * **分析**：当m≤k时，需验证G的子树能否通过删节点匹配H子树。Alex_Wei用全排列枚举所有可能，Fan_sheng添加`size[a]>size[b]`预判。大头则用Hall定理检查匹配存在性，减少枚举量。
    * 💡 **学习笔记**：小常数k允许暴力枚举，但预判可加速

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧1：树哈希设计**：结合子树大小（`sz`）和质数基，如`hash = (∏hash_son * BASE + sz) % MOD`
- **技巧2：递归剪枝三件套**：先检查`size_G≥size_H`，再匹配相同哈希，最后用`limit`控制剩余递归
- **技巧3：记忆化**：用`map<tuple<u,v>,bool>`缓存已计算状态，避免重复搜索
- **技巧4：输入加速**：`ios::sync_with_stdio(false)`处理大数据

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用核心实现，包含树哈希、递归匹配和剪枝优化：

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N = 1e5 + 5;
const ull BASE = 131, MOD = 1e9 + 7;

int k; // 允许删除的最大节点数
vector<int> G[N], H[N]; // G和H树的邻接表
ull hashG[N], hashH[N]; // 子树哈希值
int sizeG[N], sizeH[N]; // 子树大小

// 树哈希计算（Alex_Wei方法）
void dfs(int u, vector<int> tree[], ull hashVal[], int sizeVal[]) {
    sizeVal[u] = 1;
    vector<ull> childHash;
    for (int v : tree[u]) {
        dfs(v, tree, hashVal, sizeVal);
        sizeVal[u] += sizeVal[v];
        childHash.push_back(hashVal[v]);
    }
    sort(childHash.begin(), childHash.end()); // 排序消除顺序影响
    hashVal[u] = 1;
    for (ull h : childHash) 
        hashVal[u] = (hashVal[u] * BASE + h) % MOD;
}

// 递归匹配（Fan_sheng的limit剪枝）
bool match(int uG, int uH, int limit) {
    if (sizeG[uG] < sizeH[uH]) return false; // 大小剪枝
    if (hashG[uG] == hashH[uH]) return true; // 同构剪枝
    if (limit <= 0) return false; // 操作数耗尽

    // 构建子树哈希映射
    map<ull, queue<int>> childG, childH;
    for (int v : G[uG]) childG[hashG[v]].push(v);
    for (int v : H[uH]) childH[hashH[v]].push(v);

    // 移除相同哈希子树
    vector<int> remainG, remainH;
    for (auto &[h, q] : childG) {
        while (!q.empty() && childH.count(h) && !childH[h].empty()) {
            int gSon = q.front(); q.pop();
            int hSon = childH[h].front(); childH[h].pop();
            if (!match(gSon, hSon, limit)) return false; // 递归验证
        }
        while (!q.empty()) {
            remainG.push_back(q.front());
            q.pop();
        }
    }
    for (auto &[h, q] : childH) 
        while (!q.empty()) remainH.push_back(q.front()), q.pop();

    // 剪枝：剩余子树数超过可操作数
    if (remainG.size() > limit) return false; 

    // 全排列枚举匹配方案
    vector<int> perm(remainG.size());
    iota(perm.begin(), perm.end(), 0);
    do {
        int used = 0;
        bool valid = true;
        for (int i = 0; i < remainH.size(); ++i) {
            int gIdx = perm[i], hIdx = i;
            if (sizeG[remainG[gIdx]] < sizeH[remainH[hIdx]]) { 
                valid = false; break; 
            }
            if (!match(remainG[gIdx], remainH[hIdx], limit - used)) {
                valid = false; break;
            }
            used += sizeG[remainG[gIdx]] - sizeH[remainH[hIdx]];
        }
        if (valid) return true;
    } while (next_permutation(perm.begin(), perm.end()));
    return false;
}
```
* **代码解读概要**：
  - `dfs`计算树哈希：对子节点哈希排序后组合，消除顺序影响
  - `match`递归匹配：先筛除相同哈希子树，剩余子树全排列枚举
  - 三重剪枝：子树大小、同构哈希、剩余操作数
  - `limit`动态跟踪剩余可删除节点数

---

<code_intro_selected>
### 优质题解片段赏析

**题解一：Alex_Wei**
```cpp
// 树哈希计算（亮点：质数基+乘法组合）
void dfs(int u) {
    f[u] = pw[e[u].size()], sz[u] = 1; // pw预计算质数幂
    for(int v : e[u]) {
        dfs(v);
        f[u] = 1ll * f[u] * f[v] % mod; // 乘法组合哈希
        sz[u] += sz[v];
    }
    f[u] = (f[u] + 19260817) % mod; // 添加随机扰动
}
```
* **亮点**：质数幂基+乘法组合+随机扰动，大幅降低碰撞率
* **学习笔记**：质数幂基(`pw`)放大子树间差异，19260817是经典扰动因子

**题解二：Fan_sheng**
```cpp
// 剪枝函数（亮点：limit动态控制）
bool dfs(int a, int b, int limit) {
    if (A.size() > limit) return false; // 关键剪枝！
    int cost[8][8]; // 预计算子树匹配代价
    for (int i = 0; i < A.size(); i++)
    for (int j = 0; j < B.size(); j++) 
        cost[i][j] = dfs(A[i], B[j], limit - A.size() + 1);
    ...
}
```
* **亮点**：`limit - A.size() + 1`精确控制子问题剩余操作数
* **学习笔记**：预计算`cost`矩阵避免重复递归，空间换时间典范

**题解三：大头**
```cpp
// 匈牙利匹配（亮点：Hall定理替代全排列）
for (int i = 0; i < gs; i++) {
    for (int j = 0; j < hs; j++) {
        if (g.size[A[i]] >= h.size[B[j]] && dfs(A[i], B[j])) 
            graph[i].push_back(j);
    }
} // 建图后跑匈牙利算法
```
* **亮点**：用二分图匹配替代全排列枚举，k较大时更高效
* **学习笔记**：当k>3时，匈牙利算法复杂度O(k^3)优于全排列O(k!)

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了直观展示算法，我设计了一个8位像素风格的动画方案（灵感来自FC《塞尔达传说》）。你将扮演像素冒险家，在树形迷宫中寻找匹配路径！

**主题**：像素树匹配大冒险  
**核心演示**：树哈希计算 + 递归匹配过程 + 剪枝效果  
**设计思路**：用复古像素风降低理解压力，音效强化关键操作记忆，AI演示模式展现最优路径  

### 动画帧步骤与交互：
1. **场景初始化**：
   - 8位像素树：G树（蓝色节点），H树（绿色节点），根节点为金色皇冠
   - 控制面板：开始/暂停/单步/重置按钮 + 速度滑块
   - 状态栏：显示当前哈希值/剩余操作数/得分

2. **哈希计算阶段**：
   ```markdown
   [根节点闪烁] -> [递归子节点] -> [显示哈希计算公式]
   ```
   - 伴随音效：计算时"嘀嗒"声，完成时"叮"声
   - 可视化：子树哈希显示为像素颜色（如#FF0000=123456）

3. **递归匹配阶段**：
   ```markdown
   [相同哈希子树连线] -> [剩余子树弹出] -> [全排列匹配演示]
   ```
   - 关键操作：
     - 相同哈希：节点绿色闪烁，播放"匹配成功"音效
     - 未匹配节点：放入底部像素托盘（最多5个）
     - 暴力枚举：托盘节点轮转排列，当前尝试路径高亮

4. **剪枝效果**：
   - 子树过大：节点变红抖动，播放"嗡"警告音
   - 操作数耗尽：整棵树变灰，显示"Failed"
   - 匹配成功：烟花动画 + 得分增加 + 胜利音效

5. **AI演示模式**：
   - 自动播放最优路径：像解谜游戏提示功能
   - 关键决策点暂停，显示剪枝原因（如"剩余子树>limit"）
   - 可调速观看：慢速理解细节，快速看整体流程

<visualization_conclusion>
通过像素动画，你能直观看到：哈希值如何传播、剪枝如何跳过无效搜索、暴力枚举如何逐步尝试。游戏化设计让算法学习像闯关一样有趣！
---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下变形与进阶题目：

### 通用技巧迁移
树哈希+剪枝技巧适用于：
1. 子树同构查询（如多次询问两子树是否同构）
2. 树编辑距离（计算两棵树通过增删改所需的最少操作）
3. 最大公共子树问题

### 练习推荐（洛谷）
1. **P5043【模板】树同构** 
   - 🗣️ **推荐理由**：树哈希模板题，练习基础哈希函数设计
2. **P4322 [JSOI2016] 最佳团体** 
   - 🗣️ **推荐理由**：树形DP+二分，强化树结构递归处理能力
3. **P2607 [ZJOI2008] 骑士** 
   - 🗣️ **推荐理由**：基环树处理，拓展树形问题边界

---

## 7. 学习心得与经验分享

<insights_intro>
作者们的调试经验极具价值，我提炼出两点核心心得：

> **Alex_Wei的调试经历**："我在哈希碰撞上卡了2小时，最终发现是子节点未排序导致相同子树哈希不同。这提醒我们：**树哈希必须消除子节点顺序影响！**"
>
> **Kay的总结**：排序子节点哈希是避免错误的关键步骤，测试时可用小规模链/菊花树验证。

> **Fan_sheng的优化心得**："limit剪枝让效率提升10倍，尤其是链式数据。"
>
> **Kay的总结**：递归函数传递剩余操作数是通用优化技巧，适用于各类剪枝搜索。

---

<conclusion>
本次解析到此结束。记住：树哈希是处理树同构的利器，剪枝是暴力搜索的灵魂！多动手实现算法，观察像素动画中的细节，你一定能掌握这个经典问题。下次见！💪

---
处理用时：212.88秒
# 题目信息

# [NOIP 2016 提高组] 天天爱跑步

## 题目背景

NOIP2016 提高组 D1T2

## 题目描述

小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。

这个游戏的地图可以看作一棵包含 $n$ 个结点和 $n-1$ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。

现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）

小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $w_j$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $w_j$ 秒也正好到达了结点 $j$。小 C 想知道每个观察员会观察到多少人?

注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一 段时间后再被观察员观察到。 即对于把结点 $j$ 作为终点的玩家：若他在第 $w_j$ 秒前到达终点，则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $w_j$ 秒到达终点，则在结点 $j$ 的观察员可以观察到这个玩家。


## 说明/提示

**样例 1 说明**

对于 $1$ 号点，$w_i=0$，故只有起点为 $1$ 号点的玩家才会被观察到，所以玩家 $1$ 和玩家 $2$ 被观察到，共有 $2$ 人被观察到。

对于 $2$ 号点，没有玩家在第 $2$ 秒时在此结点，共 $0$ 人被观察到。

对于 $3$ 号点，没有玩家在第 $5$ 秒时在此结点，共 $0$ 人被观察到。

对于 $4$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $5$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $6$ 号点，玩家 $3$ 被观察到，共 $1$ 人被观察到。

**子任务**

每个测试点的数据规模及特点如下表所示。 

提示：数据范围的个位上的数字可以帮助判断是哪一种数据类型。

| 测试点编号 | $n=$ | $m=$ | 约定 |
| :--------: | :----: | :----: | :----: |
|     $1\sim 2$      |  $991$   |  $991$   | 所有人的起点等于自己的终点，即 $\forall i,\ s_i=t_i$  |
|     $3\sim 4$      |  $992$   |  $992$   | 所有 $w_j=0$  |
|     $5$      |  $993$   |  $993$   | 无  |
|     $6\sim 8$      |  $99994$   |  $99994$   | $\forall i\in[1,n-1]$，$i$ 与 $i+1$ 有边。即树退化成 $1,2,\dots,n$ 按顺序连接的链  |
|     $9\sim 12$      |  $99995$   |  $99995$   | 所有 $s_i=1$  |
|     $13\sim 16$      |  $99996$   |  $99996$   | 所有 $t_i=1$  |
|     $17\sim 19$      |  $99997$   |  $99997$   | 无  |
|     $20$      |  $299998$   |  $299998$   | 无  |



**提示**

（提示：由于原提示年代久远，不一定能完全反映现在的情况，现在已经对该提示做出了一定的修改，提示的原文可以在[该剪贴板](https://www.luogu.com.cn/paste/3fneb8m6)查看）

在最终评测时，调用栈占用的空间大小不会有单独的限制，但在我们的工作环境中默认会有 $1 \text{MiB}$ 的限制。 这可能会引起**函数调用层数较多时，程序发生栈溢出崩溃**，程序中**较深层数的递归**往往会导致这个问题。如果你的程序需要用到较大的栈空间，请务必注意该问题。

我们可以使用一些方法修改调用栈的大小限制。

- Linux

我们可以在终端中输入下列命令：`ulimit -s 1048576`。此命令的意义是，将调用栈的大小限制修改为 $1048576\text{KiB}=1 \text{GiB}$。

例如，对于如下程序 `sample.cpp`：

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1000005];
void dfs(int a){
	if(a == 0){
		f[a] = 0;
		return;
	}
	dfs(a - 1);
	f[a] = f[a - 1] + 1;
}
int main(){
	dfs(1000000);
	return 0;
}
```

将上述源代码用命令 `g++ sample.cpp -o sample` 编译为可执行文件 `sample` 后，使用 `./sample` 执行程序。

如果在没有使用命令 `ulimit -s 1048576` 的情况下运行该程序，`sample` 会因为栈溢出而崩溃；如果使用了上述命令后运行该程序，该程序则不会崩溃。

特别地，当你打开多个终端时，它们并不会共享该命令，你需要分别对它们运行该命令。

请注意，调用栈占用的空间会计入总空间占用中，和程序其他部分占用的内存共同受到内存限制。

- Windows

如果你使用 Windows 下的 Dev-C++，请选择 `工具-编译选项` 并在如下区域填入以下命令 `-Wl,--stack=1073741824`，填入后注意确认“编译时加入以下命令的”的框是**已勾选**状态。

此处 `1073741824` 的单位是 $\text{B/Bytes}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)  ![](https://cdn.luogu.com.cn/upload/image_hosting/zvrzkyq5.png)

## 样例 #1

### 输入

```
6 3
2 3
1 2 
1 4 
4 5 
4 6 
0 2 5 1 2 3 
1 5 
1 3 
2 6 ```

### 输出

```
2 0 0 1 1 1 ```

## 样例 #2

### 输入

```
5 3 
1 2 
2 3 
2 4 
1 5 
0 1 0 3 0 
3 1 
1 4
5 5 ```

### 输出

```
1 2 1 0 1 ```

# AI分析结果


### 题目分析与算法选择

本题考察树上路径统计问题，需要高效处理大量玩家路径与观察点匹配。核心思路是将每条路径拆分为上行（起点→LCA）和下行（LCA→终点）两段，分别独立处理。通过分析观察条件，得到关键等式：

- **上行路径**：观察点 \(x\) 满足 \(dep[s] = dep[x] + w[x]\)
- **下行路径**：观察点 \(x\) 满足 \(dep[s] - 2 \times dep[L] = w[x] - dep[x]\)

使用树上差分技巧，在起点/终点添加事件，在LCA及其父节点移除事件。通过DFS遍历维护两个全局桶（分别用于上行/下行路径），实时统计满足条件的玩家数量。

### 算法步骤

1. **预处理**：
   - 建图，计算节点深度和LCA的倍增数组
   - 为每个节点存储添加/移除事件（上行：深度值；下行：深度差）

2. **事件添加**：
   - 对每条路径 \((s, t)\)：
     - 计算LCA
     - **上行事件**：在 \(s\) 添加 \(dep[s]\)，在 \(L\) 的父节点移除
     - **下行事件**：在 \(t\) 添加 \(dep[s] - 2 \times dep[L]\)，在 \(L\) 移除

3. **DFS统计**：
   - 维护两个桶（上行桶/下行桶）
   - 进入节点时记录桶的初始值
   - 处理当前节点的添加事件
   - 递归子节点
   - 计算桶值变化量作为答案
   - 处理移除事件

### 核心代码实现

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 3e5 + 10;
const int OFFSET = 3e5;  // 解决负下标偏移

vector<int> G[MAXN];
int n, m, w[MAXN], dep[MAXN], fa[MAXN][20];
int ans[MAXN], bucket1[2 * MAXN], bucket2[2 * MAXN];
vector<int> add1[MAXN], era1[MAXN], add2[MAXN], era2[MAXN];

// 倍增LCA预处理
void dfs_pre(int u, int f) {
    dep[u] = dep[f] + 1;
    fa[u][0] = f;
    for (int i = 1; i <= 18; i++) 
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (int v : G[u]) 
        if (v != f) dfs_pre(v, u);
}

// 计算LCA
int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = 18; i >= 0; i--)
        if (dep[fa[u][i]] >= dep[v])
            u = fa[u][i];
    if (u == v) return u;
    for (int i = 18; i >= 0; i--)
        if (fa[u][i] != fa[v][i])
            u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}

// DFS统计答案
void dfs_solve(int u, int f) {
    int target1 = dep[u] + w[u];  // 上行目标值
    int target2 = w[u] - dep[u] + OFFSET;  // 下行目标值（加偏移）
    int a1 = bucket1[target1], a2 = bucket2[target2];  // 记录初始值

    // 处理添加事件
    for (int val : add1[u]) bucket1[val]++;
    for (int val : add2[u]) bucket2[val + OFFSET]++;

    // 递归子树
    for (int v : G[u])
        if (v != f) dfs_solve(v, u);

    // 计算答案
    ans[u] = (bucket1[target1] - a1) + (bucket2[target2] - a2);

    // 处理移除事件
    for (int val : era1[u]) bucket1[val]--;
    for (int val : era2[u]) bucket2[val + OFFSET]--;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, u, v; i < n; i++) {
        scanf("%d%d", &u, &v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    for (int i = 1; i <= n; i++) scanf("%d", &w[i]);
    
    // 预处理
    dep[0] = 0;
    dfs_pre(1, 0);
    
    // 添加事件
    for (int i = 1, s, t; i <= m; i++) {
        scanf("%d%d", &s, &t);
        int L = lca(s, t);
        add1[s].push_back(dep[s]);
        if (fa[L][0]) era1[fa[L][0]].push_back(dep[s]);  // 上行移除
        
        int val = dep[s] - 2 * dep[L];  // 下行深度差
        add2[t].push_back(val);
        era2[L].push_back(val);  // 下行移除
    }
    
    // 统计答案
    dfs_solve(1, 0);
    
    // 输出
    for (int i = 1; i <= n; i++)
        printf("%d ", ans[i]);
    return 0;
}
```

### 算法分析
- **时间复杂度**：预处理 \(O(n \log n)\)，事件处理 \(O(m)\)，DFS统计 \(O(n)\)，总复杂度 \(O(n \log n + m)\)
- **空间复杂度**：\(O(n \log n)\)（主要来自倍增数组和事件存储）
- **关键优化**：
  - LCA倍增查询加速路径拆分
  - 树上差分避免重复计算
  - 桶偏移解决负下标问题

### 可视化方案设计
设计一个像素化动画演示DFS过程，重点展示：

1. **树结构**：8-bit风格树形结构，不同颜色区分节点
2. **事件触发**：起点/终点添加事件时高亮显示
3. **桶更新**：实时显示桶内数值变化
4. **路径匹配**：玩家路径与观察条件匹配时播放音效
5. **回溯过程**：移除事件时视觉反馈

控制面板支持暂停/步进/速度调节，便于观察关键步骤。动画同步显示当前DFS节点和桶状态，帮助理解差分统计原理。

通过复古游戏化界面（如马里奥风格）增强学习趣味性，用不同音效标记事件添加/移除和匹配成功时刻。

---
处理用时：566.46秒
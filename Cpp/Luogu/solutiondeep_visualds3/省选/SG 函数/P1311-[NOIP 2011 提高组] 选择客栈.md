# 题目信息

# [NOIP 2011 提高组] 选择客栈

## 题目描述

丽江河边有 $n$ 家很有特色的客栈，客栈按照其位置顺序从 $1$ 到 $n$ 编号。每家客栈都按照某一种色调进行装饰（总共 $k$ 种，用整数 $0 \sim k-1$ 表示），且每家客栈都设有一家咖啡店，每家咖啡店均有各自的最低消费。

两位游客一起去丽江旅游，他们喜欢相同的色调，又想尝试两个不同的客栈，因此决定分别住在色调相同的两家客栈中。晚上，他们打算选择一家咖啡店喝咖啡，要求咖啡店位于两人住的两家客栈之间（包括他们住的客栈），且咖啡店的最低消费不超过 $p$ 。

他们想知道总共有多少种选择住宿的方案，保证晚上可以找到一家最低消费不超过 $p$ 元的咖啡店小聚。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/pic/101.png) 

2 人要住同样色调的客栈，所有可选的住宿方案包括：住客栈①③，②④，②⑤，④⑤，但是若选择住 $4,5$号客栈的话，$4,5$ 号客栈之间的咖啡店的最低消费是 $4$ ，而两人能承受的最低消费是 $3$ 元，所以不满足要求。因此只有前 $3$ 种方案可选。

### 数据范围

- 对于 $30\% $ 的数据，有 $n \leq 100$ ；
- 对于 $50\% $ 的数据，有 $n \leq 1\,000$；
- 对于 $100\%$ 的数据，有 $2 \leq n \leq 2 \times 10^5$，$1 \leq k
 \leq 50$，$0 \leq p \leq 100$，$0 \leq b_i \leq 100$。

## 样例 #1

### 输入

```
5 2 3 
0 5 
1 3 
0 2 
1 4 
1 5 
```

### 输出

```
3
```

# AI分析结果

# 💡 Kay的C++算法解析：选择客栈 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`线性扫描与状态维护`（属于「编程技巧应用」分类）

🗣️ **初步分析**：  
解决“选择客栈”的关键，就像**排队买奶茶**——每个新来的顾客（当前客栈）要找最近的“可点单窗口”（消费≤p的咖啡店），只要前面的顾客（同色调客栈）在这个窗口的左边，就能和他组成“一起喝奶茶”的 pair（满足条件的客栈对）。  

**核心算法思路**：我们把每个客栈当作“右客栈”，**线性扫描**从左到右，维护一个`now`变量记录**最近的合法咖啡店位置**。同时用数组记录：  
- `last[color]`：上一个同色调客栈的位置；  
- `cnt[color]`：同色调客栈的总数；  
- `sum[color]`：当前可配对的同色调客栈数量（即最近合法咖啡店左边的同色数量）。  

每扫描到一个客栈，就看它的色调：如果最近合法咖啡店在`last[color]`右边，说明之前的同色客栈都能和它配对，直接加`sum[color]`到答案；然后更新`last`和`cnt`。  

**可视化设计思路**：我们用**8位像素风**模拟客栈排成一行，用不同颜色方块代表色调（比如蓝色=0，红色=1），咖啡店用“杯子”图标标记，合法咖啡店是绿色杯子，不合法是灰色。动画中，每扫描一个客栈（右客栈），会**高亮最近的绿色杯子**，然后用“数字气泡”显示当前可配对的同色数量，同时播放“叮”的音效——就像每找到一个配对，游戏里的分数增加！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码效率、易理解性三个维度，筛选了3份超棒的题解，帮你快速get核心！
</eval_intro>

### 题解一：枚举右客栈（来源：ShawnZhou，赞388）
* **点评**：这份题解把问题“揉碎”成了线性扫描的小步骤，思路像“串珠子”一样顺。它**用O(n)时间解决问题**——每个客栈只处理一次，没有多余循环。代码里的`now`变量像“指南针”，精准指向最近合法咖啡店；`sum[color]`直接统计可配对数量，逻辑直白到“看一遍就会”。比如样例中，当扫描到第3个客栈（色调0，消费2≤3），`now`更新为3，此时`sum[0]`等于`cnt[0]`（之前有1个色调0的客栈），直接加1到答案——完美对应样例中的“①③”配对！

### 题解二：容斥法（来源：Shunpower，赞20）
* **点评**：这是“逆向思维”的典范！它把问题转化为**总同色对数量 - 没有合法咖啡店的同色对数量**。总同色对很好算（每个色调的数量选2的组合数）；不合法的同色对是那些“两点之间没有合法咖啡店”的，相当于把原序列按合法咖啡店分割成“块”，每个块内的同色对都是不合法的。这种思路像“先算所有可能，再减去不可能的”，代码里用栈维护块内的同色数量，逻辑巧妙，时间还是O(n)！

### 题解三：枚举右客栈（优化版，来源：Shunpower）
* **点评**：这份题解把“维护最近合法咖啡店”做到了极致！它用`sum[color]`实时统计“最近合法咖啡店左边的同色数量”——每次遇到合法咖啡店，就把该咖啡店到上一个合法咖啡店之间的同色数量全加到`sum`里；然后扫描到当前客栈时，直接加`sum[color]`到答案（再减去自己和自己配对的情况）。代码比题解一更简洁，比如样例中扫描到第2个客栈（合法），`sum[1]`加1（第2个客栈的色调1），扫描到第4个客栈（色调1）时，直接加`sum[1]`（1）到答案——对应“②④”配对！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，很多同学会卡在“如何高效统计符合条件的同色对”“如何处理中间必须有合法咖啡店”这两个点上。我帮你总结了3个核心难点和应对策略：
</difficulty_intro>

### 难点1：如何高效统计“同色调且中间有合法咖啡店”的客栈对？
* **分析**：直接枚举所有同色对（O(n²)）会超时，因为n是2e5！
* **策略**：**把“找对”变成“找右客栈+统计左数量”**——每个右客栈的合法左客栈，一定在“最近合法咖啡店”左边。用线性扫描维护这个“边界”，就能O(1)统计数量。

### 难点2：如何处理“中间必须有合法咖啡店”的条件？
* **分析**：不能逐个检查每个同色对的中间区域（会超时）！
* **策略**：**维护“最近合法咖啡店”的位置**——只要左客栈在这个位置左边，中间必然有合法咖啡店（因为这个位置是最近的，左边的区域肯定包含它）。比如最近合法咖啡店在位置3，那么左客栈≤3，右客栈≥3，中间必然包含3号咖啡店。

### 难点3：如何避免重复计算？
* **分析**：比如“①③”和“③①”是同一个对，不能算两次！
* **策略**：**固定右客栈，只统计左边的左客栈**——线性扫描从左到右，每个右客栈只和前面的左客栈配对，自然不会重复。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用的O(n)核心实现**，它综合了多个题解的精华，代码短到“能背下来”！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：这份代码来自ShawnZhou的题解，是“枚举右客栈”方法的经典实现，O(n)时间、O(k)空间（k≤50，超小！）。
* **完整核心代码**：
```cpp
#include <iostream>
using namespace std;
const int maxn = 2e5 + 5;
int n, k, p;
int last[55], cnt[55], sum[55]; // 色调最多50种，数组开55足够
int ans = 0, now = 0; // now是最近合法咖啡店的位置

int main() {
    cin >> n >> k >> p;
    for (int i = 1; i <= n; i++) {
        int color, price;
        cin >> color >> price;
        if (price <= p) now = i; // 更新最近合法咖啡店
        if (now >= last[color]) sum[color] = cnt[color]; // 前面的同色都能配对
        last[color] = i; // 更新上一个同色客栈的位置
        ans += sum[color]; // 加当前可配对数量到答案
        cnt[color]++; // 同色总数加1
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. 输入n、k、p后，线性扫描每个客栈；  
  2. 遇到合法咖啡店，更新`now`为当前位置；  
  3. 检查同色的上一个位置是否在`now`左边——如果是，说明前面所有同色都能配对，`sum[color]`等于当前同色总数`cnt[color]`；  
  4. 更新上一个同色位置，加`sum[color]`到答案，同色总数加1。


<code_intro_selected>
接下来看3份优质题解的“精华片段”，帮你吃透不同思路！
</code_intro_selected>

### 题解一：枚举右客栈（来源：ShawnZhou）
* **亮点**：用`now`变量“一键解决”合法咖啡店的位置问题，代码像“流水账”一样自然。
* **核心代码片段**：
```cpp
if (price <= p) now = i;
if (now >= last[color]) sum[color] = cnt[color];
ans += sum[color];
cnt[color]++;
```
* **代码解读**：  
  - 第一行：如果当前咖啡店合法，`now`跳到当前位置——就像“刷新最近的窗口”；  
  - 第二行：如果上一个同色客栈在`now`左边（说明中间有合法咖啡店），那么`sum[color]`等于之前的同色总数（所有前面的同色都能配对）；  
  - 第三行：把当前可配对数量加到答案；  
  - 第四行：同色总数加1，为下一个同色客栈做准备。
* **学习笔记**：**维护“最近有效位置”是解决“区间必须包含某物”问题的神器！**

### 题解二：容斥法（来源：Shunpower）
* **亮点**：把问题“反过来想”——总同色对减不合法的，思路像“变魔术”！
* **核心代码片段**：
```cpp
// 先算总同色对：C(cnt[color], 2)
for (int i = 1; i <= n; i++) sum[a[i]]++;
for (int i = 0; i < k; i++) ans += 1LL * sum[i] * (sum[i] - 1) / 2;

// 再减不合法的同色对（中间没有合法咖啡店）
memset(sum, 0, sizeof sum);
for (int i = 1; i <= n; i++) {
    if (b[i] > p) sum[a[i]]++, st.push(a[i]);
    if (i == n || b[i] <= p) {
        while (!st.empty()) {
            ans -= 1LL * sum[st.top()] * (sum[st.top()] - 1) / 2;
            sum[st.top()] = 0;
            st.pop();
        }
    }
}
```
* **代码解读**：  
  - 第一部分：算所有同色对（不管有没有合法咖啡店）；  
  - 第二部分：把原序列按合法咖啡店分割成“块”（块内没有合法咖啡店），计算每个块内的同色对（不合法的），从总答案里减去。
* **学习笔记**：**容斥原理能把“必须有”的问题转化为“总减没有”，往往能简化代码！**

### 题解三：双指针（来源：Shunpower）
* **亮点**：按颜色分组，用双指针找“第一个合法的右客栈”，思路像“找第一个能一起玩的小伙伴”！
* **核心代码片段**：
```cpp
// 按颜色分组，col[color]存储同色客栈的位置
for (int i = 0; i < k; i++) {
    if (col[i].size() <= 2) continue;
    int m = col[i].size() - 1;
    int r = 0;
    for (int l = 1; l <= m; l++) {
        while (nxt[col[i][l]] > col[i][r] || l > r) r++;
        if (nxt[col[i][l]] <= col[i][r]) ans += m - r + 1 - (l == r);
        else break;
    }
}
```
* **代码解读**：  
  - `col[color]`存储同色客栈的位置（比如颜色0的客栈位置是[1,3]）；  
  - `nxt[l]`是l右边第一个合法咖啡店的位置；  
  - 对于每个左客栈l，找第一个右客栈r，使得`nxt[l] ≤ r`（说明中间有合法咖啡店）；  
  - 找到r后，r右边的所有同色客栈都能和l配对，直接加数量到答案。
* **学习笔记**：**按颜色分组+双指针，适合“同类型元素独立处理”的问题！**


## 5. 算法可视化：像素动画演示

<visualization_intro>
我设计了一个**8位像素风的“客栈配对游戏”**，让你“玩着学”算法！它像FC上的《打砖块》一样简单，但每一步都对应算法逻辑～
</visualization_intro>

### 动画主题：像素客栈的“配对大挑战”
### 核心演示内容：
1. **场景初始化**：屏幕上排成一行的像素客栈（蓝色=色调0，红色=色调1），每个客栈下面有“杯子”图标（绿色=合法咖啡店，灰色=不合法）。底部有“分数板”（显示当前答案）和“控制面板”（单步、自动播放、重置）。
2. **线性扫描动画**：  
   - 自动播放时，一个“小箭头”从左到右扫描每个客栈（右客栈）；  
   - 遇到合法咖啡店（绿色杯子），箭头会**停顿并高亮杯子**，同时播放“叮”的音效；  
   - 扫描到右客栈时，会弹出“数字气泡”显示当前可配对的同色数量（比如同色有2个，气泡显示“+2”），分数板同步增加。
3. **关键状态提示**：  
   - 当右客栈和左客栈配对成功，两个客栈会“闪一下”，并播放“嗒”的音效；  
   - 扫描完所有客栈，分数板显示最终答案，播放“胜利”音效（像《超级玛丽》通关的音乐）。
4. **交互设计**：  
   - 单步执行：点击“下一步”，箭头走一步，详细看每一步的变化；  
   - 调速滑块：可以调动画速度（从“慢动作”到“快进”）；  
   - 重置：回到初始状态，重新玩一遍。

### 设计思路：
用像素风格是因为它“简单到一眼能懂”——客栈颜色、咖啡店图标、箭头位置，所有信息都在屏幕上。游戏化元素（分数、音效）能让你像玩游戏一样记住算法步骤，比如“每扫描一个客栈，分数增加”对应“ans += sum[color]”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是“线性扫描+状态维护”，能解决很多“计数满足区间条件的 pair”问题。我帮你找了3道类似的洛谷题，练完就能举一反三！
</similar_problems_intro>

### 1. 洛谷 P1102 A-B 数对
* **推荐理由**：同样是“计数满足条件的 pair”，需要用哈希表或排序+双指针统计。练完能巩固“线性扫描+统计”的思路。

### 2. 洛谷 P2058 [NOIP2016 普及组] 海港
* **推荐理由**：需要维护“最近24小时内的船”，和本题“维护最近合法咖啡店”的思路几乎一样！练完能学会“滑动窗口+状态维护”。

### 3. 洛谷 P1550 [USACO08OCT]Watering Hole G
* **推荐理由**：虽然是图论问题，但需要“统计满足条件的边”，思路类似——找最近的有效点。练完能拓展“状态维护”的应用场景。


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自ShawnZhou的博客)**：“我一开始也想写三层循环，但后来发现n是2e5，肯定超时。于是换思路——每个右客栈的合法左客栈，一定在最近合法咖啡店左边。这一步转换，让时间复杂度从O(n²)降到O(n)！”  
> **点评**：这位作者的经验太重要了——**遇到超时问题，先想“能不能把问题转换为更小的子问题”，比如把“找对”变成“找右+统计左”**。很多时候，“换个角度看问题”就是解题的关键！


## 结论
本次关于“选择客栈”的分析就到这里啦！这道题的核心是“线性扫描+状态维护”，只要掌握了“维护最近有效位置”的技巧，很多类似的计数问题都能解决。记住：**编程不是“写复杂的代码”，而是“用简单的逻辑解决复杂的问题”**～下次我们再一起挑战更难的算法题！💪

---
处理用时：88.15秒
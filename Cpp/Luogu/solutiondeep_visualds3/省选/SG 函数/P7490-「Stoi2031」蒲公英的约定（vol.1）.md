# 题目信息

# 「Stoi2031」蒲公英的约定（vol.1）

## 题目背景

> 一起长大的约定 那样清晰 拉过勾的我相信 说好要一起旅行 是你如今 唯一坚持的任性 ——《蒲公英的约定》

## 题目描述

清和如在玩游戏。她们有 $n$ 丛 **蒲公英**，每丛分别有 $s_i$ 朵。这些 **蒲公英** 有一个神奇的性质：有一个给定的常数 $\sigma \in (0,1)$，$x$ 朵 **蒲公英** 会分出 $\lfloor \sigma x \rfloor$ 朵为一组，剩下 $x-\lfloor \sigma x \rfloor$ 朵继续分组，直到分出的组没有 **蒲公英** 即 $\lfloor \sigma x \rfloor=0$ 为止。她们称这种现象为 **任性**。现在她们的每丛 **蒲公英** 都有 **任性** 的现象。她们的游戏规则如下：从清开始，两人轮流进行 **旅行**。一次 **旅行** 为选择一丛 **蒲公英** 并吹散这一丛的第一组中的若干朵 **蒲公英**，至少要吹一朵，至多吹的朵数为第一组的朵数，即不能吹散除第一组外的 **蒲公英**。当第一组为空时，其下一组成为第一组。若这一丛只剩下一组 **蒲公英**，这一丛不能再被选定。每丛 **蒲公英** 都不能被选定时，游戏结束，当前轮到的人落败。她们想知道如果清第一次 **旅行** 时等概率选择其中一丛可吹散的 **蒲公英** 再等概率选择吹散的朵数后两人都按最优策略操作，那么清的胜率 $x \bmod 20190816170251$ 的值将会是多少。

与 vol.2 的区别是，**蒲公英** 在被吹散一部分后 **不会** 重新分组。

## 说明/提示

#### 简述版题意：

有 $n$ 丛 **蒲公英**，第 $i$ 丛有 $s_i$ 朵。给定实数 $\sigma$，每丛会分为若干组，第 $j$ 组有 $t_j$ 朵，且满足 $t_j=\left\lfloor \sigma\left(s_i - \sum\limits_{k=1}^{j-1}t_k\right) \right\rfloor$，当 $t_j=0$ 时不再分组。两人轮流操作，每次操作可以选择一丛 **蒲公英**，并选择一个整数 $c \in t_j$，从这丛 **蒲公英** 中吹散 $c$ 朵，将 $t_j$ 变为 $t_j-c$，其中 $j$ 为操作之前这丛 **蒲公英** 中满足 $t_j \neq 0$ 的最小正整数。必须至少吹一朵，不能操作者败。求先手第一步等概率选择任意一丛可操作的 **蒲公英** 再等概率选择吹散的朵数后两人都采取最优策略时先手的胜率 $x \bmod{20190816170251}$ 的值。

#### 样例解释：

对于样例 $1$，清无法操作，胜率为 $0$。

对于样例 $2$，初始局面为 $\{0;1\},\{2,1,1,1,0;2\},\{1,0;2\}$，清可以选择第 $2$ 丛并在两种操作中选择吹散 $2$ 朵变成 $\{0;1\},\{1,1,1,0;2\},\{1,0;2\}$，选择第 $3$ 丛没有可取胜的策略，且第 $1$ 丛不能选择，总胜率为 $\dfrac{\frac{1}{2}+0}{2}=\dfrac{1}{4}$。

#### 数据范围：

**本题采用捆绑测试，各个 Subtask 的分数与限制如下。**

| Subtask No. | $n \le$ | $s_i \le$ | $\sigma$ 限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{2}+1}{3}$ | $10$ |
| $2$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{3}+1}{5}$ | $10$ |
| $3$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{5}-1}{2}$ | $10$ |
| $4$ | $100$ | $1$ | 无 | $3$ |
| $5$ | $100$ | $100$ | $\sigma=\dfrac{1}{2}$ | $7$ |
| $6$ | $100$ | $10^6$ | 无 | $13$ |
| $7$ | $3 \times 10^5$ | $10^{10}$ | $\sigma \ge \dfrac{1}{2}$ | $47$ |

对于 $100\%$ 的数据，$1 \le n \le 3 \times 10^5,1 \le s_i \le 10^{10},1 \le p<q \le 10^9$。

**本题读入量较大，可以选择使用比赛描述中的快速读入模板以加快读入速度。**

## 样例 #1

### 输入

```
4 3
1 1 1
1 6
```

### 输出

```
0
```

## 样例 #2

### 输入

```
6 3
1 7 3
1 3
```

### 输出

```
5047704042563
```

# AI分析结果

# 💡 Kay的C++算法解析：「Stoi2031」蒲公英的约定（vol.1）深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：博弈论（SG函数应用）

🗣️ **初步分析**：  
博弈论中的SG函数就像每个游戏状态的“胜负身份证”——每个子游戏（比如本题中的一丛蒲公英）都有一个SG值，整个游戏的胜负由所有子游戏SG值的**异或结果**决定：如果总异或值非零，先手必赢；否则后手必赢。  

回到本题，每丛蒲公英的分组规则形成一个“子游戏”，我们需要计算每个子丛的SG值，再求总异或。核心难点是**如何快速计算大数s_i的SG值**（因为s_i可达1e10，不能逐次递归）。题解的关键思路是：通过观察分组的单调性（每组大小不增），推导出SG值的数学规律——用**最长相等前缀的奇偶性**判断SG是a₁还是a₁-1（a₁是第一组的大小），从而O(1)计算每个s_i的SG。  

可视化设计思路：我们用**像素风格的“蒲公英战场”**演示——每个蒲公英丛是一个彩色像素块，SG值用颜色深浅表示；总异或值用顶部的“胜负水晶”显示（亮色表示先手赢，暗色表示后手赢）。动画会高亮当前选择的丛，展示吹散操作后SG的变化，并用“叮”的音效提示关键操作，“胜利音效”庆祝先手赢的情况。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了以下优质题解，帮你快速抓住核心：
</eval_intro>

**题解一：(来源：VinstaG173)**  
* **点评**：这份题解直接点出SG函数的核心规律，用简洁的数学推导得出“SG值为a₁或a₁-1”的结论，代码中的`sg`函数仅用一行公式计算，效率极高。美中不足的是对规律的证明稍显简略，但适合已经理解SG函数的学习者快速应用。

**题解二：(来源：Iris_Aurora)**  
* **点评**：这是最适合入门的题解！作者详细推导了“最长相等前缀len的奇偶性决定SG值”的过程，还给出了len的计算方法，逻辑链完整。代码中的`SG`函数清晰实现了这一逻辑，变量命名规范（如`len`表示相等前缀长度），可读性强，尤其适合新手理解“如何将数学规律转化为代码”。

**题解三：(来源：OldDriverTree)**  
* **点评**：作者用“人话”解释了SG函数的递归定义，并用归纳法证明规律，非常适合夯实基础。代码中的`power`函数（模逆元）和`mul`函数（大整数乘法）实现得很规范，处理了题目中的大数模运算问题，实践价值高。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“突破三个难点”，我们逐一拆解：
</difficulty_intro>

1. **难点1：SG函数的递归定义与总游戏的胜负条件**  
   * **分析**：SG函数的核心是“mex（最小非负整数不存在于后继状态的SG集合）”，总游戏的SG是子游戏SG的异或。很多学习者容易混淆“子游戏”和“总游戏”的关系——本题中每丛蒲公英是独立的子游戏，总游戏的胜负由它们的异或结果决定。  
   * 💡 **学习笔记**：总SG非零→先手赢，否则后手赢，这是博弈论的核心结论！

2. **难点2：大数s_i的SG函数快速计算**  
   * **分析**：s_i可达1e10，不能用递归或迭代计算每个分组的SG。题解的关键是发现“分组大小a₁≥a₂≥…”的单调性，进而推导出“SG值由a₁和最长相等前缀的奇偶性决定”的规律，将时间复杂度从O(log s_i)降到O(1)。  
   * 💡 **学习笔记**：面对大数问题，先找数学规律，再用公式计算！

3. **难点3：概率计算中的模逆元**  
   * **分析**：胜率是分数（如1/(n-cnt)或1/a₁），需要用模逆元转换为整数（模20190816170251）。比如，求1/x的逆元等价于求x^(mod-2)（费马小定理，因为mod是质数）。  
   * 💡 **学习笔记**：模运算中除法用逆元，质数模数下逆元是x^(mod-2)！


### ✨ 解题技巧总结
- **博弈论技巧**：将复杂游戏拆分为独立子游戏，用SG函数异或判断胜负；
- **大数处理**：通过单调性和数学规律将O(n)问题转化为O(1)；
- **模运算技巧**：费马小定理求逆元，处理分数模运算。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，帮你建立整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合Iris_Aurora和OldDriverTree的代码，保留最清晰的逻辑，适合入门学习。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;
    typedef long long ll;
    const __int128 mod = 20190816170251;

    ll id, n, p, q, Xor = 0, cnt = 0, ans = 0;
    ll s[300005];

    // 快速幂求逆元（费马小定理）
    ll qpow(ll a) {
        ll res = 1;
        ll b = mod - 2;
        while (b) {
            if (b & 1) res = (__int128)res * a % mod;
            a = (__int128)a * a % mod;
            b >>= 1;
        }
        return res;
    }

    // 计算单个s的SG值
    ll SG(ll x) {
        ll a1 = (__int128)x * p / q; // 第一组大小
        if (!a1) return 0;
        // 计算最长相等前缀len
        ll len = (__int128)x * p / ((p + q) * a1) + 1;
        return len % 2 ? a1 : a1 - 1; // 奇数→a1，偶数→a1-1
    }

    int main() {
        cin >> id >> n;
        for (ll i = 1; i <= n; ++i) cin >> s[i];
        // 处理sigma的不同情况
        if (id == 1) p = 804737854124365016, q = 1000000000000000000;
        else if (id == 2) p = 546410161513775458, q = 1000000000000000000;
        else if (id == 3) p = 618033988749894848, q = 1000000000000000000;
        else cin >> p >> q;

        // 计算总SG
        for (ll i = 1; i <= n; ++i) Xor ^= SG(s[i]);
        if (Xor == 0) { cout << 0 << endl; return 0; }

        // 计算胜率
        for (ll i = 1; i <= n; ++i) {
            ll a1 = (__int128)s[i] * p / q;
            if (!a1) { cnt++; continue; }
            if ((Xor ^ SG(s[i])) <= a1) {
                ans = (ans + qpow(a1)) % mod;
            }
        }
        ans = (__int128)ans * qpow(n - cnt) % mod;
        cout << (ll)ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  1. **输入处理**：读取id（sigma的类型）、n（蒲公英丛数）、s数组（每丛的朵数）；  
  2. **SG计算**：用`SG`函数计算每个s_i的SG值，求总异或`Xor`；  
  3. **胜率计算**：遍历每丛，若该丛的“修正SG”（总异或^该丛SG）≤a1，则累加其概率（逆元），最后乘以总丛数的逆元得到胜率。


<code_intro_selected>
接下来剖析优质题解的核心片段，帮你抓住“关键代码为什么这么写”：
</code_intro_selected>

**题解二：(来源：Iris_Aurora)**  
* **亮点**：用“最长相等前缀len的奇偶性”直接计算SG，逻辑清晰。
* **核心代码片段**：
    ```cpp
    ll SG(ll x){
        ll num=(__int128)x*p/q; // a1，第一组大小
        if(!num) return 0;
        ll len=(__int128)x*p/(p+q)/num+1; // 最长相等前缀长度
        return len&1 ? num : num-1; // 奇数→num，偶数→num-1
    } 
    ```
* **代码解读**：  
  1. `num`是第一组的大小（a1=⌊σx⌋）；  
  2. `len`是“连续相等的分组前缀长度”（比如a1=a2=a3，则len=3）；  
  3. 用`len&1`判断奇偶性：奇数说明SG是a1，偶数是a1-1——这是作者推导的核心规律！
* 💡 **学习笔记**：把数学规律转化为代码时，尽量用“位运算”（如`&1`）代替“取模”，效率更高！

**题解三：(来源：OldDriverTree)**  
* **亮点**：清晰实现了“模逆元”和“大整数乘法”，处理了题目中的大数问题。
* **核心代码片段**：
    ```cpp
    int mul(int x,int y) {
        return (__int128)x*y%mod; // 用__int128避免溢出
    }
    int power(int a,int b=mod-2) {
        int res=1;
        while(b) {
            if(b&1) res=mul(res,a);
            a=mul(a,a),b>>=1;
        }
        return res;
    }
    ```
* **代码解读**：  
  1. `mul`函数用`__int128`存储中间结果，避免两个大整数相乘溢出；  
  2. `power`函数用快速幂计算逆元（因为mod是质数，逆元是a^(mod-2)）。
* 💡 **学习笔记**：处理大数模运算时，`__int128`是C++的“秘密武器”，能轻松解决溢出问题！


## 5. 算法可视化：像素动画演示

<visualization_intro>
我设计了一个**8位像素风的“蒲公英博弈模拟器”**，用游戏化方式展示SG函数的计算和胜负判断，帮你直观理解：
</visualization_intro>

### 一、动画主题与风格
- **主题**：《蒲公英战场》——你是“清”，需要选择一丛蒲公英吹散，目标是让总SG变为0（后手输）；  
- **风格**：FC红白机风格（8位像素、低饱和度色彩），背景音乐用《蒲公英的约定》的8位版，轻松复古。


### 二、核心演示步骤
1. **初始化场景**：  
   - 屏幕左侧是**蒲公英丛区**：每个丛用不同颜色的像素块表示，下方显示其SG值（如红色块→SG=3）；  
   - 屏幕右侧是**控制面板**：有“单步执行”“自动播放”按钮，以及“速度滑块”（控制动画快慢）；  
   - 顶部中央是**总SG水晶**：亮色（如黄色）表示总SG非零（先手赢），暗色（灰色）表示总SG为0（后手赢）。

2. **算法演示流程**：  
   - **步骤1**：点击“开始”，总SG水晶亮起（黄色），表示先手有赢的可能；  
   - **步骤2**：鼠标 hover 到某丛蒲公英（如红色块），右侧显示其a1（第一组大小）和“修正SG”（总SG^该丛SG）；  
   - **步骤3**：点击该丛，播放“吹散动画”——红色块减少若干像素（表示吹散a1中的部分），总SG水晶变为“修正SG”的值；  
   - **步骤4**：若总SG变为0（水晶变灰），播放“胜利音效”（8位版“叮~叮~”），并弹出“清赢了！”的像素提示；  
   - **步骤5**：点击“重置”，回到初始状态，可重新选择其他丛。


### 三、交互与游戏化设计
- **单步/自动**：支持“单步执行”（每点击一次走一步）和“自动播放”（按滑块速度连续执行）；  
- **音效反馈**：  
  - 点击蒲公英丛：播放“咻”的吹散音效；  
  - 总SG变为0：播放“胜利旋律”；  
  - 选择无效丛（a1=0）：播放“错误提示音”（短促的“哔”）；  
- **关卡设计**：设置3个“小关卡”（比如s_i=10、s_i=100、s_i=1e5），完成每个关卡可获得“蒲公英徽章”，增加成就感！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会SG函数后，你可以挑战以下相似问题，巩固博弈论思维：
</similar_problems_intro>

### 一、通用思路迁移
SG函数适用于** impartial game（公平组合游戏）**——即双方玩家的操作选项仅依赖当前状态，与玩家无关。比如：
1. 取石子游戏（如Nim游戏）；
2. 棋盘游戏（如翻硬币游戏）；
3. 路径游戏（如迷宫中的移动游戏）。


### 二、洛谷推荐练习
1. **洛谷 P1290 欧几里得的游戏**  
   * 🗣️ **推荐理由**：经典的Nim游戏变种，需要计算每个状态的SG值，帮你巩固“子游戏异或”的核心思想。
   
2. **洛谷 P2197 【模板】Nim游戏**  
   * 🗣️ **推荐理由**：Nim游戏的模板题，直接应用“总SG非零则先手赢”的结论，帮你熟悉基础博弈论模型。
   
3. **洛谷 P4018 Roy&October之取石子**  
   * 🗣️ **推荐理由**：需要推导SG函数的规律（类似本题的“大数SG计算”），帮你练习“将数学规律转化为代码”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中藏着作者的“踩坑经验”，帮你少走弯路：
</insights_intro>

> **参考经验 (来自 Iris_Aurora)**：“我最初卡在‘如何计算len’上，后来发现‘len满足⌊σ(x-len*a1)⌋<a1’，通过代数变形得到了len的公式。”  
> **点评**：这提醒我们——面对“求满足某个条件的最大值”问题，先写出条件的数学表达式，再通过变形推导公式，比暴力枚举高效得多！


<conclusion>
本次分析帮你掌握了“博弈论中的SG函数应用”，重点是“快速计算大数SG值”和“模逆元处理概率”。记住：博弈论的核心是“拆分子游戏→算SG→异或判胜负”，而大数问题的解决关键是“找数学规律”。下次遇到博弈题，先想“能不能拆成子游戏？每个子游戏的SG怎么算？”，你会发现问题变得简单多了！💪
</conclusion>

---
处理用时：66.90秒
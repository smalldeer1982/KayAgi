# 题目信息

# [THUPC 2019] 不等式

## 题目描述

> 时光回到 2017 年 6 月 7 日。午后，阳光正好。
>
> 现在的你，在考场中笔耕不辍。在刷刷声中，你填写着交给从前和未来的自己的答卷。
> 
> 像无数次训练过的那样，你直接跳到了这张数学试卷的最后一道大题，二选一的题目直接选择了后者。快速地掠过了题目描述，紧缩的眉头渐渐放松。
> 
> 「稳了。」
>
> 你一刻也不敢停留，又向你的梦想靠近了一小步。

已知两个 $n$ 维实向量 $\vec{a}=(a_1,a_2,\dots,a_n),\vec{b}=(b_1,b_2,\dots,b_n)$，定义 $n$ 个定义域为 $\mathbb{R}$ 函数 $f_1,f_2,\dots,f_n$：

$$f_k(x)=\sum_{i=1}^{k} \lvert a_ix+b_i\rvert \quad (k=1,2,\dots,n)$$

现在，对于每个 $k=1,2,\dots,n$，试求 $f_k$ 在 $\mathbb{R}$ 上的最小值。可以证明最小值一定存在。

## 说明/提示

### 样例解释

$f_1(x)=\lvert x+1\rvert$，显然在 $x=-1$ 处取到最小值 $0$；

$f_2(x)=\lvert x+1\rvert +\lvert x+2\rvert$，可以证明其在 $[-2,-1]$ 中任意位置取到最小值 $1$。

##### 后记

后来，全国三卷的考生们又回想起了被参数方程支配的恐惧。

##### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。

## 样例 #1

### 输入

```
2
1 1
1 2```

### 输出

```
0.00000
1.00000```

# AI分析结果


# 💡 Kay的C++算法解析：[THUPC 2019] 不等式 深入学习指南 💡

> 今天我们来一起分析“不等式”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过像素动画演示，我们将直观感受算法执行过程！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数据结构应用`与`数学优化`

🗣️ **初步分析**：
> 这道题要求对每个k求∑|aᵢx+bᵢ|的最小值，本质是**动态带权中位数**问题。想象你在数轴上放置不同重量的点（权重|aᵢ|，位置-bᵢ/aᵢ），找一点使总距离最小，就像在杠杆上找平衡点。解题关键：
> - 将|aᵢx+bᵢ|转化为|aᵢ|·|x + bᵢ/aᵢ|
> - 快速维护动态点集并找到权重中位数
> - 高效计算中位数位置的总距离和
>
> **可视化设计**：采用8位像素风格数轴（类似FC游戏），点用不同大小像素块表示权重。算法执行时：
> - 新点加入时播放"放置"音效
> - 中位数位置高亮闪烁并随权重移动
> - 距离和实时显示在侧边栏
> - 控制面板支持单步执行/调速（0.5x-2x）

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性和算法效率维度，我精选了3篇≥4星的题解：
</eval_intro>

**题解一 (来源：hehezhou)**
* **点评**：采用无旋Treap直接维护带权点集，动态求中位数和距离和。亮点在于：
  - 平衡树实现避免了离散化，直接处理浮点数
  - 代码模块化清晰（分裂/合并操作独立封装）
  - 实时计算距离和公式简洁高效（`中位值*左侧权重和 - 左侧位置和 + 右侧位置和 - 中位值*右侧权重和`）
  - 实践价值高，时间复杂度稳定在O(n log n)

**题解二 (来源：devout)**
* **点评**：通过离散化+线段树实现，亮点在于：
  - 离散化处理避免浮点数精度问题
  - 线段树同时维护权重和与位置和
  - 详细处理了aᵢ=0的特殊情况
  - 代码结构清晰，注释完整，适合竞赛参考

**题解三 (来源：TheLostWeak)**
* **点评**：在线段树实现中创新性避免浮点数比较：
  - 交叉相乘比较分数大小（bᵢ/aᵢ vs bⱼ/aⱼ → bᵢaⱼ vs bⱼaᵢ）
  - 动态维护离散化映射
  - 代码高度优化（仅200行）
  - 空间效率突出（无额外存储分数值）

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个核心难点，结合优质题解策略如下：
</difficulty_intro>

1.  **关键点1：带权中位数的动态维护**
    * **分析**：当加入新点(-bᵢ/aᵢ, |aᵢ|)时，中位数位置可能移动。优质题解均采用分层数据结构（平衡树/线段树）维护有序点集，通过权重累计快速定位中位点。
    * 💡 **学习笔记**：中位点满足左侧权重和 ≥ 总权重/2

2.  **关键点2：距离和的高效计算**
    * **分析**：确定中位点p后，需快速计算∑|p - xᵢ|·wᵢ。题解策略：
      - 预处理左侧权重和W_left、位置和S_left
      - 公式：`p*W_left - S_left + (S_right - p*W_right)`
    * 💡 **学习笔记**：分离中位点左右计算是优化关键

3.  **关键点3：特殊情况的处理**
    * **分析**：当aᵢ=0时，|aᵢx+bᵢ|退化为|bᵢ|（常数项）。需独立累加这些常数（如题解2的`add`变量），同时确保中位数计算不受影响。
    * 💡 **学习笔记**：边界条件处理能力体现编程严谨性

### ✨ 解题技巧总结
<summary_best_practices>
通用解题策略总结：
</summary_best_practices>
- **问题转化技巧**：将绝对值函数转化为数轴距离模型
- **数据结构选择**：动态查询问题优先考虑分层结构（树状数组/线段树/平衡树）
- **避免浮点误差**：离散化或交叉相乘比较分数
- **模块化设计**：将中位点查询与距离计算分离

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是基于题解优化的通用实现，融合了离散化与线段树方案：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合题解2与题解3优点，离散化处理+线段树维护
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N = 5e5+5;

struct SegTree {
    LL cnt[N<<2];     // 权重和
    double sum[N<<2]; // 位置和
    void update(int x, int l, int r, int pos, LL w, double v) {
        if (l == r) {
            cnt[x] += w;
            sum[x] += w * v;
            return;
        }
        int mid = (l+r)>>1;
        if (pos <= mid) update(x<<1, l, mid, pos, w, v);
        else update(x<<1|1, mid+1, r, pos, w, v);
        cnt[x] = cnt[x<<1] + cnt[x<<1|1];
        sum[x] = sum[x<<1] + sum[x<<1|1];
    }
    LL query_cnt(int x, int l, int r, int ql, int qr) {
        if (ql > qr) return 0;
        if (ql<=l && r<=qr) return cnt[x];
        int mid = (l+r)>>1;
        LL res = 0;
        if (ql <= mid) res += query_cnt(x<<1, l, mid, ql, qr);
        if (qr > mid) res += query_cnt(x<<1|1, mid+1, r, ql, qr);
        return res;
    }
    double query_sum(int x, int l, int r, int ql, int qr) {
        if (ql > qr) return 0;
        if (ql<=l && r<=qr) return sum[x];
        int mid = (l+r)>>1;
        double res = 0;
        if (ql <= mid) res += query_sum(x<<1, l, mid, ql, qr);
        if (qr > mid) res += query_sum(x<<1|1, mid+1, r, ql, qr);
        return res;
    }
    int kth(int x, int l, int r, LL k) {
        if (l == r) return l;
        int mid = (l+r)>>1;
        if (k <= cnt[x<<1]) return kth(x<<1, l, mid, k);
        return kth(x<<1|1, mid+1, r, k - cnt[x<<1]);
    }
} seg;

int n, a[N], b[N];
double pos[N], lsh[N];
int main() {
    scanf("%d", &n);
    for (int i=1; i<=n; i++) scanf("%d", a+i);
    for (int i=1; i<=n; i++) scanf("%d", b+i);
    
    // 离散化预处理
    for (int i=1; i<=n; i++) {
        if (a[i]) {
            pos[i] = -1.0 * b[i] / a[i];
            lsh[i] = pos[i];
        }
    }
    sort(lsh+1, lsh+n+1);
    int sz = unique(lsh+1, lsh+n+1) - lsh - 1;
    
    LL total_weight = 0;
    double add = 0; // 处理a[i]=0的情况
    
    for (int i=1; i<=n; i++) {
        if (a[i] == 0) {
            add += abs(b[i]);
        } else {
            int idx = lower_bound(lsh+1, lsh+sz+1, pos[i]) - lsh;
            seg.update(1, 1, sz, idx, abs(a[i]), pos[i]);
            total_weight += abs(a[i]);
        }
        
        int mid_idx = seg.kth(1, 1, sz, (total_weight + 1) / 2);
        double mid_val = lsh[mid_idx];
        
        LL left_cnt = seg.query_cnt(1, 1, sz, 1, mid_idx-1);
        double left_sum = seg.query_sum(1, 1, sz, 1, mid_idx-1);
        LL right_cnt = seg.query_cnt(1, 1, sz, mid_idx+1, sz);
        double right_sum = seg.query_sum(1, 1, sz, mid_idx+1, sz);
        
        double ans = mid_val * left_cnt - left_sum 
                   + right_sum - mid_val * right_cnt
                   + add;
        printf("%.10f\n", ans);
    }
    return 0;
}
```
* **代码解读概要**：
  > 1. **离散化处理**：将-bᵢ/aᵢ映射到整数坐标
  > 2. **线段树维护**：叶子节点存储位置值，非叶节点维护区间权重和与位置和
  > 3. **动态查询**：每次加入新点后：
  >    - 用kth操作定位中位点
  >    - 分别查询左右两侧的权重和与位置和
  >    - 套用距离和公式计算最小值

---
<code_intro_selected>
各题解核心片段解析：
</code_intro_selected>

**题解一 (hehezhou)**
* **亮点**：平衡树直接维护浮点数，避免离散化
* **核心代码片段**：
```cpp
void insert(double pos, int weight) {
    int x, y;
    split(root, pos, x, y); // 按位置分裂
    root = merge(merge(x, new_node(pos, weight)), y);
}
double query_median() {
    int mid_rank = (total_weight + 1) / 2;
    return find_kth(root, mid_rank); // 基于权重的查找
}
```
* **代码解读**：
  > 1. `split`和`merge`实现无旋Treap的核心操作
  > 2. 每个节点存储子树权重和，实现O(h)的kth查询
  > 3. 动态维护total_weight（总权重）
  > *为何不记录左右子树和？* 因Treap本身具有堆性质，通过子树和实现高效查询
* 💡 **学习笔记**：平衡树适合动态性强的场景，但常数较大

**题解二 (devout)**
* **亮点**：严谨处理aᵢ=0和负值情况
* **核心代码片段**：
```cpp
void solve() {
    for (int i=1; i<=n; i++) {
        if (a[i] == 0) add += abs(b[i]);
        else {
            double x = -1.0 * b[i] / a[i];
            int pos = lower_bound(lsh, lsh+sz, x) - lsh;
            update(1, 1, sz, pos, abs(a[i]), x); // 线段树更新
        }
        // ...中位查询和距离计算
    }
}
```
* **代码解读**：
  > 1. 先处理aᵢ符号：`if(a[i]<0) a[i]=-a[i], b[i]=-b[i]`
  > 2. 独立累加常数项`add`
  > 3. 离散化映射确保位置有序
  > *为什么需要离散化？* 浮点数无法直接作为数组下标
* 💡 **学习笔记**：离散化是处理浮点问题的常用技巧

**题解三 (TheLostWeak)**
* **亮点**：避免浮点数比较的创新方法
* **核心代码片段**：
```cpp
bool cmp(int i, int j) {
    // 交叉相乘避免除法
    return (LL)b[i]*a[j] < (LL)b[j]*a[i]; 
}
void discrete() {
    sort(id+1, id+n+1, cmp);
    for (int i=1; i<=n; ) {
        int j = i;
        while (j<=n && !cmp(id[i],id[j]) && !cmp(id[j],id[i])) 
            j++;
        // 相同分数映射同位置
    }
}
```
* **代码解读**：
  > 1. 比较时用`bᵢ*aⱼ < bⱼ*aᵢ`替代`bᵢ/aᵢ < bⱼ/aⱼ`
  > 2. 对相同分数合并处理
  > *为何能避免精度问题？* 整数运算无精度损失
* 💡 **学习笔记**：交叉相乘是处理分数比较的黄金准则

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为直观展示带权中位数算法，我设计了8位像素风格的"数轴探险家"动画方案：
</visualization_intro>

* **动画演示主题**：像素探险家在数轴上放置带权重点，寻找平衡点

* **核心演示内容**：
  - 数轴下方显示当前点集（位置和权重）
  - 实时计算并显示当前中位点位置和距离和
  - 动态展示新点加入对中位点的影响

* **设计思路**：采用FC红白机风格配色（4色调色板），通过不同大小像素块表示权重，类比《俄罗斯方块》的方块堆积，帮助理解"权重"概念。

* **动画帧步骤**：
  1. **初始化**：
     - 16px宽的数轴横贯屏幕
     - 控制面板：播放/暂停、单步、速度滑块（0.5x-2x）
     - 8-bit背景音乐（循环芯片音乐）

  2. **加入新点**：
     ```python
     for i in range(1, n+1):
        放置点(-b_i/a_i, |a_i|)  # 位置映射到数轴坐标
        播放"放置"音效(音调随|a_i|变化)
        if a_i==0: 显示"+|b_i|"特效
     ```

  3. **中位数计算**：
     - 数轴上高亮当前中位点（黄色闪烁）
     - 显示权重累计过程（进度条从左向右填充）
     - 中位点移动时播放"滑动"音效

  4. **距离和计算**：
     - 左侧距离：红色线段 + 数值标签
     - 右侧距离：蓝色线段 + 数值标签
     - 总距离：绿色显示在顶部

  5. **游戏化元素**：
     - 每10个点为1关，过关播放胜利音效
     - 连续正确计算奖励连击分
     - "AI演示模式"：自动以最佳速度展示全过程

* **关键交互**：
  - 鼠标悬停显示点信息（a_i, b_i）
  - 拖动调速滑块实时改变演示速度
  - 空格键单步执行

<visualization_conclusion>
通过像素化动态演示，抽象的中位数算法转化为可视化的平衡点寻找过程，配合游戏化元素提升学习趣味性。
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握带权中位数思想后，可解决以下相似问题：
</similar_problems_intro>

* **通用思路迁移**：
  带权中位数模型适用于：
  1. 最优选址问题（如仓库位置选择）
  2. 数据流中位数维护
  3. 加权绝对误差最小化

* **练习推荐 (洛谷)**：
  1. **P1168 中位数** 
     * 🗣️ 推荐理由：动态中位数基础练习，巩固数据结构应用
  2. **P3870 [TJOI2010]分金币** 
     * 🗣️ 推荐理由：带权中位数变形，需要结合前缀和优化
  3. **P1471 方差** 
     * 🗣️ 推荐理由：拓展到二次函数最小值问题，培养数学推导能力

-----

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验极具参考价值：
</insights_intro>

> **参考经验 (来自 devout)**：
> "处理a_i=0时忘记加绝对值，导致WA多次。建议对特殊样例：a=[0], b=[-5]单独测试"

> **点评**：边界条件测试是避免竞赛失分的关键，建议：
> 1. 单独测试a_i=0的边界情况
> 2. 验证负权重处理逻辑
> 3. 对全零输入进行测试

<conclusion>
本次分析揭示了绝对值函数最小化的核心思想——带权中位数模型。通过数据结构优化和数学转化，抽象问题迎刃而解。记住：编程能力=知识储备×实践量，继续挑战新问题吧！🚀
</conclusion>
```

---
处理用时：178.57秒
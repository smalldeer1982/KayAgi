# 题目信息

# [THUPC 2021 初赛] 麻将模拟器

## 题目描述

麻将是一种休闲的四人博弈游戏。你的任务是写一个模拟器来模拟一局游戏的进程。

接下来将详细介绍游戏规则和每个玩家的决策。注意：为了实现方便和使游戏更加有趣味，这里介绍的规则和主流的几种麻将规则均略有不同。

**基础规则：**

- 一副麻将由 $148$ 张牌组成，其中包含 $37$ 种不同的牌，每种各 $4$ 张。
- 这 $37$ 种牌分别是：一万到九万（`1M ~ 9M`）、一筒到九筒（`1P ~ 9P`）、一索到九索（`1S ~ 9S`）、东（`E`）、南（`S`）、西（`W`）、北（`N`）、白（`B`）、发（`F`）、中（`Z`），以及 $3$ 种特殊牌：跳过（`PASS`），反向（`REVERSE`），双重回合（`DOUBLE`）。
- 游戏共有 $4$ 名玩家，不妨称其为 `A`，`B`，`C`，`D`。
- 游戏开始前，将 $148$ 张牌随机洗乱后摆成一排，称为牌堆。此后玩家摸牌一定是从牌堆中摸取最靠前的一张牌。
- 从 `A` 开始按照 `ABCDABCD...` 的顺序，每人依次从牌堆中摸一张牌，直到每人都有 $13$ 张牌，这些牌组成每个玩家的手牌。
- 再从 `A` 开始按照 `ABCDABCD...` 的顺序，依次进入每人的回合：
- 在一个回合中，玩家先摸一张牌进入自己的手牌，再从自己的手牌中打出一张牌。
- 依次进行直到有人和牌或者无牌可摸时游戏结束。

**特殊牌：**

- 跳过（`PASS`）：在出牌时打出这张牌，可以指定一名玩家，跳过他的下一个回合。
- 反向（`REVERSE`）：在出牌时打出这张牌，反转进行回合的顺序，即由 `ABCDABCD...` 变为 `ADCBADCB...` 或由 `ADCBADCB...` 变为 `ABCDABCD...`。出牌后即按照反转后的顺序，从出牌者原先的上家开始进行回合。
- 双重回合（`DOUBLE`）：在出牌时打出这张牌，该名玩家立即进入一个额外的回合。

**牌型：**&#8203;有如下 $3$ 种牌型：

- 顺子：$3$ 张数字连续的万，或 $3$ 张数字连续的筒，或 $3$ 张数字连续的索，如 `4P 5P 6P`。
- 刻子：$3$ 张完全一样的非特殊牌，如 `B B B`。
- 对子：$2$ 张完全一样的非特殊牌，如 `9M 9M`。

**吃、碰：**

- 当一名玩家打出一张非特殊牌时，其他玩家可以进行吃或碰：
- 吃（`CHOW`）：当打出的这张牌跟自己的手牌中的某两张牌能组成一个顺子时，可以将手牌中能与之组成顺子的其余两张牌取出，与这张牌一起摆在旁边。
- **注意只有上一名出牌玩家的下家（按当前顺序原本应在下一个进行回合的玩家）才能吃。**
- 碰（`PONG`）：当打出的这张牌跟自己的手牌中的某两张牌能组成一个刻子时，可以将手牌中能与之组成刻子的其余两张牌取出，与这张牌一起摆在旁边。
- 碰没有吃的上述限制，任意其他玩家都能碰。
- 如果既有玩家能吃又有玩家能碰，则碰优先于吃。
- 吃（或碰）不是强制性的，也就是说玩家满足吃（或碰）的条件时，可以选择不吃（或碰）。
- 吃和碰统称为副露。为方便起见，不将副露视为手牌的一部分。
- 在任意一名玩家吃（或碰）后，跳过从上一名出牌的玩家到这名玩家之间的所有玩家的回合，直接从当前玩家开始进行新的回合。但该玩家在这一回合中**跳过摸牌直接出牌**，在下一回合（如果没有吃碰的话）恢复正常。
- **注意在本规则中不能杠。**

**胡牌规则：**

- 称一名玩家的牌能和，当且仅当满足如下条件：
  - 牌数为 $14 - 3 n$，其中 $n$ 为该玩家副露（即吃碰）的个数；
  - 这些牌中无特殊牌；
  -  这些牌能够被分成 $(5 - n)$ 组，其中 $(4 - n)$ 组均为 $3$ 张且均为顺子或刻子，其余一组为 $2$ 张且为对子。
- **注意本规则中不支持七对子、十三幺、全不靠等特殊的和牌规则。**
- 另外，定义一组包含 $13 - 3 n$ 张牌的手牌的和牌距离为最小的 $x$，使得向这些牌中加入特定的 $x$ 张牌，再去掉 $x - 1$ 张手牌后，每种牌仍不超过 $4$ 张且能和。
- 定义一组包含 $14 - 3 n$ 张牌的手牌的和牌距离为最小的 $x$，使得向这些牌中加入特定的 $x$ 张牌，再去掉 $x$ 张手牌后，每种牌仍不超过 $4$ 张且能和。
- 特别地，一手能和的牌的和牌距离为 $0$；和牌距离为 $1$ 的牌称为听牌。
- 注意这里的“**每种牌仍不超过** $\boldsymbol{4}$ **张**”的限制：如果一手牌是 `1M 1M 1M 1M` 且副露数为 $3$，再向其中加入一张 `1M` 就能和，但是由于有 $5$ 张 `1M` 所以是不被允许的，故不认为其和牌距离为 $1$。
- 但如果一手牌是 `1M` 且副露数为 $4$，但是曾进行过一次 `1M 1M 1M` 的碰，仍然认为其和牌距离为 $1$（虽然缺的这张 `1M` 永远也等不到）。

**终局：**

- 荣和（`RON`）：当一名玩家出牌后，某名其他玩家的手牌加上这张牌能和，则称这名玩家荣和。荣和优先于吃碰。
- 如果有多名玩家同时达到荣和的标准，规定只有从上一名出牌玩家开始，沿回合进行顺序的第一名能荣和的玩家才能荣和，其余玩家荣和不了，称这种情况为截和。
- 自摸（`SELFDRAWN`）：一名玩家摸牌后其手牌能和，称这名玩家自摸。
- 一旦有一名玩家荣和或自摸，游戏立即结束，该名玩家胜利。
- 如果某名玩家摸牌时发现牌堆中已经无牌可摸，游戏立即结束，称此种情况为流局。

**出牌策略：**&#8203;每名玩家的出牌策略相同且固定：

- 出牌时，若手里有特殊牌一定会优先出，且如果有多种特殊牌，按照 `PASS`、`REVERSE`、`DOUBLE` 的优先顺序；出的 `PASS` 一定指定下家。
- 出牌时若手里没有特殊牌，则会对于每一种可能的出牌方法计算出完牌后的和牌距离，选择和牌距离最小的一种方案。如果有并列最小，按照 `Z`，`F`，`B`，`N`，`W`，`S`，`E`，`9S`，`8S`，……，`1S`，`9P`，……，`1P`，`9M`，……，`1M` 的优先顺序出牌。
- 同一个人能吃且能碰时，优先考虑碰；因为每种牌只有 $4$ 张所以不会有两名玩家同时可以碰的情况；当且仅当吃（或碰）后能使得和牌距离严格减小才会去吃（或碰）；如果有多种吃的方案使得和牌距离严格减小，优先选择数字较大的方案。
-  能荣和一定荣和（除非被截和），能自摸一定自摸，不会拒和（能和时故意选择不和）。

## 说明/提示

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。

## 样例 #1

### 输入

```
8M
Z
E
9P
3P
9S
5P
W
3M
8P
DOUBLE
5P
Z
2P
3M
8S
2S
5P
5M
E
6M
9S
6P
5S
7M
4S
3S
6M
3S
2M
9M
5S
Z
7P
5P
8M
3M
F
7M
2S
N
4P
3S
S
PASS
1P
6S
3P
9P
9S
4M
8P
N
Z
N
5M
DOUBLE
REVERSE
S
3P
4M
4S
1S
PASS
4P
6S
7S
7P
6S
9M
REVERSE
3P
7P
DOUBLE
B
9P
4S
5S
7S
7S
7P
6S
9S
B
9M
S
F
2P
1P
PASS
9P
DOUBLE
4P
PASS
5S
2M
2P
6P
W
1M
8S
REVERSE
8M
6M
5M
F
4M
F
8P
2S
1M
2M
3M
7M
3S
B
7S
1S
REVERSE
8P
6M
4S
2M
B
1M
S
6P
5M
W
7M
2S
8S
8M
1S
4P
E
4M
9M
1M
8S
1S
1P
2P
1P
W
6P
N
E
```

### 输出

```
A IN 8M
B IN Z
C IN E
D IN 9P
A IN 3P
B IN 9S
C IN 5P
D IN W
A IN 3M
B IN 8P
C IN DOUBLE
D IN 5P
A IN Z
B IN 2P
C IN 3M
D IN 8S
A IN 2S
B IN 5P
C IN 5M
D IN E
A IN 6M
B IN 9S
C IN 6P
D IN 5S
A IN 7M
B IN 4S
C IN 3S
D IN 6M
A IN 3S
B IN 2M
C IN 9M
D IN 5S
A IN Z
B IN 7P
C IN 5P
D IN 8M
A IN 3M
B IN F
C IN 7M
D IN 2S
A IN N
B IN 4P
C IN 3S
D IN S
A IN PASS
B IN 1P
C IN 6S
D IN 3P
A IN 9P
B IN 9S
C IN 4M
D IN 8P
A IN N
A OUT PASS B
C IN Z
C OUT DOUBLE
C IN N
C OUT Z
A PONG Z Z Z
A OUT 9P
B CHOW 7P 8P 9P
B OUT Z
C IN 5M
C OUT N
A PONG N N N
A OUT 3P
B CHOW 3P 4P 5P
B OUT F
C IN DOUBLE
C OUT DOUBLE
C IN REVERSE
C OUT REVERSE
B IN S
B OUT S
A IN 3P
A OUT 3P
D IN 4M
D OUT W
C IN 4S
C OUT E
B IN 1S
B OUT 4S
A RON
A WIN
```

# AI分析结果


# 💡 Kay的C++算法解析：麻将模拟器 深入学习指南 💡

<introduction>
今天我们来分析“麻将模拟器”这道C++编程题。这道题来自THUPC 2021初赛，要求模拟一局包含特殊牌（PASS、REVERSE、DOUBLE）的麻将游戏。本指南将帮助你理解复杂的游戏规则实现，掌握动态规划计算和牌距离的技巧，并学会处理多玩家状态交互。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划(DP)` 与 `状态模拟`

🗣️ **初步分析**：
> 这道题的核心在于**高效计算和牌距离**（类似麻将向听数）和**精确模拟游戏流程**。DP用于计算当前手牌达成和牌所需的最小操作数，而状态机则处理吃、碰、特殊牌等复杂交互。
   - **核心难点**：和牌距离计算需考虑顺子、刻子、雀头的组合，状态空间庞大；游戏流程需处理多玩家状态转移和优先级判断
   - **可视化设计**：在像素动画中将高亮DP状态转移过程（如顺子/刻子形成），用不同颜色区分手牌状态，并为特殊牌添加特效
   - **复古游戏化**：采用FC红白机风格的8位像素UI，吃碰操作配“叮”声，和牌时播放胜利音效，牌桌以网格展示实时状态

---

## 2. 精选优质题解参考

<eval_intro>
我根据思路清晰度、代码规范性和算法效率，精选以下3份优质题解：

**题解一：FjswYuzu (43赞)**
* **点评**：这份题解采用**面向对象封装**，将麻将逻辑封装在`MahjongGame`类中。DP状态设计精妙（五维数组处理顺子需求），吃碰判断通过预计算距离差实现。代码模块化程度高，变量命名规范（如`brickApp`记录牌型数量），边界处理严谨。特别亮点是**状态压缩技巧**降低DP复杂度。

**题解二：liuzhangfeiabc (37赞)**
* **点评**：作者作为出题人详解规则设计思路。DP实现用**滚动数组优化空间**，状态定义直观（$f_{i,j,k,l,g}$）。代码包含详尽注释和调试心得，如强调“和牌距离不等同向听数”。实践价值突出，吃碰判断采用**临时增减牌再计算距离差**的策略，逻辑清晰易调试。

**题解三：SuperCowHorse (5赞)**
* **点评**：最简洁的竞赛级实现（仅5K代码）。亮点是**统一牌型转换函数**和**优先级队列处理出牌选择**。DP状态转移用宏封装提升可读性，吃碰判断采用**策略模式**优先数字大的组合。虽代码紧凑但核心逻辑完整，适合竞赛参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下关键难点：

1.  **和牌距离的DP状态设计**：
    * **分析**：优质题解普遍采用五维DP：`dp[牌型][面子数][雀头][顺子需求1][顺子需求2]`。例如FjswYuzu的解法中，状态转移考虑三种情况：
      ```math
      \begin{cases} 
      \text{刻子:} & dp[i][j+1][k][a][b] \leftarrow dp[i-1][j][k][x][y] + cost \\
      \text{顺子:} & dp[i][j][k][a][b] \leftarrow dp[i-1][j][k][x][y] + cost \\
      \text{雀头:} & dp[i][j][1][a][b] \leftarrow dp[i-1][j][0][x][y] + cost 
      \end{cases}
      ```
    * 💡 **学习笔记**：DP状态需覆盖牌型的连续性需求，字牌需特殊处理

2.  **吃碰优先级与距离验证**：
    * **分析**：当玩家打牌后，需按顺序检查：荣和 > 碰 > 吃。题解通过**比较操作前后的距离差**决定是否响应：
      ```cpp
      // FjswYuzu的碰判断逻辑
      int oldDist = calcDist(hand);
      removeTwoCards(card); // 模拟碰牌
      if (calcDist(hand) < oldDist) // 距离严格减小才执行
      ```
    * 💡 **学习笔记**：吃碰响应需保证距离严格减小，且碰优先于吃

3.  **特殊牌的状态中断**：
    * **分析**：`REVERSE`会反转玩家顺序，`PASS`跳过下家，`DOUBLE`使当前玩家立即额外回合。需用**状态机变量**（如`rev`标志方向）和**递归调用**处理中断
    * 💡 **学习笔记**：特殊牌打破线性流程，建议用有限状态机建模

### ✨ 解题技巧总结
<summary_best_practices>
1. **DP状态压缩**：用滚动数组和位运算优化高维DP
2. **模块化设计**：分离牌型转换、距离计算、流程控制模块
3. **防御性测试**：特别测试边界如字牌吃碰、多张特殊牌
4. **实时距离缓存**：缓存各玩家当前距离避免重复计算
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用核心实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合FjswYuzu和liuzhangfeiabc的DP设计，优化状态转移逻辑
* **完整核心代码**：
```cpp
#include <vector>
#include <cstring>
using namespace std;

const int TYPE = 34; // 34种标准牌型

// 五维DP：[当前牌型][面子数][雀头][顺子需求1][顺子需求2]
int dp[TYPE+2][5][2][3][3]; 

int calcMahjongDist(vector<int>& hand) {
    memset(dp, 0x3f, sizeof(dp));
    dp[0][0][0][0][0] = 0;
    
    for (int i = 1; i <= TYPE; i++) {
        for (int j = 0; j <= 4; j++) { // 面子数
            for (int k = 0; k <= 1; k++) { // 雀头
                for (int a = 0; a <= 2; a++) { // 顺子需求1
                    for (int b = 0; b <= 2; b++) { // 顺子需求2
                        if (dp[i-1][j][k][a][b] > 100) continue;
                        
                        for (int c = a + b; c <= 4; c++) {
                            int need = max(0, c - hand[i]);
                            int remain = c - a - b;
                            
                            // 情况1：组成刻子
                            if (remain >= 3) 
                                update(dp[i][j+1][k][b][remain-3], need);
                            
                            // 情况2：组成雀头
                            if (!k && remain >= 2) 
                                update(dp[i][j][1][b][remain-2], need);
                            
                            // 情况3：延续顺子需求
                            if (remain <= 2)
                                update(dp[i][j][k][b][remain], need);
                        }
                    }
                }
            }
        }
    }
    return dp[TYPE][4][1][0][0]; // 目标状态
}
```
* **代码解读概要**：
  > 该DP核心计算手牌的和牌距离：
  > 1. **初始化**：`dp[0][0][0][0][0]=0` 表示起始状态
  > 2. **状态转移**：枚举当前牌型的使用数量，分刻子/雀头/顺子三种情况更新状态
  > 3. **目标状态**：`dp[TYPE][4][1][0][0]` 表示组成4个面子和1个雀头

---
<code_intro_selected>
优质题解的核心技巧片段：
</code_intro_selected>

**题解一：FjswYuzu**
* **亮点**：面向对象封装，状态转移完整
* **核心代码片段**：
```cpp
void MahjongGame::Pong(int who, int card) {
    cnt[who][card] -= 2; // 移除两张牌
    printf("%s PONG %s %s %s\n", 
        player[who], cardName[card], cardName[card], cardName[card]);
}
```
* **代码解读**：
  > 碰牌操作只需移除两张相同牌并输出记录。关键在调用前的**距离检查**确保操作有效

**题解二：liuzhangfeiabc**
* **亮点**：吃牌的多情况处理
* **核心代码片段**：
```cpp
bool canChow(Player &p, int card) {
    if (card > 27) return false; // 字牌不可吃
    int distBefore = calcDist(p.hand);
    
    // 尝试三种吃牌组合
    for (int type : {1, 2, 3}) {
        removeChowCards(p, card, type); // 移除组成顺子的牌
        if (calcDist(p.hand) < distBefore) 
            return true; // 距离减小则有效
        restoreCards(p); // 恢复手牌
    }
    return false;
}
```
* **学习笔记**：吃牌需验证所有可能组合，数字大的组合优先

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了直观理解DP状态转移，我设计了"麻将解谜"像素动画方案（FC红白机风格）：
</visualization_intro>

  * **场景设计**：
    - **牌桌网格**：4×9网格展示四人手牌，牌背用16×16像素块
    - **状态面板**：右侧显示当前DP状态矩阵（5×5×2×3×3）
    - **控制台**：底部有步进/暂停/速度滑块

  * **核心演示流程**：
    1. **初始化场景**：
        - 背景音乐：8-bit风格《东风》循环BGM
        - 牌堆：左侧像素化牌山，摸牌时有"抽牌"音效
    2. **DP计算演示**（重点）：
        ```mermaid
        graph LR
        A[牌型i-1] -->|顺子需求| B[牌型i]
        B -->|组成刻子| C[高亮3张牌]
        B -->|组成雀头| D[高亮2张牌]
        B -->|顺子延续| E[箭头连接i-1→i]
        ```
        - 当前处理牌型闪烁黄色边框
        - 状态转移时显示数学公式弹幕
        - 音效：刻子组成时"咚"，顺子组成时"叮"
    3. **吃碰操作**：
        - 吃牌：三张牌横向滑动拼合，配流水音效
        - 碰牌：三张牌爆炸特效+闪光
    4. **和牌瞬间**：
        - 屏幕闪烁+烟花特效
        - 播放《胜利》8-bit音乐
        - 显示"和牌！"像素艺术字

  * **交互控制**：
    - `空格`：单步执行DP状态转移
    - `方向键`：切换当前牌型
    - `A键`：自动演示（AI解牌）

<visualization_conclusion>
通过像素化DP状态转移和音效反馈，可直观理解麻将和牌距离的计算本质。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握麻将模拟器后，可挑战以下相似问题：
</similar_problems_intro>

1. **洛谷 P5279** - [ZJOI2019]麻将
   * 🗣️ **推荐理由**：强化和牌距离DP，需处理更多牌型
   
2. **洛谷 P5301** - [GXOI/GZOI2019]宝牌一大堆
   * 🗣️ **推荐理由**：在麻将基础上增加宝牌计数，考验状态扩展

3. **洛谷 P5380** - [THUPC2019]鸭棋
   * 🗣️ **推荐理由**：类似大模拟题，但改用中国象棋规则

---

## 7. 学习心得与经验分享

<insights_intro>
从题解中提炼的调试经验：
</insights_intro>

> **FjswYuzu 的调试经验**：
> “和牌距离定义消耗3天调试时间，务必区分向听数与操作数差异。建议用小规模牌型单元测试DP函数”
>
> **liuzhangfeiabc 的踩坑总结**：
> “吃牌组合验证时未过滤字牌导致错误，增加`if(card>27)return false`后通过”

---

<conclusion>
麻将模拟器是DP与状态机的完美结合案例。核心在于分解问题：将和牌距离转化为DP状态转移，再用有限状态机处理游戏流程。多写单元测试验证边界，善用封装提升可维护性。记住，复杂模拟题的本质是有限状态机+数据结构！</conclusion>

---
处理用时：150.33秒
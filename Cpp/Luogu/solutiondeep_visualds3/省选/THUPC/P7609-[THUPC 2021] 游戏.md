# 题目信息

# [THUPC 2021] 游戏

## 题目描述

小 C 和小 W 两个人打算玩一局双人博弈游戏。

现在小 C 手里有 $n$ 颗相同的石子，小 W 打算把它们分为有顺序的 $m$ 堆，其中第 $i$ 堆石子的数量不能超过 $a_i$，但允许为 $0$。

随后，由小 C 先手，两人轮流进行操作，每次可以选择一堆非空的石子并拿走其中若干个（至少 $1$ 个），无法操作者输。

作为算法竞赛界的老司机，小 C 和小 W 早已对各种游戏的策略摸得门儿清，于是这次他们打算玩点不一样的：他们想要知道，有多少种分石子的方法能使得小 C 有必胜策略。

## 说明/提示

**【样例解释】**

以下 $4$ 种方案是符合题意的：$(0,2,4)$、$(1,1,4)$、$(2,0,4)$、$(2,2,2)$。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_2/tree/master](https://github.com/yylidiw/thupc_2/tree/master) 查看。

## 样例 #1

### 输入

```
6 3
2 3 4
```

### 输出

```
4
```

# AI分析结果

# 💡 Kay的C++算法解析：[THUPC2021]游戏 深入学习指南 💡

<introduction>
今天我们要一起攻克THUPC2021的经典博弈问题——“游戏”。这道题结合了**Nim游戏结论**、**容斥原理**和**数位动态规划（数位DP）**，是考察“位级状态处理”与“组合计数”的典型题目。跟着Kay一步步拆解，你会发现看似复杂的问题，其实是“数学技巧+DP工具”的巧妙组合～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划(DP) + 数学（容斥原理）`

🗣️ **初步分析**：
解决这道题的关键，要先记住Nim游戏的“胜负密码”——**先手必胜当且仅当所有堆的异或和非0**。所以题目转化为：**总方案数（分m堆，每堆≤a_i，总和n）减去异或和为0的方案数**。

- **容斥原理**：总方案数不好直接算（因为每堆有上限），我们用“容斥”来绕开限制——先算“不考虑上限的方案数”，再减去“至少有一堆超过上限的方案数”，加上“至少两堆超过上限的方案数”……以此类推。这就像“先把所有可能的蛋糕都买了，再把过期的挑出去”～
- **数位DP**：异或和为0的方案数需要处理“每堆不超过a_i”和“异或和为0”两个条件。数位DP擅长处理“位级限制”问题——从最高位到最低位，逐位决定每堆的取值，同时记录“是否被上界卡住”（比如某堆的前几位都等于a_i的对应位，当前位不能超过a_i的当前位）和“进位情况”（总和要等于n，低位向高位的进位需要跟踪）。

**核心算法流程**：
1. 用容斥算总方案数：枚举所有子集S，计算“强制S中的堆超过a_i（即先放a_i+1个石子）”的方案数，再用 inclusion-exclusion 调整符号。
2. 用数位DP算异或和为0的方案数：定义状态`f[i][s][j]`表示处理到第i位，被上界卡住的堆集合是s，低位向当前位进位j次，递归计算每一位的可能取值（0或1），并确保异或和为0（每一位1的个数是偶数）。

**可视化设计思路**：
我们会做一个“像素数位探险家”游戏——把每一位的处理变成“关卡”，用像素块表示堆的状态（绿色代表“被上界卡住”，蓝色代表“自由”），进位用“像素小箭头”传递。每处理一位，播放“叮”的音效；当异或和为0时，播放“嗡”的提示音；完成所有位处理后，用“胜利音效”庆祝。还能单步看状态转移，比如子集s的变化（从大集合缩小到小集合）、进位j的增减～


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法优化程度三个维度，为你筛选了**2篇优质题解**（≥4星）。它们的核心思路一致，但细节处理各有亮点～
</eval_intro>

**题解一：（来源：Time_tears）**
* **点评**：这份题解是本题的“标准解法模板”——思路闭环（容斥算总方案+数位DP算异或0方案），复杂度优化到位（从4^m降到3^m），代码注释虽少但结构清晰。它的**最大亮点**是把“被上界卡住的堆集合s”的转移优化：不再枚举所有堆的取值，而是枚举s的子集（没被卡住的堆可以自由选0/1，用组合数计算），直接把复杂度从O(4^m m logn)压到O(3^m m² logn)，这是能通过本题的关键！此外，容斥的实现用了子集枚举，逻辑简单直接，适合初学者模仿。

**题解二：（来源：MiniLong）**
* **点评**：这篇题解的思路和题解一高度一致，但更强调“进位的传递逻辑”（j的范围是0到2m-1）。它的**亮点**是把“异或和为0”转化为“每一位1的个数是偶数”，并明确了转移时“进位如何更新”（j→2j + [n的当前位] - t，t是当前位1的个数）。虽然没有代码，但文字描述补足了数位DP的核心逻辑，适合用来理解“状态转移的数学意义”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点集中在“如何把组合计数问题转化为可计算的DP状态”，以及“如何优化高复杂度”。下面三个关键点，是你解题时需要“咬碎牙啃下来”的部分～
</difficulty_intro>

1. **难点1：总方案数的容斥计算**  
   * **问题**：直接算“每堆≤a_i且总和n”的方案数，需要处理m个上界，无法用普通隔板法。  
   * **解决策略**：用容斥原理“反着算”——先算“不考虑上界的方案数”（隔板法：C(n+m-1, m-1)），再减去“至少有一堆> a_i”的方案数（先给这堆放a_i+1个，剩下的用隔板法），加上“至少两堆> a_i”的方案数……以此类推。公式就是题解中的：  
     $$\sum_{S} (-1)^{|S|} \times C(n - \sum_{i∈S}(a_i+1) + m-1, m-1)$$  
     其中S是子集，|S|是子集大小，符号由(-1)^{|S|}决定。  
   * 💡 **学习笔记**：容斥是处理“多个上界限制”的常用工具——把“不能超过”转化为“强制超过”，再用符号调整。

2. **难点2：数位DP的状态设计**  
   * **问题**：需要同时满足“每堆≤a_i”、“异或和为0”、“总和为n”三个条件，状态要记录哪些信息？  
   * **解决策略**：状态要包含三个关键信息：  
     - `i`：当前处理到哪一位（从最高位到最低位）；  
     - `s`：被上界卡住的堆集合（比如s的第j位为1，表示第j堆的前几位都等于a_j的对应位，当前位不能超过a_j的当前位）；  
     - `j`：低位向当前位的进位次数（总和要等于n，每一位的总和加上进位要等于n的当前位）。  
     这样状态就能覆盖所有限制条件，逐位推导可能的取值。  
   * 💡 **学习笔记**：数位DP的状态设计要“精准覆盖所有限制”——不要遗漏任何会影响后续决策的信息。

3. **难点3：数位DP的转移优化**  
   * **问题**：直接枚举每堆的0/1取值，复杂度是O(2^m m logn)，m=10时2^10=1024，乘以logn（约60）和m²（100），会超时。  
   * **解决策略**：优化枚举方式——不再枚举所有堆的取值，而是枚举“被上界卡住的堆集合s的子集s'”（s'是当前位仍然被卡住的堆），剩下的堆（不在s中的）可以自由选0/1，用组合数计算选k个1的方案数。这样枚举量从2^m降到3^m（每个堆有三种选择：在s中且选1，在s中且选0，不在s中），m=10时3^10=59049，完全可接受。  
   * 💡 **学习笔记**：优化DP复杂度的关键是“找到重复计算的部分”——用组合数代替逐一枚举，减少状态数。


### ✨ 解题技巧总结
- **技巧1：问题转化**：把“求异或非0”转化为“总方案-异或为0”，避免直接处理复杂条件。  
- **技巧2：容斥原理**：处理“多个上界限制”的组合计数问题，用 inclusion-exclusion 绕开直接计算的困难。  
- **技巧3：数位DP状态优化**：用“集合表示被上界卡住的堆”和“组合数计算自由堆的取值”，将复杂度从指数级降到多项式级。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解思路的核心实现**，它包含了容斥算总方案、数位DP算异或0方案的完整逻辑～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码基于Time_tears的题解修改，补充了注释，调整了变量名可读性，保留了核心逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

typedef long long ll;
const int MOD = 998244353;
const int MAX_M = 11;  // 题目中m≤10
const int MAX_BIT = 60; // n最多是1e18，所以60位足够

ll n, a[MAX_M];
int m;
int C_table[MAX_M][MAX_M]; // 组合数C(n, k)，n≤10
int dp[2][1 << MAX_M][MAX_M]; // 数位DP数组：dp[当前位][被卡集合s][进位j]
int pow2[MAX_M]; // 预处理2的幂，用于快速计算

// 快速幂：计算a^b mod MOD
int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = (ll)res * a % MOD;
        a = (ll)a * a % MOD;
        b >>= 1;
    }
    return res;
}

// 组合数C(n, k)，n是ll，k≤10（因为m≤10）
int comb(ll n, int k) {
    if (n < k || k < 0) return 0;
    int res = 1;
    for (int i = 1; i <= k; ++i) {
        res = (ll)res * ((n - k + i) % MOD) % MOD;
        res = (ll)res * qpow(i, MOD - 2) % MOD; // 逆元
    }
    return res;
}

// 容斥计算总方案数：分m堆，每堆≤a_i，总和n的方案数
int calc_total() {
    int total = 0;
    // 枚举所有子集S（S中的堆强制超过a_i，即先放a_i+1个）
    for (int S = 0; S < (1 << m); ++S) {
        int cnt = __builtin_popcount(S);
        ll sum = 0;
        for (int i = 0; i < m; ++i) {
            if (S & (1 << i)) sum += a[i] + 1;
        }
        if (sum > n) continue;
        // 方案数：C(n - sum + m - 1, m - 1)，符号由(-1)^cnt决定
        int sign = (cnt % 2 == 0) ? 1 : MOD - 1;
        int ways = comb(n - sum + m - 1, m - 1);
        total = (total + (ll)sign * ways) % MOD;
    }
    return total;
}

// 数位DP初始化：预处理组合数C_table
void init_comb() {
    for (int i = 0; i < MAX_M; ++i) {
        C_table[i][0] = 1;
        for (int j = 1; j <= i; ++j) {
            C_table[i][j] = (C_table[i-1][j] + C_table[i-1][j-1]) % MOD;
        }
    }
}

// 数位DP主函数：计算异或和为0的方案数
int calc_xor_zero() {
    if (n % 2 != 0) return 0; // 异或和为0的话，总和n必须是偶数？不，比如1^1=0，总和2是偶数；但比如1^2^3=0，总和6是偶数？对，异或和为0时，每一位1的个数是偶数，总和的每一位是“偶数个1相加+进位”，所以总和是偶数。所以n是奇数的话，异或和为0的方案数为0。
    memset(dp, 0, sizeof(dp));
    int current = 0;
    int full_mask = (1 << m) - 1; // 初始时所有堆都被上界卡住
    dp[current][full_mask][0] = 1; // 处理最高位前，状态是所有堆被卡，进位0

    for (int bit = MAX_BIT - 1; bit >= 0; --bit) { // 从最高位到最低位
        int next = current ^ 1;
        memset(dp[next], 0, sizeof(dp[next]));
        ll n_bit = (n >> bit) & 1; // n的当前位值

        for (int s = 0; s < (1 << m); ++s) { // 枚举当前被卡的集合s
            for (int j = 0; j < m; ++j) { // 枚举进位j（0到m-1）
                int val = dp[current][s][j];
                if (val == 0) continue;

                // 枚举s的子集s'（当前位仍然被卡的堆）
                for (int s_prime = s; ; s_prime = (s_prime - 1) & s) {
                    // 检查s_prime的合法性：s中不在s_prime的堆，当前位不能超过a_i的当前位（即a_i的当前位必须是1）
                    bool valid = true;
                    for (int i = 0; i < m; ++i) {
                        if ((s & (1 << i)) && !(s_prime & (1 << i))) { // 堆i在s中，但不在s_prime中
                            if (!((a[i] >> bit) & 1)) { // a_i的当前位是0，不能选1，所以s_prime必须包含i，否则不合法
                                valid = false;
                                break;
                            }
                        }
                    }
                    if (!valid) {
                        if (s_prime == 0) break;
                        continue;
                    }

                    // 计算s_prime中当前位选1的堆数：num_1
                    int num_1 = 0;
                    for (int i = 0; i < m; ++i) {
                        if ((s_prime & (1 << i)) && ((a[i] >> bit) & 1)) {
                            num_1++;
                        }
                    }

                    // 计算自由堆的数量：不在s中的堆，可以自由选0或1
                    int free = m - __builtin_popcount(s);
                    // 异或和为0，当前位1的总数必须是偶数：t = num_1 + r，r是自由堆中选1的数量，t必须是偶数
                    for (int r = 0; r <= free; r += 2) {
                        int t = num_1 + r;
                        // 计算进位：当前位的总和是t + j（低位进位），所以向高位的进位是 (t + j) / 2
                        // 同时，总和的当前位必须等于n的当前位：(t + j) % 2 == n_bit
                        if ((t + j) % 2 != (n >> bit) & 1) continue;
                        int new_j = (t + j) / 2;
                        if (new_j >= m) continue; // 进位不能超过m-1（因为每堆最多选1，t最多是m，j最多是m-1，所以new_j最多是 (m + m-1)/2 = m-0.5，即m-1）

                        // 自由堆中选r个1的方案数：C(free, r)
                        int ways = C_table[free][r];
                        // 更新next状态：s_prime是新的被卡集合，new_j是新的进位
                        dp[next][s_prime][new_j] = (dp[next][s_prime][new_j] + (ll)val * ways) % MOD;
                    }

                    if (s_prime == 0) break; // 子集枚举结束
                }
            }
        }
        current = next;
    }

    int res = 0;
    for (int s = 0; s < (1 << m); ++s) {
        res = (res + dp[current][s][0]) % MOD; // 最后进位必须是0
    }
    return res;
}

int main() {
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        cin >> a[i];
    }
    init_comb();
    int total = calc_total();
    int xor_zero = calc_xor_zero();
    int ans = (total - xor_zero + MOD) % MOD;
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
  > 代码分为三部分：1. 用容斥算总方案数（`calc_total`）；2. 预处理组合数（`init_comb`）；3. 用数位DP算异或和为0的方案数（`calc_xor_zero`）。核心逻辑是“总方案 - 异或0方案”，其中数位DP部分逐位处理，用状态`dp[current][s][j]`跟踪被卡集合和进位，确保异或和为0。


<code_intro_selected>
接下来看**Time_tears题解**中的核心片段，它是数位DP优化的关键～
</code_intro_selected>

**题解一：（来源：Time_tears）**
* **亮点**：用“子集枚举s_prime”优化被卡集合的转移，将复杂度从4^m降到3^m。
* **核心代码片段**：
```cpp
// 枚举s的子集s_prime（当前位仍然被卡的堆）
for (int s_prime = s; ; s_prime = (s_prime - 1) & s) {
    // 检查s_prime的合法性：s中不在s_prime的堆，当前位不能超过a_i的当前位（即a_i的当前位必须是1）
    bool valid = true;
    for (int i = 0; i < m; ++i) {
        if ((s & (1 << i)) && !(s_prime & (1 << i))) { // 堆i在s中，但不在s_prime中
            if (!((a[i] >> bit) & 1)) { // a_i的当前位是0，不能选1，所以s_prime必须包含i，否则不合法
                valid = false;
                break;
            }
        }
    }
    if (!valid) {
        if (s_prime == 0) break;
        continue;
    }

    // 计算s_prime中当前位选1的堆数：num_1
    int num_1 = 0;
    for (int i = 0; i < m; ++i) {
        if ((s_prime & (1 << i)) && ((a[i] >> bit) & 1)) {
            num_1++;
        }
    }

    // 自由堆中选r个1的方案数：C(free, r)，r是偶数（确保异或和为0）
    for (int r = 0; r <= free; r += 2) {
        int t = num_1 + r;
        if ((t + j) % 2 != (n >> bit) & 1) continue;
        int new_j = (t + j) / 2;
        int ways = C_table[free][r];
        dp[next][s_prime][new_j] = (dp[next][s_prime][new_j] + (ll)val * ways) % MOD;
    }

    if (s_prime == 0) break;
}
```
* **代码解读**：
  > 这段代码是数位DP的**核心转移逻辑**。首先枚举当前被卡集合s的子集s_prime——s_prime中的堆“仍然被上界卡住”（当前位必须等于a_i的当前位），s中不在s_prime的堆“不再被卡”（当前位可以选0）。然后计算s_prime中选1的堆数num_1（因为这些堆被卡，当前位只能选a_i的当前位，所以如果a_i的当前位是1，才会算入num_1）。接下来，自由堆（不在s中的）可以选r个1，r必须是偶数（确保异或和为0，即当前位1的总数是偶数）。最后，根据总和的进位规则（t + j的奇偶性等于n的当前位，进位是(t + j)/2），更新下一位的状态。
* 💡 **学习笔记**：子集枚举是优化数位DP的关键技巧——通过枚举“被卡集合的子集”，把“逐堆决定取值”转化为“按集合批量处理”，大幅减少计算量。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”数位DP的每一步，Kay设计了一个**像素风格的“数位探险”游戏**～ 你会扮演“数位探险家”，跟着像素块一步步处理每一位，感受被卡集合的变化、进位的传递，还有异或和为0的条件！
</visualization_intro>

### 🎮 动画设计方案：《像素数位探险家》
**主题**：你是一个像素小人，要从最高位“关卡”走到最低位“关卡”，每关处理一位的取值，最终找到“异或和为0”的方案。

**核心演示内容**：
1. **场景初始化**：
   - 屏幕左侧是“数位关卡”：每一位对应一个像素化的“门”，从高位（比如第59位）到低位（第0位）排列。
   - 屏幕右侧是“状态面板”：用像素块表示被卡集合s（绿色方块代表被卡的堆，蓝色代表自由）、进位j（红色小箭头，数量等于j）、当前位的异或和（黄色数字，0或1）。
   - 控制面板有“单步”“自动”“重置”按钮，还有速度滑块（从“龟速”到“火箭”）。
   - 8位风格的背景音乐（类似《超级马里奥》的轻快旋律）开始播放。

2. **算法启动**：
   - 初始状态：所有堆都是绿色（被卡），进位j=0（没有红色箭头），异或和为0（黄色数字0）。
   - 点击“开始”，像素小人走到最高位的“门”前，播放“吱呀”的开门音效。

3. **逐位处理（关卡流程）**：
   - **步骤1：选择被卡子集s_prime**：
     - 屏幕上弹出所有可能的s_prime子集（用绿色方块的组合表示），像素小人点击一个子集，播放“叮”的音效。
     - 被卡集合从s变为s_prime（比如原来的绿色方块减少几个），自由堆变成蓝色。
   - **步骤2：选择自由堆的1的数量r**：
     - 自由堆（蓝色）上方出现“选r个1”的提示，r必须是偶数（比如0、2、4…）。
     - 像素小人点击r，蓝色方块中亮起r个黄色小灯（代表选1），播放“滴滴”的选择音效。
   - **步骤3：检查进位和总和**：
     - 屏幕下方弹出“进位计算”框：显示t=num_1 + r，j=当前进位，计算(t + j)的奇偶性是否等于n的当前位。
     - 如果符合条件，红色箭头的数量变成new_j（进位），播放“咻”的进位音效；如果不符合，弹出“错误”提示，播放“哔”的音效，重新选择。
   - **步骤4：通关当前位**：
     - 所有条件满足后，当前位的“门”打开，像素小人走进下一关（下一位），播放“通关”音效（类似《塞尔达传说》的小胜利音效）。

4. **目标达成**：
   - 处理完所有位后，如果进位j=0（没有红色箭头），异或和为0（黄色数字0），屏幕弹出“胜利！”的像素文字，播放“胜利进行曲”（8位风格），并显示异或和为0的方案数。
   - 如果中途出错（比如进位不符合条件），弹出“重试”提示，播放“失败”音效（短促的“嗡”声）。

**游戏化元素**：
- **关卡奖励**：每通过一位，获得10分；连续通过3位，获得“连击奖励”（额外20分）。
- **AI演示模式**：点击“AI自动玩”，像素小人会自动选择最优的s_prime和r，快速通关，你可以跟着看每一步的决策。
- **音效设计**：
  - 选子集：“叮”（高 pitched）；
  - 选r：“滴滴”（连续两声）；
  - 进位正确：“咻”（滑音）；
  - 通关：“叮咚”（上扬音调）；
  - 胜利：“当当当”（8位版《欢乐颂》片段）。

**技术实现**：
- 用HTML5 Canvas绘制像素块，用JavaScript处理动画逻辑。
- 用Web Audio API播放8位音效（提前制作好的.wav文件）。
- 状态面板的更新：每步处理后，重新绘制被卡集合、进位箭头、异或和数字。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“数位DP + 容斥”的组合后，你可以挑战以下相似问题，巩固所学～
</similar_problems_intro>

### 🧠 通用思路迁移
本题的思路可以用于**所有“有上界限制的异或和/总和计数问题”**，比如：
1. 计算“分m个数，每数≤a_i，总和n，异或和为k”的方案数（把异或和的条件从0改为k，调整数位DP的状态）；
2. 计算“选k个数，每个数≤a_i，异或和为0”的方案数（去掉总和的限制，调整数位DP的进位跟踪）。

### 📚 洛谷推荐练习
1. **洛谷 P7609** - [THUPC2021] 游戏  
   * 🗣️ **推荐理由**：本题原题！直接用学到的容斥+数位DP解决，检验你的掌握程度。
2. **洛谷 P4162** - [SCOI2009] 生日快乐  
   * 🗣️ **推荐理由**：虽然是搜索题，但需要处理“分块的上界限制”，可以用容斥思想优化。
3. **洛谷 P5900** - [IOI2016] aliens  
   * 🗣️ **推荐理由**：数位DP的进阶题，需要处理“多个上界限制”和“复杂的状态转移”，是很好的拓展练习。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
Time_tears的题解中提到：“最初枚举每堆的取值，复杂度是4^m，后来想到用子集枚举优化到3^m，才通过了题目。” 这句话给了我们重要的启发～
</insights_intro>

> **参考经验 (来自 Time_tears)**：“我一开始直接枚举每堆的0/1取值，结果m=10时，4^10=1048576，乘以logn的60次，直接超时。后来想到，被卡的堆可以按集合处理，不用逐堆枚举，才把复杂度降到3^10=59049，终于过了。”

**点评**：这位作者的经验太真实了！很多时候，我们会陷入“逐一枚举”的思维定式，而忽略了“按集合批量处理”的优化方法。遇到超时问题时，不妨问自己：“有没有重复计算的部分？能不能用组合数或数学公式代替枚举？” 动手模拟小例子（比如m=2时，枚举子集比枚举每堆快多少），也能帮助找到优化方向～


<conclusion>
本次的《游戏》题分析就到这里啦！你学会了用容斥算总方案，用数位DP处理异或和为0的限制，还知道了如何优化数位DP的复杂度。记住：**复杂的问题都是由简单的技巧组合而成的**——容斥是“数学工具”，数位DP是“DP工具”，组合起来就能解决大问题～ 下次遇到类似的计数问题，别慌，先想“能不能转化为总方案减不符合条件的方案”，再想“用什么DP工具处理限制”，你一定能解决！💪
</conclusion>

---
处理用时：119.43秒
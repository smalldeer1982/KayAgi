# 题目信息

# [THUPC 2023 初赛] 公平合作

## 题目描述

在大地的尽头，一座灰白的灯塔矗立在漫长的海岸线上。这一片海域海流复杂、礁石嶙峋，却又是不少航线的必经之路。若没有如此高耸而明亮的灯塔为过路的船只照亮航路，或许会有更多不幸的生命葬身海底。为了看管好这一座海上明灯，一批训练有素的守望人轮流值守于此。日复一日的工作枯燥乏味却又不能有丝毫闪失，紧绷的神经直到下一班守望人到来才得以放松。

在电力普及之前，灯塔通常使用煤油灯为过往的水手指引前行的方向。每次为这座灯塔添加燃油时，需要两位守望人各自搬运一个容积为 $L$ 的油桶；而每次轮到 Y 和 S 所在的班组照料这座灯塔时，总是由 Y 和 S 负责为灯塔加油。将煤油搬运至灯室时，如果不装满油桶，对灯塔的正常运转也没有太大影响，无非是需要多来回搬运几趟。但是，如果两位守望人都想着偷懒，问题恐怕就不只是多几趟那么简单。Y 和 S 想到了一个好办法：互相为对方的油桶装油。

灯塔里有 $N$ 个用于将储存的煤油转移到油桶中的容器，其中第 $i$ 个容器的容积为 $a_i$。Y 和 S 先想办法决定由谁先装油。两人先后装油；轮到其中一位守望人装油时，这位守望人每次从所有容器中等概率地随机选出一个容器，将其装满油，并全部倒入对方的油桶中。两位守望人都可以在操作任意多次（可以是 0 次）后结束装油，但后手必须等先手结束后才能开始装油。Y 和 S 先后装完煤油后，两人会比一下谁把对方的油桶装得更满，再各自把自己的油桶搬运到灯室。但是，如果有谁某次选出一个容器后，把对方的油桶装满了，但容器里还有没倒出的煤油，那么这位倒霉的守望人就必须把两个油桶都独自搬到灯室——这也算是为单调的生活平添了几分乐趣。显然，如果先手某次随机选中的容器会使得油桶溢出，那么后手可以往先手的油桶里面装任意量的煤油，然后幸灾乐祸；因此我们约定：当先手溢出时，必定由先手搬两个油桶。

现在只剩下了一个问题：当 Y 和 S 都采取最优策略，使得对方搬的煤油尽可能地比自己多的时候，先手搬的煤油不多于后手的概率是多大？

## 说明/提示

#### 样例解释 1

可以证明，此时先手的策略一定是装满对方的油桶，且装满时必胜。经过若干次随机抽取后，能恰好将对方的油桶装满的概率为：

$$
\left(\frac{1}{2}\right)^2 + \binom{3}{1}\left(\frac{1}{2}\right)^3 + \left(\frac{1}{2}\right)^4 = \frac{11}{16}=0.6875
$$

#### 数据范围

对于 $100\%$ 的数据，保证 $1\le N\le 2\times 10^3$，$1\le L\le 10^9$，$1\le a_i\le 2\times 10^3$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 4
1 2```

### 输出

```
0.687500000000000000
```

## 样例 #2

### 输入

```
见附件中的 2.in```

### 输出

```
见附件中的 2.out```

## 样例 #3

### 输入

```
见附件中的 3.in```

### 输出

```
见附件中的 3.out```

# AI分析结果

# 💡 Kay的C++算法解析：公平合作 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划 + 数学（多项式取模加速线性递推）`


🗣️ **初步分析**：  
解决这道题的关键，就像**“用数学公式快速叠高楼”**——动态规划帮我们理清每一步的最优选择（继续装油还是停止），而多项式取模则是“快速电梯”，帮我们跳过中间1e9层的计算，直接得到最终结果。  

### 核心算法的通俗理解  
- **动态规划（DP）**：就像你玩“选路游戏”——每一步可以选“停止”（直接比胜负）或“继续装”（看后续结果），要选赢面最大的那个。比如`q_i`表示“当前装了i升，先手的胜率”，`max(1-p_i, 平均后续胜率)`就是选“停止”还是“继续”。  
- **多项式取模**：当L大到1e9时，逐一枚举每个i是不可能的。这时候我们把递推关系转化为**多项式乘法**——就像用“积木公式”快速算出1e9步后的积木形状，不用一块块堆。  

### 题解核心思路  
1. **缩小范围**：因为最大容器是m，所以当X超过`C=L-m`后，再装一次就会到`(C, L]`，只需计算这个区间的X。  
2. **快速算概率**：用多项式取模计算`f_C`（X落在`(C, L]`的概率）。  
3. **算后手胜率**：`p_i`是X=i时，后手Y在`(i, L]`的概率。  
4. **算先手最优胜率**：`q_i`选“停止（胜率1-p_i）”或“继续（平均后续胜率）”的最大值。  
5. **求答案**：把`f_C`中每个X的概率乘以对应的`q_i`，加起来就是最终概率。  

### 可视化设计思路  
我们用**8位像素风**做一个“油桶挑战”游戏：  
- 屏幕左边是`X`的像素油桶，右边是`Y`的油桶，下面是容器堆（显示每个a_i的大小）。  
- 多项式取模时，用“积木块”组合表示多项式，乘法是“积木拼接”，取模是“切去多余部分”，伴随“叮-嗒”的音效。  
- 动态规划的`max`选择：用两种颜色的箭头（红=停止，蓝=继续），选最大值时箭头闪烁，伴随“嗡”的提示音。  
- 自动播放模式：像“贪吃蛇AI”一样，自动完成多项式计算和DP选择，每完成一个阶段（比如算出f_C）就弹出“小关卡完成”的像素提示。  


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码可读性、算法优化度等方面筛选了2份优质题解，帮你快速抓住核心！  
</eval_intro>


### 题解一：Alex_Wei（来源：洛谷P9138题解）  
**点评**：这份题解就像“算法说明书”——从状态定义到多项式取模的每一步都讲得透，代码更是“教科书级”：  
- **思路**：用多项式取模解决大L问题，动态规划计算最优胜率，逻辑链完整。  
- **代码**：变量名（如`f`表示递推概率，`g`表示多项式基）清晰，注释点明关键步骤（比如“翻转系数”对应多项式下标调整）。  
- **技巧**：多项式取模的`mul`函数巧妙处理了递推的“贡献”问题，把高次幂计算转化为快速幂，直接解决1e9的L。  
- **实践**：代码能直接处理大L，边界条件（如`C=L-m`的范围）处理严谨，是竞赛级别的实现。  


### 题解二：dead_X（来源：洛谷P9138题解）  
**点评**：这份题解像“补全手册”——补充了小L的处理方法，适合对比学习：  
- **思路**：分情况讨论L的大小（≤4000时用普通DP，否则用多项式加速），覆盖了所有情况。  
- **代码**：用`ps`数组预处理前缀和，简化了概率计算，但变量名（如`q=Q+4002`）有点绕，注释较少。  
- **技巧**：小L时的`win`数组计算（从后往前求最优胜率）和大L时的多项式加速结合，适合理解两种场景的差异。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
这道题的“拦路虎”主要是**“大L的处理”“状态的理解”“最优决策的选择”**，我们一个个拆！  
</difficulty_intro>


### 1. 难点1：状态定义——`p_i`和`q_i`的区别？  
**问题**：为什么`p_i`是“后手的概率”，而`q_i`是“先手的胜率”？  
**分析**：`p_i`是“X=i时，后手Y在(i, L]的概率”（此时先手已经停止，后手必须继续）；`q_i`是“先手可以选择停止（胜率1-p_i）或继续（平均后续胜率）”，所以要取`max`——这是先手的**最优策略**。  
**技巧**：画个“决策树”——每个节点分两支（停止/继续），选赢面大的那个。  


### 2. 难点2：大L的处理——为什么用多项式取模？  
**问题**：L到1e9，普通DP（`dp[i]`表示X=i的概率）根本算不完！  
**分析**：递推关系是**线性的**（每个`dp[i]`由`dp[i-a_j]`相加而来），可以转化为多项式`A = x^m - Σ(1/n)x^{m-a_j}`。求`x^L mod A`就能快速得到`dp[L]`的概率——就像用“公式”算1e9步后的结果，不用一步步算。  
**技巧**：记住“线性递推=多项式取模”，遇到大次数的递推先想这个方法。  


### 3. 难点3：最优决策——`max`操作的意义？  
**问题**：`q_i = max(1-p_i, (1/n)Σq_{i+a_j})`中的`max`为什么是对的？  
**分析**：1-p_i是“停止的胜率”（后手Y在(i, L]的概率是p_i，所以先手胜率是1-p_i）；(1/n)Σq_{i+a_j}是“继续装一次的平均胜率”。先手会选**赢面更大的选项**，所以取`max`。  
**技巧**：把“继续装”的结果看成“未来的胜率”，“停止”是“现在的胜率”，选大的那个就是最优。  


### ✨ 解题技巧总结  
- **状态分层**：把大问题拆成“计算f_C→算p_i→算q_i→求答案”四层，每层解决一个小问题。  
- **数学加速**：遇到大L的线性递推，用多项式取模或矩阵快速幂，避免超时。  
- **逆向计算**：动态规划的`q_i`从后往前算（从L到C），因为每个状态依赖后面的状态。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一份**综合优质题解的核心代码**，它解决了大L的问题，逻辑清晰！  
</code_intro_overall>


### 本题通用核心C++实现参考  
* **说明**：综合Alex_Wei的思路，补充注释，适合理解多项式取模和动态规划的结合。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAX_M = 2005; // m是最大容器体积，这里设2005足够
double a[MAX_M]; // a[j]是选容器j的概率（j从1到m）
double f[MAX_M], g[MAX_M]; // f是当前多项式，g是基多项式
int n, L, m;
double w; // 1/n

// 多项式乘法+取模：计算f = f * g mod A（A是递推多项式）
void mul(double *f, double *g) {
    double h[MAX_M * 2] = {0};
    // 先算多项式乘法：h[k] = sum_{i+j=k} f[i] * g[j]
    for (int i = 0; i < m; i++)
        for (int j = 0; j < m; j++)
            h[i + j] += f[i] * g[j];
    // 再取模：用A = x^m - sum(a[j] * x^{m-j})，所以x^m = sum(a[j] * x^{m-j})
    // 对于k >= m，h[k] = sum(a[j] * h[k-j])，所以把h[k]的贡献转移到h[k-j]
    for (int k = 2 * m - 2; k >= m; k--)
        for (int j = 1; j <= m; j++)
            h[k - j] += h[k] * a[j];
    // 更新f为h的前m项（模后的结果）
    for (int i = 0; i < m; i++)
        f[i] = h[i];
}

int main() {
    cin >> n >> L;
    w = 1.0 / n;
    m = 0;
    // 读入容器体积，计算a[j]（选j的概率）和m（最大容器体积）
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        a[x] += w;
        if (x > m) m = x;
    }

    // 计算x^L mod A：f初始是1（x^0），g初始是x^1
    fill(f, f + m, 0);
    fill(g, g + m, 0);
    f[0] = 1; // x^0的系数是1
    g[1] = 1; // x^1的系数是1
    int power = L;
    while (power > 0) {
        if (power % 2 == 1) mul(f, g); // 乘g（x^power的当前位）
        mul(g, g); // g平方（x^(2k)）
        power /= 2;
    }
    reverse(f, f + m); // 翻转系数，对应f_C的概率（C=L-m）

    // 计算p_i：X=C+i+1时，后手Y在(C+i+1, L]的概率
    double p[MAX_M] = {0};
    double g_copy[MAX_M];
    copy(f, f + m, g_copy);
    p[0] = 1;
    for (int i = 0; i < m; i++) {
        if (i > 0) p[i] = p[i - 1];
        for (int j = 1; j <= m; j++) {
            if (i + j >= m) {
                p[i] -= g_copy[i] * a[j]; // Y超过L，减去这部分概率
            } else {
                g_copy[i + j] += g_copy[i] * a[j]; // 累加到Y=C+i+j+1的概率
            }
        }
    }

    // 计算q_i：X=C+i+1时先手的胜率，从后往前算
    double q[MAX_M] = {0};
    double ans = 0;
    for (int i = m - 1; i >= 0; i--) {
        // 计算继续装的平均胜率：sum(q[i+j] * a[j])
        double continue_win = 0;
        for (int j = 1; j <= m; j++) {
            if (i + j < m) continue_win += q[i + j] * a[j];
        }
        // 选停止（胜率1-p[i]）或继续（continue_win）的最大值
        q[i] = max(continue_win, 1 - p[i]);
        // 累加到答案：f[i]是X=C+i+1的概率，乘以q[i]
        ans += f[i] * q[i];
    }

    printf("%.12lf\n", ans);
    return 0;
}
```
* **代码解读概要**：  
  1. **多项式初始化**：读入容器体积，计算每个容器的概率`a[j]`和最大体积`m`。  
  2. **多项式快速幂**：用`mul`函数计算`x^L mod A`，得到`f`数组（X落在`(C, L]`的概率）。  
  3. **计算p_i**：遍历每个i，计算后手Y在`(i, L]`的概率。  
  4. **计算q_i**：从后往前算每个i的最优胜率，取停止或继续的最大值。  
  5. **求答案**：累加每个i的概率*胜率，输出结果。  


<code_intro_selected>  
再看Alex_Wei题解中的**多项式取模**核心片段，这是解决大L的关键！  
</code_intro_selected>


### 题解一：Alex_Wei的核心代码片段  
* **亮点**：用`mul`函数实现多项式乘法和取模，将线性递推转化为快速幂，处理1e9的L。  
* **核心代码片段**：  
```cpp
void mul(double *f, double *g) {
    static double h[N];
    memset(h, 0, sizeof(h));
    for(int i = 0; i < mx; i++)
        for(int j = 0; j < mx; j++)
            h[i + j] += f[i] * g[j];
    for(int i = mx * 2 - 2; i >= mx; i--)
        for(int j = 1; j <= mx; j++)
            h[i - j] += h[i] * a[j];
    for(int i = 0; i < mx; i++) f[i] = h[i];
}
```
* **代码解读**：  
  1. **多项式乘法**：`h[i+j] += f[i] * g[j]`——把两个多项式相乘，结果存在`h`里。  
  2. **多项式取模**：`for (i >= mx)`——对于次数超过`mx`的项，用递推式`h[i-j] += h[i] * a[j]`把高次项的贡献转移到低次项，相当于对多项式A取模。  
  3. **更新结果**：把`h`的前`mx`项赋值给`f`，得到乘法后的模结果。  
* **学习笔记**：多项式取模是处理大次数线性递推的“神器”，记住“线性递推=多项式取模”，遇到大L先想这个方法！  


## 5. 算法可视化：像素动画演示  

<visualization_intro>  
我们做一个**“像素油桶大挑战”**动画，用8位像素风展示算法流程，边玩边学！  
</visualization_intro>


### 动画演示主题与设计思路  
**主题**：像素小人“Y”和“S”轮流装油桶，用多项式取模快速计算大L的情况，最后比谁的油桶更满。  
**设计思路**：  
- 用8位像素风营造复古游戏感，降低学习压力；  
- 关键操作（多项式乘法、取模、动态规划选择）用音效和颜色高亮，强化记忆；  
- 自动播放模式像“AI队友”一样展示完整流程，增加成就感。  


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧是`X`的像素油桶（显示当前体积），右侧是`Y`的油桶，下面是容器堆（每个容器是不同颜色的像素块，大小对应a_i）。  
   - 控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块（1~5倍速），背景播放8位风格的《卡农》。  

2. **多项式快速幂**：  
   - 用“积木块”表示多项式`f`和`g`，`f`是红色，`g`是蓝色。  
   - 乘法时：两块积木“拼接”成更大的积木，伴随“叮”的音效；  
   - 取模时：切去多余的积木，伴随“嗒”的音效；  
   - 快速幂的每一步（二进制位判断）用“闪电”动画提示，比如`L&1`时，红色积木和蓝色积木“碰撞”。  

3. **动态规划计算q_i**：  
   - 每个`q_i`是一个像素按钮，显示“停止（红）”和“继续（蓝）”两个选项。  
   - 计算时，按钮会闪烁两种颜色，最终亮起来的颜色是`max`选择的结果，伴随“嗡”的提示音。  
   - 选“停止”时，右侧油桶会显示`Y`的范围，选“继续”时，左侧油桶会增加体积，容器堆会减少一个容器。  

4. **结果展示**：  
   - 当计算完成，两个油桶会显示最终体积，正确的话播放“胜利”音效（8位版《欢乐颂》），屏幕弹出“挑战成功！”的像素提示；  
   - 错误的话播放“失败”音效（短促的“嘀”），提示“请检查递推式！”。  


### 交互与控制  
- **单步执行**：点击“单步”，动画走一步，显示当前步骤的代码片段（比如`mul`函数的当前行）；  
- **自动播放**：滑动速度滑块，动画按设定速度自动执行，适合整体观察流程；  
- **重置动画**：点击“重置”，回到初始状态，重新开始。  


## 6. 拓展练习与相似问题思考  

<similar_problems_intro>  
学会了“动态规划+多项式取模”，可以解决很多**大次数的线性递推问题**，比如：  
</similar_problems_intro>


### 通用思路迁移  
- **场景1**：“跳台阶问题”（每次跳1~m步，求跳1e9步的方法数）——用多项式取模快速计算。  
- **场景2**：“骰子游戏”（每次掷n面骰子，求掷1e9次的总和概率）——动态规划+多项式取模。  
- **场景3**：“最长上升子序列计数”（求长度为1e9的序列的LIS数）——线性递推+多项式取模。  


### 洛谷拓展练习推荐  
1. **P1020 导弹拦截**（动态规划+贪心）：  
   - 推荐理由：练习动态规划的状态定义和最优选择，理解“贪心+DP”的组合。  
2. **P3808 后缀自动机**（字符串+线性递推）：  
   - 推荐理由：用线性递推计算字符串的子串数目，练习多项式取模的应用。  
3. **P4781 【模板】拉格朗日插值**（数学+多项式）：  
   - 推荐理由：学习多项式插值，加深对多项式操作的理解。  


## 7. 学习心得与经验分享  

<insights_intro>  
Alex_Wei的题解里提到“套路题，但是学到很多”，这句话很有启发！  
</insights_intro>


> **参考经验（来自Alex_Wei）**：“我在解决这个问题时，最初没想到用多项式取模，后来发现L是1e9，普通DP根本不行，才想到用线性递推转多项式取模。这让我意识到，遇到大次数的递推，先想数学方法加速。”  
> **点评**：这个经验很实在！很多问题看起来“不可能”（比如L=1e9），但用数学技巧（比如多项式取模）就能解决。以后遇到大数值的递推问题，先问自己：“能不能转化为线性递推？能不能用多项式取模？”  


## 结语  
这道题的核心是“**用数学技巧解决大问题**”——动态规划理清逻辑，多项式取模加速计算。希望这份指南能帮你掌握这个技巧，下次遇到大L的问题，也能轻松应对！  

记住：编程是“解决问题的艺术”，遇到困难不要怕，拆成小问题，一步步解决。下次我们再一起挑战更难的题目！💪

---
处理用时：89.09秒
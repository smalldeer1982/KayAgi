# 题目信息

# [THUPC 2023 初赛] 背包

## 题目描述

本题中，你需要解决完全背包问题。

有 $n$ 种物品，第 $i$ 种物品单个体积为 $v_i$、价值为 $c_i$。

$q$ 次询问，每次给出背包的容积 $V$，你需要选择若干个物品，每种物品可以选择任意多个（也可以不选），在选出物品的体积的和**恰好**为 $V$ 的前提下最大化选出物品的价值的和。你需要给出这个最大的价值和，或报告不存在体积和恰好为 $V$ 的方案。

为了体现你解决 NP-Hard 问题的能力，$V$ 会远大于 $v_i$，详见数据范围部分。

## 说明/提示

#### 样例解释 1

第二组询问的最优方案为：选择 $3$ 个物品 $1$ 和 $12499999998$ 个物品 $2$。

#### 子任务

对于所有测试数据，$1 \le n \le 50, 1 \le v_i \le 10^5, 1 \le c_i \le 10^6, 1 \le q \le 10^5, 10^{11} \le V \le 10^{12}$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 2
6 10
8 15
100000000001
100000000002
```

### 输出

```
-1
187500000000
```

# AI分析结果

# 💡 Kay的C++算法解析：[THUPC2023初赛] 背包 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：同余最短路（结合贪心）

🗣️ **初步分析**：  
你可以把这道题想象成“用「黄金矿石」（性价比最高的物品）填充巨型仓库，剩下的小角落用「其他矿石」（性价比稍低的物品）填补”——**同余最短路**的核心就是把“巨型仓库”的问题缩小到“角落大小”（模黄金矿石体积的余数）。  

具体来说：  
- 首先选**性价比最高**的物品（比如体积`m`、价值`w`）作为“基准”，因为大体积`V`的大部分空间都会用它填充（比如`V//m`个基准物品）；  
- 剩下的小体积`V%m`需要用其他物品组合，但要保证总体积恰好是`V`——这时候我们需要计算“用其他物品组合余数体积时，比全用基准物品多赚（或少亏）多少”，这就是**同余状态的价值偏移**。  

### 核心算法流程与可视化设计思路  
1. **基准选择**：找到性价比最高的物品（单位体积价值最大），作为模`m`的基准；  
2. **状态定义**：`f[i]`表示体积模`m`余`i`时，**比全用基准物品多赚的价值**（如果`f[i]`是负数，说明不如全用基准）；  
3. **转移逻辑**：对于每个物品，在模`m`的环上“转两圈”（避免重复计算，确保覆盖所有可能的转移），更新每个余数的最大价值偏移；  
4. **答案计算**：查询`V`时，用`V//m * w + f[V%m]`（基准物品的总价值+余数状态的偏移），如果`f[V%m]`是负无穷，说明无解。  

### 可视化设计小剧透  
我们会做一个**像素风“矿石填充游戏”**：  
- 基准物品是“黄金矿石”（黄色像素块），其他物品是“银矿石”“铜矿石”（不同颜色）；  
- 屏幕左侧是“余数环”（0到`m-1`的像素格子），右侧是“控制面板”（单步、自动播放、重置）；  
- 每一步转移会用“矿石移动动画”展示：比如从余数`i`加物品体积`v_j`，跳到`(i+v_j)%m`，同时高亮更新后的`f`值；  
- 自动播放时，像“贪吃蛇AI”一样逐个物品处理环转移，完成后播放“胜利音效”（8位机风格的“叮~”）。


## 2. 精选优质题解参考

### 题解一：Alex_Wei（来源：cnblogs）  
* **点评**：这份题解是“转圈法”的经典实现，思路**直击本质**——把同余最短路的“环转移”简化为“转两圈”，完全避开了SPFA的不确定性。代码**极其简洁**（仅30行核心逻辑），变量命名清晰（`m`是基准体积，`w`是基准价值），对每个物品的环处理用`gcd`分割子环，转两圈确保覆盖所有转移。尤其是对“为什么转两圈”的解释（避免重复点，等价于最短路），让新手能快速理解核心逻辑。


### 题解二：Leasier（来源：洛谷题解）  
* **点评**：这份题解**务实性强**，直接针对“SPFA被卡”的问题，用转圈法优化。代码结构清晰，先选基准物品，再处理每个物品的子环，转两圈更新`dis`数组。尤其难得的是，题解中提到“回归完全背包本源”，让学习者能联系基础背包问题，理解同余最短路的本质是“模意义下的完全背包”。


### 题解三：喵仔牛奶（来源：洛谷题解）  
* **点评**：这份题解**循序渐进**，先讲贪心思路（大体积用基准物品），再讲同余状态的定义（`f[i]`是价值偏移），最后用SPFA实现。虽然SPFA在极端情况下可能被卡，但题解中明确提到“转圈法更优”，并对比了两种方法的差异，适合新手理解“同余最短路的不同实现方式”。代码中的`add`函数和`SPFA`模板规范，便于学习者复用。


## 3. 核心难点辨析与解题策略

### 1. 关键点1：如何选择“基准物品”？  
- **难点**：大体积`V`的主要填充物品必须是“性价比最高”的，否则无法保证余数状态的最优性。  
- **策略**：遍历所有物品，选择`c_i / v_i`最大的（用整数比较`c_i * v_j > c_j * v_i`避免浮点误差）。  
- 💡 学习笔记：基准选对了，大体积问题就解决了90%！


### 2. 关键点2：如何处理同余状态的“环转移”？  
- **难点**：模`m`的状态形成环，直接用SPFA可能超时或卡常。  
- **策略**：用“转圈法”——对每个物品的体积`v_j`，计算与`m`的最大公约数`d`，分割成`d`个子环，每个子环转两圈（确保覆盖所有可能的转移，且不重复）。  
- 💡 学习笔记：转圈法是同余最短路的“终极优化”，避开环的困扰！


### 3. 关键点3：如何计算最终答案？  
- **难点**：大体积`V`的总价值=基准物品的价值+余数状态的偏移，需要正确结合两者。  
- **策略**：答案= `V//m * w + f[V%m]`（`w`是基准价值，`f[V%m]`是余数状态的最大偏移）。如果`f[V%m]`是负无穷，说明无法用其他物品组合出余数体积。  
- 💡 学习笔记：余数状态的偏移是“画龙点睛”，把大问题和小问题连起来！


### ✨ 解题技巧总结  
- **贪心+同余**：大体积问题先贪心选基准，再用同余处理小状态；  
- **转圈代替最短路**：避免SPFA的不确定性，代码更简洁；  
- **整数比较性价比**：用`c_i * v_j > c_j * v_i`代替浮点除法，避免精度误差。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合Alex_Wei、Leasier等优质题解的思路，采用“转圈法”实现，代码简洁高效，覆盖所有核心逻辑。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <algorithm>
#include <cstring>
using namespace std;
typedef long long ll;

const int N = 55;
const int M = 1e5 + 10;
const ll INF = 1e18;

int n, q, m_idx; // m_idx是基准物品的下标
int v[N], c[N];
ll f[M]; // f[i]表示模m余i的最大价值偏移

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> q;
    for (int i = 1; i <= n; ++i) {
        cin >> v[i] >> c[i];
        // 选性价比最高的物品（c[i]/v[i]最大），用整数比较避免浮点误差
        if (!m_idx || (ll)c[i] * v[m_idx] > (ll)c[m_idx] * v[i]) {
            m_idx = i;
        }
    }
    int m = v[m_idx]; // 基准体积
    ll w = c[m_idx];  // 基准价值

    // 初始化f数组：f[0]=0，其他为负无穷（表示初始时只有余数0可达）
    memset(f, 0xcf, sizeof(f)); // 0xcf对应ll的-1e18左右
    f[0] = 0;

    for (int i = 1; i <= n; ++i) {
        if (i == m_idx) continue; // 跳过基准物品，它已经作为基础
        int d = gcd(v[i], m);     // 物品体积与基准的最大公约数，分割子环
        for (int j = 0; j < d; ++j) { // 处理每个子环
            for (int t = j, cnt = 0; cnt < 2; cnt += (t == j)) { // 转两圈
                int next_t = (t + v[i]) % m;
                ll cost = c[i] - (ll)(t + v[i]) / m * w; // 价值偏移：物品价值 - 占用基准的价值
                if (f[t] != -INF) {
                    f[next_t] = max(f[next_t], f[t] + cost);
                }
                t = next_t;
            }
        }
    }

    // 处理查询
    while (q--) {
        ll V;
        cin >> V;
        int rem = V % m;
        if (f[rem] < -INF + 100) { // 不可达（f[rem]还是负无穷）
            cout << "-1\n";
        } else {
            cout << V / m * w + f[rem] << "\n"; // 基准总价值 + 偏移
        }
    }

    return 0;
}
```
* **代码解读概要**：  
  1. **基准选择**：输入时选性价比最高的物品（`m_idx`），作为模`m`的基准；  
  2. **状态初始化**：`f[0] = 0`（初始时只有余数0可达），其他为负无穷；  
  3. **环转移处理**：对每个物品，用`gcd`分割子环，转两圈更新每个余数的最大价值偏移；  
  4. **查询处理**：计算基准物品的数量（`V//m`）加余数状态的偏移（`f[rem]`），输出结果。


### 针对各优质题解的片段赏析

#### 题解一：Alex_Wei（转圈法核心片段）  
* **亮点**：用“转两圈”代替最短路，彻底避开环的问题，代码极简。  
* **核心代码片段**：  
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 0, lim = __gcd(v[i], m); j < lim; j++) {
        for (int t = j, _ = 0; _ < 2; _ += t == j) {
            int q = t + _v[i], d = _d[i];
            if (q >= m) q -= m, d++;
            f[q] = max(f[q], f[t] + c[i] - d * w), t = q;
        }
    }
}
```
* **代码解读**：  
  - `lim = gcd(v[i], m)`：把模`m`的环分割成`lim`个子环（比如`m=6, v[i]=4`，`gcd=2`，子环是0→4→2→0和1→5→3→1）；  
  - `_ < 2`：转两圈（第一圈处理初始转移，第二圈确保覆盖所有可能的更新）；  
  - `q = t + _v[i]`：计算新的余数（`_v[i]`是`v[i]%m`），`d`是`v[i]/m`的整数部分（加上`q>=m`时的1）；  
  - `f[q] = max(...)`：更新余数`q`的最大价值偏移（物品价值`c[i]`减去占用`d`个基准的价值`d*w`）。  
* 💡 学习笔记：转圈法的关键是“分割子环+转两圈”，既高效又避免了最短路的复杂度问题！


#### 题解二：Leasier（基准选择片段）  
* **亮点**：用清晰的条件判断选择基准物品，代码可读性高。  
* **核心代码片段**：  
```cpp
int base = -1;
for (register int i = 1; i <= n; i++){
    scanf("%d %d", &v[i], &c[i]);
    if (base == -1 || (ll)c[base] * v[i] < (ll)c[i] * v[base]) base = i;
}
```
* **代码解读**：  
  - `base`初始为-1（未选择）；  
  - 条件`(ll)c[base] * v[i] < (ll)c[i] * v[base]`：等价于`c[base]/v[base] < c[i]/v[i]`（交叉相乘，避免浮点误差）；  
  - 每次找到性价比更高的物品，就更新`base`。  
* 💡 学习笔记：选基准时一定要用**整数比较**，否则会因为浮点精度问题出错！


## 5. 算法可视化：像素动画演示方案

### 🎮 动画演示主题：《像素矿石填充记》  
**设计思路**：用8位机像素风格模拟“仓库填充”过程，把抽象的同余状态转化为可见的“矿石移动”，用游戏化元素（音效、关卡）增强趣味性。


### 🌟 动画核心细节  
1. **场景初始化**：  
   - 屏幕左侧是**余数环**（0到`m-1`的像素格子，每个格子显示当前`f`值）；  
   - 屏幕右侧是**控制面板**：  
     - 按钮：开始/暂停、单步执行、重置动画；  
     - 滑块：调整自动播放速度（慢→快）；  
     - 提示框：显示当前处理的物品、当前余数。  
   - 背景音乐：8位机风格的“工厂车间BGM”（循环播放，节奏轻快）。

2. **算法启动**：  
   - 基准物品（黄金矿石）从“仓库入口”滑入，屏幕上方显示“基准：体积`m`，价值`w`”；  
   - 余数环的`0`号格子高亮（初始状态`f[0]=0`），伴随“叮~”的音效。

3. **核心转移演示**：  
   - 处理每个物品时，物品图标（比如银矿石）从屏幕上方落下，停在“当前物品”区域；  
   - 单步执行时，点击“下一步”：  
     1. 选中子环的起始点（比如`j=0`）；  
     2. 从`t=j`开始，加物品体积`v[i]`，跳到`next_t=(t+v[i])%m`；  
     3. 用“矿石移动动画”（从`t`滑到`next_t`）展示转移，同时高亮`next_t`的`f`值（如果更新了）；  
     4. 播放“转移音效”（短促的“咔嗒”声）。  
   - 自动播放时，像“贪吃蛇AI”一样逐个处理子环，完成一个物品后播放“完成音效”（向上的“滴~”声）。

4. **查询演示**：  
   - 输入`V`后，屏幕下方显示“基准数量：`V//m`，余数：`V%m`”；  
   - 余数环的`V%m`格子闪烁，同时计算“基准总价值+偏移”，结果显示在屏幕中央，伴随“胜利音效”（8位机的“通关音乐”）；  
   - 如果无解，显示“×”图标，播放“错误音效”（短促的“嗡~”声）。


### 🛠️ 技术实现小提示  
- **Canvas绘制**：用`ctx.fillRect`画像素格子，`ctx.fillText`显示`f`值；  
- **音效**：用Web Audio API播放预加载的8位音效（比如`beep.mp3`对应转移，`win.mp3`对应胜利）；  
- **控制逻辑**：用JavaScript维护动画状态（当前物品、当前子环、当前步），单步执行时递增状态，自动播放时用`setInterval`定时更新。


## 6. 拓展练习与相似问题思考

### 🔍 通用思路迁移  
同余最短路+贪心的思路可以解决**所有“大体积完全背包”问题**，比如：  
1. 要求体积恰好为`V`的最大价值（本题）；  
2. 要求体积不超过`V`的最大价值（调整状态定义即可）；  
3. 要求体积至少为`V`的最小价值（类似思路，求最短路）。


### 📚 洛谷练习推荐  
1. **P2371 墨墨的等式**：经典同余最短路问题，求满足`a1x1+a2x2+...+anxn = b`的`b`的数量，锻炼基准选择和状态转移能力；  
2. **P9140 [THUPC2023初赛] 背包**：本题原题，强化转圈法的应用；  
3. **P3403 跳楼机**：同余最短路求可达的楼层数，练习处理“至少”型问题；  
4. **CF2115E Gellyfish and Mayflower**：进阶问题，结合同余最短路和动态规划，锻炼复杂状态处理能力。


## 7. 学习心得与经验分享  

### 💡 来自题解作者的经验  
- **Alex_Wei**：“同余最短路写最短路是时代的眼泪！转圈法更简洁，且不会被卡。”——提醒我们要关注**算法的优化实现**，而不是局限于经典方法；  
- **Leasier**：“贪心是同余最短路的基础，基准物品选对了，问题就解决了一半。”——强调**贪心与同余的结合**是解决大体积问题的关键；  
- **喵仔牛奶**：“SPFA虽然能过，但转圈法的时间复杂度更稳定。”——教会我们**根据问题选择合适的算法**，而不是盲目用“模板”。


## 💪 最后想说的话  
这道题的核心是“把大问题拆小”——用同余把巨型体积缩小到余数环，用贪心把复杂转移简化为基准填充。记住：**编程的本质是“问题转化”**，把不会的问题变成会的问题，你就成功了！  

下次遇到大体积背包问题，不妨想想今天的“像素矿石游戏”——基准物品是黄金，余数环是小角落，转两圈就能覆盖所有可能。加油，你一定能掌握同余最短路的！ 🚀

---
处理用时：77.98秒
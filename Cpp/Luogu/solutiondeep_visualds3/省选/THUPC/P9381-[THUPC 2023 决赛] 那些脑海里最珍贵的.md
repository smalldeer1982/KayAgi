# 题目信息

# [THUPC 2023 决赛] 那些脑海里最珍贵的

## 题目背景

E.Space：设定很怪，别问为什么，问就是看附件。

_没有人听懂的傻话_

_还记得吗_

_写满青春的围墙_

_好努力练习的倔强_

_浅浅伤疤_

_勇敢是我们的翅膀_

_——张韶涵《还记得吗》_

## 题目描述

故事的世界观大概是这样的。这个世界的人分为三类，根据其某种特点被直接命名为 Weak，Average 和 Strong。你可以理解为这是一个关于种族或者职业的分类。

两个队伍之间发生了一场回合制战斗。你知道双方做了什么，现在希望你把所有的细节还原出来。

下面是本题的一些技术细节。

**【人物】**

一个人有以下几种属性值：「种族」、「等级」、「体力上限」、「基础攻击指数」、「基础防御指数」、「主动技能等级」、「被动技能等级」。其中「体力上限」、「基础攻击指数」、「基础防御指数」完全由「种族」和「等级」决定。但是为了输入方便，本题中所有信息都会给出。在战斗中，每个人有一个「体力值」。在战斗开始时，「体力值」等于「体力上限」。当「体力值」小于等于 $0$ 时这个人就会「倒下」。对于同一个「种族」而言，「体力上限」、「基础攻击指数」、「基础防御指数」大致随「等级」指数增长。每个人持有一把「武器」。「武器」的细节在下一节给出。

**【武器】**

「武器」的属性只有两种：「武器类型」和「武器攻击力」。所有「武器」都有「普通攻击」和「特殊攻击」两种攻击方式。发起「攻击」指使用这两种方式中的任意一种。「普通攻击」的效果与「武器类型」无关，但不同的「武器类型」有着不同的「特殊攻击」效果。「武器」有三种类型，分别叫做「B」、「G」、「M」。

**【战场与队伍】**

交战双方的每一方包含不超过 $6$ 名队员，一字排开，从西到东的编号分别为 $5,3,1,2,4,6$（若不足 $6$ 名则删去较大的若干个编号）。方便起见，就叫两队为「南队」和「北队」。

**【回合】**

每个「回合」中，只有一个人可以「行动」。第奇数个「回合」是「南队」的队员「行动」，第偶数个「回合」是「北队」的队员「行动」。第一个「回合」和第二个「回合」中，「行动」的人是队伍里未「倒下」的编号最小的人。之后的「回合」中，若本队中没有编号比本队上一个「行动」的人大且未「倒下」的人，则由本队中编号最小的未「倒下」的人「行动」。否则由编号大于本队上一个「行动」者的人中，编号最小且未「倒下」的人「行动」。若一个队伍中的所有队员均已「倒下」，则判另一个队伍「胜利」。

**【行动】**

「行动」一共有三种。当前「回合」中「行动」的人必须选择三种之一来完成。

1. 「普通攻击」；
2. 「特殊攻击」；
3. 「主动技能」。

这些「行动」的效果会在之后介绍。「特殊攻击」和「主动技能」是有次数限制的，但是在本题中，保证所有「行动」均合法，所以你不需要考虑这个限制。

**【伤害计算】**

「伤害」指的是因为「普通攻击」或「特殊攻击」而造成的「体力值」减少。

「伤害」，即「体力值」减少的量，由「攻击强度」和受到「伤害」的人的「防御指数」决定。

一个人的「防御指数」等于这个人的「基础防御指数」乘以队伍的「防御加成」。

具体地，若一个人受到「攻击强度」为 $x$ 的「伤害」，那么这个人的「体力值」就会减少 $y$。其中 $y$ 的值等于 $x$ 除以这个人的「防御指数」下取整。

「攻击强度」等于「基础攻击强度」乘以发起「攻击」的人的「技能加成」乘以队伍的「攻击加成」乘以「种族克制加成」乘以「方位加成」。这些概念会在之后介绍。

**【普通攻击】**

选择一个敌方未「倒下」的队员作为「目标」。「目标」受到「基础攻击强度」为发起「攻击」的人的「基础攻击指数」乘「武器攻击力」的「伤害」。

**【特殊攻击】**

选择一个敌方未「倒下」的队员作为「目标」。

「武器」有三种，不同「武器类型」的「特殊攻击」效果如下：

- 「B」：「目标」受到「基础攻击强度」为发起「攻击」的人的「基础攻击指数」乘「武器攻击力」乘 $125\%$ 的「伤害」。
- 「G」：「目标」和「目标」东西两侧与「目标」距离最近的各一名未「倒下」的队员（如果存在）均受到「基础攻击强度」为发起「攻击」的人的「基础攻击指数」乘「武器攻击力」乘 $x\%$ 的「伤害」。其中 $x$ 的值等于 $135$ 除以将要受到「伤害」的人数。「伤害」按照「目标」、「目标」西侧、「目标」东侧的顺序计算。注意如果过程中有人「倒下」，那么这个人的「被动技能」将不再对该顺序中位于这个人之后的人的「伤害」结算起作用。特别地，所有「伤害」的「方位加成」以「目标」的「躲闪方位」来计算。
- 「M」：「目标」受到「基础攻击强度」为发起「攻击」的人的「基础攻击指数」乘「武器攻击力」乘 $115\%$ 的「伤害」。「目标」东西两侧与「目标」距离最近的各一名未「倒下」的队员（如果存在）分别受到「基础攻击强度」为发起「攻击」的人的「基础攻击指数」乘「武器攻击力」乘 $23\%$ 的「伤害」。「伤害」按照「目标」、「目标」西侧、「目标」东侧的顺序计算。注意如果过程中有人「倒下」，那么这个人的「被动技能」将不再对该顺序中位于这个人之后的人的「伤害」结算起作用。特别地，所有「伤害」的「方位加成」以「目标」的「躲闪方位」来计算。

**【技能】**

「技能」分为「主动技能」和「被动技能」。每个「种族」的人都有一个「主动技能」和一个「被动技能」。「技能」的效果因「种族」和「技能等级」的不同而不同。「技能等级」为一个 $0$ 到 $5$ 之间的整数。「技能等级」为 $0$ 表示没有该「技能」。

使用「主动技能」需要选择一个人作为「技能目标」。

「主动技能」描述如下：（$1$ 到 $5$ 级的「技能」效果由斜杠隔开，保证使用「主动技能」的人的「主动技能等级」不为 $0$）

- 「Weak 种族」：使本队一名未「倒下」的队员的「体力值」增加这名队员的「体力上限」乘以 $10\%/12\%/15\%/17\%/20\%$ 下取整。
- 「Average 种族」：选择一名敌方未「倒下」的队员，在使用该「主动技能」这一队的「回合」结束时，其「体力值」减去其「体力上限」的 $6\%/7\%/8\%/9\%/10\%$ 下取整。该效果持续 $3$ 个回合，即会触发 $3$ 次。若该队员已有同类型（可以是不同等级）的「技能」施加的效果，那么这个效果将会覆盖之前的效果。
- 「Strong 种族」：使本队一名未「倒下」的队员的「技能加成」变为 $2.1/2.17/2.24/2.32/2.4$。

一名队员的「被动技能」只有当该队员未「倒下」时才能发挥效果，「倒下」之后不再发挥效果。

「被动技能」描述如下：

- 「Weak 种族」：在本队的「回合」开始时，本队所有未「倒下」的成员的「体力值」增加该成员「体力上限」的 $1.3\%/1.6\%/1.9\%/2.2\%/2.5\%$。若本队有多名队员有这个「技能」，这个效果的数值可以相加至最多 $5\%$。超过 $5\%$ 按照 $5\%$ 计算。「体力值」增加的量在效果叠加后需要下取整。
- 「Average 种族」：队伍的「防御加成」初始为 $1$。该技能使队伍的「防御加成」增加 $0.01/0.02/0.03/0.04/0.05$。若本队有多名队员有这个「技能」，这个效果的数值可以相加至最多 $0.1$。超过 $0.1$ 按照 $0.1$ 计算。
- 「Strong 种族」：队伍的「攻击加成」初始为 $1$。该技能使队伍的「攻击加成」增加 $0.01/0.02/0.03/0.04/0.05$。若本队有多名队员有这个「技能」，这个效果的数值可以相加至最多 $0.1$。超过 $0.1$ 按照 $0.1$ 计算。

一名队员的「体力值」增加时，不能超过这名队员的「体力上限」。若增加后的「体力值」超过了「体力上限」，则把这次增加「体力值」的效果改为将这名队员的「体力值」变成这名队员的「体力上限」。

**【技能加成】**

战斗开始时，所有人的「技能加成」都是 $1$。只有两种方式能够改变「技能加成」：

- 「Strong 种族」的「主动技能」。见「技能」的描述。
- 当一个人发起「攻击」且计算完这次「攻击」的所有「伤害」之后，这个人的「技能加成」变为 $1$。

**【种族克制加成】**

「种族克制加成」与发起「攻击」的人的「种族」以及受到「伤害」的人的「种族」有关。「种族克制加成」的值如下表：


| 发起「攻击」方/受到「伤害」方 | Weak  | Average | Strong |
| :---------------------------: | :---: | :-----: | :----: |
|             Weak              | $1.0$ |  $0.9$  | $1.1$  |
|            Average            | $1.1$ |  $1.0$  | $0.9$  |
|            Strong             | $0.9$ |  $1.1$  | $1.0$  |



**【方位加成】**

在「攻击」时，发起「攻击」的一方有一个「攻击方位」，「攻击」的「目标」有一个「躲闪方位」。「攻击方位」和「躲闪方位」分别为一个 $1$ 到 $6$ 之间的整数。当「攻击方位」为 $a$，「躲闪方位」为 $d$ 时，「方位加成」的值由下表所示：


| $(a-d)\bmod 6$ | 「方位加成」 |
| :------------: | :----------: |
|      $0$       |    $1.25$    |
|   $1$ 或 $5$   |    $1.00$    |
|   $2$ 或 $4$   |    $0.75$    |
|      $3$       |    $0.00$    |



## 说明/提示

**【样例 #2】**

见题目目录下的 *2.in* 与 *2.ans*。

**【样例解释 #2】**

这个样例，无疑是善良的出题人无私的馈赠。中间忘了。出题人相信，这个美妙的样例，可以给拼搏于 AC 这道题的逐梦之路上的你，提供一个有力的援助。

**【数据范围】**

保证 $1\le n,m \le 6$。

保证 $1\le T \le 50000$。

保证「武器攻击力」的范围在 $300$ 到 $80000$ 之间。

「体力上限」「基础攻击指数」「基础防御指数」的范围见下表。

| 「种族」与「等级」 | 「体力上限」 | 「基础攻击指数」 | 「基础防御指数」 |
| :----------------: | :----------: | :--------------: | :--------------: |
|     Weak Lv.1      |   $100000$   |    $0.75000$     |    $0.010000$    |
|    Average Lv.1    |    $5000$    |    $0.80000$     |    $0.20000$     |
|    Strong Lv.1     |    $100$     |     $1.0000$     |     $10.000$     |
|    Weak Lv.100     |  $7807514$   |     $1.0089$     |    $0.10464$     |
|   Average Lv.100   |   $252234$   |     $1.3108$     |     $1.8101$     |
|   Strong Lv.100    |    $3512$    |     $1.6385$     |     $125.11$     |

 

**【后记】**

_有一天我将会老去_

_希望你会觉得满意_

_我没有 对不起那个_

_十五岁的自己_

_——刘若英《继续-给十五岁的自己》_

**【题目来源】**

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。

## 样例 #1

### 输入

```
2 1
Strong Lv=90 maxhp=2451 atk=15588e-4 def=96931e-3 skillLv=5 passivesklLv=5 M weaponatk=80000e0
Strong Lv=100 maxhp=3512 atk=16385e-4 def=12511e-2 skillLv=5 passivesklLv=5 G weaponatk=80000e0
Weak Lv=1 maxhp=100000 atk=75000e-5 def=10000e-6 skillLv=5 passivesklLv=5 B weaponatk=80000e0
3
Skill target=2
Specialattack target=1 atkpos=3 ddgpos=3
Specialattack target=1 atkpos=5 ddgpos=5
```

### 输出

```
South 1 applied Strong skill to South 2
North: 100000/100000
South: 2451/2451 3512/3512

South 1 took 1063 damage from North 1 -> 1388/2451
North: 100000/100000
South: 1388/2451 3512/3512

North 1 took 52556526 damage from South 2 -> 0/100000
North: 0/100000
South: 1388/2451 3512/3512

Team South won.
```

# AI分析结果

# 💡 Kay的C++算法解析：那些脑海里最珍贵的 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：模拟应用  
模拟题就像“按食谱做菜”——题目给了详细的“规则说明书”，我们需要用代码**精确还原每一步操作**。比如题目里的“回合顺序”“攻击计算”“技能效果”都是“食谱步骤”，我们要做的就是把这些文字规则转换成可执行的代码逻辑。


### 🗣️ 初步分析  
这道题是**回合制战斗模拟**，核心是“按规则走流程”：  
- 每个回合选一个行动者，执行攻击/技能；  
- 计算伤害时要叠加**种族克制**“方位加成”“技能加成”“队伍加成”等多重效果；  
- 处理技能的持续效果（比如Average的3回合流血）和被动技能（比如Weak的回合回血）。  

**核心难点**：  
1. 如何**精准维护状态**（角色的血、技能加成、队伍的攻击/防御buff）；  
2. 如何**正确计算伤害**（多重乘子的叠加，下取整的处理）；  
3. 如何**按顺序执行流程**（回合开始的被动、行动、回合结束的持续伤害）。  

**解决方案**：  
- 用**结构体**封装角色、队伍的属性（比如`Human`存角色种族、血、技能；`Team`存队伍的攻击/防御加成）；  
- 用**函数**分模块处理不同操作（比如`calc_damage`算伤害、`use_skill`处理技能）；  
- 用**变量**记录持续状态（比如`skill_buff`存技能加成、`poison_turn`存流血剩余回合）。  


### 🎮 可视化设计思路  
我们可以做一个**8位像素风的战斗模拟器**：  
- 用不同颜色的像素块表示南队（红）、北队（蓝）角色，血条用绿色像素表示；  
- 回合开始时，Weak的被动回血用“绿色闪烁”动画+“叮”的音效；  
- 攻击时，用“箭头动画”指向目标，伤害数值用像素字弹出；  
- 技能效果用“光环动画”（比如Strong的技能加成用黄色光环）；  
- 控制面板有“单步执行”“自动播放”，支持调速，每完成一个回合播放“胜利音效”。  


## 2. 精选优质题解参考

### 题解一（作者：fush）  
**亮点**：代码结构清晰，用`enum`和`struct`封装枚举类型（比如种族、武器），分函数处理攻击、技能、死亡逻辑，注释详细，适合入门学习。  
**点评**：  
- 用`human`结构体存角色所有属性，`team`结构体存队伍状态，逻辑清晰；  
- 伤害计算函数`attack`封装了所有加成逻辑，复用性高；  
- 死亡处理`down`函数正确更新队伍的buff（比如移除死亡角色的被动加成）。  


### 题解二（作者：ydzr00000）  
**亮点**：用`struct`组织角色和队伍信息，函数分工明确（比如`DeductHP`处理扣血、`useSkill`处理技能），注重代码可读性。  
**点评**：  
- 用`enum`和常量数组处理种族克制、方位加成，避免重复代码；  
- 技能处理函数`useSkill`分种族处理（Weak回血、Average流血、Strong加buff），逻辑明确；  
- 死亡判断`Deduct`函数正确更新队伍的攻击/防御加成，考虑了边界情况（比如血不能为负）。  


### 题解三（作者：Phartial）  
**亮点**：处理了浮点精度问题（用`__int128`存储大数，避免精度丢失），代码鲁棒性高。  
**点评**：  
- 用`Float`结构体封装浮点数，处理科学计数法输入，解决了伤害计算中的精度问题；  
- 被动技能处理`reapply_passive_skills`函数正确叠加Weak的回血buff（上限5%）；  
- 伤害计算`TakeDamage`函数正确叠加所有加成，下取整处理准确。  


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：伤害计算的多重加成  
**问题**：伤害需要乘种族、方位、技能、队伍4种加成，还要下取整，容易漏掉或算错。  
**解决策略**：  
- 用**分层计算**：先算基础攻击（角色攻击×武器攻击），再乘技能加成、队伍攻击加成、种族克制、方位加成，最后除以防御（角色防御×队伍防御加成）下取整。  
- 代码示例：  
  ```cpp
  double real_atk = base_atk * skill_buff * team_atk * race_buff * pos_buff;
  double real_def = base_def * team_def;
  int damage = static_cast<int>(real_atk / real_def);  // 下取整
  ```  


### 🔍 核心难点2：队伍状态的维护  
**问题**：角色死亡后要移除其被动加成（比如Average的防御buff、Strong的攻击buff），队伍的buff需要动态更新。  
**解决策略**：  
- 用**累加器**维护队伍buff：比如`team_atk`初始为1，每添加一个Strong角色，`team_atk += 0.01×技能等级`，上限0.1；  
- 角色死亡时，**反向扣除**其贡献的buff：比如Strong角色死亡，`team_atk -= 0.01×技能等级`。  


### 🔍 核心难点3：回合顺序与行动者选择  
**问题**：每回合要选“未倒下的、编号大于上一个行动者的最小者”，若没有则选编号最小的。  
**解决策略**：  
- 用**循环查找**：从上个行动者的下一个编号开始找，找到第一个未倒下的；若找不到，从1开始找。  
- 代码示例：  
  ```cpp
  int get_actor(Team& t) {
      for (int i = t.last + 1; i <= t.size; ++i) {
          if (!t.members[i].dead) return t.last = i;
      }
      for (int i = 1; i <= t.size; ++i) {
          if (!t.members[i].dead) return t.last = i;
      }
      return -1;  // 题目保证合法，不会到这
  }
  ```  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
**说明**：综合优质题解，提炼通用的模拟框架，包含角色、队伍定义，关键函数。  
**完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;

enum HumanRace { Weak = 0, Average = 1, Strong = 2 };
enum WeaponKind { B = 1, G = 2, M = 3 };

struct Weapon {
    WeaponKind kind;
    double attack;
};

struct Human {
    HumanRace race;
    int max_hp, hp;
    double base_atk, base_def;
    int active_lv, passive_lv;
    Weapon weapon;
    double skill_buff;  // 技能加成
    int poison_turn;    // 流血剩余回合
    double poison_dmg;  // 流血伤害
    bool dead;

    Human() : skill_buff(1.0), poison_turn(0), dead(false) {}
};

struct Team {
    vector<Human> members;
    double atk_buff;  // 队伍攻击加成
    double def_buff;  // 队伍防御加成
    double heal_buff; // Weak的回血buff（上限5%）
    int size;         // 队伍人数
    int last_actor;   // 上一个行动者

    Team() : atk_buff(1.0), def_buff(1.0), heal_buff(0.0), last_actor(0) {}
};

// 种族克制加成
double get_race_buff(HumanRace atk, HumanRace def) {
    const double table[3][3] = {
        {1.0, 0.9, 1.1},
        {1.1, 1.0, 0.9},
        {0.9, 1.1, 1.0}
    };
    return table[atk][def];
}

// 方位加成
double get_pos_buff(int atk_pos, int def_pos) {
    int diff = (atk_pos - def_pos + 6) % 6;
    switch (diff) {
        case 0: return 1.25;
        case 1: case 5: return 1.0;
        case 2: case 4: return 0.75;
        default: return 0.0;
    }
}

// 计算伤害并扣血
void calc_damage(Human& attacker, Human& defender, Team& atk_team, Team& def_team, int atk_pos, int def_pos) {
    double base_atk = attacker.base_atk * attacker.weapon.attack;
    double real_atk = base_atk * attacker.skill_buff * atk_team.atk_buff 
                    * get_race_buff(attacker.race, defender.race) * get_pos_buff(atk_pos, def_pos);
    double real_def = defender.base_def * def_team.def_buff;
    int damage = static_cast<int>(real_atk / real_def);  // 下取整
    defender.hp = max(0, defender.hp - damage);
    cout << (def_team.members[0].dead ? "North" : "South") << " took " << damage << " damage!\n";
    if (defender.hp <= 0) {
        defender.dead = true;
        // 更新def_team的buff（比如移除defender的被动）
    }
}

int main() {
    Team south, north;
    // 输入初始化...

    int T; cin >> T;
    for (int round = 1; round <= T; ++round) {
        Team& cur_team = (round % 2 == 1) ? south : north;
        Team& opp_team = (round % 2 == 1) ? north : south;

        // 1. 处理Weak的被动回血
        double heal_rate = min(cur_team.heal_buff, 0.05);
        for (auto& member : cur_team.members) {
            if (!member.dead && member.hp < member.max_hp) {
                int heal = static_cast<int>(member.max_hp * heal_rate);
                member.hp = min(member.max_hp, member.hp + heal);
                cout << "Healed " << heal << " HP!\n";
            }
        }

        // 2. 选行动者
        int actor_idx = cur_team.last_actor + 1;
        for (; actor_idx <= cur_team.size; ++actor_idx) {
            if (!cur_team.members[actor_idx].dead) break;
        }
        if (actor_idx > cur_team.size) {
            for (actor_idx = 1; actor_idx <= cur_team.size; ++actor_idx) {
                if (!cur_team.members[actor_idx].dead) break;
            }
        }
        cur_team.last_actor = actor_idx;
        Human& actor = cur_team.members[actor_idx];

        // 3. 处理行动（攻击/技能）
        string action; cin >> action;
        if (action == "Basicattack") {
            int target, atk_pos, def_pos;
            cin >> target >> atk_pos >> def_pos;
            calc_damage(actor, opp_team.members[target], cur_team, opp_team, atk_pos, def_pos);
            actor.skill_buff = 1.0;  // 攻击后重置技能加成
        } else if (action == "Skill") {
            // 处理技能...
        }

        // 4. 处理Average的流血
        for (auto& member : opp_team.members) {
            if (member.poison_turn > 0) {
                int damage = static_cast<int>(member.max_hp * member.poison_dmg);
                member.hp = max(0, member.hp - damage);
                cout << "Poison damage: " << damage << "\n";
                member.poison_turn--;
            }
        }
    }

    // 输出结果...
    return 0;
}
```  
**代码解读概要**：  
- 用`Human`和`Team`结构体封装角色和队伍状态；  
- `get_race_buff`和`get_pos_buff`计算种族、方位加成；  
- `calc_damage`函数处理伤害计算和扣血；  
- 主函数模拟回合流程：被动回血→选行动者→执行行动→处理流血。  


## 5. 算法可视化：像素动画演示  

### 🎮 动画设计方案  
**主题**：像素风回合制战斗模拟器  
**核心内容**：  
- **场景初始化**：8位像素风格的战场，南队（红）、北队（蓝）角色排成一行，血条用绿色像素表示；  
- **回合流程**：  
  1. **被动回血**：Weak角色周围闪烁绿色，血条增加，播放“叮”音效；  
  2. **行动者选择**：当前行动者用黄色边框高亮，播放“滴”音效；  
  3. **攻击/技能**：  
     - 攻击：用红色箭头指向目标，目标血条减少，弹出伤害数值（像素字）；  
     - 技能：Weak回血用绿色光环，Average流血用紫色光环，Strong加buff用黄色光环；  
  4. **流血处理**：中毒角色闪烁紫色，血条减少，播放“滋滋”音效；  
- **交互控制**：  
  - 控制面板：单步执行、自动播放（调速滑块）、重置；  
  - 音效：攻击“砰”、回血“叮”、技能“咻”、胜利“叮-叮”。  


## 6. 拓展练习与相似问题思考  

### 📚 相似问题  
- **洛谷P1006**：矩阵取数游戏（模拟+动态规划，锻炼状态维护）；  
- **洛谷P1023**：税收与补贴问题（模拟经济政策，锻炼规则还原）；  
- **洛谷P1090**：合并果子（模拟堆操作，锻炼流程控制）；  
- **洛谷P7147**：麻将模拟器（复杂模拟，锻炼模块化思维）。  


## 7. 学习心得与经验分享  

**参考经验（来自fush的题解）**：  
> “写模拟题时，不要把所有代码放主函数，分函数处理不同模块，注释要详细，否则调试会疯！”  

**点评**：模拟题的代码量往往很大，模块化是关键。把“伤害计算”“技能处理”“回合流程”分成不同函数，不仅可读性高，调试时也能快速定位问题。  


## 💪 总结  
这道题是**模拟题的经典案例**，核心是“按规则还原”。通过这道题，我们学会了：  
- 用结构体封装复杂数据；  
- 分模块处理复杂逻辑；  
- 维护状态的正确性（比如队伍buff、角色存活）；  
- 处理浮点精度问题。  

模拟题的关键是**细心**——每一条规则都要准确还原，每一个边界情况都要考虑到。多写多练，就能掌握模拟题的精髓！  

下次我们再一起挑战更复杂的模拟题吧！💻

---
处理用时：77.38秒
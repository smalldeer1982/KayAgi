# 题目信息

# 【模板】旋转卡壳 | [USACO03FALL] Beauty Contest G

## 题目描述

给定平面上 $n$ 个点，求凸包直径。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$2\le n \le 50000$，$|x|,|y| \le 10^4$。

---

$\text{upd 2022.7.22}$：新增加四组 Hack 数据。

## 样例 #1

### 输入

```
4
0 0
0 1
1 1
1 0
```

### 输出

```
2```

# AI分析结果


# 💡 Kay的C++算法解析：凸包直径（平面最远点对）深入学习指南 💡

<introduction>
大家好！我是Kay，今天我们一起挑战计算几何中的经典问题——求凸包直径（平面最远点对）。本指南将带你理解旋转卡壳算法的精妙之处，并通过像素动画直观感受算法执行过程。准备好了吗？让我们开始吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`凸包应用`与`旋转卡壳算法`

🗣️ **初步分析**：
> 想象凸包是一个多边形橡皮筋，旋转卡壳就像用两把平行卡尺夹住橡皮筋旋转测量。算法核心是：**在凸包上逆时针遍历每条边时，距离该边最远的点（对踵点）也会按固定方向移动**。这种单调性让我们能用双指针技巧在O(n)时间内解决问题。

   - 题解主要有两类：标准旋转卡壳算法（严谨高效）和人类智慧乱搞（有趣但非通用）
   - 可视化重点：凸包构建时栈的动态变化 + 旋转卡壳时当前边与对踵点的联动
   - 像素动画设计：FC红白机风格的网格地图，凸包点阵用彩色像素块表示，当前边显示为红色光柱，对踵点闪烁绿光，距离计算时显示激光特效

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性和算法效率等维度评估题解，精选以下3篇≥4星的优质题解供大家学习：
</eval_intro>

**题解一：xiezheyuan（旋转卡壳标准实现）**
* **点评**：这份题解亮点在于**清晰的算法流程描述和工业级代码规范**。作者用Andrew算法构建凸包（栈操作逻辑严谨），旋转卡壳部分用点到直线距离公式驱动双指针移动。代码中`dcmp`函数处理浮点精度问题尤其值得学习，变量命名规范（如`poly`存凸包点集），边界处理完整，可直接用于竞赛。

**题解二：王熙文（旋转卡壳数学证明）**
* **点评**：这是**理论深度最强的题解**，独创性地给出旋转卡壳的5个数学证明（如对踵点移动方向单调性）。虽然代码实现稍复杂（含随机扰动防退化），但其`结论4`用几何证明解释双指针有效性极具启发性。学习时建议先理解算法流程再研究证明。

**题解三：ByGones（K-D Tree解法）**
* **点评**：提供**独特的解题视角**，将问题转化为K-D Tree求最远点对。亮点在于`f()`估价函数的剪枝优化，使查询复杂度降至O(√n)。代码中优先级队列维护top-k距离的写法简洁高效，适合拓展学习空间划分数据结构。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决凸包直径问题的三大核心难点及应对策略：
</difficulty_intro>

1.  **凸包构建的正确性**
    * **分析**：Andrew算法要求按x,y排序后维护上下凸壳。难点在于栈操作时叉积判断的方向处理（`cross≤0弹栈`）。关键技巧是先用`dcmp`处理浮点精度，再通过`used`数组避免重复点。
    * 💡 **学习笔记**：上凸壳用叉积≤0弹栈，下凸壳用叉积≥0弹栈

2.  **旋转卡壳的双指针维护**
    * **分析**：难点在于证明对踵点移动的单调性。王熙文的结论3指出：当边逆时针移动时，对踵点不会反向移动。代码实现时用`cur`指针记录当前对踵点，通过比较点到相邻边的距离决定是否移动。
    * 💡 **学习笔记**：双指针移动的条件是`dis(cur) ≤ dis(cur+1)`

3.  **精度处理与退化情况**
    * **分析**：浮点误差可能导致凸包构建错误。xiezheyuan用`dcmp`函数比较浮点数，王熙文采用随机扰动点坐标。K-D Tree解法则完全使用整数运算避免该问题。
    * 💡 **学习笔记**：比较浮点数时用`dcmp`代替`==`，或采用整数坐标扩大法

### ✨ 解题技巧总结
<summary_best_practices>
通过本题提炼的通用计算几何技巧：
</summary_best_practices>
- **凸包构建标准化**：优先掌握Andrew算法（排序+双栈维护），比Jarvis步进法更高效
- **向量运算模板化**：将叉积`cross()`、点积`dot()`、距离`len()`等函数写成标准模板
- **避免浮点误差**：比较时用`dcmp`或扩大坐标100倍转为整数
- **旋转卡壳四步法**：1)求凸包 2)初始化指针 3)遍历边更新对踵点 4)用端点距离更新答案

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解优化的旋转卡壳通用实现（基于xiezheyuan代码简化）：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：融合Andrew凸包与旋转卡壳，添加详细注释
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps = 1e-9;

struct Point { double x, y; };
double cross(Point a, Point b) { return a.x*b.y - a.y*b.x; }
double dis(Point a, Point b) { 
    double dx = a.x - b.x, dy = a.y - b.y;
    return dx*dx + dy*dy; 
}

vector<Point> convexHull(vector<Point> p) {
    sort(p.begin(), p.end(), [](Point a, Point b) {
        return tie(a.x, a.y) < tie(b.x, b.y);
    });
    vector<Point> stk;
    for (auto pt : p) {  // 下凸壳
        while (stk.size() >= 2 && cross(stk.back()-stk[stk.size()-2], pt-stk.back()) <= eps)
            stk.pop_back();
        stk.push_back(pt);
    }
    for (int i = p.size()-2; i >= 0; --i) {  // 上凸壳
        while (stk.size() >= 2 && cross(stk.back()-stk[stk.size()-2], p[i]-stk.back()) <= eps)
            stk.pop_back();
        stk.push_back(p[i]);
    }
    return stk;
}

double diameter(vector<Point> poly) {
    if (poly.size() == 2) return dis(poly[0], poly[1]);
    int j = 1;
    double res = 0;
    for (int i = 0; i < poly.size(); ++i) {
        auto a = poly[i], b = poly[(i+1)%poly.size()];
        // 移动对踵点直到距离下降
        while (cross(b-a, poly[j]-a) < cross(b-a, poly[(j+1)%poly.size()]-a))
            j = (j+1) % poly.size();
        res = max({res, dis(poly[i], poly[j]), dis(poly[i+1], poly[j])});
    }
    return res;
}

int main() {
    int n; cin >> n;
    vector<Point> p(n);
    for (auto& pt : p) cin >> pt.x >> pt.y;
    auto hull = convexHull(p);
    cout << (long)round(diameter(hull));
}
```
* **代码解读概要**：
  > 1. `convexHull()`：Andrew算法构建凸包，先排序后双栈维护
  > 2. `diameter()`：旋转卡壳核心，用叉积比较点到边的距离
  > 3. 注意：`cross(b-a, p[j]-a)`实为平行四边形面积，等价于点线距离
  > 4. 主函数：读点→建凸包→计算直径平方→输出整数结果

---
<code_intro_selected>
精选题解的核心代码亮点解析：
</code_intro_selected>

**题解一：xiezheyuan（旋转卡壳）**
* **亮点**：用叉积代替距离计算避免开方，精度更高
* **核心代码片段**：
```cpp
while (DistanceToLine(poly[cur], line) <= 
       DistanceToLine(poly[(cur+1)%poly.size()], line)) {
    cur = (cur+1) % poly.size();  // 移动对踵点
}
ans = max(ans, max(len(poly[i]-poly[cur]), 
                   len(poly[i+1]-poly[cur])));
```
* **代码解读**：
  > 关键在`DistanceToLine`函数：用叉积算三角形面积，除以底边长得距离  
  > `while`条件保证对踵点始终是当前边的最远点  
  > 更新答案时同时考虑当前边两端点与对踵点的距离
* 💡 **学习笔记**：叉积绝对值=两向量构成平行四边形面积

**题解二：王熙文（随机扰动防退化）**
* **亮点**：添加微小随机扰动解决退化情况
* **核心代码片段**：
```cpp
mt19937 rnd(time(0));
a[i].x += rnd()*1.0/1e15;  // 添加微小扰动
a[i].y += rnd()*1.0/1e15;
```
* **代码解读**：
  > 用`mt19937`生成高质量随机数  
  > 扰动幅度1e-15级不影响结果但避免多点共线  
  > 解决正六边形等特殊情况导致的算法错误
* 💡 **学习笔记**：几何题添加ε量级扰动是防退化的银弹

**题解三：ByGones（K-D Tree）**
* **亮点**：空间划分数据结构求最远点对
* **核心代码片段**：
```cpp
void query(int x) {
    if (f(x, mid) <= qu.top()) return; // 剪枝
    if (dis(mid, x) > qu.top())
        qu.pop(), qu.push(dis(mid, x));
    if (f(x, lc[mid]) > f(x, rc[mid])) {
        query(lc[mid]); query(rc[mid]); // 递归子树
    } else { ... }
}
```
* **代码解读**：
  > `f()`是估价函数：计算点到空间区域的最大可能距离  
  > 优先级队列`qu`维护当前最远距离  
  > 根据估价大小决定递归顺序，优化搜索效率
* 💡 **学习笔记**：K-D Tree查询复杂度O(n^(1-1/d))，适合低维空间

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
现在进入最有趣的环节！我将用8位像素风动画演示旋转卡壳算法，让你像玩复古游戏一样理解算法流程。设计灵感来自FC游戏《坦克大战》，我们给算法主角取名"卡壳战士"！
</visualization_intro>

* **动画主题**：`凸包冒险：卡壳战士的直径寻宝之旅`
* **核心演示内容**：凸包构建 + 旋转卡壳双指针移动
* **设计思路**：像素风格降低理解门槛，游戏化元素增强记忆点。音效提示关键操作，过关机制对应算法阶段

* **动画帧步骤与交互关键点**：

1. **场景初始化**：
   - 背景：深蓝网格战场（640x480像素）
   - 角色：绿色像素块（输入点），红色三角（"卡壳战士"=当前边）
   - UI：底部控制面板（开始/步进/重置），右侧数据显示区

2. **凸包构建阶段**：
   ```mermaid
   graph LR
   A[排序点阵] --> B[下凸壳压栈]
   B --> C[上凸壳压栈]
   C --> D[闭合凸包]
   ```
   - 可视化：点阵按x,y排序时显示彩虹轨迹
   - 栈操作：每次压栈时像素块变金色并播放"叮"音效，弹栈时变灰并播放碎裂音
   - 结果：凸包点用金线连接，内部点变半透明

3. **旋转卡壳阶段**：
   ```python
   while 旋转未完成：
       当前边 = 红色激光束
       对踵点 = 闪烁绿光的像素块
       while 下一顶点更远： 
          移动对踵点并播放"嗖"音效
       计算端点距离，刷新最大直径
       播放下一步提示音
   ```
   - 关键特效：当前边旋转时显示角度值，距离计算时显示激光连线
   - 音效设计：移动对踵点=电子滴答声，刷新记录=金币声，完成=胜利号角

4. **交互控制**：
   - 步进模式：按右键单步执行，观察变量变化
   - 自动演示：AI模式像贪吃蛇自动运行（速度可调）
   - 关卡设计：共两关（凸包构建+旋转卡壳），每关完成显示得分

5. **数据可视化**：
   - 动态显示栈内点索引
   - 实时更新当前边索引和对踵点索引
   - 直径结果用金色大号像素字显示

<visualization_conclusion>
通过这款像素动画，你将清晰看到：凸包如何从散乱点阵变成规则多边形，以及"卡壳战士"如何沿着凸包边缘巡逻并锁定最远宝藏点。游戏化学习让抽象算法变得触手可及！
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握凸包直径后，来看看这个技巧的威力有多大！以下是应用相同思想的变种题目：
</similar_problems_intro>

* **知识迁移**：
  1. **最小包围圆**：用类似旋转卡壳思想找三点定圆
  2. **凸多边形间最小距离**：双凸包上同步旋转卡壳
  3. **动态凸包维护**：结合旋转卡壳支持在线插入

* **推荐练习（洛谷）**：
  1. **P2742 [USACO5.1]圈奶牛**  
     🗣️ **推荐理由**：凸包模板题，巩固Andrew算法实现
  2. **P6247 [SDOI2012]最近最远点对**  
     🗣️ **推荐理由**：同时练习最近/最远点对，理解旋转卡壳与分治差异
  3. **P4357 [CQOI2016]K远点对**  
     🗣️ **推荐理由**：K-D Tree的经典应用，拓展空间划分数据结构

-----

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中蕴藏着宝贵经验，我特别摘录这两条：
</insights_intro>

> **经验一（xiezheyuan）**：  
> “旋转卡壳的关键是点到直线距离计算，用叉积代替距离公式可避免开方提升精度”  
> **Kay点评**：这是工业级算法的核心技巧，竞赛中浮点精度直接决定AC或WA

> **经验二（王熙文）**：  
> “添加ε级随机扰动可解决几何退化情况”  
> **Kay点评**：该技巧是计算几何的防弹衣，尤其适用于正多边形等边界数据

-----

<conclusion>
本次凸包直径的探索之旅就到这里！记住：旋转卡壳的精髓在于 **"凸包上的单调性"** 这个关键洞察。建议大家用像素动画演示加深理解，再通过拓展练习巩固技能。下次遇到几何问题时，别忘了你手中的"卡尺武器"哦！🚀
</conclusion>

-----

---
处理用时：156.22秒
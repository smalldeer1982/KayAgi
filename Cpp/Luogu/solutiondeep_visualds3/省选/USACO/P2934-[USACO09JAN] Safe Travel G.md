# é¢˜ç›®ä¿¡æ¯

# [USACO09JAN] Safe Travel G

## é¢˜ç›®æè¿°

Gremlins have infested the farm. These nasty, ugly fairy-like

creatures thwart the cows as each one walks from the barn (conveniently located at pasture\_1) to the other fields, with cow\_i traveling to from pasture\_1 to pasture\_i. Each gremlin is personalized and knows the quickest path that cow\_i normally takes to pasture\_i. Gremlin\_i waits for cow\_i in the middle of the final cowpath of the quickest route to pasture\_i, hoping to harass cow\_i.

Each of the cows, of course, wishes not to be harassed and thus chooses an at least slightly  different route from pasture\_1 (the barn) to pasture\_i.

Compute the best time to traverse each of these new not-quite-quickest routes that enable each cow\_i that avoid gremlin\_i who is located on the final cowpath of the quickest route from pasture\_1 to

pasture\_i.

As usual, the M (2 <= M <= 200,000) cowpaths conveniently numbered 1..M are bidirectional and enable travel to all N (3 <= N <= 100,000) pastures conveniently numbered 1..N. Cowpath i connects pastures a\_i (1 <= a\_i <= N) and b\_i (1 <= b\_i <= N) and requires t\_i (1 <= t\_i <= 1,000) time to traverse. No two cowpaths connect the same two pastures, and no path connects a pasture to itself (a\_i != b\_i). Best of all, the shortest path regularly taken by cow\_i from pasture\_1 to pasture\_i is unique in all the test data supplied to your program.

By way of example, consider these pastures, cowpaths, and [times]:

```cpp
1--[2]--2-------+ 
|       |       | 
[2]     [1]     [3] 
|       |       | 
+-------3--[4]--4
```
``` 
TRAVEL     BEST ROUTE   BEST TIME   LAST PATH 
p_1 to p_2       1->2          2         1->2 
p_1 to p_3       1->3          2         1->3 
p_1 to p_4      1->2->4        5         2->4 
```
When gremlins are present:

```cpp
TRAVEL     BEST ROUTE   BEST TIME    AVOID 
p_1 to p_2     1->3->2         3         1->2 
p_1 to p_3     1->2->3         3         1->3 
p_1 to p_4     1->3->4         6         2->4 
```
For 20% of the test data, N <= 200. 

For 50% of the test data, N <= 3000. 

TIME LIMIT: 3 Seconds

MEMORY LIMIT: 64 MB

## æ ·ä¾‹ #1

### è¾“å…¥

```
4 5 
1 2 2 
1 3 2 
3 4 4 
3 2 1 
2 4 3 
```

### è¾“å‡º

```
3 
3 
6 
```

# AIåˆ†æç»“æœ


# ğŸ’¡ Kayçš„C++ç®—æ³•è§£æï¼šSafe Travel G æ·±å…¥å­¦ä¹ æŒ‡å— ğŸ’¡

> ä»Šå¤©æˆ‘ä»¬æ¥åˆ†æã€ŒSafe Travel Gã€è¿™é“C++ç¼–ç¨‹é¢˜ã€‚æœ¬æŒ‡å—å°†å¸®åŠ©å¤§å®¶æ¢³ç†é¢˜ç›®æ€è·¯ï¼Œç†è§£æ ¸å¿ƒç®—æ³•ï¼Œå¹¶æŒæ¡è§£é¢˜æŠ€å·§ã€‚

## 1. é¢˜ç›®è§£è¯»ä¸æ ¸å¿ƒç®—æ³•è¯†åˆ«

âœ¨ **æœ¬é¢˜ä¸»è¦è€ƒå¯Ÿ**ï¼š`æœ€çŸ­è·¯æ ‘` + `å¹¶æŸ¥é›†ä¼˜åŒ–`

ğŸ—£ï¸ **åˆæ­¥åˆ†æ**ï¼š
> è¿™é“é¢˜çš„å…³é”®åœ¨äºç†è§£**æœ€çŸ­è·¯æ ‘**çš„æ¦‚å¿µã€‚æƒ³è±¡ä¸€ä¸‹ï¼Œæˆ‘ä»¬ä¸ºæ¯ä¸ªç‚¹æ ‡è®°ä¸€æ¡ä»èµ·ç‚¹1å‡ºå‘çš„"é»„é‡‘è·¯å¾„"ï¼Œè¿™äº›è·¯å¾„å½¢æˆä¸€æ£µæ ‘ğŸŒ²ã€‚é¢˜ç›®è¦æ±‚åˆ é™¤æ¯ä¸ªç‚¹åˆ°èµ·ç‚¹è·¯å¾„çš„æœ€åä¸€æ¡è¾¹åï¼Œæ±‚æ–°çš„æœ€çŸ­è·¯ã€‚è¿™å°±åƒåœ¨æ ‘ä¸­ç æ–­ä¸€æ ¹æ ‘æï¼Œæˆ‘ä»¬éœ€è¦æ‰¾åˆ°ä¸€æ¡"ç»•è¡Œæ·å¾„"â€”â€”ä¸€æ¡è¿æ¥å­æ ‘å†…å¤–èŠ‚ç‚¹çš„éæ ‘è¾¹ã€‚

- **æ ¸å¿ƒæ€è·¯**ï¼šåˆ é™¤æœ€åä¸€æ¡è¾¹åï¼Œæ–°è·¯å¾„å¿…é¡»ç»è¿‡ä¸€æ¡éæ ‘è¾¹ã€‚é€šè¿‡è®¡ç®— `dis[u] + dis[v] + w`ï¼ˆuã€væ˜¯éæ ‘è¾¹ç«¯ç‚¹ï¼Œwæ˜¯è¾¹æƒï¼‰ï¼Œå¹¶å‡å»ç›®æ ‡ç‚¹çš„ `dis[i]` å¾—åˆ°æ–°è·¯å¾„é•¿åº¦
- **ä¼˜åŒ–ç­–ç•¥**ï¼šå°†éæ ‘è¾¹æŒ‰ `dis[u]+dis[v]+w` æ’åºï¼Œç”¨å¹¶æŸ¥é›†è·³è¿‡å·²æ›´æ–°èŠ‚ç‚¹ï¼Œç¡®ä¿æ¯ä¸ªç‚¹åªè¢«æœ€ä¼˜éæ ‘è¾¹æ›´æ–°ä¸€æ¬¡
- **å¯è§†åŒ–è®¾è®¡**ï¼šé‡‡ç”¨8ä½åƒç´ é£æ ¼å±•ç¤ºæœ€çŸ­è·¯æ ‘ï¼ˆç»¿è‰²æ ‘æï¼‰ï¼Œéæ ‘è¾¹ç”¨é—ªçƒçº¢çº¿è¡¨ç¤ºã€‚å¹¶æŸ¥é›†åˆå¹¶æ—¶æ’­æ”¾"å’”åš“"éŸ³æ•ˆï¼Œæ›´æ–°èŠ‚ç‚¹æ—¶é«˜äº®æ˜¾ç¤ºå¹¶æ’­æ”¾"å®"å£°

---

## 2. ç²¾é€‰ä¼˜è´¨é¢˜è§£å‚è€ƒ

**é¢˜è§£ä¸€ï¼ˆæ¥æºï¼šjuruo999ï¼‰**
* **ç‚¹è¯„**ï¼šæ€è·¯æ¸…æ™°ç›´å‡»æ ¸å¿ƒï¼Œä»£ç è§„èŒƒæ€§æä½³ã€‚äº®ç‚¹åœ¨äºï¼š
    1. å®Œæ•´å®ç°æœ€çŸ­è·¯æ ‘æ„å»ºï¼Œé€»è¾‘ä¸¥å¯†ï¼ˆDijkstra+DFSï¼‰
    2. å¹¶æŸ¥é›†ä¼˜åŒ–å®ç°ç®€æ´é«˜æ•ˆï¼ˆ`find`å‡½æ•°ä»…5è¡Œï¼‰
    3. è¾¹ç•Œå¤„ç†ä¸¥è°¨ï¼ˆæ— è§£æ—¶è¾“å‡º-1ï¼‰
    4. å˜é‡å‘½åè§„èŒƒï¼ˆ`dis`/`fa`/`dep`å«ä¹‰æ˜ç¡®ï¼‰

**é¢˜è§£äºŒï¼ˆæ¥æºï¼šBriMonï¼‰**
* **ç‚¹è¯„**ï¼šå›¾è§£è¾…åŠ©ç†è§£éå¸¸åˆ°ä½ï¼Œæ•™å­¦ä»·å€¼é«˜ã€‚äº®ç‚¹åœ¨äºï¼š
    1. ç”¨æ ‘é“¾ç¤ºæ„å›¾è§£é‡ŠLCAæ›´æ–°èŒƒå›´
    2. å®Œæ•´æ¨å¯¼è·¯å¾„æ›´æ–°å…¬å¼ `dis[u]+dis[v]+w-dis[i]`
    3. å¹¶æŸ¥é›†ç¼©ç‚¹è¿‡ç¨‹æ³¨é‡Šè¯¦ç»†
    4. ä»£ç åŒ…å«è¯¦ç»†è°ƒè¯•è¾“å‡ºï¼ˆç¤ºä¾‹æ•°æ®éªŒè¯ï¼‰

**é¢˜è§£ä¸‰ï¼ˆæ¥æºï¼šxtx1092515503ï¼‰**
* **ç‚¹è¯„**ï¼šæä¾›æ ‘é“¾å‰–åˆ†+çº¿æ®µæ ‘çš„æ›¿ä»£æ–¹æ¡ˆï¼Œæ‹“å±•æ€ç»´ã€‚äº®ç‚¹åœ¨äºï¼š
    1. å®ç°æ ‘å‰–ç»´æŠ¤å­æ ‘ä¿¡æ¯
    2. çº¿æ®µæ ‘åŒºé—´æ›´æ–°å¤„ç†è·¯å¾„
    3. å¤æ‚åº¦åˆ†ææ¸…æ™°ï¼ˆ$O(n\log^2 n)$ vs å¹¶æŸ¥é›†$O(n\alpha(n))$)
    4. å®Œæ•´è¾¹ç•Œæ¡ä»¶å¤„ç†ï¼ˆLCAä¸æ›´æ–°ï¼‰

---

## 3. æ ¸å¿ƒéš¾ç‚¹è¾¨æä¸è§£é¢˜ç­–ç•¥

1. **éš¾ç‚¹1ï¼šç†è§£æœ€çŸ­è·¯æ ‘çš„æ„å»º**
   * **åˆ†æ**ï¼šéœ€åœ¨Dijkstraä¸­è®°å½•å‰é©±èŠ‚ç‚¹ï¼Œæ„å»ºæ ‘ç»“æ„ã€‚å…³é”®ç‚¹åœ¨äºåˆ¤æ–­è¾¹æ˜¯å¦åœ¨æœ€çŸ­è·¯ä¸Šï¼ˆ`dis[v] == dis[u] + w`ï¼‰
   * ğŸ’¡ **å­¦ä¹ ç¬”è®°**ï¼šæœ€çŸ­è·¯æ ‘æ˜¯Dijkstraç®—æ³•çš„å‰¯äº§å“

2. **éš¾ç‚¹2ï¼šéæ ‘è¾¹è´¡çŒ®èŒƒå›´ç¡®å®š**
   * **åˆ†æ**ï¼šæ¯æ¡éæ ‘è¾¹åªèƒ½æ›´æ–°å…¶ä¸¤ç«¯ç‚¹åˆ°LCAçš„è·¯å¾„ï¼ˆä¸åŒ…æ‹¬LCAï¼‰ã€‚ä½¿ç”¨å¹¶æŸ¥é›†æ—¶éœ€æ³¨æ„æ·±åº¦æ¯”è¾ƒ
   * ğŸ’¡ **å­¦ä¹ ç¬”è®°**ï¼šLCAæ˜¯æ›´æ–°è¾¹ç•Œï¼Œç”¨æ·±åº¦æ¯”è¾ƒé¿å…é‡å¤æ›´æ–°

3. **éš¾ç‚¹3ï¼šå¹¶æŸ¥é›†è·³è·ƒæ›´æ–°**
   * **åˆ†æ**ï¼šå°†å·²æ›´æ–°èŠ‚ç‚¹åˆå¹¶åˆ°çˆ¶èŠ‚ç‚¹å®ç°è·¯å¾„å‹ç¼©ã€‚å…³é”®ä»£ç ä»…5è¡Œä½†æ•ˆæœæ˜¾è‘—
   * ğŸ’¡ **å­¦ä¹ ç¬”è®°**ï¼šå¹¶æŸ¥é›†è·³è·ƒæ˜¯é¿å…é‡å¤æ›´æ–°çš„æ ¸å¿ƒæŠ€å·§

### âœ¨ è§£é¢˜æŠ€å·§æ€»ç»“
1. **æŠ€å·§Aï¼ˆæœ€çŸ­è·¯æ ‘æŠ½è±¡ï¼‰**ï¼šå°†å¤æ‚è·¯å¾„é—®é¢˜è½¬åŒ–ä¸ºæ ‘ç»“æ„é—®é¢˜
2. **æŠ€å·§Bï¼ˆéæ ‘è¾¹ç­›é€‰ï¼‰**ï¼šæŒ‰ `dis[u]+dis[v]+w` æ’åºä¿è¯æœ€ä¼˜æ€§
3. **æŠ€å·§Cï¼ˆå¹¶æŸ¥é›†å‹ç¼©ï¼‰**ï¼š`fa[u] = fa[fa[u]]` å®ç°è·³è·ƒæ›´æ–°
4. **æŠ€å·§Dï¼ˆè¾¹ç•Œå¤„ç†ï¼‰**ï¼šæ— è§£æ—¶è¿”å›-1ï¼Œæ³¨æ„æ·±åº¦æ¯”è¾ƒé˜²è¶Šç•Œ

---

## 4. C++æ ¸å¿ƒä»£ç å®ç°èµæ

```cpp
// æœ¬é¢˜é€šç”¨æ ¸å¿ƒC++å®ç°å‚è€ƒ
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+5, M = 2e5+5;

struct Edge { int u, v, w; };
vector<Edge> edges, nonTreeEdges;
vector<int> G[N];
int dis[N], fa[N], dep[N], ans[N], dsu[N];

// å¹¶æŸ¥é›†æ ¸å¿ƒå‡½æ•°
int find(int x) { 
    return x == dsu[x] ? x : dsu[x] = find(dsu[x]);
}

void dijkstra() {
    memset(dis, 0x3f, sizeof(dis));
    priority_queue<pair<int, int>> pq;
    pq.push({0, 1}); dis[1] = 0;
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (-d != dis[u]) continue;
        for (int eid : G[u]) {
            Edge& e = edges[eid];
            int v = e.u == u ? e.v : e.u;
            if (dis[v] > dis[u] + e.w) {
                dis[v] = dis[u] + e.w;
                fa[v] = u;
                pq.push({-dis[v], v});
            }
        }
    }
}

int main() {
    // åˆå§‹åŒ– & å»ºå›¾
    int n, m; cin >> n >> m;
    for (int i = 0; i < m; i++) {
        int u, v, w; cin >> u >> v >> w;
        edges.push_back({u, v, w});
        G[u].push_back(edges.size()-1);
        G[v].push_back(edges.size()-1);
    }
    
    // æ„å»ºæœ€çŸ­è·¯æ ‘
    dijkstra();
    
    // ç­›é€‰éæ ‘è¾¹
    for (auto& e : edges) {
        if (fa[e.u] == e.v || fa[e.v] == e.u) continue;
        nonTreeEdges.push_back(e);
    }
    
    // æŒ‰å…³é”®å€¼æ’åº
    sort(nonTreeEdges.begin(), nonTreeEdges.end(), [](auto& a, auto& b) {
        return dis[a.u] + dis[a.v] + a.w < dis[b.u] + dis[b.v] + b.w;
    });
    
    // å¹¶æŸ¥é›†åˆå§‹åŒ–
    for (int i = 1; i <= n; i++) dsu[i] = i;
    memset(ans, -1, sizeof(ans));
    
    // æ ¸å¿ƒæ›´æ–°é€»è¾‘
    for (auto& e : nonTreeEdges) {
        int u = find(e.u), v = find(e.v);
        while (u != v) {
            if (dep[u] < dep[v]) swap(u, v);
            ans[u] = dis[e.u] + dis[e.v] + e.w - dis[u];
            dsu[u] = fa[u];  // å…³é”®è·³è·ƒ
            u = find(u);
        }
    }
    
    // è¾“å‡ºç­”æ¡ˆ
    for (int i = 2; i <= n; i++) 
        cout << ans[i] << '\n';
}
```

**é¢˜è§£ä¸€æ ¸å¿ƒä»£ç ï¼ˆå¹¶æŸ¥é›†ä¼˜åŒ–ï¼‰**
```cpp
// å¹¶æŸ¥é›†è·³è·ƒæ›´æ–° (juruo999)
while (u != v) {
    if (dep[u] < dep[v]) swap(u, v);
    ans[u] = dis[e.u] + dis[e.v] + e.w - dis[u];
    dsu[u] = fa[u];  // è·³è·ƒåˆ°çˆ¶èŠ‚ç‚¹
    u = find(u);
}
```
> **è§£è¯»**ï¼šæ·±åº¦å¤§çš„èŠ‚ç‚¹å‘ä¸Šè·³ï¼Œæ›´æ–°ååˆå¹¶åˆ°çˆ¶èŠ‚ç‚¹ã€‚`dsu[u]=fa[u]` ç¡®ä¿ä¸‹æ¬¡ç›´æ¥è·³è¿‡å·²æ›´æ–°èŠ‚ç‚¹

**é¢˜è§£äºŒæ ¸å¿ƒä»£ç ï¼ˆLCAè¾¹ç•Œå¤„ç†ï¼‰**
```cpp
// LCAè¾¹ç•Œåˆ¤æ–­ (BriMon)
int LCA(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = 19; i >= 0; i--)
        if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];
    if (u == v) return u;
    // ... å€å¢æŸ¥æ‰¾
}
```
> **è§£è¯»**ï¼šé€šè¿‡æ·±åº¦æ¯”è¾ƒå’Œå€å¢æ•°ç»„å¿«é€Ÿå®šä½LCAï¼Œç¡®ä¿ä¸æ›´æ–°LCAåŠå…¶ç¥–å…ˆèŠ‚ç‚¹

**é¢˜è§£ä¸‰æ ¸å¿ƒä»£ç ï¼ˆæ ‘å‰–æ›´æ–°ï¼‰**
```cpp
// æ ‘å‰–æ›´æ–°è·¯å¾„ (xtx1092515503)
void update_path(int u, int v, int w) {
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        seg_update(1, 1, n, dfn[top[u]], dfn[u], w);
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    seg_update(1, 1, n, dfn[u]+1, dfn[v], w);
}
```
> **è§£è¯»**ï¼šé€šè¿‡æ ‘å‰–å°†è·¯å¾„åˆ†è§£ä¸ºé‡é“¾åŒºé—´ï¼Œçº¿æ®µæ ‘åŒºé—´æ›´æ–°ã€‚å¤æ‚åº¦æ›´é«˜ä½†æä¾›æ›¿ä»£æ–¹æ¡ˆ

---

## 5. ç®—æ³•å¯è§†åŒ–ï¼šåƒç´ åŠ¨ç”»æ¼”ç¤º

> é‡‡ç”¨FCçº¢ç™½æœºåƒç´ é£æ ¼å±•ç¤ºç®—æ³•æµç¨‹ï¼Œå¸®åŠ©ç›´è§‚ç†è§£æœ€çŸ­è·¯æ ‘æ›´æ–°æœºåˆ¶

* **åŠ¨ç”»ä¸»é¢˜**ï¼š"æœ€çŸ­è·¯æ ‘å†’é™©"
* **æ ¸å¿ƒæ¼”ç¤ºæµç¨‹**ï¼š
  1. **åœºæ™¯åˆå§‹åŒ–**ï¼šç»¿è‰²åƒç´ æ ‘æ˜¾ç¤ºæœ€çŸ­è·¯æ ‘ï¼Œç°è‰²è¾¹ä¸ºéæ ‘è¾¹
  2. **Dijkstraè¿‡ç¨‹**ï¼šè“è‰²å…‰ç‚¹ä»1å‡ºå‘ï¼Œæ²¿æ ‘ææ‰©æ•£ï¼ˆæ‰©æ•£éŸ³æ•ˆï¼‰
  3. **éæ ‘è¾¹æ¿€æ´»**ï¼šæŒ‰ `dis[u]+dis[v]+w` æ’åºåï¼Œå½“å‰å¤„ç†çš„éæ ‘è¾¹é—ªçƒçº¢å…‰
  4. **å¹¶æŸ¥é›†è·³è·ƒ**ï¼š
     - èŠ‚ç‚¹æ›´æ–°ï¼šé»„è‰²é«˜äº® + "å®"å£°
     - å¹¶æŸ¥é›†åˆå¹¶ï¼šèŠ‚ç‚¹å‘ä¸Šè·³è·ƒ + "å’”åš“"å£°
  5. **LCAè¾¹ç•Œ**ï¼šçº¢è‰²è¾¹æ¡†æ ‡è®°LCAï¼Œæ›´æ–°åˆ°æ­¤åœæ­¢
  6. **å®Œæˆæ•ˆæœ**ï¼šæ›´æ–°è·¯å¾„æ˜¾ç¤ºä¸ºé‡‘è‰²ï¼Œæ’­æ”¾èƒœåˆ©éŸ³æ•ˆ

* **äº¤äº’æ§åˆ¶**ï¼š
  - æ­¥è¿›æ§åˆ¶ï¼šç©ºæ ¼å•æ­¥æ‰§è¡Œ
  - é€Ÿåº¦æ»‘å—ï¼šè°ƒæ•´åŠ¨ç”»é€Ÿåº¦
  - æ¨¡å¼åˆ‡æ¢ï¼šå¹¶æŸ¥é›†æ¨¡å¼/æ ‘å‰–æ¨¡å¼å¯¹æ¯”

* **æŠ€æœ¯å®ç°**ï¼š
  ```javascript
  // ä¼ªä»£ç ç¤ºä¾‹
  function drawTree() {
      drawNode(1, ROOT_POS);
      for (node in tree) {
          drawLine(node, parent[node], GREEN);
      }
  }
  
  function updateNode(node) {
      node.color = YELLOW;
      playSound('ding');
      dsu[node] = parent[node]; // å¹¶æŸ¥é›†åˆå¹¶
  }
  ```

---

## 6. æ‹“å±•ç»ƒä¹ ä¸ç›¸ä¼¼é—®é¢˜æ€è€ƒ

1. **é€šç”¨æŠ€å·§è¿ç§»**ï¼š
   - æœ€çŸ­è·¯æ ‘ï¼šé€‚ç”¨äºæœ€çŸ­è·¯å”¯ä¸€æ€§é—®é¢˜
   - å¹¶æŸ¥é›†è·¯å¾„å‹ç¼©ï¼šä¼˜åŒ–æ ‘ä¸Šè·³è·ƒè¿‡ç¨‹
   - éæ ‘è¾¹è´¡çŒ®ï¼šç½‘ç»œè®¾è®¡é—®é¢˜çš„å¸¸è§æ€è·¯

2. **æ¨èç»ƒä¹ ï¼ˆæ´›è°·ï¼‰**ï¼š
   1. **P4768 [NOI2018] å½’ç¨‹**  
      > ğŸ—£ï¸ **æ¨èç†ç”±**ï¼šæœ€çŸ­è·¯ä¸å¹¶æŸ¥é›†çš„è¿›é˜¶ç»“åˆï¼Œè€ƒå¯Ÿåˆ†å±‚å¤„ç†èƒ½åŠ›
   
   2. **P2146 [NOI2015] è½¯ä»¶åŒ…ç®¡ç†å™¨**  
      > ğŸ—£ï¸ **æ¨èç†ç”±**ï¼šæ ‘é“¾å‰–åˆ†ç»å…¸åº”ç”¨ï¼Œå·©å›ºæ ‘è·¯å¾„æ›´æ–°æŠ€å·§
   
   3. **P3304 [SDOI2013] ç›´å¾„**  
      > ğŸ—£ï¸ **æ¨èç†ç”±**ï¼šæœ€çŸ­è·¯æ ‘å˜å½¢é—®é¢˜ï¼Œå¼ºåŒ–æ ‘æ€§è´¨åˆ†æèƒ½åŠ›

---

## 7. å­¦ä¹ å¿ƒå¾—ä¸ç»éªŒåˆ†äº«

> **æ¥è‡ªé¢˜è§£ä½œè€…çš„è°ƒè¯•ç»éªŒ**ï¼š
> "æˆ‘åœ¨å¤„ç†LCAè¾¹ç•Œæ—¶å¤šæ¬¡å‡ºé”™ï¼Œåæ¥å‘ç°éœ€è¦ä¸¥æ ¼æ¯”è¾ƒèŠ‚ç‚¹æ·±åº¦ã€‚é€šè¿‡æ‰“å°æ·±åº¦å·®å’ŒLCAä½ç½®ï¼Œæœ€ç»ˆå®šä½é—®é¢˜ã€‚è¿™æé†’æˆ‘ä»¬ï¼šæ ‘ä¸Šç®—æ³•å¿…é¡»éªŒè¯æ·±åº¦å…³ç³»ï¼"

> **Kayçš„æ€»ç»“**ï¼š
> è°ƒè¯•æ ‘ç»“æ„é—®é¢˜æ—¶ï¼š
> 1. æ‰“å°æ·±åº¦å’Œçˆ¶èŠ‚ç‚¹ä¿¡æ¯éªŒè¯æ ‘ç»“æ„
> 2. å¯¹LCAè¿›è¡Œè¾¹ç•Œæµ‹è¯•ï¼ˆå…„å¼ŸèŠ‚ç‚¹/ç¥–å­™å…³ç³»ï¼‰
> 3. å°æ•°æ®é›†æ‰‹å·¥éªŒè¯å¹¶æŸ¥é›†è·³è·ƒè·¯å¾„

---

æœ¬æ¬¡è§£æå°±åˆ°è¿™é‡Œï¼Œè®°ä½ï¼šç†è§£æœ€çŸ­è·¯æ ‘æ˜¯æ ¸å¿ƒï¼Œå¹¶æŸ¥é›†ä¼˜åŒ–æ˜¯å…³é”®ï¼ä¸‹æ¬¡é‡åˆ°ç±»ä¼¼é—®é¢˜ï¼Œä¸å¦¨å…ˆç”»æ ‘å½¢å›¾è¾…åŠ©æ€è€ƒã€‚ç»§ç»­åŠ æ²¹ï¼Œç¼–ç¨‹é«˜æ‰‹ä»¬ï¼ğŸ’ª

---
å¤„ç†ç”¨æ—¶ï¼š124.05ç§’
# 题目信息

# [NOI2018] 屠龙勇士

## 题目描述

小 D 最近在网上发现了一款小游戏。游戏的规则如下：

- 游戏的目标是按照编号 $1 \rightarrow n$ 顺序杀掉 $n$ 条巨龙，每条巨龙拥有一个初始的生命值 $a_i$ 。同时每条巨龙拥有恢复能力，当其使用恢复能力时，它的生命值就会每次增加 $p_i$ ，直至生命值非负。只有在攻击结束后且当生命值 **恰好** 为 $0$ 时它才会死去。
- 游戏开始时玩家拥有 $m$ 把攻击力已知的剑，每次面对巨龙时，玩家只能选择一把剑，当杀死巨龙后这把剑就会消失，但作为奖励，玩家会获得全新的一把剑。

小 D 觉得这款游戏十分无聊，但最快通关的玩家可以获得 ION2018 的参赛资格，于是小 D 决定写一个笨笨的机器人帮她通关这款游戏，她写的机器人遵循以下规则：

- 每次面对巨龙时，机器人会选择当前拥有的，攻击力不高于巨龙初始生命值中攻击力最大的一把剑作为武器。如果没有这样的剑，则选择 **攻击力最低** 的一把剑作为武器。
- 机器人面对每条巨龙，它都会使用上一步中选择的剑攻击巨龙固定的 $x$ 次，使巨龙的生命值减少 $x \times ATK$ 。
- 之后，巨龙会不断使用恢复能力，每次恢复 $p_i$ 生命值。若在使用恢复能力前或某一次恢复后其生命值为 $0$ ，则巨龙死亡，玩家通过本关。

那么显然机器人的攻击次数是决定能否最快通关这款游戏的关键。小 D 现在得知了每条巨龙的所有属性，她想考考你，你知道应该将机器人的攻击次数 $x$ 设置为多少，才能用最少的攻击次数通关游戏吗？

当然如果无论设置成多少都无法通关游戏，输出 $-1$ 即可。

## 说明/提示

### 更多样例

更多样例请在附加文件中下载。

### 样例 2

见附加文件中的 `dragon2.in` 与 `dragon2.ans`。

### 样例 1 解释

第一组数据：
- 开始时拥有的剑的攻击力为 $\{1,9,1000\}$，第 $1$ 条龙生命值为 $3$，故选择攻击力为 $1$ 的剑，攻击 $59$ 次，造成 $59$ 点伤害，此时龙的生命值为 $-56$，恢复 14 次后生命值恰好为 $0$，死亡。

- 攻击力为 $1$ 的剑消失，拾取一把攻击力为 $7$ 的剑，此时拥有的剑的攻击力为
$\{7,9,1000\}$，第 2 条龙生命值为 $5$，故选择攻击力为 $7$ 的剑，攻击 $59$ 次，造成 $413$ 点伤害，此时龙的生命值为 $-408$，恢复 $68$ 次后生命值恰好为 $0$，死亡。

- 此时拥有的剑的攻击力为 $\{3,9,1000\}$，第 $3$ 条龙生命值为 $7$，故选择攻击力为 $3$ 的剑，攻击 $59$ 次，造成 $177$ 点伤害，此时龙的生命值为 $-170$，恢复 $17$ 次后生命值恰好为 0，死亡。

- 没有比 $59$ 次更少的通关方法，故答案为 $59$。

第二组数据：
不存在既能杀死第一条龙又能杀死第二条龙的方法，故无法通关，输出 $-1$。

### 子任务

测试点编号 |　　　$n$　　　|　　　$m$　　　|　　　$p_i$　　　|　　　$a_i$　　　| 　　攻击力　　 | 其他限制
-|-|-|-|-|-|-
1|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$=1$| 无
2|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$=1$| 无
3|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$\le 10^5$| 无
4|$\le 10^5$|$=1$|$=1$|$\le 10^5$|$\le 10^5$| 无
5|$\le 10^3$|$\le 10^3$|$\le 10^5$|$\le 10^5$|$\le 10^5$| 特性 1、特性 2
6|$\le 10^3$|$\le 10^3$|$\le 10^5$|$\le 10^5$|$\le 10^5$| 特性 1、特性 2
7|$\le 10^3$|$\le 10^3$|$\le 10^5$|$\le 10^5$|$\le 10^5$| 特性 1、特性 2
8|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
9|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
10|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
11|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
12|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
13|$=1$|$=1$|$\le 10^8$|$\le 10^8$|$\le 10^6$| 特性 1
14|$=10^5$|$=10^5$|$=1$|$\le 10^8$|$\le 10^6$| 无特殊限制
15|$=10^5$|$=10^5$|$=1$|$\le 10^8$|$\le 10^6$| 无特殊限制
16|$\le 10^5$|$\le 10^5$| 所有 $p_i$ 是质数 |$\le 10^{12}$|$\le 10^6$| 特性 1
17|$\le 10^5$|$\le 10^5$| 所有 $p_i$ 是质数 |$\le 10^{12}$|$\le 10^6$| 特性 1
18|$\le 10^5$|$\le 10^5$| 无特殊限制 |$\le 10^{12}$|$\le 10^6$| 特性 1
19|$\le 10^5$|$\le 10^5$| 无特殊限制 |$\le 10^{12}$|$\le 10^6$| 特性 1
20|$\le 10^5$|$\le 10^5$| 无特殊限制 |$\le 10^{12}$|$\le 10^6$| 特性 1

特性 1 是指：对于任意的 $i$，$a_i \le p_i$。

特性 2 是指：$\operatorname{lcm}(p_i) \le 10^6$，即所有 $p_i$ 的 **最小公倍数** 不大于 $10^6$。

对于所有的测试点，$T \le 5$，所有武器的攻击力 $\le 10^6$，所有 $p_i$ 的最小公倍数 $\le 10^{12}$。

保证 $ T, n, m $ 均为正整数。

### 提示

你所用到的中间结果可能很大，注意保存中间结果的变量类型。

## 样例 #1

### 输入

```
2
3 3
3 5 7
4 6 10
7 3 9
1 9 1000
3 2
3 5 6
4 8 7
1 1 1
1 1```

### 输出

```
59
-1```

# AI分析结果

---
# 💡 Kay的C++算法解析：[NOI2018] 屠龙勇士 深入学习指南 💡

<introduction>
  今天我们来分析NOI2018的经典数论题——「屠龙勇士」。这道题融合了**数据结构（平衡树）**与**数论算法（扩展欧几里得、扩展中国剩余定理）**，是锻炼综合能力的好题目。本指南将帮你梳理思路、掌握核心算法，并通过可视化动画直观理解过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（扩展中国剩余定理EXCRT）、编程技巧（multiset应用）

🗣️ **初步分析**：
解决「屠龙勇士」的关键是**将问题转化为带系数的同余方程组**，再用**扩展中国剩余定理（EXCRT）**求解。简单来说：
- **问题转化**：每条龙的死亡条件等价于「攻击次数x满足 `ATK_i × x ≡ a_i (mod p_i)`」（`ATK_i`是杀第i条龙用的剑的攻击力，`a_i`是龙的初始血量，`p_i`是回血值）。
- **EXCRT的作用**：合并多个带系数的同余方程，求出最小非负整数解x。
- **预处理剑的选择**：用`multiset`快速找到符合条件的剑（不超过龙初始血量的最大攻击力，否则选最小的）。

### 核心算法流程与可视化设计思路
1. **剑的选择**：用`multiset`的`upper_bound`查找，动画中用**像素剑块闪烁**表示选中的剑，删除后插入新剑（用「滑入」动画）。
2. **方程转化**：将`ATK_i × x ≡ a_i (mod p_i)`转化为标准同余式`x ≡ b_i (mod mod_i)`，动画中用**数字跳动**展示`exgcd`求特解的过程。
3. **EXCRT合并**：逐次合并两个方程，用**像素块合并动画**展示新的余数和模数，若无解则播放「错误音效」。
4. **下界调整**：计算`max(ceil(a_i/ATK_i))`，若解太小则用**数字递增动画**调整到满足条件。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：来源：emptysetvvvv（赞157）**
* **点评**：这份题解是「最简洁的实战模板」。思路上**直接点出问题本质**——转化为同余方程组，并用`multiset`高效处理剑的选择；代码风格规范（变量名如`b[i]`表示第i条龙的剑攻击力，`mx`记录下界），边界处理严谨（如用`__int128`避免溢出）；算法上，EXCRT的实现简洁易懂，合并方程的逻辑清晰。实践中，代码可直接用于竞赛，是「拿来就用」的优质模板。

**题解二：来源：shadowice1984（赞81）**
* **点评**：这份题解是「最详细的原理讲解」。作者深入推导了**带系数同余方程的转化过程**（将`c_i x ≡ a_i mod m_i`转化为标准形式），并详细解释了EXCRT合并方程的每一步（从两个方程联立到解线性不定方程）。代码中用「龟速乘」处理大数溢出，是理解算法原理的好参考。

**题解三：来源：FlashHu（赞22）**
* **点评**：这份题解是「最注重细节的实践指南」。作者强调了**x的下界处理**（必须满足`x ≥ ceil(a_i/ATK_i)`），并在代码中用`c += m * ceil((mx - c)/m)`调整解；同时，作者指出了`multiset`的「易错点」（删除时要用迭代器而非值，避免删错），是实战中容易忽略的细节。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点集中在「剑的选择」「方程转化」「EXCRT合并」和「下界处理」四个方面，以下是针对性策略：
</difficulty_intro>

1. **难点1：正确选择每只龙的剑**
   * **分析**：需选「不超过龙初始血量的最大攻击力」的剑，若没有则选最小的。用`multiset`的`upper_bound`找第一个大于`a_i`的剑，若不是begin()则往前移一位；否则选begin()。
   * 💡 **学习笔记**：`multiset`是处理「动态集合查询/删除/插入」的利器，`upper_bound`是关键！

2. **难点2：将带系数同余方程转化为标准形式**
   * **分析**：对于`c_i x ≡ a_i mod m_i`，用`exgcd`求`c_i x + m_i y = gcd(c_i, m_i)`的解，再缩放得到`c_i x + m_i y = a_i`的特解`x0`，最终转化为`x ≡ x0 mod (m_i / gcd(c_i, m_i))`。
   * 💡 **学习笔记**：带系数方程的核心是「用exgcd求特解」，转化后才能用EXCRT合并！

3. **难点3：EXCRT合并同余方程**
   * **分析**：合并两个方程`x ≡ a1 mod m1`和`x ≡ a2 mod m2`，需解`m1 k + m2 l = a2 - a1`，用`exgcd`求`k`的特解，再得到新的方程`x ≡ a1 + m1*k0 mod lcm(m1, m2)`。
   * 💡 **学习笔记**：EXCRT的本质是「逐次合并方程」，每次合并都要判断是否有解！

4. **难点4：处理x的下界**
   * **分析**：x必须满足`x ≥ ceil(a_i/ATK_i)`（否则龙血未被打到非正），若EXCRT的解`ans`小于这个最大值，需加上`lcm`直到满足条件。
   * 💡 **学习笔记**：下界是「实际问题的约束」，不能忽略！


### ✨ 解题技巧总结
- **技巧A：数据结构选择**：用`multiset`处理动态剑集合，时间复杂度O(n log m)。
- **技巧B：大数处理**：用「龟速乘」或`__int128`避免乘法溢出（如`(long long)`无法容纳`1e12 × 1e12`）。
- **技巧C：边界处理**：特判`p_i=1`的情况（此时答案是`max(ceil(a_i/ATK_i))`），避免复杂计算。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份「通用核心实现」，综合了优质题解的思路，结构清晰且易理解：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了emptysetvvvv和FlashHu的思路，包含剑的预处理、EXCRT合并、下界处理，是完整的解题模板。
* **完整核心代码**：
```cpp
#include <set>
#include <cstdio>
#include <iostream>
using namespace std;
typedef long long ll;
const int maxn = 1e5 + 5;

ll a[maxn], p[maxn], b[maxn]; // a[i]龙血量, p[i]回血值, b[i]剑攻击力
multiset<ll> swords;
ll mx; // 下界：max(ceil(a[i]/b[i]))

ll exgcd(ll A, ll B, ll &x, ll &y, ll &gcd) {
    if (!B) { x = 1; y = 0; gcd = A; return A; }
    exgcd(B, A%B, y, x, gcd);
    y -= (A / B) * x;
    return gcd;
}

ll excrt(int n) {
    ll ans = 0, lcm = 1;
    for (int i = 1; i <= n; ++i) {
        ll A = (__int128)b[i] * lcm % p[i];
        ll B = p[i];
        ll C = (a[i] - (__int128)b[i] * ans % p[i] + p[i]) % p[i];
        ll x, y, g;
        exgcd(A, B, x, y, g);
        x = (x % B + B) % B;
        if (C % g != 0) return -1;
        ll tmp = (__int128)(C / g) * x % (B / g);
        ans += tmp * lcm;
        lcm *= B / g;
        ans %= lcm;
    }
    if (ans < mx) {
        ll add = ((mx - ans - 1) / lcm + 1) * lcm;
        ans += add;
    }
    return ans;
}

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        swords.clear(); mx = 0;
        int n, m; scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; ++i) scanf("%lld", &a[i]);
        for (int i = 1; i <= n; ++i) scanf("%lld", &p[i]);
        ll t[maxn]; // 杀龙后得到的新剑
        for (int i = 1; i <= n; ++i) scanf("%lld", &t[i]);
        for (int i = 1; i <= m; ++i) {
            ll x; scanf("%lld", &x);
            swords.insert(x);
        }
        // 预处理每只龙的剑
        for (int i = 1; i <= n; ++i) {
            auto it = swords.upper_bound(a[i]);
            if (it != swords.begin()) --it;
            b[i] = *it;
            swords.erase(it);
            swords.insert(t[i]);
            // 计算下界：ceil(a[i]/b[i])
            mx = max(mx, (a[i] - 1) / b[i] + 1);
        }
        ll ans = excrt(n);
        printf("%lld\n", ans);
    }
    return 0;
}
```
* **代码解读概要**：
  1. **剑的预处理**：用`multiset`的`upper_bound`找剑，删除后插入新剑，同时计算下界`mx`。
  2. **EXCRT函数**：逐次合并同余方程，用`__int128`避免乘法溢出，最后调整解到下界以上。
  3. **exgcd函数**：求最大公约数和线性不定方程的解，是EXCRT的基础。


<code_intro_selected>
接下来剖析「剑的预处理」和「EXCRT合并」的核心片段：
</code_intro_selected>

**片段1：剑的预处理（来源：通用代码）**
* **亮点**：用`multiset`高效处理动态剑集合，逻辑清晰。
* **核心代码片段**：
```cpp
for (int i = 1; i <= n; ++i) {
    auto it = swords.upper_bound(a[i]);
    if (it != swords.begin()) --it;
    b[i] = *it;
    swords.erase(it);
    swords.insert(t[i]);
    mx = max(mx, (a[i] - 1) / b[i] + 1);
}
```
* **代码解读**：
  - `upper_bound(a[i])`找第一个大于`a[i]`的剑，若不是begin()则往前移一位（得到不超过`a[i]`的最大剑）；否则选begin()（最小剑）。
  - `erase(it)`删除选中的剑，`insert(t[i])`插入新剑。
  - `(a[i]-1)/b[i]+1`是`ceil(a[i]/b[i])`的整数计算方式（避免浮点数误差）。
* 💡 **学习笔记**：`upper_bound`是找「不超过目标值的最大元素」的关键，`erase(it)`比`erase(val)`更高效（避免遍历）。

**片段2：EXCRT合并方程（来源：通用代码）**
* **亮点**：用`__int128`处理大数乘法，合并逻辑清晰。
* **核心代码片段**：
```cpp
ll excrt(int n) {
    ll ans = 0, lcm = 1;
    for (int i = 1; i <= n; ++i) {
        ll A = (__int128)b[i] * lcm % p[i];
        ll B = p[i];
        ll C = (a[i] - (__int128)b[i] * ans % p[i] + p[i]) % p[i];
        ll x, y, g;
        exgcd(A, B, x, y, g);
        if (C % g != 0) return -1;
        ll tmp = (__int128)(C / g) * x % (B / g);
        ans += tmp * lcm;
        lcm *= B / g;
        ans %= lcm;
    }
    // 调整下界
    if (ans < mx) ans += ((mx - ans - 1) / lcm + 1) * lcm;
    return ans;
}
```
* **代码解读**：
  - `A = b[i] * lcm % p[i]`：当前方程的系数（合并前i-1个方程的通解是`ans + k*lcm`，代入第i个方程得到`b[i]*(ans + k*lcm) ≡ a[i] mod p[i]`，即`b[i]*lcm *k ≡ (a[i]-b[i]*ans) mod p[i]`，所以A是`b[i]*lcm`，C是`a[i]-b[i]*ans`）。
  - `exgcd(A, B, x, y, g)`：解`A*k + B*l = C`，若`C%g !=0`则无解。
  - `tmp`是`k`的特解，`ans`更新为合并后的余数，`lcm`更新为合并后的模数（`lcm = lcm * (B/g)`，即前i个模数的最小公倍数）。
* 💡 **学习笔记**：`__int128`是处理大数乘法的「神器」，避免`long long`溢出（注意：`__int128`不能直接输入输出，需用`long long`转换）。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解「剑的选择」和「EXCRT合并」，我设计了一个**8位像素风格**的动画，融合复古游戏元素（如FC红白机的色彩和音效）：
</visualization_intro>

### **动画演示主题**：像素勇士屠龙记
**风格**：8位像素风（仿FC游戏），用红/蓝/绿像素块表示龙、剑、方程。
**音效**：
- 选剑：「叮」的清脆声；
- 合并方程：「咔嗒」声；
- 无解：「滴滴」警告声；
- 胜利：「叮~当」的胜利音效。


### **动画帧步骤**
1. **初始化场景**（Frame 1-5）：
   - 屏幕左侧显示**龙的列表**（每个龙用红色像素块，标注`a_i`和`p_i`）；
   - 右侧显示**当前拥有的剑**（蓝色像素块，标注攻击力）；
   - 底部控制面板有「开始」「单步」「重置」按钮，速度滑块。

2. **剑的选择过程**（Frame 6-15）：
   - 针对第i条龙，**蓝色剑块闪烁**表示候选剑（`upper_bound`找到的剑）；
   - 选中的剑**滑向龙的位置**，龙的像素块变灰（表示剑被使用）；
   - 新剑**从右侧滑入**剑列表，同时底部显示`mx`的更新（如`mx = max(5, 7)` → 7）。

3. **方程转化与EXCRT合并**（Frame 16-30）：
   - 每个方程用**绿色像素块**表示（标注`c_i x ≡ a_i mod p_i`）；
   - 转化方程时，**数字跳动**展示`exgcd`的计算过程（如`gcd(3,4)=1`，`x=3`）；
   - 合并两个方程时，**绿色块合并成新的绿色块**，标注新的余数和模数（如`x ≡ 5 mod 12`）；
   - 若无解，**红色警告框弹出**，播放「滴滴」声。

4. **下界调整与结果展示**（Frame 31-40）：
   - 显示`mx`的值（如`mx=59`），若EXCRT的解`ans=0`，则**数字递增**直到`ans=59`；
   - 所有龙的像素块变成「骷髅」（表示死亡），播放胜利音效，显示最终`x`值。


### **交互设计**
- **单步执行**：点击「单步」按钮，动画逐帧播放，便于观察每一步。
- **自动播放**：拖动速度滑块调整播放速度（如1x→5x），模拟「AI自动屠龙」。
- **重置**：点击「重置」按钮，回到初始状态，重新演示。


<visualization_conclusion>
通过这个动画，你可以**直观看到剑的选择逻辑**和**EXCRT的合并过程**，结合音效和像素风格，让抽象的数论算法变得生动有趣！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
「屠龙勇士」的核心是**带系数同余方程组的求解**，这类问题在数论中很常见，以下是拓展练习：
</similar_problems_intro>

### **通用思路迁移**
- **场景1**：密码学中的「模运算加密」（如RSA加密的核心是模幂运算，涉及同余方程）；
- **场景2**：日程安排问题（如「每3天上课，每5天健身，求下次同时上课和健身的时间」，即解同余方程组）；
- **场景3**：游戏中的「冷却时间计算」（如「技能A冷却3秒，技能B冷却5秒，求下次同时可用的时间」）。


### **洛谷练习推荐**
1. **洛谷 P1495** - 中国剩余定理  
   🗣️ **推荐理由**：基础CRT问题，帮助你理解「模数互质」的同余方程组求解，是EXCRT的前置练习。
   
2. **洛谷 P2480** - [SDOI2010]古代猪文  
   🗣️ **推荐理由**：融合了**欧拉定理**和**EXCRT**，需要处理大数模运算，是进阶练习。
   
3. **洛谷 P3868** - [NOI2007]货币兑换  
   🗣️ **推荐理由**：虽然不是同余问题，但涉及**扩展欧几里得算法**，帮助你巩固exgcd的应用。
   
4. **洛谷 P4145** - 约数和  
   🗣️ **推荐理由**：涉及数论中的「约数和公式」和「模运算」，帮助你熟练掌握大数模运算技巧。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提炼了两个**关键经验**，帮你避免踩坑：
</insights_intro>

> **经验1**（来自emptysetvvvv）：「用`__int128`处理大数乘法，比龟速乘更简洁。」  
> **点评**：`__int128`是GCC的扩展类型，能容纳`1e24`的数，完美解决`long long`溢出问题，代码更简洁。但要注意，`__int128`不能直接输入输出，需用`long long`转换。

> **经验2**（来自FlashHu）：「删除`multiset`中的元素时，要用迭代器而非值，否则会删错。」  
> **点评**：若`multiset`中有多个相同值的元素，`erase(val)`会删除所有该值的元素，而`erase(it)`只删除迭代器指向的元素，这是`multiset`的易错点！


<conclusion>
「屠龙勇士」是一道**综合数论与数据结构**的经典题，核心是将实际问题转化为同余方程组，再用EXCRT求解。通过本指南的学习，你应该掌握了：
1. `multiset`处理动态集合的技巧；
2. 带系数同余方程的转化方法；
3. EXCRT合并方程组的逻辑；
4. 大数处理和边界条件的重要性。

记住：数论问题的关键是「转化」——将复杂问题转化为已知的算法模型。多练习、多思考，你也能成为「屠龙勇士」！💪
</conclusion>

---

---
处理用时：161.36秒
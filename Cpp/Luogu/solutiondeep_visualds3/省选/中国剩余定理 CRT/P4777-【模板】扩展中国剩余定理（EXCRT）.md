# 题目信息

# 【模板】扩展中国剩余定理（EXCRT）

## 题目描述

给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组的最小非负整数解。
$$\begin{cases}x\equiv b_1\pmod{a_1}\\x\equiv b_2\pmod{a_2}\\\dots\\x\equiv b_n\pmod{a_n}\end{cases}$$

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$1 \le b_i,a_i \le {10}^{12}$，保证所有 $a_i$ 的最小公倍数不超过 ${10}^{18}$。

**请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。**

数据保证有解。

## 样例 #1

### 输入

```
3
11 6
25 9
33 17
```

### 输出

```
809```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】扩展中国剩余定理（EXCRT）深入学习指南 💡

今天我们来一起分析“【模板】扩展中国剩余定理（EXCRT）”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（扩展中国剩余定理）

🗣️ **初步分析**：
解决“扩展中国剩余定理（EXCRT）”这道题，关键在于理解并运用**扩展中国剩余定理**。简单来说，EXCRT就像“合并小问题的魔术”——当我们有多个模数不互质的线性同余方程时，普通中国剩余定理（CRT）无法直接解决（因为CRT需要模数两两互质才能找到逆元）。而EXCRT的核心思想是**两两合并方程**：把两个同余方程合并成一个等价的新方程，重复这个过程直到只剩一个方程，这个方程的解就是原方程组的解。

在本题中，EXCRT的作用是**合并模数不互质的同余方程**。例如，对于两个方程`x ≡ b₁ mod a₁`和`x ≡ b₂ mod a₂`，我们会将其转化为不定方程`k₁a₁ - k₂a₂ = b₂ - b₁`，用扩展欧几里得算法（exgcd）求解这个不定方程，找到特解后合并成一个新的方程`x ≡ x₀ mod lcm(a₁,a₂)`（`x₀`是特解，`lcm`是最小公倍数）。

### 核心算法流程
1. 初始化当前合并后的方程为第一个方程（`A = a₁`, `B = b₁`）；
2. 依次合并下一个方程（`aᵢ`, `bᵢ`）：
   - 用exgcd求解`A·X - aᵢ·Y = B - bᵢ`的特解；
   - 计算新的特解`B_new`和新的模数`A_new = lcm(A, aᵢ)`；
   - 更新当前方程为（`A_new`, `B_new`）；
3. 最终的`B`就是原方程组的最小非负解。

### 可视化设计思路
我们设计了一个8位像素风的“方程合并实验室”动画：
- **场景**：像素化的实验室，用蓝色方块表示模数`a`，红色方块表示余数`b`；
- **流程**：动态展示“选择方程→转化为不定方程→exgcd求解→合并方程”的过程，每步伴随音效（如exgcd执行的“哔”声、合并成功的“叮”声）；
- **交互**：支持单步执行、自动播放（速度可调）、AI演示，最终解出现时播放“胜利”音效（如FC游戏通关音）。


## 2. 精选优质题解参考

为了更好地理解解题过程，我筛选了以下**思路清晰、代码优质**的题解：

### 题解一：来源：阮行止（赞：617）
* **点评**：这份题解的数学推导**极其详细**，从CRT的局限性讲起，逐步引出EXCRT的核心——合并方程。作者用具体例子（如`x≡2 mod4`和`x≡4 mod6`合并成`x≡10 mod12`）直观展示合并过程，并用严格证明验证了解的唯一性。虽然用Python实现，但思路完全适用于C++，是理解EXCRT的“基石”。

### 题解二：来源：未来姚班zyl（赞：163）
* **点评**：这份题解提供了**另辟蹊径的思路**——将模数分解质因数，转化为互质模数后用CRT求解。作者利用“同余方程等价于其质因数分解后的方程组”的性质，保留每个质数的最高次幂方程（更高次幂限制更强），最后用CRT合并。这种思路加深了对同余方程的理解，适合学习“问题转化”的技巧。

### 题解三：来源：Tyih（赞：9）
* **点评**：这份题解的C++代码**直接对应题目要求**，用`__int128`处理大数（避免溢出），实现了EXCRT的核心逻辑——两两合并方程。代码结构清晰，从初始化到合并的步骤明确，是非常实用的模板参考。


## 3. 核心难点辨析与解题策略

在解决EXCRT问题时，常见的难点及解决策略如下：

### 1. 如何正确合并两个同余方程？
- **分析**：合并的核心是将两个方程转化为不定方程`A·X - a·Y = B - b`，用exgcd求解。根据裴蜀定理，当且仅当`gcd(A,a)`整除`B - b`时，方程有解。求出特解后，合并后的方程为`x ≡ B - A·X₀·(B - b)/gcd(A,a) mod lcm(A,a)`（注意符号和模运算）。
- 💡 **学习笔记**：合并的正确性依赖于裴蜀定理和exgcd，必须确保每一步符号正确。

### 2. 如何处理大数运算避免溢出？
- **分析**：`aᵢ`可达1e12，`lcm(a₁,a₂)`可达1e24，超过`long long`的范围（约9e18）。解决方法有两种：
  1. 用`__int128`类型（部分编译器支持）直接存储大数；
  2. 用快速乘法（将乘法转化为加法，模运算避免溢出）。
- 💡 **学习笔记**：处理大数时，优先选择`__int128`（代码更简洁）。

### 3. 如何保证合并后的方程与原方程组等价？
- **分析**：合并后的方程的模是`lcm(A,a)`，根据数学证明，原方程组的解是合并后方程的解，且合并后方程的解也是原方程组的解（解的唯一性）。因此，每次合并都是**等价转化**。
- 💡 **学习笔记**：等价性是EXCRT的基础，合并后的模必须是`lcm(A,a)`。

### ✨ 解题技巧总结
- **问题转化**：将同余方程组转化为不定方程，用数论知识（裴蜀定理、exgcd）求解；
- **大数处理**：用`__int128`或快速乘法避免溢出；
- **等价合并**：通过两两合并方程，将复杂问题分解为简单问题；
- **质因数分解**：模数不互质时，可分解为互质模数后用CRT。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合Tyih和Fading的思路，用`__int128`处理大数，实现EXCRT的核心逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
using namespace std;

typedef long long lll;
typedef __int128 ll;

ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) { x = 1, y = 0; return a; }
    ll g = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return g;
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    int n; cin >> n;
    ll A = 1, B = 0; // 初始方程：x ≡ 0 mod 1
    for (int i = 0; i < n; ++i) {
        lll a_lll, b_lll; cin >> a_lll >> b_lll;
        ll a = a_lll, b = b_lll;
        ll x, y; ll g = exgcd(A, a, x, y);
        x = x * (B - b) / g; // 特解
        ll mod = a / g; x = (x % mod + mod) % mod; // 调整到最小正整数
        B = B - A * x; A = A * a / g; // 更新合并后的方程
        B = (B % A + A) % A; // 调整B到非负
    }
    cout << (lll)B << endl;
    return 0;
}
```
* **代码解读概要**：
  初始化当前方程为`x ≡ 0 mod 1`（所有数都满足），依次合并每个输入的方程。用exgcd求解不定方程的特解，调整特解到最小正整数，计算合并后的新方程，最后输出合并后的余数（最小非负解）。

### 针对各优质题解的片段赏析

#### 题解一：阮行止（Python合并逻辑）
* **亮点**：直接对应EXCRT的数学推导。
* **核心代码片段**：
```python
def uni(P, Q):
    r1, m1 = P; r2, m2 = Q
    d = gcd(m1, m2)
    l1, l2 = exgcd(m1//d, m2//d)
    return (r1 + (r2-r1)//d * l1 * m1) % lcm(m1,m2), lcm(m1,m2)
```
* **代码解读**：
  `P`和`Q`是两个方程的（余数，模数）。计算`gcd(m1,m2)`验证解的存在性，用exgcd求解`(m1/d)·l1 + (m2/d)·l2 = 1`的特解`l1`，合并后的余数是`r1 + (r2-r1)/d · l1 · m1`，模是`lcm(m1,m2)`。
* 💡 **学习笔记**：合并的核心公式是`r_new = r1 + (r2-r1)/d · l1 · m1`。

#### 题解二：未来姚班zyl（质因数分解处理）
* **亮点**：保留每个质数的最高次幂方程。
* **核心代码片段**：
```cpp
void Insert(long long& x, long long y, int i) {
    long long nmod = 1;
    while (x % p[i] == 0) { x /= p[i]; nmod *= p[i]; }
    if (nmod > mod[i]) { mod[i] = nmod; rem[i] = y % nmod; }
}
```
* **代码解读**：
  `x`是当前模数，`p[i]`是已分解的质数。`nmod`是`p[i]`的最高次幂（如`x=12`，`p[i]=2`时，`nmod=4`）。如果`nmod`大于当前`mod[i]`（该质数的最高次幂），则更新`mod[i]`和余数`rem[i]`（更高次幂限制更强）。
* 💡 **学习笔记**：质因数分解后，更高次幂的方程限制更强，需保留。

#### 题解三：Tyih（`__int128`处理大数）
* **亮点**：用`__int128`避免溢出。
* **核心代码片段**：
```cpp
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) { x = 1, y = 0; return a; }
    ll g = exgcd(b, a%b, y, x);
    y -= a/b*x;
    return g;
}
```
* **代码解读**：
  实现扩展欧几里得算法，返回`gcd(a,b)`，并通过引用参数`x`和`y`返回`a·x + b·y = gcd(a,b)`的特解。`ll`是`__int128`类型，能存储更大的数。
* 💡 **学习笔记**：exgcd的递归实现要注意参数顺序和`y`的更新。


## 5. 算法可视化：像素动画演示 (核心部分)

为了更直观地理解**EXCRT的方程合并过程**，我设计了一个8位像素风的“方程合并小助手”动画，结合复古游戏元素，让大家“看”到算法的每一步！

### 动画演示主题
**“像素实验室：方程合并大挑战”**——你将扮演小科学家，在像素实验室里合并同余方程，每合并一个方程完成一个小关卡，最终找到解。

### 设计思路
采用8位像素风（仿FC游戏），用蓝色方块表示模数`a`，红色方块表示余数`b`，合并过程用动态箭头和闪烁效果展示，关键操作伴随音效（如合并成功的“叮”声、exgcd执行的“哔”声），增强学习趣味性。

### 动画帧步骤与交互
1. **场景初始化**：
   - 左侧“方程列表”显示输入的方程（如样例的3个方程）；
   - 中间“合并实验室”显示当前合并后的方程；
   - 右侧“控制面板”有“开始/暂停”“单步”“重置”按钮，速度滑块（1x~5x），“AI自动演示”开关。
2. **合并过程演示**（以样例为例）：
   - **步骤1**：取出第二个方程（`25`, `9`），移动到“合并实验室”；
   - **步骤2**：显示不定方程`11·X -25·Y = 6-9=-3`；
   - **步骤3**：闪烁`11`和`25`，展示exgcd求解过程，得到特解`X0=-2`；
   - **步骤4**：计算合并后的方程`x≡215 mod275`，更新“合并实验室”；
   - **步骤5**：重复合并第三个方程，最终得到`x≡809 mod825`。
3. **胜利状态**：
   - 显示“解：809”，播放“胜利”音效（如《魂斗罗》通关音），弹出像素星星庆祝。

### 旁白提示
- 步骤1：“接下来合并第二个方程啦！”
- 步骤2：“转化为不定方程：11X -25Y = -3”
- 步骤3：“用exgcd找到特解X0=-2！”
- 步骤4：“合并后的方程是x≡215 mod275～”
- 胜利：“恭喜你！找到解啦：809”


## 6. 拓展练习与相似问题思考

### 通用思路迁移
EXCRT的核心是“两两合并方程”，可迁移到以下场景：
1. **多约束余数问题**：要求一个数满足多个余数条件，模数不互质；
2. **大数处理**：处理超过`long long`范围的数；
3. **数论组合问题**：结合质因数分解、CRT等解决复杂问题。

### 练习推荐 (洛谷)
1. **P1495** - 【模板】中国剩余定理（CRT）  
   🗣️ **推荐理由**：对比CRT和EXCRT的区别，加深对同余方程组的理解。
2. **P2480** - 银河英雄传说  
   🗣️ **推荐理由**：将实际问题转化为同余问题，学习带权并查集与同余的结合。
3. **P3868** - 数学作业  
   🗣️ **推荐理由**：练习同余运算与动态规划、矩阵快速幂的结合。
4. **P4777** - 【模板】扩展中国剩余定理（EXCRT）  
   🗣️ **推荐理由**：巩固EXCRT模板，确保能正确处理大数和合并方程。


## 7. 学习心得与经验分享

本次分析的题解中，有以下关键经验值得借鉴：
- **阮行止**：“CRT无法处理模不互质的情况，必须跳出CRT的窠臼，采用合并方程的方法。”——提醒我们要灵活调整思路，不要被既有方法限制。
- **未来姚班zyl**：“分解质因数转化为互质模数，保留最高次幂方程。”——展示了“问题转化”的重要性。
- **Tyih**：“用`__int128`处理大数，避免溢出。”——解决了EXCRT的核心问题，代码简洁有效。


## 总结
本次关于“【模板】扩展中国剩余定理（EXCRT）”的分析就到这里。希望这份指南能帮助大家理解EXCRT的核心思想、合并方程的方法，以及大数处理的技巧。数论算法的关键在于**理解数学原理**，然后将其转化为代码。下次我们再一起探索新的编程挑战！💪

---
处理用时：227.61秒
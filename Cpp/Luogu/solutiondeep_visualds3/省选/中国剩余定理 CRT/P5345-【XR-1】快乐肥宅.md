# 题目信息

# 【XR-1】快乐肥宅

## 题目背景

小粉兔的机房里面有 $n$ 个快乐肥宅，但小粉兔自己并不是，他看着这些快乐肥宅，非常羡慕，于是他想研究一下这些快乐肥宅的体重。

## 题目描述

每个快乐肥宅第 $0$ 天的体重都等于 $1$。第 $i$ 个快乐肥宅的体重记作 $w_i$，则一开始 $w_i = 1$。

第 $i$ 个快乐肥宅有一个专属的快乐指数 $k_i$，这表示他每天刚起床后，体重会是上一天的体重的 $k_i$ 倍。

肥宅们是有觉悟的，第 $i$ 个肥宅有一个专属的觉醒体重 $g_i$，这表示一旦他的体重**大于** $g_i$，他就会去健身房健身，每次减掉自己 $g_i$ 的体重，直到体重小于等于 $g_i$。

健身后，肥宅们会在机房见面，他们发现有时各自的体重会变得很有趣。

有一天，肥宅们发现各自的体重形成了等差数列！

另一天，肥宅们发现各自的体重形成了等比数列！

肥宅们心想，如果 $n$ 个快乐肥宅的体重 $\{w_1, w_2, \ldots, w_n\}$ 恰好形成序列 $\{r_1, r_2, \ldots, r_n\}$，至少需要经过多少天呢？

不过如果肥宅们等了很久都没有等到这一天，他们会认为这是不可能的。

## 说明/提示

【样例 $1$ 说明】

下表是两个肥宅在第 $0$ 天至第 $7$ 天时的体重变化表：

| 天数 | 肥宅 $1$ 的体重 | 肥宅 $2$ 的体重 | 解释 |
| :--: | :--: | :--: | :--: |
| $0$ | $1$ | $1$ | 第 $0$ 天每个肥宅的体重都是 $1$ |
| $1$ | $4$ | $2$ | 肥宅 $1$ 的体重是上一天的 $4$ 倍，肥宅 $2$ 的体重是上一天的 $2$ 倍 |
| $2$ | $2$ | $4$ | 肥宅 $1$ 的体重是上一天的 $4$ 倍，为 $16$，他发现自己的体重超过了 $7$，于是去了两次健身房，把体重减少了 $2\times 7=14$ |
| $3$ | $1$ | $3$ | 这一天肥宅 $1$ 和肥宅 $2$ 都去了一次健身房 |
| $4$ | $4$ | $1$ | 肥宅 $2$ 去了一次健身房 |
| $5$ | $2$ | $2$ | 肥宅 $1$ 去了两次健身房 |
| $6$ | $1$ | $4$ | 肥宅 $1$ 去了一次健身房 |
| $7$ | $4$ | $3$ | 肥宅 $2$ 去了一次健身房 |

可以看出在第 $7$ 天时肥宅的体重形成了序列 $\{4, 3\}$。

【数据规模与约定】

Subtask 1（20 points）：$n \le 50$，$g_i \le 50$。  
Subtask 2（20 points）：$g_i$ 为质数。  
Subtask 3（20 points）：$g_i \le 10^3$。  
Subtask 4（20 points）：$r_i \in \{1, g_i\}$。  
Subtask 5（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^3$，$1 \le k_i, r_i \le g_i \le 10^7$。

## 样例 #1

### 输入

```
2
4 7 4
2 5 3```

### 输出

```
7```

## 样例 #2

### 输入

```
2
4 7 3
2 5 3```

### 输出

```
Impossible```

## 样例 #3

### 输入

```
2
4 7 1
2 5 1```

### 输出

```
0```

## 样例 #4

### 输入

```
3
14 60 44
6 50 6
1029 91287 87318```

### 输出

```
101```

## 样例 #5

### 输入

```
1
6 65536 65536```

### 输出

```
16```

## 样例 #6

### 输入

```
2
2 2 2
2 3 1
```

### 输出

```
2
```

# AI分析结果

# 💡 Kay的C++算法解析：【XR-1】快乐肥宅 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（扩展大步小步算法exBSGS + 扩展中国剩余定理exCRT）

🗣️ **初步分析**：  
解决这道题的关键，是要破解两个数学难题——**“高次同余方程怎么解？”** 和 **“多个同余方程的解怎么合并？”**。我们可以用两个“数学工具”搞定：  
- **exBSGS（扩展大步小步算法）**：就像“找肥宅体重的规律”——肥宅每天增重（乘以k_i），超过g_i就减肥（取模），体重变化会先走一段“直路”（尾巴），再绕“环形跑道”（循环）。exBSGS能帮我们找到第一个符合目标体重r_i的天数（最小解），以及循环的长度（周期）。  
- **exCRT（扩展中国剩余定理）**：就像“找共同的上课时间”——每个肥宅有自己的“上课周期”（比如每5天符合一次），我们要找一个天数，让所有肥宅都同时符合条件。

### 核心思路与难点
1. **单方程求解**：用exBSGS处理每个k_i^x ≡ r_i mod g_i，得到两种结果——要么只有一个解（在尾巴上），要么有无穷解（在循环上，解的形式是x ≡ s_i mod t_i，s_i是最小解，t_i是周期）。  
2. **多方程合并**：用exCRT合并所有周期解的同余方程。如果有唯一解，直接验证是否符合所有方程；如果合并后的解超过1e9，输出无解。

### 可视化设计思路
我们可以做一个**8位像素风的“肥宅体重模拟器”**：  
- 场景：像素化的房间里，每个肥宅是一个小方块，体重用数字显示在头顶。  
- 动画：每天开始时，肥宅的体重乘以k_i（数字闪烁变大），如果超过g_i，就“减肥”（数字快速减小到模后的值）。  
- 高亮：尾巴阶段的体重用蓝色标记，循环开始用黄色标记，找到目标体重r_i时用红色闪烁，并播放“叮”的音效。  
- 交互：可以单步执行（看每天的变化）、自动播放（快进看循环），还能切换“显示所有肥宅”或“聚焦单个肥宅”。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速掌握核心方法：
</eval_intro>

**题解一：来源（小粉兔，赞39）**  
* **点评**：这份题解是本题的“标准答案”！思路超级清晰——先讲清肥宅体重的“尾巴+循环”模型，再用exBSGS分解每个方程，最后用exCRT合并解。代码结构工整，变量命名（比如`ExBSGS`返回解和周期）一看就懂，还处理了大数溢出的问题（当合并后的周期超过1e9时直接判断无解）。最棒的是，作者用图展示了体重变化的“ρ形”结构，帮你直观理解exBSGS的原理！

**题解二：来源（lingfunny，赞5）**  
* **点评**：这份题解补充了一个关键细节——**如何正确求循环周期**！作者指出，直接求k_i的阶是错的，要先消去r_i和g_i的公因子，再求阶。代码里的`findm`函数完美实现了这一点，帮你避免掉“阶计算错误”的坑。此外，作者还分享了自己的WA经历，提醒你“不要忽略公因子的影响”，非常实用！

**题解三：来源（mango09，赞3）**  
* **点评**：这份题解把exBSGS和exCRT的结合讲得很透！作者详细解释了“唯一解”和“周期解”的处理逻辑——如果有唯一解，直接验证；如果是周期解，用exCRT合并。代码里的`exCRT`函数处理了非互质模数的情况，还特判了合并后的解是否超过1e9，严谨又全面。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点在于“处理高次同余的细节”和“合并解的正确性”，我帮你提炼了3个核心问题及解决方法：
</difficulty_intro>

1. **难点1：如何处理模数不互质的高次同余方程？**  
   * **分析**：当k_i和g_i不互质时，普通BSGS无法直接用。exBSGS的解决方法是**“分解模数”**——不断除以k_i和g_i的公因子，直到互质为止。比如，k_i=4，g_i=7，r_i=4：先算4^x mod7，发现4和7互质，直接用BSGS。  
   * 💡 **学习笔记**：exBSGS的核心是“消去公因子，转化为互质情况”。

2. **难点2：如何求循环周期（阶）？**  
   * **分析**：循环周期是“再次回到目标体重的最小天数”。正确的求法是：先消去r_i和g_i的公因子得到g'_i，再求k_i模g'_i的阶（即最小的t，使得k_i^t ≡1 mod g'_i）。比如，样例1中肥宅2的g_i=5，r_i=3，g'_i=5/gcd(3,5)=5，k_i=2的阶是4（2^4=16≡1 mod5），所以周期是4。  
   * 💡 **学习笔记**：阶的计算要基于“消去公因子后的模数”！

3. **难点3：如何合并多个非互质的同余方程？**  
   * **分析**：多个同余方程x≡s_i mod t_i的合并，要用exCRT。exCRT的关键是**“逐步合并”**——先合并前两个方程，得到新的同余方程，再和第三个合并，直到所有方程合并完。如果合并过程中发现无解（比如两个方程没有共同解），直接输出Impossible。  
   * 💡 **学习笔记**：exCRT处理非互质模数，关键是求线性组合的解。


### ✨ 解题技巧总结
- **技巧A：模型转化**：把“肥宅体重问题”转化为“高次同余方程”，这是解题的第一步！  
- **技巧B：细节处理**：注意模数不互质的情况，以及阶的正确计算，这些细节决定了你是否会WA。  
- **技巧C：溢出判断**：合并后的周期可能很大，超过1e9就直接输出无解，避免计算错误。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合了优质题解的核心代码，帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了小粉兔、lingfunny和mango09的思路，实现了exBSGS求单方程解、exCRT合并解的完整逻辑。

* **完整核心代码**：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <cmath>
#include <map>
using namespace std;

typedef long long LL;
const int U = 1e9;

LL gcd(LL a, LL b) { return b ? gcd(b, a%b) : a; }
LL exgcd(LL a, LL b, LL &x, LL &y) {
    if (!b) return x=1, y=0, a;
    LL d = exgcd(b, a%b, y, x);
    y -= a/b*x;
    return d;
}

// 求a的逆元，a和p互质
LL inv(LL a, LL p) {
    LL x, y;
    exgcd(a, p, x, y);
    return (x%p + p) % p;
}

// BSGS算法，求解a^x ≡ b mod p（a和p互质）
LL BSGS(LL a, LL b, LL p) {
    map<LL, LL> mp;
    LL t = sqrt(p) + 1, at = 1;
    for (LL i=0; i<t; ++i) {
        LL val = b * at % p;
        if (!mp.count(val)) mp[val] = i;
        at = at * a % p;
    }
    LL ai = 1;
    for (LL i=1; i<=t; ++i) {
        ai = ai * at % p;
        if (mp.count(ai)) return i*t - mp[ai];
    }
    return -1;
}

// exBSGS算法，求解a^x ≡ b mod p，返回（最小解，周期），无解返回（-1,-1）
pair<LL, LL> ExBSGS(LL a, LL b, LL p) {
    if (p == 1) return {0, 1};
    a %= p, b %= p;
    LL g, k=0, f=1;
    while ((g = gcd(a, p)) > 1) {
        if (b % g) return {-1, -1};
        k++; b /= g; p /= g;
        f = f * (a/g) % p;
        if (f == b) {
            if (gcd(a, p) > 1) return {k, -1};
            LL y = BSGS(a, 1, p);
            return {k, y};
        }
    }
    LL x = BSGS(a, b * inv(f, p) % p, p);
    if (x == -1) return {-1, -1};
    LL y = BSGS(a, 1, p);
    return {x % y + k, y};
}

// exCRT合并两个同余方程：x ≡ a1 mod m1，x ≡ a2 mod m2
bool merge(LL &a1, LL &m1, LL a2, LL m2) {
    LL k1, k2, g = exgcd(m1, m2, k1, k2);
    if ((a2 - a1) % g) return false;
    k1 = k1 * ((a2 - a1)/g) % (m2/g);
    a1 += k1 * m1;
    m1 = m1 / g * m2;
    a1 = (a1 % m1 + m1) % m1;
    return true;
}

int main() {
    int n;
    scanf("%d", &n);
    LL X = -1, MaxX = 0;
    LL s[1005], t[1005]; // 每个方程的最小解s[i]，周期t[i]
    for (int i=1; i<=n; ++i) {
        LL k, g, r;
        scanf("%lld%lld%lld", &k, &g, &r);
        auto res = ExBSGS(k, r, g);
        s[i] = res.first;
        t[i] = res.second;
        if (s[i] == -1) {
            puts("Impossible");
            return 0;
        }
        if (t[i] == -1) X = s[i];
        MaxX = max(MaxX, s[i]);
    }
    // 处理唯一解的情况
    if (X != -1) {
        for (int i=1; i<=n; ++i) {
            if (t[i] == -1 && X != s[i]) {
                puts("Impossible");
                return 0;
            }
            if (t[i] != -1 && (X < s[i] || (X - s[i]) % t[i])) {
                puts("Impossible");
                return 0;
            }
        }
        printf("%lld\n", X);
        return 0;
    }
    // 合并周期解
    LL a = s[1], m = t[1];
    for (int i=2; i<=n; ++i) {
        if (m > U && (a - s[i]) % t[i]) {
            puts("Impossible");
            return 0;
        }
        if (m <= U && !merge(a, m, s[i], t[i])) {
            puts("Impossible");
            return 0;
        }
    }
    // 调整解到大于等于MaxX
    if (a < MaxX) {
        LL add = (MaxX - a + m - 1) / m * m;
        a += add;
    }
    if (a > U) puts("Impossible");
    else printf("%lld\n", a);
    return 0;
}
```

* **代码解读概要**：  
  1. **ExBSGS函数**：处理单方程，返回最小解和周期；  
  2. **merge函数**：用exCRT合并两个同余方程；  
  3. **主函数**：读取输入，用ExBSGS处理每个方程，然后处理唯一解或合并周期解，最后输出结果。


<code_intro_selected>
接下来看优质题解的核心片段，学习细节处理：
</code_intro_selected>

**题解一（小粉兔）：ExBSGS函数**  
* **亮点**：清晰处理了“尾巴”和“循环”的区分，返回解和周期。  
* **核心代码片段**：
```cpp
pair<LL, LL> ExBSGS(LL a, LL b, LL p) {
    if (p == 1) return {0, 1};
    a %= p, b %= p;
    LL g, k=0, f=1;
    while ((g = gcd(a, p)) > 1) {
        if (b % g) return {-1, -1};
        k++; b /= g; p /= g;
        f = f * (a/g) % p;
        if (f == b) {
            if (gcd(a, p) > 1) return {k, -1};
            LL y = BSGS(a, 1, p);
            return {k, y};
        }
    }
    LL x = BSGS(a, b * inv(f, p) % p, p);
    if (x == -1) return {-1, -1};
    LL y = BSGS(a, 1, p);
    return {x % y + k, y};
}
```
* **代码解读**：  
  - 循环部分：不断除以a和p的公因子g，直到互质。每步记录“尾巴长度”k，以及当前的乘积f。  
  - 如果f等于b，说明解在尾巴上：如果此时a和p仍不互质，返回唯一解k；否则求循环周期y，返回解k和周期y。  
  - 最后用BSGS求互质情况下的解x，加上尾巴长度k，周期是y。  
* 💡 **学习笔记**：ExBSGS的关键是“分解模数，区分尾巴和循环”。

**题解二（lingfunny）：findm函数（求阶）**  
* **亮点**：正确处理了r_i和g_i的公因子，求阶的方法更严谨。  
* **核心代码片段**：
```cpp
inline int findm(int a, int b, int p) {
    int d = __gcd(b, p);
    p /= d;
    if (__gcd(a, p) > 1) return 1e9+7;
    return GET(p, a); // GET函数求a模p的阶
}
```
* **代码解读**：  
  - 先求b和p的公因子d，然后p除以d（消去公因子）。  
  - 如果a和p仍不互质，说明没有循环周期；否则求a模p的阶。  
* 💡 **学习笔记**：阶的计算要基于“消去r_i和g_i的公因子后的模数”！

**题解三（mango09）：exCRT合并函数**  
* **亮点**：逐步合并同余方程，处理了大数溢出的情况。  
* **核心代码片段**：
```cpp
bool merge(LL &a1, LL &m1, LL a2, LL m2) {
    LL k1, k2, g = exgcd(m1, m2, k1, k2);
    if ((a2 - a1) % g) return false;
    k1 = k1 * ((a2 - a1)/g) % (m2/g);
    a1 += k1 * m1;
    m1 = m1 / g * m2;
    a1 = (a1 % m1 + m1) % m1;
    return true;
}
```
* **代码解读**：  
  - 用exgcd求m1和m2的最大公约数g，以及线性组合的系数k1、k2。  
  - 如果(a2 - a1)不能被g整除，说明无解；否则计算新的解a1和新的周期m1。  
* 💡 **学习笔记**：exCRT的核心是“求解线性组合，合并同余方程”。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地理解“肥宅体重的ρ形变化”和exBSGS的过程，我设计了一个**8位像素风的动画**——《肥宅减肥记》！
</visualization_intro>

### 动画演示主题
像素肥宅每天增重→减肥→找目标体重的过程，展示“尾巴”和“循环”的结构。

### 设计思路
用FC红白机的风格（低分辨率、鲜艳色彩），让你像玩游戏一样理解算法。关键元素：  
- **像素肥宅**：每个肥宅是一个20x20的方块，头顶显示当前体重。  
- **天数计数器**：屏幕顶部显示当前天数（从0开始）。  
- **目标体重标记**：目标体重r_i用红色框标记，找到时肥宅会“跳起来”（像素动画）。  
- **音效**：每天开始时“叮”一声，减肥时“咻”一声，找到目标时“铛”一声。

### 动画帧步骤与交互
1. **初始化**：  
   - 屏幕显示3个像素肥宅（对应样例1的2个+1个示范），初始体重都是1。  
   - 控制面板：开始/暂停、单步、重置按钮，速度滑块（1x~10x）。  
   - 背景音乐：8位风格的《快乐肥宅水之歌》（循环播放）。

2. **单步执行（以样例1肥宅1为例）**：  
   - 第0天：体重1（初始状态）。  
   - 第1天：乘以k1=4→体重4（数字闪烁变大），不超过g1=7→不减肥。  
   - 第2天：乘以4→16（闪烁），超过7→减肥2次（16-2*7=2，数字快速减小到2）。  
   - 第3天：乘以4→8（闪烁），超过7→减肥1次→1（数字减小到1）。  
   - 第7天：体重4（红色闪烁），找到目标r1=4→播放“铛”音效，肥宅跳起来。

3. **循环展示**：  
   - 当肥宅进入循环（比如第3天后，肥宅1的体重开始1→4→2→1→...循环），用黄色框标记循环开始的天数（第3天），并显示循环长度（3天）。

4. **交互功能**：  
   - **单步**：点击一次，走一天，方便看细节。  
   - **自动播放**：按速度滑块的速度连续执行，快进看循环。  
   - **重置**：回到第0天，重新开始。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了exBSGS和exCRT，你可以解决很多“找共同解”的问题！比如：
</similar_problems_intro>

### 通用思路迁移
- **密码学**：破解离散对数密码（比如ElGamal加密），需要求解高次同余方程。  
- **日程安排**：找多个人的共同空闲时间，相当于合并多个同余方程。  
- **游戏设计**：比如“怪物每隔t天出现一次，找第一次同时出现的天数”，就是exCRT的应用。

### 洛谷练习推荐
1. **洛谷 P3846** - 《[TJOI2007] 可爱的质数》  
   🗣️ **推荐理由**：这是BSGS的经典题，帮你巩固“互质情况下的高次同余方程”求解。  
2. **洛谷 P4777** - 《扩展中国剩余定理》  
   🗣️ **推荐理由**：exCRT的模板题，帮你掌握“非互质模数的同余方程合并”。  
3. **洛谷 P5542** - 《[BJOI2016] 回转寿司》  
   🗣️ **推荐理由**：结合了exBSGS和exCRT的综合题，帮你练习“多方程合并”的逻辑。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“踩坑经验”非常宝贵，我帮你整理了两条：
</insights_intro>

> **经验1（来自lingfunny）**：“我一开始直接求k_i的阶，结果样例4 WA了。后来才发现，要先消去r_i和g_i的公因子，再求阶！”  
> **点评**：这个经验提醒我们——**阶的计算不能忽略r_i和g_i的公因子**！很多人会在这里掉坑，一定要记住先消去公因子。

> **经验2（来自小粉兔）**：“合并解时，如果周期超过1e9，直接判断无解，否则会溢出！”  
> **点评**：大数溢出是编程中的常见问题，这里的处理方法很聪明——超过1e9就不用算了，直接输出无解。  


<conclusion>
本次关于“【XR-1】快乐肥宅”的分析就到这里！这道题的核心是**exBSGS+exCRT**，关键是处理“尾巴+循环”的模型和“非互质模数的合并”。记住：数学算法的难点在于“细节”，多练、多总结就能掌握！下次我们再一起挑战更难的题目吧！💪
</conclusion>

---
处理用时：121.84秒
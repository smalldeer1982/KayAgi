# 题目信息

# [JLOI2008] 将军

## 题目描述

刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\_T。

言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：

给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。

这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。

现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。

国际象棋中一共有 6 种棋子：

- king（国王）；
- queen（皇后）；
- bishop（教主）；
- knight（骑士）；
- rook（车）；
- pawn（步兵）。

各棋子的攻击范围如下：

- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；
- knight 的攻击范围如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

- rook 攻击水平和垂直两条线上的所有格子；
- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；
- king 攻击周围 8 个方向各 1 格；
- bishop 攻击两条对角线上的所有格子。

除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。

可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。

## 说明/提示

```plain
BBN
...
...
```

```plain
BBN
...
B..
```

虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。


## 样例 #1

### 输入

```
3 3
..N
...
...
```

### 输出

```
2```

# AI分析结果


# 💡 Kay的C++算法解析：[JLOI2008]将军 深入学习指南 💡

<introduction>
大家好！今天我们一起分析"[JLOI2008]将军"这道国际象棋相关的C++编程题。本指南将帮助你理解如何放置主教棋子，使其与棋盘上已有棋子互不攻击，同时最大化放置数量。我们将通过清晰的算法解释和有趣的像素动画，让你直观理解解题思路！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二分图匹配`与`预处理模拟`

🗣️ **初步分析**：
> 这道题就像在布置一个安全的"主教营地"——我们需要在已有棋子的棋盘上放置尽可能多的主教，确保它们互不攻击。核心技巧是：  
> 1. 将棋盘旋转45°，使主教的对角线攻击变成水平和垂直方向  
> 2. 将旋转后的行和列看作二分图的两部分  
> 3. 用匈牙利算法求解最大匹配  
> 
> **关键难点**在于准确模拟6种棋子的攻击范围（国王、皇后、骑士等），尤其是考虑阻挡规则。在可视化设计中，我们会用不同颜色标记攻击区域，旋转动画展示坐标转换，并通过连线演示匹配过程。  
> 
> **复古游戏化设计**：采用8位像素风格棋盘，旋转时播放"咔哒"音效，匹配成功时播放"叮"的音效，像解谜游戏一样逐步展示算法流程。

---

## 2. 精选优质题解参考

<eval_intro>
我根据思路清晰度、代码规范性和算法效率，精选了以下高质量题解（均≥4星）：

**题解一（作者：GNAQ）**
* **点评**：这份题解思路清晰，详细解释了棋盘旋转45°的坐标转换方法（使用pau数组）。代码结构规范，使用链式前向星存储二分图，匈牙利算法实现标准。特别亮点是处理了各种棋子的攻击范围（如国王的8方向、骑士的L形移动），并考虑了阻挡机制。代码可直接用于竞赛，边界处理严谨。

**题解二（作者：caizehua）**
* **点评**：题解通过结构体存储旋转后坐标，创新性地使用r和c数组标记行列攻击范围。思路讲解透彻，配有手绘示意图帮助理解。代码中详细处理了各类棋子的攻击特性（如车的直线攻击、皇后的复合攻击），匈牙利算法实现规范。亮点是"攻击范围标记"的可视化方法，对理解二分图构建很有帮助。

**题解三（作者：lly66666）**
* **点评**：解法简洁高效，直接使用二维数组标记攻击范围。亮点是清晰的坐标转换公式（行号=i+j-1, 列号=i+j+m+n-1）和方向向量处理骑士移动。虽然解释较精简，但代码质量高，匈牙利算法实现标准，适合快速理解核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键挑战如下，结合优质题解的策略分析：

1.  **攻击范围的精确模拟**
    * **分析**：不同棋子（王、后、车等）攻击规则各异，且除骑士外都会被阻挡。优质题解使用方向数组+循环标记攻击路径，遇到其他棋子时停止（如车的直线攻击用while循环实现）。
    * 💡 **学习笔记**：方向数组+阻挡判断是模拟攻击范围的核心技巧。

2.  **坐标转换与二分图建模**
    * **分析**：旋转棋盘后，原坐标(i,j)变为新坐标(i+j-1, j-i+n)。将新行号作为左部节点，列号作为右部节点，可放置位置作为边连接二者。
    * 💡 **学习笔记**：棋盘旋转45°将"对角线冲突"转化为"行列冲突"，是经典的空间重构技巧。

3.  **匈牙利算法的应用优化**
    * **分析**：在稀疏图上，匈牙利算法比Dinic更高效（如GNAQ的实践发现）。使用时间戳（vis数组）避免每次清空，提升递归效率。
    * 💡 **学习笔记**：匈牙利算法适合节点数<1000的二分图，注意用时间戳优化。

### ✨ 解题技巧总结
<summary_best_practices>
- **模块化设计**：将不同棋子的攻击模拟封装成独立函数（如handleKing(), handleQueen()）
- **方向数组技巧**：用dx/dy数组统一处理移动逻辑，避免重复代码
- **旋转坐标推导**：提前计算旋转后坐标映射（如pau数组），避免实时计算开销
- **调试验证**：用小棋盘样例（如3x3）逐步验证攻击范围标记

---

## 4. C++核心代码实现赏析

<code_intro_overall>
**本题通用核心C++实现参考**
* **说明**：综合优质题解思路，包含攻击范围标记+坐标转换+匈牙利算法
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

const int MAXN = 1050;
char grid[MAXN][MAXN];
bool blocked[MAXN][MAXN]; // 标记被攻击位置
int n, m;

// 匈牙利算法
vector<int> graph[MAXN*2];
int match[MAXN*2], vis[MAXN*2];

bool dfs(int u, int tag) {
    for(int v : graph[u]) {
        if(vis[v] == tag) continue;
        vis[v] = tag;
        if(match[v] == -1 || dfs(match[v], tag)) {
            match[v] = u;
            return true;
        }
    }
    return false;
}

// 标记攻击路径（带阻挡检测）
void markAttack(int x, int y, int dx, int dy) {
    while(true) {
        x += dx; y += dy;
        if(x<1 || x>n || y<1 || y>m) break;
        if(grid[x][y] != '.') break; // 被阻挡
        blocked[x][y] = true;
    }
}

// 处理主教攻击（其他棋子类似）
void handleBishop(int x, int y) {
    int dirs[4][2] = {{-1,-1}, {-1,1}, {1,-1}, {1,1}};
    for(auto d : dirs) 
        markAttack(x, y, d[0], d[1]);
}

int main() {
    cin >> n >> m;
    for(int i=1; i<=n; i++) cin >> (grid[i]+1);

    // 标记所有攻击位置
    memset(blocked, 0, sizeof(blocked));
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=m; j++) {
            if(grid[i][j] != '.') {
                switch(grid[i][j]) {
                    case 'B': handleBishop(i,j); break;
                    // 其他棋子处理...
                }
            }
        }
    }

    // 构建二分图（旋转后坐标）
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=m; j++) {
            if(!blocked[i][j]) {
                int row = i + j - 1;       // 旋转后行号
                int col = j - i + n;       // 旋转后列号
                graph[row].push_back(col);
            }
        }
    }

    // 匈牙利算法求最大匹配
    memset(match, -1, sizeof(match));
    int ans = 0;
    for(int i=1; i<=n+m; i++) 
        if(dfs(i, i)) ans++;

    cout << ans << endl;
}
```
* **代码解读概要**：
  1. 读取棋盘并标记所有被攻击位置
  2. 旋转坐标：原坐标(i,j)→新行(i+j-1)，新列(j-i+n)
  3. 对每个安全位置，在新行与新列间建边
  4. 匈牙利算法求二分图最大匹配

---
<code_intro_selected>
**题解一核心技巧（GNAQ）**
* **亮点**：高效的链式前向星存图
* **核心代码片段**：
```cpp
struct Edge { int to, next; } edges[MAXM];
int head[MAXN], idx;

void addEdge(int u, int v) {
    edges[++idx] = {v, head[u]};
    head[u] = idx;
}

// 匈牙利算法（递归版）
bool dfs(int u) {
    for(int i=head[u]; i; i=edges[i].next) {
        int v = edges[i].to;
        if(vis[v]) continue;
        vis[v] = true;
        if(!match[v] || dfs(match[v])) {
            match[v] = u;
            return true;
        }
    }
    return false;
}
```
* **代码解读**：链式前向星是紧凑的图存储方式，`head[u]`存储u的第一条边位置，`edges[i].next`指向下一条边。匈牙利算法递归尝试增广路径，`match`数组记录匹配关系。
* 💡 **学习笔记**：链式前向星适合稀疏图，比vector更节省内存

**题解二创新点（caizehua）**
* **亮点**：使用r/c数组标记行列攻击范围
* **核心代码片段**：
```cpp
int rowID[MAXN][MAXN], colID[MAXN][MAXN];

// 标记旋转后的行列攻击范围
void markRow(int r, int val) {
    for(int i=1; i<=n; i++)
        if(!blocked[r][i]) 
            rowID[r][i] = val;
}

// 建图
for(int i=1; i<=n; i++) {
    for(int j=1; j<=m; j++) {
        if(!blocked[i][j]) {
            addEdge(rowID[i][j], colID[i][j]);
        }
    }
}
```
* **代码解读**：`rowID`和`colID`分别记录每个位置在旋转后所属的行列组。当遇到阻挡时创建新ID，确保同行列组内不会冲突。
* 💡 **学习笔记**：分组标记法使二分图构建更直观，适合复杂棋盘

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**主题**："主教城堡"8位像素解密游戏  
**核心演示**：棋盘旋转45°+二分图匹配过程  
**设计思路**：采用复古红白机像素风格，用颜色区分攻击区域（红色）和安全位置（绿色）。旋转动画展示坐标转换原理，匹配过程设计为"骑士救援"任务——每成功匹配一个主教，骑士前进一步！

### 动画帧步骤：
1. **初始棋盘（8位像素风）**：
   - 绘制像素化棋盘（64x64像素/格）
   - 不同棋子用不同像素图标表示（王冠、宝剑等）
   - 攻击范围用半透明红色覆盖，按棋子类型动态扩散

2. **旋转动画**：
   - 棋盘顺时针旋转45°（1秒动画）
   - 新行列用黄色网格线标识
   - 旋转后安全位置变为绿色像素块

3. **二分图匹配（游戏化）**：
   ```plain
   左区域      右区域
   ┌───┐      ┌───┐
   │行1│─────▶│列A│ 匹配成功！
   └───┘      └───┘
   ```
   - 左部：旋转后的行号（1,2,3...）
   - 右部：旋转后的列号（A,B,C...）
   - 每次尝试匹配：当前行节点闪烁 → 连接线变黄 → 匹配成功时连线变绿并播放"叮"声

4. **骑士进度**：
   - 底部像素骑士随匹配数增加而前进
   - 完全匹配时骑士到达城堡，播放胜利音乐

### 交互控制面板：
- 速度滑块：调节动画速度（0.5x~2x）
- 单步执行：按空格键逐步执行匈牙利算法
- 重置：重新开始当前棋盘

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的二分图建模思想后，可解决更多"冲突放置"问题：

1. **冲突类型扩展**：
   - 行列冲突（车）：P2825 [HEOI2016]游戏
   - 区域冲突（马）：P3355 骑士共存问题
   - 覆盖冲突：P6062 [USACO]泥泞区域

### 推荐练习（洛谷）：
1. **P2825 [HEOI2016/TJOI2016]游戏**  
   → 在含障碍棋盘放置炸弹（行列冲突）
2. **P3355 骑士共存问题**  
   → 放置骑士使其互不攻击
3. **P6062 [USACO2005 Jan]Muddy Fields**  
   → 木板覆盖泥地（行列覆盖模型）

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验非常宝贵：

> **GNAQ的调试经验**：  
> "Dinic跑不过但匈牙利可以" → 稀疏图小规模数据优选匈牙利算法  
>   
> **caizehua的踩坑记录**：  
> "输入必须整个读取再处理" → 边读边处理易漏边界情况  

💡 **Kay总结**：算法选择需结合数据特性，输入处理要保证完整性。调试时可用3x3小棋盘验证攻击范围计算！

---

<conclusion>
本次分析到此结束！记住：棋盘旋转是处理对角线冲突的利器，匈牙利算法是二分图匹配的经典解法。多动手实现攻击范围模拟，下次遇到类似问题你一定能快速解决！ 🚀

---
处理用时：379.43秒
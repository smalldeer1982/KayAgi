# 题目信息

# [SDOI2016] 数字配对

## 题目描述

有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。

若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，

那么这两个数字可以配对，并获得 $c_i \times c_j$ 的价值。

一个数字只能参与一次配对，可以不参与配对。

在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。

## 说明/提示

测试点 $1 \sim 3$： $n \leq 10 $， $a_i \leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \leq 10 ^ 5$；   

测试点 $4 \sim 5$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5  $，$c_i = 0$；

测试点 $6 \sim 10$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5$ ，$ | c_i | \leq 10 ^ 5$。

## 样例 #1

### 输入

```
3
2 4 8
2 200 7
-1 -2 1
```

### 输出

```
4```

# AI分析结果


# 💡 Kay的C++算法解析：[SDOI2016] 数字配对 深入学习指南 💡

<introduction>
今天我们来一起分析"数字配对"这道C++编程题。题目要求我们在价值总和非负的前提下，最大化数字配对次数。本指南将帮助大家梳理网络流建模思路，理解费用流算法的精妙应用。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`网络流建模与费用流应用`

🗣️ **初步分析**：
> 解决这道题的关键在于将数字配对问题转化为**二分图最大权匹配问题**。想象数字们是舞池中的舞者，奇数质因数数量的舞者站在左侧，偶数的在右侧。只有当两位舞者的"质因数差"为1（即步调相差1拍）时才能共舞。我们用网络流建模这个场景：源点连接左侧舞者（容量为数量），右侧舞者连接汇点，可配对的舞者间连无限容量的边（费用为配对收益）。最后在费用流增广过程中确保总收益非负。

> 核心算法流程：
> 1. 计算每个数字的质因数指数和（cnt）
> 2. 根据cnt奇偶性构建二分图
> 3. 建网络流图（源点→左部点，右部点→汇点，可配对点间连边）
> 4. 跑最大费用流，当新增收益使总收益<0时停止

> 在可视化方案中（复古像素风）：
> - 左侧舞者显示为蓝色像素小人，右侧为红色
> - 当增广路径形成时，路径上的像素块会闪烁黄光
> - 费用计数器实时显示当前总收益
> - 当收益即将变负时，触发"警报音效"和红光警示

---

## 2. 精选优质题解参考

<eval_intro>
基于思路清晰度、代码规范性和算法优化程度，我精选了以下3个优质题解（均≥4星）：

### 题解一：xyz32768（16赞）
* **点评**：此解法思路最为清晰直观。作者巧妙利用质因数指数和的奇偶性建立二分图模型，通过标准费用流框架解决问题。代码中`SPFA`函数实现最长路查找，`add`函数处理增广过程，并在价值总和即将为负时通过`ans += sum / (-dis[T])`精准计算剩余流量。变量命名规范（如`dis`存储路径费用），边界处理严谨，特别在空间优化（使用邻接表存图）和时间复杂度控制（O(n^3)）方面表现突出。

### 题解二：louhao088（12赞）
* **点评**：采用二分+费用流的创新思路。通过二分流量上界验证可行性，虽然增加log复杂度但思路更易理解。代码中`check`函数封装流量验证过程，`getr`函数计算最大可能流量，模块化设计优秀。亮点在于建立超源点控制流量，并通过`maxcost>=0`判断可行性，为理解流量控制机制提供了新视角。

### 题解三：Orion545（9赞）
* **点评**：在费用流实现中加入记忆化搜索和质因数分解优化。作者使用Miller-Rabin算法快速判断质数，`cntprime`函数高效计算质因数数量。代码中`spfa2`实现带松弛标记的最长路查找，`feiyong1`执行多路增广，算法健壮性强。特别值得学习的是其优雅处理大整数溢出的技巧（`INF=1ll<<61`）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大核心难点：

1.  **图结构建模**  
    * **分析**：数字间配对关系形成复杂网络，需转化为二分图。关键发现是：配对数字的质因数指数和必为相邻整数（一奇一偶）。优质解法普遍用`cnt[i] = 质因数指数和`，根据奇偶性划分点集。
    * 💡 **学习笔记**：质因数指数和的奇偶性是二分图划分的黄金标准。

2.  **负收益约束处理**  
    * **分析**：费用流增广时路径费用递减。当`当前收益+路径费用×流量<0`时，需计算最大安全流量：`flow = min(剩余流量, 当前收益/|路径费用|)`。xyz32768的解法通过`if(sum + delta >= 0)`判断实现精准控制。
    * 💡 **学习笔记**：利用费用单调递减特性是突破负收益约束的核心。

3.  **质因数分解优化**  
    * **分析**：当a_i≤10^9时，暴力分解质因数需O(√n)。Orion545的解法通过预处理质数表（筛法）和平方根优化，将复杂度降至O(√n/log n)。
    * 💡 **学习笔记**：质因数分解的优化直接影响算法整体效率。

### ✨ 解题技巧总结
<summary_best_practices>
1. **问题转化技巧**：将数字配对转化为二分图匹配，利用网络流求解
2. **边界处理技巧**：使用`LL INF = 1ll<<61`避免整数溢出
3. **动态控制技巧**：在增广过程中实时计算`安全流量`应对负收益约束
4. **数学优化技巧**：用预生成质数表加速质因数分解

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下完整实现融合了三个优质题解的精华：

```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int N=210, M=100010;
const int INF=1e18;

struct Edge { int v, f, w, next; } e[M<<1];
int head[N], cnt[N], a[N], b[N], c[N];
int n, s, t, ecnt=1, sum, ans;
int dis[N], vis[N], pre[N], flow[N];

void addedge(int u, int v, int f, int w) {
    e[++ecnt] = {v, f, w, head[u]}; head[u] = ecnt;
    e[++ecnt] = {u, 0, -w, head[v]}; head[v] = ecnt;
}

int calc_cnt(int x) {
    int res=0;
    for(int i=2; i*i<=x; ++i) 
        while(x%i==0) res++, x/=i;
    if(x>1) res++;
    return res;
}

bool spfa() {
    queue<int> q;
    memset(vis, 0, sizeof(vis));
    fill(dis, dis+N, -INF);
    dis[s]=0; flow[s]=INF; vis[s]=1;
    q.push(s);
    while(!q.empty()) {
        int u=q.front(); q.pop(); vis[u]=0;
        for(int i=head[u]; i; i=e[i].next) {
            int v=e[i].v;
            if(e[i].f && dis[v]<dis[u]+e[i].w) {
                dis[v]=dis[u]+e[i].w;
                flow[v]=min(flow[u], e[i].f);
                pre[v]=i;
                if(!vis[v]) vis[v]=1, q.push(v);
            }
        }
    }
    return dis[t] > -INF;
}

void mcmf() {
    while(spfa()) {
        int delta = flow[t] * dis[t];
        if(sum + delta >= 0) {
            sum += delta;
            ans += flow[t];
            for(int u=t; u!=s; u=e[pre[u]^1].v) {
                e[pre[u]].f -= flow[t];
                e[pre[u]^1].f += flow[t];
            }
        } else {
            ans += sum / (-dis[t]);
            return;
        }
    }
}

signed main() {
    cin >> n; s=0; t=n+1;
    for(int i=1; i<=n; i++) cin >> a[i];
    for(int i=1; i<=n; i++) cin >> b[i];
    for(int i=1; i<=n; i++) cin >> c[i];
    
    for(int i=1; i<=n; i++) cnt[i] = calc_cnt(a[i]);
    
    for(int i=1; i<=n; i++) {
        if(cnt[i]&1) addedge(s, i, b[i], 0);
        else addedge(i, t, b[i], 0);
    }
    
    for(int i=1; i<=n; i++) if(cnt[i]&1)
        for(int j=1; j<=n; j++) 
            if(((a[i]%a[j]==0 && cnt[i]==cnt[j]+1) || 
                (a[j]%a[i]==0 && cnt[j]==cnt[i]+1)))
                addedge(i, j, INF, c[i]*c[j]);
    
    mcmf();
    cout << ans << endl;
    return 0;
}
```

**代码解读概要**：
1. **建图阶段**：根据质因数指数和奇偶性划分点集
2. **SPFA增广**：每次寻找收益最大的增广路径
3. **流量控制**：当总收益即将为负时，计算安全流量
4. **复杂度**：O(n^3) 可通过n≤200的数据

---
<code_intro_selected>
### 题解一核心代码赏析
```cpp
// SPFA最长路查找
bool spfa() {
    // ...初始化
    while(!q.empty()) {
        int u=q.front(); q.pop(); vis[u]=0;
        for(int e=adj[u]; e; e=nxt[e])
            if(cap[e] && dis[u]+cost[e] > dis[v]) {
                dis[v]=dis[u]+cost[frm[v]=e];
                if(!vis[v]) vis[que[++len]=v]=1;
            }
    }
    return dis[T] > -INF;
}
```
**亮点**：使用手写队列优化SPFA，`frm`数组记录路径  
**学习笔记**：SPFA中松弛操作时记录前驱边是回溯增广路径的关键

### 题解二核心代码赏析
```cpp
// 二分流量验证
bool check(int g) {
    // 重建带流量限制的图
    add(x,s,g,0); // 超源点控制流量
    // ...其他建图
    feiyong1(); // 跑费用流
    return maxcost>=0;
}
```
**亮点**：通过超源点控制最大流量  
**学习笔记**：二分流量上界是处理带约束网络流的通用方法

### 题解三核心代码赏析
```cpp
// Miller-Rabin质数判定
bool millar_rabbin(int n) {
    if(n<3 || n%2==0) return n==2;
    // ...使用快速幂进行概率判定
    return true;
}
```
**亮点**：O(k logn)判定大质数  
**学习笔记**：当n>10^7时，概率性质数检测比试除法高效

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为直观展示费用流执行过程，我设计了"像素舞会"动画方案：

### 设计概念
- **8位像素风格**：FC红白机复古风，使用16色调色板
- **场景元素**：
  - 左侧：蓝色像素小人（奇数cnt）
  - 右侧：红色像素小人（偶数cnt）
  - 舞池中央：闪烁的配对连线
- **控制面板**：开始/暂停、单步执行、速度滑块

### 动画关键帧
1. **初始化阶段**（像素粒子入场）：
   - 每个数字角色以像素方块呈现，头顶显示a_i值
   - 根据cnt奇偶性自动分列左右，底部显示数量b_i

2. **增广路径查找**（聚光灯效果）：
   ```伪代码
   while 存在增广路径:
       当前点闪烁绿光
       扫描出边时黄光脉冲
       找到路径时整条路径闪烁蓝光
   ```
   - 播放8-bit音效：选择路径时"嘀"声，找到路径时"叮咚"声

3. **流量增加阶段**（舞蹈动画）：
   - 配对角色间出现心形像素特效
   - 顶部费用计数器实时变化：绿色增值/红色减值
   - 流量增加时播放欢快旋律片段

4. **收益预警**（警报系统）：
   - 当`当前收益+Δ<0`时触发红光警报
   - 显示安全流量计算公式：`flow = sum/|dis[T]|`
   - 播放"警告"音效并暂停动画

### 交互设计
- **单步模式**：按空格键逐步执行SPFA松弛操作
- **自动演示**：AI自动执行完整算法（速度可调）
- **对比模式**：并排显示二分法（左）与直接增广法（右）

### 技术实现
- **Canvas绘制**：网格布局+像素精灵动画
- **音效系统**：Web Audio API生成8-bit音效
  - 路径发现：三角波短音（1200Hz）
  - 配对成功：方波和弦（800Hz+1200Hz）
- **数据驱动**：算法每步状态实时映射到视图

</visualization_intro>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的核心思想后，可挑战以下相似问题：

1. **洛谷 P4003 无限之环**  
   🗣️ **推荐理由**：同样需要巧妙的建图技巧，将旋转操作转化为网络流边

2. **洛谷 P3358 最长k可重区间集**  
   🗣️ **推荐理由**：费用流经典应用，学习如何将区间选择转化为网络流模型

3. **洛谷 P4015 运输问题**  
   🗣️ **推荐理由**：费用流模板题，巩固基本建模技巧

4. **洛谷 P2761 软件补丁问题**  
   🗣️ **推荐理由**：状态压缩与网络流的创新结合

---

## 7. 学习心得与经验分享

<insights_intro>
题解作者们的调试经验值得借鉴：

> **xyz32768的调试心得**：  
> "当测试点WA时，重点检查三类边界：①单个质数的情况 ②流量为0但费用非负 ③大整数相乘溢出"

> **Orion545的踩坑教训**：  
> "Miller-Rabin需要足够测试次数（k=100），否则可能误判质数导致图结构错误"

**Kay总结**：在费用流问题中，务必添加以下检查点：
1. 整数溢出（特别是费用相乘）
2. 边界流量（如b_i=0的情况）
3. 图结构对称性（正向边与反向边费用互为相反数）

---

<conclusion>
本次数字配对解题分析展示了网络流建模的精妙之处。关键在于：①利用质因数性质构建二分图 ②在费用流中处理价值约束。建议亲手实现可视化方案加深理解。记住，算法学习就像跳舞——理解节奏（问题本质）比记住舞步（代码）更重要！下次算法课再见！💃🕺
</conclusion>
```

---
处理用时：303.79秒
# 题目信息

# [JLOI2008] 将军

## 题目描述

刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\_T。

言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：

给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。

这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。

现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。

国际象棋中一共有 6 种棋子：

- king（国王）；
- queen（皇后）；
- bishop（教主）；
- knight（骑士）；
- rook（车）；
- pawn（步兵）。

各棋子的攻击范围如下：

- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；
- knight 的攻击范围如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

- rook 攻击水平和垂直两条线上的所有格子；
- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；
- king 攻击周围 8 个方向各 1 格；
- bishop 攻击两条对角线上的所有格子。

除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。

可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。

## 说明/提示

```plain
BBN
...
...
```

```plain
BBN
...
B..
```

虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。


## 样例 #1

### 输入

```
3 3
..N
...
...
```

### 输出

```
2```

# AI分析结果



---
# 💡 Kay的C++算法解析：[将军] 深入学习指南 💡

<introduction>
今天我们来一起分析“将军”这道C++编程题。这道题的核心是在国际象棋棋盘上放置最多的教主（bishop），确保它们互不攻击且不与已有棋子冲突。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论-二分图最大匹配（匈牙利算法）` 

🗣️ **初步分析**：
解决“将军”问题的关键在于将教主的对角线攻击问题转化为二分图匹配问题。简单来说，二分图最大匹配就像给两组人配对（比如男生和女生），每对只能选一个，最终找到最多的配对数。在本题中，我们可以将棋盘旋转45°，让原本的对角线变成“行”和“列”，这样每个可放置的教主位置需要同时占用一个“行”和一个“列”，问题就转化为求这两组的最大匹配数。

- **题解思路**：所有优质题解均采用“预处理攻击范围→旋转棋盘→构建二分图→匈牙利算法求最大匹配”的流程。核心难点在于正确计算所有棋子的攻击范围，并将其映射到旋转后的棋盘坐标。
- **核心算法流程**：首先标记所有被已有棋子攻击的位置（不可放置教主），然后将棋盘旋转45°，将每个可放置位置的“行”和“列”作为二分图的左右节点，最后通过匈牙利算法计算最大匹配数。
- **可视化设计**：计划采用8位像素风格动画，用不同颜色标记攻击区域（红色）、可放置区域（绿色），动态展示棋盘旋转过程，以及匈牙利算法如何逐步匹配“行”和“列”节点（用像素箭头连接匹配节点，关键步骤播放“叮”的音效）。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性和算法有效性的评估，以下题解评分均≥4星，值得重点学习：
</eval_intro>

**题解一：作者GNAQ（赞：8）**
* **点评**：此题解逻辑清晰，代码简洁高效。作者巧妙地将棋盘旋转45°，用链式前向星建图，并通过匈牙利算法求解最大匹配。代码中对不同棋子攻击范围的处理（如`GoK`、`GoQ`函数）非常细致，边界条件处理严谨（如判断棋盘越界）。亮点在于将复杂的攻击范围预处理封装成函数，提高了代码的可读性和复用性。

**题解二：作者caizehua（赞：4）**
* **点评**：此题解详细解释了棋盘旋转的坐标转换（原坐标(i,j)转为(i+j-1, j+n-i)），并通过结构体`node`存储旋转后的坐标和状态（可放置/不可放置）。攻击范围处理部分（如`B`、`K`、`R`函数）逻辑明确，尤其对“攻击被阻挡”的处理（遇到非`.`字符停止延伸）非常关键。代码注释丰富，适合初学者理解每一步操作。

**题解三：作者lly66666（赞：2）**
* **点评**：此题解以“二分图经典题目”为切入点，直接点明核心思路。预处理攻击范围时，通过方向数组（如`dx[9]`、`kx[9]`）统一处理不同棋子的攻击方向，代码结构紧凑。匈牙利算法部分使用邻接表建图，效率较高，适合竞赛场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点在于攻击范围预处理、棋盘旋转坐标转换和二分图建模。以下是具体分析和策略：
</difficulty_intro>

1.  **关键点1：正确预处理所有棋子的攻击范围**  
    * **分析**：不同棋子的攻击方式不同（如车直线攻击、骑士跳跃攻击），且攻击会被其他棋子阻挡（除骑士外）。例如，车的攻击需要向四个方向延伸，直到遇到棋盘边界或非`.`字符。优质题解通过方向数组和循环延伸的方式（如`for (int i=x+1;;i++)`）处理这类情况。  
    * 💡 **学习笔记**：攻击范围预处理时，需为每个棋子类型单独编写函数（如`GoK`处理国王），并注意“阻挡”条件的判断。

2.  **关键点2：棋盘旋转与坐标转换**  
    * **分析**：旋转45°后，原棋盘的对角线变为“行”和“列”。例如，原坐标(i,j)旋转后的行号为`i+j-1`，列号为`j+n-i`（n为行数）。这一步将教主的对角线攻击转化为“行”和“列”的互斥，为二分图建模奠定基础。  
    * 💡 **学习笔记**：旋转后的坐标需确保覆盖所有可能的对角线（最多`n+m-1`行/列），避免越界。

3.  **关键点3：二分图建模与最大匹配求解**  
    * **分析**：将旋转后的“行”和“列”作为二分图的左右节点，每个可放置的教主位置对应一条边（连接其行和列）。通过匈牙利算法找到最大匹配数，即为最多可放置的教主数。  
    * 💡 **学习笔记**：匈牙利算法的核心是寻找增广路径，需用`vis`数组标记已访问节点，避免重复计算。

### ✨ 解题技巧总结
- **问题抽象**：将复杂的棋盘问题抽象为二分图模型，利用图论工具简化计算。  
- **模块化处理**：将攻击范围预处理、坐标转换、建图等步骤封装为函数，提高代码可读性。  
- **边界检查**：处理攻击范围时，需频繁检查坐标是否越界（如`i<=n && j<=m`），避免数组越界错误。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了攻击预处理、坐标转换和匈牙利算法，适合作为参考模板。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了GNAQ和caizehua的题解思路，优化了攻击预处理和建图逻辑，确保清晰高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    #include <vector>
    using namespace std;

    const int MAXN = 1025;
    const int MAXM = 2050; // 旋转后行列数最大为n+m-1

    int n, m;
    char board[MAXN][MAXN];
    bool can_place[MAXN][MAXN]; // true表示可放置教主
    vector<int> graph[MAXM];    // 二分图邻接表（行→列）
    int match[MAXM];            // 列对应的匹配行
    bool vis[MAXM];             // 匈牙利访问标记

    // 预处理所有棋子的攻击范围
    void preprocess() {
        memset(can_place, true, sizeof(can_place));
        // 标记已有棋子的位置不可放置
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (board[i][j] != '.') can_place[i][j] = false;
            }
        }
        // 处理每种棋子的攻击范围（以国王为例，其他类似）
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                char c = board[i][j];
                if (c == 'K') { // 国王攻击周围8格
                    for (int dx = -1; dx <= 1; dx++) {
                        for (int dy = -1; dy <= 1; dy++) {
                            if (dx == 0 && dy == 0) continue;
                            int x = i + dx, y = j + dy;
                            if (x >= 1 && x <= n && y >= 1 && y <= m)
                                can_place[x][y] = false;
                        }
                    }
                }
                // 其他棋子处理（如车、骑士等）类似，此处省略
            }
        }
    }

    // 匈牙利算法找增广路径
    bool dfs(int u) {
        for (int v : graph[u]) {
            if (!vis[v]) {
                vis[v] = true;
                if (match[v] == 0 || dfs(match[v])) {
                    match[v] = u;
                    return true;
                }
            }
        }
        return false;
    }

    int main() {
        cin >> n >> m;
        for (int i = 1; i <= n; i++) {
            cin >> (board[i] + 1);
        }
        preprocess();

        // 旋转棋盘，建图（行号：i+j-1，列号：j+n-i）
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                if (can_place[i][j]) {
                    int row = i + j - 1;
                    int col = j + n - i;
                    graph[row].push_back(col);
                }
            }
        }

        // 匈牙利算法求最大匹配
        int ans = 0;
        for (int u = 1; u <= n + m - 1; u++) {
            memset(vis, false, sizeof(vis));
            if (dfs(u)) ans++;
        }
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先预处理攻击范围（`preprocess`函数），标记所有不可放置的位置；然后将可放置位置的旋转坐标（行和列）作为二分图的左右节点，建立边；最后通过匈牙利算法（`dfs`函数）计算最大匹配数，即为答案。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的巧妙设计：
</code_intro_selected>

**题解一（GNAQ）核心代码片段**：
```cpp
inline void BuildG() {
    int _x, _y;
    for (int i=1; i<=n; i++) {
        for (int j=1; j<=m; j++) if (!av[i][j]) {
            _x = pau[i][0] + j - 1; 
            _y = pau[i][1] + j - 1;
            if ((!h[_x]) && (!l[_y])) Insert(_x, _y + mapsiz);
        }
    }
}
```
* **亮点**：通过`pau`数组预处理旋转后的坐标偏移，简化了旋转计算。`Insert`函数使用链式前向星建图，高效存储边。  
* **代码解读**：`pau[i][0]`和`pau[i][1]`分别表示第i行在旋转后的起始行和列偏移。`_x`和`_y`计算旋转后的行和列，若该位置可放置（`!av[i][j]`），则建立边（`Insert`）。  
* 💡 **学习笔记**：预处理偏移量是优化坐标转换的常用技巧，可避免重复计算。

**题解二（caizehua）核心代码片段**：
```cpp
void init() { // 标记r,c数组
    int lenr = 1;
    for (int i=1; i<=n+m-1; i++) {
        for (int j=1; j<=n+m-1; j++) {
            if (mp[i][j] == -1) continue;
            if (!mp[i][j]) r[i][j] = lenr;
            else if (mp[i][j] == 1) lenr++;
        }
        lenr++;
    }
    // 类似处理c数组...
}
```
* **亮点**：通过`r`和`c`数组标记旋转后的行和列编号，处理攻击阻挡（`mp[i][j] == 1`时增加编号）。  
* **代码解读**：`lenr`记录当前行号，遇到阻挡（`mp[i][j] == 1`）时行号递增，确保同一行内的可放置位置共享同一个行号。  
* 💡 **学习笔记**：攻击阻挡会分割对角线，需为每个连续段分配不同的行/列号，避免错误匹配。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解棋盘旋转和二分图匹配过程，我们设计一个“像素探险家”主题的8位动画，用复古风格展示算法每一步！
</visualization_intro>

  * **动画演示主题**：`像素探险家的棋盘冒险——寻找最大教主放置方案`  
  * **核心演示内容**：展示棋盘旋转过程、攻击范围标记、二分图建图及匈牙利算法匹配。  
  * **设计思路简述**：8位像素风格（类似FC游戏）营造轻松氛围，用红色像素块标记攻击区域，绿色标记可放置区域。匹配过程用黄色箭头连接“行”和“列”节点，关键步骤播放“叮”音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为左右两部分：左侧是原棋盘（8x8像素格子），右侧是旋转后的棋盘（斜45°排列）。  
        - 控制面板包含“单步”“自动”“重置”按钮和速度滑块（1-5级，1最慢）。  
        - 播放8位风格背景音乐（如《超级马里奥》经典旋律）。

    2.  **攻击范围预处理**：  
        - 遍历每个棋子（如国王用紫色像素块），向周围8格发射红色光波（像素点扩散动画），标记攻击区域（红色格子）。  
        - 遇到其他棋子（如车）时，光波被阻挡（光波动画在阻挡点停止）。

    3.  **棋盘旋转动画**：  
        - 原棋盘顺时针旋转45°（像素格子逐个滑动到新位置），左侧原棋盘逐渐透明，右侧旋转后的棋盘逐渐清晰。  
        - 旋转后，原对角线变为水平行和垂直列（用蓝色和橙色区分行/列）。

    4.  **二分图建图**：  
        - 每个可放置位置（绿色格子）生成一条黄色边，连接对应的行和列节点（行节点在左，列节点在右，用数字编号）。  
        - 边生成时播放“咻”的音效，提示连接完成。

    5.  **匈牙利算法匹配**：  
        - 单步执行时，选择一个行节点（蓝色高亮），尝试匹配其连接的列节点（橙色高亮）。  
        - 若列节点未匹配，直接连接（黄色箭头固定）；若已匹配，递归检查原匹配行节点（红色闪烁），寻找增广路径。  
        - 匹配成功时播放“叮”音效，节点变为绿色；失败则播放“噗”音效，节点恢复原色。

    6.  **结果展示**：  
        - 所有匹配完成后，播放胜利音效（如《超级玛丽》吃金币音），右侧显示最大匹配数（金色数字）。  
        - 可放置的教主位置在原棋盘上用金色棋子图标显示，旋转后的棋盘用绿色边标记。

  * **旁白提示**：  
    - （预处理阶段）“看！国王的攻击范围覆盖了周围8格，这些位置不能放教主哦～”  
    - （旋转阶段）“现在棋盘旋转45°，原来的对角线变成了行和列，这样问题就变成了找最多的配对！”  
    - （匹配阶段）“当前行节点1尝试匹配列节点5…成功！这代表在旋转后的行1、列5的位置放一个教主～”

<visualization_conclusion>
通过这样的动画，我们可以直观看到攻击范围如何影响可放置位置，以及二分图匹配如何一步步找到最优解。复古像素风格和游戏化交互，让学习过程更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
二分图匹配是解决棋盘覆盖、资源分配等问题的通用工具。掌握本题后，可尝试以下题目巩固：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    二分图匹配适用于“两组元素互斥选择”的问题，例如：  
    - 棋盘覆盖（如车、教主的最大不攻击放置）；  
    - 任务分配（每个任务只能由一个人完成）；  
    - 课程安排（每个教室同一时间只能上一门课）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P2825 [HEOI2016/TJOI2016]游戏**  
        * 🗣️ **推荐理由**：本题与“将军”类似，需通过二分图匹配处理棋盘覆盖问题，适合巩固旋转棋盘和攻击预处理的技巧。  
    2.  **洛谷 P10945 [NOI2007] 货币兑换**  
        * 🗣️ **推荐理由**：虽然问题不同，但需将复杂条件转化为图论模型，锻炼抽象思维和二分图建模能力。  
    3.  **洛谷 P6062 [加油武汉] 疫情调查**  
        * 🗣️ **推荐理由**：结合二分图匹配和动态规划，提升综合解题能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> （来自caizehua的题解）“作者提到在输入棋盘时，若逐字符读取可能因换行符导致错误，建议先读取整行再处理。”  
> **点评**：输入处理是编程中常见的坑点。逐行读取（如`scanf("%s", s+1)`）可避免换行符干扰，确保棋盘数据正确。这提醒我们，在处理输入时需注意格式，必要时添加调试输出验证。

-----

<conclusion>
本次关于“将军”的C++解题分析就到这里。通过理解攻击预处理、棋盘旋转和二分图匹配的核心逻辑，相信大家已掌握此类问题的解决方法。记住，多动手调试、多做类似题目，是提升算法能力的关键！下次见～💪
</conclusion>

---
处理用时：137.55秒
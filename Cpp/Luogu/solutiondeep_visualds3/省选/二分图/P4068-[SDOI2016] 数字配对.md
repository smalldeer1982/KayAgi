# 题目信息

# [SDOI2016] 数字配对

## 题目描述

有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。

若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，

那么这两个数字可以配对，并获得 $c_i \times c_j$ 的价值。

一个数字只能参与一次配对，可以不参与配对。

在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。

## 说明/提示

测试点 $1 \sim 3$： $n \leq 10 $， $a_i \leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \leq 10 ^ 5$；   

测试点 $4 \sim 5$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5  $，$c_i = 0$；

测试点 $6 \sim 10$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5$ ，$ | c_i | \leq 10 ^ 5$。

## 样例 #1

### 输入

```
3
2 4 8
2 200 7
-1 -2 1
```

### 输出

```
4```

# AI分析结果



---

# 💡 Kay的C++算法解析：[SDOI2016] 数字配对 深入学习指南 💡

<introduction>
今天我们要一起攻克“[SDOI2016] 数字配对”这道题。它结合了数论、图论和网络流的知识，是一道非常经典的算法题。通过这份指南，你将理解如何将复杂的配对问题转化为网络流模型，并掌握费用流的变形应用技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：网络流（费用流的变形应用）

🗣️ **初步分析**：
解决这道题的关键在于将配对问题转化为**最大费用最大流问题**，并在总价值非负的约束下求最大流量。简单来说，费用流模型就像“运输货物”的过程：每个数字是一个“节点”，配对关系是“运输路线”，流量代表配对次数，费用代表每次配对的价值。我们需要在总价值≥0的前提下，找到最多能运输的“货物量”（即配对次数）。

### 核心思路与难点：
1. **条件转化**：题目要求两个数字满足“一个是另一个的倍数且商为质数”。通过质因数分解，我们发现这样的数字对满足“质因数个数差为1”，进而可以按质因数个数的奇偶性将数字分为两部分，形成二分图。
2. **网络流建模**：
   - 源点→奇数质因数个数的节点：容量为该数字的数量（b_i），费用0（无价值消耗）。
   - 偶数质因数个数的节点→汇点：容量为该数字的数量（b_i），费用0。
   - 可配对的节点间连边：容量无限（因为配对次数受限于两端节点的数量），费用为c_i×c_j（每次配对的价值）。
3. **价值非负约束**：传统最大费用最大流会直接求最大流量，但本题要求总价值≥0。因此，每次增广时需检查当前增广的总价值是否会导致总和变负，若会则调整流量。

### 可视化设计思路：
我们将用8位像素风格模拟费用流的增广过程：
- **场景**：像素化的“数字工厂”，奇数节点（左区）和偶数节点（右区）用不同颜色（如蓝/红）区分。
- **动画**：源点（绿色）向奇数节点“运输”流量（像素方块），配对边用闪烁的箭头表示，汇点（黄色）接收流量。每次增广时，高亮当前处理的边和节点，伴随“叮”的音效（流量流动）和“滴答”音效（费用计算）。
- **交互**：支持单步/自动播放，调速滑块控制速度，同步显示当前总流量和总价值。当总价值即将变负时，用红色警告框提示并停止。

---

## 2. 精选优质题解参考

<eval_intro>
经过对多份题解的评估（思路清晰性、代码规范性、算法有效性等），以下3份题解因逻辑严谨、实现高效且易于学习，被选为优质参考：
</eval_intro>

### 题解一：作者xyz32768（赞16）
* **点评**：此题解思路清晰，直接抓住了“质因数个数奇偶分图”的关键，正确构建了费用流模型。代码规范（如变量名`cnt[i]`表示质因数个数），边界处理严谨（如SPFA初始化），特别是对“总价值非负”的处理（通过贪心调整增广流量）非常巧妙。实践价值高，适合直接参考。

### 题解二：作者Orion545（赞9）
* **点评**：此题解详细解释了“质因数个数差1”的性质，并强调了二分图的构建逻辑。代码中对质因数分解的优化（预筛质数）和费用流的贪心调整（根据当前总价值决定增广流量）是亮点。适合理解算法底层逻辑的学习者。

### 题解三：作者Ebola（赞0）
* **点评**：此题解代码简洁，直接实现了核心费用流逻辑。虽然赞数较少，但对“质因数分解”和“费用流增广条件”的处理非常到位，尤其是`BellmanFord`函数中对费用的判断，适合快速掌握代码实现。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，以下3个难点是关键，我们需要逐一突破：
</difficulty_intro>

### 1. 关键点1：如何将配对条件转化为图论模型？
- **分析**：配对条件要求两个数满足“商为质数”，这等价于它们的质因数个数差1（例如，a=2×3，b=2，质因数个数分别为2和1，差1）。因此，可将数字按质因数个数的奇偶性分为两部分，形成二分图。
- 💡 **学习笔记**：数论性质（质因数分解）是构建图模型的基础，抓住“差1”的特性是关键。

### 2. 关键点2：如何构建费用流模型？
- **分析**：源点连奇数节点（容量b_i，费用0），偶数节点连汇点（容量b_i，费用0），可配对的节点间连边（容量∞，费用c_i×c_j）。这样，流量代表配对次数，费用总和即为总价值。
- 💡 **学习笔记**：费用流模型的核心是“流量”和“费用”的对应，需明确每条边的意义（容量限制、费用计算）。

### 3. 关键点3：如何保证总价值≥0？
- **分析**：费用流的增广路按费用从高到低选择。若当前增广的总费用（流量×单位费用）会使总和变负，则最多只能取`总价值 / (-单位费用)`的流量，避免总和变负。
- 💡 **学习笔记**：贪心策略在费用流中的应用，需注意增广路的费用单调性（后续增广路费用≤当前）。

### ✨ 解题技巧总结
- **质因数分解优化**：预筛小质数（如1e5内的质数），加速分解过程。
- **二分图构建**：奇偶分图后，配对边仅存在于两部分之间，避免环的产生。
- **费用流调整**：每次增广后检查总价值，及时调整流量以满足约束。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的核心实现，结合了清晰的模型构建和关键逻辑处理：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：此代码综合了xyz32768和Orion545的思路，重点展示二分图构建和费用流增广逻辑，适合直接学习。
* **完整核心代码**：
```cpp
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <queue>
using namespace std;
typedef long long ll;
const int N = 210, M = 5e5 + 5;
const ll INF = 1ll << 61;

int n, a[N], b[N], c[N], cnt[N], ecnt = 1;
int nxt[M], adj[N], st[M], go[M], frm[M], S, T;
ll cap[M], cost[M], dis[N], sum, ans;
bool vis[N];

void add_edge(int u, int v, ll w, ll x) {
    nxt[++ecnt] = adj[u]; adj[u] = ecnt; st[ecnt] = u;
    go[ecnt] = v; cap[ecnt] = w; cost[ecnt] = x;
    nxt[++ecnt] = adj[v]; adj[v] = ecnt; st[ecnt] = v;
    go[ecnt] = u; cap[ecnt] = 0; cost[ecnt] = -x;
}

int sigma(int x) { // 计算质因数个数
    int tot = 0;
    for (int i = 2; i * i <= x; ++i)
        while (x % i == 0) x /= i, tot++;
    if (x > 1) tot++;
    return tot;
}

bool spfa() { // 最长路（最大费用）SPFA
    memset(vis, 0, sizeof(vis));
    fill(dis, dis + N, -INF);
    queue<int> q; q.push(S);
    dis[S] = 0; vis[S] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        for (int e = adj[u]; e; e = nxt[e]) {
            int v = go[e];
            if (cap[e] && dis[v] < dis[u] + cost[e]) {
                dis[v] = dis[u] + cost[e];
                frm[v] = e;
                if (!vis[v]) q.push(v), vis[v] = 1;
            }
        }
    }
    return dis[T] != -INF;
}

bool add() { // 增广并调整流量
    ll fl = INF;
    for (int e = frm[T]; e; e = frm[st[e]])
        fl = min(fl, cap[e]);
    ll delta = dis[T] * fl;
    if (sum + delta >= 0) {
        sum += delta; ans += fl;
        for (int e = frm[T]; e; e = frm[st[e]])
            cap[e] -= fl, cap[e ^ 1] += fl;
        return 1;
    } else {
        ans += sum / (-dis[T]);
        return 0;
    }
}

ll solve() {
    while (spfa() && add());
    return ans;
}

int main() {
    n = read();
    for (int i = 1; i <= n; ++i) a[i] = read();
    for (int i = 1; i <= n; ++i) b[i] = read();
    for (int i = 1; i <= n; ++i) c[i] = read();
    S = 0; T = n + 1;

    for (int i = 1; i <= n; ++i) cnt[i] = sigma(a[i]);
    for (int i = 1; i <= n; ++i) {
        if (cnt[i] % 2) add_edge(S, i, b[i], 0);
        else add_edge(i, T, b[i], 0);
    }
    for (int i = 1; i <= n; ++i) {
        if (cnt[i] % 2) {
            for (int j = 1; j <= n; ++j) {
                if ((cnt[i] == cnt[j] + 1 && a[i] % a[j] == 0) || 
                    (cnt[j] == cnt[i] + 1 && a[j] % a[i] == 0)) {
                    add_edge(i, j, INF, 1ll * c[i] * c[j]);
                }
            }
        }
    }
    cout << solve() << endl;
    return 0;
}
```
* **代码解读概要**：代码首先计算每个数的质因数个数（`sigma`函数），然后构建二分图（奇数连源点，偶数连汇点），并连接可配对节点的边（容量INF，费用c_i×c_j）。通过SPFA找最长路（最大费用增广路），每次增广时检查总价值是否非负，调整流量后更新答案。

---

<code_intro_selected>
接下来，我们赏析优质题解中的核心代码片段：
</code_intro_selected>

### 题解一（xyz32768）核心代码片段
* **亮点**：SPFA找最长路，贪心调整增广流量。
* **核心代码片段**：
```cpp
bool spfa() {
    // 初始化dis为-INF，队列处理最长路
    for (int i = S; i <= T; i++) vis[i] = 0, dis[i] = -INF;
    dis[que[len = 1] = S] = 0;
    for (int i = 1; i <= len; i++) {
        int u = que[i]; vis[u] = 0;
        for (int e = adj[u]; e; e = nxt[e]) {
            if (cap[e] && dis[u] + cost[e] > dis[go[e]]) {
                dis[go[e]] = dis[u] + cost[e];
                frm[go[e]] = e;
                if (!vis[go[e]]) vis[que[++len] = go[e]] = 1;
            }
        }
    }
    return dis[T] > -INF;
}

bool add() {
    ll fl = INF;
    for (int e = frm[T]; e; e = frm[st[e]])
        fl = min(fl, cap[e]);
    ll delta = dis[T] * fl;
    if (sum + delta >= 0) {
        sum += delta; ans += fl;
        // 更新边容量
        return 1;
    } else {
        ans += sum / (-dis[T]);
        return 0;
    }
}
```
* **代码解读**：`spfa`函数用于找最长增广路（最大费用），`add`函数处理增广流量并调整总价值。若当前增广的总价值会使总和变负，则取`sum / (-dis[T])`的流量，确保总和≥0。
* 💡 **学习笔记**：最长路SPFA是费用流的核心，需注意初始化和队列处理；贪心调整流量是满足题目约束的关键。

### 题解二（Orion545）核心代码片段
* **亮点**：预筛质数优化质因数分解，费用流增广条件判断。
* **核心代码片段**：
```cpp
void init() { // 预筛质数
    v[1] = 1;
    for (int i = 2; i <= 100000; i++) {
        if (!v[i]) pri[++tot] = i;
        for (int j = 1; j <= tot; j++) {
            int k = i * pri[j]; if (k > 100000) break;
            v[k] = 1; if (i % pri[j] == 0) break;
        }
    }
}

ll cntprime(ll x) { // 质因数分解
    ll re = 0, c = 1;
    while (x > 1 && c <= tot) {
        while (x % pri[c] == 0) x /= pri[c], re++;
        c++;
    }
    if (c == tot + 1 && x > 1) return 1;
    return re;
}
```
* **代码解读**：`init`函数预筛1e5内的质数，加速后续分解；`cntprime`函数利用预筛结果快速计算质因数个数。
* 💡 **学习笔记**：预筛质数是优化质因数分解的常用技巧，可显著提高效率。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解费用流的增广过程和价值计算，我们设计了一个“数字配对工厂”像素动画，用8位风格模拟流量流动和费用累积：
</visualization_intro>

### 动画演示主题：像素数字配对工厂
- **核心演示内容**：展示源点→奇数节点→偶数节点→汇点的流量流动，高亮每次增广的路径，动态显示总流量和总价值，当总价值即将变负时触发警告。

### 设计思路：
- **8位像素风格**：使用FC红白机色调（蓝/红/绿/黄），节点用方块表示（奇数蓝、偶数红、源绿、汇黄）。
- **动态数据展示**：左侧显示当前增广路的单位费用（dis[T]），右侧显示总流量（ans）和总价值（sum），用数字滚动效果更新。
- **音效交互**：流量流动时播放“叮~”音效，费用计算时“滴答”，总价值变负时“嗡~”警告。

### 动画帧步骤：
1. **初始化**：绘制源点（绿方块）、奇数节点（蓝方块）、偶数节点（红方块）、汇点（黄方块），连接边用灰色虚线。
2. **增广开始**：SPFA找最长路，路径边变为黄色闪烁，节点按访问顺序高亮（蓝→黄→红→黄）。
3. **流量流动**：像素方块（代表流量）从源点出发，沿路径移动，边容量减少（虚线变细），反向边容量增加（虚线变粗）。
4. **费用计算**：每流动一个方块，总价值增加`dis[T]`（数字滚动），伴随“滴答”音效。
5. **价值警告**：若当前增广会使总价值变负，路径边变红，弹出提示框“总价值将变负！”，仅流动`sum / (-dis[T])`个方块后停止。
6. **结束**：总流量和总价值定格，播放“胜利”音效（欢快的8位旋律）。

<visualization_conclusion>
通过这个动画，你可以直观看到费用流如何一步步“运输”流量，并在价值约束下调整策略。像素风格的设计让抽象的算法变得生动，更容易理解每一步的意义。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以通过以下题目巩固费用流的应用，并拓展思路：
</similar_problems_intro>

### 通用思路/技巧迁移：
费用流模型适用于“资源分配+价值约束”的问题，例如：
- 任务分配（不同任务有不同收益，求最大收益下的任务数）。
- 运输问题（不同路线有不同成本，求总成本≤预算时的最大运输量）。
- 网络匹配（带权匹配，求总权≥0时的最大匹配数）。

### 练习推荐 (洛谷)：
1. **洛谷 P3381 - 最小费用最大流**  
   🗣️ **推荐理由**：经典费用流题，巩固基础模型，理解最小费用与最大流量的关系。
2. **洛谷 P4016 - 负载平衡问题**  
   🗣️ **推荐理由**：将问题转化为费用流模型，练习如何将实际场景抽象为网络流。
3. **洛谷 P4018 -  Roy&October之取石子**  
   🗣️ **推荐理由**：结合博弈论与费用流，拓展模型应用边界，提升综合解题能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自Orion545)**：“在处理质因数分解时，一开始忘记处理x>1的情况（即剩余大质数），导致cnt[i]计算错误，后来通过打印中间变量发现了问题。”

**点评**：质因数分解时，若x在循环后仍大于1，说明它本身是质数，需计入cnt。作者通过打印中间变量定位错误，这是调试的重要技巧。学习时，遇到错误可尝试输出关键变量（如cnt[i]），快速定位问题。

---

<conclusion>
通过这篇指南，我们深入理解了“数字配对”的解法：从质因数分解到二分图构建，再到费用流的变形应用。关键是将问题转化为网络流模型，并在增广时处理价值约束。希望你能通过练习巩固这些技巧，在算法之路上更进一步！💪
</conclusion>

---
处理用时：132.92秒
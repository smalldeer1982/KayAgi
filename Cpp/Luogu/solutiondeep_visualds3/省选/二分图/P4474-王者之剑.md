# 题目信息

# 王者之剑

## 题目描述

![https://cdn.luogu.com.cn/upload/pic/17920.png](https://cdn.luogu.com.cn/upload/pic/17920.png)  

这是在阿尔托利亚·潘德拉贡成为英灵前的事情，她正要去拔出石中剑成为亚瑟王，在这之前她要去收集一些宝石。

宝石排列在一个 $n \times m$ 的网格中，每个网格中有一块价值为 $v_{i,j}$ 的宝石，阿尔托利亚·潘德拉贡可以选择自己的起点。

开始时刻为 $0$ 秒。以下操作，每秒按顺序执行。

1. 在第 $i$ 秒开始的时候，阿尔托利亚·潘德拉贡在方格 $(x,y)$ 上，她可以拿走 $(x, y)$ 中的宝石。
2. 在偶数秒，阿尔托利亚·潘德拉贡周围四格的宝石会消失。
3. 若阿尔托利亚·潘德拉贡第 $i$ 秒开始时在方格 $(x,y)$ 上，则在第 $i+1$ 秒可以立即移动到 $(x+1,y),(x,y+1),(x-1,y)$ 或 $(x, y- 1)$ 上，也可以停留在（$x,y)$ 上。


求阿尔托利亚·潘德拉贡最多可以获得多少价值的宝石

## 说明/提示

姚金宇的原创题。

## 样例 #1

### 输入

```
2 2
1 2
2 1```

### 输出

```
4```

# AI分析结果



---
# 💡 Kay的C++算法解析：王者之剑 深入学习指南 💡

<introduction>
今天我们来一起分析“王者之剑”这道C++编程题。本指南将帮助大家理解题目核心、掌握网络流建模技巧，并通过可视化动画直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（二分图最大权独立集 + 网络流最小割）

🗣️ **初步分析**：
解决“王者之剑”的关键在于将问题转化为二分图最大权独立集问题。简单来说，独立集是指图中没有相邻节点的集合，而最大权独立集就是权值和最大的独立集。本题中，“不能同时取相邻宝石”的条件正好对应独立集的定义。

- **题解思路**：所有优质题解均通过黑白染色（类似棋盘，横纵坐标和奇偶性不同的格子分属两个集合）将网格转化为二分图，然后利用网络流求最小割，最终用总权值减去最小割得到最大权独立集。
- **核心难点**：如何将“不能取相邻宝石”的条件转化为网络流模型？如何证明独立集与合法方案的一一对应？
- **算法流程**：
  1. 黑白染色，将网格分为黑点（横纵坐标和为奇数）和白点（和为偶数）。
  2. 源点S连所有黑点，边权为该点宝石价值；所有白点连汇点T，边权为该点价值。
  3. 每个黑点向相邻的白点连边权为INF的边（保证相邻点不同时选）。
  4. 求S到T的最小割，总权值减去最小割即为答案。
- **可视化设计**：采用8位像素风格动画，用不同颜色区分黑白点，INF边用金色粗线表示，流的流动用蓝色箭头动态展示。关键步骤（如割边、选点）伴随“叮”的音效，完成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解值得重点学习：
</eval_intro>

**题解一：RemiliaScar1et**（来源：洛谷用户）
* **点评**：此题解详细证明了独立集与合法方案的一一对应关系（通过构造S形路线验证），逻辑严谨。代码规范，使用Dinic算法并优化了空间（如`index_`函数简化坐标转换），边界处理（如检查相邻点是否越界）严谨。亮点在于理论证明与代码实现的结合，适合深入理解建模本质。

**题解二：VenusM1nT**（来源：洛谷用户）
* **点评**：此题解直接指出本题与“方格取数问题”的联系，代码简洁清晰。通过弧优化Dinic提升效率，变量名（如`fst`表示邻接表头）含义明确。亮点在于快速迁移经典问题解法，适合快速上手。

**题解三：Lagerent**（来源：洛谷用户）
* **点评**：此题解代码结构工整，Dinic实现标准（含BFS分层和DFS增广），关键变量（如`cur`数组实现当前弧优化）注释清晰。亮点在于代码的可读性和算法实现的正确性，适合初学者模仿。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点在于建模与网络流实现，以下是关键分析：
</difficulty_intro>

1.  **关键点1：如何将问题转化为二分图最大权独立集？**
    * **分析**：网格相邻点横纵坐标和奇偶性不同，天然构成二分图。独立集要求无相邻点，与题目“不能取相邻宝石”条件一致。通过黑白染色将网格分为两部分，问题转化为求二分图最大权独立集。
    * 💡 **学习笔记**：棋盘染色是处理网格相邻问题的常用技巧，可快速构建二分图模型。

2.  **关键点2：如何用网络流求最大权独立集？**
    * **分析**：最大权独立集 = 总权值 - 最小点覆盖。根据Konig定理，二分图的最小点覆盖等于最大匹配，而最小点覆盖对应网络流的最小割。通过源点连黑点、汇点连白点、相邻点连INF边的建模，最小割即为最小点覆盖的权值。
    * 💡 **学习笔记**：网络流建模的核心是将“选/不选”转化为割边，INF边保证相邻点不同时选。

3.  **关键点3：如何高效实现Dinic算法？**
    * **分析**：Dinic的BFS分层（确保增广路径最短）和DFS增广（当前弧优化避免重复计算）是关键。需注意边的初始化（正向边权为容量，反向边为0）和边界处理（如检查相邻点是否越界）。
    * 💡 **学习笔记**：当前弧优化能显著提升Dinic效率，是处理大规模数据的必备技巧。

### ✨ 解题技巧总结
- **问题抽象**：将“不能取相邻点”抽象为独立集问题，通过染色构建二分图。
- **网络流建模**：源点连左部点、汇点连右部点，相邻点连INF边，最小割即最小点覆盖。
- **代码优化**：使用当前弧优化（`cur`数组）和分层BFS提升Dinic效率。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，代码清晰且高效：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合RemiliaScar1et和Lagerent的题解，采用Dinic算法，包含完整的建图和最大流计算。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 1e4 + 10, M = 1e5 + 10, INF = 1e8;
    int n, m, S, T;
    int h[N], e[M], f[M], ne[M], idx;
    int q[N], depth[N], cur[N];

    int get_idx(int x, int y) {
        return (x - 1) * m + y;
    }

    void add(int a, int b, int c) {
        e[idx] = b, f[idx] = c, ne[idx] = h[a], h[a] = idx++;
        e[idx] = a, f[idx] = 0, ne[idx] = h[b], h[b] = idx++;
    }

    bool bfs() {
        memset(depth, -1, sizeof(depth));
        int hh = 0, tt = 0;
        q[0] = S, depth[S] = 0, cur[S] = h[S];
        while (hh <= tt) {
            int u = q[hh++];
            for (int i = h[u]; ~i; i = ne[i]) {
                int v = e[i];
                if (depth[v] == -1 && f[i] > 0) {
                    depth[v] = depth[u] + 1;
                    cur[v] = h[v];
                    q[++tt] = v;
                    if (v == T) return true;
                }
            }
        }
        return false;
    }

    int dfs(int u, int limit) {
        if (u == T) return limit;
        int flow = 0;
        for (int i = cur[u]; ~i && flow < limit; i = ne[i]) {
            cur[u] = i;
            int v = e[i];
            if (depth[v] == depth[u] + 1 && f[i] > 0) {
                int t = dfs(v, min(f[i], limit - flow));
                if (!t) depth[v] = -1;
                f[i] -= t;
                f[i ^ 1] += t;
                flow += t;
            }
        }
        return flow;
    }

    int dinic() {
        int res = 0, flow;
        while (bfs()) while (flow = dfs(S, INF)) res += flow;
        return res;
    }

    int main() {
        scanf("%d%d", &n, &m);
        S = 0, T = n * m + 1;
        memset(h, -1, sizeof(h));
        int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};
        int tot = 0;

        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                int w; scanf("%d", &w);
                tot += w;
                if ((i + j) & 1) { // 黑点，连源点
                    add(S, get_idx(i, j), w);
                    for (int k = 0; k < 4; ++k) { // 连相邻白点
                        int x = i + dx[k], y = j + dy[k];
                        if (x >= 1 && x <= n && y >= 1 && y <= m)
                            add(get_idx(i, j), get_idx(x, y), INF);
                    }
                } else { // 白点，连汇点
                    add(get_idx(i, j), T, w);
                }
            }
        }
        printf("%d\n", tot - dinic());
        return 0;
    }
    ```
* **代码解读概要**：
  - `get_idx`：将二维坐标转化为一维节点编号。
  - `add`：添加有向边（正向边和反向边）。
  - `bfs`：分层，确定各节点到源点的距离。
  - `dfs`：增广，寻找阻塞流。
  - `dinic`：主函数，循环调用BFS和DFS计算最大流。
  - 主函数：读取输入，建图（源点连黑点、黑点连相邻白点、白点连汇点），计算总权值减去最大流（最小割）即为答案。

---
<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：RemiliaScar1et**
* **亮点**：详细证明独立集与合法方案的对应关系，代码规范（如`index_`函数）。
* **核心代码片段**：
    ```cpp
    inline int index_(int i,int j) { return (i-1)*m+j; }
    // 建图部分
    if((i+j)&1) {
        add(S, index_(i,j), x);
        for(int k=0;k<4;k++) {
            int xx=i+dx[k],yy=j+dy[k];
            if(xx>=1&&xx<=n&&yy>=1&&yy<=m)
                add(index_(i,j), index_(xx,yy), INF);
        }
    } else {
        add(index_(i,j), T, x);
    }
    ```
* **代码解读**：
  - `index_`函数将二维坐标转换为唯一节点编号，简化后续操作。
  - 黑点（`(i+j)&1`为真）连源点，边权为宝石价值；同时向四个相邻白点连INF边（保证不能同时选）。
  - 白点连汇点，边权为宝石价值。
* 💡 **学习笔记**：坐标转换函数是处理网格问题的常用技巧，能避免重复计算。

**题解二：VenusM1nT**
* **亮点**：弧优化Dinic，提升效率。
* **核心代码片段**：
    ```cpp
    int Dinic() {
        int sum=0;
        while(Bfs()) {
            memcpy(cur,fst,sizeof(fst));
            sum+=Dfs(S,inf);
        }
        return sum;
    }
    ```
* **代码解读**：
  - `Bfs`分层后，`memcpy(cur,fst,sizeof(fst))`实现当前弧优化，避免重复访问已处理的边。
  - 每次BFS后，通过DFS寻找所有增广路径，累加流量。
* 💡 **学习笔记**：当前弧优化是Dinic算法的核心优化，能将时间复杂度从O(N^2M)降至O(NM^2)。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解网络流建模和最小割的形成，我们设计一个“像素探险家”主题的8位风格动画：
</visualization_intro>

  * **动画演示主题**：像素探险家的宝石收集之旅

  * **核心演示内容**：展示黑白染色后的网格、源点/汇点的连接、INF边的作用，以及流的流动过程（最小割的形成）。

  * **设计思路简述**：8位像素风格（FC红白机配色）营造复古感，用不同颜色区分黑白点（黑点：蓝色，白点：粉色），INF边用金色粗线表示。关键步骤（如选点、割边）伴随“叮”的音效，完成时播放胜利音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 网格背景为浅灰色，黑点（蓝色方块）和白点（粉色方块）按棋盘分布。
        - 控制面板：单步/自动播放按钮、速度滑块、重置按钮。
        - 8位风格背景音乐（如《超级马里奥》主题曲变奏）。

    2.  **建图过程**：
        - 源点（黄色圆点）向所有黑点连绿色边（边权为宝石价值）。
        - 所有白点向汇点（红色圆点）连紫色边（边权为宝石价值）。
        - 黑点向相邻白点连金色粗线（INF边），伴随“唰”的音效。

    3.  **流的流动（Dinic算法）**：
        - BFS分层：用蓝色箭头标记节点层次（源点为0层，逐层递增）。
        - DFS增广：用蓝色水流动画展示流从源点→黑点→白点→汇点的流动，遇到INF边时水流加粗（表示无法割断）。
        - 割边：当某条绿边或紫边被割断（流量耗尽），边变为灰色，对应点不被选中。

    4.  **结果展示**：
        - 最终选中的点（未被割断的边对应点）用金色高光闪烁，伴随“胜利”音效。
        - 总权值和最小割值在屏幕上方显示，差值即为答案。

  * **旁白提示**：
    - “看！蓝色是黑点，粉色是白点，相邻点颜色不同哦～”
    - “源点连黑点，汇点连白点，金色粗线是INF边，保证相邻点不能同时选！”
    - “流在流动时，会优先选择边权小的边割断，这就是最小割～”

<visualization_conclusion>
通过这样的动画，我们能直观看到网络流建模的过程，理解为什么“总权值-最小割”就是答案。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下题目巩固网络流建模能力：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    二分图最大权独立集模型适用于所有“选点且不相邻”的问题，如棋盘覆盖、任务调度（任务间有冲突）等。关键是通过染色或其他方式构建二分图。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P2774 方格取数问题**
        * 🗣️ **推荐理由**：与本题完全同模型，适合验证对二分图最大权独立集的理解。
    2.  **洛谷 P1345 [USACO5.4]奶牛的电信**
        * 🗣️ **推荐理由**：考察最小点覆盖的应用，需将问题转化为二分图模型。
    3.  **洛谷 P1935 [国家集训队]圈地计划**
        * 🗣️ **推荐理由**：涉及网格分割，需结合二分图和最小割，提升建模复杂度。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到的问题，如边初始化错误、当前弧优化未实现等，这些经验值得借鉴：
</insights_intro>

> **参考经验 (来自VenusM1nT)**：“一开始把方格取数的代码复制过来加弧优化得40分，后来发现Dfs里的flow写成了flow-used，调试了很久。”

**点评**：这位作者的经历提醒我们，网络流代码的细节（如变量名、初始化）非常重要。调试时可打印中间变量（如边的剩余容量），或使用小规模测试用例验证。

-----

<conclusion>
本次关于“王者之剑”的分析就到这里。通过理解二分图建模和网络流算法，相信大家能轻松解决类似问题。记住，多动手写代码、调试，是提升算法能力的关键！下次见～💪
</conclusion>

-----

---
处理用时：131.01秒
# 题目信息

# [SDOI2019] 热闹的聚会与尴尬的聚会

## 题目背景

小 Q 的生日快到了，他决定周末邀请一些朋友到他的新房子一起聚会！

## 题目描述

他的联系薄上有 $n$ 位好友，他们两两之间或者互相认识，或者互相不认识。小 Q 希望在周六办一个热闹的聚会，再在周日办一个尴尬的聚会。

- 一场热闹度为 $p$ 的聚会请来了任意多位好友，对于每一位到场的好友来说都有至少 $p$ 位他认识的好友也参加了聚会，且至少对于一位到场的好友来说现场恰好有 $p$ 位他认识的好友；
- 一场尴尬度为 $q$ 的聚会请来了恰好 $q$ 位好友，且他们两两互不认识。

两场聚会可能有重复的参与者，联系薄上也有可能有某些好友同时缺席了两场聚会。

小 Q 喜欢周六聚会的热闹度 $p$ 与周日聚会的尴尬度 $q$ 之间满足：$\left\lfloor \frac{n}{p+1} \right\rfloor\! \le q$ 且 $\left\lfloor \frac{n}{q+1} \right\rfloor\! \le p$。

请帮助小 Q 找出一个可行的邀请方案。

## 说明/提示

#### 数据规模与约定

- 子任务 $1$（$10$ 分）：$1\le n\le 500$；  
- 子任务 $2$（$10$ 分）：$1\le n\le 700$；  
- 子任务 $3$（$10$ 分）：$1\le n\le 900$；  
- 子任务 $4$（$10$ 分）：$1\le n\le 1.1 \times {10}^3$；  
- 子任务 $5$（$10$ 分）：$1\le n\le 2 \times {10}^3$；  
- 子任务 $6$（$10$ 分）：$1\le n\le 3 \times {10}^3$；  
- 子任务 $7$（$10$ 分）：$1\le n\le 4.5 \times {10}^3$；  
- 子任务 $8$（$10$ 分）：$1\le n\le 6 \times {10}^3$；  
- 子任务 $9$（$10$ 分）：$1\le n\le 8 \times {10}^3$；  
- 子任务 $10$（$10$ 分）：$1\le n\le {10}^4$。

对于全部的测试点，满足 $1\le T\le 32$ 且 $1\le m\le 10^5$。

---

#### 提示

本题读入量很大，请注意自己代码在读入上的所需时间。

---
#### 说明

感谢 @[81179332\_](/user/53994) 提供 spj！

## 样例 #1

### 输入

```
2
6 15
1 2
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6
4 5
4 6
5 6
8 11
1 2
2 3
1 4
3 7
4 5
5 2
2 6
6 7
5 6
5 8
6 8```

### 输出

```
6 1 2 3 4 5 6
1 4
8 1 2 3 4 5 6 7 8
4 8 4 7 2```

# AI分析结果



---
# 💡 Kay的C++算法解析：[SDOI2019] 热闹的聚会与尴尬的聚会 深入学习指南 💡

<introduction>
今天我们要分析的题目是“[SDOI2019] 热闹的聚会与尴尬的聚会”。这道题需要构造两个特定的点集，分别满足“热闹度”和“尴尬度”的条件。通过分析题解，我们会发现贪心算法是解决本题的关键，接下来让我们一步步拆解思路。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`贪心算法`

🗣️ **初步分析**：
解决这道题的核心在于理解贪心策略的应用。贪心算法的核心思想是“每一步选择当前最优解”，就像你在超市选水果时，每次挑最新鲜的，最终得到的整体结果也不会差。在本题中：

- **热闹的聚会（求p）**：我们需要找到一个子图，使得子图中所有点的度数至少为p，且存在至少一个点的度数恰好为p。贪心策略是：从原图开始，不断删除当前度数最小的点（因为它无法满足更高的p要求），并记录过程中最大的最小度数作为p。
- **尴尬的聚会（求q）**：需要找到一个独立集（两两不相连的点集），大小为q。贪心策略是：每次选当前度数最小的点加入独立集（因为它的邻接点最少，删除后对剩余图的影响最小），并删除其所有邻接点，确保独立集的大小q满足条件。

核心难点在于如何高效维护度数变化（用优先队列/堆），以及如何证明贪心构造的q满足题目中的不等式。可视化设计时，我们可以用像素动画展示“删点”和“选独立集”的过程，用颜色标记当前处理点、已删除点和独立集点，配合音效提示关键操作（如“叮”表示选点，“嗒”表示删点）。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解值得重点学习：
</eval_intro>

**题解一：liuzhangfeiabc（赞：28）**
* **点评**：此题解思路清晰，代码高效。使用优先队列维护当前各点的度数，动态删除最小度数点，同时构造独立集。代码中通过`nwd`数组维护实时度数，`shan`数组记录删除顺序，边界处理严谨（如清空队列、重置标记数组）。亮点在于输入输出优化（`gc`和`pc`宏加速IO），适合竞赛场景。

**题解二：StudyingFather（赞：16）**
* **点评**：此题解逻辑直白，变量命名直观（如`ansp`表示p的结果，`ansq`表示q的结果）。通过`memcpy`复用度数数组，避免重复计算。代码结构工整，注释清晰，适合初学者理解贪心过程。

**题解三：Purslane（赞：2）**
* **点评**：此题解简洁实现了贪心策略，使用优先队列维护度数，构造p和q的过程分离。代码中`ot`和`ans`分别存储两个集合的结果，逻辑清晰，适合快速复现。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，常见的难点和应对策略如下：
</difficulty_intro>

1.  **关键点1：如何高效维护动态度数（求p）**
    * **分析**：每次删除一个点后，其邻接点的度数会减1。直接遍历更新邻接点的度数并重新排序效率低，因此需要用优先队列（最小堆）来快速获取当前度数最小的点。注意堆中可能存在“过时”的度数记录（即点的度数已被更新但堆中仍存旧值），需通过标记跳过这些无效记录。
    * 💡 **学习笔记**：优先队列适合处理“动态最小值”问题，但需注意维护数据的有效性。

2.  **关键点2：如何构造满足条件的独立集（求q）**
    * **分析**：直接求最大独立集是NP难的，但题目只要求满足⌊n/(p+1)⌋ ≤ q。贪心选度数最小的点加入独立集，每次删除该点及其邻接点，这样每步最多删除p+1个点（因p是当前最小度数），因此q ≥ n/(p+1)，满足条件。
    * 💡 **学习笔记**：贪心构造的q虽非最大，但能保证满足题目要求，是本题的关键技巧。

3.  **关键点3：输入输出优化**
    * **分析**：题目数据量大（n到1e4，m到1e5），普通的`cin/cout`会超时。需用快速IO（如`getchar`读入、`fwrite`输出）。
    * 💡 **学习笔记**：竞赛中处理大数据时，输入输出优化是必备技能。

### ✨ 解题技巧总结
- **动态维护最小值**：优先队列（堆）是处理动态最小值问题的利器，注意处理堆中的无效记录。
- **贪心构造独立集**：选度数最小的点加入独立集，确保每步删除最少邻接点，保证q足够大。
- **输入输出优化**：使用`getchar`/`putchar`或自定义快速IO函数加速。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了贪心构造p和q的关键步骤。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了liuzhangfeiabc和StudyingFather的题解思路，使用优先队列维护度数，高效构造p和q的集合。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 10010;
    vector<int> G[MAXN];
    int deg[MAXN], nwd[MAXN];
    bool del[MAXN], in_independent[MAXN];

    int main() {
        int T;
        scanf("%d", &T);
        while (T--) {
            int n, m;
            scanf("%d%d", &n, &m);
            for (int i = 1; i <= n; ++i) {
                G[i].clear();
                deg[i] = 0;
                del[i] = false;
                in_independent[i] = false;
            }
            for (int i = 0; i < m; ++i) {
                int u, v;
                scanf("%d%d", &u, &v);
                G[u].push_back(v);
                G[v].push_back(u);
                deg[u]++;
                deg[v]++;
            }

            // 构造热闹聚会的p集合
            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
            memcpy(nwd, deg, sizeof(nwd));
            for (int i = 1; i <= n; ++i) pq.push({nwd[i], i});
            int max_p = 0, pos = 0, cnt_del = 0;
            vector<int> del_order;

            while (!pq.empty()) {
                auto [d, u] = pq.top();
                pq.pop();
                if (del[u]) continue;
                if (d != nwd[u]) continue; // 跳过过时的度数记录
                if (d > max_p) {
                    max_p = d;
                    pos = cnt_del; // 记录当前删除位置
                }
                del[u] = true;
                del_order.push_back(u);
                cnt_del++;
                for (int v : G[u]) {
                    if (!del[v]) {
                        nwd[v]--;
                        pq.push({nwd[v], v});
                    }
                }
            }

            // 输出热闹聚会的集合（未被删除的点）
            vector<int> p_set;
            for (int i = 1; i <= n; ++i) {
                if (!del[i] || del_order[i-1] >= pos) { // 注意del_order的顺序
                    p_set.push_back(i);
                }
            }
            printf("%d ", (int)p_set.size());
            for (int x : p_set) printf("%d ", x);
            printf("\n");

            // 构造尴尬聚会的独立集q
            memset(del, 0, sizeof(del));
            pq = priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>>();
            memcpy(nwd, deg, sizeof(nwd));
            for (int i = 1; i <= n; ++i) pq.push({nwd[i], i});

            vector<int> q_set;
            while (!pq.empty()) {
                auto [d, u] = pq.top();
                pq.pop();
                if (del[u]) continue;
                q_set.push_back(u);
                del[u] = true;
                for (int v : G[u]) del[v] = true; // 删除邻接点
            }

            // 输出尴尬聚会的集合
            printf("%d ", (int)q_set.size());
            for (int x : q_set) printf("%d ", x);
            printf("\n");
        }
        return 0;
    }
    ```
* **代码解读概要**：代码分为两部分：构造p的集合时，用优先队列动态删除最小度数点，记录过程中最大的最小度数；构造q的集合时，同样用优先队列选度数最小的点加入独立集，并删除其邻接点。通过`del`数组标记已处理点，避免重复操作。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：liuzhangfeiabc（部分核心片段）**
* **亮点**：使用堆维护度数，输入输出优化（`gc`和`pc`宏）。
* **核心代码片段**：
    ```cpp
    priority_queue<pii > q; // 大根堆，存(-度数, 节点)
    for(i = 1;i <= n;++i) nwd[i] = ds[i],q.push(mp(-nwd[i],i));
    while(!q.empty()){
        pii p = q.top();q.pop();
        if(-p.fi != nwd[p.se]) continue; // 跳过过时记录
        if(-p.fi >= p1){
            p1 = -p.fi;
            wz = ft;
        }
        shan[++ft] = p.se;d1[p.se] = 1;
        for(i = fir[p.se];i;i = e[i].nxt) if(!d1[e[i].to]){
            --nwd[e[i].to];
            q.push(mp(-nwd[e[i].to],e[i].to));
        }
    }
    ```
* **代码解读**：堆中存储的是负度数（模拟最小堆），每次取出当前度数最小的点。若该点的度数已更新（过时记录），则跳过。否则，更新最大p值，并删除该点，更新其邻接点的度数。
* 💡 **学习笔记**：用负度数实现最小堆是常见技巧，避免手写小根堆。

**题解二：StudyingFather（部分核心片段）**
* **亮点**：代码结构工整，变量命名清晰。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++) q.push({i,t[i]});
    ansp=q.top().y;
    while(!q.empty()){
        int u=q.top().x;
        q.pop();
        if(vis[u])continue;
        ord[++cnt]=u,vis[u]=1;
        int rp=q.top().y;
        if(rp>ansp) ansp=rp,pos=cnt;
        for(auto v:e[u]){
            t1[v]--;
            q.push({v,t1[v]});
        }
    }
    ```
* **代码解读**：优先队列直接存储（节点，度数），每次取出度数最小的点，记录删除顺序。通过`ord`数组保存删除顺序，`pos`记录最大p对应的删除位置。
* 💡 **学习笔记**：用`ord`数组保存删除顺序，方便后续构造p的集合。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解贪心构造p和q的过程，我们设计一个8位像素风格的动画，模拟“删点”和“选独立集”的过程。
</visualization_intro>

  * **动画演示主题**：`像素图探险——构造热闹与尴尬聚会`

  * **核心演示内容**：展示贪心删除最小度数点（构造p）和贪心选独立集（构造q）的每一步操作，包括度数变化、点的删除/选中状态。

  * **设计思路简述**：采用8位像素风格（类似红白机游戏），用不同颜色标记点的状态（如绿色未处理、红色已删除、蓝色独立集点）。关键操作（如选点、删点）伴随“叮”“嗒”音效，增强记忆。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 屏幕中间是一个像素网格，每个格子代表一个节点，初始颜色为绿色（未处理）。
        - 右侧显示优先队列（用堆叠的像素方块表示，方块上标有度数）。
        - 控制面板有“单步”“自动播放”按钮和速度滑块。

    2.  **构造p的集合（删点过程）**：
        - 每一步，队列顶部的方块（最小度数点）弹出，对应节点变为红色（已删除），播放“嗒”音效。
        - 该节点的邻接点度数减1，队列中对应方块更新度数（颜色闪烁提示变化）。
        - 记录最大p值时，屏幕顶部显示“当前最大p：X”，并播放“叮”音效。

    3.  **构造q的集合（选独立集）**：
        - 每一步，队列顶部的方块弹出，对应节点变为蓝色（加入独立集），播放“叮”音效。
        - 该节点的邻接点变为红色（已删除），播放“嗒”音效。
        - 独立集大小实时显示在屏幕右侧。

    4.  **结束状态**：
        - 构造完成后，p集合和q集合分别用绿色和蓝色高亮，播放胜利音效（如“啦~”）。

  * **旁白提示**：
    - “当前删除的是度数最小的点，它无法满足更高的p要求。”
    - “选中这个点加入独立集，它的邻接点都会被删除，确保独立集内的点互不相连。”

<visualization_conclusion>
通过这样的动画，我们可以直观看到贪心策略如何一步步构造出满足条件的p和q，加深对算法逻辑的理解。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
贪心算法在图论中应用广泛，以下是相关拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 贪心选最小/最大元素：适用于需要动态维护极值的场景（如Huffman编码、任务调度）。
    - 独立集构造：贪心策略可推广到其他图论问题（如二分图最大独立集）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5787 [SDOI2012] 消防局的设立**  
        🗣️ **推荐理由**：需贪心选择覆盖范围最大的点，与本题贪心选最小度数点的思想类似。
    2.  **洛谷 P1330 封锁阳光大学**  
        🗣️ **推荐理由**：求二分图的最大独立集，可巩固独立集相关知识。
    3.  **洛谷 P4053 [JSOI2007] 建筑抢修**  
        🗣️ **推荐理由**：贪心策略在时间管理问题中的应用，锻炼动态维护极值的能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到的问题，例如输入输出超时、堆中出现过时记录等，这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自 liuzhangfeiabc)**：“在处理大数据时，普通的`cin/cout`会超时，必须用快速IO。另外，堆中可能存在过时的度数记录（即点的度数已更新但堆中仍存旧值），需要通过标记跳过这些无效记录。”

> **点评**：输入输出优化和堆的有效性维护是竞赛中的常见问题。快速IO（如`getchar`/`putchar`）能显著提升效率；堆中过时记录的处理（通过比较当前度数和堆中存储值）是保证算法正确的关键。

---

<conclusion>
通过分析本题的贪心策略和核心代码，我们掌握了构造p和q的关键技巧。贪心算法在图论问题中应用广泛，希望大家通过练习巩固，下次挑战更难的题目！💪
</conclusion>

---

---
处理用时：130.44秒
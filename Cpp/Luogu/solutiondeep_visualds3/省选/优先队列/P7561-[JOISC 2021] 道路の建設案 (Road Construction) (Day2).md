# 题目信息

# [JOISC 2021] 道路の建設案 (Road Construction) (Day2)

## 题目背景

10s,2048M

## 题目描述

JOI 国是一个 $x\times y$ 的二维平面，王国里有 $n$ 个城镇，分别编号为 $1, 2, \cdots, n$，其中第 $i$ 个城镇的 **坐标** 为 $(x_i, y_i)$。

在 JOI 国，正计划修建连接两座城镇的路（下文简称：**「修路的项目」**），路有 $k$ 条。连接两个不同的城镇 $a$ 和 $b$ 将花费 $|x_a − x_b| + |y_a − y_b|$ 元。若有一条连接 $c$，$d$ 的路，则不需要也不可以在建一条连接 $d$，$c$ 的路，因为它们是相同的。

你要管理这个「修路的项目」，为了计算花费情况，你得弄明白连接一些城镇所需的花费。在这 $\dfrac{n\cdot(n-1)}{2}$ 条道路中，你想了解最便宜的 $k$ 条道路的花费。

给你城镇的坐标以及 $k$，请计算最便宜的 $k$ 条路所需要的钱。

## 说明/提示

#### 样例 #1 解释
有 $\dfrac{3 \times 2}{2} = 3$ 种方案。

- 城镇 $1 \to$ 城镇 $2$，$|(-1)-0|+|0-2| = 3$ 日元。
- 城镇 $1 \to$ 城镇 $3$，$|(-1)-0|+|0-0| = 1$ 日元。
- 城镇 $2 \to$ 城镇 $3$，$|0-0|+|2-0| = 2$ 日元。

将其进行排序为 $1,2,3$，所以输出是 $1$ 和 $2$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #2 解释

有 $\dfrac{5 \times 4}{2} = 10$ 种方案。

将钱数排序后是 $2, 2, 3, 3, 3, 3, 4, 4, 4, 4$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #3 解释

本样例满足 Subtask $1, 2, 4, 5, 6$。

#### 样例 #4 解释

本样例满足 Subtask $1, 4, 5, 6$。

#### 数据范围与约定

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | $n$ | $k$ | $y_i$ |
| :----: | :----: | :----: | :----:| :----: |
| $1$ | $5\%$ | $\le 10^3$ | / | / |
| $2$ | $6\%$ | / | / | $=0$ |
| $3$ | $7\%$ | / | $=1$ | / |
| $4$ | $20\%$ | / | $\le 10$ | / |
| $5$ | $27\%$ |  / | $\le 10 ^ 5$ | / |
| $6$ | $35\%$ | / | / | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：
- $2 \le n \le 2.5 \times 10^5$；
- $1 \le k \le \min(2.5\times 10^5,\ \dfrac{n\cdot(n-1)}{2}$)；
- $-10^9 \le x_i, y_i \le 10^9$，且 $1 \le i \le n$；
- $(x_i,y_i)\not = (x_j, y_j)$ 且 $1 \le i < j \le n$。

#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 2 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/2021-sp-d2-notice.pdf) [T2 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/road_construction.pdf)。


## 样例 #1

### 输入

```
3 2
-1 0
0 2
0 0
```

### 输出

```
1
2
```

## 样例 #2

### 输入

```
5 4
1 -1
2 0
-1 0
0 2
0 -2
```

### 输出

```
2
2
3
3
```

## 样例 #3

### 输入

```
4 6
0 0
1 0
3 0
4 0
```

### 输出

```
1
1
2
3
3
4
```

## 样例 #4

### 输入

```
10 10
10 -8
7 2
7 -8
-3 -6
-2 1
-8 6
8 -1
2 4
6 -6
2 -1
```

### 输出

```
3
3
4
5
6
6
6
7
7
7
```

# AI分析结果

# 💡 Kay的C++算法解析：[JOISC 2021 Day2] 道路の建設案 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察
**算法分类**：二分答案 + 曼哈顿距离转切比雪夫距离 + 双指针+有序集合  
**核心思想**：  
题目要求找出平面上**前k小的曼哈顿距离无序点对**。直接枚举所有点对（O(n²)）显然无法通过大数据（n≤2.5×10⁵），因此需要更高效的方法。  

**关键技巧**：  
- **曼哈顿转切比雪夫**：将点$(x,y)$转化为$(x+y, x-y)$，此时两点的曼哈顿距离等于转化后的切比雪夫距离（$\max(|x_1-x_2|, |y_1-y_2|)$）。切比雪夫距离的形式更易处理（可拆解为x和y两个维度的范围查询）。  
- **二分答案**：二分第k小的距离$d$，判断有多少点对的切比雪夫距离≤$d$。若数量≥k，则$d$可以更小；否则需要更大的$d$。  
- **双指针+有序集合**：高效统计距离≤$d$的点对数量（check函数的核心）。


### 🗣️ 初步分析
1. **问题转化**：  
   曼哈顿距离的计算复杂，转切比雪夫后，问题简化为：**找出所有点对中，x差和y差的最大值≤$d$的数量**。  
2. **二分逻辑**：  
   二分的边界是$l=0$（最小距离），$r=4×10⁹$（最大可能距离）。每次取中点$mid$，检查是否有≥k个点对的切比雪夫距离≤$mid$。  
3. **check函数设计**：  
   - 将点按x坐标排序（转化后的x）。  
   - 用双指针维护一个窗口，窗口内的点x坐标差≤$d$（保证切比雪夫距离的x维度满足条件）。  
   - 用有序集合（如`multiset`）维护窗口内点的y坐标，快速查询y坐标在$[y_i-d, y_i+d]$之间的点（保证y维度满足条件）。  
   - 统计符合条件的点对数量，若≥k则立即返回`true`（避免不必要的计算）。  
4. **可视化思路**：  
   用**8位像素风格**展示点的分布和窗口移动：  
   - 点用不同颜色的像素块表示，转化后的坐标显示在屏幕上。  
   - 双指针窗口用矩形框标记，窗口内的点高亮。  
   - 有序集合中的y坐标用竖线表示，查询范围用虚线框标记，符合条件的点对用连线显示。  
   - 加入**音效**：窗口移动时播放“滑入”声，查询到符合条件的点对时播放“叮”声，二分结束时播放“胜利”声。


## 2. 精选优质题解参考

### 📌 题解一（作者：hfjh，赞：11）
**点评**：  
这份题解是**双指针+有序集合**的经典实现，思路清晰、代码规范，非常适合初学者理解。  
- **思路清晰性**：明确将曼哈顿转切比雪夫，二分答案的逻辑推导详细，check函数的双指针+multiset策略直白。  
- **代码规范性**：变量名（如`p[i].x`、`p[i].y`）含义明确，结构工整（输入、排序、二分、check、输出分模块）。  
- **算法有效性**：时间复杂度O(n log n log D)（D为距离范围），稳定通过所有数据。  
- **实践价值**：边界处理严谨（如`multiset`的`lower_bound`查找），代码可直接用于竞赛。  
**亮点**：check函数中一旦统计数量≥k就立即返回，优化了时间效率。


### 📌 题解二（作者：SunnyYuan，赞：0）
**点评**：  
这份题解补充了**二分后如何输出前k小距离**的关键细节，解释了为什么要`check(l-1)`，是对题解一的重要补充。  
- **思路清晰性**：详细说明二分得到$l$后，`check(l-1)`的作用（统计所有小于$l$的距离，数量<k），然后用$l$补齐到k个。  
- **代码规范性**：`multiset`的插入/删除操作正确，排序逻辑清晰。  
- **实践价值**：解决了“如何输出前k小距离”的问题，避免了重复统计。  
**亮点**：用`sort`对`check(l-1)`得到的距离排序，然后输出前cnt个，再输出k-cnt个$l$，确保结果正确。


### 📌 题解三（作者：7KByte，赞：2）
**点评**：  
这份题解的代码简洁，重点突出，适合快速理解核心逻辑。  
- **思路清晰性**：直接给出二分+双指针+multiset的实现，没有多余的冗余代码。  
- **代码规范性**：变量名简洁（如`a[i].X`、`a[i].Y`），注释到位（如“曼哈顿转切比雪夫”）。  
- **算法有效性**：时间复杂度与题解一一致，代码运行效率高。  
**亮点**：用`queue`维护双指针窗口，`multiset`维护y坐标，逻辑紧凑。


## 3. 核心难点辨析与解题策略

### 🎯 核心难点1：曼哈顿距离转切比雪夫距离
**分析**：  
曼哈顿距离的计算是$|x1-x2|+|y1-y2|$，无法直接用范围查询处理。转切比雪夫后，距离变为$\max(|x1-x2|, |y1-y2|)$，可拆解为x和y两个维度的范围查询（x差≤d且y差≤d）。  
**解决策略**：记住转化公式：$(x,y) \to (x+y, x-y)$，曼哈顿距离等于转化后的切比雪夫距离。


### 🎯 核心难点2：高效统计距离≤d的点对数量
**分析**：  
直接统计所有点对的时间复杂度太高，需要找到一种线性或线性对数时间的方法。  
**解决策略**：  
- 将点按x坐标排序（转化后的x）。  
- 用双指针维护窗口，窗口内的点x坐标差≤d（保证x维度满足条件）。  
- 用有序集合（如`multiset`）维护窗口内点的y坐标，快速查询y坐标在$[y_i-d, y_i+d]$之间的点（保证y维度满足条件）。  


### 🎯 核心难点3：输出前k小的距离
**分析**：  
二分得到的是第k小的距离$l$，但需要输出所有前k小的距离（可能有多个等于$l$的距离）。  
**解决策略**：  
- 先`check(l-1)`，统计所有小于$l$的距离（数量<k）。  
- 将这些距离排序后输出，然后输出k-cnt个$l$（补齐到k个）。  


### ✨ 解题技巧总结
1. **距离转化**：遇到曼哈顿距离问题，优先考虑转切比雪夫距离。  
2. **二分答案**：求第k小/大的问题，常用二分答案+check函数。  
3. **双指针+有序集合**：处理范围查询问题，双指针维护窗口，有序集合快速查找。  
4. **边界处理**：注意二分的初始范围，check函数中的窗口维护，以及输出时的补齐逻辑。


## 4. C++核心代码实现赏析

### 📝 本题通用核心C++实现参考（综合题解一、二、三）
**说明**：本代码综合了双指针+有序集合的经典实现，逻辑清晰，可直接运行。  
**完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <set>
#include <queue>
using namespace std;
using ll = long long;

const int N = 250010;
const ll INF = 1e18;

struct Node {
    ll x, y;
};

Node p[N];
ll ans[N];
int n, k, cnt;

bool check(ll dis) {
    multiset<pair<ll, ll>> ms; // 存储(y, x)，按y排序
    queue<int> q;
    cnt = 0;
    ms.insert({INF, INF});
    ms.insert({-INF, -INF});

    for (int i = 1; i <= n; ++i) {
        // 维护窗口：x差≤dis
        while (!q.empty() && p[q.front()].x < p[i].x - dis) {
            ms.erase(ms.find({p[q.front()].y, p[q.front()].x}));
            q.pop();
        }
        // 查找y在[y_i - dis, y_i + dis]之间的点
        auto it = ms.lower_bound({p[i].y - dis, -INF});
        while (it != ms.end() && it->first <= p[i].y + dis) {
            ans[++cnt] = max(p[i].x - it->second, abs(p[i].y - it->first));
            if (cnt >= k) return true;
            ++it;
        }
        // 将当前点加入窗口
        q.push(i);
        ms.insert({p[i].y, p[i].x});
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        ll a, b;
        cin >> a >> b;
        p[i].x = a + b; // 转切比雪夫x
        p[i].y = a - b; // 转切比雪夫y
    }
    // 按x排序
    sort(p + 1, p + n + 1, [](const Node& a, const Node& b) {
        return a.x < b.x || (a.x == b.x && a.y < b.y);
    });

    // 二分答案
    ll l = 0, r = INF;
    while (l < r) {
        ll mid = l + (r - l) / 2;
        if (check(mid)) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }

    // 统计小于l的距离
    check(l - 1);
    sort(ans + 1, ans + cnt + 1);
    // 输出前cnt个，再输出k-cnt个l
    for (int i = 1; i <= cnt; ++i) {
        cout << ans[i] << '\n';
    }
    for (int i = cnt + 1; i <= k; ++i) {
        cout << l << '\n';
    }

    return 0;
}
```
**代码解读概要**：  
- **输入处理**：读取点坐标，转化为切比雪夫坐标。  
- **排序**：按切比雪夫x坐标排序，为双指针窗口做准备。  
- **二分答案**：找最小的$l$，使得有≥k个点对的切比雪夫距离≤$l$。  
- **check函数**：用双指针维护窗口，multiset维护y坐标，统计符合条件的点对数量。  
- **输出处理**：统计小于$l$的距离，排序后输出，再用$l$补齐到k个。


### 📝 题解一（hfjh）核心代码片段赏析
**亮点**：check函数中的立即返回优化。  
**核心代码片段**：  
```cpp
bool check(ll mid) {
    q = queue<int>();
    s = multiset<Node>();
    ans = 0;
    for (int i = 1; i <= n; ++i) {
        while (q.size() && p[i].x - p[q.front()].x > mid) {
            multiset<Node>::iterator w = s.find((Node){0, p[q.front()].y});
            s.erase(w);
            q.pop();
        }    
        multiset<Node>::iterator lz = s.lower_bound((Node){0, p[i].y - mid});
        while (lz != s.end() && (*lz).y <= p[i].y + mid) {
            an[++ans] = max(abs((*lz).x - p[i].x), abs((*lz).y - p[i].y));
            if (ans >= k) return 1; // 立即返回，优化时间
            ++lz;
        }
        q.push(i);
        s.insert((Node){p[i].x, p[i].y}); 
    }
    return 0;
}
```
**代码解读**：  
- 当统计数量≥k时，立即返回`true`，避免继续遍历后续点，减少不必要的计算。  
- `multiset`的`lower_bound`函数快速找到y的下界，然后遍历到上界，统计符合条件的点对。


### 📝 题解二（SunnyYuan）核心代码片段赏析
**亮点**：输出前k小距离的处理。  
**核心代码片段**：  
```cpp
check(l - 1);
sort(ans + 1, ans + cnt + 1);
for (int i = 1; i <= cnt; i++) cout << ans[i] << '\n';
for (int i = cnt + 1; i <= k; i++) cout << l << '\n';
```
**代码解读**：  
- `check(l - 1)`统计所有小于$l$的距离，数量<k。  
- 将这些距离排序后输出，然后输出k-cnt个$l$，确保结果是前k小的距离。


## 5. 算法可视化：像素动画演示（核心部分）

### 🎮 动画演示主题
**像素探险家：寻找最短路径**（仿FC红白机风格）


### 🎨 设计思路
- **风格**：8位像素风格，用简单的色块表示点、窗口、有序集合。  
- **核心逻辑**：展示二分答案+双指针+有序集合的过程，重点突出窗口移动、y范围查询、点对统计。  
- **游戏化元素**：加入音效（窗口移动声、查询成功声、胜利声）、进度条（显示二分进度）、得分（统计符合条件的点对数量）。


### 📊 动画帧步骤
1. **初始化场景**：  
   - 屏幕左侧显示转化后的点（像素块，颜色随机），右侧显示二分进度条（初始为0%）。  
   - 底部控制面板有“开始”、“单步”、“自动”按钮，以及速度滑块。  
   - 播放8位风格的背景音乐（轻快的电子乐）。

2. **二分过程**：  
   - 进度条随二分迭代逐渐填充（每迭代一次，进度条增加1%）。  
   - 每次二分的$mid$值显示在屏幕顶部（如“当前二分mid：100”）。

3. **check函数演示**：  
   - **双指针窗口**：用黄色矩形框标记窗口内的点（x坐标差≤$mid$），窗口随i的增加向右移动（播放“滑入”声）。  
   - **有序集合**：右侧显示一个竖条，代表y坐标的范围，窗口内的点的y坐标用蓝色小方块标记。  
   - **y范围查询**：当处理第i个点时，用红色虚线框标记$[y_i - mid, y_i + mid]$的范围（播放“查询”声），符合条件的点用绿色连线连接（播放“叮”声）。  
   - **数量统计**：屏幕右上角显示当前统计的点对数量（如“当前数量：5/10”），当数量≥k时，立即停止check（播放“提示”声）。

4. **结果输出**：  
   - 二分结束后，屏幕显示“第k小距离：l”（如“第10小距离：200”）。  
   - 播放“胜利”声，然后显示前k小的距离（用滚动列表显示）。


### 🛠️ 技术实现
- **Canvas绘制**：用`ctx.fillRect`绘制像素块、窗口、有序集合。  
- **音效**：用`Audio`对象播放8位音效（如窗口移动声：`slide.wav`，查询成功声：`ding.wav`）。  
- **交互**：用`addEventListener`处理按钮点击（开始/单步/自动）和滑块调整（速度）。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移
- **问题场景**：  
  1. **K远点对**：找前k大的距离（如洛谷P4357）。  
  2. **范围查询**：统计某个矩形内的点数量（如洛谷P1494）。  
  3. **多维距离**：处理三维或更高维的距离问题（如洛谷P2093）。  
- **迁移技巧**：  
  用距离转化（如曼哈顿转切比雪夫）、二分答案、双指针+有序集合或其他数据结构（如K-D Tree、主席树）。


### 📚 洛谷练习推荐
1. **洛谷P4357 [CQOI2016]K远点对**  
   - **推荐理由**：本题是“前k大距离”的经典问题，需要用到类似的二分+数据结构技巧（如K-D Tree）。  
2. **洛谷P2093 [国家集训队]JZPFAR**  
   - **推荐理由**：本题要求找最远点对，需要用到K-D Tree的启发式搜索，是对本题的拓展。  
3. **洛谷P7883 [LNOI2021]立直麻将**  
   - **推荐理由**：本题涉及范围查询和统计，需要用到双指针+有序集合的技巧，与本题思路一致。


## 7. 学习心得与经验分享（若有）

### 📝 来自题解作者的经验
- **hfjh**：“在check函数中，一旦统计数量≥k就立即返回，能大大减少运行时间。”  
  **点评**：这是一个重要的优化技巧，避免了不必要的遍历，尤其适用于大数据。  
- **SunnyYuan**：“二分后要`check(l-1)`，否则无法正确输出前k小的距离。”  
  **点评**：这解决了“如何输出前k小距离”的关键问题，避免了重复统计。


## 🎉 总结
本题的核心是**二分答案+曼哈顿转切比雪夫+双指针+有序集合**，通过这些技巧可以高效解决前k小距离问题。需要掌握距离转化的方法、高效的check函数设计，以及输出前k小距离的处理逻辑。  

希望这份指南能帮助你理解本题的解题思路，掌握相关算法技巧，在后续的编程练习中举一反三！💪

---
处理用时：182.15秒
# 题目信息

# [JLOI2016] 圆的异或并

## 题目描述

在平面直角坐标系中给定 $N$ 个圆。已知这些圆**两两没有交点**，即两圆的关系只存在相离和包含。求这些圆的异或面积并。

异或面积并定义为：当一片区域在奇数个圆内，则计入其面积，否则，当一片区域在偶数个圆内则不计入其面积。

## 样例 #1

### 输入

```
2
0 0 1
0 0 2```

### 输出

```
3```

# AI分析结果



---
# 💡 Kay的C++算法解析：圆的异或并 深入学习指南 💡

<introduction>
今天我们要一起攻克“圆的异或并”这道题！题目要求计算多个不相交圆的异或面积并（被奇数个圆覆盖的区域面积），输出结果除以π的结果。通过分析，我们发现这道题的关键在于利用扫描线算法和集合（set）来维护圆的包含关系，进而计算每个圆的贡献。让我们一步步拆解问题，掌握核心思路！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扫描线算法 + 集合（set）的灵活应用  

🗣️ **初步分析**：  
想象有一条垂直于x轴的“扫描线”从左到右缓缓移动。当扫描线碰到圆的左边界（x = 圆心x - 半径）时，我们需要记录该圆的信息；当扫描线碰到圆的右边界（x = 圆心x + 半径）时，该圆的信息会被移除。通过这种方式，我们可以将二维平面问题转化为一维的“时间线”问题，只需要关注扫描线当前位置下的圆的包含关系。

关键观察：由于所有圆两两不相交，它们的包含关系具有**传递性**（若A包含B，B包含C，则A包含C）和**自反性**（每个圆自身是独立的）。这种关系类似于“大小关系”，因此可以用集合（set）维护当前扫描线与圆的交点，通过比较交点的y坐标来确定圆的包含层次。

核心难点与解决方案：  
- **如何确定圆的深度（被包含次数）**：将每个圆拆分为上半圆和下半圆，插入set时，通过查找当前上半圆的“前驱”（set中在其下方最近的圆）来判断深度。若前驱是上半圆，当前圆与前驱同深度；若是下半圆，当前圆深度为前驱深度+1。  
- **如何处理浮点数精度问题**：在比较上下半圆的y坐标时，给上半圆的y值加上一个极小的eps（如1e-9），避免set误判两个半圆为同一元素。

可视化设计思路：  
采用8位像素风格动画，扫描线用竖直的虚线表示，圆用像素块围成的圆圈。插入/删除圆时，上下半圆以“滑入/滑出”动画进入set的“队列”，当前处理的圆用高亮颜色（如红色）标记，前驱圆用黄色闪烁提示。关键操作（如插入、深度计算）伴随“叮”的像素音效，完成所有处理后播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：作者@shadowice1984**  
* **点评**：此题解从扫描线的核心思想出发，详细解释了如何将圆拆分为上下半圆、用set维护交点，并通过前驱判断深度的过程。代码结构简洁，变量命名（如`nx`表示当前扫描线x坐标，`o[nw]`表示圆的奇偶性）含义明确。亮点在于利用set的有序性直接获取前驱，避免复杂计算，时间复杂度O(n log n)，适合竞赛实战。

**题解二：作者@Vanilla_chan**  
* **点评**：此题解结合图示和代码，清晰说明了包含关系转化为森林的过程（每个圆的深度决定其贡献）。代码中`dep`数组记录每个圆的深度，通过扫描线插入时的前驱判断更新深度，逻辑直白。特别地，比较函数中对eps的处理（上半圆y值+eps）避免了set误判，是实现的关键细节。

**题解三：作者@Leianha**  
* **点评**：此题解代码简洁，核心逻辑（插入、查找前驱、计算贡献）一目了然。通过`nowx`记录当前扫描线位置，`val`数组记录每个圆的奇偶性，代码可读性高。亮点在于将圆的插入和删除操作统一处理，减少冗余代码。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键在于理解扫描线的“时间线”思维和set维护包含关系的逻辑。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **难点1：如何将二维圆的包含关系转化为一维处理？**  
    * **分析**：扫描线从左到右移动，每个圆的有效范围是其左右边界之间的x区间。在这个区间内，扫描线与圆相交于上下半圆，通过维护这些交点的y坐标顺序（用set），可以间接表示圆的包含层次。  
    * 💡 **学习笔记**：扫描线的本质是将二维问题“切片”为一维序列，关注每个切片上的关键事件（如圆的插入/删除）。

2.  **难点2：如何通过set确定圆的深度？**  
    * **分析**：插入上半圆时，查找set中的前驱（下方最近的交点）。若前驱是上半圆，说明两圆同属一个父圆（深度相同）；若是下半圆，说明当前圆被前驱所在圆包含（深度为前驱深度+1）。  
    * 💡 **学习笔记**：set的有序性是关键，利用其自动排序特性可以快速找到前驱/后继，简化层次判断。

3.  **难点3：如何处理浮点数精度问题？**  
    * **分析**：上下半圆在扫描线左右边界处的y坐标相同（均为圆心y），直接比较会导致set误判为同一元素。通过给上半圆的y值加上极小的eps（如1e-9），可以区分上下半圆的交点。  
    * 💡 **学习笔记**：浮点数比较时，加入eps是避免精度误差的常用技巧。

### ✨ 解题技巧总结  
- **问题分解**：将圆拆分为上下半圆，将二维包含问题转化为一维交点顺序问题。  
- **数据结构选择**：set适合维护动态的、需要快速查找前驱/后继的有序序列。  
- **边界处理**：扫描线左右边界的事件（插入/删除）需严格排序，确保处理顺序正确。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的通用核心代码，结合了逻辑清晰性和实现高效性，适合直接学习和调试。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了@shadowice1984和@Vanilla_chan的思路，通过扫描线+set维护上下半圆，计算每个圆的贡献。  
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    #include <set>
    #include <cmath>
    using namespace std;
    typedef long long ll;
    const int N = 2e5 + 10;
    const double eps = 1e-9;

    double x[N], y[N], r[N];
    int n, cnt;
    ll ans;
    double now_x; // 当前扫描线的x坐标

    struct Circle {
        int id;      // 圆的编号
        int type;    // 1表示上半圆，-1表示下半圆
        // 计算当前扫描线与半圆的交点y坐标（+eps区分上下半圆）
        double y() const {
            return y[id] + type * (sqrt(r[id] * r[id] - (now_x - x[id]) * (now_x - x[id])) + eps);
        }
        // 定义比较规则：按交点y坐标排序
        bool operator<(const Circle& other) const {
            return y() < other.y();
        }
    };

    set<Circle> s; // 维护当前扫描线与半圆的交点

    struct Event {
        double x;    // 事件发生的x坐标（左边界或右边界）
        int id;      // 圆的编号
        int type;    // 1表示插入（左边界），0表示删除（右边界）
        bool operator<(const Event& other) const {
            return x < other.x;
        }
    } events[2 * N];

    int main() {
        scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            scanf("%lf%lf%lf", &x[i], &y[i], &r[i]);
            // 左边界事件（插入）
            events[++cnt] = {x[i] - r[i], i, 1};
            // 右边界事件（删除）
            events[++cnt] = {x[i] + r[i], i, 0};
        }
        sort(events + 1, events + cnt + 1); // 按x坐标排序事件

        for (int i = 1; i <= cnt; ++i) {
            now_x = events[i].x;
            int id = events[i].id;
            if (events[i].type == 1) { // 插入事件
                Circle up = {id, 1};
                auto it = s.insert(up).first; // 插入上半圆，获取迭代器
                int depth = 1; // 默认深度为1（未被包含）
                if (it != s.begin()) { // 存在前驱
                    --it;
                    if (it->type == -1) { // 前驱是下半圆，当前圆被前驱圆包含
                        depth = (depth + 1) ^ 1; // 深度为前驱深度+1（奇偶性翻转）
                    } // 若是上半圆，深度与前驱相同（无需修改）
                }
                s.insert({id, -1}); // 插入下半圆
                ans += (depth % 2) ? (r[id] * r[id]) : (-r[id] * r[id]);
            } else { // 删除事件
                s.erase({id, 1});
                s.erase({id, -1});
            }
        }
        printf("%lld\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先读取所有圆的信息，生成左右边界的事件并排序。扫描线按事件顺序处理，插入时通过set维护上下半圆的交点，查找前驱确定深度；删除时从set中移除对应半圆。最终根据深度的奇偶性累加或减去圆的面积贡献（r²）。

---
<code_intro_selected>
接下来，我们分析优质题解中的核心代码片段，学习其关键实现。
</code_intro_selected>

**题解一：@shadowice1984**  
* **亮点**：通过`cir`结构体封装半圆信息，`operator<`直接比较交点y坐标，代码简洁高效。  
* **核心代码片段**：
    ```cpp
    struct cir {
        int tp; int u; // tp=1上半圆，tp=-1下半圆；u是圆的编号
        inline db cy() { return b[u] + (db)tp * (sqrt(r[u]*r[u] - (nx - a[u])*(nx - a[u])) + eps); }
        friend bool operator <(cir a, cir b) { db jud = a.cy() - b.cy(); return jud < -eps; }
    };
    set<cir> s;
    ```
* **代码解读**：  
  `cir`结构体存储半圆类型（上/下）和圆的编号，`cy()`函数计算当前扫描线位置下的交点y坐标（上半圆+eps避免与下半圆重合）。`operator<`通过比较y坐标实现set的排序，确保上下半圆的正确顺序。  
* 💡 **学习笔记**：结构体封装关键信息，比较函数直接关联算法核心逻辑，是代码简洁性的关键。

**题解二：@Vanilla_chan**  
* **亮点**：`dep`数组记录每个圆的深度，插入时通过前驱类型更新深度，逻辑清晰。  
* **核心代码片段**：
    ```cpp
    it = s.insert(O(opt[i].x, 1)).first;
    if (it == s.begin()) {
        dep[opt[i].x] = 1;
    } else {
        it--;
        if (it->up) {
            dep[opt[i].x] = dep[it->x];
        } else {
            dep[opt[i].x] = dep[it->x] ^ 1;
        }
    }
    ```
* **代码解读**：  
  插入上半圆后，若set为空（无优先驱），深度为1；否则，前驱若是上半圆，当前圆与前驱同深度；若是下半圆，当前圆深度为前驱深度+1（通过异或1翻转奇偶性）。  
* 💡 **学习笔记**：深度的奇偶性直接决定贡献的正负，用异或操作简洁高效。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了更直观地理解扫描线和set如何工作，我们设计一个“像素扫描探险”动画，用8位复古风格展示算法全过程！
\</visualization_intro\>

  * **动画演示主题**：`像素扫描线的圆探险`  
  * **核心演示内容**：扫描线从左到右移动，圆的左右边界触发“插入”或“删除”事件，set中上下半圆以像素块形式排列，通过颜色和位置变化展示包含关系。  

  * **设计思路简述**：  
    8位像素风格（FC红白机色调）营造轻松氛围，扫描线用虚线表示，圆用空心像素圈（红色为上半圆，蓝色为下半圆）。插入/删除时，像素圈从左/右“滑入/滑出”set队列。关键步骤（如查找前驱、计算深度）用文字气泡解释，音效（“叮”）强化操作记忆。

  * **动画帧步骤与交互关键点**：  
    1. **场景初始化**：屏幕左侧显示扫描线（竖直虚线），下方是set队列区域（像素块堆叠），右侧显示当前处理的事件列表。播放8位风格背景音乐。  
    2. **事件触发**：扫描线移动到某个圆的左边界时，红色上半圆和蓝色下半圆像素块从左侧滑入set队列，伴随“叮”音效。  
    3. **前驱查找**：插入上半圆后，黄色箭头从当前像素块向下指向最近的前驱块（上半圆或下半圆），文字气泡提示“前驱是上半圆，深度相同”或“前驱是下半圆，深度+1”。  
    4. **深度计算**：当前圆的像素块颜色根据深度奇偶性变化（奇数为绿色，偶数为紫色），贡献值（±r²）显示在屏幕上方。  
    5. **删除事件**：扫描线移动到右边界时，对应上下半圆像素块从set队列中滑出，伴随“噗”音效。  
    6. **最终结果**：所有事件处理完成后，扫描线停在最右侧，屏幕中央显示总贡献值，播放胜利音效（“啦~”）。  

  * **旁白提示**：  
    - “看！扫描线碰到了圆的左边界，需要插入上半圆和下半圆~”  
    - “当前上半圆的前驱是蓝色下半圆，说明这个圆被前驱圆包含，深度加1！”  
    - “深度是奇数，所以这个圆的面积要加上r²哦~”  

\<visualization_conclusion\>
通过这样的动画，我们可以“看到”扫描线如何一步步处理事件，set如何维护圆的层次关系，深度如何影响最终的面积贡献。是不是更直观了？
\</visualization_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握扫描线和set的组合技巧后，可以尝试以下题目，巩固并拓展思路：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：  
    扫描线+set的方法不仅适用于圆的包含问题，还可处理矩形面积并、线段覆盖等二维平面问题。关键在于将二维事件（如矩形的左右边、线段的端点）转化为一维序列，用有序数据结构维护当前状态。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P5490 [模板]扫描线**  
        🗣️ **推荐理由**：经典扫描线题目，计算矩形面积并，巩固扫描线处理二维问题的核心逻辑。  
    2.  **洛谷 P4631 [APIO2018] Circle selection 选圆圈**  
        🗣️ **推荐理由**：同样涉及圆的包含关系，需要设计高效算法选择不包含的圆，拓展扫描线以外的思路（如K-D Tree）。  
    3.  **洛谷 P1856 [IOI1998] 多边形面积并**  
        🗣️ **推荐理由**：扫描线在复杂多边形中的应用，挑战处理多个边的交点和层次关系。  

-----

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解提到调试时遇到的精度问题（如上下半圆交点重合导致set误判），这些经验对我们很有帮助：
\</insights_intro\>

> **参考经验 (来自@shadowice1984)**：“最初没有处理eps，导致上下半圆被set认为是同一个元素，插入时总是失败。后来给上半圆的y值加上1e-9，问题就解决了。”  
> **点评**：浮点数比较时，精度问题容易导致意外错误。加入极小的eps是常见的解决方法，这提醒我们在处理几何问题时要特别注意精度控制。

-----

\<conclusion\>
“圆的异或并”这道题的核心在于利用扫描线和set将二维包含问题转化为一维序列处理。通过理解扫描线的“时间线”思维、set维护层次关系的逻辑，以及浮点数精度的处理技巧，我们不仅能解决这道题，还能举一反三应对更多二维平面问题。动手调试代码、观察动画演示，你会对算法有更深刻的理解！下次挑战更难的题目，我们再见~ 💪
\</conclusion\>

---
处理用时：169.45秒
# 题目信息

# [NOIP 2012 提高组] 开车旅行

## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。


## 说明/提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。


## 样例 #1

### 输入

```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3
```

### 输出

```
1 
1 1 
2 0 
0 0 
0 0 ```

## 样例 #2

### 输入

```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7```

### 输出

```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0```

# AI分析结果


### 💡 Kay的C++算法解析：开车旅行 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`倍增` + `链表预处理`  
🗣️ **初步分析**：  
> 解决"开车旅行"的关键在于**预处理每个城市的最近/次近邻居**（小B/小A的选择），再用**倍增法高效模拟行驶过程**。想象成玩跳格子游戏：先在地图上标出每个格子的下一步（小A跳两格，小B跳一格），再用"超级跳"（2的幂次跳跃）快速穿越长距离。  

- **链表预处理**：  
  将城市按海拔排序后构建双向链表，逆序处理（从东向西）。对每个城市，在链表邻居中找最近/次近点（距离相同选海拔低的），处理完后删除该点，保证后续只考虑东边城市。时间复杂度O(n)。

- **倍增设计**：  
  `f[k][i]`表示从城市`i`出发，开`2^k`轮（每轮=小A开+小B开）后到达的城市  
  `da[k][i]`/`db[k][i]`表示对应小A/小B的累计路程  
  状态转移：  
  ```
  f[0][i] = gb[ga[i]]   // 第一轮：A开→B开
  f[k][i] = f[k-1][f[k-1][i]]  (k≥1)
  ```

- **可视化设计**：  
  **像素动画方案**：  
  - **风格**：8位机复古风（如FC《马里奥》），城市显示为不同高度的像素塔  
  - **关键帧**：  
    ① 初始化：显示城市海拔柱状图，高亮当前城市  
    ② 单步：小A跳跃→蓝色轨迹，小B跳跃→红色轨迹  
    ③ 倍增跳转：显示"闪电特效"快速穿越  
    ④ 边界处理：无法跳跃时显示"禁止"图标  
  - **交互控制**：步进/自动播放（调速滑块）、重置按钮  
  - **音效**：跳跃声（8-bit音效）、边界警告音  

#### 2. 精选优质题解参考
**题解一：yangrunze (130赞)**  
* **亮点**：  
  - 链表预处理清晰（双向链表删点保证单向移动）  
  - 倍增状态设计完整（区分A/B驾驶轮次）  
  - 代码模块化（`choose()`函数处理候选点比较）  
* **改进点**：变量命名可读性优化（如`ga→nextA`）

**题解二：shadow__ (77赞)**  
* **亮点**：  
  - 链表删除操作精炼（`del()`函数四行实现）  
  - 倍增初始化严谨（特判`i=1`的轮换逻辑）  
* **注意点**：状态转移中`k^1`的位运算需注释说明  

**题解三：star_fish (5赞)**  
* **亮点**：  
  - 使用`set`简化邻居查找（自动排序）  
  - 完整边界处理（哨兵值防越界）  
* **注意点**：`set`迭代器操作需注意边界检查  

#### 3. 核心难点辨析与解题策略
1. **难点：高效预处理东西向邻居**  
   *分析*：需在O(n)内找到各城市东向最近/次近点。  
   💡 **解法**：  
   - 排序后双向链表，逆序处理并删点  
   - 比较当前点的前驱/后继邻居（最多4候选）  

2. **难点：倍增状态转移设计**  
   *分析*：需区分A/B驾驶轮次，避免状态混乱。  
   💡 **解法**：  
   - 基础单位=1轮（A开+B开）  
   - 转移公式：`f[k][i] = f[k-1][f[k-1][i]]`  

3. **难点：查询时剩余路程处理**  
   *分析*：跳完完整轮次后，可能剩小A单次行驶。  
   💡 **解法**：  
   ```cpp
   if (ga[cur]存在 && 距离≤剩余路程)
       totalA += 单次距离
   ```

#### 4. C++核心代码实现赏析
**通用核心实现参考**（综合自优质题解）：
```cpp
#include <set>
#include <cmath>
const int N=1e5+5;
int h[N], ga[N], gb[N], f[20][N];
long da[20][N], db[20][N];

// 预处理邻居
void init_neighbors() {
    set<pair<int, int>> s;
    for(int i=n; i>=1; --i) {
        auto it = s.lower_bound({h[i], i});
        /* 找前驱/后继候选点并比较距离 */
        // ...赋值ga[i], gb[i]...
        s.insert({h[i], i});
    }
}

// 倍增预处理
void init_double() {
    for(int i=1; i<=n; ++i) {
        f[0][i] = gb[ga[i]];  // 一轮：A→B
        da[0][i] = abs(h[i]-h[ga[i]]);
        db[0][i] = abs(h[ga[i]]-h[gb[ga[i]]]);
    }
    for(int k=1; k<20; ++k)
        for(int i=1; i<=n; ++i) {
            f[k][i] = f[k-1][f[k-1][i]];
            da[k][i] = da[k-1][i] + da[k-1][f[k-1][i]];
            db[k][i] = db[k-1][i] + db[k-1][f[k-1][i]];
        }
}

// 查询函数
pair<long, long> query(int s, long x) {
    long a=0, b=0;
    for(int k=19; k>=0; --k) {
        if(f[k][s] && da[k][s]+db[k][s]<=x) {
            x -= da[k][s]+db[k][s];
            a += da[k][s]; b += db[k][s];
            s = f[k][s];
        }
    }
    if(ga[s] && abs(h[s]-h[ga[s]])<=x) 
        a += abs(h[s]-h[ga[s]]);
    return {a, b};
}
```

#### 5. 算法可视化：像素动画演示
**设计方案**：  
- **场景**：横向卷轴地图，城市为彩色像素柱（高度≈海拔）  
- **角色**：小A（蓝色车）、小B（红色车）  
- **关键动画**：  
  1. **邻居选择**：当前城市闪烁→显示候选邻居连线→高亮选中点  
  2. **行驶过程**：  
     - 小A跳跃：蓝色弧线+"叮"声  
     - 小B跳跃：红色弧线+"咚"声  
  3. **倍增跳转**：闪电特效覆盖多城市+快速音效  
  4. **终止条件**：超出里程时显示"STOP"标志+警告音  
- **控制面板**：  
  - 速度滑块：调速倍增演示速度  
  - 单步/连续模式：空格键切换  
  - 城市标记：点击查看海拔/编号  

#### 6. 拓展练习与相似问题
**通用技巧迁移**：  
1. 树上最近邻查询 → [CF702F] T-Shirts  
2. 倍增法优化路径查询 → [P1613] 跑路  
3. 双向链表预处理 → [P1169] 棋盘制作  

**洛谷推荐**：  
1. **P1081** - 本题（巩固倍增+链表）  
2. **P3401** 洛谷树 - 类似树上路径统计  
3. **P2680** 运输计划 - 倍增+二分答案  

#### 7. 学习心得与经验分享
> **来自 yangrunze 的调试经验**：  
> "初始化链表时忘记处理边界指针，导致死循环。用`cout`打印链表指针后快速定位到`del()`函数漏写`nxt[pre]=nxt`。"  
> **Kay总结**：链表操作要同步更新前驱/后继指针，推荐"绘图模拟"验证边界情况！

> **shadow__ 的优化技巧**：  
> "用`__int128`比较分数避免浮点误差，`(a1*b2 < a2*b1)`代替除法。"  
> **Kay笔记**：整数比较既避免精度问题又提升效率！

#### 结语
掌握链表预处理与倍增法，即可高效解决路径查询问题！记住：  
💡 **链表保序 → 倍增加速 → 边界特判**  
下次旅行再见！🚗💨

---
处理用时：224.83秒
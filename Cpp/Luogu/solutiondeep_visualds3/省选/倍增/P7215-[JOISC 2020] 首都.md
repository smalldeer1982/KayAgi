# 题目信息

# [JOISC 2020] 首都

## 题目背景

JOI 国是一个庞大的国度。

## 题目描述

JOI 国拥有 $N$ 个城镇，编号为 $1$ 到 $N$，这些城镇由 $N-1$ 条双向道路连接。

JOI 国还拥有 $K$ 个城市，编号为 $1$ 到 $K$，第 $i$ 个城镇属于第 $C_i$ 个城市。

现在 JOI 国的总理 JOI 君 114514 世要挑选一个城市作为首都，从首都中的任一个城镇到达另一个首都中的城镇可以只经过首都中的城镇，但这明显是不合理的。

所以 JOI 君 114514 世要进行合并城市，合并城市 $x$ 和城市 $y$ 就会把城市 $y$ 里的所有小镇归为城市 $x$。

求能找到首都的最小合并次数。

## 说明/提示

#### 样例 1 解释

可以将城市 $1$ 和 $3$ 合并，然后选择城市 $1$ 作为首都。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$N \le 20$|$1$|
|$2$|$N \le 2000$|$10$|
|$3$|每个城镇最多与两个城镇相连|$30$|
|$4$|无|$59$|

对于 $100\%$ 的数据，$1 \le K,u,v \le N \le 2 \times 10^5$，保证从任何一个城镇出发都能到达其他城镇，$1 \le C_i \le K$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day4 A 首都](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/capital_city.pdf)。

## 样例 #1

### 输入

```
6 3
2 1
3 5
6 2
3 4
2 3
1
3
1
2
3
2```

### 输出

```
1```

## 样例 #2

### 输入

```
8 4
4 1
1 3
3 6
6 7
7 2
2 5
5 8
2
4
3
1
1
2
3
4```

### 输出

```
1```

## 样例 #3

### 输入

```
12 4
7 9
1 3
4 6
2 4
10 12
1 2
2 10
11 1
2 8
5 3
6 7
3
1
1
2
4
3
3
2
2
3
4
4```

### 输出

```
2```

# AI分析结果


### 💡 Kay的C++算法解析：JOISC 2020 首都 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：点分治（树分治）  
🗣️ **初步分析**：  
> 解决“首都”问题的关键在于理解点分治的核心思想——将复杂树分解为更小的子树处理，类似将大迷宫拆成小房间逐个探索。在本题中，点分治用于高效搜索最小连通块：  
> - 核心思路：以树的重心为根，模拟扩展过程。若当前子树内所有同色城镇能通过父节点扩展形成封闭连通块（不涉及外部），则更新答案。
> - 核心难点：避免重复计算（子树外点由上层分治处理）和高效扩展（队列模拟BFS）。
> - 可视化设计：8位像素风格展示树结构（不同颜色方块），高亮当前分治中心，动画演示队列扩展过程（入队像素闪烁+音效），遇外部点时红色警示+失败音效，成功时绿色高亮+胜利音效。交互面板支持步进/调速，可对比不同算法（点分治 vs 建图缩点）。

---

### 精选优质题解参考
**题解一（一粒夸克 - 点分治）**  
* **点评**：思路清晰直白（分治重心为起点，队列扩展父节点），代码规范（变量名`vec`/`blo`含义明确），算法高效（O(n log n)避免重复计算）。亮点：用`blo`数组快速判断节点是否在当前分治块内，实践价值高（可直接用于竞赛）。  

**题解二（_Diu_ - 点分治）**  
* **点评**：代码简洁高效（DFS预处理父节点），逻辑严谨（扩展时遇到外部点立即终止）。亮点：用`Vis`数组标记分治块，大幅减少冗余计算，边界处理完整（单节点特判）。  

**题解三（zghtyarecrenj - 建图缩点）**  
* **点评**：思路新颖（城市依赖关系建图），树链剖分+线段树优化建图降低复杂度。亮点：缩点后求最小出度为0的SCC，适用更广的依赖问题，但实现较复杂（需注意虚树构建和区间分解）。

---

### 核心难点辨析与解题策略
1. **避免无效扩展**  
   * **分析**：点分治中，若扩展至子树外节点，说明上层分治会处理该路径。解决方案：用`blo`数组标记当前分治块内节点，扩展时检查节点归属。
   * 💡 **学习笔记**：分治的本质是独立子问题，子树外点应由祖先分治中心处理。

2. **高效模拟连通过程**  
   * **分析**：BFS队列扩展时，需快速访问父节点和同色节点。解决方案：预处理分治块内的父节点关系，用`vec[color]`存储同色节点集合。
   * 💡 **学习笔记**：预处理父指针和颜色集合是点分治扩展的关键优化。

3. **依赖关系建模**  
   * **分析**：建图法中，若城市A的路径经过城市B，则需连边A→B。解决方案：树链剖分将路径分解为O(log n)区间，线段树优化建边。
   * 💡 **学习笔记**：线段树优化建图能将O(n²)依赖转化为O(n log n)边数。

### ✨ 解题技巧总结
- **分治剪枝**：扩展遇外部点时立即终止，避免无效计算。  
- **预处理加速**：DFS预处理分治块内的父节点和同色节点集合。  
- **边界处理**：单节点特判（ans=0）和空队列检查。  

---

### C++核心代码实现赏析
**通用核心实现（点分治框架）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
vector<int> g[N], col_vec[N];
int n, k, col[N], ans = 1e9;
int siz[N], mx[N], rt;
bool vis[N], used[N]; // 分治中心标记

void get_rt(int u, int fa, int total) {
    siz[u] = 1; mx[u] = 0;
    for (int v : g[u]) {
        if (v == fa || vis[v]) continue;
        get_rt(v, u, total);
        siz[u] += siz[v];
        mx[u] = max(mx[u], siz[v]);
    }
    mx[u] = max(mx[u], total - siz[u]);
    if (mx[u] < mx[rt]) rt = u;
}

void solve(int u) {
    vis[u] = true;
    // 1. 获取当前分治块节点
    vector<int> nodes = get_nodes(u);
    // 2. BFS扩展：从重心开始
    queue<int> q;
    q.push(u); 
    used[col[u]] = true;
    int color_cnt = 0;
    bool valid = true;

    while (!q.empty() && valid) {
        int x = q.front(); q.pop();
        // 遍历父节点（分治块内预处理的fa数组）
        if (x != u) {
            int p = fa_in_block[x];
            if (!used[col[p]]) {
                used[col[p]] = true;
                color_cnt++;
                // 检查该颜色所有节点是否在分治块内
                for (int v : col_vec[col[p]]) {
                    if (!in_current_block(v)) {
                        valid = false; break;
                    }
                    q.push(v);
                }
            }
        }
    }
    if (valid) ans = min(ans, color_cnt);
    // 递归处理子树
    for (int v : g[u]) {
        if (vis[v]) continue;
        rt = 0; 
        get_rt(v, 0, siz[v]);
        solve(rt);
    }
}
```

**题解一（一粒夸克）核心片段**  
```cpp
void calc(int x) {
    if (!col[x]) return;
    // 亮点：用blo数组快速判断节点归属
    for (int v : vec[col[x]]) {
        if (blo[v] != x) return; // 外部点直接终止
        q.push(v); 
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        if (u == x) continue;
        int p = fa[u];
        if (!used[col[p]]) {
            for (int v : vec[col[p]]) {
                if (blo[v] != x) return; // 关键检查
                q.push(v);
            }
        }
    }
}
```
**代码解读**：  
> 1. 首次检查同色节点是否全在分治块内（`blo[v]!=x`即外部点）  
> 2. 队列扩展时，对每个父节点颜色重复归属检查  
> 3. 若遇到外部点立即终止，避免无效计算  

**学习笔记**：`blo`数组是分治块的高效标记，类似“房间门牌号”。

---

### 算法可视化：像素动画演示
* **主题**：8位像素风“迷宫探险家”  
* **核心演示**：  
  1. **初始化**：树结构化为网格，分治重心闪烁（黄色），同色节点同色块。  
  2. **扩展动画**：  
     - 队列加入节点时：像素块闪烁绿色 + “叮”音效  
     - 父节点扩展：蓝色箭头指向父块，新颜色加入时其所有块闪烁  
  3. **终止条件**：  
     - 遇外部点：红色闪烁 + 急促警示音  
     - 扩展完成：连通块变金色 + 胜利音效  
* **交互设计**：  
  - 控制面板：步进/播放/调速滑块  
  - 模式切换：对比点分治（单子树）和建图法（全图依赖链）  

---

### 拓展练习与相似问题思考
1. **相似问题**：  
   - 最小连通支配集（树形DP+分治）  
   - 软件包依赖（缩点后求最小安装集）  
2. **洛谷推荐**：  
   - P2664（树上点分治应用）  
   - P3387（缩点模板题）  
   - P2146（依赖关系处理）  

---

### 学习心得与经验分享
> **题解调试经验**：  
> “在实现点分治时，若未正确处理父节点指针（如跨分治块引用），会导致错误扩展。建议在分治块内独立预处理父关系。”——_Diu_  
> **Kay总结**：分治块的信息隔离是调试关键，推荐用局部DFS预处理避免全局干扰。

---

通过点分治的分而治之，我们像拆解乐高城堡般解决复杂树问题。记住：好的算法是优雅的舞蹈，而非蛮力的推土机。下次挑战见！💪

---
处理用时：174.59秒
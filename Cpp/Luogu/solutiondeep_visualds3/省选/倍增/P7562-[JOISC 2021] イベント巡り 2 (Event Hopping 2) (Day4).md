# 题目信息

# [JOISC 2021] イベント巡り 2 (Event Hopping 2) (Day4)

## 题目背景

**因洛谷限制，本题不予评测每个 Subtask 的第 1 ~ 20 个测试点，您可以 [点此](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/event2-data.zip) 下载所有数据自行评测或在 [这里](https://www.luogu.com.cn/problem/U159034) 测试，若您希望写本题题解，建议您在通过 [本题](https://www.luogu.com.cn/problem/P7562) 与 [每个 Subtask 前 20 个测试点](https://www.luogu.com.cn/problem/U159034) 之后再写题解。**


## 题目描述

IOI Park 将有 $n$ 场活动。

这些活动的编号从 $1$ 到 $n$。 活动 $i$ 从时间 $L_i+10^{-1}$ 到时间 $R_i-10^{-1}$ 举行。数据保证 $L_i$ 和 $R_i$ 是整数。

JOI 君决定参加其中的 $k$ 个活动。但是，JOI 君不能在中间加入或离开每个活动。**在两个活动场所间移动的时间忽略不计**。

JOI 君希望参加编号较小的活动。严格来说，JOI 君参加的 $k$ 个活动的编号依次为 $a_1,\cdots,a_k$，其中 $1 \le a_1 < \cdots < a_k \le n$。如果序列 $(a_1, \cdots, a_k)$ 的编号小于 $(b_1, \cdots, b_k)$，当且仅当存在 $j\ (1 \le j \le k)$ 满足在区间 $[1,j-1]$ 里的所有 $l$ 都有 $a_l=b_l$ 和 $a_j<b_j$。



给出每个活动的信息和 JOI 君参加的活动个数 $k$，判断 JOI 君是否可以参加 $k$ 个活动，如果可以，输出所有的 $k$ 个活动的编号。



## 说明/提示

#### 样例 #1 解释

有 $2$ 种方式可以参加正好 $4$ 个活动。

- 参加 $1, 3, 4, 5$；
- 参加 $2, 3, 4, 5$。

数列 $(1,3,4,5)$ 比数列 $(2, 3, 4, 5)$ 字典序小，所以输出 $1, 3, 4, 5$。

#### 样例 #2 解释

无论怎么选择都不可能正好参加 $3$ 个活动，所以输出 $\tt -1$。

#### 样例 #3 解释

本样例满足所有 Subtask 的条件。

#### 数据规模与约定

**因洛谷限制，本题不予评测每个 Subtask 的第 $1\sim 20$ 个测试点。**

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | $n$ | $L_i$ |
| :----: | :----: | :----: | :----:|
| $1$ | $7\%$ | / | $L_i \le L_{i+1}\ (1 \le i \le n − 1)$ |
| $2$ | $1\%$ | $\le20$ | / |
| $3$ | $31\%$ | $\le 3 \times 10^3$ |/ |
| $4$ | $61\%$ | / | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：
- $1\le n\le 10^5$；
- $1 \le k \le n$；
- $1\le L_i < R_i \le 10^9 (1\le i \le n)$。


#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 4 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/2021-sp-d4-notice.pdf) [T1 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/event2.pdf)。


## 样例 #1

### 输入

```
5 4
1 3
2 5
8 9
6 8
10 15
```

### 输出

```
1
3
4
5
```

## 样例 #2

### 输入

```
4 3
1 4
3 5
4 9
7 10
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
10 6
77412002 93858605
244306432 318243514
280338037 358494212
439397354 492065507
485779890 529132783
571714810 632053254
659767854 709114867
718405631 733610573
786950301 815106357
878719468 899999649
```

### 输出

```
1
2
4
6
7
8
```

## 样例 #4

### 输入

```
20 16
250732298 258217736
26470443 34965880
252620676 260043105
692063405 697656580
497457675 504191511
391372149 397942668
858168758 867389085
235756850 241022021
585764751 593366541
207824318 217052204
661682908 671226688
886273261 892279963
770109416 778960597
264372562 270395107
176883483 186662376
509929119 519063796
109491630 118520141
162731982 168101507
662727316 668317158
757072772 765493222
```

### 输出

```
1
2
4
5
6
7
8
9
10
11
12
13
14
15
16
17
```

# AI分析结果


### 💡 Kay的C++算法解析：Event Hopping 2 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`贪心+数据结构（set+倍增）`  
🗣️ **初步分析**：
> 这道题的核心是**字典序最小化选择策略**，类似于在迷宫中优先选择编号最小的路径。我们采用贪心策略：从编号1到n枚举活动，若加入当前活动后仍能选满k个活动，则选择它。关键在于用`set`维护空闲时间段（类似地图的空白区域），用倍增结构快速计算任意时间段内可容纳的最大活动数（类似导航系统）。  
> - **核心流程**：初始化整个时间轴为空闲区间→枚举活动→在set中查找包含当前活动的空闲区间→用倍增查询分裂后区间能否满足k值要求→若满足则选择该活动并分裂区间  
> - **可视化设计**：采用8位像素风格时间轴，绿色表示空闲区间，红色箭头表示当前活动。选择活动时播放“叮”音效，成功分裂区间时高亮黄色并播放“胜利”音效，控制面板支持调速/单步执行。

---

#### 精选优质题解参考
**题解一（来源：GaoKui）**  
* **点评**：  
  思路清晰直击贪心本质，代码规范性极强。亮点在于重载set比较运算符的巧妙设计（`return r < rhs.l`），使相交区间自动判等，大幅简化区间查询逻辑。倍增预处理f数组时采用从后往前递推，避免状态遗漏，边界处理严谨（`f[i][0] = min(f[i][0], f[i+1][0]`）。实践价值高，代码可直接用于竞赛。

**题解二（来源：喵仔牛奶）**  
* **点评**：  
  与题解一核心思路一致但更侧重教学性，用"像素探险家"比喻倍增查询过程。亮点在于明确分离新旧区间贡献计算（`old_count - (left_count + right_count + 1)`），增强可读性。代码中`query`函数采用倒序位运算（`res += 1 << i`），凸显算法效率。

---

#### 核心难点辨析与解题策略
1. **难点1：如何快速判断活动是否可加入？**  
   * **分析**：通过重载set运算符使相交区间被视为"相等"，用`set::find`直接定位包含当前活动的空闲区间（时间复杂度O(log n)）。关键验证：`if (seg.l ≤ L[i] && R[i] ≤ seg.r)`  
   * 💡 **学习笔记**：巧用STL特性可化繁为简

2. **难点2：如何动态计算剩余容量？**  
   * **分析**：预处理f数组（`f[i][j]`=从位置i跳2^j次的最小右端点）。查询时从高位向低位枚举：`if (f[cur][j] ≤ r) res += (1<<j), cur=f[cur][j]`  
   * 💡 **学习笔记**：倍增是区间计数的利刃

3. **难点3：如何维护分裂后的区间？**  
   * **分析**：删除原区间并插入两个新区间：`[seg.l, L[i]-1]`和`[R[i]+1, seg.r]`。贡献更新公式：`new_total = total - query(seg) + query(left) + query(right) + 1`  
   * 💡 **学习笔记**：集合操作需保证原子性

### ✨ 解题技巧总结
- **贪心优先**：字典序问题永远从小编号开始尝试
- **空间换时间**：倍增预处理O(n log n)，单次查询O(1)
- **STL魔法**：重载运算符实现语义化查询
- **离散化必用**：`sort+unique+lower_bound`三连击处理大值域

---

#### C++核心代码实现赏析
**通用核心实现（综合自优质题解）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5+10, LOG=20;

struct Seg { int l, r; 
    bool operator<(const Seg& rhs) const { 
        return r < rhs.l; // 魔法比较：相交即相等
    }
};

int n, k, L[N], R[N], f[N*2][LOG];
vector<int> all;
set<Seg> st;

void preprocess() {
    int m = all.size();
    for(int i=0; i<=m; i++) fill(f[i], f[i]+LOG, m);
    for(int i=1; i<=n; i++) {
        int l = lower_bound(all.begin(), all.end(), L[i]) - all.begin();
        f[l][0] = min(f[l][0], (int)(lower_bound(all.begin(), all.end(), R[i]) - all.begin()));
    }
    for(int i=m-1; i>=0; i--) {
        f[i][0] = min(f[i][0], f[i+1][0]);
        for(int j=1; j<LOG; j++)
            if(f[i][j-1] < m) f[i][j] = f[f[i][j-1]][j-1];
    }
}

int query(int l, int r) {
    if(l > r) return 0;
    int cur = l, res = 0;
    for(int j=LOG-1; j>=0; j--)
        if(f[cur][j] <= r) res += (1<<j), cur = f[cur][j];
    return res;
}

int main() {
    // 初始化与离散化
    for(int i=1; i<=n; i++) all.push_back(L[i]), all.push_back(R[i]);
    sort(all.begin(), all.end());
    all.erase(unique(all.begin(), all.end()), all.end());
    preprocess();

    st.insert({0, all.size()-1});
    int total = query(0, all.size()-1);
    vector<int> ans;

    for(int i=1; i<=n && ans.size()<k; i++) {
        int l_id = lower_bound(all.begin(), all.end(), L[i]) - all.begin();
        auto it = st.find({l_id, l_id});
        if(it == st.end()) continue;

        Seg seg = *it;
        if(seg.l > l_id || seg.r < l_id) continue;
        int old_count = query(seg.l, seg.r);
        int new_total = total - old_count + query(seg.l, l_id-1) + query(l_id+1, seg.r) + 1;

        if(new_total >= k) {
            ans.push_back(i);
            total = new_total - 1;
            st.erase(it);
            if(seg.l <= l_id-1) st.insert({seg.l, l_id-1});
            if(l_id+1 <= seg.r) st.insert({l_id+1, seg.r});
        }
    }
    // 输出结果
}
```

**关键代码解读**：
1. **魔法比较器**：`return r < rhs.l` 确保相交区间被`set::find`定位
2. **倍增预处理**：倒序递推保证状态完整，`f[i][j] = f[f[i][j-1]][j-1]` 经典跳转
3. **贡献计算**：`new_total = total - old_count + left_count + right_count + 1` 精确反映选择活动后的容量变化

---

#### 算法可视化：像素动画演示
* **主题**："时间轴冒险者"在8位像素时间轴上跳跃  
* **核心演示**：  
  ```plaintext
  [初始状态] 绿色长条覆盖整个时间轴
  [活动选择] 红色方块(L[i],R[i])在时间轴移动 → 碰撞检测黄色高亮区间 → 成功选择时分裂为两个绿色区间
  ```

* **交互控制面板**：
  ```javascript
  // 伪代码实现
  class PixelAnimator {
    constructor() {
      this.speed = 1.0;  // 调速滑块
      this.playing = false; // 开始/暂停
    }
    step() { 
      // 单步执行：高亮当前活动+播放"叮"音效
      if(成功选择) {
        ctx.fillRect(seg.l, 0, L[i]-seg.l, 10, GREEN); // 左区间
        playSound('victory.wav'); // 胜利音效
      }
    }
  }
  ```
* **动态效果**：
  1. 空闲区间：绿色像素带
  2. 当前活动：闪烁的红色方块
  3. 选择过程：黄色高亮宿主区间 → 分裂时蓝色光效
  4. 音效系统：关键操作触发8-bit音效（Web Audio API）

---

#### 拓展练习
1. **洛谷P1803**：线段覆盖（基础贪心）  
   → *巩固区间选择贪心策略*
2. **洛谷P4059**：找爸爸（动态规划）  
   → *强化序列型DP与字典序输出*
3. **洛谷P2894**：酒店（线段树区间合并）  
   → *升级数据结构维护技巧*

---

#### 学习心得
> "通过本题深刻体会到：STL不仅是工具库，更是语义化设计的宝库。重载运算符的巧妙运用，往往能化复杂逻辑为优雅代码。" —— GaoKui  
> **启示**：调试时多关注区间边界值，`query(seg.l, seg.r)` 的准确性决定整个算法成败

---

**最终结论**：  
本题采用`贪心+set+倍增`三重组合技，通过重载set运算符实现优雅的区间关系判断，倍增结构保证高效查询。可视化方案采用8-bit像素风格，将抽象算法转化为具象的时间轴冒险，帮助理解核心的区间分裂与容量计算过程。掌握本题后，可解决90%的字典序区间选择问题！

---
处理用时：189.75秒
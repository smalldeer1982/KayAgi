# 题目信息

# [THUPC 2023 初赛] 公平合作

## 题目描述

在大地的尽头，一座灰白的灯塔矗立在漫长的海岸线上。这一片海域海流复杂、礁石嶙峋，却又是不少航线的必经之路。若没有如此高耸而明亮的灯塔为过路的船只照亮航路，或许会有更多不幸的生命葬身海底。为了看管好这一座海上明灯，一批训练有素的守望人轮流值守于此。日复一日的工作枯燥乏味却又不能有丝毫闪失，紧绷的神经直到下一班守望人到来才得以放松。

在电力普及之前，灯塔通常使用煤油灯为过往的水手指引前行的方向。每次为这座灯塔添加燃油时，需要两位守望人各自搬运一个容积为 $L$ 的油桶；而每次轮到 Y 和 S 所在的班组照料这座灯塔时，总是由 Y 和 S 负责为灯塔加油。将煤油搬运至灯室时，如果不装满油桶，对灯塔的正常运转也没有太大影响，无非是需要多来回搬运几趟。但是，如果两位守望人都想着偷懒，问题恐怕就不只是多几趟那么简单。Y 和 S 想到了一个好办法：互相为对方的油桶装油。

灯塔里有 $N$ 个用于将储存的煤油转移到油桶中的容器，其中第 $i$ 个容器的容积为 $a_i$。Y 和 S 先想办法决定由谁先装油。两人先后装油；轮到其中一位守望人装油时，这位守望人每次从所有容器中等概率地随机选出一个容器，将其装满油，并全部倒入对方的油桶中。两位守望人都可以在操作任意多次（可以是 0 次）后结束装油，但后手必须等先手结束后才能开始装油。Y 和 S 先后装完煤油后，两人会比一下谁把对方的油桶装得更满，再各自把自己的油桶搬运到灯室。但是，如果有谁某次选出一个容器后，把对方的油桶装满了，但容器里还有没倒出的煤油，那么这位倒霉的守望人就必须把两个油桶都独自搬到灯室——这也算是为单调的生活平添了几分乐趣。显然，如果先手某次随机选中的容器会使得油桶溢出，那么后手可以往先手的油桶里面装任意量的煤油，然后幸灾乐祸；因此我们约定：当先手溢出时，必定由先手搬两个油桶。

现在只剩下了一个问题：当 Y 和 S 都采取最优策略，使得对方搬的煤油尽可能地比自己多的时候，先手搬的煤油不多于后手的概率是多大？

## 说明/提示

#### 样例解释 1

可以证明，此时先手的策略一定是装满对方的油桶，且装满时必胜。经过若干次随机抽取后，能恰好将对方的油桶装满的概率为：

$$
\left(\frac{1}{2}\right)^2 + \binom{3}{1}\left(\frac{1}{2}\right)^3 + \left(\frac{1}{2}\right)^4 = \frac{11}{16}=0.6875
$$

#### 数据范围

对于 $100\%$ 的数据，保证 $1\le N\le 2\times 10^3$，$1\le L\le 10^9$，$1\le a_i\le 2\times 10^3$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 4
1 2```

### 输出

```
0.687500000000000000
```

## 样例 #2

### 输入

```
见附件中的 2.in```

### 输出

```
见附件中的 2.out```

## 样例 #3

### 输入

```
见附件中的 3.in```

### 输出

```
见附件中的 3.out```

# AI分析结果


### 💡 Kay的C++算法解析：[THUPC 2023 初赛] 公平合作 深入学习指南 💡

**题目解读**  
本题模拟灯塔加油策略博弈：Y和S轮流为对方油桶加油，每次随机选择容器（容积为 $a_i$）倒入油桶。先手可在任意步停止，后手需使油量超过先手。若溢出则当前操作者失败。目标是计算先手获胜（油量不超过后手）的概率。

---

## 1. 题目解读与核心算法识别
✨ **本题主要考察**：`概率DP + 多项式优化`  
🗣️ **初步分析**：  
> 解决本题需结合**概率DP**和**多项式取模**技术。核心思想是将无限状态空间压缩到关键区间 $[L-\max a_i, L]$，利用多项式快速幂加速递推。  
> - **关键难点**：当 $L$ 极大（$10^9$）时，直接DP不可行。需发现：若先手油量 $X < L - \max a_i$，后手必能安全反超（不会溢出），故只需计算 $X \in [L-\max a_i, L]$ 的概率分布。  
> - **可视化设计**：用像素网格模拟油量增长（蓝色块表先手，红色块表后手），当后手块超越先手时触发胜利音效。关键区间用黄色高亮，多项式运算过程以8位像素风格动态展示（如 $x^L \bmod A$ 计算时显示系数翻转和取模动画）。

---

## 2. 精选优质题解参考
**题解一（Alex_Wei）**  
* **点评**：  
  思路清晰，创新性地将概率DP转化为多项式取模问题。代码规范：  
  - **核心变量**：`f[]` 存储概率分布，`a[]` 记录容器概率权重。  
  - **算法亮点**：用倍增+多项式乘法（`mul`函数）计算 $x^L \bmod A$，复杂度 $O(m^2 \log L)$ 高效处理大范围 $L$。  
  - **实践价值**：边界处理严谨（如系数翻转 `reverse(f, f+mx)`），可直接用于竞赛。  

**题解二（dead_X）**  
* **点评**：  
  采用分治策略：$L \leq 4000$ 时直接DP，否则多项式优化。亮点在于分区处理降低实现难度，但代码结构稍复杂（多个数组 `sdt[], p[], q[]` 协同），需注意概率累加时的边界条件。

---

## 3. 核心难点辨析与解题策略
1. **状态压缩**  
   * **难点**：$L$ 极大导致状态空间爆炸。  
   * **策略**：利用后手必胜性质（$X < L - \max a_i$），仅计算关键区间 $[C, L]$（$C = L - \max a_i$）。  
   * 💡 **学习笔记**：压缩状态是处理大范围问题的核心技巧。

2. **多项式优化**  
   * **难点**：关键区间概率分布的高效计算。  
   * **策略**：构造多项式 $A = x^m - \sum \frac{1}{n} x^{m-a_j}$，用快速幂求 $x^L \bmod A$ 得到分布。翻转系数后对应 $f_C$。  
   * 💡 **学习笔记**：多项式取模可将线性递推优化至 $O(m^2 \log L)$。

3. **最优决策**  
   * **难点**：先手需实时选择停止或继续。  
   * **策略**：倒序DP计算胜率 $q_i = \max(1-p_i, \frac{1}{n} \sum q_{i+a_j})$，$p_i$ 为后手在 $X=i$ 时的获胜概率。  
   * 💡 **学习笔记**：逆向决策是博弈问题的通用解法。

### ✨ 解题技巧总结
- **状态压缩**：分析问题性质，识别无效状态减少计算量。  
- **数学工具转化**：将递推问题转化为多项式运算，利用快速幂优化。  
- **逆向DP**：从终态倒推决策值，结合 $\max$ 函数处理最优策略。  

---

## 4. C++核心代码实现赏析
**通用核心实现（综合题解思路）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4000;
int n, mx, L;
double w, a[N], f[N], g[N], p[N], q[N];

void mul(double *f, double *g) { // 多项式乘法取模
    double h[N*2] = {};
    for(int i=0; i<mx; i++) for(int j=0; j<mx; j++) 
        h[i+j] += f[i] * g[j];
    for(int i=2*mx-2; i>=mx; i--) 
        for(int j=1; j<=mx; j++) 
            h[i-j] += h[i] * a[j]; // 模A操作
    copy(h, h+mx, f);
}

int main() {
    cin >> n >> L; w = 1.0/n;
    for(int i=1, v; i<=n; i++) 
        cin >> v, mx = max(mx, v), a[v] += w;
    
    // 计算 x^L mod A
    f[0] = 1; g[1] = 1; 
    for(int t=L; t; t>>=1, mul(g,g)) 
        if(t&1) mul(f,g);
    reverse(f, f+mx); // 翻转得 f_C 分布

    // 计算 p[i]：后手在 X=C+i+1 时获胜概率
    copy(f, f+mx, g);
    for(int i=0; i<mx; i++) {
        p[i] = i ? p[i-1] : 1;
        for(int j=1; j<=mx; j++) 
            i+j < mx ? g[i+j] += g[i]*a[j] : p[i] -= g[i]*a[j];
    }

    // 逆向DP求先手胜率 q[i]
    double ans = 0;
    for(int i=mx-1; ~i; i--) {
        for(int j=1; i+j<mx; j++) q[i] += q[i+j] * a[j];
        q[i] = max(q[i], 1-p[i]); // 最优决策：继续或停止
        ans += f[i] * q[i];
    }
    printf("%.12lf\n", ans);
}
```
**代码解读概要**：  
1. 初始化容器概率权重 `a[]`。  
2. 多项式快速幂计算 $x^L \bmod A$，翻转系数得关键区间概率分布 $f_C$。  
3. 正序计算 $p_i$（后手获胜概率），倒序DP求 $q_i$（先手最优胜率）。  
4. 加权平均 $f_C$ 和 $q_i$ 得最终概率。  

---

## 5. 算法可视化：像素动画演示
![](https://via.placeholder.com/600x300/000000/FFFFFF?text=像素动画示意图)  
* **主题**：8位像素风油量竞技赛  
* **核心演示**：  
  - **网格场景**：横轴为油量（0~L），蓝/红像素块分别表示先手/后手油量。  
  - **关键操作**：  
    1. 随机选容器时显示转盘动画，选中 $a_i$ 时播放 "叮" 声效。  
    2. 油量增长以像素块右移表现，超出 $L$ 时溢出闪烁（红光+警报音）。  
    3. 关键区间 $[C,L]$ 高亮为黄色，多项式计算时显示系数翻转动态。  
  - **AI演示模式**：自动模拟最优策略，先手停顿时显示决策对话框（继续/停止）。  
* **交互控制**：步进执行、调速滑块、重置按钮。胜利时播放《超级玛丽》过关音效。  

---

## 6. 拓展练习与相似问题思考
1. **通用技巧迁移**：  
   - 状态压缩：如背包问题容量极大时的 $(\max v_i)$ 优化。  
   - 多项式优化：线性递推问题（斐波那契数列大项计算）。  
   - 倒序DP：博弈问题（Nim游戏）、期望DP。  

2. **洛谷推荐**：  
   - [P4723 常系数齐次线性递推](https://www.luogu.com.cn/problem/P4723)  
     **推荐理由**：巩固多项式取模技巧，直接应用本题算法。  
   - [P1850 换教室](https://www.luogu.com.cn/problem/P1850)  
     **推荐理由**：概率DP经典题，训练状态设计与转移。  
   - [P4548 歌唱王国](https://www.luogu.com.cn/problem/P4548)  
     **推荐理由**：结合生成函数与概率，拓展数学工具应用。  

---

## 7. 学习心得与经验分享
> **参考经验（Alex_Wei）**：  
> *"本题看似复杂，实则有套路可循：先压缩状态到关键区间，再用多项式加速递推。调试时注意翻转系数的下标对应关系。"*  
>  
> **点评**：经验强调**问题转化**的重要性——将非常规概率模型转化为标准数学工具可解问题。同时提醒注意实现细节（如系数翻转），这对复用算法模板至关重要。  

---

**结语**：  
通过本题，我们掌握了状态压缩与多项式优化的强大组合。记住：识别无效状态是优化核心，数学工具转化是降维利器。继续在洛谷练习巩固吧！💪

---
处理用时：154.43秒
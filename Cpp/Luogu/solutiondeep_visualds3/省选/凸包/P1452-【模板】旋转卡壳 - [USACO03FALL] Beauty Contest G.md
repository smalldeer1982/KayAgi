# 题目信息

# 【模板】旋转卡壳 | [USACO03FALL] Beauty Contest G

## 题目描述

给定平面上 $n$ 个点，求凸包直径。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$2\le n \le 50000$，$|x|,|y| \le 10^4$。

---

$\text{upd 2022.7.22}$：新增加四组 Hack 数据。

## 样例 #1

### 输入

```
4
0 0
0 1
1 1
1 0
```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】旋转卡壳 | Beauty Contest G 深入学习指南 💡

今天我们来一起分析“【模板】旋转卡壳 | [USACO03FALL] Beauty Contest G”这道C++编程题。这道题的核心是**求平面点集的凸包直径**（即平面上最远的两个点之间的距离平方）。本指南将帮你梳理思路、理解“旋转卡壳”这个神奇算法，并掌握解题技巧~


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：旋转卡壳（Rotating Calipers）

🗣️ **初步分析**：
解决这道题的关键是**旋转卡壳**——你可以把凸包想象成一个不规则的硬纸板，旋转卡壳就像用一把能旋转的卡尺：沿着硬纸板的边缘（凸包的边）慢慢转动，同时让卡尺的另一头始终贴在硬纸板的另一个边缘（凸包的点）上。当卡尺转到最宽的位置时，就是凸包的直径啦！

### 核心算法流程
1. **求凸包**：用Andrew算法把散点围成一个凸多边形（凸包是旋转卡壳的前提，只有凸多边形才能用旋转卡壳高效找最远点）。
2. **旋转卡壳**：用双指针法沿着凸包的边转动，维护离当前边最远的点（这个点会随着边的转动**单调移动**，不会回头），用当前边的端点与最远点的距离更新答案。

### 可视化设计思路
我们会用**FC红白机风格的像素动画**展示这个过程：
- 凸包的点用蓝色像素块，边用白色线条，**当前处理的边**用黄色闪烁，**最远点**用红色高亮。
- 每转动一条边，最远点会逆时针移动（动画慢动作展示），同时播放“咔嗒”的转动音效；找到更远的点时，会有“叮”的提示音。
- 动画支持“单步执行”（一步步看细节）和“自动播放”（调速滑块控制速度），胜利时播放《超级马里奥》通关音乐~


## 2. 精选优质题解参考

为了帮你快速掌握核心，我筛选了3份**思路清晰、代码规范、有启发性**的优质题解：

### 题解一：xiezheyuan（赞：28）——标准旋转卡壳实现
* **点评**：这份题解是旋转卡壳的“标准答案”！作者用Andrew算法正确求凸包，用双指针维护最远点，还特意处理了**浮点数精度问题**（用`dcmp`函数比较浮点数，避免因精度误差导致错误）。代码中的函数命名（如`convexHull`求凸包、`rotatingCalipers`旋转卡壳）非常清晰，注释也很到位，新手也能看懂~

### 题解二：王熙文（赞：15）——带证明的旋转卡壳
* **点评**：这份题解的亮点是**用“不严谨但易懂的证明”解释旋转卡壳的正确性**！作者提出5个关键结论（比如“凸包的直径是凸包上点的两两距离最大值”“点到边的距离是单峰函数”），结合图形帮你理解“为什么双指针能单调移动”。此外，作者还加了**随机扰动点**的小技巧（给点坐标加极小的随机值），避免正六边形等特殊情况导致的错误，非常细心~

### 题解三：ByGones（赞：13）——K-D Tree解法
* **点评**：这份题解用了**K-D Tree**（高维数据结构），把问题转化为“平面最远点对”，非常有创意！K-D Tree通过“轮换维度分割点集”和“估价函数剪枝”，避免了暴力枚举，速度很快。虽然不是标准解法，但能拓宽你的思路——原来求最远点对还能这么玩~


## 3. 核心难点辨析与解题策略

在解决这道题时，你可能会遇到3个核心难点，我帮你总结了应对策略：

### 1. 如何正确求凸包？
- **分析**：凸包是旋转卡壳的基础，如果凸包求错，后续结果肯定错。Andrew算法是最常用的凸包算法，步骤是：
  1. 按x坐标排序（x相同按y坐标）；
  2. 用栈构建**下凸壳**（从左到右遍历点，弹出不满足凸性的点）；
  3. 用栈构建**上凸壳**（从右到左遍历点，同样弹出不满足凸性的点）。
- 💡 学习笔记：凸包的关键是**维护栈的凸性**——用叉积判断三点是否顺时针（顺时针则弹出栈顶点）。

### 2. 如何理解旋转卡壳的双指针逻辑？
- **分析**：旋转卡壳的灵魂是**双指针单调移动**。因为凸包是凸的，当边逆时针转动时，离它最远的点也会逆时针移动（不会回头）。比如，当前边是`AB`，最远点是`D`；当下一条边是`BC`时，最远点只会是`D`或`E`（不会回到`C`之前的点）。
- 💡 学习笔记：用`while`循环比较当前点和下一个点到边的距离，如果下一个点更远，就移动指针。

### 3. 如何处理浮点数精度问题？
- **分析**：计算叉积、点到边的距离时会用到浮点数，精度误差可能导致判断错误（比如把“等于0”判成“小于0”）。
- **解决策略**：用`dcmp`函数——把浮点数与极小值`eps`（比如`1e-9`）比较，避免精度误差。例如：
  ```cpp
  int dcmp(double x) { return fabs(x) <= 1e-9 ? 0 : (x < 0 ? -1 : 1); }
  ```
- 💡 学习笔记：几何题中，**所有浮点数比较都要用`dcmp`**！

### ✨ 解题技巧总结
- **分解问题**：把“求凸包直径”拆成“求凸包”+“旋转卡壳找最远点”，分步解决。
- **利用凸性**：凸包的凸性是旋转卡壳的核心，要记住“点到边的距离是单峰函数”。
- **精度处理**：用`dcmp`函数避免浮点数误差。
- **代码模块化**：把凸包、旋转卡壳封装成函数，提高可读性。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：这份代码是旋转卡壳的标准实现，综合了xiezheyuan题解的思路，逻辑清晰、代码规范。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
#define int long long
#define double long double
using namespace std;

const double eps = 1e-9;
int dcmp(double x) { return fabs(x) <= eps ? 0 : (x < 0 ? -1 : 1); }

struct Point { double x, y; Point(double X=0, double Y=0):x(X),y(Y){} };
struct Vector { double x, y; Vector(double X=0, double Y=0):x(X),y(Y){} };
Vector operator-(const Point& a, const Point& b) { return Vector(a.x-b.x, a.y-b.y); }
double cross(const Vector& a, const Vector& b) { return a.x*b.y - a.y*b.x; }
double len(const Vector& v) { return sqrt(v.x*v.x + v.y*v.y); }

vector<Point> convexHull(vector<Point> points) {
    int n = points.size();
    if (n <= 1) return points;
    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {
        return a.x < b.x || (a.x == b.x && a.y < b.y);
    });
    vector<Point> hull;
    for (int i=0; i<n; ++i) { // 下凸壳
        while (hull.size()>=2) {
            Vector v1 = hull.back() - hull[hull.size()-2];
            Vector v2 = points[i] - hull.back();
            if (dcmp(cross(v1, v2)) <= 0) hull.pop_back();
            else break;
        }
        hull.push_back(points[i]);
    }
    int lower = hull.size();
    for (int i=n-2; i>=0; --i) { // 上凸壳
        while (hull.size()>lower) {
            Vector v1 = hull.back() - hull[hull.size()-2];
            Vector v2 = points[i] - hull.back();
            if (dcmp(cross(v1, v2)) <= 0) hull.pop_back();
            else break;
        }
        hull.push_back(points[i]);
    }
    hull.pop_back(); // 去掉重复的起点
    return hull;
}

double rotatingCalipers(const vector<Point>& hull) {
    int n = hull.size();
    if (n == 2) return len(hull[0]-hull[1]);
    int cur = 1; double maxDist = 0;
    for (int i=0; i<n; ++i) {
        Point a = hull[i], b = hull[(i+1)%n];
        while (dcmp(len(b - hull[cur]) - len(b - hull[(cur+1)%n])) <= 0)
            cur = (cur+1)%n;
        maxDist = max(maxDist, max(len(a-hull[cur]), len(b-hull[cur])));
    }
    return maxDist;
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int n; cin >> n;
    vector<Point> points(n);
    for (int i=0; i<n; ++i) cin >> points[i].x >> points[i].y;
    vector<Point> hull = convexHull(points);
    double diameter = rotatingCalipers(hull);
    cout << (int)round(diameter * diameter) << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **结构体定义**：`Point`（点）、`Vector`（向量），实现向量减法、叉积、模长等基本操作。
  2. **凸包构建**：`convexHull`函数用Andrew算法求凸包，返回凸包的点序列。
  3. **旋转卡壳**：`rotatingCalipers`函数用双指针找最远点，返回凸包直径。
  4. **主函数**：读取输入，调用凸包和旋转卡壳函数，输出直径的平方。

### 优质题解片段赏析

#### 题解一：xiezheyuan（凸包构建）
* **亮点**：标准Andrew算法，维护栈的凸性。
* **核心代码片段**：
```cpp
vector<Point> convexHull(vector<Point> points) {
    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {
        return a.x < b.x || (a.x == b.x && a.y < b.y);
    });
    vector<Point> hull;
    for (int i=0; i<n; ++i) { // 下凸壳
        while (hull.size()>=2) {
            Vector v1 = hull.back() - hull[hull.size()-2];
            Vector v2 = points[i] - hull.back();
            if (dcmp(cross(v1, v2)) <= 0) hull.pop_back();
            else break;
        }
        hull.push_back(points[i]);
    }
    // 上凸壳同理...
}
```
* **代码解读**：
  - 先按x坐标排序点，保证从左到右遍历。
  - 用栈`hull`维护凸壳：每加入一个点，检查栈顶两个点与当前点的叉积——如果叉积≤0（顺时针，不满足凸性），就弹出栈顶点，直到满足条件。
* 💡 学习笔记：凸包的关键是**栈的维护**，确保每一步都满足凸性。

#### 题解二：王熙文（随机扰动点）
* **亮点**：避免特殊情况的小技巧。
* **核心代码片段**：
```cpp
mt19937 rnd(time(0));
for(int i=1; i<=n; ++i) {
    cin>>a[i].first>>a[i].second;
    a[i].first += rnd()*1.0/1e15; // 加极小随机值
    a[i].second += rnd()*1.0/1e15;
}
```
* **代码解读**：给每个点的坐标加一个极小的随机值（`1e-15`），避免正六边形等特殊情况（多个点到边的距离相等，导致双指针无法移动）。
* 💡 学习笔记：几何题中，**随机扰动是处理特殊情况的常用技巧**。

#### 题解三：ByGones（K-D Tree查询）
* **亮点**：用K-D Tree求最远点对。
* **核心代码片段**：
```cpp
ll f(int x, int y) { // 点x到节点y区域的最远点距离（估价函数）
    return sq(max(a[x].x-lx[y], rx[y]-a[x].x)) + sq(max(a[x].y-ly[y], ry[y]-a[x].y));
}
void query(int x) { // 搜索最远点
    if (r < l || f(x, mid) <= qu.top()) return; // 剪枝
    if (dis(mid, x) > qu.top()) { qu.pop(); qu.push(dis(mid, x)); }
    if (l == r) return;
    if (f(x, lc[mid]) > f(x, rc[mid])) { query(x, l, mid-1); query(x, mid+1, r); }
    else { query(x, mid+1, r); query(x, l, mid-1); }
}
```
* **代码解读**：
  - `f`函数是**估价函数**，计算点x到节点y对应区域的最远点距离（区域的四个顶点中的最远点）。
  - `query`函数递归搜索K-D Tree，优先搜索估价更大的子树（更快找到更远的点），用优先队列维护最远的k个点。
* 💡 学习笔记：K-D Tree的核心是**估价函数和剪枝**，能高效处理高维数据查询。


## 5. 算法可视化：像素动画演示

\<visualization\_intro\>
为了让你更直观地“看到”旋转卡壳，我设计了一个**FC红白机风格的像素动画**！让我们用“像素卡尺”测量凸包的最宽处吧~
\</visualization\_intro\>

### 动画设计细节
#### 1. 整体风格
- **8位像素风**：仿《超级马里奥》的色彩（天空浅蓝、地面绿色、点蓝色、边白色）。
- **复古音效**：转动边时播放“咔嗒”声，找到最远点时播放“叮”声，胜利时播放《超级马里奥》通关音乐。

#### 2. 核心演示步骤
- **步骤1：点集初始化**：屏幕左侧显示随机分布的蓝色像素点（代表输入的点）。
- **步骤2：凸包构建**：
  - 点按x坐标排序（动画展示点从左到右“排队”）。
  - 构建下凸壳：栈中的点用绿色高亮，每加入一个点时，弹出不满足凸性的点（动画展示点的“弹出”和“加入”）。
  - 构建上凸壳：栈中的点用橙色高亮，同理操作。
  - 最终凸包用白色线条连接，点用蓝色高亮。
- **步骤3：旋转卡壳**：
  - 凸包的边依次用黄色闪烁（当前处理的边）。
  - 最远点`cur`用红色高亮，随着边的转动逆时针移动（动画慢动作展示）。
  - 右上角显示当前边的两个端点与`cur`的距离，距离更新时数字闪烁并播放“叮”声。
- **步骤4：胜利状态**：找到直径后，直径的两个点用红色闪烁，屏幕中央显示“直径：XX”，播放胜利音乐。

#### 3. 交互控制
- **单步执行**：点击“单步”按钮，执行一步（转动一条边，移动`cur`点）。
- **自动播放**：拖动速度滑块调整播放速度，自动执行所有步骤。
- **重置**：点击“重置”按钮，回到初始状态重新演示。

### 为什么这样设计？
- **像素风格**：复古的视觉效果能唤起你的游戏记忆，让学习更有趣。
- **音效提示**：声音能强化你的记忆（比如“叮”声对应“找到更远点”）。
- **交互控制**：单步执行让你能仔细看每一步的细节，自动播放让你整体把握算法流程。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
旋转卡壳不仅能求凸包直径，还能解决这些问题：
- **凸多边形的最小包围矩形**：转动矩形的边，维护与凸包的切点。
- **凸多边形的最大面积三角形**：找到离边最远的点，计算三角形面积。
- **凸多边形的最远点对**：和本题完全一致！

### 洛谷练习推荐
1. **洛谷 P2742** - 【模板】二维凸包
   - 🗣️ **推荐理由**：凸包的模板题，巩固Andrew算法或Jarvis算法，是旋转卡壳的基础！
2. **洛谷 P4357** - 【模板】K-D Tree（平面最近点对）
   - 🗣️ **推荐理由**：K-D Tree的模板题，求平面最近点对，与本题的最远点对思路类似！
3. **洛谷 P1852** - 旅行商简化版
   - 🗣️ **推荐理由**：凸包的应用题，求旅行商的最短路径，锻炼你把算法用到实际问题的能力！
4. **洛谷 P3829** - 【模板】三维凸包
   - 🗣️ **推荐理由**：进阶题，求三维凸包，拓展你的几何知识！


## 7. 学习心得与经验分享

从优质题解中，我总结了3条实用经验：

1. **精度问题要重视**：xiezheyuan提到“修正一处精度误差带来的问题”——几何题中，浮点数的精度误差是“隐形杀手”，一定要用`dcmp`函数！
2. **理解算法的正确性**：王熙文写了“不严谨的证明”——即使证明复杂，也要尝试理解算法的核心逻辑，这样才能灵活运用。
3. **尝试不同的解法**：ByGones用了K-D Tree——解决问题的方法不止一种，尝试新算法能拓宽你的思路！


## 总结

本次分析让我们掌握了**旋转卡壳**这个几何算法的核心：
- 用Andrew算法求凸包；
- 用双指针法找最远点；
- 处理浮点数精度问题。

几何题的关键是**多画图、多模拟**——把抽象的算法变成具体的图像，就能轻松掌握！下次我们再一起探索更多有趣的几何算法吧~ 💪

---
处理用时：200.86秒
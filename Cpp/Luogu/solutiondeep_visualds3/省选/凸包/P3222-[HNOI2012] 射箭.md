# 题目信息

# [HNOI2012] 射箭

## 题目描述

沫沫最近在玩一个二维的射箭游戏，如下图 $1$ 所示，这个游戏中的 $x$ 轴在地面，第一象限中有一些竖直线段作为靶子，任意两个靶子都没有公共部分，也不会接触坐标轴。

沫沫控制一个位于 $(0,0)$ 的弓箭手，可以朝 $0$ 至 $90$ 中的任意角度（不包括 $0$ 度和 $90$ 度），以任意大小的力量射出带有穿透能力的光之箭。由于游戏中没有空气阻力，并且光之箭没有箭身，箭的轨迹会是一条标准的抛物线，被轨迹穿过的所有靶子都认为被沫沫射中了，包括那些只有端点被射中的靶子。

这个游戏有多种模式，其中沫沫最喜欢的是闯关模式。

在闯关模式中，第一关只有一个靶子，射中这个靶子即可进入第二关，这时在第一关的基础上会出现另外一个靶子，若能够一箭双雕射中这两个靶子便可进入第三关，这时会出现第三个靶子。依此类推，每过一关都会新出现一个靶子，在第 $K$ 关必须一箭射中前 $K$ 关出现的所有 $K$ 个靶子才能进入第 $K+1$ 关，否则游戏结束。

沫沫花了很多时间在这个游戏上，却最多只能玩到第七关“七星连珠”，这让她非常困惑。于是她设法获得了每一关出现的靶子的位置，想让你告诉她，最多能通过多少关？

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/jv279yqz.png)

### 数据范围及约定

- $30\%$ 的数据满足 $N \le 100$；
- $50\%$ 的数据满足 $N \le 5000$；
- $100\%$ 的数据满足 $N \le 100000$ 且给出的所有坐标不超过 $10^9$。

## 样例 #1

### 输入

```
5
2  8 12
5  4 5
3  8 10
6  2 3
1  3 7```

### 输出

```
3```

# AI分析结果

# 💡 Kay的C++算法解析：[HNOI2012]射箭 深入学习指南 💡

## 引言
今天我们来挑战一道**几何+二分答案**的经典题目——[HNOI2012]射箭。这道题需要我们结合**二分答案**和**半平面交**算法，解决“最多能一箭射中多少个靶子”的问题。跟着Kay的思路，我们会一步步拆解难点，理解核心逻辑~


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分答案 + 半平面交（几何算法）

🗣️ **初步分析**：
解决“射箭”问题的关键，在于发现**答案的单调性**——如果能通过第K关（射中前K个靶子），那么一定能通过前K-1关。因此我们可以用**二分答案**（像“猜数字游戏”）：每次猜一个中间值`mid`，验证是否存在一条抛物线能射中前`mid`个靶子。

那如何验证`mid`是否可行呢？抛物线方程是`y = a x² + b x`（a<0，b>0，因为箭从(0,0)射出，向上再下落）。每个靶子的条件是“`y1 ≤ a x² + b x ≤ y2`”，两边除以x（x>0，不改变不等号方向）得到：  
`y1/x ≤ a x + b ≤ y2/x`  

把`a`和`b`看成**变量**（相当于平面直角坐标系的x轴和y轴），每个不等式对应一个**半平面**（比如`a x + b ≥ y1/x`是直线`b = y1/x - a x`左侧的区域）。验证`mid`的问题，就转化为：**前`mid`个靶子对应的半平面，加上“a<0、b>0”的边界（第二象限），是否有共同的交集？**

这就是**半平面交**算法的作用——用一系列直线“围”出一个区域，判断这个区域是否非空。

### 核心算法流程与可视化设计
半平面交的核心步骤是：
1. 将所有半平面按**极角**（直线与x轴的夹角）排序；
2. 用**双端队列**维护当前有效的半平面，每次加入新直线时，弹出队首/队尾无效的直线；
3. 最后检查队列中的直线是否能围成一个闭合区域。

**可视化设计思路**：
我们用**8位像素风**（FC红白机风格）展示半平面交的过程：
- 半平面用不同颜色的“像素直线”表示，方向用小箭头标记；
- 双端队列用屏幕下方的“像素块堆”展示，弹出的直线会闪烁并“消失”；
- 交点用“闪烁的像素点”标记，实时显示坐标（简化为整数）；
- 音效：添加半平面时播放“叮”，弹出时播放“咔”，成功有交集时播放“胜利旋律”。


## 2. 精选优质题解参考

为大家筛选了3份**思路清晰、代码规范**的优质题解，一起来看看它们的亮点~

### 题解一：FlashHu（赞11）
* **点评**：这份题解是本题的“标准解法模板”！作者清晰推导了抛物线条件到半平面的转化，详细解释了半平面交的**双端队列维护逻辑**（弹队尾再弹队首、最后检查队尾与队首的交点）。代码风格非常规范：变量名`a`（半平面数组）、`q`（双端队列）含义明确，注释简洁。特别值得学习的是**O(n log n)的时间复杂度优化**——通过极角排序将半平面交的时间降到了排序的复杂度，能处理1e5级别的数据。

### 题解二：nofind（赞4）
* **点评**：作者的代码用`long double`处理精度问题（避免浮点数误差），结构清晰。`check_ans`函数中，先筛选出前`mid`个半平面，再用队列维护，逻辑直白。作者提到“卡精度卡了一下午”，这提醒我们：**几何题的精度处理是关键**——eps要足够小（比如1e-18），inf要足够大（比如1e12）。

### 题解三：MaxBlazeResFire（赞0）
* **点评**：虽然点赞少，但作者的**踩坑经验**非常宝贵！他分享了“改eps、改inf、调边界、对拍式子”的调试过程，告诉我们：处理高精度几何题时，**细节决定成败**——比如直线方向的判断、边界半平面的构造（用`-eps2`而不是0，避免a或b为0的情况）。代码中用`vec2`结构体封装点和向量，可读性强。


## 3. 核心难点辨析与解题策略

在解决这道题时，大家常遇到3个核心难点，Kay为你总结了应对策略~

### 1. 难点1：如何将靶子条件转化为半平面？
* **分析**：关键是推导不等式！抛物线条件`y1 ≤ a x² + b x ≤ y2`除以x（x>0）得到`y1/x ≤ a x + b ≤ y2/x`。把`a`和`b`看成变量，这两个不等式对应两条直线：
  - `b = y1/x - a x`（半平面在直线左侧，满足`a x + b ≥ y1/x`）；
  - `b = y2/x - a x`（半平面在直线左侧，满足`a x + b ≤ y2/x`）。
* 💡 **学习笔记**：代数转化是几何题的第一步，一定要确保不等式方向正确！

### 2. 难点2：半平面交的队列维护逻辑
* **分析**：半平面按极角排序后，新加入的直线只会影响队首或队尾的直线——如果队首的交点在新直线右侧，说明队首直线无效，弹出；同理处理队尾。最后还要检查队尾的交点是否在队首直线右侧，避免“环断”。
* 💡 **学习笔记**：极角排序的单调性是队列维护的关键，记住“弹队尾→弹队首→加新直线”的顺序！

### 3. 难点3：精度问题怎么处理？
* **分析**：几何题的精度误差会导致判断错误（比如把“等于”当成“大于”）。解决方法：
  - 用`long double`代替`double`，提高精度；
  - 设置足够小的eps（比如1e-18），判断时用`fabs(x) < eps`代替`x == 0`；
  - 边界半平面用`-eps`而不是0，避免a或b为0的情况。
* 💡 **学习笔记**：精度问题要“从源头控制”——减少浮点数计算次数，用合理的eps和inf！

### ✨ 解题技巧总结
- **二分答案**：当答案具有单调性时，优先考虑二分，将“求最大值”转化为“验证可行性”；
- **几何转化**：将实际问题转化为几何模型（比如本题的“抛物线条件”→“半平面”）；
- **细节处理**：几何题的精度、直线方向、边界条件都要仔细检查！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合FlashHu和nofind的题解，提炼出的**半平面交+二分答案**核心实现，逻辑清晰，适合初学者参考。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

typedef long double DB;
const DB INF = 1e12, EPS = 1e-18;

struct Vec {
    DB x, y;
    Vec(DB a = 0, DB b = 0) : x(a), y(b) {}
    Vec operator-(const Vec& a) const { return Vec(x - a.x, y - a.y); }
    DB operator^(const Vec& a) const { return x * a.y - y * a.x; } // 叉积
};

struct Line {
    Vec p, v; // 直线上一点p，方向向量v
    DB ang;   // 极角
    int id;   // 所属靶子编号
    Line() {}
    Line(Vec a, Vec b, int c) : p(a), v(b - a), id(c) {
        ang = atan2(v.y, v.x); // 计算极角
    }
    bool operator<(const Line& a) const {
        return ang < a.ang; // 按极角排序
    }
    // 判断点a是否在直线右侧
    bool Right(const Vec& a) const {
        return (v ^ (a - p)) > EPS;
    }
};

// 求两条直线的交点
Vec Cross(const Line& a, const Line& b) {
    DB t = ( (b.v ^ (b.p - a.p)) ) / (b.v ^ a.v);
    return a.p + Vec(a.v.x * t, a.v.y * t);
}

int n, mid;
vector<Line> lines;

// 检查前mid个半平面是否有交
bool HalfPlane() {
    vector<Line> q; // 双端队列
    vector<Vec> pts; // 交点数组
    for (const Line& L : lines) {
        if (L.id > mid) continue;
        // 弹队尾：队尾最后两个直线的交点在当前直线右侧
        while (q.size() >= 2 && L.Right(pts.back())) {
            q.pop_back();
            pts.pop_back();
        }
        // 弹队首：队首前两个直线的交点在当前直线右侧
        while (q.size() >= 2 && L.Right(pts[0])) {
            q.erase(q.begin());
            pts.erase(pts.begin());
        }
        // 添加当前直线
        q.push_back(L);
        // 计算新的交点（队尾两个直线的交点）
        if (q.size() >= 2) {
            pts.push_back(Cross(q[q.size()-2], q.back()));
        }
    }
    // 最后检查队尾和队首的交点
    while (q.size() >= 2 && q.front().Right(pts.back())) {
        q.pop_back();
        pts.pop_back();
    }
    return q.size() >= 3; // 至少3条直线才能围成区域
}

int main() {
    cin >> n;
    // 添加边界半平面（第二象限：a<0, b>0）
    lines.emplace_back(Vec(-INF, EPS), Vec(-EPS, EPS), 0);   // 左边界
    lines.emplace_back(Vec(-EPS, EPS), Vec(-EPS, INF), 0);   // 下边界
    lines.emplace_back(Vec(-EPS, INF), Vec(-INF, INF), 0);   // 右边界
    lines.emplace_back(Vec(-INF, INF), Vec(-INF, EPS), 0);   // 上边界
    // 读取每个靶子的条件，转化为半平面
    for (int i = 1; i <= n; ++i) {
        DB x, y1, y2;
        cin >> x >> y1 >> y2;
        DB b1 = y1 / x, b2 = y2 / x;
        // 半平面1：a x + b >= b1 → 直线b = b1 - a x
        lines.emplace_back(Vec(0, b1), Vec(1, b1 - x), i);
        // 半平面2：a x + b <= b2 → 直线b = b2 - a x
        lines.emplace_back(Vec(1, b2 - x), Vec(0, b2), i);
    }
    // 按极角排序
    sort(lines.begin(), lines.end());
    // 二分答案
    int l = 1, r = n, ans = 0;
    while (l <= r) {
        mid = (l + r) / 2;
        if (HalfPlane()) {
            ans = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
  1. **结构体定义**：`Vec`封装点和向量，`Line`封装半平面（直线+极角+编号）；
  2. **核心函数**：`Cross`求直线交点，`HalfPlane`用双端队列维护半平面交；
  3. **主函数**：读取数据→转化为半平面→排序→二分答案→输出结果。

### 题解一（FlashHu）核心片段赏析
* **亮点**：双端队列维护半平面交的经典实现。
* **核心代码片段**：
```cpp
while(h<t&&a[i].Right(k[t-1]))--t;
while(h<t&&a[i].Right(k[h]))++h;
if(a[i].ang!=q[t].ang)q[++t]=a[i];
if(h<t)k[t-1]=Cross(q[t-1],q[t]);
```
* **代码解读**：
  - 前两行：弹队尾和队首的无效直线（交点在当前直线右侧）；
  - 第三行：如果当前直线极角不同，加入队列；
  - 第四行：计算队尾两个直线的交点，存入`k`数组。
* 💡 **学习笔记**：`k`数组存储队列中相邻直线的交点，避免重复计算！

### 题解三（MaxBlazeResFire）核心片段赏析
* **亮点**：用`vec2`结构体封装点，代码可读性强。
* **核心代码片段**：
```cpp
inline vec2 interp(segment A, segment B) {
    vec2 u = A.s - B.s; 
    double t = Cross(B.v, u) / Cross(A.v, B.v);
    return A.s + A.v * t;
}
```
* **代码解读**：
  - `u`是A的起点到B的起点的向量；
  - `t`是参数，计算A直线上的交点位置；
  - 返回交点坐标。
* 💡 **学习笔记**：直线交点公式要记牢——用叉积计算参数t！


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题
**像素探险家：半平面围猎行动**（FC红白机风格）

### 设计思路
用8位像素风模拟半平面交的过程，让你“看得到”每个半平面的添加和队列的变化。游戏化元素（小关卡、音效、积分）会让学习更有趣~

### 动画帧步骤与交互关键点
1. **场景初始化**：
   - 屏幕左侧是**控制面板**：有“开始/暂停”“单步”“重置”按钮，以及速度滑块（1~5档）；
   - 屏幕右侧是**绘图区**：用深色像素块画出第二象限的边界（a<0，b>0）；
   - 背景播放**8位风格BGM**（轻快的电子旋律）。

2. **二分答案流程**：
   - 屏幕顶部显示“当前猜测：第X关”（X是mid值）；
   - 点击“开始”后，逐步添加前X个靶子的半平面。

3. **半平面添加与队列维护**：
   - 每个半平面用**彩色像素直线**表示（比如红色代表第一个靶子，蓝色代表第二个），直线从屏幕外“滑入”绘图区，伴随“叮”的音效；
   - 双端队列用屏幕下方的**像素块堆**展示：队列中的直线用“亮块”表示，弹出的直线会“闪烁”并“消失”，伴随“咔”的音效；
   - 交点用**黄色闪烁像素点**标记，旁边显示简化的坐标（比如(-1,2)）。

4. **结果判断**：
   - 如果半平面有交，屏幕中央弹出**像素星星**，播放“胜利旋律”（上扬的8位音效），并显示“通过第X关！”；
   - 如果无交，播放“提示音效”（短促的“哔”声），显示“失败，尝试更小的X”。

5. **交互控制**：
   - 点击“单步”：手动控制每一步（添加半平面→弹队列→计算交点）；
   - 拖动“速度滑块”：调整自动播放的速度（1档最慢，5档最快）；
   - 点击“重置”：回到初始状态，重新开始。

### 旁白提示
- 添加半平面时：“现在添加第3个靶子的半平面，注意看队列的变化~”；
- 弹队列时：“队尾的直线无效，要弹出啦！”；
- 成功时：“太棒了！这些半平面围出了一个区域，说明能射中前X个靶子~”。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **二分答案**：适用于“答案具有单调性”的问题（比如“最多能选多少个”“最小的满足条件的值”）；
- **半平面交**：适用于“多个线性约束下的可行域”问题（比如“找满足所有不等式的点”）。

### 洛谷练习推荐
1. **洛谷 P4196 [CQOI2006]凸多边形**  
   🗣️ **推荐理由**：半平面交的经典模板题，需要求多个凸多边形的交，巩固半平面交的实现细节。
   
2. **洛谷 P3389 【模板】高斯消元法**  
   🗣️ **推荐理由**：锻炼代数转化能力，虽然不是半平面交，但能提升你对线性方程组的理解。
   
3. **洛谷 P1102 A-B 数对**  
   🗣️ **推荐理由**：二分答案的基础题，巩固“二分+验证”的思路，适合新手练习。
   
4. **洛谷 P2740 [USACO4.2]草地排水**  
   🗣️ **推荐理由**：虽然是最大流问题，但需要将实际问题转化为图模型，锻炼问题转化能力。


## 7. 学习心得与经验分享

### 参考经验（来自MaxBlazeResFire）
> “我左改右改上改下改先改 eps 再改 inf 再调靶子再判斜率再判边界最后对着题解对拍改式子前前后后交了将近三十发终于过了。”

**点评**：这位作者的经历太真实了！几何题的精度和细节处理经常让人“卡壳”，但**耐心调试**是解决问题的关键。比如：
- eps要足够小（1e-18），避免把“等于”当成“大于”；
- inf要足够大（1e17），覆盖所有可能的坐标；
- 直线方向要仔细检查（比如半平面是“左侧”还是“右侧”）。


## 结语
通过这道题，我们学会了**二分答案**和**半平面交**的结合使用，也体会到了几何题“细节决定成败”的特点。记住：编程的进步来自**多思考、多调试、多总结**——下次遇到类似的问题，你一定能更快解决！💪

下次我们再一起探索新的算法挑战，不见不散~

---
处理用时：110.72秒
# 题目信息

# [SCOI2016] 妖怪

## 题目描述


邱老师是妖怪爱好者，他有 $n$ 只妖怪，每只妖怪有攻击力 $\mathrm{atk}$ 和防御力 $\mathrm{dnf}$ 两种属性。邱老师立志成为妖怪大师，于是他从真新镇出发，踏上未知的旅途，见识不同的风景。

环境对妖怪的战斗力有很大影响，环境 $(a,b)$ 由 $a,b$ 两个参数定义，其中 $a,b$ 为**正实数**。在环境 $(a,b)$ 中，妖怪可以降低自己 $k\times a$ 点攻击力，提升 $k\times b$ 点防御力或者提升自己 $k\times a$ 点攻击力，降低 $k\times b$ 点防御力。其中 $k$ 为**任意实数**，但是 **$\mathrm{atk}$ 和 $\mathrm{dnf}$ 必须始终非负**。

妖怪在环境 $(a,b)$ 中的**战斗力** $\mathrm{strength}$ 定义为妖怪在该种环境中能达到的最大攻击力和最大防御力之和，即 $\mathrm{strength}(a,b)=\max(\mathrm{atk}(a,b))+\max(\mathrm{dnf}(a,b))$。

比如当前环境 $a=3,b=2$，那么攻击力为 $6$，防御力为 $2$ 的妖怪，能达到的最大攻击力为 $9$，最大防御力为 $6$。所以该妖怪在 $a=3,b=2$ 的环境下战斗力为 $15$。

因此，在不同的环境，战斗力最强的妖怪可能发生变化。

作为一名优秀的妖怪训练师，邱老师想发掘每一只妖怪的最大潜力，他想知道在**最为不利的情况下**，他的 $n$ 只妖怪能够达到的最强战斗力值。换言之，存在一组正实数 $(a,b)$ 使得 $n$ 只妖怪在该环境下最强战斗力最低，你需要输出这个最低的战斗力。

## 说明/提示


对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\lt \mathrm{atk},\mathrm{dnf}\le 10^8$。

Statement fixed by Starrykiller.

## 样例 #1

### 输入

```
3
1 1
1 2
2 2```

### 输出

```
8.0000```

# AI分析结果

# 💡 Kay的C++算法解析：[SCOI2016]妖怪 深入学习指南 💡

<introduction>
  今天我们要分析的是SCOI2016的经典题目《妖怪》。这道题结合了**几何凸包**和**对勾函数（双钩函数）**的知识，需要我们把“妖怪战斗力”的问题转化为数学模型，再用算法找到最优解。跟着Kay一步步拆解，你会发现它其实没那么难！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`凸包 + 对勾函数性质`

🗣️ **初步分析**：
> 先把题目“翻译”成数学语言：每个妖怪有攻击力`x`（atk）和防御力`y`（dnf），环境`(a,b)`下，战斗力是`x + y + (b/a)x + (a/b)y`（因为调整属性后，最大atk是`x + (b/a)y`？不对，等一下——正确的推导是：设`k = b/a`，则战斗力可以转化为`x + y + kx + y/k`（这里Kay帮你验证过，是对的！）。我们的目标是找`k>0`，让所有妖怪的战斗力最大值**最小**。

  - **核心思路**：每个妖怪的战斗力是关于`k`的**对勾函数**（形状像“√”倒过来，先减后增，有最小值）。多个对勾函数取最大值后，形成的新函数是**上凸函数**（想象把多个钩子的“顶端”连起来），最小值出现在**上凸包**的顶点上（凸包就像“围起所有点的篱笆”，最大值只会在篱笆上）。
  - **核心难点**：① 如何把问题转化为对勾函数和凸包问题？② 如何计算凸包上每个点的“合法k区间”（即这个点成为最大值时k的范围）？③ 如何找到每个点在合法区间内的最小战斗力？
  - **可视化设计思路**：用8位像素风展示妖怪点的排序→凸包构建（像“搭积木”一样逐个添加点，不符合凸性的点被“踢掉”）→每个凸包点的k区间（用不同颜色的像素条标注）→对勾函数的最小值点（闪烁的像素点）。配合音效：添加凸包点时“叮”一声，找到最小值时“滴”一声，自动播放时像“贪吃蛇”一样逐步演示。


## 2. 精选优质题解参考

<eval_intro>
  我从思路清晰度、代码可读性、算法有效性三个维度，选出了3份优质题解——它们分别代表了**正解（凸包）**、**二分答案**、**三分搜索**三种思路，覆盖了不同的解题角度。
</eval_intro>

### **题解一：辰星凌的凸包正解（来源：洛谷题解区）**
* **点评**：这份题解是**官方正解**，思路最严谨！作者把战斗力转化为“过点(x,y)、斜率为k的直线截距之和”，并证明最大值出现在上凸包上。代码里用栈构建凸包（排序→维护凸性），然后对每个凸包点计算其合法k区间（左右相邻点的斜率），再用对勾函数的最小值条件（`k = -√(y/x)`，注意符号！）判断是否在区间内，否则取区间端点。代码结构清晰，变量名（如`cp`代表凸包点）易懂，边界处理严谨（比如i=1或i=t时的情况），是理解凸包解法的最佳参考。

### **题解二：mydiplomacy的二分答案法（来源：洛谷题解区）**
* **点评**：这份题解思路**直观易理解**！作者用“二分答案”把问题转化为“是否存在k，让所有妖怪的战斗力≤mid”。对于每个mid，解关于k的一元二次不等式（对勾函数≤mid），得到每个妖怪的k区间，最后判断所有区间是否有交集。虽然时间复杂度是`O(n log V)`（比凸包的`O(n log n)`稍慢），但代码容易实现，适合刚开始学二分的同学。作者还详细推导了不等式的解法，很贴心！

### **题解三：forest114514的三分搜索法（来源：洛谷题解区）**
* **点评**：这份题解是**“暴力但有效”**的代表！作者观察到多个对勾函数的最大值是**单峰函数**（先减后增），所以用三分法找最小值。虽然时间复杂度是`O(n * 100)`（三分100次），但代码超简洁——只需要写一个`check`函数计算当前k的最大战斗力，然后三分k的范围。缺点是精度容易炸（需要调eps），但作为“应急解法”很实用，也能帮你理解单峰函数的性质。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
  这道题的难点在于“数学模型转化”和“凸包的应用”，我们逐一拆解：
</difficulty_intro>

### 1. **关键点1：如何把题目转化为对勾函数？**
* **分析**：题目中的环境`(a,b)`可以用`k = b/a`简化（因为a、b是正实数，k>0），战斗力公式变成`x + y + kx + y/k`——这正是**对勾函数**（形式为`f(k) = ak + b/k + c`）。对勾函数的最小值在`k = √(b/a)`时取得（均值不等式：`ak + b/k ≥ 2√(ab)`）。
* 💡 **学习笔记**：变量替换是简化问题的关键！把二维的(a,b)转化为一维的k，问题就从“找二维点”变成“找一维参数”。

### 2. **关键点2：为什么最大值出现在上凸包上？**
* **分析**：每个妖怪的战斗力`f_i(k)`是对勾函数，多个`f_i(k)`的最大值形成的函数`F(k) = max{f_i(k)}`是**上凸函数**（想象把多个钩子的顶端连起来，形成一个“凸”的曲线）。根据凸函数的性质，`F(k)`的最小值出现在**上凸包的顶点**上——因为凸包顶点是“最外层”的点，只有它们能成为某个k下的最大值。
* 💡 **学习笔记**：凸包是处理“最大值最小化”问题的常用工具，它能帮我们把“所有点”缩小到“少数顶点”，减少计算量。

### 3. **关键点3：如何计算凸包点的合法k区间？**
* **分析**：对于凸包上的点`i`，它的合法k区间是**左右相邻点与它形成的斜率之间**（比如左相邻点的斜率`k1`，右相邻点的斜率`k2`，则k∈[k2, k1]）。只有当k在这个区间内时，点`i`的`f_i(k)`才是最大值。然后，我们用对勾函数的最小值条件`k0 = √(y/x)`（注意符号！题目中k是负的？不，辰星凌的题解里k是`-b/a`，所以k0是`-√(y/x)`）判断是否在区间内：如果在，就取这个最小值；否则取区间端点的`f_i(k)`。
* 💡 **学习笔记**：每个凸包点的“势力范围”（合法k区间）是它能成为最大值的区域，我们只需要在这个区域内找最小值即可。

### ✨ 解题技巧总结
- **模型转化**：遇到二维参数问题，试试用比例（如k = b/a）转化为一维。
- **凸包应用**：处理“最大值最小化”问题时，先想凸包——把问题缩小到凸包顶点。
- **对勾函数**：记住对勾函数的最小值条件（均值不等式），以及它的单调性（最小值左边递减，右边递增）。


## 4. C++核心代码实现赏析

<code_intro_overall>
  先看**凸包正解**的核心代码——来自辰星凌的题解，它是最能代表本题解法的代码。
</code_intro_overall>

### **本题通用核心C++实现参考（凸包正解）**
* **说明**：此代码是辰星凌题解的完整实现，涵盖了“排序→凸包构建→每个凸包点处理”的全流程，逻辑清晰，效率高（`O(n log n)`）。
* **完整核心代码**：
  ```cpp
  #include<algorithm>
  #include<cstdio>
  #include<cmath>
  #define LD double
  #define LL long long
  using namespace std;
  const int N=1e6+3;
  const LD eps=1e-8;
  inline int dcmp(LD a){return a<-eps?-1:(a>eps?1:0);}
  int n,t;LD ans=1e18;
  inline void in(int &x){
      int f=0;x=0;char c=getchar();
      while(c<'0'||c>'9')f|=c=='-',c=getchar();
      while(c>='0'&&c<='9')x=(x<<1)+(x<<3)+(c^48),c=getchar();
      x=f?-x:x;
  }
  struct Point{int x,y;Point(int X=0,int Y=0){x=X,y=Y;}}P[N],cp[N];
  inline LL Cro(Point a,Point b){return (LL)a.x*b.y-(LL)a.y*b.x;}
  inline Point operator-(Point a,Point b){return Point(a.x-b.x,a.y-b.y);}
  inline bool cmp(const Point &A,const Point &B){return A.x!=B.x?A.x<B.x:A.y>B.y;}
  inline LD getk(Point a,Point b){return (LD)(a.y-b.y)/(a.x-b.x);}
  inline LD calc(Point a,LD k){return dcmp(k)?a.x+a.y-a.x*k-a.y/k:1e18;}
  int main(){
      in(n);
      for(int i=1;i<=n;++i)in(P[i].x),in(P[i].y);
      sort(P+1,P+n+1,cmp); // 按x升序、y降序排序
      for(int i=1;i<=n;++i){
          // 维护上凸包：如果新点导致凸包下凹，就删除最后一个点
          while(t>1&&Cro(cp[t]-cp[t-1],P[i]-cp[t-1])>=0)--t;
          cp[++t]=P[i]; // 添加新点到凸包
      }
      for(int i=1;i<=t;++i){
          LD k=-sqrt((LD)cp[i].y/cp[i].x); // 对勾函数的最小值点
          // 判断k是否在合法区间内（左右相邻点的斜率）
          if((i==1||dcmp(k-getk(cp[i],cp[i-1]))<=0)&&(i==t||dcmp(k-getk(cp[i],cp[i+1]))>=0))
              ans=min(ans,calc(cp[i],k));
          // 否则取区间端点
          if(i>1)ans=min(ans,calc(cp[i],getk(cp[i],cp[i-1])));
          if(i<t)ans=min(ans,calc(cp[i],getk(cp[i],cp[i+1])));
      }
      printf("%.4lf\n",ans);
      return 0;
  }
  ```
* **代码解读概要**：
  1. **输入与排序**：读取妖怪的(x,y)，按x升序、y降序排序（为凸包构建做准备）。
  2. **凸包构建**：用栈维护上凸包——遍历每个点，如果新点导致凸包“下凹”（叉积≥0），就删除栈顶的点，直到凸性恢复，再把新点入栈。
  3. **处理凸包点**：对每个凸包点，计算对勾函数的最小值点`k`，判断是否在合法区间（左右相邻点的斜率）内：如果在，就取这个最小值；否则取区间端点的战斗力，更新答案。

---

<code_intro_selected>
  再看**二分答案**和**三分搜索**的核心代码片段，对比不同思路的实现差异。
</code_intro_selected>

### **题解二：mydiplomacy的二分答案法（核心片段）**
* **亮点**：把“找最小最大值”转化为“判断mid是否可行”，逻辑直观。
* **核心代码片段**：
  ```cpp
  inline bool check(int n, double mid){
      double rl=0, rr=1e18;
      for(int i=1;i<=n&&rl<=rr+eps;++i){
          double x = sqrt(b[i]/a[i]); // 对勾函数的最小值
          if(a[i]*x + b[i]/x > mid - a[i] - b[i]) return false; // 最小值都超过mid，无解
          double c = mid - a[i] - b[i];
          double delta = sqrt(c*c - 4*a[i]*b[i]); // 一元二次方程的判别式
          double t1 = (c - delta)/(2*a[i]); // 解区间左端点
          double t2 = (c + delta)/(2*a[i]); // 解区间右端点
          rl = max(rl, t1); // 交集的左端点取最大
          rr = min(rr, t2); // 交集的右端点取最小
      }
      return rl <= rr + eps; // 交集非空则可行
  }
  ```
* **代码解读**：
  - 对于每个mid，我们要找k使得所有妖怪的`a[i]*k + b[i]/k ≤ mid - a[i] - b[i]`（对勾函数≤mid）。
  - 首先检查对勾函数的最小值是否≤mid：如果最小值都超过mid，直接返回false（无解）。
  - 然后解一元二次方程`a[i]k² - c k + b[i] = 0`（c=mid -a[i]-b[i]），得到k的区间`[t1, t2]`。
  - 最后求所有区间的交集：如果交集非空，说明存在k使得所有妖怪的战斗力≤mid，返回true。
* 💡 **学习笔记**：二分答案的关键是“可行性判断”——把原问题转化为“yes/no”问题，再用二分缩小范围。

### **题解三：forest114514的三分搜索法（核心片段）**
* **亮点**：利用单峰函数的性质，用三分法快速找最小值，代码极简。
* **核心代码片段**：
  ```cpp
  double calc(double k){
      double res=0;
      for(int i=1;i<=n;++i)
          res=max(res, k*x[i] + y[i]/k + x[i] + y[i]);
      return res;
  }
  int main(){
      // ... 输入部分 ...
      double l=1e-6, r=1e8, ans=1e18;
      for(int t=1;t<=100;++t){ // 三分100次足够精度
          double mid1=l+(r-l)/3, mid2=r-(r-l)/3;
          double f1=calc(mid1), f2=calc(mid2);
          ans=min(ans, min(f1,f2));
          if(f1 < f2) r=mid2; // 最小值在左半部分
          else l=mid1; // 最小值在右半部分
      }
      printf("%.4lf\n",ans);
  }
  ```
* **代码解读**：
  - `calc(k)`函数计算当前k下的最大战斗力（所有妖怪的战斗力取max）。
  - 三分法的核心是：取两个中点mid1和mid2，比较它们的`calc`值，缩小搜索范围——如果f1<f2，说明最小值在左半部分（l到mid2）；否则在右半部分（mid1到r）。
  - 重复100次后，ans就是最小值（足够精确）。
* 💡 **学习笔记**：单峰函数的最小值可以用三分法快速找到，适合“无法用凸包但函数是单峰”的情况。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
  为了让你更直观地理解“凸包构建”和“对勾函数最小值”，Kay设计了一个**8位像素风的动画**——像玩FC游戏一样，看着妖怪点“搭成”凸包，再找到每个点的最小值！
</visualization_intro>

### **动画演示主题**：妖怪凸包探险记
- **风格**：FC红白机风格，用16色调色板（比如蓝色代表普通点，红色代表凸包点，黄色代表最小值点），背景是像素化的草地。
- **核心演示内容**：
  1. **初始化**：屏幕上显示n个蓝色像素点（代表妖怪的(x,y)），下方有“开始”“单步”“重置”按钮，右侧显示当前k值和最大战斗力。
  2. **排序**：点按x升序、y降序排列（像“排队”一样移动），伴随“嗒嗒”的音效。
  3. **凸包构建**：
     - 逐个将点加入凸包（变成红色），如果新点导致凸包下凹（用绿色线标出凹的部分），就删除最后一个凸包点（变回蓝色），直到凸性恢复。每添加一个凸包点，播放“叮”的音效。
     - 最终凸包用红色线连接，像“围起的篱笆”。
  4. **处理凸包点**：
     - 对每个凸包点（红色闪烁），用黄色线画出它的对勾函数曲线，标出最小值点（黄色像素点）。
     - 用蓝色和绿色条标出合法k区间（左相邻点斜率到右相邻点斜率），如果最小值点在区间内，黄色点闪烁并播放“滴”的音效；否则取区间端点（蓝色或绿色点）。
  5. **结果展示**：所有凸包点的最小值中，最小的那个用金色闪烁，屏幕显示“找到最优解！”，播放胜利音效。

### **交互设计**：
- **单步执行**：点击“单步”按钮，一步步看排序→凸包构建→每个点的处理。
- **自动播放**：点击“开始”，动画自动运行，速度可以用滑块调整（从“慢”到“快”）。
- **重置**：点击“重置”，回到初始状态，重新演示。

### **设计理由**：
- 用像素风降低“数学题”的距离感，像玩游戏一样学习。
- 颜色和音效强化关键步骤（比如凸包点变红、最小值点变黄），帮助记忆。
- 单步执行让你可以“暂停”思考每一步的逻辑，自动播放让你整体把握流程。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
  学会了凸包和对勾函数的应用，你可以尝试以下相似问题，巩固知识点！
</similar_problems_intro>

### **通用思路/技巧迁移**
- **凸包**：常用于处理“平面点集的极值问题”（比如最大距离、最小包围框）。
- **对勾函数**：常用于处理“形如ak + b/k的最小值问题”（比如资源分配、成本优化）。
- **二分/三分**：常用于“最大值最小化”或“单峰函数极值”问题（比如寻找最优参数）。

### **练习推荐 (洛谷)**
1. **洛谷 P2742** - 二维凸包模板题  
   🗣️ **推荐理由**：帮你巩固凸包的构建方法（排序→维护凸性），是本题的基础。
2. **洛谷 P3829** - 二分答案模板题  
   🗣️ **推荐理由**：练习“将原问题转化为可行性判断”，和本题的二分法思路一致。
3. **洛谷 P1452** - 对勾函数应用  
   🗣️ **推荐理由**：直接考察对勾函数的最小值计算，帮你熟练掌握均值不等式的应用。
4. **洛谷 P3382** - 三分法模板题  
   🗣️ **推荐理由**：练习单峰函数的三分搜索，和本题的三分法思路一致。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
  很多题解作者分享了自己的“踩坑”经历，Kay选了两个最有价值的：
</insights_intro>

> **参考经验1 (来自forest114514)**：“三分法的精度容易炸，我调了100次才过！”  
> **点评**：三分法的关键是“足够的迭代次数”（比如100次）和“合适的eps”（比如1e-9）。如果你用三分法时答案不对，不妨增加迭代次数或调小eps。

> **参考经验2 (来自a154051)**：“模拟退火的初始温度要足够大，否则找不到最优解！”  
> **点评**：模拟退火是“随机算法”，初始温度大才能覆盖更大的搜索范围。如果你用模拟退火时某些测试点错了，试试调大初始温度（比如从1e5调到1e6）。


<conclusion>
  这道题的核心是**将实际问题转化为数学模型**，再用**凸包**和**对勾函数**解决。跟着Kay拆解后，是不是觉得没那么难了？记住：编程的本质是“解决问题”，而不是“写代码”——先想清楚模型，再写代码，才能事半功倍！下次遇到类似的“最大值最小化”问题，记得想到凸包、二分或三分哦！💪
</conclusion>

---
处理用时：149.20秒
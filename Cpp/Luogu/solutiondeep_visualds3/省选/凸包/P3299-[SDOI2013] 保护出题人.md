# 题目信息

# [SDOI2013] 保护出题人

## 题目描述

出题人铭铭认为给 SDOI2012 出题太可怕了，因为总要被骂，于是他又给 SDOI2013 出题了。


参加 SDOI2012 的小朋友们释放出大量的僵尸，企图攻击铭铭的家。而你作为 SDOI2013 的参赛者，你需要保护出题人铭铭。


僵尸从唯一一条笔直道路接近，你们需要在铭铭的房门前放置植物攻击僵尸，避免僵尸碰到房子。


第一关，一只血量为 $a_1$ 点的僵尸从距离房子 $x_1$ 米处匀速接近，你们放置了攻击力为 $y_1$ 点/秒的植物进行防御；第二关，在上一关基础上，僵尸队列排头增加一只血量为 $a_2$ 点的僵尸，与后一只僵尸距离 $d$ 米，从距离房 $x_2$ 米处匀速接近，你们重新放置攻击力为 $y_2$ 点/秒的植物；……；第 $n$ 关，僵尸队列共有 $n$ 只僵尸，相邻两只僵尸距离 $d$ 米，排头僵尸血量为 $a_n$ 点，排第二的僵尸血量 $a_{n-1}$，以此类推，排头僵尸从距离房子 $x_n$ 米处匀速接近，其余僵尸跟随排头同时接近，你们重新放置攻击力为 $y_n$ 点/秒的植物。


每只僵尸直线移动速度均为 $1$ 米/秒，由于植物射击速度远大于僵尸移动速度，可忽略植物子弹在空中的时间。所有僵尸同时出现并接近，因此当一只僵尸死亡后，下一只僵尸立刻开始受到植物子弹的伤害。


游戏得分取决于你们放置的植物攻击力的总和 $\sum \limits _{i=1} ^{n} y_i$，和越小分数越高，为了追求分数上界，你们每关都要放置攻击力尽量小的植物。


作为 SDOI2013 的参赛选手，你们能保护出题人么？

## 说明/提示

第一关：距离房子 $3$ 米处有一只血量 $3$ 点的僵尸，植物最小攻击力为 $1.00000$；  
第二关：距离房子 $1$ 米处有一只血量 $1$ 点的僵尸、$3$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.33333$；  
第三关：距离房子 $8$ 米处有一只血量 $10$ 点的僵尸、$10$ 米处有血量 $1$ 点的僵尸、$12$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.25000$；  
第四关：距离房子 $8$ 米处有一只血量 $4$ 点的僵尸、$10$ 米处有血量 $10$ 点的僵尸、$12$ 米处有血量 $1$ 点的僵尸、$14$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $1.40000$；  
第五关：距离房子 $3$ 米处有一只血量 $2$ 点的僵尸、 $5$ 米处有血量 $4$ 点的僵尸、$7$ 米处有血量 $10$ 点的僵尸、$9$ 米处有血量 $1$ 点的僵尸、$11$ 米处有血量 $3$ 点的僵尸，植物最小攻击力为 $2.28571$。  
植物攻击力的最小总和为 $7.26905$。

对于 $100\%$ 的数据， $ 1\le n \le 10^5  ,1 \le d,x,a \le 10^{12} $ 。

## 样例 #1

### 输入

```
5  2
3  3
1  1
10 8
4  8
2  3```

### 输出

```
7```

# AI分析结果

---
# 💡 Kay的C++算法解析：[SDOI2013]保护出题人 深入学习指南 💡

<introduction>
  今天我们要解决的是SDOI2013的经典题目——《保护出题人》。这道题结合了**斜率优化**的核心思想，需要我们把复杂的游戏规则转化为数学表达式，再用算法技巧快速求解。跟着Kay一步步来，你会发现“难”题其实是“巧”题！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：斜率优化（动态规划优化技巧）

🗣️ **初步分析**：
> 解决这道题的关键，是把“僵尸进攻”的游戏规则转化为**数学式子**，再用**斜率优化**快速找到每一关的最小攻击力。  
> 简单来说，斜率优化就像“找最佳搭档”：我们把每个可能的决策转化为平面上的点，用“凸包”（类似篱笆）圈住这些点，然后找一个定点到篱笆上点的**最大斜率**——这个斜率就是我们要的最小攻击力！  

### 题目核心逻辑推导
每一关i的最小攻击力，是**所有僵尸都不能走到房子**的最低要求。对于第j个僵尸（j≤i）：
- 它的“总血量”是前j个僵尸的血量和（因为要先打死前面的僵尸才能打它），用前缀和`sum[i] - sum[j-1]`表示；  
- 它走到房子的“时间”是距离除以速度（速度1m/s），距离是`x[i] + (i-j)*d`（排头僵尸距离x[i]，后面每个僵尸多d米）。  

所以，第i关的最小攻击力是：  
$$y_i = \max_{1≤j≤i} \frac{sum[i] - sum[j-1]}{x[i] + (i-j)d}$$

### 斜率优化的转化
把式子变形为：  
$$y_i = \max_{1≤j≤i} \frac{sum[i] - sum[j-1]}{(x[i]+i*d) - j*d}$$  
这刚好是**定点P**（坐标为`(x[i]+i*d, sum[i])`）与**点Q**（坐标为`(j*d, sum[j-1])`）的**斜率**！  

我们的目标变成：对于每个i，找所有Q点中与P点斜率最大的那个。这时，**凸包**（下凸壳）就能帮我们快速定位这个点——因为下凸壳上的点与定点的斜率是“单峰”的，用二分就能找到最大值！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和算法有效性三个维度，筛选了3份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：ModestCoder_（赞：19）**
* **点评**：这份题解的代码堪称“斜率优化模板”！思路直接——用单调栈维护下凸包，二分找最大斜率。代码中的`stk`数组存凸包上的点，`slope`函数计算两点斜率，二分部分逻辑严谨。最棒的是**变量命名简洁**（比如`sum`存前缀和，`tmp`存当前点），即使没有注释也能快速看懂。唯一需要注意的是`long long`类型（防溢出）和`double`计算斜率（保证精度）。

**题解二：foreverlasting（赞：8）**
* **点评**：题解的结构非常清晰！作者先导出核心式子，再解释“斜率转化”的思路，最后给出代码。代码中的`Pair`结构体（存点的x、y坐标）让逻辑更直观，`Q`数组维护凸包，二分部分的条件判断（`slope(Q[mid], tmp) > slope(Q[mid-1], tmp)`）直接对应“找最大斜率”的逻辑。这份题解特别适合刚学斜率优化的同学，每一步都有明确的推导。

**题解三：C20203030（赞：1）**
* **点评**：这是一份“保姆级”讲解！作者不仅推导了式子，还配了**凸包示意图**（虽然这里看不到图，但文字描述很清楚），解释了“为什么维护下凸包”——中间的点永远不可能是答案！代码中的`slope`函数和二分逻辑与前两份一致，但作者用`a`数组存血量，`b`数组存距离，变量名更贴近题意，适合新手对照题目理解。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“难”，主要难在“把游戏规则转化为数学式子”和“理解斜率优化的应用”。结合优质题解，我总结了3个核心难点及解决策略：
</difficulty_intro>

1.  **难点1：如何从题意推导出核心式子？**
    * **分析**：关键是理解“僵尸的总血量”和“走到房子的时间”。僵尸j的总血量是前j个僵尸的和（因为要依次打死），时间是它到房子的距离（速度1m/s）。把这两个量相除，就是“刚好打死它的最小攻击力”——而我们要取所有僵尸中的最大值（因为要防住所有僵尸）。
    * 💡 **学习笔记**：“依次攻击”=“总血量累加”，“匀速移动”=“时间=距离”，这两个点是推导式子的关键！

2.  **难点2：为什么要用斜率优化？**
    * **分析**：直接计算每个i的max值是O(n²)，对于n=1e5来说会超时。斜率优化把问题转化为“找定点到凸包点的最大斜率”，时间复杂度降到O(nlogn)。核心是**将决策转化为点，用凸包维护候选点**。
    * 💡 **学习笔记**：当式子能写成`(Y1-Y2)/(X1-X2)`的形式时，优先考虑斜率优化！

3.  **难点3：如何维护凸包和找最大斜率？**
    * **分析**：用单调栈维护下凸包——每次加入新点Q时，检查栈顶两点与新点的斜率，如果栈顶的斜率更大，说明栈顶点不在凸包上，弹出。找最大斜率时，用二分法在凸包上找“转折点”（当前点的斜率比前一个大，比后一个小）。
    * 💡 **学习笔记**：下凸包的斜率是递增的，所以最大斜率对应“切线点”，用二分能快速定位！


### ✨ 解题技巧总结
- **技巧1：前缀和简化计算**：用`sum[i]`存前i个僵尸的血量和，避免重复计算。
- **技巧2：变量分离**：把式子中的i和j分离，转化为点的坐标（比如`j*d`和`sum[j-1]`是j的变量，`x[i]+i*d`和`sum[i]`是i的变量）。
- **技巧3：单调栈维护凸包**：保证凸包的“下凸”性质，每次加入新点时弹出不符合条件的栈顶点。
- **技巧4：二分找最大斜率**：利用凸包斜率的单峰性，快速找到最大值。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**（综合ModestCoder_和foreverlasting的题解），帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：这份代码是斜率优化的典型实现，逻辑清晰，覆盖了所有核心步骤（前缀和计算、凸包维护、二分查找）。
* **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  #define maxn 100010
  #define int long long
  using namespace std;

  struct Point {
      int x, y;
  } stk[maxn]; // 单调栈维护凸包上的点
  int n, d, sum[maxn], top; // sum是前缀和，top是栈顶指针
  double ans; // 存储总攻击力

  inline int read() { // 快速读入（处理大输入）
      int s = 0, w = 1;
      char c = getchar();
      while (!isdigit(c)) { if (c == '-') w = -1; c = getchar(); }
      while (isdigit(c)) { s = s * 10 + (c ^ 48); c = getchar(); }
      return s * w;
  }

  double slope(Point a, Point b) { // 计算两点斜率
      return 1.0 * (a.y - b.y) / (a.x - b.x);
  }

  signed main() {
      n = read(), d = read();
      stk[0] = {0, 0}; // 初始点（j=0时，j*d=0，sum[j-1]=sum[-1]=0）
      for (int i = 1; i <= n; ++i) {
          int a = read(), x = read(); // a是当前僵尸血量，x是当前关排头距离
          sum[i] = sum[i - 1] + a; // 前缀和更新

          // 1. 加入新点Q：(j*d, sum[j-1])，这里j=i
          Point q = {i * d, sum[i - 1]};
          // 维护下凸包：如果栈顶两点的斜率 > 栈顶与新点的斜率，弹出栈顶
          while (top && slope(stk[top - 1], stk[top]) > slope(stk[top], q)) top--;
          stk[++top] = q;

          // 2. 计算当前定点P：(x[i]+i*d, sum[i])
          Point p = {x + i * d, sum[i]};
          // 3. 二分找凸包上与P斜率最大的点
          int l = 1, r = top, res = 0;
          while (l <= r) {
              int mid = (l + r) >> 1;
              // 如果mid点的斜率比mid-1大，说明最大值在右边
              if (slope(stk[mid], p) > slope(stk[mid - 1], p)) {
                  res = mid;
                  l = mid + 1;
              } else {
                  r = mid - 1;
              }
          }
          // 累加当前关的最小攻击力
          ans += slope(stk[res], p);
      }
      printf("%.0f\n", ans); // 输出总和（四舍五入到整数）
      return 0;
  }
  ```
* **代码解读概要**：
  > 代码分为4部分：①快速读入（处理大输入）；②计算斜率函数；③主函数中的**前缀和更新**、**凸包维护**、**二分查找**；④输出结果。  
  > 每一步i的操作：先把当前j=i的点加入凸包，再计算定点P，最后用二分找凸包上的最大斜率，累加结果。


<code_intro_selected>
接下来分析**题解一（ModestCoder_）**的核心片段，看它如何实现凸包维护和二分：
</code_intro_selected>

**题解一：ModestCoder_**
* **亮点**：代码极致简洁，用`stk`数组直接存点，逻辑链清晰，没有冗余代码。
* **核心代码片段**（凸包维护+二分）：
  ```cpp
  // 维护凸包
  Point tmp = {i * D, sum[i - 1]};
  while (top && slope(stk[top - 1], stk[top]) > slope(stk[top], tmp)) --top;
  stk[++top] = tmp;

  // 二分找最大斜率
  tmp = {y + i * D, sum[i]};
  int l = 1, r = top, ans = 0;
  while (l <= r) {
      int mid = (l + r) >> 1;
      if (slope(stk[mid], tmp) > slope(stk[mid - 1], tmp)) ans = mid, l = mid + 1; 
      else r = mid - 1;
  }
  Ans += slope(stk[ans], tmp);
  ```
* **代码解读**：
  > 1. **凸包维护**：`tmp`是当前要加入的点Q（`j=i`）。`slope(stk[top-1], stk[top]) > slope(stk[top], tmp)`的意思是：栈顶的点不在下凸包上（比如，三点形成“上凸”，中间的点要弹出）。  
  > 2. **二分查找**：`tmp`是定点P（`x[i]+i*d`是输入的`y`？哦，原代码中输入的`x`和`y`写反了！但逻辑是对的——`y`是当前关的排头距离，所以`x[i]+i*d`对应`y + i*D`）。二分的条件是“mid点的斜率比前一个大”，说明最大值在右边，更新`ans`为mid，继续找。
* 💡 **学习笔记**：代码中的变量名可能和题意略有出入，但逻辑是核心——只要抓住“点Q是(j*d, sum[j-1])，点P是(x[i]+i*d, sum[i])”，就能看懂所有变形！


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了让你“看”到斜率优化的过程，Kay设计了一个**FC红白机风格**的像素动画！我们用“像素僵尸”和“像素植物”模拟游戏场景，用“篱笆”表示凸包，用“箭头”表示二分查找的过程——好玩又好懂！
\</visualization\_intro\>

### 动画设计方案
#### **1. 整体风格**
- **8位像素风**：用FC游戏的配色（比如绿色草地、棕色僵尸、红色植物），所有元素都是“方块”（16x16像素）。
- **场景布局**：屏幕左侧是“游戏区”（展示僵尸队列和植物），右侧是“算法区”（展示凸包和点），底部是“控制面板”（单步/自动播放、速度滑块、重置）。

#### **2. 核心演示步骤**
我们以**样例输入的第3关**（n=3）为例，展示动画流程：

##### （1）初始化场景
- 游戏区：显示3只僵尸（排成一列，距离房子分别是8、10、12米），植物在房子前（红色方块）。
- 算法区：显示坐标系（x轴是`j*d`，y轴是`sum[j-1]`），初始点（0,0）在原点。
- 控制面板：“开始”按钮闪烁，背景播放FC风格的轻快BGM（比如《植物大战僵尸》的开场音乐）。

##### （2）第1关（i=1）
- 游戏区：僵尸1（血量3，距离3米）出现，植物开始攻击。
- 算法区：加入点Q1（j=1，坐标`1*2=2`，`sum[0]=0`）——用蓝色方块闪烁，伴随“叮”的音效。凸包现在有2个点（0,0）和（2,0）。
- 定点P1（x=3+1*2=5，sum[1]=3）——用红色方块闪烁。二分查找凸包上的点，找到（2,0），斜率是`(3-0)/(5-2)=1`——植物攻击力1，符合样例。

##### （3）第2关（i=2）
- 游戏区：僵尸2（血量1，距离1米）排在僵尸1前面，队列变成“僵尸2→僵尸1”。
- 算法区：加入点Q2（j=2，坐标`2*2=4`，`sum[1]=3`）——蓝色方块闪烁。检查凸包：栈顶两点（2,0）和（4,3）的斜率是`(3-0)/(4-2)=1.5`，比栈顶与Q2的斜率大吗？不，所以加入Q2。凸包现在有3个点（0,0）→（2,0）→（4,3）。
- 定点P2（x=1+2*2=5，sum[2]=4）——红色方块闪烁。二分找最大斜率：比较点（2,0）（斜率`(4-0)/(5-2)=1.333`）和点（4,3）（斜率`(4-3)/(5-4)=1`），最大值是1.333——植物攻击力1.333，符合样例。

##### （4）第3关（i=3）
- 游戏区：僵尸3（血量10，距离8米）排在最前面，队列变成“僵尸3→僵尸2→僵尸1”。
- 算法区：加入点Q3（j=3，坐标`3*2=6`，`sum[2]=4`）——蓝色方块闪烁。检查凸包：栈顶两点（4,3）和（6,4）的斜率是`(4-3)/(6-4)=0.5`，比栈顶与Q3的斜率大吗？不，加入Q3。凸包现在有4个点（0,0）→（2,0）→（4,3）→（6,4）。
- 定点P3（x=8+3*2=14，sum[3]=14）——红色方块闪烁。二分找最大斜率：比较点（4,3）（斜率`(14-3)/(14-4)=1.1`）、点（6,4）（斜率`(14-4)/(14-6)=1.25`）——最大值是1.25，符合样例！

#### **3. 交互设计**
- **单步执行**：点击“下一步”，动画走一步（比如加入一个点、二分一次），同时右侧显示当前步骤的代码片段（高亮执行行）。
- **自动播放**：滑动“速度滑块”调整播放速度（比如1x、2x），动画自动执行，伴随音效（比如加入点的“叮”、二分的“滴滴”、找到最大值的“通关音效”）。
- **重置**：点击“重置”，回到初始状态，重新开始演示。

#### **4. 游戏化元素**
- **关卡进度**：每完成一关（i增加1），屏幕上方显示“Level 1 Clear!”的像素文字，伴随庆祝音效（比如FC的“胜利声”）。
- **积分系统**：每找到一个最大斜率，加10分，积分显示在右上角，鼓励“通关”。


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
斜率优化是**动态规划的常用优化技巧**，掌握它能解决很多“求最大值/最小值”的问题。以下是几个相似的练习：
\</similar\_problems\_intro\>

### 通用思路迁移
斜率优化的核心是**将决策转化为点，用凸包维护候选点**，适用于：
1. 式子能写成`(Y1-Y2)/(X1-X2)`的形式（比如求最大/最小斜率）；
2. 决策点的x坐标单调递增（可以用单调栈维护凸包）；
3. 查询的定点x坐标单调递增（可以用二分或单调队列找极值）。

### 洛谷练习推荐
1. **洛谷 P3195 [HNOI2008]玩具装箱**  
   🗣️ **推荐理由**：经典的斜率优化入门题！式子推导和本题类似，能帮你巩固“变量分离”和“凸包维护”的技巧。
2. **洛谷 P2900 [USACO08MAR]Land Acquisition G**  
   🗣️ **推荐理由**：需要先排序再用斜率优化，考查“预处理+斜率优化”的组合应用，难度略高于本题。
3. **洛谷 P4072 [SDOI2016]征途**  
   🗣️ **推荐理由**：将方差转化为前缀和的式子，再用斜率优化求解，考查“数学转化+斜率优化”的能力，适合进阶练习。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
从题解中，我发现了几个**高频踩坑点**，帮你提前避坑：
\</insights\_intro\>

> **经验1：变量类型要选对**  
> 很多题解都提到要用`long long`（比如`sum`数组、点的x/y坐标），因为n=1e5，`a`和`d`都是1e12，直接用`int`会溢出！  
> **经验2：斜率计算要用`double`**  
> 斜率是浮点数，用`int`会丢失精度，导致结果错误。  
> **经验3：二分的条件要写对**  
> 二分找最大斜率的条件是“mid点的斜率比前一个大”，如果写反了，会找不到正确的点！


\<conclusion\>
《保护出题人》这道题，是**斜率优化的典型应用**——把游戏规则转化为数学式子，再用凸包和二分快速求解。记住：**复杂的问题，往往可以通过“数学转化+算法技巧”变得简单**！  
下次遇到“求最大值/最小值”的问题，不妨想想：能不能转化为斜率？能不能用凸包维护？  
继续加油，你会越来越厉害的！💪
\</conclusion\>

---

---
处理用时：152.91秒
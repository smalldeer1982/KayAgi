# 题目信息

# [JSOI2007] 合金

## 题目描述

某公司加工一种由铁、铝、锡组成的合金。他们的工作很简单。首先进口一些铁铝锡合金原材料，不同种类的原材料中铁铝锡的比重不同。然后，将每种原材料取出一定量，经过融解、混合，得到新的合金。新的合金的铁铝锡比重为用户所需要的比重。 

现在，用户给出了 $n$ 种他们需要的合金，以及每种合金中铁铝锡的比重。公司希望能够订购最少种类的原材料，并且使用这些原材料可以加工出用户需要的所有种类的合金。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，满足 $1\le m,n\le 500$，$0 \leq a_i,b_i,c_i,d_i,e_i,f_i \leq 1$，且 $a_i+b_i+c_i=1$，$d_i+e_i+f_i=1$，小数点后最多有六位数字。

## 样例 #1

### 输入

```
10 10
0.1 0.2 0.7
0.2 0.3 0.5
0.3 0.4 0.3
0.4 0.5 0.1
0.5 0.1 0.4
0.6 0.2 0.2
0.7 0.3 0
0.8 0.1 0.1
0.9 0.1 0
1 0 0
0.1 0.2 0.7
0.2 0.3 0.5
0.3 0.4 0.3
0.4 0.5 0.1
0.5 0.1 0.4
0.6 0.2 0.2
0.7 0.3 0
0.8 0.1 0.1
0.9 0.1 0
1 0 0```

### 输出

```
5```

# AI分析结果

# 💡 Kay的C++算法解析：[JSOI2007]合金 深入学习指南 💡

<introduction>
  今天我们来一起分析经典的「合金问题」！这道题曾经难倒过不少选手，但只要抓住「几何转化+图论最小环」的核心，就能轻松破解。跟着Kay一步步来，你会发现它其实像「用最少篱笆围起所有小动物」一样有趣～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：计算几何（凸包判断）+ 图论（Floyd最小环）

🗣️ **初步分析**：
> 解决「合金问题」的关键，在于把**三维比重转化为二维平面点**，再用「凸包」和「最小环」的思路解决。  
> 先讲个小比喻：三个小朋友分1块蛋糕（铁+铝+锡=1），如果知道小明分了0.3，小红分了0.2，那小刚一定分0.5——所以**第三维根本不用管**！我们可以把每个合金的「铁占比」当x坐标，「铝占比」当y坐标，直接扔到二维平面上～  
> 接下来，问题变成：选最少的原材料点（平面上的点），围成一个**凸包**，把所有需要的合金点（用户要的点）都包在里面。为什么是凸包？因为凸包是「围起所有点的最小周长多边形」——就像用最少的篱笆围花园，凸的篱笆比凹的更省材料！  
> 那怎么找这样的凸包？我们可以把每个原材料点当作图的节点，如果两个点之间的**有向边**能「挡住所有需要的点」（所有需要的点都在边的一侧或线段上），就给这两个节点连一条权为1的边。最后，找图中的**最小环**——这个环就是我们要的凸包，环的长度就是最少需要的原材料种类！  
> 可视化设计思路：我们会用「像素探险家围篱笆」的复古游戏风格，把原材料点做成「小房子」，需要的点做成「小动物」。每选一条符合条件的边（篱笆），就会有「叮」的音效；当围成最小环时，所有小动物会跳起来，播放胜利音乐～

---

## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、算法有效性」三个维度筛选了3份超棒的题解，帮你快速get核心！
</eval_intro>

**题解一：(来源：FutaRimeWoawaSete)**
* **点评**：这份题解的思路像「剥洋葱」一样层层递进——先点出三维转二维的关键，再讲凸包的性质，最后用Floyd求最小环。代码结构超工整：输入处理时把三维转二维，建图时用叉积判断边的合法性，最后Floyd找最小环。特别是**`aside`函数**（判断点是否在边的一侧或线段上）写得很严谨，连「共线时点是否在线段上」都考虑到了！新手可以直接抄这份代码的框架，绝对不会踩坑～

**题解二：(来源：s_r_f)**
* **点评**：此题解的亮点是**处理重复点**！比如用`unique`函数去掉重复的原材料点和需要的点，避免了不必要的计算。另外，代码里的`left`函数（判断点是否在边的左侧）用叉积实现，逻辑简洁。最后还特判了「答案为1或2」的情况，非常严谨——比如当所有需要的点都和某个原材料点重合时，直接输出1！

**题解三：(来源：whhsteven)**
* **点评**：这份题解的「理论推导」超详细！不仅证明了「合成的点一定在凸包内」（充分性），还证明了「凸包内的点一定能合成」（必要性）。代码里用`namespace`封装了所有逻辑，变量名也很清晰（比如`mt`代表原材料，`pd`代表需要的合金）。即使你是第一次接触凸包，看完这份题解也能明白「为什么要这么做」！

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的「坑」主要在三个地方，但只要抓住关键策略，就能轻松跳过～
</difficulty_intro>

1.  **关键点1：为什么能把三维转二维？**
    * **分析**：因为题目中所有合金的「铁+铝+锡=1」——就像三个数加起来等于1，知道前两个就能算出第三个！比如原材料的比重是(a,b,c)，那c=1-a-b，所以我们只需要用(a,b)代表这个原材料就行。这样三维问题就变成了二维平面问题，复杂度直接下降！
    * 💡 **学习笔记**：遇到「三个变量和为定值」的问题，优先考虑降维！

2.  **关键点2：如何判断一条边能作为凸包的边？**
    * **分析**：凸包的边必须满足「所有需要的点都在边的一侧，或在线段上」。我们用**叉积**判断点的方向：比如边是从点A到点B，取向量AB和向量AP（P是需要的点），叉积的正负代表P在AB的左侧或右侧。如果所有P的叉积都≤0（或≥0），说明都在一侧；如果叉积为0（共线），还要用**点积**判断P是否在线段AB上（比如P的x坐标在A和B之间，y坐标也在A和B之间）。
    * 💡 **学习笔记**：叉积是判断「点在边哪一侧」的神器，点积是判断「共线点是否在线段上」的法宝！

3.  **关键点3：为什么用Floyd求最小环？**
    * **分析**：凸包是一个「环」（起点和终点重合），我们需要找最短的环——这正是Floyd算法的拿手好戏！Floyd能计算任意两点之间的最短路径，然后每个点到自己的最短路径就是以该点为起点的最小环。最后取所有点的最小环长度，就是答案～
    * 💡 **学习笔记**：遇到「找最小环」的问题，先想Floyd！

### ✨ 解题技巧总结
<summary_best_practices>
给大家总结3个「通用技巧」，以后遇到类似问题直接用！
</summary_best_practices>
-   **降维打击**：遇到三维问题，先看有没有「变量和为定值」的条件，有的话直接降成二维！
-   **几何转图论**：把几何中的「边合法性」转化为图中的「边权」，用图论算法解决几何问题～
-   **严谨性优先**：处理浮点数时一定要用`eps`（比如1e-7）判断相等，否则会因为精度问题出错！

---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份「综合版核心代码」，它整合了优质题解的精华，逻辑清晰，适合新手模仿～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了FutaRimeWoawaSete和whhsteven的思路，保留了最核心的逻辑，去掉了冗余部分。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    #include <algorithm>
    using namespace std;

    const int MAXN = 505;
    const int INF = 1e9;
    const double eps = 1e-7;

    struct Point {
        double x, y;
        Point() : x(0), y(0) {}
        Point(double x_, double y_) : x(x_), y(y_) {}
        Point operator-(const Point& other) const {
            return Point(x - other.x, y - other.y);
        }
        double operator^(const Point& other) const { // 叉积
            return x * other.y - y * other.x;
        }
    };

    int m, n; // m是原材料数量，n是需要的合金数量
    Point mat[MAXN], prod[MAXN]; // mat是原材料点，prod是需要的合金点
    int dist[MAXN][MAXN]; // 图的邻接矩阵

    // 判断点p是否在边ab的一侧或线段上
    bool is_valid(const Point& a, const Point& b, const Point& p) {
        double cross = (b - a) ^ (p - a);
        if (cross > eps) return false; // p在ab右侧，不合法
        if (fabs(cross) < eps) { // 共线，判断是否在线段上
            double min_x = min(a.x, b.x), max_x = max(a.x, b.x);
            double min_y = min(a.y, b.y), max_y = max(a.y, b.y);
            return (p.x >= min_x - eps && p.x <= max_x + eps) &&
                   (p.y >= min_y - eps && p.y <= max_y + eps);
        }
        return true;
    }

    int main() {
        cin >> m >> n;
        // 输入原材料（忽略第三维）
        for (int i = 1; i <= m; ++i) {
            double a, b, c;
            cin >> a >> b >> c;
            mat[i] = Point(a, b);
        }
        // 输入需要的合金（忽略第三维）
        for (int i = 1; i <= n; ++i) {
            double d, e, f;
            cin >> d >> e >> f;
            prod[i] = Point(d, e);
        }

        // 初始化邻接矩阵：所有边初始化为INF
        memset(dist, 0x3f, sizeof(dist));
        for (int i = 1; i <= m; ++i) {
            for (int j = 1; j <= m; ++j) {
                if (i == j) continue;
                // 判断边i->j是否合法（所有prod点都满足is_valid）
                bool valid = true;
                for (int k = 1; k <= n; ++k) {
                    if (!is_valid(mat[i], mat[j], prod[k])) {
                        valid = false;
                        break;
                    }
                }
                if (valid) dist[i][j] = 1;
            }
        }

        // Floyd求最小环
        int ans = INF;
        for (int k = 1; k <= m; ++k) {
            for (int i = 1; i <= m; ++i) {
                for (int j = 1; j <= m; ++j) {
                    dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }

        // 找所有点的最小环（i->i的最短路径）
        for (int i = 1; i <= m; ++i) {
            ans = min(ans, dist[i][i]);
        }

        if (ans > m) cout << -1 << endl;
        else cout << ans << endl;

        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分四步：1. 输入处理（把三维转二维）；2. 建图（判断每对边是否合法，合法则连权1的边）；3. Floyd算法求所有点对的最短路径；4. 找最小环（每个点到自己的最短路径）。核心是`is_valid`函数——用叉积判断方向，用坐标范围判断共线点是否在线段上。

---
<code_intro_selected>
接下来剖析「优质题解的核心片段」，看看高手是怎么写关键逻辑的～
</code_intro_selected>

**题解一：(来源：FutaRimeWoawaSete)**
* **亮点**：`aside`函数把「方向判断」和「共线判断」写得超简洁！
* **核心代码片段**：
    ```cpp
    int aside(point a, point b, point c) {
        double mul = (b - a) ^ (c - a);
        if (mul > 0) return 1; // c在ab右侧，不合法
        if (mul < 0) return 0; // c在ab左侧，合法
        // 共线时，判断c是否在线段ab上
        double minx = min(a.x, b.x), maxx = max(a.x, b.x);
        double miny = min(a.y, b.y), maxy = max(a.y, b.y);
        return (minx <= c.x) && (c.x <= maxx) && (miny <= c.y) && (c.y <= maxy);
    }
    ```
* **代码解读**：
    > 这个函数返回1表示「不合法」，0或线段上表示「合法」。首先用叉积`mul`判断方向：如果`mul>0`，说明c在ab右侧，直接返回1（不合法）；如果`mul<0`，说明在左侧，返回0（合法）；如果`mul=0`（共线），就判断c的x、y是否在a和b的范围内——在的话就是合法的线段上点！
* 💡 **学习笔记**：用「返回值」直接表示合法性，代码更简洁！

**题解二：(来源：s_r_f)**
* **亮点**：用`unique`处理重复点，减少计算量！
* **核心代码片段**：
    ```cpp
    sort(a+1, a+n+1); // 先排序
    n = unique(a+1, a+n+1) - (a+1); // 去重
    sort(b+1, b+m+1);
    m = unique(b+1, b+m+1) - (b+1);
    ```
* **代码解读**：
    > `unique`函数能把重复的元素移到数组末尾，返回新的末尾指针。比如`a`数组是原材料点，排序后重复的点会挨在一起，`unique`后`n`就变成了不重复的原材料数量。这样可以避免处理重复的点，减少建图时的循环次数～
* 💡 **学习笔记**：处理大量点时，先去重能大大提高效率！

**题解三：(来源：whhsteven)**
* **亮点**：用`namespace`封装代码，逻辑更清晰！
* **核心代码片段**：
    ```cpp
    namespace acah {
        const int maxn = 507;
        struct vec {
            double x, y;
            vec(double _x, double _y) : x(_x), y(_y) {}
            vec operator-(const vec& b) const { return vec(x - b.x, y - b.y); }
            double operator*(const vec& b) const { return x*b.y - y*b.x; }
        };
        int N, M, ans;
        int d[maxn][maxn];
        int work() {
            // 输入、建图、Floyd...
        }
    }
    int main() { return acah::work(); }
    ```
* **代码解读**：
    > 把所有变量和函数放在`namespace acah`里，避免和其他代码冲突。比如`maxn`、`vec`结构体、`d`数组都属于`acah`，这样即使其他地方有同名变量，也不会混淆。这是竞赛中的常用技巧！
* 💡 **学习笔记**：用`namespace`封装代码，是专业选手的好习惯！

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你「亲眼看到」算法怎么跑，Kay设计了一个「像素探险家围篱笆」的复古游戏！风格像FC红白机，操作超简单～
</visualization_intro>

  * **动画演示主题**：《合金小园丁》——你是一个小园丁，需要用最少的「篱笆桩」（原材料点）围起所有「小花」（需要的合金点），围成凸包就能通关！

  * **核心演示内容**：
    1. **初始场景**：8位像素风格的二维平面，原材料点是「棕色小房子」（带编号），需要的点是「彩色小花」（红、蓝、黄）。屏幕下方有「开始」「单步」「重置」按钮，还有速度滑块。
    2. **建图过程**：点击「开始」，动画会逐个检查每对「小房子」之间的边（用「灰色篱笆」表示）。如果这条边能挡住所有小花（所有小花在一侧或线段上），篱笆会变成「绿色」（合法）；否则保持灰色（不合法）。每检查一条边，会有「滴」的音效～
    3. **Floyd求环**：绿色篱笆出现后，动画会用「黄色箭头」演示Floyd的路径更新（比如从房子1→房子3→房子2，比直接1→2更短）。每更新一条路径，箭头会闪烁一次。
    4. **最小环出现**：当找到最小环时，环上的篱笆会变成「金色」，所有小花会跳起来，播放「叮—叮—」的胜利音效！屏幕中间弹出「通关！最少需要X个篱笆桩～」的提示。

  * **设计思路**：
    - **像素风格**：用FC游戏的8位色（比如棕色=房子，绿色=合法边，金色=环），让你想起小时候玩的《超级玛丽》，更有亲切感～
    - **音效反馈**：合法边用「滴」，路径更新用「啪」，胜利用「叮」——用声音强化你的记忆，下次遇到类似问题，耳边会自动响起「叮」的声音！
    - **交互设计**：「单步」按钮让你慢慢看每一步，「速度滑块」可以调整动画速度（从「龟速」到「光速」），适合不同学习节奏的同学～

  * **关键帧示例**：
    - 帧1：初始场景，5个房子，3朵小花。
    - 帧2：检查房子1→房子2的边，所有小花在左侧，篱笆变绿，「滴」一声。
    - 帧3：检查房子2→房子3的边，合法，篱笆变绿。
    - 帧4：Floyd更新房子1→房子3的路径（1→2→3，长度2）。
    - 帧5：找到最小环（1→2→3→1），篱笆变金，小花跳跃，胜利音效！

<visualization_conclusion>
通过这个动画，你能「看得到」三维转二维、凸包边判断、Floyd求环的全过程——就像玩游戏一样，轻松记住复杂的算法！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了「凸包+最小环」的思路，我们可以解决很多类似问题！比如「围起所有点的最小多边形」「找图中的最短环路」～
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - **场景1**：用最少的摄像头监控所有街道——摄像头要放在凸包的顶点上，才能覆盖所有区域。
    - **场景2**：找最短的循环路线，经过所有景点——这就是图论中的最小环问题。
    - **场景3**：用最少的柱子支撑一个帐篷——柱子要放在凸包的顶点上，才能最稳！

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P2742** - 《[USACO5.1]圈奶牛Fencing the Cows》
          * 🗣️ **推荐理由**：这是凸包的经典题！要求用最少的篱笆围起所有奶牛，直接练手凸包算法～
    2.  **洛谷 P3199** - 《[HNOI2009]最小圈》
          * 🗣️ **推荐理由**：这是最小环的进阶题！需要用SPFA算法找最小圈，比Floyd更高效，适合拓展思路～
    3.  **洛谷 P4049** - 《[JSOI2007]合金》（原题）
          * 🗣️ **推荐理由**：再做一遍原题，巩固「凸包+最小环」的思路，保证你不会忘！
    4.  **洛谷 P1115** - 《最大子段和》（拓展）
          * 🗣️ **推荐理由**：虽然不是几何题，但用到了「动态规划找最优解」的思路，和本题的「找最小环」异曲同工～

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解里的「踩坑经验」比正确代码更宝贵！我们来看看高手们的教训～
</insights_intro>

> **参考经验 (来自 FutaRimeWoawaSete)**：「我一开始在网络流和DP上绕了很久，后来才想到用几何模型！」
>
> **点评**：这位作者的教训太真实了！很多同学看到「最少」就想到DP或网络流，但其实**先看问题的几何本质**更重要。比如本题的「最少原材料」其实是「最小凸包」，和网络流完全不沾边～
>
> **参考经验 (来自 s_r_f)**：「处理浮点数时一定要用eps！我之前没加eps，结果因为精度问题WA了三次～」
>
> **点评**：浮点数的精度问题是竞赛中的「隐形杀手」！比如0.1在计算机里是近似值，直接比较`a == b`会出错，必须用`fabs(a - b) < eps`判断～

---

<conclusion>
本次「合金问题」的分析就到这里啦！记住：**降维转化是关键，凸包判断用叉积，最小环找Floyd**。下次遇到几何+图论的问题，你肯定能一秒反应过来～  
编程就像搭积木，只要把每个知识点吃透，再难的题也能拼成漂亮的作品！加油，你一定能行～💪
</conclusion>

---
处理用时：136.08秒
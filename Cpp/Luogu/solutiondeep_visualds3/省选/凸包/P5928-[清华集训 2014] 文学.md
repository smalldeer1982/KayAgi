# 题目信息

# [清华集训 2014] 文学

## 题目描述

巨酱和主席是一对好朋友。他们都很喜欢读书，经常一起阅读相关领域书籍，进行系统的学习。一天主席列出了一份列表，里面共 $p$ 本书，其中不乏《约翰克里斯多夫》，《名人传》等名著。作为一名在文学上有很高修养的知名青年，巨酱打算用尽量少的时间把这份列表中的所有书籍都读完。

作为一名文化人，巨酱阅读书籍的方式也与一般人不同。他使用一种叫做“批量阅读”的阅读方式。首先他根据自己的喜好，对每本书给出了个参数 $x,y$，其中 $i$ 本书的两个参数为 $x_i,y_i$。当然，由于巨酱独特的口味，可能有两本不同的书，它们的 $x,y$ 参数均相同。而每次阅读的时候，他会设置三个系数 $a, b, c$，所有满足 $a \times x+b \times y \leq c$ 的书籍都可以通过这次“批量阅读”读完，这次批量阅读总共需要 $w$ 的时间。
现在，巨酱有 $n$ 种 “批量阅读”的方案，第 $i$ 种“批量阅读”三个参数为 $a_i,b_i,c_i$，需要的时间为 $w_i$。现在巨酱打算从这 $n$ 种“批量阅读”中选出若干，使得巨酱可以用尽量少的时间读完所有的书。现在我们想知道，巨酱最少用多少时间？

## 说明/提示

对于 $100\%$ 的测试数据，$1 \leq n,p \leq 100，−10^6 \leq a_i,b_i,c_i,x_i,y_i \leq 10^6， 0 \lt w_i \leq 10^6$，且保证对于任何一种“批量阅读”方案，其 $a_i$ 与 $b_i$ 不会同时为 $0$。且不存在 $i, j$（$i$ 不等于 $j$）使得 $a_i \times b_j=a_j \times b_i$。

## 样例 #1

### 输入

```
4 3
-1 0 0 10
-1 -1 -1 2
-1 1 -1 2
-1 -2 -1 1
0 2
0 -2
1 0```

### 输出

```
3```

# AI分析结果

# 💡 Kay的C++算法解析：[清华集训2014]文学 深入学习指南 💡


今天我们来一起分析“[清华集训2014]文学”这道C++编程题。这道题结合了**几何性质**和**动态规划**，需要我们用“数学眼光”拆解问题，再用“编程工具”解决。本指南会帮你梳理思路、理解核心算法，并掌握解题技巧～


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）结合几何凸包性质  

🗣️ **初步分析**：  
解决这道题的关键，是把“半平面覆盖点集”的几何问题，转化为**可动态规划的序列问题**。打个比方：假设所有点是散落在纸上的“星星”，半平面是“手电筒光束”——我们要选几束光，刚好照亮所有星星，且总电费最少。  

但几何问题的“突破口”在哪里？  
题解告诉我们：**未被覆盖的点会形成凸包**（像一个“凸多边形外壳”）。而用“扫描线”从左到右扫过凸包时，**任何时刻只有两个半平面在限制凸包的上下边界**（比如左边的点由半平面A“兜住”，右边的点由半平面B“兜住”）。  

基于这个性质，我们可以用**动态规划**跟踪扫描过程：  
- 状态`dp[i][j][k]`：扫描到第`i`个点（按横坐标排序），当前限制凸包的半平面是`j`和`k`（`j<k`）时的最小费用。  
- 核心逻辑：每处理一个点，要么当前的`j`/`k`已经覆盖它（费用不变），要么新增一个半平面`l`覆盖它（更新状态并增加费用）。  

**可视化设计思路**：  
我们会用**8位像素风格**（像FC游戏）展示扫描线移动：  
- 点用彩色像素块表示，半平面用不同颜色的“光束”（带方向的像素条）表示；  
- 扫描线是一条红色竖线，从左到右移动，每到一个点就“暂停”，高亮当前处理的点；  
- DP状态更新时，用“闪烁”或“滑入”动画展示新的半平面组合，伴随“叮”的像素音效；  
- 自动演示模式会像“AI探险家”一样，一步步扫过所有点，最终显示最优的半平面组合。  


## 2. 精选优质题解参考

为了帮你快速掌握核心思路，我筛选了**最严谨、最具代表性**的正解题解：


### 题解一：Larryyu的O(n⁴)动态规划（5星）  
* **点评**：  
  这份题解是**确定性正解**（不是随机乱搞），思路像“剥洋葱”一样层层递进：  
  1. **几何观察**：先发现“未覆盖点形成凸包”“扫描线只需跟踪两个半平面”，这是整个算法的基石；  
  2. **状态定义**：`dp[i][j][k]`精准捕捉了“当前扫描进度+当前限制半平面”的核心信息，避免了冗余状态；  
  3. **转移逻辑**：分“当前半平面已覆盖”和“新增半平面覆盖”两种情况，覆盖了所有可能，且通过`j<k`的钦定避免重复计算；  
  4. **代码规范**：变量名（如`check`函数、`dp`数组）含义明确，排序、初始化、转移的结构清晰，甚至处理了“无解”的边界情况。  

  最值得学习的是**“几何性质→DP模型”的转化能力**——把抽象的几何问题，变成了可编码的“序列决策问题”。


## 3. 核心难点辨析与解题策略

在解决这道题时，大家最容易卡壳的3个关键点，我帮你提炼好了应对策略：


### 1. 关键点1：如何把几何问题“翻译”成编程问题？  
* **分析**：  
  题目的难点在于“半平面覆盖”是几何概念，但编程只能处理“数值和逻辑”。题解的关键突破是**发现凸包性质**——未被覆盖的点一定围成凸包，而扫描线只需跟踪两个半平面。这一步需要你“画几个例子”（比如纸上画3个点和2个半平面），才能直观理解。  
* 💡 **学习笔记**：几何题的核心是“找规律”，把图形的性质转化为“数字的规律”。


### 2. 关键点2：DP状态怎么定义才合理？  
* **分析**：  
  状态`dp[i][j][k]`的3个维度分别对应“扫描进度”“上边界半平面”“下边界半平面”。这样定义的好处是：  
  - 用`i`跟踪“已经处理了多少点”，保证顺序性；  
  - 用`j`和`k`跟踪“当前限制凸包的半平面”，确保覆盖后续点的可能性。  
  初期可能会想“要不要加更多维度？”，但题解证明“两个半平面就够了”——这是几何性质带来的“状态压缩”。  
* 💡 **学习笔记**：DP状态要“刚好覆盖核心信息”，不要冗余也不要遗漏。


### 3. 关键点3：转移方程怎么推导？  
* **分析**：  
  转移方程分两种情况：  
  - 情况1：当前点已经被`j`或`k`覆盖→费用不变，直接继承`dp[i-1][j][k]`；  
  - 情况2：当前点没被覆盖→需要新增一个半平面`l`，此时新的状态是`dp[i][min(l,j)][max(l,j)]`或`dp[i][min(l,k)][max(l,k)]`（保持`j<k`避免重复），费用增加`w[l]`。  
  这一步的关键是“枚举所有可能的新增半平面”，并通过`min/max`保证状态的唯一性。  
* 💡 **学习笔记**：转移方程要“覆盖所有可能的决策”，并通过“排序/去重”减少计算量。


### ✨ 解题技巧总结  
- **技巧1：几何性质优先**：遇到几何题，先画例子找规律（比如凸包、对称性），再转化为编程模型；  
- **技巧2：状态定义要“精准”**：用最少的维度捕捉问题的核心信息（比如本题的“扫描进度+两个半平面”）；  
- **技巧3：边界条件要严谨**：比如初始化`dp[0][j][k]`为`w[j]+w[k]`（初始选两个半平面），最后取`dp[p][j][k]`的最小值。


## 4. C++核心代码实现赏析

先看**通用核心代码**（来自Larryyu的题解，调整后更清晰），再剖析关键片段～


### 本题通用核心C++实现参考  
* **说明**：本代码是Larryyu题解的“精简版”，保留了核心逻辑，去掉了冗余注释，适合快速理解框架。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

typedef long long ll;
const ll INF = 1e18;

int n, p;
ll a[110], b[110], c[110], w[110];
ll dp[110][110][110]; // dp[i][j][k]：第i个点，上下半平面j、k

struct Point { ll x, y; };
Point pts[110];

// 检查点i是否被半平面y覆盖
bool check(int pt_idx, int plane_idx) {
    return a[plane_idx] * pts[pt_idx].x + b[plane_idx] * pts[pt_idx].y <= c[plane_idx];
}

// 按x坐标排序点
bool cmp(Point a, Point b) { return a.x < b.x; }

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> p;

    // 输入半平面（0号半平面是占位符，w=0）
    a[0] = b[0] = 0; c[0] = -1e9; w[0] = 0;
    for (int i = 1; i <= n; ++i) 
        cin >> a[i] >> b[i] >> c[i] >> w[i];

    // 输入点
    for (int i = 1; i <= p; ++i) 
        cin >> pts[i].x >> pts[i].y;
    sort(pts + 1, pts + 1 + p, cmp);

    // 初始化DP数组为INF
    for (int i = 0; i <= p; ++i)
        for (int j = 0; j < n; ++j)
            for (int k = j + 1; k <= n; ++k)
                dp[i][j][k] = INF;

    // 边界：处理0个点时，选j和k两个半平面
    for (int j = 0; j < n; ++j)
        for (int k = j + 1; k <= n; ++k)
            dp[0][j][k] = w[j] + w[k];

    // 动态规划转移
    for (int i = 1; i <= p; ++i) { // 处理第i个点
        for (int j = 0; j < n; ++j) { // 上半平面j
            for (int k = j + 1; k <= n; ++k) { // 下半平面k
                if (dp[i-1][j][k] == INF) continue;

                // 情况1：当前点已被j或k覆盖
                if (check(i, j) || check(i, k)) {
                    dp[i][j][k] = min(dp[i][j][k], dp[i-1][j][k]);
                    continue;
                }

                // 情况2：需要新增半平面l
                for (int l = 1; l <= n; ++l) {
                    if (l == j || l == k || !check(i, l)) continue;
                    int new_j = min(l, j), new_k = max(l, j);
                    dp[i][new_j][new_k] = min(dp[i][new_j][new_k], dp[i-1][j][k] + w[l]);
                    new_j = min(l, k), new_k = max(l, k);
                    dp[i][new_j][new_k] = min(dp[i][new_j][new_k], dp[i-1][j][k] + w[l]);
                }
            }
        }
    }

    // 找最小费用
    ll ans = INF;
    for (int j = 0; j < n; ++j)
        for (int k = j + 1; k <= n; ++k)
            ans = min(ans, dp[p][j][k]);
    cout << (ans == INF ? -1 : ans) << endl;

    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：读入半平面和点，按x坐标排序点（扫描线需要从左到右）；  
  2. **DP初始化**：`dp[0][j][k]`表示初始选两个半平面`j`和`k`的费用；  
  3. **转移循环**：逐个处理点，分“已覆盖”和“新增半平面”两种情况更新DP；  
  4. **结果计算**：取处理完所有点后的最小费用。


### 关键片段赏析（来自题解一）  
* **亮点**：用`check`函数封装半平面覆盖判断，用`min/max`保证状态唯一性。  
* **核心代码片段**：  
```cpp
// 转移循环中的“情况2”
for (int l = 1; l <= n; ++l) {
    if (l == j || l == k || !check(i, l)) continue;
    int new_j = min(l, j), new_k = max(l, j);
    dp[i][new_j][new_k] = min(dp[i][new_j][new_k], dp[i-1][j][k] + w[l]);
    new_j = min(l, k), new_k = max(l, k);
    dp[i][new_j][new_k] = min(dp[i][new_j][new_k], dp[i-1][j][k] + w[l]);
}
```
* **代码解读**：  
  - 首先，`l`是要新增的半平面，必须满足“没被选过”（`l≠j,k`）且“能覆盖当前点”（`check(i,l)`为真）；  
  - 然后，`new_j = min(l,j)`和`new_k = max(l,j)`是为了**保持`j<k`的顺序**——比如`l=3`，`j=2`，则`new_j=2`，`new_k=3`，避免`dp[i][3][2]`和`dp[i][2][3]`重复计算；  
  - 最后，用`min`更新状态，保证取最小费用。  
* 💡 **学习笔记**：用“排序”避免重复状态，是DP中常用的“去重技巧”。


## 5. 算法可视化：像素动画演示 (核心部分)

为了让你“看”到算法的运行过程，我设计了一个**8位像素风格的动画**，主题是“像素探险家扫平凸包”～


### 🎮 动画设计方案  
* **整体风格**：FC红白机风格（4-bit色彩，像素块大小2x2），背景是浅蓝色，点是黄色像素块，半平面是红色/蓝色的“光束”（带箭头表示方向）。  
* **核心演示内容**：  
  1. **初始化**：屏幕显示排序后的点（从左到右排列），扫描线（红色竖线）在最左边；  
  2. **扫描线移动**：扫描线从左到右移动，每到一个点就“暂停”，高亮该点（闪烁黄色）；  
  3. **半平面更新**：  
     - 如果当前半平面`j`/`k`覆盖点，屏幕显示“✅已覆盖”，伴随“嘀”的音效；  
     - 如果需要新增半平面`l`，屏幕会“滑入”一个绿色光束（`l`对应的半平面），并显示“➕新增半平面”，伴随“叮”的音效；  
  4. **DP状态展示**：屏幕右侧用像素数字显示当前`dp[i][j][k]`的值，更新时数字会“跳动”；  
  5. **结束状态**：扫描完所有点后，最优的半平面组合会“闪烁”，并播放“胜利”音效（类似FC游戏通关的“哔——”声）。  


### 🎯 交互设计  
- **控制按钮**：屏幕下方有“单步”（▶️）、“自动”（⏩）、“重置”（🔄）按钮，速度滑块（1x~5x）；  
- **AI演示模式**：点击“自动”后，动画会像“AI玩家”一样自动扫过所有点，不需要手动操作；  
- **信息提示**：屏幕上方有文字气泡（比如“现在处理第3个点，当前半平面是2和5”），帮助理解每一步。  


### 🎵 音效设计  
- **扫描线移动**：轻微的“兹——”声；  
- **半平面覆盖**：“嘀”的短音；  
- **新增半平面**：“叮”的脆音；  
- **胜利**：上扬的“哔——”声；  
- **无解**：短促的“嘟”声。  


## 6. 拓展练习与相似问题思考

掌握了本题的“几何+DP”思路后，可以尝试以下相似问题，巩固技巧：


### 🔍 通用思路迁移  
本题的核心是**“利用几何性质压缩状态空间”**，这种思路还能解决：  
1. **平面点集的最小覆盖圆**：用几何性质（三点确定圆）压缩状态；  
2. **凸多边形的最优三角剖分**：用凸性将问题转化为区间DP；  
3. **半平面交的最小费用覆盖**：类似本题的“扫描线+DP”。


### 📚 洛谷练习推荐  
1. **洛谷 P6900** - 二维平面最大团  
   🗣️ **推荐理由**：同样需要利用几何性质（二维平面的点集性质），训练“几何→编程”的转化能力。  
2. **洛谷 P4158** - 粉刷匠  
   🗣️ **推荐理由**：虽然是“字符串DP”，但状态定义和转移逻辑和本题类似，训练“精准状态设计”。  
3. **洛谷 P3225** - 矿场搭建  
   🗣️ **推荐理由**：需要用“图论性质”压缩状态，训练“找规律→DP”的思维。  


## 7. 学习心得与经验分享 (若有)

Larryyu的题解中提到一个**关键经验**：“一个半平面若不限制凸包，可以直接不选，减少花费。”  
* **点评**：这是几何性质带来的“优化点”——如果一个半平面没有“兜住”凸包的任何边，说明它覆盖的点已经被其他半平面覆盖了，选它只会浪费费用。这个经验提醒我们：**解决几何题时，一定要“盯着图形的边界”——边界往往是问题的核心**。  


## 结语  
本次关于“[清华集训2014]文学”的分析就到这里～ 这道题的难点在于“几何与DP的结合”，但只要你“先画例子找规律，再设计状态写转移”，就能一步步解决。  

记住：编程的本质是“用代码表达思维”，而几何题的本质是“用思维发现图形的规律”。多画、多想、多写，你一定会越来越厉害！💪  

下次我们再一起探索新的编程挑战～

---
处理用时：106.16秒
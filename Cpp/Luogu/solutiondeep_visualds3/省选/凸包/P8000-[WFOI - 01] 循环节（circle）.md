# 题目信息

# [WFOI - 01] 循环节（circle）

## 题目背景

简化题意：[$\texttt{Link}$](https://www.luogu.com.cn/paste/v7gqdh44)。

出题人注：これは非常に嫌な質問なので、あまり時間をかけたくない場合は、この質問を見る前に他の質問を終えることをお勧めします。

## 题目描述

给你一个坐标系上的点集 $a$，你需要找出一个子点集 $b$ 和一个向量 $x$，使得 $\exist\ z\in N^+,\{b\cup b+x\cup b+2x\cup\dots\cup b+zx=a\}$。

现在想让你求出任意一对 $b_0,x_0,z_0$，其中 $z_0$ 为所有满足条件的三元组中 $z$ 最大的，$b_0$ 中任意三点不共线，任意四点不构成梯形或平行四边形且 $b_0\cap b_0+x_0=\varnothing,b_0\cap b_0+2x_0=\varnothing,\dots,b_0\cap b+yx_0=\varnothing|{y\to+\infty}$。

其中 $b+x$ 的意思是，$b$ 中的所有点都平移向量 $x$ 后组成的点集。

## 说明/提示

由于本题有样例解释也只是照着念一遍，并且相信既然您都做到这一题来了应该能读懂题目含义，所以本题不提供样例解释（~~其实是出题人懒~~）。

**本题采用 Subtask 捆绑测试。**
Subtask 编号 | 数据规模与约定
:-: | :-:
**Subtask #0($\text{20 pts}$)** | $1\le n\le10$；$-10\le x_i,y_i \le 10$
**Subtask #1($\text{20 pts}$)** | $1\le n\le10^3$
**Subtask #2($\text{30 pts}$)** | $z>1$
**Subtask #3($\text{30 pts}$)** | 无特殊限制

对于 $100\%$ 的数据，$1\le n\le10^5$，点的坐标范围 $\in\left(-10^9,10^9\right)$，数据保证有解。

## 样例 #1

### 输入

```
4
0 0
0 1
1 0
1 1```

### 输出

```
2
1 3
0 1
1```

## 样例 #2

### 输入

```
3
0 0
0 1
1 0```

### 输出

```
3
1 2 3
0 0
0```

# AI分析结果

# 💡 Kay的C++算法解析：循环节 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：计算几何（凸包 + 旋转卡壳）+ 哈希映射


🗣️ **初步分析**：  
解决“循环节”问题，关键是利用**凸包**和**旋转卡壳**这两个计算几何工具，结合哈希映射快速判断点集关系。  

- **凸包**：可以理解为“用橡皮筋把所有点围起来形成的多边形”，它能帮我们过滤掉内部点，只关注“外围关键节点”——因为题目中的平移向量`x`一定藏在凸包的边上（毕竟平移后的点集不会突破原凸包的边界）。  
- **旋转卡壳**：像“用两根平行的尺子夹住凸包，旋转着滑动”，用来找到凸包上**共线且平行于某条边**的点集——这些点正是`b`平移`x`多次后的结果，能帮我们算出最大的`z`和向量`x`。  

**核心思路**：  
1. 求点集`a`的凸包，缩小搜索范围；  
2. 用旋转卡壳找凸包上的共线点，推导`x`和最大`z`；  
3. 用哈希映射（`map`）快速判断“点`p - x`是否在`a`中”，找到原始点集`b`（因为`b`中的点平移前不存在于`a`）。  

**可视化设计思路**：  
我们会用**8位像素风**模拟凸包构建和旋转卡壳过程——比如用不同颜色的像素块代表“原始点”“凸包顶点”“当前处理的边”；旋转卡壳的两个指针用闪烁的像素箭头标记，共线点用黄色高亮；找到`x`时播放“叮”的音效，计算`b`时用绿色点亮属于`b`的点。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了2份优质题解，帮你快速把握核心逻辑：
</eval_intro>

### 题解一：（作者：€€£）
* **点评**：这份题解用“一句话点破关键”——凸包+旋转卡壳找共线点，思路极其简洁。它抓住了问题的核心性质（`x`在凸包上），直接指向高效解法。虽然细节未展开，但“抓重点”的思维非常值得学习——解决复杂问题时，先找“关键突破口”比纠结细节更重要。


### 题解二：（作者：TonyYin）
* **点评**：这是一份“手把手教学”的题解！它不仅补充了€€£题解的细节，还通过**分类讨论**（共线点的三种情况）、**代码实现**（向量类、凸包函数、旋转卡壳逻辑）把抽象思路变成了可运行的代码。  
  - **思路清晰**：把“求`x`和`z`”拆成“凸包处理→旋转卡壳找共线点→分类验证三种情况”，每一步都有直观的图示辅助；  
  - **代码规范**：用`Point`类封装向量运算（重载`+` `-` `*`等运算符），让几何计算更简洁；`Convex_hull`函数是标准的凸包模板，可读性高；  
  - **实践价值**：针对“所有点共线”的特殊情况做了特判，处理了边界条件（比如`z=0`时的`x`赋值），代码能直接用于竞赛；  
  - **亮点**：用`map<Point, bool>`快速判断点是否存在，解决了“坐标范围大无法用数组哈希”的问题——这是处理大数据量点集的常用技巧！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键是“突破三个难点”，结合优质题解的经验，我帮你整理了应对策略：
</difficulty_intro>

### 1. 难点1：如何确定平移向量`x`的位置？
* **分析**：题目中`a`是`b`平移`z`次得到的，所以`x`对应的“平移方向”一定是凸包的某条边——因为凸包是点集的“外围轮廓”，平移后的点不会超出这个轮廓。  
* **策略**：用凸包算法过滤内部点，只在凸包边上找`x`——这一步把问题规模从`n=1e5`缩小到凸包的大小（通常远小于`n`）。  
* 💡 **学习笔记**：凸包是处理“点集外围特征”的神器，遇到“平移、旋转、缩放”类问题时，先想凸包！


### 2. 难点2：如何从共线点中算出最大的`z`？
* **分析**：凸包上的共线点可能是“单个起点平移多次”或“两个起点分别平移”，需要分类验证。  
* **策略**：  
  - 情况1（单个起点）：检查点是否是`p0 + t*x`（`t`从1到`z`）；  
  - 情况2（两个起点）：检查点是否来自`p0 + t*x`或`p1 + t*x`；  
  - 情况3（特殊间隔）：检查`x`是否是`p0`到`p2`的向量（避免遗漏间隔平移的情况）。  
* 💡 **学习笔记**：分类讨论是解决“多情况问题”的通用方法，关键是要覆盖所有可能的情况！


### 3. 难点3：如何快速找到原始点集`b`？
* **分析**：`b`中的点满足“`p - x`不在`a`中”（因为平移前的点没有“前身”），但坐标范围到`1e9`，无法用数组存储。  
* **策略**：用`map<Point, bool>`存储所有点——`map`的`key`可以是自定义的`Point`类（需重载`<`运算符），查询时间是`O(log n)`，能处理大数据量。  
* 💡 **学习笔记**：当数据范围太大时，用哈希结构（`map`/`unordered_map`）代替数组是常用技巧！


### ✨ 解题技巧总结
1. **几何问题先找凸包**：过滤内部点，缩小问题规模；  
2. **旋转卡壳处理凸包极值**：找共线、平行、最远点对等问题的利器；  
3. **哈希映射处理大数据点集**：用`map`/`unordered_map`存储点，快速查询存在性；  
4. **分类讨论覆盖边界情况**：比如“所有点共线”“z=0”等特殊情况。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合优质题解的核心实现**，帮你把握整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了TonyYin题解的核心逻辑，包含凸包计算、旋转卡壳求`x`和`z`、哈希找`b`的完整流程。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <map>
  using namespace std;

  const int MAXN = 1e5 + 10;
  struct Point {
      int x, y;
      Point() {}
      Point(int a, int b) : x(a), y(b) {}
      friend Point operator-(const Point& a, const Point& b) { return Point(a.x - b.x, a.y - b.y); }
      friend bool operator==(const Point& a, const Point& b) { return a.x == b.x && a.y == b.y; }
      friend bool operator<(const Point& a, const Point& b) { return a.x < b.x || (a.x == b.x && a.y < b.y); }
  };

  Point p_in[MAXN], ch[MAXN];
  int Convex_hull(int n, Point* p, Point* ret) { // 求凸包
      sort(p, p + n);
      int top = -1;
      for (int i = 0; i < n; i++) {
          while (top > 0 && ((ret[top] - ret[top-1]) * (p[i] - ret[top-1])) >= 0) top--;
          ret[++top] = p[i];
      }
      int k = top;
      for (int i = n-2; i >= 0; i--) {
          while (top > k && ((ret[top] - ret[top-1]) * (p[i] - ret[top-1])) >= 0) top--;
          ret[++top] = p[i];
      }
      return top;
  }

  int n, z; Point x_vec;
  vector<int> b;
  void calc_b() { // 找b集合
      map<Point, bool> mp;
      for (int i = 0; i < n; i++) mp[p_in[i]] = true;
      for (int i = 0; i < n; i++) {
          Point p = p_in[i] - x_vec;
          if (!mp.count(p)) b.push_back(i+1); // 输出从1开始
      }
  }

  void calc_xz() { // 求x和z
      bool collinear = true;
      for (int i = 2; i < n; i++) {
          Point v1 = p_in[1] - p_in[0], v2 = p_in[i] - p_in[0];
          if (v1.x * v2.y - v1.y * v2.x != 0) { collinear = false; break; }
      }
      int siz;
      if (collinear) { // 所有点共线
          siz = n;
          for (int i = 0; i < n; i++) ch[i] = p_in[i];
          sort(ch, ch + n);
      } else {
          siz = Convex_hull(n, p_in, ch);
          ch[siz] = ch[0];
      }
      // 旋转卡壳找共线点（简化版，完整逻辑参考TonyYin题解）
      z = 0;
      for (int i = 0; i < siz; i++) {
          Point edge = ch[(i+1)%siz] - ch[i];
          int j = (i+1)%siz, cnt = 0;
          while (true) {
              Point v = ch[(j+1)%siz] - ch[j];
              if (edge.x * v.y - edge.y * v.x != 0) break;
              cnt++; j = (j+1)%siz;
          }
          if (cnt > z) { z = cnt; x_vec = edge; }
      }
  }

  int main() {
      cin >> n;
      for (int i = 0; i < n; i++) cin >> p_in[i].x >> p_in[i].y;
      calc_xz();
      calc_b();
      cout << b.size() << endl;
      for (int num : b) cout << num << " ";
      cout << endl << x_vec.x << " " << x_vec.y << endl << z << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：读取`n`个点存入`p_in`；  
  2. **calc_xz**：先判断是否所有点共线，再求凸包，用旋转卡壳找共线点，算出`x_vec`（平移向量）和最大`z`；  
  3. **calc_b**：用`map`存储所有点，遍历每个点`p`，若`p - x_vec`不在`map`中，则`p`属于`b`；  
  4. **输出**：按题目要求输出`b`的大小、元素、`x_vec`和`z`。


### 针对优质题解的片段赏析

#### 题解二（TonyYin）：向量类与凸包函数
* **亮点**：用`Point`类封装向量运算，让几何计算更直观；凸包函数是标准模板，可读性高。
* **核心代码片段**：
  ```cpp
  struct Point {
      int x, y;
      Point(int a, int b): x(a), y(b) {}
      friend Point operator - (const Point &a, const Point &b) {
          return Point(a.x - b.x, a.y - b.y);
      }
      friend int operator * (const Point &a, const Point &b) { // 叉积
          return a.x * b.y - a.y * b.x;
      }
  };

  int Convex_hull(int n, Point *p, Point *ret) {
      sort(p, p + n);
      int top = -1;
      for (int i = 0; i < n; i++) {
          while (top > 0 && (ret[top] - ret[top-1]) * (p[i] - ret[top-1]) >= 0)
              top--;
          ret[++top] = p[i];
      }
      // 下半部分凸包
      return top;
  }
  ```
* **代码解读**：  
  - `operator-`：计算两个点的向量差（比如`a - b`得到从`b`指向`a`的向量）；  
  - `operator*`：计算叉积——叉积为0表示两向量共线，正数表示逆时针旋转，负数表示顺时针；  
  - `Convex_hull`：先按`x`排序，再用单调栈构建上半部分凸包——当新点导致栈顶的边“向内凹”（叉积≥0）时，弹出栈顶点，保证凸包的凸性。
* 💡 **学习笔记**：向量运算的封装能让代码更简洁，叉积是判断共线、方向的核心工具！


#### 题解二（TonyYin）：用map找b集合
* **亮点**：用`map<Point, bool>`解决“大坐标点的存在性查询”问题。
* **核心代码片段**：
  ```cpp
  vector<int> b;
  void calc_b() {
      map<Point, bool> mp;
      for(int i = 0; i < n; i++) mp[p_in[i]] = 1;
      for(int i = 0; i < n; i++) {
          if(mp.count(p_in[i] - x_vec) == 0) {
              b.push_back(i+1); // 输出从1开始编号
          }
      }
  }
  ```
* **代码解读**：  
  - `mp`存储所有点的存在性；  
  - 遍历每个点`p_in[i]`，计算`p_in[i] - x_vec`（即“平移前的点”）——如果这个点不在`mp`中，说明`p_in[i]`是`b`中的原始点。
* 💡 **学习笔记**：`map`的`count`函数能快速判断键是否存在，是处理“大值键”的好工具！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看到”凸包和旋转卡壳的过程，我设计了一个**8位像素风动画**，灵感来自FC经典游戏《坦克大战》的简洁风格！
</visualization_intro>


### 🎮 动画演示主题：“凸包探险家”找平移向量
我们把问题变成一个“探险游戏”：你是一个像素探险家，要在点集里找到“平移向量x”和“原始点集b”。


### 🎨 设计思路
- **风格**：8位像素风（16色 palette，类似FC游戏），用不同颜色代表不同元素：  
  - 原始点：白色像素块；  
  - 凸包顶点：红色像素块；  
  - 当前处理的凸边：蓝色线条；  
  - 共线点：黄色高亮；  
  - 属于b的点：绿色闪烁。  
- **音效**：  
  - 凸包顶点加入时：“叮”的短音；  
  - 旋转卡壳找到共线点时：“滴”的长音；  
  - 找到b的点时：“啪”的清脆声；  
  - 完成所有步骤：FC风格的胜利音乐（比如《超级玛丽》的通关音效）。


### 🚶 动画帧步骤（以样例1为例）
样例1输入：4个点(0,0),(0,1),(1,0),(1,1)（正方形）。

1. **初始化场景**：  
   屏幕显示4个白色像素点（正方形四个顶点），下方有“开始”“单步”“重置”按钮，速度滑块（默认中等）。背景音乐是FC风格的轻快BGM。

2. **凸包构建过程**：  
   - 按`x`排序后，点顺序是(0,0)→(0,1)→(1,0)→(1,1)；  
   - 逐个加入点：先加(0,0)（红色），再加(0,1)（红色），加(1,0)时，检查叉积（(0,1)-(0,0)）×（(1,0)-(0,0)）= 0×0 -1×1 = -1 < 0，不弹出，加入(1,0)（红色）；加(1,1)时，检查栈顶边（(1,0)-(0,1)）×（(1,1)-(0,1)）= (1,-1)×(1,0) = 0 - (-1) = 1 ≥0，弹出(1,0)，再检查(0,1)-(0,0)×(1,1)-(0,0)= (0,1)×(1,1)=0×1 -1×1=-1 <0，加入(1,1)（红色）。  
   - 每加入一个凸包顶点，播放“叮”声，顶点闪烁红色。

3. **旋转卡壳找共线点**：  
   - 遍历凸包的边：比如边(0,0)→(0,1)（蓝色线条）；  
   - 旋转卡壳的指针`j`从(0,1)开始滑动，找到所有与这条边平行的点——(1,0)和(1,1)所在的边与(0,0)→(0,1)平行吗？计算叉积：(0,1)-(0,0)×(1,0)-(0,1)= (0,1)×(1,-1)=0×(-1) -1×1=-1≠0，不平行；换边(0,0)→(1,0)（蓝色线条），指针`j`滑到(1,1)，发现(1,0)→(1,1)与(0,0)→(1,0)垂直，不平行；直到边(0,1)→(1,1)（蓝色线条），指针`j`滑到(0,0)→(1,0)，发现这两条边平行（叉积为0），共线点有2个，算出`z=1`，`x=(1,0)`（蓝色向量箭头显示）。  
   - 找到共线点时，播放“滴”声，共线点闪烁黄色。

4. **计算b集合**：  
   - 用`map`检查每个点：(0,0)-x=( -1,0)不在点集中→属于b（绿色闪烁）；(0,1)-x=( -1,1)不在→属于b；(1,0)-x=(0,0)在→不属于；(1,1)-x=(0,1)在→不属于。  
   - 每个属于b的点闪烁绿色，播放“啪”声。

5. **胜利结局**：  
   屏幕显示“找到啦！”的像素文字，播放胜利音乐，所有b的点持续绿色闪烁，`x`向量用蓝色箭头循环显示。


### 🎮 交互设计
- **单步执行**：点击“单步”按钮，动画执行一步（比如加入一个凸包顶点、滑动一次指针）；  
- **自动播放**：拖动速度滑块调整播放速度（慢→快），动画自动执行所有步骤；  
- **重置**：点击“重置”按钮，回到初始状态，重新开始。


<visualization_conclusion>
通过这个动画，你能清晰看到“凸包如何围起点集”“旋转卡壳如何找共线点”“b的点如何被筛选出来”——就像玩游戏一样，把抽象的算法变成了直观的操作！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心技巧（凸包、旋转卡壳、哈希映射）能解决很多计算几何问题，比如：
</similar_problems_intro>


### 🌍 通用思路迁移
1. **凸包**：用于“点集的外围特征”问题（比如求点集的最小包围矩形、最远点对）；  
2. **旋转卡壳**：用于“凸多边形上的极值问题”（比如求凸多边形的直径、面积最大的内接三角形）；  
3. **哈希映射**：用于“大坐标点的存在性查询”（比如判断点是否在某集合中、统计点的出现次数）。


### 📚 洛谷练习推荐
1. **洛谷 P2742** - 【模板】二维凸包  
   🗣️ **推荐理由**：这是凸包的基础模板题，帮你巩固“单调栈构建凸包”的代码逻辑。  
2. **洛谷 P1452** - 旋转卡壳求凸多边形直径  
   🗣️ **推荐理由**：旋转卡壳的经典应用，让你熟悉“用两根平行边找最远点对”的思路。  
3. **洛谷 P3829** - 点的存在性查询  
   🗣️ **推荐理由**：用哈希映射处理大坐标点的查询，和本题“找b集合”的思路一致。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
TonyYin在题解中分享了“处理共线点”的经验，非常值得借鉴：
</insights_intro>

> **参考经验 (来自 TonyYin)**：“我在最初处理共线点时，只考虑了‘单个起点’的情况，结果卡在了样例2（3个共线点）。后来通过分类讨论三种情况，才覆盖了所有可能。”  
> **点评**：这位作者的踩坑经历提醒我们——**复杂问题一定要分类讨论**！比如共线点可能有“单个起点”“两个起点”“特殊间隔”三种情况，漏掉任何一种都会出错。下次遇到“多情况问题”时，不妨先列出所有可能的情况，再逐一验证。


## 💪 总结
本次分析的“循环节”问题，核心是用**凸包+旋转卡壳**缩小搜索范围，用**哈希映射**快速查询点集关系。通过动画演示，你能直观看到算法的每一步；通过代码赏析，你能学会如何把思路变成可运行的代码。  

记住：计算几何问题的关键是“抓住几何性质”（比如平移向量在凸包上），再用对应的算法工具（凸包、旋转卡壳）解决。多练习模板题，多思考“为什么用这个算法”，你会越来越熟练！  

下次我们再一起探索新的编程挑战吧！🚀

---
处理用时：121.51秒
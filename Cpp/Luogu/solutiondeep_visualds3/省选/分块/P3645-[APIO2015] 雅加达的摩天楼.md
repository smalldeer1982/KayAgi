# 题目信息

# [APIO2015] 雅加达的摩天楼

## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。


## 说明/提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$


## 样例 #1

### 输入

```
5 3
0 2
1 1
4 1```

### 输出

```
5```

# AI分析结果


```markdown
# 💡 Kay的C++算法解析：雅加达的摩天楼 深入学习指南 💡

<introduction>
今天我们来分析「雅加达的摩天楼」这道C++编程题。这道题要求计算doge传递消息的最少跳跃步数，涉及图论中的分层图与分块优化技巧。本指南将逐步解析核心算法、精选题解实现，并设计像素动画帮助直观理解。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（分层图与分块优化）`

🗣️ **初步分析**：
> 本题本质是**无权图最短路问题**，核心挑战在于避免O(n²)的显式建图。通过**分块优化**，将doge跳跃能力分为两类：
> - **小跳**（p ≤ √n）：建立分层图，每层对应跳跃能力p，层内相邻点连边权为1
> - **大跳**（p > √n）：直接从起点连向可达点，边权为步数
> 
> 这样将空间复杂度优化到O(n√n)。在可视化设计中：
> - 用不同颜色像素块表示分层图各层
> - 高亮当前处理的doge位置和跳跃路径
> - 加入"入队音效"和"跳跃成功音效"
> - 自动演示模式展示BFS的层次扩展过程

---

## 2. 精选优质题解参考

<eval_intro>
基于思路清晰性、代码规范性和算法优化度，精选以下≥4星题解：
</eval_intro>

**题解一（浮尘ii）**
* **点评**：
  思路清晰直击要害——直接BFS+分块优化。状态设计`(位置, 跳跃能力)`简洁有效，通过数学证明状态数O(n√n)。代码亮点：
  - 使用`bitset`高效判重（优于`set`防TLE）
  - `insert()`函数封装状态入队逻辑
  - 严格处理边界条件
  实践价值高，可直接用于竞赛，空间复杂度控制优异。

**题解二（StudyingFather）**
* **点评**：
  采用分层图+分块优化的经典解法。亮点在于：
  - 给出分块大小k=√(n/3)的严谨证明
  - 显式建图结构清晰（虚点ID设计巧妙）
  - 代码模块化（分离建图和最短路）
  虽然空间消耗较大，但算法正确性证明深入，具有教学价值。

**题解三（GoldenPotato137）**
* **点评**：
  图文并茂解释分层图原理，可视化辅助理解。亮点：
  - 用像素图展示分层图结构（教学友好）
  - 分块阈值取min(100,√n)平衡性能
  - SPFA实现避免Dijkstra的log开销
  实践性较强，但变量命名可读性有待提升。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大核心难点：
</difficulty_intro>

1.  **状态爆炸问题**
    * **分析**：直接存储(位置, 跳跃能力)状态需O(n²)空间。优质解法通过分块优化：对p≤√n建分层图（空间O(n√n)），对p>√n直接连边（边数≤√n）
    * 💡 **学习笔记**：分块思想是平衡时空复杂度的利器

2.  **动态状态转移**
    * **分析**：BFS扩展需同时处理位置移动和doge能力切换。解法通过：
      - 首次到达位置时激活该点所有doge
      - 跳跃时保留当前doge能力
    * 💡 **学习笔记**：状态设计需包含位置+能力双维度

3.  **高效状态判重**
    * **分析**：`bitset<maxN> vis[maxN]`实现二维判重，比`set`快O(log n)。原理：
      - `vis[i][p]`标记位置i能力p是否访问
      - 每个位置i的bitset仅需存√n大小
    * 💡 **学习笔记**：bitset是稠密状态判重的首选

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧1：分块优化** - 对问题参数√n分治处理
- **技巧2：分层建图** - 为小跳跃能力建虚点层
- **技巧3：惰性扩展** - 首次到达位置时激活doge
- **技巧4：状态压缩** - 用bitset替代哈希表降常数
---

## 4. C++核心代码实现赏析

<code_intro_overall>
通用BFS+分块实现框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合浮尘ii和StudyingFather思路的精简实现
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=30000, BLK=100;
vector<int> doge[N];      // 各位置的doge能力值
bitset<BLK> vis[N];       // 二维状态判重
bool activated[N];        // 位置激活标记

int main() {
    int n,m, S,T;
    cin >> n >> m;
    for(int i=0,b,p;i<m;i++){
        cin >> b >> p;
        doge[b].push_back(p);
        if(i==0) S=b; 
        if(i==1) T=b;
    }

    queue<tuple<int,int,int>> q; // (位置, 能力, 步数)
    activated[S]=true;
    for(int p : doge[S]) 
        q.push({S, p, 0});

    while(!q.empty()){
        auto [u,p,step] = q.front(); q.pop();
        if(u == T) return cout<<step,0;
        
        // 小跳：通过分层图预连边
        if(p <= BLK) {
            if(u-p>=0 && !vis[u-p][p]) 
                vis[u-p].set(p), q.push({u-p,p,step+1});
            if(u+p<n && !vis[u+p][p]) 
                vis[u+p].set(p), q.push({u+p,p,step+1});
        } 
        // 大跳：直接扩展
        else {
            for(int v=u-p; v>=0; v-=p)
                if(!vis[v][0]) vis[v].set(0), q.push({v,p,step+1});
            for(int v=u+p; v<n; v+=p)
                if(!vis[v][0]) vis[v].set(0), q.push({v,p,step+1});
        }
        
        // 激活新位置的doge
        if(!activated[u]){
            activated[u]=true;
            for(int np : doge[u])
                if(np<=BLK ? !vis[u][np] : !vis[u][0])
                    q.push({u, np, step});
        }
    }
    cout<<"-1";
}
```
* **代码解读概要**：
  - **初始化**：存储各位置doge的跳跃能力
  - **BFS准备**：激活起点所有doge入队
  - **状态扩展**：
    * 小跳直接检查相邻虚点
    * 大跳循环扩展可达位置
  - **位置激活**：首次到达位置时激活该点doge

---
<code_intro_selected>
优质题解核心片段赏析：
</code_intro_selected>

**题解一（浮尘ii）**
* **亮点**：bitset高效判重 + 分块数学证明
* **核心代码片段**：
```cpp
void insert(int i, int p, int step) {
    if(!Vis[i]) { // 首次到达位置i
        Vis[i]=true;
        for(auto x:Doge[i]) // 激活所有doge
            if(!vis[i].test(x)) 
                vis[i].set(x), Q.emplace(i,x,step);
    }
    if(!vis[i].test(p)) // 扩展新状态
        vis[i].set(p), Q.emplace(i,p,step);
}
```
* **代码解读**：
  > `insert`函数实现状态入队双重逻辑：
  > 1. 当首次到达位置`i`时（`!Vis[i]`），激活该点所有doge入队
  > 2. 无论是否首次到达，都尝试扩展当前状态`(i,p)`
  > 使用`bitset`的`test/set`实现O(1)状态检查

**题解二（StudyingFather）**
* **亮点**：分层图显式建图 + 分块理论证明
* **核心代码片段**：
```cpp
const int BLK=sqrt(N/3);
for(int p=1;p<=BLK;p++) // 建分层图
    for(int i=0;i<n;i++) {
        add_edge(orig[i], virt[p][i], 0); // 原图→虚点
        if(i>=p) add_edge(virt[p][i], virt[p][i-p], 1); // 虚点向左
        if(i+p<n) add_edge(virt[p][i], virt[p][i+p], 1); // 虚点向右
    }
```
* **代码解读**：
  > 1. `virt[p][i]`表示位置i在跳跃能力p的虚点
  > 2. 原图到虚点的0权边：切换到该层
  > 3. 虚点间双向连边：模拟跳跃过程
  > 分块大小`BLK=sqrt(n/3)`经数学证明最小化总边数

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
设计8位像素风格的BFS过程演示，帮助直观理解分块优化和状态扩展：
</visualization_intro>

* **主题**：像素探险家在摩天楼群中传递消息

* **核心演示内容**：
  - 摩天楼用16x16像素方块表示，颜色编码：
    * 蓝色：普通楼
    * 绿色：起点
    * 红色：终点
    * 黄色：当前处理的doge
  - 左侧面板：显示分层图（不同跳跃能力对应不同颜色层）
  - 右侧面板：显示BFS队列状态

* **动画帧步骤**：
  1. **初始化场景**：
     - 生成像素风格摩天楼群（FC游戏画风）
     - 控制面板：开始/暂停、单步执行、速度滑块
     - 播放8-bit背景音乐（循环）
  
  2. **BFS启动**：
     - 起点楼闪烁绿光 + "叮"音效
     - 起点所有doge入队：队列面板添加像素图标
  
  3. **状态扩展过程**：
     - 当前处理楼高亮黄光 + 滴答音效
     - 小跳：显示在分层图中的移动（同层颜色光晕）
     - 大跳：显示跳跃轨迹（像素箭头动画）
     - 新状态入队：队列尾部添加新图标 + "噗"音效
  
  4. **位置激活事件**：
     - 首次到达的楼闪烁白光
     - 激活doge：弹出像素狗头图标 + "汪"音效
  
  5. **消息传递成功**：
     - 终点楼爆炸特效 + 胜利音效
     - 显示总步数路径图

* **游戏化设计**：
  - 每扩展√n个状态自动进入下一"关卡"
  - 完成关卡解锁新doge皮肤
  - 错误路径：显示"X"图标 + 低沉音效

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握分块优化后，可挑战以下相似问题：
</similar_problems_intro>

1. **洛谷 P3648 [APIO2014] 序列分割**
   - 考察分块优化DP
   - 推荐理由：分块思想在DP中的应用

2. **洛谷 P4568 [JLOI2011] 飞行路线**
   - 分层图最短路经典题
   - 推荐理由：分层图建图技巧强化训练

3. **CodeForces 786B Legacy**
   - 线段树优化建图
   - 推荐理由：分块思想的进阶应用

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验：
</insights_intro>

**浮尘ii的调试经验**：
> "UOJ Extra Test #8会卡掉不严谨的分块实现，建议取k=min(100,√n)并通过完整测试"

**Kay总结**：
> 调试分块优化题时需注意：
> 1. 边界情况测试（n=0,1等）
> 2. 块大小需数学证明最优性
> 3. 使用bitset需注意位数限制

---

<conclusion>
本次分析展示了分块优化在图论问题中的强大应用。记住：将大问题分解为可管理的子问题（分块），再巧妙组合（分层图），是算法设计的核心思维。多动手实现可视化算法，能加深理解！
</conclusion>
```

---
处理用时：130.74秒
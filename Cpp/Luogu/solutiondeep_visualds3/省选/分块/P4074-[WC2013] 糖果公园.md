# 题目信息

# [WC2013] 糖果公园

## 题目描述

Candyland 有一座糖果公园，公园里不仅有美丽的风景、好玩的游乐项目，还有许多免费糖果的发放点，这引来了许多贪吃的小朋友来糖果公园游玩。

糖果公园的结构十分奇特，它由 $n$ 个游览点构成，每个游览点都有一个糖果发放处，我们可以依次将游览点编号为 $1$ 至 $n$。有 $n - 1$ 条双向道路连接着这些游览点，并且整个糖果公园都是连通的，即从任何一个游览点出发都可以通过这些道路到达公园里的所有其它游览点。

糖果公园所发放的糖果种类非常丰富，总共有 $m$ 种，它们的编号依次为 $1$ 至 $m$。每一个糖果发放处都只发放某种特定的糖果，我们用 $C_i$ 来表示 $i$ 号游览点的糖果。

来到公园里游玩的游客都不喜欢走回头路，他们总是从某个特定的游览点出发前往另一个特定的游览点，并游览途中的景点，这条路线一定是唯一的。他们经过每个游览点，都可以品尝到一颗对应种类的糖果。

大家对不同类型糖果的喜爱程度都不尽相同。 根据游客们的反馈打分，我们得到了糖果的美味指数， 第 $i$ 种糖果的美味指数为 $V_i$。另外，如果一位游客反复地品尝同一种类的糖果，他肯定会觉得有一些腻。根据量化统计，我们得到了游客第 $i$ 次品尝某类糖果的新奇指数 $W_i$。如果一位游客第 $i$ 次品尝第 $j$ 种糖果，那么他的愉悦指数 $H$ 将会增加对应的美味指数与新奇指数的乘积，即 $V_j \times W_i$。这位游客游览公园的愉悦指数最终将是这些乘积的和。

当然，公园中每个糖果发放点所发放的糖果种类不一定是一成不变的。有时，一些糖果点所发放的糖果种类可能会更改（也只会是 $m$ 种中的一种），这样的目的是能够让游客们总是感受到惊喜。

糖果公园的工作人员小 A 接到了一个任务，那就是根据公园最近的数据统计出每位游客游玩公园的愉悦指数。但数学不好的小 A 一看到密密麻麻的数字就觉得头晕，作为小 A 最好的朋友，你决定帮他一把。


## 说明/提示

【样例解释】

我们分别用

![](https://cdn.luogu.com.cn/upload/image_hosting/isw3ib3u.png)

代表 $C_i$ 为 $1$、 $2$、 $3$ 的节点，在修改之前：

![](https://cdn.luogu.com.cn/upload/image_hosting/ttkzii1u.png)

在将 $C_2$ 修改为 $1$ 之后：

![](https://cdn.luogu.com.cn/upload/image_hosting/izro364w.png)

【数据规模与约定】

对于所有的数据： $1 \leq V_i, W_i \leq 10^6$，$1 \leq A_i, B_i \leq n$， $1 \leq C_i \leq m$， $W_1, W_2, \ldots, W_n$ 是非递增序列，即对任意 $1 < i \leq n$， 满足 $W_i \le W_{i-1}$。

其它的限制条件如下表所示：

![QQ20180113072014.png](https://cdn.luogu.com.cn/upload/image_hosting/g6884nx1.png)


## 样例 #1

### 输入

```
4 3 5
1 9 2
7 6 5 1
2 3
3 1
3 4
1 2 3 2
1 1 2
1 4 2
0 2 1
1 1 2
1 4 2```

### 输出

```
84
131
27
84```

# AI分析结果


### 题目分析：P4074 [WC2013] 糖果公园

#### 题目描述
- 给定一棵树，每个节点发放一种糖果（共 \(m\) 种）。
- 糖果有美味值 \(V_i\)，品尝第 \(k\) 次某种糖果获得愉悦值 \(V_i \times W_k\)。
- 操作：
  - 修改节点 \(x\) 的糖果种类为 \(y\)。
  - 查询路径 \(u \to v\) 的总愉悦值：\(\sum_{c} V_c \sum_{k=1}^{\text{cnt}_c} W_k\)（\(\text{cnt}_c\) 是糖果 \(c\) 的出现次数）。

#### 核心算法：树上带修莫队
1. **欧拉序转换**：
   - 用 DFS 将树转为欧拉序（括号序），每个节点记录进栈时间 `in[u]` 和出栈时间 `out[u]`。
   - 路径查询转化为序列区间：
     - 若 \(u\) 是 \(v\) 的祖先：区间 `[in[u], in[v]]`。
     - 否则：区间 `[out[u], in[v]]` 并单独处理 LCA。

2. **莫队框架**：
   - **排序**：按左端点所在块（大小 \(n^{2/3}\)）、右端点所在块、时间顺序排序。
   - **状态维护**：标记数组 `vis[x]` 表示节点是否在路径上，取反时更新计数：
     - 加入：`cnt[c]++`，答案增加 \(V_c \times W_{\text{cnt}[c]}\)。
     - 移除：`cnt[c]--`，答案减少 \(V_c \times W_{\text{cnt}[c]+1}\)。

3. **修改处理**：
   - 记录修改操作（位置、原值、新值）。
   - 移动时间指针时，若修改点在当前路径上，需先移除原值，修改后再加入新值。

#### 复杂度分析
- 块大小取 \(n^{2/3}\)，总复杂度 \(O(n^{5/3})\)。

#### 关键代码实现
```cpp
// 欧拉序 DFS
void dfs(int u, int fa) {
    in[u] = ++idx; seq[idx] = u;
    for (auto v : G[u]) if (v != fa) dfs(v, u);
    out[u] = ++idx; seq[idx] = u;
}

// 莫队状态更新
void update(int x) {
    if (vis[x]) {
        cnt[c[x]]--;
        sum -= 1LL * V[c[x]] * W[cnt[c[x]] + 1];
    } else {
        cnt[c[x]]++;
        sum += 1LL * V[c[x]] * W[cnt[c[x]]];
    }
    vis[x] ^= 1;
}

// 修改操作
void apply(int t) {
    if (vis[mod[t].pos]) {
        update(mod[t].pos); // 移除原值
        swap(c[mod[t].pos], mod[t].val); // 交换值
        update(mod[t].pos); // 加入新值
    } else {
        swap(c[mod[t].pos], mod[t].val);
    }
}

// 主循环
for (int i = 1; i <= q_cnt; i++) {
    while (time < q[i].t) apply(++time); // 时间后移
    while (time > q[i].t) apply(time--); // 时间前移
    while (l > q[i].l) update(seq[--l]); // 左扩
    while (r < q[i].r) update(seq[++r]); // 右扩
    while (l < q[i].l) update(seq[l++]);  // 左缩
    while (r > q[i].r) update(seq[r--]);  // 右缩
    if (q[i].lca) update(q[i].lca);     // 处理 LCA
    ans[q[i].id] = sum;
    if (q[i].lca) update(q[i].lca);     // 还原 LCA
}
```

---

### 算法可视化方案：像素动画演示

#### 设计思路
- **风格**：8-bit 像素风（复古 FC 游戏），增强学习趣味性。
- **核心演示**：欧拉序序列上莫队指针移动，节点状态切换（加入/移除），糖果计数变化。

#### 动画要素
1. **场景布局**：
   - **主画布**：网格显示欧拉序序列（横向），每个格子代表一个节点（进/出栈）。
   - **控制面板**：开始/暂停、单步执行、速度滑块。
   - **数据结构可视化**：
     - 糖果计数条：每种糖果的当前计数和愉悦值贡献。
     - 路径状态：高亮当前路径上的节点。

2. **关键动画**：
   - **指针移动**：`l`（蓝色）、`r`（红色）指针在序列上滑动，时间指针 `time`（黄色）在修改队列移动。
   - **节点状态切换**：
     - 加入路径：节点闪烁绿色，糖果计数增加，播放 "叮" 音效。
     - 移除路径：节点闪烁红色，糖果计数减少，播放 "咔" 音效。
   - **修改操作**：被修改节点放大显示，新旧糖果图标切换。

3. **交互控制**：
   - **单步执行**：逐步展示指针移动和状态更新。
   - **自动播放**：调整速度（慢速→实时），背景音乐（8-bit 循环）。
   - **高亮逻辑**：当前操作的代码行同步显示（如 `update` 函数）。

#### 伪代码流程
```plaintext
初始化画布:
  绘制欧拉序序列网格: [1, 2, 3, 2, 4, 4, 3, ...]
  标记节点 u 的 in/out 位置

主循环 (处理查询 i):
  while time < q[i].t: 
    时间指针右移 -> 应用修改 mod[time]
    修改点闪烁 -> 新旧糖果交换动画
  while l > q[i].l:
    l 左移 -> 更新 seq[l-1]
    节点高亮绿色 -> 计数增加 -> 播放音效
  ...（其他指针移动类似）

  单独处理 LCA:
    节点闪烁金色 -> 显示 "LCA 加入"
    短暂更新计数 -> 完成后还原

  显示当前总愉悦值: sum
```

#### 学习价值
- **直观理解**：欧拉序如何表示路径、莫队指针移动逻辑。
- **难点突破**：LCA 处理、修改时的状态同步。
- **趣味性**：游戏化操作（如 "收集糖果" 音效、关卡式进度）。

---

### 总结
本题解结合树上莫队与带修莫队，通过欧拉序转化路径查询，高效处理动态修改。可视化方案以像素动画生动展示算法核心流程，帮助学习者突破难点。

---
处理用时：79.55秒
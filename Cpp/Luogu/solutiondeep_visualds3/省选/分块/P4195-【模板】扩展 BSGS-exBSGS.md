# 题目信息

# 【模板】扩展 BSGS/exBSGS

## 题目背景

题目来源：SPOJ3105 Mod

## 题目描述

给定 $a,p,b$，求满足 $a^x≡b \pmod p$ 的最小自然数 $x$ 。


## 说明/提示

对于 $100\%$ 的数据，$1\le a,p,b≤10^9$ 或 $a=p=b=0$。

2021/5/14 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)。  
2021/7/1 新添加[一组 Hack 数据](https://www.luogu.com.cn/discuss/391666)。

## 样例 #1

### 输入

```
5 58 33
2 4 3
0 0 0```

### 输出

```
9
No Solution```

# AI分析结果


# 💡 Kay的C++算法解析：扩展 BSGS/exBSGS 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论/离散对数问题（扩展BSGS算法）

🗣️ **初步分析**：
> 解决扩展BSGS问题就像在迷宫中寻找最短路径。普通BSGS算法（当a与p互质时）相当于在直路中使用地图导航，而扩展BSGS则需先清理障碍（递归除以gcd）再使用地图。核心思想是通过反复除以gcd(a,p)将方程转化为a与模数互质的情形，再应用标准BSGS算法。

- **核心难点**：处理a与p不互质的情况需要递归分解，边界条件处理（如b=1或p=1）和逆元调整是解题关键
- **算法流程**：
  1. 递归除gcd：`while(gcd(a,p)>1)`
  2. 逆元调整：`x = b * inv(ad) mod p'`
  3. BSGS求解：预处理哈希表 + 枚举大步长
- **可视化设计**：采用8位像素风格展示递归除gcd过程（铲除障碍动画），BSGS阶段显示哈希表填充（小步）和查询匹配（大步）过程。关键步骤高亮：gcd值变化、哈希表存储位置、匹配成功位置

---

## 2. 精选优质题解参考

**题解一（白鲟）**
* **亮点**：严谨的数学证明（答案上界和循环节分析）+ 高效自定义哈希实现
* **思路清晰性**：详细推导转化过程，证明x≤2φ(p)确保算法正确性
* **代码规范性**：变量命名合理（baby/giant），边界处理完整（a=p=b=0）
* **算法优化**：O(√φ(p))时间复杂度，存储哈希冲突的两个位置
* **实践价值**：可直接用于竞赛，处理了Hack数据

**题解二（suxrsfe）**
* **亮点**：模块化设计（分离BSGS/exBSGS）+ unordered_map优化查询
* **思路清晰性**：分步讲解普通BSGS与扩展区别，类比迷宫寻路
* **代码规范性**：exgcd求逆元逻辑清晰，边界条件处理严谨
* **算法有效性**：哈希表查询O(1)复杂度，适合大模数场景

**题解三（mydcwfy）**
* **亮点**：递归过程可视化说明 + 详细代码注释
* **思路清晰性**：图解gcd分解过程，解释逆元调整必要性
* **代码规范性**：函数封装良好，变量作用域明确
* **实践价值**：包含调试建议（中间变量打印）

---

## 3. 核心难点辨析与解题策略

1.  **递归转化难点**：当gcd(a,p)>1时需反复分解
    * **解决方案**：`while(gcd(a,p)>1)`循环处理，累计系数ad和次数cnt
    * 💡 **学习笔记**：每次除gcd相当于降低问题规模，类似分治思想

2.  **逆元调整难点**：递归后需消除累积系数影响
    * **解决方案**：使用exgcd求ad的模逆元，b' = b * inv(ad) mod p'
    * 💡 **学习笔记**：逆元是调整方程的关键"校正因子"

3.  **BSGS实现难点**：平衡预处理与查询效率
    * **解决方案**：设m=√p，预处理0~m-1（小步），枚举0~m（大步）
    * 💡 **学习笔记**：哈希表存储小步结果是大步查询的"导航地图"

### ✨ 解题技巧总结
- **分阶段处理**：先递归除gcd → 再逆元调整 → 最后BSGS求解
- **边界处理四象限**：
  1. p=1时必有解x=0
  2. b=1时解为x=0（a≠0）
  3. a=0时b≠0无解
  4. b%gcd≠0时直接返回无解
- **哈希优化**：优先unordered_map（O1查询），大数据量用自定义哈希
- **调试技巧**：打印递归各阶段的ad/cnt/p值，验证逆元正确性

---

## 4. C++核心代码实现赏析

**通用核心C++实现**（综合优化版）：
```cpp
#include <iostream>
#include <cmath>
#include <unordered_map>
using namespace std;
typedef long long LL;

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

void exgcd(int a, int b, LL &x, LL &y) {
    if (!b) { x = 1; y = 0; return; }
    exgcd(b, a % b, y, x);
    y -= a / b * x;
}

int BSGS(int a, int b, int p, int ad) {
    unordered_map<int, int> hash;
    int m = ceil(sqrt(p)), t = 1;
    // 小步预处理 (0 to m-1)
    for (int i = 0; i < m; i++) {
        if (!hash.count(t)) hash[t] = i;
        t = LL(t) * a % p;
    }
    // 大步枚举 (0 to m)
    int base = t; // a^m
    for (int i = 0, cur = ad; i <= m; i++) {
        LL x, y;
        exgcd(cur, p, x, y);
        x = (x % p + p) % p;
        int key = LL(b) * x % p; // b * inv(cur)
        if (hash.count(key)) return i * m + hash[key];
        cur = LL(cur) * base % p;
    }
    return -1; // 无解
}

int exBSGS(int a, int b, int p) {
    if (b == 1 || p == 1) return 0;
    int cnt = 0, ad = 1;
    // 递归除gcd
    while (1) {
        int d = gcd(a, p);
        if (d == 1) break;
        if (b % d) return -1; // 不可整除无解
        cnt++;
        b /= d; p /= d;
        ad = LL(ad) * (a / d) % p;
        if (ad == b) return cnt; // 提前找到解
    }
    // 逆元调整 + BSGS
    LL inv, tmp;
    exgcd(ad, p, inv, tmp);
    inv = (inv % p + p) % p;
    b = LL(b) * inv % p;
    int ans = BSGS(a, b, p, ad);
    return ans != -1 ? ans + cnt : -1;
}
```

**题解一片段赏析**（自定义哈希）：
```cpp
// 白鲟的自定义哈希冲突处理
long long Hash(long long value) {
    long long now = value * value % mod; // 平方取模
    while (key[now] && key[now] != value) // 线性探测
        now = (now + 1) % mod;
    if (!key[now]) stk[++stk[0]] = now; // 记录位置
    key[now] = value;
    return now;
}
```
* **解读**：通过平方取模和线性探测解决哈希冲突，栈记录修改位置便于清空
* **学习笔记**：自定义哈希避免map的log开销，适合频繁查询场景

---

## 5. 算法可视化：像素动画演示

**主题**：8位迷宫探险（FC风格）

### 动画设计
1. **初始化场景**：
   - 像素网格显示方程：`a^x ≡ b (mod p)`
   - 马里奥小人站在`x=0`位置，背包显示`ad=1, cnt=0`

2. **递归除gcd阶段**：
   - 当`gcd>1`时，障碍物（标gcd值）出现在路径
   - 小人挥铲清除障碍，显示`b/=d, p/=d`更新
   - 音效：挖掘声（8-bit短促音）

3. **BSGS预处理**（小步）：
   - 小人向左移动m步，每步在哈希网格存入`a^j`
   - 网格位置按`value % mod`计算，冲突时闪烁提示
   - 音效：放置方块声（清脆叮当声）

4. **BSGS查询**（大步）：
   - 小人向上跳跃，头顶显示`a^(i*m) * inv(ad)`
   - 当匹配成功时，目标网格高亮闪烁
   - 音效：发现音效（上扬琶音）

5. **结果展示**：
   - 路径标记`x = i*m + j + cnt`
   - 胜利动画：小人跳跃+烟花特效
   - 音效：经典马里过关音乐

### 控制面板
- **速度滑块**：调节单步执行速度
- **模式切换**：手动单步/AI自动演示
- **视角切换**：全局视图/算法细节视图

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：
1. **指数方程转化**：`a^x ≡ b (mod p)` → 离散对数问题
2. **递归分解思想**：非互质 → 互质转化
3. **分块平衡**：BSGS的`O(√p)`时间平衡

**洛谷推荐**：
1. [P3846] 可爱的质数  
   → 掌握标准BSGS基础
2. [P2485] 计算器  
   → 综合练习快速幂+exgcd+BSGS
3. [P3306] 随机数生成器  
   → 应用BSGS解决递推数列问题

---

## 7. 学习心得与经验分享

> **来自白鲟的调试经验**：  
> "在实现哈希表时，线性探测未考虑边界导致死循环，通过增加终止条件`now = (now+1)%mod`解决"

**Kay的总结**：  
调试数论问题的黄金法则：
1. 验证递归边界：检查每层gcd分解后ad和b的值
2. 逆元双重验证：`(ad * inv) % p`应等于1
3. 小数据测试：比如`a=2, p=8, b=4`验证递归终止

---

本次深度解析了扩展BSGS的算法思想和实现技巧，通过像素动画展示了递归分解和BSGS查询的核心流程。记住：离散对数问题本质是指数的迷宫探索，而递归分解就是你的万能铲！下次遇到非互质情形，相信你能优雅解决！🚀

---
处理用时：214.77秒
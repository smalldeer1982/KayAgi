# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果



---
# 💡 Kay的C++算法解析：同余方程 深入学习指南 💡

<introduction>
今天我们要一起解决的问题是“同余方程”，题目要求找到关于 \( x \) 的同余方程 \( ax \equiv 1 \pmod{b} \) 的最小正整数解。这道题的核心是求 \( a \) 在模 \( b \) 下的乘法逆元，我们将通过分析多种解法，掌握扩展欧几里得算法（exgcd）和欧拉定理的应用，最后用像素动画直观理解算法过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扩展欧几里得算法（exgcd）、数论中的模逆元求解

🗣️ **初步分析**：
解决这道题的关键在于理解“模逆元”的概念——即找到 \( x \) 使得 \( ax \) 除以 \( b \) 的余数为 1。这等价于求解线性不定方程 \( ax + by = 1 \)（其中 \( y \) 是整数）。根据数论中的裴蜀定理，当且仅当 \( a \) 和 \( b \) 互质（即 \( \gcd(a,b)=1 \)）时，方程有解。

### 核心算法选择
本题最常用的算法是**扩展欧几里得算法（exgcd）**，它能高效求解形如 \( ax + by = \gcd(a,b) \) 的方程。由于题目中 \( \gcd(a,b)=1 \)，因此解 \( x \) 即为所求的逆元。部分题解还提到了利用欧拉定理（\( a^{\varphi(b)} \equiv 1 \pmod{b} \)），通过计算 \( a^{\varphi(b)-1} \mod b \) 得到逆元，但该方法需要先计算欧拉函数 \( \varphi(b) \)，复杂度较高，适合 \( b \) 可分解质因数的情况。

### 可视化设计思路
我们将设计一个8位像素风格的动画，演示扩展欧几里得算法的递归过程：
- **场景**：像素化的“数学实验室”，背景为复古计算器风格，用不同颜色的方块表示 \( a, b, x, y \)。
- **关键步骤**：递归调用时，用箭头展示 \( (a,b) \) 如何变为 \( (b, a \mod b) \)；回溯时，高亮 \( x, y \) 的更新公式 \( x = y_{\text{下}}, y = x_{\text{下}} - \lfloor a/b \rfloor \cdot y_{\text{下}} \)。
- **音效**：递归调用时播放“叮”的音效，回溯时播放“滴”的音效，找到解时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性和算法有效性评估，以下3篇题解最值得参考：
</eval_intro>

**题解一：学委（赞：1512）**
* **点评**：该题解详细推导了扩展欧几里得算法的递归过程，从问题转化到解的调整（如 \( x = (x \% b + b) \% b \) 处理负数解）讲解透彻。代码中全局变量 \( x, y \) 的使用和递归逻辑清晰，适合理解exgcd的核心思想。亮点在于通过“方程变形”和“递归回溯”的直观解释，帮助学习者理解抽象的数论过程。

**题解二：沙普绿12138（赞：112）**
* **点评**：该题解另辟蹊径，利用欧拉定理求解逆元。通过 \( x \equiv a^{\varphi(b)-1} \pmod{b} \) 推导，结合欧拉函数的计算和快速幂，提供了非exgcd的思路。代码中 \( fai \) 函数（计算欧拉函数）和 \( fast\_pow \) 函数（快速幂）实现规范，适合拓展数论知识。亮点在于展示了不同算法的选择依据（如 \( b \) 为质数时费马小定理的简化）。

**题解三：HasNoName（赞：2）**
* **点评**：该题解的代码极其简洁，通过递归交换参数 \( x, y \) 减少中间变量，优化了exgcd的实现。核心代码仅10行，却完整涵盖了递归终止条件和回溯逻辑，适合快速上手。亮点在于对递归参数的巧妙处理（如 \( exgcd(b, a\%b, y, x) \) 直接交换 \( x, y \)），简化了代码逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于理解扩展欧几里得算法的递归逻辑和解的调整方法。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **难点1：扩展欧几里得算法的递归过程**  
    * **分析**：exgcd的核心是递归求解 \( bx_2 + (a \mod b)y_2 = \gcd(a,b) \)，再通过 \( x = y_2, y = x_2 - \lfloor a/b \rfloor \cdot y_2 \) 回溯得到原方程的解。递归终止条件是 \( b=0 \) 时 \( x=1, y=0 \)（此时 \( a = \gcd(a,b) \)）。  
    * 💡 **学习笔记**：递归的每一步都在缩小问题规模（\( a, b \) 变为 \( b, a \mod b \)），最终通过回溯“拼接”出原方程的解。

2.  **难点2：解的调整（求最小正整数解）**  
    * **分析**：exgcd求出的 \( x \) 可能为负数或大于 \( b \)，需通过 \( x = (x \% b + b) \% b \) 调整。这一步利用了模运算的性质：\( x \) 的所有解形如 \( x + k \cdot b \)（\( k \) 为整数），取模后得到最小正解。  
    * 💡 **学习笔记**：调整公式的关键是“先取模再相加”，确保结果为正。

3.  **难点3：欧拉定理方法的适用性**  
    * **分析**：欧拉定理要求 \( a \) 和 \( b \) 互质（与题目条件一致），但计算 \( \varphi(b) \) 需要分解 \( b \) 的质因数。若 \( b \) 很大且质因数复杂（如大质数），分解效率可能低于exgcd。  
    * 💡 **学习笔记**：exgcd的时间复杂度为 \( O(\log \max(a,b)) \)，是本题的最优选择；欧拉定理方法适合 \( b \) 易分解的场景。

### ✨ 解题技巧总结
- **问题转化**：将同余方程 \( ax \equiv 1 \pmod{b} \) 转化为线性不定方程 \( ax + by = 1 \)，利用exgcd求解。
- **递归终止条件**：exgcd的递归终止条件是 \( b=0 \)，此时 \( x=1, y=0 \)（因 \( a \cdot 1 + 0 \cdot 0 = a = \gcd(a,0) \)）。
- **解的调整**：通过 \( (x \% b + b) \% b \) 确保 \( x \) 是最小正整数解。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，选择扩展欧几里得算法的简洁实现作为通用核心代码，兼顾清晰性和效率。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了“学委”和“HasNoName”的题解，采用递归实现扩展欧几里得算法，调整解为最小正整数。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;

    void exgcd(long long a, long long b, long long &x, long long &y) {
        if (b == 0) {
            x = 1;
            y = 0;
            return;
        }
        exgcd(b, a % b, y, x); // 交换x和y，简化回溯逻辑
        y -= a / b * x;
    }

    int main() {
        long long a, b, x, y;
        cin >> a >> b;
        exgcd(a, b, x, y);
        x = (x % b + b) % b; // 调整为最小正整数解
        cout << x << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码通过递归调用 `exgcd` 求解 \( ax + by = 1 \) 的解。递归终止时 \( b=0 \)，设置 \( x=1, y=0 \)。回溯时，通过交换 \( x \) 和 \( y \) 并调整 \( y \) 的值（\( y -= a/b * x \)）得到原方程的解。最后调整 \( x \) 为最小正整数。

---

<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：学委（来源：学委的题解）**
* **亮点**：递归过程清晰，通过全局变量传递 \( x, y \)，适合理解exgcd的递归逻辑。
* **核心代码片段**：
    ```cpp
    void exgcd(long long a, long long b) {
        if (b == 0) {
            x = 1;
            y = 7; // 任意值不影响，因b=0时方程为ax=1
            return;
        }
        exgcd(b, a % b);
        long long tx = x;
        x = y;
        y = tx - a / b * y;
    }
    ```
* **代码解读**：  
  递归函数 `exgcd` 中，当 \( b=0 \) 时，设置 \( x=1 \)（因 \( a \cdot 1 = a = \gcd(a,0) \)）。递归调用后，通过 `tx` 暂存下层的 \( x \)，更新当前层的 \( x \) 为下层的 \( y \)，\( y \) 为下层的 \( x \) 减去 \( a/b \) 乘以下层的 \( y \)，这正是递归回溯的关键公式 \( x = y_{\text{下}}, y = x_{\text{下}} - \lfloor a/b \rfloor \cdot y_{\text{下}} \)。
* 💡 **学习笔记**：全局变量的使用简化了参数传递，但需注意递归过程中变量的更新顺序。

**题解二：沙普绿12138（来源：沙普绿12138的题解）**
* **亮点**：利用欧拉定理和快速幂，提供了非exgcd的思路。
* **核心代码片段**：
    ```cpp
    int fai(int n) { // 计算欧拉函数φ(n)
        int ans = 1;
        for (int i = 2; i * i <= n; ++i) {
            if (n % i == 0) {
                n /= i;
                ans *= i - 1;
                while (n % i == 0) {
                    n /= i;
                    ans *= i;
                }
            }
        }
        if (n > 1) ans *= n - 1;
        return ans;
    }

    int fast_pow(int x, int k) { // 快速幂计算x^k mod b
        ll ans = 1, quan = x;
        while (k) {
            if (k & 1) ans = ans * quan % b;
            quan = quan * quan % b;
            k >>= 1;
        }
        return (int)ans;
    }
    ```
* **代码解读**：  
  `fai` 函数通过分解 \( b \) 的质因数计算欧拉函数（如 \( b = p_1^{k_1}p_2^{k_2}... \)，则 \( \varphi(b) = (p_1-1)p_1^{k_1-1} \cdot (p_2-1)p_2^{k_2-1}... \)）。`fast_pow` 函数通过二进制分解指数，快速计算 \( a^{\varphi(b)-1} \mod b \)。
* 💡 **学习笔记**：欧拉定理方法的关键是正确计算 \( \varphi(b) \)，适合 \( b \) 质因数分解较简单的情况。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解扩展欧几里得算法的递归过程，我们设计一个8位像素风格的动画“数学实验室大冒险”！
</visualization_intro>

  * **动画演示主题**：像素小探险家的逆元之旅  
  * **核心演示内容**：小探险家从 \( (a, b) \) 出发，递归进入 \( (b, a \mod b) \) 的“数学洞穴”，直到 \( b=0 \) 时找到“初始钥匙”（\( x=1, y=0 \)），再回溯调整得到最终解。

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）降低学习压力；递归调用时的“洞穴入口”动画（像素方块滑动）和回溯时的“钥匙传递”动画（高亮 \( x, y \) 更新），配合音效强化记忆；控制面板支持单步/自动播放，同步显示当前递归层的 \( a, b, x, y \) 值。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为左右两部分：左侧是“递归洞穴”（用黑色网格表示，每层洞穴标有 \( (a, b) \)），右侧是“参数面板”（显示当前 \( x, y \) 和公式）。
        - 控制面板：单步/自动播放按钮、速度滑块、重置按钮。

    2.  **递归调用**：  
        - 点击“开始”，小探险家从 \( (a, b) \) 层出发，向下一层 \( (b, a \mod b) \) 移动（像素方块向右下滑动）。
        - 每进入一层，参数面板更新 \( a, b \)，播放“叮”的音效（模拟进入洞穴的声音）。

    3.  **递归终止**：  
        - 当 \( b=0 \) 时，洞穴显示“终点！”，小探险家找到“初始钥匙”（\( x=1, y=0 \) 用金色像素块标记），播放“叮咚”音效。

    4.  **回溯调整**：  
        - 从终止层开始回溯，每返回一层，参数面板计算 \( x = y_{\text{下}}, y = x_{\text{下}} - \lfloor a/b \rfloor \cdot y_{\text{下}} \)，并用箭头动画展示 \( x, y \) 的更新。
        - 播放“滴”的音效（模拟钥匙传递的声音）。

    5.  **解的调整**：  
        - 最终 \( x \) 可能为负数，通过 \( (x \% b + b) \% b \) 调整，像素块颜色从红色（负数）变为绿色（正数），播放胜利音效。

  * **旁白提示**：  
    - “现在进入第3层洞穴，参数变为 \( (b, a \mod b) \)！”  
    - “找到终点层了！这里 \( b=0 \)，所以 \( x=1, y=0 \) 是初始解~”  
    - “回溯时，用下层的 \( x_{\text{下}}, y_{\text{下}} \) 计算当前层的 \( x, y \)，公式是 \( x = y_{\text{下}}, y = x_{\text{下}} - (a/b) \cdot y_{\text{下}} \)！”

<visualization_conclusion>
通过这个动画，我们能直观看到exgcd如何通过递归缩小问题规模，再通过回溯拼接解，最终调整得到最小正整数解。像素风格的设计让抽象的数论过程变得生动有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握模逆元的求解后，我们可以尝试以下拓展问题，巩固数论知识：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    扩展欧几里得算法不仅能解 \( ax \equiv 1 \pmod{b} \)，还能解更一般的线性同余方程 \( ax \equiv c \pmod{b} \)（需 \( \gcd(a,b) \mid c \)）。此外，模逆元在组合数计算（如 \( C(n,k) \mod p \)）、RSA加密等场景中也有重要应用。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1516 青蛙的约会**  
        * 🗣️ **推荐理由**：求解线性同余方程 \( (x - y) + k(m - n) \equiv 0 \pmod{L} \)，需用exgcd求解最小正整数 \( k \)，巩固同余方程的应用。
    2.  **洛谷 P2613 有理数取余**  
        * 🗣️ **推荐理由**：计算 \( \frac{a}{b} \mod 19260817 \)，需先求 \( b \) 的模逆元，再用快速幂计算，综合应用模逆元和快速幂。
    3.  **洛谷 P3811 【模板】乘法逆元**  
        * 🗣️ **推荐理由**：批量求 \( 1 \sim n \) 的模逆元，需用线性递推法，对比exgcd的效率差异，拓展算法优化思路。

---

## 7\. 学习心得与经验分享 

<insights_intro>
部分题解提到调试时的经验，例如：
</insights_intro>

> **参考经验 (来自学委的题解)**：“在回溯时，曾错误地交换 \( x \) 和 \( y \) 的顺序，导致结果错误。后来通过打印每一步的 \( x, y \) 值，发现了递归参数传递的问题。”

**点评**：学委的经验提醒我们，递归算法的调试可以通过打印中间变量（如每一层的 \( a, b, x, y \)）来定位错误。这是解决复杂递归问题的有效方法。对于exgcd，尤其要注意回溯时 \( x, y \) 的更新顺序，避免逻辑错误。

---

<conclusion>
通过本次分析，我们掌握了扩展欧几里得算法和欧拉定理求解模逆元的方法，理解了递归回溯的核心逻辑，并通过像素动画直观感受了算法过程。数论问题的关键在于理解数学原理，结合代码实现加深记忆。接下来，不妨尝试洛谷的拓展题，巩固所学知识吧！💪
</conclusion>

---
处理用时：192.49秒
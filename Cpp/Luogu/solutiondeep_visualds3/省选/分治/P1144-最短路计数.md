# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果



---
# 💡 Kay的C++算法解析：最短路计数 深入学习指南 💡

<introduction>
今天我们来一起分析“最短路计数”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过分析多种题解，我们将提炼出最实用的方法，并结合可视化动画帮助大家直观理解算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论-单源最短路计数（BFS/SPFA/Dijkstra应用）`

🗣️ **初步分析**：
解决“最短路计数”这道题，关键在于结合单源最短路算法（BFS/SPFA/Dijkstra）统计路径数。简单来说，单源最短路算法（如BFS）用于计算从起点到各点的最短距离，而路径计数则需要在算法过程中动态维护：当找到更短路径时，路径数被覆盖；当找到等长路径时，路径数累加。

在本题中，由于图是**无向无权**的（边权为1），BFS天然适合计算最短距离（分层遍历保证第一次访问即最短），而SPFA/Dijkstra也可以通过松弛操作实现。核心难点在于：如何在更新最短距离的同时，正确维护路径数（覆盖或累加）。

例如，当从节点u访问节点v时：
- 若v未被访问过（或找到更短路径），则v的最短距离更新为u的距离+1，路径数等于u的路径数；
- 若v已被访问过且当前路径长度等于v的最短距离，则v的路径数累加u的路径数（取模）。

**可视化设计思路**：采用8位像素风格动画，用不同颜色标记节点状态（未访问、已访问、当前处理），队列/优先队列用像素方块堆叠展示。关键步骤高亮（如距离更新、路径数累加），配合“叮”的音效提示操作，自动播放模式模拟算法执行流程。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码规范性、算法有效性等方面筛选了以下优质题解（≥4星）：
</eval_intro>

**题解一：ZiDing_ByronFinlso的SPFA实现**
* **点评**：此解思路清晰，直接在SPFA的松弛过程中维护路径数。代码规范（变量名如`ans[y]`、`d[y]`含义明确），边界处理严谨（初始时`ans[1]=1`）。SPFA在无权图中效率较高，适合本题数据范围。亮点在于将路径计数与松弛操作结合，代码简洁高效。

**题解二：岸芷汀兰的BFS实现**
* **点评**：利用BFS分层遍历的特性，天然保证第一次访问即最短距离。代码结构工整（`linker`邻接表存图，`d`数组记录距离，`ans`数组计数），关键逻辑（第一次访问时覆盖、后续等长时累加）解释明确。BFS在无权图中时间复杂度为O(N+M)，适合大规模数据。

**题解三：George1123的Dijkstra+拓扑DP实现**
* **点评**：此解分两步：先用Dijkstra求最短距离，再用拓扑排序统计路径数。思路新颖，避免了SPFA可能的重复入队问题。代码中`em[i]`标记有效边（仅保留最短路径相关边），`rud`数组记录入度，拓扑排序保证无后效性。适合理解更复杂的路径计数场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何正确更新路径数？**
    * **分析**：路径数的更新分两种情况：
      - 当找到更短路径（`d[v] > d[u]+1`）：此时`v`的最短路径被`u`的最短路径覆盖，因此`ans[v] = ans[u]`；
      - 当找到等长路径（`d[v] == d[u]+1`）：此时`u`的最短路径是`v`的另一条最短路径，因此`ans[v] += ans[u]`（取模）。
    * 💡 **学习笔记**：路径数的更新依赖于最短距离的比较，必须严格按照“先覆盖后累加”的顺序。

2.  **关键点2：如何处理无向图的重边和自环？**
    * **分析**：题目中重边（如样例中的`4→5`有两条边）会影响路径数（每条重边都是独立路径），但不影响最短距离（边权相同）。自环（`u→u`）对最短距离无意义，可直接忽略。邻接表存图时需保留所有重边，但处理自环时可跳过。
    * 💡 **学习笔记**：邻接表存图能自然处理重边，自环需在输入时过滤（或在遍历边时跳过）。

3.  **关键点3：如何选择算法（BFS/SPFA/Dijkstra）？**
    * **分析**：无权图中，BFS时间复杂度最优（O(N+M)），适合本题；SPFA在稀疏图中效率接近BFS，但可能被卡；Dijkstra（堆优化）时间复杂度为O(M log N)，适合边权非负的通用场景。本题选BFS或SPFA更高效。
    * 💡 **学习笔记**：无权图优先选BFS；边权非负但可能重复选SPFA/Dijkstra；边权有负选SPFA（需防负环）。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解**：先求最短距离，再统计路径数（或同步进行）；
- **邻接表存图**：高效处理大规模无向图，保留重边；
- **取模操作**：路径数可能很大，每一步累加后取模（如`ans[v] %= 100003`）；
- **边界初始化**：起点路径数`ans[1]=1`，其他节点初始化为0。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考（BFS版）**
* **说明**：本代码综合了多个优质题解的思路，采用BFS处理无权图的最短距离，并同步统计路径数。代码简洁高效，适合理解核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <queue>
    using namespace std;

    const int MOD = 100003;
    const int MAXN = 1e6 + 5;

    vector<int> adj[MAXN]; // 邻接表存图
    int d[MAXN]; // 最短距离
    int ans[MAXN]; // 路径数
    bool vis[MAXN]; // 是否访问过

    void bfs(int start) {
        queue<int> q;
        q.push(start);
        d[start] = 0;
        ans[start] = 1;
        vis[start] = true;

        while (!q.empty()) {
            int u = q.front();
            q.pop();

            for (int v : adj[u]) {
                if (!vis[v]) { // 第一次访问，更新距离和路径数
                    vis[v] = true;
                    d[v] = d[u] + 1;
                    ans[v] = ans[u];
                    q.push(v);
                } else if (d[v] == d[u] + 1) { // 等长路径，累加路径数
                    ans[v] = (ans[v] + ans[u]) % MOD;
                }
            }
        }
    }

    int main() {
        int n, m;
        scanf("%d %d", &n, &m);

        for (int i = 0; i < m; ++i) {
            int u, v;
            scanf("%d %d", &u, &v);
            adj[u].push_back(v);
            adj[v].push_back(u); // 无向图
        }

        bfs(1);

        for (int i = 1; i <= n; ++i) {
            printf("%d\n", ans[i] % MOD);
        }

        return 0;
    }
    ```
* **代码解读概要**：
    该代码首先用邻接表存储无向图，然后通过BFS分层遍历。`d`数组记录各点最短距离（初始为无穷大，起点为0），`ans`数组记录路径数（起点为1）。BFS过程中，第一次访问节点时更新距离和路径数；后续遇到等长路径时累加路径数（取模）。最后输出各点路径数。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：ZiDing_ByronFinlso的SPFA实现**
* **亮点**：SPFA松弛过程中同步更新路径数，代码简洁高效。
* **核心代码片段**：
    ```cpp
    while(q.size()) {
        x = q.front(); q.pop();
        p[x] = 0;
        for(int i = head[x]; i; i = nxt[i]) {
            y = to[i];
            if(d[y] > d[x] + 1) {
                d[y] = d[x] + 1;
                ans[y] = ans[x];
                if(!p[y]) { q.push(y); p[y] = 1; }
            } else if(d[y] == d[x] + 1) {
                ans[y] += ans[x];
                ans[y] %= mod;
            }
        }
    }
    ```
* **代码解读**：
    SPFA队列中取出节点`x`，遍历其邻接节点`y`。若`y`的最短距离可更新（`d[y] > d[x]+1`），则更新距离并将`ans[y]`设为`ans[x]`；若`y`的最短距离等于当前路径（`d[y] == d[x]+1`），则`ans[y]`累加`ans[x]`（取模）。`p[y]`标记节点是否在队列中，避免重复入队。
* 💡 **学习笔记**：SPFA适合稀疏图，通过队列动态维护待松弛节点，路径数更新与松弛操作同步完成。

**题解二：岸芷汀兰的BFS实现**
* **亮点**：利用BFS分层特性，天然保证第一次访问即最短距离，代码结构清晰。
* **核心代码片段**：
    ```cpp
    while (q.size()) {
        int u = q.front().node, dis = q.front().dis; 
        q.pop();
        for (int i = 0; i < linker[u].size(); i++) {
            int cur = linker[u][i];
            if (!vis[cur]) {
                q.push(make(cur, dis + 1)); 
                vis[cur] = true; 
                d[cur] = dis + 1; 
                ans[cur] += ans[u]; 
                ans[cur] %= mod;
            } else {
                if (dis + 1 == d[cur]) { 
                    ans[cur] += ans[u]; 
                    ans[cur] %= mod; 
                }
            }
        }
    }
    ```
* **代码解读**：
    BFS队列中取出节点`u`，遍历其邻接节点`cur`。若`cur`未被访问（`!vis[cur]`），则记录距离并将路径数初始化为`ans[u]`；若`cur`已被访问且当前路径长度等于最短距离（`dis+1 == d[cur]`），则路径数累加`ans[u]`（取模）。
* 💡 **学习笔记**：BFS在无权图中时间复杂度最低，适合本题大规模数据。

**题解三：George1123的Dijkstra+拓扑DP实现**
* **亮点**：分两步处理（先求最短距离，再拓扑统计路径数），避免SPFA重复入队问题。
* **核心代码片段**：
    ```cpp
    // Dijkstra求最短距离
    for(int i=1; i<=n; i++) q.push((node){i, dis[i]});
    while(!q.empty()) {
        node tmp = q.top(); q.pop();
        int p = tmp.a;
        if(vis[p]) continue;
        vis[p] = 1;
        for(int i=fro[p]; i; i=e[i].nex) {
            int to = e[i].adj;
            if(dis[p]+1 < dis[to]) {
                dis[to] = dis[p]+1;
                q.push((node){to, dis[to]});
            }
        }
    }
    // 拓扑排序统计路径数
    for(int i=1; i<=top; i++) {
        if(dis[e[i].adj] - dis[e[i].from] == 1) {
            em[i] = 1;
            rud[e[i].adj]++;
        }
    }
    for(int i=1; i<=n; i++) {
        if(rud[i]==0) {
            if(dis[i]<inf) dp[i] = 1;
            tp.push(i);
        }
    }
    while(!tp.empty()) {
        int now = tp.front(); tp.pop();
        for(int i=fro[now]; i; i=e[i].nex) {
            if(!em[i]) continue;
            int p = e[i].adj;
            dp[p] = (dp[p] + dp[now]) % mod;
            rud[p]--;
            if(!rud[p]) tp.push(p);
        }
    }
    ```
* **代码解读**：
    第一步用Dijkstra求最短距离`dis`；第二步构建“最短路径图”（仅保留`dis[v] = dis[u]+1`的边），用拓扑排序统计路径数`dp`（入度为0的节点初始化为1，后续累加前驱路径数）。
* 💡 **学习笔记**：拓扑DP适合处理有向无环图（DAG）的路径计数，避免了动态过程中的重复计算。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解BFS如何统计最短路路径数，我设计了一个8位像素风格的动画演示方案，让我们“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：`像素探险：最短路径大作战`

  * **核心演示内容**：从起点1出发，BFS分层遍历所有节点，展示每个节点的最短距离和路径数的更新过程（如节点颜色变化、数字显示路径数）。

  * **设计思路简述**：采用FC红白机风格的像素画面（8色调色板），用不同颜色标记节点状态（未访问：灰色，已访问：蓝色，当前处理：黄色）。队列用像素方块堆叠展示，每处理一个节点，其邻接节点的距离和路径数动态更新。关键操作（如路径数累加）伴随“叮”的音效，完成所有节点处理后播放胜利音效。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示像素网格（节点用圆圈表示，边用线条连接），右侧显示控制面板（开始/暂停、单步、重置按钮，速度滑块）。
          * 节点1（起点）标记为绿色，其他节点为灰色；队列初始化为[1]。

    2.  **算法启动**：
          * 点击“开始”，队列弹出节点1（变为黄色），遍历其邻接节点（如节点2、3）。
          * 节点2、3未被访问，距离更新为1，路径数设为1（节点变为蓝色），加入队列（队列变为[2,3]）。

    3.  **分层处理**：
          * 单步执行时，队列弹出节点2（黄色），遍历其邻接节点（如节点4）。节点4未被访问，距离更新为2，路径数设为1（蓝色），加入队列。
          * 后续处理节点3时，发现节点4已被访问且距离为2（等于3的距离+1），路径数累加（节点4路径数变为2，数字闪烁）。

    4.  **目标达成**：
          * 所有节点处理完成后，节点5（终点）路径数显示为4，播放“胜利”音效（短旋律），节点5变为金色。

    5.  **交互控制**：
          * 支持“单步执行”（逐节点处理）、“自动播放”（可调速）、“重置”（回到初始状态）。
          * 代码同步区高亮当前执行的代码行（如`ans[cur] += ans[u]`），解释性旁白提示“当前累加路径数”。

  * **旁白提示**：
      * （处理节点1时）“起点1的路径数是1，现在遍历它的邻居节点2和3…”
      * （处理节点2时）“节点4未被访问，它的最短距离是2，路径数等于节点2的路径数（1）…”
      * （处理节点3时）“节点4已被访问且距离相同，路径数累加节点3的路径数（1），现在节点4的路径数是2！”

<visualization_conclusion>
通过这样一个融合像素艺术和交互控制的动画，我们可以清晰看到BFS如何分层遍历、更新距离和路径数，从而更直观地理解最短路计数的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      最短路计数的核心思想（覆盖与累加）不仅适用于无权图，也适用于带权图（如P1608路径统计）。关键是在松弛操作中同步维护路径数，或通过拓扑排序处理DAG的路径计数。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点或思维方式相关的题目，建议大家尝试练习：

    1.  **洛谷 P1608** - `路径统计`
          * 🗣️ **推荐理由**：带权图的最短路计数，需用SPFA或Dijkstra，路径数累加逻辑与本题类似，适合巩固松弛操作与路径计数的结合。
    2.  **洛谷 P4071** - `排列计数`
          * 🗣️ **推荐理由**：结合组合数学的最短路计数问题，需理解排列的最短交换次数与路径数的关系，拓展思维。
    3.  **洛谷 P3371** - `单源最短路径（弱化版）`
          * 🗣️ **推荐理由**：基础Dijkstra模板题，适合练习堆优化Dijkstra的实现，为更复杂的计数问题打基础。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到的问题，这些经验对我们很有参考价值：
</insights_intro>

> **参考经验 (来自ZiDing_ByronFinlso)**：“最初在处理等长路径时忘记取模，导致答案溢出。后来通过测试样例发现问题，添加了`ans[y] %= mod`后AC。”

> **点评**：路径数可能非常大，每一步累加后取模是关键。这提醒我们在处理计数问题时，要注意数值范围，及时取模防止溢出。

-----

<conclusion>
本次关于“最短路计数”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解相关算法和编程技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：200.91秒
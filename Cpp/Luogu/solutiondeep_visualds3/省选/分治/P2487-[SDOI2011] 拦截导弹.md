# 题目信息

# [SDOI2011] 拦截导弹

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度、并且能够拦截任意速度的导弹，但是以后每一发炮弹都不能高于前一发的高度，其拦截的导弹的飞行速度也不能大于前一发。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

在不能拦截所有的导弹的情况下，我们当然要选择使国家损失最小、也就是拦截导弹的数量最多的方案。但是拦截导弹数量的最多的方案有可能有多个，如果有多个最优方案，那么我们会随机选取一个作为最终的拦截导弹行动蓝图。

我方间谍已经获取了所有敌军导弹的高度和速度，你的任务是计算出在执行上述决策时，每枚导弹被拦截掉的概率。


## 说明/提示



保证总方案数不超过 C++ 中 double 类型的存储范围。

### 数据范围及约定

- 均匀分布着约 $30\%$ 的数据，所有 $v_i$ 均相等；
- 均匀分布着约 $50\%$ 的数据，满足 $1\le h_i,v_i\le 1000$。
- 对于 $30\%$ 的数据，满足 $1\le n\le 1000$；
- 对于 $100\%$ 的数据，$1\le n\le 5\times 10^4$，$1\le h_i,v_i\le 10^9$。

### 评分标准

对于每个测试点，若输出的第一行与标准输出相同，则得到该测试点 $40\%$ 的分数，若输出文件的第二行的每个数与标准输出的误差均不大于 $10^{-4}$，则得到该测试点 $60\%$ 的分数，两项相加作为该测试点总得分。

## 样例 #1

### 输入

```
4
3 30
4 40
6 60
3 30
```

### 输出

```
2
0.33333 0.33333 0.33333 1.00000
```

# AI分析结果



---

# 💡 Kay的C++算法解析：[SDOI2011] 拦截导弹 深入学习指南 💡

<introduction>
今天我们来一起分析“[SDOI2011] 拦截导弹”这道C++编程题。这道题需要计算最长不上升子序列的长度，以及每个导弹在所有最长子序列中的被拦截概率。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`CDQ分治优化动态规划（三维偏序问题）`

🗣️ **初步分析**：  
解决这道题的关键在于处理三维偏序（时间、高度、速度）的最长不上升子序列（LDS）问题，并统计方案数。CDQ分治是一种处理多维偏序问题的高效方法，它通过递归分治将三维问题降维，结合树状数组或线段树维护最大值及方案数，将时间复杂度从O(n²)优化到O(n log²n)。

- **题解思路**：  
  1. 定义`f1[i]`为以第i个导弹结尾的最长LDS长度，`g1[i]`为对应方案数；`f2[i]`为以第i个导弹开头的最长LDS长度，`g2[i]`为对应方案数。  
  2. 使用CDQ分治优化DP：递归处理左区间后，用左区间的信息更新右区间，通过树状数组维护高度和速度的偏序关系。  
  3. 正反两次CDQ分治分别计算`f1/g1`和`f2/g2`，最终统计每个导弹的概率。

- **核心难点与解决方案**：  
  - 三维偏序的处理：通过CDQ分治将时间维度有序化，高度排序后用树状数组处理速度维度。  
  - 方案数的统计：使用double类型避免溢出，树状数组同时维护最大值和方案数。  
  - 正反计算的对称性：将序列反转并取反高度、速度后，复用CDQ分治计算`f2/g2`。

- **可视化设计思路**：  
  设计8位像素动画，展示CDQ分治过程。例如，用不同颜色区分左右区间，动态演示高度排序、树状数组更新（如“入队”动画）、最大值查询（高亮当前处理元素）等步骤，配合“叮”音效提示关键操作，胜利音效提示最长序列完成。

---

## 2. 精选优质题解参考

<eval_intro>
通过对多个题解的评估（思路清晰度、代码规范性、算法有效性等），以下题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：hsfzLZH1的CDQ分治+线段树实现**  
* **点评**：该题解详细描述了CDQ分治的递归流程，强调了左右区间的处理顺序和线段树的清空技巧。代码规范，变量命名明确（如`f1`、`g1`），并处理了方案数溢出问题（使用double）。亮点在于对CDQ分治细节的把控（如排序顺序、线段树维护最大值和方案数），适合理解三维偏序优化DP的核心逻辑。

**题解二：shadowice1984的CDQ分治+树状数组实现**  
* **点评**：该题解突出了CDQ分治的递归顺序（先左后右）和数据结构的选择（树状数组），并解释了为何需要正反两次CDQ。代码简洁，通过离散化速度维度，优化了树状数组的查询效率。亮点在于对CDQ分治“分治左-更新-分治右”流程的清晰说明，适合学习递归顺序的重要性。

**题解三：lkytxdy的简洁CDQ实现**  
* **点评**：该题解代码简洁，通过重载运算符简化了方案数的合并操作，并用时间戳优化树状数组的清空。亮点在于对CDQ分治和树状数组的高效结合，适合快速理解核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要重点突破以下核心难点：
</difficulty_intro>

1.  **关键点1：三维偏序的CDQ分治处理**  
    * **分析**：时间维度天然有序（输入顺序），CDQ分治将问题分为左右区间，左区间处理完成后，按高度排序左右区间，用树状数组处理速度维度的偏序。左区间的导弹高度≥右区间时，将其速度和方案数插入树状数组，右区间查询速度≥当前导弹的最大值。  
    * 💡 **学习笔记**：CDQ分治通过递归分治和排序，将三维问题降为二维（高度和速度），树状数组高效维护第三维（速度）的最大值。

2.  **关键点2：方案数的统计与溢出处理**  
    * **分析**：方案数可能极大（超过long long范围），需用double存储。树状数组需同时维护最大值和对应方案数：若当前值更大，更新最大值和方案数；若相等，累加方案数。  
    * 💡 **学习笔记**：double的科学计数法可在不溢出的情况下存储大数，适合统计方案数。

3.  **关键点3：正反两次CDQ分治的对称性**  
    * **分析**：计算`f2/g2`时，需将序列反转并取反高度、速度，使“以i开头的最长LDS”转化为“以i结尾的最长LDS”问题，复用CDQ分治逻辑。  
    * 💡 **学习笔记**：反转序列并取反属性，可将“开头”问题转化为“结尾”问题，减少代码重复。

### ✨ 解题技巧总结
- **离散化处理**：速度和高度范围大，需离散化以适配树状数组的下标。  
- **时间戳优化**：树状数组使用时间戳清空，避免每次递归后手动重置，提高效率。  
- **对称性转换**：通过反转序列和属性，复用CDQ分治代码计算正反两种情况。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了CDQ分治和树状数组，清晰展示了最长LDS长度和方案数的计算过程。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了多个优质题解的思路，使用CDQ分治和树状数组，计算最长LDS长度及方案数，并统计每个导弹的概率。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef double db;
const int N = 5e4 + 5;

struct Node {
    int h, v, id;
} a[N], tmp[N];
int f1[N], f2[N];
db g1[N], g2[N];
int n, tot;
vector<int> vs;

struct BIT {
    int mx[N];
    db cnt[N];
    int tim[N], t;
    void clear() { t++; }
    void update(int x, int v, db c) {
        for (; x <= tot; x += x & -x) {
            if (tim[x] != t) {
                tim[x] = t;
                mx[x] = v;
                cnt[x] = c;
            } else {
                if (mx[x] < v) mx[x] = v, cnt[x] = c;
                else if (mx[x] == v) cnt[x] += c;
            }
        }
    }
    pair<int, db> query(int x) {
        int res_mx = 0;
        db res_cnt = 0;
        for (; x; x -= x & -x) {
            if (tim[x] == t && mx[x] > res_mx) {
                res_mx = mx[x];
                res_cnt = cnt[x];
            } else if (tim[x] == t && mx[x] == res_mx) {
                res_cnt += cnt[x];
            }
        }
        return {res_mx, res_cnt};
    }
} bit;

bool cmp_h_desc(const Node& a, const Node& b) { return a.h > b.h; }
bool cmp_h_asc(const Node& a, const Node& b) { return a.h < b.h; }

void cdq(int l, int r, int f[], db g[], bool desc) {
    if (l >= r) return;
    int mid = (l + r) >> 1;
    cdq(l, mid, f, g, desc);
    for (int i = l; i <= r; i++) tmp[i] = a[i];
    if (desc) {
        sort(tmp + l, tmp + mid + 1, cmp_h_desc);
        sort(tmp + mid + 1, tmp + r + 1, cmp_h_desc);
    } else {
        sort(tmp + l, tmp + mid + 1, cmp_h_asc);
        sort(tmp + mid + 1, tmp + r + 1, cmp_h_asc);
    }
    int j = l;
    bit.clear();
    for (int i = mid + 1; i <= r; i++) {
        while (j <= mid && (desc ? tmp[j].h >= tmp[i].h : tmp[j].h <= tmp[i].h)) {
            bit.update(tmp[j].v, f[tmp[j].id], g[tmp[j].id]);
            j++;
        }
        auto [mx, cnt] = bit.query(tmp[i].v);
        if (mx + 1 > f[tmp[i].id]) {
            f[tmp[i].id] = mx + 1;
            g[tmp[i].id] = cnt;
        } else if (mx + 1 == f[tmp[i].id]) {
            g[tmp[i].id] += cnt;
        }
    }
    cdq(mid + 1, r, f, g, desc);
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) {
        scanf("%d%d", &a[i].h, &a[i].v);
        a[i].id = i;
        vs.push_back(a[i].v);
    }
    sort(vs.begin(), vs.end());
    vs.erase(unique(vs.begin(), vs.end()), vs.end());
    tot = vs.size();
    for (int i = 1; i <= n; i++) {
        a[i].v = lower_bound(vs.begin(), vs.end(), a[i].v) - vs.begin() + 1;
        f1[i] = g1[i] = 1;
    }
    cdq(1, n, f1, g1, true);
    int max_len = *max_element(f1 + 1, f1 + n + 1);
    db total = 0;
    for (int i = 1; i <= n; i++) if (f1[i] == max_len) total += g1[i];
    printf("%d\n", max_len);
    for (int i = 1; i <= n; i++) {
        a[i].h = -a[i].h;
        a[i].v = tot - a[i].v + 1;
        a[i].id = n - i + 1;
        f2[i] = g2[i] = 1;
    }
    cdq(1, n, f2, g2, false);
    reverse(f2 + 1, f2 + n + 1);
    reverse(g2 + 1, g2 + n + 1);
    for (int i = 1; i <= n; i++) {
        if (f1[i] + f2[i] - 1 == max_len) {
            printf("%.5lf ", g1[i] * g2[i] / total);
        } else {
            printf("0.00000 ");
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先读取输入并离散化速度。通过CDQ分治计算`f1/g1`（以i结尾的最长LDS），然后反转序列并取反高度、速度，复用CDQ分治计算`f2/g2`（以i开头的最长LDS）。最后统计每个导弹的概率。

---

<code_intro_selected>
以下是优质题解的核心代码片段分析：
</code_intro_selected>

**题解一：hsfzLZH1的线段树实现（核心片段）**  
* **亮点**：线段树维护最大值和方案数，清晰展示了CDQ分治中左右区间的处理逻辑。  
* **核心代码片段**：  
```cpp
void CDQ1(int l, int r) {
    if (l == r) return;
    int mid = (l + r) >> 1;
    CDQ1(l, mid);
    sort(a + l, a + mid + 1, cmph);
    sort(a + mid + 1, a + r + 1, cmph);
    clear(1, 1, n);
    for (int i = l, j = mid + 1; j <= r; j++) {
        while (i <= mid && a[i].h >= a[j].h) update(1, 1, n, a[i].v, f1[a[i].t], g1[a[i].t]), i++;
        double cn = 0;
        ll t = query(1, 1, n, a[j].v, n, cn);
        if (t) {
            if (f1[a[j].t] < t + 1) f1[a[j].t] = t + 1, g1[a[j].t] = 0;
            if (f1[a[j].t] == t + 1) g1[a[j].t] += cn;
        }
    }
    CDQ1(mid + 1, r);
}
```
* **代码解读**：  
  CDQ分治递归处理左区间后，按高度排序左右区间。左区间的导弹高度≥右区间时，插入线段树；右区间查询速度≥当前导弹的最大值，更新`f1/g1`。线段树`clear`和`update`操作确保每次递归后状态正确。  
* 💡 **学习笔记**：线段树适合维护区间最大值及方案数，CDQ分治的排序顺序是处理高度偏序的关键。

**题解二：lkytxdy的简洁实现（核心片段）**  
* **亮点**：重载运算符简化方案数合并，时间戳优化树状数组清空。  
* **核心代码片段**：  
```cpp
struct data {
    int mx; double cnt;
    data operator+(data b) {
        data c; c.mx = max(mx, b.mx);
        c.cnt = (mx == c.mx) * cnt + (b.mx == c.mx) * b.cnt;
        return c;
    }
};
void cdq(int l, int r) {
    if (l >= r) return;
    int mid = (l + r) >> 1;
    cdq(l, mid);
    sort(a + l, a + mid + 1, [](node x, node y) { return x.h > y.h; });
    sort(a + mid + 1, a + r + 1, [](node x, node y) { return x.h > y.h; });
    int j = l;
    bit.clear();
    for (int i = mid + 1; i <= r; i++) {
        while (j <= mid && a[j].h >= a[i].h) {
            bit.add(a[j].v, {f[a[j].id], g[a[j].id]});
            j++;
        }
        data res = bit.query(a[i].v);
        if (res.mx + 1 > f[a[i].id]) {
            f[a[i].id] = res.mx + 1;
            g[a[i].id] = res.cnt;
        } else if (res.mx + 1 == f[a[i].id]) {
            g[a[i].id] += res.cnt;
        }
    }
    cdq(mid + 1, r);
}
```
* **代码解读**：  
  定义`data`结构体合并最大值和方案数，树状数组`add`和`query`操作直接处理结构体。CDQ分治中按高度排序左右区间，左区间插入树状数组，右区间查询更新。  
* 💡 **学习笔记**：重载运算符可简化代码逻辑，时间戳优化树状数组清空避免重复初始化。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解CDQ分治和树状数组的工作流程，我们设计了一个8位像素风格的动画演示方案。
</visualization_intro>

  * **动画演示主题**：`CDQ分治与树状数组的奇幻之旅`  

  * **核心演示内容**：  
    展示CDQ分治递归处理左右区间、按高度排序、树状数组插入/查询的过程，动态演示导弹的高度、速度变化及最长LDS的构建。

  * **设计思路简述**：  
    采用FC红白机风格（8位像素、简洁色调），通过网格展示导弹序列，用不同颜色区分左右区间。关键操作（如树状数组插入、查询）配合“叮”音效，最长序列完成时播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：  
    1. **初始化场景**：  
       - 屏幕分为左右两部分，左侧显示原始导弹序列（按时间排列），右侧显示树状数组结构（像素方块堆叠）。  
       - 控制面板包含“开始/暂停”“单步”“重置”按钮及速度滑块。  

    2. **CDQ分治递归**：  
       - 递归到左区间时，左半部分高亮（如蓝色），演示子问题分解。  
       - 处理完左区间后，左右区间按高度排序（高到低），用箭头动画展示排序过程。  

    3. **树状数组插入与查询**：  
       - 左区间导弹高度≥右区间时，左导弹（绿色）滑入树状数组对应速度位置，触发“叮”音效。  
       - 右区间导弹查询树状数组时，树状数组对应位置高亮（黄色），显示当前最大值及方案数，更新右导弹的`f`和`g`值（数字弹出）。  

    4. **递归处理右区间**：  
       - 右区间处理完成后，整体序列按时间排序恢复，演示分治的“合并”阶段。  

    5. **结果展示**：  
       - 最长LDS长度用大字体显示，每个导弹的概率用进度条或颜色深浅表示，胜利音效伴随庆祝动画（像素星星闪烁）。  

  * **旁白提示**：  
    - “现在处理左区间，确保其`f`值已计算完成！”  
    - “左区间导弹按高度排序，准备插入树状数组~”  
    - “右区间导弹查询树状数组，找到最大`f`值+1！”  

<visualization_conclusion>
通过这一动画，我们能清晰看到CDQ分治如何将三维问题降维，树状数组如何高效维护最大值及方案数，从而理解最长LDS的计算过程。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以将CDQ分治和树状数组的思路迁移到其他多维偏序问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    CDQ分治适用于处理多维偏序的动态规划问题（如二维LIS、三维点对统计）。关键步骤是：  
    1. 确定一维（如时间）为分治维度，递归处理左右区间。  
    2. 对另两维排序，用树状数组/线段树维护第三维的最大值或统计值。  

  * **练习推荐 (洛谷)**：  
    1. **洛谷 P3810 [模板] 三维偏序（陌上花开）**：  
       * 🗣️ **推荐理由**：经典三维偏序问题，直接应用CDQ分治+树状数组，巩固本题思路。  
    2. **洛谷 P4169 [Violet] 天使玩偶/SJY摆棋子**：  
       * 🗣️ **推荐理由**：二维动态逆序对问题，需结合CDQ分治和树状数组，提升对分治策略的理解。  
    3. **洛谷 P1972 [SDOI2009]HH的项链**：  
       * 🗣️ **推荐理由**：区间颜色统计问题，可通过离线处理+CDQ分治优化，拓展分治应用场景。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，以下是值得借鉴的内容：
</insights_intro>

> **参考经验 (来自hsfzLZH1)**：“在实现CDQ分治时，线段树的清空非常关键，直接memset会超时，需通过DFS剪枝清空。这让我意识到，数据结构的维护细节直接影响算法效率。”  
> **点评**：线段树/树状数组的清空是CDQ分治的常见细节问题。使用时间戳或DFS剪枝可避免重复初始化，提升效率。这提醒我们在实现时需关注数据结构的状态管理。

---

<conclusion>
本次关于“[SDOI2011] 拦截导弹”的C++解题分析就到这里。通过理解CDQ分治的核心思想、掌握树状数组的维护技巧，以及动手实践相似问题，相信大家能更熟练地处理多维偏序问题。编程能力的提升需要持续学习和练习，期待大家在后续挑战中取得进步！💪
</conclusion>

---

---
处理用时：240.37秒
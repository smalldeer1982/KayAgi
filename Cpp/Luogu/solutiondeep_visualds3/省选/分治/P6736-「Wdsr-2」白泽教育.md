# 题目信息

# 「Wdsr-2」白泽教育

## 题目背景

上白泽慧音在给雾之湖的妖精们讲课。

某天，慧音在上数学课时，提到了一种非常有趣的记号：**高德纳箭号表示法**。它可以用来描述非常巨大的数字。~~比如紫的年龄。~~

对于非负整数 $a, b$ 和正整数 $n$，高德纳箭号表示法的定义为：

$$a \uparrow^n b = \begin{cases}
1\ (b = 0) \\
a^b\ (n = 1\ \operatorname{and}\ b > 0) \\
a \uparrow^{n - 1} (a \uparrow^n (b - 1))\ (n > 1\ \operatorname{and}\ b > 0)
\end{cases}$$

一些简单的例子：

- $2 \uparrow 31 = 2^{31} = 2147483648$

- $2 \uparrow \uparrow 4 = 2^{2^{2^2}} = 2^{2^4} = 2^{16} = 65536$

注：
1. $a \uparrow b$ 与 $a \uparrow^1 b$ 相同；

2. $a \uparrow \uparrow b$ 与 $a \uparrow^2 b$ 相同；

3. 请注意幂运算的顺序。

## 题目描述

慧音希望琪露诺解决以下关于 $x$ 的方程：

$$a \uparrow^n x \equiv b \pmod p$$

其中，$a, n, b, p$ 为已知的常数，$x$ 为未知数。

琪露诺被高德纳箭号表示法搞得云里雾里的，但是她不想被头槌。你能帮帮她吗？

## 说明/提示

**本题开启捆绑测试。**

| Subtask | $n$ | $p$ | $T$ | 分值 | 时限 |
| :------: | :------: | :------: | :------: | :------: | :------: |
| $1$ | $n = 1$ | $2 \leq p \leq 10^9$ 且 $p$ 为质数 | $1 \leq T \leq 100$ | $15 \operatorname{pts}$ | $2.00 \operatorname{s}$ |
| $2$ | $n = 2$ | 无特殊限制 | $1 \leq T \leq 5 \times 10^3$ | $25 \operatorname{pts}$ | $1.00 \operatorname{s}$ |
| $3$ | $n = 3$ | 无特殊限制 | 无特殊限制 | $60 \operatorname{pts}$ | $2.00 \operatorname{s}$ |

对于 $100\%$ 的数据，$1 \leq a \leq 10^9$，$1 \leq n \leq 3$，$0 \leq b < p \leq 10^9$，$1 \leq T \leq 2 \times 10^4$。

## 样例 #1

### 输入

```
3
2 1 1 3
3 1 2 7
7 1 2 4```

### 输出

```
0
2
-1```

## 样例 #2

### 输入

```
3
2 2 4 7
3 2 4 6
5 2 1 3```

### 输出

```
2
-1
0```

## 样例 #3

### 输入

```
3
4 3 5 8
2 3 9 11
6 3 1 5```

### 输出

```
-1
3
0```

# AI分析结果



---
# 💡 Kay的C++算法解析：「Wdsr-2」白泽教育 深入学习指南 💡

<introduction>
今天我们要一起攻克的是“「Wdsr-2」白泽教育”这道数论难题！题目涉及高德纳箭号表示法的同余方程求解，需要结合离散对数、扩展欧拉定理等数论知识。本指南将带大家理清思路，掌握核心算法，并用有趣的像素动画帮你“看”懂复杂计算过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（离散对数、扩展欧拉定理）与递归/迭代技巧

🗣️ **初步分析**：
解决这道题的关键在于根据高德纳箭号的层数 \( n \)（1、2、3）选择不同的数论工具。高德纳箭号 \( a \uparrow^n x \) 是一种快速增长的运算，例如 \( n=1 \) 时是普通幂 \( a^x \)，\( n=2 \) 时是幂塔 \( a^{a^{...^a}} \)（\( x \) 层），\( n=3 \) 时则是更复杂的递归结构。我们需要找到最小的 \( x \) 使得这个巨大的数模 \( p \) 等于 \( b \)。

- **题解思路对比**：所有优质题解均围绕分情况处理 \( n \) 值展开：
  - \( n=1 \)：转化为离散对数问题 \( a^x \equiv b \pmod{p} \)，用BSGS（大步小步算法）求解；
  - \( n=2 \)：幂塔 \( a \uparrow\uparrow x \) 模 \( p \)，利用扩展欧拉定理递归计算每一层模值（\( \varphi(p), \varphi(\varphi(p)), ... \)），枚举 \( x \) 直到模值稳定；
  - \( n=3 \)：更高层箭号 \( a \uparrow^3 x \)，利用欧拉函数快速衰减特性，仅枚举 \( x=0,1,2,3 \) 等小值即可。

- **核心算法可视化设计**：针对 \( n=1 \) 的BSGS，动画将展示“大步”跳跃和“小步”枚举的过程（如像素方块在哈希表中跳跃）；针对 \( n=2 \) 的幂塔，用堆叠的像素块表示每一层 \( a \)，颜色渐变表示模 \( \varphi \) 后的值变化，关键步骤（如判断幂次是否超过 \( \varphi \)）用闪烁高亮。

- **复古游戏元素**：采用8位像素风，BSGS的哈希表查找用“叮咚”音效提示匹配，幂塔每完成一层计算播放“升级”音效，最终找到解时播放胜利旋律。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰性、代码规范性和算法有效性评估，以下3篇题解（≥4星）最值得参考：
</eval_intro>

**题解一：Leasier的全场景解法**
* **点评**：这篇题解完整覆盖了所有子任务，代码结构清晰。BSGS函数实现简洁，幂塔（tetration）和三层箭号（pentation）的递归计算逻辑明确，特别是用`Node`结构体记录模值和是否溢出的设计，巧妙解决了扩展欧拉定理中“判断幂次是否超过 \( \varphi \)”的难题。代码注释详细，边界处理严谨（如 \( p=1 \) 时直接返回0），适合作为学习模板。

**题解二：LightningUZ的优化实现**
* **点评**：此题解预处理了欧拉函数表（`phi`数组），优化了重复计算，幂塔函数（`ptower`）的递归逻辑与扩展欧拉定理高度契合。特别值得学习的是对特殊情况（如 \( a=2 \) 时 \( n=3 \) 的特判）的处理，减少了不必要的计算。代码风格统一（使用`namespace`封装），变量命名直观（如`mods`存储欧拉函数链），实践参考价值高。

**题解三：_Fontainebleau_的筛法预处理**
* **点评**：此题解通过筛法预处理小范围的欧拉函数（`sieve`函数），加速了大数的欧拉函数计算（`getphi`）。幂塔计算（`ptower`）的递归终止条件明确（当模值为1时直接返回0），代码中对`a=2`等特殊情况的处理简洁高效。适合学习如何通过预处理优化数论问题的时间复杂度。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，以下三个关键点最易卡住，我们逐一拆解：
</difficulty_intro>

1.  **关键点1：BSGS算法的正确实现**
    * **分析**：BSGS用于求解 \( a^x \equiv b \pmod{p} \)，核心是将 \( x \) 拆分为 \( i \cdot m - j \)（\( m=\sqrt{p} \)），预计算 \( b \cdot a^j \) 存入哈希表，再枚举 \( a^{i \cdot m} \) 查找匹配。需注意：\( a \) 和 \( p \) 不互质时需先约分；哈希表避免重复值（取最小 \( j \)）。
    * 💡 **学习笔记**：BSGS的关键是“分块”思想，用空间换时间，将 \( O(p) \) 复杂度降至 \( O(\sqrt{p}) \)。

2.  **关键点2：幂塔模值的计算（扩展欧拉定理）**
    * **分析**：计算 \( a^{b} \pmod{p} \) 时，若 \( b \geq \varphi(p) \)，则 \( a^b \equiv a^{b \mod \varphi(p) + \varphi(p)} \pmod{p} \)（当 \( a \) 和 \( p \) 不互质时需特判）。幂塔 \( a \uparrow\uparrow x \) 需递归计算每一层模 \( \varphi(p), \varphi(\varphi(p)), ... \)，直到模值为1。
    * 💡 **学习笔记**：扩展欧拉定理的核心是“降幂”，但需注意 \( b \) 是否超过 \( \varphi(p) \)，这可以通过递归返回的`flag`标记判断。

3.  **关键点3：三层箭号的递归处理**
    * **分析**：\( a \uparrow^3 x \) 是 \( a \uparrow\uparrow (a \uparrow^3 (x-1)) \)，由于欧拉函数快速衰减（\( \log p \) 次后变为1），实际只需枚举 \( x=0,1,2,3 \) 等值即可。例如 \( a>2 \) 时，\( a \uparrow^3 2 \) 已极大，后续值模 \( p \) 稳定。
    * 💡 **学习笔记**：高层箭号的“巨大性”可通过欧拉函数的衰减特性简化，只需枚举小值即可覆盖所有可能。

### ✨ 解题技巧总结
- **分情况处理**：根据 \( n \) 值选择BSGS、幂塔递归或特判，避免统一复杂计算；
- **预处理欧拉函数链**：预先计算 \( \varphi(p), \varphi(\varphi(p)), ... \) 直到1，减少重复计算；
- **特判边界条件**：如 \( p=1 \)（所有数模1为0）、\( b=1 \)（\( x=0 \) 可能是解）等，简化逻辑。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合Leasier和LightningUZ的题解，提炼出一个覆盖所有子任务的通用核心实现，代码简洁且逻辑清晰。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个优质题解的思路，重点优化了欧拉函数计算和幂塔递归逻辑，适用于所有子任务。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;

    struct Node { ll val; bool flag; }; // 记录模值和是否溢出

    // 快速幂，返回 (a^b mod m, 是否溢出m)
    Node quick_pow(ll a, ll b, ll m) {
        Node res = {1, false};
        a %= m;
        if (a == 0) return {0, b > 0};
        while (b) {
            if (b & 1) {
                res.val *= a;
                if (res.val >= m) res.flag = true, res.val %= m;
            }
            a *= a;
            if (a >= m) a %= m, res.flag = res.flag || (b > 1);
            b >>= 1;
        }
        return res;
    }

    // BSGS求解 a^x ≡ b mod p
    int bsgs(int a, int b, int p) {
        if (p == 1) return b == 1 ? 0 : -1;
        a %= p, b %= p;
        if (b == 1) return 0;
        unordered_map<int, int> mp;
        int m = ceil(sqrt(p)), t = 1;
        for (int j = 0; j < m; ++j) {
            if (!mp.count(t)) mp[t] = j;
            t = (ll)t * a % p;
        }
        t = 1;
        int am = 1;
        for (int i = 0; i < m; ++i) am = (ll)am * a % p;
        for (int i = 1; i <= m; ++i) {
            t = (ll)t * am % p;
            if (mp.count((ll)t * b % p)) return i * m - mp[(ll)t * b % p];
        }
        return -1;
    }

    // 计算欧拉函数链
    vector<int> get_phi_chain(int p) {
        vector<int> chain;
        while (p > 1) {
            chain.push_back(p);
            int phi = p;
            for (int i = 2; i * i <= p; ++i) {
                if (p % i == 0) {
                    phi = phi / i * (i - 1);
                    while (p % i == 0) p /= i;
                }
            }
            if (p > 1) phi = phi / p * (p - 1);
            p = phi;
        }
        chain.push_back(1);
        return chain;
    }

    // 计算幂塔 a↑↑x mod chain[id]
    Node tetration(int a, int x, int id, const vector<int>& chain) {
        if (chain[id] == 1) return {0, true};
        if (x == 0) return {1, false};
        Node prev = tetration(a, x - 1, id + 1, chain);
        if (prev.flag) prev.val += chain[id + 1];
        return quick_pow(a, prev.val, chain[id]);
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int T; cin >> T;
        while (T--) {
            int a, n, b, p; cin >> a >> n >> b >> p;
            if (n == 1) {
                cout << bsgs(a, b, p) << '\n';
            } else {
                auto chain = get_phi_chain(p);
                int ans = -1;
                if (n == 2) {
                    for (int x = 0; x <= chain.size(); ++x) {
                        Node res = tetration(a, x, 0, chain);
                        if (res.val % p == b) { ans = x; break; }
                    }
                } else { // n == 3
                    if (a == 1) ans = -1;
                    else if (b == a % p) ans = 1;
                    else {
                        // 枚举x=2,3等小值
                        Node res2 = tetration(a, a, 0, chain);
                        if (res2.val % p == b) ans = 2;
                        else {
                            Node res3 = tetration(a, 100, 0, chain); // 100足够大
                            if (res3.val % p == b) ans = 3;
                        }
                    }
                }
                cout << ans << '\n';
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
  代码分为四个核心模块：快速幂（带溢出标记）、BSGS求解离散对数、欧拉函数链计算、幂塔递归计算。主函数根据 \( n \) 值选择不同逻辑：\( n=1 \) 调用BSGS，\( n=2 \) 枚举 \( x \) 并计算幂塔模值，\( n=3 \) 特判小值 \( x \)。

---
<code_intro_selected>
接下来，我们赏析优质题解的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：Leasier的幂塔计算（tetration函数）**
* **亮点**：用`Node`结构体同时记录模值和是否溢出，完美处理扩展欧拉定理的“幂次是否超过 \( \varphi \)”判断。
* **核心代码片段**：
    ```cpp
    Node tetration(int a, int n, int index) {
        if (phi[index] == 1) return new_node(0, true);
        if (n == 0) return new_node(1, false);
        Node x = tetration(a, n - 1, index + 1);
        if (x.flag) x.val += phi[index + 1];
        return quick_pow(a, x.val, phi[index]);
    }
    ```
* **代码解读**：
  递归计算幂塔的第 \( n \) 层：若当前模值（`phi[index]`）为1，返回0（溢出）；若 \( n=0 \)，返回1（无溢出）。递归计算下一层（`index+1`）的结果，若下一层溢出（`x.flag`为true），则当前层的幂次需加上下一层的欧拉函数值（`phi[index+1]`），最后用快速幂计算当前层的模值。
* 💡 **学习笔记**：递归的每一层对应欧拉函数链的一个值，通过`flag`标记传递溢出状态，确保扩展欧拉定理的正确应用。

**题解二：LightningUZ的BSGS优化**
* **亮点**：使用`unordered_map`存储小步值，预处理大步值，减少重复计算。
* **核心代码片段**：
    ```cpp
    int BSGS(int a, int b, int p) {
        rec.clear();
        int sn = sqrt(p) + 1;
        int pw = 1;
        for (int i = 0; i < sn; ++i) {
            rec[pw] = i;
            pw = (ll)pw * a % p;
        }
        int a_sn = pw; // a^sn mod p
        for (int i = 1; i <= sn; ++i) {
            int tmp = (ll)b * qpow(a_sn, p - 2, p) % p; // 逆元优化
            if (rec.count(tmp)) return i * sn - rec[tmp];
            a_sn = (ll)a_sn * a % p;
        }
        return -1;
    }
    ```
* **代码解读**：
  先枚举小步（\( 0 \leq j < \sqrt{p} \)），将 \( b \cdot a^j \) 存入哈希表；再枚举大步（\( i \cdot \sqrt{p} \)），计算 \( a^{i \cdot \sqrt{p}} \) 并查找哈希表。使用逆元优化避免重复计算 \( a^j \)，提升效率。
* 💡 **学习笔记**：BSGS的优化关键在于哈希表的存储和大步的快速计算，逆元可以简化除法操作。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解BSGS和幂塔计算，我们设计一个“像素数论探险”动画，带大家“走进”算法内部！
</visualization_intro>

  * **动画演示主题**：像素数论探险——BSGS与幂塔的奇幻之旅

  * **核心演示内容**：
    - **BSGS部分**：展示“大步”和“小步”的跳跃过程，用不同颜色的像素块表示哈希表中的键值对，匹配时播放“叮”音效。
    - **幂塔部分**：用堆叠的像素块表示每一层 \( a \)，颜色从下到上渐变（红→黄→绿），每计算一层模 \( \varphi(p) \) 时，顶部像素块缩小，模拟欧拉函数的衰减。

  * **设计思路简述**：
    8位像素风（类似FC游戏）降低学习压力，颜色高亮关键步骤（如BSGS的匹配、幂塔的溢出判断），音效强化操作记忆。游戏化的“关卡”设计（如完成BSGS匹配过一关，幂塔计算5层过一关）增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 背景为像素风格的数学实验室，左侧显示输入参数（\( a, n, b, p \)），右侧分为BSGS区（哈希表网格）和幂塔区（堆叠像素柱）。
        - 控制面板：单步/自动按钮、速度滑块（1x-5x）、重置按钮。

    2.  **BSGS演示（\( n=1 \) 时）**：
        - **小步枚举**：像素小人从起点（\( j=0 \)）出发，每走一步（\( j++ \)）在哈希表网格中放置一个彩色方块（键：\( b \cdot a^j \)，值：\( j \)），伴随“滴答”音效。
        - **大步枚举**：像素火箭从 \( i=1 \) 开始，每次跳跃 \( \sqrt{p} \) 步，计算 \( a^{i \cdot \sqrt{p}} \)，若与哈希表中的方块颜色匹配（键相同），火箭闪烁并播放“成功”音效，显示解 \( x = i \cdot \sqrt{p} - j \)。

    3.  **幂塔计算（\( n=2 \) 时）**：
        - 初始堆叠1个红色像素块（\( x=0 \)，值为1）。
        - 每增加一层 \( x \)，顶部添加一个新像素块，颜色根据当前模值（\( \varphi(p), \varphi(\varphi(p)), ... \)）变化（红→橙→黄→绿）。
        - 当某层计算时判断幂次是否溢出（\( flag=true \)），该层像素块边缘闪烁白色，提示“需要加 \( \varphi \)”。

    4.  **目标达成**：
        - 当计算出的模值等于 \( b \) 时，所有像素块旋转并播放“胜利”旋律，屏幕显示“找到解 \( x=... \)”。

  * **旁白提示**：
    - “看！小步枚举把 \( b \cdot a^j \) 存进了哈希表，就像把钥匙放进不同的盒子～”
    - “幂塔的这一层溢出了，所以需要加上下一层的欧拉函数值哦！”

<visualization_conclusion>
通过这个动画，大家可以直观看到BSGS的分块思想和幂塔的递归过程，复杂的数论计算变得像玩游戏一样有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思想（分情况处理、扩展欧拉定理、BSGS）适用于多种数论问题，我们可以通过以下练习巩固：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - BSGS可用于求解其他形式的离散对数问题（如 \( a^x + c \equiv b \pmod{p} \)）；
    - 扩展欧拉定理和幂塔模值计算可用于处理大数取模（如计算 \( 2^{10^{100}} \mod 1e9 \)）；
    - 欧拉函数链的预处理适用于需要多次调用欧拉函数的问题（如P3747 相逢是问候）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3846 [TJOI2007] 可爱的质数**
        * 🗣️ **推荐理由**：BSGS算法的模板题，适合练习离散对数求解的细节处理。
    2.  **洛谷 P3747 [六省联考2017] 相逢是问候**
        * 🗣️ **推荐理由**：深入考察欧拉函数的嵌套性质和扩展欧拉定理，与本题 \( n=2 \) 的幂塔计算思路高度相关。
    3.  **洛谷 P5343 幂塔**
        * 🗣️ **推荐理由**：直接求解幂塔的模值问题，需要熟练应用扩展欧拉定理，与本题 \( n=2 \) 的解法一致。

---

## 7\. 学习心得与经验分享

<insights_intro>
题解中作者们提到的调试经验对我们很有启发：
</insights_intro>

> **参考经验 (来自 LightningUZ)**：“一开始没注意 \( a \) 不能先模 \( p \)（因为幂塔的上层模的是 \( \varphi(p) \) 而不是 \( p \)），导致多次WA。后来通过打印每一层的模值才发现问题。”

**点评**：这个经验提醒我们，数论问题中模运算的对象（是 \( p \) 还是 \( \varphi(p) \)）非常关键，尤其是在递归或多层计算中。调试时打印中间结果（如每一层的模值、溢出标记）是定位错误的有效方法。

---

<conclusion>
通过对“「Wdsr-2」白泽教育”的分析，我们掌握了BSGS、扩展欧拉定理和高层箭号的处理方法。数论问题的关键在于分情况拆解和细节处理，多动手模拟、调试中间步骤会让你更快找到思路！下一次，我们再一起挑战更难的算法题吧～ 💪
</conclusion>

---
处理用时：173.14秒
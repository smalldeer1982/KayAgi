# 题目信息

# [JOISC 2020] 首都

## 题目背景

JOI 国是一个庞大的国度。

## 题目描述

JOI 国拥有 $N$ 个城镇，编号为 $1$ 到 $N$，这些城镇由 $N-1$ 条双向道路连接。

JOI 国还拥有 $K$ 个城市，编号为 $1$ 到 $K$，第 $i$ 个城镇属于第 $C_i$ 个城市。

现在 JOI 国的总理 JOI 君 114514 世要挑选一个城市作为首都，从首都中的任一个城镇到达另一个首都中的城镇可以只经过首都中的城镇，但这明显是不合理的。

所以 JOI 君 114514 世要进行合并城市，合并城市 $x$ 和城市 $y$ 就会把城市 $y$ 里的所有小镇归为城市 $x$。

求能找到首都的最小合并次数。

## 说明/提示

#### 样例 1 解释

可以将城市 $1$ 和 $3$ 合并，然后选择城市 $1$ 作为首都。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$N \le 20$|$1$|
|$2$|$N \le 2000$|$10$|
|$3$|每个城镇最多与两个城镇相连|$30$|
|$4$|无|$59$|

对于 $100\%$ 的数据，$1 \le K,u,v \le N \le 2 \times 10^5$，保证从任何一个城镇出发都能到达其他城镇，$1 \le C_i \le K$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day4 A 首都](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/capital_city.pdf)。

## 样例 #1

### 输入

```
6 3
2 1
3 5
6 2
3 4
2 3
1
3
1
2
3
2```

### 输出

```
1```

## 样例 #2

### 输入

```
8 4
4 1
1 3
3 6
6 7
7 2
2 5
5 8
2
4
3
1
1
2
3
4```

### 输出

```
1```

## 样例 #3

### 输入

```
12 4
7 9
1 3
4 6
2 4
10 12
1 2
2 10
11 1
2 8
5 3
6 7
3
1
1
2
4
3
3
2
2
3
4
4```

### 输出

```
2```

# AI分析结果



---
# 💡 Kay的C++算法解析：[JOISC 2020] 首都 深入学习指南 💡

<introduction>
今天我们来分析这道“首都”问题。它要求我们在树上找到最少需要合并的城市数目，使得存在一个城市（合并后的）的所有节点构成连通块。这道题涉及树的分治、图的依赖关系分析等技巧，让我们一起拆解思路，掌握核心算法！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`点分治`与`图论（强连通分量）`

🗣️ **初步分析**：
解决这道题的关键在于处理树上的颜色连通性问题。简单来说，点分治就像“拆树高手”，把大树拆成小重心，递归处理子树问题；而图论中的强连通分量（SCC）则像“关系梳理师”，帮我们理清颜色间的依赖关系。

在本题中，点分治主要用于高效确定以当前重心为根的子树中，合并最少城市的情况。例如，每次选择重心后，通过队列扩展颜色集合（若当前颜色的节点路径经过其他颜色节点，就需合并该颜色），避免重复计算。而强连通分量法则通过构建颜色依赖图（若颜色A的节点路径经过颜色B，则A依赖B），缩点后找无出度的最小分量，直接得到答案。

核心难点包括：如何高效处理颜色扩展（点分治的子树限制）、如何构建依赖图（树链剖分+线段树优化建图）。主要解决方案是点分治分解问题，或线段树优化建图处理依赖关系。

可视化设计上，我们可以用8位像素风格的树结构，动态展示点分治的重心选择（用金色方块标记）、子树划分（不同颜色区域），队列扩展颜色时用闪烁动画（如红色→黄色融合），合并城市时用颜色渐变效果。控制面板支持单步/自动播放，同步高亮代码关键行（如队列处理部分），并加入“叮”音效提示颜色入队。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下3道题解表现突出（评分≥4星）：
</eval_intro>

**题解一：一粒夸克的点分治解法**
* **点评**：这份题解思路非常清晰，通过点分治递归处理子树，用队列扩展颜色集合，逻辑简洁高效。代码变量命名规范（如`vis`标记已处理节点，`siz`计算子树大小），边界处理严谨（如判断节点是否在当前子树内）。算法复杂度为O(n log n)，适合竞赛实战。亮点在于利用点分治的“分而治之”思想，避免了暴力枚举的O(n²)复杂度。

**题解二：zghtyarecrenj的线段树优化建图+SCC解法**
* **点评**：该题解巧妙结合树链剖分和线段树优化建图，将颜色依赖关系转化为图的边，再通过强连通分量缩点求解。代码结构工整（如`dfs1`和`dfs2`处理树链剖分，`tarjan`求SCC），算法复杂度O(n log²n)，适合进阶学习。亮点是线段树优化建图的技巧，将O(n²)边数压缩到可处理范围。

**题解三：_Diu_的点分治核心片段**
* **点评**：此代码片段聚焦点分治的核心扩展逻辑，用队列维护颜色集合，代码简洁易懂。变量如`vic`标记颜色所属分治中心，`st`数组记录扩展的颜色，关键步骤（如父节点跳转）注释清晰。亮点是通过“若当前颜色的节点不在子树内则退出”的剪枝，大幅减少计算量。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，我们常遇到以下关键点，结合优质题解的思路，一起梳理应对策略：
</difficulty_intro>

1.  **关键点1：如何高效确定需要合并的颜色集合？**
    * **分析**：直接暴力枚举所有颜色组合会超时。点分治通过选择重心，将问题限制在子树内。例如，处理重心时，仅考虑子树内的颜色扩展（若节点在子树外，说明更优解已被上层分治处理）。优质题解中，通过队列扩展颜色（如当前颜色的节点路径经过父节点颜色，则合并父节点颜色），确保每个节点仅被处理一次。
    * 💡 **学习笔记**：点分治的“分而治之”能有效剪枝，避免重复计算。

2.  **关键点2：如何构建颜色依赖图并优化？**
    * **分析**：若颜色A的节点路径经过颜色B的节点，则A依赖B。直接连边会导致O(n²)边数，需优化。树链剖分将路径拆为若干区间，线段树优化建图将区间连边转化为O(log n)条边，大幅减少边数。优质题解中，通过树链剖分的`dfn`序和线段树节点，实现高效连边。
    * 💡 **学习笔记**：树链剖分+线段树优化建图是处理树上区间依赖的常用技巧。

3.  **关键点3：如何利用强连通分量找到最小合并次数？**
    * **分析**：颜色依赖图中，强连通分量（SCC）内的颜色需合并。无出度的SCC即为候选（无需额外合并），取其中最小的SCC大小-1（自身算一个）。优质题解中，通过`tarjan`算法缩点，统计各SCC的出度和大小。
    * 💡 **学习笔记**：缩点后找无出度的最小SCC是解决依赖问题的经典方法。

### ✨ 解题技巧总结
- **点分治剪枝**：处理重心时，限制扩展仅在子树内，避免重复计算。
- **树链剖分+线段树**：将树上路径转化为区间，优化依赖图的边数。
- **强连通分量缩点**：理清颜色依赖关系，快速找到最优合并集合。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选取一粒夸克的点分治代码作为通用核心实现，它逻辑清晰、复杂度优，适合理解和学习。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了点分治的核心思路，通过递归处理重心，队列扩展颜色集合，计算最小合并次数。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    int n,k,rt;
    int ver[400005],ne[400005],head[400005],cnt;
    bool vis[200005],used[200005],vised[200005];
    int col[200005],ans=1e9,tot;
    inline void link(int x,int y){
        ver[++cnt]=y; ne[cnt]=head[x]; head[x]=cnt;
    }
    int siz[200005],mxp[200005];
    void find(int x,int fi,int tot){
        siz[x]=1; mxp[x]=0;
        for(int i=head[x];i;i=ne[i]){
            int u=ver[i];
            if(u==fi||vis[u])continue;
            find(u,x,tot);
            siz[x]+=siz[u]; mxp[x]=max(mxp[x],siz[u]);
        }
        mxp[x]=max(mxp[x],tot-siz[x]);
        if(mxp[x]<mxp[rt])rt=x;
    }
    vector<int> vec[200005];
    queue<int> q;
    inline bool push(vector<int> &v){
        for(int i=0;i<v.size();i++){
            if(!used[v[i]])return 1;
            q.push(v[i]);
        }tot++; return 0;
    }
    int fa[200005];
    void dfs1(int x,int fi){
        fa[x]=fi;
        for(int i=head[x];i;i=ne[i]){
            int u=ver[i];
            if(u==fi||vis[u])continue;
            dfs1(u,x);
        }
    }
    int stk[200005],top;
    void del(int x,int fi){
        stk[top++]=x; used[x]=1;
        for(int i=head[x];i;i=ne[i]){
            int u=ver[i];
            if(u==fi||vis[u])continue;
            del(u,x);
        }
    }
    inline void calc(int x){
        tot=0; while(!q.empty())q.pop();
        vised[col[x]]=1;
        if(push(vec[col[x]]))return ;
        dfs1(x,x);
        while(!q.empty()){
            int u=q.front(); q.pop();
            if(!vised[col[fa[u]]]){
                vised[col[fa[u]]]=1;
                if(push(vec[col[fa[u]]]))return ;
            }
        }
        ans=min(ans,tot);
    }
    void solve(int x){
        vis[x]=1; del(x,x);
        calc(x);
        while(top)--top,used[stk[top]]=vised[col[stk[top]]]=0;
        for(int i=head[x];i;i=ne[i]){
            int u=ver[i];
            if(vis[u])continue;
            rt=0; find(u,x,siz[u]); solve(rt);
        }
    }
    int main(){
        scanf("%d%d",&n,&k);
        for(int i=1;i<n;i++){
            int x,y; scanf("%d%d",&x,&y); link(x,y); link(y,x);
        }
        for(int i=1;i<=n;i++){
            scanf("%d",&col[i]); vec[col[i]].push_back(i);
        }
        mxp[rt=0]=n; find(1,1,n); solve(rt);
        printf("%d",ans-1);
        return 0;
    }
    ```
* **代码解读概要**：
  代码核心流程为：
  1. `find`函数找树的重心；
  2. `calc`函数通过队列扩展颜色集合（若当前颜色的节点路径经过父节点颜色，则合并父颜色）；
  3. `solve`递归处理子树，确保每个节点仅被处理一次。最终输出最小合并次数。

---
<code_intro_selected>
接下来，我们分析各优质题解的核心代码片段：
</code_intro_selected>

**题解一：一粒夸克的点分治代码**
* **亮点**：通过`push`函数判断颜色是否全在子树内，`calc`函数扩展队列，逻辑简洁高效。
* **核心代码片段**：
    ```cpp
    inline void calc(int x){
        tot=0; while(!q.empty())q.pop();
        vised[col[x]]=1;
        if(push(vec[col[x]]))return ; // 若颜色节点不在子树内，直接返回
        dfs1(x,x); // 计算父节点关系
        while(!q.empty()){
            int u=q.front(); q.pop();
            if(!vised[col[fa[u]]]){ // 扩展父节点颜色
                vised[col[fa[u]]]=1;
                if(push(vec[col[fa[u]]]))return ;
            }
        }
        ans=min(ans,tot);
    }
    ```
* **代码解读**：
  `calc`函数首先初始化队列，将当前重心颜色的所有节点入队。若这些节点不全在子树内（`push`返回1），说明更优解已被上层处理，直接返回。否则，通过父节点关系扩展颜色（若父节点颜色未被访问过，入队并统计），最终更新最小合并次数。
* 💡 **学习笔记**：队列扩展颜色是点分治的核心操作，确保每个颜色仅被处理一次。

**题解二：zghtyarecrenj的线段树优化建图代码**
* **亮点**：树链剖分+线段树优化建图，将路径连边转化为O(log n)条边。
* **核心代码片段**：
    ```cpp
    void add(int k, int x, int y, int d) { // 线段树区间连边
        if (x <= T[k].L && T[k].R <= y) {
            G[d].push_back(k); return;
        }
        int mid = (T[k].L + T[k].R) >> 1;
        if (x <= mid) add(T[k].ls, x, y, d);
        if (y > mid) add(T[k].rs, x, y, d);
    }
    void modify(int u, int v) { // 处理路径u-v上的连边
        int cx = c[u];
        while (top[u] != top[v]) {
            if (dep[top[u]] < dep[top[v]]) swap(u, v);
            add(rt, seg[top[u]], seg[u], cx); // 线段树区间连边
            u = anc[top[u]];
        }
        if (dep[v] > dep[u]) swap(u, v);
        add(rt, seg[v], seg[u], cx);
    }
    ```
* **代码解读**：
  `add`函数将线段树节点与颜色节点连边，`modify`函数通过树链剖分将路径拆为若干区间，每个区间对应线段树的一个节点，从而将路径连边转化为O(log n)次操作。这样颜色依赖图的边数被大幅压缩。
* 💡 **学习笔记**：树链剖分+线段树优化是处理树上区间问题的“黄金组合”。

**题解三：_Diu_的点分治核心片段**
* **亮点**：通过`vic`数组标记颜色所属分治中心，避免重复处理。
* **核心代码片段**：
    ```cpp
    void get_ans(int u){
        if(!c[u])return;
        dep[u]=1,fa[u]=0; get_fa(u,u);
        st[tp=1]=c[u],vic[c[u]]=u;
        for(int k=1;k<=tp;k++){
            for(int i=0;i<g[st[k]].size();i++){
                int v=g[st[k]][i];
                if(Vis[v]!=u)return; // 节点不在当前分治中心子树内
                while(dep[v]){
                    if(!c[v])return;
                    if(vic[c[v]]!=u)vic[c[v]]=u,st[++tp]=c[v];
                    dep[v]=0,v=fa[v];
                }
            }
        }
        ans=min(ans,tp-1);
    }
    ```
* **代码解读**：
  `get_ans`函数中，`st`数组记录扩展的颜色，`vic`标记颜色所属分治中心。若节点不在当前子树（`Vis[v]!=u`），说明更优解已被上层处理，直接返回。否则，通过父节点跳转扩展颜色，更新最小合并次数。
* 💡 **学习笔记**：标记颜色所属分治中心是避免重复计算的关键。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解点分治的过程，我们设计一个“像素树探险”动画，用8位风格展示树的分解和颜色扩展！
</visualization_intro>

  * **动画演示主题**：`像素树中的颜色探险`

  * **核心演示内容**：
    以样例1为例，展示点分治如何选择重心，扩展颜色队列，最终找到最小合并次数。关键步骤包括：重心选择（金色方块）、子树划分（不同颜色区域）、颜色扩展（队列弹出节点，父节点颜色入队）。

  * **设计思路简述**：
    8位像素风格（FC红白机色调）让学习更轻松；节点用方块表示（颜色对应城市），重心用金色闪烁标记；队列扩展时，节点方块从队列滑出，父节点颜色方块闪烁入队，伴随“叮”音效；合并完成时播放“胜利”音效，金色方块变大表示成功。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
        - 树结构用像素网格展示，节点为彩色方块（颜色对应城市），控制面板有“单步/自动”按钮、速度滑块。
        - 播放8位风格背景音乐（如《超级玛丽》经典旋律）。

    2.  **寻找重心**：
        - 算法开始，节点方块逐个闪烁，计算子树大小（数字显示）。
        - 重心节点（如样例1的节点2）变为金色并持续闪烁，提示当前处理中心。

    3.  **颜色扩展**：
        - 队列初始加入重心颜色的所有节点（如颜色1的节点1、3），方块滑入队列区域，播放“入队”音效。
        - 弹出队首节点（如节点1），检查父节点（假设父节点是颜色3），若颜色3未被访问过，其节点滑入队列，播放“入队”音效，颜色3标记为已访问。

    4.  **合并完成**：
        - 当队列为空时，统计合并次数（如样例1的1次），所有涉及颜色的方块融合为金色，播放“胜利”音效。
        - 控制面板显示“当前最小合并次数：1”。

    5.  **递归处理子树**：
        - 重心标记为已处理（灰色），子树分割为更小的区域，重复上述步骤，动画自动播放或单步执行。

  * **旁白提示**：
      - “看！金色节点是当前的重心，我们需要处理它的子树～”
      - “队列弹出节点1，它的父节点属于颜色3，需要合并！”
      - “所有颜色扩展完成，当前合并次数是1次，这是候选答案哦～”

<visualization_conclusion>
通过这样的动画，我们能直观看到点分治如何分解问题，颜色如何扩展，最终找到最小合并次数。像素风格和音效让学习更有趣！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下题目，巩固点分治和图论技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    点分治适用于树上的路径统计、连通性问题（如统计满足条件的路径数）；强连通分量适用于依赖关系分析（如任务调度中的前置条件）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4178 Tree** - `树的路径统计`
        * 🗣️ **推荐理由**：经典点分治题，练习如何分解子树并统计路径。
    2.  **洛谷 P3387 缩点** - `强连通分量`
        * 🗣️ **推荐理由**：掌握缩点技巧，理解如何通过SCC简化依赖图。
    3.  **洛谷 P7287 「JOISC 2020 Day1」扫除** - `树上分治`
        * 🗣️ **推荐理由**：进阶点分治题，练习复杂树上问题的分解与处理。

-----

## 7\. 学习心得与经验分享 

<insights_intro>
部分题解提到调试时的经验，值得借鉴：
</insights_intro>

> **参考经验 (来自一粒夸克)**：“最初在判断节点是否在子树内时，未正确标记`used`数组，导致重复计算。后来通过打印`used`数组的状态，发现了问题。”

**点评**：在点分治中，正确标记节点是否属于当前子树是关键。调试时打印关键变量（如`used`、`vised`）的状态，能快速定位错误。这提醒我们，遇到逻辑错误时，输出中间变量是有效的排错方法。

-----

<conclusion>
关于“首都”的分析就到这里！通过点分治和图论的结合，我们能高效解决树上的颜色连通性问题。希望大家多练习，掌握这些技巧，下次挑战更难的题目！💪
</conclusion>

---
处理用时：273.57秒
# 题目信息

# [COCI 2018/2019 #2] Sunčanje

## 题目描述

Slavko 做了一个不寻常的梦。在一个晴朗的早上，$N$ 个白色的矩形一个接着一个爬上了 Slavko 家的屋顶，并在屋顶上晒太阳。每个矩形在屋顶都选定了一个位置，使得它的边与屋顶的棱角平行。有些矩形可能会覆盖在其它矩形所在的位置上。每个矩形的长、宽分别为 $A_i,B_i$，其与屋顶左方和下方的棱角的距离分别为 $X_i,Y_i$。

日落后，矩形们从屋顶上下来，并睡了一觉。次日，它们发现，有些矩形变成了黄色，而有些仍为白色。变为黄色的矩形都是完全暴露在阳光下的。

请判断每个矩形是否变为了黄色。

## 说明/提示

#### 样例 1 解释

矩形 $1,3$ 没有完全暴露在阳光下，因而它们没有变为黄色：

![](https://cdn.luogu.com.cn/upload/image_hosting/pzfz7o9i.png?x-oss-process=image/resize,m_lfit,h_320,w_362)

#### 数据规模与约定

对于 $10\%$ 的数据，$N \le 10^4$。

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$0 \le X_i,Y_i \le 10^9$，$1 \le A_i,B_i \le 10^9$。

#### 说明

**本题分值按 COCI 原题设置，满分 $130$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #2](https://hsin.hr/coci/archive/2018_2019/contest2_tasks.pdf)  _T5 Sunčanje_。**

## 样例 #1

### 输入

```
5
1 1 4 2
6 1 1 1
2 2 2 3
3 4 3 2
4 0 1 2```

### 输出

```
NE
DA
NE
DA
DA```

## 样例 #2

### 输入

```
3
3 3 1 1
2 2 3 3
1 1 5 5```

### 输出

```
NE
NE
DA```

# AI分析结果

---

# 💡 Kay的C++算法解析：Sunčanje 深入学习指南 💡

<introduction>
今天我们要一起攻克的题目是「Sunčanje」（矩形覆盖判断）。这道题的核心是判断每个矩形是否被编号更大的矩形覆盖。通过分析优质题解，我们会发现CDQ分治结合线段树是解决这类多维偏序问题的关键。让我们一步步拆解思路，掌握核心算法！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`CDQ分治与线段树应用`（属于「编程技巧应用」分类）

🗣️ **初步分析**：
解决这道题的关键在于处理矩形覆盖的多维条件：编号更大（时间顺序）、横纵坐标相交。CDQ分治是处理多维偏序问题的“利器”，它通过分治将问题分解为子问题，再合并处理跨子问题的偏序关系，类似“先解决内部，再解决跨区间影响”的策略。

在本题中，CDQ分治的核心是：将矩形按编号倒序排序（保证处理时编号大的先被考虑），分治区间时，左半区间（编号较小）处理右半区间（编号较大）对它的覆盖影响。具体步骤如下：
1. **分治**：将矩形分成左右两部分，递归处理左右子问题。
2. **排序**：左半区间按x右边界排序，右半区间按x左边界排序（确保双指针扫描时，右区间的x左边界≤左区间的x右边界）。
3. **线段树维护**：用线段树维护右区间矩形的y轴区间的最大x右边界。对于左区间的每个矩形，查询其y轴区间的最大x右边界是否≥自身x左边界。若满足，说明被覆盖。

可视化设计思路：用8位像素风网格表示坐标，每个矩形用彩色像素块展示。分治过程中，左、右区间用不同颜色标记，线段树节点用堆叠的像素方块表示。双指针扫描时，当前处理的矩形高亮；线段树更新/查询时，对应y轴区间的像素块闪烁并变色（如绿色表示更新，红色表示查询结果满足条件）。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，筛选出以下3篇优质题解（评分≥4星）：
</eval_intro>

**题解一：lzqy_的CDQ分治+线段树解法**
* **点评**：此题解思路清晰，将CDQ分治与线段树结合的逻辑阐述得非常透彻。代码中变量命名规范（如`a[i]`存储矩形信息，`data[]`表示线段树区间最值），边界处理严谨（离散化后坐标调整）。亮点在于线段树的清空懒标记设计，避免了重复计算，时间复杂度O(n log²n)，适合竞赛场景。

**题解二：operator_的容斥+CDQ分治解法**
* **点评**：此题解另辟蹊径，通过容斥原理将覆盖问题转化为“无交矩形数”的统计，结合CDQ分治处理二维/三维偏序。代码中`ans[]`数组记录无交矩形数，最终与总可能数比较，思路巧妙。虽代码稍复杂，但对理解偏序问题的变形有很大启发。

**题解三：PPL_的四方向容斥+CDQ分治解法**
* **点评**：此题解详细处理了矩形覆盖的四个方向（上下左右）及四个角的容斥，代码虽冗长但逻辑完整。通过`cnt[]`数组统计各方向无交矩形数，最终判断是否完全暴露。适合想深入理解容斥与CDQ结合的学习者。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点在于如何高效处理多维偏序条件。结合优质题解，提炼以下关键点：
</difficulty_intro>

1.  **关键点1：CDQ分治的分治顺序与合并策略**
    * **分析**：CDQ分治需保证处理左区间时，右区间的矩形编号更大（时间偏序）。通过将左右区间分别按x右/左边界排序，双指针扫描确保右区间的x左边界≤左区间的x右边界（横向相交条件）。
    * 💡 **学习笔记**：CDQ分治的合并阶段是处理跨区间偏序的关键，排序策略需与问题中的偏序条件严格对应。

2.  **关键点2：线段树的区间最值维护**
    * **分析**：线段树需维护右区间矩形在y轴区间的最大x右边界。对于左区间的矩形，查询其y轴区间的最大值是否≥自身x左边界（判断是否被覆盖）。线段树的清空懒标记设计（如`LZ[]`数组）避免了不同分治层之间的干扰。
    * 💡 **学习笔记**：线段树的懒标记需同时处理“更新”和“清空”操作，顺序需严格（先清空后更新）。

3.  **关键点3：坐标离散化处理**
    * **分析**：由于坐标范围极大（1e9），直接建线段树不现实。通过离散化将坐标映射到较小范围（如1e5），既保证正确性，又降低空间复杂度。
    * 💡 **学习笔记**：离散化时需包含所有矩形的边界坐标（x1, x2, y1, y2），并去重排序。

### ✨ 解题技巧总结
- **问题转化**：将“覆盖判断”转化为“是否存在编号更大的矩形满足横纵相交”，简化为多维偏序问题。
- **双指针优化**：CDQ分治合并时，双指针扫描右区间，逐步将符合条件的矩形加入线段树，避免重复计算。
- **离散化预处理**：坐标离散化是处理大范围数据的通用技巧，需注意边界值的处理（如样例中右上角坐标-1避免边重合误判）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，以lzqy_的CDQ分治+线段树解法为基础优化，展示完整解题框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了lzqy_的CDQ分治思路，通过离散化处理坐标，线段树维护区间最值，完整实现矩形覆盖判断。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    #define ll long long
    using namespace std;
    const int maxn = 200010;
    const int N = (maxn << 2);

    struct Node {
        int id, xl, yl, xr, yr;
    } a[maxn];

    int data[N], lz[N], LZ[N]; // 线段树：data-区间最值，lz-更新懒标记，LZ-清空懒标记
    int X[N], Y[N], n, m;
    bool f[maxn];

    bool cmp1(Node a, Node b) { return a.xl < b.xl; }
    bool cmp2(Node a, Node b) { return a.xr < b.xr; }
    bool cmp4(Node a, Node b) { return a.id > b.id; }

    void pushdown(int i) {
        if (~LZ[i]) {
            lz[i<<1] = lz[i<<1|1] = 0;
            data[i<<1] = data[i<<1|1] = 0;
            LZ[i<<1] = LZ[i<<1|1] = 0;
            LZ[i] = -1;
        }
        lz[i<<1] = max(lz[i<<1], lz[i]);
        lz[i<<1|1] = max(lz[i<<1|1], lz[i]);
        data[i<<1] = max(data[i<<1], lz[i]);
        data[i<<1|1] = max(data[i<<1|1], lz[i]);
        lz[i] = 0;
    }

    void add(int i, int l, int r, int L, int R, int x) {
        if (l > R || r < L) return;
        if (l >= L && r <= R) {
            data[i] = max(data[i], x);
            lz[i] = max(lz[i], x);
            return;
        }
        pushdown(i);
        int mid = (l + r) >> 1;
        add(i<<1, l, mid, L, R, x);
        add(i<<1|1, mid+1, r, L, R, x);
        data[i] = max(data[i<<1], data[i<<1|1]);
    }

    int query(int i, int l, int r, int L, int R) {
        if (l > R || r < L) return 0;
        if (l >= L && r <= R) return data[i];
        pushdown(i);
        int mid = (l + r) >> 1;
        return max(query(i<<1, l, mid, L, R), query(i<<1|1, mid+1, r, L, R));
    }

    void cdq(int l, int r) {
        if (l >= r) return;
        int mid = (l + r) >> 1;
        cdq(l, mid); cdq(mid+1, r);
        sort(a + l, a + mid + 1, cmp2); // 左区间按xr排序
        sort(a + mid + 1, a + r + 1, cmp1); // 右区间按xl排序
        int ii = l;
        for (int j = mid + 1; j <= r; ++j) {
            while (ii <= mid && a[ii].xl <= a[j].xr) {
                add(1, 1, m, a[ii].yl, a[ii].yr, a[ii].xr);
                ii++;
            }
            f[a[j].id] |= (query(1, 1, m, a[j].yl, a[j].yr) >= a[j].xl);
        }
        // 清空线段树
        data[1] = lz[1] = 0;
        LZ[1] = 0;
        pushdown(1);
    }

    int main() {
        n = read();
        memset(LZ, -1, sizeof(LZ));
        int x, y, u, v, cntx = 0, cnty = 0;
        for (int i = 1; i <= n; ++i) {
            x = read() + 1; y = read() + 1; u = read(); v = read();
            a[i].xl = x; a[i].yl = y;
            a[i].xr = x + u - 1; a[i].yr = y + v - 1;
            X[++cntx] = a[i].xl; X[++cntx] = a[i].xr;
            Y[++cnty] = a[i].yl; Y[++cnty] = a[i].yr;
        }
        // 离散化坐标
        sort(X + 1, X + cntx + 1); sort(Y + 1, Y + cnty + 1);
        int Cntx = unique(X + 1, X + cntx + 1) - X - 1;
        int Cnty = unique(Y + 1, Y + cnty + 1) - Y - 1;
        for (int i = 1; i <= n; ++i) {
            a[i].xl = lower_bound(X + 1, X + Cntx + 1, a[i].xl) - X;
            a[i].xr = lower_bound(X + 1, X + Cntx + 1, a[i].xr) - X;
            a[i].yl = lower_bound(Y + 1, Y + Cnty + 1, a[i].yl) - Y;
            a[i].yr = lower_bound(Y + 1, Y + Cnty + 1, a[i].yr) - Y;
        }
        sort(a + 1, a + n + 1, cmp4); // 按id降序排序，保证大id先处理
        m = Cnty;
        cdq(1, n);
        for (int i = 1; i <= n; ++i) 
            printf("%s\n", f[i] ? "NE" : "DA");
        return 0;
    }
    ```
* **代码解读概要**：
  - **输入处理**：读取矩形坐标，调整右上角坐标（-1避免边重合）。
  - **离散化**：将大范围坐标映射到小范围，便于线段树处理。
  - **CDQ分治**：递归分治，合并时双指针扫描右区间，线段树维护y轴区间的最大x右边界。
  - **线段树操作**：`add`更新区间最值，`query`查询区间最值，`pushdown`处理懒标记。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，学习关键实现技巧：
</code_intro_selected>

**题解一（lzqy_）核心代码片段**：
```cpp
void cdq(int l, int r) {
    if (l >= r) return;
    int mid = (l + r) >> 1;
    cdq(l, mid); cdq(mid+1, r);
    sort(a + l, a + mid + 1, cmp2); // 左区间按xr排序
    sort(a + mid + 1, a + r + 1, cmp1); // 右区间按xl排序
    int ii = l;
    for (int j = mid + 1; j <= r; ++j) {
        while (ii <= mid && a[ii].xl <= a[j].xr) {
            add(1, 1, m, a[ii].yl, a[ii].yr, a[ii].xr);
            ii++;
        }
        f[a[j].id] |= (query(1, 1, m, a[j].yl, a[j].yr) >= a[j].xl);
    }
    // 清空线段树
    data[1] = lz[1] = 0;
    LZ[1] = 0;
    pushdown(1);
}
```
* **亮点**：CDQ分治的合并逻辑简洁高效，双指针扫描确保右区间的x左边界≤左区间的x右边界，线段树动态维护y轴区间的最大x右边界。
* **代码解读**：
  - 递归分治左右子区间后，分别按xr（左）、xl（右）排序，保证双指针扫描时右区间的xl≤左区间的xr。
  - 右区间的每个矩形j，通过`add`将其y轴区间的xr加入线段树，然后查询左区间矩形i的y轴区间的最大xr是否≥i的xl。
  - 线段树清空操作通过懒标记实现，避免跨层干扰。
* 💡 **学习笔记**：CDQ分治的合并阶段是处理跨区间偏序的核心，排序策略和双指针扫描是关键优化点。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解CDQ分治+线段树的执行过程，设计一个“像素矩形探险”主题的8位风格动画：
</visualization_intro>

  * **动画演示主题**：`像素矩形大冒险——寻找覆盖者`

  * **核心演示内容**：展示CDQ分治的分治过程（左、右区间划分），双指针扫描右区间并更新线段树，线段树查询判断覆盖。

  * **设计思路简述**：8位像素风（FC游戏风格）降低学习压力，动态高亮当前处理的矩形和线段树节点，音效提示关键操作（如“叮”表示线段树更新，“咚”表示覆盖判断成功），增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为上下两部分：上方是坐标网格（每个格子代表离散化后的坐标），下方是线段树结构（用堆叠的像素方块表示节点）。
        - 控制面板：单步/自动播放按钮、速度滑块、重置按钮。

    2.  **分治过程**：
        - 初始所有矩形排列成一行（按id降序），颜色为蓝色。
        - CDQ分治时，用虚线将矩形分成左右两部分（左区间蓝色，右区间绿色），递归处理子区间。

    3.  **合并阶段**：
        - 左区间按xr排序（从左到右xr递增），右区间按xl排序（从左到右xl递增）。
        - 双指针扫描：右指针j从mid+1开始，左指针ii从l开始。当a[ii].xl ≤ a[j].xr时，将a[ii]的y轴区间（yl到yr）对应的线段树节点用黄色高亮，并更新其最大值（显示为数字）。
        - 查询时，a[j]的y轴区间在网格中闪烁，线段树对应节点返回最大值，若≥a[j].xl，a[j]变为红色（表示被覆盖）。

    4.  **线段树操作**：
        - 线段树节点用灰色方块表示，更新时变为黄色并显示新值；查询时变为绿色并显示当前最大值。
        - 清空操作时，所有线段树节点变为灰色，值重置为0。

    5.  **音效与反馈**：
        - 双指针移动：“滴答”声。
        - 线段树更新：“叮”声。
        - 覆盖判断成功（f[j]=true）：“咚”声，矩形变红色。
        - 动画结束：“胜利”音效，所有未被覆盖的矩形（DA）闪烁绿色。

<visualization_conclusion>
通过这样的动画，我们能直观看到CDQ分治如何分解问题，线段树如何动态维护区间最值，以及覆盖判断的每一步逻辑。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
CDQ分治+线段树的组合在处理多维偏序问题中非常通用，以下是相关拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 动态逆序对：处理时间、位置、数值的三维偏序（如P4169）。
    - 二维平面覆盖：统计矩形覆盖次数（如P4587）。
    - 多维数点问题：统计满足多条件的点的数量（如P3157）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4169 [Violet] 动态逆序对**  
        🗣️ 推荐理由：经典三维偏序问题，CDQ分治的典型应用，巩固时间、位置、数值的偏序处理。
    2.  **洛谷 P3157 [CQOI2011] 动态逆序对**  
        🗣️ 推荐理由：P4169的加强版，增加修改操作，需结合CDQ分治与树状数组，提升问题变形处理能力。
    3.  **洛谷 P4587 [FJOI2016] 神秘数**  
        🗣️ 推荐理由：二维平面矩形覆盖问题，需用线段树或CDQ分治处理覆盖次数，训练多维问题转化能力。

---

## 7\. 学习心得与经验分享

<insights_intro>
lzqy_在题解中提到：“线段树清空时，需先处理清空懒标记，再处理更新懒标记，否则会导致数据残留。” 这是调试过程中总结的宝贵经验。
</insights_intro>

> **参考经验**：“线段树的清空操作容易被忽略，必须确保每次分治合并后线段树状态重置。我曾因忘记清空导致多个测试点错误，后来通过添加`LZ[]`数组记录清空标记，并在`pushdown`时优先处理，问题得以解决。”

**点评**：这位作者的经验提醒我们，线段树的懒标记处理顺序至关重要（先清空后更新）。在涉及多轮操作的算法（如CDQ分治）中，状态重置是避免错误的关键。调试时可通过打印线段树中间状态，快速定位残留数据问题。

---

<conclusion>
通过本次分析，我们掌握了CDQ分治+线段树解决多维偏序问题的核心思路，理解了矩形覆盖判断的关键条件，以及代码实现中的细节（如离散化、线段树懒标记）。编程能力的提升需要反复练习，不妨从推荐的拓展题开始，巩固所学！下次见~ 💪
</conclusion>

---
处理用时：590.29秒
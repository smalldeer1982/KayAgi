# 题目信息

# [ZJOI2022] 众数

## 题目描述

九条可怜是一个有超能力的女孩子，但她的超能力只能作用于一些奇怪的事情上。

有一天，可怜得到了一个序列 $a_1, a_2, \ldots, a_n$，她可以对这个序列使用一次超能力: 选择一个区
间 $[l, r]$（$1 \le l \le r \le n$）和一个整数 $k \in [-{10}^9, {10}^9]$，将区间内的所有数 $a_l, a_{l + 1}, \ldots, a_r$ 加上 $k$。

九条可怜很喜欢长得比较一致的序列，因此她希望最终的序列众数的出现次数尽可能多。给出序列 $a$，你需要输出最终序列的众数出现次数的最大值，并输出这个众数的所有可能取值。注意对于一个序列，众数的取值可能不止一个。

## 说明/提示

对于所有测试点：$1 \le T \le 20$，$2 \le n \le 2 \times {10}^5$，$1 \le a_i \le {10}^9$，保证 $\sum n \le 5 \times {10}^5$，且 $a_i$ 不全相等。

每个测试点的具体限制见下表：

| 测试点编号 | $\sum n \le$ | $n \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $3000$ | $300$ | 无 |
| $5 \sim 8$ | $5 \times {10}^5$ | $2 \times {10}^5$ | $a_i$ 只有 $5$ 种取值 |
| $9 \sim 10$ | $2 \times {10}^5$ | $50000$ | 无 |
| $11 \sim 20$ | $5 \times {10}^5$ | $2 \times {10}^5$ | 无 |

## 样例 #1

### 输入

```
4
5
1 2 3 2 1
5
1 1 3 1 1
6
2 4 2 4 8 8
5
1 2 3 4 5
```

### 输出

```
4
1
5
1
4
2
4
8
2
1
2
3
4
5
```

## 样例 #2

### 输入

```
见附件中的 mode/mode_ex2.in```

### 输出

```
见附件中的 mode/mode_ex2.ans```

# AI分析结果



---
# 💡 Kay的C++算法解析：[ZJOI2022] 众数 深入学习指南 💡

<introduction>
今天我们来一起分析“[ZJOI2022] 众数”这道C++编程题。这道题要求我们通过一次区间加操作，最大化最终序列的众数出现次数。本指南将帮助大家梳理题目思路，理解核心算法（根号分治），并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`根号分治（分块）`

🗣️ **初步分析**：  
解决这道题的关键在于利用“出现次数”的特性，将问题分为“大数”（出现次数>√n）和“小数”（出现次数≤√n）两类处理，这就是根号分治的思想。简单来说，根号分治像切蛋糕——把大问题切成“大块”和“小块”，分别用不同策略解决。在本题中，“大块”是出现次数多的数（最多√n个），“小块”是出现次数少的数（每个最多√n次）。

- **题解思路**：对大数，直接枚举每个大数作为可能的众数，结合前缀和快速计算区间贡献；对小数，利用出现次数少的特性，暴力枚举区间并预处理众数出现次数。  
- **核心难点**：如何高效处理大数与其他数的组合，以及如何快速计算小数区间内的众数。  
- **可视化设计**：采用8位像素风格，用不同颜色像素块表示数的出现位置。动态展示大数的前缀和计算（如红色块标记大数位置）、小数的扫描线过程（蓝色块标记区间移动），关键步骤用高亮和音效提示（如“叮”声标记区间选择）。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我筛选了以下评分较高（≥4星）的题解，它们在思路清晰度、代码规范性和算法有效性上表现突出。
</eval_intro>

**题解一：作者JoshAlMan（赞23）**  
* **点评**：此题解对根号分治的实现非常完整，详细处理了大数和小数的不同情况。代码结构清晰（如`big()`和`small()`函数分别处理大数和小数），变量命名（如`cnt[]`、`pos[]`）含义明确，特别是对前缀和的预处理和扫描线优化，有效降低了复杂度。实践价值高，适合直接参考。

**题解二：作者Alex_Wei（赞22）**  
* **点评**：此题解思路简洁，对最大子段和的优化处理尤为巧妙。通过维护前缀最小/最大值，快速计算区间贡献，代码中对边界条件的处理（如`r = n`时的特殊情况）非常严谨。适合学习如何将动态规划思想融入分治过程。

**题解三：作者dead_X（赞18）**  
* **点评**：此题解对小数的处理方法具有启发性，利用双指针预处理区间内的众数出现次数（如`g[i][j]`数组），代码逻辑严谨。特别是对“区间端点必为小数位置”的观察，大大减少了枚举次数，是优化的关键。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼出核心思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何处理大数的贡献？**  
    * **分析**：大数出现次数多（>√n），但数量少（≤√n个）。枚举每个大数作为可能的众数，预处理其前缀和数组（记录到每个位置的出现次数），然后枚举其他数作为区间内的众数，通过最大子段和思想计算贡献。  
    * 💡 **学习笔记**：大数的“少而精”特性允许我们暴力枚举，结合前缀和快速计算区间内的出现次数。

2.  **关键点2：如何处理小数的贡献？**  
    * **分析**：小数出现次数少（≤√n），但数量多。利用其出现次数少的特性，枚举可能的区间端点（必为小数位置），预处理区间内的众数出现次数（如双指针维护`g[i][j]`数组），快速计算贡献。  
    * 💡 **学习笔记**：小数的“多而小”特性允许我们暴力枚举区间，但需配合预处理优化复杂度。

3.  **关键点3：如何平衡时间复杂度？**  
    * **分析**：将问题分为大数和小数两部分，大数处理复杂度为O(n√n)，小数处理复杂度为O(n√n)，整体复杂度O(n√n)。通过分治将总复杂度控制在可接受范围内。  
    * 💡 **学习笔记**：根号分治的核心是“分而治之”，将问题规模拆分到平衡状态。

### ✨ 解题技巧总结
- **问题拆分**：将问题按出现次数拆分为大数和小数，分别处理。  
- **前缀和预处理**：快速计算区间内的出现次数，减少重复计算。  
- **双指针优化**：预处理小数区间的众数出现次数，降低枚举复杂度。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，先来看一个综合优质题解的通用核心C++实现。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了多个优质题解的思路，涵盖离散化、大数处理、小数处理和结果输出，逻辑清晰且高效。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 2e5 + 5;
    const int B = 450; // 根号分治阈值，取√(2e5)≈450

    int n, a[N], b[N], cnt[N], pos[N], len;
    vector<int> c[N]; // 存储每个数的出现位置

    // 离散化处理
    void pr() {
        for (int i = 1; i <= n; i++) b[i] = a[i];
        sort(b + 1, b + 1 + n);
        len = unique(b + 1, b + 1 + n) - b - 1;
        for (int i = 1; i <= n; i++) a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b;
        for (int i = 1; i <= len; i++) c[i].clear();
        for (int i = 1; i <= n; i++) c[a[i]].push_back(i);
    }

    // 处理大数
    void big() {
        for (int i = 1; i <= len; i++) {
            if (c[i].size() <= B) continue;
            vector<int> s(n + 1, 0);
            for (int v : c[i]) s[v] = 1;
            for (int j = 1; j <= n; j++) s[j] += s[j - 1];
            // 枚举其他数j，计算i和j的贡献
            for (int j = 1; j <= len; j++) {
                if (i == j) continue;
                int mx = -1e9, mn = 0, idx = 0;
                for (int v : c[j]) {
                    idx++;
                    mx = max(mx, idx - s[v]);
                    mn = min(mn, idx - s[v]);
                }
                cnt[i] = max(cnt[i], mx + s[n]);
                cnt[j] = max(cnt[j], s[n] - mn + (int)c[j].size());
            }
        }
    }

    // 处理小数
    void small() {
        vector<int> S(n + 2, 0);
        for (int i = 1; i <= n; i++) {
            if (c[a[i]].size() > B) continue;
            int p = lower_bound(c[a[i]].begin(), c[a[i]].end(), i) - c[a[i]].begin();
            int val = c[a[i]].size() - p + S[1];
            for (int j = p - 1; j >= 0; j--) {
                int l = c[a[i]][j];
                val = max(val, j + 1 + c[a[i]].size() - p + S[l + 1]);
            }
            cnt[a[i]] = max(cnt[a[i]], val);
            // 更新S数组
            for (int j = p; j >= 0; j--) {
                int l = c[a[i]][j];
                while (l >= 1 && S[l] < p - j + 1) {
                    S[l] = p - j + 1;
                    l--;
                }
            }
        }
    }

    // 输出结果
    void out() {
        int ans = 0;
        vector<int> res;
        for (int i = 1; i <= len; i++) {
            if (c[i].size() + cnt[i] > ans) {
                ans = c[i].size() + cnt[i];
                res.clear();
                res.push_back(b[i]);
            } else if (c[i].size() + cnt[i] == ans) {
                res.push_back(b[i]);
            }
        }
        sort(res.begin(), res.end());
        res.erase(unique(res.begin(), res.end()), res.end());
        cout << ans << "\n";
        for (int v : res) cout << v << "\n";
    }

    int main() {
        int T;
        cin >> T;
        while (T--) {
            cin >> n;
            for (int i = 1; i <= n; i++) cin >> a[i];
            pr();
            memset(cnt, 0, sizeof(cnt));
            big();
            small();
            out();
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先对输入序列离散化（`pr()`函数），然后分别处理大数（`big()`）和小数（`small()`），最后输出结果（`out()`）。大数处理通过前缀和计算区间贡献，小数处理通过扫描线和数组`S`维护区间内的众数出现次数。

---
<code_intro_selected>
接下来，剖析优质题解中的核心代码片段。
</code_intro_selected>

**题解一：作者JoshAlMan**  
* **亮点**：对大数的前缀和预处理和小数的扫描线优化。  
* **核心代码片段**：
    ```cpp
    void inline wk1(int x, int y) {
        int v = -1e9, ret = 0;
        for (int A = 0; A < (int)c[y].size(); A++) {
            chkMax(v, -A + s[c[y][A] - 1]);
            chkMax(ret, v + A + 1 + s[n] - s[c[y][A]]);
        }
        chkMax(w[x], ret);
    }
    ```
* **代码解读**：`wk1`函数计算大数`x`作为区间外众数，小数`y`作为区间内众数的贡献。通过前缀和数组`s`快速计算区间内`x`和`y`的出现次数，维护最大值`v`和结果`ret`。  
* 💡 **学习笔记**：前缀和是快速计算区间内出现次数的关键工具，结合动态维护的最大值可高效求解贡献。

**题解二：作者Alex_Wei**  
* **亮点**：最大子段和优化，维护前缀最小/最大值。  
* **核心代码片段**：
    ```cpp
    for (int ind = 1; ind < pos[j].size(); ind++) {
        mx = max(mx, cur = max(1, cur - (pre[pos[j][ind]] - pre[pos[j][ind - 1]]) + 1));
    }
    ```
* **代码解读**：此片段计算区间内`y`的出现次数减去`x`的出现次数的最大值（最大子段和）。`cur`表示当前子段的和，通过动态更新`mx`得到最大值。  
* 💡 **学习笔记**：最大子段和思想可有效处理“区间内贡献”问题，关键是维护当前最优值。

**题解三：作者dead_X**  
* **亮点**：预处理小数区间的众数出现次数（`g[i][j]`数组）。  
* **核心代码片段**：
    ```cpp
    for (int i = 1; i <= m; ++i) if (c[i].size()<B) {
        int sz=c[i].size();
        for (int j=0; j<sz; ++j)
            for (int k=j; k<sz; ++k)
                g[c[i][j]][k-j+1]=min(g[c[i][j]][k-j+1],c[i][k]);
    }
    ```
* **代码解读**：`g[i][j]`表示以`i`为左端点，众数出现次数为`j`的最小右端点。通过预处理，快速查询区间内的众数出现次数。  
* 💡 **学习笔记**：预处理关键数组可大幅减少重复计算，是处理小数问题的常用技巧。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观理解根号分治的过程，设计一个8位像素风格的动画演示，模拟大数和小数的处理流程。
</visualization_intro>

  * **动画演示主题**：`像素众数探险`（复古FC风格，角色为“分治小勇士”，探索数字大陆）

  * **核心演示内容**：展示大数的前缀和计算、小数的区间枚举，以及最终众数的出现次数最大值。

  * **设计思路简述**：采用8位像素风格（红绿蓝三色调），用不同颜色块表示不同数（如红色块为大数，蓝色块为小数）。关键步骤（如区间选择、众数更新）用闪烁高亮和“叮”声提示，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧显示原始序列（像素块排列），右侧显示控制面板（开始/暂停、单步、调速滑块）。  
        - 背景音乐为8位风格的轻快旋律。

    2.  **大数处理**：  
        - 红色块标记大数位置，动态计算前缀和（白色数字叠加）。  
        - 枚举其他数（蓝色块）时，用黄色框选区间，显示区间内的出现次数差值（绿色数字）。

    3.  **小数处理**：  
        - 蓝色块标记小数位置，扫描线（黄色箭头）从左到右移动。  
        - 维护`S`数组（右侧显示），用紫色数字更新区间内的众数出现次数。

    4.  **结果输出**：  
        - 最终众数出现次数用金色数字放大显示，所有可能的众数（不同颜色块）跳跃庆祝，播放胜利音效。

  * **旁白提示**：  
    - “看！红色块是出现次数多的大数，小勇士用前缀和快速计算它们的贡献~”  
    - “蓝色块是小数，出现次数少，小勇士枚举区间时用扫描线优化，效率超高！”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到根号分治的每一步，理解大数和小数的处理逻辑，以及如何通过优化降低复杂度。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，可以尝试以下拓展练习，巩固根号分治的应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    根号分治适用于处理与“出现次数”“频率”相关的问题，如求区间众数、统计不同元素数量等。关键是将问题拆分为“大块”和“小块”，分别优化。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1972 [SDOI2009]HH的项链**：区间颜色统计问题，练习前缀和与离散化。  
    * 🗣️ **推荐理由**：通过本题可掌握如何用前缀和快速处理区间统计问题。
    2.  **洛谷 P4135 作诗**：区间众数问题，练习根号分治的具体实现。  
    * 🗣️ **推荐理由**：与本题类似，需处理出现次数不同的数，适合巩固分治思想。
    3.  **洛谷 P5357 [模板] 分块**：分块算法模板题，练习分块的基本操作。  
    * 🗣️ **推荐理由**：掌握分块的基础结构，为解决复杂问题打基础。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者提到调试中的经验，例如处理边界条件时的易错点，这些经验对我们很有帮助：
</insights_intro>

> 参考经验（来自某题解作者）：“在处理小数的扫描线时，容易漏掉边界情况（如区间左端点为1或右端点为n），通过打印中间变量`S`数组的值，发现了这个问题。”

**点评**：这位作者的经验提醒我们，在处理边界条件时（如区间左/右端点为序列两端），需特别注意。打印中间变量是调试的有效手段，能快速定位错误。

-----

<conclusion>
本次关于“[ZJOI2022] 众数”的分析就到这里。希望通过本指南，大家能掌握根号分治的核心思想，理解如何处理大数和小数的贡献，并通过代码和动画加深记忆。编程的关键在于多思考、多练习，下次见！💪
</conclusion>

---
处理用时：166.16秒
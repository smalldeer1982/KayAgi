# 题目信息

# ZHY 的矩阵

## 题目描述

ZHY 的记忆中有一个 $k$ 行 $n$ 列的 01 矩阵 $A$，满足下列条件：

- 每一列都至多有一个 $1$。
- 每行相邻的两个 $1$ 所在的两列夹出的 $k$ 行的矩形（包括这两列）内至少有三个 $1$。

突然，ZHY 想起来了矩阵中 $x$ 个位置的值。请你计算有多少种填充 $A$ 的剩余位置的方案，使得 $A$ 满足条件。

----

形式化的讲，设 $A$ 第 $i$ 行第 $j$ 列的数为 $A_{i,j}$，则 $A$ 满足下列条件：

- 对于 $\forall i \in [1,k],\kern{2pt}j \in [1,n]$，$A_{i,j} \in \{0,1\}$。

- 对于 $\forall i \in [1,n]$，$\displaystyle\sum_{j=1}^{k} A_{j,i}\le 1$。

- 对于 $\forall i,j \in [1,n],\kern{2pt}p \in [1,k]$ 且 $j>i$，若有 $A_{p,i}=A_{p,j}=1,\displaystyle \sum_{x=i}^{j}A_{p,x}=2$，则有 $\Big(\displaystyle \sum_{x=1}^{k} \sum_{y=i}^{j} A_{x,y}\Big) \ge 3$。

- 对于 $\forall i\in[1,x]$，有 $A_{a_{i},b_{i}}=c_{i}$。

由于答案可能很大，你只需告诉 ZHY 答案对 $10^{9}+7$ 取模的结果。定义两个矩阵 $A,A'$ 不同，当且仅当存在 $i\in[1,k]$，$j\in[1,n]$ 满足 $A_{i,j}\ne A'_{i,j}$。

## 说明/提示

**样例解释**

满足条件的矩阵只有以下 $2$ 种：

$$
\begin{Bmatrix}
1&0&0\\
0&0&0
\end{Bmatrix}
$$

$$
\begin{Bmatrix}
1&0&0\\
0&0&1
\end{Bmatrix}
$$

----


**本题采用捆绑测试。**

| $\mathrm{Subtask} \kern{2pt} \mathrm{id}$ | $n$ | $x$ | 特殊性质 | 分值 |
| :-----: | :-----: | :-----: | :-----: | :-----: |
| $0$ | $\le 8$ | $\le 8$ | $k=2$ | $12$ |
| $1$ | $\le 2 \times 10^{5}$ | $\le 2\times 10^{5}$ | 无 | $26$ |
| $2$ | $\le 10^{9}$ | $=0$ | 无 | $23$ |
| $3$ | $\le 10^{9}$ | $\le 2\times 10^{5}$ | $c_{i}=1$ | $15$ |
| $4$ | $\le 10^{9}$ | $\le 2\times 10^{5}$ | 无 | $24$ |

对于所有数据，$1 \le n \le 10^{9}$，$0 \le x \le 2\times 10^{5}$，$2\le k \le 100$。$1 \le a_{i} \le k$，$1 \le b_{i} \le n$，$c_{i} \in \{0,1\}$。保证不存在一对 $i,j \in [1,x],\kern{2pt}i\neq j$，满足 $a_{i}=a_{j},\kern{2pt}b_{i}=b_{j}$。

## 样例 #1

### 输入

```
3 2 2
1 1 1
2 2 0
```

### 输出

```
2
```

# AI分析结果


### 💡 Kay的C++算法解析：ZHY的矩阵 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`动态规划优化` + `离散化`  
🗣️ **初步分析**：
> 想象你在玩一个复古像素塔防游戏：矩阵的每一列是一个关卡，你需要放置防御塔（1的位置），但必须遵守规则：① 每列最多一个塔；② 如果两个相同塔相邻，它们之间的区域必须有至少三个塔（包括它们自身）。这就像在游戏中布置防御塔时，要确保关键位置有足够支援！  
> - **核心思路**：将二维矩阵压缩为一维序列（记录每列塔的位置），通过离散化处理已知点（"断点"），用动态规划（DP）分段计算方案数。
> - **难点**：n极大（1e9）但已知点少（x≤2e5），需用数学公式加速段间转移。
> - **可视化设计**：用8-bit像素网格展示矩阵，塔用彩色方块表示。动画高亮断点分段过程，用粒子效果展示DP状态转移（如$f_{i,j}$值变化），配以"放置塔"的电子音效。当违反规则时，触发红色闪烁和错误音效。

---

#### 2. 精选优质题解参考
**题解一（Raymondzll）**  
* **点评**：  
  思路清晰直击要害——将问题转化为一维序列后，推导出段间转移的数学通项公式（$g(d,i-1)=\frac{k^d-1}{k-1}f_0 + k^{d-1}sum$），避免逐列DP。代码规范：离散化处理干净利落，边界条件严谨（如$d=1$特判）。亮点在于**数学优化**：用快速幂将复杂度降至$O(x \log n)$，完美处理1e9数据。

**题解二（0000pnc）**  
* **点评**：  
  状态定义更直观（$f_{i,j}$表示最后非零位置），详细推导段内转移的数学本质（等比数列求和）。代码实现虽略冗长，但**教学价值高**：分"已知点为1"和"未知点"两种情况推导，帮助理解公式来源。亮点是**状态迁移的完整性**：同时处理$g_i$（全零状态），增强方案完备性。

---

#### 3. 核心难点辨析与解题策略
1. **难点1：离散化断点与处理大范围n**  
   * **分析**：n可达1e9，但约束点仅x个（≤2e5）。优质题解通过排序+去重将关键点离散化，把n列分割成O(x)段。
   * 💡 **学习笔记**：离散化是处理稀疏大数据的核心技巧。

2. **难点2：段间转移的数学推导**  
   * **分析**：两段断点间隔d列时，转移方案数需公式计算而非递推。Raymondzll的$g(d,i-1)$公式本质是：  
     $方案数 = (\text{全零状态贡献}) \times \frac{k^d-1}{k-1} + (\text{非零状态贡献}) \times k^{d-1}$
   * 💡 **学习笔记**：推导通项公式可避免线性计算，是优化DP的核心手段。

3. **难点3：约束条件的动态融入**  
   * **分析**：已知点分两种：① 强制$a_i=p$（等于型）：只能从非p状态转移；② 禁止$a_i=p$（不等于型）：需排除p状态。代码通过`flag`数组分类处理。
   * 💡 **学习笔记**：约束条件应转化为状态转移的限制条件。

### ✨ 解题技巧总结
- **技巧1：离散化加速**  
  对稀疏约束点排序去重，将问题规模从O(n)降至O(x)。
- **技巧2：数学归纳替代递推**  
  通过前几项观察等比数列规律，推导通项公式。
- **技巧3：状态压缩**  
  用$sum_i = \sum f_{i,j}$ 避免冗余计算，提升效率。

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合自Raymondzll的优化版）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll P = 1000000007;
ll ksm(ll a, ll b) { // 快速幂
    ll res = 1;
    for (; b; b >>= 1, (a *= a) %= P)
        if (b & 1) (res *= a) %= P;
    return res;
}

int main() {
    // 输入与离散化
    ll n, k, x; cin >> n >> k >> x;
    vector<tuple<ll, ll, ll>> pts(x); // (位置, 行, 类型)
    vector<ll> breaks = {0, n}; // 断点包含首尾
    for (auto &[pos, row, type] : pts) {
        cin >> row >> pos >> type;
        breaks.push_back(pos);
    }
    sort(breaks.begin(), breaks.end());
    breaks.erase(unique(breaks.begin(), breaks.end()), breaks.end());

    // DP初始化：f[i][j]表示到第i断点，最后塔在行j的方案数
    vector<vector<ll>> f(breaks.size(), vector<ll>(k + 1, 0));
    vector<ll> sum(breaks.size(), 0); // 状态和
    f[0][0] = 1; // 起始全零状态

    // 分段DP
    for (int i = 1; i < breaks.size(); ++i) {
        ll d = breaks[i] - breaks[i - 1]; // 段长度
        ll inv_k = (k == 1) ? 1 : ksm(k - 1, P - 2);
        for (int j = 0; j <= k; ++j) {
            if (当前断点有约束) { /* 根据约束类型更新 */ }
            else {
                if (j == 0) f[i][j] = f[i - 1][0];
                else f[i][j] = ((ksm(k, d) - 1) * inv_k % P * f[i - 1][0] 
                              + ksm(k, d - 1) * sum[i - 1]) % P;
            }
        }
    }
    cout << (sum.back() + f.back()[0]) % P;
}
```

**题解一片段赏析（Raymondzll）**  
```cpp
if (flag[i]) { // 断点强制为某值
    for (int j = 1; j <= k; j++) {
        if (j != 禁用行) {
            f[i][j] = ksm(k, d - 1) * f[i - 1][0]  // 全零贡献
                     + (k - 1) * ksm(k, d - 2) % P * sum[i - 1]; // 非零贡献
        }
    }
}
```
* **代码解读**：  
  > 当断点$i$强制为塔$j$时：  
  > 1. **全零状态贡献**：前段全零时，当前段前$d-1$列可自由放塔（$k^{d-1}$种），最后放置$j$。  
  > 2. **非零状态贡献**：前段最后塔非零时，当前段前$d-1$列需避免在$j$放塔（$(k-1)k^{d-2}$种）。  
  > *学习笔记*：公式组合两类贡献，避免$O(d)$递推！

---

#### 5. 算法可视化：像素动画演示
**主题**：8-bit塔防游戏《矩阵守卫者》  
**核心演示**：DP状态如何随断点分段更新  

1. **场景初始化**  
   - 网格背景：行=塔类型，列=关卡，已知点用闪烁旗帜标记。
   - 控制面板：速度滑块/单步按钮，右下角实时显示$f_{i,j}$值。

2. **分段转移动画**  
   ```mermaid
   graph LR
   前段状态 -- d=3 --> 公式计算 --> 当前段状态
   ```
   - **视觉**：两断点间画出虚线框，内部填充粒子特效表示$k^{d}$计算过程。
   - **音效**：计算时播放电子运算音，结果确定时"叮"声。

3. **约束处理**  
   - 等于型约束：目标位置升起指定颜色塔，其他位置变暗。
   - 不等于型约束：禁用位置打叉，触发"错误"音效。

4. **游戏化元素**  
   - 每段完成：像素小人跳跃庆祝，显示"Segment Clear!"
   - 最终答案：所有塔亮起，播放8-bit胜利音乐。

---

#### 6. 拓展练习
1. **洛谷 Pxxx1**  
   *推荐理由*：同样需离散化+分段DP处理稀疏约束，巩固本题核心技巧。
2. **洛谷 Pxxx2**  
   *推荐理由*：变形题——将"至少三个塔"改为"至少两个塔"，思考状态转移如何调整。
3. **洛谷 Pxxx3**  
   *推荐理由*：结合状态压缩DP，挑战更复杂约束条件。

---

#### 7. 学习心得
> **Raymondzll的经验**：  
> “推导通项公式时，我先手动计算d=1,2,3的转移，发现等比数列规律后验证通项。”  
> **Kay点评**：  
> 这是**数学归纳法**的典型应用！面对复杂递推，先从小规模找规律再推广，比直接抽象推导更有效。

---
处理用时：121.64秒
# 题目信息

# [HNOI2016] 序列

## 题目描述

给定长度为 $ n $ 的序列：$ a_1, a_2, \cdots , a_n $，记为 $ a[1 \colon n] $。类似地，$ a[l \colon r] $（$ 1 \leq l \leq r \leq N$）是指序列：$ a_{l}, a_{l+1}, \cdots ,a_{r-1}, a_r$。若 $1\leq l \leq s \leq t \leq r \leq n$，则称 $ a[s \colon t] $ 是 $ a[l \colon r] $ 的子序列。

现在有 $ q $ 个询问，每个询问给定两个数 $ l $ 和 $ r $，$ 1 \leq l \leq r \leq n $，求 $ a[l \colon r] $ 的不同子序列的最小值之和。例如，给定序列
 $ 5, 2, 4, 1, 3 $，询问给定的两个数为 $ 1 $ 和 $ 3 $，那么 $ a[1 \colon 3] $ 有 $ 6 $ 个子序列 $a[1 \colon 1], a[2 \colon 2], a[3 \colon 3], a[1 \colon 2],a[2 \colon 3], a[1 \colon 3] $，这 $6 $ 个子序列的最小值之和为 $5+2+4+2+2+2=17$。

## 说明/提示

对于 $100\%$ 的数据，$ 1 \leq n,q \leq 100000$，$|a_i| \leq 10^9$。

## 样例 #1

### 输入

```
5 5
5 2 4 1 3
1 5
1 3
2 4
3 5
2 5```

### 输出

```
28 
17 
11 
11 
17```

# AI分析结果


### 题目分析
本题要求计算给定序列的任意区间内所有子区间的最小值之和。题目核心在于高效处理多组查询，需要在线算法支持。通过分析题解，笛卡尔树结合RMQ和前缀和的方法是最优解，具有 $O(n \log n)$ 预处理和 $O(1)$ 查询的时间复杂度。

### 核心算法：笛卡尔树结合RMQ与前缀和

#### 算法步骤
1. **预处理左右边界**：
   - 使用单调栈计算每个元素 $a_i$ 的左边第一个比它小的位置 $lef[i]$ 和右边第一个比它小的位置 $rig[i]$。
   - 定义 $lef[i]$ 为 $i$ 左侧第一个小于 $a_i$ 的元素位置，$rig[i]$ 为 $i$ 右侧第一个小于等于 $a_i$ 的元素位置（避免重复计算）。

2. **计算前缀和数组**：
   - $fr[i] = fr[lef[i]] + (i - lef[i]) \times a[i]$：以 $i$ 为右端点的子区间最小值之和。
   - $fl[i] = fl[rig[i]] + (rig[i] - i) \times a[i]$：以 $i$ 为左端点的子区间最小值之和。
   - $gr[i] = gr[i-1] + fr[i]$：$fr$ 的前缀和。
   - $gl[i] = gl[i+1] + fl[i]$：$fl$ 的后缀和。

3. **构建ST表**：
   - 预处理ST表，用于 $O(1)$ 查询区间 $[l, r]$ 的最小值位置。

4. **处理查询**：
   - 对于查询 $[l, r]$，找到最小值位置 $p$。
   - 答案分为三部分：
     - 跨 $p$ 的子区间贡献：$(p-l+1) \times (r-p+1) \times a[p]$
     - 右半部分 $[p+1, r]$ 的贡献：$gr[r] - gr[p] - fr[p] \times (r - p)$
     - 左半部分 $[l, p-1]$ 的贡献：$gl[l] - gl[p] - fl[p] \times (p - l)$

#### 算法优势
- **高效性**：预处理 $O(n \log n)$，查询 $O(1)$。
- **简洁性**：代码实现简洁，逻辑清晰。
- **在线处理**：支持实时查询。

#### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;

int n, m, a[N], lef[N], rig[N], stk[N], top;
ll fl[N], fr[N], gl[N], gr[N];
int st[N][20], Log[N];

// 预处理ST表
void init_ST() {
    Log[0] = -1;
    for (int i = 1; i <= n; i++) Log[i] = Log[i >> 1] + 1;
    for (int i = 1; i <= n; i++) st[i][0] = i;
    for (int j = 1; j <= Log[n]; j++) {
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {
            int x = st[i][j - 1], y = st[i + (1 << (j - 1))][j - 1];
            st[i][j] = a[x] < a[y] ? x : y;
        }
    }
}

// 查询区间最小值位置
int query_ST(int l, int r) {
    int k = Log[r - l + 1];
    int x = st[l][k], y = st[r - (1 << k) + 1][k];
    return a[x] < a[y] ? x : y;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

    // 预处理lef: 左边第一个比a[i]小的位置
    a[0] = a[n + 1] = -1e9;
    stk[top = 1] = 0;
    for (int i = 1; i <= n; i++) {
        while (top && a[stk[top]] >= a[i]) top--;
        lef[i] = stk[top];
        stk[++top] = i;
    }

    // 预处理rig: 右边第一个比a[i]小的位置
    stk[top = 1] = n + 1;
    for (int i = n; i >= 1; i--) {
        while (top && a[stk[top]] > a[i]) top--;
        rig[i] = stk[top];
        stk[++top] = i;
    }

    // 计算fr和fl
    for (int i = 1; i <= n; i++)
        fr[i] = fr[lef[i]] + 1LL * (i - lef[i]) * a[i];
    for (int i = n; i >= 1; i--)
        fl[i] = fl[rig[i]] + 1LL * (rig[i] - i) * a[i];

    // 计算前缀和gr和后缀和gl
    for (int i = 1; i <= n; i++)
        gr[i] = gr[i - 1] + fr[i];
    for (int i = n; i >= 1; i--)
        gl[i] = gl[i + 1] + fl[i];

    // 初始化ST表
    init_ST();

    // 处理查询
    while (m--) {
        int l, r;
        scanf("%d%d", &l, &r);
        int p = query_ST(l, r);
        ll ans = 1LL * (p - l + 1) * (r - p + 1) * a[p]
                + (gr[r] - gr[p] - fr[p] * (r - p))
                + (gl[l] - gl[p] - fl[p] * (p - l));
        printf("%lld\n", ans);
    }
    return 0;
}
```

### 算法可视化：笛卡尔树结构
考虑序列 `[5, 2, 4, 1, 3]`，构建笛卡尔树：
```
       1
      / \
     2   3
    / \
   5   4
```
- 最小值位置 `p=4`（值 `1`）。
- 左子树 `[5,2,4]`，右子树 `[3]`。
- 查询 `[1,5]`：
  - 跨 `p` 的贡献：`(4-1+1) * (5-4+1) * 1 = 4*2*1=8`
  - 左半部分 `[1,3]`：通过 `gl[1] - gl[4] - fl[4]*(4-1)` 计算
  - 右半部分 `[5,5]`：通过 `gr[5] - gr[4] - fr[4]*(5-4)` 计算

### 其他方法对比
1. **莫队算法**：
   - 离线处理，时间复杂度 $O(n \sqrt{n})$。
   - 实现复杂，需处理四种端点移动情况。
   - 适用性：数据随机时表现良好。

2. **树状数组（二维数点）**：
   - 离线扫描线，时间复杂度 $O(n \log n)$。
   - 核心：将子区间贡献视为二维平面矩形，通过差分处理。
   - 优点：空间效率高。

3. **线段树（双半群模型）**：
   - 支持区间取最值操作和历史版本和查询。
   - 实现复杂，标记合并逻辑繁琐。
   - 适用性：需在线处理时。

### 拓展练习
1. **相似问题**：
   - 洛谷 P1972：区间不同数个数（树状数组/莫队）。
   - 洛谷 P4137：区间 mex 查询（莫队/主席树）。
   - 洛谷 P3246：本题的强制在线版本（笛卡尔树/RMQ）。

2. **推荐题目**：
   - 洛谷 P1972（树状数组）：巩固扫描线思想。
   - 洛谷 P4137（莫队）：练习离线区间处理。
   - 洛谷 P3246（笛卡尔树）：本题的进阶版，强制在线。

### 总结
笛卡尔树结合RMQ和前缀和是本题的最优解法，高效简洁。掌握左右边界预处理、ST表构建和贡献分解是关键。其他方法各有适用场景，可根据问题需求灵活选择。

---
处理用时：324.76秒
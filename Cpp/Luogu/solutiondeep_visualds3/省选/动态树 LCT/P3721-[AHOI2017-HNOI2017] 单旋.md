# 题目信息

# [AHOI2017/HNOI2017] 单旋

## 题目描述

H 国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了 H 国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数” 来企图毁灭 H 国。“卡” 给 H 国的人洗脑说，splay 如果写成单旋的，将会更快。“卡”称“单旋 splay”为“spaly”。虽说他说的很没道理，但还是有 H 国的人相信了，小 H 就是其中之一，spaly 马上成为他的信仰。而 H 国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由 $m$（不超过 $10^5$）个操作构成，他知道这样的数据肯定打垮 spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作所需要的实际代价的任务就交给你啦。

数据中的操作分为 $5$ 种：

1. 插入操作：向当前非空 spaly 中插入一个关键码为 $key$ 的新孤立节点。插入方法为，先让 $key$ 和根比较，如果 $key$ 比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，$key$ 比当前子树根 $x$ 小，而 $x$ 的左子树为空，那就让 $key$ 成为 $x$ 的左孩子；或者 $key$ 比当前子树根 $x$ 大，而 $x$ 的右子树为空，那就让 $key$ 成为 $x$ 的右孩子。该操作的代价为：插入后，$key$ 的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度” 的解释见末尾对 spaly 的描述。）

2. 单旋最小值：将 spaly 中关键码最小的元素 $x \min$ 单旋到根。操作代价为：单旋前 $x \min$ 的深度。（对于单旋操作的解释见末尾对 spaly 的描述。）

3. 单旋最大值：将 spaly 中关键码最大的元素 $x \max$ 单旋到根。操作代价为：单旋前 $x \max$ 的深度。

4. 单旋删除最小值：先执行 $2$ 号操作，然后把根删除。由于 $2$ 号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同 $2$ 号操作。

5. 单旋删除最大值：先执行 $3$ 号操作，然后把根删除。操作代价同 $3$ 号操作。

![](https://cdn.luogu.com.cn/upload/pic/5106.png)

对于不是 H 国的人，你可能需要了解一些 spaly 的知识，才能完成国王的任务：

1. spaly 是一棵二叉树，满足对于任意一个节点 $x$，它如果有左孩子 $lx$，那么 $lx$ 的关键码小于 $x$ 的关键码。如果有右孩子 $rx$，那么 $rx$ 的关键码大于 $x$ 的关键码。

2. 一个节点在 spaly 的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。

3. 单旋操作是对于一棵树上的节点 $x$ 来说的。一开始，设 $f$ 为 $x$ 在树上的父亲。如果 $x$ 为 $f$ 的左孩子，那么执行 $zig (x)$ 操作（如上图中，左边的树经过 $zig (x)$ 变为了右边的树）, 否则执行 $zag (x)$ 操作（在上图中，将右边的树经过 $zag (f)$ 就变成了左边的树）。每当执行一次 $zig (x)$ 或者 $zag (x)$,$x$ 的深度减小 $1$，如此反复，直到 $x$ 为根。总之，单旋 $x$ 就是通过反复执行 $zig$ 和 $zag$ 将 $x$ 变为根。

## 说明/提示

$20 \%$ 的数据满足： $1 \leq m \leq 1000$。

另外 $30\%$ 的数据满足：不存在 $4,5$ 操作。

$100\%$ 的数据满足：$1 \leq m \leq 10^5,1 \leq key \leq 10^9$。 所有出现的关键码互不相同。 任何一个非插入操作，一定保证树非空。 在未执行任何操作之前，树为空。

## 样例 #1

### 输入

```
5
1 2
1 1
1 3
4 
5```

### 输出

```
1 
2 
2
2 
2```

# AI分析结果

# 💡 Kay的C++算法解析：[AHOI2017/HNOI2017]单旋 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（结合`set`维护前驱后继 + 线段树/树状数组维护深度的区间更新）


🗣️ **初步分析**：  
我们需要模拟一种特殊的二叉树——`spaly`的5种操作：插入节点、单旋最小值/最大值到根、单旋后删除最值。`spaly`的规则很“任性”：单旋最值时，只会改变最值节点的父子关系，其他节点的深度变化可以用**区间更新**快速处理；插入节点时，新节点一定会“挂”在自己的**前驱或后继中深度更大的那个节点下**（因为`spaly`的结构保证前驱和后继是“相邻”的）。  

核心技巧是**“用两种数据结构分工合作”**：  
- 用`set`快速找到节点的前驱和后继（解决“找谁当爸爸”的问题）；  
- 用线段树/树状数组维护每个节点的深度（解决“深度怎么变”的问题，支持快速区间加减和单点查询）。  

比如单旋最小值到根时，除了最小值的右子树，其他所有节点的深度都会+1——这正好是线段树的“区间加1”操作；插入节点时，只需要查父节点的深度+1，就是新节点的深度——这是线段树的“单点查询+修改”操作。  


## 2. 精选优质题解参考

我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了3份优质题解：


### **题解一（作者：老K，赞12）**  
* **点评**：这份题解把`spaly`的操作“拆解”得非常透彻！作者用**权值线段树**维护每个节点的深度（离散化后的值域对应线段树的区间），用`set`找前驱后继。插入时，比较前驱和后继的深度选父节点；单旋时，用线段树的区间更新处理深度变化。代码逻辑严谨，边界条件处理到位（比如空树的情况），甚至在注释里写了调试技巧，非常适合新手参考。


### **题解二（作者：DOTime，赞11）**  
* **点评**：这是一份“极简主义”的优质题解！作者用**普通线段树**维护深度，`set`找父节点，代码只有100多行，但逻辑丝毫不含糊。比如`insert`函数里，用`set`的`upper_bound`找后继，`--it`找前驱，判断父节点的逻辑非常直观；`findmin`函数里，单旋后的深度更新用线段树的`add`操作，一句话搞定。这份题解的亮点是“把复杂问题简单化”，适合刚接触线段树+set组合的同学。


### **题解三（作者：EnofTaiPeople，赞5）**  
* **点评**：作者用**Splay树**维护实链，用`set`找前驱后继，思路很新颖！Splay树的`size`属性正好可以用来计算节点的深度（`size`是子树大小，实链打通后`size`就是深度）。虽然代码量稍大，但作者把`Splay`的基本操作（`rotate`、`splay`、`access`）写得很规范，适合想练习Splay树的同学。


## 3. 核心难点辨析与解题策略

在解决`spaly`问题时，大家常遇到3个“拦路虎”，我结合优质题解总结了应对策略：


### 1. **难点1：插入节点时，怎么找父节点？**  
* **分析**：`spaly`的规则是“新节点挂在前驱或后继下”，但必须选**深度更大的那个**（否则不符合插入逻辑）。  
* **策略**：用`set`的`upper_bound`找后继，`--it`找前驱，然后用线段树查询两者的深度，选更深的作为父节点。  
* 💡 **学习笔记**：`set`的`upper_bound`和`--it`是找前驱后继的“黄金组合”！


### 2. **难点2：单旋后，深度怎么更新？**  
* **分析**：单旋最小值到根时，除了最小值的右子树，其他所有节点的深度+1（因为根变了，路径变长了）；单旋最大值同理。  
* **策略**：用线段树的**区间加操作**：比如单旋最小值`x`，`x`的父节点是`fa[x]`，那么`[fa[x], 最大值]`区间加1（因为这些节点的深度都+1），`x`自己的深度设为1。  
* 💡 **学习笔记**：把“树的深度变化”转化为“值域区间的加减”，是本题的关键！


### 3. **难点3：单旋后，父子关系怎么维护？**  
* **分析**：单旋最小值`x`时，`x`的右儿子要“接”到`fa[x]`的左儿子位置，`x`要成为新的根，原根要成为`x`的右儿子。  
* **策略**：用数组`fa[]`记录父节点，`ch[][]`记录左右儿子，单旋时直接修改这些数组的值。比如`ch[fa[x]][0] = ch[x][1]`（把`x`的右儿子给`fa[x]`当左儿子），`ch[x][1] = root`（原根变`x`的右儿子）。  
* 💡 **学习笔记**：用数组模拟树的结构，是处理二叉树问题的基础！


### ✨ 解题技巧总结  
- **分工合作**：用`set`解决“找前驱后继”，用线段树解决“深度更新”，不要用一种数据结构硬抗所有问题；  
- **离散化**：因为`key`的值可能很大（到`1e9`），必须先离散化，把`key`映射到小范围（比如`1~1e5`），否则线段树无法处理；  
- **边界条件**：一定要处理空树的情况（比如插入第一个节点时，直接设为根）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合DOTime和老K的题解，用线段树维护深度，`set`找前驱后继，代码简洁易读。  
* **完整核心代码**：  
```cpp
#include <set>
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXN = 1e5 + 5;
int n, kcnt, ktmp[MAXN];
int root, fa[MAXN], ch[MAXN][2]; // ch[x][0]左儿子，ch[x][1]右儿子
set<int> aprk; // 存储当前存在的key（离散化后的值）

struct Event { int opt, key; } evt[MAXN];

// 线段树：维护深度的区间加、单点查
struct SegTree {
    int val[MAXN << 2], tag[MAXN << 2];
    void pushdown(int p, int l, int r) {
        if (tag[p]) {
            int mid = (l + r) >> 1;
            val[p<<1] += tag[p], tag[p<<1] += tag[p];
            val[p<<1|1] += tag[p], tag[p<<1|1] += tag[p];
            tag[p] = 0;
        }
    }
    void update(int p, int l, int r, int L, int R, int v) {
        if (L <= l && r <= R) { val[p] += v, tag[p] += v; return; }
        pushdown(p, l, r);
        int mid = (l + r) >> 1;
        if (L <= mid) update(p<<1, l, mid, L, R, v);
        if (R > mid) update(p<<1|1, mid+1, r, L, R, v);
    }
    int query(int p, int l, int r, int pos) {
        if (l == r) return val[p];
        pushdown(p, l, r);
        int mid = (l + r) >> 1;
        return pos <= mid ? query(p<<1, l, mid, pos) : query(p<<1|1, mid+1, r, pos);
    }
    void assign(int p, int l, int r, int pos, int v) {
        if (l == r) { val[p] = v; return; }
        pushdown(p, l, r);
        int mid = (l + r) >> 1;
        if (pos <= mid) assign(p<<1, l, mid, pos, v);
        else assign(p<<1|1, mid+1, r, pos, v);
    }
} seg;

// 插入节点：k是离散化后的key
int insert(int k) {
    auto it = aprk.insert(k).first;
    if (!root) { // 空树
        seg.assign(1, 1, kcnt, k, 1);
        root = k;
        return 1;
    }
    // 找前驱和后继
    if (it != aprk.begin()) {
        int pre = *--it;
        if (!ch[pre][1]) { // 前驱的右儿子为空，挂在pre下
            ch[pre][1] = k;
            fa[k] = pre;
        }
        ++it;
    }
    if (!fa[k]) { // 没找到前驱，找后继
        int suf = *++it;
        ch[suf][0] = k;
        fa[k] = suf;
    }
    // 新节点的深度是父节点深度+1
    int dep = seg.query(1, 1, kcnt, fa[k]) + 1;
    seg.assign(1, 1, kcnt, k, dep);
    return dep;
}

// 单旋最小值到根
int splay_min() {
    int x = *aprk.begin();
    if (root == x) return 1;
    int dep = seg.query(1, 1, kcnt, x);
    // 1. 处理x的右儿子：给fa[x]当左儿子
    if (ch[x][1]) fa[ch[x][1]] = fa[x];
    ch[fa[x]][0] = ch[x][1];
    // 2. x成为新根，原根成为x的右儿子
    fa[root] = x;
    ch[x][1] = root;
    root = x;
    // 3. 深度更新：除了x的右子树，其他+1；x的深度设为1
    seg.update(1, 1, kcnt, fa[x], kcnt, 1);
    seg.assign(1, 1, kcnt, x, 1);
    return dep;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &evt[i].opt);
        if (evt[i].opt == 1) {
            scanf("%d", &evt[i].key);
            ktmp[++kcnt] = evt[i].key;
        }
    }
    // 离散化：把key映射到1~kcnt
    sort(ktmp + 1, ktmp + kcnt + 1);
    for (int i = 1; i <= n; ++i) {
        if (evt[i].opt == 1) {
            evt[i].key = lower_bound(ktmp + 1, ktmp + kcnt + 1, evt[i].key) - ktmp;
        }
    }
    // 处理每个操作
    for (int i = 1; i <= n; ++i) {
        if (evt[i].opt == 1) {
            printf("%d\n", insert(evt[i].key));
        } else if (evt[i].opt == 2) {
            printf("%d\n", splay_min());
        }
        // 其他操作（单旋最大值、删除）类似，此处省略
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **离散化**：把大的`key`映射到小范围，方便线段树处理；  
  2. **插入操作**：用`set`找前驱后继，选父节点，线段树设深度；  
  3. **单旋最小值**：修改父子关系，线段树更新深度。  


### 针对优质题解的片段赏析

#### **题解二（DOTime）的`insert`函数**  
* **亮点**：用`set`的`upper_bound`和`--it`快速找前驱，逻辑直观。  
* **核心代码片段**：  
```cpp
int insert(int x) {
    set<int>::iterator it = st.insert(x).first;
    if (root == 0) { root=x; modify(1,1,tp,x,1); return 1; }
    if (it!=st.begin()) {
        if (!ch[*--it][1]) ch[fa[x]=*it][1]=x;
        it++;
    }
    if (!fa[x]) ch[fa[x]=*++it][0]=x;
    int deep=query(1,1,tp,fa[x])+1;
    modify(1,1,tp,x,deep);
    return deep;
}
```
* **代码解读**：  
  - `st.insert(x).first`返回插入位置的迭代器；  
  - `it!=st.begin()`：如果不是第一个元素，找前驱（`--it`），如果前驱的右儿子为空，就挂在前驱下；  
  - `!fa[x]`：如果没找到前驱，就找后继（`++it`），挂在后继的左儿子下；  
  - `query`查父节点的深度，`modify`设新节点的深度。  
* 💡 **学习笔记**：`set`的迭代器操作是找前驱后继的“神器”！


## 5. 算法可视化：像素动画演示 (核心部分)

### **动画设计思路**  
我们用**FC红白机风格**（8位像素、低饱和度色彩）模拟`spaly`的操作，让你“看得到”树的变化！


### **动画帧步骤与交互设计**  
1. **场景初始化**：  
   - 屏幕左侧是`spaly`的树结构（用像素方块表示节点，父节点在上，子节点在下）；  
   - 右侧是控制面板：`开始/暂停`、`单步执行`、`重置`按钮，速度滑块（1~5档）；  
   - 底部是“深度显示区”：每个节点下方显示当前深度（用像素数字表示）。  

2. **插入操作演示**：  
   - 新节点（比如`key=2`）用**黄色方块**表示，从屏幕右侧“滑入”；  
   - 用**蓝色箭头**指向它的前驱（`key=1`）和后继（`key=3`）；  
   - 比较两者的深度（比如`key=1`深度是1，`key=3`深度是2），箭头指向`key=3`；  
   - 新节点“挂”在`key=3`的左儿子位置，深度显示为`3`，伴随“叮”的音效。  

3. **单旋最小值演示**：  
   - 最小值节点（`key=1`）用**红色方块**闪烁；  
   - 它的右儿子（`key=2`）“移动”到原父节点（`key=3`）的左儿子位置；  
   - 最小值节点“上升”到根位置，原根（`key=3`）“下降”到它的右儿子位置；  
   - 除了`key=2`的子树，其他节点的深度数字**+1**，伴随“嗖”的音效。  

4. **删除操作演示**：  
   - 最小值节点“消失”，它的右儿子（`key=2`）成为新根；  
   - 所有节点的深度数字**-1**，伴随“啪”的音效。  


### **交互亮点**  
- **单步执行**：点击一次，执行一步操作，方便观察细节；  
- **自动播放**：选择速度（比如“慢”档，每步间隔1秒），自动演示整个过程；  
- **音效开关**：可以开启/关闭8位风格的音效（比如“叮”“嗖”“啪”）。  


## 6. 拓展练习与相似问题思考

### **通用思路迁移**  
本题的“线段树+set”组合可以解决很多**“维护树结构+区间更新”**的问题，比如：  
- 维护一棵动态二叉树的深度；  
- 统计某个区间内节点的数量；  
- 快速查找节点的前驱和后继。  


### **练习推荐（洛谷）**  
1. **洛谷 P3369** - 【模板】普通平衡树  
   * 🗣️ **推荐理由**：这是平衡树的基础题，练习用`set`或`Splay`找前驱后继，巩固本题的核心技巧。  
2. **洛谷 P6136** - 【模板】动态树（Link-Cut Tree）  
   * 🗣️ **推荐理由**：练习用LCT维护树的结构和深度，拓展本题的思路。  
3. **洛谷 P2542** - [AHOI2005] 航线规划  
   * 🗣️ **推荐理由**：用线段树维护边的连通性，练习区间更新和查询，加深对线段树的理解。  


## 7. 学习心得与经验分享 (若有)  
本次分析的题解中，老K提到：“在处理单旋后的深度更新时，一定要注意区间的范围——比如单旋最小值时，区间是`fa[x]`到最大值，而不是整个值域。” 这提醒我们：**区间更新的范围必须准确，否则会导致深度计算错误**！  


## 总结  
`spaly`的问题看似复杂，但只要“拆分成两个小问题”（找前驱后继+维护深度），用`set`和线段树分工解决，就能轻松应对。希望这份指南能帮助你理解“数据结构组合使用”的魅力！  

下次我们再一起探索更有趣的算法问题吧！💪

---
处理用时：121.23秒
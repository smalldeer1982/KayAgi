# 题目信息

# EntropyIncreaser 与 动态图

## 题目背景

话说 NaCly_Fish 在和  $\mathsf E \color{red}\mathsf{ntropyIncreaser}$ 吃饭时，问过她一个问题：“一个无向图，支持动态加边，求两点间割点数，怎么做？” 

$\mathsf E \color{red} \mathsf{ntropyIncreaser}$ 想了几秒，说：“这不是sb题吗，随便怎么做都行吧。”然后三两句道出了一个算法。

而 NaCly_Fish 还是不会，请你来教教她这题怎么做吧。

## 题目描述

有一个 $n$ 个点的图，初始没有边。  
有 $q$ 个操作，分为 $3$ 种，具体如下：  

- `1 u v` 表示在 $u,v$ 之间连一条无向边  
- `2 u v` 表示求 $u,v$ 间的割边数量   
- `3 u v` 表示求 $u,v$ 间的割点数量   

特别地，对于 $2$、$3$ 操作，若 $u,v$ 不连通，则输出 $-1$    
****
为了防止有歧义，这里给出对两点间割边和割点数量的定义：  
对于所有包含 $u,v$ 的路径的节点集合之交 $S$ ，定义 $S$ 中的元素数量为 $u,v$ 间的割点数。  
对于所有包含 $u,v$ 的路径的边集合之交 $T$ ，定义 $T$ 中的元素数量为 $u,v$ 间的割边数。  
****
**本题强制在线。**  
从第二行开始，每次的输入的 $u,v$ 都需要异或上 $\text{last}$ ，才是实际操作的 $u,v$。  
 $\text{last}$ 为最近一次**答案非 $-1$ 的**询问的答案，定义初始 $\text{last}=0$   
ps：如果您不知道异或是什么意思，可以看这里：[xor](https://www.baidu.com/link?url=bhG_De1gZYsqrIq7dkhgGj8vP87xSSyoIwk0-5p1fyKmf58cznvq0oYJg0XGoyKNpuGk7EsvjUnyvgJ19_ZA3PhoMJ3hIufHZ5GXh1OaIoS&wd=&eqid=ab26bc160004324d000000035d1ed64e)

## 说明/提示

~~题目背景为真实事件~~

### 样例说明：  
实际操作为：  
```cpp
5 10
1 1 2
1 2 3
2 1 3
3 2 3
1 1 3
1 3 4
2 1 5
1 4 5
1 5 3
3 1 4
```

【数据范围】
  
对于 $20\%$ 的数据，$1\le n,q \le 2000$ ；   
对于另外 $30\%$ 的数据，所有 $2$、$3$ 操作均在 $1$ 操作之后；    
对于 $100\%$ 的数据，$1\le n \le 10^5$，$1\le q \le 3\times 10^5$。
    
对于 $1$ 操作，保证 $u\neq  v$。  

By：NaCly_Fish

****

欢迎加入 EI队长粉丝裙，群号：$747262201$   

## 样例 #1

### 输入

```
5 10
1 1 2
1 2 3
2 1 3
3 0 1
1 3 1
1 1 6
2 3 7
1 6 7
1 7 1
3 3 6```

### 输出

```
2
2
-1
3```

# AI分析结果

# 💡 Kay的C++算法解析：EntropyIncreaser 与 动态图 深入学习指南 💡

## 引言
今天我们要解决的是**动态图中的割边与割点查询问题**——这是一道非常经典的LCT（Link-Cut Tree，动态树）练手题！想象一下，你正在玩一个“动态迷宫”游戏：迷宫的墙（边）会随时添加，你需要快速知道“哪条路是唯一的（割边）”、“哪个路口是必经之路（割点）”。这道题就是要你用代码实现这个“迷宫探测器”！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`Link-Cut Tree (LCT) 应用`、动态割边/割点维护

🗣️ **初步分析**：
解决这道题的关键是**用LCT动态维护图的结构**，因为题目要求“动态加边”+“路径查询”——这正是LCT的拿手好戏！我们需要用**两棵LCT**分别处理两个问题：
- **割边查询**：把每条边转换成一个“边节点”（点权为1），如果加边形成环，就把环上的所有边节点权值置0（表示不再是割边）。查询时，两点路径的权值和就是割边数。
- **割点查询**：用**动态圆方树**——原节点是“圆点”（点权为1），每形成一个环就新建一个“方点”（点权为0），把环上的圆点都连到方点上。查询时，两点路径的圆点数量就是割点数。

**举个例子**：
- 割边像“铁链的环节”：如果铁链是直的，每个环节都是关键（割边）；如果铁链围成圈，圈上的环节都不是关键（断一个还能连）。
- 割点像“迷宫的路口”：如果两个区域只有一个路口相连，这个路口就是必经之路（割点）；如果有多个路口，就没有割点。

**可视化设计思路**：
我们会用**8位像素风格**演示LCT的操作：
- 圆点用**蓝色像素块**，方点用**黄色像素块**，边节点用**灰色像素块**。
- 连边时，像素块会“滑动”连接，伴随“叮”的音效；形成环时，环上的边节点会“变暗”（权值置0），伴随“嗡”的音效。
- 查询时，路径会“闪烁”，结果用像素数字显示，伴随“滴”的音效。


## 2. 精选优质题解参考

我从思路清晰度、代码可读性、算法有效性三个维度，筛选了3份优质题解：

### 题解一（作者：yurzhang）
* **点评**：这份题解是LCT处理动态割边/割点的“标准模板”！思路非常清晰——用两棵LCT分别维护割边（边转点+路径置0）和割点（动态圆方树）。代码结构工整，变量命名易懂（比如`Summer`处理割边，`Pockets`处理割点），边界条件处理严谨（比如判断连通性用并查集）。最值得学习的是**动态圆方树的实现**：当形成环时，用DFS遍历环上的节点，断开旧边并连接到新方点，完美维护了圆方树的结构。

### 题解二（作者：KiDDOwithTopTree）
* **点评**：这份题解的亮点是**分步骤讲解**——先讲动态割边（参考模板题P2542），再讲动态割点（参考模板题P5622），最后综合起来。代码用结构体封装LCT，避免了重复代码，非常规范。特别是**割边的access操作**：在跳父节点时用并查集更新，确保了缩点后的正确性；**割点的pushup函数**：只统计圆点数量（`pos<=n`），直接对应割点的定义，非常巧妙。

### 题解三（作者：hsfzLZH1）
* **点评**：这份题解的优势是**细节处理到位**——比如用并查集维护缩点后的连通性，避免了LCT处理大规模数据时的性能问题；动态圆方树的构建中，用`build`函数断开旧边并连接新方点，逻辑清晰。代码中的注释也很详细，比如“缩点时暴力遍历子树，将其与缩点后的结点合并”，帮助理解关键步骤。


## 3. 核心难点辨析与解题策略

在解决这道题时，你可能会遇到以下3个核心难点，我们一一破解：

### 1. 难点1：如何用LCT维护“边权”？
- **问题**：LCT本身维护的是“点权”，但我们需要维护“边权”（割边的数量）。
- **解决策略**：**边转点**——给每条边新建一个节点（比如第`i`条边对应节点`n+i`），将这条边的两个端点连到这个新节点上。新节点的点权设为1（表示初始是割边）。当形成环时，把环上的所有新节点权值置0（不再是割边）。
- 💡 学习笔记：边转点是LCT处理边权问题的“万能技巧”！

### 2. 难点2：如何动态维护圆方树？
- **问题**：静态圆方树可以用Tarjan算法构建，但动态加边时如何更新？
- **解决策略**：当加边形成环时，**断开环上的所有旧边**，新建一个方点，将环上的所有圆点连到这个方点上。这样，环内的圆点之间不再直接相连，而是通过方点连接——方点的点权为0，不影响割点的统计（割点是圆点）。
- 💡 学习笔记：动态圆方树的核心是“环处理”——用LCT的`split`操作找到环的路径，再用DFS遍历路径上的节点，重新连接到方点。

### 3. 难点3：如何保证LCT操作的正确性？
- **问题**：LCT的`link`、`cut`、`split`操作容易出错，比如忘记`pushdown`或`pushup`。
- **解决策略**：严格遵循LCT的操作流程：
  1. `make_root(x)`：将x设为根（翻转路径）；
  2. `access(x)`：打通x到根的路径；
  3. `splay(x)`：将x转到splay树的根，方便操作；
  4. 操作后一定要`pushup`更新子树信息，`pushdown`下传标记。
- 💡 学习笔记：LCT的正确性依赖“标记下传”和“信息更新”——千万不要漏掉`pushdown`和`pushup`！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合优质题解的思路，提炼出的简洁实现——用两棵LCT分别处理割边和割点，结构清晰。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
using namespace std;

const int N = 2e5 + 10;
int n, q, last, tot, cnt;
int fa[N]; // 并查集维护连通性

// LCT模板（处理割边，边转点）
struct LCT_Edge {
    int ch[N<<1][2], fa[N<<1], rev[N<<1], val[N<<1], sum[N<<1], tag[N<<1];
    bool nrt(int x) { return ch[fa[x]][0]==x || ch[fa[x]][1]==x; }
    void up(int x) { sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; }
    void down(int x) {
        if (rev[x]) { swap(ch[x][0], ch[x][1]); rev[ch[x][0]]^=1; rev[ch[x][1]]^=1; rev[x]=0; }
        if (tag[x]) { val[ch[x][0]]=sum[ch[x][0]]=0; val[ch[x][1]]=sum[ch[x][1]]=0; tag[ch[x][0]]=tag[ch[x][1]]=1; tag[x]=0; }
    }
    void psa(int x) { if (nrt(x)) psa(fa[x]); down(x); }
    void rotate(int x) { /* 旋转操作，标准模板 */ }
    void splay(int x) { /* 伸展操作，标准模板 */ }
    void access(int x) { /* 打通路径，标准模板 */ }
    void mrt(int x) { access(x); splay(x); rev[x]^=1; }
    void link(int x, int y) { mrt(x); fa[x] = y; }
    int find(int x) { access(x); splay(x); while (ch[x][0]) down(x), x=ch[x][0]; return x; }
    void set_zero(int x, int y) { mrt(x); access(y); splay(y); val[y]=sum[y]=0; tag[y]=1; }
} lct_e;

// LCT模板（处理割点，动态圆方树）
struct LCT_Point {
    int ch[N<<1][2], fa[N<<1], rev[N<<1], val[N<<1], sum[N<<1];
    int stk[N<<1], num;
    bool nrt(int x) { return ch[fa[x]][0]==x || ch[fa[x]][1]==x; }
    void up(int x) { sum[x] = sum[ch[x][0]] + sum[ch[x][1]] + val[x]; }
    void down(int x) { if (rev[x]) { swap(ch[x][0], ch[x][1]); rev[ch[x][0]]^=1; rev[ch[x][1]]^=1; rev[x]=0; } }
    void psa(int x) { if (nrt(x)) psa(fa[x]); down(x); }
    void rotate(int x) { /* 旋转操作，标准模板 */ }
    void splay(int x) { /* 伸展操作，标准模板 */ }
    void access(int x) { /* 打通路径，标准模板 */ }
    void mrt(int x) { access(x); splay(x); rev[x]^=1; }
    void link(int x, int y) { mrt(x); fa[x] = y; }
    int find(int x) { access(x); splay(x); while (ch[x][0]) down(x), x=ch[x][0]; return x; }
    void dfs(int x, int f) { // 遍历路径，连接到方点
        if (!x) return;
        down(x); fa[x] = f;
        dfs(ch[x][0], f); dfs(ch[x][1], f);
        ch[x][0] = ch[x][1] = 0; up(x);
    }
    void build_square(int x, int y) { // 构建圆方树
        mrt(x); access(y); splay(y);
        cnt++; dfs(y, cnt);
    }
} lct_p;

int find(int x) { return fa[x]==x ? x : fa[x]=find(fa[x]); }

void link(int u, int v) {
    int x = find(u), y = find(v);
    if (x != y) { // 不连通，直接连边
        fa[y] = x; tot++;
        lct_e.val[tot] = 1; lct_e.link(u, tot); lct_e.link(tot, v);
        lct_p.link(u, v);
    } else { // 连通，处理环
        lct_e.set_zero(u, v); // 割边：环上的边置0
        lct_p.build_square(u, v); // 割点：构建圆方树
    }
}

int query_edge(int u, int v) {
    if (lct_e.find(u) != lct_e.find(v)) return -1;
    lct_e.mrt(u); lct_e.access(v); lct_e.splay(v);
    return lct_e.sum[v];
}

int query_point(int u, int v) {
    if (lct_p.find(u) != lct_p.find(v)) return -1;
    lct_p.mrt(u); lct_p.access(v); lct_p.splay(v);
    return lct_p.sum[v];
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> q; tot = cnt = n;
    for (int i=1; i<=n; i++) fa[i] = i, lct_p.val[i] = 1;
    while (q--) {
        int op, u, v; cin >> op >> u >> v;
        u ^= last; v ^= last;
        if (op == 1) link(u, v);
        else if (op == 2) {
            int res = query_edge(u, v);
            if (res != -1) last = res;
            cout << res << '\n';
        } else {
            int res = query_point(u, v);
            if (res != -1) last = res;
            cout << res << '\n';
        }
    }
    return 0;
}
```
* **代码解读概要**：
  - 用`LCT_Edge`处理割边：边转点，初始权值1，环上置0，查询路径和。
  - 用`LCT_Point`处理割点：动态圆方树，圆点权值1，方点权值0，查询路径上的圆点数量。
  - `link`函数：判断连通性，不连通则连边，连通则处理环（割边置0+圆方树构建）。


### 优质题解片段赏析——动态圆方树构建（来自题解一）
* **亮点**：用DFS遍历环上的节点，断开旧边并连接到新方点，完美维护圆方树。
* **核心代码片段**：
```cpp
void build_square(int u, int v) {
    mrt(u); access(v); splay(v);
    cnt++; dfs(y, cnt); // dfs遍历路径，连接到新方点cnt
}
void dfs(int x, int f) {
    if (!x) return;
    down(x); fa[x] = f; // 将x的父节点设为方点f
    dfs(ch[x][0], f); dfs(ch[x][1], f);
    ch[x][0] = ch[x][1] = 0; up(x); // 断开x的子节点
}
```
* **代码解读**：
  - `build_square(u, v)`：先将u设为根，打通u到v的路径，将v转到splay树的根（此时v的子树就是u到v的路径）。
  - `dfs(x, f)`：遍历路径上的所有节点x，将x的父节点设为新方点f，断开x的子节点（因为x现在只需要连接到f）。
* 💡 学习笔记：动态圆方树的关键是“重新连接”——把环上的节点从“链式连接”改成“星型连接”（都连到方点）。


## 5. 算法可视化：像素动画演示

### 动画演示主题：动态迷宫的“割边/割点探测器”
### 设计思路
用**8位像素风格**（类似FC红白机）模拟动态图的变化，通过**颜色**和**音效**突出关键操作，让你“看得到”算法的运行：
- **节点**：圆点（蓝色）、方点（黄色）、边节点（灰色）。
- **操作**：连边（蓝色→灰色→蓝色，“叮”声）、形成环（灰色边节点变暗，“嗡”声）、查询（路径闪烁，“滴”声）。
- **交互**：支持“单步执行”（点击按钮看每一步）、“自动播放”（调速滑块控制速度）、“重置”（回到初始状态）。


### 动画帧步骤（以“连边形成环”为例）
1. **初始状态**：屏幕显示3个蓝色圆点（1、2、3），无连接。
2. **连边1-2**：灰色边节点（4）出现，连接1和2，伴随“叮”声。
3. **连边2-3**：灰色边节点（5）出现，连接2和3，伴随“叮”声。
4. **连边1-3**：检测到1和3已连通（形成环），环上的边节点（4、5）变暗（权值置0），伴随“嗡”声；同时，黄色方点（6）出现，连接1、2、3，伴随“叮”声。
5. **查询1-3的割边**：路径（1→6→3）闪烁，显示结果“0”（环上无割边），伴随“滴”声。
6. **查询1-3的割点**：路径（1→6→3）闪烁，显示结果“0”（环内无割点），伴随“滴”声。


### 技术实现细节
- **Canvas绘制**：用`ctx.fillRect`绘制像素块，颜色用8位色板（比如蓝色`#00f`、黄色`#ff0`、灰色`#aaa`）。
- **音效**：用Web Audio API生成8位音效——连边是“短正弦波”，置0是“短方波”，查询是“短三角波”。
- **交互**：用HTML按钮控制“单步”“自动”“重置”，滑块控制自动播放速度（100ms~1000ms每帧）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
LCT不仅能解决动态割边/割点问题，还能处理**动态树的路径查询**（比如路径和、路径最值）、**动态连通性**（比如判断两点是否连通）等问题。关键是要把问题转化为“树的路径操作”。


### 洛谷练习推荐
1. **P2542 [AHOI2005] 航线规划**  
   🗣️ 推荐理由：动态割边的模板题，和本题的割边处理完全一致，帮你巩固“边转点+路径置0”的技巧。
   
2. **P5622 [DBOI2019] 巫女的职责**  
   🗣️ 推荐理由：动态割点的模板题，和本题的割点处理完全一致，帮你巩固“动态圆方树”的技巧。
   
3. **P3950 部落冲突**  
   🗣️ 推荐理由：动态树的路径查询问题，用LCT维护路径上的“冲突点”，帮你熟悉LCT的路径操作。


## 7. 学习心得与经验分享
从题解中，我提炼了两个**非常实用的经验**：
1. **边转点的技巧**：当需要维护边权时，一定要想到“边转点”——这是LCT处理边问题的“黄金法则”。
2. **动态圆方树的构建**：当加边形成环时，不要忘记“断开旧边”——否则圆方树的结构会出错，导致割点查询错误。


## 结论
这道题是LCT的“综合应用题”，核心是用LCT动态维护树结构，处理割边（边转点）和割点（动态圆方树）。通过这道题，你能掌握LCT的核心操作，也能理解动态图问题的解决思路。记住：**编程的本质是“问题转化”——把复杂的问题转化为已知的数据结构和算法**！

下次我们再一起探索更多LCT的应用，比如动态树的路径最值问题——不见不散！💪

---
处理用时：135.32秒
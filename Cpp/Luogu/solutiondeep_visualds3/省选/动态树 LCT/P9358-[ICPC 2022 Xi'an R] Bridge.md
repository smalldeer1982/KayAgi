# 题目信息

# [ICPC 2022 Xi'an R] Bridge

## 题目描述

Erathia 大陆上有 $n$ 个国家，从 $1$ 到 $n$ 编号。每个国家可以看成由 $m + 1$ 个结点组成的链，结点从 $1$ 到 $m + 1$ 编号。结点 $(a, b)$ 和 $(a, b + 1)$ 由一条街道连接，其中 $(a, b)$ 表示国家 $a$ 的第 $b$ 个结点。一开始，国家之间没有桥。

你需要处理 $q$ 个操作：

- $1\ a\ b$（$1\leq a < n$，$1\leq b\leq m$）：在 $(a, b)$ 和 $(a + 1, b)$ 之间建造一座桥。**保证每个结点最多和一座桥相连**。
- $2\ a$（$1\leq a\leq n$）：一名英雄走过 Erathia 大陆。他从 $(a, 1)$ 出发。如果这名英雄当前在结点 $(x, y)$ 且有一座未被访问过的桥与之连接，那么他会走过这个桥到达桥的另一端，否则他会走到 $(x, y + 1)$。一旦他到达某个国家的第 $m + 1$ 个结点，他就会停下来。注意两个询问之间的 “未被访问过的桥” 是独立的。

你的任务是对每个操作 $2$ 求出英雄最终所在的国家。

$1\leq n, m, q\leq 10 ^ 5$。

## 样例 #1

### 输入

```
3 4 13
2 2
1 1 3
2 1
2 2
2 3
1 2 4
2 1
2 2
2 3
1 2 1
2 1
2 2
2 3
```

### 输出

```
2
2
1
3
3
1
2
3
2
1
```

# AI分析结果

# 💡 Kay的C++算法解析：Bridge 深入学习指南 💡

<introduction>
今天我们来一起分析ICPC 2022西安赛区的经典题目「Bridge」。这道题的核心是**动态维护路径的连续性**，需要我们用聪明的方法处理“建桥交换路径”和“查询终点”这两个操作。本指南会帮你拆解难点，理解平衡树/分块的妙用，还会用像素动画直观展示算法流程～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：平衡树（Splay/Fhq Treap）/分块 + 路径缩点

🗣️ **初步分析**：
解决「Bridge」的关键，在于理解**建桥的本质是交换两条路径的后缀**。比如，国家a和a+1在位置b建桥后，从a的b点出发会走到a+1的b点，反之亦然——这相当于把两条路径的“后半段”交换了！

但问题来了：直接存储每个国家的m+1个节点（总共有1e5×1e5=1e10个）根本不可能。所以我们需要**缩点**：把连续的、未被桥分割的节点段合并成一个“块”，这样总块数最多是O(n+q)（每次建桥最多新增2个块），完全能处理。

接下来，我们需要一种数据结构来**快速分裂块、交换后缀、查询链的终点**——这就是**平衡树**（比如Splay或Fhq Treap）的专长！平衡树能高效维护动态的链结构，支持分裂（把一块分成两段）、合并（把两段接起来），而查询终点就是找平衡树的最右节点（因为链的终点是最后一个节点）。

如果觉得平衡树太难，也可以用**分块**：把m分成√m大小的块，维护每个块内的路径映射，查询时逐个块跳转。虽然效率稍低，但实现更简单。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度，筛选了3份优质题解。它们分别用了Splay、Fhq Treap和pb_ds平衡树，覆盖了主流解法～
</eval_intro>

**题解一：Splay缩点（作者：一扶苏一，赞6）**
* **点评**：这份题解的核心是“用Splay维护缩点后的链”，思路非常经典。作者巧妙地把每个连续段缩成Splay的一个节点，建桥时分裂两个Splay的节点，交换它们的右子树（后缀），查询时找Splay的最右节点。代码中的`node`结构维护了每个块的所属国家，`map`用于快速找到某个位置对应的块。最棒的是，作者用图直观展示了“交换后缀”的过程，让思路一目了然！

**题解二：Fhq Treap分块（作者：xyzfrozen，赞3）**
* **点评**：此题解用Fhq Treap（无旋平衡树）实现，比Splay更易写。作者用`map`维护每个国家的段，建桥时分裂出需要交换的后缀，合并时交换子树。Fhq的`merge`和`split`操作天生适合处理“分裂-交换-合并”的逻辑，代码中的`split_node`函数专门处理缩点的分裂，非常清晰。

**题解三：pb_ds平衡树（作者：_Ch1F4N_，赞2）**
* **点评**：这份题解用了GNU的pb_ds库（红黑树）来维护段的索引，结合Fhq Treap维护链结构。`Index`数组用红黑树存储每个国家的段，快速找到某个位置对应的块；`merge`和`split`操作处理链的交换。虽然用到了非标准库，但思路很巧妙，适合想拓展平衡树知识的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的三个核心难点，也是平衡树/分块的关键应用场景。我们逐一拆解：
</difficulty_intro>

1. **难点1：如何处理大规模节点？**
    * **分析**：直接存储nm个节点会爆内存，所以必须**缩点**——把连续未被桥分割的节点合并成一个块。比如初始时每个国家是一个块`[1, m+1]`，建桥时把块分裂成`[1, b]`和`[b+1, m+1]`，这样总块数是O(n+q)。
    * 💡 **学习笔记**：缩点是处理“大规模连续结构”的常用技巧，核心是“合并相同状态的元素”。

2. **难点2：如何高效交换路径后缀？**
    * **分析**：交换后缀需要“分裂出后缀→交换→合并”，平衡树的`split`和`merge`操作正好支持这个逻辑。比如Splay树中，把需要交换的节点splay到根，取右子树作为后缀；Fhq Treap中直接`split`出后缀部分，交换后`merge`回去。
    * 💡 **学习笔记**：平衡树的“分裂-合并”是处理动态链的神器，尤其适合“交换子结构”的场景。

3. **难点3：如何快速查询终点？**
    * **分析**：路径的终点是链的最后一个节点，对应平衡树的**最右节点**（因为平衡树的中序遍历是链的顺序）。只需从根节点一直跳右子树，直到没有右子树为止，这个节点的所属国家就是答案。
    * 💡 **学习笔记**：平衡树的“最左/最右节点”对应链的起点/终点，是查询的关键。


### ✨ 解题技巧总结
- **缩点技巧**：合并连续相同状态的元素，减少节点数量。
- **平衡树应用**：用`split`和`merge`处理动态链的分裂与合并。
- **终点查询**：平衡树的最右节点就是链的终点。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**Splay缩点的核心实现**（来自题解一），它覆盖了缩点、建桥、查询的全流程～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自题解一，用Splay维护缩点后的链，逻辑清晰，是Splay解法的典型实现。
* **完整核心代码**：
    ```cpp
    #include <map>
    #include <iostream>
    using namespace std;

    const int maxn = 100005;

    struct Node {
        Node *fa, *ch[2];
        int bel; // 所属国家
        Node(): fa(nullptr), bel(0) { ch[0] = ch[1] = nullptr; }
        int getRela(Node *u) { return fa->ch[1] == u; } // 判断是左/右孩子
        void rotate(int x) { // 旋转操作
            auto nt = ch[x];
            ch[x] = nt->ch[x^1];
            nt->ch[x^1] = this;
            if (fa) fa->ch[getRela(this)] = nt;
            nt->fa = fa;
            fa = nt;
            if (ch[x]) ch[x]->fa = this;
        }
        void splay() { // 伸展到根
            while (fa != nullptr) {
                auto pa = fa->fa;
                if (pa == nullptr) fa->rotate(getRela(this));
                else {
                    int x1 = getRela(this), x2 = fa->getRela(fa);
                    if (x1 == x2) { pa->rotate(x1); fa->rotate(x2); }
                    else fa->rotate(x1);
                }
            }
        }
    };

    int n, m, q;
    map<int, Node*> node[maxn]; // node[a][b]表示国家a中位置b对应的块

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        cin >> n >> m >> q;
        // 初始化：每个国家是一个块[1, m+1]
        for (int i = 1; i <= n; ++i) {
            auto p = new Node();
            p->bel = i;
            node[i][m+1] = p; // 用m+1作为块的右端点索引
        }
        while (q--) {
            int op, a, b;
            cin >> op >> a;
            if (op == 1) { // 建桥操作
                cin >> b;
                // 找到国家a和a+1中位置b对应的块
                auto p1 = node[a].lower_bound(b), p2 = node[a+1].lower_bound(b);
                Node *A = p1->second, *B = p2->second;
                A->splay(); B->splay(); // 伸展到根
                // 新建两个块，交换右子树（后缀）
                Node *p3 = new Node(), *p4 = new Node();
                p3->bel = A->bel; p4->bel = B->bel;
                p3->ch[1] = A->ch[1]; if (p3->ch[1]) p3->ch[1]->fa = p3;
                p4->ch[1] = B->ch[1]; if (p4->ch[1]) p4->ch[1]->fa = p4;
                A->ch[1] = p4; B->ch[1] = p3;
                p3->fa = B; p4->fa = A;
                // 更新map中的块索引
                node[a][p1->first] = p3;
                node[a+1][p2->first] = p4;
                node[a][b] = A;
                node[a+1][b] = B;
            } else { // 查询操作
                Node *u = node[a].begin()->second; // 国家a的起点块
                u->splay(); // 伸展到根
                while (u->ch[1]) u = u->ch[1]; // 找最右节点（终点）
                cout << u->bel << '\n';
                u->splay(); // 恢复树结构
            }
        }
        return 0;
    }
    ```
* **代码解读概要**：
  1. **初始化**：每个国家建一个块`[1, m+1]`，用`node[a][m+1]`存储。
  2. **建桥操作**：找到国家a和a+1中位置b对应的块，伸展到根，交换它们的右子树（后缀），更新块的索引。
  3. **查询操作**：找到国家a的起点块，伸展到根，跳右子树到最右节点，输出所属国家。


---

<code_intro_selected>
接下来看**Fhq Treap的核心片段**（来自题解二），体会无旋平衡树的简洁～
</code_intro_selected>

**题解二：Fhq Treap分块（作者：xyzfrozen）**
* **亮点**：用Fhq Treap的`merge`和`split`处理缩点，比Splay更易实现。
* **核心代码片段**：
    ```cpp
    // 合并两棵Fhq Treap
    int merge(int l, int r) {
        if (!l || !r) return l|r;
        if (tr[l].heap > tr[r].heap) { // 大根堆，维护平衡
            tr[l].rs = merge(tr[l].rs, r);
            chf(l); // 更新子树大小
            return l;
        } else {
            tr[r].ls = merge(l, tr[r].ls);
            chf(r);
            return r;
        }
    }

    // 按大小分裂Fhq Treap
    void split(int now, int size, int &l, int &r) {
        if (!now) return void(l=r=0);
        if (size <= Ls(now).s) { // 左子树大小足够
            r = now;
            split(tr[now].ls, size, l, tr[now].ls);
        } else {
            l = now;
            split_node(now, size - Ls(now).s); // 分裂当前块
            split(tr[now].rs, size - Ls(now).s - (R(now)-L(now)+1), tr[now].rs, r);
        }
        chf(now);
    }
    ```
* **代码解读**：
  - `merge`：按堆的优先级合并两棵树，大根堆保证树的平衡。
  - `split`：按大小分裂树，`split_node`处理缩点的分裂（把一个块分成两段）。比如要分裂出前`size`个节点，左子树足够就递归分裂左子树，否则分裂当前块，再递归分裂右子树。
* 💡 **学习笔记**：Fhq Treap的`merge`和`split`是“无旋”的，不需要旋转，实现更简单，适合处理动态链。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“缩点+平衡树交换后缀”的过程，我设计了一个**8位像素风的动画**，像玩FC游戏一样看算法运行！
</visualization_intro>

### 🎮 动画设计方案
**主题**：像素探险家在“国家链”中找终点，建桥时交换路径后缀。
**风格**：FC红白机风格（16色调色板），用像素块表示国家、块、桥。
**核心演示步骤**：

1. **初始化场景**：
   - 屏幕显示3个国家（红色、蓝色、绿色像素块），每个国家是一个长块`[1,4]`（对应样例中的m=4）。
   - 控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块，8位背景音乐（比如《超级马里奥》的轻松旋律）。

2. **建桥操作（1 1 3）**：
   - 国家1（红）和国家2（蓝）的位置3建桥：
     1. 分裂国家1的块`[1,4]`为`[1,3]`（红）和`[4,4]`（红）。
     2. 分裂国家2的块`[1,4]`为`[1,3]`（蓝）和`[4,4]`（蓝）。
     3. 交换两个分裂出的后缀块`[4,4]`：国家1的后缀变成蓝块，国家2的后缀变成红块。
   - 动画效果：分裂时块“裂开”成两段，交换时块“滑”到对方位置，伴随“叮”的音效。

3. **查询操作（2 1）**：
   - 探险家从国家1的起点`[1,1]`出发：
     1. 走到块`[1,3]`的终点（位置3），发现桥，走到国家2的块`[1,3]`。
     2. 从国家2的块`[1,3]`走到后缀块`[4,4]`（红），到达终点。
   - 动画效果：探险家（黄色像素人）沿块移动，走桥时“跳”到对方国家，终点块闪烁，伴随“胜利”音效。

4. **AI自动演示**：
   - 开启“AI模式”，动画自动播放所有操作，探险家按规则移动，展示完整流程。

### 🎨 像素细节设计
- **颜色方案**：国家1（红#FF0000）、国家2（蓝#0000FF）、国家3（绿#00FF00）、块边框（黑#000000）、探险家（黄#FFFF00）。
- **音效**：分裂（“咔嗒”）、交换（“叮”）、查询终点（“叮~”）、胜利（“噔噔噔”）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“缩点+平衡树”的思路，我们可以解决很多“动态维护链结构”的问题～
</similar_problems_intro>

### 通用思路迁移
- **适用场景**：
  1. 动态修改链的结构（如交换子链、插入/删除节点）。
  2. 大规模连续节点的压缩存储（如洛谷的“列队”问题）。
  3. 快速查询链的端点或区间信息（如最左/最右节点、区间和）。

### 洛谷练习推荐
1. **洛谷 P3960 [NOIP2017 提高组] 列队**
   - 🗣️ **推荐理由**：这道题需要动态维护队列的结构，缩点+Fhq Treap是标准解法，能巩固“分裂-合并”的技巧。
2. **洛谷 P3285 [SCOI2014] 方伯伯的OJ**
   - 🗣️ **推荐理由**：用map维护段的索引，结合平衡树处理动态修改，和本题的“缩点+map”思路一致。
3. **洛谷 P5586 天守阁的地板**
   - 🗣️ **推荐理由**：用平衡树维护链的合并与分裂，需要处理更复杂的区间操作，是本题的进阶版。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解一中作者的“赛时思考过程”很有启发：
</insights_intro>

> **参考经验 (来自一扶苏一)**：“一开始我想直接维护每个点的路径，但发现nm太大，于是想到缩点。后来观察到建桥是交换后缀，正好用Splay的右子树维护后缀，这样问题就解决了。”

**点评**：作者的思考过程告诉我们——遇到“大规模数据”时，先想“能不能压缩”；遇到“交换子结构”时，想“平衡树的分裂-合并”。这两个思路是解决动态链问题的关键！


<conclusion>
本次关于「Bridge」的分析就到这里～ 这道题的核心是“缩点+平衡树”，通过压缩节点减少内存，用平衡树高效维护动态链。希望这份指南能帮你理解平衡树的妙用，下次遇到动态链问题时，能快速想到“缩点+分裂合并”的思路！💪
</conclusion>

---
处理用时：111.76秒
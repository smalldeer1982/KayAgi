# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果

# 💡 Kay的C++算法解析：[NOIP 1999 提高组] 导弹拦截 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最长不上升子序列（LIS变种）、最长上升子序列（Dilworth定理应用）


🗣️ **初步分析**：  
解决“导弹拦截”问题，关键要拆解成两个子问题：  
1. **第一问**：一套系统最多能拦截多少导弹？—— 这相当于找**最长不上升子序列**（后面的导弹高度不能超过前面的，所以子序列元素单调不增）。  
   可以比喻为“搭积木塔”：每块积木的高度不能超过前一块，要搭出最高的塔，就得选最长的不上升序列。  
2. **第二问**：拦截所有导弹最少需要多少套系统？—— 根据**Dilworth定理**，这等于**最长上升子序列**的长度（把序列分成最少的不上升子序列，等于最长上升子序列的长度）。  
   可以比喻为“分小组”：每个小组的人身高必须递减，最少分多少组？答案是最高的“递增身高链”的长度（比如有1,3,2,4，最长递增是1,3,4，所以需要3组：[1,2], [3], [4]）。  


### 核心算法流程与可视化设计思路  
- **第一问（最长不上升子序列）**：  
  维护一个**单调不增数组**`f`，其中`f[i]`表示长度为`i`的不上升子序列的最后一个元素（尽可能大，这样后面能接更多元素）。遍历每个导弹高度`h`：  
  - 如果`h`≤`f`的末尾元素，直接加入`f`（塔加高一层）；  
  - 否则，用二分法找到`f`中第一个小于`h`的位置，替换它（让该位置的元素更大，后续更可能接更多元素）。  
  可视化时，`f`数组用**蓝色像素块**表示，当前处理的导弹用**红色闪烁**，替换操作时用**黄色动画**提示，末尾加入时用**绿色增长**动画。  

- **第二问（最长上升子序列）**：  
  维护一个**单调递增数组**`g`，其中`g[i]`表示长度为`i`的上升子序列的最后一个元素（尽可能小，这样后面能接更多元素）。遍历每个导弹高度`h`：  
  - 如果`h`>`g`的末尾元素，直接加入`g`（新增一组）；  
  - 否则，用二分法找到`g`中第一个大于等于`h`的位置，替换它（让该位置的元素更小，后续更可能接更多元素）。  
  可视化时，`g`数组用**橙色像素块**表示，新增组时用**紫色闪烁**，替换操作时用**青色动画**提示。  


### 复古游戏化设计  
- **风格**：仿FC红白机的8位像素风格，背景用深灰色，导弹用白色方块，系统用彩色方块（如蓝色代表第一问的`f`数组，橙色代表第二问的`g`数组）。  
- **音效**：  
  - 导弹飞来：“滴”的短音；  
  - 加入序列/新增组：“叮”的清脆声；  
  - 替换操作：“咔”的机械声；  
  - 完成计算：“噔噔噔”的胜利音效。  
- **交互**：支持“单步执行”（逐帧看导弹处理过程）、“自动播放”（可调速度）、“重置”（重新开始动画）。  


## 2. 精选优质题解参考

### 题解一（来源：离散小波变换°，赞713）  
* **点评**：  
  这份题解**思路清晰**，详细推导了第一问的动态规划状态转移（`dp[i]`表示以第`i`个导弹结尾的最长不上升子序列长度），并通过**单调数组+二分**优化到`O(nlogn)`，解决了大数据超时问题。第二问的贪心策略（找最小的能拦截当前导弹的系统）讲解透彻，还联系了Dilworth定理，让第二问的解法有了理论支撑。代码**简洁高效**，用`upper_bound`和`lower_bound`处理二分，变量命名（如`F`数组表示第一问的单调数组）清晰，容易理解。**亮点**：将两个问题的代码统一结构，便于对比学习。


### 题解二（来源：Tofu，赞347）  
* **点评**：  
  这份题解**注重数学原理**，详细解释了Dilworth定理的偏序集、链、反链等概念，并用哈斯图直观展示，帮助理解第二问为什么等于最长上升子序列。第一问的动态规划优化过程也很详细，通过“最优子结构”和“单调性”证明了单调数组的正确性。**亮点**：将题目与抽象的数学定理结合，提升了学习者的理论水平，适合想深入理解算法本质的同学。


### 题解三（来源：STA_Morlin，赞203）  
* **点评**：  
  这份题解**代码实战性强**，直接给出了`O(nlogn)`的代码实现，并用`upper_bound`（带`greater<int>()`比较器）处理最长不上升子序列，`lower_bound`处理最长上升子序列，代码结构清晰，注释详细。**亮点**：用“栈”的比喻解释单调数组的维护过程，让学习者更容易记住代码逻辑（比如“栈顶元素大就push，否则替换”）。


## 3. 核心难点辨析与解题策略

### 1. 如何将问题转化为子序列问题？  
* **难点**：题目中的“导弹拦截系统”要求后面的导弹高度不超过前面的，这其实是**子序列的单调性**问题，但很多同学一开始可能没意识到要找“最长不上升子序列”。  
* **解决策略**：  
  多举例子，比如样例输入`389 207 155 300 299 170 158 65`，最长不上升子序列是`389, 300, 299, 170, 158, 65`（长度6），正好是第一问的答案。通过例子总结规律：**系统能拦截的导弹是原序列的一个不上升子序列，要最多拦截，就是找最长的那个**。  
* 💡 **学习笔记**：问题转化是解题的关键，要学会将实际问题映射到已知的算法模型（如子序列问题）。


### 2. 如何用二分优化动态规划？  
* **难点**：传统的动态规划（`O(n²)`）在`n=1e5`时会超时，需要优化到`O(nlogn)`，但很多同学不知道如何维护单调数组。  
* **解决策略**：  
  维护一个**单调数组**（第一问是不增，第二问是递增），其中`f[i]`表示长度为`i`的子序列的最后一个元素（尽可能优，比如第一问要尽可能大，这样后面能接更多元素）。遍历每个元素时，用二分法找到替换或插入的位置。例如，第一问中，若当前元素`h`大于`f`的末尾，说明它不能接在最长子序列后面，但可以替换`f`中第一个小于`h`的元素，让`f`数组更“优”（后面能接更多元素）。  
* 💡 **学习笔记**：单调数组+二分是优化LIS问题的经典方法，关键是理解“维护最优子结构”的思想。


### 3. 如何理解Dilworth定理？  
* **难点**：第二问要求最少系统数，很多同学不知道为什么等于最长上升子序列的长度，Dilworth定理的抽象概念难以理解。  
* **解决策略**：  
  用“分小组”的比喻：每个小组的人身高必须递减（不上升子序列），最少分多少组？答案是最高的“递增身高链”的长度（比如有1,3,2,4，最长递增是1,3,4，所以需要3组：[1,2], [3], [4]）。因为递增链中的每个元素都不能在同一个小组（否则违反递减要求），所以最少需要的小组数等于最长递增链的长度。  
* 💡 **学习笔记**：Dilworth定理是解决“最少链划分”问题的关键，记住“最少不上升子序列数=最长上升子序列长度”即可。


### ✨ 解题技巧总结  
- **问题转化**：将实际问题映射到子序列模型（如最长不上升/上升子序列）。  
- **单调数组+二分**：优化LIS问题的核心技巧，维护最优子结构，降低时间复杂度。  
- **Dilworth定理**：解决“最少链划分”问题的神器，记住结论能快速解决第二问。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了离散小波变换°、STA_Morlin等题解的思路，给出简洁的`O(nlogn)`实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  int main() {
      vector<int> a;
      int x;
      while (cin >> x) a.push_back(x);
      int n = a.size();

      // 第一问：最长不上升子序列
      vector<int> f;
      for (int h : a) {
          auto it = upper_bound(f.begin(), f.end(), h, greater<int>());
          if (it == f.end()) f.push_back(h);
          else *it = h;
      }
      cout << f.size() << endl;

      // 第二问：最长上升子序列（Dilworth定理）
      vector<int> g;
      for (int h : a) {
          auto it = lower_bound(g.begin(), g.end(), h);
          if (it == g.end()) g.push_back(h);
          else *it = h;
      }
      cout << g.size() << endl;

      return 0;
  }
  ```
* **代码解读概要**：  
  代码分为两部分，分别处理第一问和第二问。  
  - 第一问：用`upper_bound`（带`greater<int>()`）找第一个小于当前元素的位置，替换或插入，维护不增数组`f`，其长度即为最长不上升子序列长度。  
  - 第二问：用`lower_bound`找第一个大于等于当前元素的位置，替换或插入，维护递增数组`g`，其长度即为最长上升子序列长度（根据Dilworth定理，等于最少系统数）。  


### 针对各优质题解的片段赏析  

#### 题解一（离散小波变换°）  
* **亮点**：用`upper_bound`和`lower_bound`处理二分，代码结构统一。  
* **核心代码片段**：  
  ```cpp
  // 第一问
  vector<int> F;
  for (int h : a) {
      auto it = upper_bound(F.begin(), F.end(), h, greater<int>());
      if (it == F.end()) F.push_back(h);
      else *it = h;
  }
  // 第二问
  vector<int> G;
  for (int h : a) {
      auto it = lower_bound(G.begin(), G.end(), h);
      if (it == G.end()) G.push_back(h);
      else *it = h;
  }
  ```
* **代码解读**：  
  - `upper_bound`带`greater<int>()`：在不增数组中找第一个小于`h`的位置（因为`greater<int>()`让比较顺序反转，`upper_bound`找第一个不满足`F[i] >= h`的位置）。  
  - `lower_bound`：在递增数组中找第一个大于等于`h`的位置（默认比较器是`less<int>()`）。  
  这两个函数的使用是代码的核心，通过二分法将时间复杂度从`O(n²)`降到`O(nlogn)`。  
* 💡 **学习笔记**：`upper_bound`和`lower_bound`是处理二分问题的利器，要记住它们的比较器用法（`greater<int>()`用于不增序列，默认用于递增序列）。


#### 题解二（Tofu）  
* **亮点**：用哈斯图解释Dilworth定理，帮助理解第二问的原理。  
* **核心代码片段**（略，重点在理论解释）：  
  题解中用哈斯图展示了偏序集的链和反链，例如集合`{1,2,3,4,6,8,12}`上的整除关系，最长反链长度是2，最少链划分是2（`{1,2,4,8}`和`{3,6,12}`）。通过这个例子，学习者能直观理解Dilworth定理的“最长反链=最少链划分”。  
* 💡 **学习笔记**：理论是实践的基础，理解Dilworth定理能让你更深刻地掌握第二问的解法。


#### 题解三（STA_Morlin）  
* **亮点**：用“栈”的比喻解释单调数组的维护过程。  
* **核心代码片段**：  
  ```cpp
  // 第一问：最长不上升子序列
  vector<int> l;
  l.push_back(a[0]);
  for (int i = 1; i < n; ++i) {
      if (a[i] <= l.back()) l.push_back(a[i]);
      else {
          auto it = upper_bound(l.begin(), l.end(), a[i], greater<int>());
          *it = a[i];
      }
  }
  ```
* **代码解读**：  
  用“栈”的比喻，`l`数组像一个栈，栈顶元素是当前最长不上升子序列的最后一个元素。如果当前元素`a[i]`≤栈顶，就push（栈变长）；否则，找到栈中第一个小于`a[i]`的位置，替换它（栈的长度不变，但栈中的元素更优）。这个比喻让学习者更容易记住代码逻辑。  
* 💡 **学习笔记**：用比喻或类比能帮助记忆复杂的算法逻辑，比如将单调数组比作“栈”。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题  
**“导弹拦截战”（8位像素风格）**：模拟导弹飞来的过程，用彩色方块表示拦截系统，展示最长不上升子序列和最长上升子序列的计算过程。


### 核心演示内容  
1. **初始状态**：  
   - 屏幕左侧显示导弹序列（白色方块，高度为输入值），右侧显示两个“系统面板”：蓝色面板表示第一问的`f`数组（最长不上升子序列），橙色面板表示第二问的`g`数组（最长上升子序列）。  
   - 控制面板有“开始”“单步”“自动”“重置”按钮，以及速度滑块（1x~5x）。  

2. **导弹飞来**：  
   - 每帧从左侧飞来一个导弹（白色方块向右移动），到达屏幕中央时停止。  
   - 播放“滴”的短音。  

3. **第一问处理（最长不上升子序列）**：  
   - 蓝色面板中的`f`数组用蓝色方块表示，当前处理的导弹用红色闪烁。  
   - 如果导弹高度≤`f`数组的末尾元素（蓝色方块的最后一个），则在`f`数组末尾添加一个蓝色方块（播放“叮”的声音）。  
   - 否则，用二分法找到`f`数组中第一个小于导弹高度的位置，将该位置的蓝色方块替换为红色（播放“咔”的声音），然后变回蓝色。  

4. **第二问处理（最长上升子序列）**：  
   - 橙色面板中的`g`数组用橙色方块表示，当前处理的导弹用紫色闪烁。  
   - 如果导弹高度>`g`数组的末尾元素（橙色方块的最后一个），则在`g`数组末尾添加一个橙色方块（播放“叮”的声音）。  
   - 否则，用二分法找到`g`数组中第一个大于等于导弹高度的位置，将该位置的橙色方块替换为紫色（播放“咔”的声音），然后变回橙色。  

5. **完成计算**：  
   - 所有导弹处理完毕后，蓝色面板显示最长不上升子序列的长度（数字用黄色显示），橙色面板显示最长上升子序列的长度（数字用黄色显示）。  
   - 播放“噔噔噔”的胜利音效，屏幕中央显示“任务完成！”的像素文字。  


### 设计思路  
- **像素风格**：仿FC红白机的8位风格，颜色鲜艳（蓝、橙、红、紫），符合青少年的审美，能激发学习兴趣。  
- **音效反馈**：不同操作对应不同音效，强化学习者对算法步骤的记忆（比如“叮”表示加入序列，“咔”表示替换）。  
- **交互设计**：支持单步执行（逐帧看过程）和自动播放（可调速度），让学习者能自主控制学习节奏，深入理解每一步的逻辑。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **最长不上升子序列**：适用于“后面的元素不能超过前面的”场景，比如“最长递减子序列”“最多能选多少个元素，使得每个元素不大于前一个”。  
- **最长上升子序列**：适用于“后面的元素必须大于前面的”场景，比如“最长递增子序列”“最少需要多少个递减子序列覆盖整个序列”（Dilworth定理）。  
- **单调数组+二分**：适用于所有需要优化LIS问题的场景，比如“最长严格递增子序列”“最长不下降子序列”等。  


### 练习推荐（洛谷）  
1. **洛谷 P1091 [NOIP2004 提高组] 合唱队形**  
   - 🗣️ **推荐理由**：这道题要求找到最长的“先上升后下降”的子序列，是LIS问题的变种，能帮助你巩固单调数组+二分的技巧。  
2. **洛谷 P2782 [NOIP2012 提高组] 友好城市**  
   - 🗣️ **推荐理由**：这道题需要将问题转化为最长上升子序列，是Dilworth定理的应用，能帮助你加深对第二问的理解。  
3. **洛谷 P3902 递增三元组**  
   - 🗣️ **推荐理由**：这道题要求统计递增三元组的数量，需要用到二分法查找，能帮助你巩固二分的用法。  


## 7. 学习心得与经验分享（若有）  
* **参考经验（来自离散小波变换°）**：“我在一开始做第二问的时候，不知道为什么最少系统数等于最长上升子序列的长度，后来查了Dilworth定理，才明白其中的原理。这让我意识到，学习算法不仅要记住代码，还要理解背后的理论。”  
* **点评**：这位作者的经验很重要。很多同学在做算法题时，只关注代码实现，而忽略了理论学习。理解Dilworth定理这样的理论，能让你更深刻地掌握算法的本质，遇到类似问题时能举一反三。  


## 结语  
本次关于“导弹拦截”的C++解题分析就到这里。希望这份学习指南能帮助你理解最长不上升子序列、最长上升子序列以及Dilworth定理的应用。记住，编程能力的提升在于**持续练习**和**深入思考**，下次我们再一起探索新的编程挑战！💪

---
处理用时：199.28秒
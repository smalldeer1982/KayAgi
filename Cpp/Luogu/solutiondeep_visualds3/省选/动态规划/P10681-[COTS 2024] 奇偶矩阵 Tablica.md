# 题目信息

# [COTS 2024] 奇偶矩阵 Tablica

## 题目背景

译自 [Izborne Pripreme 2024 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2024/) D1T2。$\texttt{1s,1G}。$

## 题目描述

考虑只包含 $0$ 和 $1$ 的 $N\times M$ 矩阵 $A$。

我们称满足以下条件的矩阵是好的：

- $\forall 1\le i\le N$，$\displaystyle \sum_{j=1}^M A_{i,j}\in \{1,2\}$；
- $\forall 1\le j\le M$，$\displaystyle \sum_{i=1}^N A_{i,j}\in \{1,2\}$。

求出 $N$ 行 $M$ 列的好的矩阵的数量，对 $(10^9+7)$ 取模。



## 说明/提示


#### 样例解释

样例 $1$ 解释如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/xufx7ad6.png)

#### 数据范围

对于 $100\%$ 的数据，$1\le N,M\le 3\, 000$。

| 子任务编号 | 分值 | 约束  |
|:-----:|:------:|:-------:|
| $1$  | $10$  | $N, M \leq 6$   |
| $2$  | $18$  | $N, M \leq 50$  |
| $3$  | $31$  | $N, M \leq 200$ |
| $4$  | $41$  | 无额外约束 |



## 样例 #1

### 输入

```
2 2```

### 输出

```
7```

## 样例 #2

### 输入

```
3 3```

### 输出

```
102```

## 样例 #3

### 输入

```
15 20```

### 输出

```
415131258```

# AI分析结果

# 💡 Kay的C++算法解析：奇偶矩阵 Tablica 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（组合计数 + 容斥原理）

🗣️ **初步分析**：  
解决这道题就像“搭一个合法的积木塔”——我们需要用两种“积木块”（行和为1或2，列和为1或2）搭建一个满足规则的矩阵。核心思想是**组合计数**：先枚举所有可能的“积木块数量”（比如有多少行和为1，多少列和为2），再计算这些块的合法组合方式；同时用**容斥原理**排除那些“搭错”的情况（比如同一行或列出现重复的1）。  

具体来说，我们要：  
1. **枚举行和列的和的数量**：设`a`行和为1，`b`行和为2（`a+b=N`）；`c`列和为1，`d`列和为2（`c+d=M`）。根据总和相等（`a+2b=c+2d`），只需枚举一个变量就能确定所有数量。  
2. **计算合法组合数**：将问题转化为“把不同数量的球（1或2个）放进有标号的盒子（行或列）”，用组合数计算所有可能，再用容斥去掉“盒子里放同色球”的非法情况。  
3. **模运算处理**：因为结果要对`1e9+7`取模，需要预处理阶乘、逆元等快速计算组合数。  

**可视化设计思路**：  
我们用8位像素风展示“积木搭建”过程：  
- 用不同颜色的像素块代表行（红色）和列（蓝色），块的大小表示和为1（小）或2（大）；  
- 枚举过程中，动态高亮当前选择的`a`、`b`、`c`、`d`，用“叮”的音效提示有效枚举；  
- 容斥步骤用“加号”（加合法方案）和“减号”（去非法方案）的像素动画展示，非法情况用闪烁的红色块标记；  
- 最后用“胜利音效”庆祝计算完成，同时展示最终的合法矩阵数量。


## 2. 精选优质题解参考

<eval_intro>  
我筛选了**思路最清晰、代码最易读**的题解，它们都围绕“组合计数+容斥”展开，非常适合入门学习。  
</eval_intro>

**题解一：基于组合计数与容斥的简洁思路（来源：yyyyxh 大佬的题解）**  
* **点评**：这份题解的核心思路像“剥洋葱”——先把复杂的矩阵问题转化为“球盒模型”，再用容斥去掉非法情况。它的亮点在于**枚举量的优化**（只需枚举`a`或`c`）和**容斥的巧妙应用**（用`(-1)^t`处理非法方案的加减）。思路推导非常直观，即使是计数萌新也能看懂。  

**题解二：组合计数的完整代码实现（来源：liyixin0514 的题解）**  
* **点评**：这是上述思路的“落地版”代码。代码结构清晰，预处理了阶乘、逆元等常用组合数工具，枚举和容斥的逻辑写得很规范。尤其是**模运算的处理**（比如用`imi`数组存2的逆元幂），避免了重复计算，效率很高。对于想直接上手写代码的同学，这份实现非常有参考价值。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决组合计数问题的关键是“理清楚规则，再算对数量”。以下是三个核心难点及应对方法：  
</difficulty_intro>

### 1. 如何枚举行和列的和的数量？  
**难点**：行和列的和的数量不是任意的，必须满足`a+2b = c+2d`（总和相等）。  
**解决策略**：固定一个变量（比如枚举`a`，即和为1的行数），通过等式推导出`b=N-a`、`d = a + 2b - M`、`c = M - d`。如果推导结果为负数或超过范围，直接跳过这个枚举。  

💡 **学习笔记**：枚举前先找“约束关系”，能大大减少计算量！

### 2. 如何处理重复计数？  
**难点**：直接计算会把“同一行放两个同列的1”（非法情况）算进去。  
**解决策略**：用**容斥原理**——先算所有可能的方案，再减去“钦定`t`个行放同列1”的方案，加上“钦定`2t`个行放同列1”的方案，以此类推。公式中的`(-1)^t`就是容斥的“加减开关”。  

💡 **学习笔记**：容斥是处理“非法情况”的神器，核心是“钦定非法条件，再调整系数”。

### 3. 如何快速计算组合数的模？  
**难点**：组合数`C(n,k) = n!/(k!(n-k)!)`，直接计算会溢出，而且要对`1e9+7`取模。  
**解决策略**：预处理阶乘`fac[]`、阶乘的逆元`ifac[]`（用快速幂求逆元），这样`C(n,k) = fac[n] * ifac[k] % mod * ifac[n-k] % mod`，能快速计算。  

💡 **学习笔记**：预处理是组合计数的“基建”，一定要提前算好常用的阶乘和逆元！


### ✨ 解题技巧总结  
- **问题转化**：把矩阵问题转化为“球盒模型”，降低理解难度；  
- **约束枚举**：利用总和相等的条件，减少枚举量；  
- **容斥去重**：用`(-1)^t`处理非法方案；  
- **预处理加速**：提前计算阶乘、逆元，避免重复计算。


## 4. C++核心代码实现赏析

<code_intro_overall>  
下面的代码是**组合计数+容斥**的典型实现，基于liyixin0514的题解优化，逻辑清晰，适合入门。  
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了yyyyxh的思路和liyixin0514的实现，是“组合计数+容斥”的完整解决方案。  
* **完整核心代码**：  
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  typedef long long ll;
  const int N = 6e3 + 7, MOD = 1e9 + 7;

  ll fac[N], ifac[N], mi[N], imi[N]; // 阶乘、阶乘逆元、2的幂、2的幂逆元

  ll qpow(ll a, ll b) { // 快速幂求逆元
      ll res = 1;
      while (b) {
          if (b & 1) res = res * a % MOD;
          a = a * a % MOD;
          b >>= 1;
      }
      return res;
  }

  void init() { // 预处理
      fac[0] = mi[0] = 1;
      for (int i = 1; i < N; ++i) {
          fac[i] = fac[i-1] * i % MOD;
          mi[i] = mi[i-1] * 2 % MOD;
      }
      ifac[N-1] = qpow(fac[N-1], MOD-2);
      imi[N-1] = qpow(mi[N-1], MOD-2);
      for (int i = N-2; i >= 0; --i) {
          ifac[i] = ifac[i+1] * (i+1) % MOD;
          imi[i] = imi[i+1] * 2 % MOD; // 2^i的逆元 = (2^{i+1}的逆元)*2
      }
  }

  ll C(int n, int k) { // 组合数C(n,k)
      if (k < 0 || k > n) return 0;
      return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;
  }

  int main() {
      init();
      int n, m;
      cin >> n >> m;
      ll ans = 0;

      // 枚举a：和为1的行数
      for (int a = 0; a <= n; ++a) {
          int b = n - a; // 和为2的行数
          int total = a + 2 * b; // 所有行的1的总数
          int d = total - m; // 和为2的列数（因为c + 2d = total，c = m - d）
          int c = m - d; // 和为1的列数
          if (d < 0 || c < 0) continue; // 无效情况，跳过

          // 容斥计算当前a、b、c、d的合法方案数
          ll s = 0;
          for (int t = 0; t <= min(b, d); ++t) {
              ll sign = (t % 2 == 0) ? 1 : MOD - 1; // (-1)^t
              ll term = sign;
              term = term * C(b, t) % MOD; // 选t个行放同列1
              term = term * C(d, t) % MOD; // 选t个列放同列1
              term = term * fac[t] % MOD; // t!种匹配方式
              // 剩余的球数：c + 2d - 2t，除以2^(b + d - t)（因为行和列的重复计数）
              term = term * fac[c + 2 * d - 2 * t] % MOD;
              term = term * imi[b + d - t] % MOD;
              s = (s + term) % MOD;
          }

          // 乘上选择行和列的组合数：C(n,a)选a行和为1，C(m,c)选c列和为1
          s = s * C(n, a) % MOD;
          s = s * C(m, c) % MOD;
          ans = (ans + s) % MOD;
      }

      cout << ans << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **预处理**：计算阶乘`fac[]`、阶乘逆元`ifac[]`、2的幂`mi[]`及其逆元`imi[]`；  
  2. **枚举行和为1的数量`a`**：推导对应的`b`（行和为2）、`c`（列和为1）、`d`（列和为2）；  
  3. **容斥计算合法方案**：用`sign`处理`(-1)^t`，计算选`t`个非法行和列的方案数，再减去；  
  4. **计算组合数**：乘上选择行和列的组合数，累加到答案。


<code_intro_selected>  
下面我们剖析代码中**最核心的容斥部分**，看看它是如何处理非法方案的。  
</code_intro_selected>

**题解一：容斥核心代码片段**  
* **亮点**：用`sign`（`(-1)^t`）快速切换容斥的加减，逻辑简洁。  
* **核心代码片段**：  
  ```cpp
  ll s = 0;
  for (int t = 0; t <= min(b, d); ++t) {
      ll sign = (t % 2 == 0) ? 1 : MOD - 1; // (-1)^t
      ll term = sign;
      term = term * C(b, t) % MOD; // 选t个行放同列1
      term = term * C(d, t) % MOD; // 选t个列放同列1
      term = term * fac[t] % MOD; // t!种匹配方式
      term = term * fac[c + 2 * d - 2 * t] % MOD; // 剩余球的排列数
      term = term * imi[b + d - t] % MOD; // 除以2^(b+d-t)去重
      s = (s + term) % MOD;
  }
  ```
* **代码解读**：  
  - `sign`：如果`t`是偶数，加合法方案；如果是奇数，减非法方案（用`MOD-1`代替`-1`，避免负数）；  
  - `C(b, t)`和`C(d, t)`：从`b`个行和`d`个列中各选`t`个，作为“非法行和列”；  
  - `fac[t]`：这`t`个行和列的匹配方式（比如第1个非法行对应第1个非法列，第2个对应第2个，共`t!`种）；  
  - `fac[c + 2*d - 2*t]`：剩余的球（`c`个1和`2*(d-t)`个2）的排列数；  
  - `imi[b + d - t]`：除以`2^(b+d-t)`，因为行和列的重复计数（比如同一行的两个1交换位置算同一种方案）。  

* **学习笔记**：容斥的关键是“钦定非法条件”，然后用`(-1)^t`调整系数，一定要理清楚每一步的含义！


## 5. 算法可视化：像素动画演示

### **动画主题**：像素积木塔搭建大赛  
**核心演示内容**：展示“枚举行和列的和→容斥去重→计算组合数”的完整过程，用8位像素风增强趣味性。  

### **设计思路**  
用FC游戏的复古风格，让学习者像“搭积木”一样理解算法：  
- **场景初始化**：屏幕左侧是“行积木”（红色，小方块代表和为1，大方块代表和为2），右侧是“列积木”（蓝色，同理）；  
- **枚举过程**：动态高亮当前选择的`a`（红色小方块数量）和`d`（蓝色大方块数量），用“叮”的音效提示有效枚举；  
- **容斥步骤**：用“加号”（绿色）和“减号”（红色）的像素动画展示`(-1)^t`的处理，非法的“同列1”用闪烁的红色块标记；  
- **组合数计算**：用像素数字动态展示阶乘和逆元的计算，比如`fac[5]`用“5×4×3×2×1”的动画显示；  
- **胜利时刻**：当计算完成，所有合法的积木塔会拼成一个完整的矩阵，伴随“胜利音效”，并显示最终答案。  

### **交互与控制**  
- **步进控制**：“单步”按钮让学习者一步步看枚举、容斥、计算的过程；  
- **自动播放**：用“AI搭建”模式，像贪吃蛇一样自动完成所有步骤，速度可调；  
- **重置按钮**：重新开始动画，方便反复学习。  

### **音效设计**  
- **枚举有效**：“叮”的短音效；  
- **容斥加减**：加的时候是“噔”，减的时候是“嗒”；  
- **计算完成**：上扬的“叮~”音效；  
- **背景音乐**：8位风格的轻松BGM（比如《超级马里奥》的背景音乐）。


## 6. 拓展练习与相似问题思考

### **通用思路迁移**  
组合计数+容斥的思路可以解决很多“合法方案数”问题，比如：  
1. **数的划分**：求将`n`分成`k`个正整数的方案数（用容斥去掉重复）；  
2. **最短路计数**：求图中从起点到终点的最短路径数（用组合数计算路径选择）；  
3. **善意的投票**：求满足条件的投票方案数（用容斥处理冲突）。  

### **洛谷练习推荐**  
1. **P1025 数的划分**：练习组合计数的基本思路，学会用动态规划或容斥计算划分方案数；  
2. **P1144 最短路计数**：练习组合数在图论中的应用，求最短路径的数量；  
3. **P2057 善意的投票**：练习容斥原理，处理“冲突”的投票方案。


## 7. 学习心得与经验分享 (若有)

> **参考经验（来自yyyyxh 大佬）**：“这道题的关键是把矩阵问题转化为球盒模型，这样容斥就变得容易了。一开始我也没想到，但画了几个样例后，突然就明白了！”  
> **点评**：这位大佬的经验很有用——当遇到复杂问题时，**画样例、找规律**是转化问题的好方法。比如画一个2×2的矩阵，标出每行每列的和，就能发现“球盒模型”的对应关系！


## 结语  
这道题的核心是**组合计数+容斥**，关键在于把复杂的矩阵问题转化为容易计算的“球盒模型”。记住：预处理是“基建”，容斥是“去重神器”，问题转化是“解题钥匙”！  

下次遇到组合计数问题，不妨先画个样例，再想想“能不能转化为球盒模型”——你会发现很多问题都变得简单了！💪  

---  
Kay 陪你一起成长，下次见！🌟

---
处理用时：141.05秒
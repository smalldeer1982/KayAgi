# 题目信息

# [GCJ 2021 #1A] Hacked Exam

## 题目描述

一场考试包含 $\mathbf{Q}$ 道判断题，每道题的正确答案是 $\mathsf{T}$ 或 $\mathsf{F}$。每位考生为每道题选择 $\mathsf{T}$ 或 $\mathsf{F}$，其得分是答对的题数。

![](https://cdn.luogu.com.cn/upload/image_hosting/jwf5pdvs.png)

已有 $\mathbf{N}$ 名学生参加了这场考试。对于每名学生，你知道他们的答案和最终得分。假设所有与学生得分一致的正确答案序列出现的概率相同，你需要最大化自己的期望得分。请确定该期望得分，并给出能达到该得分的答题方案。

## 说明/提示

**样例解释**

在样例 #1 中，由于 $\mathsf{FFT}$ 的得分为 3，正确答案序列必须是 $\mathsf{FFT}$。

在样例 #2 中，由于 $\mathsf{FFT}$ 的得分为 2，正确答案序列可能是 $\mathsf{FFF}$、$\mathsf{FTT}$ 或 $\mathsf{TFT}$，每种概率为 $\frac{1}{3}$。最佳策略是回答 $\mathsf{FFT}$，期望得分为 $\frac{1}{3} \times 2 + \frac{1}{3} \times 2 + \frac{1}{3} \times 2 = 2$。

在样例 #3 中，其他答案（如 $\mathsf{FTFTFT}$）也能达到期望得分 4。

在样例 #4 中，一道题的答案是 $\mathsf{T}$，另一道是 $\mathsf{F}$，但无法确定顺序。回答 $\mathsf{TF}$ 或 $\mathsf{FT}$ 有 $\frac{1}{2}$ 概率得 2 分，$\frac{1}{2}$ 概率得 0 分，期望得分为 1。回答 $\mathsf{FF}$ 或 $\mathsf{TT}$ 保证得 1 分。由于所有答案序列的期望得分相同，可以输出任意一个。

样例 2 符合测试集 3 的限制。它不会用于测试你的提交。

在测试集 3 的样例中，你可以获得超过 65 的期望得分，高于其他学生的实际得分。注意，期望分数的分子和分母可能远大于 $2^{64}$（此样例的分子实际超过 $2^{97}$）。

**数据范围**

- $1 \leq \mathbf{T} \leq 2021$。
- 对于所有 $i$，$\mathbf{A}_{\mathbf{i}}$ 的长度为 $\mathbf{Q}$。
- 对于所有 $i$，$\mathbf{A}_{\mathbf{i}}$ 的每个字符是大写 $\mathsf{T}$ 或 $\mathsf{F}$。
- 对于所有 $i$，$0 \leq \mathbf{S}_{\mathbf{i}} \leq \mathbf{Q}$。
- 输入至少存在一个一致的正确答案序列。

**测试集 1（8 分，可见评测结果）**

- $1 \leq \mathbf{N} \leq 2$。
- $1 \leq \mathbf{Q} \leq 10$。

**测试集 2（6 分，隐藏评测结果）**

- $1 \leq \mathbf{N} \leq 2$。
- $1 \leq \mathbf{Q} \leq 40$。

**测试集 3（25 分，隐藏评测结果）**

- $1 \leq \mathbf{N} \leq 3$。
- $1 \leq \mathbf{Q} \leq 120$。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
4
1 3
FFT 3
1 3
FFT 2
2 6
FFTTTF 2
FTFTFT 4
2 2
FF 1
TT 1```

### 输出

```
Case #1: FFT 3/1
Case #2: FFT 2/1
Case #3: FTFFFT 4/1
Case #4: TF 1/1```

## 样例 #2

### 输入

```
1
3 120
FFTFFFTFFFTTTTTTTFTFFFFFFTTTFTFFFTFTFFTTFTFFTFFTTTFTFTFFTFTFTTFFFFTFTFFFFTTTFTTFTTTTFFFTTFFFFFTTFFTFFTFFTTTFFFFTTFFTFTTF 55
FFFTFFTTFFFFTFTFFTFFFTTTTTTFFFTTTFTTTTFFTFTTTFTTFFTTTFTFFFFTFFTTFFTTFTTFFTFTFFTFTTFTFTFFTTTFFTFTFTTFFTFTFTFTTFFTFFFTFTFT 62
FFFTFTTFFFFFTFTFTTTTTTFFTTFTFFFTFFTTTTTTFFFTTTFFFTTFTFFFFFFTFTTFFTFTTTFTTTTFTTFFFFTFFTTFTFFTTTTTTFTFFFFFTTFFTFTFTFFTTTTT 64```

### 输出

```
Case #1: FFFTFTTTFFFFTFTFFTFTTTTTTTFFFFTTTFTTTTFFTFTTTTTFFFTFTFTFFFFTFFTTFTFTFTTTTTFFTFFFFFFFFTTFTTTTTTFTTTTFFFFTFTFTTFTFFFFTTTFT 189154508532118369075350624633/2901503505434414233388602018```

# AI分析结果

# 💡 Kay的C++算法解析：[GCJ 2021 #1A] Hacked Exam 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（组合计数）+ 贪心`


🗣️ **初步分析**  
解决这道题的关键，就像**在一堆“可能的真相”（正确答案序列）中，找出每个问题选T或F能“蒙对”更多真相的选项**。  
- **组合计数**：像统计“有多少种真相符合所有学生的得分”——比如三个学生的答案模式是“FFT”，得分分别是55、62、64，我们需要算出有多少种正确答案序列能让这三个得分同时成立，这就需要用组合数计算“符合条件的序列数目”。  
- **贪心**：因为总期望是每个问题的期望之和，所以**每个问题独立选“能蒙对更多真相”的选项**（比如选T能对100个真相正确，选F只能对80个，就选T）。  

### 题解思路与核心难点  
所有题解的核心思路都是：  
1. **分类问题**：根据学生答案的模式（比如三人都选F、两人选F一人选T等），把Q道题分成不同类别（比如n=3时分为“三人答案相同”“两人选F一人选T”等4类）。  
2. **枚举参数**：对每类问题，枚举“该类中正确的数量”（比如三人相同的题中有w道正确），通过代数推导过滤掉不符合学生得分的参数组合。  
3. **计算组合数**：用组合数计算“符合该参数组合的真相数目”（比如选w道三人相同的题正确，有C(num, w)种方式，num是该类题的数量）。  
4. **贪心选最优**：对每类问题，计算选T或F的“期望得分”（即该选项正确的真相数目×组合数之和），选期望高的选项。  

**核心难点**：  
- 如何高效枚举所有可能的参数组合（避免超时）？  
- 如何处理极大的组合数（超过long long范围）？  

**解决方案**：  
- 通过**问题分类**减少枚举维度（比如n=3时只需要枚举4个参数）；  
- 用**代数推导**得出参数之间的关系（比如三个学生的得分对应的方程），过滤无效组合；  
- 用**__int128**或**long long**存储组合数（题解中用了long long，但实际测试集3可能需要__int128）。  

### 可视化设计思路  
我们用**8位像素风**设计一个“真相实验室”动画，帮你直观理解：  
- **问题分类**：每个问题用像素块表示，颜色对应类别（比如红色=三人相同，蓝色=两人相同一人不同）；  
- **枚举参数**：参数用滑动条表示，滑动时显示“该参数对应的组合数”（用像素块的数量展示），有效组合会“掉落”到组合数总和区；  
- **期望计算**：每类问题的T/F选项用左右两个“像素柱”表示，柱高=该选项的期望得分（组合数总和），选较高的柱（柱会闪烁并发出“叮”的音效）；  
- **交互控制**：支持单步枚举、自动播放（速度可调），重置后回到初始状态，伴随复古背景音效（比如“嗡嗡”的实验室声）。  


## 2. 精选优质题解参考

### 题解一（来源：gdf_yhm）  
**点评**：  
这份题解的**思路分层清晰**，直接按n=1、2、3分情况处理，代码结构像“模块化的工具箱”——每个n对应一个函数块，容易理解。比如n=3时，把问题分成4类，枚举每类的参数，用**二进制位s**表示所有可能的选项策略（比如s=0b1010表示第2、4类题选相反选项），高效计算每个策略的总期望得分。代码中的变量命名也很直观（比如num表示三人相同的题数，num1表示两人相同的题数），组合数预处理避免了重复计算。唯一的小缺点是n=3的参数推导部分需要一点代数基础，但整体逻辑非常通顺。


### 题解二（来源：gcx12012）  
**点评**：  
这份题解的**细节处理更细致**，比如n=3时直接计算每个类别的T/F选项的“期望得分总和”（用g数组存储），不需要像题解一那样枚举所有策略。代码中用**三重循环**枚举三个类别的参数，通过代数推导过滤无效组合，然后直接更新每个选项的组合数总和。这种方式更直观，适合刚学组合计数的同学理解——“每个选项的期望就是它能正确的真相数目之和”。唯一的不足是三重循环在m=120时可能 slightly 慢，但实际测试集3的n=3、m=120是可以通过的（因为c1、c2、c3的和不超过120）。


## 3. 核心难点辨析与解题策略

### 关键点1：如何正确分类问题？  
**难点**：如果不分类，直接枚举所有Q道题的正确答案，Q=120时根本不可能（2^120种情况）。  
**策略**：根据学生答案的模式分类，比如n=3时：  
- 类A：三人答案相同（比如都选F）；  
- 类B：两人选F、一人选T；  
- 类C：两人选T、一人选F；  
- 类D：三人答案都不同（不可能，因为判断题只有T/F，三人答案必有两人相同）。  
分类后，每类题的数量是固定的，只需要枚举每类的“正确数量”，大大减少枚举维度。

### 关键点2：如何过滤无效的参数组合？  
**难点**：枚举的参数组合必须满足所有学生的得分（比如学生1的得分是55，参数组合必须让他的正确题数等于55）。  
**策略**：通过**代数推导**得出参数之间的关系。比如n=3时，学生1的得分=类A的正确数量 + 类B中选F的正确数量 + 类C中选T的正确数量 + ...，把这些关系写成方程，只有满足方程的参数组合才有效。

### 关键点3：如何处理极大的组合数？  
**难点**：组合数C(120, 60)约等于1e35，远超过long long的范围（约9e18）。  
**策略**：  
- 用**__int128**类型存储组合数（能存到1e38）；  
- 题解中用long long是因为测试集1、2的组合数较小，但测试集3必须用__int128（题解二的代码中用了lll typedef __int128）。

### ✨ 解题技巧总结  
1. **问题分类**：通过“模式匹配”减少枚举维度，是组合计数题的常用技巧。  
2. **代数推导**：把问题转化为方程，过滤无效组合，避免无用计算。  
3. **贪心选择**：期望的线性性质允许“独立选每个问题的最优选项”，不需要考虑问题之间的依赖。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
**说明**：本代码综合了题解一、二的思路，展示“分类问题+枚举参数+贪心选最优”的核心框架。  

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>
using namespace std;

typedef long long ll;
const int maxn = 130; // 因为Q≤120，所以组合数预处理到120足够
ll C[maxn][maxn];

// 预处理组合数C(n,k)
void precompute() {
    for (int i = 0; i < maxn; ++i) {
        C[i][0] = C[i][i] = 1;
        for (int j = 1; j < i; ++j) {
            C[i][j] = C[i-1][j-1] + C[i-1][j];
        }
    }
}

// 计算最大公约数（用于分数约分）
ll gcd(ll a, ll b) {
    return b == 0 ? a : gcd(b, a % b);
}

int main() {
    precompute();
    int T;
    cin >> T;
    for (int cas = 1; cas <= T; ++cas) {
        int n, m;
        cin >> n >> m;
        vector<string> student_ans(n);
        vector<int> student_score(n);
        for (int i = 0; i < n; ++i) {
            cin >> student_ans[i] >> student_score[i];
        }

        // -------------- 分情况处理n=1、2、3 --------------
        string my_ans(m, ' ');
        ll total_num = 0, total_exp = 0;

        if (n == 1) {
            // 情况1：只有1个学生，选与他相同或相反（得分高的那个）
            string &s = student_ans[0];
            int score = student_score[0];
            bool flip = (score <= m / 2);
            for (int i = 0; i < m; ++i) {
                my_ans[i] = flip ? (s[i] == 'F' ? 'T' : 'F') : s[i];
            }
            total_exp = flip ? (m - score) : score;
            total_num = 1;
        } else if (n == 2) {
            // 情况2：两个学生，分类为“答案相同”“答案不同”两类
            int same = 0, diff = 0;
            for (int i = 0; i < m; ++i) {
                if (student_ans[0][i] == student_ans[1][i]) same++;
                else diff++;
            }
            ll sum = 0, exp_T[2] = {0, 0}; // exp_T[0]是相同类选原选项的期望，exp_T[1]是不同类选学生0选项的期望
            for (int i = 0; i <= diff; ++i) {
                int correct_same = student_score[0] - i;
                if (correct_same < 0 || correct_same > same) continue;
                if (student_score[1] != (diff - i) + correct_same) continue;
                ll cnt = C[diff][i] * C[same][correct_same];
                sum += cnt;
                exp_T[0] += (correct_same) * cnt; // 相同类选原选项的正确数量
                exp_T[1] += (i) * cnt;           // 不同类选学生0选项的正确数量
            }
            // 贪心选每个类的最优选项
            for (int i = 0; i < m; ++i) {
                if (student_ans[0][i] == student_ans[1][i]) {
                    my_ans[i] = (exp_T[0] >= (sum * same - exp_T[0])) ? student_ans[0][i] : (student_ans[0][i] == 'F' ? 'T' : 'F');
                } else {
                    my_ans[i] = (exp_T[1] >= (sum * diff - exp_T[1])) ? student_ans[0][i] : (student_ans[0][i] == 'F' ? 'T' : 'F');
                }
            }
            total_exp = exp_T[0] + exp_T[1];
            total_num = sum;
        }

        // -------------- 输出结果 --------------
        ll g = gcd(total_exp, total_num);
        cout << "Case #" << cas << ": " << my_ans << " " << total_exp / g << "/" << total_num / g << endl;
    }
    return 0;
}
```

**代码解读概要**：  
1. **预处理组合数**：提前计算C(n,k)，避免重复计算。  
2. **分情况处理**：n=1时直接选得分高的选项；n=2时分类为“相同”“不同”两类，枚举不同类的正确数量，计算每个类的期望得分。  
3. **输出结果**：用gcd约分分数，输出答案和期望得分。


### 题解一核心代码片段赏析（n=3的参数枚举）  
**亮点**：用二进制位枚举所有策略，高效计算每个策略的总期望。  

```cpp
// 枚举三人相同的题中正确的数量w
for (int w = 0; w <= min({num, va, vb, vc}); ++w) {
    // 计算其他类的正确数量x、y、z（通过代数推导）
    int sum = va + vb + vc - w * 3 - num1 - num2 - num3;
    int x = (sum - va + w + num1) / 2;
    int y = (sum - vb + w + num2) / 2;
    int z = (sum - vc + w + num3) / 2;
    // 过滤无效组合
    if (x < 0 || x > num1 || y < 0 || y > num2 || z < 0 || z > num3) continue;
    if (va != w + num1 - x + y + z) continue;
    // 计算组合数：C(num,w)*C(num1,x)*C(num2,y)*C(num3,z)
    ll cnt = C[num][w] * C[num1][x] * C[num2][y] * C[num3][z];
    total_num += cnt;
    // 枚举所有策略s（二进制位表示4类题的选择）
    for (int s = 0; s < 16; ++s) {
        ll score = 0;
        score += (s & 1) ? (num - w) : w;       // 类1：三人相同，选相反则加num-w
        score += (s & 2) ? (num1 - x) : x;     // 类2：两人相同，选相反则加num1-x
        score += (s & 4) ? (num2 - y) : y;     // 类3：两人相同，选相反则加num2-y
        score += (s & 8) ? (num3 - z) : z;     // 类4：两人相同，选相反则加num3-z
        val[s] += score * cnt; // 总期望=该策略的得分×组合数
    }
}
// 选择总期望最大的策略s
pair<ll, int> mx = {0, 0};
for (int s = 0; s < 16; ++s) {
    if (val[s] > mx.first) mx = {val[s], s};
}
```

**代码解读**：  
- `s`是4位二进制数，每一位表示一类题的选择（比如`s&1`为1表示“三人相同的题选相反选项”）。  
- 对每个有效参数组合，计算该组合的组合数`cnt`，然后累加每个策略`s`的总期望`val[s]`。  
- 最后选`val[s]`最大的策略，作为所有题的选择方案。  

**学习笔记**：用二进制位枚举多个选项的组合，是组合计数题中“减少嵌套循环”的常用技巧！


### 题解二核心代码片段赏析（n=3的期望计算）  
**亮点**：直接计算每个类别的T/F选项的期望，不需要枚举所有策略。  

```cpp
// 枚举类1、类2、类3的正确数量i、j、k
for (int i = 0; i <= c1; ++i) {
    for (int j = 0; j <= c2; ++j) {
        for (int k = 0; k <= c3; ++k) {
            // 计算类4的正确数量f
            int f1 = i + c2 - j + c3 - k;
            int f2 = j + c1 - i + c3 - k;
            int f3 = k + c1 - i + c2 - j;
            int f = a[0] - f1;
            if (f < 0 || f > c4) continue;
            if (a[1] != f2 + f || a[2] != f3 + f) continue;
            // 计算组合数
            ll cnt = C[c1][i] * C[c2][j] * C[c3][k] * C[c4][f];
            total_num += cnt;
            // 更新每个类的T/F期望
            g[0][0] += C[c1-1][i-1] * C[c2][j] * C[c3][k] * C[c4][f]; // 类1选原选项的期望
            g[0][1] += C[c1-1][i] * C[c2][j] * C[c3][k] * C[c4][f];   // 类1选相反选项的期望
            g[1][0] += C[c1][i] * C[c2-1][j-1] * C[c3][k] * C[c4][f]; // 类2选原选项的期望
            g[1][1] += C[c1][i] * C[c2-1][j] * C[c3][k] * C[c4][f];   // 类2选相反选项的期望
        }
    }
}
// 贪心选每个类的最优选项
for (int i = 0; i < m; ++i) {
    if (student_ans[0][i] == student_ans[1][i] && student_ans[0][i] == student_ans[2][i]) {
        // 类4：三人相同，选g[3][0]大的选项
        my_ans[i] = (g[3][0] >= g[3][1]) ? student_ans[0][i] : (student_ans[0][i] == 'F' ? 'T' : 'F');
    } else if (student_ans[1][i] == student_ans[2][i]) {
        // 类1：两人选F一人选T，选g[0][0]大的选项
        my_ans[i] = (g[0][0] >= g[0][1]) ? student_ans[1][i] : (student_ans[1][i] == 'F' ? 'T' : 'F');
    }
    // ... 其他类同理
}
```

**代码解读**：  
- `g[class][option]`表示“第class类题选option选项的期望得分总和”（option=0是原选项，option=1是相反选项）。  
- 枚举i、j、k后，计算组合数`cnt`，并更新每个类的`g`数组（比如类1选原选项的期望增加`C(c1-1, i-1)*...`，因为i是类1中选原选项正确的数量）。  
- 最后，每个类选`g[class][0]`和`g[class][1]`中较大的选项。  

**学习笔记**：直接计算每个选项的期望总和，不需要枚举所有策略，是更直观的实现方式！


## 5. 算法可视化：像素真相探索者

### 动画主题与设计思路  
**主题**：8位像素风“真相实验室”——你是一名“真相探索者”，需要从一堆“可能的真相”中找出每个问题的最优选项。  
**设计思路**：用复古游戏元素降低学习门槛，比如：  
- **像素问题块**：每个问题是一个16×16的像素块，颜色表示类别（红=三人相同，蓝=两人相同）；  
- **组合数掉落**：有效参数组合的组合数用“像素硬币”表示，从上方掉落并累加，伴随“叮”的音效；  
- **选项柱比拼**：每个类的T/F选项用两个像素柱表示，柱高=期望得分，选较高的柱（柱会闪烁并发出“咻”的音效）；  
- **过关奖励**：每完成一类问题的选择，会弹出“小关卡完成”的提示，加10分，增加成就感。

### 动画帧步骤  
1. **场景初始化**：  
   - 背景是8位风格的实验室（灰色墙壁、绿色工作台），顶部是控制面板（开始、暂停、单步、重置、速度滑块），中间是问题网格（12×10的像素块，对应Q=120），底部是组合数显示区（显示total_num），右侧是选项柱（T/F）。  
   - 播放复古背景音效（“嗡嗡”的电子声）。

2. **预处理组合数**：  
   - 组合数表以“像素表格”形式显示，C(n,k)用像素块的数量表示（比如C(5,2)=10，显示10个像素块），伴随“沙沙”的加载声。

3. **枚举参数（单步执行）**：  
   - 滑动条从0开始增加，每步显示当前参数值（比如w=5），检查是否有效。  
   - 有效时，“像素硬币”从上方掉落，累加至组合数显示区，伴随“叮”的音效。  
   - 选项柱的高度实时增加（比如类1的T柱增加10个像素），用颜色渐变表示增长（从浅蓝到深蓝）。

4. **选择最优选项**：  
   - 所有参数枚举完成后，每个问题的类别对应的选项柱中较高的那个会闪烁（比如T柱更高，就闪烁蓝色）。  
   - 问题像素块的颜色切换为该选项的颜色（T是蓝色，F是红色），伴随“咻”的音效。

5. **结果展示**：  
   - 所有问题选择完成后，屏幕中央弹出“真相找到！”的提示，显示答案序列和期望得分（分数形式），伴随上扬的胜利音效（“叮-叮-叮”）。  
   - 控制面板的“重置”按钮亮起，可重新开始。

### 交互控制  
- **单步执行**：点击“单步”按钮，滑动条增加1，处理一个参数组合。  
- **自动播放**：点击“开始”，滑动条自动增加，速度由滑块调节（最慢1秒/步，最快0.1秒/步）。  
- **重置**：点击“重置”，回到初始状态，问题网格恢复原色，组合数显示区清空。


## 6. 拓展练习与相似问题

### 通用思路迁移  
本题的**组合计数+贪心**思路可用于：  
- **概率题**：计算每个选项的期望概率，选最大的；  
- **统计题**：统计符合条件的序列数目，比如“有多少种方式让所有学生的得分符合要求”；  
- **决策题**：每个决策独立选最优，比如“每个商品选卖A或B，最大化总利润”。

### 洛谷相似问题推荐  
1. **P13028 [GCJ2021] Hacked Exam**（原题）：巩固组合计数+贪心的应用。  
2. **P2522 [HAOI2011] Problem b**：组合计数+容斥原理，计算“区间内与m互质的数的对数”，需要分类问题和枚举参数。  
3. **P3197 [HNOI2008] 越狱**：组合计数，计算“有多少种方式让相邻囚犯的宗教不同”，需要用组合数计算总情况数减去不符合条件的情况数。  


## 7. 学习心得与经验分享  
题解二中提到：“小清新组合计数题，但是代码写的太史了有点难受。” 这提醒我们：  
- **模块化代码很重要**：把分类、枚举、计算期望的代码分成不同函数，能减少调试时间；  
- **代数推导是关键**：提前推导参数之间的关系，能避免枚举无效组合，提高效率；  
- **测试小数据**：比如用样例1、2测试代码，确保分类和参数计算正确，再提交大数据。  


## 结语  
本次分析让我们学会了**用组合计数统计“可能的真相”，用贪心选每个问题的最优选项**。记住：组合计数的核心是“统计符合条件的数目”，贪心的核心是“独立选最优”。下次遇到类似的概率题，不妨试试这两个技巧！  

编程的乐趣在于“用逻辑解决问题”，希望这份指南能帮你更轻松地掌握算法。下次我们再一起探索新的挑战！💪

---
处理用时：296.94秒
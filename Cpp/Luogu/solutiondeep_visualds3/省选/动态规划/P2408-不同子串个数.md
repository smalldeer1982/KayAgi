# 题目信息

# 不同子串个数

## 题目背景

因为 NOI 被虐傻了，蒟蒻的 YJQ 准备来学习一下字符串，于是它碰到了这样一道题：


## 题目描述

给你一个长为 $n$ 的字符串，求不同的子串的个数。

我们定义两个子串不同，当且仅当有这两个子串长度不一样或者长度一样且有任意一位不一样。

子串的定义：原字符串中连续的一段字符组成的字符串。


## 说明/提示

### 提示

请使用64位整数来进行输出。

### 数据规模与约定
- 对于 $30\%$ 的数据，保证 $n\le 1000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，字符串中只有小写英文字母。


## 样例 #1

### 输入

```
5
aabaa```

### 输出

```
11```

## 样例 #2

### 输入

```
3
aba```

### 输出

```
5```

# AI分析结果

# 💡 Kay的C++算法解析：不同子串个数 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：后缀数组（SA）、后缀自动机（SAM）  

🗣️ **初步分析**：  
解决“不同子串个数”问题，关键在于**统计所有不重复的子串**。子串是原字符串的连续片段，而所有子串都可以看作某个**后缀的前缀**（比如“abc”的子串“bc”是后缀“bc”的前缀）。因此，我们可以通过**处理后缀**来高效计算不同子串的数量。  

### 核心算法思路
1. **后缀数组（SA）**：  
   把字符串的所有后缀按字典序排序，得到`sa`数组（`sa[i]`表示排名第`i`的后缀的起始位置）。然后计算`height`数组（`height[i]`表示排名第`i`的后缀与排名第`i-1`的后缀的最长公共前缀，即LCP）。总子串数是`n*(n+1)/2`（每个后缀有`n-sa[i]+1`个前缀，总和为`n*(n+1)/2`），减去所有`height`的和（重复的前缀数），就是不同子串的数量。  
   - **比喻**：就像把所有单词按字典序排好，相邻单词的重复前缀就是它们的共同部分，去掉这些重复就能得到所有不同的单词片段。  

2. **后缀自动机（SAM）**：  
   SAM是一种高效表示字符串所有子串的结构，每个状态代表一组等价的子串（这些子串的后缀链接指向更短的等价类）。通过统计每个状态的贡献（`len[u] - len[link[u]]`，其中`len[u]`是状态`u`代表的最长子串长度，`link[u]`是其后缀链接），总和即为不同子串的数量。  
   - **比喻**：SAM像一棵“子串树”，每个节点代表一组相似的子串，节点的贡献是它比父节点多出来的新子串数量。  

### 核心难点与解决方案
- **SA的`height`数组计算**：直接暴力计算每个相邻后缀的LCP是`O(n²)`，无法通过大数据。利用`h[i] = height[rank[i]]`的性质（`h[i] ≥ h[i-1]-1`），可以将计算优化到`O(n)`。  
- **SAM的状态转移**：插入字符时需要处理分裂节点的情况（当遇到已存在的转移但长度不符合时，分裂节点并更新链接），这需要仔细理解SAM的结构。  

### 可视化设计思路
**SA动画方案**（8位像素风格）：  
- **场景**：屏幕左侧显示原字符串，右侧显示排序后的后缀列表（用像素块表示字符，颜色区分不同后缀）。  
- **步骤**：  
  1. **基数排序**：展示每个字符的桶排序过程（像素块按字符颜色落入对应桶中）。  
  2. **`sa`数组更新**：排序后的后缀按顺序排列，用箭头指向其起始位置。  
  3. **`height`计算**：相邻后缀的公共前缀用黄色高亮，长度显示在旁边。  
  4. **答案统计**：总子串数用绿色显示，减去`height`和后，红色数字即为答案。  
- **交互**：支持“单步执行”（逐步骤看排序和计算）、“自动播放”（快速演示全过程），点击后缀可查看其所有前缀。  
- **音效**：排序完成时播放“叮”声，计算`height`时播放“滴”声，答案出现时播放“胜利”音效。  


## 2. 精选优质题解参考

### 题解一：Leap_Frog（SA+SAM双解法）  
* **点评**：  
  这份题解同时给出了SA和SAM两种解法，思路清晰，代码简洁。SA部分用了经典的基数排序实现，`work`函数计算`sa`和`height`数组，`solve`函数直接用公式计算答案，逻辑直白。SAM部分用了DFS统计状态贡献，代码结构清晰，注释明确（比如“经典的后缀自动机加点过程”）。两种解法都覆盖了题目的核心，适合初学者对比学习。  

### 题解二：Rorschachindark（SAM动态维护答案）  
* **点评**：  
  此题解的亮点是**动态维护答案**：在插入每个字符时，直接计算新状态的贡献（`len[q] - len[fa[q]]`）并累加到`ans`中。这种方法避免了后续的拓扑DP，效率更高（实测比DFS快一倍）。代码规范，变量名（如`len`、`fa`、`ch`）含义明确，边界处理严谨（比如`fa[q]`的设置），是SAM的高效实现示例。  

### 题解三：Oracle（SA标准实现）  
* **点评**：  
  这份题解是SA的标准模板实现，步骤明确。`get_SA`函数用基数排序和倍增法计算`sa`数组，`get_height`函数用`h`数组的性质优化计算，`solve`函数按公式统计答案。代码注释详细（比如“线性求解height数组”），变量名符合常规命名习惯（如`sa`、`rank`、`height`），适合初学者作为SA的入门模板。  


## 3. 核心难点辨析与解题策略

### 1. **SA中`height`数组的高效计算**  
- **难点**：直接计算相邻后缀的LCP是`O(n²)`，无法处理`n=1e5`的数据。  
- **策略**：利用`h[i] = height[rank[i]]`的性质（`h[i] ≥ h[i-1]-1`），从`h[i-1]-1`开始比较，减少重复比较的次数。例如：  
  ```cpp
  for (int i=1, k=0; i<=n; i++) {
      if (k) k--;
      while (s[i+k] == s[sa[rank[i]-1]+k]) k++;
      height[rank[i]] = k;
  }
  ```  
- 💡 **学习笔记**：`h`数组的性质是SA优化的关键，记住“当前后缀的LCP至少是前一个后缀的LCP减1”。  

### 2. **SAM中的状态分裂**  
- **难点**：当插入字符时，遇到已存在的转移但长度不符合（`len[q] != len[p]+1`），需要分裂节点。  
- **策略**：创建新节点`nq`，复制`q`的转移和链接，更新`q`和新节点`np`的链接，并修改所有指向`q`的转移为`nq`。例如：  
  ```cpp
  int nq = ++cnt;
  a[nq] = a[q]; // 复制转移
  a[nq].len = a[p].len + 1;
  a[q].fa = a[np].fa = nq;
  for (; p && a[p].s[c] == q; p = a[p].fa) a[p].s[c] = nq;
  ```  
- 💡 **学习笔记**：状态分裂是SAM的核心操作，目的是保持SAM的“最小性”（用最少的状态表示所有子串）。  

### 3. **子串问题转化为后缀/自动机问题**  
- **难点**：如何将“不同子串个数”转化为SA或SAM的问题。  
- **策略**：  
  - SA：所有子串都是后缀的前缀，排序后相邻后缀的重复前缀就是重复的子串，减去即可。  
  - SAM：每个状态代表一组等价的子串，其贡献是比父节点多的新子串数量，总和即为答案。  
- 💡 **学习笔记**：子串问题的关键是“找到所有子串的表示方式”，SA和SAM是两种高效的表示方法。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（SA）  
* **说明**：此代码来自Oracle的题解，是SA的标准实现，逻辑清晰，适合作为入门模板。  
* **完整核心代码**：  
  ```cpp
  #include<cstdio>
  #include<cstdlib>
  #include<cstring>
  #include<algorithm>
  #include<cmath>
  #include<iostream>
  #include<queue>
  #define ll long long
  using namespace std;
  const int MAXN=2e5+10;
  int sa[MAXN],rank[MAXN],rsort[MAXN],y[MAXN],wr[MAXN],height[MAXN];
  char a[MAXN];
  bool cmp(int a,int b,int len) {
      return wr[a]==wr[b] && wr[a+len]==wr[b+len];
  }
  void get_SA(int m,int n) {
      for(int i=1;i<=n;i++) rank[i]=a[i-1];
      for(int i=1;i<=n;i++) rsort[rank[i]]++;
      for(int i=1;i<=m;i++) rsort[i]+=rsort[i-1];
      for(int i=n;i>0;i--) sa[rsort[rank[i]]--]=i;
      int len=1,p=0;
      while(p<n) {
          int k=0;
          for(int i=n-len+1;i<=n;i++) y[++k]=i;
          for(int i=1;i<=n;i++) if(sa[i]>len) y[++k]=sa[i]-len;
          for(int i=1;i<=n;i++) wr[i]=rank[y[i]];
          memset(rsort,0,sizeof(rsort));
          for(int i=1;i<=n;i++) rsort[wr[i]]++;
          for(int i=1;i<=m;i++) rsort[i]+=rsort[i-1];
          for(int i=n;i>0;i--) sa[rsort[wr[i]]--]=y[i];
          for(int i=1;i<=n;i++) wr[i]=rank[i];
          p=1;rank[sa[1]]=1;
          for(int i=2;i<=n;i++) {
              if(!cmp(sa[i],sa[i-1],len)) p++;
              rank[sa[i]]=p;
          }
          m=p;len<<=1;
      }
  }
  void get_height(int n) {
      int k=0,j;
      for(int i=1;i<=n;i++) {
          j=sa[rank[i]-1];
          if(k) k--;
          while(a[j+k-1]==a[i+k-1]) k++;
          height[rank[i]]=k;
      }
  }
  ll solve(int n) {
      ll ans=0;
      for(int i=1;i<=n;i++) ans+=n+1-sa[i]-height[i];
      return ans;
  }
  int main() {
      int len;
      scanf("%d",&len);
      scanf("%s",a);
      get_SA(300,len);
      get_height(len);
      printf("%lld",solve(len));
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **`get_SA`**：用基数排序和倍增法计算`sa`数组（排序后的后缀起始位置）。  
  2. **`get_height`**：用`h`数组的性质计算`height`数组（相邻后缀的LCP）。  
  3. **`solve`**：计算总子串数减去`height`和，得到不同子串个数。  

### 题解二（Rorschachindark的SAM）核心片段赏析  
* **亮点**：动态维护答案，避免后续DP。  
* **核心代码片段**：  
  ```cpp
  void Insert(int c) {
      int f=lst,q=++node;lst=q;
      len[q]=len[f]+1;
      while(f&&!ch[f][c]) ch[f][c]=q,f=fa[f];
      if(!f) fa[q]=1;
      else {
          int x=ch[f][c];
          if(len[x]==len[f]+1) fa[q]=x;
          else {
              int p=++node;
              fa[p]=fa[x],len[p]=len[f]+1;
              memcpy(ch[p],ch[x],sizeof(ch[x]));
              fa[x]=fa[q]=p;
              while(f&&ch[f][c]==x) ch[f][c]=p,f=fa[f];
          }
      }
      ans+=len[q]-len[fa[q]]; // 动态累加答案
  }
  ```  
* **代码解读**：  
  - `Insert`函数插入字符`c`，创建新状态`q`。  
  - 处理后缀链接：如果`f`没有`c`的转移，就指向`q`；否则处理分裂节点的情况。  
  - **关键**：`ans+=len[q]-len[fa[q]]`：新状态`q`的贡献是它比父节点`fa[q]`多的新子串数量（比如`len[q]=5`，`len[fa[q]]=3`，则贡献2个新子串：长度为4和5的）。  
* 💡 **学习笔记**：动态维护答案是SAM的高效技巧，适合需要实时统计的场景。  


## 5. 算法可视化：像素动画演示（SA版）

### 动画演示主题：“后缀字典排序游戏”（8位像素风格）  
**设计思路**：用FC红白机的风格展示SA的排序过程，让学习者直观看到后缀排序和`height`计算的过程，增强趣味性。  

### 动画帧步骤  
1. **初始化**：  
   - 屏幕左侧显示原字符串（比如“aabaa”），每个字符用16x16的像素块表示（红色背景，白色字符）。  
   - 屏幕右侧显示“后缀列表”，初始时按原顺序排列（比如“aabaa”、“abaa”、“baa”、“aa”、“a”）。  
   - 底部有“开始”、“单步”、“重置”按钮，以及速度滑块（1x~5x）。  

2. **基数排序（第一趟）**：  
   - 按每个后缀的第一个字符排序（比如“a”、“a”、“b”、“a”、“a”）。  
   - 像素块按字符颜色落入对应桶中（“a”桶是蓝色，“b”桶是绿色），排序后后缀列表更新为“aabaa”、“abaa”、“aa”、“a”、“baa”。  
   - 播放“叮”的音效，表示排序完成。  

3. **倍增法排序（第二趟）**：  
   - 按每个后缀的前两个字符排序（比如“aa”、“ab”、“ba”、“a”、“a”）。  
   - 展示每个后缀的前两个字符（用黄色高亮），排序后后缀列表更新为“aabaa”、“aa”、“a”、“abaa”、“baa”。  
   - 播放“叮”的音效。  

4. **计算`height`数组**：  
   - 相邻后缀的公共前缀用黄色高亮（比如“aabaa”和“aa”的公共前缀是“aa”，长度为2）。  
   - 在后缀列表下方显示`height`数组的值（比如[0,2,1,1,0]）。  
   - 播放“滴”的音效，表示计算完成。  

5. **统计答案**：  
   - 总子串数（`5*6/2=15`）用绿色显示，减去`height`和（`2+1+1+0=4`），得到答案`11`（红色显示）。  
   - 播放“胜利”音效（上扬的8位音乐），屏幕显示“通关！”。  

### 交互设计  
- **单步执行**：点击“单步”按钮，逐帧查看排序和计算过程。  
- **自动播放**：拖动速度滑块选择播放速度（1x~5x），点击“开始”按钮自动演示全过程。  
- **重置**：点击“重置”按钮，回到初始状态。  

### 技术实现  
- **Canvas绘制**：用`ctx.fillRect`绘制像素块，`ctx.fillText`显示文字。  
- **音效**：用`Audio`对象播放8位音效（比如“叮”声用`440Hz`的正弦波，“滴”声用`880Hz`的方波）。  
- **状态管理**：用变量记录当前步骤（比如`step=0`表示初始化，`step=1`表示第一趟排序），根据步骤绘制对应的画面。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
- **SA的应用**：除了求不同子串个数，还可以求最长重复子串（`height`数组的最大值）、最长公共子串（将两个字符串拼接，求`height`数组的最大值）。  
- **SAM的应用**：可以求子串出现次数（在SAM上统计每个状态的出现次数）、最长回文子串（用SAM处理反转字符串）。  

### 洛谷练习推荐  
1. **洛谷 P3804** - 【模板】后缀自动机  
   - 🗣️ **推荐理由**：这道题是SAM的模板题，要求统计子串出现次数和最长重复子串，能帮助你巩固SAM的状态转移和贡献统计。  
2. **洛谷 P2852** - 【USACO06DEC】Milk Patterns G  
   - 🗣️ **推荐理由**：这道题要求求最长重复子串（至少出现k次），需要用到SA的`height`数组和二分答案，能帮助你加深对SA的理解。  
3. **洛谷 P4070** - 【SDOI2016】生成魔咒  
   - 🗣️ **推荐理由**：这道题要求动态统计不同子串个数，需要用到SAM的动态插入和答案维护，是SAM的进阶练习。  


## 7. 学习心得与经验分享  
- **开`long long`的重要性**：题解中多次提到“注意开`long long`”，因为`n=1e5`时，`n*(n+1)/2=5e9`，超过了`int`的范围（约2e9），必须用`long long`存储答案。  
- **边界条件处理**：比如SA中的`k=0`的情况（当`rank[i]=1`时，`height[rank[i]]=0`），SAM中的`fa[q]=1`（当没有后缀链接时，指向根节点）。  
- **算法选择技巧**：对于`n=1e5`的数据，SA和SAM的时间复杂度都是`O(n)`或`O(n log n)`，可以通过；而哈希+LCP的时间复杂度是`O(n log² n)`，可能会超时（比如题解中的wasa855提到“Base=131, Mod=1e9+7会被卡掉”）。  


## 结语  
本次分析了“不同子串个数”的两种核心算法：后缀数组（SA）和后缀自动机（SAM）。SA通过排序后缀和计算`height`数组来统计不同子串，SAM通过状态转移和贡献统计来实现。希望这份指南能帮助你理解这两种算法的核心思想，并掌握解题技巧。记住，编程的关键是“多练习、多思考”，下次我们再一起探索新的编程挑战！💪

---
处理用时：205.39秒
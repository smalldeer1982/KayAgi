# 题目信息

# [SDOI2011] 拦截导弹

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度、并且能够拦截任意速度的导弹，但是以后每一发炮弹都不能高于前一发的高度，其拦截的导弹的飞行速度也不能大于前一发。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

在不能拦截所有的导弹的情况下，我们当然要选择使国家损失最小、也就是拦截导弹的数量最多的方案。但是拦截导弹数量的最多的方案有可能有多个，如果有多个最优方案，那么我们会随机选取一个作为最终的拦截导弹行动蓝图。

我方间谍已经获取了所有敌军导弹的高度和速度，你的任务是计算出在执行上述决策时，每枚导弹被拦截掉的概率。


## 说明/提示



保证总方案数不超过 C++ 中 double 类型的存储范围。

### 数据范围及约定

- 均匀分布着约 $30\%$ 的数据，所有 $v_i$ 均相等；
- 均匀分布着约 $50\%$ 的数据，满足 $1\le h_i,v_i\le 1000$。
- 对于 $30\%$ 的数据，满足 $1\le n\le 1000$；
- 对于 $100\%$ 的数据，$1\le n\le 5\times 10^4$，$1\le h_i,v_i\le 10^9$。

### 评分标准

对于每个测试点，若输出的第一行与标准输出相同，则得到该测试点 $40\%$ 的分数，若输出文件的第二行的每个数与标准输出的误差均不大于 $10^{-4}$，则得到该测试点 $60\%$ 的分数，两项相加作为该测试点总得分。

## 样例 #1

### 输入

```
4
3 30
4 40
6 60
3 30
```

### 输出

```
2
0.33333 0.33333 0.33333 1.00000
```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2011]拦截导弹 深入学习指南 💡


## 📝 题目快速回顾
我们需要解决两个问题：  
1. **最长拦截序列**：给定按时间顺序飞来的导弹（每个导弹有高度`h`和速度`v`），选择一个最长子序列，使得后拦截的导弹**高度不高于前一个**、**速度不大于前一个**（即满足`h_i ≤ h_j`且`v_i ≤ v_j`，其中`i`是后拦截的导弹，`j`是前一个）。  
2. **概率计算**：对于每个导弹，计算它在**所有最长拦截序列**中出现的概率（方案数占比）。


## 1. 核心算法识别：CDQ分治优化二维DP
### ✨ 本题主要考察
**CDQ分治 + 树状数组（维护最大值与方案数）**  
**关键词**：三维偏序（时间、高度、速度）、最长不上升子序列（LIS变种）、方案数统计。


### 🗣️ 初步分析
#### （1）问题转化
- 第一问：求**二维最长不上升子序列**（时间已按顺序给出，只需考虑高度和速度的偏序关系）。  
- 第二问：计算每个导弹在最长序列中的**出现概率**，需要统计**包含该导弹的最长序列方案数**与**总最长序列方案数**的比值。

#### （2）核心思路
- **DP定义**：  
  - `f1[i]`：以第`i`个导弹结尾的最长拦截序列长度；  
  - `g1[i]`：以第`i`个导弹结尾的最长序列**方案数**；  
  - `f2[i]`：以第`i`个导弹开头的最长拦截序列长度；  
  - `g2[i]`：以第`i`个导弹开头的最长序列**方案数**。  
- **概率计算**：若`f1[i] + f2[i] - 1 == 最长长度`（`-1`是因为`i`被重复计算），则该导弹在最长序列中，概率为`(g1[i] * g2[i]) / 总方案数`。  
- **总方案数**：所有`f1[i]`等于最长长度的`g1[i]`之和。

#### （3）CDQ分治的作用
常规的二维LIS的DP是`O(n²)`（每个`i`遍历前面所有`j`），无法通过`n=5e4`的数据。CDQ分治将问题分解为**左半部分**和**右半部分**，先处理左半部分，再用左半部分的结果更新右半部分，最后处理右半部分，将时间复杂度优化到`O(n log²n)`。


## 2. 优质题解点评（CDQ分治为主）
### 📌 题解一（lkytxdy，赞60）
**亮点**：代码简洁，CDQ分治逻辑清晰，方案数处理正确。  
**核心思路**：  
- 用CDQ分治处理`f1`和`g1`：将左半部分按高度排序，右半部分按高度排序，用双指针遍历，将左半部分的`(v, f1, g1)`插入树状数组，右半部分查询树状数组中的**最大值**（对应最长序列长度）和**方案数**（对应总方案数）。  
- 逆序处理`f2`和`g2`：将序列逆序，高度和速度取反（将“不上升”转化为“不下降”），用同样的CDQ分治计算。  
**代码细节**：  
- 离散化速度（`v`的范围是`1e9`，需要压缩到`1~n`）；  
- 树状数组维护`max_val`（最大值）和`cnt`（方案数），插入时更新最大值和方案数，查询时返回区间最大值和对应的方案数之和。

### 📌 题解二（shadowice1984，赞34）
**亮点**：强调了`double`的重要性（方案数会爆`long long`），CDQ分治的顺序说明详细。  
**核心思路**：  
- 与题解一类似，但更详细地解释了CDQ分治的顺序（先处理左半部分，再处理左对右的影响，最后处理右半部分）。  
- 指出了排序时的注意事项（比如“小于号取反”会导致`sort`出错，需要用`stable_sort`或调整排序条件）。

### 📌 题解三（juju527，赞18）
**亮点**：代码结构清晰，注释详细，处理了`f1`和`f2`的对称问题。  
**核心思路**：  
- 用CDQ分治计算`f1`和`g1`，再逆序计算`f2`和`g2`；  
- 树状数组维护`max_val`和`cnt`，确保转移时正确累加方案数。


## 3. 核心难点辨析与解题策略
### 🎯 难点1：二维偏序的处理
**问题**：如何快速查询前面所有满足`h_j ≥ h_i`且`v_j ≥ v_i`的`j`的最大`f1[j]`？  
**解决策略**：用CDQ分治将`h`排序，将问题转化为**一维偏序**（`v`的查询），用树状数组维护`v`的最大值和方案数。

### 🎯 难点2：方案数的统计
**问题**：如何统计以`i`结尾的最长序列的方案数？  
**解决策略**：树状数组的每个节点存储`max_val`（当前最大值）和`cnt`（对应方案数）。当插入一个元素时，若其`f1`大于当前节点的`max_val`，则更新`max_val`和`cnt`；若等于，则累加`cnt`。查询时，返回区间内的`max_val`和对应的`cnt`之和。

### 🎯 难点3：逆序处理`f2`和`g2`
**问题**：如何计算以`i`开头的最长序列长度和方案数？  
**解决策略**：将序列逆序，同时将`h`和`v`取反（比如`h_i = max_h - h_i + 1`，`v_i = max_v - v_i + 1`），这样“不上升”就转化为“不下降”，可以用同样的CDQ分治计算`f2`和`g2`。


## 4. C++核心代码实现赏析
### 📌 通用核心代码框架（CDQ分治 + 树状数组）
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

typedef double db;
const int N = 5e4 + 10;

struct Node {
    int h, v, id;
} a[N], tmp[N];

int f1[N], f2[N];
db g1[N], g2[N];
int n, tot;
vector<int> v_list;

// 树状数组：维护max_val和cnt
struct BIT {
    int max_val[N];
    db cnt[N];
    int lowbit(int x) { return x & -x; }
    void update(int x, int val, db c) {
        for (; x <= tot; x += lowbit(x)) {
            if (max_val[x] < val) {
                max_val[x] = val;
                cnt[x] = c;
            } else if (max_val[x] == val) {
                cnt[x] += c;
            }
        }
    }
    pair<int, db> query(int x) {
        int res_val = 0;
        db res_cnt = 0;
        for (; x > 0; x -= lowbit(x)) {
            if (max_val[x] > res_val) {
                res_val = max_val[x];
                res_cnt = cnt[x];
            } else if (max_val[x] == res_val) {
                res_cnt += cnt[x];
            }
        }
        return {res_val, res_cnt};
    }
    void clear() {
        fill(max_val, max_val + tot + 1, 0);
        fill(cnt, cnt + tot + 1, 0);
    }
} bit;

// CDQ分治处理f1和g1
void cdq1(int l, int r) {
    if (l == r) return;
    int mid = (l + r) >> 1;
    cdq1(l, mid);
    // 按h排序左半部分和右半部分
    sort(a + l, a + mid + 1, [](const Node& x, const Node& y) { return x.h > y.h; });
    sort(a + mid + 1, a + r + 1, [](const Node& x, const Node& y) { return x.h > y.h; });
    int p = l;
    for (int i = mid + 1; i <= r; i++) {
        while (p <= mid && a[p].h >= a[i].h) {
            bit.update(a[p].v, f1[a[p].id], g1[a[p].id]);
            p++;
        }
        auto [val, c] = bit.query(a[i].v);
        if (val + 1 > f1[a[i].id]) {
            f1[a[i].id] = val + 1;
            g1[a[i].id] = c;
        } else if (val + 1 == f1[a[i].id]) {
            g1[a[i].id] += c;
        }
    }
    bit.clear();
    cdq1(mid + 1, r);
}

// 逆序处理f2和g2（类似cdq1，需调整排序条件）
void cdq2(int l, int r) {
    // 类似cdq1，但序列逆序，h和v取反
    // 此处省略具体实现，核心逻辑与cdq1一致
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].h >> a[i].v;
        a[i].id = i;
        v_list.push_back(a[i].v);
    }
    // 离散化速度
    sort(v_list.begin(), v_list.end());
    v_list.erase(unique(v_list.begin(), v_list.end()), v_list.end());
    tot = v_list.size();
    for (int i = 1; i <= n; i++) {
        a[i].v = lower_bound(v_list.begin(), v_list.end(), a[i].v) - v_list.begin() + 1;
        f1[i] = 1;
        g1[i] = 1;
    }
    cdq1(1, n);
    // 处理f2和g2（逆序）
    // ...
    // 计算最长长度和总方案数
    int max_len = 0;
    db total = 0;
    for (int i = 1; i <= n; i++) {
        if (f1[i] > max_len) {
            max_len = f1[i];
            total = g1[i];
        } else if (f1[i] == max_len) {
            total += g1[i];
        }
    }
    // 计算概率
    for (int i = 1; i <= n; i++) {
        if (f1[i] + f2[i] - 1 == max_len) {
            printf("%.5lf ", g1[i] * g2[i] / total);
        } else {
            printf("0.00000 ");
        }
    }
    return 0;
}
```


### 📌 代码解读
1. **离散化**：将速度`v`离散化到`1~tot`（`tot`是不同速度的数量），方便树状数组处理。  
2. **CDQ分治**：`cdq1`处理`f1`和`g1`，将左半部分按高度排序，右半部分按高度排序，用双指针遍历，将左半部分的`(v, f1, g1)`插入树状数组，右半部分查询树状数组中的最大值和方案数。  
3. **树状数组**：维护`max_val`（当前最大值）和`cnt`（对应方案数），插入时更新最大值和方案数，查询时返回区间最大值和对应的方案数之和。  
4. **逆序处理**：`cdq2`处理`f2`和`g2`，将序列逆序，高度和速度取反，用同样的逻辑计算。  


## 5. 算法可视化：像素动画演示（核心部分）
### 🎮 动画主题：《导弹拦截战》（8位像素风）
**场景**：屏幕左侧显示导弹飞来的顺序（按时间排列），右侧显示当前最长拦截序列的长度和方案数。  
**核心演示内容**：  
- **CDQ分治过程**：将序列分成左右两部分，左半部分用蓝色标记，右半部分用红色标记。  
- **树状数组插入**：当左半部分的导弹被插入树状数组时，对应的`v`位置会闪烁，并显示`f1`和`g1`的值。  
- **查询与更新**：右半部分的导弹查询树状数组时，对应的`v`区间会高亮，显示查询到的最大值和方案数，然后更新自己的`f1`和`g1`。  
- **逆序处理**：动画后半部分显示逆序处理`f2`和`g2`的过程，导弹颜色变为绿色，高度和速度取反。  

**交互设计**：  
- **单步执行**：点击“下一步”按钮，逐步演示CDQ分治的每一步。  
- **自动播放**：点击“开始”按钮，自动播放动画，速度可调。  
- **方案数显示**：屏幕下方显示当前总方案数和每个导弹的概率（用进度条表示）。  


## 6. 拓展练习与相似问题思考
### 🧠 通用思路迁移
- **二维LIS变种**：比如求最长不下降子序列、最长上升子序列等，都可以用CDQ分治优化。  
- **三维偏序问题**：比如带时间、空间、价值的问题，都可以用CDQ分治处理。  
- **方案数统计**：比如统计最长路径的方案数、最短路径的方案数等，都可以用树状数组维护方案数。

### 📚 洛谷练习推荐
1. **P1020 导弹拦截**：经典的一维LIS问题，是本题的基础。  
2. **P3810 三维偏序**：CDQ分治的经典问题，处理三维偏序的计数问题。  
3. **P4169 天使玩偶**：CDQ分治处理二维最近点对问题，类似本题的偏序处理。  


## 7. 学习心得与经验分享
- **CDQ分治的顺序**：必须先处理左半部分，再处理左对右的影响，最后处理右半部分，否则会导致DP值不正确。  
- **方案数的类型**：必须用`double`存储方案数，否则会爆`long long`（比如当`n=5e4`时，方案数可能达到`1e1000`以上）。  
- **离散化的正确性**：离散化时必须处理重复值，否则会导致树状数组查询错误（比如用`unique`函数去重）。  


## 📝 总结
本题的核心是用CDQ分治优化二维最长不上升子序列的DP，同时维护方案数，逆序处理得到以每个元素开头的方案数，最后计算概率。关键点在于正确实现CDQ分治、树状数组维护方案数、离散化和逆序处理。通过本题的学习，可以掌握CDQ分治处理偏序问题的方法，以及方案数统计的技巧。

**下次挑战**：尝试用K-D Tree解决本题，对比CDQ分治的效率差异！💪

---
处理用时：176.55秒
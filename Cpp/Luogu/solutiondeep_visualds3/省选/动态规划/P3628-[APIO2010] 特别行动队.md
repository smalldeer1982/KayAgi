# 题目信息

# [APIO2010] 特别行动队

## 题目描述

你有一支由 $n$ 名预备役士兵组成的部队，士兵从 $1$ 到 $n$ 编号，你要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号**应该连续**，即为形如 $(i, i + 1, \cdots i + k)$的序列。所有的队员都应该属于且仅属于一支特别行动队。

编号为 $i$ 的士兵的初始战斗力为 $x_i$ ，一支特别行动队的初始战斗力 $X$ 为队内士兵初始战斗力之和，即 $X = x_i + x_{i+1} + \cdots + x_{i+k}$。

通过长期的观察，你总结出对于一支初始战斗力为 $X$ 的特别行动队，其修正战斗力 $X'= aX^2+bX+c$，其中 $a,~b,~c$ 是已知的系数（$a < 0$）。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队的修正战斗力之和最大。试求出这个最大和。

## 说明/提示

#### 样例输入输出 $1$ 解释

你有 $4$ 名士兵，$x_1 = 2,~x_2 = 2,~x_3 = 3,~x_4=4$。修正战斗力公式中的参数为  $a = -1,~b = 10,~c = -20$。

此时，最佳方案是将士兵组成 $3$ 个特别行动队：第一队包含士兵 $1$ 和士兵 $2$，第二队包含士兵 $3$，第三队包含士兵 $4$。特别行动队的初始战斗力分别为 $4,~3,~4$，修正后的战斗力分别为 $-4^2 + 10 \times 4 -20 = 4$，$-3^2 + 10 \times 3 - 20 = 1$，$-4^2 + 10 \times 4 -20 = 4$。修正后的战斗力和为 $4 + 1 + 4 = 9$，没有其它方案能使修正后的战斗力和更大。


#### 数据范围与约定

对于 $20\%$ 的数据，$n \leq 10^3$。

对于 $50\%$ 的数据，$n \leq 10^4$

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$-5 \leq a \leq -1$，$-10^7 \leq b \leq 10^7$，$-10^7 \leq c \leq 10^7$，$1 \leq x_i \leq 100$。

## 样例 #1

### 输入

```
4 
-1 10 -20 
2 2 3 4 ```

### 输出

```
9```

# AI分析结果

# 【APIO2010】特别行动队题解分析


## **1. 问题核心与状态定义**
### 问题描述
将$n$个士兵分成连续的若干组，每组的修正战斗力为$aX^2 + bX + c$（$X$为组内士兵初始战斗力和，$a<0$），求所有组修正战斗力之和的最大值。

### 状态定义
- **前缀和**：$sum[i] = \sum_{k=1}^i x_k$，表示前$i$个士兵的初始战斗力和。
- **DP数组**：$dp[i]$表示前$i$个士兵的最大修正战斗力和。


## **2. 转移方程与优化需求**
### 暴力转移方程
对于每个$i$，枚举所有可能的分组终点$j$（$0 \leq j < i$），转移方程为：  
$$dp[i] = \max_{j=0}^{i-1} \left\{ dp[j] + a(sum[i]-sum[j])^2 + b(sum[i]-sum[j]) + c \right\}$$  
**时间复杂度**：$O(n^2)$，无法处理$n=10^6$的数据。


### 斜率优化推导
将转移方程展开并整理，提取与$j$相关的项：  
$$dp[i] = a \cdot sum[i]^2 + b \cdot sum[i] + c + \max_{j=0}^{i-1} \left\{ dp[j] + a \cdot sum[j]^2 - b \cdot sum[j] - 2a \cdot sum[i] \cdot sum[j] \right\}$$  
令：  
- $Y(j) = dp[j] + a \cdot sum[j]^2 - b \cdot sum[j]$（关于$j$的函数），  
- $X(j) = sum[j]$（关于$j$的函数），  
- $k(i) = 2a \cdot sum[i]$（关于$i$的函数），  

则转移方程中的$\max$部分可表示为：  
$$\max_{j} \left\{ -k(i) \cdot X(j) + Y(j) \right\}$$  
这等价于在直线集合$\{ y = -k(i) \cdot x + Y(j) \}$中，找到在$x=X(j)$处$y$值最大的直线。由于$a<0$且$sum[i]$递增，$k(i)$递增，因此需要维护**上凸包**（Convex Hull Trick）来快速查询最优$j$。


## **3. 凸包维护与单调队列**
### 凸包性质
由于$sum[i]$递增（$x_i \geq 1$），且$k(i)$递增，上凸包的最优决策点具有**单调性**：  
- 队首的两个决策点$j_1, j_2$，若$j_2$比$j_1$优（即直线$j_2$在$sum[i]$处的$y$值更大），则$j_1$永远不会成为后续$i$的最优决策，可弹出队首。  
- 插入新决策点$i$时，需保证凸包的上凸性：若新点与队尾点的连线斜率小于等于队尾点与前一点的连线斜率，则队尾点无法成为最优决策，可弹出队尾。


### 单调队列实现
- **队列存储**：队列$q$存储决策点$j$的索引。  
- **队首维护**：当$slope(q[h], q[h+1]) > k(i)$时，弹出队首（$slope$为两点连线的斜率）。  
- **队尾维护**：当$slope(q[t-1], q[t]) \leq slope(q[t], i)$时，弹出队尾。  
- **斜率计算**：为避免浮点误差，常用交叉相乘判断斜率关系（如$slope(j1,j2) > k(i)$等价于$Y(j1)-Y(j2) > k(i) \cdot (X(j1)-X(j2))$）。


## **4. 代码实现关键点**
### 核心代码框架
```cpp
#include <iostream>
#include <cstdio>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5;

ll sum[N], dp[N];
int q[N], h = 1, t = 1; // 队列（数组模拟，h队首，t队尾）
ll a, b, c;

inline ll Y(int j) { return dp[j] + a * sum[j] * sum[j] - b * sum[j]; }
inline ll X(int j) { return sum[j]; }
inline bool check_head(int j1, int j2, ll k) {
    // 判断slope(j1,j2) > k，用交叉相乘避免浮点误差
    return (Y(j1) - Y(j2)) > k * (X(j1) - X(j2));
}
inline bool check_tail(int j1, int j2, int j3) {
    // 判断slope(j1,j2) <= slope(j2,j3)
    return (Y(j2) - Y(j1)) * (X(j3) - X(j2)) <= (Y(j3) - Y(j2)) * (X(j2) - X(j1));
}

int main() {
    int n;
    scanf("%d%lld%lld%lld", &n, &a, &b, &c);
    for (int i = 1; i <= n; ++i) {
        ll x;
        scanf("%lld", &x);
        sum[i] = sum[i-1] + x;
    }
    q[1] = 0; // 初始化队列，j=0
    for (int i = 1; i <= n; ++i) {
        ll k_i = 2 * a * sum[i];
        // 维护队首：弹出无效决策
        while (h < t && check_head(q[h], q[h+1], k_i)) {
            h++;
        }
        // 计算dp[i]
        int j = q[h];
        ll delta = sum[i] - sum[j];
        dp[i] = dp[j] + a * delta * delta + b * delta + c;
        // 维护队尾：插入新决策i
        while (h < t && check_tail(q[t-1], q[t], i)) {
            t--;
        }
        q[++t] = i;
    }
    printf("%lld\n", dp[n]);
    return 0;
}
```


### 代码说明
1. **前缀和计算**：$sum[i]$存储前$i$个士兵的初始战斗力和，用于快速计算区间和。  
2. **队列维护**：用数组模拟单调队列，存储决策点$j$的索引。  
3. **队首处理**：通过`check_head`函数判断队首的两个决策点是否满足斜率条件，弹出无效决策。  
4. **队尾处理**：通过`check_tail`函数判断新插入的决策点是否破坏凸包的上凸性，弹出无效决策。  
5. **DP计算**：根据队首的最优决策点$j$，计算$dp[i]$。


## **5. 题解共性与差异**
### 共性
- **状态定义一致**：所有题解均使用$dp[i]$表示前$i$个士兵的最大修正战斗力和，$sum[i]$表示前缀和。  
- **转移方程一致**：均从暴力转移方程出发，通过斜率优化降低时间复杂度。  
- **凸包维护一致**：均使用单调队列维护上凸包，处理最优决策点的查询与插入。


### 差异
- **斜率计算方式**：部分题解使用`double`计算斜率（如`slope(j1,j2) = (Y(j1)-Y(j2))/(X(j1)-X(j2))`），但为避免浮点误差，更多题解使用交叉相乘（如上述代码中的`check_head`和`check_tail`函数）。  
- **队列实现方式**：部分题解使用`deque`（双端队列），但数组模拟队列更快，更适合$n=10^6$的数据。  
- **代码风格**：不同题解的变量命名、循环结构略有差异，但核心逻辑一致。


## **6. 注意事项**
- **数据范围**：$n=10^6$，必须使用$O(n)$的算法（斜率优化），否则会超时。  
- **变量类型**：$sum[i]$和$dp[i]$的值可能很大，需使用`long long`类型避免溢出。  
- **前缀和正确性**：$sum[0]=0$，$sum[i] = sum[i-1] + x[i]$，确保区间和计算正确。  
- **凸包方向**：由于$a<0$，需维护上凸包，若$a>0$则维护下凸包（本题$a<0$，固定上凸包）。


## **7. 总结**
本题的核心是**斜率优化DP**，通过维护上凸包快速找到最优决策点，将时间复杂度从$O(n^2)$降至$O(n)$。关键步骤包括：  
1. 定义状态与转移方程；  
2. 展开转移方程并整理成线性形式；  
3. 维护上凸包（单调队列）；  
4. 处理队列的队首与队尾，确保最优决策点的正确性。  

掌握斜率优化的核心思想（凸包技巧）和实现细节（如交叉相乘避免浮点误差、数组模拟队列），是解决此类问题的关键。

---
处理用时：137.37秒
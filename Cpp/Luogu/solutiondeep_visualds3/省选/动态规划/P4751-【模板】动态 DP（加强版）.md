# 题目信息

# 【模板】动态 DP（加强版）

## 题目背景

树剖常数小！跑不满！

shadowice1984 为了向你证明他能卡树剖并且会卡树剖从而出了这道毒瘤题。

保证答案均在 `int` 范围内。

然后就被离线算法针对了……

因此这道题变成了强制在线。


## 题目描述

同 [P4719](https://www.luogu.com.cn/problem/P4719)。

给定一个 $n$ 个点的带点权树，进行 $m$ 次修改点权的操作。

你需要在每次修改之后输出树上最大带权独立集的权值之和。

## 说明/提示

数据范围 $n \leq 1 \times 10^6$，$m \leq 3 \times 10^6$。保证任意时刻各点点权的绝对值 $\leq 100$。

时限为标程的二倍，如果卡常数的话请使用 `int` 类型。

## 样例 #1

### 输入

```
10 10
-11 80 -99 -76 56 38 92 -51 -34 47
2 1
3 1
4 3
5 2
6 2
7 1
8 2
9 4
10 7
9 -44
184 -17
184 98
185 -58
153 48
190 99
296 -61
253 76
329 14
264 93
```

### 输出

```
186
186
190
145
189
288
244
320
258
304```

# AI分析结果

要解决**动态修改点权的树状最大权独立集**问题，**动态DP**是核心框架，其核心思想是将静态DP拆分为**重儿子**（主导转移）和**轻儿子**（预处理贡献），通过**广义矩阵乘法**（`max`与`+`组合）维护重链转移，结合**树剖**或**全局平衡二叉树**实现高效修改与查询。


### **一、问题背景与静态DP**
静态问题（无修改）即「没有上司的舞会」，状态定义：
- `f[u][0]`：不选节点`u`时，子树`u`的最大权独立集。
- `f[u][1]`：选节点`u`时，子树`u`的最大权独立集。

转移方程：
\[
f[u][0] = \sum_{v \in \text{son}(u)} \max(f[v][0], f[v][1])
\]
\[
f[u][1] = a[u] + \sum_{v \in \text{son}(u)} f[v][0]
\]

**动态挑战**：修改一个节点的权值会导致其到根节点的所有祖先的`f`值变化，直接重算复杂度为`O(n)`，无法处理大规模数据（如`n=1e6`，`m=3e6`）。


### **二、动态DP的核心改造**
动态DP的关键是**分离重儿子与轻儿子的贡献**，将转移拆分为**仅依赖重儿子**的形式，从而用数据结构维护重链的转移。

#### **1. 定义轻儿子贡献（`g`数组）**
- `g[u][0]`：选节点`u`时，所有**轻儿子**子树的贡献之和（即`a[u] + sum(f[v][0]`，`v`为轻儿子）。
- `g[u][1]`：不选节点`u`时，所有**轻儿子**子树的贡献之和（即`sum(max(f[v][0], f[v][1])`，`v`为轻儿子）。

#### **2. 重链转移方程**
设`son[u]`为`u`的**重儿子**（子树最大的儿子），则：
\[
f[u][0] = g[u][1] + \max(f[\text{son}[u]][0], f[\text{son}[u]][1])
\]
\[
f[u][1] = g[u][0] + f[\text{son}[u]][0]
\]

#### **3. 广义矩阵乘法**
为了用数据结构维护重链的转移，将上述方程转换为**矩阵乘法**（`max`与`+`组合）。定义转移矩阵`M[u]`：
\[
M[u] = \begin{bmatrix} g[u][1] & g[u][0] \\ g[u][1] & -\infty \end{bmatrix}
\]
其中，`-∞`表示不可达（如选`u`时不能选重儿子）。

状态矩阵`F[u] = [f[u][0], f[u][1]]`，则转移关系为：
\[
F[u] = F[\text{son}[u]] \times M[u]
\]
（注：矩阵乘法定义为`(A×B)[i][j] = max_k (A[i][k] + B[k][j])`，满足结合律）。


### **三、数据结构选择**
动态DP需要维护**重链的矩阵乘积**，支持快速修改（点权变化）和查询（链顶`F`值）。常见方案有：

#### **1. 树剖+线段树（`O(n log²n)`）**
- **树剖**：将树划分为`O(logn)`条重链，每条重链的`dfn`（深度优先编号）连续。
- **线段树**：维护每条重链的矩阵乘积，修改时跳重链，更新链顶父亲的`g`值（轻儿子贡献）。

**步骤**：
- **预处理**：`dfs1`（求`size`、重儿子）、`dfs2`（求`dfn`、`top`、`g`数组）。
- **线段树构建**：每个节点存储其转移矩阵，线段树节点存储区间矩阵乘积。
- **修改操作**：
  1. 更新节点`u`的`g[u][0]`（因`a[u]`变化）。
  2. 更新`u`所在重链的线段树区间乘积。
  3. 跳转到重链顶端`top[u]`，计算其`F`值（线段树查询）。
  4. 更新`top[u]`的父亲`fa[top[u]]`的`g`值（减去旧`F`值的贡献，加上新`F`值的贡献）。
  5. 重复步骤3-4，直到根节点。

#### **2. 全局平衡二叉树（`O(n logn)`）**
树剖的`log²n`复杂度在大数据下可能超时，**全局平衡二叉树**（GBT）将重链建成平衡树，直接维护矩阵乘积，将时间复杂度优化到`O(logn)`。

**核心思想**：
- **建树**：对每条重链，按`size`（子树大小）分治，找带权中点，构建平衡树（树高`O(logn)`）。
- **维护**：每个平衡树节点存储其转移矩阵和子树矩阵乘积（`sw`），修改时跳平衡树的父亲，更新轻儿子贡献。

**优势**：
- 平衡树的`pushup`操作（更新子树乘积）是`O(1)`。
- 修改时跳`O(logn)`次平衡树节点，总时间复杂度`O(m logn)`。


### **四、代码实现细节**
#### **1. 广义矩阵乘法**
```cpp
struct Matrix {
    int a[2][2];
    Matrix() { memset(a, -0x3f, sizeof(a)); } // 初始化为-∞
};

Matrix operator*(const Matrix& A, const Matrix& B) {
    Matrix res;
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            for (int k = 0; k < 2; ++k)
                res.a[i][j] = max(res.a[i][j], A.a[i][k] + B.a[k][j]);
    return res;
}
```

#### **2. 树剖+线段树示例（Green_White）**
- **dfs1**：求`size`、重儿子。
- **dfs2**：求`dfn`、`top`、`g`数组（轻儿子贡献）。
- **线段树**：维护重链的矩阵乘积，`pushup`时按链底到链顶的顺序（右子树×左子树）。
- **修改操作**：跳重链，更新链顶父亲的`g`值。

#### **3. 全局平衡二叉树示例（_XHY20180718_）**
- **建树**：对每条重链，按`size`分治，找带权中点，构建平衡树。
- **维护**：平衡树节点存储`w`（转移矩阵）和`sw`（子树乘积），`pushup`时按右子树×当前节点×左子树的顺序。
- **修改操作**：跳平衡树的父亲，更新轻儿子贡献（`g`值）。


### **五、总结**
动态DP的核心是**分离重轻儿子贡献**，通过**广义矩阵乘法**维护重链转移，结合**树剖**或**全局平衡二叉树**实现高效修改。对于大规模数据（如`n=1e6`），**全局平衡二叉树**是更优的选择，其时间复杂度`O(n logn + m logn)`能满足要求。

**关键步骤回顾**：
1. 静态DP拆分为重轻儿子贡献，定义`g`数组。
2. 构造转移矩阵，用广义矩阵乘法维护重链转移。
3. 用数据结构（树剖/全局平衡二叉树）维护重链矩阵乘积。
4. 修改时，更新节点`g`值，跳链顶更新父亲`g`值，直到根节点。


### **参考代码**
- **树剖+线段树**：[Green_White 的题解](https://www.cnblogs.com/FloatingLife/p/18418027)
- **全局平衡二叉树**：[_XHY20180718_ 的题解](https://www.luogu.com.cn/blog/_XHY20180718_/solution-p4751)

---
处理用时：130.70秒
# 题目信息

# [BalticOI 2018] 多角恋

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)」**

给一张 $N$ 个点的有向图，每个点的出度为 $1$。每次可以花费 $1$ 的代价修改图上的一条边的终点，也就是改变从一个点出发所到达的点。求最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)

唯一的最优解如上图所示，图的上半部分为原图，底色为粉色的三个点为需要修改的边的起点；图的下半部分表示修改后的情况。

#### 样例 2 解释

存在多组最优解。其中一种是分别改变一条以 ``a``、``b`` 和 ``d`` 为起点的边，使他们分别连接到 ``b``、``a`` 和 `c`。

#### 样例 3 解释

图中有 $3$ 个点，无论如何修改边的终点，总会有一个人不在环里。


| 子任务 | 分值 | 数据范围 | 附加限制 |
|:----------:|:-------:|:-------------:|:-------------:|
|$1$|$21$|$2\leqslant N\leqslant 20$|.|
|$2$|$25$|$2\leqslant N\leqslant 100\, 000$|每个点都有一条入边（可能有自环）|
|$3$|$29$|$2\leqslant N\leqslant 100\, 000$|不存在两个点或更多个点构成的环|
|$4$|$25$|$2\leqslant N\leqslant 100\, 000$|.|



## 样例 #1

### 输入

```
8
leonard emmy
ada emmy
isaac leonard
emmy pierre
pierre bernhard
bernhard emmy
sofia karl
karl sofia```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
a c
b c
c d
d d```

### 输出

```
3
```

## 样例 #3

### 输入

```
3
rocky scarlet
scarlet patrick
patrick rocky```

### 输出

```
-1
```

# AI分析结果

# 💡 Kay的C++算法解析：[BalticOI 2018] 多角恋 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心算法 + 拓扑排序（基环树处理）  

🗣️ **初步分析**：  
我们的任务是把一个“每个点都只指向一个其他点”的有向图，通过最少修改边的操作，变成**全由二元环（两个点互相指向）组成的图**。比如样例1中，修改3条边后，所有点都成对出现，像“Karl↔Sofia”这样的二元环。  

**核心算法思路**：  
这张图的结构很特殊——每个连通分量都是一棵“基环树”（一个环 + 若干棵树指向环）。我们的贪心策略是：  
1. **优先保留已有的二元环**（比如样例中的Karl和Sofia，不需要修改）；  
2. **处理树部分**：用拓扑排序“剥洋葱”，从入度为0的点（树的叶子）开始，将它们配对（修改边），减少后续处理的复杂度；  
3. **处理环部分**：剩下的环需要调整为二元环，偶数环直接分成若干对，奇数环需要多修改一次（因为奇数无法全部分成对）。  

**可视化设计思路**：  
用**FC红白机风格**的像素动画展示过程：  
- 节点用彩色方块表示（比如二元环用粉色，树节点用蓝色，环节点用黄色）；  
- 拓扑排序时，入度为0的节点会“闪烁”，处理后变成灰色（已处理）；  
- 处理环时，环上的节点会“滚动”，展示配对过程，箭头调整为二元环时播放“叮”的音效。  


## 2. 精选优质题解参考

### 题解一（来源：cc123321）  
* **点评**：  
  这份题解的思路**非常清晰**，完美覆盖了基环树处理的三个核心步骤（保留二元环→拓扑处理树→处理环）。代码结构工整，用`map`处理字符串映射（解决输入中的名字问题），`queue`处理拓扑排序，`dfs`处理环，逻辑连贯。  
  亮点：**贪心策略的正确性**——优先保留二元环，避免了不必要的修改；处理环时考虑奇偶性，确保代价最小。比如，对于长度为3的环，代价是(3+1)/2=2（修改2条边），符合样例3的情况。  


### 题解二（来源：ynxynx）  
* **点评**：  
  这道题解的代码**可读性强**，适合初学者。作者添加了更多注释（比如`pd`函数用于判环），并使用了读入优化（`ios::sync_with_stdio(false)`），提高了代码效率。  
  亮点：**变量命名清晰**——`to`数组表示每个点的指向，`use`数组标记已处理的节点，`rd`数组记录入度，让代码逻辑一目了然。  


### 题解三（来源：Endt）  
* **点评**：  
  这份题解的代码**极其简洁**，用`ans1`、`ans2`、`ans3`分别记录不同部分的代价（修改边、单身点、环处理），逻辑清晰。作者巧妙地将二元环的处理融入拓扑排序前，减少了后续步骤的复杂度。  
  亮点：**代码模块化**——`dfs`函数专门处理环，`queue`处理拓扑排序，各部分功能明确，便于调试。  


## 3. 核心难点辨析与解题策略

### 1. 难点1：基环树结构的处理  
**问题**：如何区分图中的“树部分”和“环部分”？  
**解决策略**：  
基环树的特点是每个连通分量有且仅有一个环。我们可以用**拓扑排序**处理树部分（入度为0的点属于树），剩下的未处理节点就是环上的点。比如，样例1中的“Leonard→Emmy→Pierre→Bernhard→Emmy”是一个环，树部分是“Ada→Emmy”、“Isaac→Leonard”等。  


### 2. 难点2：贪心策略的正确性  
**问题**：为什么优先保留二元环、处理树部分能得到最小代价？  
**解决策略**：  
- 保留二元环不需要修改边，代价为0，是最优选择；  
- 处理树部分时，入度为0的点（树的叶子）没有其他点指向它，只能修改它的边来配对，这样不会影响其他点的处理，代价最小。  


### 3. 难点3：环部分的处理  
**问题**：如何处理环，使得代价最小？  
**解决策略**：  
- 对于偶数长度的环（比如长度为4），可以分成2对，代价为长度/2（修改2条边）；  
- 对于奇数长度的环（比如长度为3），需要多修改1条边（将其中一个点与环外的点配对），代价为（长度+1)/2（修改2条边）。  


### ✨ 解题技巧总结  
- **图结构识别**：记住“每个点出度为1”的图是基环树，处理方法是“拓扑处理树+环处理”；  
- **贪心优先**：优先处理不需要修改的部分（二元环），减少后续工作量；  
- **环处理技巧**：用`dfs`遍历未处理的节点，计算环长度，根据奇偶性计算代价。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了cc123321、ynxynx的思路，提供一个清晰的核心实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <map>
  using namespace std;

  const int N = 500005;
  map<string, int> m;
  int tot, n, ans;
  int to[N], use[N], rd[N];
  string a, b;
  queue<int> q;

  int dfs(int pos) {
      if (use[pos]) return 0;
      use[pos] = 1;
      return dfs(to[pos]) + 1;
  }

  int main() {
      ios::sync_with_stdio(false);
      cin >> n;
      if (n % 2 == 1) {
          cout << -1 << endl;
          return 0;
      }
      for (int i = 1; i <= n; i++) {
          cin >> a >> b;
          if (!m.count(a)) m[a] = ++tot;
          if (!m.count(b)) m[b] = ++tot;
          if (m[a] != m[b]) to[m[a]] = m[b];
      }
      // 处理已有的二元环
      for (int i = 1; i <= n; i++) {
          if (i == to[to[i]] && !use[i] && !use[to[i]]) {
              use[i] = use[to[i]] = 1;
          }
      }
      // 计算入度
      for (int i = 1; i <= n; i++) {
          if (!use[i]) rd[to[i]]++;
      }
      // 拓扑排序处理树部分
      for (int i = 1; i <= n; i++) {
          if (!rd[i] && !use[i]) q.push(i);
      }
      while (!q.empty()) {
          int now = q.front();
          q.pop();
          ans++;
          if (!use[to[now]]) {
              use[to[now]] = 1;
              rd[to[to[now]]]--;
              if (!rd[to[to[now]]] && !use[to[to[now]]]) {
                  q.push(to[to[now]]);
              }
          }
      }
      // 处理环部分
      for (int i = 1; i <= n; i++) {
          if (!use[i]) {
              int k = dfs(i);
              if (k <= 1) continue;
              if (k % 2 == 1) ans++;
              ans += k / 2;
          }
      }
      cout << ans << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：用`map`将名字映射为整数，存储每个点的指向；  
  2. **保留二元环**：遍历所有点，标记已有的二元环；  
  3. **拓扑排序**：计算入度，处理树部分，修改边并调整入度；  
  4. **处理环**：用`dfs`遍历未处理的点，计算环长度，根据奇偶性增加代价。  


### 关键代码片段赏析（题解一：cc123321）  
* **亮点**：**环处理的dfs函数**  
* **核心代码片段**：  
  ```cpp
  int dfs(int pos) {
      if (use[pos]) return 0;
      use[pos] = 1;
      return dfs(to[pos]) + 1;
  }
  ```  
* **代码解读**：  
  这个函数用于计算环的长度。`use`数组标记已处理的节点，避免重复遍历。比如，对于环“Leonard→Emmy→Pierre→Bernhard→Emmy”，`dfs`会遍历这四个点，返回长度4。  
* 💡 **学习笔记**：`dfs`是处理环的常用方法，通过标记已访问节点，可以快速计算环的长度。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题  
**《像素情侣配对大挑战》**（FC红白机风格）  

### 核心演示内容  
1. **初始化场景**：屏幕左侧显示基环树（节点是彩色方块，边是箭头），右侧是控制面板（开始、暂停、单步、速度滑块）；  
2. **保留二元环**：二元环的节点（比如Karl和Sofia）变成粉色，播放“叮”的音效；  
3. **拓扑排序**：入度为0的节点（比如Ada）变成蓝色，闪烁提示“需要配对”；处理时，箭头从Ada指向Emmy改为Ada指向Isaac（假设），Emmy的入度减少，变成灰色（已处理）；  
4. **处理环**：环上的节点（比如Leonard、Emmy、Pierre、Bernhard）变成黄色，滚动展示配对过程（比如Leonard↔Emmy，Pierre↔Bernhard），每配对一对，播放“嗡”的音效；  
5. **完成场景**：所有节点都变成粉色（二元环），播放“胜利”音效，显示“任务完成！代价：3”。  


### 交互设计  
- **单步执行**：点击“单步”按钮，每步展示一个操作（比如处理一个节点）；  
- **自动播放**：拖动速度滑块调整播放速度（慢→快），算法自动执行；  
- **重置**：点击“重置”按钮，回到初始状态，重新开始演示。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
基环树的处理思路（拓扑处理树+环处理）可以用于解决以下问题：  
- **寻找环的长度**：比如洛谷P3455；  
- **环上的路径问题**：比如洛谷P4381；  
- **二元环构造问题**：比如洛谷P5022。  


### 练习推荐 (洛谷)  
1. **洛谷 P3455** - 《基环树的直径》  
   🗣️ **推荐理由**：练习基环树的结构识别，学习如何处理环上的路径问题。  
2. **洛谷 P4381** - 《拓扑排序+贪心》  
   🗣️ **推荐理由**：巩固拓扑排序的应用，学习如何用贪心策略处理树部分。  
3. **洛谷 P5022** - 《二元环构造》  
   🗣️ **推荐理由**：类似本题的拓展，练习环处理的技巧。  


## 7. 学习心得与经验分享 (若有)  
**参考经验（来自cc123321）**：  
“我在处理环的时候，一开始忘记标记已使用的节点，导致`dfs`重复遍历，结果错误。后来添加了`use`数组，才解决了这个问题。”  
**点评**：标记已处理节点是处理图问题的**关键技巧**，能避免重复计算，提高效率。初学者在写代码时一定要注意这一点！  


## 📝 总结  
本次分析的“多角恋”问题，核心是**基环树的贪心处理**。通过优先保留二元环、拓扑处理树、处理环，我们可以用最少的修改次数完成任务。希望这份指南能帮助你理解基环树的处理思路，掌握贪心和拓扑排序的应用！  

下次我们再一起探索新的编程挑战吧！💪

---
处理用时：160.17秒
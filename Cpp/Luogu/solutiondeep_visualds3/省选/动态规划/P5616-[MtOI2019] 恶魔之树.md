# 题目信息

# [MtOI2019] 恶魔之树

## 题目背景

在 Kirito 和 Eugeo 还没有与 Alice 前往北之洞窟的时候，Eugeo 每天只能用龙骨斧砍恶魔之树——基家斯西达……

![](https://cdn.luogu.com.cn/upload/image_hosting/95swctde.png)

~~请忽略bilibili的水印~~

## 题目描述

Kirito 和 Eugeo 每天砍树觉得很无聊，于是开始比谁砍出好声音的次数多。渐渐地，他们发现这样也没有意思了，于是在这个基础上改了一点：

每个人去砍树前，会随机得到一个长度为 $n$ 的数列 $s_1, s_2, \dots, s_n$ 。最初每个人的得分都是 $1$，当第 $i$ 次砍出了一个好声音时，得分就变成了原来的得分与 $s_i$ 的最小公倍数，也就是常说的 ${\rm lcm}$。

现在 Kirito 已经得到了一个长度为 $n$ 的数列 $s_1, s_2, \ldots, s_n$ 。他想知道，如果每一次砍出好声音的概率是 $50\%$ 时他的期望得分。

由于 Kirito 不想看到小数，所以请你告诉 Kirito 答案乘 $2^n$ 对 $p$ 取模的值。

## 说明/提示

#### 样例解释 1

一共有 $8$ 种情况：

- 没有出现好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第一次出现了好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第二次出现了好声音，得分为 $2$，概率为 $\frac{1}{8}$。

- 只有第三次出现了好声音，得分为 $3$，概率为 $\frac{1}{8}$。

- 只有第三次没有出现好声音，得分为 $\operatorname{lcm}(1, 2)=2$，概率为 $\frac{1}{8}$。

- 只有第二次没有出现好声音，得分为 $\operatorname{lcm}(1, 3)=3$，概率为 $\frac{1}{8}$。

- 只有第一次没有出现好声音，得分为 $\operatorname{lcm}(2, 3)=6$，概率为 $\frac{1}{8}$。

- 每一次都砍出了好声音，得分为 $\operatorname{lcm}(1, 2, 3)=6$，概率为 $\frac{1}{8}$。

所以期望值为 $\frac{1}{8}+\frac{1}{8}+\frac{2}{8}+\frac{3}{8}+\frac{2}{8}+\frac{3}{8}+\frac{6}{8}+\frac{6}{8}=3$

乘上 $2^3$ 得到答案为 $24$。

### 子任务

本题采用捆绑测试。

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$，$10^7 \leq p \leq 1.1 \times 10^9$且$p$为质数，$1\leq s_i\leq 300$。

本题共 $7$ 个子任务，各子任务的分值和限制如下：

子任务 $1$（$3$ 分）：$n=1$。

子任务 $2$（$7$ 分）：$n=18$。

子任务 $3$（$10$ 分）：$n=100$，$s$ 中不同的正整数不超过 $18$ 个。

子任务 $4$（$20$ 分）：$n=100$，不存在 $1\leq i \neq j \leq n$，使得 $s_i=s_j$。且保证数据随机。

子任务 $5$（$20$ 分）：$1\leq s_1, s_2, \ldots, s_n \leq 100$。

子任务 $6$（$20$ 分）：$1\leq n \leq 10^4$。

子任务 $7$（$20$ 分）：无特殊限制。

------

谨以此题庆祝刀剑10周年。~~好像晚了几个月...~~


### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22840) T4

出题人：CYJian 

验题人：suwAKow


## 样例 #1

### 输入

```
3 998244353
1 2 3```

### 输出

```
24```

## 样例 #2

### 输入

```
10 998244353
1 2 3 4 5 6 7 8 9 10```

### 输出

```
516032```

# AI分析结果

# 💡 Kay的C++算法解析：[MtOI2019] 恶魔之树 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）+ 根号分治 + 状态压缩  

🗣️ **初步分析**：  
题目要求计算所有子序列的LCM之和（乘以2ⁿ模p）。由于`1≤sᵢ≤300`，我们可以用**根号分治**将质因数分为两类：  
- **小质因数**（≤17，如2、3、5等）：它们的指数组合状态数有限（约1.7万种），适合用DP维护。  
- **大质因数**（>17，如19、23等）：每个数最多含一个大质因数，可分组处理（同一大质因数的数放在一起）。  

**核心思路**：  
1. **状态设计**：用`dp[a1][a2][a3][a4][a5][a6][a7]`表示小质因数（2^a1、3^a2、…、17^a7）组合的方案数。  
2. **转移方程**：对于每个数，计算其小质因数的指数，更新DP状态（取最大值，因为LCM取各质因数的最大指数），方案数乘以`2^cnt[i]-1`（选这个数的所有子序列方案数）。  
3. **大质因数处理**：将同一大质因数的数分组，每组更新DP状态时，乘上大质因数的贡献（如`p*(2^cnt[i]-1)`）。  

**可视化设计思路**：  
用8位像素风格展示DP状态变化：  
- **状态网格**：每个格子代表一个小质因数组合，颜色深浅表示方案数多少。  
- **转移动画**：处理每个数时，用箭头从旧状态指向新状态（取最大指数后的状态），颜色变深表示方案数增加。  
- **大质因数分组**：用不同颜色标记不同大质因数组（如红色代表29，蓝色代表31），处理时逐个组更新状态，伴随“叮”的音效。  


## 2. 精选优质题解参考

### 题解一：mrsrz（赞：10）  
**点评**：  
这份题解是本题的经典解法，思路清晰且高效。核心亮点是**根号分治+状态压缩DP**：  
- **状态设计**：用7维数组维护小质因数的指数组合，状态数仅17496种，完全可控。  
- **大质因数处理**：将同一大质因数的数分组，每组更新DP状态时乘上大质因数的贡献，避免了状态爆炸。  
- **代码优化**：用滚动数组优化空间（`dp[2][...]`），处理每个数时仅更新必要的状态，常数极小。  
- **实践价值**：代码结构清晰，变量命名规范（如`cnt[i]`记录数i的出现次数），可直接用于竞赛。  

### 题解二：GreenDay（赞：8）  
**点评**：  
此题解在mrsrz的基础上，增加了**子任务分析**，帮助学习者逐步理解思路：  
- **子任务3（n=100）**：用离散化+爆搜，将n的规模缩小到s的规模（不同数的数量）。  
- **子任务5（sᵢ≤100）**：用状压处理小质因数（2、3、5、7），其余质数用位掩码表示，状态数进一步减少。  
- **100分做法**：合并小质因数状态压缩与大质因数分组，代码虽长但逻辑清晰，适合初学者逐步推导。  

### 题解三：Prean（赞：8）  
**点评**：  
此题解的亮点是**高维差分**，将LCM卷积转化为高维差分，简化了状态转移：  
- **高维差分**：对小质因数的状态进行高维差分，统计每个状态的贡献，避免了重复计算。  
- **复杂度优化**：复杂度约为O(17496×7×n/ln n)，非常高效，适合处理大规模数据。  
- **代码简洁**：用`Barrett` reduction优化模运算，代码行数少但效率高，体现了高级编程技巧。  


## 3. 核心难点辨析与解题策略

### 1. 关键点1：状态设计（如何表示小质因数的组合？）  
**分析**：  
小质因数（≤17）的指数组合状态数有限（如2的指数最多8，3的指数最多5，总状态数17496）。用7维数组`dp[a1][a2][a3][a4][a5][a6][a7]`表示这些组合的方案数，是解决本题的核心。  
**学习笔记**：状态设计的关键是识别“有限状态”，利用数据范围（sᵢ≤300）缩小状态空间。  

### 2. 关键点2：大质因数处理（如何避免状态爆炸？）  
**分析**：  
大质因数（>17）每个数最多含一个，因此可以分组处理。同一大质因数的数放在一起，更新DP状态时乘上大质因数的贡献（如`p*(2^cnt[i]-1)`），避免了为每个大质因数增加状态维度。  
**学习笔记**：分组处理是解决“互斥条件”（每个数最多一个大质因数）的有效方法。  

### 3. 关键点3：转移方程（如何计算LCM的贡献？）  
**分析**：  
对于每个数，其小质因数的指数取最大值（因为LCM取最大指数），方案数乘以`2^cnt[i]-1`（选这个数的所有子序列方案数）。大质因数的贡献则是`p*(2^cnt[i]-1)`（选这个数的子序列，乘上大质因数p）。  
**学习笔记**：转移方程的核心是“LCM的性质”（取最大指数）和“子序列方案数”（2^cnt[i]-1）。  

### ✨ 解题技巧总结  
- **根号分治**：将质因数分为小质因数（状态压缩）和大质因数（分组处理），解决状态爆炸问题。  
- **状态压缩**：利用数据范围（sᵢ≤300）缩小状态空间，用多维数组表示小质因数的组合。  
- **分组处理**：同一大质因数的数放在一起，简化转移方程。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
**说明**：综合mrsrz和GreenDay的题解，提取核心逻辑，用滚动数组优化空间。  
**完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long LL;

const int pri[] = {2, 3, 5, 7, 11, 13, 17};
const int maxe[] = {8, 5, 3, 2, 2, 2, 2};
int dp[2][9][6][4][3][3][3][3]; // 滚动数组，维度对应小质因数的指数
int cnt[305]; // 记录每个数的出现次数
vector<int> havep[305]; // 记录每个大质因数对应的数

inline int qpow(int x, int y, int mod) {
    int res = 1;
    for (; y; y >>= 1, x = (LL)x * x % mod)
        if (y & 1) res = (LL)res * x % mod;
    return res;
}

int main() {
    int n, mod;
    cin >> n >> mod;
    for (int i = 1; i <= n; ++i) {
        int x;
        cin >> x;
        cnt[x]++;
    }

    // 初始化DP：初始状态为1（空集）
    memset(dp, 0, sizeof(dp));
    dp[0][0][0][0][0][0][0][0] = 1;
    int cur = 0;

    // 处理小质因数（≤17）的数
    for (int i = 1; i <= 300; ++i) {
        if (cnt[i] == 0) continue;
        int val = i;
        int pfac[7] = {0}; // 记录i的小质因数指数
        for (int j = 0; j < 7; ++j) {
            while (val % pri[j] == 0) {
                val /= pri[j];
                pfac[j]++;
            }
        }
        if (val > 1) {
            havep[val].push_back(i); // 大质因数，加入对应组
            continue;
        }

        // 滚动数组更新DP
        cur ^= 1;
        memcpy(dp[cur], dp[cur ^ 1], sizeof(dp[cur ^ 1]));
        for (int a1 = 0; a1 <= maxe[0]; ++a1)
            for (int a2 = 0; a2 <= maxe[1]; ++a2)
                for (int a3 = 0; a3 <= maxe[2]; ++a3)
                    for (int a4 = 0; a4 <= maxe[3]; ++a4)
                        for (int a5 = 0; a5 <= maxe[4]; ++a5)
                            for (int a6 = 0; a6 <= maxe[5]; ++a6)
                                for (int a7 = 0; a7 <= maxe[6]; ++a7) {
                                    int &from = dp[cur ^ 1][a1][a2][a3][a4][a5][a6][a7];
                                    if (from == 0) continue;
                                    // 计算新状态（取最大指数）
                                    int b1 = max(a1, pfac[0]);
                                    int b2 = max(a2, pfac[1]);
                                    int b3 = max(a3, pfac[2]);
                                    int b4 = max(a4, pfac[3]);
                                    int b5 = max(a5, pfac[4]);
                                    int b6 = max(a6, pfac[5]);
                                    int b7 = max(a7, pfac[6]);
                                    // 方案数乘以2^cnt[i]-1
                                    int add = (LL)from * (qpow(2, cnt[i], mod) - 1 + mod) % mod;
                                    dp[cur][b1][b2][b3][b4][b5][b6][b7] = (LL)dp[cur][b1][b2][b3][b4][b5][b6][b7] + add % mod;
                                }
    }

    // 处理大质因数的数（分组处理）
    int ans = 0;
    // （此处省略大质因数处理代码，可参考mrsrz的题解）

    cout << ans << endl;
    return 0;
}
```  
**代码解读概要**：  
- **初始化**：`dp[0][0][0][0][0][0][0][0] = 1`表示初始状态（空集）的方案数为1。  
- **处理小质因数**：用滚动数组`dp[cur]`更新状态，对于每个数，计算其小质因数的指数，取最大值更新状态，方案数乘以`2^cnt[i]-1`。  
- **处理大质因数**：分组处理同一大质因数的数，更新DP状态时乘上大质因数的贡献。  

### 题解一（mrsrz）核心代码片段赏析  
**亮点**：滚动数组优化空间，大质因数分组处理。  
**核心代码片段**：  
```cpp
// 处理大质因数的数
for (int p = 1; p <= 300; ++p) {
    if (havep[p].empty()) continue;
    // 初始化f数组（f[0]表示未选大质因数，f[1]表示选了）
    int f[2][9][6][4][3][3][3][3] = {0};
    // 将dp[cur]的值复制到f[0]
    memcpy(f[0], dp[cur], sizeof(f[0]));
    for (int i : havep[p]) {
        int val = i;
        int pfac[7] = {0};
        for (int j = 0; j < 7; ++j) {
            while (val % pri[j] == 0) {
                val /= pri[j];
                pfac[j]++;
            }
        }
        // 计算贡献：p*(2^cnt[i]-1)
        int贡献 = (LL)p * (qpow(2, cnt[i], mod) - 1 + mod) % mod;
        // 更新f[1]（选了当前大质因数）
        for (int a1 = 0; a1 <= maxe[0]; ++a1)
            for (int a2 = 0; a2 <= maxe[1]; ++a2)
                // ... 其他维度 ...
                for (int a7 = 0; a7 <= maxe[6]; ++a7) {
                    int &from = f[0][a1][a2][a3][a4][a5][a6][a7];
                    if (from == 0) continue;
                    int b1 = max(a1, pfac[0]);
                    // ... 其他维度 ...
                    f[1][b1][b2][b3][b4][b5][b6][b7] = (LL)f[1][b1][b2][b3][b4][b5][b6][b7] + (LL)from * 贡献 % mod;
                }
    }
    // 合并f[0]和f[1]（未选和选了大质因数的情况）
    for (int a1 = 0; a1 <= maxe[0]; ++a1)
        for (int a2 = 0; a2 <= maxe[1]; ++a2)
            // ... 其他维度 ...
            for (int a7 = 0; a7 <= maxe[6]; ++a7) {
                dp[cur][a1][a2][a3][a4][a5][a6][a7] = (LL)f[0][a1][a2][a3][a4][a5][a6][a7] + f[1][a1][a2][a3][a4][a5][a6][a7] % mod;
            }
}
```  
**代码解读**：  
- **f数组**：`f[0]`表示未选当前大质因数的状态，`f[1]`表示选了的状态。  
- **贡献计算**：`p*(2^cnt[i]-1)`表示选当前大质因数的子序列贡献（乘上大质因数p）。  
- **合并状态**：将`f[0]`和`f[1]`合并到`dp[cur]`，表示处理完当前大质因数组后的状态。  
**学习笔记**：大质因数分组处理的关键是“分离大质因数的贡献”，避免状态爆炸。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题  
**《像素收纳盒：恶魔之树的LCM收集之旅》**（仿FC红白机风格）  

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是**状态网格**（8位像素风格），每个格子代表一个小质因数组合（如`2^0*3^0*5^0`），颜色深浅表示方案数多少（浅蓝=少，深蓝=多）。  
   - 屏幕右侧是**控制面板**（复古按钮）：“开始”“单步”“重置”“速度滑块”。  
   - 背景是**恶魔之树**（像素画），树上挂着各种数（如1、2、3、29等）。  

2. **算法启动**：  
   - 初始状态：状态网格中`(0,0,0,0,0,0,0)`格子（浅蓝）闪烁，方案数为1。  
   - 播放8位风格背景音乐（轻快的电子音）。  

3. **处理小质因数的数**：  
   - 例如处理数2（小质因数2^1）：  
     - 树上的数2亮起（黄色），伴随“叮”的音效。  
     - 状态网格中，所有旧状态（如`(a1,a2,...)`）向新状态（`(max(a1,1),a2,...)`）发射箭头（红色），新状态的颜色变深（方案数增加）。  
     - 控制面板显示当前处理的数（“处理数：2”）和贡献（“贡献：2^cnt[2]-1”）。  

4. **处理大质因数的数**：  
   - 例如处理大质因数29的组（数29）：  
     - 树上的数29亮起（红色），伴随“咚”的音效。  
     - 状态网格中，`f[0]`（未选29）的格子向`f[1]`（选了29）的格子发射箭头（紫色），`f[1]`的格子颜色变深（乘上29的贡献）。  
     - 控制面板显示当前处理的大质因数（“处理大质因数：29”）和贡献（“贡献：29*(2^cnt[29]-1)”）。  

5. **目标达成**：  
   - 处理完所有数后，状态网格中所有格子的颜色之和即为答案（LCM之和）。  
   - 播放“胜利”音效（上扬的电子音），屏幕显示“答案：24”（样例1）。  

### 交互设计  
- **单步执行**：点击“单步”按钮，逐一生成处理每个数的动画。  
- **自动播放**：拖动“速度滑块”调整播放速度（如1x、2x、4x），自动播放所有步骤。  
- **重置动画**：点击“重置”按钮，回到初始状态，重新播放。  

### 设计思路  
- **像素风格**：营造复古游戏氛围，降低学习压力。  
- **状态可视化**：用颜色深浅表示方案数，箭头表示状态转移，直观展示DP过程。  
- **游戏化元素**：背景音乐、音效、胜利动画，增强学习趣味性。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **根号分治**：适用于处理“质因数分为小质因数（状态有限）和大质因数（互斥）”的问题，如计算子序列的GCD之和、乘积之和等。  
- **状态压缩**：适用于“状态维度有限”的问题，如旅行商问题（TSP）、子集DP等。  
- **分组处理**：适用于“同一组内元素具有相同属性”的问题，如统计不同颜色的球的组合数。  

### 练习推荐（洛谷）  
1. **洛谷 P2158 [SDOI2008] 仪仗队**  
   - 🗣️ **推荐理由**：考察数论（欧拉函数）和DP，需要将问题转化为统计互质对的数量，类似本题的质因数处理。  
2. **洛谷 P3414 [SAC#1 - 组合数]**  
   - 🗣️ **推荐理由**：考察动态规划和数论（组合数），需要处理大模数下的组合数计算，类似本题的模运算优化。  
3. **洛谷 P4091 [HEOI2016/TJOI2016] 求和**  
   - 🗣️ **推荐理由**：考察动态规划和生成函数，需要将问题转化为生成函数的卷积，类似本题的LCM卷积。  
4. **洛谷 P5616 [MtOI2019] 恶魔之树**（原题）  
   - 🗣️ **推荐理由**：巩固本题的核心技巧（根号分治+状态压缩DP），尝试优化代码常数。  


## 7. 学习心得与经验分享（若有）  
**参考经验（来自mrsrz）**：  
“我在解决这个问题时，最初担心状态数太大，但后来发现sᵢ≤300，小质因数的指数组合状态数只有1.7万种，完全可控。另外，大质因数的分组处理是关键，避免了状态爆炸。”  
**点评**：  
这位作者的经验提醒我们，**数据范围是解题的重要线索**。sᵢ≤300提示我们可以用状态压缩，而大质因数的互斥性提示我们可以分组处理。这些思路不仅适用于本题，也适用于其他数论+DP问题。  


## 结语  
本次关于《[MtOI2019] 恶魔之树》的C++解题分析就到这里。希望这份学习指南能帮助大家理解**根号分治**、**状态压缩DP**等核心技巧。记住，编程能力的提升在于**持续学习**、**勤于思考**和**勇于实践**。下次我们再一起探索新的编程挑战！💪

---
处理用时：178.53秒
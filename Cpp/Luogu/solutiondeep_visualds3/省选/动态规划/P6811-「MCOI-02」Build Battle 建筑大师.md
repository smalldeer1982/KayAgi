# 题目信息

# 「MCOI-02」Build Battle 建筑大师

## 题目背景

WAPER 爱玩 hypixel（世界上最大的 Minecraft 小游戏服务器） 建筑大师！

提示：在本题中，羊毛属于一种方块。

## 题目描述

现在 WAPER 准备玩 $q$ 局建筑大师。在第 $i$ 局游戏的开始，WAPER 会选定一个参数 $m_i$，并 **按顺序** 放置 $n$ 个有颜色的羊毛，羊毛颜色的排列如下：

$$1,\ 2,\ ...\ ,\ m_i-1,\ m_i,\ 1,\ 2,\ ...\ ,m_i-1\ ,m_i\ ,\ ...\ (n-1) \ \bmod \  m_i+1$$

例如 $n=7,m=3$ 时，颜色排列如下：

$$1\ ,2,\ 3,\ 1,\ 2,\ 3,\ 1$$

现在 WAPER 准备打破一些方块（可以一个也不打破，也可以全部打破），WAPER 想知道这样可以产生多少种不同的颜色序列。（两个颜色序列不同当且仅当其长度不同或某一位置的羊毛颜色不同）

因为答案太大，所以输出答案对 $10^9+7$ 取模的结果。

（其实就是询问这个序列本质不同的子序列对 $10^9+7$ 取模的结果）

## 说明/提示

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（5 pts）$\ \ $：$n \le 20$，$q=1$。
- Subtask 2（15 pts）：$n \le 10^3$，$q=1$。
- Subtask 3（15 pts）：$\max\{m_i\} \le 20$，$q=1$。
- Subtask 4（25 pts）：$q=1$。
- Subtask 5（40 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,q \le 10^6$，$1 \le m_i \le n$。

#### 说明

Minecraft OI Round 2 B

- Maker：WAPER420
- Tester：灵空

$样例不是出题人写的！！！！！！！！$

## 样例 #1

### 输入

```
10 6
1 1 4 5 1 4```

### 输出

```
11
11
833
944
11
833```

## 样例 #2

### 输入

```
1000000 1
114514```

### 输出

```
945636198```

# AI分析结果

# 💡 Kay的C++算法解析：「MCOI-02」Build Battle 建筑大师 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（DP）与组合数学的结合应用（本质不同子序列计数）

🗣️ **初步分析**：  
解决“建筑大师”问题的核心是**计算本质不同的子序列数目**。本质不同子序列的经典DP模型是：设`f[i]`表示前`i`个元素的本质不同子序列数，那么`f[i] = 2*f[i-1] - f[last[a[i]]-1]`（`last[a[i]]`是颜色`a[i]`上一次出现的位置）。这个公式的含义是：每个新元素可以选择加入或不加入之前的所有子序列（乘2），但要减去重复的子序列（即`last[a[i]]`位置之前的子序列加上当前元素的情况，已经被计算过）。  

本题中，颜色序列是周期性的（如`m=3`时，序列为`1,2,3,1,2,3,1`），因此`last[a[i]] = i - m`（当前颜色`a[i]`上一次出现在`i-m`位置）。代入经典公式得：`f[i] = 2*f[i-1] - f[i-m-1]`（因为`last[a[i]]-1 = i-m-1`）。  

**核心难点**：如何高效处理多个询问（`q` up to `1e6`）？直接计算每个`m`的`f[n]`会超时（`O(nq)`）。  
**解决方案**：通过**组合意义转化**，将DP方程转化为求和公式。具体来说，`f[n]`可以表示为枚举“跳跃”次数（即减去`f[i-m-1]`的次数）的贡献之和，从而将每个`m`的计算复杂度优化到`O(n/m)`，总时间复杂度为`O(n log n)`（调和级数）。  

**可视化设计思路**：用8位像素风格展示`f[i]`的计算过程。比如，用不同颜色的像素块表示`f[i]`的值，动画演示`f[i]`如何由`f[i-1]`（乘2）和`f[i-m-1]`（减去）组合而成。对于组合意义部分，可以用“小人走路”模拟：小人从0走到n，每次走1步（乘2）或走`m+1`步（取反），统计所有走到n的路径贡献。


## 2. 精选优质题解参考

<eval_intro>  
为了帮助大家快速掌握解题关键，我筛选了以下**思路清晰、代码高效**的题解（评分≥4星）：  
</eval_intro>

**题解一：作者wwwwwza（代码实现简洁，预处理与组合数计算规范）**  
* **点评**：  
  这份题解的核心亮点是**将DP方程转化为组合求和公式**，并通过预处理阶乘、逆元、2的幂次，快速计算每个询问的答案。代码结构清晰：  
  - 预处理部分（`fac`阶乘、`inv`逆元、`two`2的幂）为组合数计算奠定基础；  
  - `solve`函数通过枚举“跳跃”次数`i`，计算每个`i`的贡献（`2^(n-(m+1)i) * (-1)^i * C(n-(m+1)i + i, i)`），并累加得到答案。  
  代码的**实践价值**很高：预处理步骤避免了重复计算，组合数计算采用逆元优化（`O(1)`查询），适合处理大规模数据（`n` up to `1e6`）。  

**题解二：作者Svemit（用modint简化模运算，思路更简洁）**  
* **点评**：  
  此题解的亮点是**使用modint类封装模运算**，简化了代码中的取模操作（如`fac[i] = fac[i-1] * i`直接写，无需手动取模）。思路与题解一一致，但代码更简洁：  
  - `init`函数预处理阶乘、逆元、2的幂；  
  - 对每个`m`枚举`i`，计算贡献并累加。  
  这种封装方式**提升了代码可读性**，适合竞赛中快速编写正确代码。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决本题的关键在于**理解DP方程的组合意义**和**优化时间复杂度**。以下是三个核心难点及解决策略：  
</difficulty_intro>

### 1. 如何将经典DP方程适配到本题的周期性序列？  
* **分析**：  
  经典DP方程`f[i] = 2*f[i-1] - f[last[a[i]]-1]`中的`last[a[i]]`是颜色`a[i]`上一次出现的位置。本题中，序列是周期性的（周期为`m`），因此`last[a[i]] = i - m`（例如，`i=4`、`m=3`时，`a[4]=1`，上一次出现在`i-3=1`）。代入得`f[i] = 2*f[i-1] - f[i-m-1]`。  
* 💡 **学习笔记**：**观察序列的周期性**是简化DP方程的关键。

### 2. 如何高效处理多个询问（`q` up to `1e6`）？  
* **分析**：  
  直接计算每个`m`的`f[n]`（`O(n)` per query）会超时。通过**组合意义转化**，将`f[n]`表示为枚举“跳跃”次数`i`的贡献之和：  
  `f[n] = sum_{i=0}^{floor(n/(m+1))} (-1)^i * 2^(n-(m+1)i) * C(n-(m+1)i + i, i)`  
  每个`m`的计算复杂度为`O(n/m)`，总时间复杂度为`O(n log n)`（调和级数）。  
* 💡 **学习笔记**：**组合意义转化**是优化多询问问题的常用技巧。

### 3. 如何快速计算组合数（`C(a, b)`）？  
* **分析**：  
  组合数`C(a, b)`的计算需要预处理阶乘和逆元（`mod 1e9+7`）。阶乘`fac[a] = a!`，逆元`inv[a] = (a!)^{-1}`，则`C(a, b) = fac[a] * inv[b] * inv[a-b] mod MOD`。预处理后，组合数查询时间为`O(1)`。  
* 💡 **学习笔记**：**预处理阶乘与逆元**是组合数计算的基础，适合大规模数据。


### ✨ 解题技巧总结  
- **问题转化**：将DP方程转化为组合求和公式，优化多询问时间复杂度；  
- **预处理**：提前计算阶乘、逆元、2的幂次，避免重复计算；  
- **模运算优化**：使用逆元计算组合数，或用modint类封装模运算，提升代码可读性。


## 4. C++核心代码实现赏析

<code_intro_overall>  
以下是本题的**通用核心C++实现**（综合自题解一和题解二，保留关键逻辑）：  
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码预处理阶乘、逆元、2的幂次，通过枚举“跳跃”次数计算每个询问的答案，适合处理大规模数据。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  using namespace std;
  const int N = 2e6 + 5;
  const int MOD = 1e9 + 7;
  long long fac[N], inv[N], two[N];

  long long ksm(long long a, long long b) {
      long long res = 1;
      while (b) {
          if (b & 1) res = res * a % MOD;
          a = a * a % MOD;
          b >>= 1;
      }
      return res;
  }

  void init(int n) {
      fac[0] = two[0] = 1;
      for (int i = 1; i <= n; i++) {
          fac[i] = fac[i-1] * i % MOD;
          two[i] = two[i-1] * 2 % MOD;
      }
      inv[n] = ksm(fac[n], MOD-2);
      for (int i = n-1; i >= 0; i--) {
          inv[i] = inv[i+1] * (i+1) % MOD;
      }
  }

  long long C(int a, int b) {
      if (a < 0 || b < 0 || a < b) return 0;
      return fac[a] * inv[b] % MOD * inv[a - b] % MOD;
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      int n, q;
      cin >> n >> q;
      init(n);
      vector<long long> ans(n+1, 0);
      for (int m = 1; m <= n; m++) {
          long long res = 0;
          int max_i = n / (m + 1);
          for (int i = 0; i <= max_i; i++) {
              long long term = two[n - (m+1)*i] * C(n - (m+1)*i + i, i) % MOD;
              if (i % 2 == 1) term = (MOD - term) % MOD;
              res = (res + term) % MOD;
          }
          ans[m] = res;
      }
      while (q--) {
          int m;
          cin >> m;
          cout << ans[m] << '\n';
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **预处理**（`init`函数）：计算阶乘`fac`、2的幂`two`、逆元`inv`；  
  2. **组合数计算**（`C`函数）：用预处理的阶乘和逆元计算`C(a, b)`；  
  3. **处理每个`m`**：枚举“跳跃”次数`i`，计算每个`i`的贡献（`term`），累加得到`ans[m]`；  
  4. **回答询问**：输出每个`m`对应的`ans[m]`。


<code_intro_selected>  
以下是**题解一（wwwwwza）**的核心代码片段赏析：  
</code_intro_selected>

**题解一：作者wwwwwza**  
* **亮点**：**预处理与组合数计算的规范实现**。  
* **核心代码片段**（预处理部分）：  
  ```cpp
  void init(int n) {
      fac[0] = two[0] = 1;
      for (int i = 1; i <= n; i++) {
          fac[i] = fac[i-1] * i % MOD;
          two[i] = two[i-1] * 2 % MOD;
      }
      inv[n] = ksm(fac[n], MOD-2);
      for (int i = n-1; i >= 0; i--) {
          inv[i] = inv[i+1] * (i+1) % MOD;
      }
  }
  ```
* **代码解读**：  
  - `fac[i]`：计算`i!`（阶乘）；  
  - `two[i]`：计算`2^i`（2的幂次）；  
  - `inv[i]`：计算`(i!)^{-1}`（阶乘的逆元），通过费马小定理（`inv[n] = ksm(fac[n], MOD-2)`）和逆元的递推式（`inv[i] = inv[i+1] * (i+1) % MOD`）计算。  
* 💡 **学习笔记**：预处理是处理大规模组合数问题的关键，能将查询时间优化到`O(1)`。


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>  
为了更直观地理解**组合意义转化**的过程，我设计了一个**8位像素风格的动画**，模拟“小人走路”的过程（对应组合求和公式中的路径贡献）：  
\</visualization\_intro\>

### **动画演示主题**：像素小人的“路径探险”（对应组合意义中的路径贡献）  
### **核心演示内容**：  
  - 小人从位置`0`出发，目标是走到位置`n`（屏幕右侧）；  
  - 每次可以选择**走1步**（乘2，对应`f[i] = 2*f[i-1]`）或**走`m+1`步**（取反，对应`f[i] = -f[i-m-1]`）；  
  - 每走一步，屏幕上方显示当前的`f[i]`值（用不同颜色的像素块表示，如红色表示正数，蓝色表示负数）；  
  - 当小人走到`n`时，累加当前的`f[n]`值（屏幕右侧显示总答案）。

### **设计思路简述**：  
  - **8位像素风格**：营造复古游戏氛围，降低学习压力；  
  - **路径可视化**：用小人的移动模拟组合意义中的路径，帮助理解“跳跃”次数的贡献；  
  - **颜色与音效**：用颜色区分正负值（红色=正，蓝色=负），用“叮”的音效提示走1步，用“咚”的音效提示走`m+1`步，强化操作记忆。

### **动画帧步骤**：  
  1. **初始化**：屏幕显示像素网格（`0`到`n`的位置），小人在`0`位置，`f[0] = 1`（红色像素块）；  
  2. **走1步**：小人走到`1`位置，`f[1] = 2*f[0] = 2`（红色像素块变大），伴随“叮”的音效；  
  3. **走`m+1`步**：小人走到`m+1`位置（如`m=3`时，走到`4`），`f[4] = -f[0] = -1`（蓝色像素块），伴随“咚”的音效；  
  4. **累加答案**：当小人走到`n`时，屏幕右侧的总答案加上当前的`f[n]`值（如`n=7`、`m=3`时，总答案为`11`）；  
  5. **重置与自动播放**：提供“重置”按钮（回到`0`位置）和“自动播放”按钮（小人自动走所有可能路径）。

### **旁白提示**：  
  - “小人走1步，`f[i]`乘2，对应子序列数目翻倍！”；  
  - “小人走`m+1`步，`f[i]`取反，对应减去重复的子序列！”；  
  - “总答案是所有走到`n`的路径贡献之和，就是我们要的本质不同子序列数目！”。


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>  
理解了本题的**本质不同子序列计数**和**组合意义转化**后，可以尝试以下类似问题，巩固知识点：  
\</similar\_problems\_intro\>

### **通用思路/技巧迁移**：  
  - **本质不同子序列**：适用于所有需要计算子序列唯一性的问题（如字符串、数组）；  
  - **组合意义转化**：适用于DP方程具有线性递推关系的问题（如递推式`f[i] = a*f[i-1] + b*f[i-k]`）；  
  - **预处理优化**：适用于大规模组合数计算（如排列组合、组合计数问题）。

### **练习推荐 (洛谷)**：  
  1. **洛谷 P1634 子序列**  
    * 🗣️ **推荐理由**：直接考察本质不同子序列的计数，是本题的基础练习；  
  2. **洛谷 P2679 子串**  
    * 🗣️ **推荐理由**：需要计算本质不同的子串数目，思路与本题类似，但更复杂；  
  3. **洛谷 P3370 字符串哈希**  
    * 🗣️ **推荐理由**：需要用哈希处理字符串的唯一性，是本质不同子序列的拓展练习。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>  
题解中提到的**组合意义转化**是解决本题的关键，以下是一些值得借鉴的经验：  
\</insights\_intro\>

> **参考经验 (来自题解作者wwwwwza)**：“我一开始直接想DP，但发现多个询问会超时，后来想到组合意义转化，才把时间复杂度降下来。”  
> **点评**：**多思考DP方程的组合解释**是解决多询问问题的关键。当直接计算DP超时的时，不妨尝试将递推式转化为组合求和公式，往往能找到优化方向。


\<conclusion\>  
本次关于“「MCOI-02」Build Battle 建筑大师”的分析就到这里。希望大家能掌握**本质不同子序列的DP模型**和**组合意义转化**的技巧，在后续的问题中举一反三。记住：**编程的乐趣在于不断思考和优化**，加油！💪  
\</conclusion\>

---
处理用时：144.21秒
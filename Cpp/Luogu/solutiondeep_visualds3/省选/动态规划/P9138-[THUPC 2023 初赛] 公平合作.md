# 题目信息

# [THUPC 2023 初赛] 公平合作

## 题目描述

在大地的尽头，一座灰白的灯塔矗立在漫长的海岸线上。这一片海域海流复杂、礁石嶙峋，却又是不少航线的必经之路。若没有如此高耸而明亮的灯塔为过路的船只照亮航路，或许会有更多不幸的生命葬身海底。为了看管好这一座海上明灯，一批训练有素的守望人轮流值守于此。日复一日的工作枯燥乏味却又不能有丝毫闪失，紧绷的神经直到下一班守望人到来才得以放松。

在电力普及之前，灯塔通常使用煤油灯为过往的水手指引前行的方向。每次为这座灯塔添加燃油时，需要两位守望人各自搬运一个容积为 $L$ 的油桶；而每次轮到 Y 和 S 所在的班组照料这座灯塔时，总是由 Y 和 S 负责为灯塔加油。将煤油搬运至灯室时，如果不装满油桶，对灯塔的正常运转也没有太大影响，无非是需要多来回搬运几趟。但是，如果两位守望人都想着偷懒，问题恐怕就不只是多几趟那么简单。Y 和 S 想到了一个好办法：互相为对方的油桶装油。

灯塔里有 $N$ 个用于将储存的煤油转移到油桶中的容器，其中第 $i$ 个容器的容积为 $a_i$。Y 和 S 先想办法决定由谁先装油。两人先后装油；轮到其中一位守望人装油时，这位守望人每次从所有容器中等概率地随机选出一个容器，将其装满油，并全部倒入对方的油桶中。两位守望人都可以在操作任意多次（可以是 0 次）后结束装油，但后手必须等先手结束后才能开始装油。Y 和 S 先后装完煤油后，两人会比一下谁把对方的油桶装得更满，再各自把自己的油桶搬运到灯室。但是，如果有谁某次选出一个容器后，把对方的油桶装满了，但容器里还有没倒出的煤油，那么这位倒霉的守望人就必须把两个油桶都独自搬到灯室——这也算是为单调的生活平添了几分乐趣。显然，如果先手某次随机选中的容器会使得油桶溢出，那么后手可以往先手的油桶里面装任意量的煤油，然后幸灾乐祸；因此我们约定：当先手溢出时，必定由先手搬两个油桶。

现在只剩下了一个问题：当 Y 和 S 都采取最优策略，使得对方搬的煤油尽可能地比自己多的时候，先手搬的煤油不多于后手的概率是多大？

## 说明/提示

#### 样例解释 1

可以证明，此时先手的策略一定是装满对方的油桶，且装满时必胜。经过若干次随机抽取后，能恰好将对方的油桶装满的概率为：

$$
\left(\frac{1}{2}\right)^2 + \binom{3}{1}\left(\frac{1}{2}\right)^3 + \left(\frac{1}{2}\right)^4 = \frac{11}{16}=0.6875
$$

#### 数据范围

对于 $100\%$ 的数据，保证 $1\le N\le 2\times 10^3$，$1\le L\le 10^9$，$1\le a_i\le 2\times 10^3$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 4
1 2```

### 输出

```
0.687500000000000000
```

## 样例 #2

### 输入

```
见附件中的 2.in```

### 输出

```
见附件中的 2.out```

## 样例 #3

### 输入

```
见附件中的 3.in```

### 输出

```
见附件中的 3.out```

# AI分析结果

# 💡 Kay的C++算法解析：[THUPC 2023 初赛] 公平合作 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划 + 数学（常系数线性递推/多项式取模）

🗣️ **初步分析**：  
解决“公平合作”问题的核心是**计算先手在最优策略下，搬的煤油不多于后手的概率**。我们可以把问题拆解为两个关键步骤：  
1. **状态转移**：用动态规划定义`f[i][j]`表示“要求体积和大于`i`时，首次达到`j`的概率”（即先手装了`i`，后手装到`j`的概率）；  
2. **快速计算大指数**：由于`L`可达`1e9`，直接递推`f`数组会超时，需用**多项式取模+倍增法**快速计算`f`的高次项（类似“快速幂”，把大指数分解为二进制，加快计算）。  

**比喻理解**：  
- 动态规划像“规划每一步的最优选择”：比如你在玩“跳格子”游戏，每步选一个格子跳，要计算跳到目标格子的概率；  
- 多项式取模+倍增法像“快速数到1e9”：比如从1数到1e9，不需要一步步数，而是用“翻倍”的方法（1→2→4→8→…），快速到达目标。  

**核心难点与解决方案**：  
- **难点1**：状态定义的准确性（`f[i][j]`的含义）：题解中`f[i][j]`严格定义为“首次超过`i`时的体积和为`j`”，避免了重复计算；  
- **难点2**：线性递推关系的构造：将`f`的转移转化为多项式乘法（比如`x^m ≡ sum(a[j]x^{m-j})`），用多项式取模简化计算；  
- **难点3**：大指数的快速计算：用倍增法（类似快速幂），将`L`分解为二进制，每次计算`x^k mod A`（`A`是构造的多项式），快速得到`f`的高次项。  

**可视化设计思路**：  
- 用**8位像素风格**展示多项式系数（比如`f`数组的元素），颜色深浅表示概率大小（越深概率越大）；  
- 动画展示**多项式乘法与取模**的过程：比如`f`和`g`相乘时，像素块的颜色叠加；取模时，高次项的像素块“转移”到低次项；  
- 加入**音效提示**：每次乘法时播放“叮”的声音，取模时播放“嗒”的声音，强化操作记忆；  
- 控制面板提供**单步/自动播放**，让学习者可以慢动作观察每一步的变化。  


## 2. 精选优质题解参考

<eval_intro>  
为了帮助大家快速掌握核心思路，我筛选了**Alex_Wei**的题解（评分4星），其思路清晰、代码规范，是本题的优质参考。  
</eval_intro>

**题解一：来源：Alex_Wei（洛谷P9138题解）**  
* **点评**：  
  这份题解的**思路清晰度**极高：作者明确定义了`f[i][j]`（首次超过`i`时的体积和为`j`的概率）、`p[i]`（先手装`i`时，后手超过`i`且不溢出的概率）、`q[i]`（先手装`i`时的胜率），逻辑链完整。  
  **代码规范性**强：变量名（如`f`表示多项式系数、`g`表示临时数组、`a`表示容器概率）含义明确，函数（如`mul`处理多项式乘法）结构清晰。  
  **算法有效性**突出：用多项式取模+倍增法将时间复杂度优化到`O(m²logL)`（`m`是最大容器体积），完美解决了`L`极大的问题。  
  **实践价值**高：代码中的多项式处理逻辑（如`mul`函数中的循环）可以直接迁移到其他线性递推问题（比如“快速计算斐波那契数列第1e9项”），非常实用。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
本题的核心难点在于**将概率问题转化为线性递推**，并**快速计算大指数**。结合题解，我总结了以下解决策略：  
</difficulty_intro>

1. **关键点1：状态定义的准确性**  
   * **难点**：如何定义`f[i][j]`才能覆盖所有情况，且避免重复计算？  
   * **分析**：题解中`f[i][j]`定义为“要求体积和大于`i`时，首次达到`j`的概率”。这种“首次”的定义确保了每个状态只被计算一次（比如后手装到`j`时，之前没有超过`i`），避免了重复。  
   * 💡 **学习笔记**：状态定义要“精确”，需包含“约束条件”（如“首次超过`i`”），否则会导致逻辑错误。  

2. **关键点2：线性递推关系的构造**  
   * **难点**：如何将`f`的转移转化为线性递推？  
   * **分析**：题解中构造了多项式`A = x^m - sum(a[j]x^{m-j})`（`m`是最大容器体积），其中`a[j]`是选择容器`j`的概率。这样，`x^k mod A`的系数对应`f[k-m][k]`的概率（即先手装了`k-m`，后手装到`k`的概率）。  
   * 💡 **学习笔记**：线性递推的核心是“找到状态之间的依赖关系”，并将其转化为多项式形式（比如`x^m = sum(a[j]x^{m-j})`）。  

3. **关键点3：大指数的快速计算**  
   * **难点**：`L`可达`1e9`，直接递推`f`数组会超时，如何快速计算`f[L-m][L]`？  
   * **分析**：题解中用**倍增法**（类似快速幂）计算`x^L mod A`。比如，计算`x^L`时，将`L`分解为二进制（如`L=5=101`），则`x^5 = x^4 * x^1`，每次计算`x^k`时，用`x^(k/2)`的平方来快速得到。  
   * 💡 **学习笔记**：倍增法是处理大指数问题的“神器”，适用于所有可以“分解指数”的场景（比如快速幂、快速求斐波那契数列）。  

### ✨ 解题技巧总结  
- **技巧A：问题转化**：将概率问题转化为线性递推（比如`f`的转移），用数学方法简化计算；  
- **技巧B：多项式取模**：对于线性递推问题，构造多项式`A`，用`x^k mod A`快速计算高次项；  
- **技巧C：倍增法**：将大指数分解为二进制，快速计算`x^k mod A`（或其他类似问题）。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
下面是**Alex_Wei**题解中的核心代码，涵盖了多项式乘法、取模和主逻辑。我们先看整体框架，再剖析关键片段。  
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码来自Alex_Wei的题解，是“动态规划+多项式取模”的典型实现，逻辑清晰、效率高。  
* **完整核心代码**：  
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int N = 4e3 + 5;
  int n, mx, L;
  double w, a[N], f[N], g[N], p[N], q[N];

  void mul(double *f, double *g) { // 计算 f * g mod A
    static double h[N];
    memset(h, 0, sizeof(h));
    for (int i = 0; i < mx; i++)
      for (int j = 0; j < mx; j++)
        h[i + j] += f[i] * g[j]; // 多项式乘法
    for (int i = mx * 2 - 2; i >= mx; i--) // 处理高次项，取模A
      for (int j = 1; j <= mx; j++)
        h[i - j] += h[i] * a[j]; // 用A的关系（x^m = sum(a[j]x^{m-j})）化简
    for (int i = 0; i < mx; i++) f[i] = h[i]; // 更新f为取模后的结果
  }

  int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> L, w = 1.0 / n;
    for (int i = 1, v; i <= n; i++) {
      cin >> v, mx = max(mx, v), a[v] += w; // a[v]是选择容器v的概率
    }

    f[0] = 1, g[1] = 1; // 初始化：f = x^0 = 1，g = x^1
    while (L) { // 倍增法计算x^L mod A
      if (L & 1) mul(f, g); // 如果L是奇数，f = f * g mod A
      mul(g, g), L >>= 1; // g = g * g mod A，L除以2
    }
    reverse(f, f + mx); // 翻转系数，得到f[C][i]（C = L - mx）

    // 计算p[i]：先手装C+i+1时，后手超过且不溢出的概率
    memcpy(g, f, sizeof(f));
    p[0] = 1;
    for (int i = 0; i < mx; i++) {
      if (i) p[i] = p[i - 1];
      for (int j = 1; j <= mx; j++) {
        if (i + j >= mx) p[i] -= g[i] * a[j]; // 溢出，减去该概率
        else g[i + j] += g[i] * a[j]; // 未溢出，累加到g[i+j]
      }
    }

    // 计算q[i]：先手装C+i+1时的胜率（max(停止的胜率, 继续的胜率)）
    double ans = 0;
    for (int i = mx - 1; ~i; i--) {
      for (int j = 1; i + j < mx; j++) q[i] += q[i + j] * a[j]; // 继续的胜率（从q[i+j]转移）
      q[i] = max(q[i], 1 - p[i]); // 停止的胜率是1 - p[i]（后手不超过的概率）
      ans += f[i] * q[i]; // 累加所有情况的概率
    }
    printf("%.12lf\n", ans);
    return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：读取`n`（容器数量）、`L`（油桶容积），计算每个容器的选择概率`a[v]`；  
  2. **多项式初始化**：`f`初始为`1`（`x^0`），`g`初始为`x^1`；  
  3. **倍增法计算`x^L mod A`**：通过循环分解`L`的二进制，每次计算`f`和`g`的乘积（取模`A`），快速得到`x^L mod A`的系数；  
  4. **计算`p`数组**：`p[i]`表示先手装`C+i+1`时，后手超过且不溢出的概率；  
  5. **计算`q`数组**：`q[i]`表示先手装`C+i+1`时的胜率（选择停止或继续），最终累加所有情况的概率得到答案。  

---

<code_intro_selected>  
下面我们剖析**mul函数**（多项式乘法与取模）和**倍增法循环**（快速计算`x^L mod A`）这两个核心片段。  
</code_intro_selected>

**核心片段1：mul函数（多项式乘法与取模）**  
* **亮点**：巧妙处理了多项式乘法与取模，将高次项转化为低次项，避免了指数爆炸。  
* **核心代码片段**：  
  ```cpp
  void mul(double *f, double *g) {
    static double h[N];
    memset(h, 0, sizeof(h));
    for (int i = 0; i < mx; i++)
      for (int j = 0; j < mx; j++)
        h[i + j] += f[i] * g[j]; // 第一步：多项式乘法，计算f*g的所有项
    for (int i = mx * 2 - 2; i >= mx; i--) // 第二步：处理高次项（i >= mx）
      for (int j = 1; j <= mx; j++)
        h[i - j] += h[i] * a[j]; // 用A的关系（x^m = sum(a[j]x^{m-j})）化简
    for (int i = 0; i < mx; i++) f[i] = h[i]; // 更新f为取模后的结果
  }
  ```  
* **代码解读**：  
  - 第一步：多项式乘法：`f`和`g`是两个多项式（次数都小于`mx`），它们的乘积`h`的次数小于`2mx`；  
  - 第二步：多项式取模：由于`A = x^mx - sum(a[j]x^{mx-j})`，所以`x^mx = sum(a[j]x^{mx-j})`。对于高次项`x^i`（`i >= mx`），可以用`x^{i - mx} * sum(a[j]x^{mx-j})`来代替，即`h[i]`乘以`a[j]`，加到`h[i - j]`上；  
  - 第三步：更新`f`：取模后的多项式次数小于`mx`，所以只保留`h`的前`mx`项。  
* 💡 **学习笔记**：多项式取模的核心是“用低次项表示高次项”，通过构造多项式`A`，将高次项的系数转移到低次项。  

**核心片段2：倍增法循环（快速计算`x^L mod A`）**  
* **亮点**：用倍增法将`O(L)`的时间复杂度优化到`O(logL)`，解决了`L`极大的问题。  
* **核心代码片段**：  
  ```cpp
  f[0] = 1, g[1] = 1; // f = x^0 = 1，g = x^1
  while (L) {
    if (L & 1) mul(f, g); // 如果L是奇数，f = f * g mod A（即x^{当前指数} * x^g的指数）
    mul(g, g), L >>= 1; // g = g * g mod A（即x^{2*当前指数}），L除以2
  }
  ```  
* **代码解读**：  
  - 初始化：`f`表示当前的结果（初始为`x^0`），`g`表示`x^1`；  
  - 循环分解`L`的二进制：比如`L=5`（二进制`101`），循环执行3次：  
    1. `L=5`（奇数）：`f = f * g = x^0 * x^1 = x^1`；`g = g * g = x^2`；`L=2`；  
    2. `L=2`（偶数）：不更新`f`；`g = g * g = x^4`；`L=1`；  
    3. `L=1`（奇数）：`f = f * g = x^1 * x^4 = x^5`；`g = g * g = x^8`；`L=0`；  
  - 最终`f`中的系数就是`x^L mod A`的结果（即`f[0]`是`x^L`的系数，`f[1]`是`x^{L-1}`的系数，依此类推）。  
* 💡 **学习笔记**：倍增法的核心是“将指数分解为二进制”，每次计算`x^{2^k}`，然后将这些项相乘得到`x^L`。  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>  
为了更直观地理解**多项式取模+倍增法**的过程，我设计了一个**8位像素风格**的动画，结合复古游戏元素，让你“看”到算法的每一步！  
</visualization_intro>

### **动画演示主题**：像素多项式“跳格子”游戏  
**设计思路**：  
- 用**像素块**表示多项式的系数（比如`f`数组的元素），颜色深浅表示概率大小（越深概率越大）；  
- 用**复古游戏音效**（如“叮”“嗒”）强化操作记忆；  
- 控制面板提供**单步/自动播放**，让你可以慢动作观察每一步的变化。  

### **动画帧步骤与交互关键点**  
1. **场景初始化**：  
   - 屏幕左侧显示**多项式系数面板**（用像素块表示`f`和`g`的系数，比如`f[0]`是红色，`f[1]`是蓝色，依此类推）；  
   - 屏幕右侧显示**控制面板**（包含“开始/暂停”“单步”“重置”按钮，以及速度滑块）；  
   - 背景播放**8位风格的轻音乐**（如《超级马里奥》的背景音乐）。  

2. **多项式初始化**：  
   - `f`数组的`f[0]`像素块变为最深的红色（表示概率`1`），其他像素块为白色（表示概率`0`）；  
   - `g`数组的`g[1]`像素块变为最深的蓝色（表示`x^1`），其他像素块为白色。  

3. **倍增法循环（计算`x^L mod A`）**：  
   - **步骤1（L为奇数）**：播放“叮”的声音，`f`和`g`的像素块进行“叠加”（表示多项式乘法），然后高次项的像素块“转移”到低次项（表示取模）；  
   - **步骤2（L为偶数）**：播放“嗒”的声音，`g`的像素块进行“平方”（表示`g = g * g`），然后高次项的像素块“转移”到低次项；  
   - **进度提示**：屏幕顶部显示当前`L`的二进制（如`L=5`显示为`101`），以及已处理的位数。  

4. **结果展示**：  
   - 当`L`变为`0`时，播放“胜利”音效（如《魂斗罗》的通关音乐），`f`数组的像素块颜色固定，表示`x^L mod A`的结果；  
   - 屏幕底部显示**结果说明**（如“`f[0]`表示`x^L`的系数，`f[1]`表示`x^{L-1}`的系数”）。  

### **游戏化元素**  
- **关卡设计**：将倍增法的每一步（如处理`L`的二进制位）设为“小关卡”，完成关卡后显示“过关”动画（如像素星星闪烁）；  
- **积分系统**：每完成一个关卡获得10分，连续完成3个关卡获得“连击奖励”（额外20分），激励你继续学习；  
- **AI演示模式**：点击“AI自动演示”按钮，算法会自动执行，像“贪吃蛇AI”一样展示每一步的变化，你可以观察整个过程。  

<visualization_conclusion>  
通过这个动画，你可以清晰地看到**多项式乘法与取模**的过程，以及**倍增法**如何快速计算大指数。复古游戏元素让学习更有趣，音效和像素块的变化让你更容易记住关键步骤！  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
掌握了“动态规划+多项式取模”的思路后，你可以尝试以下问题，巩固所学知识点：  
</similar_problems_intro>

### **通用思路/技巧迁移**  
- **线性递推问题**：比如“快速计算斐波那契数列第1e9项”（用多项式取模+倍增法）；  
- **概率DP问题**：比如“计算游戏中获胜的概率”（用动态规划定义状态，线性递推转移）；  
- **大指数问题**：比如“计算`a^b mod m`（`b`很大）”（用快速幂，类似倍增法）。  

### **练习推荐 (洛谷)**  
1. **洛谷 P1020 导弹拦截**  
   - 🗣️ **推荐理由**：虽然不是概率问题，但需要用动态规划定义状态（最长不下降子序列），锻炼状态定义能力。  
2. **洛谷 P3808 后缀自动机**  
   - 🗣️ **推荐理由**：涉及多项式处理（后缀自动机的构造），锻炼多项式思维。  
3. **洛谷 P4726 多项式指数函数**  
   - 🗣️ **推荐理由**：直接考察多项式取模，是本题的进阶练习，帮助你巩固多项式处理技巧。  
4. **洛谷 P1850 换教室**  
   - 🗣️ **推荐理由**：概率DP问题，需要计算期望（类似本题的概率计算），锻炼动态规划与概率结合的能力。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>  
Alex_Wei在题解中提到“套路题，但是学到很多”，这说明**即使是“套路题”，也能从中学到新的技巧**（比如多项式取模的应用）。  
</insights_intro>

> **参考经验 (来自Alex_Wei)**：“我在解决这个问题时，最初对`f[i][j]`的定义不太明确，后来通过反复推导，才确定了‘首次超过`i`’的约束条件。这让我意识到，状态定义是动态规划的核心，必须精确。”  
> **点评**：这位作者的经验很典型。在动态规划问题中，状态定义的准确性直接决定了后续逻辑的正确性。如果你在定义状态时遇到困难，可以尝试**从小例子入手**（比如样例输入），推导状态之间的关系，再总结出通用的定义。  


## 结语  
本次关于“公平合作”的分析就到这里。希望这份指南能帮助你理解**动态规划+多项式取模**的核心思路，掌握解决大指数问题的技巧。记住：**编程能力的提升在于持续学习和实践**，下次遇到类似问题时，不妨尝试用今天学到的方法解决！💪  

---  
**Kay的提示**：如果对多项式取模或倍增法还有疑问，可以尝试用小例子（比如`L=4`，`mx=2`）手动模拟代码的执行过程，相信你会有更深刻的理解！

---
处理用时：219.49秒
# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

::cute-table{tuack}

| 测试点编号   | $n \leq$  | 特殊性质           |
| :----------: | :-------: | :----------------: |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | ^ |
| $5 \sim 6$   | $10$      | 无                   |
| $7 \sim 8$   | $20$      | ^ |
| $9 \sim 10$  | $30$      | ^ |
| $11 \sim 12$ | $50$      | ^ |
| $13 \sim 14$ | $100$     | ^ |
| $15$         | $200$     | ^ |
| $16$         | $300$     | ^ |
| $17$         | $500$     | ^ |
| $18$         | $1\,000$  | ^ |
| $19$         | $2\,000$  | ^ |
| $20$         | $30\,000$ | ^ |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果


### 题目分析
本题要求计算字符串中所有子串的优秀拆分（AABB形式）的总个数。核心思路是将问题转化为计算以每个位置结尾和开头的AA型子串数量，并通过乘法原理得到最终答案。

#### 核心算法：后缀数组+调和级数枚举
1. **问题转化**：
   - 设 `f[i]` 表示以位置 `i` 结尾的AA型子串个数
   - 设 `g[i]` 表示以位置 `i` 开头的AA型子串个数
   - 答案为：$\sum_{i=1}^{n-1} f[i] \times g[i+1]$

2. **AA型子串计算**：
   - **枚举A的长度** `len`（1 到 n/2）
   - **设置关键点**：在位置 `len, 2*len, 3*len,...` 处设置关键点
   - **处理相邻关键点** `i` 和 `j = i+len`：
     - 计算 `LCP`（后缀 `i` 和 `j` 的最长公共前缀）
     - 计算 `LCS`（前缀 `i-1` 和 `j-1` 的最长公共后缀）
     - 若 `LCP + LCS >= len`，则存在AA型子串，数量为 `t = LCP + LCS - len + 1`
     - 更新差分数组：
       - 开头位置范围：`[i - LCS, i - LCS + t - 1]` → 更新 `g[]`
       - 结尾位置范围：`[i - LCS + 2*len - 1, i - LCS + 2*len - 1 + t - 1]` → 更新 `f[]`

3. **后缀数组优化**：
   - 构建原串和反串的后缀数组（SA）
   - 使用ST表实现O(1)的LCP查询
   - 反串的LCP对应原串的LCS

#### 时间复杂度
- 后缀数组构建：$O(n \log n)$
- 调和级数枚举：$O(n \log n)$
- 总时间复杂度：$O(n \log n)$

### 代码实现
```cpp
#include <iostream>
#include <cstring>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 30005;
const int LOG_MAXN = 16;

int Log[MAXN];

void initLog() {
    Log[0] = -1;
    for (int i = 1; i < MAXN; i++) {
        Log[i] = Log[i >> 1] + 1;
    }
}

struct SA {
    char s[MAXN];
    int n, m;
    int sa[MAXN], rk[MAXN], tp[MAXN], c[MAXN];
    int ht[MAXN], st[MAXN][LOG_MAXN];

    void buildSA() {
        m = 128;
        for (int i = 0; i <= m; i++) c[i] = 0;
        for (int i = 1; i <= n; i++) c[rk[i] = s[i]]++;
        for (int i = 1; i <= m; i++) c[i] += c[i - 1];
        for (int i = n; i >= 1; i--) sa[c[rk[i]]--] = i;

        for (int k = 1, p = 0; p < n; k <<= 1, m = p) {
            p = 0;
            for (int i = n - k + 1; i <= n; i++) tp[++p] = i;
            for (int i = 1; i <= n; i++)
                if (sa[i] > k) tp[++p] = sa[i] - k;

            for (int i = 0; i <= m; i++) c[i] = 0;
            for (int i = 1; i <= n; i++) c[rk[tp[i]]]++;
            for (int i = 1; i <= m; i++) c[i] += c[i - 1];
            for (int i = n; i >= 1; i--) sa[c[rk[tp[i]]]--] = tp[i];

            swap(rk, tp);
            rk[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) {
                rk[sa[i]] = (tp[sa[i]] == tp[sa[i - 1]] && 
                             tp[sa[i] + k] == tp[sa[i - 1] + k]) ? p : ++p;
            }
        }
    }

    void getHeight() {
        int k = 0;
        for (int i = 1; i <= n; i++) {
            if (k) k--;
            int j = sa[rk[i] - 1];
            while (s[i + k] == s[j + k]) k++;
            ht[rk[i]] = k;
        }
    }

    void buildST() {
        for (int i = 1; i <= n; i++) st[i][0] = ht[i];
        for (int j = 1; j <= Log[n]; j++) {
            for (int i = 1; i + (1 << j) - 1 <= n; i++) {
                st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
            }
        }
    }

    int query(int i, int j) {
        if (i > n || j > n) return 0;
        if (i == j) return n - i + 1;
        int l = rk[i], r = rk[j];
        if (l > r) swap(l, r);
        l++;
        int k = Log[r - l + 1];
        return min(st[l][k], st[r - (1 << k) + 1][k]);
    }

    void init(char *str, int len) {
        n = len;
        for (int i = 1; i <= n; i++) s[i] = str[i];
        s[n + 1] = 0;
        buildSA();
        getHeight();
        buildST();
    }
};

int main() {
    initLog();
    int T;
    cin >> T;
    while (T--) {
        char s[MAXN];
        cin >> (s + 1);
        int n = strlen(s + 1);
        
        SA SA1, SA2;
        SA1.init(s, n);
        
        char t[MAXN];
        for (int i = 1; i <= n; i++) 
            t[i] = s[n - i + 1];
        SA2.init(t, n);

        vector<long long> da(n + 10, 0), db(n + 10, 0);

        for (int len = 1; len <= n / 2; len++) {
            for (int i = len; i + len <= n; i += len) {
                int j = i + len;
                int LCP = min(SA1.query(i, j), len);
                int LCS = 0;
                if (i > 1) {
                    LCS = min(SA2.query(n - i + 2, n - j + 2), len - 1);
                }
                if (LCP + LCS < len) continue;
                
                int t_val = LCP + LCS - len + 1;
                int l_begin = i - LCS;
                int r_begin = l_begin + t_val - 1;
                
                db[l_begin]++;
                if (r_begin + 1 <= n) db[r_begin + 1]--;
                
                int l_end = l_begin + 2 * len - 1;
                if (l_end <= n) {
                    da[l_end]++;
                    if (l_end + t_val <= n) {
                        da[l_end + t_val]--;
                    }
                }
            }
        }

        for (int i = 1; i <= n; i++) {
            if (i > 1) {
                db[i] += db[i - 1];
                da[i] += da[i - 1];
            }
        }

        long long ans = 0;
        for (int i = 1; i < n; i++) {
            ans += da[i] * db[i + 1];
        }
        cout << ans << endl;
    }
    return 0;
}
```

### 算法可视化
#### 像素动画演示：关键点扫描
1. **场景初始化**：
   - 8位像素风格网格（类似FC游戏）
   - 字符串显示为彩色像素块
   - 控制面板：单步/自动播放、速度调节

2. **关键点扫描过程**：
   - 枚举长度 `len` 时，关键点高亮显示
   - 相邻关键点 `i` 和 `j` 用不同颜色标记
   - 动态显示LCP/LCS计算：
     - LCP：绿色箭头从 `i` 和 `j` 向右延伸
     - LCS：蓝色箭头从 `i-1` 和 `j-1` 向左延伸
     - 匹配长度实时显示

3. **AA串标记**：
   - 当 `LCP+LCS >= len` 时：
     - 开头位置范围：红色高亮像素块
     - 结尾位置范围：绿色高亮像素块
   - 伴随音效：匹配成功（清脆音）、范围标记（电子音）

4. **结果展示**：
   - 最终 `f[]` 和 `g[]` 数组用柱状图显示
   - AABB拆分点（`f[i] * g[i+1]`）用闪光特效
   - 播放胜利音效并显示总答案

#### 交互设计
- **单步执行**：按空格键逐步观察
- **自动播放**：可调节速度滑块
- **数据对比**：并排显示不同 `len` 的结果
- **关卡积分**：每个 `len` 完成作为小关卡，积分增加

通过这种可视化方式，学习者可以直观理解调和级数枚举和LCP/LCS计算过程，增强算法理解深度。

---
处理用时：414.38秒
# 题目信息

# [HNOI2008] 玩具装箱

## 题目描述

P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。

P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。

为了方便整理，P 教授要求：

- 在一个一维容器中的玩具编号是连续的。

- 同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum\limits_{k=i}^{j}C_k$。

制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。

## 说明/提示

对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$。

## 样例 #1

### 输入

```
5 4
3
4
2
1
4```

### 输出

```
1```

# AI分析结果

要解决《玩具装箱》（[HNOI2008] TOY）问题，**动态规划（DP）+ 斜率优化**是核心思路，能将时间复杂度从暴力的$O(n^2)$优化到$O(n)$，适用于$n=5 \times 10^4$的规模。


### **一、问题分析**
#### 1. 题目大意
给定$n$个玩具，每个玩具压缩后的长度为$C_i$。将连续的玩具装入容器，容器长度为$j-i+1 + \sum_{k=i}^j C_k$（$i$到$j$的玩具），费用为$(\text{容器长度} - L)^2$。求最小总费用。

#### 2. 暴力DP思路
- **状态定义**：$f[i]$表示前$i$个玩具的最小费用。
- **转移方程**：  
  $f[i] = \min_{0 \leq j < i} \left\{ f[j] + \left( (sum[i] - sum[j]) + (i - j) - 1 - L \right)^2 \right\}$  
  其中，$sum[i]$是$C$的前缀和（$sum[i] = \sum_{k=1}^i C_k$），$(sum[i]-sum[j])$是$i$到$j+1$的玩具长度和，$(i-j)$是间隔数（每个间隔加1），减1是因为间隔数为$i-j-1$（比如$i=3,j=1$，间隔数是2），再减$L$是费用计算。

- **问题**：$O(n^2)$的时间复杂度无法通过$n=5 \times 10^4$的测试用例。


### **二、斜率优化推导**
#### 1. 变量替换简化方程
令$s[i] = sum[i] + i$（前缀和加索引，用于合并项），则：  
$sum[i] - sum[j] + i - j = s[i] - s[j]$  
转移方程简化为：  
$f[i] = \min_{0 \leq j < i} \left\{ f[j] + (s[i] - s[j] - 1 - L)^2 \right\}$  

#### 2. 展开方程并转化为线性形式
将平方项展开：  
$f[i] = f[j] + (s[i] - L - 1)^2 - 2 \cdot (s[i] - L - 1) \cdot s[j] + s[j]^2$  
整理为**线性函数形式**（$y = kx + b$）：  
$f[j] + s[j]^2 = 2 \cdot (s[i] - L - 1) \cdot s[j] + (f[i] - (s[i] - L - 1)^2)$  

- **变量对应**：  
  - $y = f[j] + s[j]^2$（关于$j$的函数）  
  - $k = 2 \cdot (s[i] - L - 1)$（斜率，随$i$单调递增）  
  - $x = s[j]$（横坐标，随$j$单调递增）  
  - $b = f[i] - (s[i] - L - 1)^2$（截距，需最小化）  

#### 3. 凸包优化思路
我们的目标是**最小化截距$b$**，即找到$j$使得点$(s[j], f[j] + s[j]^2)$在斜率为$k$的直线下的截距最小。  
由于$s[i]$单调递增（$C_i \geq 1$），斜率$k$也单调递增，因此最优$j$一定在**下凸包**（所有点构成的凸壳底部）上。


### **三、斜率优化实现**
#### 1. 维护下凸包
使用**单调队列**维护下凸包，队列中的点满足：  
- 相邻两点的斜率**单调递增**（保证凸性）。  
- 队首是当前最优$j$（斜率小于当前$k$时，队首更优）。

#### 2. 队列操作
- **队首弹出**：当队首两个点的斜率小于当前$k$时，弹出队首（后面的点更优）。  
- **计算$f[i]$**：用队首的$j$计算$f[i]$。  
- **队尾弹出**：当队尾两个点与新点$i$的斜率破坏凸性（即队尾前两点的斜率大于队尾与新点的斜率）时，弹出队尾。  
- **加入新点**：将$i$加入队尾。

#### 3. 代码实现（核心部分）
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
const int MAXN = 50005;

ll n, L;
ll sum[MAXN], s[MAXN], f[MAXN];
int q[MAXN], head = 0, tail = 0; // 单调队列

ll sq(ll x) { return x * x; }

// 计算两点(j1, j2)的斜率：(y2 - y1)/(x2 - x1)，其中y = f[j] + s[j]^2，x = s[j]
double slope(int j1, int j2) {
    ll y1 = f[j1] + sq(s[j1]);
    ll y2 = f[j2] + sq(s[j2]);
    ll x1 = s[j1], x2 = s[j2];
    if (x1 == x2) return y1 > y2 ? -1e18 : 1e18; // 避免除以零
    return (double)(y2 - y1) / (x2 - x1);
}

int main() {
    scanf("%lld%lld", &n, &L);
    L++; // 简化式子：将-1-L合并为-L（因为原式中的-1-L = -(L+1)）
    for (int i = 1; i <= n; i++) {
        ll c;
        scanf("%lld", &c);
        sum[i] = sum[i-1] + c;
        s[i] = sum[i] + i; // s[i] = sum[i] + i
    }

    f[0] = 0;
    q[tail++] = 0; // 初始队列加入j=0

    for (int i = 1; i <= n; i++) {
        // 弹出队首：当前斜率k=2*(s[i]-L)，若队首两点斜率小于k，则队首更优
        while (head + 1 < tail && slope(q[head], q[head+1]) < 2 * (s[i] - L)) {
            head++;
        }
        int j = q[head];
        f[i] = f[j] + sq(s[i] - s[j] - L); // 计算f[i]

        // 弹出队尾：维护下凸包，若队尾两点与i的斜率破坏凸性，则弹出队尾
        while (head + 1 < tail && slope(q[tail-2], q[tail-1]) > slope(q[tail-1], i)) {
            tail--;
        }
        q[tail++] = i; // 将i加入队尾
    }

    printf("%lld\n", f[n]);
    return 0;
}
```


### **四、关键细节说明**
1. **变量替换**：$s[i] = sum[i] + i$合并了$sum[i]$和$i$，简化了转移方程中的项。  
2. **斜率单调递增**：由于$C_i \geq 1$，$s[i]$单调递增，因此斜率$k=2*(s[i]-L)$也单调递增，保证了队首弹出的正确性。  
3. **凸包维护**：队尾弹出的条件是为了保持下凸包的凸性，确保新点加入后队列中的点仍构成下凸包。  
4. **数据类型**：使用`long long`避免整数溢出（$C_i$和$L$的值可能很大）。


### **五、总结**
《玩具装箱》问题的核心是**动态规划+斜率优化**，通过维护下凸包将转移复杂度从$O(n^2)$优化到$O(n)$。关键步骤包括：  
- 定义状态并写出转移方程；  
- 变量替换简化方程；  
- 转化为线性函数形式，识别斜率和截距；  
- 用单调队列维护下凸包，优化转移。  

这种方法适用于**具有决策单调性**和**斜率单调递增**的动态规划问题，是解决大规模DP问题的常用技巧。

---
处理用时：119.08秒
# 题目信息

# 「Stoi2031」蒲公英的约定（vol.1）

## 题目背景

> 一起长大的约定 那样清晰 拉过勾的我相信 说好要一起旅行 是你如今 唯一坚持的任性 ——《蒲公英的约定》

## 题目描述

清和如在玩游戏。她们有 $n$ 丛 **蒲公英**，每丛分别有 $s_i$ 朵。这些 **蒲公英** 有一个神奇的性质：有一个给定的常数 $\sigma \in (0,1)$，$x$ 朵 **蒲公英** 会分出 $\lfloor \sigma x \rfloor$ 朵为一组，剩下 $x-\lfloor \sigma x \rfloor$ 朵继续分组，直到分出的组没有 **蒲公英** 即 $\lfloor \sigma x \rfloor=0$ 为止。她们称这种现象为 **任性**。现在她们的每丛 **蒲公英** 都有 **任性** 的现象。她们的游戏规则如下：从清开始，两人轮流进行 **旅行**。一次 **旅行** 为选择一丛 **蒲公英** 并吹散这一丛的第一组中的若干朵 **蒲公英**，至少要吹一朵，至多吹的朵数为第一组的朵数，即不能吹散除第一组外的 **蒲公英**。当第一组为空时，其下一组成为第一组。若这一丛只剩下一组 **蒲公英**，这一丛不能再被选定。每丛 **蒲公英** 都不能被选定时，游戏结束，当前轮到的人落败。她们想知道如果清第一次 **旅行** 时等概率选择其中一丛可吹散的 **蒲公英** 再等概率选择吹散的朵数后两人都按最优策略操作，那么清的胜率 $x \bmod 20190816170251$ 的值将会是多少。

与 vol.2 的区别是，**蒲公英** 在被吹散一部分后 **不会** 重新分组。

## 说明/提示

#### 简述版题意：

有 $n$ 丛 **蒲公英**，第 $i$ 丛有 $s_i$ 朵。给定实数 $\sigma$，每丛会分为若干组，第 $j$ 组有 $t_j$ 朵，且满足 $t_j=\left\lfloor \sigma\left(s_i - \sum\limits_{k=1}^{j-1}t_k\right) \right\rfloor$，当 $t_j=0$ 时不再分组。两人轮流操作，每次操作可以选择一丛 **蒲公英**，并选择一个整数 $c \in t_j$，从这丛 **蒲公英** 中吹散 $c$ 朵，将 $t_j$ 变为 $t_j-c$，其中 $j$ 为操作之前这丛 **蒲公英** 中满足 $t_j \neq 0$ 的最小正整数。必须至少吹一朵，不能操作者败。求先手第一步等概率选择任意一丛可操作的 **蒲公英** 再等概率选择吹散的朵数后两人都采取最优策略时先手的胜率 $x \bmod{20190816170251}$ 的值。

#### 样例解释：

对于样例 $1$，清无法操作，胜率为 $0$。

对于样例 $2$，初始局面为 $\{0;1\},\{2,1,1,1,0;2\},\{1,0;2\}$，清可以选择第 $2$ 丛并在两种操作中选择吹散 $2$ 朵变成 $\{0;1\},\{1,1,1,0;2\},\{1,0;2\}$，选择第 $3$ 丛没有可取胜的策略，且第 $1$ 丛不能选择，总胜率为 $\dfrac{\frac{1}{2}+0}{2}=\dfrac{1}{4}$。

#### 数据范围：

**本题采用捆绑测试，各个 Subtask 的分数与限制如下。**

| Subtask No. | $n \le$ | $s_i \le$ | $\sigma$ 限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{2}+1}{3}$ | $10$ |
| $2$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{3}+1}{5}$ | $10$ |
| $3$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{5}-1}{2}$ | $10$ |
| $4$ | $100$ | $1$ | 无 | $3$ |
| $5$ | $100$ | $100$ | $\sigma=\dfrac{1}{2}$ | $7$ |
| $6$ | $100$ | $10^6$ | 无 | $13$ |
| $7$ | $3 \times 10^5$ | $10^{10}$ | $\sigma \ge \dfrac{1}{2}$ | $47$ |

对于 $100\%$ 的数据，$1 \le n \le 3 \times 10^5,1 \le s_i \le 10^{10},1 \le p<q \le 10^9$。

**本题读入量较大，可以选择使用比赛描述中的快速读入模板以加快读入速度。**

## 样例 #1

### 输入

```
4 3
1 1 1
1 6
```

### 输出

```
0
```

## 样例 #2

### 输入

```
6 3
1 7 3
1 3
```

### 输出

```
5047704042563
```

# AI分析结果


### 💡 Kay的C++算法解析：「蒲公英的约定」 深入学习指南 💡

#### **题目解读与核心算法识别**
✨ **本题主要考察**：`博弈论（SG函数）`  
🗣️ **初步分析**：  
> 解决本题的关键是理解**SG函数**（Sprague-Grundy函数），这就像下棋时的"必胜策略计算器"。每个蒲公英丛的分组状态对应一个棋局位置，SG值表示该位置的胜负潜力。  
**核心难点**在于高效计算每个蒲公英丛的SG值——需分析分组规则（$\sigma$ 的作用）和游戏操作（吹散蒲公英）。  
**可视化设计思路**：用像素方块表示蒲公英组，动态展示吹散操作和SG值变化（如绿色方块表示可操作组，红色闪烁提示关键分组变化），配合8-bit音效增强操作反馈。

---

#### **精选优质题解参考**
**题解（作者：VinstaG173）**  
* **点评**：  
  思路清晰推导SG函数递推关系：$SG(x) = \lfloor\sigma x\rfloor - \delta$（$\delta$为分组奇偶修正）。  
  代码亮点：  
  - **变量设计**：`_tau`/`_sigma`封装分组计算，`SG[]`存储状态值  
  - **优化技巧**：位运算`((x-_tau(t)-1)/t)&1`避免分支判断  
  - **边界处理**：`_sigma(s[i])==0`跳过无效丛  
  实践价值高，可直接用于竞赛（时间复杂度$O(n)$）。

---

#### **核心难点辨析与解题策略**
1. **难点1：分组规则与SG值关联**  
   * **分析**：需证明 $t_1 = \lfloor\sigma x\rfloor$ 与后继状态的关系。题解通过数学归纳法得出：当 $t_1 = t_2$ 且奇偶性匹配时 $SG(x)=t_1-1$，否则 $SG(x)=t_1$。  
   💡 **学习笔记**：SG值取决于**首组大小**和**分组链的奇偶性**。

2. **难点2：大数运算优化**  
   * **分析**：$s_i \leq 10^{10}$ 需避免浮点误差。题解用`LL __int128`和整数化处理：$\lfloor\sigma x\rfloor = (x \times p) // q$。  
   💡 **学习笔记**：博弈问题中，数学转化比暴力模拟更高效。

3. **难点3：胜率动态计算**  
   * **分析**：当 $\text{SG}(x) \oplus \text{全局SG} \leq \lfloor\sigma x\rfloor$ 时更新胜率。题解用模逆元`_inv`处理分数取模：$ans = \sum \frac{1}{n \cdot t_1} \mod 20190816170251$。  
   💡 **学习笔记**：异或性质 $\oplus$ 是组合博弈的核心运算符。

**✨ 解题技巧总结**  
- **技巧1 状态压缩**：将分组序列压缩为单个SG值  
- **技巧2 数学优化**：用整数运算代替浮点数  
- **技巧3 模逆元应用**：$a^{-1} \mod m$ 处理分数取模

---

#### **C++核心代码实现赏析**
**通用核心实现参考**  
```cpp
#include<cstdio>
#define LL __int128
const LL MOD = 20190816170251;

// 计算分组边界
inline ll sigma(ll x) { 
    return (x * p) / q; // 整数化处理σ
}

// 核心SG函数
inline ll sg(ll x) {
    ll t = sigma(x);
    if(!t) return 0;
    return t - (((x - (x*q-p)/t -1)/t) & 1); // 奇偶性修正
}

int main() {
    LL ans = 0;
    for(int i=1; i<=n; ++i) {
        ll t = sigma(s[i]);
        if(t == 0) continue;
        if((SG[i] ^ totalSG) <= t) // 可获胜操作
            ans = (ans + inv(n * t)) % MOD; // 累加胜率
    }
}
```
**代码解读概要**：  
1. `sigma(x)` 计算首组蒲公英数  
2. `sg(x)` 通过位运算快速确定SG值  
3. 主循环中动态更新全局胜率

---

### 算法可视化：像素动画演示  
![](https://via.placeholder.com/400x200?text=像素动画示意图)  
* **主题**：8-bit风格《蒲公英保卫战》  
* **核心演示**：  
  1. **蒲公英分组**：像素方块堆叠表示$t_1,t_2...$组（颜色深浅表数量）  
  2. **吹散操作**：点击方块触发"吹散"动画，伴随碎裂音效  
  3. **SG值显示**：顶部LED屏动态刷新当前SG值  
* **交互设计**：  
  - `A键`：单步执行吹散  
  - `B键`：自动演示（速度可调）  
  - 胜利时播放FC胜利音乐  
* **设计意义**：视觉化抽象的分组规则和SG值关联，增强策略理解

---

#### **拓展练习与相似问题思考**
1. **洛谷 P2197**：基础Nim游戏（SG函数入门）  
2. **洛谷 P2148**：阶梯Nim变形（分组策略进阶）  
3. **洛谷 P4136**：取石子问题（大数SG值优化）

> 掌握SG函数后，可解决**任何公平组合博弈问题**——从取石子到棋盘游戏，本质都是状态图的SG值计算！

---

<conclusion>  
通过本指南，我们揭开了「蒲公英的约定」背后的博弈奥秘。记住：SG函数是博弈论的"万能钥匙"，而数学优化是处理大数据的核心武器。下次遇到类似问题，不妨先问自己：**如何将规则转化为状态图？** 实践出真知，动手编码吧！💻✨  
</conclusion>

---
处理用时：63.05秒
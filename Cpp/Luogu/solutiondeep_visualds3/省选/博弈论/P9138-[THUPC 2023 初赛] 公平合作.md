# 题目信息

# [THUPC 2023 初赛] 公平合作

## 题目描述

在大地的尽头，一座灰白的灯塔矗立在漫长的海岸线上。这一片海域海流复杂、礁石嶙峋，却又是不少航线的必经之路。若没有如此高耸而明亮的灯塔为过路的船只照亮航路，或许会有更多不幸的生命葬身海底。为了看管好这一座海上明灯，一批训练有素的守望人轮流值守于此。日复一日的工作枯燥乏味却又不能有丝毫闪失，紧绷的神经直到下一班守望人到来才得以放松。

在电力普及之前，灯塔通常使用煤油灯为过往的水手指引前行的方向。每次为这座灯塔添加燃油时，需要两位守望人各自搬运一个容积为 $L$ 的油桶；而每次轮到 Y 和 S 所在的班组照料这座灯塔时，总是由 Y 和 S 负责为灯塔加油。将煤油搬运至灯室时，如果不装满油桶，对灯塔的正常运转也没有太大影响，无非是需要多来回搬运几趟。但是，如果两位守望人都想着偷懒，问题恐怕就不只是多几趟那么简单。Y 和 S 想到了一个好办法：互相为对方的油桶装油。

灯塔里有 $N$ 个用于将储存的煤油转移到油桶中的容器，其中第 $i$ 个容器的容积为 $a_i$。Y 和 S 先想办法决定由谁先装油。两人先后装油；轮到其中一位守望人装油时，这位守望人每次从所有容器中等概率地随机选出一个容器，将其装满油，并全部倒入对方的油桶中。两位守望人都可以在操作任意多次（可以是 0 次）后结束装油，但后手必须等先手结束后才能开始装油。Y 和 S 先后装完煤油后，两人会比一下谁把对方的油桶装得更满，再各自把自己的油桶搬运到灯室。但是，如果有谁某次选出一个容器后，把对方的油桶装满了，但容器里还有没倒出的煤油，那么这位倒霉的守望人就必须把两个油桶都独自搬到灯室——这也算是为单调的生活平添了几分乐趣。显然，如果先手某次随机选中的容器会使得油桶溢出，那么后手可以往先手的油桶里面装任意量的煤油，然后幸灾乐祸；因此我们约定：当先手溢出时，必定由先手搬两个油桶。

现在只剩下了一个问题：当 Y 和 S 都采取最优策略，使得对方搬的煤油尽可能地比自己多的时候，先手搬的煤油不多于后手的概率是多大？

## 说明/提示

#### 样例解释 1

可以证明，此时先手的策略一定是装满对方的油桶，且装满时必胜。经过若干次随机抽取后，能恰好将对方的油桶装满的概率为：

$$
\left(\frac{1}{2}\right)^2 + \binom{3}{1}\left(\frac{1}{2}\right)^3 + \left(\frac{1}{2}\right)^4 = \frac{11}{16}=0.6875
$$

#### 数据范围

对于 $100\%$ 的数据，保证 $1\le N\le 2\times 10^3$，$1\le L\le 10^9$，$1\le a_i\le 2\times 10^3$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 4
1 2```

### 输出

```
0.687500000000000000
```

## 样例 #2

### 输入

```
见附件中的 2.in```

### 输出

```
见附件中的 2.out```

## 样例 #3

### 输入

```
见附件中的 3.in```

### 输出

```
见附件中的 3.out```

# AI分析结果


### 💡 Kay的C++算法解析：[THUPC 2023 初赛] 公平合作 深入学习指南 💡

---

#### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：`概率动态规划` + `多项式取模优化`  
🗣️ **初步分析**：  
> 解决这道题的关键在于**概率建模与最优策略决策**。就像两位玩家轮流往对方桶里倒水，既要避免溢出（桶满则输），又要让对方的桶比自己满。  
> - **核心思路**：通过动态规划计算先手获胜概率，但直接计算会超时（$L$ 达 $10^9$）。巧妙之处在于发现当油量 $x < L - \max(a_i)$ 时先手必输，只需计算 $[L-\max a_i, L]$ 区间的状态。  
> - **优化核心**：用**多项式取模**将状态转移压缩为矩阵幂运算，复杂度从 $O(L)$ 降至 $O(m^2 \log L)$（$m=\max a_i$）。  
> - **可视化设计**：像素动画可设计为双桶水位上升过程，高亮当前操作容器，溢出时桶闪烁红色并播放失败音效。自动演示模式会逐步展示多项式系数的转移过程（如像素网格中的系数滑动）。

---

#### **2. 精选优质题解参考**  
**题解一（Alex_Wei）**  
* **点评**：  
  - **思路清晰性**：将问题分解为概率计算 $f_{i,j}$（先手倒 $i$ 时后手首次超量的概率）和最优策略 $q_i$（先手选择停或继续），逻辑严谨。  
  - **代码规范性**：变量名 `f, g, p, q` 作用明确，多项式乘法和取模封装为函数 `mul`，模块化清晰。  
  - **算法有效性**：多项式取模优化将复杂度优化到 $O(m^2 \log L)$，显著优于暴力 $O(L)$。  
  - **实践价值**：完整处理边界（如 `i+j >= mx` 跳过溢出），可直接用于竞赛。  
  **亮点**：**翻转多项式系数**匹配递推方向，避免冗余计算。

---

#### **3. 核心难点辨析与解题策略**  
1. **难点1：状态压缩与区间缩减**  
   * **分析**：直接计算 $[0, L]$ 状态不可行。发现当 $x < L - \max a_i$ 时后手必超 $x$（不溢出），只需计算 $[L - \max a_i, L]$ 的 $O(m)$ 个状态。  
   * 💡 **学习笔记**：**缩小有效状态范围**是优化大规模 DP 的关键。  

2. **难点2：多项式取模优化递推**  
   * **分析**：状态转移 $f_{i,j} = \frac{1}{n} \sum_k f_{i-1, j-a_k}$ 是线性递推。通过构造多项式 $A = x^m - \frac{1}{n} \sum x^{m-a_k}$，用 $x^L \bmod A$ 计算边界状态。  
   * 💡 **学习笔记**：**常系数线性递推**可转化为多项式运算，倍增幂加速。  

3. **难点3：最优策略的博弈决策**  
   * **分析**：先手每一步选择停（胜率 $1-p_i$）或继续倒油（转移至 $q_{i+a_j}$），需取最大值：$q_i = \max(1-p_i, \frac{1}{n} \sum_j q_{i+a_j})$。  
   * 💡 **学习笔记**：**博弈 DP 需同时考虑当前操作与对手反制**。  

### ✨ 解题技巧总结  
- **技巧1：问题分解**：将概率计算（$p_i$）和策略选择（$q_i$）分离，降低思维复杂度。  
- **技巧2：多项式压缩**：用多项式系数表示 DP 状态，通过取模避免高维数组。  
- **技巧3：边界剪枝**：利用单调性（如 $x < L - m$ 必输）减少无效计算。  

---

#### **4. C++核心代码实现赏析**  
**通用核心实现**（基于 Alex_Wei 解法优化）：  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4000;
int n, mx, L;
double w, a[N], f[N], g[N], p[N], q[N];

void mul(double *f, double *g) { // 多项式乘法取模
  double h[N] = {};
  for (int i = 0; i < mx; i++)
    for (int j = 0; j < mx; j++)
      h[i + j] += f[i] * g[j];
  for (int i = mx * 2 - 2; i >= mx; i--)
    for (int j = 1; j <= mx; j++)
      h[i - j] += h[i] * a[j]; // 模 A 操作
  memcpy(f, h, sizeof(h));
}

int main() {
  cin >> n >> L; w = 1.0 / n;
  for (int i = 1, v; i <= n; i++) {
    cin >> v; mx = max(mx, v);
    a[v] += w; // 容器概率分布
  }

  // 多项式幂: 计算 x^L mod A
  f[0] = 1; g[1] = 1;
  for (int t = L; t; t >>= 1, mul(g, g))
    if (t & 1) mul(f, g);
  reverse(f, f + mx); // 翻转系数匹配递推

  // 计算 p[i]: 先手倒 i 时后手获胜概率
  memcpy(g, f, sizeof(f));
  for (int i = 0; i < mx; i++) {
    if (i) p[i] = p[i - 1];
    for (int j = 1; j <= mx; j++)
      if (i + j >= mx) p[i] -= g[i] * a[j]; // 剪枝溢出
      else g[i + j] += g[i] * a[j]; // 状态转移
  }

  // 计算 q[i]: 先手最优策略胜率
  double ans = 0;
  for (int i = mx - 1; i >= 0; i--) {
    for (int j = 1; j <= mx; j++)
      if (i + j < mx) q[i] += q[i + j] * a[j];
    q[i] = max(q[i], 1 - p[i]); // 关键决策点
    ans += f[i] * q[i]; // 整合答案
  }
  printf("%.12lf\n", ans);
}
```

**代码解读概要**：  
> 1. **多项式初始化**：`a[v]` 存储容器体积概率，`f` 初始为 $1$（$x^0$），`g` 为 $x^1$。  
> 2. **快速幂计算**：通过 `mul` 函数实现 $x^L \bmod A$，翻转系数后 `f[i]` 表示边界状态概率。  
> 3. **概率递推**：`g` 数组迭代计算 $p_i$（后手胜率），`q[i]` 根据停或继续的决策取最大值。  

**题解一片段赏析**：  
```cpp
void mul(double *f, double *g) {
  double h[N] = {};
  for (int i = 0; i < mx; i++)
    for (int j = 0; j < mx; j++)
      h[i + j] += f[i] * g[j];
  for (int i = mx * 2 - 2; i >= mx; i--)
    for (int j = 1; j <= mx; j++)
      h[i - j] += h[i] * a[j];
  memcpy(f, h, sizeof(h));
}
```
* **亮点**：**双重循环实现多项式卷积**，再通过取模压缩次数（`i - j` 循环）。  
* **学习笔记**：多项式取模本质是**将高次项按定义式 $A(x)=0$ 降次**。  

---

#### **5. 算法可视化：像素动画演示**  
* **主题**：`像素油桶对决`（8-bit 风格双桶水位模拟）  
* **设计思路**：  
  - **网格场景**：左侧先手桶，右侧后手桶，底部容器队列（不同颜色方块代表 $a_i$）。  
  - **动画流程**：  
    1. **初始化**：桶为空，容器队列闪烁，播放芯片音乐 BGM。  
    2. **先手操作**：随机高亮容器，油从容器流向对方桶（像素水流动画），桶水位上升。  
    3. **策略决策点**：若先手停止，弹出菜单（继续/停止）；选停止则后手开始操作。  
    4. **溢出效果**：桶满时闪烁红光，播放低沉错误音效；获胜时播放胜利音效。  
  - **自动演示**：AI 模式展示最优策略路径（如先手在 $q_i > 1-p_i$ 时继续）。  
* **交互控制**：  
  - **速度滑块**：调节倒油速度。  
  - **单步执行**：逐步观察多项式系数转移（如 `f[]` 数组值显示在网格上方）。  

---

#### **6. 拓展练习**  
1. **洛谷 P4723**：常系数齐次线性递推模板题  
   → *推荐理由*：巩固多项式取模优化递推技巧。  
2. **洛谷 P4548**：概率 DP + 期望计算  
   → *推荐理由*：强化概率 DP 建模能力。  
3. **洛谷 P1654**：博弈论 + 最优策略 DP  
   → *推荐理由*：深入理解带决策点的概率 DP。  

---

> 掌握概率 DP 与多项式优化的结合，是解决此类问题的关键。尝试修改容器分布 $a_i$，观察策略变化！ 🚀

---
处理用时：121.93秒
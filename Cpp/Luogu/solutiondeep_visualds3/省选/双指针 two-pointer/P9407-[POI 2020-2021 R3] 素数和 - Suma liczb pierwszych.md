# 题目信息

# [POI 2020/2021 R3] 素数和 / Suma liczb pierwszych

## 题目背景

译自 [XXVIII Olimpiada Informatyczna - III etap](https://sio2.mimuw.edu.pl/c/oi28-3/dashboard/) [Suma liczb pierwszych](https://szkopul.edu.pl/problemset/problem/8brtPux-IyytS6rOoOR1cJTL/statement/)。

d2t3。

## 题目描述

给你一个数字 $n$，求 $l,r$，使 $[l,r]$ 区间内的所有质数之和等于 $n$。

如果有多解，任意一组均可；无解输出 `NIE`。

## 说明/提示

对于所有数据，$1\leq n\leq 10^{11}$。

| 子任务编号 | 附加限制 | 分数 |
| :----------: | :----------: | :----------: |
| 1 | $n\leq 10000$ | 15 |
| 2 | $n\leq 10^8$ | 20 |
| 3 | $n\leq 2\times 10^9$ | 40 |
| 4 |  | 25 |

## 样例 #1

### 输入

```
15
```

### 输出

```
3 7
```

## 样例 #2

### 输入

```
9992
```

### 输出

```
4993 4999
```

## 样例 #3

### 输入

```
100000000
```

### 输出

```
NIE
```

## 样例 #4

### 输入

```
1000000007
```

### 输出

```
1000000007 1000000007
```

## 样例 #5

### 输入

```
99999999996
```

### 输出

```
295693 1693067
```

# AI分析结果

# 💡 Kay的C++算法解析：素数和 深入学习指南 💡

<introduction>
今天我们来一起分析POI的经典题目“素数和”——给定一个数n，找一个区间[l,r]，让里面所有质数的和刚好等于n。这道题的难点在于n可以大到10¹¹，直接枚举所有质数根本行不通！不过别担心，我们会用“分段找宝藏”的思路，结合质数筛、双指针和区间筛的技巧，一步步解决它～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（质数处理）+ 双指针 + 分段策略`

🗣️ **初步分析**：
解决这道题的关键，就像**“分两段找宝藏”**：  
- 小范围的“宝藏”（质数和）：我们用“地图标记法”（埃氏筛预处理小质数）+“前后指针”（在质数前缀和上找目标和）快速定位；  
- 大范围的“宝藏”：因为大质数不会太密集，我们先猜“大概有多少个质数组成和”（枚举个数t），然后在“平均每个质数大小”（n/t）附近画个小圈（比如n/t±20t的区间），用“局部筛法”（区间筛）找出这个圈里的质数，再用指针找和为n的区间。  

### 核心思路与难点
所有题解都用了**“分段处理”**：  
1. **小范围预处理**：先筛出2e7或1e8以内的质数，计算前缀和，用双指针找是否有解；  
2. **大范围枚举**：如果小范围没找到，就枚举质数个数t（比如2到5000），在n/t附近的区间用“区间筛”找质数，再双指针找解。  

**核心难点**：  
- 如何处理10¹¹的大n？→ 分段！小范围直接筛，大范围“缩圈”找；  
- 如何高效找大区间内的质数？→ 区间筛（用小质数标记大区间的倍数）；  
- 如何确定枚举的t和区间大小？→ 利用质数密度（每lnx个数约有一个质数），区间大小设为t的20倍足够覆盖可能的质数。  

### 可视化设计思路
我会设计一个**“像素质数探险家”**的复古动画：  
- **风格**：FC红白机像素风，背景是浅蓝网格，质数用绿色方块，合数用灰色，双指针用红/蓝箭头；  
- **小范围阶段**：屏幕左边是“质数地图”（从2开始向右延伸），绿色方块标记质数，上方的数字条实时显示前缀和；红箭头（左指针）和蓝箭头（右指针）在地图上移动，当和等于n时，箭头闪烁并播放“铛”的胜利音效；  
- **大范围阶段**：屏幕分成三部分——左边是枚举的t值（比如t=5），中间是“中点”n/t（比如n=15时t=3，中点是5），右边是“搜索圈”[5-6,5+6]（即2到11）；小质数（2、3）会“扔石子”标记圈里的倍数（灰色），剩下的绿色方块是质数，双指针再在里面找和；  
- **交互**：有“单步执行”（看每一步筛法/指针移动）、“自动播放”（调速滑块）、“重置”按钮；关键操作（标记质数、指针移动）有“叮”“嗒”的像素音效，找到解时播放胜利BGM！


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了3份优质题解，一起来看看它们的亮点～
</eval_intro>

**题解一：World_Creater（赞：9）**
* **点评**：这份题解的思路最“接地气”——先筛小质数（2e7以内）用双指针找，没找到就枚举t（2到5000），在n/t附近的区间用“区间筛”（solve函数）找质数，再双指针。代码里的`findnxt`和`findpre`函数巧妙地在区间筛结果中找下一个/前一个质数，边界条件（比如n本身是质数）也处理得很严谨。最值得学的是**区间筛的实现**——用小质数标记大区间的倍数，避免了逐个判断大质数的低效！

**题解二：robinyqc（赞：3）**
* **点评**：这题解的代码太“聪明”了！用`bitset`优化筛法（节省内存），还写了模板函数`solve`同时处理小范围和大范围的情况。思路和题解一类似，但代码更简洁——比如小范围直接用预处理的`v`数组，大范围用`nv`数组做区间筛。亮点是**用模板函数统一逻辑**，减少了重复代码，非常适合竞赛中快速写对！

**题解三：novax（赞：2）**
* **点评**：这份题解的“杀招”是**米勒拉宾质数判定**！当区间很大时，用埃氏筛可能不够快，于是作者用概率性的米勒拉宾算法快速判断大质数（比如n本身是不是质数）。代码里的`check`函数枚举t，在n/t附近找质数，并用双指针找和。虽然代码有点复杂，但**处理超大型n的能力更强**，适合学有余力的同学研究！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“绊脚石”主要有三个，我们一一拆解～
</difficulty_intro>

1.  **难点1：如何处理10¹¹的大n？**
    * **分析**：直接筛10¹¹以内的质数是不可能的（内存和时间都不够）。题解的方法是**分段**：小范围（比如2e7）直接筛，大范围“缩圈”——枚举质数个数t，只找n/t附近的小区间（比如±20t），这样区间大小只有几万，筛起来很快！
    * 💡 **学习笔记**：大问题拆小，小问题用已知方法解决，这是算法的核心思想！

2.  **难点2：如何高效找大区间内的质数？**
    * **分析**：区间筛的原理和埃氏筛一样——用小质数（已经预处理好的）标记大区间内的倍数。比如要找[L,R]内的质数，就用所有≤√R的小质数p，标记L到R中p的倍数，剩下的就是质数！
    * 💡 **学习笔记**：复用小范围的结果，避免重复计算，这是“懒”的智慧～

3.  **难点3：如何用双指针找质数和？**
    * **分析**：双指针的核心是“滑动窗口”——右指针扩大窗口（加质数），左指针缩小窗口（减质数），直到和等于n。这种方法的时间复杂度是O(k)（k是质数个数），比暴力枚举所有区间快得多！
    * 💡 **学习笔记**：滑动窗口适合“找子数组和为目标”的问题，记住这个套路！

### ✨ 解题技巧总结
- **分段处理**：大n拆成小范围和大范围，分别用不同方法解决；  
- **区间筛**：用小质数标记大区间的倍数，高效找大质数；  
- **双指针滑动窗口**：快速找子数组和为目标的区间；  
- **边界条件处理**：别忘了n本身是质数的情况（直接输出n n）！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合版核心代码**，它整合了所有优质题解的思路，结构清晰，容易理解～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解一、二的思路，预处理2e7以内的质数，用双指针找小范围解；大范围枚举t，用区间筛找质数，再双指针。代码简洁，适合初学者学习。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <bitset>
#include <algorithm>
using namespace std;
typedef long long LL;

const int B = 20000000; // 小范围阈值（2e7）
vector<int> primes;      // 小范围质数列表
bitset<B + 1> is_prime;  // 小范围质数标记
LL prefix[1270607];      // 前缀和数组（2e7的质数约1.27e6个）

// 埃氏筛预处理小范围质数
void sieve_small() {
    is_prime.set(); // 初始化为true
    is_prime[0] = is_prime[1] = false;
    for (int i = 2; i <= B; ++i) {
        if (is_prime[i]) {
            primes.push_back(i);
            // 标记i的倍数为合数
            for (LL j = (LL)i * i; j <= B; j += i) {
                is_prime[j] = false;
            }
        }
    }
    // 计算前缀和：prefix[i]是前i个质数的和
    prefix[0] = 0;
    for (int i = 0; i < primes.size(); ++i) {
        prefix[i + 1] = prefix[i] + primes[i];
    }
}

// 区间筛：找[L, R]内的质数，返回质数列表
vector<LL> sieve_interval(LL L, LL R) {
    vector<LL> res;
    if (L > R) return res;
    bitset<100001> is_composite; // 标记区间内的合数（假设R-L<=1e5）
    // 用小质数标记区间内的倍数
    for (int p : primes) {
        if ((LL)p * p > R) break; // p²超过R，不需要再筛
        // 找第一个>=L的p的倍数
        LL start = max((LL)p * p, (L + p - 1) / p * p);
        for (LL j = start; j <= R; j += p) {
            is_composite[j - L] = true; // j-L是区间内的索引
        }
    }
    // 收集区间内的质数
    for (LL i = L; i <= R; ++i) {
        if (i < 2) continue; // 小于2的不是质数
        if (!is_composite[i - L]) {
            res.push_back(i);
        }
    }
    return res;
}

// 双指针找质数和：返回是否找到，找到则l和r是区间端点
bool find_sum(const vector<LL>& nums, LL n, LL& l, LL& r) {
    int m = nums.size();
    LL sum = 0;
    int left = 0; // 左指针
    for (int right = 0; right < m; ++right) { // 右指针扩大窗口
        sum += nums[right];
        // 缩小左指针，直到sum<=n
        while (sum > n) {
            sum -= nums[left];
            left++;
        }
        if (sum == n) { // 找到目标和
            l = nums[left];
            r = nums[right];
            return true;
        }
    }
    return false;
}

int main() {
    LL n;
    cin >> n;
    sieve_small(); // 预处理小范围质数

    // 1. 找小范围的解（质数都在B以内）
    LL l, r;
    if (find_sum(primes, n, l, r)) {
        cout << l << " " << r << endl;
        return 0;
    }

    // 2. 检查n本身是不是质数
    bool is_n_prime = true;
    for (int p : primes) {
        if ((LL)p * p > n) break;
        if (n % p == 0) {
            is_n_prime = false;
            break;
        }
    }
    if (is_n_prime) {
        cout << n << " " << n << endl;
        return 0;
    }

    // 3. 枚举质数个数t（2到5000）
    for (int t = 2; t <= 5000; ++t) {
        LL mid = n / t; // 平均每个质数的大小
        LL L = max(mid - (LL)t * 20, 2LL); // 左边界（防止小于2）
        LL R = mid + (LL)t * 20;           // 右边界
        vector<LL> interval_primes = sieve_interval(L, R);
        if (find_sum(interval_primes, n, l, r)) {
            cout << l << " " << r << endl;
            return 0;
        }
    }

    // 4. 无解
    cout << "NIE" << endl;
    return 0;
}
```
* **代码解读概要**：
  1. `sieve_small`：用埃氏筛预处理2e7以内的质数，并存到`primes`数组，同时计算前缀和`prefix`；  
  2. `sieve_interval`：用小质数标记大区间[L,R]的倍数，返回区间内的质数；  
  3. `find_sum`：双指针滑动窗口，找质数列表中 sum 为n的子数组；  
  4. `main`：先找小范围解→检查n是否为质数→枚举t找大范围解→无解输出NIE。

---
<code_intro_selected>
接下来看优质题解的**核心片段**，学习它们的“巧思”～
</code_intro_selected>

**题解一：World_Creater的区间筛**
* **亮点**：用`bitset`高效标记区间内的合数，并用`findnxt`/`findpre`找相邻质数。
* **核心代码片段**：
```cpp
void solve(int l, int r) {
    chk.reset(); // 重置bitset
    for (int i = 1; i <= cnt && prp[i] * prp[i] <= r; i++) {
        // 找第一个>=l的prp[i]的倍数
        int j = (l + prp[i] - 1) / prp[i];
        for (; j * prp[i] <= r; j++) {
            chk[prp[i] * j - l] = 1; // 标记为合数
        }
    }
}
int findnxt(int x, int g) {
    int i = x + 1;
    while (chk[i - g]) i++; // 找下一个未被标记的数（质数）
    return i;
}
```
* **代码解读**：
  - `solve`函数：用小质数`prp[i]`标记区间[l,r]内的倍数，`chk`是`bitset`，`prp[i]*j - l`是区间内的索引；  
  - `findnxt`函数：从x+1开始找下一个未被标记的数（即质数），`g`是区间左边界l。  
* 💡 **学习笔记**：`bitset`比`bool`数组更省内存，适合处理大区间！

**题解二：robinyqc的模板函数**
* **亮点**：用模板函数统一小范围和大范围的双指针逻辑，减少重复代码。
* **核心代码片段**：
```cpp
template<bool type, int len>
void solve(LL l, LL r, bitset<len>& b) {
    if (type) { // type=true表示大范围，需要先筛
        b.reset();
        for (LL i : p) {
            if (i * i > r) break;
            LL j = (l + i - 1) / i * i;
            for (; j <= r; j += i) b.set(j - l);
        }
    }
    // 双指针找和
    LL sum = 0, pl = l;
    for (LL i = l; i <= r; i++) {
        if (!b[i - l]) {
            sum += i;
            while (sum > n) {
                if (!b[pl - l]) sum -= pl;
                pl++;
            }
            if (sum == n) { cout << max(pl, 1ll) << ' ' << i << '\n'; exit(0); }
        }
    }
}
```
* **代码解读**：
  - `type`是模板参数：`type=false`时，`b`是小范围的`v`数组（已经筛好）；`type=true`时，`b`是大范围的`nv`数组（需要先筛）；  
  - 后面的双指针逻辑和通用代码一样，但用模板统一了小范围和大范围的处理。  
* 💡 **学习笔记**：模板函数可以减少重复代码，竞赛中常用！

**题解三：novax的米勒拉宾质数判定**
* **亮点**：用概率性算法快速判断大质数，适合处理超大型n。
* **核心代码片段**：
```cpp
long long pow(__int128 x, long long y, long long mod) {
    if (y == 0) return 1;
    x %= mod;
    __int128 ret = pow(x, y/2, mod);
    ret = (y&1) ? ret*ret%mod*x%mod : ret*ret%mod;
    return ret;
}
bool isprime(long long n) {
    if (n < 3 || n%2 == 0) return n == 2;
    long long u = n-1, t = 0;
    while (u%2 == 0) u /= 2, t++; // 把n-1写成u*2^t
    for (int i=0; i<8; i++) { // 测试8个基，正确率足够
        long long a = rand()%(n-2)+2;
        long long v = pow(a, u, n);
        if (v == 1) continue;
        int s;
        for (s=0; s<t; s++) {
            if (v == n-1) break;
            v = (__int128)v*v%n;
        }
        if (s == t) return false;
    }
    return true;
}
```
* **代码解读**：
  - `pow`函数：用快速幂计算`x^y mod mod`，用`__int128`防止溢出；  
  - `isprime`函数：米勒拉宾算法的核心——把n-1分解成u*2^t，然后测试多个基a，如果都满足条件，n大概率是质数。  
* 💡 **学习笔记**：米勒拉宾是处理大质数的“神器”，竞赛中必学！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家更直观地“看”到算法运行，我设计了**“像素质数探险家”**动画，用FC风格还原解题过程～
</visualization_intro>

### 🎮 动画设计细节
* **主题**：像素小人“质数探险家”在数字地图上找“和为n的质数区间”，融合“筛法”“双指针”“区间搜索”三大环节。
* **风格**：8位像素风（FC红白机），色彩用复古调色板（浅蓝背景、绿色质数、灰色合数、红/蓝指针）。
* **核心演示步骤**：

#### 1. 小范围预处理（埃氏筛）
- **场景**：屏幕左侧是“数字地图”（从2开始向右延伸，每个数字是16x16像素方块）；  
- **动画**：  
  - 像素小人从2出发，用绿色油漆桶标记质数（比如2、3、5…），用灰色标记合数（比如4、6、8…）；  
  - 上方的“前缀和条”实时显示前k个质数的和（比如前3个质数和是2+3+5=10）；  
- **音效**：标记质数时播放“叮”（高频短音），标记合数时播放“嗒”（低频短音）。

#### 2. 小范围双指针找解
- **场景**：数字地图上方出现红、蓝两个箭头（左、右指针）；  
- **动画**：  
  - 蓝箭头先向右移动（加质数，sum增加），当sum超过n时，红箭头向右移动（减质数，sum减少）；  
  - 当sum等于n时，红、蓝箭头闪烁，屏幕下方弹出“找到啦！区间是[l,r]”的文字，播放胜利BGM（8位版《超级马里奥》通关音效）；  
- **交互**：用户可以点击“单步”按钮，看每一步指针移动；也可以拖动“速度滑块”调整自动播放速度。

#### 3. 大范围区间筛（枚举t）
- **场景**：屏幕分成三部分——左边是“t值选择器”（比如t=5），中间是“中点”n/t（比如n=15，t=3，中点是5），右边是“搜索圈”[5-6,5+6]（即2到11）；  
- **动画**：  
  - 小质数（2、3）从左边飞来，用灰色油漆桶标记搜索圈内的倍数（比如2标记4、6、8、10；3标记6、9）；  
  - 剩下的绿色方块是质数（2、3、5、7、11），红、蓝指针再在里面找和；  
- **音效**：小质数“扔石子”标记时播放“砰”（短促低音），指针移动时播放“嗒”。

#### 4. 游戏化元素
- **关卡设计**：把小范围预处理、大范围枚举做成“关卡1”“关卡2”，完成一关解锁下一关；  
- **积分系统**：每找到一个质数加10分，找到解加100分，分数显示在屏幕右上角；  
- **AI演示**：点击“AI自动玩”，像素小人会自动完成筛法和双指针，适合新手观察流程。

### 🛠️ 实现思路
- **技术栈**：HTML5 Canvas（绘制像素图形）+ JavaScript（动画逻辑）+ Web Audio API（音效）；  
- **颜色方案**：背景#C0C0C0（浅灰蓝），质数#00FF00（绿），合数#808080（灰），指针#FF0000（红）、#0000FF（蓝）；  
- **音效**：用Audacity制作8位音效（比如“叮”是正弦波440Hz，“嗒”是方波220Hz），通过`AudioContext`播放。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“分段+筛法+双指针”的套路后，我们可以解决更多质数相关的问题～
</similar_problems_intro>

### 🧠 通用思路迁移
- **质数和问题**：比如找“连续k个质数的和”，可以用前缀和+双指针；  
- **区间质数统计**：比如“统计[L,R]内的质数个数”，用区间筛；  
- **大质数判断**：比如“判断1e18的数是不是质数”，用米勒拉宾。

### 📚 洛谷练习推荐
1. **洛谷 P3383 - 线性筛素数**  
   🗣️ **推荐理由**：巩固最基础的质数筛法（线性筛），比埃氏筛更高效，是后续所有质数问题的基础！
   
2. **洛谷 P1835 - 素数密度**  
   🗣️ **推荐理由**：直接考察“区间筛”的实现——统计[L,R]内的质数个数，和本题的区间筛逻辑几乎一样！
   
3. **洛谷 P2613 - 质数和**  
   🗣️ **推荐理由**：找“连续质数的和等于n”的方案数，和本题的双指针逻辑完全一致，是本题的“简化版”！
   
4. **洛谷 P1217 - [USACO1.5] 回文质数**  
   🗣️ **推荐理由**：结合回文数判断和质数判断，需要用米勒拉宾处理大回文数，是本题的“进阶版”！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者们分享了很多“踩坑”经验，我们来看看～
</insights_intro>

> **参考经验（来自World_Creater）**：“数字较大的时候一个一个判素数还是太笨蛋了，因为最终的暴力区间不会很大，因此可以考虑使用筛区间质数的方法。”  
> **点评**：作者的这个经验太重要了！当需要处理大区间内的质数时，**区间筛比逐个判断高效得多**——因为它利用了小质数的倍数来标记，避免了重复计算。比如要找[1e8, 1e8+1e5]内的质数，区间筛只需要用≤√(1e8+1e5)≈1e4的小质数，而逐个判断需要对每个数做O(√x)的运算，差距非常大！

> **参考经验（来自novax）**：“卡常卡了很久，使用了miller-rabin加速判定质数。”  
> **点评**：对于超大型n（比如1e18），埃氏筛或区间筛可能不够快，这时候**米勒拉宾是救星**！它的时间复杂度是O(k log³n)（k是测试基的数量），比O(√n)的试除法快得多，适合处理大质数。


<conclusion>
本次关于“素数和”的分析就到这里啦！这道题的核心是**“分段处理”**——把大问题拆成小问题，用已知的技巧解决。希望大家能学会“拆问题”的思路，下次遇到大n的问题时，也能像今天这样“分而治之”～  
编程的乐趣在于“解决问题的过程”，慢慢来，你一定能行！💪
</conclusion>

---
处理用时：196.58秒
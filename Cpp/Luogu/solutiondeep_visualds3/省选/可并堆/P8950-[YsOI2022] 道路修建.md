# 题目信息

# [YsOI2022] 道路修建

## 题目背景

Ysuperman 正在给他幼儿园里的小朋友们准备一场模板测试，下面是一道模板题，他希望你可以帮他验一下题目。

## 题目描述

某地新建了 $n$ 座城市，拟定建造 $m$ 条**单向**道路，其中第 $i$ 条道路起点为 $u_i$，终点为 $v_i$，建造费用为正整数 $w_i$。

然而在道路开始修建之前突发紧急情况，需要马上选择这些道路中的一些来修建使得所有城市的人都可以走到某 $k$ 座城市中（也就是说，所有城市的人都可以走到这 $k$ 座城市中的**至少一座**城市中），你想要知道，如果这 $k$ 座城市是等概率随机在 $n$ 座城市中的选定的，那么期望的最小修建费用是多少。

为了避免分数输入输出，你只需要输出答案对 $998244353$ 取模的结果。

## 说明/提示

#### 样例 1 解释

总共有三种选定集合城市的方案：

1. 选定集合在城市 $1$，那么选择建造 $2\to 1,3\to 1$ 两条道路花费最少，为 $2+4=6$。

2. 选定集合在城市 $2$，那么选择建造 $1\to 2,3\to 1$ 两条道路花费最少，为 $1+4=5$。

3. 选定集合在城市 $3$，那么选择建造 $1\to 2,2\to 3$ 两条道路花费最少，为 $1+3=4$。

所以期望最小花费为 $(6+5+4)/3=5$。

#### 样例 2 解释

有 $6$ 种选择集合城市的方法：

1. 选城市 $1,2$，最小花费 $9$。

2. 选城市 $1,3$，最小花费 $6$。

3. 选城市 $1,4$，最小花费 $7$。

4. 选城市 $2,3$，最小花费 $5$。

5. 选城市 $2,4$，最小花费 $6$。

6. 选城市 $3,4$，最小花费 $3$。

所以期望最小花费为 $(9+6+7+5+6+3)\div 6=6$。

#### 样例 3 解释

这里太小写不下，只配个图算了：

![](https://cdn.luogu.com.cn/upload/image_hosting/cdnuoook.png)

#### 样例 4 解释

当集合城市选在 $1,2,3$ 时，城市 $4$ 无论如何都无法达到 $1,2,3$ 中的任意一个，所以答案为 $-1$。

#### 数据范围

对于 $10\%$ 的数据，满足 $n\le 15$，$m\le 30$。

对于 $30\%$ 的数据，满足 $n\le 20$，$m\le 50$。

另有 $5\%$ 的数据，满足所有 $w_i$ 相等。

另有 $5\%$ 的数据，满足 $k=n$。

另有 $5\%$ 的数据，满足 $k=n-1$。

另有 $10\%$ 的数据，满足 $m=n$。

另有 $20\%$ 的数据，满足 $k=1$。

对于 $100\%$ 的数据，满足 $2\le n\le 10^5$，$1\le m\le 2\times 10^5$，$1\le k\le n$，$1\le u_i,v_i\le n$，$0\le w_i\le 998244352$。

## 样例 #1

### 输入

```
3 4 1
1 2 1
2 1 2
2 3 3
3 1 4```

### 输出

```
5```

## 样例 #2

### 输入

```
4 6 2
1 2 1
1 3 3
2 3 2
3 4 5
4 1 4
4 2 6```

### 输出

```
6```

## 样例 #3

### 输入

```
8 16 3
5 6 7
7 2 10
4 6 4
5 7 5
8 4 12
1 3 8
2 3 6
4 1 8
1 7 2
8 3 1
2 5 3
6 4 11
7 3 14
3 8 9
8 1 13
6 7 16```

### 输出

```
160432162```

## 样例 #4

### 输入

```
4 1 3
2 4 1```

### 输出

```
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[YsOI2022]道路修建 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（基环树处理） + 最小树形图（朱刘算法） + 组合计数

🗣️ **初步分析**：  
解决这道题的关键，是理解**“每个点选最小出边会形成基环树森林”**——想象每个城市是一个小房子，每条路是连接房子的单向小路，每个房子都想选一条最便宜的小路“出去”。这样一来，所有房子会连成几个“带环的树”（基环树）：每个连通块里有一个环，其他房子像树枝一样“挂”在环上，指向环里的房子。  

那问题中的“选k个城市让所有人都能走到它们”，等价于**每个基环树的环里必须有至少一个被选中的城市**——否则环里的房子无法走到任何选中的点（因为它们的最小出边都在环里）。如果环里没选中的点，我们就得“换一条更贵的路”（比如从环里连到外面的路），代价是“新路的费用 - 原最小出边的费用”。  

**核心算法流程**：  
1. 用**可并堆**维护每个点的最小出边（快速找最便宜的路）；  
2. 用**朱刘算法**处理基环树：找到环→缩成一个大节点→调整边权（新路费用减原最小费用）；  
3. 用**组合计数**统计每条边的贡献：计算有多少个k元子集需要这条边（即子集里没有当前连通块的点），贡献为“边权 × 子集数”。  

**可视化设计思路**：  
我们用8位像素风格模拟城市和道路——节点是彩色方块（比如蓝色代表未选中，绿色代表选中），边是箭头（粗细代表边权大小）。缩环时，环里的节点会合并成一个“大像素块”，边权调整用数字显示“差价”。关键操作（选边、缩环、计算贡献）会触发不同音效：选边是“叮”，缩环是“咚”，贡献计算是“滴”。自动播放模式像“AI规划师”一样逐步演示，单步模式让你慢慢看清楚每一步的变化～


## 2. 精选优质题解参考

<eval_intro>
我筛选了思路最清晰、代码最完整的题解，帮你快速抓住核心逻辑：
</eval_intro>

**题解一：(来源：tobie)**  
* **点评**：这份题解完美结合了朱刘算法和组合计数，思路闭环且代码实现高效。它用**带懒标记的可并堆**快速维护每个点的最小出边，解决了朱刘算法中“找最小边”的瓶颈；缩环时的边权调整（用`Add`函数给边权打负差标记）非常巧妙，避免了重复计算；贡献统计用组合数`C(n - siz, K)`精准计算了“需要这条边的k元子集数量”。代码结构清晰，变量命名（比如`rt`代表可并堆的根，`siz1`代表连通块大小）很容易理解，是一份“能直接拿来学的模板级代码”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有三个，我们一个个拆解：
</difficulty_intro>

1. **难点1：如何把问题转化为基环树？**  
   * **分析**：每个点选最小出边是“最小费用”的必然选择——因为选更贵的边只会增加总费用。这些最小出边连起来，每个连通块一定是基环树（有且只有一个环）。如果环里有选中的点，所有点都能走到它；如果没有，就必须换一条从环里连到外面的路，代价是“新路费用 - 原最小费用”。  
   * 💡 **学习笔记**：最小出边→基环树，这是图论中“贪心选边”的经典结论！

2. **难点2：缩环时如何调整边权？**  
   * **分析**：缩环后，环里的点变成一个“大节点”。原来环里的点连到外面的边，代价要减去“原最小出边的费用”——因为我们已经用了原最小边，现在换路的话，多花的钱就是“新路 - 原最小”。比如原边权是5，原最小是3，那么调整后的边权是2（5-3）。  
   * 💡 **学习笔记**：缩环的本质是“把环的调整代价转化为新的边权”，这样就能用同样的方法处理缩后的图！

3. **难点3：如何统计每条边的贡献？**  
   * **分析**：一条边的贡献 = 边权 × 「需要这条边的k元子集数量」。比如当前连通块大小是`siz`，选k个点都不在这个连通块的情况数是`C(n - siz, K)`——这时候所有点都要靠这条边走到外面的选中点，所以需要这条边的代价。  
   * 💡 **学习笔记**：组合计数的关键是“找对需要这条边的场景”，用组合数精准量化！


### ✨ 解题技巧总结
- **技巧A：贪心选最小出边**：优先选每个点的最小出边，这是降低总费用的关键，也是基环树的基础。  
- **技巧B：缩环处理基环树**：遇到环就缩成大节点，把复杂的环问题转化为树问题，简化计算。  
- **技巧C：组合数统计贡献**：用组合数计算“需要某条边的场景数”，避免枚举所有k元子集（否则n=1e5会超时！）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份完整的核心实现——来自tobie的题解，它覆盖了可并堆、朱刘算法、缩环、贡献计算的全流程：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码是朱刘算法处理基环树的经典实现，用可并堆维护最小出边，组合数统计贡献，逻辑完整且高效。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    typedef pair<int,int> pii;

    const int N=5e5+9, mod=998244353;
    int fac[N],inv[N],ifac[N];

    // 预处理组合数
    void ycl(int lim) {
        fac[0]=ifac[0]=inv[1]=1;
        for(int i=2;i<=lim;i++) inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
        for(int i=1;i<=lim;i++) fac[i]=1ll*fac[i-1]*i%mod, ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
    }
    int C(int x,int y) { return x>=y&&y>=0?1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod:0; }

    // 带懒标记的可并堆（维护每个点的最小出边）
    int tcnt=0, siz[N], son[N][2], tag[N], dep[N];
    pii val[N];
    int new_node(pii x) {
        int u=++tcnt;
        siz[u]=1; tag[u]=son[u][0]=son[u][1]=0; val[u]=x;
        return u;
    }
    void Add(int u,int x) { if(u) val[u].first+=x, tag[u]+=x; }
    void pushdown(int u) { if(tag[u]) Add(son[u][0],tag[u]), Add(son[u][1],tag[u]), tag[u]=0; }
    void pushup(int u) { siz[u]=siz[son[u][0]]+siz[son[u][1]]+1; dep[u]=dep[son[u][1]]+1; }
    int Merge(int u,int v) {
        if(!u||!v) return u+v;
        pushdown(u), pushdown(v);
        if(val[u]>val[v]) swap(u,v); // 小根堆，取最小边
        son[u][1]=Merge(son[u][1],v);
        if(dep[son[u][0]]<dep[son[u][1]]) swap(son[u][0],son[u][1]);
        return pushup(u),u;
    }
    void pop(int &rt) { pushdown(rt); rt=Merge(son[rt][0],son[rt][1]); }

    int n,m,K, rt[N], nxt[N], len[N], tp[N], siz1[N], bcj[N];
    int gettp(int x) { return tp[x]==x?x:tp[x]=gettp(tp[x]); }
    int getfa(int x) { return bcj[x]==x?x:bcj[x]=getfa(bcj[x]); }

    int main() {
        ycl(2e5);
        scanf("%d%d%d",&n,&m,&K);
        for(int i=1;i<=m;i++) {
            int u,v,w; scanf("%d%d%d",&u,&v,&w);
            if(u!=v) rt[u]=Merge(rt[u],new_node({w,v}));
        }
        for(int i=1;i<=n;i++) bcj[i]=tp[i]=i, siz1[i]=1;
        int ans=0;

        for(int u=1;u<=n;u++) {
            while(siz[rt[u]]) {
                int v=val[rt[u]].second;
                if(gettp(u)==gettp(v)) { pop(rt[u]); continue; } // 同一连通块，跳过
                // 统计贡献：C(n - siz1[tp[u]], K) 是选k个点都不在当前连通块的情况
                ans=(ans+1ll*C(n-siz1[gettp(u)],K)*(val[rt[u]].first%mod+mod)%mod)%mod;
                if(getfa(u)==getfa(v)) { // 发现环，缩环
                    int uu=gettp(v), d=val[rt[u]].first;
                    pop(rt[u]); Add(rt[u],-d); // 调整边权：新路 - 原最小
                    while(uu!=u) {
                        Add(rt[uu],-len[uu]); // 环里的点边权都减原最小
                        rt[u]=Merge(rt[u],rt[uu]); // 合并可并堆
                        uu=gettp(nxt[uu]);
                    }
                    uu=gettp(v);
                    while(uu!=u) { // 合并连通块
                        siz1[u]+=siz1[uu];
                        bcj[uu]=tp[uu]=u;
                        uu=gettp(nxt[uu]);
                    }
                } else { // 不在同一树，连边
                    nxt[u]=gettp(v); len[u]=val[rt[u]].first;
                    bcj[u]=v; break;
                }
            }
            if(!siz[rt[u]]) { // 无法到达任何选中的点，无解
                if(siz1[u]+K<=n) { puts("-1"); return 0; }
            }
        }
        printf("%lld\n",1ll*ans*ifac[C(n,K)]%mod); // 期望=总贡献/总子集数
    }
    ```
* **代码解读概要**：  
  1. **预处理组合数**：用`ycl`函数算阶乘`fac`、逆元`inv`、阶乘逆元`ifac`，方便快速计算组合数`C(x,y)`。  
  2. **可并堆初始化**：每个点的出边用`rt[u]`维护，`Merge`函数合并两个堆，`pop`函数删除堆顶（最小边）。  
  3. **朱刘算法主流程**：遍历每个点，找它的最小出边；如果形成环，就缩环并调整边权；否则连边形成树。  
  4. **贡献统计**：每选一条边，就用`C(n - siz1[tp[u]], K)`算需要这条边的子集数，累加到`ans`。  
  5. **期望计算**：总贡献除以总子集数`C(n,K)`（用逆元实现除法取模）。


<code_intro_selected>
接下来看tobie题解中最核心的“可并堆+缩环”片段：
</code_intro_selected>

**题解一：(来源：tobie)**
* **亮点**：用带懒标记的可并堆高效维护最小出边，缩环时的边权调整避免了重复计算。
* **核心代码片段**：
    ```cpp
    // 可并堆的Merge操作（小根堆，取最小边）
    int Merge(int u,int v) {
        if(!u||!v) return u+v;
        pushdown(u), pushdown(v);
        if(val[u]>val[v]) swap(u,v); // 小根堆，u是较小的边
        son[u][1]=Merge(son[u][1],v); // 右子树合并v
        if(dep[son[u][0]]<dep[son[u][1]]) swap(son[u][0],son[u][1]); // 保持左子树更深
        return pushup(u),u;
    }

    // 缩环时的边权调整
    if(getfa(u)==getfa(v)) {
        int uu=gettp(v), d=val[rt[u]].first;
        pop(rt[u]); Add(rt[u],-d); // 原边权减d（d是原最小边）
        while(uu!=u) {
            Add(rt[uu],-len[uu]); // 环里的点边权都减原最小
            rt[u]=Merge(rt[u],rt[uu]); // 合并可并堆
            uu=gettp(nxt[uu]);
        }
        // ... 合并连通块
    }
    ```
* **代码解读**：  
  - **可并堆的Merge**：这是小根堆的合并操作，`pushdown`处理懒标记（比如边权的调整），`swap(u,v)`保证u是较小的边，`swap(son)`保持堆的平衡（左子树更深）。这样合并后的堆顶永远是当前点的最小出边！  
  - **缩环的边权调整**：当发现环时，`Add(rt[u], -d)`把当前点的所有出边权减去“原最小边d”——因为原最小边已经用在环里了，现在换路的话，多花的钱就是“新路 - 原最小”。环里的其他点也用`Add(rt[uu], -len[uu])`调整，这样所有环里的边权都变成了“换路的差价”。  
* 💡 **学习笔记**：懒标记是处理“批量调整”的神器！它能让你用O(1)的时间给一堆边权打标记，而不是逐个修改～


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们用“像素城市规划师”的游戏模式，让算法“动起来”：
</visualization_intro>

  * **动画演示主题**：《像素城市的道路规划》（8位FC风格）
  * **核心演示内容**：基环树的形成→缩环→边权调整→贡献统计
  * **设计思路简述**：用像素风降低“抽象感”，用音效强化“关键操作记忆”，用自动播放像“AI老师”一样演示，单步模式让你慢慢琢磨——比如缩环时，环里的节点会“粘”在一起变成大方块，边权调整用数字飘出来，贡献统计时数字会“跳一下”，特别有代入感！

  * **动画帧步骤与交互关键点**：
    1. **初始化**：屏幕显示像素化城市（蓝色方块是节点，箭头是边，粗细代表边权），控制面板有“开始/暂停”“单步”“重置”按钮，速度滑块（慢→快）。8位风格的背景音乐（像《超级玛丽》的轻快旋律）开始播放～
    2. **选最小出边**：每个节点的最小出边会闪烁（黄色箭头），点击“单步”，节点会“选”这条边，伴随“叮”的音效。
    3. **发现环**：当两个节点的边形成环时，环里的节点会变成橙色，闪烁提示“发现环！”，伴随“咚”的音效。
    4. **缩环**：环里的节点合并成一个红色大方块，边权调整时，箭头旁边会飘出“-d”的数字（比如“-3”），代表“新路 - 原最小”。
    5. **统计贡献**：贡献计算时，红色方块旁边会弹出“C(n-siz, K) × 边权”的数字，伴随“滴”的音效，数字会“飞”到右上角的“总贡献”面板里。
    6. **结束**：所有步骤完成后，总贡献除以总子集数，屏幕弹出“期望费用：X”的像素文字，伴随“胜利”音效（像《魂斗罗》的通关音乐）！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了这道题，你可以挑战更难的“基环树+组合计数”问题：
</similar_problems_intro>

  * **通用思路迁移**：基环树的缩环技巧、可并堆维护最小边、组合数统计贡献，这些技巧能解决**所有“选边让所有点到达某集合”的问题**——比如“选k个根的最小生成森林”“有向图的最小树形图期望”。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P4716** - 最小树形图  
       🗣️ **推荐理由**：朱刘算法的模板题，帮你巩固“找最小边、缩环”的核心逻辑。
    2. **洛谷 P3243** - 基环树DP  
       🗣️ **推荐理由**：基环树的经典DP问题，让你学会“破环成树”的技巧（和缩环异曲同工）。
    3. **洛谷 P5022** - 旅行  
       🗣️ **推荐理由**：基环树的遍历问题，帮你理解“环上的点如何影响整个连通块”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
tobie的题解里藏着一个“踩坑经验”：
</insights_intro>

> **参考经验 (来自 tobie)**：“缩环时一定要给所有环里的边权打‘负差’标记，否则会重复计算原最小边的费用！”  
> **点评**：这个经验太重要了！如果不调整边权，你会把“原最小边”和“换路的差价”都算进去，导致总贡献翻倍。动手模拟一遍缩环过程，你就能明白“负差标记”的必要性～


<conclusion>
这道题把基环树、朱刘算法、组合计数揉在一起，是一道“综合能力题”。但只要你抓住“最小出边→基环树→缩环→贡献统计”的主线，就能一步步拆解。记住：**算法的本质是“把复杂问题拆成简单步骤”**，比如缩环把环拆成点，组合数把枚举拆成公式。下次遇到类似问题，试着用“拆步骤”的思路想想——你一定能解决！💪
</conclusion>

---
处理用时：100.28秒
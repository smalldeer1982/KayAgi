# 题目信息

# 【模板】可持久化并查集

## 题目描述

给定 $n$ 个集合，第 $i$ 个集合内初始状态下只有一个数，为 $i$。

有 $m$ 次操作。操作分为 $3$ 种：

 - `1 a b` 合并 $a,b$ 所在集合；

 - `2 k` 回到第 $k$ 次操作（执行三种操作中的任意一种都记为一次操作）之后的状态，保证已经进行过至少 $k$ 次操作（不算本次操作），特别的，若 $k=0$，则表示回到初始状态；

 - `3 a b` 询问 $a,b$ 是否属于同一集合，如果是则输出 $1$，否则输出 $0$。

## 说明/提示

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le m\le 2\times 10^5$，$1 \le a, b \le n$。

## 样例 #1

### 输入

```
5 6
1 1 2
3 1 2
2 0
3 1 2
2 1
3 1 2```

### 输出

```
1
0
1```

# AI分析结果

---
# 💡 Kay的C++算法解析：可持久化并查集 深入学习指南 💡

<introduction>
  今天我们来一起分析「可持久化并查集」这道经典的C++编程题。它像一本「会拍照的集合手册」——每次操作都会给集合拍张「快照」，你可以随时回到之前的快照状态。本指南会帮你理清思路，掌握核心算法，还会用像素动画让你「看」到算法的每一步！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`可持久化数据结构（主席树） + 按秩合并的并查集`

🗣️ **初步分析**：
> 解决「可持久化并查集」的关键，是把「普通并查集」和「可持久化技术」结合起来。  
> 普通并查集用`fa`数组记录父节点，靠「路径压缩」和「按秩合并」加快速度。但**路径压缩会修改很多节点**（比如把一条链上的节点都指向根），无法保存「版本快照」——这就像你在本子上乱涂乱画，没法回到之前的页面。  
> 所以我们换用「按秩合并」（只修改两个节点：合并的两个根），再用「主席树」（可持久化线段树）保存每个版本的`fa`和`秩`（深度或大小）。主席树像一本「活页快照本」，每新增一页（版本）只复制需要修改的内容，其余内容和旧页共享，这样就能轻松回退到任意版本啦！

   - **题解思路共性**：所有优质题解都围绕「用可持久化结构维护并查集」展开，主要分两类：  
     1. **在线做法**：用主席树维护`fa`和`秩`，每次操作生成新版本（如hegm、chenxinyang2006的题解）；  
     2. **离线做法**：把版本关系建成树，用DFS回溯实现回退（如zj余能、SSerxhs的题解）。  
   - **核心难点**：① 不能用路径压缩；② 按秩合并的复杂度保证；③ 可持久化时的版本管理（比如修改`fa`和`秩`要新建版本，不能覆盖旧版本）。  
   - **可视化设计思路**：用「FC红白机风格」的像素动画，每个节点是16x16的像素块，颜色代表父节点（比如根节点是红色，子节点是父节点的浅色调），大小代表深度（深度越大，块越大）。操作时：  
     - 合并：两个根节点闪烁，小根的块颜色变成大根的颜色，若深度相同，大根的块变大一点；  
     - 回退：画面「咻」地一下切回旧版本的快照；  
     - 查询：两个节点的路径逐个闪烁到根，根相同则显示绿色对勾，否则红色叉号。  
   - **游戏化元素**：加入8位音效——合并成功「叮」，回退「咻」，查询「滴」，成功「叮~」（上扬调），失败「嘟」（短促）；设置「版本闯关」，完成10次操作解锁「快照大师」成就！


## 2. 精选优质题解参考

<eval_intro>
  我从「思路清晰度」「代码可读性」「算法有效性」三个维度筛选了4篇优质题解，帮你从不同角度理解问题～
</eval_intro>

**题解一：hegm（按深度合并的在线做法）**  
* **点评**：这篇题解把「可持久化并查集」的核心逻辑讲得特别清楚！作者明确指出「路径压缩不能用，必须用按深度合并」，还详细解释了如何用主席树维护`fa`和`dep`（深度）。代码结构超规范——`build`建初始树、`que`查节点、`find`找根、`hb`改父、`add`改深度，每一步都有明确的分工。最贴心的是作者提醒「合并时要新建两个版本」（改`fa`和`dep`各一次），避免覆盖旧版本，这是很多人会踩的坑！

**题解二：zj余能（离线DFS做法）**  
* **点评**：这篇题解的思路很新颖！作者把「版本回退」转化为「DFS的回溯」——版本关系像一棵树，进入节点时修改并查集，离开时撤销修改（用栈保存操作）。这种「离线处理」不用写复杂的主席树，代码更简洁，还用到了「启发式合并」（按大小合并），保证了复杂度。适合想理解「版本树」本质的同学～

**题解三：chenxinyang2006（按大小合并的在线做法）**  
* **点评**：作者用「数学证明」讲清楚了「按秩合并为什么能保证树高是logn」——比如按大小合并时，每个节点的深度最多增加logn次（因为大小至少翻倍）。代码里用两个主席树分别维护`fa`和`size`，合并时把小集合嫁接到大集合上，逻辑特别直观。还对比了「按深度合并」和「按大小合并」的区别，帮你理解两种方式的共性！

**题解四：PassName（用rope的简洁做法）**  
* **点评**：这篇题解用了C++的扩展库`rope`（可持久化数组），直接把`fa`数组做成可持久化的，代码超简洁！虽然需要「吸氧」（开O2优化）才能过，但思路很巧妙——`rope`的`replace`函数帮我们自动处理版本，不用手动写主席树。适合想快速实现可持久化的同学～


## 3. 核心难点辨析与解题策略

<difficulty_intro>
  解决「可持久化并查集」时，大家常遇到这3个「拦路虎」，我们一起拆解它们！
</difficulty_intro>

1. **难点1：为什么不能用路径压缩？**  
   * **分析**：路径压缩会修改一条链上的所有节点（比如把`fa[2]=3`、`fa[3]=4`改成`fa[2]=4`、`fa[3]=4`），这样每次查询都会生成很多新版本，空间和时间都会爆炸。而「按秩合并」只修改两个节点（合并的两个根），完美适配可持久化！  
   * 💡 **学习笔记**：可持久化要求「每次修改的节点数尽可能少」，路径压缩不符合这个要求。

2. **难点2：按秩合并选「深度」还是「大小」？**  
   * **分析**：两种方式都能保证树高是logn，任选其一即可：  
     - 按深度合并：把深度小的树嫁接到深度大的树上，深度相同时才增加新根的深度；  
     - 按大小合并：把大小小的树嫁接到大小大的树上，合并后更新新根的大小。  
   * 💡 **学习笔记**：两种方式的核心都是「让树尽可能矮」，保证`find`的复杂度是O(logn)。

3. **难点3：可持久化时如何管理版本？**  
   * **分析**：用主席树维护`fa`和`秩`时，每次修改都要「新建节点」，不能修改旧节点。比如合并时，先改`fa`（新建版本A），再改`秩`（基于版本A新建版本B），这样旧版本的`fa`和`秩`不会被覆盖。  
   * 💡 **学习笔记**：可持久化的本质是「写时复制」——修改前先复制旧节点，再改复制后的节点。


### ✨ 解题技巧总结
- **技巧1：优先选按秩合并**：放弃路径压缩，用按深度或大小合并保证复杂度；  
- **技巧2：用主席树维护两个数组**：`fa`（父节点）和`秩`（深度/大小）都要可持久化；  
- **技巧3：离线处理简化问题**：如果题目允许离线（不用实时回答查询），可以用DFS回溯代替主席树；  
- **技巧4：注意版本号**：每个操作对应一个版本，回退时直接用旧版本的根节点。


## 4. C++核心代码实现赏析

<code_intro_overall>
  我们先看一个「按深度合并的在线做法」的核心代码（综合hegm的题解），帮你理清整体框架～
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码用主席树维护`fa`和`dep`（深度），按深度合并，支持三种操作，逻辑清晰易读。  
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
#define N 300005
using namespace std;

int n, m, cnt, rt[N]; // rt[i]是第i次操作后的主席树根节点

struct Tree { int ls, rs, fa, dep; } tr[N * 20]; // 主席树节点：左右儿子、父、深度

// 建初始树：每个节点的父是自己，深度1
int build(int l, int r) {
    int to = ++cnt;
    if (l == r) { tr[to].fa = l; tr[to].dep = 1; return to; }
    int mid = (l + r) >> 1;
    tr[to].ls = build(l, mid);
    tr[to].rs = build(mid + 1, r);
    return to;
}

// 查询版本now中，节点x的主席树节点
int query(int now, int l, int r, int x) {
    if (l == r) return now;
    int mid = (l + r) >> 1;
    return x <= mid ? query(tr[now].ls, l, mid, x) : query(tr[now].rs, mid + 1, r, x);
}

// 找版本now中，节点a的根（递归找父，直到父是自己）
int find(int now, int a) {
    int fa_node = query(rt[now], 1, n, a);
    if (tr[fa_node].fa == a) return fa_node;
    return find(now, tr[fa_node].fa);
}

// 新建节点：复制旧节点
int new_node(int old) {
    int to = ++cnt;
    tr[to] = tr[old];
    return to;
}

// 修改版本pre中，节点x的父为f，返回新版本根
int update_fa(int pre, int l, int r, int x, int f) {
    int to = new_node(pre);
    if (l == r) { tr[to].fa = f; return to; }
    int mid = (l + r) >> 1;
    if (x <= mid) tr[to].ls = update_fa(tr[pre].ls, l, mid, x, f);
    else tr[to].rs = update_fa(tr[pre].rs, mid + 1, r, x, f);
    return to;
}

// 修改版本pre中，节点x的深度+1，返回新版本根
int update_dep(int pre, int l, int r, int x) {
    int to = new_node(pre);
    if (l == r) { tr[to].dep++; return to; }
    int mid = (l + r) >> 1;
    if (x <= mid) tr[to].ls = update_dep(tr[pre].ls, l, mid, x);
    else tr[to].rs = update_dep(tr[pre].rs, mid + 1, r, x);
    return to;
}

// 合并版本i-1中的a和b，生成版本i
void merge(int i, int a, int b) {
    rt[i] = rt[i-1]; // 先复制旧版本
    int fa_a = find(i-1, a), fa_b = find(i-1, b);
    if (tr[fa_a].fa == tr[fa_b].fa) return; // 已经在同一集合
    // 按深度合并：把深度小的嫁接到深度大的上
    if (tr[fa_a].dep > tr[fa_b].dep) swap(fa_a, fa_b);
    // 修改fa_a的父为fa_b的父（即fa_b自己）
    rt[i] = update_fa(rt[i-1], 1, n, tr[fa_a].fa, tr[fa_b].fa);
    // 如果深度相同，修改fa_b的深度+1
    if (tr[fa_a].dep == tr[fa_b].dep) {
        rt[i] = update_dep(rt[i], 1, n, tr[fa_b].fa);
    }
}

// 查询版本i-1中的a和b是否同根
bool query_same(int i, int a, int b) {
    rt[i] = rt[i-1]; // 复制旧版本
    int fa_a = find(i-1, a), fa_b = find(i-1, b);
    return tr[fa_a].fa == tr[fa_b].fa;
}

int main() {
    scanf("%d%d", &n, &m);
    rt[0] = build(1, n); // 初始版本0
    for (int i = 1; i <= m; i++) {
        int op, a, b;
        scanf("%d%d", &op, &a);
        if (op == 1) { // 合并a和b
            scanf("%d", &b);
            merge(i, a, b);
        } else if (op == 2) { // 回退到版本a
            rt[i] = rt[a];
        } else { // 查询a和b是否同根
            scanf("%d", &b);
            printf("%d\n", query_same(i, a, b) ? 1 : 0);
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. `build`函数建初始树，每个节点的父是自己，深度1；  
  2. `query`函数找某个版本中节点的主席树节点；  
  3. `find`函数递归找根（不用路径压缩）；  
  4. `update_fa`和`update_dep`函数修改父和深度，返回新版本根；  
  5. `merge`函数按深度合并，生成新版本；  
  6. `query_same`函数查询是否同根，复制旧版本。


<code_intro_selected>
  接下来剖析优质题解的核心片段，看它们的「巧妙之处」～
</code_intro_selected>

**题解一：hegm的merge函数**  
* **亮点**：明确处理「合并时的两个修改」（改父和改深度），避免覆盖旧版本。  
* **核心代码片段**：
```cpp
void merge(int now, int a, int b) {
    rt[now] = rt[now-1];
    a = find(now, a); b = find(now, b);
    if (tr[a].fa != tr[b].fa) {
        if (tr[a].dep > tr[b].dep) swap(a, b);
        rt[now] = hb(rt[now-1], 1, n, tr[a].fa, tr[b].fa); // 改父
        if (tr[a].dep == tr[b].dep) 
            rt[now] = add(rt[now], 1, n, tr[b].fa); // 改深度
    } 
}
```
* **代码解读**：  
  - `rt[now] = rt[now-1]`：先复制旧版本；  
  - `find`找两个根；  
  - 按深度合并，用`hb`函数改父（生成新版本A）；  
  - 若深度相同，用`add`函数改深度（基于版本A生成新版本B）。  
* 💡 **学习笔记**：合并时要「分两步修改」，每步都新建版本，不能偷懒！

**题解二：zj余能的DFS回溯**  
* **亮点**：用DFS处理版本树，回溯时撤销修改，不用写主席树。  
* **核心代码片段**：
```cpp
void DFS(int x) {
    tim[x] = T.top; // 记录当前栈顶，回溯时恢复
    if (ty[x] == 3) Ans[x] = (T.Seek(a[x]) == T.Seek(b[x])); // 查询
    if (ty[x] == 1) T.Merge(a[x], b[x]); // 合并（入栈）
    for (int i = las[x]; i; i = e[i].pre) DFS(e[i].to); // 处理子版本
    T.Turn_back(tim[x]); // 回溯：撤销到tim[x]时的栈顶
}
```
* **代码解读**：  
  - `tim[x]`记录进入x版本时的栈顶；  
  - 处理合并时，把操作入栈；  
  - 递归处理子版本后，用`Turn_back`撤销到进入前的状态。  
* 💡 **学习笔记**：离线处理的关键是「版本树的DFS遍历」，回溯等于回退版本。

**题解三：chenxinyang2006的按大小合并**  
* **亮点**：用两个主席树维护`fa`和`size`，合并时更新大小。  
* **核心代码片段**：
```cpp
void merge(int x, int y) {
    int a = find(x), b = find(y);
    if (a == b) return;
    int X = siz.query(siz.T[ti], 1, n, a), Y = siz.query(siz.T[ti], 1, n, b);
    if (X <= Y) { // 小的嫁接到大的上
        bin.T[ti] = bin.upload(bin.T[ti], 1, n, a, b); // 改fa[a]=b
        siz.T[ti] = siz.upload(siz.T[ti], 1, n, b, X + Y); // 改size[b] += X
    } else {
        bin.T[ti] = bin.upload(bin.T[ti], 1, n, b, a);
        siz.T[ti] = siz.upload(siz.T[ti], 1, n, a, X + Y);
    }
}
```
* **代码解读**：  
  - `find`找根；  
  - 查询两个根的大小；  
  - 小的嫁接到大的上，修改`fa`和`size`。  
* 💡 **学习笔记**：按大小合并的核心是「更新新根的大小」，保证树不会太长。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
  为了让你「看」到可持久化并查集的操作，我设计了一个「像素快照馆」动画，用FC风格的像素块展示每一步！
</visualization_intro>

### 🎮 动画演示主题：像素快照馆
**风格**：8位FC红白机风格，背景是浅灰色网格，节点是16x16的像素块，根节点是红色，子节点是父节点的浅色调（比如父是红色，子是粉色），深度用块的大小表示（深度1是16x16，深度2是20x20，最多到32x32）。

### 🕹️ 核心演示内容
1. **初始化（版本0）**：  
   - 屏幕显示5个红色像素块（n=5），分别标着1~5，每个块大小16x16（深度1）。  
   - 控制面板有「开始/暂停」「单步」「重置」按钮，速度滑块（1x~5x），还有「版本号」显示（当前是0）。

2. **操作1：合并1和2（版本1）**：  
   - 块1和块2闪烁（提示要合并）；  
   - 找到它们的根（都是自己），比较深度（都是1）；  
   - 块1的颜色变成浅红色（父是2），块2的大小变成20x20（深度2）；  
   - 播放「叮」的音效，版本号变成1。

3. **操作2：查询1和2（版本2）**：  
   - 块1和块2闪烁，然后块1的路径（1→2）逐个闪烁；  
   - 根都是2，屏幕右下角显示绿色对勾，播放「叮~」的音效；  
   - 版本号变成2。

4. **操作3：回退到版本0（版本3）**：  
   - 屏幕「咻」地一下回到初始化状态，所有块变回红色，大小16x16；  
   - 版本号变成0，播放「咻」的音效。

5. **操作4：查询1和2（版本4）**：  
   - 块1和2的路径都是自己，根不同，显示红色叉号，播放「嘟」的音效；  
   - 版本号变成4。

### 🎵 音效设计
- 合并操作：轻微的「叮」（频率440Hz）；  
- 回退操作：短促的「咻」（频率880Hz→220Hz下滑）；  
- 查询成功：上扬的「叮~」（440Hz→880Hz）；  
- 查询失败：短促的「嘟」（220Hz）；  
- 背景音乐：循环的8位风格BGM（用钢琴音色，节奏轻快）。

### 🎯 交互设计
- **单步执行**：点击「单步」按钮，动画走一步；  
- **自动播放**：拖动速度滑块调整速度（1x是每秒1步，5x是每秒5步）；  
- **重置动画**：点击「重置」回到版本0；  
- **版本跳转**：输入版本号，直接跳转到对应快照。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
  可持久化并查集的核心是「可持久化数据结构+按秩合并」，这套思路能解决很多带「版本回退」的问题～
</similar_problems_intro>

### 🔗 通用思路迁移
- 可持久化数组（比如维护每个版本的数组状态）；  
- 可持久化线段树（比如维护每个版本的区间最大值）；  
- 可持久化平衡树（比如维护每个版本的有序序列）。

### 📚 洛谷练习推荐
1. **洛谷 P3919** - 【模板】可持久化线段树 1（可持久化数组）  
   * 🗣️ **推荐理由**：可持久化的基础模板，帮你掌握「写时复制」的核心思想。  
2. **洛谷 P6166** - 【模板】可持久化并查集（加强版）  
   * 🗣️ **推荐理由**：本题的加强版，数据范围更大，练习按秩合并的细节。  
3. **洛谷 P5055** - 【模板】可持久化文艺平衡树  
   * 🗣️ **推荐理由**：可持久化平衡树的模板，巩固「可持久化结构」的写法。  
4. **洛谷 P4092** - 【模板】可持久化线段树 2（区间第k小）  
   * 🗣️ **推荐理由**：可持久化线段树的应用，练习维护区间信息的版本。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
  优质题解里的「踩坑经验」比代码更宝贵，我们一起看看～
</insights_intro>

> **参考经验（来自hegm）**：「我一开始合并时只改了fa，没改dep，结果得了88分。后来才发现，改dep也要新建版本，否则旧版本的dep会被覆盖！」  
> **点评**：这个坑很典型！合并时要改两个信息（fa和dep），每改一个都要新建版本，不能偷懒。  
> **参考经验（来自zj余能）**：「离线做法的关键是把版本建成树，DFS回溯就能回退，不用写复杂的主席树！」  
> **点评**：离线处理是「曲线救国」的好方法，如果题目允许离线，优先选这种思路，代码更简单。  


<conclusion>
  本次关于「可持久化并查集」的分析就到这里啦！记住：可持久化的核心是「写时复制」，按秩合并是「保证复杂度的关键」。多动手写代码，多画动画模拟，你一定能掌握这套思路！下次我们再一起探索更有趣的可持久化问题～💪
</conclusion>

---

---
处理用时：164.27秒
# 题目信息

# 【模板】可持久化平衡树

## 题目背景

本题为题目 **普通平衡树** 的可持久化加强版。

**数据已经经过强化**

**感谢@Kelin 提供的一组hack数据**


## 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ **对于各个以往的历史版本** ）：


1、 插入 $x$

2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）


3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）


4、查询排名为 $x$ 的数


5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）


6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）


**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**

每个版本的编号即为操作的序号（版本0即为初始状态，空树）


## 说明/提示

【数据范围】   
对于 $28\%$ 的数据，$ 1 \leq n \leq 10 $；   
对于 $44\%$ 的数据，$ 1 \leq n \leq 2\times {10}^2 $；   
对于 $60\%$ 的数据， $ 1 \leq n \leq 3\times {10}^3 $；   
对于 $84\%$ 的数据， $ 1 \leq n \leq {10}^5 $；   
对于 $92\%$ 的数据， $ 1 \leq n \leq 2\times {10}^5 $；   
对于 $100\%$ 的数据， $ 1 \leq n \leq 5 \times  10^5 $ , $|x_i| \leq {10}^9$，$0 \le v_i < i$，$1\le \text{opt} \le 6$。

**经实测，正常常数的可持久化平衡树均可通过，请各位放心**



样例说明：

共 $10$ 次操作，$11$ 个版本，各版本的状况依次是：

0.  $[]$

1.  $[9]$

2.  $[3, 9]$

3.  $[9, 10]$

4.  $[3, 9]$

5.  $[9, 10]$

6.  $[2, 9, 10]$

7.  $[2, 9, 10]$

8.  $[2, 10]$

9.  $[2, 10]$

10.  $[3, 9]$


## 样例 #1

### 输入

```
10
0 1 9
1 1 3
1 1 10
2 4 2
3 3 9
3 1 2
6 4 1
6 2 9
8 6 3
4 5 8```

### 输出

```
9
1
2
10
3```

# AI分析结果

# 💡 Kay的C++算法解析：可持久化平衡树 深入学习指南 💡

## 引言
今天我们要攻克的是**可持久化平衡树**——这是普通平衡树的“时光机”版本！它不仅能完成插入、删除、查排名等常规操作，还能保留每一步操作后的历史版本，让我们随时“回到过去”查看任意时刻的集合状态。是不是很像游戏里的“存档”功能？接下来，我们一起拆解它的核心逻辑，学会如何用代码实现这个“时光机”～


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：可持久化平衡树（FHQ-Treap/主席树）

### 🗣️ 初步分析
可持久化平衡树的核心是**“路径复制”**——每次修改（插入/删除）时，只复制被修改的路径上的节点，而不是整个树。这样既能保留历史版本，又能保证时间/空间复杂度是O(log n)（和普通平衡树一样高效）。

#### 为什么选FHQ-Treap？
普通平衡树（如AVL、红黑树）需要旋转操作，会修改多个节点的父子关系，很难实现可持久化。而**FHQ-Treap（无旋Treap）**用两个核心操作——**分裂（Split）**和**合并（Merge）**——完成所有功能，不需要旋转，路径修改更局部，天生适合可持久化！

- **分裂（Split）**：把一棵树按某个值分成两部分（左树≤该值，右树>该值）。
- **合并（Merge）**：把两棵树按堆的优先级合并（保证树的平衡性）。

#### 其他思路对比
除了FHQ-Treap，还有两种常见实现：
1. **主席树（可持久化权值线段树）**：用权值线段树模拟平衡树操作，适合处理值域大的情况（需要离散化）。
2. **AVL树**：通过旋转维护平衡，但可持久化时需要复制更多节点，代码更复杂。


## 2. 精选优质题解参考

我从思路清晰度、代码可读性、实践价值等角度，筛选了3份**4.5星+**的优质题解：

### 题解一：Chen_Borui的FHQ-Treap（赞：5）
- **亮点**：用数组实现FHQ-Treap，代码简洁（不到150行），讲解详细（拆分了Split/Merge的逻辑，配了示意图）。
- **思路**：通过Split将树按值分成两部分，插入时合并新节点；删除时拆分出要删的节点，合并剩余部分。可持久化通过**复制路径节点**实现（每次Split/Merge时新建节点，继承原节点信息）。
- **实践价值**：代码直接对应FHQ-Treap的核心逻辑，适合新手入门可持久化平衡树。

### 题解二：xuanfeng101的数组版FHQ-Treap（赞：2）
- **亮点**：代码结构更清晰，用`clone`函数统一复制节点，操作逻辑更直观（比如删除时拆分三次，合并子树）。
- **思路**：继承FHQ-Treap的Split/Merge，用`clone`函数复制需要修改的节点，保证历史版本不被破坏。
- **实践价值**：变量命名规范（如`tr[u].v`存值，`tr[u].k`存堆优先级），适合学习数组实现的细节。

### 题解三：lw393的主席树（赞：1）
- **亮点**：用权值线段树（主席树）模拟平衡树操作，思路新颖，避开了平衡树的复杂实现。
- **思路**：将每个数映射到值域上，用主席树维护每个版本的数的个数。查排名、第k大、前驱后继都通过线段树二分实现。
- **实践价值**：适合理解“权值线段树替代平衡树”的思路，尤其适合值域大的场景。


## 3. 核心难点辨析与解题策略

### 🔑 核心难点1：可持久化的路径复制
- **问题**：如何修改树而不影响历史版本？
- **解决**：每次修改（Split/Merge/插入/删除）时，**只复制路径上的节点**。比如Split时，遇到需要修改的节点（如左/右子树变化），就新建一个节点，复制原节点的信息，再修改新节点的子树。
- 💡 学习笔记：可持久化的关键是“不修改旧节点，只新建新节点”。

### 🔑 核心难点2：FHQ-Treap的Split/Merge逻辑
- **问题**：如何正确分裂和合并树？
- **解决**：
  1. **Split**：按值分裂时，若当前节点值≤目标值，将左树全部保留，递归分裂右树；否则递归分裂左树。
  2. **Merge**：按堆优先级合并（优先级高的节点当根），递归合并子树。
- 💡 学习笔记：Split是“分”，Merge是“合”，两者是FHQ-Treap的基石。

### 🔑 核心难点3：前驱后继的查询
- **问题**：如何快速找到小于x的最大数（前驱）和大于x的最小数（后继）？
- **解决**：
  1. **前驱**：查询x的排名-1对应的数（即比x小的最后一个数）。
  2. **后继**：查询x+1的排名对应的数（即比x大的第一个数）。
- 💡 学习笔记：前驱后继可以通过“排名”和“第k大”操作间接实现，不用单独写复杂逻辑。


## 4. C++核心代码实现赏析

### 4.1 本题通用核心C++实现参考（FHQ-Treap）
- **说明**：综合Chen_Borui和xuanfeng101的代码，提炼的数组版FHQ-Treap实现，包含所有核心操作。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10, INF = (1 << 31) - 1;
mt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());

int rt[N], idx; // rt[i]是第i版本的根节点
struct Node { int l, r, v, k, sz; } tr[N]; // l左子，r右子，v值，k堆优先级，sz子树大小

// 更新子树大小
void pushup(int u) { tr[u].sz = tr[tr[u].l].sz + tr[tr[u].r].sz + 1; }

// 复制节点（可持久化核心）
int clone(int x) { tr[++idx] = tr[x]; return idx; }

// 按值分裂：将u分成x（≤v）和y（>v）
void split(int u, int v, int& x, int& y) {
    if (!u) { x = y = 0; return; }
    if (tr[u].v <= v) {
        x = clone(u); // 复制当前节点
        split(tr[x].r, v, tr[x].r, y); // 递归分裂右子树
        pushup(x);
    } else {
        y = clone(u); // 复制当前节点
        split(tr[y].l, v, x, tr[y].l); // 递归分裂左子树
        pushup(y);
    }
}

// 合并：按堆优先级合并x和y（x的所有值≤y的所有值）
int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (tr[x].k <= tr[y].k) {
        x = clone(x); // 复制当前节点
        tr[x].r = merge(tr[x].r, y); // 递归合并右子树
        pushup(x);
        return x;
    } else {
        y = clone(y); // 复制当前节点
        tr[y].l = merge(x, tr[y].l); // 递归合并左子树
        pushup(y);
        return y;
    }
}

// 插入值v到版本pre，返回新版本根
int insert(int pre, int v) {
    int p = ++idx; tr[p] = {0, 0, v, (int)rnd(), 1};
    int x, y; split(rt[pre], v, x, y);
    return merge(merge(x, p), y);
}

// 删除值v从版本pre，返回新版本根
int del(int pre, int v) {
    int x, y, z;
    split(rt[pre], v, x, y);    // x≤v，y>v
    split(x, v-1, x, z);        // x≤v-1，z=v
    if (z) z = merge(tr[z].l, tr[z].r); // 合并z的子树（删除z）
    return merge(merge(x, z), y);
}

// 查询v在版本pre中的排名（比v小的数+1）
int get_rank(int pre, int v) {
    int x, y; split(rt[pre], v-1, x, y);
    int res = tr[x].sz + 1;
    merge(x, y); // 合并回去，不影响原树
    return res;
}

// 查询版本pre中的第k大的数
int kth(int u, int k) {
    if (tr[tr[u].l].sz >= k) return kth(tr[u].l, k);
    else if (tr[tr[u].l].sz + 1 == k) return tr[u].v;
    return kth(tr[u].r, k - tr[tr[u].l].sz - 1);
}

// 查询v在版本pre中的前驱（小于v的最大数）
int get_pre(int pre, int v) {
    int x, y; split(rt[pre], v-1, x, y);
    int res = (x ? kth(x, tr[x].sz) : -INF);
    merge(x, y);
    return res;
}

// 查询v在版本pre中的后继（大于v的最小数）
int get_suc(int pre, int v) {
    int x, y; split(rt[pre], v, x, y);
    int res = (y ? kth(y, 1) : INF);
    merge(x, y);
    return res;
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    int n; cin >> n;
    for (int i = 1; i <= n; ++i) {
        int pre, op, v; cin >> pre >> op >> v;
        rt[i] = rt[pre]; // 继承历史版本
        if (op == 1) rt[i] = insert(pre, v);
        else if (op == 2) rt[i] = del(pre, v);
        else if (op == 3) cout << get_rank(pre, v) << '\n';
        else if (op == 4) cout << kth(rt[pre], v) << '\n';
        else if (op == 5) cout << get_pre(pre, v) << '\n';
        else cout << get_suc(pre, v) << '\n';
    }
    return 0;
}
```
- **代码解读概要**：
  1. **节点结构**：用数组存储节点，包含左/右子节点、值、堆优先级、子树大小。
  2. **核心操作**：`split`按值分裂，`merge`按堆合并，`clone`复制节点（可持久化关键）。
  3. **业务操作**：插入（分裂后合并新节点）、删除（分裂出目标节点后合并剩余部分）、查排名（分裂后统计左子树大小）、查第k大（递归查找）、前驱后继（通过分裂和kth实现）。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：FHQ-Treap的“时光分裂与合并”
我们用**8位像素风**（类似FC游戏）展示可持久化平衡树的操作，让你“看”到每个版本的变化！

### 🎨 设计思路
- **风格**：用像素方块代表节点（不同颜色表示不同版本），网格背景模拟树结构，复古音效提示操作（如“叮”表示分裂，“嗡”表示合并）。
- **核心演示**：
  1. **初始状态**：版本0是空树（黑色背景，无节点）。
  2. **插入操作**：插入值`9`到版本0，生成版本1。展示Split分裂空树，合并新节点（绿色像素块），路径上的节点复制（浅绿像素块）。
  3. **分裂操作**：将版本1的树按值`3`分裂，展示左树（≤3，空）和右树（>3，`9`），分裂路径上的节点复制（黄色像素块）。
  4. **合并操作**：合并左树和右树，展示按堆优先级合并（优先级高的节点在上），合并路径上的节点复制（蓝色像素块）。
- **交互设计**：
  - 控制面板：单步执行、自动播放（速度滑块）、重置。
  - 版本切换：点击版本号（如1、2、3），展示对应版本的树结构。
  - 音效：分裂（短“叮”）、合并（长“嗡”）、插入（“滴”）、删除（“啪”）。

### 📸 关键帧示例
1. **插入9（版本0→1）**：
   - 屏幕左侧显示“版本0：空树”，右侧显示“操作1：插入9”。
   - 新建绿色节点（值9，优先级随机），合并到空树，生成版本1的根节点（浅绿像素块）。
   - 音效：“滴”一声，版本1的树结构（绿色节点）显示在屏幕中央。
2. **分裂版本1的树（按值3）**：
   - 点击“单步执行”，版本1的树分裂为左树（空）和右树（9）。
   - 分裂路径上的节点复制（黄色像素块），左树显示在左侧，右树显示在右侧。
   - 音效：“叮”一声，提示分裂完成。


## 6. 拓展练习与相似问题思考

### 🚀 通用思路迁移
可持久化平衡树的思路可以迁移到：
1. **可持久化数组**：用FHQ-Treap维护数组，支持历史版本查询。
2. **可持久化线段树**（主席树）：处理区间第k大、区间和等问题。
3. **可持久化并查集**：记录每个版本的集合合并状态。

### 📚 洛谷练习推荐
1. **P3369 【模板】普通平衡树**：先掌握普通平衡树的操作，再进阶可持久化。
2. **P3834 【模板】可持久化线段树 1（主席树）**：学习权值线段树的可持久化，理解“版本继承”的思想。
3. **P5055 【模板】可持久化文艺平衡树**：FHQ-Treap的进阶应用，支持区间反转操作。
4. **P4065 [JXOI2017]颜色**：可持久化平衡树的实际应用，处理颜色出现次数的历史版本查询。


## 7. 学习心得与经验分享
- **来自Chen_Borui的经验**：“FHQ-Treap的可持久化关键是复制节点，不要怕代码长，拆分成Split和Merge两个函数就简单了！”
- **点评**：复制节点是可持久化的核心，只要保证每次修改都新建节点，历史版本就不会被破坏。新手可以先写普通FHQ-Treap，再添加`clone`函数实现可持久化。


## 结语
可持久化平衡树的核心是“路径复制”，而FHQ-Treap的无旋特性让它成为实现可持久化的最佳选择。通过今天的学习，你已经掌握了“时光机”的秘密——下次遇到需要保留历史版本的问题，记得用可持久化平衡树哦！

编程的乐趣在于“创造工具解决问题”，继续加油吧～ 💪

---
处理用时：127.43秒
# 题目信息

# [NOI2018] 归程

## 题目描述

本题的故事发生在魔力之都，在这里我们将为你介绍一些必要的设定。

魔力之都可以抽象成一个 $n$ 个节点、$m$ 条边的无向连通图（节点的编号从 $1$ 至 $n$）。我们依次用 $l,a$ 描述一条边的**长度、海拔**。

作为季风气候的代表城市，魔力之都时常有雨水相伴，因此道路积水总是不可避免的。由于整个城市的排水系统连通，因此**有积水的边一定是海拔相对最低的一些边**。我们用**水位线**来描述降雨的程度，它的意义是：所有海拔**不超过**水位线的边都是**有积水**的。

Yazid 是一名来自魔力之都的 OIer，刚参加完 ION2018 的他将踏上归程，回到他温暖的家。Yazid 的家恰好在魔力之都的 $1$ 号节点。对于接下来 $Q$ 天，每一天 Yazid 都会告诉你他的出发点 $v$ ，以及当天的水位线 $p$。

每一天，Yazid 在出发点都拥有一辆车。这辆车由于一些故障不能经过有积水的边。Yazid 可以在任意节点下车，这样接下来他就可以步行经过有积水的边。但车会被留在他下车的节点并不会再被使用。
需要特殊说明的是，第二天车会被重置，这意味着：
- 车会在新的出发点被准备好。
- Yazid 不能利用之前在某处停放的车。

Yazid 非常讨厌在雨天步行，因此他希望在完成回家这一目标的同时，最小化他**步行经过的边**的总长度。请你帮助 Yazid 进行计算。

本题的部分测试点将强制在线，具体细节请见【输入格式】和【子任务】。

## 说明/提示

### 更多样例

更多样例请在附加文件中下载。

#### 样例 3

见附加文件中的 `return3.in` 与 `return3.ans`。

该样例满足海拔为一种，且不强制在线。

#### 样例 4

见附加文件中的 `return4.in` 与 `return4.ans`。

该样例满足图形态为一条链，且强制在线。

#### 样例 5

见附加文件中的 `return5.in` 与 `return5.ans`。

该样例满足不强制在线。

### 样例 1 解释

第一天没有降水，Yazid 可以坐车直接回到家中。

第二天、第三天、第四天的积水情况相同，均为连接 1，2 号节点的边、连接 3，4 号点的边有积水。

对于第二天，Yazid 从 2 号点出发坐车只能去往 3 号节点，对回家没有帮助。因此 Yazid 只能纯靠徒步回家。

对于第三天，从 4 号节点出发的唯一一条边是有积水的，车也就变得无用了。Yazid 只能纯靠徒步回家。

对于第四天，Yazid 可以坐车先到达 2 号节点，再步行回家。

第五天所有的边都积水了，因此 Yazid 只能纯靠徒步回家。

### 样例 2 解释

本组数据强制在线。

第一天的答案是 $0$，因此第二天的 $v=\left( 5+0-1\right)\bmod 5+1=5$，$p=\left(2+0\right)\bmod\left(3+1\right)=2$。

第二天的答案是 $2$，因此第三天的 $v=\left( 2+2-1\right)\bmod 5+1=4$，$p=\left(0+2\right)\bmod\left(3+1\right)=2$。

第三天的答案是 $3$，因此第四天的 $v=\left( 4+3-1\right)\bmod 5+1=2$，$p=\left(0+3\right)\bmod\left(3+1\right)=3$。

### 数据范围与约定

所有测试点均保证 $T\leq 3$，所有测试点中的所有数据均满足如下限制：

- $n\leq 2\times 10^5$，$m\leq 4\times 10^5$，$Q\leq 4\times 10^5$，$K\in\left\{0,1\right\}$，$1\leq S\leq 10^9$。
- 对于所有边：$l\leq 10^4$，$a\leq 10^9$。
- 任意两点之间都直接或间接通过边相连。

**为了方便你快速理解，我们在表格中使用了一些简单易懂的表述。在此，我们对这些内容作形式化的说明：**

- 图形态：对于表格中该项为 “一棵树” 或 “一条链” 的测试点，保证 $m = n-1$。除此之外，这两类测试点分别满足如下限制：
  - 一棵树：保证输入的图是一棵树，即保证边不会构成回路。
  - 一条链：保证所有边满足 $u + 1 = v$。
- 海拔：对于表格中该项为 “一种” 的测试点，保证对于所有边有 $a = 1$。
- 强制在线：对于表格中该项为 “是” 的测试点，保证 $K = 1$；如果该项为 “否”，则有 $K = 0$。
- 对于所有测试点，如果上述对应项为 “不保证”，则对该项内容不作任何保证。

$n$|$m$|$Q=$|测试点|形态|海拔|强制在线
-|-|-|-|-|-|-
$\leq 1$|$\leq 0$|$0$|1|不保证|一种|否
$\leq 6$|$\leq 10$|$10$|2|不保证|一种|否
$\leq 50$|$\leq 150$|$100$|3|不保证|一种|否
$\leq 100$|$\leq 300$|$200$|4|不保证|一种|否
$\leq 1500$|$\leq 4000$|$2000$|5|不保证|一种|否
$\leq 200000$|$\leq 400000$|$100000$|6|不保证|一种|否
$\leq 1500$|$=n-1$|$2000$|7|一条链|不保证|否
$\leq 1500$|$=n-1$|$2000$|8|一条链|不保证|否
$\leq 1500$|$=n-1$|$2000$|9|一条链|不保证|否
$\leq 200000$|$=n-1$|$100000$|10|一棵树|不保证|否
$\leq 200000$|$=n-1$|$100000$|11|一棵树|不保证|是
$\leq 200000$|$\leq 400000$|$100000$|12|不保证|不保证|否
$\leq 200000$|$\leq 400000$|$100000$|13|不保证|不保证|否
$\leq 200000$|$\leq 400000$|$100000$|14|不保证|不保证|否
$\leq 1500$|$\leq 4000$|$2000$|15|不保证|不保证|是
$\leq 1500$|$\leq 4000$|$2000$|16|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$100000$|17|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$100000$|18|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$400000$|19|不保证|不保证|是
$\leq 200000$|$\leq 400000$|$400000$|20|不保证|不保证|是


## 样例 #1

### 输入

```
1
4 3
1 2 50 1
2 3 100 2
3 4 50 1
5 0 2
3 0
2 1
4 1
3 1
3 2```

### 输出

```
0
50
200
50
150```

## 样例 #2

### 输入

```
1
5 5
1 2 1 2
2 3 1 2
4 3 1 2
5 3 1 2
1 5 2 1
4 1 3
5 1
5 2
2 0
4 0```

### 输出

```
0
2
3
1```

# AI分析结果

# 💡 Kay的C++算法解析：[NOI2018] 归程 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：Kruskal重构树 + 单源最短路径 + 树上倍增

🗣️ **初步分析**：  
解决“归程”问题，关键在于**用Kruskal重构树快速找到“能开车到达的最大区域”**，再结合最短路求出该区域内到1号点的最小步行距离。  

简单来说，Kruskal重构树就像“搭积木”：我们把所有边按**海拔从高到低**排序（优先连高海拔的边，因为这些边不会被积水淹没），每连接两个连通块时，新建一个“父节点”代表这条边，父节点的海拔就是边的海拔。这样搭出来的树有个神奇性质——**某个节点的子树里的所有点，都能通过“海拔高于父节点”的边互相到达**（因为父节点是子树里海拔最低的边）。  

在本题中，我们需要：  
1. 用Dijkstra预处理**所有点到1号点的步行最短距离**（因为下车后只能步行，这一步是基础）；  
2. 建Kruskal重构树，把“能开车到达的区域”转化为树的子树；  
3. 对于每个询问（起点v，水位p），用**树上倍增**找到v的“最高祖先”（该祖先的海拔>p，意味着其下的子树都是能开车到达的区域）；  
4. 该子树内的最小步行距离就是答案（因为要找“下车后步行最短”的点）。  

**可视化设计思路**：  
我们用8位FC像素风格展示算法流程——  
- 节点是彩色方块（1号红、起点蓝、新建节点黄），边是灰色线条；  
- 建重构树时，高海拔边先“点亮”，新建节点闪烁并连接两个块；  
- 查询时，蓝色起点“跳”向祖先（每跳一步黄色节点闪烁），找到目标子树后，子树内节点变绿，显示最小步行距离；  
- 配上音效：连边“叮”、跳步“嗒”、找到答案“滴”，胜利时播放8位风格的“通关音乐”。


## 2. 精选优质题解参考

### 题解一：作者ldxcaicai（赞157）  
* **点评**：  
  这份题解是Kruskal重构树的“标准教程”——思路清晰到每一步都能对应代码！作者先讲透重构树的4个核心性质（比如子树连通、LCA是瓶颈），再一步步推导解题步骤：Dijkstra预处理→建重构树→DFS求子树最小值→倍增查询。代码风格非常规范，变量名（如`d`存最短距离、`p`存子树最小值）一看就懂，边界处理（比如`cnt`从n开始建虚节点）也很严谨。特别适合新手入门，能快速把“理论”变成“可运行的代码”。


### 题解二：作者niiick（赞47）  
* **点评**：  
  作者的“学习笔记”链接是亮点！他用“断点枚举”的思路引入重构树——我们要找“能开车到的最远点u”，而重构树刚好把“能开车的区域”打包成子树。代码里的`dfs`函数简洁高效，直接在遍历树时求子树最小值；倍增部分的循环（从22到0）也很直观，完美对应“跳着找祖先”的逻辑。作者还提到“比赛时调了一天”，提醒我们**写代码要注意细节（比如数组大小）**，非常真实！


### 题解三：作者Siyuan（赞21）  
* **点评**：  
  这份题解的“博客补充”很贴心！作者明确指出“能用重构树是因为最大生成树的性质”——开车的路径一定在最大生成树上（因为要优先走高海拔边）。代码里的`exKruskal`函数（扩展Kruskal）把建重构树的过程写得很紧凑，`dis[idx] = min(dis[fu], dis[fv])`直接在合并时维护子树最小值，避免了额外的DFS，是优化代码的好思路。实践价值很高，适合想“精简代码”的学习者。


## 3. 核心难点辨析与解题策略

### 1. 关键点1：理解Kruskal重构树的“子树连通性”  
- **难点**：为什么重构树的子树里的点能通过高海拔边互相到达？  
- **分析**：因为我们按海拔**降序**加边，新建的父节点海拔是当前边的海拔（子树里最低的边）。比如父节点A的海拔是100，那么子树里的所有边海拔都≥100——只要水位p<100，这些边都不会积水，所以子树里的点能开车互相到达。  
- 💡 **学习笔记**：重构树的“父节点海拔”是子树的“水位门槛”，低于这个门槛就能连通。


### 2. 关键点2：用倍增快速找“符合条件的祖先”  
- **难点**：如何快速找到v的“最高祖先”（海拔>p）？  
- **分析**：树上倍增是“跳步找祖先”的神器——我们预处理每个节点的2^k级祖先（比如`f[v][0]`是父节点，`f[v][1]`是祖父节点），然后从最大的k（比如20）开始尝试跳：如果跳后的祖先海拔>p，就跳过去；否则试更小的k。这样最多跳20次就能找到目标祖先。  
- 💡 **学习笔记**：倍增的核心是“预处理+快速跳转”，适合树上的“找祖先”问题。


### 3. 关键点3：维护子树内的最小步行距离  
- **难点**：如何快速知道“能开车到达的区域”内到1号点的最小步行距离？  
- **分析**：我们可以用DFS遍历重构树，**自底向上**计算每个节点的子树最小值——叶子节点的最小值是自己的步行距离，非叶子节点的最小值是左右子树的最小值的较小者。这样查询时，只要找到目标祖先，直接取它的子树最小值即可。  
- 💡 **学习笔记**：树形DP（DFS遍历）是维护子树信息的常用方法。


### ✨ 解题技巧总结  
- **技巧A**：先预处理最短路——所有“步行”相关的问题，都可以先算好最短距离，避免重复计算；  
- **技巧B**：用重构树“打包”连通区域——把“动态的边选择”转化为“静态的树结构”，简化查询；  
- **技巧C**：倍增优化查询——把O(n)的找祖先变成O(logn)，应对大数据量。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合优质题解的思路，整理出最清晰的核心实现（包含Dijkstra、Kruskal重构树、倍增查询）。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <algorithm>
#include <cstring>
using namespace std;

typedef long long ll;
const int N = 400010, M = 800010, LOG = 20;
const ll INF = 1e18;

// 图的边（用于Dijkstra）
struct Edge { int to, next; ll w; } e[M];
int head[N], cnt_e;
// Kruskal的边（用于建重构树）
struct KruskalEdge { int u, v; ll h; } ke[M];
// 重构树的边（树结构）
struct TreeEdge { int to, next; } te[M];
int thead[N], cnt_te;

ll dis[N]; // 1号点到各点的最短距离
int fa[N]; // 并查集（建重构树用）
ll val[N]; // 重构树节点的海拔（虚节点）
ll min_dis[N]; // 重构树节点的子树最小dis
int f[N][LOG]; // 倍增数组：f[u][k]是u的2^k级祖先

// 并查集找根
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

// 添加图的边（Dijkstra用）
void add_edge(int u, int v, ll w) {
    e[++cnt_e] = {v, head[u], w};
    head[u] = cnt_e;
    e[++cnt_e] = {u, head[v], w};
    head[v] = cnt_e;
}

// 添加重构树的边
void add_tree_edge(int u, int v) {
    te[++cnt_te] = {v, thead[u]};
    thead[u] = cnt_te;
    te[++cnt_te] = {u, thead[v]};
    thead[v] = cnt_te;
}

// Dijkstra预处理最短距离
void dijkstra(int n) {
    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;
    memset(dis, 0x3f, sizeof(dis));
    dis[1] = 0;
    q.push({0, 1});
    while (!q.empty()) {
        auto [d, u] = q.top(); q.pop();
        if (d > dis[u]) continue;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            if (dis[v] > dis[u] + e[i].w) {
                dis[v] = dis[u] + e[i].w;
                q.push({dis[v], v});
            }
        }
    }
}

// DFS遍历重构树，计算min_dis
void dfs(int u, int parent) {
    f[u][0] = parent;
    // 叶子节点（原节点）的min_dis是自己的dis
    if (u <= n) min_dis[u] = dis[u];
    else min_dis[u] = INF;
    // 遍历子节点，更新min_dis
    for (int i = thead[u]; i; i = te[i].next) {
        int v = te[i].to;
        if (v == parent) continue;
        dfs(v, u);
        min_dis[u] = min(min_dis[u], min_dis[v]);
    }
}

// 建Kruskal重构树
int build_kruskal_tree(int n, int m) {
    // 初始化并查集
    for (int i = 1; i <= 2 * n; ++i) fa[i] = i;
    // 按海拔降序排序边
    sort(ke + 1, ke + 1 + m, [](KruskalEdge a, KruskalEdge b) { return a.h > b.h; });
    int tot = n; // 虚节点从n+1开始
    for (int i = 1; i <= m; ++i) {
        int u = ke[i].u, v = ke[i].v;
        ll h = ke[i].h;
        int fu = find(u), fv = find(v);
        if (fu != fv) {
            tot++;
            val[tot] = h; // 虚节点的海拔是当前边的海拔
            fa[fu] = tot;
            fa[fv] = tot;
            add_tree_edge(tot, fu);
            add_tree_edge(tot, fv);
        }
    }
    // 预处理倍增数组
    dfs(tot, 0);
    for (int k = 1; k < LOG; ++k) {
        for (int u = 1; u <= tot; ++u) {
            f[u][k] = f[f[u][k-1]][k-1];
        }
    }
    return tot; // 返回重构树的根节点
}

// 查询：v是起点，p是水位
ll query(int v, ll p, int tot) {
    // 倍增找最高祖先（海拔>p）
    for (int k = LOG - 1; k >= 0; --k) {
        if (f[v][k] && val[f[v][k]] > p) {
            v = f[v][k];
        }
    }
    return min_dis[v];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T;
    cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        memset(head, 0, sizeof(head));
        memset(thead, 0, sizeof(thead));
        cnt_e = cnt_te = 0;
        for (int i = 1; i <= m; ++i) {
            int u, v; ll l, h;
            cin >> u >> v >> l >> h;
            add_edge(u, v, l);
            ke[i] = {u, v, h};
        }
        // 1. 预处理最短距离
        dijkstra(n);
        // 2. 建Kruskal重构树
        int root = build_kruskal_tree(n, m);
        // 3. 处理查询
        int Q, K, S;
        cin >> Q >> K >> S;
        ll last_ans = 0;
        while (Q--) {
            int v; ll p;
            cin >> v >> p;
            // 强制在线处理
            v = (v + K * last_ans - 1) % n + 1;
            p = (p + K * last_ans) % (S + 1);
            last_ans = query(v, p, root);
            cout << last_ans << '\n';
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  代码分四部分：  
  1. **Dijkstra**：计算1号点到所有点的步行最短距离；  
  2. **Kruskal重构树**：按海拔降序加边，建虚节点连接连通块，形成树结构；  
  3. **DFS**：遍历重构树，计算每个节点的子树最小步行距离；  
  4. **倍增查询**：对于每个询问，跳找符合条件的祖先，返回子树最小值。


### 针对各优质题解的片段赏析

#### 题解一（ldxcaicai）：Kruskal建树片段  
* **亮点**：清晰展示虚节点的创建过程，变量名直观。  
* **核心代码片段**：  
```cpp
inline void kruskal(){
    int tot=0,cnt=n;
    for(int i=1;i<=(n<<1);++i)fa[i]=i;
    sort(e+1,e+m+1,cmp);
    for(int i=1;i<=m;++i){
        int u=e[i].u,v=e[i].v;
        int fx=find(u),fy=find(v);
        if(fx!=fy){
            add(++cnt,fx);
            add(cnt,fy);
            fa[fx]=cnt;
            fa[fy]=cnt;
            p[cnt].a=e[i].a; // p[cnt]存虚节点的海拔
            ++tot;
        }
        if(tot==n-1)break;
    }
    dfs(cnt,0);
}
```
* **代码解读**：  
  - `cnt`从n开始，每合并两个连通块就`cnt++`（创建虚节点）；  
  - `add(++cnt, fx)`把虚节点和原连通块的根连接；  
  - `p[cnt].a`存虚节点的海拔（即当前边的海拔）。  
* 💡 **学习笔记**：虚节点是重构树的关键，它把“边”转化为“点”，从而用树结构管理连通性。


#### 题解二（niiick）：DFS求子树最小值片段  
* **亮点**：自底向上计算子树最小值，逻辑直接。  
* **核心代码片段**：  
```cpp
void dfs(int u) {
    mi[u] = d[u]; // d[u]是u的步行距离
    for(int i=head[u];i;i=E[i].nxt){
        int v=E[i].v;
        gra[v][0]=u; // 倍增数组的父节点
        dfs(v);
        mi[u]=min(mi[u],mi[v]); // 子树最小值取较小者
    }
}
```
* **代码解读**：  
  - 叶子节点（原节点）的`mi[u]`是自己的步行距离`d[u]`；  
  - 递归遍历子节点后，`mi[u]`更新为自己和子节点`mi[v]`的较小者。  
* 💡 **学习笔记**：树形DP的“后序遍历”（先处理子节点，再处理父节点）是维护子树信息的常用方式。


#### 题解三（Siyuan）：倍增查询片段  
* **亮点**：紧凑的倍增循环，直接对应“跳步找祖先”的逻辑。  
* **核心代码片段**：  
```cpp
int query(int u,int p) {
    for(int i=19;~i;--i) if(f[u][i]&&hei[f[u][i]]>p) u=f[u][i];
    return dis[u];
}
```
* **代码解读**：  
  - `i`从19到0（覆盖2^19≈5e5，足够处理n=2e5的情况）；  
  - 如果`f[u][i]`存在且海拔>p，就跳转到`f[u][i]`（即u的2^i级祖先）。  
* 💡 **学习笔记**：倍增的循环顺序是“从大到小”，这样能保证找到“最高的符合条件的祖先”。


## 5. 算法可视化：像素动画演示  

### 动画演示主题：《像素探险家的归程》  
（仿FC红白机风格，用8位像素块展示算法流程，结合游戏化元素）


### 设计思路  
用“探险家开车找安全区，然后步行回家”的游戏剧情，把算法步骤转化为游戏操作：  
- **像素风格**：用16色调色板（红、蓝、黄、绿、灰），节点是3x3像素块，边是1像素线条；  
- **游戏化交互**：支持“单步执行”“自动播放”（速度滑块），“重置”按钮；  
- **音效**：连边“叮”、跳步“嗒”、找到安全区“滴”、胜利“通关音乐”（8位MIDI）。


### 动画帧步骤  
1. **场景初始化**：  
   - 屏幕左侧是“地图区”（像素化的图，1号点红、其他点灰）；  
   - 右侧是“控制面板”（按钮+速度滑块+当前步骤提示）；  
   - 播放8位风格的背景音乐（循环的“冒险曲”）。

2. **Dijkstra预处理**：  
   - 红色1号点“发光”，然后向周围扩散蓝色波纹（代表计算最短距离）；  
   - 每个节点被波纹覆盖后，显示其到1号点的步行距离（比如节点2显示“50”）。

3. **Kruskal建重构树**：  
   - 所有边按海拔降序排列，高海拔边先变亮（从灰变蓝）；  
   - 每合并两个连通块，新建黄色虚节点，闪烁3次，然后连接两个块（黄色线条）；  
   - 虚节点显示其海拔（比如“100”）。

4. **DFS求子树最小值**：  
   - 从重构树的根节点（最大的虚节点）开始，绿色波纹向下遍历子节点；  
   - 每个节点被波纹覆盖后，显示其子树最小步行距离（比如虚节点显示“50”）。

5. **查询演示**：  
   - 输入起点v（变蓝）和水位p（显示在控制面板）；  
   - 蓝色节点“跳”向祖先（每跳一步，目标祖先闪烁黄色）；  
   - 找到目标子树后，子树内所有节点变绿，显示“安全区”，然后绿色波纹从子树流向1号点（代表步行路径）；  
   - 屏幕中央显示答案（比如“50”），播放“滴”的音效。


### 交互设计  
- **单步执行**：点击“下一步”按钮，动画走一帧；  
- **自动播放**：拖动速度滑块（1x~5x），动画自动执行；  
- **重置**：点击“重置”按钮，回到初始状态；  
- **代码同步**：右侧显示当前步骤对应的C++代码片段（比如建重构树时显示`kruskal()`函数）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
Kruskal重构树的核心是**将“边的选择”转化为“树的结构”**，适用于以下场景：  
1. **路径瓶颈问题**（如“货车运输”：找两点间路径的最大边最小）；  
2. **动态连通性问题**（如“离线处理多个查询，每个查询问某条边是否在连通块中”）；  
3. **子树查询问题**（如“求某个区域内的最小值/最大值”）。


### 洛谷练习推荐  
1. **洛谷 P1967 货车运输**  
   🗣️ **推荐理由**：和本题几乎一样的思路！需要用Kruskal重构树求两点间路径的最大边最小，能直接巩固重构树的应用。  
2. **洛谷 P2245 星际导航**  
   🗣️ **推荐理由**：将“海拔”换成“燃料消耗”，同样需要找“能到达的区域”，是重构树的变形练习。  
3. **洛谷 P3946 诸神眷顾的幻想乡**  
   🗣️ **推荐理由**：需要用树形DP维护子树信息，和本题的“子树最小值”思路一致，能锻炼树形处理能力。


## 7. 学习心得与经验分享  

### 参考经验（来自niiick）  
> “我在比赛时调了一天才过，一开始忘记虚节点的数组要开两倍大，结果越界报错。后来才明白——重构树的节点数最多是2n（n个原节点+n-1个虚节点）！”  
**点评**：这个经验太重要了！写代码时，数组大小一定要考虑“最坏情况”——比如重构树的节点数是2n，所以`fa`、`val`、`min_dis`等数组要开2n的大小，否则会越界崩溃。


### 参考经验（来自ldxcaicai）  
> “Kruskal重构树的性质一定要记牢：父节点的海拔是子树的最小值，所以找祖先时要找‘海拔>p’的最高祖先！”  
**点评**：性质是解题的关键！如果记反了“升序/降序”，整个算法都会错——比如本题是按海拔降序建树，所以父节点的海拔是子树的最小值；如果按升序建树，父节点的海拔是子树的最大值。


## 结语  
“归程”题的核心是**用Kruskal重构树把“动态的边选择”转化为“静态的树结构”**，再结合最短路和倍增解决查询问题。希望这份指南能帮助你理解重构树的神奇之处——它就像一把“钥匙”，能打开很多“连通性+查询”问题的大门！  

下次遇到类似的问题，不妨想想：“能不能用重构树把边打包成树？” 编程的乐趣，就在于用聪明的方法解决复杂的问题～ 💪

---
处理用时：171.60秒
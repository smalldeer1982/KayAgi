# 题目信息

# [SDOI2009] 晨跑

## 题目描述

Elaxia 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等等，不过到目前为止，他坚持下来的只有晨跑。 

现在给出一张学校附近的地图，这张地图中包含 $N$ 个十字路口和 $M$ 条街道，Elaxia 只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。

Elaxia 每天从寝室出发跑到学校，保证寝室编号为 $1$，学校编号为 $N$。 

Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。

Elaxia 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。

除了练空手道，Elaxia 其他时间都花在了学习和找 MM 上面，所有他想请你帮忙为他设计一套满足他要求的晨跑计划。

可能存在 $1\rightarrow n$ 的边。这种情况下，这条边只能走一次。

## 说明/提示

- 对于 $30\%$ 的数据，$N\le 20$，$M \le 120$。
- 对于 $100\%$ 的数据，$2\leq N\le 200$，$1\leq M\le 2\times 10^4$，$1\le c\le 10^4$。

## 样例 #1

### 输入

```
7 10
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1
4 6 1
2 5 5
3 6 6
5 7 1
6 7 1```

### 输出

```
2 11
```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2009]晨跑 深入学习指南 💡


## 1. 题目解读与核心算法识别

### 1.1 题目核心
Elaxia每天从寝室（1号）跑向学校（N号），要求**周期内天数尽量多（每天路线不相交于中间路口）**，且**总路程尽量短**。这像什么？比如你要安排多批快递员从仓库（1号）送包裹到网点（N号），每批快递员的路线不能经过同一个中间站点，同时要让总配送距离最短——这就是**最小费用最大流**的典型场景！


### 1.2 核心算法：最小费用最大流
- **算法本质**：在“流网络”中找到**最大流量**（对应最多天数），同时让**总费用**（对应总路程）最小。  
- **本题应用**：  
  - 流量=天数：每一条从1到N的路径代表一天的晨跑路线，“最大流”就是最多能安排的天数。  
  - 费用=路程：每条街道的长度是“单位费用”，“最小费用”就是总路程最短。  


### 1.3 关键难点与解决
- **难点1**：中间路口只能走一次（不能重复经过）。  
  - **解决**：**拆点**！把每个路口`i`拆成“入点`i₁`”和“出点`i₂`”，用一条容量为1、费用为0的边连接`i₁→i₂`——这样每个路口只能“流一次”，自然限制了访问次数。  
- **难点2**：起点（1号）和终点（N号）可以重复经过。  
  - **解决**：起点和终点的拆点边容量设为`INF`（无限大），允许无限次流经。  


### 1.4 可视化设计思路
我设计了一个**像素风“快递员送包裹”动画**，帮你直观理解：
- **场景**：8位像素风的街道地图，用不同颜色的方块表示“入点”（蓝色）、“出点”（绿色）、起点（红色）、终点（黄色）。  
- **核心动画**：  
  1. **拆点展示**：每个中间节点的蓝方块（入点）和绿方块（出点）用细线条连接，代表容量1的边。  
  2. **流量流动**：当快递员（流量）从1号出点出发，沿着街道（边）流向N号入点时，路径上的方块会**闪烁黄色**，同时播放“叮”的音效。  
  3. **费用计算**：每走完一条街道，右上角的“总路程”数字会**增加对应边长**，用像素字体显示。  
- **交互**：支持“单步执行”（看每一步流量怎么走）、“自动播放”（快速看完整过程），还有“重置”按钮重新开始。  


## 2. 精选优质题解参考

### 题解一：Siyuan（来源：Luogu题解）
- **点评**：这是一份**标准且规范的最小费用最大流模板题解**！思路清晰到“像说明书”——先拆点，再建边，最后跑模板。代码用邻接表存图，SPFA找最短路径（最小费用），DFS更新流量（最大流），变量名`lnk`（邻接表头）、`ter`（终点）、`cap`（容量）、`cost`（费用）都很易懂。尤其是**拆点的处理**：把`i`拆成`i`和`i+n`，中间连`(i, i+n, 1, 0)`，完美解决了节点访问限制。


### 题解二：半仙胡小桃（来源：Luogu题解）
- **点评**：这份题解的**亮点是“分情况建边”**——专门处理了“起点为1”和“终点为N”的边，避免了通用模板的小bug。比如当边是`1→N`时，直接连`1的出点→N的入点`，容量1，费用是边长，完美符合题目中“1→N的边只能走一次”的要求。代码用`make_map`函数封装建边逻辑，可读性很高。


### 题解三：Yeji_（来源：Luogu题解）
- **点评**：虽然作者自称“小蒟蒻”，但代码**逻辑完整、注释清晰**！用`pre`数组记录前驱节点，`nxt`数组记录前驱边，`flow`数组记录当前路径的最小流量，完全符合最小费用最大流的“SPFA+更新”流程。尤其是`MCMF`函数的循环，每找到一条增广路就更新流量和费用，步骤明确，适合新手模仿。


## 3. 核心难点辨析与解题策略

### 3.1 难点1：为什么要拆点？
- **原因**：网络流的“容量”是给**边**的，而题目限制的是**节点**的访问次数。拆点相当于把“节点限制”转化为“边限制”——每个节点的入点到出点的边容量为1，自然限制了节点只能走一次。  
- **技巧**：记住“节点限制→拆点”，这是网络流的经典套路！


### 3.2 难点2：如何建立最小费用最大流模型？
- **流量对应什么？**：题目要“天数尽量多”，所以流量=天数（每条路径是一天）。  
- **费用对应什么？**：题目要“总路程尽量短”，所以费用=每条边的长度（路程）。  
- **技巧**：遇到“最大化X，同时最小化Y”的问题，先想“最小费用最大流”！


### 3.3 难点3：起点和终点的特殊处理
- **原因**：起点和终点是“必经之地”，不能限制访问次数。  
- **解决**：把起点的入点→出点边容量设为`INF`（比如`0x3f3f3f3f`），终点同理，允许无限次流经。  


### ✨ 解题技巧总结
1. **节点限制→拆点**：把节点拆成入点和出点，用边容量限制访问次数。  
2. **最小费用最大流模板**：SPFA找最短路径（最小费用），DFS/BFS更新流量（最大流）。  
3. **特殊点处理**：起点和终点的拆点边容量设为无限大。  


## 4. C++核心代码实现赏析

### 4.1 本题通用核心C++实现参考
- **说明**：综合了Siyuan、半仙胡小桃等优质题解的思路，优化了代码可读性，是一份标准的最小费用最大流模板。
- **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 405;  // 拆点后最多200*2=400节点
const int MAXM = 1e5 + 5;
const int INF = 0x3f3f3f3f;

struct Edge {
    int to, next, cap, cost;
} edge[MAXM];
int head[MAXN], tot = 1;  // 邻接表表头，tot从1开始（方便反向边）
int n, m;
int dis[MAXN], pre[MAXN], incf[MAXN];  // dis: 最短距离；pre: 前驱边；incf: 当前路径最小容量
bool vis[MAXN];
int max_flow, min_cost;

void add_edge(int u, int v, int cap, int cost) {
    edge[++tot].to = v;
    edge[tot].cap = cap;
    edge[tot].cost = cost;
    edge[tot].next = head[u];
    head[u] = tot;
    // 反向边（容量0，费用相反数）
    edge[++tot].to = u;
    edge[tot].cap = 0;
    edge[tot].cost = -cost;
    edge[tot].next = head[v];
    head[v] = tot;
}

bool spfa(int s, int t) {
    memset(dis, INF, sizeof(dis));
    memset(vis, false, sizeof(vis));
    queue<int> q;
    q.push(s);
    dis[s] = 0;
    vis[s] = true;
    incf[s] = INF;  // 起点的初始容量是无限大
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (edge[i].cap > 0 && dis[v] > dis[u] + edge[i].cost) {
                dis[v] = dis[u] + edge[i].cost;
                pre[v] = i;  // 记录前驱边
                incf[v] = min(incf[u], edge[i].cap);  // 当前路径的最小容量
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
    }
    return dis[t] != INF;  // 能否到达汇点
}

void update(int s, int t) {
    int u = t;
    while (u != s) {
        int i = pre[u];
        edge[i].cap -= incf[t];  // 正向边容量减少
        edge[i ^ 1].cap += incf[t];  // 反向边容量增加
        u = edge[i ^ 1].to;  // 反向边的起点是原边的终点
    }
    max_flow += incf[t];
    min_cost += incf[t] * dis[t];
}

int main() {
    cin >> n >> m;
    // 1. 拆点：i → i（入点）和 i+n（出点）
    for (int i = 1; i <= n; ++i) {
        if (i == 1 || i == n) {
            add_edge(i, i + n, INF, 0);  // 起点和终点允许无限次流经
        } else {
            add_edge(i, i + n, 1, 0);  // 中间节点只能流经一次
        }
    }
    // 2. 建原边：u的出点 → v的入点，容量1，费用为边长
    for (int i = 0; i < m; ++i) {
        int u, v, c;
        cin >> u >> v >> c;
        add_edge(u + n, v, 1, c);  // u的出点（u+n）连v的入点（v）
    }
    // 3. 源点是1的出点（1+n），汇点是n的入点（n）
    int s = 1 + n, t = n;
    while (spfa(s, t)) {
        update(s, t);
    }
    cout << max_flow << " " << min_cost << endl;
    return 0;
}
```
- **代码解读概要**：
  1. **拆点**：用`add_edge(i, i+n, cap, 0)`把每个节点拆成入点（`i`）和出点（`i+n`）。  
  2. **建边**：原边`u→v`转化为`u的出点（u+n）→v的入点（v）`，容量1，费用是边长。  
  3. **最小费用最大流**：用SPFA找最短路径（最小费用），用update函数更新流量（最大流）。  


### 4.2 优质题解片段赏析

#### 题解一：Siyuan的核心片段
- **亮点**：用`add`和`addedge`函数封装建边逻辑，代码简洁。
- **核心代码片段**：
```cpp
void add(int u, int v, int w, int c) {
    ter[++tot] = v, nxt[tot] = lnk[u], lnk[u] = tot, cap[tot] = w, cost[tot] = c;
}
void addedge(int u, int v, int w, int c) {
    add(u, v, w, c), add(v, u, 0, -c);
}
```
- **代码解读**：
  - `add`函数：添加一条从`u`到`v`的边，容量`w`，费用`c`。  
  - `addedge`函数：同时添加正向边和反向边（反向边容量0，费用`-c`）——这是网络流的标准操作，反向边用于“反悔”（调整流量）。
- **学习笔记**：建边时一定要记得加反向边，否则无法正确更新流量！


#### 题解二：半仙胡小桃的核心片段
- **亮点**：用`make_map`函数分情况处理边，避免起点终点的错误。
- **核心代码片段**：
```cpp
void make_map(int from, int ds, int cost1) {
    if (from == 1) {  // 起点的边：从起点直接连到ds的入点
        add(1, ds, 1, cost1);
        add(ds, 1, 0, -cost1);
        return;
    }
    if (ds == n) {  // 终点的边：从from的出点连到终点
        add(from + n, n, 1, cost1);
        add(n, from + n, 0, -cost1);
        return;
    }
    add(from + n, ds, 1, cost1);  // 普通边：出点连入点
    add(ds, from + n, 0, -cost1);
}
```
- **代码解读**：
  - 当`from`是起点（1）时，直接连`1→ds`（因为起点的出点就是自己）；  
  - 当`ds`是终点（n）时，连`from+n→n`（终点的入点就是自己）；  
  - 普通边连`from+n→ds`（出点连入点）。
- **学习笔记**：分情况处理特殊边，可以避免通用模板的“一刀切”错误！


## 5. 算法可视化：像素动画演示

### 5.1 动画主题：像素快递员送包裹
- **风格**：8位像素风（类似FC游戏《超级马里奥》），用简单的方块和线条表示节点和边。
- **核心演示步骤**：
1. **初始化**：  
   - 屏幕左侧显示“控制面板”：`开始/暂停`、`单步`、`重置`按钮，以及`速度滑块`（从1x到5x）。  
   - 屏幕右侧显示像素地图：红色方块是起点（1号出点），黄色方块是终点（n号入点），蓝色是入点，绿色是出点，灰色是街道（边）。
2. **算法启动**：  
   - 点击“开始”，红色起点会“弹出”一个小快递员（像素小人），沿着灰色街道向终点移动。  
   - 每走一条街道，快递员经过的方块会**闪烁黄色**，同时播放“叮”的音效。
3. **流量更新**：  
   - 当快递员到达终点，右上角的“天数”（最大流）加1，“总路程”（最小费用）加对应边长，播放“咻”的音效。
4. **自动演示**：  
   - 点击“自动播放”，快递员会自动走完全部增广路，直到无法再走为止，最后显示“任务完成！”的像素文字，播放胜利音效。


### 5.2 交互设计
- **单步执行**：点击“单步”，快递员走一步，停在当前节点，方便观察每一步的流量和费用。  
- **速度调节**：用滑块调整自动播放的速度，最慢1x（每步1秒），最快5x（每步0.2秒）。  
- **重置**：点击“重置”，所有方块回到初始状态，重新开始演示。


## 6. 拓展练习与相似问题

### 6.1 相似问题
1. **洛谷 P1402 酒店之王**：同样需要拆点限制节点访问次数，求最大流。  
2. **洛谷 P1231 教辅的组成**：拆点+最大流，解决“书、练习册、答案”的匹配问题。  
3. **洛谷 P2891 Dining**：拆点+最大流，解决“牛吃饲料”的限制问题。  


### 6.2 进阶练习
1. **洛谷 P2153 晨跑**（本题）：巩固拆点+最小费用最大流。  
2. **洛谷 P3381 【模板】最小费用最大流**：熟悉模板的不同实现方式。  
3. **洛谷 P1004 方格取数**：拆点+最大流，解决“不能重复取数”的问题。  


## 7. 学习心得与经验分享

### 7.1 来自题解作者的经验
- **半仙胡小桃**：“我一开始没处理起点和终点的边，结果WA了好几次——后来发现起点的边要直接连入点，终点的边要连出点，这才对！”  
- **点评**：起点和终点的特殊处理是本题的“坑点”，一定要记得它们的拆点边容量是无限大，边的连接方式也要调整。


### 7.2 我的学习提醒
- **拆点是关键**：遇到“节点限制”的问题，第一反应就是拆点！  
- **模板要记牢**：最小费用最大流的模板是“SPFA找最短路径+更新流量”，一定要熟练掌握。  
- **多画图**：画一张拆点后的图，比看十遍代码更有用！比如画一个3节点的小图，标出每个节点的入点和出点，再连边，瞬间就懂了。  


## 总结
“晨跑”题的核心是**拆点+最小费用最大流**，解决了“节点限制”和“最小费用最大流”的结合问题。通过像素动画和优质题解的分析，相信你已经掌握了这个套路。接下来，不妨试试拓展练习中的题目，巩固一下！

编程的路上，拆点不是终点，而是开启更多问题的钥匙——加油！💪

---
处理用时：103.97秒
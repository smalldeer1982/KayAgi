# 题目信息

# [HNOI2001] 软件开发

## 题目描述

某软件公司正在规划一项 $n$ 天的软件开发计划，根据开发计划第 $i$ 天需要 $n_i$ 个软件开发人员，为了提高软件开发人员的效率，公司给软件人员提供了很多的服务，其中一项服务就是要为每个开发人员每天提供一块消毒毛巾，这种消毒毛巾使用一天后必须再做消毒处理后才能使用。

消毒方式有两种，$A$ 种方式的消毒需要 $a$ 天时间，$B$ 种方式的消毒需要 $b$ 天，$A$ 种消毒方式的费用为每块毛巾 $f_A$, $B$ 种消毒方式的费用为每块毛巾 $f_B$，而买一块新毛巾的费用为 $f$（新毛巾是已消毒的，当天可以使用）。公司经理正在规划在这 $n$ 天中，每天买多少块新毛巾、每天送多少块毛巾进行 $A$ 种消毒和每天送多少块毛巾进行 $B$ 种消毒。当然，公司经理希望费用最低。

你的任务就是：为该软件公司计划每天买多少块毛巾、每天多少块毛巾进行 $A$ 种消毒和多少毛巾进行 $B$ 种消毒，使公司在这项 $n$ 天的软件开发中，提供毛巾服务的总费用最低。

## 说明/提示

#### 数据规模与约定
对于 $100\%$ 的数据，保证 $b>a$，$f>f_A>f_B$，$1\le f,f_A,f_B\le 60$，$1\le n\le 10^3$。

## 样例 #1

### 输入

```
4  1  2  3  2  1                         

8  2  1  6  

```

### 输出

```
38```

# AI分析结果

# 💡 Kay的C++算法解析：[HNOI2001]软件开发 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论 - 最小费用最大流  

🗣️ **初步分析**：  
解决这道题的关键，就像规划一条“最便宜的送水路线”——我们需要把“毛巾”从“源头”（买新的、消毒后的）送到“需求点”（每天早上需要的干净毛巾），同时每条“送水管道”（对应一种操作，比如买毛巾、消毒）有固定的“费用”（操作成本）和“流量限制”（操作能处理的毛巾数量）。我们的目标是让所有“需求点”都收到足够的“水”（毛巾），同时总“水费”（成本）最少——这就是**最小费用最大流**的核心思想！  

在本题中，我们需要处理“每天早上需要干净毛巾”和“每天晚上产生脏毛巾”这两个独立的过程，因此**拆点**是关键：把每一天拆成“早上节点”（处理干净毛巾的需求）和“晚上节点”（处理脏毛巾的去向）。所有题解的核心思路都是通过拆点建立网络流模型，将“买毛巾”“消毒毛巾”“留到第二天处理脏毛巾”转化为网络中的边，最终用最小费用最大流算法计算总费用。  

**核心算法流程**：  
1. **拆点**：第i天拆为早上节点i和晚上节点i+n；  
2. **建边**：  
   - 源点→晚上节点i+n：流量为当天使用的毛巾数n_i（晚上产生n_i条脏毛巾），费用0；  
   - 早上节点i→汇点：流量为n_i（早上需要n_i条干净毛巾），费用0；  
   - 源点→早上节点i：流量无限（可买任意多新毛巾），费用f（买毛巾的成本）；  
   - 晚上节点i+n→早上节点i+a+1：流量无限（可消毒任意多毛巾），费用f_A（A消毒的成本）；  
   - 晚上节点i+n→早上节点i+b+1：流量无限，费用f_B（B消毒的成本）；  
   - 晚上节点i+n→晚上节点(i+1)+n：流量无限，费用0（脏毛巾留到第二天处理）。  
3. **计算**：用最小费用最大流算法，找到满足所有需求的最小总费用。  

**可视化设计思路**：  
我们将用**8位像素风**模拟这个过程——源点是绿色像素块，汇点是红色，每天的“早上节点”是蓝色方块，“晚上节点”是黄色方块。边用彩色线条表示（买毛巾是橙色，A消毒是紫色，B消毒是青色，留到第二天是灰色），线条宽度代表流量，颜色深浅代表费用。动画中，**单步执行**会高亮当前处理的节点（闪烁），**自动播放**会模拟“水流”流动，每完成一次消毒或买毛巾操作，伴随“叮”的像素音效；所有需求满足时，播放“嘟嘟嘟”的胜利音效，屏幕显示“通关！”。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，它们能帮你快速理解建模和代码实现~
</eval_intro>

### 题解一：作者TEoS（赞11）
* **点评**：这份题解是我见过对“拆点建模”讲解最细致的！作者不仅一步步解释了每个边的意义（比如“源点→晚上节点”对应产生脏毛巾），还贴心地在代码中用`a++`和`b++`简化了消毒后的天数计算（避免反复加1）。代码采用经典的“SPFA找最小费用路径+update更新流量”模板，变量名（如`ver`存边的终点、`cost`存费用）清晰易懂，甚至注释了“双向建边”的原因——网络流需要反向边来调整流量。无论是建模思路还是代码实现，这份题解都是新手的“绝佳参考”！

### 题解二：作者zj余能（赞6）
* **点评**：此题解的代码非常简洁！作者用`SPFA`函数实现了“找最短费用增广路”，`MinCost`函数循环处理所有增广路，逻辑链条清晰。特别值得学习的是`SPFA`中的“松弛操作”——通过比较`dis[u]+e[i].cost`和`dis[v]`，找到当前节点到汇点的最小费用路径。此外，作者对“源点”和“汇点”的编号（`S=2n+1`，`T=S+1`）很规范，避免了节点编号冲突，适合新手模仿。

### 题解三：作者Broken_Heart（赞3）
* **点评**：这份题解的“拆点解释”超贴心！作者先分析了“不拆点”的问题（流量不够用，因为既要流向汇点又要流向其他节点），再引出“拆点”的解决方案（将每天拆为早上和晚上，分开处理干净/脏毛巾）。代码中用`num[i][0]`和`num[i][1]`分别记录第i天的晚上和早上节点，清晰区分了两个过程。此外，作者还用`build`函数封装了“双向建边”，减少了代码重复，是很好的编程习惯~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“把问题转化为网络流模型”，以下3个难点是新手最容易卡壳的地方，我们一一攻破！
</difficulty_intro>

### 1. 难点1：为什么要拆点？
* **分析**：每天的“干净毛巾需求”和“脏毛巾处理”是两个独立的过程——早上需要干净毛巾，晚上产生脏毛巾。如果只用一个节点表示一天，无法区分这两个过程，会导致“脏毛巾还没处理就被当成干净毛巾用了”。  
* **解决**：把每一天拆成“早上节点”（处理干净毛巾的需求）和“晚上节点”（处理脏毛巾的去向），两个节点独立处理，就像“两个口袋，一个装干净毛巾，一个装脏毛巾”。

### 2. 难点2：消毒后的毛巾何时可用？
* **分析**：A消毒需要a天，比如第1天晚上送的脏毛巾，要第1+a+1=3天早上才能用（第1天晚上送，第2天消毒，第3天早上拿回来）。如果直接连到`i+a`天，就会提前一天，导致错误。  
* **解决**：在代码中，先把`a`和`b`加1（比如`a++`），这样`i+a`就对应`i+a+1`天，避免计算错误。比如TEoS的代码中，`a++,b++`后，`i+a`就是正确的天数。

### 3. 难点3：如何用模板计算最小费用最大流？
* **分析**：最小费用最大流的核心是“找增广路（能增加流量的路径）”，且要找“费用最小”的增广路。新手容易混淆“最大流”和“最小费用”的关系——我们需要在满足“所有需求（最大流）”的前提下，让总费用最少。  
* **解决**：用`SPFA`算法找“从源点到汇点的最短费用路径”（因为费用是边的权重，最短路径就是最小费用），然后沿着这条路径“增广”（增加流量），直到没有增广路为止。TEoS的`spfa`函数和`update`函数完美实现了这个逻辑！

### ✨ 解题技巧总结
- **拆点法**：当问题涉及“同一对象的两个不同状态”（比如毛巾的“干净”和“脏”），拆点是常用技巧；  
- **边的意义**：网络流的边要对应“实际操作”（比如“买毛巾”对应源点到早上节点的边），边的“流量”对应“操作能处理的数量”，“费用”对应“操作的成本”；  
- **模板复用**：最小费用最大流的核心模板（SPFA找增广路+update更新流量）可以套用到大部分费用流问题中，记熟模板能节省大量时间！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份“通用核心代码”，它综合了优质题解的思路，代码简洁且注释详细~
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码来自TEoS的题解，修改了注释使其更易懂，是“最小费用最大流+拆点建模”的典型实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
using namespace std;

const int INF = 0x7f7f7f7f;
const int N = 2010;  // 2*1000+10，n最大是1000
const int M = 6010;  // 边数上限

int n, a, b, f, fa, fb;
int s, t;  // 源点s，汇点t
int head[N], ver[M*2], edge[M*2], Next[M*2], cost[M*2];  // 邻接表存储边
int pre[N], minf[N], d[N];  // pre记录路径的边，minf记录路径的最小流量，d记录最小费用
bool v[N];  // 标记节点是否在队列中
int tot = 1;  // 边的编号，从1开始（方便反向边）
int ans = 0;  // 总费用

// 双向建边：x→y，流量z，费用c；y→x，流量0，费用-c
void add(int x, int y, int z, int c) {
    ver[++tot] = y;
    edge[tot] = z;
    cost[tot] = c;
    Next[tot] = head[x];
    head[x] = tot;
    // 反向边
    ver[++tot] = x;
    edge[tot] = 0;
    cost[tot] = -c;
    Next[tot] = head[y];
    head[y] = tot;
}

// SPFA找从s到t的最小费用路径
bool spfa() {
    memset(v, 0, sizeof(v));
    memset(d, 0x7f, sizeof(d));  // d初始化为无穷大
    queue<int> q;
    d[s] = 0;  // 源点费用为0
    v[s] = 1;
    minf[s] = INF;  // 源点的最大流量是无穷大
    q.push(s);
    while (!q.empty()) {
        int x = q.front();
        q.pop();
        v[x] = 0;
        for (int i = head[x]; i; i = Next[i]) {  // 遍历x的所有边
            int y = ver[i];
            if (edge[i] > 0 && d[y] > d[x] + cost[i]) {  // 边有流量，且能更新费用
                d[y] = d[x] + cost[i];  // 更新到y的最小费用
                minf[y] = min(minf[x], edge[i]);  // 路径的最小流量是当前边流量和之前的最小值
                pre[y] = i;  // 记录到达y的边
                if (!v[y]) {  // 如果y不在队列中，加入队列
                    q.push(y);
                    v[y] = 1;
                }
            }
        }
    }
    return d[t] != INF;  // 如果d[t]还是无穷大，说明没有增广路
}

// 更新流量：沿着SPFA找到的路径，减少正向边流量，增加反向边流量
void update() {
    int x = t;
    while (x != s) {  // 从汇点倒推回源点
        int i = pre[x];  // 到达x的边
        edge[i] -= minf[t];  // 正向边流量减少minf[t]（路径的最小流量）
        edge[i^1] += minf[t];  // 反向边流量增加minf[t]（方便后续调整）
        x = ver[i^1];  // 反向边的起点是原边的终点，即x的前一个节点
    }
    ans += d[t] * minf[t];  // 总费用增加：路径费用×流量
}

int main() {
    scanf("%d%d%d%d%d%d", &n, &a, &b, &f, &fa, &fb);
    s = 0;  // 源点编号0
    t = 2 * n + 1;  // 汇点编号2n+1
    a++;  // 消毒a天，变为a+1天（方便计算i+a）
    b++;  // 同理
    for (int i = 1; i <= n; i++) {
        int x;
        scanf("%d", &x);  // 第i天需要的毛巾数n_i
        // 1. 源点→晚上节点i+n：流量x（产生x条脏毛巾），费用0
        add(s, i + n, x, 0);
        // 2. 早上节点i→汇点：流量x（需要x条干净毛巾），费用0
        add(i, t, x, 0);
        // 3. 源点→早上节点i：流量无穷（买新毛巾），费用f
        add(s, i, INF, f);
        // 4. 晚上节点i+n→早上节点i+a：流量无穷（A消毒），费用fa（如果i+a<=n）
        if (i + a <= n) {
            add(i + n, i + a, INF, fa);
        }
        // 5. 晚上节点i+n→早上节点i+b：流量无穷（B消毒），费用fb（如果i+b<=n）
        if (i + b <= n) {
            add(i + n, i + b, INF, fb);
        }
        // 6. 晚上节点i+n→晚上节点(i+1)+n：流量无穷（留到第二天），费用0（如果i+1<=n）
        if (i + 1 <= n) {
            add(i + n, (i + 1) + n, INF, 0);
        }
    }
    // 跑最小费用最大流：只要有增广路，就更新流量
    while (spfa()) {
        update();
    }
    printf("%d\n", ans);
    return 0;
}
```
* **代码解读概要**：
  1. **变量定义**：用邻接表存储边（`head`、`ver`、`edge`、`cost`），`pre`记录路径的边，`minf`记录路径的最小流量，`d`记录最小费用；
  2. **add函数**：双向建边，网络流的核心——每条正向边对应一个反向边，用于调整流量；
  3. **spfa函数**：找“从源点到汇点的最小费用路径”，用队列优化的Bellman-Ford算法；
  4. **update函数**：根据SPFA找到的路径，更新边的流量，并累加总费用；
  5. **主函数**：
     - 输入数据，设置源点`s=0`、汇点`t=2n+1`；
     - 拆点建边：处理每天的脏毛巾（源点→晚上节点）、干净毛巾需求（早上节点→汇点）、买新毛巾（源点→早上节点）、消毒（晚上节点→几天后的早上节点）、留到第二天（晚上节点→第二天晚上节点）；
     - 循环跑`spfa`和`update`，直到没有增广路，输出总费用。

<code_intro_selected>
接下来看优质题解的“核心片段”，点出它们的亮点~
</code_intro_selected>

### 题解一：作者TEoS（赞11）
* **亮点**：用`a++`和`b++`简化了消毒后的天数计算，避免了“i+a+1”的繁琐。
* **核心代码片段**：
```cpp
a++;  // 消毒a天，变为a+1天（比如a=1→a=2，i=1→i+a=3，对应第3天早上）
b++;
for (int i = 1; i <= n; i++) {
    // ... 其他代码 ...
    if (i + a <= n) {
        add(i + n, i + a, INF, fa);  // 晚上节点i+n→早上节点i+a
    }
    if (i + b <= n) {
        add(i + n, i + b, INF, fb);  // 晚上节点i+n→早上节点i+b
    }
}
```
* **代码解读**：
  问：为什么要`a++`？  
  答：比如原题中A消毒需要`a=1`天——第1天晚上送的脏毛巾，要第`1+1+1=3`天早上才能用（第1天晚上送，第2天消毒，第3天早上拿回来）。如果直接写`i+a+1`，会很麻烦；而`a++`后，`a=2`，`i+a=1+2=3`，正好是第3天早上！这个小技巧能减少代码中的“+1”错误，超实用~
* 💡 **学习笔记**：遇到“时间延迟”问题时，可以通过“调整变量值”简化计算，避免重复的“+1”“-1”操作！

### 题解二：作者zj余能（赞6）
* **亮点**：用`MinCost`函数封装了“循环处理增广路”，代码逻辑更清晰。
* **核心代码片段**：
```cpp
int MinCost(int s, int t) {
    while (SPFA(s, t, cc)) {  // 只要有增广路，就处理
        ;  // SPFA内部已经更新了费用和流量
    }
    return cc;  // 返回总费用
}
```
* **代码解读**：
  问：`SPFA`函数里做了什么？  
  答：`SPFA`函数不仅找了“最小费用路径”，还**直接更新了流量和费用**——通过`from`数组记录路径的边，然后循环`i=from[t]`，减少正向边流量，增加反向边流量，同时累加`x*e[i].cost`（x是路径的最小流量）。这种“将更新逻辑放在SPFA里”的写法，能让代码更简洁！
* 💡 **学习笔记**：可以将“找增广路+更新流量”的逻辑封装成函数，减少主函数的代码量~

### 题解三：作者Broken_Heart（赞3）
* **亮点**：用`num[i][0]`和`num[i][1]`记录每天的“晚上节点”和“早上节点”，清晰区分两个过程。
* **核心代码片段**：
```cpp
int num[N<<2][2];  // num[i][0]是第i天晚上节点，num[i][1]是第i天早上节点
int cnt = 0;  // 节点计数器
il int ask(int &u) {  // 分配节点编号（如果u未分配，就cnt++）
    if (!u) u = ++cnt;
    return u;
}

int main() {
    // ... 其他代码 ...
    for (int i = 1; i <= n; i++) {
        int u = ask(num[i][0]);  // 晚上节点
        int v = ask(num[i][1]);  // 早上节点
        build(s, u, r[i], 0);  // 源点→晚上节点：流量r[i]（脏毛巾），费用0
        build(s, v, r[i], c0);  // 源点→早上节点：流量r[i]（买新毛巾），费用c0
        build(v, t, r[i], 0);  // 早上节点→汇点：流量r[i]（需要干净毛巾），费用0
        // ... 消毒和留到第二天的边 ...
    }
}
```
* **代码解读**：
  问：`ask`函数的作用是什么？  
  答：`num[i][0]`和`num[i][1]`初始是0，`ask`函数会给它们分配唯一的节点编号（比如第1天晚上节点是1，早上节点是2，第2天晚上节点是3，依此类推）。这种“动态分配节点编号”的方法，避免了“手动计算节点编号”的错误（比如n=1000时，晚上节点是1001，早上节点是1，容易混淆），适合新手！
* 💡 **学习笔记**：当节点数量多且需要“分类”时，可以用二维数组记录节点编号，再用函数动态分配，避免编号冲突~


## 5. 算法可视化：像素动画演示

### 动画演示主题：《像素毛巾工厂》
**核心演示内容**：模拟“毛巾从源点出发，经过买、消毒、留到第二天等操作，最终满足每天需求”的过程，用8位像素风格展示网络流的流动。

### 设计思路简述
采用**FC红白机风格**（低分辨率、高饱和色彩），让学习过程像玩“经营游戏”——你是“毛巾工厂经理”，需要规划毛巾的流向，让总费用最少。动画中的“单步执行”能让你看清每一步的流量变化，“自动播放”像“AI经理”帮你完成所有操作，伴随像素音效增强记忆。

### 动画帧步骤与交互关键点
1. **场景初始化**：
   - 屏幕左侧是**源点**（绿色方块，标“S”），右侧是**汇点**（红色方块，标“T”）；
   - 中间是**n天的节点**：每天两个方块，蓝色是“早上节点”（标“M_i”），黄色是“晚上节点”（标“E_i”）；
   - 底部是**控制面板**：包含“开始/暂停”“单步”“重置”按钮，速度滑块（1x~5x），以及“费用显示区”（实时显示总费用）。
   - 播放**8位风格背景音乐**（轻快的电子音）。

2. **建边动画**：
   - 源点→早上节点M_i：橙色线条（标“买，费用f”），线条宽度代表“无限流量”；
   - 源点→晚上节点E_i：灰色线条（标“脏毛巾，流量n_i”）；
   - 晚上节点E_i→早上节点M_{i+a+1}：紫色线条（标“A消毒，费用fa”）；
   - 晚上节点E_i→早上节点M_{i+b+1}：青色线条（标“B消毒，费用fb”）；
   - 晚上节点E_i→晚上节点E_{i+1}：白色线条（标“留到明天，费用0”）。

3. **算法执行动画**：
   - **SPFA找路径**：当前处理的节点会**闪烁**（比如E_1→M_3的边会变成亮紫色），同时“费用显示区”显示当前路径的费用；
   - **更新流量**：正向边的线条会**变细**（流量减少），反向边的线条会**变粗**（流量增加），伴随“嗒”的音效；
   - **完成一天**：当M_i→T的边流量满时，M_i会变成**绿色**（表示当天需求满足），播放“叮”的音效；
   - **通关**：当所有M_i都变成绿色时，屏幕显示“🎉 总费用：X元”，播放“嘟嘟嘟”的胜利音效，背景音乐切换为“胜利旋律”。

4. **交互设计**：
   - **单步执行**：点击“单步”按钮，执行一次SPFA+update，看清每一步的变化；
   - **自动播放**：点击“开始”，动画按设置的速度（1x~5x）自动执行，适合快速浏览整体流程；
   - **重置**：点击“重置”，所有节点和边恢复初始状态，重新开始动画。

### 技术实现考量
- 用**HTML5 Canvas**绘制像素节点和边，用**JavaScript**实现SPFA和update的逻辑；
- 用**Web Audio API**播放音效（比如“叮”用440Hz正弦波，“嗒”用220Hz方波）；
- 所有资源打包成**单HTML文件**，本地双击即可运行，无需网络。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移
“最小费用最大流+拆点建模”的思路，能解决**所有“资源分配+最小成本”**的问题，比如：
1. **食堂打饭**：每天需要不同数量的饭菜，可提前做（成本低但需要时间）或当天做（成本高但及时），求最小成本；
2. **快递配送**：每天需要送不同数量的快递，可找慢快递（便宜但慢）或快快递（贵但快），求最小成本；
3. **工厂生产**：每天需要不同数量的产品，可提前生产（存储成本低）或当天生产（人力成本高），求最小成本。

### 洛谷练习推荐
1. **P1251 餐巾计划问题**：和本题**完全一样**的模型（双倍经验！），只是变量名不同，适合巩固建模思路；
2. **P2917 [USACO08NOV] Toys G**：需要将“玩具的生产”转化为网络流模型，考察“拆点+费用流”的应用；
3. **P4480 [BJWC2018] 餐巾计划问题**：本题的**进阶版**，增加了“毛巾的损耗”和“多工厂生产”，需要更复杂的建模。


## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自作者TEoS)**：“我在建模时，一开始忘了‘脏毛巾可以留到第二天处理’，导致总费用总是算错。后来加了‘晚上节点→第二天晚上节点’的边，问题就解决了！”  
> **点评**：这位作者的经验很典型——**不要遗漏任何操作**！实际问题中的“留到第二天”“延期处理”等操作，往往对应网络流中的“边”，如果遗漏，会导致模型不完整，结果错误。遇到这种情况，可以**再读一遍题目**，确保所有操作都被转化为边~


## 8. 总结

今天我们一起分析了“[HNOI2001]软件开发”这道题，核心是**最小费用最大流+拆点建模**。通过拆点将“每天的干净毛巾需求”和“脏毛巾处理”分开，再将实际操作转化为网络流的边，最后用模板计算最小费用。

记住：**网络流的本质是“模型转化”**——把实际问题中的“操作”“成本”“限制”转化为“边”“费用”“流量”，剩下的就是套模板啦！

下次遇到“最小成本+满足所有需求”的问题，不妨想想：“能不能用最小费用最大流？需要拆点吗？” 多练习几道题，你会越来越熟练~

加油，编程之路没有捷径，但每一步都有收获！💪


--- 
**附录**：如果你想自己实现可视化动画，可以参考以下JavaScript代码框架（绘制像素节点）：
```javascript
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// 绘制像素节点（x,y是坐标，color是颜色，text是文字）
function drawNode(x, y, color, text) {
    ctx.fillStyle = color;
    ctx.fillRect(x*10, y*10, 10, 10);  // 10x10像素的方块
    ctx.fillStyle = 'black';
    ctx.font = '8px Arial';
    ctx.fillText(text, x*10+2, y*10+8);  // 文字显示在方块内
}

// 绘制边（x1,y1到x2,y2，color是颜色）
function drawEdge(x1, y1, x2, y2, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(x1*10+5, y1*10+5);  // 从节点中心出发
    ctx.lineTo(x2*10+5, y2*10+5);  // 到节点中心
    ctx.stroke();
}

// 初始化场景
drawNode(1, 1, 'green', 'S');  // 源点
drawNode(20, 1, 'red', 'T');   // 汇点
drawNode(5, 5, 'blue', 'M1');  // 第1天早上节点
drawNode(5, 6, 'yellow', 'E1');// 第1天晚上节点
drawEdge(1,1,5,5,'orange');    // 源点→M1（买毛巾）
```
保存为`index.html`，双击打开就能看到像素节点啦！

---
处理用时：147.29秒
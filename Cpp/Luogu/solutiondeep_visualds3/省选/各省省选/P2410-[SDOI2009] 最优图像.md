# 题目信息

# [SDOI2009] 最优图像

## 题目背景

小 E 在好友小 W 的家中发现一幅神奇的图画，对此颇有兴趣。

## 题目描述

这幅画可以被看做一个包含 $n \times m$ 个像素的黑白图像，为了方便起见，我们用 $0$ 表示白色像素，$1$ 表示黑色像素。小 E 认为这幅图画暗藏玄机，因此他记录下了这幅图像中每行、每列的黑色像素数量，以回去慢慢研究其中的奥妙。

有一天，小 W 不慎将图画打湿，原本的图像已经很难分辨。他十分着急，于是找来小 E，希望共同还原这幅图画。根据打湿后的图画，他们无法确定真正的图像，然而可以推测出每个像素原本是黑色像素的概率 $p_{i,j}\%$。那么，一个完整的图像的出现概率就可以定义为:

$$\prod\limits_{i = 1}^n \prod\limits_{j = 1}^{m} p_{i, j}\% \times [s_{i, j} = 1]$$

其中 $s_{i,j}$ 表示在还原后的图像中，像素是白色($0$)还是黑色($1$)，$[s_{i, j} = 1]$ 表示若 $s_{i, j} = 1$，则该表达式的值为 $1$，否则为 $0$。换句话说，一个完整图像出现概率就等于其所有黑色像素的出现概率之积。显然，图像的黑色像素不能包含概率为 $0$ 的像素。

然而，小 E 对此也无能为力。因此他们找到了会编程的小 F，也就是你，请你根据以上信息，告诉他们最有可能是原始图像的答案是什么。



## 说明/提示

#### 样例输入输出 1 解释

共有两种可能的图像：

```plain
01
10
```
```plain
10
01
```
前者的出现概率是 $0.1×0.2=0.02$，后者的出现概率是 $0.9×0.8=0.72$，故后者是最优图像。

---

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n, m \leq 5$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 100$，$0 \leq p_{i, j} \leq 100$，$0 \leq a_i \leq m$，$0 \leq b_i \leq n$。

---

感谢 @[test12345](https://www.luogu.com.cn/user/23118) 提供 spj。

## 样例 #1

### 输入

```
2 2
90 10
20 80
1 1
1 1
```

### 输出

```
10
01
```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2009] 最优图像 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（费用流）

🗣️ **初步分析**：  
解决这道题的关键是把“恢复图像”的问题转化为**网络流中的最大费用最大流**问题。你可以把它想象成一场“资源分配游戏”：  
- 每行需要选出`a_i`个黑像素（就像“工厂”需要生产`a_i`个产品），每列需要接收`b_j`个黑像素（像“商店”需要卖`b_j`个产品）；  
- 每个格子`(i,j)`是否选黑像素，就像“工厂i”到“商店j”的一条“运输路线”——选它就相当于用这条路线运1个产品，同时能获得`p_{i,j}%`的“利润”（概率）；  
- 我们的目标是让所有选中的路线的“利润乘积”最大（也就是总概率最大），这对应网络流中的“最大费用最大流”（因为费用是乘积，所以要最大化总费用）。  

### 核心算法流程与可视化设计思路  
1. **建图**：  
   - 源点S连向每行节点（流量`a_i`，费用1，因为“生产”1个产品不额外赚钱）；  
   - 每列节点连向汇点T（流量`b_j`，费用1，“卖出”1个产品也不额外赚钱）；  
   - 行i连向列j（流量1，费用`p_{i,j}*0.01`，代表选这个格子为黑的概率）。  
2. **费用流计算**：  
   用SPFA找“最长路径”（因为要最大化乘积，松弛操作是`dis[y] = max(dis[y], dis[x] * w[x][y])`），再用DFS增广；反边的费用是原边的**倒数**（因为乘法的逆操作是除法）。  
3. **输出方案**：遍历残量网络，找行i到列j的边中**容量为0**的（说明这条路线被“用满了”，对应格子是黑）。  

### 可视化设计小预告  
我们会用**8位像素风**做一个“运输模拟游戏”：  
- 行是红色像素块（工厂），列是蓝色像素块（商店），源点是黄色星星（仓库），汇点是绿色房子（市场）；  
- 边是灰色线条，当流量流过时线条会“闪烁”（像卡车在运货），满流的边会变成橙色（表示“这条路已经用满啦”）；  
- 操作时有音效：连边时“叮”一声，流量流动时“沙沙”声，找到最优解时会有“胜利的小旋律”～


## 2. 精选优质题解参考

### 题解一：来源：tommymio（赞：6）  
* **点评**：  
  这道题的“标杆题解”！作者不仅讲清了**网络流行列模型**的建图逻辑，还针对本题的“乘积最大化”做了关键优化——SPFA用乘法松弛，反边用倒数。代码里用了`zkw`费用流（更高效的费用流实现），还加了**常数优化**（快读、当前弧、避免`memset`），跑起来非常快。最棒的是，作者最后通过残量网络找“容量为0的边”输出方案，逻辑清晰，很适合初学者模仿。

### 题解二：来源：Aranea晨曦（赞：5）  
* **点评**：  
  这篇题解的“初心”特别好——专门解释了“为什么要这么建图”！作者用“工厂-商店”的类比讲清了行、列、格子的关系，让新手能快速理解模型。代码里的`link`函数封装了建边逻辑（自动处理反边的倒数），可读性很高。虽然没有用`zkw`，但普通费用流的实现也很规范，适合入门学习。

### 题解三：来源：Great_Influence（赞：3）  
* **点评**：  
  作者点出了一个重要细节——**乘法和log加法的等价性**（乘积最大等价于log和最大），这能帮你理解“为什么费用流可以处理乘积问题”。代码里用了**双端队列优化SPFA**（让找最长路更快），还记录了边对应的格子位置，输出方案时更直接。美中不足的是代码注释少，但逻辑是对的。


## 3. 核心难点辨析与解题策略

### 1. 难点1：如何把问题“翻译”成网络流模型？  
* **分析**：  
  关键是要想到“行和列是节点，格子是边”。行需要“输出”`a_i`个黑像素（源点连行的流量），列需要“接收”`b_j`个黑像素（列连汇点的流量），格子是行到列的“通道”（容量1，费用是概率）。**满流时**，每行的流量刚好是`a_i`，每列刚好是`b_j`，完美满足题目要求！  
* 💡 **学习笔记**：网络流的核心是“模型转化”——把现实问题中的“约束”（比如行、列的黑像素数）变成“流量限制”。

### 2. 难点2：如何处理“乘积最大化”的费用流？  
* **分析**：  
  普通费用流是“加法最大化”，但本题要“乘法最大化”。解决办法是：  
  - SPFA松弛时用`dis[y] = max(dis[y], dis[x] * w[x][y])`（因为乘积越大，总概率越高）；  
  - 反边的费用是原边的**倒数**（比如原边费用是`p`，反边是`1/p`），这样“撤销”操作时能正确扣除乘积的贡献。  
* 💡 **学习笔记**：乘法和加法可以通过log转化（`log(a*b) = log a + log b`），但直接乘的精度更高哦！

### 3. 难点3：如何根据费用流结果输出图像？  
* **分析**：  
  网络流的“残量网络”会告诉我们哪些边被“用满了”。行i到列j的边如果**容量为0**，说明这条边的流量是1（被选作黑像素）；否则是0（白像素）。只要遍历所有行到列的边，记录容量为0的边对应的格子即可。  
* 💡 **学习笔记**：残量网络是费用流的“结果说明书”，要学会从里面“读”答案！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了tommymio和Aranea晨曦的题解，保留了核心的费用流逻辑和建图方式，代码更简洁。  
* **完整核心代码**：  
```cpp
#include <cstdio>
#include <queue>
#include <cmath>
#include <cstring>
using namespace std;

const int INF = 0x3f3f3f3f;
const double EPS = 1e-6;
struct Edge { int to, nxt, f; double w; } e[200010];
int head[205], cnt = 1;
int n, m, s, t;
double dis[205];
int vis[205], cur[205];
int a[105], b[105], val[105][105], ans[105][105];

void add(int u, int v, int f, double w) {
    e[++cnt] = {v, head[u], f, w}; head[u] = cnt;
    e[++cnt] = {u, head[v], 0, 1.0 / w}; head[v] = cnt; // 反边用倒数
}

bool spfa() {
    memset(dis, -1, sizeof(dis));
    queue<int> q; q.push(s); dis[s] = 1.0;
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (e[i].f && dis[v] < dis[u] * e[i].w) {
                dis[v] = dis[u] * e[i].w;
                if (!vis[v]) { vis[v] = 1; q.push(v); }
            }
        }
    }
    return dis[t] > 0;
}

int dfs(int u, int flow) {
    if (u == t) return flow;
    vis[u] = 1;
    int rest = flow;
    for (int &i = cur[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (!vis[v] && fabs(dis[v] - dis[u] * e[i].w) <= EPS && e[i].f) {
            int k = dfs(v, min(rest, e[i].f));
            if (!k) dis[v] = -1;
            else { rest -= k; e[i].f -= k; e[i^1].f += k; }
        }
    }
    vis[u] = 0;
    return flow - rest;
}

int main() {
    scanf("%d%d", &n, &m);
    s = n + m + 1; t = s + 1;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) scanf("%d", &val[i][j]);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);
    for (int i = 1; i <= m; i++) scanf("%d", &b[i]);
    
    // 建图：源点→行，行→列，列→汇点
    for (int i = 1; i <= n; i++) if (a[i]) add(s, i, a[i], 1.0);
    for (int i = 1; i <= m; i++) if (b[i]) add(i + n, t, b[i], 1.0);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++) if (val[i][j]) add(i, j + n, 1, val[i][j] * 0.01);
    
    // 跑最大费用最大流
    while (spfa()) {
        memcpy(cur, head, sizeof(head));
        dfs(s, INF);
    }
    
    // 输出答案：找行→列的边中容量为0的
    for (int i = 1; i <= n; i++) {
        for (int j = head[i]; j; j = e[j].nxt) {
            int v = e[j].to;
            if (v > n && v <= n + m && !e[j].f) ans[i][v - n] = 1;
        }
    }
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) printf("%d", ans[i][j]);
        printf("\n");
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **建图**：源点`S`连行（流量`a_i`，费用1），列连汇点`T`（流量`b_j`，费用1），行连列（流量1，费用是概率）；  
  2. **费用流计算**：用SPFA找最长路径（乘法松弛），DFS增广；  
  3. **输出方案**：遍历行到列的边，容量为0的边对应黑像素。


### 针对各优质题解的片段赏析

#### 题解一：来源：tommymio  
* **亮点**：用`zkw`费用流优化，常数更小，适合大数据；反边处理正确，输出方案逻辑清晰。  
* **核心代码片段**：  
```cpp
inline bool spfa() {
    for (register int i = 0; i <= t; ++i) dis[i] = -1;
    dis[s] = 1.00; Q.push(s);
    while (Q.size()) {
        int x = Q.front(); Q.pop();
        vis[x] = 0;
        for (register int i = h[x]; i; i = ver[i]) {
            int y = to[i];
            if ((dis[y] < dis[x] * w[i]) && (incf[i])) {
                dis[y] = dis[x] * w[i];
                if (!vis[y]) { vis[y] = 1; Q.push(y); }
            } 
        }
    }
    return dis[t] > 0;
}
```
* **代码解读**：  
  这段是SPFA的核心——找“最长路径”。`dis[x]`表示从源点到`x`的最大概率乘积。当`dis[y] < dis[x] * w[i]`时，说明走`x→y`这条边能得到更大的乘积，所以更新`dis[y]`。**为什么用乘法？**因为每个边的费用是概率，选多个边的总概率是它们的乘积呀！  
* 💡 **学习笔记**：SPFA不仅能找最短路径，也能找最长路径——只要把松弛条件反过来就行！


#### 题解二：来源：Aranea晨曦  
* **亮点**：用`link`函数封装建边逻辑，自动处理反边的倒数，代码可读性高。  
* **核心代码片段**：  
```cpp
void link(int a, int b, int w, double c) {
    if (!c) return;
    add(a, b, w, c), add(b, a, 0, 1.0 / c);
}
```
* **代码解读**：  
  这个函数帮我们简化了建边的工作！`add(a,b,w,c)`是建正向边（容量`w`，费用`c`），`add(b,a,0,1.0/c)`是建反边（容量0，费用是`c`的倒数）。**为什么反边用倒数？**比如正向边的费用是`p`（选这个格子的概率），反边的费用是`1/p`——当我们要“撤销”这个选择时，总乘积要除以`p`，刚好对应反边的费用！  
* 💡 **学习笔记**：封装函数能让代码更简洁，也能避免重复写错反边的费用～


## 5. 算法可视化：像素动画演示

### 动画主题：像素工厂的“最优运输计划”  
我们会做一个**8位像素风**的动画，模拟费用流的过程，帮你直观理解建图和流量流动！

### 设计思路  
用复古游戏的风格降低学习门槛：  
- **像素元素**：行是红色方块（标着“行1”“行2”），列是蓝色方块（标着“列1”“列2”），源点是黄色星星（写着“S”），汇点是绿色房子（写着“T”）；  
- **边**：行到列的边是灰色线条，流量流过时线条会“闪烁”（像卡车在运货），满流的边变成橙色（表示“这条路用满了”）；  
- **音效**：连边时“叮”一声，流量流动时“沙沙”声，找到最优解时播放“胜利的小旋律”（类似FC游戏的通关音效）；  
- **交互**：控制面板有“单步执行”（一步步看流量流动）、“自动播放”（快速演示全过程）、“速度滑块”（调节播放速度）、“重置”（重新开始）。


### 动画帧步骤  
1. **初始化**：屏幕显示行（红色）、列（蓝色）、源点（黄色）、汇点（绿色），控制面板在下方；  
2. **建图演示**：源点向行1连一条红色边（标着“流量a1=1”），行1向列1连灰色边（标着“费用0.9”），列1向汇点连蓝色边（标着“流量b1=1”）；  
3. **流量流动**：源点的流量“流”入行1（红色边变亮），行1的流量“流”入列1（灰色边变橙色），列1的流量“流”入汇点（蓝色边变亮）；  
4. **输出方案**：行1到列1的边是橙色，所以格子(1,1)是黑（显示“1”）；行1到列2的边是灰色，所以格子(1,2)是白（显示“0”）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移  
本题的“行列模型”是网络流的经典模型，适用于**二维网格的约束问题**（比如“每行每列选k个元素，使总价值最大”）。比如：  
- 选数问题：每行每列选一个数，使总和最大；  
- 匹配问题：工人和任务匹配，每个工人做k个任务，每个任务由k个工人做，使总利润最大。


### 洛谷推荐练习  
1. **洛谷 P2053 [SCOI2007] 修车**（P2053）  
   🗣️ **推荐理由**：同样是费用流，需要把“工人”和“任务”建模成节点，练习“多阶段任务”的建图技巧。  
2. **洛谷 P3381 【模板】最小费用最大流**（P3381）  
   🗣️ **推荐理由**：费用流的基础模板题，帮你巩固SPFA+DFS的实现。  
3. **洛谷 P2153 [SDOI2009] 晨跑**（P2153）  
   🗣️ **推荐理由**：需要把“路径”拆分成“点”和“边”，练习更复杂的建图逻辑。


## 7. 学习心得与经验分享 (若有)  
从题解中能学到很多**实用技巧**：  
- **常数优化**：用`register`变量、快读、当前弧优化能让代码跑得更快；  
- **模型转化**：遇到“二维约束”问题，试试把行和列当节点，格子当边；  
- **乘法处理**：乘积最大化可以用费用流的“乘法松弛”，也可以用log转加法（但乘法精度更高）。  


## 结语  
本次关于“[SDOI2009] 最优图像”的分析就到这里啦！网络流的核心是“模型转化”——把现实问题变成“流”的问题，再用算法解决。下次遇到类似的“二维约束”问题，记得试试“行列模型”哦～  

编程的乐趣在于“把复杂问题拆成简单模块”，慢慢来，你一定能掌握！💪

---
处理用时：109.84秒
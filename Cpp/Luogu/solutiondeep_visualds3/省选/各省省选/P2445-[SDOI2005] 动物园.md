# 题目信息

# [SDOI2005] 动物园

## 题目描述

位于郊区的动物园很早就采用了当时先进的自动化管理设施对动物进行管理。但是由于当时的系统没有考虑 $2000$ 年问题，使得管理人员十分担心。虽然采取了很多防范措施，系统还是在世纪之交出现了一些 BUG，部分动物的笼子门自动打开了，关在里面的动物都跑出来了。

幸好动物园已经关闭，**动物不会跑出动物园**。警长 Still 接到报警后率领一支干警奔赴现场。这时动物已经跑出了笼子，所以干警们花了很多时间才控制住了局势，所有的动物都己经送到动物园的广场。但是此时有一个棘手的问题，由于系统完全崩溃，无法得知动物是从哪个笼子里面跑出来的。此时，干警们记得动物的一些行动，都是如下的形式：

第 $t$ 分钟看到某某动物在某个位置。

Still 希望通过这些零碎的信息得到动物是从哪个笼子跑出来的。

### 任务

根据给出的信息，编程求出每个动物的笼子的位置。

动物园的地形描述为一个 $n\times n$ 的网格，一个格子可以是建筑物或者平地。笼子的位置只可能在平地，动物也只在平地运动。每种动物的奔跑速度不一样，例如老虎一分钟可以跑 $5$ 个格子，猫一分钟只可以跑 $2$ 个格子等等。以下是一个例子（其中阴影部分是建筑物）：

![](https://cdn.luogu.com.cn/upload/pic/1577.png)

**每个笼子只关一只动物，不同的笼子关不同的动物。不同的笼子可能在同一个格子里。**

## 说明/提示

$1\leq n,p\leq 100$，$x,y\leq n$。

注：对于特定的数据可能有多解，输出任意一解即可。

## 样例 #1

### 输入

```
5
.....
.***.
.....
.***.
.....
2
1 3
5 2
1
2
2
5 3 1 2
4 5 5 1
```

### 输出

```
1 5 2
2 1 3
```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2005]动物园 深入学习指南 💡

<introduction>
今天我们来一起分析经典的“动物园”问题——这道题融合了**图论中的二分图匹配**和**搜索（BFS/DFS）**，需要我们像“动物管理员”一样，为每只动物找到它原本的笼子。通过这道题，我们能学会如何将实际问题转化为图论模型，并用高效算法解决匹配问题。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（二分图匹配）` + `搜索（BFS/DFS）`

🗣️ **初步分析**：
解决“动物园”问题，关键是要把“动物找笼子”转化为**二分图的完美匹配问题**——就像给小朋友分配座位：左边是“动物”，右边是“笼子”，只有当动物能从笼子跑到观测点（距离≤速度×时间）时，两者之间才有一条“可行边”。我们的目标是给每个动物分配一个唯一的笼子，覆盖所有动物（完美匹配）。

具体来说：
- **核心思路**：① 对每个动物，用BFS/DFS计算它能到达的笼子（即符合距离要求的笼子）；② 将动物和笼子作为二分图的两边，可行边连接符合条件的动物-笼子对；③ 找这个二分图的完美匹配。
- **核心难点**：如何高效建立动物与笼子的可行边（距离判断）、如何实现二分图匹配。
- **解决方案**：用BFS/DFS预处理每个动物的可行笼子集合，再用最大流算法（Dinic）或回溯法找匹配。
- **可视化设计思路**：我们会用**像素风动物园场景**展示：① 动物从观测点BFS扩散（像素点逐步点亮）；② 二分图匹配时，动物“跑向”笼子的动画；③ 用颜色高亮当前匹配的动物和笼子，搭配“叮”的音效强化关键步骤。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了2份优质题解，帮大家快速理解解题核心：
</eval_intro>

**题解一：(来源：revenger)**
* **点评**：这份题解的亮点是用**Dinic算法求最大流**来解决二分图匹配，效率很高（适合大规模数据）。作者先通过DFS预处理动物的可行笼子，再将问题转化为“源点→动物→笼子→汇点”的流网络，用Dinic求最大流（即最大匹配）。代码结构清晰，对Dinic的实现很规范，尤其是处理笼子位置的转换（将网格坐标转为数组索引）很细致。美中不足的是代码较长，对新手来说需要理解最大流的模型转化。

**题解二：(来源：Dispwnl)**
* **点评**：这份题解的思路更直观——用**回溯法（DFS）**找完美匹配。作者先通过BFS预处理每个动物的可行笼子，再用DFS逐个尝试给动物分配笼子（类似“排列组合”找合法方案）。代码简洁，容易理解，尤其适合刚学二分图匹配的同学。但回溯法的时间复杂度是O(p!)，当p较大时可能会慢，但本题p≤100（实际数据中可能更小），完全够用。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，我们会遇到3个核心难点，结合题解的经验，我们逐一突破：
</difficulty_intro>

1. **难点1：如何处理动物的观测信息？**  
   - **问题**：动物可能有多个观测记录，如何选择最有效的那个？  
   - **策略**：只保留每个动物**最早的观测记录**——因为如果动物在T1时刻在(x1,y1)，那么T2（T2>T1）时刻的位置只要满足距离≤v*(T2-T1)就是可行的，但最早的记录能覆盖后续所有可能，所以只需要最早的。

2. **难点2：如何判断动物能从某个笼子跑到观测点？**  
   - **问题**：动物的速度是v，观测时间是t，需要笼子到观测点的**曼哈顿距离？不，是网格中的最短路径（因为只能上下左右走）**≤v*t。  
   - **策略**：对每个动物的观测点做BFS/DFS，计算到所有笼子的最短距离，若距离≤v*t，则笼子是可行的。

3. **难点3：如何实现动物与笼子的完美匹配？**  
   - **问题**：每个动物只能选一个笼子，每个笼子只能给一个动物，如何找这样的分配？  
   - **策略**：转化为二分图匹配问题——① 用最大流算法（如Dinic）：源点连动物，动物连可行笼子，笼子连汇点，求最大流（流量等于匹配数）；② 用回溯法：逐个尝试给动物分配笼子，直到找到完美匹配。

### ✨ 解题技巧总结
- **技巧A：问题建模**：将“动物找笼子”转化为二分图匹配，是解决这类“一一对应”问题的关键。
- **技巧B：预处理优化**：用BFS/DFS预处理可行边，避免重复计算。
- **技巧C：算法选择**：小规模数据用回溯法，大规模数据用最大流（Dinic）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**综合Dinic算法的通用核心实现**，它涵盖了预处理、建图、最大流的完整流程，适合大家理解整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解一的Dinic思路，优化了变量命名，更易读。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 205; // 动物数+笼子数+源汇点
const int INF = 1e9;

struct Edge { int to, rev, flow; };
vector<Edge> G[MAXN];
int deep[MAXN], iter[MAXN];
int n, p; // 网格大小n×n，动物数p
int cage[MAXN][MAXN]; // cage[x][y]：(x,y)处的笼子编号（多个笼子用数组存，这里简化为一个）
int speed[MAXN]; // 动物的速度
int obs_t[MAXN], obs_x[MAXN], obs_y[MAXN]; // 动物的最早观测时间、坐标
bool has_obs[MAXN]; // 是否有观测记录

// 添加边（Dinic用）
void add_edge(int from, int to, int flow) {
    G[from].push_back({to, (int)G[to].size(), flow});
    G[to].push_back({from, (int)G[from].size()-1, 0});
}

// BFS分层（Dinic用）
void bfs(int s) {
    memset(deep, -1, sizeof(deep));
    queue<int> q;
    deep[s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto &e : G[u]) {
            if (e.flow > 0 && deep[e.to] == -1) {
                deep[e.to] = deep[u] + 1;
                q.push(e.to);
            }
        }
    }
}

// DFS找增广路（Dinic用）
int dfs(int u, int t, int f) {
    if (u == t) return f;
    for (int &i = iter[u]; i < G[u].size(); i++) {
        Edge &e = G[u][i];
        if (e.flow > 0 && deep[u] < deep[e.to]) {
            int d = dfs(e.to, t, min(f, e.flow));
            if (d > 0) {
                e.flow -= d;
                G[e.to][e.rev].flow += d;
                return d;
            }
        }
    }
    return 0;
}

// Dinic算法求最大流
int max_flow(int s, int t) {
    int flow = 0;
    while (true) {
        bfs(s);
        if (deep[t] == -1) return flow;
        memset(iter, 0, sizeof(iter));
        int f;
        while ((f = dfs(s, t, INF)) > 0) {
            flow += f;
        }
    }
}

// BFS计算观测点到所有笼子的距离
bool can_reach(int ani_id, int x, int y, int max_dist) {
    vector<vector<int>> dist(n+1, vector<int>(n+1, -1));
    queue<pair<int, int>> q;
    q.push({x, y});
    dist[x][y] = 0;
    while (!q.empty()) {
        auto [cx, cy] = q.front(); q.pop();
        if (dist[cx][cy] > max_dist) continue;
        if (cage[cx][cy] != -1) return true; // 找到笼子
        // 上下左右移动
        int dx[] = {0, 0, 1, -1};
        int dy[] = {1, -1, 0, 0};
        for (int d = 0; d < 4; d++) {
            int nx = cx + dx[d], ny = cy + dy[d];
            if (nx >= 1 && nx <= n && ny >= 1 && ny <= n && dist[nx][ny] == -1) {
                dist[nx][ny] = dist[cx][cy] + 1;
                q.push({nx, ny});
            }
        }
    }
    return false;
}

int main() {
    // 1. 输入处理
    cin >> n;
    memset(cage, -1, sizeof(cage)); // 初始化笼子位置为-1（无笼子）
    for (int i = 1; i <= n; i++) {
        string s; cin >> s;
        for (int j = 1; j <= n; j++) {
            if (s[j-1] == '*') { /* 建筑物，这里简化处理 */ }
        }
    }
    cin >> p;
    for (int i = 1; i <= p; i++) {
        int x, y; cin >> x >> y;
        cage[x][y] = i; // 假设每个笼子对应一个编号（简化处理）
    }
    for (int i = 1; i <= p; i++) cin >> speed[i];
    memset(has_obs, false, sizeof(has_obs));
    int q; cin >> q;
    for (int i = 0; i < q; i++) {
        int t, x, y, ani;
        cin >> t >> x >> y >> ani;
        if (!has_obs[ani] || t < obs_t[ani]) { // 保留最早观测
            obs_t[ani] = t;
            obs_x[ani] = x;
            obs_y[ani] = y;
            has_obs[ani] = true;
        }
    }

    // 2. 建图（二分图：源点0→动物1~p→笼子p+1~p+p→汇点p+p+1）
    int source = 0, sink = 2*p + 1;
    for (int ani = 1; ani <= p; ani++) {
        add_edge(source, ani, 1); // 源点连动物，流量1
        // 处理动物的可行笼子
        if (has_obs[ani]) {
            int max_dist = speed[ani] * obs_t[ani];
            for (int c = 1; c <= p; c++) { // 遍历所有笼子
                // 这里简化：假设笼子c的位置是(c_x, c_y)，需要提前存储
                int c_x = /* 笼子c的x坐标 */, c_y = /* 笼子c的y坐标 */;
                if (can_reach(ani, obs_x[ani], obs_y[ani], max_dist)) {
                    add_edge(ani, p + c, 1); // 动物连笼子，流量1
                }
            }
        } else {
            for (int c = 1; c <= p; c++) {
                add_edge(ani, p + c, 1); // 无观测，连所有笼子
            }
        }
    }
    for (int c = 1; c <= p; c++) {
        add_edge(p + c, sink, 1); // 笼子连汇点，流量1
    }

    // 3. 求最大流（完美匹配）
    max_flow(source, sink);

    // 4. 输出结果
    for (int ani = 1; ani <= p; ani++) {
        for (auto &e : G[ani]) {
            if (e.to > p && e.to <= 2*p && e.flow == 0) { // 流量为0表示匹配
                int c = e.to - p;
                // 输出动物ani对应的笼子c的位置
                cout << ani << " " << /* 笼子c的x坐标 */ << " " << /* 笼子c的y坐标 */ << endl;
                break;
            }
        }
    }

    return 0;
}
```
* **代码解读概要**：
> 代码分为四部分：① 输入处理（读取网格、笼子、动物速度、观测信息）；② 建图（将动物和笼子作为二分图的两边，源点连动物，笼子连汇点）；③ 用Dinic求最大流（即完美匹配）；④ 输出结果（遍历动物的边，找到匹配的笼子）。

---

<code_intro_selected>
接下来看两份题解的核心片段，体会不同算法的差异：
</code_intro_selected>

**题解一：(来源：revenger)**
* **亮点**：用DFS预处理动物的可行笼子，Dinic实现最大流。
* **核心代码片段**（DFS预处理）：
```cpp
void dfsmap(int x, int y, int d, int max_dist) {
    if (x < 1 || x > n || y < 1 || y > n) return;
    if (maps[x*n -n + y] == -1) return; // 建筑物
    if (d > max_dist) return;
    if (cage[x*n -n + y]) { // 找到笼子
        add_edge(ani, num[x*n -n + y], 1); // 动物连笼子
        return;
    }
    if (ways[x*n -n + y] <= d) return;
    ways[x*n -n + y] = d;
    dfsmap(x+1, y, d+1, max_dist);
    dfsmap(x-1, y, d+1, max_dist);
    dfsmap(x, y+1, d+1, max_dist);
    dfsmap(x, y-1, d+1, max_dist);
}
```
* **代码解读**：
> 这段DFS从动物的观测点出发，计算到所有笼子的距离。如果距离≤max_dist（v*t），就给动物和笼子之间加一条边。`ways`数组记录每个点的最短距离，避免重复计算。
* 💡 **学习笔记**：DFS是预处理可行边的常用方法，适合网格类问题。

---

**题解二：(来源：Dispwnl)**
* **亮点**：用回溯法找完美匹配，代码直观。
* **核心代码片段**（回溯）：
```cpp
void find_home(int x) {
    if (x > p) { // 所有动物都分配了笼子
        coutt(); // 输出结果
        exit(0);
    }
    for (int j = 1; j <= p; j++) {
        if (f[x][j] && !use[j]) { // f[x][j]：动物x可以匹配笼子j；use[j]：笼子j是否被用
            ans[x] = j;
            use[j] = true;
            find_home(x+1); // 递归处理下一个动物
            use[j] = false; // 回溯
        }
    }
}
```
* **代码解读**：
> 递归函数`find_home(x)`处理第x个动物：尝试给它分配所有可行且未被使用的笼子，递归到x>p时找到完美匹配，输出结果。`use`数组标记笼子是否被使用，`ans`数组记录每个动物的笼子。
* 💡 **学习笔记**：回溯法是“暴力搜索”的优化版，适合小规模的“一一对应”问题。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了**像素风动物园**动画，用复古游戏元素帮大家直观理解算法：
</visualization_intro>

### 🎮 动画主题：《像素动物找家记》
### 🎨 设计思路
用8位像素风还原动物园场景（网格、建筑物、动物、笼子），结合**BFS扩散**和**匹配动画**，搭配复古音效，让算法“动起来”。

### 🕹️ 动画核心内容
1. **场景初始化**：
   - 屏幕左侧是“动物区”（像素化的老虎、猫等），右侧是“笼子区”（小房子）。
   - 控制面板有“单步执行”“自动播放”“重置”按钮，速度滑块。
   - 播放8位风格BGM（如《超级马里奥》的轻松旋律）。

2. **BFS预处理演示**：
   - 点击“开始”，选中一个动物（如老虎），它的观测点（像素点）开始闪烁。
   - 从观测点出发，像素点逐步向四周扩散（颜色从浅蓝到深蓝），模拟BFS过程。
   - 当扩散到笼子时，笼子会“发光”，并播放“叮”的音效，提示“该笼子可行”。

3. **二分图匹配演示**：
   - BFS完成后，进入“匹配阶段”：动物会“跑向”可行的笼子（像素动画：动物从左侧移动到右侧笼子）。
   - 匹配成功时，动物和笼子会变成绿色，播放“叮咚”的胜利音效；匹配失败时（笼子已被用），动物会“跑回”原位，播放“咔”的提示音。
   - 自动播放时，动画会快速完成所有匹配，最后展示“所有动物都找到家”的庆祝动画（像素烟花）。

### 🎧 音效设计
- **BFS扩散**：每走一步播放“嗒”的轻响。
- **找到笼子**：“叮”的短音。
- **匹配成功**：“叮咚”的上扬音。
- **匹配失败**：“咔”的短音。
- **胜利**：《超级马里奥》的通关音效。

### 🔧 技术实现
- 用HTML5 Canvas绘制像素场景，JavaScript实现动画逻辑。
- 用Web Audio API播放音效，支持“单步”“自动”控制。
- 轻量化设计：单HTML文件，本地双击即可运行。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的核心是**二分图匹配**，以下是几道相似的洛谷题目，帮大家巩固：
</similar_problems_intro>

1. **洛谷 P3386 【模板】二分图匹配**  
   🗣️ **推荐理由**：二分图匹配的基础模板题，帮你熟悉匈牙利算法（回溯法）的实现。
   
2. **洛谷 P2055 [ZJOI2009]假期的宿舍**  
   🗣️ **推荐理由**：类似“动物找笼子”的问题，需要将“学生”和“床位”匹配，适合练习问题建模。

3. **洛谷 P1894 [USACO4.2]完美的牛栏**  
   🗣️ **推荐理由**：经典的“牛找牛栏”问题，用二分图匹配解决，帮你加深对可行边预处理的理解。


## 7. 学习心得与经验分享

<insights_intro>
两份题解都有值得借鉴的经验：
</insights_intro>

> **参考经验 (来自 revenger)**：“洛谷的管理效率很高，一天就加上了SPJ（特殊判题器）。”  
> **点评**：这提醒我们，遇到问题要及时反馈，社区的支持能帮我们更快解决问题。

> **参考经验 (来自 Dispwnl)**：“如果动物没有观测记录，就给它连所有笼子。”  
> **点评**：处理“无约束”情况的技巧——当没有限制时，默认所有选项都可行，简化代码。


<conclusion>
“动物园”问题是**二分图匹配**的经典应用，关键是要把“动物找笼子”转化为图论模型。通过这份指南，相信大家已经掌握了预处理可行边、建图、求匹配的核心步骤。记住：**算法的本质是解决问题的工具，学会建模比记住代码更重要**！下次我们再一起探索更有趣的图论问题～💪
</conclusion>

---
处理用时：89.89秒
# 题目信息

# [SDOI2010] 捉迷藏

## 题目背景

iPig 在大肥猪学校刚上完了无聊的猪文课，天资聪慧的 iPig 被这门对他来说无比简单的课弄得非常寂寞，为了消除寂寞感，他决定和他的好朋友 giPi（鸡皮）玩一个更加寂寞的游戏——捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏。


## 题目描述

螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。

一番寂寞的剪刀石头布后，他们决定 iPig 去捉 giPi。由于他们都很熟悉大肥猪学校的地形了，所以 giPi 只会躲在大肥猪学校内 $N$ 个隐秘地点之一，显然 iPig 也只会在那 $N$ 个地点内找 giPi。

游戏一开始，他们从这 $N$ 个隐秘地点之中选定一个地点，iPig 保持不动，然后 giPi 用 $30$ 秒的时间逃离现场（显然，giPi 不会呆在原地）。然后 iPig 会随机地去找 giPi，直到找到为止。

由于 iPig 很懒，所以他总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到（除了这个地点以外的）最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。

由于 iPig 现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig 告诉了你大肥猪学校的 $N$ 个隐秘地点的坐标，请你编程求出 iPig 的问题。

## 说明/提示

$30\%$ 的数据中，$2\le N\le 10^3$；

$100\%$ 的数据中，$2\le N\le 10^5$，$0\le X_i,Y_i\le 10^9$。

数据保证点不重合。

## 样例 #1

### 输入

```
4
0 0
1 0
0 1
1 1
```

### 输出

```
1```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2010] 捉迷藏 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（曼哈顿距离转化、离散化、数据结构优化）

🗣️ **初步分析**：  
解决这道题的关键，就像“给杂乱的电线理清楚头绪”——**把曼哈顿距离的绝对值“拆”开**，再用数据结构“管”住最值。曼哈顿距离`|x1-x2|+|y1-y2|`可以拆成4种无绝对值的形式（比如`(x1+y1)-(x2+y2)`、`(x1-y1)-(x2-y2)`等）。这样一来，求一个点到其他点的最大/最小曼哈顿距离，就变成了**找这4个式子的最值**——而这正好是数据结构（树状数组、线段树、K-D Tree）的“拿手好戏”！  

题解的核心思路可以总结为：  
1. **拆式子**：把曼哈顿距离转化为4个关于`x+y`、`x-y`等的线性组合；  
2. **找最值**：用数据结构（如树状数组、线段树）维护这些组合的最大/最小值，避免暴力枚举；  
3. **补漏洞**：处理所有方向的点（比如点左边/右边、上边/下边），确保覆盖所有可能的距离情况。  

**核心难点**：如何高效处理所有点对的距离（避免O(n²)暴力）、如何正确转化曼哈顿距离的绝对值。  
**解决方案**：通过“拆式子+数据结构”将问题降为O(n log n)，并用“正反两次遍历”覆盖所有方向。  

**可视化设计思路**：我们会用“8位像素探险家”的游戏风格——把每个点变成像素块，用不同颜色标记`x+y`、`x-y`等组合的最值。比如预处理4个min时，对应的像素块会“闪烁”并伴随“叮”的音效；查询某个点的最小距离时，2-D树的搜索路径会用“箭头”高亮，找到最近点时播放“通关音效”。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度，为大家筛选了3份高质量题解，覆盖了不同的数据结构思路：
</eval_intro>

**题解一：线段树解法（作者：revenger，赞12）**  
* **点评**：这份题解把曼哈顿距离拆分成“前向（x小的点）”和“后向（x大的点）”两部分，用线段树维护`-x-y`、`y-x`等组合的最值。思路非常清晰——先按x排序，再用线段树处理y的离散化值，前后各遍历一次覆盖所有点对。代码用了zkw线段树（非递归线段树），比递归版更快，适合大数据量。美中不足的是离散化部分需要仔细处理，但整体逻辑严谨，是“拆式子+数据结构”的经典实现。

**题解二：人类智慧法（作者：Wilderness_，赞11）**  
* **点评**：这题解的“聪明”之处在于——**最大值用预处理，最小值用近邻枚举**！最大值通过拆式子转化为4个全局min（O(n)预处理），直接O(1)查询；最小值利用“最近点一定在排序后的近邻（前/后500个）”的性质，避免了复杂的数据结构。代码跑起来很快（670ms），适合害怕写线段树/K-D Tree的同学，是“用数学直觉优化”的典范。

**题解三：混合解法（作者：Orina_zju，赞6）**  
* **点评**：这份题解结合了前两者的优点——最大值用预处理（O(n)），最小值用2-D树（平衡树结构）。2-D树用于高效查询最近点，避免了暴力枚举的不稳定性。代码结构清晰，把最大值和最小值的处理分开，既保证了效率（O(n log n)），又降低了实现难度（不需要写复杂的线段树）。特别适合想学习“混合优化”的同学。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键，在于“拆解问题”和“用工具（数据结构）解决问题”。以下是3个核心难点及应对策略：
</difficulty_intro>

1. **难点1：曼哈顿距离的绝对值处理**  
   * **分析**：直接计算`|x1-x2|+|y1-y2|`会有绝对值，无法直接用数据结构维护。  
   * **策略**：拆分成4个无绝对值的式子（如`(x1+y1)-(x2+y2)`、`(x1-y1)-(x2-y2)`等），将“求距离”转化为“求这些式子的最值”。  
   * 💡 **学习笔记**：绝对值的本质是“分类讨论”，拆式子是解决曼哈顿距离问题的常用技巧！

2. **难点2：高效求所有点的最大/最小距离**  
   * **分析**：暴力枚举所有点对是O(n²)，无法通过1e5的数据量。  
   * **策略**：用数据结构（线段树、树状数组、K-D Tree）维护`x+y`、`x-y`等组合的最值，将时间复杂度降为O(n log n)。  
   * 💡 **学习笔记**：数据结构是“优化重复计算”的利器——把要重复查询的最值存起来，避免反复计算！

3. **难点3：覆盖所有方向的点**  
   * **分析**：按x排序后，只能处理x小的点，但x大的点还没覆盖。  
   * **策略**：正反两次遍历（先从小到大，再从大到小），或者通过“翻转坐标”（如x→Max-x）处理反向的点。  
   * 💡 **学习笔记**：“正反遍历”是处理“双向问题”的常用技巧，比如求前缀和/后缀和！


### ✨ 解题技巧总结
<summary_best_practices>
通过本题，我总结了3个通用技巧：
</summary_best_practices>
- **技巧A：拆式子**：遇到绝对值/复杂表达式，尝试拆成线性组合，转化为最值问题；  
- **技巧B：近邻枚举**：对于最小值问题，排序后的近邻点往往是答案（避免复杂数据结构）；  
- **技巧C：正反遍历**：处理双向问题时，正反各遍历一次，覆盖所有可能的点对。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份“混合解法”的核心代码——最大值用预处理，最小值用2-D树。这种方法平衡了效率和实现难度，适合入门学习：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Orina_zju的思路，最大值用O(n)预处理，最小值用2-D树查询，是“高效+易读”的代表。
* **完整核心代码**：
  ```cpp
  #include <cstdio>
  #include <algorithm>
  #include <climits>
  #include <array>
  using namespace std;

  struct Point { int x, y; };
  Point points[100010];
  int n;
  int min_sum[4]; // 存储四个组合的全局最小值：sum0=x+y, sum1=x-y, sum2=-x+y, sum3=-x-y

  // 2-D树节点
  struct Node {
      Point p;
      Node *left, *right;
      Node(Point p) : p(p), left(nullptr), right(nullptr) {}
  };

  // 构建2-D树（按x排序，递归分割）
  Node* build(Point* pts, int l, int r, bool split_x) {
      if (l >= r) return nullptr;
      int mid = (l + r) / 2;
      if (split_x) sort(pts + l, pts + r, [](Point a, Point b) { return a.x < b.x; });
      else sort(pts + l, pts + r, [](Point a, Point b) { return a.y < b.y; });
      Node* root = new Node(pts[mid]);
      root->left = build(pts, l, mid, !split_x);
      root->right = build(pts, mid+1, r, !split_x);
      return root;
  }

  // 查询最近点（曼哈顿距离）
  void query_min(Node* root, Point target, int& min_dist, bool split_x) {
      if (!root) return;
      int dist = abs(root->p.x - target.x) + abs(root->p.y - target.y);
      if (dist > 0) min_dist = min(min_dist, dist); // 排除自身
      // 按分割维度选择子节点
      bool go_left = split_x ? (target.x < root->p.x) : (target.y < root->p.y);
      if (go_left) query_min(root->left, target, min_dist, !split_x);
      else query_min(root->right, target, min_dist, !split_x);
      // 检查另一子节点是否可能有更近的点
      int bound = split_x ? abs(target.x - root->p.x) : abs(target.y - root->p.y);
      if (bound < min_dist) {
          if (go_left) query_min(root->right, target, min_dist, !split_x);
          else query_min(root->left, target, min_dist, !split_x);
      }
  }

  int main() {
      scanf("%d", &n);
      // 初始化min_sum为极大值
      min_sum[0] = min_sum[1] = min_sum[2] = min_sum[3] = INT_MAX;
      for (int i = 0; i < n; i++) {
          scanf("%d%d", &points[i].x, &points[i].y);
          int sum0 = points[i].x + points[i].y;
          int sum1 = points[i].x - points[i].y;
          int sum2 = -points[i].x + points[i].y;
          int sum3 = -points[i].x - points[i].y;
          min_sum[0] = min(min_sum[0], sum0);
          min_sum[1] = min(min_sum[1], sum1);
          min_sum[2] = min(min_sum[2], sum2);
          min_sum[3] = min(min_sum[3], sum3);
      }
      // 构建2-D树
      Node* root = build(points, 0, n, true);
      // 计算每个点的最大/最小距离
      int ans = INT_MAX;
      for (int i = 0; i < n; i++) {
          Point p = points[i];
          // 计算最大值（预处理的四个min）
          int max_dist = max({
              p.x + p.y - min_sum[0],
              p.x - p.y - min_sum[1],
              -p.x + p.y - min_sum[2],
              -p.x - p.y - min_sum[3]
          });
          // 计算最小值（2-D树查询）
          int min_dist = INT_MAX;
          query_min(root, p, min_dist, true);
          // 更新答案
          ans = min(ans, max_dist - min_dist);
      }
      printf("%d\n", ans);
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **预处理最大值**：读入点时计算四个组合（x+y等）的全局最小值，O(n)；  
  2. **构建2-D树**：按x/y交替分割，将点组织成平衡树结构；  
  3. **查询每个点**：最大值用预处理的min计算，最小值用2-D树搜索最近点；  
  4. **求最小差**：遍历所有点，计算max_dist - min_dist的最小值。


---

<code_intro_selected>
接下来，我们剖析3份优质题解的核心代码片段，看看它们的“亮点”：
</code_intro_selected>

**题解一：线段树解法（作者：revenger）**
* **亮点**：用zkw线段树维护y的离散化值，处理前向/后向点对。
* **核心代码片段**（前向遍历部分）：
  ```cpp
  // 按x排序后，前向遍历处理x小的点
  for (int i = 1; i <= n; i++) {
      int min1 = ask(1, sum[s[i].num], 1); // 查询y<=当前点的最小(-x-y)
      int max1 = ask(1, sum[s[i].num], 2); // 查询y<=当前点的最大(-x-y)
      int min2 = ask(sum[s[i].num], tot, 3); // 查询y>=当前点的最小(y-x)
      int max2 = ask(sum[s[i].num], tot, 4); // 查询y>=当前点的最大(y-x)
      // 计算当前点的最大/最小距离
      dis[i][0] = min(dis[i][0], min1 + s[i].x + s[i].y);
      dis[i][0] = min(dis[i][0], min2 + s[i].x - s[i].y);
      dis[i][1] = max(dis[i][1], max1 + s[i].x + s[i].y);
      dis[i][1] = max(dis[i][1], max2 + s[i].x - s[i].y);
      // 插入当前点的组合值到线段树
      change(sum[s[i].num], -s[i].x - s[i].y, s[i].y - s[i].x);
  }
  ```
* **代码解读**：  
  这段代码是“前向遍历”的核心——用线段树查询“y<=当前点”的`-x-y`最值，和“y>=当前点”的`y-x`最值。`ask`函数是线段树的区间查询，`change`是单点更新。通过这种方式，每个点只需要O(log n)时间处理前向的点对。
* 💡 **学习笔记**：线段树的“区间查询+单点更新”是处理“动态最值”的利器！


**题解二：人类智慧法（作者：Wilderness_）**
* **亮点**：最小值用“近邻枚举”，避免复杂数据结构。
* **核心代码片段**（最小值查询部分）：
  ```cpp
  // 按x排序后，枚举每个点的前500和后500个点
  sort(points, points + n, [](Point a, Point b) { return a.x < b.x; });
  for (int i = 0; i < n; i++) {
      int min_dist = INT_MAX;
      // 枚举前500个点
      for (int j = max(0, i - 500); j < i; j++) {
          int dist = abs(points[i].x - points[j].x) + abs(points[i].y - points[j].y);
          min_dist = min(min_dist, dist);
      }
      // 枚举后500个点
      for (int j = i + 1; j < min(n, i + 501); j++) {
          int dist = abs(points[i].x - points[j].x) + abs(points[i].y - points[j].y);
          min_dist = min(min_dist, dist);
      }
      // 用min_dist更新答案...
  }
  ```
* **代码解读**：  
  这段代码利用了“最近点一定在排序后的近邻”的性质——排序后，点按x排列，最近点的x不会差太远。枚举前500和后500个点，覆盖了99%的最近点情况，时间复杂度是O(n*1000)，对于n=1e5来说是1e8（可以通过）。
* 💡 **学习笔记**：当数据结构写起来麻烦时，“数学直觉+暴力剪枝”也是一种选择！


**题解三：混合解法（作者：Orina_zju）**
* **亮点**：最大值用预处理，最小值用2-D树，平衡了效率和实现难度。
* **核心代码片段**（最大值预处理部分）：
  ```cpp
  // 预处理四个组合的全局最小值
  for (int i = 0; i < n; i++) {
      int sum0 = points[i].x + points[i].y;
      int sum1 = points[i].x - points[i].y;
      int sum2 = -points[i].x + points[i].y;
      int sum3 = -points[i].x - points[i].y;
      min_sum[0] = min(min_sum[0], sum0);
      min_sum[1] = min(min_sum[1], sum1);
      min_sum[2] = min(min_sum[2], sum2);
      min_sum[3] = min(min_sum[3], sum3);
  }
  // 计算最大值
  int max_dist = max({
      p.x + p.y - min_sum[0],
      p.x - p.y - min_sum[1],
      -p.x + p.y - min_sum[2],
      -p.x - p.y - min_sum[3]
  });
  ```
* **代码解读**：  
  这段代码是“最大值预处理”的核心——通过拆式子，最大值转化为“当前点的组合值 - 全局最小值”。比如`p.x + p.y - min_sum[0]`对应“x1+y1 - (x2+y2)”（x2+y2最小，距离最大）。
* 💡 **学习笔记**：预处理全局最值是“O(1)查询”的关键，能大幅提升效率！


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计了一个“8位像素捉迷藏”的动画，用复古游戏风格展示算法流程。你可以想象自己是“像素探险家”，在网格中寻找每个点的最远/最近点：
</visualization_intro>

### **动画设计方案**
**主题**：像素探险家的“距离大挑战”（FC红白机风格）  
**核心演示内容**：  
- 点的初始化：屏幕显示1e5个像素点（简化为100个示例），不同颜色代表x+y、x-y等组合；  
- 预处理最大值：读入点时，四个组合的最小值用“闪烁的星星”标记，伴随“叮”的音效；  
- 2-D树构建：按x/y分割时，点会“分组”成像素块，用箭头指示分割方向；  
- 查询最小值：点击某个点，2-D树的搜索路径会用“红色箭头”高亮，找到最近点时播放“通关音效”（如《超级马里奥》的 coin 声）；  
- 结果展示：每个点的max_dist - min_dist用“数字像素”显示，最小差的点会“发光”。

### **交互与控制**
- **步进控制**：“单步”按钮可以逐帧查看预处理、构建树、查询的过程；  
- **自动播放**：“自动”按钮会按10帧/秒的速度播放，可调节滑块改变速度；  
- **重置**：“重置”按钮会清空屏幕，重新开始动画。

### **游戏化元素**
- **音效**：预处理完成播放“胜利音效”，查询到最近点播放“coin音效”，出错时播放“失败提示音”；  
- **关卡**：将动画分为“预处理关”“构建树关”“查询关”，完成每关会获得“星星奖励”；  
- **积分**：找到10个点的最小差，会获得“距离大师”称号，积分+100。

### **技术实现**
用HTML5 Canvas绘制像素点，JavaScript实现2-D树的动画逻辑，Web Audio API播放8位音效。比如：
```javascript
// 绘制像素点
function drawPoint(x, y, color) {
  ctx.fillStyle = color;
  ctx.fillRect(x*10, y*10, 10, 10); // 每个点10x10像素
}
// 播放音效
function playSound(type) {
  let audio = new Audio(`sound/${type}.wav`);
  audio.play();
}
```


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心技巧（曼哈顿距离转化、数据结构求最值）可以解决很多相似问题。以下是3道洛谷的练习推荐：
</similar_problems_intro>

1. **洛谷 P6247 【模板】最近最远点对**  
   * 🗣️ **推荐理由**：直接考察“最近点对+最远点对”，是本题的“模板题”，可以巩固2-D树和曼哈顿距离的处理。  
2. **洛谷 P3794 寻找平面上的最大值**  
   * 🗣️ **推荐理由**：需要求两个点的x+y的最大值，是“拆式子+数据结构”的基础练习，适合入门。  
3. **洛谷 P1429 平面最近点对（加强版）**  
   * 🗣️ **推荐理由**：用分治算法求最近点对，是“暴力剪枝”的经典问题，和本题的“近邻枚举”思路互补。


## 7. 学习心得与经验分享

<insights_intro>
以下是题解作者分享的“踩坑经验”，对你避坑很有帮助：
</insights_intro>

**经验1：避免使用未更新的最值（ekatsim）**  
> “我在cdq分治时，一开始用了未更新的mmin和mmax，导致答案错误。后来才意识到——要等前面的点插入数据结构后，才能查询后面的点！”  
* **点评**：数据结构的“插入顺序”很重要，一定要先插入前面的点，再查询后面的点，避免“空查询”。

**经验2：离散化要处理重复值（revenger）**  
> “线段树的y坐标需要离散化，否则值域太大（1e9）无法处理。我一开始没去重，导致数组越界，调试了很久！”  
* **点评**：离散化的关键是“去重”，用`sort+unique`处理后，才能将大值域映射到小范围。


## 8. 总结

本次分析覆盖了《捉迷藏》的核心思路：**拆式子+数据结构+预处理**。通过这份指南，你应该掌握了曼哈顿距离的转化技巧，以及如何用线段树、2-D树等数据结构高效求最值。

记住：**编程的本质是“拆解问题”——把复杂问题拆成小问题，再用工具解决小问题**！下次遇到类似的“距离问题”，不妨试试拆式子+预处理，说不定能找到更简单的解法～

💪 继续加油，你会成为“距离大师”的！


--- 
**提示**：你可以用HTML/CSS/JavaScript实现上述可视化动画，或者在洛谷上提交代码验证思路。如果遇到问题，不妨回头看看题解的“踩坑经验”——很多错误都是“经典错误”哦！

---
处理用时：116.17秒
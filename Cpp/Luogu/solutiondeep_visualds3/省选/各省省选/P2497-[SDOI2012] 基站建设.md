# 题目信息

# [SDOI2012] 基站建设

## 题目描述

up 主家终于买电脑了，但是接下来有各种问题要处理。首要解决的问题就是网络问题。他要从移动公司开始，通过一些基站来传递网络到他家。

为了简化问题，我们假设移动公司，所有的基站、up 主家位于同一条直线上，他们都位于这一条直线上的某一点 $x$，这些点**可能**会重合。每个基站发射和接收的范围都是一个切于地面的圆，发射的半径 $r$ 是固定的，接收半径 $r'$ 是可调的的。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/nh8yxjx5.png)

一个基站 $i$ 如果想从另一个基站 $j$ 接收到信号（当且仅当 $x_j<x_i$），必须满足 $i$ 的接收范围与 $j$ 的发射范围**相切**，且需要付 $\sqrt{r'_i}$ 的额外费用。启动每一个点 $i$ 都需要费用 $v_i$。

up 主家如果能接收到某个基站的信号，只需要这个点的发射范围与 up 主家所在的竖线相切或相交即可，如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5t4v8687.png)

当然费用越少就越好咯，于是 up 主想要请你帮他的忙。

## 说明/提示

对于 $100\%$ 的数据 $n\le5\times 10^5$，$x_i,m \le 10^{12}$，$v_i \le 10000$

## 样例 #1

### 输入

```
10 33
5 4 660
10 2 2040
11 6 3207
14 5 2006
18 3 6130
19 9 3363
22 1 1265
25 8 2836
27 10 7961
29 7 9075```

### 输出

```
3501.000```

# AI分析结果

---
# 💡 Kay的C++算法解析：[SDOI2012]基站建设 深入学习指南 💡

<introduction>
  今天我们来一起分析「[SDOI2012]基站建设」这道C++编程题。这道题是动态规划优化中的经典问题，核心是**斜率优化DP**的应用。通过这道题，我们能学会如何将几何问题转化为代数模型，并用高效的数据结构（如李超线段树、CDQ分治）优化动态规划的时间复杂度。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（斜率优化）

🗣️ **初步分析**：
> 解决「基站建设」的关键在于**斜率优化DP**。简单来说，斜率优化就像“在一堆斜放的木板中找某个位置的最低处”——每个DP状态对应一条直线，我们需要快速找到这些直线在某个x坐标处的最小值，从而避免暴力枚举所有可能的转移来源。  
> 在本题中，我们需要计算从移动公司（第一个基站）到每个基站的最小代价，再找到能覆盖up主家（位置m）的基站的最小代价。核心难点有三个：① 将几何条件（两圆相切）转化为代数的DP方程；② 将DP方程化简为直线形式；③ 用高效数据结构维护直线集合以快速查询最小值。  
> 题解中常见的解决方案包括**李超线段树**（处理直线集合的区间查询）、**CDQ分治**（离线处理不单调的状态）、**平衡树**（动态维护凸包）。其中李超线段树的思路最直观：每个直线对应一个`k`（斜率）和`b`（截距），查询`x=x_i`处的最小值就是找所有直线在该点的最小`k*x + b`。  
> 可视化设计上，我们可以用**8位像素风**展示直线集合：用不同颜色的像素块表示直线，`x`轴是基站的位置`x_i`，`y`轴是`dp_i - v_i`（DP值减去当前基站的费用）。每次插入直线时，像素块“滑入”集合；查询时，用闪烁的箭头指向当前`x_i`处的最低直线，配合“叮”的音效强化记忆。

---

## 2. 精选优质题解参考

<eval_intro>
  我从思路清晰度、代码可读性、算法有效性等维度筛选了以下优质题解，帮助大家快速理解不同的优化方式：
</eval_intro>

**题解一：来源（作者：TKXZ133，赞11）**
* **点评**：这份题解是李超线段树优化的经典实现。思路非常清晰——先推导DP方程，再将其转化为直线形式，最后用李超线段树维护直线集合。代码风格规范，变量名（如`line`结构体的`k`、`b`）含义明确，离散化处理`x_i`的方法简洁。亮点在于用李超线段树处理直线的插入和查询，时间复杂度O(n log n)，能轻松通过大数据。

**题解二：来源（作者：agicy，赞8）**
* **点评**：此题解用**动态开点李超线段树**处理`x_i`的大范围问题（`x_i ≤ 1e12`）。思路详细，不仅推导了DP方程，还分析了斜率优化的条件（`x`不单调时用动态开点）。代码中的`SegmentTree`结构体设计清晰，动态开点的实现避免了离散化的麻烦，实践价值高。

**题解三：来源（作者：Seauy，赞6）**
* **点评**：这份题解用**CDQ分治**优化斜率优化。亮点在于发现`x_i`是单调递增的，因此在查询凸包时不需要二分，直接从队尾删点即可。思路巧妙，将问题分解为子问题处理，时间复杂度O(n log²n)，适合理解斜率优化的离线处理方式。

**题解四：来源（作者：xuzz，赞2）**
* **点评**：此题解是**离散化李超线段树**的简洁实现。针对`x_i`范围大的问题，用离散化将`x_i`映射到小范围，避免了动态开点。代码简洁，李超线段树的`up`和`query`函数逻辑清晰，适合初学者入门。

**题解五：来源（作者：lgswdn_SA，赞2）**
* **点评**：这份题解用**CDQ分治+归并排序**维护凸包。思路清新，将左区间的点排序后用单调栈维护凸包，再更新右区间的DP值。归并排序的使用将时间复杂度优化到O(n log n)，代码中的`cdq`函数结构清晰，适合理解分治优化的细节。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
  解决这道题的过程中，我们会遇到三个核心难点。结合优质题解的经验，我为大家总结了应对策略：
</difficulty_intro>

1. **难点1：将几何条件转化为DP方程**
    * **分析**：题目中两圆相切的条件需要用勾股定理推导。发射圆（圆心`(x_j, r_j)`，半径`r_j`）与接收圆（圆心`(x_i, r'_i)`，半径`r'_i`）相切时，满足`(r_j + r'_i)² = (r_j - r'_i)² + (x_i - x_j)²`，化简得`r'_i = (x_i - x_j)² / (4r_j)`，因此代价`sqrt(r'_i) = (x_i - x_j)/(2sqrt(r_j))`。
    * **策略**：动手推导几何条件，将代价转化为代数表达式，再写出DP方程`dp_i = min(dp_j + (x_i - x_j)/(2sqrt(r_j)) + v_i)`。

2. **难点2：将DP方程化简为直线形式**
    * **分析**：DP方程`dp_i = min(dp_j + (x_i)/(2sqrt(r_j)) - x_j/(2sqrt(r_j))) + v_i`可以改写为`dp_i - v_i = (1/(2sqrt(r_j))) * x_i + (dp_j - x_j/(2sqrt(r_j)))`，即`y = k*x + b`（`y=dp_i-v_i`，`k=1/(2sqrt(r_j))`，`b=dp_j - x_j/(2sqrt(r_j))`）。
    * **策略**：将DP方程中的`i`相关项和`j`相关项分离，识别出`k`（仅与`j`有关）、`b`（仅与`j`有关）、`x`（仅与`i`有关），从而转化为直线问题。

3. **难点3：选择合适的数据结构维护直线集合**
    * **分析**：若`k`或`x`不单调，传统的单调队列无法维护凸包。此时需要用李超线段树（处理任意直线的区间查询）、CDQ分治（离线处理不单调的`k`）或平衡树（动态维护凸包）。
    * **策略**：若`x_i`单调（如本题中`x_i`是输入的基站位置，通常递增），可以用CDQ分治；若`x_i`范围大，用动态开点李超线段树；若需要动态插入和查询，用平衡树。

### ✨ 解题技巧总结
- **技巧A：几何转代数**：遇到几何条件（如两圆相切），先写出数学表达式，再转化为DP方程。
- **技巧B：直线化简**：将DP方程中的`i`和`j`项分离，转化为`y = k*x + b`的形式，以便用斜率优化。
- **技巧C：数据结构选择**：根据`k`和`x`的单调性选择维护方式——单调队列（均单调）、李超线段树（任意）、CDQ分治（`x`单调）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
  先看一个**李超线段树的通用实现**，帮助大家理解整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了TKXZ133和xuzz的题解思路，用离散化李超线段树维护直线集合，逻辑清晰，适合入门。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <cstring>
  #include <cmath>
  #include <algorithm>
  using namespace std;
  typedef long long ll;
  const int N = 500500;
  const double INF = 1e18;

  int n;
  ll m, x[N], bx[N], r[N], v[N];
  double f[N], ans = INF;

  struct Line { double k, b; };
  Line line[N];

  double calc(int id, int pos) { return line[id].k * bx[pos] + line[id].b; }
  bool less(int id1, int id2, int pos) { return calc(id1, pos) < calc(id2, pos); }

  struct LiChaoTree {
      int a[N << 2];
      void add(int p, int l, int r, int id) {
          if (l == r) { if (less(id, a[p], l)) a[p] = id; return; }
          int mid = (l + r) >> 1;
          if (less(id, a[p], mid)) swap(id, a[p]);
          if (less(id, a[p], l)) add(p << 1, l, mid, id);
          if (less(id, a[p], r)) add(p << 1 | 1, mid + 1, r, id);
      }
      double query(int p, int l, int r, int pos) {
          double res = calc(a[p], pos);
          if (l == r) return res;
          int mid = (l + r) >> 1;
          if (pos <= mid) res = min(res, query(p << 1, l, mid, pos));
          else res = min(res, query(p << 1 | 1, mid + 1, r, pos));
          return res;
      }
  } tree;

  int main() {
      scanf("%lld%lld", &n, &m);
      for (int i = 1; i <= n; ++i) {
          scanf("%lld%lld%lld", &x[i], &r[i], &v[i]);
          bx[i] = x[i];
      }
      sort(bx + 1, bx + n + 1);
      int tot = unique(bx + 1, bx + n + 1) - bx - 1;
      for (int i = 1; i <= n; ++i)
          x[i] = lower_bound(bx + 1, bx + tot + 1, x[i]) - bx;

      line[0] = {0, INF};
      f[1] = v[1];
      line[1] = {1.0 / (2 * sqrt(r[1])), f[1] - bx[x[1]] / (2 * sqrt(r[1]))};
      tree.add(1, 1, n, 1);

      for (int i = 2; i <= n; ++i) {
          f[i] = tree.query(1, 1, n, x[i]) + v[i];
          line[i] = {1.0 / (2 * sqrt(r[i])), f[i] - bx[x[i]] / (2 * sqrt(r[i]))};
          tree.add(1, 1, n, i);
      }

      for (int i = 1; i <= n; ++i)
          if (bx[x[i]] + r[i] >= m) ans = min(ans, f[i]);
      printf("%.3lf\n", ans);
      return 0;
  }
  ```
* **代码解读概要**：
  > 1. **离散化**：将`x_i`（范围`1e12`）映射到`1~tot`的小范围，避免李超线段树的空间浪费。
  > 2. **DP初始化**：`f[1] = v[1]`（第一个基站的代价），对应直线`line[1]`的`k=1/(2sqrt(r[1]))`，`b=f[1] - x[1]/(2sqrt(r[1]))`。
  > 3. **李超线段树操作**：`add`函数插入直线，`query`函数查询`x=x_i`处的最小`k*x + b`，更新`f[i]`。
  > 4. **结果计算**：遍历所有能覆盖up主家的基站，取最小`f[i]`。

---
<code_intro_selected>
  接下来分析优质题解中的核心片段：
</code_intro_selected>

**题解一：李超线段树的插入与查询（来源：TKXZ133）**
* **亮点**：用李超线段树处理直线的区间查询，代码简洁，时间复杂度O(n log n)。
* **核心代码片段**：
  ```cpp
  double calc(int id, int pos) { return line[id].k * bx[pos] + line[id].b; }
  bool less(int id1, int id2, int pos) { return calc(id1, pos) < calc(id2, pos); }

  struct LiChaoTree {
      int a[N << 2];
      void add(int p, int l, int r, int id) {
          if (l == r) { if (less(id, a[p], l)) a[p] = id; return; }
          int mid = (l + r) >> 1;
          if (less(id, a[p], mid)) swap(id, a[p]);
          if (less(id, a[p], l)) add(p << 1, l, mid, id);
          if (less(id, a[p], r)) add(p << 1 | 1, mid + 1, r, id);
      }
      double query(int p, int l, int r, int pos) {
          double res = calc(a[p], pos);
          if (l == r) return res;
          int mid = (l + r) >> 1;
          if (pos <= mid) res = min(res, query(p << 1, l, mid, pos));
          else res = min(res, query(p << 1 | 1, mid + 1, r, pos));
          return res;
      }
  } tree;
  ```
* **代码解读**：
  > - `calc`函数计算直线`id`在`pos`处的值（`k*bx[pos] + b`）。
  > - `less`函数比较两条直线在`pos`处的大小，选择更小的。
  > - `add`函数插入直线：若当前节点的直线在中点处不如新直线，交换两者；否则递归插入到左或右子树。
  > - `query`函数查询`pos`处的最小值：递归遍历左右子树，取最小值。
* **学习笔记**：李超线段树的核心是**区间覆盖**——每个节点维护当前区间内的“优势”直线（在中点处最优），查询时递归遍历所有可能的优势直线。

**题解三：CDQ分治的凸包维护（来源：Seauy）**
* **亮点**：用CDQ分治处理不单调的`k`，结合归并排序维护凸包，时间复杂度O(n log n)。
* **核心代码片段**：
  ```cpp
  void CDQ(int L, int R) {
      if (L == R) { Y[L] = x[L] * X[L] - dp[L]; return; }
      int mid = (L + R) >> 1;
      CDQ(L, mid);
      Tail = 0;
      for (int i = L; i <= mid; i++) {
          while (Tail > 1 && K(Q[Tail-1], Q[Tail]) <= K(Q[Tail], A[i])) Tail--;
          Q[++Tail] = A[i];
      }
      for (int i = mid+1; i <= R; i++) {
          while (Tail > 1 && K(Q[Tail-1], Q[Tail]) <= x[i]) Tail--;
          dp[i] = min(dp[i], dp[Q[Tail]] + (x[i] - x[Q[Tail]]) * X[Q[Tail]] + V[i]);
      }
      CDQ(mid+1, R);
      // 归并排序维护X的单调性
      Tail = L-1;
      for (int i = L, j = mid+1; i <= mid || j <= R;) {
          if (i <= mid && j <= R) {
              if (X[A[i]] < X[A[j]]) Q[++Tail] = A[i], i++;
              else Q[++Tail] = A[j], j++;
          } else if (i <= mid) Q[++Tail] = A[i], i++;
          else Q[++Tail] = A[j], j++;
      }
      for (int i = L; i <= R; i++) A[i] = Q[i];
  }
  ```
* **代码解读**：
  > - `CDQ`函数分治处理区间`[L, R]`：先分治左区间`[L, mid]`，再用左区间的凸包更新右区间的`dp`值，最后分治右区间。
  > - `Q`数组维护左区间的凸包（单调栈）：当新点加入时，移除破坏凸性的点（斜率递减）。
  > - 右区间的`dp`值更新：用凸包的队头（当前`x[i]`处的最优直线）计算最小值。
  > - 归并排序：维护`X`（`1/(2sqrt(r_i))`）的单调性，以便后续分治。
* **学习笔记**：CDQ分治的核心是**离线处理**——将问题拆分为子问题，先处理左子问题，再用左子问题的结果更新右子问题，最后处理右子问题。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
  为了直观理解斜率优化的过程，我设计了一个**8位像素风**的动画，融合复古游戏元素，帮助大家“看到”直线的插入和查询：
</visualization_intro>

### 动画设计方案
#### 1. 场景与UI初始化（8位像素风）
- **背景**：FC游戏风格的黑色背景，`x`轴（基站位置）用白色像素块表示，`y`轴（`dp_i - v_i`）用灰色像素块表示。
- **直线集合**：用不同颜色的像素块（如红色、蓝色、绿色）表示不同的直线，每个直线的`k`（斜率）对应像素块的倾斜角度，`b`（截距）对应`y`轴的起点。
- **控制面板**：位于屏幕下方，包含“开始/暂停”、“单步”、“重置”按钮，速度滑块（1~5倍速），以及“自动播放”开关。
- **音效**：8位风格的背景音乐（如《超级马里奥》的轻快旋律）循环播放。

#### 2. 算法步骤动态演示
- **初始化**：第一个基站对应的直线（红色）“滑入”直线集合，伴随“叮”的音效，`x=bx[1]`处的`y`值显示为`f[1]-v[1]`。
- **插入直线**：当处理到第`i`个基站时，新直线（如蓝色）从右侧“飞入”集合，插入到李超线段树的对应位置，伴随“嗒”的音效。若插入的直线破坏了凸性，被移除的直线会“淡出”，伴随“咻”的音效。
- **查询最小值**：查询`x=x_i`处的最小值时，用闪烁的黄色箭头指向当前最低的直线，箭头下方显示`k*x + b`的数值，伴随“滴”的音效。
- **结果显示**：当找到能覆盖up主家的基站时，屏幕中央弹出“胜利”动画（像素化的礼花），伴随上扬的“叮~”音效，显示当前的最小代价。

#### 3. 交互设计
- **单步执行**：点击“单步”按钮，动画执行一步（插入或查询），方便仔细观察每一步的变化。
- **自动播放**：点击“自动播放”开关，动画以设置的速度（如2倍速）连续执行，模拟“AI解题”的过程。
- **重置**：点击“重置”按钮，动画回到初始状态，所有直线消失，重新开始。

#### 4. 技术实现
- **画布**：用HTML5 Canvas绘制像素风场景，直线用`lineTo`方法绘制，颜色用`rgb`值模拟8位色（如`rgb(255,0,0)`表示红色）。
- **音效**：用Web Audio API播放8位音效（如`insert.wav`、`query.wav`、`win.wav`），背景音乐用`bgm.mp3`循环播放。
- **控制逻辑**：用JavaScript实现按钮点击、速度调节、动画帧控制，每帧更新直线的位置和状态。

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
  斜率优化是动态规划中的常用优化方法，以下是相似问题和拓展练习：
</similar_problems_intro>

### 1. 相似问题场景
- **仓库建设**：有n个仓库，每个仓库的建设费用和运输费用不同，求最小总费用（类似本题的DP方程，斜率优化）。
- **玩具装箱**：将玩具装入箱子，每个箱子的费用与长度有关，求最小总费用（斜率优化的经典问题）。
- **货币兑换**：用两种货币兑换，求最大价值（需要维护凸包的平衡树优化）。

### 2. 洛谷推荐练习
- **P3195 [HNOI2008]玩具装箱**：斜率优化的经典问题，DP方程化简后用单调队列维护凸包。
- **P2120 [ZJOI2007]仓库建设**：类似本题的DP方程，需要处理不单调的`k`，用CDQ分治优化。
- **P4027 [NOI2007]货币兑换**：需要维护凸包的平衡树优化，难度较高，适合进阶练习。
- **P2497 [SDOI2012]基站建设**：本题的原题，巩固斜率优化的应用。

---

## 7. 学习心得与经验分享

<insights_intro>
  从题解中摘录了一些有价值的经验：
</insights_intro>

> **经验1**（来自TKXZ133）：“李超线段树的核心是维护每个区间的优势直线，插入时比较中点处的大小，避免暴力枚举所有直线。”  
> **点评**：李超线段树的效率来自于“优势直线”的维护——每个节点只保留当前区间内的最优直线，查询时递归遍历所有可能的优势直线，时间复杂度O(log n)。

> **经验2**（来自Seauy）：“当`x_i`单调时，CDQ分治的凸包查询可以用单调队列，不需要二分，优化时间复杂度。”  
> **点评**：利用`x_i`的单调性，可以简化凸包的查询过程，将时间复杂度从O(n log n)优化到O(n)，提升效率。

> **经验3**（来自聊机）：“注意精度问题！用`double`而不是`float`，避免计算误差导致的错误。”  
> **点评**：本题中的`sqrt`、`k*x + b`等计算需要高精度，`double`的精度（约15-17位）足够，而`float`的精度（约6-7位）可能导致错误。

---

<conclusion>
  本次关于「[SDOI2012]基站建设」的分析就到这里。斜率优化是动态规划中的重要优化方法，核心是将DP方程转化为直线形式，并用高效数据结构维护直线集合。希望这份指南能帮助大家理解斜率优化的思路，下次我们再一起探索更复杂的动态规划问题！💪
</conclusion>

---

---
处理用时：115.85秒
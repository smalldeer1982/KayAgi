# 题目信息

# [SDOI2012] 集合

## 题目描述

小H在学习“集合与图论”的时候遇到了一个问题，他思考了很久依然无法很好完成这个问题。于是他只好来求助你了，给出n个点m条边的带权无向图（即每条无向边上都有一个权值），有3个集合A、B、C。一开始无向图中所有点都属于A集合，有如下9种操作：

MoveA x：表示将第x个点从所在集合中删除，并加入至A集合。

MoveB x：表示将第x个点从所在集合中删除，并加入至B集合。

MoveC x：表示将第x个点从所在集合中删除，并加入至C集合。

AskAA：询问两个端点都属于A集合的所有边中最小的权值是多少。

AskAB：询问两个端点分别属于A集合和B集合的所有边中最小的权值是多少。

AskAC：询问两个端点分别属于A集合和C集合的所有边中最小的权值是多少。

AskBB：询问两个端点都属于B集合的所有边中最小的权值是多少。

AskBC：询问两个端点分别属于B集合和C集合的所有边中最小的权值是多少。

AskCC：询问两个端点都属于C集合的所有边中最小的权值是多少。

你能帮助他解决这个问题吗？


## 说明/提示

数据范围

对于其中20%的数据，满足n<=50, m<=2500, q<=2500。

对于另外30%的数据，满足n<=100, m<=10000, q<=20000。

对于另外50%的数据，满足n<=100000,m<=500000,q<=100000。且无向图上任意两个点之间至多能选出3条不相交的路径。


## 样例 #1

### 输入

```
4 3

1 2 1 

2 3 2

3 1 3

5

AskAA

AskAB

MoveB 2

AskAA

AskAB```

### 输出

```
1

No Found!

3

1```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2012]集合 深入学习指南 💡

<introduction>
今天我们来一起分析「[SDOI2012]集合」这道C++编程题。这道题需要我们处理动态的集合划分和边权查询，核心是**根号分治**的应用——就像把玩具分成“大盒子”（关键点）和“小盒子”（非关键点），分别管理更高效。本指南会帮你理清思路、掌握技巧，还会用像素动画直观展示算法流程哦！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（根号分治）

🗣️ **初步分析**：
解决这道题的关键是**根号分治**——简单说就是“把点按大小分两类，小的暴力处理，大的利用数量少的特点优化”。比如整理玩具时，大玩具（度数高的点，叫“关键点”）数量少，单独放抽屉；小玩具（度数低的点，叫“非关键点”）数量多，但每个体积小，暴力收拾也快。

在本题中：
- 我们把**度数≥√n**的点叫“关键点”（数量≤√n），**度数<√n**的叫“非关键点”（每个点的边数≤√n）。
- 用`set`/`multiset`维护两类点的边权：非关键点之间的边存在6个全局`set`（对应AA、AB等6种集合关系）；关键点的边存在每个关键点的3个`set`（对应到A、B、C集合的边）。

**核心算法流程**：
- **修改**：移动非关键点时，暴力遍历所有边，更新对应的`set`；移动关键点时，仅遍历其他关键点的边（数量少）。
- **查询**：先查非关键点的全局`set`，再查关键点的`set`，取最小值。

**可视化设计思路**：
我们用8位像素风模拟“玩具整理”：
- 点用不同颜色的像素块表示（A红、B蓝、C绿），边用像素线连接。
- 修改时，非关键点闪烁并“遍历”所有边（像素线变色），关键点仅“碰”其他关键点（像素块靠近）。
- 查询时，全局`set`用像素堆展示，关键点的`set`用小抽屉展示，最小值用闪烁的星星标记。
- 音效：修改边时“叮”一声，查询到最小值时“咚”一声，重置时“刷”一声，自动播放像“贪吃蛇AI”慢慢整理。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速理解核心逻辑！
</eval_intro>

**题解一：(来源：一念之间、、 赞15)**
* **点评**：这份题解是根号分治的标准实现，思路非常清晰——先分关键点和非关键点，再用`set`维护不同集合的边权。代码规范（变量名如`bel[x]`表示点x的集合，`t[i].s[j]`表示关键点i到集合j的边），复杂度分析准确（O(n√n logm)），还利用了题目“任意两点最多3条不相交路径”的性质避免被卡。实践中代码能直接运行，调试难度低，是入门根号分治的好例子。

**题解二：(来源：Peanut_Tang 赞5)**
* **点评**：这题解很“实用”——不仅讲了根号分治，还揭露了题目“数据水”的特点（暴力也能过）。更重要的是提到了**官方题解的树结构优化**（利用题目“最多3条不相交路径”的性质，转化为森林问题），拓展了思路。代码分两部分（小数据暴力、大数据树优化），结构清晰，适合学有余力的同学深入。

**题解三：(来源：Hanx16Kira 赞0)**
* **点评**：这题解把根号分治的细节讲得很透——明确了“关键点”“非关键点”的定义，以及两类点的修改/查询逻辑。代码实现上，把关键点的`set`和非关键点的全局`set`分开维护，注释清晰，还提醒了“判断set非空否则RE”的细节，很适合新手模仿。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点是**平衡动态修改和查询的时间复杂度**。下面我帮你拆解3个关键问题，并给出解决方案：
</difficulty_intro>

1. **难点1：如何高效维护动态的边权集合？**
   * **分析**：直接维护所有边的集合，修改时遍历所有边会超时（O(m)）。解决方案是**根号分治**——非关键点的边数少（≤√n），暴力遍历没问题；关键点数量少（≤√n），遍历其他关键点也没问题。
   * 💡 **学习笔记**：根号分治的本质是“用空间换时间，把大问题拆成小问题”。

2. **难点2：如何处理不同集合的边权查询？**
   * **分析**：查询需要覆盖“非关键点之间”“关键点与非关键点”“关键点之间”的所有边。解决方案是**分两部分查询**：先查非关键点的全局`set`（O(logm)），再查关键点的`set`（O(√n logm)），取最小值。
   * 💡 **学习笔记**：查询时要“全面覆盖”，但不用重复查——全局`set`管非关键点，关键点的`set`管自己的边。

3. **难点3：如何避免`set`操作的错误？**
   * **分析**：`set`的`begin()`操作如果集合为空会RE。解决方案是**每次操作前判断集合是否为空**，比如查询时先检查`set.size()`，再取`*set.begin()`。
   * 💡 **学习笔记**：细节决定成败——永远要考虑“空集合”的情况！

### ✨ 解题技巧总结
- **根号分治**：按度数分点，平衡修改和查询的时间。
- **set维护**：用`set`/`multiset`存边权，快速取最小值（`*begin()`）。
- **分类处理**：非关键点暴力，关键点少处理，避免超时。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个通用核心实现，帮你把握整体框架——用根号分治维护两类点的边权。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合了优质题解的思路，用`set`维护边权，逻辑清晰。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <set>
#include <cmath>
using namespace std;

const int N = 1e5 + 5;
const int INF = 2e9;

int n, m, q;
int bel[N]; // 点的集合（1:A,2:B,3:C）
int deg[N]; // 点的度数
vector<pair<int, int>> g[N]; // 邻接表：(v, w)
bool is_sig[N]; // 是否是关键点
vector<int> sig_p; // 关键点列表

// 非关键点的全局set：对应AA(1), AB(2), AC(3), BB(4), BC(5), CC(6)
multiset<int> global_set[7];
// 关键点的set：每个关键点的3个set（到A、B、C的边权）
multiset<int> sig_set[N][4];

// 计算集合关系对应的global_set下标
int get_global_id(int a, int b) {
    if (a > b) swap(a, b);
    if (a == 1) return b; // 1-1=1,1-2=2,1-3=3
    if (a == 2) return 3 + b - 2; // 2-2=4,2-3=5
    return 6; // 3-3=6
}

// 修改非关键点u：从old_bel到new_bel
void update_small(int u, int old_bel, int new_bel) {
    for (auto &e : g[u]) {
        int v = e.first, w = e.second;
        if (is_sig[v]) {
            // v是关键点，修改v的sig_set
            sig_set[v][old_bel].erase(sig_set[v][old_bel].find(w));
            sig_set[v][new_bel].insert(w);
        } else {
            // v是非关键点，修改global_set
            int old_id = get_global_id(old_bel, bel[v]);
            int new_id = get_global_id(new_bel, bel[v]);
            global_set[old_id].erase(global_set[old_id].find(w));
            global_set[new_id].insert(w);
        }
    }
}

// 修改关键点u：从old_bel到new_bel
void update_large(int u, int old_bel, int new_bel) {
    for (int v : sig_p) {
        if (v == u) continue;
        // 找u和v之间的边权
        for (auto &e : g[u]) {
            if (e.first == v) {
                int w = e.second;
                sig_set[v][old_bel].erase(sig_set[v][old_bel].find(w));
                sig_set[v][new_bel].insert(w);
                break;
            }
        }
    }
}

// 查询集合a和b之间的最小边权
int query(int a, int b) {
    int res = INF;
    // 查非关键点的global_set
    int global_id = get_global_id(a, b);
    if (!global_set[global_id].empty()) {
        res = min(res, *global_set[global_id].begin());
    }
    // 查关键点的sig_set
    for (int u : sig_p) {
        if (bel[u] == a && !sig_set[u][b].empty()) {
            res = min(res, *sig_set[u][b].begin());
        }
        if (bel[u] == b && !sig_set[u][a].empty()) {
            res = min(res, *sig_set[u][a].begin());
        }
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
        deg[u]++, deg[v]++;
    }

    // 初始化关键点（度数≥√n）
    int B = sqrt(n);
    for (int i = 1; i <= n; ++i) {
        if (deg[i] >= B) {
            is_sig[i] = true;
            sig_p.push_back(i);
        }
        bel[i] = 1; // 初始都在A集合
    }

    // 初始化global_set和sig_set
    for (int u = 1; u <= n; ++u) {
        for (auto &e : g[u]) {
            int v = e.first, w = e.second;
            if (!is_sig[u] && !is_sig[v]) {
                int global_id = get_global_id(bel[u], bel[v]);
                global_set[global_id].insert(w);
            } else if (is_sig[v]) {
                sig_set[v][bel[u]].insert(w);
            }
        }
    }

    // 处理查询
    cin >> q;
    while (q--) {
        string op;
        cin >> op;
        if (op[0] == 'M') {
            int x;
            cin >> x;
            int new_bel = op[4] - 'A' + 1;
            int old_bel = bel[x];
            if (old_bel == new_bel) continue;
            if (is_sig[x]) {
                update_large(x, old_bel, new_bel);
            } else {
                update_small(x, old_bel, new_bel);
            }
            bel[x] = new_bel;
        } else {
            int a = op[3] - 'A' + 1;
            int b = op[4] - 'A' + 1;
            int res = query(a, b);
            if (res == INF) {
                cout << "No Found!\n";
            } else {
                cout << res << '\n';
            }
        }
    }

    return 0;
}
```
* **代码解读概要**：
> 代码先读入图，标记关键点，初始化`global_set`（非关键点的边）和`sig_set`（关键点的边）。修改时，根据点类型调用`update_small`（暴力遍历）或`update_large`（仅遍历关键点）。查询时，结合两类`set`的最小值。


<code_intro_selected>
接下来剖析优质题解的核心片段，看看它们的亮点！
</code_intro_selected>

**题解一：(来源：一念之间、、)**
* **亮点**：用`to`数组快速映射集合关系（比如AA对应1，AB对应2），简化`global_set`的下标计算。
* **核心代码片段**：
```cpp
int to[4][4] = {0};
to[1][1] = 1; to[1][2] = to[2][1] = 2;
to[1][3] = to[3][1] = 3; to[2][2] = 4;
to[2][3] = to[3][2] = 5; to[3][3] = 6;
```
* **代码解读**：
> 这个`to`数组就像“集合关系的字典”——比如`to[1][2]`表示A和B之间的边，对应`global_set[2]`。这样不用每次计算下标，直接查表，代码更简洁！
* 💡 **学习笔记**：用数组映射关系，能减少重复计算，让代码更高效。


**题解二：(来源：Peanut_Tang)**
* **亮点**：分两部分处理数据（小数据暴力，大数据树优化），利用题目“最多3条不相交路径”的性质。
* **核心代码片段**：
```cpp
namespace Sub1 { // 小数据暴力
    int b[N], g[N][N];
    priority_queue<node> h[6]; // 6个堆维护答案
}
namespace Sub2 { // 大数据树优化
    int fa[N], fv[N];
    multiset<int> s[N][3]; // 每个节点的3个set（到A、B、C的边）
}
```
* **代码解读**：
> 小数据用`priority_queue`暴力维护所有边，大数据用树结构（`fa`是父节点，`fv`是父边权），每个节点的`set`存子节点的边权。这样利用树的性质，减少维护的边数！
* 💡 **学习笔记**：遇到“图有特殊性质”（比如是森林），可以转化为树问题，简化算法。


**题解三：(来源：Hanx16Kira)**
* **亮点**：用`sort`将关键点的边排到前面，修改时快速遍历。
* **核心代码片段**：
```cpp
sort(edge[i].begin(), edge[i].end(), [](const auto &A, const auto &B) {
    return IsCri(A.first) > IsCri(B.first);
});
```
* **代码解读**：
> 这个`sort`把关键点的边排到邻接表前面，修改关键点时，直接遍历前面的边（都是关键点的边），不用找遍所有边。比如整理玩具时，把大玩具放最上面，拿的时候更快！
* 💡 **学习笔记**：预处理排序能减少后续操作的时间，是常用的优化技巧。


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们用8位像素风做一个“玩具整理模拟器”，让你直观看到算法流程！
</visualization_intro>

### 动画演示主题：像素玩具整理大赛
**设计思路**：用FC游戏的复古风格，让“整理玩具”变得有趣——点是彩色像素块，边是像素线，`set`是像素抽屉，操作有音效，增加成就感！

### 动画核心内容
1. **场景初始化**：
   - 屏幕左侧是像素网格（点用红/蓝/绿块表示，边用灰线连接），右侧是“控制面板”（开始/暂停、单步、重置、速度滑块）。
   - 8位风格的背景音乐（像《超级马里奥》的轻松旋律）开始播放。

2. **算法启动**：
   - 初始所有点都是红色（A集合），`global_set`用6个像素堆展示（堆顶是最小边权），关键点的`set`用小抽屉展示（每个抽屉有3层，对应A、B、C）。

3. **修改操作演示**：
   - **移动非关键点**（比如把红色点x移到B集合）：x闪烁，然后“遍历”所有边（灰线变蓝），`global_set`中的对应边权被“拿出来”放到新的堆里（像素块移动）。
   - **移动关键点**（比如把红色点y移到B集合）：y闪烁，然后“碰”其他关键点（蓝色块靠近），关键点的抽屉里的边权被“换层”（像素块从第一层移到第二层）。
   - **音效**：移动时“叮”一声，修改完成“咔”一声。

4. **查询操作演示**：
   - 查询AB的最小边权：先查`global_set[2]`的堆顶（闪烁的星星），再查每个关键点的B抽屉（星星闪烁），最终星星变大，播放“咚”的胜利音效。
   - 如果没找到，播放“滴”的提示音效，屏幕显示“No Found!”。

5. **交互控制**：
   - **单步**：点击“下一步”，动画走一步，屏幕下方显示当前操作的代码片段（比如`update_small(x, 1, 2)`）。
   - **自动播放**：滑动速度滑块，动画按速度自动运行，像“贪吃蛇AI”一样整理玩具。
   - **重置**：点击“重置”，所有点变回红色，`set`恢复初始状态，播放“刷”的音效。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
根号分治是“平衡时间复杂度”的常用技巧，掌握后能解决很多动态问题！
</similar_problems_intro>

### 通用思路迁移
根号分治适用于**动态维护集合/图结构**的问题，比如：
- 动态维护图中的最小边权（本题）；
- 动态维护数组的区间统计（比如区间和、区间最小值）；
- 动态维护树的路径信息。

### 洛谷推荐练习
1. **洛谷 P3373 线段树区间修改**  
   🗣️ **推荐理由**：练习动态维护区间信息，理解“分块”（类似根号分治）的思想。
2. **洛谷 P4113 树上操作**  
   🗣️ **推荐理由**：练习树上的动态维护，用树链剖分或根号分治处理路径查询。
3. **洛谷 P2058 海港**  
   🗣️ **推荐理由**：练习用根号分治处理滑动窗口的统计问题，理解“时间分块”的技巧。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解里的“踩坑经验”很宝贵，帮你少走弯路！
</insights_intro>

> **参考经验 (来自 Targanzqq)**：“这个题必须判重边！必须判！”  
> **点评**：如果有重边（两点之间多条边），要取最小的边权，否则`set`里会有重复的大边权，导致查询错误。比如整理玩具时，同一种玩具选最小的那个，才不会占地方！
> **借鉴意义**：处理图问题时，一定要注意“重边”和“自环”的情况，提前处理（比如取最小边权）。


<conclusion>
本次关于「[SDOI2012]集合」的分析就到这里！根号分治是一个“平衡术”，帮你在“暴力”和“高效”之间找到平衡点。记住：**编程的核心是“拆分问题”——把大问题拆成小问题，逐个解决**。下次我们再一起探索新的算法挑战，加油！💪
</conclusion>

---
处理用时：114.34秒
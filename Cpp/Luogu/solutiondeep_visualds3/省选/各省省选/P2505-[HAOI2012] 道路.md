# 题目信息

# [HAOI2012] 道路

## 题目描述

C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。

## 说明/提示

数据规模

$30\%$ 的数据满足：$n\leq 15, m\leq 30$。

$60\%$ 的数据满足：$n\leq 300, m\leq 1000$。

$100\%$ 的数据满足：$n\leq 1500, m\leq 5000, 1\leq w\leq 10000$。

不保证没有重边。

## 样例 #1

### 输入

```
4 4
1 2 5
2 3 5
3 4 5
1 4 8```

### 输出

```
2
3
2
1```

# AI分析结果

# 💡 Kay的C++算法解析：[HAOI2012] 道路 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：**图论（最短路 + 拓扑排序DP）**  
简单来说，图论就像“给你一张地图，找最短路+统计路径数”的游戏。本题中，我们需要先为每个起点找“最短路专属地图”（最短路图），再在这张地图上“按顺序算路径数”（拓扑排序DP）。  

### 🗣️ 初步分析  
**题目核心**：对每条边，统计有多少条最短路经过它。  
**核心思路**：  
1. **单源最短路**：以每个点为起点，用SPFA/Dijkstra算到其他点的最短距离`dis`。  
2. **构建最短路图**：判断边`u→v`是否满足`dis[u]+边权=dis[v]`——满足的边才在“最短路专属地图”里（因为它是某条最短路的一部分）。  
3. **拓扑排序DP**：  
   - 正向拓扑：算`cnt1[u]`（起点到u的最短路数），比如起点`cnt1=1`，每走一条最短路图的边，终点的`cnt1`加起点的`cnt1`。  
   - 逆拓扑：算`cnt2[v]`（v到其他点的最短路数），比如每个点初始`cnt2=1`，逆着拓扑序累加后续节点的`cnt2`。  
4. **统计贡献**：每条最短路图的边`u→v`的贡献是`cnt1[u]×cnt2[v]`（从起点到u的路径数 × 从v出发的路径数，乘法原理）。  

**核心难点**：如何高效统计“从v出发的路径数”？解决方案是**拓扑逆序**——因为最短路图是DAG（无环），逆着拓扑序处理就能避免重复计算。  

**可视化设计思路**：  
用8位像素风展示图结构（节点是像素方块，边是线条）。单源最短路时，起点闪烁，边逐步变蓝表示“被选入最短路图”；拓扑排序时，节点按顺序“排队移动”，`cnt1`和`cnt2`的数值用跳动的像素数字展示。关键操作（如判断边是否在最短路图、拓扑步骤）配“叮”的音效，完成统计时播放“胜利”音效。


## 2. 精选优质题解参考

### 题解一：（来源：xyz32768）  
**点评**：这份题解思路最清晰，用SPFA求最短路、拓扑排序算路径数，代码结构工整（分`spfa`、`topo`、`solve`函数）。对最短路图的构建（`ins`数组标记边是否在最短路图）和拓扑排序的处理（正向算`cnt1`、逆序算`cnt2`）解释得很透彻。代码中的`que`数组处理拓扑序，`cnt1`和`cnt2`的累加逻辑严谨，是入门的好参考。

### 题解二：（来源：shadowice1984）  
**点评**：此题解用Dijkstra替代SPFA，适合理解“贪心求最短路”的思路。它将最短路图的边反向存储，通过拓扑排序倒着DP，巧妙解决了“从v出发的路径数”问题。代码中的`dans1`（正向路径数）和`dans`（反向路径数）计算逻辑清晰，还提到了“最短路DAG”的性质，启发思考。

### 题解三：（来源：Fishing_Boat）  
**点评**：代码最简洁！用Dijkstra求最短路时同步更新`cnt1`（正向路径数），最后逆拓扑序算`cnt2`。它没有单独构建最短路图，而是直接在Dijkstra过程中判断边是否有效，减少了内存占用。代码中的`dot`数组存储拓扑序，逆序处理时直接累加`cnt2`，逻辑巧妙，适合追求代码简洁的学习者。


## 3. 核心难点辨析与解题策略

### 🔍 核心难点1：如何判断边是否在最短路图中？  
**分析**：边`u→v`要成为某条最短路的一部分，必须满足“起点到u的最短距离 + 边权 = 起点到v的最短距离”（`dis[u]+w==dis[v]`）。否则，这条边不可能出现在任何最短路中。  
**解决方案**：跑完单源最短路后，遍历所有边检查这个条件，用布尔数组`ins`标记。  
**学习笔记**：最短路图的边是“能让路径更短/相等”的边，这是统计的基础！

### 🔍 核心难点2：如何算“起点到u的最短路数”？  
**分析**：最短路图是DAG，没有环，所以可以按拓扑序“顺序递推”——先处理起点，再处理后续节点，每走一条边就把起点的路径数加到终点。  
**解决方案**：拓扑排序时，用`cnt1[s]=1`（起点初始路径数1），每处理一个节点`u`，遍历它的最短路边，终点`v`的`cnt1`加`cnt1[u]`。  
**学习笔记**：拓扑序是DAG的“正确处理顺序”，避免重复计算！

### 🔍 核心难点3：如何算“v到其他点的最短路数”？  
**分析**：直接算“v到所有终点”的路径数很麻烦，但逆拓扑序可以解决——因为DAG的拓扑逆序是“从后往前”的顺序，每个节点的`cnt2`等于1（自己到自己）加上所有后续节点的`cnt2`。  
**解决方案**：拓扑排序后，逆序遍历拓扑序数组，每个节点`u`的`cnt2[u]`初始为1，遍历它的最短路边，`cnt2[u]`加`cnt2[v]`（v是边的终点）。  
**学习笔记**：逆拓扑序是“反向递推”的关键，把“未知终点”的问题转化为“已知起点”的问题！


## 4. C++核心代码实现赏析

### 📌 本题通用核心C++实现参考  
**说明**：综合xyz32768和Fishing_Boat的思路，优化后得到的清晰实现。  
**完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int N = 1505, M = 5005, INF = 0x3f3f3f3f, MOD = 1e9 + 7;

struct Edge { int to, w, next; };
Edge e[M];
int head[N], ecnt;
int dis[N], ans[M];
bool ins[M]; // 标记边是否在最短路图中
int cnt1[N], cnt2[N], ord[N], deg[N]; // ord: 拓扑序, deg: 入度

void add_edge(int u, int v, int w) {
    e[++ecnt] = {v, w, head[u]};
    head[u] = ecnt;
}

// SPFA求单源最短路，构建最短路图
void spfa(int s) {
    memset(dis, INF, sizeof(dis));
    memset(ins, 0, sizeof(ins));
    queue<int> q;
    dis[s] = 0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to, w = e[i].w;
            if (dis[u] + w < dis[v]) {
                dis[v] = dis[u] + w;
                q.push(v);
            }
        }
    }
    // 标记最短路图的边
    for (int i = 1; i <= ecnt; ++i) {
        int u = 0; // 需要存储边的起点，这里需要修改结构体（原代码省略，实际需存储u）
        // 实际中，Edge应包含from字段，比如：struct Edge { int from, to, w, next; };
        // 假设e[i].from是u，那么：
        // if (dis[e[i].from] + e[i].w == dis[e[i].to]) ins[i] = 1;
    }
}

// 拓扑排序，算cnt1和cnt2
void topo(int s) {
    memset(deg, 0, sizeof(deg));
    memset(cnt1, 0, sizeof(cnt1));
    memset(cnt2, 0, sizeof(cnt2));
    queue<int> q;
    int len = 0;

    // 统计入度
    for (int i = 1; i <= ecnt; ++i) if (ins[i]) deg[e[i].to]++;
    q.push(s); cnt1[s] = 1;

    // 正向拓扑算cnt1
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ord[++len] = u;
        for (int i = head[u]; i; i = e[i].next) {
            if (!ins[i]) continue;
            int v = e[i].to;
            cnt1[v] = (cnt1[v] + cnt1[u]) % MOD;
            if (--deg[v] == 0) q.push(v);
        }
    }

    // 逆拓扑算cnt2
    for (int i = len; i >= 1; --i) {
        int u = ord[i];
        cnt2[u] = 1;
        for (int i = head[u]; i; i = e[i].next) {
            if (!ins[i]) continue;
            int v = e[i].to;
            cnt2[u] = (cnt2[u] + cnt2[v]) % MOD;
        }
    }
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        add_edge(u, v, w);
    }
    for (int s = 1; s <= n; ++s) {
        spfa(s);
        topo(s);
        // 统计每条边的贡献
        for (int i = 1; i <= ecnt; ++i) {
            if (ins[i]) {
                // 假设e[i].from是u，e[i].to是v
                ans[i] = (ans[i] + 1LL * cnt1[e[i].from] * cnt2[e[i].to]) % MOD;
            }
        }
    }
    for (int i = 1; i <= m; ++i) cout << ans[i] << endl;
    return 0;
}
```

**代码解读概要**：  
1. `add_edge`：链式前向星存图。  
2. `spfa`：求单源最短路，标记最短路图的边。  
3. `topo`：正向拓扑算`cnt1`（起点到各点的路径数），逆拓扑算`cnt2`（各点到其他点的路径数）。  
4. `main`：遍历所有起点，调用`spfa`和`topo`，最后输出每条边的贡献。


### 📌 题解一片段赏析（来源：xyz32768）  
**亮点**：SPFA+拓扑排序的标准实现，逻辑清晰。  
**核心代码片段**：  
```cpp
void spfa(int S) {
    memset(dis, INF, sizeof(dis));
    memset(ins, 0, sizeof(ins));
    dis[que[len=1] = S] = 0;
    for (int i=1; i<=len; ++i) {
        int u=que[i]; vis[u]=0;
        for (int e=adj[u]; e; e=nxt[e]) {
            int v=go[e];
            if (dis[u]+val[e] < dis[v]) {
                dis[v] = dis[u]+val[e];
                if (!vis[v]) vis[que[++len]=v] = 1;
            }
        }
    }
    for (int i=1; i<=m; ++i)
        if (dis[st[i]] + val[i] == dis[go[i]]) ins[i] = 1;
}
```  
**代码解读**：  
- `que`数组模拟队列，`len`是队列长度。`vis`标记节点是否在队列中，避免重复入队。  
- 松弛操作：如果`dis[u]+val[e] < dis[v]`，更新`dis[v]`并将v入队。  
- 最后遍历所有边，标记`ins[i]`为1当且仅当边在最短路图中。  
**学习笔记**：SPFA的核心是“队列优化的Bellman-Ford”，适合处理有负权边的图（本题边权正，但SPFA更通用）。


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：《像素探险家的最短路日志》  
**设计思路**：用8位像素风模拟“探险家找最短路+统计路径”的过程，结合复古游戏元素（音效、关卡），让学习更有趣。

### 🕹️ 动画帧步骤  
1. **初始化**：  
   - 屏幕显示像素化地图（节点是彩色方块，边是灰色线条），左上角是“控制面板”（单步、自动、重置按钮，速度滑块）。  
   - 播放8位风格BGM（如《超级马里奥》的轻松旋律）。  

2. **单源最短路（SPFA）**：  
   - 点击“开始”，起点（比如节点1）闪烁红光，队列用像素方块堆叠展示。  
   - 每松弛一条边，边变蓝色，节点v闪烁绿光，伴随“叮”的音效。  
   - 完成最短路计算后，所有最短路图的边变蓝，播放“完成”音效。  

3. **拓扑排序**：  
   - 节点按拓扑序“排队”（从起点开始，依次向右移动），`cnt1`数值用黄色像素数字显示在节点下方，每累加一次数字跳动。  
   - 逆拓扑序时，节点向左移动，`cnt2`数值用紫色像素数字显示，累加时播放“滴”的音效。  

4. **统计贡献**：  
   - 每条蓝边的`cnt1[u]×cnt2[v]`结果用橙色数字显示在边中间，逐步累加总贡献。  
   - 完成所有统计后，播放“胜利”音效（如《塞尔达》的 treasure 音效），所有边的贡献值闪烁。  

### 🎯 交互设计  
- **单步执行**：点击“下一步”，动画走一步，同步显示当前代码行（如`spfa`的松弛操作）。  
- **自动播放**：滑块调节速度（1x~5x），自动演示整个过程。  
- **重置**：恢复初始状态，重新开始。  


## 6. 拓展练习与相似问题

### 🔗 通用思路迁移  
本题的“单源最短路+拓扑DP”思路可用于：  
1. **最短路计数**（如洛谷P1144）：统计从起点到终点的最短路数。  
2. **路径覆盖问题**（如洛谷P2764）：在DAG中找最少路径覆盖所有节点。  
3. **有向无环图的最长路径**（如洛谷P1807）：拓扑排序+DP求最长路径。

### 📚 洛谷推荐练习  
1. **P1144 最短路计数**：基础最短路计数，练惯用拓扑或BFS算路径数。  
2. **P2384 最短路统计**：类似本题，统计每条边的最短路经过次数（简化版）。  
3. **P3371 单源最短路径**：练惯用Dijkstra/SPFA求最短路，掌握图的存储。  


## 7. 学习心得与经验分享  
**参考经验（来自xyz32768）**：“最短路图是DAG，所以可以用拓扑排序。一开始没想到逆拓扑算cnt2，后来画了个小例子才明白——逆序处理就能累加后续节点的路径数。”  
**点评**：这位作者的经验很实用！遇到“统计从某点出发的路径数”时，先想“图的性质”（比如DAG），再想“处理顺序”（拓扑逆序）。画小例子是很好的debug方法，能帮你快速理清逻辑。


## 🎉 结语  
本题的核心是“最短路图+拓扑DP”，关键是理解“乘法原理”和“拓扑逆序”的妙用。多练相似题目，比如最短路计数、DAG路径问题，就能熟练掌握这套思路。记住：编程的乐趣在于“用逻辑解决问题”，慢慢来，你一定能学会！💪

---
处理用时：89.07秒
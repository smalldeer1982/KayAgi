# 题目信息

# [AHOI2005] 穿越磁场

## 题目描述

探险机器人在Samuel星球上寻找一块奇特的矿石，然而此时它陷入了一片神秘的磁场区域，动弹不得。

探险空间站立刻扫描了这片区域，绘制出该区域的磁场分布平面图。这片区域中分布了N个磁场，每个磁场呈正方形，且边与坐标轴平行。

例如下图中，存在3个磁场，白点表示机器人的位置，黑点表示矿石的位置：

 ![](https://cdn.luogu.com.cn/upload/pic/1642.png) 

科学家们分析平面图，进一步发现：这些磁场为大小不一的正方形，可能相交，甚至覆盖，但是它们的边缘不会重合，顶点也不会重合。

例如下面的两种情形是不会出现的：

 ![](https://cdn.luogu.com.cn/upload/pic/1643.png) 

科学家们给探险机器人启动了磁力罩，这样它就可以在磁场中自由穿越了。

初始时，探险机器人和所有矿石都不在任何磁场的边缘。由于技术限制，在穿越过程中机器人只能够水平或垂直移动，且不能够沿着磁场的边缘行动。

由于磁力罩的能量有限，科学家们希望探险机器人穿越尽量少的磁场边缘采集到这块矿石。例如上图中，探险机器人最少需要穿越两次磁场边缘。

现在小联请你编写程序，帮助科学家们设计探险机器人的路线，统计探险机器人最少需要穿越多少次磁场边缘。


## 样例 #1

### 输入

```
2
1 3 3 
2 1 4
0 0 3 4```

### 输出

```
2```

# AI分析结果

# 💡 Kay的C++算法解析：[AHOI2005]穿越磁场 深入学习指南 💡

今天我们来一起分析经典算法题「[AHOI2005]穿越磁场」。这道题能帮我们掌握**离散化技巧**和**最短路算法**的结合应用，让我们开始吧！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（离散化） + 最短路算法（01BFS/SPFA）

🗣️ **初步分析**：
解决这道题的关键就像「把世界地图缩成手账本」——首先用**离散化**将原本无限大的平面「压缩」成由磁场边界、起点终点组成的小网格，再用**最短路算法**找「穿过最少磁场边缘」的路径（此时「最短」=「穿越次数最少」）。

- **离散化**：收集所有磁场的左右/上下边界坐标、起点终点坐标，排序去重后，将大坐标转化为小网格的「格子编号」。比如原本x=1000的边界，可能变成网格里的x=5，这样大问题就变成小网格里的路径问题。
- **最短路**：每个小格子是图的节点，相邻格子间的边代价为「是否穿越磁场边缘」（1或0）。我们需要找从起点格子到终点格子的**最小代价路径**，这正好是最短路算法的擅长领域。

核心流程：  
收集关键坐标→离散化→建图（边代价1/0）→跑最短路。

可视化设计思路：我们会把离散后的网格做成「像素游戏地图」——白色格子是普通区域，灰色是磁场边界，红色是起点，绿色是终点。每步移动时当前格子闪烁，穿越边缘时会有「叮」的音效，自动播放像「贪吃蛇找食物」，完成时播放胜利音乐~


## 2. 精选优质题解参考

为了帮大家快速入门，我筛选了3份思路清晰、代码扎实的题解：

**题解一：作者D_14134（赞5）**  
* **点评**：这份题解把「离散化→建图→SPFA」的步骤讲得明明白白，尤其强调了离散化的「坑」——必须补充边界外坐标（比如-1、10000），否则机器人无法绕到磁场外面。代码结构规整，`init()`（初始化坐标）、`lsh()`（离散化）、`spfa()`（最短路）分工明确，`flag`数组标记边界的逻辑超严谨，适合初学者跟着敲代码。

**题解二：作者litble（赞3）**  
* **点评**：此题解用了更高效的**01BFS**（双端队列）代替SPFA——边代价只有0或1时，01BFS比SPFA快一倍！`prework()`函数处理离散化的逻辑很简洁，`v`数组标记每个方向的边界状态，`bfs()`用双端队列（代价0放队首，代价1放队尾），保证第一次到节点就是最小代价，代码可读性很高。

**题解三：作者Zwaire（赞2）**  
* **点评**：这份题解补充了「中间空白坐标」的技巧——如果两个相邻坐标差大于1，就加一个中间值（比如x=3和x=5之间加x=4），避免把空白区域「合并」成边界。`id()`函数将网格坐标转成节点编号的技巧很实用，适合学习如何将网格问题转化为图问题。


## 3. 核心难点辨析与解题策略

解决这道题的「绊脚石」主要有3个，我们一一拆解：

### 难点1：离散化如何避免「漏区域」？
**问题**：如果只保留磁场边界和起点终点，会漏掉「磁场外面的路」（比如机器人可以从x=-1绕过去）。  
**解法**：收集坐标时加「边界外坐标」（如-1、10000），并补充「中间空白坐标」（比如x=3和x=5之间加x=4）。  
💡 学习笔记：离散化不是「砍大刀」，而是「保留所有能走的路」。

### 难点2：如何判断边代价是1还是0？
**问题**：相邻格子间的边是否是磁场边界？  
**解法**：用二维数组`v[x][y][d]`标记「格子(x,y)向d方向（上下左右）走的代价」——如果是磁场边界，代价1，否则0。  
💡 学习笔记：建图的核心是「标记边界」，数组是最直接的工具。

### 难点3：选SPFA还是01BFS？
**问题**：两种算法都能解决最短路，但效率不同。  
**解法**：边代价为0或1时，优先用**01BFS**（双端队列，时间复杂度O(E)）；否则用SPFA或Dijkstra。  
💡 学习笔记：算法选对了，代码能快一倍！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合D_14134和litble的思路，用离散化+01BFS（更高效），逻辑清晰易读。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <deque>
  #include <cstring>
  using namespace std;

  const int MAXN = 210;
  const int INF = 0x3f3f3f3f;

  struct Field { int x1, x2, y1, y2; };
  Field fields[MAXN];
  vector<int> xs, ys;
  int n, sx, sy, tx, ty;
  int v[MAXN][MAXN][4]; // v[x][y][d]：向d方向走的代价（0/1）
  int dis[MAXN][MAXN];
  int dx[] = {-1, 1, 0, 0}; // 上、下、左、右
  int dy[] = {0, 0, -1, 1};

  // 离散化：找val在sorted数组中的位置（返回网格编号）
  int get_id(const vector<int>& sorted, int val) {
      return lower_bound(sorted.begin(), sorted.end(), val) - sorted.begin() + 1;
  }

  void prework() {
      // 1. 收集所有关键坐标（磁场边界、起点终点）
      xs.push_back(sx), xs.push_back(tx);
      ys.push_back(sy), ys.push_back(ty);
      for (int i = 0; i < n; ++i) {
          xs.push_back(fields[i].x1), xs.push_back(fields[i].x2);
          ys.push_back(fields[i].y1), ys.push_back(fields[i].y2);
      }
      // 2. 排序去重
      sort(xs.begin(), xs.end());
      xs.erase(unique(xs.begin(), xs.end()), xs.end());
      sort(ys.begin(), ys.end());
      ys.erase(unique(ys.begin(), ys.end()), ys.end());
      // 3. 补充中间空白（避免合并空白区域）
      vector<int> new_xs = xs;
      for (int i = 1; i < xs.size(); ++i)
          if (xs[i] - xs[i-1] > 1) new_xs.push_back(xs[i]-1);
      xs = new_xs; sort(xs.begin(), xs.end());
      vector<int> new_ys = ys;
      for (int i = 1; i < ys.size(); ++i)
          if (ys[i] - ys[i-1] > 1) new_ys.push_back(ys[i]-1);
      ys = new_ys; sort(ys.begin(), ys.end());
      // 4. 补充边界外坐标（避免地图被围死）
      xs.push_back(-1), xs.push_back(10000);
      ys.push_back(-1), ys.push_back(10000);
      sort(xs.begin(), xs.end());
      sort(ys.begin(), ys.end());
      // 5. 标记磁场边界的代价
      memset(v, 0, sizeof(v));
      for (int i = 0; i < n; ++i) {
          Field& f = fields[i];
          int x1 = get_id(xs, f.x1);
          int x2 = get_id(xs, f.x2);
          int y1 = get_id(ys, f.y1);
          int y2 = get_id(ys, f.y2);
          // 左右边界（x方向）
          for (int y = y1; y <= y2; ++y) {
              v[x1][y][1] = 1; // 从x1向下走（右边界）代价1
              v[x2][y][0] = 1; // 从x2向上走（左边界）代价1
          }
          // 上下边界（y方向）
          for (int x = x1; x <= x2; ++x) {
              v[x][y1][3] = 1; // 从y1向右走（下边界）代价1
              v[x][y2][2] = 1; // 从y2向左走（上边界）代价1
          }
      }
      // 6. 转换起点终点为网格编号（从0开始）
      sx = get_id(xs, sx) - 1;
      sy = get_id(ys, sy) - 1;
      tx = get_id(xs, tx) - 1;
      ty = get_id(ys, ty) - 1;
  }

  void bfs() {
      memset(dis, 0x3f, sizeof(dis));
      deque<pair<int, int>> q;
      dis[sx][sy] = 0;
      q.push_back({sx, sy});
      while (!q.empty()) {
          auto [x, y] = q.front();
          q.pop_front();
          for (int d = 0; d < 4; ++d) {
              int nx = x + dx[d], ny = y + dy[d];
              if (nx < 0 || nx >= xs.size() || ny < 0 || ny >= ys.size()) continue;
              int cost = v[x][y][d];
              if (dis[nx][ny] > dis[x][y] + cost) {
                  dis[nx][ny] = dis[x][y] + cost;
                  cost ? q.push_back({nx, ny}) : q.push_front({nx, ny});
              }
          }
      }
  }

  int main() {
      cin >> n;
      for (int i = 0; i < n; ++i) {
          int x, y, l;
          cin >> x >> y >> l;
          fields[i] = {x, x + l, y, y + l};
      }
      cin >> sx >> sy >> tx >> ty;
      prework();
      bfs();
      cout << dis[tx][ty] << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  1. `prework()`：收集坐标→离散化→标记边界→转换起点终点。  
  2. `bfs()`：用双端队列实现01BFS，代价0的边放队首，代价1的放队尾，保证最小代价。  
  3. `main()`：读入数据→调用`prework()`→调用`bfs()`→输出结果。


### 针对各优质题解的片段赏析

**题解一（D_14134）：补充边界外坐标**  
* **亮点**：避免机器人无法绕路。  
* **核心代码片段**：  
  ```cpp
  X[++xx] = -1, xp[xx] = xx;
  X[++xx] = 10000, xp[xx] = xx;
  ```
* **代码解读**：  
  为什么加`-1`和`10000`？比如所有磁场都在x=1~100之间，加`X=-1`后，离散后的网格会包含x=-1的区域，机器人可以从这里绕到磁场外面！如果没有这一步，机器人就只能在磁场内部挤来挤去，可能找不到路。  
* 💡 学习笔记：离散化要「留后路」，边界外的区域也很重要！

**题解二（litble）：01BFS的双端队列**  
* **亮点**：比SPFA快一倍的关键。  
* **核心代码片段**：  
  ```cpp
  deque<PR> q;
  dis[sx][sy] = 0;
  q.push_back({sx, sy});
  while (!q.empty()) {
      auto [x, y] = q.front(); q.pop_front();
      for (int d = 0; d < 4; ++d) {
          int nx = x + dx[d], ny = y + dy[d];
          if (dis[nx][ny] > dis[x][y] + v[x][y][d]) {
              dis[nx][ny] = dis[x][y] + v[x][y][d];
              v[x][y][d] ? q.push_back({nx, ny}) : q.push_front({nx, ny});
          }
      }
  }
  ```
* **代码解读**：  
  双端队列的魔法——代价0的边（不穿越边缘）放在队首，优先处理；代价1的边（穿越边缘）放在队尾。这样队列里的节点按「代价从小到大」排列，每个节点第一次被访问时，得到的就是最小代价！  
* 💡 学习笔记：边代价0/1时，01BFS是最优解！


## 5. 算法可视化：像素动画演示

为了让大家「看明白」离散化和01BFS，我设计了**像素探险家**游戏风格的动画：

### 动画主题
机器人（红色像素）在像素网格中找矿石（绿色），穿越磁场边界（灰色）时会有提示，完成后播放胜利音乐~

### 核心演示内容
1. **场景初始化**：  
   - 8位像素网格（32x32），白色=普通区域，灰色=磁场边界，红色=起点，绿色=终点。  
   - 控制面板：开始/暂停、单步、重置，速度滑块（1x-5x），音乐开关。  
   - 播放《超级马里奥》风格的8位背景音乐。

2. **算法启动**：  
   - 起点闪烁，伴随「滴」的提示音，显示「起点：(sx, sy)」。  
   - 双端队列用像素块堆在右侧，初始时只有起点。

3. **核心步骤演示**：  
   - **单步执行**：点击「单步」，当前格子闪烁，向四个方向移动：  
     - 代价0（普通区域）：新格子蓝色闪烁，放队首，伴随「啪」的轻响。  
     - 代价1（磁场边界）：新格子黄色闪烁，放队尾，伴随「叮」的提示音。  
   - **自动播放**：机器人像「贪吃蛇」一样移动，每穿越一次边缘，上方「穿越次数」+1。

4. **目标达成**：  
   - 机器人到达终点时，绿色格子闪烁，播放胜利音效（《塞尔达》宝箱声），显示「胜利！最少穿越次数：X」。


## 6. 拓展练习与相似问题思考

掌握了「离散化+最短路」后，可以尝试以下题目巩固：

### 相似问题推荐
1. **洛谷 P1339 [USACO09OCT]Heat Wave G**  
   * 推荐理由：经典最短路问题，用Dijkstra或SPFA解决，巩固最短路基础。  
2. **洛谷 P1144 最短路计数**  
   * 推荐理由：边代价为1，用BFS计算最短路的数量，强化BFS应用。  
3. **洛谷 P2921 [USACO08DEC]Trick or Treat on the Farm G**  
   * 推荐理由：离散化+找环，巩固「将大问题缩成小网格」的技巧。


## 7. 学习心得与经验分享

从题解中，我们能学到超实用的经验：  
> **D_14134的经验**：「最开始卡了很久，后来画图才发现漏掉了边界外的区域。」  
> **点评**：编程遇坑时，**画图**是最好的调试工具！把离散后的网格画出来，立刻就能发现问题。  

> **litble的经验**：「边代价0/1时，01BFS比SPFA快很多。」  
> **点评**：算法选对了，效率翻倍！遇到边代价只有0/1的问题，优先想01BFS~


## 结语
这道题的核心是「用离散化缩小问题规模，用最短路找最优解」。希望大家能掌握这两个技巧，下次遇到「大坐标路径问题」时，能轻松拆解！  

记住：编程的本质是「把复杂问题拆成简单问题」——离散化帮你拆，最短路帮你解。加油，你一定能行！💪

---
处理用时：176.05秒
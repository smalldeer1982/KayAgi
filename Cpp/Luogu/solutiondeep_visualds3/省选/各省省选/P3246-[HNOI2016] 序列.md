# 题目信息

# [HNOI2016] 序列

## 题目描述

给定长度为 $ n $ 的序列：$ a_1, a_2, \cdots , a_n $，记为 $ a[1 \colon n] $。类似地，$ a[l \colon r] $（$ 1 \leq l \leq r \leq N$）是指序列：$ a_{l}, a_{l+1}, \cdots ,a_{r-1}, a_r$。若 $1\leq l \leq s \leq t \leq r \leq n$，则称 $ a[s \colon t] $ 是 $ a[l \colon r] $ 的子序列。

现在有 $ q $ 个询问，每个询问给定两个数 $ l $ 和 $ r $，$ 1 \leq l \leq r \leq n $，求 $ a[l \colon r] $ 的不同子序列的最小值之和。例如，给定序列
 $ 5, 2, 4, 1, 3 $，询问给定的两个数为 $ 1 $ 和 $ 3 $，那么 $ a[1 \colon 3] $ 有 $ 6 $ 个子序列 $a[1 \colon 1], a[2 \colon 2], a[3 \colon 3], a[1 \colon 2],a[2 \colon 3], a[1 \colon 3] $，这 $6 $ 个子序列的最小值之和为 $5+2+4+2+2+2=17$。

## 说明/提示

对于 $100\%$ 的数据，$ 1 \leq n,q \leq 100000$，$|a_i| \leq 10^9$。

## 样例 #1

### 输入

```
5 5
5 2 4 1 3
1 5
1 3
2 4
3 5
2 5```

### 输出

```
28 
17 
11 
11 
17```

# AI分析结果


# 题解分析：HNOI2016 序列

## 题目概述
给定长度为 $n$ 的序列 $a_1$ 到 $a_n$，$q$ 次询问，每次求区间 $[l, r]$ 中所有子区间的最小值之和。

## 核心算法：在线RMQ+预处理
### 算法思路
1. **预处理区间最小值位置**：使用ST表在 $O(1)$ 时间内查询任意区间的最小值位置。
2. **预处理左右边界**：利用单调栈计算每个位置 $i$ 左侧第一个比 $a_i$ 小的位置 $lef[i]$ 和右侧第一个比 $a_i$ 小的位置 $rig[i]$。
3. **预处理前缀/后缀和**：
   - $fl[i]$：以 $i$ 为右端点的所有区间的最小值之和（从左边界 $lef[i]+1$ 到 $i$）。
   - $fr[i]$：以 $i$ 为左端点的所有区间的最小值之和（从 $i$ 到右边界 $rig[i]-1$）。
   - $gl[i]$：$fl$ 的后缀和（$gl[i] = gl[i+1] + fl[i]$）。
   - $gr[i]$：$fr$ 的前缀和（$gr[i] = gr[i-1] + fr[i]$）。
4. **查询处理**：对于每个询问 $[l, r]$：
   - 找到区间最小值位置 $p$。
   - 计算三部分贡献：
     - 最小值 $a_p$ 的贡献：$a_p \times (p-l+1) \times (r-p+1)$。
     - 左半部分 $[l, p-1]$：$gl[l] - gl[p] - fl[p] \times (p-l)$。
     - 右半部分 $[p+1, r]$：$gr[r] - gr[p] - fr[p] \times (r-p)$。

### 算法分析
- **时间复杂度**：
  - 预处理：$O(n \log n)$（ST表） + $O(n)$（单调栈） = $O(n \log n)$。
  - 查询：$O(1)$ 每查询。
- **空间复杂度**：$O(n \log n)$（ST表） + $O(n)$（其他数组）。
- **优势**：在线算法，查询速度快，适合多次查询。

### 可视化算法演示
- **初始化阶段**：
  1. 构建ST表：将序列分块，每块预处理最小值位置。
  2. 单调栈：扫描序列，维护递增栈，记录每个位置的左右边界。
- **查询阶段**：
  1. ST表查询 $[l, r]$ 的最小值位置 $p$。
  2. 计算 $p$ 的贡献（覆盖 $p$ 的子区间）。
  3. 利用预处理的和式快速计算左右两半的贡献。

## 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAXN = 100005;
int n, q, a[MAXN];
int lef[MAXN], rig[MAXN]; // 左右第一个比 a[i] 小的位置
ll fl[MAXN], fr[MAXN];    // 前缀/后缀最小值贡献
ll gl[MAXN], gr[MAXN];    // fl 的后缀和, fr 的前缀和

// ST表部分
int st[MAXN][20], lg[MAXN];

void buildST() {
    lg[0] = -1;
    for (int i = 1; i <= n; i++) {
        lg[i] = lg[i >> 1] + 1;
        st[i][0] = i;
    }
    for (int j = 1; (1 << j) <= n; j++) {
        for (int i = 1; i + (1 << j) - 1 <= n; i++) {
            int k = i + (1 << (j - 1));
            st[i][j] = a[st[i][j - 1]] < a[st[k][j - 1]] ? st[i][j - 1] : st[k][j - 1];
        }
    }
}

int queryMin(int l, int r) {
    int k = lg[r - l + 1];
    int mid = r - (1 << k) + 1;
    return a[st[l][k]] < a[st[mid][k]] ? st[l][k] : st[mid][k];
}

// 单调栈预处理 lef 和 rig
void preprocessBounds() {
    stack<int> s;
    // 左侧边界
    for (int i = 1; i <= n; i++) {
        while (!s.empty() && a[s.top()] >= a[i]) s.pop();
        lef[i] = s.empty() ? 0 : s.top();
        s.push(i);
    }
    while (!s.empty()) s.pop();
    // 右侧边界
    for (int i = n; i >= 1; i--) {
        while (!s.empty() && a[s.top()] > a[i]) s.pop();
        rig[i] = s.empty() ? n + 1 : s.top();
        s.push(i);
    }
}

// 预处理 fl, fr, gl, gr
void preprocessSums() {
    // fl[i]: 以 i 为右端点的最小值贡献
    for (int i = 1; i <= n; i++)
        fl[i] = fl[lef[i]] + 1LL * a[i] * (i - lef[i]);
    // fr[i]: 以 i 为左端点的最小值贡献
    for (int i = n; i >= 1; i--)
        fr[i] = fr[rig[i]] + 1LL * a[i] * (rig[i] - i);
    // gl[i]: fl 的后缀和
    for (int i = n; i >= 1; i--)
        gl[i] = gl[i + 1] + fl[i];
    // gr[i]: fr 的前缀和
    for (int i = 1; i <= n; i++)
        gr[i] = gr[i - 1] + fr[i];
}

int main() {
    scanf("%d%d", &n, &q);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

    buildST();
    preprocessBounds();
    preprocessSums();

    while (q--) {
        int l, r;
        scanf("%d%d", &l, &r);
        int p = queryMin(l, r); // 区间最小值位置
        ll ans = 1LL * a[p] * (p - l + 1) * (r - p + 1);
        ans += (gr[r] - gr[p] - fr[p] * (r - p));
        ans += (gl[l] - gl[p] - fl[p] * (p - l));
        printf("%lld\n", ans);
    }
    return 0;
}
```

## 总结
- **算法优势**：在线处理，查询速度快（$O(1)$），适合多次查询场景。
- **关键点**：通过单调栈和ST表预处理，将复杂查询转化为常数时间操作。
- **适用性**：适用于静态序列的多次区间查询，特别是当查询次数大时效率显著。

此算法以 $O(n \log n)$ 预处理和 $O(1)$ 查询的高效性，成为解决此类问题的首选方案。

---
处理用时：284.90秒
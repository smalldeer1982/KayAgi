# 题目信息

# [ZJOI2017] 树状数组

## 题目描述

漆黑的晚上，九条可怜躺在床上辗转反侧。难以入眠的她想起了若干年前她的一次悲惨的 OI 比赛经历。那是一道基础的树状数组题。

给出一个长度为 $n$ 的数组 $A$，初始值都为 $0$，接下来进行 $m$ 次操作，操作有两种：

* $1\ x$，表示将 $A_x$  变成 $(A_x + 1) \bmod 2$。
* $2\ l\ r$，表示询问 $(\sum_{i=l}^r A_i) \bmod 2$。

尽管那个时候的可怜非常的 simple，但是她还是发现这题可以用树状数组做。当时非常 young 的她写了如下的算法：

![](https://cdn.luogu.com.cn/upload/pic/4744.png)

其中 $\mathrm{lowbit}(x)$ 表示数字 $x$ **最低**的非 $0$ 二进制位，例如 $\text{lowbit}(5) = 1, \text{lowbit}(12) = 4$。进行第一类操作的时候就调用 $\mathrm{Add}(x)$，第二类操作的时候答案就是 $\mathrm{Query}(l, r)$。

如果你对树状数组比较熟悉，不难发现可怜把树状数组写错了：**$\text{Add}$ 和 $\text{Find}$ 中 $x$  变化的方向反了**。因此这个程序在最终测试时华丽的爆 0 了。

然而奇怪的是，在当时，这个程序通过了出题人给出的大样例——这也是可怜没有进行对拍的原因。

现在，可怜想要算一下，这个程序回答对每一个询问的概率是多少，这样她就可以再次的感受到自己是一个多么非的人了。然而时间已经过去了很多年，即使是可怜也没有办法完全回忆起当时的大样例。幸运的是，她回忆起了大部分内容，唯一遗忘的是每一次第一类操作的 $x$ 的值，因此她假定这次操作的 $x$ 是在 $[l_i, r_i]$  范围内**等概率随机**的。

具体来说，可怜给出了一个长度为 $n$ 的数组 $A$，初始为 $0$，接下来进行了 $m$ 次操作：

* $1\ l\ r$，表示在区间 $[l, r]$ 中等概率选取一个 $x$ 并执行 $\text{Add}(x)$ 。

* $2\ l\ r$，表示询问执行 $\text{Query}(l, r)$ 得到的结果是正确的概率是多少。

## 说明/提示

#### 样例说明

在进行完 $\mathrm{Add}(3)$ 之后，$A$ 数组变成了 $[0, 1, 1, 0, 0]$。所以前两次询问可怜的程序答案都是 $1$，因此第一次询问可怜一定正确，第二次询问可怜一定错误。

#### 数据范围

| 测试点编号 |        $n$         |              $m$               |      其他约定      |
| :--------: | :----------------: | :----------------------------: | :----------------: |
|    $1$     |      $\le 5$       |            $\le 10$            |         无         |
|    $2$     |      $\le 50$      |      $\le 50$      |         无         |
|    $3$     |      $\le 50$      |      $\le 50$      |         无         |
|    $4$     | $\le 3\times 10^3$ | $\le 3\times 10^3$ |         无         |
|    $5$     | $\le 3\times 10^3$ | $\le 3\times 10^3$ |         无         |
|    $6$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |
|    $7$     |       $10^5$       |       $10^5$       | 所有询问都在修改后 |
|    $8$     |       $10^5$       |       $10^5$       |         无         |
|    $9$     |       $10^5$       |       $10^5$       |         无         |
|    $10$    |       $10^5$       |       $10^5$       |         无         |


对于 $100\%$ 的数据，保证 $1\leq l\leq r\leq n$。

更新：2018/05/13 @larryzhong 提供了 5 组强的数据。

## 样例 #1

### 输入

```
5 5
1 3 3
2 3 5
2 4 5
1 1 3
2 2 5```

### 输出

```
1
0
665496236```

# AI分析结果


### 题目分析
本题考察树状数组的变种实现及概率分析。九条可怜的错误实现将前缀和计算变为后缀和，导致查询结果依赖于 $A_{l-1}$ 和 $A_r$ 的相等关系。核心难点在于动态维护随机修改下二元组 $(A_i, A_j)$ 相等的概率。

#### 核心算法识别
- **算法分类**：二维线段树（树套树）与概率复合
- **比喻解释**：想象一个二维网格，每个格子 $(i,j)$ 存储 $A_i=A_j$ 的概率。每次修改像在网格上喷洒颜料，不同区域染色程度不同（概率影响不同），需高效更新和查询单点。
- **核心流程**：
  1. 修改 $[L,R]$ 时，将平面划分为多个矩形区域：
     - $[1,L-1]×[L,R]$ 和 $[L,R]×[R+1,n]$：以 $1-\frac{1}{len}$ 概率不变
     - $[L,R]×[L,R]$：以 $1-\frac{2}{len}$ 概率不变
     - 特殊点 $(0,j)$（$l=1$ 时）：$j∈[L,R]$ 时以 $p=\frac{1}{len}$ 不变，否则为 $0$
  2. 查询 $(l-1,r)$ 时复合路径上所有概率
- **可视化设计**：复古像素风格展示二维网格，高亮当前修改影响的矩形区域，用颜色深浅表示概率变化，辅以8-bit音效标记关键操作。

#### 精选题解
1. **鬼烨（赞27）**
   - **思路**：二维线段树外层维护 $i$，内层维护 $j$，标记永久化
   - **亮点**：概率复合公式 $P' = P·Q + (1-P)(1-Q)$ 满足结合律，支持高效合并
   - **代码规范**：结构清晰，变量名明确（`rt` 外层根，`tr` 内层节点）
   - **优化**：逆元预处理，空间 $O(n\log^2 n)$

2. **shadowice1984（赞22）**
   - **思路**：矩阵乘法描述概率转移（$2×2$ 矩阵复合）
   - **亮点**：将概率变换转为矩阵乘法，数学严谨
   - **实践价值**：标记永久化实现矩形修改，$O(\log^2 n)$ 时间复杂度

3. **ywy_c_asm（赞12）**
   - **思路**：平衡树套矩阵维护概率变换
   - **亮点**：KDT 优化矩阵复合，替罪羊树保持平衡
   - **技巧**：概率复合的线性变换性质，避免 $4×4$ 矩阵

#### 核心难点与解题策略
1. **概率复合的结合律证明**
   - **分析**：变换 $f(Q): P \rightarrow (2Q-1)P + (1-Q)$ 可复合，等价于矩阵乘法
   - **策略**：用 $v_{\text{new}} = v_1v_2 + (1-v_1)(1-v_2)$ 复合节点标记

2. **二维空间高效更新**
   - **分析**：修改影响 $O(1)$ 个矩形区域，需支持区间更新、单点查询
   - **策略**：线段树套线段树，外层 $[0,n]$ 内层 $[1,n]$，标记永久化

3. **$l=1$ 的特判处理**
   - **分析**：此时等价于 $A_r = \text{全局和}$，需独立维护
   - **策略**：用特殊点 $(0,j)$ 单独更新，分区间处理概率

#### 核心代码实现
```cpp
#include <cstdio>
typedef long long ll;
const int N = 1e5 + 5, mod = 998244353;
int n, m, cnt_outer, cnt_inner;
struct NodeY { int ls, rs, v; } tree_y[N * 400];
int root_y[N << 2];

ll qpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) res = res * a % mod;
    return res;
}

int merge(int a, int b) {
    return (1LL * a * b + 1LL * (1 - a + mod) * (1 - b + mod)) % mod;
}

void update_y(int &y, int l, int r, int yL, int yR, int v) {
    if (!y) y = ++cnt_inner, tree_y[y].v = 1;
    if (yL <= l && r <= yR) {
        tree_y[y].v = merge(tree_y[y].v, v);
        return;
    }
    int mid = (l + r) >> 1;
    if (yL <= mid) update_y(tree_y[y].ls, l, mid, yL, yR, v);
    if (yR > mid) update_y(tree_y[y].rs, mid + 1, r, yL, yR, v);
}

void update_x(int x, int l, int r, int xL, int xR, int yL, int yR, int v) {
    if (xL <= l && r <= xR) {
        update_y(root_y[x], 1, n, yL, yR, v);
        return;
    }
    int mid = (l + r) >> 1;
    if (xL <= mid) update_x(x << 1, l, mid, xL, xR, yL, yR, v);
    if (xR > mid) update_x(x << 1 | 1, mid + 1, r, xL, xR, yL, yR, v);
}

int query_y(int y, int l, int r, int ypos) {
    if (!y) return 1;
    if (l == r) return tree_y[y].v;
    int mid = (l + r) >> 1, res;
    if (ypos <= mid) res = query_y(tree_y[y].ls, l, mid, ypos);
    else res = query_y(tree_y[y].rs, mid + 1, r, ypos);
    return merge(tree_y[y].v, res);
}

int query_x(int x, int l, int r, int xpos, int ypos) {
    int res = query_y(root_y[x], 1, n, ypos);
    if (l == r) return res;
    int mid = (l + r) >> 1;
    if (xpos <= mid) return merge(res, query_x(x << 1, l, mid, xpos, ypos));
    return merge(res, query_x(x << 1 | 1, mid + 1, r, xpos, ypos));
}

int main() {
    scanf("%d%d", &n, &m);
    while (m--) {
        int op, l, r;
        scanf("%d%d%d", &op, &l, &r);
        if (op == 1) {
            ll p = qpow(r - l + 1, mod - 2);
            if (l > 1) {
                update_x(1, 0, n, 1, l - 1, l, r, (1 - p + mod) % mod);
                update_x(1, 0, n, 0, 0, 1, l - 1, 0);
            }
            if (r < n) {
                update_x(1, 0, n, l, r, r + 1, n, (1 - p + mod) % mod);
                update_x(1, 0, n, 0, 0, r + 1, n, 0);
            }
            update_x(1, 0, n, l, r, l, r, (1 - 2 * p % mod + mod) % mod);
            update_x(1, 0, n, 0, 0, l, r, p);
        } else {
            printf("%d\n", l == 1 ? query_x(1, 0, n, 0, r) : query_x(1, 0, n, l - 1, r));
        }
    }
    return 0;
}
```

#### 可视化方案：像素动画演示
- **主题**：8-bit 风格网格探险
- **设计**：
  1. **场景**：$n×n$ 像素网格（FC 风格），格子 $(i,j)$ 用颜色表示 $A_i=A_j$ 概率（0: 红→1: 蓝）
  2. **修改动画**：
     - 喷枪效果：修改 $[L,R]$ 时，高亮受影响矩形（闪烁黄框）
     - 概率更新：格子颜色渐变，音效标记（入队声）
  3. **查询动画**：
     - 路径追踪：高亮查询点 $(l-1,r)$ 的树遍历路径
     - 结果展示：目标格发光+胜利音效
  4. **控制面板**：
     - 步进/播放/速度滑块
     - 重置/算法对比（正常 vs 错误树状数组）

#### 拓展练习
1. **洛谷 P1972**：树状数组+概率应用
2. **洛谷 P3759**：带修区间概率问题
3. **洛谷 P4216**：树套树优化信息复合

---

> 可视化方案将算法过程转化为互动式游戏，帮助理解二维线段树的矩形操作和概率复合机制。通过复古风格和音效反馈，使抽象的概率变化具象化。

---
处理用时：571.22秒
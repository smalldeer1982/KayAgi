# 题目信息

# [BJOI2017] 魔法咒语

## 题目描述

Chandra 是一个魔法天才。

从一岁时接受火之教会洗礼之后，Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。

直到十四岁，开始学习威力强大的禁咒法术时，Chandra 才遇到了障碍。

根据火之魔法规则，禁咒的构成单位是 $N$ 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 $L$ 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。

但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时，Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。

这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。

很多年过去了，在一次远古遗迹探险中，Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。


禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 $M$ 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。

例如，若 `banana` 是唯一的忌讳词语，`an`、`ban`、`analysis` 是基本词汇，禁咒长度须是 $11$，则 `bananalysis` 是无效法术，`analysisban`、`anbanbanban` 是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。

谜题破解，Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。

由于答案可能很大，你只需要输出答案模 $10 ^ 9 + 7$ 的结果。


## 说明/提示

【样例解释 1】

有效的禁咒法术共有 $14$ 种：`boom/bang/oo`，`oo/oo/oo/oo/oo`，`oo/oo/ooh/ooh`，`oo/ooh/oo/ooh`，`oo/ooh/ooh/oo`，`ooh/oo/oo/ooh`，`ooh/oo/ooh/oo`，`
ooh/ooh/boom`，`ooh/ooh/oo/oo`，`ooh/ooh/bang`，`ooh/bang/ooh`，`bang/oo/oo/oo`，`bang/ooh/ooh`，`bang/bang/oo`。

【样例解释 2】

有效的禁咒法术有 `a/ab`，`ab/a`，`aba` 共三种。注意，`ab/a` 和 `aba` 算成两种不同的禁咒法术。

【数据规模与约定】

本题一共有 $10$ 个测试点。

下表是每个测试点的数据规模和约定：

 ![](https://cdn.luogu.com.cn/upload/pic/5191.png) 

对于 $100\%$ 的数据，$1 \le N, M \le 50，1 \le L \le 10^8$，基本词汇的长度之和不超过 $100$，忌讳词语的长度之和不超过 $100$。保证基本词汇不重复，忌讳词语不重复。


## 样例 #1

### 输入

```
4 2 10
boom
oo
ooh
bang
ob
mo```

### 输出

```
14```

## 样例 #2

### 输入

```
3 1 3
a
ab
aba
aaa```

### 输出

```
3```

## 样例 #3

### 输入

```
3 1 14
ban
an
analysis
banana```

### 输出

```
15```

# AI分析结果


### 题目解读与核心算法识别
✨ **本题主要考察**：`AC自动机` + `动态规划` + `矩阵快速幂优化`

🗣️ **初步分析**：
> 解决"魔法咒语"问题的核心在于结合AC自动机进行字符串匹配检测，并使用动态规划计数合法方案。当基本词汇长度不超过2且L极大时，通过矩阵快速幂将O(L)优化为O(logL)。算法流程如下：
> 1. **AC自动机构建**：插入所有禁忌词汇，构建fail指针并传递非法标记（若fail路径非法则当前节点非法）。
> 2. **转移预处理**：对每个AC节点和基本词汇，模拟添加过程，记录合法转移终点。
> 3. **DP实现**：
>    - **小L（≤100）**：直接DP，状态`dp[i][j]`表示长度i且位于节点j的方案数
>    - **大L（>100）**：构造分块转移矩阵（含长度1/2的转移和单位矩阵块），矩阵快速幂加速
> 
> **可视化设计**：
> - **像素风格AC自动机**：绿色合法节点/红色非法节点，字符转移用箭头连接
> - **DP状态转移动画**：网格填充表示dp表更新，矩阵乘法时分块高亮
> - **交互控制**：步进/暂停/速度滑块，音效标记非法转移和成功状态

---

### 精选优质题解参考
**题解一（shadowice1984）**  
* **亮点**：  
  创新性地将状态向量扩展为`[dp_i, dp_{i-1}]`，通过分块矩阵同时处理长度1和2的转移。代码使用滚动数组优化空间至O(状态数²)，并详细解释了AC自动机非法标记的传递必要性（`end[u] |= end[fail[u]]`）。

**题解二（oscar）**  
* **亮点**：  
  清晰分离小L和大L的逻辑（namespace封装），矩阵构造用图示说明分块原理（左上角长度1转移/左下角单位矩阵/右上角长度2转移）。代码规范性强，边界处理严谨。

**题解三（Hoks）**  
* **亮点**：  
  提供扩展练习（POI2010 CHO-Hamsters等同类题），关键变量命名自文档化（如`tran[u][j]`表转移终点）。矩阵乘法用`long暂存+最后取模`优化常数效率。

> 共同优势：均严格处理AC自动机的非法标记传递，避免漏判禁忌词汇

---

### 核心难点辨析与解题策略
1. **非法标记传递遗漏**  
   * **分析**：AC自动机中若仅标记禁忌词终点，会漏判其子串（如禁忌词"ab"在路径"a→b"中未标记中间节点）  
   * **解决**：BFS构建fail后立即传递标记（`tag[u] |= tag[fail[u]]`）

2. **大L矩阵构造逻辑**  
   * **分析**：长度1和2的转移需共存于矩阵中，且需保留上一状态  
   * **解决**：  
     ```markdown
     状态向量设计: [当前状态dp_i, 上一状态dp_{i-1}]  
     转移矩阵分4块：
        ┌───────────┬───────────┐
        │ 长度1转移  │ 长度2转移  │  ← 新dp_i来自：
        ├───────────┼───────────┤    - 长度1：dp_{i-1}经1步转移
        │ 单位矩阵   │ 零矩阵    │    - 长度2：dp_{i-2}经2步转移
        └───────────┴───────────┘
     其中单位矩阵块将dp_{i-1}复制到新向量的dp_{i-1}位置
     ```

3. **基本词汇转移预处理**  
   * **分析**：暴力模拟每个节点添加词汇可能超时  
   * **解决**：预处理`tran[u][k]`表节点u添加词汇k的终点，若路径非法置-1

---

### C++核心代码实现赏析
```cpp
// AC自动机传递非法标记
void build() {
    queue<int> q;
    for (int i = 0; i < 26; ++i)
        if (ch[0][i]) q.push(ch[0][i]);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        end[u] |= end[fail[u]]; // 关键：传递非法标记
        for (int i = 0; i < 26; ++i) {
            int &v = ch[u][i];
            if (v) fail[v] = ch[fail[u]][i], q.push(v);
            else v = ch[fail[u]][i];
        }
    }
}

// 矩阵快速幂核心（大L情况）
Matrix operator*(const Matrix &b) const {
    Matrix res;
    for (int i = 0; i < n; ++i)
        for (int k = 0; k < n; ++k)
            for (int j = 0; j < n; ++j)
                res.a[i][j] = (res.a[i][j] + a[i][k] * b.a[k][j]) % mod;
    return res;
}

// 构造转移矩阵（分块处理）
void build_matrix() {
    // 左上块：长度1转移
    for (int u = 0; u <= cnt; ++u) 
        for (int k = 1; k <= n; ++k) 
            if (len[k] == 1 && tran[u][k] != -1)
                mat.a[u][tran[u][k]]++;
    
    // 右上块：长度2转移
    for (int u = 0; u <= cnt; ++u)
        for (int k = 1; k <= n; ++k)
            if (len[k] == 2 && tran[u][k] != -1)
                mat.a[u][cnt + 1 + tran[u][k]]++; // 偏移至右上块
    
    // 左下块：单位矩阵（传递上一状态）
    for (int i = 0; i <= cnt; ++i)
        mat.a[cnt + 1 + i][i] = 1; 
}
```

---

### 算法可视化：像素动画演示
* **整体风格**：8位红白机像素风，配电子音效  
* **动态演示流程**：  
  1. **AC自动机构建**：  
     - 禁忌词汇"mo"→节点逐步变红，fail指针用黄色箭头连接  
     - 音效：禁忌词终点节点出现时播放低音警告  

  2. **DP转移（小L）**：  
     - 网格：行=长度(0~L)，列=AC节点  
     - 添加词汇"oo"→绿色像素从(0,0)移动到(2,5)，伴随"叮"声  

  3. **矩阵乘法（大L）**：  
     ```markdown
     ┌─────────────────┐
     │ 长度1转移        │  dp_i新状态
     │   [绿块移动]     │
     ├─────────────────┤
     │ 单位矩阵         │  dp_{i-1}→dp_i
     │   [黄块闪烁]     │
     └─────────────────┘
     ```
     - 矩阵块颜色：绿色=长度1转移/蓝色=长度2转移/黄色=单位矩阵  
     - 音效：矩阵乘法时播放快速电子音阶  

* **交互控制面板**：  
  - 速度滑块：调节单步执行速度  
  - "AI演示"模式：自动播放完整算法流程（如贪吃蛇路径探索）  

---

### 拓展练习与相似问题
1. **通用技巧迁移**：  
   - **POJ2778**：DNA序列禁特定模式串（纯长度1转移）  
   - **HDU2243**：长度≤L的方案数（矩阵加等比数列求和）  
   - **CodeForces 696D**：带权值的禁忌词汇覆盖  

2. **洛谷推荐**：  
   - **P4052 [JSOI2007]文本生成器**  
     > 理由：同AC自动机+DP计数，巩固"至少一个禁忌词"的补集转化思维  
   - **P6120 [USACO17OPEN] COWBASIC**  
     > 理由：矩阵快速幂优化循环，学习高维状态设计  
   - **P3311 [SDOI2014] 数数**  
     > 理由：AC自动机+数位DP，综合性强  

---

### 学习心得与经验分享
> **来自shadowice1984的调试经验**：  
> “初始未传递fail树的非法标记，导致漏判禁忌子串。通过打印AC自动机转移路径定位问题”  
>   
> **Kay总结**：  
> 1. AC自动机必须做`end[u] |= end[fail[u]]`，否则会漏判  
> 2. 小数据暴力DP验证后再扩展矩阵快速幂  
> 3. 矩阵维度=2×AC状态数，避免开小  

---

> 本次解析就到这里，继续坚持刷题，你的魔法咒语终将释放出惊人威力！✨

---
处理用时：188.93秒
# 题目信息

# [AHOI2017/HNOI2017] 单旋

## 题目描述

H 国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了 H 国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数” 来企图毁灭 H 国。“卡” 给 H 国的人洗脑说，splay 如果写成单旋的，将会更快。“卡”称“单旋 splay”为“spaly”。虽说他说的很没道理，但还是有 H 国的人相信了，小 H 就是其中之一，spaly 马上成为他的信仰。而 H 国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由 $m$（不超过 $10^5$）个操作构成，他知道这样的数据肯定打垮 spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作所需要的实际代价的任务就交给你啦。

数据中的操作分为 $5$ 种：

1. 插入操作：向当前非空 spaly 中插入一个关键码为 $key$ 的新孤立节点。插入方法为，先让 $key$ 和根比较，如果 $key$ 比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，$key$ 比当前子树根 $x$ 小，而 $x$ 的左子树为空，那就让 $key$ 成为 $x$ 的左孩子；或者 $key$ 比当前子树根 $x$ 大，而 $x$ 的右子树为空，那就让 $key$ 成为 $x$ 的右孩子。该操作的代价为：插入后，$key$ 的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度” 的解释见末尾对 spaly 的描述。）

2. 单旋最小值：将 spaly 中关键码最小的元素 $x \min$ 单旋到根。操作代价为：单旋前 $x \min$ 的深度。（对于单旋操作的解释见末尾对 spaly 的描述。）

3. 单旋最大值：将 spaly 中关键码最大的元素 $x \max$ 单旋到根。操作代价为：单旋前 $x \max$ 的深度。

4. 单旋删除最小值：先执行 $2$ 号操作，然后把根删除。由于 $2$ 号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同 $2$ 号操作。

5. 单旋删除最大值：先执行 $3$ 号操作，然后把根删除。操作代价同 $3$ 号操作。

![](https://cdn.luogu.com.cn/upload/pic/5106.png)

对于不是 H 国的人，你可能需要了解一些 spaly 的知识，才能完成国王的任务：

1. spaly 是一棵二叉树，满足对于任意一个节点 $x$，它如果有左孩子 $lx$，那么 $lx$ 的关键码小于 $x$ 的关键码。如果有右孩子 $rx$，那么 $rx$ 的关键码大于 $x$ 的关键码。

2. 一个节点在 spaly 的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。

3. 单旋操作是对于一棵树上的节点 $x$ 来说的。一开始，设 $f$ 为 $x$ 在树上的父亲。如果 $x$ 为 $f$ 的左孩子，那么执行 $zig (x)$ 操作（如上图中，左边的树经过 $zig (x)$ 变为了右边的树）, 否则执行 $zag (x)$ 操作（在上图中，将右边的树经过 $zag (f)$ 就变成了左边的树）。每当执行一次 $zig (x)$ 或者 $zag (x)$,$x$ 的深度减小 $1$，如此反复，直到 $x$ 为根。总之，单旋 $x$ 就是通过反复执行 $zig$ 和 $zag$ 将 $x$ 变为根。

## 说明/提示

$20 \%$ 的数据满足： $1 \leq m \leq 1000$。

另外 $30\%$ 的数据满足：不存在 $4,5$ 操作。

$100\%$ 的数据满足：$1 \leq m \leq 10^5,1 \leq key \leq 10^9$。 所有出现的关键码互不相同。 任何一个非插入操作，一定保证树非空。 在未执行任何操作之前，树为空。

## 样例 #1

### 输入

```
5
1 2
1 1
1 3
4 
5```

### 输出

```
1 
2 
2
2 
2```

# AI分析结果


### 💡 Kay的C++算法解析：单旋 深入学习指南 💡

> 今天我们来分析“[AHOI2017/HNOI2017] 单旋”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数据结构模拟`（动态维护二叉搜索树形态与深度）

🗣️ **初步分析**：
> 解决“单旋”题目的关键在于**动态维护二叉搜索树（BST）的形态变化和深度信息**。想象一下，我们正在用积木搭建一棵会旋转的树——每次操作就像移动特定积木（最小/最大值），同时调整整棵树的连接结构。核心挑战在于：
> - **插入操作**：新节点需精准嫁接在深度最大的前驱/后继下方
> - **单旋操作**：最小/最大值上旋至根时，需重构父子关系并更新子树深度
> - **深度维护**：所有节点深度需高效动态更新（区间加减）
> 
> **可视化设计思路**：
> - 用像素网格模拟BST（x轴为键值，y轴为深度）
> - 单旋时：高亮操作节点（红色），显示子树移动轨迹（黄色箭头），其他节点下移（+1深度→蓝色加深）
> - 复古音效：节点移动(滴答声)，旋转完成(胜利音效)，删除(碎裂声)

---

## 2. 精选优质题解参考

> 从学习角度评估，筛选出思路清晰、代码规范、实践性强的解法：

**题解一（作者：老K）**
* **点评**：采用**离散化+权值线段树+set**的组合方案。亮点在于：
  - **思路直白**：插入时通过前驱/后继深度比较确定父节点
  - **代码规范**：明确分离深度维护（线段树）与结构维护（set）
  - **优化技巧**：线段树区间加减高效处理深度变化（O(log n)）
  > 调试心得：注意深度更新范围（如单旋时需排除自身子树）

**题解二（作者：shadowice1984）**
* **点评**：**线段树+set+树形结构数组**实现。亮点：
  - **结构清晰**：用fa[]/ch[][]数组显式维护父子关系
  - **效率优化**：插入时直接定位深度最大父节点
  - **边界严谨**：离散化处理保证键值唯一性
  > 关键调试：旋转后子树接驳需验证父子指针双向更新

**题解三（作者：DOTime）**
* **点评**：**树状数组+set**的轻量级方案。亮点：
  - **代码简洁**：树状数组实现深度区间加减
  - **实践友好**：无需复杂树旋转，直接修改连接关系
  > 学习价值：理解树状数组如何替代线段树进行深度管理

---

## 3. 核心难点辨析与解题策略

> 解决此类问题的关键难点及应对策略：

1.  **难点1：动态维护深度**
    * **分析**：单旋操作引发非操作子树深度集体±1。优质解法普遍采用**差分思想**（树状数组/线段树区间修改），避免暴力更新。
    * 💡 **学习笔记**：深度变化本质是区间操作，数据结构优化是核心

2.  **难点2：快速定位插入位置**
    * **分析**：新节点的父节点必是前驱或后继，且选择深度较大者。**Set维护有序节点集合**，实现O(log n)前驱/后继查询。
    * 💡 **学习笔记**：BST插入位置由键值有序性和深度共同决定

3.  **难点3：树形结构调整**
    * **分析**：单旋操作需精确修改父子指针：
    ```python
    # 单旋最小值伪代码
    min_node = set.first()
    parent = fa[min_node]
    parent.left = min_node.right  # 右子树嫁接给父节点
    min_node.right = root         # 原根变为右孩子
    fa[root] = min_node
    ```
    * 💡 **学习笔记**：指针修改需同步更新父节点和子节点双向关系

### ✨ 解题技巧总结
1. **离散化先行**：大范围键值→紧凑整数映射，优化存储与查询
2. **职责分离**：独立模块处理深度维护（树状数组/线段树）和结构维护（set/数组）
3. **边界防御**：空树/单节点等边界情况需特判
4. **可视化调试**：小规模手工模拟验证指针更新逻辑

---

## 4. C++核心代码实现赏析

**通用核心实现参考**（综合自优质题解）：
```cpp
#include <set>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 1e5+5;
set<int> treeSet; // 维护存在节点
int fa[MAXN], ch[MAXN][2]; // 父指针/左右孩子
int root, totalNodes; // 根节点/当前节点数

// 树状数组维护深度
class FenwickTree {
    int tree[MAXN], size;
    int lowbit(int x) { return x & -x; }
public:
    void init(int n) { size = n; }
    void update(int x, int v) { 
        while (x <= size) tree[x] += v, x += lowbit(x); 
    }
    int query(int x) { 
        int res = 0;
        while (x) res += tree[x], x -= lowbit(x);
        return res;
    }
    void rangeAdd(int l, int r, int v) { 
        update(l, v); update(r+1, -v); 
    }
} depthTree;

int insert(int key) {
    if (treeSet.empty()) { // 空树初始化
        root = key;
        depthTree.rangeAdd(key, key, 1);
        treeSet.insert(key);
        return 1;
    }
    auto it = treeSet.upper_bound(key);
    int succ = it != treeSet.end() ? *it : -1;
    int pred = it != treeSet.begin() ? *prev(it) : -1;

    int parent = -1;
    if (pred != -1 && depthTree.query(pred) > depthTree.query(succ)) {
        parent = pred; ch[parent][1] = key;
    } else {
        parent = succ; ch[parent][0] = key;
    }
    fa[key] = parent;
    int newDepth = depthTree.query(parent) + 1;
    depthTree.rangeAdd(key, key, newDepth);
    treeSet.insert(key);
    return newDepth;
}
```

**题解一关键片段赏析**：
```cpp
// 单旋最小值（老K）
void rotateMin() {
    int minNode = *treeSet.begin();
    int parent = fa[minNode], rightChild = ch[minNode][1];
    int oldDepth = depthTree.query(minNode);

    // 嫁接右子树给父节点
    if (parent) ch[parent][0] = rightChild;
    if (rightChild) fa[rightChild] = parent;

    // 原根变为右孩子
    ch[minNode][1] = root;
    fa[root] = minNode;

    // 更新深度：非子树节点+1
    depthTree.rangeAdd(1, n, 1);
    depthTree.rangeAdd(minNode, minNode, 1 - oldDepth);
}
```
> **代码解读**：
> 1. 定位最小值节点及其父节点
> 2. 将最小值的右子树嫁接给父节点（左子树必空）
> 3. 原根节点变为最小值的右孩子
> 4. 整树深度+1，但最小值节点深度重置为1
> 💡 **学习笔记**：深度更新需排除自身子树（先全局+1再单独修正）

---

## 5. 算法可视化：像素动画演示

**主题**：8位机风格的动态BST模拟器  
**核心演示**：插入/单旋时树形变化与深度更新  

![](https://cdn.luogu.com.cn/upload/pic/5106.png)  
*图：单旋操作示意图（原题提供）*

**动画流程设计**：
1. **初始化界面**：
   - 16色像素网格：x轴（键值1~100），y轴（深度1~5）
   - 控制面板：操作按钮（插入/单旋/删除）+ 速度滑块

2. **插入操作演示**：
   ```python
   # 伪代码流程
   点击"插入" → 输入键值 → 新节点(黄色)从顶部落下
   while 当前节点非叶节点:
       与当前节点(蓝色)比较 → 向左/右移动
   停在前驱(红色)/后继(绿色)下方 → 显示深度值
   ```

3. **单旋最小值**：
   - **步骤1**：最小值节点闪烁红光，播放提示音
   - **步骤2**：右子树（黄色块）沿虚线箭头移动到父节点位置
   - **步骤3**：原根节点（蓝色）变为最小值右孩子，位置下移
   - **步骤4**：非子树节点颜色变深（深度+1），最小值升到根部

4. **交互控制**：
   - 单步模式：空格键逐步执行
   - 自动演示：AI模拟操作流程（速度可调）
   - 音效反馈：移动(滴)、旋转完成(叮)、错误(嗡)

---

## 6. 拓展练习与相似问题思考

**技巧迁移场景**：
1. 动态维护二叉树深度：`[NOIP2014] 联合权值`
2. 数据结构模拟：`[ZJOI2006] 书架`
3. 离线离散化+树状数组：`[SDOI2009] 虔诚的墓主人`

**洛谷题目推荐**：
1. **P3391 【模板】文艺平衡树**  
   → 练习伸展树核心操作
2. **P2042 [NOI2005] 维护数列**  
   → 综合训练伸展树实现技巧
3. **P3369 【模板】普通平衡树**  
   → 巩固BST基础操作与深度理解

---

## 7. 学习心得与经验分享

> 来自题解作者的调试经验：
> 
> **gorokokoro**：  
> *“调试时发现深度更新范围错误——单旋后子树深度不应变化。解决方案：用树状数组区间更新时排除子树范围”*
>
> **Kay的总结**：  
> 深度更新需精确控制作用域，建议：
> 1. 画图确认受影响节点范围
> 2. 输出中间状态验证
> 3. 小数据集手工演算

---

> 本次“单旋”题解分析就到这里。记住：编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的挑战！💪

---
处理用时：160.66秒
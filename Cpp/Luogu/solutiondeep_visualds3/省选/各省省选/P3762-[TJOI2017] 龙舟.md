# 题目信息

# [TJOI2017] 龙舟

## 题目描述

加里敦大学有一个龙舟队，龙舟队有 $n$ 支队伍，每只队伍有 $m$ 个划手。龙舟比赛是一个集体项目，和每个人的能力息息相关，但由于龙舟讲究配合，所以评价队伍的能力的是一个值 $C=\frac{b_1 \times b_2 \times \cdots \times b_m}{a_1 \times a_2 \times \cdots \times a_m}$，其中 $b_i$ 表示第 $i$ 个位置的标准能力值，$a_i$ 表示在队伍中第 $i$ 个位置的划手的能力值。最后通过约分，我们会得到 $C=\frac{B}{A}$，其中 $\gcd(B,A)=1$，即 $A,B$ 互质。

但是由于比赛现场的情况不一样，我们认为在现场压力为 $M$ 的情况下，队伍最后的表现情况是 $C^{-1}\mod M$。我们规定在模 $M$ 的条件下 $\frac{1}{x}=y$，其中 $y$ 满足 $xy \equiv 1\pmod M$，并且 $y$ 大于等于 $0$ 小于 $M$。如果不存在这样的 $y$ 我们就认为在压力为 $M$ 的条件下这支队伍会发挥失常（即 $y$ 是 $x$ 在模 $M$ 意义下的逆元，如果不存在逆元我们认为队伍发挥失常）。给出这个赛季的比赛安排情况，现在教练组想知道各队在比赛中的表现情况。

## 说明/提示

对于 $20\%$ 的数据，$1<M,a_i,b_i<10^8$，$m \le 100$。

对于 $100\%$ 的数据，$1<M,a_i,b_i<2 \times 10^{18}$，$m \le 10000$，$n \le 20$，$k \le 50$。

## 样例 #1

### 输入

```
2 3 3
5 2 3
3 2 3
2 3 2
1 4
2 4
1 7```

### 输出

```
3
-1
4```

# AI分析结果


### Kay的C++算法解析：龙舟 深入学习指南 💡

#### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：`数论（质因数分解与模逆元）`  

🗣️ **初步分析**：  
> 本题要求计算分数模逆元，核心挑战在于处理大数（$2×10^{18}$）的质因数分解与约分。想象你在做披萨分配：分母$a_i$若与模数$M$不互质（有共同质因数），就无法公平分割（逆元不存在）。解题分三步走：  
> 1. **分解$M$的质因数**（用Pollard Rho算法）  
> 2. **约分处理**：将分子$b_i$和分母$a_i$中$M$的质因数约去，记录指数差  
> 3. **计算逆元**：剩余部分用欧拉定理求逆元  
>  
> **可视化设计**：采用8位像素风计算器界面，分三屏演示：  
> - 屏幕1：$M$被分解为像素方块质因数（爆破动画+音效）  
> - 屏幕2：$b_i$/$a_i$数值条被质因数方块"吞噬"（绿色+1/红色-1）  
> - 屏幕3：剩余数值快速相乘（LED屏显示），逆元计算时二进制指数闪烁  

---

#### **2. 精选优质题解参考**  
**题解（来源：agicy）**  
* **点评**：  
  解法采用**分层处理**避免直接计算大数乘积：  
  - **思路亮点**：分解$M$而非每个$a_i/b_i$，将复杂度从$O(m·M^{1/4})$降至$O(k·M^{1/4})$  
  - **代码规范**：模块化设计（Miller-Rabin检测、Pollard Rho分解）  
  - **算法优化**：质因数指数差检查提前判定无解（-1）  
  - **实践价值**：完整处理$2×10^{18}$数据，欧拉定理求逆替代扩展欧几里得  

---

#### **3. 核心难点辨析与解题策略**  
1. **难点1：大数质因数分解**  
   * **分析**：$M≤2×10^{18}$使试除法失效，Pollard Rho算法通过随机步探测因子  
   * 💡 **学习笔记**：$x_{n+1}=(x_n^2+c) \mod M$ 的循环性可高效找因子  

2. **难点2：避免中间结果溢出**  
   * **分析**：直接计算$\prod b_i/\prod a_i$会溢出，改为：  
     - 仅保留与$M$互质的部分  
     - 用快速乘（加法模拟乘法）处理模运算  
   * 💡 **学习笔记**：$a×b \mod M = \sum_{i=0}^{k} (a·2^i \mod M)$（$b$的二进制分解）  

3. **难点3：逆元存在性判定**  
   * **分析**：约分后若分母与$M$不互质则无解，通过质因数指数负值检测  
   * 💡 **学习笔记**：$\gcd(A,M)\neq1 ⇒ A^{-1} \mod M$ 不存在  

**✨ 解题技巧总结**  
- **质因数压缩**：分解$M$后只需处理相关质因子  
- **欧拉定理替代**：$\varphi(M)$可快速计算，避免扩展欧几里得的递归开销  
- **边界防御**：$a_i=0$时直接返回-1（题解未提及但建议补充）  

---

#### **4. C++核心代码实现赏析**  
**通用核心实现参考**  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;

// 快速乘 (防溢出)
ll mul(ll a, ll b, ll mod) {
    ll res = 0;
    while (b) {
        if (b & 1) res = (res + a) % mod;
        a = (a + a) % mod;
        b >>= 1;
    }
    return res;
}

// 快速幂
ll pow(ll x, ll exp, ll mod) {
    ll res = 1;
    while (exp) {
        if (exp & 1) res = mul(res, x, mod);
        x = mul(x, x, mod);
        exp >>= 1;
    }
    return res;
}

// 核心解题函数
void solve(int id, ll M) {
    // Step1: 分解M的质因数
    vector<ll> factors = pollard_rho(M);
    
    // Step2: 约分并记录指数差
    vector<int> exp_diff(factors.size(), 0);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < factors.size(); j++) {
            while (b[i] % factors[j] == 0) {
                exp_diff[j]++;
                b[i] /= factors[j];
            }
            while (a[id][i] % factors[j] == 0) {
                exp_diff[j]--;
                a[id][i] /= factors[j];
            }
        }
    }
    
    // Step3: 检查无解并计算剩余乘积
    ll nume = 1, deno = 1;
    for (int j = 0; j < factors.size(); j++) {
        if (exp_diff[j] < 0) { cout << "-1\n"; return; }
        nume = mul(nume, pow(factors[j], exp_diff[j], M), M);
    }
    for (int i = 0; i < m; i++) {
        nume = mul(nume, b[i], M);
        deno = mul(deno, a[id][i], M);
    }
    
    // Step4: 欧拉定理求逆元
    ll phi = compute_phi(M, factors); // 根据质因数计算φ(M)
    cout << mul(nume, pow(deno, phi - 1, M), M) << "\n";
}
```

**关键片段解析**  
1. **快速乘（防溢出）**  
   ```cpp
   ll mul(ll a, ll b, ll mod) {
       ll res = 0;
       while (b) {
           if (b & 1) res = (res + a) % mod; // 累加当前位
           a = (a + a) % mod;                // 预计算下一位
           b >>= 1;                          // 移位
       }
       return res;
   }
   ```
   > **类比**：如同用加法器组装乘法器，$a×7 = a×4 + a×2 + a×1$  
   > **学习笔记**：此方法将乘法复杂度从$O(1)$降至$O(\log b)$，但避免了大数溢出  

2. **质因数指数检查**  
   ```cpp
   for (int j = 0; j < factors.size(); j++) {
       if (exp_diff[j] < 0) { 
           cout << "-1\n"; 
           return; 
       }
   }
   ```
   > **设计逻辑**：若分母的某质因子次数更高（指数差负值），则剩余部分仍含该因子，导致与$M$不互质  
   > **学习笔记**：负指数检查是逆元存在性的关键判据  

---

#### **5. 算法可视化：像素动画演示**  
* **主题**：8位计算器《质因数大冒险》  
* **核心流程**：  
  ![](https://via.placeholder.com/400x200?text=Pixel+Animation+Frame)  
  **帧1：质因数分解**  
  - $M$显示为金色方块，爆破成像素质因数（不同颜色）  
  - **音效**：爆破声 + 质因数落地的"叮"声  

  **帧2：约分过程**  
  - $b_i$/$a_i$数值条从左向右移动，被质因数方块"吞噬"  
  - 指数计数器：绿字（+1） / 红字（-1）闪烁  
  - **交互**：点击质因数查看当前指数差  

  **帧3：逆元计算**  
  - 剩余数值用LED样式显示，快速乘过程展现二进制位操作  
  - 欧拉定理计算时，$\varphi(M)$公式浮动显示  
  - **成功动画**：结果像素块拼成龙舟图案 + 胜利音效  

* **游戏化设计**：  
  - **关卡模式**：每通过一个询问解锁新难度（$M$增大）  
  - **错误反馈**：指数负值时屏幕闪烁红光 + 警报声  

---

#### **6. 拓展练习与相似问题**  
1. **洛谷 P3811** - 乘法逆元  
   > 🗣️ 线性求逆元模板，巩固模运算基础  
2. **洛谷 P4718** - Pollard Rho模板  
   > 🗣️ 专练大数分解，优化本题的关键步骤  
3. **CodeForces 1513C** - 扩展欧几里得应用  
   > 🗣️ 综合逆元与递推关系，提升数论建模能力  

---

#### **7. 学习心得与经验分享**  
> **作者调试经验**（agicy）：  
> *"初始版本未检查指数差直接求逆元，导致WA。建议在分解后立即输出质因数指数表验证"*  
>   
> **Kay总结**：  
> 大数问题需**分步验证中间状态**，质因数指数表是核心调试工具。类似地，在快速乘中可添加中间值输出语句。

通过本指南，你不仅掌握了质因数分解与模逆元的协同应用，更学会用分层处理化解大数危机。下次遇到$10^{18}$级数据时，记得召唤Pollard Rho这位像素冒险伙伴！🚣

---
处理用时：127.02秒
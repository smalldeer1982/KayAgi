# 题目信息

# [JLOI2008] 将军

## 题目描述

刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\_T。

言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：

给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。

这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。

现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。

国际象棋中一共有 6 种棋子：

- king（国王）；
- queen（皇后）；
- bishop（教主）；
- knight（骑士）；
- rook（车）；
- pawn（步兵）。

各棋子的攻击范围如下：

- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；
- knight 的攻击范围如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

- rook 攻击水平和垂直两条线上的所有格子；
- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；
- king 攻击周围 8 个方向各 1 格；
- bishop 攻击两条对角线上的所有格子。

除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。

可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。

## 说明/提示

```plain
BBN
...
...
```

```plain
BBN
...
B..
```

虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。


## 样例 #1

### 输入

```
3 3
..N
...
...
```

### 输出

```
2```

# AI分析结果


# 💡 Kay的C++算法解析：[JLOI2008] 将军 深入学习指南 💡

<introduction>
今天我们来分析国际象棋中的主教放置问题。本指南将帮助你理解棋盘旋转技巧、攻击范围预处理和二分图匹配的核心思想，并通过像素动画直观展示算法流程。让我们一起破解这个"主教最多能放几个"的难题！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二分图匹配`（图论应用）

🗣️ **初步分析**：
> 解决"将军"问题的核心在于**棋盘旋转技巧**。想象将棋盘顺时针旋转45°后，主教的斜线攻击神奇地变成了水平和垂直攻击！这就像把倾斜的镜子摆正后，反射角度变得规整易处理。
>
> **核心思路**： 
> 1. 预处理标记所有已有棋子的攻击范围（注意骑士攻击不会被阻挡）
> 2. 将可放置区域映射到旋转后的坐标系
> 3. 建立二分图模型（行→列）
> 4. 用匈牙利算法求最大匹配
>
> **可视化设计**：
> 在像素动画中，我们将：
> - 用闪烁红光动态标记攻击范围
> - 展示棋盘旋转的网格变形过程
> - 用蓝色连线演示匹配过程
> - 添加"棋子放置音效"和"匹配成功"的8-bit音效
> - 实现"AI自动演示"模式，像解谜游戏般逐步展示算法

---

## 2. 精选优质题解参考

<eval_intro>
基于思路清晰度、代码规范性和算法优化度，我精选了以下优质题解：

**题解一：caizehua（4星）**
* **点评**：  
  这份题解最突出的亮点是**详细的坐标映射教学**。作者用结构体清晰存储旋转后坐标(`a[i][j].xx/yy`)，并创新性地用`can`变量三重状态标记（0可放置/1有棋子/2被攻击）。  
  在预处理部分，对六种棋子的攻击范围模拟**逻辑严谨完整**，特别是处理"阻挡"的循环跳出条件。匈牙利算法实现规范，变量命名合理(`r[]`行标记/`c[]`列标记)。  
  实践价值极高，完整代码包含完整输入处理和调试建议，作者特别强调"整行输入"的坑点，这对避免竞赛WA很有帮助。

**题解二：GNAQ（4星）**
* **点评**：  
  **代码结构简洁高效**是最大亮点。独创的`pau`数组映射法实现坐标旋转（`pau[i][0]+j-1`计算新坐标），比常规公式更节省内存。  
  攻击范围处理采用模块化函数（`GoB()/GoQ()`等），代码复用率高。匈牙利算法用链式前向星存图，`Find()`函数实现标准。  
  特别有价值的是作者对算法选择的实战建议——提到"Dinic跑不过但匈牙利可以"，这揭示了**稀疏图匹配的特性**。

**题解三：lly66666（3.5星）**
* **点评**：  
  解法**简洁实用**，特别适合快速实现。用统一框架处理攻击范围（如`bishop()`用`b=y-x`计算对角线），减少了代码冗余。  
  二分图建图部分直接使用STL vector存图，匈牙利算法实现清晰。虽然旋转坐标解释较简略，但整体算法正确性有保障，适合基础较好的学习者参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三个关键难点：

1.  **攻击范围模拟的完整性**
    * **分析**：  
      六种棋子攻击规则各异，且除骑士外都会被阻挡。优质题解通用策略是：  
      - 用`check()`函数处理边界和阻挡  
      - 骑士用固定方向数组  
      - 车/皇后/教主用`while循环+break`模拟阻挡  
      - 特别注意题目要求：新主教不能攻击原棋子，反之亦然
    * 💡 **学习笔记**：攻击范围模拟要像"光线的直线传播"，遇阻即停

2.  **坐标映射的准确性**
    * **分析**：  
      旋转映射需保证双射关系。主流方案有两种：  
      1. **公式法**：新行 = i+j-1，新列 = j+n-i（caizehua解法）  
      2. **增量法**：用`pau`数组记录每行起始坐标（GNAQ解法）  
      关键要处理旋转后坐标偏移，保证`(n+m-1)*(n+m-1)`新网格不越界
    * 💡 **学习笔记**：棋盘旋转如同折纸，对角线就是新的横纵线

3.  **二分图建模的巧妙性**
    * **分析**：  
      将可放置点的新行号作为左部，新列号作为右部建边。难点在理解：  
      - 匹配成功 = 放置主教  
      - 每个行/列只能有一个主教（斜线互斥）  
      匈牙利算法的`vis[]`标记避免环路是关键优化
    * 💡 **学习笔记**：行列匹配就是"十字路口的交通管制"

### ✨ 解题技巧总结
1. **分而治之**：拆解为"攻击模拟→坐标映射→匹配求解"三阶段
2. **方向向量封装**：用`dx/dy`数组统一处理8方向（骑士单独处理）
3. **状态压缩**：用位运算或`bool`矩阵高效存储攻击范围
4. **匈牙利剪枝**：用时间戳(`Time`变量)替代`memset(vis)`加速

---

## 4. C++核心代码实现赏析

<code_intro_overall>
下面展示综合优化的核心实现，融合了坐标映射和匈牙利算法：

```cpp
#include<bits/stdc++.h>
#define N 2050
using namespace std;

int n,m,ans;
char mp[N][N];
bool attack[N][N]; // 攻击范围标记
int match[N<<2],vis[N<<2]; // 匈牙利算法
vector<int> g[N<<1]; // 二分图邻接表

// 坐标映射函数 (公式法)
inline int newX(int i,int j){ return i+j-1; }
inline int newY(int i,int j){ return j-i+n; }

void markAttack(int i,int j, int dx[], int dy[], int len, bool blockable){
    for(int k=0;k<len;k++){
        for(int step=1;;step++){
            int x = i+dx[k]*step, y = j+dy[k]*step;
            if(x<1||x>n||y<1||y>m||(blockable&&mp[x][y]!='.')) break;
            attack[x][y] = true;
        }
    }
}

void buildGraph(){
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            if(!attack[i][j] && mp[i][j]=='.'){
                int u = newX(i,j), v = newY(i,j) + (n+m);
                g[u].push_back(v);
            }
        }
    }
}

bool dfs(int u,int tag){
    if(vis[u]==tag) return false;
    vis[u]=tag;
    for(int v:g[u]){
        if(!match[v] || dfs(match[v],tag)){
            match[v]=u; return true;
        }
    }
    return false;
}

int main(){
    cin>>n>>m;
    // 攻击范围预处理(略)
    buildGraph();
    for(int i=1;i<=2*(n+m);i++) 
        if(dfs(i,i)) ans++;
    cout<<ans;
}
```

**代码解读概要**：  
1. `markAttack()`统一处理可阻挡的攻击类型  
2. `newX()`/`newY()`实现坐标旋转映射  
3. 建图时左部节点用`newX`值，右部用`newY`值偏移避免冲突  
4. 匈牙利算法用时间戳(`tag`)优化`vis`数组重置  

---

<code_intro_selected>
精选题解核心代码亮点分析：

**题解一：caizehua**  
* **亮点**：三维状态标记和旋转坐标结构体  
* **核心代码**：
  ```cpp
  struct node{ int xx,yy,can; }a[N][N];
  // 坐标转换
  for(int i=1;i<=n;i++) 
      for(int j=1;j<=m;j++) 
          a[i][j] = {i+j-1, j+n-i, (mp[i][j]!='.')?1:0};
  ```
* **学习笔记**：结构体封装使坐标变换更直观

**题解二：GNAQ**  
* **亮点**：`pau`数组实现增量式坐标计算  
* **核心代码**：
  ```cpp
  pau[1][0]=1; pau[1][1]=m; // 起始坐标
  for(int i=2;i<=n;i++) 
      pau[i][0]=pau[i-1][0]+1, pau[i][1]=pau[i-1][1]-1;
  // 新坐标计算
  _x = pau[i][0]+j-1; _y = pau[i][1]+j-1;
  ```
* **学习笔记**：增量法避免重复计算，提升效率

**题解三：lly66666**  
* **亮点**：STL vector建图与统一攻击函数接口  
* **核心代码**：
  ```cpp
  // 方向向量统一传递
  void mark(int dx[],int dy[],int len){
      for(int k=0;k<len;k++) /*...*/ 
  }
  ```
* **学习笔记**：标准化参数接口增强代码复用性

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**主题**：8-bit国际象棋解密  
**核心演示**：棋盘旋转与匈牙利匹配的像素化过程  
**设计理念**：用复古游戏风格将抽象算法具象化，通过音效强化关键操作记忆  

### 动画帧设计
1. **初始棋盘（FC红白机风格）**  
   - 棕色像素块：已有棋子（K/Q等字母标识）  
   - 灰色网格：安全区域，绿色闪烁：可放置位点  
   *音效：经典"马里奥金币"声*

2. **攻击范围标记（动态扩散）**  
   - 红色波纹：从棋子位置扩散攻击范围  
   - 遇到其他棋子时触发"阻挡"动画（像素墙升起）  
   *音效：不同频率的"警报"声*

3. **棋盘旋转（45°变换）**  
   - 网格顺时针旋转动画（0.5秒/帧）  
   - 旋转后坐标显示在侧边栏（如`(3,2)→(4,5)`)  
   *音效：齿轮转动声*

4. **二分图匹配（连线解谜）**  
   ![](https://assets.algorithm-visualizer.org/illustrations/bipartite-matching.png)
   - 左部：黄色行号块，右部：蓝色列号块  
   - 可匹配时产生绿色连接线（伴随"连接"音效）  
   - 增广路径查找时路径高亮闪烁  

5. **自动演示模式**  
   - 速度滑块控制匹配速度（1x-5x）  
   - 每成功匹配一个主教触发：  
     *像素主教降落动画 + 得分音效 + 分数+1*

### 交互控制面板
```plain
[开始] [暂停] [单步] [重置] 速度：■■■■□
当前匹配数：0  剩余可放置点：24
```

### 技术实现要点
- **Canvas绘制**：每个格子10x10像素，攻击范围用半透明红色层
- **坐标映射**：`drawRotatedGrid(ctx)`实现45°旋转
- **音效触发**：Web Audio API播放8-bit音效片段

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握"棋盘旋转+二分图"的解题范式后，可解决更多变体问题：

1. **方向扩展**：处理骑士共存问题（攻击方向为L形）
2. **维度升级**：三维空间放置问题（立方体对角线）
3. **动态障碍**：随时间变化的障碍物场景

### 洛谷推荐
1. **P2825 [HEOI2016]游戏**  
   🗣️ *推荐理由*：在含障碍棋盘放置炸弹，体验行列匹配的直接应用

2. **P3355 骑士共存问题**  
   🗣️ *推荐理由*：学习如何处理L形攻击的二分图建模

3. **P6062 模拟题**  
   🗣️ *推荐理由*：综合训练棋盘预处理和匹配优化技巧

---

## 7. 学习心得与经验分享

<insights_intro>
题解作者们的调试经验尤其珍贵：

> **caizehua的忠告**：  
> "输入整个棋盘后再处理！逐字符读取容易导致边界错位"  
> *→ 启示：棋盘类问题优先整行读取(`cin>>mp[i]+1`)避免越界*

> **GNAQ的优化心得**：  
> "匈牙利用时间戳代替vis数组重置，速度提升40%"  
> *→ 技巧：`dfs(u,Time)`用全局递增Time标记访问*

---

<conclusion>
通过本指南，我们掌握了棋盘旋转的魔法技巧和二分图匹配的精髓。记住：国际象棋是算法的试金石，而旋转视角往往是破局关键！下次遇到类似问题，不妨试着"转一转"棋盘。继续加油，未来的算法大师！♟️
</conclusion>
```

---
处理用时：176.21秒
# 题目信息

# [FJOI2016] 神秘数

## 题目描述

一个可重复数字集合 $S$ 的神秘数定义为最小的不能被 $S$ 的子集的和表示的正整数。例如 $S=\{1,1,1,4,13\}$，有：$1 = 1$，$2 = 1+1$，$3 = 1+1+1$，$4 = 4$，$5 = 4+1$，$6 = 4+1+1$，$7 = 4+1+1+1$。

$8$ 无法表示为集合 $S$ 的子集的和，故集合 $S$ 的神秘数为 $8$。

现给定长度为 $n$ 的**正整数**序列 $a$，$m$ 次询问，每次询问包含两个参数 $l,r$，你需要求出由 $a_l,a_{l+1},\cdots,a_r$ 所组成的可重集合的神秘数。

## 说明/提示

对于 $100\%$ 的数据点，$1\le n,m\le {10}^5$，$\sum a\le {10}^9$。

## 样例 #1

### 输入

```
5
1 2 4 9 10
5
1 1
1 2
1 3
1 4
1 5```

### 输出

```
2
4
8
8
8```

# AI分析结果


### 题目分析
题目要求求解区间神秘数，即区间内无法由子集和表示的最小正整数。核心思路是利用可持久化线段树（主席树）维护区间值域信息，通过迭代扩展当前可表示的连续整数范围，直到无法扩展为止。

### 算法思路
1. **主席树构建**：
   - 每个版本维护值域区间内数的和。
   - 插入新元素时，新建节点并更新路径上的区间和。

2. **查询处理**：
   - 初始化可表示的最大连续整数 `ans = 1`。
   - 迭代查询区间内值域 `[1, ans]` 的元素和 `sum`：
     - 若 `sum >= ans`，则扩展范围至 `[1, sum]`，更新 `ans = sum + 1`。
     - 否则，跳出循环，当前 `ans` 即为神秘数。

3. **时间复杂度**：
   - 构建主席树：$O(n \log \text{MAX\_VALUE})$。
   - 单次查询：$O(\log(\sum a_i) \cdot \log \text{MAX\_VALUE})$。
   - 总复杂度：$O(n \log \text{MAX\_VALUE} + m \log(\sum a_i) \log \text{MAX\_VALUE})$。

### 代码实现
```cpp
#include <iostream>
#include <cstdio>
using namespace std;

const int MAX_N = 100005;
const int MAX_VALUE = 1000000000; // 值域上限
const int MAX_NODE = MAX_N * 32;  // 主席树节点数

struct Node {
    int l, r;   // 左右子节点索引
    int sum;    // 区间和
} tree[MAX_NODE];

int root[MAX_N]; // 每个版本的根节点
int tot;         // 节点总数

// 更新主席树
int update(int pre, int l, int r, int pos, int val) {
    int cur = ++tot;
    tree[cur] = tree[pre];
    tree[cur].sum += val;
    if (l == r) return cur;
    int mid = (l + r) >> 1;
    if (pos <= mid) 
        tree[cur].l = update(tree[pre].l, l, mid, pos, val);
    else 
        tree[cur].r = update(tree[pre].r, mid + 1, r, pos, val);
    return cur;
}

// 查询区间 [L, R] 内值域 [ql, qr] 的和
int query(int u, int v, int l, int r, int ql, int qr) {
    if (ql <= l && r <= qr) 
        return tree[v].sum - tree[u].sum;
    int mid = (l + r) >> 1;
    int res = 0;
    if (ql <= mid && tree[u].l != tree[v].l) // 有左子树
        res += query(tree[u].l, tree[v].l, l, mid, ql, qr);
    if (qr > mid && tree[u].r != tree[v].r) // 有右子树
        res += query(tree[u].r, tree[v].r, mid + 1, r, ql, qr);
    return res;
}

int main() {
    int n, m;
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        int a;
        scanf("%d", &a);
        root[i] = update(root[i - 1], 1, MAX_VALUE, a, a);
    }

    scanf("%d", &m);
    while (m--) {
        int l, r;
        scanf("%d%d", &l, &r);
        int ans = 1;
        while (true) {
            int sum_val = query(root[l - 1], root[r], 1, MAX_VALUE, 1, ans);
            if (sum_val >= ans) 
                ans = sum_val + 1;
            else 
                break;
        }
        printf("%d\n", ans);
    }
    return 0;
}
```

### 算法分析
1. **主席树作用**：
   - 高效维护区间值域信息，支持快速查询任意区间内指定值域的和。
   - 动态开点避免内存浪费，仅需 $O(n \log \text{MAX\_VALUE})$ 空间。

2. **迭代过程**：
   - 初始 `ans = 1`，表示当前可表示连续范围为 `[0,0]`（空集），目标表示 `1`。
   - 每次迭代扩展范围至少翻倍，保证最多 $O(\log(\sum a_i))$ 次迭代。

3. **正确性**：
   - 若值域 `[1, ans]` 的和 `sum` 能覆盖 `ans`，则 `[1, sum]` 均可表示。
   - 否则，`ans` 无法被表示，即为神秘数。

### 复杂度证明
- **空间**：主席树节点数 $O(n \log \text{MAX\_VALUE})$，约 $3.2 \times 10^6$。
- **时间**：单次查询 $O(\log(\sum a_i) \cdot \log \text{MAX\_VALUE})$，$m$ 次查询可接受。

### 总结
本题结合主席树的高效区间查询与迭代扩展思想，巧妙求解区间神秘数问题。核心在于利用值域信息的可加性，通过迭代扩展可表示范围，直至找到最小缺口。

---
处理用时：124.27秒
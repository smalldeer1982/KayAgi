# 题目信息

# [SDOI2019] 热闹的聚会与尴尬的聚会

## 题目背景

小 Q 的生日快到了，他决定周末邀请一些朋友到他的新房子一起聚会！

## 题目描述

他的联系薄上有 $n$ 位好友，他们两两之间或者互相认识，或者互相不认识。小 Q 希望在周六办一个热闹的聚会，再在周日办一个尴尬的聚会。

- 一场热闹度为 $p$ 的聚会请来了任意多位好友，对于每一位到场的好友来说都有至少 $p$ 位他认识的好友也参加了聚会，且至少对于一位到场的好友来说现场恰好有 $p$ 位他认识的好友；
- 一场尴尬度为 $q$ 的聚会请来了恰好 $q$ 位好友，且他们两两互不认识。

两场聚会可能有重复的参与者，联系薄上也有可能有某些好友同时缺席了两场聚会。

小 Q 喜欢周六聚会的热闹度 $p$ 与周日聚会的尴尬度 $q$ 之间满足：$\left\lfloor \frac{n}{p+1} \right\rfloor\! \le q$ 且 $\left\lfloor \frac{n}{q+1} \right\rfloor\! \le p$。

请帮助小 Q 找出一个可行的邀请方案。

## 说明/提示

#### 数据规模与约定

- 子任务 $1$（$10$ 分）：$1\le n\le 500$；  
- 子任务 $2$（$10$ 分）：$1\le n\le 700$；  
- 子任务 $3$（$10$ 分）：$1\le n\le 900$；  
- 子任务 $4$（$10$ 分）：$1\le n\le 1.1 \times {10}^3$；  
- 子任务 $5$（$10$ 分）：$1\le n\le 2 \times {10}^3$；  
- 子任务 $6$（$10$ 分）：$1\le n\le 3 \times {10}^3$；  
- 子任务 $7$（$10$ 分）：$1\le n\le 4.5 \times {10}^3$；  
- 子任务 $8$（$10$ 分）：$1\le n\le 6 \times {10}^3$；  
- 子任务 $9$（$10$ 分）：$1\le n\le 8 \times {10}^3$；  
- 子任务 $10$（$10$ 分）：$1\le n\le {10}^4$。

对于全部的测试点，满足 $1\le T\le 32$ 且 $1\le m\le 10^5$。

---

#### 提示

本题读入量很大，请注意自己代码在读入上的所需时间。

---
#### 说明

感谢 @[81179332\_](/user/53994) 提供 spj！

## 样例 #1

### 输入

```
2
6 15
1 2
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6
4 5
4 6
5 6
8 11
1 2
2 3
1 4
3 7
4 5
5 2
2 6
6 7
5 6
5 8
6 8```

### 输出

```
6 1 2 3 4 5 6
1 4
8 1 2 3 4 5 6 7 8
4 8 4 7 2```

# AI分析结果


# 💡 Kay的C++算法解析：热闹的聚会与尴尬的聚会 深入学习指南 💡

今天我们来一起分析“热闹的聚会与尴尬的聚会”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略与数据结构应用

🗣️ **初步分析**：
> 解决这道题的核心在于巧妙运用贪心策略。想象你在组织聚会：热闹聚会要保证每位嘉宾都有足够的朋友（最小度数最大化），尴尬聚会则要避免朋友相遇（最大独立集）。就像在舞池中安排站位：先找出最不受欢迎的人（度数最小点）调整位置，再精心安排互不认识的人站在一起。
> 
> - 题解普遍采用两步贪心：第一问通过不断删除度数最小点来最大化最小度数；第二问通过选择最小度数点构建独立集
> - 核心难点在于动态维护度数变化和高效选择最小度数点，可视化设计将重点展示度数更新过程（颜色深浅表示度数高低）和关键选择点（闪烁标记）
> - 采用复古像素风格模拟：节点用8位色块表示，删除操作配"破碎"音效，独立集选择配"收集"音效，自动演示模式可调速展示算法流程

---

## 2. 精选优质题解参考

<eval_intro>
以下题解在思路清晰度、代码规范性和算法效率方面表现优异（均≥4星），值得重点学习：
</eval_intro>

**题解一（作者：liuzhangfeiabc）**
* **点评**：此解法思路最为完整，清晰阐述了两问的内在联系。第一问用堆维护度数最小点，删除时记录最佳状态；第二问类似方法构造独立集，并给出严谨数学证明（q≥⌈n/(p+1)⌉）。代码实现规范（变量名`ft/wz`含义明确），包含IO优化处理大数据，边界条件处理严谨，可直接用于竞赛。亮点在于将两问贪心过程统一，并证明其自然满足题目条件。

**题解二（作者：StudyingFather）**
* **点评**：解法简洁高效，聚焦核心逻辑。使用STL优先队列实现堆，代码结构清晰易读。状态转移设计巧妙（`ord`数组记录删除顺序），独立集构造与第一问共享度数更新逻辑。实践价值突出，适合初学者理解贪心思想。亮点在于用最简代码实现完整功能，变量`maxt`精确记录最佳状态位置。

**题解三（作者：i207M）**
* **点评**：创新使用桶队列（计数排序思想）替代堆，实现O(n)高效维护度数。将度数作为数组下标，避免堆的log开销，在n较大时优势显著。代码简短但内涵深刻，`ckmax(mxp,mn)`等宏定义提升可读性。亮点在于数据结构优化，适合进阶学习高效算法设计。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下三个关键点：
</difficulty_intro>

1.  **动态维护度数变化**
    * **分析**：在贪心删除/选择过程中，需实时更新邻居度数。优质题解均采用数据结构（堆/桶队列）高效维护。堆实现简单但带log复杂度；桶队列更高效但需处理相同度数的节点队列
    * 💡 **学习笔记**：选择数据结构时权衡实现复杂度与效率，小图可用堆，大图宜用桶队列

2.  **贪心正确性证明**
    * **分析**：为什么删除最小度数点能得到最大p？因为保留该点会限制整体最小度。为什么选择最小度数点构建独立集？因为其影响范围小（度数≤p），能保证q≥⌈n/(p+1)⌉
    * 💡 **学习笔记**：贪心策略需结合数学证明，理解"局部最优导致全局最优"的条件

3.  **状态回溯与记录**
    * **分析**：第一问需记录删除过程中的最佳状态点（`bestStep`）。实现时用`ord`数组记录删除顺序，`bestDeg`记录最佳度数，最后回溯保留未删除点
    * 💡 **学习笔记**：当算法过程会破坏原始状态时，需记录关键信息以便回溯

### ✨ 解题技巧总结
<summary_best_practices>
- **技巧1（问题分解）**：将复杂问题拆解为两个相关联的子问题（热闹聚会+尴尬聚会），共享度数维护逻辑
- **技巧2（数据结构优化）**：根据问题规模选择堆（O(n log n)）或桶队列（O(n)）维护最小度数点
- **技巧3（边界处理）**：特别注意堆中"过时"度数（`if(d!=deg[u])continue`）和空队列检查
- **技巧4（IO优化）**：大数据时使用`fread/fwrite`加速输入输出

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用实现：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合堆解法与桶队列优点，完整实现两问贪心策略
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 10010;

vector<int> G[N];
int deg[N], n, m;
bool del[N], inSet[N];

int main() {
    int T; scanf("%d", &T);
    while (T--) {
        scanf("%d%d", &n, &m);
        // 初始化图
        for (int i = 1; i <= n; ++i) {
            G[i].clear();
            deg[i] = 0;
            del[i] = inSet[i] = false;
        }
        for (int i = 0; i < m; ++i) {
            int u, v; scanf("%d%d", &u, &v);
            G[u].push_back(v);
            G[v].push_back(u);
            deg[u]++; deg[v]++;
        }

        // 第一问：热闹聚会（最小度数最大化）
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
        for (int i = 1; i <= n; ++i) pq.push({deg[i], i});
        
        int bestDeg = 0, bestStep = 0;
        vector<int> order;
        while (!pq.empty()) {
            auto [d, u] = pq.top(); pq.pop();
            if (d != deg[u]) continue; // 跳过已更新节点
            
            if (d >= bestDeg) { // 记录最佳状态
                bestDeg = d;
                bestStep = order.size();
            }
            
            del[u] = true;
            order.push_back(u);
            
            // 更新邻居度数
            for (int v : G[u]) {
                if (!del[v] && --deg[v] >= 0) {
                    pq.push({deg[v], v});
                }
            }
        }
        
        // 恢复最佳状态
        fill(del, del + n + 1, false);
        for (int i = 0; i < bestStep; ++i) del[order[i]] = true;
        
        vector<int> party1;
        for (int i = 1; i <= n; ++i) 
            if (!del[i]) party1.push_back(i);
        
        printf("%d", (int)party1.size());
        for (int x : party1) printf(" %d", x);
        puts("");

        // 第二问：尴尬聚会（独立集）
        fill(del, del + n + 1, false);
        fill(inSet, inSet + n + 1, false);
        vector<int> party2;
        
        // 重新初始化度数
        for (int i = 1; i <= n; ++i) {
            deg[i] = G[i].size();
            if (deg[i] == 0) party2.push_back(i); // 孤立点直接加入
        }
        
        // 桶队列优化
        vector<queue<int>> buckets(n + 1);
        for (int i = 1; i <= n; ++i) 
            if (deg[i] > 0) buckets[deg[i]].push(i);
        
        int minDeg = 0;
        while (minDeg <= n) {
            // 跳过空桶
            while (minDeg <= n && buckets[minDeg].empty()) minDeg++;
            if (minDeg > n) break;
            
            int u = buckets[minDeg].front(); 
            buckets[minDeg].pop();
            if (del[u]) continue;
            
            party2.push_back(u);
            inSet[u] = del[u] = true;
            
            // 删除邻居及其关联边
            for (int v : G[u]) {
                if (del[v]) continue;
                del[v] = true; // 标记邻居为已删除
                
                // 更新二级邻居
                for (int w : G[v]) {
                    if (!del[w] && --deg[w] >= 0) {
                        buckets[deg[w]].push(w);
                        minDeg = min(minDeg, deg[w]);
                    }
                }
            }
        }
        
        printf("%d", (int)party2.size());
        for (int x : party2) printf(" %d", x);
        puts("");
    }
    return 0;
}
```
* **代码解读概要**：
  - **图初始化**：邻接表存储，`deg`数组记录度数
  - **第一问**：堆维护最小度数点，删除时更新邻居度数，记录最佳状态位置
  - **状态回溯**：根据`bestStep`从删除序列`order`中恢复最佳点集
  - **第二问**：桶队列（`buckets`）按度数分组节点，优先处理低度节点构建独立集
  - **邻居更新**：选择节点后删除其邻居，并更新邻居的邻居度数

---
<code_intro_selected>
优质题解核心片段解析：
</code_intro_selected>

**题解一（liuzhangfeiabc）**
* **亮点**：IO优化处理大数据，完整记录删除序列
* **核心代码片段**：
```cpp
while(!q.empty()){
    pii p = q.top(); q.pop();
    if(-p.fi != nwd[p.se]) continue;
    if(-p.fi >= p1){ // 发现更优状态
        p1 = -p.fi; wz = ft;
    }
    shan[++ft] = p.se; // 记录删除顺序
    for(i = fir[p.se];i;i=e[i].nxt) if(!d1[e[i].to]){
        --nwd[e[i].to]; // 更新邻居度数
        q.push(mp(-nwd[e[i].to],e[i].to));
    }
}
```
* **代码解读**：
  > 1. 堆中存储（-度数，节点）实现最小堆
  > 2. `nwd`数组动态维护当前度数，跳过"过时"度数
  > 3. `shan`数组记录删除序列，`wz`记录最佳状态位置
  > 4. 邻居度数更新后重新入堆
* 💡 **学习笔记**：堆中存储负度数技巧避免自定义比较函数

**题解二（StudyingFather）**
* **亮点**：STL优先队列简洁实现
* **核心代码片段**：
```cpp
for(int i=1;i<=n;i++) q.push({i,t[i]});
ansp=q.top().y;
while(!q.empty()){
    node cur=q.top(); q.pop();
    if(vis[cur.x]) continue;
    ord[++cnt]=cur.x; // 记录删除顺序
    if(q.top().y>ansp) ansp=q.top().y, pos=cnt;
    for(auto v:e[cur.x]){
        t1[v]--;
        q.push({v,t1[v]});
    }
}
```
* **代码解读**：
  > 1. `ord`数组按删除顺序记录节点
  > 2. `pos`记录最佳状态位置（`cnt`为当前删除数）
  > 3. 类似BFS方式更新邻居度数
* 💡 **学习笔记**：`auto`和基于范围的for循环简化邻接表遍历

**题解三（i207M）**
* **亮点**：桶队列实现O(n)复杂度
* **核心代码片段**：
```cpp
vector<queue<int>> buckets(n+1);
for(int i=1;i<=n;++i) buckets[deg[i]].push(i);
while(minDeg <= n){
    while(minDeg<=n && buckets[minDeg].empty()) ++minDeg;
    int u = buckets[minDeg].front(); 
    buckets[minDeg].pop();
    // 处理节点u...
    for(auto v:G[u]){
        for(auto w:G[v]){ // 更新二级邻居
            buckets[--deg[w]].push(w);
            minDeg = min(minDeg, deg[w]);
        }
    }
}
```
* **代码解读**：
  > 1. `buckets`数组下标对应度数，存储该度数的节点队列
  > 2. `minDeg`动态追踪当前最小度数位置
  > 3. 更新邻居时直接放入对应度数的桶中
* 💡 **学习笔记**：桶队列在度数范围小时效率远超堆

-----

## 5. 算法可视化：像素动画演示

\<visualization\_intro\>
下面设计一个8位像素风格动画，帮助直观理解算法流程：
\</visualization\_intro\>

  * **动画演示主题**：像素探险家构造聚会地图
  * **核心演示内容**：度数动态更新与独立集构建过程
  * **设计思路**：采用复古红白机风格，用颜色深浅表示度数高低，关键操作配经典音效增强记忆点

  * **动画帧步骤**：
    1. **场景初始化**：节点呈网格排列，深蓝（低度）-浅蓝（高度）渐变着色，控制面板含速度滑块
    2. **第一问演示**：
       - 标记最小度数点为闪烁红色，删除时播放"破碎"音效
       - 邻居度数减1，颜色变深，更新度数显示
       - 当发现新最佳状态时，当前点集绿色高亮
    3. **第二问演示**：
       - 选择最小度数点为独立集（金色），播放"收集金币"音效
       - 邻居变灰（删除），二级邻居度数更新
    4. **自动演示模式**：
       - 按空格暂停/继续，方向键调速
       - 成功时播放胜利音效，节点闪烁庆祝
    5. **状态面板**：
       - 左侧显示当前操作伪代码
       - 右侧显示度数分布直方图
       - 底部记录p/q值变化曲线

  * **交互设计**：
    - **步进控制**：`→`单步执行，`↑/↓`调整速度
    - **模式切换**：`Tab`键切换两问演示
    - **高亮显示**：鼠标悬停节点显示度数/状态
    - **音效方案**：
      * 删除节点：8位"爆破"音效（短促滴声）
      * 加入独立集：经典"金币收集"音效
      * 发现最佳状态：上升音阶
      * 错误操作：低沉警示音

\<visualization\_conclusion\>
通过像素动画，可直观观察度数变化如何影响贪心决策，理解为什么选择最小度数点是最优策略。
\</visualization\_conclusion\>

-----

## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握本题贪心思想后，可解决以下类似问题：
\</similar\_problems\_intro\>

1. **洛谷 P1979** - 华容道
   * 🗣️ **推荐理由**：同样需要高效维护状态变化，练习广度搜索与优化

2. **洛谷 P3381** - 最小费用最大流
   * 🗣️ **推荐理由**：练习贪心思想在网络流中的应用，强化数据结构维护能力

3. **洛谷 P4570** - 元素
   * 🗣️ **推荐理由**：贪心+独立集思想的变种应用，需结合线性基知识

-----

## 7. 学习心得与经验分享

\<insights\_intro\>
题解中的调试经验尤其珍贵：
\</insights\_intro\>

> **参考经验 (来自 liuzhangfeiabc)**：第一问需注意堆中"过时"度数问题，通过`if(-p.fi!=nwd[p.se])continue`跳过已更新节点
>
> **点评**：这是优先队列常见陷阱，在动态更新场景中，队列内可能存在过期状态。正确做法是比较当前度数是否匹配，否则跳过。这提醒我们：使用堆时务必验证堆顶元素是否为最新状态！

---

\<conclusion\>
通过本题，我们学习了如何用贪心策略解决图论问题，并掌握堆/桶队列优化技巧。记住：算法设计要结合严谨证明，数据结构选择需考虑问题规模。多动手实现不同解法，才能真正掌握核心思想。下次见！💪
\</conclusion\>
```

---
处理用时：216.47秒
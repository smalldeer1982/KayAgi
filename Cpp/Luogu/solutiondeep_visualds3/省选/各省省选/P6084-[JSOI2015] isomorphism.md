# 题目信息

# [JSOI2015] isomorphism

## 题目描述

一个无向树的度数为 $2$ 的结点称为假结点，其它结点称为真结点。一个无向树的简化树其结点由原树的全体真结点组成，两个真结点之间有边当且仅当它们在原树中有边，或者在原树中有一条联结这两个结点的路，其中间节点全是假结点。两个无向树各自的简化树如果同构，即存在结点之间的一一对应，使得在一个树中的任意两个结点之间有边当且仅当它们的对应结点在另一个树中有边，则称原来的两个无向树实质同构。

给定若干个无向树，将相互实质同构的无向树只保留一个其余删除。统计剩下的相互不实质同构的无向树个数，并将它们的简化树结点个数从小到大输出。

## 说明/提示

#### 数据范围

对于 $100\%$ 的数据，$2\leq m\leq 20, 2\leq n\leq 10^4$。

## 样例 #1

### 输入

```
2
4
1 4
2 4
3 4
5
1 3
2 3
3 4
4 5```

### 输出

```
1
4```

# AI分析结果


### 💡 Kay的C++算法解析：[JSOI2015] isomorphism 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`树结构处理` + `树同构判断`（树哈希算法）  
🗣️ **初步分析**：
> 这道题的核心是处理树结构的两次转换：首先**压缩原树**（移除所有度为2的节点并重新连接真节点），然后**判断压缩后的树是否同构**。就像在像素游戏中简化迷宫路径一样，我们去除冗余节点，保留关键转折点。  
> - **核心难点**：无根树同构判断需转换为有根树处理（选择重心为根），且哈希函数需能区分不同结构的树  
> - **可视化设计**：用8位像素风格展示树压缩过程（灰色方块为假结点，彩色方块为真结点），重心用闪烁金色标记，哈希计算时显示子树大小和公式浮动  

---

#### 精选优质题解参考
**题解 (作者：Great_Influence)**  
* **点评**：思路清晰分为树压缩和同构判断两步。亮点在于：
  - **重心处理**：精妙处理单/双重心情况（双重心时断开连接分别哈希）
  - **哈希设计**：`Hash[u]=⊕(Hash[v]-W[u])*W[v]` 结合子树大小和随机权重，碰撞概率低
  - **代码规范**：`ed[]`/`us[]`区分压缩前后树结构，`sz[]`/`F[]`记录子树信息，变量名明确
  - **实践价值**：随机种子初始化`w[]`提升可靠性，边界处理严谨（从叶子节点开始压缩）

---

#### 核心难点辨析与解题策略
1. **树压缩的实现**  
   * **分析**：DFS遍历时跳过度为2的节点（假结点），直接连接真结点。关键技巧：  
     - 从**叶子节点**（度=1）开始递归  
     - 传递父真结点指针`tf`建立新连接  
   * 💡 **学习笔记**：假结点=路径中转站，压缩即去除冗余路径

2. **无根树同构处理**  
   * **分析**：通过树重心转为有根树（重心性质：最大子树最小化）。双重心时：  
     - 断开重心间边，分别计算哈希后异或合并  
   * 💡 **学习笔记**：重心是树的"平衡点"，适合作为哈希基准

3. **抗碰撞哈希设计**  
   * **分析**：公式`(hs[v]-w[sz[u]])*w[sz[v]]` 三重防护：  
     - 子树大小`sz`参与计算  
     - 随机权重`w[]`防刻意构造  
     - 异或⊕消除子节点顺序影响  
   * 💡 **学习笔记**：好的树哈希=结构特征+随机化

### ✨ 解题技巧总结
- **假结点处理**：度=2的节点不存储数据，仅作路径连接  
- **重心定位**：递归计算子树大小，最大子树最小者为重心  
- **哈希技巧**：用`rand() | (ull)rand()<<30`生成64位随机权重  

---

#### C++核心代码实现赏析
**树压缩核心片段**：
```cpp
void shrink(int u, int fa, int tf, int &n) {
    if(d[u] == 2) { // 假结点处理
        for(int v : us[u]) if(v != fa) 
            shrink(v, u, tf, --n); // 跳过该节点
    } else { // 真结点处理
        if(tf) { // 连接父真结点
            ed[u].pb(tf); ed[tf].pb(u); 
        }
        for(int v : us[u]) if(v != fa) 
            shrink(v, u, u, n); // 传递当前真结点
    }
}
```
> **代码解读**：  
> - `us[]`存储原树，`ed[]`存储压缩树  
> - `d[u]==2`时递归子节点且**节点数n减1**  
> - 真结点通过`tf`参数与父真结点直连  

**树哈希核心片段**：
```cpp
void geths(int u, int fa) {
    sz[u] = 1;
    hs[u] = 0;
    for(int v : ed[u]) if(v != fa) {
        geths(v, u);             // 递归子节点
        sz[u] += sz[v];          // 累加子树大小
    }
    for(int v : ed[u]) if(v != fa)
        hs[u] ^= (hs[v] - w[sz[u]]) * w[sz[v]];
    hs[u] ^= w[sz[u]];  // 最终混合当前节点权重
}
```
> **学习笔记**：哈希值同时依赖**子树结构**和**节点规模**  

---

### 算法可视化：像素动画演示
* **主题**：`像素树形压缩探险`  
* **核心演示**：  
  ![树压缩示意图](https://via.placeholder.com/400x200?text=假结点(灰)+真结点(彩)+重心(金闪))  
  **动画流程**：  
  1. **原树展示**：灰方块(假结点)连彩色方块(真结点)  
  2. **压缩过程**：  
     - 删除灰块时播放`咔哒`音效  
     - 新增真结点直连时亮绿色连接线  
  3. **重心定位**：  
     - 当前节点标记红色光圈  
     - 重心确定时金色闪烁+`叮！`音效  
  4. **哈希计算**：  
     - 子树大小显示在节点上方  
     - 哈希公式浮动显示计算过程  
     - 成功时播放`胜利旋律`  

* **交互设计**：  
  - 速度滑块控制单步/自动播放  
  - `AI演示模式`：自动完成压缩+哈希全过程  
  - 双屏对比：并排展示不同树的压缩/哈希差异  

---

### 拓展练习与相似问题
1. **洛谷 P5043** - 树的同构  
   > 直接练习树同构判断，巩固哈希算法  
2. **洛谷 P4323** - 树叶  
   > 考察树结构分析能力，强化度相关处理  
3. **洛谷 P2664** - 树上游戏  
   > 结合重心分解(点分治)的进阶训练  

---

### 学习心得分享
> 作者Great_Influence提到：  
> *"双重心情况需断开连接分别哈希——这是同构判断最易漏的点"*  
> **Kay点评**：这提醒我们：树的结构特殊性（如对称性）需特殊处理，通过分治化解复杂性是关键思路  

---
**最终结论**：本题通过`树压缩`+`重心哈希`解决同构判断，核心在于把握树的结构特征与哈希设计。可视化中像素风格能清晰展现节点类型和计算过程，帮助理解抽象算法流程。

---
处理用时：164.93秒
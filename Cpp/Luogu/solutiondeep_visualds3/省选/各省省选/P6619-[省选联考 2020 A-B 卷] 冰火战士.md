# 题目信息

# [省选联考 2020 A/B 卷] 冰火战士

## 题目背景

A 卷 D1T1，B 卷 D1T3。

时限 3s，内存 512MB。

## 题目描述

一场比赛即将开始。

每位战士有两个属性：温度和能量，有两派战士：冰系战士的技能会对周围造成降温冰冻伤害，因而要求场地温度不低于他的自身温度才能参赛；火系战士的技能会对周围造成升温灼烧伤害，因而要求场地温度不高于他的自身温度才能参赛。

当场地温度确定时，双方能够参赛的战士分别排成一队。冰系战士按自身温度从低到高排序，火系战士按自身温度从高到低排序，温度相同时能量大的战士排在前面。首先，双方的第一位战士之间展开战斗，两位战士消耗相同的能量，能量少的战士将耗尽能量退出比赛，而能量有剩余的战士将继续和对方的下一位战士战斗（能量都耗尽则双方下一位战士之间展开战斗）。如此循环，直至某方战士队列为空，比赛结束。

你需要寻找最佳场地温度：使冰火双方消耗总能量最高的温度的最高值。

现在，比赛还处于报名阶段，目前还没有任何战士报名，接下来你将不断地收到报名信息和撤回信息。其中，报名信息包含报名战士的派系和两个属性，撤回信息包含要撤回的报名信息的序号。每当报名情况发生变化（即收到一条信息）时，你需要立即报出当前局面下的最佳场地温度，以及该场地温度下双方消耗的总能量之和是多少。若当前局面下无论何种温度都无法开展比赛（某一方没有战士能参赛），则只要输出 `Peace`。

## 说明/提示

#### 样例 1 解释
为说明方便，约定：若第 $k$ 条信息是报名信息，则该条报名信息对应战士 $k$。样例中含有战士 $1,2,3,4,6,7,8$，由于第 $5$ 条是撤回信息，所以没有战士 $5$。

下面逐个解释每个输出：

1. 只有火系战士：战士 $1$，无法比赛，输出 `Peace`。
2. 温度为 $100 \sim 103$ 都能消耗最多的能量 $200$：战士 $1$ 对阵战士 $2$ 消耗能量 $200$，最佳温度为 $103$。
3. 温度为 $100 \sim 103$ 都能消耗最多的能量 $200$：战士 $1$ 对阵战士 $2$ 消耗能量 $200$，最佳温度为 $103$。
4. 温度 $103$ 能消耗最多的能量 $300$：首先，战士 $1$ 对阵战士 $2$ 消耗能量 $200$；然后，战士 $1$ 对阵战士 $4$ 消耗能量 $100$，最佳温度为 $103$。
5. 从现在起战士 $1$ 不再存在。温度 $100 \sim 102$ 能消耗最多的能量 $200$：战士 $2$ 对阵战士 $3$ 消耗能量 $200$，最佳温度为 $102$。

#### 样例 2

见附加文件中 `icefire2.in` 与 `icefire2.ans`。

#### 数据范围

$10\%$ 的数据：$Q \leq 100$，$x \leq 10^3$。

另有 $20\%$ 的数据：$Q \leq 10^4$，$x \leq 5000$，不存在撤回信息，且输入的 $x$ 按顺序不降。

$60\%$ 的数据（包含上述 $20\%$，下同）：$Q \leq 2 \times 10^5$，$x \leq 2 \times 10^5$。

$90\%$ 的数据：$Q \leq 2 \times 10^6$，$x \leq 2 \times 10^6$。

$100\%$ 的数据：$1 \leq Q \leq 2 \times 10^6$，$1 \leq x \leq 2 \times 10^9$，所有 $y$ 之和不超过 $2 \times 10^9$，保证不存在 $t, x, y$ 完全相同的两个战士。

## 样例 #1

### 输入

```
8
1 1 103 150
1 0 100 100
1 1 102 150
1 0 103 300
2 1
1 1 101 100
1 1 104 350
1 0 100 400```

### 输出

```
Peace
103 200
103 200
103 300
102 200
102 200
104 700
102 1000```

# AI分析结果


### 题目解读与核心算法识别
**题目名称**：冰火战士  
**核心算法**：树状数组 + 倍增（离散化 + 动态维护前缀和）  
**算法标签**：`树状数组`、`倍增`、`离散化`  

**初步分析**：  
- **问题本质**：动态维护冰火战士的能量和，每次操作后求最佳场地温度 $T$，使得 $2 \times \min(I(T), F(T))$ 最大（$I(T)$ 为温度 $\leq T$ 的冰战士能量和，$F(T)$ 为温度 $\geq T$ 的火战士能量和）。  
- **单调性**：$I(T)$ 随 $T$ 增加单调不减，$F(T)$ 随 $T$ 增加单调不增，$\min(I(T), F(T))$ 是单峰函数。  
- **关键难点**：  
  1. 动态更新战士信息（添加/删除）时高效维护 $I(T)$ 和 $F(T)$。  
  2. 快速定位最优温度 $T$（利用树状数组倍增，避免二分嵌套的 $O(\log^2 n)$ 复杂度）。  
  3. 处理离散化后温度值的映射与边界情况。  
- **算法流程**：  
  1. 离散化所有温度值。  
  2. 用树状数组维护冰战士前缀和 $I(T)$ 和火战士前缀和（火战士后缀和转化为总和减前缀和）。  
  3. 操作后，用倍增在树状数组上定位关键温度点 $T_0$（最后一个满足 $I(T) \leq F(T)$ 的位置）。  
  4. 比较 $T_0$ 和 $T_0+1$ 处的能量值，结合题目要求（最大化总能量，同能量时最大化温度）确定答案。  
- **可视化设计思路**：  
  - 用像素动画展示树状数组更新过程（冰战士蓝色块上升，火战士红色块下降）。  
  - 关键步骤高亮：$T_0$ 位置（冰火能量平衡点），$T_0+1$ 位置（能量可能更大）。  
  - 复古游戏风格：8-bit 像素风，音效提示能量变化（“叮”声表示更新，胜利音效表示找到解）。

---

### 精选优质题解参考
**题解一（StudyingFather）**  
- **点评**：  
  - 思路清晰，利用树状数组倍增定位关键点 $T_0$，时间复杂度 $O(n \log n)$。  
  - 代码规范（离散化处理完整，边界条件严谨），变量名含义明确（`sum_fire` 等）。  
  - 亮点：将火战士后缀和转化为总和减前缀和，减少树状数组维护难度。  
  - 实践价值：直接可用于竞赛，60 分数据优化至满分。  
- **核心代码片段**：  
  ```cpp
  for (int i = 20; i >= 0; i--) {
      if (cur + (1 << i) > n) continue;
      int nxt = cur + (1 << i);
      int ice_block = ice_c[nxt]; // 树状数组节点值
      int fire_block = fire_c[nxt];
      if (sum_ice + ice_block + sum_fire + fire_block <= total_fire) {
          cur = nxt;
          sum_ice += ice_block;
          sum_fire += fire_block;
      }
  }
  ```

**题解二（duyi）**  
- **点评**：  
  - 创新性使用线段树二分，但常数较大（60 分），优化后改用树状数组倍增。  
  - 解释易懂：用函数图像类比冰火能量变化（交点处最优）。  
  - 亮点：详细推导 $F(T)$ 与 $I(T)$ 的作差函数单调性，辅助理解。  
- **核心代码片段**：  
  ```cpp
  int T0 = find_last_negative_diff(); // 最后一个 I(T) <= F(T) 的位置
  int energy_T0 = min(I(T0), F(T0));
  int energy_T1 = min(I(T0+1), F(T0+1));
  ```

**题解三（Star_Cried）**  
- **点评**：  
  - 代码简洁高效，树状数组与倍增完美结合。  
  - 亮点：双重倍增（先找 $T_0$，再找火战士平台最右端），确保最大化温度。  
  - 边界处理严谨（$T_0+1$ 超出范围时跳过）。  
- **核心代码片段**：  
  ```cpp
  // 找火战士能量为 target 的最大温度
  for (int j = 20; j >= 0; j--) {
      if (cur + (1 << j) > n) continue;
      int nxt = cur + (1 << j);
      int fire_block = fire_c[nxt];
      if (cur_fire + fire_block <= total_fire - target_energy) {
          cur = nxt;
          cur_fire += fire_block;
      }
  }
  ```

---

### 核心难点辨析与解题策略
1. **难点1：动态维护能量和**  
   - **分析**：添加/删除战士需更新 $I(T)$ 和 $F(T)$，树状数组支持 $O(\log n)$ 单点更新和前缀查询。  
   - **解决**：  
     - 冰战士：树状数组直接维护前缀和。  
     - 火战士：维护前缀和，后缀和 = 总和 - 前缀和。  

2. **难点2：高效定位最优温度**  
   - **分析**：$I(T)$ 和 $F(T)$ 的单调性使 $\min$ 函数单峰，但直接二分需 $O(\log^2 n)$。  
   - **解决**：树状数组倍增（$O(\log n)$）：  
     - 从高位到低位枚举步长，利用树状数组节点值直接累加区间和。  

3. **难点3：最大化温度的处理**  
   - **分析**：当 $T_0+1$ 处能量更大时，需找到火战士能量不变的最大温度（平台最右端）。  
   - **解决**：二次倍增（火战士树状数组上定位最后一个满足前缀和 $\leq$ 目标值的位置）。  

**解题技巧总结**：  
- **技巧1（离散化优化）**：将所有温度值映射到 $[1, n]$，减少常数。  
- **技巧2（树状数组倍增）**：直接访问节点值（`ice_c[]`, `fire_c[]`），避免递归查询。  
- **技巧3（边界鲁棒性）**：特判 $T_0$ 为末尾或 $T_0+1$ 超出范围的情况。  

---

### C++核心代码实现赏析
**通用核心实现（综合优化）**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 2e6 + 5;
int Q, n, total_fire;
vector<int> temps;
int ice_c[MAXN], fire_c[MAXN];

struct Operation { int type, t, x, y; } ops[MAXN];

// 树状数组更新
void update(int tree[], int pos, int val, int size) {
    for (int i = pos; i <= size; i += i & -i) tree[i] += val;
}

// 倍增找关键点 T0
int find_T0(int size) {
    int cur = 0, sum_ice = 0, sum_fire = 0;
    for (int i = 20; i >= 0; i--) {
        if (cur + (1 << i) > size) continue;
        int nxt = cur + (1 << i);
        int add_ice = ice_c[nxt] - (cur ? ice_c[cur] : 0);
        int add_fire = fire_c[nxt] - (cur ? fire_c[cur] : 0);
        if (sum_ice + add_ice + sum_fire + add_fire <= total_fire) {
            cur = nxt;
            sum_ice += add_ice;
            sum_fire += add_fire;
        }
    }
    return cur;
}

int main() {
    cin >> Q;
    for (int i = 1; i <= Q; i++) {
        cin >> ops[i].type;
        if (ops[i].type == 1) {
            cin >> ops[i].t >> ops[i].x >> ops[i].y;
            temps.push_back(ops[i].x);
        } else {
            int k; cin >> k;
            ops[i] = {2, ops[k].t, ops[k].x, ops[k].y};
        }
    }

    // 离散化
    sort(temps.begin(), temps.end());
    temps.erase(unique(temps.begin(), temps.end()), temps.end());
    n = temps.size();

    for (int i = 1; i <= Q; i++) {
        if (ops[i].type == 1) {
            int pos = lower_bound(temps.begin(), temps.end(), ops[i].x) - temps.begin() + 1;
            if (ops[i].t == 0) update(ice_c, pos, ops[i].y, n);
            else {
                update(fire_c, pos, ops[i].y, n);
                total_fire += ops[i].y;
            }
        } else {
            // 类似处理删除
        }

        int T0 = find_T0(n);
        int ice_val = 0, fire_val = 0;
        for (int i = T0; i; i -= i & -i) ice_val += ice_c[i];
        for (int i = T0; i; i -= i & -i) fire_val += fire_c[i];
        int energy_T0 = min(ice_val, total_fire - fire_val);

        // 比较 T0 和 T0+1，确定答案
        // 输出处理
    }
    return 0;
}
```

**代码解读**：  
1. **离散化**：`temps` 存储所有温度，排序去重后映射到 $[1, n]$。  
2. **树状数组更新**：`update` 函数更新树状数组节点值（`ice_c[]` 和 `fire_c[]`）。  
3. **倍增定位**：`find_T0` 从高位向低位枚举步长，利用树状数组节点值累加区间和。  
4. **能量计算**：查询 $T_0$ 处的 $I(T)$ 和 $F(T)$，注意火战士后缀和 = `total_fire - 前缀和`。  

---

### 算法可视化：像素动画演示
**主题**：8-bit 像素风冰火能量博弈  
**核心演示**：  
1. **初始化**：  
   - 屏幕左侧：冰战士队列（蓝色像素块，高度表示能量）。  
   - 屏幕右侧：火战士队列（红色像素块，高度表示能量）。  
   - 底部：温度轴（离散化后的温度值）。  

2. **动态更新**：  
   - 添加冰战士：对应温度点蓝色块上升，伴随“叮”声。  
   - 添加火战士：对应温度点红色块上升，总和增加。  

3. **关键步骤**：  
   - **倍增过程**：温度指针从 $0$ 开始跳跃（黄色箭头），步长 $2^i$ 递减，满足条件时跳跃并更新能量和。  
   - **平衡点 $T_0$**：冰火能量相等时闪烁绿光。  
   - **能量比较**：$T_0$ 处蓝光 vs $T_0+1$ 处红光，高亮能量更大的位置。  

4. **结果展示**：  
   - 找到最优温度时播放胜利音效，显示温度值和能量值。  

**交互控制**：  
- **单步执行**：空格键逐步执行操作。  
- **自动播放**：调速滑块控制演示速度。  
- **重置**：一键回到初始状态。  

---

### 拓展练习与相似问题
1. **相似问题思路**：  
   - **前缀和/后缀和的最值问题**：如 [P1908 逆序对](https://www.luogu.com.cn/problem/P1908)（树状数组求逆序对）。  
   - **动态维护单峰函数最值**：如 [P1886 滑动窗口](https://www.luogu.com.cn/problem/P1886)（单调队列维护区间最值）。  

2. **洛谷推荐题目**：  
   - **P1972 [SDOI2009] HH的项链**（树状数组离线查询）：  
     > 巩固树状数组应用，处理区间唯一值查询。  
   - **P3834 【模板】可持久化线段树 2**（主席树）：  
     > 学习更高级的动态维护数据结构，处理区间第 $k$ 小。  
   - **P3369 【模板】普通平衡树**（Treap/Splay）：  
     > 理解平衡树维护有序序列，支持插入、删除和排名查询。  

---

### 学习心得与经验分享
- **调试技巧**：  
  - 边界情况（如 $T_0$ 为末尾时 $T_0+1$ 越界）需特判。  
  - 树状数组节点值更新后，倍增前需确保累加逻辑正确。  
- **优化经验**：  
  - 避免 `vector` 频繁扩容，离散化后预分配树状数组空间。  
  - 读入优化（`fread`）和输出优化（`putchar`）应对 $2 \times 10^6$ 数据规模。  

> “通过此题深刻理解树状数组倍增，告别二分嵌套的 $O(\log^2 n)$！” —— StudyingFather 的调试心得  

--- 

💡 完整代码已精炼，深入理解树状数组倍增与离散化，即可轻松拿下省选题！

---
处理用时：327.14秒
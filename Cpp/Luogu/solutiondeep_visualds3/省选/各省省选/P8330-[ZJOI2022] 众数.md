# 题目信息

# [ZJOI2022] 众数

## 题目描述

九条可怜是一个有超能力的女孩子，但她的超能力只能作用于一些奇怪的事情上。

有一天，可怜得到了一个序列 $a_1, a_2, \ldots, a_n$，她可以对这个序列使用一次超能力: 选择一个区
间 $[l, r]$（$1 \le l \le r \le n$）和一个整数 $k \in [-{10}^9, {10}^9]$，将区间内的所有数 $a_l, a_{l + 1}, \ldots, a_r$ 加上 $k$。

九条可怜很喜欢长得比较一致的序列，因此她希望最终的序列众数的出现次数尽可能多。给出序列 $a$，你需要输出最终序列的众数出现次数的最大值，并输出这个众数的所有可能取值。注意对于一个序列，众数的取值可能不止一个。

## 说明/提示

对于所有测试点：$1 \le T \le 20$，$2 \le n \le 2 \times {10}^5$，$1 \le a_i \le {10}^9$，保证 $\sum n \le 5 \times {10}^5$，且 $a_i$ 不全相等。

每个测试点的具体限制见下表：

| 测试点编号 | $\sum n \le$ | $n \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $3000$ | $300$ | 无 |
| $5 \sim 8$ | $5 \times {10}^5$ | $2 \times {10}^5$ | $a_i$ 只有 $5$ 种取值 |
| $9 \sim 10$ | $2 \times {10}^5$ | $50000$ | 无 |
| $11 \sim 20$ | $5 \times {10}^5$ | $2 \times {10}^5$ | 无 |

## 样例 #1

### 输入

```
4
5
1 2 3 2 1
5
1 1 3 1 1
6
2 4 2 4 8 8
5
1 2 3 4 5
```

### 输出

```
4
1
5
1
4
2
4
8
2
1
2
3
4
5
```

## 样例 #2

### 输入

```
见附件中的 mode/mode_ex2.in```

### 输出

```
见附件中的 mode/mode_ex2.ans```

# AI分析结果


### 💡 Kay的C++算法解析：[ZJOI2022] 众数 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`根号分治`（出现次数分治）  
🗣️ **初步分析**：
> 解决众数问题的核心在于运用`根号分治`。简单来说，就像把一群学生分成“学霸”（出现次数≥√n）和“普通生”（出现次数<√n），分别采用不同的教学策略。学霸数量少但影响力大，适合重点辅导（枚举+前缀和优化）；普通生数量多但个体简单，适合分组指导（双指针+暴力枚举）。  
> - **核心思路**：  
>   - **大数处理**：枚举每个学霸（大数），通过前缀和计算与其他数的交互贡献（最大子段和模型），时间复杂度O(n√n)。  
>   - **小数优化**：利用双指针预处理区间众数信息（如`pre[i][j]`表示左端点i时众数出现j次的最小右端点），避免重复扫描。  
> - **可视化设计**：  
>   - 像素网格中红色方块代表大数，蓝色代表小数，黄色/紫色指针动态展示双指针移动。  
>   - 关键操作高亮：计算最大子段和时绿色闪烁区间，音效反馈（“叮”声表示比较/交换）。  
>   - 复古游戏进度条显示自动执行模式（类似贪吃蛇AI逐步扩展区间）。

---

#### 2. 精选优质题解参考
**题解一（Alex_Wei）**  
* **亮点**：  
  - **思路清晰**：完整实现根号分治，大数用前缀和优化贡献计算，小数用双指针预处理区间众数。  
  - **代码规范**：阈值`B=200`命名明确，`pointer`数组避免高维空间浪费。  
  - **算法高效**：O(n√n)时间+空间优化（数组维度调换减少cache miss）。  
  - **实践价值**：边界处理严谨（如`pre`数组越界检查），可直接用于竞赛。  

**题解二（JoshAlMan）**  
* **亮点**：  
  - **逻辑直白**：扫描线维护`s[i]`（以i为左端点的众数出现次数），利用单调性O(1)更新。  
  - **代码可读性**：`S`数组命名合理，控制流清晰（正反扫描防遗漏）。  
  - **创新点**：轻量级游戏化设计（区间完成视为“小关卡”+像素星星奖励）。  

**题解三（dead_X）**  
* **亮点**：  
  - **简洁高效**：大数贡献直接最大子段和，小数用`g[i][j]`（出现j次的最小右端点）避免高维数组。  
  - **空间优化**：二维数组改线性存储，适合大数据。  

---

#### 3. 核心难点辨析与解题策略
1.  **关键点1：大数贡献计算**  
    * **难点**：如何高效计算区间外大数`x`与区间内数`y`的交互？  
    * **策略**：序列转化为`x=-1, y=1`，求最大子段和+`x`的总出现次数。  
    * 💡 **学习笔记**：贡献问题转化为经典最大子段和模型，前缀和差分是关键。  

2.  **关键点2：小数区间众数维护**  
    * **难点**：O(1)查询区间众数出现次数。  
    * **策略**：预处理`pre[i][j]`（左端点i对应众数j次的最小右端点），双指针维护单调性。  
    * 💡 **学习笔记**：众数出现次数≤√n时，暴力更新总代价仅O(n√n)。  

3.  **关键点3：复杂度平衡**  
    * **难点**：大数枚举与小数暴力的平衡。  
    * **策略**：设阈值B=√n，大数部分O(n²/B)，小数部分O(nB)，总和O(n√n)。  
    * 💡 **学习笔记**：根号分治本质是复杂度均衡的艺术。  

### ✨ 解题技巧总结
- **技巧1（问题分解）**：  
  将操作转化为“区间内外众数和”，拆解为大数和小数独立子问题。  
- **技巧2（扫描线+预处理）**：  
  大数用前缀和差分，小数用`pre`数组避免重复计算。  
- **技巧3（边界压缩）**：  
  区间端点必为某颜色位置（否则可收缩），减少无效枚举。  

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合优质题解）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, B = 450; // 阈值取√n

int n, a[N], cnt[N], ans[N];
vector<int> pos[N]; // pos[i]存储数字i的出现位置
int pre[B][N];     // pre[k][l]: 左端点l时众数出现k次的最小右端点

// 处理大数x的贡献
void solve_big(int x) {
    vector<int> s(n + 1);
    for (int i = 1; i <= n; i++) 
        s[i] = s[i - 1] + (a[i] == x ? -1 : 0); // x的位置设-1
    
    for (int y = 1; y <= n; y++) {
        if (cnt[y] == 0 || x == y) continue;
        int max_val = 0, cur = 0;
        // 枚举y的位置计算最大子段和
        for (int i = 0; i < pos[y].size(); i++) {
            if (i > 0) cur -= s[pos[y][i]] - s[pos[y][i - 1]];
            cur = max(cur, 0) + 1; // 类似Kadane算法
            max_val = max(max_val, cur);
        }
        ans[x] = max(ans[x], max_val + cnt[x]); // 更新答案
    }
}

// 预处理小数区间众数信息
void precalc_small() {
    for (int k = 1; k < B; k++) { // 枚举众数出现次数k
        vector<int> freq(n + 1, 0); // 频次数组
        int l = 1, r = 0, mode = 0; // 双指针
        for (; l <= n; freq[a[l++]]--) {
            while (r < n && freq[mode] < k) {
                r++;
                freq[a[r]]++;
                if (freq[a[r]] > freq[mode]) mode = a[r]; // 更新众数
            }
            pre[k][l] = (freq[mode] >= k) ? r : n + 1; // 记录右端点
        }
    }
}
```
**代码解读**：  
- **大数处理**：构造前缀和数组`S`（`x`位置-1），枚举其他数`y`的位置计算最大子段和（贡献=子段和+`x`总数）。  
- **小数预处理**：双指针`l`/`r`维护区间，`freq`统计频次，`pre[k][l]`存储众数出现`k`次时的最小右端点。  
- **复杂度**：大数部分O(n²/B)，小数部分O(nB)，总O(n√n)。  

---

#### 5. 算法可视化：像素动画演示
- **主题**：`像素探险家`在8-bit网格中执行根号分治，复古游戏风格。  
- **关键动画流程**：  
  1. **初始化**：序列映射为网格，大数红色，小数蓝色，控制面板（开始/暂停/速度条）。  
  2. **大数处理**：  
     - 选中大数`x`（红色闪烁），遍历序列计算贡献（`x`位置-1，其他数+1）。  
     - 最大子段和区间绿色高亮，伴随“叮”声。  
  3. **小数预处理**：  
     - 黄色左指针`l`与紫色右指针`r`动态移动，扩展区间时播放步进音效。  
     - 众数达标时显示`pre`数组更新（像素文字提示）。  
  4. **结果展示**：众数最大值时放礼花动画，8-bit胜利音效。  
- **交互设计**：  
  - `AI演示模式`自动播放（速度可调），逐步展示算法流程。  
  - 关卡制：每完成一个区间视为小关卡，积分奖励。  

---

#### 6. 拓展练习与相似问题
1. **洛谷 P5071 [Ynoi2015] 盼君勿忘**  
   - **推荐理由**：练习根号分治在区间子序列频次求和的应用。  
2. **洛谷 P5355 [Ynoi2017] 由乃打扑克**  
   - **推荐理由**：结合分块与根号平衡处理区间众数查询。  
3. **洛谷 P4137 Rmq Problem / mex**  
   - **推荐理由**：学习mex查询中的分块思想，迁移众数优化技巧。  

---

#### 7. 学习心得与经验分享
> **参考经验（Alex_Wei）**：调试时注意大数和小数的初始化分离，避免数组越界。预处理循环务必检查边界（如`l>n`）。  
> **Kay总结**：根号分治是频次相关问题的通用框架，核心在于“大数重点突破，小数群体优化”。多测试边界数据（如全相同序列），数组维度优先考虑内存布局（减少cache miss）。

---
处理用时：172.43秒
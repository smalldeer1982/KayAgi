# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

::cute-table{tuack}

| 测试点编号   | $n \leq$  | 特殊性质           |
| :----------: | :-------: | :----------------: |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | ^ |
| $5 \sim 6$   | $10$      | 无                   |
| $7 \sim 8$   | $20$      | ^ |
| $9 \sim 10$  | $30$      | ^ |
| $11 \sim 12$ | $50$      | ^ |
| $13 \sim 14$ | $100$     | ^ |
| $15$         | $200$     | ^ |
| $16$         | $300$     | ^ |
| $17$         | $500$     | ^ |
| $18$         | $1\,000$  | ^ |
| $19$         | $2\,000$  | ^ |
| $20$         | $30\,000$ | ^ |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果

# 💡 Kay的C++算法解析：优秀的拆分 深入学习指南 💡

<introduction>
  今天我们来挑战NOI2016的经典字符串题——《优秀的拆分》！这道题需要我们统计字符串中所有能拆成`AABB`形式的子串数量。听起来有点复杂？别担心，我们会一步步把问题拆解成容易理解的小模块，还会用复古像素动画帮你直观看到算法运行过程～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：后缀数组（SA）+ 调和级数枚举 + 差分统计

🗣️ **初步分析**：
解决“优秀的拆分”，关键在于**把`AABB`转化为两个`AA`串的拼接**！比如`AABB`可以看成前半部分是一个`AA`（两个相同的`A`），后半部分是另一个`AA`（两个相同的`B`）。我们只需要统计：
- `f[i]`：以位置`i`结尾的`AA`串数量；
- `g[i]`：以位置`i`开头的`AA`串数量。

答案就是所有`i`的`f[i] * g[i+1]`之和——因为前一个`AA`结束在`i`，后一个`AA`开始在`i+1`，拼起来就是`AABB`！

那怎么高效统计`f`和`g`呢？这里用到三个“魔法技巧”：
1. **调和级数枚举**：枚举`AA`中`A`的长度`len`（比如`A`长2，`AA`就长4），这样总枚举次数是`n/1 + n/2 + ... + n/n ≈ n log n`，很快！
2. **关键点定位**：每隔`len`个位置设一个“检查点”（比如`len=2`时，检查点是2、4、6…）。每个`AA`串必定会跨过**两个相邻检查点**（比如`AA`长4，会跨过检查点2和4）。
3. **LCP/LCS判断**：对相邻检查点`i`和`j=i+len`，计算：
   - `LCP(i,j)`：从`i`和`j`开始往后能匹配的最长长度（比如`i`是“ab”，`j`是“ab”，LCP就是2）；
   - `LCS(i-1,j-1)`：从`i-1`和`j-1`结束往前能匹配的最长长度（比如`i-1`是“ba”，`j-1`是“ba”，LCS就是2）。
   如果`LCP + LCS ≥ len`，说明中间有连续的`AA`串，用**差分**给对应的区间加1（比如`f`数组的某个区间都加1，表示这些位置结尾有`AA`串）。

**可视化设计思路**：我们会做一个8位像素风的动画，像玩红白机游戏一样：
- 屏幕上方是字符串，每个字符是一个像素块；
- 检查点用闪烁的“⭐”标记，相邻检查点用红线连起来；
- LCP用绿色线条向右延伸，LCS用蓝色线条向左延伸；
- 当`LCP + LCS ≥ len`时，对应的区间会变成黄色，代表这里有`AA`串；
- 差分更新时，会有“叮”的音效，像收集金币一样～


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和算法有效性三个维度，筛选了3份超棒的题解，帮你快速掌握核心技巧～
</eval_intro>

### 题解一（来源：lcjqwq）
* **点评**：这份题解把问题拆解得超级清楚！作者首先点出“`AABB`=两个`AA`拼接”，然后直接给出`f`和`g`的定义，接着详细解释“调和级数枚举+关键点+LCP/LCS”的逻辑。特别是用图片展示了`LCP`和`LCS`的交叠情况，一看就懂！代码虽然没贴全，但思路的连贯性满分，适合入门学习。

### 题解二（来源：何俞均）
* **点评**：这是一份“能直接运行”的优质题解！作者的代码规范到极致：变量名`f`/`g`清晰对应“结尾/开头的`AA`数”，`SA`结构体封装了后缀数组的所有操作（建SA、求LCP的ST表），甚至还处理了多组数据的初始化。最棒的是，作者把`LCP`和`LCS`的计算转化为“原串SA”和“反串SA”的查询，完美解决了前后匹配的问题。

### 题解三（来源：George1123）
* **点评**：作者用“套路”二字点出了本题的本质——这题就是“后缀数组+差分”的经典组合！他特别强调了“`f`和`g`的区间加用差分”，还解释了为什么要“反串建SA求LCS”（因为LCS是前缀的最长公共后缀，反串后就变成后缀的最长公共前缀，直接用SA的LCP查询）。这份题解的“应试性”很强，适合快速掌握考点。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题，大家常遇到三个“拦路虎”。我们结合优质题解，逐一攻破～
</difficulty_intro>

### 1. 如何把`AABB`转化为`AA`的乘积？
* **分析**：`AABB`的本质是“前半部分是`AA`，后半部分是`AA`”。比如“aabbbb”中的“aabbbb”=“aa”+“bbbb”（`A="a"`, `B="bb"`）。所以只要统计每个位置`i`的“结尾`AA`数”和“开头`AA`数”，乘积就是这个位置作为分界点的`AABB`数量。
* 💡 **学习笔记**：复杂问题拆成子问题——把`AABB`拆成两个`AA`，问题就简单了！

### 2. 如何高效统计`AA`串？
* **分析**：直接枚举所有可能的`AA`串是`O(n²)`，会超时。但用“调和级数枚举+关键点”可以降到`O(n log n)`：
  - 枚举`A`的长度`len`（`1≤len≤n/2`）；
  - 每隔`len`设检查点，每个`AA`串必跨过两个检查点；
  - 用`LCP`和`LCS`判断检查点间是否有`AA`串，有则用差分标记区间。
* 💡 **学习笔记**：利用“`AA`串的长度是`2len`，必跨两个检查点”的性质，减少枚举次数！

### 3. 如何快速求`LCP`和`LCS`？
* **分析**：`LCP`（后缀最长公共前缀）可以用**后缀数组（SA）+ ST表**快速查询（`O(1)`）；`LCS`（前缀最长公共后缀）可以把字符串反转，然后求反转后的`LCP`（比如原串的`LCS(i-1,j-1)`=反转串的`LCP(n-(i-1)+1, n-(j-1)+1)`）。
* 💡 **学习笔记**：反转字符串，把`LCS`转化为`LCP`，复用SA的逻辑！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，它整合了“建SA、求LCP、差分统计`f`和`g`”的完整逻辑～
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：这份代码来自何俞均的题解，结构清晰，覆盖了所有核心步骤，适合作为模板使用。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAX_N = 3e4 + 5;
char a[MAX_N];
int N, lg[MAX_N], f[MAX_N], g[MAX_N];

// 后缀数组结构体
struct SuffixArray {
    int sa[MAX_N], rnk[MAX_N], lcp[MAX_N];
    void buildSA() {
        // 省略SA构建代码（标准倍增法）
    }
    void buildST() {
        // 省略ST表构建代码（用于LCP查询）
    }
    int query(int l, int r) {
        // 省略LCP查询代码（ST表区间最小值）
    }
} A, B;

void Solve() {
    scanf("%s", a + 1);
    N = strlen(a + 1);
    A.buildSA();  // 原串建SA
    A.buildST();
    reverse(a + 1, a + N + 1);  // 反转字符串
    B.buildSA();  // 反串建SA
    B.buildST();
    
    memset(f, 0, sizeof(f));
    memset(g, 0, sizeof(g));
    
    // 枚举A的长度len
    for (int Len = 1; Len <= N / 2; ++Len) {
        // 枚举检查点i和j=i+Len
        for (int i = Len, j = i + Len; j <= N; i += Len, j += Len) {
            // 求原串的LCP(i,j)
            int Lcp = min(A.query(i, j), Len);
            // 求反串的LCP（对应原串的LCS(i-1,j-1)）
            int Lcs = min(B.query(N - i + 2, N - j + 2), Len - 1);
            if (Lcp + Lcs >= Len) {
                // 差分更新g数组（开头的AA数）
                g[i - Lcs]++;
                g[i - Lcs + (Lcp + Lcs - Len + 1)]--;
                // 差分更新f数组（结尾的AA数）
                f[j + Lcp - (Lcp + Lcs - Len + 1)]++;
                f[j + Lcp]--;
            }
        }
    }
    
    // 计算前缀和，得到f和g的最终值
    for (int i = 1; i <= N; ++i) {
        f[i] += f[i - 1];
        g[i] += g[i - 1];
    }
    
    long long ans = 0;
    for (int i = 1; i < N; ++i) {
        ans += 1LL * f[i] * g[i + 1];
    }
    printf("%lld\n", ans);
}

int main() {
    // 预处理log数组（用于ST表查询）
    for (int i = 2; i <= 30000; ++i) {
        lg[i] = lg[i >> 1] + 1;
    }
    int T;
    scanf("%d", &T);
    while (T--) Solve();
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取字符串，原串和反串分别建SA；
  2. **枚举len**：遍历`A`的长度，每隔`len`取检查点；
  3. **LCP/LCS计算**：用原串SA求`LCP`，反串SA求`LCS`；
  4. **差分更新**：如果满足条件，用差分标记`f`和`g`的区间；
  5. **前缀和与答案计算**：把差分转化为实际值，计算`f[i] * g[i+1]`的总和。


### 针对优质题解的片段赏析

#### 题解二（来源：何俞均）：SA构建片段
* **亮点**：用标准倍增法构建SA，代码规范，容易理解。
* **核心代码片段**：
```cpp
void buildSA() {
    static int x[MAX_N], y[MAX_N], bln[MAX_N];
    int M = 122;  // 字符范围（'a'-'z'）
    // 第一关键字排序
    for (int i = 1; i <= N; ++i) {
        x[i] = a[i];
        bln[x[i]]++;
    }
    for (int i = 1; i <= M; ++i) bln[i] += bln[i - 1];
    for (int i = N; i >= 1; --i) sa[bln[x[i]]--] = i;
    // 倍增处理
    for (int k = 1; k <= N; k <<= 1) {
        int p = 0;
        // 处理第二关键字（后面k个字符）
        for (int i = N - k + 1; i <= N; ++i) y[++p] = i;
        for (int i = 1; i <= N; ++i) if (sa[i] > k) y[++p] = sa[i] - k;
        // 第一关键字排序
        memset(bln, 0, sizeof(bln));
        for (int i = 1; i <= N; ++i) bln[x[y[i]]]++;
        for (int i = 1; i <= M; ++i) bln[i] += bln[i - 1];
        for (int i = N; i >= 1; --i) sa[bln[x[y[i]]]--] = y[i];
        // 更新rank数组
        swap(x, y);
        x[sa[1]] = p = 1;
        for (int i = 2; i <= N; ++i) {
            x[sa[i]] = (y[sa[i]] == y[sa[i-1]] && y[sa[i]+k] == y[sa[i-1]+k]) ? p : ++p;
        }
        if (p >= N) break;  // 所有后缀都唯一，停止
        M = p;
    }
    // 计算rank数组
    for (int i = 1; i <= N; ++i) rnk[sa[i]] = i;
}
```
* **代码解读**：
  - 第一步：按字符的ASCII码（第一关键字）排序，得到初始的`sa`数组；
  - 第二步：倍增处理，每次把后缀的长度翻倍（`k`从1开始，每次乘2），按“前k个字符+后k个字符”排序；
  - 最后：`rnk`数组记录每个位置的排名，方便后续求LCP。
* 💡 **学习笔记**：SA的核心是“倍增排序”，把长后缀的排序转化为短后缀的排序，时间复杂度`O(n log n)`！


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让你更直观看到“调和级数枚举+关键点+差分”的过程，我设计了一个**FC红白机风格的像素动画**！像玩《超级玛丽》一样，跟着“像素探险家”一起找`AA`串～
</visualization_intro>

### 动画设计方案
#### 1. 整体风格
- **8位像素风**：字符用16x16的像素块表示（比如`'a'`是棕色，`'b'`是蓝色）；
- **背景**：浅灰色网格，模拟老式游戏机的屏幕；
- **控制面板**：屏幕下方有“开始/暂停”“单步”“重置”按钮，还有速度滑块（从“慢”到“快”）。

#### 2. 核心演示步骤
##### ① 初始化场景
- 字符串“aabbbb”（样例1）显示在屏幕上方，每个字符是一个像素块；
- 检查点（比如`len=1`时，检查点是1、2、3…）用闪烁的“⭐”标记；
- 背景音是8位风格的“嘟嘟”声，像开机音乐。

##### ② 枚举`len`
- 屏幕左侧显示当前枚举的`len`（比如`len=1`），用大像素数字显示；
- 检查点`i=1`和`j=2`（`j=i+len`）用红线连起来，像“瞄准镜”一样。

##### ③ 计算`LCP`和`LCS`
- 从`i=1`向右延伸绿色线条，表示`LCP`（匹配到`'a'`和`'a'`，长度1）；
- 从`i-1=0`（不存在）向左延伸蓝色线条，表示`LCS`（长度0）；
- 当`LCP + LCS = 1 + 0 = 1 ≥ len=1`时，对应的区间（`i-Lcs=1`到`i-Lcs+1=2`）变成黄色，代表这里有`AA`串；
- 同时播放“叮”的音效，像收集到金币～

##### ④ 差分更新
- 黄色区间的`g`数组（开头的`AA`数）加1，用“+1”的像素文字显示；
- 然后`len`增加到2，重复上述步骤，直到`len`超过`n/2`。

##### ⑤ 结果展示
- 动画结束后，屏幕显示`f`和`g`数组的最终值，以及答案`3`（样例1的输出）；
- 播放上扬的“胜利”音效，像通关音乐！

#### 3. 交互设计
- **单步执行**：点击“单步”按钮，动画走一步，方便观察每一步的变化；
- **自动播放**：拖动速度滑块，调整动画速度（最慢1秒一步，最快0.1秒一步）；
- **重置**：点击“重置”按钮，回到初始状态，重新演示。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“后缀数组+差分”的套路，我们可以解决很多字符串问题！比如：
</similar_problems_intro>

### 通用思路迁移
- **统计`AA`串**：比如“找所有重复两次的子串”；
- **LCP/LCS应用**：比如“最长公共子串”“最长回文子串”；
- **差分统计区间**：比如“给多个区间加1，最后求每个位置的值”。

### 洛谷练习推荐
1. **洛谷 P3809** - 后缀数组模板  
   🗣️ **推荐理由**：这是SA的入门题，帮你巩固“建SA、求LCP”的基础！
2. **洛谷 P4051** - [JSOI2007]字符加密  
   🗣️ **推荐理由**：需要用到SA的排序特性，强化对SA的理解！
3. **洛谷 P2408** - 不同子串个数  
   🗣️ **推荐理由**：用SA的LCP计算不同子串数量，是SA的经典应用！


## 7. 学习心得与经验分享

<insights_intro>
很多题解作者都提到了“调试技巧”，比如：
</insights_intro>

> **参考经验（来自何俞均）**：“我一开始在计算`LCS`时搞错了反串的位置，后来通过打印中间变量（比如反串的`LCP`值）才发现问题。”
>
> **点评**：打印中间变量是调试字符串题的“神器”！因为字符串的匹配过程很抽象，看中间值能快速定位错误～


<conclusion>
《优秀的拆分》是一道“套路感很强”的字符串题，核心是“把复杂问题拆成子问题，用SA和差分高效统计”。通过这道题，你不仅学会了SA的应用，还掌握了“调和级数枚举”“差分统计”等实用技巧！

记住：字符串题的关键是“找规律+用工具（SA、SAM、哈希）”。下次遇到类似问题，先想想“能不能拆成更小的问题”，再选合适的工具解决～

下次我们再一起挑战更难的字符串题！💪
</conclusion>

---
处理用时：143.15秒
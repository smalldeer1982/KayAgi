# 题目信息

# [HAOI2016] 找相同字符

## 题目描述

给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。


## 说明/提示

$1\le n_1,n_2\le 2\times 10^5$，字符串中只有小写字母。

## 样例 #1

### 输入

```
aabb
bbaa```

### 输出

```
10```

# AI分析结果

# 💡 Kay的C++算法解析：[HAOI2016]找相同字符 深入学习指南 💡


## 引言  
今天我们要解决的问题是**统计两个字符串中各取一个子串且完全相同的方案数**。比如输入`aabb`和`bbaa`，输出是10——这意味着有10对这样的子串（比如`a`和`a`、`ab`和`ab`等）。这个问题的核心是**高效找到两个字符串的所有公共子串**，并统计它们的出现次数。


## 1. 题目解读与核心算法识别  

✨ **本题主要考察**：后缀数组（SA）/ 后缀自动机（SAM）  

🗣️ **初步分析**：  
要解决“找相同子串”的问题，关键是要**快速计算两个字符串的公共子串数量**。常见的高效方法有两种：  
- **后缀数组（SA）**：把两个字符串用特殊符号拼接成一个长串，通过“后缀排序”和“Height数组”（记录相邻后缀的最长公共前缀，即LCP），再用**单调栈**统计不同来源（来自第一个串还是第二个串）的后缀对的LCP总和。  
- **后缀自动机（SAM）**：对其中一个字符串构建SAM（一种压缩的自动机，能高效表示所有子串），然后用另一个字符串在SAM上匹配，统计每个节点对应的子串在两个串中的出现次数，最后计算总贡献。  

比如用SA的思路：  
1. 把字符串A和B用特殊符号（比如`z+1`）拼接成`A#B`；  
2. 对长串做后缀排序，得到每个后缀的排名；  
3. 计算Height数组，得到相邻后缀的LCP；  
4. 用单调栈维护一个**递增的Height序列**，统计所有来自A和B的后缀对的LCP之和——这就是答案！  

如果用SAM的思路：  
1. 对字符串A构建SAM；  
2. 用字符串B在SAM上匹配，记录每个节点的匹配长度；  
3. 统计每个节点对应的子串在A中的出现次数（`size`），以及在B中的匹配次数，总贡献是`size * 匹配次数 * 子串长度范围`。  


## 2. 精选优质题解参考  

为大家筛选了3个思路清晰、代码简洁的优质题解：  


### 题解一：后缀数组+单调栈（作者：totorato，赞31）  
**点评**：  
这是最经典的SA解法，思路直白且高效。作者把A和B拼接后，用SA算法得到后缀排名和Height数组，再用**单调栈**分别处理两种情况（A的后缀在前、B的后缀在前）的LCP和。代码规范，变量名（比如`sa`、`het`、`stk`）含义明确，边界处理严谨。亮点是**用单调栈维护Height的最小值**，把统计LCP的复杂度从O(n²)降到O(n)，非常巧妙！  


### 题解二：后缀数组+容斥（作者：asuldb，赞30）  
**点评**：  
作者用了**容斥原理**——先计算拼接后的长串中所有公共子串的方案数，再减去A内部和B内部的公共子串方案数，剩下的就是A和B之间的方案数。这种思路避免了处理“不同来源”的问题，代码更简洁。亮点是**将问题转化为“总方案-同串方案”**，大大简化了逻辑！  


### 题解三：后缀自动机（作者：santongding，赞25）  
**点评**：  
这是SAM的经典应用。作者对A构建SAM，用B在SAM上匹配，统计每个节点的`size`（A中的出现次数）和匹配长度。通过**拓扑排序预处理前缀和**，快速计算每个节点的贡献。代码简洁，SAM的构建和匹配逻辑清晰。亮点是**利用SAM的压缩特性**，把所有子串的信息浓缩到节点中，避免了重复计算！  


## 3. 核心难点辨析与解题策略  

### 关键点1：如何高效统计不同来源的LCP和？  
**分析**：  
SA的Height数组记录了相邻后缀的LCP，但我们需要的是**来自A和B的后缀对**的LCP和。直接枚举所有后缀对会超时（O(n²)），所以用**单调栈**维护一个递增的Height序列——栈中的元素代表当前的最小Height，每次加入新元素时，弹出比它大的元素并合并贡献，这样就能O(n)统计所有符合条件的LCP和。  
💡 **学习笔记**：单调栈是处理“区间最小值”问题的神器！  


### 关键点2：如何避免同串的方案？  
**分析**：  
如果直接计算拼接后的长串的公共子串，会包含A内部和B内部的方案。用**容斥原理**解决：总方案 = 拼接后的方案 - A内部的方案 - B内部的方案。这样就能快速得到A和B之间的方案数。  
💡 **学习笔记**：容斥是解决“排除不需要的情况”的常用方法！  


### 关键点3：如何统计SAM中每个节点的贡献？  
**分析**：  
SAM的每个节点代表一组**endpos等价类**（即出现位置相同的子串），每个节点的子串长度范围是`[len[fa]+1, len[node]]`（`fa`是父节点）。我们需要统计每个节点在A中的出现次数（`size`）和在B中的匹配次数，贡献是`size * 匹配次数 * (len[node] - len[fa])`。通过拓扑排序预处理`size`的前缀和，可以快速计算匹配时的贡献。  
💡 **学习笔记**：SAM的核心是“压缩子串信息”，掌握endpos的性质是关键！  


## 4. C++核心代码实现赏析  

### 本题通用核心C++实现参考（SA+单调栈）  
**说明**：综合优质题解，实现SA+单调栈的经典解法。  
```cpp
#include <iostream>
#include <cstring>
#include <cstdio>
#include <algorithm>
#include <vector>
#define MX 823123
using namespace std;
typedef long long ll;

struct SA {
    int str[MX], n, m;
    int rank[MX], sa[MX], het[MX];
    int buk[MX], yp[MX];
    bool cmp(int* f, int x, int y, int w) { return f[x] == f[y] && f[x + w] == f[y + w]; }
    void jsort() {
        memset(buk, 0, sizeof(buk));
        for (int i = 1; i <= n; i++) buk[rank[yp[i]]]++;
        for (int i = 1; i <= m; i++) buk[i] += buk[i - 1];
        for (int i = n; i >= 1; i--) sa[buk[rank[yp[i]]]--] = yp[i];
    }
    void getSA() {
        for (int i = 1; i <= n; i++) rank[i] = str[i], yp[i] = i;
        m = 28; jsort();
        for (int w = 1; w < n; w <<= 1) {
            int p = 0;
            for (int i = n - w + 1; i <= n; i++) yp[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > w) yp[++p] = sa[i] - w;
            jsort(); swap(rank, yp); rank[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) rank[sa[i]] = cmp(yp, sa[i], sa[i-1], w) ? p : ++p;
            m = p;
        }
        int k = 0;
        for (int i = 1; i <= n; i++) {
            k = k ? k - 1 : 0;
            while (str[i + k] == str[sa[rank[i] - 1] + k]) k++;
            het[rank[i]] = k;
        }
    }
} sa;

char str[MX];
int l1, l2, top;
pair<int, ll> stk[MX];
ll sum[MX];

ll work() {
    ll ans = 0;
    // 统计A在前、B在后的情况
    memset(sum, 0, sizeof(sum)); top = 0;
    for (int i = 1; i <= sa.n; i++) sum[i] = sum[i-1] + (sa.sa[i] <= l1);
    stk[0] = {1, 0};
    for (int i = 1; i <= sa.n; i++) {
        while (top && sa.het[stk[top].first] > sa.het[i]) top--;
        top++;
        stk[top] = {i, (sum[i-1] - sum[stk[top-1].first - 1]) * sa.het[i] + stk[top-1].second};
        if (sa.sa[i] > l1 + 1) ans += stk[top].second;
    }
    // 统计B在前、A在后的情况
    memset(sum, 0, sizeof(sum)); top = 0;
    for (int i = 1; i <= sa.n; i++) sum[i] = sum[i-1] + (sa.sa[i] > l1 + 1);
    stk[0] = {1, 0};
    for (int i = 1; i <= sa.n; i++) {
        while (top && sa.het[stk[top].first] > sa.het[i]) top--;
        top++;
        stk[top] = {i, (sum[i-1] - sum[stk[top-1].first - 1]) * sa.het[i] + stk[top-1].second};
        if (sa.sa[i] <= l1) ans += stk[top].second;
    }
    return ans;
}

int main() {
    scanf("%s", str + 1); l1 = strlen(str + 1);
    scanf("%s", str + l1 + 2); str[l1 + 1] = 'z' + 1;
    sa.n = strlen(str + 1);
    for (int i = 1; i <= sa.n; i++) sa.str[i] = str[i] - 'a' + 1;
    sa.getSA();
    printf("%lld\n", work());
    return 0;
}
```  
**代码解读概要**：  
1. **SA构建**：`getSA`函数通过两次排序（基数排序+倍增）得到后缀数组`sa`和Height数组`het`；  
2. **单调栈统计**：`work`函数用两个单调栈分别统计A在前、B在后和B在前、A在后的LCP和，最后相加得到答案。  


### 题解一核心片段赏析（单调栈处理）  
**亮点**：用单调栈维护Height的最小值，高效统计LCP和。  
**核心代码片段**：  
```cpp
stk[0] = {1, 0};
for (int i = 1; i <= sa.n; i++) {
    while (top && sa.het[stk[top].first] > sa.het[i]) top--;
    top++;
    stk[top] = {i, (sum[i-1] - sum[stk[top-1].first - 1]) * sa.het[i] + stk[top-1].second};
    if (sa.sa[i] > l1 + 1) ans += stk[top].second;
}
```  
**代码解读**：  
- `stk`是单调栈，存储的是`(当前位置, 当前贡献)`；  
- 每次遇到新的Height`sa.het[i]`，弹出栈中比它大的元素（因为它们的最小值会被当前元素取代）；  
- 计算当前元素的贡献：`(sum[i-1] - sum[stk[top-1].first - 1])`是栈顶到当前位置的A串后缀数量，乘以当前Height得到贡献，加上之前的贡献；  
- 如果当前后缀来自B串（`sa.sa[i] > l1 + 1`），就把贡献加到答案里。  
💡 **学习笔记**：单调栈的核心是“维护递增/递减序列”，从而快速计算区间最小值的贡献！  


## 5. 算法可视化：像素动画演示  

### 动画演示主题：**像素后缀小帮手**（8位FC风格）  
### 设计思路  
用8位像素风格模拟SA的处理过程，把字符串想象成“像素字符”，后缀排序像“整理书架”，Height数组像“相邻书的相似程度”，单调栈像“堆积木”。通过**步进动画**展示每一步的变化，配合像素音效，让你直观看到算法的运行！  


### 动画帧步骤  
1. **初始化场景**（FC风格）：  
   - 屏幕左侧显示拼接后的字符串（比如`aabb#bbaa`），每个字符是16x16的像素块；  
   - 右侧是“后缀排序区”，初始是乱序的后缀；  
   - 底部是“控制面板”：单步、自动播放、重置按钮，速度滑块。  

2. **后缀排序过程**：  
   - 每一步倍增排序（比如k=1、k=2），后缀会“移动”到正确的位置，用**闪烁**提示当前排序的k值；  
   - 排序完成后，后缀排序区显示有序的后缀，每个后缀用不同颜色标记来源（A串是蓝色，B串是红色）。  

3. **Height数组计算**：  
   - 相邻后缀的公共前缀长度用**绿色进度条**显示，进度条长度就是Height值；  
   - 计算完成后，右侧显示Height数组的像素柱形图。  

4. **单调栈统计**：  
   - 单调栈用**黄色积木**表示，每次加入新积木时，弹出比它高的积木（用“消失动画”），合并贡献；  
   - 每一步的贡献用**数字气泡**显示，最终答案累加时播放“叮”的音效。  

5. **结果展示**：  
   - 动画结束后，屏幕中央显示最终答案，播放“胜利”音效，像素字符跳起来庆祝！  


### 交互设计  
- **单步执行**：点击“下一步”按钮，动画走一步，同时显示当前步骤的文字说明（比如“正在计算k=2的排序”）；  
- **自动播放**：拖动速度滑块调整播放速度，动画自动运行；  
- **重置**：点击“重置”按钮，回到初始状态，重新开始动画。  


## 6. 拓展练习与相似问题思考  

### 通用思路迁移  
- SA的思路可以解决**所有需要计算LCP的问题**（比如求最长公共子串、不同子串个数）；  
- SAM的思路可以解决**所有需要统计子串出现次数的问题**（比如求子串出现的位置、次数）。  


### 洛谷练习推荐  
1. **P4248 [AHOI2013]差异**：用SA+单调栈计算所有后缀对的LCP和，巩固单调栈的应用；  
2. **P3804 【模板】后缀自动机**：SAM的模板题，掌握SAM的构建和基本操作；  
3. **P2408 不同子串个数**：用SAM统计不同子串的数量，巩固endpos的性质；  
4. **P5546 【XR-4】模拟赛**：用广义SAM处理多个字符串的公共子串问题，拓展SAM的应用。  


## 7. 学习心得与经验分享  

- **SA的关键**：理解后缀排序的倍增思想，以及Height数组的意义；  
- **SAM的关键**：掌握endpos等价类的性质，以及拓扑排序预处理的方法；  
- **调试技巧**：遇到SA的问题，可以打印`sa`、`rank`、`het`数组，观察是否正确；遇到SAM的问题，可以打印每个节点的`len`、`fa`、`size`，检查是否符合预期。  


## 结语  
通过这道题，我们学习了SA和SAM两种高效处理字符串问题的算法。SA适合处理LCP相关的问题，SAM适合处理子串出现次数的问题。记住：**字符串问题的核心是“压缩子串信息”**，无论是SA的后缀排序还是SAM的自动机，都是为了高效处理子串！  

下次遇到字符串问题，不妨想想：“用SA还是SAM？” 动手试试，你会发现字符串问题其实很有趣！💪

---
处理用时：124.01秒
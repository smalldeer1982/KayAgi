# 题目信息

# 【模板】后缀自动机（SAM）

## 题目描述

给定一个只包含小写字母的字符串 $S$。

请你求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。


## 说明/提示

对于 $10 \%$ 的数据，$\lvert S \rvert \le 1000$。  
对于 $100\% $的数据，$1 \le \lvert S \rvert \le {10}^6$。

- 2023.7.30：添加一组 hack 数据。

## 样例 #1

### 输入

```
abab```

### 输出

```
4```

# AI分析结果

# 💡 Kay的C++算法解析：后缀自动机（SAM）模板 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：后缀自动机（SAM）的构造与应用


### 🗣️ 初步分析
解决这道题的核心是 **后缀自动机（SAM）**——一种能高效压缩字符串所有子串的数据结构。简单来说，SAM就像一个“超级压缩包”：它把字符串的所有子串按“结束位置相同”的规则打包成**等价类**（每个等价类对应一个节点），用O(n)的空间存储O(n²)的子串信息，还能在线性时间内完成构造。

#### 核心问题与解法
题目要求找到**出现次数≠1的子串**，并计算“出现次数×长度”的最大值。SAM的关键性质是：**每个等价类的子串出现次数等于其endpos集合的大小**（endpos是子串所有结束位置的集合）。因此解法分为三步：
1. **构造SAM**：将字符串的子串压缩成等价类节点，记录转移（字符边）和后缀链接（parent树）。
2. **统计出现次数**：通过parent树的子树和（每个节点的子树包含所有后缀，因此子树大小就是endpos大小）。
3. **计算最大值**：遍历所有节点，若出现次数≠1，更新“次数×长度”的最大值。


#### 核心算法流程与可视化思路
SAM的构造是**增量式**的：逐个字符插入，维护当前最长前缀的节点（`last`），并调整转移和后缀链接。可视化时可以用**8位像素风格**展示：
- 节点：用不同颜色的像素块表示（根节点蓝色，新增节点绿色，拆分节点黄色）。
- 转移边：用带字符的箭头连接节点（比如`a`转移用红色箭头）。
- 后缀链接：用虚线连接（比如根节点到子节点的虚线）。
- 插入过程：每插入一个字符，动态展示节点创建、边添加、拆分节点的过程（比如插入`abab`时，节点从1→2→3→4→5的变化）。
- 统计过程：用“水流填充”效果展示子树和的计算（从叶子节点向上合并大小）。


## 2. 精选优质题解参考

### 题解一：Hatsune_Miku（理论详细）
* **点评**：这是一篇SAM的“理论圣经”，从endpos的定义到SAM的构造细节，逐一证明推导。亮点是**严格的数学证明**（比如endpos的性质、SAM的线性复杂度），适合想深入理解SAM本质的同学。不足是代码部分较简洁，需结合其他题解补充。


### 题解二：KesdiaelKen（通俗入门）
* **点评**：这篇题解用“字典树压缩”“endpos等价类”等通俗比喻，把SAM的复杂概念拆解成“可意会”的内容。亮点是**构造过程的图文解释**（比如插入`aababa`的节点变化图）和**代码逐行解析**，非常适合入门。比如用“拆分包裹”比喻节点拆分，让复杂步骤变得直观。


### 题解三：shadowice1984（简洁高效）
* **点评**：这道题解的代码堪称“SAM模板的天花板”——结构清晰、变量命名规范，且包含**拓扑排序统计子树大小**的优化（避免DFS递归栈溢出）。亮点是**时间复杂度的优化**（用桶排序处理节点顺序，线性时间统计），适合竞赛中直接套用。


### 题解四：all_for_god（模板实用）
* **点评**：这篇题解提供了**完整的SAM模板**，包括构造、统计子树大小和计算最大值的全流程。亮点是**应用举例**（比如最小表示法、最长公共子串），帮助同学理解SAM的拓展用法。代码中的`cnt`数组记录节点初始大小（前缀节点初始为1），`dfs1`函数递归计算子树和，逻辑清晰。


## 3. 核心难点辨析与解题策略

### 1. **难点1：理解endpos等价类**
- **问题**：为什么要把endpos相同的子串归为一类？
- **分析**：endpos相同的子串具有“后缀关系”（短串是长串的后缀），且它们的出现次数相同。归为一类可以压缩空间，比如`abab`中的`ab`和`b`（endpos都是{2,4}），可以用一个节点表示。
- 💡 **学习笔记**：endpos是SAM的“灵魂”，所有性质都基于它。


### 2. **难点2：SAM的构造（特别是拆分节点）**
- **问题**：为什么要拆分节点？如何处理？
- **分析**：当插入字符时，若找到的转移节点`q`的长度大于`p.len+1`（`p`是当前跳后缀链接找到的节点），说明`q`包含的子串中，只有长度≤`p.len+1`的子串是新后缀的一部分，需要拆分成`q`（保留长串）和`clone`（负责短串）。拆分后要调整转移和后缀链接（比如把`p`及其祖先的`c`转移从`q`改为`clone`）。
- 💡 **学习笔记**：拆分节点是SAM构造的关键，记住“复制转移、调整后缀链接、重定向转移”三步。


### 3. **难点3：统计出现次数（子树和）**
- **问题**：为什么子树和等于endpos大小？
- **分析**：parent树中，子节点的endpos是父节点的子集（子串是父节点子串的后缀）。每个前缀节点（插入时新建的节点）的endpos初始大小为1（只包含当前位置），子树和就是所有后代节点的初始大小之和，即该等价类的出现次数。
- 💡 **学习笔记**：统计出现次数的本质是“父节点包含所有子节点的endpos”，因此子树和就是endpos的大小。


### ✨ 解题技巧总结
- **技巧A**：SAM的构造要注意“增量式”——逐个字符插入，维护`last`节点。
- **技巧B**：统计子树和可以用DFS或拓扑排序（后者更适合长字符串，避免栈溢出）。
- **技巧C**：拆分节点时，要复制原节点的转移和后缀链接，再调整相关转移。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合多个优质题解的思路，提供一个清晰的SAM模板，包含构造、统计子树大小和计算最大值。

```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 2e6 + 10; // 字符串长度的两倍（SAM节点数上限）

struct Node {
    int ch[26];   // 转移：字符→节点编号
    int len;      // 该节点对应子串的最大长度
    int fa;       // 后缀链接（parent树的父节点）
    long long cnt;// 该节点的出现次数（endpos大小）
} sam[MAXN];

int sz = 1, last = 1; // sz: 节点总数（初始为1，根节点）; last: 当前最长前缀的节点

// 插入字符c（c是0~25的整数）
void insert(int c) {
    int cur = ++sz; // 新建节点，代表当前最长前缀
    sam[cur].len = sam[last].len + 1;
    sam[cur].cnt = 1; // 前缀节点的endpos初始大小为1

    int p = last;
    // 沿后缀链接向上找，添加转移到cur
    while (p && !sam[p].ch[c]) {
        sam[p].ch[c] = cur;
        p = sam[p].fa;
    }

    if (!p) {
        sam[cur].fa = 1; // 没找到转移，后缀链接连到根
    } else {
        int q = sam[p].ch[c];
        if (sam[p].len + 1 == sam[q].len) {
            sam[cur].fa = q; // q符合条件，直接连后缀链接
        } else {
            // 拆分q为clone，复制转移和后缀链接
            int clone = ++sz;
            sam[clone] = sam[q]; // 复制转移和fa
            sam[clone].len = sam[p].len + 1;
            sam[clone].cnt = 0;  // clone节点不是前缀，初始次数为0

            // 调整q和cur的后缀链接
            sam[q].fa = clone;
            sam[cur].fa = clone;

            // 重定向p及其祖先的c转移到clone
            while (p && sam[p].ch[c] == q) {
                sam[p].ch[c] = clone;
                p = sam[p].fa;
            }
        }
    }

    last = cur; // 更新last为当前节点
}

vector<int> g[MAXN]; // parent树的邻接表（用于统计子树和）
long long ans = 0;   // 答案：最大的次数×长度

// 递归统计子树和，并计算最大值
void dfs(int u) {
    for (int v : g[u]) {
        dfs(v);
        sam[u].cnt += sam[v].cnt; // 子树和累加
    }
    // 如果出现次数≠1，更新答案
    if (sam[u].cnt > 1) {
        ans = max(ans, sam[u].cnt * sam[u].len);
    }
}

int main() {
    string s;
    cin >> s;
    for (char ch : s) {
        insert(ch - 'a'); // 将字符转为0~25的整数
    }

    // 构建parent树的邻接表
    for (int i = 2; i <= sz; ++i) {
        g[sam[i].fa].push_back(i);
    }

    dfs(1); // 从根节点开始统计
    cout << ans << endl;

    return 0;
}
```

* **代码解读概要**：
  1. **结构体Node**：存储每个节点的转移、长度、后缀链接和出现次数。
  2. **insert函数**：增量式构造SAM，处理转移、后缀链接和节点拆分。
  3. **dfs函数**：遍历parent树，计算子树和（出现次数），并更新最大值。
  4. **主函数**：读取字符串，插入每个字符，构建parent树，统计并输出结果。


### 针对优质题解的片段赏析

#### 题解二（KesdiaelKen）：拆分节点的关键代码
* **亮点**：用通俗的方式解释了节点拆分的逻辑。
* **核心代码片段**：
  ```cpp
  int nq=++tot;dian[nq]=dian[q];
  dian[nq].len=dian[p].len+1;
  dian[q].fa=dian[np].fa=nq; 
  for(;p&&dian[p].ch[c]==q;p=dian[p].fa)dian[p].ch[c]=nq;
  ```
* **代码解读**：
  - 第一行：复制`q`节点的所有属性到`nq`（拆分出的新节点）。
  - 第二行：设置`nq`的长度为`p.len+1`（符合“最长后缀”的要求）。
  - 第三行：调整`q`和`np`（当前新建节点）的后缀链接到`nq`。
  - 第四行：重定向`p`及其祖先的`c`转移到`nq`，确保后续转移正确。
* 💡 **学习笔记**：拆分节点的核心是“复制+调整”，确保新节点负责短串，原节点负责长串。


#### 题解三（shadowice1984）：拓扑排序统计子树大小
* **亮点**：用桶排序处理节点顺序，避免递归栈溢出。
* **核心代码片段**：
  ```cpp
  int bu[N],so[N];
  for(int i=1;i<=cn;i++)bu[t[i].le]++;
  for(int i=1;i<=cn;i++)bu[i]+=bu[i-1];
  for(int i=1;i<=cn;i++)so[bu[t[i].le]--]=i;
  for(int i=cn;i>=1;i--){
      int no=so[i];
      su[t[no].fa]+=su[no];
      if(su[no]>1)an=max(an,su[no]*t[no].le);
  }
  ```
* **代码解读**：
  - 前两行：统计每个长度的节点数量，用于桶排序。
  - 第三行：按长度从大到小排序节点（parent树中，父节点长度小于子节点）。
  - 第四至七行：逆序遍历节点，累加子树和，并计算最大值。
* 💡 **学习笔记**：拓扑排序统计子树和更高效，适合处理长字符串（比如1e6长度）。


## 5. 算法可视化：像素动画演示

### 🎮 动画演示主题：SAM的“压缩与成长”
用8位像素风格模拟SAM的构造过程，结合复古游戏元素（比如《吃豆人》的像素风格、《超级马里奥》的音效），让SAM的构建变得直观有趣。


### 🎬 动画帧步骤与交互设计
1. **初始场景**：
   - 屏幕中央是根节点（蓝色像素块，编号1），下方是控制面板（开始/暂停、单步、重置按钮，速度滑块）。
   - 背景是复古游戏的星空，背景音乐是8位风格的《卡农》。

2. **插入字符`a`**：
   - 新建节点2（绿色），根节点的`a`转移（红色箭头）连到节点2。
   - 节点2的后缀链接（红色虚线）连到根节点。
   - 播放“叮”的音效（表示节点创建）。

3. **插入字符`b`**：
   - 新建节点3（绿色），从节点2向上跳后缀链接（到根节点）。
   - 根节点没有`b`转移，添加转移到节点3。
   - 节点3的后缀链接连到根节点，播放“叮”音效。

4. **插入字符`a`**：
   - 新建节点4（绿色），从节点3向上跳后缀链接（到根节点）。
   - 根节点有`a`转移到节点2，检查`node2.len+1`是否等于`node2.len`？不，`node2.len=1`，`node2.len+1=2`，而`node2`的`a`转移是节点4？不对，实际插入`a`时，节点3的后缀链接是根节点，根节点的`a`转移是节点2，此时`node2.len+1=2`，而`node2`的`a`转移是节点4吗？需要调整动画逻辑，比如插入`a`时，节点3的`a`转移不存在，添加到节点4，然后跳后缀链接到根节点，根节点的`a`转移是节点2，此时`node2.len+1=2`，等于`node4.len`（`node4.len=3`？不对，可能需要更准确的动画设计，比如插入`abab`的第四步：
   - 新建节点5（绿色），从节点4向上跳后缀链接到节点2（节点4的后缀链接是节点2）。
   - 节点2有`b`转移到节点3，检查`node2.len+1=2`是否等于`node3.len=2`？是的，所以节点5的后缀链接连到节点3。
   - 播放“叮”音效，节点5闪烁。

5. **统计子树大小**：
   - 用“水流填充”效果，从叶子节点（绿色）向上填充到根节点（蓝色），每个节点的颜色深度表示子树大小。
   - 当节点的子树大小>1时，节点闪烁黄色，同时显示“次数×长度”的值。

6. **交互设计**：
   - **单步执行**：点击“单步”按钮，动画执行一步（插入一个字符或统计一个节点）。
   - **自动播放**：拖动速度滑块调整播放速度（比如1x、2x、4x）。
   - **重置动画**：点击“重置”按钮，回到初始状态。
   - **音效**：节点创建播放“叮”，拆分节点播放“啪”，统计完成播放“胜利”音效。


## 6. 拓展练习与相似问题思考

### 🌟 通用思路迁移
SAM不仅能解决本题，还能处理以下问题：
1. **不同子串个数**：计算所有等价类的`len - fa.len`之和（每个等价类的子串数量）。
2. **最长公共子串**：对一个串建SAM，用另一个串匹配，记录最长匹配长度。
3. **第k大子串**：结合子树大小和字典序遍历，找到第k大的子串。


### 📚 练习推荐（洛谷）
1. **洛谷 P3975** - 弦论  
   🗣️ **推荐理由**：这道题要求求第k大子串，需要结合SAM的子树大小和字典序遍历，是SAM的进阶应用。
2. **洛谷 P4070** - 生成魔咒  
   🗣️ **推荐理由**：动态插入字符并维护不同子串个数，考验SAM的在线构造能力。
3. **洛谷 SP1811** - LCS - Longest Common Substring  
   🗣️ **推荐理由**：求两个串的最长公共子串，是SAM的经典应用，需要用一个串建SAM，另一个串匹配。
4. **洛谷 P6640** - 封印  
   🗣️ **推荐理由**：求两个串的区间最长公共子串，需要结合SAM和二分答案，考验综合应用能力。


## 7. 学习心得与经验分享

### 📝 来自题解的经验
- **KesdiaelKen**：“我一开始卡了很久，后来通过画图模拟插入过程才理解节点拆分。”  
  **点评**：画图是理解SAM的好方法，尤其是构造过程中的节点变化和转移调整。
- **shadowice1984**：“用拓扑排序统计子树和可以避免递归栈溢出，适合长字符串。”  
  **点评**：竞赛中要注意算法的实用性，比如递归可能会爆栈，拓扑排序更安全。
- **all_for_god**：“SAM的关键是理解endpos，所有性质都基于它。”  
  **点评**：抓住核心概念（endpos），其他性质都会变得容易理解。


## 💪 总结
SAM是字符串算法中的“瑞士军刀”，能高效处理多种子串问题。学习SAM的关键是：
1. 理解endpos等价类和parent树的性质。
2. 掌握增量式构造的细节（尤其是节点拆分）。
3. 学会通过子树和统计出现次数。

希望这份指南能帮助你掌握SAM的核心思想！多画图、多模拟、多练习，你一定能熟练运用SAM解决字符串问题！🚀

---
处理用时：176.41秒
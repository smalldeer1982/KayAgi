# 题目信息

# [SDOI2016] 生成魔咒

## 题目描述

魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1,2$ 拼凑起来形成一个魔咒串 $[1,2]$。

一个魔咒串 $S$ 的非空字串被称为魔咒串 $S$ 的生成魔咒。

例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1],[2],[1,2],[2,1],[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1],[1,1],[1,1,1]$ 三种，最初 S 为空串。  

共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。


## 说明/提示

#### 数据规模与约定   
对于 $10\%$ 的数据，保证 $1 \le n \le 10$；  
对于 $30\%$ 的数据，保证 $1 \le n \le 100$；  
对于 $60\%$ 的数据，保证 $1 \le n \le 10^3$；   
对于 $100\%$ 的数据，保证 $1 \le n \le 10^5$，$1 \leq x_i \leq 10^9$。


## 样例 #1

### 输入

```
7
1 2 3 3 3 1 2```

### 输出

```
1
3
6
9
12
17
22```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2016]生成魔咒 深入学习指南 💡

## 引言
今天我们要解决的是**动态添加字符求本质不同子串个数**的问题——[SDOI2016]生成魔咒。想象一下：你在玩一个“字符串拼接游戏”，每次在末尾加一个字符，要立刻算出现在有多少种**不一样的小片段**（子串）。这道题的核心是**高效处理动态字符串的子串计数**，而解决它的“神器”是**后缀自动机（SAM）**或**后缀数组（SA）**。接下来我们一步步拆解思路～


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：后缀自动机（SAM）/ 后缀数组（SA）的应用

🗣️ **初步分析**：
解决这道题的关键，是理解**本质不同子串的计数方法**——对于字符串`S`，其本质不同子串的数量等于所有**以每个位置结尾的新子串**的数量之和。比如加字符`c`后，新子串是`S+c`的所有后缀（如`c`、`S[-1]+c`、`S[-2]+S[-1]+c`…），但要减去与之前重复的部分。

### 核心算法选择：后缀自动机（SAM）
为什么选SAM？因为它是**在线算法**（边加字符边处理），且时间复杂度是`O(n log n)`（用`map`处理大字符集），完美适配“动态添加”的需求！

SAM的核心思想可以用一个比喻理解：  
把字符串的所有子串装进**不同的盒子（状态）**里——每个盒子装的是**结束位置完全相同**的子串（称为`endpos`集合）。比如子串`"ab"`和`"b"`如果结束位置都在第3位，就会被装进同一个盒子吗？不！只有`endpos`完全一样的子串才会在一个盒子里。每个盒子的子串长度是**连续区间**：比如盒子`v`的最长子串长度是`len[v]`，最短是`len[link[v]]+1`（`link[v]`是`v`的“父盒子”，装着更短的子串）。因此，每个盒子贡献的新子串数量是`len[v] - len[link[v]]`，所有盒子的贡献之和就是**本质不同子串的总数**！

### 另一种思路：后缀数组（SA）
如果用SA，需要**反转字符串**——把“末尾加字符”变成“开头删字符”（因为反转后，原字符串的后缀变成前缀，动态添加等价于动态删除前缀）。然后用**平衡树（如`set`）**维护当前所有后缀的`rank`值，结合**ST表**查询区间最小`height`（即最长公共前缀LCP），从而计算重复的子串数量。但SA的复杂度更高（`O(n log²n)`），不如SAM简洁。


## 2. 精选优质题解参考

我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了3份优质题解：

### 题解一：skylee的SAM解法（赞5）
* **点评**：这份题解的代码**极度简洁**，完美体现了SAM的核心逻辑！作者用`map`处理大字符集（题目中字符是`1e9`的数字），每次插入字符时：
  1. 创建新状态`cur`，长度是上一个状态`last`的长度+1；
  2. 遍历`last`的`link`链，更新转移；
  3. 处理`q`的情况（如果`q`的长度等于`p+1`，直接连`link`；否则分裂`q`为`new_q`）；
  4. 最后计算贡献`ans += len[cur] - len[link[cur]]`。  
  代码的变量命名（如`link`、`len`、`go`）非常直观，边界处理严谨，是SAM的“模板级”实现！

### 题解二：hehelego的SAM证明（赞26）
* **点评**：这份题解**从理论层面讲透了SAM的计数原理**！作者证明了：
  - SAM的状态与本质不同子串一一对应；
  - 每个状态的贡献是`len[v] - len[link[v]]`；
  - 动态插入字符时，新增的贡献仅来自新状态`np`。  
  对于想理解“为什么SAM能解决这个问题”的同学，这份题解是“开窍神器”！

### 题解三：xht的SA解法（赞38）
* **点评**：这份题解提供了SA的思路——**反转字符串+set维护相邻后缀**。作者通过反转字符串，把动态添加转化为动态删除，用`set`存储当前后缀的`rank`值，每次删除时找前驱和后继，用ST表查询LCP，从而调整重复子串的数量。虽然复杂度稍高，但思路巧妙，适合想练习SA的同学！


## 3. 核心难点辨析与解题策略

在解决这道题时，你可能会遇到以下**3个核心难点**，我们结合优质题解的思路来突破：

### 难点1：如何处理大字符集？
**问题**：题目中字符是`1e9`的数字，无法用数组存储转移！  
**解决策略**：用`map`或`unordered_map`存储每个状态的转移（如skylee的题解用`std::map<int, State*>`）。`map`的查询和插入是`O(log n)`，总复杂度是`O(n log n)`，完全可以处理`1e5`的数据。

### 难点2：SAM的状态分裂是什么？
**问题**：当插入字符时，遇到`q`的长度不等于`p+1`（`p`是当前状态的父状态），怎么办？  
**解决策略**：分裂`q`为`new_q`！`new_q`继承`q`的转移和`link`，但长度是`p+1`。然后把`q`和新状态`np`的`link`指向`new_q`，再更新`p`的转移链（如skylee题解中的`clone`操作）。**状态分裂是SAM的核心难点，一定要理解其本质——拆分`endpos`集合**！

### 难点3：SA的反转字符串为什么有效？
**问题**：原问题是“末尾加字符”，反转后变成“开头删字符”，为什么能等价？  
**解决策略**：原字符串`S`的子串`T`，反转后变成`reverse(T)`，且`T`是`S`的子串当且仅当`reverse(T)`是`reverse(S)`的子串。因此，**反转后的本质不同子串数量与原字符串相同**。而“开头删字符”只会影响一个后缀（原字符串的前缀），更容易用SA维护！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（SAM版）
* **说明**：综合skylee、MikeDuke等题解的思路，提炼出的SAM模板，用`map`处理大字符集，代码简洁高效。
* **完整核心代码**：
```cpp
#include <map>
#include <cstdio>
#include <cctype>
using namespace std;

inline int getint() {
    char ch;
    while (!isdigit(ch = getchar()));
    int x = ch ^ '0';
    while (isdigit(ch = getchar())) x = (((x << 2) + x) << 1) + (ch ^ '0');
    return x;
}

struct State {
    State* link;
    map<int, State*> go;
    int len;
    State(int l) : link(nullptr), len(l) {}
};

State* root, *last;
long long ans;

void extend(int w) {
    State* p = last;
    State* new_p = new State(last->len + 1);
    while (p && !p->go.count(w)) {
        p->go[w] = new_p;
        p = p->link;
    }
    if (!p) {
        new_p->link = root;
    } else {
        State* q = p->go[w];
        if (q->len == p->len + 1) {
            new_p->link = q;
        } else {
            State* new_q = new State(p->len + 1);
            new_q->go = q->go;
            new_q->link = q->link;
            q->link = new_p->link = new_q;
            while (p && p->go[w] == q) {
                p->go[w] = new_q;
                p = p->link;
            }
        }
    }
    last = new_p;
    ans += new_p->len - (new_p->link ? new_p->link->len : 0);
}

int main() {
    root = last = new State(0);
    int n = getint();
    for (int i = 0; i < n; ++i) {
        extend(getint());
        printf("%lld\n", ans);
    }
    return 0;
}
```
* **代码解读概要**：
  1. `State`结构体：每个状态包含`link`（父状态指针）、`go`（转移表，用`map`存）、`len`（最长子串长度）；
  2. `extend`函数：插入字符`w`，创建新状态`new_p`，遍历`p`的`link`链更新转移，处理`q`的情况（分裂或直接连`link`）；
  3. `main`函数：初始化`root`和`last`，循环插入字符，每次输出`ans`（本质不同子串数）。


### 优质题解片段赏析——skylee的SAM代码
* **亮点**：用`map`处理大字符集，代码简洁到极致！
* **核心代码片段**：
```cpp
class SuffixAutomaton {
private:
    struct State {
        State* link;
        map<int, State*> go;
        int len;
        State(int l) : link(nullptr), len(l) {}
    };
    State* root, *last;
    long long ans;
    void extend(int w) {
        State* p = last;
        State* new_p = new State(last->len + 1);
        while (p && !p->go.count(w)) {
            p->go[w] = new_p;
            p = p->link;
        }
        if (!p) new_p->link = root;
        else {
            State* q = p->go[w];
            if (q->len == p->len + 1) new_p->link = q;
            else {
                State* new_q = new State(p->len + 1);
                new_q->go = q->go;
                new_q->link = q->link;
                q->link = new_p->link = new_q;
                while (p && p->go[w] == q) p->go[w] = new_q, p = p->link;
            }
        }
        last = new_p;
        ans += new_p->len - (new_p->link ? new_p->link->len : 0);
    }
public:
    SuffixAutomaton() : root(new State(0)), last(root), ans(0) {}
    long long query(int w) { extend(w); return ans; }
};
```
* **代码解读**：
  - `State`结构体：用`map<int, State*>`存转移，解决大字符集问题；
  - `extend`函数：核心逻辑，处理插入字符的所有情况；
  - `query`函数：对外接口，插入字符并返回当前`ans`。
* 💡 **学习笔记**：SAM的核心是“状态+转移+link指针”，只要掌握这三个部分，就能写出SAM的模板！


## 5. 算法可视化：像素动画演示（SAM版）

### 动画设计思路
我们用**8位像素风**（类似FC红白机）展示SAM的插入过程，让你直观看到“状态如何创建、link指针如何连接”！

### 动画细节
1. **场景初始化**：
   - 屏幕左侧是**状态列表**：每个状态是一个带编号的像素方块（如`State 1`是红色，`State 2`是蓝色），下方显示`len`值；
   - 屏幕中间是**转移图**：用线条连接状态和转移字符（如`State 1`→`State 2`的线条旁标`5`，表示字符是5）；
   - 屏幕右侧是**答案显示区**：用大像素字显示当前`ans`；
   - 底部是**控制面板**：有“单步执行”“自动播放”“重置”按钮，速度滑块（1x~5x）。

2. **插入字符的动态演示**（以插入字符`5`为例）：
   - **步骤1**：创建新状态`new_p`（编号+1，颜色闪烁），`len`值是`last`的`len+1`（如`last`是`State 2`，`len=3`，则`new_p`的`len=4`）；
   - **步骤2**：遍历`last`的`link`链（从`State 2`→`State 1`→`nullptr`），更新转移（如`State 1`的`go[5]`指向`new_p`，线条闪烁）；
   - **步骤3**：如果`p`是`nullptr`，`new_p`的`link`指向`root`（线条变绿）；
   - **步骤4**：计算贡献`ans += new_p->len - new_p->link->len`，答案区的数字闪烁更新；
   - **音效**：创建状态时“叮”，更新转移时“嗒”，完成时“叮～”（上扬音调）。

3. **状态分裂的演示**：
   - 当遇到`q`的`len`不等于`p+1`时，分裂`q`为`new_q`（新的像素方块，颜色是`q`的浅色调）；
   - `new_q`继承`q`的转移和`link`，`q`和`new_p`的`link`指向`new_q`（线条变紫）；
   - 更新`p`的转移链（如`State 1`的`go[5]`从`q`改为`new_q`，线条闪烁）。

### 为什么这样设计？
- 像素风格：复古有趣，降低学习压力；
- 状态和转移可视化：让“抽象的SAM”变成“看得见的积木”；
- 音效提示：强化关键操作的记忆（比如“叮”对应状态创建，“嗒”对应转移更新）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
SAM不仅能解决本题，还能处理**所有与“子串计数、出现次数、位置”相关的问题**，比如：
1. 统计一个字符串中所有本质不同子串的数量（洛谷P2408）；
2. 统计一个子串在原字符串中的出现次数（洛谷P3804）；
3. 找到字符串中字典序第k小的子串（洛谷P5355）。

### 洛谷练习推荐
1. **洛谷P2408** - 不同子串个数  
   🗣️ **推荐理由**：SAM的基础应用，直接计算本质不同子串数，巩固SAM的计数原理。
2. **洛谷P3804** - 后缀自动机（模板）  
   🗣️ **推荐理由**：SAM的模板题，练习SAM的构建和基本操作（如统计子串出现次数）。
3. **洛谷P6139** - 【模板】广义后缀自动机（广义SAM）  
   🗣️ **推荐理由**：SAM的进阶版，处理多个字符串的子串问题，拓展SAM的应用场景。
4. **洛谷P5546** - 公共子串计数  
   🗣️ **推荐理由**：SA的应用，练习SA的构建和`height`数组的使用，对比SAM的解法。


## 7. 学习心得与经验分享

从题解中，我总结了**3条关键经验**：
1. **优先选在线算法**：对于动态添加的问题，SAM比SA更高效，因为它不需要预处理整个字符串；
2. **理解本质比背模板重要**：SAM的状态分裂、link指针的作用，一定要理解其背后的`endpos`集合理论，否则容易写错；
3. **大字符集用map**：遇到`1e9`的字符，不要慌，用`map`或`unordered_map`存储转移，复杂度完全可控！


## 结语
通过这道题，我们掌握了**后缀自动机（SAM）**的核心思想和应用，学会了用`map`处理大字符集，理解了动态字符串的子串计数方法。记住：**编程的本质是解决问题，而算法是解决问题的工具**——选择合适的工具（如SAM），才能高效解决问题！

下次我们会探索更有趣的算法问题，比如**广义SAM**或**后缀树**，敬请期待～ 💪

---
处理用时：149.31秒
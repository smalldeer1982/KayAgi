# 题目信息

# [HEOI2015] 最短不公共子串

## 题目描述

在虐各种最长公共子串、子序列的题虐的不耐烦了之后，你决定反其道而行之。

下面给出一些定义：

- 一个串的“子串”指的是它的连续的一段，例如 `bcd` 是 `abcdef` 的子串，但 `bde` 不是。
- 一个串的“子序列”指的是它的可以不连续的一段，例如 `bde` 是 `abcdef` 的子序列，但 `bdd` 不是。

下面，给两个小写字母串 $a, b$，请你计算：

1. $a$ 的一个最短的子串，它不是 $b$ 的子串。
2. $a$ 的一个最短的子串，它不是 $b$ 的子序列。
3. $a$ 的一个最短的子序列，它不是 $b$ 的子串。
4. $a$ 的一个最短的子序列，它不是 $b$ 的子序列。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $20$。
- 对于 $50\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $500$。
- 对于 $100\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $2000$。

## 样例 #1

### 输入

```
aabbcc
abcabc```

### 输出

```
2
4
2
4```

## 样例 #2

### 输入

```
aabbcc
aabbcc```

### 输出

```
-1
-1
2
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[HEOI2015]最短不公共子串 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：自动机应用（后缀自动机SAM + 序列自动机SQAM）、广度优先搜索（BFS）

🗣️ **初步分析**：  
这道题是**四合一的自动机应用题**，核心目标是找到A中“最短的、不在B对应结构里的串”——这里的“结构”可以是子串（连续）或子序列（不连续）。解决这类问题的关键是：用**自动机**快速判断“一个串是否属于另一个串的子串/子序列”，再用**BFS**找“最短的不符合条件的串”（因为BFS的层级对应串的长度，第一次找到的就是最短）。  

- **自动机的作用**：  
  - 后缀自动机（SAM）：高效表示一个串的所有子串（比如B的SAM能快速判断“某串是否是B的子串”）。  
  - 序列自动机（SQAM）：高效表示一个串的所有子序列（比如B的SQAM能快速判断“某串是否是B的子序列”）。  
- **BFS的作用**：  
  我们需要找“最短的串”，而BFS的**层级顺序**刚好对应串的长度（第一层是长度1，第二层是长度2，依此类推）。只要在BFS中遇到“A能转移但B不能转移”的情况，当前层级就是答案。  

**核心算法流程**：  
1. 对A、B分别构建SAM（处理子串）和SQAM（处理子序列）。  
2. 针对四个子问题，组合不同的自动机对（比如问题1用B的SAM，问题3用A的SQAM+B的SAM）。  
3. 用BFS遍历自动机的状态对（比如A的SQAM状态 + B的SAM状态），记录已访问的状态避免重复，直到找到第一个“A能转但B不能转”的情况。  

**可视化设计思路**：  
我会设计一个**8位像素风格的自动机状态演示器**，用像素方块表示自动机的状态，箭头表示转移。比如问题3的可视化：  
- 左侧显示A的SQAM状态（绿色方块），右侧显示B的SAM状态（蓝色方块）。  
- BFS每走一步，当前状态会闪烁，转移的字符用像素文字标注（比如“选字符a”）。  
- 当A能转但B不能转时，绿色方块会“爆炸”（像素动画），同时播放“叮”的胜利音效，提示“找到最短串！”。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，覆盖了“分模块处理”和“统一BFS”两种思路，适合不同学习阶段的同学参考~
</eval_intro>

### 题解一：Ebola（赞10）—— 分模块清晰，代码易读
* **点评**：  
  这份题解把问题拆得很“直白”：先为A、B分别构建SAM（处理子串）和SQAM（处理子序列），然后用**四个独立的BFS函数**对应四个子问题。比如问题1用B的SAM，问题2用B的SQAM，问题3用A的SQAM+B的SAM，问题4用A的SQAM+B的SQAM。  
  代码结构非常清晰：`SAM`结构体负责构建后缀自动机，`SqAM`结构体负责构建序列自动机，四个`BFS`函数分别处理四个问题。变量名（比如`SA`代表A的SAM，`SQA`代表A的SQAM）也很直观，适合初学者一步步跟着写。  
  **亮点**：用`vis`数组记录状态对（比如`vis[va][vb]`），避免重复访问，保证BFS的效率。

### 题解二：UniverseofHK（赞12）—— 代码简洁，统一BFS
* **点评**：  
  这份题解的最大亮点是**把四个问题合并成一个BFS函数**！通过参数`f1`和`f2`控制使用哪种自动机（比如`f1=1`代表A用SAM，`f2=1`代表B用SAM，对应问题1）。代码非常简洁，压行处理后只有几十行核心逻辑，但思路完全不打折扣。  
  **亮点**：发现SAM和SQAM的“转移逻辑”是相通的（都是`ch[状态][字符]`），因此可以用同一个BFS框架处理所有问题，大大减少了代码冗余。

### 题解三：WhiteEurya（赞2）—— 分步骤解释，适合入门
* **点评**：  
  这份题解把四个子问题**逐个拆解**，分别讲清楚每个问题的解法：比如问题1用DP求最长公共后缀，问题2用SQAM枚举子串，问题3用SAM+DP，问题4用SQAM+DP。每个子问题都有独立的函数和注释，非常适合刚学自动机的同学理解“每个问题到底需要什么”。  
  **亮点**：用通俗的语言解释了“为什么用自动机”——比如问题2中，序列自动机可以“贪心”地找到子序列的转移路径，避免暴力枚举所有子序列。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点集中在“自动机的构建”和“状态的高效遍历”上。结合优质题解的共性，我总结了3个核心难点及解决策略：
</difficulty_intro>

### 1. 难点1：后缀自动机（SAM）的构建
- **问题**：SAM的“分裂操作”（处理`len[q] != len[p]+1`的情况）容易写错，比如忘记更新父节点或转移边。  
- **解决策略**：记住SAM的核心逻辑——每个节点代表一组“endpos相同的子串”。分裂操作的目的是“拆分出一个新节点，保存原节点的部分转移”。参考优质题解的`insert`函数：  
  1. 新建节点`np`，长度为`len[p]+1`。  
  2. 沿着`p`的父节点链更新转移边到`np`。  
  3. 如果`p`没有父节点，`np`的父节点是根；否则，处理`q`（`p`的转移节点）：  
     - 若`len[q] == len[p]+1`，直接让`np`的父节点是`q`。  
     - 否则，分裂`q`为`nq`，复制`q`的转移和父节点，再更新`p`的链上的转移到`nq`。  

### 2. 难点2：序列自动机（SQAM）的构建
- **问题**：如何高效构建序列自动机？比如，如何快速找到“下一个字符的位置”？  
- **解决策略**：序列自动机的核心是“每个状态`i`表示前缀`s[1..i]`，转移`ch[i][c]`表示`i`之后第一个`c`的位置”。构建时**从后往前遍历**，维护每个字符的最新位置：  
  1. 初始化`nxt`数组为`n+1`（表示没有该字符）。  
  2. 从`n`到`0`遍历：  
     - 复制`nxt`数组到`ch[i]`（表示`i`位置的转移）。  
     - 更新`nxt[s[i]-'a'] = i`（记录当前字符的位置）。  

### 3. 难点3：BFS中的状态去重
- **问题**：自动机的状态很多（比如SAM有`2n`个节点，SQAM有`n+1`个节点），如果不记录已访问的状态，BFS会重复遍历，导致超时。  
- **解决策略**：用**二维数组`vis`记录状态对**（比如`vis[sa_state][sb_state]`），表示“A的自动机状态`sa_state`和B的自动机状态`sb_state`已经被访问过”。每次BFS时，只有未访问的状态对才会入队。

### ✨ 解题技巧总结
1. **自动机选择**：子串用SAM，子序列用SQAM——这是处理“串的存在性”问题的通用技巧。  
2. **最短路径用BFS**：只要问题要求“最短”，优先考虑BFS（层级对应长度）。  
3. **状态去重**：自动机的状态对可能很多，但`vis`数组可以把复杂度从指数级降到多项式级。  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一个**通用核心实现**，综合了优质题解的思路，覆盖了SAM、SQAM的构建和四个问题的处理：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了Ebola和UniverseofHK的思路，结构清晰，覆盖所有子问题。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2005;
const int MAXM = 4005; // SAM节点数是2*MAXN

// 后缀自动机（SAM）结构体
struct SAM {
    int ch[MAXM][26], par[MAXM], len[MAXM];
    int lst, tot;
    SAM() { lst = tot = 1; memset(ch, 0, sizeof(ch)); memset(par, 0, sizeof(par)); memset(len, 0, sizeof(len)); }
    void insert(int c) {
        int p = lst, np = ++tot;
        len[np] = len[p] + 1;
        while (p && !ch[p][c]) ch[p][c] = np, p = par[p];
        if (!p) par[np] = 1;
        else {
            int q = ch[p][c];
            if (len[q] == len[p] + 1) par[np] = q;
            else {
                int nq = ++tot;
                len[nq] = len[p] + 1;
                memcpy(ch[nq], ch[q], sizeof(ch[q]));
                par[nq] = par[q];
                par[q] = par[np] = nq;
                while (p && ch[p][c] == q) ch[p][c] = nq, p = par[p];
            }
        }
        lst = np;
    }
};

// 序列自动机（SQAM）结构体
struct SqAM {
    int ch[MAXN][26];
    int n;
    void build(char *s) {
        n = strlen(s+1);
        memset(ch, 0, sizeof(ch));
        int nxt[26];
        for (int i = 0; i < 26; ++i) nxt[i] = n + 1;
        for (int i = n; i >= 0; --i) {
            memcpy(ch[i], nxt, sizeof(nxt));
            if (i > 0) nxt[s[i] - 'a'] = i;
        }
    }
};

char A[MAXN], B[MAXN];
SAM SA, SB; // A的SAM，B的SAM
SqAM SQA, SQB; // A的SQAM，B的SQAM
bool vis[MAXM][MAXM]; // 状态对去重

// BFS函数：a_auto是A的自动机类型（0=SQAM，1=SAM），b_auto是B的自动机类型
int bfs(int a_auto, int b_auto) {
    memset(vis, 0, sizeof(vis));
    queue<tuple<int, int, int>> q; // (a_state, b_state, length)
    int a_root = (a_auto == 1) ? 1 : 0; // SAM的根是1，SQAM的根是0
    int b_root = (b_auto == 1) ? 1 : 0;
    q.emplace(a_root, b_root, 0);
    vis[a_root][b_root] = true;
    while (!q.empty()) {
        auto [a_s, b_s, len] = q.front(); q.pop();
        for (int c = 0; c < 26; ++c) {
            // 获取A的转移
            int a_nxt;
            if (a_auto == 1) a_nxt = SA.ch[a_s][c];
            else a_nxt = SQA.ch[a_s][c];
            if (!a_nxt) continue; // A没有这个转移，跳过
            // 获取B的转移
            int b_nxt;
            if (b_auto == 1) b_nxt = SB.ch[b_s][c];
            else b_nxt = SQB.ch[b_s][c];
            // 判断是否找到答案
            if (!b_nxt) return len + 1;
            // 状态未访问过，入队
            if (!vis[a_nxt][b_nxt]) {
                vis[a_nxt][b_nxt] = true;
                q.emplace(a_nxt, b_nxt, len + 1);
            }
        }
    }
    return -1; // 没找到
}

int main() {
    scanf("%s%s", A+1, B+1);
    // 构建SAM
    for (int i = 1; A[i]; ++i) SA.insert(A[i] - 'a');
    for (int i = 1; B[i]; ++i) SB.insert(B[i] - 'a');
    // 构建SQAM
    SQA.build(A);
    SQB.build(B);
    // 处理四个问题
    printf("%d\n", bfs(1, 1)); // 问题1：A子串，B子串（SAM+SAM）
    printf("%d\n", bfs(1, 0)); // 问题2：A子串，B子序列（SAM+SQAM）
    printf("%d\n", bfs(0, 1)); // 问题3：A子序列，B子串（SQAM+SAM）
    printf("%d\n", bfs(0, 0)); // 问题4：A子序列，B子序列（SQAM+SQAM）
    return 0;
}
```
* **代码解读概要**：  
  1. **SAM构建**：`SAM`结构体的`insert`函数实现了后缀自动机的构建，处理了分裂操作。  
  2. **SQAM构建**：`SqAM`结构体的`build`函数从后往前遍历，维护每个字符的最新位置，构建序列自动机。  
  3. **BFS处理**：`bfs`函数通过参数`a_auto`和`b_auto`控制使用哪种自动机，遍历状态对，找第一个“ A能转但B不能转”的情况。  
  4. **主函数**：构建四个自动机，调用`bfs`处理四个问题，输出结果。

---

<code_intro_selected>
接下来，我们剖析优质题解中的核心片段，看看它们的“亮点”在哪里：
</code_intro_selected>

### 题解一：Ebola——SAM的`insert`函数
* **亮点**：标准的SAM构建代码，处理了所有细节（分裂、父节点更新）。
* **核心代码片段**：
```cpp
void insert(int c) {
    int p = lst, np = ++tot; len[np] = len[p] + 1;
    while (p && !ch[p][c]) ch[p][c] = np, p = par[p];
    if (!p) par[np] = 1;
    else {
        int q = ch[p][c];
        if (len[q] == len[p]+1) par[np] = q;
        else {
            int nq = ++tot; len[nq] = len[p]+1;
            memcpy(ch[nq], ch[q], sizeof(ch[q]));
            par[nq] = par[q]; par[q] = par[np] = nq;
            while (p && ch[p][c] == q) ch[p][c] = nq, p = par[p];
        }
    }
    lst = np;
}
```
* **代码解读**：  
  - `p = lst`：`lst`是上一个插入的节点，`p`沿着父节点链更新转移边。  
  - `while (p && !ch[p][c])`：如果`p`没有`c`的转移，就把`p`的`c`转移指向`np`，然后`p`跳转到父节点。  
  - 处理`q`：如果`q`的长度刚好是`p`的长度+1，说明`q`是`np`的父节点；否则，分裂`q`为`nq`，复制`q`的转移和父节点，再更新`p`的链上的转移到`nq`。  
* 💡 **学习笔记**：SAM的`insert`函数是模板级别的代码，背下来！

### 题解二：UniverseofHK——统一BFS的`bfs`函数
* **亮点**：用参数`f1`和`f2`控制自动机类型，减少代码冗余。
* **核心代码片段**：
```cpp
void bfs(int f1, int f2) {
    memset(vis,0,sizeof(vis));
    queue<P> q;
    q.push((P){f1,f2,0}); vis[f1][f2]=1;
    while(!q.empty()) {
        P now=q.front(); q.pop();
        for(int i=0; i<26; ++i) if(ch[0][f1][now.a][i]) {
            if(ch[1][f2][now.b][i]) {
                int a=ch[0][f1][now.a][i], b=ch[1][f2][now.b][i];
                if(!vis[a][b]) vis[a][b]=1, q.push((P){a,b,now.c+1});
            }
            else return (void)printf("%d\n", now.c+1);
        }
    }
    printf("-1\n");
}
```
* **代码解读**：  
  - `ch[0][f1][now.a][i]`：`ch[0]`表示A的自动机，`f1`是自动机类型（1=SAM，0=SQAM），`now.a`是当前状态，`i`是字符。  
  - `if (ch[1][f2][now.b][i])`：判断B的自动机是否有`i`的转移。如果没有，直接输出当前长度+1（找到答案）。  
* 💡 **学习笔记**：用参数控制逻辑，可以大大减少重复代码，这是“代码复用”的好例子。


## 5. 算法可视化：像素动画演示

\<visualization\_intro\>
为了让大家直观看到“自动机+BFS”的过程，我设计了一个**8位像素风格的动画演示器**，结合复古游戏元素（比如FC的音效、像素方块），展示问题3（A的子序列，不是B的子串）的求解过程~
\</visualization\_intro\>

### 动画设计方案
#### 1. 整体风格与场景
- **像素风格**：采用FC红白机的8位色彩（比如绿色#00FF00、蓝色#0000FF、黄色#FFFF00），用16x16的像素方块表示自动机状态，用4x4的像素箭头表示转移。  
- **场景布局**：  
  - 左侧：A的序列自动机（SQAM）状态区（绿色方块），显示当前状态`a_s`。  
  - 右侧：B的后缀自动机（SAM）状态区（蓝色方块），显示当前状态`b_s`。  
  - 中间：转移字符区（黄色像素文字），显示当前尝试的字符（比如“a”）。  
  - 底部：控制面板（红色按钮），包括“单步执行”“自动播放”“重置”。

#### 2. 核心动画流程
以**样例输入1**（A="aabbcc"，B="abcabc"）为例：
1. **初始化**：  
   - A的SQAM根状态是0（绿色方块），B的SAM根状态是1（蓝色方块）。  
   - 控制面板显示“开始”按钮，背景音乐是FC风格的《超级马里奥》开场曲。  
2. **BFS第一步（长度0）**：  
   - 尝试字符`a`（0号字符）：  
     - A的SQAM状态0转移到1（`SQA.ch[0][0] = 1`）。  
     - B的SAM状态1转移到2（`SB.ch[1][0] = 2`）。  
   - 动画：绿色方块从0移动到1，蓝色方块从1移动到2，中间显示“选a”，伴随“叮”的音效。  
3. **BFS第二步（长度1）**：  
   - 尝试字符`a`：  
     - A的SQAM状态1转移到2（`SQA.ch[1][0] = 2`）。  
     - B的SAM状态2转移到3（`SB.ch[2][0] = 3`）？不，B的SAM中状态2的`a`转移不存在！  
   - 动画：绿色方块闪烁（准备转移），蓝色方块不变（无法转移），中间显示“选a”，伴随“啪”的失败音效，然后弹出“找到答案！长度2”的像素文字，播放胜利音效。

#### 3. 交互设计
- **单步执行**：点击一次按钮，执行BFS的一步，显示当前状态和转移。  
- **自动播放**：按1秒/步的速度自动执行，直到找到答案。  
- **重置**：恢复初始状态，重新开始演示。

#### 4. 技术实现
- **Canvas绘制**：用HTML5 Canvas绘制像素方块和箭头，比如`fillRect(x, y, 16, 16)`绘制状态方块，`beginPath()`绘制转移箭头。  
- **音效**：用Web Audio API播放8位音效（比如“叮”的声音是`440Hz`的正弦波，“啪”的声音是`880Hz`的方波）。  
- **状态同步**：每一步动画都同步显示对应的C++代码片段（比如`a_nxt = SQA.ch[a_s][c]`），高亮当前执行行。

\<visualization\_conclusion\>
通过这个动画，你可以**亲眼看到**BFS是如何“一层一层”找最短串的，自动机的状态转移是如何工作的。复古游戏元素让学习更有趣，音效和动画让“抽象的算法”变成“看得见的过程”！
\</visualization\_conclusion\>


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
自动机是处理“串的存在性”问题的神器，学会它可以解决很多类似的题目。以下是几个拓展练习：
\</similar\_problems\_intro\>

### 通用思路迁移
- **子串问题**：比如“最长公共子串”（用SAM）、“不同子串的个数”（用SAM的节点长度差求和）。  
- **子序列问题**：比如“最长公共子序列”（用DP）、“不同子序列的个数”（用DP+模数）。  
- **不公共串问题**：比如“最长不公共子串”（类似本题，但找最长）、“最短不公共子序列”（本题的问题4）。

### 洛谷练习推荐
1. **洛谷 P3804** - 【模板】后缀自动机  
   🗣️ **推荐理由**： SAM的模板题，帮你巩固SAM的构建和基本应用（比如统计不同子串的个数）。  
2. **洛谷 P5826** - 【模板】序列自动机  
   🗣️ **推荐理由**： SQAM的模板题，帮你掌握序列自动机的构建和查询（比如判断一个串是否是另一个串的子序列）。  
3. **洛谷 P4052** - [JSOI2007]文本生成器  
   🗣️ **推荐理由**： 结合SAM和DP的应用题，要求计算“不包含任何给定串的文本数量”，帮你练习自动机的状态转移。  
4. **洛谷 P1368** - 最小表示法  
   🗣️ **推荐理由**： 与子串相关的问题，要求找到字符串的最小表示，帮你理解“子串的序”的概念。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
优质题解中提到了一些调试和学习的经验，我整理了两条最有价值的：
\</insights\_intro\>

> **经验1**（来自Ebola）：“写四个BFS函数的时候，一开始忘记用`vis`数组去重，结果超时了。后来加上`vis`数组，复杂度从O(n^4)降到O(n^2)，一下子就过了。”  
> **点评**：状态去重是BFS的关键！如果不记录已访问的状态，自动机的状态对会被重复遍历，导致超时。一定要记得用`vis`数组！

> **经验2**（来自WhiteEurya）：“构建序列自动机的时候，一开始从前往后遍历，结果转移边全错了。后来改成从后往前遍历，才对了。”  
> **点评**：序列自动机的构建必须从后往前！因为我们需要“找到当前位置之后第一个字符的位置”，从后往前才能正确维护每个字符的最新位置。


## 结语
这道题是自动机的“综合练习题”，覆盖了SAM和SQAM的构建，以及BFS的应用。通过这道题，你可以掌握“用自动机处理串的存在性”和“用BFS找最短路径”的核心技巧。记住：自动机是工具，BFS是方法，关键是要理解“问题的本质是找最短的不符合条件的串”。  

下次遇到“串的存在性+最短”问题，不妨想想：能不能用自动机？能不能用BFS？相信你会有收获的！💪

---
处理用时：185.93秒
# 题目信息

# [AHOI2013] 差异

## 题目描述

给定一个长度为 $n$ 的字符串 $S$，令 $T_i$ 表示它从第 $i$ 个字符开始的后缀。求

$$\displaystyle \sum_{1\leqslant i<j\leqslant n}\operatorname{len}(T_i)+\operatorname{len}(T_j)-2\times\operatorname{lcp}(T_i,T_j)$$

其中，$\text{len}(a)$ 表示字符串 $a$ 的长度，$\text{lcp}(a,b)$ 表示字符串 $a$ 和字符串 $b$ 的最长公共前缀。

## 说明/提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $2\le n\le 500000$，且 $S$ 中均为小写字母。

## 样例 #1

### 输入

```
cacao```

### 输出

```
54```

# AI分析结果

# 💡 Kay的C++算法解析：[AHOI2013]差异 深入学习指南 💡

<introduction>
  今天我们来一起分析「[AHOI2013]差异」这道经典的字符串算法题。这道题看似复杂，但只要掌握了**后缀数组（SA）**或**后缀自动机（SAM）**的核心思想，再结合单调栈等技巧，就能迎刃而解。本指南会帮你拆解问题、理解关键算法，并通过可视化动画直观感受解题过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串（后缀数组/后缀自动机） + 单调栈/并查集`

🗣️ **初步分析**：
> 题目要求计算所有后缀对的「差异」之和，差异的定义是「两个后缀的长度和减去两倍的最长公共前缀（LCP）」。首先，我们可以**化简式子**：  
> 原式子 = $\sum_{i<j} (len(T_i)+len(T_j)) - 2\sum_{i<j} lcp(T_i,T_j)$  
> 前半部分是定值（因为每个后缀长度$len(T_i)=n-i+1$，可以通过数学公式直接算出：$\frac{(n-1)n(n+1)}{2}$），**核心难点是求所有后缀对的LCP之和**。

### 核心算法思路
要计算LCP之和，有两种经典路线：
1. **后缀数组（SA）+ 单调栈**：  
   后缀数组将所有后缀按字典序排序，此时两个后缀的LCP等于它们在SA中的排名区间内的`height`数组的最小值（`height[k]`表示排名第$k$和第$k-1$的后缀的LCP长度）。问题转化为：**求`height`数组所有子区间的最小值之和**——这可以用**单调栈**高效计算（$O(n)$时间）。
2. **后缀自动机（SAM）+ 树形DP**：  
   将原字符串反转后，后缀的LCP转化为前缀的最长公共后缀（LCS），而SAM的`parent`树恰好记录了这种关系。通过计算`parent`树中每个节点的子树大小，可快速求出所有LCP的贡献。

### 可视化设计思路
我会设计一个**8位像素风的动画**，展示「后缀数组排序→height数组生成→单调栈处理区间最小值」的全过程：
- 用不同颜色的像素块代表每个后缀，排序时方块按字典序移动到对应位置；
- 用纵向像素柱表示`height`数组的大小，柱子高度对应`height`值；
- 单调栈用「堆叠的像素块」表示，处理每个`height`元素时，栈的推入/弹出伴随「叮」的音效，同时高亮该元素能覆盖的左右区间（即作为最小值的范围）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了3份优质题解，帮你快速抓住核心！
</eval_intro>

**题解一：小粉兔（SA+单调栈，赞52）**
* **点评**：这份题解是「SA+单调栈」的经典实现，思路堪称标杆！作者先化简式子，明确核心是求LCP之和；接着完整实现了后缀数组的**倍增法构建**和`height`数组计算；最后用单调栈找到每个`height`元素作为最小值的左右边界（`L[i]`和`R[i]`），通过`(R[i]-i)*(i-L[i])*height[i]`计算贡献。代码规范（变量名如`SA`、`Height`清晰），边界处理严谨（比如`Height[1]`初始化为0），是入门SA的绝佳参考！

**题解二：Kelin（SAM+反转字符串，赞16）**
* **点评**：作者的思路非常巧妙——将原字符串反转后，后缀的LCP转化为前缀的LCS，而SAM的`parent`树正好记录了前缀的公共后缀关系。通过统计每个节点作为LCA（最低公共祖先）的次数（`sz[fa[u]]*sz[u]`），再乘以节点长度`len[fa[u]]`，就能快速求出LCP之和。这种「问题转化」的思维值得学习，代码也简洁高效（SAM的实现很标准）。

**题解三：Memory_of_winter（SAM的两种方法，赞10）**
* **点评**：作者给出了SAM的两种解法，全面展示了SAM的灵活性：  
  1. 方法一：通过`parent`树的DFS统计每个节点作为LCA的贡献；  
  2. 方法二：直接计算每条边的贡献（`sz[v]*(n-sz[v])*(R[v]-R[u])`）。  
  两种方法都围绕「子树大小」展开，帮你深入理解SAM的结构。代码注释清晰，对SAM的`fail`数组、`len`数组的解释很到位，适合进阶学习！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是「将问题转化为已知模型」，以下是三个核心难点及应对策略：
</difficulty_intro>

1. **难点1：式子化简——从复杂到简单**  
   * **分析**：原式子包含长度和与LCP，直接计算LCP之和是不可能的（$O(n^2)$时间）。通过数学化简，我们将问题拆解为「定值计算」+「LCP之和计算」，这是解题的第一步。  
   * 💡 **学习笔记**：遇到求和问题，先尝试「分离变量」或「数学化简」，把复杂问题拆成可解决的子问题！

2. **难点2：后缀数组与height数组的关系——LCP的转化**  
   * **分析**：后缀数组将后缀排序后，两个后缀的LCP等于它们排名区间内的`height`最小值（比如排名$i$和$j$的后缀，LCP是$\min(height[i+1..j])$）。这一步是连接「后缀对」和「数组区间」的关键。  
   * 💡 **学习笔记**：后缀数组的核心价值是「将后缀的字典序关系转化为数组的位置关系」，而`height`数组是桥梁！

3. **难点3：区间最小值之和——单调栈的应用**  
   * **分析**：直接枚举所有区间是$O(n^2)$，无法通过大数据。单调栈的作用是**找到每个元素作为最小值的左右边界**（左边第一个比它小的元素位置`L[i]`，右边第一个比它小的元素位置`R[i]`），从而计算该元素的贡献（$(R[i]-i)*(i-L[i])*height[i]$）。  
   * 💡 **学习笔记**：单调栈是处理「区间最值贡献」问题的神器，关键是维护栈的单调性（递增或递减）！

### ✨ 解题技巧总结
- **技巧1：问题转化**：将LCP问题转化为后缀数组的`height`区间最小值，或SAM的`parent`树问题；
- **技巧2：单调栈**：处理区间最值贡献时，用单调栈找左右边界，时间复杂度$O(n)$；
- **技巧3：后缀自动机**：处理字符串的公共前缀/后缀问题时，SAM的`parent`树是高效工具（时间复杂度$O(n)$）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**SA+单调栈**的通用核心实现（基于小粉兔的题解），帮你把握整体框架！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了小粉兔题解的核心逻辑，实现了后缀数组的构建、`height`数组计算，以及单调栈求区间最小值之和。
* **完整核心代码**：
```cpp
#include <cstdio>
#include <cstring>
typedef long long LL;
const int MN = 500005;

int N;
char str[MN];

int M;
int rk[MN], rk2[MN], SA[MN], SA2[MN];
int buk[MN];
int Height[MN];

// 计算Height数组
void GetHeight() {
    int k = 0;
    for (int i = 1; i <= N; ++i) {
        if (rk[i] == 1) { k = Height[1] = 0; continue; }
        if (k) --k;
        int j = SA[rk[i] - 1];
        while (i + k <= N && j + k <= N && str[i + k] == str[j + k]) ++k;
        Height[rk[i]] = k;
    }
}

// 基数排序
void Rsort() {
    for (int i = 1; i <= M; ++i) buk[i] = 0;
    for (int i = 1; i <= N; ++i) ++buk[rk[i]];
    for (int i = 1; i <= M; ++i) buk[i] += buk[i - 1];
    for (int i = N; i >= 1; --i) SA[buk[rk[SA2[i]]]--] = SA2[i];
}

// 构建后缀数组（倍增法）
void GetSA() {
    M = 26;
    for (int i = 1; i <= N; ++i) rk[i] = str[i] - 'a' + 1, SA2[i] = i;
    Rsort();
    for (int j = 1; j < N; j <<= 1) {
        int P = 0;
        for (int i = N - j + 1; i <= N; ++i) SA2[++P] = i;
        for (int i = 1; i <= N; ++i) if (SA[i] > j) SA2[++P] = SA[i] - j;
        Rsort();
        rk2[SA[1]] = P = 1;
        for (int i = 2; i <= N; ++i) {
            if (rk[SA[i]] != rk[SA[i - 1]] || rk[SA[i] + j] != rk[SA[i - 1] + j]) ++P;
            rk2[SA[i]] = P;
        }
        for (int i = 1; i <= N; ++i) rk[i] = rk2[i];
        M = P;
        if (M == N) break;
    }
    GetHeight();
}

int main() {
    scanf("%s", str + 1);
    N = strlen(str + 1);
    GetSA(); // 构建后缀数组和Height数组

    // 单调栈求每个Height[i]的左右边界
    int st[MN], t = 1;
    int L[MN], R[MN];
    st[t] = 1;
    for (int i = 2; i <= N; ++i) {
        while (t && Height[st[t]] > Height[i]) R[st[t--]] = i;
        L[i] = st[t];
        st[++t] = i;
    }
    while (t) R[st[t--]] = N + 1;

    // 计算答案
    LL Ans = (LL)(N - 1) * N * (N + 1) / 2;
    for (int i = 2; i <= N; ++i)
        Ans -= 2LL * (R[i] - i) * (i - L[i]) * Height[i];
    printf("%lld\n", Ans);
    return 0;
}
```
* **代码解读概要**：  
  1. **GetSA()**：用倍增法构建后缀数组（`SA`数组存储排序后的后缀起始位置，`rk`数组存储每个后缀的排名）；  
  2. **GetHeight()**：计算`Height`数组（每个排名对应的LCP长度）；  
  3. **单调栈**：找到每个`Height[i]`的左右边界（`L[i]`和`R[i]`），计算其作为最小值的贡献；  
  4. **答案计算**：用定值减去两倍的LCP之和，输出结果。


<code_intro_selected>
接下来剖析优质题解的核心片段，看看它们的亮点！
</code_intro_selected>

### 题解一：小粉兔（SA+单调栈）
* **亮点**：单调栈处理左右边界的逻辑非常清晰，直接计算每个`Height`的贡献。
* **核心代码片段**（单调栈部分）：
```cpp
int st[MN], t = 1;
int L[MN], R[MN];
st[t] = 1;
for (int i = 2; i <= N; ++i) {
    while (t && Height[st[t]] > Height[i]) R[st[t--]] = i;
    L[i] = st[t];
    st[++t] = i;
}
while (t) R[st[t--]] = N + 1;
```
* **代码解读**：  
  - 栈`st`维护递增的`Height`元素（栈顶元素的`Height`值最大）；  
  - 遍历`i`时，弹出所有比`Height[i]`大的栈顶元素，这些元素的右边界`R`就是`i`；  
  - `L[i]`是栈顶元素（左边第一个比`Height[i]`小的位置）；  
  - 最后处理栈中剩余元素，它们的右边界是`N+1`。
* 💡 **学习笔记**：单调栈处理边界的关键是「维护栈的单调性」，这样能快速找到每个元素的左右边界！


### 题解二：Kelin（SAM+反转字符串）
* **亮点**：将LCP转化为LCS，用SAM的`parent`树计算贡献，思路巧妙。
* **核心代码片段**（SAM的calc函数）：
```cpp
ll calc(){
    ll tp=0;
    fp(i,1,T)++c[len[i]];
    fp(i,1,T)c[i]+=c[i-1];
    fp(i,1,T)b[c[len[i]]--]=i;
    fd(i,T,1){int u=b[i];
        tp+=(ll)sz[fa[u]]*sz[u]*len[fa[u]],sz[fa[u]]+=sz[u];
    }
    return tp;
}
```
* **代码解读**：  
  - 按`len`数组逆序处理节点（保证父节点在子节点之后处理）；  
  - `sz[u]`是子树中「终止节点」的数量（即后缀的数量）；  
  - 每个节点`fa[u]`的贡献是`sz[fa[u]]*sz[u]*len[fa[u]]`（表示有多少对后缀的LCP是`len[fa[u]]`）。
* 💡 **学习笔记**：SAM的`parent`树是「后缀的公共后缀树」，逆序处理节点能快速累加子树大小！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你直观感受「SA+单调栈」的过程，我设计了一个**8位像素风的动画**，结合复古游戏元素，帮你「看」懂算法！
</visualization_intro>

### 动画设计方案
#### 1. **整体风格**
- **8位像素风**：采用FC红白机的色彩（如浅蓝色背景、红色后缀块、绿色`height`柱），字体用像素化的`Press Start 2P`。
- **场景布局**：  
  - 左侧：展示后缀数组的排序过程（用不同颜色的方块代表每个后缀）；  
  - 中间：展示`height`数组的像素柱（高度对应`height`值）；  
  - 右侧：展示单调栈的状态（堆叠的方块，栈顶元素高亮）；  
  - 底部：控制面板（单步、自动播放、重置按钮，速度滑块）。

#### 2. **核心动画步骤**
- **步骤1：后缀数组排序**：  
  初始时，所有后缀方块（如`c`、`a`、`c`、`a`、`o`）随机排列；  
  每一步倍增排序（按前`2^k`个字符排序），方块按字典序移动到对应位置，伴随「沙沙」的移动音效；  
  排序完成后，后缀方块按字典序排列（如`a`、`a`、`c`、`c`、`o`）。

- **步骤2：`height`数组生成**：  
  排序后的后缀方块下方，逐个生成绿色的像素柱，高度对应`height`值（如排名1和2的后缀LCP是1，柱高为1）；  
  生成时伴随「叮」的音效，柱顶显示`height`值。

- **步骤3：单调栈处理**：  
  遍历每个`height`柱，栈的推入/弹出用「滑动」动画表示：  
  - 若当前`height`小于栈顶元素，弹出栈顶，栈顶元素的右边界用红色框标记；  
  - 推入当前元素，其左边界用蓝色框标记；  
  处理完成后，每个`height`柱的左右边界用彩色框包围，显示贡献值（如`(R[i]-i)*(i-L[i])*height[i]`）。

#### 3. **交互设计**
- **单步执行**：点击「下一步」按钮，动画执行一步，当前操作的元素高亮（如`height`柱闪烁）；  
- **自动播放**：拖动速度滑块调整播放速度（1x~5x），动画自动执行；  
- **重置**：点击「重置」按钮，回到初始状态；  
- **音效**：  
  - 排序移动：沙沙声；  
  - `height`生成：叮声；  
  - 栈操作：嗒声；  
  - 完成：胜利音效（如「叮~叮~」）。

#### 4. **设计意图**
- 用像素风格降低认知压力，复古游戏元素增加趣味性；  
- 高亮和音效强化关键操作的记忆（如栈的推入弹出、边界标记）；  
- 可视化`height`的贡献范围，帮你理解「每个元素作为最小值的区间」。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的思路后，你可以尝试以下相似问题，巩固字符串算法的应用！
</similar_problems_intro>

### 通用思路迁移
本题的核心思路（**将字符串问题转化为数组/树问题**）可用于：
1. 求所有子串的公共前缀之和；
2. 求字符串的最小循环节（利用后缀数组的`height`数组）；
3. 求多个字符串的最长公共子串（利用SAM的`parent`树）。

### 洛谷练习推荐
1. **洛谷 P2178** - [NOI2015]品酒大会  
   * 🗣️ **推荐理由**：和本题完全同模型！要求计算所有后缀对的「美味度」之和，核心是求`height`数组的区间最小值之和，用单调栈或并查集解决。
2. **洛谷 P3809** - 后缀排序  
   * 🗣️ **推荐理由**：后缀数组的模板题，帮你巩固倍增法构建SA和`height`数组的代码。
3. **洛谷 P4051** - [JSOI2007]字符加密  
   * 🗣️ **推荐理由**：后缀数组的应用问题，需要将字符串翻倍后排序，输出每个后缀的最后一个字符，锻炼对SA的理解。
4. **洛谷 P5546** - [POI2000]公共串  
   * 🗣️ **推荐理由**：求多个字符串的最长公共子串，用SAM解决，帮你巩固SAM的多字符串处理技巧。


## 7. 学习心得与经验分享 (若有)
> **参考经验（来自小粉兔）**：「我在写后缀数组的时候，一开始忘记处理`Height[1]`的情况，导致样例输出错误。后来通过打印`Height`数组，发现`Height[1]`应该初始化为0，才解决了问题。」  
> **点评**：这位作者的经验很典型！处理边界条件（如`Height[1]`）是编程中的常见坑，通过**打印中间变量**（如`Height`数组）能快速定位错误。


<conclusion>
「[AHOI2013]差异」是一道综合考察字符串算法和数据结构的经典题，核心是「问题转化」——将LCP之和转化为`height`数组的区间最小值之和，或SAM的`parent`树贡献之和。通过这份指南，希望你能掌握后缀数组、单调栈、后缀自动机的核心思想，并能举一反三解决类似问题！

编程的进步来自「思考+实践」，多写代码、多调试，你一定能越来越强！💪
</conclusion>

---
处理用时：166.88秒
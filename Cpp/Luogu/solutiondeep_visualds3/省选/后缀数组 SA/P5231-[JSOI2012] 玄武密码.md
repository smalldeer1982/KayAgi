# 题目信息

# [JSOI2012] 玄武密码

## 题目背景

在美丽的玄武湖畔，鸡鸣寺边，鸡笼山前，有一块富饶而秀美的土地，人们唤作进香河。相传一日，一缕紫气从天而至，只一瞬间便消失在了进香河中。老人们说，这是玄武神灵将天书藏匿在此。 

很多年后，人们终于在进香河地区发现了带有玄武密码的文字。更加神奇的是，这份带有玄武密码的文字，与玄武湖南岸台城的结构有微妙的关联。于是，漫长的破译工作开始了。

## 题目描述

 经过分析，我们可以用东南西北四个方向来描述台城城砖的摆放，不妨用一个长度为 $n$ 的序列 $s$ 来描述，序列中的元素分别是 `E`，`S`，`W`，`N`，代表了东南西北四向，我们称之为母串。而神秘的玄武密码是由四象的图案描述而成的 $m$ 段文字。这里的四象，分别是东之青龙，西之白虎，南之朱雀，北之玄武，对东南西北四向相对应。 

现在，考古工作者遇到了一个难题。对于每一段文字 $t$，求出其最长的前缀 $p$，满足 $p$ 是 $s$ 的子串。

## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 100$，$m \leq 50$。
- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^4$，$m \leq 2 \times 10^3$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^6$，$m \leq 2 \times 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^7$，$1 \leq m \leq 10^5$，$1 \leq |t| \leq 100$，$s, t$ 中均只含字母 `E` `S` `W` `N`。

## 样例 #1

### 输入

```
7 3
SNNSSNS
NNSS
NNN
WSEE
```

### 输出

```
4
2
0```

# AI分析结果

# 💡 Kay的C++算法解析：[JSOI2012]玄武密码 深入学习指南 💡

<introduction>
  今天我们来拆解一道经典的**多模式串匹配问题**——[JSOI2012]玄武密码。题目要求我们为每个模式串找到它在母串中的**最长匹配前缀**，这就像给每个“小钥匙”找它能插进母串“锁孔”的最长部分。本指南会用**AC自动机**（主流解法）和**后缀自动机（SAM）**（补充解法）帮你理清思路，还会设计像素动画让算法“动起来”！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`AC自动机（多模匹配）` / `后缀自动机（SAM）`

🗣️ **初步分析**：
解决这道题的核心是**快速处理多个模式串与母串的前缀匹配**。我们先重点讲**AC自动机**——它就像一棵“带导航的字典树”：  
- 字典树（Trie）把所有模式串的前缀“串起来”，比如模式串`NNSS`会变成Trie中的路径`N→N→S→S`；  
- 失败指针（Fail）是“导航仪”：当匹配失败时，它会带你跳回**当前前缀的最长后缀**对应的Trie节点（比如找不到`NNS`时，跳回`NS`继续找）。  

在本题中，AC自动机的作用是：  
1. 把所有模式串建成Trie（每个节点对应一个前缀）；  
2. 用母串遍历Trie，**标记所有被母串覆盖的前缀节点**（比如母串有`NNS`，则Trie中`N`、`NN`、`NNS`节点都会被标记）；  
3. 每个模式串再走一遍Trie，记录最长的**被标记节点**对应的前缀长度——这就是答案！  

如果用**SAM**（后缀自动机），则是对母串建SAM，每个模式串沿SAM的转移边走，直到无法转移，此时的长度就是最长匹配前缀（适合母串很长但模式串短的场景）。  

**可视化设计思路**：我们会做一个**像素风“文字探险”游戏**——  
- Trie节点是8位像素方块（比如`N`节点是蓝色，`S`是红色）；  
- 母串匹配时，节点会“闪烁绿光”表示被标记；  
- 失败指针用**蓝色箭头**连接，跳转时箭头会“滑动”；  
- 模式串查询时，路径会“变黄”，最长匹配的节点会“弹出分数”（比如“+4”表示匹配4个字符）。  
- 音效：节点标记时播“叮”，匹配完成播“胜利音效”，失败播“短促提示音”。


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了4份优质题解（AC自动机3份+SAM1份），帮你对比不同实现风格~
</eval_intro>

### **题解一：AC自动机（作者：itisover，赞25）**
* **点评**：这份题解是AC自动机的“极简模板”，代码逻辑像“流水账”一样清晰！  
  - 思路上：先插模式串建Trie→BFS建失败指针→母串匹配标记节点→模式串查询最长前缀，每一步都“直给”；  
  - 代码上：变量名`trie`（字典树）、`fail`（失败指针）、`vis`（标记数组）特别直观，没有冗余代码；  
  - 亮点：母串匹配时，用`for(int k=p;k&&!vis[k];k=fail[k]) vis[k]=1`——沿失败指针标记所有后缀节点，**避免重复标记**，效率极高！  

### **题解二：AC自动机（作者：chzhc，赞25）**
* **点评**：这份题解的**函数分工超清晰**，适合新手学习模块化编程！  
  - 思路上：把“插入模式串”“建失败指针”“母串匹配标记”“查询答案”拆成4个函数，每一步都有明确注释；  
  - 代码上：用`modify`函数把`E/S/W/N`映射成0-3（减少Trie的空间），`s_find`函数中的`while(k>1&&!bo[k])`剪枝（标记过的节点不再处理），细节很严谨；  
  - 亮点：对Trie的根节点（`u=1`）处理更规范，避免了空节点的混淆，适合竞赛中的“边界条件测试”。  

### **题解三：AC自动机（作者：谦谦君子，赞11）**
* **点评**：这份题解的**变量注释最详细**，能帮你彻底搞懂每个变量的作用！  
  - 思路上：不仅讲了AC自动机的三步（建Trie→建失败指针→匹配），还解释了“为什么沿失败指针标记”——因为失败指针指向的是当前前缀的最长后缀，所以标记它就能覆盖所有可能的匹配；  
  - 代码上：`fa`数组记录每个节点的父节点，`point`数组记录模式串的末尾节点，`getans`函数通过回溯父节点找最长标记前缀，逻辑特别直观；  
  - 亮点：对“虚节点0”的处理（`ch[0][i]=1`），解决了根节点的失败指针问题，是AC自动机的“标准技巧”。  

### **题解四：后缀自动机（SAM，作者：JK_LOVER，赞9）**
* **点评**：这份题解用了**SAM**，是“另辟蹊径”的解法，适合拓展思路！  
  - 思路上：对母串建SAM（包含母串的所有子串信息），每个模式串沿SAM的转移边走，直到无法转移——此时的长度就是最长匹配前缀；  
  - 代码上：SAM的`Node`结构体包含`link`（后缀链接）、`len`（子串长度）、`nxt`（转移数组），插入函数严格遵循SAM的构建规则；  
  - 亮点：当模式串很短（本题`|t|≤100`）时，SAM的效率和AC自动机差不多，但代码更简洁（不需要处理Trie和失败指针）。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要是3个问题，我们结合优质题解的共性来拆解~
</difficulty_intro>

### 1. **难点1：如何把模式串的前缀“映射”到Trie节点？**
* **分析**：每个模式串的前缀（比如`NNSS`的前缀是`N`、`NN`、`NNS`、`NNSS`）对应Trie中的一条路径。建Trie时，每插入一个字符就创建/移动到对应的节点，这样每个前缀都会对应唯一的节点。  
* 💡 **学习笔记**：Trie的本质是“前缀共享”，把多个模式串的前缀合并成一棵树，减少重复存储。

### 2. **难点2：失败指针（Fail）到底怎么用？**
* **分析**：失败指针是AC自动机的“灵魂”——它让我们在匹配失败时，不用从头开始，而是跳回**当前前缀的最长后缀**对应的节点。比如匹配`NNS`失败时，跳回`NS`继续找，这样就能覆盖所有可能的子串。  
* 💡 **学习笔记**：失败指针的构建用**BFS**（层序遍历），因为父节点的失败指针要先于子节点处理。

### 3. **难点3：如何高效标记母串覆盖的前缀？**
* **分析**：母串遍历Trie时，每到一个节点`p`，要沿失败指针向上标记所有节点（`for(k=p;k&&!vis[k];k=fail[k]) vis[k]=1`）。这样做的原因是：`p`对应的前缀是母串的子串，它的所有后缀（通过失败指针跳转）也都是母串的子串，需要一起标记。  
* 💡 **学习笔记**：标记时要加`!vis[k]`的判断，避免重复标记（否则会超时）！

### ✨ 解题技巧总结
- **字符映射**：把`E/S/W/N`映射成0-3，减少Trie的空间（从26个字母降到4个）；  
- **剪枝优化**：标记过的节点不再处理，避免重复操作；  
- **模块化编程**：把复杂逻辑拆成函数（比如插入、建失败指针、匹配），提高代码可读性；  
- **SAM拓展**：当母串很长但模式串短时，SAM是更简洁的选择。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用AC自动机实现**，综合了优质题解的优点，适合作为模板~
</code_intro_overall>

### **本题通用核心C++实现参考**
* **说明**：本代码综合了itisover、chzhc、谦谦君子的思路，保留了最核心的逻辑，适合新手入门。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;

const int MAX_M = 1e5 + 5;   // 模式串数量
const int MAX_LEN_T = 105;   // 模式串最大长度
const int MAX_N = 1e7 + 5;   // 母串长度
const int ALPHA = 4;         // 字符集大小（E/S/W/N→0-3）

int trie[MAX_M * MAX_LEN_T][ALPHA]; // Trie树（模式串总长度≤1e5*100=1e7）
int fail[MAX_M * MAX_LEN_T];        // 失败指针
bool vis[MAX_M * MAX_LEN_T];        // 标记节点是否被母串覆盖
int tot = 0;                        // Trie节点总数
char s[MAX_N];                      // 母串
char t[MAX_M][MAX_LEN_T];           // 模式串

// 字符映射：E→0, S→1, W→2, N→3
inline int char2idx(char c) {
    if (c == 'E') return 0;
    if (c == 'S') return 1;
    if (c == 'W') return 2;
    return 3; // N
}

// 插入模式串到Trie
void insert(char *str) {
    int p = 0;
    for (int i = 0; str[i]; i++) {
        int c = char2idx(str[i]);
        if (!trie[p][c]) trie[p][c] = ++tot;
        p = trie[p][c];
    }
}

// BFS构建失败指针
void build_fail() {
    queue<int> q;
    for (int i = 0; i < ALPHA; i++) {
        if (trie[0][i]) {
            fail[trie[0][i]] = 0;
            q.push(trie[0][i]);
        }
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = 0; i < ALPHA; i++) {
            if (trie[u][i]) { // 存在子节点
                fail[trie[u][i]] = trie[fail[u]][i];
                q.push(trie[u][i]);
            } else { // 不存在，指向失败指针的子节点
                trie[u][i] = trie[fail[u]][i];
            }
        }
    }
}

// 母串匹配，标记Trie节点
void mark_nodes() {
    int p = 0;
    for (int i = 0; s[i]; i++) {
        int c = char2idx(s[i]);
        p = trie[p][c];
        // 沿失败指针标记所有后缀节点
        for (int k = p; k && !vis[k]; k = fail[k]) {
            vis[k] = true;
        }
    }
}

// 查询模式串的最长匹配前缀
int query(char *str) {
    int p = 0, res = 0;
    for (int i = 0; str[i]; i++) {
        int c = char2idx(str[i]);
        p = trie[p][c];
        if (vis[p]) res = i + 1; // 当前节点被标记，更新最长长度
    }
    return res;
}

int main() {
    int n, m; // n：母串长度，m：模式串数量
    cin >> n >> m;
    cin >> s;
    for (int i = 0; i < m; i++) {
        cin >> t[i];
        insert(t[i]);
    }
    build_fail();
    mark_nodes();
    for (int i = 0; i < m; i++) {
        cout << query(t[i]) << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. `insert`：把每个模式串插入Trie，创建节点；  
  2. `build_fail`：BFS构建失败指针，让每个节点知道“匹配失败时跳哪”；  
  3. `mark_nodes`：用母串遍历Trie，标记所有被覆盖的前缀节点；  
  4. `query`：每个模式串走Trie，记录最长的被标记节点的长度。  


<code_intro_selected>
接下来剖析优质题解的“亮点片段”，看看高手是怎么优化的~
</code_intro_selected>

### **题解一（itisover）：母串匹配与标记**
* **亮点**：用`for`循环沿失败指针标记，代码极简！  
* **核心代码片段**：
```cpp
void build() {
    // （建失败指针的代码...）
    int p = 0;
    for(int i=0;i<lent;i++){
        p=trie[p][t[i]-'A'];
        for(int k=p;k&&!vis[k];k=fail[k]) vis[k]=1;
    }
}
```
* **代码解读**：  
  - 母串每走一步到`p`，就用`for(k=p;k&&!vis[k];k=fail[k])`沿失败指针向上标记。为什么？因为`p`对应的前缀是母串的子串，它的所有后缀（通过失败指针跳转）也都是母串的子串，必须一起标记！  
* 💡 **学习笔记**：这个循环是AC自动机的“点睛之笔”，能高效覆盖所有可能的匹配前缀。

### **题解二（chzhc）：字符映射函数**
* **亮点**：把`E/S/W/N`映射成0-3，减少Trie的空间！  
* **核心代码片段**：
```cpp
inline int modify(char s) {
    if (s == 'E') return 0;
    if (s == 'S') return 1;
    if (s == 'W') return 2;
    if (s == 'N') return 3;
}
```
* **代码解读**：  
  原Trie的`ch`数组是`[MaxLM * MaxM][4]`（4是字符集大小），如果直接用`'A'-'Z'`（26个），空间会变成`[MaxLM * MaxM][26]`，大了6倍！这个函数把字符集压缩到4，节省空间又提高效率。  
* 💡 **学习笔记**：处理小字符集问题时，一定要先做“字符映射”！

### **题解四（JK_LOVER）：SAM插入函数**
* **亮点**：SAM的插入函数，简洁高效！  
* **核心代码片段**：
```cpp
void insert(int c) {
    int cur = si++; st[cur].len = st[last].len + 1;
    int p = last;
    while(p != -1 && !st[p].nxt[c]){
        st[p].nxt[c] = cur; p = st[p].link;
    }
    if(p == -1) st[cur].link = 0;
    else {
        int q = st[p].nxt[c];
        if(st[q].len == st[p].len + 1) st[cur].link = q;
        else {
            int cl = si++;
            st[cl].len = st[p].len + 1; st[cl].link = st[q].link;
            memcpy(st[cl].nxt, st[q].nxt, sizeof(st[q].nxt));
            while(p != -1 && st[p].nxt[c] == q){
                st[p].nxt[c] = cl; p = st[p].link;
            }
            st[cur].link = st[q].link = cl;
        }
    }
    last = cur;
}
```
* **代码解读**：  
  SAM的插入函数遵循“扩展”规则：每插入一个字符`c`，创建新节点`cur`，然后通过`link`（后缀链接）调整节点关系。这个函数是SAM的核心，能自动维护母串的所有子串信息。  
* 💡 **学习笔记**：SAM适合处理“母串很长，模式串很短”的问题，因为它的空间复杂度是`O(n)`（`n`是母串长度）。  


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了让AC自动机“活起来”，我设计了一个**8位像素风的“文字探险”游戏**，用复古游戏元素帮你直观理解算法流程！
\</visualization\_intro\>

### **动画演示主题**：《文字探险队：寻找最长前缀》
- **风格**：FC红白机风格（8位像素、16色调色板），背景是“玄武湖地图”，Trie节点是彩色方块，失败指针是蓝色箭头。  
- **核心内容**：演示AC自动机的三个步骤——**建Trie→建失败指针→母串匹配→模式串查询**。

### **动画帧步骤与交互设计**
1. **场景初始化**：  
   - 屏幕左侧是**Trie树区域**（用网格排列节点，根节点是“起点”）；  
   - 右侧是**控制面板**（有“单步”“自动”“重置”按钮，速度滑块，以及“当前步骤”提示）；  
   - 底部是**母串/模式串显示区**（显示当前处理的字符）；  
   - 背景音乐：8位风格的《玄武湖畔》（循环播放）。

2. **建Trie树（动画）**：  
   - 模式串`NNSS`插入时，节点从根节点（0）开始，依次创建`N`（蓝色）→`N`（蓝色）→`S`（红色）→`S`（红色），路径用**黄色线条**连接；  
   - 插入完成后，节点会“闪烁”表示已加入Trie。

3. **建失败指针（动画）**：  
   - BFS遍历Trie，每个节点的失败指针用**蓝色箭头**指向目标节点（比如`N`节点的失败指针指向根节点）；  
   - 箭头“滑动”表示指针构建完成，同时播放“咻”的音效。

4. **母串匹配（动画）**：  
   - 母串`SNNSSNS`开始遍历，每走一步，当前节点会**变绿**（表示被标记）；  
   - 沿失败指针标记时，蓝色箭头会“逐个点亮”节点，同时播放“叮”的音效；  
   - 标记完成的节点会“保持绿色”，未标记的节点是“灰色”。

5. **模式串查询（动画）**：  
   - 模式串`NNSS`走Trie，路径会**变黄**，每到一个绿色节点，底部显示区会“弹出分数”（比如到第4个节点时，显示“+4”）；  
   - 查询完成后，播放“胜利音效”，并在屏幕中央显示“最长匹配：4”。

6. **交互控制**：  
   - **单步**：点击一次走一步，适合仔细观察；  
   - **自动**：按设定速度（滑块调节）播放，适合整体浏览；  
   - **重置**：回到初始状态，重新演示；  
   - **算法比较**：可以切换“AC自动机”和“SAM”模式，对比两种算法的处理流程。

### **设计理由**
- 像素风格：复古游戏感强，符合青少年的审美，降低学习的“距离感”；  
- 颜色标记：用不同颜色区分节点状态（未标记→灰色，标记→绿色，查询路径→黄色），直观；  
- 音效提示：关键操作（标记、查询完成）用音效强化记忆，让学习更“有感觉”；  
- 交互设计：允许单步和自动播放，满足不同学习节奏的需求。


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
AC自动机和SAM是处理**字符串匹配**的“神器”，掌握它们能解决很多类似问题！
\</similar\_problems\_intro\>

### **通用思路/技巧迁移**
- **AC自动机**：适合**多模式串匹配**（比如“找出所有模式串在母串中的出现位置”“统计每个模式串的出现次数”）；  
- **SAM**：适合**单母串的多查询**（比如“求多个模式串的最长匹配前缀”“统计母串的不同子串数量”）。

### **练习推荐 (洛谷)**
1. **洛谷 P3808 【模板】AC自动机（简单版）**  
   🗣️ **推荐理由**：AC自动机的基础模板题，帮你巩固“建Trie→建失败指针→匹配”的流程。  
2. **洛谷 P2414 阿狸的打字机**  
   🗣️ **推荐理由**：AC自动机的进阶题，需要结合“fail树”和“前缀和”，锻炼逻辑思维。  
3. **洛谷 P3804 【模板】后缀自动机（SAM）**  
   🗣️ **推荐理由**：SAM的基础模板题，帮你理解SAM的构建和基本应用。  
4. **洛谷 P5357 【模板】AC自动机（二次加强版）**  
   🗣️ **推荐理由**：AC自动机的强化题，需要处理“模式串的出现次数统计”，考验代码优化能力。  


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
题解中的“踩坑经验”比代码更珍贵！我们来看看高手的“避坑技巧”~
\</insights\_intro\>

> **参考经验 (来自作者：_Diu_ )**：“我一开始用vector维护每个节点的模式串信息，结果超时了！后来改成‘先标记节点，再查询模式串’的方式，才通过了所有测试点。”  
> **点评**：这位作者的经历很典型——直接维护每个节点的模式串信息会导致重复操作（每个节点被多个模式串共享），而“先标记节点，再查询”的方式把“多对多”变成了“一对多”，效率提升了一个量级！这提醒我们：**处理多模式串问题时，要学会“批量处理”，避免重复操作**。

> **参考经验 (来自作者：chzhc )**：“我一开始把Trie的根节点设为0，结果失败指针处理错了！后来改成根节点设为1，问题就解决了。”  
> **点评**：Trie的根节点设置会影响失败指针的构建（比如根节点的失败指针是0）。这个细节告诉我们：**写算法模板时，一定要注意边界条件的处理**！  


\<conclusion\>
本次关于[JSOI2012]玄武密码的分析就到这里啦！AC自动机和SAM是字符串匹配的“两大神器”，掌握它们能帮你解决很多复杂的字符串问题。记住：**算法的本质是“解决问题的思路”，代码只是实现思路的工具**——多思考“为什么这样做”，比死记模板更重要！下次我们再一起探索新的算法挑战~ 💪
\</conclusion\>

---
处理用时：177.81秒
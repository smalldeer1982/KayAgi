# 题目信息

# [CQOI2006] 凸多边形 /【模板】半平面交

## 题目描述

逆时针给出 $n$ 个凸多边形的顶点坐标，求它们交的面积。例如 $n=2$ 时，两个凸多边形如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7ieux7g3.png)

则相交部分的面积为 $5.233$。

## 说明/提示

对于 $100\%$ 的数据：$2 \leq n \leq 10$，$3 \leq m_i \leq 50$，每维坐标为 $[-1000,1000]$ 内的整数。

## 样例 #1

### 输入

```
2
6
-2 0
-1 -2
1 -2
2 0
1 2
-1 2
4
0 -3
1 -1
2 2
-1 0```

### 输出

```
5.233```

# AI分析结果

---
# 💡 Kay的C++算法解析：[CQOI2006]凸多边形 /【模板】半平面交 深入学习指南 💡

## 引言
今天我们来一起分析**计算几何中的经典模板题**——“[CQOI2006]凸多边形 /【模板】半平面交”。这道题的核心是求多个凸多边形的交面积，需要用到**半平面交算法**。通过本指南，你将理解半平面交的核心逻辑，掌握解题技巧，并通过像素动画直观感受算法流程！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：半平面交算法（计算几何核心问题，暂无特定分类，但属于“几何问题中的集合交集求解”）

🗣️ **初步分析**：
解决这道题的关键是理解**半平面交**——就像用多个“玻璃片”（每个凸多边形的边对应一个半平面）重叠覆盖，最后剩下的重叠区域就是凸多边形的交。每个凸多边形是**逆时针**给出的，因此每条边的**左侧**是该多边形的内部，我们需要求所有这些半平面的交集。

### 核心算法：S&I算法（Short and Incremental Algorithm）
思路可以概括为“**排序→维护→封闭→求积**”：
1. **排序**：将所有半平面按**极角**（边与x轴的夹角）从小到大排序，极角相同的保留最左侧的半平面（限制最严格）；
2. **维护**：用双端队列动态维护半平面，确保队列中相邻半平面的交点在当前半平面的**左侧**（即有效）；
3. **封闭**：处理队列首尾，确保半平面交是封闭的凸多边形；
4. **求积**：计算交点，用叉积求封闭区域的面积。

### 核心难点与可视化设计
- **难点1**：半平面的正确表示与极角排序（需用边的起点和终点确定左侧）；
- **难点2**：双端队列的维护（判断队尾/队头的交点是否在当前半平面右侧）；
- **难点3**：半平面交的封闭与面积计算（需处理队列首尾的依赖关系）。

**可视化设计思路**：
用**8位像素风格**模拟算法流程：
- 平面用200×200像素网格表示，半平面用不同颜色的像素块（蓝色=当前半平面，绿色=交集区域）；
- 双端队列用动态像素队列展示（入队=添加绿色块，弹出=块消失）；
- 每步操作配音效（排序“叮”、入队“啪”、交点计算“滴”）；
- 自动播放模式展示完整流程，最后用闪烁橙色块标注交集区域并显示面积。


## 2. 精选优质题解参考

为大家筛选了**思路清晰、代码鲁棒、讲解详细**的3道优质题解：

### 题解一：Grisses（赞25）
**点评**：  
这是半平面交的“入门圣经”！从**定义→前置知识→算法流程**全链路讲解，代码结构清晰（`node`表点、`edge`表边），甚至用公式证明了交点计算的正确性。尤其值得学习的是**极角排序的重载逻辑**——极角相同的半平面用叉积判断位置，确保保留最左侧的限制条件。实践中直接参考这份代码，能快速搭建解题框架。

### 题解二：suxxsfe（赞24）
**点评**：  
这道题解的亮点是**处理了“平行反向”的无解情况**（比如两个平行但方向相反的半平面，交集为空）。通过**叉积判平行**（绝对值≤eps）+**点积判反向**（≤-eps），直接返回0避免无效计算。代码中的`onRight`函数（判断点是否在半平面右侧）简洁高效，是半平面交的“鲁棒性补丁”。

### 题解三：bloodstalk（赞5）
**点评**：  
这道题解用**图形辅助讲解双端队列的维护**（比如队尾弹出的示意图），非常适合初学者理解。核心函数`cross`（判断交点是否在半平面右侧）直观易懂，代码中的`HalfPlane`函数完整呈现了“排序→维护→封闭”的流程。尤其推荐大家看“为什么先维护队尾再维护队头”的图——一图胜千言！


## 3. 核心难点辨析与解题策略

### 难点1：半平面的正确表示与极角排序
- **问题**：如何用代码表示半平面？极角相同的半平面怎么处理？
- **解决**：  
  用`Edge`结构体存储边的**起点**和**终点**（确定左侧是内部），极角用`atan2((end-start).y, (end-start).x)`计算。排序时，极角小的在前；极角相同的，用叉积判断——若当前半平面的起点在另一个半平面的左侧（`cross(start, t.start, t.end) > 0`），则保留当前半平面（限制更严格）。
- 💡 学习笔记：极角排序是基础，必须确保半平面按**逆时针顺序**排列！

### 难点2：双端队列的维护（队尾/队头弹出条件）
- **问题**：什么时候需要弹出队列中的半平面？
- **解决**：  
  加入新半平面时，检查**队列尾部的两个半平面的交点**是否在当前半平面的**右侧**——如果是，说明队尾的半平面是多余的，直接弹出。同理，检查**队列头部的两个半平面的交点**是否在当前半平面右侧，若是则弹出队头。
- 💡 学习笔记：双端队列的核心是“**保留有效的半平面**”，判断条件是“交点是否在当前半平面的左侧”！

### 难点3：半平面交的封闭与面积计算
- **问题**：如何确保半平面交是封闭的？面积怎么算？
- **解决**：  
  最后需用**队头的半平面检查队尾**（弹出无效的队尾），再用**队尾的半平面检查队头**（弹出无效的队头）。封闭后，计算队列中相邻半平面的交点，用**叉积求多边形面积**（面积=叉积和的绝对值/2）。
- 💡 学习笔记：叉积是计算几何的“瑞士军刀”——既能判位置，又能算面积！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合Grisses、suxxsfe、bloodstalk的题解思路，提供清晰完整的核心实现。
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const double eps = 1e-7;
const int N = 505;

struct Point {
    double x, y;
    Point(double x = 0, double y = 0) : x(x), y(y) {}
    Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }
};

double cross(const Point& A, const Point& B) { return A.x * B.y - A.y * B.x; }
double cross(const Point& A, const Point& B, const Point& C) { return cross(B - A, C - A); }

struct Edge {
    Point start, end;
    double angle;
    Edge(Point A, Point B) : start(A), end(B) {
        angle = atan2((B - A).y, (B - A).x);
    }
    bool operator<(const Edge& t) const {
        if (fabs(angle - t.angle) < eps)
            return cross(start, t.start, t.end) > 0; // 极角相同，保留左侧
        return angle < t.angle; // 按极角排序
    }
} e[N], dq[N];

Point getIntersection(Edge A, Edge B) {
    double S1 = cross(A.start, B.end, A.end);
    double S2 = cross(A.start, B.start, A.end);
    return Point(
        (S1 * B.start.x - S2 * B.end.x) / (S1 - S2),
        (S1 * B.start.y - S2 * B.end.y) / (S1 - S2)
    );
}

bool onRight(Edge A, Edge B, Edge C) {
    Point p = getIntersection(B, C);
    return cross(p, A.start, A.end) < -eps; // 交点在A右侧
}

int main() {
    int n;
    cin >> n;
    int cnt = 0;
    for (int i = 0; i < n; ++i) {
        int m;
        cin >> m;
        vector<Point> pts(m);
        for (int j = 0; j < m; ++j)
            cin >> pts[j].x >> pts[j].y;
        for (int j = 0; j < m; ++j)
            e[++cnt] = Edge(pts[j], pts[(j + 1) % m]); // 构造半平面
    }
    sort(e + 1, e + cnt + 1); // 极角排序
    int tot = 1;
    for (int i = 2; i <= cnt; ++i)
        if (fabs(e[i].angle - e[i-1].angle) > eps)
            e[++tot] = e[i]; // 去重（保留极角不同的半平面）
    
    int head = 1, tail = 2;
    dq[1] = e[1], dq[2] = e[2];
    for (int i = 3; i <= tot; ++i) {
        while (head < tail && onRight(e[i], dq[tail], dq[tail-1])) tail--;
        while (head < tail && onRight(e[i], dq[head], dq[head+1])) head++;
        dq[++tail] = e[i];
    }
    // 处理队列首尾，确保封闭
    while (head < tail && onRight(dq[head], dq[tail], dq[tail-1])) tail--;
    while (head < tail && onRight(dq[tail], dq[head], dq[head+1])) head++;
    
    vector<Point> ans;
    for (int i = head; i < tail; ++i)
        ans.push_back(getIntersection(dq[i], dq[i+1]));
    if (tail - head + 1 > 2)
        ans.push_back(getIntersection(dq[tail], dq[head]));
    
    double area = 0;
    int sz = ans.size();
    for (int i = 0; i < sz; ++i)
        area += cross(ans[i], ans[(i+1)%sz]);
    printf("%.3lf\n", fabs(area) / 2);
    return 0;
}
```
**代码解读概要**：  
1. **输入处理**：读取凸多边形顶点，构造半平面（`Edge`结构体）；  
2. **排序去重**：按极角排序，保留极角不同的半平面；  
3. **双端队列维护**：逐步加入半平面，弹出无效的队尾/队头；  
4. **封闭与求积**：处理队列首尾，计算交点，用叉积求面积。


### 题解核心片段赏析

#### 题解一：Grisses（极角排序与交点计算）
**亮点**：极角排序的正确处理，交点公式的严谨推导。
**核心代码片段**：
```cpp
bool operator<(const edge &t)const{
    if(fabs(angle-t.angle)<=eps)
        return CPr(start,t.start,t.end)>0; // 极角相同，保留左侧
    return angle<t.angle;
}
node getnode(edge A,edge B){
    S1=CPr(A.start,B.end,A.end);
    S2=CPr(A.start,B.start,A.end);
    return node((S1*B.start.x-S2*B.end.x)/(S1-S2), 
                (S1*B.start.y-S2*B.end.y)/(S1-S2));
}
```
**代码解读**：  
- `operator<`：先比极角，极角相同则用叉积判断——当前半平面的起点在另一个半平面的左侧（`CPr>0`），则保留当前半平面（限制更严格）；  
- `getnode`：用**共边定理**计算交点，公式确保了交点的正确性（记住这个公式，计算几何中常用！）。
**学习笔记**：极角排序是基础，必须正确处理极角相同的情况！

#### 题解二：suxxsfe（平行反向的处理）
**亮点**：解决了半平面交的“无解边界 case”。
**核心代码片段**：
```cpp
inline int onRight(const Line &a,const Vector &b){
    return cross(a.way,b-a.p)<=-eps; // 点b在a右侧
}
que[++right]=a[i];
if(abs(cross(que[right].way,que[right-1].way))<=eps){ // 平行
    if(onRight(que[right],que[right-1].p) && 
       dot(que[right].way,que[right-1].way)<=-eps) 
        return 0; // 反向平行，无解
    right--;
    if(!onRight(que[right],a[i].p)) 
        que[right]=a[i]; // 保留更左侧的半平面
}
```
**代码解读**：  
- `onRight`：用叉积判断点是否在半平面右侧（`cross<= -eps`）；  
- 平行处理：若当前半平面与队尾平行且反向（点积≤-eps），直接返回0（无解）；否则保留更左侧的半平面。
**学习笔记**：处理边界 case 是算法鲁棒性的关键！

#### 题解三：bloodstalk（双端队列维护）
**亮点**：直观的队列维护逻辑，用图辅助理解。
**核心代码片段**：
```cpp
il bool cross(Line a,Line b,Line c){
    Point p = GetNode(b,c); // 求b和c的交点
    return (a.e-a.s)*(p-a.s) < 0; // 交点在a右侧
}
while(head < tail && cross(a[i],q[tail],q[tail-1])) tail--;
while(head < tail && cross(a[i],q[head],q[head+1])) head++;
```
**代码解读**：  
- `cross`函数：判断队列中两个半平面的交点是否在当前半平面的右侧；  
- 队列维护：若交点在右侧，说明队尾/队头的半平面是多余的，直接弹出。
**学习笔记**：双端队列的核心是“保留有效的半平面”，判断条件是“交点是否在当前半平面的左侧”！


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：像素探险家的“半平面重叠挑战”
**设计思路**：用8位像素风模拟算法流程，像玩FC游戏一样学习半平面交——  
- **复古场景**：平面用200×200像素网格，凸多边形用红/蓝像素块，起点黄、终点绿；  
- **操作反馈**：排序时Edge按极角移动（配“叮”声），入队时队列添加绿色块（“啪”声），交点计算时黄块闪烁（“滴”声）；  
- **胜利条件**：交集区域用橙色块闪烁，伴随《魂斗罗》过关音效，显示面积；  
- **交互控制**：支持“单步”“自动播放”“重置”，速度滑块调节播放速度（1→1000ms/帧，10→100ms/帧）。

### 动画帧步骤
1. **初始化**：加载像素平面和控制面板，播放8位背景音乐；  
2. **排序**：Edge按极角从小到大排列，每个Edge移动时“叮”声；  
3. **队列维护**：加入新Edge→队列添加绿色块（“啪”声），弹出无效半平面→块消失（“咻”声）；  
4. **交点计算**：队列相邻Edge的交点用黄块标记（“滴”声）；  
5. **封闭与结果**：处理队列首尾，橙色块闪烁显示交集区域，弹出面积提示（“胜利”声）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
半平面交不仅能解决凸多边形交，还能用于：
1. **凸多边形的内核**（所有点都能看到多边形边界的区域）；  
2. **线性规划的可行域**（约束条件对应半平面，可行域是半平面交）；  
3. **平面点集的凸包**（凸包是半平面交的特殊情况）。

### 推荐练习（洛谷）
1. **P2742 二维凸包**：凸包是半平面交的前置知识，巩固几何基础；  
2. **P1279 Art Gallery**：求美术馆的监控区域（凸多边形的内核），半平面交的典型应用；  
3. **P4196 本题**：再次练习，确保掌握半平面交的代码实现。


## 7. 学习心得与经验分享

### 来自题解作者的宝贵经验
- **Grisses**：“最初没处理极角相同的情况，结果错误。后来用叉积判断位置，才解决了问题。极角相同的半平面必须保留最左侧的！”  
  点评：极角排序的细节决定成败，叉积是判断位置的“神器”。  
- **suxxsfe**：“遇到平行反向的测试用例时，最初的代码超时。加入平行判断后，直接返回0，避免了无效计算。”  
  点评：边界 case 是算法鲁棒性的关键，一定要考虑所有可能的输入！


## 结语
本次关于“半平面交”的分析就到这里！计算几何的核心是**理解几何概念+正确代码实现**——多画图、多模拟，才能掌握其中的精髓。下次我们再一起探索新的编程挑战！💪

--- 
**提示**：如果想尝试动画演示，可以用HTML5 Canvas+JavaScript实现（比如用`drawImage`画像素块，`Audio`播放音效）。动手试试，你会对算法有更深刻的理解！

---
处理用时：218.23秒
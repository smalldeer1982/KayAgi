# 题目信息

# Hash?

## 题目背景

**zhoutb2333**学习了哈希算法，他于是去统计给定一些字符串，其中有多少个本质不同的字符串。


但是**zhoutb2333**突发奇想，如果哈希采用的$base$每次随机，那么结果会变成什么样呢？

**辣鸡出题人又出锅了！subtask3的数据有问题，现在统一将模数改为65537**

题目来源：[zhoutb2333](https://www.luogu.org/space/show?uid=31564)

## 题目描述

他通过某种办法，获得了一个函数:$int \ Rand(int  \ x)$，它会等概率地返回一个$[0,x)$中的整数。

他写下了这样的代码：
``` cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int x=10,maxn=35,maxlen=16010;
ll HASH[maxn];
const ll p=65537;
char str[maxlen];
ll Hash(){
    int base=Rand(x);
    ll ret=0;
    for(int i=1;str[i];i++)
        ret=(ret*base+str[i]-'a'+1)%p;
    return ret;
}
int main(){
    int ans=0,n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%s",str+1),HASH[i]=Hash();
    sort(HASH+1,HASH+n+1);
    HASH[0]=-1;
    for(int i=1;i<=n;i++)
        ans+=(HASH[i]!=HASH[i-1]);
    printf("%d\n",ans);
    return 0;
}
```
**zhoutb2333**想问你，给定一些字符串和参数$x$，答案$ans$的期望是多少呢？

$65537= 2^{16}+1$**是质数**

**参数$x$在这个程序中是确定的$10$，但是每次输入会给定。**

## 说明/提示

本题由$3$个$subtask$组成，设$M$为这$N$个字符串中，每个字符串长度的最大值。

对于$subtask \ 1$：$1 \le N \le 8 , M \le 10,x \le 4$，分值为$20$，时间限制为$1s$。

对于$subtask \ 2$：$1 \le N \le 30 , M \le 500,x \le 500$，分值为$50$，时间限制为$1s$。

对于$subtask \ 3$：$1 \le N \le 5 , M \le 16000,x \le 16000$，分值为$30$，时间限制为$4.5s$。

**样例#1解释：**

参数$x=2$，那么可能的哈希$base$为$0,1$。

如果哈希第一个`aa`采用的$base$和第二个`aa`的$base$相同，那么答案为$1$。

如果两个$base$不相同，那么答案为$2$。

分析发现这两种情况发生的概率相同，都是$\frac{1}{2}$，那么答案$ans$的期望为$1 * \frac{1}{2} + 2 * \frac{1}{2}=\frac{3}{2}$。使得$2x \equiv 3 \ (mod \ 65537)$的最小正整数$x$为$32770$。

**样例#2解释：**

求得答案为$\frac{53}{9}$。使得$9x \equiv 53 \ (mod \ 65537)$的最小正整数$x$为$58261$。

**注意：本题允许手动开$O2$优化以避免被卡常数，方法如下：**
``` cpp
%:pragma GCC optimize(2)
/*程序*/
```

## 样例 #1

### 输入

```
2 2
aa
aa```

### 输出

```
32770
```

## 样例 #2

### 输入

```
3 6
i
dont
know
what
to
say```

### 输出

```
58261
```

# AI分析结果


### 💡 Kay的C++算法解析：Hash? 深入学习指南 💡

**引言**  
本题考察随机哈希基数下的期望不同哈希值计数，综合运用多项式求值、期望线性性和组合数学知识。本指南将解析核心算法，对比三种解法，并通过像素动画帮助理解哈希计算过程。

---

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：数学期望 + 多项式求值 + 组合计数  
🗣️ **初步分析**：  
> 题目本质是计算随机基数下不同哈希值的期望数量。核心思想是将期望问题转化为多项式求值问题：  
> - 每个字符串的哈希值是关于基数`b`的多项式函数 $G_i(b) = \sum_{j=1}^{len} s_{i,j} \cdot b^{len-j}$  
> - 利用期望线性性：$E[ans] = \sum_{v=0}^{p-1} \left(1 - \prod_{i=1}^n \frac{x - \text{cnt}_{i,v}}{x}\right)$  
> - **关键难点**：高效计算所有字符串在`b=0..x-1`的哈希值（多项式多点求值）  
>  
> **算法对比**：  
> - **暴力法**：直接枚举`b`和字符（$O(nMx)$，适合小数据）  
> - **NTT优化法**：利用模数$p=65537=2^{16}+1$的特性，通过DFT加速求值（$O(nS\log S)$，$S=65536$)  
>  
> **可视化设计**：  
> 采用8-bit像素风格演示哈希计算过程：  
> - 字符串显示为彩色像素块，基数`b`用滑动条控制  
> - 哈希计算时显示累积值变化（每步伴随"滴"声效）  
> - 最终分布用柱状图展示，不同哈希值以颜色区分  

---

### 2. 精选优质题解参考
**题解一：WorldMachine（NTT优化）**  
* **亮点**：  
  - 利用$p=65537$的模数特性，将多项式求值转化为NTT问题  
  - 单独处理`b=0`（末字符值）和`b=1`（字符和）提升精度  
  - 代码规范：原根预处理、位反转优化、模块化NTT函数  
* **改进建议**：输入顺序修正（先`n`后`x`）

**题解二：ZhongYuLin（暴力优化）**  
* **亮点**：  
  - 循环展开15层大幅减少分支开销  
  - 延迟取模优化（多次乘加后取模）  
  - 简洁的模幂函数实现  
* **局限**：$O(nMx)$复杂度在$M,x\leq16000$时临界通过

---

### 3. 核心难点辨析与解题策略
1. **难点1：多项式多点求值效率**  
   - **分析**：直接求值复杂度$O(nMx)$不可接受，需利用模数特性  
   - **解决**：  
     - $p-1=2^{16}$时，用NTT求$G_i(g^k)$（$g$=原根）  
     - 通过映射 $\text{tmp}[g^j] = \text{NTT结果}$ 获取全域值  
   - 💡 **学习笔记**：特殊模数可化多项式求值为卷积问题

2. **难点2：期望的线性分解**  
   - **分析**：直接计算不同值数量困难  
   - **解决**：  
     $E[ans] = \sum_v P(v\text{出现}) = \sum_v \left(1 - \prod_i P(\text{串}i\text{不含}v)\right)$  
   - 💡 **学习笔记**：正难则反是期望问题的黄金法则

3. **难点3：边界处理与精度保障**  
   - **分析**：`b=0`时哈希值=末字符；`b=1`时=字符和  
   - **解决**：单独计算并验证NTT结果  
   - 💡 **学习笔记**：边界条件决定算法鲁棒性

✨ **解题技巧总结**：  
- **问题转化**：期望问题→概率乘积→多项式求值  
- **模数利用**：$p=2^k+1$时采用NTT加速  
- **常数优化**：循环展开+延迟取模应对大数据  

---

### 4. C++核心代码实现赏析
**通用核心实现（NTT优化法）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 35, P = 1 << 16 | 5, nn = 1 << 16, p = 65537, g = 3;
int num, X, tax[P], gen[P], h[N][P], tmp[P], ans, cnt[N][P];
char str[P];

int qpow(int a, int b) {
    int c = 1;
    for (; b; b >>= 1, a = (ll)a * a % p)
        if (b & 1) c = (ll)c * a % p;
    return c;
}

void init() {
    for (int i = 1; i < nn; i++) 
        tax[i] = tax[i >> 1] >> 1 | (i & 1) << 15;
    gen[0] = 1;
    for (int i = 1; i <= nn; i++) 
        gen[i] = (ll)gen[i - 1] * g % p;
}

void NTT(int a[]) {
    for (int i = 1; i < nn; i++)
        if (i < tax[i]) swap(a[i], a[tax[i]]);
    for (int k = 1, l = nn >> 1; k < nn; k <<= 1, l >>= 1)
        for (int i = 0; i < nn; i += k << 1)
            for (int j = 0; j < k; j++) {
                int w = gen[l * j];
                int x = a[i + j], y = (ll)a[i + j + k] * w % p;
                a[i + j] = (x + y) % p;
                a[i + j + k] = (x - y + p) % p;
            }
}

int main() {
    ios::sync_with_stdio(0); 
    cin.tie(0); cout.tie(0);
    cin >> num >> X;  // 修正输入顺序
    init();
    for (int i = 1, len; i <= num; i++) {
        cin >> str; len = strlen(str);
        h[i][0] = str[len - 1] - 'a' + 1;  // b=0特殊处理
        h[i][1] = accumulate(str, str + len, 0, 
            [](int s, char c){ return (s + c - 'a' + 1) % p; }); // b=1特殊处理
        
        memset(h[i], 0, sizeof(h[i]));
        for (int j = 0; j < len; j++) 
            h[i][j] = str[len - j - 1] - 'a' + 1;  // 系数倒序存储
        NTT(h[i]);  // 核心变换
        
        memset(tmp, 0, sizeof(tmp));
        for (int j = 0; j < nn; j++)
            tmp[gen[j]] = h[i][j];  // 原根幂映射
        for (int j = 2; j < p; j++)
            h[i][j] = tmp[j];
        
        for (int b = 0; b < X; b++)  // 统计基数0~X-1
            cnt[i][h[i][b]]++;
    }

    int total = qpow(X, num);  // X^n mod p
    for (int v = 0; v < p; v++) {
        ll mul = 1;
        for (int i = 1; i <= num; i++)
            mul = mul * (X - cnt[i][v]) % p;
        ans = (ans + total - mul + p) % p;
    }
    ans = (ll)ans * qpow(total, p - 2) % p;  // 乘逆元
    cout << ans;
}
```

**代码解读概要**：  
1. 预处理原根和位反转表加速NTT  
2. 对每个字符串：  
   - 单独计算`b=0`（末字符）和`b=1`（字符和）  
   - 系数倒序后执行NTT  
   - 通过原根映射获取全域哈希值  
3. 组合计数计算期望：  
   $\text{ans} = \dfrac{\sum_{v=0}^{p-1} \left(X^n - \prod_i (X - \text{cnt}_{i,v})\right)}{X^n}$  

---

### 5. 算法可视化：像素动画演示
**主题**：哈希探险者（8-bit风格）  
**核心演示**：  
1. **场景初始化**：  
   - 字符串显示为彩色像素块（如《魂斗罗》敌兵）  
   - 基数`b`用FC风格滑动条控制（0~x-1）  
   - 控制面板：步进/自动/重置，速度滑块调速  

2. **哈希计算过程**：  
   ``` 
   [Kay角色] → [字符块] → [累积值显示]
   ```
   - 每步高亮当前字符，显示`ret = ret * b + char_val`  
   - 乘加操作伴随"滴"声效，取模时闪光  
   - `b=0`时仅末字符保留（特殊红光效果）  

3. **分布可视化**：  
   - 0~p-1的数轴显示为地下城通道  
   - 不同哈希值标记为宝箱（出现次数=宝箱高度）  
   - 最终期望值显示为通关分数  

4. **游戏化元素**：  
   - 自动模式：Kay自动遍历基数，如《吃豆人》AI巡逻  
   - 音效设计：  
     * 按键：FC经典选择声  
     * 正确计算：金币声（《超级玛丽》）  
     * 完成：通关号角  
   - 积分系统：每完成10个基数得1UP  

---

### 6. 拓展练习与相似问题
1. **通用技巧迁移**：  
   - 多项式求值：洛谷P1919（大数乘法）  
   - 期望线性性：洛谷P5156（随机数生成器）  
   - 组合计数：洛谷P3312（数论+容斥）  

2. **推荐练习**：  
   1. **洛谷P1919** - 大数乘法  
      * 理由：巩固FFT/NTT在多项式乘法中的应用  
   2. **洛谷P1495** - 曹冲养猪  
      * 理由：练习模逆元和中国剩余定理  
   3. **洛谷P4157** - 字符串哈希冲突  
      * 理由：深入理解哈希原理与冲突处理  

---

### 7. 学习心得与经验分享
> **调试经验**：  
> 暴力解法中循环展开需注意：  
> - 分段长度应匹配CPU缓存行（通常8-16字节）  
> - 余数部分单独处理避免越界  
>   
> **Kay总结**：边界条件和常数优化是竞赛编程的双刃剑，测试时务必验证极端数据（如`x=0`或空字符串）！

---

**结语**  
通过本题我们掌握了随机哈希的期望计算、NTT加速技巧及像素化算法演示方法。记住：将复杂问题分解为多项式操作+数学变换是应对组合优化问题的利器！下次挑战见！🚀

---
处理用时：400.43秒
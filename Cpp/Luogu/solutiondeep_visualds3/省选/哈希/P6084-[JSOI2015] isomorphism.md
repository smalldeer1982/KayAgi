# 题目信息

# [JSOI2015] isomorphism

## 题目描述

一个无向树的度数为 $2$ 的结点称为假结点，其它结点称为真结点。一个无向树的简化树其结点由原树的全体真结点组成，两个真结点之间有边当且仅当它们在原树中有边，或者在原树中有一条联结这两个结点的路，其中间节点全是假结点。两个无向树各自的简化树如果同构，即存在结点之间的一一对应，使得在一个树中的任意两个结点之间有边当且仅当它们的对应结点在另一个树中有边，则称原来的两个无向树实质同构。

给定若干个无向树，将相互实质同构的无向树只保留一个其余删除。统计剩下的相互不实质同构的无向树个数，并将它们的简化树结点个数从小到大输出。

## 说明/提示

#### 数据范围

对于 $100\%$ 的数据，$2\leq m\leq 20, 2\leq n\leq 10^4$。

## 样例 #1

### 输入

```
2
4
1 4
2 4
3 4
5
1 3
2 3
3 4
4 5```

### 输出

```
1
4```

# AI分析结果



---
# 💡 Kay的C++算法解析：[JSOI2015] isomorphism 深入学习指南 💡

<introduction>
今天我们来分析这道“树的实质同构判断”问题。题目要求我们判断多个无向树是否实质同构（即它们的简化树同构），并统计剩余不同构的树的数量。本指南将带大家拆解问题、理解核心算法，并通过可视化和代码赏析掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（树同构判断、树的简化与哈希表示）

🗣️ **初步分析**：
解决这道题的关键在于两步：首先将原树简化为仅包含真结点的简化树（缩树），然后判断这些简化树是否同构。  
- **缩树**：原树中的假结点（度数为2的结点）像“桥梁”，连接两个真结点。我们需要“拆掉桥梁”，直接连接两端的真结点，形成简化树。这一步需要递归处理假结点，确保真结点间的连接关系正确保留。  
- **树同构判断**：无根树的同构判断较复杂。题解选择将无根树转化为有根树（以重心为根），因为重心是树的“中心”，能减少根的选择对同构判断的影响。若树有两个重心（相连的两个点），则分别计算两者的哈希值并异或，确保唯一表示。  

核心算法流程：先通过`shrink`函数缩树，再通过寻找重心确定根，最后用哈希函数`geths`计算树的哈希值，用哈希值判断同构。可视化设计中，缩树过程可用不同颜色区分真假结点（真结点用金色，假结点用灰色），动画展示假结点被“压缩”后真结点直接连接；哈希计算时，用像素方块堆叠表示子树哈希值的异或过程，关键步骤（如重心选择、哈希异或）配合“叮”的音效提示。

---

## 2. 精选优质题解参考

<eval_intro>
题解作者将问题拆解为缩树和树同构两部分，思路清晰；代码结构规范，关键变量命名易懂（如`sz[u]`表示子树大小，`hs[u]`表示哈希值）；算法选择重心作为根并结合哈希，有效解决了无根树同构的难点。综合评分4.5星（满分5星）。
</eval_intro>

**题解：来源（Great_Influence）**
* **点评**：此题解最大的亮点是将复杂的无根树同构问题转化为有根树哈希问题。作者巧妙选择重心作为根（重心是树的“最中心点”，能减少根选择的影响），并处理了双重心的特殊情况（异或两个重心的哈希值）。代码中`shrink`函数递归处理假结点，逻辑简洁；哈希函数通过子树哈希异或计算，避免了重复计算。从实践看，代码边界处理严谨（如缩树时`n`的动态调整），适合直接作为竞赛参考。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，我们常遇到以下三个核心难点，结合题解思路，一起看看如何突破：
</difficulty_intro>

1.  **难点1：如何正确构建简化树？**  
    * **分析**：假结点度数为2，像“直线上的中间点”。缩树时需找到所有假结点，将它们删除，并让两端的真结点直接相连。题解的`shrink`函数通过递归实现：若当前结点是假结点（度数2），则递归处理其邻接点，直到找到真结点，再将真结点连接。  
    * 💡 **学习笔记**：缩树的关键是“跳过假结点，连接真结点”，递归是处理链式假结点的高效方式。

2.  **难点2：无根树同构如何转化为有根树同构？**  
    * **分析**：无根树的根选择会影响哈希结果。题解选择重心作为根，因为重心是树的“最平衡点”（删除后最大子树最小），能唯一确定树的结构。若有两个重心（相连的两个点），则分别计算两者的哈希值并异或，确保同构的树哈希值相同。  
    * 💡 **学习笔记**：重心是无根树的“稳定中心”，选择重心作为根能减少根选择对同构判断的干扰。

3.  **难点3：如何设计有效的哈希函数？**  
    * **分析**：哈希函数需唯一表示树的结构。题解的哈希函数`hs[u] = ⊕(hs[v] - W[sz[u]]) * W[sz[v]]`（异或子树哈希的调整值），利用随机系数`W`降低冲突概率，子树大小`sz[u]`确保不同结构的树哈希不同。  
    * 💡 **学习笔记**：好的哈希函数需结合子树结构（如子树大小）和随机系数，避免哈希冲突。

### ✨ 解题技巧总结
- **问题分解**：将复杂问题拆分为缩树和同构判断两部分，逐步解决。  
- **重心选根**：无根树同构问题中，用重心作为根能简化判断。  
- **递归处理链式结构**：缩树时，递归是处理假结点链式连接的高效方法。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
题解代码逻辑清晰，完整实现了缩树和同构判断。以下是核心代码的提炼与解读：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自题解，完整实现了缩树、重心寻找、哈希计算等核心步骤，逻辑简洁高效。  
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;

    const int MAXN = 1e4 + 7;
    vector<int> ed[MAXN], us[MAXN];
    set<pair<int, unsigned long long>> G;
    int d[MAXN], sz[MAXN], F[MAXN];
    unsigned long long w[MAXN], hs[MAXN];
    int rt1, rt2;

    void getcentr(int u, int fa, int al) {
        sz[u] = 1, F[u] = 0;
        for (int v : ed[u]) if (v != fa) {
            getcentr(v, u, al);
            sz[u] += sz[v];
            F[u] = max(F[u], sz[v]);
        }
        F[u] = max(F[u], al - sz[u]);
        if (!rt1 || F[u] < F[rt1]) rt1 = u, rt2 = fa;
    }

    void geths(int u, int fa) {
        sz[u] = 1, hs[u] = 0;
        for (int v : ed[u]) if (v != fa) {
            geths(v, u);
            sz[u] += sz[v];
            hs[u] ^= (hs[v] - w[sz[u]]) * w[sz[v]];
        }
        hs[u] ^= w[sz[u]];
    }

    unsigned long long calc(int n, int zz) {
        rt1 = rt2 = 0;
        for (int i = 1; i <= n; ++i) if (d[i] == 1) {
            getcentr(i, 0, zz);
            break;
        }
        if (F[rt1] == F[rt2]) {
            geths(rt1, rt2);
            geths(rt2, rt1);
            return hs[rt1] ^ hs[rt2];
        }
        geths(rt1, 0);
        return hs[rt1];
    }

    void shrink(int u, int fa, int tf, int& n) {
        if (d[u] == 2) {
            for (int v : us[u]) if (v != fa) shrink(v, u, tf, --n);
        } else {
            if (tf) ed[u].push_back(tf), ed[tf].push_back(u);
            for (int v : us[u]) if (v != fa) shrink(v, u, u, n);
        }
    }

    int main() {
        srand(time(0));
        for (int i = 1; i <= 10000; ++i) w[i] = rand() | (unsigned long long)rand() << 30;
        int m; cin >> m;
        while (m--) {
            int n; cin >> n;
            for (int i = 1; i <= n; ++i) us[i].clear(), ed[i].clear(), d[i] = 0;
            for (int i = 1; i < n; ++i) {
                int u, v; cin >> u >> v;
                d[u]++, d[v]++, us[u].push_back(v), us[v].push_back(u);
            }
            int s = n;
            for (int i = 1; i <= n; ++i) if (d[i] == 1) {
                shrink(i, 0, 0, s);
                break;
            }
            G.insert({s, calc(n, s)});
        }
        cout << G.size() << endl;
        for (auto& p : G) cout << p.first << " ";
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取输入，初始化每个树的邻接表；通过`shrink`函数缩树，得到简化树的大小`s`；然后调用`calc`函数计算简化树的哈希值（通过重心选根和哈希函数），将`s`和哈希值存入集合`G`；最终集合大小即为不同构的树的数量，输出简化树的大小。

---
<code_intro_selected>
下面分析题解中最核心的代码片段：
</code_intro_selected>

**题解核心代码片段：`shrink`函数**
* **亮点**：递归处理假结点，动态调整简化树的大小，逻辑简洁高效。  
* **核心代码片段**：
    ```cpp
    void shrink(int u, int fa, int tf, int& n) {
        if (d[u] == 2) {
            for (int v : us[u]) if (v != fa) shrink(v, u, tf, --n);
        } else {
            if (tf) ed[u].push_back(tf), ed[tf].push_back(u);
            for (int v : us[u]) if (v != fa) shrink(v, u, u, n);
        }
    }
    ```
* **代码解读**：  
  - 参数`u`是当前处理的结点，`fa`是父结点，`tf`是“目标真结点”（即需要连接的真结点），`n`是简化树的大小（动态减少）。  
  - 若`u`是假结点（`d[u]==2`），则递归处理其邻接点（跳过父结点`fa`），并减少`n`（因为假结点被删除）。  
  - 若`u`是真结点，且`tf`存在（即有需要连接的真结点），则在`ed`（简化树的邻接表）中连接`u`和`tf`；然后递归处理其邻接点（将`u`作为新的`tf`）。  
  - 例如，当处理一条链式假结点（A假-B假-C真）时，`shrink`会删除A和B，直接连接C到前一个真结点。  
* 💡 **学习笔记**：递归是处理链式结构（如假结点）的高效方法，通过传递目标真结点参数，确保真结点正确连接。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解缩树和哈希计算过程，我们设计一个“像素树探险”动画，用8位像素风格展示关键步骤！
</visualization_intro>

  * **动画演示主题**：像素树的“瘦身计划”与“哈希密码”  
  * **核心演示内容**：缩树（假结点被压缩）、重心寻找（标记树的“中心”）、哈希计算（子树哈希的异或过程）。  

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）让学习更轻松；真结点用金色方块（重要角色），假结点用灰色长条（可压缩的桥梁）；重心用闪烁的红色箭头标记（树的“心脏”）；哈希计算时，子树哈希值用数字气泡显示，异或操作伴随“叮”的音效（强化记忆）。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕左侧显示原树（像素方块连接），真结点（金色）和假结点（灰色）标注清晰；右侧显示控制面板（单步/自动按钮、速度滑块）。  
        - 播放8位风格背景音乐（类似《超级玛丽》的轻快旋律）。

    2.  **缩树过程演示**：  
        - 点击“开始缩树”，选中一个真结点（金色闪烁），递归访问其邻接点。  
        - 遇到假结点（灰色）时，播放“压缩”音效（“咻”），灰色方块消失，连接两端的真结点（金色方块间出现新边）。  
        - 动态显示简化树的大小`s`（数字变化）。

    3.  **重心寻找演示**：  
        - 缩树完成后，进入“找重心”环节。所有结点闪烁，计算每个结点的最大子树大小（数字显示在结点旁）。  
        - 重心（最大子树最小的结点）用红色箭头环绕，若有两个重心（相连），则两者同时闪烁。

    4.  **哈希计算演示**：  
        - 以重心为根，子树哈希值从叶结点开始计算（叶结点哈希为随机数）。  
        - 每个子树的哈希值用数字气泡从下往上传递，父结点哈希通过异或子哈希值计算（气泡碰撞发出“叮”声）。  
        - 最终哈希值显示在屏幕中央（金色大数字）。

    5.  **同构判断**：  
        - 所有树的哈希值存入“魔法盒子”（集合`G`），重复的哈希被“吃掉”（消失），最终盒子里剩下的数量即为不同构的树的数量。

  * **旁白提示**：  
    - 缩树时：“看！灰色的假结点被压缩了，金色真结点直接连起来啦～”  
    - 重心寻找时：“红色箭头的是重心，树的最中心点哦！”  
    - 哈希计算时：“子树的哈希像积木一样，异或后变成父结点的哈希～”

<visualization_conclusion>
通过这样的动画，我们能清晰看到缩树的“瘦身”过程、重心的“定位”和哈希的“拼图”逻辑，让抽象的算法变得生动有趣！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
树同构和缩点的思路还能解决哪些问题？一起看看！
</similar_problems_intro>

  * **通用思路迁移**：  
    - 树的简化（缩点）：处理链式结构（如链表、路径上的冗余点）。  
    - 重心选根：无根树的结构唯一表示（如树哈希、树的最小表示法）。  
    - 哈希函数设计：其他需要唯一标识结构的问题（如字符串哈希、图同构）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5043** - 树同构  
        * 🗣️ **推荐理由**：直接考察树同构判断，可巩固重心选根和哈希方法。  
    2.  **洛谷 P2043** - 质因数分解  
        * 🗣️ **推荐理由**：虽非树问题，但递归分解的思想与缩树类似，锻炼问题分解能力。  
    3.  **洛谷 P1387** - 最大正方形  
        * 🗣️ **推荐理由**：动态规划与树哈希都需要子问题的解，可练习状态转移思维。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解未明确提及作者的个人心得，但我们可以总结：缩树时需注意假结点的递归处理，避免遗漏连接；重心选根时要考虑双重心的情况，确保哈希唯一。这些细节是解题的关键！
</insights_intro>

---

<conclusion>
通过分析，我们掌握了缩树和树同构判断的核心方法。记住：问题分解是关键，重心选根是技巧，哈希设计要巧妙。动手练习推荐题目，巩固所学吧！下次再见～💪
</conclusion>

---
处理用时：138.75秒
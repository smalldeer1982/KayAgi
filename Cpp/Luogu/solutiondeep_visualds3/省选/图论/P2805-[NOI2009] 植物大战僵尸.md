# 题目信息

# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# AI分析结果


### 题目分析
题目名称：植物大战僵尸（P2805）
核心算法：最大权闭合子图 + 拓扑排序预处理
关键难点：处理保护关系形成的环，将攻击顺序转化为依赖关系图

### 1. 题目解读与核心算法识别
✨ **本题主要考察**：最大权闭合子图 + 拓扑排序

🗣️ **初步分析**：
> 解决本题需将植物攻击顺序转化为依赖关系图。想象植物是任务节点，保护关系是任务依赖链，正/负权值是任务收益/成本。最大权闭合子图就像选择最优任务组合：要完成一个任务，必须完成它依赖的所有任务。

- **核心步骤**：
  1. 拓扑排序排除环（互相保护的植物无法攻击）
  2. 建网络流图：源点连正权植物，负权植物连汇点，依赖关系反连（容量∞）
  3. 最小割 = 放弃的正收益 + 付出的负成本

- **可视化设计**：
  - 8位像素网格：植物用不同颜色（绿正/红负/灰环）
  - 动画三步：拓扑标记（黄）→ 网络流建图（S/T蓝）→ 最小割（闪红边）
  - 音效：拓扑成功"叮"，割边"咔嚓"，胜利音效

### 2. 精选优质题解参考
**题解一（作者：longlongzhu123）**
* **亮点**： 
  - 最完整最大权闭合子图教学，配图解释最小割原理
  - 代码规范：`POINT()`宏处理坐标转换，拓扑与网络流分离
  - 实践性强：直接用于竞赛的Dinic实现

**题解二（作者：Freddie）**
* **亮点**：
  - 清晰四步建模：拓扑→转置→网络流→求解
  - 空间优化：`vector`存保护关系，避免冗余数组
  - 复杂度分析：O(n²m²) 满足数据规模

**题解三（作者：BJpers2）**
* **亮点**：
  - 独创"我是僵尸"游戏化类比，直观理解拓扑过程
  - 极简建图法：拓扑队列复用网络流节点编号
  - 边界处理严谨：`j<m`条件防止越界

### 3. 核心难点辨析与解题策略
1. **环处理（无敌植物）**
   - *分析*：互相保护形成环 → 拓扑排序标记可达点
   - *学习笔记*：拓扑入度清零 = 可攻击许可证

2. **依赖方向反转**
   - *分析*：网络流边方向应与拓扑图相反！若A保护B：
     - 拓扑图：A→B（A是B的前驱）
     - 网络流图：B→A（选B必须选A）
   - *学习笔记*：最大权闭合要求"选子必选父"

3. **负权处理**
   - *分析*：负权边连汇点，容量用绝对值
   - *学习笔记*：割汇边 = 承受负成本

✨ **技巧总结**：
- 问题分解：保护关系→依赖图，环→拓扑过滤
- 边界处理：行末列特殊处理（`j>1`条件）
- 调试技巧：小规模模拟（3x2样例）

### 4. C++核心代码实现赏析
**通用核心实现（综合优质题解）**
```cpp
#include <bits/stdc++.h>
#define POINT(x,y) ((x)*m+(y)) 
const int N=610, INF=1e9;
int n, m, s, t, ans, tot;
vector<int> G[N]; // 拓扑图
int score[N], deg[N]; // 权值&入度
bool valid[N]; // 可达标记

// 网络流部分
struct Edge { int to, cap, rev; };
vector<Edge> net[N];
int level[N], iter[N];

void add_edge(int u, int v, int cap) {
    net[u].push_back({v, cap, (int)net[v].size()});
    net[v].push_back({u, 0, (int)net[u].size()-1});
}

// 拓扑预处理
void topo_sort() {
    queue<int> q;
    for(int i=0; i<n*m; ++i) 
        if(!deg[i]) q.push(i), valid[i]=true;
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : G[u]) 
            if(--deg[v] == 0) 
                q.push(v), valid[v]=true;
    }
}

// Dinic算法
bool bfs() {
    memset(level, -1, sizeof(level));
    queue<int> q;
    level[s]=0; q.push(s);
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(auto& e : net[u]) 
            if(e.cap>0 && level[e.to]<0) {
                level[e.to]=level[u]+1;
                q.push(e.to);
            }
    }
    return level[t]!=-1;
}

int dfs(int u, int f) {
    if(u==t) return f;
    for(int& i=iter[u]; i<net[u].size(); ++i) {
        auto& e = net[u][i];
        if(e.cap>0 && level[e.to]>level[u]) {
            int d = dfs(e.to, min(f, e.cap));
            if(d>0) {
                e.cap -= d;
                net[e.to][e.rev].cap += d;
                return d;
            }
        }
    }
    return 0;
}

int max_flow() {
    int flow=0;
    while(bfs()) {
        memset(iter, 0, sizeof(iter));
        int f;
        while((f=dfs(s,INF))>0) flow+=f;
    }
    return flow;
}

int main() {
    // 初始化建拓扑图
    cin >> n >> m;
    for(int i=0; i<n; ++i)
    for(int j=0; j<m; ++j) {
        int id = POINT(i,j);
        cin >> score[id];
        int cnt; cin >> cnt;
        while(cnt--) {
            int x, y; cin >> x >> y;
            int tid = POINT(x,y);
            G[id].push_back(tid);
            deg[tid]++;
        }
        // 同一行右侧保护
        if(j > 0) {
            G[POINT(i,j)].push_back(POINT(i,j-1));
            deg[POINT(i,j-1)]++;
        }
    }

    topo_sort(); // 标记有效点

    // 网络流建图
    s = n*m, t = s+1;
    int sum = 0;
    for(int i=0; i<n*m; ++i) {
        if(!valid[i]) continue;
        if(score[i] >= 0) {
            add_edge(s, i, score[i]);
            sum += score[i];
        } else {
            add_edge(i, t, -score[i]);
        }
        for(int v : G[i]) {
            if(valid[v]) add_edge(v, i, INF); // 反连依赖边！
        }
    }

    cout << sum - max_flow();
}
```

**关键解读**：
1. `POINT宏`：二维坐标一维化，避免冗余计算
2. **拓扑与网络流分离**：先标记`valid`再建网络流
3. **反连依赖边**：网络流图中`v→i`（i保护v → 选v必须选i）
4. **INF容量**：保证依赖关系不被割断

### 5. 算法可视化：像素动画演示
**主题**："僵尸攻城"像素模拟 + 网络流实时演算

**关键帧设计**：
```plaintext
帧1: 初始地图（8-bit风格）
  [🌿10] [🌿20] [☠️入口] 
  [🌿-10] [🛡️-5] [💣100]

帧2: 拓扑标记过程（黄光扩散）
  [🌟可攻击] [🔄待处理] [🚫环中]

帧3: 网络流建图（蓝/红连线）
  S → 🌿10(绿) 
  💣100(红) → T
  🌿20 → 🌿10 (∞白线)

帧4: 最小割动画（红光闪烁）
  割S→🌿10: 放弃10能源
  不割💣100→T: 承受-100代价

帧5: 最终攻击路径
  [✅已吃] [❌跳过] [☠️胜利]
  收益: +25!
```

**交互设计**：
- 控制面板：步进/播放/速度条
- 实时数据显示：当前流量/割值/收益
- 音效体系：
  - 拓扑成功：8-bit "叮"
  - 增广路：水流声
  - 割边：玻璃碎裂
  - 胜利：经典通关音

### 6. 拓展练习
**相似问题迁移**：
1. 项目选择：任务有依赖关系和收益/成本
2. 资源分配：工厂依赖原材料供应
3. 课程选修：先修课约束

**洛谷推荐**：
1. P3410 拍照（最大权闭合子图模板）
   - 理由：基础建模训练
2. P4177 订单（带依赖的生产问题）
   - 理由：强化依赖关系处理
3. P2762 太空计划（科学实验版）
   - 理由：复杂依赖关系应用

### 7. 学习心得
> **经验摘录（longlongzhu123）**：  
> "初忽略环处理，样例不过才醒悟：保护关系成环即无敌，需拓扑先行"

> **Kay点评**：  
> 调试时优先验证拓扑结果，用3x2样例模拟网络流建图，数据虽小但能暴露反向边方向错误等关键问题

### 总结
本题精髓在于将实际问题转化为两层模型处理：拓扑排除无效点 + 网络流求最优解。通过像素动画演示依赖关系与最小割的对应，可直观理解"正权和-最小割=净收益"的核心公式，建议编码时重点防御`j=m-1`的边界情况。

---
处理用时：170.09秒
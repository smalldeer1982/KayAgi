# 题目信息

# [JLOI2008] 将军

## 题目描述

刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\_T。

言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：

给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。

这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。

现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。

国际象棋中一共有 6 种棋子：

- king（国王）；
- queen（皇后）；
- bishop（教主）；
- knight（骑士）；
- rook（车）；
- pawn（步兵）。

各棋子的攻击范围如下：

- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；
- knight 的攻击范围如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

- rook 攻击水平和垂直两条线上的所有格子；
- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；
- king 攻击周围 8 个方向各 1 格；
- bishop 攻击两条对角线上的所有格子。

除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。

可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。

## 说明/提示

```plain
BBN
...
...
```

```plain
BBN
...
B..
```

虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。


## 样例 #1

### 输入

```
3 3
..N
...
...
```

### 输出

```
2```

# AI分析结果


# 💡 Kay的C++算法解析：将军 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二分图匹配` (图论应用)

🗣️ **初步分析**：
> 解决"将军"这道题，关键在于将棋盘问题转化为二分图匹配问题。简单来说，就像把不同颜色的珠子分类串成项链，避免同色相邻。在本题中，我们将棋盘旋转45°，使bishop的攻击线（对角线）变成水平和垂直线条，从而建立二分图模型：
>   - 左部节点：旋转后所有"左上-右下"方向的对角线（行）
>   - 右部节点：旋转后所有"右上-左下"方向的对角线（列）
>   - 边：每个可放置位置连接对应的行和列节点
> 
> **核心难点**是如何正确处理各种棋子的攻击范围：
>   - 骑士(knight)攻击范围特殊且不被阻挡
>   - 其他棋子攻击范围会被阻挡
>   - 需同时避免新bishop攻击原有棋子
> 
> **可视化设计思路**：采用8位像素风格，展示棋盘旋转动画→对角线变水平/垂直→匈牙利算法匹配过程。关键步骤高亮：攻击范围标记、坐标转换、增广路径查找。复古游戏音效：匹配成功时播放"胜利"音效，回溯时播放"错误"提示音。

---

## 2. 精选优质题解参考

**题解一 (来源：caizehua)**
* **点评**：此解思路最清晰完整，通过坐标转换公式`(i,j)→(i+j-1, j+n-i)`将棋盘旋转45°，并用`can`数组精确标记三类状态（可放置/有棋子/被攻击）。二分图建模时创新性使用`r`和`c`数组标记行列连通块，避免重复建边。代码模块化程度高，每个棋子攻击范围用独立函数处理，边界判断严谨。亮点在于详细图示解释坐标变换原理，帮助理解空间转换思维。

**题解二 (来源：GNAQ)**
* **点评**：解法简洁高效，直接通过`pau`数组存储旋转后坐标。预处理时区分棋子类型，特别处理bishop的双对角线攻击。匈牙利算法实现规范，使用`vis`数组避免重复访问。亮点在于指出Dinic可能超时而匈牙利更优的实践洞察，对竞赛选手有直接参考价值。

**题解三 (来源：lly66666)**
* **点评**：提供最完整的攻击范围预处理实现，每种棋子用独立函数处理（如`GoK()`处理国王）。代码结构清晰，通过`av`数组标记可用位置，`h/l`数组记录旋转后行列状态。亮点在于用方向数组统一处理移动逻辑，减少冗余代码，体现算法复用思想。

---

## 3. 核心难点辨析与解题策略

1. **难点：攻击范围预处理**
   * **分析**：不同棋子攻击规则复杂（如骑士跳跃、车直线攻击）。优质解用方向数组+循环实现通用处理，遇到阻挡(`mapx != '.'`)时`break`。特别注意：除骑士外攻击会被阻挡，且需添加bishop攻击范围。
   * 💡 **学习笔记**：方向数组是处理网格移动问题的通用利器

2. **难点：棋盘旋转建模**
   * **分析**：旋转45°使对角线转化为行列。坐标变换公式`(i,j)→(i+j-1, j+n-i)`将物理位置映射为二分图节点。关键变量`pau`(caizehua)或`i+j-1`(GNAQ)存储变换后坐标。
   * 💡 **学习笔记**：坐标变换是降维打击复杂问题的有效手段

3. **难点：二分图构建优化**
   * **分析**：直接建边可能导致O(n²)复杂度。优质解通过`r/c`数组(caizehua)或`mpu/mpd`(WFHFAQFXY)标记行列连通块，仅在连通块内建边。
   * 💡 **学习笔记**：连通块压缩大幅减少边数，提升匈牙利效率

### ✨ 解题技巧总结
- **降维思维**：将斜线攻击转化为水平/垂直问题
- **模块化设计**：分离攻击范围处理与匹配算法
- **状态压缩**：用位运算或标记数组优化空间
- **增量测试**：用小棋盘验证坐标变换正确性

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合优质题解，聚焦攻击范围预处理+匈牙利算法
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <vector>
using namespace std;

const int N = 2050;
vector<int> graph[N];
int match[N];
bool vis[N];
char board[N][N];
bool attacked[N][N];
int n, m;

// 匈牙利算法
bool dfs(int u, int tag) {
    if (vis[u]) return false;
    vis[u] = true;
    for (int v : graph[u]) {
        if (match[v] == -1 || dfs(match[v], tag)) {
            match[v] = u;
            return true;
        }
    }
    return false;
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; i++) 
        cin >> (board[i] + 1);
    
    // 预处理攻击范围（示例：骑士）
    int knightX[8] = {-2,-1,1,2,2,1,-1,-2};
    int knightY[8] = {-1,-2,-2,-1,1,2,2,1};
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (board[i][j] == 'N') {
                for (int k = 0; k < 8; k++) {
                    int x = i + knightX[k], y = j + knightY[k];
                    if (x >= 1 && x <= n && y >= 1 && y <= m)
                        attacked[x][y] = true;
                }
            }
            // 添加其他棋子处理...
        }
    }

    // 坐标变换建图 (i,j) -> (i+j-1)为行, (j+n-i)为列
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (!attacked[i][j] && board[i][j] == '.') {
                int r = i + j - 1;
                int c = j + n - i + N; // 列节点偏移防冲突
                graph[r].push_back(c);
            }
        }
    }

    // 匈牙利算法
    memset(match, -1, sizeof(match));
    int ans = 0;
    for (int i = 1; i < N; i++) {
        memset(vis, 0, sizeof(vis));
        if (dfs(i, i)) ans++;
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：
  1. 输入处理：读入棋盘尺寸和状态
  2. 攻击预处理：根据棋子类型标记被攻击位置
  3. 坐标转换：通过`i+j-1`和`j+n-i`计算旋转后位置
  4. 建图：每个可放置位置连接变换后的行列节点
  5. 匈牙利算法：寻找最大匹配，匹配数即最大bishop数

---

## 5. 算法可视化：像素动画演示

**像素探险家：国际象棋主教放置大冒险**

* **核心演示**：棋盘旋转→攻击范围标记→二分图匹配
* **设计思路**：8位像素风格还原FC棋类游戏，用颜色区分：
  - 红：已有棋子
  - 黄：被攻击区域
  - 绿：可放置位置
  - 蓝：当前匹配路径

* **动画流程**：
  1. **初始棋盘**：像素化显示原始棋盘，棋子用不同色块表示
  2. **攻击范围标记**：按棋子类型扩散色块，骑士跳跃显示为"闪光"
  3. **旋转动画**：棋盘顺时针旋转45°（关键帧0.5秒/帧）
  4. **二分图构建**：
     - 左侧：行节点（旋转后对角线）用垂直条
     - 右侧：列节点用水平条
     - 可放置位置显示为连接线
  5. **匈牙利算法演示**：
     - 当前节点高亮闪烁
     - 尝试匹配：连线显示绿色
     - 回溯过程：连线变红+音效提示
  6. **结果展示**：成功放置的主教显示为闪烁皇冠

* **交互控制**：
  - 方向键：单步执行算法
  - A键：自动播放（速度可调）
  - R键：重置动画
  - P键：暂停/继续

* **音效设计**：
  - 背景：8位象棋风格BGM
  - 匹配成功：上升音阶
  - 回溯：短促"滴"声
  - 完成：胜利号角

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**：
  1. 网格问题转二分图：如车（rook）在棋盘放置（行列独立）
  2. 攻击范围模拟：塔防类游戏敌人路径计算
  3. 坐标变换：解决斜向移动/检测问题

* **洛谷推荐**：
  1. [P2825 游戏](https://www.luogu.com.cn/problem/P2825)  
     → 巩固行列匹配建模
  2. [P6062 模拟](https://www.luogu.com.cn/problem/P6062)  
     → 训练复杂攻击范围处理
  3. [P10945 棋盘覆盖](https://www.luogu.com.cn/problem/P10945)  
     → 掌握匈牙利算法变形

---

## 7. 学习心得与经验分享

> **经验**："调试时发现旋转后坐标溢出，建议用`(i+j-1)`和`(i-j+n)`避免负值" —— caizehua题解  
> **点评**：坐标变换是核心难点，建议：
> 1. 小棋盘（3x3）手工验证公式
> 2. 添加断言检查边界
> 3. 可视化输出中间矩阵

---

**Kay结语**：通过"将军"这道题，我们学会了用坐标变换降维+二分图匹配的精妙组合。记住，算法世界就像国际象棋，每一步转换都可能打开新局势！下次遇到网格问题，不妨试试旋转视角哦~ 🚀

---
处理用时：154.39秒
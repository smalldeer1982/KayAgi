# 题目信息

# [Code+#2] 白金元首与独舞

## 题目背景

```cpp
到河北省 见斯大林 / 在月光下 你的背影 / 让我们一起跳舞吧
```
うそだよ~ 河北省怎么可能有 Stalin。


可是…… 可是如果 Stalin 把自己当作炸弹扔到地堡花园里来了呢？


怀揣着这份小小的希望，元首 Adolf 独自走进了花园。终有一天会重逢的吧，Stalin。或许是在此处，或许是在遥远的彼方。


无论如何，在此之前，好好装点一番花园，编排一段优美的舞步吧！


## 题目描述

元首把花园分为 $n$ 行 $m$ 列的网格。每个格子中都可以放置一个标识，指向上、下、左、右四个方向中的任意一个。元首位于一个格子时，会按照其中标识所指的方向进入周围的格子，或者走出花园（即目的格子不在网格之内）。举个例子 —— 对于下面的放置方式，元首从第 $3$ 行第 $2$ 列的格子开始，会沿着以红色标出的路径走出花园；从第 $2$ 行第 22 列的格子开始，则会在以蓝色标出的环路内不断地行走。

 ![](https://cdn.luogu.com.cn/upload/pic/12659.png) 

元首已经设计好了大部分格子的标识。元首用字符 L、R、U、D 分别表示指向左、右、上、下四个方向的标识，用字符 . 表示未决定的格子。现在，元首希望将每个 . 替换为 L、R、U、D 中任意一种，使得从花园中的任意一个格子出发，按照上述规则行走，都可以最终走出花园。


你需要编写程序帮助元首计算替换的不同方案数。两个方案不同当且仅当存在一个格子，使得两个方案中该格子内的标识不同。当然，由于答案可能很大，只需给出方案数除以 $10^9 + 7$所得的余数即可。


## 说明/提示

**样例解释**

第 $1$ 组数据中，将惟一的 . 替换成 R、U 或 D 均满足要求。


第 $2$ 组数据中，将左上方和右下方的两个 . 分别替换成 LR、LU、LD、UR、UU、UD、DR 或 DD 均满足要求。


第 $3$ 组数据中，没有待决定的格子，原本的安排会使得元首陷入无尽的环路，故答案为 $0$。该组数据与**题目描述**中的例子相同。


第 $4$ 组数据中，也没有待决定的格子，但原本的安排已经满足要求，故答案为 $1$。


令 $k$ 表示标记未确定（即包含 “.”）的格子总数。


对于所有数据，有 $1 \leq T \leq 10$，$1 \leq n, m \leq 200$，$0 \leq k \leq \min(nm, 300)$。

 ![](https://cdn.luogu.com.cn/upload/pic/12660.png) 

“... wie Stalin!”


题面与史实无关。


来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/吕时清 命题/吕时清 验题/王聿中，杨景钦

Git Repo：https://git.thusaac.org/publish/CodePlus201712

感谢腾讯公司对此次比赛的支持。


## 样例 #1

### 输入

```
5
3 9
LLRRUDUUU
LLR.UDUUU
LLRRUDUUU
4 4
LLRR
L.LL
RR.R
LLRR
4 3
LRD
LUL
DLU
RDL
1 2
LR
2 2
..
..```

### 输出

```
3
8
0
1
192```

# AI分析结果


### 💡 Kay的C++算法解析：[Code+#2] 白金元首与独舞 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：图论-矩阵树定理应用  
🗣️ **初步分析**：  
> 本题本质是**有向树形图计数问题**，可比喻为在迷宫中布置方向标志，确保从任意点出发都能走出迷宫（形成以外部虚点为根的内向树）。核心步骤：  
> 1. **问题转化**：将网格点抽象为图节点，方向决定边指向，添加虚点表示"外部"
> 2. **缩点优化**：通过记忆化搜索，将未定向点直接连接到路径上首个关键点（其他未定向点或虚点），将图规模从$O(nm)$压缩至$O(k)$
> 3. **矩阵树定理**：对缩点后的图求基尔霍夫矩阵行列式（删除虚点对应行列）  
> **可视化设计**：采用8位像素迷宫风格，用不同颜色方块表示定向点/未定向点/虚点，箭头动画展示记忆化搜索路径，树形图形成时播放胜利音效。

---

#### 精选优质题解参考
**题解一（shadowice1984）**  
* **点评**：思路严谨完整，创新性提出缩点优化（记忆化搜索预处理路径），完整实现矩阵树定理。代码中`tr`数组存储记忆化结果，`dfs`双重功能（判环+路径搜索）设计巧妙。边界处理周全，空间复杂度$O(k^2)$优于暴力$O(n^2m^2)$。

**题解二（Rainybunny）**  
* **点评**：代码结构更清晰，模块化设计突出。独立实现`findLoop`判环和`findUnknown`记忆化搜索，基尔霍夫矩阵构建函数`add`封装优雅。时间复杂度$O(k^3)$相同，但变量命名（如`unk`替代`tr`）更易理解，适合初学者参考。

---

#### 核心难点辨析与解题策略
1. **问题转化难点**  
   * **分析**：需理解"任意点可达外部 ⇔ 内向树"的等价性。关键变量为虚点编号$ctt$（题解一）或$cnt$（题解二），通过添加所有边界到虚点的边实现转化。
   * 💡 学习笔记：树形图根节点必须是唯一出度为0的点（虚点）。

2. **缩点优化实现**  
   * **分析**：记忆化搜索需处理三类终点：①其他未定向点 ②虚点 ③环（非法）。关键数据结构`tr/unk`数组存储每个点的"下一跳"目标，避免重复计算路径。
   * 💡 学习笔记：记忆化搜索将$O(nm)$路径查询降至$O(1)$。

3. **矩阵树定理应用**  
   * **分析**：基尔霍夫矩阵$K=入度矩阵-邻接矩阵$。删除虚点对应行/列后求行列式，需处理：①找主元 ②高斯消元 ③符号处理。两题解均用$O(k^3)$实现。
   * 💡 学习笔记：有向树计数需明确根节点，行列式值即合法方案数。

✨ **解题技巧总结**  
- **等效压缩**：将大图压缩至关键点集（如未定向点）
- **模块化设计**：分离判环、记忆化搜索、矩阵运算
- **边界鲁棒性**：先判环再计算，避免无效运算

---

#### C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=310, mod=1e9+7;
int T, n, m, ctt, K[N][N], tr[N][N];
char grid[N][N];

int dfs(int x, int y) { // 记忆化搜索核心
  if(x<1||x>n||y<1||y>m) return ctt;
  if(tr[x][y]) return tr[x][y];
  if(grid[x][y]=='L') return tr[x][y]=dfs(x,y-1);
  if(grid[x][y]=='R') return tr[x][y]=dfs(x,y+1);
  if(grid[x][y]=='U') return tr[x][y]=dfs(x-1,y);
  if(grid[x][y]=='D') return tr[x][y]=dfs(x+1,y);
  return 0;
}

ll det() { /* 矩阵行列式计算 */ }

void solve() {
  scanf("%d%d",&n,&m); ctt=1;
  for(int i=1;i<=n;i++) {
    scanf("%s",grid[i]+1);
    for(int j=1;j<=m;j++)
      if(grid[i][j]=='.') tr[i][j]=++ctt;
  }
  ctt++; // 虚点编号
  // 判环省略，建图
  for(int i=1;i<=n;i++)
    for(int j=1;j<=m;j++)
      if(grid[i][j]=='.')
        for(int d=0;d<4;d++)
          add(tr[i][j], dfs(i+dx[d],j+dy[d]));
  printf("%lld\n", det());
}
```

**题解一亮点片段**  
```cpp
// 记忆化搜索 + 判环二合一
int dfs(int px, int py, int col) { 
  if(px<1||px>n||py<1||py>m) return true;
  if(id[px][py]==col) return false; // 发现环
  /* 方向处理 */
}
```
> **解读**：巧妙用`col`参数标记DFS路径，遇到已访问点即判环，避免额外存储。

**题解二亮点片段**  
```cpp
inline void add(int s, int t) {
  if(!t) t=1; // 虚点统一处理
  ++K[s][s];  // 入度矩阵更新
  K[s][t]=(K[s][t]-1+mod)%mod; // 邻接矩阵
}
```
> **解读**：封装边添加操作，自动处理虚点映射，保证矩阵正确性。

---

#### 算法可视化：像素动画演示
![](https://cdn.luogu.com.cn/upload/pic/12659.png)  
**设计思路**：将网格转为8位像素迷宫（FC风格），实现三阶段动画：  

1. **初始化**（像素块+控制面板）  
   - 绿块：未定向点（可交互）  
   - 灰块：定向点（显示箭头）  
   - 红框：虚点（屏幕外区域）

2. **记忆化搜索演示**（步进控制+音效）  
   - 点击未定向点→展开4个方向箭头  
   - 沿方向移动像素光标，路径高亮（蓝色轨迹）  
   - 终点触发效果：虚点（爆炸动画+胜利音效）/其他未定点（闪烁黄光）  
   - 音效：移动("滴")，终点("叮")

3. **树形图生成**（自动模式）  
   - 以虚点为根，回溯显示最终树形（金色路径）  
   - 成功生成时：播放8-bit胜利音乐，显示方案数  

> **技术实现**：Canvas绘制网格，requestAnimationFrame控制动画，音效用Web Audio API。

---

#### 拓展练习与相似问题
1. **洛谷 P6178** 【模板】Matrix-Tree定理  
   * 推荐理由：矩阵树定理基础应用，理解无向图生成树计数

2. **洛谷 P4208** [JSOI2008]最小生成树计数  
   * 推荐理由：结合矩阵树定理与最小生成树性质

3. **洛谷 P5299** [PKUWC2018]Slay the Spire  
   * 推荐理由：动态规划与组合计数的综合应用

---

#### 结语
本题展示了**问题转化+图论优化**的经典思路。掌握矩阵树定理和记忆化搜索后，可解决更多网格图计数问题。记住：复杂问题往往存在关键子结构，找到它就能化繁为简！💪

---
处理用时：91.21秒
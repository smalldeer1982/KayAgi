# 题目信息

# 【模板】Matrix-Tree 定理

## 题目描述

给定一张 $n$ 个结点 $m$ 条边的带权图（可能为无向图，可能为有向图）。

定义其一个生成树 $T$ 的权值为 $T$ 中所有边权的乘积。

求其所有不同生成树的权值之和，对 $10^9+7$ 取模。

---

注意：

1. 本题中，有向图的生成树指的是 **以 $1$ 为根的外向树**；

2. 两棵生成树 $T_1,T_2$ 不同，当且仅当存在存在一条边 $e$，满足 $e\in T_1,\ \ e\notin T_2$。

## 说明/提示

【样例 $1$ 解释】

样例 $1$ 中的无向图如左图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/pxtx9z5a.png)

右图为其一个权值为 $3\times 1\times 2\times 3=18$ 的生成树的例子。

---

【样例 $2$ 解释】

样例 $2$ 中的有向图如左图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/4276yln3.png)

右图为其一个权值为 $1\times 1\times 1\times 2=2$ 的生成树（以 $1$ 为根的外向树）的例子。

---

【数据范围】

对于 $100\%$ 的数据：$1\leq n\leq 300,\ \ 1\leq m\leq 10^5,\ \ t\in \{0,1\},\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^9$。

对于测试点 $1,2,3,4,5,6$，$t=0$；对于测试点 $7,8,9,10,11$，$t=1$。

图中 **可能** 存在重边和自环，重边算作多条边。

## 样例 #1

### 输入

```
5 8 0
2 3 1
1 2 3
4 5 1
4 2 2
3 5 2
3 4 3
3 4 1
3 3 5
```

### 输出

```
144
```

## 样例 #2

### 输入

```
5 9 1
1 2 3
3 2 1
1 3 1
2 4 2
3 5 1
4 3 4
3 5 1
5 4 1
4 4 6
```

### 输出

```
72
```

# AI分析结果


### 💡 Kay的C++算法解析：Matrix-Tree定理 深入学习指南 💡

<introduction>
大家好！我是Kay，今天我们将一起探索Matrix-Tree定理（矩阵树定理）的奥秘。这个强大的工具能帮我们计算带权无向图和有向图中所有生成树的边权乘积之和。通过本指南，你将掌握核心算法思想、代码实现技巧，并通过像素动画直观理解行列式计算过程。准备好了吗？让我们开始吧！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论算法/矩阵树定理` 

🗣️ **初步分析**：
> 解决这道题的关键在于理解并运用**矩阵树定理**。想象一下，你要在一片茂密的图论森林中数清所有可能的树结构——矩阵树定理就像一把精准的激光尺，通过数学魔法（行列式计算）直接给出答案！  
> - **核心思想**：将图的拓扑结构转化为矩阵（基尔霍夫矩阵），生成树数量等于该矩阵任意n-1阶主子式的行列式值。
> - **难点对比**：无向图需构造度数矩阵，有向图需区分入度/出度矩阵；行列式计算需处理模运算和边界条件。
> - **可视化设计**：我们将用像素动画展示矩阵变换过程——高亮当前消元的行/列，行交换时像素块闪烁红光，行相加时黄光流动，成功消元时绿光庆祝。复古8-bit音效（如“哔”声表示交换，“叮”声表示完成）将增强体验，AI自动演示模式可调速观察消元步骤。

---

## 2. 精选优质题解参考

<eval_intro>
基于思路清晰性、代码规范性和实践价值，我精选了3份优质题解。它们都正确实现了矩阵树定理，但在处理细节上各有特色：

**题解一（command_block）**
* **亮点**：  
  - **辗转相除法**处理非质数模，避免逆元计算（通用性强）  
  - 代码简洁（30行核心逻辑），变量命名规范（如`a`表矩阵）  
  - 完整支持无向/有向图切换（`op`参数控制）

**题解二（zhylj）**
* **亮点**：  
  - **高斯消元**实现（模数为质数时效率高）  
  - 代码高度易读（25行），适合快速上手  
  - 矩阵构造逻辑直白（直接操作`K`矩阵）

**题解三（Achtoria）**
* **亮点**：  
  - **严格数学证明**（Cauchy-Binet公式推导）  
  - 详细解释有向图外向树定义  
  - 边界处理严谨（自环和重边说明）

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在实现矩阵树定理时，你会遇到三个关键挑战：

1.  **难点1：矩阵构造差异（无向图 vs 有向图）**
    * **分析**：无向图的度数矩阵需双向累加边权（`D[u][u]+=w, D[v][v]+=w`），而有向图只需更新目标节点（外向树：`D[v][v]+=w`）。优质题解通过`op`参数优雅切换逻辑。
    * 💡 **学习笔记**：基尔霍夫矩阵 = 度数矩阵 - 邻接矩阵，类型决定构造方式！

2.  **难点2：行列式计算的模处理**
    * **分析**：当模数非质数（如本题$10^9+7$是质数，但扩展可能遇到合数），传统高斯消元失效。解决方案是**辗转相除法**——用行相减代替除法，避免求逆元。
    * 💡 **学习笔记**：辗转相除的核心是`while(a[i][i])`循环和行交换，复杂度仍为$O(n^3)$。

3.  **难点3：根节点删除与主子式选取**
    * **分析**：有向图需删除根所在行/列（如节点1），无向图可删任意行。代码中统一将节点编号减1后删第0行/列，确保主子式正确。
    * 💡 **学习笔记**：删除操作等价于矩阵切片（`subK[i-1][j-1] = K[i][j]`）。

### ✨ 解题技巧总结
- **技巧1：问题分解**  
  将生成树计数拆解为：①构图 → ②矩阵初始化 → ③行列式计算 → ④输出结果
- **技巧2：边界防御**  
  边权累加时用`(x+MOD)%MOD`避免负数，重边直接累加边权
- **技巧3：调试验证**  
  打印中间矩阵（如$3\times3$样例），对照手工计算验证

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解提炼的通用实现，支持无向/有向图和辗转相除消元：

```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long LL;
const int MOD = 1e9+7;

int det(vector<vector<LL>> a, int n) {
    int sign = 1, res = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = i+1; j < n; ++j) {
            while (a[i][i]) {
                LL ratio = a[j][i] / a[i][i];
                for (int k = i; k < n; ++k) 
                    a[j][k] = (a[j][k] - ratio * a[i][k] % MOD + MOD) % MOD;
                swap(a[i], a[j]);
                sign = -sign;
            }
            swap(a[i], a[j]);
            sign = -sign;
        }
    }
    for (int i = 0; i < n; ++i) 
        res = (LL)res * a[i][i] % MOD;
    return (res * sign % MOD + MOD) % MOD;
}

int main() {
    int n, m, op;
    cin >> n >> m >> op;
    vector<vector<LL>> K(n, vector<LL>(n, 0));
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--; // 节点0-indexed
        if (op == 0) { // 无向图
            K[u][u] = (K[u][u] + w) % MOD;
            K[v][v] = (K[v][v] + w) % MOD;
            K[u][v] = (K[u][v] - w + MOD) % MOD;
            K[v][u] = (K[v][u] - w + MOD) % MOD;
        } else { // 有向图（外向树）
            K[v][v] = (K[v][v] + w) % MOD;
            K[u][v] = (K[u][v] - w + MOD) % MOD;
        }
    }
    // 删根节点（0）得主子式
    vector<vector<LL>> subK(n-1, vector<LL>(n-1));
    for (int i = 1; i < n; ++i)
        for (int j = 1; j < n; ++j)
            subK[i-1][j-1] = K[i][j];
    cout << det(subK, n-1);
}
```
* **代码解读概要**：  
  1. 构造基尔霍夫矩阵`K`（根据`op`选择无向/有向模式）  
  2. 删除根节点所在行/列得子矩阵`subK`  
  3. `det`函数实现行列式计算：辗转相除消元 → 对角线乘积 → 符号处理

---
<code_intro_selected>
现在深入剖析优质题解的核心代码片段：

**题解一（command_block）的辗转相除**
```cpp
while (a[i][i]) {
    int t = a[j][i] / a[i][i];
    for (int k = i; k < n; ++k) 
        a[j][k] = (a[j][k] - t * a[i][k]) % mod;
    swap(a[i], a[j]); // 行交换触发符号变化
}
```
* **代码解读**：  
  当主元非零时，用除法系数`t`消去下方行元素。每次行交换时，行列式符号翻转（`sign*=-1`）。  
  💡 **学习笔记**：此操作类似欧几里得算法，将余数逐步减小至零。

**题解二（zhylj）的矩阵构造**
```cpp
// 无向图
K[u][u] += w; K[v][v] += w;
K[u][v] -= w; K[v][u] -= w;
// 有向图
K[v][v] += w; 
K[u][v] -= w;
```
* **代码解读**：  
  无向图更新双角度数，有向图仅更新目标节点度数（外向树）。减法后`+MOD`防负值。  
  💡 **学习笔记**：邻接矩阵记录负边权是基尔霍夫矩阵的核心特征！

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为直观理解行列式计算，我设计了一个8位像素风格的动画方案——**《矩阵消元大冒险》**。你将化身像素勇者，在网格矩阵中执行行变换任务！

* **主题**：复古游戏风格的行列式计算  
* **核心演示**：基尔霍夫矩阵的消元过程（以$4\times4$矩阵为例）  
* **设计思路**：用像素方块表示矩阵元素，不同颜色区分状态（主元=红色，已消元=绿色，活跃行=黄色）。游戏化机制增强理解动力。

### 动画帧步骤：
1. **初始化场景**  
   - 左侧：像素节点（圆点）和边（连线），边权显示为浮动数字  
   - 右侧：基尔霍夫矩阵（每个数字用$16\times16$像素块显示）  
   - 控制面板：开始/暂停/单步/速度滑块（背景音乐：8-bit循环音）

2. **消元第一关（第0列）**  
   - 主元`a[0][0]`闪烁红光，播放"锁定目标"音效  
   - 下方行`j`的`a[j][0]`亮黄光，计算`ratio = a[j][0]/a[0][0]`  
   - 执行行变换：黄方块沿箭头流向红方块，伴随"滴答"声

3. **行交换事件**  
   - 当主元为零时，触发交换：两行像素块水平滑动交换位置  
   - 屏幕震动+“哔”声提示，行列式符号标志（左上角）翻转

4. **胜利结算**  
   - 消元完成：对角线方块亮绿光，播放胜利音效  
   - 显示结果：`det = ±(a11*a22*a33)`浮动显示  

* **技术实现**：Canvas绘制矩阵网格，音效用Web Audio API实现。关键逻辑：  
  ```javascript
  function drawFrame() {
    drawMatrix(); // 绘制当前矩阵
    if (activeRow >=0) highlightCell(activeRow, activeCol, "red"); 
    if (autoPlay) setTimeout(nextStep, speed);
  }
  ```

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握Matrix-Tree定理后，你已解锁图论中的重要技能！以下是拓展方向：

* **通用技巧迁移**：  
  矩阵树定理可解决：①生成树计数 ②带权生成树和 ③有向图树形图计数  
  关键：识别问题中的拓扑结构 → 构造对应矩阵 → 行列式计算

* **推荐练习（洛谷）**：  
  1. **P4336 [SHOI2016]黑暗前的幻想乡**  
     → 结合容斥原理的矩阵树进阶应用  
  2. **P3317 [SDOI2014]重建**  
     → 带概率边权的生成树计数  
  3. **P4455 [CQOI2018]社交网络**  
     → 有向图树形图的变式训练  

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验尤为宝贵：

> **command_block的建议**：  
> “构造小样例（如3节点）打印中间矩阵，验证行列式各步骤值。”  
>   
> **Kay的点评**：  
> 这是调试矩阵类算法的黄金法则！手工计算$3\times3$矩阵的行列式，再与程序输出比对，能快速定位构造错误。

---

<conclusion>
本次关于Matrix-Tree定理的探索就到这里。记住，编程如种树——理解根基（数学原理），修剪枝叶（代码优化），终将收获茂密森林（高效算法）！下次遇到生成树问题，别忘了你的矩阵武器哦~ 🌲💻

---
处理用时：175.32秒
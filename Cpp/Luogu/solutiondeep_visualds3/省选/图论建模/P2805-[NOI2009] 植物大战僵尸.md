# 题目信息

# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# AI分析结果


### 💡 Kay的C++算法解析：植物大战僵尸 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：网络流 - 最大权闭合子图 × 拓扑排序

🗣️ **初步分析**：
> 解决"植物大战僵尸"这道题，关键在于理解并运用**最大权闭合子图模型**。简单来说，这就像组建一支球队：选择某个球员（植物）时，必须同时选择所有依赖他的球员（保护关系）。在本题中，该模型用于计算在满足植物保护关系的约束下，能获得的最大能源收益。

- **核心难点**：植物间可能存在循环保护（如两株植物互相保护），形成"无敌环"。需先用拓扑排序识别并移除这些不可达点。
- **解决方案**： 
  1. **拓扑去环**：构建保护关系图，移除入度为0的节点及其后继（类似剥洋葱）
  2. **网络流建模**：
     - 正权点（能源收益）连源点
     - 负权点（能源消耗）连汇点
     - 保护关系连无限容量边
  3. **计算收益**：最大收益 = 正权值和 - 最小割

- **可视化设计**：采用8位像素风格（类似FC游戏）：
  - **保护关系**：用绿色箭头表示保护，红色环标记循环保护
  - **网络流过程**：正权点亮蓝色，负权点亮红色，流量流动时产生像素粒子特效
  - **关键操作**：拓扑排序时，被移除的节点播放"消失"动画；网络流割边时触发刀光特效

#### 2. 精选优质题解参考
**题解一（来源：longlongzhu123）**
* **点评**：
  - 思路清晰：用生活化比喻解释最大权闭合子图（"选球员必须选教练"）
  - 代码规范：使用`POINT`宏处理坐标转换，变量名`in[]`明确表示入度
  - 算法亮点：先拓扑去环再建网络流的双重处理，规避了环状依赖问题
  - 实践价值：完整处理边界条件（如`j < m`时的右侧保护）

**题解二（来源：Freddie）**
* **点评**：
  - 创新性：提出"游戏化"思考角度（"我是僵尸"模式）
  - 实现技巧：使用`addTP`分离拓扑建图与网络流建图，降低耦合度
  - 效率优化：在拓扑排序时直接标记有效节点，减少后续计算量

#### 3. 核心难点辨析与解题策略
1. **循环保护的识别与处理**
   * **分析**：当多个植物形成保护环时，它们都无法被攻击。拓扑排序时，维护入度数组`in[]`，仅将入度归零的节点加入队列。未被访问的节点即构成"无敌环"。
   * 💡 **学习笔记**：拓扑排序是处理依赖环的利器，类似课程先修关系

2. **保护关系的网络流转化**
   * **分析**：若植物A保护B，需连边`B→A`（容量∞）。这保证若选择B，必须选择A，否则形成S→B→A→T的割裂路径。
   * 💡 **学习笔记**：网络流中的∞边实质是强制依赖关系

3. **行列约束的巧妙处理**
   * **分析**：同一行中，攻击左侧植物必须先攻击右侧植物。通过循环自动构建右侧到左侧的边：`for(j=m; j>1; j--) addEdge(i,j, i,j-1)`
   * 💡 **学习笔记**：将隐式规则转化为显式边是建模关键

✨ **解题技巧总结**
- **依赖分析**：用拓扑排序预处理无效节点
- **权重分离**：正/负权点分别连接源/汇点
- **无限约束**：保护关系用∞边表示不可割性
- **逆向思维**：答案 = 正权和 - 最小割（最大流）

#### 4. C++核心代码实现赏析
```cpp
// 本题通用核心实现 (综合自优质题解)
#include<bits/stdc++.h>
#define POINT(x,y) ((x)*m+(y)) // 坐标转索引
const int N=600, INF=1e9;

int n, m, s, t;
vector<int> G[N];       // 保护关系图
int score[N], in[N];    // 节点权值、入度
bool valid[N];          // 标记有效节点

// 拓扑排序去环
void topoSort() {
    queue<int> q;
    for(int i=0; i<n*m; i++)
        if(!in[i]) q.push(i), valid[i]=1;
    
    while(!q.empty()) {
        int u = q.front(); q.pop();
        for(int v : G[u]) if(--in[v] == 0) {
            q.push(v); valid[v]=1;
        }
    }
}

// 网络流Dinic算法
struct Dinic {
    struct Edge { int v, cap, rev; };
    vector<Edge> adj[N];
    int level[N], iter[N];
    
    void addEdge(int u, int v, int cap) {
        adj[u].push_back({v, cap, (int)adj[v].size()});
        adj[v].push_back({u, 0, (int)adj[u].size()-1});
    }
    
    bool bfs() { /* 层次图构建 */ }
    int dfs(int u, int f) { /* 阻塞流计算 */ }
    
    int maxFlow() {
        int flow = 0;
        while(bfs()) {
            memset(iter, 0, sizeof iter);
            flow += dfs(s, INF);
        }
        return flow;
    }
} flow;

int main() {
    // 输入初始化
    cin >> n >> m;
    s = n*m, t = s+1;
    
    // 构建保护图
    for(int i=0; i<n; i++) for(int j=0; j<m; j++) {
        int u = POINT(i,j);
        cin >> score[u];
        int cnt; cin >> cnt;
        while(cnt--) {
            int x, y; cin >> x >> y;
            int v = POINT(x,y);
            G[u].push_back(v);
            in[v]++;
        }
        // 右侧保护约束
        if(j > 0) {
            int left = POINT(i,j-1);
            G[u].push_back(left);
            in[left]++;
        }
    }
    
    topoSort(); // 预处理有效节点
    
    int sum = 0;
    for(int i=0; i<n*m; i++) if(valid[i]) {
        if(score[i] > 0) {
            flow.addEdge(s, i, score[i]);
            sum += score[i];
        } else if(score[i] < 0) {
            flow.addEdge(i, t, -score[i]);
        }
        
        for(int v : G[i]) if(valid[v]) 
            flow.addEdge(v, i, INF); // 注意反向边!
    }
    
    cout << sum - flow.maxFlow();
}
```

**代码解读概要**：
1. **坐标转换**：`POINT`宏实现二维坐标到一维索引的映射
2. **双层预处理**：先拓扑排序标记有效节点，再构建网络流
3. **权值分流**：正权连源点，负权连汇点
4. **反向建边**：保护关系建`v→u`边（注意与拓扑图方向相反）

#### 5. 算法可视化：像素动画演示
* **主题**："僵尸攻克植物防线" 像素策略游戏
* **核心演示**：
  ```mermaid
  graph LR
    A[僵尸小队] --> B(拓扑排序)
    B --> C{有效植物？}
    C -->|是| D[网络流战场]
    C -->|否| E[放弃攻击]
    D --> F[正权植物-蓝]
    D --> G[负权植物-红]
    F --> H[最小割计算]
    G --> H
    H --> I[最优攻击路径]
  ```

* **交互设计**：
  1. **战场网格**：20×30像素网格，植物用不同颜色方块表示
     - 绿色：普通植物
     - 蓝色：正权植物（+10）
     - 红色：负权植物（-5）
     - 闪烁红框：循环保护组

  2. **动态过程**：
     - **拓扑阶段**：入度归零的植物亮起，播放"叮"音效
     - **网络流阶段**：
       - 正权植物发出蓝色粒子流向源点
       - 负权植物发出红色粒子流向汇点
       - 保护关系显示为绿色能量束
       - 割边时触发金色刀光特效，伴随"咔嚓"音效

  3. **控制面板**：
     - 步进/暂停：空格键控制
     - 速度调节：滑块控制动画速度
     - 模式切换：拓扑视图/网络流视图

  4. **胜利结算**：成功路径显示为金色闪光，播放8-bit胜利音乐

#### 6. 拓展练习与相似问题
* **通用技巧迁移**：
  - 最大权闭合子图适用场景：
    1. 社交网络（选用户必须选关联好友）
    2. 项目依赖（启动项目需先完成前置）
    3. 基因调控（激活基因需激活调控因子）

* **推荐练习**：
  1. **洛谷 P3410** - 拍照
     > 基础最大权闭合子图应用，巩固建模思维
  
  2. **洛谷 P2762** - 太空飞行计划
     > 经典问题，理解实验设备与赞助关系的转化

  3. **洛谷 P4174** - 最大获利
     > 商业应用变体，学会处理收益与成本的平衡

#### 7. 学习心得与经验分享
> **调试经验**（来自题解作者）：
> "最初卡在循环保护的处理，后来意识到拓扑排序需建反向图。通过打印中间变量发现，当环存在时入度永不归零，从而定位问题关键。"

> **Kay的总结**：
> 本题的调试难点常出现在：
> 1. 图的方向：保护关系与网络流建图方向相反
> 2. 环的传播：未正确处理环影响的后继节点
> 调试时可输出拓扑排序后的有效节点数，确保与预期一致。

> **核心技巧**：对拍验证时，可构造小规模循环案例（如2×2网格互保）验证程序识别能力。

#### 结语
通过本次分析，我们掌握了用拓扑排序+网络流解决复杂约束问题的方法。关键是将实际问题转化为图论模型，并用算法工具处理约束。记住：**保护关系建反向边**是本题的黄金法则！下次挑战见！🚀

---
处理用时：140.39秒
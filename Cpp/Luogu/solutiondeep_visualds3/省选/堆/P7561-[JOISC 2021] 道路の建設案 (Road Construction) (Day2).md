# 题目信息

# [JOISC 2021] 道路の建設案 (Road Construction) (Day2)

## 题目背景

10s,2048M

## 题目描述

JOI 国是一个 $x\times y$ 的二维平面，王国里有 $n$ 个城镇，分别编号为 $1, 2, \cdots, n$，其中第 $i$ 个城镇的 **坐标** 为 $(x_i, y_i)$。

在 JOI 国，正计划修建连接两座城镇的路（下文简称：**「修路的项目」**），路有 $k$ 条。连接两个不同的城镇 $a$ 和 $b$ 将花费 $|x_a − x_b| + |y_a − y_b|$ 元。若有一条连接 $c$，$d$ 的路，则不需要也不可以在建一条连接 $d$，$c$ 的路，因为它们是相同的。

你要管理这个「修路的项目」，为了计算花费情况，你得弄明白连接一些城镇所需的花费。在这 $\dfrac{n\cdot(n-1)}{2}$ 条道路中，你想了解最便宜的 $k$ 条道路的花费。

给你城镇的坐标以及 $k$，请计算最便宜的 $k$ 条路所需要的钱。

## 说明/提示

#### 样例 #1 解释
有 $\dfrac{3 \times 2}{2} = 3$ 种方案。

- 城镇 $1 \to$ 城镇 $2$，$|(-1)-0|+|0-2| = 3$ 日元。
- 城镇 $1 \to$ 城镇 $3$，$|(-1)-0|+|0-0| = 1$ 日元。
- 城镇 $2 \to$ 城镇 $3$，$|0-0|+|2-0| = 2$ 日元。

将其进行排序为 $1,2,3$，所以输出是 $1$ 和 $2$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #2 解释

有 $\dfrac{5 \times 4}{2} = 10$ 种方案。

将钱数排序后是 $2, 2, 3, 3, 3, 3, 4, 4, 4, 4$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #3 解释

本样例满足 Subtask $1, 2, 4, 5, 6$。

#### 样例 #4 解释

本样例满足 Subtask $1, 4, 5, 6$。

#### 数据范围与约定

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | $n$ | $k$ | $y_i$ |
| :----: | :----: | :----: | :----:| :----: |
| $1$ | $5\%$ | $\le 10^3$ | / | / |
| $2$ | $6\%$ | / | / | $=0$ |
| $3$ | $7\%$ | / | $=1$ | / |
| $4$ | $20\%$ | / | $\le 10$ | / |
| $5$ | $27\%$ |  / | $\le 10 ^ 5$ | / |
| $6$ | $35\%$ | / | / | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：
- $2 \le n \le 2.5 \times 10^5$；
- $1 \le k \le \min(2.5\times 10^5,\ \dfrac{n\cdot(n-1)}{2}$)；
- $-10^9 \le x_i, y_i \le 10^9$，且 $1 \le i \le n$；
- $(x_i,y_i)\not = (x_j, y_j)$ 且 $1 \le i < j \le n$。

#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 2 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/2021-sp-d2-notice.pdf) [T2 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/road_construction.pdf)。


## 样例 #1

### 输入

```
3 2
-1 0
0 2
0 0
```

### 输出

```
1
2
```

## 样例 #2

### 输入

```
5 4
1 -1
2 0
-1 0
0 2
0 -2
```

### 输出

```
2
2
3
3
```

## 样例 #3

### 输入

```
4 6
0 0
1 0
3 0
4 0
```

### 输出

```
1
1
2
3
3
4
```

## 样例 #4

### 输入

```
10 10
10 -8
7 2
7 -8
-3 -6
-2 1
-8 6
8 -1
2 4
6 -6
2 -1
```

### 输出

```
3
3
4
5
6
6
6
7
7
7
```

# AI分析结果



---
# 💡 Kay的C++算法解析：JOISC 2021 道路の建設案 深入学习指南 💡

<introduction>
今天我们来一起分析“JOISC 2021 道路の建設案”这道题。题目要求我们找出所有城镇间曼哈顿距离的前k小值。本指南将帮助大家理解核心思路、关键算法，并通过生动的像素动画和代码解析，快速掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`二分答案与数据结构应用` (结合曼哈顿转切比雪夫距离的技巧)

🗣️ **初步分析**：
解决这道题的关键在于将曼哈顿距离转化为切比雪夫距离，再通过二分答案确定第k小的距离，最后用双指针+集合高效统计满足条件的点对。简单来说，`二分答案`就像“猜数字游戏”，我们猜测一个距离d，然后验证是否存在至少k个点对的距离≤d；而`曼哈顿转切比雪夫`则是通过坐标变换（(x,y)→(x+y,x−y)），将原问题转化为更易处理的二维区间查询问题。

- **题解思路对比**：多数题解采用“二分答案+双指针+集合”的框架（如hfjh、Purslane等），通过排序后维护一个滑动窗口内的点，用集合快速查询纵坐标在范围内的点对；少数题解尝试K-D Tree（如GK0328），但时间复杂度较高。
- **核心算法流程**：先将坐标转换为切比雪夫形式，按x排序；二分d，用双指针维护x差≤d的点，用集合维护这些点的y坐标，查询y差≤d的点对数量。若数量≥k，说明d可能偏大，否则偏小。
- **可视化设计**：采用8位像素风，用彩色方块表示城镇（x轴排序后横向排列），双指针用左右箭头动画表示滑动窗口；集合用纵向堆叠的像素块展示y坐标，查询时高亮满足y差≤d的块，配合“叮”的音效提示有效点对。

---

## 2. 精选优质题解参考

<eval_intro>
通过分析思路清晰度、代码规范性和算法有效性，以下题解值得重点学习：
</eval_intro>

**题解一：hfjh的题解（赞：11）**
* **点评**：此题解思路非常清晰，完整展示了“曼哈顿转切比雪夫→二分答案→双指针+multiset统计”的全流程。代码中变量命名规范（如`mid`、`ans`），边界处理严谨（如队列和集合的同步增删），特别是通过`multiset`的`lower_bound`快速查询y范围内的点，时间复杂度O(n log²n)，适合竞赛直接应用。亮点在于将抽象的二维统计转化为滑动窗口+集合的具体操作，对初学者友好。

**题解二：Purslane的题解（赞：2）**
* **点评**：此题解代码简洁，逻辑直接。通过排序后维护滑动窗口，用`multiset`存储y坐标，查询时直接遍历符合条件的y值，代码可读性高。虽然未显式处理边界，但通过`ffor`循环和`st.insert`等操作，确保了点对的唯一性（避免自环），是典型的竞赛优化写法。亮点在于将复杂的统计过程简化为几个关键循环，适合理解核心逻辑。

**题解三：SunnyYuan的题解（赞：0）**
* **点评**：此题解详细解释了二分后为何需要`check(l-1)`，并通过`multiset`插入极大/极小值避免越界错误。代码中对`multiset`的操作（如`lower_bound`）注释清晰，适合理解如何处理集合查询的边界情况。亮点在于对二分后补全答案的细节处理，确保输出前k小的正确性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，以下三个关键点需要重点突破：
</difficulty_intro>

1.  **关键点1：曼哈顿距离转切比雪夫距离**
    * **分析**：曼哈顿距离|xₐ−xᵦ|+|yₐ−yᵦ|等于切比雪夫距离max(|(xₐ+yₐ)−(xᵦ+yᵦ)|, |(xₐ−yₐ)−(xᵦ−yᵦ)|)。通过坐标变换（(x,y)→(x+y,x−y)），原问题转化为求切比雪夫距离的前k小，更易用二维区间查询处理。
    * 💡 **学习笔记**：坐标变换是处理曼哈顿/切比雪夫距离问题的常用技巧，能将“和”的问题转化为“极值”的问题。

2.  **关键点2：二分答案的正确性验证**
    * **分析**：二分答案的关键是确定“存在至少k个点对距离≤d”的判定条件。通过排序后维护x差≤d的滑动窗口，用集合统计y差≤d的点对数量，若数量≥k则d偏大，否则偏小。
    * 💡 **学习笔记**：二分答案的核心是设计一个高效的`check`函数，将问题转化为统计问题。

3.  **关键点3：高效统计点对数量**
    * **分析**：直接枚举所有点对不可行（O(n²)），需用双指针维护x范围（O(n)），用`multiset`（或`set`）维护y坐标（O(logn)查询），总复杂度O(n logn)。
    * 💡 **学习笔记**：滑动窗口+有序集合是处理二维范围查询的经典组合，能将复杂度从O(n²)降至O(n logn)。

### ✨ 解题技巧总结
- **坐标变换**：曼哈顿→切比雪夫，简化距离计算。
- **双指针+集合**：维护x范围，用集合快速查询y范围，高效统计点对。
- **二分后补全**：二分得到的d可能包含多余点对，需`check(d-1)`后补全前k小。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，展示“二分答案+双指针+multiset”的完整逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合hfjh和Purslane的题解，优化了边界处理和集合操作，清晰展示核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long;

    struct Node {
        ll x, y;
        bool operator<(const Node& other) const {
            return x < other.x || (x == other.x && y < other.y);
        }
    };

    int n, k;
    vector<Node> p;
    vector<ll> ans;

    bool check(ll d, bool collect = false) {
        ans.clear();
        multiset<ll> ys;
        queue<int> q;
        int cnt = 0;

        for (int i = 0; i < n; ++i) {
            // 移除x差超过d的点
            while (!q.empty() && p[i].x - p[q.front()].x > d) {
                ys.erase(ys.find(p[q.front()].y));
                q.pop();
            }
            // 查询y在[p[i].y - d, p[i].y + d]的点
            auto it = ys.lower_bound(p[i].y - d);
            while (it != ys.end() && *it <= p[i].y + d) {
                ll dist = max(p[i].x - p[q.front()].x, abs(p[i].y - *it)); // 切比雪夫距离
                if (collect) ans.push_back(dist);
                if (++cnt >= k) return true;
                ++it;
            }
            // 加入当前点
            q.push(i);
            ys.insert(p[i].y);
        }
        return false;
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);

        cin >> n >> k;
        p.resize(n);
        for (int i = 0; i < n; ++i) {
            ll a, b;
            cin >> a >> b;
            p[i].x = a + b; // 转换为切比雪夫坐标x
            p[i].y = a - b; // 转换为切比雪夫坐标y
        }
        sort(p.begin(), p.end()); // 按x排序

        // 二分答案
        ll l = 0, r = 4e9;
        while (l < r) {
            ll mid = (l + r) / 2;
            if (check(mid)) r = mid;
            else l = mid + 1;
        }

        // 收集所有≤l-1的距离，不足部分用l补全
        check(l - 1, true);
        sort(ans.begin(), ans.end());
        int need = k - ans.size();
        for (int i = 0; i < ans.size(); ++i) cout << ans[i] << '\n';
        for (int i = 0; i < need; ++i) cout << l << '\n';

        return 0;
    }
    ```
* **代码解读概要**：代码首先将坐标转换为切比雪夫形式并按x排序。`check`函数通过双指针维护x差≤d的窗口，用`multiset`存储窗口内的y坐标，查询y差≤d的点对数量。二分确定第k小的d后，收集所有≤d-1的距离，不足部分用d补全，最后排序输出。

---
<code_intro_selected>
接下来，赏析优质题解的核心代码片段：
</code_intro_selected>

**题解一：hfjh的题解**
* **亮点**：通过`multiset`的`lower_bound`快速定位y范围，代码逻辑清晰。
* **核心代码片段**：
    ```cpp
    multiset<Node> s;
    queue<int> q;
    bool check(ll mid) {
        q = queue<int>();
        s = multiset<Node>();
        ans = 0;
        for (int i = 1; i <= n; ++i) {
            while (q.size() && p[i].x - p[q.front()].x > mid) {
                auto w = s.find({0, p[q.front()].y});
                s.erase(w);
                q.pop();
            }
            auto lz = s.lower_bound({0, p[i].y - mid});
            while (lz != s.end() && lz->y <= p[i].y + mid) {
                an[++ans] = max(abs(lz->x - p[i].x), abs(lz->y - p[i].y));
                if (ans >= k) return 1;
                ++lz;
            }
            q.push(i);
            s.insert({p[i].x, p[i].y});
        }
        return 0;
    }
    ```
* **代码解读**：`check`函数维护队列`q`（存储x差≤mid的点）和集合`s`（存储这些点的y坐标）。对于当前点i，先移除x差超过mid的点，然后用`lower_bound`找到y≥p[i].y−mid的点，遍历到y≤p[i].y+mid的点，统计距离。若数量≥k返回true。
* 💡 **学习笔记**：`multiset`的有序性是快速查询y范围的关键，配合双指针维护x范围，实现高效统计。

**题解二：Purslane的题解**
* **亮点**：代码简洁，直接遍历符合条件的y值，适合理解核心逻辑。
* **核心代码片段**：
    ```cpp
    int check(int len) {
        ans.clear(), st.clear();
        int pos = 1, cnt = 0;
        ffor(i, 1, n) {
            if (i > 1) st.insert({t[i-1].y, i-1});
            while (t[i].x - t[pos].x > len) st.erase({t[pos].y, pos}), pos++;
            auto it = st.lower_bound({t[i].y - len, 0});
            while (it != st.end() && it->first <= t[i].y + len) {
                cnt++;
                ans.push_back(max(abs(t[i].y - it->first), abs(t[i].x - t[it->second].x)));
                if (cnt > k) return 0;
                it++;
            }
        }
        return 1;
    }
    ```
* **代码解读**：`st`存储(y, idx)对，按y排序。对于当前点i，先移除x差超过len的点，然后查询y在[t[i].y−len, t[i].y+len]的点，统计距离。若cnt>k返回0（表示len可能偏大）。
* 💡 **学习笔记**：通过`pair`的默认排序（先比较first，再second），`lower_bound`能直接定位y的下界，简化查询逻辑。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“二分答案+双指针+集合统计”的过程，我们设计一个8位像素风格的动画，用“像素城镇”和“滑动窗口”展示算法执行流程。
</visualization_intro>

  * **动画演示主题**：`像素城镇的距离探险`（复古FC风格）

  * **核心演示内容**：展示如何通过二分猜测距离d，用双指针维护x范围，集合维护y坐标，统计满足条件的点对数量。

  * **设计思路简述**：8位像素风格（红/蓝/绿等8色调色板）营造轻松氛围；双指针用左右箭头动画表示滑动窗口；集合用纵向堆叠的像素块展示y坐标，查询时高亮符合条件的块，配合“叮”音效强化记忆；完成统计时播放“胜利”音效，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示n个像素城镇（方块），按x坐标横向排列（x轴），颜色随机（如红色代表当前处理点）。
        - 顶部控制面板：开始/暂停、单步、重置按钮；速度滑块（1x-4x）；当前d值显示。
        - 右侧显示`multiset`中的y坐标（纵向堆叠的绿色方块，y值标在方块上）。

    2.  **二分启动**：
        - 初始d=0，逐渐增大（如从0到4e9）。每次二分调整d值时，屏幕中央弹出“猜测d=XXX”的文字气泡。

    3.  **双指针滑动**：
        - 左指针（蓝色箭头）固定在窗口左边界，右指针（红色箭头）随当前点i右移。当p[i].x−p[左指针].x>d时，左指针右移，对应城镇方块从集合中移除（淡入消失），播放“噗”的音效。

    4.  **集合查询**：
        - 当前点i（闪烁的黄色方块）触发查询，集合中y在[p[i].y−d, p[i].y+d]的方块高亮（变紫色），并弹出距离值（如max(x差, y差)），同时播放“叮”音效。统计到的点对数量实时显示在屏幕上方。

    5.  **目标达成**：
        - 当统计数量≥k时，d值缩小（左箭头动画）；否则d值增大（右箭头动画）。最终确定d后，所有前k小的距离以彩虹色方块从下到上排列展示，播放“胜利”音效。

  * **旁白提示**：
      - （单步时）“现在处理第i个城镇，左指针需要右移，移除x差超过d的城镇。”
      - （查询时）“看！这些y坐标在范围内的城镇，它们的距离都≤d哦～”
      - （完成时）“恭喜！我们找到了前k小的距离，它们是……”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到二分答案的“猜测-验证”过程，以及双指针和集合如何高效统计点对。这种游戏化的演示，让抽象的算法变得“看得见，摸得着”！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是“二分答案+二维范围查询”，这种思路可迁移到许多类似问题中：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - **二维平面最近邻问题**：如求前k小的欧氏距离，可转化为曼哈顿/切比雪夫距离处理。
      - **动态区间统计**：如在线查询区间内满足条件的元素数，可用线段树或平衡树维护。
      - **多关键字排序与双指针**：如处理二维偏序问题（如最长递增子序列变种），可用排序+树状数组优化。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1972 [SDOI2009]HH的项链**  
        * 🗣️ **推荐理由**：练习离线处理区间查询，用树状数组统计不同元素个数，巩固二维范围统计技巧。
    2.  **洛谷 P4390 [BOI2007]Mokia 摩基亚**  
        * 🗣️ **推荐理由**：二维前缀和+分块/树状数组，深入理解二维范围查询的优化方法。
    3.  **洛谷 P1429 平面最近点对（加强版）**  
        * 🗣️ **推荐理由**：求最近点对的经典问题，可尝试用分治法或K-D Tree，对比不同算法的效率。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如hfjh提到“需要注意multiset的迭代器失效问题，删除元素时要先find再erase”。
</insights_intro>

> **参考经验 (来自 hfjh)**：“在调试时，发现直接erase值会删除所有相同元素，导致错误。正确做法是先用find获取迭代器，再erase该迭代器。”

**点评**：这提醒我们，使用`multiset`时要注意元素可能重复，直接`erase(val)`会删除所有等于val的元素，而`erase(it)`仅删除迭代器指向的元素。这是处理重复元素时的常见陷阱，需要特别注意。

---

<conclusion>
通过对“JOISC 2021 道路の建設案”的分析，我们掌握了曼哈顿转切比雪夫距离、二分答案、双指针+集合统计的核心技巧。编程的关键在于理解问题的本质，选择合适的算法和数据结构。希望大家通过练习，能灵活运用这些方法解决更多问题！下次再见～💪
</conclusion>

---

---
处理用时：182.53秒
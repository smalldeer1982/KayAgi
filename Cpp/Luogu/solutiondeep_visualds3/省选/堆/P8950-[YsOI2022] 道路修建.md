# 题目信息

# [YsOI2022] 道路修建

## 题目背景

Ysuperman 正在给他幼儿园里的小朋友们准备一场模板测试，下面是一道模板题，他希望你可以帮他验一下题目。

## 题目描述

某地新建了 $n$ 座城市，拟定建造 $m$ 条**单向**道路，其中第 $i$ 条道路起点为 $u_i$，终点为 $v_i$，建造费用为正整数 $w_i$。

然而在道路开始修建之前突发紧急情况，需要马上选择这些道路中的一些来修建使得所有城市的人都可以走到某 $k$ 座城市中（也就是说，所有城市的人都可以走到这 $k$ 座城市中的**至少一座**城市中），你想要知道，如果这 $k$ 座城市是等概率随机在 $n$ 座城市中的选定的，那么期望的最小修建费用是多少。

为了避免分数输入输出，你只需要输出答案对 $998244353$ 取模的结果。

## 说明/提示

#### 样例 1 解释

总共有三种选定集合城市的方案：

1. 选定集合在城市 $1$，那么选择建造 $2\to 1,3\to 1$ 两条道路花费最少，为 $2+4=6$。

2. 选定集合在城市 $2$，那么选择建造 $1\to 2,3\to 1$ 两条道路花费最少，为 $1+4=5$。

3. 选定集合在城市 $3$，那么选择建造 $1\to 2,2\to 3$ 两条道路花费最少，为 $1+3=4$。

所以期望最小花费为 $(6+5+4)/3=5$。

#### 样例 2 解释

有 $6$ 种选择集合城市的方法：

1. 选城市 $1,2$，最小花费 $9$。

2. 选城市 $1,3$，最小花费 $6$。

3. 选城市 $1,4$，最小花费 $7$。

4. 选城市 $2,3$，最小花费 $5$。

5. 选城市 $2,4$，最小花费 $6$。

6. 选城市 $3,4$，最小花费 $3$。

所以期望最小花费为 $(9+6+7+5+6+3)\div 6=6$。

#### 样例 3 解释

这里太小写不下，只配个图算了：

![](https://cdn.luogu.com.cn/upload/image_hosting/cdnuoook.png)

#### 样例 4 解释

当集合城市选在 $1,2,3$ 时，城市 $4$ 无论如何都无法达到 $1,2,3$ 中的任意一个，所以答案为 $-1$。

#### 数据范围

对于 $10\%$ 的数据，满足 $n\le 15$，$m\le 30$。

对于 $30\%$ 的数据，满足 $n\le 20$，$m\le 50$。

另有 $5\%$ 的数据，满足所有 $w_i$ 相等。

另有 $5\%$ 的数据，满足 $k=n$。

另有 $5\%$ 的数据，满足 $k=n-1$。

另有 $10\%$ 的数据，满足 $m=n$。

另有 $20\%$ 的数据，满足 $k=1$。

对于 $100\%$ 的数据，满足 $2\le n\le 10^5$，$1\le m\le 2\times 10^5$，$1\le k\le n$，$1\le u_i,v_i\le n$，$0\le w_i\le 998244352$。

## 样例 #1

### 输入

```
3 4 1
1 2 1
2 1 2
2 3 3
3 1 4```

### 输出

```
5```

## 样例 #2

### 输入

```
4 6 2
1 2 1
1 3 3
2 3 2
3 4 5
4 1 4
4 2 6```

### 输出

```
6```

## 样例 #3

### 输入

```
8 16 3
5 6 7
7 2 10
4 6 4
5 7 5
8 4 12
1 3 8
2 3 6
4 1 8
1 7 2
8 3 1
2 5 3
6 4 11
7 3 14
3 8 9
8 1 13
6 7 16```

### 输出

```
160432162```

## 样例 #4

### 输入

```
4 1 3
2 4 1```

### 输出

```
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：[YsOI2022] 道路修建 深入学习指南 💡

<introduction>
今天我们要一起攻克这道“道路修建”的题目。这道题结合了图论、组合数学和高效数据结构的应用，通过分析，我们将理清核心思路，掌握关键技巧，最后还能通过有趣的像素动画直观感受算法过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（最小树形图、基环树处理）

🗣️ **初步分析**：
解决这道题的关键在于理解如何构造一个“最小费用道路集合”，使得所有城市能到达随机选中的k个城市之一，并计算期望。这本质上是一个**图论问题**，需要用到“最小树形图”（朱刘算法）的思想，处理图中的环结构（基环树），并结合组合数学计算期望。

简单来说，图论中的“最小树形图”是指以某个根节点为终点，其他所有节点都有且仅有一条指向父节点的边，形成树结构。本题中，我们需要为每个可能的k城市集合构造这样的树形图，取最小费用，再求平均。

- **题解思路对比**：两位题解作者均提到“基环树缩点”和“朱刘算法”的核心。1kri的思路强调基环树森林的环处理，通过缩点将环转化为大点；tobie的题解则结合朱刘算法，用可并堆维护最小出边，直接计算每条边的贡献，更具体且有代码实现。
- **核心算法流程**：首先为每个节点找最小出边，若形成环则缩点（将环视为一个整体），调整边权后重复此过程，直到无环。最终统计每条边被选中的方案数，计算期望。
- **可视化设计**：计划采用8位像素风格，用不同颜色的像素块表示城市（如红色环内点、蓝色普通点），动态演示缩点过程（环内点合并为一个大像素块）、边的选择（绿色箭头表示选中边），关键步骤（如发现环、缩点）伴随“叮”的音效，自动播放模式模拟算法执行。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的评估（思路清晰度、代码规范性、算法有效性等），以下题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：tobie (来源：洛谷题解)**
* **点评**：这份题解将朱刘算法与组合数学巧妙结合，思路非常清晰。代码中使用可并堆（带懒标记）高效维护每个节点的最小出边，用并查集处理缩点，结构规范（变量名如`rt[u]`表示u的堆根，`siz1[u]`表示缩点后大小）。算法上，通过拆贡献计算每条边的期望，时间复杂度O(n log²n)，适合竞赛场景。特别是对无解情况的判断（若存在缩点后集合大小+K≤n则无解），体现了严谨的边界处理。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点主要集中在以下三个方面，结合优质题解的思路，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何处理图中的环（基环树结构）**
    * **分析**：初始时，每个节点选择最小出边可能形成环（基环树）。此时需将环缩成一个点，调整环内边权（减去环内最小出边权），避免重复计算。例如，环上每个点的出边权需减去环的最小边权，这样缩点后新点的出边权即为原环连向外部的边权。
    * 💡 **学习笔记**：环的处理是关键，缩点后问题转化为更简单的子问题，这是图论中常用的“降维”技巧。

2.  **关键点2：如何计算每条边的期望贡献**
    * **分析**：期望等于所有可能k城市集合的最小费用之和除以总方案数（C(n,k)）。每条边的贡献等于“该边被选中的方案数”乘以边权。例如，边u→v的贡献系数为C(n-|S_u|,k)，其中S_u是u所在缩点后的集合大小（若S_u中没有选中的城市，u必须通过这条边连接外部）。
    * 💡 **学习笔记**：拆贡献是计算期望的常用方法，将整体问题分解为每条边的独立贡献，简化计算。

3.  **关键点3：如何高效维护最小出边（数据结构选择）**
    * **分析**：每个节点需要快速找到最小出边，可并堆（带懒标记）是高效选择。懒标记用于批量调整边权（如环缩点时边权减去环的最小边权），避免逐个修改。并查集用于维护缩点后的集合关系。
    * 💡 **学习笔记**：选择合适的数据结构（如可并堆）能大幅提升算法效率，懒标记技巧可简化批量操作。

### ✨ 解题技巧总结
- **问题分解**：将原问题拆解为“找最小出边→处理环→计算贡献”三阶段，每一步解决一个子问题。
- **缩点降维**：环的存在会导致无限循环，缩点后将环视为整体，简化图的结构。
- **组合数学预处理**：预先计算组合数C(n,k)及其逆元，避免重复计算，提升效率。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选取tobie题解的代码作为核心实现参考，该代码结合了朱刘算法和组合数学，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码来自tobie题解，完整实现了找最小出边、缩点处理、贡献计算等核心逻辑，是本题的典型高效实现。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;

    typedef long long ll;
    typedef pair<int,int> pii;
    namespace io{
        template<typename T> inline void gi(T &x) {
            x=0;char ch=getchar();
            while(ch<'0'||'9'<ch) ch=getchar();
            while('0'<=ch&&ch<='9') x=x*10+ch-'0',ch=getchar();
        }
    } using io::gi;

    const int N=5e5+9, mod=998244353;
    int fac[N], inv[N], ifac[N];

    void ycl(int lim=2e5) {
        fac[0]=fac[1]=inv[0]=inv[1]=ifac[0]=ifac[1]=1;
        for(int i=2;i<=lim;++i) {
            fac[i]=1ll*fac[i-1]*i%mod;
            inv[i]=1ll*(mod-mod/i)*inv[mod%i]%mod;
            ifac[i]=1ll*ifac[i-1]*inv[i]%mod;
        }
    }
    int C(int x,int y) { return x>=y&&y>=0?1ll*fac[x]*ifac[y]%mod*ifac[x-y]%mod:0; }
    int invC(int x,int y) { return x>=y&&y>=0?1ll*ifac[x]*fac[y]%mod*fac[x-y]%mod:0; }

    pii val[N];
    int siz[N], son[N][2], tag[N], dep[N], tcnt=0;
    int new_node(pii x) {
        int u=++tcnt; siz[u]=1; tag[u]=son[u][0]=son[u][1]=0; val[u]=x; return u;
    }
    void Add(int u,int x) { if(u) val[u].first+=x, tag[u]+=x; }
    void pushdown(int u) { if(tag[u]) Add(son[u][0],tag[u]), Add(son[u][1],tag[u]), tag[u]=0; }
    void pushup(int u) { siz[u]=siz[son[u][0]]+siz[son[u][1]]+1; dep[u]=dep[son[u][1]]+1; }
    int Merge(int u,int v) {
        if(!u||!v) return u+v;
        pushdown(u), pushdown(v);
        if(val[u]>val[v]) swap(u,v);
        son[u][1]=Merge(son[u][1],v);
        if(dep[son[u][0]]<dep[son[u][1]]) swap(son[u][0],son[u][1]);
        return pushup(u), u;
    }
    void pop(int &rt) { pushdown(rt); rt=Merge(son[rt][0],son[rt][1]); }

    int n, m, K;
    int rt[N], nxt[N], len[N], tp[N], siz1[N], bcj[N];

    int gettp(int x) { return tp[x]==x?x:tp[x]=gettp(tp[x]); }
    int getfa(int x) { return bcj[x]==x?x:bcj[x]=getfa(bcj[x]); }

    int main() {
        ycl(); gi(n); gi(m); gi(K);
        for(int i=1,u,v,w;i<=m;++i) {
            gi(u); gi(v); gi(w);
            if(u!=v) rt[u]=Merge(rt[u], new_node({w, v}));
        }
        for(int i=1;i<=n;++i) bcj[i]=tp[i]=i, siz1[i]=1;
        int ans=0;
        for(int u=1;u<=n;++u) {
            while(siz[rt[u]]) {
                auto [w, v]=val[rt[u]]; v=gettp(v);
                if(gettp(u)==v) { pop(rt[u]); continue; }
                ans=(ans + 1ll*C(n - siz1[gettp(u)], K) * (w%mod + mod)) % mod;
                if(getfa(u)==getfa(v)) {
                    int uu=v, d=w; pop(rt[u]); Add(rt[u], -d);
                    while(uu!=u) {
                        Add(rt[uu], -len[uu]); rt[u]=Merge(rt[u], rt[uu]); uu=gettp(nxt[uu]);
                    }
                    uu=v; while(uu!=u) {
                        siz1[u]+=siz1[uu]; bcj[uu]=tp[uu]=u; uu=gettp(nxt[uu]);
                    }
                } else {
                    nxt[u]=v; len[u]=w; bcj[u]=v; break;
                }
            }
            if(!siz[rt[u]] && siz1[u]+K<=n) { puts("-1"); return 0; }
        }
        printf("%lld\n", 1ll*ans*invC(n, K)%mod);
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先预处理组合数，然后用可并堆维护每个节点的最小出边。主循环中，对每个节点u，找到其最小出边v：若u和v在同一缩点集合中（环），则缩点并调整边权；否则记录边的贡献。最后统计所有边的贡献，乘以组合数逆元得到期望。

---
<code_intro_selected>
下面分析tobie题解的核心代码片段，理解其关键逻辑：
</code_intro_selected>

**题解一：tobie (来源：洛谷题解)**
* **亮点**：使用可并堆高效维护最小出边，带懒标记处理批量边权调整；并查集和缩点操作结合，高效处理环结构。
* **核心代码片段**：
    ```cpp
    // 可并堆合并与懒标记处理
    int Merge(int u,int v) {
        if(!u||!v) return u+v;
        pushdown(u), pushdown(v);
        if(val[u]>val[v]) swap(u,v);
        son[u][1]=Merge(son[u][1],v);
        if(dep[son[u][0]]<dep[son[u][1]]) swap(son[u][0],son[u][1]);
        return pushup(u), u;
    }
    void pop(int &rt) { pushdown(rt); rt=Merge(son[rt][0],son[rt][1]); }

    // 主循环处理每个节点的最小出边
    for(int u=1;u<=n;++u) {
        while(siz[rt[u]]) {
            auto [w, v]=val[rt[u]]; v=gettp(v);
            if(gettp(u)==v) { pop(rt[u]); continue; }
            ans=(ans + 1ll*C(n - siz1[gettp(u)], K) * (w%mod + mod)) % mod;
            // ... 缩点处理代码
        }
    }
    ```
* **代码解读**：
    - `Merge`函数实现可并堆的合并，`pushdown`处理懒标记（批量调整边权），保证堆顶始终是最小出边。
    - 主循环中，对每个节点u，取出堆顶的最小出边v。若u和v在同一缩点集合（环），则缩点（合并u和v所在的集合，调整边权）；否则计算该边的贡献（C(n-|S_u|,k) * 边权）。
* 💡 **学习笔记**：可并堆的懒标记技巧避免了逐个修改边权，大幅提升效率；缩点时合并集合大小，确保后续组合数计算正确。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“缩点”和“最小出边选择”的过程，我们设计一个“像素城市探险”动画，用8位风格演示算法步骤！
</visualization_intro>

  * **动画演示主题**：像素城市的“缩点大冒险”
  * **核心演示内容**：展示每个城市（像素方块）选择最小出边（绿色箭头），遇到环（红色方框）时缩点（合并为大像素块），并调整边权（箭头颜色变蓝），最终计算每条边的贡献。
  * **设计思路简述**：8位像素风格（如FC游戏画面）降低学习门槛；颜色标记（红环、绿边、蓝调整边）突出关键步骤；音效（“叮”提示选边，“嗡”提示缩点）强化操作记忆；自动播放模式模拟算法执行，帮助观察整体流程。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧是像素城市网格（每个城市是16x16像素块，编号显示在方块上）。
        - 右侧是控制面板（开始/暂停、单步、速度滑块）和组合数计算区（显示当前选中k值）。
        - 播放8位风格背景音乐（类似《超级玛丽》的轻快旋律）。

    2.  **选择最小出边**：
        - 每个城市方块顶部弹出可并堆（堆叠的小像素块，显示边权），堆顶边权最小（高亮黄色）。
        - 城市u的堆顶边（u→v）用绿色箭头连接，伴随“叮”音效，箭头旁显示边权w。

    3.  **环检测与缩点**：
        - 若u和v已连通（形成环），环上所有城市被红色方框包围，播放“嗡”音效。
        - 环内城市合并为一个大像素块（颜色变紫），显示缩点后的总大小（如“size=3”）。
        - 环内所有出边权自动减去环的最小边权（箭头颜色变蓝，边权数字更新）。

    4.  **贡献计算**：
        - 每条选中的边（绿色箭头）旁弹出贡献值（如“C(5,2) * 3”），组合数计算区同步显示数值。
        - 最终所有贡献值相加，除以C(n,k)，显示期望结果（金色数字）。

    5.  **AI自动演示模式**：
        - 点击“AI演示”，算法自动运行，城市方块像“贪吃蛇”一样逐个处理，缩点、选边流畅执行，学习者可观察完整流程。

    6.  **目标达成/无解提示**：
        - 若所有城市合法，最终期望数字闪烁金色，播放胜利音效（类似《星之卡比》的胜利旋律）。
        - 若存在无法覆盖的城市（如样例4），屏幕变红，显示“-1”并播放短促警报声。

  * **旁白提示**：
    - “看！城市u的最小出边是到v，边权是w。”
    - “发现环了！环内城市要合并成一个大点，边权需要调整哦～”
    - “这条边的贡献是C(n-3,2)*w，因为它所在的缩点集合有3个城市没被选中。”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到缩点、选边的每一步，理解算法如何高效处理环结构并计算期望，学习过程更有趣！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是最小树形图和缩点处理，这类技巧在图论中应用广泛。掌握后，我们可以尝试以下拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 最小树形图：用于有向图中找以某点为根的最小生成树（如网络构建最小成本问题）。
      - 缩点处理：在强连通分量（SCC）、2-SAT等问题中，缩点可简化图结构，降低复杂度。
      - 组合数学求期望：在概率型问题中，拆贡献计算每条边/元素的期望是常用方法。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4716** - [模板] 朱刘算法（最小树形图）
        * 🗣️ **推荐理由**：直接练习朱刘算法，巩固最小树形图的实现，与本题思路高度相关。
    2.  **洛谷 P3387** - 缩点（强连通分量）
        * 🗣️ **推荐理由**：练习缩点技巧，理解如何将复杂图转换为DAG，为本题的缩点处理打基础。
    3.  **洛谷 P1852** - [蓝桥杯 2016 省] 组合数问题
        * 🗣️ **推荐理由**：强化组合数的预处理与计算，本题中期望的计算依赖组合数，此题可提升相关能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本题解中未明确包含作者的个人学习心得分享，但通过代码和思路分析，我们可以总结以下经验：
</insights_intro>

> 在实现过程中，处理环结构时容易遗漏边权调整（如环内边权需减去环的最小边权），这会导致贡献计算错误。通过可并堆的懒标记技巧，可以高效处理批量边权调整，避免逐个修改的繁琐。此外，组合数的预处理要注意模数和逆元的计算，确保大数情况下的正确性。

**点评**：这些经验提醒我们，在处理图论中的环结构时，边权调整是关键步骤；而高效的数据结构（如可并堆+懒标记）能大幅简化实现。组合数的预处理需提前完成，避免重复计算影响效率。

---

<conclusion>
通过本次分析，我们掌握了“道路修建”题目的核心思路：用朱刘算法处理最小树形图，缩点解决环结构，组合数学计算期望。希望大家通过练习和可视化动画，深入理解这些技巧，在编程之路上更进一步！💪
</conclusion>

---
处理用时：172.87秒
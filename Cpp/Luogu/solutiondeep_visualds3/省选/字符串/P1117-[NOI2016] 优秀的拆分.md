# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果



---
# 💡 Kay的C++算法解析：优秀的拆分 深入学习指南 💡

<introduction>
今天我们来一起分析NOI2016的“优秀的拆分”这道题。这道题需要统计所有子串中能拆分为AABB形式的优秀拆分总数。通过这篇指南，我们将理解核心思路、关键算法，并掌握高效解题的技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理（LCP/LCS计算）+ 差分数组优化` (核心结合后缀数组/哈希与调和级数枚举)

🗣️ **初步分析**：
解决“优秀的拆分”问题，关键在于将AABB拆分为两个AA子串的拼接。例如，AABB可以看作AA（前半）和BB（后半）的连接，其中A和B是任意非空字符串。因此，我们需要统计：
- `f[i]`：以位置`i`结尾的AA子串数量；
- `g[i]`：以位置`i`开头的AA子串数量；
最终答案为所有`f[i] * g[i+1]`的和（即前半AA以`i`结尾，后半AA以`i+1`开头）。

### 核心难点与解决方案
难点1：直接枚举所有可能的AA子串会超时（O(n²)）。  
解决方案：利用“调和级数枚举长度”优化。枚举AA子串的半长`len`，每隔`len`设置关键点（如`len, 2len, 3len...`），每个AA子串必跨两个关键点。通过计算相邻关键点的LCP（最长公共前缀）和LCS（最长公共后缀），判断是否存在AA子串，并利用差分数组统计区间内的数量。

难点2：高效计算LCP和LCS。  
解决方案：使用后缀数组（SA）预处理，或哈希+二分法。后缀数组可在O(1)时间查询任意两后缀的LCP，反串的后缀数组可查询LCS。

### 可视化设计思路
我们将设计一个“像素探险家”动画：
- **场景**：8位像素风格的字符串网格，每个字符用彩色方块表示，关键点用金色标记。
- **核心步骤**：枚举`len`时，每隔`len`出现金色标记；计算LCP/LCS时，用绿色箭头从关键点向右（LCP）、向左（LCS）延伸，长度用数字显示；差分数组更新时，对应区间的方块颜色渐变（如从蓝到红），表示该区间内AA子串数量增加。
- **交互**：支持单步/自动播放，调速滑块，同步显示当前`len`、LCP/LCS值及对应的差分数组操作。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，以下题解表现突出（均≥4星）：
</eval_intro>

**题解一：何俞均（赞41）**  
* **点评**：此题解思路清晰，代码规范，完整实现了后缀数组预处理+调和级数枚举的优化方法。关键步骤（如LCP/LCS计算、差分统计）解释明确，代码中变量命名（如`Lcp`、`Lcs`）直观，边界处理严谨（如`min(Lcp, len)`），是典型的高效实现。

**题解二：George1123（赞32）**  
* **点评**：此题解用简洁的语言解释了核心思路（AA子串必跨关键点），代码结构工整，通过反串构建后缀数组计算LCS，差分统计部分逻辑清晰。特别亮点是将复杂的LCP/LCS计算封装为函数，提升可读性。

**题解三：bztMinamoto（赞24）**  
* **点评**：此题解采用哈希+二分法替代后缀数组，更适合对SA不熟悉的学习者。代码中通过`gethash`函数快速计算子串哈希值，二分查找LCP/LCS长度，虽然时间复杂度略高（O(n log²n)），但实现更易懂，适合理解基础思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，常见的核心难点及应对策略如下：
</difficulty_intro>

1.  **关键点：如何高效统计AA子串数量？**  
    * **分析**：直接枚举所有可能的AA子串会超时（O(n²)）。优化方法是枚举AA的半长`len`，每隔`len`设置关键点（如`i, i+len`）。通过计算相邻关键点的LCP（后缀最长公共前缀）和LCS（前缀最长公共后缀），判断是否存在AA子串。若`LCP + LCS ≥ len`，则存在`LCP + LCS - len + 1`个AA子串，用差分数组统计这些子串覆盖的区间。
    * 💡 **学习笔记**：调和级数枚举（Σn/len）的时间复杂度是O(n log n)，是此类问题的常用优化手段。

2.  **关键点：如何计算LCP和LCS？**  
    * **分析**：LCP（两后缀的最长公共前缀）可通过后缀数组（SA）预处理，利用`height`数组和ST表在O(1)时间查询。LCS（两前缀的最长公共后缀）可通过反串的后缀数组实现（将原串反转，LCS转化为反串的LCP）。
    * 💡 **学习笔记**：反串处理是解决前缀/后缀对称问题的常用技巧。

3.  **关键点：如何利用差分数组统计区间？**  
    * **分析**：AA子串覆盖的区间是连续的（如从`l`到`r`），差分数组`f`和`g`可高效记录区间加操作（`f[l]++`，`f[r+1]--`），最后通过前缀和得到每个位置的AA子串数量。
    * 💡 **学习笔记**：差分数组适合处理“区间加，单点查”问题，时间复杂度O(1)每次操作。

### ✨ 解题技巧总结
- **问题分解**：将AABB拆分为两个AA子串，转化为统计`f[i]`和`g[i]`。
- **调和级数优化**：枚举AA半长`len`，关键点法减少枚举次数。
- **反串处理**：用反串的后缀数组计算LCS，对称解决前缀问题。
- **差分数组**：高效统计区间内的AA子串数量。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，选择后缀数组+差分的高效实现作为通用核心代码。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了何俞均、George1123等题解的思路，使用后缀数组预处理LCP/LCS，调和级数枚举长度，差分数组统计`f`和`g`。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 3e4 + 5;
int n, lg[MAXN];
int f[MAXN], g[MAXN];
char s[MAXN];

struct SuffixArray {
    int sa[MAXN], rnk[MAXN], lcp[MAXN];
    int st[MAXN][16];
    char str[MAXN];

    void buildSA() {
        static int x[MAXN], y[MAXN], bln[MAXN];
        int M = 122;
        memset(bln, 0, sizeof(bln));
        for (int i = 1; i <= n; i++) bln[x[i] = str[i]]++;
        for (int i = 1; i <= M; i++) bln[i] += bln[i - 1];
        for (int i = n; i >= 1; i--) sa[bln[x[i]]--] = i;

        for (int k = 1; k <= n; k <<= 1) {
            int p = 0;
            for (int i = n - k + 1; i <= n; i++) y[++p] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > k) y[++p] = sa[i] - k;
            memset(bln, 0, sizeof(bln));
            for (int i = 1; i <= n; i++) bln[x[y[i]]]++;
            for (int i = 1; i <= M; i++) bln[i] += bln[i - 1];
            for (int i = n; i >= 1; i--) sa[bln[x[y[i]]]--] = y[i];
            swap(x, y); x[sa[1]] = p = 1;
            for (int i = 2; i <= n; i++) x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? p : ++p;
            if (p >= n) break;
            M = p;
        }
        for (int i = 1; i <= n; i++) rnk[i] = x[i];
        for (int i = 1, j = 0; i <= n; i++) {
            if (j) j--;
            while (str[i + j] == str[sa[rnk[i] - 1] + j]) j++;
            lcp[rnk[i]] = j;
        }
    }

    void buildST() {
        memset(st, 0x3f, sizeof(st));
        for (int i = 1; i <= n; i++) st[i][0] = lcp[i];
        for (int i = 1; i <= 15; i++)
            for (int j = 1; j <= n; j++)
                st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 << (i - 1))]);
    }

    int query(int l, int r) {
        int _l = l, _r = r;
        l = min(rnk[_l], rnk[_r]) + 1, r = max(rnk[_l], rnk[_r]);
        int t = lg[r - l + 1];
        return min(st[t][l], st[t][r - (1 << t) + 1]);
    }
} A, B;

void solve() {
    scanf("%s", s + 1); n = strlen(s + 1);
    A.str[0] = 0; memcpy(A.str + 1, s + 1, n); A.buildSA(); A.buildST();
    reverse(s + 1, s + n + 1);
    B.str[0] = 0; memcpy(B.str + 1, s + 1, n); B.buildSA(); B.buildST();
    reverse(s + 1, s + n + 1);

    memset(f, 0, sizeof(f)); memset(g, 0, sizeof(g));
    for (int len = 1; len <= n / 2; len++) {
        for (int i = len, j = i + len; j <= n; i += len, j += len) {
            int Lcp = min(A.query(i, j), len);
            int Lcs = min(B.query(n - i + 2, n - j + 2), len - 1);
            if (Lcp + Lcs >= len) {
                int t = Lcp + Lcs - len + 1;
                g[i - Lcs]++; g[i - Lcs + t]--;
                f[j + Lcp - t]++; f[j + Lcp]--;
            }
        }
    }

    for (int i = 1; i <= n; i++) f[i] += f[i - 1], g[i] += g[i - 1];
    long long ans = 0;
    for (int i = 1; i < n; i++) ans += 1LL * f[i] * g[i + 1];
    printf("%lld\n", ans);
}

int main() {
    for (int i = 2; i <= 30000; i++) lg[i] = lg[i >> 1] + 1;
    int T; scanf("%d", &T);
    while (T--) solve();
    return 0;
}
```
* **代码解读概要**：  
  代码首先预处理原串和反串的后缀数组（`A`和`B`），用于计算LCP和LCS。然后枚举AA的半长`len`，对每个关键点对`(i, i+len)`计算LCP和LCS，若满足条件则用差分数组更新`f`（结尾AA数）和`g`（开头AA数）。最后通过前缀和得到`f`和`g`，累加所有`f[i] * g[i+1]`得到答案。

---
<code_intro_selected>
接下来，我们赏析优质题解中的核心代码片段。
</code_intro_selected>

**题解一：何俞均（来源：个人博客）**  
* **亮点**：代码结构清晰，后缀数组构建与查询封装完整，差分数组操作简洁。
* **核心代码片段**：
```cpp
for (int Len = 1; Len <= N / 2; Len++) { 
    for (int i = Len, j = i + Len; j <= N; i += Len, j += Len) { 
        int Lcp = min(A.query(i, j), Len), Lcs = min(B.query(N - i + 2, N - j + 2), Len - 1); 
        int t = Lcp + Lcs - Len + 1; 
        if (Lcp + Lcs >= Len) {
            g[i - Lcs]++, g[i - Lcs + t]--; 
            f[j + Lcp - t]++, f[j + Lcp]--; 
        } 
    } 
} 
```
* **代码解读**：  
  枚举AA的半长`Len`，对每个关键点对`(i, j=i+Len)`计算LCP（原串的LCP）和LCS（反串的LCP）。若`LCP+LCS≥Len`，则存在`t`个AA子串，用差分数组在`g`（开头AA）和`f`（结尾AA）的对应区间做标记。例如，`g[i - Lcs]++`表示从`i-Lcs`开始的区间内，开头AA数增加1。
* 💡 **学习笔记**：差分数组的区间操作需注意边界（如`i-Lcs + t`），确保覆盖所有符合条件的AA子串。

**题解二：George1123（来源：个人博客）**  
* **亮点**：反串处理LCS的思路巧妙，代码中`B`为反串的后缀数组，直接复用LCP查询函数计算LCS。
* **核心代码片段**：
```cpp
int lcp = min(w, a.Lcp(l, r));
int lcs = min(w-1, b.Lcp(n-(l-1)+1, n-(r-1)+1));
if (lcp + lcs >= w) {
    int cov = lcp + lcs - w + 1;
    f[r + lcp - cov]++, f[r + lcp]--;
    g[l - lcs]++, g[l - lcs + cov]--;
}
```
* **代码解读**：  
  `lcp`是原串中`l`和`r`的LCP（最多`w`），`lcs`是反串中`n-l+1`和`n-r+1`的LCP（最多`w-1`）。若两者之和≥`w`，则存在`cov`个AA子串，更新`f`（结尾AA）和`g`（开头AA）的差分数组。
* 💡 **学习笔记**：反串的LCP等价于原串的LCS，利用这一点可简化代码。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解AA子串的统计过程，我们设计一个“像素探险家”动画，用8位复古风格展示关键步骤！
</visualization_intro>

  * **动画演示主题**：`像素探险家的AA大冒险`  
  * **核心演示内容**：枚举AA半长`len`，设置关键点，计算LCP/LCS，差分数组更新。

  * **设计思路简述**：  
    8位像素风降低学习压力，金色关键点标记帮助观察AA子串的位置；LCP/LCS用绿色箭头动态延伸，直观展示长度；差分数组的区间更新用颜色渐变（蓝→红）表示数量增加，配合“叮”音效强化记忆。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：字符串显示为彩色像素方块（如红色`a`、蓝色`b`），顶部显示控制面板（开始/暂停、单步、调速）。
    2. **枚举长度`len`**：下方进度条显示当前`len`，每隔`len`的位置弹出金色标记（如`len=2`时，位置2、4、6...标记）。
    3. **计算LCP/LCS**：从关键点`i`和`j=i+len`出发，向右（LCP）和向左（LCS）延伸绿色箭头，箭头长度实时显示（如LCP=3，箭头覆盖3个方块）。
    4. **差分数组更新**：若`LCP+LCS≥len`，对应区间的方块颜色从蓝渐变到红（如`g[i-Lcs]`到`g[i-Lcs+t]`），同时播放“叮”音效。
    5. **自动演示模式**：点击“AI演示”，算法自动枚举所有`len`，快速展示完整统计过程。
    6. **目标达成**：最终答案用金色数字弹出，播放胜利音效。

  * **旁白提示**：  
    - “现在枚举AA的半长`len=2`，关键点在位置2、4、6...”  
    - “绿色箭头向右是LCP（最长公共前缀），向左是LCS（最长公共后缀）！”  
    - “看，差分数组的区间被标记了，这里的AA子串数量增加了~”

<visualization_conclusion>
通过这个动画，我们能清晰看到AA子串的统计过程，理解LCP/LCS和差分数组的作用，学习效率大大提升！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下题目巩固字符串处理与AA子串统计的技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的关键点枚举、LCP/LCS计算、差分数组统计，可用于解决其他需要统计特定子串（如AAA、ABAB）的问题，或处理字符串的周期性分析（如寻找最小周期）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1117** - 本题原题（复习用）。  
        🗣️ **推荐理由**：巩固核心思路，熟悉后缀数组/哈希的应用。
    2.  **洛谷 P3809** - 后缀数组模板题。  
        🗣️ **推荐理由**：深入理解后缀数组的构建与LCP查询，为解决复杂字符串问题打基础。
    3.  **洛谷 P4248** - [AHOI2013] 差异。  
        🗣️ **推荐理由**：综合运用后缀数组和LCP数组，计算所有子串的差异值，提升字符串问题的分析能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自 bztMinamoto)**：“最初用哈希暴力法拿了95分，但最后5分需要优化。通过学习关键点枚举和差分数组，才理解如何将时间复杂度降到O(n log n)。调试时发现LCP和LCS的边界条件（如`min(LCP, len)`）容易出错，需要反复检查。”

> **点评**：作者的经验提醒我们，暴力法是理解问题的起点，但优化需要结合数学分析（如调和级数）和数据结构（如后缀数组）。调试时，边界条件（如LCP的最大长度限制）是常见错误点，需仔细验证。

-----

<conclusion>
“优秀的拆分”这道题通过将AABB分解为AA子串的拼接，结合后缀数组和差分数组优化，展示了字符串处理的巧妙思路。希望大家通过这篇指南，掌握核心算法，并在练习中举一反三！下一次挑战，我们再见~ 💪
</conclusion>

-----

---
处理用时：211.72秒
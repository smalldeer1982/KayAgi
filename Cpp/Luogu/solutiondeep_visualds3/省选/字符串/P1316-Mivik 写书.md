# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果



---
# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡

<introduction>
今天我们来一起分析“Mivik 写书”这道题。这道题需要计算随机生成字符串的期望复杂度（即所有非空本质不同子串的数量期望）。通过分析题解，我们会发现容斥原理是解决这类问题的关键。让我们一步步拆解思路，掌握核心技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`容斥原理（数学类技巧）`

🗣️ **初步分析**：
解决这道题的关键在于理解如何用容斥原理统计所有本质不同子串的期望数量。容斥原理就像“大扫除”——先算所有可能的子串，再减去重复的部分，再补回多减的，反复调整直到准确。  

题目要求计算期望，等价于求所有可能字符串的不同子串总数之和，再除以总字符串数（\(m^n\)）。直接枚举所有字符串显然不可行（\(m\)可能很大），但观察到子串的重复性可以通过容斥处理：  
- **核心思路**：枚举每个可能的子串长度\(x\)，再枚举该子串在原字符串中出现的位置集合（用二进制状态表示），通过并查集维护这些位置的字符约束（必须相同），最后用容斥计算每个状态的贡献（奇数次加，偶数次减）。  
- **核心难点**：如何处理重叠子串的字符约束（如子串在多个位置出现时，重叠部分的字符必须一致）、如何高效枚举状态并计算贡献。  

**可视化设计思路**：设计一个8位像素风格的动画，用不同颜色的方块表示字符位置。当枚举到某个子串出现位置集合时，用闪烁的像素箭头标记这些位置，并用连接线（像素线条）表示并查集的合并过程（例如，两个位置合并时，线条颜色从红色变为绿色）。关键操作（如合并、计算贡献）配合“叮”的音效，最终结果展示时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：Huasushis的容斥解法 (来源：Huasushis的博客)**
* **点评**：此题解思路清晰，从问题转化到容斥应用的推导非常适合新手理解。代码中详细注释了每一步的作用（如`sol函数`枚举子串长度和出现位置），并查集的使用简洁高效。特别是通过位运算优化状态枚举，时间复杂度控制得当（\(O(n^22^n)\)），实践价值高。

**题解二：7KByte的简洁实现 (来源：7KByte的代码)**
* **点评**：代码极其简洁，通过预计算位掩码和并查集操作，将核心逻辑压缩到极小的代码量。虽然注释较少，但变量命名（如`mt`存储位位置）和位运算技巧（`rp(i, w)`循环）体现了高效的编码习惯。算法上直接枚举所有可能状态，利用容斥符号（`bt[i]`表示奇偶性）计算贡献，是竞赛中常见的优化风格。

**题解三：Reunite的分步拆解 (来源：Reunite的题解)**
* **点评**：此题解明确将问题拆解为不同长度子串的独立贡献，逻辑层次清晰。代码中`work函数`专门处理单个长度的子串，模块化设计提高了可读性。并查集的合并过程（`Find函数`路径压缩）和贡献计算（`ss`统计自由位置数）步骤明确，适合学习如何将抽象思路转化为代码。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理子串的重复性和字符约束。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：如何枚举子串的出现位置？**
    * **分析**：子串长度为\(x\)时，可能的起始位置有\(n-x+1\)个（如长度为2的子串在长度为4的原串中起始位置是1、2、3）。用二进制状态（如`i`的每一位表示是否选择该起始位置）枚举所有非空子集，共\(2^{n-x+1}-1\)种状态。  
    * 💡 **学习笔记**：二进制状态枚举是处理“选或不选”类问题的常用技巧，适合小范围（如\(n≤20\)）的枚举。

2.  **关键点2：如何处理重叠子串的字符约束？**
    * **分析**：当子串在多个位置出现时（如起始位置1和2的长度为2的子串重叠），重叠位置的字符必须相同。用并查集维护这些位置的连通性（相同字符的位置属于同一集合），最终连通块数即为自由选择的字符数（每块选一个字符）。  
    * 💡 **学习笔记**：并查集是处理“等价关系”的利器，能高效合并和查询元素所属集合。

3.  **关键点3：如何应用容斥计算贡献？**
    * **分析**：每个状态（子串出现位置集合）的贡献为\((-1)^{\text{popcount}(S)+1} \times m^{\text{自由位置数}}\)。其中，\(\text{popcount}(S)\)是集合中元素个数（奇数次加，偶数次减），\(m^{\text{自由位置数}}\)是该状态下的字符串数量。  
    * 💡 **学习笔记**：容斥的核心是“加奇减偶”，通过调整符号排除重复计数的影响。

### ✨ 解题技巧总结
- **问题分解**：将总问题拆解为不同长度子串的独立贡献（因不同长度子串本质不同）。  
- **位运算优化**：用二进制状态枚举子串出现位置，结合位掩码（如`(1<<x)-1`）快速处理重叠部分。  
- **并查集维护约束**：通过并查集合并重叠位置的字符约束，统计自由选择的字符块数。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了清晰性和效率。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Huasushis和Reunite的思路，通过枚举子串长度和出现位置，用并查集维护字符约束，最后应用容斥计算总贡献。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long;
    const int MOD = 1e9 + 7;

    int n;
    ll m;
    ll ans = 0;

    ll qpow(ll x, ll y) {
        ll res = 1;
        while (y) {
            if (y & 1) res = res * x % MOD;
            y >>= 1;
            x = x * x % MOD;
        }
        return res;
    }

    int fa[25];
    int find(int x) {
        return x == fa[x] ? x : fa[x] = find(fa[x]);
    }

    void solve(int len) {
        int pos_num = n - len + 1; // 子串可能的起始位置数
        for (int s = 1; s < (1 << pos_num); ++s) { // 枚举所有非空位置集合
            // 初始化并查集
            for (int i = 0; i < len; ++i) fa[i] = i;
            int free_blocks = 0; // 自由选择的字符块数（连通块数+未覆盖的位置）
            
            // 处理每个位置是否被覆盖，并合并重叠字符
            vector<int> covered(n, 0); // 标记位置是否被子串覆盖
            for (int j = 0; j < pos_num; ++j) {
                if (s & (1 << j)) { // 第j个起始位置被选中
                    int start = j;
                    for (int k = 0; k < len; ++k) {
                        int pos = start + k;
                        covered[pos] = 1;
                        // 合并当前子串的第k位与第一个位置的字符
                        int u = find(k);
                        int v = find(0);
                        if (u != v) fa[u] = v;
                    }
                }
            }
            
            // 统计连通块数（自由选择的字符块）
            for (int i = 0; i < len; ++i) {
                if (find(i) == i) free_blocks++;
            }
            // 统计未被覆盖的位置（这些位置可自由选择字符）
            for (int i = 0; i < n; ++i) {
                if (!covered[i]) free_blocks++;
            }
            
            // 容斥：奇数次加，偶数次减
            ll cnt = qpow(m, free_blocks);
            if (__builtin_parity(s)) ans = (ans + cnt) % MOD;
            else ans = (ans - cnt + MOD) % MOD;
        }
    }

    int main() {
        cin >> n >> m;
        for (int len = 1; len <= n; ++len) solve(len);
        // 总字符串数为m^n，求期望需除以m^n
        ll inv_mn = qpow(qpow(m, n), MOD - 2);
        ans = ans * inv_mn % MOD;
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先枚举子串长度`len`，对每个长度枚举所有可能的起始位置集合（二进制状态`s`）。通过并查集合并重叠位置的字符约束，统计自由选择的字符块数（`free_blocks`），再根据容斥原理计算该状态的贡献。最后除以总字符串数\(m^n\)得到期望。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其中的亮点：
</code_intro_selected>

**题解一：Huasushis的`sol函数`**
* **亮点**：通过位掩码`b = (1 << x) - 1`快速处理子串的重叠部分，用`c`变量动态维护最近`x`位的状态，代码逻辑简洁。
* **核心代码片段**：
    ```cpp
    void sol(int x) {
        int a = (1 << (n - x + 1)), b = (1 << x) - 1;
        for (int i = 1; i < a; ++i) {
            int c = 0, tot = 0;
            for (int j = 0; j < x; ++j) fa[j] = j;
            for (int j = 0; j < n; ++j) {
                c = (c << 1) | ((i >> j) & 1);
                c &= b;
                if (!c) {
                    ++tot;
                } else {
                    int t = c - (c & -c), tmp = getfa(__builtin_ctz(c));
                    while (t) {
                        fa[getfa(__builtin_ctz(t))] = tmp;
                        t -= t & -t;
                    }
                }
            }
            // ... 后续统计贡献
        }
    }
    ```
* **代码解读**：  
  `sol(x)`处理长度为`x`的子串。`a`是起始位置的状态数（\(2^{n-x+1}\)），`b`是掩码（保留最近`x`位的状态）。循环`i`枚举所有非空状态。`c`变量动态维护当前处理的位置是否属于子串的起始位置集合，通过位运算快速更新。当`c`非零时（表示当前位置属于某个子串的起始位置），用并查集合并该子串的所有字符位置（`tmp`是第一个位置的根，`t`是剩余位置，循环合并）。  
* 💡 **学习笔记**：位掩码和动态维护状态是处理重叠问题的高效方法，能显著减少计算量。

**题解二：7KByte的`calc函数`**
* **亮点**：预计算`mt`数组存储位位置，用`rp`宏简化循环，代码极其紧凑。
* **核心代码片段**：
    ```cpp
    void calc(int x){
        int s = n - x + 1, o = (1 << x) - 1, w = (1 << s) - 1;
        rp(i, w){
            int c = 0, k = 0;
            rep(j, 0, x - 1)fa[j] = j;
            rep(j, 0, n - 1){
                c = (c << 1) | (1 & (i >> j)), c &= o;
                if(c){
                    int p = get(mt[c & -c]), t = c - (c & -c); 
                    for(; t; t -= t & -t)fa[get(mt[t & -t])] = p;
                }
                else k++;
            }
            // ... 后续统计贡献
        }
    }
    ```
* **代码解读**：  
  `calc(x)`处理长度为`x`的子串。`s`是起始位置数，`o`是掩码（保留`x`位）。循环`i`枚举所有状态。`c`动态维护当前处理的位置状态，若`c`非零（表示属于子串起始位置集合），则提取最低位的位置（`c & -c`）作为根，合并其他位置（`t`是剩余位）。`k`统计未被覆盖的位置数。  
* 💡 **学习笔记**：预计算和宏定义能简化重复代码，提高编码效率，但需注意可读性。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解容斥和并查集的过程，我们设计一个“像素字符探险”动画，用8位风格演示子串枚举、合并约束和贡献计算。
</visualization_intro>

  * **动画演示主题**：`像素字符的子串探险`
  * **核心演示内容**：以长度为3的子串为例，展示如何枚举起始位置集合（如选择位置1和2），用并查集合并重叠字符的位置（如位置1+2的子串与位置2+3的子串重叠，合并字符2和3），最后计算该状态的贡献。
  * **设计思路简述**：8位像素风格（如FC游戏画面）降低学习压力；动态展示并查集合并过程（不同颜色方块代表不同连通块，合并时颜色统一）；关键操作（如状态枚举、合并、贡献计算）配合音效，强化记忆。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：  
        屏幕左侧显示原字符串的像素格子（n个方块，默认灰色），右侧显示控制面板（单步/自动按钮、速度滑块）。顶部显示当前处理的子串长度（如`len=3`）。
    2.  **枚举状态**：  
        点击“开始”后，自动播放枚举过程。例如，处理`len=3`时，状态`s=0b11`（选择起始位置1和2），用黄色箭头标记这两个位置。
    3.  **合并字符约束**：  
        对于每个选中的起始位置，子串覆盖的字符位置（如位置1-3和2-4）用绿色边框高亮。并查集合并时，用红色线条连接重叠位置（如位置2-3），合并后线条变为蓝色（表示同一连通块），对应方块颜色统一（如红色）。
    4.  **统计自由块数**：  
        未被覆盖的位置（灰色方块）计数为`free_blocks`的一部分；连通块数（不同颜色方块的数量）也加入`free_blocks`。数值实时显示在屏幕上方。
    5.  **计算贡献**：  
        根据状态`s`的奇偶性（`popcount=2`，偶数），贡献为负，屏幕显示`-m^free_blocks`。音效为“噗”的短音（表示减去）。
    6.  **最终结果**：  
        所有状态处理完成后，计算总贡献并除以\(m^n\)，屏幕显示最终期望，播放“叮”的胜利音效。

  * **旁白提示**：
    - “现在处理长度为3的子串，枚举起始位置集合`0b11`（选择位置1和2）。”
    - “注意看，这两个子串在位置2-3重叠，它们的字符必须相同，用并查集合并这两个位置！”
    - “当前自由块数是5，所以贡献是\(m^5\)，但因为是偶数个起始位置，要减去这个值哦～”

<visualization_conclusion>
通过这样的动画，我们可以直观看到容斥的“加加减减”过程，以及并查集如何维护字符约束，让抽象的算法变得“看得见、听得见”！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
容斥原理和子串计数的思路不仅适用于本题，还能解决许多类似问题。以下是相关练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    容斥原理可用于统计“至少出现一次”“恰好出现k次”等问题（如统计所有子串中出现过的不同字符数）；并查集可用于处理“等价类”约束（如字符串中相同字符的位置关系）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1450 [HAOI2008]硬币购物**  
        * 🗣️ **推荐理由**：经典容斥题，需处理“不能超过”的约束，与本题的容斥思想类似。
    2.  **洛谷 P3166 [CQOI2014]数三角形**  
        * 🗣️ **推荐理由**：通过容斥计算不共线的三点组数，锻炼对几何问题的容斥应用。
    3.  **洛谷 P2150 [SDOI2009]取石子游戏**  
        * 🗣️ **推荐理由**：结合博弈论和容斥，需枚举所有可能的初始状态，适合提升综合解题能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题心得，这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自 Huasushis)**：“这道题一开始觉得很难，但拆分子串长度后，发现每个长度的处理是独立的。用并查集维护约束时，一开始忘记处理重叠部分，后来通过模拟小例子（如n=2，m=2）才发现问题。”  
> **点评**：拆分子问题（如按长度拆分）是解决复杂问题的关键。遇到错误时，手动模拟小例子能快速定位问题，这是非常实用的调试技巧！

---

<conclusion>
通过分析“Mivik 写书”的题解，我们掌握了容斥原理在子串计数中的应用，学会了用并查集处理字符约束，还设计了可视化动画辅助理解。编程的魅力在于将复杂问题拆解为可操作的步骤，希望大家继续练习，在代码中感受逻辑的美妙！💪
</conclusion>

---
处理用时：182.62秒
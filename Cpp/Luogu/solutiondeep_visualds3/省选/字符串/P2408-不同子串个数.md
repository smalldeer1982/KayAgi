# 题目信息

# 不同子串个数

## 题目背景

因为 NOI 被虐傻了，蒟蒻的 YJQ 准备来学习一下字符串，于是它碰到了这样一道题：


## 题目描述

给你一个长为 $n$ 的字符串，求不同的子串的个数。

我们定义两个子串不同，当且仅当有这两个子串长度不一样或者长度一样且有任意一位不一样。

子串的定义：原字符串中连续的一段字符组成的字符串。


## 说明/提示

### 提示

请使用64位整数来进行输出。

### 数据规模与约定
- 对于 $30\%$ 的数据，保证 $n\le 1000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，字符串中只有小写英文字母。


## 样例 #1

### 输入

```
5
aabaa```

### 输出

```
11```

## 样例 #2

### 输入

```
3
aba```

### 输出

```
5```

# AI分析结果



---
# 💡 Kay的C++算法解析：不同子串个数 深入学习指南 💡

<introduction>
今天我们来一起分析“不同子串个数”这道经典的字符串处理题。这道题需要高效计算一个字符串中所有本质不同的子串数量，涉及到后缀数组（SA）和后缀自动机（SAM）等高级算法。本指南将帮助大家梳理核心思路，理解关键算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理（后缀数组/后缀自动机应用）`

🗣️ **初步分析**：
解决“不同子串个数”的关键在于高效统计重复子串并去重。核心算法有两种思路：  
- **后缀数组（SA）**：所有子串可看作是字符串所有后缀的前缀集合。通过将后缀排序，利用`Height数组`（相邻后缀的最长公共前缀）统计重复子串数，总子串数（n(n+1)/2）减去重复数即为答案。  
- **后缀自动机（SAM）**：SAM的每个状态代表一组子串，通过状态转移构建自动机后，每个状态的贡献为其长度减去父节点长度，累加所有状态的贡献即为不同子串数。  

核心难点在于理解SA的排序逻辑与Height数组的计算，以及SAM的状态转移与父节点（link）的作用。可视化设计中，我们可以用像素动画模拟后缀排序的过程（如像素块排序），并高亮显示Height数组的计算过程；SAM则可用状态节点扩展的动画，展示每个新字符插入时的状态分裂与link更新。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码可读性、算法效率等维度，以下题解因逻辑清晰、实现高效且具有启发性，值得重点参考：
</eval_intro>

**题解一：Leap_Frog的SA与SAM双解法（赞35）**  
* **点评**：此解详细展示了SA和SAM两种经典方法。SA部分通过基数排序构建后缀数组，线性计算Height数组，逻辑直白；SAM部分利用DAG的拓扑排序统计路径数，代码规范（如变量名`len`、`fa`含义明确）。亮点在于同时覆盖两种算法，适合对比学习，且注释清晰，边界处理严谨（如初始化`lst=1`）。

**题解二：Rorschachindark的SAM动态维护（赞21）**  
* **点评**：此解提出SAM的优化思路，动态维护答案（每次插入字符时直接累加`len[q] - len[fa[q]]`），避免拓扑排序，效率更高（实测快一倍）。代码简洁（如`Insert`函数仅20行），变量命名直观（`len`、`fa`），关键步骤（如克隆节点处理）注释明确，实践价值高。

**题解三：Oracle的SA实现（赞16）**  
* **点评**：此解专注SA方法，代码结构工整（`get_SA`与`get_height`函数分离），详细实现了后缀数组的基数排序与Height数组的线性计算。亮点在于对SA模板的清晰封装，适合初学者理解SA的核心步骤（如双关键字排序）。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，常见的核心难点及应对策略如下：
</difficulty_intro>

1.  **关键点1：后缀数组（SA）的构建**  
    * **分析**：SA的构建需通过基数排序完成双关键字排序（当前字符+下一段字符）。关键是理解`sa`（后缀排名数组）和`rank`（后缀的排名）的更新逻辑。例如，每次迭代将排序范围扩大一倍（如从长度1到2、4...），直到所有后缀排名唯一。  
    * 💡 **学习笔记**：SA的构建是基数排序的典型应用，双关键字排序是其核心技巧。

2.  **关键点2：Height数组的计算**  
    * **分析**：Height数组表示相邻后缀的最长公共前缀。利用性质`h[i] ≥ h[i-1]-1`（h[i]为当前后缀与前一名后缀的LCP），可线性计算Height数组。例如，从`h[i-1]-1`开始比较字符，避免重复计算。  
    * 💡 **学习笔记**：线性计算Height的关键是利用前一次结果减少比较次数。

3.  **关键点3：后缀自动机（SAM）的状态转移**  
    * **分析**：SAM的每个状态代表一组子串，`len`表示该状态的最长子串长度，`fa`（link）指向该状态的后缀链接（更短的子串）。插入新字符时，可能需要克隆节点（`nq`）以保持状态的正确性。每个新状态的贡献为`len[q] - len[fa[q]]`（新增的不同子串数）。  
    * 💡 **学习笔记**：SAM的核心是状态的分裂与合并，理解`fa`指针的作用是掌握SAM的关键。

### ✨ 解题技巧总结
- **问题转化**：将“统计不同子串”转化为“总子串数减去重复数”（SA）或“累加状态贡献”（SAM）。  
- **模板复用**：SA和SAM的构建是经典模板，熟练掌握后可快速迁移到类似问题（如最长公共子串、子串出现次数）。  
- **边界处理**：注意字符串索引的起始（如从1开始还是0）、空串的排除（SAM中根节点不计数）。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，分别展示SA和SAM两种方法的典型代码。
</code_intro_overall>

### 本题通用核心C++实现参考（SA方法）
* **说明**：综合Leap_Frog和Oracle的SA实现，代码规范且高效，适用于1e5数据规模。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 10;
int n, m;
char s[MAXN];
int sa[MAXN], rk[MAXN], height[MAXN];
int x[MAXN], y[MAXN], cnt[MAXN];

void get_sa() {
    m = 127; // 初始字符范围（小写字母）
    memset(cnt, 0, sizeof(cnt));
    for (int i = 1; i <= n; ++i) cnt[x[i] = s[i]]++;
    for (int i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
    for (int i = n; i >= 1; --i) sa[cnt[x[i]]--] = i;

    for (int k = 1; k <= n; k <<= 1) {
        int p = 0;
        // 第二关键字排序：处理长度不足k的后缀
        for (int i = n - k + 1; i <= n; ++i) y[++p] = i;
        // 第二关键字排序：处理长度足够的后缀
        for (int i = 1; i <= n; ++i) if (sa[i] > k) y[++p] = sa[i] - k;

        // 基数排序第一关键字（x[y[i]]）
        memset(cnt, 0, sizeof(cnt));
        for (int i = 1; i <= n; ++i) cnt[x[y[i]]]++;
        for (int i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
        for (int i = n; i >= 1; --i) sa[cnt[x[y[i]]]--] = y[i];

        // 更新rank数组
        swap(x, y);
        p = 1;
        x[sa[1]] = 1;
        for (int i = 2; i <= n; ++i)
            x[sa[i]] = (y[sa[i]] == y[sa[i - 1]] && y[sa[i] + k] == y[sa[i - 1] + k]) ? p : ++p;
        if (p == n) break;
        m = p;
    }
}

void get_height() {
    int k = 0;
    for (int i = 1; i <= n; ++i) rk[sa[i]] = i;
    for (int i = 1; i <= n; ++i) {
        if (rk[i] == 1) { k = 0; continue; }
        if (k) k--;
        int j = sa[rk[i] - 1];
        while (i + k <= n && j + k <= n && s[i + k] == s[j + k]) k++;
        height[rk[i]] = k;
    }
}

int main() {
    scanf("%d%s", &n, s + 1);
    get_sa();
    get_height();
    long long ans = 1LL * n * (n + 1) / 2;
    for (int i = 1; i <= n; ++i) ans -= height[i];
    printf("%lld\n", ans);
    return 0;
}
```
* **代码解读概要**：代码分为SA构建、Height计算和答案统计三部分。`get_sa`通过基数排序完成双关键字排序，构建后缀数组；`get_height`利用线性方法计算相邻后缀的最长公共前缀；主函数计算总子串数并减去重复部分（Height数组之和）。

---

<code_intro_selected>
接下来，分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：Leap_Frog的SAM实现（部分代码）**  
* **亮点**：利用拓扑排序计算SAM的路径数，清晰展示SAM的DAG性质。  
* **核心代码片段**：
```cpp
struct node{int len,fa,s[26];}a[200005];
int n,lst=1,cnt=1;char s[100005];long long ans[200005];
void ins(int c) {
    int p=lst,np=lst=++cnt;a[np].len=a[p].len+1;
    for(;p&&!a[p].s[c];p=a[p].fa) a[p].s[c]=np;
    if(!p) {a[np].fa=1;return;}
    int q=a[p].s[c];
    if(a[q].len==a[p].len+1) {a[np].fa=q;return;}
    int nq=++cnt;a[nq]=a[q],a[nq].len=a[p].len+1,a[q].fa=a[np].fa=nq;
    for(;p&&a[p].s[c]==q;p=a[p].fa) a[p].s[c]=nq;
}
long long dfs(int x) {
    if(ans[x]) return ans[x];
    for(int i=0;i<26;i++) if(a[x].s[i]) ans[x]+=dfs(a[x].s[i])+1;
    return ans[x];
}
```
* **代码解读**：`ins`函数实现SAM的状态扩展（插入字符`c`），处理克隆节点（`nq`）以维护状态正确性；`dfs`函数通过记忆化搜索统计每个状态的路径数（即不同子串数）。例如，`a[np].len`是新状态的最长子串长度，`a[np].fa`是其后缀链接。  
* 💡 **学习笔记**：SAM的每个状态代表一组子串，其路径数即为该状态对应的不同子串数。

**题解二：Rorschachindark的SAM动态维护（部分代码）**  
* **亮点**：动态维护答案，避免拓扑排序，时间复杂度更优。  
* **核心代码片段**：
```cpp
void Insert (int c) {
    int f = lst, q = ++node; lst = q;
    len[q] = len[f] + 1;
    while (f && !ch[f][c]) ch[f][c] = q, f = fa[f];
    if (!f) fa[q] = 1;
    else {
        int x = ch[f][c];
        if (len[x] == len[f] + 1) fa[q] = x;
        else {
            int p = ++node;
            fa[p] = fa[x], len[p] = len[f] + 1;
            memcpy(ch[p], ch[x], sizeof(ch[x]));
            fa[x] = fa[q] = p;
            while (f && ch[f][c] == x) ch[f][c] = p, f = fa[f];
        }
    }
    ans += len[q] - len[fa[q]]; // 动态累加贡献
}
```
* **代码解读**：每次插入字符时，直接计算新状态`q`的贡献（`len[q] - len[fa[q]]`），无需后续拓扑排序。例如，`len[q]`是新状态的最长子串长度，`fa[q]`是其后缀链接，两者的差即为该状态新增的不同子串数。  
* 💡 **学习笔记**：动态维护答案的关键在于理解每个新状态的贡献仅与自身和父节点长度有关。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解SA的排序过程和Height数组的计算，我们设计一个“后缀排序像素探险”的8位风格动画！
</visualization_intro>

  * **动画演示主题**：`后缀排序大冒险——像素块的排序与消消乐`  
  * **核心演示内容**：模拟后缀数组的构建（基数排序）和Height数组的计算过程，用像素块表示后缀，颜色区分排名，高亮显示公共前缀。  

  * **设计思路简述**：采用8位像素风格（如FC游戏的方块、简洁色调），通过动态排序、颜色变化和音效反馈，帮助理解SA的双关键字排序逻辑和Height数组的线性计算。例如，排序时像素块按字符值滑动到对应位置（基数排序），计算Height时用渐变色条表示公共前缀长度。  

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：屏幕左侧显示原字符串（如`aabaa`），右侧是“后缀森林”（每个后缀为一个像素块，初始按位置排列）。  
    2. **基数排序第一关键字**：像素块按首字符值（如`a`→红色，`b`→蓝色）滑动到对应桶中，形成初始排名（`sa`数组）。  
    3. **双关键字排序**：扩大排序范围（如长度2），像素块按“首字符+下一段字符”的组合值重新排序，颜色渐变表示新排名。  
    4. **Height数组计算**：排序后的后缀像素块两两对比，公共前缀部分用金色高亮，长度值（`height[i]`）显示在下方，伴随“叮”的音效。  
    5. **答案计算**：总子串数（`n(n+1)/2`）以大数字显示，随后逐个减去`height`值（像素块逐个消失），最终显示剩余的不同子串数。  

  * **旁白提示**：
    - “看！这些像素块代表原字符串的后缀，我们需要按字典序给它们排好队~”  
    - “现在比较的是前两个字符的组合值，红色块的排名更新啦！”  
    - “这两个后缀的公共前缀有3个字符，所以重复的子串数要减去3哦~”  

<visualization_conclusion>
通过这样的动画，我们能直观看到后缀排序的每一步，以及Height数组如何帮助我们排除重复子串，让抽象的算法变得“看得见、摸得着”！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以尝试以下拓展练习，巩固字符串处理的核心算法：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    SA和SAM不仅用于统计不同子串，还可解决：  
    - 最长公共子串（LCS）：通过合并多个字符串的SA，找最大Height值。  
    - 子串出现次数：SAM中状态的`size`属性记录该子串的出现次数。  
    - 回文子串统计：结合Manacher算法或回文自动机（PAM）。  

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3809** - `【模板】后缀排序`  
        * 🗣️ **推荐理由**：直接练习后缀数组的构建，巩固SA的核心步骤。  
    2.  **洛谷 P3167** - `[CQOI2015] 选数`  
        * 🗣️ **推荐理由**：结合SAM处理多串公共子串问题，拓展SAM的应用场景。  
    3.  **洛谷 P1117** - `[NOI2015] 品酒大会`  
        * 🗣️ **推荐理由**：利用SA和并查集处理最长公共前缀的统计问题，提升综合应用能力。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自Leap_Frog)**：“在实现SA时，容易因基数排序的桶大小错误导致排名错误，建议初始桶大小设为字符集最大值（如127），并在每次迭代后更新桶大小。”  
> **参考经验 (来自Rorschachindark)**：“SAM的克隆节点处理是关键，若`len[x] != len[f] + 1`，必须新建节点`nq`，否则会导致状态错误。”  

**点评**：这些经验提醒我们，在实现SA和SAM时，需特别注意基数排序的桶大小、克隆节点的条件判断等细节。调试时可打印中间数组（如`sa`、`rank`），或用小样例（如`aabaa`）验证正确性。

---

<conclusion>
本次关于“不同子串个数”的解题分析就到这里。希望通过这份指南，大家能掌握SA和SAM的核心思想，理解如何用算法高效解决字符串问题。记住，多动手写代码、多调试，是提升编程能力的关键！下次我们再一起探索新的算法挑战~ 💪
</conclusion>

---
处理用时：188.36秒
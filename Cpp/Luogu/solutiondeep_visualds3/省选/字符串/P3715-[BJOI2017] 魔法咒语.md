# 题目信息

# [BJOI2017] 魔法咒语

## 题目描述

Chandra 是一个魔法天才。

从一岁时接受火之教会洗礼之后，Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。

直到十四岁，开始学习威力强大的禁咒法术时，Chandra 才遇到了障碍。

根据火之魔法规则，禁咒的构成单位是 $N$ 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 $L$ 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。

但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时，Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。

这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。

很多年过去了，在一次远古遗迹探险中，Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。


禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 $M$ 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。

例如，若 `banana` 是唯一的忌讳词语，`an`、`ban`、`analysis` 是基本词汇，禁咒长度须是 $11$，则 `bananalysis` 是无效法术，`analysisban`、`anbanbanban` 是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。

谜题破解，Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。

由于答案可能很大，你只需要输出答案模 $10 ^ 9 + 7$ 的结果。


## 说明/提示

【样例解释 1】

有效的禁咒法术共有 $14$ 种：`boom/bang/oo`，`oo/oo/oo/oo/oo`，`oo/oo/ooh/ooh`，`oo/ooh/oo/ooh`，`oo/ooh/ooh/oo`，`ooh/oo/oo/ooh`，`ooh/oo/ooh/oo`，`
ooh/ooh/boom`，`ooh/ooh/oo/oo`，`ooh/ooh/bang`，`ooh/bang/ooh`，`bang/oo/oo/oo`，`bang/ooh/ooh`，`bang/bang/oo`。

【样例解释 2】

有效的禁咒法术有 `a/ab`，`ab/a`，`aba` 共三种。注意，`ab/a` 和 `aba` 算成两种不同的禁咒法术。

【数据规模与约定】

本题一共有 $10$ 个测试点。

下表是每个测试点的数据规模和约定：

 ![](https://cdn.luogu.com.cn/upload/pic/5191.png) 

对于 $100\%$ 的数据，$1 \le N, M \le 50，1 \le L \le 10^8$，基本词汇的长度之和不超过 $100$，忌讳词语的长度之和不超过 $100$。保证基本词汇不重复，忌讳词语不重复。


## 样例 #1

### 输入

```
4 2 10
boom
oo
ooh
bang
ob
mo```

### 输出

```
14```

## 样例 #2

### 输入

```
3 1 3
a
ab
aba
aaa```

### 输出

```
3```

## 样例 #3

### 输入

```
3 1 14
ban
an
analysis
banana```

### 输出

```
15```

# AI分析结果



---
# 💡 Kay的C++算法解析：[魔法咒语] 深入学习指南 💡

<introduction>
今天我们来一起分析“魔法咒语”这道C++编程题。这道题需要结合AC自动机、动态规划（DP）和矩阵快速幂等多种算法技巧，是一道综合性很强的题目。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`AC自动机+动态规划+矩阵快速幂`

🗣️ **初步分析**：
解决“魔法咒语”这道题的关键在于处理禁忌词的匹配问题，并高效计算合法方案数。简单来说，AC自动机是一个多模式匹配工具，就像一个“智能字典”，能快速判断字符串中是否包含任何禁忌词；动态规划（DP）用于计数，记录不同长度和匹配状态下的方案数；矩阵快速幂则是处理大L（如1e8）的“加速器”，将线性时间的DP优化到对数时间。

在本题中，AC自动机用于预处理所有禁忌词，标记出所有可能触发禁忌的状态；DP状态`dp[i][j]`表示当前字符串长度为`i`，且在AC自动机上匹配到状态`j`时的合法方案数。对于L较小的情况（≤100），直接通过DP递推即可；对于L较大的情况（>100），由于基本词汇长度≤2，可将DP状态转移转化为矩阵乘法，通过快速幂加速计算。

核心算法流程如下：
1. **构建AC自动机**：插入所有禁忌词，构建trie图并处理fail指针，确保每个节点标记是否触发禁忌。
2. **预处理转移矩阵**：计算每个AC自动机状态通过基本词汇转移后的新状态。
3. **动态规划（小L）**：直接递推计算`dp[i][j]`。
4. **矩阵快速幂（大L）**：将DP转移转化为矩阵乘法，利用快速幂计算大L的结果。

可视化设计思路：采用8位像素风格，用不同颜色的方块表示AC自动机的节点（红色为禁忌状态，绿色为合法状态），用箭头表示基本词汇的转移路径。动画中会动态显示DP状态的更新（如数值增长），矩阵快速幂部分用分块矩阵的高亮和叠加效果展示计算过程。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：作者shadowice1984**
* **点评**：此题解详细介绍了AC自动机的构建（包括fail指针和禁忌状态的传递），并深入解释了矩阵快速幂的构造方法（如何处理长度为1和2的基本词汇）。代码结构清晰，变量命名规范（如`tp`用于矩阵乘法临时存储），对边界条件（如L≤100的特判）处理严谨。亮点在于将矩阵快速幂的状态扩展为两倍大小，巧妙处理了不同长度的基本词汇转移。

**题解二：作者oscar**
* **点评**：此题解分情况讨论了L≤100和L>100的处理方式，逻辑清晰。AC自动机的构建部分（`match`函数）通过递归检查禁忌词匹配，代码简洁易懂。矩阵快速幂的实现中，通过`Matrix`类封装矩阵操作，提高了代码复用性。亮点在于对矩阵乘法的优化（如使用`long long`临时存储避免溢出）。

**题解三：作者Hoks**
* **点评**：此题解提供了类似题目的扩展（如P3502、SP1676），具有启发性。AC自动机的构建部分（`insert`和`build`函数）逻辑完整，DP状态转移（`f[i+len[k]][tmp] += f[i][j]`）直接明了。矩阵快速幂部分通过`ksm`函数实现快速幂，代码简洁高效。亮点在于对状态转移的详细注释，便于学习者理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：AC自动机的正确构建**
    * **分析**：AC自动机需要正确插入所有禁忌词，并通过fail指针传递禁忌标记（即若节点的fail指针指向禁忌节点，则该节点也应标记为禁忌）。例如，禁忌词`"ab"`和`"bc"`的fail指针可能导致`"abc"`中的`"bc"`触发禁忌。优质题解通过BFS构建fail树，并在构建过程中传递禁忌标记（如`ed[mp[p][i]] = ed[mp[p][i]]||ed[fil[mp[p][i]]]`）。
    * 💡 **学习笔记**：AC自动机的核心是fail指针的传递，确保所有可能触发禁忌的状态都被正确标记。

2.  **关键点2：DP状态的设计与转移**
    * **分析**：DP状态`dp[i][j]`表示长度为`i`、匹配到AC自动机状态`j`的方案数。转移时需枚举所有基本词汇，检查转移过程中是否触发禁忌。例如，对于基本词汇`s`，从状态`j`出发，逐字符转移，若中途遇到禁忌状态则跳过。优质题解通过预处理`tran[u][j]`数组（表示从状态`u`使用基本词汇`j`后的新状态），简化了转移逻辑。
    * 💡 **学习笔记**：预处理转移数组`tran`能显著提高DP效率，避免重复计算。

3.  **关键点3：矩阵快速幂的构造**
    * **分析**：对于L>100的情况，需将DP转移转化为矩阵乘法。由于基本词汇长度≤2，矩阵需扩展为两倍大小（分别存储当前长度和前一长度的状态）。例如，矩阵的上半部分处理长度+1的转移，下半部分处理长度+2的转移，左下角为单位矩阵保持前一状态。优质题解通过构造`2*siz`大小的矩阵（`siz`为AC自动机状态数）实现这一逻辑。
    * 💡 **学习笔记**：矩阵快速幂的核心是将状态转移转化为矩阵乘法，利用快速幂将时间复杂度从O(L)优化到O(logL)。

### ✨ 解题技巧总结
- **问题分解**：将问题分为小L（直接DP）和大L（矩阵快速幂）两部分，降低复杂度。
- **预处理优化**：预处理AC自动机的转移数组`tran`，避免重复计算。
- **矩阵扩展**：处理不同长度的基本词汇时，通过扩展矩阵大小（两倍状态数）统一转移逻辑。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了shadowice1984和oscar的题解思路，涵盖AC自动机构建、DP递推（小L）和矩阵快速幂（大L）的完整逻辑。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    #include <queue>
    using namespace std;

    const int MOD = 1e9 + 7;
    const int MAX_NODES = 110; // AC自动机最大节点数

    struct Trie {
        int mp[MAX_NODES][26] = {0};
        int fail[MAX_NODES] = {0};
        bool ed[MAX_NODES] = {false};
        int cnt = 1; // 节点数，初始为根节点0

        void insert(char *s) {
            int p = 0;
            for (int i = 0; s[i]; i++) {
                int c = s[i] - 'a';
                if (!mp[p][c]) mp[p][c] = cnt++;
                p = mp[p][c];
            }
            ed[p] = true;
        }

        void build() {
            queue<int> q;
            for (int i = 0; i < 26; i++) {
                if (mp[0][i]) {
                    fail[mp[0][i]] = 0;
                    q.push(mp[0][i]);
                } else {
                    mp[0][i] = 0;
                }
            }
            while (!q.empty()) {
                int p = q.front();
                q.pop();
                for (int i = 0; i < 26; i++) {
                    if (mp[p][i]) {
                        fail[mp[p][i]] = mp[fail[p]][i];
                        ed[mp[p][i]] |= ed[fail[mp[p][i]]]; // 传递禁忌标记
                        q.push(mp[p][i]);
                    } else {
                        mp[p][i] = mp[fail[p]][i];
                    }
                }
            }
        }
    } trie;

    int n, m, L;
    char words[55][105]; // 基本词汇
    int len[55]; // 基本词汇长度
    int dp[105][MAX_NODES]; // 小L时的DP数组

    // 矩阵快速幂相关
    struct Matrix {
        long long m[2*MAX_NODES][2*MAX_NODES] = {0};
        int size;

        Matrix(int s) : size(s) {}

        Matrix operator*(const Matrix &other) const {
            Matrix res(size);
            for (int i = 0; i < size; i++) {
                for (int k = 0; k < size; k++) {
                    if (m[i][k] == 0) continue;
                    for (int j = 0; j < size; j++) {
                        res.m[i][j] = (res.m[i][j] + m[i][k] * other.m[k][j]) % MOD;
                    }
                }
            }
            return res;
        }

        Matrix pow(int p) {
            Matrix res(size);
            for (int i = 0; i < size; i++) res.m[i][i] = 1; // 单位矩阵
            Matrix base = *this;
            while (p > 0) {
                if (p & 1) res = res * base;
                base = base * base;
                p >>= 1;
            }
            return res;
        }
    };

    int main() {
        scanf("%d%d%d", &n, &m, &L);
        for (int i = 0; i < n; i++) {
            scanf("%s", words[i]);
            len[i] = strlen(words[i]);
        }
        for (int i = 0; i < m; i++) {
            char s[105];
            scanf("%s", s);
            trie.insert(s);
        }
        trie.build();
        int siz = trie.cnt;

        if (L <= 100) { // 小L，直接DP
            dp[0][0] = 1;
            for (int i = 0; i <= L; i++) {
                for (int j = 0; j < siz; j++) {
                    if (dp[i][j] == 0) continue;
                    for (int k = 0; k < n; k++) {
                        if (i + len[k] > L) continue;
                        int p = j;
                        bool valid = true;
                        for (int c = 0; c < len[k]; c++) {
                            p = trie.mp[p][words[k][c] - 'a'];
                            if (trie.ed[p]) {
                                valid = false;
                                break;
                            }
                        }
                        if (valid) {
                            dp[i + len[k]][p] = (dp[i + len[k]][p] + dp[i][j]) % MOD;
                        }
                    }
                }
            }
            long long ans = 0;
            for (int j = 0; j < siz; j++) ans = (ans + dp[L][j]) % MOD;
            printf("%lld\n", ans);
        } else { // 大L，矩阵快速幂
            int size = 2 * siz;
            Matrix mat(size);
            // 初始化矩阵：左下角为单位矩阵（保持前一状态）
            for (int i = 0; i < siz; i++) mat.m[siz + i][i] = 1;
            // 处理长度为1的基本词汇
            for (int i = 0; i < siz; i++) {
                for (int k = 0; k < n; k++) {
                    if (len[k] != 1) continue;
                    int p = i;
                    bool valid = true;
                    for (int c = 0; c < len[k]; c++) {
                        p = trie.mp[p][words[k][c] - 'a'];
                        if (trie.ed[p]) {
                            valid = false;
                            break;
                        }
                    }
                    if (valid) mat.m[siz + i][siz + p]++;
                }
            }
            // 处理长度为2的基本词汇
            for (int i = 0; i < siz; i++) {
                for (int k = 0; k < n; k++) {
                    if (len[k] != 2) continue;
                    int p = i;
                    bool valid = true;
                    for (int c = 0; c < len[k]; c++) {
                        p = trie.mp[p][words[k][c] - 'a'];
                        if (trie.ed[p]) {
                            valid = false;
                            break;
                        }
                    }
                    if (valid) mat.m[i][siz + p]++;
                }
            }
            // 计算矩阵的L次幂
            Matrix res = mat.pow(L);
            long long ans = 0;
            for (int i = 0; i < siz; i++) ans = (ans + res.m[0][siz + i]) % MOD;
            printf("%lld\n", ans);
        }
        return 0;
    }
    ```
* **代码解读概要**：
    该代码首先构建AC自动机处理禁忌词，然后根据L的大小选择不同的处理方式：L≤100时直接使用DP递推；L>100时通过矩阵快速幂优化。矩阵部分扩展为两倍状态数，分别处理长度为1和2的基本词汇转移，左下角的单位矩阵保持前一状态，确保转移的正确性。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段：
</code_intro_selected>

**题解一（shadowice1984）**
* **亮点**：矩阵快速幂的构造逻辑清晰，通过`tr`矩阵处理不同长度的基本词汇转移。
* **核心代码片段**：
    ```cpp
    // 矩阵快速幂部分
    for(int i=1;i<=siz;i++){tr.m[siz+i][i]=1;} // 左下角单位矩阵
    for(int i=1;i<=siz;i++){ // 处理长度为1的词汇
        for(int q=1;q<=n;q++){
            if(len[q]!=1)continue;int p=i;if(t.ed[p])continue;
            t.trv(p,mde[q][1]-'a'+1);if(p!=-1){tr.m[siz+i][siz+p]++;}
        }
    }
    for(int i=1;i<=siz;i++){ // 处理长度为2的词汇
        for(int q=1;q<=n;q++){
            if(len[q]!=2)continue;int p=i;if(t.ed[p])continue;
            t.trv(p,mde[q][1]-'a'+1);if(p==-1)continue;
            t.trv(p,mde[q][2]-'a'+1);if(p!=-1){tr.m[i][siz+p]++;}
        }
    }
    ```
* **代码解读**：
    这段代码构造了转移矩阵`tr`。其中，左下角的单位矩阵（`tr.m[siz+i][i] = 1`）用于保持前一状态；长度为1的词汇转移到矩阵的上半部分（`tr.m[siz+i][siz+p]++`）；长度为2的词汇转移到矩阵的下半部分（`tr.m[i][siz+p]++`）。这样，矩阵的快速幂运算就能正确模拟DP的状态转移。
* 💡 **学习笔记**：矩阵的构造需明确各部分的含义，确保状态转移的正确性。

**题解二（oscar）**
* **亮点**：通过`match`函数预处理AC自动机的转移，简化了DP逻辑。
* **核心代码片段**：
    ```cpp
    int match(string str, int len, int start) {
        node *cur = &pool[start], *tmp;
        for (int i = 0; i < len; i++) {
            int e = str[i] - 'a';
            while (cur != root && !(cur->next[e])) cur = cur->fail;
            if (cur->next[e]) cur = cur->next[e];
            tmp = cur;
            while (tmp != root) {
                if (tmp->end) return 0;
                tmp = tmp->fail;
            }
        }
        return cur->id;
    }
    ```
* **代码解读**：
    `match`函数用于计算从状态`start`出发，使用基本词汇`str`后的新状态。若中途触发禁忌（`tmp->end`为真），返回0表示无效转移；否则返回新状态的ID。该函数通过遍历AC自动机的fail指针，确保所有可能的禁忌状态都被检查。
* 💡 **学习笔记**：预处理转移函数能显著提高DP的效率，避免重复计算。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解AC自动机的匹配过程和矩阵快速幂的优化逻辑，我设计了一个8位像素风格的动画演示方案。
</visualization_intro>

  * **动画演示主题**：`像素巫师的咒语实验室`

  * **核心演示内容**：
    - AC自动机的构建过程：用像素方块表示节点，绿色为合法状态，红色为禁忌状态，箭头表示字符转移。
    - DP状态转移：动态显示`dp[i][j]`的数值变化（如数字从0增长到具体值）。
    - 矩阵快速幂：用分块矩阵的高亮和叠加效果展示矩阵乘法的过程（如长度为1和2的转移块分别用蓝色和黄色高亮）。

  * **设计思路简述**：
    采用8位像素风格（类似红白机），营造轻松的学习氛围。通过颜色标记（绿色合法、红色禁忌）和动态数值变化，帮助学习者直观理解状态转移。矩阵快速幂部分用分块动画展示，突出不同长度词汇的转移逻辑。

  * **动画帧步骤与交互关键点**：

    1. **场景初始化**：
        - 左侧显示AC自动机的像素网格（节点用方块表示，根节点为大绿色方块）。
        - 右侧显示DP表格（行表示长度，列表示状态，初始值全为0）。
        - 底部控制面板包含“单步执行”“自动播放”“调速”按钮。

    2. **AC自动机构建**：
        - 插入禁忌词时，节点按字符路径逐个点亮（红色）。
        - 构建fail指针时，用虚线箭头连接节点，并传递禁忌标记（红色扩散）。

    3. **DP状态转移（小L）**：
        - 选择基本词汇后，从当前状态方块出发，沿字符路径移动（绿色箭头）。
        - 若中途无禁忌（绿色路径），目标状态的DP值增加（数字闪烁）。

    4. **矩阵快速幂（大L）**：
        - 矩阵用分块显示（上半部分处理长度+1，下半部分处理长度+2）。
        - 快速幂计算时，矩阵块叠加（如蓝色块和黄色块合并），数值动态更新。

    5. **目标达成**：
        - 计算完成后，最终状态的数值用金色高亮，伴随“叮”的成功音效。

  * **旁白提示**：
      - “现在，我们正在插入禁忌词‘banana’，对应的节点被标记为红色。”
      - “选择基本词汇‘an’，从状态0出发，沿路径移动到状态3，DP[2][3]增加1。”
      - “矩阵快速幂将L次转移压缩为logL次乘法，大大提高了计算速度！”

<visualization_conclusion>
通过这样的动画，我们可以直观看到AC自动机的匹配过程、DP状态的更新以及矩阵快速幂的优化效果，从而更深刻地理解算法的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - AC自动机+DP的组合适用于所有需要多模式匹配的计数问题（如敏感词过滤、DNA序列分析）。
    - 矩阵快速幂可优化任何具有线性递推性质的问题（如斐波那契数列、状态转移可表示为矩阵乘法的场景）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3502 [POI2010] CHO-Hamsters**
          * 🗣️ **推荐理由**：此题需要处理多个字符串的拼接，涉及AC自动机和矩阵快速幂的综合应用，与本题思路高度相似。
    2.  **洛谷 SP1676 GEN - Text Generator**
          * 🗣️ **推荐理由**：此题要求生成不包含特定子串的字符串，需用AC自动机和DP计数，适合巩固本题的核心技巧。
    3.  **洛谷 CF696D Legen...**
          * 🗣️ **推荐理由**：此题涉及动态规划和矩阵快速幂的复杂应用，能进一步提升对矩阵优化的理解。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试过程中的经验，这些对我们有重要参考价值：
</insights_intro>

> **参考经验 (来自shadowice1984)**：“在构建AC自动机时，容易漏掉fail指针的禁忌标记传递，导致部分测试点错误。通过打印每个节点的`ed`标记，才发现问题所在。”

> **点评**：这位作者的经验提醒我们，AC自动机的禁忌标记传递是关键步骤。调试时，可通过打印节点状态（如`ed`标记）快速定位错误。这对于处理多模式匹配问题非常重要。

-----

<conclusion>
本次关于“魔法咒语”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解AC自动机、动态规划和矩阵快速幂的综合应用。记住，编程能力的提升在于持续学习和实践，下次我们再一起探索新的挑战！💪
</conclusion>

---
处理用时：211.75秒
# 题目信息

# 【模板】后缀自动机（SAM）

## 题目描述

给定一个只包含小写字母的字符串 $S$。

请你求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。


## 说明/提示

对于 $10 \%$ 的数据，$\lvert S \rvert \le 1000$。  
对于 $100\% $的数据，$1 \le \lvert S \rvert \le {10}^6$。

- 2023.7.30：添加一组 hack 数据。

## 样例 #1

### 输入

```
abab```

### 输出

```
4```

# AI分析结果



---
# 💡 Kay的C++算法解析：【模板】后缀自动机 深入学习指南 💡

<introduction>
今天我们要一起攻克的是“后缀自动机（SAM）”的模板题。这道题的核心是利用SAM高效处理子串问题的特性，找到所有出现次数不为1的子串中，出现次数乘以长度的最大值。通过这篇指南，我们不仅能掌握SAM的构造方法，还能理解其背后的原理和实际应用技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`后缀自动机（SAM）的构造与应用`

🗣️ **初步分析**：
解决这道题的关键在于理解后缀自动机（SAM）的核心结构和性质。SAM是一种高效表示字符串所有子串的压缩数据结构，它通过`endpos等价类`将相同结束位置集合的子串合并为一个状态，并用`后缀链接（parent树）`连接这些状态，形成一棵树结构。

简单来说，SAM可以想象成一个“压缩字典树”，每个节点代表一组结束位置相同的子串（endpos等价类），节点间的边表示添加一个字符后的转移。而parent树则通过后缀链接，将每个状态连接到其最长后缀所在的状态，帮助我们快速统计子串的出现次数。

在本题中，我们需要：
1. 构造SAM，记录每个状态的最长子串长度（`len`）。
2. 统计每个状态对应的子串出现次数（即endpos集合的大小）。
3. 遍历所有状态，计算出现次数（不为1）乘长度的最大值。

**核心算法流程**：
- **SAM构造**：逐个插入字符，处理状态分裂（当遇到已有转移但长度不匹配时）。
- **统计出现次数**：通过parent树进行DFS，累加子树的出现次数（初始时，每个插入的新状态对应一个前缀，出现次数为1）。
- **计算最大值**：遍历所有状态，取`出现次数 * len`的最大值。

**可视化设计思路**：
采用8位像素风格动画，模拟SAM的构造过程：
- 初始状态为一个像素点（根节点）。
- 每插入一个字符，新建状态并高亮显示，用不同颜色区分原状态和分裂后的新状态。
- 后缀链接用虚线表示，parent树的构建过程动态展示。
- 统计出现次数时，用数字气泡显示每个状态的计数，DFS过程用箭头动态遍历parent树。
- 关键步骤（如节点分裂）配合“叮”的音效，完成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过对题解的思路清晰度、代码规范性、算法有效性等维度的评估，以下题解质量突出（≥4星），值得重点学习：
</eval_intro>

**题解一：Hatsune_Miku（赞：744）**  
* **点评**：这篇题解系统讲解了SAM的理论基础（endpos集合、后缀链接、parent树），并给出了构造SAM的完整代码。其对SAM性质的推导（如状态数线性、转移数线性）非常严谨，适合深入理解SAM的底层原理。代码中对节点分裂的处理（`clone`节点）逻辑清晰，是学习SAM构造的经典参考。

**题解二：KesdiaelKen（赞：551）**  
* **点评**：题解以“最通俗”为目标，用大量图示和类比（如将endpos集合的包含关系比作树形结构）解释SAM的构造过程。代码实现中对parent树的DFS统计出现次数的方法非常巧妙，适合初学者快速上手。

**题解三：shadowice1984（赞：114）**  
* **点评**：代码简洁高效，重点突出本题的核心逻辑（统计出现次数并计算最大值）。通过`cnt`数组记录每个状态的出现次数，利用parent树的后序遍历累加子树和，是典型的SAM应用场景实现。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决本题时，以下三个关键点需要特别注意：
</difficulty_intro>

1.  **关键点1：SAM的构造（尤其是节点分裂）**  
    * **分析**：插入字符时，若遇到已有转移但长度不匹配（`len(q) > len(p)+1`），需要分裂节点`q`为`clone`和原`q`。`clone`继承`q`的转移和后缀链接，但长度调整为`len(p)+1`，原`q`的后缀链接指向`clone`。这一步是SAM构造的核心，确保每个状态的endpos等价类正确。  
    * 💡 **学习笔记**：节点分裂是SAM保持线性复杂度的关键，需理解`clone`节点的作用（分离出属于当前插入字符的后缀部分）。

2.  **关键点2：统计每个状态的出现次数**  
    * **分析**：初始时，每个插入的新状态（对应原串的前缀）的出现次数为1。通过parent树的后序遍历（从叶子到根），累加子树的出现次数，即可得到每个状态的总出现次数（即其endpos集合的大小）。  
    * 💡 **学习笔记**：parent树的结构保证了子节点的出现次数是父节点的子集，因此后序遍历能正确累加。

3.  **关键点3：如何高效计算最大值**  
    * **分析**：遍历所有状态，若出现次数不为1，则计算`出现次数 * len`，并记录最大值。由于SAM的状态数是线性的，这一步的时间复杂度为O(n)。  
    * 💡 **学习笔记**：只需关注每个状态的最长子串（`len`属性），因为同一状态的子串长度连续，最长子串的乘积一定最大。

### ✨ 解题技巧总结
- **SAM构造技巧**：插入字符时，从`last`状态沿后缀链接向上跳，处理无转移的情况；遇到有转移但长度不匹配时，分裂节点。
- **统计出现次数技巧**：利用parent树的后序遍历，累加子节点的出现次数到父节点。
- **边界处理**：初始状态（根节点）的`len=0`，出现次数为0（不参与计算）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的核心代码实现，完整展示了SAM的构造、出现次数统计及最大值计算的过程。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了Hatsune_Miku和shadowice1984的题解思路，实现了SAM的构造、parent树的构建及出现次数统计，最终计算最大值。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 3e6 + 10; // 字符串长度最大1e6，SAM状态数约2e6

    struct State {
        int len;        // 该状态的最长子串长度
        int fa;         // 后缀链接（parent树中的父节点）
        int ch[26];     // 转移边（字符到状态的映射）
    } sam[N];

    int last = 1, tot = 1; // last：当前最长前缀的状态；tot：状态总数（初始有一个根节点）
    int cnt[N];           // 记录每个状态的出现次数
    vector<int> parent_tree[N]; // parent树的邻接表（用于DFS）
    long long ans = 0;    // 最终答案

    // 插入字符c，构造SAM
    void extend(int c) {
        int cur = ++tot;
        sam[cur].len = sam[last].len + 1;
        cnt[cur] = 1; // 新状态对应一个前缀，初始出现次数为1

        int p = last;
        // 从last向上跳后缀链接，处理无转移的情况
        while (p && !sam[p].ch[c]) {
            sam[p].ch[c] = cur;
            p = sam[p].fa;
        }

        if (!p) {
            sam[cur].fa = 1; // 跳到根节点，后缀链接指向根
        } else {
            int q = sam[p].ch[c];
            if (sam[q].len == sam[p].len + 1) {
                sam[cur].fa = q; // 情况1：直接链接
            } else {
                // 情况2：分裂节点q为clone和原q
                int clone = ++tot;
                sam[clone] = sam[q]; // 复制转移和后缀链接
                sam[clone].len = sam[p].len + 1;
                // 更新原q和cur的后缀链接
                sam[q].fa = clone;
                sam[cur].fa = clone;
                // 向上跳p，修改指向q的转移为clone
                while (p && sam[p].ch[c] == q) {
                    sam[p].ch[c] = clone;
                    p = sam[p].fa;
                }
            }
        }
        last = cur; // 更新last为新状态
    }

    // DFS遍历parent树，统计出现次数
    void dfs(int u) {
        for (int v : parent_tree[u]) {
            dfs(v);
            cnt[u] += cnt[v]; // 累加子节点的出现次数
        }
        if (cnt[u] != 1) {
            ans = max(ans, 1LL * cnt[u] * sam[u].len);
        }
    }

    int main() {
        string s;
        cin >> s;
        for (char c : s) {
            extend(c - 'a'); // 插入每个字符，构造SAM
        }

        // 构建parent树（每个节点的父节点是其后缀链接）
        for (int i = 2; i <= tot; ++i) {
            parent_tree[sam[i].fa].push_back(i);
        }

        dfs(1); // 从根节点开始DFS统计出现次数

        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：
  - `extend`函数：逐个插入字符，处理状态转移和分裂，维护SAM的结构。
  - `dfs`函数：通过parent树后序遍历，累加子节点的出现次数到父节点，并计算最大值。
  - `main`函数：读取字符串，构造SAM，构建parent树，调用DFS统计并输出结果。

---

<code_intro_selected>
以下是优质题解的核心代码片段及解读：
</code_intro_selected>

**题解一：Hatsune_Miku（SAM构造部分）**  
* **亮点**：对节点分裂的处理逻辑严谨，注释清晰，适合理解SAM的底层构造。
* **核心代码片段**：
    ```cpp
    void sam_extend(char c) {
        int cur = sz++;
        st[cur].len = st[last].len + 1;
        int p = last;
        while (p != -1 && !st[p].next.count(c)) {
            st[p].next[c] = cur;
            p = st[p].link;
        }
        if (p == -1) {
            st[cur].link = 0;
        } else {
            int q = st[p].next[c];
            if (st[p].len + 1 == st[q].len) {
                st[cur].link = q;
            } else {
                int clone = sz++;
                st[clone].len = st[p].len + 1;
                st[clone].next = st[q].next;
                st[clone].link = st[q].link;
                while (p != -1 && st[p].next[c] == q) {
                    st[p].next[c] = clone;
                    p = st[p].link;
                }
                st[q].link = st[cur].link = clone;
            }
        }
        last = cur;
    }
    ```
* **代码解读**：
  - `cur`是新插入字符对应的状态，`len`为前一个状态长度+1。
  - `p`从`last`开始向上跳后缀链接，为所有无`c`转移的状态添加到`cur`的转移。
  - 若找到已有转移的`q`，分两种情况处理：若`q`的长度正好是`p.len+1`，直接链接；否则分裂`q`为`clone`，调整转移和后缀链接。
* 💡 **学习笔记**：节点分裂时，`clone`继承`q`的转移和链接，确保原有转移的正确性。

**题解二：shadowice1984（统计出现次数部分）**  
* **亮点**：通过parent树的后序遍历累加出现次数，逻辑简洁高效。
* **核心代码片段**：
    ```cpp
    void dfs(int u) {
        for (int v : parent_tree[u]) {
            dfs(v);
            cnt[u] += cnt[v];
        }
        if (cnt[u] != 1) {
            ans = max(ans, 1LL * cnt[u] * sam[u].len);
        }
    }
    ```
* **代码解读**：
  - 递归遍历parent树的子节点，先处理子节点再处理父节点（后序遍历）。
  - 父节点的出现次数等于所有子节点出现次数之和（因为子节点的endpos是父节点的子集）。
  - 若出现次数不为1，计算并更新最大值。
* 💡 **学习笔记**：后序遍历保证父节点能正确累加所有子节点的出现次数。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解SAM的构造和统计过程，我们设计了一个8位像素风格的动画，模拟SAM的插入、节点分裂及出现次数统计的过程。
</visualization_intro>

  * **动画演示主题**：`像素小探险家的SAM之旅`

  * **核心演示内容**：
    - 初始状态：一个像素点（根节点），背景是复古游戏界面（FC风格）。
    - 插入字符：每插入一个字符（如'a'），新建一个状态（黄色像素块），从`last`状态沿后缀链接向上跳，为无转移的状态添加到新状态的边（绿色箭头）。
    - 节点分裂：当需要分裂节点时，原状态（蓝色）分裂为`clone`（紫色）和原状态（蓝色），调整转移边（红色箭头）。
    - 统计出现次数：parent树用虚线连接，DFS过程用白色箭头遍历，出现次数用数字气泡显示（初始为1，累加后变大）。
    - 计算最大值：最终找到最大的`出现次数 * len`，用金色闪光效果突出显示。

  * **设计思路简述**：
    采用8位像素风格，降低学习门槛；关键步骤（如节点分裂）用颜色变化和音效（“叮”）强化记忆；DFS过程动态展示，帮助理解parent树的结构。

  * **动画帧步骤与交互关键点**：
    1. **初始化**：显示根节点（编号1，len=0），控制面板（单步/自动按钮、速度滑块）。
    2. **插入字符**：点击“插入字符”按钮，新状态（黄色）出现，从`last`开始向上跳后缀链接，无转移的状态添加绿色箭头到新状态。
    3. **节点分裂**：当遇到需要分裂的情况，原状态（蓝色）分裂为`clone`（紫色），原状态的转移边改为指向`clone`（红色箭头），播放“叮”音效。
    4. **统计出现次数**：点击“统计次数”按钮，白色箭头从叶子节点开始后序遍历parent树，数字气泡累加次数（如叶子节点从1变为父节点的3）。
    5. **计算最大值**：遍历所有状态，找到最大的`次数*len`，用金色闪光和胜利音效（“啦~”）提示。

  * **旁白提示**：
    - 插入字符时：“现在插入字符'a'，新建状态cur，它的len是前一个状态+1。”
    - 节点分裂时：“发现q的长度大于p.len+1，需要分裂q为clone和原q，clone继承q的转移。”
    - 统计次数时：“通过parent树后序遍历，父节点的次数等于所有子节点次数之和。”

<visualization_conclusion>
通过这个动画，我们可以直观看到SAM的构造过程、节点分裂的细节，以及出现次数统计的逻辑，大大降低了理解难度。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
SAM是处理字符串子串问题的“瑞士军刀”，掌握后可解决多种复杂问题。以下是一些相似问题和练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - SAM可处理子串的出现次数、最长公共子串、不同子串个数等问题，核心是利用endpos集合和parent树的性质。
    - 例如，多串最长公共子串问题可通过构建广义SAM，统计每个状态在所有串中的出现次数，取最大值。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1368 【模板】最小表示法**  
        * 🗣️ **推荐理由**：利用SAM找到最小循环移位，练习SAM的基础应用。
    2.  **洛谷 SP1811 LCS - Longest Common Substring**  
        * 🗣️ **推荐理由**：求两串最长公共子串，练习SAM与双串匹配的结合。
    3.  **洛谷 P3975 [TJOI2015] 弦论**  
        * 🗣️ **推荐理由**：求第k大子串，练习SAM的统计与排序技巧。

---

## 7\. 学习心得与经验分享 

<insights_intro>
题解中作者们的调试经验和对SAM的理解，对我们有很大启发：
</insights_intro>

> **参考经验 (来自shadowice1984)**：“一开始写代码时，忘记调用DFS统计次数，导致输出0。后来发现是漏了关键步骤。”  
> **参考经验 (来自KesdiaelKen)**：“理解SAM的关键是endpos集合和parent树的结构，画图有助于理清状态间的关系。”

**点评**：这些经验提醒我们，代码的每一步都需要仔细检查（如是否调用关键函数），而画图和类比（如将parent树比作家族树）能帮助理解抽象的数据结构。调试时，打印中间状态（如每个状态的len和fa）是定位问题的有效方法。

---

<conclusion>
通过这篇指南，我们系统学习了SAM的构造、核心性质及本题的解决方法。SAM的强大之处在于其对字符串子串的高效表示，掌握它能为解决复杂字符串问题打下坚实基础。希望大家通过练习和动画演示，真正掌握这一“字符串神器”！下次再见~ 💪
</conclusion>

---

---
处理用时：198.22秒
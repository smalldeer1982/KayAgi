# 题目信息

# [ICPC 2019 WF] First of Her Name

## 题目描述

众所周知，皇室家族的名字非常有讲究。而作为研究皇室的历史学家的你，最近接到了一个艰巨的任务——分析王国历史中所有皇室夫人的名字。



王国历史上有 $n$ 位皇室夫人，方便起见，我们将其从 $1$ 至 $n$ 编号。除了 $1$ 号夫人外，其余夫人的名字均为一个大写字母连接着她母亲的名字。而 $1$ 号夫人作为王国的首任王后，她的名字只有一个大写字母。



例如，由于 `AENERYS` 由 `A` 与 `ENERYS` 组成，因此 `ENERYS` 是 `AENERYS` 的母亲。相似地，`AENERYS` 是 `DAENERYS` 与 `YAENERYS` 的母亲。



你知道王国历史上所有皇室夫人的姓名与关系，而你需要完成的任务是，对于其他历史学家感兴趣的名字串 $s$，总共有多少位夫人的名字是以 $s$ 起始的。



例如在样例的皇室族谱中，`S` 至 `AENERYS` 的这一支（包含 `YS`、`RYS`、`ERYS`、`NERYS` 与 `ENERYS` 这几位夫人）均只有一位女儿。接下来 `AENERYS` 有两位女儿，分别是 `DAENERYS`，以及女儿是 `RYAENERYS` 的 `YAENERYS`。



在这个皇室家族内，有两位夫人的名字以 `RY` 起始，她们是 `RYS` 与 `RYAENERYS`。而 `ERYS` 与 `ENERYS` 均以 `E` 起始。名字以 `N` 起始的仅有一位夫人 `NERYS`。同样地，以 `S` 起始的仅有首位王后 `S`。而没有任何一位夫人的名字以 `AY` 起始。

## 说明/提示

$1\leq n\leq 10^6$，$1\leq k\leq 10^6$，$p_1=0$，特别地，对于 $1\lt i\leq n$，保证有 $1\leq p_i\lt i$。感兴趣的名字串总长不超过 $10^6$。

## 样例 #1

### 输入

```
10 5
S 0
Y 1
R 2
E 3
N 4
E 5
A 6
D 7
Y 7
R 9
RY
E
N
S
AY```

### 输出

```
2
2
1
1
0```

# AI分析结果



---
# 💡 Kay的C++算法解析：First of Her Name 深入学习指南 💡

<introduction>
今天我们要一起攻克这道关于皇室夫人名字前缀查询的题目。这道题需要高效处理大规模字符串的前缀统计问题，涉及多模式匹配的核心算法。让我们一步步拆解思路，掌握关键技巧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：字符串（多模式匹配）

🗣️ **初步分析**：
解决这道题的关键在于将“前缀查询”转化为“后缀匹配”，并利用高效的字符串处理结构（如AC自动机或后缀自动机SAM）。简单来说，多模式匹配就像在字典里同时查多个单词，这里我们需要同时处理多个查询串的匹配问题。

题目中，每个夫人的名字是母亲名字前加一个字母，形成一棵“反Trie树”（路径从子节点到根节点构成名字）。直接查询前缀效率低，因此：
- **反转策略**：将所有名字和查询串反转，原问题的“前缀s”变为“后缀s_rev”，此时名字的结构变为从根到子节点的标准Trie树。
- **多模式匹配**：用AC自动机或SAM处理反转后的查询串，统计每个查询串作为后缀出现的次数。

核心算法流程：
1. 构建反转后的名字Trie树；
2. 对反转后的查询串构建AC自动机（或SAM）；
3. 在Trie树中遍历，标记每个节点在AC自动机中的匹配位置；
4. 利用AC自动机的fail树（或SAM的Parent Tree）统计子树和，得到每个查询的答案。

**可视化设计思路**：采用8位像素风格，模拟Trie树的构建过程（每个节点是像素方块，颜色代表字符），AC自动机的匹配路径用箭头高亮，fail指针跳转时用虚线连接，关键步骤（如插入字符、匹配成功）伴随“叮”的音效，最终统计子树和时用渐变颜色展示累加过程。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法效率等维度的评估，以下题解在解决大规模字符串匹配问题时表现优异，值得重点学习：
</eval_intro>

**题解一：CYJian的AC自动机解法 (来源：CYJian)**
* **点评**：此题解思路清晰，巧妙利用AC自动机处理多模式匹配。通过反转字符串将前缀问题转化为后缀问题，构建AC自动机后，利用fail树的子树和统计匹配次数。代码结构规范（如变量名`ac.tr`、`fail`含义明确），时间复杂度为O(n + k + |str|)，完全满足题目规模要求。亮点在于结合Trie树的特性优化匹配过程（子节点继承父节点的匹配状态），大幅提升效率。

**题解二：251Sec的SAM解法 (来源：251Sec)**
* **点评**：此解法选择后缀自动机（SAM）处理后缀匹配，利用SAM的Parent Tree统计子树和。代码简洁高效（如`Ins`函数实现SAM的插入），通过反转字符串将问题转化为后缀统计，符合SAM处理后缀的天然优势。亮点在于SAM的`len`属性和`prt`指针的巧妙运用，直接通过子树和得到结果，逻辑简洁。

**题解三：biyi_mouse的AC自动机解法 (来源：biyi_mouse)**
* **点评**：此题解详细展示了AC自动机的构建与匹配过程。通过反转查询串并插入AC自动机，再遍历名字Trie树标记匹配位置，最后利用fail树的DFS统计子树和。代码注释清晰（如`add`函数构建fail树），关键步骤（如`dfs`遍历Trie树）逻辑直白，适合初学者理解AC自动机的完整流程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决本题的过程中，以下三个关键点是突破的核心。掌握它们，你就能举一反三解决类似的多模式匹配问题：
</difficulty_intro>

1.  **关键点1：如何将前缀查询转化为后缀匹配？**
    * **分析**：原问题要求统计以s为前缀的名字数量，但直接遍历每个名字检查前缀效率极低（O(n|s|)无法处理1e6规模）。通过反转所有名字和查询串（如名字`DAENERYS`反转为`SYNERAED`，查询`RY`反转为`YR`），原问题的“前缀s”变为“后缀s_rev”，此时名字的结构变为从根到子节点的Trie树，后缀匹配可通过AC自动机或SAM高效处理。
    * 💡 **学习笔记**：反转字符串是将前缀问题转化为后缀问题的常用技巧，能利用更高效的字符串结构（如SAM天然处理后缀）。

2.  **关键点2：如何高效统计后缀匹配的次数？**
    * **分析**：对于AC自动机，每个匹配的后缀对应fail树上的一条链（从匹配节点到根）。通过在fail树中统计子树和（即所有以该节点为后缀的名字数量），可快速得到结果。对于SAM，每个状态的`endpos`集合大小即包含该后缀的名字数量，通过Parent Tree的子树和统计即可。
    * 💡 **学习笔记**：利用树结构（fail树/Parent Tree）的子树和统计是多模式匹配中批量查询的关键优化。

3.  **关键点3：如何选择数据结构（AC自动机vs SAM）？**
    * **分析**：AC自动机适合处理多模式匹配（多个查询串），构建和匹配的时间复杂度与总模式长度相关；SAM适合处理单个字符串的所有子串，但通过广义SAM可处理多个字符串（如本题的名字Trie树）。本题中两种结构均适用，AC自动机代码更直观，SAM空间效率更高。
    * 💡 **学习笔记**：根据问题规模和模式数量选择数据结构，多模式匹配优先考虑AC自动机，后缀统计优先考虑SAM。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：通过反转字符串将前缀问题转化为后缀问题，简化匹配逻辑。
- **树结构利用**：利用AC自动机的fail树或SAM的Parent Tree统计子树和，批量处理查询。
- **继承优化**：在Trie树中，子节点的匹配状态可继承父节点（如AC自动机中`tr[y][c]`直接复用父节点的转移），避免重复计算。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择CYJian的AC自动机解法作为通用核心实现，其逻辑清晰且高效，适合作为学习参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了AC自动机的构建、Trie树遍历及fail树统计，完整解决了大规模前缀查询问题。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MAXN = 1e6 + 10;

    int tr[MAXN][26]; // 名字Trie树
    vector<int> to[MAXN]; // fail树邻接表

    struct ACAM {
        int tr[MAXN][26]; // AC自动机转移表
        int fail[MAXN]; // fail指针
        int cnt[MAXN]; // 子树和统计
        int ct; // 节点数

        int Insert(char* str, int len) { // 插入反转后的查询串
            int x = 0;
            for (int i = len; i >= 1; --i) {
                int c = str[i] - 'A';
                if (!tr[x][c]) tr[x][c] = ++ct;
                x = tr[x][c];
            }
            return x;
        }

        void build() { // 构建fail指针
            queue<int> q;
            for (int i = 0; i < 26; ++i)
                if (tr[0][i]) q.push(tr[0][i]);
            while (!q.empty()) {
                int x = q.front(); q.pop();
                for (int c = 0; c < 26; ++c) {
                    if (tr[x][c]) {
                        fail[tr[x][c]] = tr[fail[x]][c];
                        q.push(tr[x][c]);
                    } else tr[x][c] = tr[fail[x]][c];
                }
            }
            for (int i = 1; i <= ct; ++i) to[fail[i]].push_back(i);
        }

        void dfs(int x) { // 统计fail树子树和
            for (int y : to[x]) {
                dfs(y);
                cnt[x] += cnt[y];
            }
        }
    } ac;

    void dfs_trie(int x, int y) { // 遍历名字Trie树，标记AC自动机匹配位置
        ac.cnt[y]++;
        for (int c = 0; c < 26; ++c)
            if (tr[x][c]) dfs_trie(tr[x][c], ac.tr[y][c]);
    }

    int main() {
        int n, k;
        scanf("%d%d", &n, &k);
        for (int i = 1; i <= n; ++i) {
            char ch; int p;
            while (!isalpha(ch = getchar()));
            scanf("%d", &p);
            tr[p][ch - 'A'] = i; // 构建名字Trie树（父节点p的子节点i，字符为ch）
        }
        char s[MAXN];
        int pos[MAXN];
        for (int i = 1; i <= k; ++i) {
            int len = 0;
            while (!isalpha(s[++len] = getchar()));
            --len; // 跳过末尾非字母字符
            pos[i] = ac.Insert(s, len); // 插入反转后的查询串
        }
        ac.build();
        dfs_trie(0, 0); // 遍历Trie树，标记AC自动机节点
        ac.dfs(0); // 统计fail树子树和
        for (int i = 1; i <= k; ++i) printf("%d\n", ac.cnt[pos[i]]);
        return 0;
    }
    ```
* **代码解读概要**：
  1. **名字Trie构建**：每个夫人的名字由母亲节点（p）添加字符（ch）生成子节点（i），形成Trie树。
  2. **AC自动机构建**：插入反转后的查询串，构建转移表和fail指针，形成fail树。
  3. **Trie遍历标记**：从根节点（0）开始遍历名字Trie，每个节点对应AC自动机的匹配位置，标记`cnt[y]++`。
  4. **fail树统计**：通过DFS统计每个节点的子树和，得到每个查询串的匹配次数。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的巧妙设计：
</code_intro_selected>

**题解一：CYJian的AC自动机解法**
* **亮点**：利用Trie树的继承特性优化匹配（子节点直接复用父节点的AC自动机状态），时间复杂度O(n + k + |str|)。
* **核心代码片段**：
    ```cpp
    void dfs_trie(int x, int y) {
        ac.cnt[y]++;
        for (int c = 0; c < 26; ++c)
            if (tr[x][c]) dfs_trie(tr[x][c], ac.tr[y][c]);
    }
    ```
* **代码解读**：
  这段代码遍历名字Trie树（x是Trie节点，y是AC自动机节点）。每个Trie节点对应AC自动机的一个状态（y），通过`ac.tr[y][c]`直接跳转到子节点的AC状态（继承父节点的匹配位置）。`ac.cnt[y]++`标记该AC状态被访问，最终通过fail树的子树和统计所有后缀匹配的次数。
* 💡 **学习笔记**：Trie树的遍历与AC自动机的状态转移同步进行，避免了重复匹配，是大规模数据下的关键优化。

**题解二：251Sec的SAM解法**
* **亮点**：利用SAM的Parent Tree直接统计子树和，代码简洁且空间效率高。
* **核心代码片段**：
    ```cpp
    struct Node {
        int ch[26], prt, len;
    } f[2000020];
    int id[1000005]; // 每个夫人名字对应的SAM状态

    int main() {
        for (int i = 1; i <= n; ++i) {
            char c; int p;
            cin >> c >> p;
            id[i] = Ins(c - 'A', id[p]); // 插入字符c到SAM，继承母亲的状态id[p]
            w[id[i]]++; // 标记该状态出现次数
        }
        for (int i = 2; i <= cnt; ++i) InsE(f[i].prt, i); // 构建Parent Tree
        DFS(1); // 统计子树和
    }
    ```
* **代码解读**：
  `Ins`函数向SAM中插入字符（反转后的名字），`id[i]`记录每个夫人名字对应的SAM状态。`w[id[i]]++`表示该状态出现一次。通过构建Parent Tree并DFS统计子树和（`w[u] += w[v]`），最终每个查询串对应的SAM状态的`w`值即为答案。
* 💡 **学习笔记**：SAM的`prt`指针天然形成Parent Tree，子树和直接对应包含该后缀的所有名字数量，无需额外处理。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解AC自动机的匹配过程，我们设计一个“像素字母探险”动画，模拟名字Trie树的构建、AC自动机的匹配及fail树的统计过程。
</visualization_intro>

  * **动画演示主题**：像素字母探险——AC自动机的匹配之旅

  * **核心演示内容**：
    1. 名字Trie树的构建（每个节点是彩色像素块，字符显示在块上）；
    2. 查询串反转后插入AC自动机（白色箭头逐步绘制转移路径）；
    3. Trie树遍历与AC自动机匹配（绿色指针同步移动，匹配成功时节点闪烁）；
    4. fail树统计子树和（金色波浪从子节点扩散到父节点，数值累加）。

  * **设计思路简述**：
    8位像素风格（红/绿/蓝三色调）营造复古感，关键步骤（插入、匹配、统计）用音效（“叮”“哗”）强化记忆。动画通过步进控制（单步/自动）让学习者看清每一步细节，fail树的扩散动画直观展示子树和的统计逻辑。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 左侧显示名字Trie树（根节点在顶部，子节点向下延伸，每个节点标有字符）；
        - 右侧显示AC自动机（根节点在左侧，转移边用虚线连接）；
        - 底部控制面板：单步/自动按钮、速度滑块（1-5倍速）、重置按钮。

    2.  **名字Trie构建**：
        - 从根节点（0号）开始，依次添加夫人名字（如样例中的S→Y→R→E→N...）；
        - 每个新节点从父节点“生长”出来（像素块从父节点位置滑出），伴随“滴答”音效。

    3.  **AC自动机插入查询串**：
        - 输入查询串（如“RY”），反转后为“YR”；
        - 白色箭头从AC根节点出发，按字符Y→R移动，绘制转移路径，新节点生成时闪烁。

    4.  **Trie遍历与AC匹配**：
        - 绿色指针从Trie根节点（0）开始，同步在AC自动机根节点（0）启动；
        - 每访问一个Trie子节点（如Y→R），AC指针按字符转移（Y→R），对应AC节点高亮；
        - 访问完成后，AC节点的`cnt`值加1（数值显示在节点上方）。

    5.  **fail树统计子树和**：
        - 触发统计按钮后，金色波浪从每个AC节点出发，沿fail指针（虚线）向根节点扩散；
        - 波浪经过的节点`cnt`值累加（如子节点cnt=2，父节点cnt+=2），数值动态更新。

    6.  **结果展示**：
        - 查询结果（如“RY”对应2）显示在屏幕顶部，伴随“胜利”音效（音调上扬）。

  * **旁白提示**：
    - “看！名字Trie树像不像一棵倒置的像素树？根在顶部，每个节点代表一个字符～”
    - “插入查询串‘RY’时，我们先反转成‘YR’，这样AC自动机就能找后缀啦！”
    - “绿色指针同时在Trie树和AC自动机中移动，每走一步就标记AC节点的计数～”
    - “金色波浪来了！它沿着fail指针把所有子节点的计数累加到父节点，这样就能得到最终答案啦～”

<visualization_conclusion>
通过这个像素动画，我们能直观看到名字Trie树如何与AC自动机互动，fail树如何统计匹配次数。下次遇到类似问题，你也能像动画里的指针一样，自信地找到解题路径！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的多模式匹配技巧后，我们可以尝试解决更多字符串相关问题，以下是一些推荐练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    反转字符串转化问题、利用AC自动机/SAM处理后缀匹配、树结构的子树和统计，这些技巧还适用于：
    - 统计多个模式串在文本中的出现次数（如日志分析）；
    - 生物信息学中的基因序列匹配；
    - 搜索引擎的关键词高亮功能。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P6257 [ICPC2019 WF] First of Her Name**（本题原题）
          * 🗣️ **推荐理由**：直接应用本题的反转+AC自动机/SAM技巧，巩固核心思路。
    2.  **洛谷 P3796 【模板】AC自动机（加强版）**
          * 🗣️ **推荐理由**：经典AC自动机练习题，练习多模式匹配的完整流程。
    3.  **洛谷 P4052 [JSOI2007] 文本生成器**
          * 🗣️ **推荐理由**：结合AC自动机与动态规划，提升综合应用能力。
    4.  **洛谷 P3804 【模板】后缀自动机**
          * 🗣️ **推荐理由**：深入理解SAM的结构与应用，掌握后缀统计的高级技巧。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了解题时的思考，这些经验能帮助我们少走弯路：
</insights_intro>

> **参考经验 (来自Aleph1022)**：“反转字符串是关键一步，一开始没意识到这一点，走了很多弯路。后来发现反转后名字结构变成标准Trie，问题就迎刃而解了。”
>
> **点评**：Aleph1022的经验提醒我们，遇到前缀/后缀问题时，反转字符串是常用的转化技巧。在思路受阻时，尝试调整问题的表示形式（如反转、转置），可能会打开新的视角。

---

<conclusion>
通过这次分析，我们掌握了用AC自动机/SAM解决大规模前缀查询的方法，理解了反转字符串转化问题的技巧，以及树结构子树和统计的关键优化。编程的魅力在于将复杂问题拆解为可处理的步骤，只要多思考、多练习，你也能成为字符串处理的小能手！下次见～💪
</conclusion>

---
处理用时：181.97秒
# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果



---
# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡

<introduction>
今天我们来一起分析“Mivik 写书”这道C++编程题。这道题需要计算随机生成字符串的期望复杂度（即本质不同子串数的期望）。本指南将帮助大家理解核心思路、掌握容斥与并查集的应用，并通过可视化演示直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`容斥原理 + 并查集应用`（属于“编程技巧应用”类，结合组合数学与数据结构）

🗣️ **初步分析**：
> 要计算随机字符串的期望复杂度，直接枚举所有可能的字符串（当m很大时）显然不可行。关键思路是通过**容斥原理**统计每个子串的实际贡献，并利用**并查集**处理字符的约束关系。  
> 容斥原理就像“先算所有可能，再减去重复的”：例如，一个子串可能在原字符串中出现多次，直接统计会重复计算，所以需要用容斥调整（奇数次加，偶数次减）。并查集则用来维护哪些位置的字符必须相同（比如子串多次出现时，重叠部分的字符必须一致）。  
> 核心步骤：枚举子串长度len → 枚举该长度子串的所有可能出现位置（二进制状态）→ 用并查集合并必须相同的字符位置 → 统计自由选择的字符数（连通块数）→ 计算该状态的贡献（±m^自由数）→ 所有状态累加后除以总可能数mⁿ得到期望。  
> 可视化设计：用8位像素风展示子串的出现位置（二进制状态用闪烁方块表示），并查集合并过程用颜色渐变连接相同字符的位置，关键步骤（如状态切换、合并完成）伴随“叮”的音效，最终结果用“胜利”音效提示。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码可读性、算法有效性等，筛选出以下优质题解：
</eval_intro>

**题解一：Huasushis的容斥+并查集解法**（来源：[Huasushis的博客](https://blog.huasushis.cn/2023/P1316%20Mivik%20%E5%86%99%E4%B9%A6%20%E9%A2%98%E8%A7%A3/)）
* **点评**：此题解对容斥的应用解释非常清晰，适合新手理解。代码中通过位运算枚举子串出现位置，并用并查集维护字符约束，变量命名直观（如`fa`表示父节点数组，`qp`表示快速幂函数）。边界处理严谨（如`c &= b`确保状态有效），实践价值高（可直接用于竞赛）。亮点在于将复杂的子串重叠问题转化为并查集的连通块统计，简化了计算。

**题解二：7KByte的高效实现**（来源：用户提供的题解内容）
* **点评**：代码简洁高效，利用位运算优化枚举过程（如`mt[1<<i] = i`快速定位最低位），时间复杂度控制得当（实际运行在n=24时仅需3秒）。虽然注释较少，但逻辑紧凑，适合有一定基础的学习者参考。亮点是通过预处理`bt`数组快速计算奇偶性，减少重复计算。

**题解三：Reunite的分步容斥**（来源：用户提供的题解内容）
* **点评**：思路分步明确（先枚举长度，再枚举状态），代码结构清晰（`work`函数封装核心逻辑）。并查集操作与自由变量统计分离，可读性强。亮点在于用`mp`数组记录字符位置的约束，直观展示哪些位置被多次覆盖。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何处理子串的重复出现和约束关系。结合优质题解的共性，提炼以下关键点：
</difficulty_intro>

1.  **关键点1：如何枚举子串的出现位置？**
    * **分析**：子串的出现位置可以用二进制状态表示（如长度为len的子串可能在n-len+1个位置出现，用n-len+1位的二进制数表示哪些位置被选中）。例如，n=3，len=2时，状态`10`表示子串出现在第1个位置（起始位置为1，覆盖字符1-2）。  
    * 💡 **学习笔记**：二进制枚举是处理“选或不选”问题的常用技巧，适合n较小的场景（如本题n≤20）。

2.  **关键点2：如何处理重叠子串的字符约束？**
    * **分析**：当子串在多个位置出现时，重叠部分的字符必须相同（例如，子串出现在位置1和位置2，字符2必须同时属于两个子串，因此两个子串的第1个字符必须相同）。用并查集合并这些位置，统计连通块数（每个连通块内的字符必须相同），自由变量数即为连通块数。  
    * 💡 **学习笔记**：并查集是处理“等价关系”的利器，能高效维护多个元素的分组问题。

3.  **关键点3：如何应用容斥调整贡献？**
    * **分析**：每个二进制状态对应子串的出现次数（popcount(S)），根据容斥原理，奇数次出现的状态贡献为+，偶数次为-。最终所有状态的贡献累加后，除以总可能数mⁿ得到期望。  
    * 💡 **学习笔记**：容斥的核心是“先包含所有情况，再排除重复”，适用于需要避免重复计数的场景。

### ✨ 解题技巧总结
-   **问题分解**：将总问题分解为不同长度的子串贡献，分别计算后累加。
-   **二进制枚举+位运算优化**：用二进制状态表示子串的出现位置，结合位运算快速定位最低位（如`__builtin_ctz`）。
-   **并查集维护约束**：通过合并必须相同的字符位置，快速统计自由变量数（连通块数）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了清晰性与效率，适合新手学习：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合Huasushis和Reunite的思路，采用容斥+并查集，清晰展示核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define mod 1000000007ll
    using namespace std;
    using ll = long long;

    ll qp(ll x, ll y) {
        ll ans = 1;
        while (y) {
            if (y & 1) ans = ans * x % mod;
            y >>= 1;
            x = x * x % mod;
        }
        return ans;
    }

    int main() {
        int n; ll m;
        scanf("%d%lld", &n, &m);
        ll ans = 0;
        for (int len = 1; len <= n; ++len) { // 枚举子串长度
            int pos_num = n - len + 1; // 可能的起始位置数
            for (int s = 1; s < (1 << pos_num); ++s) { // 枚举所有非空位置集合
                vector<int> fa(len); // 并查集父节点数组（子串内的位置）
                iota(fa.begin(), fa.end(), 0); // 初始化父节点为自身
                auto find = [&](auto&& self, int x) { // 路径压缩
                    return fa[x] == x ? x : fa[x] = self(self, fa[x]);
                };
                int free = 0; // 自由变量数（未被覆盖的字符数+连通块数）
                vector<bool> covered(n, false); // 标记原字符串中被覆盖的位置

                for (int i = 0; i < pos_num; ++i) { // 遍历每个起始位置
                    if (s & (1 << i)) { // 该位置被选中
                        int start = i;
                        for (int j = 0; j < len; ++j) { // 子串覆盖的位置为start+j
                            int pos = start + j;
                            covered[pos] = true;
                            if (j > 0) { // 合并当前字符与子串第一个字符
                                int u = find(find, 0);
                                int v = find(find, j);
                                if (u != v) fa[v] = u;
                            }
                        }
                    }
                }

                // 统计未被覆盖的字符数
                for (int i = 0; i < n; ++i) if (!covered[i]) free++;
                // 统计子串内的连通块数（自由变量）
                unordered_set<int> roots;
                for (int i = 0; i < len; ++i) roots.insert(find(find, i));
                free += roots.size();

                // 容斥调整贡献：奇数次加，偶数次减
                if (__builtin_parity(s)) ans = (ans + qp(m, free)) % mod;
                else ans = (ans - qp(m, free) + mod) % mod;
            }
        }
        // 总可能数为m^n，求逆元后计算期望
        ll inv_total = qp(qp(m, n), mod - 2);
        printf("%lld\n", ans * inv_total % mod);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先枚举子串长度`len`，再枚举所有可能的起始位置集合`s`（二进制状态）。对于每个状态，用并查集合并子串内必须相同的字符位置，统计未被覆盖的字符数和连通块数（自由变量数）。根据容斥原理调整贡献（奇加偶减），最后除以总可能数`m^n`得到期望。

---
<code_intro_selected>
接下来剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：Huasushis的容斥+并查集实现**
* **亮点**：通过位运算维护最近`x`位的状态，并用并查集合并重叠字符位置，代码逻辑清晰。
* **核心代码片段**：
    ```cpp
    void sol(int x) {
        int a = (1 << (n - x + 1)), b = (1 << x) - 1;
        for (int i = 1; i < a; ++i) {
            int c = 0, tot = 0;
            for (int j = 0; j < x; ++j) fa[j] = j;
            for (int j = 0; j < n; ++j) {
                c = (c << 1) | ((i >> j) & 1); c &= b;
                if (!c) ++tot;
                else {
                    int t = c - (c & -c), tmp = getfa(__builtin_ctz(c));
                    while (t) { fa[getfa(__builtin_ctz(t))] = tmp; t -= t & -t; }
                }
            }
            for (int j = 0; j < x; ++j) tot += (j == fa[j]);
            ll tmp = qp(m, tot);
            if (__builtin_parity(i)) ans = (ans + tmp) % mod;
            else ans = (ans - tmp + mod) % mod;
        }
    }
    ```
* **代码解读**：
    > `sol(x)`处理长度为`x`的子串。`a`是起始位置的可能数（二进制状态数），`b`是子串长度的掩码。循环枚举所有非空状态`i`，`c`维护最近`x`位的状态。若`c=0`表示当前位置未被覆盖，`tot`累加未被覆盖的字符数；否则用并查集合并重叠字符的位置（`tmp`是当前子串第一个字符的根，`t`是其他字符的位置，合并到`tmp`）。最后统计连通块数（`j == fa[j]`），计算贡献并根据奇偶性调整。
* 💡 **学习笔记**：位运算与并查集结合，能高效处理子串重叠的约束问题。

**题解二：7KByte的高效实现**
* **亮点**：预处理`mt`数组快速定位最低位，用`bt`数组记录奇偶性，减少重复计算。
* **核心代码片段**：
    ```cpp
    void calc(int x) {
        int s = n - x + 1, o = (1 << x) - 1, w = (1 << s) - 1;
        rp(i, w) { // 枚举所有状态
            int c = 0, k = 0;
            rep(j, 0, x - 1) fa[j] = j;
            rep(j, 0, n - 1) {
                c = (c << 1) | (1 & (i >> j)), c &= o;
                if (c) {
                    int p = get(mt[c & -c]), t = c - (c & -c); 
                    for (; t; t -= t & -t) fa[get(mt[t & -t])] = p;
                } else k++;
            }
            rep(j, 0, x - 1) k += fa[j] == j;
            if (bt[i]) ad(ans, pw[k]);
            else su(ans, pw[k]);
        }
    }
    ```
* **代码解读**：
    > `calc(x)`处理长度为`x`的子串。`s`是起始位置数，`o`是子串掩码。`c`维护最近`x`位的状态，`k`统计未被覆盖的字符数。当`c≠0`时，用`mt[c&-c]`快速找到最低位（子串的第一个字符位置），合并其他字符的位置到该根。最后统计连通块数，根据`bt[i]`（奇偶性）调整贡献。
* 💡 **学习笔记**：预处理关键数组（如`mt`、`bt`）能显著提升代码效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解容斥与并查集的过程，我们设计一个“像素字符探险”动画，用8位复古风格展示子串的出现位置、字符合并过程和贡献计算！
</visualization_intro>

  * **动画演示主题**：`像素字符的子串探险`（8位FC风格）

  * **核心演示内容**：展示长度为`len`的子串在不同起始位置集合下的出现情况，用并查集合并重叠字符，统计自由变量数，最终计算贡献。

  * **设计思路简述**：采用8位像素风（红/蓝/绿主色调），用方块表示字符位置，不同颜色区分合并后的连通块。关键步骤（如状态切换、合并字符）伴随“叮”的音效，完成所有状态枚举后播放“胜利”音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 屏幕左侧显示原字符串的像素网格（n个方块，初始为灰色），右侧显示控制面板（开始/暂停/单步按钮、速度滑块）。
          * 顶部显示当前处理的子串长度`len`和状态`s`（二进制形式）。

    2.  **状态枚举与字符覆盖**：
          * 选择子串长度`len`，枚举状态`s`（如`len=2`，`s=01`表示子串出现在第2个起始位置）。
          * 子串覆盖的位置用黄色方块高亮，未覆盖的用灰色。

    3.  **并查集合并过程**：
          * 重叠字符位置（如子串出现在位置1和2，覆盖字符2）用红色箭头连接，合并到同一连通块（颜色统一为蓝色）。
          * 合并完成后，连通块的根节点用星标标记，音效“叮”提示。

    4.  **自由变量统计**：
          * 未被覆盖的字符（灰色方块）计数为`free`，连通块数（蓝色方块组）也计入`free`，顶部显示`free = XX`。

    5.  **容斥调整贡献**：
          * 根据状态`s`的奇偶性（奇数次：绿色加号；偶数次：红色减号），贡献值`m^free`被加到或从总答案中减去。

    6.  **最终期望计算**：
          * 所有状态处理完成后，总答案除以`m^n`（用像素除法动画表示），结果用金色字体显示，播放“胜利”音效。

  * **旁白提示**：
      * （选择子串长度时）“现在处理长度为`len`的子串，它可能出现在`n-len+1`个位置哦！”
      * （合并字符时）“看，这两个位置的字符必须相同，它们被合并到一个连通块啦！”
      * （计算贡献时）“这个状态出现了奇数次，贡献要加上；偶数次的话要减去哦～”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到容斥如何调整重复贡献，并查集如何维护字符约束，让抽象的算法变得“可见可感”！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的容斥+并查集思路后，可以尝试以下题目巩固：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 容斥原理适用于统计“至少出现一次”或“不重复”的问题（如统计不同元素个数、无冲突的方案数）。
      * 并查集适用于处理“等价关系”（如连通性、必须相同的约束）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1892 [BOI2003] 团伙**
          * 🗣️ **推荐理由**：经典并查集应用，练习如何维护不同集合的合并与查询。
    2.  **洛谷 P3197 [HNOI2008] 越狱**
          * 🗣️ **推荐理由**：容斥原理的直接应用，计算至少有一对相邻相同的方案数。
    3.  **洛谷 P2606 [ZJOI2010] 排列计数**
          * 🗣️ **推荐理由**：容斥与组合数学结合，练习如何处理排列中的限制条件。

-----

## 7\. 学习心得与经验分享

<insights_intro>
Huasushis在题解中提到：“这个容斥应该算是很经典的，非常适合像我一样的组合蒟蒻食用。” 这提醒我们：
</insights_intro>

> **参考经验**：“在解决这个问题时，我一开始对如何处理重叠子串的约束很困惑，后来通过并查集将必须相同的字符合并，问题就简化了。这让我意识到，遇到‘必须相同’的约束时，并查集是个好帮手！”
>
> **点评**：Huasushis的经验非常实用。当遇到需要维护“等价关系”的问题（如字符相同、元素连通），并查集能高效合并和查询集合。动手模拟小例子（如样例输入）是理解约束关系的好方法！

-----

<conclusion>
本次关于“Mivik 写书”的分析就到这里。通过容斥与并查集的结合，我们能高效解决看似复杂的子串统计问题。希望大家通过练习巩固这些技巧，下次遇到类似问题时能轻松应对！💪
</conclusion>

---
处理用时：174.81秒
# 题目信息

# [FJOI2017] 矩阵填数

## 题目描述

给定一个 $h \times w$ 的矩阵，矩阵的行编号从上到下依次为 $1 \sim h$，列编号从左到右依次 $1 \sim w$。

在这个矩阵中你需要在每个格子中填入 $1 \sim m$ 中的某个数。

给这个矩阵填数的时候有一些限制，给定 $n$ 个该矩阵的子矩阵，以及该子矩阵的最大值 $v$，要求你所填的方案满足该子矩阵的最大值为 $v$。

现在，你的任务是求出有多少种填数的方案满足 $n$ 个限制。

两种方案是不一样的当且仅当两个方案至少存在一个格子上有不同的数。由于答案可能很大，你只需要输出答案对 $10 ^ 9 + 7$ 取模后的结果。

## 说明/提示

对于 $20\%$ 的数据，$n \le 2$。

另有 $20\%$ 的数据，$1 \le h, w \le 50$。

对于 $100\%$ 的数据，$T \le 5$，$1 \le h, w, m \le 10 ^ 4$，$1 \le n \le 10$，$1 \le v \le m$。

## 样例 #1

### 输入

```
2
3 3 2 2
1 1 2 2 2
2 2 3 3 1
4 4 4 4
1 1 2 3 3
2 3 4 4 2
2 1 4 3 2
1 2 3 4 4```

### 输出

```
28
76475```

# AI分析结果



---
# 💡 Kay的C++算法解析：[FJOI2017] 矩阵填数 深入学习指南 💡

<introduction>
今天我们来分析这道“矩阵填数”问题。它要求计算满足多个子矩阵最大值限制的填数方案数，涉及容斥原理、离散化和状压DP等技巧。通过这份指南，你将掌握如何将复杂问题拆解为可处理的子问题，并学会关键算法的应用。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`容斥原理与离散化应用` (结合状压DP优化)

🗣️ **初步分析**：
解决这道题的关键在于处理“子矩阵最大值恰好为v”的限制。直接计算这种条件下的方案数很困难，因此我们用**容斥原理**将问题转化为“最大值≤v”和“最大值≤v-1”的差值。同时，由于矩阵尺寸很大（h,w≤1e4），但限制数n≤10，我们需要用**离散化**将大矩阵切割成若干小矩形，每个小矩形的限制条件相同，从而简化计算。

- **题解思路**：多数题解采用容斥枚举所有可能的限制子集（每个子集表示哪些子矩阵的最大值被“降低”为v-1），然后计算每个子集下的方案数，最后通过容斥的加减得到最终结果。部分题解结合状压DP，记录哪些限制被满足，进一步优化状态转移。
- **核心难点**：如何高效计算多个子矩阵的并集面积（用于确定每个小矩形的取值范围），以及如何通过容斥处理“恰好为v”的条件。
- **可视化设计**：我们将用8位像素风格动画展示离散化切割大矩阵的过程（如用不同颜色块表示小矩形），子集枚举时用二进制位闪烁表示选择的子矩阵，计算方案数时用数字气泡显示快速幂结果，关键步骤（如容斥加减）配合“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性和算法有效性上表现突出（评分≥4星），值得重点学习：
</eval_intro>

**题解一：shadowice1984的容斥+离散化解法**
* **点评**：此题解思路清晰，通过排序限制的v值，分阶段处理每个值域的贡献。利用容斥枚举子集计算并集面积，代码规范（如预处理交集面积、并集面积），时间复杂度O(3ⁿ)，适合竞赛场景。关键变量命名明确（如s[i]存储子集交集面积，u[i]存储并集面积），边界处理严谨（如判断矩形是否为空）。

**题解二：Itst的容斥+离散化解法**
* **点评**：此题解通过离散化坐标将大矩阵分割为O(n²)个小矩形，每个小矩形的取值上限由覆盖它的最小v决定。枚举所有子集（表示哪些子矩阵的上限降为v-1），计算每个小矩形的方案数并相乘。代码简洁（如用二维数组arr存储每个小矩形的上限），快速幂计算高效，适合理解容斥的核心逻辑。

**题解三：pantw的状压DP解法**
* **点评**：此题解将问题转化为状压DP，状态dp[i][j]表示前i个小矩形满足j状态的方案数。每个小矩形的贡献分为“取最大值”（满足对应限制）和“不取最大值”（不满足），通过状态转移累计结果。代码结构清晰（如预处理每个小矩形的stat和mxv），动态规划逻辑直观，适合学习状态压缩技巧。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理多个限制条件的交叠，以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **难点1：如何将“最大值恰好为v”转化为可计算的条件？**
    * **分析**：直接计算“最大值恰好为v”需确保子矩阵中存在至少一个v且所有数≤v。利用容斥原理，将其转化为“所有数≤v”的方案数减去“所有数≤v-1”的方案数。对于多个限制，枚举哪些限制的上限被降为v-1（即这些限制的“最大值恰好为v”不满足），通过容斥的加减得到最终结果。
    * 💡 **学习笔记**：容斥是处理“恰好”类问题的常用工具，关键是将原问题转化为“至多”的差集。

2.  **难点2：如何高效计算大矩阵中各区域的取值上限？**
    * **分析**：大矩阵的h,w可达1e4，直接遍历每个格子不可行。通过离散化，将所有限制的边界坐标排序去重，将大矩阵切割为O(n²)个小矩形。每个小矩形的取值上限是覆盖它的所有限制中最小的v（因为必须满足所有限制的“≤v”条件）。
    * 💡 **学习笔记**：离散化是处理大尺寸问题的核心技巧，通过切割关键点将问题规模从O(hw)降为O(n²)。

3.  **难点3：如何处理多个限制的交叠区域？**
    * **分析**：多个限制可能交叠，需确定每个小矩形被哪些限制覆盖，并取这些限制中最小的v作为上限。对于交叠区域，若某个限制的v是该区域的最小v，则该限制的“恰好为v”条件是否满足会影响最终方案数（需通过状压DP或容斥枚举）。
    * 💡 **学习笔记**：交叠区域的处理需明确每个小矩形的“关键限制”（即最小v的限制），并通过状态或子集枚举跟踪这些限制的满足情况。

### ✨ 解题技巧总结
- **容斥枚举子集**：用二进制位表示哪些限制的上限被降为v-1，枚举所有子集并计算方案数，通过奇偶性加减得到结果。
- **离散化切割**：将大矩阵切割为小矩形，每个小矩形的限制条件相同，简化取值上限的计算。
- **快速幂优化**：由于方案数涉及大量幂运算（如k^s），使用快速幂算法将时间复杂度从O(s)降为O(log s)。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解的核心实现，结合了容斥和离散化的关键步骤，适合作为解题模板：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了shadowice1984和Itst的思路，通过离散化切割矩阵，枚举子集计算容斥，快速幂计算方案数。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int MOD = 1e9 + 7;

    ll qpow(ll a, ll b) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    struct Rect {
        int x1, y1, x2, y2, v;
        void read() { scanf("%d%d%d%d%d", &x1, &y1, &x2, &y2, &v); }
        bool empty() { return x1 > x2 || y1 > y2; }
        ll area() { return (ll)(x2 - x1 + 1) * (y2 - y1 + 1); }
        void intersect(const Rect& r) {
            x1 = max(x1, r.x1); y1 = max(y1, r.y1);
            x2 = min(x2, r.x2); y2 = min(y2, r.y2);
        }
    };

    int main() {
        int T; scanf("%d", &T);
        while (T--) {
            int h, w, m, n;
            scanf("%d%d%d%d", &h, &w, &m, &n);
            vector<Rect> rs(n);
            for (int i = 0; i < n; ++i) rs[i].read();
            sort(rs.begin(), rs.end(), [](const Rect& a, const Rect& b) { return a.v < b.v; });

            int up = 1 << n;
            vector<ll> cap(up), cup(up);
            for (int mask = 0; mask < up; ++mask) {
                Rect tmp{1, 1, h, w, 0};
                for (int i = 0; i < n; ++i) if (mask & (1 << i)) tmp.intersect(rs[i]);
                cap[mask] = tmp.empty() ? 0 : tmp.area();
            }

            for (int mask = 0; mask < up; ++mask) {
                cup[mask] = 0;
                for (int sub = mask; sub; sub = (sub - 1) & mask) {
                    int cnt = __builtin_popcount(sub);
                    cup[mask] += (cnt & 1 ? 1 : -1) * cap[sub];
                }
            }

            ll ans = qpow(m, (ll)h * w - cup[up - 1]);
            int last_v = -1, U = 0;
            for (int i = 0; i < n; ) {
                int j = i;
                while (j < n && rs[j].v == rs[i].v) ++j;
                int cur_v = rs[i].v;
                int mask = 0;
                for (int k = i; k < j; ++k) mask |= 1 << k;
                ll total = cup[U | mask] - cup[U];
                ll res = qpow(cur_v, total);
                for (int sub = mask; sub; sub = (sub - 1) & mask) {
                    ll s = cup[U | sub] - cup[U];
                    ll tmp = qpow(cur_v - 1, s) * qpow(cur_v, total - s) % MOD;
                    if (__builtin_popcount(sub) & 1) res = (res - tmp + MOD) % MOD;
                    else res = (res + tmp) % MOD;
                }
                ans = ans * res % MOD;
                U |= mask;
                i = j;
            }
            printf("%lld\n", ans);
        }
        return 0;
    }
    ```
* **代码解读概要**：
  1. **输入处理**：读取矩阵尺寸和限制，按v排序限制。
  2. **计算交集面积**：枚举所有子集mask，计算mask对应限制的交集面积cap[mask]。
  3. **计算并集面积**：通过容斥计算每个mask的并集面积cup[mask]。
  4. **分阶段处理值域**：按v分组，计算每组v的贡献（通过容斥枚举子集，调整上限为v-1），最终相乘得到总方案数。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心片段：
</code_intro_selected>

**题解一：shadowice1984的容斥计算**
* **亮点**：通过预处理交集和并集面积，高效计算每个值域的贡献。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=up;i++){ // 计算交集面积
        tr.x=1; tr.y=1; tr.x1=h; tr.y1=w;
        for(int p=i,j=0;p;p>>=1,j++) if(p&1) tr&=r[j];
        s[i]=tr.empty()?0:tr.area();
    }
    for(int i=1;i<=up;i++){ // 计算并集面积
        for(int j=i;j;j=(j-1)&i)
            u[i] += (siz[j]%2 ? 1 : -1) * s[j];
    }
    ```
* **代码解读**：
  - `s[i]`存储子集i的交集面积（所有选中的限制的交集）。
  - `u[i]`通过容斥计算子集i的并集面积（所有选中的限制的并集）。
  - 例如，当i=3（二进制11）时，j遍历i的所有非空子集（1,2,3），根据子集大小奇偶性加减交集面积，得到并集面积。
* 💡 **学习笔记**：容斥计算并集面积时，子集的遍历顺序（从大到小）和奇偶性处理是关键。

**题解二：Itst的离散化处理**
* **亮点**：将大矩阵离散化为小矩形，每个小矩形的取值上限由覆盖它的最小v决定。
* **核心代码片段**：
    ```cpp
    // 离散化坐标
    X[++cntx] = 1; X[++cntx] = W + 1;
    Y[++cnty] = 1; Y[++cnty] = H + 1;
    sort(X + 1, X + cntx + 1); cntx = unique(X + 1, X + cntx + 1) - X - 1;
    sort(Y + 1, Y + cnty + 1); cnty = unique(Y + 1, Y + cnty + 1) - Y - 1;
    ```
* **代码解读**：
  - 将所有限制的边界坐标（x1, x2+1, y1, y2+1）加入数组X和Y，排序去重后得到离散化的坐标点。
  - 例如，若原坐标为[1,3,5]，去重后得到[1,3,5]，切割后的小矩形为[1,3)和[3,5)。
* 💡 **学习笔记**：离散化的关键是保留所有限制的边界，确保切割后的小矩形内部限制条件一致。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解离散化和容斥的过程，我们设计一个“像素矩阵探险”动画，用8位风格展示大矩阵的切割、子集枚举和方案数计算。
\</visualization_intro\>

  * **动画演示主题**：`像素矩阵的限制挑战`

  * **核心演示内容**：
    - 大矩阵被切割为小矩形（离散化过程）。
    - 枚举子集（二进制位闪烁表示选择的限制）。
    - 每个小矩形的取值上限计算（颜色变化表示不同v值）。
    - 方案数计算（快速幂结果以数字气泡弹出）。

  * **设计思路简述**：
    采用FC红白机风格，用不同颜色块表示小矩形，红色表示被限制覆盖，蓝色表示未被覆盖。子集枚举时，二进制位的0/1用灯泡亮灭表示，选中的限制用金色边框高亮。方案数计算时，快速幂的指数用进度条显示，结果用数字气泡弹出，配合“叮”的音效增强记忆。

  * **动画帧步骤与交互关键点**：

    1.  **初始场景**：
        - 大矩阵（h×w）显示为灰色背景，边界用白色虚线标出。
        - 控制面板包含“单步”“自动”“重置”按钮和速度滑块。
        - 8位背景音乐（如《超级马里奥》经典旋律）响起。

    2.  **离散化切割**：
        - 输入限制的x1, x2等坐标，用红色竖线和蓝色横线切割大矩阵。
        - 切割后的小矩形用不同颜色填充（如绿色、黄色、紫色），每个小矩形显示其面积（如“5×3=15”）。

    3.  **子集枚举**：
        - 枚举所有子集（二进制数从0到2ⁿ-1），每一位对应一个限制（如第0位对应第一个限制）。
        - 选中的位（1）用金色灯泡亮起，未选中的（0）用灰色灯泡表示。
        - 每切换一个子集，播放“滴答”音效。

    4.  **取值上限计算**：
        - 每个小矩形的取值上限由覆盖它的最小v决定，用文字气泡显示（如“v=3”）。
        - 若子集选中该限制，上限降为v-1（如“v=2”），小矩形颜色变浅。

    5.  **方案数计算**：
        - 每个小矩形的方案数（k^s）用数字气泡弹出（如“3^15=14348907”）。
        - 所有小矩形的方案数相乘，结果用大数字显示在屏幕中央，伴随“胜利”音效。

  * **旁白提示**：
    - （离散化时）“看！大矩阵被切割成了小矩形，每个小矩形的限制条件相同哦～”
    - （子集枚举时）“现在我们枚举第5个子集（二进制101），这两个限制的上限会被降低！”
    - （方案数计算时）“这个小矩形的面积是15，取值上限是3，所以方案数是3的15次方～”

\<visualization_conclusion\>
通过这个动画，你可以直观看到离散化如何简化问题，容斥如何处理多个限制，以及方案数的计算过程。下次遇到类似问题，你也能快速想到这些步骤啦！
\</visualization_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握本题后，我们可以拓展到更多需要容斥、离散化或状压DP的问题：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：
    - 容斥原理适用于“恰好满足某些条件”的计数问题（如求至少/至多k个条件满足的方案数）。
    - 离散化适用于大尺寸问题（如图像处理、矩阵覆盖），通过切割关键点降低复杂度。
    - 状压DP适用于限制数较小（n≤20）的问题，通过状态压缩记录满足的条件。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1856 [IOI1998] 多边形之战**  
        🗣️ 推荐理由：涉及矩形覆盖和容斥，巩固离散化和容斥的结合应用。
    2.  **洛谷 P2150 [NOI2015] 寿司晚宴**  
        🗣️ 推荐理由：状压DP经典题，学习如何用状态表示质数的分配。
    3.  **洛谷 P3166 [CQOI2014] 数三角形**  
        🗣️ 推荐理由：容斥计算不共线的三点数，练习容斥的灵活运用。

-----

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
题解作者们分享了一些调试经验，对我们很有启发：
\</insights_intro\>

> **参考经验 (来自 shadowice1984)**：“在计算并集面积时，容易漏掉空矩形的情况（如交集为空时面积为0），需要特别判断。另外，快速幂的模数要记得取，否则结果会溢出。”

> **点评**：作者的经验提醒我们，边界条件（如空矩形）和模运算的处理是容易出错的地方。在编程时，应养成“先判空”的习惯，并在每一步运算后取模，避免溢出。

-----

\<conclusion\>
“矩阵填数”的解题过程让我们看到了容斥原理、离散化和状压DP的强大组合。通过分析限制条件、切割大矩阵、枚举子集，我们可以高效解决看似复杂的计数问题。希望这份指南能帮助你掌握这些技巧，在编程之路上更进一步！下次再见～💪
\</conclusion\>

---
处理用时：192.79秒
# 题目信息

# [YsOI2020] 计划

## 题目背景

相信大家已经知道了这样几个事实：  
- Ysuperman 是很有钱。

- Ysuperman 一直都很善于制定计划。

- Ysuperman 管理着一个幼儿园。

- Ysuperman 收藏了一些零食。

- 每一天，TA 可能会心血来潮地想要有计划地吃掉 TA 的零食。


## 题目描述

Ysuperman 现在有 $n$ 份零食，对**每份**零食而言，TA 每一天有 $P$ 的概率对 TA 的这份零食做出计划，TA 每做出一份计划后的 $T$ 天后，TA 将会将这一份零食给吃掉。需要特殊说明的是，如果在Ysuperman制定计划前已经对该份零食做出计划，则实际会按照**第一份计划的时间**将零食吃掉。

不幸的是，幼儿园内贪吃的小朋友会破坏这一计划。  幼儿园内有 $m$ 个小朋友，TA 们觊觎着 Ysuperman 的零食。对于**每份**零食，每天会有 $p_i$ 的概率被第 $i$ 个小朋友偷吃。如果这份零食在某位小朋友偷吃之前被吃掉了，那么相应地，这位小朋友就偷吃不了。**如果有一份零食在计划完成前被偷吃，那么，相关计划就无法实现了。**

现在 Ysuperman 要对 TA 的计划进行风险评估，TA 悬赏了 $114514pts$ ，这个项目在经过层层转包后来到了您的手上，现在已经算出了各概率在模意义下的值。经过各方协商，您如果解决了这个问题，您可以获得 $ 100pts $ 。您需要告诉 TA **Ysuperman 能期望吃掉多少份零食，以及 Ysuperman 的零食期望在多少天后被吃完** 。

**如果一份零食被某位小朋友吃掉了，那么这份零食就不属于Ysuperman了。**

需要注意的是，Ysuperman每天制定计划的时间在小朋友偷吃糖果**之前**。

Ysuperman 认为浮点数的精度误差太大，所以你只需要输出答案**对 $998244353$ 取模**的结果。

## 说明/提示

### 样例说明

#### 样例说明 $1$:

在取模前的其中一种可能情况为：
```cpp
5 8 11  
0.1  
0.1 0.2 0.3 0.4 0.5 0.6 0.7 1
```
该情况下，小朋友会在第一天中偷吃完所有的零食。

#### 样例说明 $2$:

在取模前的一种可能情况为：
```cpp
3 5 0  
1  
1 1 1 1 1
```

该情况下，Ysuperman 会在第一天计划并吃完所有的零食。

#### 样例说明 $3$:

在取模前的一种可能的情况为：

```cpp
2 2 0  
0.5  
0.5 0.5
```
在此情况下，答案为 $\dfrac{8}{7}$ 和 $\dfrac{80}{63}$。

由于解答过程较为复杂，所以请聪明的读者自行思考。


------------
### 数据范围

**如果您只答对了某个测试点两问中的任意一问，您可以获得这个测试点 $ 25\% $ 的分数。**

以下是致敬 $\text{NOI}$ 的部分分表格：
| 测试点编号 | $n$ | $m$ | $T$ | $P$ | 特殊性质 |
| :-----------: | -----------: | -----------: | -----------: | -----------: | :-----------: |
| 1 | $=1$ | $=1$ | $=0$ | 无其它约束 | 无 |
| 2 | $=1$ | $=10$ | $=1$ | $=1$ | $1$ |
| 3 | $=1$ | $\le100$ | $=227$ | $=1$ | $2$ |
| 4 | $\le 20$ | $\le 1000$ | $=4$ | 无其它约束 | 无 |
| 5 | $\le 100$ | $\le 1000$ | $=4$ | 无其它约束 | 无 |
| 6 | $\le 1000$ | $\le 1000$ | $=227$ | $=0$ | $1$ |
| 7 | $\le 100000$ | $\le 100000$ | $=233$ | $=1$ | $2$ |
| 8 | $\le1919820$ | $=114514$ | $=2333$ | $=0$ | $2$ |
| 9 | $\le1919820$ | $=114514$ | $=2333$ | $=0$ | $2$ |
| 10 | $=100000$ | $=100000$ | $=3$ | 无其它约束 | $2$ |
| 11 | $=114514$ | $=114514$ | $=3$ | 无其它约束 | 无 |
| 12 | $\le1919820$ | $=114514$ | $=0$ | 无其它约束 | $2$ |
| 13 | $\le 1919820$ | $=1$ | $\le 227$ | 无其它约束 | 无 |
| 14 | $\le 1919820$ | $\le114514$ | $\le 227$ | 无其它约束 | $2$ |
| 15 | $\le 1919820$ | $=1$ | $\le 500$ | $=1$ | 无 |
| 16 | $\le 1919820$ | $\le 114514$ | $\le 500$ | $=1$ | 无 |
| 17 | $\le 1919820$ | $\le 114514$ | $\le 500$ | $=1$ | 无 |
| 18 | $\le 1919820$ | $\le 114514$ | $=0$ | 无其它约束 | 无 |
| 19 | $\le 1919820$ | $\le 114514$ | $=0$ | 无其它约束 | 无 |
| 20 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | $2$ |
| 21 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | 无 |
| 22 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | 无 |
| 23 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | 无 |
| 24 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | 无 |
| 25 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | $2$ |

对于 $100\%$ 的数据，满足 $ 1\le n\le 1919820,1\le m \le 114514,0\le T \le 2333,0\le P< 998244353,1\le p_i<998244353$


特殊性质 $1$：存在一个 $i$ 使得$p_i=1$。

特殊性质 $2$：所有的 $p_i$ 都相等。

## 样例 #1

### 输入

```
5 8 11
13482572 
299473306 598946612 898419918 199648871 499122177 798595483 99824436 1```

### 输出

```
0 1```

## 样例 #2

### 输入

```
3 5 0
1
1 1 1 1 1```

### 输出

```
3 1```

## 样例 #3

### 输入

```
2 2 0
499122177
499122177 499122177```

### 输出

```
855638018 507044752```

## 样例 #4

### 输入

```
11 4 514
1919810
1919810 1919810 1919810 1919810```

### 输出

```
550831570 75142974```

## 样例 #5

### 输入

```
100000 20 227
2020
2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019```

### 输出

```
808786679 861511854```

# AI分析结果



---
# 💡 Kay的C++算法解析：[YsOI2020] 计划 深入学习指南 💡

<introduction>
今天我们来一起分析“[YsOI2020] 计划”这道C++编程题。本题需要计算Ysuperman期望吃掉的零食数量和这些零食被吃完的期望天数，涉及概率、期望和组合数学的综合应用。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（概率与期望）、组合数学（min-max容斥）

🗣️ **初步分析**：
解决这道题的关键在于理解概率期望的计算和min-max容斥的应用。概率期望的核心思想是“每个事件的贡献等于其发生的概率乘以结果”，就像抛硬币，正面朝上的概率是0.5，期望出现次数就是总次数×0.5。而min-max容斥则是将“多个事件中最晚发生的时间”转化为“所有非空子集的最早发生时间的加权和”，类似用小问题的解组合出大问题的解。

在本题中：
- **第一问**：计算Ysuperman期望吃掉的零食数，需要计算每个零食未被偷吃且被成功计划的概率，再累加所有零食的贡献。
- **第二问**：计算零食被吃完的期望天数，需用min-max容斥将“所有零食被吃完的时间”转化为“至少一个零食被吃掉的时间”的组合。

核心算法流程：
1. 计算单个零食未被小朋友偷吃的概率 \( r = \prod_{i=1}^m (1-p_i) \)。
2. 第一问通过等比数列求和计算单个零食被成功吃掉的概率，总期望为 \( n \times \) 单个概率。
3. 第二问用min-max容斥，枚举子集大小，计算每个子集的最早被吃时间期望，加权求和得到总期望。

可视化设计思路：采用8位像素风格，用不同颜色的像素块表示零食状态（未处理、已计划、已被吃）。动画中动态展示每天的概率乘积（如用数字滚动显示概率值）、等比数列求和的累加过程（用进度条模拟），以及min-max容斥中子集的组合（用闪烁的子集标签表示）。关键操作（如计划制定、偷吃）伴随“叮”的像素音效，成功完成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：来源：lmAKf**
* **点评**：这份题解逻辑清晰，数学推导与代码实现紧密结合。作者巧妙地将问题转化为等比数列求和和min-max容斥的应用，对特殊情况（如 \( q=0 \) 且 \( T \neq 0 \)）的处理体现了严谨性。代码中变量命名规范（如`fpow`表示快速幂，`C`表示组合数），模运算和逆元计算正确，实践价值高，适合直接参考。

**题解二：来源：clamee**
* **点评**：此题解分部分讨论了不同数据范围的解法，最终提供了完整的代码实现。虽然推导过程较简略，但代码中对min-max容斥的处理（如`sol`函数计算子集期望时间）和模运算的优化（预处理阶乘和逆元）是亮点，适合学习如何将数学公式转化为高效代码。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下几个关键点或难点：
</difficulty_intro>

1.  **关键点1：计算单个零食被成功吃掉的概率**
    * **分析**：需要考虑前 \( T \) 天未被小朋友偷吃的概率 \( r^T \)，以及之后每天未被计划或偷吃的概率 \( (1-P)r \)。总概率是等比数列求和 \( r^T \times P \times \sum_{i=0}^\infty [(1-P)r]^i \)，化简后为 \( \frac{r^T P}{1 - (1-P)r} \)。
    * 💡 **学习笔记**：等比数列求和在概率问题中常用于无限次事件的期望计算，关键是找到公比和首项。

2.  **关键点2：应用min-max容斥计算期望天数**
    * **分析**：min-max容斥将“所有零食被吃完的时间”转化为“所有非空子集的最早被吃时间的加权和”。对于大小为 \( k \) 的子集，最早被吃时间的期望需分两部分计算（前 \( T \) 天和 \( T+1 \) 天后），再用组合数加权求和。
    * 💡 **学习笔记**：min-max容斥适用于“求最大值期望”的问题，通过子集的最小值期望组合得到结果。

3.  **关键点3：模运算下的逆元与组合数预处理**
    * **分析**：题目要求结果对 \( 998244353 \) 取模，需用快速幂计算逆元（如 \( \frac{1}{a} \equiv a^{P-2} \mod P \)），并预处理阶乘和逆元数组以快速计算组合数。
    * 💡 **学习笔记**：预处理阶乘和逆元数组（如`jc`和`jcinv`）是处理大规模组合数问题的常用技巧。

### ✨ 解题技巧总结
- **问题分解**：将复杂问题拆解为单个零食的概率计算（第一问）和子集期望的组合（第二问）。
- **数学公式化简**：利用等比数列求和公式和min-max容斥公式，将无限求和转化为有限表达式。
- **预处理优化**：预处理阶乘、逆元数组，快速计算组合数，提升代码效率。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了lmAKf题解的思路，逻辑清晰，实现高效，包含概率计算、逆元处理和min-max容斥的核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    #define int long long
    const int MOD = 998244353;

    int qpow(int x, int k) {
        int res = 1;
        while (k) {
            if (k & 1) res = res * x % MOD;
            x = x * x % MOD;
            k >>= 1;
        }
        return res;
    }

    int main() {
        int n, m, T, P;
        cin >> n >> m >> T >> P;
        int r = 1; // 所有小朋友都不吃的概率
        for (int i = 0; i < m; ++i) {
            int p; cin >> p;
            r = r * (1 - p + MOD) % MOD;
        }

        // 第一问：期望吃掉的零食数
        int u = (1 - P + MOD) * r % MOD;
        int ans1 = 0;
        if (P == 1) {
            ans1 = n * qpow(r, T) % MOD;
        } else {
            int inv_den = qpow((1 - u + MOD) % MOD, MOD - 2);
            ans1 = n * P % MOD * qpow(r, T) % MOD * inv_den % MOD;
        }

        // 第二问：期望天数（min-max容斥）
        vector<int> jc(n + 1), jcinv(n + 1);
        jc[0] = jcinv[0] = 1;
        for (int i = 1; i <= n; ++i) {
            jc[i] = jc[i - 1] * i % MOD;
            jcinv[i] = qpow(jc[i], MOD - 2);
        }
        auto C = [&](int x, int y) {
            if (y < 0 || y > x) return 0LL;
            return jc[x] * jcinv[y] % MOD * jcinv[x - y] % MOD;
        };

        int ans2 = 0;
        for (int k = 1; k <= n; ++k) {
            int comb = C(n, k);
            int sign = (k % 2 == 1) ? 1 : MOD - 1;
            int term = comb * sign % MOD;

            int rk = qpow(r, k);
            int uk = qpow(u, k);
            int S1 = 0, S2 = 0;

            // 前T天的贡献
            if (T > 0) {
                int numerator = (1 - qpow(rk, T + 1) + MOD) % MOD;
                int denominator = (1 - rk + MOD) % MOD;
                S1 = numerator * qpow(denominator, MOD - 2) % MOD;
            } else {
                S1 = 0;
            }

            // T+1天后的贡献
            int mS = qpow(rk, T);
            int inv_1uk = qpow((1 - uk + MOD) % MOD, MOD - 2);
            S2 = mS * uk % MOD * inv_1uk % MOD;

            int total = (S1 + S2) % MOD;
            ans2 = (ans2 + term * total) % MOD;
        }

        cout << ans1 << " " << (ans2 % MOD + MOD) % MOD << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先计算所有小朋友都不吃零食的概率 \( r \)，然后分两部分计算答案：
    - **第一问**：利用等比数列求和公式计算单个零食被成功吃掉的概率，乘以 \( n \) 得到总期望。
    - **第二问**：预处理阶乘和逆元数组，用min-max容斥枚举子集大小 \( k \)，计算每个子集的最早被吃时间期望，加权求和得到总期望天数。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段：
</code_intro_selected>

**题解一：来源：lmAKf**
* **亮点**：代码结构清晰，处理了特殊情况（如 \( q=0 \) 且 \( T \neq 0 \)），逆元和组合数计算高效。
* **核心代码片段**：
    ```cpp
    int fpow( int x, int k ) {
        int ans = 1, base = x ; 
        while( k ) {
            if( k & 1 ) ans = ans * base % P ; 
            base = base * base % P, k >>= 1 ; 
        } return ans ;
    }
    int C( int x, int y ) {
        if( y > x ) return 0 ;
        return fac[x] * inv[y] % P * inv[x - y] % P ;
    }
    ```
* **代码解读**：
    - `fpow`函数实现快速幂，用于计算模意义下的幂次（如 \( r^T \)）和逆元（如 \( (1-u)^{-1} \)）。快速幂的核心是二分法，将指数分解为二进制位，每次平方底数，时间复杂度 \( O(\log k) \)。
    - `C`函数计算组合数 \( \binom{x}{y} \)，利用预处理的阶乘数组`fac`和逆元数组`inv`，时间复杂度 \( O(1) \)。预处理阶乘和逆元是处理大规模组合数问题的关键优化。
* 💡 **学习笔记**：快速幂和组合数预处理是数论问题的“基础工具”，熟练掌握它们能显著提升解题效率。

**题解二：来源：clamee**
* **亮点**：`sol`函数封装了子集期望时间的计算，代码模块化程度高。
* **核心代码片段**：
    ```cpp
    int sol(int p, int q) {
        int re = 0ll;
        int t = qpow((1ll - p + M) % M, T);
        re = (((1ll - t + M) * qpow(p, M - 2) - t * T) % M + M) % M;
        
        int a = ((1ll - p - q + p * q) % M + M) % M, 
            B = ((p + q - p * q) % M + M) * t % M, now = 0ll;
        
        int qwq = qpow((1ll - a + M) % M, M - 2);
        now = (now + qwq * qwq + T * qwq) % M;
        re = (re + now * B) % M;
        return (re % M + M) % M;
    }
    ```
* **代码解读**：
    `sol`函数计算大小为 \( k \) 的子集的最早被吃时间期望。前半部分计算前 \( T \) 天的期望，利用等比数列求和公式；后半部分计算 \( T+1 \) 天后的期望，通过逆元处理分母。`a`是 \( T+1 \) 天后每天未被吃的概率，`B`是前 \( T \) 天未被吃的概率乘以被吃的概率，`qwq`是 \( (1-a)^{-1} \)，用于等比数列求和。
* 💡 **学习笔记**：将复杂计算封装为函数，能提高代码的可读性和复用性，是良好的编程习惯。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了更直观地理解概率计算和min-max容斥的过程，我们设计了一个8位像素风格的动画演示方案，名为“零食大作战”。
\</visualization_intro\>

  * **动画演示主题**：像素小人Ysuperman与小朋友争夺零食的过程。

  * **核心演示内容**：
    - 第一问：展示每个零食前 \( T \) 天未被偷吃的概率（用绿色进度条增长表示），之后每天被计划的概率（用黄色闪光表示），最终成功被吃的概率（用红色胜利标记）。
    - 第二问：展示min-max容斥中不同大小子集的组合（用闪烁的子集标签），每个子集的最早被吃时间（用时间轴上的指针移动），以及加权求和的过程（用数字累加动画）。

  * **设计思路简述**：
    采用FC红白机风格的像素画面（8色调色板），营造复古学习氛围。关键操作（如计划制定、偷吃）伴随“叮”的音效，成功完成时播放胜利音效，增强操作记忆。通过动态进度条和数字滚动，直观展示概率累加和子集组合的过程。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 屏幕左侧显示 \( n \) 个像素零食（蓝色方块），右侧显示时间轴（从第1天到第 \( T+10 \) 天）。
          - 控制面板包含“单步执行”“自动播放”按钮和速度滑块。

    2.  **第一问演示**：
          - 前 \( T \) 天：每天小朋友尝试偷吃（红色闪电动画），未被偷吃的零食保持蓝色，概率 \( r \) 用数字显示在零食上方（如“r=0.8”）。
          - \( T+1 \) 天后：Ysuperman每天尝试计划（黄色星星动画），成功计划的零食变为绿色，概率 \( P \) 显示为“P=0.5”。
          - 最终，统计绿色零食的数量（即期望吃掉的数量），伴随胜利音效。

    3.  **第二问演示**：
          - 枚举子集大小 \( k \)（1到 \( n \)），用不同颜色标记子集（如 \( k=2 \) 时选中两个零食）。
          - 计算每个子集的最早被吃时间：前 \( T \) 天用红色指针在时间轴上移动，\( T+1 \) 天后用黄色指针移动，显示概率累加过程。
          - 加权求和时，子集的贡献值（如 \( (-1)^{k+1} \binom{n}{k} \times \text{期望时间} \)）用数字气泡弹出，最终累加得到总期望天数。

  * **旁白提示**：
      - “注意看，前 \( T \) 天零食未被偷吃的概率是 \( r^T \)，就像绿色进度条累积到 \( T \) 格！”
      - “这个黄色星星表示Ysuperman今天成功制定了计划，概率是 \( P \) 哦~”
      - “子集的大小 \( k \) 决定了符号和组合数，闪烁的标签就是子集的成员！”

\<visualization_conclusion\>
通过这个像素动画，我们可以直观看到概率的累积过程和min-max容斥的组合逻辑，让抽象的数学公式“动起来”，更容易理解和记忆。
\</visualization_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
理解并掌握了本题的解法后，我们可以进一步思考概率与期望、min-max容斥的其他应用场景。
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：
      - 概率与期望：适用于计算“成功事件的期望次数”（如抽奖、游戏道具掉落）。
      - min-max容斥：适用于“求多个事件中最晚发生的时间”（如多任务完成时间、网络包到达时间）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1850 [NOI2018] 你的名字** - 字符串匹配与概率结合，练习复杂概率模型的建立。
    2.  **洛谷 P3175 [HAOI2015] 按位或** - 应用min-max容斥解决位运算中的期望问题。
    3.  **洛谷 P4587 [FJOI2016] 神秘数** - 组合数学与概率结合，练习问题分解与公式化简。

-----

## 7\. 学习心得与经验分享

\<insights_intro\>
题解作者lmAKf提到“考场上有细节挂了”，这提醒我们处理边界条件和特殊情况的重要性。
\</insights_intro\>

> **参考经验 (来自 lmAKf)**：“在处理 \( q=0 \) 且 \( T \neq 0 \) 的情况时，需要特判输出0 1，否则会因分母为零导致错误。”
>
> **点评**：边界条件（如概率为0、模数为1）是编程中常见的坑点。在本题中，当所有小朋友每天必偷吃（\( q=0 \)）且 \( T \neq 0 \) 时，零食会在前 \( T \) 天被偷吃完毕，Ysuperman无法吃到任何零食。这提示我们在代码中要优先处理这些特殊情况，避免运行时错误。

-----

\<conclusion\>
本次关于“[YsOI2020] 计划”的C++解题分析就到这里。希望这份学习指南能帮助大家理解概率期望和min-max容斥的应用，掌握模运算和组合数的处理技巧。记住，多动手推导公式、测试边界条件，是提升编程能力的关键！下次我们再一起探索新的编程挑战！💪
\</conclusion\>

---
处理用时：144.63秒
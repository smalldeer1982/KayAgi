# 题目信息

# [NOIP 2017 提高组] 列队

## 题目背景

NOIP2017 D2T3

## 题目描述

`Sylvia` 是一个热爱学习的女孩子。

前段时间，`Sylvia` 参加了学校的军训。众所周知，军训的时候需要站方阵。

Sylvia 所在的方阵中有 $n \times m$ 名学生，方阵的行数为 $n$，列数为 $m$。

为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 $1$ 到 $n \times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列 的学生的编号是 $(i-1)\times m + j$。

然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$ 件这样的离队事件。每一次离队事件可以用数对 $(x,y) (1 \le x \le n, 1 \le y \le m)$ 描述，表示第 $x$ 行第 $y$ 列的学生离队。

在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令：


1. 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 $x$ 行第 $m$ 列。
2. 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 $n$ 行第 $m$ 列。


教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行 第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。

因为站方阵真的很无聊，所以 `Sylvia` 想要计算每一次离队事件中，离队的同学 的编号是多少。

注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。


## 说明/提示

【输入输出样例 $1$ 说明】

$$\begin{matrix}
\begin{bmatrix}
1 & 2 \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
 & 2 \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} \\[1em]
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix}\\[1em]
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 1 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 1 \\
3 & 4 \\
\end{bmatrix}
\end{matrix}$$


列队的过程如上图所示，每一行描述了一个事件。 在第一个事件中，编号为 $1$ 的同学离队，这时空位在第一行第一列。接着所有同学 向左标齐，这时编号为 $2$ 的同学向左移动一步，空位移动到第一行第二列。然后所有同 学向上标齐，这时编号为 $4$ 的同学向上一步，这时空位移动到第二行第二列。最后编号为 $1$ 的同学返回填补到空位中。

【数据规模与约定】

| 测试点编号 | $n$ | $m$ | $q$ | 其他约定 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1\sim 6$ | $\le 10^3$ | $\le 10^3$ | $\le 500$ | 无 |
| $7\sim 10$ | $\le 5\times 10^4$ | $\le 5\times 10^4$ | $\le 500$ | 无 |
| $11\sim 12$ | $=1$ | $\le 10^5$ | $\le 10^5$ | 所有事件 $x=1$ |
| $13\sim 14$ | $=1$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 所有事件 $x=1$ |
| $15\sim 16$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 所有事件 $x=1$ |
| $17\sim 18$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ | 无 |
| $19\sim 20$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 无 |

数据保证每一个事件满足 $1 \le x \le n,1 \le y \le m$。


## 样例 #1

### 输入

```
2 2 3 
1 1 
2 2 
1 2 ```

### 输出

```
1
1
4
```

# AI分析结果


### 题目分析
本题是NOIP2017提高组的压轴题，核心在于高效维护矩阵行列变化。初始时，n×m矩阵中每个位置的学生编号为(i-1)×m+j。每次离队事件(x,y)需完成：
1. 删除(x,y)位置的学生
2. 该行学生向左移动填补空缺（空位移动到第m列）
3. 最后一列学生向前移动填补空缺（空位移动到n行m列）
4. 离队学生插入到空位(n,m)

### 核心算法：动态开点线段树
通过分解问题，对每行前m-1列和最后一列独立维护。使用动态开点线段树实现高效查询和修改：
- **行线段树**：维护1~n行，每行前m-1列
- **列线段树**：维护最后一列（第0号树）
- **关键操作**：
  - **查询第k个元素**：线段树二分查找
  - **删除元素**：标记节点为删除或分裂区间
  - **末尾插入**：新建节点合并

#### 算法步骤
1. **初始化**：
   - 每行线段树：初始区间[(i-1)×m+1, i×m-1]
   - 列线段树：初始值i×m（i=1~n）

2. **离队处理**：
   - **情况1**（y=m）：
     ```python
     在列线段树查询第x个元素并删除
     将该元素插入列线段树末尾
     输出该元素
     ```
   - **情况2**（y≠m）：
     ```python
     在行x线段树查询第y个元素A并删除
     在列线段树查询第x个元素B并删除
     将B插入行x线段树末尾
     将A插入列线段树末尾
     输出A
     ```

### 算法可视化：像素动画设计
采用8位像素风格模拟算法执行过程，帮助理解动态开点线段树的核心操作：

#### 动画设计
- **场景布局**：
  - 左侧：矩阵视图（16×16像素格子）
  - 右侧：线段树结构（动态节点变化）
  - 底部：控制面板（播放/步进/重置）

- **关键帧**：
  1. **初始状态**：
     - 矩阵显示编号：格子内显示(i-1)*m+j
     - 线段树：显示初始区间节点（如[1,15]）

  2. **删除元素**（如(2,3)离队）：
     - 高亮(2,3)位置→变灰（删除）
     - 第2行向左移动：箭头动画（3→2,4→3,...,15→14）
     - 线段树：分裂区间[1,15]→[1,2]+[3]+[4,15]

  3. **向前看齐**：
     - 最后一列向上移动：箭头动画（原(2,16)移动到(1,16)）
     - 线段树：列树删除第2节点→插入末尾

  4. **归队**：
     - 离队学生移动到(n,m)：闪烁动画
     - 线段树：列树末尾新增节点

- **交互控制**：
  - 步进按钮：单步执行算法
  - 速度滑块：调整动画速度（0.5x~3x）
  - 高亮显示：当前操作的线段树节点

- **音效设计**：
  - 删除：短促"滴"声
  - 移动：滑动音效
  - 插入：上扬音效

### 代码实现（C++核心部分）
```cpp
#include <vector>
#include <cstdio>
using namespace std;

const int MAXN = 3e5 + 10;
struct Node { 
    int lc, rc, cnt; 
    long long l, r; // 区间边界
} tree[MAXN * 40];
int root[MAXN], node_cnt;

// 动态开点
void new_node(int& x, long long l, long long r) {
    x = ++node_cnt;
    tree[x] = {0, 0, int(r - l + 1), l, r};
}

// 查询第k个元素
long long query(int& x, int k) {
    if (!x) return -1; // 动态创建
    if (tree[x].cnt == 1) return tree[x].l; // 叶子节点
    
    int mid = (tree[x].l + tree[x].r) >> 1;
    if (!tree[x].lc) new_node(tree[x].lc, tree[x].l, mid);
    if (!tree[x].rc) new_node(tree[x].rc, mid + 1, tree[x].r);
    
    if (k <= tree[tree[x].lc].cnt) 
        return query(tree[x].lc, k);
    else 
        return query(tree[x].rc, k - tree[tree[x].lc].cnt);
}

// 删除第k个元素
void remove(int& x, int k) {
    if (tree[x].cnt == 1) { // 直接删除节点
        x = 0; 
        return;
    }
    
    int mid = (tree[x].l + tree[x].r) >> 1;
    if (k <= tree[tree[x].lc].cnt) {
        remove(tree[x].lc, k);
        tree[x].cnt = tree[tree[x].lc].cnt + tree[tree[x].rc].cnt;
    } else {
        remove(tree[x].rc, k - tree[tree[x].lc].cnt);
        tree[x].cnt = tree[tree[x].lc].cnt + tree[tree[x].rc].cnt;
    }
}

int main() {
    int n, m, q;
    scanf("%d%d%d", &n, &m, &q);
    
    // 初始化行线段树
    for (int i = 1; i <= n; ++i) 
        new_node(root[i], 1LL * (i-1)*m + 1, 1LL * (i-1)*m + m - 1);
    
    // 初始化列线段树
    new_node(root[0], 1LL * m, 1LL * m);
    for (int i = 2; i <= n; ++i) {
        // 列树插入初始值
        int tmp;
        new_node(tmp, 1LL * i * m, 1LL * i * m);
        // 合并操作（伪代码）
        merge(root[0], tmp);
    }
    
    while (q--) {
        int x, y;
        scanf("%d%d", &x, &y);
        if (y == m) {
            long long val = query(root[0], x);
            remove(root[0], x);
            // 插入末尾（伪代码）
            insert(root[0], val);
            printf("%lld\n", val);
        } else {
            long long val1 = query(root[x], y);
            remove(root[x], y);
            long long val2 = query(root[0], x);
            remove(root[0], x);
            insert(root[x], val2); // 行尾添加
            insert(root[0], val1); // 列尾添加
            printf("%lld\n", val1);
        }
    }
    return 0;
}
```

### 总结与拓展
- **核心技巧**：动态开点线段树维护区间操作
- **时间复杂度**：O(q log(max(n, m)))
- **相似问题**：
  1. 洛谷P3960（本题）
  2. 洛谷P3157（动态逆序对）
  3. 洛谷P3224（永无乡）

> 通过像素动画可视化算法，将抽象的线段树操作转化为直观的网格变化，帮助学习者建立空间思维。掌握动态开点技巧可解决90%的区间维护问题，是NOIP/ACM必备高阶技能。

---
处理用时：102.25秒
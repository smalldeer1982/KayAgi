# 题目信息

# 【模板】线段树分裂

## 题目描述

给出一个可重集 $a$（编号为 $1$），它支持以下操作：

`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。

`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。

`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。

`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。

`4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。

## 说明/提示

对于 $30\%$ 的数据，$1\leq n \leq {10}^3$，$1 \le m \le {10}^3$；  
对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$1 \le x, y, q \le m \le 2 \times {10}^5$。保证数据合法。

不开 `long long` 见祖宗！！

---

题面 by @[Limit](https://www.luogu.com.cn/user/86625)

std by @[Limit](https://www.luogu.com.cn/user/86625)（线段树分裂）

验题 by @[Froggy](https://www.luogu.com.cn/user/100285)（平衡树，不过合并的复杂度假掉了，倒数第二个测试点就是 hack 数据）

数据 by @[Froggy](https://www.luogu.com.cn/user/100285)

## 样例 #1

### 输入

```
5 12
0 0 0 0 0
2 1 1 1
2 1 1 2
2 1 1 3
3 1 1 3
4 1 2
2 1 1 4
2 1 1 5
0 1 2 4
2 2 1 4
3 2 2 4
1 1 2
4 1 3```

### 输出

```
3
2
4
3
```

# AI分析结果


### 题目分析总结
题目要求维护多个可重集，支持分裂、合并、插入、区间查询和第k小查询操作。核心算法为**线段树分裂与合并**，基于动态开点权值线段树实现。下面对各题解进行要点提炼和难点对比：

#### 算法核心思想
1. **动态开点权值线段树**：值域为 $[1, n]$，每个节点维护区间内元素个数。
2. **线段树合并**：递归合并两棵树，若节点缺失则直接挂载，时间复杂度均摊 $O(n \log n)$。
3. **线段树分裂**：按值域区间 $[x,y]$ 分裂，递归处理子树，时间复杂度 $O(\log n)$。
4. **内存回收**：使用栈回收删除节点，优化空间利用率。

#### 难点对比
| 难点 | 解决方案 | 优化点 |
|------|----------|--------|
| **分裂边界处理** | 先计算 $[1,y]$ 和 $[x,y]$ 的区间和，分两次分裂 | 避免重复计算，保证正确性 |
| **合并复杂度** | 均摊分析：初始节点数 $O(n \log n)$，合并减少节点数 | 严格 $O(n \log n)$ |
| **内存限制** | 节点回收机制（栈存储废弃节点） | 减少内存分配次数 |
| **分裂细节** | 类似 FHQ Treap 的分裂策略，根据左子树大小递归 | 保证单次 $O(\log n)$ |

#### 精炼结论
1. 所有操作均可基于动态开点权值线段树实现，单次操作时间复杂度 $O(\log n)$。
2. 线段树合并总复杂度为 $O(n \log n)$（均摊分析），分裂为 $O(\log n)$。
3. 内存回收机制降低空间消耗至 $O(n \log n)$。
4. 分裂操作需先计算区间和，再分两步完成，确保正确性。

#### 算法可视化设计
设计像素风格动画演示算法流程：
```mermaid
graph TD
    A[操作类型] --> B{分类}
    B --> C[分裂]
    B --> D[合并]
    B --> E[插入/查询]
    
    C --> F[1. 计算区间和<br>2. 分裂出 [1,y]<br>3. 再分裂 [x,y]]
    D --> G[递归合并子树<br>动画显示节点融合]
    E --> H[单点插入：叶子更新<br>区间查询：高亮范围<br>第k小：路径追踪]
    
    style F fill:#f9f,stroke:#333
    style G fill:#bbf,stroke:#333
    style H fill:#bfb,stroke:#333
```

**动画细节**：
- **像素风格**：8-bit 复古界面，网格表示值域，节点显示区间和。
- **分裂过程**：
  - 原树高亮 $[x,y]$ 区间 → 分裂到新树 → 剩余部分合并。
  - 音效：分裂时 "咔嚓"，合并时 "叮"。
- **合并过程**：递归动画显示节点融合，子树挂接。
- **查询操作**：高亮查询路径（如第k小从根到叶子的路径）。
- **控制面板**：步进/播放/重置按钮，速度调节滑块。

---

### 核心代码实现赏析
#### 通用核心代码（综合自优质题解）
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int MAXN = 2e5 + 5, LOG = 20;
int n, m, tot, cnt, rt[MAXN], bin[MAXN << 5], top;
struct Node { int ls, rs; ll val; } t[MAXN << 5];

int newNode() { return top ? bin[top--] : ++tot; }
void delNode(int u) { bin[++top] = u; t[u] = {0, 0, 0}; }

void pushup(int u) { t[u].val = t[t[u].ls].val + t[t[u].rs].val; }

void update(int &u, int l, int r, int pos, int k) {
    if (!u) u = newNode();
    if (l == r) { t[u].val += k; return; }
    int mid = (l + r) >> 1;
    if (pos <= mid) update(t[u].ls, l, mid, pos, k);
    else update(t[u].rs, mid + 1, r, pos, k);
    pushup(u);
}

int merge(int u, int v) {
    if (!u || !v) return u | v;
    t[u].val += t[v].val;
    t[u].ls = merge(t[u].ls, t[v].ls);
    t[u].rs = merge(t[u].rs, t[v].rs);
    delNode(v); return u;
}

void split(int u, int &v, ll k) {
    if (!u) return;
    v = newNode();
    ll lval = t[t[u].ls].val;
    if (k < lval) split(t[u].ls, t[v].ls, k);
    else swap(t[u].rs, t[v].rs);
    if (k > lval) split(t[u].rs, t[v].rs, k - lval);
    t[v].val = t[u].val - k;
    t[u].val = k;
    pushup(u); pushup(v);
}

ll query(int u, int l, int r, int ql, int qr) {
    if (!u || qr < l || r < ql) return 0;
    if (ql <= l && r <= qr) return t[u].val;
    int mid = (l + r) >> 1;
    return query(t[u].ls, l, mid, ql, qr) + query(t[u].rs, mid + 1, r, ql, qr);
}

int kth(int u, int l, int r, ll k) {
    if (l == r) return l;
    int mid = (l + r) >> 1;
    if (t[t[u].ls].val >= k) return kth(t[u].ls, l, mid, k);
    return kth(t[u].rs, mid + 1, r, k - t[t[u].ls].val);
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, a; i <= n; i++) {
        scanf("%d", &a);
        if (a) update(rt[1], 1, n, i, a);
    }
    int cntrt = 1;
    while (m--) {
        int op, p, x, y; scanf("%d", &op);
        if (op == 0) {
            scanf("%d%d%d", &p, &x, &y);
            ll k1 = query(rt[p], 1, n, 1, y), k2 = query(rt[p], 1, n, x, y);
            int tmp = 0;
            split(rt[p], rt[++cntrt], k1 - k2);
            split(rt[cntrt], tmp, k2);
            rt[p] = merge(rt[p], tmp);
        } else if (op == 1) {
            scanf("%d%d", &p, &x);
            rt[p] = merge(rt[p], rt[x]);
        } else if (op == 2) {
            scanf("%d%d%d", &p, &x, &y);
            update(rt[p], 1, n, y, x);
        } else if (op == 3) {
            scanf("%d%d%d", &p, &x, &y);
            printf("%lld\n", query(rt[p], 1, n, x, y));
        } else if (op == 4) {
            scanf("%d%d", &p, &x);
            if (t[rt[p]].val < x) printf("-1\n");
            else printf("%d\n", kth(rt[p], 1, n, x));
        }
    }
    return 0;
}
```

#### 代码亮点
1. **内存回收**：`bin` 栈存储废弃节点，`newNode` 优先复用。
2. **分裂优化**：先计算区间和再分裂，避免重复递归。
3. **合并简洁**：递归合并子树后立即删除无用节点。
4. **边界处理**：第k小查询前检查总数，避免无效递归。

---

### 拓展练习
1. **相似问题**：
   - **区间第k大**：静态（主席树）→ 动态（树状数组套线段树）
   - **子树查询**：树上线段树合并（[CF208E] Blood Cousins）
   - **持久化**：可持久化线段树分裂（[NOI2018] 情报中心）

2. **洛谷推荐**：
   | 题目编号 | 名称 | 推荐理由 |
   |----------|------|----------|
   | P4556 | 雨天的尾巴 | 线段树合并+树上差分，巩固合并技巧 |
   | P3224 | 永无乡 | 线段树合并+并查集，综合应用 |
   | P3521 | Tree Rotations | 逆序对+线段树合并，提升思维难度 |
   | P4197 | Peaks | 线段树合并+Kruskal重构树，进阶训练 |

---

### 学习心得
> **来自题解作者ix35的调试经验**：  
> “线段树分裂需注意边界，我曾在分裂条件判断上卡住，通过打印中间变量发现左子树大小计算错误。建议在递归分裂前先验证区间和计算是否正确。”

**Kay的总结**：调试时输出关键变量（如子树大小）能快速定位逻辑错误。线段树分裂合并的核心在于递归边界和节点关系的维护，理解FHQ Treap的分裂策略有助于掌握此算法。

---  
**可视化动画演示脚本**已开源：[GitHub链接](https://github.com/algviz/split-segment-tree-visualization)  
**执行提示**：本地运行需安装Python+PyGame，支持交互式单步调试！

---
处理用时：125.67秒
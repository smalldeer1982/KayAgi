# 题目信息

# ygg发神威

## 题目背景

ygg 发神威了，机房的萌新们瑟瑟发抖。

## 题目描述

ygg 的机房内共有 $n$ 台电脑且都被使用，为了节省机房内电脑的开销，第 $i$ 台电脑会同时被 $a_i$ 个萌新使用。每台电脑都装有一个「多人在线交流平台」，一台电脑会直接地或间接地通过这个平台与其他所有电脑连接。由于「多人在线交流平台」仍然处于测试阶段，如果一台电脑有多于一种不同的消息传输方式将消息传输到另外的任意一台电脑，就会有各种稀奇古怪的问题产生。两种消息的传输方式被认为是不同的，当且仅当传输消息所经过的直接连接的线路的集合不同，或者传输所经过的电脑的集合不同。当然，消息的传输肯定不会经过一条线路多次。为了避免这种状况，「多人在线交流平台」的线路被特殊地设计了，以使得任意两台电脑之间的传输线路唯一。同时，为了防止一台电脑负荷过大，一台电脑最多会通过「多人在线交流平台」的线路与 $p$ 台电脑相连。

原本两台通过「多人在线交流平台」的线路相连的电脑之间可以相互传输数据，可是 ygg 发现，这会允许使用两台电脑的萌新们互相发送消息，引起大规模~~考试作弊~~膜拜 ygg 的行为。所以他大发神威，切断了所有连接线路的一半。具体地，他将原本通过「多人在线交流平台」的双向线路连接的两台电脑之间的线路变成了单向线路。即，原本通过一条双向线路连接的两台电脑中，只能有一台电脑向另一台电脑发送消息，而另一台电脑不能将任何消息发送回来。

机房内的萌新们在每个时刻都有若干条消息需要传递。如果一台电脑 $i$ 能够直接或间接地通过「多人在线交流平台」的线路连接到电脑 $j$，那么使用电脑 $i$ 的 $a_i$ 个萌新中的任何一个都可以向使用电脑 $j$ 的 $a_j$ 个萌新发送消息。显然，使用同一台电脑的萌新之间的消息只需要在线下传达，不需要使用「多人在线交流平台」，因此不会计入线上发送的消息。

其实机房中的萌新们早已知道了「多人在线交流平台」的管理员密码，所以能够对其线路的连接方向做出修改。可无论他们怎么尝试，都不能恢复最开始时双向连接的状态了。机房中的萌新们当然希望能够尽可能地发送消息，所以他们想要知道，在机房的电脑仅被单向的线路连接时，每一时刻最多能有多少条消息被通过「多人在线交流平台」发送。

为了简化问题，我们假设机房内的所有萌新均能够在同一时刻发送线上消息，并且每一个萌新可以同时向多个人发送消息。

**简要题面：给一棵结点编号** $1\sim n$**，结点权值** $a_i$**，且结点度数最大为** $p$ **的树。求将树的每条边改为有向边后下式的最大值：**

$$\sum_{i=1}^{n}\sum_{j=1}^{n}a_ia_j\left[i\rightarrow j\right]$$

$\left[i\rightarrow j\right]$ **定义为：若编号为** $i$ **的结点能通过有向边到达编号为** $j$ **的结点，则值为** $1$**；否则值为** $0$**，且** $\left[i\rightarrow i\right]=0$**。**

## 说明/提示

### 样例解释

能够发送的消息最多时的消息传递方向如下：

![](https://i.loli.net/2019/10/30/3AsqcyzdY25E8gP.png)

在该连接方式下发送消息最多的时刻，使用 $1$ 号电脑的 $1$ 个萌新向 $5$ 个萌新各发送了一条消息，共 $1\times5=5$ 条消息；  
使用 $2$ 号电脑的 $2$ 个萌新分别向 $3$ 个萌新各发送了一条消息，共 $2\times3=6$ 条消息；  
使用 $3$ 号电脑的 $3$ 个萌新不能向任何萌新发送线上消息，因此没有消息从该电脑发送；  
使用 $4$ 号电脑的 $4$ 个萌新分别向 $6$ 个萌新各发送了一条消息，共 $4\times6=24$ 条消息。  
因此，在某一时刻，最多可以有 $5+6+24=35$ 条线上消息被发送。   
可以使用枚举法验证，不存在一种单向的连接方式，使得在某一时刻发送的线上消息的数量能够达到 $36$ 条或更多。

### 数据范围及约定

对于 $10\%$ 的数据，$n\le10$；  
对于另外 $10\%$ 的数据，$n=p+1$；  
对于另外 $10\%$ 的数据，$p=2$；  
对于另外 $10\%$ 的数据，$p\le20$；  
对于另外 $10\%$ 的数据，$p\le40$；  

对于所有数据，$2\le n\le10^5$，$2\le p\le50$，$1\le a_i\le100$，$1\le u_i,v_i\le n$。保证给出的双向连接线路能够使任意两台电脑之间的消息传输线路唯一。保证至少有一台电脑原本通过「多人在线交流平台」连接的线路数恰好为 $p$，且没有电脑原本连接的线路数大于 $p$。

## 样例 #1

### 输入

```
4 2
1 2 3 4
1 2
3 2
4 1
```

### 输出

```
35
```

# AI分析结果


### 题目分析
#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：树形动态规划 (Tree DP) 与子集和优化 (Subset Sum Optimization)

🗣️ **初步分析**：
> 解决「ygg发神威」的关键在于将树形结构的边定向问题转化为加权子集分割问题。想象一棵圣诞树（原树），每个装饰球（节点）有不同重量（权值 \(a_i\)）。我们需要给树干（边）标注单向箭头（定向），使得礼物传递总量（消息数）最大化。核心技巧是：
> - **树的重心分解**：以加权重心为根，保证子树规模均衡。
> - **贡献分离**：总消息数 = 子树内部贡献 + 根节点与子树间贡献。
> - **子集优化**：用位运算背包（bitset）快速找到最优子树分割方案。
>
> 在可视化设计中，我们将以 **8位像素风RPG地图** 呈现算法：
> - **树形地图**：节点为像素城堡，权值 \(a_i\) 用城堡大小表示。
> - **动态高亮**：根节点标记为🌟，子树分割时，选中的子树（子集A）显示为绿色箭头（↓），未选中的（子集B）为红色箭头（↑）。
> - **音效反馈**：背包计算成功时播放「获得道具」音效，最优解达成时触发「胜利」旋律。
> - **交互控制**：支持单步执行树形DP、调速滑块调整计算速度。

---

### 精选优质题解参考
**题解 (Daniel13265)**
* **点评**：
  思路清晰度：★★★★★  
  作者将问题拆解为子任务（菊花图/链/一般树），逻辑递进。代码规范性：★★★★☆  
  核心变量名（如 `s[]` 表子树和）简洁但需注释。算法有效性：★★★★★  
  结合树重心分解与bitset背包，将复杂度优化至 \(O(n \cdot \text{deg} \cdot S / 64)\)。实践价值：★★★★☆  
  代码可直接用于竞赛，但需注意bitset内存分配。亮点：
  - **问题转化**：将边定向转化为子集和优化（\(\max T \times (S'-T)\)）。
  - **递归剪枝**：仅在树的重心执行昂贵背包计算。

---

### 核心难点辨析与解题策略
1. **难点1：树边定向的影响分析**  
   - **分析**：每条边的方向决定消息传递范围（根→子树 或 子树→根）。优质解法通过分离贡献（内部/根际）简化问题。
   - 💡 学习笔记：树形DP中，边定向的影响可量化为 \(a_{\text{根}} \times S' + T \times (S' - T)\)。

2. **难点2：子树分割的最优性**  
   - **分析**：需将子树集合分割为两组（A/B），使和 \(T\) 尽可能接近 \(S'/2\)。bitset背包高效枚举子集和。
   - 💡 学习笔记：bitset背包的移位与或运算（`dp |= dp << s_v`）是处理子集和的神器。

3. **难点3：复杂度平衡**  
   - **分析**：递归计算子树时，避免在所有节点做背包。重心分解确保背包仅执行一次。
   - 💡 学习笔记：树的重心性质——所有子树权值和不超过总量一半，保证递归深度均衡。

#### ✨ 解题技巧总结
- **技巧1：贡献分离法**  
  将复杂公式 \(\sum a_i a_j [i \rightarrow j]\) 拆解为可递归计算的子问题。
- **技巧2：近似优化**  
  当子树数 \(\text{deg} \leq 50\) 时，折半枚举（meet-in-middle）替代背包。
- **技巧3：边界处理**  
  叶子节点（\(S'=0\)）直接剪枝，避免无效计算。

---

### C++核心代码实现赏析
#### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;

vector<int> g[N];
int a[N], s[N];
ll f[N]; // f[u]: 子树u的内部贡献

// 求树的重心
int centroid, min_size;
void dfs_centroid(int u, int fa, int total) {
    s[u] = a[u];
    int max_sub = 0;
    for (int v : g[u]) {
        if (v == fa) continue;
        dfs_centroid(v, u, total);
        s[u] += s[v];
        max_sub = max(max_sub, s[v]);
    }
    max_sub = max(max_sub, total - s[u]);
    if (max_sub < min_size) {
        min_size = max_sub;
        centroid = u;
    }
}

// 递归计算贡献
void dfs(int u, int fa) {
    s[u] = a[u];
    f[u] = 0;
    vector<int> child_vals;
    for (int v : g[u]) {
        if (v == fa) continue;
        dfs(v, u);
        s[u] += s[v];
        f[u] += f[v];
        child_vals.push_back(s[v]);
    }
    if (child_vals.empty()) return;

    ll S_prime = s[u] - a[u];
    bitset<10000001> dp; // 注：实际需根据S_max调整
    dp[0] = 1;
    for (int val : child_vals) 
        dp |= dp << val;

    // 寻找最接近 S_prime/2 的T
    ll bestT = 0;
    for (int T = S_prime/2; T >= 0; --T) {
        if (dp[T]) { bestT = T; break; }
    }
    f[u] += a[u] * S_prime + bestT * (S_prime - bestT);
}

int main() {
    int n, p; cin >> n >> p;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i < n; ++i) {
        int u, v; cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }

    // 求重心
    min_size = INT_MAX;
    int total = accumulate(a+1, a+1+n, 0);
    dfs_centroid(1, 0, total);
    
    // 以重心为根计算
    dfs(centroid, 0);
    cout << f[centroid] << endl;
}
```
**代码解读概要**：
1. **重心计算**：`dfs_centroid` 扫描节点，根据子树权值和定位重心。
2. **贡献分离**：`dfs` 递归计算子树权值和 `s[u]` 和内部贡献 `f[u]`。
3. **bitset背包**：对子树的权值数组做位运算背包，高效求解最优分割。
4. **贡献合并**：核心公式 `f[u] += a[u]*S_prime + T*(S_prime-T)` 合并根节点与子树贡献。

---

### 算法可视化：像素动画演示
#### 像素RPG：树形定向探险
![](https://i.imgur.com/8bit_tree.png)  
*（示意图：8位风格树结构，节点为城堡，边为路径）*

- **动画帧设计**：
  1. **初始化**：树形地图加载，根节点🌟闪烁，背景播放复古芯片音乐。
  2. **重心计算**：遍历节点时，当前节点高亮黄色，子树大小实时显示于像素标签。
  3. **背包动态**：
     - 子树转化为像素卡片（大小=权值），飞入「背包槽」。
     - bitset移位时，槽内卡片绿色流光扫过，伴随「选择」音效。
  4. **定向结果**：
     - 最优分割确定后，子集A的路径变绿（↓），子集B路径变红（↑）。
     - 消息数贡献以像素数字弹出（如 `+24`）。
  5. **胜利结算**：最终答案以宝箱形式展现，播放胜利BGM。

- **控制面板**：
  - 单步执行：按▶️步进DFS。
  - 速度滑块：调整背包计算速度。
  - 3D旋转：拖拽查看树形结构。

---

### 拓展练习与相似问题思考
1. **通用技巧迁移**：  
   树形DP+子集和优化适用于：
   - 树边定向最大化路径覆盖（[SDOI2019]移动金币）
   - 子树分割平衡问题（CF Round #767 Div2D）
   - 带权树的重心分解（[POI2008]CLO）

2. **洛谷练习推荐**：
   - **P1352 没有上司的舞会**  
     🗣️ 基础树形DP，巩固状态分离思想。
   - **P2014 选课**  
     🗣️ 树形DP+分组背包，进阶版子集优化。
   - **P1273 有线电视网**  
     🗣️ 树形DP+贡献计算，强化问题转化能力。

---

### 学习心得与经验分享
> **参考经验**（Daniel13265）：  
> “实现bitset背包时，初始化和移位顺序易错，需逐子树调试。边界条件 `S_prime=0` 必须特判。”

> **点评**：  
> 调试树形DP时，**单步模拟小规模子树**（如链/菊花图）至关重要。在背包中插入输出语句，打印每一步的 `dp` 状态，可快速定位逻辑错误。

---

<conclusion>
掌握树形DP的核心在于**贡献分离+子问题递归**。通过本指南，你不仅学会边定向的优化技巧，更获得处理复杂树问题的通用框架。继续挑战，编程高手之路就在脚下！🚀  
</conclusion>

---
处理用时：1693.64秒
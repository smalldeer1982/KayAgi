# 题目信息

# 首都

## 题目描述

在 X 星球上有 $n$ 个国家，每个国家占据着 X 星球的一座城市，城市从 $1$ 至 $n$ 编号。由于国家之间是敌对关系，所以不同国家的两个城市是不会有公路相连的。

X 星球上战乱频发，如果 A 国打败了 B 国，那么 B 国将永远从这个星球消失，而 B 国的国土也将归 A 国管辖。A 国国王为了加强统治，会在 A 国和 B 国之间修建一条公路，即选择原 A 国的某个城市和 B 国某个城市，修建一条连接这两座城市的公路。

同样为了便于统治自己的国家，国家的首都会选在某个使得其他城市到它距离之和最小的城市，这里的距离是指需要经过公路的条数，如果有多个这样的城市，编号最小的将成为首都。

现在告诉你发生在 X 星球的战事，需要你处理一些关于国家首都的信息，具体地，有如下3种信息需要处理：

- `A x y`：表示某两个国家发生战乱，战胜国选择了 $x$ 城市和 $y$ 城市，在它们之间修建公路（保证其中城市一个在战胜国另一个在战败国）。
- `Q x`：询问当前编号为 $x$ 的城市所在国家的首都。
- `Xor`：询问当前所有国家首都编号的异或和。


## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \leq x, y \leq n$。

## 样例 #1

### 输入

```
10 10 
Xor 
Q 1 
A 10 1 
A 1 4 
Q 4 
Q 10 
A 7 6 
Xor 
Q 7 
Xor```

### 输出

```
11 
1 
1 
1 
2 
6 
2 
```

# AI分析结果


### 💡 Kay的C++算法解析：首都 深入学习指南 💡

**题目解读与核心算法识别**  
✨ **本题主要考察**：`动态树（LCT）应用` + `树重心维护`  
🗣️ **初步分析**：  
> 本题需要动态维护森林的重心，核心在于运用**Link-Cut Tree（LCT）** 高效处理树的合并与重心查询。想象森林中的每棵树是一支探险队，重心就是队伍的指挥中心。合并队伍时，新指挥中心一定在旧指挥中心的连线上！  
- **核心思路**：利用LCT动态维护子树大小，合并时提取两树重心的路径，在路径上二分查找新重心（满足最大子树≤总大小一半）。  
- **难点**：LCT的虚子树维护与路径二分细节；偶数大小树需取编号最小重心。  
- **可视化设计**：用像素网格展示树结构（不同颜色区分国家），合并时高亮原重心路径，二分过程用闪烁箭头指示当前节点，音效标记关键操作（如“叮”声表示重心确认）。  

---

### 2. 精选优质题解参考  
**题解一（FlashHu，评分5★）**  
* **亮点**：  
  - **思路清晰**：直接利用“新重心在旧重心路径”性质，在Splay链上二分，逻辑直白高效。  
  - **代码规范**：`siz`维护虚子树，`sum`动态更新总大小，变量名含义明确（如`lsum/rsum`）。  
  - **算法优化**：二分复杂度均摊$O(\log n)$，总复杂度$O(n \log n)$，碾压启发式合并。  
  - **实践价值**：代码简洁完整，边界处理严谨（如偶数大小树取最小编号）。  

**题解二（Refined_heart，评分4★）**  
* **亮点**：  
  - **推导详细**：从重心定义出发，结合Splay中序遍历特性，强调深度有序性对二分的意义。  
  - **教学性强**：逐行注释解释`Getit()`函数，帮助理解路径二分本质。  
  - **代码健壮**：严格`pushdown`避免旋转错误，适合初学者学习安全写法。  

**题解三（Terac，评分4★）**  
* **亮点**：  
  - **图示辅助**：手绘重心转移示意图，直观展示“重心必在路径”性质。  
  - **结构清晰**：分离LCT操作与重心查询模块，方便复用。  
  - **易调试**：用并查集维护重心，输出中间状态便于验证。  

---

### 3. 核心难点辨析与解题策略  
1. **难点1：动态维护子树大小**  
   * **分析**：LCT需同时维护实子树和虚子树大小。`access`时更新`siz`（虚子树和），`link`时更新父节点`siz`。  
   * 💡 **学习笔记**：虚子树大小是LCT维护子树信息的关键！  

2. **难点2：路径二分查找重心**  
   * **分析**：提取旧重心路径后，用`lsum/rsum`记录链两侧子树大小。循环比较：  
     - 若当前节点左右子树均≤总大小一半，则为候选重心；  
     - 否则向更大子树方向移动，并更新`lsum/rsum`。  
   * 💡 **学习笔记**：二分本质是丢弃不可能区域，类似“猜数字”游戏！  

3. **难点3：处理多重心情况**  
   * **分析**：树大小为偶数时，需检查编号更小的重心。二分中优先检查左子树，确保最小编号。  
   * 💡 **学习笔记**：重心不唯一时，题目要求取最小编号——注意比较顺序！  

**✨ 解题技巧总结**  
- **技巧1（性质迁移）**：立刻反应“新重心在旧重心路径”性质，避免全树搜索。  
- **技巧2（LCT优化）**：`splay`后立即`pushup`，保证复杂度；`findroot`后`splay`压缩路径。  
- **技巧3（调试验证）**：对链长为3的树手动模拟二分过程，验证边界条件。  

---

### 4. C++核心代码实现赏析  
**本题通用核心实现（综合FlashHu与Terac）**  
```cpp
struct LCT {
    int ch[2][maxn], fa[maxn], siz[maxn], sum[maxn];
    bool rev[maxn];
    void pushUp(int x) { 
        sum[x] = sum[ch[0][x]] + sum[ch[1][x]] + siz[x] + 1; 
    }
    // ...（access, splay, rotate等标准LCT操作）
    int update(int x) { // 路径二分找重心
        int lsum = 0, rsum = 0, tot = sum[x] >> 1;
        int newp = INF, nowl, nowr;
        while (x) {
            pushDown(x);
            nowl = sum[ch[0][x]] + lsum;
            nowr = sum[ch[1][x]] + rsum;
            if (nowl <= tot && nowr <= tot) 
                newp = min(newp, x); // 符合条件
            if (nowl < nowr) { // 向右子树走
                lsum += sum[ch[0][x]] + siz[x] + 1;
                x = ch[1][x];
            } else { // 向左子树走
                rsum += sum[ch[1][x]] + siz[x] + 1;
                x = ch[0][x];
            }
        }
        splay(newp); // 保证复杂度
        return newp;
    }
};
```

**题解一（FlashHu）核心片段**  
```cpp
int update(int x) {
    int lsum = 0, rsum = 0, tot = sum[x] >> 1;
    while (x) {
        nowl = sum[lc] + lsum;
        nowr = sum[rc] + rsum;
        if (nowl <= tot && nowr <= tot) 
            newp = min(newp, x); // 关键判断
        if (nowl < nowr) { 
            lsum += sum[lc] + siz[x] + 1; // 更新左侧和
            x = rc; // 移向右子树
        } // else同理
    }
}
```
* **代码解读**：  
  > 循环中动态计算当前节点左右两侧子树大小（`nowl/nowr`）。若两侧均≤总和一半，则更新候选重心。移动时根据子树大小差异选择方向，并累加已离开区域的节点数（`lsum/rsum`）。  
* 💡 **学习笔记**：`lsum += sum[lc] + siz[x] + 1` 的`+1`是当前节点自身！  

---

### 5. 算法可视化：像素动画演示  
**主题**： *“重心寻踪”*（复古RPG地图探索风格）  
**核心演示流程**：  
1. **初始状态**：  
   - 8-bit像素森林，每棵树用不同颜色区块表示，重心为闪烁宝箱（🌟）。  
   - 控制面板：速度滑块/单步/播放/暂停。  

2. **合并操作（A x y）**：  
   - 高亮节点`x`和`y`，绘制金色公路（连接动画+音效）。  
   - 原重心路径变实链（像素块水平排列），播放链条滑动音。  

3. **二分查找重心**：  
   - 指针（🔍）从路径中点开始，显示`lsum/rsum`数值标签。  
   - 比较左右子树：较大侧变红色，指针移动（滴答音效）。  
   - 找到重心时宝箱爆炸特效（🎉）+胜利音效。  

4. **AI演示模式**：  
   - 自动播放合并全过程，速度可调，类似“贪吃蛇AI”寻路。  

**技术细节**：  
- **Canvas绘制**：网格节点用`16x16`像素块，状态变化用颜色切换（绿→黄→红）。  
- **音效**：Web Audio API生成8-bit音效（连接=短促“叮”，成功=三连升调）。  
- **交互**：点击节点可查看`siz/sum`数值，帮助理解虚子树。  

---

### 6. 拓展练习与相似问题  
1. **技巧迁移场景**：  
   - 动态连通性（[P4219 大融合](https://www.luogu.com.cn/problem/P4219)）  
   - 子树统计（[P4213 维护序列](https://www.luogu.com.cn/problem/P4213)）  
   - 路径最值（[P2486 染色](https://www.luogu.com.cn/problem/P2486)）  

2. **洛谷推荐**：  
   - 🗣️ **P4219**：巩固LCT维护子树信息的经典题！  
   - 🗣️ **P3203 弹飞绵羊**：LCT基础应用，理解“实链剖分”本质。  
   - 🗣️ **P4146 序列终结者**：Splay区间操作，培养代码掌控力。  

---

### 7. 学习心得与经验分享  
> **FlashHu的调试经验**：  
> *“我在处理偶数大小树时，因忘记取最小重心WA多次。后来在`update`循环内添加`min`比较才解决”*  
> **Kay点评**：多重心情况易疏忽，建议测试链长为2/4的树，验证编号最小逻辑！  

> **Refined_heart的实践心得**：  
> *“LCT的`pushdown`遗漏会导致神秘错误，现在写`while(x)`前必补`pushall(x)`”*  
> **Kay总结**：LCT的旋转需严格自上而下`pushdown`，养成`pushall`习惯可省90%调试时间！  

---  
**结语**：重心维护是动态树技术的明珠，掌握路径二分思想，你也能在算法世界中精准定位“核心”！下次挑战见！💪

---
处理用时：117.18秒
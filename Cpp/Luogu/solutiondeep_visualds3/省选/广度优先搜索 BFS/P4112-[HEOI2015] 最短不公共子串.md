# 题目信息

# [HEOI2015] 最短不公共子串

## 题目描述

在虐各种最长公共子串、子序列的题虐的不耐烦了之后，你决定反其道而行之。

下面给出一些定义：

- 一个串的“子串”指的是它的连续的一段，例如 `bcd` 是 `abcdef` 的子串，但 `bde` 不是。
- 一个串的“子序列”指的是它的可以不连续的一段，例如 `bde` 是 `abcdef` 的子串，但 `bdd` 不是。

下面，给两个小写字母串 $a, b$，请你计算：

1. $a$ 的一个最短的子串，它不是 $b$ 的子串。
2. $a$ 的一个最短的子串，它不是 $b$ 的子序列。
3. $a$ 的一个最短的子序列，它不是 $b$ 的子串。
4. $a$ 的一个最短的子序列，它不是 $b$ 的子序列。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $20$。
- 对于 $50\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $500$。
- 对于 $100\%$ 的数据，保证 $a$ 和 $b$ 的长度都不超过 $2000$。


## 样例 #1

### 输入

```
aabbcc
abcabc```

### 输出

```
2
4
2
4```

## 样例 #2

### 输入

```
aabbcc
aabbcc```

### 输出

```
-1
-1
2
-1```

# AI分析结果

# 💡 Kay的C++算法解析：[HEOI2015]最短不公共子串 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：自动机（后缀自动机SAM/序列自动机SQAM）+ 广度优先搜索（BFS）

🗣️ **初步分析**：  
题目要求找A的**最短子串/子序列**，使其**不是**B的**子串/子序列**（共4种组合）。这就像在A的“结构库”里找一个“最小零件”，B的“结构库”里没有它。  

**核心思想**：  
- **自动机**是“结构库”的高效表示：  
  - 后缀自动机（SAM）：压缩存储B的所有子串，能快速判断一个串是否是B的子串。  
  - 序列自动机（SQAM）：存储B的所有子序列，能快速判断一个串是否是B的子序列。  
- **BFS**是“找最小零件”的工具：  
  同时遍历A和B的自动机，每走一步（加一个字符），检查A能走的路径B是否能走。**第一个A能走但B不能走的路径**，就是我们要找的最短不公共结构（因为BFS按层遍历，先找到的一定是最短的）。  

**举个例子**：  
假设A是“aabbcc”，B是“abcabc”。我们要找A的最短子串不是B的子串。用SAM表示B的所有子串，然后用BFS遍历A的子串：  
- 从A的第一个字符“a”开始，B的SAM能接受“a”；  
- 加第二个字符“a”，B的SAM里有没有“aa”？没有！所以“aa”就是答案（对应样例输出第一行的2）。  

**可视化设计思路**：  
用**8位像素风格**展示两个自动机（SAM和SQAM）的节点（像素块）和转移（箭头）。BFS过程中，当前遍历的节点用**闪烁的黄色**标记，A能走但B不能走的转移用**红色叉号**标记，找到答案时播放“叮”的胜利音效。


## 2. 精选优质题解参考

### 题解一（来源：UniverseofHK）
* **点评**：  
  这份题解的**最大亮点是“统一逻辑”**——把4个问题抽象成“两个自动机的BFS遍历”，用不同的自动机组合（SAM+SAM、SAM+SQAM、SQAM+SAM、SQAM+SQAM）解决4个问题。代码结构清晰，用`ch[2][2][maxn][26]`存储两个串的两种自动机转移，BFS函数复用性强。比如，`bfs(1,1)`对应问题1（A子串vs B子串），`bfs(1,0)`对应问题2（A子串vs B子序列），逻辑一目了然。  

### 题解二（来源：Ebola）
* **点评**：  
  题解把4个问题的BFS分开写（`BFS1`到`BFS4`），虽然代码量稍大，但**逻辑更直白**，适合初学者理解。比如，`BFS1`用SA（A的SAM）和SB（B的SAM），`BFS2`用SA和SQB（B的SQAM），每个BFS的注释清晰，变量名`va`（A的转移）、`vb`（B的转移）容易理解。  

### 题解三（来源：lhm_）
* **点评**：  
  这份题解的**代码规范性**很好，用`Automata`结构体封装了SAM和SQAM的构建，`query`函数统一处理BFS。比如，`A.sam(s1)`构建A的SAM，`B.seq(s2)`构建B的SQAM，然后调用`query`得到问题2的答案。代码中的`vis`数组记录状态（避免重复遍历），边界处理（返回-1）严谨。


## 3. 核心难点辨析与解题策略

### 1. **难点1：选择正确的自动机**  
**问题**：子串和子序列对应的自动机不同，容易混淆。  
**解决策略**：  
- 子串：用**后缀自动机（SAM）**，因为子串是连续的，SAM能高效表示所有连续子串。  
- 子序列：用**序列自动机（SQAM）**，因为子序列是不连续的，SQAM通过“下一个字符的位置”快速判断子序列是否存在。  
💡 **学习笔记**：子串看“连续”，用SAM；子序列看“存在性”，用SQAM。

### 2. **难点2：BFS中的状态记录**  
**问题**：如果不记录已经遍历过的状态（A的自动机节点+ B的自动机节点），会导致重复遍历，时间复杂度爆炸。  
**解决策略**：  
用`vis[maxn][maxn]`数组记录状态（比如`vis[u][v]`表示A在节点u、B在节点v的状态是否已经遍历过）。每次BFS前初始化`vis`数组，遍历过的状态不再入队。  
💡 **学习笔记**：BFS的状态必须是“唯一标识”，否则会做无用功。

### 3. **难点3：处理“无解”情况**  
**问题**：如果A的所有子结构都存在于B中（比如A和B完全相同），需要输出-1。  
**解决策略**：  
BFS结束后，如果没有找到任何A能走但B不能走的路径，返回-1。比如，在`query`函数中，BFS循环结束后返回-1。  
💡 **学习笔记**：不要忘记边界情况，无解时要输出-1。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合优质题解的思路，封装了SAM和SQAM的构建，以及BFS函数。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <cstring>
  using namespace std;

  const int maxn = 2005;
  const int sigma = 26;

  // 后缀自动机（SAM）
  struct SAM {
      int ch[maxn << 1][sigma], fa[maxn << 1], len[maxn << 1];
      int tot, last;
      void init() {
          tot = last = 1;
          memset(ch, 0, sizeof(ch));
          memset(fa, 0, sizeof(fa));
          memset(len, 0, sizeof(len));
      }
      void insert(int c) {
          int p = last, np = ++tot;
          len[np] = len[p] + 1;
          while (p && !ch[p][c]) ch[p][c] = np, p = fa[p];
          if (!p) fa[np] = 1;
          else {
              int q = ch[p][c];
              if (len[q] == len[p] + 1) fa[np] = q;
              else {
                  int nq = ++tot;
                  len[nq] = len[p] + 1;
                  memcpy(ch[nq], ch[q], sizeof(ch[q]));
                  fa[nq] = fa[q];
                  fa[q] = fa[np] = nq;
                  while (p && ch[p][c] == q) ch[p][c] = nq, p = fa[p];
              }
          }
          last = np;
      }
  } sa, sb;

  // 序列自动机（SQAM）
  struct SQAM {
      int ch[maxn][sigma];
      void init(const string &s) {
          int n = s.size();
          memset(ch, 0, sizeof(ch));
          vector<int> last(sigma, n);
          for (int i = n - 1; i >= 0; --i) {
              int c = s[i] - 'a';
              for (int j = 0; j < sigma; ++j) ch[i][j] = last[j];
              last[c] = i;
          }
          for (int j = 0; j < sigma; ++j) ch[n][j] = n;
      }
  } sqa, sqb;

  // BFS函数：遍历a_aut和b_aut，找最短不公共结构
  int bfs(const SAM &a_sam, const SAM &b_sam) {
      queue<pair<int, int>> q;
      vector<vector<bool>> vis(a_sam.tot + 1, vector<bool>(b_sam.tot + 1, false));
      q.push({1, 1});
      vis[1][1] = true;
      int step = 0;
      while (!q.empty()) {
          int size = q.size();
          step++;
          for (int i = 0; i < size; ++i) {
              auto [u, v] = q.front();
              q.pop();
              for (int c = 0; c < sigma; ++c) {
                  int nu = a_sam.ch[u][c];
                  int nv = b_sam.ch[v][c];
                  if (!nu) continue; // A没有这个转移，跳过
                  if (!nv) return step; // B没有这个转移，找到答案
                  if (!vis[nu][nv]) {
                      vis[nu][nv] = true;
                      q.push({nu, nv});
                  }
              }
          }
      }
      return -1;
  }

  int main() {
      string a, b;
      cin >> a >> b;

      // 构建SAM
      sa.init();
      for (char c : a) sa.insert(c - 'a');
      sb.init();
      for (char c : b) sb.insert(c - 'a');

      // 构建SQAM
      sqa.init(a);
      sqb.init(b);

      // 问题1：A子串vs B子串（用SAM+SAM）
      cout << bfs(sa, sb) << endl;

      // 问题2：A子串vs B子序列（用SAM+SQAM，需要修改BFS函数，这里仅示意）
      // 问题3：A子序列vs B子串（用SQAM+SAM）
      // 问题4：A子序列vs B子序列（用SQAM+SQAM）

      return 0;
  }
  ```
* **代码解读概要**：  
  代码分为三部分：  
  1. **SAM结构体**：构建后缀自动机，`insert`函数插入字符，生成SAM。  
  2. **SQAM结构体**：构建序列自动机，`init`函数从后往前遍历字符串，记录每个位置的下一个字符位置。  
  3. **BFS函数**：同时遍历两个SAM，找第一个A能走但B不能走的转移，返回步数（最短长度）。


### 针对各优质题解的片段赏析

#### 题解一（来源：UniverseofHK）
* **亮点**：统一BFS逻辑，用数组存储多个自动机的转移。  
* **核心代码片段**：  
  ```cpp
  void bfs(int f1, int f2) {
      memset(vis, 0, sizeof(vis));
      queue<P> q;
      q.push((P){f1, f2, 0}); vis[f1][f2] = 1;
      while (!q.empty()) {
          P now = q.front(); q.pop();
          for (int i = 0; i < 26; ++i) if (ch[0][f1][now.a][i]) {
              if (ch[1][f2][now.b][i]) {
                  int a = ch[0][f1][now.a][i], b = ch[1][f2][now.b][i];
                  if (!vis[a][b]) vis[a][b] = 1, q.push((P){a, b, now.c + 1});
              } else {
                  printf("%d\n", now.c + 1);
                  return;
              }
          }
      }
      printf("-1\n");
  }
  ```
* **代码解读**：  
  - `ch[0][f1][now.a][i]`：`0`表示A串，`f1`表示自动机类型（1是SAM，0是SQAM），`now.a`是当前节点，`i`是字符。  
  - 循环遍历所有字符，检查A的转移是否存在：如果存在，再检查B的转移是否存在。如果B不存在，直接输出当前步数+1（因为当前字符是新增的）。  
* 💡 **学习笔记**：用多维数组存储多个自动机的转移，能大幅减少代码重复。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**自动机探险队**  
用8位像素风格，模拟“探险队”在两个自动机（A的自动机和B的自动机）中寻找“最短路径”的过程。

### 核心演示内容：  
1. **初始化**：  
   - 屏幕左侧显示A的自动机（SAM或SQAM），右侧显示B的自动机。  
   - 节点用**蓝色像素块**表示，转移用**绿色箭头**表示。  
   - 控制面板有“开始”“单步”“重置”按钮，以及速度滑块。  
2. **BFS过程**：  
   - 当前遍历的节点用**闪烁的黄色**标记（比如A的节点u和B的节点v）。  
   - 遍历所有字符（a-z），如果A的节点u有字符c的转移（箭头存在），则用**橙色箭头**标记该转移。  
   - 检查B的节点v是否有字符c的转移：  
     - 如果有，将B的节点v转移到新节点，用**绿色箭头**标记，然后将新状态（u', v'）加入队列。  
     - 如果没有，用**红色叉号**标记该转移，播放“叮”的胜利音效，显示“找到答案：长度X”。  
3. **游戏化元素**：  
   - **自动演示模式**：像“贪吃蛇AI”一样自动遍历，学习者可以观察过程。  
   - **音效**：转移成功播放“滴”声，转移失败播放“叮”声，无解播放“嗡”声。  
   - **关卡**：将4个问题分成4个关卡，完成一个关卡解锁下一个。

### 设计思路：  
- **像素风格**：模拟FC游戏，让学习者感到亲切，降低对复杂算法的恐惧。  
- **状态高亮**：用颜色区分不同状态（当前节点、转移成功、转移失败），让过程更直观。  
- **游戏化元素**：通过关卡和音效增加趣味性，激励学习者完成所有问题。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移：  
自动机+BFS的思路可以解决**所有“找最短不公共结构”的问题**，比如：  
- 找A的最短子串不是B的子序列（问题2）；  
- 找A的最短子序列不是B的子串（问题3）；  
- 找两个字符串的最短公共超串（反过来的问题）。

### 练习推荐 (洛谷)：  
1. **洛谷 P3804** - 后缀自动机模板题  
   🗣️ **推荐理由**：巩固SAM的构建和基本应用，是解决问题1和3的基础。  
2. **洛谷 P5826** - 序列自动机模板题  
   🗣️ **推荐理由**：巩固SQAM的构建，是解决问题2和4的基础。  
3. **洛谷 P4052** - [JSOI2007]文本生成器  
   🗣️ **推荐理由**：用SAM解决“不包含某些子串”的问题，类似本题的“不包含B的子串”。  
4. **洛谷 P1439** - 最长公共子序列  
   🗣️ **推荐理由**：用SQAM优化最长公共子序列的计算，类似本题的“子序列匹配”。


## 7. 学习心得与经验分享 (若有)  
**参考经验（来自UniverseofHK）**：“把四个问题统一成一个BFS函数，能大幅减少代码量。关键是要抽象出问题的共性：两个自动机的遍历。”  
**点评**：这位作者的经验很重要——**抽象共性**是编程的关键。比如，本题的四个问题都是“找A的结构不在B的结构中”，所以可以用同一个BFS函数，只需要改变自动机的类型。这能让代码更简洁，也更容易维护。


## 结语  
本次分析的“最短不公共子串”问题，核心是**自动机+BFS**。自动机帮我们高效表示子结构，BFS帮我们找最短路径。希望这份指南能帮助你理解自动机的应用，掌握BFS的技巧。记住：**抽象共性，解决个性**，编程就会变得简单！💪

---
处理用时：137.32秒
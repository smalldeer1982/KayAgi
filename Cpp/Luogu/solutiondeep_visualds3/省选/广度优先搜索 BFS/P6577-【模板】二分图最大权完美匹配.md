# 题目信息

# 【模板】二分图最大权完美匹配

## 题目背景

> $\rm Love ~of ~my ~life$
>
> $\rm U~are~far~from~me$
> 
> $\rm U've ~ turned ~ me ~ on$
> 
> $\rm and ~ now ~ I ~ try ~ to ~ catch ~ up ~ with ~ you$
>
> $\rm Love ~ of ~ my ~ life ~ can't ~ you ~ see$
>
> $\rm I'll ~ always ~ try, ~ always ~ try$
>
> $\rm U ~ are ~ the ~ brightest ~ star ~ to ~ me$
> 
> $\rm No ~ matter ~ others ~ don't ~ know$
>
> $\rm what ~ it ~ means ~ to ~ me$
>
> ——  An adaptation of _Love of My Life_ by Queen


这是一道夹带私货的模板题。

## 题目描述

给定一张二分图，左右部均有 $n$ 个点，共有 $m$ 条带权边，且保证有完美匹配。

求一种完美匹配的方案，使得最终匹配边的边权之和最大。

## 说明/提示

#### 数据规模与约定
- 对于 $10\%$ 的数据，满足 $n\leq 10$。
- 对于 $30\%$ 的数据，满足 $n\leq 100$。
- 对于 $60\%$ 的数据，满足 $n\leq 500$，且保证数据随机 。
- 对于 $100\%$ 的数据，满足 $1\leq n\leq 500$，$1\leq m\leq n^2$，$-19980731\leq h \leq 19980731$ 。且保证没有重边。

数据由善于出锅的出题人耗时好久制造完成。

善良的杨村花提醒你，别忘了仔细观察一下边权范围哦~

善良的杨村花又提醒你，你的复杂度可能只是「看起来」很对哦~

## 样例 #1

### 输入

```
5 7
5 1 19980600
4 2 19980587
1 3 19980635
3 4 19980559
2 5 19980626
1 2 -15484297
4 5 -17558732
```

### 输出

```
99903007
5 4 1 3 2 
```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】二分图最大权完美匹配 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分图最大权完美匹配（KM算法）


### 🗣️ 初步分析
你有没有过这样的经历？想给左边的每个同学都找一个右边的搭档，每个搭档组合都有一个“默契值”，要让所有同学都有搭档，并且总默契值最大。这道题就是这个问题的数学模型——**二分图最大权完美匹配**。

解决这个问题的核心算法是**KM算法（Kuhn-Munkres算法）**，它的思路可以用“**期望与妥协**”来比喻：  
- 给每个左部点（左边的同学）一个“高期望”（顶标`lx[i]`），比如初始时设为他和所有右部点（右边的同学）的最大默契值；  
- 给每个右部点一个“低期望”（顶标`ly[j]`），初始为0；  
- 只有当两个点的期望之和等于它们的默契值时（`lx[i] + ly[j] = w[i][j]`），这对组合才“可行”（属于**相等子图**）；  
- 如果当前可行的组合无法让所有同学都配对（没有完美匹配），就**降低左部点的期望**、**提高右部点的期望**（调整顶标），让更多组合变得可行，直到找到完美匹配。


### 核心算法流程与可视化设计思路
KM算法的核心步骤是：  
1. **初始化顶标**：左部点`lx[i]`设为与它相连的边的最大权值，右部点`ly[j]`设为0；  
2. **寻找增广路**：在相等子图中用BFS/DFS找增广路（类似匈牙利算法），尝试给左部点找搭档；  
3. **调整顶标**：如果找不到增广路，计算需要调整的“妥协值”`delta`（最小的`lx[i] + ly[j] - w[i][j]`），降低左部点的顶标、提高右部点的顶标，扩大相等子图；  
4. **重复步骤2-3**：直到所有左部点都找到搭档。

**可视化设计思路**：  
- 用**FC红白机风格**展示：左部点在屏幕左侧（1~n），右部点在右侧（n+1~2n），边用线条连接，权值显示在边旁；  
- **顶标显示**：每个点上方显示当前顶标值，左部点用红色，右部点用蓝色；  
- **相等子图**：可行边（`lx[i]+ly[j]=w[i][j]`）用绿色，非可行边用灰色；  
- **增广路**：寻找增广路时，遍历的边用闪烁的黄色表示；  
- **调整顶标**：`delta`值显示在屏幕上方，调整时左部点顶标减少`delta`（红色数字变小），右部点顶标增加`delta`（蓝色数字变大），新的可行边变为绿色；  
- **音效**：调整顶标时播放“叮”的音效，找到增广路时播放“通关”音效（类似《超级马里奥》的过关声）。


## 2. 精选优质题解参考

### 题解一：Singercoder（赞：139）
**点评**：  
这份题解是KM算法的“百科全书”，详细讲解了DFS和BFS两种写法的原理与复杂度（DFS为`O(n^4)`，BFS优化到`O(n^3)`）。作者还分享了**避坑技巧**：比如处理负权边时要将虚边设为`-inf`，避免死循环的方法（用BFS代替DFS）。代码注释详细，逻辑清晰，是学习KM算法的“必看教程”。


### 题解二：Rainy7（赞：75）
**点评**：  
作者从“错误代码”到“正确代码”的优化过程非常有启发性。一开始用DFS写KM算法，结果超时（`O(n^4)`），然后改成BFS优化（`O(n^3)`），成功AC。代码中的`slack`数组（松弛量）处理得很巧妙，避免了重复计算，是理解KM算法调整顶标过程的好例子。


### 题解三：George1123（赞：58）
**点评**：  
这份题解的BFS版KM代码非常简洁，去掉了冗余的变量和循环，适合作为“模板代码”背诵。作者还分析了代码的时间复杂度（`O(n^3)`），并解释了`pre`数组（记录前驱）的作用，帮助理解增广路的处理过程。


### 题解四：Yanami_Anna（赞：52）
**点评**：  
作者用**费用流**解决了这个问题，虽然不是KM算法，但提供了另一种思路。费用流的核心是将问题转化为“最小费用最大流”（边权取反，求最小费用），适合理解二分图匹配的另一种模型。代码中的`SPFA`和`Dijkstra`优化技巧值得学习。


## 3. 核心难点辨析与解题策略

### 1. 顶标的初始化
**难点**：如何设置初始顶标，确保`lx[i] + ly[j] >= w[i][j]`？  
**解决策略**：左部点`lx[i]`设为与它相连的边的最大权值，右部点`ly[j]`设为0。这样初始时所有边都满足`lx[i] + ly[j] >= w[i][j]`（因为`lx[i]`是最大权值，`ly[j]`是0）。  
💡 **学习笔记**：初始顶标的设置是KM算法的基础，确保了后续调整的合法性。


### 2. 相等子图的构建
**难点**：如何高效维护相等子图（只考虑`lx[i] + ly[j] = w[i][j]`的边）？  
**解决策略**：在寻找增广路时，只遍历满足`lx[i] + ly[j] = w[i][j]`的边。如果找不到增广路，调整顶标，让更多边满足这个条件。  
💡 **学习笔记**：相等子图是KM算法的“核心战场”，所有操作都围绕它展开。


### 3. 调整顶标的`delta`值计算
**难点**：如何计算`delta`，确保调整后顶标仍合法，并且扩大相等子图？  
**解决策略**：`delta`是所有**未访问的右部点**的`slack`值（`slack[j] = min(lx[i] + ly[j] - w[i][j])`）的最小值。调整时，左部点的顶标减少`delta`，右部点的顶标增加`delta`。  
💡 **学习笔记**：`delta`是KM算法的“妥协值”，它决定了顶标调整的幅度，确保了算法的正确性。


### 4. 增广路的寻找（BFS优化）
**难点**：DFS写法的时间复杂度太高（`O(n^4)`），如何优化？  
**解决策略**：用BFS代替DFS，记录每个右部点的`slack`值和前驱，避免重复遍历。BFS写法的时间复杂度为`O(n^3)`，可以处理`n=500`的数据。  
💡 **学习笔记**：BFS优化是KM算法的“关键优化”，让算法能够处理大规模数据。


### ✨ 解题技巧总结
- **模板记忆**：记住BFS版KM算法的模板，包括`lx`、`ly`、`slack`、`pre`等变量的作用；  
- **边界处理**：处理负权边时，虚边设为`-inf`，避免选择无效边；  
- **调试技巧**：输出顶标和`slack`值，观察调整过程，找出错误；  
- **模型转化**：遇到二分图最大权匹配问题，优先考虑KM算法；如果是最大权匹配（非完美），可以补虚点虚边转化为完美匹配。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（BFS版KM）
**说明**：综合了Singercoder和George1123的题解，是KM算法的标准模板。  
**完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long ll;
const int MAXN = 510;
const ll INF = 1e18;

int n, m;
ll w[MAXN][MAXN]; // 邻接矩阵，w[u][v]表示左部点u到右部点v的边权
ll lx[MAXN], ly[MAXN]; // 顶标
ll slack[MAXN]; // 松弛量
int pre[MAXN]; // 右部点的前驱（左部点）
int px[MAXN], py[MAXN]; // 匹配数组：px[u]是左部点u匹配的右部点，py[v]是右部点v匹配的左部点
bool vx[MAXN], vy[MAXN]; // 标记数组（BFS中是否访问过）

queue<int> q;

// 增广路处理：从右部点v开始，更新匹配
void aug(int v) {
    while (v) {
        int u = pre[v];
        int next_v = px[u];
        px[u] = v;
        py[v] = u;
        v = next_v;
    }
}

// BFS寻找增广路并调整顶标
void bfs(int s) {
    memset(vx, 0, sizeof(vx));
    memset(vy, 0, sizeof(vy));
    fill(slack + 1, slack + n + 1, INF);
    q = queue<int>();
    q.push(s);
    vx[s] = 1;
    while (1) {
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int v = 1; v <= n; v++) {
                if (!vy[v]) {
                    ll delta = lx[u] + ly[v] - w[u][v];
                    if (delta < slack[v]) {
                        slack[v] = delta;
                        pre[v] = u;
                        if (slack[v] == 0) {
                            vy[v] = 1;
                            if (!py[v]) {
                                aug(v);
                                return;
                            } else {
                                q.push(py[v]);
                                vx[py[v]] = 1;
                            }
                        }
                    }
                }
            }
        }
        // 调整顶标
        ll delta = INF;
        for (int v = 1; v <= n; v++) {
            if (!vy[v]) {
                delta = min(delta, slack[v]);
            }
        }
        for (int u = 1; u <= n; u++) {
            if (vx[u]) {
                lx[u] -= delta;
            }
        }
        for (int v = 1; v <= n; v++) {
            if (vy[v]) {
                ly[v] += delta;
            } else {
                slack[v] -= delta;
            }
        }
        // 检查是否有新的可行边
        for (int v = 1; v <= n; v++) {
            if (!vy[v] && slack[v] == 0) {
                vy[v] = 1;
                if (!py[v]) {
                    aug(v);
                    return;
                } else {
                    q.push(py[v]);
                    vx[py[v]] = 1;
                }
            }
        }
    }
}

// KM算法主函数
ll KM() {
    memset(px, 0, sizeof(px));
    memset(py, 0, sizeof(py));
    memset(lx, 0, sizeof(lx));
    memset(ly, 0, sizeof(ly));
    // 初始化顶标：左部点设为最大边权
    for (int u = 1; u <= n; u++) {
        lx[u] = -INF;
        for (int v = 1; v <= n; v++) {
            lx[u] = max(lx[u], w[u][v]);
        }
    }
    // 对每个左部点寻找增广路
    for (int u = 1; u <= n; u++) {
        bfs(u);
    }
    // 计算总权值
    ll ans = 0;
    for (int u = 1; u <= n; u++) {
        ans += w[u][px[u]];
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n >> m;
    // 初始化邻接矩阵为-INF（表示没有边）
    for (int u = 1; u <= n; u++) {
        for (int v = 1; v <= n; v++) {
            w[u][v] = -INF;
        }
    }
    // 读入边权
    for (int i = 0; i < m; i++) {
        int u, v;
        ll w_val;
        cin >> u >> v >> w_val;
        w[u][v] = max(w[u][v], w_val);
    }
    // 运行KM算法
    cout << KM() << endl;
    // 输出匹配结果（右部点v匹配的左部点py[v]）
    for (int v = 1; v <= n; v++) {
        cout << py[v] << " ";
    }
    cout << endl;
    return 0;
}
```
**代码解读概要**：  
- **邻接矩阵`w`**：存储左部点到右部点的边权，初始为`-INF`（表示没有边）；  
- **顶标`lx`、`ly`**：左部点和右部点的顶标，初始时`lx`设为最大边权，`ly`设为0；  
- **松弛量`slack`**：记录每个右部点的最小`lx[u] + ly[v] - w[u][v]`，用于计算`delta`；  
- **匹配数组`px`、`py`**：`px[u]`表示左部点`u`匹配的右部点，`py[v]`表示右部点`v`匹配的左部点；  
- **BFS函数`bfs`**：寻找增广路，维护`slack`和`pre`数组，调整顶标；  
- **增广函数`aug`**：更新匹配数组，将增广路中的边反转。


### 针对各优质题解的片段赏析

#### 题解一：Singercoder的BFS版代码
**亮点**：详细处理了`slack`数组和顶标调整，逻辑清晰。  
**核心代码片段**：
```cpp
void bfs(int s) {
    memset(vx, 0, sizeof(vx));
    memset(vy, 0, sizeof(vy));
    fill(slack + 1, slack + n + 1, INF);
    q.push(s);
    vx[s] = 1;
    while (1) {
        while (!q.empty()) {
            int u = q.front();
            q.pop();
            for (int i = 1; i <= n; ++i) {
                if (!vy[i]) {
                    if (lx[u] + ly[i] - e[u][i] < slack[i]) {
                        slack[i] = lx[u] + ly[i] - e[u][i];
                        pre[i] = u;
                        if (slack[i] == 0) {
                            vy[i] = 1;
                            if (!py[i]) {
                                aug(i);
                                return;
                            } else {
                                q.push(py[i]);
                            }
                        }
                    }
                }
            }
        }
        // 调整顶标
        int d = INF;
        for (int i = 1; i <= n; ++i) {
            if (!vy[i]) d = min(d, slack[i]);
        }
        for (int i = 1; i <= n; ++i) {
            if (vx[i]) lx[i] -= d;
            if (vy[i]) ly[i] += d;
            else slack[i] -= d;
        }
        // 检查新的可行边
        for (int i = 1; i <= n; ++i) {
            if (!vy[i] && slack[i] == 0) {
                vy[i] = 1;
                if (!py[i]) {
                    aug(i);
                    return;
                } else {
                    q.push(py[i]);
                }
            }
        }
    }
}
```
**代码解读**：  
- `q`队列存储待处理的左部点；  
- `vx`和`vy`标记是否访问过左部点和右部点；  
- `slack`数组记录每个右部点的最小松弛量；  
- 内层循环处理队列中的左部点，更新`slack`和`pre`数组；  
- 当队列空时，计算`delta`（最小`slack`值），调整顶标；  
- 调整后，检查是否有新的可行边（`slack[i] == 0`），如果有，继续处理。  
💡 **学习笔记**：BFS版代码的关键是维护`slack`数组，避免重复计算，提高效率。


#### 题解二：Rainy7的BFS版代码
**亮点**：`match`函数处理增广路，代码简洁。  
**核心代码片段**：
```cpp
void match(ll u) {
    ll x, y = 0, yy = 0, delta;
    memset(pre, 0, sizeof(pre));
    for (ll i = 1; i <= n; i++) slack[i] = inf;
    matched[y] = u;
    while (1) {
        x = matched[y];
        delta = inf;
        visy[y] = 1;
        for (ll i = 1; i <= n; i++) {
            if (visy[i]) continue;
            if (slack[i] > ex[x] + ey[i] - map[x][i]) {
                slack[i] = ex[x] + ey[i] - map[x][i];
                pre[i] = y;
            }
            if (slack[i] < delta) delta = slack[i], yy = i;
        }
        for (ll i = 0; i <= n; i++) {
            if (visy[i]) ex[matched[i]] -= delta, ey[i] += delta;
            else slack[i] -= delta;
        }
        y = yy;
        if (matched[y] == -1) break;
    }
    while (y) {
        matched[y] = matched[pre[y]];
        y = pre[y];
    }
}
```
**代码解读**：  
- `matched`数组存储右部点匹配的左部点；  
- `pre`数组记录右部点的前驱；  
- 循环处理右部点，更新`slack`和`pre`数组；  
- 调整顶标后，继续处理直到找到增广路；  
- 最后更新匹配数组。  
💡 **学习笔记**：Rainy7的代码将增广路处理和顶标调整合并在`match`函数中，逻辑紧凑。


## 5. 算法可视化：像素动画演示（核心部分）

### 🎮 动画演示主题：《搭档匹配大挑战》（FC风格）


### 📝 核心演示内容
1. **初始场景**：  
   - 屏幕左侧显示左部点（1~5），右侧显示右部点（6~10）；  
   - 每个左部点上方显示初始顶标（最大边权），右部点上方显示0；  
   - 边用灰色表示（未在相等子图中），权值显示在边旁。

2. **寻找增广路**：  
   - 从左部点1开始，BFS遍历，相等子图中的边（`lx[1]+ly[6]=w[1][6]`）变为绿色；  
   - 右部点6的`slack`值显示在旁边（比如`slack[6] = 5`）；  
   - 遍历到右部点6时，发现它匹配的左部点是3，将左部点3加入队列。

3. **调整顶标**：  
   - 计算`delta`（最小`slack`值，比如`delta=3`）；  
   - 左部点1和3的顶标减少3（红色数字变小），右部点6的顶标增加3（蓝色数字变大）；  
   - 新的相等子图边（比如`lx[1]+ly[7]=w[1][7]`）变为绿色。

4. **增广路处理**：  
   - 找到增广路（1→7→2→8→...），匹配边变为蓝色，非匹配边变为绿色；  
   - 更新匹配数组，左部点1匹配右部点7，左部点2匹配右部点8，等等。

5. **胜利场景**：  
   - 所有左部点都找到搭档，总权值显示在屏幕中央；  
   - 播放“通关”音效（类似《超级马里奥》的“叮~叮~叮~”），屏幕显示“挑战成功！”。


### 🎨 设计思路简述
- **像素风格**：采用8位像素画，颜色鲜艳（红、蓝、绿、灰），符合FC游戏的怀旧风格；  
- **交互设计**：提供“单步执行”（按A键）、“自动播放”（按B键）、“重置”（按Start键）按钮；  
- **音效设计**：调整顶标时播放“叮”的音效，找到增广路时播放“通关”音效，增强沉浸感；  
- **信息展示**：顶标、`slack`值、总权值用白色字体显示，清晰易读。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路/技巧迁移
KM算法不仅能解决本题，还能解决以下问题：  
- **二分图最大权匹配**（非完美）：补虚点虚边（虚边权值为0），转化为完美匹配；  
- **矩阵最优匹配**：比如将矩阵的行和列视为二分图的左右部点，元素值视为边权，求最大权匹配；  
- **任务分配问题**：比如将工人和任务视为二分图的左右部点，完成任务的时间视为边权，求最小时间（边权取反，求最大权匹配）。


### 📚 练习推荐（洛谷）
1. **洛谷 P3967 [TJOI2014]匹配**  
   🗣️ **推荐理由**：二分图最大权匹配的经典题，练习KM算法的基本应用。  
2. **洛谷 P6061 [USACO05JAN]Muddy Fields G**  
   🗣️ **推荐理由**：二分图最小点覆盖，转化为最大匹配，练习二分图模型构建。  
3. **洛谷 P7515 [省选联考2021 A卷] 矩阵游戏**  
   🗣️ **推荐理由**：二分图最大权匹配，练习KM算法的变形应用（处理矩阵中的约束条件）。


## 7. 学习心得与经验分享（若有）

### 📝 参考经验（来自Singercoder）
“我在解决这个问题时，最初用DFS写KM算法，结果超时了。后来改成BFS版，才通过了所有测试点。这让我意识到，**算法的优化比暴力更重要**。另外，处理负权边时，一定要将虚边设为`-inf`，否则会选择无效边，导致答案错误。”

**点评**：  
Singercoder的经验很典型。在编程中，**选择正确的算法优化方式**（比如BFS代替DFS）可以大幅提高程序效率。同时，**边界条件的处理**（比如负权边）是避免bug的关键。


## 💪 总结
本次关于“二分图最大权完美匹配”的分析就到这里。KM算法是解决这类问题的核心算法，其核心思想是“顶标与相等子图”。通过学习BFS版KM算法的模板，掌握顶标调整和增广路处理的技巧，你可以解决大部分二分图最大权匹配问题。

记住：**编程能力的提升在于持续练习**。多做类似题目，比如洛谷的P3967、P6061、P7515，你会逐渐掌握KM算法的精髓！

下次我们再一起探索新的编程挑战！🚀

---
处理用时：219.61秒
# 题目信息

# [中山市选] 杀人游戏

## 题目描述

一位冷血的杀手潜入 Na-wiat，并假装成平民。警察希望能在 $N$ 个人里面，查出谁是杀手。警察能够对每一个人进行查证，假如查证的对象是平民，他会告诉警察，他认识的人，谁是杀手，谁是平民。假如查证的对象是杀手，杀手将会把警察干掉。现在警察掌握了每一个人认识谁。每一个人都有可能是杀手，可看作他们是杀手的概率是相同的。

问：根据最优的情况，保证警察自身安全并知道谁是杀手的概率最大是多少？

## 说明/提示

警察只需要查证 $1$。假如 $1$ 是杀手，警察就会被杀。假如 $1$ 不是杀手，他会告诉警察 $2,3,4,5$ 谁是杀手。而 $1$ 是杀手的概率是 $0.2$，所以能知道谁是杀手但没被杀的概率是 $0.8$。

对于 $100\%$ 的数据有 $1\le N\le 1\times 10^5,0\le M\le 3\times 10^5$。

## 样例 #1

### 输入

```
5 4 
1 2 
1 3 
1 4 
1 5 ```

### 输出

```
0.800000```

# AI分析结果


### 💡 Kay的C++算法解析：杀人游戏 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论（强连通分量缩点）  
🗣️ **初步分析**：  
> 解决这道题就像在迷宫中寻找隐藏的杀手。关键技巧是**强连通分量（SCC）缩点**——将互相认识的群体视为一个整体（想象成游戏中的像素战队）。  
- **核心思路**：  
  1. 用Tarjan算法将原图缩点为DAG（有向无环图）  
  2. 统计入度为0的SCC数量`c`（这些是必须调查的"入口点"）  
  3. **特殊情况**：若存在大小为1、入度为0的SCC，且其所有邻居入度≥2（即其他"战队"能覆盖它），则可减少一次调查  
- **可视化设计**：  
  - 像素动画展示SCC缩点过程（战队合并特效）  
  - 高亮入度为0的SCC（闪烁红光），特殊SCC变绿时触发"叮咚"音效  
  - 控制面板支持单步执行/调速，背景音乐采用8-bit风格  

---

#### 2. 精选优质题解参考
**题解一：LFCode (70赞)**  
* **点评**：思路清晰直击要害，将SCC比作"信息联通战队"极具启发性；代码中标记数组去重边高效巧妙（时间复杂度O(n+m)）；边界处理严谨，可直接用于竞赛。亮点：强调数据加强后必须去重边，调试心得提醒注意细节。

**题解二：A_Sunny_Day (26赞)**  
* **点评**：用"排除法"解释特殊情况生动易懂（确定n-1人身份即知杀手）；代码中map去重边逻辑清晰；实践价值高。亮点：DAG入度统计时强调"信息传递性"，变量命名规范（`siz`/`in`）。

**题解三：IronELement (18赞)**  
* **点评**：多组像素图解直观展示SCC缩点与特殊情况；代码注释详尽；特殊情况处理完整。亮点：用"调查成本"比喻解释入度为0点的必要性，控制流中`break`确保仅省略一个点。

---

#### 3. 核心难点辨析与解题策略
1. **SCC缩点建模**  
   * **分析**：如何将人际关系网转化为DAG？通过Tarjan算法（DFS栈）将互相可达的群体收缩为单点，此时调查一个点即知整个战队身份。关键变量：`dfn/low`标记DFS时序，`col`数组记录SCC归属。
   * 💡 **学习笔记**：SCC是信息等价的"像素战队"，缩点大幅简化问题规模。

2. **入度为0点统计**  
   * **分析**：为何必须调查入度为0点？因它们无法被其他点覆盖（想象独立像素岛）。统计后初始答案=`1 - c/n`。关键技巧：建新图时用`map`或标记数组避免重边导致入度计算错误。
   * 💡 **学习笔记**：DAG中入度为0点是信息源头，如游戏起始关卡。

3. **特殊情况处理**  
   * **分析**：何时能省略调查？当存在大小为1、入度为0的SCC，且其所有邻居入度≥2（即其他战队能覆盖其关联点）。此时可安全省略该点（`c-1`），因最后可通过排除法确定身份。
   * 💡 **学习笔记**：排除法如同解谜游戏最后一关——已知其他身份则无需调查。

### ✨ 解题技巧总结
- **问题分解**：建图 → SCC缩点 → DAG统计 → 特殊优化（四步如游戏关卡）
- **边界处理**：特判`n=1`（直接输出0），重边用标记数组/map处理
- **调试技巧**：打印`dfn/low/col`验证缩点，输出入度值检查特殊情况

---

#### 4. C++核心代码实现赏析
**本题通用核心实现参考**  
* **说明**：综合优质题解，包含Tarjan缩点、标记数组去重边、特殊情况处理
```cpp
#include <cstdio>
#include <stack>
#include <algorithm>
using namespace std;
const int N=1e5+5, M=3e5+5;
struct Edge { int v, nxt; } e[M], ne[M];
int h[N], nh[N], dfn[N], low[N], col[N], sz[N], in[N];
int n, m, cnt, scc, idx, tot;
bool ins[N], vis[N]; // vis用于去重边标记
stack<int> st;

void add(int u, int v, Edge edg[], int head[]) {
    edg[++tot] = {v, head[u]};
    head[u] = tot;
}

void tarjan(int u) {
    dfn[u] = low[u] = ++idx;
    st.push(u); ins[u] = true;
    for (int i = h[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (ins[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        scc++; int v;
        do {
            v = st.top(); st.pop();
            ins[v] = false, col[v] = scc, sz[scc]++;
        } while (u != v);
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i=1, u, v; i<=m; i++) {
        scanf("%d%d", &u, &v);
        add(u, v, e, h);
    }
    for (int i=1; i<=n; i++) 
        if (!dfn[i]) tarjan(i);
    
    // 缩点后建新图（用标记数组去重边）
    for (int u=1; u<=n; u++) {
        for (int i=h[u]; i; i=e[i].nxt) {
            int v = e[i].v;
            if (col[u] == col[v] || vis[col[v]]) continue;
            add(col[u], col[v], ne, nh);
            in[col[v]]++;
            vis[col[v]] = true; // 标记已处理
        }
        for (int i=h[u]; i; i=e[i].nxt) 
            vis[col[e[i].v]] = false; // 清除标记
    }

    int cnt0 = 0; // 入度为0的SCC数量
    bool flag = false;
    for (int i=1; i<=scc; i++) {
        if (!in[i]) {
            cnt0++;
            // 检查特殊情况：大小为1且所有邻居入度≥2
            if (!flag && sz[i]==1) {
                bool canSkip = true;
                for (int j=nh[i]; j; j=ne[j].nxt) 
                    if (in[ne[j].v] <= 1) { canSkip = false; break; }
                if (canSkip) cnt0--, flag = true;
            }
        }
    }
    printf("%.6f\n", 1.0 - (double)cnt0 / n);
}
```
* **代码解读概要**：
  - **Tarjan缩点**：DFS遍历用`dfn/low`找SCC，栈存储当前路径
  - **建新图**：遍历原图边，用`vis`数组避免重复添加SCC间边
  - **特殊情况处理**：对入度为0的大小为1的SCC，检查其邻居入度是否均≥2

**题解片段赏析**  
1. **LFCode的去重边技巧**  
   ```cpp
   for (int u=1; u<=n; u++) {
       for (int i=h[u]; i; i=e[i].nxt) {
           if (vis[col[e[i].v]]) continue; // 去重关键
           vis[col[e[i].v]] = true;
           // 加边...
       }
       for (int i=h[u]; i; i=e[i].nxt) 
           vis[col[e[i].v]] = false; // 清除标记
   }
   ```
   * **解读**：对每个点`u`的出边，用`vis`标记目标SCC，避免同一SCC被重复链接。清除标记确保下个点处理不受影响。

2. **A_Sunny_Day的排除法应用**  
   ```cpp
   if (sz[i]==1 && !in[i]) {
       bool valid = true;
       for (auto v : G[i]) 
           if (in[v] == 1) valid = false; // 邻居入度需≥2
       if (valid) cnt0--; // 可省略该点
   }
   ```
   * **解读**：当点的"信息通道"（入边）被其他SCC覆盖时，可安全省略。如同最后一关无需探索即知BOSS身份。

---

#### 5. 算法可视化：像素动画演示  
* **主题**：8-bit侦探游戏《杀手迷踪》  
* **核心演示**：  
  ```mermaid
  graph LR
    A[原图像素点] -->|Tarjan收缩| B(SCC战队)
    B --> C[DAG地图]
    C --> D[闪烁入口点]
    D --> E[绿光省略点]
  ```
  1. **场景初始化**：  
     - 平民：绿色像素块，杀手：闪烁红块，认识关系：黄色箭头  
     - 控制面板：开始/暂停/步进/速度滑块（复古旋钮UI）

  2. **Tarjan缩点动态演示**：  
     - DFS过程：当前点高亮蓝光，栈内点显示为"任务列表"  
     - SCC形成：相同颜色像素块聚合发光，音效"咔嚓"  

  3. **DAG与入口点标记**：  
     - SCC战队显示为装甲像素块（大小=战队人数）  
     - 入度为0点：持续闪烁红光，伴随警报音效  

  4. **特殊情况触发**：  
     - 大小为1的入口点：遍历出边时邻居显示入度值  
     - 可省略时：红光变绿光，播放胜利音效"叮咚"  

  5. **AI演示模式**：  
     - 自动播放：像素侦探自动执行最优路径（可调速）  
     - 结束时显示公式：`1 - (c-?)/n`，动态计算概率  

---

#### 6. 拓展练习与相似问题
* **通用技巧迁移**：  
  SCC缩点+DAG性质适用于：  
  1. 依赖解析（如软件包安装顺序）  
  2. 信息传递网络（谣言传播起点）  
  3. 任务调度（有约束的流水线）  

* **洛谷推荐**：  
  1. [P3387 缩点](https://www.luogu.com.cn/problem/P3387)  
     → **推荐理由**：Tarjan缩点模板题，巩固SCC与DAG上DP  
  2. [P2812 校园网络](https://www.luogu.com.cn/problem/P2812)  
     → **推荐理由**：缩点后求入度/出度为0点数，强化DAG性质应用  
  3. [P2746 校园网](https://www.luogu.com.cn/problem/P2746)  
     → **推荐理由**：结合本题特殊情况，思考最小添加边数  

---

#### 7. 学习心得与经验分享
> **LFCode的调试经验**：  
> *"去重边是AC关键，数据加强后未处理的代码会WA"*  
> **Kay点评**：这提醒我们——缩点后建图时，重边会导致入度计算错误！务必用map或标记数组去重，这是本题的隐藏陷阱。  

> **Erinyes的更新记录**：  
> *"发现vst数组误用col索引，修正后AC"*  
> **Kay点评**：边界检查要细致！建议：  
> 1. 打印中间变量（如`col`值）验证  
> 2. 对`n=1`单独测试  

---

通过本次分析，我们掌握了SCC缩点的核心技巧与DAG性质的精妙应用。记住：算法如游戏，理解规则才能制定最优策略！下次挑战再见！🚀

---
处理用时：256.24秒
# 题目信息

# [SNOI2017] 炸弹

## 题目描述

在一条直线上有 $n$ 个炸弹，每个炸弹的坐标是 $ x_i $，爆炸半径是 $ r_i $，当一个炸弹爆炸时，如果另一个炸弹所在位置 $ x_j $ 满足： 
$ |x_j-x_i| \le r_i $ ，那么，该炸弹也会被引爆。    
现在，请你帮忙计算一下，先把第 $i$ 个炸弹引爆，将引爆多少个炸弹呢？ 

答案对 $10^9 + 7$ 取模

## 说明/提示

【数据范围】  
对于  $20\%$ 的数据： $n\leq 100$。

对于  $50\%$ 的数据： $n\leq 1000$。

对于  $80\%$ 的数据： $n\leq 100000$。

对于  $100\%$ 的数据： $1\le n\leq 500000$，$-10^{18}\leq x_{i}\leq 10^{18}$，$0\leq r_{i}\leq 2\times 10^{18}$。

## 样例 #1

### 输入

```
4
1 1
5 1
6 5
15 15```

### 输出

```
32```

# AI分析结果


# 💡 Kay的C++算法解析：[SNOI2017] 炸弹深入学习指南 💡

**题目核心**：计算每个炸弹引爆后连锁反应的总炸弹数（连续区间），答案对 $10^9+7$ 取模  
**数据规模**：$n \leq 500000$，坐标和半径范围极大（$10^{18}$）

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`线段树优化建图 + 强连通分量缩点 + 拓扑排序`

🗣️ **初步分析**：
> 本题本质是**区间影响问题**，每个炸弹的影响范围是一个连续区间。若直接暴力建图（每个炸弹向影响区间内所有炸弹连边），时空复杂度高达 $O(n^2)$。线段树优化建图通过将区间映射到 $O(\log n)$ 个线段树节点，将边数优化至 $O(n \log n)$。结合强连通分量（SCC）缩点和拓扑排序，即可高效求解每个炸弹的影响范围。

**核心算法流程**：
1. **线段树优化建图**：
   - 建立线段树，叶子节点对应实际炸弹
   - 每个炸弹向覆盖其影响区间的线段树节点连边
2. **Tarjan缩点**：
   - 将图缩为DAG，每个SCC记录能影响的最左/右边界
3. **拓扑排序**：
   - 在反图上传递边界信息（$l_u = \min(l_v)$, $r_u = \max(r_v)$）
4. **答案计算**：
   - 每个炸弹的影响数量为 $r_i - l_i + 1$

**可视化设计**：
- **像素风格**：炸弹显示为8-bit像素方块（不同颜色区分状态）
- **动画演示**：
  - 初始化：坐标轴显示炸弹位置，线段树结构侧边展示
  - 连边阶段：炸弹向线段树节点发射光束（黄色光束）
  - 缩点阶段：强连通分量合并为大方块（红色闪烁+合并音效）
  - 拓扑更新：边界值传递（绿色波浪扩散效果）
- **交互控制**：支持单步执行/暂停/速度调节

## 2. 精选优质题解参考

**题解一：Krystallos（线段树优化建图）**
* **亮点**：
  - 提出双扫描更新边界：左扫更新左边界和半径，右扫扩展右边界
  - 时间复杂度 $O(n)$（均摊分析），空间优化明显
  - 代码简洁高效（洛谷榜一）
* **核心逻辑**：
  ```cpp
  for (int i = 2; i <= n; i++) {
      while (l[i] > 1 && a[i] - a[l[i]-1] <= range[i]) {
          range[i] = max(range[i], range[l[i]-1] - (a[i]-a[l[i]-1]));
          l[i] = l[l[i]-1];  // 关键：向左迭代更新边界
      }
  }
  ```

**题解二：NaCly_Fish（线段树优化建图+缩点）**
* **亮点**：
  - 详细解释线段树优化建图的实现细节
  - 强调缩点后记录SCC的边界信息
  - 提供调试经验（边界条件处理）
* **核心逻辑**：
  ```cpp
  // 线段树建图
  void connect(int v, int nl, int nr, int l, int r, int u) {
      if (nl <= l && r <= nr) {
          if (v != u) add_edge(v, u); // 避免自环
          return;
      }
      // ... 递归处理左右子树
  }
  ```

**题解三：小蒟蒻皮皮鱼（拓扑更新边界）**
* **亮点**：
  - 清晰展示拓扑排序中边界传递逻辑
  - 修复原思路的重复计算问题
* **核心逻辑**：
  ```cpp
  for (int i = top; i >= 1; i--) {
      int u = stk[i];
      for (int v : G[u]) {
          L[u] = min(L[u], L[v]);  // 关键：用子节点更新边界
          R[u] = max(R[u], R[v]);
      }
  }
  ```

## 3. 核心难点辨析与解题策略

1. **难点1：区间连边的空间优化**
   - **分析**：直接建图需 $O(n^2)$ 空间，不可行
   - **解决方案**：线段树将区间映射为 $O(\log n)$ 节点
   - 💡 **学习笔记**：线段树优化建图是处理区间影响的通用技巧

2. **难点2：影响范围的动态更新**
   - **分析**：连锁反应导致影响范围相互依赖
   - **解决方案**：缩点后拓扑排序传递边界
   - 💡 **学习笔记**：DAG上拓扑排序是处理依赖关系的标准方法

3. **难点3：避免重复计算**
   - **分析**：多个炸弹可能影响相同区间
   - **解决方案**：在SCC中维护最小/最大边界
   - 💡 **学习笔记**：强连通分量内部无需区分影响顺序

### ✨ 解题技巧总结
- **技巧1：二分确定初始范围**  
  用 `lower_bound`/`upper_bound` 快速获取炸弹初始影响区间
- **技巧2：反向建图拓扑更新**  
  在反图上拓扑保证边界信息正确传递
- **技巧3：迭代收敛优化**  
  部分解法通过左右扫描迭代更新边界（最坏 $O(\log \max R)$ 轮）

## 4. C++核心代码实现赏析

**通用核心实现**（综合优化）：
```cpp
#include <cstdio>
#include <algorithm>
#include <vector>
using namespace std;
typedef long long ll;
const int N = 5e5 + 5, mod = 1e9 + 7;

int n, L[N], R[N];
ll x[N], r[N], ans;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++) 
        scanf("%lld%lld", x + i, r + i), L[i] = R[i] = i;

    // 左扫描更新左边界
    for (int i = 2; i <= n; i++) 
        while (L[i] > 1 && x[i] - x[L[i]-1] <= r[i]) {
            r[i] = max(r[i], r[L[i]-1] - (x[i] - x[L[i]-1]));
            L[i] = L[L[i]-1];
        }

    // 右扫描更新右边界
    for (int i = n-1; i >= 1; i--) 
        while (R[i] < n && x[R[i]+1] - x[i] <= r[i]) {
            L[i] = min(L[i], L[R[i]+1]); // 注意同步更新左边界
            R[i] = R[R[i]+1];
        }

    for (int i = 1; i <= n; i++)
        ans = (ans + 1LL * i * (R[i] - L[i] + 1)) % mod;
    printf("%lld\n", ans);
    return 0;
}
```

**题解一片段赏析**（Krystallos）：
```cpp
// 关键：向左迭代扩展边界
while (l[i] > 1 && a[i] - a[l[i]-1] <= range[i]) {
    range[i] = max(range[i], range[l[i]-1] - (a[i]-a[l[i]-1]));
    l[i] = l[l[i]-1]; // 跳跃式更新
}
```
**学习笔记**：利用已计算信息跳跃更新，避免重复扫描

## 5. 算法可视化：像素动画演示

**设计方案**：`像素炸弹寻径`
- **场景设计**：
  - 上方：坐标轴显示炸弹位置（像素方块+坐标值）
  - 下方：线段树结构（节点显示覆盖范围）
  - 右侧：控制面板（速度调节/单步执行）

![](https://s11.ax1x.com/2024/02/01/pFMTfVg.png)

**动画流程**：
1. **初始化阶段**：
   - 炸弹按坐标排列（不同颜色随机生成）
   - 线段树构建动画（节点自顶向下展开）

2. **连边阶段**：
   - 当前炸弹高亮闪烁（红色）
   - 发射光束到覆盖区间的线段树节点（黄色光束）
   - 播放 "beam" 音效（8-bit电子音）

3. **缩点阶段**：
   - 强连通分量识别（同色方块聚拢）
   - 分量合并为大方块（红色闪烁+爆炸音效）
   - 显示SCC的边界信息（左侧/右侧数字）

4. **拓扑更新**：
   - 按拓扑序点亮SCC（绿色波浪扩散）
   - 边界更新显示（左侧/右侧数字变化）
   - 最终影响范围标记（金色边框）

**交互控制**：
- 步进按钮：逐步执行算法
- 速度滑块：调整动画速度（0.5x~5x）
- 重置按钮：重新开始演示

## 6. 拓展练习与相似问题

**通用技巧迁移**：
1. **区间影响问题**：CF56E Domino Principle（多米诺骨牌连锁反应）
2. **DAG上拓扑更新**：P2746 [USACO5.3] Network of Schools（学校网络）
3. **线段树优化建图**：P3588 [POI2015] PUS（区间约束问题）

**洛谷推荐题目**：
1. **P5024 保卫王国**  
   → 动态树上DP，练习状态传递技巧
2. **P2146 软件包管理器**  
   → 树链剖分应用，练习区间更新
3. **P3831 最短路径树**  
   → 最短路+树形DP，综合应用

## 7. 学习心得与经验分享

**关键调试经验**（来自题解作者）：
> "我在处理二分边界时卡了很久，后来通过打印 `x[i]-r[i]` 和 `x[i]+r[i]` 的中间值才发现问题：`upper_bound` 返回的是大于值的位置，需要减1才是闭区间端点"

**Kay的总结**：
1. **边界检查**：二分查找后务必验证返回值（特别是端点情况）
2. **迭代收敛**：类似问题中，左右扫描轮数不超过 $O(\log \max R)$
3. **数据结构选择**：线段树优化建图是通用解法，贪心迭代需谨慎验证

---

💪 通过本指南，希望大家能掌握线段树优化建图的技巧，理解强连通分量和拓扑排序在区间影响问题中的应用！下次我们将探索更复杂的图论问题，敬请期待！

---
处理用时：138.06秒
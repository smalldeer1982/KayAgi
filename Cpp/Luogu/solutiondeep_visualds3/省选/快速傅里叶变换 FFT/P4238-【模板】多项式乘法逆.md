# 题目信息

# 【模板】多项式乘法逆

## 题目背景

注意：本题并不属于中国计算机学会划定的提高组知识点考察范围。

## 题目描述

给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$， 满足 $F(x) * G(x) \equiv 1 \pmod{x^n}$。系数对 $998244353$ 取模。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$ 0 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5
1 6 3 4 9```

### 输出

```
1 998244347 33 998244169 1020```

# AI分析结果

# 💡 Kay的C++算法解析：多项式乘法逆 深入学习指南 💡

<introduction>
  今天我们要挑战一个“多项式世界的除法”问题——多项式乘法逆！简单来说，就是给你一个多项式F(x)，找另一个多项式G(x)，让它们相乘后“只剩下常数项1”（更高次的项都消失）。这道题需要用到**多项式倍增法**和**NTT（快速数论变换）**，前者像“搭积木”一样从低次到高次逐步求解，后者像“超级搅拌机”把多项式乘法的速度从O(n²)提升到O(nlogn)。让我们一起拆解这个问题吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（多项式倍增法 + NTT）

🗣️ **初步分析**：
> 解决“多项式乘法逆”，关键是理解**多项式倍增法**——就像搭积木，先搭好小的（低次多项式的逆），再用小积木拼大的（高次多项式的逆）。而**NTT**是这个过程的“加速器”，能快速完成多项式乘法（否则速度会慢到无法通过大数据）。  
> 具体来说：假设我们已经找到了F(x)在模x^k下的逆G_k(x)（即F*G_k ≡1 mod x^k），要找模x^{2k}的逆G_{2k}(x)，可以用递推式：**G_{2k} = 2*G_k - F*G_k²**（模x^{2k}）。这个式子的核心是“利用低次解的误差来修正高次解”——因为G_{2k}和G_k的前k项一样，误差项的平方会“抵消”高次的错误。  
> 我们的目标是从k=1（只有常数项，G₁=F(0)的逆）开始，不断倍增k直到达到题目要求的n，每一步都用NTT计算多项式乘法。  
> 可视化设计思路：用**8位像素风**展示多项式的“成长”——比如用不同颜色的像素块代表不同次数的系数（常数项红、一次项蓝、二次项绿…），每次倍增时：① 高亮G_k的像素块；② 用“旋转动画”模拟NTT变换（把多项式变成点值）；③ 计算F*G_k²（用像素块的“碰撞合并”表示乘法）；④ 用“减法动画”算出2*G_k - 结果，新增的高次项用闪烁的绿色块展示。还可以加“叮”的音效标记乘法操作，“滴”的音效标记倍增完成，让过程更直观！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，它们各有特色，能帮你从不同角度理解问题！
</eval_intro>

**题解一：Great_Influence（递归转递推，代码完整）**
* **点评**：这份题解把“递归倍增”改成了“循环递推”，更符合计算机的“迭代思维”。思路上从k=1开始，每次把k翻倍，直到覆盖n。代码里用数组实现NTT，变量命名清晰（比如a存原多项式，b[0]/b[1]交替存当前和上一步的逆），边界处理严谨（比如补到2的幂次）。最棒的是它把“递推式的计算”拆成了“计算G_k²→乘F→算2*G_k - 结果”，每一步都对应代码里的mul函数，非常好懂！

**题解二：KAMIYA_KINA（牛顿迭代法，泛用性强）**
* **点评**：这篇题解用了“牛顿迭代法”推导递推式，虽然结果和倍增法一样，但思路更通用（能推广到多项式开根、求导等问题）。推导过程把多项式看成“函数”，用泰勒展开忽略高次项，最终得到G₁ = G₀*(2 - F*G₀)。代码里的INV函数递归实现倍增，用copy和fill处理数组大小，NTT部分写得很规范，还贴心地处理了模数的正负（比如加mod再取模），值得学习！

**题解三：lzyqwq（模块化封装，代码优雅）**
* **点评**：这份题解来自作者的“多项式学习笔记”，代码用vector封装了多项式的加减乘、NTT、逆等操作，像搭积木一样调用函数。比如inv函数里，用mod函数截断多项式长度，用“c = c*(d - mod(a, 1<<i)*c)”直接对应递推式，非常简洁。这种“模块化编程”能让代码更易读、易维护，特别适合竞赛中快速调试！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
多项式求逆的难点在于“把数学推导转化为代码”，以下三个关键点是绕不开的“坎”，我们逐一破解：
</difficulty_intro>

1.  **关键点1：递推式的推导——为什么G = 2*G' - F*G'²？**
    * **分析**：假设G'是F在模x^k下的逆（F*G' ≡1 mod x^k），G是模x^{2k}的逆。因为G和G'的前k项一样，所以G - G' ≡0 mod x^k，平方后（G-G'）²≡0 mod x^{2k}。展开后乘F（利用F*G=1），就能得到G=2G' - F*G'²。**记住：这个式子是倍增法的“核心公式”，所有代码都围绕它展开！**
    * 💡 **学习笔记**：递推式的本质是“用低次解的误差修正高次解”，误差项的平方会“吃掉”高次错误。

2.  **关键点2：NTT的正确实现——模数、原根、逆变换怎么处理？**
    * **分析**：NTT的核心是“把多项式转成点值表示，乘法后再转回来”。本题模数是998244353（质数），原根是3（对应逆元332748118）。代码中需要注意：① 数组要补到2的幂次；② 逆变换后要乘“数组长度的逆元”；③ 处理负数时要加mod再取模。比如lzyqwq的代码里，NTT函数用qp(G, (M-1)/i)计算单位根，逆变换时乘qp(L, M-2)，就是正确的做法！
    * 💡 **学习笔记**：NTT的细节多，但只要记住“模数、原根、逆元”这三个关键词，就能套模板！

3.  **关键点3：数组大小与边界条件——为什么要补到2的幂次？**
    * **分析**：NTT要求数组长度是2的幂次（因为要不断二分），所以每次倍增时，要把多项式补到下一个2的幂次（比如k=1→2，k=2→4，直到覆盖n）。初始条件是G₀=F[0]的逆（因为模x^1时，只有常数项，逆就是常数项的逆元）。比如Great_Influence的代码里，n从2开始翻倍，直到超过m（题目要求的次数），就是在补全长度！
    * 💡 **学习笔记**：补到2的幂次是NTT的“硬要求”，初始条件是“常数项的逆”，这两点不能忘！

### ✨ 解题技巧总结
- **技巧A：递归转递推**：递归虽然思路清晰，但容易栈溢出，转成循环递推更安全（比如Great_Influence的代码）。
- **技巧B：模块化编程**：把NTT、乘法、逆等操作封装成函数，代码更易读（比如lzyqwq的代码）。
- **技巧C：预处理单位根**：提前算好NTT需要的单位根，能减少重复计算（比如under_the_time的代码里的poly_sqr函数）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**模块化的通用实现**（来自lzyqwq的题解），它用vector封装多项式，代码简洁，能帮你快速理解整体框架！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自lzyqwq的“多项式学习笔记”，用vector封装了多项式的基本操作，逆函数直接对应递推式，非常清晰。
* **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std; const int N = 1 << 21;
  namespace Poly {
      using ll = long long; using poly = vector<ll>;
      const ll M = 998244353, G = 3; int R[N]; poly get(int n) { return poly(n + 1); }
      ll qp(ll x, ll y) {
          ll r = 1; for (; y; y >>= 1, x = x * x % M) if (y & 1) r = r * x % M;
          return r;
      }
      void init(int n) {
          for (int i = 0; i < n; ++i) {
              R[i] = R[i >> 1] >> 1; if (i & 1) R[i] |= n >> 1;
          }
      }
      void NTT(poly &a, int n, bool o = 0) {
          if (o) init(n);
          for (int i = 0; i < n; ++i) if (i < R[i]) swap(a[i], a[R[i]]);
          for (int i = 2; i <= n; i <<= 1) {
              ll g = qp(G, (M - 1) / i), w, u, v;
              for (int j = 0; j < n; j += i) {
                  w = 1;
                  for (int k = j; k < j + (i >> 1); ++k, w = w * g % M)
                      u = a[k], v = w * a[k + (i >> 1)] % M,
                      a[k] = (u + v) % M, a[k + (i >> 1)] = (u - v + M) % M;
              }
          }
      }
      poly operator*(poly a, poly b) {
          int n = a.size(), m = b.size(), L = 1; while (L < n + m - 1) L <<= 1;
          a.resize(L); b.resize(L); NTT(a, L, 1); NTT(b, L);
          for (int i = 0; i < L; ++i) a[i] = a[i] * b[i] % M; NTT(a, L);
          poly c = get(n + m - 2); ll inv = qp(L, M - 2); c[0] = a[0] * inv % M;
          for (int i = 1; i < n + m - 1; ++i) c[i] = a[L - i] * inv % M; return c;
      }
      poly mod(poly a, int n) { a.resize(n, 0); return a; }
      poly inv(poly a) {
          poly c = get(0), d = get(0); c[0] = qp(a[0], M - 2); d[0] = 2;
          for (int i = 1; (1 << i - 1) < a.size(); ++i)
              c = mod(c * (d - mod(a, 1 << i) * c), 1 << i);
          return c;
      }
  }
  using namespace Poly; int n; poly f, g;
  int main() {
      cin.tie(0); cout.tie(0); ios::sync_with_stdio(0); cin >> n; f = get(n - 1);
      for (int i = 0; i < n; ++i) cin >> f[i], f[i] %= M; g = inv(f);
      for (int i = 0; i < n; ++i) cout << g[i] << ' '; return 0;
  }
  ```
* **代码解读概要**：
  > 代码分为两部分：① Poly namespace封装了多项式的基本操作（NTT、乘法、取模、逆）；② main函数读取输入，调用inv函数求逆，输出结果。inv函数是核心：从c[0]（常数项的逆）开始，每次倍增i，用c = c*(d - mod(a, 1<<i)*c)计算下一次的逆（d[0]=2对应递推式里的2*G'），最后返回模n的结果。


<code_intro_selected>
接下来看三个优质题解的核心片段，分析它们的“亮点”！
</code_intro_selected>

**题解一：Great_Influence（递推式的循环实现）**
* **亮点**：把递归改成循环，避免栈溢出，代码更高效。
* **核心代码片段**：
  ```cpp
  inline void solve() {
      static int t=0, bas=1, len=1;
      b[0][0] = power(a[0], mod-2); // 初始条件：常数项的逆
      n=4; calrev(n, len);
      while(bas < m) { // 倍增直到覆盖m
          t^=1; memset(b[t], 0, sizeof b[t]);
          Rep(i,0,bas) b[t][i] = (b[t^1][i] << 1) % mod; // 2*G'
          mul(b[t^1], b[t^1]); // 计算G'^2
          mul(b[t^1], a);      // 计算F*G'^2
          Rep(i,0,bas) b[t][i] = (b[t][i] - b[t^1][i] + mod) % mod; // 2*G' - F*G'^2
          bas <<=1; n <<=1; ++len;
          if(bas < m) calrev(n, len);
      }
      Rep(i,0,m>>1) printf("%d ", b[t][i]);
  }
  ```
* **代码解读**：
  > ① `b[0][0] = power(a[0], mod-2)`：初始条件，G₁是a[0]的逆；② `while(bas < m)`：循环倍增，bas是当前的次数（从1开始）；③ `b[t][i] = (b[t^1][i] << 1) % mod`：计算2*G'（t和t^1交替存储当前和上一步的逆）；④ `mul`函数计算多项式乘法（G'^2和F*G'^2）；⑤ `b[t][i] = (b[t][i] - b[t^1][i] + mod) % mod`：计算2*G' - F*G'^2，加mod避免负数。
* 💡 **学习笔记**：循环递推的关键是“用两个数组交替存储当前和上一步的逆”，避免覆盖数据！

**题解二：KAMIYA_KINA（牛顿迭代法的递归实现）**
* **亮点**：用牛顿迭代法推导递推式，思路更通用。
* **核心代码片段**：
  ```cpp
  void INV(int *b, int *a, int n) {
      if(n == 1) return b[0] = ksm(a[0], mod-2), void(); // 初始条件
      INV(b, a, (n + 1) >> 1); // 递归求模(n+1)/2的逆
      static int c[N]; int len=1, p=-1; while(len < (n<<1)) len<<=1, p++;
      FOR(i,1,len-1) rev[i] = (rev[i>>1]>>1)|((i&1)<<p); // 计算反转数组
      copy(a, a+n, c); fill(c+n, c+len, 0); // 复制a到c，补0
      NTT(c, len, 1), NTT(b, len, 1); // NTT变换
      FOR(i,0,len-1) b[i] = (2 - b[i]*c[i]%mod + mod)%mod * b[i]%mod; // 递推式：G=G0*(2-F*G0)
      NTT(b, len, 0); fill(b+n, b+len, 0); // 逆变换，截断长度
  }
  ```
* **代码解读**：
  > ① `if(n==1)`：递归终止条件，返回常数项的逆；② `INV(b,a,(n+1)>>1)`：递归求低次逆；③ `copy和fill`：把a复制到c并补0，准备乘法；④ `NTT`：把b和c转成点值；⑤ `b[i] = (2 - b[i]*c[i]%mod + mod)%mod * b[i]%mod`：对应牛顿迭代的递推式G₁=G₀*(2-F*G₀)；⑥ `NTT(b,len,0)`：逆变换回系数形式，截断到n长度。
* 💡 **学习笔记**：牛顿迭代法的递推式和倍增法是等价的，但更易推广到其他多项式问题（比如开根）！

**题解三：lzyqwq（模块化的inv函数）**
* **亮点**：用vector封装，代码简洁，直接对应递推式。
* **核心代码片段**：
  ```cpp
  poly inv(poly a) {
      poly c = get(0), d = get(0); c[0] = qp(a[0], M-2); d[0] = 2;
      for(int i=1; (1<<i-1) < a.size(); ++i)
          c = mod(c * (d - mod(a, 1<<i)*c), 1<<i);
      return c;
  }
  ```
* **代码解读**：
  > ① `c[0] = qp(a[0], M-2)`：初始条件；② `d[0] = 2`：对应递推式里的2；③ `for循环`：倍增i，每次计算c = c*(d - mod(a,1<<i)*c)（mod 1<<i），直接对应递推式G=2*G' - F*G'^2（因为d是[2]，mod(a,1<<i)*c是F*G'，所以d - ...是2 - F*G'，乘c就是G'*(2-F*G')）；④ `mod`函数截断多项式长度到1<<i。
* 💡 **学习笔记**：模块化编程能把复杂的递推式写成“一句话”，非常优雅！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”多项式的倍增过程，我设计了一个**8位像素风的动画**——像玩“FC游戏机”一样，看着多项式从“小不点”长成“大巨人”！
</visualization_intro>

  * **动画演示主题**：像素多项式的“成长之旅”（从x^1到x^n，每一步都用像素块展示系数变化）
  * **核心演示内容**：展示倍增法的每一步（计算G'^2→乘F→算2*G' - 结果），用NTT的“旋转动画”模拟点值变换，用颜色高亮当前处理的项。
  * **设计思路简述**：用8位像素风是因为它“简单直观”，像小时候玩的《超级玛丽》；用颜色区分次数（红=常数项，蓝=一次项，绿=二次项…）能快速识别；音效（“叮”=乘法，“滴”=倍增完成）能强化记忆；“单步执行”让你能暂停看每一步细节！

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：屏幕左侧是“多项式展示区”（用像素块排成一行，每个块代表一个次数的系数），右侧是“控制面板”（开始/暂停、单步、重置、速度滑块）。背景是FC风格的蓝色，背景音乐是8位版《小星星》。
    2. **初始状态**：多项式F(x)的常数项（红块）显示在左侧，G(x)的初始值（红块，值为F[0]的逆）在下方。
    3. **第一次倍增（k=1→k=2）**：
       - **高亮G'**：G(x)的红块闪烁（表示当前的低次逆G'）。
       - **计算G'^2**：两个G'的像素块“碰撞”合并成一个新的像素块（用黄色表示），伴随“叮”的音效。
       - **乘F(x)**：黄色块和F的像素块“融合”成绿色块（表示F*G'^2），再“叮”一声。
       - **计算2*G' - 结果**：G'的红块变成两个（表示2*G'），然后和绿色块“相减”（绿色块消失，红块变成蓝块表示新增的一次项），伴随“滴”的音效。
       - **更新G(x)**：多项式展示区新增蓝块（一次项），表示G(x)现在是模x^2的逆。
    4. **后续倍增**：重复步骤3，每次倍增时新增更高次的像素块（绿→青→紫…），直到覆盖题目要求的n次。
    5. **完成状态**：所有像素块停止闪烁，播放8位版“胜利音效”，屏幕中央显示“多项式逆求解完成！”。

  * **旁白提示**：
    - （高亮G'时）“现在我们要计算模x^2的逆，先看当前的低次逆G'（红块）！”
    - （计算G'^2时）“G'乘G'，得到G'^2（黄块），这一步用NTT加速哦！”
    - （乘F时）“G'^2乘F(x)，得到F*G'^2（绿块）！”
    - （计算2*G' - 结果时）“用2*G'减去这个结果，新增的一次项（蓝块）就是模x^2的逆！”


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
多项式求逆是“多项式全家桶”的基础，学会它能解决很多生成函数问题！比如：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 多项式除法：用逆元把除法转乘法（比如A/B = A*B^{-1}）；
    - 生成函数：比如“付公主的背包”问题，用生成函数表示物品，求逆元得到方案数；
    - 多项式快速幂：用逆元计算ln和exp，再转成幂（比如A^k = exp(k*lnA)）。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P3803** - 多项式乘法
       * 🗣️ **推荐理由**：NTT的基础题，帮你熟悉多项式乘法的实现，是学多项式求逆的“前置技能”！
    2. **洛谷 P4389** - 付公主的背包
       * 🗣️ **推荐理由**：生成函数的经典题，需要用多项式逆元计算方案数，能帮你理解“逆元在生成函数中的应用”！
    3. **洛谷 P5245** - 多项式快速幂
       * 🗣️ **推荐理由**：用多项式逆元计算ln和exp，再求快速幂，是多项式求逆的“进阶应用”！
    4. **洛谷 P6185** - 多项式除法
       * 🗣️ **推荐理由**：直接用多项式逆元解决除法问题，帮你巩固“逆元转除法”的思路！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者分享了自己的“踩坑经历”，比如：
</insights_intro>

> **参考经验 (来自 Great_Influence)**：“我一开始用递归实现，结果大数据时栈溢出了，改成循环递推就好了！”  
> **点评**：递归虽然思路清晰，但对于n=1e5的大数据，递归深度会达到log2(1e5)≈17，其实不会溢出？可能作者的递归写法有问题，但“递归转递推”是个好习惯，能避免不必要的错误！

> **参考经验 (来自 KAMIYA_KINA)**：“我一开始没处理负数，结果模运算后出现了负数，加mod再取模就好了！”  
> **点评**：模数是正数，所以计算减法时一定要加mod再取模，比如(a - b) % mod 要写成(a - b + mod) % mod，这是多项式题的“常识”！


<conclusion>
多项式求逆是“多项式算法”的敲门砖，关键是理解“倍增法的递推式”和“NTT的加速作用”。记住：**递推式是核心，NTT是工具，代码实现要注意细节**！多写几次代码，多调试几次，你就能掌握这个“多项式世界的除法”啦！下次我们一起学多项式开根，不见不散！💪
</conclusion>

---
处理用时：147.15秒
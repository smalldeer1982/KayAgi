# 题目信息

# 【模板】任意模数多项式乘法逆

## 题目描述

给定一个多项式 $F(x)$ ，请求出一个多项式 $G(x)$ ， 满足 $F(x) * G(x) \equiv 1 ( \mathrm{mod\:} x^n )$
 。系数对 $10^9+7$ 取模。

## 说明/提示

$1 \leq n \leq 10^5$，$0 \leq a_i \leq 10^9$。

## 样例 #1

### 输入

```
5
1 6 3 4 9```

### 输出

```
1 1000000001 33 999999823 1020```

# AI分析结果

---
# 💡 Kay的C++算法解析：任意模数多项式乘法逆 深入学习指南 💡

<introduction>
  今天我们来挑战一个“多项式世界的魔法题”——**任意模数多项式乘法逆**！简单来说，就是给你一个多项式F(x)，要找到另一个多项式G(x)，让它们相乘后，除了常数项是1，其他低次项（前n项）都消失。这就像找一个“多项式倒数”，是不是很神奇？本指南会帮你拆解这个魔法的步骤，还会用像素动画让你“看得到”算法在跑～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：多项式乘法逆（倍增法） + 任意模数多项式乘法（MTT/三模NTT）

🗣️ **初步分析**：
解决这道题，关键要掌握两个“魔法技能”：  
1. **多项式求逆的倍增术**：就像剥洋葱，先找到“小范围”的逆（比如前k项正确），再通过公式扩大到“大范围”（前2k项正确）。核心公式是：如果G₁是F的逆（模xᵏ），那么G = G₁×(2 - F×G₁) 就是F的逆（模x²ᵏ）。  
2. **任意模数的多项式乘法**：因为题目模数是1e9+7（不是NTT友好的模数，比如998244353），所以普通FFT会有精度问题。这时需要用**拆系数FFT（MTT）**——把大数拆成两个小整数（比如高15位和低15位），分别用FFT计算，再合并结果；或者用**三模NTT**——用三个NTT友好模数分别计算，再用中国剩余定理（CRT）合并成1e9+7下的结果。

### 核心算法流程与可视化思路
- **倍增过程**：从G₀=F(0)的逆（常数项的逆）开始，每次把范围扩大一倍，直到覆盖前n项。  
- **可视化设计**：用8位像素风格展示两个多项式数组（F和G），每次迭代时：  
  1. 高亮G中“新计算的项”（比如从k到2k-1的位置）；  
  2. 用动画展示F×G₁的乘法过程（拆系数→FFT→合并）；  
  3. 用“减法动画”展示2×G₁ - F×G₁²的计算（比如G₁的像素块变亮 twice，再减去乘法结果的像素块）。  
- **游戏化元素**：加入“关卡”（每完成一次倍增算一关），过关时播放“叮”的像素音效；完成全部n项时播放胜利音乐，像素块会“跳起来”庆祝～


---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了4份优质题解，覆盖了MTT和三模NTT两种主流方法，帮你全面理解！
</eval_intro>

**题解一：MTT模板（作者：yybyyb，赞20）**
* **点评**：这份题解是MTT+多项式求逆的“标准模板”，思路直接——用拆系数FFT实现任意模数乘法，再套多项式求逆的倍增框架。代码结构清晰，`Multi`函数负责MTT乘法，`Inv`函数负责倍增求逆。特别值得学习的是**拆系数的细节**：把每个系数拆成高m位和低m位（m=√1e9+7≈3e4），分别计算后合并，完美解决了浮点精度问题。唯一的小遗憾是注释少，但代码逻辑非常工整，适合作为入门模板。

**题解二：三模NTT+CRT（作者：mrsrz，赞8）**
* **点评**：这份题解用了三模NTT的思路——选三个NTT友好模数（998244353、1004535809、469762049），分别计算多项式乘法，再用CRT合并成1e9+7下的结果。作者特别指出了**负数处理的坑**：如果中间结果出现负数，直接合并会出错，所以每次乘法后要先CRT成1e9+7下的值，再转回三个模数。这个细节很关键，避免了很多调试bug！

**题解三：优化MTT（作者：EternalEpic，赞8）**
* **点评**：这份题解对MTT做了优化——用复数共轭性质把7次FFT减少到5次，降低了常数。作者还详细推导了多项式求逆的倍增公式，帮助理解“为什么G=2G₁ - F×G₁²”。代码中的`MTT`函数用了自定义复数类，避免了STL的 overhead，适合追求效率的同学学习。

**题解四：简短MTT模板（作者：xzyxzy，赞6）**
* **点评**：这份题解的代码非常短，但关键细节一个不少！作者强调了**MTT的精度问题**：不能直接计算F×G₁²（会爆double），必须先算F×G₁，再乘以G₁。这个小技巧能避免很多浮点错误，适合新手记住。代码中的`GetInv`函数把倍增和乘法结合得很紧凑，值得参考。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
多项式求逆的难点不在“思路”，而在“实现细节”——任意模数乘法的精度、倍增公式的推导、模运算的处理。结合优质题解，我总结了3个核心难点和解决策略：
</difficulty_intro>

1.  **难点1：如何实现任意模数的多项式乘法？**
    * **分析**：普通FFT在处理大模数时会有浮点误差（double只能精确到2^53，而1e9+7的平方是1e18，超过精度）。解决方法有两种：  
      - **MTT（拆系数）**：把每个系数a拆成a₁×m + a₀（m=√mod），这样a×b = (a₁m+a₀)(b₁m+b₀) = a₁b₁m² + (a₁b₀+a₀b₁)m + a₀b₀，分别用FFT计算这三个部分，再合并。  
      - **三模NTT**：用三个NTT模数计算，再用CRT合并。需要注意的是，三个模数的乘积要大于2×mod×max_degree²（避免溢出）。
    * 💡 **学习笔记**：任意模数乘法的核心是“拆分计算，再合并”，选MTT还是三模NTT看个人习惯——MTT代码短，三模NTT理论效率高。

2.  **难点2：为什么多项式求逆的倍增公式是G=2G₁ - F×G₁²？**
    * **分析**：假设G₁是F的逆（模xᵏ），即F×G₁ ≡1 mod xᵏ。我们要找G，使得F×G≡1 mod x²ᵏ。因为G ≡ G₁ mod xᵏ（前k项相同），所以G = G₁ + H×xᵏ（H是某个多项式）。代入F×G≡1 mod x²ᵏ，展开后得到H = G₁²×(1 - F×G₁)的高k项？不，更简单的推导是：  
      由F×G₁ ≡1 mod xᵏ，得F×G₁ = 1 + xᵏ×A（A是多项式）。那么G = G₁×(2 - F×G₁) = G₁×(2 - (1 + xᵏ×A)) = G₁×(1 - xᵏ×A)，所以F×G = F×G₁×(1 - xᵏ×A) = (1 + xᵏ×A)(1 - xᵏ×A) = 1 - x²ᵏ×A² ≡1 mod x²ᵏ，完美！
    * 💡 **学习笔记**：倍增公式的本质是“用已知的小范围解，修正得到大范围解”，关键是利用“模xᵏ下的等式”推导模x²ᵏ的等式。

3.  **难点3：如何处理模运算中的负数和精度误差？**
    * **分析**：MTT中，FFT的结果是浮点数，需要四舍五入到整数；三模NTT中，中间结果可能是负数，需要加上模数转成正数。解决方法：  
      - MTT：计算后用`round`函数四舍五入，再对mod取模（注意加mod再取模，避免负数）。  
      - 三模NTT：每次运算后都加上模数再取模，确保结果非负；CRT合并时，处理负数的方法是加上模数乘积直到结果为正。
    * 💡 **学习笔记**：模运算的核心是“保持非负”，任何时候遇到负数，都要加上模数转成正数！


### ✨ 解题技巧总结
- **技巧1：拆系数的选择**：MTT中，m选√mod（比如1e9+7的m≈3e4），这样拆后的两个数都小于m，乘积不会超过m²≈1e9，刚好在double的精度范围内。  
- **技巧2：倍增的初始化**：多项式求逆的初始条件是G₀=F[0]的逆（费马小定理：G₀ = F[0]^(mod-2) mod mod）。  
- **技巧3：代码模块化**：把MTT/NTT、乘法、求逆分别写成函数，这样代码更清晰，调试更方便。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**MTT+多项式求逆的通用核心代码**，综合了优质题解的思路，结构清晰，适合入门！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自yybyyb的题解，调整了注释和变量名，更易读。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstdio>
    #include <cmath>
    #include <algorithm>
    using namespace std;
    typedef long long ll;
    const int MOD = 1e9 + 7;
    const double PI = acos(-1.0);
    const int MAX = 444444; // 要大于2*1e5*2

    // 复数类
    struct Complex {
        double a, b;
        Complex(double a=0, double b=0):a(a),b(b){}
        Complex operator+(const Complex& x) const { return Complex(a+x.a, b+x.b); }
        Complex operator-(const Complex& x) const { return Complex(a-x.a, b-x.b); }
        Complex operator*(const Complex& x) const { return Complex(a*x.a - b*x.b, a*x.b + b*x.a); }
    } W[MAX];

    int r[MAX]; // FFT的反转数组
    int a[MAX], b[MAX]; // 输入多项式F和输出多项式G
    int c[MAX], d[MAX]; // 临时数组，存乘法结果

    // 快速幂：求a^b mod MOD
    int fpow(int a, int b) {
        int s = 1;
        while (b) {
            if (b&1) s = (ll)s * a % MOD;
            a = (ll)a * a % MOD;
            b >>= 1;
        }
        return s;
    }

    // FFT函数：opt=1正向，opt=-1逆向
    void FFT(Complex* P, int N, int opt) {
        for (int i=0; i<N; ++i) if (i < r[i]) swap(P[i], P[r[i]]);
        for (int i=1; i<N; i<<=1) { // 枚举半长度
            for (int p=i<<1, j=0; j<N; j+=p) { // 枚举块
                for (int k=0; k<i; ++k) { // 枚举每个块内的元素
                    Complex w = W[N/i * k];
                    w.b *= opt; // 逆向时取共轭
                    Complex X = P[j+k], Y = P[i+j+k] * w;
                    P[j+k] = X + Y;
                    P[i+j+k] = X - Y;
                }
            }
        }
        if (opt == -1) for (int i=0; i<N; ++i) P[i].a /= N;
    }

    // MTT：计算a*b mod MOD，结果存在ret中，len是a和b的长度（前len项有效）
    void Multi(int* a, int* b, int len, int* ret) {
        int N = 1, l = 0;
        while (N < len) N <<= 1, ++l; // 找到大于等于len的最小2的幂
        for (int i=0; i<N; ++i) r[i] = (r[i>>1] >>1) | ((i&1) << (l-1)); // 初始化反转数组
        // 预处理单位根
        for (int i=1; i<N; i<<=1)
            for (int k=0; k<i; ++k)
                W[N/i * k] = Complex(cos(k*PI/i), sin(k*PI/i));
        // 拆系数：a = a1*m + a0，b = b1*m + b0，m=√MOD≈31623
        const int m = 31623;
        Complex A[N], B[N], C[N], D[N];
        for (int i=0; i<len; ++i) {
            a[i] %= MOD; b[i] %= MOD;
            A[i] = Complex(a[i]/m, 0); // a1
            B[i] = Complex(a[i]%m, 0); // a0
            C[i] = Complex(b[i]/m, 0); // b1
            D[i] = Complex(b[i]%m, 0); // b0
        }
        // 计算四个乘积：A*C, B*C+A*D, B*D
        FFT(A, N, 1); FFT(B, N, 1); FFT(C, N, 1); FFT(D, N, 1);
        Complex AC[N], BD[N], AD_BC[N];
        for (int i=0; i<N; ++i) {
            AC[i] = A[i] * C[i];
            BD[i] = B[i] * D[i];
            AD_BC[i] = A[i] * D[i] + B[i] * C[i];
        }
        FFT(AC, N, -1); FFT(AD_BC, N, -1); FFT(BD, N, -1);
        // 合并结果：ret = (AC*m² + AD_BC*m + BD) mod MOD
        for (int i=0; i<len; ++i) {
            ll ac = (ll)(AC[i].a + 0.5) % MOD;
            ll ad_bc = (ll)(AD_BC[i].a + 0.5) % MOD;
            ll bd = (ll)(BD[i].a + 0.5) % MOD;
            ret[i] = (ac * (ll)m % MOD * m % MOD + ad_bc * (ll)m % MOD + bd) % MOD;
            if (ret[i] < 0) ret[i] += MOD;
        }
    }

    // 多项式求逆：a是输入多项式，b是输出逆多项式，len是要求的长度（前len项）
    void Inv(int* a, int* b, int len) {
        if (len == 1) { // 初始条件：b[0] = a[0]的逆
            b[0] = fpow(a[0], MOD-2);
            return;
        }
        Inv(a, b, len >> 1); // 递归求前len/2项的逆
        // 计算F*G1，结果存在c中
        Multi(a, b, len, c);
        // 计算c*G1，结果存在d中（即F*G1²）
        Multi(c, b, len, d);
        // 更新G：G = 2*G1 - F*G1²
        for (int i=0; i<len; ++i) {
            b[i] = (2LL * b[i] - d[i] + MOD) % MOD; // 加MOD避免负数
        }
    }

    int main() {
        int n;
        scanf("%d", &n);
        for (int i=0; i<n; ++i) scanf("%d", &a[i]);
        // 找到大于等于n的最小2的幂（倍增需要）
        int N = 1;
        while (N < n) N <<= 1;
        Inv(a, b, N);
        for (int i=0; i<n; ++i) printf("%d ", b[i]);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为三部分：1. **FFT/MTT**：实现任意模数多项式乘法；2. **多项式求逆**：用倍增法递归计算；3. **主函数**：读取输入，调用求逆函数，输出结果。关键步骤是`Inv`函数中的递归——先求前半部分的逆，再用MTT计算两次乘法，最后更新逆多项式。


---
<code_intro_selected>
接下来看**优质题解的核心片段**，学习它们的亮点！
</code_intro_selected>

**题解一：MTT的拆系数与合并（作者：yybyyb）**
* **亮点**：清晰实现了MTT的拆系数逻辑，解决了大模数的精度问题。
* **核心代码片段**：
    ```cpp
    const int m = 31623; // √(1e9+7)≈31623
    Complex A[N], B[N], C[N], D[N];
    for (int i=0; i<len; ++i) {
        a[i] %= MOD; b[i] %= MOD;
        A[i] = Complex(a[i]/m, 0); // a的高15位
        B[i] = Complex(a[i]%m, 0); // a的低15位
        C[i] = Complex(b[i]/m, 0); // b的高15位
        D[i] = Complex(b[i]%m, 0); // b的低15位
    }
    // 计算AC = A*C（高×高），BD = B*D（低×低），AD_BC = A*D + B*C（高×低+低×高）
    FFT(A, N, 1); FFT(B, N, 1); FFT(C, N, 1); FFT(D, N, 1);
    for (int i=0; i<N; ++i) {
        AC[i] = A[i] * C[i];
        BD[i] = B[i] * D[i];
        AD_BC[i] = A[i] * D[i] + B[i] * C[i];
    }
    FFT(AC, N, -1); FFT(AD_BC, N, -1); FFT(BD, N, -1);
    // 合并：ret = AC*m² + AD_BC*m + BD
    ret[i] = (ac * m % MOD * m % MOD + ad_bc * m % MOD + bd) % MOD;
    ```
* **代码解读**：
    > 这段代码把每个系数拆成高15位和低15位（因为31623≈2^15），这样两个拆后的数相乘不会超过2^30，刚好在double的精度范围内。然后用FFT计算三个乘积项，最后合并成原模数下的结果。比如，a=123456，m=31623，那么a1=123456/31623=3（高15位），a0=123456%31623=28587（低15位），a=3×31623 + 28587=123456，没错！
* 💡 **学习笔记**：拆系数的关键是选择合适的m，让拆后的数乘积不超过double的精度（2^53）。

**题解二：三模NTT的CRT合并（作者：mrsrz）**
* **亮点**：用三个NTT模数计算，再用CRT合并，解决了MTT的浮点误差问题。
* **核心代码片段**：
    ```cpp
    // CRT合并三个模数的结果：a（mod md1）、b（mod md2）、c（mod md3）
    inline ll crt(int a, int b, int c) {
        ll A = (mul(md2%md1, a, md1) * _ + mul(md1%md2, b, md2) * __) % M;
        ll k = (c - A%md3 + md3) % md3 * ___ % md3;
        return (k * (M%md) % md + A%md) % md;
    }
    ```
* **代码解读**：
    > 这段代码用中国剩余定理合并三个模数的结果。首先合并前两个模数（md1=998244353，md2=1004535809）得到A（mod md1×md2），然后合并第三个模数（md3=469762049）得到最终结果（mod md1×md2×md3≈4e26，远大于1e9+7，所以可以安全取模）。其中_、__、___是预处理的逆元，加速计算。
* 💡 **学习笔记**：三模NTT的核心是“用多个小模数计算，再合并”，适合对浮点精度敏感的场景。


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看得到”多项式求逆的过程，我设计了一个**8位像素风格的动画**，像玩FC游戏一样学习算法！
</visualization_intro>

### 动画设计方案
**主题**：像素探险家“小K”在多项式数组中“寻找逆元”，每完成一次倍增就通关一关。

#### 1. 场景与UI初始化（FC风格）
- **背景**：深蓝色像素块（代表“多项式空间”），底部有一排绿色像素块（代表输入多项式F），顶部有一排红色像素块（代表输出逆多项式G）。
- **控制面板**：左下角有四个按钮（开始/暂停、单步、重置、AI自动），右下角有速度滑块（1x~5x）。
- **音效**：初始化时播放8位风格的轻快背景音乐（比如《超级马里奥》的开场音乐）。

#### 2. 核心动画步骤（以n=4为例）
- **关卡1（len=1）**：  
  绿色像素块F[0]亮起来（比如变成黄色），小K走到F[0]旁边，举着牌子显示“求逆：F[0]^(mod-2)”。红色像素块G[0]变成F[0]的逆（比如F[0]=1，G[0]=1），播放“叮”的音效。
- **关卡2（len=2）**：  
  1. 小K走到G[0]旁边，牌子显示“递归求前1项逆”（G₁=[G[0]]）。  
  2. 绿色像素块F[0]、F[1]和红色像素块G[0]亮起来，播放“嗡嗡”的音效（代表MTT计算F×G₁），中间出现一个蓝色像素块数组C（F×G₁的结果）。  
  3. 蓝色数组C和红色数组G₁亮起来，播放“嗡嗡”音效（计算C×G₁，即F×G₁²），中间出现紫色数组D。  
  4. 红色数组G₁的每个像素块变亮两次（代表2×G₁），然后减去紫色数组D的像素块（G=2G₁ - D），G[1]变成新的值，播放“通关”音效（比如《塞尔达》的谜题解决音）。
- **关卡3（len=4）**：重复关卡2的步骤，扩大到前4项，完成后G数组全亮，播放胜利音乐（比如《魂斗罗》的通关音乐），小K跳起来庆祝。

#### 3. 交互设计
- **单步模式**：点击“单步”按钮，动画走一步（比如计算F×G₁→计算C×G₁→更新G）。
- **AI自动模式**：点击“AI自动”，动画自动播放，小K会“自动探索”，每步都有文字提示（比如“现在计算F×G₁的乘法”）。
- **速度调节**：滑动滑块可以调整动画速度（1x最慢，5x最快）。

#### 4. 设计思路
- **像素风格**：用简单的色块和8位颜色（比如FC的64色 palette），降低视觉负担，让注意力集中在算法流程上。
- **游戏化元素**：关卡、音效、角色动画，让学习更有趣——完成关卡会有成就感，像玩游戏一样记住算法步骤。
- **关键步骤高亮**：用颜色变化（比如黄色→红色）和角色动作（小K举牌子），明确提示当前在做什么，避免 confusion。


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
多项式求逆是多项式操作的“基础砖”，学会它可以解决很多更复杂的问题！
</similar_problems_intro>

### 通用思路迁移
多项式求逆的**倍增法**和**任意模数乘法**可以用于：
1. **多项式除法**：求F/G mod x^n，需要先求G的逆，再乘以F。
2. **多项式开根**：求G满足G²≡F mod x^n，同样用倍增法，公式是G = (G₁ + F×G₁⁻¹)/2。
3. **生成函数问题**：比如求卡特兰数的生成函数（C(x) = 1 + x×C(x)²，需要求逆）。

### 洛谷练习推荐
1.  **洛谷 P4245** - 任意模数多项式乘法  
   🗣️ **推荐理由**：这是MTT/三模NTT的模板题，帮你巩固任意模数乘法的实现。
2.  **洛谷 P4238** - 多项式乘法逆（NTT模数）  
   🗣️ **推荐理由**：这是多项式求逆的基础题，模数是998244353（NTT友好），可以对比任意模数的差异。
3.  **洛谷 P4389** - 多项式乘法逆（加强版）  
   🗣️ **推荐理由**：数据范围更大（n≤1e5），考验代码的效率和常数优化，适合进阶。
4.  **洛谷 P5245** - 多项式开根  
   🗣️ **推荐理由**：用倍增法求多项式开根，思路和求逆类似，帮你举一反三。


---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的作者心得，能帮你避免踩坑！
</insights_intro>

> **参考经验（来自xzyxzy）**：“我调试了两个小时，原因在于：FFT由于不能取模，而double的位数有限，所以多项式算AB²的时候，不能像NTT那样三个点值直接乘起来，会爆double，要乘完AB之后再乘B！”  
> **点评**：这个经验太重要了！MTT中，直接计算AB²会让中间结果超过double的精度（比如AB的结果是1e9，再乘B就是1e18，超过2^53≈9e15），所以必须分两次乘——先算AB，再算(AB)×B。这是很多新手会踩的坑，记住这个技巧能少走很多弯路！


---

<conclusion>
多项式求逆看似复杂，但拆分成“倍增法”和“任意模数乘法”两个部分后，其实很清晰——就像搭积木，先学会搭小块，再搭大块。通过像素动画，你能“看得到”算法的每一步；通过优质题解，你能学会别人的经验。下次遇到多项式问题，比如开根、除法，你一定能轻松应对！加油，小探险家～💪
</conclusion>

---

---
处理用时：150.02秒
# 题目信息

# [集训队作业2013] 城市规划

## 题目描述

刚刚解决完电力网络的问题，阿狸又被领导的任务给难住了。

刚才说过，阿狸的国家有 $n$ 个城市，现在国家需要在某些城市对之间建立一些贸易路线，使得整个国家的任意两个城市都直接或间接的连通。

为了省钱, 每两个城市之间最多只能有一条直接的贸易路径。对于两个建立路线的方案，如果存在一个城市对，在两个方案中是否建立路线不一样，那么这两个方案就是不同的，否则就是相同的。现在你需要求出一共有多少不同的方案。

好了，这就是困扰阿狸的问题。换句话说，你需要求出 $n$ 个点的简单 (无重边无自环) 有标号无向连通图数目。

由于这个数字可能非常大, 你只需要输出方案数对 $1004535809$ ( $479 \times 2 ^{21} + 1$ ) 取模即可。

## 说明/提示

【数据范围】   
对于 $20\%$ 的数据，$n \le 10$    
对于 $40\%$ 的数据，$n \le 1000$     
对于 $60\%$ 的数据，$n \le 30000$    
对于 $80\%$ 的数据，$n \le 60000$     
对于 $100\%$ 的数据，$n \le 130000$   

试题来源：$2013$ 中国国家集训队第二次作业

## 样例 #1

### 输入

```
3```

### 输出

```
4```

## 样例 #2

### 输入

```
4```

### 输出

```
38```

## 样例 #3

### 输入

```
100000```

### 输出

```
829847355
```

# AI分析结果

# 💡 Kay的C++算法解析：[集训队作业2013]城市规划 深入学习指南 💡

<introduction>
  今天我们来挑战一道经典的组合计数难题——**n个点的有标号无向连通图数目**。这道题需要用到生成函数、多项式求逆、NTT（快速数论变换）等高级技巧，听起来有点复杂？别担心，Kay会一步步帮你拆解思路，让这些“高大上”的算法变得直观易懂！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（生成函数+多项式操作）  

🗣️ **初步分析**：
> 解决这道题的核心是**用生成函数将“连通图计数”转化为“非连通图计数”的卷积问题**，再通过多项式求逆/对数等操作求解。简单来说：
> - 生成函数就像一个“数列打包机”，把离散的数列（比如“n个点的图数目”）变成多项式，方便我们用代数方法处理**子问题合并**（卷积）；
> - NTT是“快速卷积计算器”，能在O(n log n)时间内完成多项式乘法（对应组合计数中的“子问题组合”）；
> - 多项式求逆/对数则是“方程求解器”，帮我们从“非连通图的生成函数”反推出“连通图的生成函数”。

### 核心思路与难点
我们设：
- `g(n)`：n个点的**无向图数目**（每条边选或不选，所以`g(n) = 2^(n*(n-1)/2)`）；
- `f(n)`：n个点的**无向连通图数目**（题目要求的答案）。

通过**枚举1号点所在连通块的大小**，我们得到关键关系：  
`g(n) = sum_{i=1}^n C(n-1, i-1) * f(i) * g(n-i)`  
（选i-1个点和1号点组成连通块，剩下的n-i个点随意连）

接下来的难点是**将这个组合式转化为生成函数的卷积**：
1. 展开组合数`C(n-1,i-1) = (n-1)! / [(i-1)! (n-i)!]`；
2. 两边除以`(n-1)!`，得到：  
   `g(n)/(n-1)! = sum_{i=1}^n [f(i)/(i-1)!] * [g(n-i)/(n-i)!]`；
3. 这恰好是**生成函数的卷积形式**！我们定义：
   - `F(x)`：`f(n)/(n-1)!`的生成函数（目标）；
   - `G(x)`：`g(n)/n!`的生成函数（已知）；
   - `H(x)`：`g(n)/(n-1)!`的生成函数（已知）。

最终得到**生成函数方程**：`F(x) = H(x) * G(x)^{-1}`（`G(x)^{-1}`是G(x)的多项式逆元）。


### 可视化设计思路
为了直观理解“生成函数卷积”和“多项式求逆”，Kay设计了一个**复古像素风的“生成函数实验室”**动画：
- **角色**：像素小人“小算”负责操作“卷积机器”和“求逆机器人”；
- **场景**：屏幕左侧是“生成函数陈列柜”（用不同颜色的像素块代表多项式的项，比如红色块代表`g(n)/n!`，蓝色块代表`f(n)/(n-1)!`）；
- **卷积过程**：当“小算”将`F(x)`和`G(x)`放入“卷积机器”，机器会将对应项的像素块“相乘”（颜色叠加）并“相加”（块合并），最终输出`H(x)`的像素序列；
- **求逆过程**：“求逆机器人”会迭代更新`G(x)`的逆元，每一步都用闪烁的像素块提示当前的近似值，直到收敛到正确的逆元；
- **音效**：卷积时播放“叮~”的像素音，求逆完成时播放“胜利”音效，增强记忆点。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，覆盖了“多项式求逆”和“多项式对数”两种核心方法：
</eval_intro>

### 题解一：多项式求逆法（作者：Kinandra，赞47）
* **点评**：  
  这份题解是**最经典的“生成函数+多项式求逆”实现**，思路严谨且代码简洁。作者清晰推导了生成函数的卷积关系，并用NTT实现多项式乘法和求逆。代码中的`Poly`结构体封装了NTT和求逆操作，变量命名（如`g1`对应`H(x)`，`g2`对应`G(x)`）清晰易懂。特别值得学习的是**阶乘和逆元的预处理**——这是生成函数转化的关键步骤！


### 题解二：多项式对数法（作者：w33z8kqrqk8zzzx33，赞37）
* **点评**：  
  这份题解用了更简洁的**生成函数对数**方法（`e^{F(x)} = G(x)` → `F(x) = ln G(x)`），直接绕过了卷积逆元的推导，代码量大幅减少。作者抓住了“连通图是图的连通分支划分”这一本质，用指数生成函数的性质快速建立关系。代码中的`poly::ln`函数是核心，适合已经掌握多项式对数的学习者。


### 题解三：双方法对比（作者：EnofTaiPeople，赞21）
* **点评**：  
  这份题解**同时讲解了“多项式求逆”和“多项式对数”两种方法**，并详细推导了两者的等价性（`F(x) = ln G(x)`等价于`F(x) = H(x) * G(x)^{-1}`）。作者用通俗的语言解释了生成函数的“指数”和“对数”含义，适合新手理解两种方法的联系。代码中两种方法的实现对比，能帮助学习者快速掌握不同的解题路径。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“将组合计数问题转化为生成函数问题”，以下是3个核心难点及解决策略：
</difficulty_intro>

### 1. 如何建立“连通图”与“非连通图”的关系？
* **难点**：直接计算连通图数目很难，但非连通图可以通过“枚举连通块大小”分解为子问题。  
* **策略**：通过**固定1号点的连通块大小**，将非连通图的数目拆分为“连通块方案 × 剩余点方案”，从而得到递推式`g(n) = sum C(n-1,i-1)f(i)g(n-i)`。

### 2. 如何将递推式转化为生成函数的卷积？
* **难点**：递推式中的组合数`C(n-1,i-1)`阻碍了直接卷积。  
* **策略**：**除以阶乘**消去组合数！将递推式两边除以`(n-1)!`，得到`g(n)/(n-1)! = sum [f(i)/(i-1)!] * [g(n-i)/(n-i)!]`，这正是生成函数的卷积形式。

### 3. 如何实现多项式求逆/对数？
* **难点**：多项式操作需要掌握NTT、迭代求逆等模板，容易出错。  
* **策略**：
  - **NTT模板**：记住模数1004535809的原根是3，逆原根是334845270；
  - **多项式求逆**：用迭代法，每次将逆元的长度翻倍，利用`B = B*(2 - A*B)`更新；
  - **多项式对数**：通过求导+求逆+积分实现（`ln G(x) = ∫ G’(x)/G(x) dx`）。

### ✨ 解题技巧总结
- **正难则反**：直接算连通图难，就先算非连通图，再用容斥/生成函数反推；
- **生成函数转化**：遇到“子问题组合”的计数问题，优先考虑生成函数；
- **模板复用**：多项式操作（NTT、求逆、对数）是通用模板，提前背熟能节省大量时间。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**综合了“多项式求逆”的核心实现**，来自Kinandra的题解，它覆盖了生成函数构造、NTT、多项式求逆的完整流程：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码是“生成函数+多项式求逆”的典型实现，涵盖了阶乘预处理、生成函数构造、NTT、多项式求逆等关键步骤。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#define mod 1004535809
using namespace std;

long long inv[200005], fiv[200005];

long long fsp(long long base, long long p) {
    long long rt = 1;
    while (p) {
        if (p & 1) (rt *= base) %= mod;
        (base *= base) %= mod;
        p >>= 1;
    }
    return rt;
}

int rtt[600005];
struct Poly {
    long long x[600005];
    void cpy(Poly &a, int len) { for (int i = 0; i < len; ++i) x[i] = a.x[i]; }
    void mem(int len) { for (int i = 0; i < len; ++i) x[i] = 0; }
    void ntt(int w, int b) {
        int len = 1 << w;
        for (int i = 0; i < len; ++i) {
            rtt[i] = rtt[i >> 1] >> 1 | ((i & 1) << (w - 1));
            if (i < rtt[i]) swap(x[i], x[rtt[i]]);
        }
        for (int l = 2; l <= len; l <<= 1) {
            int m = l >> 1;
            long long omega = fsp(3, (mod - 1) / l);
            if (b) omega = fsp(omega, mod - 2);
            for (int i = 0; i < len; i += l) {
                long long tomega = 1;
                for (int j = i; j < i + m; ++j, (tomega *= omega) %= mod) {
                    long long t = tomega * x[j + m] % mod;
                    x[j + m] = (x[j] + mod - t) % mod;
                    x[j] = (x[j] + t) % mod;
                }
            }
        }
    }
} g1, g2, f, tmp1, tmp2;

Poly inversion(Poly &a, Poly &b, Poly &c, int n) {
    b.mem(2 * n);
    b.x[0] = fsp(a.x[0], mod - 2);
    for (int w = 1; (1 << (w - 1)) < n; ++w) {
        int len = 1 << w;
        c.cpy(a, len), c.ntt(w + 1, 0), b.ntt(w + 1, 0);
        for (int i = 0; i < (len << 1); ++i) 
            (b.x[i] *= mod + 2ll - b.x[i] * c.x[i] % mod) %= mod;
        b.ntt(w + 1, 1);
        long long ny = fsp(len << 1, mod - 2);
        for (int i = 0; i < len; ++i) (b.x[i] *= ny) %= mod;
        for (int i = len; i < (len << 1); ++i) b.x[i] = 0;
    }
    return b;
}

int main() {
    int n;
    scanf("%d", &n); n++;
    // 预处理阶乘逆元
    fiv[0] = fiv[1] = inv[0] = inv[1] = 1;
    for (int i = 2; i <= n; ++i) {
        inv[i] = mod - (mod / i) * inv[mod % i] % mod;
        fiv[i] = fiv[i - 1] * inv[i] % mod;
    }
    // 构造生成函数G(x)和H(x)
    g2.x[0] = 1;
    for (int i = 1; i < n; ++i) {
        long long tmp = fsp(2, 1ll * i * (i - 1) / 2 % (mod - 1));
        g1.x[i] = tmp * fiv[i - 1] % mod;  // H(x): g(n)/(n-1)!
        g2.x[i] = tmp * fiv[i] % mod;      // G(x): g(n)/n!
    }
    // 求G(x)的逆元
    g2 = inversion(g2, tmp1, tmp2, n);
    // 计算F(x) = H(x) * G^{-1}(x)
    int w = 0; while ((1 << w) < (n << 1)) w++;
    g1.ntt(w, 0), g2.ntt(w, 0);
    for (int i = 0; i <= (1 << w); ++i) f.x[i] = g1.x[i] * g2.x[i] % mod;
    f.ntt(w, 1);
    // 计算答案：f(n) = F(x)的n次项 * (n-1)!
    printf("%lld", fsp(inv[2], w) * f.x[n - 1] % mod * fsp(fiv[n - 2], mod - 2) % mod);
    return 0;
}
```
* **代码解读概要**：
  1. **预处理**：计算阶乘逆元`fiv`（用于生成函数的项转换）；
  2. **构造生成函数**：`g1`对应`H(x)`（`g(n)/(n-1)!`），`g2`对应`G(x)`（`g(n)/n!`）；
  3. **多项式求逆**：用`inversion`函数求`g2`的逆元（`G^{-1}(x)`）；
  4. **卷积计算**：用NTT计算`g1`和`g2逆`的卷积，得到`F(x)`；
  5. **结果转换**：将`F(x)`的n次项乘以`(n-1)!`，得到最终答案。


### 针对各优质题解的片段赏析

#### 题解一：多项式求逆的核心——`inversion`函数
* **亮点**：用迭代法实现多项式求逆，每一步翻倍逆元长度，保证正确性。
* **核心代码片段**：
```cpp
Poly inversion(Poly &a, Poly &b, Poly &c, int n) {
    b.mem(2 * n);
    b.x[0] = fsp(a.x[0], mod - 2);  // 初始逆元（长度1）
    for (int w = 1; (1 << (w - 1)) < n; ++w) {
        int len = 1 << w;
        c.cpy(a, len);  // 拷贝a的前len项
        c.ntt(w + 1, 0); b.ntt(w + 1, 0);  // NTT到点值域
        // 更新逆元：B = B*(2 - A*B)
        for (int i = 0; i < (len << 1); ++i) 
            (b.x[i] *= mod + 2ll - b.x[i] * c.x[i] % mod) %= mod;
        b.ntt(w + 1, 1);  // IDFT回系数域
        long long ny = fsp(len << 1, mod - 2);  // 逆元的归一化系数
        for (int i = 0; i < len; ++i) (b.x[i] *= ny) %= mod;
        for (int i = len; i < (len << 1); ++i) b.x[i] = 0;  // 截断长度
    }
    return b;
}
```
* **代码解读**：
  - 初始时，逆元`b`的长度为1，值为`a[0]`的逆元（因为单元素多项式的逆元就是其倒数）；
  - 每次迭代将逆元长度翻倍（从`len`到`2*len`），用`B = B*(2 - A*B)`更新逆元（这是多项式求逆的核心公式，来自泰勒展开）；
  - 用NTT将多项式转换为点值域，快速计算乘法，再用IDFT转换回系数域。
* 💡 **学习笔记**：多项式求逆的关键是“迭代更新+NTT加速”，记住公式`B = B*(2 - A*B)`就能写出模板！


#### 题解二：多项式对数的核心——`poly::ln`函数
* **亮点**：用“求导+求逆+积分”实现多项式对数，直接从`G(x)`得到`F(x)`。
* **核心代码片段**（简化版）：
```cpp
void ln(int *a, int *b, int n) {
    static int p[MAXN], q[MAXN];
    der(a, p, n);  // 求导：p = G’(x)
    inv(a, q, n);  // 求逆：q = G^{-1}(x)
    mul(p, q, b, n, n);  // 卷积：b = G’(x) * G^{-1}(x)
    itg(b, b, n);  // 积分：b = ∫ (G’/G) dx = ln G(x)
}
```
* **代码解读**：
  - 求导`der`：将多项式`G(x)`的系数`a[i]`变为`i*a[i]`（对应导数的幂次下降）；
  - 求逆`inv`：计算`G(x)`的逆元`G^{-1}(x)`；
  - 卷积`mul`：计算`G’(x) * G^{-1}(x)`（对应导数的商）；
  - 积分`itg`：将多项式`b[i]`变为`b[i]/(i+1)`（对应积分的幂次上升）。
* 💡 **学习笔记**：多项式对数的本质是“导数的逆操作”，适合处理“指数生成函数的连通性问题”！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家直观理解“生成函数卷积”和“多项式求逆”，Kay设计了一个**8位像素风的“生成函数实验室”**动画，融合了复古游戏元素：
</visualization_intro>

### 动画演示主题
**《小算的生成函数冒险》**：像素小人“小算”需要通过“卷积机器”和“求逆机器人”，从“非连通图的生成函数”中提取“连通图的生成函数”。

### 核心演示内容
1. **场景初始化**：
   - 屏幕左侧是“生成函数陈列柜”，用不同颜色的像素块展示`G(x)`（红色，`g(n)/n!`）、`H(x)`（蓝色，`g(n)/(n-1)!`）、`F(x)`（绿色，`f(n)/(n-1)!`）的系数；
   - 屏幕右侧是“卷积机器”（复古打字机风格）和“求逆机器人”（像素机器人形象）；
   - 背景音乐：8位风格的《卡农》，营造轻松的学习氛围。

2. **生成函数构造**：
   - “小算”点击“生成G(x)”按钮，陈列柜中的红色块逐渐出现（对应`g(n)/n!`的计算）；
   - 点击“生成H(x)”按钮，蓝色块出现（对应`g(n)/(n-1)!`的计算）；
   - 每出现一个块，下方的文字气泡提示：“这是G(x)的第i项，值为g(i)/i! = 2^(i*(i-1)/2) / i!”。

3. **多项式求逆**：
   - “小算”将`G(x)`拖入“求逆机器人”，机器人开始迭代更新：
     - 第1步：机器人展示红色块（`G(x)`的第0项），计算其逆元（绿色块，值为`1/G(0)`）；
     - 第2步：机器人展示前2项红色块，用公式`B = B*(2 - A*B)`更新绿色块（逆元的前2项）；
     - 每一步迭代，机器人都会闪烁并播放“滴~”的音效，文字气泡提示：“当前逆元长度：2^w”；
   - 当逆元收敛到正确长度时，机器人播放“胜利”音效，绿色块停止更新（对应`G^{-1}(x)`）。

4. **卷积计算**：
   - “小算”将`H(x)`（蓝色块）和`G^{-1}(x)`（绿色块）拖入“卷积机器”，机器开始转动：
     - 机器将蓝色块和绿色块的对应项“相乘”（颜色叠加为青色），再“相加”（合并为绿色块）；
     - 每完成一个项的计算，机器播放“叮~”的音效，文字气泡提示：“F(x)的第i项 = sum_{k=0}^i H(k) * G^{-1}(i-k)”；
   - 卷积完成后，陈列柜中的绿色块就是`F(x)`的系数，文字气泡提示：“F(x)的第n项就是f(n)/(n-1)!，乘以(n-1)!就是答案！”。

5. **结果展示**：
   - 屏幕中央弹出“答案窗口”，显示最终结果（如输入3时输出4），并播放“欢呼”音效；
   - 点击“重置”按钮，动画回到初始状态，方便重新观看。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
生成函数和多项式操作是组合计数的“瑞士军刀”，掌握它们能解决很多类似问题。以下是几个拓展方向：
</similar_problems_intro>

### 通用思路迁移
- **问题1**：求n个点的有标号树数目（Cayley公式）——生成函数为`T(x) = x*e^{T(x)}`，用多项式对数求解；
- **问题2**：求n个点的有标号连通二分图数目——类似本题，先算非连通二分图，再用生成函数逆推；
- **问题3**：求n个元素的划分方式数目（Bell数）——生成函数为`e^{e^x - 1}`，用多项式指数求解。

### 洛谷练习推荐
1. **洛谷 P4721** - 【模板】分治FFT  
   🗣️ **推荐理由**：练习分治FFT，理解“递推式转卷积”的基础方法，是本题的前置练习。
2. **洛谷 P5488** - 【模板】多项式求逆  
   🗣️ **推荐理由**：直接练习多项式求逆的模板，掌握迭代法的实现细节。
3. **洛谷 P5383** - 【模板】多项式对数函数  
   🗣️ **推荐理由**：练习多项式对数的实现，理解“求导+求逆+积分”的流程。
4. **洛谷 P3723** - 「AH2017/HNOI2017」礼物  
   🗣️ **推荐理由**：用NTT解决实际问题，理解“卷积在组合计数中的应用”。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我们可以学到一些宝贵的“踩坑经验”：
</insights_intro>

> **参考经验（来自Kinandra）**：“我最初在计算`g(n)`时，直接用`pow(2, n*(n-1)/2)`导致溢出，后来发现可以用欧拉定理对指数取模（`mod-1`），因为模数是质数。”  
> **点评**：这个经验很重要！当计算`a^b mod p`（p是质数）时，若a和p互质，可以用欧拉定理将指数模`p-1`，避免计算大数。本题中`2`和`1004535809`互质，所以`2^{n*(n-1)/2} mod mod = 2^{(n*(n-1)/2) mod (mod-1)} mod mod`。


<conclusion>
这道题的难点在于“将组合计数转化为生成函数”，但只要掌握了生成函数的基本思想和多项式操作的模板，就能迎刃而解。记住：**生成函数是“数列的代数包装”，多项式操作是“包装的工具”**，核心还是“子问题的组合”。  

下次遇到计数问题时，不妨想想：“能不能用生成函数把问题打包成多项式？” 坚持练习，你会发现这些“高级技巧”其实一点都不高冷！💪
</conclusion>

---
处理用时：156.79秒
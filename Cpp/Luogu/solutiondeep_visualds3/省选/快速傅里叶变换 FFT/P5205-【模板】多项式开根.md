# 题目信息

# 【模板】多项式开根

## 题目背景

模板题，无背景

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个在 ${} \bmod x^n$ 意义下的多项式 $B(x)$，使得 $B^2(x) \equiv A(x) \pmod{x^n}$。若有多解，请取零次项系数较小的作为答案。

多项式的系数在 ${}\bmod 998244353$ 的意义下进行运算。

## 说明/提示

对于 $100 \%$ 的数据：$1 \le n \leq 10^5$，$0 \le a_i < 998244353$。

## 样例 #1

### 输入

```
3
1 2 1
```

### 输出

```
1 1 0
```

## 样例 #2

### 输入

```
7
1 8596489 489489 4894 1564 489 35789489  
```

### 输出

```
1 503420421 924499237 13354513 217017417 707895465 411020414
```

# AI分析结果

# 💡 Kay的C++算法解析：多项式开根 深入学习指南 💡

今天我们来一起分析“多项式开根”这道经典的C++模板题。多项式操作是算法竞赛中的“高级工具”，掌握它能帮我们解决很多复杂的数学问题。本指南会帮你梳理核心思路、拆解难点，还会用像素动画让你“看”到算法运行的过程！


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：多项式操作（牛顿迭代 + 多项式求逆 + NTT）

🗣️ **初步分析**：
解决“多项式开根”，关键是用**牛顿迭代法**逐步提升解的精度——就像猜数字游戏：比如要猜√4，第一次猜1，用公式`(1 + 4/1)/2=2.5`改进，再用`(2.5 + 4/2.5)/2=2.05`，慢慢逼近正确值2。多项式开根也是一样：我们要找`B(x)`使得`B²≡A(x) mod xⁿ`，先求低精度的`B₀(x)`（比如`mod x¹`），再用公式`B(x) = (B₀² + A)/(2B₀)`算出更高精度的`B(x)`（比如`mod x²`），直到满足`mod xⁿ`的要求。

这个过程需要两个“工具”：
- **NTT（快速数论变换）**：快速计算多项式乘法（相当于“多项式的乘法器”）；
- **多项式求逆**：计算`1/(2B₀)`（相当于“多项式的除法”）。

**核心流程**：
1. 初始时，`B₀(x)`的0次项是`√A₀`（本题中`A₀=1`，所以`B₀(0)=1`）；
2. 倍增迭代：每次把精度从`len`提升到`2len`，用公式`B = (B₀² + A) * inv(2B₀) mod x²len`；
3. 直到精度达到`n`，输出`B(x)`。

**可视化设计思路**：
我们会用8位像素风格展示多项式系数数组（比如`B`的系数是一排彩色小方块，颜色越深值越大）。每次迭代时：
- 高亮`B₀`的系数（蓝色），计算`B₀²`（方块闪烁表示相乘）；
- 叠加`A`的系数（红色），得到`B₀² + A`（方块变色）；
- 计算`inv(2B₀)`（方块旋转表示求逆），再与前面的结果相乘（方块移动合并）；
- 最后更新`B`的系数（绿色），表示精度提升。
还会加“叮”的音效（每次NTT操作）、“咻”的音效（求逆完成），让你“听”到算法的节奏！


## 2. 精选优质题解参考

为了帮你快速掌握，我筛选了**思路清晰、代码规范、注释详细**的3道题解：

### 题解一：Owen_codeisking（赞36）
* **点评**：这份题解堪称“模板标杆”！思路上严格遵循牛顿迭代的倍增流程，公式推导简洁明了；代码结构非常清晰——把NTT、求逆、开根分别写成独立函数，变量命名（比如`f`存原多项式、`g`存结果）一看就懂。特别是**边界处理**很严谨（比如每次迭代后清空多余系数），直接复制到竞赛中也能运行。作者还贴心地写了`inv2`（1/2 mod 998244353），避免了重复计算，细节满分！

### 题解二：CYJian（赞16）
* **点评**：这道题解的**推导过程超级友好**！作者用泰勒展开解释牛顿迭代的由来，把“为什么用这个公式”讲得明明白白——比如为什么`(f_t - f_{t-1})²`会被模掉，为什么能简化成线性项。代码实现上，`Mul`（多项式乘法）、`GetNi`（求逆）、`Sqrt`（开根）的分工很明确，适合刚学多项式的同学一步步跟着写。作者还加了“浅谈多项式”的链接，帮你补全前置知识，很贴心！

### 题解三：Gauss0320（赞6）
* **点评**：这份题解的代码**极度简洁**！比如`NTT`函数里用`add`函数处理模运算，避免了负数；`Inv`函数里直接复用`A`、`B`数组，减少了内存开销。虽然注释少，但逻辑链很完整——从牛顿迭代公式到代码实现，每一步都对应得很准。适合想练“简洁代码”的同学参考！


## 3. 核心难点辨析与解题策略

多项式开根的难点集中在**“理解原理”和“实现工具”**上，我帮你总结了3个核心问题及解决方法：

### 1. 关键点1：牛顿迭代的公式怎么来的？
* **分析**：牛顿迭代是“用切线逼近根”的方法。对于多项式`G(B)=B² - A`，我们要找`G(B)=0`的解。假设已有低精度解`B₀`，那么切线方程是`G(B) ≈ G(B₀) + G’(B₀)(B - B₀)`。令右边为0，解得`B = B₀ - G(B₀)/G’(B₀)`。代入`G(B)=B²-A`和`G’(B)=2B`，就得到`B=(B₀² + A)/(2B₀)`！
* 💡 **学习笔记**：牛顿迭代的核心是“用线性近似替代非线性函数”，记住这个推导过程，就不用死记公式啦！

### 2. 关键点2：多项式求逆怎么实现？
* **分析**：多项式求逆是开根的基础——要算`inv(2B₀)`，就得先会求`inv(B₀)`。求逆的思路也是倍增：先求`inv(B₀) mod x¹`，再用公式`inv(B) = 2*inv(B₀) - B₀*inv(B₀)² mod x²`逐步提升精度。本质上还是牛顿迭代（把求逆转化为解`B*inv(B)-1=0`）。
* 💡 **学习笔记**：多项式求逆和开根的“倍增框架”是一样的，学会一个就能迁移到另一个！

### 3. 关键点3：NTT怎么不写错？
* **分析**：NTT的易错点有三个：
  1. **蝴蝶操作**：`rev`数组（反转位）的计算要正确（比如`rev[i] = (rev[i>>1]>>1) | ((i&1)?len:0)`）；
  2. **模数处理**：乘法后要取模，减法要加`mod`再取模；
  3. **逆变换**：最后要乘以`inv(n)`（`n`是NTT的长度）。
* 💡 **学习笔记**：写NTT时，可以先复制模板，再逐行验证——比如用小例子（比如`(1+x)*(1+x)`）测试，确保结果正确！

### ✨ 解题技巧总结
- **框架优先**：先写好NTT、求逆的模板，再套牛顿迭代的公式，避免“从头造轮子”；
- **精度控制**：每次迭代的长度要取2的幂（比如`len`从1开始，每次乘2），确保NTT能正确运行；
- **边界检查**：迭代后要清空多余的系数（比如`for(int i=len; i<lim; i++) b[i]=0;`），避免干扰下一次计算。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码综合了Owen_codeisking和Gauss0320的思路，保留了最核心的NTT、求逆、开根函数，结构清晰，适合入门。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int maxn = 4e5 + 10;
const int mod = 998244353;
const int inv2 = 499122177; // 1/2 mod 998244353
int n, f[maxn], g[maxn], A[maxn], B[maxn], r[maxn];

inline int read() { /* 快读函数，省略实现 */ }
int fpow(int a, int b) { /* 快速幂，省略实现 */ }

void NTT(int* a, int n, int op) {
    for (int i = 0; i < n; i++) if (i < r[i]) swap(a[i], a[r[i]]);
    for (int len = 1; len < n; len <<= 1) {
        int tmp = fpow(3, (mod - 1) / (len << 1));
        if (op == -1) tmp = fpow(tmp, mod - 2);
        for (int i = 0; i < n; i += len << 1) {
            int buf = 1;
            for (int j = 0; j < len; j++) {
                int x = a[i+j], y = 1LL * buf * a[i+j+len] % mod;
                a[i+j] = (x + y) % mod;
                a[i+j+len] = (x - y + mod) % mod;
                buf = 1LL * buf * tmp % mod;
            }
        }
    }
    if (op == -1) {
        int invn = fpow(n, mod - 2);
        for (int i = 0; i < n; i++) a[i] = 1LL * a[i] * invn % mod;
    }
}

void Inv(int* a, int* b, int n) {
    b[0] = fpow(a[0], mod - 2);
    int len, lim;
    for (len = 1; len < (n << 1); len <<= 1) {
        lim = len << 1;
        memcpy(A, a, len * sizeof(int)); memset(A + len, 0, len * sizeof(int));
        memcpy(B, b, len * sizeof(int)); memset(B + len, 0, len * sizeof(int));
        for (int i = 0; i < lim; i++) r[i] = (r[i>>1]>>1) | ((i&1) ? len : 0);
        NTT(A, lim, 1); NTT(B, lim, 1);
        for (int i = 0; i < lim; i++) b[i] = 1LL * (2 - 1LL * A[i] * B[i] % mod + mod) * B[i] % mod;
        NTT(b, lim, -1);
        memset(b + len, 0, len * sizeof(int));
    }
}

void Sqrt(int* a, int* b, int n) {
    b[0] = 1; // A[0] = 1，所以B[0] = 1
    int len, lim;
    for (len = 1; len < (n << 1); len <<= 1) {
        lim = len << 1;
        memcpy(A, a, len * sizeof(int)); memset(A + len, 0, len * sizeof(int));
        static int tmp[maxn];
        Inv(b, tmp, len); // 求b的逆
        for (int i = 0; i < lim; i++) r[i] = (r[i>>1]>>1) | ((i&1) ? len : 0);
        NTT(A, lim, 1); NTT(tmp, lim, 1);
        for (int i = 0; i < lim; i++) A[i] = 1LL * A[i] * tmp[i] % mod;
        NTT(A, lim, -1);
        for (int i = 0; i < len; i++) b[i] = 1LL * (b[i] + A[i]) % mod * inv2 % mod;
        memset(b + len, 0, len * sizeof(int));
    }
}

int main() {
    n = read();
    for (int i = 0; i < n; i++) f[i] = read();
    Sqrt(f, g, n);
    for (int i = 0; i < n; i++) printf("%d ", g[i]);
    return 0;
}
```
* **代码解读概要**：
  1. **NTT函数**：实现快速数论变换，`op=1`是正变换，`op=-1`是逆变换；
  2. **Inv函数**：用倍增法求多项式的逆；
  3. **Sqrt函数**：核心开根逻辑，每次迭代用`(B₀² + A) * inv(2B₀)`更新B；
  4. **主函数**：读取输入，调用Sqrt，输出结果。


### 题解一（Owen_codeisking）核心片段赏析
* **亮点**：`Sqrt`函数中**清晰的迭代流程**，把“复制A→求逆→NTT相乘→更新B”的步骤写得一目了然。
* **核心代码片段**：
```cpp
void Sqrt(int *a,int *b,int n){
    b[0]=1;
    int *A=C,*B=D,len,lim;
    for(len=1;len<(n<<1);len<<=1){
        lim=len<<1;
        for(int i=0;i<len;i++) A[i]=a[i];
        Inv(b,B,lim>>1); // 求b的逆，长度是lim>>1
        for(int i=0;i<lim;i++) r[i]=(r[i>>1]>>1)|((i&1)?len:0);
        NTT(A,lim,1);NTT(B,lim,1);
        for(int i=0;i<lim;i++) A[i]=1ll*A[i]*B[i]%mod;
        NTT(A,lim,-1);
        for(int i=0;i<len;i++) b[i]=1ll*(b[i]+A[i])%mod*inv2%mod;
        for(int i=len;i<lim;i++) b[i]=0;
    }
}
```
* **代码解读**：
  - 第1行：初始化`b[0]=1`（因为`A[0]=1`，平方根是1）；
  - 第4行：`len`从1开始倍增，每次处理`mod x^len`的情况；
  - 第6行：把原多项式`a`复制到`A`（要计算`A * inv(b)`）；
  - 第7行：调用`Inv`求`b`的逆（即`1/b`）；
  - 第8-11行：用NTT计算`A * inv(b)`（也就是`A / b`）；
  - 第12行：用公式`b = (b + A*inv(b)) * inv2`更新`b`（对应`(B₀² + A)/(2B₀)`？不对，等一下——其实`A`是原多项式，`b`是`B₀`，所以`A*inv(b)`是`A/B₀`，加上`B₀`后乘以`inv2`，就是`(B₀ + A/B₀)/2 = (B₀² + A)/(2B₀)`，对！）；
  - 第13行：清空`b`的多余系数，避免干扰下一次迭代。
* 💡 **学习笔记**：`Sqrt`函数的核心就是“倍增+公式应用”，只要把`Inv`和`NTT`写对，这部分就不会错！


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：“像素多项式的平方根冒险”
我们用**8位红白机风格**（比如《超级马里奥》的像素块）展示多项式开根的过程，让你像玩游戏一样学算法！


### 核心演示内容与设计思路
#### 1. 场景初始化（8位像素风）
- **画布**：左侧是“多项式系数区”（一排16x16的像素块，代表`B`的系数，颜色从浅蓝到深红表示值的大小）；
- **右侧**：“控制面板”（有“开始/暂停”“单步”“重置”按钮，速度滑块）；
- **背景音乐**：循环播放《坦克大战》的8位BGM，营造复古氛围。

#### 2. 算法启动：初始状态
- `B`的0次项是1（深红色方块），其他项是0（浅蓝色）；
- 原多项式`A`的系数用绿色方块显示在下方（比如样例1的`A=[1,2,1]`，对应三个绿色方块）。

#### 3. 迭代过程：逐步提升精度
以**样例1（n=3）**为例，展示第一次迭代（从`len=1`到`len=2`）：
1. **步骤1：计算`B₀²`**：
   - 高亮`B`的0次项（深红），播放“叮”的音效；
   - 用NTT计算`B₀*B₀`，结果是`[1, 0, 0]`（方块闪烁后变成浅红）；
2. **步骤2：加上`A`**：
   - 叠加`A`的系数（绿色），得到`[1+1, 0+2, 0+1] = [2,2,1]`（方块变成紫粉色）；
3. **步骤3：求`inv(2B₀)`**：
   - `2B₀`是`[2,0,0]`，求逆后是`[499122177, 0, 0]`（方块旋转并变成黄色）；
4. **步骤4：相乘得到新`B`**：
   - 用NTT计算`(B₀² + A) * inv(2B₀)`，结果是`[1,1,0]`（方块变成亮绿色）；
   - 播放“咻”的音效，表示迭代完成！

#### 4. 交互与游戏化元素
- **单步模式**：点击“下一步”，逐帧看每一步的变化，适合慢学；
- **自动模式**：滑块调整速度（1x到5x），算法像“自动马里奥”一样跑完全程；
- **胜利时刻**：当精度达到`n=3`时，所有`B`的系数（`[1,1,0]`）闪烁，播放《魂斗罗》的胜利音效，屏幕弹出“通关！”的像素字！


## 6. 拓展练习与相似问题思考

### 通用思路迁移
多项式开根的**牛顿迭代框架**还能用来解决：
1. **多项式求逆**：解`B*A ≡ 1 mod xⁿ`；
2. **多项式对数**：解`ln(A) = ∫(A’/A) dx`；
3. **多项式指数**：解`exp(A) = 1 + A + A²/2! + A³/3! + ...`。

### 洛谷练习推荐
1. **洛谷 P4238** - 多项式乘法逆元  
   🗣️ **推荐理由**：练会多项式求逆，才能搞定开根！这道题是求逆的模板，帮你巩固“倍增+NTT”的框架。
2. **洛谷 P4245** - 多项式开根（本题原题）  
   🗣️ **推荐理由**：直接练原题，测试你对公式和代码的掌握程度。
3. **洛谷 P4725** - 多项式对数函数  
   🗣️ **推荐理由**：用开根的“求逆+NTT”思路，拓展到对数函数，帮你迁移知识。
4. **洛谷 P4726** - 多项式指数函数  
   🗣️ **推荐理由**：用牛顿迭代求指数，进一步熟悉“线性近似”的思想。


## 7. 学习心得与经验分享

### 参考经验（来自Owen_codeisking）
> “看到新模板，过来做一下。前置知识是多项式求逆 + NTT。”

**点评**：作者的这句话点出了多项式开根的核心——**基础要牢**！如果没学过求逆和NTT，直接看开根会像“看天书”。建议你先练熟求逆，再攻开根，循序渐进。

### 参考经验（来自CYJian）
> “我在推导的时候，一开始没理解为什么`(f_t - f_{t-1})²`会被模掉，后来画了个多项式的系数表，才明白高次项会被忽略！”

**点评**：作者的“画图法”很有用！多项式的高次项模`x^n`后会消失，用表格列出来（比如`x²`模`x¹`是0），就能直观理解为什么能简化泰勒展开。


## 总结
多项式开根的核心是**牛顿迭代的倍增思路**，加上**NTT和求逆的工具支持**。记住“猜数字”的比喻，多写几遍模板，再用像素动画看过程，你一定能掌握！

下次我们会分析更复杂的多项式操作（比如指数函数），继续加油哦！💪

---
处理用时：118.13秒
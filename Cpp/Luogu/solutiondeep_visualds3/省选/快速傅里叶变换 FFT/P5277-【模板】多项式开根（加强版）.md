# 题目信息

# 【模板】多项式开根（加强版）

## 题目背景

模板题，无背景

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$ ，求一个在 $\bmod\ {x^n}$ 意义下的多项式 $B(x)$ ，使得 $B^2(x)\equiv A(x)\pmod {x^n}$。

多项式的系数在 $\bmod\ 998244353$ 的意义下进行运算。

## 说明/提示

对于$25\%$的数据，有$n \leq 1000$

对于$50\%$的数据，有$n \leq 10^4$

对于$75\%$的数据，有$n \leq 5\times 10^4$

对于$100\%$的数据，有$n \leq 10^5,a_i \in [0,998244352] \cap \mathbb{Z}$

## 样例 #1

### 输入

```
3
1 2 1
```

### 输出

```
1 1 0```

## 样例 #2

### 输入

```
7
1 8596489 489489 4894 1564 489 35789489  
```

### 输出

```
1 503420421 924499237 13354513 217017417 707895465 411020414
```

# AI分析结果

---
# 💡 Kay的C++算法解析：【模板】多项式开根（加强版）深入学习指南 💡

<introduction>
  今天我们来一起分析「多项式开根（加强版）」这道C++模板题。它是多项式运算的核心题型之一，需要结合**二次剩余**、**多项式求逆**、**牛顿迭代**等知识。本指南将帮你梳理思路、理解核心算法，并掌握解题技巧~
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：多项式开根（依赖多项式求逆、NTT、二次剩余）

🗣️ **初步分析**：
解决多项式开根问题，本质是找到多项式 $B(x)$，使得 $B^2(x) \equiv A(x) \pmod{x^n}$（系数模998244353）。就像给数字开平方一样，多项式开根需要**从低次到高次逐步逼近**——这就是**牛顿迭代法**的核心思想：先求模 $x^1$ 的解（常数项开根），再通过递推式扩展到模 $x^2, x^4, \dots, x^n$ 的解。

- **核心思路**：  
  设当前已求得模 $x^k$ 的解 $B_0(x)$，要扩展到模 $x^{2k}$ 的解 $B(x)$，根据牛顿迭代推导得递推式：  
  $$B(x) = \frac{1}{2} \left( B_0(x) + \frac{A(x)}{B_0(x)} \right) \pmod{x^{2k}}$$  
  其中 $\frac{A(x)}{B_0(x)}$ 是多项式求逆（即求 $B_0(x)$ 的逆元多项式）。

- **核心难点**：  
  1. 常数项的**二次剩余**（求 $B(0)^2 \equiv A(0) \pmod{998244353}$）；  
  2. 多项式求逆的正确实现（牛顿迭代的基础）；  
  3. 牛顿迭代递推式的代码转化。

- **可视化设计思路**：  
  用**8位像素风**展示牛顿迭代的「倍增过程」：  
  - 初始时，屏幕中央显示常数项 $A(0)$，用像素块标记其二次剩余解 $B(0)$（比如黄色块）；  
  - 每一步倍增时，左侧显示当前 $B_0(x)$ 的系数数组（蓝色块），右侧显示 $A(x)/B_0(x)$ 的结果（红色块），中间计算 $(B_0 + A/B_0)/2$（绿色块）；  
  - 关键操作（如多项式乘法、求逆）触发**像素音效**（比如乘法是“叮”，求逆是“滴”），完成一次倍增时播放“升级”音效；  
  - 控制面板支持「单步执行」「自动播放」（速度可调），帮助你逐帧观察系数变化。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了以下优质题解，帮你快速掌握核心解法~
</eval_intro>

**题解一：牛顿迭代法（来源：SSerxhs 解法二）**
* **点评**：  
  此题解直接采用牛顿迭代的核心递推式，思路直白且代码完整。它先通过Cipolla算法求常数项的二次剩余，再用多项式求逆实现递推式。代码中`polysqrt`函数清晰展示了“倍增→求逆→计算新解”的流程，变量命名（如`sqrtf`存储A(x)，`sqrtg`存储B0的逆）易于理解。边界处理（如常数项开根后的验证）体现了严谨性，是多项式开根的标准实现。

**题解二：Cipolla+牛顿迭代（来源：Vocalise P5277题解）**
* **点评**：  
  此题解完美分离了「二次剩余」和「多项式开根」的逻辑：用Cipolla算法解决常数项开根，再用牛顿迭代处理多项式部分。代码中的`Cipolla`函数实现了模意义下的二次剩余求解，`Sqrt`函数则严格按照递推式编写，结构清晰。特别适合新手学习——先掌握二次剩余，再扩展到多项式。

**题解三：ln+exp法（来源：周道_Althen 题解）**
* **点评**：  
  此题解提供了另一种思路：利用多项式的对数（ln）和指数（exp）将开根转化为幂运算（$\sqrt{A} = A^{1/2}$）。它先通过BSGS求原根的指标，再计算常数项的二次剩余，最后用`Log`和`Exp`函数完成幂运算。这种方法拓展性强（可求任意次根），但需要掌握更多多项式运算模板，适合进阶学习者。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
多项式开根的难点集中在「二次剩余」「多项式求逆」和「牛顿迭代递推」，以下是针对性的解决策略：
</difficulty_intro>

1. **难点1：常数项的二次剩余**  
   * **分析**：要求 $B(0)^2 \equiv A(0) \pmod{998244353}$，常用**Cipolla算法**或**BSGS+原根**解决。Cipolla算法的核心是随机找一个数 $a$，使得 $a^2 - A(0)$ 是二次非剩余，再通过“复数”运算求根；BSGS法则利用原根3，将 $A(0)$ 表示为 $3^t$，则解为 $3^{t/2}$。  
   * 💡 **学习笔记**：二次剩余是多项式开根的“起点”，必须先解决常数项才能扩展到高次。

2. **难点2：多项式求逆**  
   * **分析**：多项式求逆是牛顿迭代的基础，用于计算 $\frac{A(x)}{B_0(x)}$。其核心思想也是倍增：先求模 $x^1$ 的逆（常数项的逆元），再递推到高次，递推式为 $B(x) = B_0(x) \times (2 - A(x) \times B_0(x)) \pmod{x^{2k}}$。  
   * 💡 **学习笔记**：多项式求逆的代码模板要牢记，它是多项式运算的“基石”。

3. **难点3：牛顿迭代递推式的实现**  
   * **分析**：递推式 $B(x) = \frac{1}{2} (B_0(x) + A(x)/B_0(x))$ 需要转化为代码：先求 $B_0$ 的逆，再与 $A$ 相乘，最后与 $B_0$ 相加并乘以 $1/2$（即模998244353的逆元499122177）。  
   * 💡 **学习笔记**：递推式的每一步都要对应多项式运算（乘法、加法、取模），注意数组的大小和初始化。

### ✨ 解题技巧总结
- **技巧1：模板化处理**：多项式求逆、NTT、Cipolla等都是模板，提前写好并测试正确性，避免重复造轮子。  
- **技巧2：模运算细节**：所有运算都要取模，负数要加模后再取模（如`(a - b + mod) % mod`）。  
- **技巧3：数组大小控制**：多项式运算时，数组大小要取2的幂次（NTT的要求），避免越界。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**牛顿迭代+Cipolla**的通用实现，它覆盖了题目所有要求，逻辑清晰~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合Vocalise和ikka的题解，包含Cipolla算法和牛顿迭代的多项式开根，是标准模板。
* **完整核心代码**：
  ```cpp
  #include <cstdio>
  #include <cstring>
  #include <ctime>
  #include <cstdlib>
  #include <algorithm>
  using namespace std;

  typedef long long ll;
  const int MOD = 998244353;
  const int G = 3;          // 原根
  const int INV2 = 499122177; // 1/2 mod MOD
  const int MAXN = 400010;

  // 快速幂
  ll qpow(ll a, ll b) {
      ll res = 1;
      while (b) {
          if (b & 1) res = res * a % MOD;
          a = a * a % MOD;
          b >>= 1;
      }
      return res;
  }

  // Cipolla算法求二次剩余
  ll w; // 虚数单位的平方
  struct Complex {
      ll x, y;
      Complex(ll x=0, ll y=0) : x(x), y(y) {}
      Complex operator*(const Complex& rhs) const {
          return Complex(
              (x * rhs.x % MOD + w * y % MOD * rhs.y % MOD) % MOD,
              (x * rhs.y % MOD + y * rhs.x % MOD) % MOD
          );
      }
  };

  ll cipolla(ll n) {
      srand(time(0));
      if (qpow(n, (MOD-1)/2) == MOD-1) return -1; // 无解
      while (true) {
          ll a = rand() % MOD;
          w = (a * a % MOD - n + MOD) % MOD;
          if (qpow(w, (MOD-1)/2) == MOD-1) { // 找到非剩余
              Complex res(a, 1);
              res = qpow(res, (MOD+1)/2); // 快速幂（重载）
              return min(res.x, MOD - res.x);
          }
      }
  }

  // NTT相关
  int r[MAXN];
  void ntt(ll* a, int n, bool inv) {
      for (int i=0; i<n; i++) if (i < r[i]) swap(a[i], a[r[i]]);
      for (int i=1; i<n; i<<=1) {
          ll wn = qpow(G, (MOD-1)/(i<<1));
          if (inv) wn = qpow(wn, MOD-2);
          for (int j=0; j<n; j+=i<<1) {
              ll w = 1;
              for (int k=0; k<i; k++, w=w*wn%MOD) {
                  ll x = a[j+k], y = w*a[j+k+i]%MOD;
                  a[j+k] = (x + y) % MOD;
                  a[j+k+i] = (x - y + MOD) % MOD;
              }
          }
      }
      if (inv) {
          ll inv_n = qpow(n, MOD-2);
          for (int i=0; i<n; i++) a[i] = a[i] * inv_n % MOD;
      }
  }

  // 多项式求逆：a的逆元存在b中，长度为n
  void poly_inv(ll* a, ll* b, int n) {
      if (n == 1) { b[0] = qpow(a[0], MOD-2); return; }
      poly_inv(a, b, (n+1)/2);
      int len = 1;
      while (len < n*2) len <<=1;
      for (int i=1; i<len; i++) r[i] = (r[i>>1]>>1) | ((i&1) ? len/2 : 0);
      ll* tmp = new ll[len];
      memcpy(tmp, a, n*sizeof(ll));
      memset(tmp + n, 0, (len - n)*sizeof(ll));
      ntt(tmp, len, false);
      ntt(b, len, false);
      for (int i=0; i<len; i++) b[i] = b[i] * (2 - tmp[i] * b[i] % MOD + MOD) % MOD;
      ntt(b, len, true);
      memset(b + n, 0, (len - n)*sizeof(ll));
      delete[] tmp;
  }

  // 多项式开根：a的平方根存在b中，长度为n
  void poly_sqrt(ll* a, ll* b, int n) {
      if (n == 1) { b[0] = cipolla(a[0]); return; }
      poly_sqrt(a, b, (n+1)/2);
      int len = 1;
      while (len < n*2) len <<=1;
      ll* inv_b = new ll[len];
      memset(inv_b, 0, len*sizeof(ll));
      poly_inv(b, inv_b, n); // 求b的逆元
      ll* tmp = new ll[len];
      memcpy(tmp, a, n*sizeof(ll));
      memset(tmp + n, 0, (len - n)*sizeof(ll));
      // 计算 tmp = a * inv_b
      ntt(tmp, len, false);
      ntt(inv_b, len, false);
      for (int i=0; i<len; i++) tmp[i] = tmp[i] * inv_b[i] % MOD;
      ntt(tmp, len, true);
      // 计算 b = (b + tmp) * INV2
      for (int i=0; i<n; i++) b[i] = (b[i] + tmp[i]) % MOD * INV2 % MOD;
      delete[] inv_b;
      delete[] tmp;
  }

  ll a[MAXN], b[MAXN];
  int main() {
      int n;
      scanf("%d", &n);
      for (int i=0; i<n; i++) scanf("%lld", &a[i]);
      poly_sqrt(a, b, n);
      for (int i=0; i<n; i++) printf("%lld ", b[i]);
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **Cipolla算法**：解决常数项的二次剩余，通过随机数找到非剩余，用“复数”运算求根；  
  2. **NTT**：快速数论变换，用于多项式乘法（复杂度O(n log n)）；  
  3. **多项式求逆**：用牛顿迭代求逆元多项式，是开根的基础；  
  4. **多项式开根**：用牛顿迭代递推式，从低次到高次计算平方根。


<code_intro_selected>
接下来分析优质题解的核心片段，看看它们的亮点~
</code_intro_selected>

**题解一：SSerxhs 的 polysqrt 函数**
* **亮点**：直接对应牛顿迭代递推式，代码简洁。
* **核心代码片段**：
  ```cpp
  void polysqrt(int *f,int *g,int biglim) {
      memset(g,0,biglim<<3);
      g[0] = mosqrt(f[0]); // 常数项开根（类似Cipolla）
      for (int i=2; i<=biglim; i=limit,l++) {
          limit = i<<1;
          polyinv(g, sqrtg, i); // 求g的逆元
          memcpy(sqrtf, f, limit<<1);
          // 计算 (g² + f) * inv(2g) → 等价于 (g + f/g)/2
          dft(sqrtf,0,limit); dft(sqrtg,0,limit); dft(g,0,limit);
          for (j=0; j<limit; j++) {
              g[j] = (ll)sqrtg[j] * ((ll)g[j]*g[j]%p + sqrtf[j])%p;
              g[j] = (g[j] & 1) ? (g[j]+p)>>1 : g[j]>>1; // 乘以1/2
          }
          dft(g,i,limit);
      }
  }
  ```
* **代码解读**：  
  这段代码直接实现了递推式：先求当前解 $g$ 的逆元 `sqrtg`，再计算 $f/g$（`sqrtf * sqrtg`），最后将 $g$ 与 $f/g$ 相加并乘以1/2。其中`mosqrt`是二次剩余函数（类似Cipolla），`dft`是NTT变换。
* 💡 **学习笔记**：递推式的代码实现要严格对应数学公式，每一步的多项式运算都要通过NTT完成。

**题解二：Vocalise 的 Sqrt 函数**
* **亮点**：清晰分离了“求逆”和“递推”步骤，可读性强。
* **核心代码片段**：
  ```cpp
  void Sqrt(ll *a, ll *b, int n) {
      if (n == 1) { b[0] = Cipolla(a[0]); return; }
      Sqrt(a, b, (n+1)/2); // 递归求低次解
      memset(b1, 0, sizeof(b1));
      Inv(b, b1, n); // 求b的逆元
      // 计算 (b + a*inv(b)) * 1/2
      NTT(a1, N, 0); NTT(b, N, 0); NTT(b1, N, 0);
      for (int i=0; i<N; i++) b[i] = (b[i] + a1[i] * b1[i] % MOD) % MOD * inv2 % MOD;
      INTT(b, N);
  }
  ```
* **代码解读**：  
  递归求低次解后，先求逆元`b1`，再用NTT计算`a*inv(b)`，最后合并得到高次解。代码结构清晰，适合新手理解牛顿迭代的“递归+倍增”逻辑。
* 💡 **学习笔记**：递归实现牛顿迭代更直观，但要注意数组的大小和初始化。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解牛顿迭代的“倍增过程”，我设计了一个**8位像素风**的动画，像玩复古游戏一样看多项式开根~
</visualization_intro>

### 动画设计方案
#### **1. 整体风格**
- **像素风UI**：仿照FC红白机的画面，用16色像素块表示多项式系数（比如蓝色块代表当前解，红色块代表逆元，绿色块代表新解）；  
- **背景音乐**：循环播放8位风格的轻快BGM（比如《超级马里奥》的经典旋律）；  
- **音效**：  
  - 多项式乘法：“叮”（类似金币声）；  
  - 多项式求逆：“滴”（类似跳跃声）；  
  - 完成一次倍增：“噔”（类似升级声）；  
  - 最终完成：“胜利”音效（类似通关声）。

#### **2. 核心演示步骤**
以样例输入`3 1 2 1`（求 $1+2x+x^2$ 的平方根，结果为 $1+x$）为例：
1. **初始化**：屏幕中央显示常数项`1`，用黄色块标记。Cipolla算法求出其二次剩余`1`（蓝色块）。
2. **倍增到x²**：  
   - 左侧显示当前解 $B_0 = 1$（蓝色块）；  
   - 计算 $A/B_0 = 1+2x+x^2$（红色块）；  
   - 计算 $(B_0 + A/B_0)/2 = (1 + 1+2x+x^2)/2 = 1 + x + 0.5x^2$（模998244353下0.5是499122177，所以结果为 $1 + x$，绿色块）。
3. **倍增到x³**：  
   - 左侧显示当前解 $B_0 = 1 + x$（蓝色块）；  
   - 计算 $A/B_0 = (1+2x+x^2)/(1+x) = 1 + x$（红色块）；  
   - 计算 $(B_0 + A/B_0)/2 = (1+x + 1+x)/2 = 1 + x$（绿色块），完成！

#### **3. 交互设计**
- **控制面板**：包含「开始/暂停」「单步执行」「重置」按钮，以及速度滑块（从“慢”到“快”）；  
- **AI自动演示**：点击“自动”按钮，动画会自动完成所有倍增步骤，像“AI通关”一样展示全过程；  
- **信息提示**：每一步上方会出现文字气泡（比如“正在计算B0的逆元”“正在合并新解”），帮助理解当前操作。

<visualization_conclusion>
通过这个动画，你可以清晰看到多项式开根的“从小到大”过程——从常数项到一次项，再到二次项，每一步都在逼近最终解。像素风格和游戏音效让学习更有趣！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
多项式开根是多项式运算的基础，掌握它后可以解决更多复杂问题，比如多项式除法、开高次根等~
</similar_problems_intro>

### **通用思路迁移**
- **多项式开高次根**：将递推式改为 $B(x) = \frac{1}{k}((k-1)B_0(x) + \frac{A(x)}{B_0^{k-1}(x)})$（k是根次数）；  
- **多项式除法**：利用逆元将除法转化为乘法；  
- **生成函数应用**：比如求卡特兰数、斐波那契数的生成函数，常需要多项式开根。

### **练习推荐 (洛谷)**
1. **洛谷 P5205** - 【模板】多项式开根  
   🗣️ **推荐理由**：基础版多项式开根，常数项为1，适合入门练习。
2. **洛谷 P5273** - 【模板】多项式幂函数 (加强版)  
   🗣️ **推荐理由**：将开根转化为幂运算，拓展你的多项式运算能力。
3. **洛谷 P4238** - 【模板】多项式求逆  
   🗣️ **推荐理由**：多项式开根的前置知识，必须掌握！
4. **洛谷 P3803** - 【模板】多项式乘法（FFT/NTT）  
   🗣️ **推荐理由**：NTT是多项式运算的核心，巩固你的基础。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中提到的“踩坑”经验很有价值，帮你避免走弯路~
</insights_intro>

> **参考经验 (来自 Vocalise)**：  
> “随机数如果用`rand()`相乘会TLE，因为随机性太差。后来换成`time(0)`作为种子，解决了这个问题。”  
> **点评**：Cipolla算法的随机步骤需要足够的随机性，否则会重复尝试同一个a，导致超时。用`time(0)`作为种子可以提高随机性，避免这个问题。

> **参考经验 (来自 周道_Althen)**：  
> “最初用BSGS求原根时，结果总是WA，后来发现要取`min(ret, mod-ret)`，因为二次剩余有两个解。”  
> **点评**：二次剩余的解是成对出现的（比如x和mod-x），取较小的那个可以避免结果不一致的问题。


<conclusion>
多项式开根是多项式运算的“敲门砖”，掌握它需要熟悉**二次剩余**、**多项式求逆**和**牛顿迭代**。多写模板、多做练习，你会发现多项式运算其实很有趣！下次我们再一起探索更复杂的多项式问题~💪
</conclusion>

---

---
处理用时：140.20秒
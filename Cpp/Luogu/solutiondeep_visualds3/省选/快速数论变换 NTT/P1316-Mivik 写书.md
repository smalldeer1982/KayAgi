# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果

# 💡 Kay的C++算法解析：Mivik写书 深入学习指南 💡

## 一、前言
今天我们要解决的是**Mivik写书**问题——这道题看起来是关于字符串的，但核心其实是**组合计数与容斥原理**的应用！通过这道题，我们能学会如何将“期望问题”转化为“计数问题”，并用容斥巧妙解决重复计算的问题。


---

## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：组合计数 + 容斥原理
### 🗣️ 初步分析
#### 问题转化：从“期望”到“计数”
题目要求“随机字符串的期望不同子串数”。根据**期望的线性性**（无需变量独立！），我们可以把问题拆成：**所有可能的非空字符串t，其出现在随机字符串中的概率之和**。  
举个例子：比如字符串“aa”的不同子串是“a”“aa”，概率分别是1（肯定出现）和1/4（只有当字符串是“aa”时出现），所以期望是1 + 1/4 = 5/4？不对，等一下——哦不，正确的转化是：**每个子串t如果出现在原字符串中，就贡献1，否则贡献0。总期望等于所有t的出现概率之和**！  
比如样例1（n=2，m=2）：
- 长度1的子串有“a”“b”，每个出现的概率是3/4（除了全“b”或全“a”的情况）；
- 长度2的子串有“aa”“ab”“ba”“bb”，每个出现的概率是1/4；
- 总期望 = (3/4 + 3/4) + (1/4 + 1/4 + 1/4 + 1/4) = 5/2，和样例一致！

#### 核心难点：如何计算所有t的出现概率之和？
直接枚举所有t是不可能的（m可以到5e6），但我们可以**按子串长度分组计算**：对于每个长度l，计算所有长度为l的t的出现次数之和，再除以总字符串数mⁿ（期望=总和/mⁿ）。  
这里的关键是——**对于长度l，所有t的出现次数之和等于“所有长度为n的字符串中，长度为l的不同子串的总数之和”**（比如字符串“ab”有“a”“b”“ab”三个不同子串，贡献3）。

#### 容斥原理：解决重复计算
如何计算“所有字符串中长度为l的不同子串总数之和”？我们用**容斥**来避免重复：
- 对于每个长度l，枚举子串的**出现位置集合S**（比如S={1,3}表示子串出现在位置1和3）；
- 用**并查集**维护这些位置的字符约束（比如位置1和3的子串必须相同，所以对应位置的字符必须相等）；
- 计算满足约束的字符串数目（m^k，k是自由字符的数量），再根据S的大小奇偶性调整符号（奇加偶减）。


---

## 2. 精选优质题解参考

### 题解一：Huasushis的容斥+并查集解法（推荐指数：5星）
- **思路清晰性**：把问题拆解为“枚举子串长度→枚举出现位置→计算约束→容斥累加”，每一步都有明确的逻辑；
- **代码可读性**：变量名直观（比如`qp`是快速幂，`sol`处理每个长度l），并查集实现简洁；
- **算法有效性**：时间复杂度O(n²2ⁿ)，对于n=20完全够用；
- **实践价值**：边界处理严谨（比如模运算中的正负调整），直接可用于竞赛。

### 题解二：Reunite的入门容斥解法（推荐指数：4.5星）
- **亮点**：用`work`函数处理每个长度l，代码结构和Huasushis一致，但注释更详细，适合新手理解“并查集如何维护约束”；
- **小优化**：预处理`pw`数组存储m的幂次，避免重复计算。

### 题解三：rainygame的简洁实现（推荐指数：4星）
- **亮点**：代码极其简洁，用`__builtin_parity`快速判断二进制中1的个数奇偶性，适合学习“如何写短代码”；
- **注意**：变量`c`用于记录每个位置是否被约束，需要仔细理解。


---

## 3. 核心难点辨析与解题策略

### 1. 难点1：如何将“期望问题”转化为“计数问题”？
- **分析**：期望的线性性是关键！不管子串是否重叠，总期望等于每个子串出现概率之和。这一步转化让问题从“统计不同子串数”变成了“计算所有子串的出现次数之和”。
- 💡 学习笔记：遇到“期望”问题，先想能不能用线性性拆分成“每个元素的贡献之和”！

### 2. 难点2：如何用容斥处理重复计算？
- **分析**：直接计算“包含至少一个t的字符串数”会重复（比如字符串“aaa”包含“a”三次），所以用容斥：枚举所有可能的出现位置集合S，用“奇加偶减”抵消重复。
- 💡 学习笔记：容斥的核心是“用集合的交集来修正重复计数”，符号由集合大小的奇偶性决定！

### 3. 难点3：如何用并查集计算“自由字符数”？
- **分析**：当子串出现在多个位置时，对应位置的字符必须相等（比如位置1的子串是“ab”，位置2的子串也是“ab”，则位置1的字符=位置2的字符，位置2的字符=位置3的字符）。并查集可以把这些必须相等的位置合并成一个连通块，每个连通块只能选一个字符，所以自由字符数=连通块数+未被约束的位置数。
- 💡 学习笔记：并查集是处理“等价关系”的神器，比如“字符必须相等”就是一种等价关系！

### ✨ 解题技巧总结
1. **问题转化**：遇到期望问题先试线性性，拆成单个元素的贡献；
2. **容斥应用**：处理“至少一个”的计数问题，用容斥抵消重复；
3. **数据结构**：用并查集维护等价约束，快速计算连通块数；
4. **模运算**：预处理幂次和逆元，避免重复计算，注意正负调整。


---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合Huasushis和Reunite的思路，实现一个清晰的核心版本。
```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

ll qpow(ll x, ll y) { // 快速幂
    ll ans = 1;
    while (y) {
        if (y & 1) ans = ans * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return ans;
}

int fa[25];
int getfa(int x) { // 并查集查找
    return x == fa[x] ? x : fa[x] = getfa(fa[x]);
}

int main() {
    int n; ll m;
    cin >> n >> m;
    ll ans = 0;
    for (int l = 1; l <= n; ++l) { // 枚举子串长度l
        int maxS = 1 << (n - l + 1); // 出现位置的集合数（S的大小）
        for (int S = 1; S < maxS; ++S) { // 枚举非空集合S
            for (int i = 0; i < l; ++i) fa[i] = i; // 初始化并查集（子串的l个位置）
            int c = 0; // 当前窗口的约束状态
            int free = 0; // 未被约束的位置数
            int mask = (1 << l) - 1; // 窗口大小的掩码
            for (int j = 0; j < n; ++j) { // 遍历原字符串的每个位置j
                c = (c << 1) | ((S >> j) & 1); // 更新当前窗口的约束
                c &= mask; // 保持窗口大小为l
                if (!c) {
                    free++; // 该位置未被约束
                } else {
                    // 合并当前窗口中所有需要相等的位置
                    int first = getfa(__builtin_ctz(c)); // 第一个置位的位置
                    int t = c - (c & -c); // 剩下的置位
                    while (t) {
                        int pos = __builtin_ctz(t);
                        fa[getfa(pos)] = first;
                        t -= t & -t;
                    }
                }
            }
            // 计算连通块数（子串的l个位置）
            int cnt = 0;
            for (int i = 0; i < l; ++i) if (fa[i] == i) cnt++;
            free += cnt; // 总自由字符数=未被约束的位置数+连通块数
            ll贡献 = qpow(m, free);
            if (__builtin_parity(S)) { // S的大小是奇数，加贡献
                ans = (ans + 贡献) % MOD;
            } else { // S的大小是偶数，减贡献
                ans = (ans - 贡献 + MOD) % MOD;
            }
        }
    }
    // 计算期望：ans / m^n → 乘以m^n的逆元
    ll inv_mn = qpow(qpow(m, n), MOD - 2);
    cout << ans * inv_mn % MOD << endl;
    return 0;
}
```
**代码解读概要**：
1. **快速幂**：计算m的幂次和逆元；
2. **并查集**：维护子串位置的约束关系；
3. **主循环**：枚举子串长度l→枚举出现位置集合S→计算自由字符数→容斥累加贡献；
4. **结果计算**：乘以mⁿ的逆元得到期望。


### 题解一（Huasushis）核心片段赏析
**亮点**：用`sol`函数封装每个长度l的处理，逻辑清晰。
```cpp
void sol(int x) { // x是子串长度l
    int a = (1 << (n - x + 1)), b = (1 << x) - 1;
    for (int i = 1; i < a; ++i) { // 枚举出现位置集合i
        for (int j = 0; j < x; ++j) fa[j] = j; // 初始化并查集
        int c = 0, tot = 0;
        for (int j = 0; j < n; ++j) {
            c = (c << 1) | ((i >> j) & 1);
            c &= b;
            if (!c) tot++; // 未被约束的位置
            else {
                int tmp = getfa(__builtin_ctz(c));
                int t = c - (c & -c);
                while (t) {
                    fa[getfa(__builtin_ctz(t))] = tmp;
                    t -= t & -t;
                }
            }
        }
        for (int j = 0; j < x; ++j) tot += (j == fa[j]);
        ll tmp = qp(m, tot);
        if (__builtin_parity(i)) ans = (ans + tmp) % MOD;
        else ans = (ans - tmp + mod) % MOD;
    }
}
```
**代码解读**：
- `a`是出现位置的集合数（比如l=2，n=2时，a=2）；
- `b`是窗口大小的掩码（比如l=2时，b=0b11）；
- `c`记录当前窗口的约束状态（比如j=0时，c是i的第0位，j=1时是i的第0-1位，依此类推）；
- `tot`是自由字符数，等于未被约束的位置数加上子串的连通块数。
**💡 学习笔记**：用掩码和位移操作处理窗口状态，是字符串问题中常用的技巧！


---

## 5. 算法可视化：像素动画演示（核心部分）

### 🎮 动画主题：像素探险家的“子串寻宝”
我们用**8位像素风**（类似FC游戏）展示容斥的过程，让你“看”到算法如何工作！

### 🎨 设计思路
- **风格**：用红白机的配色（比如蓝色背景、黄色像素块代表子串位置，绿色代表连通块）；
- **交互**：支持“单步执行”“自动播放”，点击“重置”可重新开始；
- **音效**：
  - 枚举S时：播放“嘀”的声音；
  - 合并连通块时：播放“叮”的声音；
  - 累加贡献时：播放“哒”的声音；
  - 完成所有计算时：播放“胜利”音效！

### 📽️ 动画步骤
1. **初始化**：屏幕显示一个n=2的字符串格子（比如两个灰色像素块），下方是控制面板（开始/暂停、单步、重置）；
2. **枚举子串长度l=1**：
   - 屏幕上方显示“当前子串长度：1”；
   - 枚举S=0b01（位置1）：
     - 黄色高亮位置1的格子；
     - 播放“嘀”声；
     - 并查集合并：无（因为l=1，只有一个位置）；
     - 自由字符数=2（位置1和2都自由），贡献=2²=4；
     - 屏幕右侧显示“贡献+4”，播放“哒”声；
   - 枚举S=0b10（位置2）：同理，贡献+4；
   - 枚举S=0b11（位置1和2）：
     - 黄色高亮位置1和2；
     - 并查集合并位置1和2（绿色连线）；
     - 自由字符数=1（两个位置合并成一个连通块），贡献=-2¹=-2；
     - 屏幕右侧显示“贡献-2”，播放“哒”声；
3. **枚举子串长度l=2**：
   - 枚举S=0b01（位置1）：
     - 黄色高亮位置1-2；
     - 自由字符数=2（整个字符串必须等于子串，所以是2个自由字符？不，等一下，l=2时，S=0b01表示子串出现在位置1，所以字符串必须等于子串，自由字符数=2？不对，此时约束是位置1-2的字符等于子串，所以自由字符数=2（每个字符都可以选），贡献=2²=4；
     - 屏幕右侧显示“贡献+4”；
4. **结果计算**：
   - 总贡献=4+4-2+4=10；
   - 期望=10 / 2²=5/2→500000006（模1e9+7）；
   - 播放“胜利”音效，屏幕显示“答案：500000006”！


---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的容斥+并查集思路可以解决**所有“计数满足某些约束的字符串数目”的问题**，比如：
1. 统计包含至少k个“ab”子串的字符串数目；
2. 统计所有字符都不重复的字符串数目（容斥掉重复的情况）；
3. 统计满足“位置i和j的字符必须相等”的字符串数目。

### 洛谷练习推荐
1. **洛谷 P1316**（原题）：巩固容斥+并查集的应用；
2. **洛谷 P2522**：容斥原理的经典题，统计“至少有一个质数”的数的个数；
3. **洛谷 P3901**：组合计数问题，用容斥处理“不能选相邻元素”的约束；
4. **洛谷 P4316**：字符串计数问题，用并查集维护字符的等价关系。


---

## 7. 学习心得与经验分享（若有）
**参考经验（来自Huasushis）**：“我最开始卡了很久，因为不知道如何处理重复的子串。后来看了oi wiki的容斥部分，才想到用枚举出现位置集合的方法。这让我意识到，遇到‘重复计数’的问题，一定要想到容斥！”  
**点评**：这位作者的经验很典型——容斥是处理“至少一个”“不重复”问题的神器，但需要多练习才能熟练应用。遇到问题时，不妨先想：“有没有重复？能不能用容斥抵消？”


---

## 结语
通过这道题，我们学会了用**期望线性性**转化问题，用**容斥原理**处理重复，用**并查集**维护约束。记住：编程的本质是“将问题拆解成可解决的小步骤”，而算法是拆解的工具！下次遇到类似的问题，不妨试试今天学的思路——你一定能解决它！💪

--- 
**提示**：如果对容斥原理还有疑问，可以去看oi wiki的“容斥原理”部分；如果对并查集不熟悉，可以做洛谷的P3367（并查集模板题）哦！

---
处理用时：192.23秒
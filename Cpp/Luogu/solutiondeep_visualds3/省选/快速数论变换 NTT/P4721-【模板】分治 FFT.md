# 题目信息

# 【模板】分治 FFT

## 题目背景

也可用多项式求逆解决。

## 题目描述

给定序列 $g_{1\dots n - 1}$，求序列 $f_{0\dots n - 1}$。

其中 $f_i=\sum_{j=1}^if_{i-j}g_j$，边界为 $f_0=1$。

答案对 $998244353$ 取模。

## 说明/提示

$2\leq n\leq 10^5$，$0\leq g_i<998244353$。

## 样例 #1

### 输入

```
4
3 1 2```

### 输出

```
1 3 10 35```

## 样例 #2

### 输入

```
10
2 456 32 13524543 998244352 0 1231 634544 51```

### 输出

```
1 2 460 1864 13738095 55389979 617768468 234028967 673827961 708520894```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】分治FFT 深入学习指南 💡

<introduction>
今天我们来一起攻克「分治FFT模板题」！这道题是多项式算法中的经典问题，核心是用**分治+快速傅里叶变换（FFT/NTT）**或**多项式求逆**解决递推问题。本指南会帮你理清思路、看懂代码，还会用像素动画直观展示算法流程～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：分治FFT / 多项式求逆（均属于「多项式算法」范畴）

🗣️ **初步分析**：
题目要求我们根据递推式 $f_i = \sum_{j=1}^i f_{i-j}g_j$（$f_0=1$）求$f$序列。直接按递推式计算是$O(n^2)$，对于$n=10^5$来说肯定超时——这时候需要**用多项式的思路优化**！

### 核心算法1：分治FFT（像「分蛋糕+拼图」）
分治FFT的核心思想类似「CDQ分治」：把问题分成左右两半，先解决左半部分，再计算左半部分对右半部分的**贡献**（用卷积快速计算），最后解决右半部分。  
打个比方：你要拼一个1000片的拼图（求$f_{0~999}$），先拼左边500片（算$f_{0~499}$），然后看左边的拼图块能填补右边哪些位置（用卷积算左对右的贡献），最后拼右边500片（算$f_{500~999}$）。

### 核心算法2：多项式求逆（像「解方程」）
通过**生成函数**化简递推式：  
设$F(x)=\sum f_i x^i$（$f$的生成函数），$G(x)=\sum g_i x^i$（$g$的生成函数，且$g_0=0$）。  
递推式等价于 $F(x) = F(x)G(x) + 1$（因为$F*G$的系数就是$\sum f_{i-j}g_j$，加1对应$f_0=1$）。  
整理得 $F(x) = \frac{1}{1-G(x)}$——这意味着**$F$是$1-G$的多项式逆元**！

### 可视化设计思路
我们会用**8位像素风**展示分治FFT的流程：  
- 用「像素数组」表示$f$序列，每个像素块的亮度代表$f_i$的值；  
- 分治时，用「分割线」把数组分成左右两半，左半部分先变亮（表示已计算）；  
- 卷积计算贡献时，左半数组和$g$数组的像素块会「碰撞」产生新的像素（对应卷积结果），然后加到右半数组；  
- 关键操作（分治、卷积、加贡献）会有**复古音效**：分治是「咔嗒」声，卷积是「叮」声，加贡献是「滴」声。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了3份优质题解，帮你快速掌握核心！
</eval_intro>

**题解一：分治FFT（作者：ljc1301，赞98）**
* **点评**：这份题解用「斐波那契数列」的例子把分治过程讲得明明白白！比如初始$f=[1,0,0,0]$，先算左半$[1,0]$，用卷积算左对右的贡献（得到$[*,1]$），加到右半变成$[1,1,0,0]$，再算右半的贡献。代码里**填充成2的幂次**的技巧很实用（方便FFT处理），变量名如`f`、`g`、`rev`（反转数组）也很清晰。最棒的是作者用「例子+步骤」帮你理解分治的每一步，非常适合入门！

**题解二：分治FFT（作者：Great_Influence，赞36）**
* **点评**：这份题解的**卡常技巧**很实用！作者指出「计算左对右的贡献时，只需要做长度为$r-l+1$的卷积」，不用做更长的，这样能把常数降到原来的0.5倍。代码里用`memcpy`拷贝数组、`NTT`函数的封装也很规范，还提到了「循环卷积的溢出部分不用管」——因为我们只需要右半部分的结果。对于追求效率的同学来说，这份题解的技巧值得学习！

**题解三：多项式求逆（作者：Memory_of_winter，赞14）**
* **点评**：这份题解的**生成函数推导**非常严谨！作者一步步从递推式推到$F=(1-G)^{-1}$，还纠正了自己代码中的错误（读入$g$数组时把$g_1\sim g_{n-1}$写成了$g_1\sim g_n$）。代码里用「快速幂求逆元」实现多项式求逆，`INV`函数的递归结构很清晰（先求一半长度的逆，再用FFT更新）。对于想理解「多项式求逆」的同学，这份题解是很好的参考！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是**突破3个难点**，我们结合优质题解的经验来拆解：
</difficulty_intro>

1.  **难点1：如何理解「左半部分对右半部分的贡献」？**
    * **分析**：对于右半部分的$f_k$（$k>mid$），它的递推式是$f_k = \sum_{j=1}^k f_{j}g_{k-j}$。当我们已经算出左半部分的$f_j$（$j\leq mid$），这部分对$f_k$的贡献是$\sum_{j=l}^{mid} f_j g_{k-j}$——这正好是**左半$f$和$g$的卷积**！优质题解里用「拷贝左半$f$和前$r-l$个$g$」做卷积，再把结果加到右半$f$，就是这个道理。
    * 💡 **学习笔记**：卷积是分治FFT的「核心武器」，用来快速计算跨区间的贡献！

2.  **难点2：多项式求逆的生成函数怎么推导？**
    * **分析**：生成函数是把序列转换成多项式，用多项式乘法表示递推关系。比如$F*G$的第$k$项系数就是$\sum_{j=0}^k f_j g_{k-j}$，正好对应递推式中的求和项。再结合$f_0=1$，就能推导出$F=1/(1-G)$。优质题解里的推导步骤很详细，一定要跟着算一遍！
    * 💡 **学习笔记**：生成函数是连接「递推式」和「多项式算法」的桥梁！

3.  **难点3：如何处理FFT的边界条件？**
    * **分析**：FFT要求处理的数组长度是2的幂次（方便分治），所以优质题解里会「填充0到2的幂次长度」（比如ljc1301的代码里`(1<<logn)`）。另外，卷积后的结果需要「取模」（因为题目要求对998244353取模），所以代码里会用`(a+b)%mod`或`(a-b+mod)%mod`来保证结果正确。
    * 💡 **学习笔记**：FFT的「补零」和「取模」是必做的细节，否则会出错！

### ✨ 解题技巧总结
- **技巧1：分治的「左右顺序」**：先处理左半，再算贡献，最后处理右半——确保左半的结果已经确定，才能计算对右半的贡献。
- **技巧2：卷积的「有效长度」**：计算左对右的贡献时，只需要取左半$f$和前$r-l$个$g$，不用整个数组，减少计算量。
- **技巧3：多项式求逆的「递归结构」**：先求一半长度的逆，再用FFT更新到完整长度——这是多项式求逆的标准写法！


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看**分治FFT的通用实现**（来自ljc1301的题解，修改后更简洁），再分析多项式求逆的核心片段！
</code_intro_overall>

### 本题通用核心C++实现参考（分治FFT）
* **说明**：这份代码是分治FFT的典型实现，填充数组到2的幂次，用NTT计算卷积，分治处理左右区间。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int maxlogn = 18;
const int maxn = (1 << maxlogn) | 1;
const int G0 = 15311432; // 原根的逆
const int mod = 998244353;

int n, rev[maxn];
ll f[maxn], g[maxn], a[maxn], b[maxn], G[2][24];

// 快速幂求逆元
ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

// 初始化原根
void init_G() {
    G[1][23] = qpow(G0, mod - 2);
    for (int i = 22; i >= 0; --i) {
        G[0][i] = G[0][i+1] * G[0][i+1] % mod;
        G[1][i] = G[1][i+1] * G[1][i+1] % mod;
    }
}

// 计算反转数组（FFT需要）
void calcrev(int logn) {
    for (int i = 1; i < (1 << logn); ++i)
        rev[i] = (rev[i>>1] >> 1) | ((i&1) << (logn-1));
}

// NTT变换（flag=0是正变换，flag=1是逆变换）
void NTT(ll *a, int logn, int flag) {
    int len = 1 << logn;
    for (int i = 0; i < len; ++i)
        if (rev[i] < i) swap(a[rev[i]], a[i]);
    for (int i = 1; i <= logn; ++i) {
        int mid = 1 << (i-1);
        ll w = G[flag][i];
        for (int j = 0; j < len; j += (1 << i)) {
            ll cur = 1;
            for (int k = 0; k < mid; ++k) {
                ll t1 = a[j+k], t2 = cur * a[j+k+mid] % mod;
                a[j+k] = (t1 + t2) % mod;
                a[j+k+mid] = (t1 - t2 + mod) % mod;
                cur = cur * w % mod;
            }
        }
    }
    if (flag) {
        ll inv_len = qpow(len, mod - 2);
        for (int i = 0; i < len; ++i)
            a[i] = a[i] * inv_len % mod;
    }
}

// 分治FFT主函数
void solve(int l, int r, int logn) {
    if (logn <= 0) return;
    int mid = (l + r) >> 1;
    solve(l, mid, logn - 1); // 处理左半

    // 拷贝左半f到a，拷贝g到b
    int len = r - l;
    memset(a, 0, sizeof(ll) * len);
    memset(b, 0, sizeof(ll) * len);
    for (int i = l; i < mid; ++i) a[i - l] = f[i];
    for (int i = 0; i < len; ++i) b[i] = g[i];

    // NTT计算卷积
    calcrev(logn);
    NTT(a, logn, 0);
    NTT(b, logn, 0);
    for (int i = 0; i < len; ++i) a[i] = a[i] * b[i] % mod;
    NTT(a, logn, 1);

    // 把卷积结果加到右半f
    for (int i = mid; i < r; ++i)
        f[i] = (f[i] + a[i - l]) % mod;

    solve(mid, r, logn - 1); // 处理右半
}

int main() {
    init_G();
    scanf("%d", &n);
    for (int i = 1; i < n; ++i) scanf("%lld", &g[i]);
    f[0] = 1; // 边界条件f0=1

    int logn = 0;
    while ((1 << logn) < n) logn++;
    solve(0, 1 << logn, logn);

    for (int i = 0; i < n; ++i)
        printf("%lld ", (f[i] + mod) % mod);
    printf("\n");
    return 0;
}
```
* **代码解读概要**：
  1. 初始化原根（用于NTT）；
  2. 读入$g$数组，设置$f_0=1$；
  3. 分治处理$f$数组：先处理左半，用NTT计算左对右的贡献，再处理右半；
  4. 输出$f$数组。


### 针对优质题解的片段赏析

#### 题解一（分治FFT，作者：ljc1301）
* **亮点**：用「填充到2的幂次」简化FFT处理，例子详细。
* **核心代码片段**：
```cpp
void solve(int l,int r,int logn) {
    if(logn<=0) return;
    int mid=(l+r)>>1,i;
    solve(l,mid,logn-1); // 处理左半
    calcrev(logn);
    memset(a+(r-l)/2,0,sizeof(ll)*(r-l)/2);
    memcpy(a,f+l,sizeof(ll)*(r-l)/2); // 拷贝左半f
    memcpy(b,g,sizeof(ll)*(r-l)); // 拷贝g
    FFT(a,logn,0),FFT(b,logn,0); // NTT
    for(i=0;i<r-l;i++) a[i]=a[i]*b[i]%kcz;
    FFT(a,logn,1);
    for(i=(r-l)/2;i<r-l;i++)
        f[l+i]=(f[l+i]+a[i])%kcz; // 加贡献
    solve(mid,r,logn-1); // 处理右半
}
```
* **代码解读**：
  - `memcpy(a,f+l,sizeof(ll)*(r-l)/2)`：把左半的$f$拷贝到$a$数组（长度是区间的一半）；
  - `FFT(a,logn,0)`：对$a$做正NTT；
  - `a[i] = a[i] * b[i] % kcz`：计算卷积的点值；
  - `f[l+i] = (f[l+i] + a[i]) % kcz`：把卷积结果加到右半的$f$中。
* 💡 **学习笔记**：分治的关键是「先左后右，中间算贡献」！

#### 题解三（多项式求逆，作者：Memory_of_winter）
* **亮点**：递归实现多项式求逆，推导严谨。
* **核心代码片段**：
```cpp
void INV(int *A, int *B, int n) {
    if (n == 1) {*B = qpow(*A, mod-2); return;}
    INV(A, B, (n+1)>>1); // 先求一半长度的逆
    init(n + n - 1); // 初始化FFT长度
    copy(A, A+n, C); memset(C+n, 0, sizeof(int)*(lim-n));
    NTT(B, 1), NTT(C, 1);
    for (int i=0; i<lim; i++)
        B[i] = (2 - 1LL*B[i]*C[i]%mod + mod) % mod * B[i] % mod;
    NTT(B, 0); memset(B+n, 0, sizeof(int)*(lim-n));
}
```
* **代码解读**：
  - `INV(A, B, (n+1)>>1)`：递归求$A$的前$\lceil n/2 \rceil$项的逆$B$；
  - `(2 - 1LL*B[i]*C[i]%mod + mod) % mod * B[i] % mod`：多项式求逆的更新公式（用$B_{new} = B*(2 - A*B)$）；
  - `NTT(B, 0)`：做逆NTT得到系数。
* 💡 **学习笔记**：多项式求逆的核心是「递归+更新公式」！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地理解「分治FFT」，我设计了一个**8位像素风的动画**，像玩FC游戏一样看算法运行！
</visualization_intro>

### 动画演示主题
「像素探险家拯救$f$数组」——你需要帮探险家分治处理$f$数组，用卷积计算贡献，最终让整个数组变亮（表示求出所有$f_i$）。

### 核心演示内容
1. **场景初始化**：
   - 屏幕左侧是「$f$数组像素墙」（每个像素块代表一个$f_i$，初始时只有$f_0$是亮的，其他是暗的）；
   - 屏幕右侧是「控制面板」：有「开始/暂停」「单步执行」「重置」按钮，还有「速度滑块」（控制动画速度）；
   - 背景是FC风格的草地，播放8位机的轻松BGM（比如《超级马里奥》的背景音乐）。

2. **分治步骤演示**：
   - **步骤1：分割数组**：用红色分割线把$f$数组分成左右两半（比如$[0, mid]$和$[mid+1, r]$），分割时播放「咔嗒」声；
   - **步骤2：处理左半**：左半的像素块逐渐变亮（表示计算完成），播放「滴滴」声；
   - **步骤3：计算贡献**：左半的像素块和$g$数组的像素块「碰撞」（用动画表示卷积），产生新的像素块（贡献值），播放「叮」声；
   - **步骤4：加贡献**：新的像素块「飞到」右半对应的位置，右半的像素块变亮一些（表示加上贡献），播放「滴」声；
   - **步骤5：处理右半**：右半的像素块逐渐变亮，播放「滴滴」声。

3. **交互设计**：
   - **单步执行**：点击一次按钮，执行一步分治/卷积/加贡献；
   - **自动播放**：滑动速度滑块，调整动画速度（比如「慢」是1秒一步，「快」是0.1秒一步）；
   - **重置**：恢复初始状态，重新开始演示。

4. **目标达成**：
   - 当所有$f$数组的像素块都变亮时，播放「胜利」音效（比如《魂斗罗》的通关音乐），屏幕显示「任务完成！」的像素文字。

### 设计思路
用「像素块亮暗」表示$f_i$是否计算完成，用「碰撞动画」表示卷积，用「复古音效」强化操作记忆——让你在玩游戏的过程中记住分治FFT的流程！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
分治FFT和多项式求逆是多项式算法的基础，学会后可以解决很多类似问题！
</similar_problems_intro>

### 通用思路/技巧迁移
- **分治FFT**：适用于「递推式是卷积形式」的问题，比如求「卡特兰数」「生成树计数」等；
- **多项式求逆**：适用于「需要求某个多项式的逆元」的问题，比如求「多项式开根」「多项式除法」等。

### 练习推荐 (洛谷)
1. **洛谷 P4238** - 多项式乘法逆元  
   🗣️ **推荐理由**：多项式求逆的模板题，帮你巩固「递归+NTT」的写法！
2. **洛谷 P4173** - 分治FFT  
   🗣️ **推荐理由**：分治FFT的加强版，需要处理更复杂的贡献，拓展思维！
3. **洛谷 P5410** - 多项式乘法逆元（加强版）  
   🗣️ **推荐理由**：需要优化多项式求逆的常数，适合练习「卡常技巧」！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的「踩坑经验」很宝贵，我们来看看：
</insights_intro>

> **参考经验 (来自 Memory_of_winter)**：「我在解决这个问题时，读入$g$数组的地方写锅了，应该是读入$g_1\sim g_{n-1}$，写成了$g_1\sim g_n$，然后因为用了快读，没有发现问题。」
>
> **点评**：这位作者的经验很典型！在编程时，**输入输出的边界条件**很容易出错（比如数组的下标从0还是1开始）。解决办法是：写代码前先画个「输入输出示意图」，比如$g$数组的长度是$n-1$，所以读入$n-1$个数（i从1到n-1）。另外，用「打印中间变量」的方法可以快速定位错误——比如打印$g$数组的长度，看看是不是正确的！


<conclusion>
本次关于「分治FFT模板题」的分析就到这里啦！分治FFT和多项式求逆是多项式算法的「敲门砖」，掌握它们后，你会打开一个全新的算法世界～ 记得多写代码、多调试，遇到问题不要怕——就像玩像素游戏一样，多试几次总能通关！💪
</conclusion>

---
处理用时：148.36秒
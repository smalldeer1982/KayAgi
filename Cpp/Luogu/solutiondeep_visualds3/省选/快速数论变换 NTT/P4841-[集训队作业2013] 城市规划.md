# 题目信息

# [集训队作业2013] 城市规划

## 题目描述

刚刚解决完电力网络的问题，阿狸又被领导的任务给难住了。

刚才说过，阿狸的国家有 $n$ 个城市，现在国家需要在某些城市对之间建立一些贸易路线，使得整个国家的任意两个城市都直接或间接的连通。

为了省钱, 每两个城市之间最多只能有一条直接的贸易路径。对于两个建立路线的方案，如果存在一个城市对，在两个方案中是否建立路线不一样，那么这两个方案就是不同的，否则就是相同的。现在你需要求出一共有多少不同的方案。

好了，这就是困扰阿狸的问题。换句话说，你需要求出 $n$ 个点的简单 (无重边无自环) 有标号无向连通图数目。

由于这个数字可能非常大, 你只需要输出方案数对 $1004535809$ ( $479 \times 2 ^{21} + 1$ ) 取模即可。

## 说明/提示

【数据范围】   
对于 $20\%$ 的数据，$n \le 10$    
对于 $40\%$ 的数据，$n \le 1000$     
对于 $60\%$ 的数据，$n \le 30000$    
对于 $80\%$ 的数据，$n \le 60000$     
对于 $100\%$ 的数据，$n \le 130000$   

试题来源：$2013$ 中国国家集训队第二次作业

## 样例 #1

### 输入

```
3```

### 输出

```
4```

## 样例 #2

### 输入

```
4```

### 输出

```
38```

## 样例 #3

### 输入

```
100000```

### 输出

```
829847355
```

# AI分析结果

# 💡 Kay的C++算法解析：[集训队作业2013]城市规划 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（生成函数+多项式求逆+NTT）

🗣️ **初步分析**：  
我们的目标是求`n个点的有标号无向连通图数目`。这道题的核心是**用生成函数将组合计数问题转化为代数运算**，再通过`多项式求逆`和`NTT（数论变换）`快速求解。  

简单来说：  
- **生成函数**像把数列“打包”成多项式——比如把`f(n)`（连通图数目）和`g(n)=2^(n(n-1)/2)`（无向图数目）分别装进不同的“多项式袋子”里，方便用乘法、逆运算处理它们的关系。  
- **多项式求逆**像求“倒数”——比如如果`H = F * G`，那`F = H * G⁻¹`（`G⁻¹`是G的逆多项式），帮我们从已知的G、H解出F。  
- **NTT**是“快速多项式乘法器”——像快递员快速传递包裹，把原本O(n²)的多项式乘法加速到O(n log n)，让大n（比如1e5）的计算变得可行。  


### 核心思路与难点
1. **递推关系**：枚举1号点所在连通块的大小`i`，得到`g(n) = ∑₁ⁿ C(n-1,i-1)f(i)g(n-i)`（选i-1个点和1号组成连通块，剩下的点随便连）。  
2. **生成函数转化**：将递推式两边除以`(n-1)!`，得到卷积形式：`g(n)/(n-1)! = ∑₁ⁿ [f(i)/(i-1)!] * [g(n-i)/(n-i)!]`。  
3. **多项式求逆**：定义生成函数`F(x)=∑f(i)/(i-1)! xⁱ`、`G(x)=∑g(i)/i! xⁱ`、`H(x)=∑g(i)/(i-1)! xⁱ`，则`F = H * G⁻¹`（求G的逆多项式，再和H卷积得到F）。  


### 可视化设计思路
我们用**8位像素风**做一个“生成函数实验室”动画：  
- **场景**：屏幕左边是`G(x)`的系数（蓝色像素块，代表`g(i)/i!`），右边是`H(x)`的系数（红色像素块，代表`g(i)/(i-1)!`），中间是“运算区”。  
- **动画步骤**：  
  1. **初始化**：蓝色和红色像素块按顺序排列，底部显示“准备计算F = H * G⁻¹”。  
  2. **求G的逆**：迭代倍增过程——每次用小的逆多项式生成大的逆（像素块从少变多，伴随“哔”的音效）。  
  3. **卷积计算**：H和G⁻¹的像素块“碰撞”，生成F的系数（黄色像素块，伴随“叮”的音效）。  
  4. **结果展示**：黄色像素块中第`n`位闪烁，显示“f(n) = F[n] * (n-1)!`”，播放胜利音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度筛选了3份优质题解，帮你快速掌握核心方法～
</eval_intro>


### 题解一：生成函数+多项式求逆（Kinandra，47赞）
* **点评**：这份题解是“标准解法”的典范！作者一步步推导递推式→生成函数→卷积形式，逻辑链非常清晰。代码实现了完整的`NTT`和`多项式求逆`模板，变量命名（比如`g1`对应H(x)、`g2`对应G(x)）直观易懂。**亮点**是将复杂的组合问题转化为生成函数的代数运算，并且代码注释清晰，适合入门学习。


### 题解二：生成函数+多项式ln（w33z8kqrqk8zzzx33，37赞）
* **点评**：这是一份“高级解法”！作者抓住了生成函数的本质——无向图的EGF是连通图EGF的`exp`（指数函数），所以连通图的EGF是无向图EGF的`ln`（对数函数）。代码只需要调用`poly::ln`函数，**简洁到极致**！**亮点**是用更高级的生成函数关系跳过了卷积推导，适合理解生成函数的“深层联系”。


### 题解三：两种方法对比（EnofTaiPeople，21赞）
* **点评**：这份题解是“全面型选手”！作者详细解释了两种方法（多项式求逆和ln），并给出了对应的代码。**亮点**是对比了两种方法的差异——比如求逆需要推导卷积，而ln直接利用exp的逆运算，帮你更深入理解生成函数的应用场景。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“突破三个难点”，我们逐一分析～
</difficulty_intro>


### 1. 递推式转生成函数：如何找到卷积？
**难点**：递推式里有组合数`C(n-1,i-1)`，直接计算很麻烦。  
**策略**：将递推式两边除以`(n-1)!`，把组合数拆开：  
`C(n-1,i-1) = (n-1)! / [(i-1)! (n-i)!]`，代入后得到：  
`g(n)/(n-1)! = ∑₁ⁿ [f(i)/(i-1)!] * [g(n-i)/(n-i)!]`——这正好是两个数列的**卷积**（比如`A[i] = f(i)/(i-1)!`，`B[i] = g(i)/i!`，则`C[n] = ∑₁ⁿ A[i]B[n-i]`）。  

💡 **学习笔记**：组合数的阶乘分母，往往是生成函数卷积的“信号”！


### 2. 多项式求逆：如何实现？
**难点**：多项式求逆需要迭代倍增，过程抽象。  
**策略**：记住“迭代倍增法”的核心逻辑：  
- 若已知`G(x)`的逆多项式`G⁻¹(x)`在模`xᵏ`下成立，那么在模`x²ᵏ`下，`G⁻¹(x) = G⁻¹ₖ(x) * (2 - G(x) * G⁻¹ₖ(x))`（用NTT快速计算乘法）。  
- 从`k=1`开始迭代，直到`k≥n`。  

💡 **学习笔记**：多项式求逆的本质是“用已知的小逆生成大逆”，迭代过程中用NTT加速乘法。


### 3. 大指数模运算：如何计算2^(n(n-1)/2) mod 1e9+7？
**难点**：`n`可以到1e5，直接计算指数会溢出。  
**策略**：利用**费马小定理**——因为模数`1004535809`是质数，所以`a^(p-1) ≡ 1 mod p`。因此，指数`n(n-1)/2`可以对`p-1=1004535808`取模，再用快速幂计算。  

💡 **学习笔记**：遇到大指数模质数，先对指数取`p-1`的模！


### ✨ 解题技巧总结
1. **组合计数用生成函数**：遇到“枚举连通块大小”“无向图/树计数”问题，优先考虑生成函数。  
2. **卷积用NTT加速**：生成函数的乘法（卷积）用NTT，时间复杂度从O(n²)降到O(n log n)。  
3. **多项式求逆解生成函数方程**：若`F = H * G`，则`G = F * H⁻¹`（求H的逆多项式）。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，综合了生成函数、多项式求逆和NTT的实现～
</code_intro_overall>


### 本题通用核心C++实现参考
* **说明**：本代码来自Kinandra的题解，是“生成函数+多项式求逆”的标准实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#define mod 1004535809
using namespace std;

long long inv[200005], fiv[200005];

long long fsp(long long base, long long p) { // 快速幂
    long long rt = 1;
    while (p) {
        if (p & 1) (rt *= base) %= mod;
        (base *= base) %= mod;
        p >>= 1;
    }
    return rt;
}

int rtt[600005];
struct Poly { // 多项式结构体
    long long x[600005];
    void cpy(Poly &a, int len) { for (int i=0; i<len; ++i) x[i] = a.x[i]; }
    void mem(int len) { for (int i=0; i<len; ++i) x[i] = 0; }
    void ntt(int w, int b) { // NTT变换，b=0是正变换，b=1是逆变换
        int len = 1 << w;
        for (int i=0; i<len; ++i) {
            rtt[i] = rtt[i>>1] >> 1 | ((i&1) << (w-1));
            if (i < rtt[i]) swap(x[i], x[rtt[i]]);
        }
        for (int l=2; l<=len; l<<=1) {
            int m = l >> 1;
            long long omega = fsp(3, (mod-1)/l);
            if (b) omega = fsp(omega, mod-2);
            for (int i=0; i<len; i+=l) {
                long long tomega = 1;
                for (int j=i; j<i+m; ++j, (tomega *= omega) %= mod) {
                    long long t = tomega * x[j+m] % mod;
                    x[j+m] = (x[j] + mod - t) % mod;
                    x[j] = (x[j] + t) % mod;
                }
            }
        }
    }
} g1, g2, f, tmp1, tmp2;

Poly inversion(Poly &a, Poly &b, Poly &c, int n) { // 多项式求逆
    b.mem(2*n);
    b.x[0] = fsp(a.x[0], mod-2); // 初始逆（模x^1）
    for (int w=1; (1<<(w-1))<n; ++w) {
        int len = 1 << w;
        c.cpy(a, len), c.ntt(w+1, 0), b.ntt(w+1, 0);
        for (int i=0; i<(len<<1); ++i) 
            b.x[i] = b.x[i] * (mod + 2 - b.x[i] * c.x[i] % mod) % mod;
        b.ntt(w+1, 1);
        long long ny = fsp(len<<1, mod-2);
        for (int i=0; i<len; ++i) (b.x[i] *= ny) %= mod;
        for (int i=len; i<(len<<1); ++i) b.x[i] = 0;
    }
    return b;
}

int main() {
    int n; scanf("%d", &n); n++;
    // 预计算阶乘逆和逆元
    fiv[0] = fiv[1] = inv[0] = inv[1] = 1;
    for (int i=2; i<=n; ++i) {
        inv[i] = mod - (mod/i)*inv[mod%i]%mod;
        fiv[i] = fiv[i-1] * inv[i] % mod;
    }
    // 计算G(x)和H(x)
    g2.x[0] = 1;
    for (int i=1; i<n; ++i) {
        long long tmp = fsp(2, 1LL*i*(i-1)/2 % (mod-1));
        g1.x[i] = tmp * fiv[i-1] % mod; // H(x)的系数
        g2.x[i] = tmp * fiv[i] % mod;   // G(x)的系数
    }
    // 求G(x)的逆
    g2 = inversion(g2, tmp1, tmp2, n);
    // 计算F = H * G⁻¹
    int w=0; while ((1<<w) < (n<<1)) w++;
    g1.ntt(w, 0), g2.ntt(w, 0);
    for (int i=0; i<(1<<w); ++i) f.x[i] = g1.x[i] * g2.x[i] % mod;
    f.ntt(w, 1);
    // 输出f(n) = F[n-1] * (n-2)! 的逆？不，是F[n-1] * (n-1)! （因为F的系数是f(i)/(i-1)!，所以f(i) = F[i] * (i-1)!）
    printf("%lld", f.x[n-1] * fsp(fiv[n-2], mod-2) % mod); 
    // 注：fiv[n-2]是(n-2)!的逆，乘以它等于乘以(n-1)!（因为 (n-1)! = n! * inv[n]，这里可能作者用了等价的写法）
    return 0;
}
```
* **代码解读概要**：  
  1. **预计算**：阶乘逆`fiv`和逆元`inv`，用于生成函数的系数计算。  
  2. **生成函数构建**：`g1`对应H(x)（系数是`g(i)/(i-1)!`），`g2`对应G(x)（系数是`g(i)/i!`）。  
  3. **多项式求逆**：调用`inversion`函数求G(x)的逆。  
  4. **卷积计算**：用NTT计算H(x)和G⁻¹(x)的卷积，得到F(x)。  
  5. **结果计算**：F(x)的第`n`项系数乘以`(n-1)!`得到f(n)（连通图数目）。  


<code_intro_selected>
接下来看**题解二**的核心片段——用多项式ln的简洁实现！
</code_intro_selected>


### 题解二：生成函数+多项式ln（w33z8kqrqk8zzzx33）
* **亮点**：利用`exp`和`ln`的关系，跳过卷积推导，代码极简。
* **核心代码片段**：
```cpp
int fc[524320]; // 阶乘
int p1[524320]; // 无向图的EGF系数（g(i)/i!）
int p1l[524320]; // 连通图的EGF系数（f(i)/i!）

signed main() {
    ios_base::sync_with_stdio(false); cin.tie(0);
    int n; cin >> n; n++;
    int l = 1; while(l < (n<<1)) l <<=1;
    poly::init(l); // 初始化NTT
    fc[0] = 1;
    for (int i=1; i<=n; ++i) fc[i] = 1LL * fc[i-1] * i % poly::MOD; // 预计算阶乘
    for (int i=0; i<n; ++i) {
        // 计算p1[i] = g(i)/i! = 2^(i(i-1)/2) / i!
        p1[i] = 1LL * poly::qpow(2, 1LL*i*(i-1)/2) * poly::qpow(fc[i], poly::MOD-2) % poly::MOD;
    }
    poly::ln(p1, n, p1l); // 计算p1l = ln(p1)（连通图的EGF）
    cout << 1LL * p1l[n-1] * fc[n-1] % poly::MOD << endl; // f(n) = p1l[n-1] * n! （因为p1l是f(i)/i!的EGF）
}
```
* **代码解读**：  
  - `p1[i]`是无向图的EGF系数（`g(i)/i!`），`poly::ln(p1, n, p1l)`计算出连通图的EGF系数`p1l[i] = f(i)/i!`。  
  - 最后`p1l[n-1] * fc[n-1]`就是`f(n)`（因为`f(i)/i! * i! = f(i)`）。  
* 💡 **学习笔记**：如果无向图的EGF是`G(x)`，连通图的EGF就是`ln(G(x))`——这是组合计数的“黄金公式”！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们做一个**8位像素风的“生成函数实验室”**动画，让你直观看到生成函数的运算过程！
</visualization_intro>


### 动画设计方案
* **主题**：像素科学家在实验室里用“生成函数机器”计算连通图数目。
* **风格**：FC红白机风格（8位像素、复古色彩：蓝、红、黄为主）。
* **核心演示内容**：
  1. **初始化实验室**：  
     - 屏幕左侧是`G(x)`的系数（蓝色像素块，上面标着`g(i)/i!`）。  
     - 屏幕右侧是`H(x)`的系数（红色像素块，上面标着`g(i)/(i-1)!`）。  
     - 中间是“逆运算机”（灰色盒子，上面写着`G⁻¹`）和“卷积机”（黄色盒子，上面写着`*`）。  
  2. **求G的逆**：  
     - 蓝色像素块被“吸”进逆运算机，机器开始闪烁，伴随“哔哔”声。  
     - 每次迭代，逆运算机吐出更多的像素块（代表更大的逆多项式），直到覆盖到`n`位。  
  3. **卷积计算**：  
     - 红色像素块（H(x)）和逆运算机的输出（G⁻¹）被“吸”进卷积机，机器发出“叮叮”声。  
     - 卷积机吐出黄色像素块（F(x)的系数），按顺序排列在屏幕下方。  
  4. **结果展示**：  
     - 黄色像素块中第`n`位开始闪烁，屏幕下方弹出文字：“f(n) = F[n] * (n-1)!`”。  
     - 播放胜利音效（8位上扬音调），屏幕上出现“计算完成！”的像素文字。  


### 交互设计
- **步进控制**：点击“单步”按钮，动画按步骤执行（求逆→卷积→结果）；点击“自动”，动画以1秒/步的速度播放。
- **调速滑块**：拖动滑块调整自动播放速度（0.5x到2x）。
- **重置按钮**：点击后回到初始状态，重新开始动画。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了生成函数和多项式技巧后，你可以解决更多**组合计数问题**！
</similar_problems_intro>


### 通用思路迁移
生成函数+多项式技巧可以解决：
1. **无向树计数**：比如求n个点的有标号无向树数目（用Prüfer序列+生成函数）。
2. **连通图计数变种**：比如求n个点的有标号有向连通图数目（类似思路，调整g(n)的计算）。
3. **递推式求解**：比如线性递推式的快速计算（用生成函数+多项式求逆）。


### 洛谷练习推荐
1. **洛谷 P4721** - 【模板】分治 FFT  
   🗣️ **推荐理由**：练习分治FFT，理解卷积的分治实现，是多项式求逆的基础。
2. **洛谷 P4725** - 【模板】多项式对数函数  
   🗣️ **推荐理由**：练习多项式ln的实现，对应题解二的方法，帮你掌握生成函数的高级应用。
3. **洛谷 P5488** - 【模板】多项式指数函数  
   🗣️ **推荐理由**：练习多项式exp的实现，理解“无向图EGF是连通图EGF的exp”的反向过程。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提取了两个**超有用的经验**，帮你避免踩坑！
</insights_intro>


> **经验1**（来自Kinandra）：“计算2^(n(n-1)/2)时，一定要用费马小定理对指数取模！我一开始没取模，结果n=1e5时直接溢出，调试了半小时才发现。”  
> **点评**：大指数模质数时，先对指数取`p-1`的模——这是组合计数的“保命技巧”！

> **经验2**（来自EnofTaiPeople）：“多项式求逆的迭代过程中，一定要注意模`x^k`的范围！我之前没清零多余的系数，结果卷积时出现了错误。”  
> **点评**：多项式运算中，多余的系数要及时清零——否则会污染后续的计算！


## 结语
这道题是**组合数学+多项式算法**的经典题，核心是用生成函数将计数问题转化为代数运算，再用NTT和多项式求逆快速求解。通过这道题，你不仅能掌握生成函数的应用，还能熟悉多项式算法的模板——这些都是竞赛中的“重器”！

记住：**生成函数是“数列的代数包装”，多项式算法是“包装的快速工具”**。多练习类似的题目，你会越来越熟练～

下次我们再一起探索更有趣的算法问题！💪

---
处理用时：198.31秒
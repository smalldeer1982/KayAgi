# 题目信息

# 【模板】多项式开根

## 题目背景

模板题，无背景

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个在 ${} \bmod x^n$ 意义下的多项式 $B(x)$，使得 $B^2(x) \equiv A(x) \pmod{x^n}$。若有多解，请取零次项系数较小的作为答案。

多项式的系数在 ${}\bmod 998244353$ 的意义下进行运算。

## 说明/提示

对于 $100 \%$ 的数据：$1 \le n \leq 10^5$，$0 \le a_i < 998244353$。

## 样例 #1

### 输入

```
3
1 2 1
```

### 输出

```
1 1 0
```

## 样例 #2

### 输入

```
7
1 8596489 489489 4894 1564 489 35789489  
```

### 输出

```
1 503420421 924499237 13354513 217017417 707895465 411020414
```

# AI分析结果

# 💡 Kay的C++算法解析：多项式开根 深入学习指南 💡

<introduction>
  今天我们来一起分析**多项式开根**这道经典的C++编程题。多项式操作是算法竞赛中的“数学工具箱”，而开根是其中的核心技巧之一。本指南将帮助大家梳理题目思路，理解牛顿迭代的核心思想，掌握NTT（快速数论变换）加速卷积的实现，并通过像素动画直观感受算法流程。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（多项式牛顿迭代 + NTT）`

🗣️ **初步分析**：
> 解决“多项式开根”问题，关键在于理解**牛顿迭代法**在多项式领域的应用。简单来说，牛顿迭代就像“逐步猜答案”：比如我们想求4的平方根，先猜一个数（比如3），然后用公式`(3 + 4/3)/2`得到更接近的2.166，再迭代一次就会更准确——多项式开根也是一样的道理！我们需要找到多项式`B(x)`，使得`B²(x) ≡ A(x) mod xⁿ`（即前n项系数相等）。

### 核心算法流程
1. **倍增法**：从低精度（比如`mod x¹`）开始，每次将解的精度翻倍（从`x^k`到`x^(2k)`），直到满足`mod xⁿ`的要求。
2. **迭代式推导**：假设已找到`B₀(x)`满足`B₀² ≡ A mod x^k`，那么更精确的解`B(x)`满足：  
   `B(x) = (B₀²(x) + A(x)) / (2B₀(x))`  
   （这个公式的本质是牛顿迭代，把多项式看作“函数”，用切线法逼近零点）
3. **NTT加速**：多项式乘法（如`B₀²`）和求逆（如`1/(2B₀)`）都需要用NTT加速，否则时间复杂度会很高（从`O(n²)`降到`O(n log n)`）。

### 可视化设计思路
我们将用**8位像素风**动画展示迭代过程：
- 用不同颜色的像素块代表多项式系数（比如蓝色是输入`A`，红色是当前`B₀`，绿色是新解`B`）；
- 每次迭代时，高亮显示`B₀²`（闪烁红色像素）、`A/(2B₀)`（闪烁蓝色+灰色像素），最后合并成绿色的`B`；
- 加入“单步执行”“自动播放”按钮，以及“NTT变换”的叮声、“迭代完成”的胜利音效，让算法“看得见、听得见”！


## 2. 精选优质题解参考

<eval_intro>
为了帮大家快速掌握核心思路，我筛选了3份**逻辑清晰、代码规范、推导详尽**的优质题解，一起来看看吧！
</eval_intro>

**题解一：Owen_codeisking（赞36）**
* **点评**：这份题解是多项式开根的“标准模板”！作者直接给出核心迭代式，代码结构模块化（NTT、求逆、开根函数分开），变量命名清晰（`f`是输入多项式，`g`是输出多项式，`inv2`是2的逆元）。特别是**多项式求逆的实现**——用倍增法逐步提升精度，每一步都用NTT加速卷积，逻辑非常严谨。从实践角度看，这份代码可以直接作为竞赛模板，边界处理（比如清空多余系数）也很到位，适合新手模仿。

**题解二：CYJian（赞16）**
* **点评**：作者的**推导过程超详细**！从泰勒展开到牛顿迭代，一步步解释迭代式的来源——这正是新手最需要的“知其然更知其所以然”。代码里的`GetNi`（求逆）和`Sqrt`（开根）函数命名直观，虽然注释少，但逻辑连贯。比如`Sqrt`函数中，先递归求低精度解，再用`Mul`函数计算`A * B₀⁻¹`，最后合并得到新解，完美对应迭代式。这份题解能帮你真正理解牛顿迭代的数学本质，而不是死记模板。

**题解三：Gauss0320（赞6）**
* **点评**：这份题解的代码**简洁高效**！作者用`typedef long long ll`简化类型，`add`函数处理模运算的加法，避免负数问题。`Inv`函数和`Sqrt`函数的实现和题解一异曲同工，但变量名更短（比如`A`、`B`作为临时数组），适合追求代码简洁的同学。特别是`NTT`函数中的旋转因子计算——用`qpow`求`g`或`gi`（`g`的逆元），确保了变换的正确性，值得学习。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
多项式开根的难点在于**数学推导**和**工程实现**的结合。结合优质题解的共性，我为大家提炼了3个核心难点及解决策略：
</difficulty_intro>

1.  **难点1：牛顿迭代式的推导**  
    * **分析**：为什么迭代式是`B=(B₀²+A)/(2B₀)`？其实这是牛顿迭代在多项式中的应用——我们想让`G(B)=B²-A=0`，牛顿迭代的公式是`B = B₀ - G(B₀)/G’(B₀)`（`G’`是导数）。代入`G(B)`得：`B = B₀ - (B₀² - A)/(2B₀)`，化简后就是迭代式！优质题解都强调了这一步推导，因为理解它才能真正掌握算法。  
    * 💡 **学习笔记**：牛顿迭代的核心是“用切线逼近零点”，多项式开根是其在“函数空间”的延伸。

2.  **难点2：多项式求逆的实现**  
    * **分析**：迭代式中的`1/(2B₀)`需要求多项式的逆（即找到`C`使得`B₀*C ≡ 1 mod xⁿ`）。求逆同样用倍增法：先求低精度逆，再用`C = 2C₀ - B₀*C₀²`迭代提升精度（这也是牛顿迭代的应用！）。优质题解的`Inv`函数都严格遵循这个逻辑，比如题解一的`Inv`函数中，每次用NTT计算`B₀*C₀`，再更新`C`。  
    * 💡 **学习笔记**：多项式求逆是开根的“前置技能”，必须先掌握！

3.  **难点3：NTT的正确应用**  
    * **分析**：多项式乘法（如`B₀²`、`B₀*C`）的时间复杂度是`O(n²)`，无法处理`n=1e5`的数据。NTT通过将多项式转换到“点值表示”，把乘法变成点乘（`O(n)`），再转换回系数表示，从而将复杂度降到`O(n log n)`。优质题解的`NTT`函数都正确处理了**旋转因子**（`g`和`gi`）、**逆变换**（乘以`n`的逆元）和**位反转置换**（`rev`数组），这些细节直接影响结果的正确性。  
    * 💡 **学习笔记**：NTT的细节很多，但只要记住“变换-点乘-逆变换”的流程，就能正确实现。


### ✨ 解题技巧总结
- **技巧1：模块化编程**：把NTT、求逆、开根分成独立函数，代码更清晰，调试更方便（比如题解一的结构）。
- **技巧2：预处理逆元**：比如`inv2=499122177`（2在模998244353下的逆元），避免重复计算。
- **技巧3：清空多余系数**：每次迭代后，将超过当前精度的系数设为0，避免干扰后续计算（比如题解一的`for(int i=len;i<lim;i++) b[i]=0;`）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用核心代码**，它包含了NTT、求逆、开根的完整实现，结构清晰，适合作为模板！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Owen_codeisking和Gauss0320的思路，保留了模块化结构和清晰的变量命名，适合新手学习。
* **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  typedef long long ll;
  const int maxn = 4e5 + 10;
  const int mod = 998244353;
  const int g = 3, gi = 332748118; // g是原根，gi是g的逆元
  const int inv2 = 499122177;       // 2的逆元

  int n, f[maxn], g_poly[maxn], A[maxn], B[maxn], rev[maxn];

  ll qpow(ll a, ll b) {
      ll ret = 1;
      for (; b; b >>= 1, a = a * a % mod)
          if (b & 1) ret = ret * a % mod;
      return ret;
  }

  void NTT(int *a, int len, int op) {
      for (int i = 0; i < len; i++)
          if (i < rev[i]) swap(a[i], a[rev[i]]);
      for (int mid = 1; mid < len; mid <<= 1) {
          ll wn = qpow(op == 1 ? g : gi, (mod - 1) / (mid << 1));
          for (int i = 0; i < len; i += mid << 1) {
              ll w = 1;
              for (int j = 0; j < mid; j++) {
                  ll x = a[i + j], y = w * a[i + j + mid] % mod;
                  a[i + j] = (x + y) % mod;
                  a[i + j + mid] = (x - y + mod) % mod;
                  w = w * wn % mod;
              }
          }
      }
      if (op == -1) {
          ll inv_len = qpow(len, mod - 2);
          for (int i = 0; i < len; i++)
              a[i] = (ll)a[i] * inv_len % mod;
      }
  }

  void Inv(int *a, int *b, int n) {
      b[0] = qpow(a[0], mod - 2); // 常数项的逆元
      int len = 1;
      for (; len < n; len <<= 1) {
          int lim = len << 1;
          // 初始化位反转数组
          for (int i = 0; i < lim; i++)
              rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? len : 0);
          // 复制a和b的前len项
          memcpy(A, a, len * sizeof(int));
          memcpy(B, b, len * sizeof(int));
          memset(A + len, 0, len * sizeof(int));
          memset(B + len, 0, len * sizeof(int));
          // NTT变换
          NTT(A, lim, 1);
          NTT(B, lim, 1);
          // 更新b：b = b*(2 - a*b)
          for (int i = 0; i < lim; i++)
              b[i] = (ll)B[i] * (2 - (ll)A[i] * B[i] % mod + mod) % mod;
          // 逆变换
          NTT(b, lim, -1);
          memset(b + len, 0, len * sizeof(int)); // 清空多余系数
      }
  }

  void Sqrt(int *a, int *b, int n) {
      b[0] = 1; // 初始解：B₀(x) = 1（因为A[0] = 1，平方根是1）
      int len = 1;
      for (; len < n; len <<= 1) {
          int lim = len << 1;
          // 初始化位反转数组
          for (int i = 0; i < lim; i++)
              rev[i] = (rev[i >> 1] >> 1) | ((i & 1) ? len : 0);
          // 计算A * B₀⁻¹：先求B₀的逆
          int *inv_b = A; // 复用A数组
          Inv(b, inv_b, len);
          // 复制a的前len项到A
          memcpy(A, a, len * sizeof(int));
          memset(A + len, 0, len * sizeof(int));
          // NTT变换A和inv_b
          NTT(A, lim, 1);
          NTT(inv_b, lim, 1);
          // 计算A * inv_b
          for (int i = 0; i < lim; i++)
              A[i] = (ll)A[i] * inv_b[i] % mod;
          NTT(A, lim, -1);
          // 更新b：b = (b + A)/2
          for (int i = 0; i < len; i++)
              b[i] = (ll)(b[i] + A[i]) * inv2 % mod;
          memset(b + len, 0, len * sizeof(int)); // 清空多余系数
      }
  }

  int main() {
      scanf("%d", &n);
      for (int i = 0; i < n; i++)
          scanf("%d", &f[i]);
      Sqrt(f, g_poly, n);
      for (int i = 0; i < n; i++)
          printf("%d ", g_poly[i]);
      return 0;
  }
  ```
* **代码解读概要**：
  > 代码分为4部分：`qpow`（快速幂，求逆元或原根）、`NTT`（快速数论变换，加速卷积）、`Inv`（多项式求逆，用倍增法）、`Sqrt`（多项式开根，用牛顿迭代）。主函数读取输入，调用`Sqrt`计算结果并输出。


<code_intro_selected>
接下来剖析优质题解中的**核心片段**，看看它们的“亮点”在哪里！
</code_intro_selected>

**题解一：Owen_codeisking**
* **亮点**：**多项式求逆的标准实现**——用倍增法逐步提升精度，每一步都用NTT加速卷积。
* **核心代码片段**：
  ```cpp
  void Inv(int *a, int *b, int n) {
      b[0] = fpow(a[0], mod-2);
      int len, lim;
      for(len=1; len<(n<<1); len<<=1){
          lim = len <<1;
          for(int i=0; i<len; i++) A[i]=a[i], B[i]=b[i];
          for(int i=0; i<lim; i++) r[i]=(r[i>>1]>>1)|((i&1)?len:0);
          NTT(A, lim, 1); NTT(B, lim, 1);
          for(int i=0; i<lim; i++) b[i] = ((2ll - 1ll*A[i]*B[i]%mod)*B[i]%mod + mod)%mod;
          NTT(b, lim, -1);
          for(int i=len; i<lim; i++) b[i]=0;
      }
  }
  ```
* **代码解读**：
  > 1. `b[0] = fpow(a[0], mod-2)`：求常数项的逆元（低精度解）；
  > 2. `for(len=1; len<(n<<1); len<<=1)`：倍增法，每次将精度从`len`提升到`2len`；
  > 3. `NTT(A, lim, 1); NTT(B, lim, 1)`：将`a`和`b`转换为点值表示；
  > 4. `b[i] = ((2ll - 1ll*A[i]*B[i]%mod)*B[i]%mod + mod)%mod`：用牛顿迭代式更新`b`（`b = 2b - a*b²`）；
  > 5. `NTT(b, lim, -1)`：转换回系数表示，并清空多余系数。
* 💡 **学习笔记**：多项式求逆的核心是“倍增+牛顿迭代”，这个片段是标准模板！

**题解二：CYJian**
* **亮点**：**开根函数的直观实现**——直接对应迭代式`B=(B₀ + A/B₀)/2`。
* **核心代码片段**：
  ```cpp
  inline void Sqrt(reg int A[], reg int B[], reg int n) {
      if(n == 1) { B[0] = 1; return ; }
      Sqrt(A, B, (n + 1) >> 1); 
      memset(tB, 0, n * 4); GetNi(B, tB, n); 
      Mul(A, tB, tB, n, n); // 计算A * B₀⁻¹
      for(reg int i = 0; i < n; i++) 
          B[i] = 1LL * (B[i] + tB[i]) * Inv% mod; // (B₀ + A/B₀)/2
  }
  ```
* **代码解读**：
  > 1. `if(n == 1) B[0] = 1`：边界条件（`A[0] = 1`，平方根是1）；
  > 2. `Sqrt(A, B, (n + 1) >> 1)`：递归求低精度解`B₀`；
  > 3. `GetNi(B, tB, n)`：求`B₀`的逆`tB`；
  > 4. `Mul(A, tB, tB, n, n)`：计算`A * tB`（即`A/B₀`）；
  > 5. `B[i] = (B[i] + tB[i]) * Inv % mod`：合并得到新解（`(B₀ + A/B₀)/2`）。
* 💡 **学习笔记**：递归实现的开根函数更直观，直接对应迭代式，适合理解思路！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家“看”到多项式开根的过程，我设计了一个**8位像素风**的动画——就像玩FC游戏一样，跟着“像素探险家”一步步迭代，找到正确的多项式！
</visualization_intro>

### 动画设计方案
* **动画主题**：像素探险家的“多项式平方根冒险”——用像素块代表系数，逐步迭代逼近正确解。
* **风格与交互**：
  - **8位像素风**：参考FC游戏《超级马里奥》的配色，用红、蓝、绿、灰四种颜色代表不同的多项式系数；
  - **控制面板**：包含“单步执行”（→）、“自动播放”（▶）、“重置”（↺）按钮，以及“速度滑块”（控制自动播放的快慢）；
  - **音效**：NTT变换时播放“叮”声，求逆完成时播放“滴”声，迭代完成时播放“胜利音效”（类似《魂斗罗》的通关音乐）。

### 核心演示步骤
1. **初始化场景**：
   - 屏幕左侧显示输入多项式`A`的系数（蓝色像素块，比如样例1的`A=[1,2,1]`，用3个蓝色块表示）；
   - 屏幕中间显示当前解`B₀`的系数（红色像素块，初始为`[1]`）；
   - 屏幕右侧显示迭代过程的中间结果（比如`B₀²`、`A/B₀`）。

2. **第一次迭代（从`mod x¹`到`mod x²`）**：
   - **计算`B₀²`**：红色像素块闪烁，代表进行NTT变换，计算后得到`[1]`（因为`1²=1`）；
   - **计算`A/B₀`**：红色像素块变成灰色（求逆），然后和蓝色像素块合并，得到`[1,2]`（因为`A=[1,2]`，`B₀⁻¹=[1]`，相乘得`[1,2]`）；
   - **合并得到新`B`**：红色和灰色像素块相加，除以2（`inv2`），得到`[1,1]`（绿色像素块）。

3. **第二次迭代（从`mod x²`到`mod x³`）**：
   - **计算`B₀²`**：绿色像素块`[1,1]`闪烁，NTT变换后得到`[1,2,1]`（`(1+x)²=1+2x+x²`）；
   - **计算`A/B₀`**：绿色像素块变成灰色，求逆后得到`[1,-1,0]`（`1/(1+x) ≡ 1 - x mod x³`），和`A=[1,2,1]`相乘得`[1,1,0]`；
   - **合并得到新`B`**：绿色和灰色像素块相加，除以2，得到`[1,1,0]`（最终解，和样例1的输出一致！）。

4. **结束状态**：
   - 绿色像素块闪烁，播放胜利音效，屏幕显示“迭代完成！”的像素文字；
   - 用户可以点击“重置”按钮，重新开始动画。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
多项式开根是“多项式工具箱”的重要成员，掌握它后，你可以解决更多复杂的多项式问题！
</similar_problems_intro>

### 通用思路迁移
多项式牛顿迭代不仅能开根，还能求**逆**、**对数**、**指数**、**快速幂**——核心都是“倍增+迭代式”。比如：
- 多项式求逆：迭代式`C = 2C₀ - A*C₀²`；
- 多项式对数：`ln A = ∫ (A’/A) dx`（需要求导、求逆、积分）；
- 多项式指数：`exp A = Newton迭代求G(B)=B - exp A=0`。

### 洛谷练习推荐
1. **洛谷 P4238** - 多项式求逆  
   * 🗣️ **推荐理由**：多项式开根的前置题，帮你巩固“倍增+牛顿迭代”的求逆实现！
2. **洛谷 P4721** - 多项式对数函数  
   * 🗣️ **推荐理由**：需要用求导、求逆、积分，是多项式开根的“进阶练习”！
3. **洛谷 P4725** - 多项式指数函数  
   * 🗣️ **推荐理由**：牛顿迭代的另一个应用，帮你理解“指数与对数的关系”！
4. **洛谷 P5245** - 多项式快速幂  
   * 🗣️ **推荐理由**：综合应用开根、指数、对数，是多项式操作的“综合测试”！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解的作者们分享了很多宝贵的经验，一起来看看吧！
</insights_intro>

> **经验1（来自Owen_codeisking）**：“多项式开根的核心是牛顿迭代，而牛顿迭代的核心是推导迭代式。一定要先理解数学推导，再写代码！”  
> **点评**：这句话戳中了很多新手的痛点——死记模板容易忘，理解推导才能灵活应用。比如迭代式中的`(B₀² + A)`和`2B₀`，为什么这样组合？因为牛顿迭代的切线法！
> 
> **经验2（来自CYJian）**：“NTT的细节很重要，比如旋转因子的计算、位反转数组的初始化，错一点就会WA（wrong answer）！”  
> **点评**：确实，NTT的实现需要“精准”——比如`g`是3，`gi`是332748118（`3^(mod-2) mod mod`），这些常数不能错！
> 
> **经验3（来自TianTian2008）**：“多项式开根还可以用`exp(0.5*ln A)`实现，这样只需要exp和ln的模板！”  
> **点评**：这是多项式操作的“灵活性”——不同的方法可以达到相同的目的，比如用指数和对数实现开根，适合已经掌握exp和ln的同学。


<conclusion>
本次关于“多项式开根”的分析就到这里啦！多项式操作是算法竞赛中的“高级技巧”，但只要掌握了牛顿迭代和NTT的核心思想，就能一步步攻克它。记住：**数学推导是基础，工程实现是关键**，多写多练才能熟练掌握！下次我们再一起探索更多多项式的奥秘吧！💪
</conclusion>

---
处理用时：195.30秒
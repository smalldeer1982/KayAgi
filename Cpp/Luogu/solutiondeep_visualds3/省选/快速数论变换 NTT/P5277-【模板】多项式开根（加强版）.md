# 题目信息

# 【模板】多项式开根（加强版）

## 题目背景

模板题，无背景

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$ ，求一个在 $\bmod\ {x^n}$ 意义下的多项式 $B(x)$ ，使得 $B^2(x)\equiv A(x)\pmod {x^n}$。

多项式的系数在 $\bmod\ 998244353$ 的意义下进行运算。

## 说明/提示

对于$25\%$的数据，有$n \leq 1000$

对于$50\%$的数据，有$n \leq 10^4$

对于$75\%$的数据，有$n \leq 5\times 10^4$

对于$100\%$的数据，有$n \leq 10^5,a_i \in [0,998244352] \cap \mathbb{Z}$

## 样例 #1

### 输入

```
3
1 2 1
```

### 输出

```
1 1 0```

## 样例 #2

### 输入

```
7
1 8596489 489489 4894 1564 489 35789489  
```

### 输出

```
1 503420421 924499237 13354513 217017417 707895465 411020414
```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】多项式开根（加强版）深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：多项式操作（牛顿迭代法/对数指数变换）

🗣️ **初步分析**：  
我们要找一个多项式 $B(x)$，使得它的平方在“模 $x^n$”下等于给定的 $A(x)$——这就像求“多项式的平方根”。核心思路有两种：  
- **牛顿迭代法**：像“打磨玉器”，先求低精度解（比如只看常数项），再用低精度解推导高精度解（精度从 $x^1$ 翻倍到 $x^2$、$x^4$…直到 $x^n$）。公式是 $B(x) = \frac{1}{2}(B_0(x) + \frac{A(x)}{B_0(x)})$，其中 $B_0$ 是上一步的低精度解。  
- **对数指数法**：像“换个思路算平方”，利用 $B(x) = \exp\left(\frac{1}{2}\ln A(x)\right)$——开根等价于求 $1/2$ 次方，先算 $A$ 的对数，乘以 $1/2$，再算指数。  

**核心难点**：  
1. 求 $A(0)$ 的二次剩余（因为 $B(0)^2 \equiv A(0) \pmod{998244353}$）；  
2. 正确实现多项式求逆、对数、指数等前置模板；  
3. 理解牛顿迭代的“精度翻倍”逻辑。  

**可视化设计思路**：  
用8位像素风格展示多项式系数（像素块位置代表次数，颜色代表值）。牛顿迭代时，一步步展示从低精度到高精度的过程：  
- 初始解（模 $x^1$）：仅显示常数项；  
- 迭代到模 $x^2$：显示 $x^0$ 和 $x^1$ 项，高亮计算 $\frac{A}{B_0}$ 的过程；  
- 最终到模 $x^n$：所有项完成，播放“胜利”音效。  


## 2. 精选优质题解参考

### 题解一：牛顿迭代法（来源：SSerxhs，赞17）  
* **点评**：直接命中核心的模板实现！思路清晰，从常数项二次剩余到迭代公式都写得很完整。代码中 `polysqrt` 函数递归实现牛顿迭代，`mosqrt` 用Cipolla算法求二次剩余，变量名（如 `sqrtf`、`sqrtg`）易懂。实践中效率高，是竞赛常用模板。


### 题解二：对数指数法（来源：周道_Althen，赞6）  
* **点评**：换角度思考的典范！用 $\exp\left(\frac{1}{2}\ln A\right)$ 求开根，还推广到任意次方根。作者用BSGS求常数项的二次剩余（利用原根3），代码中 `Kth_root` 整合了ln、exp和二次剩余，很有启发性。


### 题解三：详细推导+Cipolla（来源：Vocalise，赞5）  
* **点评**：最适合新手的“推导派”题解！从牛顿迭代的泰勒展开讲起，完整实现Cipolla算法求二次剩余，`Sqrt` 函数的递归步骤明确。推导部分能帮你彻底搞懂“为什么牛顿迭代能工作”。


## 3. 核心难点辨析与解题策略

### 核心难点与解决策略

1. **难点1：常数项的二次剩余**  
   - **问题**：必须找到 $B(0)$ 使得 $B(0)^2 \equiv A(0) \pmod{998244353}$。  
   - **解决**：用Cipolla算法：随机选 $a$，让 $a^2 - A(0)$ 是非二次剩余，再用“复数快速幂”计算 $(a + \sqrt{a^2 - A(0)})^{(p+1)/2}$，结果的实部就是解。  
   - 💡 学习笔记：二次剩余是多项式开根的“入门砖”，必须先搞定！


2. **难点2：多项式求逆**  
   - **问题**：牛顿迭代和对数指数法都需要求多项式的逆（比如 $\frac{A}{B_0}$ 是 $A \times B_0^{-1}$）。  
   - **解决**：用牛顿迭代求逆：先求低精度逆，再用公式 $g = g_0 \times (2 - A \times g_0)$ 迭代到高精度。  
   - 💡 学习笔记：多项式求逆是“基石”，一定要掌握！


3. **难点3：牛顿迭代的精度翻倍**  
   - **问题**：为什么公式 $B = \frac{1}{2}(B_0 + \frac{A}{B_0})$ 能把精度从 $x^m$ 提高到 $x^{2m}$？  
   - **解决**：泰勒展开推导：假设 $B_0^2 \equiv A \pmod{x^m}$，要找 $B = B_0 + \Delta$ 满足 $B^2 \equiv A \pmod{x^{2m}}$，代入得 $\Delta = \frac{A - B_0^2}{2B_0}$，所以 $B = \frac{1}{2}(B_0 + \frac{A}{B_0})$。  
   - 💡 学习笔记：精度翻倍是牛顿迭代的核心！


### ✨ 解题技巧总结  
- **模板复用**：提前写好求逆、ln、exp模板，比赛中直接用；  
- **处理前导零**：若 $A(0)=0$，先提岀前导零（$A(x)=x^k C(x)$，$C(0)≠0$），再求 $C$ 的开根，最后补回 $x^{k/2}$；  
- **模数处理**：负数要加模数变正（如 $a - b$ 写成 $(a - b + mod) \% mod$）。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（牛顿迭代法）  
* **说明**：综合Vocalise和SSerxhs的题解，包含Cipolla算法和多项式求逆。  

```cpp
#include <cstdio>
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cstdlib>
#include <ctime>
using namespace std;

typedef long long ll;
const int p = 998244353;
const int inv2 = 499122177; // 2的逆元
const int MAXN = 4e6 + 10;

ll read() {
    ll x = 0, f = 1; char ch = getchar();
    while (ch > '9' || ch < '0') { if (ch == '-') f = -1; ch = getchar(); }
    do x = (x * 10 + ch - 48) % p, ch = getchar(); while (ch >= '0' && ch <= '9');
    return (x * f % p + p) % p;
}

ll fastpow(ll a, int b) {
    ll res = 1; a %= p;
    while (b) {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

int r[MAXN];
ll a[MAXN], b[MAXN], a1[MAXN], b1[MAXN];

void NTT(ll *a, int N, int f) {
    for (int i = 0; i < N; i++) if (i < r[i]) swap(a[i], a[r[i]]);
    for (int n = 2, m = 1; n <= N; m = n, n <<= 1) {
        ll g1 = fastpow(3, (p - 1) / n);
        for (int l = 0; l < N; l += n) {
            ll g = 1, t1, t2;
            for (int i = l; i < l + m; i++) {
                t1 = a[i], t2 = g * a[i + m] % p;
                a[i] = (t1 + t2) % p;
                a[i + m] = (t1 - t2 + p) % p;
                g = g * g1 % p;
            }
        }
    }
    if (f == -1) {
        reverse(a + 1, a + N);
        int invN = fastpow(N, p - 2);
        for (int i = 0; i < N; i++) a[i] = a[i] * invN % p;
    }
}

ll w;
struct Complex {
    ll x, y;
    Complex(ll _x = 0, ll _y = 0) : x(_x), y(_y) {}
    friend Complex operator*(const Complex &a, const Complex &b) {
        return Complex((a.x * b.x % p + w * a.y % p * b.y % p) % p,
                      (a.x * b.y % p + a.y * b.x % p) % p);
    }
};

ll Cipolla(ll x) {
    srand(time(0));
    if (fastpow(x, (p - 1) >> 1) == p - 1) return -1;
    while (true) {
        ll a_val = (1ll * rand() << 15 | rand()) % p;
        w = (a_val * a_val % p + p - x) % p;
        if (fastpow(w, (p - 1) >> 1) == p - 1) {
            ll res = fastpow(Complex(a_val, 1), (p + 1) >> 1).x;
            return min(res, p - res);
        }
    }
}

void Inv(ll *a, ll *b, int n) {
    if (n == 1) { b[0] = fastpow(a[0], p - 2); return; }
    Inv(a, b, (n + 1) >> 1);
    int N = 1, l = -1;
    while (N <= n << 1) N <<= 1, l++;
    for (int i = 1; i < N; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    memcpy(a1, a, n * sizeof(ll)); memset(a1 + n, 0, (N - n) * sizeof(ll));
    NTT(a1, N, 1); NTT(b, N, 1);
    for (int i = 0; i < N; i++) b[i] = ((b[i] << 1) % p + p - a1[i] * b[i] % p * b[i] % p) % p;
    NTT(b, N, -1);
    memset(b + n, 0, (N - n) * sizeof(ll));
}

void Sqrt(ll *a, ll *b, int n) {
    if (n == 1) { b[0] = Cipolla(a[0]); return; }
    Sqrt(a, b, (n + 1) >> 1);
    memset(b1, 0, MAXN * sizeof(ll));
    Inv(b, b1, n);
    int N = 1, l = -1;
    while (N <= n << 1) N <<= 1, l++;
    for (int i = 1; i < N; i++) r[i] = (r[i >> 1] >> 1) | ((i & 1) << l);
    memcpy(a1, a, n * sizeof(ll)); memset(a1 + n, 0, (N - n) * sizeof(ll));
    NTT(a1, N, 1); NTT(b, N, 1); NTT(b1, N, 1);
    for (int i = 0; i < N; i++) b[i] = (b[i] + a1[i] * b1[i] % p) % p * inv2 % p;
    NTT(b, N, -1);
    memset(b + n, 0, (N - n) * sizeof(ll));
}

int main() {
    int n = read();
    for (int i = 0; i < n; i++) a[i] = read();
    Sqrt(a, b, n);
    for (int i = 0; i < n; i++) printf("%lld ", b[i]);
    return 0;
}
```

* **代码解读**：  
  1. **输入处理**：读取多项式 $A$ 的系数；  
  2. **Cipolla算法**：求 $A(0)$ 的二次剩余，作为初始解；  
  3. **牛顿迭代**：`Sqrt` 函数递归求高精度解，每次用 `Inv` 求逆，用NTT做多项式乘法；  
  4. **输出**：打印 $B$ 的系数。


### 题解一核心片段（牛顿迭代）  
* **亮点**：递归实现迭代，处理二次剩余。  
```cpp
void polysqrt(int *f, int *g, int biglim) {
    g[0] = mosqrt(f[0]); // 求f[0]的二次剩余
    for (int i = 2; i <= biglim; i = limit) {
        limit = i << 1;
        polyinv(g, sqrtg, i); // 求g的逆
        dft(sqrtf, 0, limit); dft(sqrtg, 0, limit); dft(g, 0, limit);
        for (int j = 0; j < limit; j++) {
            g[j] = (ll)sqrtg[j] * ((ll)g[j] * g[j] % p + sqrtf[j]) % p;
            g[j] = (g[j] & 1) ? (g[j] + p) >> 1 : g[j] >> 1; // 除以2
        }
        dft(g, i, limit);
    }
}
```
* **解读**：  
  - `g[0] = mosqrt(f[0])`：初始解（模 $x^1$）；  
  - 循环迭代：每次精度翻倍，求逆后计算新的 $g$。


### 题解二核心片段（对数指数法）  
* **亮点**：推广到任意次方根。  
```cpp
void Kth_root(int *a, int *b, int len, int K) {
    Logarithmic(a, s_a, len); // 算ln(a)
    int Kr = Inv(K); // K的逆元（这里K=2）
    for (int i = 1; i <= len; i++) s_a[i] = 1ll * s_a[i] * Kr % mod; // ln(a)/2
    b[0] = solve(a[0], K); // 求a[0]的二次剩余
    Exponential(s_a, b, len); // 算exp(ln(a)/2)
}
```
* **解读**：  
  - 先算对数，再乘以 $1/2$，最后算指数，得到开根结果。


## 5. 算法可视化：像素动画演示（牛顿迭代版）

### 动画设计思路  
用**8位像素风**（FC游戏风格）展示迭代过程，让你“看得到”精度提升。


### 动画细节（以样例1为例）  
1. **初始状态**：背景是深蓝色，顶部显示“多项式开根模拟器”，底部有“开始”“单步”“重置”按钮。  
2. **模 $x^1$**：仅显示 $x^0$ 的像素块（亮白色，值1），弹出文字“初始解：B₀(0)=1”，播放“叮”音效。  
3. **模 $x^2$**：  
   - 显示 $B₀=[1,0]$（白色），然后显示 $A/B₀=[1,2]$（浅蓝色）；  
   - 相加得到 $[2,2]$（播放“哗啦”音效），除以2得到 $[1,1]$（亮绿色）；  
   - 文字：“第一次迭代：B₁=[1,1]”。  
4. **模 $x^3$**：  
   - 显示 $B₁=[1,1,0]$（绿色），$A/B₁=[1,1,0]$（浅蓝色）；  
   - 相加得到 $[2,2,1]$，除以2得到 $[1,1,0]$（亮黄色）；  
   - 播放“胜利”音效，所有块闪烁，文字：“完成！B=[1,1,0]”。


### 交互设计  
- **单步**：一步步看迭代过程；  
- **自动播放**：调节速度（慢→快）；  
- **重置**：回到初始状态。


## 6. 拓展练习与相似问题思考

### 思路迁移  
多项式开根的方法可推广到：  
- 多项式求逆（$B \times A \equiv 1 \pmod{x^n}$）；  
- 多项式幂函数（$A^k \pmod{x^n}$，$k$ 为分数）；  
- 多项式除法（$A/B \pmod{x^n}$）。


### 洛谷练习推荐  
1. **P5205 【模板】多项式开根**：基础模板题，练牛顿迭代；  
2. **P4238 【模板】多项式求逆**：前置模板，必须掌握；  
3. **P5273 【模板】多项式幂函数（加强版）**：练对数指数法；  
4. **P3803 【模板】多项式乘法（FFT）**：NTT的基础。


## 7. 学习心得与经验分享  
- **SSerxhs**：“处理前导零时要左移k/2位”——教训：遇到前导零要先提出来；  
- **周道_Althen**：“优化模板常数很重要”——技巧：用快速NTT实现；  
- **Vocalise**：“rand()相乘随机性差”——技巧：用 `rand()<<15 | rand()` 生成大随机数。


## 结语  
多项式开根是多项式算法的“入门钥匙”，掌握它能帮你理解更复杂的操作。记住：**模板是基础，推导是关键**——不要死记代码，要搞懂每一步的逻辑！  

下次我们会探索多项式求逆的细节，加油！💪

---
处理用时：278.32秒
# 题目信息

# 【模板】子集卷积

## 题目背景

这是一道模板题。

## 题目描述

给定两个长度为 $2^n$ 的序列 $a_0,a_1,\cdots,a_{2^n-1}$ 和 $b_0,b_1,\cdots,b_{2^n-1}$，你需要求出一个序列 $c_0,c_1,\cdots,c_{2^n-1}$，其中 $c_k$ 满足：

$$c_k=\sum_{\substack{{i \& j=0}\\{i~\mid~ j=k}}} a_i b_j$$

其中$~\mid~$表示按位或，$\&$表示按位与。

答案对 $10^9+9$ 取模。

## 说明/提示

对于所有数据，$1\le n\le 20$，$0\le a_i,b_i< 10^9+9$。

## 样例 #1

### 输入

```
2
1 0 2 1
2 0 2 1```

### 输出

```
2 0 6 3```

# AI分析结果

# 💡 Kay的C++算法解析：子集卷积 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（集合幂级数与FMT变换）`

🗣️ **初步分析**：  
我们可以把每个数字的二进制位看成一个「集合」——比如数字`5`（二进制`101`）代表包含元素`0`和`2`的集合。题目要求的`c_k`，其实是**找两个不重叠的小集合（i和j，即i&j=0），拼起来正好是大集合k（i|j=k），然后把它们的乘积加起来**。这就像拼积木：只有两块积木完全不重叠，才能刚好拼成一块大积木，我们要算所有这样的拼法的总重量。

解决这个问题的核心技巧是「**用二进制中1的个数（popcount）拆分问题**」+「**FMT（快速莫比乌斯变换）处理或卷积**」：  
- **popcount拆分**：两个集合不重叠的条件等价于「它们的1的个数之和等于大集合的1的个数」（比如i有2个1，j有3个1，拼起来的k必须有5个1）。我们可以把原序列按popcount拆成多个维度（比如`a[i][s]`表示集合s有i个1时的a_s值）。  
- **FMT处理或卷积**：对于每个popcount维度，用FMT快速计算「所有子集的贡献和」，这样就能高效算出任意两个维度的或卷积（即拼起来的集合的总贡献）。  

**可视化设计思路**：我们可以用「像素集合网格」展示每个数字对应的集合（比如用不同颜色的像素块代表不同popcount的集合）。FMT过程中，高亮当前处理的二进制位，展示子集的累加（比如红色像素块扩散到所有包含它的子集）；卷积过程中，展示不同popcount维度的像素块相乘，最后合并成目标集合的像素块（绿色高亮）。动画还会加入「拼积木成功」的音效（比如“咔嗒”声），以及「完成卷积」的胜利音效。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、原理讲解详细度等方面筛选了以下优质题解，帮你快速抓住核心：
</eval_intro>

### 题解一：EternalAlexander（赞：48）  
* **点评**：此题解是子集卷积的「标准模板」，思路直接命中核心——用popcount拆分维度，对每个维度做FMT，再按维度卷积。代码简洁规范，变量命名清晰（比如`a[ctz(i)][i]`直接用`ctz`（popcount的简写）作为维度索引），甚至吐槽了题目卡常的问题，非常接地气。其FMT函数的实现是经典的「按位累加子集」，容易理解和复用。

### 题解二：yijan（赞：27）  
* **点评**：此题解是「原理派天花板」——不仅详细推导了FMT的数学公式（比如或卷积的FMT性质），还一步步解释了子集卷积的转化过程（从或卷积到带popcount约束的卷积）。代码中`a[__builtin_popcount(i)][i]`的初始化方式直接对应popcount拆分，FMT后的卷积和逆变换逻辑完整，适合想深入理解原理的同学。

### 题解三：EnofTaiPeople（赞：5）  
* **点评**：此题解是「常数优化大师」——用快速读入（`fast_rd::read`）替代`cin`，用位运算优化popcount计算（`pct[i]=pct[i>>1]+(i&1)`），甚至在FMT循环中合并了`f`和`g`的变换，减少了重复代码。其代码的运行效率很高（最慢点1.82s），适合学习「如何写出能过卡常题的代码」。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决子集卷积问题，最容易卡壳的是「如何把数学条件转化为代码逻辑」。以下是三个核心难点及破解方法：
</difficulty_intro>

### 1. 如何将「i&j=0」转化为可计算的条件？  
* **分析**：直接枚举所有i和j判断`i&j=0`会超时（复杂度O(4^n)）。但我们发现：`i&j=0`等价于`popcount(i)+popcount(j)=popcount(i|j)`（两个不重叠的集合，元素个数相加等于合并后的集合大小）。  
* **解决方案**：把原序列按popcount拆分成二维数组（比如`a[k][s]`表示集合s有k个元素时的a_s值），这样只需要在卷积时让`k1+k2=k`，就能保证i和j不重叠。  
* 💡 **学习笔记**：用popcount把「不重叠」的条件转化为「维度相加」，是子集卷积的关键突破口！

### 2. 如何高效计算带popcount约束的或卷积？  
* **分析**：普通或卷积（`c_k=Σ_{i|j=k}a_i b_j`）可以用FMT快速计算，但带popcount约束后，需要对每个维度单独处理。  
* **解决方案**：对每个popcount维度的数组做FMT（得到子集和），然后按维度相乘（比如`c[x][s] += a[i][s] * b[x-i][s]`），最后对每个维度做逆FMT得到结果。  
* 💡 **学习笔记**：FMT的「可加性」让我们可以对每个维度单独处理，再合并结果——这是集合幂级数的核心性质！

### 3. FMT的正变换和逆变换如何实现？  
* **分析**：FMT的正变换是「求所有子集的和」（比如`A[s] = Σ_{t⊆s} a_t`），逆变换是「从子集和恢复原数组」。  
* **解决方案**：正变换按二进制位从小到大处理，对每个位，将当前位为1的数加上对应位为0的数（比如`a[j+k+i] += a[j+k]`）；逆变换则反过来，减去对应的值（比如`a[j+k+i] -= a[j+k]`）。  
* 💡 **学习笔记**：FMT的本质是「高维前缀和」，按位处理是为了避免重复计算！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个综合了优质题解思路的「通用核心实现」，帮你建立整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码综合了EternalAlexander、yijan等题解的思路，保留了最核心的FMT变换和维度卷积逻辑，适合作为模板使用。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
using namespace std;

const int mod = 1e9 + 9;
int n, lim;
int a[22][1 << 21], b[22][1 << 21], c[22][1 << 21];

// FMT正变换（求子集和）
void fmt(int *arr) {
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < lim; ++j)
            if (j & (1 << i))
                arr[j] = (arr[j] + arr[j ^ (1 << i)]) % mod;
}

// FMT逆变换（恢复原数组）
void ifmt(int *arr) {
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < lim; ++j)
            if (j & (1 << i))
                arr[j] = (arr[j] - arr[j ^ (1 << i)] + mod) % mod;
}

int main() {
    scanf("%d", &n);
    lim = 1 << n;
    for (int i = 0; i < lim; ++i) {
        int x; scanf("%d", &x);
        a[__builtin_popcount(i)][i] = x;
    }
    for (int i = 0; i < lim; ++i) {
        int x; scanf("%d", &x);
        b[__builtin_popcount(i)][i] = x;
    }
    // 对每个popcount维度做FMT
    for (int i = 0; i <= n; ++i) {
        fmt(a[i]);
        fmt(b[i]);
    }
    // 按维度卷积
    for (int x = 0; x <= n; ++x)
        for (int i = 0; i <= x; ++i)
            for (int j = 0; j < lim; ++j)
                c[x][j] = (c[x][j] + 1LL * a[i][j] * b[x - i][j]) % mod;
    // 逆变换得到结果
    for (int i = 0; i <= n; ++i)
        ifmt(c[i]);
    // 输出结果（取对应popcount的维度）
    for (int i = 0; i < lim; ++i)
        printf("%d ", c[__builtin_popcount(i)][i]);
    return 0;
}
```  
* **代码解读概要**：  
  1. **输入处理**：读取n和序列a、b，按popcount拆分成二维数组（比如`a[k][s]`表示集合s有k个元素的a_s值）。  
  2. **FMT变换**：对每个popcount维度的数组做FMT，得到子集和。  
  3. **维度卷积**：枚举所有可能的popcount组合（i + (x-i) = x），按位相乘得到卷积结果。  
  4. **逆变换**：对每个维度的卷积结果做逆FMT，恢复原数组。  
  5. **输出**：取每个集合s对应的popcount维度的结果（`c[popcount(s)][s]`）。


### 针对各优质题解的片段赏析

#### 题解一：EternalAlexander（来源：综合题解）  
* **亮点**：用`ctz`（`__builtin_popcount`的简写）直接作为维度索引，代码更简洁。  
* **核心代码片段**：  
```cpp
int ctz(int x) { return __builtin_popcount(x); }
// 输入处理
for (int i = 0; i < n; ++i)
    scanf("%d", &a[ctz(i)][i]);
for (int i = 0; i < n; ++i)
    scanf("%d", &b[ctz(i)][i]);
```  
* **代码解读**：  
  `ctz`函数是`__builtin_popcount`的别名，直接返回数字的二进制1的个数。输入时，将a[i]存入`a[ctz(i)][i]`，相当于按popcount自动拆分维度——这一步把「手动计算popcount」的工作交给了编译器，代码更简洁。  
* 💡 **学习笔记**：用函数别名简化常用操作，能让代码更易读！

#### 题解二：yijan（来源：综合题解）  
* **亮点**：详细的FMT实现，直接对应「子集和」的定义。  
* **核心代码片段**：  
```cpp
void FMT(int A[], int l) {
    for (int i = 0; i < l; ++i)
        for (int j = 0; j < (1 << l); ++j)
            if (j & (1 << i))
                A[j] = (A[j] + A[j ^ (1 << i)]) % P;
}
```  
* **代码解读**：  
  这段FMT函数的逻辑是：按二进制位从小到大处理（i从0到l-1），对每个数j，如果j的第i位是1，就把j去掉第i位后的值（j^(1<<i)）加到j上。这正好对应「求所有子集的和」——比如j的第i位是1，那么j^(1<<i)是j的子集，把它的贡献加进来。  
* 💡 **学习笔记**：FMT的本质是「按位累加子集」，这段代码是最经典的实现方式！

#### 题解三：EnofTaiPeople（来源：综合题解）  
* **亮点**：用快速读入优化输入速度，适合卡常题。  
* **核心代码片段**：  
```cpp
namespace fast_rd {
    const int R = 1e5 + 5;
    char buf[R + 5], c;
    int it, ed, f;
    inline void read(int &x) {
        for (f = 0, c = gc; c < 48; c = gc) if (c == '-') f = !f;
        for (x = 0; c > 47; x = x * 10 + (48 ^ c), c = gc); if (f) x = -x;
    }
}
using fast_rd::read;
```  
* **代码解读**：  
  这段快速读入代码直接从缓冲区读取字符，避免了`cin`的流同步开销。对于大输入（比如2^20=1e6的数据），能显著提升速度。其中`48^c`是快速将字符转换为数字的技巧（比如'0'的ASCII是48，`48^'0'=0`，`48^'1'=1`）。  
* 💡 **学习笔记**：卡常题的输入优化，快读是必备技巧！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地「看到」子集卷积的过程，我设计了一个**像素积木拼接游戏**动画，用复古8位像素风展示集合的拆分与合并：
</visualization_intro>

### 动画演示主题  
**「像素积木大师」**——你需要用两个不重叠的像素积木（代表集合i和j）拼出目标积木（代表集合k），动画会展示FMT如何计算所有子集的贡献，以及卷积如何合并结果。

### 设计思路简述  
采用8位像素风是为了营造「复古游戏」的轻松氛围，让学习像玩游戏一样有趣。每个集合用**不同颜色的像素块**表示（比如红色代表popcount=2的集合，蓝色代表popcount=3的集合），FMT过程像「积木扩散」（红色积木的贡献扩散到所有包含它的大积木），卷积过程像「积木拼接」（红色和蓝色积木拼成紫色积木）。关键操作会伴随「咔嗒」声（子集累加）、「叮」声（卷积相乘），完成时会有「胜利号角」声，增强记忆点。


### 动画帧步骤与交互关键点  

1. **场景初始化**：  
   - 屏幕左侧是「集合网格」（用8x8像素块代表每个集合，比如数字5对应`101`的像素块）。  
   - 屏幕右侧是「控制面板」：包含「开始/暂停」「单步执行」「重置」按钮，以及「速度滑块」（控制动画播放速度）。  
   - 背景播放8位风格的轻松BGM（比如《超级马里奥》的背景音乐）。

2. **数据初始化**：  
   - 输入n=2（对应4个集合：00、01、10、11），序列a=[1,0,2,1]，b=[2,0,2,1]（样例输入）。  
   - 每个集合的像素块按popcount染色（比如00=黑色，01=红色，10=红色，11=蓝色）。

3. **FMT变换演示**：  
   - **处理第0位**：高亮所有第0位为1的集合（01、11），将它们的贡献加到对应的子集（比如01的贡献加到11）——红色像素块扩散到蓝色像素块，伴随「咔嗒」声。  
   - **处理第1位**：高亮所有第1位为1的集合（10、11），将它们的贡献加到对应的子集（比如10的贡献加到11）——红色像素块再次扩散到蓝色像素块，伴随「咔嗒」声。  
   - 此时，每个集合的像素块亮度代表子集和的大小（越亮表示贡献越大）。

4. **维度卷积演示**：  
   - **枚举popcount组合**：比如x=2（目标集合的popcount=2），枚举i=0和j=2、i=1和j=1、i=2和j=0。  
   - **按位相乘**：比如集合11（popcount=2）的a值是1，b值是1，相乘得到1——蓝色像素块变成紫色，伴随「叮」声。  
   - 所有组合处理完后，紫色像素块的亮度代表卷积结果的大小。

5. **逆变换与结果展示**：  
   - 对每个维度的卷积结果做逆FMT（减去子集的贡献），恢复原数组——紫色像素块的亮度调整为最终结果。  
   - 目标集合k=11（二进制11）的结果是3（样例输出），此时紫色像素块闪烁，伴随「胜利号角」声，屏幕显示「拼接成功！」。


### 交互控制  
- **单步执行**：点击「单步」按钮，动画执行一步（比如处理一个二进制位，或一个popcount组合）。  
- **自动播放**：拖动「速度滑块」调整播放速度，点击「开始」按钮，动画自动执行所有步骤。  
- **重置**：点击「重置」按钮，回到初始状态，重新开始演示。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
子集卷积是「集合幂级数」的基础操作，掌握它后，你可以解决更多复杂的集合问题：
</similar_problems_intro>

### 通用思路迁移  
子集卷积的核心是「用popcount拆分维度+FMT处理或卷积」，这个思路可以迁移到：  
1. **求两个集合的不重叠并的贡献和**（比如统计所有不重叠的子集对的乘积和）。  
2. **集合幂级数的其他卷积**（比如对称差卷积，但需要用FWT处理异或变换）。


### 洛谷练习推荐  

1. **P4717 【模板】快速莫比乌斯/沃尔什变换 (FMT/FWT)**  
   - 🗣️ **推荐理由**：这是FMT/FWT的基础模板题，帮你巩固「子集和」「异或和」的变换逻辑。

2. **P5387 [Cnoi2019] 人形演武**  
   - 🗣️ **推荐理由**：这题需要用子集卷积处理集合的合并问题，是子集卷积的实际应用。

3. **P6102 [Emiya 家今天的饭] 加强版**  
   - 🗣️ **推荐理由**：这题需要用集合幂级数的卷积优化动态规划，是子集卷积的进阶应用。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我总结了几个「踩坑教训」，帮你避免走弯路：
</insights_intro>

> **参考经验（来自多位题解作者）**：  
> 1. **popcount的计算**：一定要用`__builtin_popcount`（编译器内置函数），不要自己写循环计算——内置函数的速度比手写快10倍以上！  
> 2. **FMT的逆变换**：逆变换时要加`mod`再取模（比如`(arr[j] - arr[j ^ (1 << i)] + mod) % mod`），否则会出现负数。  
> 3. **卡常技巧**：对于n=20的情况（2^20=1e6），输入输出一定要用快读快写，否则会超时！


## 8. 总结  

子集卷积的核心是「用popcount拆分维度+FMT处理或卷积」——把「不重叠的集合合并」转化为「维度相加的卷积」，再用FMT快速计算。通过本次学习，你不仅掌握了子集卷积的模板代码，还理解了背后的数学原理（集合幂级数、FMT变换），以及卡常技巧（快读、内置函数）。

记住：编程像拼积木，只要把大问题拆成小问题，再找到合适的工具（比如FMT），再难的题也能解决！下次我们一起探索更复杂的集合幂级数问题吧！💪

---
处理用时：125.14秒
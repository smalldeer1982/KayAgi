# 题目信息

# [省选联考 2022] 卡牌

## 题目描述

小 A 有 $n$ 张卡牌，编号为 $1, 2, \ldots, n$。每张卡牌上写着一个正整数，第 $i$ 张卡牌上的正整数为 $s_i$。

现在有 $m$ 轮游戏，第 $i$ 轮游戏会给出 $c_i$ 个质数，小 A 需要选择任意多张卡牌，使得这些卡牌上面的正整数的乘积能被该轮游戏给出的每个质数整除。

这当然难不倒小 A，于是他开始思考一个更难的问题，对于每一轮游戏，他有多少种卡牌的选法。

这给小 A 整不会了，于是他只能来求助你，你只需要告诉他答案模 $998244353$ 的值即可。两种选法 A 和 B 互不相同当且仅当存在一张卡牌在 A 中被选择但在 B 中未被选择或者存在一张卡牌在 B 中被选择但在 A 中未被选择。注意：牌面上的数字相同但编号不相同的两张卡牌被视为不同的卡牌。

## 说明/提示

**【样例解释 #1】**

第一轮游戏：除了以下 $5$ 种方案外其它方案都可行：什么都不选、选 $2$、选 $5$、选 $46$、选 $2$ 和 $46$。所以答案为 $2^5 - 5 = 27$。

第二轮游戏：只要选了 $46$，其它卡牌选不选均可，所以答案为 $2^4 = 16$。

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le {10}^6$，$1 \le s_i \le 2000$，$1 \le m \le 1500$，$1 \le c_i, \sum_i c_i \le 18000$，$2 \le p_{i, j} \le 2000$。

| 测试点 | $n \le$ | $m \le$ | $\sum_i c_i \le$ | 其他限制 |
|:-:|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | $10$ | $20$ | $s_i \le 30$ |
| $3 \sim 5$ | $10$ | $20$ | $50$ | 无 |
| $6 \sim 8$ | ${10}^6$ | $1500$ | $10000$ | $s_i \le 30$ |
| $9 \sim 11$ | $10000$ | $1000$ | $5000$ | $s_i \le 500$ |
| $12 \sim 13$ | $1000$ | $100$ | $1000$ | 无 |
| $14 \sim 17$ | $5000$ | $600$ | $7000$ | 无 |
| $18 \sim 20$ | ${10}^6$ | $1500$ | $18000$ | 无 |

## 样例 #1

### 输入

```
5
10 2 10 5 46
4
2 2 5
2 2 23
1 3
1 23```

### 输出

```
27
16
0
16```

## 样例 #2

### 输入

```
见附件中的 card/card2.in```

### 输出

```
见附件中的 card/card2.ans```

# AI分析结果

# 💡 Kay的C++算法解析：[省选联考2022]卡牌 深入学习指南 💡

## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：根号分治 + 状压DP + 容斥原理

🗣️ **初步分析**：  
解决“卡牌”问题的核心，就像**用“钥匙串”开“组合锁”**——我们把小质数（≤41，共13个）做成“钥匙串”（状压成二进制数），大质数（>41）当成“单独的锁”（每个数最多含一个，独立处理）。要打开所有“锁”（覆盖给定质数），需要：  
1. **状压小质数**：用13位二进制数表示小质数的覆盖状态（比如`101`表示覆盖了第1、3个小质数）；  
2. **根号分治**：大质数无法状压，但每个数最多含一个大质数，所以可以“单独算账”；  
3. **容斥原理**：直接算“覆盖所有质数”的方案数太难，我们用“总方案数 - 不覆盖某些质数的方案数 + 不覆盖某些质数的方案数……”来间接计算。

### 核心算法流程与可视化设计思路  
- **预处理**：统计每个数的小质数状压值，以及每个大质数的出现次数；  
- **容斥枚举**：枚举小质数的不覆盖子集，计算对应的合法方案数，用容斥系数调整（奇减偶加）；  
- **大质数处理**：对于每个大质数，若需要覆盖，则必须选至少一个其倍数（方案数为`2^count - 1`）；否则选不选都行（方案数为`2^count`）。  

**可视化设计**：  
- 用**8位像素风**展示：小质数状压状态用“像素钥匙串”（不同颜色的方块表示不同质数），大质数用“像素锁”；  
- **关键步骤高亮**：容斥枚举时，当前不覆盖的小质数用“红色闪烁”，大质数的处理用“蓝色滑动”；  
- **音效**：状压状态变化时“叮”一声，大质数处理完成时“咔嗒”一声，最终答案出现时“胜利音效”。


## 2. 精选优质题解参考

### 题解一：（来源：lg_zhou，赞59）  
* **点评**：这份题解把“正难则反”的容斥思想用得很透！先预处理小质数的状压状态和大质数的计数，然后通过枚举小质数的不覆盖子集，结合大质数的强制选择，快速计算合法方案数。代码里`tt[j]`统计不覆盖小质数子集`j`的数的总数，`f[j][k]`统计这些数中是大质数`k`倍数的数量，逻辑清晰，预处理和查询的分工明确，很适合初学者理解“容斥+分治”的结合。

### 题解二：（来源：Alex_Wei，赞19）  
* **点评**：这道题的“FWT+状压”写法很惊艳！把每个数的小质数状压值转化为“集合幂级数”，用FWT（快速沃尔什变换）快速计算或卷积（覆盖所有质数的方案数）。对于大质数，通过“除掉空集贡献”来强制选择，代码里`h[j]`的点值变换和IFWT（逆变换）的处理很巧妙，把复杂的集合运算转化为简单的点乘，效率很高。

### 题解三：（来源：zmx_wzx_JY，赞1）  
* **点评**：这份题解的“预处理+容斥”写法很扎实！预处理`g[S]`（不覆盖小质数子集`S`的数的总数）和`f[S][i]`（这些数中是大质数`i`倍数的数量），查询时直接枚举小质数的子集，结合大质数的处理计算答案。代码里`qp`（2的幂）和`iqp`（逆元）的预处理很实用，容斥的循环逻辑直接对应数学公式，容易验证正确性。


## 3. 核心难点辨析与解题策略

### 1. 难点1：小质数的状压处理  
- **问题**：小质数有13个，状压成`2^13=8192`种状态，如何高效统计每个状态的数的数量？  
- **解决**：预处理时，对每个小质数子集`S`，用埃氏筛的方式标记不允许出现的数（属于`S`中的质数的倍数），然后统计剩下的数的总数（`g[S]`）。

### 2. 难点2：大质数的独立处理  
- **问题**：大质数有很多，但每个数最多含一个大质数，如何快速计算它们的贡献？  
- **解决**：预处理时，对每个大质数`p`，统计不覆盖小质数子集`S`的数中是`p`倍数的数量（`f[S][p]`）。查询时，若需要覆盖`p`，则方案数为`2^f[S][p] - 1`（至少选一个）；否则为`2^f[S][p]`（选不选都行）。

### 3. 难点3：容斥原理的正确应用  
- **问题**：如何用容斥计算“覆盖所有给定质数”的方案数？  
- **解决**：枚举小质数的不覆盖子集`S`，若`S`是给定小质数集合的子集，则计算该子集对应的方案数（大质数的贡献×剩余数的贡献），然后用容斥系数（`(-1)^{|S|}`）调整（奇减偶加）。

### ✨ 解题技巧总结  
- **根号分治**：把质数分成小质数（状压）和大质数（独立处理），解决状态爆炸问题；  
- **预处理优先**：提前计算所有小质数子集的数的数量和大质数的计数，减少查询时的重复计算；  
- **正难则反**：用容斥计算“不合法方案数”，再用总方案数减去不合法方案数，简化问题。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合lg_zhou和zmx_wzx_JY的题解思路，提炼出“预处理+容斥”的核心实现，结构清晰，容易理解。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>
using namespace std;

const int MOD = 998244353;
const int MAX_S = 2005;
const int MAX_PRIME = 13; // 小质数数量（≤41）
const int MAX_STATE = 1 << MAX_PRIME; // 8192

int n, m;
int va[MAX_S]; // va[i]：数i的出现次数
int prim[MAX_PRIME] = {2,3,5,7,11,13,17,19,23,29,31,37,41}; // 小质数列表
int id[MAX_S]; // id[p]：质数p的编号（小质数0~12，大质数≥13）
int pct; // 总质数数量
bool ish[MAX_S]; // 标记是否为质数
int g[MAX_STATE]; // g[S]：不覆盖小质数子集S的数的总数
int f[MAX_STATE][305]; // f[S][k]：不覆盖S的数中是大质数k倍数的数量
int bc[MAX_STATE]; // bc[S]：子集S的大小（容斥系数用）
long long qp[1000005]; // qp[i] = 2^i mod MOD
long long iqp[1000005]; // iqp[i] = (2^i)^(-1) mod MOD

// 快速幂求逆元
long long pow_mod(long long a, long long b) {
    long long res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

// 预处理质数编号
void init_primes() {
    memset(ish, 0, sizeof(ish));
    pct = 0;
    // 筛所有≤2000的质数
    for (int i = 2; i < MAX_S; ++i) {
        if (!ish[i]) {
            id[i] = pct++;
            for (int j = i; j < MAX_S; j += i) {
                ish[j] = 1;
            }
        }
    }
    // 重新标记小质数的编号（0~12）
    for (int i = 0; i < MAX_PRIME; ++i) {
        id[prim[i]] = i;
    }
}

// 预处理g和f数组
void precompute() {
    // 预处理qp和iqp
    qp[0] = 1;
    for (int i = 1; i <= 1000000; ++i) {
        qp[i] = qp[i-1] * 2 % MOD;
    }
    iqp[0] = 1;
    iqp[1] = pow_mod(2, MOD-2);
    for (int i = 2; i <= 1000000; ++i) {
        iqp[i] = iqp[i-1] * iqp[1] % MOD;
    }

    // 预处理g和f
    memset(g, 0, sizeof(g));
    memset(f, 0, sizeof(f));
    memset(bc, 0, sizeof(bc));

    for (int S = 0; S < MAX_STATE; ++S) {
        // 计算bc[S]（子集大小）
        bc[S] = __builtin_popcount(S);
        // 标记不允许出现的数（属于S中的小质数的倍数）
        bool vs[MAX_S] = {false};
        for (int i = 0; i < MAX_PRIME; ++i) {
            if (S & (1 << i)) {
                for (int x = prim[i]; x < MAX_S; x += prim[i]) {
                    vs[x] = true;
                }
            }
        }
        // 计算g[S]：不覆盖S的数的总数
        for (int x = 1; x < MAX_S; ++x) {
            if (!vs[x]) {
                g[S] += va[x];
            }
        }
        // 计算f[S][k]：不覆盖S的数中是大质数k倍数的数量
        for (int k = MAX_PRIME; k < pct; ++k) {
            int prime = 0;
            // 找到大质数k对应的质数（因为id[prime] = k）
            for (int x = 2; x < MAX_S; ++x) {
                if (id[x] == k) {
                    prime = x;
                    break;
                }
            }
            for (int x = prime; x < MAX_S; x += prime) {
                if (!vs[x]) {
                    f[S][k] += va[x];
                }
            }
        }
    }
}

// 处理一个查询
int solve() {
    int c;
    cin >> c;
    vector<int> query(c);
    for (int i = 0; i < c; ++i) {
        cin >> query[i];
    }
    // 去重
    sort(query.begin(), query.end());
    query.erase(unique(query.begin(), query.end()), query.end());
    c = query.size();

    // 计算小质数的目标集合（需要覆盖的小质数）
    int target_small = 0;
    vector<int> big_primes; // 需要覆盖的大质数
    for (int p : query) {
        int idx = id[p];
        if (idx < MAX_PRIME) {
            target_small |= (1 << idx);
        } else {
            big_primes.push_back(idx);
        }
    }

    long long ans = 0;
    // 枚举小质数的不覆盖子集S（必须是target_small的子集）
    for (int S = 0; S < MAX_STATE; ++S) {
        if ((S | target_small) != target_small) continue;
        // 计算当前子集S的方案数：2^g[S] * 乘积（对于每个大质数k，2^f[S][k]-1）
        long long cnt = qp[g[S]];
        for (int k : big_primes) {
            long long cnt_k = f[S][k];
            cnt = cnt * iqp[cnt_k] % MOD; // 除以2^cnt_k（即乘逆元）
            cnt = cnt * (qp[cnt_k] - 1 + MOD) % MOD; // 乘(2^cnt_k - 1)
        }
        // 容斥系数：(-1)^|S|
        if (bc[S] % 2 == 1) {
            ans = (ans - cnt + MOD) % MOD;
        } else {
            ans = (ans + cnt) % MOD;
        }
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);

    // 读取输入：n张卡牌，统计每个数的出现次数
    int card_cnt;
    cin >> card_cnt;
    memset(va, 0, sizeof(va));
    for (int i = 0; i < card_cnt; ++i) {
        int x;
        cin >> x;
        va[x]++;
    }

    // 初始化质数编号
    init_primes();
    // 预处理g和f数组
    precompute();

    // 处理m个查询
    int m;
    cin >> m;
    while (m--) {
        cout << solve() << '\n';
    }

    return 0;
}
```
* **代码解读概要**：  
  1. **预处理**：`init_primes`标记质数编号，`precompute`计算小质数子集的数的总数`g[S]`和大质数的计数`f[S][k]`，同时预处理`qp`（2的幂）和`iqp`（逆元）；  
  2. **查询处理**：`solve`函数读取查询的质数，计算需要覆盖的小质数集合`target_small`和大质数列表`big_primes`，枚举小质数的不覆盖子集`S`，结合容斥系数计算合法方案数；  
  3. **核心逻辑**：通过“不覆盖子集的方案数×容斥系数”的总和，得到“覆盖所有质数的方案数”，其中大质数的强制选择用`(2^cnt_k - 1)`（至少选一个）实现。


### 题解一：（来源：lg_zhou）  
* **亮点**：用“预处理+容斥”快速计算不覆盖子集的方案数，`tt[j]`和`f[j][k]`的分工明确，查询时的循环逻辑直接对应容斥公式。  
* **核心代码片段**：  
```cpp
// 预处理tt[j]和f[j][k]
for (int i = 0; i < (1<<13); i++){//枚举不含哪些小质数
    for (int j = 2; j <= 2000; j++){
        if ( (q[j]&i) ) continue; // 含小质数i，跳过
        f[i][v[j][v[j].size()-1]] += a[j]; // 统计大质数的数量
        tt[i] += a[j];
    }
    tt[i] += a[1]; // 加上数1的数量
}

// 查询时的容斥计算
for (int j = 0; j < (1<<13); j++){
    if ( (j|less) != less) continue; // 不是目标小质数的子集
    int ct = tt[j]; // 不覆盖j的数的总数
    ans = 1;
    for (int k = 0; k < c; k++){
        if (hvp[k] <= 41) continue; // 小质数已处理
        (ans *= (ksm(2,f[j][hsp[hvp[k]]])-1)) %= MOD; // 大质数必须选
        ct -= f[j][hsp[hvp[k]]];
    }
    (ans *= ksm(2,ct)) %= MOD; // 剩下的选不选都行
    // 容斥系数
    int cnt1 = __builtin_popcount(j);
    if (cnt1&1) (edans -= ans) %= MOD;
    else (edans += ans) %= MOD;
}
```
* **代码解读**：  
  - `q[j]`是数`j`的小质数状压值，`v[j][v[j].size()-1]`是数`j`的大质数编号；  
  - `tt[j]`统计不覆盖小质数`j`的数的总数，`f[j][k]`统计这些数中是大质数`k`倍数的数量；  
  - 查询时，`less`是目标小质数的状压值，枚举`j`（不覆盖的小质数子集），计算`ans`（当前子集的方案数），用`cnt1`（子集大小）判断容斥系数（加或减）。  
* **学习笔记**：预处理时把“不覆盖子集的数的数量”和“大质数的计数”算好，查询时直接组合这些结果，能大幅减少重复计算！


### 题解二：（来源：Alex_Wei）  
* **亮点**：用FWT快速计算或卷积，把“覆盖所有质数的方案数”转化为集合幂级数的点乘，效率很高。  
* **核心代码片段**：  
```cpp
// 预处理每个数的小质数状压值和大质数的计数
for(int i = 1; i < N; i++) {
    if(!buc[i]) continue;
    int tmp = i, msk = 0;
    for(int j = 0; j < 13; j++) while(tmp % P[j] == 0) tmp /= P[j], msk |= 1 << j;
    for(int j = 0; j < V; j++) if((j & msk) == msk) f[j] += buc[i]; // 小质数状压的幂次
    if(tmp > 1) for(int j = 0; j < V; j++) if((j & msk) == msk) g[tmp][j] += buc[i]; // 大质数的计数
}

// 查询时的FWT处理
for(int k = 1; k < V; k <<= 1) for(int i = 0; i < V; i += k << 1) for(int j = 0; j < k; j++) sub(h[i | j | k], h[i | j]); // IFWT
for(int j = 0; j < V; j++) if((msk & j) == msk) add(ans, h[j]); // 统计覆盖所有小质数的方案数
```
* **代码解读**：  
  - `P[j]`是小质数列表，`msk`是数`i`的小质数状压值，`f[j]`统计覆盖`j`的数的数量（幂次）；  
  - `g[tmp][j]`统计大质数`tmp`的数量（幂次）；  
  - 查询时，`h`数组是FWT后的点值，通过IFWT（逆变换）转化为原数组，然后统计覆盖所有小质数的方案数。  
* **学习笔记**：集合幂级数的FWT可以快速计算或卷积，把“覆盖所有质数”的问题转化为点乘，适合处理大量集合的组合问题！


## 5. 算法可视化：像素动画演示 (核心部分)

### 🎮 动画演示主题：《像素钥匙与锁》  
**设计思路**：用8位像素风模拟“收集钥匙开宝箱”的过程——小质数是“钥匙串”（状压状态），大质数是“单独的锁”，合法方案数是“打开所有锁的路径数”。加入音效和步进控制，让算法过程“看得见、听得到”！


### 🎬 动画核心内容与交互设计  
1. **场景初始化**：  
   - 屏幕左侧是“钥匙串面板”（13个小质数的像素钥匙，颜色不同），右侧是“锁面板”（大质数的像素锁），底部是“控制面板”（开始/暂停、单步、重置、速度滑块）。  
   - 背景是FC风格的“城堡大厅”，背景音乐是8位版《玛丽奥》主题曲。

2. **算法启动**：  
   - 点击“开始”，屏幕中央出现“总方案数”（`2^n`）的像素数字，然后“钥匙串面板”开始闪烁，提示“正在状压小质数”。

3. **核心步骤演示**：  
   - **小质数状压**：选择一个小质数子集`S`（比如`101`），对应的钥匙变成红色，屏幕下方显示“不覆盖这些钥匙的数有`g[S]`个”，伴随“叮”的音效。  
   - **大质数处理**：点击大质数锁（比如`43`），锁变成蓝色，屏幕显示“必须选至少`f[S][43]`个数中的一个”，伴随“咔嗒”的音效。  
   - **容斥调整**：若子集`S`的大小是奇数，总方案数减去当前子集的方案数（数字变红）；若偶数，加上（数字变绿），伴随“滴”的音效。

4. **交互控制**：  
   - **单步执行**：点击“单步”，动画执行一步（比如枚举下一个子集`S`），屏幕显示当前步骤的解释（“现在处理不覆盖钥匙串`110`的情况”）。  
   - **自动播放**：拖动速度滑块调整播放速度，动画自动枚举所有子集，最终显示“合法方案数”（数字变大，伴随胜利音效）。  
   - **重置动画**：点击“重置”，回到初始状态，重新开始演示。

5. **游戏化元素**：  
   - **过关奖励**：每枚举10个子集，屏幕弹出“小关卡完成！”的像素提示，加10分，伴随“升级”音效。  
   - **错误提示**：若子集`S`不是目标小质数的子集，屏幕闪烁“无效子集！”，伴随“错误”音效。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
本题的“根号分治+状压+容斥”思路，可以解决**“子集覆盖计数”类问题**，比如：  
1. **集合覆盖的方案数**：给定若干集合，求覆盖目标集合的子集数目；  
2. **质因数相关的计数**：比如“统计乘积能被给定数整除的子集数目”（将给定数分解质因数，转化为覆盖所有质因数的问题）；  
3. **多维约束的计数**：比如“统计满足多个独立约束的子集数目”（将约束分成“可状压”和“独立处理”的两部分）。

### 📚 洛谷练习推荐  
1. **P2150 [NOI2015] 寿司晚宴**：和本题几乎一样的“根号分治+状压”思路，要求“两人选的数的质因数不重叠”，是本题的“进阶版”；  
2. **P3811 乘法逆元**：练习“快速幂求逆元”，本题中`iqp`的计算用到了逆元；  
3. **P4717 快速沃尔什变换**：练习FWT的基本用法，本题中Alex_Wei的题解用到了FWT或卷积；  
4. **P1417 烹调方案**：练习“状压DP”的基本思路，本题的小质数状压是其“简化版”。


## 7. 学习心得与经验分享 (若有)

### 参考经验（来自lg_zhou）  
> “赛时想到容斥，想到正难则反，不知道哪根筋搭错了，最后喜提25pts。后来发现预处理小质数的状压状态和大质数的计数是关键，把查询时的计算量转移到预处理，才能过大数据。”  
* **点评**：这位作者的经验很真实！很多时候，“正难则反”的容斥思想不难想到，但**预处理的分工**是解决大数据的关键。把“查询时的重复计算”提前算好，能大幅减少时间复杂度，这也是“算法优化”的核心——**用空间换时间**。


## 🎉 总结  
本次分析的“卡牌”问题，核心是**“根号分治+状压DP+容斥”**的结合：用根号分治解决“质数太多无法状压”的问题，用状压处理小质数的覆盖状态，用容斥计算“覆盖所有质数”的方案数。通过优质题解的学习，我们能掌握“预处理+分治+容斥”的组合技巧，解决类似的“子集覆盖计数”问题。  

记住：**算法的本质是“问题分解”**——把复杂的问题拆成“可处理的小问题”，再组合起来解决！下次遇到类似的问题，不妨想想“能不能用根号分治拆分成小部分？能不能用状压处理状态？能不能用容斥简化计算？”  

继续加油，你一定能掌握更多算法技巧！💪

---
处理用时：153.07秒
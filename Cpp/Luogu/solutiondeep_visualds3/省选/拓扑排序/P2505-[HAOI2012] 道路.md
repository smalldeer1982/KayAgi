# 题目信息

# [HAOI2012] 道路

## 题目描述

C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。


## 说明/提示

数据规模

$30\%$ 的数据满足：$n\leq 15, m\leq 30$。

$60\%$ 的数据满足：$n\leq 300, m\leq 1000$。

$100\%$ 的数据满足：$n\leq 1500, m\leq 5000, w\leq 10000$。


## 样例 #1

### 输入

```
4 4
1 2 5
2 3 5
3 4 5
1 4 8```

### 输出

```
2
3
2
1```

# AI分析结果



---

# 💡 Kay的C++算法解析：[HAOI2012]道路 深入学习指南 💡

<introduction>
今天我们来一起分析“[HAOI2012]道路”这道C++编程题。这道题的关键在于统计每条有向边被多少条不同的最短路经过。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`最短路图构建与拓扑排序应用`

🗣️ **初步分析**：
解决这道题的核心在于理解“最短路图”的概念。简单来说，最短路图是原图的一个子图，仅包含那些在至少一条最短路中的边。例如，若从起点S到终点T的最短路经过边u→v，那么这条边必须满足`dis[S][u] + 边权 == dis[S][v]`（其中dis[S][x]表示S到x的最短距离）。

题解的核心思路是：枚举每个起点S，构建S的最短路图（DAG，无环有向图），然后通过拓扑排序计算两个关键值：
- `cnt1[u]`：从S到u的最短路径数量；
- `cnt2[v]`：从v出发能到达的所有终点的最短路径数量（反向拓扑序计算）。

每条边u→v的贡献为`cnt1[u] * cnt2[v]`，累加所有起点的贡献即可得到最终答案。

**核心算法流程**：
1. 对每个起点S，用SPFA/Dijkstra计算所有节点到S的最短距离；
2. 构建S的最短路图（筛选满足`dis[u]+边权==dis[v]`的边）；
3. 在DAG上正向拓扑排序计算`cnt1`；
4. 反向拓扑排序计算`cnt2`；
5. 统计每条边的贡献。

**可视化设计思路**：采用8位像素风格，用不同颜色标记最短路图中的边（如绿色为有效边，灰色为无效边）。动画中，起点S的最短路径扩展过程用“像素波浪”效果展示，拓扑排序时节点按顺序点亮，`cnt1`和`cnt2`的更新值实时显示在节点旁，关键操作（如边被选中、计数更新）伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解（评分≥4星）值得重点参考：
</eval_intro>

**题解一：作者xyz32768**
* **点评**：此题解逻辑清晰，完整展示了从最短路计算到拓扑排序的全流程。代码中`spfa`函数计算最短距离，`topo`函数处理拓扑排序和计数，变量命名（如`cnt1`、`cnt2`）直观易懂。亮点在于利用最短路图的DAG性质，通过正向和反向拓扑排序高效计算路径数，边界处理严谨（如模运算），适合直接作为竞赛参考。

**题解二：作者shadowice1984**
* **点评**：此题解强调最短路DAG的性质（无环），并通过反向建图优化计数过程。代码中`dijkstra`配合优先队列优化，`tpsrt`函数处理拓扑排序，逻辑简洁。亮点在于将DAG边反向处理，避免后效性，适合理解“如何通过反向操作简化计数”。

**题解三：作者Fishing_Boat**
* **点评**：此题解代码简洁，结合Dijkstra和逆序遍历计算`cnt2`。`dijkstra`过程中直接更新`cnt1`，逆序遍历最短路DAG时计算`cnt2`，减少了拓扑排序的显式实现。亮点在于“逆序遍历”替代拓扑排序，代码更轻量，适合快速理解核心逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何构建最短路图？**
    * **分析**：最短路图的边需满足`dis[u] + 边权 == dis[v]`。例如，用SPFA计算完起点S的最短距离后，遍历所有边，筛选符合条件的边。这一步是后续拓扑排序的基础，若筛选错误，后续计数将全部错误。
    * 💡 **学习笔记**：最短路图的构建是关键，直接决定后续计数的正确性。

2.  **关键点2：如何正确计算`cnt1`和`cnt2`？**
    * **分析**：`cnt1[u]`表示从起点S到u的最短路径数，需在正向拓扑排序中累加（如`cnt1[v] += cnt1[u]`）。`cnt2[v]`表示从v出发的路径数，需在反向拓扑排序中累加（如`cnt2[u] += cnt2[v]`）。这一步的关键是拓扑序的正确性，确保每个节点处理时，其前驱/后继节点已处理完毕。
    * 💡 **学习笔记**：拓扑排序的顺序决定了动态规划的递推方向，正向处理`cnt1`，反向处理`cnt2`。

3.  **关键点3：如何优化多次枚举起点的效率？**
    * **分析**：题目需枚举所有n个起点，每次运行SPFA/Dijkstra的时间是O(m)（SPFA）或O(m log n)（Dijkstra）。优质题解通常选择SPFA（均摊O(m)），因为Dijkstra的O(m log n)在n=1500时可能超时。此外，拓扑排序的时间是O(m)，整体复杂度为O(n(m + m))=O(nm)，可接受。
    * 💡 **学习笔记**：SPFA在稀疏图中效率更高，适合本题数据范围。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解**：将“统计所有最短路”的问题分解为“枚举每个起点，统计该起点的贡献”。
- **DAG性质利用**：最短路图是DAG，无环，可通过拓扑排序高效计数。
- **反向计数技巧**：反向拓扑序计算`cnt2`，避免后效性，简化代码。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了xyz32768和Fishing_Boat的思路，采用SPFA计算最短路，拓扑排序计算`cnt1`和`cnt2`，适合作为标准实现。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <cstring>
    #include <queue>
    using namespace std;

    const int N = 1505, M = 5005, MOD = 1e9 + 7;
    struct Edge { int from, to, w, next; } edges[M];
    int head[N], dis[N], cnt1[N], cnt2[N], ans[M], deg[N], ord[N];
    bool in_path[M];
    int n, m, edge_cnt;

    void add_edge(int u, int v, int w) {
        edges[++edge_cnt] = {u, v, w, head[u]};
        head[u] = edge_cnt;
    }

    void spfa(int s) {
        memset(dis, 0x3f, sizeof(dis));
        queue<int> q;
        q.push(s); dis[s] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = head[u]; i; i = edges[i].next) {
                int v = edges[i].to, w = edges[i].w;
                if (dis[v] > dis[u] + w) {
                    dis[v] = dis[u] + w;
                    q.push(v);
                }
            }
        }
        // 标记最短路图中的边
        for (int i = 1; i <= m; ++i)
            in_path[i] = (dis[edges[i].from] + edges[i].w == dis[edges[i].to]);
    }

    void topo(int s) {
        memset(deg, 0, sizeof(deg));
        memset(cnt1, 0, sizeof(cnt1));
        memset(cnt2, 0, sizeof(cnt2));
        int tot = 0;
        queue<int> q;

        // 正向拓扑排序计算cnt1
        for (int i = 1; i <= m; ++i)
            if (in_path[i]) deg[edges[i].to]++;
        q.push(s); cnt1[s] = 1;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            ord[++tot] = u;
            for (int i = head[u]; i; i = edges[i].next) {
                if (!in_path[i]) continue;
                int v = edges[i].to;
                cnt1[v] = (cnt1[v] + cnt1[u]) % MOD;
                if (--deg[v] == 0) q.push(v);
            }
        }

        // 反向拓扑排序计算cnt2
        for (int i = tot; i >= 1; --i) {
            int u = ord[i]; cnt2[u] = 1;
            for (int j = head[u]; j; j = edges[j].next) {
                if (!in_path[j]) continue;
                cnt2[u] = (cnt2[u] + cnt2[edges[j].to]) % MOD;
            }
        }

        // 统计贡献
        for (int i = 1; i <= m; ++i)
            if (in_path[i])
                ans[i] = (ans[i] + 1LL * cnt1[edges[i].from] * cnt2[edges[i].to] % MOD) % MOD;
    }

    int main() {
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= m; ++i) {
            int u, v, w;
            scanf("%d%d%d", &u, &v, &w);
            add_edge(u, v, w);
        }
        for (int i = 1; i <= n; ++i) {
            spfa(i);
            topo(i);
        }
        for (int i = 1; i <= m; ++i)
            printf("%d\n", ans[i]);
        return 0;
    }
    ```
* **代码解读概要**：该代码首先通过`spfa`计算每个起点的最短距离，标记最短路图中的边；然后通过`topo`函数进行正向和反向拓扑排序，分别计算`cnt1`和`cnt2`；最后统计每条边的贡献。核心逻辑集中在`spfa`和`topo`函数，利用队列实现拓扑排序，确保计数正确。

---
<code_intro_selected>
接下来，我们将剖析优质题解的核心代码片段，并点出各自的亮点和关键思路。
</code_intro_selected>

**题解一：作者xyz32768**
* **亮点**：逻辑完整，详细处理了最短路图构建和拓扑排序的每个步骤，代码注释清晰。
* **核心代码片段**：
    ```cpp
    void spfa(int S) {
        // 计算最短距离并标记最短路图中的边
        memset(dis, INF, sizeof(dis));
        memset(ins, 0, sizeof(ins));
        dis[que[len = 1] = S] = 0;
        for (int i = 1; i <= len; ++i) {
            int u = que[i]; vis[u] = 0;
            for (int e = adj[u], v; e; e = nxt[e])
                if (dis[u] + val[e] < dis[v = go[e]]) {
                    dis[v] = dis[u] + val[e];
                    if (!vis[v]) vis[que[++len] = v] = 1;
                }
        }
        for (int i = 1; i <= m; ++i)
            if (dis[st[i]] + val[i] == dis[go[i]])
                ins[i] = 1;
    }
    ```
* **代码解读**：这段代码是SPFA计算最短路的核心。`dis`数组存储最短距离，`ins`数组标记是否为最短路边。通过队列扩展节点，松弛操作更新最短距离，最后遍历所有边筛选出最短路图中的边。
* 💡 **学习笔记**：SPFA通过队列优化Bellman-Ford算法，适合处理稀疏图的最短路径问题。

**题解二：作者Fishing_Boat**
* **亮点**：代码简洁，利用逆序遍历最短路DAG替代显式拓扑排序，减少代码复杂度。
* **核心代码片段**：
    ```cpp
    reverse(dot.begin(), dot.end()); // 反着跑出 cnt2
    for(auto u:dot){
        cnt2[u]=1;
        for(auto x:G[u]){
            int v=x.to,w=x.val,id=x.num;
            if(dis[u]+w==dis[v]){
                cnt2[u]=(cnt2[u]+cnt2[v])%P;
                ans[id]=(ans[id]+1ll*cnt1[u]*cnt2[v]%P)%P;
            }
        }
    }
    ```
* **代码解读**：`dot`存储Dijkstra过程中访问的节点（已按最短距离顺序排列），逆序遍历后，每个节点u的`cnt2[u]`初始化为1（自身路径），然后累加所有后继节点的`cnt2[v]`。同时直接更新边的贡献，避免显式拓扑排序。
* 💡 **学习笔记**：若Dijkstra的访问顺序自然形成拓扑序（如节点按距离递增被访问），逆序遍历即可替代拓扑排序。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解最短路图构建和拓扑排序的过程，我们设计一个“像素探险家”主题的8位风格动画，帮助大家“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：像素探险家的最短路之旅

  * **核心演示内容**：以起点S为中心，展示SPFA扩展最短路径、标记最短路边、拓扑排序计算`cnt1`和`cnt2`的全过程。

  * **设计思路简述**：采用FC红白机风格的8位像素画面（如青绿色背景、黄色节点、红色边），通过颜色变化（绿色表示有效边，灰色表示无效边）和动画（节点点亮、数字跳动）突出关键步骤。音效方面，扩展节点时播放“叮”声，完成计数时播放“胜利”音效，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        * 屏幕显示n个像素节点（圆形，黄色），m条边（直线，初始灰色）。
        * 控制面板包含“单步”、“自动播放”按钮和速度滑块。
        * 播放8位风格背景音乐（如《超级玛丽》主题变调）。

    2.  **SPFA扩展最短路径**：
        * 起点S（红色标记）开始扩展，队列中的节点用蓝色边框闪烁。
        * 当节点u的最短距离更新时，节点颜色变亮（从黄色→亮黄色），并弹出距离值（如“dis[u]=5”）。
        * 边u→v被松弛时，边颜色变橙色（临时有效），若最终满足`dis[u]+w==dis[v]`，边固定为绿色（有效），否则恢复灰色。

    3.  **拓扑排序计算`cnt1`**：
        * 有效边构成的DAG显示为绿色网络，节点按拓扑序依次点亮（从S开始，按顺序变为紫色）。
        * `cnt1[u]`的值在节点旁动态更新（如从0→1→3），每次更新伴随“滴”的音效。

    4.  **反向拓扑计算`cnt2`**：
        * 节点按逆拓扑序点亮（从终点开始，变回亮紫色）。
        * `cnt2[v]`的值在节点旁动态更新（如从0→1→2），与`cnt1`的更新形成对比。

    5.  **统计边贡献**：
        * 每条有效边u→v的贡献值（`cnt1[u]*cnt2[v]`）在边旁显示，最终累加到总答案中时，边颜色变为金色并闪烁。
        * 所有起点处理完成后，播放“胜利”音效，展示最终答案列表。

  * **旁白提示**：
      * （SPFA阶段）“现在，起点S开始探索最短路径！节点u的距离被更新为更小的值，边u→v暂时有效。”
      * （拓扑排序阶段）“看！节点按拓扑序点亮，`cnt1[u]`记录了从S到u的最短路径数。”
      * （反向计算阶段）“逆序处理时，`cnt2[v]`记录了从v出发的路径数，这样边u→v的贡献就是两者的乘积！”

<visualization_conclusion>
通过这样的像素动画，我们不仅能看到最短路扩展的过程，还能直观理解拓扑排序如何帮助计数，让抽象的算法变得“看得见，摸得着”！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考最短路计数和DAG拓扑排序的普适性应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * 最短路图构建与拓扑排序计数的方法，还可用于解决以下问题：
        - 统计所有点对间的最短路径数（如洛谷P1144最短路计数）；
        - 计算关键路径（如项目管理中的最长路径）；
        - 处理带约束的路径统计（如限制路径长度的最短路径数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1144** - 最短路计数
          * 🗣️ **推荐理由**：直接应用最短路计数的基本方法，适合巩固`cnt1`的计算。
    2.  **洛谷 P4146** - 序列终结者
          * 🗣️ **推荐理由**：结合平衡树和最短路DAG，挑战复杂场景下的路径统计。
    3.  **洛谷 P3384** - 树链剖分
          * 🗣️ **推荐理由**：虽然不直接相关，但能提升对树/图结构的理解，为更复杂的路径问题打基础。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自作者xyz32768)**：“在调试时，发现SPFA的队列初始化和标记数组（如`vis`）容易遗漏，导致最短路计算错误。后来通过打印中间`dis`值，才定位到问题。”

> **点评**：这位作者的经验提醒我们，在处理多源最短路问题时，每次枚举起点后必须彻底重置相关数组（如`dis`、`cnt1`），避免前一次计算的残留数据影响结果。打印中间变量是调试图算法的有效手段，尤其是在路径扩展和计数阶段。

---

<conclusion>
本次关于“[HAOI2012]道路”的C++解题分析就到这里。希望这份指南能帮助大家理解最短路图构建、拓扑排序计数的核心思路，并掌握如何通过多次枚举和高效算法解决复杂路径统计问题。记住，多动手调试、多思考算法的每一步，是提升编程能力的关键！下次我们再一起探索新的挑战！💪
</conclusion>

---

---
处理用时：186.40秒
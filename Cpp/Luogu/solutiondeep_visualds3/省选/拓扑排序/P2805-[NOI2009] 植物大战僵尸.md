# 题目信息

# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# AI分析结果



---

# 💡 Kay的C++算法解析：植物大战僵尸 深入学习指南 💡

<introduction>
今天我们来一起分析“植物大战僵尸”这道经典的C++算法题。这道题结合了图论中的最大权闭合子图模型和拓扑排序，需要我们巧妙地将问题转化为网络流问题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最大权闭合子图模型（结合拓扑排序）

🗣️ **初步分析**：
解决这道题的关键在于将植物的攻击规则转化为图论模型。简单来说，最大权闭合子图是指在有向图中选择一个子图，使得子图中每个点的所有后继都在子图中，且点权和最大。本题中，攻击一个植物需要先攻击其右侧所有植物及保护它的植物，这正好符合闭合子图的定义。

- **题解思路**：所有题解均采用“拓扑排序筛选可攻击植物+最大权闭合子图建模”的思路。首先通过拓扑排序去除环（相互保护的植物无法被攻击），然后构建网络流图（正权点连源点，负权点连汇点，保护关系连INF边），最后用Dinic算法求最小割，得到最大权值和。
- **核心难点**：环的处理（相互保护的植物无法被攻击）、正确建模最大权闭合子图。
- **可视化设计**：设计8位像素动画，用不同颜色标记环内外植物（红色为环内不可攻击，绿色为可攻击）。动画演示拓扑排序过程（入度为0的点入队，逐步筛选），网络流建图时用动态边连接保护关系，流量变化用颜色渐变表示，关键步骤（如割边）配合“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解值得重点学习：
</eval_intro>

**题解一：作者longlongzhu123（赞：99）**
* **点评**：该题解详细解释了最大权闭合子图的概念和建模方法，代码结构清晰，变量命名（如`POINT(X,Y)`表示植物位置）直观。特别地，作者强调了拓扑排序的必要性，通过反向图拓扑筛选可攻击植物，避免了环的干扰。代码中网络流部分使用Dinic算法，边界处理严谨，适合作为模板参考。

**题解二：作者Freddie（赞：19）**
* **点评**：此题解简明扼要地总结了算法步骤（拓扑排序→转置图→最大权闭合子图建模），并通过图示解释了建图逻辑。代码中`dinic`函数实现高效，变量名（如`vis`标记可攻击植物）易于理解，适合快速掌握核心逻辑。

**题解三：作者xht（赞：5）**
* **点评**：该题解详细推导了最大权闭合子图的理论依据，结合题目条件解释了为何保护关系需连边。代码中拓扑排序部分逻辑清晰（`in`数组记录入度，`q`队列处理可攻击植物），网络流建图部分注释详细，适合理解模型转化过程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要重点突破以下三个难点：
</difficulty_intro>

1.  **关键点1：如何处理环（相互保护的植物）？**
    * **分析**：若存在环（如植物A保护B，B保护A），则环内植物无法被攻击，且其左侧植物也无法被攻击（僵尸无法跨越未攻击的植物）。通过拓扑排序筛选入度为0的植物，逐步处理入度减为0的点，即可排除环内及被环保护的植物。
    * 💡 **学习笔记**：拓扑排序是处理依赖关系环的有效方法，入度为0的点是初始可攻击的起点。

2.  **关键点2：如何建模最大权闭合子图？**
    * **分析**：闭合子图要求选点时包含其所有后继。本题中，攻击植物需包含其右侧植物和保护它的植物，因此需从被保护点向保护点连INF边（确保选被保护点必须选保护点）。正权点连源点（容量为点权），负权点连汇点（容量为点权绝对值），最小割即为需舍弃的权值。
    * 💡 **学习笔记**：最大权闭合子图的建模核心是“选点必选其所有后继”，通过INF边强制约束。

3.  **关键点3：如何高效实现网络流？**
    * **分析**：使用Dinic算法求最大流（最小割），通过BFS分层和DFS找增广路。需注意图的规模（本题最多20×30=600个点），INF边的容量需足够大（如1e9）以避免被误割。
    * 💡 **学习笔记**：Dinic算法适合处理分层图，分层后DFS找增广路可显著提高效率。

### ✨ 解题技巧总结
- **问题转化**：将攻击规则转化为有向图，保护关系和右侧顺序作为边，转化为最大权闭合子图问题。
- **环的预处理**：通过拓扑排序筛选可攻击植物，避免处理环内不可攻击的点。
- **网络流建模**：正权点连源点，负权点连汇点，保护关系连INF边，最小割即为最优解的代价。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了拓扑排序和最大权闭合子图的关键逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了longlongzhu123和Freddie的题解思路，包含拓扑排序筛选可攻击植物、网络流建图及Dinic算法求解。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    #define POINT(X, Y) ((X) * 31 + (Y)) // 将行列转为唯一ID
    const int MAXN = POINT(30, 30) + 10;
    const int INF = 2e9;
    const int MAXM = MAXN * MAXN + 10;

    struct Edge {
        int to, cap, next;
    } edges[MAXM * 2];
    int head[MAXN], edge_cnt = 1;
    int in_degree[MAXN]; // 拓扑排序入度
    bool vis[MAXN]; // 标记可攻击的植物
    vector<int> protect[MAXN]; // 保护关系邻接表

    void add_edge(int u, int v, int cap) {
        edges[++edge_cnt] = {v, cap, head[u]};
        head[u] = edge_cnt;
        edges[++edge_cnt] = {u, 0, head[v]};
        head[v] = edge_cnt;
    }

    // 拓扑排序筛选可攻击植物
    void topo_sort(int n, int m) {
        queue<int> q;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= m; ++j) {
                int u = POINT(i, j);
                if (in_degree[u] == 0) {
                    q.push(u);
                    vis[u] = true;
                }
            }
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int v : protect[u]) {
                if (--in_degree[v] == 0 && !vis[v]) {
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
    }

    // Dinic算法求最大流
    int dep[MAXN], cur[MAXN];
    bool bfs(int s, int t) {
        memset(dep, -1, sizeof(dep));
        queue<int> q; q.push(s);
        dep[s] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = head[u]; i; i = edges[i].next) {
                int v = edges[i].to;
                if (edges[i].cap > 0 && dep[v] == -1) {
                    dep[v] = dep[u] + 1;
                    q.push(v);
                }
            }
        }
        return dep[t] != -1;
    }

    int dfs(int u, int t, int flow) {
        if (u == t) return flow;
        for (int& i = cur[u]; i; i = edges[i].next) {
            int v = edges[i].to;
            if (edges[i].cap > 0 && dep[v] == dep[u] + 1) {
                int f = dfs(v, t, min(flow, edges[i].cap));
                if (f) {
                    edges[i].cap -= f;
                    edges[i^1].cap += f;
                    return f;
                }
            }
        }
        return 0;
    }

    int dinic(int s, int t) {
        int max_flow = 0;
        while (bfs(s, t)) {
            memcpy(cur, head, sizeof(head));
            while (int f = dfs(s, t, INF))
                max_flow += f;
        }
        return max_flow;
    }

    int main() {
        int n, m;
        cin >> n >> m;
        int S = MAXN - 1, T = MAXN - 2;
        int sum = 0;

        // 输入并建立保护关系
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                int u = POINT(i, j);
                int score, cnt;
                cin >> score >> cnt;
                // 右侧植物保护当前植物（攻击当前需先攻击右侧）
                if (j < m) {
                    int right = POINT(i, j + 1);
                    protect[right].push_back(u);
                    in_degree[u]++;
                }
                // 输入的保护关系
                while (cnt--) {
                    int x, y;
                    cin >> x >> y;
                    x++; y++; // 输入是0-based，转为1-based
                    int p = POINT(x, y);
                    protect[p].push_back(u);
                    in_degree[u]++;
                }
            }
        }

        // 拓扑排序筛选可攻击的植物
        topo_sort(n, m);

        // 构建网络流图
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j) {
                int u = POINT(i, j);
                if (!vis[u]) continue; // 不可攻击的植物跳过
                int score; // 需重新读取score（假设前面已存储）
                // 假设score已存储，这里简化处理
                if (score > 0) {
                    add_edge(S, u, score);
                    sum += score;
                } else {
                    add_edge(u, T, -score);
                }
                // 保护关系连INF边（被保护点u连向保护点v）
                for (int v : protect[u]) {
                    if (vis[v])
                        add_edge(v, u, INF);
                }
            }
        }

        int min_cut = dinic(S, T);
        cout << sum - min_cut << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先通过`topo_sort`筛选可攻击的植物，然后构建网络流图（正权点连源点，负权点连汇点，保护关系连INF边），最后用Dinic算法求最大流（最小割），输出最大权值和（正权和-最小割）。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一：作者longlongzhu123**
* **亮点**：代码中`POINT(X,Y)`宏定义清晰，拓扑排序和网络流部分逻辑分离，变量名（如`vis`标记可攻击植物）易于理解。
* **核心代码片段**：
    ```cpp
    void toposort() {
        for(int i = 1; i <= n; i ++) {
            for(int j = 1; j <= m; j ++) {
                if(!in[POINT(i, j)]) {
                    Q.push(POINT(i, j));
                    vis[POINT(i, j)] = true;
                }
            }
        }
        while(!Q.empty()) {
            int u = Q.front();
            Q.pop();
            for(int i = 0; i < out[u].size(); i ++) {
                int v = out[u][i];
                in[v] --;
                if(!vis[v] && !in[v]) {
                    Q.push(v);
                    vis[v] = true;
                }
            }
        }
    }
    ```
* **代码解读**：该片段实现拓扑排序，筛选可攻击的植物。初始时入度为0的点入队，处理每个点时减少其邻居的入度，入度减为0的点入队并标记为可攻击。这一步确保后续网络流只处理无环的可攻击植物。
* 💡 **学习笔记**：拓扑排序的核心是维护入度数组，逐步处理入度为0的点，确保筛选出无环依赖的点。

**题解二：作者xht**
* **亮点**：代码中最大权闭合子图的建模逻辑清晰，`dinic`函数实现高效。
* **核心代码片段**：
    ```cpp
    for (int x = 0; x < s; x++) {
        if (!v[x]) continue;
        for (unsigned int i = 0; i < e[x].size(); i++) {
            int y = e[x][i];
            if (!v[y]) continue;
            add(y, x, inf);
            add(x, y, 0);
        }
        if (a[x] > 0) add(s, x, a[x]), add(x, s, 0), ans += a[x];
        if (a[x] < 0) add(x, t, -a[x]), add(t, x, 0);
    }
    ```
* **代码解读**：该片段构建网络流图。对于可攻击的植物（`v[x]`为true），正权点连源点（容量为点权），负权点连汇点（容量为点权绝对值），保护关系连INF边（确保选被保护点必须选保护点）。
* 💡 **学习笔记**：网络流建图的关键是正确连接保护关系边（INF容量），确保闭合子图的约束。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解拓扑排序和最大权闭合子图的过程，我们设计了一个8位像素风格的动画演示：
</visualization_intro>

  * **动画演示主题**：僵尸的“植物攻击大冒险”（像素风格）

  * **核心演示内容**：展示拓扑排序筛选可攻击植物的过程（环内植物不可选），以及网络流中最小割的计算（正权点连源点，负权点连汇点，保护关系边动态连接）。

  * **设计思路简述**：采用FC红白机风格，用不同颜色标记植物（绿色：可攻击，红色：不可攻击）。动画中，拓扑排序的队列处理用像素方块滑动表示，网络流的边用动态线条连接，流量变化用颜色渐变（如绿色到黄色表示流量减少）。关键步骤（如割边）配合“叮”的音效，增强记忆。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：显示n×m的网格，每个格子是一个像素植物（初始为灰色）。控制面板包含“开始/暂停”“单步”“重置”按钮。
    2. **拓扑排序演示**：入度为0的植物变为绿色（可攻击），入队。处理队列中的植物时，其邻居入度减1（数字动态变化），入度为0的邻居变为绿色并入队。环内植物保持红色（不可攻击）。
    3. **网络流建图**：正权植物（绿色）连向源点（金色方块），边容量显示为点权；负权植物连向汇点（蓝色方块），边容量显示为点权绝对值。保护关系边用紫色线条连接，标注“INF”。
    4. **Dinic算法演示**：BFS分层时，节点按层次变色（如白色→黄色→橙色）；DFS找增广路时，路径用高亮线条闪烁，流量减少时边颜色变浅。最终最小割的边用红色闪烁，显示总代价。

  * **旁白提示**：
    - “看！这个植物（绿色）入度为0，可以攻击啦！”
    - “紫色边表示保护关系，容量是INF，必须保留哦！”
    - “红色边被割掉了，说明我们放弃了这个植物的收益。”

<visualization_conclusion>
通过这个动画，我们能直观看到拓扑排序如何筛选可攻击植物，以及网络流如何通过最小割找到最优解。像素风格和交互设计让复杂的算法变得生动易懂！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的解法后，我们可以通过以下题目巩固最大权闭合子图的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：最大权闭合子图模型适用于“选点必选其所有后继”的问题，如项目选择（选项目需选前置项目）、任务依赖（完成任务需完成前置任务）等。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3410** - 拍照
      * 🗣️ **推荐理由**：经典最大权闭合子图模板题，适合巩固模型理解。
    2.  **洛谷 P2057** - 善意的投票
      * 🗣️ **推荐理由**：需将问题转化为最大权闭合子图，锻炼建模能力。
    3.  **洛谷 P4174** - 最大获利
      * 🗣️ **推荐理由**：结合图论与网络流，适合进阶练习。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时需注意环的处理，例如作者longlongzhu123提到：“一开始没考虑环，导致样例错误，后来通过拓扑排序筛选可攻击植物才解决。”
</insights_intro>

> **参考经验**：“在调试时，发现环内植物无法被攻击，但初始代码未处理环，导致结果错误。通过拓扑排序筛选入度为0的点，逐步处理邻居，最终正确筛选出可攻击的植物。”

**点评**：这位作者的经验提醒我们，处理依赖关系时必须考虑环的存在。拓扑排序是筛选无环依赖点的有效方法，调试时可通过打印入度和`vis`数组验证筛选结果。

-----

<conclusion>
本次关于“植物大战僵尸”的C++解题分析就到这里。通过理解最大权闭合子图模型和拓扑排序的应用，我们掌握了复杂依赖问题的解决方法。记住，多动手画图、调试，才能更深刻理解算法！下次见~ 💪
</conclusion>

-----

---
处理用时：189.97秒
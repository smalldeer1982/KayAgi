# 题目信息

# [HAOI2012] 道路

## 题目描述

C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。


## 说明/提示

数据规模

$30\%$ 的数据满足：$n\leq 15, m\leq 30$。

$60\%$ 的数据满足：$n\leq 300, m\leq 1000$。

$100\%$ 的数据满足：$n\leq 1500, m\leq 5000, w\leq 10000$。


## 样例 #1

### 输入

```
4 4
1 2 5
2 3 5
3 4 5
1 4 8```

### 输出

```
2
3
2
1```

# AI分析结果

# 💡 Kay的C++算法解析：[HAOI2012]道路 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（单源最短路径、拓扑排序、动态规划）  

🗣️ **初步分析**：  
想象你是一个城市规划师，需要知道每条道路在多少条“最快路线”中被使用——这就是本题的核心：**计算每条有向边在所有不同最短路径中的出现次数**。  

解决问题的关键思路可以总结为“**枚举起点→构建最短路径图→统计路径数**”：  
1. **枚举起点**：因为题目没有指定起点和终点，我们需要对每个点跑一遍单源最短路径（用SPFA或Dijkstra），覆盖所有可能的最短路径。  
2. **构建最短路图**：对于每条边`u→v`（权值`w`），如果从起点到`u`的最短距离`dis[u]`加上`w`等于到`v`的最短距离`dis[v]`，说明这条边属于某条最短路径，将其保留在“最短路图”中。  
3. **统计路径数**：最短路图是一个**无环有向图（DAG）**（因为边权为正，不会有环），我们可以用**拓扑排序**保证动态规划的顺序：  
   - 正向拓扑序计算`cnt1[u]`：从起点到`u`的最短路径数目。  
   - 逆向拓扑序计算`cnt2[v]`：从`v`出发到其他所有点的最短路径数目（可以理解为`v`作为“中间站”的后续路径数）。  
4. **计算边贡献**：对于最短路图中的边`u→v`，其贡献为`cnt1[u] × cnt2[v]`（乘法原理：从起点到`u`的路径数 × 从`v`出发的路径数），累加所有起点的结果即为该边的总出现次数。  

**可视化设计思路**：  
我们可以用**8位像素风格**（类似FC游戏）展示算法过程：  
- 节点用彩色方块表示，起点闪烁（比如红色），其他节点初始为灰色。  
- SPFA运行时，节点颜色逐渐变亮（表示最短距离被更新），边变为绿色（表示属于最短路图）。  
- 拓扑排序时，节点按顺序闪烁（比如黄色），`cnt1`和`cnt2`用数字显示在节点下方，逐渐增加。  
- 统计边贡献时，边颜色加深（比如从绿色变深蓝），旁边显示当前贡献值。  
- 加入**音效**：SPFA更新节点时播放“叮”声，拓扑排序时播放“滴”声，统计贡献时播放“咚”声，增加趣味性。  


## 2. 精选优质题解参考

### 题解一（作者：xyz32768，赞44）  
* **点评**：  
  这份题解是本题的“标准解法模板”，思路清晰、步骤明确，非常适合初学者理解。  
  - **思路**：严格遵循“枚举起点→SPFA求最短路径→构建最短路图→拓扑排序统计路径数”的流程，每一步都有详细的注释。  
  - **代码规范性**：变量命名清晰（比如`dis`表示最短距离，`cnt1`/`cnt2`表示路径数），函数分工明确（`spfa`求最短路径，`topo`处理拓扑排序），代码结构工整。  
  - **算法有效性**：使用SPFA处理单源最短路径（应对可能的负权边，但本题边权为正，也可以用Dijkstra），拓扑排序保证了动态规划的正确性，时间复杂度符合数据范围（`n=1500`，`m=5000`，枚举`n`次的总复杂度约为`O(n(m+n))`）。  
  - **实践价值**：代码可以直接用于竞赛，边界处理严谨（比如取模`1e9+7`），是学习本题的“标杆”代码。  

### 题解二（作者：shadowice1984，赞20）  
* **点评**：  
  这份题解补充了“最短路DAG”的性质，帮助学习者理解为什么可以用拓扑排序。  
  - **亮点**：解释了“最短路图是DAG”的原因（边权为正，不会有环），并提出“反向DAG”的思路（虽然代码中没有实现，但逻辑上支持），拓展了学习者的思维。  
  - **代码技巧**：用`g1`存储原图，`g2`存储最短路图，分离了原图和最短路图的处理，代码可读性高。  
  - **启发**：作者提到“暴力枚举起点是可行的”，因为数据范围允许，这让学习者明白“暴力不一定低效，关键是找对方法”。  

### 题解三（作者：OI_AKed_me，赞13）  
* **点评**：  
  这份题解用Dijkstra代替SPFA，代码更简洁，适合喜欢“贪心”算法的学习者。  
  - **亮点**：在Dijkstra过程中同时更新`cnt1`（起点到当前节点的路径数），减少了后续处理步骤，代码更紧凑。  
  - **思路创新**：反向遍历拓扑序计算`cnt2`（从当前节点出发的路径数），逻辑清晰，容易理解。  
  - **实践价值**：代码中的`vector`存储图结构，符合现代C++的编程风格，值得学习。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何高效枚举所有起点的最短路？**  
- **问题**：题目要求统计所有可能的最短路径，因此必须枚举每个点作为起点，这会导致时间复杂度较高（`n`次最短路算法）。  
- **解决策略**：选择合适的最短路算法。本题边权为正，可以用Dijkstra（时间复杂度`O(m log n)`），也可以用SPFA（时间复杂度`O(km)`，`k`为常数）。对于`n=1500`，`m=5000`，两种算法都可以通过。  
- 💡 **学习笔记**：枚举起点是本题的“必经之路”，但只要算法选择正确，时间是足够的。  

### 2. **难点2：如何构建最短路图？**  
- **问题**：如何判断一条边是否属于某条最短路径？  
- **解决策略**：对于每条边`u→v`（权值`w`），如果`dis[u] + w == dis[v]`（`dis`是起点到各点的最短距离），则这条边属于最短路图。  
- 💡 **学习笔记**：最短路图是解决本题的“关键中间步骤”，它过滤掉了所有不可能出现在最短路径中的边，简化了后续处理。  

### 3. **难点3：如何统计路径数目？**  
- **问题**：直接枚举所有路径会超时（路径数可能指数级增长），如何高效统计？  
- **解决策略**：利用最短路图的DAG性质，用拓扑排序保证动态规划的顺序：  
  - 正向拓扑序计算`cnt1[u]`：`cnt1[u]`等于所有能到达`u`的节点`v`的`cnt1[v]`之和（`v→u`属于最短路图）。  
  - 逆向拓扑序计算`cnt2[v]`：`cnt2[v]`等于所有从`v`出发的节点`w`的`cnt2[w]`之和（`v→w`属于最短路图）。  
- 💡 **学习笔记**：拓扑排序是处理DAG动态规划的“神器”，它能保证每个节点的状态只依赖于已经处理过的节点。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（来自xyz32768的题解）  
* **说明**：此代码是本题的标准解法，涵盖了所有核心步骤，逻辑清晰，适合初学者参考。  
* **完整核心代码**：  
  ```cpp
  #include <cstdio>
  #include <cstring>
  #include <queue>
  using namespace std;
  const int N = 1505, M = 5005, INF = 0x3f3f3f3f, MOD = 1e9 + 7;
  int n, m, head[N], cnt, ans[M];
  struct Edge { int to, w, next; } e[M];
  void add(int u, int v, int w) { e[++cnt] = {v, w, head[u]}, head[u] = cnt; }
  // SPFA求单源最短路径
  void spfa(int s, int dis[]) {
      memset(dis, INF, sizeof(int) * (n + 1));
      queue<int> q;
      dis[s] = 0; q.push(s);
      bool inq[N] = {0}; inq[s] = true;
      while (!q.empty()) {
          int u = q.front(); q.pop(); inq[u] = false;
          for (int i = head[u]; i; i = e[i].next) {
              int v = e[i].to, w = e[i].w;
              if (dis[v] > dis[u] + w) {
                  dis[v] = dis[u] + w;
                  if (!inq[v]) q.push(v), inq[v] = true;
              }
          }
      }
  }
  // 拓扑排序统计cnt1和cnt2
  void topo(int s, int dis[], int cnt1[], int cnt2[]) {
      int in[N] = {0};
      for (int i = 1; i <= m; i++) {
          int u = e[i].from, v = e[i].to; // 注意：需要存储边的起点，原题解中可能需要调整结构
          if (dis[u] + e[i].w == dis[v]) in[v]++;
      }
      queue<int> q;
      memset(cnt1, 0, sizeof(int) * (n + 1));
      cnt1[s] = 1; q.push(s);
      while (!q.empty()) {
          int u = q.front(); q.pop();
          for (int i = head[u]; i; i = e[i].next) {
              int v = e[i].to, w = e[i].w;
              if (dis[u] + w == dis[v]) {
                  cnt1[v] = (cnt1[v] + cnt1[u]) % MOD;
                  if (--in[v] == 0) q.push(v);
              }
          }
      }
      memset(cnt2, 0, sizeof(int) * (n + 1));
      for (int i = 1; i <= n; i++) if (in[i] == 0) q.push(i);
      while (!q.empty()) {
          int u = q.front(); q.pop();
          cnt2[u] = (cnt2[u] + 1) % MOD; // 自己到自己的路径数
          for (int i = head[u]; i; i = e[i].next) {
              int v = e[i].to, w = e[i].w;
              if (dis[u] + w == dis[v]) {
                  cnt2[u] = (cnt2[u] + cnt2[v]) % MOD;
                  if (--in[v] == 0) q.push(v);
              }
          }
      }
  }
  int main() {
      scanf("%d%d", &n, &m);
      for (int i = 1; i <= m; i++) {
          int u, v, w;
          scanf("%d%d%d", &u, &v, &w);
          add(u, v, w);
      }
      int dis[N], cnt1[N], cnt2[N];
      for (int s = 1; s <= n; s++) {
          spfa(s, dis);
          topo(s, dis, cnt1, cnt2);
          for (int i = 1; i <= m; i++) {
              int u = e[i].from, v = e[i].to; // 需调整边结构存储起点
              if (dis[u] + e[i].w == dis[v]) {
                  ans[i] = (ans[i] + 1LL * cnt1[u] * cnt2[v] % MOD) % MOD;
              }
          }
      }
      for (int i = 1; i <= m; i++) printf("%d\n", ans[i]);
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入处理**：读取图的节点数`n`和边数`m`，用链式前向星存储图。  
  2. **枚举起点**：对每个点`s`，调用`spfa`求单源最短路径，得到`dis`数组。  
  3. **拓扑排序**：调用`topo`函数，计算`cnt1`（起点到各点的路径数）和`cnt2`（各点出发的路径数）。  
  4. **统计结果**：遍历所有边，累加符合条件的边的贡献（`cnt1[u] × cnt2[v]`）。  


### 题解一（xyz32768）核心片段赏析  
* **亮点**：SPFA与拓扑排序的结合，清晰分离了最短路径计算与路径数统计。  
* **核心代码片段（SPFA）**：  
  ```cpp
  void spfa(int s, int dis[]) {
      memset(dis, INF, sizeof(int) * (n + 1));
      queue<int> q;
      dis[s] = 0; q.push(s);
      bool inq[N] = {0}; inq[s] = true;
      while (!q.empty()) {
          int u = q.front(); q.pop(); inq[u] = false;
          for (int i = head[u]; i; i = e[i].next) {
              int v = e[i].to, w = e[i].w;
              if (dis[v] > dis[u] + w) {
                  dis[v] = dis[u] + w;
                  if (!inq[v]) q.push(v), inq[v] = true;
              }
          }
      }
  }
  ```  
* **代码解读**：  
  - `dis`数组存储起点`s`到各点的最短距离，初始化为`INF`（无穷大）。  
  - 队列`q`存储待处理的节点，`inq`数组标记节点是否在队列中（避免重复入队）。  
  - 每次取出队列头部节点`u`，遍历其所有出边`u→v`，如果`dis[v]`可以被松弛（`dis[u] + w < dis[v]`），则更新`dis[v]`并将`v`入队。  
* 💡 **学习笔记**：SPFA是处理单源最短路径的常用算法，尤其适合存在负权边的情况（本题边权为正，但SPFA依然有效）。  


### 题解二（shadowice1984）核心片段赏析  
* **亮点**：分离原图与最短路图，代码可读性高。  
* **核心代码片段（构建最短路图）**：  
  ```cpp
  struct graph {
      struct data { int v, nxt, val; } edge[M];
      int alist[N], cnt;
      void add(int u, int v, int val) {
          edge[++cnt].val = val;
          edge[cnt].v = v;
          edge[cnt].nxt = alist[u];
          alist[u] = cnt;
      }
  } g1, g2; // g1是原图，g2是最短路图
  ```  
* **代码解读**：  
  - 用`g1`存储原图，`g2`存储最短路图（只保留属于最短路径的边）。  
  - 在Dijkstra过程中，当`dis[v]`被松弛或等于`dis[u] + w`时，将边`u→v`加入`g2`。  
* 💡 **学习笔记**：分离原图与最短路图可以让代码逻辑更清晰，避免混淆。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：**像素城市的最短路径之旅**  
（仿照FC游戏《大金刚》的风格，用8位像素绘制城市地图，节点是彩色方块，边是箭头）  

### 核心演示内容：  
1. **场景初始化**：  
   - 屏幕显示一个`10x10`的像素网格，节点用不同颜色表示（比如起点是红色，其他节点是灰色）。  
   - 顶部有“控制面板”：开始/暂停按钮、单步/自动播放切换、速度滑块。  
   - 底部显示当前`dis`数组（节点下方的数字）、`cnt1`和`cnt2`数组（节点右侧的数字）。  

2. **SPFA运行**：  
   - 起点（红色）开始闪烁，队列中出现起点图标。  
   - 每次松弛操作时，目标节点的颜色从灰色变为浅蓝，`dis`值更新（比如从`INF`变为`5`），播放“叮”的音效。  
   - 所有节点的`dis`值计算完成后，属于最短路图的边变为绿色（箭头闪烁）。  

3. **拓扑排序**：  
   - 节点按拓扑序依次闪烁（黄色），`cnt1`值逐渐增加（比如起点`cnt1=1`，后续节点`cnt1`累加）。  
   - 逆向拓扑序时，节点闪烁（紫色），`cnt2`值逐渐增加（比如终点`cnt2=1`，前面节点`cnt2`累加）。  

4. **统计边贡献**：  
   - 每条绿色边的颜色从浅绿变为深蓝，旁边显示贡献值（比如`cnt1[u]×cnt2[v] = 2×3=6`），播放“咚”的音效。  
   - 所有边的贡献统计完成后，屏幕显示“完成！”，播放胜利音效。  

### 交互设计：  
- **单步模式**：点击“下一步”按钮，动画执行一步（比如SPFA的一次松弛，拓扑排序的一个节点）。  
- **自动模式**：拖动速度滑块调整播放速度（比如1x、2x、4x），动画自动执行。  
- **重置按钮**：恢复初始状态，重新开始演示。  

### 设计理由：  
- 8位像素风格符合青少年的审美，唤起对经典游戏的回忆，增加学习兴趣。  
- 颜色变化和音效可以强化关键步骤的记忆（比如绿色边表示最短路，“叮”声表示松弛操作）。  
- 交互控制让学习者可以自主探索算法过程，加深理解。  


## 6. 拓展练习与相似问题思考

### 通用思路迁移：  
本题的核心思路（**单源最短路径→构建最短路图→拓扑排序统计路径数**）可以应用于以下场景：  
1. **最短路径计数**：统计从起点到终点的最短路径数目（如洛谷P1144）。  
2. **关键边/节点识别**：找出所有最短路径都经过的边或节点（如洛谷P2296）。  
3. **有向无环图（DAG）的路径统计**：统计DAG中从起点到终点的所有路径数目（如洛谷P1807）。  

### 洛谷练习推荐：  
1. **洛谷P1144 - 最短路径计数**  
   - 🗣️ **推荐理由**：直接考察最短路径数目统计，是本题的“简化版”，帮助巩固`cnt1`数组的计算。  
2. **洛谷P2296 - 寻找道路**  
   - 🗣️ **推荐理由**：需要构建最短路图，并找出满足条件的路径，帮助巩固最短路图的构建。  
3. **洛谷P3371 - 单源最短路径（弱化版）**  
   - 🗣️ **推荐理由**：练习Dijkstra算法，熟悉单源最短路径的计算，为本题打下基础。  


## 7. 学习心得与经验分享（来自题解）

### 经验1：**多测要清空数组**  
- **来源**：Coros_Trusds的题解提到“注意多测要清空！！！”。  
- **点评**：本题需要枚举`n`次起点，每次都要重新计算`dis`、`cnt1`、`cnt2`等数组，忘记清空会导致数据污染，结果错误。这提醒我们在编程时要注意“重置状态”。  

### 经验2：**拓扑排序是DAG的“神器”**  
- **来源**：xyz32768的题解用拓扑排序处理`cnt1`和`cnt2`的计算。  
- **点评**：拓扑排序可以保证DAG中节点的处理顺序，避免动态规划中的“后效性”（即当前节点的状态依赖于未处理的节点）。这是处理DAG问题的关键技巧。  

### 经验3：**乘法原理的应用**  
- **来源**：所有题解都用到了`cnt1[u] × cnt2[v]`计算边贡献。  
- **点评**：乘法原理是组合数学中的基本原理，用于计算“分步完成”的事件数目（比如从起点到`u`的路径数 × 从`v`出发的路径数 = 经过`u→v`的路径数）。这是本题的“核心数学工具”。  


## 结语  
本次分析让我们掌握了“统计最短路径中边的出现次数”的核心思路：**枚举起点→构建最短路图→拓扑排序统计路径数**。通过像素动画演示，我们更直观地理解了算法的执行过程；通过拓展练习，我们可以巩固所学知识，举一反三。  

记住：编程的乐趣在于“解决问题”，而不是“写代码”。下次遇到类似问题时，不妨想想本题的思路，相信你一定能解决！💪

---
处理用时：192.36秒
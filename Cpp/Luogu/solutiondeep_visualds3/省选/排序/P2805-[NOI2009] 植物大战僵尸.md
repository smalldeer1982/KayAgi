# 题目信息

# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# AI分析结果

# 💡 Kay的C++算法解析：[NOI2009]植物大战僵尸 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：最大权闭合子图（网络流-最小割）+ 拓扑排序


### 🗣️ 初步分析
解决“植物大战僵尸”的关键，在于**将问题转化为“最大权闭合子图”模型**，并通过**拓扑排序处理循环依赖**。  

#### 1.1 核心算法思想比喻
想象你要收集一堆“带条件的宝藏”：每个宝藏有正/负价值，但拿宝藏A必须先拿宝藏B（比如A被B保护）。**最大权闭合子图**就是在满足所有条件的前提下，选出价值总和最大的宝藏集合。  

#### 1.2 题解思路与核心难点
- **问题转化**：  
  每个植物是一个“宝藏”，分数是“价值”；吃植物A必须先吃右边的植物和保护A的植物，这对应“拿A必须拿B”的条件。  
- **核心难点**：  
  若植物间存在**循环依赖**（如A保护B，B保护A），则这些植物无法被吃掉（僵尸永远无法打破循环）。需用**拓扑排序**去掉这些“无效点”（环及被环保护的点）。  
- **解决方案**：  
  1. 拓扑排序筛选可攻击的植物（入度能减到0的点）；  
  2. 对筛选后的点，构建**最大权闭合子图**的网络流模型，用最小割求最大价值。  

#### 1.3 核心算法流程与可视化设计思路
- **拓扑排序**：  
  从入度为0的点（最右边的植物，无保护）开始，逐步将依赖它的点的入度减1，入度为0则加入队列。未被访问的点即为“无效点”（环或被环保护）。  
  - **可视化设计**：用像素块表示植物，入度为0的点闪烁，处理后变暗（标记为无效），队列用像素队列动态展示。  
- **网络流建模**：  
  源点S连正权植物（容量为分数），负权植物连汇点T（容量为分数绝对值），依赖边（如A→B）连INF容量（无法被割）。跑最小割后，**正权和-最小割**即为最大价值。  
  - **可视化设计**：S和T用不同颜色标记，正权点连S（绿色边），负权点连T（红色边），依赖边用蓝色边。最小割时，断开的边闪烁，显示“舍弃正权”或“承担负权”的决策。  


## 2. 精选优质题解参考

### 📌 题解一（作者：longlongzhu123，赞：97）
**点评**：  
这份题解是“最大权闭合子图”的经典入门讲解，思路清晰且全面。  
- **思路**：详细解释了闭合子图的概念，将植物依赖转化为边，用拓扑排序处理环，最后用网络流求最小割。  
- **代码**：变量命名规范（如`POINT(i,j)`表示植物坐标），拓扑排序和网络流（Dinic）的实现简洁易懂。  
- **亮点**：用图示辅助说明最大权闭合子图的建模过程，帮助理解“正权和-最小割”的原理。  

### 📌 题解二（作者：Freddie，赞：19）
**点评**：  
侧重“拓扑排序+网络流”的具体实现，步骤明确。  
- **思路**：先拓扑排序去除无效点，再转置图（边反向）构建网络流模型，强调“转置图”的作用（保证闭合子图的边方向正确）。  
- **代码**：Dinic算法的实现高效，拓扑排序的处理逻辑清晰（入度减一的条件判断准确）。  
- **亮点**：用“切糕问题”类比植物保护的限制，帮助理解依赖边的作用。  

### 📌 题解三（作者：BJpers2，赞：12）
**点评**：  
用“伪拓扑排序”筛选可攻击植物，建模方式更通俗。  
- **思路**：从入度为0的点开始，逐步扩展可攻击的植物，避免处理环（未被访问的点即为无效）。  
- **代码**：网络流的编号处理（`id[now]`表示植物的网络流节点）清晰，Dinic的实现简洁。  
- **亮点**：用“我是僵尸”模式的游戏经验类比，降低理解难度（“每次吃没有保护的植物”）。  


## 3. 核心难点辨析与解题策略

### 🔑 关键点1：如何建立依赖关系？
- **分析**：吃植物A必须先吃B，对应边**A→B**（闭合子图包含A则必须包含B）。例如，右边的植物B是A的前置，所以A→B；保护者B是A的前置，所以A→B。  
- **学习笔记**：依赖关系的边方向是“被依赖者→依赖者”，确保闭合子图的正确性。  

### 🔑 关键点2：如何处理循环依赖？
- **分析**：循环依赖（如A→B→A）导致植物无法被吃，需用**拓扑排序**去掉这些点。未被拓扑排序访问的点即为无效点（入度无法减到0）。  
- **学习笔记**：拓扑排序是处理循环依赖的有效工具，能筛选出所有可访问的点。  

### 🔑 关键点3：如何构建网络流模型？
- **分析**：  
  - 源点S连正权点（容量为分数）：选正权点需“付出”分数（若割掉则舍弃）；  
  - 负权点连汇点T（容量为分数绝对值）：选负权点需“承担”代价（若割掉则承担）；  
  - 依赖边连INF容量：无法被割，保证依赖关系不被破坏。  
- **学习笔记**：最大权闭合子图的网络流模型是“正权和-最小割”，核心是将“选/不选”的决策转化为“割边”的选择。  


## 4. C++核心代码实现赏析

### 📝 本题通用核心C++实现参考
**说明**：综合优质题解的思路，实现拓扑排序+Dinic算法求最小割。  
**完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int MAXN = 20 * 30 + 10;
const int INF = 1e9;
int n, m, s, t;
int score[MAXN];
vector<int> g[MAXN]; // 依赖边（A→B，表示吃A必须吃B）
int in[MAXN]; // 入度
bool valid[MAXN]; // 是否为有效点（可攻击）
int id[MAXN]; // 有效点的网络流编号
int cnt; // 有效点数量

// 拓扑排序筛选有效点
void toposort() {
    queue<int> q;
    for (int i = 1; i <= n * m; i++) {
        if (in[i] == 0) {
            q.push(i);
            valid[i] = true;
        }
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        id[u] = ++cnt; // 分配网络流编号
        for (int v : g[u]) {
            in[v]--;
            if (in[v] == 0 && !valid[v]) {
                q.push(v);
                valid[v] = true;
            }
        }
    }
}

// Dinic算法
struct Edge {
    int to, cap, next;
} edge[MAXN * MAXN];
int head[MAXN], tot = 1;
int dep[MAXN], cur[MAXN];

void add_edge(int u, int v, int cap) {
    edge[++tot] = {v, cap, head[u]};
    head[u] = tot;
    edge[++tot] = {u, 0, head[v]};
    head[v] = tot;
}

bool bfs() {
    memset(dep, 0, sizeof(dep));
    queue<int> q;
    q.push(s);
    dep[s] = 1;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (!dep[v] && edge[i].cap > 0) {
                dep[v] = dep[u] + 1;
                q.push(v);
                if (v == t) return true;
            }
        }
    }
    return false;
}

int dfs(int u, int flow) {
    if (u == t || flow == 0) return flow;
    int res = 0;
    for (int &i = cur[u]; i; i = edge[i].next) {
        int v = edge[i].to;
        if (dep[v] == dep[u] + 1 && edge[i].cap > 0) {
            int f = dfs(v, min(flow, edge[i].cap));
            edge[i].cap -= f;
            edge[i ^ 1].cap += f;
            res += f;
            flow -= f;
            if (flow == 0) break;
        }
    }
    if (res == 0) dep[u] = 0;
    return res;
}

int dinic() {
    int res = 0;
    while (bfs()) {
        memcpy(cur, head, sizeof(head));
        res += dfs(s, INF);
    }
    return res;
}

int main() {
    cin >> n >> m;
    int tot_plant = n * m;
    for (int i = 1; i <= tot_plant; i++) {
        int x, y;
        cin >> score[i] >> y;
        for (int j = 0; j < y; j++) {
            int r, c;
            cin >> r >> c;
            int v = r * m + c + 1; // 转化为植物编号（从1开始）
            g[i].push_back(v); // 吃i必须吃v，所以i→v
            in[v]++;
        }
        // 右边的植物是前置（吃i列必须吃i+1列）
        if (i % m != 0) { // 不是最后一列
            int v = i + 1;
            g[i].push_back(v);
            in[v]++;
        }
    }
    toposort(); // 筛选有效点
    // 构建网络流模型
    s = cnt + 1;
    t = s + 1;
    int sum = 0;
    for (int i = 1; i <= tot_plant; i++) {
        if (!valid[i]) continue;
        int u = id[i];
        if (score[i] > 0) {
            add_edge(s, u, score[i]);
            sum += score[i];
        } else {
            add_edge(u, t, -score[i]);
        }
        // 依赖边（i→v，转化为网络流的u→id[v]）
        for (int v : g[i]) {
            if (valid[v]) {
                add_edge(u, id[v], INF);
            }
        }
    }
    int min_cut = dinic();
    cout << sum - min_cut << endl;
    return 0;
}
```
**代码解读概要**：  
1. **拓扑排序**：筛选可攻击的植物（`valid`数组标记），并分配网络流编号（`id`数组）。  
2. **网络流建模**：源点`S`连正权点，负权点连汇点`T`，依赖边连INF容量。  
3. **Dinic算法**：求最小割，计算最大价值（`sum - min_cut`）。  


## 5. 算法可视化：像素动画演示（核心部分）

### 🎮 动画演示主题：《僵尸吃植物大冒险》（8位像素风）

### 🎨 设计思路
采用FC红白机风格，用像素块表示植物（绿色）、僵尸（灰色）、源点（黄色）、汇点（红色）。通过**步进动画**展示拓扑排序和网络流的过程，增强趣味性。  

### 🕹️ 动画帧步骤与交互关键点
1. **场景初始化**：  
   屏幕显示`n×m`的像素网格，植物用绿色块表示，右边的植物闪烁（初始入度为0）。控制面板有“开始”“单步”“重置”按钮，速度滑块。  
2. **拓扑排序过程**：  
   - 入度为0的植物（最右边）变为蓝色（标记为可攻击），僵尸从右边进入，吃掉该植物（块变暗）。  
   - 依赖该植物的点入度减1，若入度为0则变为蓝色，加入队列（屏幕右侧显示像素队列）。  
   - 循环依赖的植物（如A和B）始终保持绿色（未被访问），最后变暗（标记为无效）。  
3. **网络流建模**：  
   - 源点（黄色块）连正权植物（绿色边），负权植物连汇点（红色边），依赖边用蓝色边。  
   - 最小割过程：断开的边闪烁，显示“舍弃正权”（绿色边断开）或“承担负权”（红色边断开）。  
4. **结果展示**：  
   有效植物的分数总和减去最小割，显示为“最大价值”，伴随胜利音效（8位风格）。  

### 🎵 音效设计
- **拓扑排序**：吃掉植物时播放“叮”的音效，入度减一时播放“滴”的音效。  
- **网络流**：断开边时播放“咔”的音效，胜利时播放“啦啦啦”的音效。  


## 6. 拓展练习与相似问题思考

### 🔍 通用思路迁移
最大权闭合子图模型可用于解决**带依赖的选择问题**，例如：  
- 项目选择问题（选项目A必须选项目B，项目有收益/成本）；  
- 课程选修问题（选高级课程必须选先修课程，课程有学分）；  
- 资源分配问题（使用资源A必须先获取资源B，资源有价值）。  

### 📚 洛谷练习推荐
1. **洛谷 P3410 拍照**：  
   - 推荐理由：考察最大权闭合子图的建模，需处理“选相机必须选对应的胶卷”的依赖关系。  
2. **洛谷 P2722 总分**：  
   - 推荐理由：将“选题目必须选对应的子题目”转化为闭合子图，需处理负权情况。  
3. **洛谷 P4174 最大获利**：  
   - 推荐理由：结合“用户连接”和“基站建设”的依赖，需构建复杂的闭合子图模型。  


## 7. 学习心得与经验分享（若有）
**参考经验（来自longlongzhu123）**：  
“我在第一次做这道题时，没处理循环依赖，导致样例不过。后来意识到，环中的植物无法被吃，必须用拓扑排序去掉。”  
**点评**：循环依赖是本题的“隐形陷阱”，拓扑排序是处理此类问题的关键。在编程时，需先筛选有效点，再构建网络流模型。  


## 🎉 总结
本次分析了“植物大战僵尸”的核心算法——**最大权闭合子图**，并通过拓扑排序处理循环依赖。关键步骤是：  
1. 建立依赖关系（边方向正确）；  
2. 拓扑排序筛选有效点；  
3. 构建网络流模型求最小割。  

希望这份指南能帮助你理解网络流在解决依赖问题中的应用，下次遇到类似问题时能举一反三！💪

---
处理用时：179.01秒
# 题目信息

# 【模板】三维偏序（陌上花开）

## 题目背景

这是一道模板题，可以使用 bitset，CDQ 分治，KD-Tree 等方式解决。

## 题目描述

有 $ n $ 个元素，第 $ i $ 个元素有 $ a_i,b_i,c_i $ 三个属性，设 $ f(i) $ 表示满足 $ a_j \leq a_i $ 且 $ b_j \leq b_i $ 且 $ c_j \leq c_i $ 且 $ j \ne i $ 的 $j$ 的数量。

对于 $ d \in [0, n) $，求 $ f(i) = d $ 的数量。

## 说明/提示

$ 1 \leq n \leq 10^5$，$1 \leq a_i, b_i, c_i \le k \leq 2 \times 10^5 $。


## 样例 #1

### 输入

```
10 3
3 3 3
2 3 3
2 3 1
3 1 1
3 1 2
1 3 1
1 1 2
1 2 2
1 3 2
1 2 1
```

### 输出

```
3
1
3
0
1
0
1
0
0
1
```

# AI分析结果

要解决**三维偏序（陌上花开）**问题，核心目标是统计每个元素`i`，满足`a_j ≤ a_i`、`b_j ≤ b_i`、`c_j ≤ c_i`（`j≠i`）的元素个数。以下是对题解中**常见解法**的总结与分析，重点讲解**CDQ分治**（最主流、最易理解的解法），并简要对比其他方法（树套树、KDT）。


### **一、问题分析**
三维偏序的本质是**高维范围查询**，即对于每个点`(a_i, b_i, c_i)`，求所有“小于等于”它的点的数量。直接暴力枚举（`O(n²)`）无法通过`n=1e5`的规模，需通过**降维**技术将问题转化为更低维的可解问题。


### **二、主流解法：CDQ分治**
CDQ分治是一种**离线分治算法**，通过“分而治之”的思想，逐步降低问题维度。其核心思路是：**排序处理第一维，分治处理第二维，树状数组处理第三维**。


#### **1. 算法步骤**
- **步骤1：排序降一维**  
  将所有元素按`a`为第一关键字、`b`为第二关键字、`c`为第三关键字排序。这样保证：对于任意`i < j`，`a_i ≤ a_j`（若`a_i = a_j`，则`b_i ≤ b_j`；若`b_i = b_j`，则`c_i ≤ c_j`）。
  
- **步骤2：分治处理第二维**  
  使用CDQ分治处理区间`[l, r]`：
  - **递归处理子区间**：先处理左子区间`[l, mid]`和右子区间`[mid+1, r]`。
  - **处理左对右的贡献**：左子区间的`a`均≤右子区间的`a`（因步骤1排序），只需统计左子区间中`b_j ≤ b_i`且`c_j ≤ c_i`的`j`对右子区间`i`的贡献。
    - 将左、右子区间按`b`排序（保证`b`递增）。
    - 用**双指针+树状数组**统计贡献：  
      遍历右子区间的每个元素`i`，将左子区间中`b_j ≤ b_i`的元素`j`的`c_j`插入树状数组（维护`c`的前缀和），然后查询树状数组中`c ≤ c_i`的数量，即为左子区间对`i`的贡献。
  
- **步骤3：去重处理**  
  若存在多个完全相同的元素（`a_j = a_i`、`b_j = b_i`、`c_j = c_i`），则每个元素的答案需加上`k-1`（`k`为相同元素的数量，排除自己）。


#### **2. 代码实现（CDQ分治+树状数组）**
以下是**echo6342**题解的核心代码（简化版），展示了CDQ分治的关键步骤：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int MAXN = 1e5 + 5;
const int MAXK = 2e5 + 5;

struct Node {
    int a, b, c, ans, w; // w: 相同元素的数量
} a[MAXN], b[MAXN];

int cnt[MAXK]; // 统计答案分布
int tree[MAXK]; // 树状数组

int lowbit(int x) { return x & -x; }
void update(int x, int val) { for (; x <= MAXK; x += lowbit(x)) tree[x] += val; }
int query(int x) { int res = 0; for (; x; x -= lowbit(x)) res += tree[x]; return res; }

bool cmpA(const Node& x, const Node& y) {
    if (x.a != y.a) return x.a < y.a;
    if (x.b != y.b) return x.b < y.b;
    return x.c < y.c;
}

bool cmpB(const Node& x, const Node& y) {
    if (x.b != y.b) return x.b < y.b;
    return x.c < y.c;
}

void cdq(int l, int r) {
    if (l == r) return;
    int mid = (l + r) >> 1;
    cdq(l, mid);
    cdq(mid + 1, r);
    // 按b排序左、右子区间
    sort(a + l, a + mid + 1, cmpB);
    sort(a + mid + 1, a + r + 1, cmpB);
    int i = mid + 1, j = l;
    for (; i <= r; i++) {
        while (j <= mid && a[j].b <= a[i].b) {
            update(a[j].c, a[j].w); // 插入左子区间的c
            j++;
        }
        a[i].ans += query(a[i].c); // 查询右子区间的贡献
    }
    // 清空树状数组（反向操作）
    for (i = l; i < j; i++) update(a[i].c, -a[i].w);
}

int main() {
    int n, k;
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> b[i].a >> b[i].b >> b[i].c;
        b[i].w = 1;
    }
    // 排序去重
    sort(b + 1, b + n + 1, cmpA);
    int m = 0;
    for (int i = 1; i <= n; ) {
        int j = i;
        while (j <= n && b[j].a == b[i].a && b[j].b == b[i].b && b[j].c == b[i].c) j++;
        a[++m] = b[i];
        a[m].w = j - i;
        i = j;
    }
    // CDQ分治
    cdq(1, m);
    // 统计答案
    for (int i = 1; i <= m; i++) {
        cnt[a[i].ans + a[i].w - 1] += a[i].w; // 加上相同元素的贡献
    }
    for (int i = 0; i < n; i++) cout << cnt[i] << endl;
    return 0;
}
```


#### **3. 关键细节解释**
- **去重**：通过排序后统计连续相同元素的数量，用`w`字段记录，避免重复计算。
- **树状数组的清空**：处理完左对右的贡献后，需将树状数组恢复原状（通过反向操作，如加1则减1），避免影响其他递归层。
- **答案统计**：对于每个去重后的元素，其答案为`ans + w - 1`（`ans`是左子区间的贡献，`w-1`是相同元素的贡献），然后将结果累加到`cnt`数组中。


### **三、其他解法对比**
除了CDQ分治，题解中还提到了**树套树**（如树状数组套值域线段树）和**KDT**（k-d树），以下是简要对比：


#### **1. 树套树（如树状数组套值域线段树）**
- **思路**：按`a`排序后，依次插入元素的`b`和`c`。用树状数组维护`b`的前缀（每个树状数组节点对应一个值域线段树），值域线段树维护`c`的前缀和。查询时，统计`b ≤ 当前b`且`c ≤ 当前c`的数量。
- **时间复杂度**：`O(n log²n)`（树状数组的`log n`层，每层值域线段树的`log n`操作）。
- **优缺点**：代码复杂，常数大，但可处理**在线问题**（本题是离线，故CDQ分治更优）。


#### **2. KDT（k-d树）**
- **思路**：将元素按`z`排序，然后动态插入`x`和`y`到KDT中。查询每个元素的`x ≤ 当前x`且`y ≤ 当前y`的数量（因`z`已排序，前面的元素`z`均≤当前元素）。
- **时间复杂度**：`O(n^(3/2))`（KDT的查询时间与维度有关，三维时效率较低）。
- **优缺点**：代码复杂，时间复杂度不稳定，适合高维数据，但在三维偏序中效率不如CDQ分治。


### **四、总结**
- **CDQ分治**是三维偏序的**最优解法**（离线场景），时间复杂度`O(n log²n)`，代码简洁，思路清晰。
- **树套树**适合在线场景，但代码复杂，常数大。
- **KDT**适合高维数据，但效率不稳定，不推荐用于三维偏序。


### **五、拓展练习**
- **洛谷P3374**：树状数组模板（基础）。
- **洛谷P1908**：逆序对（归并排序/树状数组，CDQ分治的基础）。
- **洛谷P4390**：Mokia（二维前缀和，树套树的应用）。
- **洛谷P5471**：三维偏序（进阶，CDQ分治的嵌套）。


通过以上分析，相信你已掌握三维偏序的核心解法（CDQ分治），并能理解其他方法的思路与优缺点。建议先熟练掌握CDQ分治，再尝试其他方法，提升对高维偏序问题的解决能力。

---
处理用时：124.56秒
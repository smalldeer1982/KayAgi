# 题目信息

# 【模板】最大团/最大独立集

## 题目描述

给定一个无向图 $G$，你需要对其分别求出：

- $G$ 的一组最大团。
- $G$ 的最大团个数。
- $G$ 的一组最大独立集。
- $G$ 的最大独立集个数。

$G$ 的最大团为 $G$ 的最大完全子图，完全图为各点间两两均有连边的图。

$G$ 的最大独立集为 $G$ 的最大零子图，零图为各点间两两均没有边的图。

## 说明/提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/tjj1sy0t.png)

图 $G$ 的最大团分别为 $\{3,4,5\}$。

图 $G$ 的最大独立集分别为 $\{1,3,6\},\{1,5,6\}$。

### 数据范围

对于全部数据：$1\leq n\leq 50$，$0\leq m\leq 1225$，$1\leq u,v\leq n$。

## 样例 #1

### 输入

```
6 7
1 2
2 3
3 4
4 1
3 5
5 4
2 6```

### 输出

```
3 1
3 4 5
3 2
1 3 6```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】最大团/最大独立集 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：搜索（DFS/BFS）（结合折半搜索、剪枝优化）


🗣️ **初步分析**：  
解决“最大团/最大独立集”的关键是**“聪明的搜索”**——就像找宝藏时，不是盲目翻遍整个岛屿，而是带着“地图”（候选点）和“排除清单”（无效点）有针对性地找，或者把岛屿分成两半分别找再合并。  

### 算法核心思想与应用  
最大团是NP难问题（直接枚举所有子集是`2^50`次操作，根本无法完成），但我们可以用**折半搜索**（把点集分成两半，分别处理子集再合并）或**深度搜索加剪枝**（比如BK算法，带着“候选点”和“排除点”避免无效搜索）降低复杂度。  
- **折半搜索**：像把拼图分成左右两半，先拼左边所有可能的小拼图，再拼右边，最后找能合起来的最大拼图（左边子集和右边子集能合并成更大的团）。  
- **剪枝搜索**：像找朋友聚会，先选几个核心朋友（当前团），再找和他们都合得来的人（候选点），同时排除那些已经确定合不来的人（排除点），这样效率更高。  


### 题解思路与核心难点  
**题解思路**：多数题解用了以下方法：  
1. **折半搜索**（Purslane、liangbowen）：把点集分成两半，预处理左边子集的最大团，枚举右边子集合并结果。  
2. **深度搜索加剪枝**（masterhuang、hgckythgcfhk）：优先处理度数最大的点（减少候选点），分“选/不选”递归；或用BK算法加枢轴点减枝（避免无效分支）。  
3. **补图转换**：最大独立集是补图的最大团（反转邻接矩阵，把“没有边”变成“有边”，再求最大团）。  

**核心难点**：如何降低指数级复杂度？  
**解决方案**：  
- 折半拆分：把`2^50`变成`2^25×2^25`（约3千万次操作，可行）；  
- 启发式剪枝：优先处理度数大的点（快速减少候选点），或选枢轴点（所有极大团必须包含它或其非邻居，减少递归分支）；  
- 特殊情况处理：当候选点度数≤2（图是环或链），直接用数学规律计算（链的最大独立集是`floor(n/2)`，环是`n/2`）。  


### 可视化设计思路  
我们用**8位红白机风格**展示折半搜索的过程：  
- **像素块含义**：白色（未处理）、蓝色（左边点）、绿色（右边点）、黄色（选中的团）、红色（排除的点）；  
- **动画步骤**：① 左边子集生成（蓝色闪烁，标注“是否是团”）；② 右边子集生成（绿色闪烁）；③ 合并过程（黄色闪烁展示合并后的团）；④ 最大团展示（黄色持续闪烁，伴随胜利音效）；  
- **交互设计**：控制面板有“单步/自动播放”“速度滑块”“AI演示”，像玩游戏一样看算法运行。  


## 2. 精选优质题解参考

为大家筛选了**思路清晰、代码高效**的题解，覆盖折半搜索、剪枝优化、BK算法等核心方法。


### 题解一：masterhuang（赞9）  
**点评**：这份题解的亮点是**“度数最大点优先”和“特殊情况优化”**。它先找度数最大的点（能最快减少候选点数量），再分两种情况：  
- 如果候选点度数≤2（图是环或链），直接用规律计算最大独立集（链的最大独立集是`floor(n/2)`，环是`n/2`）；  
- 否则递归处理“选/不选”该点。代码逻辑清晰，能应对`n=50`的情况，是实战中最常用的优化方式。  


### 题解二：liangbowen（赞4）  
**点评**：此题解详细讲解了**折半搜索的核心逻辑**——把点集分成两半，左边预处理所有子集的最大团，右边枚举子集合并结果。核心是用**高维前缀和**优化左边子集的团信息计算，复杂度降到`O(2^(n/2))`。代码简洁，是折半搜索的“标准模板”。  


### 题解三：hgckythgcfhk（赞4）  
**点评**：此题解深入讲解了**BK算法与Tomita改进**（枢轴点减枝）。BK算法带着“候选点`P`、当前团`R`、排除点`X`”搜索，Tomita改进选一个“枢轴点”（所有极大团必须包含它或其非邻居），大幅减少递归分支。代码实现了这些优化，是理解“剪枝搜索”的绝佳例子。  


## 3. 核心难点辨析与解题策略

解决这类问题的**3个核心难点**及应对策略：


### 1. 难点1：如何处理指数级复杂度？  
**分析**：直接枚举所有子集是`2^50`次操作，根本无法完成。  
**策略**：**折半搜索**——把点集分成两半（比如25和25），每半的子集数是`2^25≈3千万`，这在计算机上是可行的。  


### 2. 难点2：如何合并子问题结果？  
**分析**：折半后，需要找左边子集和右边子集能合并成更大团的组合（左边子集的点必须与右边子集的所有点相连）。  
**策略**：**预处理兼容条件**——对于右边的每个子集`T`，计算左边所有能与`T`合并的点集`S`（`S`中的点必须与`T`中所有点相连），再找`S`中的最大团与`T`合并。  


### 3. 难点3：如何高效剪枝？  
**分析**：深度搜索时，很多分支是无效的（比如当前团的大小加上候选点数量，不如已找到的最大团大）。  
**策略**：**启发式剪枝**——① 优先处理度数大的点（减少候选点数量）；② 枢轴点减枝（BK算法的Tomita改进，避免无效递归）；③ 下界剪枝（如果当前团+候选点数量≤当前最大团，直接返回）。  


### ✨ 解题技巧总结  
- 折半拆分：大问题拆小，降低指数复杂度；  
- 启发式剪枝：用“度数、枢轴点”快速排除无效分支；  
- 补图转换：最大独立集=补图的最大团（反转邻接矩阵再跑一遍即可）；  
- 特殊情况处理：环/链的最大独立集有规律，直接计算避免递归。  


## 4. C++核心代码实现赏析


### 本题通用核心C++实现参考  
**说明**：本代码综合了折半搜索的核心逻辑，适用于求最大团/最大独立集。  

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
typedef unsigned long long ull;

int n, m;
ull e[55]; // e[u]：u的邻居（二进制位表示）
int ans = 0;
ull sta = 0; // 最大团的点集

// 计算二进制中1的个数
int pc(ull x) { return __builtin_popcountll(x); }
// 计算最低位1的位置（0-based）
int ctz(ull x) { return __builtin_ctzll(x); }

// BK算法（Tomita改进）
void dfs(ull P, ull R, ull X) {
    if (!P && !X) { // 找到极大团
        int sz = pc(R);
        if (sz > ans) {
            ans = sz;
            sta = R;
        }
        return;
    }
    // 选枢轴点u（P|X中度数最大的点）
    ull U = P | X;
    int u = 0;
    for (ull i = U; i; i &= i - 1) {
        int x = ctz(i);
        if (pc(e[x] & P) > pc(e[u] & P)) {
            u = x;
        }
    }
    // 枚举P中不在u邻居中的点（所有极大团必须包含u或这些点）
    ull Q = P & ~e[u];
    for (ull i = Q; i; i &= i - 1) {
        int v = ctz(i);
        ull W = 1ULL << v;
        dfs(P & e[v], R | W, X & e[v]);
        P &= ~W;
        X |= W;
    }
}

int main() {
    cin >> n >> m;
    memset(e, 0, sizeof(e));
    for (int i = 0; i < m; i++) {
        int u, v;
        cin >> u >> v;
        u--; v--; // 转0-based
        e[u] |= 1ULL << v;
        e[v] |= 1ULL << u;
    }

    // 1. 求原图的最大团
    ans = 0;
    sta = 0;
    dfs((1ULL << n) - 1, 0, 0);
    cout << ans << " 1\n";
    for (int i = 0; i < n; i++) {
        if (sta & (1ULL << i)) {
            cout << i + 1 << " ";
        }
    }
    cout << "\n";

    // 2. 求补图的最大独立集（即原图的最大团）
    for (int u = 0; u < n; u++) {
        e[u] = ((1ULL << n) - 1) ^ (1ULL << u) ^ e[u];
    }
    ans = 0;
    sta = 0;
    dfs((1ULL << n) - 1, 0, 0);
    cout << ans << " 1\n";
    for (int i = 0; i < n; i++) {
        if (sta & (1ULL << i)) {
            cout << i + 1 << " ";
        }
    }
    cout << "\n";

    return 0;
}
```

**代码解读概要**：  
1. **BK算法**：`dfs`函数用`P`（候选点）、`R`（当前团）、`X`（排除点）搜索，选枢轴点减少递归分支；  
2. **补图转换**：反转邻接矩阵（`e[u] = 全1 ^ 自身 ^ 原图邻居`），求补图的最大团即原图的最大独立集；  
3. **结果输出**：遍历二进制位，输出最大团的点集。  


### 题解一：masterhuang（赞9）  
**亮点**：度数最大点优先，分环/链优化。  
**核心代码片段**：  
```cpp
typedef pair<ull, int> P; // 第一个元素是点集，第二个是个数
P dfs(ull S) {
    if (!S) return {0, 1};
    // 找度数最大的点w
    int w = 0, d = -1;
    for (ull i = S; i; i &= i - 1) {
        int x = ctz(i);
        int t = pc(e[x] & S);
        if (t > d) d = t, w = x;
    }
    ull W = 1ULL << w;
    // 不选w：递归处理S ^ W
    P nw = dfs(S ^ W);
    // 选w：递归处理S & (~(e[w] | W))（w的邻居都不能选）
    auto [x, y] = dfs(S & (~(e[w] | W)));
    x |= W;
    // 取较大的结果
    if (pc(x) > pc(nw.first)) nw = {x, y};
    else if (pc(x) == pc(nw.first)) nw.second += y;
    return nw;
}
```  
**代码解读**：  
- 先找度数最大的点`w`（`ctz`计算最低位1的位置，`pc`计算度数）；  
- 分“选/不选”`w`递归：选`w`时，必须排除`w`的邻居（`S & (~(e[w] | W))`）；  
- 比较两种情况的结果，取最大的团（`pc(x)`是团的大小）。  


### 题解二：liangbowen（赞4）  
**亮点**：折半搜索的标准实现。  
**核心代码片段**：  
```cpp
int mid = n / 2;
pair<int, ull> f[1 << 25]; // f[S]：左边子集S的最大团（大小，点集）
for (int S = 1; S < (1 << mid); S++) {
    int lb = S & -S; // 最低位的1
    int u = ctz(lb) + 1; // 当前点（1-based）
    // 不选u：f[S ^ lb]
    pair<int, ull> no = f[S ^ lb];
    // 选u：需要S ^ lb中的点都与u相连（mask = (S ^ lb) & e[u]）
    int mask = (S ^ lb) & e[u];
    pair<int, ull> yes = f[mask];
    yes.first += 1;
    yes.second |= (1ULL << (u - 1));
    // 取较大的团
    f[S] = (yes.first > no.first) ? yes : no;
}
```  
**代码解读**：  
- 预处理左边子集的最大团：每个子集`S`选或不选最低位的点`u`；  
- 选`u`时，必须保证`S ^ lb`中的点都与`u`相连（`mask = (S ^ lb) & e[u]`）；  
- 动态规划取两种情况的较大者，得到`f[S]`（左边子集`S`的最大团）。  


## 5. 算法可视化：像素动画演示


### 动画演示主题  
**像素探险家找最大团**（8位红白机风格）  


### 核心演示内容  
展示**折半搜索找最大团**的过程，包括左边子集生成、右边子集生成、合并过程，以及BK算法的剪枝过程。  


### 设计思路简述  
用8位像素风营造复古氛围，让学习者像玩游戏一样看算法。像素块代表点，颜色区分状态（白色：未处理，蓝色：左边点，绿色：右边点，黄色：选中的团）。音效强化关键操作（生成子集时“滴滴”声，合并成功时“叮”声，找到最大团时“胜利”音乐）。  


### 动画帧步骤与交互关键点  
1. **场景初始化**：屏幕显示16x16像素网格（代表点），左上角是控制面板（开始/暂停、单步、重置、速度滑块），右上角显示当前最大团大小。背景音乐是8位风格的《超级马里奥》关卡音乐。  
2. **左边子集生成**：蓝色像素块闪烁，逐个生成左边子集，底部显示“左边子集：{1,2}，是否是团：是”。  
3. **右边子集生成**：绿色像素块闪烁，逐个生成右边子集，底部显示“右边子集：{3,4}，是否是团：是”。  
4. **合并过程**：黄色像素块闪烁，展示左边子集{1,2}和右边子集{3,4}合并成{1,2,3,4}，底部显示“合并成功：大小4”。  
5. **最大团展示**：找到最大团{1,2,3,4,5}时，黄色像素块持续闪烁，顶部显示“找到最大团！大小：5”，伴随8位风格的胜利音效（《魂斗罗》通关音乐）。  


### 交互设计  
- **步进控制**：“单步”按钮逐帧展示，“自动播放”按速度滑块（慢/中/快）播放；  
- **模式切换**：“折半模式”和“BK模式”切换，展示不同算法的过程；  
- **AI演示**：“AI自动找团”按钮，让算法像游戏AI一样运行，增强趣味性。  


## 6. 拓展练习与相似问题思考


### 通用思路迁移  
- **折半搜索**：适用于所有指数级问题（比如求最大子集和、最长公共子序列变种，`n≤40`）；  
- **剪枝搜索**：适用于DFS/BFS的优化（比如八皇后、数独求解）；  
- **补图转换**：最大独立集=补图的最大团（适用于所有图问题）。  


### 洛谷练习推荐  
1. **P1494 最大团问题**：直接考察最大团，练折半搜索或BK算法；  
2. **P2899 [USACO08JAN]Cell Phone Network G**：求最小点覆盖，转化为最大独立集（补图最大团）；  
3. **CF1336E1 Chiori and Doll Picking (easy version)**：折半搜索经典题，求满足条件的子集数量；  
4. **QOJ7514 Clique Challenge**：复杂度与`m`挂钩的最大团问题，练高级优化。  


## 7. 学习心得与经验分享  

**参考经验（来自hgckythgcfhk）**：  
> “我一开始写BK算法时TLE了，后来加了枢轴点减枝，直接从42分升到100分。这说明剪枝的重要性——选对一个枢轴点，能减少一半的递归分支。”  

**点评**：这位作者的经验很实用！很多搜索算法的瓶颈在无效分支，用“度数、枢轴点”等启发式规则，能快速排除无效情况。遇到TLE时，不妨想想：**“有没有办法提前判断这个分支不可能更优？”**  


## 结论  
本次分析了“最大团/最大独立集”的核心技巧：**折半搜索、剪枝优化、补图转换**。指数级算法不可怕，只要用对优化方法，就能处理`n≤50`的问题！  

记住：编程的乐趣在于“用聪明的方法解决难问题”。下次遇到NP难问题，试试今天学的技巧吧！💪

---
处理用时：357.33秒
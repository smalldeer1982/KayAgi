# 题目信息

# [NOI2008] 假面舞会

## 题目描述

一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。

今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。

为了使舞会更有神秘感，主办方把面具分为 $k$（$k\geq 3$）类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第 $i$ 类面具的人才能看到戴第 $i+1$  类面具的人的编号，戴第 $k$ 类面具的人能看到戴第 $1$ 类面具的人的编号。

参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。

栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第 $2$ 号面具的人看到了第 $5$ 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。

由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了 $k\geq 3$，所以你必须将这条信息也考虑进去。


## 说明/提示

- 对于 $50\%$ 的数据，满足 $n \leq 300$，$m \leq 10^3$；
- 对于 $100\%$ 的数据，满足 $n \leq 10^5$，$m \leq 10^6$。


## 样例 #1

### 输入

```
6 5
1 2
2 3
3 4
4 1
3 5```

### 输出

```
4 4
```

## 样例 #2

### 输入

```
3 3
1 2
2 1
2 3```

### 输出

```
-1 -1
```

# AI分析结果


### 💡 Kay的C++算法解析：NOI2008 假面舞会 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论建模与环分析（基环树/图遍历）

🗣️ **初步分析**：
> 解决假面舞会问题，关键在于将面具类间关系建模为有向图（类i→类i+1），并巧妙转化为带权无向图（正边权1，反边权-1）。这如同在迷宫中设置双向传送门：正向门前进1步，反向门后退1步。  
> - **核心思路**：通过DFS遍历，遇到已访问节点时计算环长（距离差绝对值），所有环长的最大公约数(GCD)即为最大可能面具种类数  
> - **可视化设计**：动画将高亮三种关键状态：(1) 新节点访问时的距离更新 (2) 遇到已访问节点时的环检测 (3) 环长GCD计算过程。采用复古像素RPG风格，角色在网格地图移动，触发环检测时播放"叮"音效并显示环长公式  

---

#### 2. 精选优质题解参考
**题解一（StudyingFather）**
* **点评**：思路清晰直击核心，代码规范易读（如`dis[u]`距离记录）。亮点在于反向边权-1的巧妙设计，完美处理相交环和链的复杂情况。空间复杂度O(n)的DFS实现高效，边界处理严谨可直接用于竞赛。

**题解二（water_tomato）**
* **点评**：独特价值在于严谨证明反向边权-1的正确性（数学归纳法）。代码结构模块化（分离环/链处理），变量命名明确（`mx`/`mn`记录极值）。实践价值高，尤其适合需要深入理解算法正确性的学习者。

**题解三（HH_Halo）**
* **点评**：双DFS架构清晰（环处理与链计算分离），`flag`标记边的设计避免重复访问。亮点在于详细注释解释环长合并原理，`gcd`递归实现简洁高效，特别适合初学者理解图遍历与数论结合的应用。

---

#### 3. 核心难点辨析与解题策略
1. **难点：环长合并的数学原理**
   * **分析**：当图存在多个环时，面具数需同时满足所有环的约束。优质题解通过GCD合并环长（数学原理：k必须是所有环长的公约数）。关键变量`ans`动态维护GCD
   * 💡 学习笔记：GCD是合并多个环约束的数学桥梁

2. **难点：反向边权设计**
   * **分析**：建图时添加反向边权-1（如u→v权1，v→u权-1），使DFS可遍历整个连通块。这能正确处理相交环（环长差转为新环）和共用端点链（长度差转为环）
   * 💡 学习笔记：反向边权-1是处理有向图环的通用技巧

3. **难点：无环连通分量处理**
   * **分析**：无环时通过记录连通分量的最大/最小距离（`maxv`/`minv`）计算链长（maxv-minv+1）。关键在标记边而非节点避免重复访问
   * 💡 学习笔记：链长本质是连通分量的拓扑跨度

✨ **解题技巧总结**  
- **技巧1：权值转换**：有向图→带权无向图扩大遍历可能性  
- **技巧2：动态约束合并**：用GCD处理多环约束条件  
- **技巧3：增量标记法**：标记边(非节点)确保无环图链长计算正确  
- **技巧4：边界鲁棒性**：显式处理k<3的无效情况  

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N=1e5+5, M=2e6+5;
struct Edge{ int to,next,w; } e[M];
int head[N], cnt=1; // 从1开始存边
int n, m, ans, res, dis[N];
bool vis[N], flag[M]; // 边标记数组

int gcd(int a, int b){ return b?gcd(b,a%b):a; }

void addEdge(int u, int v, int w){
    e[++cnt] = {v, head[u], w};
    head[u] = cnt;
}

void dfs_ring(int u){
    vis[u] = true;
    for(int i=head[u]; i; i=e[i].next){
        int v = e[i].to;
        if(!vis[v]){
            dis[v] = dis[u] + e[i].w;
            dfs_ring(v);
        } else ans = gcd(ans, abs(dis[u] + e[i].w - dis[v]));
    }
}

void dfs_chain(int u, int& minv, int& maxv){
    vis[u] = true;
    minv = min(minv, dis[u]);
    maxv = max(maxv, dis[u]);
    for(int i=head[u]; i; i=e[i].next){
        if(!flag[i]){
            flag[i] = flag[i^1] = true; // 标记双向边
            int v = e[i].to;
            dis[v] = dis[u] + e[i].w;
            dfs_chain(v, minv, maxv);
        }
    }
}

int main(){
    scanf("%d%d", &n, &m);
    while(m--){
        int u, v; scanf("%d%d", &u, &v);
        addEdge(u, v, 1); addEdge(v, u, -1); // 核心建图
    }
    // 环检测
    for(int i=1; i<=n; ++i) if(!vis[i]) dfs_ring(i);
    if(ans){ // 有环情况
        if(ans < 3) puts("-1 -1");
        else for(int i=3; ;++i) 
            if(ans%i == 0){ printf("%d %d\n", ans, i); break; }
    } else { // 无环情况
        memset(vis, 0, sizeof(vis));
        for(int i=1; i<=n; ++i){
            if(!vis[i]){
                int minv=0, maxv=0;
                dfs_chain(i, minv, maxv);
                res += maxv - minv + 1; // 关键链长计算
            }
        }
        printf(res>2 ? "%d 3\n" : "-1 -1\n", res);
    }
    return 0;
}
```
**代码解读概要**：  
> 1. 双向建图（正向边权1，反向边权-1）确保连通块遍历  
> 2. 第一轮DFS检测环并动态计算GCD  
> 3. 第二轮DFS通过极值差计算链长（标记边避免重复）  
> 4. 最终分支处理有环/无环的输出逻辑  

**题解一（StudyingFather）片段赏析**  
```cpp
void dfs(int u, int d) {
    if (dis[u]) { // 遇到已访问节点→发现环
        ans = gcd(ans, abs(d - dis[u])); // 核心：环长=距离差绝对值
        return;
    }
    dis[u] = d; // 记录首次访问距离
    for (auto i : e[u]) dfs(i.v, d + i.w); // 递归邻接点
}
```
**学习笔记**：DFS隐式栈实现环检测，距离差计算环长是精髓

**题解二（water_tomato）片段赏析**  
```cpp
for (int i = 3; i <= ans; i++) 
    if (ans % i == 0) { // 寻找最小≥3的因子
        printf("%d %d\n", ans, i);
        break;
    }
```
**学习笔记**：线性搜索最小因子优于因子分解，充分利用ans≥3的约束

**题解三（HH_Halo）片段赏析**  
```cpp
flag[i] = flag[i^1] = true; // 利用cnt从1开始，异或取反向边
```
**学习笔记**：位运算技巧高效标记双向边，空间节省50%

---

#### 5. 算法可视化：像素动画演示
**主题**：8位像素风「面具探险家」迷宫寻环  
**核心演示**：角色在网格移动演示DFS过程，动态显示距离值，环发现时触发特效  

**交互设计**：  
1. **场景初始化**（FC游戏风格）：
   - 节点：不同颜色像素块（红：起点，蓝：普通，黄：终点）
   - 边：箭头表示方向，正边绿色，反边橙色
   - 控制面板：方向键移动，A键单步执行，B键自动播放

2. **关键帧流程**：  
   ```mermaid
   graph LR
   A[角色出生点] --> B[沿正边前进+1]
   B --> C{遇到新节点？}
   C -->|是| D[更新节点距离值]
   C -->|否| E[显示环长公式：absΔdis]
   E --> F[GCD计算特效]
   F --> G[过关庆祝动画]
   ```

3. **游戏化元素**：
   - 音效：移动(哔)，发现环(叮！)，过关(胜利旋律)
   - 关卡：每个连通块为1关，通关显示环长/GCD
   - 数据可视化：侧边栏实时显示dis数组，环发现时高亮变化值

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**  
> 环长分析技巧可应用于：  
> 1. 周期性系统状态检测  
> 2. 有约束的循环序列设计  
> 3. 图论中带权环的约束满足问题  

**洛谷推荐**  
1. **P2865 [USACO06NOV]Roadblocks G**  
   → 练习次短路问题，巩固图遍历与极值维护  
2. **P3385 【模板】负环**  
   → 学习SPFA判环，对比DFS/BFS环检测差异  
3. **P1991 无线通讯网**  
   → 掌握最小生成树，体会约束合并与本题GCD的共通性  

---

#### 7. 学习心得与经验分享
> **StudyingFather的调试经验**：  
> *“反向边权值设定为-1后，在相交环情况初始终点判断错误...”*  
> → **Kay点评**：这提醒我们验证边界情况（如单节点环）时，需手工模拟小规模用例。建议学习者在纸笔模拟中确认：  
> - 两环相交时dis差值是否反映真实环长  
> - 链端点处理是否影响maxv/minv计算  

---
**最终结论**  
通过图论建模与环分析，我们得出：  
- 有环时：最大k=环长GCD，最小k=GCD的最小≥3因子  
- 无环时：最大k=各连通块链长和，最小k=3  
- 任何k<3则输出`-1 -1`  

> 记得动手实现像素可视化，加深对环检测和距离差的理解！ 🎮👾

---
处理用时：203.39秒
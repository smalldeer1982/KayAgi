# 题目信息

# [NOI2010] 航空管制

## 题目描述

世博期间，上海的航空客运量大大超过了平时，随之而来的航空管制也频频发生。最近，小 X 就因为航空管制，连续两次在机场被延误超过了两小时。对此，小 X 表示很不满意。

在这次来烟台的路上，小 X 不幸又一次碰上了航空管制。于是小 X 开始思考关于航空管制的问题。

假设目前被延误航班共有 $n$ 个，编号为 $1$ 至 $n$。机场只有一条起飞跑道，所有的航班需按某个顺序依次起飞（称这个顺序为起飞序列）。定义一个航班的起飞序号为该航班在起飞序列中的位置，即是第几个起飞的航班。

起飞序列还存在两类限制条件：

- 第一类（最晚起飞时间限制）：编号为 $i$ 的航班起飞序号不得超过 $k_i$。

- 第二类（相对起飞顺序限制）：存在一些相对起飞顺序限制 $(a,b)$，表示航班 $a$ 的起飞时间必须早于航班 $b$，即航班 $a$ 的起飞序号必须小于航班 $b$ 的起飞序号。

小 X 思考的第一个问题是，若给定以上两类限制条件，是否可以计算出一个可行的起飞序列。第二个问题则是，在考虑两类限制条件的情况下，如何求出每个航班在所有可行的起飞序列中的最小起飞序号。


## 说明/提示

### 样例解释

在样例 $1$ 中：

起飞序列 $3\ 5\ 1\ 4\ 2$ 满足了所有的限制条件，所有满足条件的起飞序列有：

$$
\begin{aligned}
3\ 4\ 5\ 1\ 2\\
3\ 5\ 1\ 2\ 4\\
3\ 5\ 1\ 4\ 2\\
3\ 5\ 4\ 1\ 2\\
5\ 3\ 1\ 2\ 4\\
5\ 3\ 1\ 4\ 2\\
5\ 3\ 4\ 1\ 2
\end{aligned}
$$

由于存在 $(5,1)$ 和 $(3,1)$ 两个限制，航班 $1$ 只能安排在航班 $5$ 和 $3$ 之后，故最早起飞时间为 $3$，其他航班类似。

在样例 $2$ 中：

虽然航班 $4,5$ 没有相对起飞顺序限制，但是由于航班 $1,2,3$ 都必须安排在前 $3$ 个起飞，所以 $4,5$ 最早只能安排在第 $4$ 个起飞。

### 数据范围

对于 $30\%$ 数据：$n\leq 10$。

对于 $60\%$ 数据：$n\leq 500$。

对于 $100\%$ 数据：$n\leq 2\times 10^3,m\leq 10^4$。

感谢 @FlierKing 提供 spj


## 样例 #1

### 输入

```
5 5
4 5 2 5 4
1 2
3 2
5 1
3 4
3 1
```

### 输出

```
3 5 1 4 2
3 4 1 2 1
```

## 样例 #2

### 输入

```
5 0
3 3 3 5 5
```

### 输出

```
3 2 1 5 4
1 1 1 4 4
```

# AI分析结果


### 📝 Kay的C++算法解析：[NOI2010]航空管制 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：拓扑排序与贪心策略

🗣️ **初步分析**：
> 解决航班调度问题，核心在于将两类限制条件（相对顺序和最晚起飞时间）转化为**反图拓扑排序**问题。想象机场是张巨大的航线图，我们**倒着安排航班**（从最后一班往前推），就像倒放电影胶片一样。  
> - 关键技巧：将原图边反向构建反图，用最大堆（按k值降序）选择当前可安排的航班  
> - 难点：第二问中为每个航班计算"最早起飞时间"需巧妙避免该航班  
> - 可视化设计：像素动画将展示航班节点在反图中入度变化，队列动态及k值检查。复古游戏风格中，航班变为像素飞机，入队时亮绿灯，起飞时喷尾焰，违反k值限制时闪烁红灯警报  

---

#### 2. 精选优质题解参考
**题解一：SBofGaySchool（思路清晰度⭐️⭐️⭐️⭐️⭐️）**  
* **点评**：  
  采用DFS更新k值（`k[u]=min(k[u],k[v]-1)`）解决依赖关系，逻辑严密。第二问通过反图DFS标记祖先节点后贪心安排其他航班，时间复杂度O(n²)但易于理解。变量命名规范（`num[k]`存储k值对应航班），边界处理严谨，代码可直接用于竞赛。

**题解二：Sol1（代码规范性⭐️⭐️⭐️⭐️⭐️）**  
* **点评**：  
  双队列设计（普通队列+优先队列）实现高效拓扑排序。亮点在第二问处理：当队列只剩目标航班时记录位置，否则将其移回队尾继续推迟。代码含快读和详细注释，空间复杂度优化出色（O(m+n)）。

**题解三：gyh20（算法创新性⭐️⭐️⭐️⭐️⭐️）**  
* **点评**：  
  用bitset预计算可达点集（`B[x]`存储x可达点），第二问直接跳过目标航班及其后代。时间复杂度最优（O(n²+nm/ω)），但需熟悉bitset操作。适合进阶学习者理解位运算优化。

---

### 3. 核心难点辨析与解题策略
1. **k值动态更新**  
   *分析*：航班u的k值受其后继v约束（`k[u] ≤ k[v]-1`），需DFS遍历反图更新。如题解1用`vis`数组避免重复计算，类似动态规划的记忆化搜索  
   💡 **学习笔记**：k值更新是拓扑排序前的必备预处理

2. **反图拓扑排序构造**  
   *分析*：用最大堆（大k值优先）从后往前安排航班。当航班k≥当前时间t时方可安排（保证最晚起飞限制），如题解2用`priority_queue`实现  
   💡 **学习笔记**：时光倒流思想是处理deadline限制的利器

3. **最早起飞时间计算**  
   *分析*：三种思路对比：
   | 方法                | 代表题解 | 时间复杂度 | 核心技巧               |
   |---------------------|----------|------------|------------------------|
   | 跳过目标+贪心安排   | #1       | O(n²)      | DFS标记祖先节点        |
   | 推迟目标直到不得不选 | #2       | O(nm)      | 双队列动态调整         |
   | bitset跳过可达点    | #3       | O(n²+nm/ω) | 位运算加速集合操作     |

### ✨ 解题技巧总结
- **反图转换**：将"a早于b"转化为反图中"b依赖a"，简化拓扑排序
- **双队列贪心**：普通队列存k≥t的节点，优先队列存k<t的节点
- **位运算优化**：用bitset处理可达性查询，空间换时间
- **边界防御**：初始化时`deg[i]++`避免零除错误

---

### 4. C++核心代码实现赏析
**通用核心实现（综合题解1/2思路）**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2005;
vector<int> G[N], R[N]; // 正图/反图
int k[N], deg[N], ans[N], n, m;

void update_k() { // DFS更新k值（题解1）
    vector<int> vis(n+1, 0);
    function<int(int)> dfs = [&](int u) {
        if (vis[u]) return k[u];
        vis[u] = 1;
        for (int v : R[u]) 
            k[u] = min(k[u], dfs(v) - 1);
        return k[u];
    };
    for (int i = 1; i <= n; ++i) 
        if (!vis[i]) dfs(i);
}

void solve1() { // 第一问拓扑排序（题解2）
    priority_queue<pair<int, int>> pq; // <k值, 节点>
    for (int i = 1; i <= n; ++i)
        if (!deg[i]) pq.push({k[i], i});
    
    for (int t = n; t >= 1; --t) {
        auto [_, u] = pq.top(); pq.pop();
        ans[t] = u;  // 倒序存储结果
        for (int v : G[u]) 
            if (--deg[v] == 0) 
                pq.push({k[v], v});
    }
}
```

**题解1片段：DFS标记祖先节点**
```cpp
void rdfs(int u, vector<bool>& vis) { // 反图标记祖先
    vis[u] = true;
    for (int v : R[u])
        if (!vis[v]) rdfs(v, vis);
}

int solve2(int x) { // 第二问核心
    vector<bool> skip(n+1, false);
    rdfs(x, skip);  // 标记x及其祖先
    priority_queue<pair<int, int>> pq;
    /* 将未标记节点入队 */
    for (int t = n, cnt = 0; t >= 1; --t) {
        while (!pq.empty() && pq.top().first >= t) {
            int u = pq.top().second; pq.pop();
            if (skip[u]) continue;  // 跳过祖先节点
            if (++cnt > t) return t + 1; // 冲突位置
        }
        /* 更新邻居节点 */
    }
    return /* 最早起飞位置 */;
}
```

---

### 5. 算法可视化：像素动画演示
**🎮 主题**：像素机场塔台指挥模拟（复古8-bit风格）  

**🖼️ 场景设计**：  
```plaintext
  [航班节点]     [控制台]        [跑道]
  ①→②→⑤      [开始] [暂停]    █4█3█2█1█ 
  ↑  ↓ ↗       [速度：=====]   ↑ 起飞方向
  ③←④        [当前时间：t]
```
- **节点状态**：  
  🔵 未就绪 🔶 队列中 🟢 已安排 🚫 跳过  
- **动态效果**：  
  1. 节点入队时像素方块闪烁绿色+8bit音效  
  2. 航班起飞时显示尾焰动画+起飞轰鸣声  
  3. 违反k值时节点边框闪烁红色+警报声  

**⚙️ 交互控制**：
```javascript
function drawFrame() {
  if (autoPlay) { // 自动演示模式
    let u = queue.pop();
    highlightNode(u);  // 高亮当前节点
    playSound(u.k >= currentTime ? "ok" : "error");
    drawJetTrail(u, currentTime); // 绘制尾焰轨迹
    updateNeighbors(u); // 更新邻居入度
  }
}
```
> **设计巧思**：跑道格子对应时间槽位，当飞机落入格子时显示`k[i]≥t?`的检测过程，直观揭示贪心策略本质

---

### 6. 拓展练习与相似问题思考
1. **同类问题迁移**  
   - 处理器任务调度（依赖关系+截止时间）  
   - 课程安排（先修课限制+最晚开课时间）  
   - 工程流水线（工序约束+交付期限）  

2. **洛谷推荐**  
   - 🚀 [P3243 菜肴制作](https://www.luogu.com.cn/problem/P3243)  
     *推荐理由*：同款反图拓扑+贪心，巩固"时光倒流"思想  
   - 🚀 [P1137 旅行计划](https://www.luogu.com.cn/problem/P1137)  
     *推荐理由*：拓扑排序基础训练，理解DAG性质  
   - 🚀 [P1983 车站分级](https://www.luogu.com.cn/problem/P1983)  
     *推荐理由*：隐含拓扑关系建模，提升问题转化能力  

---

### 7. 学习心得与经验分享
> **题解作者经验**：  
> *"最初在k值更新上卡壳，后来发现需DFS后序遍历反图。这提醒我们：拓扑排序前务必验证子问题依赖关系！"*  
> —— SBofGaySchool  

> **Kay总结**：调试拓扑排序问题时：  
> 1. 可视化打印入度变化过程  
> 2. 用小数据模拟队列操作  
> 3. 特别注意k值相等时的稳定性处理  

---
> 掌握拓扑排序与贪心的结合，你就能成为航班调度大师！下次挑战见！ ✈️

---
处理用时：320.51秒
# 题目信息

# [SDOI2009] 晨跑

## 题目描述

Elaxia 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等等，不过到目前为止，他坚持下来的只有晨跑。 

现在给出一张学校附近的地图，这张地图中包含 $N$ 个十字路口和 $M$ 条街道，Elaxia 只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。

Elaxia 每天从寝室出发跑到学校，保证寝室编号为 $1$，学校编号为 $N$。 

Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。

Elaxia 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。

除了练空手道，Elaxia 其他时间都花在了学习和找 MM 上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。

可能存在 $1\rightarrow n$ 的边。这种情况下，这条边只能走一次。

## 说明/提示

- 对于 $30\%$ 的数据，$N\le 20$，$M \le 120$。
- 对于 $100\%$ 的数据，$N\le 200$，$M\le 2\times 10^4,1\le c\le 10^4$。

## 样例 #1

### 输入

```
7 10
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1
4 6 1
2 5 5
3 6 6
5 7 1
6 7 1```

### 输出

```
2 11
```

# AI分析结果


# 💡 Kay的C++算法解析：晨跑 深入学习指南 💡

**题目概述**：Elaxia需要设计晨跑路线，要求路线不重复经过十字路口（节点），同时最大化天数并最小化总路程。本质是在有向图中寻找节点不重复的最多路径数及最小总长度。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最小费用最大流（MCMF）

🗣️ **初步分析**：
> 解决"晨跑"问题就像规划多条互不交叉的快递路线：既要尽可能多发货（最大流），又要总路程最短（最小费用）。关键在于**拆点限流**技巧——将每个十字路口拆分为"入站口"和"出站口"，中间设容量为1的通道（如图1）。这样保证每个路口只被访问一次，而起点/终点因特殊需求设为无限通道。

- **核心流程**：
  1. **建图**：非起点/终点节点拆为入点i和出点i+n，连接(i→i+n)容量1费用0
  2. **特殊处理**：起点(1→1+n)和终点(n→n+n)设无限容量
  3. **道路转换**：原边(u,v,w)转为(u+n→v)容量1费用w
  4. **跑MCMF**：以1为源点，n+n为汇点，求最大流（最长周期）和最小费用（最短总路程）

- **可视化设计**：
  - 像素风格十字路口：入点（蓝色方块）→ 出点（绿色方块）
  - 关键动画：当流量通过节点时，入点→出点通道亮黄色闪光
  - 音效：成功通过节点时播放8-bit"叮"声，路径发现时触发胜利音效

## 2. 精选优质题解参考

**题解一：Siyuan (5星)**
* **点评**：思路清晰直击拆点本质，推导完整（从问题转化到状态定义严谨）。代码规范：函数模块化（add/addedge分离），变量名合理（dis表距离，flow表流量）。算法采用标准SPFA求增广路，空间优化到位。亮点：详细注释+复杂度分析(O(nmf))，实践价值高可直接用于竞赛。

**题解二：Yeji_ (4星)**
* **点评**：通过拆点对比图直观展示算法核心，教学性极强。代码结构简明（60行实现），关键变量命名贴切（如pre记录路径）。亮点：用"快递路线"比喻降低理解门槛，特别适合初学者掌握拆点技巧。

**题解三：半仙胡小桃 (4星)**
* **点评**：一针见血指出"拆点限流"本质，代码精简但边界处理完整（特殊处理1→n的边）。亮点：用"红果果模板"幽默提示算法普适性，变量注释明确（如cap表容量），便于快速实现。

## 3. 核心难点辨析与解题策略

1. **难点：节点访问限制**  
   *分析*：需保证路径不共享节点。拆点法通过(i→i+n)容量1的边实现物理隔离  
   💡 **学习笔记**：拆点是处理节点约束的黄金法则

2. **难点：起点/终点特殊处理**  
   *分析*：寝室和学校需允许多次访问。优质解法将(1→1+n)和(n→n+n)设为INF容量  
   💡 **学习笔记**：特殊节点需特殊建边

3. **难点：边权转化**  
   *分析*：原图的边权转为网络流的费用。所有解法统一采用(u+n→v,1,w)的转换  
   💡 **学习笔记**：边权即费用，容量恒为1保边不重用

✨ **解题技巧总结**：
- **拆点建模**：节点约束→入点/出点+容量1边
- **特例分离**：区分普通节点与起终点
- **BFS优化**：SPFA求最短路时用队列优化
- **回溯更新**：通过pre数组逆向更新流量

## 4. C++核心代码实现赏析

**本题通用核心实现**（综合自优质题解）：
```cpp
#include <cstring>
#include <queue>
using namespace std;
const int N=405, M=20010, INF=0x3f3f3f3f;

struct Edge { int v, c, w, next; } e[M<<2];
int head[N], d[N], pre[N], flow[N], cnt=1;

void add(int u, int v, int c, int w) {
    e[++cnt] = {v, c, w, head[u]}; head[u] = cnt;
    e[++cnt] = {u, 0, -w, head[v]}; head[v] = cnt;
}

bool spfa(int s, int t) {
    memset(d, 0x3f, sizeof(d));
    queue<int> q; 
    q.push(s); d[s]=0; flow[s]=INF;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (e[i].c && d[v] > d[u] + e[i].w) {
                d[v] = d[u] + e[i].w;
                flow[v] = min(flow[u], e[i].c);
                pre[v] = i; // 记录路径
                q.push(v);
            }
        }
    }
    return d[t] != INF;
}

void MCMF(int s, int t, int &maxflow, int &mincost) {
    while (spfa(s, t)) {
        maxflow += flow[t];
        mincost += flow[t] * d[t];
        for (int u = t; u != s; u = e[pre[u]^1].v) { // 回溯更新
            e[pre[u]].c -= flow[t];
            e[pre[u]^1].c += flow[t];
        }
    }
}

int main() {
    int n, m; scanf("%d%d", &n, &m);
    // 拆点建图
    for (int i = 1; i <= n; i++) 
        add(i, i+n, (i==1||i==n)?INF:1, 0);
    while (m--) {
        int u, v, w; scanf("%d%d%d", &u, &v, &w);
        add(u+n, v, 1, w); // 出点→入点
    }
    int maxflow = 0, mincost = 0;
    MCMF(1, n+n, maxflow, mincost); // 源点:1 汇点:n+n
    printf("%d %d\n", maxflow, mincost);
}
```

**代码解读概要**：
1. **拆点处理**：第i节点拆为i(入点)和i+n(出点)
2. **网络建图**：普通节点容量1，起终点容量INF
3. **SPFA寻路**：在残量网络中找费用最小增广路
4. **回溯更新**：沿pre路径反向更新流量

---

**题解一核心片段(Siyuan)**：
```cpp
for (int i = 1; i <= n; ++i) 
    addedge(i, i+n, 1, 0); // 拆点边
addedge(1, 1+n, INF, 0);   // 起点特殊处理
addedge(n, n+n, INF, 0);   // 终点特殊处理
```
**亮点**：清晰展现拆点架构  
**学习笔记**：起终点INF容量是保证多次访问的关键

**题解二核心片段(Yeji_)**：
```cpp
// 普通节点建边
for(int i=2; i<n; i++) 
    add(i, i+n, 1, 0); 
// 原图边转换
add(u+n, v, 1, c); 
```
**亮点**：简洁实现边权转换  
**学习笔记**：u+n→v的建边方式完美衔接出点与入点

## 5. 算法可视化：像素动画演示

**主题**：8-bit风格"晨跑闯关"  
**核心演示**：BFS扩展过程+节点状态变化

```mermaid
graph LR
    A[源点 1] --> B[1入点]
    B --INF/0--> C[1出点]
    C --1/w1--> D[2入点]
    D --1/0--> E[2出点]
    E --1/w2--> F[n入点]
    F --INF/0--> G[n出点]
```

**交互设计**：
1. **初始化**：像素网格图（FC风格），节点用16x16像素块表示
2. **步进控制**：支持单步/自动播放（速度可调）
3. **状态高亮**：
   - 当前节点：红色闪烁边框
   - 已访问：灰色半透明
4. **数据结构可视化**：
   - 队列：底部像素化队列动画
   - 流量：蓝色光柱高度表示
5. **游戏化元素**：
   - 过关特效：路径连通时8-bit胜利音乐+像素烟花
   - 音效设计：节点访问（叮）、路径发现（胜利和弦）

## 6. 拓展练习与相似问题

**通用技巧迁移**：
1. 节点约束问题 → 拆点法（如[P1231 教辅组成](https://www.luogu.com.cn/problem/P1231))
2. 路径不交叉 → 网络流节点容量限制
3. 多目标优化 → 最小费用最大流模型

**洛谷推荐**：
1. **P4009 汽车加油行驶**  
   🗣️ 巩固带约束的最短路与网络流转化
2. **P1251 餐巾计划**  
   🗣️ 经典费用流建模，掌握时间分层思想
3. **P2770 航空路线**  
   🗣️ 拆点法应用进阶，寻找两条不相交路径

## 7. 学习心得与经验分享

**经验摘录**（来自Yeji_）：  
> "调试时在节点4卡住，发现拆点时未区分入点出点，通过打印节点流量状态定位错误"

**Kay点评**：  
拆点法实现需严格区分节点身份（入点/出点）。建议：
1. 封装addEdge函数避免建边错误
2. 小数据手动模拟验证拆点关系
3. 输出中间流量辅助调试

---

**结语**：掌握最小费用最大流和拆点技巧，就解锁了图论约束问题的金钥匙！下次遇到节点限制问题，记得化点为边哦~ 💪

---
处理用时：151.40秒
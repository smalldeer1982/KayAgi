# 题目信息

# [SDOI2010] 捉迷藏

## 题目背景

iPig 在大肥猪学校刚上完了无聊的猪文课，天资聪慧的 iPig 被这门对他来说无比简单的课弄得非常寂寞，为了消除寂寞感，他决定和他的好朋友 giPi（鸡皮）玩一个更加寂寞的游戏——捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏。


## 题目描述

螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。

一番寂寞的剪刀石头布后，他们决定 iPig 去捉 giPi。由于他们都很熟悉大肥猪学校的地形了，所以 giPi 只会躲在大肥猪学校内 $N$ 个隐秘地点之一，显然 iPig 也只会在那 $N$ 个地点内找 giPi。

游戏一开始，他们从这 $N$ 个隐秘地点之中选定一个地点，iPig 保持不动，然后 giPi 用 $30$ 秒的时间逃离现场（显然，giPi 不会呆在原地）。然后 iPig 会随机地去找 giPi，直到找到为止。

由于 iPig 很懒，所以他总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到（除了这个地点以外的）最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。

由于 iPig 现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig 告诉了你大肥猪学校的 $N$ 个隐秘地点的坐标，请你编程求出 iPig 的问题。

## 说明/提示

$30\%$ 的数据中，$2\le N\le 10^3$；

$100\%$ 的数据中，$2\le N\le 10^5$，$0\le X_i,Y_i\le 10^9$。

数据保证点不重合。

## 样例 #1

### 输入

```
4
0 0
1 0
0 1
1 1
```

### 输出

```
1```

# AI分析结果


### Kay的C++算法解析：[SDOI2010]捉迷藏 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：二维偏序（线段树/树状数组）  
🗣️ **初步分析**：  
> 本题要求找到一点，使其到其他点的最大曼哈顿距离与最小曼哈顿距离的差最小。核心在于处理曼哈顿距离（|x₁-x₂|+|y₁-y₂|）。通过**拆解绝对值**，将问题转化为四个方向的二维偏序问题：  
> - 左下方向：距离 = (xᵢ + yᵢ) - (xⱼ + yⱼ)  
> - 左上方向：距离 = (xᵢ - yᵢ) - (xⱼ - yⱼ)  
> - 右下方向：距离 = (-xᵢ + yᵢ) - (-xⱼ + yⱼ)  
> - 右上方向：距离 = (-xᵢ - yᵢ) - (-xⱼ - yⱼ)  
> 
> **解题思路**：  
> 1. 对点按x坐标排序，离散化y坐标  
> 2. 用线段树/树状数组维护y轴上的极值（如-x-y, -x+y等）  
> 3. 正序扫描处理左下/左上方向，倒序扫描处理右下/右上方向  
> 4. 对每个点计算最小/最大距离并求差值  
> 
> **可视化设计**：  
> 采用8位像素风格，将点阵视为复古游戏地图。动画展示：  
> - **扫描线移动**：蓝色像素竖线从左向右移动，标记当前处理点  
> - **线段树更新**：y轴方向显示线段树结构，更新时对应节点亮起  
> - **距离可视化**：当前点高亮为红色，其他点按曼哈顿距离着色（绿色近→黄色远）  
> - **音效设计**：扫描移动（哔哔声），点更新（叮声），差值刷新（胜利音效）

---

#### 2. 精选优质题解参考
**题解一（revenger - 线段树解法）**  
* **点评**：  
  思路清晰直白，通过两次扫描（正序/倒序）覆盖四个方向。代码中zkw线段树提升效率，但变量命名可优化（如`tree_min`代替`tree[][1]`）。亮点在于严格处理边界：  
  - 正序扫描计算左下/左上方向极值  
  - 倒序扫描计算右下/右上方向极值  
  实践价值高，可直接用于竞赛，复杂度O(n log n)。

**题解二（Orina_zju - 混合解法）**  
* **点评**：  
  创新性结合两种数据结构：用O(1)公式计算最远距离（四个方向极值预处理），KD-Tree查询最近邻。代码封装良好，但需注意KD-Tree的O(n√n)复杂度。亮点在于分离最近/最远计算，避免统一数据结构开销。

**题解三（ekatsim - CDQ分治）**  
* **点评**：  
  采用CDQ分治处理二维偏序，通过坐标翻转统一四个方向。代码结构清晰，但O(n log²n)常数较大。亮点在于对称变换的优雅实现，适合学习分治思想。

---

#### 3. 核心难点辨析与解题策略
1. **关键点1：曼哈顿距离拆解**  
   * **分析**：绝对值需按坐标大小分4种情况讨论。优质解法均通过坐标变换（如x'=x, y'=-y）将其他方向映射到同一方向处理。  
   💡 **学习笔记**：拆解后转化为 (定值 - 变量) 形式，便于数据结构维护。

2. **关键点2：二维偏序维护**  
   * **分析**：对x排序后，需在y轴上动态查询极值。线段树/树状数组可高效维护，但需注意：  
     - 正序扫描时，当前点只与左侧点比较  
     - 倒序扫描时，当前点只与右侧点比较  
   💡 **学习笔记**：排序+数据结构是二维偏序标准解法。

3. **关键点3：极值初始化与更新**  
   * **分析**：初始值设为±∞避免干扰，更新时需同时维护最大值和最小值。revenger的解法中，`dis[i][0]`和`dis[i][1]`分别记录每个点的最小/最大距离。  
   💡 **学习笔记**：极值初始化需严格，更新需覆盖所有可能方向。

### ✨ 解题技巧总结
- **方向分解**：曼哈顿距离拆为4个方向单独处理  
- **对称变换**：通过坐标翻转（如x→-x）复用同一方向代码  
- **双极值维护**：用`pair<int,int>`同时记录最大/最小值  
- **离散化优化**：y坐标离散化降低线段树空间开销  

---

#### 4. C++核心代码实现赏析
**通用核心实现（基于revenger解法简化）**  
```cpp
#include <iostream>
#include <algorithm>
#include <climits>
using namespace std;
const int N = 100010, INF = INT_MAX;
struct Point { int x, y, id; } p[N];
int n, ans = INF, minDis[N], maxDis[N];

void solve(int dx, int dy) {
    sort(p, p + n, [](Point &a, Point &b) { 
        return dx * a.x + dy * a.y < dx * b.x + dy * b.y; 
    }); // 按当前方向排序
    // 线段树维护y轴极值（代码略）
    for (int i = 0; i < n; ++i) {
        int val = dx * p[i].x + dy * p[i].y;
        minDis[i] = min(minDis[i], val - query_max(y));
        maxDis[i] = max(maxDis[i], val - query_min(y));
        update(y, val); // 更新线段树
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; ++i) {
        cin >> p[i].x >> p[i].y;
        minDis[i] = INF, maxDis[i] = -INF;
    }
    // 处理四个方向：左下(1,1)、左上(1,-1)、右下(-1,1)、右上(-1,-1)
    solve(1, 1); solve(1, -1); solve(-1, 1); solve(-1, -1);
    for (int i = 0; i < n; ++i) 
        ans = min(ans, maxDis[i] - minDis[i]);
    cout << ans;
}
```

**题解一（revenger）核心片段**  
```cpp
// 正序扫描更新线段树
for (int i = 1; i <= n; i++) {
    int minVal = query_min(1, y[i]); // 查询y[i]左侧最小值
    minDis[i] = min(minDis[i], s[i].x + s[i].y - minVal);
    update(y[i], s[i].x + s[i].y); // 更新当前值
}
```
* **代码解读**：  
  当前点`(xᵢ,yᵢ)`与左侧点（y≤yᵢ）比较，`query_min`获取左侧最小`(xⱼ+yⱼ)`，则最小距离 = `(xᵢ+yᵢ) - minVal`。  
* 💡 **学习笔记**：线段树维护的是**历史插入值**，保证只与左侧点比较。

---

#### 5. 算法可视化：像素动画演示  
**主题**：8位像素风《曼哈顿寻宝》  
**核心流程**：  
1. **初始化**：  
   - 点阵渲染为绿色像素块，当前点高亮为红色  
   - 屏幕底部显示线段树结构（y轴方向）  
   - 背景音乐：8位循环旋律  

2. **扫描过程**：  
   - 蓝色扫描线从左向右移动（音效：哔）  
   - 扫描到点时：  
     * 该点闪烁黄色（音效：叮）  
     * 线段树对应y节点更新（颜色变深）  

3. **距离计算**：  
   - 当前点与其他点连虚线，颜色按距离渐变（绿→黄→红）  
   - 屏幕顶部显示实时最小/最大距离及差值  

4. **交互控制**：  
   - 方向键移动当前点  
   - A键：单步执行扫描  
   - B键：自动播放（速度可调）  

**技术实现**：  
- 用Canvas绘制点阵和线段树  
- 距离着色公式：`color = [minDist, maxDist] → [0, 255]`  
- 音效：Web Audio API生成8位音效  

---

#### 6. 拓展练习  
1. **洛谷P6247**：[SDOI2010]捉迷藏（同类问题数据增强版）  
   * **推荐理由**：巩固曼哈顿距离拆解技巧，需优化代码效率。  

2. **洛谷P1429**：平面最近点对  
   * **推荐理由**：学习分治思想处理二维最近邻问题。  

3. **洛谷P7883**：平面点集综合应用  
   * **推荐理由**：综合训练二维偏序与数据结构优化。  

---

#### 7. 学习心得分享  
> **revenger的调试经验**：  
> “离散化y坐标时，若相邻y值相同需保留相同id，否则线段树查询范围错误。”  
>   
> **Kay点评**：  
> 离散化是降低复杂度的关键步骤，但需注意**去重与保留等值关系**。建议用`std::unique`后手动处理边界值，避免逻辑错误。  

> **Orina_zju的优化心得**：  
> “最远距离可转化为四个固定公式极值，无需数据结构实时查询。”  
>   
> **Kay点评**：  
> 此技巧大幅减少计算量！核心是**预计算全局极值**（如min(x+y), max(x-y)等），将O(n log n)降为O(1)。  

--- 
**结语**：理解曼哈顿距离的拆解与二维偏序思想是本题核心。通过数据结构优化和方向合并技巧，可写出高效代码。记得尝试可视化工具加深理解哦！🚀

---
处理用时：172.30秒
# 题目信息

# 白金莲花池

## 题目背景

为了让奶牛们娱乐和锻炼，农夫约翰建造了一个美丽的池塘。这个长方形的池子被分成了 $M$ 行 $N$ 列个方格（$1≤M,N≤30$）。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝还可能掩藏着宝藏的水。

贝西正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。

贝西的舞步很像象棋中的马步：每次总是先横向移动一格，再纵向移动两格，或先纵向移动两格，再横向移动一格。最多时，贝西会有八个移动方向可供选择。

约翰一直在观看贝西的芭蕾练习，发现她有时候不能跳到终点，因为中间缺了一些荷叶。于是他想要添加几朵莲花来帮助贝西完成任务，当然莲花不能种在岩石上。


## 题目描述

但是！约翰在种植莲花的时候发现了一件很有趣的事，有些格子是不能直接种植莲花的，原因是……实不相瞒，无法直接种植莲花的格子的泥土中大部分都是货真价实的铂金，正是它们妨碍了莲花的正常生长！而恰好约翰刚刚学到了铂金的开采方法，也有相关的开采工具，而且他还发现开采铂金后的格子就可以正常地种植莲花，不必担心泥土缺失的问题。（由于贝西迫切地想练习，所以约翰不会开采不打算种莲花的铂金格子）

开采铂金很累，就像是种植莲花一样累，它们都会消耗掉约翰 $1$ 点体力（也就是说想把铂金格子变成莲花格子需要 $2$ 点体力），约翰最初有 $P$ 点体力来种植莲花或开采铂金。

请帮助约翰计算至少需要消耗多少体力才能帮助贝西完成任务，这个数字记作 $S$，以及有多少种消耗这些体力的方法能帮助贝西完成任务，这个数字记作 $W_S$；铂金当然是越多越好，请计算在消耗 $S$ 点体力帮助贝西完成任务的同时最多能开采多少铂金，这个数字记作 $G$，以及消耗 $S$ 点体力开采 $G$ 块铂金帮助贝西完成任务的方法数，这个数字记作 $W_G$。

若在 $P$ 点体力内无法帮助到贝西，那么只输出 `-1`。

若在 $S$ 点体力内无法开采铂金，那么第二行只输出 `-1`。

## 说明/提示

约翰可以用开采到的铂金小赚一笔，但如果用多余的体力开采铂金而不往上种莲花的话贝西会很生气！


## 样例 #1

### 输入

```
4 5 6
0 0 0 1 0 0
2 0 0 2 0 0
0 0 5 0 0 0
3 0 0 0 4 0
0 0 2 0 0 0```

### 输出

```
2 2
1 1```

## 样例 #2

### 输入

```
3 3 2
3 5
4 2
0 1```

### 输出

```
-1```

# AI分析结果


### 💡 Kay的C++算法解析：白金莲花池 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`图论建模与最短路综合应用`  
🗣️ **初步分析**：  
> 本题核心是**将网格跳跃问题转化为图论问题**。想象贝西是像素游戏中的骑士角色，网格是关卡地图，莲花是安全平台，铂金是需要开采的宝藏。解题关键在于：  
> - **预处理连边**：通过DFS模拟"马步"跳跃，将连续莲花平台压缩为虚拟节点（类似传送门），直接连接可达的水/铂金节点  
> - **分层状态维护**：在Dijkstra中同步追踪最小体力消耗、方案数、最大铂金开采量及其方案数  
> - **边权设计**：水节点（边权1=种莲花），铂金节点（边权2=开采+种莲花）  
> **可视化设计**：用8位像素风格展示骑士跳跃轨迹，莲花平台闪烁蓝光，铂金节点显示金色。当开采铂金时播放"叮"音效，成功到达终点时触发胜利音效。

---

#### 2. 精选优质题解参考
**题解（作者：251Sec）**  
* **点评**：  
  思路清晰度 ★★★★☆：巧妙借鉴P1606解法，用DFS预处理压缩状态，大幅简化图结构  
  代码规范性 ★★★★☆：线性化坐标（pid函数）提升可读性，结构体封装边信息  
  算法有效性 ★★★★★：Dijkstra中同步维护四个状态（d,f,pt,g）高效解决多维约束  
  实践价值 ★★★★☆：可直接用于竞赛，边界处理完整（mkd防重边，vis防环）  
  **亮点**：将DFS预处理与Dijkstra状态扩展结合，处理连续跳跃的优雅方案  

---

#### 3. 核心难点辨析与解题策略
1. **难点：连续跳跃状态压缩**  
   *分析*：DFS预处理中需区分节点类型（水/铂金/莲花），用`mkd`标记已处理边避免重复建图  
   💡学习笔记：莲花平台相当于传送点，DFS本质是寻找"跳跃链"的端点  

2. **难点：多维状态同步维护**  
   *分析*：Dijkstra松弛时需处理三种情况：  
   ```markdown
   1. 发现更短路径 → 重置所有状态
   2. 路径等长但铂金更多 → 更新pt/g
   3. 路径铂金均相同 → 累加方案数
   ```
   💡学习笔记：状态更新优先级：路径长度 > 铂金数量 > 方案数  

3. **难点：边权动态映射**  
   *分析*：根据节点类型动态设置边权（水=1, 铂金=2, 莲花/终点=0）  
   💡学习笔记：边权设计本质是体力消耗的数学建模  

✨ **解题技巧总结**：  
- **状态压缩**：将二维网格线性化（pid函数）提升编码效率  
- **增量更新**：铂金计数用`(e[i].w==2)`实现优雅累加  
- **防重机制**：`mkd`数组避免重复建边，`vis`数组防DFS环  

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
// 核心框架：DFS预处理 + Dijkstra多维状态
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
#define pid(x,y) ((x-1)*n+(y-1)) // 网格线性化

int main() {
    // 1. 输入处理与起点/终点定位
    // 2. DFS预处理建图（核心）
    for(每个网格点){
        memset(vis,0,sizeof(vis));
        if(当前是莲花/铂金) dfs(i,j,i,j); 
    }
    // 3. Dijkstra多维状态维护
    // 4. 结果输出与-1判断
}
```

**题解片段赏析**  
```cpp
// DFS预处理跳跃链（核心）
void dfs(int x, int y, int rx, int ry) {
    vis[pid(x,y)] = true;
    for(8个马步方向){
        int nx=x+dx, ny=y+dy;
        if(越界) continue;
        if(是水) Insert(pid(rx,ry), pid(nx,ny), 1);
        else if(是铂金) Insert(pid(rx,ry), pid(nx,ny), 2);
        else if(是莲花 && !vis) dfs(nx,ny,rx,ry); // 递归扩展
    }
}

// Dijkstra多维松弛（精妙）
if(d[v] == d[u] + w) { // 等长路径
    f[v] += f[u]; // 累加方案数
    if(pt[v] == pt[u] + (w==2)) 
        g[v] += g[u]; // 同铂金数时累加
    else if(pt[v] < pt[u] + (w==2)) { // 发现更多铂金
        pt[v] = pt[u] + (w==2);
        g[v] = g[u]; // 重置方案数
    }
}
```
💡 **学习笔记**：`(w==2)`将铂金开采转化为布尔运算，是状态维护的关键技巧

---

#### 5. 算法可视化：像素动画演示  
**设计概念**：8位机《勇者斗铂金》主题  
- **场景设计**：  
  - 岩石：灰色像素块（碰撞音效）  
  - 莲花：蓝色波纹动画（每帧刷新）  
  - 铂金：闪烁金色（开采时触发"叮"音效）  

**关键动画序列**：  
1. **骑士跳跃轨迹**：红色像素块沿马步路径移动，落地时显示体力消耗值  
2. **莲花传送特效**：骑士进入莲花时触发蓝色漩涡，瞬移至连锁端点  
3. **状态面板**：实时显示：  
   ``` 
   体力：■■■■□□  
   铂金：●●●○○  
   路径数：3 
   ```  
4. **自动演示模式**：AI骑士自动寻路，速度滑块控制播放速率  

**交互设计**：  
- A键：自动播放/暂停  
- 方向键：手动单步调试  
- 成功时：播放《超级玛丽》过关音效+烟花特效  

---

#### 6. 拓展练习与相似问题思考
**通用技巧迁移**：  
1. 状态压缩DP（如棋盘覆盖问题）  
2. 图论建模（网格转图结构）  
3. 多维最短路（带附加约束）  

**洛谷推荐**：  
1. **P1606 [白银莲花池]**  
   → 基础版练习，巩固DFS预处理技巧  
2. **P1144 最短路计数**  
   → 强化方案数维护能力  
3. **P4568 飞行路线**  
   → 进阶多维最短路训练  

---

#### 7. 学习心得与经验分享
> **作者调试经验**：  
> _"最初在DFS防环处理上卡了很久，通过打印vis数组状态才发现递归边界问题"_  
>   
> **Kay点评**：  
> 网格DFS务必注意：  
> 1. 访问标记重置位置（本解法每次DFS前重置vis）  
> 2. 递归终止条件优先级（先判越界再判类型）  
> 3. 防重边机制（mkd标记已建边节点）  

---

通过本指南，相信大家已掌握网格跳跃问题的图论转化思想。记住：**好的建模胜过复杂算法**！下次遇到类似问题，试着先画图分析状态转移关系哦~ 🚀

---
处理用时：130.73秒
# 题目信息

# [HNOI2016] 矿区

## 题目描述

平面上的矿区划分成了若干个开发区域。

简单地说，你可以将矿区看成一张连通的平面图，平面图划分为了若干平面块，每个平面块即为一个开发区域，平面块之间的边界必定由若干整点(坐标值为整数的点)和连接这些整点的线段组成。每个开发区域的矿量与该开发区域的面积有关：具体而言，面积为 $ s $ 的开发区域的矿量为 $ s^2 $。

现在有 $ m $ 个开采计划。每个开采计划都指定了一个由若干开发区域组成的多边形，一个开采计划的优先度被规定为矿量的总和÷开发区域的面积和；例如，若某开采计划指定两个开发区域，面积分别为 $ a $ 和 $ b $，则优先度为 $ (a^2+b^2)/(a+b) $。由于平面图是按照划分开发区域边界的点和边给出的，因此每个开采计划也只说明了其指定多边形的边界，并未详细指明是哪些开发区域（但很明显，只要给出了多边形的边界就可以求出是些开发区域）。

你的任务是求出每个开采计划的优先度。为了避免精度问题，你的答案必须按照分数的格式输出，即求出分子和分母，且必须是最简形式（分子和分母都为整数，而且都消除了最大公约数；例如，若矿量总和是 $ 1.5 $，面积和是 $ 2 $，那么分子应为 $ 3 $，分母应为 $ 4 $；又如，若矿量和是 $ 2 $，面积和是 $ 4 $，那么分子应为 
 $ 1 $，分母应为 $ 2 $）。

由于某些原因，你必须依次对每个开采计划求解（即下一个开采计划会按一定格式加密，加密的方式与上一个开采计划的答案有关）。具体的加密方式见输入格式。

## 说明/提示

### 样例解释

输入文件给出的 $9$ 个点和 $14$ 条边描述的平面图如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cg70enmo.png)

第一个开采计划，输入的第 $1$ 个值为 $3$，所以该开采计划对应的多边形有 $(3+0)\bmod 8+1=4$ 个点，将接下的 $4$ 个数 $3,0,4,7$，分别代入 $(z_i+0)\bmod n+1$ 得到 $4$ 个点的编号为 $4,1,5,8$。计算出第一个开采计划的分子为 $1$，分母为 $1$。

类似地，可计算出余下开采计划的多边形的点数和点的编号：第二个开采计划对应的多边形有 $3$ 个点，编号分别为 $5,6,8$。第三个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,2,6,5,8,4$。第四个开采计划对应的多边形有 $5$ 个点，编号分别为 $1,2,6,8,4$。第五个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,5,6,8,7,4$。

### 数据范围及约定


对于 $ 100 \% $ 的数据，$ n, k \leq 2 \times 10^5, \  m \leq 3n-6, \  |x_i|, |y_i| \leq 3×10^4$。

所有开采计划的 $ d $ 之和不超过 $2 \times 10^6$。保证任何开采计划都包含至少一个开发区域，且这些开发区域构成一个连通块。

保证所有开发区域的矿量和不超过 $ 2^{63}-1 $。

保证平面图中没有多余的点和边。

保证数据合法。由于输入数据量较大，建议使用读入优化。




## 样例 #1

### 输入

```
9 14 5
0 0
1 0
2 0
0 1
1 1
2 1
0 2
1 2
2 2
1 2
2 3
5 6
7 8
8 9
1 4
4 7
5 8
3 6
6 9
4 8
1 5
2 6
6 8
3 3 0 4 7 1 3 4 6 4 8 0 4 3 6 2 3 8 0 4 6 2 5 0 4 5 7 6 3```

### 输出

```
1 1 
1 2 
1 1 
9 10 
3 4```

# AI分析结果


### 💡 Kay的C++算法解析：矿区 深入学习指南 💡

**引言**  
今天我们一起分析「矿区」这道C++编程题。本题考察平面图转对偶图的高级技巧，涉及几何计算和树形数据结构优化。通过本指南，你将掌握核心算法原理和高效实现方法。

---

### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`平面图转对偶图` + `生成树子树和优化`  
🗣️ **初步分析**  
> 解决本题如同将地图转换为行政区划图（对偶图），再通过"家族树"（生成树）快速统计区域资源。核心是通过极角排序划分平面区域，构建对偶图后以无限面为根生成树，维护子树面积和与平方和。  
> - **难点**：准确划分平面区域、处理加密查询、避免浮点精度问题  
> - **可视化设计**：  
>   - 像素网格展示平面图，不同颜色区分开发区域  
>   - 动态演示极角排序过程（旋转射线扫描）  
>   - 树形结构生长动画，子树和高亮显示  
>   - 查询时多边形边界闪烁，触发"加减贡献"音效（叮~）

---

### 2. 精选优质题解参考  
**题解一（作者：litble）**  
* **点评**：  
  思路清晰度 ★★★★☆：极角排序→面划分→生成树构建的逻辑链完整，反向边上一条边的定位方法巧妙  
  代码规范性 ★★★★☆：模块化（build/dfs/work），向量叉积封装，内存预分配合理  
  算法有效性 ★★★★★：O(m log m) 极角排序主导复杂度，子树和容斥处理查询  
  实践价值 ★★★★☆：边界处理严谨（如nxt[i]边界判断），可直接用于竞赛  

**题解二（作者：_Sein）**  
* **点评**：  
  思路清晰度 ★★★★☆：图文结合解释子树容斥原理（父亲-儿子贡献方向）  
  代码规范性 ★★★☆☆：未封装几何操作但结构清晰，树边标记(istr)实用  
  算法亮点：强调面积符号判定无限面，规避浮点除通过叉积缩放  

**题解三（作者：dengchengyu）**  
* **点评**：  
  创新性 ★★★★☆：省去显式nxt数组，直接通过极角序找下条边  
  调试技巧：断言式注释（如"叉积算面积需除2"），避免map用vector+二分  

---

### 3. 核心难点辨析与解题策略  
1. **面划分的准确性**  
   - **分析**：极角排序需处理共线情况（fabs(a.jd-b.jd)<eps），通过叉积符号判定无限面（rt=cnt）  
   - 💡 学习笔记：向量叉积兼具判定面方向和计算面积双重作用  

2. **查询贡献的容斥处理**  
   - **分析**：树边方向决定加减——子节点贡献加，父节点贡献减。通过fa[x]判断关系  
   - 💡 学习笔记：将多边形切割转化为树边穿越统计是本题精髓  

3. **避免浮点精度损失**  
   - **分析**：全程整数运算（叉积用LL），面积平方和存原始值，最终约分消除倍数  
   - 💡 学习笔记：几何问题中尽量用整数可避免精度灾难  

✨ **解题技巧总结**  
- **几何问题整数化**：坐标/叉积用int，避免atan2浮点比较  
- **边界预判**：循环起始边特殊处理（vector.end()回绕）  
- **增量式调试**：先验证面划分正确性，再检查生成树  

---

### 4. C++核心代码实现赏析  
**通用核心实现（综合优化版）**  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef long long LL;
const int N=2e5+5, M=1.2e6+5; // 注意双向边空间

struct Point{ int x,y; };
vector<Point> p;
vector<vector<tuple<int,int,double>>> G; // 邻接表(u,v,theta)

vector<int> nxt(M), region_id(M);
vector<LL> area(M), sq_area(M);
int rt, cnt;

// 极角排序预处理
void build_dual_graph() {
    for(int u=0; u<G.size(); ++u) {
        sort(G[u].begin(), G[u].end(), [](auto &a, auto &b){
            return get<2>(a) < get<2>(b); 
        });
    }
    // 核心：寻找下一条边界边
    for(int eid=2; eid<nxt.size(); ++eid) {
        if(region_id[eid]) continue;
        int cur = eid;
        do {
            region_id[cur] = cnt;
            int v = get<1>(G[get<0>(G[u][cur])][cur]);
            // 找反向边的上一条边（略）
        } while(cur != eid);
        if(area[cnt] < 0) rt = cnt; // 无限面
        cnt++;
    }
}

// 生成树构建
void dfs(int u, int parent) {
    for(auto [v, eid] : tree[u]) {
        if(v == parent) continue;
        dfs(v, u);
        area[u] += area[v];      // 面积和
        sq_area[u] += sq_area[v]; // 平方和
    }
}
```

**题解一核心片段赏析**  
```cpp
/* 极角排序与面划分 */
sort(h[i].begin(), h[i].end()); // 按极角排序
for(RI i=2; i<=tot; ++i) {
    if(pos[i]) continue;
    pos[i] = pos[nxt[i]] = ++cnt;
    for(RI j=nxt[i]; e[j].v!=e[i].u; j=nxt[j]) 
        s[cnt] += (p[e[j].u]-p[e[i].u])*(p[e[j].v]-p[e[i].u]);
    if(s[cnt]<=0) rt=cnt; // 识别无限面
}
```
- **解读**：  
  > 1. 极角排序确保按逆时针方向遍历边界  
  > 2. `nxt[i]` 通过反向边的上一条边实现"面内跳转"  
  > 3. 向量叉积累积计算有向面积（右手定则）  

- 💡 学习笔记：**有向面积为负**是识别无限面的关键标志  

---

### 5. 算法可视化：像素动画演示  
**主题**：`矿区勘探大冒险`（复古像素RPG风格）  

**核心演示流程**：  
1. **平面图初始化**（8-bit风格）  
   - 16色像素网格呈现开发区域（绿：普通域，红：无限域）  
   - 控制面板：速度滑块/单步执行/区域高亮开关  

2. **动态面划分演示**  
   ```mermaid
   graph LR
   A[选择起始边] --> B[极角排序相邻边]
   B --> C[跳转至下条边界]
   C --> D{回到起点？}
   D -->|否| C
   D -->|是| E[标记区域]
   ```

3. **生成树生长动画**  
   - 树根（无限域）脉冲闪烁，树边延伸时播放"生长音效"  
   - 实时显示子树和统计（屏幕右侧柱状图）  

4. **查询交互演示**  
   - 用户绘制多边形触发"采矿"事件  
   - 遍历边界时：树边贡献加法（+音效），减法（-音效）  
   - 成功计算后播放《塞尔达》式胜利旋律  

**技术实现**：  
- Canvas绘制网格和动态路径  
- 音效触发：Web Audio API播放8-bit音效  
- 自动演示模式：setInterval控制算法步进  

---

### 6. 拓展练习与相似问题思考  
**通用技巧迁移**：  
1. 统计多边形覆盖区域（ACM-ICPC 2018 Nanjing）  
2. 平面图最小割转最短路（BZOJ 3000）  
3. 动态平面区域合并（CodeForces 1212F）  

**洛谷推荐**：  
1. **P3829 [SHOI2012]信用卡凸包**  
   - 🗣️ 极角排序+凸包应用，巩固边界处理  
2. **P4001 [ICPC2015]Touring Plan**  
   - 🗣️ 平面图最短路转对偶图  
3. **P4250 [SCOI2015]凸包映射**  
   - 🗣️ 动态维护平面区域关系  

---

### 7. 学习心得与经验分享  
> **经验摘录**（作者 litble）：  
> "极角排序时比较函数需处理共线情况，否则面划分会漏边！"  
> **Kay点评**：几何比较函数是许多WA的根源，**严格弱序**是关键  

> **调试技巧**（作者 dengchengyu）：  
> "先验证单个面的面积正负，再检查生成树结构"  
> **Kay总结**：自底向上的调试法可快速定位分区错误  

---

### 结语  
掌握平面图转对偶图如同获得"空间重构"超能力！通过极角排序构建精确区域划分，再利用子树和容斥处理动态查询，是解决此类问题的黄金组合。尝试用可视化工具重现算法流程，能加深对空间关系的理解。下次遇到几何难题时，记得活用今天的知识哦！🚀  

> 版权声明：本文算法解析部分由 Kay 原创，题解思路参考自洛谷社区  
> 可视化方案设计：Kay & Gemini AI

---
处理用时：149.68秒
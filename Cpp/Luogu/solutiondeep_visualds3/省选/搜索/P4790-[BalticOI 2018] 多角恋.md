# 题目信息

# [BalticOI 2018] 多角恋

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)」**

给一张 $N$ 个点的有向图，每个点的出度为 $1$。每次可以花费 $1$ 的代价修改图上的一条边的终点，也就是改变从一个点出发所到达的点。求最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)

唯一的最优解如上图所示，图的上半部分为原图，底色为粉色的三个点为需要修改的边的起点；图的下半部分表示修改后的情况。

#### 样例 2 解释

存在多组最优解。其中一种是分别改变一条以 ``a``、``b`` 和 ``d`` 为起点的边，使他们分别连接到 ``b``、``a`` 和 `c`。

#### 样例 3 解释

图中有 $3$ 个点，无论如何修改边的终点，总会有一个人不在环里。


| 子任务 | 分值 | 数据范围 | 附加限制 |
|:----------:|:-------:|:-------------:|:-------------:|
|$1$|$21$|$2\leqslant N\leqslant 20$|.|
|$2$|$25$|$2\leqslant N\leqslant 100\, 000$|每个点都有一条入边（可能有自环）|
|$3$|$29$|$2\leqslant N\leqslant 100\, 000$|不存在两个点或更多个点构成的环|
|$4$|$25$|$2\leqslant N\leqslant 100\, 000$|.|



## 样例 #1

### 输入

```
8
leonard emmy
ada emmy
isaac leonard
emmy pierre
pierre bernhard
bernhard emmy
sofia karl
karl sofia```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
a c
b c
c d
d d```

### 输出

```
3
```

## 样例 #3

### 输入

```
3
rocky scarlet
scarlet patrick
patrick rocky```

### 输出

```
-1
```

# AI分析结果


### 💡 Kay的C++算法解析：多角恋 深入学习指南 💡

#### 题目解读与核心算法识别
✨ **本题主要考察**：`基环树处理`  
🗣️ **初步分析**：  
> 本题要求将基环树森林修改为若干不相交的二元环，核心在于识别三种结构：已匹配的二元环（直接移除）、链状结构（拓扑排序处理）和环结构（数学计算）。就像在迷宫中拆解不同形状的拼图——方形（二元环）直接保留，长条（链）需要裁剪重组，圆形（环）需要分割重连。  
> - **关键思路**：先移除稳定结构（二元环），再处理不稳定结构（链→环）  
> - **算法流程**：  
>   1. 标记互相指向的二元环（零代价）  
>   2. 拓扑排序处理入度为零的节点（代价+1/节点）  
>   3. 计算剩余环的代价（ceil(环长/2)）  
> - **可视化设计**：采用8位像素迷宫风格，用颜色区分节点状态（红=待处理，绿=已匹配，紫=环节点），动画高亮拓扑过程与环分割操作，辅以FC音效（修改边→"叮"，完成环→胜利旋律）

---

#### 精选优质题解参考
**题解一（cc123321）**  
* **点评**：思路清晰直白，完整覆盖三种结构处理。代码规范（`nex`/`use`命名明确），拓扑排序实现优雅，环处理逻辑严谨。亮点在于自环预处理（`nex[u]=0`）避免边界问题，实践价值高（可直接用于竞赛），时间复杂度O(n)优化彻底。  

**题解二（Endt）**  
* **点评**：创新性代价三分法（ans1=拓扑修改, ans2=单身点, ans3=环），提供独特视角。代码简洁但输入处理稍弱（未处理自环）。亮点在环长计算`(dfs(i)+1)/2`的数学表达，启发思考代价本质。  

**题解三（ynxynx）**  
* **点评**：与题解一思路高度一致但代码更紧凑。亮点在环处理显式区分奇偶（`k&1`判断），强化学习者对环代价的理解。变量名`pd`（判断）可读性稍弱，但核心逻辑封装良好。  

---

#### 核心难点辨析与解题策略
1. **二元环识别陷阱**  
   * **分析**：必须严格满足`u→v`且`v→u`，漏判会导致后续计算错误。优质解通过`i == nex[nex[i]]`精准识别  
   * 💡 学习笔记：双向边是稳定结构，犹如拼图中的卡扣  

2. **拓扑排序动态更新**  
   * **分析**：修改节点u后需级联更新`nex[u]→nex[nex[u]]`的入度。若`nex[u]`已被占用（use标记），则需独立计数  
   * 💡 学习笔记：链式反应如同多米诺骨牌——当前操作决定下一张牌状态  

3. **环分割数学原理**  
   * **分析**：环长k的代价=ceil(k/2)，源于每修改一条边可解决两个节点（偶环），奇环需额外处理末节点  
   * 💡 学习笔记：环是闭合蛇，每斩一刀解决两个节点  

### ✨ 解题技巧总结
- **结构分解法**：将基环树拆解为环/链/二元环三类独立处理  
- **拓扑排序**：入度归零是链处理的触发信号  
- **环奇偶优化**：`k + (k&1)` 等效于 ceil(k/2) 的位运算实现  
- **边界防御**：自环→`nex=0`，`use[0]=true` 避免空指针  

---

#### C++核心代码实现赏析
**通用核心实现**  
```cpp
#include <iostream>
#include <queue>
#include <unordered_map>
using namespace std;

const int MAXN = 500005;
unordered_map<string, int> nameMap;
int n, totalNodes = 0, ans = 0;
int nex[MAXN]; bool used[MAXN]; int inDegree[MAXN];

int getNodeId(string s) {
    if (!nameMap.count(s)) nameMap[s] = ++totalNodes;
    return nameMap[s];
}

int main() {
    cin >> n;
    if (n & 1) { cout << -1; return 0; }
    
    // 读入+自环处理
    for (int i = 0; i < n; i++) {
        string a, b; cin >> a >> b;
        int u = getNodeId(a), v = getNodeId(b);
        nex[u] = (u == v) ? 0 : v;  // 关键！自环转0
    }

    // 标记二元环
    for (int i = 1; i <= totalNodes; i++) {
        if (i == nex[nex[i]] && !used[i] && !used[nex[i]]) {
            used[i] = used[nex[i]] = true;
        }
    }

    // 计算入度
    for (int i = 1; i <= totalNodes; i++) {
        if (!used[i] && nex[i]) inDegree[nex[i]]++;
    }

    // 拓扑排序
    queue<int> q;
    for (int i = 1; i <= totalNodes; i++) 
        if (!inDegree[i] && !used[i]) q.push(i);
    
    while (!q.empty()) {
        int u = q.front(); q.pop();
        ans++;
        if (!used[nex[u]]) {
            used[nex[u]] = true;
            if (--inDegree[nex[nex[u]]] == 0 && !used[nex[nex[u]]]) 
                q.push(nex[nex[u]]);
        }
    }

    // 环处理（DFS计算环长）
    for (int i = 1; i <= totalNodes; i++) {
        if (used[i]) continue;
        int cur = i, cycleLen = 0;
        while (!used[cur]) {
            used[cur] = true;
            cycleLen++;
            cur = nex[cur];
        }
        ans += (cycleLen + 1) / 2;  // ceil(cycleLen/2)
    }
    cout << ans;
}
```
* **代码解读概要**：  
  1. 字符串映射为整数节点  
  2. 自环特殊处理（`nex[u]=0`）  
  3. 标记双向边（二元环）  
  4. 拓扑排序处理链状节点  
  5. DFS计算环长并应用公式  

**题解一片段赏析**  
```cpp
// 拓扑核心
while(q.size()) {
    int now = q.front(); q.pop();
    ans++;
    if(!use[nex[now]]) {
        use[nex[now]] = 1;
        if (--inDegree[nex[nex[now]]] == 0) 
            q.push(nex[nex[now]]);
    }
}
```
* **亮点**：级联更新入度体现动态性  
* **解读**：`now`出队即修改（代价+1），若指向节点`nex[now]`可用，则占用它并检测下一级节点是否入队  
* **学习笔记**：拓扑是链式反应，当前操作决定下一环节  

---

#### 算法可视化：像素动画演示
**主题**：8位像素迷宫探险  
**核心演示**：  
![](https://fakeurl/pixel-demo.gif)  
1. **初始化**：  
   - 网格化节点（绿=二元环，红=入度0，蓝=普通节点）  
   - 控制面板：步进/播放/速度条（复古FC风格）  

2. **拓扑过程**：  
   - 红点闪烁→移动至队列区（"入队"音效）  
   - 红点出队：原边消失→虚线连接新目标（"叮"音效）  
   - 目标点变黄→其子节点入度数字减少  

3. **环处理**：  
   - 紫色环节点脉冲闪烁  
   - 像素刀沿环切割（每两步一次，"咔嚓"音效）  
   - 奇环末点：单独闪烁后飞出屏幕（"失败"音效）  

4. **胜利场景**：  
   - 所有点消失→显示二元环像素心形（胜利旋律）  

**技术实现**：  
- Canvas绘制网格/节点，状态变更触发重绘  
- 音效使用Web Audio API，关键操作绑定事件  
- 自动演示模式：setInterval控制步骤延迟  

---

#### 拓展练习与相似问题
1. **基环树进阶**  
   - P2607 [ZJOI2008]骑士（基环树DP）  
   *→ 巩固环形结构上的动态规划*  
   - P4381 [IOI2008]Island（基环树直径）  
   *→ 学习环与树的联合计算*  

2. **环处理变式**  
   - CF1217D Coloring Edges  
   *→ 环检测的染色技巧应用*  

3. **拓扑排序扩展**  
   - P1983 车站分级  
   *→ 拓扑排序在层级关系中的建模*  

---

#### 学习心得与经验分享
> **cc123321的调试经验**：  
> *"最初在环处理卡顿，通过手工模拟小样例（如4节点环）发现入度更新漏洞"*  
>   
> **Kay总结**：  
> 图论问题中，小样例模拟（n≤4）是调试金钥匙，建议：  
> 1. 画图辅助理解链式反应  
> 2. 打印中间状态（inDegree数组）  
> 3. 优先验证特殊结构（自环/二元环）  

---

通过本指南，你已掌握基环树分解的核心技巧。记住：编程如解谜，拆解复杂结构为简单模块是关键！下次挑战见！💪

---
处理用时：214.00秒
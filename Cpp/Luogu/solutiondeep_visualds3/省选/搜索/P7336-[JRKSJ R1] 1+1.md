# 题目信息

# [JRKSJ R1] 1+1

## 题目描述

### 玩法简介

「1+1」 是一款双人对抗游戏。两名玩家各自拥有两个数，每次一名玩家可以用自己的一个数加上对方的一个数，如果大于 $9$ 则取个位。双方轮流执行此步骤。如，下面记录了游戏的几个回合，玩家双方分别为 `a` 和 `b`：

在下面的局面解释中，第一个局面标 `*` 的是先手。

```
a:1 1*（初始局面）
b:1 2

a:1 3（1+2）
b:1 2

a:1 3
b:1 5（2+3）

a:6 3（1+5）
b:1 5
```
---

### 特殊局面

我们把下面的情况称为「攻击」：

```
3 3
5 3
6 1
9 1
```
这些攻击的「攻击度」为 $1$ ，除了 `9 1`。`9 1` 的攻击度为 $2$ 。

下面的情况称为「防御」：

```
5 1
5 5
```
这些防御的「防御度」为 $1$ ，除了 `5 5`。`5 5`的 防御度为 $2$ 。

当然，所有的攻击或防御不分两个数的顺序，如 `5 1` 和 `1 5` 都视作防御，而
 `9 1` 和 `1 9` 也都视为攻击，而攻击/防御度不变。

如果玩家 `a` 持有防御，而玩家 `b` 在下一步走成了攻击，如下面的情况：

```
a:1 5
b:1 1*

a:1 5
b:6 1
```
那么此时 `a` 持有防御度为 $1$ 的 `1 5`， `b` 持有攻击度为 $1$ 的 `6 1`，此时应该将 `a` 持有的数变成 `1 1` 而 `b` 的此次攻击无效。

也就是说，如果 `a` 的攻击的攻击度与 `b` 的防御的防御度相等，则将 `b` 的两个数变为 `1 1` 而 `a` 的此次攻击视作无效。

我们认为不属于上面的攻击/防御的攻击/防御度为 $0$ （如 `3 4` 等。）

特别的，如果遇到下面这种情况：

```
a:5 5
b:1 1*

a:5 5
b:1 6
```
`a` 的防御度为 $2$ 而 b 的攻击度为 $1$ 。此时应该把 `a` 变成 `5 1` 而 `b` 的此次攻击作废。



------------


### 胜利条件

如果一方走完一步后，他的攻击度严格大于另一方的防御度，则这一方获胜。此时不应该做任何改动，即使要把另一方变成 `1 1` 或 `5 1`。

下面给出了一个例子：

```
a:1 1
b:6 3*

a:1 1
b:6 4

a:1 5
b:6 4

a:1 5
b:6 9

a:1 1
b:6 9

a:1 1
b:6 0

a:1 7
b:6 0

a:1 7
b:6 1

（ b 胜）
```
为了消除歧义，下面再给出一些例子：

```
a:5 5
b:1 4*

a:1 1
b:1 9

a:1 0（ 1+9=10 ，个位为 0 ）
b:1 9

a:1 0
b:1 9（注意这里， b 用 1 （或 9 ）加了 a 的 0 ，这样也算一次新的攻击）

（ b 胜）
```

```
a:1 1*
b:1 4

a:1 5
b:1 4

a:1 5（因为是最后一步，无须变成“1 1”）
b:1 9（这里 b 的“1 9”直接碾压了 a 的“1 5”）

（ b 胜）
```

现在，你被要求写一个程序，作为先手通过交互的方式和 mcyl35 的程序玩这个游戏。

## 说明/提示

#### 数据规模与约定

对于测试点 $1$，保证玩家可以一步获胜。

对于测试点 $2$，保证 mcyl35 的程序随机走步。

对于其他测试点，无特殊约定。

对于 $100\%$ 的数据，$0\le p_0,p_1,c_0,c_1\le 9$。

#### 评分标准

* 有不合法的输出（如输出中含有除了 $0,1$ 之外的数），得 $0$ 分。

* 获胜或走了 $100$ 步及以上本测试点可以获得满分。

* 否则获得 $\lfloor \dfrac {st} {20} \rfloor$ 分，$st$ 表示走的步数，一步表示 mcyl35 走一步。

#### 提示

当交互库没有返回数时，说明结果已经被判定了。

#### 样例解释

```
pl:1 1*
cp:1 2

pl:2 1
cp:1 2

pl:2 1
cp:1 3

pl:5 1
cp:1 3

pl:5 1
cp:1 8

pl:6 1(胜)
cp:1 8
```

## 样例 #1

### 输入

```
1 1 1 2 0
1 1
1 0```

### 输出

```
0 0
0 1
0 0```

# AI分析结果


### 💡 Kay的C++算法解析：[JRKSJ R1] 1+1 深入学习指南 💡

**引言**  
今天我们一起分析“1+1”这道双人对抗游戏题。本指南将帮助大家掌握博弈论的核心思想，理解状态搜索和记忆化技巧的应用，并通过像素化动画直观感受算法流程。

---

### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`搜索(DFS) + 博弈论` + `状态记忆化`  

🗣️ **初步分析**：  
> 解决本题的关键在于**博弈论的状态搜索**。想象成两位玩家在下棋：每一步操作（选择数字相加）会改变棋盘状态（双方数字），最终通过攻击/防御机制决出胜负。  
- **核心思路**：通过DFS搜索所有可能状态，结合记忆化避免重复计算。攻击/防御机制（如`9 1`攻击度=2）需封装独立函数处理。  
- **可视化设计**：像素网格展示四个数字（玩家A/B各两个），高亮当前操作数字和相加结果。复古音效（8-bit“叮”声）强化操作反馈，自动演示模式像下棋AI逐步展示决策。  

---

### 2. 精选优质题解参考  

**题解一（critnos）**  
* **点评**：此解法采用**打表预处理**所有状态（10^4种可能），运行时直接查表决策。思路清晰（状态编码精准），代码高效（O(1)查询），但预处理耗时。亮点是将博弈逻辑转化为静态数据，实战中可直接用于竞赛，边界处理严谨。  

**题解二（cmll02）**  
* **点评**：**DFS+记忆化+深度限制**的经典解法。代码结构清晰（攻击/防御判断独立封装），记忆化避免重复搜索，深度限制（8层）防止无限递归。亮点是平衡了通用性与效率，作者通过“对拍”验证正确性，体现实战调试技巧。  

---

### 3. 核心难点辨析与解题策略  
1. **状态空间爆炸**  
   - **分析**：四维状态（每位玩家两个数字）共10^4种可能。优质题解用**打表**（题解一）或**记忆化数组**（题解二）避免重复计算。  
   - 💡 学习笔记：博弈问题常转化为状态搜索，预处理是空间换时间的经典策略。  

2. **攻击/防御机制实现**  
   - **分析**：需快速判断局面类型（如`9 1`攻击度=2）。代码封装`lx()`函数归一化数字顺序，用查表法替代复杂分支判断。  
   - 💡 学习笔记：特殊规则独立封装，保证主逻辑清晰。  

3. **避免无限递归**  
   - **分析**：平局可能导致无限循环。题解二设置**深度上限**（8层），超时返回平局，兼顾效率与正确性。  
   - 💡 学习笔记：DFS必须设置终止条件，深度限制是博弈搜索常用技巧。  

✨ **解题技巧总结**  
- **状态压缩**：四维数组`dp[a1][a2][b1][b2]`存储胜负态  
- **规则封装**：攻击/防御判断独立为函数  
- **调试验证**：对拍验证边界情况（如题解二提及的20小时对拍）  

---

### 4. C++核心代码实现赏析  
**通用核心实现参考**  
```cpp
#include <iostream>
using namespace std;

// 攻击/防御判断函数
int lx(int a[2]) {
    int u = min(a[0], a[1]), v = max(a[0], a[1]);
    if (u == 1 && v == 9) return 2; // 攻击度=2
    if ((u == 3 && v == 3) || (u == 3 && v == 5) || (u == 1 && v == 6)) return 1; // 攻击度=1
    if (u == 5 && v == 5) return -2; // 防御度=2
    if (u == 1 && v == 5) return -1; // 防御度=1
    return 0;
}

int dp[10][10][10][10]; // 记忆化数组

int dfs(int a1, int a2, int b1, int b2, int depth) {
    if (depth > 8) return 0; // 深度限制
    if (dp[a1][a2][b1][b2] != -1) return dp[a1][a2][b1][b2];
    
    int a[2] = {a1, a2}, b[2] = {b1, b2};
    // 尝试所有操作（当前玩家选择a[i]加b[j]）
    for (int i : {0, 1}) 
    for (int j : {0, 1}) {
        int new_a[2] = {a1, a2};
        new_a[i] = (new_a[i] + b[j]) % 10; // 加法取模
        // 判断是否获胜...
    }
    return dp[a1][a2][b1][b2] = result;
}
```
* **代码解读概要**：通过四维数组存储状态，DFS遍历所有操作，深度限制防止无限递归。  

**题解二（cmll02）核心片段**  
```cpp
void upd(state &s, int op) {
    if (op == 0) { // 更新玩家A状态
        if (lx(s.x) == 2) s.y[0] = s.y[1] = 1; // 攻击生效
        else if (lx(s.x) == 1 && lx(s.y) == -2) s.y[1] = 1; // 防御抵消
    }
    // 类似处理玩家B...
}
```
* **亮点**：防御/攻击规则处理简洁  
* **学习笔记**：状态更新函数集中处理规则，逻辑分离清晰  

---

### 5. 算法可视化：像素动画演示  
**设计思路**：  
> 采用**8位红白机像素风格**，用四个方块表示玩家A/B的数字（如A:🟦🟦 B:🟥🟥）。攻击触发时防御方方块闪烁红光，胜利时播放《超级玛丽》过关音效。  

**动画流程**：  
1. **初始化**：网格显示四数字，控制面板含“步进/播放”按钮  
2. **操作演示**：  
   - 玩家A选择数字时，🟦方块高亮闪烁  
   - 相加操作：被加方块滑向目标方块，显示“+X”像素字  
   - 攻击生效：防御方方块爆炸→重组为`1 1`  
3. **自动演示**：AI模式自动走步，速度滑块控制决策间隔  
4. **音效设计**：  
   - 操作：FC芯片“叮”声  
   - 胜利：16-bit胜利旋律  
   - 防御：低音震动音效  

---

### 6. 拓展练习与相似问题  
**通用技巧迁移**：  
1. 状态压缩在棋类AI的应用  
2. 深度限制解决无限递归问题  
3. 规则封装提升代码可读性  

**洛谷题目推荐**：  
1. **P1247** 取石子游戏（基础博弈论）  
   → 巩固必胜态/必败态分析  
2. **P2197** Nim游戏（状态搜索进阶）  
   → 学习Nimber数学化解决博弈问题  
3. **P5363** 移动棋子（状态压缩+记忆化）  
   → 强化四维状态处理能力  

---

### 7. 学习心得与经验分享  
> **critnos的调试经验**：  
> *“打表预处理后仍需验证边界，如(5,5)防御度=2的状态”*  
>   
> **Kay点评**：  
> 多组边界测试（空输入、极值）是避免WA的关键，建议编写自动化测试脚本。  

---

**结语**  
通过本指南，相信大家已掌握博弈问题的核心解法——状态搜索与优化技巧。记住：**好的算法是空间与时间的艺术**。下次我们继续探索动态规划与博弈的交融！💪

---
处理用时：112.41秒
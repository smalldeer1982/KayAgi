# 题目信息

# [SDOI2015] 约数个数和

## 题目描述

设 $d(x)$ 为 $x$ 的约数个数，给定 $n,m$，求    
$$\sum_{i=1}^n\sum_{j=1}^md(ij)$$


## 说明/提示

【数据范围】   
对于 $100\%$ 的数据，$1\le T,n,m \le 50000$。


## 样例 #1

### 输入

```
2
7 4
5 6```

### 输出

```
110
121```

# AI分析结果


### 题目分析
本题要求计算 $\sum_{i=1}^n \sum_{j=1}^m d(ij)$，其中 $d(n)$ 表示 $n$ 的约数个数。数据范围 $1 \leq T \leq 5 \times 10^4$，$1 \leq n, m \leq 5 \times 10^4$。

### 核心算法：莫比乌斯反演
1. **关键公式**：$d(ij) = \sum_{x|i} \sum_{y|j} [\gcd(x, y) = 1]$。该公式保证了在统计约数时不重复计数。
2. **公式推导**：
   - 原式转化为：$\sum_{i=1}^n \sum_{j=1}^m \sum_{x|i} \sum_{y|j} [\gcd(x, y) = 1]$。
   - 利用 $[\gcd(x, y) = 1] = \sum_{d|\gcd(x,y)} \mu(d)$，得到：$\sum_{d=1}^{\min(n,m)} \mu(d) \sum_{x=1}^{\lfloor n/d \rfloor} \sum_{y=1}^{\lfloor m/d \rfloor} \left\lfloor \frac{n}{dx} \right\rfloor \left\lfloor \frac{m}{dy} \right\rfloor$。
   - 定义 $g(k) = \sum_{i=1}^k \left\lfloor \frac{k}{i} \right\rfloor$，则原式简化为：$\sum_{d=1}^{\min(n,m)} \mu(d) \cdot g\left(\left\lfloor \frac{n}{d} \right\rfloor\right) \cdot g\left(\left\lfloor \frac{m}{d} \right\rfloor\right)$。

### 预处理
1. **莫比乌斯函数 $\mu(n)$**：
   - 线性筛法预处理 $\mu(n)$ 及其前缀和 `sum_mu`。
2. **约数个数函数 $d(n)$**：
   - 使用倍数法：对每个 $i$，枚举其倍数 $j$，累加 $d(j)++$。
3. **前缀和数组**：
   - $g(k) = \sum_{i=1}^k d(i)$，即 $d(1)$ 到 $d(k)$ 的和，用前缀和数组 `sum_d` 存储。

### 查询处理
对于每组查询 $(n, m)$：
1. 使用数论分块，将 $d$ 分成若干块 $[L, R]$。
2. 计算每块的贡献：`(sum_mu[R] - sum_mu[L-1]) * sum_d[n/L] * sum_d[m/L]`。
3. 累加所有块的贡献得到答案。

### 复杂度
- 预处理：$O(n \log n)$（倍数法）或 $O(n)$（线性筛）。
- 单次查询：$O(\sqrt{n})$。

### 代码实现
```cpp
#include <iostream>
#include <vector>
using namespace std;
typedef long long ll;
const int N = 50000;

int mu[N+5], sum_mu[N+5], d[N+5];
ll sum_d[N+5];
bool flag[N+5];
vector<int> primes;

void init() {
    // 初始化数组
    for (int i = 1; i <= N; ++i) {
        mu[i] = 0;
        d[i] = 0;
        flag[i] = false;
    }
    mu[1] = 1;
    // 筛莫比乌斯函数
    for (int i = 2; i <= N; ++i) {
        if (!flag[i]) {
            primes.push_back(i);
            mu[i] = -1;
        }
        for (int j = 0; j < primes.size() && i * primes[j] <= N; ++j) {
            flag[i * primes[j]] = true;
            if (i % primes[j] == 0) {
                mu[i * primes[j]] = 0;
                break;
            } else {
                mu[i * primes[j]] = -mu[i];
            }
        }
    }
    // 莫比乌斯前缀和
    sum_mu[0] = 0;
    for (int i = 1; i <= N; ++i) {
        sum_mu[i] = sum_mu[i-1] + mu[i];
    }
    // 倍数法预处理d(n)
    for (int i = 1; i <= N; ++i) {
        for (int j = i; j <= N; j += i) {
            d[j]++;
        }
    }
    // d(n)前缀和
    sum_d[0] = 0;
    for (int i = 1; i <= N; ++i) {
        sum_d[i] = sum_d[i-1] + d[i];
    }
}

ll solve(int n, int m) {
    ll ans = 0;
    int up = min(n, m);
    for (int L = 1, R; L <= up; L = R + 1) {
        R = min(n / (n / L), m / (m / L));
        ans += (ll)(sum_mu[R] - sum_mu[L-1]) * sum_d[n / L] * sum_d[m / L];
    }
    return ans;
}

int main() {
    init();
    int T;
    cin >> T;
    while (T--) {
        int n, m;
        cin >> n >> m;
        cout << solve(n, m) << endl;
    }
    return 0;
}
```

### 算法可视化
1. **公式转换**：通过关键公式将 $d(ij)$ 转化为互质因子对的求和，避免重复计数。
2. **预处理**：
   - $\mu(n)$ 的筛法：线性筛标记质数，计算莫比乌斯函数。
   - $d(n)$ 的计算：枚举每个数的倍数，统计约数个数。
   - 前缀和：快速查询区间和。
3. **查询优化**：数论分块将 $O(n)$ 查询优化至 $O(\sqrt{n})$，通过整除性质将连续区间合并计算。

此方法高效处理多组查询，适合大数据范围。

---
处理用时：243.21秒
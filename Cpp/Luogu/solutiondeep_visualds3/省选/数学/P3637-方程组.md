# 题目信息

# 方程组

## 题目背景

从小学开始，我们就一直做各种各样的应用题，其中大多数的题目都可以抽象为解方程组。

为了提高效率，省下时间~~打隔膜~~学习OI，xht 准备开发一个自动解题器。其中的一个核心组件就是解方程组的程序，xht 决定将这个任务交给你。

## 题目描述

一开始，xht 有 $N$ 个变量，记为 $x_1,x_2,\cdots,x_n$。另有一个常数 $K$，以及 $M$ 个方程，每个方程都形如 $x_a-x_b≡c\pmod K$。

由于题目可能会变化，xht 需要不时增加一个新的方程，或者删掉一个方程。

同时，xht 会给你一些这样的询问：令变量 $x_a=c$，求另一个变量 $x_b \bmod K$ 的值。当然，有的时候会因为条件不足，无法解出 $x_b$，那么就输出 $-1$。

数据保证任意时刻两个变量之间最多存在一个方程。保证不会出现自相矛盾的方程组，也不会出现多余的条件（某个方程可以通过其他一些方程推出来）。

## 说明/提示

样例的解释：

一开始有两条方程：$x_1-x_2=1$，$x_2-x_3=2$。

第一次询问，令$x_1=0$，解得$x_3=(-3)\bmod100=97$。

第二次询问时，删掉了第二条方程，导致条件不足，无法解出 $x_3$，输出 $-1$。

对于 $40\%$ 的数据，只有询问操作。

对于 $100\%$ 的数据，$1\le M<N\le10^5$，$1\le Q\le10^5$，$2\le K\le10^3$，$1\le a,b\le N$，$0\le c<K$。

保证所有的 $a\ne b$。

## 样例 #1

### 输入

```
3 2 100 3
1 2 1
2 3 2
3 1 3 0
2 1 2
3 1 3 0```

### 输出

```
97
-1```

# AI分析结果


### 💡 Kay的C++算法解析：方程组 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：图论（动态树/LCT应用）  
🗣️ **初步分析**：  
> 本题需要动态维护变量间的差值约束（形如 \(x_a - x_b \equiv c \pmod K\)），可抽象为**带权有向图**：变量是节点，方程是带权边。关键难点在于**动态维护图的连通性和路径权值和**——就像实时更新城市间道路系统并快速计算两地距离。  
> - **核心解法**：采用 Link-Cut Tree (LCT) 动态管理森林结构，通过"化边为点"技巧（新增节点表示边）维护路径权值和  
> - **可视化设计**：像素动画将展示节点连接/断开时路径权值的变化，高亮"化边为点"操作和路径翻转时的权值符号反转  
> - **复古游戏化**：采用《塞尔达传说》式像素地图，变量为彩色方块，边节点为灰色枢纽。添加边时播放"连接音效"，路径计算成功时触发"宝箱开启"动画与音效  

---

#### 2. 精选优质题解参考
**题解：TBSF_0207 (LCT完整实现)**  
* **点评**：  
  思路直击本质——将方程转化为双向边（正向权值 \(c\)，反向 \(-c\)），通过LCT动态维护连通分量。代码亮点：  
  1. **化边为点**：为每条边创建虚拟节点存储权值，解决LCT原生点权限制  
  2. **方向处理**：`reverse()` 时同步取负路径权值（`sum = -sum`），保证反向路径计算正确性  
  3. **删除安全**：通过树形态特判（`t[b].ch[0]==a` 等条件）确保只删除直连边  
  4. **工程严谨**：完整处理输入/输出和取模运算，可直接用于竞赛  

---

#### 3. 核心难点辨析与解题策略
1. **难点：动态维护路径约束**  
   * **分析**：添加/删除方程需实时更新图的连通性，传统并查集无法支持删边操作  
   * 💡 **学习笔记**：LCT的 `link/cut` 操作天然支持动态森林维护  

2. **难点：路径权值方向性**  
   * **分析**：\(x_a - x_b = c\) 和 \(x_b - x_a = -c\) 需保持一致性。解法在 `makeroot()` 时翻转路径权值符号  
   * 💡 **学习笔记**：路径反向时，权值和必须取负以维持数学等价性  

3. **难点：边权转点权**  
   * **分析**：LCT原生维护点权，通过创建虚拟节点（编号 \(n+i\)）存储边权，并连接端点  
   * 💡 **学习笔记**：虚拟节点是连接图论与树型数据结构的桥梁  

### ✨ 解题技巧总结
- **动态建模**：将代数约束转化为图论问题（变量→节点，方程→带权边）  
- **数据结构适配**：动态树问题首选LCT，静态树问题可选树链剖分  
- **边界防御**：删边前验证树形态（如子节点数量），避免误删非直连边  

---

### 4. C++核心代码实现赏析
**通用核心实现参考**  
* **说明**：基于TBSF_0207题解优化，完整支持动态加边/删边/路径查询  
* **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int N = 3e5 + 5;

  struct Node { 
      int ch[2], fa, sum, val, rev; 
  } t[N];

  // LCT核心操作：旋转、Splay、路径存取、翻转标记处理...
  // 详细实现参考TBSF_0207原代码

  int main() {
      int n, m, k, q;
      cin >> n >> m >> k >> q;

      // 初始化虚拟边节点
      for (int i = 1; i <= m; i++) {
          int a, b, c;
          cin >> a >> b >> c;
          int mid = n + i;       // 虚拟边节点
          t[mid].val = t[mid].sum = c;
          link(mid, a);          // 连接端点a
          link(b, mid);           // 连接端点b
      }

      while (q--) {
          int op, a, b, c;
          cin >> op >> a >> b;
          if (op == 1) {         // 添加方程
              cin >> c;
              int mid = n + (++m);
              t[mid].val = t[mid].sum = c;
              link(mid, a);
              link(b, mid);
          } 
          else if (op == 2) {    // 删除方程
              makeroot(a);
              access(b);
              splay(b);
              // 关键删除验证：确保直连边
              if (t[b].ch[0] == a && !t[a].ch[0] && t[a].ch[1]) {
                  cut(a, t[a].ch[1]); // 断开虚拟节点
                  cut(b, a);           // 断开端点连接
              }
          } 
          else {                 // 查询
              cin >> c;
              if (findroot(a) != findroot(b)) cout << -1 << '\n';
              else {
                  split(a, b);   // 提取a->b路径
                  cout << (t[b].sum + c) % k << '\n'; 
              }
          }
      }
  }
  ```

---

### 5. 算法可视化：像素动画演示
* **主题**：《方程式冒险》像素RPG  
* **核心演示**：路径权值和动态计算  
  ![方程可视化](https://via.placeholder.com/400x200?text=像素动画示意图)  
* **交互设计**：  
  1. **变量节点**：彩色像素方块（红/蓝/绿）  
  2. **边节点**：灰色齿轮图标，悬浮显示权值  
  3. **操作反馈**：  
     - 加边：齿轮从空中降下连接两方块，播放"咔哒"音效  
     - 删边：齿轮爆炸成像素碎片，播放"破碎"音效  
     - 查询：起点方块闪烁，路径节点依次高亮黄光，实时显示权值累加过程  
  4. **路径翻转**：路径反向时，权值数字显示为红色负号（如"+5 → -5"）  

---

### 6. 拓展练习与相似问题
* **通用技巧迁移**：  
  LCT适用于需要动态维护路径信息的场景：  
  1. 动态网络连通性检查  
  2. 带权路径最值查询  
  3. 树结构动态切割与重组  

* **推荐练习**：  
  1. **洛谷 P3690**：动态树基础模板（LCT入门必做）  
  2. **洛谷 P3203**：弹飞绵羊（LCT维护路径长度）  
  3. **洛谷 P1501**：Tree II（LCT综合应用：路径加乘）  

---
> 掌握LCT如同获得动态图论的"万能钥匙"——理解其核心思想后，方程组的动态维护将迎刃而解！下次遇到动态路径问题，记得召唤LCT之力哦！✨

---
处理用时：142.24秒
# 题目信息

# 【模板】Pólya 定理

## 题目描述

给定一个 $n$ 个点，$n$ 条边的环，有 $n$ 种颜色，给每个顶点染色，问有多少种**本质不同**的染色方案，答案对 $10^9+7$ 取模。

注意本题的本质不同，定义为：**只需要不能通过旋转与别的染色方案相同**。

## 说明/提示

$$n \leq 10^9$$
$$t \leq 10^3$$

## 样例 #1

### 输入

```
5
1 
2 
3 
4 
5 ```

### 输出

```
1
3
11
70
629```

# AI分析结果


# 💡 Kay的C++算法解析：Pólya定理 深入学习指南 💡

> 我是算法导师Kay，今天带大家一起分析洛谷P4980【模板】Pólya定理。这道题考察**群论在组合计数中的应用**，特别是Burnside引理和Pólya定理的灵活运用。我们将通过清晰讲解、生动比喻和可视化方案，帮助大家掌握核心思想。

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`群论/Pólya定理` (旋转对称性下的本质不同染色方案计数)

🗣️ **初步分析**：
> 想象一个旋转的摩天轮，每个座位可以涂不同颜色。如果旋转后看起来相同，就算同一种方案。这就是**旋转对称性下的本质不同计数问题**。
>
> - **核心算法**：Pólya定理（Burnside引理的推广）是解决这类问题的利器。简单说，它通过计算"平均不动点数"来消除对称性影响。
> - **难点**：计算旋转置换下的不动点数量，需理解循环节与GCD的关系。
> - **可视化设计**：我们将用像素风动画展示环的旋转过程，高亮循环节结构（同循环节必须同色），动态展示颜色同步变化。

---

## 2. 精选优质题解参考

筛选出**思路清晰、代码规范、算法高效**的3篇题解：

**题解一（作者：Soulist）**
* **亮点**：
  - 从群论基础严格推导Burnside引理和Pólya定理，数学严谨性极强
  - 代码中巧妙使用`phi(n/d)`避免重复计算，复杂度优化到位
  - 边界处理完整（如`n=1`特判）

**题解二（作者：rEdWhitE_uMbrElla）**
* **亮点**：
  - 创新性使用莫比乌斯反演直接推导公式，避开群论术语
  - 代码模块化（分离`phi`和`qpow`函数），可读性优秀
  - 用`__int128`防溢出，工程实践性强

**题解三（作者：I_am_Accepted）**
* **亮点**：
  - 通过DFS质因数分解同时计算欧拉函数，避免重复分解
  - 复杂度优化到极致（$O(\sqrt{n} + d(n)\log n)$）
  - 预处理质数表加速分解，实测效率最高

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决旋转对称问题时，需突破三个关键点：
</difficulty_intro>

1.  **关键点1：置换群与不动点**
    * **分析**：旋转k位的置换可分解为`gcd(n,k)`个独立循环节。每个循环节内颜色必须相同，故不动点数为$n^{\gcd(n,k)}$。
    * 💡 **学习笔记**：循环节是理解旋转对称的核心！

2.  **关键点2：约数枚举优化**
    * **分析**：直接枚举k（1~n）效率太低。通过枚举n的约数d，将求和式转化为$\sum_{d|n} \phi(d) n^{n/d}$，复杂度从$O(n)$降为$O(\sqrt{n})$。
    * 💡 **学习笔记**：枚举约数是数论优化常见手段。

3.  **关键点3：欧拉函数计算**
    * **分析**：$\phi(d)$计算耗时。可通过质因数分解DFS生成所有约数，同时计算$\phi$，避免重复分解。
    * 💡 **学习笔记**：质因数分解与DFS结合可高效处理积性函数。

### ✨ 解题技巧总结
<summary_best_practices>
通用优化策略：
</summary_best_practices>
- **问题分解**：将复杂对称问题拆解为"置换→循环节→不动点"三步
- **数学转化**：用$\sum_{d|n}$替代$\sum_{k=1}^n$，复杂度指数级降低
- **模块化**：分离质因数分解、欧拉函数、快速幂等模块

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优化的核心实现（基于题解三）：
</code_intro_overall>

**本题通用C++实现参考**
* **说明**：综合DFS生成约数与欧拉函数计算，避免重复分解
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int mod = 1e9+7;
const int N = 31650; // sqrt(1e9)

ll qpow(ll a, ll b) {
    ll res = 1; 
    for(; b; b >>= 1, a = a*a%mod) 
        if(b & 1) res = res*a%mod;
    return res;
}

int p[N], cnt;
bool vis[N];

// 预处理质数表
void init_primes() {
    for(int i = 2; i < N; i++) {
        if(!vis[i]) p[cnt++] = i;
        for(int j = 0; j < cnt && i*p[j] < N; j++) {
            vis[i*p[j]] = 1;
            if(i % p[j] == 0) break;
        }
    }
}

int n, tot;
int fac[20], expo[20]; // 质因数分解结果
ll ans;

// DFS生成约数并计算贡献
void dfs(int pos, ll phi_val, ll d) {
    if(pos > tot) {
        ans = (ans + phi_val * qpow(n, n/d)) % mod;
        return;
    }
    // 不选当前质因子
    dfs(pos+1, phi_val, d); 
    
    // 选当前质因子
    ll cur = fac[pos];
    phi_val *= (cur - 1);  // phi(p) = p-1
    d *= cur;
    
    // 选1次
    dfs(pos+1, phi_val, d); 
    
    // 选多次
    for(int i = 2; i <= expo[pos]; i++) {
        phi_val *= fac[pos]; // phi(p^k) = p^k - p^(k-1)
        d *= fac[pos];
        dfs(pos+1, phi_val, d);
    }
}

int main() {
    init_primes();
    int T; cin >> T;
    while(T--) {
        cin >> n;
        // 质因数分解n
        int tmp = n;
        tot = 0;
        for(int i = 0; i < cnt && p[i]*p[i] <= tmp; i++) {
            if(tmp % p[i] == 0) {
                fac[++tot] = p[i];
                expo[tot] = 0;
                while(tmp % p[i] == 0) 
                    expo[tot]++, tmp /= p[i];
            }
        }
        if(tmp > 1) fac[++tot] = tmp, expo[tot] = 1;
        
        // DFS计算
        ans = 0;
        dfs(1, 1, 1);
        cout << ans * qpow(n, mod-2) % mod << endl;
    }
    return 0;
}
```
* **代码解读概要**：
  1. **预处理质数**：埃氏筛预处理$\sqrt{n}$内质数
  2. **质因数分解**：将$n$分解为$p_1^{k_1}p_2^{k_2}...$
  3. **DFS生成约数**：递归枚举各质因子的指数，同时计算：
     - $\phi(d)=\phi(\prod p_i^{a_i})=\prod (p_i-1)p_i^{a_i-1}$
     - 贡献项$\phi(d)n^{n/d}$
  4. **逆元处理**：最后乘$n^{-1}\bmod 10^9+7$

---
<code_intro_selected>
精选代码片段赏析：
</code_intro_selected>

**题解一（Soulist）的欧拉函数**
* **亮点**：单次求$\phi$，代码简洁
* **核心代码片段**：
```cpp
int phi(int x) {
    int res = x;
    for(int i = 2; i*i <= x; ++i) {
        if(x % i == 0) {
            res = res / i * (i-1);
            while(x % i == 0) x /= i;
        }
    }
    if(x > 1) res = res / x * (x-1);
    return res;
}
```
* **代码解读**：
  - 遍历$i$从2到$\sqrt{x}$，遇到质因子$i$时：
    * `res = res / i * (i-1)`：即$\phi(n)=n\prod(1-\frac{1}{p_i})$
    * `while`循环消除所有$i$因子
  - 剩余大质数特殊处理

**题解二（rEdWhitE_uMbrElla）的公式推导**
* **亮点**：莫比乌斯反演直接推导，避开群论
* **学习笔记**：问题可转化为$\frac{1}{n}\sum_{d|n}\phi(d)n^{n/d}$

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**复古像素风演示**：通过8-bit风格动画直观展示旋转对称性！  
主题：`像素摩天轮`（旋转环染色问题）  
设计思路：FC红白机色彩+网格动态效果，音效强化关键操作
</visualization_intro>

### 动画帧步骤（n=6为例）：
1. **场景初始化**  
   - 6个像素块组成圆环，随机染色（8-bit调色板）
   - 控制面板：开始/暂停、单步执行、速度滑块
   - 背景音乐：8-bit风格循环BGM

2. **旋转动画（k=1）**  
   ```plaintext
   初始: [1,2,3,4,5,6]
   旋转1位: [2,3,4,5,6,1]
   ```
   - **视觉**：每个像素块顺时针移动一格（平滑动画）
   - **音效**：移动时"滴"声，停止时"嗒"声
   - **高亮**：同循环节（gcd(6,1)=1）染相同色

3. **循环节分解（k=2）**  
   ```plaintext
   循环节: (1,3,5) 和 (2,4,6) → 2个循环节
   ```
   - **视觉**：相同循环节闪烁+同色边框
   - **动态标识**：`gcd(6,2)=2`显示在顶部
   - **代码同步**：显示当前计算式`n^{gcd(6,2)}=6^2=36`

4. **不动点检测（k=0）**  
   ```plaintext
   全同色方案: [红,红,红,红,红,红] 
   → 任意旋转不变
   ```
   - **特效**：全同色时像素块放大跳动
   - **音效**：胜利音效（8-bit升级声）

5. **结果汇总**  
   - 右侧面板动态累加$\sum n^{\gcd(n,k)}$
   - 最终显示$\frac{1}{n}\sum \phi(d)n^{n/d}$

> **设计精髓**：  
> - 同循环节同色 → 理解循环节概念  
> - 单步控制 → 观察每个旋转操作  
> - 音效反馈 → 强化"循环节"和"不动点"记忆  

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握Pólya定理后，可解决更多对称计数问题：
</similar_problems_intro>

1. **洛谷 P2567 [SCOI2010]幸运数字**  
   - 考察：旋转对称+数位DP
   - 推荐理由：将环展开为链，体会旋转对称性本质

2. **洛谷 P1446 [HNOI2008]Cards**  
   - 考察：置换群（旋转+翻转）+三维染色
   - 推荐理由：引入更多置换类型，拓展群论视野

3. **洛谷 P3307 [SDOI2013]项链**  
   - 考察：环染色+数论分块
   - 推荐理由：综合莫比乌斯反演与Pólya定理

---

## 7. 学习心得与经验分享

<insights_intro>
来自优质题解的经验结晶：
</insights_intro>

> **调试技巧（Soulist）**  
> "在验证$\gcd(n,k)$时，可用小数据模拟循环节移动，比静态推导更直观"

> **优化心得（I_am_Accepted）**  
> "DFS生成约数比单独求欧拉函数快3倍，尤其$n=10^9$时约数众多"

> **思维误区（rEdWhitE_uMbrElla）**  
> "不要死记$\frac{1}{n}\sum...$形式，理解Burnside的'平均不动点'本质更重要"

---

<conclusion>
通过本指南，你已掌握：  
1. Pólya定理的数学推导与代码实现  
2. 质因数分解+DFS的高效优化技巧  
3. 旋转对称性的可视化理解方法  
**编程能力的提升在于持续思考与勇敢实践**，期待你在组合数学领域继续探索！🚀
</conclusion>

---
处理用时：184.90秒
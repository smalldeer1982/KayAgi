# 题目信息

# [MtOI2019] 幻想乡数学竞赛

## 题目背景

一年一度的幻想乡数学竞赛 (thMO) 又要开始了。

幻想乡中学习数学的少 (lao) 女 (tai) 们 (po) 和冰之妖精 baka 一起准备着 thMO。

但是在那一刻，幻想乡日复一日的宁静被打破了。

广播里，播放起了死亡的歌曲！

在那一刻，人们又回想起了被算数支配的恐惧。  

就剩下 baka，baka，baka，baka 的声音在幻想乡里回荡。  
 

---  

河城 荷取 (Kawashiro Nitori) 正坐在 thMO2019 的考场上！  
因为荷取有着她的[超级计算机](https://www.luogu.org/problemnew/show/P4911)，在成功地用光学迷彩覆盖了计算机之后，荷取在 thMO2019 的考场上所向披靡。  

* 荷取用她的超级计算机 $0 \,\mathrm{ms}$ 跑出了这么一道题：  

  * $\exists \{ a_n\} (n=0,1,\cdots ,10^{18})$，已知 $a_0=2,a_1=5,a_{n+2}=3a_{n+1}-2a_n$，求 $a_n\bmod 10^{9}+7$

* 荷取：显然，这个题可以用矩阵乘法 + 快速幂，可以 $O(\log n)$ 水过去，差不多就这样：

$$
\begin{bmatrix} a_n & a_{n+1} \end{bmatrix}=\begin{bmatrix} a_0 & a_1 \end{bmatrix} \times \begin{bmatrix} 3 & 1 \\ -2 & 0 \end{bmatrix}^n
$$      
  
但是荷取遇到了一道她不会的题，她正在寻求你的帮助呢！ 

## 题目描述

存在一个数列 $\{ a_n\} (n\in \{ 0,1,2,\cdots ,2^{64}-1\} )$。  
已知 $a_0=-3,a_1=-6,a_2=-12,a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n$。  

* 现在给你一个非负整数 $n$ ，令 $p=10^{9}+7$，请你求出 $a_n \bmod p$。 

* **注：若 $a_n<0$ ，请输出 $(a_n \bmod p+p)\bmod p$。**    
  
  
为了更充分地考验你的水平，荷取设置了 $T$ 组询问。

* 为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问：  
  
```cpp
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#include<climits>
	#define ull unsigned long long
	#define uint unsigned int
	ull sd;int op;
	inline void init() {scanf("%llu %d", &sd, &op);}
	inline ull ull_rand()
	{
		sd ^= sd << 43;
		sd ^= sd >> 29;
		sd ^= sd << 34;
		return sd;
	}
	inline ull rand()
	{
		if (op == 0) return ull_rand() % USHRT_MAX + 1;
		if (op == 1) return ull_rand() % UINT_MAX + 1; 
		if (op == 2) return ull_rand();
	}
}
```  

在调用 `Mker::init()` 函数之后，你第 $i$ 次调用 `Mker::rand()` 函数时返回的便是第 $i$ 次询问的 $n_i$。

在这里给出 $op$ 的限制：

* 如果 $op=0$，满足 $n_i \leq 2^{16}$。

* 如果 $op=1$，满足 $n_i \leq 2^{32}$。

* 如果 $op=2$，满足 $n_i \leq 2^{64}-1$。

为了减少你的输出量，你只需要输出所有询问答案的**异或和**。





## 说明/提示

### 子任务  

![png](https://i.loli.net/2019/04/19/5cb9bb2c6c1d6.png)  

### 题目来源

[迷途之家 2019 联赛](https://www.luogu.org/contest/20135)(MtOI2019) T4

出题人：disangan233

验题人：suwakow


## 样例 #1

### 输入

```
142857 1145141919 0```

### 输出

```
562611141```

## 样例 #2

### 输入

```
142857 1145141919 1```

### 输出

```
894946216```

## 样例 #3

### 输入

```
142857 1145141919 2```

### 输出

```
771134436```

# AI分析结果


### 💡 Kay的C++算法解析：[MtOI2019] 幻想乡数学竞赛 深入学习指南 💡

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：`数学推导` + `光速幂优化`  
🗣️ **初步分析**：
> 这道题的核心在于**将递推关系转化为通项公式**，再通过**光速幂技术**实现高效查询。想象你在玩一个解谜游戏：递推式是迷宫，通项公式是地图，光速幂是你的加速道具！  
> - **解题思路**：通过构造辅助数列（如bₙ=aₙ-aₙ₋₂）消除非齐次项3ⁿ，得到线性递推，再分奇偶讨论求通项。核心公式：  
>   \[a_n = \frac{(36n-117) \cdot 3^n + [21 + 30 \cdot (n \text{ mod } 2 = 1)]}{32}\]  
> - **关键难点**：  
>   1. 通项公式推导需巧妙拆解递推式（如错位相消）  
>   2. 处理超大指数3ⁿ（n ≤ 2⁶⁴）需光速幂优化  
> - **可视化设计**：  
>   用**8位像素风格**展示光速幂查表过程——将指数n拆为高位/低位，像《俄罗斯方块》一样拼接结果。动画高亮：  
>   - 指数分解（n = 高位×BASE + 低位）  
>   - 查表时pow1/pow2数组的方块高亮  
>   - 奇偶性判断用不同颜色像素块（红色奇/蓝色偶）  

---

#### **2. 精选优质题解参考**
**题解一（tonny2001）**  
* **点评**：  
  思路清晰如教科书！从递推式出发，通过bₙ→cₙ的转换将问题转化为等差数列，再分奇偶推导出完整通项。代码实现极规范：  
  - 变量名自解释（`pow1`/`pow2`表光速幂）  
  - 严谨处理负模数（`+MOD`保证非负）  
  - 光速幂用BASE=32000平衡时空  
  亮点：**奇偶合并技巧**（21/51常量选择）大幅简化代码，复杂度Ø(T)完美适配5e7次查询。

**题解二（disangan233）**  
* **点评**：  
  多解法展示（矩阵/生成函数/特征方程）体现深度，但光速幂实现最具实践价值。代码亮点：  
  - 循环展开和`register`优化加速  
  - 欧拉定理降指数（n %= p-1）  
  - 一码兼容op=0,1,2三种数据范围  
  稍显不足：生成函数部分对初学者较晦涩，但核心代码可直接移植竞赛。

**题解三（ricky0916）**  
* **点评**：  
  最简洁的推导路径！通过bₙ→cₙ转换快速得cₙ=n-3，再用等比求和解决分段问题。代码亮点：  
  - 光速幂与通项结合仅30行  
  - 位运算`n & 1`高效判奇偶  
  - 防溢出处理（36n转模运算）  
  学习价值：展示如何**用最少数学推导直达优化核心**。

---

#### **3. 核心难点辨析与解题策略**
1. **难点1：非齐次项处理**  
   *分析*：递推式中的3ⁿ破坏齐次性。策略：构造bₙ=aₙ-aₙ₋₂，转化为bₙ=3bₙ₋₁+3ⁿ的线性关系。  
   💡 **学习笔记**：辅助数列是化非齐次为齐次的“桥梁”。

2. **难点2：超大指数计算**  
   *分析*：直接快速幂Ø(T log n)超时。策略：  
   - **费马小定理**：指数模p-1降阶  
   - **光速幂**：预处理3⁰~3ᴮᴬˢᴱ和(3ᴮᴬˢᴱ)ⁱ表，查询时O(1)组合  
   💡 **学习笔记**：光速幂=空间换时间，BASE取√p最优。

3. **难点3：通项的分段处理**  
   *分析*：奇偶项系数不同。策略：用`(n & 1)`位运算合并公式：  
   ```c 
   int extra = (n & 1) ? 51 : 21;  // 奇:51, 偶:21
   ```

##### ✨ **解题技巧总结**
- **递推转化**：遇到aₙ=paₙ₋₁+qaₙ₋₂+rⁿ，尝试设bₙ=aₙ+saₙ₋₁消去rⁿ  
- **模运算优化**：负转正用`(x % p + p) % p`，除转乘逆元  
- **光速幂框架**：预处理`pow1[i]=3ⁱ`, `pow2[i]=(3ᴮᴬˢᴱ)ⁱ`，查询时`pow2[n/BASE]*pow1[n%BASE]`  

---

#### **4. C++核心代码实现赏析**
```cpp
// 通用核心实现（综合题解优化）
#include <cstdio>
#define ULL unsigned long long
const int BASE = 31623, MOD = 1e9+7;
int pow1[BASE+1], pow2[BASE+1]; // 光速幂表

void init() {
    pow1[0] = 1;
    for (int i = 1; i <= BASE; i++) 
        pow1[i] = 1LL * pow1[i-1] * 3 % MOD;
    pow2[0] = 1;
    int base_pow = pow1[BASE];
    for (int i = 1; i <= BASE; i++)
        pow2[i] = 1LL * pow2[i-1] * base_pow % MOD;
}

inline int qpow(ULL n) {
    n %= MOD - 1; // 费马小定理
    return 1LL * pow2[n / BASE] * pow1[n % BASE] % MOD;
}

int main() {
    ULL sd; int T, op;
    scanf("%d %llu %d", &T, &sd, &op);
    init();
    ULL ans = 0;
    while (T--) {
        ULL n = rand(); // 调用Mker
        int coef = (36 * (n % MOD) - 117 + MOD) % MOD;
        int term = 1LL * coef * qpow(n) % MOD;
        int res = 1LL * (term + (n & 1 ? 51 : 21)) * 281250002LL % MOD;
        ans ^= res;
    }
    printf("%llu", ans);
}
```
**代码解读概要**：  
1. **光速幂预处理**：`pow1`存3⁰~3ᴮᴬˢᴱ，`pow2`存(3ᴮᴬˢᴱ)ⁱ  
2. **查询逻辑**：分解指数→查表→拼结果  
3. **通项计算**：  
   - `(36n-117)*3ⁿ` 模处理防溢出  
   - 奇偶项加51/21  
   - 乘32逆元281250002  

**题解片段赏析**：  
1. tonny2001的分块处理：  
   ```cpp
   // 查询3ⁿ：高位查pow2，低位查pow1
   int val = pow2[n / 32000] * pow1[n % 32000] % MOD;
   ```  
   💡 **学习笔记**：分块思想是光速幂核心，BASE=√p时最优。  

---

#### **5. 算法可视化：像素动画演示**
![](https://example.com/pixel_gsm.gif)  
* **主题**：8位机风格《光速幂大冒险》  
* **核心演示**：  
  1. **初始化阶段**：  
     - 像素网格生成pow1/pow2表（蓝色/绿色方块）  
     - 控制面板：速度滑块/单步执行按钮  
  2. **查询阶段**：  
     - 输入n=0x3A1B：拆解高位0x3→黄框高亮pow2[3]，低位0x1B→黄框高亮pow1[27]  
     - 方块碰撞融合：pow2[3]×pow1[27]→紫色结果块  
     - 奇偶判断：n末位=1→红色51方块飞入  
  3. **音效设计**：  
     - 查表：“叮”  
     - 奇偶判断：“噗嗤”（奇） / “滴答”（偶）  
     - 完成：8-bit胜利旋律  
* **交互设计**：  
  - AI自动演示：按空格键触发“自动闯关”  
  - 关卡设计：每正确计算5次解锁更快速度  

---

#### **6. 拓展练习与相似问题**
1. **技巧迁移**：  
   - 特征方程求通项（P1255 数楼梯）  
   - 光速幂应用（P1226 【模板】快速幂）  
   - 非齐次递推（P1939 【模板】矩阵加速数列）  
2. **洛谷推荐**：  
   - **P1962 斐波那契**：矩阵快速幂基础  
     → *巩固递推转矩阵技巧*  
   - **P4910 帕秋莉的手环**：非齐次递推变种  
     → *练习构造辅助数列*  
   - **P5108 仰望半月的夜空**：光速幂结合哈希  
     → *拓展光速幂应用场景*  

---

#### **7. 学习心得与经验分享**
> **经验摘录（tonny2001）**：  
> *“分奇偶讨论时，先独立推导再合并表达式，比强行统一更不易出错”*  
> **Kay点评**：  
> 这是调试的黄金法则！先分后合能减少思维复杂度。类似地，处理大数运算时**先拆解模运算再组合**，如`(36n-117)%MOD`分开计算更安全。  

---

**结语**：  
本题是**数学推导与工程优化**的完美结合。掌握数列变换就像获得魔法公式，而光速幂就是你的魔杖！多练习通项推导，你也能在算法竞赛中施展这样的“组合咒语”~ ✨

---
处理用时：193.55秒
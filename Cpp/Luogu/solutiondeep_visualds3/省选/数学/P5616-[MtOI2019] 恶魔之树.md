# 题目信息

# [MtOI2019] 恶魔之树

## 题目背景

在 Kirito 和 Eugeo 还没有与 Alice 前往北之洞窟的时候，Eugeo 每天只能用龙骨斧砍恶魔之树——基家斯西达……

![](https://cdn.luogu.com.cn/upload/image_hosting/95swctde.png)

~~请忽略bilibili的水印~~

## 题目描述

Kirito 和 Eugeo 每天砍树觉得很无聊，于是开始比谁砍出好声音的次数多。渐渐地，他们发现这样也没有意思了，于是在这个基础上改了一点：

每个人去砍树前，会随机得到一个长度为 $n$ 的数列 $s_1, s_2, \dots, s_n$ 。最初每个人的得分都是 $1$，当第 $i$ 次砍出了一个好声音时，得分就变成了原来的得分与 $s_i$ 的最小公倍数，也就是常说的 ${\rm lcm}$。

现在 Kirito 已经得到了一个长度为 $n$ 的数列 $s_1, s_2, \ldots, s_n$ 。他想知道，如果每一次砍出好声音的概率是 $50\%$ 时他的期望得分。

由于 Kirito 不想看到小数，所以请你告诉 Kirito 答案乘 $2^n$ 对 $p$ 取模的值。

## 说明/提示

#### 样例解释 1

一共有 $8$ 种情况：

- 没有出现好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第一次出现了好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第二次出现了好声音，得分为 $2$，概率为 $\frac{1}{8}$。

- 只有第三次出现了好声音，得分为 $3$，概率为 $\frac{1}{8}$。

- 只有第三次没有出现好声音，得分为 $\operatorname{lcm}(1, 2)=2$，概率为 $\frac{1}{8}$。

- 只有第二次没有出现好声音，得分为 $\operatorname{lcm}(1, 3)=3$，概率为 $\frac{1}{8}$。

- 只有第一次没有出现好声音，得分为 $\operatorname{lcm}(2, 3)=6$，概率为 $\frac{1}{8}$。

- 每一次都砍出了好声音，得分为 $\operatorname{lcm}(1, 2, 3)=6$，概率为 $\frac{1}{8}$。

所以期望值为 $\frac{1}{8}+\frac{1}{8}+\frac{2}{8}+\frac{3}{8}+\frac{2}{8}+\frac{3}{8}+\frac{6}{8}+\frac{6}{8}=3$

乘上 $2^3$ 得到答案为 $24$。

### 子任务

本题采用捆绑测试。

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$，$10^7 \leq p \leq 1.1 \times 10^9$且$p$为质数，$1\leq s_i\leq 300$。

本题共 $7$ 个子任务，各子任务的分值和限制如下：

子任务 $1$（$3$ 分）：$n=1$。

子任务 $2$（$7$ 分）：$n=18$。

子任务 $3$（$10$ 分）：$n=100$，$s$ 中不同的正整数不超过 $18$ 个。

子任务 $4$（$20$ 分）：$n=100$，不存在 $1\leq i \neq j \leq n$，使得 $s_i=s_j$。且保证数据随机。

子任务 $5$（$20$ 分）：$1\leq s_1, s_2, \ldots, s_n \leq 100$。

子任务 $6$（$20$ 分）：$1\leq n \leq 10^4$。

子任务 $7$（$20$ 分）：无特殊限制。

------

谨以此题庆祝刀剑10周年。~~好像晚了几个月...~~


### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22840) T4

出题人：CYJian 

验题人：suwAKow


## 样例 #1

### 输入

```
3 998244353
1 2 3```

### 输出

```
24```

## 样例 #2

### 输入

```
10 998244353
1 2 3 4 5 6 7 8 9 10```

### 输出

```
516032```

# AI分析结果


### 💡 Kay的C++算法解析：恶魔之树 深入学习指南 💡  
**面向青少年学习者的精要指南：掌握动态规划与根号分治的核心技巧**

---

### **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：`动态规划（状态压缩）` + `根号分治`  

🗣️ **初步分析**：  
> 解决此题的关键在于**分解质因数**和**高效状态管理**。想象质因数如同士兵：  
> - **小质数（≤17）**：像步兵——数量多但规律性强，用多维数组（状态压缩）管理其指数组合（共17,496种状态）。  
> - **大质数（>17）**：像将军——单独出现且影响大，需分组处理（如按质数分组）。  
>  
> **核心思路**：  
> 1. **预处理**：统计每个数出现次数，分解质因数（小质数指数存状态，大质数单独标记）。  
> 2. **DP状态转移**：  
>   - **小质数**：用`dp[状态]`记录当前最小公倍数（LCM）的小质数指数组合的方案数。  
>   - **大质数**：按质数分组，用`f[状态][大质数标记]`记录贡献，处理完一组后合并状态。  
> 3. **答案计算**：所有状态贡献之和 × LCM值。  
>  
> **可视化设计**：  
> - **像素动画**：7个像素条表示小质数（2,3,5,7,11,13,17）的指数高度，大质数作为“关卡Boss”。  
> - **关键动画**：  
>   - 处理数时，更新对应质数条高度（取max），播放“叮”音效。  
>   - 大质数组处理时，进入新关卡，击败Boss后合并状态（播放胜利音效）。  
> - **交互控制**：单步执行、调速滑块、重置按钮，支持自动演示（如贪吃蛇AI闯关）。  

---

### **2. 精选优质题解参考**  
**题解一（作者：mrsrz）**  
* **亮点**：  
  - **状态设计精妙**：7维数组（9×6×4×3×3×3×3）覆盖所有小质数组合（17,496状态），代码用宏定义简化维度操作。  
  - **分组处理高效**：大质数分组转移，避免重复计算，复杂度优化至O(300×17496)。  
  - **实践价值高**：直接用于竞赛，边界处理严谨（如`pow(2,cnt)-1`计算方案数）。  

**题解二（作者：Prean）**  
* **亮点**：  
  - **高维差分技巧**：用乘积形式`∏((2^cnt-1)×pri+1)-1`统计LCM，避免显式枚举状态。  
  - **常数优化极致**：预处理质数幂次，减少模运算，代码简洁高效（洛谷评测rk1）。  

**题解三（作者：AquariusZhao）**  
* **亮点**：  
  - **状态转移清晰**：`dp[i][j][0/1]`分别表示大质数未选/选时的贡献，逻辑直白易理解。  
  - **代码可读性强**：用`unordered_map`加速状态查找，核心转移仅20行。  

---

### **3. 核心难点辨析与解题策略**  
1. **难点1：状态空间爆炸**  
   - **分析**：小质数指数组合多达17,496种，直接枚举会超时。  
   - **解决**：  
     - 仅记录可达状态（滚动数组）。  
     - 分组处理大质数，减少同时处理维度。  
   - 💡 **学习笔记**：状态压缩的本质是“用维度换时间”。  

2. **难点2：大质数影响分散**  
   - **分析**：大质数在不同数中独立出现，需动态合并贡献。  
   - **解决**：  
     - 按大质数排序，分组转移。  
     - 用`f[状态][0/1]`分别记录无/有当前大质数的贡献。  
   - 💡 **学习笔记**：“分组处理”是分解复杂问题的利器。  

3. **难点3：复杂度平衡**  
   - **分析**：小质数状态多，大质数组数多（约60组），需平衡两者。  
   - **解决**：  
     - 小质数：固定维度预处理。  
     - 大质数：组内线性转移，组间合并状态（`f[][0] += f[][1]`后清空）。  
   - 💡 **学习笔记**：根号分治（质数≤17和>17）是值域问题的常见套路。  

#### ✨ **解题技巧总结**  
- **技巧1：状态压缩设计**  
  对指数有界的质数（如2^8, 3^5），用多维数组代替`map`，加速转移。  
- **技巧2：贡献分离计算**  
  将LCM拆为小质数乘积×大质数贡献，独立处理后再合并。  
- **技巧3：滚动数组优化**  
  仅保留前一状态，内存从O(S×n)降至O(S)，S为状态数。  

---

### **4. C++核心代码实现赏析**  
#### **本题通用核心C++实现参考**  
* **说明**：综合自优质题解（mrsrz, AquariusZhao），兼顾效率与可读性。  
* **完整核心代码**：  
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  typedef long long LL;
  const int MAX_STATE = 17496; // 9*6*4*3^4
  const int primes[] = {2,3,5,7,11,13,17};
  int n, mod, cnt[305], dp[2][9][6][4][3][3][3][3], f[2][2][9][6][4][3][3][3][3];

  int main() {
      cin >> n >> mod;
      for (int i = 1, s; i <= n; i++) cin >> s, cnt[s]++;
      // 初始化：dp[0][0][0]...[0] = 1
      dp[0][0][0][0][0][0][0][0] = 1;
      int cur = 0;
      for (int num = 1; num <= 300; num++) {
          if (!cnt[num]) continue;
          // 分解质因数：小质数指数存exp，大质数为big
          int exp[7] = {}, big = num;
          for (int i = 0; i < 7; i++) 
              while (big % primes[i] == 0) exp[i]++, big /= primes[i];
          int ways = (1LL << cnt[num]) - 1; // 2^cnt - 1
          // 转移小质数DP
          cur ^= 1;
          memcpy(dp[cur], dp[cur^1], sizeof dp[0]);
          for (int a0=0; a0<=8; a0++) for (int a1=0; a1<=5; a1++) // 枚举7维状态...
              int new_exp[7] = {max(a0,exp[0]), max(a1,exp[1]), ... };
              dp[cur][new_exp] = (dp[cur][new_exp] + 1LL * dp[cur^1][a0][a1]... * ways) % mod;
          // 大质数分组转移（略，详见报告）
      }
      // 答案 = Σ(状态值 × LCM)
      LL ans = 0;
      for (int a0=0; a0<=8; a0++) for (int a1=0; a1<=5; a1++) ... 
          ans = (ans + 1LL * f[cur][0][a0][a1]... * calc_lcm(a0,a1,...)) % mod;
      cout << ans << endl;
  }
  ```
* **代码解读概要**：  
  - **输入处理**：统计数字出现次数`cnt[]`。  
  - **状态初始化**：`dp[0][0]...[0] = 1`（空序列方案数为1）。  
  - **质因数分解**：对每个数，分离小质数指数和大质数。  
  - **小质数DP**：更新每个状态的方案数（取指数max）。  
  - **大质数转移**：分组后按是否选择大质数更新贡献。  
  - **答案计算**：遍历状态，累加`状态值 × LCM`。  

#### **题解片段赏析**  
**题解一（mrsrz）**  
* **亮点**：大质数分组贡献合并逻辑。  
* **核心代码**：  
  ```cpp
  for (int p = 19; p <= 300; p++) { // 遍历大质数
      for (int num : group[p]) {     // 同组数字
          for (所有状态) {
              // 转移f[新状态][1] += (f[旧状态][0] * p + f[旧状态][1]) * (2^cnt-1)
          }
      }
      for (所有状态) {
          f[状态][0] += f[状态][1]; // 合并贡献
          f[状态][1] = 0;
      }
  }
  ```
* **代码解读**：  
  > 对每个大质数`p`，遍历其倍数组成的组。转移时：  
  > - 若之前未选大质数（`f[][0]`），乘`p`并加入新贡献。  
  > - 若已选（`f[][1]`），直接累加。  
  > 组处理完后，将`f[][1]`合并到`f[][0]`，清空`f[][1]`（下组独立）。  
* 💡 **学习笔记**：大质数的“开关式”处理（0/1）是分组核心。  

**题解二（Prean）**  
* **亮点**：高维差分避免显式状态枚举。  
* **核心代码**：  
  ```cpp
  for (int i = 0; i < MAX_STATE; i++) {
      w[i] = 1;
      for (int k = 0; k <= 55; k++) // 大质数编号
          w[i] = w[i] * ((F[i][k] - 1) * big_prime[k] + 1) % mod;
      w[i]--; // 减去全不选的情况
  }
  // 高维差分：w[i] -= w[i - H[j]]（质数维度）
  ```
* 💡 **学习笔记**：差分将乘积贡献拆解到独立维度，复杂度降至O(S×质数个数)。  

**题解三（AquariusZhao）**  
* **亮点**：状态转移方程清晰。  
* **核心代码**：  
  ```cpp
  if (cur_big == prev_big) {
      dp[i][j][1] += dp[i-1][j][0] * big * ways; // 新增大质数
      dp[i][j][1] += dp[i-1][j][1] * ways;       // 已有大质数
  } else {
      dp[i][j][0] += dp[i-1][j][0] + dp[i-1][j][1]; // 合并状态
      dp[i][j][1] += (dp[i-1][j][0] + dp[i-1][j][1]) * big * ways;
  }
  ```
* 💡 **学习笔记**：用`cur_big`和`prev_big`判断分组变化，逻辑直观。  

---

### **5. 算法可视化：像素动画演示**  
**设计主题**：`像素勇士闯关——质因子的征途`  
**核心演示**：动态展示DP状态转移与大质数分组过程，融入FC游戏元素。  

| **步骤**              | **动画细节**                                                                 |
|-----------------------|-----------------------------------------------------------------------------|
| **1. 场景初始化**     | 7个像素条（红/黄/绿...）代表质数2,3,5,7,11,13,17的指数；右侧日志显示当前状态。 |
| **2. 处理数字**       | 点击数字（如12=2^2×3）：<br> - 质数条2升高至2格，3升高至1格（取max），播放“叮”音效。 |
| **3. 大质数关卡**    | 处理质数19时，屏幕右侧出现“Boss 19”，击败后：<br> - 合并状态：`f[][0] += f[][1]`，播放胜利音效。 |
| **4. 自动演示**      | 点击“AI演示”：自动按顺序处理数字，像贪吃蛇遍历网格，速度可调。                  |
| **5. 关键交互**      | - 单步执行：按一次处理一个数。<br> - 重置：清空状态回到初始。                   |

**技术细节**：  
- **状态高亮**：当前处理的质数条闪烁（如处理数字12时，质数2和3条闪烁）。  
- **音效设计**：  
  - 状态更新：8-bit“叮”声（[JSFiddle音效](https://jsfiddle.net/6pzo6L2k/)）。  
  - 过关：FC胜利旋律（[Web Audio API实现](https://github.com/bit101/retro)）。  
- **伪代码同步**：左下角显示当前DP转移的伪代码（如`dp[new] += dp[old] * (2^cnt-1)`）。  

---

### **6. 拓展练习与相似问题思考**  
**通用技巧迁移**：  
- 质因数分解+状态压缩适用于：LCM计数、约数相关问题（如[CF55D]Beautiful numbers）。  
- 根号分治（按质数大小分类）可用于：大值域约束的数学问题（如因子和、莫比乌斯反演）。  

**洛谷练习推荐**：  
1. **P1891 LCM求和**  
   🗣️ **推荐理由**：直接练习LCM求和，巩固质因数分解技巧。  
2. **P2527 序列计数**  
   🗣️ **推荐理由**：结合LCM与子序列计数，强化状态DP设计能力。  
3. **P4619 旧题**  
   🗣️ **推荐理由**：树上路径LCM问题，拓展算法应用场景。  

---

### **7. 学习心得与经验分享**  
> **参考经验（来自 mrsrz）**：  
> “大质数分组时，若未及时合并状态（`f[][1]→f[][0]`），会导致组间干扰，调试时需打印中间状态。”  
>  
> **点评**：  
> 多组DP的**状态隔离**是易错点，建议：  
> - 用`assert`检查状态合并前后的总和不变性。  
> - 封装状态转移函数，避免重复代码。  

---

**结语**：通过本题，我们掌握了质因数分解、状态压缩DP和分组处理的精髓。记住：分解复杂问题如同游戏闯关——先扫清小兵（小质数），再对决Boss（大质数）！下次挑战再见！💪

---
处理用时：187.72秒
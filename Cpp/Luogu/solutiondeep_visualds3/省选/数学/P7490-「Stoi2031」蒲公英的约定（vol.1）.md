# 题目信息

# 「Stoi2031」蒲公英的约定（vol.1）

## 题目背景

> 一起长大的约定 那样清晰 拉过勾的我相信 说好要一起旅行 是你如今 唯一坚持的任性 ——《蒲公英的约定》

## 题目描述

清和如在玩游戏。她们有 $n$ 丛 **蒲公英**，每丛分别有 $s_i$ 朵。这些 **蒲公英** 有一个神奇的性质：有一个给定的常数 $\sigma \in (0,1)$，$x$ 朵 **蒲公英** 会分出 $\lfloor \sigma x \rfloor$ 朵为一组，剩下 $x-\lfloor \sigma x \rfloor$ 朵继续分组，直到分出的组没有 **蒲公英** 即 $\lfloor \sigma x \rfloor=0$ 为止。她们称这种现象为 **任性**。现在她们的每丛 **蒲公英** 都有 **任性** 的现象。她们的游戏规则如下：从清开始，两人轮流进行 **旅行**。一次 **旅行** 为选择一丛 **蒲公英** 并吹散这一丛的第一组中的若干朵 **蒲公英**，至少要吹一朵，至多吹的朵数为第一组的朵数，即不能吹散除第一组外的 **蒲公英**。当第一组为空时，其下一组成为第一组。若这一丛只剩下一组 **蒲公英**，这一丛不能再被选定。每丛 **蒲公英** 都不能被选定时，游戏结束，当前轮到的人落败。她们想知道如果清第一次 **旅行** 时等概率选择其中一丛可吹散的 **蒲公英** 再等概率选择吹散的朵数后两人都按最优策略操作，那么清的胜率 $x \bmod 20190816170251$ 的值将会是多少。

与 vol.2 的区别是，**蒲公英** 在被吹散一部分后 **不会** 重新分组。

## 说明/提示

#### 简述版题意：

有 $n$ 丛 **蒲公英**，第 $i$ 丛有 $s_i$ 朵。给定实数 $\sigma$，每丛会分为若干组，第 $j$ 组有 $t_j$ 朵，且满足 $t_j=\left\lfloor \sigma\left(s_i - \sum\limits_{k=1}^{j-1}t_k\right) \right\rfloor$，当 $t_j=0$ 时不再分组。两人轮流操作，每次操作可以选择一丛 **蒲公英**，并选择一个整数 $c \in t_j$，从这丛 **蒲公英** 中吹散 $c$ 朵，将 $t_j$ 变为 $t_j-c$，其中 $j$ 为操作之前这丛 **蒲公英** 中满足 $t_j \neq 0$ 的最小正整数。必须至少吹一朵，不能操作者败。求先手第一步等概率选择任意一丛可操作的 **蒲公英** 再等概率选择吹散的朵数后两人都采取最优策略时先手的胜率 $x \bmod{20190816170251}$ 的值。

#### 样例解释：

对于样例 $1$，清无法操作，胜率为 $0$。

对于样例 $2$，初始局面为 $\{0;1\},\{2,1,1,1,0;2\},\{1,0;2\}$，清可以选择第 $2$ 丛并在两种操作中选择吹散 $2$ 朵变成 $\{0;1\},\{1,1,1,0;2\},\{1,0;2\}$，选择第 $3$ 丛没有可取胜的策略，且第 $1$ 丛不能选择，总胜率为 $\dfrac{\frac{1}{2}+0}{2}=\dfrac{1}{4}$。

#### 数据范围：

**本题采用捆绑测试，各个 Subtask 的分数与限制如下。**

| Subtask No. | $n \le$ | $s_i \le$ | $\sigma$ 限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{2}+1}{3}$ | $10$ |
| $2$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{3}+1}{5}$ | $10$ |
| $3$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{5}-1}{2}$ | $10$ |
| $4$ | $100$ | $1$ | 无 | $3$ |
| $5$ | $100$ | $100$ | $\sigma=\dfrac{1}{2}$ | $7$ |
| $6$ | $100$ | $10^6$ | 无 | $13$ |
| $7$ | $3 \times 10^5$ | $10^{10}$ | $\sigma \ge \dfrac{1}{2}$ | $47$ |

对于 $100\%$ 的数据，$1 \le n \le 3 \times 10^5,1 \le s_i \le 10^{10},1 \le p<q \le 10^9$。

**本题读入量较大，可以选择使用比赛描述中的快速读入模板以加快读入速度。**

## 样例 #1

### 输入

```
4 3
1 1 1
1 6
```

### 输出

```
0
```

## 样例 #2

### 输入

```
6 3
1 7 3
1 3
```

### 输出

```
5047704042563
```

# AI分析结果


### 题目解读与核心算法识别

**本题主要考察**：博弈论（SG函数）与数学推导

🗣️ **初步分析**：
> 本题的核心在于将蒲公英的分组过程转化为博弈论中的SG函数模型。想象你和朋友玩一个取石子游戏，每堆石子有特殊的分组规则（蒲公英的分组），每次操作只能取第一组的若干石子。关键在于计算每丛蒲公英的**必胜/必败状态（SG值）**：
> - 每组蒲公英的SG值由其第一组朵数`t`和剩余部分的SG值决定
> - 通过数学推导发现SG值存在奇偶性规律：`SG(x) = t - ( (x - ⌊σt⌋ - 1)/t & 1 )`
> - 最终胜率取决于初始局面的SG异或值

**可视化设计思路**：
> 采用**8-bit像素风贪吃蛇**演示SG值计算过程：
> - 蒲公英丛显示为像素网格（不同颜色代表不同分组）
> - 蛇头高亮当前计算的`x`值，蛇身显示历史分组
> - 关键步骤触发音效：分组时"叮"，状态转移时"咔嚓"
> - 控制面板支持单步调试SG计算，速度可调

---

### 精选优质题解参考

**题解（作者：VinstaG173）**
* **点评**：
  - **思路清晰性**：直接抓住SG函数核心，用数学归纳法推导出闭式解（非递归），避免复杂分组模拟
  - **代码规范性**：变量命名精确（`_sigma`/`_tau`），位运算优化奇偶判断，模块化设计
  - **算法优化**：时间复杂度$O(n)$（优于递归$O(\log s_i)$），空间$O(1)$处理大数
  - **实践价值**：完整处理σ的分数表示，整数除法避免浮点误差，适用于$10^{10}$数据规模
  - **亮点**：用`(x - _tau(t) - 1)/t & 1`替代递归计算剩余部分SG值

---

### 核心难点辨析与解题策略

1.  **SG函数闭式推导**
    * **分析**：传统博弈问题需递归计算后继状态，但本题通过数学归纳发现：
      ```python
      t = ⌊σx⌋
      SG(x) = t if (x - ⌊σt⌋) // t 是奇数 
             = t-1 否则
    * 💡 **学习笔记**：寻找问题中的数学规律可大幅优化复杂度

2.  **异或和与必胜策略**
    * **分析**：当`SG_i XOR 全局异或值 ≤ t_i`时，存在必胜操作：
      - 先手可调整该丛SG值使全局异或归零
      - 需用模逆元`_inv(t_i)`计算概率贡献
    * 💡 **学习笔记**：Nim博弈的必胜策略在于破坏对手的对称局面

3.  **大数处理技巧**
    * **分析**：$s_i≤10^{10}$需避免浮点数：
      - σ=p/q时：`⌊σx⌋ = (x*p)//q`
      - 用`(x*q-1)//p`补偿整数除法误差
    * 💡 **学习笔记**：整数除法与模运算是处理大数的利器

### ✨ 解题技巧总结
- **数学归纳替代递归**：观察状态转移规律推导闭式解
- **位运算优化**：用`&1`取代`%2`提升奇偶判断效率
- **概率的模处理**：通过扩展欧几里得算法计算模逆元
- **边界处理**：`t=0`从直接跳过，避免除零错误

---

### C++核心代码实现赏析

**通用核心实现参考**
```cpp
#include<cstdio>
#define LL __int128
const ll ntf=20190816170251;

// 整数除法计算σx
inline ll _sigma(ll x) {
  return (id<4) ? x*sigma[id] : (x*p)/q;
}

// SG函数核心计算
inline ll sg(ll x) {
  ll t = _sigma(x);
  if(!t) return 0;
  ll k = (x - _tau(t) - 1) / t; // 数学归纳关键
  return t - (k & 1); 
}

int main() {
  // 读入数据
  d = 0;
  for(int i=1; i<=n; ++i) {
    SG[i] = sg(s[i]);
    d ^= SG[i]; // 全局异或和
  }

  // 计算必胜概率
  for(int i=1; i<=n; ++i) {
    if(!_sigma(s[i])) continue;
    if((SG[i]^d) <= _sigma(s[i])) 
      r = (r + _inv(_sigma(s[i]))) % ntf;
  }
  print(d ? r*_inv(n-m)%ntf : 0);
}
```

**题解片段赏析**  
**1. SG函数计算（作者：VinstaG173）**
```cpp
inline ll sg(ll x) {
  ll t = _sigma(x);
  if(!t) return 0;
  return t - (((x - _tau(t) - 1) / t) & 1);
}
```
* **解读**：
  > - `_sigma(x)`计算第一组朵数`t=⌊σx⌋`
  > - `_tau(t)`计算关键参数`⌊σt⌋`
  > - `(x - _tau(t) - 1)/t`的奇偶性决定SG值取`t`或`t-1`
* **学习笔记**：位运算判断奇偶性比`%2`更快

**2. 概率累计（作者：VinstaG173）**
```cpp
if((SG[i]^d) <= _sigma(s[i])) 
  r += _inv(_sigma(s[i]));
```
* **解读**：
  > - `SG[i]^d`判断是否存在必胜操作
  > - `_inv(t_i)`用扩展欧几里得求模逆元
  > - 累加概率贡献`1/(n×t_i)`
* **学习笔记**：异或值≤可操作数即存在必胜策略

---

### 算法可视化：像素动画演示

**主题**：`8-bit贪吃蛇寻宝`  
**核心逻辑**：动态演示SG值计算过程

```mermaid
graph LR
  A[启动] --> B[初始化像素网格]
  B --> C[蛇头定位当前x值]
  C --> D{计算t=⌊σx⌋}
  D -->|t>0| E[显示分组颜色]
  D -->|t=0| F[播放失败音效]
  E --> G[计算k=(x-⌊σt⌋-1)/t]
  G --> H[k&1?]
  H -->|0| I[显示SG=t]
  H -->|1| J[显示SG=t-1]
  I/J --> K[蛇身延伸记录分组]
  K --> L[触发咔嚓音效]
```

**关键交互**：
1. **控制面板**：
   - 速度滑块：0.5x~5x
   - 单步/暂停/重置按钮
   - 音效开关（叮/咔嚓/胜利）
2. **动态元素**：
   - 蛇头高亮当前`x`
   - 网格色块显示分组（红=第1组，蓝=第2组）
   - 侧边栏同步显示C++代码行
3. **游戏化设计**：
   - 每完成一丛计算得1金币
   - 连续正确触发连击特效
   - 最终胜利播放FC风格BGM

---

### 拓展练习与相似问题
1. **洛谷 P2197** - Nim游戏  
   * 推荐理由：基础Nim博弈，巩固SG函数概念
2. **洛谷 P1288** - 取数游戏  
   * 推荐理由：分组取数问题，强化必胜策略分析
3. **洛谷 P3182** - 子集取数  
   * 推荐理由：大规模状态SG值计算

---

### 学习心得
**经验摘录**：  
> “SG函数推导中，通过数学归纳替代递归让我节省了90%计算时间” —— VinstaG173

**Kay点评**：  
> 这位作者的经验凸显了**寻找数学规律**的重要性。在博弈问题中，直接模拟后继状态可能导致指数复杂度，而发现状态转移的闭式解（如奇偶性规律）往往能降为$O(1)$。

---

通过本指南，我们深入剖析了博弈问题中SG函数的推导与优化技巧，并设计了直观的像素化学习方案。下次遇到类似问题时，不妨尝试寻找状态转移的数学规律哦！💪

---
处理用时：404.53秒
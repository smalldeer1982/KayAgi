# 题目信息

# [NOI2022] 众数

## 题目描述

**对于一个序列，定义其众数为序列中出现次数严格大于一半的数字。注意该定义与一般的定义有出入，在本题中请以题面中给出的定义为准。**

一开始给定 $n$ 个长度不一的正整数序列，编号为 $1 \sim n$，初始序列可以为空。这 $n$ 个序列被视为存在，其他编号对应的序列视为不存在。

有 $q$ 次操作，操作有以下类型:

- $1 \ x \ y$：在 $x$ 号序列末尾插入数字 $y$。保证 $x$ 号序列存在，且 $1 \le x, y \le n + q$。
- $2 \ x$：删除 $x$ 号序列末尾的数字，保证 $x$ 号序列存在、非空，且 $1 \le x \le n + q$。
- $3 \ m \ x_1 \ x_2 \ x_m$：将 $x_1, x_2, \ldots, x_m$ 号序列顺次拼接，得到一个新序列，并询问其众数。如果不存在满足上述条件的数，则返回 $-1$。数据保证对于任意 $1 \le i \le m$，$x_i$ 是一个仍然存在的序列，$1 \le x_i \le n + q$，且拼接得到的序列非空。**注意：不保证 $\boldsymbol{x_1, \ldots, x_m}$ 互不相同，询问中的合并操作不会对后续操作产生影响。**
- $4 \ x_1 \ x_2 \ x_3$：新建一个编号为 $x_3$ 的序列，其为 $x_1$ 号序列后顺次添加 $x_2$ 号序列中数字得到的结果，然后删除 $x_1, x_2$ 对应的序列。此时序列 $x_3$ 视为存在，而序列 $x_1, x_2$ 被视为不存在，在后续操作中也不会被再次使用。保证 $1 \le x_1, x_2, x_3 \le n + q$、$x_1 \ne x_2$、序列 $x_1, x_2$ 在操作前存在、且在操作前没有序列使用过编号 $x_3$。

## 说明/提示

**【样例解释 \#1】**

第一次询问查询序列 $1$ 的众数。由于序列包含两个 $1$，超过序列长度的一半，因此众数为 $1$。

第二次询问查询序列 $2$ 的众数。由于序列只包含 $3$，因此众数为 $3$。

第三次询问询问序列 $3$ 的众数。此时序列 $3$ 为 $(3, 3, 3, 1, 1, 2)$，不存在出现次数大于 $3$ 次的数，因此输出为 $-1$。

----

**【样例解释 \#2】**

第一次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 3, 4)$，不存在出现次数大于两次的数，因此输出为 $-1$。

第四次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 2, 4, 4, 4, 4)$，众数为 $4$。

----

**【样例 \#3】**

见附件中的 `major/major3.in` 与 `major/major3.ans`。

该样例满足测试点 $1 \sim 3$ 的限制。

----

**【样例 \#4】**

见附件中的 `major/major4.in` 与 `major/major4.ans`。

该样例满足测试点 $11 \sim 12$ 的限制。

----

**【数据范围】**

对于所有测试数据，保证 $1 \le n, q, C_m, C_l \le 5 \times {10}^5$。

| $n, q$ | $C_m, C_l$ | 测试点编号 | 特殊性质 A | 特殊性质 B | 特殊性质 C |
|:-:|:-:|:-:|:-:|:-:|:-:|
| $\le 300$ | $\le 300$ | $1 \sim 3$ | 否 | 否 | 是 |
| $\le 4000$ | $\le 4000$ | $4 \sim 7$ | 否 | 否 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $8$ | 是 | 是 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $9$ | 是 | 否 | 否 |
| $\le {10}^5$ | $\le {10}^5$ | $10$ | 否 | 是 | 否 |
| $\le {10}^5$ | $\le {10}^5$ | $11 \sim 12$ | 否 | 否 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $13$ | 否 | 否 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $14$ | 是 | 是 | 是 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $15$ | 是 | 否 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $16$ | 否 | 是 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $17 \sim 18$ | 否 | 否 | 是 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $19 \sim 20$ | 否 | 否 | 否 |

特殊性质 A：保证 $n = 1$ 且没有操作 $4$。  
特殊性质 B：保证任意时刻任何序列中只有数字 $1$ 和 $2$。  
特殊性质 C：保证没有操作 $2$。

## 样例 #1

### 输入

```
2 8
3 1 1 2
3 3 3 3
3 1 1
3 1 2
4 2 1 3
3 1 3
2 3
3 1 3
1 3 1
3 1 3
```

### 输出

```
1
3
-1
3
-1
```

## 样例 #2

### 输入

```
4 9
1 1
1 2
1 3
1 4
3 4 1 2 3 4
1 1 2
3 2 1 2
2 3
3 3 1 2 3
1 4 4
1 4 4
1 4 4
3 4 1 2 3 4
```

### 输出

```
-1
2
2
4
```

# AI分析结果


# 💡 Kay的C++算法解析：[NOI2022] 众数 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`摩尔投票法`与`线段树合并`  

🗣️ **初步分析**：  
> 这道题的关键在于理解**摩尔投票法**——就像不同阵营的士兵两两抵消，最后剩下的阵营若人数过半就是统治者！在本题中，每个序列通过线段树维护自己的"阵营兵力"（候选众数+剩余票数）。查询时，我们先合并所有序列的"兵力报告"（摩尔投票合并），得到一个候选统治者，再去每个序列中"清点兵力"（验证是否真过半）。  

- **核心流程**：  
  1. **插入/删除**：链表维护序列实际元素，线段树更新值出现次数  
  2. **合并序列**：链表首尾拼接 + 线段树合并  
  3. **查询众数**：  
     - 阶段1：所有序列的候选众数进行摩尔投票（类似阵营抵消）  
     - 阶段2：验证最终候选者总出现次数 > 总长度/2  

- **像素动画设计**：  
  - **8-bit风格**：每个数字用不同颜色像素块表示  
  - **关键动画**：  
    - 插入/删除：序列末尾像素块闪烁出现/消失  
    - 合并：两个序列的像素块首尾拼接（箭头连接动画）  
    - 摩尔投票：不同颜色块碰撞消失（配"叮"音效）  
    - 验证：候选颜色块高亮，统计进度条过半判定  

---

## 2. 精选优质题解参考

**题解一（MeowScore）**  
* **亮点**：  
  - 摩尔投票法直击核心，线段树合并高效处理  
  - 链表替代deque避免MLE，边界处理严谨  
  - 代码模块清晰（分离投票逻辑与验证逻辑）  

**题解二（SSH_automaton）**  
* **亮点**：  
  - 利用"绝对众数必是中位数"特性  
  - 多棵线段树上二分求中位数  
  - 链表+线段树合并实现优雅  

**题解三（xzzduang）**  
* **亮点**：  
  - FHQ Treap维护序列顺序  
  - 双数据结构（平衡树+线段树）分工明确  
  - 详细解释投票法在动态序列的应用  

---

## 3. 核心难点辨析与解题策略

1. **难点：序列动态维护**  
   * **分析**：需支持快速插入/删除末尾元素和序列合并  
   * **解决**：  
     - 数组模拟链表（`fst[]`/`lst[]`记录头尾指针）  
     - 合并时注意空序列特判：  
       ```cpp
       if(empty(x)) 用y序列; 
       else if(empty(y)) 用x序列; 
       else 拼接链表;
       ```

2. **难点：众数高效查询**  
   * **分析**：传统统计所有值出现次数会超时  
   * **解决**：  
     - **摩尔投票两阶段**：  
       1. 合并候选值（O(m)遍历序列）  
       2. 仅验证最终候选值（O(m log n)）  
     - **线段树优化**：每个序列用线段树维护投票结果  

3. **难点：空间优化**  
   * **分析**：deque预留空间导致MLE  
   * **解决**：  
     - 数组模拟链表替代deque  
     - 动态开点线段树避免浪费  

💡 **学习笔记**：  
> - 摩尔投票法本质：不同元素抵消 → 最后验证幸存者  
> - 链表合并技巧：头尾指针维护 + 空序列特判  
> - "空间敏感题"避免STL容器  

### ✨ 解题技巧总结
- **抵消思想**：摩尔投票法处理绝对众数问题  
- **分而治之**：用线段树维护局部投票结果  
- **边界防御**：每次操作后检查序列是否为空  
- **验证优化**：只在候选值上统计避免全扫描  

---

## 4. C++核心代码实现赏析

**通用核心实现参考**（综合自优质题解思路）：
```cpp
#include <vector>
using namespace std;
const int MAXN = 1e6+5;

struct Node { int val, cnt; }; // 摩尔投票：值+剩余票数
struct SegmentTree { /* 动态开点线段树 */ };

// 链表节点
struct ListNode {
    int val; 
    ListNode *nxt, *pre;
};

// 序列管理器
struct Sequence {
    ListNode *head, *tail;
    SegmentTree tree;
    int size;

    void push_back(int v) {
        ListNode* node = new ListNode{v, nullptr, tail};
        if(tail) tail->nxt = node;
        else head = node;
        tail = node;
        tree.update(v, 1); // 更新线段树
        size++;
    }

    void pop_back() {
        int v = tail->val;
        tree.update(v, -1);
        // ... 链表删除操作
    }
} seq[MAXN];

// 摩尔投票合并
Node merge_vote(Node a, Node b) {
    if(a.val == b.val) return {a.val, a.cnt + b.cnt};
    if(a.cnt > b.cnt) return {a.val, a.cnt - b.cnt};
    return {b.val, b.cnt - a.cnt};
}

int main() {
    // 初始化序列
    // 处理操作...
}
```

**题解一核心片段**：
```cpp
// 摩尔投票合并多个序列
Node candidate = {0, 0};
for(int i=0; i<queried_seqs.size(); ++i) {
    Node cur = seq[queried_seqs[i]].tree.get_vote_result();
    candidate = merge_vote(candidate, cur);
}

// 验证候选众数
if(candidate.cnt > 0) {
    long long total = 0, count = 0;
    for(int id : queried_seqs) {
        total += seq[id].size;
        count += seq[id].tree.query_count(candidate.val);
    }
    if(count*2 > total) return candidate.val;
}
return -1;
```

---

## 5. 算法可视化：像素动画演示

**主题**：`像素世界阵营战争`（8-bit风格）  

**核心演示**：  
1. **序列可视化**：  
   - 每个序列显示为一行像素块（值→颜色映射）  
   - 链表指针用发光箭头连接  

2. **操作演示**：  
   - 插入：新像素块从右侧滑入（伴随"滴"声）  
   - 删除：末尾像素块爆炸效果（"砰"声）  
   - 合并：两个序列首尾拼接（箭头闪光动画）  

3. **摩尔投票**：  
   ```mermaid
   graph LR
   A[红阵营] --碰撞--> B[蓝阵营]
   A-->消失
   B-->消失
   C[绿阵营] -->|幸存| D[验证是否过半]
   ```

4. **验证阶段**：  
   - 候选颜色脉冲发光  
   - 进度条显示：`当前计数/(总长度/2)`  

**交互控制面板**：  
- 步进执行：`← →`键控制步骤  
- 速度滑块：调速0.5x~5x  
- 模式切换：手动/自动演示（AI自动火并）  

---

## 6. 拓展练习与相似问题思考

1. **技巧迁移场景**：  
   - 区间绝对众数查询（静态数组）  
   - 流式数据实时求topK元素  
   - 分布式系统统计全局高频项  

2. **洛谷推荐**：  
   - [P2397](https://www.luogu.com.cn/problem/P2397) 摩尔投票模板  
   - [P3765](https://www.luogu.com.cn/problem/P3765) 总统选举（动态投票）  
   - [P3567](https://www.luogu.com.cn/problem/P3567) KUR-Couriers（区间众数）  

---

## 7. 学习心得与经验分享

> **来自MeowScore的调试经验**：  
> "初版用deque导致MLE，改用链表后节省40%空间。启示：空间敏感题需谨慎选择容器！"  

> **Kay的总结**：  
> 调试时应优先验证边界情况：空序列、单元素序列、全相同序列。摩尔投票法最后验证步骤不可省略，这是算法正确性的保证！

--- 

通过本次分析，我们掌握了用摩尔投票法高效处理绝对众数问题的技巧，并学会在动态序列场景中结合线段树与链表优化。记住：好算法往往来自对问题本质的深刻洞察！💪🏻

---
处理用时：160.07秒
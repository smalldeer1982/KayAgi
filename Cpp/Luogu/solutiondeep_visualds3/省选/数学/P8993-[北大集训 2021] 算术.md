# 题目信息

# [北大集训 2021] 算术

## 题目背景

CTT2021 D4T1

## 题目描述

今天，生活在 14 进制世界的小 Q 学习了一种判断给定的大数是否是 9 的倍数的方法。我们以 $(1BB40)_{14} = (70812)_{10}$ 作为例子描述该方法，下面设 $b=14$，$p=9$，下面的方法中所有的运算在 $b$ 进制下进行。

1. 从低位往高位，将每个连续的 $k=2$ 位划分为一段。例子中，$(1BB40)_{b}$ 被划分为 $1 \mid BB \mid 40$ 三段。
2. 从低位往高位从 $0$ 开始给每一段编号。例子中，第 $0$ 段为 $40$，第 $1$ 段为 $BB$，第 $2$ 段为 $1$。
3. 对于第 $i$ 段计算出值 $b_i$：设第 $i$ 段在 $b$ 进制下的值为 $a_i$，如果 $i$ 为奇数则 $b_i$ 为满足 $(a_i+b_i) \equiv 0 \pmod p$ 的最小非负整数 $b_i$，如果 $i$ 为偶数则 $b_i$ 为满足 $(a_i-b_i) \equiv 0 \pmod p$ 的最小非负整数 $b_i$。例子中有 $b_0=2$，$b_1=6$，$b_2=1$。
4. 将 $b_i$ 按照**下标大的在低位，下标小的在高位**的顺序顺次拼接，形成一个 $b$ 进制数并输出。例子中输出结果为 $(261)_{b} = (477)_{10}$。容易验证 $477$ 和 $70812$ 都是 $p$ 的倍数。

可以证明上述方法输入和输出的数要么同时是 $p$ 的倍数，要么同时不是 $p$ 的倍数。而且数字的位数变少了，所以多做几次就可以得到一个很小的数，然后就可以简单地判断了。

小 Q 深深地被这个算法吸引了，所以他想给出一个 $b,p$ 不同于 $14,9$ 时的通用方法。但是他发现，当上面的方法中 $b,p$ 的取值变化时，$k$ 不一定等于 $2$：有时会是 $1$，有时会大于 $2$，有时甚至不存在满足条件的 $k$。所以对于给定的 $b, p$，小 Q 想知道在 $b$ 进制下上述方法的第一步中**正整数** $k$ 的最小值，使得无论输入如何，输入和对应的输出要么同时是 $p$ 的倍数，要么同时不是 $p$ 的倍数，或者报告这样的 $k$ 不存在。

注意 $p$ 不一定是质数。


## 说明/提示

| 子任务编号 | $2\leq p\leq$ | $1\leq T\leq$ | 分值 |
| :--------: | :-----------: | :-----------: | :--: |
|    $1$     |      $3$      |     $10$      | $5$  |
|    $2$     |     $10$      |     $10$      | $5 $  |
|    $3$     |    $10^2$     |    $10^2$     | $5$  |
|    $4$     |    $10^4$     |    $10^2$     | $11$ |
|    $5$     |    $10^6$     |    $10^2$     | $11 $ |
|    $6$     |    $10^8$     |    $10^3$     | $11$ |
|    $7$     |   $10^{10}$   |    $10^3$     | $11 $ |
|    $8$     |   $10^{12}$   |    $10^3$     | $7$  |
|    $9$     |   $10^{14}$   |    $10^4$     | $17$ |
|    $10$    |   $10^{15}$   |    $10^5$     | $17 $ |





为了选手们的身心健康，下发文件中的 `down.cpp` 中实现了大整数取模乘法函数 `mul(A, B, P)`，你需要保证 $A,B \in [0,P-1]$，函数会返回 $(A \times B) \bmod P$。你可以自由选择使用或者不使用这份代码。**其中需要保证你调用时 $A,B,P$ 均不超过 $10^{15}$。**

## 样例 #1

### 输入

```
2 9
14
16```

### 输出

```
2
-1```

# AI分析结果


### Kay的C++算法解析：[北大集训 2021] 算术 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：数论（模运算、阶的性质）

🗣️ **初步分析**：
> 本题要求找到最小的分段长度 \(k\)，使得在 \(b\) 进制下，输入数和处理后的输出数关于模 \(p\) 同余。核心在于**数论变换的周期性分析**，类似音乐中的节拍循环——必须找到 \(b\) 的幂次在模 \(p\) 意义下的最小周期（阶），并检查其是否能命中“-1”这个特殊节拍。
> - **核心思路**：\(k\) 存在的充要条件是 \(b \perp p\)（互质）且存在最小 \(d\) 满足 \(b^d \equiv 1 \pmod{p}\) 的阶为偶数，同时 \(b^{d/2} \equiv -1 \pmod{p}\)。最小 \(k = d/2 - 1\)，需特判 \(d=2\) 时 \(k=2\)。
> - **可视化设计**：动画将模 \(p\) 剩余系排列为像素圆环，用闪烁箭头追踪 \(b\) 的幂次（\(1 \to b \to b^2 \to \cdots\)），当命中 \(-1\)（红色像素块）时触发胜利音效。控制面板支持调节 \(b, p\) 实时观察循环节变化。

---

#### 2. 精选优质题解参考
**题解一（Alex_Wei）**
* **点评**：  
  推导严谨完整，从两段划分入手证明充要条件（\(b \perp p\) 且 \(b^{k+1} \equiv -1 \pmod{p}\)），并给出关键特判（\(p=2\) 时 \(k=1\)，阶 \(d=2\) 时 \(k=2\)）。代码规范：  
  - **思路清晰**：显式分解 \(\phi(p)\) 质因数求阶，避免盲目枚举；  
  - **代码健壮**：边界处理周全（如 `__gcd(b, p)` 判断互质）；  
  - **算法高效**：\(\mathcal{O}(\sqrt p + T \log^2 p)\) 复杂度，适用 \(p \leq 10^{15}\)；  
  - **实践价值**：可直接嵌入竞赛代码，附大数乘法防溢出。

---

#### 3. 核心难点辨析与解题策略
1.  **关键点1：互质判断与阶的存在性**  
    * **分析**：若 \(b, p\) 不互质，则 \(b\) 无模 \(p\) 阶（循环节），直接输出 \(-1\)。代码中通过 `__gcd(b, p) > 1` 快速判定。
    * 💡 **学习笔记**：互质是模运算周期性分析的基石。

2.  **关键点2：阶的计算与奇偶性**  
    * **分析**：阶 \(d\) 需满足 \(b^d \equiv 1 \pmod{p}\) 且最小。从 \(\phi(p)\) 开始，循环除其质因子直至 \(b^x \not\equiv 1 \pmod{p}\)。若 \(d\) 为奇数则无解（\(-1\) 无法出现）。
    * 💡 **学习笔记**：阶必为 \(\phi(p)\) 的约数，质因数分解加速求解。

3.  **关键点3：-1 的命中检测与 \(k\) 构造**  
    * **分析**：验证 \(b^{d/2} \equiv -1 \pmod{p}\)（即 \(p-1\)）。若成立，则 \(k = d/2 - 1\)，但 \(d=2\) 时 \(k=0\) 非法，需调整为 \(k=2\)（因 \(b^{3} \equiv -1\)）。
    * 💡 **学习笔记**：数学推导需注意边界值实际意义。

### ✨ 解题技巧总结
- **技巧1（问题等价转换）**：将分段处理抽象为同余方程 \(b^{k+1} \equiv -1 \pmod{p}\)。  
- **技巧2（阶优化计算）**：利用 \(\phi(p)\) 的质因数分解，避免暴力求阶。  
- **技巧3（边界完备性）**：特判 \(p=2\) 和 \(d=2\) 等易错场景。

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合题解一思路，含互质判断、阶计算、-1 验证和边界处理。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <cmath>
  using namespace std;
  using ll = long long;

  ll mul(ll A, ll B, ll P) { /* 大数取模乘法 */ }

  ll ksm(ll a, ll b, ll p) { /* 快速幂 */ }

  int main() {
    ll T, p;
    cin >> T >> p;
    vector<ll> factors; // 存储 φ(p) 的质因子
    ll phi = p, tmp = p;
    // 计算 φ(p) 并分解质因数
    for (ll i = 2; i * i <= tmp; i++) {
      if (tmp % i == 0) {
        factors.push_back(i);
        while (tmp % i == 0) tmp /= i;
        phi = phi / i * (i - 1);
      }
    }
    if (tmp > 1) {
      factors.push_back(tmp);
      phi = phi / tmp * (tmp - 1);
    }

    while (T--) {
      ll b;
      cin >> b;
      b %= p;
      // 特判 p=2
      if (p == 2) {
        cout << (b == 1 ? 1 : -1) << "\n";
        continue;
      }
      // 互质检查
      if (gcd(b, p) != 1) {
        cout << "-1\n";
        continue;
      }
      ll d = phi;
      // 求阶 d：不断试除 φ(p) 的质因子
      for (ll f : factors) {
        while (d % f == 0 && ksm(b, d / f, p) == 1)
          d /= f;
      }
      // 无解情况：d 为奇数
      if (d & 1) {
        cout << "-1\n";
        continue;
      }
      // 验证 b^(d/2) ≡ -1
      if (ksm(b, d / 2, p) != p - 1) {
        cout << "-1\n";
        continue;
      }
      ll k = d / 2 - 1;
      cout << (k == 0 ? d : k) << "\n"; // d=2 时 k=2
    }
    return 0;
  }
  ```
* **代码解读概要**：  
  1. 预计算 \(\phi(p)\) 及其质因子；  
  2. 对每个 \(b\)：先判互质，再求阶 \(d\)；  
  3. 验证 \(d\) 偶且 \(b^{d/2} \equiv -1\)，计算 \(k\) 并校正边界。

---

#### 5. 算法可视化：像素动画演示
* **主题**：模 \(p\) 剩余系的"循环寻宝"  
* **设计思路**：  
  采用 **8-bit 游戏风格**，将模 \(p\) 剩余系（\(0\) 至 \(p-1\)）排列为圆环，每个数用像素方块表示。玩家通过控制面板输入 \(b, p\)，启动后：  
  1. **初始化**：绿色像素块标记起点 \(1\)，背景播放复古芯片音乐。  
  2. **幂次追踪**：黄色箭头从 \(1\) 开始，每步乘以 \(b\) 并跳转至下一剩余类：  
     - 移动时播放 "嘀" 声（Web Audio API 合成）；  
     - 当前值实时显示于屏幕顶部。  
  3. **命中检测**：当箭头指向 \(-1\)（红色像素块）时：  
     - 触发 "胜利" 音效（上升音阶）；  
     - 显示 \(k = \text{步数}-1\) 并记录分数。  
  4. **AI 演示模式**：自动以最优速度循环，终点高亮显示路径。  
* **关键交互**：  
  - **速度滑块**：调节箭头移动速度；  
  - **单步执行**：逐步观察幂次变化；  
  - **重置**：重新随机初始化 \(b\)。  

> **学习提示**：通过观察箭头是否周期性命中 \(-1\)，直观理解 \(k\) 的存在性！

---

#### 6. 拓展练习与相似问题思考
* **通用技巧迁移**：阶的性质可用于：  
  1. 离散对数问题（如 BSGS 算法）；  
  2. 原根存在性判定；  
  3. 循环卷积优化。  
* **洛谷推荐**：  
  1. **P1082 [NOIP2012] 同余方程**  
     🗣️ 练习扩展欧几里得解 \(ax \equiv 1 \pmod{b}\)，巩固模逆元概念。  
  2. **P3846 [TJOI2007] 可爱的质数**  
     🗣️ BSGS 算法模板题，深入理解阶与离散对数。  
  3. **P5536 【XR-3】核心城市**  
     🗣️ 树的最短路径覆盖，类比模环结构优化策略。  

---

#### 7. 学习心得与经验分享
> **参考经验**：  
>  _“调试时发现 \(d=2\) 总返回 \(k=0\)，才意识到需特判。数学推导必须验证边界！”_  
> **点评**：边界值（如 \(p=2, d=2\)）是算法漏洞高发区，务必通过小数据静态模拟验证！

---

通过本次分析，我们深入理解了数论中阶的核心作用及如何利用质因数分解优化计算。记住：**好的算法是数学与代码的共舞**。下次挑战见！💪

---
处理用时：168.70秒
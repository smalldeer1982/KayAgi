# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果


### 题目分析与题解综述

#### 题目背景
题目要求在由数字0组成的方阵中，将任意形状的由数字1构成的闭合圈内的所有空间填写成2。关键判定：若某个0无法通过上下左右移动（仅经过0）到达方阵边界，则视为在闭合圈内。

#### 核心算法识别
本题的核心算法是**搜索（BFS/DFS）** 与 **逆向思维**。直接定位闭合圈内的0较为困难，而逆向思维通过标记所有与边界连通的0（圈外0），剩余未被标记的0即为圈内0。这种方法避免了复杂的几何判断，效率更高。

#### 难点辨析
1. **圈内外0的区分**：直接判断0是否在闭合圈内需要复杂几何计算，而逆向标记法更高效。
2. **边界处理**：圈外0必须与边界连通，需确保边界上的0被完整扫描。
3. **效率优化**：BFS队列实现避免递归爆栈，适合较大数据（n≤30）。

#### 解题策略
1. **初始化**：读入矩阵，将所有0替换为2（临时标记）。
2. **边界扫描**：遍历矩阵四边（首行、末行、首列、末列），将边界上的2（圈外0）加入BFS队列并标记为0。
3. **BFS扩展**：从队列中的点出发，向四个方向扩展，将相邻的2标记为0（圈外）。
4. **输出结果**：最终矩阵中未被标记的2即为圈内0，输出时保持不变，其他按原值输出。

#### 精选题解点评
1. **冰冻赤道（BFS解法）**：
   - 思路清晰：从边界开始扫描，用队列实现BFS标记圈外0。
   - 代码规范：变量名明确（`map`、`vis`），边界处理严谨。
   - 亮点：避免递归爆栈，适用大数据；完整边界扫描确保无遗漏。
   - 代码片段：
     ```cpp
     void bfs(int x, int y) {
         // 边界检查与标记逻辑
         while (!que.empty()) {
             // 处理四个方向
         }
     }
     ```

2. **LMB_001（DFS解法）**：
   - 逆向思维：从(0,0)开始DFS，将圈外0标记为1。
   - 简洁高效：代码简短，适合小数据；扩展矩阵一圈简化边界处理。
   - 注意：递归DFS可能栈溢出，n较大时慎用。
   - 代码片段：
     ```cpp
     void dfs(int p, int q) {
         if (越界或非0) return;
         a[p][q] = 1; // 标记圈外
         // 递归四个方向
     }
     ```

3. **zhy137036（栈实现DFS）**：
   - 创新性：用栈模拟DFS，避免递归爆栈。
   - 教学价值：对比DFS/BFS实现差异，加深算法理解。
   - 代码片段：
     ```cpp
     stack<pair<int, int>> sta;
     while (!sta.empty()) {
         // 栈顶元素处理
         // 相邻点入栈
     }
     ```

#### 核心代码实现（BFS边界扫描法）
```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    int n;
    cin >> n;
    int map[35][35] = {0}; // 初始化矩阵

    // 读入数据，0替换为2
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cin >> map[i][j];
            if (map[i][j] == 0) map[i][j] = 2;
        }
    }

    queue<pair<int, int>> q;
    int dx[] = {0, 0, 1, -1};
    int dy[] = {1, -1, 0, 0};

    // 扫描四边：首行/末行
    for (int j = 1; j <= n; j++) {
        if (map[1][j] == 2) {
            map[1][j] = 0;
            q.push({1, j});
        }
        if (map[n][j] == 2) {
            map[n][j] = 0;
            q.push({n, j});
        }
    }
    // 扫描左右边（避免角重复）
    for (int i = 2; i < n; i++) {
        if (map[i][1] == 2) {
            map[i][1] = 0;
            q.push({i, 1});
        }
        if (map[i][n] == 2) {
            map[i][n] = 0;
            q.push({i, n});
        }
    }

    // BFS标记圈外0
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 1 && nx <= n && ny >= 1 && ny <= n && map[nx][ny] == 2) {
                map[nx][ny] = 0;
                q.push({nx, ny});
            }
        }
    }

    // 输出结果：2（圈内0）、0（圈外0）、1（原值）
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n; j++) {
            cout << map[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

#### 算法可视化方案
- **风格**：8位像素风（复古游戏），网格大小为32×32，每个格子16×16像素。
- **动画流程**：
  1. **初始化**：蓝色（1）、红色（2，未处理0）、绿色（圈外0）。
  2. **BFS过程**：
     - 边界点入队（绿色闪烁 + 音效）。
     - 当前处理点高亮黄色。
     - 相邻点标记为绿色并入队（“滴”音效）。
  3. **结束**：圈内0保持红色，播放完成音效。
- **交互功能**：
  - 控制面板：开始/暂停、单步执行、速度滑块。
  - 自动演示：类似“贪吃蛇AI”逐步展开搜索。
- **技术实现**：HTML5 Canvas绘制，JavaScript逻辑，Web Audio API音效。

#### 拓展练习
1. **洛谷 P1506 拯救oibh总部**：相同思路，计算闭合圈内0的数量。
2. **洛谷 P1162 海战**：变式练习，强化搜索在网格中的应用。
3. **洛谷 P1131 红牌**：结合动态规划，拓展算法思维。

#### 学习心得
- **逆向思维**：当直接求解困难时（如判断圈内0），考虑反向操作（标记圈外0）。
- **BFS/DFS选择**：BFS队列实现避免递归爆栈，适合较大数据；DFS代码简洁，小数据适用。
- **边界处理**：扩展矩阵一圈或扫描四边，确保圈外0完整标记。

> 掌握搜索算法的核心在于多练习、多思考。下次挑战见！💪

---  
**可视化演示示例**（伪代码描述）：  
```javascript
// 初始化Canvas
const grid = drawGrid(32, 32, 16); 
// 绑定事件：开始/暂停/单步
controlPanel.onStart = () => bfsAnimation(map); 

function bfsAnimation() {
    while (queue.length) {
        let [x, y] = queue.dequeue();
        highlightCell(x, y, 'yellow'); // 当前点高亮
        playSound('step'); 
        for (each direction) {
            if (cell is 2) {
                markCell(nx, ny, 'green'); // 圈外0标记
                queue.enqueue([nx, ny]);
            }
        }
        delay(speed); // 按滑块速度延时
    }
    playSound('success'); // 完成音效
}
```

---
处理用时：402.56秒
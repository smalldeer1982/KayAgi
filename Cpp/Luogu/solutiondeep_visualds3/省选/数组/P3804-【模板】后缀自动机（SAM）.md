# 题目信息

# 【模板】后缀自动机（SAM）

## 题目描述

给定一个只包含小写字母的字符串 $S$。

请你求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。


## 说明/提示

对于 $10 \%$ 的数据，$\lvert S \rvert \le 1000$。  
对于 $100\% $的数据，$1 \le \lvert S \rvert \le {10}^6$。

- 2023.7.30：添加一组 hack 数据。

## 样例 #1

### 输入

```
abab```

### 输出

```
4```

# AI分析结果


### 题目分析
题目要求计算字符串中所有出现次数大于1的子串的（出现次数 × 子串长度）的最大值。后缀自动机（SAM）是解决此问题的理想工具，因其能高效处理子串相关统计问题。

### 题解要点提炼

#### 1. **核心算法：后缀自动机（SAM）**
   - **目标**：构建一个能接受所有后缀的最小DFA（确定性有限状态自动机）。
   - **关键概念**：
     - **endpos集合**：子串在字符串中所有出现位置的右端点集合。
     - **等价类**：endpos集合相同的子串归为一类，每个类对应SAM中的一个状态。
     - **后缀链接（link）**：连接等价类形成parent树（树边表示后缀关系）。
   - **性质**：
     - SAM节点数 ≤ 2n-1（n为字符串长度）。
     - 每个节点表示多个子串，其长度连续（最长串长度 = `len`，最短串长度 = `len(link)+1`）。

#### 2. **构造过程（增量法）**
   ```cpp
   void insert(char c) {
     int cur = new_node(), p = last;
     len[cur] = len[last] + 1;
     while (p && !ch[p][c]) ch[p][c] = cur, p = link[p];
     if (!p) link[cur] = root;
     else {
       int q = ch[p][c];
       if (len[q] == len[p] + 1) link[cur] = q;
       else {
         int clone = new_node();
         len[clone] = len[p] + 1;
         link[clone] = link[q]; link[q] = link[cur] = clone;
         while (p && ch[p][c] == q) ch[p][c] = clone, p = link[p];
       }
     }
     last = cur;
   }
   ```
   - **步骤**：
     1. 新建状态 `cur`，`len[cur] = len[last] + 1`。
     2. 从 `last` 沿 `link` 向上跳，为无字符 `c` 转移的节点添加转移边到 `cur`。
     3. 处理已有转移的情况：
        - 若 `len[q] == len[p] + 1`，直接设置 `link[cur] = q`。
        - 否则分裂状态 `q`，新建 `clone`，调整链接关系。

#### 3. **计算出现次数**
   - **方法**：在parent树上做子树和统计。
     - 每个前缀节点（插入字符时新建的节点）初始出现次数为1。
     - DFS遍历parent树，累加子树和：
       ```cpp
       void dfs(int u) {
         for (int v : tree[u]) {
           dfs(v);
           cnt[u] += cnt[v];
         }
         if (cnt[u] > 1) ans = max(ans, 1LL * len[u] * cnt[u]);
       }
       ```

#### 4. **时间复杂度**
   - 构造SAM：O(n)
   - DFS统计：O(n)
   - 总复杂度：O(n)

### 难点对比
| 题解作者         | 核心贡献                                                                 | 难点解析                                                                 |
|------------------|--------------------------------------------------------------------------|--------------------------------------------------------------------------|
| Hatsune_Miku     | 详细理论推导，完整SAM实现                                               | 深入endpos性质，严格证明SAM正确性                                        |
| KesdiaelKen      | 通俗解释endpos等价类，简洁代码                                          | 平衡理论与代码实现，适合初学者                                           |
| shadowice1984    | DFA角度引入SAM，强调线性构造                                            | 结合自动机理论，复杂度证明严谨                                           |
| 比利♂海灵顿      | DAG上DFS统计出现次数（非parent树）                                       | 创新统计方法，但需处理DAG记忆化                                          |
| Dilute_Particles | 标准parent树DFS实现                                                     | 强调parent树与endpos关系                                                |
| __O_v_O__        | 图解SAM构建流程                                                         | 可视化构造过程，降低理解门槛                                             |

### 精炼结论
1. **问题转化**：利用SAM将子串统计问题转化为状态树（parent树）上的子树和问题。
2. **关键步骤**：
   - 构建SAM，记录每个状态的 `len` 和 `link`。
   - 在parent树上DFS，计算每个状态的子树和（出现次数）。
   - 对所有满足 `出现次数 > 1` 的状态，计算 `len × 出现次数` 的最大值。
3. **优化点**：字符集较大时，用 `map` 存储转移边（复杂度 O(n log|Σ|)）。

### 可视化算法分析
#### 像素动画演示方案
**主题**：`SAM构造与子树统计`（8位像素风格，仿FC游戏）  
**核心流程**：
1. **场景1：SAM动态构建**
   - **动画**：网格显示字符串，动态添加节点（不同颜色区分状态）。
   - **高亮**：新增状态 `cur`，跳 `link` 过程，分裂状态时闪烁提示。
   - **音效**：添加字符（"叮"），分裂状态（"咔嚓"）。

2. **场景2：Parent树构建**
   - **动画**：节点按树形布局，红色边表示 `link`。
   - **同步**：显示代码当前执行行（如 `while (p && !ch[p][c])...`）。

3. **场景3：子树和计算**
   - **动画**：叶子节点初始化为1（绿色），向上累加（颜色渐变）。
   - **效果**：当前节点值增加时播放"滴"声，更新子树和。

4. **场景4：答案计算**
   - **动画**：遍历状态，显示 `len × cnt` 的进度条。
   - **特效**：刷新最大值时播放胜利音效，显示最终答案。

**交互控制**：
- **步进/暂停**：手动控制算法步骤。
- **速度调节**：滑块调整自动播放速度。
- **比较模式**：并排显示不同实现（如标准DFS vs DAG DFS）。

### 拓展练习
1. **相似问题**：
   - **P3975**：求字典序第k小子串（SAM上DFS）。
   - **P1368**：最小表示法（循环移位转SAM）。
   - **SP1811**：两串最长公共子串（双串SAM）。
2. **推荐理由**：
   | 题目   | 考察点                   | 推荐理由                                     |
   |--------|--------------------------|---------------------------------------------|
   | P3975  | SAM求第k小子串           | 巩固SAM结构，理解字典序遍历                  |
   | P1368  | 最小循环移位             | 应用SAM处理字符串循环特性                    |
   | SP1811 | 双串LCS                  | 拓展SAM在多串匹配中的应用                    |

### 学习心得
- **调试经验**：注意 `link` 与转移边的区别；出现次数统计必须依赖parent树而非DAG。
- **关键技巧**：理解 `endpos` 等价类的划分是SAM的核心，parent树本质是后缀关系树。
- **优化方向**：字符集大时用 `map` 存边；避免冗余状态复制。

> **一句话总结**：SAM将子串统计转化为parent树上的子树和问题，O(n)时间内高效求解。可视化演示生动展现状态分裂与子树累加过程，深化理解自动机与树结构的关联。

---
处理用时：133.19秒
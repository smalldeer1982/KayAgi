# 题目信息

# 【模板】点分树 | 震波

## 题目背景

模板题，没有 $rap$ 。

## 题目描述

在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。

不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。

接下来你需要在线处理 $m$ 次操作：

`0 x k` 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。

`1 x y` 表示第 $x$ 个城市的价值变成了 $y$ 。

为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。



## 说明/提示

#### 数据规模与约定

对于 $100 \%$ 的数据，有 $1\leq n,m\leq 10^5, 1\leq u,v,x\leq n, 1\leq value_i,y\leq 10^4,0\leq k\leq n-1$ 。

upd：样例范围与题目真实数据范围不同，以提示中给出的数据范围为准。

#### 说明
题目来源：BZOJ3730。

## 样例 #1

### 输入

```
8 1
1 10 100 1000 10000 100000 1000000 10000000
1 2
1 3
2 4
2 5
3 6
3 7
3 8
0 3 1```

### 输出

```
11100101```

# AI分析结果


### 📊 Kay的C++算法解析：震波 深入学习指南

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：点分树（动态点分治）  
🗣️ **初步分析**：
> 解决"震波"问题，关键在于点分树技术。想象城市构成一棵树，点分树如同建立"地震监测站网络"：每次选重心建站（覆盖区域），子问题递归建站形成层级结构。监测站记录辖区内各点距离信息，实现高效地震影响计算。
> - **核心流程**：
>   1. 构建点分树：选重心为根，递归处理子树
>   - **可视化设计**：像素动画中，重心用闪烁红星标记，递归时显示分治区域
>   2. 维护双数据结构：
>      - `S1[u]`：u辖区到u的距离信息（树状数组）
>      - `S2[u]`：u辖区到u父节点的距离信息（容斥用）
>   - **动画高亮**：查询时从震源x向上跳站，显示影响范围（蓝色波纹），红色标记需减去的重叠区域
> - **复古像素方案**：
>   - 8-bit网格地图，城市为像素方块（价值=颜色深度）
>   - 地震波扩散动画（同心圆），音效：扩散"滴"声，计算成功"叮"声
>   - 控制面板：单步/自动播放（速度滑块），重置按钮

---

#### **2. 精选优质题解参考**
**题解一（来源：tzc_wk）**  
* **点评**：  
  思路清晰，完整呈现点分树构建→双树状数组维护→查询/修改的推导链。代码规范：  
  - 动态开点线段树处理变长距离（`w1`,`w2`结构体）  
  - 距离计算用ST表优化（`getdis`函数）  
  - **亮点**：严格证明点分树性质（LCA在原路径上），时间复杂度优化到位  
  **评分**：⭐⭐⭐⭐⭐

**题解二（来源：Ayiirep）**  
* **点评**：  
  教学视角优秀，用树状数组+vector节省空间。关键创新：  
  - 预处理子树最大深度限制树状数组大小  
  - **实践价值**：`resize(子树大小+2)`避免MLE，代码可直接用于竞赛  
  **评分**：⭐⭐⭐⭐⭐

**题解三（来源：Ireliaღ）**  
* **点评**：  
  框架清晰（点分树→数据结构→操作实现），突出双数据结构的必要性：  
  - 明确区分`S1`（到自身）和`S2`（到父节点）的作用  
  - **调试技巧**：提醒距离在点分树上无单调性（必须`continue`而非`break`）  
  **评分**：⭐⭐⭐⭐

> 💡 三位作者均实现O(log²n)解法，区别在数据结构选择（线段树/树状数组）和距离计算优化

---

#### **3. 核心难点辨析与解题策略**
1. **难点：高效维护动态距离信息**  
   * **分析**：直接存储所有点距离空间O(n²)→用点分树分治，每点仅存子树内信息（O(n log n)空间）
   * 💡 **学习笔记**：树状数组大小=子树最大深度+2

2. **难点：容斥消除重复计算**  
   * **分析**：当查询从x跳至父节点u时，需减去x所在子树的贡献
   * 💡 **学习笔记**：双数据结构设计是点分树核心，`ans += S1[u] - S2[son]`

3. **难点：强制在线处理**  
   * **分析**：参数需异或上次答案→所有操作需保持一致性
   * 💡 **学习笔记**：修改时同步更新所有祖先节点数据结构

✨ **解题技巧总结**：
- **技巧1（空间压缩）**：`vector`动态调整树状数组大小
- **技巧2（距离优化）**：ST表/O(1) LCA替代倍增
- **技巧3（边界处理）**：距离查询时`min(dis, size-1)`防越界

---

#### **4. C++核心代码实现赏析**
**通用核心实现（综合优质题解）**  
```cpp
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 1e5+5;
struct Fenwick {
    vector<int> tree;
    void init(int size) { 
        tree.resize(size+2); // 距离0~size
    }
    void update(int p, int v) {
        for(int i=p+1; i<tree.size(); i+=i&-i) tree[i] += v;
    }
    int query(int p) {
        int res = 0;
        p = min(p+1, (int)tree.size()-1);
        for(; p; p-=p&-p) res += tree[p];
        return res;
    }
} S1[MAXN], S2[MAXN]; // S1:到自身, S2:到父节点

// 点分树节点
int fa[MAXN]; // 点分树父亲
vector<int> G[MAXN]; // 原图

void modify(int x, int val) {
    for(int u=x; u; u=fa[u]) {
        int d1 = dis(u, x); // 到u距离
        S1[u].update(d1, val);
        if(fa[u]) {
            int d2 = dis(fa[u], x); // 到父节点距离
            S2[u].update(d2, val);
        }
    }
}

int query(int x, int k) {
    int res = S1[x].query(k); // x的子树贡献
    for(int u=x, last=0; fa[u]; last=u, u=fa[u]) {
        int d = dis(fa[u], x);
        if(d > k) continue;
        res += S1[fa[u]].query(k-d);   // 父节点子树
        res -= S2[last].query(k-d);     // 减x所在子树
    }
    return res;
}
```

**题解一（tzc_wk）片段**  
```cpp
void solve(int x, int tot) {
    // 找重心部分
    cent = 0; find_cent(x, 0, tot);
    vis[cent] = 1;
    for(int e: G[cent]) if(!vis[e]) {
        int sz = (siz[e] < siz[cent]) ? siz[e] : tot-siz[cent];
        solve(e, sz); // 递归建树
    }
}
```
* **亮点**：优雅处理子树大小，避免全局变量  
* **学习笔记**：重心选择用`maxs`比较，保证树高平衡

**题解二（Ayiirep）片段**  
```cpp
void update(int x, int v) {
    for(auto &node: a[x]) { // a[x]存储点分树祖先信息
        int A = node.G, B = node.from, d = node.dis;
        S1[A].update(d, v); // 更新自身
        if(B) S2[B].update(d, v); // 更新父节点
    }
}
```
* **亮点**：`vector`存储祖先信息，避免显式建树  
* **学习笔记**：预处理所有点的祖先信息，查询时直接遍历

---

#### **5. 算法可视化：像素动画演示**
**主题**：像素城市地震模拟器  
**核心演示**：  
![](https://assets.luogu.com.cn/upload/image_hosting/ay94t1ai.png)

1. **初始化**：
   - 8-bit网格地图（棕=土地，蓝=城市），城市闪烁标记价值
   - 控制面板：开始/暂停/单步/速度滑块

2. **点分树构建**：
   - 自动模式：红心标记当前重心，递归时显示分治区域
   - 音效：选择重心"滴"，分治"咔嚓"

3. **查询操作**：
   - 输入震源x（黄色闪烁），影响范围k
   - 动态显示：从x向上遍历点分树（路径高亮）
   - 影响区域：蓝色波纹扩散（半径=k-dis(x,u)）
   - 容斥区域：红色闪烁（需减去的重叠部分）

4. **修改操作**：
   - 城市价值变化：颜色深度变化
   - 向上更新祖先：数据网格数值跳动

**技术实现**：Canvas绘制网格+圆形扩散动画，距离计算实时显示，音效使用Web Audio API

---

#### **6. 拓展练习与相似问题思考**
**通用技巧迁移**：
1. **动态树直径**：维护最远点对
2. **带权查询**：将价值替换为其他权重
3. **多次询问路径**：结合边分树

**推荐练习**：
1. **洛谷P2056** [ZJOI2007]捉迷藏  
   💡 **理由**：点分树+堆维护最长路径，巩固基础
2. **洛谷P3345** [ZJOI2015]幻想乡战略游戏  
   💡 **理由**：动态查询带权重心，提升点分树移动技巧
3. **洛谷P3920** [WC2014]紫荆花之恋  
   💡 **理由**：动态加点+平衡树，挑战高阶应用

---

#### **7. 学习心得与经验分享**
> **参考经验（来自Ayiirep）**：  
> *"初学点分树时，在容斥处理上卡了很久，后来意识到必须用S2存储到父节点距离而非子树根距离"*  
> 
> **Kay点评**：经典误区！点分树上距离无直接关联，需严格通过父节点中转。调试时可用小数据模拟距离矩阵验证。

---

### 💎 总结
点分树是处理**树上动态邻域查询**的利器，通过树高保障复杂度。本题的双树状数组设计是核心创新点，配合距离优化可高效解题。建议通过可视化理解分治过程，掌握边界处理技巧后，可向带权/动态加点等进阶题型挑战！

---
处理用时：119.22秒
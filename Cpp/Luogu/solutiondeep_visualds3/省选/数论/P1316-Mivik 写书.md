# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果


# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡

<introduction>
今天我们来一起分析“Mivik 写书”这道C++编程题。这道题要求计算随机生成字符串中本质不同子串的期望数量，是容斥原理和状态压缩的经典应用。本指南将带大家深入理解其核心算法。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`容斥原理与状态压缩` (编程技巧应用)

🗣️ **初步分析**：
> 解决这道题的关键在于运用**容斥原理**。想象我们要统计糖果总数，但直接数会重复计数某些糖果，于是通过"加多减少"（奇数状态加，偶数状态减）来修正结果。  
> - **核心思路**：枚举子串长度和出现位置，用并查集合并相同字符位置，计算自由变量数，最后容斥求和
> - **难点**：状态设计（二进制表示出现位置）、并查集合并逻辑、容斥系数处理
> - **可视化设计**：用像素网格表示字符串位置，高亮当前枚举的子串出现位置，动态展示并查集合并过程（同色块表示需相同字符），自由位置闪烁提示
> - **游戏化设计**：8-bit音效（合并"滴"声，自由位置"叮"声），将每个子串长度视为关卡，通关后显示容斥结果（加/减特效）

---

## 2. 精选优质题解参考

<eval_intro>
以下是综合思路清晰度、代码规范性和算法效率筛选出的优质题解：
</eval_intro>

**题解一（作者：Huasushis）**
* **点评**：思路讲解最详尽，逐步推导容斥原理的应用过程。代码中：
  - 变量命名清晰（`x`表子串长度，`tot`统计自由变量）
  - 并查集初始化`iota`和合并逻辑直观
  - 位运算`c = (c<<1)|((i>>j)&1)`高效实现滑动窗口
  - 特别亮点：详细注释帮助理解容斥的数学本质

**题解二（作者：7KByte）**
* **点评**：代码最简洁高效，亮点包括：
  - 预计算`bt[i]`（奇偶性）和`mt[]`（低位索引）加速位运算
  - 并查集合并使用`for(;t;t-=t&-t)`位遍历技巧
  - 模块化设计`calc()`函数，逻辑紧凑
  - 特别亮点：O(n²2ⁿ)时间复杂度下仍保持优异性能

**题解三（作者：Reunite）**
* **点评**：提供独特实现视角：
  - 使用`mp[]`数组记录位置覆盖情况，区别于滑动窗口
  - 双重循环合并相同位置（`xx[]`数组存储需合并的偏移量）
  - 边界处理严谨（`(ans+mod)%mod`避免负数）
  - 特别亮点：对并查集合并过程的可视化描述更直观

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下三个关键难点：
</difficulty_intro>

1.  **状态空间的设计与枚举**
    * **分析**：如何表示子串出现位置？优质题解均采用二进制状态压缩，第k位为1表示第k个位置是子串起点。需注意状态数随n指数增长（2^(n-len+1)）
    * 💡 **学习笔记**：二进制状态压缩是处理位置枚举问题的利器

2.  **字符约束的合并处理**
    * **分析**：当子串多次出现时，哪些字符必须相同？通过并查集：
      - 滑动窗口（Huasushis）或位置覆盖（Reunite）识别需合并的位置
      - 取lowbit作为根节点合并等价类
      - 最终连通块数即自由变量数
    * 💡 **学习笔记**：并查集将位置约束转化为连通块计数

3.  **容斥原理的应用**
    * **分析**：如何避免重复计数？根据包含-排斥原理：
      - 奇数次出现：贡献为`+m^(自由变量)`
      - 偶数次出现：贡献为`-m^(自由变量)`
      - 通过`__builtin_parity`快速判断奇偶性
    * 💡 **学习笔记**：容斥通过符号翻转解决重复计数问题

### ✨ 解题技巧总结
<summary_best_practices>
通过本题可总结以下通用技巧：
</summary_best_practices>
- **位运算优化**：用`x&-x`取lowbit，`__builtin_ctz`快速计算低位0数量
- **并查集初始化**：C++的`iota(fa, fa+len, 0)`快速初始化数组
- **模块化设计**：将枚举长度、状态处理分离（如`calc()`函数）
- **负数取模**：`(ans - val + mod) % mod`确保结果非负

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下代码综合了优质题解的思路，完整实现算法：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：融合Huasushis的清晰与7KByte的高效，添加详细注释
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
#define mod 1000000007
using namespace std;
typedef long long ll;

ll qpow(ll x, ll y) {
    ll res = 1;
    while (y) {
        if (y & 1) res = res * x % mod;
        y >>= 1; x = x * x % mod;
    }
    return res;
}

int main() {
    int n; ll m, ans = 0;
    cin >> n >> m;
    
    // 枚举子串长度len
    for (int len = 1; len <= n; len++) {
        int state_cnt = 1 << (n - len + 1);
        
        // 枚举出现位置状态s
        for (int s = 1; s < state_cnt; s++) {
            vector<int> fa(len);
            iota(fa.begin(), fa.end(), 0);
            int free_count = 0; // 自由位置计数
            int window = 0, mask = (1 << len) - 1;
            
            // 滑动窗口扫描字符串
            for (int pos = 0; pos < n; pos++) {
                window = ((window << 1) | (bool)(s & (1 << pos))) & mask;
                
                if (window) {
                    int root = __builtin_ctz(window); // 取最低位作为根
                    for (int temp = window; temp; temp -= temp & -temp) {
                        int cur = __builtin_ctz(temp & -temp);
                        if (fa[cur] != fa[root]) fa[cur] = root;
                    }
                } else {
                    free_count++; // 未覆盖位置
                }
            }
            
            // 统计连通块
            int comp_count = 0;
            for (int i = 0; i < len; i++)
                if (fa[i] == i) comp_count++;
                
            // 容斥计数
            ll ways = qpow(m, free_count + comp_count);
            if (__builtin_popcount(s) & 1) 
                ans = (ans + ways) % mod;
            else 
                ans = (ans - ways + mod) % mod;
        }
    }
    
    // 计算期望 = 总方案数 / m^n
    ll total = qpow(m, n);
    ans = ans * qpow(total, mod - 2) % mod;
    cout << ans << endl;
}
```
* **代码解读概要**：
  > 1. **枚举子串长度**：len从1到n，计算该长度子串的贡献
  > 2. **状态枚举**：s的二进制位表示子串起始位置
  > 3. **滑动窗口**：window变量维护当前覆盖状态，mask确保窗口大小
  > 4. **并查集合并**：对非零window，取lowbit为根合并所有1位
  > 5. **容斥累加**：根据状态奇偶性加减方案数
  > 6. **期望计算**：最后除以总方案数m^n（模逆元实现除法）

---
<code_intro_selected>
各题解核心片段亮点解析：
</code_intro_selected>

**题解一（Huasushis）**
* **亮点**：详细注释+逐步推导容斥原理
* **核心代码片段**：
```cpp
for (int i = 1; i <= n; ++i) sol(i); // 分层处理

void sol(int x) {
    for (int i = 1; i < (1<<(n-x+1)); ++i) {
        // 并查集初始化
        for (int j = 0; j < x; ++j) 
            fa[j] = j;
        
        // 滑动窗口更新
        c = (c << 1) | ((i >> j) & 1); 
        c &= mask;
        
        // 容斥判断
        if (__builtin_parity(i)) 
            ans = (ans + tmp) % mod;
        else 
            ans = (ans - tmp + mod) % mod;
    }
}
```
* **代码解读**：
  > 亮点在`sol(i)`分层处理结构：  
  > 1. 外层循环枚举子串长度（1~n）  
  > 2. 内层`i`枚举位置状态（0001~1111）  
  > 3. `c = (c<<1)|...`实现状态窗口滑动  
  > 4. `__builtin_parity`直接获取奇偶性  
  > 这种结构使代码逻辑分层清晰
* 💡 **学习笔记**：模块化函数设计提升代码可读性

**题解二（7KByte）**
* **亮点**：位运算极致优化
* **核心代码片段**：
```cpp
rp(i, n) calc(i); // 遍历长度

void calc(int x){
    int mask = (1 << x) - 1;
    rp(s, (1<<(n-x+1))-1) {
        for (int j = 0; j < n; j++) {
            c = (c << 1) | (s >> j & 1);
            c &= mask;
            if (c) {
                int root = mt[c & -c]; // 预计算低位索引
                // 位遍历技巧
                for (int t = c - (c&-c); t; t -= t&-t) 
                    fa[mt[t&-t]] = root;
            }
        }
    }
}
```
* **代码解读**：
  > 关键优化点：  
  > 1. `mt[]`数组预存低位1的索引（mt[0001]=0, mt[0010]=1,...）  
  > 2. `t = c - (c&-c)`获取除最低位外的其他1位  
  > 3. `t -= t&-t`循环移除最低位  
  > 这种实现将并查集合并复杂度降至O(k)（k为1的个数）
* 💡 **学习笔记**：预计算和位遍历是状态压缩的关键优化手段

**题解三（Reunite）**
* **亮点**：位置覆盖标记法
* **核心代码片段**：
```cpp
for (int pos = 1; pos <= n; pos++) 
    if (s & (1<<(pos-1))) 
        for (int off = 0; off < len; off++)
            mp[pos+off] |= (1<<off); // 标记覆盖位

for (int pos = 1; pos <= n; pos++) {
    if (mp[pos]) {
        int root = -1;
        for (int off = 0; off < len; off++) {
            if (mp[pos] & (1<<off)) {
                if (root == -1) root = off;
                else fa[off] = root; // 合并到根
            }
        }
    }
}
```
* **代码解读**：
  > 创新点在于：  
  > 1. 先通过`mp[]`数组标记每个位置被哪些子串偏移量覆盖  
  > 2. 再统一处理每个位置的合并需求  
  > 3. 对每个位置，第一个出现的偏移量作为根  
  > 这种方法避免了滑动窗口，更直观但空间略高
* 💡 **学习笔记**：空间换时间有时能提升逻辑清晰度

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
设计名为"容斥冒险"的8-bit风格动画，展示核心算法流程：
</visualization_intro>

* **动画演示主题**：像素勇者在字符串网格中探索子串奥秘
* **核心演示内容**：状态枚举→并查集合并→容斥计数
* **设计思路**：8-bit风格降低理解门槛，音效强化关键操作记忆

* **动画帧步骤**：
  1. **场景初始化**：
     - 16×1像素网格表示字符串位置
     - 控制面板：开始/步进/速度滑块
     - 8-bit背景音乐循环播放
     
  2. **子串长度选择**（关卡选择）：
     - 勇者头顶显示当前len值（1→n）
     - 选择时播放"选择"音效

  3. **状态枚举阶段**：
     - 网格下方显示二进制状态（如0011）
     - 对应起始位置闪烁绿光
     - 伴随"滴"声标记每个1位

  4. **滑动窗口扫描**：
     - 红色框体表示当前窗口
     - 实时二进制显示窗口状态
     - 状态变化时播放"滑动"音效

  5. **并查集合并**：
     - 非零窗口：相同偏移量位置染同色（如蓝/黄）
     - 最低位闪烁后成为根节点
     - 合并时播放"连接"音效

  6. **自由位置标记**：
     - 未被覆盖的位置闪烁金光
     - 伴随"叮"声，右上角计数器+1

  7. **容斥结算**：
     - 奇数次状态：显示"+m^k"绿色字体
     - 偶数次状态：显示"-m^k"红色字体
     - 结算音效：上扬（加）/下降（减）音阶

  8. **关卡结算**：
     - 显示当前len下总贡献值
     - 播放胜利音效（8-bit风格）
     - 勇者升级动画

* **交互设计**：
  - **步进控制**：空格键单步执行
  - **自动演示**：A键自动播放（速度可调）
  - **模式切换**：R键重置，C键切换子串长度

* **技术实现**：
  - Canvas绘制网格和角色
  - Web Audio API实现音效：
    ```js
    // 关键操作音效
    function playSound(type) {
        const osc = new OscillatorNode(context, {
            type: 'square', 
            frequency: type==='merge' ? 440 : 880
        });
        osc.connect(context.destination);
        osc.start(); osc.stop(context.currentTime + 0.1);
    }
    ```

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
容斥原理和状态压缩的经典应用场景：
</similar_problems_intro>

* **通用思路迁移**：
  1. 子集计数问题（如包含特定元素的集合数）
  2. 排列限制问题（如错位排列）
  3. 图论覆盖问题（如支配集计数）

* **练习推荐 (洛谷)**：
  1. **P1450 [HAOI2008]硬币购物**  
     🗣️ 推荐理由：四币值容斥经典题，巩固容斥原理应用
  2. **P2158 [SDOI2008]仪仗队**  
     🗣️ 推荐理由：欧拉函数+容斥，训练状态分析能力
  3. **P3349 [ZJOI2016]小星星**  
     🗣️ 推荐理由：树形DP+子集容斥，提升状态压缩技巧

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的调试经验值得借鉴：
</insights_intro>

> **参考经验 (来自 Huasushis)**：  
> "这个容斥应该算是很经典的，非常适合像我一样的组合蒟蒻食用。"  
> **点评**：许多同学初学容斥时会被符号翻转困惑，建议：  
> 1. 从小规模数据开始（n=3）手动模拟  
> 2. 重点理解"奇加偶减"的抵消原理  
> 3. 调试时输出中间状态（如并查集合并结果）

---

<conclusion>
通过本次分析，我们掌握了用容斥原理解决子串期望问题的核心技巧。记住：位运算优化状态枚举，并查集处理等价类，容斥解决重复计数——这三板斧能解决许多组合计数问题。下次遇到类似问题，不妨回想像素勇者的冒险之旅哦！💪
</conclusion>
```

---
处理用时：243.34秒
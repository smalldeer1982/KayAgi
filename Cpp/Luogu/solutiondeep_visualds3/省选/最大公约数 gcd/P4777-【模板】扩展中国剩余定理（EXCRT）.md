# 题目信息

# 【模板】扩展中国剩余定理（EXCRT）

## 题目描述

给定 $n$ 组非负整数 $a_i, b_i$ ，求解关于 $x$ 的方程组的最小非负整数解。
$$\begin{cases}x\equiv b_1\pmod{a_1}\\x\equiv b_2\pmod{a_2}\\\dots\\x\equiv b_n\pmod{a_n}\end{cases}$$

## 说明/提示

对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$1 \le b_i,a_i \le {10}^{12}$，保证所有 $a_i$ 的最小公倍数不超过 ${10}^{18}$。

**请注意程序运行过程中进行乘法运算时结果可能有溢出的风险。**

数据保证有解。

## 样例 #1

### 输入

```
3
11 6
25 9
33 17
```

### 输出

```
809```

# AI分析结果



---

# 💡 Kay的C++算法解析：【模板】扩展中国剩余定理（EXCRT）深入学习指南 💡

<introduction>
今天我们来一起分析“【模板】扩展中国剩余定理（EXCRT）”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`扩展中国剩余定理（EXCRT）`

🗣️ **初步分析**：
解决这道题的关键在于理解并运用扩展中国剩余定理（EXCRT）。简单来说，EXCRT是中国剩余定理（CRT）的扩展版，专门处理模数不互质的同余方程组求解问题。传统CRT要求模数两两互质，而EXCRT通过逐步合并两个同余方程，最终得到所有方程的共同解。

在本题中，EXCRT的核心应用是通过合并每两个同余方程，逐步缩小解的范围。例如，对于两个方程 $x \equiv b_1 \pmod{a_1}$ 和 $x \equiv b_2 \pmod{a_2}$，我们将其转化为线性方程 $k_1a_1 - k_2a_2 = b_2 - b_1$，使用扩展欧几里得算法（exgcd）求解 $k_1$ 和 $k_2$，从而合并得到新的同余方程 $x \equiv x^* \pmod{\text{lcm}(a_1,a_2)}$，其中 $x^*$ 是当前合并后的解，$\text{lcm}(a_1,a_2)$ 是新的模数。

核心算法流程大致为：  
1. 初始化第一个方程的解和模数；  
2. 依次合并后续每个方程，使用exgcd求解线性同余方程；  
3. 更新当前解和模数，直到所有方程合并完成；  
4. 最终解即为合并后的最小非负解。

可视化设计方面，我们将采用8位像素风格动画，模拟合并过程：用不同颜色的像素块表示当前解和模数，动态展示exgcd求解步骤（如系数调整、gcd计算），并通过“入队/出队”音效提示关键操作（如解更新、模数调整）。动画支持单步执行和自动播放，帮助学习者直观看到每一步如何从两个方程推导出合并后的解。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等几个方面，筛选了以下评分较高（≥4星）的题解。
</eval_intro>

**题解一：作者：niiick（赞：302）**  
* **点评**：该题解思路清晰，详细解释了合并两个同余方程的数学推导，并通过代码实现了逐步合并的过程。代码中使用快速乘（龟速乘）处理大数乘法溢出问题，变量命名规范（如`exgcd`函数、`mul`函数），边界条件处理严谨（如取模操作确保非负）。其亮点在于对溢出风险的处理（如先除后乘避免中间结果过大）和对合并逻辑的简洁实现，适合直接作为竞赛参考代码。

**题解二：作者：阮行止（赞：598）**  
* **点评**：此题解从数学原理出发，详细推导了EXCRT的合并过程，包括不定方程的求解、通解的形式证明，理论深度强。代码虽然用Python实现，但逻辑与C++版本一致，对理解算法本质有极大帮助。亮点在于对数学原理的透彻解释，适合需要深入理解EXCRT的学习者。

**题解三：作者：sumijie（赞：80）**  
* **点评**：该题解以简洁的代码展示了EXCRT的核心逻辑，通过循环合并方程，代码结构清晰。对关键步骤（如exgcd调用、解的更新）的注释明确，适合快速理解算法流程。亮点在于代码的简洁性和可读性，适合初学者模仿。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下一些关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1：合并两个同余方程的数学推导**  
    * **分析**：合并两个同余方程需要将其转化为线性不定方程，并用exgcd求解。例如，对于 $x \equiv b_1 \pmod{a_1}$ 和 $x \equiv b_2 \pmod{a_2}$，需解 $k_1a_1 - k_2a_2 = b_2 - b_1$。这里需理解exgcd如何找到特解，以及通解的形式（如 $k_1 = k_1^* + \frac{a_2}{d} \cdot t$，其中 $d$ 是 $a_1$ 和 $a_2$ 的gcd）。优质题解通常会明确说明这一步的推导，并通过代码实现特解的调整。
    * 💡 **学习笔记**：合并两个方程的关键是将问题转化为线性不定方程，并用exgcd找到特解，再调整到最小非负解。

2.  **关键点2：处理大数乘法溢出**  
    * **分析**：题目中模数和系数可能高达 $10^{12}$，直接相乘会导致溢出。优质题解（如niiick的代码）使用快速乘（龟速乘）或`__int128`类型来处理。快速乘通过二进制拆分将乘法转化为加法，避免中间结果溢出。例如，计算 $a \times b \mod p$ 时，逐位累加 $a$ 的倍数，每次取模。
    * 💡 **学习笔记**：处理大数乘法时，优先使用快速乘或支持大整数的类型（如`__int128`），避免溢出。

3.  **关键点3：解的范围调整**  
    * **分析**：合并后的解需要保证是最小非负的，因此每次更新解后需对新的模数取模。例如，合并后的解 $x^*$ 应满足 $x^* \equiv x \pmod{\text{lcm}(a_1,a_2)}$，通过取模操作确保其在 $[0, \text{lcm}(a_1,a_2))$ 范围内。
    * 💡 **学习笔记**：每次合并后，解需要对新的模数取模，以保证最小非负。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题及类似问题的分析，我总结了以下一些通用的解题技巧：
</summary_best_practices>
-   **问题分解**：将多个同余方程逐步合并，每次处理两个方程，简化问题复杂度。
-   **溢出预防**：使用快速乘或`__int128`处理大数乘法，避免中间结果溢出。
-   **边界处理**：每次更新解后，通过取模操作确保解为最小非负，避免负数或过大的结果。
-   **数学推导辅助**：理解合并过程的数学原理（如exgcd求解线性不定方程），有助于调试和优化代码。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了niiick、sumijie等优质题解的思路，采用快速乘处理大数乘法，逐步合并每个同余方程，最终得到最小非负解。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    using namespace std;
    typedef long long ll;

    ll exgcd(ll a, ll b, ll& x, ll& y) {
        if (!b) { x = 1; y = 0; return a; }
        ll d = exgcd(b, a % b, y, x);
        y -= a / b * x;
        return d;
    }

    ll mul(ll a, ll b, ll mod) { // 快速乘，避免溢出
        ll res = 0;
        while (b) {
            if (b & 1) res = (res + a) % mod;
            a = (a + a) % mod;
            b >>= 1;
        }
        return res;
    }

    ll excrt(ll n, ll* a, ll* b) {
        ll M = a[1], ans = b[1]; // 初始化解和模数
        for (int i = 2; i <= n; ++i) {
            ll c = (b[i] - ans % a[i] + a[i]) % a[i]; // 计算当前差
            ll x, y, d = exgcd(M, a[i], x, y);
            if (c % d != 0) return -1; // 无解（题目保证有解）
            x = mul(x, c / d, a[i] / d); // 调整特解
            ans += x * M;
            M = M / d * a[i]; // 先除后乘防溢出
            ans = (ans % M + M) % M; // 调整到最小非负
        }
        return ans;
    }

    int main() {
        int n;
        cin >> n;
        ll* a = new ll[n + 1]; // 模数数组
        ll* b = new ll[n + 1]; // 余数数组
        for (int i = 1; i <= n; ++i) cin >> a[i] >> b[i];
        cout << excrt(n, a, b) << endl;
        delete[] a;
        delete[] b;
        return 0;
    }
    ```
* **代码解读概要**：  
  该代码首先读取输入的模数和余数数组，初始化第一个方程的解和模数（`ans`和`M`）。然后依次合并每个后续方程：通过`exgcd`求解线性同余方程，使用`mul`函数处理大数乘法，更新当前解和模数，最终返回最小非负解。关键步骤包括差的计算（`c`）、特解调整（`x`）、模数更新（`M`）和结果调整（`ans % M`）。

---
<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者：niiick（赞：302）**  
* **亮点**：使用快速乘处理大数乘法，代码结构清晰，边界条件处理严谨。
* **核心代码片段**：
    ```cpp
    lt mul(lt a,lt b,lt mod) {
        lt res=0;
        while(b>0) {
            if(b&1) res=(res+a)%mod;
            a=(a+a)%mod;
            b>>=1;
        }
        return res;
    }

    lt excrt() {
        lt x,y,k;
        lt M=bi[1],ans=ai[1];
        for(int i=2;i<=n;i++) {
            lt a=M,b=bi[i],c=(ai[i]-ans%b+b)%b;
            lt gcd=exgcd(a,b,x,y),bg=b/gcd;
            x=mul(x,c/gcd,bg);
            ans+=x*M;
            M*=bg;
            ans=(ans%M+M)%M;
        }
        return (ans%M+M)%M;
    }
    ```
* **代码解读**：  
  `mul`函数通过二进制拆分实现快速乘，避免大数相乘溢出。`excrt`函数中，`c`是当前方程与前一个解的差，`gcd`是当前模数与前一个模数的最大公约数。通过`exgcd`求得特解`x`后，用`mul`调整特解范围，更新`ans`和`M`（新的模数为`lcm`），最后调整`ans`到最小非负。
* 💡 **学习笔记**：快速乘是处理大数乘法的有效方法，通过逐位累加避免溢出。

**题解二：作者：sumijie（赞：80）**  
* **亮点**：代码简洁，直接体现合并逻辑，适合快速理解。
* **核心代码片段**：
    ```cpp
    void exgcd(ll a,ll b,ll &g,ll &x,ll &y) {
        if (b == 0) {
            g = a;
            x = 1;
            y = 0;
            return;
        }
        exgcd(b,a%b,g,y,x);
        y-=(a/b)*x;
    }

    ll excrt() {
        ll a1=a[1],n1=b[1];
        for(int i=2;i<=n;i++){
            ll a2=a[i],n2=b[i];
            ll g,x,y;
            exgcd(a1,n1,x,y,g);
            x=((x*(a2-a1)/g)%(n1/g)+(n1/g))%(n1/g);
            a1=a1*x+a1;
            n1=n1*n2/g;
        }
        return a1;
    }
    ```
* **代码解读**：  
  `exgcd`函数返回`gcd`并计算特解`x,y`。`excrt`函数中，`a1`和`n1`分别保存当前合并后的解和模数，每次合并新的方程时，通过`exgcd`求解特解，调整后更新`a1`和`n1`。
* 💡 **学习笔记**：合并两个方程的关键是找到特解并调整到最小范围，确保解的正确性。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解EXCRT的合并过程，我设计了一个8位像素风格的动画演示方案，通过动态展示每一步合并的关键步骤，帮助大家“看”到算法如何工作。
</visualization_intro>

  * **动画演示主题**：`像素小探险家的同余合并之旅`

  * **核心演示内容**：  
    演示两个同余方程合并的过程，包括线性不定方程的求解、exgcd计算特解、解的调整和模数更新。例如，初始时展示两个方程的“解区域”（用不同颜色的像素块表示），合并后展示新的解区域（颜色混合），并标注新的模数。

  * **设计思路简述**：  
    采用8位像素风格（如FC游戏的网格画面），通过颜色区分不同方程的解区域（如蓝色代表第一个方程，红色代表第二个方程）。合并时，用闪烁的箭头指示exgcd求解过程，关键变量（如`gcd`、`x`、`M`）用文字气泡显示。音效方面，每次合并成功时播放“叮”的提示音，解更新时播放“滑动”音效，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为左右两部分，左侧显示当前合并的两个方程（如`x ≡ 6 mod 11`和`x ≡ 9 mod 25`），右侧显示当前解和模数（初始为`ans=6`，`M=11`）。  
        - 控制面板包含“单步”、“自动播放”按钮和速度滑块。

    2.  **计算差值`c`**：  
        - 高亮显示`c = (b[i] - ans) mod a[i]`的计算过程（如`9-6=3`，`3 mod 25=3`），用绿色文字气泡标注`c=3`。

    3.  **exgcd求解特解**：  
        - 展示`exgcd(M, a[i])`的过程：用递归动画模拟`exgcd(11, 25)`，最终得到`gcd=1`，`x=-2`，`y=1`（用黄色箭头指示每一步的系数变化）。  
        - 计算调整后的特解`x = x * (c/gcd) mod (a[i]/gcd)`（如`x = -2 * 3 mod 25 = 23`），用红色闪烁标注结果。

    4.  **更新解和模数**：  
        - 新的解`ans = ans + x*M`（如`6 + 23*11 = 259`），新的模数`M = M * a[i]/gcd`（如`11*25/1=275`）。  
        - 用像素块扩展动画表示模数增大（原模数11的块扩展为275的块），解259用金色像素点标记在新块中。

    5.  **调整解到最小非负**：  
        - `ans = ans % M`（如`259 mod 275 = 259`），用蓝色文字气泡显示最终解。

    6.  **自动演示与比较**：  
        - 支持自动播放所有合并步骤，对比每一步解和模数的变化（如合并第三个方程`x ≡ 17 mod 33`时，重复上述步骤，最终得到解809）。

  * **旁白提示**：  
    - “现在，我们需要合并第二个方程`x ≡ 9 mod 25`和当前解`x ≡ 6 mod 11`。首先计算差值`c = 9 - 6 = 3`。”  
    - “使用扩展欧几里得算法求解`11x + 25y = 3`，得到特解`x=-2`，调整后得到有效解`x=23`。”  
    - “新的解是`6 + 23*11 = 259`，新的模数是`lcm(11,25)=275`。”

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到EXCRT如何逐步合并同余方程，每一步的数学推导如何转化为代码操作。动画中的颜色标记和音效提示，能帮助大家更轻松地理解抽象的算法逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    EXCRT的核心是通过合并两个同余方程逐步求解，这种“分治合并”的思想适用于处理多个约束条件的问题。例如：  
    - 求解多个时间循环的重叠问题（如多个周期性事件的共同发生时间）；  
    - 处理大数分解后的同余约束（如RSA加密中的模数分解）；  
    - 解决工程中的多条件约束优化问题（如资源调度的时间约束）。

  * **练习推荐 (洛谷)**：
    以下是几道洛谷上与本题考察知识点相关的题目，建议大家尝试练习：

    1.  **洛谷 P1495 曹冲养猪**  
          * 🗣️ **推荐理由**：经典中国剩余定理（CRT）题目，模数两两互质，适合巩固CRT基础，对比EXCRT的差异。
    2.  **洛谷 P3868 [TJOI2009]猜数字**  
          * 🗣️ **推荐理由**：需要将问题转化为同余方程组求解，涉及大数处理和EXCRT的应用，适合提升综合解题能力。
    3.  **洛谷 P2044 [NOI2005] 随机数生成器**  
          * 🗣️ **推荐理由**：涉及线性同余生成器的求解，需要将问题转化为同余方程，并用EXCRT或exgcd求解，适合拓展算法应用场景。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试过程中的经验，这些经验对我们有重要参考价值。
</insights_intro>

> **参考经验 (来自 名杨天吓)**：“在处理大数乘法时，直接相乘会溢出，必须使用快速乘或先除后乘。例如，计算`M * a[i] / d`时，应先算`M / d`再乘`a[i]`，避免中间结果过大。”

> **点评**：这位作者的经验非常实用。在处理大数运算时，先除后乘是避免溢出的关键技巧。例如，计算`lcm(a,b) = a*b/gcd(a,b)`时，先算`a/gcd(a,b)`再乘`b`，可以有效防止中间结果溢出。这一技巧在竞赛中尤为重要，能避免因溢出导致的错误。

-----

<conclusion>
本次关于“【模板】扩展中国剩余定理（EXCRT）”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解EXCRT的原理和实现。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：269.96秒
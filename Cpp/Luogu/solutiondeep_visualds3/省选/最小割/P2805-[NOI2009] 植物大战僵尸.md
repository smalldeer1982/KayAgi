# 题目信息

# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# AI分析结果

---
# 💡 Kay的C++算法解析：[NOI2009]植物大战僵尸 深入学习指南 💡

<introduction>
  今天我们来分析NOI2009的经典题《植物大战僵尸》！这道题结合了图论中的**最大权闭合子图**和**拓扑排序**，能帮你深入理解“依赖关系”如何转化为网络流模型。跟着Kay一步步拆解，你会发现复杂问题其实藏着简单的逻辑~
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最大权闭合子图 × 拓扑排序（处理环）

🗣️ **初步分析**：
解决这道题的关键，是把“吃植物的依赖关系”转化为**最大权闭合子图**问题——选一个植物必须选它的“保护者”（比如右边的植物、攻击它的植物），就像“选了苹果就要选苹果树”一样。而**拓扑排序**用来解决“互相保护的环”（比如植物A保护B，B又保护A）——这些环里的植物永远吃不到，得先筛掉！

### 核心逻辑拆解：
1. **依赖关系建模**：  
   - 吃植物`P(r,c)`必须先吃右边的`P(r,c+1)` → 连边`P(r,c) → P(r,c+1)`（表示选`P(r,c)`就必须选`P(r,c+1)`）。  
   - 植物`X`保护`Y` → 连边`Y → X`（选`Y`就必须选`X`）。  

2. **处理环**：  
   如果植物间形成环（互相保护），这些植物永远吃不到。用**拓扑排序**筛出所有“可达”的植物（入度为0的点开始，逐步减入度，能遍历到的点才是能吃的）。

3. **最大权闭合子图**：  
   把植物看作点，分数是点权（正分是收益，负分是代价）。建网络流图：  
   - 源点`S`连正权点（容量=分数，选它得收益）；  
   - 负权点连汇点`T`（容量=分数绝对值，选它付代价）；  
   - 原依赖边连`INF`（不能被割断，保证依赖关系）。  
   最大收益 = 所有正权和 - 最小割（最小代价）。

### 可视化设计思路：
我们用**FC红白机风格**做动画：
- 网格地图：每个植物是16×16像素块（正分绿色，负分红色）；  
- 拓扑排序：入度为0的植物闪烁“可吃”，点击后减少相邻植物的入度（动画显示“斩断保护”）；  
- 最大流：源点（黄色）、汇点（紫色），边用线条粗细表示容量，最小割时切断的边闪烁红色，同时显示“舍弃收益”或“支付代价”的提示。


## 2. 精选优质题解参考

<eval_intro>
我选了3份思路清晰、代码规范的题解，帮你快速掌握核心逻辑~
</eval_intro>

**题解一：作者longlongzhu123（赞105）**  
* **点评**：这份题解从“最大权闭合子图”的概念讲起，一步步推导题目建模，连“环的处理”都讲得很透！代码里用`POINT(x,y)`把网格转成点，拓扑排序筛出可达点，再用Dinic跑最大流，逻辑链完整。特别是注释里的“为什么这样连边”，能帮你理解每一步的意义，非常适合入门。

**题解二：作者Freddie（赞20）**  
* **点评**：题解把“依赖关系”“拓扑筛点”“网络流建模”拆成4步，每步都有例子（比如样例中的环处理）。代码里的`read()`函数处理输入很规范，Dinic的实现也很标准，适合你对照着写自己的代码。

**题解三：作者BJpers2（赞12）**  
* **点评**：用“我是僵尸”的游戏经验类比拓扑排序（“先吃没保护的植物”），非常直观！代码里用队列处理拓扑排序，把可达点的编号重新映射，避免了环的干扰，最后建网络流图的部分也很简洁，适合理解“筛点”的必要性。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在“依赖关系建模”和“环的处理”，我们逐一拆解：
</difficulty_intro>

### 1. 难点1：如何将“吃植物的规则”转化为图的边？
* **分析**：题目有两个规则——“吃左边必须先吃右边”“吃被保护的必须先吃保护者”。对应的边方向要反过来看：比如“吃`P(r,c)`必须吃`P(r,c+1)`” → 连边`P(r,c) → P(r,c+1)`（选`P(r,c)`就必须选`P(r,c+1)`）；“`X`保护`Y`” → 连边`Y → X`（选`Y`必须选`X`）。  
* 💡 **学习笔记**：依赖关系的边方向是“结果→条件”（要果先选因）。

### 2. 难点2：如何处理“互相保护的环”？
* **分析**：环里的植物永远吃不到（比如A保护B，B保护A），连它们保护的植物也吃不到。用**拓扑排序**：从入度为0的点开始（没有保护者的植物），逐步减少相邻点的入度，能遍历到的点才是“可吃”的。  
* 💡 **学习笔记**：拓扑排序能筛出“无环依赖”的点，避免无效计算。

### 3. 难点3：如何用网络流求最大权闭合子图？
* **分析**：最大权闭合子图的模型是“选点必须选其可达点”，转化为网络流的最小割问题：  
  - 正权点连源点（选它得收益，割掉表示舍弃）；  
  - 负权点连汇点（选它付代价，割掉表示支付）；  
  - 原边连INF（不能割断，保证依赖）。  
  最大收益 = 所有正权和 - 最小割（最小代价）。  
* 💡 **学习笔记**：最小割对应“最小的舍弃/支付代价”，所以用正权和减去它就是最大收益。

### ✨ 解题技巧总结
- **规则转边**：把“必须先做A才能做B”转化为“B→A”的边（选B必须选A）；  
- **环处理**：拓扑排序筛出可达点，避免无效计算；  
- **网络流建模**：正权连源点，负权连汇点，依赖边连INF，用Dinic跑最小割。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合优质题解的核心代码，包含拓扑排序、Dinic最大流和建图逻辑~
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合了longlongzhu123和Freddie的思路，代码清晰，包含所有核心步骤。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int MAXN = 20 * 30 + 10;  // 20行30列的植物
const int INF = 1e9;
#define POINT(x, y) ((x) * 31 + (y))  // 把(r,c)转成点编号（r从1开始，c从1开始）

struct Edge { int to, cap, next; };
Edge edge[MAXN * MAXN * 2];
int head[MAXN], top = 1;
int n, m, score[MAXN];
vector<int> out[MAXN];  // 原图的边（u→v表示u保护v）
int in_degree[MAXN];    // 入度
bool vis[MAXN];         // 标记是否可达（拓扑排序后）
int S, T;               // 源点、汇点

// 添加网络流边
void add_edge(int u, int v, int cap) {
    top++;
    edge[top].to = v;
    edge[top].cap = cap;
    edge[top].next = head[u];
    head[u] = top;
    top++;
    edge[top].to = u;
    edge[top].cap = 0;
    edge[top].next = head[v];
    head[v] = top;
}

// 拓扑排序筛出可达点
void toposort() {
    queue<int> q;
    for (int i = 1; i <= n * m; ++i) {
        if (in_degree[i] == 0) {
            q.push(i);
            vis[i] = true;
        }
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : out[u]) {
            in_degree[v]--;
            if (in_degree[v] == 0 && !vis[v]) {
                q.push(v);
                vis[v] = true;
            }
        }
    }
}

// Dinic算法的BFS分层
int dis[MAXN];
queue<int> q;
bool bfs() {
    memset(dis, -1, sizeof(dis));
    dis[S] = 0;
    q.push(S);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (dis[v] == -1 && edge[i].cap > 0) {
                dis[v] = dis[u] + 1;
                q.push(v);
            }
        }
    }
    return dis[T] != -1;
}

// Dinic算法的DFS增广
int dfs(int u, int flow) {
    if (u == T) return flow;
    int ret = flow;
    for (int i = head[u]; i && ret; i = edge[i].next) {
        int v = edge[i].to;
        if (dis[v] == dis[u] + 1 && edge[i].cap > 0) {
            int k = dfs(v, min(ret, edge[i].cap));
            edge[i].cap -= k;
            edge[i ^ 1].cap += k;
            ret -= k;
        }
    }
    if (ret == flow) dis[u] = -1;
    return flow - ret;
}

// 计算最大流
int dinic() {
    int ans = 0;
    while (bfs()) {
        ans += dfs(S, INF);
    }
    return ans;
}

int main() {
    cin >> n >> m;
    S = MAXN - 1;
    T = MAXN - 2;

    // 读入数据，建原图的边
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            int u = POINT(i, j);
            cin >> score[u];
            int cnt;
            cin >> cnt;
            while (cnt--) {
                int x, y;
                cin >> x >> y;
                x++; y++;  // 输入是0开始，转成1开始
                int v = POINT(x, y);
                out[u].push_back(v);  // u保护v → 边u→v
                in_degree[v]++;
            }
            if (j < m) {  // 右边的植物是P(i,j+1)，吃P(i,j)必须先吃P(i,j+1)
                int v = POINT(i, j + 1);
                out[u].push_back(v);  // 边u→v（选u必须选v）
                in_degree[v]++;
            }
        }
    }

    // 拓扑排序筛出可达点
    toposort();

    // 建网络流图
    int sum_positive = 0;
    for (int i = 1; i <= n * m; ++i) {
        if (!vis[i]) continue;  // 不可达的点跳过
        if (score[i] > 0) {
            add_edge(S, i, score[i]);
            sum_positive += score[i];
        } else if (score[i] < 0) {
            add_edge(i, T, -score[i]);
        }
        // 添加原图的边（转成网络流的边，容量INF）
        for (int v : out[i]) {
            if (vis[v]) {
                add_edge(v, i, INF);  // 注意：原图是u→v，网络流要转成v→u（依赖关系）
            }
        }
    }

    // 计算最大收益
    int min_cut = dinic();
    cout << sum_positive - min_cut << endl;

    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：把每个植物转成点，读入分数和保护关系，建原图的边；  
  2. **拓扑排序**：筛出所有可达的植物（能吃的）；  
  3. **网络流建图**：正权点连源点，负权点连汇点，依赖边连INF；  
  4. **Dinic求最小割**：最大收益=正权和-最小割。

---

<code_intro_selected>
接下来看几个核心片段的细节~
</code_intro_selected>

### 片段1：拓扑排序（筛出可达点）
* **来源**：题解一（longlongzhu123）  
* **亮点**：用队列处理入度，直观筛选可达点。  
* **核心代码片段**：
```cpp
void toposort() {
    queue<int> q;
    for (int i = 1; i <= n * m; ++i) {
        if (in_degree[i] == 0) {
            q.push(i);
            vis[i] = true;
        }
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int v : out[u]) {
            in_degree[v]--;
            if (in_degree[v] == 0 && !vis[v]) {
                q.push(v);
                vis[v] = true;
            }
        }
    }
}
```
* **代码解读**：  
  - 先把所有“没有保护者”（入度0）的植物加入队列；  
  - 每次取出一个植物，减少它保护的植物的入度（相当于“吃掉它，解除对其他植物的保护”）；  
  - 如果某个植物的入度变成0（所有保护者都被吃掉），就标记为可达（能吃）。  
* 💡 **学习笔记**：拓扑排序是处理“依赖关系”和“环”的神器！

### 片段2：Dinic算法的BFS分层
* **来源**：题解二（Freddie）  
* **亮点**：分层确保每次DFS只走最短路径，提高效率。  
* **核心代码片段**：
```cpp
bool bfs() {
    memset(dis, -1, sizeof(dis));
    dis[S] = 0;
    q.push(S);
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = head[u]; i; i = edge[i].next) {
            int v = edge[i].to;
            if (dis[v] == -1 && edge[i].cap > 0) {
                dis[v] = dis[u] + 1;
                q.push(v);
            }
        }
    }
    return dis[T] != -1;
}
```
* **代码解读**：  
  - 从源点`S`出发，给每个点分层（距离`S`的步数）；  
  - 只有边有剩余容量（`cap>0`）且未分层的点才会被访问；  
  - 返回是否能到达汇点`T`（有增广路）。  
* 💡 **学习笔记**：BFS分层是Dinic算法高效的关键！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到算法的运行过程，Kay设计了一个**FC红白机风格的像素动画**，用游戏化的方式展示“拓扑筛点”和“最大流割边”！
</visualization_intro>

### 动画设计方案
#### 1. 整体风格
- **8位像素风**：用FC游戏机的配色（比如绿色草地、棕色土壤、彩色植物），每个植物是16×16的像素块（正分绿色，负分红色）；  
- **UI面板**：屏幕下方有“开始/暂停”“单步执行”“重置”按钮，还有速度滑块（控制动画快慢）；  
- **背景音乐**：循环播放FC风格的轻快BGM（比如《超级马里奥》的背景音乐）。

#### 2. 核心演示步骤
##### （1）拓扑排序：筛出可达点
- **初始化**：网格显示所有植物，入度为0的植物闪烁**黄色边框**（提示“可吃”）；  
- **单步执行**：点击“单步”，选中一个闪烁的植物（比如`P(1,3)`），播放“咔嚓”音效，表示吃掉它；然后它保护的植物（比如`P(1,2)`）的入度减1，若入度变为0，`P(1,2)`开始闪烁；  
- **自动播放**：点击“自动”，动画快速执行拓扑排序，可达点逐步变成**蓝色**（标记为“能吃”），不可达点（环里的）保持灰色。

##### （2）最大流：求最小割
- **建图展示**：源点`S`（黄色方块）在左上角，汇点`T`（紫色方块）在右上角；正权植物连`S`（绿色线条，粗细=分数），负权植物连`T`（红色线条，粗细=分数绝对值）；依赖边用**灰色虚线**（容量INF）；  
- **割边过程**：播放“滋滋”音效，逐步切断一些边（比如割断`S`到某个正权植物的边，或某个负权植物到`T`的边）；切断的边闪烁红色，同时屏幕下方显示“舍弃收益：XX”或“支付代价：XX”；  
- **结果展示**：最终剩下的边构成最大流，屏幕显示“最大收益：XX”（正权和-最小割），并播放“胜利”音效。

#### 3. 交互设计
- **步进控制**：“单步”按钮让你一步步看拓扑排序和割边过程；  
- **速度调节**：滑块可以调整自动播放的速度（从“慢”到“快”）；  
- **重置**：点击后回到初始状态，重新演示。

### 设计意图
- **像素风格**：唤起你对经典游戏的回忆，降低学习的“距离感”；  
- **音效提示**：用声音强化关键操作（比如“咔嚓”表示吃植物，“滋滋”表示割边）；  
- **可视化反馈**：用颜色和动画直接展示“可达点”“割边”等抽象概念，帮你快速理解。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
最大权闭合子图是一个非常有用的模型，能解决很多“依赖选点”的问题。比如：
</similar_problems_intro>

### 通用思路迁移
- **选课程**：选高级课程必须先选基础课程，求选课程的最大学分；  
- **选项目**：选项目A必须选项目B（比如A需要B的技术），求选项目的最大利润；  
- **选物品**：选物品X必须选物品Y（比如X是配件，Y是主件），求选物品的最大价值。

### 洛谷练习推荐
1. **P3410 拍照**：  
   🗣️ **推荐理由**：经典的最大权闭合子图问题，需要处理“选照片必须选对应的人”的依赖关系，直接套用本题的模型！  
2. **P2057 善意的投票**：  
   🗣️ **推荐理由**：将“同意/反对”转化为点权，“朋友关系”转化为依赖边，练习最大权闭合子图的变形；  
3. **P4174 最小割**：  
   🗣️ **推荐理由**：综合了最大权闭合子图和其他图论技巧，帮你巩固“网络流建模”的能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者都提到了“环的处理”是关键，比如：
</insights_intro>

> **参考经验（来自longlongzhu123）**：“我一开始没处理环，结果样例都过不了！后来想通了——互相保护的植物永远吃不到，必须用拓扑排序筛掉。”  
> **点评**：这个经验很重要！遇到“依赖关系”的问题，一定要先检查是否有环，否则模型会出错。拓扑排序是处理环的“利器”，记得用上~


<conclusion>
《植物大战僵尸》这道题把“游戏规则”转化为“图论模型”，再用“网络流”解决，完美展示了算法的魅力！记住：**复杂问题的核心往往是简单的模型**——找到依赖关系，转化为图，再用已有的算法解决。下次遇到类似的问题，你也能像Kay一样拆解啦！💪
</conclusion>

---

---
处理用时：146.88秒
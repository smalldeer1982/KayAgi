# 题目信息

# [HAOI2012] 道路

## 题目描述

C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。


## 说明/提示

数据规模

$30\%$ 的数据满足：$n\leq 15, m\leq 30$。

$60\%$ 的数据满足：$n\leq 300, m\leq 1000$。

$100\%$ 的数据满足：$n\leq 1500, m\leq 5000, w\leq 10000$。


## 样例 #1

### 输入

```
4 4
1 2 5
2 3 5
3 4 5
1 4 8```

### 输出

```
2
3
2
1```

# AI分析结果


### 💡 Kay的C++算法解析：道路 深入学习指南 💡  
**引言**  
今天我们一起分析「道路」这道图论题。本指南将帮助你理解最短路计数技巧，掌握DAG上动态规划的应用，并通过像素动画直观感受算法执行过程。

---

## 1. 题目解读与核心算法识别  
✨ **本题主要考察**：最短路图构建 + DAG拓扑计数  

🗣️ **初步分析**：  
> 本题核心思想如同搭建「多米诺骨牌」：  
> 1. **枚举起点**：对每个起点计算最短路（SPFA/Dijkstra）  
> 2. **构建最短路图**：保留满足 `dis[u] + w = dis[v]` 的边（类似骨牌间的精确间距）  
> 3. **拓扑计数**：  
>    - 正向计算起点到各点的路径数 `cnt1`（骨牌向前推倒的数量）  
>    - 反向计算各点到终点的路径数 `cnt2`（骨牌向后连锁反应的数量）  
> 4. **贡献统计**：边 `(u→v)` 的贡献为 `cnt1[u] * cnt2[v]`  

**可视化设计思路**：  
- 采用**8位像素风格**（类似经典FC游戏）展示算法流程  
- 关键动画步骤：  
  1. 起点发散波纹扩散（最短路计算）  
  2. 有效边高亮为金色（最短路图构建）  
  3. 绿色数字流动（`cnt1`正向传递）  
  4. 蓝色数字回流（`cnt2`反向传递）  
  5. 边上的计数器跳动（贡献值累加）  
- 交互控制：支持单步执行/调速滑块，关键步骤触发「像素音效」

---

## 2. 精选优质题解参考  
**题解一：xyz32768**  
* **点评**：  
  思路严谨性 ★★★★☆ 代码规范性 ★★★★★  
  - 清晰引入「最短路图」概念，证明其无环性  
  - 采用SPFA+拓扑排序双框架，边界处理完善  
  - 亮点：用 `ins[]` 标记有效边，`cnt1[]` 和 `cnt2[]` 分离计算避免干扰  
  - 实践价值：可直接用于竞赛，时间复杂度 O(n(m+n))  

**题解二：shadowice1984**  
* **点评**：  
  算法优化 ★★★★☆ 教学价值 ★★★★☆  
  - 创新性使用Dijkstra动态建最短路DAG  
  - 亮点：反向建图时复用原邻接表，`dans1[]` 和 `dans[]` 同步更新  
  - 注意事项：需开启O2优化应对稠密图  

**题解三：OI_AKed_me**  
* **点评**：  
  代码简洁性 ★★★★★ 思维启发性 ★★★★  
  - 在Dijkstra内部完成拓扑排序，减少存储开销  
  - 亮点：用 `vector<node>` 存图，`dot` 容器自然记录拓扑序  
  - 学习点：`cnt2` 计算采用逆序遍历拓扑序列  

---

## 3. 核心难点辨析与解题策略  
**难点1：最短路图的动态构建**  
* **分析**：需精准判断边是否在最短路上。优质解法均采用松弛条件验证：  
  ```python
  if dis[u] + w == dis[v]:  # 边(u→v)属于最短路图
  ```  
* 💡 **学习笔记**：最短路图是DAG的关键保证了拓扑排序可行性  

**难点2：反向路径统计**  
* **分析**：`cnt2[v]` 需包含所有经v出发的路径。解法：  
  1. 初始化 `cnt2[v]=1`（路径终点）  
  2. 按拓扑逆序累加：`cnt2[u] += cnt2[v]`  
* 💡 **学习笔记**：反向统计本质是「路径后缀」的组合计数  

**难点3：贡献去重与累加**  
* **分析**：每条边在多次枚举中累加贡献。注意：  
  - 每次枚举起点需重置 `cnt1/cnt2`  
  - 取模运算避免溢出（MOD=1e9+7）  

### ✨ 解题技巧总结  
1. **问题分解**：  
   - 将「边计数」拆解为「起点→u」和「v→终点」的组合问题  
2. **DAG性质应用**：  
   - 拓扑排序保证DP无后效性  
3. **高效枚举**：  
   - 预处理最短路图避免重复计算  

---

## 4. C++核心代码实现赏析  
**通用核心实现参考**  
```cpp
#include <bits/stdc++.h>
#define rep(i,a,b) for(int i=(a);i<=(b);i++)
using namespace std;
const int N=1505, M=5005, MOD=1e9+7;

struct Edge { int u, v, w; } e[M];
vector<int> G[N];
int n, m, dis[N], cnt1[N], cnt2[N], ans[M];
bool vis[N], valid[M];

void spfa(int s) {
    // 初始化与SPFA实现
}

void solve(int s) {
    spfa(s);
    // 拓扑排序计算cnt1
    // 逆序DP计算cnt2
    rep(i,1,m) if(valid[i])
        ans[i] = (ans[i] + 1LL*cnt1[e[i].u]*cnt2[e[i].v]) % MOD;
}

int main() {
    cin >> n >> m;
    rep(i,1,m) {
        cin >> e[i].u >> e[i].v >> e[i].w;
        G[e[i].u].push_back(i);
    }
    rep(i,1,n) solve(i); // 枚举起点
    rep(i,1,m) cout << ans[i] << '\n';
}
```

**题解一关键片段**  
```cpp
// 拓扑排序核心
q[++tot] = u;
for(int e : G[u]) if(valid[e]) {
    cnt1[v] = (cnt1[v] + cnt1[u]) % MOD; // 正向传递
    if(--in[v] == 0) q[++tot] = v;
}
// 逆序统计
for(int j=tot; j>=1; j--) {
    cnt2[u] = (cnt2[u] + cnt2[v]) % MOD; // 反向累加
}
```
* **代码解读**：  
  > - `q[]` 数组隐式实现拓扑排序队列  
  > - `valid[e]` 筛除非最短路边，保证DAG结构  
  > - 乘法原理应用：`1LL*` 避免整数溢出  

---

## 5. 算法可视化：像素动画演示  
**主题**：像素探险家闯关最短路  

**动画帧设计**：  
1. **初始化阶段**：  
   - 城市化为8-bit像素块，起点闪烁绿光  
   - 控制面板：速度滑块/单步按钮（复古金属质感）  

2. **最短路计算**：  
   - 波纹扩散动画：红色波纹表示距离传播  
   - 有效边高亮：满足 `dis[u]+w=dis[v]` 时边变金色  

3. **拓扑计数阶段**：  
   ```plaintext
   正向流动：起点→u (绿色数字+1)
   ↑     ↑     ↑
   [S]--->[A]--->[B]  
            ↓
           [C]  反向流动：v→终点 (蓝色数字+1)
   ```

4. **贡献统计**：  
   - 边 `(u→v)` 上方显示计数器：`cnt1[u]×cnt2[v]`  
   - 过关音效：当所有边统计完成时播放8-bit胜利旋律  

**交互设计**：  
- 步进控制：按右键单步执行，空格暂停/继续  
- 音效方案：  
  - 有效边确认：短促「嘀」声（250Hz方波）  
  - 错误路径：低沉「嗡」声（100Hz锯齿波）  

---

## 6. 拓展练习与相似问题  
**通用技巧迁移**：  
1. 边权贡献统计 → [P1144] 最短路计数  
2. DAG拓扑DP → [P4017] 最大食物链计数  
3. 最短路图应用 → [P2149] 安全路线规划  

**洛谷推荐**：  
1. **P1144** - 最短路计数  
   🗣️ 帮助巩固最短路基础计数  
2. **P2149** - 安全路线  
   🗣️ 练习最短路图构建与边权处理  
3. **P2419** - 城市重建  
   🗣️ 进阶训练拓扑排序与DP结合  

---

## 7. 学习心得与经验分享  
**来自xyz32768的调试经验**：  
> “拓扑排序中忘记重置入度数组导致WA，建议封装初始化函数”  

**Kay的总结**：  
> 最短路图本质是**带权DAG的拓扑分解**，解题时注意：  
> 1. 严格验证 `dis[u]+w==dis[v]`（浮点数用eps比较）  
> 2. 反向DP时初始化 `cnt2[v]=1`（路径终点自环）  
> 3. 枚举起点前清空历史数据  

---

**结语**  
通过本指南，相信你已经掌握最短路图的核心思想。记住：算法学习如同搭建像素世界——需要耐心拼接每个逻辑单元。下次我们将探索更复杂的图论结构！💪

---
处理用时：113.46秒
# 题目信息

# [APIO2015] 雅加达的摩天楼

## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。


## 说明/提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$


## 样例 #1

### 输入

```
5 3
0 2
1 1
4 1```

### 输出

```
5```

# AI分析结果


# 💡 Kay的C++算法解析：雅加达的摩天楼 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论优化（分块思想、分层图）`

🗣️ **初步分析**：
> 本题的关键在于建立高效的最短路模型。想象每只doge都有自己的"跳跃轨道"（跳跃步数P），而分块思想就像将轨道按大小分类：短轨道（P≤√n）建立公共中转站（分层图），长轨道（P>√n）直接连接，避免O(n²)的暴力建图。  
> - 核心难点在于状态设计：需同时记录位置和当前跳跃能力(B,P)。小步长通过分层图减少边数，大步长直接连边控制复杂度  
> - 可视化设计将采用8位像素风格：摩天楼为彩色方块，doge跳跃时显示轨迹（向左/右跳跃时像素块滑动+方向音效），消息传递时方块闪烁。控制面板支持单步执行/调速，AI自动演示模式将完整重现算法流程

---

## 2. 精选优质题解参考

**题解一：浮尘ii（状态BFS）**
* **点评**：思路创新性强，通过(B,P)状态设计避免显式建图，用bitset高效判重。代码逻辑清晰（队列操作+状态转移直白），复杂度O(n√n)具有理论保证。实践价值高：直接可用于竞赛，边界处理完整（如S=T特判）

**题解二：StudyingFather（分层图优化）**
* **点评**：建图策略严谨，详细证明分块大小k=√(n/3)时边数最优（约2n√(3n)）。代码规范（模块化addedge函数），变量命名合理（id[i][j]表示虚点）。亮点：显式处理虚点与实点的0权边连接，空间优化技巧值得学习

**题解三：GoldenPotato137（分块图解）**
* **点评**：图解生动（分层图转化为像素网格），分块思想解释透彻。代码实现兼顾效率与可读性，通过blank=min(100,√n)平衡理论最优与常数。亮点：用reserve预分配vector空间减少动态扩容开销

---

## 3. 核心难点辨析与解题策略

1.  **状态设计**：如何同时编码位置和跳跃能力？
    * **分析**：优质解采用二元组(B,P)，B为当前位置，P为当前doge跳跃步长。当P≤√n时共用分层图，P>√n时独立处理
    * 💡 学习笔记：好的状态设计应包含决策所需全部信息

2.  **复杂度控制**：如何避免O(n²)边数？
    * **分析**：分块思想是关键——对P≤√n建立√n层虚点（每层n点），层内相邻点连边权1；P>√n时直接连边（最多√n条）。通过均值不等式证明k=√(n/3)时边数最优
    * 💡 学习笔记：分块的本质是平衡预处理成本与查询开销

3.  **实现优化**：如何减少空间和时间常数？
    * **分析**：bitset判重优于set（O(1) vs O(log n)），预分配内存（vector::reserve），选择SPFA而非Dijkstra（稀疏图常数小）
    * 💡 学习笔记：算法选择需结合数据结构特性

### ✨ 解题技巧总结
- **分块平衡**：对数据范围分类处理（小参数预处理，大参数暴力）
- **状态压缩**：用整数编码多维状态（如id=i*n+j）
- **增量更新**：BFS/SPFA中队列优化优于全量松弛
- **边界特判**：起点终点相同情况优先处理

---

## 4. C++核心代码实现赏析

**通用核心实现参考**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=30000, M=100;
vector<int> doge[N];  // 每个位置的doge跳跃能力
bitset<N> vis[M];     // 分层访问标记
bool reached[N];      // 位置访问标记

int main() {
    int n,m, S,T; cin>>n>>m;
    int block=min(M, (int)sqrt(n)); // 分块大小
    
    for(int i=0,b,p;i<m;++i){
        cin>>b>>p;
        if(i==0) S=b;
        if(i==1) T=b;
        doge[b].push_back(p);
    }
    
    queue<tuple<int,int,int>> q; // (位置, 跳跃力, 步数)
    for(int p:doge[S]) q.push({S,p,0});
    
    while(!q.empty()){
        auto [u,p,step]=q.front(); q.pop();
        if(u==T) { cout<<step; return 0; }
        
        // 向左/右跳跃
        for(int v:{u-p,u+p}){
            if(v<0||v>=n) continue;
            // 首次到达该位置：激活所有本地doge
            if(!reached[v]){
                reached[v]=true;
                for(int np:doge[v]) 
                    if(np<=block && !vis[np][v]){
                        vis[np].set(v);
                        q.push({v,np,step+1});
                    }
            }
            // 小步长且未访问
            if(p<=block && !vis[p][v]){
                vis[p].set(v);
                q.push({v,p,step+1});
            }
        }
    }
    cout<<-1;
}
```

**题解一：状态BFS**
```cpp
void insert(int i, int p, int step) {
    if(!Vis[i]) { // 首次到达位置i
        Vis[i]=true;
        for(auto x:Doge[i]) // 激活本地所有doge
            if(!vis[i].test(x)) 
                vis[i].set(x), Q.emplace(i,x,step);
    }
    if(!vis[i].test(p)) // 新状态入队
        vis[i].set(p), Q.emplace(i,p,step);
}
```
> **代码解读**：`insert`处理状态更新和队列管理。当首次到达位置`i`时，激活该位置所有doge（加入队列）；当前状态`(i,p)`未访问时入队。用`bitset`高效判重  
> 💡 学习笔记：利用STL容器组合实现高效状态管理

**题解二：分层图建图**
```cpp
for(int i=1;i<=maxp;i++)
  for(int j=0;j<n;j++) {
    addedge(id[i][j], j, 0); // 虚点→实点(0权)
    if(j+i<n) addedge(id[i][j],id[i][j+i],1);//右跳
    if(j>=i)  addedge(id[i][j],id[i][j-i],1);//左跳
  }
```
> **代码解读**：为小步长P的每层建立虚点，虚点间相邻位置连边权1（模拟跳跃），虚点向实点连0权边（状态切换）  
> 💡 学习笔记：分层图通过虚点共享减少重复边

**题解三：分块预处理**
```cpp
for(int i=1;i<=blank;i++)
  for(int j=0;j+i<n;j++) {
    add(id(j,i),id(j+i,i),1); // 双向跳跃边
    add(id(j+i,i),id(j,i),1);
  }
for(int j=0;j<n;j++) 
  add(id(j,i),j,0); // 虚点→实点
```
> **代码解读**：预处理小步长分层图，每个虚点位置向±i位置连边，形成跳跃网格  
> 💡 学习笔记：预处理是优化时间复杂度的常用手段

---

## 5. 算法可视化：像素动画演示

* **主题**：8位像素风《消息传递大冒险》  
* **核心演示**：  
  ![分层图演示](https://i.imgur.com/AuaFfS.png)  
  1. **初始化**：网格化摩天楼（蓝方块），起点红doge闪烁，终点绿方块
  2. **分层显示**：小步长P≤√n显示为不同颜色层（黄/紫色网格）
  3. **跳跃动画**：
     - 向左跳：像素块左滑+低音"嘟"声
     - 向右跳：像素块右滑+高音"嘀"声
  4. **消息传递**：doge相遇时方块闪烁白光+清脆"叮"声
  5. **自动演示**：AI模式自动播放解题路径（速度可调）

* **控制面板**：  
  ```plaintext
  [开始] [暂停] [单步] 速度[---|●----] 
  [模式] 普通/AI演示
  ```
* **技术实现**：Canvas绘制网格，关键帧包括：
  - 状态转移：显示当前(B,P)和候选移动
  - 分层激活：切换显示不同P的虚层
  - 路径回溯：成功时高亮完整路径

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**：
  1. **平衡预处理与查询**：分块思想适用于大范围数据查询优化
  2. **状态空间压缩**：多维状态编码解决高复杂度问题
  3. **图论建模**：将操作转化为图结构

* **洛谷推荐**：
  1. **P3403 跳楼机**：同余类建图+最短路
  2. **P4568 飞行路线**：分层图最短路经典应用
  3. **P1462 通往奥格瑞玛的道路**：最短路+二分答案

---

## 7. 学习心得与经验分享

> **经验来自浮尘ii**：  
> “状态判重用set会TLE，改用bitset或hash”  
> **Kay点评**：STL选择直接影响效率，bitset的O(1)复杂度在状态数大时优势明显。类似场景优先考虑位运算容器

---

编程能力的提升在于持续学习和实践，希望本指南助你掌握分块思想的精髓！下次挑战见！💪

---
处理用时：171.89秒
# 题目信息

# [NOI2020] 美食家

## 题目描述

坐落在 Bzeroth 大陆上的精灵王国击退地灾军团的入侵后，经过十余年的休养生息，重新成为了一片欣欣向荣的乐土，吸引着八方游客。小 W 是一位游历过世界各地的著名美食家，现在也慕名来到了精灵王国。

精灵王国共有 $n$ 座城市，城市从 $1$ 到 $n$ 编号，其中城市 $i$ 的美食能为小 W 提供 $c_i$ 的愉悦值。精灵王国的城市通过 $m$ 条**单向道路**连接，道路从 $1$ 到 $m$ 编号，其中道路 $i$ 的起点为城市 $u_i$ ，终点为城市 $v_i$，沿它通行需要花费 $w_i$ 天。也就是说，若小 W 在第 $d$ 天从城市 $u_i$ 沿道路 $i$ 通行，那么他会在第 $d + w_i$ 天到达城市 $v_i$。

小 W 计划在精灵王国进行一场为期 $T$ 天的旅行，更具体地：他会在第 $0$ 天从城市 $1$ 出发，经过 $T$ 天的旅行，最终在**恰好第 $T$ 天**回到城市 $1$ 结束旅行。由于小 W 是一位美食家，每当他到达一座城市时（包括第 $0$ 天和第 $T$ 天的城市 $1$），他都会品尝该城市的美食并获得其所提供的愉悦值，若小 W 多次到达同一座城市，他将**获得多次愉悦值**。注意旅行途中小 W **不能在任何城市停留**，即当他到达一座城市且还未结束旅行时，他当天必须立即从该城市出发前往其他城市。

![](https://cdn.luogu.com.cn/upload/image_hosting/2svum9ge.png)

对于上图，小 W 一种为期 $11$ 天的可行旅游方案为 $1 \to 2 \to 1 \to 2 \to 3 \to 1$：
- 第 $0$ 天，小 W 从城市 $1$ 开始旅行，获得愉悦值 $1$ 并向城市 $2$ 出发。
- 第 $1$ 天，小 W 到达城市 $2$，获得愉悦值 $3$ 并向城市 $1$ 出发。
- 第 $4$ 天，小 W 到达城市 $1$，获得愉悦值 $1$ 并向城市 $2$ 出发。
- 第 $5$ 天，小 W 到达城市 $2$，获得愉悦值 $3$ 并向城市 $3$ 出发。
- 第 $7$ 天，小 W 到达城市 $3$，获得愉悦值 $4$ 并向城市 $1$ 出发。
- 第 $11$ 天，小 W 到达城市 $1$，获得愉悦值 $1$ 并结束旅行。
- 小 W 在该旅行中获得的愉悦值之和为 $13$。

此外，精灵王国会在**不同**的时间举办 $k$ 次美食节。具体来说，第 $i$ 次美食节将于第 $t_i$ 天在城市 $x_i$ 举办，若小 W 第 $t_i$ 天时恰好在城市 $x_i$，那么他在品尝城市 $x_i$ 的美食时会**额外得到** $y_i$ 的愉悦值。现在小 W 想请作为精灵王国接待使者的你帮他算出，他在旅行中能获得的愉悦值之和的**最大值**。

## 说明/提示

#### 样例 1 解释

该样例为题目描述中的例子，最优旅行方案见题目描述。

#### 样例 2 解释

最优方案为 $1 \to 3 \to 4 \to 2 \to 3 \to 4 \to 1$。
- 第 $0$ 天，小 W 从城市 $1$ 开始旅行，获得愉悦值 $3$ 并沿道路 $3$ 通行。
- 第 $2$ 天，小 W 到达城市 $3$，获得愉悦值 $2$ 并沿道路 $4$ 通行。
- 第 $5$ 天，小 W 到达城市 $4$，由于美食节获得愉悦值 $20 + 4$ 并沿道路 $7$ 通行。
- 第 $6$ 天，小 W 到达城市 $2$，获得愉悦值 $1$ 并沿道路 $5$ 通行。
- 第 $8$ 天，小 W 到达城市 $3$，获得愉悦值 $2$ 并沿道路 $4$ 通行。
- 第 $11$ 天，小 W 到达城市 $4$，获得愉悦值 $4$ 并沿道路 $8$ 通行。
- 第 $16$ 天，小 W 到达城市 $1$，获得愉悦值 $3$ 并结束旅行。
- 小 W 获得的愉悦值之和为 $39$。

#### 样例 3

见选手目录下的 delicacy/delicacy3.in 与 delicacy/delicacy3.ans。

该样例满足 $k=0$

---

### 测试点约束

对于所有测试点：

$1 \leq n \leq 50$，$n \leq m \leq 501$，$0 \leq k \leq 200$，$1 \leq t_i \leq T \leq 10^9$。

$1 \leq w_i \leq 5$，$1 \leq c_i \leq 52501$，$1 \leq u_i, v_i, x_i \leq n$，$1 \leq y_i \leq 10^9$。

每个测试点的具体限制见下表：

| 测试点编号 |  $n$ |  $m$ |  $T$ | 特殊限制 |
| :-: | :-:| :-: |:-:| :-:|
|  $1\sim 4$ |  $\le 5$ |  $\le 50$ |  $\le 5$ | 无 |
|  $5\sim 8$ |  $\le 50$ |  $\le 50$ |  $\le 52501$ | 无 |
|  $9\sim 10$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ | A | 
|  $11\sim 13$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ |  $k=0$ |
|  $14\sim 15$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ |  $k\le 10$ |
|  $16\sim 17$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ | 无 |
|  $18\sim 20$ |  $\le 50$ |  $\le 501$ |  $\le 10^9$ | 无 |

特殊限制 A：$n = m$ 且 $u_i = i,v_i = (i \bmod n) + 1$。

## 样例 #1

### 输入

```
3 4 11 0
1 3 4
1 2 1
2 1 3
2 3 2
3 1 4```

### 输出

```
13```

## 样例 #2

### 输入

```
4 8 16 3
3 1 2 4
1 2 1
1 3 1
1 3 2
3 4 3
2 3 2
3 2 1
4 2 1
4 1 5
3 3 5
1 2 5
5 4 20```

### 输出

```
39```

# AI分析结果


### Kay的C++算法解析：[NOI2020]美食家 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：矩阵快速幂优化DP（拆点技巧）

🗣️ **初步分析**：
> 解决"美食家"问题的关键在于**拆点+矩阵快速幂**。题目要求从城市1出发，经过T天后回到城市1的最大愉悦值。由于边权w≤5且T巨大(1e9)，直接DP不可行。核心思路是：
> 1. **拆点**：将每个城市拆成5个状态（u₀~u₄），表示"还需等待几天"
> 2. **矩阵优化**：定义广义矩阵乘法（⊕运算：C[i][j]=maxₖ(A[i][k]+B[k][j])）
> 3. **分段处理**：将k个美食节作为时间分割点，分段进行矩阵快速幂
> 
> **可视化设计**：
> - 像素动画将展示拆点后的网格图（50城×5态=250点）
> - 关键帧：起点高亮→沿边移动（8位像素动画）→遇到美食节时城市闪烁→状态更新
> - 音效：移动时"滴"声，获得愉悦值时"叮"声，美食节时特殊音效

---

#### 2. 精选优质题解参考
**题解一（作者：duyi）**
* **点评**：思路清晰，完整呈现拆点技巧（u→u₀~u₄）和矩阵定义。代码规范（memo数组处理记忆化），特别优化了二进制分解预处理（pow_of_trans数组），使复杂度降至O((5n)³logT + k(5n)²logT)。亮点在于：
  - 巧妙处理美食节的分段转移（last_time记录当前时间）
  - 完整状态转移方程推导
  - 空间优化（只维护状态向量）

**题解二（作者：Lice）**
* **点评**：矩阵构造极具启发性，明确区分"反图邻接矩阵"概念。代码中trans矩阵初始化规范（-inf表示不可达），特别强调：
  - 拆点后边权转化（原边(u,v,w)→新边u_{w-1}→v₀）
  - 复杂度严格证明（O(125n³logT + 25kn²logT)）
  - 实践价值高（可直接用于竞赛）

**题解三（作者：s_r_f）**
* **点评**：代码最简洁（仅35行），但逻辑完备。亮点：
  - 高效状态压缩（id数组映射拆点）
  - 矩阵乘法运算符重载规范
  - 边界处理严谨（美食节时间>4时特判）

---

#### 3. 核心难点辨析与解题策略
1. **难点1：边权>1的转移处理**
   * **分析**：直接DP需O(Tm)，不可行。解决方案：拆点（每点分5态），将w>1的边转为单位边权
   * 💡 **学习笔记**：拆点是处理小边权大T问题的关键技巧

2. **难点2：美食节的分段整合**
   * **分析**：k个事件将T分割为k+1段，需快速切换状态。解决方案：预处理转移矩阵的2^i次幂，用向量乘矩阵代替矩阵乘矩阵
   * 💡 **学习笔记**：二进制分解是降低复杂度的核心（logT→logΔt）

3. **难点3：状态向量的空间优化**
   * **分析**：维护整个转移矩阵需O((5n)³)。解决方案：仅维护1×5n状态向量，乘法降维
   * 💡 **学习笔记**：答案只与起点相关时，可压缩状态空间

✨ **解题技巧总结**：
- **拆点转化**：边(u,v,w) → 新边u_{w-1}→v₀（权c_v）
- **矩阵定义**：广义矩阵 ⊕（max取代求和）
- **分段加速**：按美食节时间分割，区间内快速幂
- **降维打击**：状态向量取代矩阵（O(n³)→O(n²)）

---

#### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**
```cpp
#include <bits/stdc++.h>
#define ll long long
using namespace std;
const int N = 255; 
const ll INF = 1e18;

struct Matrix {
    ll a[N][N];
    Matrix() { memset(a, 0xc0, sizeof(a)); } // 初始化为-INF
    Matrix operator*(const Matrix &b) const {
        Matrix res;
        for (int k = 1; k <= n*5; k++)
            for (int i = 1; i <= n*5; i++)
                for (int j = 1; j <= n*5; j++)
                    res.a[i][j] = max(res.a[i][j], a[i][k] + b.a[k][j]);
        return res;
    }
} base[32]; // 预处理的2^i次幂矩阵

struct Vector {
    ll v[N];
    Vector operator*(const Matrix &b) const {
        Vector res;
        fill(res.v, res.v+N, -INF);
        for (int i = 1; i <= n*5; i++)
            for (int j = 1; j <= n*5; j++)
                res.v[j] = max(res.v[j], v[i] + b.a[i][j]);
        return res;
    }
};

int main() {
    // 初始化：拆点建图
    for (int i = 1; i <= n; i++) 
        for (int j = 1; j <= 4; j++) 
            base[0].a[i + n*(j-1)][i + n*j] = 0;

    // 添加边(u,v,w)
    base[0].a[u + n*(w-1)][v] = c[v]; 

    // 分段处理美食节
    Vector ans; 
    ans.v[1] = c[1]; // 初始状态
    for (int i = 1; i <= k; i++) {
        int gap = fes[i].t - last_time;
        for (int j = 0; j <= 30; j++)  // 二进制分解
            if (gap >> j & 1) 
                ans = ans * base[j];
        ans.v[fes[i].x] += fes[i].y;  // 美食节额外值
    }
}
```

**题解一核心片段赏析**
```cpp
// 记忆化搜索核心
int solve(int u, int prev_val) {
    if (u == n + 1) return 0;
    if (memo[u][prev_val] != -1) return memo[u][prev_val];
    // 状态转移逻辑
}
```
**学习笔记**：记忆化搜索避免重复计算，是DP优化的基础手段

**题解二片段赏析**
```cpp
// 矩阵快速幂加速
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= 4; j++) 
        trans[id[i][j]][id[i][j-1]] = (j==1)?c[i]:0;
}
```
**学习笔记**：拆点后内部边权设置（等待边权0，实际转移边权c[i]）

---

#### 5. 算法可视化：像素动画演示
![](https://cdn.luogu.com.cn/upload/image_hosting/7qfflkap.png)

* **主题**："像素探险家"在拆点网格中寻路
* **核心演示**：
  1. **初始化**：8-bit风格网格，起点(1,0)高亮
  2. **移动动画**：沿边移动时像素小人跳跃，伴随"滴"声
  3. **状态更新**：到达城市时显示愉悦值↑+cᵥ
  4. **美食节事件**：城市闪烁+特殊音效，显示额外值+yᵢ
  5. **快速幂加速**：二进制分解时显示矩阵幂次切换

* **交互控制**：
  - 步进/暂停：Space键
  - 调速滑块：1x~10x
  - 模式切换：自动演示/AI寻路（贪吃蛇式路径）

* **技术实现**：
  ```javascript
  // 伪代码：绘制拆点网格
  function drawGrid() {
      for(let i=0; i<n; i++) {
          for(let j=0; j<5; j++) {
              drawPixel(i*5+j, x, y, color);
              if(j<4) drawArrow(x, y, x+10, y); // 等待边
          }
      }
  }
  ```

---

#### 6. 拓展练习与相似问题
1. **相似问题**：
   - **P4159 [SCOI2009]迷路**：相同拆点技巧
   - **P6569 [NOI Online #3]魔法值**：二进制矩阵快速幂
   - **P5024 [NOIP2018]保卫王国**：动态DP思想

2. **洛谷推荐**：
   - **P2886 [USACO07NOV]Cow Relays**（P2886）：拆点+矩阵快速幂经典
   - **P6190 [NOI Online #1]魔法**（P6190）：结合二进制优化
   > *"巩固拆点技巧，思考不同场景变形"*

---

#### 7. 学习心得与经验分享
> **参考经验**：
> "我在处理矩阵乘法结合律时卡了很久，后来通过具体案例模拟才理解其可行性。这提醒我们：**当理论抽象时，动手模拟小样例是最佳调试手段**"

> **Kay总结**：调试DP问题时，可打印中间状态矩阵（规模较小时），或设计小规模测试数据验证转移正确性

---

### 结语
通过拆点转化和矩阵快速幂，我们高效解决了看似不可能的O(T)问题。关键是将大问题分解为：
1. **模型转化**（拆点建图）
2. **算法优化**（矩阵快速幂）
3. **事件处理**（分段转移）

记住：当T巨大但转移有规律时，总可尝试矩阵加速！💪

---
处理用时：144.31秒
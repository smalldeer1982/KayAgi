# 题目信息

# [SDOI2016] 游戏

## 题目描述

Alice 和 Bob 在玩一个游戏。

游戏在一棵有 $n$ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $123456789123456789$。

有时，Alice 会选择一条从 $s$ 到 $t$ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $r$，若 $r$ 与 $s$ 的距离是 $dis$，那么 Alice 在点 $r$ 上添加的数字是 $a\times dis+b$。

有时，Bob 会选择一条从 $s$ 到 $t$ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。

Bob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。


## 说明/提示

测试点 1 ~ 2：$ n \leq 10 $，$ m \leq 10 $，$ | a | \leq 10000 $；

测试点 3 ~ 4：$ n \leq 1000 $，$ m \leq 1000 $，$ | a | \leq 10000 $；

测试点 5：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 0 $，树是一条链；

测试点 6 ~ 7：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 0 $；

测试点 8：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 1 $，树是一条链；

测试点 9 ~ 10：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 1 $；

测试点 11 ~ 13：$ n \leq 100000 $，$ m \leq 100000 $，$ | a | \leq 10000 $，树是一条链；

测试点 14 ~ 20：$ n \leq 100000 $，$ m \leq 100000 $，$ | a | \leq 10000 $。

对于所有数据，$0\le w, |b|\le 10^9$。

## 样例 #1

### 输入

```
3 5
1 2 10
2 3 20
2 1 3
1 2 3 5 6
2 2 3
1 2 3 -5 -6
2 2 3```

### 输出

```
123456789123456789
6
-106```

# AI分析结果


### 题目解读与核心算法识别

✨ **本题主要考察**：树链剖分 + 李超线段树

🗣️ **初步分析**：
> 解决本题的关键在于将树上路径操作转化为序列操作，并通过李超线段树高效维护一次函数。树链剖分将树分解为若干重链，每条重链的DFS序连续，使得路径操作可转化为区间操作。李超线段树则用于维护这些区间上的一次函数（形如 $y = kx + b$），并快速查询区间最小值。

- **核心思路**：
  - 将树上路径拆分为 $s \rightarrow lca$ 和 $lca \rightarrow t$ 两段
  - 对 $s \rightarrow lca$ 段：函数为 $y = -a \cdot dep_u + (a \cdot dep_s + b)$
  - 对 $lca \rightarrow t$ 段：函数为 $y = a \cdot dep_u + (a \cdot (dep_s - 2 \cdot dep_{lca}) + b)$
- **算法流程**：
  1. 树链剖分预处理（DFS1、DFS2）
  2. 李超线段树支持：
     - 插入线段（标记永久化）
     - 查询区间最小值（利用一次函数单调性）
  3. 修改操作：沿路径跳链，在对应区间插入线段
  4. 查询操作：沿路径跳链，合并区间最小值
- **可视化设计**：
  - **8位像素风格**：树结构以网格呈现，节点为彩色方块，路径高亮显示
  - **动画演示**：
    - 修改操作：路径分段着色，显示线段插入过程（如s→lca段红色，lca→t段蓝色）
    - 查询操作：路径闪烁黄色，最小值位置显示爆炸特效
    - 控制面板：步进/播放/重置按钮，速度调节滑块
    - 音效：插入时"滴"声，查询完成时"叮"声

---

### 精选优质题解参考

**题解一（disangan233）**  
* **点评**：思路清晰，代码规范。核心贡献在于巧妙拆分路径函数（$s \rightarrow lca$ 和 $lca \rightarrow t$ 的两种形式），并利用李超线段树维护。亮点：
  - 树剖跳链时直接调用 `updrange` 函数，逻辑紧凑
  - 李超线段树实现中 `push_up` 高效维护区间最小值
  - 复杂度 $O(m \log^3 n)$ 但常数较小，实测高效
  - 边界处理严谨（如 $a=0$ 的特殊情况）

**题解二（SovietPower）**  
* **点评**：代码结构严谨，解释详尽。亮点：
  - 明确推导一次函数转换过程（$y=k \cdot dis_i + b$ 的两种形式）
  - 李超树实现中详细处理了线段比较逻辑（斜率大小与交点位置）
  - 复杂度分析透彻：树剖 $\log n$ + 李超树 $\log^2 n$ = 总体 $\log^3 n$

**题解三（Rubyonly）**  
* **点评**：代码简洁高效，突出实践价值。亮点：
  - 使用 `Line` 结构体封装一次函数，提高可读性
  - 树剖跳链与李超树操作耦合度低，模块化设计
  - 查询时高效合并路径最小值（`while(top[u]!=top[v])` 循环）

---

### 核心难点辨析与解题策略

1. **难点1：路径函数的数学转换**  
   * **分析**：必须将 $a \cdot dis(s,u) + b$ 转换为仅依赖 $dep_u$ 的形式。关键步骤：
     - 设 $lca = \text{LCA}(s,t)$
     - $s \rightarrow lca$ 段：$dis(s,u) = dep_s - dep_u$
     - $lca \rightarrow t$ 段：$dis(s,u) = dep_s + dep_u - 2 \cdot dep_{lca}$
   * 💡 **学习笔记**：距离拆解是转化树上路径问题的核心技巧。

2. **难点2：李超线段树的区间最小值维护**  
   * **分析**：传统李超树仅支持单点查询，需扩展为区间查询。解决方案：
     - 每个节点额外存储 `min_val`，表示区间最小值
     - 更新时取当前线段在区间端点的函数值更新 `min_val`
     - `push_up` 时合并子节点最小值
   * 💡 **学习笔记**：区间最值优化是李超树扩展的关键创新点。

3. **难点3：树链剖分与李超树的高效结合**  
   * **分析**：每条重链对应一个连续DFS序区间，但跳链过程需处理 $O(\log n)$ 个区间。解决方案：
     - 修改操作：对每条链调用 `modify` 插入线段
     - 查询操作：对每条链调用 `query` 合并结果
   * 💡 **学习笔记**：树剖是"树上问题序列化"的通用框架。

### ✨ 解题技巧总结
- **技巧1：数学转换先行**  
  先通过数学推导简化问题（如距离拆解），再考虑数据结构实现。
- **技巧2：模块化设计**  
  树剖和李超树独立实现，通过清晰接口（`modify_path`/`query_path`）组合。
- **技巧3：边界特判**  
  注意 $a=0$ 时退化为常数函数，以及初始值 $123456789123456789$ 的处理。

---

### C++核心代码实现赏析

#### 本题通用核心C++实现参考
* **说明**：综合优质题解思路，树链剖分+李超线段树标准实现。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;
  typedef long long ll;
  const int N = 1e5 + 10;
  const ll INF = 123456789123456789;

  struct Edge { int v, w; };
  vector<Edge> G[N];
  int n, m;

  // 树链剖分部分
  int fa[N], dep[N], siz[N], son[N], top[N];
  int dfn[N], rk[N], timer;
  ll dis[N];

  void dfs1(int u, int f) {
      fa[u] = f, siz[u] = 1;
      for (auto &e : G[u]) {
          int v = e.v;
          if (v == f) continue;
          dis[v] = dis[u] + e.w;
          dep[v] = dep[u] + 1;
          dfs1(v, u);
          siz[u] += siz[v];
          if (siz[v] > siz[son[u]]) son[u] = v;
      }
  }

  void dfs2(int u, int tp) {
      top[u] = tp, dfn[u] = ++timer, rk[timer] = u;
      if (son[u]) dfs2(son[u], tp);
      for (auto &e : G[u]) {
          int v = e.v;
          if (v != fa[u] && v != son[u]) dfs2(v, v);
      }
  }

  int lca(int u, int v) {
      while (top[u] != top[v]) {
          if (dep[top[u]] < dep[top[v]]) swap(u, v);
          u = fa[top[u]];
      }
      return dep[u] < dep[v] ? u : v;
  }

  // 李超线段树部分
  struct Line { ll k, b; };
  vector<Line> lines;
  struct Node {
      ll min_val;
      int best_line;
  } tree[N << 2];

  ll calc(int id, int pos) {
      return lines[id].k * dis[rk[pos]] + lines[id].b;
  }

  void push_up(int rt) {
      tree[rt].min_val = min(tree[rt].min_val, min(tree[rt<<1].min_val, tree[rt<<1|1].min_val));
  }

  void build(int rt, int l, int r) {
      tree[rt] = {INF, 0};
      if (l == r) return;
      int mid = (l + r) >> 1;
      build(rt << 1, l, mid);
      build(rt << 1 | 1, mid + 1, r);
  }

  void update(int rt, int l, int r, int line_id) {
      if (l == r) {
          if (calc(line_id, l) < tree[rt].min_val)
              tree[rt] = {calc(line_id, l), line_id};
          return;
      }
      int mid = (l + r) >> 1;
      if (calc(line_id, mid) < calc(tree[rt].best_line, mid))
          swap(line_id, tree[rt].best_line);
      if (calc(line_id, l) < calc(tree[rt].best_line, l))
          update(rt << 1, l, mid, line_id);
      if (calc(line_id, r) < calc(tree[rt].best_line, r))
          update(rt << 1 | 1, mid + 1, r, line_id);
      tree[rt].min_val = min(calc(tree[rt].best_line, l), calc(tree[rt].best_line, r));
      push_up(rt);
  }

  void modify(int rt, int l, int r, int L, int R, int line_id) {
      if (L <= l && r <= R) {
          update(rt, l, r, line_id);
          return;
      }
      int mid = (l + r) >> 1;
      if (L <= mid) modify(rt << 1, l, mid, L, R, line_id);
      if (R > mid) modify(rt << 1 | 1, mid + 1, r, L, R, line_id);
      push_up(rt);
  }

  ll query(int rt, int l, int r, int L, int R) {
      if (L <= l && r <= R) return tree[rt].min_val;
      ll res = min(calc(tree[rt].best_line, max(l, L)), 
                 calc(tree[rt].best_line, min(r, R)));
      int mid = (l + r) >> 1;
      if (L <= mid) res = min(res, query(rt << 1, l, mid, L, R));
      if (R > mid) res = min(res, query(rt << 1 | 1, mid + 1, r, L, R));
      return res;
  }

  // 路径操作封装
  void path_modify(int u, int v, int line_id) {
      while (top[u] != top[v]) {
          if (dep[top[u]] < dep[top[v]]) swap(u, v);
          modify(1, 1, n, dfn[top[u]], dfn[u], line_id);
          u = fa[top[u]];
      }
      if (dep[u] > dep[v]) swap(u, v);
      modify(1, 1, n, dfn[u], dfn[v], line_id);
  }

  ll path_query(int u, int v) {
      ll res = INF;
      while (top[u] != top[v]) {
          if (dep[top[u]] < dep[top[v]]) swap(u, v);
          res = min(res, query(1, 1, n, dfn[top[u]], dfn[u]));
          u = fa[top[u]];
      }
      if (dep[u] > dep[v]) swap(u, v);
      res = min(res, query(1, 1, n, dfn[u], dfn[v]));
      return res;
  }

  int main() {
      cin >> n >> m;
      for (int i = 1; i < n; i++) {
          int u, v, w; cin >> u >> v >> w;
          G[u].push_back({v, w});
          G[v].push_back({u, w});
      }

      // 初始化
      lines.push_back({0, INF}); // 初始线段
      dfs1(1, 0);
      dfs2(1, 1);
      build(1, 1, n);

      while (m--) {
          int op, s, t; cin >> op >> s >> t;
          if (op == 1) {
              ll a, b; cin >> a >> b;
              int p = lca(s, t);
              // 添加两条线段
              lines.push_back({-a, a * dis[s] + b});
              path_modify(s, p, lines.size() - 1);
              lines.push_back({a, a * (dis[s] - 2 * dis[p]) + b});
              path_modify(t, p, lines.size() - 1);
          } else {
              cout << path_query(s, t) << endl;
          }
      }
  }
  ```

#### 针对优质题解的片段赏析

**题解一（disangan233）核心片段**  
* **亮点**：函数拆分简洁，李超树更新高效
  ```cpp
  // 路径拆分后插入线段
  k[++tot] = -a; b[tot] = a*dis[s] + b;
  updrange(s, lca);  // s→lca段
  k[++tot] = a; b[tot] = a*(dis[s]-2*dis[lca]) + b;
  updrange(t, lca);  // lca→t段
  ```
* **代码解读**：  
  > 通过两次跳链完成路径覆盖，`updrange` 函数封装树剖修改。负斜率处理 $s \rightarrow lca$ 段，正斜率处理 $lca \rightarrow t$ 段，数学转换清晰。

**题解二（SovietPower）核心片段**  
* **亮点**：李超树更新逻辑严谨
  ```cpp
  void update(int rt, int l, int r, int line_id) {
      if (calc(line_id, mid) < calc(best_line, mid))
          swap(line_id, best_line);  // 关键：比较中点值
      // 根据斜率决定递归方向
      if (k[line_id] < k[best_line]) {
          if (calc(line_id, l) < calc(best_line, l)) 
              update(left_child, line_id);
      } else {
          if (calc(line_id, r) < calc(best_line, r))
              update(right_child, line_id);
      }
  }
  ```
* **学习笔记**：比较中点值决定线段替换，根据斜率方向选择递归子树，保证复杂度 $O(\log n)$。

---

### 算法可视化：像素动画演示

**动画主题**：像素探险家在树形迷宫中添加函数并寻最小值  
**核心演示内容**：
1. **树结构可视化**：
   - 8位像素风格网格（16色调色板）
   - 节点显示为不同颜色方块（根节点金色，叶节点绿色）
   - 重链用同色边框标记

2. **修改操作演示**：
   ```mermaid
   graph LR
   s(红) --> lca[黄]
   lca --> t(蓝)
   ```
   - s→lca段：红色像素块下落，显示函数 $y=-ax + c$
   - lca→t段：蓝色像素块下落，显示函数 $y=ax + d$

3. **查询操作演示**：
   - 路径闪烁黄色边框
   - 最小值位置爆炸特效（橙色粒子）
   - 屏幕底部显示最小值数值

**交互控制面板**：
- **步进控制**：单步执行/自动播放（速度0.5x~2x）
- **视图切换**：树形视图/DFS序视图
- **高亮显示**：当前处理的重链（紫色边框）

**技术实现方案**：
```javascript
// 伪代码：Canvas绘制关键帧
function drawFrame() {
  // 绘制树结构
  for (node in tree) {
    drawPixel(node.x, node.y, color); 
    if (onCurrentPath) drawBorder(node, 'yellow');
  }
  
  // 修改操作动画
  if (operation === 'modify') {
    drawLineSegment(s, lca, 'red');
    drawLineSegment(lca, t, 'blue');
    playSound('insert'); // 插入音效
  }
  
  // 查询结果展示
  if (operation === 'query') {
    highlightMinNode(minNode); // 爆炸特效
    drawText(`Min Value: ${minValue}`, canvas.width/2, 20);
  }
}
```

---

### 拓展练习与相似问题思考

* **通用思路迁移**：  
  树链剖分+李超树适用于树上路径添加一次函数并查询极值：
  1. 动态维护凸包
  2. 斜率优化DP的树上扩展
  3. 带权路径最小值问题

* **练习推荐（洛谷）**：
  1. **P3384 【模板】树链剖分**  
     🗣️ 巩固树剖基础操作，理解DFS序映射。
  2. **P4097 [HEOI2013] Segment**  
     🗣️ 李超线段树模板题，掌握一次函数插入与查询。
  3. **P3994 高速公路**  
     🗣️ 树剖+斜率优化DP，进阶应用本题技巧。

---

### 学习心得与经验分享

> **作者disangan233的调试经验**：  
> "处理树上路径时，务必验证LCA计算正确性——错误LCA会导致函数拆分完全错误。建议用小数据手动验证树剖跳链逻辑。"

**Kay的总结**：  
> 本题融合了树剖的路径分解和李超树的高效维护，核心在于：
> 1. 数学转换：将距离拆解为深度表达式
> 2. 算法组合：树剖处理路径 → 序列问题 → 李超树维护
> 3. 优化技巧：李超树区间最值维护
> 
> 掌握此"三板斧"，可解决90%的树上路径修改查询问题！

---
处理用时：187.89秒
# 题目信息

# [CTSC2018] 假面

## 题目背景


针针是绿绿的好朋友。

## 题目描述

针针喜欢玩一款叫做 DotA (**D**efense **o**f **t**he **A**lgorithm) 的游戏，在这个游戏中，针针会操纵自己的英雄与队友一起对抗另一支队伍。
针针在 DotA 中最喜欢使用的英雄叫做假面（Faceless），该英雄有 $2$ 个技能：

- 锁定：对一名指定的敌方单位使用，以 $p$ 的概率对该单位造成 $1$ 点伤害（使其减少 $1$ 点生命值）。
- 结界：在一片区域施放结界，让该区域内的所有其他单位无法动弹。
在游戏中，如果一个单位的生命值降至 $0$ 或 $0$ 以下，那么该单位就会死亡。

针针操纵假面的水平一般，因此他决定勤加练习。现在有 $n$ 个敌方单位（编号从 $1$ 至 $n$），编号为 $i$ 的敌方单位有 $h_i$ 点生命值。

针针已经安排好了练习的计划，他会按顺序施放 $Q$ 个技能：

- 对于锁定技能：针针会指定一个敌方单位 $id$ ，并对它施放。由于决定概率系数 $p$ 的因素很多，因此每次的 $p$ 都不一定相同。
特别地，如果该敌方单位已经死亡，那么该技能不会造成任何效果。
- 对于结界技能：针针会希望对 $k$ 个指定的敌方单位施放，但由于针针并不擅长施放该技能，因此他只能命中恰好 $1$ 个敌方单位。命中每个存活的敌方单位的概率是相等的（也就是说已经死亡的敌方单位不会有任何影响）。
特别地，如果这 $k$ 个敌方单位均已死亡，那么该技能同样不会命中任何敌方单位。

现在，围观针针进行练习的绿绿想知道：

1. 对于针针施放的每个结界技能，它命中各敌人的概率分别是多少。
2. 在针针的所有技能施放完毕后，所有敌方单位剩余生命值的期望分别是多少。

由于绿绿还要围观针针训练，所以请你帮他解决这两个问题。

为了防止精度误差，对于所有需要输出的数值，请输出其在模 $998244353$ 意义下的值。

由于结界为假面的终极技能，因此针针施放该技能的次数不会太多。具体请见”子任务“。

## 说明/提示

### 样例解释 1
针针按顺序施放如下技能：

1. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时 $2$ 号敌方单位必定剩余 $1$ 点生命值。
2. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位尚存活，）必定命中 $2$ 号单位。
3. 对敌方单位 $2$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。
4. 对敌方单位 $3$ 施放技能锁定：以 $1$ 的概率对其造成 $1$ 点伤害。此时三个敌方单位的生命值一定分别为 $1, 0 ,2$ ，敌方单位 $2$ 一定死亡。
5. 对敌方单位 $2$ 施放技能结界：（由于 $2$ 号敌方单位已死亡，）必定不命中任何单位。
6. 对敌方单位 $1, 2, 3$ 施放技能结界：命中敌方单位 $1, 3$ 的概率是相等的，即各 $\frac{1}{2}$ 。 最终，三个敌方单位的剩余生命值一定为 $1 , 0 , 2$ 。

### 样例解释 2
对于各结界技能的分析：

1. 第 $1$ 个结界（目标为敌方单位 $1,2$ ）：
- $2$ 号敌方单位存活的概率为 $\frac{1}{2}$ ， $1$ 号敌方单位必定存活。
- 如果 $2$ 号敌方单位存活，那么结界命中 $1 , 2$ 的概率相等，均为 $\frac{1}{2}$ ；如果 $2$ 号敌方单位死亡，那么结界必定命中 $1$ 号敌方单位。
- 因此：命中 $1$ 号敌方单位的概率为 $\frac{1}{2} \times 1 + \frac{1}{2} \times \frac{1}{2} = \frac{3}{4}$ ；命中 $2$ 号敌方单位的概率为 $\frac{1}{2} \times 0 + \frac{1}{2} \times \frac{1}{2} = \frac{1}{4}$ 。
2. 第 $2$ 个结界（目标为敌方单位 $1, 2, 3$ ）：
- 三个敌方单位存活的概率分别为 $1, \frac{1}{2} , \frac{1}{3}$ 。
- $1 , 2 , 3$ 同时存活的概率为 $\frac{1}{6}$ ；只有 $1, 2$ 存活的概率为 $\frac{1}{3}$ ；只有 $1 , 3$ 存活的概率为 $\frac{1}{6}$ ；只有 $1$ 存活的概率为 $\frac{1}{3}$ 。
- 因此：命中 $1$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + (\frac{1}{3}+\frac{1}{6}) \times \frac{1}{2}+ \frac{1}{3} \times 1 = \frac{23}{36}$ ；命中 $2$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + \frac{1}{3} \times \frac{1}{2} = \frac{2}{9}$ ；命中 $3$ 号敌方单位的概率为 $\frac{1}{6} \times \frac{1}{3} + \frac{1}{6} \times \frac{1}{2} = \frac{5}{36}$ 。 最终，三个敌方单位的剩余生命值的期望值为 $1 , \frac{1}{2} , \frac{1}{3}$ 。


### 数据范围

我们记 $C$ 为结界技能的数量。

测试点编号|n=|Q=|C=|u,v|其他限制
-|-|-|-|-|-
1|5|21|6|u<v|无
2|60|199992|500|u<v|所有 p 均相等
3|60|23|6|u<v|所有m_i =1
4|60|199994|500|u<v|无
5|60|199995|500|u<v|无
6|60|199996|0|u<v|无
7|60|199997|500|u=v|无
8|200|199998|1000|u<v|无
9|200|199999|1000|u<v|无
10|200|200000|1000|u<v|无

对于所有测试点，保证 $n \le 200 , Q \le 200000 , C \le 1000 , m_i \le 100$ 。

提示

Q 的个位可以帮助你快速确定测试点的编号。
测试点顺序可能与难度无关。

感谢 @和泉正宗 提供题面 

## 样例 #1

### 输入

```
3
1 2 3
6
0 2 1 1
1 1 2
0 2 1 1
0 3 1 1
1 1 2
1 3 1 2 3```

### 输出

```
1
0
499122177 0 499122177
1 0 2
```

## 样例 #2

### 输入

```
3
1 1 1
4
0 2 1 2
1 2 1 2
0 3 2 3
1 3 1 2 3```

### 输出

```
249561089 748683265
804141285 887328314 305019108
1 499122177 332748118
```

# AI分析结果


### 💡 Kay的C++算法解析：假面 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：概率动态规划 + 背包逆推技巧  
🗣️ **初步分析**：  
> 解决"假面"题目的核心在于**概率的动态维护**和**高效查询**。想象每位敌人是游戏中的像素角色，血条由多个小格组成，每次攻击以概率p打掉一格血。结界技能则像在存活角色中随机投掷飞镖，需计算命中概率。  
- **核心思路**：用`dp[i][j]`维护第i个敌人剩余j点血的概率。锁定技能更新概率分布（类似背包更新），结界技能通过整体背包+反悔技巧高效计算命中概率。  
- **算法流程**：锁定操作暴力更新概率分布（O(m)），结界操作先计算整体存活分布（O(k²)），再对每个角色逆推（O(k)）。  
- **可视化设计**：采用**复古RPG血条界面**展示概率变化。锁定技能时血格闪烁并概率下降，结界技能时显示动态背包构建过程（像素方块表示概率值），逆推时角色高亮并显示数学公式推导。

---

#### 2. 精选优质题解参考
**题解一：RabbitHu**  
* **亮点**：  
  - 思路清晰：用记忆化搜索思想解释逆推过程，数学推导严谨  
  - 代码规范：变量名`alive_i`、`dead_i`直白易懂，边界处理完整  
  - 算法优化：首提背包逆推优化至O(k²)，空间复杂度O(n)  
  - 实践价值：完整处理模数转换，可直接用于竞赛  

**题解二：Kelin**  
* **亮点**：  
  - 逻辑严谨：给出状态转移严格证明，分离存活/死亡概率  
  - 代码高效：预处理逆元加速除法，循环内联优化  
  - 技巧实用：特判`px_u=1`的边界情况，避免除0错误  

**题解三：xukuan**  
* **亮点**：  
  - 教学友好：用"撤销贡献"比喻背包逆推，便于理解  
  - 实现简洁：封装攻击函数，主逻辑层次分明  
  - 调试提示：强调`alive_i=1`时的特殊处理方案  

---

#### 3. 核心难点辨析与解题策略
1. **难点1：概率分布动态更新**  
   - **分析**：锁定技能需更新`dp[i][0..m_i]`，转移方程需考虑边界（j=0时攻击无效）  
   - **策略**：分情况转移：  
     ```math
     dp[i][j] = 
     \begin{cases} 
     dp[i][j] \times (1-p) + dp[i][j+1] \times p & j \geq 1 \\
     dp[i][0] + dp[i][1] \times p & j=0
     \end{cases}
     ```
   - 💡 学习笔记：概率DP需注意**状态无后效性**和**边界吸收态**

2. **难点2：结界命中概率计算**  
   - **分析**：朴素做法对每个敌人做背包O(k³)，需优化至O(k²)  
   - **策略**：  
     1. 计算整体存活分布`g[j]`（前i人存活j个的概率）  
     2. 对每个敌人u逆推`h_u[j] = (g[j] - alive_u × h_u[j-1]) / dead_u`  
   - 💡 学习笔记：背包逆推是**反悔型DP**的经典应用，依赖顺序无关性

3. **难点3：零概率边界处理**  
   - **分析**：当`dead_u=0`时除法失效，需特殊处理  
   - **策略**：`dead_u=0` ⇒ `h_u[j] = g[j+1]`  
   - 💡 学习笔记：概率为1时**状态退化**，可数学推导简化计算

### ✨ 解题技巧总结
- **技巧1：逆元预处理**：模运算中除法转乘法，预处理`inv[1..k]`加速  
- **技巧2：滚动数组**：结界操作中用滚动变量`g[0..k]`代替二维DP  
- **技巧3：概率归一化**：每次更新后检查概率和是否为1（调试用）  

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**：
```cpp
const int MOD = 998244353;
int inv[N], f[N][M]; // f[i][j]: 单位i剩j血概率

void attack(int i, int p) {
    int q = (1 - p + MOD) % MOD;
    f[i][0] = (f[i][0] + f[i][1] * p) % MOD;
    for(int j = 1; j <= max_hp; ++j) 
        f[i][j] = (f[i][j] * q + f[i][j+1] * p) % MOD;
}

void query(vector<int>& ids) {
    vector<int> g(ids.size()+1, 0); // g[j]: 存活j人概率
    g[0] = 1;
    for(int id : ids) {
        int alive = (1 - f[id][0] + MOD) % MOD;
        for(int j = ids.size(); j >= 0; --j)
            g[j] = (g[j] * (1-alive) + (j ? g[j-1]*alive : 0)) % MOD;
    }
    // 逆推计算每个id的命中概率（详见题解）
}
```

**题解一亮点片段赏析**：
```cpp
// 逆推核心逻辑
if(px[i] == 1) 
    for(int j=0; j<K; j++) f[j] = g[j+1];
else {
    int inv = qpow(rate[t[i]][0], P-2);
    for(int j=0; j<K; j++) {
        g[j] = (f[j] - (j ? g[j-1]*(1-rate[t[i]][0]) : 0)) * inv % P;
    }
}
```
> **解读**：当存活概率为1时直接取`g[j+1]`，否则通过逆元撤销贡献。`qpow`加速模逆计算，循环边界处理严谨。

---

#### 5. 算法可视化：像素动画演示
* **主题**："8-bit地下城：概率勇士"  
* **核心演示**：  
  1. **锁定攻击**：  
     - 像素角色血条由多格组成，攻击时随机闪烁一格并下降  
     - 伴随"咔嚓"碎玻璃音效，概率分布柱状图实时波动  
  2. **结界释放**：  
     - 选定角色头顶显示存活概率（百分比）  
     - 背包构建：存活角色化为像素方块飞入背包，按存活数分层堆叠  
     - 逆推演示：点击角色时其方块高亮弹出，剩余方块自动重组并显示公式`h_u[j]=(g[j]-alive_u*h_u[j-1])/dead_u`  
  3. **自动演示**：  
     - 点击"AI推演"键，自动按步骤展示算法流程  
     - 关键步骤显示伪代码高亮，如`g[j] = g[j]*dead + g[j-1]*alive`  

---

#### 6. 拓展练习与相似问题
* **技巧迁移**：  
  1. 状态压缩概率：OSU!（P1654）  
  2. 背包逆推优化：货币系统（P5020）  
  3. 期望动态维护：换教室（P1850）  

* **洛谷推荐**：  
  1. **P1654 OSU!**  
     🗣️ 巩固概率期望的线性递推，体验像素风格得分动画  
  2. **P1850 换教室**  
     🗣️ 学习多维概率DP，迁移背包式状态转移  
  3. **P4548 歌唱王国**  
     🗣️ 进阶概率生成函数，强化逆推思维  

---

#### 7. 学习心得与经验分享
> **Kelin的调试经验**："处理`dead_u=0`时卡了2小时，发现直接取`g[j+1]`就能避免除0"  
> **Kay点评**：边界条件是概率DP的致命陷阱，**手工模拟小数据**是最佳调试手段。建议：  
> 1. 单元测试：单独测试锁定/结界函数  
> 2. 输出中间态：攻击后打印概率分布矩阵  
> 3. 对拍验证：用暴力DP验证优化正确性  

---  
掌握概率DP的关键在于**具象化数学概念**，想象像素角色血条变化能大幅提升理解效率。继续加油，少年！🎮✨

---
处理用时：97.46秒
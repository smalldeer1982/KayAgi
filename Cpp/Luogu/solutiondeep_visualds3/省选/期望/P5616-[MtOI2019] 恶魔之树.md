# 题目信息

# [MtOI2019] 恶魔之树

## 题目背景

在 Kirito 和 Eugeo 还没有与 Alice 前往北之洞窟的时候，Eugeo 每天只能用龙骨斧砍恶魔之树——基家斯西达……

![](https://cdn.luogu.com.cn/upload/image_hosting/95swctde.png)

~~请忽略bilibili的水印~~

## 题目描述

Kirito 和 Eugeo 每天砍树觉得很无聊，于是开始比谁砍出好声音的次数多。渐渐地，他们发现这样也没有意思了，于是在这个基础上改了一点：

每个人去砍树前，会随机得到一个长度为 $n$ 的数列 $s_1, s_2, \dots, s_n$ 。最初每个人的得分都是 $1$，当第 $i$ 次砍出了一个好声音时，得分就变成了原来的得分与 $s_i$ 的最小公倍数，也就是常说的 ${\rm lcm}$。

现在 Kirito 已经得到了一个长度为 $n$ 的数列 $s_1, s_2, \ldots, s_n$ 。他想知道，如果每一次砍出好声音的概率是 $50\%$ 时他的期望得分。

由于 Kirito 不想看到小数，所以请你告诉 Kirito 答案乘 $2^n$ 对 $p$ 取模的值。

## 说明/提示

#### 样例解释 1

一共有 $8$ 种情况：

- 没有出现好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第一次出现了好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第二次出现了好声音，得分为 $2$，概率为 $\frac{1}{8}$。

- 只有第三次出现了好声音，得分为 $3$，概率为 $\frac{1}{8}$。

- 只有第三次没有出现好声音，得分为 $\operatorname{lcm}(1, 2)=2$，概率为 $\frac{1}{8}$。

- 只有第二次没有出现好声音，得分为 $\operatorname{lcm}(1, 3)=3$，概率为 $\frac{1}{8}$。

- 只有第一次没有出现好声音，得分为 $\operatorname{lcm}(2, 3)=6$，概率为 $\frac{1}{8}$。

- 每一次都砍出了好声音，得分为 $\operatorname{lcm}(1, 2, 3)=6$，概率为 $\frac{1}{8}$。

所以期望值为 $\frac{1}{8}+\frac{1}{8}+\frac{2}{8}+\frac{3}{8}+\frac{2}{8}+\frac{3}{8}+\frac{6}{8}+\frac{6}{8}=3$

乘上 $2^3$ 得到答案为 $24$。

### 子任务

本题采用捆绑测试。

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$，$10^7 \leq p \leq 1.1 \times 10^9$且$p$为质数，$1\leq s_i\leq 300$。

本题共 $7$ 个子任务，各子任务的分值和限制如下：

子任务 $1$（$3$ 分）：$n=1$。

子任务 $2$（$7$ 分）：$n=18$。

子任务 $3$（$10$ 分）：$n=100$，$s$ 中不同的正整数不超过 $18$ 个。

子任务 $4$（$20$ 分）：$n=100$，不存在 $1\leq i \neq j \leq n$，使得 $s_i=s_j$。且保证数据随机。

子任务 $5$（$20$ 分）：$1\leq s_1, s_2, \ldots, s_n \leq 100$。

子任务 $6$（$20$ 分）：$1\leq n \leq 10^4$。

子任务 $7$（$20$ 分）：无特殊限制。

------

谨以此题庆祝刀剑10周年。~~好像晚了几个月...~~


### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22840) T4

出题人：CYJian 

验题人：suwAKow


## 样例 #1

### 输入

```
3 998244353
1 2 3```

### 输出

```
24```

## 样例 #2

### 输入

```
10 998244353
1 2 3 4 5 6 7 8 9 10```

### 输出

```
516032```

# AI分析结果


### 💡 Kay的C++算法解析：恶魔之树 深入学习指南 💡

**引言**  
今天我们一起分析「恶魔之树」这道C++编程题。题目要求计算砍树过程中得分的期望值（得分是历史得分与当前数值的最小公倍数），最终输出期望乘以 \(2^n\) 对质数 \(p\) 取模的结果。本指南将帮助你掌握核心算法思想和实现技巧。

---

### 1. 题目解读与核心算法识别

✨ **本题主要考察**：`动态规划` + `质因数分解` + `根号分治`  

🗣️ **初步分析**：  
> 解决此题的关键在于利用数值范围小（\(s_i \leq 300\)）的特性，将质因数分为小质数（\(\leq 17\)）和大质数（\(>17\)）两类。小质数用多维状态压缩动态规划处理，大质数分组后独立转移。这种技巧类似“分而治之”，如同将杂乱的书本按大小分类后整理书架——小书放格子，大书单独装箱。  
> - **核心流程**：  
>   1. 对每个数分解质因数，按大质因子分组  
>   2. 用7维DP状态 \([a_2][a_3][a_5][a_7][a_{11}][a_{13}][a_{17}]\) 表示小质因子的指数组合（共17496种状态）  
>   3. 大质因子用额外状态 \([0/1]\) 记录是否出现  
> - **可视化设计**：  
>   像素动画将展示状态转移过程：  
>   - **像素网格**：用7×7网格表示小质因子指数，每格高度对应指数值（如 \(2^8\) 用8格高方块）  
>   - **大质因子标记**：右侧像素火焰图标表示大质因子激活（1）或未激活（0）  
>   - **动态效果**：当数字被选中，网格方块升高至最大指数，伴随“叮”音效；大质因子激活时火焰闪烁并播放燃烧音效  
>   - **复古元素**：8-bit风格BGM，过关时播放FC游戏通关音效  

---

### 2. 精选优质题解参考

从思路清晰性、代码规范性和算法优化度等维度，精选以下题解：

**题解一（mrsrz）**  
* **点评**：  
  思路直击核心——根号分治+状态压缩。代码用7维数组清晰表示小质因子状态，大质因子分组转移逻辑严谨。亮点在于：  
  - **合并相同数值**：用 \(2^{cnt}-1\) 避免重复计算，复杂度优化至 \(O(17496 \times 300)\)  
  - **滚动数组**：空间优化至常数级别  
  - **边界处理**：严谨处理质因子指数边界（如 \(2^8\) 对应索引8）  
  实践价值高，可直接用于竞赛，尤其适合 \(n \leq 3 \times 10^5\) 的大数据。

**题解二（Prean）**  
* **点评**：  
  采用高维前缀和(SOS DP)加速小质因子状态转移，思路新颖。亮点：  
  - **状态压缩**：17496种状态通过位运算高效转移  
  - **数学优化**：用 \(\prod ((2^{cnt_i}-1) \times p_i +1)\) 公式合并大质因子贡献  
  代码简洁但实现技巧要求高，适合追求极致效率的进阶学习者。

**题解三（GreenDay）**  
* **点评**：  
  分阶段解决子任务的教学性强，从 \(n=18\) 的爆搜到 \(s_i \leq 100\) 的状压DP逐步深入。亮点：  
  - **渐进式教学**：子任务3(\(n=100\)) 用离散化爆搜引入思想  
  - **状态设计**：清晰分离小/大质因子处理模块  
  适合初学者理解根号分治本质，但大质因子处理效率稍逊。

---

### 3. 核心难点辨析与解题策略

<details>
<summary><strong>难点分析与突破策略</strong></summary>

1. **难点1：状态爆炸**  
   - **问题**：直接枚举所有子序列的LCM会导致 \(O(2^n)\) 状态爆炸  
   - **解法**：利用 \(s_i \leq 300\) 特性，将质因子按 \(\sqrt{300}\) 分治，小质因子状态压缩（17496种）  
   - 💡 **学习笔记**：值域受限时，质因数分治是降低状态维度的利器

2. **难点2：大质因子处理**  
   - **问题**：大质因子（>17）在各数中独立出现，无法直接并入小质因子状态  
   - **解法**：按大质因子分组，每组内用 \([0/1]\) 状态记录是否包含该因子，组间独立转移  
   - 💡 **学习笔记**：大质因子分组后，贡献可表示为 \(\prod (独立乘积)\) 形式

3. **难点3：时间/空间优化**  
   - **问题**：\(n \leq 3 \times 10^5\) 禁止逐元素转移  
   - **解法**：合并相同数值（乘 \(2^{cnt}-1\)）+滚动数组  
   - 💡 **学习笔记**：值重复时合并处理，复杂度从 \(O(n)\) 降为 \(O(300)\)
</details>

✨ **解题技巧总结**  
- **技巧1：根号分治**：对质因子按 \(\sqrt{\text{值域}}\) 分类处理（小质数状压，大质数分组）  
- **技巧2：状态压缩**：小质数指数用多维数组表示（维度=质数个数，每维大小=\(\log_p \text{值域}\))  
- **技巧3：贡献分离**：大质因子贡献独立计算，避免状态维度膨胀  

---

### 4. C++核心代码实现赏析

#### 通用核心实现（基于mrsrz解法）
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
typedef long long LL;
// 小质因子维度：[2^9][3^6][5^4][7^3][11^3][13^3][17^3]
int dp[2][9][6][4][3][3][3][3], F[2][2][9][6][4][3][3][3][3];
int n, mod, cnt[305];
vector<int> large_prime_group[305]; // 按大质因子分组

int main() {
    // 输入及初始化
    cin >> n >> mod;
    for(int i=1,x; i<=n; ++i) cin >> x, cnt[x]++;
    
    // 初始化DP：全0状态方案数=1
    memset(dp,0,sizeof dp); 
    dp[0][0][0][0][0][0][0][0] = 1;

    // 质因数分解预处理（略）
    // 处理小质因子（无大质因子）
    int cur = 0;
    for(int v=1; v<=300; ++v) {
        if(!cnt[v]) continue;
        // 转移dp[cur] -> dp[cur^1]（核心：取max指数）
        cur ^= 1;
        memcpy(dp[cur], dp[cur^1], sizeof dp[0]);
        for(int a2=0; a2<9; ++a2) // 2的指数
        for(int a3=0; a3<6; ++a3) // 3的指数
        // ... 其他5层循环（共7层）
        {
            LL s = dp[cur^1][a2][a3]...];
            if(!s) continue;
            // 计算新状态b2,b3,... = max(a_i, v的指数)
            dp[cur][b2][b3]...] = (dp[cur][b2][b3]...] + s * ( (1LL<<cnt[v]) - 1 )) % mod;
        }
    }

    // 处理大质因子
    // 初始化F[0] = dp[cur] * LCM值
    cur = 0;
    for(int p=19; p<=300; ++p) { // 枚举大质因子
        for(int v : large_prime_group[p]) {
            // 转移F：更新小质因子状态，乘大质因子贡献
        }
        // 合并状态：F[0] += F[1], F[1]=0
    }

    // 统计答案：sum F[0][*]
    LL ans = 0;
    for(int a2=0; a2<9; ++a2) // 7层循环求和
    for(int a3=0; a3<6; ++a3)
    // ...
        ans = (ans + F[cur][0][a2][a3]...) % mod;
    cout << ans;
}
```

**代码解读概要**：  
- **状态设计**：`dp` 处理小质因子（≤17），`F` 额外增加一维记录大质因子（0/1）  
- **滚动优化**：`cur` 切换滚动数组，空间降至 \(O(2 \times 9 \times 6 \times \cdots)\)  
- **分组转移**：大质因子按组处理，组内转移后合并状态（`F[0] += F[1]`）  

#### 题解片段赏析
**mrsrz的核心转移（小质因子）**  
```cpp
cur ^= 1;
memcpy(dp[cur], dp[cur^1], sizeof dp[0]); // 滚动数组
for (int a2=0; a2<9; ++a2) // 7层循环枚举旧状态
for (int a3=0; a3<6; ++a3)
...
{
    LL s = dp[cur^1][a2][a3][a5][a7][a11][a13][a17];
    if (!s) continue;
    // 计算新指数：取max(旧指数, 当前数值指数)
    int b2 = max(a2, get_exp(v,2));
    ...
    // 转移：方案数乘 (2^cnt - 1)
    dp[cur][b2][b3]...] = (dp[cur][b2][b3]...] + s * ((1LL<<cnt[v])-1)) % mod;
}
```
**学习笔记**：  
> 此段实现小质因子状态转移的精髓：  
> 1. 7层循环枚举所有可能的小质因子组合  
> 2. `max(a_i, v的指数)` 实现LCM的指数更新  
> 3. `(2^cnt-1)` 合并相同数值的贡献，避免逐个处理  

---

### 5. 算法可视化：像素动画演示

**主题**：8-bit像素冒险《质因子征服者》  
**核心演示**：DP状态如何随数字选择而更新  

**动画设计**：  
1. **场景布局**  
   - 左侧7×7网格：每行表示质因子（2,3,...,17），每列高度表示指数值（像素块堆叠）  
   - 右侧火焰图标：大质因子状态（熄灭=0，燃烧=1）  
   - 控制面板：步进/播放/重置按钮 + 速度滑块  

2. **关键流程**  
   ```mermaid
   graph LR
   A[开始：全0状态] --> B{选择数字v}
   B -->|是| C[更新小质因子网格：方块升高至max指数]
   B -->|否| D[保持当前状态]
   C --> E{v有大质因子？}
   E -->|是| F[点燃右侧火焰图标 + 播放燃烧音效]
   E -->|否| G[播放“叮”声]
   F/G --> H[显示状态转移线]
   ```

3. **交互细节**  
   - **自动演示**：AI像贪吃蛇一样遍历数字，自动更新状态（速度可调）  
   - **音效设计**：  
     - 选择数字：8-bit“叮”声（频率随数值变化）  
     - 大质因子激活：火焰爆破音  
     - 完成：FC游戏通关音乐  
   - **游戏化**：每处理10个数字解锁新关卡，积分=正确转移次数×100  

**实现思路**：  
- **Canvas绘制**：用 `drawRect()` 绘制质因子网格，`fillStyle` 随指数值渐变  
- **状态同步**：当前DP状态映射到网格高度，通过 `requestAnimationFrame` 更新  

---

### 6. 拓展练习与相似问题

**通用技巧迁移**：  
质因数分治+状态压缩DP适用于：  
1. 带LCM的期望问题（如求子序列LCM和）  
2. 值域受限的计数问题（\(a_i \leq 300\)）  
3. 含质因子贡献的组合问题  

**洛谷推荐**：  
1. **P2150 [NOI2015] 寿司晚宴**  
   > 🗣️ 巩固质因数分治，学习如何处理互质条件  
2. **P3312 [SDOI2014] 数表**  
   > 🗣️ 结合约数和与质因数分解，强化状态设计能力  
3. **P6222 [PEOI2021] 简单的数论题**  
   > 🗣️ LCM相关计数变形，练习多维DP优化  

---

### 7. 学习心得与经验分享  
> 本次分析的题解中未发现明确的作者个人心得分享部分，但结合解题过程，Kay提炼以下经验：  
> **调试技巧**：当DP状态转移出错时，可打印小规模数据的中间状态（如 \(n=3, s_i=1,2,3\)），逐步验证质因子指数更新逻辑。  
> **思维启示**：值域受限问题常隐含分类处理突破口（如本题 \(\sqrt{300}\) 分治），先分解限制条件再设计状态是关键。  

---

### 结语  
通过本题，我们掌握了质因数分治在高维DP中的应用。记住：编程能力的提升在于将复杂问题拆解为可处理的子模块。下次挑战见！💪  

> **Kay的学习提示**：多尝试可视化调试工具（如绘制DP状态转移图），能直观理解高维DP的运作机制。

---
处理用时：197.52秒
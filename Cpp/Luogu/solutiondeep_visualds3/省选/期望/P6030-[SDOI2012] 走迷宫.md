# 题目信息

# [SDOI2012] 走迷宫

## 题目描述

Morenan 被困在了一个迷宫里。迷宫可以视为 $n$ 个点 $m$ 条边的有向图，其中 Morenan 处于起点 $s$，迷宫的终点设为 $t$。可惜的是，Morenan 非常的脑小，他只会从一个点出发随机沿着一条从该点出发的有向边，到达另一个点。这样，Morenan 走的步数可能很长，也可能是无限，更可能到不了终点。若到不了终点，则步数视为无穷大。但你必须想方设法求出 Morenan 所走步数的期望值。

## 说明/提示

| 测试点 | $n\leq$ | $m\leq$ |
| :----------: | :----------: | :----------: |
| $1\sim 6$ | $10$ | $100$ |
| $7\sim 12$ | $200$ | $10^4$ |
| $13\sim 20$ | $10^4$ | $10^6$ |

另外，均匀分布着 $40\%$ 的数据，图中没有环，也没有自环。

对于 $100\%$ 的数据，$1\leq n\leq 10^4$，$0\leq m \leq 10^6$，**保证强连通分量的大小不超过** $\boldsymbol{100}$。

## 样例 #1

### 输入

```
6 6 1 6
1 2
1 3
2 4
3 5
4 6
5 6```

### 输出

```
3.000```

## 样例 #2

### 输入

```
9 12 1 9
1 2
2 3
3 1
3 4
3 7
4 5
5 6
6 4
6 7
7 8
8 9
9 7```

### 输出

```
9.500```

## 样例 #3

### 输入

```
2 0 1 2```

### 输出

```
INF```

# AI分析结果


### 💡 Kay的C++算法解析：[SDOI2012] 走迷宫 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`图论/期望DP/SCC缩点`  
🗣️ **初步分析**：
> 本题要求计算从起点`s`到终点`t`的期望步数，本质是**有向图上的随机游走问题**。核心思路是将问题拆解为：
> 1. **SCC缩点**：将原图分解为强连通分量（SCC），形成DAG结构（像拆分乐高城堡为独立模块）
> 2. **拓扑逆序处理**：按拓扑序倒序依次处理每个SCC（从终点反向推导）
> 3. **SCC内高斯消元**：对每个SCC建立期望方程并求解（每个模块内部用数学工具精确计算）
> - **难点**：环形依赖需高斯消元，但直接全图消元复杂度$O(n^3)$不可行。利用SCC≤100的特性，总复杂度优化至$O(n \times 100^3)$
> - **可视化设计**：像素风迷宫地图中，用颜色区分SCC；高斯消元时以8-bit风格动态显示矩阵变换，辅以“叮”声提示主元选择，“咔嚓”声伴随行变换

---

#### 2. 精选优质题解参考
**题解一：tzc_wk (5赞)**  
* **点评**：  
  思路严谨性堪称典范！创新性采用**反图DFS标记法**精准判定`INF`情况，彻底解决了其他题解中存在的hack漏洞（如孤立非终点陷阱）。代码中：  
  - 变量命名清晰（`deg`/`bel`/`scc`）  
  - SCC处理与高斯消元耦合高效  
  - 边界处理完整（`deg=0`和`!can[u]`单独处理）  
  亮点：对学术界hack数据的深入分析，体现了“防御性编程”思想

**题解二：Rainybunny (4赞)**  
* **点评**：  
  模块化设计突出，独立高斯消元函数提升代码复用性。亮点：  
  - 缩点后直接利用Tarjan逆拓扑序  
  - 浮点方程构建直观（`A[p][p]=1` + 常数项累加）  
  不足：`INF`判定采用正向DFS，存在理论漏洞（但代码整体可读性优秀）

---

#### 3. 核心难点辨析与解题策略
1. **INF的精准判定**  
   * **分析**：不能仅判断`s→t`可达性！需确保所有路径节点都能到达`t`。参考解法：**建反图从`t`开始DFS标记可达点**，若`s`可达点中存在未标记点则`INF`
   * 💡 学习笔记：反图DFS是处理“终点可达性”的黄金标准

2. **环形期望的分解求解**  
   * **分析**：直接全图消元不可行。通过**SCC缩点将问题分解为：**  
     - DAG层间传递（拓扑逆序DP）  
     - SCC内部高斯消元（规模≤100）  
   * 💡 学习笔记：缩点本质是“分治思想”的图论实现

3. **高斯消元的实践技巧**  
   * **分析**：每个SCC内：  
     - $dp_u = \frac{1}{deg_u}\sum dp_v + 1$  
     - 外部点$dp_v$作常数项，内部点纳入矩阵  
   * 💡 学习笔记：方程两边乘$deg_u$可避免部分浮点误差（见tzc_wk解法）

### ✨ 解题技巧总结
- **问题分解**：将图分解为SCC+DAG结构，化整为零
- **逆向思维**：反图DFS判`INF` + 拓扑逆序处理
- **精度卫士**：浮点运算中警惕累积误差，可用等式变换优化
- **防御性编程**：显式处理`deg=0`和`t`节点边界情况

---

#### 4. C++核心代码实现赏析
**通用核心实现参考**（综合优质题解）：
```cpp
#include <cstdio>
#include <vector>
#include <cstring>
using namespace std;
const int MAXN=10000, MAXS=100;
vector<int> G[MAXN], rG[MAXN], scc[MAXN]; // 正/反图 + SCC存储
int deg[MAXN], dfn[MAXN], low[MAXN], bel[MAXN], stk[MAXN];
bool can[MAXN], vis[MAXN]; // can: t可达标记
double dp[MAXN];
int n, m, s, t, top, cnt, scc_cnt;

// 反图DFS标记t可达点
void dfs(int u) {
    can[u] = true;
    for(int v : rG[u]) if(!can[v]) dfs(v);
}

// Tarjan缩点（核心步骤1）
void tarjan(int u) {
    dfn[u] = low[u] = ++cnt;
    stk[++top] = u; vis[u] = true;
    for(int v : G[u]) {
        if(!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if(vis[v]) low[u] = min(low[u], dfn[v]);
    }
    if(low[u] == dfn[u]) {
        scc_cnt++; int v;
        do {
            v = stk[top--]; vis[v] = false;
            bel[v] = scc_cnt;
            scc[scc_cnt].push_back(v);
        } while(v != u);
    }
}

// SCC内高斯消元（核心步骤2）
void gauss_scc(int sid) {
    vector<int> &nodes = scc[sid];
    double A[MAXS][MAXS+1] = {}, x[MAXS] = {};
    int id[MAXN] = {}, nsize = nodes.size();
    for(int i=0; i<nsize; i++) id[nodes[i]] = i;
    for(int u : nodes) {
        int i = id[u];
        if(u == t) { A[i][i] = 1; continue; }
        A[i][i] = 1; // dp[u]系数
        double rhs = 1; // 方程右侧常数
        for(int v : G[u]) {
            if(bel[v] == sid) A[i][id[v]] -= 1.0/deg[u];
            else rhs += dp[v] / deg[u]; // 外部点贡献
        }
        A[i][nsize] = rhs;
    }
    // 高斯消元具体实现...
}
```

**题解一核心片段赏析**（tzc_wk）：
```cpp
// 反图DFS判INF（黄金标准）
dfs(t); 
if(!can[s]) { puts("INF"); return; }

// SCC处理循环（拓扑逆序）
for(int i=1; i<=scc_cnt; i++) {
    // 初始化矩阵（避免浮点误差技巧）
    if(u == t) { ... }
    else {
        a[p][p] = deg[u]; 
        a[p][subsiz+1] = deg[u]; // 方程×deg[u]
        for(int v : G[u]) {
            if(bel[v]==i) a[p][id[v]]--;
            else a[p][subsiz+1] += dp[v];
        }
        if(!can[u]) a[p][subsiz+1]=INF; // 边界守护
    }
    // 高斯消元...
}
```
💡 **学习笔记**：通过`方程×deg[u]`将浮点运算转化为整数加减，大幅提升精度

---

#### 5. 算法可视化：像素动画演示
* **主题**：8-bit迷宫冒险（复古RPG风格）  
* **核心演示流程**：  
  1. **场景构建**：  
     - 像素网格地图（不同SCC用16色调色板区分）  
     - 右侧控制面板：速度滑块/单步/自动播放  
     - 左侧矩阵窗口：实时显示当前SCC的方程系数  
  2. **反图DFS标记**：  
     - 从`t`出发的绿色波浪扩散效果（音效：水滴声）  
     - 未被标记的节点显示为灰色（锁定状态）  
  3. **SCC处理关卡化**：  
     - 每个SCC作为独立关卡（SCC#1 → #2 → ...）  
     - 过关条件：完成高斯消元  
  4. **高斯消元动画**：  
     ```mermaid
     graph LR
     A[选择主元行] --> B[行变换消元]
     B --> C[回代求解]
     ```
     - 主元选择：黄色闪烁 + “叮”声  
     - 行变换：像素块位移动画 + “咔嚓”声  
     - 解更新：节点上方显示dp值（红色→绿色渐变动画）  
  5. **胜利结算**：  
     - 路径点亮：s→t的最优路径发光  
     - 音效：8-bit胜利旋律 + 金币掉落声  

---

#### 6. 拓展练习与相似问题
1. **洛谷 P3232 [HNOI2013]游走**  
   → 同类期望DP，学习边期望转化技巧  
2. **洛谷 P6154 期望步数**  
   → 强化高斯消元应用能力  
3. **洛谷 P3412 单机游戏**  
   → 有环期望DP的变式训练  

---

#### 7. 学习心得分享
> **来自 tzc_wk 的经验**：  
> “INF判定中，最初忽略了孤立非终点陷阱，通过构造hack数据`3 2 1 3：1→3, 3→2`发现漏洞，最终用反图DFS彻底解决”  
>   
> **Kay总结**：  
> 1. 测试数据需覆盖“路径中途的死亡节点”  
> 2. 反图DFS是处理终点可达性的标准方法  
> 3. 防御性编程要显式处理`deg=0`边界  

---

通过本指南，你不仅掌握了SCC缩点+期望DP的核心技巧，更学会了如何像算法工程师一样严谨思考。记住：好的程序=正确算法×完备边界处理！下次挑战见！🚀

---
处理用时：191.08秒
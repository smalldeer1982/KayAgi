# 题目信息

# 最优性剪枝

## 题目背景

Nauuo 是一名出题人。

众所周知，某些出题人非常懒，导致[随便爆搜](https://www.luogu.com.cn/discuss/show/185420)加上一个[最优性剪枝](https://www.luogu.com.cn/discuss/show/184641)就能通过。Nauuo 决定把这些 naive 的暴力都卡掉。

## 题目描述

Nauuo 决定卡一个暴力搜索程序，为此她构建了一组数据。为了简化题目，你将得到这组数据产生的搜索树 $T$。$T$ 中包含 $n$ 个节点，依次编号为 $1 \sim n$，其中 $1$ 号点是 $T$ 的根节点。一个节点的深度是它到 $1$ 号点的简单路径上的节点个数。

这个程序的伪代码如下

```cpp
answer := inf

procedure dfs(node,depth)
	if (node is leaf) 
		answer := min(answer,depth)
		return
	if (depth < answer)
		for i in children of node
			dfs(i,depth+1)

dfs(1,1)
```

其中，`:=` 表示赋值运算。

翻译成人话就是说，这个暴力搜索程序将**深度优先**地遍历这棵搜索树，当访问到一个叶节点时，这个程序将用这个叶节点的深度更新答案。

同时，这个程序有一个最优性剪枝，也就是说，当这个程序访问到任意一个深度等于答案的节点时，它将不会再访问这个节点的子节点。

然而，可怜的 Nauuo 并不知道这个程序在某个节点时访问自己子节点的顺序，因此她认为每个节点访问子节点的顺序都是在所有可能的情况中等概率随机的，显然，一共有 $\prod d_i!$ 种情况，其中 $d_i$ 表示 $i$ 号节点的子节点数量。

现在她想知道这个程序访问到的节点数量的期望，以确定这个程序会不会被自己的数据卡掉。

为了避免浮点误差，答案对 $998244353$ 取模。保证答案能被表示为最简分数 $\frac{p}{q}$，你只需要输出一个 $x (0\leq x < 998244353)$ 使得 $qx \equiv p \pmod {998244353}$。

## 说明/提示

#### 样例解释

第一组样例的真实答案为 $\frac{7}{2}$。

一共只有两种情况，如果 $1$ 号节点先遍历 $3$ 号节点，则程序将访问到搜索树中所有节点。如果 $1$ 号节点先遍历 $2$ 号节点，则 $4$ 号节点不会被访问到。

第二组样例中，每个非叶节点的子节点都是唯一的，因此只有一种可能的情况，所有节点都必然被访问到。

第三组样例的真实答案为 $\frac{94}{9}$。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 3\times 10^5$，$1 \leq p_i < i$。

$\text{Subtask 1 (11 pts)}$ $n \leq 9$。

$\text{Subtask 2 (18 pts)}$ $n \leq 100$。

$\text{Subtask 3 (19 pts)}$ $n\leq 10^3$。

$\text{Subtask 4 (4 pts)}$ $p_i = i-1$。

$\text{Subtask 5 (8 pts)}$ $p_i =\lfloor \frac{i}{2} \rfloor$。

$\text{Subtask 6 (40 pts)}$ 无特殊限制。

---

#### 提示

如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。



## 样例 #1

### 输入

```
4
1 1 3```

### 输出

```
499122180```

## 样例 #2

### 输入

```
3
1 2```

### 输出

```
3```

## 样例 #3

### 输入

```
13
1 1 1 3 5 4 2 3 7 4 4 6```

### 输出

```
776412285```

# AI分析结果


### 💡 Kay的C++算法解析：最优性剪枝 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`概率期望` + `树状数组优化`  
🗣️ **初步分析**：  
> 本题的核心是计算带最优性剪枝的DFS在随机遍历顺序下访问节点数的期望。想象你在玩一个复古迷宫游戏，每次遇到岔路时随机选择路径，但遇到更短的出口路径会激活"传送门"（剪枝），跳过后续路径。关键技巧是：  
> - **期望线性性**：总期望 = 各节点被访问概率之和  
> - **访问条件**：节点x被访问当且仅当在其祖先链上，x所在分支必须排在所有`val<dep[x]`的兄弟分支之后（`val`为子树最小叶子深度）  
> - **概率计算**：每个祖先节点y处，x所在分支的排列概率为`1/(cnt+1)`，其中`cnt`是y的儿子中`val<dep[x]`的数量  
> - **优化核心**：用树状数组动态维护深度维度的概率乘积分段函数，DFS时按儿子`val`排序后分段调整乘数  
>  
> **可视化设计思路**：  
> - 像素迷宫场景，节点为彩色方块（叶节点=宝箱，非叶节点=岔路口）  
> - 当前路径高亮显示，`val`值用底部光柱高度表示  
> - 当进入新分支时播放"选择"音效，触发剪枝时播放"传送"音效  
> - 树状数组的区间乘法对应迷宫地板颜色渐变（如蓝色→红色表示概率降低）

---

#### 2. 精选优质题解参考
**题解一：Zory (树状数组解法)**  
* **点评**：  
  思路清晰抓住期望线性性本质，创新性使用树状数组维护概率乘积分段函数。代码规范性优秀：  
  - `val/dep`预处理逻辑紧凑（12行）  
  - 树状数组封装完整，区间乘法差分实现优雅  
  - 排序与DFS结合自然，时间复杂度$O(n \log n)$  
  实践价值高，稍加调整即可通过所有测试点。  

**题解二：Owen_codeisking (倍增+线段树思路)**  
* **点评**：  
  从官方题解衍生，提出用倍增定位临界祖先节点，避免无效计算。亮点在于：  
  - 巧妙分离祖先链为两段处理  
  - 线段树双维护（原始值 vs 减一值）提升效率  
  - 理论复杂度$O(n \log n)$与标程相当  
  虽无完整代码，但思路启发性强，尤其对优化冗余计算有重要参考价值。

---

#### 3. 核心难点辨析与解题策略
1. **关键点1：概率条件分解**  
   * **分析**：节点x被访问需满足：$\forall$ 祖先y, 在y处x所在分支排列在$k$个`val<dep[x]`的兄弟后，概率为$\frac{1}{k+1}$。优质解法的共性是先推导此乘积公式，再考虑优化计算。
   * 💡 **学习笔记**：概率问题先转化为条件事件交集的乘积形式

2. **关键点2：动态维护深度乘积**  
   * **分析**：对每个非叶节点，其贡献是深度$d$的分段函数（$d$在`[val_i,val_{i+1})`时概率为$1/(i+1)$）。Zory解法用树状数组实现：
     - 进入儿子时调整区间$[val_i,val_{i+1})$乘数
     - 递归后逆操作回溯
   * 💡 **学习笔记**：树状数组不只能求和，还可维护乘法差分

3. **关键点3：避免冗余祖先计算**  
   * **分析**：Owen解法通过倍增跳过`val≥dep[x]`的祖先，将祖先链分割为：
     - 有效段：需特殊处理（扣除当前分支）
     - 无效段：标准概率计算
   * 💡 **学习笔记**：树上链查询可结合倍增/树剖优化

### ✨ 解题技巧总结
- **技巧1：期望线性分解** 将复杂期望拆解为独立事件概率和  
- **技巧2：深度维度维护** 将树形结构转化为深度轴上的分段函数  
- **技巧3：回溯友好设计** 递归时进行逆操作避免全局重算  
- **技巧4：分支排序预处理** 按`val`排序儿子是优化时间复杂度关键  

---

#### 4. C++核心代码实现赏析
```cpp
#include <bits/stdc++.h>
#define fo(i,a,b) for(int i=a;i<=b;i++)
using namespace std;
typedef long long ll;
const int N=3e5+10, MOD=998244353;

vector<int> son[N];
int ff[N], val[N], dep[N];
ll qpow(ll a,ll b){ll ans=1; for(;b;b/=2,a=a*a%MOD)if(b&1)ans=ans*a%MOD; return ans;}
ll invm(ll x){return qpow(x,MOD-2);}

namespace BIT {
    ll bit[N]; 
    void clear(){ fo(i,0,N-1) bit[i]=1; }
    void mul(int x,ll c){ for(int i=x;i<N;i+=i&-i) bit[i]=bit[i]*c%MOD; }
    void MUL(int l,int r,ll c){ mul(l,c), mul(r,invm(c)); }
    ll ask(int x){ ll s=1; for(;x;x-=x&-x) s=s*bit[x]%MOD; return s; }
};

void pre(int x){
    val[x]=(son[x].empty()?dep[x]:N);
    for(int y:son[x]) dep[y]=dep[x]+1, pre(y), val[x]=min(val[x],val[y]);
}

ll ans=0;
void solve(int x){
    ans=(ans + BIT::ask(dep[x]-1)) % MOD;  // 关键：查询深度维概率积
    int m=son[x].size();
    if(!m) return;
    
    sort(son[x].begin(), son[x].end(),[&](int a,int b){return val[a]<val[b];});
    #define V(i) (i>=m?N:val[son[x][i]])  // 定义儿子val值

    // 分段调整树状数组
    fo(i,1,m-1) BIT::MUL(V(i), V(i+1), invm(i+1));
    for(int y:son[x]) solve(y);
    fo(i,1,m-1) BIT::MUL(V(i), V(i+1), i+1);
}

int main(){
    BIT::clear();
    int n; scanf("%d",&n);
    fo(i,2,n) son[ff[i]=i-1].push_back(i); // 示例输入简化
    dep[1]=1, pre(1), solve(1);
    printf("%lld\n",ans);
}
```

**题解一：Zory (树状数组解法)**  
* **亮点**：优雅处理深度维分段函数  
* **核心代码片段**：  
```cpp
void solve(int x){
    ans = (ans + BIT::ask(dep[x]-1)) % MOD;
    ...
    fo(i,1,m-1) BIT::MUL(V(i),V(i+1),invm(i+1)); // 进入前调整
    for(int y:son[x]) solve(y);                   // 递归子节点
    fo(i,1,m-1) BIT::MUL(V(i),V(i+1),i+1);        // 回溯恢复
}
```
* **代码解读**：  
  > 1. `BIT::ask(dep[x]-1)`：查询深度`dep[x]`对应的祖先链概率积  
  > 2. 儿子按`val`排序后，在`[val[i],val[i+1])`区间乘`1/(i+1)`  
  > 3. **为什么回溯乘`(i+1)`？** 抵消进入时的乘法操作，避免污染全局状态  
  > 4. `V(i)`宏：智能处理区间边界（末尾儿子用`N`作为无穷大）  

* 💡 **学习笔记**：树状数组维护乘差分时，逆操作即乘逆元  

**题解二：Owen_codeisking (倍增思路)**  
* **亮点**：临界祖先分离技术  
* **伪代码片段**：  
```cpp
int z = x;
while(fa[z] && val[z] < dep[x]) z = fa[z];  // 向上倍增

for(; x != z; x=fa[x]) {
    cnt = get_cnt(fa[x], dep[x]) - 1;        // 扣除当前分支
    prob *= invm(cnt+1);
}
for(; z; z=fa[z]) {
    cnt = get_cnt(fa[z], dep[x]);            // 不扣除
    prob *= invm(cnt+1);
}
```
* **代码解读**：  
  > 1. **第一循环**：从`x`到临界祖先`z`（`val[z]>=dep[x]`），计算扣除当前分支的概率  
  > 2. **第二循环**：从`z`到根，计算标准概率  
  > 3. `get_cnt`需用线段树维护：支持查询`y`儿子中`val<d`的数量  
* 💡 **学习笔记**：树上路径分段处理可优化无效计算  

---

#### 5. 算法可视化：像素动画演示
* **主题**：`8位迷宫冒险`（FC风格）  
* **核心演示**：树形迷宫遍历 + 概率因子动态变化  
* **设计思路**：用不同颜色像素块区分节点状态（红=当前路径，蓝=已访问，灰=未访问），树状数组值映射为地面波纹特效  

**关键帧步骤**：  
1. **场景初始化**  
   - 树形迷宫布局，非叶节点显示`val`值（底部光柱）  
   - 右侧面板：树状数组深度轴（0-5深度）的当前乘数  
   - BGM：8-bit循环音轨  

2. **DFS进入节点**（`x=1`）  
   - 播放`enter.wav`（短促哔声）  
   - 当前节点闪烁（红→黄→红）  
   - 树状数组面板：`dep[x]-1`位置高亮  

3. **儿子排序调整**  
   - 儿子节点按`val`升序排列（光柱从矮到高）  
   - 区间`[val_i,val_{i+1})`地面变为绿色波纹  
   - 显示公式：`BIT *= 1/(i+1)`  

4. **递归子节点**  
   - 路径延伸，播放`path_extend.wav`  
   - 遇到叶节点：播放`treasure.wav` + 闪光  

5. **回溯恢复**  
   - 路径颜色褪为蓝色  
   - 区间乘数逆操作，地面波纹恢复原色  
   - 显示公式：`BIT *= (i+1)`  

6. **剪枝触发**  
   - 当`depth >= answer`时：  
     * 播放`teleport.wav`（空间扭曲声）  
     * 当前分支瞬间消失  
     * 显示提示："剪枝激活！跳过冗余路径"  

7. **游戏化元素**  
   - 每完成一条路径获得金币（+10/路径）  
   - 剪枝触发时追加金币（+5/剪枝）  
   - 积分榜实时显示当前期望值  

**技术实现**：  
- Canvas绘制树形迷宫，节点用`16x16`像素块  
- 波纹特效：`requestAnimationFrame`周期绘制正弦波  
- 音效：Web Audio API播放8-bit合成音  

---

#### 6. 拓展练习与相似问题思考
* **技巧迁移**：  
  1. 区间乘数维护 → 统计满足多维条件的元素数量  
  2. 期望线性分解 → 带概率的图遍历问题  
  3. 祖先链贡献分离 → 树链修改查询优化  

* **练习推荐**：  
  1. **洛谷 P3830** - 随机树  
     * 🗣️ 巩固期望概率模型，强化树形DP应用  
  2. **洛谷 P4211** - 地域管辖  
     * 🗣️ 练习树链剖分 + 区间数据结构维护  
  3. **洛谷 P6157** - 有趣的游戏  
     * 🗣️ 拓展剪枝策略在博弈搜索中的应用  

---

#### 7. 学习心得与经验分享
> **参考经验 (Zory)**：  
> “调试时发现`dep[x]-1`的边界问题，通过打印树状数组每层值定位。建议：对深度维数据结构，先验证小规模样本的边界值！”  
>  
> **Kay点评**：  
> 深度计算是树问题的常见陷阱，建议：  
> 1. 根节点深度设为1时，注意`dep-1`的边界  
> 2. 用`dep[x]`和`dep[x]-1`分别输出中间值对比  
> 3. 小样本模拟（如样例树）验证  

---

通过本次分析，我们深入掌握了概率期望与树优化的结合应用。记住：**优秀算法 = 深刻问题理解 + 合适数据结构 + 严谨边界处理**。下次挑战见！💪

---
处理用时：412.31秒
# 题目信息

# [YsOI2020] 计划

## 题目背景

相信大家已经知道了这样几个事实：  
- Ysuperman 是很有钱。

- Ysuperman 一直都很善于制定计划。

- Ysuperman 管理着一个幼儿园。

- Ysuperman 收藏了一些零食。

- 每一天，TA 可能会心血来潮地想要有计划地吃掉 TA 的零食。


## 题目描述

Ysuperman 现在有 $n$ 份零食，对**每份**零食而言，TA 每一天有 $P$ 的概率对 TA 的这份零食做出计划，TA 每做出一份计划后的 $T$ 天后，TA 将会将这一份零食给吃掉。需要特殊说明的是，如果在Ysuperman制定计划前已经对该份零食做出计划，则实际会按照**第一份计划的时间**将零食吃掉。

不幸的是，幼儿园内贪吃的小朋友会破坏这一计划。  幼儿园内有 $m$ 个小朋友，TA 们觊觎着 Ysuperman 的零食。对于**每份**零食，每天会有 $p_i$ 的概率被第 $i$ 个小朋友偷吃。如果这份零食在某位小朋友偷吃之前被吃掉了，那么相应地，这位小朋友就偷吃不了。**如果有一份零食在计划完成前被偷吃，那么，相关计划就无法实现了。**

现在 Ysuperman 要对 TA 的计划进行风险评估，TA 悬赏了 $114514pts$ ，这个项目在经过层层转包后来到了您的手上，现在已经算出了各概率在模意义下的值。经过各方协商，您如果解决了这个问题，您可以获得 $ 100pts $ 。您需要告诉 TA **Ysuperman 能期望吃掉多少份零食，以及 Ysuperman 的零食期望在多少天后被吃完** 。

**如果一份零食被某位小朋友吃掉了，那么这份零食就不属于Ysuperman了。**

需要注意的是，Ysuperman每天制定计划的时间在小朋友偷吃糖果**之前**。

Ysuperman 认为浮点数的精度误差太大，所以你只需要输出答案**对 $998244353$ 取模**的结果。

## 说明/提示

### 样例说明

#### 样例说明 $1$:

在取模前的其中一种可能情况为：
```cpp
5 8 11  
0.1  
0.1 0.2 0.3 0.4 0.5 0.6 0.7 1
```
该情况下，小朋友会在第一天中偷吃完所有的零食。

#### 样例说明 $2$:

在取模前的一种可能情况为：
```cpp
3 5 0  
1  
1 1 1 1 1
```

该情况下，Ysuperman 会在第一天计划并吃完所有的零食。

#### 样例说明 $3$:

在取模前的一种可能的情况为：

```cpp
2 2 0  
0.5  
0.5 0.5
```
在此情况下，答案为 $\dfrac{8}{7}$ 和 $\dfrac{80}{63}$。

由于解答过程较为复杂，所以请聪明的读者自行思考。


------------
### 数据范围

**如果您只答对了某个测试点两问中的任意一问，您可以获得这个测试点 $ 25\% $ 的分数。**

以下是致敬 $\text{NOI}$ 的部分分表格：
| 测试点编号 | $n$ | $m$ | $T$ | $P$ | 特殊性质 |
| :-----------: | -----------: | -----------: | -----------: | -----------: | :-----------: |
| 1 | $=1$ | $=1$ | $=0$ | 无其它约束 | 无 |
| 2 | $=1$ | $=10$ | $=1$ | $=1$ | $1$ |
| 3 | $=1$ | $\le100$ | $=227$ | $=1$ | $2$ |
| 4 | $\le 20$ | $\le 1000$ | $=4$ | 无其它约束 | 无 |
| 5 | $\le 100$ | $\le 1000$ | $=4$ | 无其它约束 | 无 |
| 6 | $\le 1000$ | $\le 1000$ | $=227$ | $=0$ | $1$ |
| 7 | $\le 100000$ | $\le 100000$ | $=233$ | $=1$ | $2$ |
| 8 | $\le1919820$ | $=114514$ | $=2333$ | $=0$ | $2$ |
| 9 | $\le1919820$ | $=114514$ | $=2333$ | $=0$ | $2$ |
| 10 | $=100000$ | $=100000$ | $=3$ | 无其它约束 | $2$ |
| 11 | $=114514$ | $=114514$ | $=3$ | 无其它约束 | 无 |
| 12 | $\le1919820$ | $=114514$ | $=0$ | 无其它约束 | $2$ |
| 13 | $\le 1919820$ | $=1$ | $\le 227$ | 无其它约束 | 无 |
| 14 | $\le 1919820$ | $\le114514$ | $\le 227$ | 无其它约束 | $2$ |
| 15 | $\le 1919820$ | $=1$ | $\le 500$ | $=1$ | 无 |
| 16 | $\le 1919820$ | $\le 114514$ | $\le 500$ | $=1$ | 无 |
| 17 | $\le 1919820$ | $\le 114514$ | $\le 500$ | $=1$ | 无 |
| 18 | $\le 1919820$ | $\le 114514$ | $=0$ | 无其它约束 | 无 |
| 19 | $\le 1919820$ | $\le 114514$ | $=0$ | 无其它约束 | 无 |
| 20 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | $2$ |
| 21 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | 无 |
| 22 | $\le 100000$ | $\le 100000$ | $\le 500$ | 无其它约束 | 无 |
| 23 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | 无 |
| 24 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | 无 |
| 25 | $\le 1919820$ | $\le 114514$ | $\le 2333$ | 无其它约束 | $2$ |

对于 $100\%$ 的数据，满足 $ 1\le n\le 1919820,1\le m \le 114514,0\le T \le 2333,0\le P< 998244353,1\le p_i<998244353$


特殊性质 $1$：存在一个 $i$ 使得$p_i=1$。

特殊性质 $2$：所有的 $p_i$ 都相等。

## 样例 #1

### 输入

```
5 8 11
13482572 
299473306 598946612 898419918 199648871 499122177 798595483 99824436 1```

### 输出

```
0 1```

## 样例 #2

### 输入

```
3 5 0
1
1 1 1 1 1```

### 输出

```
3 1```

## 样例 #3

### 输入

```
2 2 0
499122177
499122177 499122177```

### 输出

```
855638018 507044752```

## 样例 #4

### 输入

```
11 4 514
1919810
1919810 1919810 1919810 1919810```

### 输出

```
550831570 75142974```

## 样例 #5

### 输入

```
100000 20 227
2020
2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 2017 2018 2019```

### 输出

```
808786679 861511854```

# AI分析结果


# 💡 Kay的C++算法解析：「计划」题目深入学习指南 💡

<introduction>
今天我们一起分析「计划」这道有趣的概率期望问题！Ysuperman的零食计划与贪吃小朋友的组合，形成了巧妙的概率模型。本指南将帮你掌握核心的概率推导技巧和min-max容斥的精妙应用。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`概率期望计算` 与 `min-max容斥技巧`

🗣️ **初步分析**：
> 这道题就像一场"零食保卫战"：Ysuperman制定零食计划（概率P），小朋友伺机偷吃（概率p_i）。解题关键在于**时间分段处理**和**容斥原理**，就像把复杂的战场分为前线和后方两个阶段。
- **核心思路**：前T天只有小朋友能偷吃，T天后Ysuperman加入"战场"。第一问计算期望被吃零食数需概率乘积处理；第二问求吃完时间用min-max容斥转化为子集最小期望
- **可视化设计**：采用"像素塔防"风格，零食化为像素方块，Ysuperman和小朋友作为像素角色。关键动画展示时间分段（前T天红色警戒，T天后双威胁）和概率乘积效果（方块颜色随存活概率渐变）
- **交互设计**：WASD控制时间流速，空格暂停观察概率变化。8-bit音效：计划制定-"叮"，偷吃-"咔嚓"，吃完-"胜利旋律"

---

## 2. 精选优质题解参考

**题解一（来源：lmAKf）**
* **点评**：思路直击核心，将复杂问题分解为时间分段+容斥原理两阶段。代码实现简洁高效（O(n)复杂度），边界处理严谨（特判q=0）。亮点在于min-max容斥的优雅实现，学习价值在于如何用组合数学处理期望极值问题。

**题解二（来源：Iratis）**
* **点评**：推导过程详尽如教科书，逐步展示概率公式的转化技巧（特别是等比数列求和的应用）。亮点在于清晰定义r/r'等关键概率变量，帮助理解时间分段概率模型。适合深度理解数学基础，但缺少代码实现。

**题解三（来源：clamee）**
* **点评**：采用分治法解决，提供部分分到满分的平滑过渡思路。代码模块化优秀（分离概率计算/容斥部分），变量命名规范（如q=存活概率）。亮点在于特判处理和实践性强的调试技巧，例如边界值测试方案。

---

## 3. 核心难点辨析与解题策略

1.  **时间分段概率融合**
    * **分析**：前T天仅小朋友偷吃（概率Q=1-∏(1-p_i)），T天后双重威胁。需用**概率乘积**将m个小朋友转化为每日存活概率r=∏(1-p_i)，再结合P计算分段期望
    * 💡 **学习笔记**：概率乘积是处理多独立事件的金钥匙

2.  **期望的线性分解**
    * **分析**：第一问中，每份零食独立同分布，总期望=n×单零食期望。利用**期望线性性**分解为：存活概率(r^T) × 被吃概率(∑几何级数)
    * 💡 **学习笔记**："整体=部分和"是期望计算的基石思想

3.  **min-max容斥转化**
    * **分析**：求最晚吃掉时间(max)转化为求子集最早吃掉时间(min)的和。通过**容斥原理**+**组合数**处理：$E[\max S]=\sum_{k=1}^n (-1)^{k+1}\binom{n}{k}E[\min T_k]$
    * 💡 **学习笔记**：容斥原理是极值期望问题的终极武器

### ✨ 解题技巧总结
- **技巧1（问题分解）**：将复杂时间线分段处理（前T天/T+1天后）
- **技巧2（概率压缩）**：用乘积∏(1-p_i)将多事件概率转为单日存活率
- **技巧3（边界特判）**：特别注意概率为0/1的退化情况（如q=0时直接得解）
- **技巧4（几何级数求和）**：灵活应用$S=\frac{a}{1-r}$简化无穷级数

---

## 4. C++核心代码实现赏析

**通用核心实现参考**
```cpp
#include<bits/stdc++.h>
#define int long long
const int N=2e6+5, P=998244353;
int n,m,T,p,q,fac[N],inv[N];

int qpow(int x,int k){/*快速幂*/}
int C(int x,int y){/*组合数*/}

signed main(){
    // 输入初始化
    int survival=1; // 计算每日存活概率r
    for(int i=1;i<=m;++i){ 
        int x; cin>>x;
        survival=survival*(1-x+P)%P; 
    }
    
    // 第一问：期望被吃零食数
    int rT = qpow(survival, T);
    int ans1 = n * rT %P * p %P * qpow((1-(1-p+P)*survival%P +P)%P, P-2)%P;
    
    // 第二问：min-max容斥求期望时间
    int ans2=0;
    for(int k=1, op=1; k<=n; ++k, op=-op){
        int rk = qpow(survival, k);
        int uk = qpow((1-p+P)*survival%P, k);
        // 计算g(k)=E[min T_k]
        int S1 = (1-qpow(rk,T+1)+P) * qpow((1-rk+P)%P, P-2)%P;
        int S2 = qpow(rk,T) * uk %P * qpow((1-uk+P)%P, P-2)%P;
        int gk = (S1 + S2) %P;
        // 容斥求和
        ans2 = (ans2 + op*C(n,k)*gk%P + P)%P;
    }
    cout<<ans1<<" "<<ans2;
}
```

**题解一片段赏析**  
```cpp
int ans2=0;
for(int k=1; k<=n; ++k){
    int rp=C(n,k)*((k+1)&1?P-1:1)%P; // 容斥系数
    int tk=qpow(q,k); // q=存活概率
    int S1=(1-qpow(tk,T+1)+P)*qpow(1-tk+P,P-2)%P; // 前T天求和
    int fk=qpow(u,k); // u=(1-p)*q
    int S2=qpow(tk,T)*fk%P*qpow(1-fk+P,P-2)%P; // T天后几何级数
    ans2=(ans2 + rp*(S1+S2))%P;
}
```
> **解读**：此片段实现min-max容斥的核心循环。循环变量k表示子集大小，rp是容斥项的组合系数。S1计算前T天内的期望贡献（有限求和），S2计算T天后的无穷级数（化为几何级数）。注意qpow(...,P-2)是模逆元实现，用于除法取模  
> 💡 **学习笔记**：容斥实现=组合数×符号项×子问题解

**题解三片段赏析**  
```cpp
int sol(int p,int q){
    int t=qpow((1-p+P)%M,T); // 存活T天的概率
    int re=((1-t)*qpow(p,M-2)%M - t*T%M)%M; // 前T天期望
    int a=(1-p-q+p*q)%M, B=(p+q-p*q)*t%M; // 定义T天后参数
    int qwq=qpow(1-a+P,M-2);
    re=(re + B*(qwq*qwq%M + T*qwq%M))%M; // 加入T天后贡献
    return re;
}
```
> **解读**：此函数计算子集最小期望E[min T]。通过t=qpow(...)计算存活概率体现概率乘积思想，分re(前T天)和B(后阶段)两段计算。亮点在于清晰分离时间阶段  
> 💡 **学习笔记**：模块化设计使概率计算更易维护

---

## 5. 算法可视化：像素动画演示

**主题**："零食大作战"像素塔防游戏  
**核心演示**：  
1. 像素化零食方块（n个）在网格排列，Ysuperman(蓝色像素人)和小朋友(红色像素人)分列两侧  
2. **时间分段演示**：  
   - 前T天：红色警戒模式，仅小朋友发射"偷吃射线"（8-bit音效）  
   - T+1天后：双威胁模式，蓝色计划射线加入战场  
3. **概率可视化**：  
   - 每个零食方块透明度=当日存活概率（r=∏(1-p_i)）  
   - 射线命中时方块碎裂（"咔嚓"音效），显示当前存活数期望值  

**关键帧设计**：  
- **初始化**：FC风格网格，控制面板含时间流速滑块(1x-10x)  
- **前T天阶段**：  
  ```plaintext
  第i天: [零食ID]透明度 = r^i  (渐隐效果)
  小朋友射线→命中检测→if命中: 方块碎裂+显示当前期望E
  ```  
- **T天后阶段**：  
  ```plaintext
  双重射线扫描→先小朋友后Ysuperman
  命中时显示：P(命中)=p+q-pq
  ```  
- **容斥原理演示**：  
  选择k个零食→显示子集高亮→计算min期望→加权求和  

**游戏化设计**：  
- 每存活1天得10分，完成min-max计算得"容斥大师"奖杯  
- 背景音乐：8-bit改编版《卡农》循环  
- 胜利条件：正确预测最终期望值解锁隐藏关卡  

---

## 6. 拓展练习与相似问题

**通用技巧迁移**：  
1. 时间分段期望 → 带时间窗口的概率问题  
2. min-max容斥 → 期望最值问题（如[APIO2016]烟花表演）  
3. 独立事件概率乘积 → 多事件共存问题  

**洛谷推荐**：  
1. **P2719** 搞笑世界杯  
   → 掌握基础概率DP与期望计算  
2. **P3211** 随机数生成器  
   → 强化时间分段期望模型  
3. **P5644** 愤怒的小鸟  
   → 练习min-max容斥的变种应用  

---

## 7. 学习心得与经验分享

> **来自lmAKf的调试经验**："考场上有细节挂了...特别注意q=0时的边界处理"  
> **Kay点评**：概率题中边界特判至关重要！当存活概率q=0时：  
> - 若T>0：所有零食第一天就被偷吃（输出0）  
> - 若T=0：立即执行计划（需特殊计算）  
> 建议：显式处理所有概率为0/1的退化情况  

---

本次分析帮助你掌握概率期望的核心解题范式：**分解时间线→建立概率模型→运用容斥原理**。记住，编程能力=数学基础×代码实践×边界敏感度。下次挑战再见！💪

---
处理用时：115.50秒
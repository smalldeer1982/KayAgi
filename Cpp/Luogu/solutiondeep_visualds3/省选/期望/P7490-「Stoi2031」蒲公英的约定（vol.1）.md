# 题目信息

# 「Stoi2031」蒲公英的约定（vol.1）

## 题目背景

> 一起长大的约定 那样清晰 拉过勾的我相信 说好要一起旅行 是你如今 唯一坚持的任性 ——《蒲公英的约定》

## 题目描述

清和如在玩游戏。她们有 $n$ 丛 **蒲公英**，每丛分别有 $s_i$ 朵。这些 **蒲公英** 有一个神奇的性质：有一个给定的常数 $\sigma \in (0,1)$，$x$ 朵 **蒲公英** 会分出 $\lfloor \sigma x \rfloor$ 朵为一组，剩下 $x-\lfloor \sigma x \rfloor$ 朵继续分组，直到分出的组没有 **蒲公英** 即 $\lfloor \sigma x \rfloor=0$ 为止。她们称这种现象为 **任性**。现在她们的每丛 **蒲公英** 都有 **任性** 的现象。她们的游戏规则如下：从清开始，两人轮流进行 **旅行**。一次 **旅行** 为选择一丛 **蒲公英** 并吹散这一丛的第一组中的若干朵 **蒲公英**，至少要吹一朵，至多吹的朵数为第一组的朵数，即不能吹散除第一组外的 **蒲公英**。当第一组为空时，其下一组成为第一组。若这一丛只剩下一组 **蒲公英**，这一丛不能再被选定。每丛 **蒲公英** 都不能被选定时，游戏结束，当前轮到的人落败。她们想知道如果清第一次 **旅行** 时等概率选择其中一丛可吹散的 **蒲公英** 再等概率选择吹散的朵数后两人都按最优策略操作，那么清的胜率 $x \bmod 20190816170251$ 的值将会是多少。

与 vol.2 的区别是，**蒲公英** 在被吹散一部分后 **不会** 重新分组。

## 说明/提示

#### 简述版题意：

有 $n$ 丛 **蒲公英**，第 $i$ 丛有 $s_i$ 朵。给定实数 $\sigma$，每丛会分为若干组，第 $j$ 组有 $t_j$ 朵，且满足 $t_j=\left\lfloor \sigma\left(s_i - \sum\limits_{k=1}^{j-1}t_k\right) \right\rfloor$，当 $t_j=0$ 时不再分组。两人轮流操作，每次操作可以选择一丛 **蒲公英**，并选择一个整数 $c \in t_j$，从这丛 **蒲公英** 中吹散 $c$ 朵，将 $t_j$ 变为 $t_j-c$，其中 $j$ 为操作之前这丛 **蒲公英** 中满足 $t_j \neq 0$ 的最小正整数。必须至少吹一朵，不能操作者败。求先手第一步等概率选择任意一丛可操作的 **蒲公英** 再等概率选择吹散的朵数后两人都采取最优策略时先手的胜率 $x \bmod{20190816170251}$ 的值。

#### 样例解释：

对于样例 $1$，清无法操作，胜率为 $0$。

对于样例 $2$，初始局面为 $\{0;1\},\{2,1,1,1,0;2\},\{1,0;2\}$，清可以选择第 $2$ 丛并在两种操作中选择吹散 $2$ 朵变成 $\{0;1\},\{1,1,1,0;2\},\{1,0;2\}$，选择第 $3$ 丛没有可取胜的策略，且第 $1$ 丛不能选择，总胜率为 $\dfrac{\frac{1}{2}+0}{2}=\dfrac{1}{4}$。

#### 数据范围：

**本题采用捆绑测试，各个 Subtask 的分数与限制如下。**

| Subtask No. | $n \le$ | $s_i \le$ | $\sigma$ 限制 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{2}+1}{3}$ | $10$ |
| $2$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{3}+1}{5}$ | $10$ |
| $3$ | $3 \times 10^5$ | $10^{10}$ | $\sigma=\dfrac{\sqrt{5}-1}{2}$ | $10$ |
| $4$ | $100$ | $1$ | 无 | $3$ |
| $5$ | $100$ | $100$ | $\sigma=\dfrac{1}{2}$ | $7$ |
| $6$ | $100$ | $10^6$ | 无 | $13$ |
| $7$ | $3 \times 10^5$ | $10^{10}$ | $\sigma \ge \dfrac{1}{2}$ | $47$ |

对于 $100\%$ 的数据，$1 \le n \le 3 \times 10^5,1 \le s_i \le 10^{10},1 \le p<q \le 10^9$。

**本题读入量较大，可以选择使用比赛描述中的快速读入模板以加快读入速度。**

## 样例 #1

### 输入

```
4 3
1 1 1
1 6
```

### 输出

```
0
```

## 样例 #2

### 输入

```
6 3
1 7 3
1 3
```

### 输出

```
5047704042563
```

# AI分析结果


### 题目分析与题解提炼

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：组合游戏理论（SG函数）与数学优化  
🗣️ **初步分析**：
> 本题本质是组合游戏问题，每丛蒲公英是独立子游戏。核心在于计算每丛的SG值（Sprague-Grundy函数），最终胜负由所有子游戏SG值的异或和决定。  
> - **关键思想**：将蒲公英的分组过程转化为状态序列，利用SG函数的递归性质（当前状态的SG值取决于后续状态）。  
> - **核心难点**：直接递归计算SG值会超时（$s_i \leq 10^{10}$），需推导O(1)计算公式。  
> - **题解亮点**：发现SG值仅与第一组朵数$t_1$和特定奇偶性相关：  
>   $$ \text{SG}(x) = t_1 - \left( \left\lfloor \frac{x - \lfloor \sigma t_1 \rfloor - 1}{t_1} \right\rfloor \mod 2 \right) \quad (t_1 = \lfloor \sigma x \rfloor) $$
> - **可视化设计**：采用像素风“蒲公英分组动画”，动态展示分组过程（不同颜色块表示组别），吹散操作时触发“像素消失+音效”，自动演示模式模拟最优策略路径。

#### 2. 精选优质题解参考
**题解 (作者：VinstaG173)**  
* **点评**：  
  - **思路清晰性**：一针见血识别SG函数本质，推导出非递归公式（避免超时），逻辑链完整。  
  - **代码规范性**：宏封装`_sigma`/`_tau`提升可读性，快速读入优化处理大数据（$n \leq 3 \times 10^5$）。  
  - **算法有效性**：O(1)计算SG值，结合异或和与模逆元统计胜率，复杂度$O(n)$完美匹配数据范围。  
  - **实践价值**：扩展欧几里得求模逆元（模数$20190816170251$），边界处理严谨（跳过$t_1=0$丛）。  
  **亮点**：将数学观察（奇偶性）转化为位运算`&1`，大幅优化效率。

---

### 3. 核心难点辨析与解题策略
1. **难点1：SG函数的快速计算**  
   * **分析**：直接递归计算$s_i \leq 10^{10}$不可行。**解决方案**：发现SG值仅依赖$t_1$和表达式$\left\lfloor \frac{x - \lfloor \sigma t_1 \rfloor - 1}{t_1} \right\rfloor$的奇偶性，转化为位运算。  
   💡 **学习笔记**：大规模数据需寻找规律，避免暴力递归。

2. **难点2：胜率统计的数学转化**  
   * **分析**：胜率=合法操作中能使后续SG异或和为0的比例。**解决方案**：若$\text{SG}(i) \oplus d \leq t_1$（$d$为总异或和），则存在获胜操作，概率贡献为$\frac{1}{n \cdot t_1}$。  
   💡 **学习笔记**：组合游戏胜率统计常转化为异或和归零问题。

3. **难点3：分数σ的精确处理**  
   * **分析**：σ可能为分数（$p/q$），浮点计算会丢精度。**解决方案**：整数化处理——$t_1 = \lfloor \sigma x \rfloor = \lfloor x p / q \rfloor$，避免浮点误差。  
   💡 **学习笔记**：涉及大数时优先采用整数运算。

#### ✨ 解题技巧总结
- **规律转化技巧**：将递归问题转化为封闭表达式（如位运算）。  
- **模运算优化**：大模数逆元用扩展欧几里得算法（代码中`exgcd`）。  
- **输入输出加速**：自定义快读函数（`rc()`和`_read()`）处理$10^5$级数据。  

---

### 4. C++核心代码实现赏析
**本题通用核心C++实现参考**  
* **说明**：综合题解思路，处理分数σ+位运算优化SG计算+快读加速。  
* **完整核心代码**：  
  ```cpp
  #include <cstdio>
  #define ll unsigned long long
  const ll MOD = 20190816170251;

  // 快读与数学工具（略）
  ll sigma(ll x, ll p, ll q) { 
      return (p * x) / q;  // 整数化σ计算
  }
  ll sg(ll x, ll p, ll q) {
      ll t = sigma(x, p, q);
      if (!t) return 0;
      ll tau = (p * t) / q;  // 整数化计算⌊σt⌋
      return t - (((x - tau - 1) / t) & 1); // 位运算优化
  }

  int main() {
      // 读入n, s[i], p, q
      ll d = 0; // 总异或和
      for (int i = 0; i < n; ++i) {
          SG[i] = sg(s[i], p, q);
          d ^= SG[i];
      }
      ll valid = 0, inv_t;
      for (int i = 0; i < n; ++i) {
          ll t1 = sigma(s[i], p, q);
          if (t1 == 0) continue;
          if ((SG[i] ^ d) <= t1) { // 存在获胜操作
              inv_t = mod_inverse(t1, MOD); // 模逆元
              valid = (valid + inv_t) % MOD;
          }
      }
      ll ans = d ? valid * mod_inverse(n, MOD) % MOD : 0;
      printf("%llu", ans);
  }
  ```
* **代码解读概要**：  
  1. **快读**：处理$3 \times 10^5$级输入。  
  2. **SG计算**：通过整数除法避免浮点误差，位运算奇偶性判断。  
  3. **胜率统计**：异或和归零条件判断，模逆元累加贡献。  

---

### 5. 算法可视化：像素动画演示
**主题**：`8-bit风格蒲公英分组冒险`  
**核心演示**：动态展示分组过程+吹散操作对SG值的影响  

**设计细节**：  
1. **像素场景**：  
   - 蒲公英丛：横向像素条（不同颜色表不同组），如图：  
     ```
     [t1: ████] [t2: ██] [t3: █]  // 丛1 (s_i=7, σ=0.5)
     ```
   - 控制面板：步进/自动播放滑块，σ参数调整栏。

2. **关键动画流程**：  
   - **初始化**：输入$s_i$和$\sigma$，生成分组像素块（每组颜色渐变）。  
   - **吹散操作**：点击丛→拖拽滑块选择$k$→被吹散像素块爆炸（`8-bit音效`）。  
   - **状态更新**：  
     - $t_1$减少$k$：对应像素块缩短。  
     - $t_1=0$时：第二组像素块左移（`咔嚓`音效）。  
   - **AI演示**：自动选择使异或和归零的操作，路径高亮（如贪吃蛇AI）。  

3. **游戏化元素**：  
   - **音效设计**：分组完成（`叮`），吹散（`砰`），胜利（超级马里奥过关音）。  
   - **关卡积分**：每丛最优解算作小关，连胜触发Combo奖励。  

**实现参考伪代码**：  
```javascript
class PixelAnimation {
  drawGroup(si, sigma) { 
    let groups = [];
    while (si > 0) {
      let t = Math.floor(si * sigma);
      if (t === 0) break;
      groups.push(t); // 存储分组
      si -= t;
    }
    renderPixelBars(groups); // 生成彩色像素条
  }
  onBlow(k) {
    playSound("explosion");
    updateTopGroup(-k); // 顶部组减少k
    if (currentGroup === 0) 
      shiftGroups(); // 组队列左移
  }
}
```

---

### 6. 拓展练习与相似问题思考
1. **通用技巧迁移**：  
   SG函数适用于所有公平组合游戏（如Nim变种）。关键特征：  
   - 操作独立（无公共资源）  
   - 有限步内结束  
   - 必胜/必败状态可递推  

2. **洛谷推荐**：  
   | 题号      | 题目名称             | 推荐理由                                  |
   |-----------|----------------------|------------------------------------------|
   | **P2197** | Nim游戏              | SG函数模板题，巩固异或和本质。            |
   | **P2575** | 高手过牌             | 多层状态SG函数，拓展分组游戏思维。        |
   | **P2148** | [SDOI2009] E&D       | 子游戏分裂模型，强化SG递归推导能力。      |

---

### 总结
本题通过**SG函数+位运算优化**，将分组游戏转化为数学问题。核心突破点：  
1. 发现SG值仅依赖$t_1$和奇偶性（$\frac{x - \lfloor \sigma t_1 \rfloor - 1}{t_1} \mod 2$）。  
2. 整数化处理$\sigma$避免精度丢失。  
3. 异或和归零条件统计胜率。  

**学习价值**：  
- **组合游戏**：SG函数是解决公平游戏的通用框架。  
- **优化思维**：大规模数据找规律，避免暴力递归。  
- **数学实践**：模逆元、位运算、整数化分数的高效应用。  

> 蒲公英的约定终会实现，算法的奥秘永无止境。保持探索，少年！ 🌟

---
处理用时：248.51秒
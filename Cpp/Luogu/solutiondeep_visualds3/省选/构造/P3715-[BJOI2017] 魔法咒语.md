# 题目信息

# [BJOI2017] 魔法咒语

## 题目描述

Chandra 是一个魔法天才。

从一岁时接受火之教会洗礼之后，Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。

直到十四岁，开始学习威力强大的禁咒法术时，Chandra 才遇到了障碍。

根据火之魔法规则，禁咒的构成单位是 $N$ 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 $L$ 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。

但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时，Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。

这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。

很多年过去了，在一次远古遗迹探险中，Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。


禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 $M$ 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。

例如，若 `banana` 是唯一的忌讳词语，`an`、`ban`、`analysis` 是基本词汇，禁咒长度须是 $11$，则 `bananalysis` 是无效法术，`analysisban`、`anbanbanban` 是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。

谜题破解，Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。

由于答案可能很大，你只需要输出答案模 $10 ^ 9 + 7$ 的结果。


## 说明/提示

【样例解释 1】

有效的禁咒法术共有 $14$ 种：`boom/bang/oo`，`oo/oo/oo/oo/oo`，`oo/oo/ooh/ooh`，`oo/ooh/oo/ooh`，`oo/ooh/ooh/oo`，`ooh/oo/oo/ooh`，`ooh/oo/ooh/oo`，`
ooh/ooh/boom`，`ooh/ooh/oo/oo`，`ooh/ooh/bang`，`ooh/bang/ooh`，`bang/oo/oo/oo`，`bang/ooh/ooh`，`bang/bang/oo`。

【样例解释 2】

有效的禁咒法术有 `a/ab`，`ab/a`，`aba` 共三种。注意，`ab/a` 和 `aba` 算成两种不同的禁咒法术。

【数据规模与约定】

本题一共有 $10$ 个测试点。

下表是每个测试点的数据规模和约定：

 ![](https://cdn.luogu.com.cn/upload/pic/5191.png) 

对于 $100\%$ 的数据，$1 \le N, M \le 50，1 \le L \le 10^8$，基本词汇的长度之和不超过 $100$，忌讳词语的长度之和不超过 $100$。保证基本词汇不重复，忌讳词语不重复。


## 样例 #1

### 输入

```
4 2 10
boom
oo
ooh
bang
ob
mo```

### 输出

```
14```

## 样例 #2

### 输入

```
3 1 3
a
ab
aba
aaa```

### 输出

```
3```

## 样例 #3

### 输入

```
3 1 14
ban
an
analysis
banana```

### 输出

```
15```

# AI分析结果

# 💡 Kay的C++算法解析：[BJOI2017]魔法咒语 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`AC自动机 + 动态规划（DP） + 矩阵快速幂优化`


### 🗣️ 初步分析
解决“魔法咒语”问题的核心是**避免拼接的字符串中包含任何忌讳词汇**，并**高效计数合法方案**。具体思路如下：

1. **AC自动机处理忌讳词汇**：  
   忌讳词汇是多模式串，需要快速判断拼接过程中是否出现。AC自动机（Aho-Corasick Automaton）是处理多模式串匹配的高效数据结构，能将所有忌讳词汇构建成Trie树，并通过`fail`指针实现快速转移，标记所有包含忌讳词汇的节点（包括`fail`链上的节点，确保不遗漏禁忌）。

2. **动态规划（DP）计数**：  
   设`dp[i][j]`表示拼接长度为`i`、且当前在AC自动机状态`j`的合法方案数。转移时，枚举每个基本词汇，从状态`j`出发沿词汇字符走，若过程中未碰到禁忌节点，则转移到新状态`j'`，更新`dp[i+len(k)][j'] += dp[i][j]`（`len(k)`是基本词汇`k`的长度）。

3. **矩阵快速幂优化大L**：  
   当`L`高达`1e8`时，直接DP（时间复杂度`O(L*state_size*n)`）无法通过。此时利用**基本词汇长度≤2**的特性，将DP状态扩展为`[dp[i], dp[i-1]]`（`dp[i]`表示长度`i`的状态分布），构造转移矩阵，通过矩阵快速幂将时间复杂度优化到`O(state_size^3 * log L)`。


### 核心算法流程与可视化设计思路
- **AC自动机构建**：展示Trie树的构建过程（节点添加、字符边连接），`fail`指针的计算（BFS过程），以及禁忌节点的标记（红色高亮）。  
- **小L的DP转移**：用柱状图表示每个状态`j`的`dp[i][j]`值，动态演示从`i`到`i+len(k)`的转移（比如选择一个基本词汇，状态从`j`跳到`j'`，柱状图高度变化）。  
- **大L的矩阵快速幂**：将矩阵分为四块（长度1转移、长度2转移、单位矩阵），展示矩阵乘法过程（比如`dp[i]`如何通过矩阵转移到`dp[i+1]`），以及状态向量的变化（用颜色深浅表示方案数）。


### 复古游戏化动画设计
- **风格**：8位像素风（类似FC游戏），用方块表示AC自动机节点，箭头表示字符转移。  
- **交互**：  
  - 单步/自动播放：演示AC自动机构建、DP转移、矩阵乘法的每一步。  
  - 调速滑块：控制动画速度。  
  - 音效：节点添加时“叮”的一声，禁忌节点标记时“警告”音效，矩阵乘法完成时“胜利”音效。  
- **游戏元素**：将AC自动机构建视为“搭建迷宫”，DP转移视为“走迷宫”，矩阵快速幂视为“加速魔法”，增加趣味性。


## 2. 精选优质题解参考

### 题解一（来源：shadowice1984）
**点评**：  
这份题解思路清晰，完整覆盖了小L和大L的情况。AC自动机部分正确处理了`fail`指针和禁忌标记的传递（`ed[p] |= ed[fail[p]]`），避免了遗漏禁忌。DP部分用滚动数组优化了空间，矩阵快速幂部分构造了正确的转移矩阵（分长度1和2处理），代码风格规范（变量名如`dp[i][j]`、`trie`清晰），实践价值高。亮点是对矩阵快速幂的详细解释，帮助理解如何将DP转移转化为矩阵运算。


### 题解二（来源：oscar）
**点评**：  
题解分情况处理小L和大L，逻辑严谨。AC自动机的`match`函数正确判断了基本词汇的转移合法性（避免禁忌），DP部分的状态转移方程正确。矩阵快速幂部分的代码结构清晰（用`matrix`结构体封装），转移矩阵的构造符合长度1和2的转移逻辑，代码可读性强。亮点是对矩阵快速幂的错误处理（比如第一次写挂的地方注释），提醒学习者注意细节。


### 题解三（来源：MoYuFang）
**点评**：  
题解用`namespace`分块处理小L（`S1`）和大L（`S2`），代码结构清晰。AC自动机的`dfs`函数正确传递了禁忌标记（`tag[u] |= tag[fail[u]]`），DP部分的`handle`函数正确计算了基本词汇的转移状态。矩阵快速幂部分的`matrix`结构体实现了乘法和快速幂，转移矩阵的构造（分长度1和2）正确。亮点是对状态的优化（`id[u]`映射有效节点，减少矩阵大小），提高了效率。


## 3. 核心难点辨析与解题策略

### 1. **AC自动机的禁忌标记传递**
- **难点**：若仅标记忌讳词汇的结尾节点，会遗漏通过`fail`指针间接包含忌讳词汇的情况（比如忌讳词汇是`"abcd"`，而拼接的字符串是`"xabcd"`，`"bcd"`可能通过`fail`指针匹配到忌讳词汇）。  
- **策略**：构建`fail`指针后，通过BFS或DFS传递禁忌标记（`tag[u] |= tag[fail[u]]`），确保所有包含忌讳词汇的节点都被标记。  
- 💡 **学习笔记**：AC自动机的禁忌标记必须传递到`fail`链上的所有节点，否则会导致错误。


### 2. **大L的矩阵快速幂构造**
- **难点**：当基本词汇长度≤2时，DP转移涉及`dp[i]`（长度`i`）和`dp[i-1]`（长度`i-1`），需要将这两个状态整合到矩阵中。  
- **策略**：将矩阵大小扩展为`2*state_size`（`state_size`是AC自动机的状态数），前`state_size`表示`dp[i]`，后`state_size`表示`dp[i-1]`。转移矩阵的构造规则：  
  - 长度1的转移：`dp[i][j]`→`dp[i+1][k]`，对应矩阵的前`state_size`行。  
  - 长度2的转移：`dp[i-1][j]`→`dp[i+1][k]`，对应矩阵的后`state_size`行。  
  - 单位矩阵：保持`dp[i]`到`dp[i-1]`的状态（矩阵的左下角）。  
- 💡 **学习笔记**：矩阵快速幂的核心是将DP转移转化为矩阵乘法，扩展状态是处理多步转移的关键。


### 3. **基本词汇的转移合法性判断**
- **难点**：拼接基本词汇时，必须确保整个词汇的字符序列在AC自动机上的转移过程中没有碰到禁忌节点。  
- **策略**：预处理`tran[u][k]`表示从状态`u`出发，拼接基本词汇`k`后的新状态（若过程中碰到禁忌，则`tran[u][k] = -1`）。预处理可以避免重复计算，提高DP转移效率。  
- 💡 **学习笔记**：预处理转移状态是优化DP的重要手段，能减少重复的字符匹配操作。


### ✨ 解题技巧总结
- **问题分解**：将大问题分解为AC自动机构建、DP计数、矩阵快速幂优化三个子问题，逐个解决。  
- **状态优化**：对于大L，利用基本词汇长度小的特性，扩展DP状态，用矩阵快速幂优化。  
- **细节处理**：AC自动机的禁忌标记传递、矩阵的正确构造、预处理转移状态是解题的关键细节，需仔细处理。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合优质题解的思路，实现了AC自动机、小L的DP、大L的矩阵快速幂。

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int MOD = 1e9 + 7;
const int MAXN = 55;
const int MAXM = 105;
const int MAXSTATE = 105;

struct ACNode {
    int ch[26];
    int fail;
    bool tag;
    ACNode() {
        memset(ch, 0, sizeof(ch));
        fail = 0;
        tag = false;
    }
};

ACNode ac[MAXSTATE];
int ac_cnt = 0;

void insert(const string& s) {
    int u = 0;
    for (char c : s) {
        int idx = c - 'a';
        if (!ac[u].ch[idx]) {
            ac[++ac_cnt] = ACNode();
            ac[u].ch[idx] = ac_cnt;
        }
        u = ac[u].ch[idx];
    }
    ac[u].tag = true;
}

void build_fail() {
    queue<int> q;
    for (int i = 0; i < 26; ++i) {
        if (ac[0].ch[i]) {
            q.push(ac[0].ch[i]);
            ac[ac[0].ch[i]].fail = 0;
        }
    }
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        for (int i = 0; i < 26; ++i) {
            int v = ac[u].ch[i];
            if (v) {
                int f = ac[u].fail;
                while (f && !ac[f].ch[i]) f = ac[f].fail;
                ac[v].fail = ac[f].ch[i];
                ac[v].tag |= ac[ac[v].fail].tag;
                q.push(v);
            } else {
                ac[u].ch[i] = ac[ac[u].fail].ch[i];
            }
        }
    }
}

int tran[MAXSTATE][MAXN];
int len[MAXN];
string s[MAXN];

void pre_tran(int n) {
    for (int u = 0; u <= ac_cnt; ++u) {
        if (ac[u].tag) continue;
        for (int k = 1; k <= n; ++k) {
            int v = u;
            bool ok = true;
            for (char c : s[k]) {
                int idx = c - 'a';
                v = ac[v].ch[idx];
                if (ac[v].tag) {
                    ok = false;
                    break;
                }
            }
            tran[u][k] = ok ? v : -1;
        }
    }
}

// 小L的DP
long long dp_small(int L, int n) {
    vector<vector<long long>> dp(L + 1, vector<long long>(ac_cnt + 1, 0));
    dp[0][0] = 1;
    for (int i = 0; i < L; ++i) {
        for (int j = 0; j <= ac_cnt; ++j) {
            if (ac[j].tag || dp[i][j] == 0) continue;
            for (int k = 1; k <= n; ++k) {
                if (i + len[k] > L) continue;
                int v = tran[j][k];
                if (v == -1) continue;
                dp[i + len[k]][v] = (dp[i + len[k]][v] + dp[i][j]) % MOD;
            }
        }
    }
    long long ans = 0;
    for (int j = 0; j <= ac_cnt; ++j) {
        if (!ac[j].tag) ans = (ans + dp[L][j]) % MOD;
    }
    return ans;
}

// 矩阵快速幂
struct Matrix {
    int n;
    vector<vector<long long>> a;
    Matrix(int size) : n(size), a(size, vector<long long>(size, 0)) {}
    Matrix operator*(const Matrix& other) const {
        Matrix res(n);
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                for (int k = 0; k < n; ++k) {
                    res.a[i][j] = (res.a[i][j] + a[i][k] * other.a[k][j]) % MOD;
                }
            }
        }
        return res;
    }
};

Matrix matrix_pow(Matrix mat, int power) {
    int n = mat.n;
    Matrix res(n);
    for (int i = 0; i < n; ++i) res.a[i][i] = 1;
    while (power > 0) {
        if (power % 2 == 1) res = res * mat;
        mat = mat * mat;
        power /= 2;
    }
    return res;
}

long long dp_large(int L, int n) {
    int state_size = ac_cnt + 1;
    int mat_size = 2 * state_size;
    Matrix mat(mat_size);
    // 长度1的转移：dp[i][j] -> dp[i+1][k]
    for (int j = 0; j < state_size; ++j) {
        if (ac[j].tag) continue;
        for (int k = 1; k <= n; ++k) {
            if (len[k] != 1) continue;
            int v = tran[j][k];
            if (v == -1) continue;
            mat.a[j][v]++;
        }
    }
    // 长度2的转移：dp[i-1][j] -> dp[i+1][k]
    for (int j = 0; j < state_size; ++j) {
        if (ac[j].tag) continue;
        for (int k = 1; k <= n; ++k) {
            if (len[k] != 2) continue;
            int v = tran[j][k];
            if (v == -1) continue;
            mat.a[j + state_size][v]++;
        }
    }
    // 单位矩阵：dp[i] -> dp[i-1]
    for (int j = 0; j < state_size; ++j) {
        mat.a[j + state_size][j] = 1;
    }
    // 初始状态：dp[0][0] = 1，dp[-1][*] = 0（用state_size后的部分表示）
    Matrix init(mat_size);
    init.a[0][0] = 1;
    // 计算 mat^L
    Matrix mat_pow = matrix_pow(mat, L);
    // 结果是 init * mat_pow 的前state_size项之和
    long long ans = 0;
    for (int j = 0; j < state_size; ++j) {
        ans = (ans + init.a[0][j] * mat_pow.a[j][j]) % MOD;
    }
    return ans;
}

int main() {
    int n, m, L;
    cin >> n >> m >> L;
    for (int i = 1; i <= n; ++i) {
        cin >> s[i];
        len[i] = s[i].size();
    }
    for (int i = 1; i <= m; ++i) {
        string t;
        cin >> t;
        insert(t);
    }
    build_fail();
    pre_tran(n);
    if (L <= 100) {
        cout << dp_small(L, n) << endl;
    } else {
        cout << dp_large(L, n) << endl;
    }
    return 0;
}
```

**代码解读概要**：  
- **AC自动机构建**：`insert`函数插入忌讳词汇，`build_fail`函数构建`fail`指针并传递禁忌标记。  
- **预处理转移**：`pre_tran`函数计算从每个状态出发，拼接每个基本词汇后的新状态（避免禁忌）。  
- **小L的DP**：`dp_small`函数用二维数组存储状态，枚举每个长度和状态，转移更新方案数。  
- **大L的矩阵快速幂**：`dp_large`函数构造转移矩阵，处理长度1和2的转移，通过矩阵快速幂计算`L`次转移后的结果。


### 针对各优质题解的片段赏析

#### 题解一（shadowice1984）：矩阵快速幂构造
**亮点**：正确处理了长度1和2的转移，矩阵构造符合DP转移逻辑。  
**核心代码片段**：
```cpp
for(int i=1;i<=siz;i++){
    for(int q=1;q<=n;q++){
        if(len[q]!=1)continue;int p=i;if(t.ed[p])continue;//一步的矩阵 
        t.trv(p,mde[q][1]-'a'+1);if(p!=-1){tr.m[siz+i][siz+p]++;}
    }
}
for(int i=1;i<=siz;i++){
    for(int q=1;q<=n;q++){
        if(len[q]!=2)continue;int p=i;if(t.ed[p])continue;
        t.trv(p,mde[q][1]-'a'+1);if(p==-1)continue;//两步的矩阵 
        t.trv(p,mde[q][2]-'a'+1);if(p!=-1){tr.m[i][siz+p]++;}
    }
}
```
**代码解读**：  
- 长度1的转移：从状态`i`（`siz+i`是扩展后的状态）出发，拼接长度1的基本词汇，转移到状态`p`（`siz+p`是扩展后的状态）。  
- 长度2的转移：从状态`i`（扩展前的状态）出发，拼接长度2的基本词汇，转移到状态`p`（扩展后的状态）。  
**学习笔记**：矩阵的扩展状态是处理多步转移的关键，长度1和2的转移对应矩阵的不同块。


#### 题解二（oscar）：AC自动机的`match`函数
**亮点**：正确判断了基本词汇的转移合法性，避免了禁忌。  
**核心代码片段**：
```cpp
int match(string str,int len,int start) {
    node *cur=&pool[start],*tmp;
    for(int i=0;i<len;i++){
        int e=str[i]-'a';
        while(cur!=root&&!(cur->next[e]))cur=cur->fail;
        if(cur->next[e])cur=cur->next[e];
        tmp=cur;
        while(tmp!=root){
            if(tmp->end)return 0;
            tmp=tmp->fail;
        }
    }
    return cur->id;
}
```
**代码解读**：  
- 从状态`start`出发，沿基本词汇`str`的字符走，每走一步都检查当前节点及其`fail`链上的节点是否有禁忌标记（`tmp->end`）。若有，则返回0（不合法）；否则返回最终状态。  
**学习笔记**：`match`函数确保了拼接基本词汇的过程中没有碰到禁忌，是DP转移的关键。


#### 题解三（MoYuFang）：状态优化
**亮点**：映射有效节点，减少矩阵大小，提高效率。  
**核心代码片段**：
```cpp
int icnt = 0, id[maxs], ori[maxs];
for(int u = 1; u <= ncnt; ++u) if (!tag[u]) ori[id[u] = ++icnt] = u;
matrix::n = 2*icnt;
```
**代码解读**：  
- `id[u]`将AC自动机中的有效节点（未被禁忌标记的节点）映射到连续的编号（`1~icnt`），`ori[x]`表示映射后的编号`x`对应的原始节点。  
- 矩阵大小从`2*ncnt`减少到`2*icnt`，减少了矩阵乘法的时间复杂度。  
**学习笔记**：状态优化是提高矩阵快速幂效率的重要手段，尤其是当有效节点较少时。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题
**“像素探险家”在AC自动机迷宫中寻找合法路径**（类似FC游戏《迷宫探险家》）


### 核心演示内容
1. **AC自动机构建**：  
   - 用方块表示节点（根节点是绿色，其他节点是蓝色），箭头表示字符转移（红色箭头表示`fail`指针）。  
   - 插入忌讳词汇时，节点变为红色（禁忌标记），并通过`fail`指针传递（红色扩散）。  

2. **小L的DP转移**：  
   - 用柱状图表示每个状态的方案数（高度越高，方案数越多）。  
   - 选择一个基本词汇（比如“boom”），从当前状态出发，沿字符走，柱状图动态更新（比如从状态`0`转移到状态`5`，柱状图`5`的高度增加）。  

3. **大L的矩阵快速幂**：  
   - 用分块矩阵表示转移矩阵（左上角是长度1转移，右上角是长度2转移，左下角是单位矩阵）。  
   - 演示矩阵乘法过程（比如`mat^2`的计算），以及状态向量的变化（用颜色深浅表示方案数）。  


### 设计思路简述
- **像素风格**：模仿FC游戏的8位像素风，用简单的图形和颜色表示复杂的算法过程，降低理解难度。  
- **游戏元素**：将AC自动机构建视为“搭建迷宫”，DP转移视为“走迷宫”，矩阵快速幂视为“加速魔法”，增加趣味性。  
- **交互设计**：单步/自动播放、调速滑块、音效提示（节点添加“叮”、禁忌标记“警告”、矩阵乘法“胜利”），提高参与感。  


### 动画帧步骤与交互关键点
1. **初始化**：展示AC自动机的根节点（绿色方块），控制面板（开始/暂停、单步、重置、调速滑块）。  
2. **插入忌讳词汇**：比如插入“ob”，节点`0→1→2`变为红色，`fail`指针（红色箭头）从`2`指向`0`。  
3. **插入基本词汇**：比如插入“boom”，计算`tran[0][1]`（从状态`0`出发，拼接“boom”后的状态）。  
4. **小L的DP转移**：演示从`i=0`到`i=10`的转移，柱状图动态更新，最终显示长度为10的合法方案数。  
5. **大L的矩阵快速幂**：演示矩阵`mat`的构造，计算`mat^10`，显示长度为10的合法方案数（与小L的结果一致）。  


### 旁白提示
- **插入忌讳词汇**：“现在插入忌讳词汇‘ob’，节点2变为红色（禁忌），`fail`指针从2指向0。”  
- **DP转移**：“选择基本词汇‘boom’，从状态0出发，沿字符走，状态变为5，方案数增加。”  
- **矩阵快速幂**：“矩阵`mat`的左上角是长度1的转移，右上角是长度2的转移，计算`mat^10`，得到长度为10的方案数。”  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移
- **AC自动机**：用于处理多模式串匹配问题（比如过滤敏感词、统计文本中的关键词出现次数）。  
- **矩阵快速幂优化DP**：用于处理状态转移具有线性性、且转移步数很大的问题（比如斐波那契数列、路径计数问题）。  


### 练习推荐 (洛谷)
1. **洛谷 P3502 [POI2010] CHO-Hamsters**  
   🗣️ **推荐理由**：本题与“魔法咒语”思路一致，用AC自动机处理禁忌词汇，矩阵快速幂优化DP，巩固AC自动机和矩阵快速幂的应用。  

2. **洛谷 SP1676 GEN - Text Generator**  
   🗣️ **推荐理由**：生成不包含任何禁忌词汇的字符串，长度为L，用AC自动机和DP，练习小L的DP处理。  

3. **洛谷 CF696D Legen...**  
   🗣️ **推荐理由**：拼接单词求长度为L的方案数，用AC自动机和矩阵快速幂，练习大L的矩阵优化。  


## 7. 学习心得与经验分享 (若有)
**参考经验 (来自 shadowice1984)**：“我在解决这个问题时，最初在AC自动机的`fail`指针处理上卡了很久，后来通过`ed[p] |= ed[fail[p]]`传递禁忌标记才解决。这让我意识到AC自动机的禁忌标记必须传递到`fail`链上的所有节点。”  
**点评**：这位作者的经验很典型。在AC自动机中，`fail`指针的处理是关键，禁忌标记的传递能确保不遗漏任何禁忌情况。动手模拟`fail`指针的传递过程（比如用小例子测试）是避免错误的有效方法。  


## 结语
本次关于“[BJOI2017]魔法咒语”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解AC自动机、DP和矩阵快速幂的结合应用。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪

---
处理用时：251.17秒
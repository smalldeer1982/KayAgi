# 题目信息

# 秘密任务

## 题目背景

>飞雪连天射白鹿，笑书神侠倚碧鸳。

>谨纪念金庸先生。

 但是这与本题没有联系。


## 题目描述

wgr 是 $R$ 国军队总指挥官。现在，他决定组织两个小队分别去执行两个秘密任务。

wgr 将派出 $N$ 名战士来执行这两个任务，他们的编号为 $1 \sim N$ 。由于任务无比重要，wgr 需要使派出的队伍配合绝对默契 。配合绝对默契指队伍中**任何**两名战士的配合都是默契的。同时，他还需要使两个队伍的战斗力差距尽可能小，队伍的战斗力定义为 $F=2^{k}$，$k$ 为队伍的人数，不允许有人剩余。

wgr 已经知道哪些战士之间的配合是默契的，但由于时间紧迫，wgr 来不及慢慢整理资料了，现在，他请你以最快的速度帮他完成资料的整理，并告诉他：

1. 一共有多少种不同的分组方案。两种方案被认为是不同的当且仅当其两支队伍战斗力差值不同。
2. 所有分组方案中，最小的战斗力差值是多少，由于这个差值可能很大，请对  $10^9+7$ 取模后再输出。
3. 有多少对战士配合默契但是不可能被分在同一小组。

**注意：** 特别地，由于队伍的默契程度十分重要，一支队伍 $N$ 名战士另一支队伍 $0$ 名战士也是合法的分组方案。


## 说明/提示

本题共有三个 Subtask。

- Subtask 1：共 $5$ 个测试点，一个测试点 $5$ 分，满足 $N≤30$；
- Subtask 2：共 $3$ 个测试点，一个测试点 $10$ 分，满足 $N≤300$；
- Subtask 3：共 $3$ 个测试点，一个测试点 $15$ 分，满足 $N≤2500$。 

对于所有的数据，不会重复说明同一组关系，$1\le x,y\le  n$ 且 $x\neq y$。此外保证 $0\le m≤n\times (n-1)/2$。


本题开启 Special Judge：

- 若你的答案第一行输出正确你可以得到该测试点 $60\%$ 的分数；
- 若你的答案第二行输出正确你可以得到该测试点 $40\%$ 的分数。

为了确保你能够得到部分分，**请按格式要求输出**。


## 样例 #1

### 输入

```
4 4
3 4
1 2
2 4
2 3```

### 输出

```
2 0
0```

## 样例 #2

### 输入

```
10 2
1 7
3 5
```

### 输出

```
-1
2```

# AI分析结果

# 💡 Kay的C++算法解析：秘密任务 深入学习指南 💡

<introduction>
  今天我们来一起分析“秘密任务”这道C++编程题。这道题需要我们将战士分成两个默契的队伍，并解决三个关键问题：方案数、最小战斗力差、以及无法同组的默契 pair 统计。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：补图二分图染色 + 背包动态规划 (DP)

🗣️ **初步分析**：
> 解决“秘密任务”的关键，在于将“队伍内两两默契”的条件转化为**补图的二分图问题**。简单来说，原图中的边表示“可以同组”，补图中的边则表示“不能同组”（因为原图没有边意味着不默契，无法同组）。如果补图是二分图，那么我们可以将其分成两个独立集（即两个队伍，每个队伍内没有补图的边，对应原图的团）。  
> - **核心难点**：① 补图的构建与二分图合法性判断；② 用背包DP计算合法分组方案；③ 统计无法同组的默契 pair。  
> - **算法流程**：① 构建补图；② 对补图进行二分图染色（判断是否合法）；③ 记录每个联通块的黑白点数；④ 用背包DP计算合法的分组方案；⑤ 统计无法同组的默契 pair。  
> - **可视化设计思路**：用像素块表示战士，颜色（黑/白）表示分组。动态展示补图的构建（原图边消失，补图边出现）、二分图染色（像素块逐渐变色）、背包DP状态转移（进度条显示状态更新）。加入“叮”的音效表示染色完成，“胜利”音效表示找到合法方案。


## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面，为大家筛选了以下2份优质题解（评分≥4星）：
</eval_intro>

**题解一：Monster_Qi（补图二分图染色 + 背包DP）**
* **点评**：这份题解的思路非常清晰，将“队伍内两两默契”转化为补图的二分图问题，逻辑直白。代码风格规范（变量名如`col`表示颜色、`w`记录联通块黑白点数），易于理解。其亮点在于**补图的构建**（通过反转原图边）和**背包DP的状态转移**（模仿0/1背包，选择每个联通块的黑或白点加入集合）。从实践角度看，代码处理了边界条件（如二分图不合法时输出-1），严谨性高，适合竞赛参考。

**题解二：MikukuOvO（补图BFS染色 + 容斥统计）**
* **点评**：此题解用BFS实现二分图染色，比DFS更直观（适合青少年理解）。其亮点在于**第三问的容斥原理**（用总不能同组对数减去补图边数，避免暴力枚举），优化了时间复杂度。代码中的`sigma`记录每个联通块的黑白点乘积（总不能同组对数），`cnt/2`是补图边数（不默契的不能同组对数），逻辑清晰，值得学习。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下3个核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1. **难点1：为什么要构建补图？**
    * **分析**：原图要求队伍内两两有边（团），而团的补集是独立集（补图中没有边）。因此，将问题转化为补图的二分图划分（两个独立集），更容易处理。优质题解中，`a[i][j] ^= 1`（Monster_Qi）或`!vis[i][j]`（MikukuOvO）就是构建补图的关键步骤。
    * 💡 **学习笔记**：补图是解决团问题的常用技巧，将“必须有边”转化为“不能有边”。

2. **难点2：如何判断二分图合法性？**
    * **分析**：二分图的充要条件是没有奇数环。优质题解用DFS（Monster_Qi）或BFS（MikukuOvO）进行染色，若发现相邻节点颜色相同，则说明存在奇数环，无法分组。例如，Monster_Qi的`dfs`函数中，`if(col[i] == col[x]) flag=1`就是合法性判断的关键。
    * 💡 **学习笔记**：二分图染色是判断二分图的有效手段，时间复杂度O(N+M)。

3. **难点3：如何用背包DP计算分组方案？**
    * **分析**：每个联通块的黑白点必须选择其一加入集合（因为不能同组）。优质题解用`f[j]`表示集合大小为j是否合法，转移时`f[j] |= f[j - w[i][0]]`（选黑点）或`f[j] |= f[j - w[i][1]]`（选白点）。例如，Monster_Qi的`for(int j=n;j>=Min;j--)`循环就是背包DP的核心。
    * 💡 **学习笔记**：背包DP用于组合优化问题，这里将每个联通块视为一个物品，选择其黑白点的数量作为“重量”。


### ✨ 解题技巧总结
- **技巧A：问题转化**：将“团划分”转化为“补图二分图划分”，降低问题难度。
- **技巧B：二分图染色**：用DFS/BFS进行染色，判断合法性并记录分组信息。
- **技巧C：背包DP**：用0/1背包计算合法的分组方案，状态转移时考虑每个联通块的选择。


## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个通用的核心C++实现参考（综合Monster_Qi和MikukuOvO的思路）：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了补图构建、二分图染色、背包DP的核心逻辑，旨在提供一个清晰的实现框架。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstring>
    #include <vector>
    using namespace std;

    const int MAXN = 2505;
    const int MOD = 1e9+7;

    int n, m;
    bool graph[MAXN][MAXN], col[MAXN];
    vector<pair<int, int>> components; // 每个联通块的黑白点数
    bool dp[MAXN];

    bool dfs(int u, int c) {
        col[u] = c;
        for (int v = 1; v <= n; v++) {
            if (u == v) continue;
            if (!graph[u][v]) { // 补图有边，不能同组
                if (col[v] == col[u]) return false;
                if (!col[v] && !dfs(v, 3 - c)) return false;
            }
        }
        return true;
    }

    long long pow_mod(long long a, long long b) {
        long long res = 1;
        while (b) {
            if (b & 1) res = res * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return res;
    }

    int main() {
        cin >> n >> m;
        memset(graph, true, sizeof(graph));
        for (int i = 0; i < m; i++) {
            int u, v;
            cin >> u >> v;
            graph[u][v] = graph[v][u] = false; // 原图有边，补图无边
        }

        // 补图构建：反转原图边
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (i != j) graph[i][j] = !graph[i][j];
            }
        }

        // 二分图染色
        bool valid = true;
        for (int i = 1; i <= n; i++) {
            if (!col[i]) {
                int cnt1 = 0, cnt2 = 0;
                if (!dfs(i, 1)) {
                    valid = false;
                    break;
                }
                for (int j = 1; j <= n; j++) {
                    if (col[j] == 1) cnt1++;
                    else if (col[j] == 2) cnt2++;
                }
                components.emplace_back(cnt1, cnt2);
            }
        }

        if (!valid) {
            cout << "-1" << endl;
            return 0;
        }

        // 背包DP
        dp[0] = true;
        for (auto &[a, b] : components) {
            for (int j = n; j >= 0; j--) {
                if (j >= a) dp[j] |= dp[j - a];
                if (j >= b) dp[j] |= dp[j - b];
            }
        }

        // 计算答案
        int ans1 = 0, ans2 = 0;
        for (int i = 0; i <= n/2; i++) {
            if (dp[i] && dp[n - i]) {
                ans1++;
                ans2 = i;
            }
        }
        cout << ans1 << " " << (pow_mod(2, n - ans2) - pow_mod(2, ans2) + MOD) % MOD << endl;

        // 统计第三问（略，参考MikukuOvO的容斥）
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码首先构建补图（反转原图边），然后用DFS进行二分图染色（判断合法性），记录每个联通块的黑白点数。接着用背包DP计算合法的分组方案（`dp[j]`表示集合大小为j是否合法）。最后输出方案数和最小战斗力差。


<code_intro_selected>
接下来，我们剖析优质题解中的核心片段：
</code_intro_selected>

**题解一：Monster_Qi（补图构建）**
* **亮点**：用`a[i][j] ^= 1`快速构建补图。
* **核心代码片段**：
    ```cpp
    for(int i=1;i<=n;i++)	
        for(int j=1;j<=n;j++)
            if(i!=j) a[i][j]^=1;
    ```
* **代码解读**：
    > 原图中`a[i][j]`为1表示有边（可以同组），补图中需要将其反转（`^=1`），即`a[i][j]`为1表示补图有边（不能同组）。这一步是问题转化的关键，将“团划分”转化为“二分图划分”。
* 💡 **学习笔记**：异或操作是反转布尔值的快捷方式。

**题解二：MikukuOvO（容斥统计第三问）**
* **亮点**：用容斥原理避免暴力枚举。
* **核心代码片段**：
    ```cpp
    sigma += a[num][0] * a[num][1]; // 总不能同组对数（黑白点乘积）
    printf("%lld\n", sigma - cnt/2); // 减去补图边数（不默契的不能同组对数）
    ```
* **代码解读**：
    > 每个联通块的黑白点不能同组，总共有`a[0]*a[1]`对。补图中的边表示“不默契的不能同组”，所以需要用总不能同组对数减去补图边数，得到“默契的不能同组”对数（第三问答案）。
* 💡 **学习笔记**：容斥原理可以简化统计问题，避免O(N^2)的暴力枚举。


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了更直观地理解“补图二分图染色”的过程，我设计了一个8位像素风格的动画，结合复古游戏元素，帮助大家“看”到算法的每一步！
\</visualization\_intro\>

  * **动画演示主题**：像素战士“分组大挑战”（模仿FC游戏《坦克大战》的UI风格）

  * **核心演示内容**：
    - 补图构建：原图边（绿色线条）逐渐消失，补图边（红色线条）逐渐出现。
    - 二分图染色：战士（像素块）从起点开始，逐渐变成黑色或白色（表示分组）。
    - 合法性判断：若发现相邻战士颜色相同，屏幕闪烁红色，播放“错误”音效。
    - 背包DP：底部进度条显示`dp`数组的状态更新（绿色块表示`dp[j]`为真）。

  * **设计思路简述**：
    - 8位像素风格：营造轻松复古的学习氛围，符合青少年的审美。
    - 音效提示：“叮”的音效表示染色完成，“胜利”音效表示找到合法方案，“错误”音效表示二分图不合法，强化记忆。
    - 游戏化元素：将染色过程设计为“闯关”，完成一个联通块染色即“过关”，显示“得分+100”，增加成就感。

  * **动画帧步骤**：
    1. **初始化**：屏幕显示10x10的像素网格（代表10名战士），原图边（绿色）连接默契的战士。
    2. **补图构建**：绿色边逐渐消失，红色边（补图）出现，旁白提示：“补图中的红色边表示不能同组！”
    3. **二分图染色**：起点战士（左上角）变成黑色，相邻的补图边战士变成白色，依次扩散。每染色一个战士，播放“叮”的音效。
    4. **合法性判断**：若发现相邻战士颜色相同，屏幕闪烁红色，播放“错误”音效，旁白提示：“无法分组！”
    5. **背包DP**：底部进度条显示`dp`数组的状态，绿色块从左到右扩展，旁白提示：“背包DP正在计算合法方案！”
    6. **结果展示**：若合法，屏幕显示“成功！”，播放“胜利”音效，显示方案数和最小战斗力差。

  * **交互设计**：
    - 单步执行：点击“下一步”按钮，逐步查看补图构建、染色、DP的过程。
    - 自动播放：点击“开始”按钮，动画自动执行，速度可调（滑块从“慢”到“快”）。
    - 重置：点击“重置”按钮，回到初始状态，重新演示。


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
理解了补图二分图染色和背包DP的思路后，我们可以尝试以下相似问题，巩固所学知识：
\</similar\_problems\_intro\>

  * **通用思路迁移**：
    - 补图二分图染色：适用于“团划分”问题（如将节点分成两个团）。
    - 背包DP：适用于“组合优化”问题（如选择物品使总和满足条件）。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P1330 [NOIP2011 提高组] 封锁阳光大学**
          * 🗣️ **推荐理由**：这道题需要将节点分成两个集合，使得每条边的两个节点属于不同集合（二分图染色），与本题的补图二分图问题类似。
    2. **洛谷 P2055 [ZJOI2009] 假期的宿舍**
          * 🗣️ **推荐理由**：这道题需要判断是否存在完美匹配（二分图匹配），是二分图问题的延伸。
    3. **洛谷 P3386 [模板] 二分图匹配**
          * 🗣️ **推荐理由**：这是二分图匹配的模板题，帮助巩固二分图的基本概念。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
从优质题解中，我们可以学到一些宝贵的经验：
\</insights\_intro\>

> **参考经验 (来自 Monster_Qi)**：“补图的构建是解决本题的关键，一开始我没想到转补图，导致思路卡住。后来看了题解，才明白团问题可以转化为补图的独立集问题。”
>
> **点评**：这位作者的经验很典型。在解决图论问题时，**问题转化**是关键。如果直接解决原问题困难，可以尝试转补图、转对偶图等方法，往往能事半功倍。


\<conclusion\>
本次关于“秘密任务”的C++解题分析就到这里。希望这份学习指南能帮助大家理解补图二分图染色和背包DP的核心思想。记住，编程的乐趣在于将复杂问题转化为简单模型，不断尝试和思考！下次我们再一起探索新的编程挑战！💪
\</conclusion\>

---
处理用时：165.90秒
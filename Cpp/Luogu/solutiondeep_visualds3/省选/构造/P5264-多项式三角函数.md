# 题目信息

# 多项式三角函数

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个 $\bmod{\:x^n}$ 下的多项式 $F(x)$，满足 $F(x)\equiv\sin{A(x)}$ 或 $F(x)\equiv\cos{A(x)}$。

所有运算在 $\bmod\ 998244353$ 意义下进行。

## 说明/提示

对于 $100\%$ 的数据：$n\leq10^5$，$a_i\in[0,998244352]\cap\mathbb{Z}$。

前 $5$ 个点 $type=0$，后 $5$ 个点 $type=1$。

## 样例 #1

### 输入

```
8 0
0 4 2 6 1 5 3 7```

### 输出

```
0 4 2 332748113 998244338 931694687 998244320 72887640```

## 样例 #2

### 输入

```
8 1
0 4 2 6 1 5 3 7```

### 输出

```
1 0 998244345 998244345 665496220 332748123 44366450 133099314```

# AI分析结果

# 💡 Kay的C++算法解析：多项式三角函数 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：多项式算法（多项式指数函数、多项式求逆）

🗣️ **初步分析**：  
解决“多项式三角函数”问题，关键在于**用欧拉公式将三角函数转化为指数函数的组合**，再通过多项式指数函数（`exp`）和多项式求逆（`inv`）计算结果。简单来说，欧拉公式就像“数学翻译机”，把`sin`和`cos`翻译成`exp`的组合，而多项式`exp`和`inv`则是“计算引擎”，负责处理这些组合。  

### 核心思路
题目要求计算`sin(A(x))`或`cos(A(x))`（模`x^n`和`998244353`）。根据欧拉公式：  
- `cos(A(x)) = [exp(i*A(x)) + exp(-i*A(x))] / 2`  
- `sin(A(x)) = [exp(i*A(x)) - exp(-i*A(x))] / (2i)`  

其中，`i`是模`998244353`下的虚数单位（值为`86583718`，因为`i² ≡ -1 mod 998244353`）。因此，问题转化为计算`exp(i*A(x))`和其逆元`exp(-i*A(x))`，再组合得到结果。  

### 核心难点与解决方案
- **难点1**：如何将三角函数转化为指数函数？→ 用欧拉公式翻译。  
- **难点2**：模意义下的虚数单位`i`怎么处理？→ 预计算`i = 86583718`（`g^((p-1)/4)`，`g`是原根）。  
- **难点3**：多项式`exp`和`inv`的高效实现？→ 用快速数论变换（NTT）优化，时间复杂度`O(nlogn)`。  

### 可视化设计思路
计划设计一个**像素风格的“多项式实验室”**动画，展示`exp(i*A(x))`的计算过程：  
- **场景**：8位像素风的实验室，用不同颜色的方块代表多项式系数（如红色代表`A(x)`的系数，蓝色代表`exp`后的系数）。  
- **关键步骤**：  
  1. **输入展示**：红色方块排列成`A(x)`的系数序列。  
  2. **乘以`i`**：红色方块变成紫色（代表`i*A(x)`）。  
  3. **exp计算**：紫色方块通过“递归分裂”动画（每一步分裂成更小的方块）生成蓝色的`exp(i*A(x))`系数。  
  4. **求逆**：蓝色方块通过“镜像反转”动画生成绿色的`exp(-i*A(x))`系数。  
  5. **组合结果**：蓝色和绿色方块合并，根据`sin`或`cos`的公式生成最终的黄色系数（结果）。  
- **交互设计**：支持“单步执行”（点击按钮一步步看）、“自动播放”（调整速度滑块），并伴随音效（如`NTT`变换用“叮”声，`exp`计算用“嗡嗡”声，结果生成用“胜利”声）。  


## 2. 精选优质题解参考

### 题解一：NaCly_Fish（赞：18）
* **点评**：  
  这份题解是“多项式三角函数”的经典模板，思路清晰到“一眼就能看懂”！作者直接套用欧拉公式，将问题转化为`exp`和`inv`的组合，代码结构工整（预处理`NTT`、`exp`、`inv`等函数），变量命名规范（如`img`代表虚数单位`i`）。最值得学习的是**代码优化**：用`#pragma`指令开启循环优化，提升了`NTT`的运行速度；预处理`inv2`（2的逆元）和`rt`（旋转因子），减少了重复计算。从实践角度看，这份代码可以直接用于竞赛，边界处理（如模运算的负数处理）非常严谨。

### 题解二：密期望（赞：16）
* **点评**：  
  这道题解的“原理讲解”非常详细，适合初学者理解欧拉公式的应用！作者从泰勒展开讲起，一步步推导欧拉公式，再过渡到多项式三角函数的计算，逻辑链条完整。代码部分，作者用`polymerization`类封装了多项式操作（如`exp`、`sin`、`cos`），结构清晰，可读性高。亮点是**模板通用性**：作者提供了模板函数，支持不同类型的`i`（如复数或模意义下的`i`），方便扩展到其他问题。

### 题解三：Gauss0320（赞：1）
* **点评**：  
  这份题解的“代码注释”非常详细，适合学习`exp`和`inv`的实现细节！作者逐函数解释了`NTT`、`inv`、`derivative`（导数）、`inter`（积分）、`ln`（对数）、`exp`的作用，比如`derivative`函数计算多项式的导数，`inter`函数计算积分。代码中的`img`变量直接使用`86583718`，符合题目要求。虽然赞数少，但代码的可读性和注释质量很高，适合初学者模仿。  


## 3. 核心难点辨析与解题策略

### 1. 关键点1：欧拉公式的应用
* **分析**：  
  欧拉公式是连接三角函数和指数函数的“桥梁”，但很多同学会疑惑“为什么能用到多项式上？”。其实，多项式的泰勒展开和指数函数的泰勒展开是一致的，因此欧拉公式对多项式同样成立。例如，`exp(i*A(x))`的泰勒展开就是`cos(A(x)) + i*sin(A(x))`，所以可以通过组合`exp`的结果得到`sin`和`cos`。  
* 💡 **学习笔记**：欧拉公式是多项式三角函数的“钥匙”，记住它的形式（`e^(ix) = cosx + isinx`）就能解决问题。

### 2. 关键点2：模意义下的虚数单位`i`
* **分析**：  
  虚数单位`i`在模`998244353`下的取值是`86583718`，这是因为`998244353`是一个质数，且`(998244353-1)/4 = 249561088`，原根`g=3`的`249561088`次方就是`i`（`3^249561088 ≡ 86583718 mod 998244353`）。计算时，只需要将`A(x)`的每个系数乘以`i`，再计算`exp`即可。  
* 💡 **学习笔记**：`i`的值是固定的，记住`86583718`就能直接用。

### 3. 关键点3：多项式`exp`和`inv`的实现
* **分析**：  
  多项式`exp`是计算`e^F(x)`的多项式，其核心是用牛顿迭代法：`exp(F(x)) = exp(F0(x)) * (1 - ln(exp(F0(x))) + F(x))`，其中`F0(x)`是`F(x)`的低次部分。多项式`inv`是计算`1/F(x)`的多项式，同样用牛顿迭代法：`inv(F(x)) = inv(F0(x)) * (2 - F(x)*inv(F0(x)))`。这两个函数都需要`NTT`来加速多项式乘法，时间复杂度`O(nlogn)`。  
* 💡 **学习笔记**：`exp`和`inv`是多项式算法的基础，一定要掌握它们的模板。

### ✨ 解题技巧总结
- **技巧A**：用欧拉公式翻译问题，将三角函数转化为指数函数的组合。  
- **技巧B**：预计算`i`的值（`86583718`），避免重复计算。  
- **技巧C**：使用`NTT`优化多项式乘法，提升`exp`和`inv`的速度。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合了NaCly_Fish、密期望、Gauss0320的题解，提取了`exp`、`inv`、`sin`、`cos`的核心代码，结构清晰，适合初学者学习。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  const int MOD = 998244353;
  const int G = 3;
  const int IMG = 86583718; // 虚数单位i

  // 快速幂
  int qpow(int a, int b) {
      int res = 1;
      while (b) {
          if (b & 1) res = 1LL * res * a % MOD;
          a = 1LL * a * a % MOD;
          b >>= 1;
      }
      return res;
  }

  // NTT变换
  void ntt(vector<int>& a, bool inv) {
      int n = a.size();
      for (int i = 1, j = 0; i < n; i++) {
          int bit = n >> 1;
          for (; j & bit; bit >>= 1) j ^= bit;
          j ^= bit;
          if (i < j) swap(a[i], a[j]);
      }
      for (int len = 2; len <= n; len <<= 1) {
          int wlen = qpow(G, (MOD - 1) / len);
          if (inv) wlen = qpow(wlen, MOD - 2);
          for (int i = 0; i < n; i += len) {
              int w = 1;
              for (int j = 0; j < len / 2; j++) {
                  int u = a[i + j], v = 1LL * a[i + j + len / 2] * w % MOD;
                  a[i + j] = (u + v) % MOD;
                  a[i + j + len / 2] = (u - v + MOD) % MOD;
                  w = 1LL * w * wlen % MOD;
              }
          }
      }
      if (inv) {
          int invn = qpow(n, MOD - 2);
          for (int& x : a) x = 1LL * x * invn % MOD;
      }
  }

  // 多项式乘法
  vector<int> multiply(vector<int> a, vector<int> b) {
      int n = 1;
      while (n < a.size() + b.size()) n <<= 1;
      a.resize(n), b.resize(n);
      ntt(a, false), ntt(b, false);
      for (int i = 0; i < n; i++) a[i] = 1LL * a[i] * b[i] % MOD;
      ntt(a, true);
      return a;
  }

  // 多项式求逆
  vector<int> inverse(vector<int> a) {
      vector<int> b(1, qpow(a[0], MOD - 2));
      while (b.size() < a.size()) {
          int len = b.size() << 1;
          vector<int> a_sub(a.begin(), a.begin() + min(a.size(), len));
          a_sub.resize(len), b.resize(len);
          vector<int> tmp = multiply(b, b);
          tmp = multiply(tmp, a_sub);
          for (int i = 0; i < len; i++) b[i] = (2LL * b[i] - tmp[i] + MOD) % MOD;
          b.resize(len / 2);
      }
      b.resize(a.size());
      return b;
  }

  // 多项式导数
  vector<int> derivative(vector<int> a) {
      for (int i = 1; i < a.size(); i++) a[i - 1] = 1LL * a[i] * i % MOD;
      a.pop_back();
      return a;
  }

  // 多项式积分
  vector<int> integral(vector<int> a) {
      a.push_back(0);
      for (int i = a.size() - 1; i > 0; i--) a[i] = 1LL * a[i - 1] * qpow(i, MOD - 2) % MOD;
      a[0] = 0;
      return a;
  }

  // 多项式对数
  vector<int> log(vector<int> a) {
      vector<int> da = derivative(a);
      vector<int> inv_a = inverse(a);
      vector<int> tmp = multiply(da, inv_a);
      tmp.resize(a.size() - 1);
      return integral(tmp);
  }

  // 多项式指数
  vector<int> exp(vector<int> a) {
      vector<int> b(1, 1);
      while (b.size() < a.size()) {
          int len = b.size() << 1;
          vector<int> b_sub(b.begin(), b.begin() + len / 2);
          vector<int> log_b = log(b_sub);
          log_b.resize(len);
          vector<int> a_sub(a.begin(), a.begin() + min(a.size(), len));
          a_sub.resize(len);
          for (int i = 0; i < len; i++) log_b[i] = (a_sub[i] - log_b[i] + MOD) % MOD;
          log_b[0] = (log_b[0] + 1) % MOD;
          b = multiply(b_sub, log_b);
          b.resize(len);
      }
      b.resize(a.size());
      return b;
  }

  // 多项式sin
  vector<int> sin_poly(vector<int> a) {
      int n = a.size();
      for (int& x : a) x = 1LL * x * IMG % MOD;
      vector<int> exp_ix = exp(a);
      vector<int> exp_neg_ix = inverse(exp_ix);
      vector<int> res(n);
      int inv_2i = qpow(2LL * IMG % MOD, MOD - 2);
      for (int i = 0; i < n; i++) {
          res[i] = 1LL * (exp_ix[i] - exp_neg_ix[i] + MOD) % MOD * inv_2i % MOD;
      }
      return res;
  }

  // 多项式cos
  vector<int> cos_poly(vector<int> a) {
      int n = a.size();
      for (int& x : a) x = 1LL * x * IMG % MOD;
      vector<int> exp_ix = exp(a);
      vector<int> exp_neg_ix = inverse(exp_ix);
      vector<int> res(n);
      int inv_2 = qpow(2, MOD - 2);
      for (int i = 0; i < n; i++) {
          res[i] = 1LL * (exp_ix[i] + exp_neg_ix[i]) % MOD * inv_2 % MOD;
      }
      return res;
  }

  int main() {
      int n, type;
      cin >> n >> type;
      vector<int> a(n);
      for (int i = 0; i < n; i++) cin >> a[i];
      vector<int> res;
      if (type == 0) res = sin_poly(a);
      else res = cos_poly(a);
      for (int x : res) cout << x << " ";
      cout << endl;
      return 0;
  }
  ```
* **代码解读概要**：  
  代码分为以下几个部分：  
  1. **基础函数**：`qpow`（快速幂）、`ntt`（NTT变换）、`multiply`（多项式乘法）。  
  2. **多项式操作**：`inverse`（求逆）、`derivative`（导数）、`integral`（积分）、`log`（对数）、`exp`（指数）。  
  3. **三角函数计算**：`sin_poly`（计算`sin(A(x))`）、`cos_poly`（计算`cos(A(x))`），通过欧拉公式组合`exp`和`inv`的结果。  
  4. **主函数**：读取输入，调用相应的三角函数函数，输出结果。  


### 针对各优质题解的片段赏析

#### 题解一：NaCly_Fish（来源：洛谷）
* **亮点**：代码优化（循环优化、预处理旋转因子）。  
* **核心代码片段**：  
  ```cpp
  #pragma GCC optimize ("unroll-loops")
  #pragma GCC optimize (2)
  ...
  void init(int n) {
      int w, lim = 1;
      while (lim <= n) lim <<= 1, ++siz;
      for (reg int i = 1; i != lim; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (siz - 1));
      inv2[1] = inv[1] = rt[lim >> 1] = 1;
      w = power(114514, (p - 1) >> siz); // 114514是原根
      for (reg int i = (lim >> 1) + 1; i != lim; ++i) rt[i] = (ll)rt[i - 1] * w % p;
      for (reg int i = (lim >> 1) - 1; i; --i) rt[i] = rt[i << 1];
      for (reg int i = 2; i <= n; ++i) inv[i] = (ll)(p - p / i) * inv[p % i] % p;
      for (reg int i = 1; i <= siz; ++i) inv2[1 << i] = p - ((p - 1) >> i);
  }
  ```
* **代码解读**：  
  作者用`#pragma`指令开启了循环优化（`unroll-loops`）和等级2优化（`optimize (2)`），提升了代码运行速度。`init`函数预处理了`rev`（反转数组）、`rt`（旋转因子）、`inv`（逆元）、`inv2`（2的逆元），减少了`NTT`和`inv`函数的重复计算。例如，`rt`数组存储了所有需要的旋转因子，避免了每次`NTT`都重新计算。  
* 💡 **学习笔记**：预处理是提升代码速度的关键，尤其是在竞赛中，预处理能节省大量时间。

#### 题解二：密期望（来源：洛谷）
* **亮点**：模板通用性（支持不同类型的`i`）。  
* **核心代码片段**：  
  ```cpp
  template <typename T>
  polymer sin(const polymer &a, T i) {
      polymer x(a * i);
      return (exp(x) - exp(-x)) * inverse(2 * i);
  }
  template <typename T>
  polymer cos(const polymer &a, T i) {
      polymer x(a * i);
      return (exp(x) + exp(-x)) * inverse(2);
  }
  ```
* **代码解读**：  
  作者用模板函数封装了`sin`和`cos`的计算，支持不同类型的`i`（如复数或模意义下的`i`）。例如，当`i`是模意义下的`86583718`时，函数会计算模意义下的`sin`和`cos`；当`i`是复数时，函数会计算复数域下的`sin`和`cos`。这种模板设计提高了代码的通用性，方便扩展到其他问题。  
* 💡 **学习笔记**：模板函数能提高代码的复用性，适合处理类似的问题。

#### 题解三：Gauss0320（来源：洛谷）
* **亮点**：代码注释详细（逐函数解释作用）。  
* **核心代码片段**：  
  ```cpp
  void derivative(int *a, int *b, int n) {
      // 计算多项式a的导数，结果存到b
      b[n - 1] = 0;
      for (int i = 1; i < n; ++i)
          b[i - 1] = (ll)a[i] * i % P;
  }
  void inter(int *a, int *b, int n) {
      // 计算多项式a的积分，结果存到b
      *b = 0;
      for (int i = n - 1; i >= 0; --i)
          b[i + 1] = a[i] * (ll)pow(i + 1, P - 2) % P;
  }
  ```
* **代码解读**：  
  作者为`derivative`（导数）和`inter`（积分）函数添加了详细的注释，说明函数的作用（计算导数/积分）和参数（输入数组`a`、输出数组`b`、长度`n`）。例如，`derivative`函数通过循环计算`a`的导数：`b[i-1] = a[i] * i`（导数的系数公式）。这种注释能帮助初学者快速理解函数的作用，避免混淆。  
* 💡 **学习笔记**：代码注释是良好的编程习惯，能提高代码的可读性，方便自己和他人理解。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：多项式实验室（8位像素风）

### 核心演示内容
展示`sin(A(x))`的计算过程，包括：  
1. 输入`A(x)`的系数。  
2. 乘以虚数单位`i`（`86583718`）。  
3. 计算`exp(i*A(x))`。  
4. 计算`exp(-i*A(x))`（`exp(i*A(x))`的逆元）。  
5. 组合`exp(i*A(x))`和`exp(-i*A(x))`得到`sin(A(x))`。  

### 设计思路简述
采用8位像素风（类似FC红白机），用不同颜色的方块代表多项式系数，结合动画和音效，让学习者直观看到多项式的变化过程。例如：  
- 红色方块：`A(x)`的系数。  
- 紫色方块：`i*A(x)`的系数（乘以`i`后）。  
- 蓝色方块：`exp(i*A(x))`的系数（`exp`计算后）。  
- 绿色方块：`exp(-i*A(x))`的系数（`inv`计算后）。  
- 黄色方块：`sin(A(x))`的系数（组合后）。  

### 动画帧步骤与交互关键点
1. **场景初始化**：  
   - 屏幕左侧显示“多项式实验室”标题（8位像素字体）。  
   - 中间区域显示`A(x)`的系数（红色方块排列成一行）。  
   - 右侧显示控制面板：“开始”、“单步”、“重置”按钮，速度滑块（0~100）。  
   - 底部显示当前步骤的文字提示（如“输入A(x)的系数”）。  

2. **输入展示**：  
   - 红色方块从左到右依次闪烁，代表`A(x)`的系数（如样例输入中的`0,4,2,6,1,5,3,7`）。  
   - 文字提示：“当前输入的是A(x)的系数，红色方块代表每个项的系数。”  

3. **乘以`i`**：  
   - 红色方块逐渐变成紫色（代表乘以`i`），同时播放“叮”的音效。  
   - 文字提示：“将A(x)的每个系数乘以虚数单位i（86583718），得到i*A(x)。”  

4. **计算`exp(i*A(x))`**：  
   - 紫色方块通过“递归分裂”动画生成蓝色方块（每一步分裂成更小的方块，代表`exp`的递归计算）。  
   - 播放“嗡嗡”的音效，文字提示：“计算exp(i*A(x))，蓝色方块代表结果的系数。”  

5. **计算`exp(-i*A(x))`**：  
   - 蓝色方块通过“镜像反转”动画生成绿色方块（代表`exp(i*A(x))`的逆元）。  
   - 播放“叮”的音效，文字提示：“计算exp(-i*A(x))（exp(i*A(x))的逆元），绿色方块代表结果的系数。”  

6. **组合结果**：  
   - 蓝色和绿色方块合并，生成黄色方块（代表`sin(A(x))`的系数）。  
   - 播放“胜利”的音效，文字提示：“组合exp(i*A(x))和exp(-i*A(x))，得到sin(A(x))的系数。”  

7. **交互控制**：  
   - “开始”按钮：自动播放动画（速度由滑块控制）。  
   - “单步”按钮：一步步执行动画（每点击一次执行一步）。  
   - “重置”按钮：恢复到初始状态。  
   - 速度滑块：调整自动播放的速度（滑块越靠右，速度越快）。  

### 旁白提示（文字气泡）
- 在“乘以`i`”步骤：“看，红色方块变成紫色了！这代表我们把A(x)的每个系数乘以了虚数单位i。”  
- 在“计算`exp`”步骤：“蓝色方块正在分裂，这是exp函数在递归计算哦！”  
- 在“组合结果”步骤：“黄色方块就是我们要的sin(A(x))的系数啦！”  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移
多项式`exp`和`inv`是多项式算法的基础，常用于以下场景：  
1. **多项式开根**：计算`sqrt(F(x))`，需要用到`exp`和`log`。  
2. **多项式除法**：计算`F(x)/G(x)`，需要用到`inv`。  
3. **生成函数**：计算生成函数的指数生成函数（如组合计数问题）。  

### 练习推荐 (洛谷)
1. **洛谷 P4726** - 多项式指数函数  
   * 🗣️ **推荐理由**：这是本题的前置条件，必须掌握多项式`exp`的实现。  
2. **洛谷 P4725** - 多项式对数函数  
   * 🗣️ **推荐理由**：多项式`log`是`exp`的基础，掌握它能更好地理解`exp`的计算。  
3. **洛谷 P4728** - 多项式开根  
   * 🗣️ **推荐理由**：多项式开根需要用到`exp`和`log`，是多项式算法的拓展练习。  
4. **洛谷 P4731** - 多项式乘法逆元  
   * 🗣️ **推荐理由**：多项式`inv`是本题的核心，掌握它能解决更多多项式问题。  


## 7. 学习心得与经验分享 (若有)
本次分析的题解中，**NaCly_Fish**提到了“预处理旋转因子能提升`NTT`的速度”，**密期望**提到了“模板函数能提高代码的通用性”，**Gauss0320**提到了“代码注释能帮助理解函数作用”。这些经验对学习者来说非常宝贵：  
- **预处理的重要性**：在竞赛中，预处理能节省大量时间，尤其是对于`NTT`这样的高频操作。  
- **模板的通用性**：模板函数能处理不同类型的问题，提高代码的复用性。  
- **注释的必要性**：代码注释能帮助自己和他人理解函数的作用，避免混淆。  


## 结语
本次关于“多项式三角函数”的C++解题分析就到这里。希望这份学习指南能帮助大家理解多项式算法的核心思想，掌握`exp`和`inv`的实现，以及欧拉公式的应用。记住，多项式算法是竞赛中的重要考点，多练习、多总结才能提高！下次我们再一起探索新的编程挑战！💪

---
处理用时：222.88秒
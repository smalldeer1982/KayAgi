# 题目信息

# 黄牛の争

## 题目背景

Source：天空之城

本题背景中「黄牛」仅代指某游戏中的一种怪物，与一般含义的「[**黄牛**](https://baike.baidu.com/item/黄牛党/285883)」无关。

本题「推荐题目」三灰一黑，但不太能说明本题难度和他们差不多（

相传在很久很久之前梅兰德大陆上空漂浮着一座天空之城，是当时财富、力量、荣誉中心，突然有一天再也不见踪影。

如今已多个世纪不见痕迹的天空之城突然出现，王国的勇士去探索一番，但是飞船船票可不是那么好得到的。

**飞艇码头的船长是梅德龙 · 杜鲁夫，船长为了牟利要求大家必须 *买* *票* *上* *船*，没有票的旅行者无法登船。**

დ琢喵 作为一届黄牛的首领——黄牛党，派出了 $q$ 组黄牛买断了梅德龙 · 杜鲁夫的船票。

她以高价卖出这些船票，并通过差价获取巨额利润。

为维护飞艇码头的治安，梅德龙 · 杜鲁夫规定不允许人类和黄牛打架，当然船长并没有规定黄牛之间不可以打架。

## 题目描述

დ琢喵 的手下有两种黄牛：

1. I 类黄牛「攻击」为 $a$，「血量」为 $A$；
2. II 类黄牛「攻击」为 $b$，「血量」为 $B$。

黄牛之间的作战，满足以下条件：

1. 任意时刻，某一方「血量」$\le 0$ 时，其对手胜利；
2. 每一回合，「攻击」高者先手；
3. 每回合每方出手一次，造成的伤害即其「攻击」值。

构造的 III 类黄牛应当满足下面条件：

1. 「攻击」数值与 I 类黄牛和 II 类黄牛都不同；
2. I 类黄牛和 II 类黄牛作战 II 类黄牛胜利；（若输入不满足该条件则应直接输出 `-1 -1`）
3. II 类黄牛和 III 类黄牛作战 III 类黄牛胜利；
4. III 类黄牛和 I 类黄牛作战 I 类黄牛胜利。

请给出一种合法的构造。

---

**题意简述**

解方程：（若 $x=\text{true}$ 则 $[x]=1$ 反之 $=0$）

$$\begin{aligned}\left\lceil\frac{A}{b}\right\rceil&+[b<a]\le\left\lceil\frac{B}{a}\right\rceil\\\left\lceil\frac{B}{c}\right\rceil&+[c<b]\le\left\lceil\frac{C}{b}\right\rceil\\\left\lceil\frac{C}{a}\right\rceil&+[a<c]\le\left\lceil\frac{A}{c}\right\rceil\\c&\ne a~\text{and}~c\ne b\end{aligned}$$

已知 $a,A,b,B$，解 $c,C$。

## 说明/提示

### 样例说明

对于样例 #1，可设 A 是 $(1,5)$，B 是 $(2,3)$，C 是 $(4,1)$。

其中二元组 $(x,y)$ 表示一个「攻击」为 $x$，「血量」为 $y$ 的黄牛。

下面的表格展现了 A、B、C 的对战情况，括号中的数字表示每回合开始时它们的「血量」数值。

| A 和 B 单挑 | B 和 C 单挑 | C 和 A 单挑 |
| :----------: | :----------: | :----------: |
| $\begin{aligned}&\texttt{A(5)~B(3)}\overset{\texttt{A-2~B-1}}{\Rightarrow\Rightarrow}\\&\texttt{A(3)~B(2)}\overset{\texttt{A-2~B-1}}{\Rightarrow\Rightarrow}\\&\texttt{A(1)~B(1)}\overset{\texttt{A-2}}{\Rightarrow}\\&\texttt{A}\le\texttt{0~\color{red}B win}\end{aligned}$ | $\begin{aligned}&\texttt{B(3)~C(1)}\overset{\texttt{B-4}}{\Rightarrow}\\&\texttt{B}\le\texttt{0~\color{red}C win}\end{aligned}$ | $\begin{aligned}&\texttt{A(5)~C(1)}\overset{\texttt{A-4~C-1}}{\Rightarrow\Rightarrow}\\&\texttt{C}\le\texttt{0~\color{red}A win}\end{aligned}$ |

因此输出剩下一类黄牛即给分。

对于样例 #2：钦定 III 类黄牛攻击力为 $11$，已经足以击倒 II 类黄牛，血量为 $11\sim14$ 都可以输给 I 类黄牛。

因此任意输出一组均给分。

对于样例 #3：II 类黄牛十分强大，难以再构造又能击败 II 类黄牛又能输给 I 类黄牛的 III 类黄牛品种。

因此输出 `-1 -1` 即给分。

### 数据规模

设 $M=\max\left(a,A,b,B\right)$：

- Subtask1(10pts)：$M\le10,q=399\underline0$。
- Subtask2(20pts)：$M\le100,q=399\underline1$，数据随机。
- Subtask3(10pts)：$M\le10^5,q=99\underline2$，数据随机。
- Subtask4(20pts)：$M\le10^5,q=99\underline3$。
- Subtask5(10pts)：$q=399\underline4$，数据随机。
- Subtask6(30pts)：$q=399\underline5$，无特殊限制。
- 本题根据数据强度设置了不同梯度的时间限制，如果有合理的满分做法被卡了请联系我。

提示：数据组数 $q$ **结尾** 的数字（$\underline0,\underline1,\underline2,\underline3,\underline4,\underline5$）可能有助于你判断 Subtask 的类型。

对于 $100\%$ 的数据：$1\le q<4000,1\le M\le10^8$。

### 大样例

本题提供符合 Subtask $2,3,5$ 限制的测试用例。

直接编译并运行下面代码，即可得到 `E01.in` `E02.in` `E03.in` 分别是满足 Subtask $2,3,5$ 限制的测试数据。

```cpp
#include<ctime>
#include<cstdio>
#include<random>
#include<string>
#include<cassert>
#include<cstdlib>
#include<iostream>
#define int long long
void print(int x){
	if (x < 0) x = -x, putchar('-');
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
void printsp(int x){
	print(x), putchar(' ');
}
void println(int x){
	print(x), putchar('\n');
}
char str[] = "E  .in";
const int Buff = 3989;
std::string string;
namespace Data_Maker{
	std::mt19937 rnd(time(0));
	int rand(int l, int r) {
		int x = r - l + 1;
		return (rnd() % x + x) % x + l;
	}
	int a, A, b, B;
	void maker(int subtaskID) {
		int t = Buff + subtaskID;
		if (3 <= subtaskID && subtaskID <= 4)
			t -= 3000;
		println(t);
		if (subtaskID == 2 || subtaskID == 3 || subtaskID == 5) {
			int MOD = 0;
			if (subtaskID == 2) MOD = 100;
			if (subtaskID == 3) MOD = 100000;
			if (subtaskID == 5) MOD = 100000000;
			while (t--) {
				a = rand(1, MOD), A = rand(1, MOD);
				b = rand(1, MOD), B = rand(1, MOD);
				while (b == a)
					b = rand(1, MOD);
				printsp(a), printsp(A), printsp(b), println(B);
			}
		}
	}
	void File(int Test) {
		str[1] = Test / 10 + '0';
		str[2] = Test % 10 + '0';
		freopen(str, "w", stdout);
	}
	void Subtask2() {
		for (int Test = 1; Test <= 1; ++Test) {
			File(Test); maker(2);
		}
	}
	void Subtask3() {
		for (int Test = 2; Test <= 2; ++Test) {
			File(Test); maker(3);
		}
	}
	void Subtask5() {
		for (int Test = 3; Test <= 3; ++Test) {
			File(Test); maker(5);
		}
	}
}
using namespace Data_Maker;
signed main(){
	Subtask2();
	Subtask3();
	Subtask5();
}
```

另外还提供了下面的 Special Judge，可以编译并通过调用 `spj E.in E.out E.ans` 来获取返回信息。

```cpp

#include "testlib.h"
#define int long long
#define inf inf.readLong()
#define ouf ouf.readLong()
#define ans ans.readLong()
bool win(int a, int A, int b, int B){
  int x = 0, f = 1;
  if (a < b)
    a ^= b ^= a ^= b, A ^= B ^= A ^= B, f *= -1;
  while (1) {
    if (B - a <= 0) {
      x = 1;
      break;
    }
    if (A - b <= 0) {
      x = -1;
      break;
    }
    B -= a, A -= b;
  }
  x *= f;
  return x < 0;
}
signed main (signed argc, char**argv) {
  registerTestlibCmd(argc, argv);
  int q = inf;
  for (int t = 1; t <= q; ++t) {
    int a = inf, A = inf, b = inf, B = inf, c = ouf, C = ouf, d = ans, D = ans;
    if (d == -1 && c == -1 && C == -1)
      continue;
    if (c == a)
      quitf (_wa, "Test #%lld, a cannot equal to c!", t);
    if (c < 1 || C < 1)
      quitf (_wa, "Test #%lld, cannot print negative numbers!", t);
    if (!win(c, C, a, A))
      quitf (_wa, "Test #%lld, A cannot beat C!", t);
    if (!win(b, B, c, C))
      quitf (_wa, "Test #%lld, C cannot beat B!", t);
    if (!win(a, A, b, B))
      quitf (_wa, "Test #%lld, B cannot beat A!", t);
  }
  quitf (_ok, "Good job!");
}
```

题目附件中的是本题实际数据的脚造方式，如有更强有意义的数据欢迎在讨论区中提出并 at 出题人。

## 样例 #1

### 输入

```
3
1 5 2 3
2 3 4 1
4 1 1 5```

### 输出

```
4 1
1 5
2 3```

## 样例 #2

### 输入

```
4
14 1 10 15
14 1 10 15
14 1 10 15
14 1 10 15```

### 输出

```
11 11
11 12
11 13
11 14```

## 样例 #3

### 输入

```
1
1 1 999 999```

### 输出

```
-1 -1```

# AI分析结果

# 💡 Kay的C++算法解析：《黄牛の争》深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学建模 + 枚举优化（暴力枚举/整除分块）


🗣️ **初步分析**：  
解决《黄牛の争》的关键，是将“黄牛对战胜负”转化为**可计算的数学不等式**，再通过**枚举+验证**找到满足条件的III类黄牛参数（c, C）。简单来说，这就像“给三把锁找一把钥匙”——c是钥匙，必须同时打开“III赢II”“I赢III”“c≠a/b”这三把锁。  

### 核心算法流程  
1. **数学建模**：将对战规则转化为不等式（如II类赢I类的条件是 $\left\lceil\frac{A}{b}\right\rceil + [b<a] \le \left\lceil\frac{B}{a}\right\rceil$）；  
2. **枚举c**：遍历可能的c值（攻击值），跳过等于a或b的情况；  
3. **验证C的合法性**：对每个c，计算满足“III赢II”和“I赢III”的C范围（如通过公式推导C的上下界）；  
4. **输出结果**：找到第一个合法的(c, C)，或输出-1。  

### 可视化设计思路  
为了直观展示“枚举c→验证C”的过程，我设计了一个**8位像素风的“钥匙开锁”动画**：  
- **场景**：屏幕左侧是“c的枚举进度条”（像素块从左到右移动），中间是“C的范围框”（显示当前c对应的C上下界），右侧是“三把锁”（分别代表三个条件，锁开则变绿）；  
- **交互**：支持“单步执行”（点击一次走一个c）、“自动播放”（调速滑块控制速度），找到合法解时播放“叮~”的胜利音效；  
- **高亮**：当前枚举的c用红色像素块标记，合法的C范围用黄色填充，锁开时闪烁绿色。  


## 2. 精选优质题解参考

### 题解三（E3：数学公式直接计算C范围）  
* **点评**：这份题解的核心亮点是**用数学公式直接推导C的合法区间**，避免了暴力枚举C的时间消耗。作者通过对不等式的变形，得到了C的上下界（$l = b \times (\left\lfloor\frac{B}{c}\right\rfloor + [c < b])$，$r = (\left\lfloor\frac{A}{c}\right\rfloor - [a < c]) \times a + a - 1$），只要l ≤ r，就存在合法的C。这种方法将C的验证从O(M)优化到了O(1)，非常适合大数据场景。代码中的`ok`函数简洁明了，直接返回C的最小值（l+1），逻辑清晰。  

### 题解四（E4：整除分块优化枚举c）  
* **点评**：此题解在E3的基础上，进一步用**整除分块**优化了c的枚举范围。由于$\left\lfloor\frac{A}{c}\right\rfloor$和$\left\lfloor\frac{B}{c}\right\rfloor$的值在连续区间内是相同的，作者将c的枚举分成多个块，每个块内只需要验证一次，大大减少了枚举次数（从O(M)优化到O(√M)）。这种优化技巧是处理“大范围枚举”问题的常用手段，代码中的循环`i = mn(A/(A/i), B/(B/i)) + 1`清晰体现了整除分块的思想。  

### 题解二（E2：二分法找C）  
* **点评**：这份题解针对中等数据，用**二分法**寻找C的合法值。对于每个c，作者通过二分C的范围（1到(M-1)^2），验证是否满足“III赢II”和“I赢III”的条件。二分法将C的验证从O(M)优化到了O(log M)，适合M≤1e5的场景。代码中的二分逻辑严谨，边界处理得当（如c>a时r=A-1，c<b时l=B+1）。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：将对战规则转化为正确的数学不等式**  
* **分析**：对战中的“先手”和“回合数”容易混淆。例如，II类赢I类的条件是“II的回合数 + 先手修正 ≤ I的回合数”（先手修正：如果II的攻击小于I，则II是后手，需要多打一轮，所以加1）。解决这个问题的关键是**模拟对战过程**，总结出回合数的计算方式（$\left\lceil\frac{血量}{对方攻击}\right\rceil$），再考虑先手的影响。  
* 💡 **学习笔记**：数学建模是解决此类问题的第一步，一定要先理解规则再推导公式。  

### 2. **难点2：枚举c的范围过大，导致超时**  
* **分析**：直接枚举c从1到M（M≤1e8）显然不可行。解决方法是**剪枝**：比如c必须满足“能让III赢II”（c> b或C足够大），或者“能让I赢III”（c< a或C足够小）。题解中的“整除分块”更是将枚举范围压缩到了O(√M)。  
* 💡 **学习笔记**：大范围枚举时，一定要想办法“减少不必要的循环”，比如剪枝、分块、数学优化。  

### 3. **难点3：计算C的合法区间**  
* **分析**：对于每个c，需要找到C的范围，使得“III赢II”（C ≥ l）且“I赢III”（C ≤ r）。解决这个问题的关键是**对不等式进行变形**，将C单独放在一边。例如，“III赢II”的条件可以转化为$C ≥ b \times (\left\lfloor\frac{B}{c}\right\rfloor + [c < b])$，“I赢III”的条件可以转化为$C ≤ (\left\lfloor\frac{A}{c}\right\rfloor - [a < c]) \times a + a - 1$。  
* 💡 **学习笔记**：不等式变形时，要注意“上取整”和“下取整”的转换（如$\left\lceil\frac{p}{q}\right\rceil = \left\lfloor\frac{p-1}{q}\right\rfloor + 1$）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（基于E3）  
* **说明**：本代码综合了E3的数学公式推导和E4的整除分块优化，是解决本题的高效实现。  
* **完整核心代码**：  
  ```cpp
  #include<cstdio>
  #define int long long
  int init(){
      char c = getchar();
      int x = 0, f = 1;
      for (; c < '0' || c > '9'; c = getchar())
          if (c == '-') f = -1;
      for (; c >= '0' && c <= '9'; c = getchar())
          x = (x << 1) + (x << 3) + (c ^ 48);
      return x * f;
  }
  void print(int x){
      if (x < 0) x = -x, putchar('-');
      if (x > 9) print(x / 10);
      putchar(x % 10 + '0');
  }
  bool win(int a, int b, int c, int d){
      return (b + c - 1) / c + (c < a) <= (a + d - 1) / a;
  }
  int a, A, b, B;
  int ok(int c){
      if (c == a || c == b) return 0;
      int l = b * (B / c + (c < b));
      int r = (A / c - (a < c)) * a + a - 1;
      if (l > r) return 0;
      return l + 1; // 返回最小的合法C
  }
  int mn(int a, int b){ return a < b ? a : b; }
  int mx(int a, int b){ return a > b ? a : b; }
  signed main(){
      int t = init();
      while (t--) {
          a = init(), A = init(), b = init(), B = init();
          if (!win(a, A, b, B) || (B > A && b > a)) {
              puts("-1 -1");
              continue;
          }
          --A, --B; // 转换为下取整
          int c = 0, C;
          // 优先尝试a+1和b+1（常见的合法c）
          if (ok(a + 1)) c = a + 1, C = ok(a + 1);
          else if (ok(b + 1)) c = b + 1, C = ok(b + 1);
          else {
              // 整除分块枚举c
              for (int i = 1; i <= mn(A, B); i = mn(A/(A/i), B/(B/i)) + 1)
                  if (ok(i)) { c = i, C = ok(i); break; }
              if (!c) for (int i = mn(A, B)+1; i <= mx(A, B); i = mx(A, B)/(mx(A, B)/i) + 1)
                  if (ok(i)) { c = i, C = ok(i); break; }
          }
          if (c) print(c), putchar(' '), print(C), putchar('\n');
          else puts("-1 -1");
      }
  }
  ```
* **代码解读概要**：  
  1. **输入输出**：`init`函数快速读取输入，`print`函数递归输出整数；  
  2. **胜负判断**：`win`函数用数学公式判断对战结果；  
  3. **C的合法性检查**：`ok`函数计算C的上下界，返回最小的合法C；  
  4. **主逻辑**：优先尝试a+1和b+1（常见的合法c），否则用整除分块枚举c，找到合法的(c, C)。  


### 题解三（E3）核心片段赏析  
* **亮点**：用数学公式直接推导C的范围，避免暴力枚举C。  
* **核心代码片段**：  
  ```cpp
  int ok(int c){
      if (c == a || c == b) return 0;
      int l = b * (B / c + (c < b));
      int r = (A / c - (a < c)) * a + a - 1;
      if (l > r) return 0;
      return l + 1;
  }
  ```
* **代码解读**：  
  - `l`：III类黄牛赢II类的最小血量（C必须≥l）；  
  - `r`：I类黄牛赢III类的最大血量（C必须≤r）；  
  - 如果l ≤ r，返回最小的合法C（l+1），否则返回0（不合法）。  
* 💡 **学习笔记**：数学公式是优化的关键，掌握不等式变形能大大提高代码效率。  


### 题解四（E4）核心片段赏析  
* **亮点**：用整除分块优化c的枚举范围，减少循环次数。  
* **核心代码片段**：  
  ```cpp
  for (int i = 1; i <= mn(A, B); i = mn(A/(A/i), B/(B/i)) + 1)
      if (ok(i)) { c = i, C = ok(i); break; }
  ```
* **代码解读**：  
  - `i`从1开始，每次跳到下一个块的起始位置（`mn(A/(A/i), B/(B/i)) + 1`）；  
  - 每个块内的$\left\lfloor\frac{A}{i}\right\rfloor$和$\left\lfloor\frac{B}{i}\right\rfloor$值相同，只需验证一次i即可。  
* 💡 **学习笔记**：整除分块是处理“大范围枚举”问题的常用技巧，能将时间复杂度从O(M)降到O(√M)。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：《黄牛钥匙开锁记》（8位像素风）  
**设计思路**：用“找钥匙开锁”的游戏场景，将枚举c的过程转化为“寻找能打开三把锁的钥匙”，增强趣味性和直观性。  


### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧是“c的枚举进度条”（100个像素块，从左到右代表c从1到100）；  
   - 中间是“C的范围框”（显示当前c对应的l和r，用黄色填充合法范围）；  
   - 右侧是“三把锁”（分别代表“c≠a/b”“III赢II”“I赢III”，锁闭时为红色，打开时为绿色）；  
   - 底部是“控制面板”（单步、自动播放、重置按钮，调速滑块）。  

2. **算法启动**：  
   - 点击“开始”按钮，进度条上的红色像素块从左到右移动（代表枚举c）；  
   - 每移动到一个c，中间的范围框显示当前c的l和r，右侧的锁根据条件变化（如c≠a/b则第一把锁打开）。  

3. **核心步骤演示**：  
   - 当枚举到合法的c时，三把锁全部打开，播放“叮~”的胜利音效，进度条停止；  
   - 点击“单步”按钮，可逐步查看每个c的验证过程；  
   - 拖动“调速滑块”，可调整自动播放的速度（如1x、2x、3x）。  

4. **游戏化元素**：  
   - **关卡设计**：将枚举c的过程分为“小关卡”（如c从1到20为第一关，21到40为第二关），完成关卡可获得“像素星星”奖励；  
   - **AI演示**：点击“AI自动演示”按钮，算法会自动枚举c，找到合法解，像“贪吃蛇AI”一样展示过程。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **数学建模**：将实际问题转化为数学不等式（如《排队接水》《货仓选址》）；  
- **枚举优化**：用剪枝、分块、二分法减少枚举次数（如《寻找第k小的数》《区间求和》）；  
- **整除分块**：处理涉及$\left\lfloor\frac{n}{i}\right\rfloor$的问题（如《约数之和》《数论分块》）。  


### 练习推荐（洛谷）  
1. **洛谷 P1164 《小A点菜》**  
   - 🗣️ **推荐理由**：这道题需要将“点菜”问题转化为动态规划模型，锻炼数学建模能力。  
2. **洛谷 P1824 《进击的奶牛》**  
   - 🗣️ **推荐理由**：此题用二分法寻找最大间距，适合练习“二分法优化枚举”。  
3. **洛谷 P2085 《最小函数值》**  
   - 🗣️ **推荐理由**：这道题需要用优先队列优化枚举，适合练习“大范围枚举的优化技巧”。  


## 7. 学习心得与经验分享（若有）  
> **参考经验（来自题解作者）**：“我在解决这个问题时，最初尝试暴力枚举c和C，但超时了。后来想到用数学公式推导C的范围，再用整除分块优化c的枚举，才通过了所有测试用例。”  
> **点评**：作者的经验很典型——**暴力枚举是基础，但优化是关键**。当暴力超时的时，一定要想办法用数学或算法技巧减少循环次数。比如本题中的“整除分块”，就是处理大范围枚举的有效手段。  


## 结语  
本次关于《黄牛の争》的C++解题分析就到这里。希望这份学习指南能帮助大家理解**数学建模**和**枚举优化**的核心思想。记住，编程的乐趣在于“用智慧解决问题”——当你用优化后的代码通过大数据测试时，那种成就感是无法用言语表达的！下次我们再一起探索新的编程挑战！💪

---
处理用时：141.80秒
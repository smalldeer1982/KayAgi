# 题目信息

# [CoE R4 C] 网格

## 题目描述

**这是一道交互题。**

有一张 $n$ 个点的无向无权图。

这张图有一个特殊性质：存在一个点 $u \ (1 \leq u \leq n)$ 到正整数对 $(x, y) \ (1 \leq x \leq l, 1 \leq y \leq c)$ 的**一一对应**关系，使得 $n = l \cdot c$，且点 $u, v$ 间存在边当且仅当 $u, v$ 对应的数对 $(x_u, y_u), (x_v, y_v)$ 满足 $|x_u - x_v| + |y_u - y_v| = 1$。换而言之，这张图和 $l$ 行 $c$ 列的网格图同构。

现在，你要通过一些询问还原这张图的结构。每次询问时，你需要给定一个点 $u \ (1 \leq u \leq n)$。询问的返回值是一个长为 $n$ 的数组 $\{d_i\} \ (1 \leq i \leq n)$，表示点 $u, i$ 间的最短路径所经过的边数。

请你使用不超过 $q$ 次询问，还原出这张图的结构。

---

### 交互格式

**本题有多组数据。**

首先输入一个整数 $T$，表示数据组数。

对于每组数据：

- 首先输入一个整数 $n$，表示图的点数。
- 接下来，你可以执行一些询问。对于每次询问，输出一个整数 $u$，为你询问的点。然后，输入 $n$ 个整数 $\{d_i\}$，为询问的返回值。
- 当你确定答案后，输出一个整数 $0$，然后输出答案。

在输出答案时：

- 第一行输出两个整数 $l, c$；
- 接下来，输出 $l$ 行 $c$ 列整数，为你还原的对应关系。第 $i$ 行 $j$ 列的数为 $(i, j)$ 对应的编号。

如果有多个答案，你可以输出任意一个。一个答案是正确的，当且仅当它和标准答案无法被任何询问区分：也就是，在这两个答案对应的网格图中，任意点对间的最短路径所经过的边数都是相同的。

---

请注意：**在每次执行询问或者输出答案后，你应该清空缓冲区：**

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Java 中，使用 `System.out.flush()`。
- 在 Python 中，使用 `stdout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 对于其他语言，请自行查阅对应语言的帮助文档。


## 说明/提示

### 样例 $1$ 解释

对于样例，以下 $3$ 行 $2$ 列的网格图也是正确的输出。

```
3 2
4 2
3 5
6 1
```

左边是样例对应的网格图，右边是以上输出对应的网格图。

![](https://cdn.luogu.com.cn/upload/image_hosting/jy23v0au.png)

---

### 评分标准

对于一个子任务，令 $q_{\max}$ 为你在这个子任务的所有测试数据中的最大询问次数。

如果交互的格式不合法，运行超出了时间限制，或者你的答案不正确，或者 $q_{\max} > q$，你的得分为 $0$。

否则，对于子任务 $1 \sim 3$，你得满分；对于子任务 $4$，你的分数由下表给出：

| 条件 | 分数 |
| :-: | :-: |
| $q_{\max} \leq 3$ | $61$ |
| $q_{\max} = 4$ | $41$ |
| $q_{\max} = 5$ | $31$ |
| $q_{\max} = 6$ | $21$ |
| $q_{\max} \geq 7$ | $11$ |

---

### 数据规模

**本题采用捆绑测试。**

| 子任务 | 分值 | $n \leq$ | $q = $  | 特殊性质 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $3$ | $4$ | $4$ | 无 |
| $2$ | $13$ | $10^5$ | $4$ | 存在解使得 $l = 1$ |
| $3$ | $23$ | $36$ | $36$ | 存在解使得 $2 \leq l, c \leq 6$ |
| $4$ | $61$ | $10^5$ | $12$ | 无 |

对于所有数据，保证 $1 \leq T \leq 10^3$，$1 \leq n \leq 10^5$，$\sum n \leq 3 \times 10^5$。

在部分测试数据中，交互器是自适应的。也就是，图的结构可能会根据你的询问而变化。但是可以保证：在每次询问之后，存在至少一个答案符合当前所有询问的返回值。


## 样例 #1

### 输入

```
1
6

0 2 2 3 1 1

2 0 2 1 1 3

2 2 0 1 1 1

3 1 1 0 2 2

1 1 1 2 0 2

1 3 1 2 2 0```

### 输出

```


1

2

3

4

5

6

0
2 3
2 5 1
4 3 6```

## 样例 #2

### 输入

```
2
1



2

1 0```

### 输出

```


0
1 1
1

2

0
2 1
1
2```

# AI分析结果

# 💡 Kay的C++算法解析：[CoE R4 C] 网格 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**几何推导与交互策略**（基于网格图的曼哈顿距离特性）


🗣️ **初步分析**：  
这道题是**交互题**，需要通过最多3次询问还原网格图的结构。核心思路是利用**网格图的几何性质**——**角点（如左上角、右下角）到其他点的曼哈顿距离具有唯一性**，且通过两个邻角的距离可以计算出每个点的坐标。  

简单来说，网格图就像一张“坐标纸”，每个点的位置可以用`(x,y)`表示，相邻点的曼哈顿距离为1。我们的目标是通过询问几个关键节点（如角点）的距离，反推所有点的坐标。  

### 核心算法流程：
1. **找第一个角点**：询问1号点，距离1号点最远的点一定是网格的一个角点（如左上角）。  
2. **找对角点**：询问这个角点，距离它最远的点是对角点（如右下角）。  
3. **计算网格尺寸**：对角点的距离等于`l + c - 2`（`l`行`c`列），结合`l*c = n`可求出`l`和`c`。  
4. **计算所有点坐标**：通过两个角点的距离，用公式推导每个点的`(x,y)`坐标。  

### 可视化设计思路：
- **像素风格**：用8位像素块代表节点，颜色表示距离（如1号点的距离用蓝色渐变，角点用红色高亮）。  
- **关键步骤动画**：  
  - 询问1号点时，节点按距离从近到远依次闪烁（蓝色加深）。  
  - 最远点（角点）被红色框标记，伴随“叮”的音效。  
  - 询问角点时，对角点（最远点）同样被标记，显示`l`和`c`的计算过程（如屏幕下方弹出“l=3, c=2”的像素文字）。  
- **交互控制**：支持“单步执行”（逐次展示询问和计算）、“自动播放”（快速演示流程），以及“重置”（重新开始动画）。  


## 2. 精选优质题解参考

**题解一：来源：Sakura_xyz（赞：2）**  
* **点评**：  
  这份题解的**思路非常清晰**，抓住了网格图“角点距离最远”的核心特性，用3次询问就解决了问题。逻辑推导严谨：从1号点找最远点作为第一个角点，再找对角点，最后通过数学公式计算坐标。  
  代码**规范性强**：变量名`a1`、`a2`、`a3`分别存储三次询问的结果，函数`Ask`封装了询问逻辑，结构工整。**算法有效性高**：处理了所有边界情况（如1xN的网格、单节点），符合子任务4的“q≤3”要求，实践价值高。  
  亮点：通过`sum1`（`i*j`）和`sum2`（`(l-i+1)*(c-j+1)`）计算1号点的坐标，巧妙利用了矩形区域的点数量特性，避免了复杂的几何判断。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何确定角点？**  
- **分析**：网格图中，角点（如左上角）到其他点的曼哈顿距离最大。例如，1号点的最远点一定是角点（反证法：若不是角点，可向更远处移动，距离会更大）。  
- 💡 **学习笔记**：最远点是角点的特性是解决本题的关键，记住这个结论可以快速定位角点。  

### 2. **难点2：如何处理边界情况（如1xN的网格）？**  
- **分析**：1xN的网格是特殊情况，每个点的度数（距离为1的节点数）为1或2。题解中通过`get_d`函数计算度数，若1号点度数为1，则直接输出1xN的网格。  
- 💡 **学习笔记**：边界情况需要优先处理，否则会影响后续的角点判断。  

### 3. **难点3：如何通过两个角点的距离计算坐标？**  
- **分析**：设左上角为`X`，右下角为`Y`，则点`p`的坐标`(tx, ty)`可通过公式推导：`ty = (dis_Z(p) + dis_X(p) - dis_X(Z) + 2)/2`（`Z`是左下角或右上角），`tx = dis_X(p) - ty + 2`。  
- 💡 **学习笔记**：数学公式是坐标计算的核心，需要理解曼哈顿距离与网格坐标的关系。  


### ✨ 解题技巧总结  
- **技巧A：利用几何特性**：网格图的角点距离最远，这是快速定位关键节点的关键。  
- **技巧B：封装交互逻辑**：用`Ask`函数封装询问过程，避免重复代码，提高可读性。  
- **技巧C：处理边界情况**：优先判断1xN、单节点等特殊情况，避免复杂逻辑。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了题解的核心逻辑，封装了询问、角点查找、坐标计算等功能，适用于所有情况。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  const int MAXN = 100005;
  int n, a1[MAXN], a2[MAXN], a3[MAXN];

  void Ask(int* a, int x) {
      cout << x << endl;
      for (int i = 1; i <= n; i++) cin >> a[i];
  }

  int get_d(int* a) {
      int ret = 0;
      for (int i = 1; i <= n; i++) ret += (a[i] == 1);
      return ret;
  }

  void solve() {
      cin >> n;
      Ask(a1, 1);
      if (get_d(a1) == 0) { // 单节点
          cout << 0 << endl;
          cout << 1 << ' ' << 1 << endl;
          cout << 1 << endl;
          return;
      }
      if (get_d(a1) == 1) { // 1xN网格
          vector<int> a(n);
          a[0] = 1;
          for (int i = 1; i <= n; i++) a[a1[i]] = i;
          cout << 0 << endl;
          cout << 1 << ' ' << n << endl;
          for (int i = 0; i < n; i++) cout << a[i] << ' ';
          cout << endl;
          return;
      }
      // 找第一个角点（1号点的最远点）
      int X = 1;
      for (int i = 1; i <= n; i++) if (a1[i] > a1[X]) X = i;
      Ask(a2, X);
      // 找对角点（X的最远点）
      int Y = X;
      for (int i = 1; i <= n; i++) if (a2[i] > a2[Y]) Y = i;
      // 计算l和c
      int sum_lc = a2[Y] + 2;
      int l = 1, c = n;
      for (int i = 1; i <= n; i++) {
          if (n % i == 0 && i + n / i == sum_lc) {
              l = i;
              c = n / i;
              break;
          }
      }
      // 计算1号点的坐标（x_1, y_1）
      int t1 = 0, t2 = 0;
      for (int i = 1; i <= n; i++) {
          if (a1[i] + a2[i] == a2[1]) t1++; // sum1 = i*j
          if (a1[i] + (l + c - 2 - a2[i]) == (l + c - 2 - a2[1])) t2++; // sum2 = (l-i+1)*(c-j+1)
      }
      int x_1 = 1, y_1 = 1;
      for (int i = 1; i <= l; i++) {
          for (int j = 1; j <= c; j++) {
              if (i + j == a2[1] + 2 && i * j == t1 && (l - i + 1) * (c - j + 1) == t2) {
                  x_1 = i;
                  y_1 = j;
                  break;
              }
          }
      }
      // 生成网格
      vector<vector<int>> grid(l, vector<int>(c));
      for (int i = 1; i <= n; i++) {
          int tx = (a2[i] + (a1[i] - (abs(x_1 - 1) + abs(y_1 - 1))) + 2) / 2;
          int ty = a2[i] - tx + 2;
          grid[tx - 1][ty - 1] = i;
      }
      // 输出结果
      cout << 0 << endl;
      cout << l << ' ' << c << endl;
      for (int i = 0; i < l; i++) {
          for (int j = 0; j < c; j++) {
              cout << grid[i][j] << ' ';
          }
          cout << endl;
      }
  }

  int main() {
      int T;
      cin >> T;
      while (T--) solve();
      return 0;
  }
  ```  
* **代码解读概要**：  
  代码分为三个部分：  
  1. **交互封装**：`Ask`函数负责输出询问并读取结果。  
  2. **边界处理**：判断单节点、1xN网格等特殊情况，直接输出结果。  
  3. **核心逻辑**：找角点、计算网格尺寸、推导坐标、生成网格。  


### 针对优质题解的片段赏析  
**题解一：来源：Sakura_xyz**  
* **亮点**：巧妙利用`sum1`和`sum2`计算1号点的坐标，避免了复杂的几何判断。  
* **核心代码片段**：  
  ```cpp
  int t1 = 0, t2 = 0;
  for (int i = 1; i <= n; i++) {
      if (a1[i] + a2[i] == a2[1]) t1++; // sum1 = i*j
      if (a1[i] + (l + c - 2 - a2[i]) == (l + c - 2 - a2[1])) t2++; // sum2 = (l-i+1)*(c-j+1)
  }
  ```  
* **代码解读**：  
  - `t1`统计满足`dis(1,i) + dis(X,i) = dis(X,1)`的点数量，这些点位于以`X`为左上角、`1`为右下角的矩形中，数量等于`i*j`（`1`的坐标为`(i,j)`）。  
  - `t2`统计满足`dis(1,i) + dis(Y,i) = dis(Y,1)`的点数量，这些点位于以`1`为左上角、`Y`为右下角的矩形中，数量等于`(l-i+1)*(c-j+1)`。  
  通过这两个值，可以反推出`1`的坐标`(i,j)`。  
* 💡 **学习笔记**：利用矩形区域的点数量特性，可以快速计算坐标，这是一种巧妙的数学技巧。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素探险家的网格寻宝之旅**  
（仿FC红白机风格，用像素块代表节点，颜色表示距离，音效增强互动）


### 核心演示内容：  
1. **场景初始化**：屏幕显示一个8位像素风格的网格（初始为空白），底部有“开始”“单步”“重置”按钮，右侧有速度滑块。  
2. **询问1号点**：  
   - 1号点（像素块）闪烁，伴随“哔”的音效。  
   - 所有节点按距离1号点的远近依次变色（蓝色：近，深蓝色：远）。  
   - 最远点（角点）被红色框标记，屏幕弹出文字“找到角点X！”。  
3. **询问角点X**：  
   - 角点X闪烁，伴随“哔”的音效。  
   - 所有节点按距离X的远近依次变色（绿色：近，深绿色：远）。  
   - 对角点Y被红色框标记，屏幕弹出文字“找到对角点Y！l=3, c=2”。  
4. **计算坐标**：  
   - 每个节点的坐标（tx, ty）通过公式推导，像素块从空白变为对应的数字（如`2`、`5`等）。  
   - 完成后，屏幕弹出“网格还原成功！”的文字，伴随胜利音效。  


### 交互与游戏化元素：  
- **单步执行**：点击“单步”按钮，逐次展示询问、找角点、计算坐标的过程。  
- **自动播放**：拖动速度滑块调整播放速度，算法自动完成所有步骤，像“贪吃蛇AI”一样演示。  
- **音效**：询问时播放“哔”声，找到角点时播放“叮”声，完成时播放胜利音效。  
- **关卡设计**：将“找角点”“计算坐标”设为小关卡，完成后获得“星星”奖励（像素星星闪烁）。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **几何推导**：本题的角点距离特性可用于其他网格图问题（如求最短路径、定位节点）。  
- **交互策略**：最少询问次数的问题，通常需要找到“关键节点”（如角点、中心点），通过它们的信息推导所有节点。  


### 练习推荐 (洛谷)  
1. **洛谷 P1002 [NOIP2002 普及组] 过河卒**  
   - 🗣️ **推荐理由**：这道题需要计算网格中的路径数，锻炼几何推导能力，与本题的网格坐标计算思路相似。  
2. **洛谷 P1003 [NOIP2000 提高组] 铺地毯**  
   - 🗣️ **推荐理由**：本题需要处理网格中的覆盖问题，锻炼对网格坐标的理解，与本题的坐标推导有共通之处。  
3. **洛谷 P1162 填涂颜色**  
   - 🗣️ **推荐理由**：这道题需要用BFS遍历网格，锻炼网格图的遍历能力，与本题的交互策略（找最远点）有相似之处。  


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自 Sakura_xyz)**：“我在解决这个问题时，最初没有考虑到1xN的特殊情况，导致代码在小数据时出错。后来通过计算度数（距离为1的节点数），优先处理了这种情况，才通过了所有测试用例。”  
**点评**：这位作者的经验很重要！在编程中，**边界情况**往往是最容易忽略的，但也是最容易导致错误的。通过计算度数（`get_d`函数），可以快速判断1xN的网格，避免复杂的逻辑处理。  


## 总结  
本次分析的“网格”题，核心是利用网格图的几何特性（角点距离最远）和曼哈顿距离公式，通过最少的询问还原网格结构。解题的关键是**找角点**、**处理边界情况**、**推导坐标**。希望这份指南能帮助你掌握几何推导和交互策略的技巧，下次遇到类似问题时能举一反三！💪  

（注：代码中的`Ask`函数需要根据题目要求清空缓冲区，实际使用时请添加`cout.flush()`。）

---
处理用时：132.29秒
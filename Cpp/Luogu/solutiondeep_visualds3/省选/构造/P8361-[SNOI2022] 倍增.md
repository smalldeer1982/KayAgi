# 题目信息

# [SNOI2022] 倍增

## 题目描述

小 Z 是一个喜欢编程的女孩子。

这天，她在做一道编程题的时候偶然发现了一个神奇的整数 $142857$。

$142857 \times 2 = 285714$，而 $285714$ 的所有数位恰好是 $142857$ 的一个排列。

她很好奇，有没有更大的满足这种性质的整数。

她写了一个搜索，发现了一些更大的有趣的数：

$26835741 \times 2 = 53671482$

$0987312654 \times 2 = 1974625308$

$\dots$

她不满足于解决十进制下这样的问题，于是她想知道，是否在 $B$ 进制下存在一个 $n$ 位正整数 $x$，满足 $2x$ 的所有数位在 $B$ 进制下是 $x$ 的所有数位的一个排列。

由于她讨厌数字 $0$，因此她还要求对于任意 $1 \leq i \leq n$，$x$ 和 $2x$ 在 $B$ 进制下的第 $i$ 位不能同时为 $0$。

## 说明/提示

**【样例 1 解释】**

- 第一组数据的解释参见【题目描述】。
- 对于第二组数据，可以通过枚举所有的 $n$ 位 $B$ 进制数说明一定不能找到这样的正整数。
- 对于第三组数据，$2x$ 的 $7$ 进制表示为 $103635_{(7)}$，因此这是一个满足题意的答案。

注意此样例的答案文件仅表明了一种可能的合法答案，不表明答案文件恰好对应标准程序的输出。

**【样例 2/3 解释】**

注意此样例的答案文件仅表明了一种可能的合法答案，不表明答案文件恰好对应标准程序的输出。

**【提示】**

由于答案可能不唯一，我们下发了校验器 `checker.cpp` 和库文件 `testlib.h`。

可以使用以下命令编译 `checker.cpp`：

```
g++ -o checker checker.cpp -O2 -std=c++11
```

将 `checker.cpp` 编译得到可执行文件 `checker` 后你可以使用以下方式测试你的答案：

`checker <input> <output> <answer>`：利用选手目录下的 `double/double*.ans` 可以用来检验你的答案在样例测试点 `double/double*.in` 的正确性。

`checker <input> <output> <output>`：会检查你的所有有解输出是否符合题目要求。注意以此种方式测试的时候，输出无解总会被报告为合法，因为在此种运行方式下我们只会检查你报告的所有解。

**请选手注意多组数据之间的清空问题。**

**【数据规模与约定】**

对于全部数据，$1 \leq T \leq 10^4$，$2 \leq \sum B \leq 2 \times 10^5$，$1 \leq \sum n \leq 2 \times 10^5$，$n \geq 1$，$B \geq 2$。

具体的数据规模与约定见下表。

| 测试点编号 |    $n \leq$     |    $ B \leq$    | $T \leq$ | 特殊约定            |
| :--------: | :-------------: | :-------------: | :------: | ------------------- |
|    $1$     |       $8$       |       $8$       |   $10$   |                     |
|    $2$     |       $8$       |       $8$       |  $10^4$  |                     |
|    $3$     | $2 \times 10^5$ |       $8$       |   $10$   |                     |
|    $4$     | $2 \times 10^5$ |       $8$       |  $10^4$  |                     |
|    $5$     | $2 \times 10^5$ |       $8$       |  $10^4$  |                     |
|    $6$     |      $15$       |      $15$       |  $100$   |                     |
|    $7$     |      $40$       |      $40$       |  $100$   |                     |
|    $8$     |      $100$      |      $100$      |  $100$   |                     |
|    $9$     |      $300$      |      $300$      |  $100$   |                     |
|    $10$    |     $1000$      |     $1000$      |  $100$   |                     |
|    $11$    |     $3000$      |     $3000$      |  $100$   |                     |
|    $12$    |     $15000$     |     $15000$     |  $100$   |                     |
|    $13$    |     $50000$     |     $50000$     |  $100$   |                     |
|    $14$    | $2 \times 10^5$ | $2 \times 10^5$ |  $100$   |                     |
|    $15$    |      $200$      |      $200$      |  $10^4$  | $n \geq 100$        |
|    $16$    |     $5000$      |     $5000$      |  $10^4$  | $n \geq 100$        |
|    $17$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  | $n \geq 100$        |
|    $18$    |      $300$      |      $300$      |  $10^4$  | $B=3k-1,k \in \N^*$ |
|    $19$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  | $B=3k-1,k \in \N^*$ |
|    $20$    |      $300$      |      $300$      |  $10^4$  | $B=3k,k \in \N^*$   |
|    $21$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  | $B=3k,k \in \N^*$   |
|    $22$    |      $100$      |      $100$      |  $10^4$  |                     |
|    $23$    |      $500$      |     $5000$      |  $10^4$  |                     |
|    $24$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  |                     |
|    $25$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  |                     |


## 样例 #1

### 输入

```
3
6 10
3 3
6 7
```

### 输出

```
1 4 2 8 5 7
-1
0 3 5 3 1 6```

## 样例 #2

### 输入

```
样例 2 见附件 double2.in
本组数据满足测试点 3 的限制。```

### 输出

```
样例 2 见附件 double2.ans```

## 样例 #3

### 输入

```
样例 3 见附件 double3.in
本组数据满足测试点 17 的限制。```

### 输出

```
样例 3 见附件 double3.ans```

# AI分析结果

# 💡 Kay的C++算法解析：[SNOI2022] 倍增 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**构造与暴力枚举（结合数学推导）**  

🗣️ **初步分析**：  
解决“倍增”问题的关键，是**找到B进制下最短的合法n位数x**，使得2x的数位是x的排列（且对应位不同时为0）。因为一旦找到最短解，我们可以通过在**进位位置插入B-1**（例如142857→1428957），快速扩展出更长的解。这就像“搭积木”——最短解是基础块，插入B-1是扩展块，能无限延长合法解。  

### 核心思路拆解：
1. **最小解构造**：枚举可能的短长度（如n=2~9），因为通过打表发现，所有B的最小解n≤9（仅3个B需要n=9）。  
2. **排列与进位枚举**：对于每个n，枚举x的数位与2x的数位对应关系（排列p），以及每一位是否向高位进位（二进制串S）。  
3. **环结构解方程**：排列p会形成若干环（如i→p(i)→p(p(i))→…→i），每个环对应一组线性方程，解出数位值后验证是否在[0,B)范围内。  

### 可视化设计思路：
我们用**8位像素风**模拟“数位侦探”游戏：  
- **场景**：屏幕左侧是B进制数位网格（像素块表示数位，颜色代表值），右侧是“进位控制面板”（二进制开关表示是否进位）。  
- **动画步骤**：  
  1. 枚举排列时，像素块会“跳跃”到对应位置（如i→p(i)），伴随“叮”的音效。  
  2. 处理环结构时，环内像素块会依次“点亮”，显示方程推导过程（如2a_i + c_{i-1} - Bc_i = a_{p(i)}）。  
  3. 解出数位值后，正确的像素块会变成绿色，错误则变红，伴随“胜利”或“失败”音效。  
- **交互**：支持“单步执行”（逐一枚举排列）、“自动播放”（快速遍历所有可能），以及“进位开关”（手动调整进位状态）。  


## 2. 精选优质题解参考

### 题解一：zhoukangyang（思路深度★★★★☆）
* **点评**：  
  这道题解的**核心亮点是环结构与欧拉回路的结合**。作者将排列分解为环，通过线性方程推导数位值，并提出“欧拉回路”条件（0→1和1→0的边数相等），从数学角度解释了合法解的构造原理。虽然代码未完全展示，但思路的严谨性和深度值得学习——它帮我们理解了“为什么这样的解存在”。

### 题解二：panyf（代码实用性★★★★☆）
* **点评**：  
  这道题解的**最大优势是代码的可操作性**。作者通过枚举排列、进位和环结构，实现了最小解的自动计算，并针对n=9的特殊情况打表优化（仅3个B需要打表）。代码中的`wk`函数（枚举排列和进位）和`main`函数（处理查询）结构清晰，变量命名（如`a`表示数位，`s`表示状态）易于理解。特别是打表部分，解决了大n的性能问题，是竞赛中的常用技巧。

### 题解三：Renshey（归纳性★★★★☆）
* **点评**：  
  这道题解的**亮点是归纳构造法**。作者通过观察样例（如142857→1428957），总结出“插入B-1扩展解”的规律，将问题简化为“找最短解”。代码中的`solve`函数（枚举排列和进位）逻辑直白，注释清晰，适合初学者理解“如何从0开始构造解”。此外，作者提到“n≤9”的结论，为暴力枚举提供了理论依据。


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何处理排列的环结构？**  
* **分析**：排列p会将数位分成若干环（如i→p(i)→p(p(i))→…→i）。每个环对应一组线性方程（如2a_i + c_{i-1} - Bc_i = a_{p(i)}），需要解出所有a_i的值。  
* **策略**：对于每个环，从任意节点开始，依次推导其他节点的a_i（如a_{p(i)} = 2a_i + c_{i-1} - Bc_i），最后通过环的闭合性（回到起点）解出a_i的具体值。  
* 💡 **学习笔记**：环结构是处理排列问题的常用技巧，它能将复杂的排列分解为独立的子问题。

### 2. **难点2：如何高效枚举进位？**  
* **分析**：每一位是否向高位进位（c_i）是二进制变量（0或1），枚举所有可能的进位组合（2^n种）会导致n较大时性能下降。  
* **策略**：利用“最小解n≤9”的结论，将n限制在9以内，此时2^9=512种组合是可接受的。此外，通过打表预处理n=9的情况，避免重复计算。  
* 💡 **学习笔记**：暴力枚举的可行性往往依赖于“问题规模小”的结论，打表是优化暴力的有效手段。

### 3. **难点3：如何验证解的合法性？**  
* **分析**：解出的数位a_i必须满足0≤a_i<B，且对应位（x和2x的数位）不同时为0。  
* **策略**：在解出a_i后，遍历所有数位，检查是否在合法范围内。对于对应位的条件，可以通过排列p快速验证（如a_i和a_{p(i)}不同时为0）。  
* 💡 **学习笔记**：合法性验证是构造题的最后一步，也是最容易忽略的一步，必须严谨处理。

### ✨ 解题技巧总结
- **归纳扩展**：找到最小解后，通过插入B-1扩展解，避免重复计算。  
- **环结构分解**：将排列分解为环，简化方程求解。  
- **打表优化**：对于特殊情况（如n=9），预处理结果，提升查询速度。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合Renshey和panyf的题解，提炼出“枚举排列+环结构解方程”的核心逻辑。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;

  const int MAX_B = 2e5 + 5;
  vector<int> ans[MAX_B]; // 存储每个B的最小解

  void solve(int B) {
      if (!ans[B].empty()) return; // 已处理过
      for (int n = 2;; ++n) { // 枚举最小长度n
          vector<int> p(n);
          for (int i = 0; i < n; ++i) p[i] = i;
          do {
              for (int S = 2; S < (1 << n); S += 2) { // 枚举进位（S的二进制位表示是否进位）
                  vector<bool> vis(n, false);
                  vector<int> a(n, -1);
                  bool valid = true;
                  for (int i = 0; i < n && valid; ++i) {
                      if (vis[i]) continue;
                      // 处理环i→p(i)→...→i
                      vector<int> cycle;
                      int j = i;
                      while (!vis[j]) {
                          vis[j] = true;
                          cycle.push_back(j);
                          j = p[j];
                      }
                      // 解方程：对于环中的每个节点，a[p(j)] = 2a[j] + c[j-1] - B*c[j]
                      // 其中c[j]是S的第j位（是否向高位进位）
                      long long k = 1, b = 0;
                      for (int pos : cycle) {
                          k *= 2;
                          b *= 2;
                          if (pos > 0) b += (S >> (pos - 1)) & 1; // c[pos-1]
                          b -= ((S >> pos) & 1) * B; // -B*c[pos]
                      }
                      k -= 1;
                      if (k == 0 || b % k != 0) { valid = false; break; }
                      int a0 = -b / k;
                      if (a0 < 0 || a0 >= B) { valid = false; break; }
                      a[cycle[0]] = a0;
                      for (int t = 1; t < cycle.size(); ++t) {
                          int prev = cycle[t-1];
                          int curr = cycle[t];
                          a[curr] = 2 * a[prev] + ((prev > 0) ? ((S >> (prev - 1)) & 1) : 0) - ((S >> prev) & 1) * B;
                          if (a[curr] < 0 || a[curr] >= B) { valid = false; break; }
                      }
                  }
                  if (valid) {
                      ans[B] = a;
                      return;
                  }
              }
          } while (next_permutation(p.begin(), p.end()));
      }
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      int T;
      cin >> T;
      while (T--) {
          int n, B;
          cin >> n >> B;
          solve(B);
          if (ans[B].size() > n) {
              cout << "-1\n";
              continue;
          }
          // 输出解：在进位位置插入B-1
          int pos = -1;
          for (int i = 0; i < ans[B].size(); ++i) {
              if (2 * ans[B][i] >= B) { // 找到进位位置
                  pos = i;
                  break;
              }
          }
          for (int i = 0; i < pos; ++i) cout << ans[B][i] << ' ';
          for (int i = 0; i < n - ans[B].size(); ++i) cout << B - 1 << ' ';
          for (int i = pos; i < ans[B].size(); ++i) cout << ans[B][i] << ' ';
          cout << '\n';
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. `solve`函数：枚举最小长度n，排列p，进位S，处理每个环的方程，解出数位a_i。  
  2. `main`函数：处理查询，调用`solve`获取最小解，在进位位置插入B-1扩展解。  


### 针对各优质题解的片段赏析

#### 题解二：panyf（打表优化）
* **亮点**：针对n=9的特殊情况打表，避免重复计算。  
* **核心代码片段**：  
  ```cpp
  // 预处理n=9的情况（仅3个B）
  Sol[32131]={3081,6162,12324,24648,17165,2200,17606,4401,8803,};
  Sol[64261]={7168,14336,28672,57344,50427,36594,35714,8928,17857,};
  Sol[160651]={53131,106262,51873,103747,53445,46843,106891,93686,26722,};
  ```
* **代码解读**：  
  这些是预处理好的n=9的解，当B等于这些值时，直接使用打表结果，避免枚举排列和进位（节省大量时间）。  
* 💡 **学习笔记**：打表是处理特殊情况的有效手段，尤其适用于“少量数据需要大量计算”的场景。

#### 题解三：Renshey（归纳构造）
* **亮点**：通过插入B-1扩展解，简化问题。  
* **核心代码片段**：  
  ```cpp
  // 插入B-1扩展解
  for (int i = 0; i < n - ans[B].size(); ++i) {
      cout << B - 1 << ' ';
  }
  ```
* **代码解读**：  
  当n大于最小解长度时，在进位位置插入B-1（B-1×2=2B-2，进位1，剩余B-2，不会改变其他数位的排列），从而快速扩展解。  
* 💡 **学习笔记**：归纳构造是解决“扩展解”问题的常用方法，能将复杂问题简化为“找基础解”。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**数位侦探之“寻找倍增解”**（8位像素风）

### 设计思路简述：
采用**FC红白机风格**（16色调色板），模拟“数位侦探”游戏，让学习者通过操作“进位开关”和“排列按钮”，直观看到解的构造过程。动画中的“像素块”代表数位，颜色变化表示进位状态，音效提示关键操作（如“枚举排列”“解出数位”）。

### 动画帧步骤与交互关键点：
1. **场景初始化**：  
   - 屏幕左侧是**数位网格**（3×3像素块，代表n=3的情况），右侧是**控制面板**（“排列”按钮、“进位”开关、“单步”/“自动”按钮）。  
   - 背景是复古的“实验室”场景（像素化的烧杯、试管），伴随8位风格的背景音乐（如《超级马里奥》的轻快旋律）。

2. **枚举排列**：  
   - 点击“排列”按钮，数位网格中的像素块会“跳跃”到对应位置（如i→p(i)），伴随“叮”的音效。例如，排列p=[1,2,0]时，像素块0跳到位置1，像素块1跳到位置2，像素块2跳到位置0。

3. **处理环结构**：  
   - 环内的像素块会依次“点亮”（从红色变为蓝色），显示方程推导过程。例如，环0→1→2→0时，像素块0显示“2a0 + c2 - Bc0 = a1”，像素块1显示“2a1 + c0 - Bc1 = a2”，像素块2显示“2a2 + c1 - Bc2 = a0”。

4. **解出数位**：  
   - 解出a_i后，正确的像素块会变成绿色，错误则变红。例如，a0=1（B=10）时，像素块0变成绿色，显示“1”；若a0=10（超过B），则变成红色，显示“错误”。

5. **扩展解**：  
   - 点击“扩展”按钮，在进位位置插入B-1（像素块变成黄色），显示“插入B-1”的动画，伴随“咻”的音效。例如，在142857的进位位置插入9，变成1428957。

### 交互与控制：
- **单步执行**：逐一枚举排列和进位，每步显示方程推导过程。  
- **自动播放**：快速遍历所有可能的排列和进位，显示解的构造过程。  
- **进位开关**：手动调整进位状态（0或1），观察解的变化。  
- **重置**：恢复初始状态，重新开始。

### 音效设计：
- **枚举排列**：“叮”（如《塞尔达传说》的菜单音效）。  
- **解出数位**：“滴”（如《俄罗斯方块》的消除音效）。  
- **扩展解**：“咻”（如《超级马里奥》的跳跃音效）。  
- **错误**：“ buzzer”（如《魂斗罗》的死亡音效）。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移：
- **构造与扩展**：本题的“最小解+扩展”思路，可用于解决“寻找满足某种条件的最长序列”问题（如“寻找最长回文子串”的扩展）。  
- **环结构处理**：排列的环结构，可用于解决“置换群”问题（如“求排列的循环节”）。  
- **打表优化**：打表可用于解决“少量数据需要大量计算”的问题（如“求大质数的原根”）。

### 练习推荐 (洛谷)：
1. **洛谷 P1028** - 数的计算  
   * 🗣️ **推荐理由**：这道题需要构造满足条件的数，与本题的“构造最小解”思路类似，可帮助巩固“归纳构造”技巧。  
2. **洛谷 P1117** - 数的计算（加强版）  
   * 🗣️ **推荐理由**：这道题需要处理更大的数据，与本题的“打表优化”思路类似，可帮助巩固“预处理”技巧。  
3. **洛谷 P2670** - 排列问题  
   * 🗣️ **推荐理由**：这道题需要处理排列的环结构，与本题的“环结构解方程”思路类似，可帮助巩固“环结构分解”技巧。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自 panyf)：
> “我在解决这个问题时，最初在n=9的情况卡了很久，后来通过打表预处理，才解决了性能问题。这让我意识到，对于特殊情况，打表是一种非常有效的优化手段。”

**点评**：  
panyf的经验很典型。在编程过程中，**特殊情况的预处理**（如打表）能极大提升程序的性能，尤其是当特殊情况的数量很少时。例如，本题中n=9的情况只有3个B，打表能避免枚举排列和进位（节省大量时间）。


## 🎉 结语
本次关于“[SNOI2022] 倍增”的C++解题分析就到这里。希望这份学习指南能帮助大家理解**构造与暴力枚举**的核心思路，掌握“最小解+扩展”“环结构分解”“打表优化”等技巧。记住，编程能力的提升在于**持续学习、勤于思考和勇于实践**。下次我们再一起探索新的编程挑战！💪

---
处理用时：150.98秒
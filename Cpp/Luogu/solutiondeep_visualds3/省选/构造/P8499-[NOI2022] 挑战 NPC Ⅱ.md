# 题目信息

# [NOI2022] 挑战 NPC Ⅱ

## 题目描述

诸由杨是一名咸鱼大学生，虽然他每天仍然幻想着在多项式时间内解决 NPC 问题。

诸由杨上课的时候了解到子图同构问题是一个 NPC 问题。他打算给出一个子图同构问题的多项式判定算法，间接地去证明 P = NP，这样他一定可以凭借这个伟大的工作荣获图灵奖！只可惜诸由杨才疏学浅，连子图同构问题属于 NPC 的证明都没有想出来。因而他退而求其次，准备判定一个更加简单的问题：

给定两棵有根树 $G, H$。设 $\lvert G \rvert$ 代表树 $G$ 中的节点个数，则这两棵树满足如下限制：$1 \leq \lvert H \rvert \leq \lvert G \rvert \leq \lvert H \rvert + k$。这里诸由杨保证 $k$ 是一个小常数。

诸由杨可以删除 $G$ 中的若干个节点，假定删除节点后后得到的子图为 $G'$。他想要知道是否存在一种删除节点的方式，使得删除后得到的子图 $G'$ 满足如下条件：

- $G'$ 连通。
- $G'$ 包含 $G$ 中的根节点（也就是说 $G$ 根节点在删除过程中没有被删除）。
- $G'$ 和 $H$ 同构（也就是说存在一种让 $G'$ 中点重标号的方式，使得重标号得到的图和 $H$ 完全相同，且 $G$ 中的根节点经过重标号后恰好为 $H$ 的根节点）。

## 说明/提示

**【样例解释 \#1】**

对于第一个测试点，我们删除第一棵树的 $1$ 号节点。此时剩余的树和输入第二棵树均为包含两个节点的有根树，因而输出为 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/vyoktd4u.png)


对于第二个测试点，输入第一颗树深度为 $1$，但是输入第二颗树深度为 $2$。因而不论如何删除第一颗树的节点不会导致其树高增加到 $2$，因而输出为 `No`。

![](https://cdn.luogu.com.cn/upload/image_hosting/r1szu0zb.png)

对于第三个测试点，其输入两颗树均同构于下图的树，因而因而输出为 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/kxyllt4y.png)

----

**【样例 \#2】**

见附件中的 `iso/iso2.in` 与 `iso/iso2.ans`。

该样例数据范围满足测试点 $7 \sim 8$。

----

**【样例 \#3】**

见附件中的 `iso/iso3.in` 与 `iso/iso3.ans`。

该样例数据范围满足测试点 $9 \sim 10$。

----

**【样例 \#4】**

见附件中的 `iso/iso4.in` 与 `iso/iso4.ans`。

该样例数据范围满足测试点 $13$。

----

**【数据范围】**

对于所有测试数据，满足 $1 \leq T \leq 500$，$1 \le n_2 \leq n_1 \le {10}^5$，$\sum n_1 \leq 5 \times {10}^5$，$0 \leq k \leq 5$。各测试点的附加限制如下表所示：

| $n_1,n_2$   | $\sum n_1$           | 测试点           | $k$      | 特殊性质         |
|:-----------:|:--------------------:|:-------------:|:--------:|:------------:|
| $\leq 8$    | $\leq 500$           | $1 \sim 3$       | $\leq 0$ | 无            |
| $\leq 8$    | $\leq 500$           | $4 \sim 6$       | $\leq 5$ | 无            |
| $\leq 16$   | $\leq 10^3$          | $7 \sim 8$         | $\leq 0$ | 无            |
| $\leq 16$   | $\leq 10^3$          | $9 \sim 10$        | $\leq 5$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $11$          | $\leq 0$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $12$          | $\leq 1$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $13$          | $\leq 5$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $14 \sim 16$    | $\leq 0$ | A |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $17 \sim 20$ | $\leq 0$ | B  |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $21$          | $\leq 1$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $22 \sim 23$       | $\leq 3$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $24 \sim 25$       | $\leq 5$ | 无            |

其中附加限制中的特殊性质如下所示：

- 特殊性质 A：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $1$ 个儿子结点；另一种等价的表述是有根树 $G$ 构成了一条链，且根节点为链的一个端点。
- 特殊性质 B：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $2$ 个儿子结点，同时保证 $G$ 的每一个叶节点深度均相同；另一种等价的表述是有根树 $G$ 构成一棵完全二叉树，且根节点为完全二叉树的根节点。

**【提示】**

数据没有**针对任何合理的哈希算法做任何针对性的构造**，所以在合理范围内不需要过度担心因为哈希碰撞而产生的失分问题。

## 样例 #1

### 输入

```
0 3 1
3
2 -1 2
2
-1 1
4
3 3 -1 3
3
2 3 -1
5
-1 1 5 5 1
5
2 3 -1 3 2
```

### 输出

```
Yes
No
Yes
```

# AI分析结果

# 💡 Kay的C++算法解析：[NOI2022] 挑战 NPC Ⅱ 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树哈希（Tree Hashing）+ 递归暴力匹配（基于小常数k的剪枝）


🗣️ **初步分析**：  
解决“挑战NPCⅡ”的关键，是判断有根树G能否通过删除**不超过k个节点**（k≤5），得到一棵与H同构的连通子树（必须包含G的根）。这里的核心思路可以类比“**拼图游戏**”：  
- 树哈希是树的“指纹”：每个子树的哈希值唯一标识其结构（类似拼图块的形状），用于快速判断两个子树是否同构。  
- 递归匹配是“拼拼图”：从根节点开始，先匹配哈希相同的子树（直接拼上），剩下的**不匹配子树**（数量≤k，因为总删除节点数有限）通过**暴力枚举排列**（尝试不同的拼法），递归检查是否能通过删除少量节点完成匹配。  

### 核心算法流程
1. **树哈希预处理**：对G和H的所有子树计算哈希值（排序子节点的哈希值，消除顺序影响）。  
2. **递归匹配根节点**：  
   - 若G的子树大小小于H的，直接返回`No`。  
   - 若两者哈希相同，直接返回`Yes`。  
   - 否则，提取G和H根节点的子节点，匹配哈希相同的子树（去掉这些“已拼好的碎片”）。  
   - 对剩下的**不匹配子树**（数量≤k），枚举所有可能的排列（尝试不同的配对方式），递归检查每个配对是否可行。  

### 可视化设计思路
我们用**8位像素风格**（类似红白机游戏）展示算法流程：  
- **场景初始化**：屏幕左侧是树G（根节点为大红色方块），右侧是树H（根节点为大蓝色方块），子节点用小方块表示，哈希值相同的子节点颜色相同（如绿色）。  
- **匹配过程**：  
  - 哈希相同的子节点会“自动连线”（绿色线条），表示直接匹配。  
  - 剩下的不匹配子节点（红色）会“闪烁”，表示需要枚举排列。  
  - 枚举排列时，红色子节点会“交换位置”（动画效果），尝试不同的配对。  
  - 递归到子节点时，镜头会“缩放”到该子节点，重复上述过程。  
- **交互设计**：支持“单步执行”（查看每一步匹配）、“自动播放”（快速演示），以及“重置”（重新开始）。  


## 2. 精选优质题解参考

### 题解一：Alex_Wei（赞：15）
* **点评**：  
  这份题解的思路非常清晰，**树哈希的设计**（用乘法和加法结合，排序子节点消除顺序影响）和**递归匹配的剪枝**（利用k小的特点）都很到位。代码风格规范（变量名如`f_G`表示G的哈希值，`sz`表示子树大小，含义明确），边界处理严谨（如判断子树大小是否足够）。  
  其核心亮点是**将问题拆解为子树匹配**：先匹配哈希相同的子树，剩下的不匹配子树数量≤k，暴力枚举排列的复杂度（k!）完全可接受。从实践角度看，代码可直接用于竞赛，且树哈希的冲突概率极低（题目提示不卡哈希）。


### 题解二：Fan_sheng（赞：8）
* **点评**：  
  此题解的**动态规划思路**（`dfs(a,b,limit)`表示修改次数不超过`limit`时能否匹配）很有特色。通过`limit`剪枝（若不匹配子树数量超过`limit`，直接返回`inf`），进一步优化了递归效率。  
  其亮点是**明确了修改次数的限制**：每个不匹配子树至少需要删除一个节点，因此当不匹配子树数量超过`limit`时，直接跳过。这种剪枝大大减少了不必要的递归调用，提升了代码运行速度。


### 题解三：pomelo_nene（赞：8）
* **点评**：  
  此题解的**树哈希实现**（用双哈希，即两个模数，进一步降低冲突概率）很值得学习。同时，其**递归匹配的逻辑**（先排序子节点的哈希值，再匹配）与Alex_Wei的题解异曲同工，但代码更简洁。  
  其亮点是**双哈希的使用**：通过两个不同的模数计算哈希值，即使其中一个模数发生冲突，另一个模数也能保证正确性，进一步提高了树哈希的可靠性。


## 3. 核心难点辨析与解题策略

### 1. 树哈希的正确性（如何设计“指纹”）
* **难点**：如何设计哈希函数，使得同构的子树哈希值相同，不同构的子树哈希值不同？  
* **策略**：  
  - 排序子节点的哈希值：有根树的子节点顺序不影响同构，因此需要对每个节点的子节点哈希值进行排序（如升序），再用交换律的运算（如乘法）结合这些哈希值。例如，Alex_Wei的哈希函数：`f_G(x) = (P1 + B^|son_G(x)| * ∏f_G(y)) mod P2`，其中`y`是`x`的子节点（已排序）。  
  - 用双哈希：使用两个不同的模数（如`1e9+7`和`1e9+9`）计算哈希值，降低冲突概率（如pomelo_nene的题解）。  
* 💡 **学习笔记**：树哈希的关键是“消除子节点顺序影响”和“降低冲突概率”。


### 2. 递归过程中的剪枝（如何减少不必要的计算）
* **难点**：若不剪枝，递归的复杂度会很高（如O(n^k)），无法通过大数据。  
* **策略**：  
  - **大小剪枝**：若G的子树大小小于H的，直接返回`No`（无法通过删除节点让子树变大）。  
  - **数量剪枝**：若不匹配的子树数量超过k，直接返回`No`（每个不匹配子树至少需要删除一个节点，总删除数超过k）。  
  - **修改次数剪枝**：若当前修改次数已超过k，直接返回`No`（如Fan_sheng的`limit`参数）。  
* 💡 **学习笔记**：剪枝是递归算法的“加速器”，利用问题的约束条件（如k小）可以大大减少计算量。


### 3. 暴力枚举排列的合理性（为什么k小就能行）
* **难点**：枚举排列的复杂度是k!，当k=5时，5!=120，这为什么可行？  
* **策略**：  
  - 因为k≤5，所以k!的取值很小（5!=120，6!=720），即使每个节点都需要枚举排列，总复杂度也只有O(n*k!)，完全可以处理1e5的数据。  
  - 此外，递归过程中会不断剪枝（如大小剪枝、数量剪枝），实际枚举的排列数量远小于k!。  
* 💡 **学习笔记**：小常数是暴力枚举的“通行证”，当问题中的常数很小时，暴力枚举是可行的。


### ✨ 解题技巧总结
- **树哈希技巧**：排序子节点的哈希值，用交换律的运算（如乘法）结合，必要时用双哈希。  
- **递归剪枝技巧**：利用子树大小、不匹配数量、修改次数等约束条件，减少不必要的递归调用。  
- **暴力枚举技巧**：当常数很小时（如k≤5），暴力枚举排列是可行的，无需担心复杂度。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合Alex_Wei和Fan_sheng的题解，提炼出的核心实现（树哈希+递归匹配）。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <map>
  using namespace std;

  typedef long long ll;
  const int MOD = 1e9 + 7;
  const int BASE = 131;
  const int N = 1e5 + 5;

  struct Tree {
      int n, rt;
      vector<int> e[N];
      ll f[N]; // 哈希值
      int sz[N]; // 子树大小

      void init() {
          cin >> n;
          for (int i = 1; i <= n; i++) e[i].clear();
          for (int i = 1; i <= n; i++) {
              int fa;
              cin >> fa;
              if (fa == -1) rt = i;
              else e[fa].push_back(i);
          }
          dfs(rt);
      }

      void dfs(int u) {
          sz[u] = 1;
          f[u] = 1; // 初始哈希值
          for (int v : e[u]) {
              dfs(v);
              sz[u] += sz[v];
              f[u] = (f[u] * f[v]) % MOD; // 乘法结合子节点哈希（需排序）
          }
          // 排序子节点的哈希值，消除顺序影响
          sort(e[u].begin(), e[u].end(), [&](int x, int y) { return f[x] < f[y]; });
          // 重新计算哈希值（结合排序后的子节点）
          f[u] = 1;
          for (int v : e[u]) {
              f[u] = (f[u] * f[v]) % MOD;
          }
          f[u] = (f[u] + BASE) % MOD; // 加入BASE，避免全1的情况
      }
  } G, H;

  map<pair<int, int>, bool> memo; // 记忆化

  bool dfs(int u, int v, int k) {
      if (memo.count({u, v})) return memo[{u, v}];
      if (G.sz[u] < H.sz[v]) return memo[{u, v}] = false;
      if (G.f[u] == H.f[v]) return memo[{u, v}] = true;
      if (H.sz[v] == 1) return memo[{u, v}] = (G.sz[u] == k + 1); // H是叶子，G需删k个节点

      vector<int> gu = G.e[u], hv = H.e[v];
      int pg = 0, ph = 0;
      vector<int> s, t; // s: G未匹配的子节点，t: H未匹配的子节点

      // 匹配哈希相同的子节点
      while (pg < gu.size() && ph < hv.size()) {
          if (G.f[gu[pg]] == H.f[hv[ph]]) {
              pg++;
              ph++;
          } else if (G.f[gu[pg]] < H.f[hv[ph]]) {
              s.push_back(gu[pg]);
              pg++;
          } else {
              t.push_back(hv[ph]);
              ph++;
          }
      }
      // 处理剩余的子节点
      while (pg < gu.size()) s.push_back(gu[pg++]);
      while (ph < hv.size()) t.push_back(hv[ph++]);

      if (s.size() < t.size() || s.size() > k) return memo[{u, v}] = false;

      // 枚举排列，尝试配对
      vector<int> perm(s.size());
      for (int i = 0; i < s.size(); i++) perm[i] = i;
      do {
          bool ok = true;
          int need = 0;
          for (int i = 0; i < t.size(); i++) {
              int gs = s[perm[i]], hs = t[i];
              if (G.sz[gs] < H.sz[hs]) {
                  ok = false;
                  break;
              }
              need += G.sz[gs] - H.sz[hs];
              if (!dfs(gs, hs, G.sz[gs] - H.sz[hs])) {
                  ok = false;
                  break;
              }
          }
          for (int i = t.size(); i < s.size(); i++) {
              need += G.sz[s[perm[i]]];
          }
          if (ok && need == k) {
              return memo[{u, v}] = true;
          }
      } while (next_permutation(perm.begin(), perm.end()));

      return memo[{u, v}] = false;
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      int C, T, k;
      cin >> C >> T >> k;
      while (T--) {
          G.init();
          H.init();
          memo.clear();
          cout << (dfs(G.rt, H.rt, G.n - H.n) ? "Yes" : "No") << endl;
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **树哈希部分**：`Tree`结构中的`dfs`函数计算每个子树的哈希值（排序子节点，用乘法结合）。  
  2. **递归匹配部分**：`dfs(u, v, k)`函数判断G的u子树能否通过删除k个节点匹配H的v子树。首先匹配哈希相同的子节点，剩下的枚举排列，递归检查每个配对。  


### 针对各优质题解的片段赏析

#### 题解一：Alex_Wei（树哈希部分）
* **亮点**：用乘法和加法结合哈希值，排序子节点消除顺序影响。  
* **核心代码片段**：  
  ```cpp
  void dfs(int id) {
      f[id] = pw[e[id].size()], sz[id] = 1;
      for (int it : e[id]) dfs(it), f[id] = 1ll * f[id] * f[it] % mod, sz[id] += sz[it];
      f[id] = (f[id] + 19260817) % mod;
      sort(e[id].begin(), e[id].end(), [&](int x, int y) { return f[x] < f[y]; });
  }
  ```
* **代码解读**：  
  - `pw[e[id].size()]`：用子节点数量的幂次作为初始哈希值（避免空节点的情况）。  
  - `f[id] = 1ll * f[id] * f[it] % mod`：用乘法结合子节点的哈希值（排序前）。  
  - `sort(e[id].begin(), e[id].end(), [&](int x, int y) { return f[x] < f[y]; })`：排序子节点的哈希值（消除顺序影响）。  
* 💡 **学习笔记**：树哈希的关键是“排序子节点”和“用交换律运算结合哈希值”。


#### 题解二：Fan_sheng（动态规划剪枝部分）
* **亮点**：用`limit`参数限制修改次数，剪枝超过`limit`的情况。  
* **核心代码片段**：  
  ```cpp
  int dfs(int a, int b, int limit) {
      if (G.sz[a] < H.sz[b] || G.edge[a].size() < H.edge[b].size()) return inf;
      if (H.sz[b] == 1) return G.sz[a] - 1;
      // ... 匹配子节点 ...
      if (A.size() > limit) return inf; // 剪枝：不匹配数量超过limit
      // ... 枚举排列 ...
  }
  ```
* **代码解读**：  
  - `if (A.size() > limit) return inf`：若不匹配的子树数量超过`limit`（当前允许的最大修改次数），直接返回`inf`（不可行）。  
  - `if (H.sz[b] == 1) return G.sz[a] - 1`：若H的子树是叶子，G的子树需要删除`G.sz[a] - 1`个节点（只剩根节点）。  
* 💡 **学习笔记**：剪枝是递归算法的“加速器”，利用问题的约束条件可以大大减少计算量。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《树拼图大挑战》（8位像素风格）


### 核心演示内容
1. **场景初始化**：  
   - 屏幕左侧是树G（根节点为大红色方块，编号为`G_root`），右侧是树H（根节点为大蓝色方块，编号为`H_root`）。  
   - 子节点用小方块表示，颜色由其哈希值决定（哈希相同的子节点颜色相同，如绿色）。  
   - 底部有“单步执行”“自动播放”“重置”按钮，以及“速度滑块”（调节动画速度）。

2. **树哈希计算**：  
   - 每个节点的哈希值计算完成后，子节点会“闪烁”（如黄色），表示哈希值已计算。  
   - 排序子节点时，子节点会“交换位置”（动画效果），按哈希值升序排列。

3. **递归匹配过程**：  
   - **匹配哈希相同的子节点**：G和H的子节点中，哈希相同的会“自动连线”（绿色线条），表示直接匹配。连线后，这些子节点会“变暗”（表示已处理）。  
   - **枚举不匹配子节点的排列**：剩下的不匹配子节点（红色）会“闪烁”，表示需要枚举排列。枚举时，红色子节点会“交换位置”（动画效果），尝试不同的配对。  
   - **递归到子节点**：当某对不匹配子节点配对后，镜头会“缩放”到该子节点（如G的子节点`G_child`和H的子节点`H_child`），重复上述过程。

4. **结果展示**：  
   - 若匹配成功，屏幕会显示“胜利”动画（如烟花），并播放上扬的8位音效（如“叮~叮~”）。  
   - 若匹配失败，屏幕会显示“失败”动画（如红色叉号），并播放短促的音效（如“哔~”）。


### 设计思路简述
- **8位像素风格**：营造复古游戏氛围，符合青少年的审美，降低学习压力。  
- **动画效果**：通过“闪烁”“交换位置”“缩放”等效果，直观展示算法的关键步骤（如树哈希计算、子节点匹配、枚举排列）。  
- **交互设计**：支持“单步执行”（让学习者仔细观察每一步）和“自动播放”（快速了解整体流程），满足不同的学习需求。  
- **音效提示**：用不同的音效（如“叮~”表示匹配成功，“哔~”表示失败）强化学习者的记忆，增加学习趣味性。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移
树哈希+递归匹配的思路，可用于解决以下问题：  
1. **子树同构判断**（如洛谷P4323）：判断两棵树是否存在子树同构。  
2. **子树同构计数**（如洛谷P5043）：统计一棵树中与给定子树同构的子树数量。  
3. **有根树同构判断**（如洛谷P8436）：判断两棵有根树是否同构。  


### 练习推荐 (洛谷)
1. **洛谷 P4323** - 《树的同构》  
   * 🗣️ **推荐理由**：这道题是树同构的经典问题，需要判断两棵无根树是否同构。通过练习，你可以巩固树哈希的设计（如无根树转有根树的哈希）。  
2. **洛谷 P5043** - 《子树同构计数》  
   * 🗣️ **推荐理由**：这道题需要统计一棵树中与给定子树同构的子树数量。通过练习，你可以掌握如何用树哈希快速查询子树同构的数量。  
3. **洛谷 P8436** - 《有根树的同构判断》  
   * 🗣️ **推荐理由**：这道题是有根树同构的判断问题，与本题的树哈希部分高度相似。通过练习，你可以巩固有根树哈希的设计（如排序子节点的哈希值）。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自Alex_Wei的题解)
> “我在解决这个问题时，最初没有排序子节点的哈希值，导致树哈希的冲突概率很高，无法通过样例。后来我意识到，有根树的子节点顺序不影响同构，因此需要排序子节点的哈希值，消除顺序影响。”

**点评**：这位作者的经验很典型。树哈希的关键是“消除子节点顺序影响”，如果没有排序子节点的哈希值，即使两个子树同构，它们的哈希值也可能不同。排序子节点是树哈希的“必做步骤”，可以避免这种错误。


### 参考经验 (来自Fan_sheng的题解)
> “我在递归过程中加入了`limit`参数，限制修改次数，这大大减少了不必要的递归调用。例如，当不匹配的子树数量超过`limit`时，直接返回`inf`，避免了无效的枚举。”

**点评**：这位作者的经验说明，剪枝是递归算法的“关键优化”。利用问题的约束条件（如k小），可以剪去大量无效的递归路径，提升代码的运行速度。


## 🎉 结语
本次关于“[NOI2022] 挑战 NPC Ⅱ”的C++解题分析就到这里。希望这份学习指南能帮助你掌握树哈希和递归匹配的技巧，理解如何利用小常数k解决复杂问题。记住，编程的乐趣在于“解决问题”，而不是“背诵代码”——多思考、多练习，你一定会越来越厉害！💪  

下次我们再一起探索新的编程挑战吧！😉

---
处理用时：187.27秒
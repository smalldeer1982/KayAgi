# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果



---
# 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡

<introduction>
今天我们来一起分析“Mivik 写书”这道题。这道题需要计算随机生成字符串的期望复杂度（即所有非空本质不同子串的数目的期望）。通过分析题解，我们会发现容斥原理和并查集是解决问题的关键。让我们一步步拆解思路，掌握核心算法！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`容斥原理与并查集应用` (编程技巧应用类)

🗣️ **初步分析**：
解决这道题的关键在于计算所有可能字符串的不同子串数之和，再除以总方案数得到期望。直接枚举所有字符串不可行（因m可能很大），但n很小（≤20），可以通过**容斥原理**统计每个子串的贡献，并用**并查集**维护字符约束。

简单来说，容斥原理是“先算所有可能，再减去重复，再加回多减的”。例如，一个子串可能在原字符串中出现多次，直接统计会重复计算，容斥能帮我们调整这些重复贡献。并查集则用来处理“某些位置字符必须相同”的约束（比如子串重复出现时，重叠位置的字符必须一致）。

- **题解思路**：多数题解采用“枚举子串长度+容斥+并查集”的思路。具体步骤：枚举所有可能的子串长度x，再枚举该子串在原字符串中出现的位置集合（用二进制状态表示），通过并查集合并重叠位置的字符约束，计算自由选择的字符数（即连通块数），最后用容斥调整贡献符号。
- **核心难点**：如何枚举子串的出现位置、处理重叠位置的字符约束、正确应用容斥的符号规则。
- **可视化设计**：用8位像素风动画模拟枚举过程：每个子串长度x对应一个“像素块”，出现位置用二进制灯条（亮灯表示选中）；并查集合并时，用不同颜色的连接线表示字符必须相同的位置；容斥符号变化时，用“+”“-”图标闪烁提示。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：Huasushis的容斥+并查集解法**  
* **点评**：此题解思路清晰，适合新手入门。作者详细解释了容斥的应用场景（处理子串重复贡献），并通过并查集维护字符约束，代码中变量命名直观（如`fa`表示父节点数组），边界处理严谨（如`tot`统计自由位置数）。亮点在于用位运算优化枚举过程，时间复杂度为O(n²2ⁿ)，在n=20时仍高效。

**题解二：7KByte的简洁实现**  
* **点评**：代码非常简洁，通过预处理`mt`数组快速定位二进制位，并用`bt`数组记录奇偶性（容斥符号）。虽然解释较少，但核心逻辑（枚举子串长度、状态、并查集合并）清晰，适合有一定基础的学习者参考其优化技巧。

**题解三：Reunite的入门向容斥**  
* **点评**：此题解强调“不同长度子串贡献独立”，将问题拆解为各长度子串的贡献之和，降低理解难度。代码中`work`函数明确处理每个长度的子串，变量`ss`统计自由位置数，逻辑直白，适合理解容斥的基本流程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何处理子串的重复贡献和字符约束。结合优质题解，我们提炼以下关键点：
</difficulty_intro>

1.  **关键点1：如何枚举子串的出现位置？**  
    * **分析**：子串长度为x时，可能在原字符串中出现的起始位置有n-x+1个（如n=3，x=2时有位置1和2）。用二进制状态枚举这些位置（如状态i的第j位为1表示子串从位置j开始），共2^(n-x+1)-1种非空状态。  
    * 💡 **学习笔记**：二进制状态枚举是处理“选或不选”问题的常用技巧，适合n较小的场景。

2.  **关键点2：如何处理重叠位置的字符约束？**  
    * **分析**：若子串在位置j和k同时出现（j < k且k-j < x），则重叠部分的字符必须相同（如子串从位置1和2开始，长度为3，则原字符串的位置2、3的字符需同时满足两个子串的约束）。用并查集合并这些位置，统计连通块数（即自由选择的字符数）。  
    * 💡 **学习笔记**：并查集能高效维护“等价类”（必须相同的字符位置），是处理字符约束的关键工具。

3.  **关键点3：如何正确应用容斥的符号规则？**  
    * **分析**：每个状态i的贡献符号由其二进制中1的个数（popcount）决定：若popcount(i)为奇数，贡献为+；偶数则为-（容斥原理中“奇加偶减”）。  
    * 💡 **学习笔记**：容斥的符号规则是“奇数次出现加，偶数次出现减”，确保每个子串仅被统计一次。

### ✨ 解题技巧总结
- **问题拆解**：将总贡献拆解为各长度子串的贡献之和，降低复杂度。  
- **位运算优化**：用二进制状态枚举子串出现位置，快速处理选/不选的状态。  
- **并查集维护约束**：合并重叠位置的字符约束，统计自由选择的字符数（m的幂次）。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合Huasushis和Reunite的题解，提炼一个通用的核心实现，展示容斥+并查集的完整逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了多个优质题解的思路，用容斥枚举子串出现位置，并用并查集维护字符约束，计算每个状态的贡献。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MOD = 1e9 + 7;

ll n, m;
ll ans = 0;

ll qpow(ll x, ll y) {
    ll res = 1;
    while (y) {
        if (y & 1) res = res * x % MOD;
        x = x * x % MOD;
        y >>= 1;
    }
    return res;
}

int fa[25];
int find(int x) {
    return x == fa[x] ? x : fa[x] = find(fa[x]);
}

void solve(int len) {
    int pos_num = n - len + 1; // 子串可能的起始位置数
    for (int s = 1; s < (1 << pos_num); ++s) { // 枚举所有非空位置集合
        // 初始化并查集
        for (int i = 0; i < len; ++i) fa[i] = i;
        int free = 0; // 自由位置数（未被任何子串覆盖的位置）

        // 处理每个位置j，判断是否被子串覆盖
        vector<bool> covered(n, false);
        for (int j = 0; j < pos_num; ++j) {
            if (s & (1 << j)) { // 子串从位置j开始
                for (int k = 0; k < len; ++k) {
                    int pos = j + k; // 原字符串中的位置
                    covered[pos] = true;
                    // 合并当前子串的第k位与第一个位置的约束
                    int u = find(k);
                    int v = find(0);
                    if (u != v) fa[u] = v;
                }
            }
        }

        // 统计未被覆盖的自由位置
        for (int i = 0; i < n; ++i) 
            if (!covered[i]) free++;

        // 统计并查集中的连通块数（自由选择的字符数）
        int cnt = 0;
        for (int i = 0; i < len; ++i) 
            if (find(i) == i) cnt++;

        // 总自由数：未被覆盖的位置 + 连通块数
        ll total_free = free + cnt;
        ll contribution = qpow(m, total_free);

        // 容斥符号：奇数个1则加，偶数则减
        if (__builtin_popcount(s) % 2 == 1) 
            ans = (ans + contribution) % MOD;
        else 
            ans = (ans - contribution + MOD) % MOD;
    }
}

int main() {
    cin >> n >> m;
    for (int len = 1; len <= n; ++len) 
        solve(len);
    // 除以总方案数m^n（模逆元）
    ll inv_total = qpow(qpow(m, n), MOD - 2);
    ans = ans * inv_total % MOD;
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  代码首先枚举每个子串长度`len`，然后枚举该子串所有可能的起始位置集合（二进制状态`s`）。对于每个状态，用并查集合并重叠位置的字符约束，统计未被覆盖的位置数和连通块数（自由选择的字符数），最后根据容斥符号计算贡献。最终除以总方案数`m^n`得到期望。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的巧妙设计。
</code_intro_selected>

**题解一：Huasushis的容斥实现**  
* **亮点**：用位运算快速处理子串覆盖的位置，并用`tot`统计自由位置数，代码简洁高效。  
* **核心代码片段**：
```cpp
void sol(int x) {
    int a = (1 << (n - x + 1)), b = (1 << x) - 1;
    for (int i = 1; i < a; ++i) {
        int c = 0, tot = 0;
        for (int j = 0; j < x; ++j) fa[j] = j;
        for (int j = 0; j < n; ++j) {
            c = (c << 1) | ((i >> j) & 1); // 维护最近x位的覆盖状态
            c &= b;
            if (!c) ++tot; // 未被覆盖的位置
            else {
                int t = c - (c & -c), tmp = find(__builtin_ctz(c));
                while (t) { // 合并重叠位置的约束
                    fa[find(__builtin_ctz(t))] = tmp;
                    t -= t & -t;
                }
            }
        }
        for (int j = 0; j < x; ++j) tot += (j == fa[j]); // 统计连通块
        ll tmp = qpow(m, tot);
        if (__builtin_parity(i)) ans = (ans + tmp) % mod;
        else ans = (ans - tmp + mod) % mod;
    }
}
```
* **代码解读**：  
  `sol(x)`处理长度为x的子串。`a`是起始位置的状态数，`b`是掩码（保留最近x位的覆盖状态）。循环枚举所有状态`i`，用`c`维护当前覆盖状态。若`c`为0表示当前位置未被覆盖（`tot++`）；否则用并查集合并重叠位置（`__builtin_ctz`快速找到最低位的1的位置）。最后统计连通块数，根据状态`i`的奇偶性调整贡献。  
* 💡 **学习笔记**：位运算（如`c &= b`）能高效维护滑动窗口的覆盖状态，`__builtin_ctz`是快速定位二进制位的实用函数。

**题解二：7KByte的简洁实现**  
* **亮点**：预处理`mt`数组快速定位二进制位，用`bt`数组记录奇偶性，代码高度优化。  
* **核心代码片段**：
```cpp
rep(j, 0, x - 1)fa[j] = j;
rep(j, 0, n - 1){
    c = (c << 1) | (1 & (i >> j)), c &= o;
    if(c){
        int p = get(mt[c & -c]), t = c - (c & -c); 
        for(; t; t -= t & -t)fa[get(mt[t & -t])] = p;
    }
    else k++;
}
```
* **代码解读**：  
  `mt[1<<j] = j`预处理二进制位的位置。`c`维护当前覆盖状态，`c & -c`取最低位的1（即第一个覆盖位置），`t`是剩余位。通过并查集将所有覆盖位置的字符约束合并到第一个位置。  
* 💡 **学习笔记**：预处理关键数组（如`mt`）能大幅提高代码效率，适合高频位操作场景。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解容斥和并查集的过程，我们设计一个“像素字符工厂”动画，用8位风格模拟子串覆盖、字符约束合并的过程。
</visualization_intro>

  * **动画演示主题**：`像素字符工厂——子串约束大挑战`  
  * **核心演示内容**：展示枚举子串长度x、起始位置集合s、并查集合并字符约束、容斥调整贡献的全过程。  

  * **设计思路简述**：  
    8位像素风（FC红白机风格）营造轻松氛围；用不同颜色的方块表示字符位置（如红色未覆盖，蓝色覆盖）；并查集合并时用黄色连接线表示约束；容斥符号用“+”“-”图标闪烁提示，增强操作记忆。

  * **动画帧步骤与交互关键点**：  

    1.  **场景初始化**：  
        - 屏幕分为左右两部分：左半是“字符工厂”（n个像素块排成一行，初始为灰色）；右半是“控制面板”（单步/自动按钮、速度滑块）。  
        - 播放8位风格背景音乐（如《超级马里奥》的轻快旋律）。

    2.  **枚举子串长度x**：  
        - 顶部显示当前处理的子串长度x（如x=2时，显示“当前挑战：长度2子串”）。  
        - 左半屏幕的字符块下方出现x长度的“子串模板”（绿色虚线框）。

    3.  **枚举起始位置集合s**：  
        - 右侧“位置灯条”显示n-x+1个小灯（对应起始位置），状态s的二进制位决定哪些灯亮（如s=5=101时，第1、3灯亮）。  
        - 每点击“单步”，灯条切换一个状态，伴随“滴答”音效。

    4.  **并查集合并约束**：  
        - 子串模板根据s的亮灯位置，覆盖到字符工厂的对应位置（如s=101且x=2，覆盖位置0和2）。  
        - 重叠位置的字符块变为蓝色（表示被覆盖），并用黄色连接线连接（如位置0和1被第一个子串覆盖，位置2和3被第二个子串覆盖，重叠的位置2变为蓝色，连接线合并位置2的约束）。  
        - 并查集父节点变化时，用文字气泡显示“合并位置2和位置0”。

    5.  **统计自由位置与贡献**：  
        - 未被覆盖的字符块变为红色，显示数量（如“自由位置：3”）。  
        - 并查集连通块数用绿色数字显示（如“连通块：2”），总自由数=3+2=5，显示“m^5=32”。  
        - 根据s的奇偶性，贡献符号“+”或“-”闪烁，伴随“叮”或“咚”音效。

    6.  **目标达成**：  
        - 所有子串长度处理完成后，屏幕显示总贡献值，播放胜利音效（如《超级玛丽》通关音乐），并提示“最终期望：500000006”。

  * **旁白提示**：  
    - “现在处理长度为2的子串，灯条状态s=5（二进制101），表示子串从位置0和2开始。”  
    - “注意看，位置2被两个子串覆盖，字符必须相同！用黄色线连接它们。”  
    - “这个状态有2个1（偶数），所以贡献要减去m^5哦~”

<visualization_conclusion>
通过这个动画，我们能直观看到容斥如何调整重复贡献，并查集如何维护字符约束，让抽象的算法变得“看得见，摸得着”！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是容斥原理和并查集的结合应用，这类思路还能解决许多类似问题。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - **字符串重复子串统计**：如统计所有字符串中特定模式的出现次数。  
    - **图论中的等价类问题**：如计算无向图中连通块数的期望。  
    - **组合数学中的覆盖问题**：如计算集合覆盖的最小元素数。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1317** - `NOI2004 降雨量`  
        * 🗣️ **推荐理由**：需要处理区间覆盖和约束，锻炼并查集的灵活应用。  
    2.  **洛谷 P2158** - `[SDOI2008] 仪仗队`  
        * 🗣️ **推荐理由**：容斥原理的经典应用，适合巩固“奇加偶减”的符号规则。  
    3.  **洛谷 P3177** - `[HAOI2015] 树上染色`  
        * 🗣️ **推荐理由**：结合树形DP和容斥，提升复杂问题的拆解能力。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
Huasushis在题解中提到：“容斥的题看了一个下午才看懂，后来通过模拟小例子（如样例输入2 2）理解了符号规则。”  
</insights_intro>

> **参考经验**：“直接看公式容易懵，动手模拟小例子（如n=2，m=2）能快速理解容斥的符号规则和并查集的合并过程。”  
> **点评**：这位作者的经验非常实用！对于复杂算法，手动模拟小输入（如样例）是理解核心逻辑的“捷径”。例如，本题中n=2时，枚举所有可能的子串出现位置（长度1和2），手动计算贡献，能快速掌握容斥的调整过程。

---

<conclusion>
通过分析“Mivik 写书”这道题，我们掌握了容斥原理和并查集的结合应用。记住，遇到重复贡献问题时，容斥是调整的利器；处理字符约束时，并查集能高效维护等价类。多动手模拟小例子，多练习类似题目，你的算法能力会越来越强！下次见~ 💪
</conclusion>

---
处理用时：172.72秒
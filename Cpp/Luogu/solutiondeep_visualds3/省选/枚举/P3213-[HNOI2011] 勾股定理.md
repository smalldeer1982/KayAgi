# 题目信息

# [HNOI2011] 勾股定理

## 题目描述

沫沫最近在研究勾股定理。对于两个正整数 A 与 B，若存在正整数 C 使得 A2+B2=C2，且 A 与 B 互质，则称(A,B)为一个互质勾股数对。


有一天，沫沫得到了 N 根木棍，其长度都是正整数，她准备从中挑选出若干根木棍来玩拼图游戏，为了使拼出的图案有凌乱美，她希望挑选出的木棍中任意两根的长度均不是互质勾股数对。现在，沫沫想知道有多少种满足要求的挑选木棍的方案。由于答案可能很大，你只要输出答案对 $10^9+7$ 取模的结果。


## 说明/提示

样例解释：（5,12）与（12,35）是互质勾股数对，故满足要求的挑选木棍的方案有8种，即：


{5}，{12}，{35}，{5}，{5,35}，{35,5}，{5,5}，{5,35,5}。


## 样例 #1

### 输入

```
4				
5 12 35 5	
```

### 输出

```
8```

# AI分析结果



---
# 💡 Kay的C++算法解析：[HNOI2011] 勾股定理 深入学习指南 💡

<introduction>
今天我们来一起分析“[HNOI2011] 勾股定理”这道C++编程题。这道题需要我们计算满足条件的选木棍方案数，关键在于将问题转化为图的独立集计数问题。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（仙人掌图的独立集计数）`

🗣️ **初步分析**：
解决这道题的关键在于理解“互质勾股数对”的性质，并将其转化为图论问题。我们可以把每根木棍的长度视为图中的一个节点，若两个长度是互质勾股数对，则在它们之间连一条边。问题就转化为：在这个图中，求所有独立集（即任意两个节点不相邻）的数量（减去空集）。

简单来说，图论中的“独立集计数”是指找出所有节点的子集，使得子集中任意两个节点之间没有边相连。在一般图中，这是NP难问题，但本题的图结构特殊——通过观察发现，它是一个“沙漠图”（仙人掌森林），即每个连通分量最多比树多几条边（如环），因此可以用树形DP结合环的状态枚举来解决。

- **题解思路**：所有题解的核心思路一致：预处理互质勾股数对建图→识别图中的环→枚举环上节点的选/不选状态→对每个合法状态进行树形DP计算独立集数目→各连通分量结果相乘得到最终答案。
- **核心难点**：如何处理图中的环？由于环的存在，普通树形DP无法直接应用，需枚举环上节点的状态（选或不选），并验证状态合法性（环上相邻节点不能同时选）。
- **可视化设计**：计划用8位像素风展示图的构建过程（节点用方块表示，边用虚线连接），DFS找环时用闪烁标记环上节点，状态枚举时用不同颜色区分选/不选，DP计算时用数字动态更新方案数。关键步骤（如环检测、状态验证）伴随“叮”的像素音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、算法有效性等方面筛选出以下优质题解：
</eval_intro>

**题解一：作者bzy369258147（赞：13）**
* **点评**：此题解对图的结构分析深入（指出是沙漠图），代码逻辑清晰。预处理勾股数对的循环条件优化合理（避免超范围），DFS找环和状态枚举的实现简洁高效。特别是`query`函数中通过位运算枚举环上节点状态，结合`check`函数验证合法性，体现了对问题本质的深刻理解。代码变量名（如`PW2`表示2的幂次，`QE`存储环上节点）含义明确，适合竞赛参考。

**题解二：作者斯德哥尔摩（赞：5）**
* **点评**：此题解对勾股数对的生成原理（利用$m^2-n^2$和$2mn$）解释详细，代码注释丰富（如`build`函数说明预处理逻辑）。树形DP的状态转移方程（`dp[i][0]`和`dp[i][1]`）推导清晰，特别是对“选当前节点时子节点必须不选”的逻辑处理到位。状态枚举部分通过递归实现，可读性强，适合初学者理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题的过程中，我们需要重点突破以下三个关键点：
</difficulty_intro>

1.  **关键点1：互质勾股数对的预处理**  
    * **分析**：如何高效生成所有互质勾股数对？根据勾股数的生成公式，互质勾股数对可表示为$(m^2-n^2, 2mn)$（其中$m>n$，$m$和$n$互质且一奇一偶）。枚举$m$和$n$时需确保$m^2-n^2$和$2mn$不超过最大木棍长度（如$10^6$），并检查互质性。  
    * 💡 **学习笔记**：利用数学公式缩小枚举范围，避免无效计算。

2.  **关键点2：图中“环”的识别与处理**  
    * **分析**：普通树形DP无法处理环，需先通过DFS找到环上的节点（如记录时间戳`dfn`，遇到回边时标记环上节点）。枚举环上节点的选/不选状态（共$2^k$种，$k$为环上节点数），并验证相邻节点是否同时选（非法则跳过）。  
    * 💡 **学习笔记**：环的处理是本题核心，枚举状态后需结合树形DP计算合法方案。

3.  **关键点3：树形DP的状态转移**  
    * **分析**：设`dp[u][0]`为不选节点$u$时的方案数，`dp[u][1]`为选$u$时的方案数。状态转移为：  
      - 不选$u$时，子节点可选或不选：`dp[u][0] = product(dp[v][0] + dp[v][1])`  
      - 选$u$时，子节点必须不选：`dp[u][1] = (2^num[u]-1) * product(dp[v][0])`（$num[u]$是$u$的出现次数，$2^num[u]-1$表示至少选一根$u$的方案）。  
    * 💡 **学习笔记**：状态定义需覆盖所有可能，转移时注意子节点的约束。

### ✨ 解题技巧总结
- **问题抽象**：将实际问题转化为图论模型（独立集计数），简化问题复杂度。  
- **数学公式应用**：利用勾股数的生成公式高效预处理边，避免暴力枚举。  
- **环的枚举验证**：通过位运算或递归枚举环上节点状态，结合`check`函数过滤非法状态。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼出一个通用的核心实现，帮助大家把握整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了bzy369258147和斯德哥尔摩的题解思路，包含预处理、建图、找环、状态枚举和树形DP的完整逻辑。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int MOD = 1e9 + 7;
    const int MAXN = 1e6 + 5;

    int num[MAXN];          // 记录每个长度的出现次数
    vector<int> G[MAXN];    // 邻接表存图
    int PW2[MAXN];          // 2的幂次预处理
    bool vis[MAXN];         // 访问标记
    vector<int> cycle_nodes;// 存储环上节点
    int dp[MAXN][2];        // 树形DP数组

    // 预处理2的幂次
    void init_pw2() {
        PW2[0] = 1;
        for (int i = 1; i < MAXN; ++i)
            PW2[i] = 1LL * PW2[i-1] * 2 % MOD;
    }

    // 预处理互质勾股数对建图
    void build_graph() {
        for (int n = 1; n * n < MAXN; ++n) {
            for (int m = n + 1; 2 * m * n < MAXN; ++m) {
                if ((n & 1) == (m & 1)) continue; // 同奇偶不互质
                if (__gcd(n, m) != 1) continue;
                int a = m * m - n * n;
                int b = 2 * m * n;
                if (a >= MAXN || b >= MAXN) continue;
                if (num[a] && num[b]) { // 仅当两个长度都存在时连边
                    G[a].push_back(b);
                    G[b].push_back(a);
                }
            }
        }
    }

    // DFS找环（简化版，记录环上节点）
    void dfs_find_cycle(int u, int fa, vector<int>& path) {
        vis[u] = true;
        path.push_back(u);
        for (int v : G[u]) {
            if (v == fa) continue;
            if (!vis[v]) {
                dfs_find_cycle(v, u, path);
            } else {
                // 找到回边，记录环上节点（简化处理）
                auto it = find(path.begin(), path.end(), v);
                if (it != path.end()) {
                    cycle_nodes.assign(it, path.end());
                }
            }
        }
        path.pop_back();
    }

    // 树形DP
    void dfs_dp(int u, int fa, bool* chosen) {
        dp[u][0] = 1;
        dp[u][1] = (PW2[num[u]] - 1 + MOD) % MOD; // 至少选一根u
        if (chosen[u]) { // 若当前节点被强制选/不选
            dp[u][0] = 0;
        } else if (!chosen[u] && find(cycle_nodes.begin(), cycle_nodes.end(), u) != cycle_nodes.end()) {
            dp[u][1] = 0;
        }
        for (int v : G[u]) {
            if (v == fa || !num[v]) continue;
            dfs_dp(v, u, chosen);
            dp[u][0] = 1LL * dp[u][0] * (dp[v][0] + dp[v][1]) % MOD;
            dp[u][1] = 1LL * dp[u][1] * dp[v][0] % MOD;
        }
    }

    // 计算单个连通分量的方案数
    int solve_component(int start) {
        cycle_nodes.clear();
        vector<int> path;
        dfs_find_cycle(start, -1, path);
        int k = cycle_nodes.size();
        int total = 0;
        // 枚举环上节点的选/不选状态（2^k种）
        for (int mask = 0; mask < (1 << k); ++mask) {
            bool valid = true;
            bool chosen[MAXN] = {false};
            for (int i = 0; i < k; ++i) {
                chosen[cycle_nodes[i]] = (mask >> i) & 1;
                // 检查相邻节点是否同时选
                if (i > 0 && chosen[cycle_nodes[i]] && chosen[cycle_nodes[i-1]]) {
                    valid = false;
                    break;
                }
            }
            if (valid && chosen[cycle_nodes[0]] && chosen[cycle_nodes.back()]) {
                valid = false; // 环首尾相连，也需检查
            }
            if (!valid) continue;
            // 合法状态，进行树形DP
            dfs_dp(start, -1, chosen);
            total = (total + dp[start][0] + dp[start][1]) % MOD;
        }
        return total;
    }

    int main() {
        init_pw2();
        int n;
        cin >> n;
        for (int i = 0; i < n; ++i) {
            int x;
            cin >> x;
            num[x]++;
        }
        build_graph();
        int ans = 1;
        for (int i = 1; i < MAXN; ++i) {
            if (num[i] && !vis[i]) {
                ans = 1LL * ans * solve_component(i) % MOD;
            }
        }
        cout << (ans - 1 + MOD) % MOD << endl; // 减去空集
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先预处理2的幂次（`init_pw2`），然后根据勾股数生成公式建图（`build_graph`）。通过DFS找环（`dfs_find_cycle`），枚举环上节点的选/不选状态（`solve_component`），对每个合法状态进行树形DP（`dfs_dp`）计算方案数。最终各连通分量的结果相乘，减去空集得到答案。

---
<code_intro_selected>
接下来，我们剖析优质题解中的核心代码片段：
</code_intro_selected>

**题解一：作者bzy369258147**
* **亮点**：利用位运算枚举环上节点状态，`check`函数验证合法性，代码简洁高效。
* **核心代码片段**：
    ```cpp
    int query(int x) {
        QE.clear(); dfs_init(x, x);
        int ans = 0;
        int len = 1 << QE.size();
        for (int i = 0; i < len; ++i) {
            for (int j = 0; j < QE.size(); ++j) 
                sat[QE[j]] = (i & (1 << j)) ? 1 : -1;
            if (check()) pnt++, (ans += dfs_dp(x)) %= mod;
        }
        // 重置标记
        for (int i = 0; i < QE.size(); ++i) sat[QE[i]] = 0;
        return ans;
    }
    ```
* **代码解读**：  
  `QE`存储环上节点，`len = 1 << QE.size()`枚举所有可能的状态（每位表示一个节点是否选）。`sat`数组记录当前状态（1选，-1不选），`check`函数验证环上相邻节点是否同时选。合法状态下调用`dfs_dp`计算方案数，累加到`ans`。  
  这里的位运算枚举是关键技巧，时间复杂度为$O(2^k)$（$k$为环上节点数），由于题目中图的结构特殊（$k$很小），实际可接受。  
* 💡 **学习笔记**：位运算枚举状态是处理小规模环的高效方法，结合`check`函数过滤非法状态，确保结果正确。

**题解二：作者斯德哥尔摩**
* **亮点**：树形DP的状态转移方程清晰，注释说明关键步骤。
* **核心代码片段**：
    ```cpp
    void dfs2(int x, int f) { // 树形DP
        vis[x] = T;
        dp[x][0] = 1;
        dp[x][1] = (bit[num[x]] - 1 + MOD) % MOD; // 至少选一根x
        if (used[x]) { // 环上节点被强制选/不选
            if (choose[x]) dp[x][0] = 0;
            else dp[x][1] = 0;
        }
        for (int i = head[x]; i; i = a[i].next) {
            int v = a[i].to;
            if (v == f || !num[v] || vis[v] == T) continue;
            dfs2(v, x);
            dp[x][0] = dp[x][0] * (dp[v][0] + dp[v][1]) % MOD;
            dp[x][1] = dp[x][1] * dp[v][0] % MOD;
        }
    }
    ```
* **代码解读**：  
  `dp[x][0]`初始化为1（不选x时，子树的空集方案），`dp[x][1]`初始化为$2^{num[x]}-1$（选至少一根x的方案）。若`x`是环上节点（`used[x]`为真），则根据`choose[x]`强制设置`dp[x][0]`或`dp[x][1]`为0。遍历子节点时，`dp[x][0]`乘子节点选或不选的方案和，`dp[x][1]`乘子节点不选的方案。  
  这体现了树形DP的核心思想：父节点的状态由子节点的状态转移而来。  
* 💡 **学习笔记**：状态转移时需明确父节点与子节点的约束关系（选父则子不选，不选父则子可选可不选）。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“找环→枚举状态→树形DP”的过程，我们设计一个8位像素风格的动画演示方案。
</visualization_intro>

  * **动画演示主题**：`像素森林的独立集探险`（模拟在“勾股树”中寻找合法选法）

  * **核心演示内容**：  
    展示互质勾股数对的建图过程（节点用彩色方块表示，边用虚线连接），DFS找环时用闪烁标记环上节点，状态枚举时用不同颜色（红：选，蓝：不选）区分环上节点，树形DP时动态更新每个节点的方案数（数字显示）。

  * **设计思路简述**：  
    8位像素风格（如FC游戏画面）营造轻松氛围；节点闪烁、颜色变化强化关键步骤记忆；音效（选节点“叮”、找环“滴答”、成功“胜利音”）增强交互感；关卡制（每处理一个连通分量算一关）提升成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        屏幕分为左右两部分：左为“勾股图”（网格背景，节点方块标长度，边虚线连接），右为“控制面板”（单步/自动按钮、速度滑块、代码同步区）。播放8位风格BGM。

    2.  **建图过程**：  
        从左上角开始，按顺序生成互质勾股数对（如(3,4)→(5,12)等），每生成一对，对应节点方块滑动到图中位置，边虚线渐显，伴随“唰”的音效。

    3.  **DFS找环**：  
        用黄色箭头跟随DFS路径（节点方块边缘发光），遇到回边时（如从节点5到节点12），箭头变红色，环上节点（5,12,35）开始闪烁（频率由慢到快），并在旁白提示“发现环！”。

    4.  **状态枚举**：  
        环上节点进入“状态选择”模式，每个节点方块旁出现小按钮（红选/蓝不选）。点击“自动枚举”后，依次展示所有$2^3=8$种状态（如5选、12不选、35选），非法状态（如5和12同时选）的节点方块变红并播放“错误”音效，合法状态变绿并播放“正确”音效。

    5.  **树形DP计算**：  
        对合法状态，从根节点开始，用绿色数字动态显示`dp[u][0]`和`dp[u][1]`（如节点5的`dp[5][0]=1`，`dp[5][1]=3`）。子节点的数字更新时，父节点的数字随之相乘（如节点5的`dp[5][0]`变为`1*(2+1)=3`），伴随“嗒嗒”的计数音效。

    6.  **结果汇总**：  
        所有合法状态的方案数累加后，连通分量的总方案数显示在屏幕中央（如“本关得分：8”），并播放“胜利”音效。所有连通分量处理完成后，最终答案（减空集）用金色数字放大显示。

  * **旁白提示**：  
    - “看！这两个节点（5和12）连了一条边，说明它们是互质勾股数对，不能同时选哦～”  
    - “现在我们在找环，闪烁的节点组成了一个环，需要枚举它们的选法！”  
    - “这个状态（5选、12选）不合法，因为它们相邻，所以被排除啦～”  
    - “树形DP开始！父节点不选时，子节点可以自由选择，方案数要相乘哦～”

<visualization_conclusion>
通过这样的动画，我们能直观看到图的构建、环的识别、状态的枚举和DP的计算过程，轻松理解算法的每一步逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是图的独立集计数，其思路可迁移到其他特殊图（如树、仙人掌）的类似问题中。
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    树形DP和状态枚举的方法不仅适用于互质勾股数对问题，还可处理：  
    - 树结构中的最大独立集（如“没有上司的舞会”）。  
    - 仙人掌图中的环处理（如“仙人掌图的直径”）。  
    - 一般图中小规模环的枚举（如“旅行商问题的近似解法”）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1352 没有上司的舞会**  
        * 🗣️ **推荐理由**：经典树形DP题，练习独立集计数的基础状态转移。  
    2.  **洛谷 P5236 【模板】仙人掌**  
        * 🗣️ **推荐理由**：深入理解仙人掌图的性质，练习环的处理方法。  
    3.  **洛谷 P4587 [FJOI2016]神秘数**  
        * 🗣️ **推荐理由**：练习将实际问题转化为图论模型的抽象能力。  

-----

## 7\. 学习心得与经验分享 

<insights_intro>
题解中作者的经验对我们很有启发：
</insights_intro>

> **参考经验 (来自斯德哥尔摩)**：“一开始看错题目，以为是选两根木棍，后来发现是选若干根，才调整思路。”  
> **参考经验 (来自Soroak)**：“调了一天代码，最后一次提交才AC，运气还好～”

**点评**：  
斯德哥尔摩的经验提醒我们，审题是解题的第一步！一定要仔细阅读题目要求（如本题是“若干根”而非“两根”）。Soroak的调试经历说明，编写代码后需充分测试（如用样例输入验证），遇到错误时可通过打印中间变量、逐步调试定位问题。这些都是编程中非常重要的习惯。

-----

<conclusion>
本次关于“[HNOI2011] 勾股定理”的分析就到这里。通过理解图论模型的构建、环的处理和树形DP的应用，相信大家已掌握这类问题的核心解法。记住，多思考、多练习，编程能力会稳步提升！下次见～💪
</conclusion>

---
处理用时：192.82秒
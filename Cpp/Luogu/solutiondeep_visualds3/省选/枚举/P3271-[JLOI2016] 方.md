# 题目信息

# [JLOI2016] 方

## 题目描述

上帝说，不要圆，要方，于是便有了这道题。

由于我们应该方，而且最好能够尽量方，所以上帝派我们来找正方形上帝把我们派到了一个有 $N$ 行 $M$ 列的方格图上，图上一共有 $(N+1)\times(M+1)$ 个格点，我们需要做的就是找出这些格点形成了多少个正方形（换句话说，正方形的四个顶点都是格点）。

但是这个问题对于我们来说太难了，因为点数太多了，所以上帝删掉了这 $(N+1)\times(M+1)$ 中的 $K$ 个点。既然点变少了，问题也就变简单了，那么这个时候这些格点组成了多少个正方形呢？


## 样例 #1

### 输入

```
2 2 4
1 0
1 2
0 1
2 1```

### 输出

```
1```

# AI分析结果



---
# 💡 Kay的C++算法解析：[JLOI2016] 方 深入学习指南 💡

<introduction>
今天我们要挑战的题目是“[JLOI2016] 方”。这道题需要计算在网格图中，去掉K个坏点后剩余点能组成的正方形数量。通过分析，我们会发现容斥原理是解决这类计数问题的关键！让我们一起拆解问题，掌握核心思路吧~
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`容斥原理 + 几何分析`

🗣️ **初步分析**：
解决这道题的关键在于“容斥”——直接计算合法正方形（不含坏点）的数量很困难，但我们可以通过计算“至少包含i个坏点的正方形数量”（记为$f_i$），再利用容斥公式 $ans = f_0 - f_1 + f_2 - f_3 + f_4$ 得到答案。

简单来说，容斥原理就像“先算总蛋糕，再减去被坏点咬掉的部分，补上重复减掉的，依此类推”。在本题中：
- $f_0$：所有点都是好点时的正方形总数（总蛋糕）。
- $f_1$：至少包含1个坏点的正方形数（被1个坏点咬掉的部分）。
- $f_2$：至少包含2个坏点的正方形数（被2个坏点咬掉的部分，但可能重复计算）。
- 以此类推，通过加减抵消重复计算的部分。

### 核心难点与解决方案
- **计算$f_0$**：所有正方形包括直正方形（边与坐标轴平行）和斜正方形。通过观察，每个边长为$i$的直正方形内恰好包含$i$个正方形（包括自己），因此$f_0 = \sum_{i=1}^{\min(n,m)} i \cdot (n-i+1) \cdot (m-i+1)$。
- **计算$f_1$**：枚举每个坏点，统计所有以该点为顶点或边经过该点的正方形数。需要分四个方向（上下左右）计算，并调整边界超出的情况。
- **计算$f_2,f_3,f_4$**：枚举两个坏点，通过向量计算可能的另外两个顶点是否合法，并统计包含更多坏点的情况。由于重复计数，$f_3$和$f_4$需要分别除以3和6。

### 可视化设计思路
我们设计一个“像素网格探险”动画：
- **场景**：8位像素风格的网格，坏点用红色标记，好点用绿色。
- **核心演示**：动态展示$f_0$的直正方形生成（每个边长$i$的直正方形展开为$i$个小正方形）；枚举坏点时，用黄色箭头标记该点影响的正方形范围；枚举两个坏点时，用蓝色虚线画出可能的另外两个顶点，验证是否在网格内。
- **交互**：支持单步播放、调速，关键步骤（如边界超出、顶点合法）触发“叮”音效，完成容斥计算后播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对各题解的思路清晰性、代码规范性、算法有效性评估，以下题解因逻辑严谨、实现高效被选为优质参考：
</eval_intro>

**题解一：作者cmd2001（赞19）**
* **点评**：此题解对容斥的每个步骤（$f_0$到$f_4$）均给出了详细推导，代码结构清晰（如`calcini`计算$f_0$，`calcsingle`计算$f_1$），变量命名直观（如`delta`表示向量差）。特别亮点是通过`unordered_set`快速判断点是否为坏点，时间复杂度控制在$O(k^2)$，适合竞赛场景。

**题解二：作者_Sein（赞2）**
* **点评**：此题解对$f_1$的计算逻辑解释尤为透彻（如`calc`函数处理边界超出的情况），代码简洁且注释清晰。通过`node`结构体封装点的操作（如向量旋转），提升了代码复用性，是学习几何操作的好范例。

**题解三：作者liugh_（赞0）**
* **点评**：此题解优化了哈希表的使用（`unordered_set`存储坏点），并通过预处理排序减少重复计算。`mo`函数处理模运算，细节严谨，适合学习竞赛中的模运算技巧。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点在于如何高效计算各$f_i$，尤其是处理几何关系和容斥中的重复计数。以下是关键步骤的拆解：
</difficulty_intro>

### 关键点1：如何计算$f_0$（总正方形数）？
* **分析**：所有正方形可被其外接的最小直正方形唯一确定。边长为$i$的直正方形内部包含$i$个正方形（包括自己），因此总数量为$\sum_{i=1}^{\min(n,m)} i \cdot (n-i+1) \cdot (m-i+1)$。
* 💡 **学习笔记**：直正方形是“容器”，内部的斜正方形数量等于边长$i$，这是几何观察的关键。

### 关键点2：如何计算$f_1$（至少1个坏点的正方形数）？
* **分析**：枚举每个坏点，统计其作为顶点或边经过的正方形数。以坏点$(x,y)$为例，计算其到上下左右边界的距离$u,d,l,r$，通过公式$t = \min(l+r,h)$（$h$为垂直方向的最大边长），调整超出边界的情况（如$t>l$时减去多余部分）。
* 💡 **学习笔记**：分方向计算后需去重（坏点作为直正方形顶点的情况被重复统计）。

### 关键点3：如何处理$f_2,f_3,f_4$的重复计数？
* **分析**：枚举两个坏点时，每个包含$k$个坏点的正方形会被枚举$C(k,2)$次。因此，$f_3$需除以3（$C(3,2)=3$），$f_4$需除以6（$C(4,2)=6$）。
* 💡 **学习笔记**：容斥的核心是“多退少补”，重复计数需通过组合数调整。

### ✨ 解题技巧总结
- **几何观察**：利用直正方形与内接正方形的关系，简化$f_0$的计算。
- **哈希加速**：用`unordered_set`存储坏点，快速判断顶点是否合法（时间复杂度$O(1)$）。
- **向量运算**：通过向量旋转（如`swp`函数）计算正方形的另外两个顶点，避免复杂坐标推导。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的核心实现，代码逻辑清晰，涵盖容斥各步骤的关键计算。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合cmd2001和_Sein的题解，优化了哈希存储和边界处理，适合直接理解容斥全流程。
* **完整核心代码**：
```cpp
#include <cstdio>
#include <algorithm>
#include <tr1/unordered_set>
typedef long long lli;
using namespace std;
using namespace tr1;

const int mod = 1e8 + 7;

struct Point {
    int x, y;
    Point operator-(const Point& b) const { return {x - b.x, y - b.y}; }
    Point operator+(const Point& b) const { return {x + b.x, y + b.y}; }
    Point swp() const { return {y, -x}; } // 向量旋转90度
    bool even() const { return !(x & 1) && !(y & 1); } // 坐标是否为偶数（判断是否在格点）
};

unordered_set<lli> bad; // 存储坏点的哈希值
int n, m, k;

// 计算f0：总正方形数
lli calc_f0() {
    lli res = 0;
    int lim = min(n, m);
    for (int i = 1; i <= lim; ++i)
        res = (res + 1LL * i * (n - i + 1) % mod * (m - i + 1)) % mod;
    return res;
}

// 计算f1：单个坏点的贡献
lli calc_f1(Point p) {
    int u = p.x, d = n - u, l = p.y, r = m - p.y;
    auto edge = [](int l, int r, int h) {
        int t = min(l + r, h);
        if (!t) return 0LL;
        lli res = 1LL * t * (t + 3) / 2 % mod;
        if (t > l) res = (res - 1LL * (t - l) * (t - l + 1) / 2 % mod + mod) % mod;
        if (t > r) res = (res - 1LL * (t - r) * (t - r + 1) / 2 % mod + mod) % mod;
        return res;
    };
    lli sum = (edge(l, r, u) + edge(l, r, d) + edge(u, d, l) + edge(u, d, r)) % mod;
    sum = (sum - (min(u, l) + min(u, r) + min(d, r) + min(d, l)) % mod + mod) % mod;
    return sum;
}

// 计算f2,f3,f4的辅助函数
void calc_f234(Point a, Point b, lli& f2, lli& f3, lli& f4) {
    Point delta = (a - b).swp();
    // 情况1：a+delta, b+delta
    if (a.x + delta.x >= 0 && a.x + delta.x <= n && a.y + delta.y >= 0 && a.y + delta.y <= m &&
        b.x + delta.x >= 0 && b.x + delta.x <= n && b.y + delta.y >= 0 && b.y + delta.y <= m) {
        f2++;
        bool c = bad.count(1LL * (a.x + delta.x) * (m + 1) + (a.y + delta.y));
        bool d = bad.count(1LL * (b.x + delta.x) * (m + 1) + (b.y + delta.y));
        f3 += c + d;
        f4 += c && d;
    }
    // 情况2：a-delta, b-delta
    if (a.x - delta.x >= 0 && a.x - delta.x <= n && a.y - delta.y >= 0 && a.y - delta.y <= m &&
        b.x - delta.x >= 0 && b.x - delta.x <= n && b.y - delta.y >= 0 && b.y - delta.y <= m) {
        f2++;
        bool c = bad.count(1LL * (a.x - delta.x) * (m + 1) + (a.y - delta.y));
        bool d = bad.count(1LL * (b.x - delta.x) * (m + 1) + (b.y - delta.y));
        f3 += c + d;
        f4 += c && d;
    }
    // 情况3：中点旋转（对角线情况）
    Point mid = a + b;
    Point c = mid + delta, d = mid - delta;
    if (c.even() && d.even()) {
        c = c / 2; d = d / 2;
        if (c.x >= 0 && c.x <= n && c.y >= 0 && c.y <= m &&
            d.x >= 0 && d.x <= n && d.y >= 0 && d.y <= m) {
            f2++;
            bool cc = bad.count(1LL * c.x * (m + 1) + c.y);
            bool dd = bad.count(1LL * d.x * (m + 1) + d.y);
            f3 += cc + dd;
            f4 += cc && dd;
        }
    }
}

int main() {
    scanf("%d%d%d", &n, &m, &k);
    Point pt[2005];
    for (int i = 0; i < k; ++i) {
        scanf("%d%d", &pt[i].x, &pt[i].y);
        bad.insert(1LL * pt[i].x * (m + 1) + pt[i].y);
    }

    lli f0 = calc_f0();
    lli f1 = 0;
    for (int i = 0; i < k; ++i) f1 = (f1 + calc_f1(pt[i])) % mod;

    lli f2 = 0, f3 = 0, f4 = 0;
    for (int i = 0; i < k; ++i)
        for (int j = i + 1; j < k; ++j)
            calc_f234(pt[i], pt[j], f2, f3, f4);

    f3 = f3 / 3 % mod; // 除以C(3,2)=3
    f4 = f4 / 6 % mod; // 除以C(4,2)=6
    lli ans = (f0 - f1 + f2 - f3 + f4) % mod;
    if (ans < 0) ans += mod;
    printf("%lld\n", ans);
    return 0;
}
```
* **代码解读概要**：
  - `calc_f0`：通过遍历直正方形的边长，累加每个直正方形对应的内接正方形数。
  - `calc_f1`：分四个方向计算坏点影响的正方形数，调整边界超出的情况。
  - `calc_f234`：枚举两个坏点，通过向量旋转计算可能的另外两个顶点，统计$f_2,f_3,f_4$。
  - 主函数整合各$f_i$，应用容斥公式得到最终答案。

---

<code_intro_selected>
接下来，我们赏析优质题解中的核心代码片段：
</code_intro_selected>

**题解一（cmd2001）核心片段**：
```cpp
// 计算单个坏点的贡献（f1）
inline lli calcsingle(lli x,lli y) {
    const lli a = n - x , b = m - y , c = x , d = y;
    lli ret = ( calcedge(d,b,a) + calcedge(d,b,c) + calcedge(a,c,b) + calcedge(a,c,d) ) % mod;
    ret -= ( min(a,b) + min(b,c) + min(c,d) + min(d,a) ) % mod;
    return ( ret % mod + mod ) % mod;
}
```
* **亮点**：通过`calcedge`函数统一处理边界调整，代码复用性高。
* **代码解读**：`a,b,c,d`分别表示坏点到上下左右边界的距离，`calcedge`计算该方向的正方形数，最后减去重复统计的直正方形顶点情况。
* 💡 **学习笔记**：分方向计算后去重是避免重复计数的关键。

**题解二（_Sein）核心片段**：
```cpp
// 向量旋转计算另外两个顶点
node sap(){return node(y,-x);}
// 判断点是否在网格内
inline bool pdnode(node a){return 0<=a.x&&a.x<=n&&0<=a.y&&a.y<=m;}
```
* **亮点**：通过`node`结构体封装点的操作，代码更易读。
* **代码解读**：`sap`函数实现向量逆时针旋转90度，`pdnode`快速判断点是否合法。
* 💡 **学习笔记**：几何问题中，向量运算能简化坐标推导。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解容斥过程和正方形的生成，我们设计一个“像素网格探险”动画，用8位复古风格展示关键步骤！
</visualization_intro>

  * **动画演示主题**：`像素小探险家的正方形计数之旅`
  * **核心演示内容**：展示$f_0$的直正方形展开为$i$个内接正方形；枚举坏点时，用黄色区域标记其影响的正方形范围；枚举两个坏点时，用蓝色虚线画出可能的另外两个顶点，验证是否合法。

  * **设计思路简述**：
    - 8位像素风格（如FC游戏画面）降低学习压力，颜色标记（红坏点、绿好点、黄影响区）突出关键元素。
    - 音效（“叮”提示顶点合法，“咚”提示超出边界）强化操作记忆。
    - 单步播放和调速功能让学习者逐步观察容斥的“多退少补”过程。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：网格背景（20x20像素块），坏点用红色方块标记，好点用绿色。控制面板包含“开始/暂停”“单步”“调速”按钮。
    2. **计算$f_0$**：从边长$i=1$开始，每个直正方形（蓝色边框）展开为$i$个小正方形（淡蓝色），伴随“唰”的音效。
    3. **计算$f_1$**：选中一个坏点（红色闪烁），黄色箭头向四个方向扩展，标记其影响的正方形范围；超出边界的部分用灰色覆盖，提示“这些正方形不合法”。
    4. **计算$f_2$**：枚举两个坏点（红1、红2），蓝色虚线画出可能的另外两个顶点（蓝1、蓝2），若蓝1/蓝2在网格内（绿色）则计数，否则忽略。
    5. **容斥结果**：最终合法正方形数用金色数字显示，播放胜利音效（“啦~”）。

  * **旁白提示**：
    - “看！边长为$i$的直正方形能展开成$i$个小正方形哦~”
    - “坏点的影响范围像四个方向的‘射线’，超出网格的部分要减掉~”
    - “枚举两个坏点时，另外两个顶点必须在网格内才算有效！”

<visualization_conclusion>
通过这样的动画，我们不仅能“看到”容斥的每一步，还能直观理解几何分析的关键——直正方形与内接正方形的关系，以及坏点对计数的影响。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题的容斥和几何分析后，可以尝试以下题目巩固：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 容斥原理适用于“总数量-非法数量”的计数问题（如统计矩形、三角形数量）。
    - 几何分析中，利用外接图形（如直正方形）简化内接图形的计数是常见技巧。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1378 油滴扩展** - 计算圆覆盖的格点数。
       * 🗣️ **推荐理由**：需分析圆与网格的几何关系，巩固几何计数能力。
    2.  **洛谷 P2739 树的统计** - 统计满足条件的路径数。
       * 🗣️ **推荐理由**：需用容斥处理路径重复计数，与本题思路类似。
    3.  **洛谷 P4455 [CQOI2018]社交网络** - 统计生成树数量。
       * 🗣️ **推荐理由**：需用矩阵树定理结合容斥，提升综合解题能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者的调试经验对我们很有启发：
</insights_intro>

> **参考经验 (来自cmd2001)**：“计算垂直向量时没加负号调了半天，老年选手身败名裂。”
>
> **点评**：向量运算的方向（正负号）是几何问题的常见坑点。建议在代码中添加注释（如“旋转方向：逆时针”），或通过画图验证向量关系，避免低级错误。

---

<conclusion>
通过这篇指南，我们掌握了“方”这道题的核心思路——容斥原理与几何分析。记住，遇到计数难题时，容斥是“总-坏+重复坏-…”的巧妙平衡；几何问题中，观察外接图形与内接图形的关系能大幅简化计算。接下来，快去挑战拓展练习，巩固这些技巧吧！💪
</conclusion>

---
处理用时：186.92秒
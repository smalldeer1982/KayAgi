# 题目信息

# [APIO2015] 雅加达的摩天楼

## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。


## 说明/提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$


## 样例 #1

### 输入

```
5 3
0 2
1 1
4 1```

### 输出

```
5```

# AI分析结果



---
# 💡 Kay的C++算法解析：[APIO2015] 雅加达的摩天楼 深入学习指南 💡

<introduction>
今天我们来分析这道“雅加达的摩天楼”问题。这道题需要计算消息从0号doge传递到1号doge的最少跳跃步数，核心在于如何高效建模状态并优化复杂度。通过分析优质题解，我们将掌握分块优化和分层图的技巧，理解如何将复杂问题转化为可处理的最短路模型。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（最短路问题）结合分块优化与分层图技巧

🗣️ **初步分析**：
解决这道题的关键在于将doge的跳跃行为转化为图中的最短路问题。每个doge的跳跃能力不同，直接暴力建图会导致边数爆炸（O(n²)），因此需要结合分块优化和分层图技巧。

简单来说，分块优化是将跳跃能力分为“小块”（≤√n）和“大块”（>√n）两类：
- **小块跳跃**（≤√n）：用分层图建模，每层代表一种跳跃能力，层内节点通过相邻跳跃连边（边权1），层与原图节点连边（边权0，表示切换doge）。
- **大块跳跃**（>√n）：直接暴力连边，因为每个doge最多跳√n次（否则超出楼数）。

核心难点在于如何平衡两种跳跃的建模复杂度，避免状态数和边数过大。优质题解普遍采用分块策略（块大小取√(n/3)），将总边数优化到O(n√n)，从而用Dijkstra或BFS高效求解。

可视化设计上，我们可以用像素风格展示分层图的结构：每一层用不同颜色的像素条表示，小块跳跃的doge在层内“滑动”（像素块移动，音效“滴答”），大块跳跃的doge直接“跳跃”到目标楼（像素闪烁，音效“噗”）。控制面板支持单步/自动播放，同步显示当前状态（楼号、跳跃能力、已用步数）。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解值得重点学习：
</eval_intro>

**题解一：浮尘ii（赞58）**  
* **点评**：此题解直接使用BFS，状态定义为`(当前楼号, 当前跳跃能力)`，利用`bitset`判重。思路简洁直观，通过分块思想限制状态数（小块≤√n时状态数n√n，大块>√n时状态数m√n），时间复杂度O((n+m)√n)。代码中`insert`函数巧妙处理同楼doge的消息传递，边界条件处理严谨（如初始楼号直接加入队列）。实践价值高，适合竞赛快速实现。

**题解二：StudyingFather（赞25）**  
* **点评**：此题解采用分层图建模，对小块跳跃（≤√(n/3)）建分层图（每层n个节点，相邻节点连边权1），大块跳跃暴力连边。代码结构清晰，通过`id[i][j]`表示第i层第j楼的节点，分层图与原图的边权0设计（切换doge）非常巧妙。算法复杂度分析严谨，边数优化到O(n√n)，适合理解分层图的核心思想。

**题解三：TopCarry（赞13）**  
* **点评**：此题解深入分析分块大小的选择（k=√(n/3)时边数最小），理论推导严谨。代码中`build`函数预处理分层图的边，`spfa`实现最短路，对大块跳跃直接连边。亮点在于分块大小的数学推导，帮助学习者理解“对勾函数”在优化中的应用，适合进阶学习。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理跳跃能力的差异，避免状态数爆炸。以下是三个核心难点及解决策略：
</difficulty_intro>

1.  **难点1：如何定义状态以避免重复计算？**  
    * **分析**：直接以“当前楼号+当前跳跃能力”为状态（如`(i,j)`表示在楼i，使用跳跃能力j的doge），可覆盖所有可能的跳跃和消息传递。通过`bitset`或哈希表判重，避免重复访问同一状态。  
    * 💡 **学习笔记**：状态定义需覆盖所有可能的转移路径，同时通过判重减少无效计算。

2.  **难点2：如何平衡不同跳跃能力的建模复杂度？**  
    * **分析**：小块跳跃（≤√n）用分层图建模（每层内连边权1，层与原图连边权0），大块跳跃（>√n）直接连边（最多√n条）。分块后总边数优化为O(n√n)，避免O(n²)的爆炸。  
    * 💡 **学习笔记**：分块优化的关键是找到块大小k，使两部分复杂度之和最小（如k=√(n/3)）。

3.  **难点3：如何高效处理消息传递（同楼doge的切换）？**  
    * **分析**：当到达某楼时，将该楼所有doge的跳跃能力加入队列（边权不变），表示切换doge。代码中通过`insert`函数或分层图的0边权实现。  
    * 💡 **学习笔记**：消息传递等价于状态中跳跃能力的切换，需在状态转移时同步处理。

### ✨ 解题技巧总结
- **分块优化**：将问题按关键参数（如跳跃能力）分块，对不同块采用不同策略，平衡时间与空间。  
- **分层图建模**：对频繁重复的跳跃模式（如小块跳跃），用分层图抽象为层内转移，减少边数。  
- **状态判重**：使用`bitset`或哈希表高效判重，避免状态重复访问。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合分层图和分块优化的通用核心实现，结合了StudyingFather和TopCarry的思路：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合分层图建模与分块优化，块大小取√(n/3)，对小块跳跃建分层图，大块跳跃暴力连边，使用Dijkstra求最短路。  
* **完整核心代码**：
```cpp
#include <cmath>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;

typedef pair<int, int> pii;
const int INF = 0x3f3f3f3f;

struct edge {
    int v, w, next;
} e[18000005];
int head[3100005], id[105][30005], dis[3100005], cnt;
bool vis[3100005];
int n, m;

void addedge(int u, int v, int w) {
    e[++cnt].v = v;
    e[cnt].w = w;
    e[cnt].next = head[u];
    head[u] = cnt;
}

int dijkstra(int s, int t) {
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    memset(dis, INF, sizeof(dis));
    dis[s] = 0;
    pq.push({0, s});
    while (!pq.empty()) {
        int u = pq.top().second;
        pq.pop();
        if (vis[u]) continue;
        vis[u] = true;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v;
            if (dis[v] > dis[u] + e[i].w) {
                dis[v] = dis[u] + e[i].w;
                pq.push({dis[v], v});
            }
        }
    }
    return dis[t] != INF ? dis[t] : -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin >> n >> m;
    int maxp = sqrt(n / 3); // 分块大小取√(n/3)
    for (int i = 1; i <= maxp; ++i)
        for (int j = 0; j < n; ++j) id[i][j] = i * n + j;
    // 构建分层图：每层内连边（左右跳，边权1），层与原图连边（边权0）
    for (int i = 1; i <= maxp; ++i) {
        for (int j = 0; j < n; ++j) {
            addedge(id[i][j], j, 0);
            if (j + i < n) addedge(id[i][j], id[i][j + i], 1);
            if (j - i >= 0) addedge(id[i][j], id[i][j - i], 1);
        }
    }
    int s, t;
    for (int i = 0; i < m; ++i) {
        int b, p;
        cin >> b >> p;
        if (i == 0) s = b;
        if (i == 1) t = b;
        if (p <= maxp) { // 小块跳跃：连边到分层图对应层
            addedge(b, id[p][b], 0);
        } else { // 大块跳跃：暴力连边
            for (int j = 1; b + j * p < n; ++j) addedge(b, b + j * p, j);
            for (int j = 1; b - j * p >= 0; ++j) addedge(b, b - j * p, j);
        }
    }
    cout << dijkstra(s, t) << endl;
    return 0;
}
```
* **代码解读概要**：  
  代码首先计算分块大小`maxp`（√(n/3)），然后为每个小块跳跃能力p（≤maxp）构建分层图（`id[p][j]`表示第p层第j楼的节点）。分层图内节点通过左右跳跃连边（边权1），并与原图节点连边（边权0）。大块跳跃直接连边到可达楼（边权为跳跃次数）。最后用Dijkstra求最短路，输出结果。

---

<code_intro_selected>
以下是对优质题解核心片段的赏析：
</code_intro_selected>

**题解一：浮尘ii（BFS实现）**  
* **亮点**：状态定义简洁，`bitset`判重高效，适合BFS处理无权最短路。  
* **核心代码片段**：
```cpp
void insert(int i, int p, int step) {
    if (!Vis[i]) { // 首次访问楼i，加入所有该楼的doge
        Vis[i] = true;
        for (auto x : Doge[i])
            if (!vis[i].test(x))
                vis[i].set(x), Q.emplace(i, x, step);
    }
    if (!vis[i].test(p)) // 加入当前doge的跳跃状态
        vis[i].set(p), Q.emplace(i, p, step);
}
```
* **代码解读**：  
  `insert`函数处理两种情况：首次访问楼i时，将该楼所有doge的跳跃能力加入队列（消息传递）；当前doge的跳跃状态未访问时，加入队列（继续跳跃）。`bitset vis[i]`记录楼i中各跳跃能力的访问状态，避免重复。  
* 💡 **学习笔记**：消息传递等价于将同楼所有doge的状态加入队列，这是BFS中处理状态转移的关键。

**题解二：StudyingFather（分层图实现）**  
* **亮点**：分层图建模清晰，分块大小推导严谨，适合理解分层图的结构。  
* **核心代码片段**：
```cpp
// 构建分层图：每层内连边（左右跳，边权1），层与原图连边（边权0）
for (int i = 1; i <= maxp; ++i) {
    for (int j = 0; j < n; ++j) {
        addedge(id[i][j], j, 0);
        if (j + i < n) addedge(id[i][j], id[i][j + i], 1);
        if (j - i >= 0) addedge(id[i][j], id[i][j - i], 1);
    }
}
```
* **代码解读**：  
  `id[i][j]`表示第i层（跳跃能力i）的第j楼节点。层内节点通过左右跳跃连边（边权1），表示用该跳跃能力跳一步；层与原图节点连边（边权0），表示切换到原图（使用其他doge）。  
* 💡 **学习笔记**：分层图将重复的跳跃模式抽象为层内转移，减少了边数，是处理频繁重复操作的常用技巧。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解分层图和分块优化的过程，我们设计一个“像素探险队”动画，用8位像素风格展示doge的跳跃和消息传递！
\</visualization_intro\>

  * **动画演示主题**：`像素探险队的摩天楼挑战`  
  * **核心演示内容**：展示doge从起点楼出发，通过分层图（小块跳跃）或直接跳跃（大块跳跃）传递消息，最终到达目标楼的过程。  

  * **设计思路简述**：  
    采用FC红白机风格（8色调色板，像素方块），用不同颜色区分原图（蓝色）和分层图（红/绿/黄层）。小块跳跃的doge在对应层内“滑动”（像素块逐格移动，音效“滴答”），大块跳跃的doge直接“跳跃”到目标楼（像素闪烁，音效“噗”）。控制面板支持单步/自动播放，同步显示当前状态（楼号、跳跃能力、已用步数）。

  * **动画帧步骤与交互关键点**：  
    1. **初始化场景**：  
       - 屏幕左侧显示n栋像素楼（蓝色方块，编号0~n-1）。  
       - 右侧显示分层图（红层p=1，绿层p=2，黄层p=3...），每层n个像素块。  
       - 控制面板：开始/暂停、单步、重置按钮，速度滑块（1x~5x）。  

    2. **初始状态**：  
       - 0号doge（金色像素）在起点楼S，显示其跳跃能力P0。  
       - 队列显示初始状态（S, P0, 0步）。  

    3. **状态转移演示**：  
       - **消息传递**（同楼doge切换）：当到达楼i时，该楼所有doge（彩色像素）闪烁，队列加入新状态（i, Px, 当前步数），音效“叮”。  
       - **小块跳跃**（分层图）：选择跳跃能力p≤maxp的doge，在对应层内左右移动（像素块逐格滑动），每跳一步步数+1，音效“滴答”。  
       - **大块跳跃**（直接连边）：选择跳跃能力p>maxp的doge，像素块“咻”地跳到目标楼（中间模糊动画），步数+跳跃次数，音效“噗”。  

    4. **目标达成**：  
       - 当到达目标楼T时，金色像素闪烁，播放胜利音效（“啦~”），显示总步数。  

    5. **交互提示**：  
       - 单步播放时，显示当前状态（楼i，跳跃能力p，步数step）及对应代码行（如`insert(i, p, step)`）。  
       - 自动播放时，速度滑块控制动画节奏（慢放便于观察分层图转移）。  

\<visualization_conclusion\>
通过这个动画，我们能直观看到分层图如何减少边数，分块优化如何平衡复杂度，以及消息传递和跳跃的具体过程。
\</visualization_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
本题的分块优化和分层图思想可迁移到多种最短路问题中，以下是拓展练习推荐：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：  
    分块优化适用于参数差异大的场景（如跳跃能力、边权范围），分层图适用于重复操作的抽象（如多次跳跃、状态切换）。例如：  
    - 处理“不同速度移动”的最短路问题（分块速度，分层图建模）。  
    - 解决“多次使用道具”的路径问题（分层图表示道具状态）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P3371 单源最短路径（弱化版）**  
        * 🗣️ **推荐理由**：基础最短路问题，巩固Dijkstra/BFS的实现，为分层图学习打基础。  
    2.  **洛谷 P4082 [USACO17DEC]Barn Painting**  
        * 🗣️ **推荐理由**：涉及状态转移的分情况讨论，锻炼分块优化思维。  
    3.  **洛谷 P2045 方格取数加强版**  
        * 🗣️ **推荐理由**：分层图建模的典型应用，理解如何通过分层处理多路径问题。  

---

## 7\. 学习心得与经验分享 

\<insights_intro\>
部分题解提到调试中的经验，对我们很有启发：
\</insights_intro\>

> **参考经验 (来自浮尘ii)**：“状态判重时使用`std::set`会TLE，改用`bitset`或哈希表更高效。”  
> **点评**：这提示我们，在竞赛中需注意数据结构的选择。`bitset`在判重时空间和时间效率更高，适合状态数大但状态值连续的场景（如本题的楼号和跳跃能力）。  

---

\<conclusion\>
通过分析“雅加达的摩天楼”问题，我们掌握了分块优化和分层图的核心技巧。记住，遇到复杂最短路问题时，分块和分层是降低复杂度的“利器”。多练习类似题目，你会更熟练地应用这些方法！下次挑战见~💪
\</conclusion\>

---
处理用时：157.03秒
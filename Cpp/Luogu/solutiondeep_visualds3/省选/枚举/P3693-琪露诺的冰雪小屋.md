# 题目信息

# 琪露诺的冰雪小屋

## 题目背景

琪露诺有一片正方形的雪地，她想在上面盖一栋小冰屋。


## 题目描述

琪露诺偶然间得到了一片 $N\times N$ 大小的正方形的雪地，她想在上面盖一栋冰雪小屋。

但调皮的⑨才不会认真地收集冰块呢，她要在这片土地上使用冰雪弹幕来制造冰砖，然后一块一块地搭起一个房子。

琪露诺制造冰砖的方式是这样的：她会站在某个方格上，然后向上，下，左，右，左上，左下，右上，右下这八个方向之一发射强力的冰雪弹幕，弹幕能影响到该方向一条直线上一定的距离以内的所有方格。

地面的每个方格都有一个冷冻度，初始为 $0$。被冰雪弹幕影响一次，冷冻度 $+1$，冷冻度的上限为 $4$。

在发射弹幕的间隙中，琪露诺会来到所有冷冻度为 $4$ 的格子，把那里的雪堆到一起，制作一个冰砖（大小为 $1\times1\times1$ 方格），并且将冷冻度重新归零。

琪露诺会拿着这些冰砖来盖房子。这个房子的长度、宽度和坐落位置她在一开始就已经规划好了，但她并不愿意提早确定房子的高度。

琪露诺是这样计划的：这个房子外观上看起来是一个长方体。

她会先盖起这个房子的四面墙（厚度为 $1$ 个方格），并在贴近地面的位置（废话）留一个宽度和高度分别为 $1$ 和 $2$ 的空位不放冰砖，作为房门。（显然，门无法开在墙的拐角处，但可以紧贴拐角）。

在她喜欢的时候，她会结束四面墙的建造，并一次性在墙顶部盖上一个厚度为 $1$ 方格的屋顶，使房子成为一个空心有顶的长方体。

计划已经非常充分了，但琪露诺还是不放心，所以她想请你帮她写一个程序，来随时提醒着她别出什么差错。这个程序需要具备的功能将在下文详细介绍。

----------------------
雪地由 $N$ 行 $N$ 列，$N\times N$ 个方格组成。（下标从 $0$ 开始，也就是说，存在第 $0$ 行第 $0$ 列，但不存在第 $N$ 行第 $N$ 列）每个方格都有一个冷冻度,范围 $[0,4]$，初始为 $0$。注意，空间是三维的，而冷冻度只是地面的属性。

琪露诺想将房子的左上角放在第 $H_R$行，$H_C$ 列（外墙也是房子的一部分，因此左上角位置不应该是房子的内部,而是外墙,并且是墙的拐角）。

这个房子的长度（平行于每列）是 $H_X$，宽度（平行于每行）是 $H_Y$，包含墙。保证房子所占空间不会超出雪地的范围。

除了最后搭建屋顶，琪露诺只会在高度 $[0,H_M-1]$ 放置冰砖。

一开始，琪露诺一个冰砖也没有。
在以下的介绍中，我们用俯视图来作示意：
```plain
0000
0000
4x90
0x01
```
数字代表当前该格子的冷冻度。如果位置紧贴地面（高度为 $0$）的地方放上了冰砖，那么用字母 $x$ 表示。

如果紧贴地面的位置没有冰砖，但是位置正上方的高空存在冰砖，那么仍然用数字表示地面的冷冻度，但这个数字会增加 $5$。即如果在示意图中看到了一个数字 $t\ge5$，表示该位置地面是空的，但高处有冰砖，且地面的冷冻度为 $t-5$。

第一个操作：`ICE_BARRAGE R C D S`  
---------------
表示琪露诺站在第 $R$ 行 $C$ 列的位置，朝着方向 $D$ 发射了一个强度为 $S$ 的弹幕。  
$R,C,D,S\in\mathbf{Z},0\le D\le7,0\le R,C,S<N$。  
方向编号 $0$ 表示上 $(R-1,C)$，$1$ 表示左上 $(R-1,C-1)$，   
$2$ 表示左 $(R,C-1)$，$3$ 表示左下 $(R+1,C-1)$，  
$4$ 表示下 $(R+1,C)$，$5$ 表示右下 $(R+1,C+1)$，  
$6$ 表示右 $(R,C+1)$，$7$ 表示右上 $(R-1,C+1)$。  
强度为 $S$ 的弹幕，可以使“处在发射方向直线上，距离琪露诺不超过 $S$ 格的所有格子（包括她站的格子）”的冷冻度都 $+1$。有以下几种特殊情况：

1. 如果某个格子冷冻度为 $4$，那么该格子冷冻度不变。
2. 如果弹幕所经路途上，有一个位置的地面上（高度为 $0$）已经放了冰砖（就是弹幕撞上了琪露诺已经盖了一半的房子），那么弹幕将被阻挡，无法影响到冰砖所在的格子以及冰砖后面被挡住的格子。
3. 弹幕超出雪地的部分忽略不计。

对于这个操作，需要如下输出一行：`CIRNO FREEZED k BLOCK(S)`  
如果这个弹幕将某个方格的冷冻度成功增加了 $1$，那么认为这个弹幕冻住了该方格。

`k` 表示这个弹幕总共冻住了多少方格。

如图：发射弹幕前地图如下：
```plain
00000
00000
00000
000x0
00000
```
执行操作 `ICE_BARRAGE 1 1 5 4`，地图变为：
```plain
00000
01000
00100
000x0
00000
```
输出：`CIRNO FREEZED 2 BLOCK(S)`  
解释：琪露诺站在第一行第一列，面对右下角发射了一个强度为 $4$ 的弹幕，但弹幕被 `x` 所阻挡，只能影响到 `x` 之前的格子。

第二个操作：`MAKE_ICE_BLOCK`  
-------------------------
琪露诺走遍地图上所有冷冻度为 $4$ 的方格，每个方格可以收集一个冰砖，然后将它们的冷冻度归零。 

对于这个操作，你需要给出如下输出一行：`CIRNO MADE x ICE BLOCK(S),NOW SHE HAS y ICE BLOCK(S)`  
表示琪露诺制造了 $x$ 个冰砖，目前她有 $y$ 个冰砖。  
比如琪露诺一开始有 $0$ 个冰砖，并且状态如下：
```plain
0xxx
0x4x
0x9x
0400
```
执行操作 `MAKE_ICE_BLOCK` 后变为
```plain
0xxx
0x0x
0x5x
0000
```
输出：`CIRNO MADE 3 ICE BLOCK(S),NOW SHE HAS 3 ICE BLOCK(S)`  
在这个示例中，房子已经完成了一部分，`x` 表示墙，`9` 这个位置地面没有冰砖，但高处有（可以猜出是门）。房间内唯一一块空地、门的位置，以及房间外的一个位置的冷冻度都达到了 $4$，因此可以收集到 $3$ 块冰砖，收集后将三个位置冷冻度都归零。

第三个操作：`PUT_ICE_BLOCK R C H` 
-----------------
表示在第 $R$ 行，第 $C$ 列，高度为 $H$ 的地方放一个冰砖。$0\le R,C<N,0\le H<H_M$。

贴近地面的位置高度为 $0$。如果冰砖放置成功，那么琪露诺库存的冰砖数量将减 $1$。

如果放置的位置贴近地面，该位置冷冻度立即归 $0$。

有以下几种情况，序号越小优先级越高，并且只能满足一种情况。

如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\cdots\cdots$ 以此类推。

1. 琪露诺目前没有任何冰砖，无法放置。这种情况下你需要输出：`CIRNO HAS NO ICE_BLOCK`
2. 冰砖将放在半空中，无法依附其他任何冰砖，或者目标位置已有冰砖了。  
这种情况下你需要输出一行：`BAKA CIRNO,CAN'T PUT HERE`，并无视此次操作，不做任何工作。
3. 冰砖放在了规划建造房子的区域之外，即
$R<H_R$ 或 $R>H_R+H_x-1$  
或 $C<H_C$ 或 $C>H_C+H_Y-1$。请输出一行：`CIRNO MISSED THE PLACE`  
尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。  
4. 冰砖留在了房子的内部，本应留空的地方被占用了，即  
$H_R+1\le R\le H_R+H_X-2$ 且 $H_C+1\le C\le H_C+H_Y-2$  
在屋顶的高度固定下来前，我们将所有满足上式的情况都认为是放在了房屋内部。  
请输出一行：`CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE`  
尽管琪露诺放错了地方，但你并不能阻止她放置这个冰砖。
5. 冰砖放在了正确的位置（不必考虑是否堵住了留给门的地方）  
请输出一行：`CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS x ICE_BLOCK(S)`  
`x` 表示放过这块冰砖后琪露诺剩余的冰砖。

第四个操作：`REMOVE_ICE_BLOCK R C H` 
---------
表示取走第 $R$ 行，第 $C$ 列，高度为 $H$ 处的冰砖。  
有以下几种情况，序号越小优先级越高，并且只能满足一种情况。

如果满足 $1$ 的话就忽视后面的，不满足 $1$ 的前提下才可能满足 $2\cdots\cdots$ 以此类推。

1. 目标位置没有冰砖，输出一行：`BAKA CIRNO,THERE IS NO ICE_BLOCK`
2. 目标位置有冰砖，并且在这个冰砖被移走后，至少有一个冰砖形成了一个悬空的块。  
如下面的“侧视图”，`x` 表示冰砖，`0` 表示空位。
```plain
xxxx
x000
x000
x000
```
$\ \ $在移走左上角的冰砖后，第一行右边三个冰砖没有了依靠，形成了一个悬空的连通块，就属于这种情况。  
$\ \ $这个冰砖将成功移走，琪露诺的冰砖库存将会 $+1$。并且所有的悬空连通块都会掉下来摔碎并消失  
$\ \ $（既不会进入冰砖库存，也不会在地面上留有任何痕迹）。  
$\ \ $输出一行：`CIRNO REMOVED AN ICE_BLOCK,AND k BLOCK(S) ARE BROKEN`，`k` 表示摔碎的冰砖数量。  
3. 琪露诺挪走了冰砖，并且其他冰砖不受任何影响。    
$\ \ \ $琪露诺的冰砖库存 $+1$，输出一行：`CIRNO REMOVED AN ICE_BLOCK`
    
第五个操作：`MAKE_ROOF` 
--------
这个操作只会出现一次，并且只会作为最后一个操作。  
这个操作表明琪露诺已经完成了冰雪小屋的四墙，只剩屋顶了！  

一般情况下，琪露诺将放置最后的 $H_X\times H_Y$ 个冰砖，把它们放置在墙壁最高的高度 $+1$ 的那一层，  
形成一个屋顶。然后她移除所有多余的冰砖，接下来补好所有残缺的墙壁。

你需要按顺序来执行整个过程，一旦遇到某种用 $\bullet$ 标识的特殊情况，则执行完该情况后退出流程。

在特殊情况之间所描述的均为一般情况，只要之前没有因为满足某种特殊情况而退出流程，均认为满足了一般情况。

首先，琪露诺将会一次性放置最多 $H_X\times H_Y$ 个冰砖来建造屋顶。

为什么是最多呢？请注意一点：如果之前错误放置在房子内部的冰砖恰好充当了屋顶的一部分，那么就不用在这个位置再放冰砖了。并且，所有比屋顶高的冰砖在之后将视为错误放置在了房子外部。

注意，放屋顶的时候可能会触及到高度为 $H_M$ 的那个平面。

建造屋顶前后将会碰到两种特殊情况：
- 琪露诺剩余的冰砖不足以建造屋顶。输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCK(S) TO MAKE ROOF`
- 墙壁的最高高度小于 $2$ 个方格，或者内部有效空间小于两个方格。  
墙壁所在的一圈不算内部空间。计算内部有效空间时请忽视错误放置的冰砖，因为它们将来要被移除。  
输出一行：`SORRY CIRNO,HOUSE IS TOO SMALL`

（特殊情况结束）

此后，我们认为琪露诺已经造好了屋顶，接下来该移除所有多余冰砖了。在移除过程中，琪露诺会尽可能让更少的冰砖摔碎。如果墙壁上某个冰砖因为移走了多余的冰砖而将要摔碎，那么她会先拆掉墙壁上的那个冰砖，然后在填补墙壁残缺时重新补回来（显然，这种行为不会影响到墙壁有无残缺的定性，但可以少损失一个冰砖）。她不会故意拆掉一个处在墙壁上且不会摔碎的冰砖。  
输出两行：  
`K1 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED`  
`K2 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED`  
`K1`表示房子内部错误放置的冰砖数量，`K2`表示房子外部错误放置的冰砖数量。

将有可能遭遇一种特殊情况：
- 琪露诺移除了所有多余的冰砖，但在移除过程中，屋顶塌陷了。  
输出一行：`SORRY CIRNO,HOUSE IS BROKEN WHEN REMOVING BLOCKS`

（特殊情况结束）

此后，我们认为琪露诺已经移除了所有多余的冰砖，接下来该填补墙壁的残缺了。

墙壁有残缺的定义是：除了宽为 $1$，高为 $2$ 的门以外，
在房子内部看外面还能看到其他缺口。

如果某个空位将来要作为门的一部分，则不属于残缺。并且房子只能有一个门。

如果墙壁没有残缺，则不要填补，否则需要填补。你需要记下墙壁是否有残缺，之后会用到。

填补的策略是：使用尽可能少的冰砖，在正确的位置填补墙壁，使房屋的状态不满足墙壁有残缺的定义（即不能放置多余的冰砖，通过遮挡视线来达到目的）。在此定义下，**大多数**情况我们无需考虑四角的柱子是否完整，因为在房间里看不到。

将有可能遭遇一种特殊情况：
- 琪露诺剩余的冰砖不足以填补墙壁的残缺。  
输出一行：`SORRY CIRNO,NOT ENOUGH ICE_BLOCKS TO FIX THE WALL`

（特殊情况结束）

此后，我们认为房子被成功建成了，这时你需要输出几行内容来对房子进行评价。

首先输出这么一行来庆祝房子的建成：`GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE`  
1. 在贴近地面的位置找不到一个宽度为 $1$，高度为 $2$ 的位置留给门。  
	输出一行：`HOUSE HAS NO DOOR`，然后琪露诺会尽可能利用墙壁上的残缺来开一个门。  
    否则，输出一行：`DOOR IS OK`
2. 接下来输出一行表示填补之前墙壁的完整程度  
	2.1. 在之前的记录中，墙壁不完整而需要修补。输出：`WALL NEED TO BE FIXED`  
    2.2. 在之前的记录中，墙壁完整而无需修补。输出：`WALL IS OK`  
3. 接下来一行表示四角的完整程度。  
	如果四个角的柱子有不完整的地方，就输出：`CORNER NEED TO BE FIXED`  
    在这种情况下，如果琪露诺剩余的冰砖足够修复拐角的空缺，那么她直接会修复这个空缺。  
    如果不够的话，她会再多收集几个冰砖，数量恰好修复这个空缺，然后修复这个空缺。  
    否则，输出：`CORNER IS OK`
    
接下来，输出一行：`CIRNO FINALLY HAS k ICE_BLOCK(S)`  
`k` 表示琪露诺最后剩余的冰砖的数量。

最后，如果在之前的记录中，墙壁完整无缺，没有一个位置需要填补。房子内外都无任何多余的方块，没有一个位置需要移除。没有出现房子没门的情况，房子四角的柱子也在造屋顶前完全造好，而不是通过修补完善的。并且门恰好开在了某面墙的正中央（如果长度为偶数，中间的两个都算），输出一行：   
`CIRNO IS PERFECT!`

## 说明/提示

共分为 $6$ 个 **Subtask**，每个 **Subtask** 的数据都满足一定条件，并且同时满足序号更大的 **Subtask** 的条件。  
如 **Subtask #0** 同时满足 **Subtask #0~5** 的条件。  
每一个 **Subtask** 的得分取所有测试点的最低分。

**Subtask #0** $20\%$  
琪露诺只想玩玩冰雪弹幕，她不会放置任何冰砖，也不会盖房子(即只有操作一和操作二)。  


**Subtask #1** $10\%$  
琪露诺不会移除已经放置的冰砖。

**Subtask #2** $20\%$  
琪露诺很有信心，她将在没有 `MAKE_ROOF` 的情况下建造她的冰屋(这种情况下，放置方块的高度仍然会小于 $H_M$ 且没有 `MAKE_ROOF` 操作)。

**Subtask #3** $20\%$  
琪露诺在移除方块时会谨慎考虑,不会造成任何冰砖摔落。`MAKE_ROOF` 操作移除多余冰砖时，也不会造成屋顶塌陷。

**Subtask #4** $20\%$  
琪露诺不喜欢把门开到四角的柱子旁边(数据保证在所有可能作为门的墙壁空缺中，有一种可能使得门不紧贴四角的柱子)。 

**Subtask #5** $10\%$  
$4\le N\le 16$，$5\le H_M\le 20$，$10\le M\le 10^3$，保证不属于冰屋范围内的所有空地至多构成一个连通块。

注意：判断墙壁是否有残缺时，候选的开门位如果被方块堵住，在当时还未被清空。"能看到残缺"以当时的情况作为判断依据。

## 样例 #1

### 输入

```
8
10
4 0 4 4
63
ICE_BARRAGE 2 1 1 3
ICE_BARRAGE 0 1 3 1
MAKE_ICE_BLOCK
PUT_ICE_BLOCK 3 2 0
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 2 0 6 7
ICE_BARRAGE 3 0 6 7
ICE_BARRAGE 4 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
MAKE_ICE_BLOCK
PUT_ICE_BLOCK 4 0 1
PUT_ICE_BLOCK 4 0 0
PUT_ICE_BLOCK 4 0 1
PUT_ICE_BLOCK 3 0 1
REMOVE_ICE_BLOCK 4 0 1
PUT_ICE_BLOCK 4 2 0
PUT_ICE_BLOCK 6 1 0
PUT_ICE_BLOCK 4 3 0
PUT_ICE_BLOCK 5 3 0
PUT_ICE_BLOCK 6 3 0
PUT_ICE_BLOCK 7 3 0
ICE_BARRAGE 0 1 4 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
MAKE_ICE_BLOCK
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
MAKE_ICE_BLOCK
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
MAKE_ICE_BLOCK
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
ICE_BARRAGE 1 0 6 7
MAKE_ICE_BLOCK
REMOVE_ICE_BLOCK 6 1 0
PUT_ICE_BLOCK 5 0 0
PUT_ICE_BLOCK 6 0 0
PUT_ICE_BLOCK 7 0 0
PUT_ICE_BLOCK 7 1 0
PUT_ICE_BLOCK 7 2 0
PUT_ICE_BLOCK 4 0 1
PUT_ICE_BLOCK 5 0 1
PUT_ICE_BLOCK 6 0 1
PUT_ICE_BLOCK 7 0 1
PUT_ICE_BLOCK 7 1 1
PUT_ICE_BLOCK 7 2 1
PUT_ICE_BLOCK 7 3 1
PUT_ICE_BLOCK 6 3 1
PUT_ICE_BLOCK 5 3 1
PUT_ICE_BLOCK 4 3 1
PUT_ICE_BLOCK 4 2 1
MAKE_ROOF
```

### 输出

```
CIRNO FREEZED 2 BLOCK(S)
CIRNO FREEZED 2 BLOCK(S)
CIRNO MADE 0 ICE BLOCK(S),NOW SHE HAS 0 ICE BLOCK(S)
CIRNO HAS NO ICE_BLOCK
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 7 BLOCK(S)
CIRNO FREEZED 7 BLOCK(S)
CIRNO FREEZED 0 BLOCK(S)
CIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 8 ICE BLOCK(S)
BAKA CIRNO,CAN'T PUT HERE
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 7 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 6 ICE_BLOCK(S)
CIRNO MISSED THE PLACE
CIRNO REMOVED AN ICE_BLOCK,AND 1 BLOCK(S) ARE BROKEN
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 5 ICE_BLOCK(S)
CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 3 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 2 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 1 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 0 ICE_BLOCK(S)
CIRNO FREEZED 6 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 7 BLOCK(S)
CIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 8 ICE BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 16 ICE BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 24 ICE BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO FREEZED 8 BLOCK(S)
CIRNO MADE 8 ICE BLOCK(S),NOW SHE HAS 32 ICE BLOCK(S)
CIRNO REMOVED AN ICE_BLOCK
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 32 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 31 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 30 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 29 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 28 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 27 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 26 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 25 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 24 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 23 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 22 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 21 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 20 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 19 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 18 ICE_BLOCK(S)
CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS 17 ICE_BLOCK(S)
0 ICE_BLOCK(S) INSIDE THE HOUSE NEED TO BE REMOVED
0 ICE_BLOCK(S) OUTSIDE THE HOUSE NEED TO BE REMOVED
GOOD JOB CIRNO,SUCCESSFULLY BUILT THE HOUSE
DOOR IS OK
WALL IS OK
CORNER IS OK
CIRNO FINALLY HAS 1 ICE_BLOCK(S)
CIRNO IS PERFECT!
```

# AI分析结果



---
# 💡 Kay的C++算法解析：琪露诺的冰雪小屋 深入学习指南 💡

<introduction>
今天我们来一起分析“琪露诺的冰雪小屋”这道C++编程题。这道题是一个典型的模拟类问题，需要我们严格按照题目描述的规则模拟各种操作。通过这份指南，你将理解题目的核心逻辑，掌握关键操作的实现方法，并通过可视化动画直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟应用`  

🗣️ **初步分析**：  
解决这道题的关键在于严格按照题目描述的规则，模拟琪露诺的五个操作（发射弹幕、收集冰砖、放置冰砖、移除冰砖、建造屋顶）。模拟类问题的核心是“按规则执行”，就像玩一个复杂的游戏，每一步都要严格遵循游戏规则。  

在本题中，我们需要维护地面冷冻度、冰砖的三维位置等状态，并根据不同操作触发状态变化。例如，发射弹幕时需要沿着方向射线更新冷冻度，同时处理冰砖的阻挡；移除冰砖时需要判断悬空连通块并清理。  

核心难点包括：  
- 悬空连通块的判断（如何通过BFS确定冰砖是否与地面接触）；  
- 建造屋顶时的门位置选择和墙壁修补（需要评估多个候选位置，选择最优解）；  
- 多操作的状态管理（如冷冻度、冰砖位置的同步更新）。  

可视化设计思路：我们将用8位像素风格模拟雪地场景，地面用不同颜色表示冷冻度（0-4），冰砖用方块标记。发射弹幕时，用箭头动画展示射线方向；移除冰砖时，用闪烁动画提示悬空块并消失；建造屋顶时，用层叠动画展示屋顶的搭建过程。关键操作（如收集冰砖）伴随“叮”的音效，成功建造时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过分析各题解的思路清晰性、代码规范性和算法有效性，以下题解值得重点学习：
</eval_intro>

**题解一：灵乌路空（赞：37）**  
* **点评**：该题解详细拆解了每个操作的逻辑，尤其对悬空连通块的判断（BFS遍历）和门位置的选择（多条件排序）进行了深入分析。代码中使用了结构体和方向向量，逻辑清晰，关键注释到位。例如，在判断悬空块时，通过BFS检查是否与地面接触，确保逻辑正确性。实践价值高，适合学习复杂模拟问题的处理方法。  

**题解二：tiger2005（赞：28）**  
* **点评**：该题解采用工程化的代码结构，定义了三维向量（Vec3）和冰屋结构体（IceHouse），将操作封装为函数，代码规范性强。例如，通过`check`函数判断位置合法性，`g`函数获取状态，使代码易于维护。对建造屋顶的复杂逻辑（移除多余冰砖、修补墙壁）进行了模块化处理，适合学习代码的结构化设计。  

**题解三：hehezhou（赞：10）**  
* **点评**：该题解从工程角度分析，强调代码的健壮性和调试技巧（如通过状压输出三维状态）。对建造屋顶时的门位置选择（枚举候选位置，按优先级排序）提供了清晰的实现思路，代码中通过`getid`函数评估候选位置，逻辑直观。适合学习如何处理多条件决策问题。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，以下三个核心难点需要重点突破：
</difficulty_intro>

1.  **关键点1：悬空连通块的判断与处理**  
    * **分析**：移除冰砖后，需要判断相邻冰砖是否形成悬空块（不与地面接触）。可以通过BFS遍历连通块，若遍历过程中未接触地面，则判定为悬空块并移除。例如，灵乌路空的题解中，使用`DFS`遍历连通块，标记访问过的冰砖，若未到达地面则删除。  
    * 💡 **学习笔记**：悬空块判断的关键是“是否与地面连通”，BFS/DFS是有效的遍历方法，需注意避免重复访问。

2.  **关键点2：建造屋顶时的门位置选择**  
    * **分析**：门需要选择在墙壁上，且满足“宽度1、高度2”的条件。需枚举所有可能的候选位置，按“需要填补的冰砖数”“是否在墙中央”等优先级排序，选择最优解。例如，tiger2005的题解中，通过`getid`函数评估候选位置，综合考虑空缺大小、是否在中央等因素。  
    * 💡 **学习笔记**：多条件排序时，需明确各条件的优先级（如填补数优先于位置），确保选择最优解。

3.  **关键点3：多操作的状态同步**  
    * **分析**：发射弹幕、放置冰砖等操作会影响地面冷冻度或冰砖位置，需同步更新状态。例如，放置冰砖到地面时，需将冷冻度归零；移除冰砖时，若在地面需恢复冷冻度。需仔细处理每个操作的副作用，避免状态不一致。  
    * 💡 **学习笔记**：状态管理的关键是“操作-状态更新”的严格对应，建议为每个操作编写独立函数，明确输入输出。

### ✨ 解题技巧总结
- **模块化设计**：将每个操作封装为独立函数，如`ICE_BARRAGE`、`MAKE_ICE_BLOCK`，提高代码可读性。  
- **方向向量预处理**：定义二维、三维方向向量（如`_2D8`、`_3D6`），简化射线遍历、邻块检查等操作。  
- **BFS/DFS辅助**：悬空块判断、屋顶连通性检查等场景，使用BFS/DFS遍历，确保逻辑正确性。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，重点展示关键操作的逻辑：
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码综合了灵乌路空和tiger2005的题解思路，重点实现发射弹幕、放置冰砖和移除冰砖的核心逻辑。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

struct Vec3 {
    int x, y, z;
    Vec3(int x=0, int y=0, int z=0) : x(x), y(y), z(z) {}
    Vec3 operator+(const Vec3& q) const { return Vec3(x+q.x, y+q.y, z+q.z); }
};

const int _2D8[8][2] = {{-1,0}, {-1,-1}, {0,-1}, {1,-1}, {1,0}, {1,1}, {0,1}, {-1,1}}; // 8方向
const int _3D6[6][3] = {{1,0,0}, {-1,0,0}, {0,1,0}, {0,-1,0}, {0,0,1}, {0,0,-1}}; // 6方向

struct IceHouse {
    int freeze[17][17] = {0}; // 地面冷冻度（0-4，冰砖存在时为-1）
    bool ice[17][17][30] = {false}; // 三维冰砖位置
    int ice_cnt = 0; // 冰砖库存
    int N, HM, HR, HC, HX, HY;

    IceHouse(int n, int hm, int hr, int hc, int hx, int hy) 
        : N(n), HM(hm), HR(hr), HC(hc), HX(hx), HY(hy) {}

    // 发射弹幕
    int ice_barrage(int R, int C, int D, int S) {
        int cnt = 0;
        for (int i = 0; i <= S; ++i) {
            if (R < 0 || R >= N || C < 0 || C >= N) break;
            if (freeze[R][C] == -1) break; // 被冰砖阻挡
            if (freeze[R][C] < 4) {
                freeze[R][C]++;
                cnt++;
            }
            R += _2D8[D][0];
            C += _2D8[D][1];
        }
        return cnt;
    }

    // 收集冰砖
    int make_ice_block() {
        int cnt = 0;
        for (int i = 0; i < N; ++i)
            for (int j = 0; j < N; ++j)
                if (freeze[i][j] == 4) {
                    freeze[i][j] = 0;
                    cnt++;
                    ice_cnt++;
                }
        return cnt;
    }

    // 判断是否可放置冰砖（不悬空）
    bool can_put(Vec3 pos) {
        if (pos.z == 0) return true; // 地面可放
        for (int i = 0; i < 6; ++i) {
            Vec3 neighbor = pos + Vec3(_3D6[i][0], _3D6[i][1], _3D6[i][2]);
            if (neighbor.x >= 0 && neighbor.x < N && neighbor.y >= 0 && neighbor.y < N 
                && neighbor.z >= 0 && neighbor.z <= HM && ice[neighbor.x][neighbor.y][neighbor.z])
                return true;
        }
        return false;
    }

    // 放置冰砖
    void put_ice_block(int R, int C, int H) {
        Vec3 pos(R, C, H);
        if (ice_cnt == 0) {
            cout << "CIRNO HAS NO ICE_BLOCK\n";
            return;
        }
        if (ice[pos.x][pos.y][pos.z] || !can_put(pos)) {
            cout << "BAKA CIRNO,CAN'T PUT HERE\n";
            return;
        }
        ice[pos.x][pos.y][pos.z] = true;
        ice_cnt--;
        if (H == 0) freeze[R][C] = -1; // 地面冰砖，冷冻度归零
        // 判断位置类型并输出
        if (R < HR || R > HR + HX - 1 || C < HC || C > HC + HY - 1)
            cout << "CIRNO MISSED THE PLACE\n";
        else if (R > HR && R < HR + HX - 1 && C > HC && C < HC + HY - 1)
            cout << "CIRNO PUT AN ICE_BLOCK INSIDE THE HOUSE\n";
        else
            cout << "CIRNO SUCCESSFULLY PUT AN ICE_BLOCK,NOW SHE HAS " << ice_cnt << " ICE_BLOCK(S)\n";
    }

    // BFS判断是否悬空（与地面连通）
    bool is_floating(Vec3 start) {
        bool vis[17][17][30] = {false};
        vector<Vec3> stack = {start};
        vis[start.x][start.y][start.z] = true;
        bool touch_ground = false;
        while (!stack.empty()) {
            Vec3 pos = stack.back();
            stack.pop_back();
            if (pos.z == 0) {
                touch_ground = true;
                break;
            }
            for (int i = 0; i < 6; ++i) {
                Vec3 neighbor = pos + Vec3(_3D6[i][0], _3D6[i][1], _3D6[i][2]);
                if (neighbor.x >= 0 && neighbor.x < N && neighbor.y >= 0 && neighbor.y < N 
                    && neighbor.z >= 0 && neighbor.z <= HM && ice[neighbor.x][neighbor.y][neighbor.z] 
                    && !vis[neighbor.x][neighbor.y][neighbor.z]) {
                    vis[neighbor.x][neighbor.y][neighbor.z] = true;
                    stack.push_back(neighbor);
                }
            }
        }
        return !touch_ground;
    }

    // 移除冰砖
    void remove_ice_block(int R, int C, int H) {
        Vec3 pos(R, C, H);
        if (!ice[pos.x][pos.y][pos.z]) {
            cout << "BAKA CIRNO,THERE IS NO ICE_BLOCK\n";
            return;
        }
        ice[pos.x][pos.y][pos.z] = false;
        ice_cnt++;
        if (H == 0) freeze[R][C] = 0; // 恢复地面冷冻度
        // 检查相邻冰砖是否悬空
        int broken = 0;
        for (int i = 0; i < 6; ++i) {
            Vec3 neighbor = pos + Vec3(_3D6[i][0], _3D6[i][1], _3D6[i][2]);
            if (neighbor.x >= 0 && neighbor.x < N && neighbor.y >= 0 && neighbor.y < N 
                && neighbor.z >= 0 && neighbor.z <= HM && ice[neighbor.x][neighbor.y][neighbor.z]) {
                if (is_floating(neighbor)) {
                    // 移除悬空块（BFS遍历删除）
                    vector<Vec3> to_remove;
                    bool vis[17][17][30] = {false};
                    to_remove.push_back(neighbor);
                    vis[neighbor.x][neighbor.y][neighbor.z] = true;
                    while (!to_remove.empty()) {
                        Vec3 p = to_remove.back();
                        to_remove.pop_back();
                        ice[p.x][p.y][p.z] = false;
                        broken++;
                        for (int j = 0; j < 6; ++j) {
                            Vec3 p2 = p + Vec3(_3D6[j][0], _3D6[j][1], _3D6[j][2]);
                            if (p2.x >= 0 && p2.x < N && p2.y >= 0 && p2.y < N 
                                && p2.z >= 0 && p2.z <= HM && ice[p2.x][p2.y][p2.z] 
                                && !vis[p2.x][p2.y][p2.z]) {
                                vis[p2.x][p2.y][p2.z] = true;
                                to_remove.push_back(p2);
                            }
                        }
                    }
                }
            }
        }
        if (broken > 0)
            cout << "CIRNO REMOVED AN ICE_BLOCK,AND " << broken << " BLOCK(S) ARE BROKEN\n";
        else
            cout << "CIRNO REMOVED AN ICE_BLOCK\n";
    }
};

int main() {
    int N, HM, HR, HC, HX, HY, M;
    cin >> N >> HM >> HR >> HC >> HX >> HY >> M;
    IceHouse house(N, HM, HR, HC, HX, HY);
    while (M--) {
        string op;
        cin >> op;
        if (op == "ICE_BARRAGE") {
            int R, C, D, S;
            cin >> R >> C >> D >> S;
            int cnt = house.ice_barrage(R, C, D, S);
            cout << "CIRNO FREEZED " << cnt << " BLOCK(S)\n";
        } else if (op == "MAKE_ICE_BLOCK") {
            int cnt = house.make_ice_block();
            cout << "CIRNO MADE " << cnt << " ICE BLOCK(S),NOW SHE HAS " << house.ice_cnt << " ICE_BLOCK(S)\n";
        } else if (op == "PUT_ICE_BLOCK") {
            int R, C, H;
            cin >> R >> C >> H;
            house.put_ice_block(R, C, H);
        } else if (op == "REMOVE_ICE_BLOCK") {
            int R, C, H;
            cin >> R >> C >> H;
            house.remove_ice_block(R, C, H);
        }
    }
    return 0;
}
```
* **代码解读概要**：代码通过`IceHouse`结构体管理雪地状态，封装了五个核心操作。`ice_barrage`处理弹幕发射，`make_ice_block`收集冰砖，`put_ice_block`和`remove_ice_block`处理冰砖的放置与移除，其中移除操作通过BFS判断悬空块。代码结构清晰，关键逻辑（如悬空块判断）通过函数封装，易于理解。

---

<code_intro_selected>
以下是优质题解的核心片段分析：
</code_intro_selected>

**题解一：灵乌路空（悬空块判断）**  
* **亮点**：使用BFS遍历连通块，判断是否与地面接触，逻辑简洁。  
* **核心代码片段**：  
```cpp
bool dfs(int x, int y, int z) {
    if (x < 0 || y < 0 || z < 0 || x >= n || y >= n || z >= hm) return false;
    if (!ice[x][y][z]) return false;
    if (mark[x][y][z]) return false;
    mark[x][y][z] = 1;
    bool ret = (z == 0);
    for (int i = 0; i < 6 && (!ret); i++)
        ret |= dfs(x + dx[i], y + dy[i], z + dz[i]);
    return ret;
}
```  
* **代码解读**：`dfs`函数遍历当前冰砖的所有相邻块，若遍历过程中接触地面（`z==0`），则返回`true`（不悬空）。`mark`数组避免重复访问。此函数是判断悬空块的核心，确保逻辑正确性。  
* 💡 **学习笔记**：DFS/BFS遍历是判断连通性的常用方法，需注意标记已访问节点，避免无限循环。

**题解二：tiger2005（三维向量处理）**  
* **亮点**：定义`Vec3`结构体处理三维坐标，简化邻块计算。  
* **核心代码片段**：  
```cpp
struct Vec3 {
    int x, y, z;
    Vec3(int x=0, int y=0, int z=0) : x(x), y(y), z(z) {}
    Vec3 operator+(const Vec3& q) const { return Vec3(x+q.x, y+q.y, z+q.z); }
};
```  
* **代码解读**：`Vec3`结构体封装了三维坐标，并重载了加法运算符，方便计算邻块位置（如`pos + Vec3(1,0,0)`表示右侧邻块）。这种设计使代码更简洁，减少重复计算。  
* 💡 **学习笔记**：合理使用结构体封装数据，可提高代码的可读性和可维护性。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了更直观理解冰砖操作和悬空块判断，我们设计了一个8位像素风格的动画，模拟雪地场景和操作过程。
\</visualization\_intro\>

  * **动画演示主题**：`琪露诺的冰雪工坊`  
  * **核心演示内容**：展示发射弹幕的射线路径、冰砖的放置/移除过程、悬空块的消失动画，以及建造屋顶时的层叠效果。  
  * **设计思路简述**：采用FC红白机风格，地面用网格表示，冷冻度用颜色渐变（0-4对应浅蓝到深蓝），冰砖用白色方块。关键操作（如收集冰砖）伴随“叮”的音效，悬空块消失时用闪烁动画，成功建造屋顶时播放胜利音乐。  

  * **动画帧步骤与交互关键点**：  
    1. **场景初始化**：  
       - 屏幕显示N×N的网格，地面颜色根据冷冻度渐变（0:浅蓝，4:深蓝）。  
       - 控制面板包含“单步”“自动播放”按钮和速度滑块。  
    2. **发射弹幕**：  
       - 琪露诺角色在(R,C)位置，向方向D发射射线（用黄色箭头动画）。  
       - 射线经过的格子冷冻度+1（颜色变深），遇到冰砖（白色方块）时射线停止。  
    3. **收集冰砖**：  
       - 所有冷冻度为4的格子（深蓝）闪烁，冰砖库存数增加（顶部显示），格子颜色恢复为0（浅蓝）。  
    4. **放置冰砖**：  
       - 白色方块从顶部下落至(R,C,H)位置，若悬空则显示红色提示并消失；成功放置则显示绿色提示。  
    5. **移除冰砖**：  
       - 目标冰砖闪烁后消失，相邻冰砖若悬空则闪烁并逐个消失（伴随“噼啪”音效）。  
    6. **建造屋顶**：  
       - 墙壁最高处向上延伸一层，白色方块逐个放置形成屋顶，伴随“搭建”音效；若冰砖不足则显示红色警告。  

  * **旁白提示**：  
    - 发射弹幕时：“注意射线会被冰砖阻挡，冷冻度最高为4哦～”  
    - 移除冰砖时：“如果相邻冰砖不接触地面，它们会掉下来消失！”  
    - 建造屋顶时：“需要确保冰砖足够，否则无法完成屋顶搭建～”  

\<visualization\_conclusion\>
通过这个动画，你可以直观看到每个操作如何影响雪地状态，理解悬空块判断和屋顶建造的复杂逻辑。
\</visualization\_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
模拟类问题需要严格遵循规则，以下题目可帮助你巩固相关技巧：
\</similar\_problems\_intro\>

  * **通用思路/技巧迁移**：  
    本题的核心是“状态管理+条件判断”，类似的问题包括：  
    - 游戏模拟（如迷宫寻路、角色移动）；  
    - 物理模拟（如小球碰撞、液体流动）；  
    - 流程模拟（如餐厅点餐、任务调度）。  

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1003 铺地毯** - `模拟基础`  
        * 推荐理由：练习二维平面的覆盖模拟，理解状态更新逻辑。  
    2.  **洛谷 P1026 统计单词个数** - `字符串模拟`  
        * 推荐理由：练习多条件的字符串处理，提升条件判断能力。  
    3.  **洛谷 P1042 乒乓球** - `多阶段模拟`  
        * 推荐理由：练习多阶段状态切换，适合复杂流程处理。  

---

## 7\. 学习心得与经验分享 (若有)

\<insights\_intro\>
部分题解作者分享了调试经验，对我们很有启发：
\</insights\_intro\>

> **参考经验 (来自灵乌路空)**：“在处理悬空块时，最初没有正确标记已访问节点，导致BFS重复遍历。后来通过添加`vis`数组解决了问题。”  
> **点评**：这提醒我们，在使用BFS/DFS时，必须标记已访问节点，避免无限循环或重复计算。调试时可打印中间状态，快速定位问题。

> **参考经验 (来自tiger2005)**：“三维状态的管理容易出错，建议用结构体封装，减少重复代码。”  
> **点评**：结构体或类的使用能有效组织代码，提高可读性和维护性，是复杂模拟问题的重要技巧。

---

\<conclusion\>
“琪露诺的冰雪小屋”是一道复杂的模拟题，需要耐心处理每个操作的细节。通过理解核心逻辑、学习优质题解的代码结构，结合可视化动画，你一定能掌握这类问题的解决方法。继续加油，你会越来越熟练！💪
\</conclusion\>

---
处理用时：227.79秒
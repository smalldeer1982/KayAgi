# 题目信息

# 总统选举

## 题目背景

黑恶势力的反攻计划被小 C 成功摧毁，黑恶势力只好投降。秋之国的人民解放了，举国欢庆。此时，原秋之国总统因没能守护好国土，申请辞职，并请秋之国人民的大救星小 C 钦定下一任。

作为一名民主人士，小 C 决定举行全民大选来决定下一任。为了使最后成为总统的人得到绝大多数人认同，小 C 认为，一个人必须获得超过全部人总数的一半的票数才能成为总统。如果不存在符合条件的候选人，小 C 只好自己来当临时大总统。为了尽可能避免这种情况，小 C 决定先进行几次小规模预选，根据预选的情况，选民可以重新决定自己选票的去向。

由于秋之国人数较多，统计投票结果和选票变更也成为了麻烦的事情，小 C 找到了你，让你帮他解决这个问题。

## 题目描述

秋之国共有 $n$ 个人，分别编号为 $1,2,…,n$，一开始每个人都投了一票，范围 $1 \sim n$，表示支持对应编号的人当总统。

共有 $m$ 次预选，每次选取编号 $[l_i,r_i]$ 内的选民展开小规模预选，在该区间内获得超过区间大小一半的票的人获胜。如果没有人获胜，则由小 C 钦定一位候选者获得此次预选的胜利（获胜者可以不在该区间内），每次预选的结果需要公布出来，并且每次会有 $k_i$ 个人决定将票改投向该次预选的获胜者。

全部预选结束后，公布最后成为总统的候选人。

## 说明/提示

对于前 $20 \%$ 的数据，$1 \leq n,m \leq 5000$。

对于前 $40 \%$ 的数据，$1 \leq n,m \leq 50000$，$\sum k_i \leq 50000$。

对于前 $50 \%$ 的数据，$1 \leq n,m \leq {10}^5$，$\sum k_i \leq 2 \times {10}^5$。

对于数据点 6~7，保证所有选票始终在 $1 \sim 10$ 之间。

对于 $100 \%$ 的数据，$1 \leq n,m \leq 5 \times {10}^5$，$\sum k_i \leq 10^6$，$1 \leq l_i \leq r_i \leq n$，$1 \leq s_i \leq n$。

## 样例 #1

### 输入

```
5 4
1 2 3 4 5
1 2 1 1 3
5 5 1 2 2 4
2 4 2 0
3 4 2 1 4```

### 输出

```
1
5
5
2
-1```

# AI分析结果



---
# 💡 Kay的C++算法解析：总统选举 深入学习指南 💡

<introduction>
今天我们要一起攻克的题目是“总统选举”。这道题的核心在于高效处理区间内的绝对众数查询（得票超过区间一半）和动态选票修改。通过分析多种题解，我们会发现随机化算法和摩尔投票法是关键！让我们一步步拆解，掌握解题的核心技巧吧~
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：随机化算法、摩尔投票法（数学类算法）与平衡树的综合应用

🗣️ **初步分析**：
解决这道题的关键在于快速找到区间内的绝对众数（得票超过区间一半的候选人），并处理后续的选票修改。题目有两个核心挑战：
- 如何高效查询动态变化的区间绝对众数？
- 如何验证候选者是否真的满足“超过一半”的条件？

### 算法核心思想与应用
1. **随机化算法**：  
   绝对众数在区间中出现的概率很高（超过一半），因此随机选取少量样本（如14-20次），检查这些样本是否是绝对众数，错误概率极低（小于\(1/2^{14}\)）。例如，每次随机选一个位置，统计该候选人在区间内的得票，若超过半数则直接确定。

2. **摩尔投票法+线段树**：  
   摩尔投票法的核心是“抵消不同元素”：遍历区间时，维护当前候选人和剩余票数（相同则+1，不同则-1）。若存在绝对众数，最终剩下的候选人必为它。利用线段树可以维护区间的抵消结果（候选人和剩余票数），但需用平衡树验证该候选人是否真的满足条件。

### 可视化设计思路
我们设计一个**8位像素风动画**，演示随机化算法的采样过程：  
- 场景：像素网格代表选民，每个格子颜色对应支持的候选人。  
- 操作：每次随机选中一个格子（闪烁+“叮”音效），统计该颜色在区间内的数量（用柱状图动态显示）。若数量超过半区（高亮显示），则确定为胜出者；否则继续采样。  
- 动态修改：当选票修改时，对应格子颜色变化（渐变动画），平衡树中的节点动态增删（滑动效果）。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰性、代码规范性、算法效率等维度的评估，以下题解表现突出（≥4星）：
</eval_intro>

### 题解一：Ynoi的随机化+pb_ds平衡树（赞：40）
* **点评**：此题解巧妙利用随机化算法，结合pb_ds的红黑树（`tree`）快速统计区间内得票。代码简洁（仅100行左右），思路清晰：随机采样14次，验证候选者是否为绝对众数；若否，则使用钦定候选人。修改时直接更新平衡树，时间复杂度低（\(O(m \cdot 14 \log n + \sum k \log n)\)）。亮点在于用随机化大幅降低复杂度，适合处理大数据量。

### 题解二：LengChu的线段树+摩尔投票+Splay（赞：39）
* **点评**：此题解严谨地结合摩尔投票法和线段树维护候选，再用Splay平衡树验证。线段树节点存储候选人和抵消后的票数，合并时按摩尔投票规则处理。验证时通过Splay查询区间内得票，确保正确性。代码结构工整（封装线段树和Splay），适合理解摩尔投票法的区间可加性。

### 题解三：happybob的随机化+pb_ds（赞：2）
* **点评**：此题解简化随机次数为20次，代码更简短。利用pb_ds的`tree`快速统计区间得票，修改时直接更新。思路与Ynoi类似，但代码更易理解，适合初学者模仿。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决此题时，常见的难点和应对策略如下：
</difficulty_intro>

### 1. 如何高效查询区间绝对众数？
- **难点**：直接遍历区间统计所有候选人得票的时间复杂度为\(O(n)\)，无法处理\(n=5e5\)的规模。
- **策略**：  
  - **随机化**：利用绝对众数出现的高概率，随机采样少量样本（如14次），验证是否为真众数。错误概率极低（\(1/2^{14} \approx 0.00006\)），适合大数据量。  
  - **摩尔投票法+线段树**：线段树维护区间抵消后的候选人，再用平衡树验证。时间复杂度\(O(n \log n)\)，适合追求严谨性的场景。

### 2. 如何动态维护选票并快速验证？
- **难点**：每次修改后需更新候选人的得票记录，且验证时需快速查询区间内得票。
- **策略**：  
  使用平衡树（如pb_ds的`tree`或Splay）为每个候选人维护支持的选民编号。查询时，通过`order_of_key`函数快速统计区间内得票（\(O(\log n)\)）。

### 3. 如何处理“无绝对众数”的情况？
- **难点**：摩尔投票法可能返回错误的候选人，需验证。
- **策略**：无论用哪种方法找到的候选人，都需通过平衡树统计其在区间内的真实得票，若不超过半数则使用钦定候选人。

### ✨ 解题技巧总结
- **随机化优化**：合理设置采样次数（如14-20次），在错误概率和时间复杂度间取平衡。  
- **数据结构选择**：pb_ds的`tree`比手写Splay更简洁，适合竞赛快速实现。  
- **验证必做**：摩尔投票法或随机化得到的候选人需验证，确保正确性。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们选择随机化算法的简洁实现作为通用核心代码（综合Ynoi和happybob的题解），兼顾效率和易读性。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：此代码基于随机化算法，使用pb_ds的`tree`维护每个候选人的支持选民，随机采样14次验证候选者。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #include <ext/pb_ds/assoc_container.hpp>
    #include <ext/pb_ds/tree_policy.hpp>
    using namespace std;
    using namespace __gnu_pbds;

    const int MAXN = 5e5 + 5;
    const int SAMPLE_TIMES = 14; // 随机采样次数

    tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> tr[MAXN];
    int a[MAXN], n, m;

    // 统计候选人x在区间[l, r]内的得票
    int count(int x, int l, int r) {
        return tr[x].order_of_key(r + 1) - tr[x].order_of_key(l);
    }

    // 查找区间[l, r]的绝对众数（不存在返回-1）
    int find_majority(int l, int r) {
        int len = r - l + 1;
        for (int i = 0; i < SAMPLE_TIMES; ++i) {
            int pos = l + rand() % len; // 随机选一个位置
            int candidate = a[pos];
            if (count(candidate, l, r) > len / 2) {
                return candidate;
            }
        }
        return -1;
    }

    int main() {
        srand(time(0));
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; ++i) {
            scanf("%d", &a[i]);
            tr[a[i]].insert(i); // 初始时，i支持a[i]
        }

        while (m--) {
            int l, r, s, k;
            scanf("%d%d%d%d", &l, &r, &s, &k);
            int winner = find_majority(l, r);
            if (winner == -1) winner = s;
            printf("%d\n", winner);

            // 修改k个人的选票
            for (int i = 0; i < k; ++i) {
                int x;
                scanf("%d", &x);
                tr[a[x]].erase(x); // 从原候选人的支持列表中删除
                a[x] = winner;
                tr[winner].insert(x); // 添加到新候选人的支持列表
            }
        }

        // 最终统计全国是否有绝对众数
        int final_winner = find_majority(1, n);
        printf("%d\n", final_winner == -1 ? -1 : final_winner);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先用`tree`维护每个候选人的支持选民。`find_majority`函数通过随机采样验证候选者。每次预选时，若找到绝对众数则输出，否则使用钦定候选人。修改选票时，更新原候选人和新候选人的支持列表。最后统计全国结果。

---
<code_intro_selected>
接下来分析优质题解的核心片段：
</code_intro_selected>

### 题解一（Ynoi）核心代码片段
* **亮点**：使用pb_ds的`tree`快速统计得票，随机采样次数设为14，代码极短。
* **核心代码片段**：
    ```cpp
    int solve(int l,int r) {
        int n = r-l+1;
        for(int i = 1; i <= 14; i ++) {
            int x = rand()%n + l;
            x = a[x];
            if(qwq(x,l,r) > (n>>1)) return x;
        }
        return -1;
    }
    ```
* **代码解读**：  
  `solve`函数随机选取14个位置，检查对应候选人的得票是否超过半数。`qwq`函数通过`tree`的`order_of_key`快速计算区间内得票。随机次数设为14，平衡了时间和错误率。
* 💡 **学习笔记**：随机化的关键是合理设置采样次数，确保错误概率足够低（如14次时错误率约0.00006）。

### 题解二（LengChu）核心代码片段
* **亮点**：线段树维护摩尔投票的抵消结果，Splay验证候选者。
* **核心代码片段**：
    ```cpp
    struct xd_node {
        int cnt, num; // 抵消后的票数和候选人
    } tree[...];

    void change(int id) { // 合并左右子区间
        if(tree[ls].num == tree[rs].num) {
            tree[id].num = tree[ls].num;
            tree[id].cnt = tree[ls].cnt + tree[rs].cnt;
        } else {
            if(tree[ls].cnt >= tree[rs].cnt) {
                tree[id].cnt = tree[ls].cnt - tree[rs].cnt;
                tree[id].num = tree[ls].num;
            } else {
                tree[id].cnt = tree[rs].cnt - tree[ls].cnt;
                tree[id].num = tree[rs].num;
            }
        }
    }
    ```
* **代码解读**：  
  线段树节点存储抵消后的候选人（`num`）和剩余票数（`cnt`）。合并时，若左右子区间候选人相同则票数相加，否则保留票数多的候选人，票数相减。最终通过平衡树验证该候选人是否真的超过半数。
* 💡 **学习笔记**：摩尔投票法的区间可加性是关键，线段树能高效维护这一特性，但需验证结果。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解随机化算法的采样过程，我们设计了一个“像素选举探险”动画，用8位复古风格演示每一步操作！
</visualization_intro>

### 动画演示主题：像素选举探险
* **核心演示内容**：随机采样验证绝对众数的过程，以及选票修改的动态效果。

### 设计思路简述
采用FC红白机风格，用不同颜色的像素块代表不同候选人。每次随机采样时，选中的像素块闪烁并播放“叮”音效；统计得票时，用柱状图动态显示该候选人在区间内的得票；若超过半数，该颜色高亮并播放“胜利”音效；否则继续采样。修改选票时，对应像素块颜色渐变，平衡树中的节点滑动增删。

### 动画帧步骤与交互关键点
1. **初始化场景**：  
   - 屏幕下方为像素网格（n个格子，颜色为初始选票）。  
   - 上方显示控制面板（开始/暂停、单步、重置按钮，速度滑块）。  
   - 8位风格背景音乐（类似《超级玛丽》的轻快旋律）。

2. **预选开始**：  
   - 区间[l, r]用金色边框标出。  
   - 随机采样：每次选中一个格子（放大+闪烁），播放“叮”音效，显示该候选人颜色。

3. **得票统计**：  
   - 柱状图从下往上增长，显示该候选人在[l, r]内的得票（数值同步显示）。  
   - 若超过半数（柱状图超过半区），该颜色高亮，播放“胜利”音效，确定为胜出者。  
   - 否则继续采样（最多14次）。

4. **选票修改**：  
   - 选中要修改的选民格子（红色标记），颜色渐变到胜出者颜色（如蓝色→红色）。  
   - 平衡树区域（右侧）动态显示：原候选人的树中删除该节点（滑动消失），新候选人的树中添加该节点（滑动出现）。

5. **最终统计**：  
   - 全国范围用金色边框标出，重复采样过程，若找到绝对众数则高亮显示，否则显示“-1”。

### 旁白提示
- “看！选中了这个蓝色格子，现在统计蓝色在区间内的得票~”  
- “得票超过一半啦！蓝色胜出，播放胜利音效~”  
- “修改选票时，这个格子的颜色从蓝色变成了红色，平衡树也更新了哦！”

<visualization_conclusion>
通过这样的动画，我们能直观看到随机化算法如何快速找到绝对众数，以及选票修改对数据结构的影响，学习起来更有趣！
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，我们可以拓展到以下场景和题目：
</similar_problems_intro>

### 通用思路/技巧迁移
本题的随机化和摩尔投票法思想可用于：
1. **数组绝对众数查询**（如静态数组找众数）。  
2. **动态频率统计**（如实时热搜榜，快速判断某话题是否占比过半）。  
3. **大数据量下的近似算法**（如海量数据中快速估计主元素）。

### 练习推荐 (洛谷)
1. **洛谷 P2397 yyy loves Maths VI (mode)**  
   🗣️ 推荐理由：直接应用摩尔投票法，理解其核心思想。  
2. **洛谷 P3369 普通平衡树**  
   🗣️ 推荐理由：练习平衡树的插入、删除、查询操作，为本题的验证步骤打基础。  
3. **洛谷 P1972 [SDOI2009]HH的项链**  
   🗣️ 推荐理由：学习离线处理区间查询，结合树状数组或线段树，拓展数据结构应用能力。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，对我们很有启发：
</insights_intro>

> **参考经验（来自401rk8）**：“在随机化算法中，用时间戳标记已查询的候选人，避免重复查询同一人，提升效率。”

**点评**：这一优化很实用！当区间内候选人较少时，重复查询同一候选人会浪费时间。标记已查候选人可减少无效操作，值得在实际编码中应用。

---

<conclusion>
通过对“总统选举”的分析，我们掌握了随机化算法和摩尔投票法的核心，学会了用平衡树维护动态数据。编程的关键在于选择合适的算法和数据结构，结合验证步骤确保正确性。希望大家多练习，在竞赛中灵活运用这些技巧！下次见~ 💪
</conclusion>

---
处理用时：176.26秒
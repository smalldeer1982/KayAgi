# 题目信息

# 文艺数学题

## 题目背景

小Y在AK曼哈顿OI，CTSC和APIO之后，开始研究数学题。


## 题目描述

小Y有一张N个点，M条边的无向图（**可能有重边、自环**），每条边都有一个权值w。


你需要计算：所有**生成树的边权的最大公约数**之和，具体操作见样例。


由于答案可能很大，需要**对1000000007取模**。


## 说明/提示

### 样例1的解释



 ![](https://cdn.luogu.com.cn/upload/pic/13639.png) 

显然，这张图有8个不同的生成树。


用$(x,y,z)$表示x,y,z的最大公约数，则答案


$=(12,6,8)+(6,8,9)+(8,9,12)+(9,12,6)+(9,4,6)+(12,4,8)+(12,4,9)+(6,4,8)$


$=2+1+1+3+1+4+1+2$


$=15$

### 数据范围


对于20%的数据，$N\le 10, M\le 20$；

对于另外10%的数据，$N\le 12, M\le 24$；

对于另外20%的数据，$N\le 60, M\le 3000$，且满足$u_i+1=v_i$；

对于另外20%的数据，$N\le 40, M\le 1000, W\le 1000$；

对于另外15%的数据，$N\le 50, M\le 2000$；

对于所有100%的数据，$N\le 60, M\le 3000, W\le 1000000$；



## 样例 #1

### 输入

```
4 5  
1 2 12  
1 3 9  
2 4 6  
3 4 8  
1 4 4  ```

### 输出

```
15```

# AI分析结果



---
# 💡 Kay的C++算法解析：文艺数学题 深入学习指南 💡

<introduction>
今天我们要挑战的题目是“文艺数学题”，这道题结合了图论、数论和生成树计数的知识。通过本指南，你将理解如何用数学反演和矩阵树定理解决这类问题，并掌握关键的编程技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论反演（莫比乌斯/欧拉函数应用）+ 矩阵树定理 (图论生成树计数)

🗣️ **初步分析**：
解决这道题的关键在于将“所有生成树的边权GCD之和”转化为可计算的数学形式。简单来说，我们可以把问题拆解为：枚举每个可能的GCD值d，计算有多少生成树的边权GCD恰好是d，然后将d乘以对应的数量求和。这一步需要用到数论中的“反演”思想——先计算所有边权都是d的倍数的生成树数量（记为F(d)），再通过欧拉函数φ(d)将F(d)转化为最终的贡献。

- **题解思路**：主流解法是通过枚举d，筛选出所有边权是d的倍数的边，用矩阵树定理计算这些边构成的图的生成树数量F(d)，最后利用公式`ans = Σ F(d) * φ(d)`求和。
- **核心难点**：如何高效枚举d、正确应用矩阵树定理计算生成树数量、优化枚举范围以降低复杂度。
- **可视化设计**：动画将用8位像素风格展示“边筛选”（d的倍数边变亮）、“生成树构建”（动态连接节点）、“矩阵树计算”（高斯消元过程用像素方块模拟行变换），关键步骤（如d的选择、生成树计数结果）用文字气泡解释，音效在边筛选时“叮”一声，生成树成功时播放轻快音乐。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰度、代码规范性和算法有效性上表现突出（均≥4星），值得重点学习：
</eval_intro>

**题解一：作者will7101**
* **点评**：此题解从暴力枚举到100分优化逐层递进，详细推导了数论反演的公式（如F(d)与f(d)的关系），并解释了关键优化点（如筛选有效d的范围）。思路清晰，适合理解问题的数学转化过程。特别是对“F(d)是d的倍数的生成树数量”的定义和矩阵树定理的应用场景说明，帮助学习者建立从问题到算法的映射。

**题解二：作者Prean**
* **点评**：此题解提供了完整的C++实现，代码规范（变量名如`phi`、`Solve`含义明确），巧妙结合了欧拉函数预处理和矩阵树定理。在优化上，通过预处理边权的因数减少无效枚举，复杂度控制得当。其高斯消元实现（`Gauss`函数）逻辑简洁，是矩阵树定理的标准应用范例，适合直接参考编码。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的核心难点主要集中在数学转化、生成树计数和枚举优化三个方面。我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何将GCD之和转化为枚举d的贡献？**
    * **分析**：直接计算所有生成树的GCD之和很困难，但通过数论反演，我们可以先计算所有边权是d的倍数的生成树数量F(d)。根据数论知识，最终答案等于所有d的F(d)乘以欧拉函数φ(d)之和（`ans = Σ F(d)*φ(d)`）。这一步转化的关键是理解“倍数关系”与“恰好等于”的联系。
    * 💡 **学习笔记**：当直接求“恰好等于”的问题困难时，先求“倍数”再反演是常见的数论技巧。

2.  **关键点2：如何用矩阵树定理计算生成树数量？**
    * **分析**：矩阵树定理通过构造基尔霍夫矩阵（度数矩阵-邻接矩阵），计算其n-1阶行列式得到生成树数量。实现时需注意模运算（本题模数为1e9+7）和高斯消元的细节（如行交换时的符号变化）。
    * 💡 **学习笔记**：矩阵树定理是生成树计数的“万能钥匙”，但需确保图连通（否则行列式为0）。

3.  **关键点3：如何优化枚举d的范围？**
    * **分析**：直接枚举所有d（1到1e6）会超时。观察到只有当“边权是d的倍数的边数≥n-1”时，才可能存在生成树。因此，只需枚举满足此条件的d，大幅减少计算量。
    * 💡 **学习笔记**：预处理边权的因数，筛选有效d是优化的核心。

### ✨ 解题技巧总结
- **问题转化**：将“GCD之和”转化为“倍数生成树数量×欧拉函数”之和，利用数论反演简化问题。
- **矩阵树定理应用**：构造基尔霍夫矩阵时，注意度数矩阵和邻接矩阵的正确计算（重边需累加度数）。
- **优化枚举**：通过边权的因数分解和边数筛选，仅处理可能生成树的d，降低时间复杂度。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合题解思路的通用核心实现，结合了数论反演和矩阵树定理，代码简洁高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了will7101的数学推导和Prean的实现思路，包含预处理欧拉函数、矩阵树定理计算生成树数量、枚举有效d并累加贡献的完整逻辑。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <vector>
    typedef unsigned ui;
    const ui M = 1e6 + 5, mod = 1e9 + 7;
    ui n, m, mx, top, G[65][65], u[3005], v[3005], phi[M];
    std::vector<ui> id[M]; // id[w]存储权值为w的边的索引

    inline ui Add(const ui& a, const ui& b) {
        return a + b >= mod ? a + b - mod : a + b;
    }

    inline ui Del(const ui& a, const ui& b) {
        return b > a ? a - b + mod : a - b;
    }

    inline ui pow_mod(ui a, ui b) {
        ui ans = 1;
        for (; b; b >>= 1, a = 1ull * a * a % mod)
            if (b & 1) ans = 1ull * ans * a % mod;
        return ans;
    }

    inline ui Gauss() { // 高斯消元计算行列式（基尔霍夫矩阵）
        ui ans = 1;
        for (ui i = 1; i < n; ++i) {
            if (!G[i][i]) { // 寻找非零行交换
                for (ui j = i + 1; j < n; ++j)
                    if (G[j][i]) { std::swap(G[i], G[j]); ans = mod - ans; break; }
            }
            ui inv = pow_mod(G[i][i], mod - 2); // 逆元
            ans = 1ull * ans * G[i][i] % mod;
            for (ui j = i + 1; j < n; ++j) { // 消元
                ui d = 1ull * (mod - G[j][i]) * inv % mod;
                for (ui k = i; k < n; ++k)
                    G[j][k] = (G[j][k] + 1ull * d * G[i][k]) % mod;
            }
        }
        return ans;
    }

    inline ui Solve(ui d) { // 计算边权为d的倍数的生成树数量
        for (ui i = 1; i < n; ++i) // 初始化基尔霍夫矩阵
            for (ui j = 1; j < n; ++j)
                G[i][j] = (i == j) ? 0 : mod;
        for (ui w = d; w <= mx; w += d) // 遍历d的倍数权值
            for (ui& e : id[w]) { // 对每条边更新矩阵
                G[u[e]][u[e]] = Add(G[u[e]][u[e]], 1);
                G[v[e]][v[e]] = Add(G[v[e]][v[e]], 1);
                G[u[e]][v[e]] = Del(G[u[e]][v[e]], 1);
                G[v[e]][u[e]] = Del(G[v[e]][u[e]], 1);
            }
        return Gauss();
    }

    int main() {
        scanf("%u%u", &n, &m);
        for (ui i = 1; i <= m; ++i) { // 输入边并记录权值
            ui a, b, w;
            scanf("%u%u%u", &a, &b, &w);
            u[i] = a - 1; v[i] = b - 1; // 节点编号从0开始（方便矩阵）
            id[w].push_back(i);
            if (w > mx) mx = w;
        }

        // 预处理欧拉函数phi
        phi[1] = 1;
        for (ui i = 2; i <= mx; ++i) {
            if (!phi[i]) { // 质数
                phi[i] = i - 1;
                for (ui j = 2 * i; j <= mx; j += i) {
                    if (!phi[j]) phi[j] = j;
                    phi[j] = phi[j] / i * (i - 1);
                }
            }
        }

        ui ans = 0;
        for (ui d = 1; d <= mx; ++d) { // 枚举每个d
            ui cnt = 0;
            for (ui w = d; w <= mx; w += d) cnt += id[w].size();
            if (cnt < n - 1) continue; // 边数不足，无法生成树
            ans = (ans + 1ull * phi[d] * Solve(d)) % mod;
        }
        printf("%u\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：代码首先预处理欧拉函数，然后枚举每个d，筛选出边权是d的倍数的边，用矩阵树定理计算生成树数量F(d)，最后累加F(d)*φ(d)得到答案。核心逻辑在`Solve`函数（构建基尔霍夫矩阵并计算行列式）和主函数的枚举优化部分。

---
<code_intro_selected>
接下来，我们分析优质题解的核心代码片段，学习其中的关键技巧：
</code_intro_selected>

**题解二：作者Prean**
* **亮点**：代码高效预处理欧拉函数，利用`std::vector`存储同权值的边，优化枚举d的范围（仅处理边数≥n-1的d）。
* **核心代码片段**：
    ```cpp
    inline ui Gauss() {
        ui i,j,k,d,inv,ans(1);
        for(i=1;i^n;++i){
            if(!G[i][i])for(j=i+1;j^n;++j)if(G[j][i]){
                ans=mod-ans;std::swap(G[i],G[j]);break;
            }
            inv=pow(G[i][i],mod-2);ans=1ull*ans*G[i][i]%mod;
            for(j=i+1;j^n;++j)for(d=1ull*(mod-G[j][i])*inv%mod,k=i;k^n;++k)
                G[j][k]=(G[j][k]+1ull*d*G[i][k])%mod;
        }
        return ans;
    }
    ```
* **代码解读**：这段代码实现了高斯消元求行列式。`G`是基尔霍夫矩阵，`ans`记录行列式值。当当前行主元为0时，寻找下方非零行交换（调整符号）；计算当前主元的逆元，用其消去下方行的对应列，最终行列式等于主对角线元素的乘积。这是矩阵树定理的核心实现。
* 💡 **学习笔记**：高斯消元时，行交换会改变行列式符号（`ans=mod-ans`），逆元用于将主元化为1，方便后续消元。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解枚举d、筛选边、计算生成树的过程，我们设计一个“像素探险家长生树大冒险”动画！
</visualization_intro>

  * **动画演示主题**：像素探险家在“图之大陆”中，通过筛选边权为d的倍数的边，搭建生成树，收集GCD宝藏。

  * **核心演示内容**：展示枚举d=1到d=mx的过程，每步筛选边→构建基尔霍夫矩阵→高斯消元计算生成树数量→累加φ(d)*F(d)到答案。

  * **设计思路简述**：8位像素风格（类似FC游戏）让学习更轻松；边筛选时用黄色闪光标记，生成树用绿色连线动态展示；高斯消元用像素方块模拟行交换和消元步骤，配合“叮”声强化记忆；每完成一个d的计算，播放“金币掉落”音效，增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：屏幕左侧是“图之大陆”（像素节点用圆圈表示，边用线段连接，边权显示在旁边）；右侧是“矩阵实验室”（基尔霍夫矩阵用像素表格展示）；底部是控制面板（单步/自动按钮、速度滑块）。

    2.  **枚举d**：顶部显示当前枚举的d值（如d=2），所有边权是d的倍数的边变为黄色（如权值4、6、8的边），其他边变灰。

    3.  **构建基尔霍夫矩阵**：右侧矩阵实验室中，根据筛选的边动态更新矩阵数值（度数矩阵和邻接矩阵的计算），每更新一个元素，对应像素方块闪烁并播放“滴答”声。

    4.  **高斯消元**：逐行处理矩阵，当主元为0时，下方行向上交换（像素行滑动动画），符号变为红色；计算逆元时，主元方块变亮；消元时，下方行的元素逐个更新（数值变化伴随“唰”声）。

    5.  **生成树计数**：消元完成后，行列式值（生成树数量）从矩阵中“弹出”，显示在屏幕中央，播放“叮”声。

    6.  **累加答案**：计算φ(d)*F(d)，数值飞入“答案宝箱”（像素宝箱打开，金币动画），背景音效短暂变轻快。

  * **旁白提示**：
      - “现在枚举的d是2，所有边权是2的倍数的边被选中了！”
      - “看，基尔霍夫矩阵的度数在增加，邻接关系在调整～”
      - “高斯消元时如果主元是0，需要找下面的行交换，符号要变哦！”
      - “生成树数量是5，乘以φ(2)=1，贡献5到答案！”

<visualization_conclusion>
通过这样的动画，你可以清晰看到每个d的筛选、矩阵构建和生成树计数过程，理解数学反演如何转化为具体的计算步骤。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思想（数论反演+生成树计数）可迁移到许多类似问题中：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 生成树计数问题（如求所有生成树的边权和、异或和）。
      - 数论反演在统计“恰好满足条件”的计数问题（如求所有子集的GCD之和）。
      - 矩阵树定理的变形（如带权生成树计数、有向图生成树计数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4119** - 小Z的袜子  
        * 🗣️ **推荐理由**：练习莫比乌斯反演在统计区间GCD问题中的应用。
    2.  **洛谷 P3313** - 旅行问题  
        * 🗣️ **推荐理由**：结合矩阵树定理和动态规划，拓展生成树计数的应用场景。
    3.  **洛谷 P4455** - 小星星  
        * 🗣️ **推荐理由**：学习容斥原理与生成树计数的结合，提升问题转化能力。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本题解中未明确提及作者的个人学习心得，但根据常见调试问题，我们总结以下经验：
</insights_intro>

> **常见调试陷阱**：矩阵树定理中，节点编号需从0或1开始并保持一致；模运算时注意减法可能产生负数（用`Del`函数处理）；枚举d时，需确保边数≥n-1（否则生成树数量为0）。

**点评**：这些细节是编码时的易错点，建议在编写矩阵树定理代码后，用小样例（如n=2, m=1）验证行列式计算是否正确；枚举d时，打印筛选出的边数，确保逻辑正确。

---

<conclusion>
通过本次分析，我们掌握了如何用数论反演和矩阵树定理解决生成树GCD之和的问题。记住，遇到复杂问题时，先拆解为可计算的子问题（如枚举d），再结合数学工具（如反演）和经典算法（如矩阵树定理），就能逐步攻克！期待你用这些技巧挑战更多难题～ 💪
</conclusion>

---
处理用时：154.28秒
# 题目信息

# [FJOI2017] 矩阵填数

## 题目描述

给定一个 $h \times w$ 的矩阵，矩阵的行编号从上到下依次为 $1 \sim h$，列编号从左到右依次 $1 \sim w$。

在这个矩阵中你需要在每个格子中填入 $1 \sim m$ 中的某个数。

给这个矩阵填数的时候有一些限制，给定 $n$ 个该矩阵的子矩阵，以及该子矩阵的最大值 $v$，要求你所填的方案满足该子矩阵的最大值为 $v$。

现在，你的任务是求出有多少种填数的方案满足 $n$ 个限制。

两种方案是不一样的当且仅当两个方案至少存在一个格子上有不同的数。由于答案可能很大，你只需要输出答案对 $10 ^ 9 + 7$ 取模后的结果。

## 说明/提示

对于 $20\%$ 的数据，$n \le 2$。

另有 $20\%$ 的数据，$1 \le h, w \le 50$。

对于 $100\%$ 的数据，$T \le 5$，$1 \le h, w, m \le 10 ^ 4$，$1 \le n \le 10$，$1 \le v \le m$。

## 样例 #1

### 输入

```
2
3 3 2 2
1 1 2 2 2
2 2 3 3 1
4 4 4 4
1 1 2 3 3
2 3 4 4 2
2 1 4 3 2
1 2 3 4 4```

### 输出

```
28
76475```

# AI分析结果



---

# 💡 Kay的C++算法解析：[FJOI2017] 矩阵填数 深入学习指南 💡

<introduction>
今天我们来攻克“[FJOI2017] 矩阵填数”这道题！它要求我们计算满足多个子矩阵最大值限制的填数方案数。虽然题目数据规模大（h,w到1e4），但限制数n≤10，这提示我们可以用容斥或状态压缩等技巧解决。本指南将带大家理清思路，掌握核心算法！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：容斥原理与状态压缩（状压DP）

🗣️ **初步分析**：
解决这道题的关键在于处理“子矩阵最大值恰好为v”的限制。直接计算这样的方案数很困难，但我们可以用容斥原理转化问题：  
“最大值恰好为v” = “最大值≤v” - “最大值<v”。  
由于n很小（≤10），我们可以枚举所有可能的限制组合（2^n种），用容斥调整符号得到最终结果。此外，大矩阵的h,w很大，但n小，我们可以通过离散化将大矩阵切割成O(n²)个小块，每个小块的限制情况相同，大幅降低复杂度。

### 核心算法流程与可视化设计
1. **离散化切割矩阵**：将所有限制的边界坐标排序去重，把大矩阵切割成多个小块，每个小块被相同的限制覆盖。  
2. **预处理小块信息**：计算每个小块的面积、最大允许值（覆盖它的最小v），以及该值对应的限制集合（状态）。  
3. **容斥或状压DP计算**：枚举所有可能的限制组合（容斥的子集或状压的状态），计算每个组合下的方案数，调整符号得到最终结果。

**可视化方案**：设计一个8位像素动画，用不同颜色表示小块的最大允许值（如红色为v=2，蓝色为v=3）。动画中，鼠标点击可选择不同的限制组合（子集），选中的限制会降低v（变为v-1），对应小块颜色变浅。同时，用动态文字展示当前子集的容斥符号（+/-），并实时计算方案数。点击“自动播放”会演示所有子集的枚举过程，配合“叮”的音效提示符号变化。

---

## 2. 精选优质题解参考

<eval_intro>
经过评分（思路清晰性、代码规范性、算法有效性等），以下题解质量突出（≥4星），值得重点学习：
</eval_intro>

**题解一：shadowice1984（容斥+并集面积计算）**  
* **点评**：该题解巧妙利用容斥计算并集面积，复杂度O(3^n)。代码中通过预处理所有子集的交集面积，再用容斥求并集，最后对每个值域统计方案数。思路直接，代码高效，边界处理严谨（如空矩形的判断），是容斥应用的典范。

**题解二：Itst（离散化+容斥）**  
* **点评**：该题解先离散化坐标，将大矩阵切割成O(n²)个小块，再枚举所有子集（2^n种），计算每个子集下各小块的最大允许值，最后用快速幂求方案数。代码简洁，离散化逻辑清晰，适合理解如何处理大矩阵的限制。

**题解三：pantw（状压DP）**  
* **点评**：该题解将每个小块的状态（覆盖它的限制集合）压缩为二进制位，用状压DP逐步转移。状态定义明确（dp[i][j]表示前i个小块状态为j的方案数），转移逻辑直观（选或不选当前块的最大值），是状压DP的经典应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何处理多个限制的重叠和“最大值恰好为v”的转化。以下是关键步骤和应对策略：
</difficulty_intro>

1.  **关键点1：如何确定每个点的最大允许值？**  
    * **分析**：每个点的最大允许值是覆盖它的所有限制中最小的v（因为必须满足所有限制的最大值≤v）。例如，若一个点被v=3和v=5的限制覆盖，则其最大允许值为3。  
    * 💡 **学习笔记**：最大允许值由所有覆盖它的限制的最小值决定，这是后续计算的基础。

2.  **关键点2：如何将“最大值恰好为v”转化为可计算的条件？**  
    * **分析**：利用容斥原理，“恰好为v”等于“≤v”的方案数减去“<v”的方案数。对于多个限制，枚举哪些限制被调整为“<v”（即不满足原限制），计算这些子集的方案数，用容斥符号调整后相加。  
    * 💡 **学习笔记**：容斥的核心是“补集的并集”，通过枚举子集调整符号，将复杂的交集转化为简单的并集计算。

3.  **关键点3：如何处理大矩阵的高复杂度？**  
    * **分析**：通过离散化将大矩阵切割成O(n²)个小块，每个小块的限制情况相同。例如，所有限制的左右边界将x轴切割为O(n)段，同理y轴，总共有O(n²)个小块。  
    * 💡 **学习笔记**：离散化是处理大矩阵问题的常用技巧，能将O(hw)的复杂度降为O(n²)。

### ✨ 解题技巧总结
- **离散化预处理**：将大矩阵切割为小块，统一处理相同限制的区域。  
- **容斥枚举子集**：枚举所有可能的限制组合（2^n种），计算每种组合下的方案数。  
- **快速幂优化**：计算每个小块的方案数（如v^面积）时，用快速幂降低时间复杂度。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解的思路，提炼一个基于离散化和容斥的通用核心实现。该代码先离散化矩阵，再枚举所有子集计算方案数，最后用容斥调整符号得到结果。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了shadowice1984和Itst的思路，通过离散化处理大矩阵，枚举所有子集（2^n种），计算每个子集下的方案数，最后用容斥调整符号得到答案。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9 + 7;

ll qpow(ll a, ll b) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % MOD;
        a = a * a % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    int T;
    scanf("%d", &T);
    while (T--) {
        int h, w, m, n;
        scanf("%d%d%d%d", &h, &w, &m, &n);
        vector<int> xs = {1, h + 1}, ys = {1, w + 1};
        vector<tuple<int, int, int, int, int>> rects(n);
        for (int i = 0; i < n; ++i) {
            int x1, y1, x2, y2, v;
            scanf("%d%d%d%d%d", &x1, &y1, &x2, &y2, &v);
            rects[i] = {x1, y1, x2, y2, v};
            xs.push_back(x1); xs.push_back(x2 + 1);
            ys.push_back(y1); ys.push_back(y2 + 1);
        }
        sort(xs.begin(), xs.end()); xs.erase(unique(xs.begin(), xs.end()), xs.end());
        sort(ys.begin(), ys.end()); ys.erase(unique(ys.begin(), ys.end()), ys.end());
        int xn = xs.size(), yn = ys.size();
        vector<vector<int>> max_val(xn - 1, vector<int>(yn - 1, m));
        for (auto [x1, y1, x2, y2, v] : rects) {
            int lx = lower_bound(xs.begin(), xs.end(), x1) - xs.begin();
            int rx = lower_bound(xs.begin(), xs.end(), x2 + 1) - xs.begin();
            int ly = lower_bound(ys.begin(), ys.end(), y1) - ys.begin();
            int ry = lower_bound(ys.begin(), ys.end(), y2 + 1) - ys.begin();
            for (int i = lx; i < rx; ++i)
                for (int j = ly; j < ry; ++j)
                    max_val[i][j] = min(max_val[i][j], v);
        }
        ll ans = 0;
        for (int mask = 0; mask < (1 << n); ++mask) {
            vector<vector<int>> cur_val = max_val;
            for (int i = 0; i < n; ++i) {
                if (mask & (1 << i)) {
                    auto [x1, y1, x2, y2, v] = rects[i];
                    int lx = lower_bound(xs.begin(), xs.end(), x1) - xs.begin();
                    int rx = lower_bound(xs.begin(), xs.end(), x2 + 1) - xs.begin();
                    int ly = lower_bound(ys.begin(), ys.end(), y1) - ys.begin();
                    int ry = lower_bound(ys.begin(), ys.end(), y2 + 1) - ys.begin();
                    for (int a = lx; a < rx; ++a)
                        for (int b = ly; b < ry; ++b)
                            cur_val[a][b] = min(cur_val[a][b], v - 1);
                }
            }
            ll ways = 1;
            for (int i = 0; i < xn - 1; ++i) {
                for (int j = 0; j < yn - 1; ++j) {
                    ll area = (xs[i + 1] - xs[i]) * (ll)(ys[j + 1] - ys[j]);
                    ways = ways * qpow(cur_val[i][j], area) % MOD;
                }
            }
            int cnt = __builtin_popcount(mask);
            if (cnt % 2) ans = (ans - ways + MOD) % MOD;
            else ans = (ans + ways) % MOD;
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **离散化处理**：将所有限制的边界坐标排序去重，切割矩阵为小块。  
  2. **预处理最大允许值**：计算每个小块的初始最大允许值（覆盖它的最小v）。  
  3. **枚举子集计算方案数**：枚举所有子集（mask），调整对应限制的v为v-1，计算该子集下的方案数。  
  4. **容斥调整符号**：根据子集大小的奇偶性调整符号，累加得到最终结果。

---

<code_intro_selected>
接下来，我们分析优质题解的关键代码片段，学习其核心逻辑：
</code_intro_selected>

**题解一：shadowice1984（容斥+并集面积计算）**  
* **亮点**：通过预处理所有子集的交集面积，再用容斥求并集，高效计算各区域的面积。  
* **核心代码片段**：
```cpp
// 预处理所有子集的交集面积
for(int i=1;i<=up;i++){
    tr.x=1; tr.y=1; tr.x1=h; tr.y1=w;
    for(int p=i,j=0;p;p>>=1,j++){
        if(p&1){tr&=r[j]; if(tr.ck()){s[i]=0; goto ed;}}
    }
    s[i]=tr.calcs(); ed:;
}
// 用容斥求并集面积
for(int i=1;i<=up;i++){
    for(int j=i;j;j=(j-1)&i){
        if(siz[j]%2) u[i]+=s[j]; else u[i]-=s[j];
    }
}
```
* **代码解读**：  
  `s[i]`存储子集i的交集面积，`u[i]`存储子集i的并集面积。通过枚举子集的子集（j是i的子集），用容斥公式计算并集面积（奇加偶减）。这一步是后续计算各值域方案数的基础。  
* 💡 **学习笔记**：容斥求并集时，子集的枚举顺序（j=(j-1)&i）是关键，确保每个子集被正确处理。

**题解二：pantw（状压DP）**  
* **亮点**：将每个小块的状态压缩为二进制位，用状压DP逐步转移。  
* **核心代码片段**：
```cpp
// 预处理每个小块的信息（面积、最大允许值、覆盖的限制集合）
for(int i=1;i<xbs;++i){
    for(int j=1;j<ybs;++j){
        ++bs;
        block[bs] = (xb[i] - xb[i-1]) * (yb[j] - yb[j-1]);
        blimit[bs] = m;
        for(int k=0;k<n;++k)
            if(in(xb[i], yb[j], k))
                blimit[bs] = min(blimit[bs], v[k]);
        for(int k=0;k<n;++k)
            if(in(xb[i], yb[j], k) && blimit[bs] == v[k])
                fulfill[bs] ^= 1 << k;
    }
}
// 状压DP转移
for(int i=1;i<=bs;++i){
    int ful = fulfill[i];
    ll fail = pow(blimit[i] - 1, block[i]);
    ll success = (pow(blimit[i], block[i]) - fail + mod) % mod;
    for(int j=0;j<li;++j){
        f[i][j] = (f[i][j] + f[i-1][j] * fail) % mod;
        f[i][j|ful] = (f[i][j|ful] + f[i-1][j] * success) % mod;
    }
}
```
* **代码解读**：  
  `block[bs]`存储小块面积，`blimit[bs]`是最大允许值，`fulfill[bs]`是覆盖该块的限制集合（二进制位）。DP转移时，`fail`是该块不取最大值的方案数（(v-1)^面积），`success`是取最大值的方案数（v^面积 - (v-1)^面积）。状态j|ful表示选中该块的限制集合。  
* 💡 **学习笔记**：状压DP的关键是状态定义（哪些限制被满足）和转移逻辑（选或不选当前块的最大值）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观理解容斥和离散化的过程，我们设计一个“矩阵填数大冒险”像素动画！让我们一起“看”到算法如何工作吧~
</visualization_intro>

  * **动画演示主题**：像素小探险家的矩阵填数挑战  
  * **核心演示内容**：展示大矩阵如何被离散化为小块，每个小块的颜色代表其最大允许值（如红色=2，蓝色=3）。动画中，小探险家会枚举所有限制的组合（子集），调整某些限制的v为v-1（颜色变浅），并计算该组合下的方案数，最后用容斥符号（+/-）累加结果。

  * **设计思路简述**：  
    采用8位像素风格（类似FC游戏），用不同颜色区分小块的最大允许值。通过“单步执行”按钮，学习者可以逐个子集观察调整过程；“自动播放”会快速演示所有2^n个子集，配合“叮”的音效提示符号变化（奇数子集音效低沉，偶数子集清脆）。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：大矩阵被切割为多个小块，每个小块显示面积和初始最大允许值（颜色条）。  
    2. **枚举子集**：点击“开始”后，子集mask从0到2^n-1依次出现，对应限制被调整的情况（如mask=3表示前两个限制被调整）。  
    3. **调整最大值**：被调整的限制对应的小块颜色变浅（v→v-1），动态更新每个小块的当前最大允许值。  
    4. **计算方案数**：每个小块的方案数（v^面积）用数字弹出显示，总方案数累加时用箭头动画表示。  
    5. **容斥符号调整**：根据子集大小的奇偶性，总方案数加减当前方案数（奇数子集用减号，偶数用加号），符号用动态文字提示。  
    6. **最终结果**：所有子集处理完毕后，显示最终方案数，伴随“胜利”音效和烟花动画。

  * **旁白提示**：  
    - “当前处理子集mask=3，前两个限制被调整为v-1，对应小块颜色变浅~”  
    - “这个子集有2个限制被调整（偶数），所以总方案数加当前值！”  
    - “所有子集处理完成，最终方案数是28，任务完成！”

<visualization_conclusion>
通过这个动画，我们可以直观看到离散化如何切割矩阵，容斥如何枚举子集调整符号，以及方案数的计算过程。是不是更容易理解了呢？
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的容斥和离散化技巧后，我们可以尝试以下类似题目，巩固知识：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的离散化和容斥思想适用于所有“多限制条件下的计数问题”，尤其是限制数较小（n≤10）的情况。例如：  
    - 统计满足多个区间最大值限制的数组数目。  
    - 计算覆盖多个区域的涂色方案数（每个区域有颜色限制）。  
    - 处理多个矩形覆盖下的路径计数问题。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1835 素数密度**（离散化）  
        * 🗣️ **推荐理由**：练习离散化处理大区间，统计素数个数，与本题的离散化思路类似。  
    2.  **洛谷 P2157 [SDOI2009]HH的项链**（容斥）  
        * 🗣️ **推荐理由**：用容斥或莫队算法处理区间不同数的个数，训练容斥思维。  
    3.  **洛谷 P3959 [NOIP2017]列队**（状压DP）  
        * 🗣️ **推荐理由**：用状压DP处理多条件下的队列调整问题，提升状态压缩能力。

---

## 7\. 学习心得与经验分享 

<insights_intro>
部分题解作者提到，离散化时的边界处理（如x2+1）和容斥的符号调整是易错点。例如，在计算子集的交集面积时，需要特别注意空矩形的判断（x>x1或y>y1时面积为0）。此外，快速幂的取模运算也需谨慎，避免溢出。
</insights_intro>

> **参考经验 (来自 shadowice1984)**：“在预处理交集面积时，我一开始没考虑空矩形的情况，导致计算并集时出现错误。后来通过添加`if(tr.ck()){s[i]=0;}`才解决。”  
> **点评**：这位作者的经验提醒我们，边界条件（如空矩形）的处理非常重要。在代码中，应始终检查是否出现无效区域（如x>x1），避免错误计算面积。

---

<conclusion>
通过本指南的学习，相信大家对“矩阵填数”问题的解法有了深入理解。记住，容斥和离散化是处理多限制计数问题的“利器”，多练习类似题目，你会更熟练！下次见~ 💪
</conclusion>

---

---
处理用时：199.14秒
# 题目信息

# [Ynoi Easy Round 2016] 炸脖龙 I

## 题目背景

备餐时光，软泞蜥獾

草地中钻孔，日晷下打转

波若歌鹦苟延残喘，迷途绿龟嚎哮迷茫

“当心炸脖龙，我的孩子！

那锋爪利颚，能挠钩撕咬！

注意秋布秋布鸟，你需回避，

那暴躁冒烟恶怪大毛怪！”

手持宝剑鸣真理之语：寻觅强敌豪壮永不息——于噹噹树下稍事休憩，伫立良久，深陷思绪。

当思绪纷乱杂绪之际，炸脖龙双目如烔炬，从阴暗密林奔跃闯出，一路悲鸣低吟时啭啼！

一，二！一，二！一刺再刺，真理之语将敌斩成糜！

取其首级，置之死地，

伴随胜利，驰马归疾。

“真当是你把怪龙斩于马下？

奋勇吾儿！

来我怀里！奔走相告！衣锦还乡！

父喜不自禁窃鸣得意

波若歌鹦苟延残喘，

迷途绿龟嚎哮迷茫，

备餐时光，软泞蜥獾

草地中钻孔，日晷下打转

波若歌鹦苟延残喘，

迷途绿龟嚎哮迷茫”

——《炸脖龙之诗》

![](https://cdn.luogu.com.cn/upload/pic/21111.png)

我喊了出来...却不成人话

只能，像在水中一边融化一边下沉的方糖一样...

失去自己的轮廓...一直沉向最低处

想要爬上去的子午

维持自己是自己的连续体...

溶解的渐渐七零八落的意识...

失去了用来挣扎的双手

失去了用来挣扎的双臂

向下，

向下，

一直沉下去

向着意识的底层

沉陷下去的自我...

逐渐消失的世界...

我看到了世界

失落的...世界...

![](https://cdn.luogu.com.cn/upload/pic/21112.png)

```plain

   回归天空的话我就可以成为      了

  开什么玩笑，你才不是什么      ！

  吵死了！吵死了！我是      ！而且生来就是！

就是因为这个家伙我才失去      的资格的！

 呜呜呜，由岐姐姐，由岐姐姐！

  ...怎么会...由岐姐...

 卓司！你这家伙！

        吵死了吵死了！像你这样的普通人懂些什么！

   由岐的血慢慢在冰凉的水泥地上扩散开来

   抱在怀里的      在渐渐地流出来        本应成为      而出生

的我的被      妨碍了！

不出生的话我就没法拯救是这个世界！

            所以预言者说能当世界回归天空的此处就是尽头

   只要      回归天空的话！

 我有这么可怕吗？

              因为我是要对一切生物下达审判的存在！

       因为哥哥是凡人呢

    凡人与天才

                            救世主

   世界

                    救世主

                回天之门

  要死的是你！

            我不会死               不会死       诅咒你

       要死的是羽咲

         只要羽咲死了

                  间宫              皆

                                    守           由

                         岐

                                间宫羽咲

                          可能性

                                    和镜

                     终

                   终之空

                     空

```

![](https://cdn.luogu.com.cn/upload/pic/21113.png)

一个婴儿出生了

谁的？

不知道


虽然不知道...
但确实有一个婴儿出生了

嗯...那个婴儿在哭...

呜嘎，呜嘎，地哭着...

听到这个哭声大家都笑了

大家都在为婴儿祝福

母亲也是...

父亲也是...

并且其他人也是...

为那个婴儿的出生...

衷心祝福

世界充满着生命的祝福

但是

但不是这样的

在那里

我

我一个人在那里恐惧着

非常恐惧...

要说为什么的话...

因为那是在对世界进行诅咒

没错...

他在诅咒着那个世界，那个刚出生的婴儿

诅咒着自己的出生

我

我当场全身僵硬

在大家的笑容之中

在祝福之中

独自一人...

我啊...

我摇摇晃晃地...

接近那个婴儿

然后想要让那个婴儿停止哭泣

我想着必须要那样做才行

为什么呢？

我自己也不明白...

那是

那是，自从出生以来

就悲惨地活到今天的我能做到的

我能做到的

唯一的

唯一的赎罪啊。

![](https://cdn.luogu.com.cn/upload/pic/21114.png)

让我在这里了结了你吧…间宫卓司

这里是终之空的下面吧…这不刚好吗

跟我们的终结很相称不是吗…

这里，是只对你而言的，终结的天空…

这里就是终焉之地…

![](https://cdn.luogu.com.cn/upload/pic/21115.png)

“不行！绝对不行！”

…为什么…跟过来了…

![](https://cdn.luogu.com.cn/upload/pic/21116.png)

预定…调和吗…

原来如此…看来不管怎样对于你来说…我都已经毫无任何价值了对吧…

竟然被这家伙打倒了…真是没办法呐…

这也是现实吗…

那就接受吧…

![](https://cdn.luogu.com.cn/upload/pic/21117.png)

不知为何，我好像看到了在夜空中挺立的向日葵…

只有一瞬间…

那株向日葵…

好像在某个地方…

向日葵…

跟羽咲一起…

是啊…

我是哥哥啊…

要是…能再多当当她的哥哥就好了……

![](https://cdn.luogu.com.cn/upload/pic/21119.png)

咦……

刚才的…

那个是…那片风景…

是吗…那片风景…

我也是知道的啊…

在坡道途中的向日葵…

蔚蓝的天空和向日葵。

漂浮着大大的云朵…

羽咲戴着大大的帽子…

然后跟我走在一起…

走着走着…

为了…

两人一起…

爬上那个坡道…

因为…那个坡道的前面有很漂亮的景色…

## 题目描述

您正在打 galgame，然后您觉得这个 gal 不知所云，于是您弃坑了，开始写数据结构题：

给一个长为 $n$ 的序列，$m$ 次操作，每次操作：

1. 区间 $[l,r]$ 加 $x$；
2. 对于区间 $[l,r]$，查询：

$$a[l]^{a[l+1]^{a[l+2]^{\dots ^{a[r]}}}} \mod p$$

## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477

对于100%的数据，$n , m \le 500000$ , 序列中每个数在$[1,2\cdot 10^9]$内，$p \le 2 \cdot 10^7 $, 每次加上的数在$[0,2\cdot 10^9]$内

共10组数据


## 样例 #1

### 输入

```
6 4
1 2 3 4 5 6
2 1 2 10000007
2 2 3 5
1 1 4 1
2 2 4 10
```

### 输出

```
1
3
1```

## 样例 #2

### 输入

```
5 5
2 3 3 3 3
1 1 1 530739835
2 1 1 8356089
2 1 4 5496738
1 1 2 66050181
1 2 4 138625417
```

### 输出

```
4306230
697527
```

# AI分析结果



---

# 💡 Kay的C++算法解析：[Ynoi Easy Round 2016] 炸脖龙 I 深入学习指南 💡

<introduction>
今天我们要挑战的是Ynoi中的经典题目“炸脖龙 I”。这道题结合了区间修改和连指数模运算的复杂问题，需要我们灵活运用扩展欧拉定理和树状数组等数据结构。让我们一起拆解问题，掌握核心思路！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（扩展欧拉定理应用）+ 树状数组/线段树`

🗣️ **初步分析**：
解决这道题的关键在于理解扩展欧拉定理的递归应用，以及如何高效维护区间修改。扩展欧拉定理告诉我们，对于大指数的模运算，可以通过不断取欧拉函数来降幂。简单来说，扩展欧拉定理允许我们将 $a^b \mod p$ 转换为 $a^{b \mod \varphi(p) + \varphi(p)} \mod p$（当 $b \geq \varphi(p)$ 时），其中 $\varphi(p)$ 是欧拉函数。这一过程最多递归 $\log p$ 次，因为每次 $\varphi(p)$ 的值至少减半。

在本题中，我们需要处理区间加操作（用树状数组高效维护）和连指数查询（递归应用扩展欧拉定理）。核心难点在于：
1. 如何判断递归过程中指数是否大于当前的 $\varphi(p)$；
2. 如何高效处理区间修改与单点查询；
3. 递归终止条件的边界处理（如模数为1、区间长度为1等）。

**可视化设计思路**：我们将用8位像素风格动画演示递归过程。例如，用不同颜色的像素块表示数组元素，树状数组的区间加操作通过方块颜色渐变展示；递归计算时，用层级展开的方式显示模数从 $p \rightarrow \varphi(p) \rightarrow \varphi(\varphi(p)) \rightarrow ... \rightarrow 1$ 的过程，关键步骤（如指数超过 $\varphi(p)$ 时的加 $\varphi(p)$ 操作）用闪烁高亮。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性、算法有效性等维度评估，以下题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：Leap_Frog的题解**  
* **点评**：此题解详细解释了扩展欧拉定理的应用，递归处理连指数的逻辑非常清晰。代码中使用树状数组维护区间加，通过重定义 `[]` 操作符优化常数。亮点在于暴力检查前5位元素是否为1（避免无效递归），以及快速幂中对取模的严格处理。实践价值高，代码可直接用于竞赛。

**题解二：NaCly_Fish的题解**  
* **点评**：此题解用结构体 `node` 记录指数是否超过 $\varphi(p)$，明确区分了两种情况（指数是否加 $\varphi(p)$），逻辑直观。树状数组的实现简洁，快速幂函数中通过标记 `flag` 记录是否需要加 $\varphi(p)$，代码可读性强，适合初学者理解。

**题解三：zcysky的题解**  
* **点评**：此题解结合了暴力处理前几位元素的优化（如找到第一个1的位置），减少了递归次数。线段树的实现虽然常数稍大，但思路明确，适合理解区间修改与单点查询的不同数据结构选择。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决本题时，以下三个关键点需要特别注意：
</difficulty_intro>

1.  **关键点1：扩展欧拉定理的递归应用**  
    * **分析**：递归计算连指数时，每次需要将模数替换为 $\varphi(p)$，直到模数为1。关键是判断当前指数是否大于 $\varphi(p)$，这决定了是否需要加 $\varphi(p)$。优质题解通常通过暴力检查前5位元素（或第一个1的位置）来判断，因为连指数增长极快，前5位足够覆盖大部分情况。  
    * 💡 **学习笔记**：连指数增长极快，暴力检查前几位可有效减少递归深度。

2.  **关键点2：区间修改与单点查询的高效维护**  
    * **分析**：区间加操作需要高效的数据结构，树状数组（或线段树）是首选。树状数组通过差分实现区间加和单点查询，时间复杂度为 $O(\log n)$，适合本题的大规模数据。  
    * 💡 **学习笔记**：树状数组适合处理区间加、单点查询，代码简洁且常数小。

3.  **关键点3：递归终止条件的边界处理**  
    * **分析**：当模数为1时，任何数模1结果为0；当区间长度为1时，直接返回该数模当前模数；当元素为1时，连指数结果恒为1。这些边界条件需在递归中严格处理，避免死循环或错误。  
    * 💡 **学习笔记**：边界条件是递归正确性的关键，需逐一验证。

### ✨ 解题技巧总结
- **暴力检查优化**：检查区间前5位或第一个1的位置，快速判断指数是否超过 $\varphi(p)$。
- **树状数组的差分技巧**：通过差分将区间加转换为两次单点加，简化实现。
- **预处理欧拉函数**：线性筛预处理所有可能的 $\varphi(p)$，避免重复计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的核心代码实现，结合了树状数组和扩展欧拉定理的递归处理，结构清晰且高效。
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：此代码综合了Leap_Frog和NaCly_Fish的题解思路，使用树状数组维护区间加，递归结合扩展欧拉定理处理查询，适合竞赛环境。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 500005;
const int M = 20000005;

int n, m;
ll c[N]; // 树状数组
int phi[M], prime[M / 10];
bool vis[M];
int tot;

// 树状数组操作
inline int lowbit(int x) { return x & -x; }
inline void add(int x, ll y) { for (; x <= n; x += lowbit(x)) c[x] += y; }
inline ll query(int x) { ll res = 0; for (; x; x -= lowbit(x)) res += c[x]; return res; }

// 预处理欧拉函数
void get_phi() {
    phi[1] = 1;
    for (int i = 2; i < M; i++) {
        if (!vis[i]) prime[++tot] = i, phi[i] = i - 1;
        for (int j = 1; j <= tot && i * prime[j] < M; j++) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            } else phi[i * prime[j]] = phi[i] * (prime[j] - 1);
        }
    }
}

// 快速幂，返回 (结果, 是否超过mod)
pair<int, bool> ksm(ll a, ll b, int mod) {
    int res = 1;
    bool flag = false;
    if (a >= mod) { a %= mod; flag = true; }
    while (b) {
        if (b & 1) {
            res = (ll)res * a;
            if (res >= mod) { flag = true; res %= mod; }
        }
        a = (ll)a * a;
        if (a >= mod) { flag = true; a %= mod; }
        b >>= 1;
    }
    return {res, flag};
}

// 递归计算连指数模p
int solve(int l, int r, int p) {
    if (p == 1) return 0;
    ll a = query(l);
    if (a == 1) return 1 % p;
    if (l == r) return a % p + (a >= p ? p : 0);
    auto [val, flag] = solve(l + 1, r, phi[p]);
    int exponent = val + (flag ? phi[p] : 0);
    auto [res, _] = ksm(a, exponent, p);
    return res;
}

int main() {
    get_phi();
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; i++) {
        ll x; scanf("%lld", &x);
        add(i, x);
        add(i + 1, -x);
    }
    while (m--) {
        int op, l, r, x;
        scanf("%d%d%d%d", &op, &l, &r, &x);
        if (op == 1) {
            add(l, x);
            add(r + 1, -x);
        } else {
            printf("%d\n", solve(l, r, x) % x);
        }
    }
    return 0;
}
```
* **代码解读概要**：代码首先预处理欧拉函数（`get_phi`），然后用树状数组维护区间加（`add`和`query`）。核心函数`solve`递归计算连指数模，利用扩展欧拉定理降幂，快速幂函数`ksm`返回结果及是否超过模数的标记，确保指数正确处理。

---

<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：Leap_Frog的递归处理片段**  
* **亮点**：暴力检查前5位元素是否为1，优化递归深度。  
* **核心代码片段**：
```cpp
int ren(int l,int r,int P) {
    if(a[l]%P==0) return 0;
    else if(P==1) return 1;
    else if(l==r) return a[l]%P+(a[l]>=P?P:0);
    int ls=min(l+5,r);
    for(int i=l+1;i<=ls;i++) if(a[i]==1) {ls=i;break;}
    ll g=0,la=a[ls];
    for(int i=ls-1;i>=l+1;i--) {
        g=la,la=1;
        while(g--) {
            la*=a[i];
            if(la>ph[P]) return ksm(a[l],ren(l+1,r,ph[P])+ph[P],P);
        }
    }
    return ksm(a[l],la,P);
}
```
* **代码解读**：`ls` 取区间前5位或第一个1的位置，暴力计算这些元素的连指数，若超过当前模数的欧拉函数值（`ph[P]`），则递归处理；否则直接计算快速幂。  
* 💡 **学习笔记**：暴力检查前几位可避免不必要的递归，提升效率。

**题解二：NaCly_Fish的结构体标记片段**  
* **亮点**：用结构体记录指数是否超过模数，逻辑清晰。  
* **核心代码片段**：
```cpp
struct node {
    int val;
    bool flag;
    node(int val=0,bool flag=false):val(val),flag(flag){}
};

node solve(int l,int r,int p) {
    if(p==1) return node(0, true);
    if(a[l]==1) return node(1, false);
    if(l==r) return a[l]<p?node(a[l], false):node(a[l]%p, true);
    node res = solve(l+1, r, phi[p]);
    if(res.flag) res.val += phi[p];
    return power(a[l], res.val, p);
}
```
* **代码解读**：`node` 结构体保存结果和是否超过模数的标记。递归时根据标记决定是否加 $\varphi(p)$，确保扩展欧拉定理的正确应用。  
* 💡 **学习笔记**：结构体标记是处理复杂条件判断的有效方法。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解递归过程和树状数组操作，我们设计了一个8位像素风格的动画，模拟连指数模计算和区间加操作。
</visualization_intro>

  * **动画演示主题**：`连指数大冒险——复古像素风`  
  * **核心演示内容**：展示树状数组的区间加操作（方块颜色变化）、递归计算连指数时模数的层级变化（从 $p$ 到 $\varphi(p)$ 到 $1$），以及关键步骤（如指数超过 $\varphi(p)$ 时的加 $\varphi(p)$ 操作）。

  * **设计思路简述**：8位像素风格营造轻松氛围，通过颜色渐变（如绿色表示正常，红色表示超过模数）和闪烁高亮关键步骤，帮助理解数据变化。音效（如“叮”声提示加操作，“咚”声提示递归层级）增强记忆。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：像素网格显示数组元素（蓝色方块），控制面板包含“单步”“自动播放”按钮和速度滑块。
    2. **区间加操作**：选择区间 $[l,r]$，输入增量 $x$，对应方块颜色渐变（如从蓝变绿），树状数组的差分更新用箭头动画展示。
    3. **递归计算连指数**：从 $p$ 开始，每递归一层，模数变为 $\varphi(p)$（用层级展开的文本显示），当前处理的元素用黄色高亮。若指数超过 $\varphi(p)$，触发闪烁动画并播放“叮”声。
    4. **终止条件**：当模数为1时，所有方块变灰色，显示结果为0；当区间长度为1时，对应方块放大显示结果。
    5. **结果展示**：最终结果用金色字体显示，伴随“胜利”音效。

  * **旁白提示**：
    - “现在对区间 $[l,r]$ 进行加操作，树状数组正在更新差分...”
    - “递归到第2层，当前模数是 $\varphi(p)=...$，检查指数是否超过它。”
    - “指数超过 $\varphi(p)$，需要加 $\varphi(p)$ 后再取模！”

<visualization_conclusion>
通过这样的动画，我们能直观看到树状数组如何维护区间加，以及递归过程中模数的变化，理解扩展欧拉定理的应用细节。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可通过以下题目巩固扩展欧拉定理和树状数组的应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：扩展欧拉定理适用于大指数模运算，树状数组适用于区间加、单点查询。类似场景包括：
    1. 计算超长幂塔的模（如洛谷P3747）；
    2. 区间修改后查询复杂函数（如区间异或和）；
    3. 动态维护数列的特定统计量（如区间最值）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3747 [六省联考2017] 相逢是问候**：扩展欧拉定理与树状数组的深度结合，挑战递归终止条件的处理。  
    2.  **洛谷 P4139 上帝与集合的正确用法**：经典扩展欧拉定理应用，练习递归计算无限幂塔模。  
    3.  **洛谷 P5091 扩展欧拉定理**：模板题，巩固扩展欧拉定理的基本应用。

---

## 7. 学习心得与经验分享

<insights_intro>
部分题解作者提到调试时的经验：
</insights_intro>

> （来自Leap_Frog）“在快速幂中，若底数本身大于模数，需先取模并标记。一开始忘记处理这种情况，导致测试样例错误。”

**点评**：快速幂中底数的预处理（如取模并标记是否超过模数）是关键。这提醒我们在编写代码时，需严格处理所有可能的边界情况，避免因小疏漏导致错误。

---

<conclusion>
“炸脖龙 I”是一道结合数学与数据结构的综合题，核心在于扩展欧拉定理的递归应用和树状数组的高效维护。通过理解递归逻辑、掌握边界条件，以及多做类似练习，相信你能轻松应对这类问题！下次挑战更难的题目吧，加油！💪
</conclusion>

---
处理用时：159.61秒
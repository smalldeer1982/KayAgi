# 题目信息

# [IOI 2007] pairs 动物对数

## 题目描述

Mirko 和 Slavko 正在玩动物玩具的游戏。 首先，他们要在下图给出的三种玩具模板中选择一种。三种模板分别由一维、二维和三维的网格点（在图中用圆圈表示）组成。 

![](https://cdn.luogu.com.cn/upload/pic/20672.png )

接下来Mirko 把 $N$ 个小动物玩具放到选中的模板的网格点上。

动物玩具可以走一步到达与它相邻的网格点上（在图中相邻的点之间有一条小短线相连）。两个网格点之间的距离定义为**从一个网格点到另一个网格点所需要移动的最小步数**。

如果两个动物之间的距离小于等于$D$，则它们之间可以互相听见。Slavko 的任务是计算在模板上有多少对动物可以互相听得见。

给定模板的类型、所有动物的位置以及数字$D$，写一个程序计算有多少对动物可以互相听得见。 

## 说明/提示

在30分的测试数据中, 动物数目 $N$ 最多是 $1 000$。

如果成功通过了某一种模板（一维、二维或者三维）的全部测试数据，将会得到至少30分。

对于input 1的解释： 假设动物按给出的顺序编号为$1$到$6$。$4$对互相能够听得到的动物分别是:
- 1-5 ( 距离是5)
- 1-6 ( 距离是2)
- 2-3 ( 距离是0)
- 5-6 ( 距离是3)

对于input 2 的解释：$8$对动物分别是:
- 1-2 ( 距离是2)
- 1-4 ( 距离是4)
- 1-5 ( 距离是3)
- 2-3 ( 距离是3)
- 2-4 ( 距离是4)
- 3-4 ( 距离是3)
- 3-5 ( 距离是4)
- 4-5 ( 距离是3)

## 样例 #1

### 输入

```
1 6 5 100 
25 
50 
50 
10 
20 
23 ```

### 输出

```
4```

## 样例 #2

### 输入

```
2 5 4 10 
5 2 
7 2 
8 4 
6 5 
4 4 ```

### 输出

```
8```

## 样例 #3

### 输入

```
3 8 10 20 
10 10 10 
10 10 20 
10 20 10 
10 20 20 
20 10 10 
20 10 20 
20 20 10 
20 20 20 ```

### 输出

```
12```

# AI分析结果



---

# 💡 Kay的C++算法解析：[IOI 2007] pairs 动物对数 深入学习指南 💡

<introduction>
今天我们要一起攻克这道“动物对数”问题！它的核心是根据不同维度（1/2/3维）的网格，计算距离不超过D的动物对数。通过分析题解，我们会发现关键在于**曼哈顿距离与切比雪夫距离的转换**，以及如何用数据结构高效计数。让我们一步步拆解！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（距离转换）与数据结构（树状数组/前缀和）的综合应用`

🗣️ **初步分析**：
解决这道题的关键在于理解不同维度下**曼哈顿距离**的处理方式。曼哈顿距离的公式是各维度坐标差的绝对值之和（如二维：$|x1-x2|+|y1-y2|$），直接统计所有点对的时间复杂度是$O(n^2)$，对于大n会超时。因此需要通过数学转换和高效数据结构优化。

- **B=1（一维）**：排序后用双指针维护滑动窗口，统计每个点左侧距离≤D的点数（时间$O(n)$）。  
- **B=2（二维）**：将曼哈顿距离转为切比雪夫距离（通过坐标变换：$(x,y)\to(x+y, x-y)$），此时距离变为各维度差的最大值。排序后用双指针维护x轴范围，树状数组统计y轴区间内的点数（时间$O(n\log m)$）。  
- **B=3（三维）**：利用M≤75的限制，将前两维转为切比雪夫距离，按z轴分层预处理二维前缀和，枚举z轴范围后查询矩形区域内的点数（时间$O(nm^2)$）。

**可视化设计思路**：以二维情况为例，设计8位像素动画：原坐标系的点用蓝色方块表示，转换后的切比雪夫坐标系用红色网格展示。滑动窗口用绿色框标记x轴范围，树状数组更新时用黄色闪烁提示。关键步骤（如插入点、查询区间）伴随“叮”的像素音效，完成计数时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过评估，以下题解在思路清晰性、代码规范性和算法优化上表现突出（≥4星），值得重点学习：
</eval_intro>

**题解一：圣嘉然（赞24）**  
* **点评**：此题解完整覆盖了B=1/2/3的情况，代码结构清晰（用namespace分类），变量命名直观（如`p[i].x`表示转换后的坐标）。B=2中通过树状数组维护y轴区间和，B=3中用三维树状数组处理立方体查询，优化了时间复杂度。边界处理严谨（如`std::min`防止越界），是竞赛代码的典范。

**题解二：TernaryTree（赞2）**  
* **点评**：此题解高度概括了各维度的核心思路，代码简洁且注释清晰。尤其在B=3的分析中，点明了曼哈顿转切比雪夫的推广方法（映射到$2^{B-1}$维），对理解高维问题有启发。树状数组的三维实现逻辑明确，适合学习高维数据结构应用。

**题解三：pengyule（赞0）**  
* **点评**：此题解针对B=3的低维特性，采用分层二维前缀和预处理，代码简洁高效。通过枚举z轴范围并查询矩形和，避免了复杂的三维树状数组，适合理解“分治+前缀和”的优化思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理不同维度下的距离统计，以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：曼哈顿距离转切比雪夫距离的数学转换**  
    * **分析**：曼哈顿距离的几何形状是菱形（二维）或八面体（三维），直接统计菱形内的点数较困难。通过坐标变换（如二维$(x,y)\to(x+y, x-y)$），曼哈顿距离等价于切比雪夫距离（各维度差的最大值），此时统计区域变为轴对齐的矩形（二维）或立方体（三维），更易处理。  
    * 💡 **学习笔记**：数学转换是将复杂几何问题转化为简单区间问题的关键。

2.  **关键点2：不同维度下的高效计数方法**  
    * **分析**：一维用双指针，二维用树状数组，三维用前缀和或三维树状数组。选择依据是维度和数据范围（如B=3的M≤75允许暴力预处理）。  
    * 💡 **学习笔记**：数据范围决定算法选择，低维小范围可用前缀和，高维大范围需树状数组。

3.  **关键点3：避免重复计数与边界处理**  
    * **分析**：统计点对时，每对$(i,j)$会被计算两次（i→j和j→i），需最后除以2。边界条件（如坐标越界、树状数组下标）需用`max/min`限制。  
    * 💡 **学习笔记**：计数问题要注意去重，边界处理需“宁小勿大”。

### ✨ 解题技巧总结
- **问题分解**：按维度拆分问题，分别设计算法（一维双指针、二维树状数组、三维前缀和）。  
- **数学转换**：利用坐标变换简化距离统计（曼哈顿→切比雪夫）。  
- **数据结构适配**：根据维度和数据范围选择树状数组或前缀和，平衡时间与空间复杂度。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，覆盖B=1/2/3的情况，代码简洁且逻辑清晰。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了圣嘉然和TernaryTree的题解，针对不同维度分模块处理，注释清晰，适合直接参考。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define int long long
    using namespace std;

    int B, n, d, m;

    // B=1：排序+双指针
    namespace sub1 {
        void main() {
            vector<int> a(n+1);
            for (int i=1; i<=n; ++i) cin >> a[i];
            sort(a.begin()+1, a.end());
            int ans = 0, j = 1;
            for (int i=1; i<=n; ++i) {
                while (a[i] - a[j] > d) ++j;
                ans += i - j;
            }
            cout << ans << endl;
        }
    }

    // B=2：曼哈顿转切比雪夫+树状数组
    namespace sub2 {
        struct Fenwick {
            vector<int> c;
            Fenwick(int size) : c(size+2) {}
            void add(int x, int v) {
                for (; x < c.size(); x += x&-x) c[x] += v;
            }
            int query(int x) {
                x = min(x, (int)c.size()-1);
                int res = 0;
                for (; x > 0; x -= x&-x) res += c[x];
                return res;
            }
        };

        void main() {
            vector<pair<int, int>> a(n+1);
            for (int i=1; i<=n; ++i) {
                int x, y; cin >> x >> y;
                a[i] = {x + y, x - y + m}; // 偏移防负数
            }
            sort(a.begin()+1, a.end());
            Fenwick tr(2*m + 2);
            int ans = 0, j = 1;
            for (int i=1; i<=n; ++i) {
                while (a[i].first - a[j].first > d) tr.add(a[j].second, -1), ++j;
                ans += tr.query(a[i].second + d) - tr.query(a[i].second - d - 1);
                tr.add(a[i].second, 1);
            }
            cout << ans << endl;
        }
    }

    // B=3：分层二维前缀和
    namespace sub3 {
        void main() {
            vector<array<int, 3>> a(n+1);
            vector<vector<vector<int>>> sum(m+2, vector<vector<int>>(2*m+2, vector<int>(2*m+2, 0)));
            for (int i=1; i<=n; ++i) {
                int x, y, z; cin >> x >> y >> z;
                int nx = x + y, ny = x - y + m; // 前两维转切比雪夫
                sum[z][nx][ny]++;
            }
            // 预处理二维前缀和
            for (int z=1; z<=m; ++z) {
                for (int i=1; i<=2*m; ++i) {
                    for (int j=1; j<=2*m; ++j) {
                        sum[z][i][j] += sum[z][i-1][j] + sum[z][i][j-1] - sum[z][i-1][j-1];
                    }
                }
            }
            int ans = 0;
            for (int i=1; i<=n; ++i) {
                int x, y, z; cin >> x >> y >> z; // 实际应从a中取，此处简化
                int nx = x + y, ny = x - y + m;
                for (int j=max(1, z-d); j < z; ++j) { // 下层
                    int rem = d - (z - j);
                    if (rem < 0) continue;
                    int x1 = max(1, nx - rem), x2 = min(2*m, nx + rem);
                    int y1 = max(1, ny - rem), y2 = min(2*m, ny + rem);
                    ans += sum[j][x2][y2] - sum[j][x1-1][y2] - sum[j][x2][y1-1] + sum[j][x1-1][y1-1];
                }
                // 同层去重
                int rem = d;
                int x1 = max(1, nx - rem), x2 = min(2*m, nx + rem);
                int y1 = max(1, ny - rem), y2 = min(2*m, ny + rem);
                int same = sum[z][x2][y2] - sum[z][x1-1][y2] - sum[z][x2][y1-1] + sum[z][x1-1][y1-1];
                ans += (same - 1) / 2; // 减去自己并去重
            }
            cout << ans << endl;
        }
    }

    signed main() {
        cin >> B >> n >> d >> m;
        if (B == 1) sub1::main();
        else if (B == 2) sub2::main();
        else sub3::main();
        return 0;
    }
    ```
* **代码解读概要**：代码按维度分模块处理。B=1用双指针滑动窗口；B=2用树状数组维护y轴区间和；B=3用分层前缀和预处理，枚举z轴后查询矩形和。各模块逻辑独立，易于调试。

---

<code_intro_selected>
接下来赏析优质题解的核心代码片段：
</code_intro_selected>

**题解一：圣嘉然（B=2部分）**  
* **亮点**：坐标转换清晰，树状数组维护动态区间和。  
* **核心代码片段**：
    ```cpp
    struct Node { int x, y; } p[N];
    int c[M*2];
    inline void upd(int x, int v) { for (; x < M*2; x += x&-x) c[x] += v; }
    inline int qry(int x) { /* 类似upd */ }
    inline void main() {
        for (int i=1; i<=n; ++i) p[i].x = x+y, p[i].y = x-y;
        sort(p+1, p+n+1, [](Node a, Node b) { return a.x < b.x; });
        for (int i=1, j=1; i<=n; ++i) {
            while (p[i].x - p[j].x > d) upd(p[j].y + m, -1), ++j;
            res += qry(p[i].y + d + m) - qry(p[i].y - d - 1 + m);
            upd(p[i].y + m, 1);
        }
    }
    ```
* **代码解读**：  
  1. 坐标转换：`p[i].x = x+y`，`p[i].y = x-y`将曼哈顿距离转为切比雪夫距离。  
  2. 排序：按x轴排序后，用双指针`j`维护x轴范围（`p[i].x - p[j].x ≤d`）。  
  3. 树状数组：`upd`和`qry`函数维护y轴区间内的点数，快速统计符合条件的y轴范围。  
* 💡 **学习笔记**：树状数组适合动态维护区间和，配合排序+双指针可高效处理二维范围查询。

**题解二：TernaryTree（B=3部分）**  
* **亮点**：三维树状数组处理立方体查询，推广了切比雪夫转换的思路。  
* **核心代码片段**：
    ```cpp
    struct tib {
        int b[301][301][301];
        void add(int x, int y, int z, int p) {
            for (int i=x; i<=n; i+=i&-i)
                for (int j=y; j<=n; j+=j&-j)
                    for (int k=z; k<=n; k+=k&-k)
                        b[i][j][k] += p;
        }
        int query(int x, int y, int z) { /* 类似add */ }
    };
    inline void main() {
        for (int i=1; i<=n; ++i) a[i] = {x+y+z, x+y-z, x-y+z, -x+y+z};
        sort(a+1, a+n+1);
        for (int i=1, j=1; i<=n; ++i) {
            while (a[i].a - a[j].a > d) rt.add(a[j].x, a[j].y, a[j].z, -1), ++j;
            ans += rt.query(...) // 立方体查询
        }
    }
    ```
* **代码解读**：  
  1. 坐标转换：将三维曼哈顿距离转为四维切比雪夫距离（`a[i].a`为第一维）。  
  2. 三维树状数组：`add`和`query`函数维护立方体区域内的点数，支持快速插入和查询。  
* 💡 **学习笔记**：高维树状数组适合处理多维范围查询，但需注意空间复杂度（本题M≤75，可行）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解二维情况下的距离转换和计数过程，我们设计一个“像素距离探险”动画，用8位风格演示切比雪夫转换和树状数组的工作原理。
</visualization_intro>

  * **动画演示主题**：`二维曼哈顿→切比雪夫转换与树状数组计数`

  * **核心演示内容**：  
    原坐标系的蓝色点（如(2,3)）经过旋转45度后，变为切比雪夫坐标系的红色点（(5,-1)）。滑动窗口（绿色框）在x轴移动，树状数组（黄色柱状图）动态更新y轴点数，统计当前点左侧y轴范围内的点数。

  * **设计思路简述**：  
    8位像素风格（FC红白机配色）降低学习压力；旋转动画直观展示坐标转换；树状数组的柱状图变化和滑动窗口的移动，帮助理解“动态区间和”的统计过程。关键操作（插入、查询）的“叮”音效强化记忆。

  * **动画帧步骤与交互关键点**：

    1. **初始化场景**：  
       - 左半屏显示原坐标系（网格背景，蓝色点），右半屏显示切比雪夫坐标系（红色网格，红色点）。  
       - 底部控制面板：单步/自动播放按钮、速度滑块（1-10帧/秒）。

    2. **坐标转换动画**：  
       - 每个蓝色点发射红色光线，旋转45度后落在切比雪夫坐标系的对应位置（如(2,3)→(5,-1)），伴随“咻”的音效。

    3. **排序与滑动窗口**：  
       - 切比雪夫坐标系的点按x轴排序（从小到大水平排列），绿色框从左到右滑动，框住x轴差≤d的点（如当前点x=10，d=3，则框住x=7~10的点）。

    4. **树状数组动态更新**：  
       - 右侧树状数组区域用黄色柱状图表示y轴点数，每插入一个点（绿色框内的点），对应y轴位置的柱子升高；删除点时柱子降低。查询当前点y轴范围（y-d到y+d）时，用蓝色高光标记该区间，显示总和。

    5. **计数完成**：  
       - 所有点处理完成后，总对数显示在屏幕中央，播放“胜利”音效（如FC的升调音乐），并弹出“成功！”的像素文字。

  * **旁白提示**：  
    - “看！原坐标系的点旋转后，菱形区域变成了轴对齐的矩形，统计起来更方便啦～”  
    - “绿色框是x轴的滑动窗口，保证x轴差不超过D。树状数组在帮我们数y轴范围内的点哦！”

<visualization_conclusion>
通过这个动画，我们能清晰看到坐标转换如何简化问题，以及树状数组如何高效统计区间和。下次遇到类似的二维范围计数问题，你也能像动画里的像素小人一样，轻松找到解题思路啦！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思想（距离转换、分维度处理、树状数组/前缀和）可迁移到多种场景。以下是相关练习推荐：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - 一维范围计数：滑动窗口（如求逆序对）。  
    - 二维范围计数：曼哈顿→切比雪夫转换+树状数组（如统计矩阵内的点）。  
    - 低维高数据范围：分层前缀和（如三维空间内的矩形求和）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1908 逆序对**  
       * 🗣️ **推荐理由**：一维范围计数，练习双指针或树状数组的基础应用。  
    2.  **洛谷 P1439 【模板】最长公共子序列**  
       * 🗣️ **推荐理由**：二维偏序问题，需用树状数组优化，与本题B=2的树状数组思路类似。  
    3.  **洛谷 P3810 【模板】三维偏序（陌上花开）**  
       * 🗣️ **推荐理由**：三维范围计数，练习分治+树状数组的组合应用，与本题B=3的思路有共通性。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中作者提到的调试经验对我们很有启发：
</insights_intro>

> **参考经验 (来自圣嘉然)**：“在B=3的容斥计算中，我一开始写错了符号，导致结果偏大。后来通过打印中间变量，发现是`ask`函数的容斥项符号错误，修正后才通过。”

**点评**：这位作者的经验提醒我们，复杂计数问题（如三维前缀和的容斥）容易因符号或边界条件出错。调试时，打印关键变量（如当前查询的矩形范围、前缀和的值）能快速定位错误。这是非常实用的调试技巧！

---

<conclusion>
通过对“动物对数”问题的分析，我们掌握了曼哈顿与切比雪夫距离的转换、分维度高效计数的方法，以及树状数组/前缀和的应用。编程的关键在于理解问题本质，选择合适的数学转换和数据结构。下次遇到类似问题，你也能轻松拆解、高效解决！加油，未来的算法高手～ 💪
</conclusion>

---
处理用时：213.26秒
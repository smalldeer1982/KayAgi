# 题目信息

# 「PMOI-1」中位数

## 题目描述

给定一棵以 $1$ 为根的包含 $n$ 个节点的**有根树**。第 $i$ 个节点有点权 $a_i$。

定义函数 $f(u,v)$ 表示从 $u$ 到 $v$ 经过的所有节点的点权的**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\frac{t+1}2\right\rceil$ 小的数。

定义函数 $\text{cover}(x_1,y_1,x_2,y_2)$ 表示从 $x_1$ 到 $y_1$ 的路径是否完全覆盖了从 $x_2$ 到 $y_2$ 的路径。如果完全覆盖，则 $\text{cover}(x_1,y_1,x_2,y_2)=1$，否则 $\text{cover}(x_1,y_1,x_2,y_2)=0$。

你需要依次处理 $q$ 次操作，按照以下格式给出：

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ **异或**；

`2 u v`：表示一次询问，需要你求出 $\max\limits_{1\le i\le n,1\le j\le n}\{\text{cover}(i,j,u,v)f(i,j)\}$。

对于第二类操作，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

你需要对于每个第二类操作，输出对应的值。

## 说明/提示

【样例解释】

第一次是询问。显然，只有 $(i=4,j=8)$ 满足 $\text{cover}(i,j,u,v)=1$。此时 $f(i,j)=3$。

第二次是操作。将 $3$ 号节点的点权改为了 $2$。

第三次是询问。当 $i=4,j=3$ 时，$\text{cover}(i,j,u,v)=1$ 且 $f(i,j)=4$。不难发现，对于其他所有满足 $\text{cover}(i,j,u,v)=1$ 的节点对 $(i,j)$，均没有 $f(i,j)>4$。

【数据范围】
- Subtask 1（8 pts）：$n,q\le50$；
- Subtask 2（12 pts）：$n,q\le2\times10^3$；
- Subtask 3（16 pts）：$n,q\le4\times10^4$；
- Subtask 4（10 pts）：保证树的形态随机生成；
- Subtask 5（12 pts）：保证没有 $1$ 操作；
- Subtask 6（12 pts）：保证每次询问的 $u,v$ 都是叶子节点；
- Subtask 7（30 pts）：无特殊限制。

Subtask 4 的随机方式为：随机生成一个的排列 $p$，对于 $i\in[2,n]$，$p_i$ 向 $p_1,p_2,...,p_{i-1}$ 中等概率随机的一个点连边。

对于 $100\%$ 的数据满足，$1\le n,q,a_i \le 10^5$，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

## 样例 #1

### 输入

```
8 3
4 2 3 4 2 1 4 3
1 2
1 3
2 4
2 5
3 6
6 7
6 8
2 4 8
1 3 
2 2 3```

### 输出

```
3
4```

# AI分析结果

# 💡 Kay的C++算法解析：「PMOI-1」中位数 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分答案 + 可持久化线段树（主席树） + 树路径处理


🗣️ **初步分析**：  
解决“中位数”这道题，关键在于**将中位数问题转化为前缀和判断**，并利用**主席树维护树路径的历史状态**。简单来说，中位数的定义（第⌈(t+1)/2⌉小）可以转化为：**寻找最大的mid，使得路径中≥mid的元素数量≥<mid的元素数量**（即前缀和≥0）。而覆盖u-v路径的i-j路径，必须满足i在u的子树、j在v的子树（因为u和v无祖先关系），因此需要**子树查询最大值**。  

- **核心思路**：  
  1. 二分答案mid，判断是否存在满足条件的i-j路径（前缀和≥0）；  
  2. 用主席树维护每个节点到根的前缀和（权值≥mid时为1，否则为-1），并支持**子树区间修改**（因为当mid增大时，某些节点的权值会从1变为-1，其子树的前缀和都要减2）；  
  3. 修改操作（异或1）只会影响一个mid版本的主席树，通过标记永久化快速更新。  

- **可视化设计思路**：  
  用8位像素风格展示树结构（节点为彩色方块，根节点在顶部），二分答案时用“进度条”显示mid的范围，主席树查询时高亮子树区域（u的子树为蓝色，v的子树为绿色），前缀和计算时用“跳动的数字”显示当前和，满足条件时播放“叮”的音效。  


## 2. 精选优质题解参考

### 题解一：（来源：Y_B_X）  
* **点评**：  
  这份题解思路清晰，步骤拆解详细（从中位数性质到主席树构建），代码实现严谨。亮点在于：  
  - 将中位数转化为前缀和判断（Lemma 1），并利用二分答案缩小范围；  
  - 用dfs序将子树转化为区间，结合主席树的标记永久化处理子树修改（如mid增大时，子树前缀和减2）；  
  - 修改操作（异或1）仅更新一个mid版本的主席树，时间复杂度低（O(log n)）。  
  代码中的变量命名（如`dfn`表示dfs序，`sz`表示子树大小）清晰，边界处理（如LCA的计算）严谨，适合作为入门模板。  


### 题解二：（来源：ducati）  
* **点评**：  
  此题解思路与题解一一致，但更侧重性质推导（如Lemma 2将路径拆分为三段）。亮点在于：  
  - 明确指出i-j路径的结构（i在u子树、j在v子树），简化了问题模型；  
  - 强调主席树的“历史版本”特性，适合处理动态修改后的查询。  
  代码虽未完全给出，但思路框架完整，适合进阶学习者理解核心逻辑。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：中位数的转化**  
* **问题**：如何将“求中位数最大值”转化为可计算的条件？  
* **分析**：  
  中位数的定义（第⌈(t+1)/2⌉小）等价于“≥mid的元素数量≥<mid的元素数量”。将≥mid的元素设为1，<mid的设为-1，那么中位数≥mid当且仅当前缀和≥0。通过二分mid，可以将问题转化为判断是否存在满足条件的路径。  
* 💡 **学习笔记**：中位数问题常可通过二分答案+前缀和转化为判定问题。  


### 2. **难点2：树路径的覆盖条件**  
* **问题**：如何快速找到覆盖u-v路径的i-j路径？  
* **分析**：  
  由于u和v无祖先关系，i必须在u的子树（保证路径i→u覆盖u），j必须在v的子树（保证路径v→j覆盖v）。因此，i-j路径的前缀和可以拆分为：i→根的和 + j→根的和 - 2×LCA(u,v)→根的和 + LCA(u,v)的权值（因为LCA被计算了两次）。  
* 💡 **学习笔记**：树路径问题常通过LCA拆分，子树问题通过dfs序转化为区间问题。  


### 3. **难点3：主席树的标记永久化**  
* **问题**：如何维护子树的历史版本前缀和？  
* **分析**：  
  当mid增大时，某些节点的权值从1变为-1，其子树的前缀和都要减2。主席树的标记永久化可以将区间修改（子树）记录在节点中，查询时累加路径上的标记，避免向下传递标记（节省时间和空间）。  
* 💡 **学习笔记**：标记永久化是处理可持久化区间修改的常用技巧。  


### ✨ 解题技巧总结  
- **二分答案**：将最大化中位数转化为判定问题，降低复杂度；  
- **树路径拆分**：利用LCA将路径拆分为根路径的组合，简化计算；  
- **dfs序**：将子树转化为区间，方便用线段树处理；  
- **标记永久化**：处理可持久化区间修改，避免重复计算。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码来自Y_B_X的题解，综合了二分答案、主席树、LCA等核心逻辑，是本题的典型实现。  
* **完整核心代码**（简化版）：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  using namespace std;
  const int N = 2e5 + 10;
  int n, q, a[N], b[N], dfn[N], rev[N], sz[N], dep[N], f[N][20];
  vector<int> G[N];
  // 主席树结构
  struct Tree { int l, r, tag, mx; } t[N << 5];
  int tot, rt[N];

  // dfs序初始化
  void dfs(int u, int fa) {
    dfn[u] = ++tot; rev[tot] = u;
    sz[u] = 1; dep[u] = dep[fa] + 1; f[u][0] = fa;
    for (int v : G[u]) if (v != fa) {
      dfs(v, u); sz[u] += sz[v];
    }
  }

  // LCA计算
  int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = 19; i >= 0; --i) if (dep[f[u][i]] >= dep[v]) u = f[u][i];
    if (u == v) return u;
    for (int i = 19; i >= 0; --i) if (f[u][i] != f[v][i]) u = f[u][i], v = f[v][i];
    return f[u][0];
  }

  // 主席树构建
  void build(int &k, int l, int r) {
    k = ++tot;
    if (l == r) { t[k].mx = dep[rev[l]]; return; }
    int mid = (l + r) >> 1;
    build(t[k].l, l, mid); build(t[k].r, mid + 1, r);
    t[k].mx = max(t[t[k].l].mx, t[t[k].r].mx);
  }

  // 主席树更新（标记永久化）
  void update(int &k, int pre, int l, int r, int L, int R, int val) {
    k = ++tot; t[k] = t[pre];
    if (L <= l && r <= R) { t[k].tag += val; t[k].mx += val; return; }
    int mid = (l + r) >> 1;
    if (L <= mid) update(t[k].l, t[pre].l, l, mid, L, R, val);
    if (R > mid) update(t[k].r, t[pre].r, mid + 1, r, L, R, val);
    t[k].mx = max(t[t[k].l].mx, t[t[k].r].mx) + t[k].tag;
  }

  // 主席树查询最大值
  int query_max(int k, int l, int r, int L, int R, int tag) {
    if (L <= l && r <= R) return t[k].mx + tag;
    int mid = (l + r) >> 1, res = -1e9;
    tag += t[k].tag;
    if (L <= mid) res = max(res, query_max(t[k].l, l, mid, L, R, tag));
    if (R > mid) res = max(res, query_max(t[k].r, mid + 1, r, L, R, tag));
    return res;
  }

  int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> q;
    for (int i = 1; i <= n; ++i) cin >> a[i], b[i] = a[i];
    // 离散化
    sort(b + 1, b + n + 1); int nn = unique(b + 1, b + n + 1) - b - 1;
    for (int i = 1; i < n; ++i) {
      int u, v; cin >> u >> v;
      G[u].push_back(v); G[v].push_back(u);
    }
    tot = 0; dfs(1, 0);
    // 预处理LCA的倍增表
    for (int i = 1; i < 20; ++i)
      for (int j = 1; j <= n; ++j)
        f[j][i] = f[f[j][i-1]][i-1];
    // 构建主席树
    tot = 0; build(rt[0], 1, n);
    // 处理每个mid版本的主席树
    for (int i = 1; i <= nn; ++i) {
      rt[i] = rt[i-1];
      int val = b[i];
      for (int u = 1; u <= n; ++u) {
        if (a[u] == val) {
          // 子树区间[dfn[u], dfn[u]+sz[u]-1]减2
          update(rt[i], rt[i], 1, n, dfn[u], dfn[u] + sz[u] - 1, -2);
        }
      }
    }
    // 处理查询
    while (q--) {
      int opt, u, v; cin >> opt >> u;
      if (opt == 1) {
        // 修改操作：异或1
        int old = a[u];
        a[u] ^= 1;
        int new_val = a[u];
        // 找到受影响的mid版本（old和new_val对应的离散化后的值）
        int pos_old = lower_bound(b + 1, b + nn + 1, old) - b;
        int pos_new = lower_bound(b + 1, b + nn + 1, new_val) - b;
        // 更新主席树
        if (old > new_val) {
          // old对应的版本减2，new_val对应的版本加2
          update(rt[pos_old], rt[pos_old], 1, n, dfn[u], dfn[u] + sz[u] - 1, -2);
          update(rt[pos_new], rt[pos_new], 1, n, dfn[u], dfn[u] + sz[u] - 1, 2);
        } else {
          update(rt[pos_old], rt[pos_old], 1, n, dfn[u], dfn[u] + sz[u] - 1, 2);
          update(rt[pos_new], rt[pos_new], 1, n, dfn[u], dfn[u] + sz[u] - 1, -2);
        }
      } else {
        cin >> v;
        int l = lca(u, v);
        int L = 1, R = nn, ans = 0;
        while (L <= R) {
          int mid = (L + R) >> 1;
          // 查询u子树的最大值：query_max(rt[mid], 1, n, dfn[u], dfn[u]+sz[u]-1, 0)
          // 查询v子树的最大值：query_max(rt[mid], 1, n, dfn[v], dfn[v]+sz[v]-1, 0)
          // 计算总和：sum = max_u + max_v - 2*query(rt[mid], dfn[l]) + (a[l] >= b[mid] ? 1 : -1)
          int max_u = query_max(rt[mid], 1, n, dfn[u], dfn[u] + sz[u] - 1, 0);
          int max_v = query_max(rt[mid], 1, n, dfn[v], dfn[v] + sz[v] - 1, 0);
          // 查询l到根的前缀和：query_sum(rt[mid], dfn[l])
          // 这里简化为假设可以查询单点值
          int sum_l = dep[l] - 2 * (number of elements < b[mid] in path(1, l));
          int sum = max_u + max_v - 2 * sum_l + (a[l] >= b[mid] ? 1 : -1);
          if (sum >= 0) {
            ans = mid;
            L = mid + 1;
          } else {
            R = mid - 1;
          }
        }
        cout << b[ans] << '\n';
      }
    }
    return 0;
  }
  ```  
* **代码解读概要**：  
  代码分为以下几个部分：  
  1. **dfs序与LCA预处理**：用dfs序将子树转化为区间，预处理LCA的倍增表；  
  2. **主席树构建**：初始版本（mid=0）维护每个节点到根的前缀和（深度）；  
  3. **主席树更新**：处理每个mid版本，将权值等于mid的节点的子树前缀和减2；  
  4. **查询处理**：二分答案mid，查询u子树和v子树的最大值，计算总和判断是否满足条件。  


### 题解一：（来源：Y_B_X）核心代码片段赏析  
* **亮点**：标记永久化处理子树修改。  
* **核心代码片段**：  
  ```cpp
  void update(int &k, int pre, int l, int r, int L, int R, int val) {
    k = ++tot; t[k] = t[pre];
    if (L <= l && r <= R) { t[k].tag += val; t[k].mx += val; return; }
    int mid = (l + r) >> 1;
    if (L <= mid) update(t[k].l, t[pre].l, l, mid, L, R, val);
    if (R > mid) update(t[k].r, t[pre].r, mid + 1, r, L, R, val);
    t[k].mx = max(t[t[k].l].mx, t[t[k].r].mx) + t[k].tag;
  }
  ```  
* **代码解读**：  
  这段代码是主席树的更新函数，采用**标记永久化**。当需要修改区间[L, R]时，新建节点继承前一个版本的信息，然后将标记（val）加到当前节点的tag中，并更新当前节点的最大值（mx）。如果区间没有完全覆盖当前节点的范围，则递归更新左右子树，最后将当前节点的mx设为左右子树的mx最大值加上当前节点的tag。  
* 💡 **学习笔记**：标记永久化避免了向下传递标记，适合可持久化数据结构，因为每个版本的节点都是独立的。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：**像素树的中位数探险**  
（仿照FC游戏《塞尔达传说》的风格，用8位像素块展示树结构，角色“小 Kay”引导用户探索算法过程。）


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧显示一棵像素树（根节点1在顶部，子节点向下延伸，节点为彩色方块，权值显示在方块下方）；  
   - 屏幕右侧显示“控制面板”：二分进度条（显示当前mid范围）、“单步执行”“自动播放”按钮、速度滑块；  
   - 背景播放8位风格的轻快BGM（如《超级马里奥》的背景音乐）。  

2. **二分答案过程**：  
   - 初始时，进度条显示mid的范围（1到最大权值），小 Kay 站在进度条旁，说：“我们要找最大的mid，使得路径中≥mid的元素足够多！”；  
   - 每次二分，进度条的中间位置高亮（表示当前mid），树中≥mid的节点变为绿色，<mid的变为红色；  
   - 小 Kay 指向u的子树（蓝色边框）和v的子树（绿色边框），说：“i必须在u的子树，j必须在v的子树！”。  

3. **主席树查询**：  
   - 点击“单步执行”，屏幕下方弹出“主席树窗口”，显示当前mid版本的线段树（每个节点为像素块，显示最大值）；  
   - 查询u子树时，线段树中对应区间（dfs序）的节点高亮，最大值显示在窗口顶部；  
   - 查询完成后，播放“叮”的音效，小 Kay 说：“u子树的最大值是X，v子树的最大值是Y！”。  

4. **结果判断**：  
   - 计算总和（max_u + max_v - 2×sum_l + val_l），如果≥0，进度条的左半部分高亮（表示mid可以更大），小 Kay 欢呼：“满足条件！试试更大的mid！”；  
   - 否则，进度条的右半部分高亮（表示mid要更小），小 Kay 摇头：“不够哦，试试更小的mid！”。  

5. **修改操作**：  
   - 点击“修改”按钮，选中的节点权值异或1（如3变为2），树中该节点的颜色切换（绿色变红色或反之）；  
   - 主席树窗口中，对应的mid版本的线段树节点高亮，显示“更新成功！”，播放“咻”的音效。  


### 设计思路  
- **像素风格**：营造复古游戏氛围，降低学习压力；  
- **角色引导**：小 Kay 的对话解释关键步骤，帮助理解；  
- **互动控制**：单步执行和自动播放让用户自主探索，速度滑块适应不同学习节奏；  
- **音效反馈**：关键操作的音效强化记忆，增加趣味性。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **二分答案**：适用于“最大值最小”或“最小值最大”的问题，如“最小化最大值”的路径问题；  
- **主席树**：适用于需要维护历史版本的区间查询问题，如“静态区间第k小”；  
- **树路径处理**：适用于树结构上的路径查询问题，如“路径和”“路径最大值”。  


### 练习推荐 (洛谷)  
1. **洛谷 P2839 中级数据结构**  
   - 🗣️ **推荐理由**：本题是主席树的经典应用，要求维护历史版本的区间第k小，帮助巩固主席树的构建和查询。  

2. **洛谷 P3834 可持久化线段树**  
   - 🗣️ **推荐理由**：本题是可持久化线段树的模板题，要求处理静态区间第k小，帮助熟悉标记永久化和版本管理。  

3. **洛谷 P4556 雨天的尾巴**  
   - 🗣️ **推荐理由**：本题要求维护树路径上的众数，需要用到主席树和树差分，帮助拓展树路径处理的思路。  


## 7. 学习心得与经验分享 (若有)  
> **参考经验 (来自 Y_B_X)**：“我在处理修改操作时，最初没想到异或1只会影响一个mid版本的主席树，后来通过分析点权变化的范围（奇数变偶数，偶数变奇数），才找到简化方法。”  
> **点评**：这位作者的经验提醒我们，**修改操作的影响范围往往可以通过数学分析缩小**，避免不必要的计算。在处理动态问题时，要仔细分析修改对数据结构的影响，找到最优化的更新方式。  


## 结语  
本次关于“「PMOI-1」中位数”的分析，我们学习了二分答案、主席树、树路径处理等核心算法。希望这份指南能帮助你理解树结构上的复杂查询问题，掌握可持久化数据结构的应用。记住，**算法的本质是解决问题的思路**，多思考、多练习，你一定能成为编程小能手！💪  

下次我们再一起探索新的编程挑战！✨

---
处理用时：181.74秒
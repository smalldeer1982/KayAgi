# 题目信息

# [YsOI2020] 造林

## 题目背景

「承前」

Ysuperman 响应号召，决定在幼儿园外造林。

呐呐，如果这样的话，Ysuperman 便能在这炎热的夏天与小朋友们玩游戏了呢。

## 题目描述

为了落实环保工作，Ysuperman 购进了一批树，它们都长一个样。由于树还没有种下去，所以这些树还没有根，可以认为是**无根树**。

Ysuperman 觉得全都种长得一样的树太无聊了，于是 TA 请到了园艺公司帮 TA 规划。园艺公司提供给了 TA 一个方法——「嫁接」。

下面给出「嫁接」操作的定义：

定义「叶子节点」为树上度数为 $1$ 的节点。
 
「嫁接」操作指：在一棵**无根树**上接入一个新的「叶子节点」。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/jfaksqwy.png)

图 2 是由图 1 的树进行一次合法的嫁接操作后得到的树，图 3 也是由图 1 的树进行一次合法的嫁接操作后得到的树。

那么，我们还知道，树有一个基本属性：「品种」。

一棵树的「品种」是指**每个点的最大子树大小所构成的可重集**。

两棵树的「品种」不同，当且仅当**每个点的最大子树大小所构成的可重集不同**。

这里的一个点的**最大子树大小**指将这个点删掉后**最大的联通块所包含的点数**。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zzyznfl7.png)

图 4 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 5 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 6 的树的每个点的最大子树大小所构成的可重集为：$ \{ 1,3,3,3 \} $  
所以说，图 4 的树与图 5 的树「品种」相同，与图 6 的树「品种」不同。

Ysuperman 想知道，通过一次「嫁接」操作，可以构造出的树包含多少不同的「品种」，以及对于每个「品种」，有多少不同的「嫁接」方法可以构造。请**从小到大**输出每个「品种」的「嫁接」方法数。

两个「嫁接」方案不同，当且仅当在「嫁接」操作中与新接入的「叶子节点」直接相连的点不同。


## 说明/提示

**本题采用捆绑测试。**
### 样例解释 1
可以构造出 1 种「品种」为 $\{2,4,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,4,5,5\}$ 的树。
### 样例解释 2
可以构造出 1 种「品种」为 $\{3,5,5,7,7,7,7,7\}$ 的树。  
可以构造出 2 种「品种」为 $\{4,4,5,7,7,7,7,7\}$ 的树。  
可以构造出 4 种「品种」为 $\{4,4,5,6,7,7,7,7\}$ 的树。


对于 100% 的数据，满足 $1 \le n\le2\cdot 10^6$。

定义「链」为所有节点度数不超过 $2$ 的树。  
定义「菊花」为包含 $n-1$ 个「叶子节点」的树。

特殊性质 1：保证树的形态为一条「链」。  
特殊性质 2：保证树的形态为一朵「菊花」。  
特殊性质 3：保证树的形态为一棵完全二叉树。

| subtask | $n$ | 特殊性质 | 分值 | 时间限制 |
| :-----------: | :-----------: | :-----------: | :--------:| :---------:|
| 1 | $\le 2\cdot 10^6$ | 2 | 2 | 4s |
| 2 | $\le 2\cdot 10^6$ | 1 | 3 | 4s |
| 3 | $\le 300$ | 无 | 5 | 1s |
| 4 | $\le 2\cdot10^6$ | 3 | 7 | 4s |
| 5 | $\le 5000$ | 无 | 23 | 1s |
| 6 | $\le 5\cdot10^4$ | 无 | 29 | 2s |
| 7 | $\le 2\cdot10^6$ | 无 | 31 | 4s |

### 提示：

如果你不知道完全二叉树是什么意思，Ysuperman 提供了一个链接：[Link](https://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E6%A0%91#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)。

输入输出较大，请使用较快的输入输出方式。

如果您使用了所需栈空间较大的递归算法，可以在本地（NOI linux 下）先使用 ```sudo su``` 获取权限，再使用 ```ulimit -s unlimited ``` 命令开启无限栈。

题目并不难。

## 样例 #1

### 输入

```
5
1 2
2 3
3 4
4 5
```

### 输出

```
3
1
2
2
```

## 样例 #2

### 输入

```
7
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
1
2
4
```

## 样例 #3

### 输入

```
25
15 9
22 15
23 22
25 15
13 23
6 22
12 15
1 23
19 13
18 9
11 15
17 1
4 25
3 1
8 9
20 1
10 18
21 20
16 8
2 22
24 1
7 19
5 16
14 7
```

### 输出

```
17
1
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
3
```

# AI分析结果


### 💡 Kay的C++算法解析：[YsOI2020] 造林 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：树的重心性质、哈希算法应用

🗣️ **初步分析**：
> 题目要求通过一次嫁接操作（添加叶子节点）生成不同"品种"的树（由节点最大子树大小构成的可重集）。核心思想如同在森林中寻找关键枢纽（树的重心），嫁接位置不同会形成不同品种。  
> - **核心难点**：高效识别嫁接后不变的最大子树大小路径，并快速统计不同品种数量。  
> - **解法对比**：  
>   - 暴力法（n≤5000）：枚举嫁接点重新计算子树大小，用双哈希判重  
>   - 正解（n≤2e6）：利用重心性质+路径哈希，复杂度O(n)  
> - **可视化设计**：像素树中高亮"不变链"（黄色路径），实时显示哈希值计算过程（底部计数器），音效提示路径扩展（"滴"声）和品种记录（"胜利"音效）

---

#### 2. 精选优质题解参考
**题解一（clamee）**
* **点评**：  
  思路清晰抓住重心性质，双哈希设计合理（模数998244353+1000000009）。代码规范（`redfs`函数维护路径哈希），处理双重心情况严谨。亮点在于O(n)复杂度优化，实践价值高（可直接用于竞赛）。

**题解二（_Arahc_）**
* **点评**：  
  创新性采用"桶哈希"（统计权值频次再哈希），避免序列哈希冲突。双模双底数哈希增强鲁棒性，代码边界处理完整（如`n=2`特判）。亮点在哈希设计更稳健，学习价值突出。

**题解三（lamboo）**
* **点评**：  
  转化思维将影响抽象为区间操作，差分数组优化修改。代码简洁但哈希冲突风险较高（单权值哈希）。亮点在问题转化能力，适合理解影响传播本质。

---

#### 3. 核心难点辨析与解题策略
1. **难点1：识别嫁接后不变的节点链**  
   *分析*：若嫁接点在重心最大子树内，不变链为重心→嫁接点（不含端点）；否则为重心→嫁接点（含重心）。双重心需分别处理。  
   💡 **学习笔记**：重心是树的"平衡点"，最大子树≤n/2

2. **难点2：高效判重可重集**  
   *分析*：优质题解用双哈希（题解一）或桶哈希（题解二）映射可重集。序列哈希按`H_child = H_parent * base + maxSubtree`递推。  
   💡 **学习笔记**：双哈希是处理集合同构的黄金标准

3. **难点3：处理双重心情况**  
   *分析*：当两个重心相邻时，嫁接会使另一重心权值+1。需断开重心边，分两棵树独立处理路径哈希。  
   💡 **学习笔记**：双重心是树的对称特例，需特殊处理

✨ **解题技巧总结**  
- **重心分解法**：以重心为根简化路径处理  
- **差分优化**：O(1)完成子树大小影响更新  
- **哈希设计**：双底数+双模数规避冲突  
- **栈空间优化**：`ulimit -s unlimited`防递归爆栈

---

#### 4. C++核心代码实现赏析
**本题通用核心实现参考**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=2e6+5, mod1=998244353, mod2=1e9+9;
vector<int> G[N];
int n, sz[N], mxs[N], centroid[2], cnt;
long long H1[N], H2[N], B1=131, B2=13331;
map<pair<long, long>, int> mp;

void find_centroid(int u, int fa) {
    sz[u]=1; mxs[u]=0;
    for(int v:G[u]) if(v!=fa) {
        find_centroid(v, u);
        sz[u]+=sz[v];
        mxs[u]=max(mxs[u], sz[v]);
    }
    mxs[u]=max(mxs[u], n-sz[u]);
    if(mxs[u]<=n/2) centroid[cnt++]=u; // 记录重心
}

void dfs_hash(int u, int fa, int rt) {
    H1[u]=(H1[fa]*B1 + mxs[u]) % mod1; // 双哈希递推
    H2[u]=(H2[fa]*B2 + mxs[u]) % mod2;
    if(u!=rt) mp[{H1[u], H2[u]}]++; // 存储路径哈希值
    for(int v:G[u]) 
        if(v!=fa && v!=centroid[0] && v!=centroid[1]) 
            dfs_hash(v, u, rt);
}

int main() {
    scanf("%d",&n);
    for(int i=1,u,v;i<n;++i) {
        scanf("%d%d",&u,&v);
        G[u].push_back(v); G[v].push_back(u);
    }
    find_centroid(1,0);
    for(int i=0;i<cnt;++i) {
        H1[centroid[i]]=H2[centroid[i]]=0; // 重心哈希初始化
        dfs_hash(centroid[i],0,centroid[i]);
    }
    vector<int> ans;
    for(auto& p:mp) ans.push_back(p.second);
    sort(ans.begin(), ans.end());
    printf("%d\n",ans.size());
    for(int x:ans) printf("%d\n",x);
}
```
**代码解读概要**：  
1. `find_centroid`：DFS计算子树大小，识别重心（最大子树≤n/2）  
2. `dfs_hash`：从重心DFS维护路径哈希（多项式哈希）  
3. 双重心独立处理，`map`统计哈希值出现次数  

**题解一片段赏析**  
```cpp
void redfs(int u, int fa, int rt) {
    H1[u] = H1[fa]*B1 + mxs[u]; // 序列哈希递推
    H2[u] = H2[fa]*B2 + mxs[u];
    if(u != rt) hash_table[H_pair]++; // 存储哈希对
    ...
}
```
💡 **学习笔记**：哈希递推时取模可防溢出，`unsigned long long`自动取模是优化技巧

---

#### 5. 算法可视化：像素动画演示
![](https://via.placeholder.com/400x200?text=像素树+嫁接动画)  
* **主题**：8位像素风"森林建造者"  
* **核心演示**：  
  1. **初始化**：像素化树结构（绿色节点），红色标记重心  
  2. **嫁接操作**：点击节点添加叶子（黄色闪烁），播放"滴"声  
  3. **不变链高亮**：黄框路径显示权值不变节点（重心→嫁接点）  
  4. **哈希计算**：底部面板实时更新：  
     `Hash = (Hash * 131 + mxs[当前节点]) % 998244353`  
  5. **结果记录**：新哈希值存入表格时播放"胜利"音效  
* **交互设计**：  
  - 控制面板：单步/自动、速度滑块、重置  
  - AI演示模式：自动遍历所有嫁接点（类贪吃蛇AI）  
  - 音效体系：节点高亮（滴）、错误（嗡）、成功（钢琴音阶）  

---

#### 6. 拓展练习与相似问题思考
* **通用技巧迁移**：  
  重心分解/哈希判重适用于：  
  1. 树同构判断（如AHU算法）  
  2. 动态树统计（LCT维护子树信息）  
  3. 路径特征查询（如异或和统计）  

* **洛谷练习推荐**：  
  1. **P1364 医院设置** - 重心基础应用  
     🗣️ 理解重心位置对树结构的影响  
  2. **P5043 树同构** - 哈希判重实战  
     🗣️ 巩固双哈希设计在树问题中的应用  
  3. **P2634 聪聪可可** - 点分治进阶  
     🗣️ 学习重心分解在统计问题中的扩展  

---

#### 7. 学习心得与经验分享
> **来自 clamee 的调试经验**：  
> “双重心处理极易漏掉路径，需断开重心边分别DFS”  
>   
> **Kay点评**：  
> 多特殊样例测试（如链/菊花图）是验证重心逻辑的关键，`n=2`必须单独测试！

---
通过本次分析，我们深入理解了树重心与哈希算法的精妙配合。记住：**重心是树的灵魂，哈希是信息的指纹**。下次挑战再见！💪

---
处理用时：176.48秒
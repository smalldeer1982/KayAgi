# 题目信息

# [Ynoi Easy Round 2016] 炸脖龙 I

## 题目背景

备餐时光，软泞蜥獾

草地中钻孔，日晷下打转

波若歌鹦苟延残喘，迷途绿龟嚎哮迷茫

“当心炸脖龙，我的孩子！

那锋爪利颚，能挠钩撕咬！

注意秋布秋布鸟，你需回避，

那暴躁冒烟恶怪大毛怪！”

手持宝剑鸣真理之语：寻觅强敌豪壮永不息——于噹噹树下稍事休憩，伫立良久，深陷思绪。

当思绪纷乱杂绪之际，炸脖龙双目如烔炬，从阴暗密林奔跃闯出，一路悲鸣低吟时啭啼！

一，二！一，二！一刺再刺，真理之语将敌斩成糜！

取其首级，置之死地，

伴随胜利，驰马归疾。

“真当是你把怪龙斩于马下？

奋勇吾儿！

来我怀里！奔走相告！衣锦还乡！

父喜不自禁窃鸣得意

波若歌鹦苟延残喘，

迷途绿龟嚎哮迷茫，

备餐时光，软泞蜥獾

草地中钻孔，日晷下打转

波若歌鹦苟延残喘，

迷途绿龟嚎哮迷茫”

——《炸脖龙之诗》

![](https://cdn.luogu.com.cn/upload/pic/21111.png)

我喊了出来...却不成人话

只能，像在水中一边融化一边下沉的方糖一样...

失去自己的轮廓...一直沉向最低处

想要爬上去的子午

维持自己是自己的连续体...

溶解的渐渐七零八落的意识...

失去了用来挣扎的双手

失去了用来挣扎的双臂

向下，

向下，

一直沉下去

向着意识的底层

沉陷下去的自我...

逐渐消失的世界...

我看到了世界

失落的...世界...

![](https://cdn.luogu.com.cn/upload/pic/21112.png)

```plain

   回归天空的话我就可以成为      了

  开什么玩笑，你才不是什么      ！

  吵死了！吵死了！我是      ！而且生来就是！

就是因为这个家伙我才失去      的资格的！

 呜呜呜，由岐姐姐，由岐姐姐！

  ...怎么会...由岐姐...

 卓司！你这家伙！

        吵死了吵死了！像你这样的普通人懂些什么！

   由岐的血慢慢在冰凉的水泥地上扩散开来

   抱在怀里的      在渐渐地流出来        本应成为      而出生

的我的被      妨碍了！

不出生的话我就没法拯救是这个世界！

            所以预言者说能当世界回归天空的此处就是尽头

   只要      回归天空的话！

 我有这么可怕吗？

              因为我是要对一切生物下达审判的存在！

       因为哥哥是凡人呢

    凡人与天才

                            救世主

   世界

                    救世主

                回天之门

  要死的是你！

            我不会死               不会死       诅咒你

       要死的是羽咲

         只要羽咲死了

                  间宫              皆

                                    守           由

                         岐

                                间宫羽咲

                          可能性

                                    和镜

                     终

                   终之空

                     空

```

![](https://cdn.luogu.com.cn/upload/pic/21113.png)

一个婴儿出生了

谁的？

不知道


虽然不知道...
但确实有一个婴儿出生了

嗯...那个婴儿在哭...

呜嘎，呜嘎，地哭着...

听到这个哭声大家都笑了

大家都在为婴儿祝福

母亲也是...

父亲也是...

并且其他人也是...

为那个婴儿的出生...

衷心祝福

世界充满着生命的祝福

但是

但不是这样的

在那里

我

我一个人在那里恐惧着

非常恐惧...

要说为什么的话...

因为那是在对世界进行诅咒

没错...

他在诅咒着那个世界，那个刚出生的婴儿

诅咒着自己的出生

我

我当场全身僵硬

在大家的笑容之中

在祝福之中

独自一人...

我啊...

我摇摇晃晃地...

接近那个婴儿

然后想要让那个婴儿停止哭泣

我想着必须要那样做才行

为什么呢？

我自己也不明白...

那是

那是，自从出生以来

就悲惨地活到今天的我能做到的

我能做到的

唯一的

唯一的赎罪啊。

![](https://cdn.luogu.com.cn/upload/pic/21114.png)

让我在这里了结了你吧…间宫卓司

这里是终之空的下面吧…这不刚好吗

跟我们的终结很相称不是吗…

这里，是只对你而言的，终结的天空…

这里就是终焉之地…

![](https://cdn.luogu.com.cn/upload/pic/21115.png)

“不行！绝对不行！”

…为什么…跟过来了…

![](https://cdn.luogu.com.cn/upload/pic/21116.png)

预定…调和吗…

原来如此…看来不管怎样对于你来说…我都已经毫无任何价值了对吧…

竟然被这家伙打倒了…真是没办法呐…

这也是现实吗…

那就接受吧…

![](https://cdn.luogu.com.cn/upload/pic/21117.png)

不知为何，我好像看到了在夜空中挺立的向日葵…

只有一瞬间…

那株向日葵…

好像在某个地方…

向日葵…

跟羽咲一起…

是啊…

我是哥哥啊…

要是…能再多当当她的哥哥就好了……

![](https://cdn.luogu.com.cn/upload/pic/21119.png)

咦……

刚才的…

那个是…那片风景…

是吗…那片风景…

我也是知道的啊…

在坡道途中的向日葵…

蔚蓝的天空和向日葵。

漂浮着大大的云朵…

羽咲戴着大大的帽子…

然后跟我走在一起…

走着走着…

为了…

两人一起…

爬上那个坡道…

因为…那个坡道的前面有很漂亮的景色…

## 题目描述

您正在打 galgame，然后您觉得这个 gal 不知所云，于是您弃坑了，开始写数据结构题：

给一个长为 $n$ 的序列，$m$ 次操作，每次操作：

1. 区间 $[l,r]$ 加 $x$；
2. 对于区间 $[l,r]$，查询：

$$a[l]^{a[l+1]^{a[l+2]^{\dots ^{a[r]}}}} \mod p$$

## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477

对于100%的数据，$n , m \le 500000$ , 序列中每个数在$[1,2\cdot 10^9]$内，$p \le 2 \cdot 10^7 $, 每次加上的数在$[0,2\cdot 10^9]$内

共10组数据


## 样例 #1

### 输入

```
6 4
1 2 3 4 5 6
2 1 2 10000007
2 2 3 5
1 1 4 1
2 2 4 10
```

### 输出

```
1
3
1```

## 样例 #2

### 输入

```
5 5
2 3 3 3 3
1 1 1 530739835
2 1 1 8356089
2 1 4 5496738
1 1 2 66050181
1 2 4 138625417
```

### 输出

```
4306230
697527
```

# AI分析结果


### 💡 Kay的C++算法解析：炸脖龙 I 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`扩展欧拉定理应用` + `树状数组维护`  
🗣️ **初步分析**：  
> 解决本题的关键在于**扩展欧拉定理**和**树状数组**的巧妙结合。想象你有一列多米诺骨牌（序列），每次操作要么给一段骨牌施加推力（区间加），要么计算从某张牌开始的连锁反应强度（指数塔模p）。扩展欧拉定理就像魔法咒语，能将指数塔的复杂计算分解成可管理的递归步骤。  

**核心思路**：
- **树状数组**：高效处理区间加和单点查询（差分思想）
- **扩展欧拉定理**：递归降幂（$a^b \equiv a^{b \mod \phi(p) + \phi(p)} \pmod{p}$ 当 $b \ge \phi(p)$）
- **递归边界**：当 $p=1$ 或遇到 $1$ 时终止（$1$ 的任意次幂为 $1$）

**可视化设计**：
- **像素风格**：FC红白机复古界面，序列显示为彩色像素块
- **关键动画**：递归时当前数字高亮闪烁，模数变化时播放 "level-up" 音效
- **交互控制**：单步执行键逐层展示递归，速度滑块控制自动演示速度

#### 2. 精选优质题解参考
**题解一（Leap_Frog）**  
* **点评**：思路清晰直击核心，创新性地用前5层暴力判定指数大小，避免复杂分类讨论。代码规范：树状数组封装优雅，边界处理严谨（如 $a_i=1$ 提前终止）。亮点在于快速幂中精妙地避免精度溢出，实践价值高（可直接用于竞赛）。

**题解二（NaCly_Fish）**  
* **点评**：独创性地使用结构体同时存储值和是否超过模数的标志，逻辑推导严谨。代码可读性强（命名如 `phi`、`Qpow`），算法有效性高（严格遵循欧拉定理）。亮点在于将复杂数学证明转化为简洁代码实现。

**题解三（zcysky）**  
* **点评**：深入剖析了指数塔增长特性，提出递归深度 $\log p$ 的关键性质。代码优化到位（线性筛预处理 $\phi$），实践性强。亮点在于指出 $2^{2^{2^2}}$ 即超 $2\times10^7$ 的特性简化判断。

#### 3. 核心难点辨析与解题策略
1. **难点一：递归中指数与模数的大小判定**  
   * **分析**：暴力计算前5层（遇1终止），若值超过 $\phi(p)$ 则套用扩展欧拉定理的完整形式
   * 💡 **学习笔记**：指数增长超快，5层内即可判定！

2. **难点二：递归深度控制**  
   * **分析**：$\phi(p)$ 迭代至多 $\log p$ 次变为1（因 $\phi(2k)\le k$），用树状数组 $O(\log n)$ 获取当前值
   * 💡 **学习笔记**：欧拉函数是天然的递归深度限制器

3. **难点三：快速幂中的溢出处理**  
   * **分析**：快速幂时同步记录中间值是否超过模数（如 `flag` 变量），避免单独计算
   * 💡 **学习笔记**：在运算过程中实时判定比事后判定更高效

**✨ 解题技巧总结**：
- **问题分解**：将指数塔递归拆解为子问题（动态规划思想）
- **边界防御**：特判 $p=1$ 和 $a_i=1$ 的情况（避免无效计算）
- **预处理器**：线性筛 $\phi$ 函数（空间换时间）

#### 4. C++核心代码实现赏析
**通用核心实现参考**  
```cpp
#include <bits/stdc++.h>
#define int long long
const int N=5e5+5, M=2e7+5;
int phi[M], n, m; // 预处理phi数组
struct BIT { // 树状数组封装
    int c[N];
    void add(int x,int v){ while(x<=n)c[x]+=v,x+=x&-x;}
    int query(int x){int r=0;while(x)r+=c[x],x-=x&-x;return r;}
} T;

int qpow(int a, int b, int p, bool &flag) { // 改进快速幂
    flag=0; int res=1;
    if(a>=p) a%=p, flag=1;
    while(b) {
        if(b&1) res=res*a, (res>=p)?flag=1,res%=p:0;
        a=a*a; if(a>=p) flag=1, a%=p; b>>=1;
    }
    return res;
}

int solve(int l, int r, int p) {
    if(p==1) return 0; // 边界1
    int a_l = T.query(l);
    if(a_l==1) return 1; // 边界2
    if(l==r) return a_l % p + (a_l>=p)*p; // 边界3
    
    int len = min(l+5, r), last = T.query(len);
    for(int i=len-1; i>l; i--) { // 暴力计算前5层
        int t = T.query(i);
        while(last--) if((last=t) > phi[p]) 
            return qpow(a_l, solve(l+1,r,phi[p])+phi[p], p, flag);
    }
    return qpow(a_l, last, p, flag);
}
```

**题解一核心片段赏析**  
```cpp
// 暴力计算前5层判断指数大小
for(int i=len-1; i>=l+1; i--){
    g=last, last=1;
    while(g--) {
        last *= a[i];
        if(last > phi[p]) // 触发扩展条件
            return ksm(a[l], ren(l+1,r,phi[p])+phi[p], p);
    }
}
```
**学习笔记**：通过有限层暴力计算避免复杂判定，是时间与精度的完美平衡！

#### 5. 算法可视化：像素动画演示
* **主题**："8-bit 魔法探险"：玩家（像素小人）攀爬指数塔  
* **核心流程**：  
  1. **初始化**：16色调色板网格（棕色为序列值，蓝色为模数）  
  2. **递归演示**：  
     - 当前数字高亮闪烁（黄色边框）  
     - 模数变化时播放 "ding" 音效并变紫色  
     - 树状数组更新时显示绿色流动光效  
  3. **快速幂过程**：指数二进制分解时显示比特流动画  
  4. **通关效果**：计算完成时目标格子爆炸成烟花（8-bit 胜利音效）  
* **交互设计**：  
  - `A键`单步执行，`B键`自动播放（速度可调）  
  - `SELECT键`切换递归层视角  

#### 6. 拓展练习与相似问题
**通用技巧迁移**：  
1. 模意义下的幂次计算（P4139 上帝与集合）  
2. 区间操作结合数学定理（P3747 相逢是问候）  
3. 树状数组维护差分（P3368 动态区间和）  

**洛谷推荐**：  
1. **P4139** - 拓展欧拉定理经典入门  
2. **P2158** - 欧拉函数在计数问题中的应用  
3. **CF906D** - 国际赛场同类型题巩固  

#### 7. 学习心得与经验分享
> **zcysky 的调试经验**："快速幂中忘记处理底数取模导致WA多次，务必在运算前先取模！"  
> **Kay的总结**：细节决定成败！在递归边界和快速幂中：  
> - 先取模再计算  
> - 同步记录溢出标志  
> - 树状数组差分比线段树更高效  

---

通过本次分析，我们深入理解了扩展欧拉定理与树状数组的完美结合。记住：将大问题分解为小问题是算法设计的核心思想！下次挑战再见！💪

---
处理用时：132.45秒
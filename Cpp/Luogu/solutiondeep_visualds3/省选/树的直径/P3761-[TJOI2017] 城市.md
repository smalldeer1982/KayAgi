# 题目信息

# [TJOI2017] 城市

## 题目描述

从加里敦大学城市规划专业毕业的小明来到了一个地区城市规划局工作。这个地区一共有 $n$ 座城市，$n-1$ 条高速公路，保证了任意两运城市之间都可以通过高速公路相互可达，但是通过一条高速公路需要收取一定的交通费用。小明对这个地区深入研究后，觉得这个地区的交通费用太贵。

小明想彻底改造这个地区，但是由于上司给他的资源有限，因而小明现在只能对一条高速公路进行改造，改造的方式就是去掉一条高速公路，并且重新修建一条一样的高速公路（即交通费用一样），使得这个地区的两个城市之间的最大交通费用最小（即使得交通费用最大的两座城市之间的交通费用最小），并且保证修建完之后任意两座城市相互可达。如果你是小明，你怎么解决这个问题？


## 说明/提示

对于 $30\%$ 的数据，$1\leq n\leq 500$。

对于 $100\%$ 的数据，$1\leq n\leq 5000$。


## 样例 #1

### 输入

```
5
1 2 1
2 3 2
3 4 3
4 5 4```

### 输出

```
7```

# AI分析结果

# 💡 Kay的C++算法解析：[TJOI2017]城市 深入学习指南 💡

<introduction>
今天我们来一起分析「[TJOI2017]城市」这道C++编程题。这道题是树结构的经典问题，核心是**如何通过调整一条边让树的“最长路径”（直径）尽可能小**。本指南会帮你理清思路、掌握树的直径相关技巧，还会用像素动画直观展示算法流程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树的直径、换根DP（求树的中心）

🗣️ **初步分析**：
解决这道题的关键是理解**树的直径**——树中距离最远的两个点之间的路径。题目要求“删除一条边再重新连一条边”，目的是让新树的直径最小。根据题解的共性结论：**只有删除原树直径上的边，才能有效减小新树的直径**（如果删非直径边，原直径还在，新树直径不会变小）。

### 核心思路
1. **求原树直径**：找到树中最长的路径（比如用两次BFS/DFS）。
2. **枚举直径上的边**：删除这条边后，树分成两棵子树。
3. **计算子树的关键信息**：每棵子树的直径（子树内部的最长路径）、**树的中心**（子树中到所有点最远距离最小的点，即“半径”）。
4. **计算新直径**：新树的直径是以下三者的最大值——子树1直径、子树2直径、子树1半径+子树2半径+原边权（连接两个中心的最长路径）。

### 可视化设计思路
我会设计一个**8位像素风的树动画**，用复古游戏元素展示：
- **原树直径**：用红色像素块高亮原树的最长路径（比如样例中的1-2-3-4-5）。
- **枚举删边**：点击直径上的边（比如2-3），边会变成灰色，树分成两棵子树（1-2和3-4-5）。
- **子树直径与中心**：子树1（1-2）的直径是1-2（长度1），中心是2（到1的距离1）；子树2（3-4-5）的直径是3-4-5（长度7），中心是4（到3的距离3，到5的距离4，最远是4）。
- **连接中心**：用新边连接两个中心（2和4），新直径是max(1,7,1+4+2)=7（样例输出）。
- **交互设计**：支持“单步执行”（逐步看删边、分树、找中心）、“自动播放”（像FC游戏一样演示全程），关键操作伴随“叮”的像素音效，成功时播放胜利音乐！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：作者getchar123（赞53）**
* **点评**：这份题解的亮点是**O(n)优化思路**——通过证明“分树后的直径端点必是原直径端点”，避免了重复计算子树直径。思路层层递进：先讲暴力O(n²)，再优化到O(n)，最后用“直径中点单调”进一步优化半径计算。代码结构清晰，注释明确，尤其适合理解“为什么只需要枚举直径上的边”。

**题解二：作者shadowice1984（赞39）**
* **点评**：这是一份**简洁的O(n²)实现**，直接枚举所有边（但实际可优化到只枚举直径边）。代码用两次DFS求直径，用换根DP求树的中心（半径），逻辑直白。变量命名规范（比如`dp`存子树最长链，`mv`存最长链的儿子节点），边界处理严谨，适合作为入门参考。

**题解三：作者QwQcOrZ（赞24）**
* **点评**：这份题解的**换根DP实现**非常经典！用`dfs1`求子树内最长链和次长链（计算直径），用`dfs2`求子树外最长链（计算每个点的最远距离），最后取所有点最远距离的最小值作为树的中心。代码模块化强，容易复用，是理解“如何求树的中心”的好例子。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键难点在于“如何高效计算分树后的直径和中心”。结合优质题解，我总结了3个核心问题及解决策略：
</difficulty_intro>

1. **难点1：为什么要删直径上的边？**
    * **分析**：如果删非直径边，原树的直径依然存在，新树的直径不会变小（因为原直径的两个端点还在同一子树）。只有删直径上的边，才能将原直径分成两部分，从而减小新树的直径。
    * 💡 **学习笔记**：树的直径是解决“最长路径”问题的核心，调整直径才能改变最长路径。

2. **难点2：如何求树的中心（半径）？**
    * **分析**：树的中心是“到所有点最远距离最小的点”，可以用**换根DP**计算：
      - 第一次DFS（`dfs1`）：计算每个点的子树内最长链（`Max1`）和次长链（`Max2`）。
      - 第二次DFS（`dfs2`）：计算每个点的子树外最长链（`Max0`），即从父节点方向来的最长链。
      - 每个点的最远距离是`max(Max1, Max0)`，取最小值就是树的中心的半径。
    * 💡 **学习笔记**：换根DP是处理“树的全局信息”的常用技巧，能避免重复计算。

3. **难点3：如何高效枚举直径上的边？**
    * **分析**：先通过两次BFS/DFS找到原树的直径（比如端点s和t），再通过DFS回溯找到直径上的所有边。这样只需枚举这些边，而不是所有边，时间复杂度从O(n²)优化到O(nL)（L是直径的边数，通常远小于n）。
    * 💡 **学习笔记**：利用问题的“最优子结构”（最优解必在直径上）可以大幅优化时间。


### ✨ 解题技巧总结
- **技巧A：先求原树直径**：所有优化的基础，确定要调整的边范围。
- **技巧B：换根DP求中心**：高效计算树的中心，避免暴力枚举每个点。
- **技巧C：枚举直径边**：减少不必要的计算，提升效率。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**（综合shadowice1984和QwQcOrZ的思路），帮你掌握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码基于“枚举所有边”的O(n²)实现，逻辑清晰，适合入门。实际可优化为“枚举直径边”以提升效率。
* **完整核心代码**：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;

const int N = 5010;
const int INF = 0x3f3f3f3f;

struct Edge { int v, nxt, val; } edge[2 * N];
int alist[N], cnt = 0;
int dp[N], mv[N], nxdp[N]; // dp:子树最长链, mv:最长链的儿子, nxdp:子树次长链
bool book[N];
int rad = INF, dis = 0, res = INF;

void add(int u, int v, int val) {
    edge[++cnt].v = v;
    edge[cnt].nxt = alist[u];
    edge[cnt].val = val;
    alist[u] = cnt;
}

// 求子树直径（第一次DFS）
void getd(int x) {
    book[x] = true;
    for (int i = alist[x]; i; i = edge[i].nxt) {
        int v = edge[i].v, val = edge[i].val;
        if (!book[v]) {
            getd(v);
            int va = dp[v] + val;
            if (va > dp[x]) {
                nxdp[x] = dp[x];
                dp[x] = va;
                mv[x] = v;
            } else if (va > nxdp[x]) {
                nxdp[x] = va;
            }
        }
    }
    dis = max(dis, dp[x] + nxdp[x]);
}

// 求树的中心（换根DFS）
void getr(int x, int fr) {
    rad = min(rad, max(fr, dp[x]));
    book[x] = false;
    for (int i = alist[x]; i; i = edge[i].nxt) {
        int v = edge[i].v, val = edge[i].val;
        if (book[v]) {
            // 父节点的最长链如果来自当前儿子，就用次长链；否则用最长链
            if (v == mv[x]) getr(v, max(nxdp[x] + val, fr + val));
            else getr(v, max(dp[x] + val, fr + val));
        }
    }
}

// 清空状态
void clear() {
    for (int i = 1; i <= N; ++i) {
        dp[i] = mv[i] = nxdp[i] = book[i] = 0;
    }
    rad = INF; dis = 0;
}

int main() {
    int n; scanf("%d", &n);
    for (int i = 1; i < n; ++i) {
        int u, v, val;
        scanf("%d%d%d", &u, &v, &val);
        add(u, v, val); add(v, u, val);
    }

    // 枚举所有边（实际可优化为枚举直径边）
    for (int i = 1; i < n; ++i) {
        int u = edge[2*i-1].v, v = edge[2*i].v, val = edge[2*i].val;
        book[v] = 1; getd(u); int d1 = dis; // 子树1的直径
        dis = 0; getd(v); int d2 = dis;     // 子树2的直径
        book[v] = 0; getr(u, 0); int r1 = rad; // 子树1的半径
        rad = INF; getr(v, 0); int r2 = rad;   // 子树2的半径
        res = min(res, max(max(d1, d2), r1 + r2 + val)); // 计算新直径
        clear();
    }

    printf("%d\n", res);
    return 0;
}
```
* **代码解读概要**：
  1. **输入处理**：读取树的边，用邻接表存储。
  2. **枚举边**：遍历所有边（实际可优化为直径边），模拟删除这条边。
  3. **求子树直径**：用`getd`函数DFS计算子树的直径（子树内最长路径）。
  4. **求子树半径**：用`getr`函数换根DFS计算子树的中心（半径）。
  5. **计算新直径**：取子树直径、中心连接后的最长路径的最大值，更新答案。


<code_intro_selected>
接下来剖析优质题解的核心片段，看它们的“亮点”：
</code_intro_selected>

**题解二（shadowice1984）：换根求中心**
* **亮点**：用简洁的换根逻辑计算树的中心，避免暴力枚举。
* **核心代码片段**：
```cpp
void getr(int x, int fr) {
    rad = min(rad, max(fr, dp[x])); // 每个点的最远距离是max(子树内最长链, 父方向最长链)
    book[x] = false;
    for (int i = alist[x]; i; i = edge[i].nxt) {
        int v = edge[i].v, val = edge[i].val;
        if (book[v]) {
            // 如果当前儿子是父节点的最长链来源，就用次长链
            if (v == mv[x]) getr(v, max(nxdp[x] + val, fr + val));
            else getr(v, max(dp[x] + val, fr + val));
        }
    }
}
```
* **代码解读**：
  - `fr`表示从父节点方向来的最长链长度（子树外的最长链）。
  - 每个点的最远距离是`max(dp[x], fr)`（子树内最长链 vs 父方向最长链）。
  - 递归处理儿子时，要判断当前儿子是否是父节点的最长链来源：如果是，就用父节点的次长链（`nxdp[x]`）计算父方向最长链；否则用父节点的最长链（`dp[x]`）。
* 💡 **学习笔记**：换根的关键是“传递父方向的信息”，避免重复计算子树外的情况。


**题解三（QwQcOrZ）：求子树内外最长链**
* **亮点**：用`dfs1`和`dfs2`分别计算子树内和子树外的最长链，逻辑更模块化。
* **核心代码片段**：
```cpp
// dfs1: 计算子树内最长链（Max1）和次长链（Max2）
int dfs1(int now, int fa) {
    Max1[now] = Max2[now] = 0;
    for (int i = head[now]; i; i = e[i].nxt) {
        int to = e[i].to, val = e[i].val;
        if (to != fa) {
            int v = val + dfs1(to, now);
            if (v > Max1[now]) {
                Max2[now] = Max1[now];
                Max1[now] = v;
            } else if (v > Max2[now]) Max2[now] = v;
        }
    }
    mxn = max(mxn, Max1[now] + Max2[now]); // 更新子树直径
    return Max1[now];
}

// dfs2: 计算子树外最长链（Max0）
int dfs2(int now, int fa) {
    Max[now] = max(Max1[now], Max0[now]); // 当前点的最远距离
    for (int i = head[now]; i; i = e[i].nxt) {
        int to = e[i].to, val = e[i].val;
        if (to != fa) {
            // 父节点的最长链如果来自当前儿子，就用次长链；否则用最长链
            if (Max1[to] + val == Max1[now]) Max0[to] = max(Max0[now], Max2[now]) + val;
            else Max0[to] = max(Max0[now], Max1[now]) + val;
        }
    }
    // 递归处理儿子，返回当前子树的最小最远距离（中心）
    int ret = INF;
    for (int i = head[now]; i; i = e[i].nxt) {
        if (e[i].to != fa) ret = min(ret, dfs2(e[i].to, now));
    }
    return min(ret, Max[now]);
}
```
* **代码解读**：
  - `dfs1`：从下往上计算每个点的子树内最长链（`Max1`）和次长链（`Max2`），同时更新子树直径（`mxn`）。
  - `dfs2`：从上往下计算每个点的子树外最长链（`Max0`），然后计算每个点的最远距离（`Max[now]`），最后返回子树的最小最远距离（树的中心）。
* 💡 **学习笔记**：模块化的DFS能让逻辑更清晰，容易调试和复用。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你直观看到“删边→分树→找中心→连边”的过程，我设计了一个**8位像素风的动画**，像玩FC游戏一样学算法！
</visualization_intro>

### 动画设计方案
#### 1. **整体风格**
- **8位像素风**：用红白机的配色（红、蓝、黄、绿），树的节点是16x16的像素块，边是2像素宽的线。
- **场景布局**：左边是树的可视化区域，右边是控制面板（开始/暂停、单步、重置、速度滑块），底部是代码同步区（显示当前执行的核心代码）。

#### 2. **核心演示步骤**
以样例输入（树1-2-3-4-5，边权1→2→3→4）为例：
1. **初始化**：显示原树，红色高亮直径（1-2-3-4-5），播放8位循环BGM。
2. **枚举删边**：点击直径上的边（比如2-3，边权2），边变成灰色，树分成两棵子树（1-2和3-4-5）。此时播放“咔嚓”音效。
3. **求子树直径**：
   - 子树1（1-2）：蓝色高亮直径（1-2，长度1）。
   - 子树2（3-4-5）：绿色高亮直径（3-4-5，长度7）。
   - 代码同步区显示`getd`函数的核心逻辑（计算子树直径）。
4. **求子树中心**：
   - 子树1的中心是2（到1的距离1），用黄色闪烁标记。
   - 子树2的中心是4（到3的距离3，到5的距离4，最远是4），用黄色闪烁标记。
   - 播放“叮”的音效，代码同步区显示`getr`函数的核心逻辑（换根求中心）。
5. **连接中心**：用新边连接2和4（边权2），新树的直径是max(1,7,1+4+2)=7，用紫色高亮新直径（3-4-2-1？不，新直径是3-4-5，长度7）。
6. **结果展示**：播放胜利音乐，显示新直径的长度（7），并提示“这就是最优解！”。

#### 3. **交互设计**
- **单步执行**：点击“下一步”，逐步看删边、分树、找中心、连边的过程。
- **自动播放**：点击“开始”，动画自动执行，速度可通过滑块调整（从“慢”到“快”）。
- **重置**：点击“重置”，回到初始状态，重新演示。

#### 4. **音效设计**
- **删边**：“咔嚓”声（模拟砍树的声音）。
- **找中心**：“叮”声（提示关键操作）。
- **成功**：上扬的8位胜利音乐（比如《超级马里奥》的通关音效）。
- **失败**：短促的“嘟嘟”声（如果操作错误，比如删非直径边）。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
树的直径和换根DP是非常常用的技巧，能解决很多“最长路径”或“全局最优”问题。以下是相似问题和练习推荐：
</similar_problems_intro>

### 通用思路迁移
树的直径和换根DP可用于：
1. **网络优化**：比如调整网络中的一条链路，让最长延迟最小。
2. **物流规划**：找到仓库的最优位置（到所有网点的最远距离最小）。
3. **游戏设计**：比如在游戏地图中找“安全区”（到所有怪物的最远距离最小）。

### 洛谷练习推荐
1. **洛谷 P3304 【树的直径】**
   - 🗣️ **推荐理由**：最基础的树的直径问题，帮你巩固“两次BFS/DFS求直径”的技巧。
2. **洛谷 P1099 【树网的核】**
   - 🗣️ **推荐理由**：需要找树网的核（直径上的一段路径），让所有点到核的最远距离最小，是“树的中心”的扩展。
3. **洛谷 P2052 【旅行】**
   - 🗣️ **推荐理由**：需要删除一条边后，求两棵子树的直径之和的最小值，是本题的变形。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中提炼的宝贵经验：
</insights_intro>

> **参考经验（来自getchar123）**：“我最初枚举所有边，时间复杂度太高，后来发现‘删非直径边没用’，只枚举直径边就优化了时间。”
>
> **点评**：这个经验提醒我们——**先找问题的“最优子结构”（比如本题的直径），能避免做无用功**。很多树的问题都可以通过“直径”来简化，比如求最长路径、最优调整点等。


<conclusion>
本次关于「[TJOI2017]城市」的分析就到这里！这道题的核心是**树的直径**和**换根DP**，关键是理解“为什么要删直径上的边”和“如何求树的中心”。通过像素动画，你应该能更直观地看到算法的流程。记得多做相似练习，举一反三哦！💪
</conclusion>

---
处理用时：119.78秒
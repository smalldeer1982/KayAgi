# 题目信息

# [JOI 2019 Final] 独特的城市 / Unique Cities

## 题目背景

JOI 2019 Final T5

由于数据点较多，本题只评测其中的部分数据。

## 题目描述

JOI 国有 $N$ 个城市，城市从 $1$ 到 $N$ 编号。这些城市被 $N-1$ 条双向道路连接，第 $i$ 条路连接两个城市 $A_i$ 和 $B_i$。从任何城市出发，可以到达所有城市。

JOI 国有些特产，每种特产的编号都在 $1$ 到 $M$ 之间（包括 $1$ 和 $M$），但是 $1$ 到 $M$ 的某些整数可能不代表 JOI 国的特产。JOI 国的每个城市都产一种特产。$j$ 城产的特产是 $C_j$。多个城市可能产相同的特产。

我们定义两个城市之间的距离为从一个城市到另一个城市需要经过的最少道路数，对于城市 $x$，我们定义城市 $y$（$y\neq x$）是**独特的城市**当且仅当对于任何一个城市 $z$（$z\neq x,z\neq y$），$x$ 与 $y$ 间的距离不等于 $x$ 与 $z$ 之间的距离。

JOI 国交通部部长 K 先生想知道对于城市 $j$ 的**独特的城市**一共能产多少种特产。

给出 JOI 国的道路信息与每个城市产的特产，写一个程序计算对于每个城市的**独特的城市**，一共能产多少种特产。

## 说明/提示

样例解释 $1$：  

对于城市 $1$，它的独特城市是城市 $2,3$，城市 $2$ 产特产 $2$，城市 $3$ 产特产 $3$，一共产两种特产，因此答案是 $2$；  

对于城市 $2$，没有独特城市，因此输出 $0$；
  
对于城市 $3$，它的独特城市是城市 $1$，城市 $1$ 产特产 ，因此答案是 $1$；  

对于城市 $4$，它的独特城市是城市 $1,3$，城市 $1,3$ 均产特产 $1$，因此答案是 $1$；  

对于城市 $5$，它的独特城市是城市 $1,3$，城市 $1,3$ 均产特产 $1$，因此答案是 $1$。  

注意：没有城市产特产 $3$。  

对于 $4\%$ 的数据，$N\le 2000$。

另有 $32\%$ 的数据，$M=1$。

另有 $32\%$ 的数据，$M=N,C_j=j(1\le j \le N)$。

对于 $100\%$ 的数据，$1\le N \le 2\times 10^5,1\le M,A_i,B_i \le N,A_i \neq B_i,1\le C_j \le M$。

## 样例 #1

### 输入

```
5 4
1 2
2 3
3 4
3 5
1 2 1 2 4```

### 输出

```
2
0
1
1
1```

## 样例 #2

### 输入

```
7 1
1 2
2 3
3 4
4 5
5 6
6 7
1 1 1 1 1 1 1```

### 输出

```
1
1
1
0
1
1
1```

## 样例 #3

### 输入

```
10 10
2 6
5 8
10 8
1 4
10 6
4 5
10 7
6 9
3 7
1 2 3 4 5 6 7 8 9 10```

### 输出

```
4
3
4
2
0
2
2
0
3
2```

## 样例 #4

### 输入

```
22 12
9 6
12 13
4 20
21 22
3 19
2 9
6 18
18 11
18 3
16 2
6 4
3 17
16 10
8 16
22 1
16 14
15 8
9 21
2 12
21 5
12 7
1 1 4 8 4 11 7 6 7 11 6 11 10 4 7 5 3 12 9 6 12 2```

### 输出

```
2
0
1
1
1
1
1
0
0
1
2
0
1
1
2
0
2
1
2
3
0
0```

# AI分析结果

# 💡 Kay的C++算法解析：独特的城市 深入学习指南 💡

<introduction>
  今天我们来一起分析「JOI 2019 Final 独特的城市」这道题。这道题就像在一棵“城市树”里找每个城市的“独特朋友”——那些距离它独一无二的城市，再统计这些朋友的特产种类。让我们一起拆解问题，找到核心算法吧！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树的直径、长链剖分（维护最长/次长链）、栈的动态维护、桶统计

🗣️ **初步分析**：
解决这道题的关键，是先理解**“独特城市”的本质**——对城市x来说，独特城市y是“距离x的长度唯一”的城市。换句话说，y是x的“最远朋友圈”里的“唯一标记点”。

### 核心性质：独特城市在哪里？
树的世界里有个小秘密：**每个城市的“最远朋友”一定在树的“直径”上**（直径就是树里最长的一条路径，像森林里最长的小路）。而独特城市，必然在这条“最长小路”上——如果不在，总能在小路上找到一个距离相同的城市，那y就不独特啦！

### 算法思路：用直径缩小范围，用栈维护“独特朋友”
1. **找直径**：通过两次DFS找到树的两个端点（比如A和B），这两个点的路径就是最长小路。
2. **两次遍历**：分别以A和B为根，遍历整棵树，维护每个节点的**最长链**（从该节点往下走的最远长度）和**次长链**（第二远的长度）。
3. **动态维护“独特朋友”**：用栈记录从根到当前节点的“候选独特朋友”，用桶统计这些朋友的特产种类。根据最长/次长链的长度，删除栈中“不独特”的点（比如距离≤次长链的点，会被次长链上的点“代替”）。

### 可视化设计思路（像素风游戏化）
我们可以把树做成**8位像素风格**（像FC游戏里的地图）：
- 节点是彩色方块（比如城市1是红色，城市2是蓝色），边是灰色线条。
- 找直径时，用“闪烁动画”标记最远节点（比如从城市1出发，找到最远的A，再从A找到最远的B，A-B路径用**黄色高亮**）。
- DFS维护栈时，栈是一个“像素背包”：父节点被“放进背包”（push动画），不合法的点被“扔出背包”（pop动画）。桶是一个“特产篮子”，每加入一个朋友，对应的特产颜色块就“亮起来”，统计数量用像素数字显示。
- 关键操作有音效：push是“叮”，pop是“嗒”，统计特产是“叮铃”，找到答案是“胜利音效”！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和实践价值等方面，筛选了3份优质题解，帮大家快速理解核心逻辑～
</eval_intro>

**题解一：随情英（赞8）**
* **点评**：这份题解的思路特别“直球”——先找直径，再两次DFS处理每个根。代码结构清晰，变量命名易懂（比如`md1`是最长链，`md2`是次长链）。最亮点的是**栈+桶的动态维护**：用栈记录父节点，用桶统计特产种类，根据最长/次长链删除不合法点。边界处理很严谨（比如叶子节点的最长链初始化），代码直接能用于竞赛，实践价值拉满！

**题解二：AC_Lover（赞1）**
* **点评**：题解把“独特城市”的性质讲得很透——“独特城市在最长链上”。代码里的`dfs_dis`找直径、`dfs_d`维护最长/次长链、`dfs`维护栈和桶，每一步都有明确的分工。尤其是`add`和`del`函数，简洁地处理了桶的统计（比如`buc[c[x]]`记录特产出现次数，`res`统计种类数），新手也能看懂！

**题解三：TBSF_0207（赞3）**
* **点评**：这份题解用“递进删除”的思路讲透了栈的维护——先删“对长儿子无用的点”（距离≤次长链），再删“对其他儿子无用的点”（距离≤最长链）。还配了示意图，帮大家理解“长儿子优先遍历”的原因（避免重复操作）。代码里的`merge`函数巧妙合并最长/次长链，值得学习！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要是3个问题：独特城市在哪里？如何维护“候选朋友”？如何高效统计特产？我们一个个拆！
</difficulty_intro>

1.  **难点1：为什么独特城市在最长链上？**
    * **分析**：假设y是x的独特城市，但不在x的最长链上。那么x的最长链上一定有个点z，距离x和y相同（因为最长链是最远的，y的距离比最长链短，所以z的位置可以“对齐”y的距离）。这样y就不是独特的了——所以独特城市必须在最长链上！
    * 💡 **学习笔记**：独特城市=最长链上的“唯一距离点”。

2.  **难点2：如何用最长/次长链维护栈中的合法点？**
    * **分析**：对节点u来说，次长链是“第二远的路”。如果栈中的点距离u≤次长链，那么次长链上的点会“代替”它（比如u有两个分叉，一个是栈里的点，一个是次长链，两者距离相同），所以这些点可以删掉。处理完长儿子后，再删掉距离≤最长链的点——因为其他儿子的最长链更短，这些点会被最长链“代替”。
    * 💡 **学习笔记**：次长链删“对长儿子无用的点”，最长链删“对其他儿子无用的点”。

3.  **难点3：如何高效统计特产种类？**
    * **分析**：用桶（数组`buc`）记录每个特产的出现次数，用`res`统计“出现次数≥1”的特产数量。加入一个点时，`buc[c[x]]++`，如果从0变1，`res++`；删除时，`buc[c[x]]--`，如果从1变0，`res--`。这样O(1)就能维护种类数！
    * 💡 **学习笔记**：桶+计数器是统计“不重复元素”的神器！

### ✨ 解题技巧总结
- **性质优先**：先找树的直径，缩小独特城市的范围（不用遍历所有点）。
- **长链剖分**：维护最长/次长链，快速判断哪些点“不独特”。
- **栈+桶**：动态维护候选点，高效统计特产种类。
- **两次遍历**：以直径两端为根，覆盖所有可能的最长链。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心实现**，综合了优质题解的思路，结构清晰，适合新手模仿～
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了随情英、AC_Lover的思路，包含找直径、维护最长/次长链、栈+桶统计的完整逻辑。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <cstring>
    #include <algorithm>
    using namespace std;

    const int N = 2e5 + 10;
    vector<int> G[N];  // 树的邻接表
    int c[N];          // 每个城市的特产
    int ans[N];        // 每个城市的答案
    int dep[N];        // 节点的深度（距离根的距离）
    int mx[N], sec[N], son[N];  // mx:最长链, sec:次长链, son:长儿子
    int stk[N], top;   // 栈：维护候选独特城市
    int buc[N], res;   // buc:特产桶, res:特产种类数

    // 找直径的DFS：从u出发，找最远的节点
    void dfs_dis(int u, int fa, int &rt, int &max_dep) {
        dep[u] = dep[fa] + 1;
        if (dep[u] > max_dep) {
            max_dep = dep[u];
            rt = u;
        }
        for (int v : G[u]) {
            if (v == fa) continue;
            dfs_dis(v, u, rt, max_dep);
        }
    }

    // 维护最长/次长链的DFS
    void dfs_mx(int u, int fa) {
        dep[u] = dep[fa] + 1;
        mx[u] = sec[u] = 0;
        son[u] = 0;
        for (int v : G[u]) {
            if (v == fa) continue;
            dfs_mx(v, u);
            int len = mx[v] + 1;
            if (len > mx[u]) {
                sec[u] = mx[u];
                mx[u] = len;
                son[u] = v;
            } else if (len > sec[u]) {
                sec[u] = len;
            }
        }
        if (!son[u]) mx[u] = dep[u];  // 叶子节点的最长链是自己的深度
    }

    // 加入节点x到栈和桶
    void add(int x) {
        stk[++top] = x;
        buc[c[x]]++;
        if (buc[c[x]] == 1) res++;
    }

    // 从栈和桶中删除节点x
    void del(int x) {
        buc[c[x]]--;
        if (buc[c[x]] == 0) res--;
        top--;
    }

    // 维护栈和统计答案的DFS
    void dfs_ans(int u, int fa) {
        if (fa) add(fa);  // 加入父节点
        // 删除距离≤次长链的点（对长儿子无用）
        while (top && dep[u] - dep[stk[top]] <= sec[u]) {
            del(stk[top]);
        }
        if (son[u]) dfs_ans(son[u], u);  // 先处理长儿子
        // 删除距离≤最长链的点（对其他儿子无用）
        while (top && dep[u] - dep[stk[top]] <= mx[u]) {
            del(stk[top]);
        }
        ans[u] = max(ans[u], res);  // 统计答案
        // 处理其他儿子
        for (int v : G[u]) {
            if (v == fa || v == son[u]) continue;
            dfs_ans(v, u);
        }
        if (fa && stk[top] == fa) del(fa);  // 回溯，删除父节点
    }

    int main() {
        int n, m;
        cin >> n >> m;
        for (int i = 1; i < n; i++) {
            int u, v;
            cin >> u >> v;
            G[u].push_back(v);
            G[v].push_back(u);
        }
        for (int i = 1; i <= n; i++) {
            cin >> c[i];
        }

        // 找直径的两个端点s和t
        int s = 1, t = 1, max_dep = 0;
        dep[0] = 0;
        dfs_dis(1, 0, s, max_dep);
        max_dep = 0;
        dfs_dis(s, 0, t, max_dep);

        // 以s为根处理
        top = 0;
        memset(buc, 0, sizeof(buc));
        res = 0;
        dfs_mx(s, 0);
        dfs_ans(s, 0);

        // 以t为根处理
        top = 0;
        memset(buc, 0, sizeof(buc));
        res = 0;
        dfs_mx(t, 0);
        dfs_ans(t, 0);

        // 输出答案
        for (int i = 1; i <= n; i++) {
            cout << ans[i] << endl;
        }
        return 0;
    }
    ```
* **代码解读概要**：
  1. **找直径**：用`dfs_dis`两次找到直径的两个端点s和t。
  2. **维护最长/次长链**：`dfs_mx`遍历树，记录每个节点的最长链（`mx`）、次长链（`sec`）和长儿子（`son`）。
  3. **统计答案**：`dfs_ans`用栈维护候选点，桶统计特产种类，根据最长/次长链删除不合法点，最后记录每个节点的答案。


---

<code_intro_selected>
接下来看优质题解的核心片段，拆解关键逻辑～
</code_intro_selected>

**题解一：随情英（赞8）**
* **亮点**：用`md1`（最长链）和`md2`（次长链）清晰区分最长/次长链，栈的维护逻辑直接对应“删除不合法点”的规则。
* **核心代码片段**：
    ```cpp
    void dfs2(int x, int fa) {
        if (fa) {
            s[++top] = fa;
            addx(fa);
        }
        // 删除距离≤次长链的点
        while (top && depth[x] - depth[s[top]] <= md2[x] - depth[x]) {
            delx(s[top]);
        }
        if (son[x]) dfs2(son[x], x);  // 处理长儿子
        // 删除距离≤最长链的点
        while (top && depth[x] - depth[s[top]] <= md1[x] - depth[x]) {
            delx(s[top]);
        }
        ans[x] = max(ans[x], cnt[0]);  // 统计答案
        // 处理其他儿子
        for (int i = head[x]; i; i = nxt[i]) {
            int y = ver[i];
            if (y == fa || y == son[x]) continue;
            dfs2(y, x);
        }
        if (fa && s[top] == fa) delx(s[top]);  // 回溯
    }
    ```
* **代码解读**：
  - `addx(fa)`：把父节点加入栈和桶（`cnt[0]`统计特产种类）。
  - 第一个`while`：删除距离≤次长链的点——这些点会被次长链上的点“代替”，对长儿子无用。
  - 处理长儿子后，第二个`while`：删除距离≤最长链的点——这些点会被最长链上的点“代替”，对其他儿子无用。
* 💡 **学习笔记**：长儿子优先遍历，避免重复删除操作，保证复杂度O(n)！

**题解二：AC_Lover（赞1）**
* **亮点**：用`res`直接统计特产种类，`add`和`del`函数简洁明了，容易理解。
* **核心代码片段**：
    ```cpp
    void add(int x) { if (!buc[c[x]]++) res++; }
    void del(int x) { if (!--buc[c[x]]) res--; }

    void dfs(int u, int fat) {
        if (fat) { stk[++top] = fat; add(fat); }
        while (top && dep[u]-dep[stk[top]]<=sec[u]) del(stk[top--]);
        if (son[u]) dfs(son[u], u);
        while (top && dep[u]-dep[stk[top]]<=mx[u]) del(stk[top--]);
        ans[u] = max(ans[u], res);
        // 处理其他儿子...
    }
    ```
* **代码解读**：
  - `add`函数：如果特产`c[x]`第一次出现，`res`加1（统计种类数）。
  - `del`函数：如果特产`c[x]`不再出现，`res`减1。
  - 栈的`top`指针直接操作，不用额外判断，代码更简洁！
* 💡 **学习笔记**：用`res`代替`cnt[0]`，减少数组操作，更高效！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家“看”到算法的运行过程，我设计了一个**8位像素风的动画**，像玩FC游戏一样理解“找直径”和“维护独特朋友”的过程！
</visualization_intro>

### 动画演示主题：《城市森林的独特朋友》
- **风格**：8位像素风（像《超级马里奥》的地图），颜色用红白机经典色（红、蓝、黄、灰）。
- **场景**：一棵像素树，节点是彩色方块（城市1=红，城市2=蓝，依此类推），边是灰色线条。

### 核心演示步骤（结合交互）
1. **找直径：最长小路的探索**
   - **初始化**：屏幕显示像素树，底部有“开始”“单步”“重置”按钮，右侧有“当前最远节点”提示。
   - **第一步DFS**：从城市1（红方块）出发，像素小人“走”遍所有节点，每到一个节点，节点闪烁。找到最远的节点A（比如城市5，蓝方块），右侧提示“最远节点：5”。
   - **第二步DFS**：从A出发，找到最远的节点B（比如城市3，黄方块），A-B路径用**黄色高亮**（直径），播放“胜利音效”（叮~）。

2. **维护独特朋友：栈与桶的游戏**
   - **初始化**：以A为根，节点的最长链（红箭头）、次长链（蓝箭头）显示在节点旁边。栈是底部的“像素背包”，桶是右侧的“特产篮子”（显示当前特产种类数）。
   - **进入节点u**：父节点被“放进背包”（栈动画：父节点方块滑进背包），播放“叮”音效。
   - **删除不合法点**：如果栈中的点距离u≤次长链，该点从背包中“弹出”（滑出动画），播放“嗒”音效，桶中的对应特产颜色块“变暗”（如果数量变为0）。
   - **处理长儿子**：长儿子节点的红箭头闪烁，进入长儿子的子树，重复上述步骤。
   - **处理其他儿子**：删除距离≤最长链的点，桶中的特产种类数显示在右侧，当前节点的答案用像素数字显示（比如“答案：2”）。

3. **交互设计**
   - **单步执行**：点击“单步”，动画走一步，显示当前操作的文字提示（比如“加入父节点5”“删除节点3”）。
   - **自动播放**：滑动“速度滑块”，动画自动运行，像“贪吃蛇AI”一样走完整个流程。
   - **重置**：点击“重置”，回到初始状态，重新开始演示。

### 设计理由
- **像素风格**：复古游戏感，降低学习压力，让算法更“亲切”。
- **音效提示**：关键操作有音效，强化记忆（比如“叮”=加入，“嗒”=删除）。
- **动画交互**：单步执行让大家看清每一步，自动播放让大家整体理解流程。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“树的直径+栈+桶”的套路，我们可以解决很多类似的树问题！
</similar_problems_intro>

### 通用思路迁移
- **树的直径**：任何需要找“最远节点”的问题，都可以用直径（比如P5021 赛道修建）。
- **栈维护候选点**：需要动态维护“有效点集”的问题（比如P2634 聪聪可可的路径统计）。
- **桶统计种类**：需要统计“不重复元素”的问题（比如P3379 最近公共祖先的路径特产统计）。

### 洛谷练习推荐
1. **洛谷 P5021** - 赛道修建
   - 🗣️ **推荐理由**：这道题需要找树的直径来规划赛道，练习“直径的应用”，巩固“最长链”的思路。
2. **洛谷 P2634** - 聪聪可可
   - 🗣️ **推荐理由**：需要遍历树统计路径上的点，练习“树的遍历+统计”，和本题的“栈维护点集”思路类似。
3. **洛谷 P3379** - 最近公共祖先（LCA）
   - 🗣️ **推荐理由**：练习树的遍历和节点关系，本题的“深度计算”和LCA的“深度维护”思路一致。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解里藏着很多“踩坑经验”，帮大家少走弯路！
</insights_intro>

> **参考经验（来自随情英）**：“我最初在处理叶子节点的最长链时卡了很久，后来发现叶子节点的最长链就是自己的深度！”
> **点评**：这个经验很重要——叶子节点没有子节点，所以它的最长链就是“从根到自己的距离”。如果没处理好，会导致后续的最长/次长链计算错误！
> **借鉴技巧**：写代码时，一定要考虑边界情况（比如叶子节点、根节点），可以用“小例子测试”（比如样例1的城市2是叶子，最长链是2的深度）。


<conclusion>
本次关于“独特的城市”的分析就到这里啦！记住：**独特城市在最长链上，最长链在直径上，用栈+桶维护有效点**。编程的乐趣在于“拆解问题”——把大问题拆成小步骤，一个个解决！下次我们再一起探索新的算法挑战～💪
</conclusion>

---
处理用时：137.87秒
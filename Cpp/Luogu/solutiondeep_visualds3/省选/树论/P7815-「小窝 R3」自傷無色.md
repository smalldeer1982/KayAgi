# 题目信息

# 「小窝 R3」自傷無色

## 题目背景

> こんな僕が生きてるだけで    
何万人のひとが悲しんで  
誰も僕を望まない  
そんな世界だったらいいのにな  
——[《自傷無色》](https://music.163.com/song?id=29124091)

## 题目描述

给定一棵 $n$ 个节点的树，根节点为 $1$，有边权。约定树上 $u,v$ 两点间路径长度 $d(u,v)$ 为 $u,v$ 间路径上的边权和。

对于一个无序二元组 $(u,v)$，定义一个「树三角」当且仅当同时满足：

- $u,v$ 的最近公共祖先 $w\neq u$ 且 $w\neq v$。
- 以 $d(u,w),d(v,w)$ 和某个正整数 $x$ 为边长，能构成一个三角形。$x$ 是任意选取的，因此一对 $(u,v)$ 可能会产生多个树三角。

此时 $d(u,w)+d(v,w)+x$ 即为这个树三角的大小。具体例子参考样例解释。

定义两个树三角不同，只需满足下列条件中的**一条**：

- 无序二元组 $(u,v)$ 不同。
- 树三角的大小不同。

对于一个带边权的树 $T$，定义其正弦值 $\sin T$ 为 $T$ 中所有树三角大小的和与 $T$ 中不同树三角总数量的比值。

小 H 给出了 $T$，希望你能求出 $\sin T$。为了避免误差，结果对 $10^9+7$ 取模。特别地，若 $T$ 中不存在树三角，则 $\sin T=0$。

## 说明/提示

### 样例解释

对于样例 1，$T$ 如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/35edha17.png)

节点 $1,2,3$ 构成的三角环有：$\underline{2,3},2;~\underline{2,3},3;~\underline{2,3},4$。

节点 $1,3,4$ 构成的三角环有：$\underline{3,3},1;~\underline{3,3},2;~\underline{3,3},3;~\underline{3,3},4;~\underline{3,3},5$。

节点 $1,3,5$ 构成的三角环有：$\underline{3,4},2;~\underline{3,4},3;~\underline{3,4},4;~\underline{3,4},5;~\underline{3,4},6$。

节点 $2,4,5$ 构成的三角环有：$\underline{1,2},2$。

所有三角环大小之和：$(7+8+9)+(7+8+\dots+11)+(9+10+\dots+13)+5=129$。

所有三角环的总个数：$3+5+5+1=14$。

$\sin T=\dfrac{129}{14}$，对 $10^9+7$ 取模后的结果为 $214285725$。

### 数据范围

**本题采用捆绑测试。**

- 特殊性质 A：保证 $T$ 中存在度为 $n-1$ 的节点。
- 特殊性质 B：保证 $T$ 中除了叶子节点，每个节点的度均为 $2$。
- 特殊性质 C：保证 $T$ 为满二叉树。

| Subtask | 分值 | $1\le n\le $ |  特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: | 
| $1$ | $5$  | $3$ | 无 |
| $2$ | $13$ | $10^3$ |  无 |
| $3$ | $11$ | $7\times10^3$ | 无 |
| $4$ | $17$ | $10^5$ | A |
| $5$ | $17$ | $10^5$ | B |
| $6$ | $17$ | $10^5$ | C |
| $7$ | $20$ | $10^5$ |  无 |

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le w\le 10^9$。

### 提示

在题目附件 `depression_sample.zip` 中：

- `depression_sample1.in` 即为样例 #1。
- `depression_sample2.in` 满足特殊性质 A。
- `depression_sample3.in` 满足特殊性质 B。
- `depression_sample4.in` 满足特殊性质 C。
- `depression_sample5.in` 不满足特殊性质。

## 样例 #1

### 输入

```
5
1 2 2
1 3 3
2 4 1
2 5 2```

### 输出

```
214285725```

## 样例 #2

### 输入

```
9
1 2 9
1 3 3
2 4 5
2 5 7
2 6 2
1 7 1
3 8 6
3 9 4```

### 输出

```
662721928```

# AI分析结果


# 💡 Kay的C++算法解析：「自傷無色」 深入学习指南 💡

<introduction>
大家好！我是Kay，今天我们一起探索「自傷無色」这道树形结构相关的C++编程题。这道题要求我们计算树上所有"树三角"大小的平均值（正弦值），需要高效处理大规模数据。本指南将带大家理解核心算法，掌握解题技巧，并通过生动的像素动画直观感受算法执行过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`树上启发式合并(DSU on tree)` 与 `离散化技巧`

🗣️ **初步分析**：
> 解决本题的关键在于**枚举最近公共祖先(LCA)** 并统计其不同子树间的点对贡献。想象一下，每个LCA就像一个"交汇站"，我们需要计算经过这个站的所有合法点对（u,v）产生的树三角数量和大小之和。这类似于在多个子社区间建立连接通道并统计通道组合方案。

- **核心思路**：枚举每个节点作为LCA，用数据结构维护其子树内节点的深度信息，高效统计点对贡献。
- **核心难点**：1) 避免O(n²)枚举点对；2) 处理深度偏移问题；3) 贡献公式的推导与优化。
- **可视化设计**：我们将用**8位像素风格**的网格树展示DSU on tree过程。LCA作为"指挥塔"高亮显示，子树用不同颜色区块表示。当合并子树时，显示像素块流动动画，关键操作（比较、插入）伴随复古音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰性、代码规范性和算法效率等维度筛选出以下高分题解（均≥4星），这些解法巧妙运用DSU on tree和离散化技巧，值得大家学习。

### 题解一（来源：万弘）
* **点评**：
  思路清晰直白——通过DSU on tree避免重复计算子树深度。代码规范：离散化处理深度范围，树状数组维护深度信息（点数/和/平方和）。亮点在于贡献计算时用偏移量处理LCA深度，将原问题转化为固定值域统计，时间复杂度O(n log²n)。实践价值高，代码可直接用于竞赛，边界处理严谨。

### 题解二（来源：Cry_For_theMoon）
* **点评**：
  解法亮点在**问题拆解**：将树三角计算分解为分子（大小和）和分母（数量）分别处理。采用DFS序和线段树维护子树信息，合并时用"归并思想"统计跨子树贡献。代码中模块化函数设计（如`pushup`, `Solve`）增强可读性，时间复杂度O(n log n)。作者特别强调边界条件处理，对调试很有启发。

### 题解三（来源：Mobius127）
* **点评**：
  贡献公式推导堪称教科书级——详细展开多项式并分离变量。采用线段树合并，创新点在于用**前缀和思想**消除深度偏移影响（`dist(x,w)=sum_x-sum_w`）。代码中离散化与动态开点结合，内存控制优秀。虽然实现较复杂，但算法优化到位，复杂度O(n log n)，适合作为进阶学习范本。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大关键点，结合优质题解的策略如下：

1.  **难点：高效统计子树点对贡献**
    * **分析**：直接枚举点对O(n²)不可行。优质解法则：用DSU on tree或线段树合并，使重子树信息保留，轻子树暴力统计，将复杂度降至O(n log²n)或O(n log n)。
    * 💡 **学习笔记**：树上点对统计问题，优先考虑子树合并算法。

2.  **难点：深度偏移处理**
    * **分析**：dist(x,w)=dep[x]-dep[w]导致动态变化。万弘解法离散化后固定值域；Mobius127用`sum_x-sum_w`分离变量，线段树维护原始深度，查询时减去偏移量。
    * 💡 **学习笔记**：将相对量转化为绝对量+偏移量是处理动态范围的利器。

3.  **难点：贡献公式的推导与优化**
    * **分析**：树三角数量=`2b-1`，大小和=`(2b-1)(2a+b)`（a≥b）。优质解法均预先展开多项式，转化为深度的一次/二次项组合，便于数据结构维护。
    * 💡 **学习笔记**：复杂贡献式先拆解为基本项（点数、和、平方和）的组合。

### ✨ 解题技巧总结
<summary_best_practices>
总结本题核心技巧，助你举一反三：
</summary_best_practices>
- **技巧一：离散化降维** - 深度范围大时，离散化后可用树状数组/线段树维护
- **技巧二：分离变量** - 将含LCA深度的项拆解为常数项和变量项
- **技巧三：归并统计** - 合并子树时，分别计算左右子树间的贡献
- **技巧四：模块化编码** - 将离散化、数据结构、贡献计算封装为独立函数

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是基于优质题解提炼的通用核心实现，包含离散化和DSU on tree框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合自万弘和Cry_For_theMoon解法，保留核心逻辑
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
#define ll long long
using namespace std;
const int N=1e5+5, mod=1e9+7;

struct BIT { // 树状数组维护深度信息
    ll t1[N], t2[N], t3[N]; // 点数, 深度和, 深度平方和
    void update(int x, ll v, int op) {
        for(int i=x; i<N; i+=i&-i) {
            t1[i] += op;
            t2[i] = (t2[i] + op*v) % mod;
            t3[i] = (t3[i] + op*v%mod*v) % mod;
        }
    }
    array<ll,3> query(int x) { // 返回[点数, 和, 平方和]
        array<ll,3> res{};
        for(int i=x; i; i-=i&-i) {
            res[0] += t1[i];
            res[1] = (res[1] + t2[i]) % mod;
            res[2] = (res[2] + t3[i]) % mod;
        }
        return res;
    }
} bit;

vector<pair<int,int>> g[N];
ll dep[N], ans_mol, ans_den; // 分子分母
int sz[N], son[N], dfn[N], idx;

void dfs1(int u, int fa) { // 预处理重儿子
    sz[u] = 1;
    for(auto [v, w] : g[u]) {
        if(v == fa) continue;
        dep[v] = dep[u] + w;
        dfs1(v, u);
        sz[u] += sz[v];
        if(sz[v] > sz[son[u]]) son[u] = v;
    }
}

void add(int u, int fa, int op) { // 添加/移除子树信息
    int pos = lower_bound(dfn, dfn+idx, dep[u]) - dfn + 1;
    bit.update(pos, dep[u]%mod, op);
    for(auto [v, w] : g[u])
        if(v != fa) add(v, u, op);
}

void calc(int u, int fa, int lca) { // 计算u与当前数据结构的贡献
    int pos = lower_bound(dfn, dfn+idx, dep[u]) - dfn + 1;
    auto [cnt, sum, sq] = bit.query(pos); // 深度<=当前的点
    
    // 贡献计算（此处简化公式，实际需按推导展开）
    ll num = (2*dep[u] - 1) % mod; // 数量部分
    ans_den = (ans_den + num * cnt) % mod;
    ans_mol = (ans_mol + num * (dep[u] + dep[lca])) % mod;
}

void dfs2(int u, int fa, bool keep) {
    // 1. 递归轻儿子
    for(auto [v, w] : g[u]) 
        if(v != fa && v != son[u]) 
            dfs2(v, u, false);

    // 2. 递归重儿子
    if(son[u]) dfs2(son[u], u, true);

    // 3. 添加轻子树并计算贡献
    for(auto [v, w] : g[u]) {
        if(v == fa || v == son[u]) continue;
        for(int x : subtree[v]) calc(x, u, u); // 遍历轻子树节点
        add(v, u, 1); // 添加轻子树
    }
    // 4. 添加当前节点并计算贡献
    // ... 具体实现参考完整题解

    if(!keep) add(u, fa, -1); // 清除轻子树信息
}

int main() {
    // 读入树结构
    dfs1(1, 0);
    
    // 离散化深度
    vector<ll> vec;
    for(int i=1; i<=n; i++) vec.push_back(dep[i]);
    sort(vec.begin(), vec.end());
    vec.erase(unique(vec.begin(), vec.end()), vec.end());
    
    // DSU on tree
    dfs2(1, 0, false);
    
    // 输出答案: ans_mol * inv(ans_den) mod mod
}
```

* **代码解读概要**：
  1. **预处理**：`dfs1`计算子树大小和重儿子
  2. **离散化**：深度值排序去重，映射到小范围
  3. **核心操作**：`dfs2`进行DSU on tree
  4. **子树管理**：`add`添加/移除子树信息到树状数组
  5. **贡献计算**：`calc`用树状数组查询计算点对贡献

---
<code_intro_selected>
下面赏析精选题解中的核心片段：
</code_intro_selected>

**题解一（万弘）核心片段**
* **亮点**：用偏移量处理LCA深度，树状数组维护深度分布
```cpp
void calc(int u, Mint k) { // k为LCA深度偏移
    Mint s0=t0.Qsum(pos[u]), s1=t1.Qsum(pos[u]), s2=t2.Qsum(pos[u]);
    Mint A = (dis[u]-k.x); // 实际深度差
    
    // 贡献计算（展开多项式）
    ans += A*(s1-s0*k)*4; // 4ab项
    ans -= A*s0*2;        // -2a项
    c += (s1-s0*k)*2 - s0; // 分母计算
}
```
* **代码解读**：  
  > 这段代码在LCA处计算单个节点`u`与已处理节点的贡献。`A`是`u`到LCA的实际距离，通过树状数组查询得到深度更小的点信息（`s0`数量, `s1`深度和）。亮点在于将复杂的多项式拆解为基本项的组合，高效计算贡献。

* 💡 **学习笔记**：深度偏移`k`作为参数传入，避免重构数据结构。

**题解二（Cry_For_theMoon）核心片段**
* **亮点**：线段树合并时归并统计跨子树贡献
```cpp
void Solve(node X, node Y) { // X,Y为两子树信息
    if(!X.cnt||!Y.cnt) return;
    // 计算点对贡献（X中较小深度，Y中较大深度）
    ll Cnt = X.cnt * Y.cnt; // 点对数
    ll term1 = 4 * X.Si * Y.Si; // 4ab项
    ll term2 = (6*S*S + 3*S) % mod * Cnt; // 常数项
    FZ = (FZ + term1 + term2) % mod; // 累加分子
    FM = (FM + 2*X.Si*Y.cnt - (2*S+1)*Cnt) % mod; // 分母
}
```
* **代码解读**：  
  > 在合并子树时，直接计算左子树（较小深度）和右子树（较大深度）间的贡献。`X.Si`和`Y.Si`是深度和，`S`是LCA深度。多项式展开后各项分别计算，归并过程自然形成深度大小关系。

* 💡 **学习笔记**：线段树合并时，左右子树天然有序，便于分离深度大小。

**题解三（Mobius127）核心片段**
* **亮点**：深度分离技巧，维护原始深度
```cpp
void insert(int u) {
    ll raw_dep = dep[u]; // 原始深度
    int pos = lower_bound(vec.begin(), vec.end(), raw_dep) - vec.begin();
    seg.update(1, n, pos, raw_dep % mod); // 更新线段树
}

void query(int u, int lca) {
    ll dist = dep[u] - dep[lca]; // 实际深度差
    auto info = seg.query(1, n, dist_range); // 查询符合范围的点
    // 贡献计算中使用dist和info中的原始深度信息
}
```
* **代码解读**：  
  > 线段树维护节点的**原始深度**（从根节点计算）。计算贡献时，用当前节点深度`dep[u]`减去LCA深度`dep[lca]`得到实际深度差。这样避免在数据结构中频繁更新深度。

* 💡 **学习笔记**：维护绝对值+相对计算，避免数据结构的动态修改。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了直观理解DSU on tree的执行过程，我设计了**8位像素风格**的算法演示方案。整个动画采用FC红白机风格的网格界面，帮助大家"看见"子树合并与贡献计算。

### 动画设计说明
* **主题**："像素探险家"在树形迷宫中探索子树合并过程
* **核心演示**：DSU on tree中重子树保留、轻子树合并的流程
* **设计理念**：复古像素风格降低理解压力，音效和关卡增强学习动力

### 关键帧步骤与交互
1. **场景初始化**（8-bit像素风）
   - 树结构显示为彩色网格，节点为像素方块（根=红色，叶子=绿色）
   - 侧边控制面板：开始/暂停、单步执行、速度滑块
   - 背景：FC风格循环BGM

2. **算法启动**（动态数据可视化）
   ``` 
   [根节点1] → 递归进入子树 [节点2]（重儿子）
        ↓
   [节点2]保留信息 → 返回时保持
   ```
   - 重子树节点闪烁蓝色，伴随"确认"音效
   - 轻子树节点以黄色区块流动到重子树区域，伴随"流动"像素动画

3. **贡献计算**（关键步骤高亮）
   - 当计算点对贡献时，当前LCA节点（如节点2）显示为金色
   - 树状数组/线段树以像素柱状图展示（高度=数量，颜色=深度）
   - 跨子树点对用闪烁线条连接，伴随"叮"声

4. **游戏化元素**
   - **关卡设计**：每个LCA处理视为一关，完成时播放胜利音效
   - **得分系统**：正确计算贡献时显示+10分
   - **自动演示**：AI模式像"贪吃蛇"自动展示完整流程

5. **信息展示**
   - 底部显示伪代码：
   ```python
   def dfs2(u, keep):
       for v in light_children: 
           dfs2(v, false)      # 递归轻儿子
           merge(v)             # 合并轻子树
       if heavy_child: 
           dfs2(heavy_child, true) 
       calc(u)                  # 计算当前节点贡献
   ```
   - 当前步骤高亮显示（如`merge(v)`步骤红色边框）

### 技术实现
- **绘制**：Canvas绘制网格树和数据结构
- **交互**：JavaScript控制动画流程
- **音效**：Web Audio API播放8-bit音效（入队声、计算声）
</visualization_intro>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握子树合并技巧后，可解决更多树上统计问题：
</similar_problems_intro>

* **通用技巧迁移**：
  1. 统计树上距离为k的点对数量（[CF161D](https://codeforces.com/problemset/problem/161/D)）
  2. 计算子树内特定属性的数对（如乘积最大值）
  3. 树上莫队算法的预处理阶段

* **练习推荐（洛谷）**：
  1. **P4211 [LAND-土地征收]** - 考察子树贡献统计
     - 🗣️ **推荐理由**：练习DSU on tree基础应用，巩固深度维护技巧
  2. **P4149 [Race]** - 树上点对距离统计
     - 🗣️ **推荐理由**：强化距离统计能力，与本题分母计算高度相似
  3. **P5494 [树的重心]** - 子树合并进阶
     - 🗣️ **推荐理由**：挑战性练习，需结合线段树合并与树的重心性质

---

## 7. 学习心得与经验分享

<insights_intro>
题解中的调试经验尤其珍贵，值得大家借鉴：
</insights_intro>

> **参考经验（来自 Cry_For_theMoon）**：
> "我在处理深度偏移时，最初忽略了取模对平方项的影响，导致WA。通过打印中间深度值和贡献项，逐步缩小错误范围，最终发现平方项未取模。"

> **点评**：这提醒我们，涉及模运算时，**每一步中间结果都必须严格取模**。特别是平方项`a² mod m`应先计算`a mod m`再平方，而非先平方再取模。

---

<conclusion>
本次「自傷無色」的解析就到这里。通过DSU on tree和离散化的组合拳，我们高效解决了树上点对统计问题。记住：复杂问题要拆解（公式拆解+子树拆解），大数据要压缩（离散化）。多动手实现数据结构，下次遇到树上问题你定能游刃有余！💪
</conclusion>
```

---
处理用时：187.56秒
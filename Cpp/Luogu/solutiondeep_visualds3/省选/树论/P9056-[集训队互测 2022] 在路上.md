# 题目信息

# [集训队互测 2022] 在路上

## 题目背景

滥用本题评测者封号。

dottle bot。

## 题目描述

**这是一道交互题，仅支持 C++ 提交**。

有一棵未知的树，**保证树的大小为奇数，你需要找到这棵树重心的编号**。

你可以进行询问，每次询问你可以询问三个点 $(x,y,z)$，若不存在一条简单路径同时经过三个点，则交互器会返回 $0$，否则若存在，那么交互器会返回三个点在路径上相对顺序中间的一个点。

令 $dis(a,b)$ 表示 $a,b$ 两点在树上最短路径经过的边数，你也可以理解为:

若 $dis(x,y)+dis(x,z)=dis(y,z)$，则交互器会返回 $x$。

否则若 $dis(y,x)+dis(y,z)=dis(x,z)$，交互器会返回 $y$。

否则若 $dis(z,x)+dis(z,y)=dis(x,y)$，交互器会返回 $z$。

否则交互器会返回 $0$。

在最终的测试中，每个测试点会包含 $T$ 组测试数据，和一个常数 $M$，表示你在所有测试数据中询问次数总和的上限，具体细则见 输入格式 以及 数据范围。

#### 实现细节

~~你需要引用 `path.h` 头文件。~~ 本题中你只需要把 `path.h` 头文件的内容粘贴到程序开头即可，不要引用 `path.h` 头文件。

你需要实现下面的函数：

```
int centroid(int id,int N,int M);
```

其中 $id$ 为当前子任务的编号，$N$ 为当前询问树的大小，$M$ 为当前测试点剩余的询问次数，函数的返回值为当前树的重心编号。

具体的，在第一次调用时 $M$ 为当前测试点的询问次数上限，每次调用结束之后 $M$ 会减去当前测试点使用的询问次数。

你可以调用下面的函数：

```
int ask(int x,int y,int z);
```

表示你进行了一次询问，交互器会返回当前询问的答案，特别的，若询问次数已经超过了上限，交互器会返回 $-1$。

注意同一个测试点中 `centroid` 函数可能会被多次调用，请注意数组清空等情况。

**下发文件中有样例交互库，该交互库的实现与评测时的交互库几乎一致，如果对交互方式有不理解可以参照交互库的代码理解**。


## 说明/提示

#### 数据范围

![](https://cdn.luogu.com.cn/upload/image_hosting/f3d6b2zv.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

特殊性质 $A$：保证树的形态为一条链，即每个点的度数均不超过 $2$。

保证每个 Subtask 里的测试数据数量均不超过 $20$。**请仔细阅读每一档子任务及其限制**。

#### 时空限制

Subtask 5 时限为 3s。

Subtask 7,8 时限为 4s。

其余 Subtask 时限为 1s。

空间限制：512MB。

保证最终交互库的时间使用不超过  2s，空间使用不超过 64MB。

#### 下发文件

下发文件中有一个样例交互库，提供的交互头文件，一份示例代码，以及一个满足子任务 $4$ 性质的样例，选手也可以按照题目的输入格式构造其他样例。

另外也有一份洛谷样式的交互库。

保证下发的交互库和最终使用的交互库除反作弊之外没有区别，你可以使用这个交互库输出调试信息。

# AI分析结果


### 💡 Kay的C++算法解析：[集训队互测 2022] 在路上 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`树的重心交互探测`（综合：随机化算法、链转化技巧、摩尔投票验证）

🗣️ **初步分析**：
> 想象你在一个黑暗迷宫中摸索一棵树的结构，每次只能用手电筒同时照亮三个点，观察它们是否在一条路径上。本题要求用最少的“光照”（询问）找到树的重心（最平衡的核心点）。核心思想是**随机选两个点作为“主绳”**，将树转化为链结构，再用**带权二分法**在链上逼近重心位置。  
> - **关键技巧**：通过`ask(x,y,z)`返回值将点分类（链上/子树），递归时维护左右子树规模确保重心在链上  
> - **可视化设计**：像素网格中动态生成链（亮色像素路径），随机点用闪光效果，子树用颜色区块区分。单步执行时高亮当前操作点，音效标记分类操作（如"叮"声入队，"咔"声分类成功）  
> - **游戏化元素**：设置"探险进度条"表示递归深度，每层通关解锁新地图，BGM随递归深度变化音调  

---

#### 2. 精选优质题解参考
**题解（作者：DaiRuiChen007）**  
* **点评**：  
  思路清晰度 ⭐⭐⭐⭐☆ 将复杂树问题转化为链上二分，通过四类点分类（L/R/C/S）巧妙处理子树关系  
  代码规范性 ⭐⭐⭐⭐ 使用`vector<int>`分组存储，变量名`L/R/C/S`直观体现点集性质  
  算法有效性 ⭐⭐⭐⭐⭐ 随机链转化+带权二分使期望询问次数仅**O(n)**，摩尔投票验证重心极富创意  
  实践价值 ⭐⭐⭐⭐ 完整处理链/树多场景，边界用`chk`函数二次验证，可直接用于竞赛  

---

#### 3. 核心难点辨析与解题策略
1. **难点：如何将树结构转化为可处理的链？**  
   * **解法**：随机选两点`l,r`作链端点，用`ask(i,l,r)`将其他点分类：  
     - 返回`l/r` → 加入`L/R`（端点子树）  
     - 返回非零非端点 → 加入`C`（链上点）  
     - 返回`0` → 加入`S`（待定点）  
   * 💡 **学习笔记**：随机链包含重心的概率＞50%，期望两次即可命中  

2. **难点：链上如何快速定位重心？**  
   * **解法**：在链`C`上随机选点`k`，用`ask(l,k,i)`细分链上点：  
     - 返回`i` → `i`在`l`→`k`段（归`CL`）  
     - 否则 → `i`在`k`→`r`段（归`CR`)  
   * 💡 **学习笔记**：比较`L+CL+SL`与`R+CR+SR`的大小，递归较大侧  

3. **难点：如何验证候选点是重心？**  
   * **解法**：摩尔投票法！遍历点集时：  
     - `ask(rt,i,col)==rt` → 不同子树（计数减）  
     - 否则 → 同子树（计数加）  
     * 验证最大子树≤n/2即通过  
   * 💡 **学习笔记**：摩尔投票将子树验证复杂度从O(n²)降至O(n)  

### ✨ 解题技巧总结
- **随机锚定法**：随机选链端点转化问题，避免最坏情况  
- **四象限分类**：用`L/R/C/S`清晰管理点集关系  
- **投票验证**：摩尔投票快速定位绝对众数子树  

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合题解思路优化）**  
```cpp
#include<bits/stdc++.h>
using namespace std;
extern "C" int ask(int x,int y,int z);
mt19937 rnd;

vector<int> L,R,C,S; // 四类点集
int n;

// 摩尔投票验证重心
int chk(int rt, vector<int> V) {
    int cnt=0, col=0;
    for(int i:V) {
        if(!cnt) ++cnt, col=i;
        else if(ask(rt,i,col)==rt) --cnt; // 不同子树抵消
        else ++cnt;                       // 同子树叠加
    }
    if(!cnt) return rt; // 无绝对众数
    int tot=0;
    for(int i:V) if(ask(rt,col,i)!=rt) ++tot; // 统计子树大小
    return (tot<=n/2) ? rt : -1;
}

// 核心递归：l,r链端点，L/R端点子树，C链上点，S游离点
int solve(int l,int r,vector<int> L,vector<int> R,vector<int> C,vector<int> S) {
    if(L.size()>n/2) return chk(l,L);   // 左子树过大
    if(R.size()>n/2) return chk(r,R);   // 右子树过大
    if(C.size()==2) {                    // 链仅剩两点
        vector<int> tmp=C; 
        for(int i:R) tmp.push_back(i);
        int z=chk(l,tmp);                // 验证左端点
        if(z!=-1) return z;
        // 否则验证右端点（代码略）
    }
    // 在链上随机选点k（非端点）
    int k=l;
    while(k==l||k==r) k=C[rnd()%C.size()]; 

    vector<int> CL,CR,SK,SL,SR;
    for(int i:C) if(i!=k) {              // 细分链上点
        if(ask(l,k,i)==i) CL.push_back(i); // 在l~k段
        else CR.push_back(i);              // 在k~r段
    }
    for(int i:S) {                       // 细分游离点
        if(ask(l,k,i)==k && ask(r,k,i)==k) SK.push_back(i); // k的子树
        else if(ask(r,k,i)==r) SR.push_back(i);  // r的子树
        else SL.push_back(i);             // l的子树
    }
    // 计算左右权重（代码略），递归权重大的链段
}

// 主接口
extern "C" int centroid(int id,int N,int M) {
    n=N;
    while(true) {
        int l=rnd()%n+1, r=rnd()%n+1;
        if(l==r) continue;
        // 初始化四类点集（代码略）
        int k=solve(l,r,L,R,C,S);
        if(k!=-1) return k;
    }
}
```

**代码解读概要**：  
> 1. **四类点管理**：用`L/R`存端点子树点，`C`存链上点，`S`存游离点  
> 2. **递归剪枝**：若某子树＞n/2立即验证对应端点  
> 3. **摩尔投票**：两轮扫描验证子树平衡性，避免O(n²)开销  

---

#### 5. 算法可视化：像素动画演示  
![](https://cdn.luogu.com.cn/upload/image_hosting/7y9w4vqk.png)  
* **主题**：8-bit迷宫探险家  
* **核心机制**：  
  1. **动态链生成**：绿色像素路径连接`l`→`r`，新点加入时路径延伸  
  2. **点分类特效**：  
     - `L/R`点 → 左/右蓝色区块  
     - `C`点 → 路径上黄色闪光点  
     - `S`点 → 灰色待定区（点击显示分类过程）  
  3. **递归进度条**：底部能量条表示当前递归深度，满格时通关  
* **交互控制**：  
  - `A键`：随机新链端点（重置迷宫）  
  - `方向键`：单步执行分类  
  - `空格`：自动演示（像素小人沿链移动）  
* **音效设计**：  
  - 分类成功：8-bit "叮"声  
  - 递归深入：BGM升调  
  - 找到重心：通关胜利音效  

---

#### 6. 拓展练习与相似问题
1. **洛谷 P1364** 医院设置（树重心基础应用）  
   → 巩固重心性质与子树规模计算  
2. **洛谷 P5536** 核心节点（树直径+重心综合）  
   → 强化链转化技巧的变式应用  
3. **洛谷 P7963** 棋局（交互题思维拓展）  
   → 训练复杂交互逻辑抽象能力  

---

#### 7. 学习心得与经验分享
> 本次题解未包含作者调试心得，但Kay强调：  
> **关键陷阱**：游离点`S`需用`ask(l,k,i)`和`ask(r,k,i)`双重验证！  
> **调试技巧**：对拍时用静态树模拟交互库，打印点分类矩阵辅助分析  

---

通过本次解析，我们掌握了树重心交互题的三大核心技能：**随机链转化**、**带权二分**和**摩尔投票验证**。记住，好的算法如同在黑暗中编织光之路径——用最少的探询照亮答案！💪

---
处理用时：253.37秒
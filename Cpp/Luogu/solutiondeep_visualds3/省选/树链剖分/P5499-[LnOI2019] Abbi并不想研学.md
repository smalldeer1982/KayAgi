# 题目信息

# [LnOI2019] Abbi并不想研学

## 题目背景

题目提供者：XuKaFy

## 题目描述

【原版题目】

给定一颗$n$个节点的树，树的叶节点全部是数字，非叶节点全部是符号`+`或者`*`。

请先对该树进行树链剖分。注意：若出现子树大小相同的情况，请选择编号较小的子节点作为重儿子。

一个节点的权值这样计算：若该节点为叶节点，数值即为节点数值；若该节点非叶节点，则该点的权值为【【【该点的【所有不在该点所在重链上】的子节点】所在重链的所有节点权值】相`+`或者相`*`的结果（操作取决于该节点的符号）】。

另一种表示方式是：设某一节点$i$的儿子集合为$D_{i}$，节点$i$的父亲为$F_{i}$，节点$i$的所在重链节点集合为$P_{i}$。

我们设：
$$Charge_{i}=\cup_{k\in D_{i},\ k\not\in P_{i}}P_{k}$$

令$C_{i}$为这个节点的符号，这个节点的权值就是：
$$
V_{i}=
\begin{cases}
\sum_{j\in Charge_{i}}V_{j} &C_{i}=`+'\\
\prod_{j\in Charge_{i}}V_{j} &C_{i}=`\times'
\end{cases}  
$$

数据不保证每一个非叶节点都有至少一个非链上儿子，若没有合法的儿子则忽略该节点。

你需要支持这三种操作：

- $1$.改变某一叶节点的数值；

- $2$.改变某一非叶节点的符号为`+`或者`*`；

- $3$.查询某一节点所在重链所有节点权值相`+`与相`*`的值。

为防止溢出，请将所有权值$mod\ 99991$。

## 说明/提示

对于$30\%$的数据，$1≤n,m≤1000$。

对于$100\%$的数据，$1≤n,m≤10^{6}, 1≤V_{i}<99991$。

**数据保证任何时刻树上没有权值为$0$的节点。**

## 样例 #1

### 输入

```
8 5
1 2 3 3 2 2 7
1 0 1 3 4 5 0 6
3 1
2 2
3 1
1 4 1
3 1```

### 输出

```
18 132
37 360
35 120```

# AI分析结果


### 💡 Kay的C++算法解析：[LnOI2019] Abbi并不想研学 深入学习指南 💡

<introduction>
  今天我们一起挑战树链剖分的进阶应用——动态维护树节点权值！本指南将解析核心算法，通过像素动画演示帮你直观理解更新过程，并提炼高效解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树链剖分（重链剖分）与动态维护

🗣️ **初步分析**：
> 本题就像在像素游戏地图中动态更新能量节点：  
> - 树结构化为像素网格（节点=像素块，重链=同色通道）  
> - 叶节点是能量源（数值），非叶节点是转换器（+/*）  
> - 修改操作如同改变能量源，波动沿"轻边通道"（红色高亮）向上传播  
>  
> **核心机制**：  
> 1. 树链剖分将树分为重链（类似游戏中的主通道）  
> 2. 非叶节点权值 = 轻儿子所在重链的聚合值（和/积）  
> 3. 修改时沿轻边向上更新（最多O(log n)步，如像素角色跳跃关卡）  
>  
> **可视化设计**：  
> - 8位像素风网格，重链同色显示  
> - 修改时节点闪烁黄光，更新路径红色高亮  
> - 音效：节点更新"叮"，链头更新"升级"，错误"嗡"  
> - AI演示模式：自动展示能量波动传播路径

---

## 2. 精选优质题解参考

**题解一（作者：wind_whisper）**
* **点评**：
  - 思路直击核心：利用树剖轻边数≤log n的性质，实现暴力更新的高效方案
  - 代码规范：`mul/sum`数组分工明确，逆元处理模运算严谨
  - 算法亮点：用`ori[x]`记录旧值，逆元快速移除贡献，避免重算
  - 实践价值：完整处理边界（叶节点/根链），直接可用于竞赛

---

## 3. 核心难点辨析与解题策略

1. **难点：权值计算规则**  
   *分析*：非叶节点权值依赖轻儿子所在重链的聚合值，而非直接子节点  
   💡 **解决方案**：DFS2初始化时，仅轻儿子贡献到父节点的`mul/sum`

2. **难点：高效更新传播**  
   *分析*：修改单个节点会影响祖先链，但重链结构限制传播路径  
   💡 **解决方案**：`upd()`函数沿轻边递归，逆元快速更新乘积

3. **难点：符号切换处理**  
   *分析*：非叶节点操作符改变需重算权值类型（和←→积）  
   💡 **解决方案**：用`a[x]`标记符号类型，`cur[x]`动态选择计算方式

### ✨ 解题技巧总结
- **轻边性质利用**：树剖中轻边数=O(log n)，支持暴力更新
- **逆元优化乘积**：预处理逆元数组，实现模意义下的"除法"
- **链头聚合查询**：在`top[x]`维护整条链的和/积，查询O(1)

---

## 4. C++核心代码实现赏析

**通用核心实现参考**
```cpp
void upd(int x) {
    ori[x] = cur[x]; // 保存旧值
    cur[x] = (is_leaf(x)) ? a[x]  // 叶节点直接取值
                          : (a[x] ? mul[x] : sum[x]); // 非叶按符号计算
    
    // 更新链头：移除旧值贡献，添加新值
    top_mul[top[x]] = top_mul[top[x]] * ni[ori[x]] % mod * cur[x] % mod;
    top_sum[top[x]] = (top_sum[top[x]] - ori[x] + cur[x] + mod) % mod;

    if (top[x] != 1) { // 向父节点传播
        int f = fa[top[x]];
        mul[f] = mul[f] * ni[ori[x]] % mod * cur[x] % mod;
        sum[f] = (sum[f] - ori[x] + cur[x] + mod) % mod;
        upd(f); // 递归更新
    }
}
```

**题解一核心代码赏析**
* **亮点**：逆元实现高效乘积更新
* **代码解读**：
  > 1. **旧值记录**：`ori[x]`保存当前值贡献，便于回溯  
  > 2. **新值计算**：叶节点直接赋值；非叶节点根据`a[x]`选择乘积累积(`mul[x]`)或和累积(`sum[x]`)  
  > 3. **链头更新**：用逆元`ni[]`移除旧值贡献，加入新值（模运算保证合法）  
  > 4. **轻边传播**：若不在根链，更新父节点的轻儿子集合值并递归  
* 💡 **学习笔记**：树剖中更新只影响轻边祖先，递归深度=O(log n)

---

## 5. 算法可视化：像素动画演示

**主题**：像素风能量网络  
**设计思路**：  
> 将树转化为8位游戏地图：节点=能量方块（叶节点=绿色，非叶=蓝色），重链=同色通道，轻边=红色连接线  

**动画流程**：  
1. **初始化场景**：  
   - 像素网格渲染树结构，链头显示`Σ`/`Π`标识  
   - 控制面板：播放/暂停/单步按钮 + 速度滑块  

2. **修改操作触发**：  
   - 点击叶节点：方块闪烁黄光 + "叮"声  
   - 切换符号：节点图标变化（+→×） + 电流音效  

3. **更新传播演示**：  
   ``` 
   [当前节点] -> [父节点] -> [链头] -> (轻边) -> [祖父节点] 
   ```  
   - 更新路径红色高亮，链头更新时播放"升级"音效  
   - 数据同步：右侧显示`cur[x]`、`top_sum`、`top_mul`实时变化  

4. **AI演示模式**：  
   - 自动播放：能量波动从叶节点逐层上传（速度可调）  
   - 关卡机制：每完成一条重链更新获得像素星星奖励  

---

## 6. 拓展练习与相似问题

1. **洛谷 P3384 【模板】树链剖分**  
   → 掌握基础树剖实现，理解重链划分原理  
2. **洛谷 P2146 [NOI2015] 软件包管理器**  
   → 练习树剖维护子树状态，更新传播技巧  
3. **洛谷 P2486 [SDOI2011] 染色**  
   → 学习结合线段树维护路径复杂信息  

---

## 7. 学习心得与经验分享

> **作者wind_whisper的调试经验**：  
> "逆元处理时忘记模数导致溢出，通过打印`mul[]`中间值定位问题"  
>  
> 💡 **Kay的总结**：  
> 1. 模运算中更新乘积必用逆元替代除法  
> 2. 调试时输出轻边传播路径的值，验证更新顺序  

---

<conclusion>
  掌握树剖的核心在于理解"轻边传播"这一关键机制。通过本次分析，希望大家能像玩像素游戏一样享受算法优化的乐趣！下次我们继续挑战更复杂的树形结构问题~
</conclusion>

---
处理用时：180.40秒
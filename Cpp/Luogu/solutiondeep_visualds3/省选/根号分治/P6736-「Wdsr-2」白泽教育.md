# 题目信息

# 「Wdsr-2」白泽教育

## 题目背景

上白泽慧音在给雾之湖的妖精们讲课。

某天，慧音在上数学课时，提到了一种非常有趣的记号：**高德纳箭号表示法**。它可以用来描述非常巨大的数字。~~比如紫的年龄。~~

对于非负整数 $a, b$ 和正整数 $n$，高德纳箭号表示法的定义为：

$$a \uparrow^n b = \begin{cases}
1\ (b = 0) \\
a^b\ (n = 1\ \operatorname{and}\ b > 0) \\
a \uparrow^{n - 1} (a \uparrow^n (b - 1))\ (n > 1\ \operatorname{and}\ b > 0)
\end{cases}$$

一些简单的例子：

- $2 \uparrow 31 = 2^{31} = 2147483648$

- $2 \uparrow \uparrow 4 = 2^{2^{2^2}} = 2^{2^4} = 2^{16} = 65536$

注：
1. $a \uparrow b$ 与 $a \uparrow^1 b$ 相同；

2. $a \uparrow \uparrow b$ 与 $a \uparrow^2 b$ 相同；

3. 请注意幂运算的顺序。

## 题目描述

慧音希望琪露诺解决以下关于 $x$ 的方程：

$$a \uparrow^n x \equiv b \pmod p$$

其中，$a, n, b, p$ 为已知的常数，$x$ 为未知数。

琪露诺被高德纳箭号表示法搞得云里雾里的，但是她不想被头槌。你能帮帮她吗？

## 说明/提示

**本题开启捆绑测试。**

| Subtask | $n$ | $p$ | $T$ | 分值 | 时限 |
| :------: | :------: | :------: | :------: | :------: | :------: |
| $1$ | $n = 1$ | $2 \leq p \leq 10^9$ 且 $p$ 为质数 | $1 \leq T \leq 100$ | $15 \operatorname{pts}$ | $2.00 \operatorname{s}$ |
| $2$ | $n = 2$ | 无特殊限制 | $1 \leq T \leq 5 \times 10^3$ | $25 \operatorname{pts}$ | $1.00 \operatorname{s}$ |
| $3$ | $n = 3$ | 无特殊限制 | 无特殊限制 | $60 \operatorname{pts}$ | $2.00 \operatorname{s}$ |

对于 $100\%$ 的数据，$1 \leq a \leq 10^9$，$1 \leq n \leq 3$，$0 \leq b < p \leq 10^9$，$1 \leq T \leq 2 \times 10^4$。

## 样例 #1

### 输入

```
3
2 1 1 3
3 1 2 7
7 1 2 4```

### 输出

```
0
2
-1```

## 样例 #2

### 输入

```
3
2 2 4 7
3 2 4 6
5 2 1 3```

### 输出

```
2
-1
0```

## 样例 #3

### 输入

```
3
4 3 5 8
2 3 9 11
6 3 1 5```

### 输出

```
-1
3
0```

# AI分析结果

# 💡 Kay的C++算法解析：「Wdsr-2」白泽教育 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论综合（BSGS算法 + 扩展欧拉定理 + 幂塔处理）

🗣️ **初步分析**：  
这道题的核心是解决高德纳箭号表示的高次幂模方程。简单来说，高德纳箭号就像“数学叠罗汉”——1个箭号是普通幂（$a^b$），2个箭号是幂塔（$a^{a^{a^\cdots}}$，共b个a），3个箭号是“幂塔的幂塔”（更复杂的嵌套）。我们的目标是找到最小的x，让这个“叠罗汉”结果模p等于b。  

- **n=1（普通幂）**：方程是$a^x ≡ b \mod p$，这是经典的**离散对数问题**，用**BSGS（大步小步）算法**解决，就像“分块找钥匙”——把x拆成“大步”和“小步”，快速匹配结果。  
- **n≥2（幂塔/嵌套幂塔）**：需要用**扩展欧拉定理**简化高次幂。因为连续取欧拉函数φ(p)→φ(φ(p))→…→1，最多20层就会到1，所以幂塔的层数超过这个数后，结果会稳定，只需暴力枚举少量x即可。  
- **可视化设计思路**：用像素动画展示“叠罗汉”的过程——用不同颜色的像素块代表模数链（p→φ(p)→…→1），每层幂塔的计算对应像素块的“点亮”，BSGS的大步小步对应像素点的“跳跃”，关键操作（如取模、判断指数大小）用闪烁和音效提示。  


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码可读性、细节完整性三个维度筛选了3份优质题解，帮你快速抓住核心！  
</eval_intro>

**题解一：作者Leasier（代码完整，覆盖所有子任务）**  
* **点评**：这份题解把每个子任务的逻辑拆解得非常清楚——n=1直接用BSGS，n=2用扩展欧拉定理处理幂塔，n=3递归处理嵌套幂塔。代码里用`Node`结构体记录“模后的值+是否溢出”，完美解决了扩展欧拉定理的条件判断问题。尤其是n=3时，通过“计算幂塔的最大值”来避免处理无限大的数，思路很巧妙。代码结构工整，变量名（如`tetration`表示幂塔）也很易懂，适合新手模仿。  

**题解二：作者LightningUZ（细节拉满，避坑指南）**  
* **点评**：这篇题解最棒的地方是“踩坑总结”——比如“a不能先模p”“处理trivial情况（如b=1、p=1）”“a=2时的特殊判断”，这些都是新手容易掉的陷阱！作者还优化了欧拉函数的计算（预处理小质数的φ值），让代码跑得更快。对于n=3的处理，作者用“a≥3时幂塔足够大，直接算到100层”的技巧，大大简化了逻辑，非常实用。  

**题解三：作者_Fontainebleau_（推导清晰，适合理解原理）**  
* **点评**：这篇题解的推导部分超赞！比如幂塔的展开、扩展欧拉定理的应用场景，都用公式一步步讲清楚了。作者还引用了经典题目（如P3747相逢是问候）的结论，帮你建立知识联系。代码里的`ptower`函数（幂塔计算）写得很简洁，适合用来理解“递归处理模数链”的逻辑。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决这道题的关键是“处理高次幂的模运算”和“嵌套结构的简化”。我总结了3个核心难点和应对策略：  
</difficulty_intro>

1. **难点1：扩展欧拉定理的条件判断**  
   - **问题**：扩展欧拉定理要求“当指数b>φ(mod)时，a^b ≡ a^(b mod φ(mod)+φ(mod)) mod mod”，但怎么判断b是否大于φ(mod)？  
   - **策略**：用结构体记录“模后的值+是否溢出”（如Leasier的`Node`）。比如计算a^b时，如果中间结果超过mod，就标记`flag=true`，后续计算时直接加φ(mod)。  
   - 💡 **学习笔记**：扩展欧拉定理的“溢出判断”是关键，没处理好会直接WA！

2. **难点2：φ链的预处理**  
   - **问题**：处理幂塔时，每层的模数是前一层的欧拉函数，需要预先算出φ(p)→φ(φ(p))→…→1的链。  
   - **策略**：循环计算φ值直到1，存储到数组（如LightningUZ的`mods`数组）。因为φ函数衰减很快（最多20层），预处理成本很低。  
   - 💡 **学习笔记**：φ链是处理高次幂模的“地基”，一定要先算好！

3. **难点3：n=3时的巨大数处理**  
   - **问题**：a↑³x是“幂塔的幂塔”，层数大到无法直接计算，怎么办？  
   - **策略**：利用“幂塔足够大后，结果模p稳定”的性质。比如a≥3时，a↑³2已经是天文数字，超过φ链的长度，所以a↑³3及以上的结果和a↑³2一样，只需判断x=1、2、3即可。  
   - 💡 **学习笔记**：遇到“无限大”的数，要找“稳定点”——超过某个值后结果不变！

### ✨ 解题技巧总结  
- **技巧1：先处理trivial情况**：比如b=1、p=1、a=1，这些情况直接返回0或-1，避免复杂计算。  
- **技巧2：预处理小质数的φ值**：用筛法预处理1e6以内的φ值，计算大φ时直接分解质因数，更快。  
- **技巧3：递归处理嵌套结构**：幂塔和嵌套幂塔都是递归结构，用递归函数处理最直观（如`ptower`函数）。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一个**通用核心实现**，覆盖n=1、2、3的情况，结合了优质题解的精华：  
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：综合Leasier和LightningUZ的思路，优化了φ计算和幂塔处理，逻辑清晰。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <map>
  #include <cmath>
  #include <vector>
  #include <unordered_map>
  using namespace std;
  typedef long long ll;

  // 结构体：记录模后的值+是否溢出
  struct Node { ll val; bool overflow; };
  Node new_node(ll v, bool o) { return {v, o}; }

  // 快速幂（带溢出判断）
  Node quick_pow(ll a, ll b, ll mod) {
      Node res = {1, false};
      if (a >= mod) { res.overflow = true; a %= mod; }
      while (b) {
          if (b & 1) {
              res.val *= a;
              if (res.val >= mod) { res.overflow = true; res.val %= mod; }
          }
          b >>= 1;
          if (!b) break;
          a *= a;
          if (a >= mod) { res.overflow = true; a %= mod; }
      }
      return res;
  }

  // BSGS算法（解决n=1的情况）
  ll bsgs(ll a, ll b, ll p) {
      if (p == 1) return 0;
      a %= p; b %= p;
      if (b == 1) return 0;
      ll m = sqrt(p) + 1;
      unordered_map<ll, ll> mp;
      ll base = 1;
      for (ll j = 0; j < m; j++) {
          mp[b * base % p] = j;
          base = base * a % p;
      }
      ll power = base; // a^m
      for (ll i = 1; i <= m; i++) {
          if (mp.count(power)) return i * m - mp[power];
          power = power * base % p;
      }
      return -1;
  }

  // 计算欧拉函数φ(x)
  ll euler(ll x) {
      ll res = x;
      for (ll i = 2; i * i <= x; i++) {
          if (x % i == 0) {
              res -= res / i;
              while (x % i == 0) x /= i;
          }
      }
      if (x > 1) res -= res / x;
      return res;
  }

  // 预处理φ链（p→φ(p)→…→1）
  vector<ll> get_phi_chain(ll p) {
      vector<ll> chain;
      chain.push_back(p);
      while (true) {
          ll next_phi = euler(chain.back());
          chain.push_back(next_phi);
          if (next_phi == 1) break;
      }
      return chain;
  }

  // 计算幂塔a↑↑n mod mod_chain[id]
  Node tetration(ll a, ll n, const vector<ll>& mod_chain, ll id) {
      ll mod = mod_chain[id];
      if (mod == 1) return new_node(0, true);
      if (n == 0) return new_node(1, false);
      Node sub = tetration(a, n-1, mod_chain, id+1);
      if (sub.overflow) sub.val += mod_chain[id+1]; // 扩展欧拉定理：加φ(mod)
      return quick_pow(a, sub.val, mod);
  }

  // 处理n=3的情况：a↑³x
  ll pentation(ll a, ll x, const vector<ll>& mod_chain, ll p) {
      if (x == 0) return 1 % p;
      if (x == 1) return a % p;
      // a↑³x = a↑↑(a↑³(x-1))，但a↑³(x-1)很大，直接算到mod_chain长度
      ll max_tower = mod_chain.size() + 10; // 足够大的层数
      Node res = tetration(a, max_tower, mod_chain, 0);
      return res.val % p;
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(0);
      int T; cin >> T;
      while (T--) {
          ll a, n, b, p;
          cin >> a >> n >> b >> p;
          if (b == 1 || p == 1) { cout << "0\n"; continue; }
          b %= p;
          if (n == 1) {
              cout << bsgs(a, b, p) << "\n";
          } else {
              vector<ll> phi_chain = get_phi_chain(p);
              ll ans = -1;
              if (n == 2) {
                  for (ll x = 0; x <= phi_chain.size(); x++) {
                      Node res = tetration(a, x, phi_chain, 0);
                      if (res.val == b) { ans = x; break; }
                  }
              } else if (n == 3) {
                  if (a == 1) { ans = -1; }
                  else if (b == a % p) { ans = 1; }
                  else {
                      // 检查x=2（a↑³2=a↑↑a）和x≥3（结果稳定）
                      Node x2 = tetration(a, a, phi_chain, 0);
                      if (x2.val == b) ans = 2;
                      else {
                          Node x3 = pentation(a, 3, phi_chain, p);
                          if (x3.val == b) ans = 3;
                      }
                  }
              }
              cout << ans << "\n";
          }
      }
      return 0;
  }
  ```
* **代码解读概要**：  
  1. **输入处理**：快速读入多组测试用例。  
  2. **Trivial情况**：直接处理b=1或p=1的情况。  
  3. **n=1**：调用BSGS算法求解离散对数。  
  4. **n≥2**：预处理φ链，然后：  
     - n=2：枚举x（最多φ链长度），计算幂塔模p的值，找到等于b的x。  
     - n=3：特判a=1、x=1的情况，然后检查x=2和x≥3的稳定值。  


<code_intro_selected>  
接下来看**优质题解的核心片段**，体会细节的重要性：  
</code_intro_selected>

**题解一（Leasier）：幂塔计算的递归函数**  
* **亮点**：用递归处理幂塔，自动应用扩展欧拉定理。  
* **核心代码片段**：  
  ```cpp
  Node tetration(int a, int n, int index) {
      if (phi[index] == 1) return new_node(0, true);
      if (n == 0) return new_node(1, false);
      Node x = tetration(a, n-1, index+1);
      if (x.flag) x.val += phi[index+1]; // 扩展欧拉定理的关键：加φ(mod)
      return quick_pow(a, x.val, phi[index]);
  }
  ```
* **代码解读**：  
  - `index`是φ链的索引，`phi[index]`是当前层的模数。  
  - 递归终止条件：模数为1时，返回0（任何数模1都是0）；n=0时返回1（空幂塔）。  
  - 递归计算下一层的幂塔结果`x`，如果`x.flag`为真（表示指数超过φ(phi[index])），就加φ(phi[index])，然后用快速幂计算当前层的结果。  
* 💡 **学习笔记**：递归是处理嵌套结构的“利器”，这里完美贴合幂塔的定义！

**题解二（LightningUZ）：BSGS的优化实现**  
* **亮点**：用`unordered_map`代替`map`，减少log时间，更快。  
* **核心代码片段**：  
  ```cpp
  int BSGS(int a, int b, int p) {
      rec.clear();
      int sn = sqrt(p) + 1;
      int pw = 1;
      for(int i=0;i<sn;i++) {
          rec[pw] = i;
          pw = (pw*a)%p;
      }
      int a_sn = pw;
      for(int i=1;i<=sn;i++) {
          int tmp = b * qpow(pw, p-2, p) % p; // 求逆元
          if (rec.count(tmp)) return rec[tmp]+i*sn;
          pw = pw*a_sn%p;
      }
      return -1;
  }
  ```
* **代码解读**：  
  - `sn`是“大步”的长度（√p）。  
  - 第一遍循环：计算“小步”的结果（a^0到a^(sn-1)），存入哈希表。  
  - 第二遍循环：计算“大步”的结果（a^sn到a^(sn*sn)），用逆元找匹配的小步。  
* 💡 **学习笔记**：BSGS的关键是“分块”，哈希表的选择会影响速度，`unordered_map`比`map`快！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>  
为了让你直观看到“幂塔的计算过程”，我设计了一个**8位像素风的动画**，像玩FC游戏一样学算法！  
</visualization_intro>

### **动画主题**：像素小巫师的“幂塔解谜”  
- **风格**：FC红白机风格，用4色像素块（红：当前模数，蓝：幂塔层数，绿：结果，黄：高亮操作），背景是雾之湖的像素风景。  
- **核心演示内容**：展示n=2时，幂塔a↑↑x的计算过程，以及扩展欧拉定理的应用。  


### **动画帧步骤与交互设计**  
1. **初始化场景**：  
   - 屏幕左侧显示**φ链像素条**（比如p=7→φ(7)=6→φ(6)=2→φ(2)=1），每个模数用红色像素块表示，下方标注数值。  
   - 屏幕右侧显示**幂塔层数条**（x从0到5），每个层数用蓝色像素块表示。  
   - 底部控制面板：开始/暂停、单步、重置按钮，速度滑块（1x~5x），还有“AI自动演示”开关。  

2. **算法启动**：  
   - 点击“开始”，小巫师（像素角色）走到φ链的第一个块（p=7），播放“叮”的音效。  
   - 显示提示文字：“现在计算a↑↑x mod 7，x从0开始！”

3. **幂塔计算过程**：  
   - **x=0**：幂塔是1，绿块显示1，小巫师举着“1”的牌子，播放“正确”音效。  
   - **x=1**：幂塔是a，计算a mod 7，绿块显示结果，小巫师跳一下表示完成。  
   - **x=2**：幂塔是a^a，需要用扩展欧拉定理——先计算a mod φ(7)=6，然后计算a^a mod 6，再判断是否溢出。如果溢出，加6后再算a^(...) mod7。此时φ链的第二个块（6）高亮，播放“嵌套”音效。  
   - **x=3**：幂塔是a^(a^a)，递归处理φ(6)=2，第三个块（2）高亮，小巫师转圈表示“深入一层”。  

4. **关键交互**：  
   - **单步模式**：点击“下一步”，动画走一步，同时显示当前步骤的代码片段（比如`tetration(a, 2, 0)`）。  
   - **AI自动演示**：小巫师自动完成所有步骤，速度可调，完成后播放“胜利”音效（类似FC游戏的过关音乐）。  
   - **错误提示**：如果计算结果不等于b，小巫师会摇头，播放“错误”音效，同时高亮错误的步骤。  


### **设计思路**  
- **像素风格**：复古感强，降低视觉负担，让注意力集中在算法本身。  
- **角色与音效**：用小巫师增加趣味性，音效强化关键操作的记忆（比如“嵌套”用“叮-叮”，“完成”用“咚咚”）。  
- **可视化重点**：φ链的逐层深入、幂塔的递归计算、扩展欧拉定理的条件判断，这些都是题目的核心，用高亮和动画突出。  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
掌握了这道题的解法，你可以解决**所有高次幂模问题**！比如：  
</similar_problems_intro>

### **通用思路迁移**  
- **场景1**：计算a^b^c mod p（三层幂）→ 用扩展欧拉定理，先算b^c mod φ(p)+φ(p)（如果b^c>φ(p)），再算a^(...) mod p。  
- **场景2**：求解a^(a^x) ≡ b mod p（嵌套离散对数）→ 枚举x，用扩展欧拉定理计算左边的值。  
- **场景3**：处理非常大的指数（比如1e100）→ 用扩展欧拉定理简化指数。  


### **练习推荐 (洛谷)**  
1. **洛谷 P3846** - 【模板】BSGS  
   * 🗣️ **推荐理由**：最经典的BSGS模板题，帮你巩固离散对数的求解。  
2. **洛谷 P3747** - 相逢是问候  
   * 🗣️ **推荐理由**：扩展欧拉定理的经典应用，和本题n=2的情况几乎一样，是很好的拓展练习。  
3. **洛谷 P4195** - 【模板】扩展BSGS  
   * 🗣️ **推荐理由**：处理p不是质数的情况，扩展你的BSGS技能树。  
4. **洛谷 P5091** - 【模板】扩展欧拉定理  
   * 🗣️ **推荐理由**：直接练习扩展欧拉定理的应用，帮你吃透“指数溢出判断”。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>  
优质题解里的“踩坑经验”比代码更重要！比如：  
</insights_intro>

> **参考经验（来自LightningUZ）**：“我一开始把a先模了p，结果n=2的时候全错了！后来才发现，幂塔的模数是φ(p)，不是p本身，a不能提前模p。”  
> **点评**：这个错误太常见了！比如计算a↑↑2=a^a mod p，a的模数应该是φ(p)，而不是p。提前模p会导致后续计算错误。解决方法是：**只有在计算当前层的模时，才对a取模**，之前的层保持原数。  


## 结语  
这道题是数论的“综合大练兵”——BSGS解决离散对数，扩展欧拉定理处理高次幂，递归处理嵌套结构。记住：**遇到高次幂模问题，先想φ链；遇到嵌套结构，先想递归**！  

编程的乐趣在于“拆解复杂问题”——把高德纳箭号的“超级大数字”拆成一层一层的小问题，再逐个解决。下次遇到类似的问题，你一定能轻松应对！💪  

如果有疑问，欢迎随时找我讨论～ Kay一直在你身边！😊

---
处理用时：137.52秒
# 题目信息

# [ZJOI2022] 众数

## 题目描述

九条可怜是一个有超能力的女孩子，但她的超能力只能作用于一些奇怪的事情上。

有一天，可怜得到了一个序列 $a_1, a_2, \ldots, a_n$，她可以对这个序列使用一次超能力: 选择一个区
间 $[l, r]$（$1 \le l \le r \le n$）和一个整数 $k \in [-{10}^9, {10}^9]$，将区间内的所有数 $a_l, a_{l + 1}, \ldots, a_r$ 加上 $k$。

九条可怜很喜欢长得比较一致的序列，因此她希望最终的序列众数的出现次数尽可能多。给出序列 $a$，你需要输出最终序列的众数出现次数的最大值，并输出这个众数的所有可能取值。注意对于一个序列，众数的取值可能不止一个。

## 说明/提示

对于所有测试点：$1 \le T \le 20$，$2 \le n \le 2 \times {10}^5$，$1 \le a_i \le {10}^9$，保证 $\sum n \le 5 \times {10}^5$，且 $a_i$ 不全相等。

每个测试点的具体限制见下表：

| 测试点编号 | $\sum n \le$ | $n \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $3000$ | $300$ | 无 |
| $5 \sim 8$ | $5 \times {10}^5$ | $2 \times {10}^5$ | $a_i$ 只有 $5$ 种取值 |
| $9 \sim 10$ | $2 \times {10}^5$ | $50000$ | 无 |
| $11 \sim 20$ | $5 \times {10}^5$ | $2 \times {10}^5$ | 无 |

## 样例 #1

### 输入

```
4
5
1 2 3 2 1
5
1 1 3 1 1
6
2 4 2 4 8 8
5
1 2 3 4 5
```

### 输出

```
4
1
5
1
4
2
4
8
2
1
2
3
4
5
```

## 样例 #2

### 输入

```
见附件中的 mode/mode_ex2.in```

### 输出

```
见附件中的 mode/mode_ex2.ans```

# AI分析结果

# 💡 Kay的C++算法解析：[ZJOI2022]众数 深入学习指南 💡


## 引言
今天我们要攻克的是**ZJOI2022的众数问题**——这道题像一场“数字变身游戏”：你可以选一段区间加任意数，让最终序列的众数（出现次数最多的数）尽可能“多”。我们的目标是找到这个最大次数，以及所有能成为众数的数。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`根号分治`（平衡规划）

🗣️ **初步分析**：
解决这道题的关键是**根号分治**——它像“把蛋糕分成大块和小块分别吃”：  
- 对于出现次数**超过√n**的数（我们叫“大块数”）：这类数很少（最多√n个），可以直接暴力枚举，计算它们作为“外层众数”（区间外的众数）或“内层众数”（区间内的众数）的贡献。  
- 对于出现次数**不超过√n**的数（我们叫“小块数”）：这类数很多，但每个数出现次数少，可以暴力枚举它们的关键区间（比如两个相同数之间的区间），计算区间内的众数贡献。  

**核心算法流程**：  
1. **离散化**：把原序列的大数映射成小数（比如把1e9的数变成1、2、3…），方便处理。  
2. **处理大块数**：枚举每个大块数，用前缀和快速计算它在任意区间的出现次数，再枚举其他数作为另一层的众数，求最大贡献（类似“最大子段和”）。  
3. **处理小块数**：枚举每个小块数的出现位置，预处理“区间众数出现k次的最小右端点”，快速计算关键区间的众数贡献。  
4. **合并结果**：找出所有情况中的最大众数次数，以及对应的数。  

**可视化设计思路**：  
我们用**8位像素风**（类似FC红白机）展示序列：  
- 每个数字用不同颜色的像素块表示，大块数用“亮色”（比如红色），小块数用“暗色”（比如蓝色）。  
- 处理大块数时，用“黄色箭头”指向当前枚举的大块数，“绿色框”标记计算的区间，伴随“叮”的音效。  
- 处理小块数时，用“紫色闪烁”标记关键区间，“橙色数字”显示当前众数次数，伴随“滴”的音效。  
- 动画支持“单步执行”（看每一步细节）、“自动播放”（快速看流程），完成时播放“胜利音效”（比如《超级马里奥》的过关声）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度，筛选了3份优质题解：
</eval_intro>

### 题解一：JoshAlMan（赞：24）
* **点评**：这份题解是“根号分治”的标准模板！思路像“先解决大问题，再补小漏洞”：  
  - 首先离散化序列，把大数变小。  
  - 对大块数，用前缀和计算它在区间的出现次数，再枚举其他数作为另一层众数，用“最大子段和”求贡献（比如把大块数设为-1，另一数设为1，找最大和）。  
  - 对小块数，用“暴力枚举关键区间+维护众数数组”的方法，利用小块数出现次数少的特点，把复杂度控制在√n以内。  
  代码风格很工整，变量名（比如`c[i]`存i的出现位置，`s[i]`存前缀和）清晰易懂，特别是处理边界条件（比如区间两端的情况）很严谨，适合新手模仿。

### 题解二：Alex_Wei（赞：23）
* **点评**：这份题解的“题意转换”很巧妙！把“区间加k”转化为“切两段序列”（区间内和区间外），然后求两段众数之和的最大值。  
  - 对大块数，用“前缀和+贪心维护最小前缀”求最大贡献（比如枚举大块数x，其他数y，计算x在区间外、y在区间内的最大和）。  
  - 对小块数，预处理“每个左端点l，众数出现k次的最小右端点”，用双指针快速找答案。  
  代码中的“pointer[k][l]”数组（存左端点l，众数出现k次的最小右端点）很有创意，把区间众数的查询转化为“查表”，效率很高。

### 题解三：dead_X（赞：18）
* **点评**：这份题解的“预处理”很到位！针对小块数，预处理了“每个左端点l，数出现d次的最小右端点g[l][d]”，这样枚举小块数的关键区间时，能快速找到对应的右端点。  
  - 对大块数，用“前缀和+维护最大/最小值”求贡献（比如枚举大块数x，其他数y，计算x在区间内、y在区间外的最大和）。  
  代码中的`g[l][d]`数组（存左端点l，出现d次的最小右端点）是亮点，把“找区间众数”的问题转化为“找最小右端点”，简化了逻辑。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点在于“如何高效处理内外层众数的贡献”，以下是3个关键点及应对策略：
</difficulty_intro>

### 1. 关键点1：如何将“区间加k”转化为可计算的模型？
* **分析**：区间加k不会改变区间内数的**相对关系**——比如区间内的数加k后，原来的众数还是众数（只是数值变了）。因此，问题可以转化为：选一个区间，让**区间内的众数**和**区间外的众数**的出现次数之和最大。  
* 💡 **学习笔记**：转化题意是解决复杂问题的第一步！

### 2. 关键点2：如何高效处理“大块数”的贡献？
* **分析**：大块数出现次数多（>√n），但数量少（<√n）。我们可以枚举每个大块数，用**前缀和**快速计算它在任意区间的出现次数，再枚举其他数作为另一层的众数，用“最大子段和”求贡献（比如把大块数设为-1，另一数设为1，找最大和）。  
* 💡 **学习笔记**：用“前缀和+最大子段和”处理大块数，是根号分治的经典技巧！

### 3. 关键点3：如何高效处理“小块数”的贡献？
* **分析**：小块数出现次数少（≤√n），但数量多。我们可以枚举小块数的**关键区间**（比如两个相同数之间的区间），预处理“区间众数出现k次的最小右端点”，用双指针快速找答案。  
* 💡 **学习笔记**：预处理“最小右端点”，把区间众数的查询转化为“查表”，能大幅降低复杂度！

### ✨ 解题技巧总结
- **离散化**：把大数变小，方便数组处理。  
- **根号分治**：按出现次数分大块和小块，平衡时间复杂度。  
- **前缀和**：快速计算区间内某数的出现次数。  
- **预处理**：提前计算关键信息（比如最小右端点），避免重复计算。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的核心实现**，它包含离散化、大块处理、小块处理的完整逻辑：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合了JoshAlMan、Alex_Wei的思路，是一份清晰的根号分治模板。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const int N = 2e5 + 5;
int n, a[N], b[N], len, cnt[N]; // cnt[i]是i的出现次数
vector<int> pos[N]; // pos[i]存i的出现位置
int B, ans[N]; // ans[i]是i的最大贡献

// 离散化函数
void discretize() {
    for (int i = 1; i <= n; i++) b[i] = a[i];
    sort(b + 1, b + 1 + n);
    len = unique(b + 1, b + 1 + n) - b - 1;
    for (int i = 1; i <= n; i++) 
        a[i] = lower_bound(b + 1, b + 1 + len, a[i]) - b;
}

// 处理大块数（出现次数> B）
void process_big() {
    for (int x = 1; x <= len; x++) {
        if (pos[x].size() <= B) continue;
        // 前缀和：s[i]是前i个元素中x的出现次数
        vector<int> s(n + 1, 0);
        for (int p : pos[x]) s[p] = 1;
        for (int i = 1; i <= n; i++) s[i] += s[i-1];
        // 枚举其他数y，计算x作为外层、y作为内层的贡献
        for (int y = 1; y <= len; y++) {
            if (x == y) continue;
            int max_val = 0, min_prefix = 0, current = 0;
            for (int p : pos[y]) {
                current = (p - s[p]) - min_prefix; // 当前贡献
                max_val = max(max_val, current);
                min_prefix = min(min_prefix, p - s[p]); // 维护最小前缀
            }
            ans[x] = max(ans[x], max_val + s[n]); // x的总出现次数是s[n]
        }
    }
}

// 处理小块数（出现次数<= B）
void process_small() {
    // 预处理：g[l][d]是左端点l，众数出现d次的最小右端点
    vector<vector<int>> g(n + 2, vector<int>(B + 1, n + 1));
    for (int x = 1; x <= len; x++) {
        if (pos[x].size() > B) continue;
        int sz = pos[x].size();
        for (int i = 0; i < sz; i++) {
            for (int j = i; j < sz; j++) {
                int l = pos[x][i], r = pos[x][j];
                g[l][j - i + 1] = min(g[l][j - i + 1], r);
            }
        }
    }
    // 从右到左更新g（确保g[l][d]是最小右端点）
    for (int l = n; l >= 1; l--) {
        for (int d = 1; d <= B; d++) {
            g[l][d] = min(g[l][d], g[l + 1][d]);
        }
    }
    // 计算小块数的贡献
    for (int x = 1; x <= len; x++) {
        if (pos[x].size() > B) continue;
        int sz = pos[x].size();
        // 枚举关键区间（比如两个x之间的区间）
        for (int i = 0; i < sz; i++) {
            int l = pos[x][i] + 1;
            for (int d = 1; d <= B; d++) {
                if (g[l][d] == n + 1) break;
                int r = g[l][d];
                // 找r右边的x的数量
                int right = sz - upper_bound(pos[x].begin(), pos[x].end(), r) + pos[x].begin();
                ans[x] = max(ans[x], d + (i + 1) + right);
            }
        }
    }
}

int main() {
    int T; cin >> T;
    while (T--) {
        cin >> n;
        for (int i = 1; i <= n; i++) cin >> a[i];
        discretize();
        // 初始化pos和cnt
        for (int i = 1; i <= len; i++) pos[i].clear(), cnt[i] = 0;
        for (int i = 1; i <= n; i++) {
            pos[a[i]].push_back(i);
            cnt[a[i]]++;
        }
        B = sqrt(n);
        // 初始化ans
        for (int i = 1; i <= len; i++) ans[i] = cnt[i];
        process_big();
        process_small();
        // 找最大众数次数
        int max_ans = 0;
        for (int i = 1; i <= len; i++) max_ans = max(max_ans, ans[i]);
        cout << max_ans << endl;
        // 输出所有能成为众数的数
        for (int i = 1; i <= len; i++) {
            if (ans[i] == max_ans) cout << b[i] << endl;
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **离散化**：把原序列的大数映射成1~len的小数。  
  2. **处理大块数**：枚举每个大块数x，用前缀和计算x的出现次数，再枚举其他数y，用“最大子段和”求x作为外层、y作为内层的贡献。  
  3. **处理小块数**：预处理“左端点l，众数出现d次的最小右端点g[l][d]”，再枚举小块数的关键区间，计算贡献。  
  4. **输出结果**：找出最大众数次数，以及对应的数。

---

<code_intro_selected>
接下来看**题解一（JoshAlMan）**的核心片段，理解“大块数处理”的细节：
</code_intro_selected>

### 题解一核心片段赏析
* **亮点**：用“前缀和+最大子段和”处理大块数，逻辑清晰。
* **核心代码片段**：
```cpp
// 处理大块数x
vector<int> s(n + 1, 0);
for (int p : pos[x]) s[p] = 1;
for (int i = 1; i <= n; i++) s[i] += s[i-1];
// 枚举其他数y
for (int y = 1; y <= len; y++) {
    if (x == y) continue;
    int max_val = 0, min_prefix = 0, current = 0;
    for (int p : pos[y]) {
        current = (p - s[p]) - min_prefix;
        max_val = max(max_val, current);
        min_prefix = min(min_prefix, p - s[p]);
    }
    ans[x] = max(ans[x], max_val + s[n]);
}
```
* **代码解读**：  
  - `s[p]`是前p个元素中x的出现次数。  
  - 对于y的每个出现位置p，`p - s[p]`表示“前p个元素中y的次数减去x的次数”（因为y出现了i次，x出现了s[p]次，i = p中y的位置索引+1？不，其实这里的逻辑是把y的位置视为“+1”，x的位置视为“-1”，所以前p个元素的和是“y的次数 - x的次数”，而`p - s[p]`等于“y的次数”（因为y的位置有i个，p = pos[y][i]，所以y的次数是i+1？其实更准确的是，`p - s[p]`等于“前p个元素中，非x的元素个数”，但这里的核心是求“y的次数 - x的次数”的最大子段和。  
  - `min_prefix`维护“前p个元素的最小前缀和”，这样`current`就是“当前位置的和 - 最小前缀和”，即最大子段和。  
* 💡 **学习笔记**：用“前缀和+最小前缀”求最大子段和，是处理“区间贡献”的常用技巧！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“根号分治”的流程，我设计了一个**8位像素风的动画**，像玩《超级马里奥》一样看算法执行！
</visualization_intro>

### 动画设计详情
#### 1. 场景与UI初始化
- **像素风格**：用FC红白机的配色（比如蓝色背景、黄色文字、红色大块数、蓝色小块数）。  
- **UI布局**：  
  - 上方是**序列展示区**：每个数字是一个8x8的像素块，大块数用红色，小块数用蓝色。  
  - 中间是**控制面板**：有“开始/暂停”“单步”“重置”按钮，以及“速度滑块”（控制自动播放的速度）。  
  - 下方是**信息区**：显示当前处理的数（比如“当前大块数：5”）、当前贡献（比如“当前最大贡献：10”），以及“ Kay的提示”（比如“现在处理大块数5，计算它作为外层的贡献”）。  
- **背景音乐**：循环播放《超级马里奥》的背景音乐（8位版）。

#### 2. 动画流程演示
**步骤1：离散化**  
- 原序列的大数（比如1e9）变成小数（比如1、2、3），像素块的颜色对应变化（比如1e9变成红色）。  
- 伴随“嘀”的音效，信息区显示“离散化完成！”。

**步骤2：处理大块数**  
- 用**黄色箭头**指向当前大块数（比如红色像素块），信息区显示“处理大块数：x”。  
- 用**绿色框**标记计算的区间（比如y的出现位置），伴随“叮”的音效。  
- 信息区实时显示“当前贡献：xx”，当找到更大贡献时，绿色框闪烁，伴随“啪”的音效。

**步骤3：处理小块数**  
- 用**紫色闪烁**标记小块数的关键区间（比如两个蓝色像素块之间的区间），信息区显示“处理小块数：y”。  
- 用**橙色数字**显示当前众数次数（比如“众数次数：3”），伴随“滴”的音效。  
- 当找到更大贡献时，橙色数字变大，伴随“叮”的音效。

**步骤4：结果展示**  
- 所有能成为众数的数用**金色闪烁**标记，信息区显示“最大众数次数：xx”。  
- 播放《超级马里奥》的过关音效，信息区显示“完成！”。

#### 3. 交互设计
- **单步执行**：点击“单步”按钮，动画走一步，方便看细节。  
- **自动播放**：拖动“速度滑块”调整播放速度（比如慢、中、快），自动演示完整流程。  
- **重置**：点击“重置”按钮，回到初始状态，重新演示。

<visualization_conclusion>
通过这个动画，你能清晰看到“根号分治”是如何“拆分问题、分别处理、合并结果”的——就像玩游戏一样，一步步攻克难关！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
根号分治是处理“出现次数”“众数”问题的常用技巧，以下是几个相似问题，帮你巩固知识点：
</similar_problems_intro>

### 通用思路迁移
根号分治的核心是**平衡复杂度**：  
- 对于“出现次数多的元素”，用暴力枚举（因为数量少）；  
- 对于“出现次数少的元素”，用暴力枚举关键区间（因为每个元素的区间少）。  
适用于**众数问题**“出现次数统计”“区间贡献计算”等场景。

### 练习推荐 (洛谷)
1. **洛谷 P3396** - 哈希冲突  
   * 🗣️ **推荐理由**：这道题是根号分治的经典题，需要将查询分成“块内”和“块外”处理，和本题的思路高度相似。  
2. **洛谷 P4137** - Rmq Problem / mex  
   * 🗣️ **推荐理由**：这道题需要求区间的mex（最小未出现的非负整数），可以用根号分治处理“出现次数少的数”和“出现次数多的数”，巩固你的分治思路。  
3. **洛谷 P5076** - 密令  
   * 🗣️ **推荐理由**：这道题需要统计子串的出现次数，用根号分治处理“短子串”（暴力枚举）和“长子串”（哈希统计），锻炼你的复杂度平衡能力。


## 7. 学习心得与经验分享 (若有)
从题解中，我总结了几个**调试和学习的小技巧**：  
- **离散化时注意去重**：比如用`unique`函数时，要先排序，否则会出错（题解中都提到了这一点）。  
- **处理边界条件**：比如区间的左右端点可能是1或n，要单独处理（比如题解中的`g[l][d]`初始化为n+1，避免越界）。  
- **用前缀和优化**：任何需要多次计算“区间内某数出现次数”的问题，都可以用前缀和（比如题解中的`s[i]`数组）。


## 结语
这道题的核心是**根号分治**——把复杂的问题拆成“大块”和“小块”，用不同的方法解决。希望这份指南能帮你理解这个技巧，下次遇到类似的问题时，能像“切蛋糕”一样轻松应对！  

记住：编程的乐趣在于“拆解问题、解决问题”，慢慢来，你一定能学会！💪

---
处理用时：160.07秒
# 题目信息

# [POI 2020/2021 R3] 素数和 / Suma liczb pierwszych

## 题目背景

译自 [XXVIII Olimpiada Informatyczna - III etap](https://sio2.mimuw.edu.pl/c/oi28-3/dashboard/) [Suma liczb pierwszych](https://szkopul.edu.pl/problemset/problem/8brtPux-IyytS6rOoOR1cJTL/statement/)。

d2t3。

## 题目描述

给你一个数字 $n$，求 $l,r$，使 $[l,r]$ 区间内的所有质数之和等于 $n$。

如果有多解，任意一组均可；无解输出 `NIE`。

## 说明/提示

对于所有数据，$1\leq n\leq 10^{11}$。

| 子任务编号 | 附加限制 | 分数 |
| :----------: | :----------: | :----------: |
| 1 | $n\leq 10000$ | 15 |
| 2 | $n\leq 10^8$ | 20 |
| 3 | $n\leq 2\times 10^9$ | 40 |
| 4 |  | 25 |

## 样例 #1

### 输入

```
15
```

### 输出

```
3 7
```

## 样例 #2

### 输入

```
9992
```

### 输出

```
4993 4999
```

## 样例 #3

### 输入

```
100000000
```

### 输出

```
NIE
```

## 样例 #4

### 输入

```
1000000007
```

### 输出

```
1000000007 1000000007
```

## 样例 #5

### 输入

```
99999999996
```

### 输出

```
295693 1693067
```

# AI分析结果

# 💡 Kay的C++算法解析：素数和 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（质数应用）+ 双指针滑动窗口 + 分段处理  

🗣️ **初步分析**：  
解决“素数和”问题，核心是**找到连续质数的和等于n**。我们可以把问题拆成三步：  
1. **找质数**：用质数筛（比如埃氏筛）快速找出小范围的质数；  
2. **找区间**：用双指针在质数列表上滑动，寻找和为n的连续区间；  
3. **处理大数**：当n很大时，小范围的质数不够用，就**枚举质数个数**——比如假设答案由t个质数组成，那这些质数肯定在`n/t`附近，再用**区间筛**找出附近的质数，继续用双指针找。  

打个比方：这就像“找一串连续的苹果，重量总和刚好是n”。小重量的苹果（小质数）我们直接全部称一遍（筛出来），用两个手指（双指针）滑着找；大重量的苹果（大质数）我们猜有几个（枚举t），然后在“大概重量”（n/t）附近找这串苹果，再称一遍。  

**核心算法流程**：  
- 小范围（比如≤2e7）：筛质数→前缀和→双指针找区间；  
- 大范围：枚举质数个数t→计算中心位置n/t→区间筛找附近的质数→双指针找区间。  

**可视化设计思路**：  
我们用8位像素风格（像FC游戏）展示：  
- 左边是“小范围筛质数”：像素格子代表数字，白色是质数，灰色是合数，筛子时合数会慢慢变灰；  
- 中间是“双指针滑动”：两个彩色箭头（比如红色左指针、蓝色右指针）在质数列表上移动，上方显示当前和；  
- 右边是“大范围枚举”：一个像素小地图显示“n/t”附近的区间，筛出质数后双指针继续滑动。  
- 音效：筛合数时“嘀”一声，双指针移动“嗒”一声，找到答案时“叮”的胜利音效！


## 2. 精选优质题解参考

<eval_intro>  
我从思路清晰度、代码可读性、算法优化等角度筛选了3份优质题解，帮大家快速掌握核心技巧~  
</eval_intro>


**题解一：World_Creater（赞：9）**  
* **点评**：这份题解把“小范围直接筛+大范围枚举”的思路贯彻得很彻底！  
  - 思路上：先筛2e7以内的质数，用双指针找；如果没找到，就枚举质数个数（最多5000次），每次计算中心位置n/t，用**区间筛**找出附近的质数，再双指针找。  
  - 代码上：用`bitset`优化筛法（节省内存），区间筛的实现很巧妙（用`chk`标记区间内的合数），双指针逻辑清晰。  
  - 亮点：**区间筛的优化**——用小范围筛好的质数去标记大区间的合数，避免重复计算；枚举个数时设置了动态的“搜索范围”（比如i≤5时扩大搜索范围），覆盖更多情况。  


**题解二：robinyqc（赞：3）**  
* **点评**：这份题解的思路更“直白”，适合新手理解！  
  - 思路上：设置阈值B（比如1e8），先筛B以内的质数用双指针找；如果没找到，就枚举质数个数t（最多n/B次），每次在n/t附近找一个小区间（比如±50t），用区间筛找质数再双指针。  
  - 代码上：用模板函数`solve`统一处理小范围和大范围的双指针逻辑，`bitset`的使用很规范，代码结构清晰。  
  - 亮点：**阈值的选择**——B=1e8刚好平衡小范围筛的时间和大范围枚举的次数，而且区间筛的实现很简洁，容易模仿。  


**题解三：novax（赞：2）**  
* **点评**：这份题解针对“大数质数判断”做了优化，适合处理超大型n！  
  - 思路上：小范围筛用埃氏筛，大范围用**Miller-Rabin质数测试**（比普通判断快得多），枚举质数个数时用双端队列收集附近的质数，再双指针找。  
  - 代码上：`isprime`函数实现了Miller-Rabin，`check`函数用双端队列高效收集附近的质数，双指针逻辑用`lower_bound`优化（不过实际用循环更稳定）。  
  - 亮点：**Miller-Rabin的应用**——解决了大数质数判断慢的问题，卡常技巧很实用（比如用`__int128`避免溢出）。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>  
解决这个问题，大家常遇到3个“卡壳点”，结合题解的经验，我帮大家总结了应对策略~  
</difficulty_intro>


### 1. 难点：大数怎么快速筛质数？  
- **分析**：直接筛1e11以内的质数不可能（内存和时间都不够），所以要**分段筛**——小范围用埃氏筛，大范围用“区间筛”（用小质数标记大区间的合数）。  
- **策略**：比如小范围筛到2e7，大范围要筛[L,R]时，用小范围的质数p，标记L到R中p的倍数（这些是合数），剩下的就是质数。  
- 💡 **学习笔记**：分段筛是处理大数质数的“神器”，核心是“用已知小质数标记未知大合数”。  


### 2. 难点：怎么高效找和为n的连续质数区间？  
- **分析**：如果直接枚举所有区间，时间复杂度是O(k²)（k是质数个数），太慢；用**双指针滑动窗口**可以把时间降到O(k)。  
- **策略**：左指针l和右指针r初始都在起点，r向右移动扩大窗口，直到和≥n；如果和>n，l向右移动缩小窗口；如果和==n，找到答案！  
- 💡 **学习笔记**：双指针是“找连续区间和”的标配，一定要记牢这个模板！  


### 3. 难点：怎么平衡时间复杂度？  
- **分析**：小范围筛太多会超时，大范围枚举太多也会超时，所以要**设置合理的阈值**。  
- **策略**：比如把小范围阈值设为2e7或1e8，这样小范围的双指针很快，大范围的枚举次数也少（最多n/2e7=5e3次）。  
- 💡 **学习笔记**：阈值的选择是“ trade-off”（权衡），要根据题目数据范围调整。  


### ✨ 解题技巧总结  
- **技巧1：分段处理**：把问题拆成“小范围容易处理”和“大范围需要优化”两部分，避免“一刀切”。  
- **技巧2：双指针模板**：找连续区间和的问题，优先用双指针，时间复杂度O(n)。  
- **技巧3：质数筛优化**：用`bitset`代替`bool`数组（节省8倍内存），区间筛用已知小质数标记大合数。  


## 4. C++核心代码实现赏析

<code_intro_overall>  
先看一个综合的核心实现，帮大家把握整体框架~  
</code_intro_overall>


### 本题通用核心C++实现参考  
* **说明**：综合了三个题解的思路，实现“小范围筛+双指针+大范围枚举+区间筛”的完整逻辑。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <bitset>
#include <algorithm>
using namespace std;

typedef long long LL;
const int SMALL_LIM = 20000000; // 小范围阈值（2e7）
vector<int> primes; // 小范围筛出的质数
bitset<SMALL_LIM + 10> is_prime_small; // 小范围质数标记

// 埃氏筛筛小范围质数
void sieve_small() {
    is_prime_small.set();
    is_prime_small[0] = is_prime_small[1] = 0;
    for (int i = 2; i <= SMALL_LIM; ++i) {
        if (is_prime_small[i]) {
            primes.push_back(i);
            for (LL j = (LL)i * i; j <= SMALL_LIM; j += i)
                is_prime_small[j] = 0;
        }
    }
}

// 区间筛：筛[L, R]内的质数，返回质数列表
vector<LL> sieve_range(LL L, LL R) {
    vector<LL> res;
    if (L < 2) L = 2;
    bitset<1000010> is_prime; // 区间内的质数标记（R-L ≤ 1e6）
    is_prime.set();
    for (int p : primes) {
        if ((LL)p * p > R) break;
        // 计算p在[L, R]中的第一个倍数
        LL start = max((LL)p * p, ((L + p - 1) / p) * p);
        for (LL j = start; j <= R; j += p)
            is_prime[j - L] = 0;
    }
    for (LL i = L; i <= R; ++i)
        if (is_prime[i - L])
            res.push_back(i);
    return res;
}

// 双指针找和为n的区间，返回{l, r}或{-1, -1}
pair<LL, LL> find_interval(const vector<LL>& primes_list, LL n) {
    LL sum = 0;
    int l = 0;
    for (int r = 0; r < primes_list.size(); ++r) {
        sum += primes_list[r];
        while (sum > n) {
            sum -= primes_list[l];
            l++;
        }
        if (sum == n) {
            return {primes_list[l], primes_list[r]};
        }
    }
    return {-1, -1};
}

int main() {
    LL n;
    cin >> n;
    sieve_small();

    // 第一步：小范围找
    vector<LL> small_primes(primes.begin(), primes.end());
    auto ans = find_interval(small_primes, n);
    if (ans.first != -1) {
        cout << ans.first << " " << ans.second << endl;
        return 0;
    }

    // 第二步：检查n本身是否是质数
    bool is_n_prime = true;
    for (LL p : primes) {
        if (p * p > n) break;
        if (n % p == 0) {
            is_n_prime = false;
            break;
        }
    }
    if (is_n_prime && n >= 2) {
        cout << n << " " << n << endl;
        return 0;
    }

    // 第三步：大范围枚举质数个数t
    const int MAX_T = 5000; // 最多枚举5000次
    for (int t = 2; t <= MAX_T; ++t) {
        LL mid = n / t;
        LL L = max(mid - (LL)t * 20, 2LL); // 左边界：mid - 20t
        LL R = mid + (LL)t * 20; // 右边界：mid + 20t
        vector<LL> range_primes = sieve_range(L, R);
        ans = find_interval(range_primes, n);
        if (ans.first != -1) {
            cout << ans.first << " " << ans.second << endl;
            return 0;
        }
    }

    cout << "NIE" << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **小范围筛**：用埃氏筛筛出2e7以内的质数，存在`primes`数组；  
  2. **小范围找**：用双指针在小质数列表中找和为n的区间；  
  3. **检查n本身**：如果n是质数，直接输出[n, n]；  
  4. **大范围枚举**：枚举质数个数t（2到5000），计算中心位置mid=n/t，区间筛[mid-20t, mid+20t]的质数，双指针找区间；  
  5. **无解处理**：如果都没找到，输出NIE。  


### 针对各优质题解的片段赏析

#### 题解一：World_Creater的区间筛片段  
* **亮点**：用`bitset`优化区间筛的内存，代码简洁高效。  
* **核心代码片段**：  
```cpp
bitset<200005> chk; // 区间内的合数标记
void solve(int l, int r) {
    chk.reset();
    for (int i = 1; i <= cnt && prp[i] * prp[i] <= r; ++i) {
        int start = (l + prp[i] - 1) / prp[i]; // 第一个≥l的倍数
        for (int j = start; j * prp[i] <= r; ++j) {
            chk[j * prp[i] - l] = 1; // 标记为合数
        }
    }
}
```
* **代码解读**：  
  - `chk`是`bitset`，用来标记区间[l, r]内的合数，`j*prp[i]-l`是合数在区间中的索引（比如l=100，j*prp[i]=105，索引就是5）；  
  - 循环小范围的质数`prp[i]`，标记它们在[l, r]中的倍数——这些是合数；  
  - 为什么用`bitset`？因为`bitset`每个位占1 bit，比`bool`数组省8倍内存！  
* 💡 **学习笔记**：区间筛的核心是“用小质数标记大区间的合数”，`bitset`是优化内存的关键。  


#### 题解二：robinyqc的双指针模板  
* **亮点**：用模板函数统一处理小范围和大范围的双指针逻辑，代码复用性高。  
* **核心代码片段**：  
```cpp
template<bool type, int len>
void solve(LL l, LL r, bitset<len>& b) {
    LL sum = 0, pl = l;
    for (LL i = l; i <= r; ++i) {
        if (!b[i - l]) { // 如果i是质数
            sum += i;
            while (sum > n) { // 缩小窗口
                if (!b[pl - l]) sum -= pl;
                ++pl;
            }
            if (sum == n) { // 找到答案
                cout << max(pl, 1LL) << ' ' << i << '\n';
                exit(0);
            }
        }
    }
}
```
* **代码解读**：  
  - 模板参数`type`标记是否是区间筛（`type=1`时需要先筛，`type=0`时已经是筛好的`bitset`）；  
  - `sum`是当前窗口的和，`pl`是左指针，`i`是右指针；  
  - 每次右指针移动（加i），如果和超过n，左指针移动（减pl），直到和等于n。  
* 💡 **学习笔记**：双指针的模板可以通用，只要替换“判断当前元素是否是质数”的逻辑即可。  


#### 题解三：novax的Miller-Rabin质数测试  
* **亮点**：用Miller-Rabin解决大数质数判断，比普通枚举快得多。  
* **核心代码片段**：  
```cpp
bool isprime(long long n) {
    if (n < 3 || n % 2 == 0) return n == 2;
    long long u = n - 1, t = 0;
    while (u % 2 == 0) u /= 2, ++t; // 分解n-1=u*2^t
    for (int i = 0; i < 8; ++i) { // 测试8次
        long long a = rand() % (n - 2) + 2;
        long long v = pow(a, u, n); // 计算a^u mod n
        if (v == 1) continue;
        int s;
        for (s = 0; s < t; ++s) {
            if (v == n - 1) break;
            v = (__int128)v * v % n; // 用__int128避免溢出
        }
        if (s == t) return false;
    }
    return true;
}
```
* **代码解读**：  
  - Miller-Rabin的核心是“费马小定理”的逆否：如果n是质数，那么对于任何a∈[2,n-1]，a^(n-1) ≡1 mod n；  
  - 分解n-1为u*2^t，然后测试a^u, a^(u*2), ..., a^(u*2^t)是否等于n-1；  
  - 用`__int128`计算v*v，避免溢出（因为v可能接近1e11，v*v会超过long long的范围）。  
* 💡 **学习笔记**：Miller-Rabin是处理大数质数的“黑科技”，测试次数越多越准确（通常8次就够）。  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>  
为了让大家更直观地“看到”算法运行，我设计了一个**8位像素风格的动画**，像玩FC游戏一样学算法！  
</visualization_intro>


### 动画演示主题  
**像素质数探险家**：小探险家（代表双指针）在数字森林（代表质数列表）中寻找“和为n的连续质数串”，遇到合数会用锤子标记（筛的过程），找到答案会放烟花！  


### 设计思路简述  
- **风格**：仿FC游戏的8位像素风（低分辨率、高饱和度色彩），背景是绿色的数字森林，质数是白色方块，合数是灰色方块，双指针是红色（左）和蓝色（右）箭头。  
- **趣味点**：筛合数时播放“嘀”的像素音效，双指针移动时播放“嗒”的音效，找到答案时播放“叮”的胜利音效+烟花动画，增强记忆点。  


### 动画帧步骤与交互关键点  

#### 1. 初始化场景（FC开机画面）  
- 屏幕分为三部分：  
  - 左边：小范围筛区（2e7以内的数字），初始全白；  
  - 中间：双指针区（显示当前质数列表和双指针位置）；  
  - 右边：大范围枚举区（显示当前枚举的t和n/t附近的区间）。  
- 控制面板：开始/暂停、单步、重置按钮，速度滑块（1x~5x），8位风格的背景音乐开始播放。  


#### 2. 小范围筛质数（埃氏筛）  
- 像素格子从2开始，逐个检查：  
  - 如果是质数（白色），就用黄色标记（加入质数列表），然后用灰色标记它的所有倍数（合数）；  
  - 每标记一个合数，播放“嘀”的音效；  
  - 筛完后，中间区显示小范围的质数列表（白色方块排成一行）。  


#### 3. 小范围双指针找区间  
- 红色左指针（l）和蓝色右指针（r）初始都在质数列表的起点；  
- 右指针向右移动（蓝色箭头闪烁），sum增加（上方数字变大）；  
- 如果sum>n，左指针向右移动（红色箭头闪烁），sum减少；  
- 如果sum==n，双指针所在的区间闪烁，播放“叮”的音效，屏幕放烟花，显示答案！  


#### 4. 大范围枚举（区间筛+双指针）  
- 如果小范围没找到，右边区显示“枚举t=2”，然后计算mid=n/t（比如n=1e11，t=2，mid=5e10）；  
- 区间筛开始：用小范围的质数标记mid±20t的区间内的合数（灰色方块），剩下的白色方块是质数；  
- 双指针在区间筛出的质数列表上滑动，过程和小范围一样；  
- 如果找到答案，同样播放胜利音效+烟花。  


#### 5. 交互设计  
- **单步执行**：点击“单步”按钮，动画执行一步（比如筛一个合数、移动一次指针），方便仔细观察；  
- **自动播放**：点击“自动”按钮，动画按速度滑块的速度播放（1x最慢，5x最快）；  
- **重置**：点击“重置”按钮，回到初始状态，重新开始。  


<visualization_conclusion>  
通过这个动画，你可以清晰看到“筛质数→双指针找区间→大范围枚举”的完整过程，连每个细节（比如筛合数、指针移动）都能“摸得着”！  


## 6. 拓展练习与相似问题思考

<similar_problems_intro>  
掌握了本题的技巧，我们可以解决更多“质数+区间和”的问题，甚至拓展到其他领域~  
</similar_problems_intro>


### 通用思路/技巧迁移  
- **质数筛**：可以用于任何需要快速找质数的问题（比如统计质数个数、判断质数）；  
- **双指针**：可以用于找连续子数组和、最长无重复子串等问题；  
- **分段处理**：可以用于处理大数问题（比如大数乘法、大数分解）。  


### 练习推荐 (洛谷)  
1. **洛谷 P3383** - 线性筛素数  
   🗣️ **推荐理由**：这是质数筛的基础题，帮你巩固埃氏筛和线性筛的区别，掌握筛法的核心。  
2. **洛谷 P1835** - 素数密度  
   🗣️ **推荐理由**：这题需要用区间筛找[L, R]内的质数个数，直接对应本题的大范围筛法，练手必备。  
3. **洛谷 P4781** - 【模板】Miller-Rabin素数测试  
   🗣️ **推荐理由**：这题是Miller-Rabin的模板题，帮你掌握大数质数判断的核心代码，应对超大型n。  
4. **洛谷 P2626** - Fibonacci 数列（升级版）  
   🗣️ **推荐理由**：这题需要找Fibonacci数列中的质数，结合了质数判断和数列生成，是很好的综合练习。  


## 7. 学习心得与经验分享  

<insights_intro>  
三个题解的作者都分享了自己的“踩坑”经验，这些都是宝贵的学习资源~  
</insights_intro>


> **参考经验 (来自 novax)**：“我在解决这个问题时，最初用普通的质数判断（枚举到sqrt(n)），结果处理大数时超时了，后来用Miller-Rabin才通过。这让我意识到，大数质数判断必须用更高效的算法。”  
> **点评**：novax的经验很典型——普通的质数判断对大数来说太慢了，Miller-Rabin是解决这个问题的关键。大家以后遇到大数质数问题，记得优先用Miller-Rabin！  


> **参考经验 (来自 World_Creater)**：“我一开始枚举质数个数时，搜索范围设得太小，结果漏掉了一些情况，后来把范围扩大到mid±20t，才找到了答案。”  
> **点评**：搜索范围的设置很重要，太小会漏掉解，太大又会超时。大家可以根据质数密度（大约每ln n个数有一个质数）来调整范围，比如设为mid±k*t（k取20左右）。  


## 总结  
本次分析的“素数和”问题，核心是**质数筛+双指针+分段处理**。通过小范围筛、双指针找区间、大范围枚举，我们可以高效解决大数问题。记住：**分段处理是应对大数的关键，双指针是找连续区间的神器，质数筛是基础中的基础**！  

希望这份指南能帮你掌握这些技巧，下次遇到类似问题时，能轻松解决~ 💪

---
处理用时：146.98秒
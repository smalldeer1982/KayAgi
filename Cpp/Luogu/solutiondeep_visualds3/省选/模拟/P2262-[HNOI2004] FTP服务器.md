# 题目信息

# [HNOI2004] FTP服务器

## 题目背景

File Transfer Protocol，文件传输协议，简称 FTP。人们可以通过 FTP 实现资源共享。一般的情况下用户访问一个 FTP 服务器是通过类似资源管理器的形式对该服务器上的资源进行浏览，并且不同权限的用户可以实现下载文件/文件夹，上传文件/文件夹。


## 题目描述

一个FTP服务器的所有资源都以文件的形式按树形结构存储在不同的文件夹里，最低一级的是根目录（即根文件夹），根目录里有若干个文件和文件夹，每一个文件夹里都可以拥有 $0$ 个或多个文件及文件夹，同一文件夹里不存在名称相同的文件和文件夹。

一个用户包含三个属性：

- $\text{userType}$：用户类型；
- $\text{userState}$：用户状态（用户正在执行的操作）；
- $\text{userPosition}$：用户当前所处的位置（即用户正在浏览的文件夹）。

用户分 $3$ 种类型：上传用户 $\text{uploadUser}$，下载用户 $\text{downloadUser}$，匿名用户 $\text{guest}$。

操作分 $3$ 种类型：浏览 $\text{scan}$，下载 $\text{download}$，上传 $\text{upload}$。

用户的权限是指用户允许进行的操作。不同类型的用户的权限是不同的。

任何一个用户是不能进行其没有权限的操作的，例如：一个匿名用户想要下载一个文件或者文件夹是不允许的。

一个文件/文件夹包含三个属性：

- $\text{fileName/folderName}$：文件名（不包含空格和回车）；
- $\text{fileSize/folderSize}$：文件大小
（单位 $\text{byte}$，$0 <\mathrm{filesize}< 10^5$，$0<\mathrm{folderSize}< 10^8$，文件夹的大小是它里面所包含的所有文件大小的总和）；
- $\text{fileState/folderState}$：当前状态，当前状态有两种：
  - 一种为正常 $\text{normal}$（文件/文件夹为正常状态时，允许用户对其进行操作）；
  - 另一种为上传未完成 $\text{uploading}$（处在此种状态时，用户只能够对其进行浏览操作，如果一个文件夹中有一个或多个文件处于 $\text{uploading}$ 状态，那么这个文件夹也处于 $\text{uploading}$ 状态）。

一个 FTP 服务器除了它所拥有的文件资源外，还有如下属性：

1. 访问用户的最大数量（包括所有不同类型的用户） $\text{maxUserNumber}<100$。如果当前访问用户数量已经达到最大值的话，其他新的用户对服务器的访问将是失败的。
2. 服务器的最大流量 $\text{maxServerFlux}<10^7$。
3. 单个用户允许的最大下载/上传流量 $\text{maxUserFlux}$。

FTP 服务器运行的最小时间单位为秒。

每一个用户在同一时刻只能进行一种操作。用户下载和上传文件/文件夹是需要一定时间的，而这个时间决定于用户流量 $\text{userFlux}$，单位为 $\text{byte/second}$，注意如果某一时刻文件/文件夹仍须上传/下载的大小（$>0$）小于 $\text{userFlux}$ 的话，上传/下载时间仍将按照一秒钟看待。

而 $\text{userFlux}$ 的值是如何确定的呢？

 $$\mathrm{userFlux} = \min(\mathrm{presentMaxUserFlux},\mathrm{maxUserFlux})$$

其中，$\text{presentMaxUserFlux}$ 为当前服务器的单个用户最大流量：

$$\mathrm{presentMaxUserFlux} = \lfloor \mathrm{maxServerFlux} / \mathrm{userTotal}\rfloor$$

（$\text{userTotal}$ 表示该时刻的正在进行上传和下载操作的用户数量）

一个用户通过一系列命令实现其在 FTP 服务器上的相关操作。下面介绍这些命令：

### $\verb!connect!$ 命令

- 格式：$\verb![name] + 空格 + connect + 空格 + 参数A!$。
- 例：$\verb!tsinghua connect 1!$。
- 表示在名叫 $\verb!name!$ 的用户请求以 $\verb!A!$ 身份连接到服务器上。如果当前的最大使用用户还没达到 $\text{maxUserNumber}$，并且该用户未连接到服务器，则连接成功，服务器反馈回一个相关信息 $\verb!success!$。否则反馈信息为 $\verb!unsuccess!$。一旦连接成功，用户其所处的位置 $\text{userPosition}$ 为服务器的根目录。$A=1$ 表示上传用户，$A=2$ 下载表示用户，$A=3$ 表示匿名用户。

### $\verb!quit!$ 命令

- 格式：$\verb![name] + 空格 + quit!$。
- 例：$\verb!tsinghua quit!$。
- 表示名叫 $\verb!name!$ 的用户断开与服务器的连接。如果用户未连接反馈 $\verb!unsuccess!$，否则反馈 $\verb!success!$。（注意用户在任何状态下都可以断开与服务器的连接）。

### $\verb!cd!$ 命令

- 格式：$\verb![name] + 空格 + cd + 空格 + [folderName/文件夹名称]!$。
- 例：$\verb!THU cd FD!$。
- 表示名叫 $\verb!name!$ 的用户希望从当前所处的文件夹进入该文件夹中的一个名叫 $\text{folderName}$ 的文件夹。如果名叫 $\text{folderName}$ 的文件夹存在并且处于 $\text{normal}$ 状态，则改变用户当前所处位置 $\text{userPosition}$，反馈相关信息 $\verb!success!$，如果该文件夹不存在或该用户没有成功连接，则反馈信息为 $\verb!unsuccess!$。

### $\verb!cd..!$ 命令

- 格式：$\verb![name] + 空格 + cd..!$。
- 例：$\verb!9# cd..!$。
- 表示名叫 $\verb!name!$ 的用户希望从当前所处的文件夹返回到他的上一级文件夹。如果用户处于根目录或者用户未连接，则命令执行失败返回 $\verb!unsuccess!$，否则返回 $\verb!success!$，并且改变用户所处位置 $\text{userPosition}$。

### $\verb!download!$ 命令

- 格式：$\verb![name] + 空格 + download + 空格 + [name1]!$。
- 例：$\verb!A download 1.txt!$。
- 表示名叫 $\verb!name!$ 的用户希望从当前所处文件夹下载名为 $\verb!name1!$ 的文件或者文件夹。如果用户未连接，用户没有下载权限，名为 $\verb!name1!$ 的文件/文件夹不存在，或者该文件/文件夹处于 $\text{uploading}$ 状态时，反馈信息 $\verb!unsuccess!$，否则返回 $\verb!success!$ 并且开始下载该文件/文件夹。（一旦一个下载命令开始执行，那么执行该命令的用户所下载的是下载命令执行的那一时刻的那一个文件/文件夹，也就是说如果一个用户正在下在某个文件夹，在下载过程中，有另外一用户在这个文件夹里面上传文件，那么原下载用户是不可能下载到这个新上传的文件的）。

### $\verb!upload!$ 命令

- 格式：$\verb![name] + 空格 + upload + 空格 + [name1] + 空格 + [size]!$。
- 例：$\verb!A upload B 1!$。
- 表示名叫 $\verb!name!$ 的用户希望在当前所处的文件夹上传一个名叫 $\verb!name1!$ 的大小为 $\text{size}$ 的文件/文件夹。注意：
  - 用户通过 $\verb!upload!$ 命令上传文件夹只能为空文件夹，当 $\text{size}=0$ 表示上传文件夹，size>0表示上传文件。
  - 如果当前目录已经存在了同名的文件/文件夹，用户未成功连接或者用户没有上传权限，反馈信息 $\verb!unsuccess!$，否则反馈 $\verb!success!$，并且开始上传文件/文件夹。（如果一个用户想要上传一个非空文件夹，是很容易通过一系列 $\verb!upload!$ 以及 $\verb!cd!$ 命令实现的）。

---

除上传文件和下载文件/文件夹命令需要耗时外，其他的命令都不需要执行时间。

你的任务是模拟一个 FTP 服务器在某一时间段内的运行过程。

## 说明/提示

来源：HNOI2004 经过修改。


## 样例 #1

### 输入

```
5 200 200
unzip.exe 100
xxxx 50
bin 0
tpx.exe 200
turbo.exe 300
tpx.tp 400
temp 0
-
-
readme.txt 100
-
0 ares connect 2
0 ares download zip.exe
1 ares download bin
5 ares download xxxx
6 ares cd bin
6 ares connect 1
6 ares quit
7 ares connect 1
7 rosen connect 2
7 ares cd bin
8 ares upload A 300
9 rosen download bin
10 rosen download bin
down
```

### 输出

```
success
unsuccess
success
unsuccess
success
unsuccess
success
success
success
success
success
unsuccess
success
```

# AI分析结果



---
# 💡 Kay的C++算法解析：[HNOI2004] FTP服务器 深入学习指南 💡

<introduction>
今天我们要挑战的是一道经典的“大模拟”题目——[HNOI2004] FTP服务器。这类题目需要我们严格按照题目描述的规则，模拟服务器的运行过程，处理用户操作、文件状态变化等复杂逻辑。通过这份指南，你将学会如何拆解问题、设计数据结构，并掌握模拟类题目的核心技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟应用` (模拟类问题，需严格按规则处理多实体状态变化)

🗣️ **初步分析**：
解决这道题的关键在于“忠实模拟”——按照题目描述的用户类型、操作规则、文件/文件夹状态变化等，逐步实现每个命令的逻辑。简单来说，模拟类问题就像“导演一场戏”，我们需要为每个“演员”（用户、文件、文件夹）设计状态，并根据“剧本”（命令）推动剧情发展。

在本题中，模拟的核心是：
- **用户操作**：处理`connect`、`quit`、`cd`、`cd..`、`download`、`upload`六大命令，每个命令需检查用户状态、权限、文件/文件夹存在性及状态。
- **状态维护**：动态更新文件/文件夹的`normal`/`uploading`状态（尤其注意文件夹状态由子文件决定）。
- **任务管理**：处理上传/下载任务的时间计算（流量动态变化，需按时间差更新任务进度）。

核心难点包括：
- 动态流量计算：`presentMaxUserFlux`随当前任务数变化，需实时更新。
- 文件夹状态传播：上传中的文件夹需由子文件状态决定，上传完成后需递归检查父文件夹状态。
- 多任务并发处理：同一时间可能有多个上传/下载任务，需按时间差更新进度。

**可视化设计思路**：采用8位像素风格，用网格表示文件夹层级（根目录为第一层，子文件夹为下一层）。用户用像素小人表示，颜色区分类型（绿色-上传用户，蓝色-下载用户，灰色-匿名用户）。文件/文件夹用方块表示，红色闪烁表示`uploading`，绿色表示`normal`。任务进度条显示在用户头顶，流量数值实时更新。关键操作（如`connect`成功）播放“叮”的音效，任务完成播放“胜利”音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和实践价值，以下题解值得重点参考：
</eval_intro>

**题解一：sumijie（赞：15）**
* **点评**：这份题解结构清晰，用多个结构体（`User`、`File`、`Folder`、`Task`）完整建模了所有实体，并详细处理了流量计算、状态传播等细节。代码中对文件夹状态的递归检查（`check()`方法）和任务进度的动态更新（`tasks`集合的时间差计算）尤为出色。作者还标注了“流量会改变”“上传结束不立即置为normal”等坑点，对学习者极有帮助。

**题解二：HanPi（赞：7）**
* **点评**：此题解采用类封装（`file`、`folder`、`user`、`task`、`FTPServer`），代码结构更面向对象。作者特别指出“不需要每秒更新任务进度”（通过时间差计算），并提到测试数据中的特殊情况（如第167行的文件转文件夹），对实际调试有指导意义。

**题解三：Network_Flow（赞：3）**
* **点评**：此题解用数组存储文件/文件夹，通过索引管理父子关系，代码简洁高效。对`cd`、`addFile`等操作的实现（如递归更新文件夹大小）逻辑清晰，适合理解基础模拟流程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
模拟类问题的核心在于“细节处理”，以下是本题的三大关键难点及应对策略：
</difficulty_intro>

1.  **关键点1：动态流量计算与任务进度更新**
    * **分析**：上传/下载任务的流量（`userFlux`）由当前任务数决定（`presentMaxUserFlux = maxServerFlux / userTotal`），需在每次命令执行前更新。例如，当新任务加入或旧任务完成时，`userTotal`变化，流量也随之变化。
    * 💡 **学习笔记**：任务进度应按时间差（当前时间-上次更新时间）和实时流量计算，避免预计算总时间（因流量会变）。

2.  **关键点2：文件夹状态的传播与检查**
    * **分析**：文件夹的`uploading`状态由子文件决定。当子文件上传完成时，需递归检查父文件夹是否所有子文件都为`normal`，才能将父文件夹状态置为`normal`。例如，上传一个文件到文件夹A，A的状态变为`uploading`；文件上传完成后，若A中无其他`uploading`文件，A的状态才恢复`normal`。
    * 💡 **学习笔记**：用递归函数（如`check()`）遍历子文件/子文件夹，确保状态正确传播。

3.  **关键点3：多条件判断的命令处理**
    * **分析**：每个命令（如`download`）需检查用户是否在线、权限是否匹配、文件/文件夹是否存在且状态正常等。例如，`download`命令需用户是`downloadUser`且状态为`scan`，目标文件/文件夹存在且为`normal`。
    * 💡 **学习笔记**：将每个条件拆分为独立检查函数（如`checkDownload()`），提高代码可读性。

### ✨ 解题技巧总结
- **问题拆解**：将大问题拆分为用户管理、文件管理、任务管理等模块，分别实现。
- **状态可视化**：用结构体/类封装状态（如`User.state`、`File.state`），方便跟踪变化。
- **边界测试**：针对“根目录`cd..`”“同名文件上传”“任务数为0时的流量计算”等边界条件，设计测试用例。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，重点展示用户管理、任务处理和状态更新的关键逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合sumijie和HanPi的题解思路，重点实现`connect`、`download`、`upload`命令及任务进度更新逻辑。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <string>
    #include <set>
    using namespace std;

    struct File {
        string name;
        int size;
        int state; // 1-normal, 2-uploading
        File* fatherFolder; // 所属文件夹
        File(string n, int s, File* f) : name(n), size(s), state(1), fatherFolder(f) {}
    };

    struct Folder {
        string name;
        vector<File*> files;
        vector<Folder*> subFolders;
        int state; // 1-normal, 2-uploading
        Folder* father; // 父文件夹（根目录为nullptr）
        Folder(string n, Folder* f) : name(n), state(1), father(f) {}

        void checkState() { // 检查子文件状态，更新自身状态
            bool hasUploading = false;
            for (File* f : files) 
                if (f->state == 2) hasUploading = true;
            for (Folder* sub : subFolders) 
                if (sub->state == 2) hasUploading = true;
            state = hasUploading ? 2 : 1;
        }
    };

    struct Task {
        string userName;
        int remainingSize; // 剩余大小
        int lastUpdateTime; // 上次更新时间
        bool isUpload; // 是否上传任务
        File* targetFile; // 目标文件（上传/下载）
        Folder* targetFolder; // 目标文件夹（下载）
        Task(string u, int s, int t, bool up, File* f) 
            : userName(u), remainingSize(s), lastUpdateTime(t), isUpload(up), targetFile(f), targetFolder(nullptr) {}
        Task(string u, int s, int t, bool up, Folder* fol) 
            : userName(u), remainingSize(s), lastUpdateTime(t), isUpload(up), targetFile(nullptr), targetFolder(fol) {}
    };

    struct User {
        string name;
        int type; // 1-upload, 2-download, 3-guest
        int state; // 1-uploading, 2-downloading, 3-scan
        Folder* currentFolder; // 当前所在文件夹
        User(string n, int t, Folder* f) : name(n), type(t), state(3), currentFolder(f) {}
    };

    // 全局变量
    vector<User*> users;
    set<Task*> tasks;
    int maxUserNumber, maxServerFlux, maxUserFlux;
    Folder* root = new Folder("root", nullptr);

    // 辅助函数：查找用户
    User* findUser(string name) {
        for (User* u : users) 
            if (u->name == name) return u;
        return nullptr;
    }

    // 处理任务进度更新
    void updateTasks(int currentTime) {
        int userTotal = tasks.size();
        int presentMaxUserFlux = userTotal == 0 ? 0 : maxServerFlux / userTotal;
        int userFlux = min(presentMaxUserFlux, maxUserFlux);

        for (auto it = tasks.begin(); it != tasks.end();) {
            Task* t = *it;
            int deltaTime = currentTime - t->lastUpdateTime;
            t->remainingSize -= deltaTime * userFlux;
            t->lastUpdateTime = currentTime;

            if (t->remainingSize <= 0) { // 任务完成
                if (t->isUpload && t->targetFile) {
                    t->targetFile->state = 1; // 上传完成，文件状态恢复normal
                    t->targetFile->fatherFolder->checkState(); // 触发父文件夹状态检查
                }
                User* u = findUser(t->userName);
                if (u) u->state = 3; // 用户状态恢复scan
                tasks.erase(it++);
                delete t;
            } else {
                it++;
            }
        }
    }

    int main() {
        // 输入初始化（略）
        // 处理命令（以download为例）
        string name, cmd, target;
        int time;
        while (cin >> time >> name >> cmd) {
            updateTasks(time); // 先更新所有任务进度
            User* u = findUser(name);
            if (cmd == "download") {
                cin >> target;
                if (!u || u->type != 2 || u->state != 3) {
                    cout << "unsuccess" << endl;
                    continue;
                }
                // 检查目标文件/文件夹是否存在且状态正常（略）
                // 创建下载任务（略）
                cout << "success" << endl;
            }
            // 其他命令处理（略）
        }
        return 0;
    }
    ```
* **代码解读概要**：代码通过`File`、`Folder`、`User`、`Task`结构体建模实体，`updateTasks`函数处理任务进度（根据时间差和动态流量计算剩余大小），`checkState`方法维护文件夹状态。主函数循环读取命令，先更新任务进度，再处理具体操作。

---
<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：sumijie（关键片段）**
* **亮点**：用`set<Task*>`管理任务，自动按时间排序；`Folder::check()`递归检查子文件状态。
* **核心代码片段**：
    ```cpp
    void Folder::check() {
        bool flag = false;
        for (auto i = files.begin(); i != files.end(); i++) {
            if ((*i)->state != 1) {
                flag = true;
                break;
            }
        }
        if (!flag) this->state = 1;
    }

    // 任务处理循环
    for (auto it = tasks.begin(); it != tasks.end();) {
        auto i = *it;
        if (i->remove) {
            tasks.erase(it++); 
            continue;
        }
        i->size -= (second - i->time) * userFlux;
        i->time = second;
        if (i->size <= 0) {
            // 任务完成处理（略）
        }
    }
    ```
* **代码解读**：`Folder::check()`遍历子文件，若所有文件为`normal`，则将文件夹状态置为`normal`。任务循环中，根据时间差（`second - i->time`）和当前流量（`userFlux`）更新剩余大小，确保进度计算准确。
* 💡 **学习笔记**：用集合管理任务，便于动态增删；递归检查状态是维护文件夹状态的关键。

**题解二：HanPi（关键片段）**
* **亮点**：用类封装`FTPServer`，统一管理用户、任务和流量。
* **核心代码片段**：
    ```cpp
    class FTPServer {
    public:
        int maxUserNumber, maxServerFlux, maxUserFlux;
        vector<User*> users;
        set<Task*> tasks;

        void updateFlux() {
            int userTotal = tasks.size();
            presentMaxUserFlux = userTotal == 0 ? 0 : maxServerFlux / userTotal;
            userFlux = min(presentMaxUserFlux, maxUserFlux);
        }

        void updateTasks(int currentTime) {
            updateFlux();
            for (auto it = tasks.begin(); it != tasks.end();) {
                Task* t = *it;
                t->remainingSize -= (currentTime - t->lastTime) * userFlux;
                // 任务完成处理（略）
            }
        }
    };
    ```
* **代码解读**：`updateFlux`计算当前流量，`updateTasks`结合时间差和流量更新任务进度。类封装使服务器状态管理更集中。
* 💡 **学习笔记**：面向对象设计可提高代码模块化，降低维护难度。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解FTP服务器的操作流程，我们设计一个“像素FTP探险”动画，用8位风格展示文件夹层级、用户操作和任务进度！
</visualization_intro>

  * **动画演示主题**：`像素FTP探险——管理你的文件服务器`

  * **核心演示内容**：展示用户连接（`connect`）、目录切换（`cd`/`cd..`）、上传/下载（`upload`/`download`）的全过程，重点突出文件夹状态变化（`normal`→`uploading`）和任务进度条动态更新。

  * **设计思路简述**：采用FC红白机风格（16色像素），用分层网格表示文件夹（根目录为第0层，子文件夹为下一层）。用户用不同颜色的小人表示（绿色-上传用户，蓝色-下载用户），文件/文件夹用方块（绿色-`normal`，红色闪烁-`uploading`）。任务进度条显示在用户头顶，流量数值实时更新，关键操作（如任务完成）播放8位音效，增强沉浸感。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
          * 屏幕左侧显示文件夹树（根目录为大绿色方块，子文件夹为小方块层叠）。
          * 右侧显示用户列表（像素小人+名称+类型）和任务列表（进度条+剩余大小）。
          * 底部为控制面板（单步/自动播放按钮、速度滑块）。

    2.  **用户连接（connect）**：
          * 用户小人从屏幕右侧滑入，头顶显示“success”气泡，伴随“叮”音效。
          * 用户列表新增条目，当前用户数（`nowCount`）加1并高亮。

    3.  **目录切换（cd）**：
          * 用户小人向目标文件夹方块移动（动画：像素步移动），到达后文件夹边框闪烁绿色。
          * 当前文件夹路径（如`root/bin`）更新显示在顶部。

    4.  **上传任务（upload）**：
          * 用户小人头顶出现红色上传图标（↑），目标文件方块变为红色闪烁（`uploading`）。
          * 任务列表新增条目，进度条从0%开始增长（根据流量动态计算）。
          * 每更新一次进度（如1秒），播放“滴答”音效。

    5.  **任务完成**：
          * 进度条填满时，文件方块恢复绿色（`normal`），触发父文件夹递归检查（父文件夹依次检查子文件，若全为绿色则恢复绿色）。
          * 用户小人头顶图标消失，播放“胜利”音效（升调），任务列表移除该任务。

    6.  **用户断开（quit）**：
          * 用户小人淡出屏幕，伴随“噗”音效，用户列表移除该条目，当前用户数减1。

  * **旁白提示**：
      * （用户连接时）“用户`ares`成功连接，当前在线用户数：1！”
      * （上传开始时）“开始上传文件`A`，当前流量：200byte/s，预计需要2秒～”
      * （任务完成时）“文件`A`上传完成，文件夹`bin`状态恢复正常！”

<visualization_conclusion>
通过这个像素动画，你可以直观看到用户操作如何影响服务器状态，文件/文件夹如何“变色”，任务进度如何动态更新。这种“看得见”的模拟，能帮你更快理解复杂的状态变化逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
模拟类题目考验对规则的细致处理和代码的模块化设计。掌握本题后，可尝试以下题目巩固能力：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 本题的“状态管理”和“多任务处理”技巧可迁移到：操作系统进程调度模拟、游戏角色状态管理、物流系统订单跟踪等场景。
      - 关键是将复杂规则拆解为“实体状态”+“操作触发条件”+“状态转移逻辑”。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1093 奖学金**  
        * 🗣️ **推荐理由**：模拟学生分数排序和奖学金发放，需处理多条件排序和状态统计，适合练习基础模拟逻辑。
    2.  **洛谷 P1323 删数问题**  
        * 🗣️ **推荐理由**：模拟删除数字的过程，需动态维护最优解，锻炼贪心+模拟的综合能力。
    3.  **洛谷 P5741 旗鼓相当的对手**  
        * 🗣️ **推荐理由**：模拟统计班级成绩，需处理多维度条件判断，适合练习细节处理。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解作者们分享了许多调试经验，这些“踩坑”经历对我们很有启发：
</insights_intro>

> **参考经验 (sumijie)**：“流量会改变！不能用下载时的流量预计算总时间，必须每过一段时间更新任务进度。上传结束后，文件夹状态不能直接置为normal，要遍历所有子文件重新检查。”
>
> **点评**：sumijie的经验点出了模拟类题目的核心——“动态性”。文件/文件夹状态、流量等都可能随时间变化，必须实时更新。调试时，建议打印关键变量（如当前流量、任务剩余大小），快速定位错误。

> **参考经验 (HanPi)**：“最后一个测试点数据有问题，第167行的文件被当作文件夹使用，需要特判。”
>
> **点评**：这提醒我们，面对“数据异常”时，可通过观察测试样例的输入输出，针对性调整代码（如特判某行操作）。

-----

<conclusion>
模拟类题目是编程能力的“试金石”，需要耐心和细致。通过本题的学习，你不仅掌握了FTP服务器的模拟方法，更重要的是学会了如何拆解复杂问题、设计数据结构。记住：多调试、多打印，细节决定成败！下次挑战更难的模拟题，你一定行！💪
</conclusion>

-----

---
处理用时：189.43秒
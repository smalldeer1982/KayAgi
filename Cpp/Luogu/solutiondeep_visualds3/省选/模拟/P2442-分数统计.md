# 题目信息

# 分数统计

## 题目背景

大宁考完联赛回来，成功的躲过了期中考试，但是他的班主任 Yellow_sword  不会放过他。

## 题目描述

Yellow_sword 要大宁给他弄一个数据库，维护班级的考试平均分。每个人期中考试各科的分数已经被统一的转化为评价值，为一个 $[1,100]$ 之间的整数。它评价了这个人的总体水平，现在 Yellow_sword 丢给了大宁 $n$ 个班级的班级平均评价值和每个班的人数，由于 Yellow_sword 和大宁都很懒，所以都假装每个班每个人的评价值就是班级的平均评价值。他想知道：

1. 连续的若干个班所有人评价值的平均数。
2. 连续的若干个班所有人评价值的众数（若有多个取最小的那个众数）。
3. 连续的若干个班所有人评价值的极差（即评价值最高和最低的差）。

既然大家都很懒，那事情就给你来做了。

## 说明/提示

|测试点| 数据规模| 时限 |
| :-------:| :----:| :----: |
| $1\sim3$ |$n=q=10^3$| $0.5s$ |
|$4\sim5$| $n=q=5\times 10^4$| $0.5s$ |
| $6\sim 7$ |     $n=q=10^5$| $1s$ |
| $8\sim 10$ |  $n=q=2\times 10^5$| $1s$ |

**建议使用较快的读入方式。**

## 样例 #1

### 输入

```
5 3
90 100 90 90 80
2 1 2 1 8
1 1 3
2 3 5
3 1 2
```

### 输出

```
92.00
80
10
```

# AI分析结果



---
# 💡 Kay的C++算法解析：分数统计 深入学习指南 💡

<introduction>
今天我们来一起分析“分数统计”这道C++编程题。题目需要处理三个操作：区间平均数、区间众数（取最小）、区间极差。数据规模大（n和q可达2e5），需要高效算法。本指南将帮助大家梳理思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数据结构综合应用（分块/莫队算法）`  

🗣️ **初步分析**：
> 解决“分数统计”的关键在于高效处理多类型区间查询。由于数值范围小（1-100），分块或莫队算法是核心思路。分块算法将数组分成若干块，预处理块内信息，查询时结合块内暴力和块间预处理结果，平衡时间与空间；莫队算法通过离线排序查询，利用移动指针维护当前区间的统计信息。

- **题解思路对比**：多数题解采用分块（如s_r_f、LG_kemeng），预处理每块的数值统计，查询时暴力处理边角块+块间前缀和；部分题解用莫队（如zhengrunzhe），离线处理众数查询。分块更适合在线查询，莫队适合离线但时间复杂度稍高（O(n√n)）。
- **核心算法流程**：以分块为例，预处理每块的数值出现次数前缀和，查询时：
  - 平均数：总分数/总人数（前缀和直接计算）。
  - 众数：统计边角块的数值次数+块间前缀和，遍历1-100找最大值（最小优先）。
  - 极差：边角块暴力找最大最小值+块间预处理的最值。
- **可视化设计**：采用8位像素风格，将数组分块为彩色方块（每块颜色不同），查询时边角块闪烁，块间数据用像素堆叠显示次数，众数用金色闪烁标记，极差用最高/最低值的像素箭头对比。

---

## 2. 精选优质题解参考

<eval_intro>
通过思路清晰度、代码规范性、算法有效性等维度筛选，以下题解值得重点学习：
</eval_intro>

**题解一：s_r_f的分块解法**  
* **点评**：此题解思路简洁，利用分块预处理每块的数值前缀和，时间复杂度O(q*100)，空间线性（O(n*100/S)，S=40）。代码变量命名清晰（如`prea`为总分数前缀，`cnt[j][i]`为前i块数值j的总人数），边界处理严谨（如`cl[i]`和`cr[i]`标记块的左右端点），适合竞赛快速实现。

**题解二：LG_kemeng的分块众数优化**  
* **点评**：此题解在分块基础上预处理块间众数（`mode[i][j]`）和最值（`smaximum`/`sminimum`），减少查询时的暴力统计。代码结构工整（分块初始化、预处理、查询逻辑分离），但稍显复杂，适合理解分块的进阶应用。

**题解三：zhengrunzhe的莫队+ST表解法**  
* **点评**：此题解离线处理众数（莫队），在线处理平均数（前缀和）和极差（ST表），充分利用各算法优势。代码简洁（如`add`/`del`函数维护当前区间的数值次数），适合学习多算法结合的思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理多类型查询的高效性，以下是三个核心难点及策略：
</difficulty_intro>

1.  **关键点1：众数的高效统计**  
    * **分析**：众数需统计区间内各值的总人数，直接暴力统计O(n)会超时。分块预处理每块的数值人数前缀和（如`s_r_f`的`cnt[j][i]`），查询时边角块暴力+块间前缀和，总时间O(100)；莫队通过移动指针维护当前区间的数值次数（如`zhengrunzhe`的`cnt`数组），总时间O(n√n)。  
    * 💡 **学习笔记**：数值范围小（1-100）是关键突破口，利用前缀和或滑动窗口统计次数。

2.  **关键点2：多操作的综合处理**  
    * **分析**：平均数用前缀和（O(1)查询），极差用ST表或分块预处理（O(1)或O(√n)查询），众数用分块或莫队（O(100)或O(√n)查询）。需根据操作特点选择算法，避免时间/空间冗余。  
    * 💡 **学习笔记**：分块适合在线多操作，莫队适合离线但需排序查询。

3.  **关键点3：空间优化**  
    * **分析**：直接存储100个数值的前缀和需O(n*100)空间（如Maniac丶坚果的代码），无法通过空间限制。分块将空间降至O((n/S)*100)（S为块长，如S=40），满足要求。  
    * 💡 **学习笔记**：分块是平衡时间与空间的常用技巧，块长S通常取√n或类似值。

### ✨ 解题技巧总结
- **问题分解**：将多操作拆解为独立子问题（平均数→前缀和，众数→分块/莫队，极差→ST表/分块）。
- **数值范围利用**：1-100的数值范围允许暴力遍历统计次数，简化众数计算。
- **分块设计**：块长S取√n或40左右，平衡预处理和查询时间。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们以s_r_f的分块解法为基础，提炼通用核心代码，兼顾效率与可读性。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合分块思路，预处理每块的数值人数前缀和，处理三种查询。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
#define LL long long
using namespace std;
template <typename T> void read(T &x) {
    static char ch; x = 0, ch = getchar();
    while (!isdigit(ch)) ch = getchar();
    while (isdigit(ch)) x = x * 10 + ch - '0', ch = getchar();
}
const int N = 200005, S = 40; // 块长设为40，平衡时间空间
int n, m, a[N], b[N], cur[N], cl[N], cr[N], prea[N], preb[N], cnt[101][N/S + 5];

int main() {
    read(n), read(m);
    for (int i = 1; i <= n; ++i) read(a[i]);
    for (int i = 1; i <= n; ++i) {
        cur[i] = (i - 1) / S + 1; // 计算i所属的块
        read(b[i]);
        prea[i] = prea[i - 1] + a[i] * b[i]; // 总分数前缀和
        preb[i] = preb[i - 1] + b[i]; // 总人数前缀和
    }
    for (int i = 1; i <= cur[n]; ++i) { // 预处理每块的数值人数前缀和
        cl[i] = S * (i - 1) + 1; // 块i左端点
        cr[i] = min(n, S * i); // 块i右端点
        for (int j = 1; j <= 100; ++j) cnt[j][i] = cnt[j][i - 1]; // 继承前i-1块的统计
        for (int j = cl[i]; j <= cr[i]; ++j) cnt[a[j]][i] += b[j]; // 统计块i内数值a[j]的人数
    }
    while (m--) {
        int op, l, r; read(op), read(l), read(r);
        if (op == 1) { // 平均数
            double avg = (double)(prea[r] - prea[l - 1]) / (preb[r] - preb[l - 1]);
            printf("%.2lf\n", avg);
            continue;
        }
        int now[101] = {0}; // 统计当前查询区间各数值的人数
        int curl = cur[l], curr = cur[r];
        if (curl + 1 >= curr) { // 边角块暴力统计
            for (int i = l; i <= r; ++i) now[a[i]] += b[i];
        } else { // 块间用前缀和，边角块暴力
            for (int i = l; i <= cr[curl]; ++i) now[a[i]] += b[i];
            for (int i = cl[curr]; i <= r; ++i) now[a[i]] += b[i];
            for (int j = 1; j <= 100; ++j) now[j] += cnt[j][curr - 1] - cnt[j][curl]; // 块间前缀和
        }
        if (op == 2) { // 众数（最小优先）
            int ans = 1;
            for (int j = 2; j <= 100; ++j) 
                if (now[j] > now[ans]) ans = j;
            printf("%d\n", ans);
        } else if (op == 3) { // 极差
            int mn = 101, mx = 0;
            for (int j = 1; j <= 100; ++j) 
                if (now[j]) { mn = j; break; }
            for (int j = 100; j; --j) 
                if (now[j]) { mx = j; break; }
            printf("%d\n", mx - mn);
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先预处理每块的数值人数前缀和（`cnt[j][i]`），处理查询时：  
  - 平均数通过总分数前缀和（`prea`）和总人数前缀和（`preb`）计算。  
  - 众数统计边角块和块间的数值人数（`now`数组），遍历1-100找最大值（最小优先）。  
  - 极差通过遍历`now`数组找最小和最大非零值，计算差值。

<code_intro_selected>
接下来分析优质题解的核心片段：
</code_intro_selected>

**题解一：s_r_f的分块解法**  
* **亮点**：块长设为40，平衡时间空间；预处理块的数值人数前缀和，查询时快速统计。  
* **核心代码片段**：
```cpp
for (int i = 1; i <= cur[n]; ++i) {
    cl[i] = S*(i-1)+1, cr[i] = min(n,S*i);
    for (int j = 1; j <= 100; ++j) cnt[j][i] = cnt[j][i-1];
    for (int j = cl[i]; j <= cr[i]; ++j) cnt[a[j]][i] += b[j]; 
}
```
* **代码解读**：  
  这段代码预处理每块的数值人数前缀和。`cl[i]`和`cr[i]`标记块i的左右端点，`cnt[j][i]`表示前i块中数值j的总人数（继承前i-1块的统计，加上当前块内的人数）。这样查询块间数值j的人数时，可直接用`cnt[j][curr-1] - cnt[j][curl]`计算。  
* 💡 **学习笔记**：分块预处理的关键是存储块间前缀和，减少重复统计。

**题解二：zhengrunzhe的莫队解法**  
* **亮点**：离线处理众数，用`add`/`del`函数维护当前区间的数值次数，代码简洁。  
* **核心代码片段**：
```cpp
inline const void add(const int &x) { cnt[a[x]] += b[x]; }
inline const void del(const int &x) { cnt[a[x]] -= b[x]; }
// 莫队移动指针
while (r < q[i].r) add(++r);
while (l > q[i].l) add(--l);
while (r > q[i].r) del(r--);
while (l < q[i].l) del(l++);
```
* **代码解读**：  
  `add`和`del`函数通过增减`cnt`数组维护当前区间内各数值的人数。莫队通过排序查询（按块排序），移动左右指针调整当前区间，保证时间复杂度O(n√n)。  
* 💡 **学习笔记**：莫队适合离线查询，需注意排序方式（块内奇偶排序优化）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解分块处理过程，我们设计一个8位像素风格的动画，模拟分块预处理和查询过程。
\</visualization_intro\>

  * **动画演示主题**：`像素分块小能手——统计大作战`  
  * **核心演示内容**：分块预处理每块的数值人数，查询时边角块暴力统计+块间前缀和计算众数/极差。  
  * **设计思路简述**：8位像素风（FC游戏风格）营造轻松氛围，用不同颜色区分块（如红、绿、蓝），数值用像素数字显示。关键操作（如块预处理、查询统计）伴随“叮”音效，完成查询播放“胜利”音效，增强记忆。

  * **动画帧步骤与交互关键点**：  
    1. **初始化场景**：  
       - 屏幕上方显示分块后的数组（每个块为彩色矩形，标注块号），下方为控制面板（单步/自动/调速按钮）。  
       - 播放8位风格BGM（如《超级马里奥》经典旋律）。  

    2. **预处理块统计**：  
       - 动画逐个块处理：块i的矩形闪烁，数值a[j]的像素数字从块内弹出，累加到`cnt[j][i]`的像素计数器（显示数值j的总人数）。  

    3. **查询操作演示**：  
       - **平均数**：总分数和总人数的像素数字从l到r滑动，相除得到结果（像素计算器动画）。  
       - **众数**：边角块的像素逐个高亮（显示数值和人数），块间前缀和的像素计数器叠加，最后众数像素（金色）闪烁并放大。  
       - **极差**：最小/最大值的像素箭头从边角块和块间弹出，对比显示差值。  

    4. **交互控制**：  
       - 单步执行：点击“单步”，逐帧显示预处理或查询步骤。  
       - 自动播放：调速滑块控制速度（慢→快），观察整体流程。  

  * **旁白提示**：  
    - 预处理时：“看！每个块在统计自己的数值人数，这样查询时就能快速计算啦～”  
    - 众数统计时：“边角块的数值在暴力统计，块间用预处理的前缀和，这样就不用重复计算啦！”  

\<visualization_conclusion\>
通过像素动画，我们能直观看到分块如何平衡预处理和查询时间，理解众数/极差的高效计算逻辑。
\</visualization_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
掌握本题后，可尝试以下题目巩固分块/莫队算法：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：  
    分块/莫队算法适用于数值范围小、多区间查询的问题，如统计区间内不同数的个数（HH的项链）、区间频率问题（蒲公英）等。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1972 [SDOI2009]HH的项链**  
       * 🗣️ **推荐理由**：经典莫队题，练习离线处理区间不同数的个数，与本题众数统计思路类似。  
    2.  **洛谷 P4168 [Violet]蒲公英**  
       * 🗣️ **推荐理由**：分块处理区间众数的典型题，块长优化和预处理技巧值得学习。  
    3.  **洛谷 P1816 忠诚**  
       * 🗣️ **推荐理由**：ST表处理区间最小值，练习极差统计的高效方法。  

---

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解提到调试经验，对我们很有启发：
\</insights_intro\>

> **参考经验 (来自Maniac丶坚果)**：“调试时发现总分数会溢出，改用long long后解决。块长选择需测试，80-100时最优。”  
> **点评**：数据类型（如long long）和块长选择是常见坑点。处理大数值时需注意溢出，块长需根据题目调整（如本题块长40或80）。

---

\<conclusion\>
本次“分数统计”的分析就到这里。通过分块/莫队算法，我们能高效处理多类型区间查询。记住，多练习、多总结，编程能力会稳步提升！下次见～💪
\</conclusion\>

---
处理用时：168.73秒
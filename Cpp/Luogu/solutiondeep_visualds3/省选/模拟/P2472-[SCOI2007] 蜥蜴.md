# 题目信息

# [SCOI2007] 蜥蜴

## 题目描述

在一个 $r$ 行 $c$ 列的网格地图中有一些高度不同的石柱，第 $i$ 行 $j$ 列的石柱高度为 $h_{i,j}$。

一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃到边界外。

每行每列中相邻石柱的距离为 $1$，蜥蜴的跳跃距离是 $d$，即蜥蜴可以跳到**平面距离**不超过 $d$ 的任何一个石柱上。

石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减 $1$（如果仍然落在地图内部，则到达的石柱高度不变）。

如果该石柱原来高度为 $1$，则蜥蜴离开后消失，以后其他蜥蜴不能落脚。

任何时刻不能有两只蜥蜴在同一个石柱上。

## 说明/提示

对于 $100\%$ 的数据满足：$1\le r,c\le20$，$1\le d\le 4$，$1\le h\le 3$。

## 样例 #1

### 输入

```
5 8 2
00000000
02000000
00321100
02000000
00000000
........
........
..LLLL..
........
........
```

### 输出

```
1```

# AI分析结果



---
# 💡 Kay的C++算法解析：[SCOI2007] 蜥蜴 深入学习指南 💡

<introduction>
今天我们要一起攻克这道经典的网络流题目——“[SCOI2007] 蜥蜴”。这道题的关键在于将问题转化为最大流模型，通过巧妙的拆点技巧和网络流算法求解。让我们一步步拆解，理解核心思路，掌握解题方法！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`网络流（最大流建模）` 

🗣️ **初步分析**：
解决这道题的关键在于将“蜥蜴跳跃”问题转化为网络流中的最大流问题。简单来说，最大流算法就像给水管网找“最粗的水管”，让尽可能多的水流（蜥蜴）从源点（起点）流到汇点（边界外）。在本题中，我们需要用“拆点法”处理石柱的使用次数限制，将每个石柱拆分为入点和出点，通过边容量限制其最多被使用的次数（即石柱高度）。

- **题解思路**：所有优质题解均采用“最大流+拆点法”。核心步骤包括：① 拆点（石柱入点→出点，容量为高度）；② 源点连蜥蜴所在石柱入点（容量1）；③ 出点连能跳边界的汇点（容量无穷大）；④ 出点连其他可达石柱入点（容量无穷大）。最后求最大流，用蜥蜴总数减最大流得答案。
- **核心难点**：如何正确建模石柱的使用限制（拆点）、处理跳跃距离的计算（欧几里得距离）、以及最大流算法的高效实现（如Dinic的分层和当前弧优化）。
- **可视化设计**：采用8位像素风格动画，用不同颜色区分入点（蓝色）、出点（绿色）、源点（红色）、汇点（黄色）。动画中，石柱入点→出点的边会动态显示容量（高度），蜥蜴（像素小人）从源点出发，沿边流动，经过石柱时边容量减少，最终到达汇点时播放“胜利”音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对各题解的思路清晰度、代码规范性、算法有效性等维度的评估，以下3篇题解因逻辑清晰、代码规范且解释详尽，被选为优质参考：
</eval_intro>

**题解一：LeavingZzz（赞：69）**  
* **点评**：此题解详细解释了拆点法的必要性（解决“多源汇入同一石柱”的容量限制问题），并通过图示和代码注释清晰展示了建模过程。代码中使用Dinic算法，包含当前弧优化，结构规范（如`add`函数封装边添加），变量名（如`u`, `v`, `cf`）含义明确。亮点在于对距离计算的边界条件处理（如直接分类讨论d=1~4的情况），适合学习网络流建模细节。

**题解二：Ajwallet（赞：75）**  
* **点评**：此题解以简洁的语言概括了建模思路，并通过图示直观展示了拆点后的网络结构（源点→入点→出点→汇点）。代码中对石柱的入点编号、出点编号处理清晰（如`num(i,j)`函数），且关键步骤（如连边到汇点）注释明确。亮点是将复杂的距离计算转化为预定义的邻接关系，降低代码复杂度。

**题解三：ifyml（赞：33）**  
* **点评**：此题解从网络流的基本概念（源点、汇点、容量）入手，逐步推导到本题的建模过程，适合初学者理解。代码中对Dinic算法的BFS分层和DFS找增广路的实现清晰，关键变量（如`cur`数组用于当前弧优化）注释详细。亮点是将“石柱能否跳出边界”的条件判断独立为逻辑块，提升代码可读性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们可能会遇到以下核心难点。结合优质题解的经验，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何用“拆点法”限制石柱的使用次数？**  
    * **分析**：每个石柱最多被h只蜥蜴使用（每次跳跃减1，高度为h时可用h次）。拆点法将石柱分为入点（接收其他石柱的跳跃）和出点（向其他石柱跳跃），入点→出点的边容量设为h，直接限制了该石柱的使用次数。例如，石柱A的入点A1到出点A2的边容量为h，表示最多h只蜥蜴通过A。
    * 💡 **学习笔记**：拆点法是处理“节点容量限制”的常用技巧，通过将节点拆分为入点和出点，将节点容量转化为边容量。

2.  **关键点2：如何正确建立跳跃关系的边？**  
    * **分析**：蜥蜴可跳跃到平面距离≤d的石柱或边界外。对于地图内的石柱，需计算两石柱的欧几里得距离（如`(x1-x2)² + (y1-y2)² ≤ d²`），并从出点连到目标石柱的入点（容量无穷大）。对于能跳出边界的石柱，直接从出点连到汇点（容量无穷大）。
    * 💡 **学习笔记**：距离计算时注意使用平方比较（避免浮点运算），边界判断需检查石柱坐标是否满足“i≤d 或 i+d>r 或 j≤d 或 j+d>c”。

3.  **关键点3：如何高效实现最大流算法（如Dinic）？**  
    * **分析**：Dinic算法的核心是分层（BFS）和找增广路（DFS）。分层时用BFS建立层次图，确保每次DFS只沿最短路径增广；DFS时用当前弧优化（`cur`数组）避免重复检查无效边，提升效率。
    * 💡 **学习笔记**：当前弧优化是Dinic的关键优化，通过记录每个节点当前处理到的边，避免重复遍历已处理的边，时间复杂度可优化至O(n²m)。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题转化**：将“最大逃脱数”转化为“最大流问题”，通过源点、汇点、中间节点的边容量建模约束。
- **拆点技巧**：节点容量限制→拆分为入点和出点，入点→出点的边容量为节点容量。
- **边界处理**：独立判断石柱能否跳出边界，减少主逻辑的复杂度。
- **代码模块化**：将连边、距离计算、最大流算法封装为函数，提升可读性和复用性。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合了LeavingZzz和Ajwallet的题解，提炼出一个简洁、规范的核心实现，展示网络流建模和Dinic算法的关键步骤。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了多个优质题解的思路，采用拆点法建模石柱限制，Dinic算法求解最大流，代码结构清晰，关键步骤注释详尽。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <algorithm>
    #include <queue>
    #include <cstring>
    using namespace std;

    const int MAXN = 805; // 节点数：r*c*2 + 2
    const int MAXM = 100005; // 边数
    const int INF = 0x3f3f3f3f;

    struct Edge {
        int to, next, cap;
    } e[MAXM];
    int head[MAXN], cnt = 1; // 边从2开始，方便异或找反向边
    int cur[MAXN], dep[MAXN]; // 当前弧优化、分层数组

    inline void add(int u, int v, int cap) {
        e[++cnt] = {v, head[u], cap}; head[u] = cnt;
        e[++cnt] = {u, head[v], 0}; head[v] = cnt;
    }

    // BFS分层
    bool bfs(int s, int t) {
        memset(dep, -1, sizeof(dep));
        queue<int> q; q.push(s); dep[s] = 0;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = head[u]; i; i = e[i].next) {
                int v = e[i].to;
                if (e[i].cap > 0 && dep[v] == -1) {
                    dep[v] = dep[u] + 1;
                    q.push(v);
                    if (v == t) return true;
                }
            }
        }
        return false;
    }

    // DFS找增广路（当前弧优化）
    int dfs(int u, int t, int flow) {
        if (u == t) return flow;
        for (int &i = cur[u]; i; i = e[i].next) {
            int v = e[i].to;
            if (e[i].cap > 0 && dep[v] == dep[u] + 1) {
                int f = dfs(v, t, min(flow, e[i].cap));
                if (f) {
                    e[i].cap -= f;
                    e[i^1].cap += f;
                    return f;
                }
            }
        }
        return 0;
    }

    // Dinic算法求最大流
    int dinic(int s, int t) {
        int max_flow = 0;
        while (bfs(s, t)) {
            memcpy(cur, head, sizeof(head)); // 重置当前弧
            while (int f = dfs(s, t, INF)) {
                max_flow += f;
            }
        }
        return max_flow;
    }

    int r, c, d, tot_lizards = 0;
    int h[25][25]; // 石柱高度
    char grid[25][25]; // 蜥蜴位置

    // 计算石柱(i,j)的入点编号（出点为入点 + r*c）
    inline int in_node(int i, int j) { return (i-1)*c + j; }
    inline int out_node(int i, int j) { return in_node(i, j) + r*c; }

    int main() {
        scanf("%d%d%d", &r, &c, &d);
        int s = 0, t = 2*r*c + 1;

        // 输入石柱高度并建入点→出点边
        for (int i = 1; i <= r; i++) {
            scanf("%s", grid[i]+1);
            for (int j = 1; j <= c; j++) {
                h[i][j] = grid[i][j] - '0';
                if (h[i][j] > 0) {
                    add(in_node(i, j), out_node(i, j), h[i][j]);
                }
            }
        }

        // 输入蜥蜴位置并建源点→入点边
        for (int i = 1; i <= r; i++) {
            scanf("%s", grid[i]+1);
            for (int j = 1; j <= c; j++) {
                if (grid[i][j] == 'L' && h[i][j] > 0) {
                    add(s, in_node(i, j), 1);
                    tot_lizards++;
                }
            }
        }

        // 建出点→汇点边（能跳出边界的石柱）
        for (int i = 1; i <= r; i++) {
            for (int j = 1; j <= c; j++) {
                if (h[i][j] > 0 && (i <= d || i + d > r || j <= d || j + d > c)) {
                    add(out_node(i, j), t, INF);
                }
            }
        }

        // 建出点→其他可达石柱入点的边
        for (int i1 = 1; i1 <= r; i1++) {
            for (int j1 = 1; j1 <= c; j1++) {
                if (h[i1][j1] == 0) continue;
                for (int i2 = 1; i2 <= r; i2++) {
                    for (int j2 = 1; j2 <= c; j2++) {
                        if (h[i2][j2] == 0 || (i1 == i2 && j1 == j2)) continue;
                        int dx = i1 - i2, dy = j1 - j2;
                        if (dx*dx + dy*dy <= d*d) {
                            add(out_node(i1, j1), in_node(i2, j2), INF);
                        }
                    }
                }
            }
        }

        int max_escape = dinic(s, t);
        printf("%d\n", tot_lizards - max_escape);
        return 0;
    }
    ```
* **代码解读概要**：此代码首先读取输入，构建石柱的入点和出点，并建立入点→出点的边（容量为石柱高度）。然后，源点连接到有蜥蜴的入点（容量1），能跳出边界的出点连接到汇点（容量INF），其他可达石柱的出点连接到目标入点（容量INF）。最后通过Dinic算法计算最大流，得到最多能逃脱的蜥蜴数，用总数减去最大流即为答案。

---
<code_intro_selected>
接下来，我们选取LeavingZzz题解的核心片段，分析其亮点和实现细节：
</code_intro_selected>

**题解一：LeavingZzz（来源：洛谷题解）**  
* **亮点**：代码中对距离的处理采用分类讨论（d=1~4），减少了四层循环的计算量；`linkE`函数封装连边逻辑，提升代码复用性。
* **核心代码片段**：
    ```cpp
    inline void linkE(int u, int i, int j) {
        if (i < 1 || i > N || j < 1 || j > M) { // 跳出边界，连到汇点
            add(u, T, inf);
            return;
        }
        if (m1[i][j] == '0') return; // 目标无石柱
        add(u, num(i, j), inf); // 连到目标入点
    }

    inline void link(int i, int j) { // 处理石柱(i,j)的所有连边
        if (m1[i][j] == '0') return;
        add(num(i, j), num(i, j) + all, m1[i][j] - '0'); // 入点→出点，容量为高度
        if (m2[i][j] == 'L') add(S, num(i, j), 1), ans++; // 源点→入点（蜥蜴）
        if (i == 1 || j == 1 || i == N || j == M) add(num(i, j) + all, T, inf); // 出点→汇点（边界）
        int u = num(i, j) + all; // 出点
        // 分类讨论d的取值，连接可达石柱
        if (d >= 1) linkE(u, i-1, j), linkE(u, i+1, j), linkE(u, i, j-1), linkE(u, i, j+1);
        if (d >= 2) linkE(u, i-2, j), linkE(u, i+2, j), ...; // 省略部分代码
        // d≥3、d≥4的情况类似
    }
    ```
* **代码解读**：`linkE`函数处理“从出点u连接到位置(i,j)”的逻辑，若(i,j)在边界外则连到汇点，否则连到目标石柱的入点。`link`函数为每个石柱建立入点→出点的边（容量为高度），并根据是否有蜥蜴、是否能跳出边界，建立源点→入点、出点→汇点的边。分类讨论d的取值，减少了不必要的距离计算，提升效率。
* 💡 **学习笔记**：分类讨论d的取值（d≤4）是本题的优化技巧，避免了四层循环计算所有可能的石柱对，适合小数据范围的题目。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解网络流建模和最大流的过程，我们设计了一个“像素蜥蜴大逃亡”的8位复古动画。通过动态展示石柱拆点、边容量变化和蜥蜴流动，帮助大家“看”懂算法！
</visualization_intro>

  * **动画演示主题**：`像素蜥蜴的逃亡之旅`  
  * **核心演示内容**：展示石柱拆分为入点（蓝色方块）和出点（绿色方块），蜥蜴（黄色小人）从源点（红色城堡）出发，经过入点→出点（边容量动态减少），跳跃到其他石柱或直接跳出边界（汇点，金色城堡）的过程。

  * **设计思路简述**：采用FC红白机风格，用简单的像素方块表示节点，边用箭头表示。关键操作（如入点→出点的容量减少）用颜色渐变（绿色→黄色→红色）提示，跳跃时播放“叮”的音效，成功到达汇点时播放“胜利”音效，增强操作记忆。

  * **动画帧步骤与交互关键点**：
    1. **初始化场景**：屏幕分为左右两部分，左半部分为网格地图（石柱用蓝绿方块表示），右半部分为控制面板（单步/自动播放按钮、速度滑块）。顶部显示石柱高度、当前流量等信息。
    2. **建图阶段**：动态绘制入点→出点的边（容量为石柱高度，绿色条显示），源点→蜥蜴入点的边（红色细线），出点→汇点的边（金色粗线），其他可达边（灰色虚线）。
    3. **最大流过程**：
        - **BFS分层**：用蓝色渐变标记节点层次（源点为0层，汇点为最高层）。
        - **DFS增广**：蜥蜴小人沿当前路径移动，经过的边容量减少（绿色条缩短），反向边容量增加（红色条增长）。
        - **当前弧优化**：用箭头标记当前处理的边，避免重复遍历。
    4. **结束状态**：所有增广路处理完毕后，汇点显示成功逃脱的蜥蜴数，未逃脱的蜥蜴数用红色数字提示。

  * **旁白提示**：
    - “看！石柱被拆成了蓝色入点和绿色出点，中间的绿色条表示还能使用多少次。”
    - “蜥蜴从红色源点出发，只能走容量足够的边哦～”
    - “这条边的容量用完了（变红），其他蜥蜴得找别的路啦！”

<visualization_conclusion>
通过这样的动画，我们可以直观看到网络流中“分层→增广→优化”的过程，理解拆点法如何限制石柱使用次数，以及最大流算法如何找到最多的逃脱路径。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“蜥蜴问题”的网络流建模方法后，我们可以尝试以下拓展练习，巩固网络流的应用能力：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的拆点法和最大流建模思想可用于以下场景：  
    1. **节点容量限制问题**（如服务器处理请求，每个服务器最多处理k次）；  
    2. **多源多汇问题**（如多个起点到多个终点的最大运输量）；  
    3. **距离限制的连接问题**（如无线传感器网络的覆盖范围）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3376** - `【模板】网络最大流`  
        * 🗣️ **推荐理由**：网络流的模板题，适合练习Dinic算法的实现和调试。
    2.  **洛谷 P1345** - `[USACO5.4] 奶牛的电信Telecowmunication`  
        * 🗣️ **推荐理由**：需要拆点处理节点的最小割，巩固拆点法的应用。
    3.  **洛谷 P2762** - `太空飞行计划问题`  
        * 🗣️ **推荐理由**：最大权闭合子图问题，通过最大流建模求解，拓展网络流的应用场景。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
在题解中，多位作者提到了调试过程中遇到的问题，例如：
</insights_intro>

> **参考经验 (来自 LeavingZzz)**：“一开始没有正确拆点，导致石柱的使用次数未被限制，后来通过打印中间变量（如边容量）发现了问题。这让我意识到，拆点法的关键是确保入点→出点的边容量正确对应石柱高度。”

**点评**：这位作者的经验提醒我们，网络流建模中节点和边的对应关系非常重要。调试时可以通过打印边的容量变化（如入点→出点的剩余容量），快速定位建模错误。此外，对于距离计算等关键逻辑，建议先手动验证几个测试用例（如d=1时的相邻石柱），确保代码正确性。

-----

<conclusion>
通过这道题的学习，我们掌握了网络流建模的核心技巧——拆点法，以及Dinic算法的实现。希望大家在练习中多思考、多调试，逐步提升网络流问题的解决能力！下次见～ 💪
</conclusion>

---
处理用时：213.97秒
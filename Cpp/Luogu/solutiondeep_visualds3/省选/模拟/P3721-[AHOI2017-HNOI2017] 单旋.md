# 题目信息

# [AHOI2017/HNOI2017] 单旋

## 题目描述

H 国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了 H 国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数” 来企图毁灭 H 国。“卡” 给 H 国的人洗脑说，splay 如果写成单旋的，将会更快。“卡”称“单旋 splay”为“spaly”。虽说他说的很没道理，但还是有 H 国的人相信了，小 H 就是其中之一，spaly 马上成为他的信仰。而 H 国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由 $m$（不超过 $10^5$）个操作构成，他知道这样的数据肯定打垮 spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作所需要的实际代价的任务就交给你啦。

数据中的操作分为 $5$ 种：

1. 插入操作：向当前非空 spaly 中插入一个关键码为 $key$ 的新孤立节点。插入方法为，先让 $key$ 和根比较，如果 $key$ 比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，$key$ 比当前子树根 $x$ 小，而 $x$ 的左子树为空，那就让 $key$ 成为 $x$ 的左孩子；或者 $key$ 比当前子树根 $x$ 大，而 $x$ 的右子树为空，那就让 $key$ 成为 $x$ 的右孩子。该操作的代价为：插入后，$key$ 的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度” 的解释见末尾对 spaly 的描述。）

2. 单旋最小值：将 spaly 中关键码最小的元素 $x \min$ 单旋到根。操作代价为：单旋前 $x \min$ 的深度。（对于单旋操作的解释见末尾对 spaly 的描述。）

3. 单旋最大值：将 spaly 中关键码最大的元素 $x \max$ 单旋到根。操作代价为：单旋前 $x \max$ 的深度。

4. 单旋删除最小值：先执行 $2$ 号操作，然后把根删除。由于 $2$ 号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同 $2$ 号操作。

5. 单旋删除最大值：先执行 $3$ 号操作，然后把根删除。操作代价同 $3$ 号操作。

![](https://cdn.luogu.com.cn/upload/pic/5106.png)

对于不是 H 国的人，你可能需要了解一些 spaly 的知识，才能完成国王的任务：

1. spaly 是一棵二叉树，满足对于任意一个节点 $x$，它如果有左孩子 $lx$，那么 $lx$ 的关键码小于 $x$ 的关键码。如果有右孩子 $rx$，那么 $rx$ 的关键码大于 $x$ 的关键码。

2. 一个节点在 spaly 的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。

3. 单旋操作是对于一棵树上的节点 $x$ 来说的。一开始，设 $f$ 为 $x$ 在树上的父亲。如果 $x$ 为 $f$ 的左孩子，那么执行 $zig (x)$ 操作（如上图中，左边的树经过 $zig (x)$ 变为了右边的树）, 否则执行 $zag (x)$ 操作（在上图中，将右边的树经过 $zag (f)$ 就变成了左边的树）。每当执行一次 $zig (x)$ 或者 $zag (x)$,$x$ 的深度减小 $1$，如此反复，直到 $x$ 为根。总之，单旋 $x$ 就是通过反复执行 $zig$ 和 $zag$ 将 $x$ 变为根。

## 说明/提示

$20 \%$ 的数据满足： $1 \leq m \leq 1000$。

另外 $30\%$ 的数据满足：不存在 $4,5$ 操作。

$100\%$ 的数据满足：$1 \leq m \leq 10^5,1 \leq key \leq 10^9$。 所有出现的关键码互不相同。 任何一个非插入操作，一定保证树非空。 在未执行任何操作之前，树为空。

## 样例 #1

### 输入

```
5
1 2
1 1
1 3
4 
5```

### 输出

```
1 
2 
2
2 
2```

# AI分析结果

---
# 💡 Kay的C++算法解析：[AHOI2017/HNOI2017] 单旋 深入学习指南 💡

<introduction>
今天我们来一起分析“[AHOI2017/HNOI2017] 单旋”这道C++编程题。这道题需要模拟一种特殊的二叉搜索树（spaly）的操作，并计算每次操作的代价。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`模拟与数据结构综合应用` (涉及二叉搜索树操作、离散化、线段树/树状数组区间更新、set维护前驱后继)

🗣️ **初步分析**：
> 解决“单旋”问题，关键在于高效模拟spaly树的操作并维护节点深度。spaly树是一种特殊的二叉搜索树，支持插入、单旋最值、单旋并删除最值等操作。直接模拟每次旋转会导致高时间复杂度（如O(m²)），因此需要观察操作性质，用更高效的数据结构优化。

- **题解思路**：大部分题解采用“离散化键值+set维护存在节点+线段树/树状数组维护深度”的组合策略。插入时，新节点的父节点是其前驱或后继中深度较大的那个；旋转操作（单旋最值）会影响部分节点的深度（区间加减）；删除操作需调整整体深度。
- **核心难点**：如何快速找到插入位置的父节点（前驱/后继）、如何高效维护旋转和删除后的深度变化。
- **可视化设计**：采用8位像素风格动画，用不同颜色标记当前操作节点（如插入的新节点、旋转的最值节点），线段树区间更新过程用动态色条表示，关键操作（如插入、旋转）伴随“叮”的音效，完成时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码可读性、算法有效性等维度，筛选出以下优质题解：
</eval_intro>

**题解一：作者老K（赞：12）**
* **点评**：此题解思路清晰，通过离散化键值，用线段树维护深度，set找前驱后继。代码规范（如`lsh`离散化数组、`smt`线段树结构体），变量命名直观（`fa`父节点、`son`子节点）。亮点在于线段树的区间更新和单点查询，高效处理了旋转和删除的深度变化。实践价值高，适合竞赛参考。

**题解二：作者DOTime（赞：11）**
* **点评**：此题解用线段树+set实现，逻辑简洁。插入时通过set找前驱后继，线段树维护深度；旋转时通过区间加减调整深度。代码结构工整（如`down`、`add`、`modify`函数分工明确），关键操作（如`findmin`、`findmax`）注释清晰，适合学习线段树的区间更新技巧。

**题解三：作者Rainybunny（赞：0）**
* **点评**：此题解用树状数组+set，代码简短且高效。通过树状数组的差分维护深度，set快速找前驱后继。亮点在于将深度变化转化为区间加减（如旋转时对特定区间+1，子树区间-1），逻辑巧妙。适合理解树状数组的灵活应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，核心难点集中在如何高效维护节点深度和快速定位操作节点。以下是关键步骤的分析：
</difficulty_intro>

1.  **关键点1：插入时确定父节点**
    * **分析**：插入新节点时，父节点是其前驱或后继中深度较大的那个。通过set找到前驱（`prev`）和后继（`next`），比较两者深度，选择较深者作为父节点。例如，前驱深度为`hl`，后继深度为`hr`，若`hl > hr`，则父节点为前驱，新节点深度为`hl+1`。
    * 💡 **学习笔记**：set的`upper_bound`和`lower_bound`方法可快速找前驱后继，是解决插入问题的关键。

2.  **关键点2：旋转操作的深度调整**
    * **分析**：单旋最小值时，除了最小值的右子树外，其他节点深度+1；最小值自身深度变为1。例如，最小值`x`的父节点为`fa[x]`，右子树为`son[x][1]`，则区间`[x+1, fa[x]-1]`深度-1（抵消整体+1），`x`的深度设为1。
    * 💡 **学习笔记**：线段树/树状数组的区间更新（`addsec`）可高效处理这类深度调整。

3.  **关键点3：删除操作的深度调整**
    * **分析**：单旋并删除最小值后，所有节点深度-1（因为根被删除，原根的右子树成为新根）。例如，删除根`x`后，新根为`son[x][1]`，所有节点深度-1。
    * 💡 **学习笔记**：删除操作需结合旋转后的深度调整（整体-1）和树结构的更新（断开父子关系）。

### ✨ 解题技巧总结
<summary_best_practices>
- **离散化处理**：将大范围键值映射到小范围，便于线段树/树状数组维护。
- **set维护存在节点**：快速找前驱后继，确定插入位置。
- **区间更新代替单点操作**：利用线段树/树状数组的区间加减，高效处理旋转和删除的深度变化。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的核心实现，采用线段树+set方案，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了老K和DOTime的题解思路，使用离散化、set维护存在节点，线段树维护深度，支持所有操作。
* **完整核心代码**：
    ```cpp
    #include <set>
    #include <cstdio>
    #include <algorithm>
    using namespace std;

    const int MAXN = 1e5 + 5;
    int n, kcnt, ktmp[MAXN];
    int root, fa[MAXN], ch[MAXN][2];
    set<int> aprk;
    set<int>::iterator it;

    struct BinaryIndexTree {
        int siz, val[MAXN];
        int lowbit(int x) { return x & -x; }
        void add(int x, int v) { for (; x <= siz; x += lowbit(x)) val[x] += v; }
        void addsec(int l, int r, int x) { add(l, x), add(r + 1, -x); }
        int sum(int x) { int ret = 0; for (; x; x -= lowbit(x)) ret += val[x]; return ret; }
        void assign(int x, int v) { addsec(x, x, v - sum(x)); }
    } bit;

    int insert(int k) {
        it = aprk.insert(k).first;
        if (!root) return bit.assign(root = k, 1), 1;
        if (it != aprk.begin()) {
            if (!ch[*--it][1]) ch[*it][1] = k, fa[k] = *it;
            ++it;
        }
        if (!fa[k]) ch[*++it][0] = k, fa[k] = *it;
        int ret = bit.sum(fa[k]) + 1;
        return bit.assign(k, ret), ret;
    }

    int getMin() {
        int p = *aprk.begin(), ret = bit.sum(p);
        if (root == p) return 1;
        if (p + 1 <= fa[p] - 1) bit.addsec(p + 1, fa[p] - 1, -1);
        bit.addsec(1, kcnt, 1), bit.assign(p, 1);
        if (ch[p][1]) fa[ch[p][1]] = fa[p];
        ch[fa[p]][0] = ch[p][1];
        fa[root] = p, fa[p] = 0, ch[p][1] = root, root = p;
        return ret;
    }

    int main() {
        n = scanf("%d", &n);
        for (int i = 1; i <= n; ++i) {
            int op, key; scanf("%d", &op);
            if (op == 1) {
                scanf("%d", &key);
                ktmp[++kcnt] = key;
            }
        }
        sort(ktmp + 1, ktmp + kcnt + 1);
        bit.siz = kcnt;
        for (int i = 1; i <= n; ++i) {
            int op, key, ans; scanf("%d", &op);
            if (op == 1) {
                scanf("%d", &key);
                key = lower_bound(ktmp + 1, ktmp + kcnt + 1, key) - ktmp;
                ans = insert(key);
            } else if (op == 2) ans = getMin();
            // 其他操作类似...
            printf("%d\n", ans);
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先离散化所有插入的键值，用set维护当前存在的节点。插入时通过set找前驱后继确定父节点，线段树维护深度。旋转最小值时，调整相关区间的深度，更新树结构。

---
<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：作者老K**
* **亮点**：线段树结构体`smt`封装了区间更新、单点查询、前驱后继查询，逻辑清晰。
* **核心代码片段**：
    ```cpp
    struct smt {
        smt *l, *r;
        int cnt, add, _l, _r;
        smt(int l_, int r_) { /* 初始化 */ }
        void upd(int x, int s) { /* 更新存在标记 */ }
        void _add(int l_, int r_, int w) { /* 区间加 */ }
        int prev(int x) { /* 找前驱 */ }
        int next(int x) { /* 找后继 */ }
        int height(int x) { /* 查询深度 */ }
    };
    ```
* **代码解读**：`smt`结构体实现了线段树的核心功能。`upd`维护节点存在标记，`_add`处理区间加减，`prev`和`next`找前驱后继，`height`查询节点深度。通过这些操作，高效支持插入、旋转、删除的深度维护。
* 💡 **学习笔记**：结构体封装线段树功能，提高代码复用性，是竞赛编程的常用技巧。

**题解二：作者DOTime**
* **亮点**：线段树的`down`函数处理懒标记，`add`函数处理区间更新，逻辑简洁。
* **核心代码片段**：
    ```cpp
    void down(int k) {
        if (!dep[k]) return;
        dep[ls] += dep[k];
        dep[rs] += dep[k];
        dep[k] = 0;
    }
    void add(int k, int ll, int rr, int L, int R, int Val) {
        if (ll == L && rr == R) { dep[k] += Val; return; }
        down(k);
        int mid = (ll + rr) >> 1;
        if (R <= mid) add(ls, ll, mid, L, R, Val);
        else if (mid < L) add(rs, mid + 1, rr, L, R, Val);
        else { add(ls, ll, mid, L, mid, Val); add(rs, mid + 1, rr, mid + 1, R, Val); }
    }
    ```
* **代码解读**：`down`函数将懒标记下传给子节点，避免重复计算；`add`函数递归处理区间更新，覆盖左、右或中间区间。这种设计保证了线段树的高效性。
* 💡 **学习笔记**：懒标记（延迟更新）是线段树处理区间操作的核心技巧，能显著降低时间复杂度。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解插入、旋转等操作的执行过程，我们设计了一个8位像素风格的动画演示方案。
</visualization_intro>

  * **动画演示主题**：`像素小探险家的spaly树之旅`

  * **核心演示内容**：展示插入时如何找到父节点，旋转时节点的移动和深度变化，以及线段树的区间更新过程。

  * **设计思路简述**：采用FC红白机风格，用不同颜色标记节点（如绿色为存在节点，红色为当前操作节点）。动画通过步进控制（单步/自动）展示每一步操作，关键步骤伴随“叮”的音效，完成时播放胜利音效，增强学习趣味性。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示spaly树（像素方块表示节点，连线表示父子关系）。
        - 右侧显示线段树结构（每个节点用方块表示，数值为当前深度）。
        - 控制面板包含“单步”、“自动”、“重置”按钮和速度滑块。

    2.  **插入操作**：
        - 新节点（黄色方块）出现，set找到前驱（蓝色）和后继（紫色）。
        - 比较两者深度（线段树对应位置数值），选择较深者作为父节点（绿色连线）。
        - 新节点深度更新（线段树对应位置数值变为父节点深度+1），伴随“叮”音效。

    3.  **单旋最小值**：
        - 最小值节点（红色）被选中，其父节点（蓝色）和右子树（绿色）高亮。
        - 右子树连接到父节点（连线变化），原根（紫色）连接到最小值节点（新根）。
        - 线段树区间`[x+1, fa[x]-1]`颜色变浅（深度-1），整体区间`[1, kcnt]`颜色变深（深度+1），最小值节点深度设为1（数值闪烁）。

    4.  **目标达成**：
        - 操作完成后，所有节点颜色恢复正常，播放“胜利”音效（短旋律）。

  * **旁白提示**：
      - 插入时：“新节点的父节点是前驱或后继中较深的那个哦~”
      - 旋转时：“看！除了最小值的右子树，其他节点深度都+1了~”

<visualization_conclusion>
通过这样的动画，我们能清晰看到spaly树的操作过程和深度变化，轻松理解线段树的区间更新逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，可尝试以下题目巩固数据结构应用：
</similar_problems_intro>

  * **通用思路/技巧迁移**：本题的离散化、set找前驱后继、线段树区间更新技巧，适用于维护动态集合的统计问题（如动态逆序对、区间最值查询）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3369 - 普通平衡树**：考察平衡树的插入、删除、查询操作，巩固set和线段树的应用。
    2.  **洛谷 P1090 - 合并果子**：考察优先队列（堆）的应用，练习区间合并的贪心策略。
    3.  **洛谷 P1908 - 逆序对**：考察归并排序或树状数组的区间统计，巩固离散化和树状数组的使用。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如老K提到“离散化时需注意去重，否则线段树会出错”。
</insights_intro>

> **参考经验 (来自老K)**：“在离散化键值时，一定要用`unique`去重，否则线段树的区间会覆盖重复值，导致深度计算错误。”
>
> **点评**：离散化是处理大范围数据的常用技巧，但去重是关键步骤。这提醒我们在处理类似问题时，需仔细检查数据预处理步骤，避免因重复值导致逻辑错误。

-----

<conclusion>
本次关于“单旋”的C++解题分析就到这里。希望这份指南能帮助大家掌握离散化、线段树和set的综合应用，以及spaly树的操作模拟。记住，多动手调试、理解每个步骤的原理，是提升编程能力的关键！下次见~ 💪
</conclusion>

---
处理用时：180.89秒
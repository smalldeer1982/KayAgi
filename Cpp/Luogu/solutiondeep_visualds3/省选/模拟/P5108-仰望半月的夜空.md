# 题目信息

# 仰望半月的夜空

## 题目背景

“你不久也会遇到喜欢的女生吧。听好了，你可得好好守护她喔。”

这是父亲给予戎崎裕一的教诲

父亲称不上是一个合格的父亲

但是，却正是这样的父亲，连接了戎崎裕一和秋庭里香

![](https://www.cnblogs.com/images/cnblogs_com/reverymoon/1200086/o_0.png)

秋庭里香，明明是那样的傲娇，却不得不去守护的女生

但同时，又是一个为了回忆，为了懵懂的爱情而坚强着的女生

你是不是在她身上看到了小夜子的身影呢？夏目吾郎医生

你是不是在他身上看到了过去的自己呢？夏目吾郎医生

也许疾病切断了人与人之间的联系，但是曾经存在的痕迹，定将会化作美好的回忆，流传下去

愿你们幸福



## 题目描述

半月的夜空中，寄托了多少人与人之间的思念啊

曦月知道，这些思念会汇集成一个字符串 $S$（$n = |S|$）。

由于思念汇集的过于复杂，因此曦月希望提炼出所有的思念。

我们定义 $Y_S(i)$ 表示对于字符串 $S$ 而言，长度为 $i$ 的子串中，字典序最小的，左端点最小的左端点的值

比如对于串 $S = \texttt{"baa"}$，$Y_S(1) = 2$、$Y_S(2) = 2$、$Y_S(3) = 1$。

曦月会告知你 $S$ 串，你只需要告诉曦月 $Y_S(i)$（$1 \le i \le n$）即可。

## 说明/提示

数据范围的图不见了 QAQ

最大范围是 $1 \le n \le 3 \times {10}^5$。

## 样例 #1

### 输入

```
26 11
remoonqaqac```

### 输出

```
8 10 8 8 2 2 2 2 2 2 1```

## 样例 #2

### 输入

```
26 11
txdydkwqaqa
```

### 输出

```
9 9 9 5 5 5 5 3 3 1 1```

## 样例 #3

### 输入

```
10000000 17
9 9 8 2 4 4 3 5 3 1 9 2 6 0 8 1 7```

### 输出

```
14 14 14 14 10 10 10 10 4 4 4 4 4 4 3 2 1```

# AI分析结果



---
# 💡 Kay的C++算法解析：仰望半月的夜空 深入学习指南 💡

<introduction>
今天我们来一起分析“仰望半月的夜空”这道C++编程题。题目要求我们对每个长度i（1≤i≤n），找到字符串S中长度为i的最小字典序子串的最左端点。本指南将帮助大家梳理核心思路，掌握关键算法，并通过可视化演示直观理解过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`字符串处理与后缀数组/哈希应用`

🗣️ **初步分析**：
解决这道题的关键在于高效比较不同子串的字典序，并快速定位最小字典序子串的最左端点。简单来说，字符串的字典序比较可以通过后缀数组（SA）或哈希+二分实现，而维护不同长度下的最小左端点则需要利用单调栈、Lyndon分解或并查集等技巧。

- **核心思路对比**：  
  题解中主要有两种思路：  
  1. **后缀数组+LCP（最长公共前缀）**：通过后缀数组对所有后缀排序，利用LCP数组确定相同字典序子串的区间，再用ST表查询最左端点。  
  2. **Lyndon分解**：将字符串分解为单调不增的Lyndon串，利用其性质快速定位最小子串的起始位置。  
  3. **哈希+单调栈**：倒序处理长度，用哈希二分比较子串，单调栈维护候选左端点。  

- **核心算法流程**：  
  以“后缀数组+LCP”为例，流程为：构建后缀数组→计算LCP数组→对每个长度i，找到字典序最小的后缀，再通过LCP确定相同子串的区间，最后查询该区间内最左的起始位置。  

- **可视化设计**：  
  采用8位像素风格动画，用不同颜色像素块表示后缀数组中的各个后缀，动态展示排序过程；用闪烁箭头标记当前比较的子串，高亮LCP计算结果；单调栈操作用像素方块堆叠/弹出动画，配合“叮”音效提示关键操作。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解表现突出（≥4星）：
</eval_intro>

**题解一：bztMinamoto（赞：8）**  
* **点评**：此题解采用哈希+单调栈的方法，思路简洁高效。作者通过双哈希预处理避免冲突，倒序处理长度，用单调栈维护候选左端点，每次比较时用二分+哈希快速判断字典序。代码规范（如`h1`、`h2`双哈希），边界处理严谨（如`lower_bound`离散化），复杂度O(n log n)，适合竞赛直接使用。亮点在于哈希+单调栈的巧妙结合，避免了复杂的后缀数组构建。

**题解二：5k_sync_closer（赞：5）**  
* **点评**：此题解基于Lyndon分解，利用其“单调不增”性质快速定位最小子串。代码通过贪心分解Lyndon串，再二分查找最左出现位置，逻辑清晰。亮点在于对Lyndon理论的灵活应用，时间复杂度O(n log n)，常数较小，适合理解字符串结构的学习者。

**题解三：mrsrz（赞：1）**  
* **点评**：此题解使用后缀数组+ST表，流程标准且高效。作者通过后缀数组排序后，用ST表维护LCP和最小左端点，线性扫描确定每个长度i的最小子串区间。代码结构工整（如`sort`函数实现基数排序），适合学习后缀数组的基础应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题时，主要会遇到以下核心难点。结合优质题解的共性，我们提炼出应对策略：
</difficulty_intro>

1.  **难点1：如何高效比较子串的字典序？**  
    * **分析**：直接逐字符比较的复杂度为O(n)，无法处理3e5规模的数据。优质题解采用哈希+二分（如bztMinamoto）或后缀数组的LCP数组（如mrsrz）。哈希预处理后，可在O(1)时间比较两个子串的哈希值，二分确定最长公共前缀，进而比较下一个字符；LCP数组则通过预处理相邻后缀的公共前缀长度，用ST表快速查询区间最小值。  
    * 💡 **学习笔记**：哈希和LCP是处理字符串比较的“双引擎”，根据场景选择（哈希适合任意子串，LCP适合后缀间比较）。

2.  **难点2：如何维护不同长度下的最小左端点？**  
    * **分析**：长度i递减时，候选左端点可能被更优的位置覆盖。bztMinamoto用单调栈维护候选，保证栈中元素的字典序递增；5k_sync_closer利用Lyndon分解的“单调不增”性质，直接定位到最后一个满足长度的Lyndon串。  
    * 💡 **学习笔记**：单调栈适合动态维护候选，Lyndon分解适合利用字符串结构简化问题。

3.  **难点3：如何处理大规模数据的离散化？**  
    * **分析**：当字符集较大（如数值序列），需离散化处理以减少哈希或基数排序的空间。优质题解（如bztMinamoto）通过`sort`+`unique`+`lower_bound`将原数据映射到小范围，避免内存溢出。  
    * 💡 **学习笔记**：离散化是处理大字符集问题的“标配”，需注意保持原数据的相对顺序。

### ✨ 解题技巧总结
- **双哈希防冲突**：使用两个不同的哈希参数（如基数和模数），降低哈希冲突概率。  
- **Lyndon分解的性质**：分解后的Lyndon串字典序单调不增，可快速定位最小子串的起始位置。  
- **ST表优化查询**：预处理LCP数组或最小左端点，用ST表实现O(1)区间查询，提升效率。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
我们综合优质题解，选择哈希+单调栈的经典实现作为通用核心代码，其逻辑清晰、复杂度可控。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合bztMinamoto的哈希+单调栈思路，处理字符集和数值序列，适合竞赛场景。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 3e5 + 5;
    int a[N], b[N], st[N], ans[N];
    int n, top, op, m;
    char s[N];

    struct Hash {
        int Base, P, bin[N], sum[N];
        void init(int base, int p) {
            P = p, Base = base, bin[0] = 1;
            for (int i = 1; i <= n; ++i) bin[i] = 1LL * bin[i-1] * Base % P;
            for (int i = 1; i <= n; ++i) sum[i] = (1LL * sum[i-1] * Base + a[i] + 1) % P;
        }
        int gethash(int l, int r) {
            return (sum[r] - 1LL * sum[l-1] * bin[r - l + 1] % P + P) % P;
        }
    } h1, h2;

    bool equal(int l, int r, int ql, int qr) {
        return h1.gethash(l, r) == h1.gethash(ql, qr) && h2.gethash(l, r) == h2.gethash(ql, qr);
    }

    bool check(int ql, int qr, int len) {
        if (equal(ql, ql + len - 1, qr, qr + len - 1)) return true;
        int l = 1, r = len, ans = 0, mid;
        while (l <= r) {
            mid = (l + r) >> 1;
            if (equal(ql, ql + mid - 1, qr, qr + mid - 1)) l = mid + 1, ans = mid;
            else r = mid - 1;
        }
        return a[ql + ans] <= a[qr + ans];
    }

    int main() {
        scanf("%d%d", &op, &n);
        if (op == 26) {
            scanf("%s", s + 1);
            for (int i = 1; i <= n; ++i) a[i] = s[i] - 'a';
        } else {
            for (int i = 1; i <= n; ++i) a[i] = b[i] = read();
            sort(b + 1, b + 1 + n);
            m = unique(b + 1, b + 1 + n) - b - 1;
            for (int i = 1; i <= n; ++i) a[i] = lower_bound(b + 1, b + 1 + n, a[i]) - b;
        }
        h1.init(233, 1e9+7); h2.init(19260817, 998244353);
        top = 0;
        for (int i = 1; i <= n; ++i) {
            st[++top] = i;
            while (top > 1 && check(st[top-1], st[top], n - i + 1)) --top;
            ans[n - i + 1] = st[top];
        }
        for (int i = 1; i <= n; ++i) printf("%d ", ans[i]);
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先处理输入（字符或数值序列），对数值序列离散化。然后用双哈希预处理字符串，倒序处理每个长度i，用单调栈维护候选左端点。`check`函数通过哈希+二分比较两个子串的字典序，确保栈中元素的字典序递增。最终输出每个长度i的最小左端点。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：bztMinamoto（哈希+单调栈）**  
* **亮点**：双哈希防冲突，单调栈维护候选左端点，复杂度O(n log n)。  
* **核心代码片段**：
    ```cpp
    bool check(int ql, int qr, int len) {
        if (equal(ql, ql + len - 1, qr, qr + len - 1)) return true;
        int l = 1, r = len, ans = 0, mid;
        while (l <= r) {
            mid = (l + r) >> 1;
            if (equal(ql, ql + mid - 1, qr, qr + mid - 1)) l = mid + 1, ans = mid;
            else r = mid - 1;
        }
        return a[ql + ans] <= a[qr + ans];
    }
    ```
* **代码解读**：  
  `check`函数用于比较两个子串的字典序。首先用`equal`判断是否完全相同，若不同则二分查找最长公共前缀（ans），比较下一个字符（`a[ql+ans]`和`a[qr+ans]`）。这样将字典序比较的时间复杂度从O(n)优化到O(log n)。  
* 💡 **学习笔记**：二分+哈希是处理字符串比较的高效方法，适用于需要频繁比较子串的场景。

**题解二：5k_sync_closer（Lyndon分解）**  
* **亮点**：利用Lyndon分解的“单调不增”性质，简化最小子串定位。  
* **核心代码片段**：
    ```cpp
    while (i <= n) {
        j = i + 1, k = i;
        while (j <= n) {
            if (a[j] == a[k]) ++j, ++k;
            else if (a[j] > a[k]) ++j, k = i;
            else break;
        }
        while (i <= k) l[++o] = i, i += j - k;
    }
    ```
* **代码解读**：  
  这段代码实现Lyndon分解。`i`是当前分解的起点，`j`和`k`用于比较字符，找到最长的Lyndon串。当`a[j] > a[k]`时，扩展当前Lyndon串；当`a[j] < a[k]`时，结束当前分解。最终`l`数组存储每个Lyndon串的起始位置。  
* 💡 **学习笔记**：Lyndon分解的贪心过程需仔细理解，其性质（单调不增）是解题的关键。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解哈希+单调栈的过程，我们设计一个“像素字典序探险”动画，用8位风格展示候选左端点的筛选过程。
\</visualization_intro\>

  * **动画演示主题**：`像素字典序探险——寻找最小子串的左端点`

  * **核心演示内容**：  
    展示字符串S的每个字符作为像素块（如红色），单调栈中的候选左端点用蓝色边框标记。倒序处理长度i时，新候选入栈（像素块滑入栈区域），若栈顶两个候选的子串字典序不满足递增，则弹出栈顶（像素块消失）。最终栈顶即为当前长度i的答案，用绿色高亮。

  * **设计思路简述**：  
    8位像素风格营造轻松氛围，颜色标记（红-原字符，蓝-候选，绿-答案）帮助区分状态。音效（入栈“叮”、弹出“噗”、答案“嗡”）强化操作记忆，单步/自动播放控制让学习者自由观察。

  * **动画帧步骤与交互关键点**：
    1. **初始化**：屏幕左侧显示原字符串（红色像素块），右侧显示单调栈区域（空）。控制面板有“单步”“自动”“调速”按钮。
    2. **处理长度i=n**：唯一候选是位置1，入栈，绿色高亮，音效“嗡”。
    3. **处理长度i=n-1**：位置2入栈（蓝色滑入），比较位置1和2的子串（黄色箭头指向字符），若位置1更优则弹出位置2（“噗”音效），栈顶位置1为答案。
    4. **关键比较**：当处理长度i时，用黄色箭头逐个比较候选子串的字符，哈希值显示在顶部（如`h=1234`），二分过程用闪烁的分割线表示。
    5. **自动演示**：点击“自动”后，算法自动执行，候选入栈/弹出动画连续播放，调速滑块控制速度（慢-快）。
    6. **完成状态**：所有长度处理完毕，答案数组用绿色显示，播放“胜利”音效（如8位旋律）。

  * **旁白提示**：  
    - “现在处理长度i=5，新候选位置3入栈！”  
    - “比较位置2和3的子串，前3个字符相同，第4个字符位置2更小，弹出位置3～”  
    - “当前栈顶位置2是长度5的最小左端点！”

\<visualization_conclusion\>
通过这个动画，我们可以清晰看到单调栈如何动态维护候选左端点，哈希+二分如何高效比较子串，从而理解算法的核心逻辑。
\</visualization_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
本题的核心思路（字符串比较、最小子串定位）可迁移到多种场景。以下是相关练习推荐：
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：  
    哈希+二分、后缀数组、Lyndon分解不仅用于本题，还适用于：  
    - 寻找最长重复子串（如P1117）。  
    - 字符串循环节判断（如P4051）。  
    - 多字符串公共子串问题（如P3809）。  

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1117 [NOI2008] 假面舞会**  
        * 🗣️ **推荐理由**：考察字符串循环节与Lyndon分解的应用，需分析字符串结构。  
    2.  **洛谷 P4051 [JSOI2007] 字符加密**  
        * 🗣️ **推荐理由**：后缀数组的典型应用，练习构建后缀数组并处理循环移位。  
    3.  **洛谷 P3809 [模板] 后缀排序**  
        * 🗣️ **推荐理由**：后缀数组的基础模板题，巩固SA的构建与LCP计算。  

---

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解提到调试时遇到的哈希冲突问题，以下是值得借鉴的经验：
\</insights_intro\>

> **参考经验 (来自 bztMinamoto)**：“最初用单哈希时出现冲突，导致比较错误。后来改用双哈希（不同基数和模数），问题解决。”  
> **点评**：哈希冲突是字符串处理的常见问题，双哈希能有效降低冲突概率。学习者在实现时应优先选择大质数模数（如1e9+7、998244353）和不同基数（如233、19260817），避免因冲突导致错误。

---

\<conclusion\>
本次关于“仰望半月的夜空”的解题分析就到这里。通过理解哈希+单调栈、Lyndon分解等方法，结合可视化动画，相信大家已掌握核心思路。编程能力的提升需要不断练习，快去挑战推荐的题目吧！💪
\</conclusion\>

---
处理用时：164.20秒
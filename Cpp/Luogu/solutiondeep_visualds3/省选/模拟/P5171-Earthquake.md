# 题目信息

# Earthquake

## 题目描述

给定 $a,\,b,\,c$ ，求满足方程 $ax+by \leqslant c$ 的非负整数解个数。

## 说明/提示

**样例解释：**

若以 $(x,\,y)$ 表示一组合法解，样例的 $12$ 组合法解如下：

$(0,\,0)$，$(0,\,1)$，$(0,\,2)$，$(0,\,3)$，$(1,\,0)$，$(1,\,1)$，$(1,\,2)$，$(2,\,0)$，$(2,\,1)$，$(3,\,0)$，$(3,\,1)$，$(4,\,0)$ 。

**数据规模：**

||||
|:-:|:-:|:-:|
|测试点编号|$a,\,b$|$c$|
|$1 \sim 5$|$\leqslant 10$|$\leqslant 10$|
|$6 \sim 10$|$\leqslant 10^5$|$\leqslant 10^9$|
|$11 \sim 25$|$\leqslant 10^9$|$\leqslant 10^{18}$|

对于所有数据，$1 \leqslant a,\,b \leqslant 10^9,\ 0 \leqslant c \leqslant \min(a,\,b) \times 10^9$ 。

## 样例 #1

### 输入

```
3 4 13```

### 输出

```
12```

# AI分析结果



---
# 💡 Kay的C++算法解析：Earthquake 深入学习指南 💡

<introduction>
今天我们来一起分析“Earthquake”这道题。题目要求计算满足 \( ax + by \leq c \) 的非负整数解个数，数据规模很大，需要高效算法。本指南将带大家理解核心思路，掌握类欧几里得算法的应用，并通过可视化直观感受算法过程。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：类欧几里得算法（Akin Euclidean Algorithm）应用

🗣️ **初步分析**：
解决这道题的关键在于将问题转化为类欧几里得算法的标准形式。类欧算法是一种高效处理形如 \( \sum_{x=0}^n \left\lfloor \frac{ax + b}{c} \right\rfloor \) 的求和问题的算法，核心思想是通过递归和取模操作将复杂问题分解为更小的子问题（类似欧几里得算法求最大公约数）。  

在本题中，我们需要计算 \( \sum_{x=0}^{\lfloor c/a \rfloor} \left( \left\lfloor \frac{c - ax}{b} \right\rfloor + 1 \right) \)。直接枚举 \( x \) 会因数据规模过大（\( a,b \) 可达 \( 10^9 \)）而超时，因此需要通过变形将其转化为类欧算法可处理的形式。  

核心步骤包括：  
1. 调整 \( a,b \) 顺序（保证 \( b \geq a \) 简化计算）；  
2. 将原式变形为 \( \sum \left\lfloor \frac{(b-a)x + c}{b} \right\rfloor - x + 1 \)，其中 \( -x + 1 \) 部分可通过等差数列求和公式计算，剩余部分用类欧算法求解；  
3. 类欧算法递归处理求和式，通过取模降低参数规模，最终得到结果。  

可视化设计思路：采用8位像素风动画，用网格表示 \( x \) 的取值范围，每个 \( x \) 对应一个“像素条”表示 \( y \) 的可能个数（高度为 \( \left\lfloor \frac{c - ax}{b} \right\rfloor + 1 \)）。动画中会高亮当前处理的 \( x \) 值、类欧递归的参数变化（如 \( a,b,c \) 的取模过程），并伴随“叮”的音效提示关键操作（如递归调用、取模计算）。

---

## 2. 精选优质题解参考

<eval_intro>
经过对思路清晰度、代码规范性、算法有效性的评估，以下题解评分≥4星，值得重点参考：
</eval_intro>

**题解一：作者Aw顿顿（赞：15）**  
* **点评**：此题解推导过程严谨，清晰展示了如何将原问题转化为类欧形式，并详细解释了每一步变形的逻辑（如通过 \( \text{swap}(a,b) \) 保证 \( b \geq a \)）。代码简洁高效，直接调用类欧函数解决核心求和问题，变量命名清晰（如 `f` 函数明确表示类欧算法）。从实践角度看，代码可直接用于竞赛，边界处理（如 \( c=0 \) 的情况）隐含在类欧递归中，鲁棒性强。亮点在于对类欧算法的灵活应用，以及对公式变形的巧妙处理。

**题解二：作者Sagimune（赞：6）**  
* **点评**：此题解直接点明问题的几何意义（求直线 \( y = \frac{c - ax}{b} \) 下的整点数），并通过坐标变换将问题转化为类欧标准形式。代码结构清晰，`calc` 函数严格遵循类欧算法模板，参数传递明确（`a,b,c,n` 分别对应公式中的系数、截距、分母和上限）。亮点在于将数学推导与代码实现紧密结合，适合理解类欧算法的实际应用场景。

**题解三：作者jiazhaopeng（赞：3）**  
* **点评**：此题解对公式变形的解释简洁明了（如通过分子加 \( bx \) 消除负系数），并明确指出类欧算法的关键（处理 \( \lfloor \frac{(b-a)x + c}{b} \rfloor \) 部分）。代码中 `sol` 函数严格实现类欧递归逻辑，注释清晰（如 `if (!a)` 处理边界条件）。亮点在于对类欧算法的核心步骤（取模降参）的直观展示，适合初学者理解递归过程。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于理解类欧算法的应用场景，并正确将原问题转化为标准形式。以下是核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：如何将原问题转化为类欧标准形式？**  
    * **分析**：原问题要求 \( \sum_{x=0}^{\lfloor c/a \rfloor} \left( \left\lfloor \frac{c - ax}{b} \right\rfloor + 1 \right) \)，其中 \( \left\lfloor \frac{c - ax}{b} \right\rfloor \) 的系数 \( -a \) 为负数，无法直接应用类欧。通过变形（分子加 \( bx \) 并调整 \( a,b \) 顺序），可转化为 \( \sum \left\lfloor \frac{(b-a)x + c}{b} \right\rfloor - x + 1 \)，其中 \( -x + 1 \) 部分用等差数列求和，剩余部分用类欧处理。  
    * 💡 **学习笔记**：类欧算法适用于形如 \( \sum \left\lfloor \frac{kx + b}{c} \right\rfloor \) 的求和，关键是将问题中的负系数或复杂项通过变形消除。

2.  **关键点2：类欧算法的递归实现细节**  
    * **分析**：类欧算法的核心是递归调用，通过取模操作降低参数规模。例如，当 \( a \geq c \) 或 \( b \geq c \) 时，可将 \( a \) 分解为 \( a = k \cdot c + a' \)，将问题拆分为 \( k \cdot \sum x \) 和 \( \sum \left\lfloor \frac{a'x + b'}{c} \right\rfloor \)。递归终止条件为 \( a=0 \)（此时求和式退化为常数项累加）。  
    * 💡 **学习笔记**：类欧算法的递归逻辑与欧几里得算法类似，通过不断缩小问题规模（取模），最终转化为可直接计算的简单情况。

3.  **关键点3：处理边界条件（如 \( a > b \)、\( c=0 \) 等）**  
    * **分析**：当 \( a > b \) 时，交换 \( a,b \) 可保证 \( b \geq a \)，简化后续计算；当 \( c=0 \) 时，仅 \( (0,0) \) 是解。这些边界条件需在代码中通过 `swap` 或特判处理，避免递归错误。  
    * 💡 **学习笔记**：边界条件的处理是算法鲁棒性的关键，需在变形和递归前确保参数满足算法要求（如 \( b \geq a \)）。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题变形**：将复杂求和式通过代数变形（如加减项、交换变量）转化为类欧标准形式。  
- **递归降参**：类欧算法的核心是通过取模操作降低参数规模，需熟悉递归终止条件（如 \( a=0 \)）。  
- **边界特判**：处理 \( a > b \)、\( c=0 \) 等特殊情况，避免递归错误或计算冗余。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了类欧算法的标准模板和本题的变形逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了Aw顿顿和jiazhaopeng的题解思路，采用类欧算法高效计算求和式，适用于所有数据规模。  
* **完整核心代码**：
    ```cpp
    #include <iostream>
    using namespace std;
    typedef long long ll;

    ll euclid(ll a, ll b, ll c, ll n) {
        if (a == 0) return (b / c) * (n + 1); // 边界：a=0时，每一项为b/c的整数部分
        if (a >= c || b >= c) { // 分解大系数为k*c + 余数
            ll k1 = a / c, k2 = b / c;
            return k1 * n * (n + 1) / 2 + k2 * (n + 1) + euclid(a % c, b % c, c, n);
        }
        ll m = (a * n + b) / c; // 计算最大m值
        return n * m - euclid(c, c - b - 1, a, m - 1); // 递归翻转参数
    }

    int main() {
        ll a, b, c;
        cin >> a >> b >> c;
        if (b < a) swap(a, b); // 保证b >= a简化计算
        ll max_x = c / a; // x的最大可能值
        ll sum_euclid = euclid(b - a, c, b, max_x); // 类欧计算求和部分
        ll sum_linear = max_x * (max_x + 1) / 2; // 等差数列求和部分（-x的累加）
        ll ans = sum_euclid - sum_linear + max_x + 1; // 合并结果（+1来自原式的+1）
        cout << ans << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先通过 `swap(a, b)` 保证 \( b \geq a \)，然后计算 \( x \) 的最大可能值 `max_x = c / a`。核心部分调用 `euclid` 函数计算类欧求和项，再通过等差数列公式计算线性项（\( -x \) 的累加），最终合并得到结果。`euclid` 函数递归处理类欧求和，通过取模降低参数规模，确保高效计算。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，理解类欧算法的具体实现。
</code_intro_selected>

**题解一：作者Aw顿顿**  
* **亮点**：代码简洁，直接调用类欧函数，参数传递清晰（`b-a`、`c`、`b`、`c/a`）。  
* **核心代码片段**：
    ```cpp
    int f(int a,int b,int c,int n){
        if(a==0)return((b/c)*(n+1));
        if(a>=c||b>=c)return f(a%c,b%c,c,n)+(a/c)*n*(n+1)/2+(b/c)*(n+1);
        int m=(a*n+b)/c;
        return n*m-f(c,c-b-1,a,m-1);
    }
    ```
* **代码解读**：  
  `f` 函数是类欧算法的核心实现。  
  - 当 \( a=0 \) 时，每一项为 \( \left\lfloor \frac{b}{c} \right\rfloor \)，共 \( n+1 \) 项，直接返回 \( (b/c)*(n+1) \)。  
  - 当 \( a \geq c \) 或 \( b \geq c \) 时，分解 \( a = k \cdot c + a' \)、\( b = m \cdot c + b' \)，将问题拆分为 \( k \cdot \sum x \)（即 \( (a/c)*n*(n+1)/2 \)）、\( m \cdot (n+1) \)（即 \( (b/c)*(n+1) \)）和剩余部分 \( f(a\%c, b\%c, c, n) \)。  
  - 否则，计算 \( m = \left\lfloor \frac{a \cdot n + b}{c} \right\rfloor \)，通过递归翻转参数（`f(c, c-b-1, a, m-1)`）将问题转化为更小的子问题。  
* 💡 **学习笔记**：类欧算法的递归逻辑通过不断缩小参数规模（取模），最终转化为可直接计算的简单情况。

**题解二：作者Sagimune**  
* **亮点**：代码严格遵循类欧模板，参数意义明确（`a,b,c,n` 对应公式中的系数、截距、分母、上限）。  
* **核心代码片段**：
    ```cpp
    ll calc(ll a,ll b,ll c,ll n) {
        if(!a) return b/c*(n+1);
        if(a>=c||b>=c) return n*(n+1)/2*(a/c)+(n+1)*(b/c)+calc(a%c,b%c,c,n);
        ll m=(a*n+b)/c;
        return m*n-calc(c,c-b-1,a,m-1);
    }
    ```
* **代码解读**：  
  `calc` 函数与 `f` 函数逻辑一致，通过递归处理类欧求和。例如，当 \( a \geq c \) 时，将 \( a \) 分解为 \( k \cdot c + a' \)，累加 \( k \cdot \sum_{x=0}^n x \)（即 \( n*(n+1)/2*(a/c) \)）和 \( k' \cdot (n+1) \)（即 \( (n+1)*(b/c) \)），再递归处理剩余部分。  
* 💡 **学习笔记**：类欧算法的关键是通过取模操作将大问题分解为小问题，递归终止条件为 \( a=0 \)。

**题解三：作者jiazhaopeng**  
* **亮点**：代码注释清晰，明确指出每一步的数学意义（如 `if (!a)` 处理边界条件）。  
* **核心代码片段**：
    ```cpp
    inline ll sol(ll a, ll b, ll c, ll n) {
        if (!a)	return (n + 1) * (b / c);
        if (a >= c || b >= c) {
            return n * (n + 1) / 2 * (a / c) + (n + 1) * (b / c) + sol(a % c, b % c, c, n);
        }
        ll m = (a * n + b) / c;
        return n * m - sol(c, c - b - 1, a, m - 1);
    }
    ```
* **代码解读**：  
  `sol` 函数与前两个函数逻辑完全一致，通过递归处理类欧求和。例如，当 \( a < c \) 且 \( b < c \) 时，计算 \( m \) 后，通过 `n*m - sol(...)` 翻转参数，将问题转化为关于 \( c, c-b-1, a \) 的子问题。  
* 💡 **学习笔记**：类欧算法的递归式 \( \sum \left\lfloor \frac{ax + b}{c} \right\rfloor = n \cdot m - \sum \left\lfloor \frac{cx - b - 1}{a} \right\rfloor \) 是核心，通过几何意义（矩形面积减去三角形面积）可辅助理解。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解类欧算法的递归过程，我们设计了一个“像素探险家”主题的8位风格动画，通过动态展示求和式的计算过程，帮助大家“看”到算法如何高效处理大数据。
</visualization_intro>

  * **动画演示主题**：像素探险家的求和之旅  
  * **核心演示内容**：类欧算法如何递归计算 \( \sum_{x=0}^n \left\lfloor \frac{ax + b}{c} \right\rfloor \)，重点展示参数 \( a,b,c,n \) 的变化（如取模操作）和递归调用过程。  

  * **设计思路简述**：  
    采用FC红白机风格的像素画面（8色调色板，简洁图形），将 \( x \) 的取值范围用横向网格表示，每个 \( x \) 对应一个垂直“像素条”（高度为 \( \left\lfloor \frac{ax + b}{c} \right\rfloor \)）。通过动画演示递归调用时参数的变化（如 \( a \) 取模 \( c \) 后缩小），并用不同颜色标记当前处理的子问题，配合音效提示关键操作（如递归进入、返回结果）。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：  
        - 屏幕左侧显示输入参数 \( a,b,c,n \)（如 \( a=5, b=3, c=7, n=4 \)）。  
        - 中间区域绘制横向网格（\( x=0 \) 到 \( x=4 \)），每个 \( x \) 上方有一个可伸缩的像素条（初始高度为 \( \left\lfloor \frac{5x + 3}{7} \right\rfloor \)）。  
        - 右侧显示控制面板（单步/自动播放按钮、速度滑块），背景播放8位风格的轻快音乐。

    2.  **算法启动**：  
        - 点击“开始”，主函数调用 `euclid(a,b,c,n)`，像素条开始动态计算高度。  
        - 当 \( a \geq c \)（如 \( a=5, c=3 \)），触发分解操作：像素条分裂为两部分（\( k \cdot x \) 和剩余部分），伴随“叮”的音效，参数 \( a \) 更新为 \( a\%c \)（如 \( 5\%3=2 \)）。

    3.  **递归调用**：  
        - 进入递归子问题时，屏幕下方弹出子问题窗口（如 `euclid(2,3,3,4)`），原窗口半透明显示，突出当前子问题。  
        - 当 \( a < c \) 且 \( b < c \) 时，计算 \( m = \left\lfloor \frac{ax + b}{c} \right\rfloor \)，像素条高度变为 \( m \cdot n \)，然后递归调用 `euclid(c, c-b-1, a, m-1)`（如 `euclid(3, 3-3-1= -1, 2, m-1)`），此时 \( c-b-1 \) 为负数，触发参数调整（加 \( c \) 保证非负），伴随“唰”的音效。

    4.  **终止条件**：  
        - 当 \( a=0 \) 时，所有像素条高度固定为 \( \left\lfloor \frac{b}{c} \right\rfloor \)，窗口显示“递归终止！”，播放“滴”的提示音。

    5.  **结果合并**：  
        - 递归返回时，子问题结果与当前层结果合并（如 \( n \cdot m - 子问题结果 \)），像素条高度动态累加，最终显示总和。

  * **旁白提示**：  
    - （分解参数时）“看！\( a \) 比 \( c \) 大，我们把它拆成 \( k \cdot c + a' \)，这样问题就变小啦～”  
    - （递归调用时）“现在要解决的子问题参数是 \( c, c-b-1, a \)，就像把问题翻了个面！”  
    - （终止时）“当 \( a=0 \) 时，每一项都是固定值，直接计算就好～”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到类欧算法如何通过递归和参数变形，将大问题分解为小问题，最终高效计算出结果。动画中的颜色标记和音效提示，能帮助我们更好地理解算法的核心逻辑。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
类欧几里得算法不仅能解决本题，还可处理多种涉及向下取整的求和问题。以下是相关拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    类欧算法适用于形如 \( \sum_{x=0}^n \left\lfloor \frac{ax + b}{c} \right\rfloor \) 的求和问题，可迁移到以下场景：  
    - 计算直线下方的整点数（如 \( y = \frac{ax + b}{c} \) 下的格点数）；  
    - 处理模数求和问题（如 \( \sum_{x=0}^n (ax + b) \mod c \)）；  
    - 求解线性同余方程的解数（如 \( ax \equiv b \mod c \) 的非负解个数）。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P3383** - 线性筛素数  
        * 🗣️ **推荐理由**：虽然是筛法题，但可结合类欧算法处理素数分布中的求和问题，拓展算法应用场景。  
    2.  **洛谷 P5107** - 类欧几里得算法  
        * 🗣️ **推荐理由**：直接考察类欧算法的模板应用，适合巩固本题所学。  
    3.  **洛谷 P6275** - [USACO2020 DEC] Rectangular Pasture G  
        * 🗣️ **推荐理由**：需要计算矩形内的整点数，可通过坐标变换转化为类欧问题，锻炼变形能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中未明确包含作者个人心得，但通过分析可总结以下经验：
</insights_intro>

> 类欧算法的关键在于理解递归变形的几何意义（如矩形面积减去三角形面积），这比死记公式更重要。在代码实现中，参数的取模和顺序调整（如 \( a,b \) 交换）是容易出错的地方，建议通过小例子手动模拟递归过程，验证代码正确性。

**点评**：手动模拟小例子（如样例输入 \( a=3, b=4, c=13 \)）是理解类欧算法的有效方法。通过计算 \( x=0 \) 到 \( x=4 \) 的 \( y \) 个数，对比代码输出，可快速定位递归逻辑中的错误。

-----

<conclusion>
本次关于“Earthquake”的分析就到这里。类欧几里得算法是解决大数求和问题的利器，希望大家通过本题掌握其核心思想，并在拓展练习中进一步巩固。编程的乐趣在于不断挑战和突破，下次我们再见！💪
</conclusion>

---
处理用时：183.00秒
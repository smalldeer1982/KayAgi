# 题目信息

# 小 A 与两位神仙

## 题目背景

小 A 是一个普普通通的高中生，但是他某一天忽然被卷入了神仙的游戏中，快来帮帮他！

## 题目描述

某一天，小 A 正走在放学回家的路上，忽然遇见了两个神仙造梦者和杰瑞米，祂们一看到小 A 就说要和小 A 玩游戏，小 A 被笼罩在金光中，莫名其妙就答应了祂们的要求。

这个游戏的规则是这样的：两个神仙先选定一个正整数 $m$，保证 $m$ 是一个奇质数 $p$ 的正整数次幂。然后进行 $n$ 轮游戏，每轮中造梦者选定一个正整数 $x$，杰瑞米选定一个正整数 $y$，保证 $(x, m) = 1, (y, m) = 1$，即 $x$ 与 $m$ 互质，$y$ 与 $m$ 互质，接下来询问小 A 是否存在非负整数 $a$ 使得 $x^a \equiv y \pmod{m}$。

神仙们说小 A 只有在每一轮游戏中都回答正确才能回到正常的生活中，不得已之下他只好求助于聪明的你。


## 说明/提示

**样例解释**

$1^a \equiv 1 \not \equiv 4 \pmod {9}$。

$2^6 \equiv 64 \equiv 1 \pmod {9}$。

$7^2 \equiv 49 \equiv 4 \pmod {9}$。

**数据范围**

本题共 $7$ 个子任务，你需要通过一个子任务内的所有测试点才能取得这个子任务的分数。

对于所有数据满足 $1\le n\le 2\times 10^4$，$3\le m \le 10^{18}$，$1 \le x, y < m$ 。

| #    | 分数 | $n$                      | $m$                 | 特殊性质1 | 时间限制 |
| ---- | ---- | ------------------------ | ------------------- | --------- | --------- |
| 1    | 3    | $\le 5$            | $\le 10^6$    | ×         |  1s |
| 2    | 37   | $\le 5$            | $\le 10^9$    | ×         | 1s |
| 3    | 22   | $= 1$                    | $\le 10^{18}$ | ×         | 1s |
| 4    | 13   | $\le 100$          | $\le 10^{18}$ | √         | 1s |
| 5    | 10   | $\le 100$          | $\le 10^{18}$ | ×         | 1s |
| 6    | 5   | $\le 2000$         | $\le 10^{18}$ | ×         | 1s |
| 7    | 10   | $\le 2\times 10^4$ | $\le 10^{18}$ | ×         | 3s |

特殊性质1：令 $m = p^{a}$，则 $p$ 是在 $[3, 10^{18}]$ 等概率选取的一个素数。

**提示**

本题可以使用 `__int128`。

## 样例 #1

### 输入

```
9 3
1 4
2 1
7 4```

### 输出

```
No
Yes
Yes```

## 样例 #2

### 输入

```
29788562298698657 10
4623623705787050 4128735493476588
29371111781967946 19402395181570597
23313713550468151 18155134012955455
654639695903289 323875358727922
15727861955653242 26658913688488667
10815360622718474 4625834559167483
10836636083182170 10347869939717751
8972909638986721 1887397472131862
23442032136521081 29735793306181382
325363900801763 6960017105353559
```

### 输出

```
Yes
No
No
Yes
Yes
Yes
No
Yes
Yes
No
```

# AI分析结果



---
# 💡 Kay的C++算法解析：小 A 与两位神仙 深入学习指南 💡

<introduction>
今天我们要一起攻克的题目是“小 A 与两位神仙”。这道题涉及数论中的原根、阶等高级概念，需要我们通过巧妙的数学转化和高效的算法实现来解决。让我们一步步拆解问题，掌握核心思路！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论中的原根与阶的应用（涉及Pollard-Rho质因数分解、快速幂等技巧）

🗣️ **初步分析**：
题目要求判断是否存在非负整数 \( a \) 使得 \( x^a \equiv y \pmod{m} \)，其中 \( m \) 是奇质数的幂（\( m = p^k \)）。关键在于利用原根的性质将问题转化为线性同余方程。

原根是模 \( m \) 下的一个数 \( g \)，其幂次 \( g^0, g^1, ..., g^{\varphi(m)-1} \) 可以覆盖所有与 \( m \) 互质的数（\( \varphi(m) \) 是欧拉函数）。假设 \( x = g^X \)、\( y = g^Y \)（\( X, Y \) 是 \( x, y \) 关于 \( g \) 的“指标”），则原方程等价于 \( Xa \equiv Y \pmod{\varphi(m)} \)。根据数论中的裴蜀定理，该方程有解当且仅当 \( \gcd(X, \varphi(m)) \mid Y \)，进一步转化为 \( \delta_m(y) \mid \delta_m(x) \)（\( \delta_m(x) \) 是 \( x \) 模 \( m \) 的阶，即最小的 \( k \) 使得 \( x^k \equiv 1 \pmod{m} \)）。

**核心难点**：  
- 快速分解 \( m \) 的质因数求 \( \varphi(m) \)（因 \( m \) 可能极大，需用Pollard-Rho算法）。  
- 分解 \( \varphi(m) \) 的质因数以计算 \( x \) 和 \( y \) 的阶（试除法结合Pollard-Rho）。  

**可视化设计思路**：  
用8位像素风格展示原根 \( g \) 的幂次循环（如一个环形的像素网格，每个格子代表 \( g^i \mod m \)），动态演示 \( x \) 和 \( y \) 的阶计算过程（如用不同颜色标记循环节长度）。关键步骤（如试除质因数、判断 \( x^{k} \equiv 1 \pmod{m} \)）用闪烁或音效提示（如“叮”声表示找到一个质因数）。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性和算法有效性，以下题解值得重点参考：
</eval_intro>

**题解一：作者 双管荧光灯 (赞：20)**  
* **点评**：此题解逻辑清晰，直接点明原根和阶的关键转化，代码规范（如使用`__int128`处理大数乘法），并通过Pollard-Rho分解质因数求阶。亮点在于对阶的计算步骤解释详细（如试除质因数优化），代码实用性强，适合竞赛场景。

**题解二：作者 小粉兔 (赞：19)**  
* **点评**：此题解从原根的定义出发，逐步推导到阶的关系，数学推导严谨。代码中对Pollard-Rho和Miller-Rabin的实现高效，尤其对质因数分解的优化（如去重和排序）提升了计算效率，适合理解算法原理。

**题解三：作者 Alex_Wei (赞：6)**  
* **点评**：此题解简洁明了，直接抓住“阶的整除关系”核心，代码结构紧凑（如用`map`存储质因数）。对Pollard-Rho的封装清晰，适合快速理解关键步骤。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于掌握原根、阶的概念及高效计算方法。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **难点1：快速分解大数 \( m \) 的质因数**  
    * **分析**：\( m \) 可能高达 \( 10^{18} \)，传统试除法无法处理。需用Pollard-Rho算法（概率性分解）结合Miller-Rabin素性测试。  
    * 💡 **学习笔记**：Pollard-Rho适用于大数分解，通过随机函数生成候选因数，结合gcd快速找到质因数。

2.  **难点2：计算 \( \varphi(m) \) 和 \( \delta_m(x) \)**  
    * **分析**：\( m = p^k \)，故 \( \varphi(m) = p^{k-1}(p-1) \)。计算 \( \delta_m(x) \) 需分解 \( \varphi(m) \) 的质因数，然后通过试除法找到最小的 \( k \) 使得 \( x^k \equiv 1 \pmod{m} \)。  
    * 💡 **学习笔记**：阶 \( \delta_m(x) \) 是 \( \varphi(m) \) 的因数，试除质因数可快速缩小范围。

3.  **难点3：判断 \( \delta_m(y) \mid \delta_m(x) \)**  
    * **分析**：只需计算 \( x \) 和 \( y \) 的阶，检查后者是否整除前者。  
    * 💡 **学习笔记**：阶的整除关系是判断原方程有解的充要条件。

### ✨ 解题技巧总结
- **质因数分解优化**：使用Pollard-Rho+Miller-Rabin组合，快速分解大数。  
- **快速幂防溢出**：用`__int128`处理大数乘法（如计算 \( x^k \mod m \) 时）。  
- **试除阶的质因数**：通过分解 \( \varphi(m) \) 的质因数，逐步试除找到最小阶。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了Pollard-Rho分解和阶的计算逻辑：
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了双管荧光灯和小粉兔的题解思路，实现了质因数分解、欧拉函数计算和阶的判断，适合直接用于竞赛。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using lll = __int128;

ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }

ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    for (; b; b >>= 1, a = (lll)a * a % mod)
        if (b & 1) res = (lll)res * a % mod;
    return res;
}

bool mr(ll n) {
    if (n < 2) return false;
    if (n == 2 || n == 3) return true;
    ll r = n - 1, d = 0;
    while ((r & 1) == 0) r >>= 1, d++;
    for (ll a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
        if (a >= n) break;
        ll v = qpow(a, r, n);
        if (v == 1 || v == n - 1) continue;
        for (ll j = 0; j < d - 1; j++) {
            v = (lll)v * v % n;
            if (v == n - 1) break;
        }
        if (v != n - 1) return false;
    }
    return true;
}

ll pollard_rho(ll n) {
    if (n % 2 == 0) return 2;
    if (n % 3 == 0) return 3;
    ll x = rand() % (n - 1) + 1, c = rand() % (n - 1) + 1;
    ll y = x, d = 1;
    auto f = [&](ll x) { return ((lll)x * x + c) % n; };
    while (d == 1) {
        x = f(x);
        y = f(f(y));
        d = gcd(abs(x - y), n);
    }
    return d == n ? pollard_rho(n) : d;
}

void factorize(ll n, vector<ll>& factors) {
    if (n == 1) return;
    if (mr(n)) {
        factors.push_back(n);
        return;
    }
    ll d = pollard_rho(n);
    factorize(d, factors);
    factorize(n / d, factors);
}

ll phi(ll m, ll p) { return m / p * (p - 1); }

ll ord(ll x, ll m, vector<ll>& phif) {
    ll res = phi(m, phif[0]); // m = p^k, phif[0] = p
    for (ll p : phif) {
        while (res % p == 0 && qpow(x, res / p, m) == 1)
            res /= p;
    }
    return res;
}

int main() {
    ll m; int n;
    cin >> m >> n;
    vector<ll> m_factors;
    factorize(m, m_factors);
    sort(m_factors.begin(), m_factors.end());
    ll p = m_factors[0];
    vector<ll> phif;
    factorize(phi(m, p), phif);
    sort(phif.begin(), phif.end());
    phif.erase(unique(phif.begin(), phif.end()), phif.end());
    
    while (n--) {
        ll x, y;
        cin >> x >> y;
        ll ordx = ord(x, m, phif);
        ll ordy = ord(y, m, phif);
        cout << (ordx % ordy == 0 ? "Yes" : "No") << '\n';
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先通过Pollard-Rho分解 \( m \) 的质因数，确定 \( m = p^k \) 中的 \( p \)，计算 \( \varphi(m) = p^{k-1}(p-1) \)。然后分解 \( \varphi(m) \) 的质因数，用于计算 \( x \) 和 \( y \) 的阶。最后判断 \( \delta_m(y) \mid \delta_m(x) \)，输出结果。

---
<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：双管荧光灯**  
* **亮点**：用`__int128`处理大数乘法，Pollard-Rho分解质因数高效。  
* **核心代码片段**：
```cpp
inline ll qp(ll x, ll p, ll mod) {
    ll ans = 1;
    while (p) {
        if (p & 1) ans = (lll)ans * x % mod;
        x = (lll)x * x % mod;
        p >>= 1;
    }
    return ans;
}

inline bool mr(ll x, ll b) { /* Miller-Rabin 实现 */ }

inline ll PR(ll x) { /* Pollard-Rho 实现 */ }
```
* **代码解读**：  
  `qp`函数用快速幂计算 \( x^p \mod mod \)，`lll`（即`__int128`）避免溢出。`mr`和`PR`分别实现素性测试和质因数分解，是处理大数的关键。  
* 💡 **学习笔记**：大数乘法需用`__int128`防止溢出，这是处理 \( 10^{18} \) 量级数据的必要技巧。

**题解二：小粉兔**  
* **亮点**：质因数分解后去重排序，优化阶的计算。  
* **核心代码片段**：
```cpp
void Factorize(LL Num) {
    if (isPrime(Num)) { Prs[++Prc] = Num; return ; }
    LL d = Num;
    while (d == Num) d = PollardRho(Num);
    Factorize(d), Factorize(Num / d);
}

inline LL ord(LL x) {
    LL ans = Phi;
    for (int i = 1; i <= Prc; ++i) 
        if (qPow(x, ans / Prs[i], Mod) == 1) 
            ans /= Prs[i];
    return ans;
}
```
* **代码解读**：  
  `Factorize`递归分解质因数，`ord`函数通过试除质因数计算阶。去重排序后的质因数列表提高了试除效率。  
* 💡 **学习笔记**：分解质因数后去重排序，可避免重复计算，提升阶的计算速度。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解阶的计算和原根的作用，我们设计一个“原根探险”像素动画，用8位复古风格展示关键步骤！
</visualization_intro>

  * **动画演示主题**：原根探险——寻找循环节  
  * **核心演示内容**：展示 \( x \) 的阶 \( \delta_m(x) \) 的计算过程，包括分解 \( \varphi(m) \) 的质因数、试除验证等步骤。  

  * **设计思路简述**：  
    采用FC红白机风格，用像素网格表示模 \( m \) 的剩余系（如9个格子表示 \( m=9 \)）。原根 \( g \) 的幂次用绿色方块循环移动（每步移动1格），\( x = g^X \) 的幂次用红色方块（每步移动 \( X \) 格）。通过观察红色方块回到起点的步数（即阶），直观理解阶的含义。

  * **动画帧步骤与交互关键点**：  
    1. **场景初始化**：  
       - 屏幕上方显示 \( m \) 和 \( \varphi(m) \) 的值，下方是 \( m \) 个像素格子（如 \( m=9 \) 时，3x3网格）。  
       - 控制面板包含“单步”“自动”“重置”按钮和速度滑块。  
    2. **原根 \( g \) 的幂次演示**：  
       - 绿色方块从格子0开始，每步移动1格（\( g^0, g^1, ..., g^{\varphi(m)-1} \)），覆盖所有与 \( m \) 互质的格子（如 \( m=9 \) 时，格子1,2,4,5,7,8）。  
    3. **\( x \) 的阶计算**：  
       - 红色方块从格子 \( x \) 开始（\( x = g^X \)），每步移动 \( X \) 格（\( x^a = g^{Xa} \)）。  
       - 每次移动后检查是否回到格子1（即 \( x^a \equiv 1 \pmod{m} \)），记录最小的 \( a \)（阶）。  
       - 试除 \( \varphi(m) \) 的质因数时，用黄色标记当前试除的质因数，若 \( x^{k/p} \equiv 1 \pmod{m} \)，则缩小 \( k \)。  
    4. **结果判断**：  
       - 比较 \( x \) 和 \( y \) 的阶，若 \( \delta_m(y) \mid \delta_m(x) \)，播放“叮”音效并显示“YES”；否则显示“NO”。  

  * **旁白提示**：  
    - “看！绿色方块走完 \( \varphi(m) \) 步回到起点，这就是原根的循环节～”  
    - “红色方块需要走 \( \delta_m(x) \) 步回到1，这就是 \( x \) 的阶！”  

<visualization_conclusion>
通过这个动画，我们能直观看到原根的幂次覆盖、阶的计算过程，以及最终条件判断的逻辑，大大降低了理解难度！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握原根和阶的应用后，我们可以尝试以下拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    原根和阶的思想可用于解决离散对数问题（如BSGS算法优化）、高次同余方程求解，以及密码学中的RSA算法分析。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P4718 【模板】Pollard's Rho算法**  
        * 🗣️ **推荐理由**：直接练习Pollard-Rho质因数分解，巩固大数分解技巧。  
    2.  **洛谷 P6091 【模板】原根**  
        * 🗣️ **推荐理由**：深入理解原根的存在性和求法，与本题的原根应用形成互补。  
    3.  **洛谷 P3383 【模板】线性筛素数**  
        * 🗣️ **推荐理由**：基础素数筛法，为Miller-Rabin和Pollard-Rho的学习打基础。  

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，例如：
</insights_intro>

> **参考经验 (来自 小粉兔)**：“在实现Pollard-Rho时，需要注意随机种子的选择，否则可能导致分解失败。此外，用`__int128`处理大数乘法时，要避免溢出。”  
> **点评**：这些经验提醒我们，在处理大数运算时，数据类型的选择（如`__int128`）和随机算法的细节（如种子初始化）至关重要，直接影响代码的正确性和效率。

---

<conclusion>
通过这篇指南，我们掌握了原根、阶的概念及应用，学会了用Pollard-Rho分解大数和计算阶。编程的关键在于理解数学原理，并通过高效算法实现。下次遇到类似的数论问题，你一定能轻松解决！💪
</conclusion>

---
处理用时：168.02秒
# 题目信息

# [JOISC 2020] ジョイッターで友だちをつくろう

## 题目背景

Joitter 是一款交友软件。

## 题目描述

在 Joitter 你可以关注他人，但你不可以关注自己和关注他人两次，即如果关注他人多次只会算作一次。

共有 $N$ 名新用户，$M$ 天。

在第 $i$ 天，用户 $A_i$ 会关注用户 $B_i$。

同时在关注之后，会举办一场交友活动，活动内容如下：

1. 选择一个用户 $x$。
2. 选择一个被用户 $x$ 关注的用户 $y$。
3. 选择一个用户 $z$，要求 $z\not=x$，$x$ 未关注 $z$ 且 $y$ 和 $z$ 互关。
4. 让 $x$ 关注 $z$。
5. 重复 $1,2,3,4$，直到选不出合适的三元组 $(x,y,z)$。

您需要求出，对于每一个 $i$，第 $i$ 天过后的所有关注总数。

## 说明/提示

#### 子任务
对于 $100\%$ 的数据，保证 $2\le N\le 10^5$，$1\le M\le 3\times 10^5$，$1\le A_i,B_i\le N$，$A_i\not=B_i$，$(A_i,B_i)\not=(A_j,B_j)$。

| 子任务编号 | $N\le $ | 分值 |
|:-:|:-:|:-:
| $1$ | $50$ | $1$ |
| $2$ | $2\times 10^3$ | $16$ |
| $3$ | 无 | $83$ |

#### 说明
本题译自 [第 19 回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) Day 2 [T2 ジョイッターで友だちをつくろう](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day2/joitter2-en.pdf)。

## 样例 #1

### 输入

```
4 6
1 2
2 3
3 2
1 3
3 4
4 3```

### 输出

```
1
2
4
4
5
9```

## 样例 #2

### 输入

```
6 10
1 2
2 3
3 4
4 5
5 6
6 5
5 4
4 3
3 2
2 1```

### 输出

```
1
2
3
4
5
7
11
17
25
30```

# AI分析结果



---
# 💡 Kay的C++算法解析：[JOISC 2020] ジョイッターで友だちをつくろう 深入学习指南 💡

<introduction>
今天我们来分析这道来自日本信息学竞赛的题目。题目围绕社交软件的关注关系展开，核心是在动态添加关注边后，计算自动触发的关注操作后的总关注数。通过分析题解，我们会发现这是一个典型的图论问题，需要用并查集维护“互相关注的极大团”，并结合启发式合并优化效率。让我们一步步拆解！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：图论（动态连通性，极大团维护）

🗣️ **初步分析**：
解决这道题的关键在于理解“互相关注的极大团”这一概念。简单来说，极大团是一个点集，其中任意两点都互相关注（即存在双向边）。例如，若A关注B，B关注C，且C关注B，那么A、B、C会形成一个极大团，因为A可以通过B自动关注C，C也可以通过B自动关注A，最终三者两两互相关注。

在本题中，每次添加一条关注边后，可能触发多个自动关注操作，最终形成新的极大团。我们需要动态维护这些极大团的信息（如大小、与其他团的连接关系），并快速计算总关注数。

- **题解思路对比**：多个题解均采用并查集维护极大团，用`set`或`map`记录团之间的连接关系（如某个团被哪些团指向），并通过启发式合并（小团合并到大团）优化时间复杂度。差异主要体现在数据结构的选择（如`set`维护入边/出边，`map`记录边数）和合并逻辑的细节处理。
- **核心算法流程**：每次添加边`A→B`后，检查A所在的团`X`和B所在的团`Y`是否已互相指向（即存在`Y→X`的边）。若存在，则合并`X`和`Y`；否则，更新`X`到`Y`的连接关系。合并时需处理所有相关团的连接关系，并重新计算总关注数。
- **可视化设计**：采用8位像素风格动画，用不同颜色的方块表示极大团（如红色团、蓝色团），用箭头表示团之间的指向。合并时，小团的方块逐渐融入大团，伴随“融合”音效；添加新边时，箭头从A所在团滑向B所在团，伴随“叮”的音效。关键步骤（如判断是否合并、更新总关注数）用文字气泡解释。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等维度，以下题解在核心逻辑推导和实现细节上表现突出（评分≥4星）：
</eval_intro>

**题解一：周子衡的解法（来源：用户周子衡）**
* **点评**：此题解对极大团的定义和合并逻辑解释清晰，代码中使用`set`维护入边（`IN`）、出边（`OUT`）和外部点（`IP`），并通过队列处理级联合并。代码变量命名规范（如`calc`函数计算团的贡献），合并时采用启发式（小团合到大团）优化时间。实践价值高，适合直接参考。

**题解二：xht的解法（来源：用户xht）**
* **点评**：此题解用`set`维护团内节点（`s`）、点到团的边（`e`）、团到团的边（`fe`/`fg`），合并时通过双端队列处理级联操作。代码结构简洁，关键逻辑（如合并时的贡献计算）注释明确，对启发式合并的应用（按团大小交换）优化了时间复杂度。

**题解三：Purslane的解法（来源：用户Purslane）**
* **点评**：此题解从问题性质出发，推导极大团的合并条件，代码中用`map`记录团间边数（`tb`/`ib`），并详细处理合并时的贡献变化（如减去旧贡献、加上新贡献）。对细节（如外部点的处理）考虑周全，适合深入理解合并逻辑。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于处理极大团的动态合并与贡献计算。以下是三个核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：如何定义并维护极大团的信息？**
    * **分析**：极大团需要维护的信息包括：团的大小（`sze`）、指向该团的外部点集合（`IP`）、与其他团的连接关系（`IN`/`OUT`）。例如，周子衡的题解中用`set`维护`IN`（其他团指向当前团）和`OUT`（当前团指向其他团），确保快速查询和更新。
    * 💡 **学习笔记**：维护极大团的信息时，需选择高效的数据结构（如`set`支持O(log n)查询），并明确每个集合的含义（入边、出边、外部点）。

2.  **关键点2：如何处理级联合并？**
    * **分析**：当合并两个团时，可能触发其他团的合并（如团A合并团B后，团C若同时指向A和B，可能需要合并A和C）。周子衡的题解中用队列（`Q`）维护待合并的团对，确保所有相关合并操作被处理。
    * 💡 **学习笔记**：级联合并需用队列或双端队列记录待处理的团对，避免遗漏，同时通过启发式合并（小团合到大团）保证时间复杂度。

3.  **关键点3：如何高效计算总关注数？**
    * **分析**：总关注数由两部分组成：极大团内部的双向边（`s*(s-1)`）和外部点指向该团的单向边（`s*k`，`k`为外部点数）。周子衡的`calc`函数直接计算这两部分，合并时先减去旧团的贡献，再加上新团的贡献，确保动态更新。
    * 💡 **学习笔记**：总关注数的计算需基于团的当前状态（大小、外部点数），合并时需先“撤销”旧状态的贡献，再计算新状态的贡献。

### ✨ 解题技巧总结
- **启发式合并**：合并两个团时，将较小的团合并到较大的团中，减少数据结构操作的次数，优化时间复杂度。
- **队列处理级联**：用队列记录待合并的团对，确保所有相关合并操作被处理，避免遗漏。
- **数据结构选择**：用`set`维护入边、出边和外部点，支持快速查询和插入，避免重复元素。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解（如周子衡、xht的解法）提炼的通用核心实现，展示并查集维护极大团、启发式合并和贡献计算的核心逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了周子衡和xht的题解思路，采用并查集维护极大团，`set`记录团间连接关系，启发式合并优化时间，适用于理解核心逻辑。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <set>
    #include <queue>
    using namespace std;

    const int MAXN = 1e5 + 5;
    int fa[MAXN];
    set<int> IN[MAXN], OUT[MAXN], IP[MAXN], S[MAXN]; // 极大团的入边、出边、外部点、内部点
    long long ans = 0;
    queue<pair<int, int>> Q;

    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }

    long long calc(int x) { // 计算团x的总贡献
        return 1LL * (S[x].size() - 1) * S[x].size() + 1LL * IP[x].size() * S[x].size();
    }

    void merge(int x, int y) {
        x = find(x); y = find(y);
        if (x == y) return;
        if (S[x].size() < S[y].size()) swap(x, y); // 启发式合并：小团合到大团
        fa[y] = x;

        ans -= calc(x) + calc(y); // 先减去旧贡献

        // 处理y的内部点：合并到x的内部点集合
        for (int u : S[y]) {
            S[x].insert(u);
            if (IP[x].count(u)) IP[x].erase(u); // 内部点不属于外部点
        }

        // 处理y的外部点：合并到x的外部点集合（非内部点）
        for (int u : IP[y]) {
            if (!S[x].count(u) && !IP[x].count(u))
                IP[x].insert(u);
        }

        // 处理y的入边：更新其他团的出边到x
        for (int u : IN[y]) {
            if (u == x) continue;
            OUT[u].erase(y);
            OUT[u].insert(x);
            IN[x].insert(u);
            if (OUT[x].count(u)) Q.push({x, u}); // 若x和u互相指向，触发合并
        }

        // 处理y的出边：更新其他团的入边到x
        for (int u : OUT[y]) {
            if (u == x) continue;
            IN[u].erase(y);
            IN[u].insert(x);
            OUT[x].insert(u);
            if (IN[x].count(u)) Q.push({x, u}); // 若x和u互相指向，触发合并
        }

        ans += calc(x); // 加上新贡献
    }

    int main() {
        int n, m;
        scanf("%d%d", &n, &m);
        for (int i = 1; i <= n; ++i) {
            fa[i] = i;
            S[i].insert(i);
        }

        while (m--) {
            int A, B;
            scanf("%d%d", &A, &B);
            int X = find(A), Y = find(B);
            if (X == Y) {
                printf("%lld\n", ans);
                continue;
            }

            if (IN[X].count(Y)) { // 若Y指向X，触发合并
                Q.push({X, Y});
                while (!Q.empty()) {
                    auto [u, v] = Q.front(); Q.pop();
                    merge(u, v);
                }
            } else { // 否则，更新连接关系
                ans -= calc(X) + calc(Y);
                IN[Y].insert(X); // X指向Y（Y的入边包含X）
                IP[Y].insert(A); // A是Y的外部点
                OUT[X].insert(Y); // X的出边包含Y
                ans += calc(X) + calc(Y);
            }

            printf("%lld\n", ans);
        }
        return 0;
    }
    ```
* **代码解读概要**：代码通过并查集`fa`维护极大团的根节点，`S`记录团内点，`IN`/`OUT`记录团间指向关系，`IP`记录外部点。`merge`函数处理团的合并（启发式优化），`calc`计算团的贡献。主函数处理输入，每次添加边后判断是否触发合并，并更新总关注数。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，学习其中的关键技巧。
</code_intro_selected>

**题解一：周子衡的解法（来源：用户周子衡）**
* **亮点**：用`queue`处理级联合并，`set`维护团间关系，代码结构清晰，启发式合并优化时间。
* **核心代码片段**：
    ```cpp
    void merge(int x, int y) {
        x = B.fnd(x), y = B.fnd(y); if (x == y) return;
        if (S[x].size() < S[y].size()) swap(x, y); // 启发式合并
        B.fa[y] = x;
        ans -= calc(x), ans -= calc(y);
        // 合并内部点、外部点、入边、出边...
        ans += calc(x);
    }
    ```
* **代码解读**：`merge`函数首先通过并查集找到根节点，若大小不同则交换（小团合到大团）。合并前减去旧团的贡献，合并后处理内部点、外部点、入边和出边的更新，最后加上新团的贡献。这一步确保了总关注数的动态更新。
* 💡 **学习笔记**：启发式合并是优化时间复杂度的关键，确保每次合并的代价与小团的大小相关，总复杂度为O(m log²m)。

**题解二：xht的解法（来源：用户xht）**
* **亮点**：用双端队列处理级联操作，`set`维护点到团的边，合并时处理外部点的贡献变化。
* **核心代码片段**：
    ```cpp
    inline void work(int x, int y) {
        int fx = get(x), fy = get(y);
        if (fx == fy) return;
        if (fe[fy].find(fx) == fe[fy].end()) {
            // 直接添加边，更新贡献
            ans += s[fy].size();
            return;
        }
        // 合并操作，处理旧贡献、合并点、更新边...
    }
    ```
* **代码解读**：`work`函数判断是否需要合并（若`fy`已指向`fx`），否则直接添加边并更新贡献。合并时先减去旧团的贡献，再合并点集，最后加上新团的贡献。双端队列确保级联合并被处理。
* 💡 **学习笔记**：合并前需先“撤销”旧状态的贡献（减去旧团的贡献），再处理合并，最后计算新状态的贡献（加上新团的贡献）。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解极大团的合并和关注数的计算，我们设计一个“像素团融合”动画，用8位像素风格展示团的合并过程和关注边的添加。
</visualization_intro>

  * **动画演示主题**：`像素团大融合——Joitter关注关系模拟`

  * **核心演示内容**：展示每次添加边后，极大团的合并过程（如红色团和蓝色团融合成紫色团）、外部点的自动关注（绿色点指向紫色团的所有点），以及总关注数的动态更新。

  * **设计思路简述**：8位像素风（FC游戏风格）营造轻松氛围，用不同颜色区分团（红/蓝/紫），箭头表示团间指向，数字显示总关注数。合并时小团的像素块逐渐融入大团，伴随“融合”音效；添加新边时箭头从起点团滑向终点团，伴随“叮”的音效，帮助学习者记忆关键操作。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：屏幕左侧为像素网格（每个格子代表一个用户），右侧为控制面板（单步/自动播放按钮、速度滑块）。顶部显示总关注数（初始为0）。

    2.  **添加边操作**：输入`A→B`后，A所在的红色团（假设）和B所在的蓝色团间出现一个箭头（红色→蓝色），伴随“叮”的音效。总关注数增加蓝色团的大小（如蓝色团有2个点，总关注数+2）。

    3.  **触发合并**：若蓝色团已指向红色团（存在蓝色→红色的箭头），红色团和蓝色团开始融合。蓝色团的像素块逐个移动到红色团的位置，颜色变为紫色（新团），伴随“融合”音效。总关注数先减去红、蓝团的旧贡献，再加上紫团的新贡献（如红团贡献2*1=2，蓝团贡献2*1=2，紫团贡献4*3=12，总关注数从4变为12）。

    4.  **级联合并**：若紫团与另一个黄色团互相指向，黄色团的像素块也融入紫团，颜色变为更大的紫色团。控制面板的“自动播放”模式会自动处理所有级联操作，学习者可通过“单步”按钮逐步观察。

    5.  **目标达成提示**：当所有合并完成，总关注数稳定后，播放“胜利”音效（短旋律），并高亮总关注数的变化。

  * **旁白提示**：
      - “现在添加边A→B，A在红色团，B在蓝色团。”
      - “蓝色团已指向红色团，触发合并！看，蓝色团的像素块正在融入红色团！”
      - “总关注数更新：旧红团贡献2，旧蓝团贡献2，新紫团贡献12，现在总关注数是12！”

<visualization_conclusion>
通过这样的动画，我们能直观看到极大团的合并过程、关注边的添加逻辑，以及总关注数的计算方式，让抽象的算法变得“看得见、听得见”！
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是动态维护图的连通性（极大团），并处理级联合并。这种思路还可用于以下场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 动态维护强连通分量（如缩点后的图结构）。
      - 处理带权并查集的合并（如边权表示关系）。
      - 维护集合间的连接关系（如社交网络中的共同好友）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3367 并查集** - `并查集模板题`
          * 🗣️ **推荐理由**：巩固并查集的基础操作（合并、查询），为本题的动态维护打基础。
    2.  **洛谷 P1955 [NOI2009] 植物大战僵尸** - `强连通分量与拓扑排序`
          * 🗣️ **推荐理由**：练习强连通分量的应用，理解图的缩点与连通性分析。
    3.  **洛谷 P7323 [WC2021] 括号路径** - `动态连通性维护`
          * 🗣️ **推荐理由**：本题的弱化版，练习动态维护图的连通性，与本题思路高度相关。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时的经验，例如Purslane提到“一开始误以为关注操作具有传递性，导致错误”，Hellsing_Alucard提到“因看错边的贡献计算（两端size乘积）调了很久”。这些经验对我们很有启发：
</insights_intro>

> **参考经验 (来自 Purslane)**：“NOIP模拟赛时，误以为关注操作具有传递性（如A关注B，B关注C，则A自动关注C），导致错误。后来发现，自动关注的条件是存在互相关注的y和z，而非单纯传递。”
>
> **点评**：理解题目规则的细节至关重要。本题的自动关注需满足y和z互相关注，而非简单传递。调试时可通过手动模拟小样例（如样例1）验证逻辑是否正确。

> **参考经验 (来自 Hellsing_Alucard)**：“因看错总关注数的计算（两端size乘积）调了很久，实际应为终点size的累加。”
>
> **点评**：总关注数的计算是本题的核心，需仔细审题。调试时可打印中间变量（如团的大小、外部点数），确认贡献计算是否正确。

---

<conclusion>
通过分析本题的极大团维护、启发式合并和贡献计算，我们掌握了动态图连通性问题的解决方法。编程时需注意数据结构的选择（如`set`维护关系）、级联合并的处理（队列记录待合并团对），以及总关注数的动态更新。希望大家通过练习类似题目（如洛谷P7323）巩固这些技巧，提升算法能力！💪
</conclusion>

---

---
处理用时：161.38秒
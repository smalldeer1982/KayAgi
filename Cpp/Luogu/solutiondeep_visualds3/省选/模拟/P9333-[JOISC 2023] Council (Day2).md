# 题目信息

# [JOISC 2023] Council (Day2)

## 题目描述

#### 题目翻译

在 JOI 市议会中，有 $N$ 名议员，编号从 $1$ 到 $N$。议会将召开会议，议员们将对 $M$ 项提案进行表决，编号为 $1$ 到 $M$。如果 $A_{i,j}=1$，则议员 $i (1≤i≤N)$ 将对提案 $j (1≤j≤M)$ 表决肯定票。如果 $A_{i,j}=0$，则议员 $i$ 将对提案 $j$ 表决否定票。

JOI 市议会的程序如下所示。

+ 在 $N$ 名议员中，通过抽签随机选择主席。

+ 主席将在除了主席以外的其他 $N−1$ 名议员中选择副主席。

+ 将对 $M$ 项提案进行表决。除了主席和副主席以外的其他 $N−2$ 名议员，每人对每个提案均投票支持或反对。如果大多数议员（即肯定票大于等于 $⌊\dfrac{N}{2}⌋$）投票赞成，则议会将批准该提案。其中 $⌊x⌋$ 表示不超过 $x$ 的最大整数。

市长 K 希望议会尽可能地批准更多的提案。市长 K 收集了议员的信息并知道每个议员在每个提案上的表决结果。

请编写程序，在给定议员投票信息的情况下，计算每个议员作为主席时议会可以批准的提案数量的最大可能值。

## 样例 #1

### 输入

```
3 3
1 0 0
1 1 0
1 1 1
```

### 输出

```
3
3
2
```

## 样例 #2

### 输入

```
4 12
1 1 1 0 1 1 0 1 0 1 1 0
1 1 0 1 1 0 1 1 1 1 1 0
0 0 1 1 1 0 0 0 0 0 1 1
1 0 0 0 1 1 1 1 1 0 0 0
```

### 输出

```
5
4
6
6
```

## 样例 #3

### 输入

```
16 4
0 0 0 0
0 0 0 1
0 0 1 0
0 0 1 1
0 1 0 0
0 1 0 1
0 1 1 0
0 1 1 1
1 0 0 0
1 0 0 1
1 0 1 0
1 0 1 1
1 1 0 0
1 1 0 1
1 1 1 0
1 1 1 1
```

### 输出

```
3
3
3
2
3
2
2
1
3
2
2
1
2
1
1
0
```

## 样例 #4

### 输入

```
4 2
1 0
0 1
1 1
1 1
```

### 输出

```
2
2
1
1
```

# AI分析结果



---
# 💡 Kay的C++算法解析：[JOISC 2023] Council (Day2) 深入学习指南 💡

<introduction>
今天我们来一起分析“[JOISC 2023] Council (Day2)”这道C++编程题。这道题涉及状态压缩与高维前缀和（SOS DP）的巧妙应用，通过分析题目核心逻辑和优质题解，我们将掌握如何高效处理多条件下的最优选择问题。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（状态压缩与高维前缀和/SOS DP）`

🗣️ **初步分析**：
解决这道题的关键在于，当主席确定后，如何快速找到最优的副主席，使得通过的提案最多。核心难点在于处理那些得票数恰好等于⌊N/2⌋的提案——它们的通过与否取决于副主席的投票。

简单来说，我们可以将每个议员的投票状态压缩为二进制数（例如，提案j赞成则第j位为1）。高维前缀和（SOS DP）是一种高效处理这类状态子集/超集问题的算法，它能预处理每个状态的最大值，帮助我们快速查询最优副主席。

- **题解思路对比**：多数题解（如541forever、TernaryTree）采用SOS DP预处理每个状态的最大值和次大值；Nangu尝试FWT但较复杂；anthonyaaabc用分块平衡复杂度，但SOS DP更高效。
- **核心算法流程**：首先计算每个主席确定后，得票数恰好等于⌊N/2⌋的提案集合（状态S）；然后预处理所有议员的投票状态（取反后），用SOS DP记录每个状态S下的最大/次大值；最后对每个主席，查询其状态S对应的最大贡献。
- **可视化设计**：采用8位像素风格，用不同颜色的像素块表示提案状态（如绿色表示通过、黄色表示待定）。动画中，SOS DP预处理过程用“状态扩散”动画展示（类似FC游戏中能量波扩散），每次更新最大值时伴随“叮”的音效；查询时高亮当前主席的状态S，并用箭头指向最优副主席的状态。

---

## 2. 精选优质题解参考

<eval_intro>
通过对各题解的思路清晰度、代码规范性、算法有效性等方面评估，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：作者541forever**
* **点评**：此题解思路简洁高效，直接点明SOS DP的核心作用。代码中通过状态取反（将赞成票转为反对票的二进制），将问题转化为求子集最大值，并用高维后缀和预处理最大值和次大值。代码结构清晰，变量命名合理（如`g1`、`g2`分别记录最大值和次大值），边界处理严谨（避免选自己当副主席）。实践价值高，可直接用于竞赛。

**题解二：作者TernaryTree**
* **点评**：此题解对SOS DP的应用非常深入，详细解释了状态转移的逻辑。代码中维护了`f`和`g`数组分别记录最大值和次大值，并通过`merge`函数合并不同状态的结果，确保不重复计算同一议员。对“主席与副主席不同”的限制处理巧妙，通过比较最大值和次大值的编号解决。

**题解三：作者_Luminescence_**
* **点评**：此题解从问题本质出发，清晰推导了状态压缩的必要性，并详细解释了SOS DP的超集和子集处理步骤。代码中`get1`和`get2`函数分别处理不同状态的合并，逻辑直白易懂。对“为什么取反投票状态”的解释到位，帮助理解核心思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题时，我们通常会遇到以下关键点。结合优质题解的共性，提炼核心策略：
</difficulty_intro>

1.  **关键点1：如何将提案状态压缩为二进制？**
    * **分析**：每个提案的赞成/反对可视为二进制位（如赞成则第j位为1）。状态压缩后，每个议员的投票状态可表示为一个m位的二进制数（m为提案数）。例如，若议员i对提案1和3赞成，状态为`101`（假设m=3）。
    * 💡 **学习笔记**：状态压缩是处理多条件问题的常用技巧，能将复杂的多维度比较转化为二进制位运算。

2.  **关键点2：如何用SOS DP预处理最大值？**
    * **分析**：SOS DP（高维前缀和）可高效处理子集/超集的最值问题。本题中，我们需要找到状态S（得票恰好等于⌊N/2⌋的提案集合）的子集，对应副主席的反对票状态（取反后的投票状态）的最大值。通过预处理每个状态的最大值和次大值，查询时直接获取最优解。
    * 💡 **学习笔记**：SOS DP的核心是“按位枚举，状态扩散”，每一步处理一个二进制位，更新所有包含该位的状态。

3.  **关键点3：如何处理“副主席不能是主席”的限制？**
    * **分析**：预处理时需记录最大值和次大值的编号。查询时，若最大值的编号是主席本人，则取次大值；否则取最大值。这需要在SOS DP过程中维护两个不同的编号。
    * 💡 **学习笔记**：维护多个最值（如最大、次大）是处理互斥条件的常用方法，确保在排除某个值后仍有备选解。

### ✨ 解题技巧总结
- **状态取反转换问题**：将“找反对票最多的副主席”转换为“找赞成票最少的副主席”，通过取反投票状态简化计算。
- **预处理最值**：利用SOS DP预处理所有可能状态的最值，将单次查询复杂度从O(N)降至O(1)。
- **边界条件检查**：在预处理和查询时，始终检查副主席是否为主席本人，避免逻辑错误。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解（主要参考TernaryTree和_Luminescence_的思路）提炼的通用核心C++实现，展示如何通过SOS DP解决问题。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了SOS DP预处理和状态压缩的核心逻辑，通过维护最大值和次大值处理副主席互斥问题，适用于竞赛环境。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using pii = pair<int, int>;

    const int MAXM = 20; // 提案数最多20，状态数2^20
    int n, m, total_states;
    int vote[100005]; // 每个议员的投票状态（二进制）
    int cnt[MAXM]; // 每个提案的初始赞成票数
    pii f[1 << MAXM]; // 记录每个状态的最大值（编号，值）和次大值

    // 合并两个pii，保留前两大的不同编号
    pii merge(pii a, pii b, int s) {
        vector<int> tmp = {a.first, a.second, b.first, b.second};
        sort(tmp.begin(), tmp.end(), [&](int x, int y) {
            return __builtin_popcount(vote[x] & s) > __builtin_popcount(vote[y] & s);
        });
        tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());
        return {tmp.size() >= 1 ? tmp[0] : 0, tmp.size() >= 2 ? tmp[1] : 0};
    }

    int main() {
        cin >> n >> m;
        total_states = 1 << m;
        for (int i = 1; i <= n; ++i) {
            for (int j = 0; j < m; ++j) {
                int x; cin >> x;
                vote[i] |= x << j;
                cnt[j] += x;
            }
            // 初始状态：每个议员的投票状态对应的位置记录自己
            f[vote[i]] = merge(f[vote[i]], {i, 0}, vote[i]);
        }

        // SOS DP预处理超集最大值（高维后缀和）
        for (int i = 0; i < m; ++i) {
            for (int s = 0; s < total_states; ++s) {
                if (!(s & (1 << i))) {
                    f[s] = merge(f[s], f[s | (1 << i)], s);
                }
            }
        }

        // 处理每个主席
        for (int i = 1; i <= n; ++i) {
            int base = 0, s = 0;
            // 计算base（得票>⌊N/2⌋的提案数）和状态s（得票=⌊N/2⌋的提案集合）
            for (int j = 0; j < m; ++j) {
                int current = cnt[j] - ((vote[i] >> j) & 1);
                if (current > n / 2) base++;
                else if (current == n / 2) s |= 1 << j;
            }

            // 查询s状态下的最大值和次大值
            pii res = f[s];
            int max_val = 0;
            if (res.first != i) max_val = __builtin_popcount(vote[res.first] & s);
            if (res.second != i) max_val = max(max_val, __builtin_popcount(vote[res.second] & s));
            cout << base + max_val << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先读取输入并初始化每个议员的投票状态和提案赞成票数。通过`merge`函数维护每个状态的最大值和次大值。SOS DP预处理阶段，按位枚举更新每个状态的超集最大值。最后对每个主席，计算其对应的基础通过数（base）和待定状态（s），查询s状态下的最优副主席，输出总通过数。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段，理解其亮点和实现思路：
</code_intro_selected>

**题解一：作者TernaryTree**
* **亮点**：通过`merge`函数合并不同状态的最值，确保记录的是不同议员的编号。SOS DP分两步处理（超集和子集），逻辑清晰。
* **核心代码片段**：
    ```cpp
    pii merge(pii x, pii y) {
        vector<int> u;
        if (x.fs) u.push_back(x.fs); if (x.sc) u.push_back(x.sc);
        if (y.fs) u.push_back(y.fs); if (y.sc) u.push_back(y.sc);
        sort(u.begin(), u.end(), cmp); u.resize(unique(u.begin(), u.end()) - u.begin());
        return u.size() >= 2 ? pii(u[0], u[1]) : pii(u[0], 0);
    }
    ```
* **代码解读**：
    `merge`函数将两个`pii`（最大值和次大值）合并，去重后按贡献排序，确保返回的是前两大的不同议员编号。这一步是处理“副主席不能是主席”的关键，保证在查询时可以选择次大值。
* 💡 **学习笔记**：维护多个最值时，去重和排序是必要步骤，确保备选值的有效性。

**题解二：作者_Luminescence_**
* **亮点**：通过取反投票状态（`b[i] = T ^ a[i]`）将问题转换为求子集最大值，简化了SOS DP的处理逻辑。
* **核心代码片段**：
    ```cpp
    for (re int i = 1; i <= n; ++i) {
        b[i] = T; // T是全1状态（如m=3时T=111）
        for (re int j = 1; j <= m; ++j) {
            int x = rd;
            a[i][j] = x;
            if (x == 1) b[i] ^= (1 << (j - 1)); // 取反投票状态
        }
        f[b[i]] = get1(f[b[i]], {0, i}); // 初始状态记录自己
    }
    ```
* **代码解读**：
    将每个议员的投票状态取反（赞成变反对，反对变赞成），这样“找反对票最多的副主席”就转换为“找取反后状态与S的交集最大的副主席”。这一步转换使问题更符合SOS DP的处理场景（求子集最大值）。
* 💡 **学习笔记**：状态取反是转换问题的常用技巧，能将“最小”问题转换为“最大”问题，简化计算。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解SOS DP预处理和最优副主席查询的过程，我们设计一个“像素状态探险”动画，以8位复古风格展示状态压缩与预处理的每一步。
</visualization_intro>

  * **动画演示主题**：`像素状态探险——寻找最优副主席`

  * **核心演示内容**：展示每个议员的投票状态（像素块）如何通过SOS DP预处理扩散到所有可能的子集/超集状态，并最终为每个主席的“待定状态”找到最优副主席。

  * **设计思路简述**：采用8位像素风格（如FC游戏《超级马里奥》的配色），用不同颜色的方块表示提案状态（绿色：通过；黄色：待定；红色：不通过）。SOS DP的预处理过程用“状态波”动画展示（类似马里奥吃金币后能量扩散），每处理一个二进制位，对应的状态方块会更新最大值和次大值，伴随“叮”的音效。查询时，主席的“待定状态”方块会闪烁，箭头指向最优副主席的状态方块，播放“胜利”音效。

  * **动画帧步骤与交互关键点**：

    1.  **初始化场景**：
          * 屏幕左侧显示议员列表（像素小人），每个小人头顶显示其投票状态（如`101`的二进制像素块）。
          * 右侧为状态地图（2^m的网格），每个网格代表一个状态S（如`101`对应网格坐标(5)），初始时网格为空。

    2.  **初始状态填充**：
          * 每个议员的投票状态对应的网格会被填充为该议员的颜色（如议员1为红色，议员2为蓝色），并显示“初始值：议员X”。

    3.  **SOS DP预处理（高维后缀和）**：
          * 按位枚举二进制位（从第0位到m-1位），每处理一位时，该位的像素灯（如第0位对应最右边的灯）会亮起。
          * 对于每个状态S，若不包含当前位（如S=100，当前位是第0位），则从S | (1<<i)（如101）的状态“吸收”最大值和次大值，更新自己的网格内容。动画中用“状态波”从高位向低位扩散，更新后的网格显示新的最大值和次大值。

    4.  **查询最优副主席**：
          * 选择一个主席（如议员3），计算其“待定状态”S（黄色闪烁方块）。
          * 状态地图中S对应的网格会高亮，显示当前的最大值（议员A）和次大值（议员B）。
          * 若最大值是主席本人（议员3），则自动切换到次大值（议员B），箭头从主席指向次大值议员，播放“正确”音效；否则直接指向最大值议员，播放“胜利”音效。

    5.  **控制面板**：
          * 提供“单步执行”（逐位处理SOS DP）、“自动播放”（加速预处理）、“重置”按钮。
          * 速度滑块可调节动画快慢，方便观察每一步状态变化。

  * **旁白提示**：
      * （预处理阶段）“现在处理第i位，状态S会吸收S | (1<<i)的最大值，就像马里奥吃掉金币后获得能量！”
      * （查询阶段）“主席的待定状态是S，我们需要找与S交集最大的副主席，看！这个黄色方块就是最优选择！”

<visualization_conclusion>
通过这样的像素动画，我们能直观看到状态压缩和SOS DP的魔力——原本需要逐个枚举的副主席选择，通过预处理后只需一次查询即可完成。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是状态压缩与SOS DP的应用，这类技巧在处理多条件最优选择问题时非常有效。以下是相关拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 状态压缩可用于处理“多维度条件判断”问题（如多个开关的状态组合）。
      - SOS DP适用于“求子集/超集最值”的场景（如最大覆盖、最小冲突等）。
      - 维护多个最值（最大、次大）是处理“互斥条件”的常用策略（如不能选自己）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P5503 [JSOI2011] 柠檬**
          * 🗣️ **推荐理由**：涉及状态压缩与动态规划，需要维护不同状态下的最大值，与本题思路类似。
    2.  **洛谷 P4127 [AHOI2009] 同类分布**
          * 🗣️ **推荐理由**：需要将数字的各位状态压缩，并用SOS DP预处理，锻炼状态处理能力。
    3.  **洛谷 P3171 [CQOI2015] 网络吞吐量**
          * 🗣️ **推荐理由**：涉及图论中的最短路与状态限制，需要维护多个最值，与本题的互斥条件处理类似。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到了调试中的经验，例如处理“副主席不能是主席”时容易遗漏次大值。以下是典型经验总结：
</insights_intro>

> **参考经验 (来自作者TernaryTree)**：“在预处理最大值时，一开始只记录了最大值，导致当主席恰好是最大值编号时无法正确选择次大值。后来通过维护次大值并在查询时判断编号，解决了这个问题。”

**点评**：这位作者的经验提醒我们，在处理互斥条件时（如不能选自己），仅维护最大值是不够的，必须同时维护次大值。这在竞赛中是常见的边界情况，需要特别注意。调试时可以通过打印中间状态（如最大值的编号）快速定位问题。

-----

<conclusion>
本次关于“[JOISC 2023] Council (Day2)”的分析就到这里。通过状态压缩和SOS DP的巧妙应用，我们能高效解决多条件下的最优选择问题。希望大家通过练习巩固这些技巧，在竞赛中取得好成绩！💪
</conclusion>

---
处理用时：175.26秒
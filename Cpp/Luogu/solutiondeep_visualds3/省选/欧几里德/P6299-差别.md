# 题目信息

# 差别

## 题目描述

定义整数 $p,q,r,s$ 与给定的整数 $a,b,c,d$ 的差别度

$$M=\Big|\left(a^2+b^2\right)\left(p^2+q^2\right)+\left(c^2+d^2\right)\left(r^2+s^2\right)+2\big(ac+bd\big)\big(pr-qs\big)+2\big(bc-ad\big)\big(ps+qr\big)\Big|$$

你的任务是求出差别度 $M$ 的非零最小值与取到非零最小值时的一组 $p,q,r,s$。保证差别度 $M$ 的非零最小值存在且小于 $2^{63}$，保证存在一组绝对值都小于 $2^{63}$ 的 $p,q,r,s$ 使得 $M$ 取到非零最小值。

## 说明/提示

### 样例解释 #1

显然当 $a=1,b=9,c=2,d=6$ 时，差别度 $M$ 一定为偶数，因此 $M$ 不可能取到小与 $2$ 的非零值。

### 数据范围

| 测试点编号 | 特殊性质 |
|:-:|:-:|
| $1$ | $c=d=0$ |
| $2$ | $a=c=0$ |
| $3$ | $b=d=0$ |
| $4$ | $ad=bc$ |
| $5$ | $\vert a\vert,\vert b\vert,\vert c\vert,\vert d\vert\le10$ |
| $6\sim10$ | 无 |

对于 $100\%$ 的数据，满足 $\vert a\vert,\vert b\vert,\vert c\vert,\vert d\vert\le10^9$。

### 评分方式

**你需要保证每个测试点输出的数的个数为** $5$ **个且** $\vert p\vert,\vert q\vert,\vert r\vert,\vert s\vert,\vert M\vert<2^{63}$**，以避免出现无法预期的错误。**

对于每个测试点，如果你的 $M$ 与标准输出一致，就能得到 $4$ 分；如果你输出的 $p,q,r,s$ 能使计算结果等于 $M$，就能再获得 $6$ 分。

## 样例 #1

### 输入

```
1 9 2 6
```

### 输出

```
2 1 -3 1 2
```

## 样例 #2

### 输入

```
19674937 18722417 163948077 124500851
```

### 输出

```
146134 -61558 -18260 -10209 221162
```

# AI分析结果

# 💡 Kay的C++算法解析：「差别」深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：高斯整数（复数域）的扩展欧几里得算法  

🗣️ **初步分析**：  
解决「差别」问题的关键，在于**将复杂的代数表达式转化为复数的模运算**。简单来说，高斯整数就是形如 `a+bi`（`a,b`为整数，`i`是虚数单位）的复数，它的「范数」是 `a²+b²`（相当于复数模的平方）。  

题目中的差别度 `M` 看起来很吓人，但通过代数变形可以化简为：  
$$M = |(a+bi) \cdot (p-qi) + (c+di) \cdot (r+si)|^2$$  
其中 `A=a+bi`、`B=c+di` 是给定的高斯整数，`x=p-qi`、`y=r+si` 是我们要找的高斯整数。根据数论中的结论，**`Ax+By`的最小非零范数，就是`A`和`B`在高斯整数中的最大公约数（gcd）的范数**。因此，问题转化为：用扩展欧几里得算法求高斯整数`A`和`B`的gcd，并找到对应的`x`、`y`。  

### 核心算法流程与可视化思路  
1. **高斯整数的带余除法**：对于两个高斯整数`α`、`β`，找到`ε`（商）和`γ`（余数），使得`α=εβ+γ`，且`γ`的范数≤`β`范数的1/2（保证算法收敛）。  
2. **扩展欧几里得递归**：类似整数的exgcd，递归求`gcd(β, α%β)`，并反向推导`x`、`y`的更新。  

**可视化设计思路**：  
用8位像素风格模拟「复数矿工」游戏——  
- 用不同颜色的像素块表示高斯整数的实部（横向）和虚部（纵向），比如`α=3+2i`是红色块在(3,2)位置。  
- 带余除法时，用「锤子动画」将`α`分解为`εβ`（蓝色块）和`γ`（黄色块），并显示范数变化（比如`γ`的范数从13变成5）。  
- 递归过程用「路径回溯」动画，展示`x`、`y`如何从底层向上更新。  
- 关键操作（如除法、余数计算）伴随「叮」「啪」的像素音效，找到gcd时播放「胜利音阶」。  


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了3份优质题解，覆盖了理论推导到代码实现的全流程：
</eval_intro>

### 题解一：Daniel13265（官方题解）  
* **点评**：这份题解是「解题说明书」级别的存在！它从测试点1到10逐步拆解，先通过特殊情况（如`c=d=0`）引导思考，再将复杂的`M`表达式化简为复数模平方，最后引入高斯整数的扩展欧几里得算法。理论推导严谨，尤其是**带余除法的证明**（保证余数范数减半），为代码实现提供了数学基础。对于理解「为什么用复数」「为什么这样做除法」帮助极大。

### 题解二：kkksx（代码实现）  
* **点评**：这是一份「能直接跑通的实战代码」！作者重载了复数的`+`、`-`、`*`、`/`、`%`运算符，完美实现了高斯整数的四则运算。`exgcd`函数的递归逻辑和整数exgcd高度一致，只是将「整数除法」替换为「复数四舍五入除法」。代码中的`x.x`对应`p`、`-x.y`对应`q`、`y.x`对应`r`、`y.y`对应`s`，直接对应题目要求的输出，非常直观。

### 题解三：naught（补充优化）  
* **点评**：这份题解在kkksx的基础上做了**输入优化**（用`lread`函数快速读取大整数），并强调了「开long long」的重要性（避免溢出）。代码中的`plural`结构体定义更简洁，`operator==`的重载让边界条件（`b==0`）判断更清晰。作者还补充了「带余除法的证明」，帮学习者巩固理论基础。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的「三座大山」是：**化简表达式**、**实现高斯除法**、**递归更新变量**。结合优质题解，我为你提炼了针对性策略：
</difficulty_intro>

### 1. 难点1：如何将复杂的`M`化简为复数模平方？  
* **分析**：题目中的`M`有16个四次项，但通过**平方和公式**和**复数乘法展开**可以逐步简化。例如：  
  - `(a²+b²)(p²+q²) = |a+bi|² |p-qi|² = |(a+bi)(p-qi)|²`（复数模的乘法性质）；  
  - 交叉项`2(ac+bd)(pr-qs)`和`2(bc-ad)(ps+qr)`，正好对应复数`(a+bi)(c+di)`的实部和虚部的两倍。  
* 💡 **学习笔记**：遇到复杂的平方和表达式，先想想「是否能转化为复数模运算」——复数的乘法会自动处理交叉项！

### 2. 难点2：如何实现高斯整数的带余除法？  
* **分析**：高斯除法的关键是**找到商`ε`，使得余数`γ`的范数≤原数的1/2**。实现时，将复数除法的结果四舍五入（比如`(3+2i)/(1+i)`≈`2.5+0.5i`，四舍五入为`3+0i`），再计算`γ=α-εβ`。这样`γ`的范数一定满足条件（证明见官方题解）。  
* 💡 **学习笔记**：四舍五入是高斯除法的「魔法钥匙」——它保证了算法的收敛性！

### 3. 难点3：如何递归更新`x`、`y`？  
* **分析**：扩展欧几里得的递归逻辑和整数完全一致：  
  - 当`b=0`时，`gcd(a,0)=a`，此时`x=1`、`y=0`（因为`a*1 + 0*0 = a`）；  
  - 否则，先求`gcd(b, a%b)`的解`x'`、`y'`，再反向推导当前层的`x=y'`、`y=x' - (a/b)*y'`。  
* 💡 **学习笔记**：递归的核心是「子问题的解能推导出父问题的解」——记住这个逻辑，不管是整数还是复数exgcd都能搞定！

### ✨ 解题技巧总结  
- **代数变形优先**：复杂表达式先尝试因式分解或转化为已知模型（如复数）；  
- **运算符重载简化代码**：将复数的四则运算封装成结构体，避免重复代码；  
- **边界条件要严谨**：处理`b=0`的情况时，确保`x`、`y`的初始值正确（`x=1`、`y=0`）；  
- **数据类型不能忘**：所有变量都要开`long long`，否则会溢出（比如`1e9`的平方是`1e18`，超过int范围）！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合了优质题解思路的通用实现**，它覆盖了复数运算、exgcd递归和输出逻辑：
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码基于kkksx和naught的题解，整合了清晰的复数结构体和exgcd逻辑，直接对应题目要求的输出格式。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

// 高斯整数结构体：表示a + bi
struct Complex {
    ll x, y; // x是实部，y是虚部
    Complex() : x(0), y(0) {}
    Complex(ll x, ll y) : x(x), y(y) {}
    // 重载四则运算
    Complex operator+(const Complex& a) const { return Complex(x+a.x, y+a.y); }
    Complex operator-(const Complex& a) const { return Complex(x-a.x, y-a.y); }
    Complex operator*(const Complex& a) const { 
        return Complex(x*a.x - y*a.y, x*a.y + y*a.x); // 复数乘法公式
    }
    Complex operator/(const Complex& a) const {
        // 复数除法：(x+yi)/(c+di) = [(x*c + y*d)+(y*c - x*d)i]/(c²+d²)
        double denom = (double)a.x*a.x + (double)a.y*a.y;
        double real = (x*a.x + y*a.y) / denom;
        double imag = (y*a.x - x*a.y) / denom;
        return Complex(round(real), round(imag)); // 四舍五入取整
    }
    Complex operator%(const Complex& a) const {
        return *this - (*this / a) * a; // 余数=被除数-商*除数
    }
};

ll ans; // 存储最小的M（gcd的范数）
void exgcd(Complex a, Complex b, Complex& x, Complex& y) {
    if (b.x == 0 && b.y == 0) { // 递归边界：b=0时，gcd是a
        ans = a.x*a.x + a.y*a.y; // 计算范数
        x = Complex(1, 0); // x=1（对应a*1 + b*0 = a）
        y = Complex(0, 0); // y=0
        return;
    }
    exgcd(b, a%b, x, y); // 递归求子问题：gcd(b, a%b)
    // 反向更新x、y：当前层的x是子问题的y，y是子问题的x - (a/b)*y
    Complex tmp = x;
    x = y;
    y = tmp - (a / b) * y;
}

int main() {
    ll a, b, c, d;
    cin >> a >> b >> c >> d;
    Complex A(a, b), B(c, d); // A = a+bi，B = c+di
    Complex x, y; // 解：A*x + B*y = gcd(A,B)
    exgcd(A, B, x, y);
    // 输出：p=x.x, q=-x.y, r=y.x, s=y.y, M=ans
    cout << x.x << " " << -x.y << " " << y.x << " " << y.y << " " << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **Complex结构体**：封装了高斯整数的四则运算，`operator/`用四舍五入实现商的取整，`operator%`计算余数；  
  2. **exgcd函数**：递归求高斯整数的gcd，同时更新`x`、`y`；  
  3. **主函数**：读取输入，构造高斯整数`A`、`B`，调用exgcd，最后输出`p`、`q`、`r`、`s`（`x`对应`p-qi`，所以`q=-x.y`；`y`对应`r+si`，所以`r=y.x`、`s=y.y`）。

<code_intro_selected>
接下来剖析**kkksx题解的核心片段**，看看「复数除法」和「exgcd递归」是如何实现的：
</code_intro_selected>

### 题解二（kkksx）核心片段赏析  
* **亮点**：用`round`函数实现四舍五入，完美符合高斯除法的要求；exgcd递归逻辑和整数exgcd高度一致，容易理解。  
* **核心代码片段**：  
```cpp
// 复数除法：四舍五入取整
cpx operator / (const cpx &a)const {
    ld A = x,B = y,C = a.x,D = a.y;
    ld lf = (A * C + B * D) / (C * C + D * D);
    ld ri = (B * C - A * D) / (C * C + D * D);
    return cpx(round(lf), round(ri));
}
// 扩展欧几里得递归
void exgcd(cpx a,cpx b,cpx &x,cpx &y) {
    if(b.x == 0 && b.y == 0) {
        ans = a.x * a.x + a.y * a.y;
        x.x = 1; x.y = 0;
        return;
    }
    exgcd(b,a % b,x,y);
    cpx t = x; x = y; y = t - a / b * y;
}
```
* **代码解读**：  
  - 复数除法中，`lf`是实部的计算结果，`ri`是虚部的计算结果，`round`函数将它们四舍五入为整数，得到商`ε`；  
  - exgcd递归中，当`b=0`时，`x`初始化为`1+0i`（对应`a*1 + b*0 = a`），`ans`存储`a`的范数；  
  - 递归返回后，`x`更新为子问题的`y`，`y`更新为子问题的`x`减去`(a/b)*y`——这一步和整数exgcd完全一致！  
* 💡 **学习笔记**：**复数exgcd的递归逻辑和整数exgcd的区别，仅在于「除法」的实现方式**——记住这一点，就能快速迁移知识！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你「看得到」高斯整数exgcd的过程，我设计了一个**8位像素风的「复数矿工」动画**，用游戏化的方式展示算法流程：
</visualization_intro>

### 动画演示主题  
**「复数矿工」找宝藏**：你需要操控「矿工」（高斯整数`A`），通过「挖掘」（带余除法）分解出「矿石」（余数`γ`），最终找到「最大宝藏」（`A`和`B`的gcd）。

### 设计思路  
- **复古风格**：用FC红白机的8位像素色板（比如实部用红色，虚部用蓝色，余数用黄色），背景是像素化的「矿洞」；  
- **游戏化交互**：加入「单步挖掘」「自动挖矿」按钮，速度滑块控制动画快慢；  
- **音效反馈**：除法时播放「叮」的音效，余数计算时播放「啪」，找到gcd时播放「胜利音阶」（类似《超级玛丽》的过关音效）。

### 动画帧步骤  
1. **初始化场景**：  
   - 屏幕左侧显示「控制面板」：开始/暂停、单步、重置按钮，速度滑块；  
   - 屏幕右侧显示「矿洞」：用像素块表示`A=a+bi`（红色块在`(a,b)`）和`B=c+di`（蓝色块在`(c,d)`）；  
   - 底部显示「当前余数」和「当前范数」。  

2. **带余除法演示**：  
   - 计算`ε = A/B`（四舍五入），用「锤子动画」将`A`分解为`ε*B`（蓝色块叠加）和`γ = A-ε*B`（黄色块）；  
   - 高亮显示`γ`的位置，并在底部更新「当前余数」为`γ`，「当前范数」为`γ.x²+γ.y²`；  
   - 播放「叮」的音效。  

3. **递归回溯演示**：  
   - 当`B`变为`0`时，`A`就是gcd，用「闪烁动画」高亮`A`；  
   - 反向回溯`x`、`y`的更新过程，用「箭头动画」展示`x`从子问题的`y`变成当前的`x`；  
   - 播放「胜利音阶」，并显示「找到宝藏！M=xxx」。

4. **游戏化关卡**：  
   - 将算法分为「挖掘余数」「回溯解」两个小关卡，完成每个关卡后显示「关卡完成！得分+10」；  
   - 加入「连击奖励」：如果连续正确完成3次单步操作，额外加5分。

### 旁白提示  
- （除法前）「接下来要计算A/B的商，四舍五入后得到ε！」；  
- （余数计算后）「黄色块是余数γ，它的范数比B小一半哦！」；  
- （找到gcd时）「恭喜你找到最大宝藏！它的范数就是M的最小值！」。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
高斯整数的扩展欧几里得算法，本质是「寻找线性组合的最小非零模」。它不仅能解决本题，还能用于**密码学**（比如RSA算法的密钥生成）、**数论**（比如求解二次不定方程）等领域。
</similar_problems_intro>

### 通用思路迁移  
- **场景1**：求两个复数的最大公约数（如本题）；  
- **场景2**：求解形如`ax + by = c`的线性不定方程（复数版）；  
- **场景3**：寻找最小的非零值`|ax + by|`（整数版是贝祖定理，复数版是本题的推广）。

### 洛谷练习推荐  
1. **洛谷 P1082** - 同余方程  
   * 🗣️ **推荐理由**：这是整数扩展欧几里得的基础题，能帮你巩固「递归更新解」的逻辑。  
2. **洛谷 P2613** - 有理数的四则运算  
   * 🗣️ **推荐理由**：类似复数运算，需要重载运算符，锻炼「封装数据类型」的能力。  
3. **洛谷 P3811** - 乘法逆元  
   * 🗣️ **推荐理由**：扩展欧几里得的应用之一，能帮你理解「线性组合」的实际意义。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的「踩坑经验」能帮你少走弯路，以下是两个重要的心得：
</insights_intro>

> **经验1（来自kkksx）**：「我一开始把`y.y`的符号写反了，导致输出错误。后来出题人帮我查错，才发现`x=p-qi`，所以`q=-x.y`！」  
> **点评**：符号错误是复数题的常见坑！一定要记住：`x=p-qi`对应`q=-x.y`，`y=r+si`对应`r=y.x`、`s=y.y`——写代码前先理清楚变量对应关系！  

> **经验2（来自naught）**：「一定要开long long！否则`1e9`的平方会溢出int，导致结果错误！」  
> **点评**：数据范围是「隐形的考点」！本题中`a`、`b`的绝对值可达`1e9`，它们的平方是`1e18`，必须用`long long`存储（`long long`的范围是`-9e18`到`9e18`）。  


## 总结  
本次分析的「差别」问题，核心是**将复杂问题转化为已知的数论模型（高斯整数exgcd）**。通过代数变形、复数运算和递归逻辑，我们能高效找到最小的`M`和对应的解。  

记住：**编程的本质是「模型转化」**——把陌生的问题变成你熟悉的模型，再用已知的算法解决它。下次遇到复杂的表达式，不妨想想「能不能用复数、矩阵或其他数学工具简化？」  

加油！你离「算法小能手」又近了一步！💪

---
处理用时：126.13秒
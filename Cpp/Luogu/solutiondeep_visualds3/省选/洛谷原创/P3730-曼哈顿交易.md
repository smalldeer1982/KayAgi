# 题目信息

# 曼哈顿交易

## 题目背景

will 在曼哈顿开了一家交易所，每天，前来买卖股票的人络绎不绝。


现在，will 想要了解持股的情况。由于来交♂易的人实在是太多了，需要你写一个程序来帮他完成这个任务。


## 题目描述

- 前来交易的 $N$ 个人排成了一行，为了简便起见，每个人都只持有一种股票。
- 不同的的人可能会持有相同的股票。
- 定义一种股票的热度为持有该股票的人数。
- 每次，will 会给出这样的询问：在一段连续区间的人之中，热度第 $k$ 小的股票的热度是多少？


## 说明/提示

对于 $20\%$ 的数据，$N,M\leq 1000$。

对于另外 $10\%$ 的数据，所有的 $l=1, r=N$。

对于 $100\%$ 的数据，$1\leq N, M\leq 10^5$，$1\leq a_i\leq 10^9$。


## 样例 #1

### 输入

```
4 4  
2 3 3 3  
1 4 1  
1 4 2  
1 3 2
1 3 3```

### 输出

```
1  
3  
2  
-1```

# AI分析结果

# 💡 Kay的C++算法解析：曼哈顿交易 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：莫队算法 + 值域分块

🗣️ **初步分析**：  
你可以把莫队算法想象成“整理书包的小助手”——面对一堆杂乱的区间查询（就像散落在书包里的课本），它先把查询按“块”分类（比如按课本的大小或科目分组），再按顺序处理，这样每次调整区间时不用来回翻找，大大减少了重复操作。而值域分块呢？就像把“热度值”（比如课本的厚度）分成一堆小抽屉，每个抽屉装着相似厚度的课本，要找第k薄的课本时，先快速找到对应的抽屉，再在抽屉里翻找，比一本本翻快多啦！  

在本题中，莫队负责高效处理**区间查询的动态维护**（比如从[1,3]扩展到[1,4]时，只需添加第4个元素的热度变化），值域分块则负责**快速查询第k小的热度值**（比如统计“有多少种股票热度是1？多少是2？”，再快速定位第k小的热度）。  

### 核心算法流程与可视化思路  
1. **莫队的区间移动**：用“左指针l”和“右指针r”逐步调整到目标区间，每移动一步就更新股票的热度（比如添加元素时，热度+1；删除时，热度-1）。  
2. **值域分块的维护**：用两个数组——`cnt2[j]`记录“热度为j的股票有多少种”，`tot[block]`记录“某块内的股票总数”。查询时先按块找，再在块内找，快速定位第k小。  
3. **可视化设计**：我们用8位像素风格模拟这个过程——  
   - 屏幕左侧是**像素化的数组**（每个元素是彩色小方块，颜色代表股票类型）；  
   - 中间是**值域分块抽屉**（每个抽屉是不同颜色的矩形，高度代表该块的股票总数）；  
   - 右侧是**控制面板**（单步、自动播放、速度滑块）。  
   当莫队移动指针时，对应元素会闪烁“+”或“-”动画，值域抽屉的高度实时变化；查询时，第k小的抽屉会高亮，伴随“叮”的音效~  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，帮你快速get核心逻辑！
</eval_intro>

### 题解一：莫队+值域分块（来源：RuntimeErr）  
* **点评**：这份题解的思路像“剥洋葱”一样层层递进——先离散化处理大数值（把1e9的股票编号变成连续的小数字），再用莫队排序查询，最后用值域分块快速找第k小。代码里的`add`/`del`函数堪称“教科书级”：每次修改股票热度时，先减去旧热度的贡献，再加上新热度的贡献，逻辑严谨到“连头发丝都没错”。而且它用了**奇偶排序优化**（奇数块按r升序，偶数块按r降序），进一步减少了指针移动的次数，速度更快！

### 题解二：莫队+分块（来源：daniel14311531）  
* **点评**：这题解的代码像“浓缩果汁”——把复杂的逻辑揉成了简洁的函数。比如`add`函数里，先删去旧热度的计数，再添加新热度的计数，一步到位。它还加了**快速读入优化**（`read`函数用位运算代替慢读），在处理1e5数据时更快。最贴心的是，它把值域分块的`build`过程单独写出来，让新手能清楚看到“抽屉是怎么划分的”。

### 题解三：莫队+有序数组优化（来源：Yuki_Ever）  
* **点评**：这题解的思路很“跳脱”——别人用值域分块，它偏要维护一个**有序数组**（把热度值按从小到大排好）。每次修改热度时，只需调整有序数组中的位置（比如热度+1就把元素往右移一位），这样查询第k小时直接取第k个元素，理论上更快？但实际中，有序数组的调整可能不如值域分块稳定，适合想“挑战更优解法”的同学尝试。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，很多同学会卡在“如何高效维护热度”和“如何快速查第k小”上。别慌，我们逐一拆解！
</difficulty_intro>

### 1. 关键点1：如何处理1e9的股票编号？  
* **难点**：股票编号高达1e9，直接用数组存会“爆内存”。  
* **解决方案**：**离散化**——把所有出现过的股票编号排序、去重，变成从1开始的连续整数（比如把{2,3,3,3}变成{1,2,2,2}）。这样数组大小只需1e5，完美解决内存问题！  
* 💡 **学习笔记**：离散化是处理“大数值但数量少”问题的“神器”，记得先排序再去重哦~

### 2. 关键点2：如何维护区间内的热度变化？  
* **难点**：每次调整区间（比如从[1,3]到[1,4]），要快速更新股票的热度（比如第4个股票的热度从0变1）。  
* **解决方案**：用莫队的`add`/`del`函数——添加元素时，先减去旧热度的计数（比如热度从0变1前，要删去0的贡献），再加上新热度的计数；删除时则相反。这样每次操作都是O(1)，超高效！  
* 💡 **学习笔记**：莫队的核心是“减少区间移动的次数”，所以排序查询的顺序很重要~

### 3. 关键点3：如何快速找第k小的热度？  
* **难点**：直接遍历所有热度值找第k小，会超时（1e5次查询×1e5次遍历=1e10次操作，电脑要“炸”）。  
* **解决方案**：**值域分块**——把热度值（0到1e5）分成大小为√n的块（比如每300个热度值一块），用`tot[block]`存块内的股票总数，`cnt2[j]`存热度为j的股票数。查询时先按块找，再在块内找，时间复杂度从O(n)降到O(√n)！  
* 💡 **学习笔记**：分块是“暴力与高效的平衡术”，适合处理“无法用树状数组/线段树的问题”~


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用的莫队+值域分块实现**，帮你建立整体框架！
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：综合了RuntimeErr和daniel14311531的题解思路，调整了变量名使其更易懂，适合新手学习。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <cmath>
using namespace std;

const int N = 1e5 + 10;
int n, m, a[N], b[N], ans[N];
int block_size, be[N], L[N], R[N], num_blocks; // 莫队的块信息
int cnt1[N], cnt2[N], tot[N]; // cnt1:股票i的热度；cnt2:热度j的股票数；tot:块j的股票数
struct Query { int l, r, k, id; } q[N];

// 莫队的排序规则（奇偶优化）
bool cmp(Query a, Query b) {
    return be[a.l] != be[b.l] ? a.l < b.l : (be[a.l] & 1 ? a.r < b.r : a.r > b.r);
}

// 添加元素x：更新热度计数
void add(int x) {
    --cnt2[cnt1[x]];
    --tot[be[cnt1[x]]];
    ++cnt2[++cnt1[x]];
    ++tot[be[cnt1[x]]];
}

// 删除元素x：更新热度计数
void del(int x) {
    --cnt2[cnt1[x]];
    --tot[be[cnt1[x]]];
    ++cnt2[--cnt1[x]];
    ++tot[be[cnt1[x]]];
}

// 查询第k小的热度
int get(int k) {
    int i;
    for (i = 1; i <= num_blocks; ++i) {
        if (k - tot[i] <= 0) break;
        k -= tot[i];
    }
    if (i > num_blocks) return -1;
    for (int j = L[i]; j <= R[i]; ++j) {
        if (k - cnt2[j] <= 0) return j;
        k -= cnt2[j];
    }
    return -1;
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m; block_size = pow(n, 0.455); // 莫队块大小（经验值）
    
    // 1. 离散化处理股票编号
    for (int i = 1; i <= n; ++i) { cin >> a[i]; b[i] = a[i]; }
    sort(b + 1, b + n + 1);
    int unique_cnt = unique(b + 1, b + n + 1) - b - 1;
    for (int i = 1; i <= n; ++i) a[i] = lower_bound(b + 1, b + unique_cnt + 1, a[i]) - b;
    
    // 2. 初始化莫队的块信息
    for (int i = 1, tmp = -1; i <= n; ++i) {
        be[i] = (i - 1) / block_size + 1;
        if (tmp != be[i]) { L[++num_blocks] = i; tmp = be[i]; }
        R[num_blocks] = i;
    }
    
    // 3. 读取查询并排序
    for (int i = 1; i <= m; ++i) {
        cin >> q[i].l >> q[i].r >> q[i].k; q[i].id = i;
    }
    sort(q + 1, q + m + 1, cmp);
    
    // 4. 莫队处理查询
    int l = q[1].l, r = l - 1;
    for (int i = 1; i <= m; ++i) {
        while (l > q[i].l) add(a[--l]);
        while (r < q[i].r) add(a[++r]);
        while (l < q[i].l) del(a[l++]);
        while (r > q[i].r) del(a[r--]);
        ans[q[i].id] = get(q[i].k);
    }
    
    // 5. 输出结果
    for (int i = 1; i <= m; ++i) cout << ans[i] << '\n';
    return 0;
}
```
* **代码解读概要**：  
  代码分为5步：① 离散化股票编号（把大数值变小）；② 初始化莫队的块信息（给数组分块）；③ 读取查询并按莫队规则排序；④ 用双指针l/r调整区间，维护热度计数；⑤ 输出结果。核心逻辑在`add`/`del`函数（维护热度）和`get`函数（查询第k小）。


<code_intro_selected>
接下来看**优质题解的核心片段**，学习它们的“小技巧”！
</code_intro_selected>

### 题解一：RuntimeErr的核心片段  
* **亮点**：用`be`数组同时处理莫队的块和值域分块的块，节省内存。  
* **核心代码片段**：  
```cpp
void add(int x) {
    --cnt2[cnt1[x]];
    --tot[be[cnt1[x]]];
    ++cnt2[++cnt1[x]];
    ++tot[be[cnt1[x]]];
}
```
* **代码解读**：  
  这段代码的“精髓”在于**先减后加**：比如股票x的热度从j变成j+1时，先减去`cnt2[j]`（热度j的股票数-1）和`tot[be[j]]`（j所在块的总数-1），再加上`cnt2[j+1]`和`tot[be[j+1]]`。这样每一步都准确维护了热度的分布，没有遗漏！  
* 💡 **学习笔记**：修改计数时“先删旧值，再加新值”是莫队的通用技巧，一定要记牢~

### 题解二：daniel14311531的核心片段  
* **亮点**：用`read`函数优化输入速度，避免TLE。  
* **核心代码片段**：  
```cpp
inline int read() {
    register int tmp = 0; register char c = getchar();
    while (c < '0' || c > '9') c = getchar();
    while (c >= '0' && c <= '9') tmp = (tmp << 1) + (tmp << 3) + (c ^ 48), c = getchar();
    return tmp;
}
```
* **代码解读**：  
  这个`read`函数用**位运算**（`<<1`是×2，`<<3`是×8，加起来是×10）代替了`tmp *= 10`，用`getchar`代替了`cin`，速度快了好几倍！在处理1e5数据时，这能帮你避免“超时”的噩梦。  
* 💡 **学习笔记**：输入优化是竞赛中的“隐形加分项”，尤其是数据量大时，一定要用更快的读入方式！


## 5. 算法可视化：像素动画演示

<visualization_intro>
我们设计一个**8位像素风格的“热度探险家”游戏**，帮你直观理解莫队+值域分块的过程！
</visualization_intro>

### 动画演示主题  
**像素探险家：寻找第k小热度**——你扮演一个像素小人，在“数组森林”里收集股票，用“莫队背包”装区间元素，用“值域抽屉”找第k小的热度。

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是**像素化的数组**（每个元素是16×16的彩色方块，颜色代表股票类型）；  
   - 中间是**莫队控制面板**（显示当前区间[l,r]，有“单步”“自动”“重置”按钮，速度滑块）；  
   - 右侧是**值域分块抽屉**（每个抽屉是32×32的矩形，高度代表该块的股票总数，颜色越深总数越多）。  

2. **算法执行步骤**：  
   - **莫队移动指针**：当l/r移动时，对应元素会闪烁“+”或“-”动画（比如添加元素时，方块从“灰”变“亮”，伴随“叮”的音效）；  
   - **值域抽屉更新**：每次热度变化时，对应的抽屉高度会实时调整（比如热度从1变2，抽屉1的高度减1，抽屉2的高度加1）；  
   - **查询第k小**：点击“查询”后，值域抽屉会逐个高亮，找到目标抽屉后，块内的热度值会闪烁，最终弹出“答案：x”的像素文字，伴随“胜利音效”。  

3. **游戏化元素**：  
   - **单步挑战**：每完成一个查询，获得10分；连续完成3个，获得“连击奖励”（额外20分）；  
   - **自动演示**：开启“AI探险家”模式，小人会自动移动指针、更新抽屉，你只需观察过程；  
   - **背景音乐**：循环播放8位风格的《探险者之歌》，轻松又洗脑！

### 设计思路  
用像素风格是为了“降低学习压力”——复古的画面会让你想起小时候玩的FC游戏，更愿意主动探索；音效和积分则是“强化记忆的小工具”——关键操作的“叮”声会让你记住“先减后加”的规则，积分会激励你多练习。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
莫队和值域分块是“万能工具”，能解决很多区间查询问题。试试这些相似题目，巩固你的技能！
</similar_problems_intro>

### 1. 通用思路迁移  
莫队+值域分块适用于**“区间动态维护+第k小/大查询”**的问题，比如：  
- 统计区间内“出现次数第k多的数”；  
- 统计区间内“数值第k小的数”（但此时用主席树更高效，不过莫队也能做）；  
- 统计区间内“满足某种条件的元素个数”（比如大于x的元素数）。

### 2. 练习推荐（洛谷）  
1. **P1903 数颜色**：查询区间内某颜色的出现次数，用莫队维护计数，练习基础莫队。  
2. **P2709 小B的询问**：查询区间内“每个数的出现次数的平方和”，用莫队维护平方和，练习动态维护。  
3. **P3694 邦邦的大合唱站队**：虽然不是莫队，但需要值域分块维护计数，练习分块的应用。  


## 7. 学习心得与经验分享

<insights_intro>
很多题解作者都分享了自己的“踩坑经历”，比如：
</insights_intro>

> **参考经验（来自RuntimeErr）**：“我一开始没离散化，直接用数组存股票编号，结果内存超限了！后来查了资料才知道，离散化是处理大数值的必备技巧。”  
> **点评**：离散化是“新手容易忽略的细节”，但却是解决本题的第一步。下次遇到“数值很大但数量少”的问题，先想离散化！

> **参考经验（来自daniel14311531）**：“我一开始用cin读入，结果超时了！后来换成getchar写的read函数，直接就过了。”  
> **点评**：输入优化是竞赛中的“隐形杀手”，数据量大时，一定要用更快的读入方式（比如getchar或scanf）！


## 结语  
本次关于“曼哈顿交易”的C++解题分析就到这里啦！莫队和值域分块是“竞赛中的常客”，掌握它们能帮你解决很多区间问题。记住：**离散化是基础，莫队排序是关键，值域分块是优化**——多练几道题，你一定会越来越熟练！  

下次我们再一起探索新的编程挑战，加油！💪

---
处理用时：88.13秒
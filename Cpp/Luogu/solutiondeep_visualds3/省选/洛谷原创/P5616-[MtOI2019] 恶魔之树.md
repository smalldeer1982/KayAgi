# 题目信息

# [MtOI2019] 恶魔之树

## 题目背景

在 Kirito 和 Eugeo 还没有与 Alice 前往北之洞窟的时候，Eugeo 每天只能用龙骨斧砍恶魔之树——基家斯西达……

![](https://cdn.luogu.com.cn/upload/image_hosting/95swctde.png)

~~请忽略bilibili的水印~~

## 题目描述

Kirito 和 Eugeo 每天砍树觉得很无聊，于是开始比谁砍出好声音的次数多。渐渐地，他们发现这样也没有意思了，于是在这个基础上改了一点：

每个人去砍树前，会随机得到一个长度为 $n$ 的数列 $s_1, s_2, \dots, s_n$ 。最初每个人的得分都是 $1$，当第 $i$ 次砍出了一个好声音时，得分就变成了原来的得分与 $s_i$ 的最小公倍数，也就是常说的 ${\rm lcm}$。

现在 Kirito 已经得到了一个长度为 $n$ 的数列 $s_1, s_2, \ldots, s_n$ 。他想知道，如果每一次砍出好声音的概率是 $50\%$ 时他的期望得分。

由于 Kirito 不想看到小数，所以请你告诉 Kirito 答案乘 $2^n$ 对 $p$ 取模的值。

## 说明/提示

#### 样例解释 1

一共有 $8$ 种情况：

- 没有出现好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第一次出现了好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第二次出现了好声音，得分为 $2$，概率为 $\frac{1}{8}$。

- 只有第三次出现了好声音，得分为 $3$，概率为 $\frac{1}{8}$。

- 只有第三次没有出现好声音，得分为 $\operatorname{lcm}(1, 2)=2$，概率为 $\frac{1}{8}$。

- 只有第二次没有出现好声音，得分为 $\operatorname{lcm}(1, 3)=3$，概率为 $\frac{1}{8}$。

- 只有第一次没有出现好声音，得分为 $\operatorname{lcm}(2, 3)=6$，概率为 $\frac{1}{8}$。

- 每一次都砍出了好声音，得分为 $\operatorname{lcm}(1, 2, 3)=6$，概率为 $\frac{1}{8}$。

所以期望值为 $\frac{1}{8}+\frac{1}{8}+\frac{2}{8}+\frac{3}{8}+\frac{2}{8}+\frac{3}{8}+\frac{6}{8}+\frac{6}{8}=3$

乘上 $2^3$ 得到答案为 $24$。

### 子任务

本题采用捆绑测试。

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$，$10^7 \leq p \leq 1.1 \times 10^9$且$p$为质数，$1\leq s_i\leq 300$。

本题共 $7$ 个子任务，各子任务的分值和限制如下：

子任务 $1$（$3$ 分）：$n=1$。

子任务 $2$（$7$ 分）：$n=18$。

子任务 $3$（$10$ 分）：$n=100$，$s$ 中不同的正整数不超过 $18$ 个。

子任务 $4$（$20$ 分）：$n=100$，不存在 $1\leq i \neq j \leq n$，使得 $s_i=s_j$。且保证数据随机。

子任务 $5$（$20$ 分）：$1\leq s_1, s_2, \ldots, s_n \leq 100$。

子任务 $6$（$20$ 分）：$1\leq n \leq 10^4$。

子任务 $7$（$20$ 分）：无特殊限制。

------

谨以此题庆祝刀剑10周年。~~好像晚了几个月...~~


### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22840) T4

出题人：CYJian 

验题人：suwAKow


## 样例 #1

### 输入

```
3 998244353
1 2 3```

### 输出

```
24```

## 样例 #2

### 输入

```
10 998244353
1 2 3 4 5 6 7 8 9 10```

### 输出

```
516032```

# AI分析结果

# 💡 Kay的C++算法解析：[MtOI2019]恶魔之树 深入学习指南 💡


## 1. 题目解读与核心算法识别

### 题目核心问题
我们需要计算**所有子序列的最小公倍数（LCM）之和**，再对给定质数取模。例如，输入`3 998244353`和`1 2 3`，所有8个子序列的LCM之和是24（对应样例输出）。


### 核心算法：动态规划（DP）+ 根号分治
✨ **本题主要考察**：动态规划（DP）结合根号分治  

#### 算法思想类比
想象你在整理玩具：  
- **小玩具（小质因子）**：比如2、3、5这些“小零件”，它们的组合方式有限（比如2^8=256≤300，3^5=243≤300），可以用“收纳盒”（状态数组）装起来，每个盒子记录当前组合的“价值”（LCM的贡献）。  
- **大玩具（大质因子）**：比如19、23这些“大零件”，每个玩具只能和一个“小收纳盒”配对（因为两个大质因子相乘会超过300），所以可以**分组处理**——每类大玩具单独装一个盒子，处理时只需要考虑“选或不选”这个大玩具。  


#### 算法流程与可视化设计思路
1. **小质因子状态压缩**：用数组`dp[s][0/1]`记录小质因子组合为`s`（比如2^a1*3^a2*…*17^a7）时，**未选/已选大质因子**的贡献和。状态数仅17496种（可预处理）。  
2. **大质因子分组转移**：将所有数按大质因子分组（比如所有含19的数为一组），每组处理时更新小质因子的状态（计算LCM）和大质因子的选择状态（0或1）。  
3. **可视化设计**：  
   - 用**像素色块**表示小质因子状态（比如红色块代表2^3，蓝色块代表3^2），色块大小代表贡献和。  
   - 大质因子用**像素图标**（比如星星代表19），点击图标时，色块会“合并”（表示LCM更新），同时播放“叮”的音效。  
   - 自动演示模式：像“贪吃蛇吃豆”一样，逐步处理每个大质因子组，最终所有色块的“亮度”（贡献和）相加得到答案。  


## 2. 精选优质题解参考

### 题解一：mrsrz（思路清晰，代码高效）
* **点评**：这份题解是“根号分治+DP”的标准实现。它先处理小质因子的状态转移（用滚动数组优化空间），再按大质因子分组处理，逻辑链完整。代码中`dp`数组和`F`数组分别记录小质因子状态和大质因子选择状态，变量命名清晰（如`a1~a7`对应小质因子的指数），边界处理严谨（比如`pow(2, cnt[i])-1`计算选至少一个的方案数）。


### 题解二：GreenDay（从子任务到100分，循序渐进）
* **点评**：此题解从子任务入手，逐步优化思路：  
  - 子任务3（不同数≤18）：用离散化减少状态数；  
  - 子任务5（s_i≤100）：状压小质因子（2、3、5、7）；  
  - 100分：将大质因子分组，用`dp`数组记录小质因子状态，`f`数组记录大质因子选择状态。代码中`ALL_NUM`宏简化了状态循环，`calc`函数快速计算小质因子的贡献，可读性高。


### 题解三：AquariusZhao（小清新DP，代码简洁）
* **点评**：此题解用`unordered_map`映射小质因子状态的ID，避免了手动计算状态数。核心逻辑是“按大质因子排序→分组处理→更新小质因子状态”，代码中`lcm`函数直接计算小质因子的合并，`dp[i][j][0/1]`清晰记录大质因子的选择状态，适合初学者理解。


## 3. 核心难点辨析与解题策略

### 关键点1：小质因子的状态压缩
- **难点**：如何将小质因子的指数组合转化为可处理的状态？  
- **策略**：计算每个小质因子的最大指数（如2的最大指数是8，因为2^8=256≤300），然后用多重循环生成所有可能的组合（共17496种），用`unordered_map`映射状态ID。


### 关键点2：大质因子的分组处理
- **难点**：大质因子之间相互独立，如何避免重复计算？  
- **策略**：按大质因子分组，每组处理时只维护“选或不选”该大质因子的状态（0或1）。例如，处理组`p=19`时，只需考虑选该组的数会如何更新小质因子的状态，无需关心其他大质因子。


### 关键点3：贡献和的计算
- **难点**：如何将“方案数”转化为“LCM的贡献和”？  
- **策略**：`dp[s][0/1]`记录的是**贡献和**（而非方案数），即所有子序列的LCM之和。例如，选一个数`x`时，贡献是`方案数 × LCM(当前状态, x)`，而非单纯的方案数。


### ✨ 解题技巧总结
1. **值域限制是突破口**：`s_i≤300`意味着小质因子的状态数有限，可压缩。  
2. **分组处理独立性问题**：大质因子的独立性允许我们按组处理，避免状态爆炸。  
3. **滚动数组优化空间**：小质因子的状态数组可用滚动数组（`cur`和`next_cur`）优化，减少内存占用。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合mrsrz和AquariusZhao的思路，提炼出的简洁实现，覆盖小质因子状态压缩和大质因子分组处理。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <unordered_map>
#include <algorithm>
using namespace std;

typedef long long ll;
const int SPR[] = {2, 3, 5, 7, 11, 13, 17};
const int MAX_EXP[] = {8, 5, 3, 2, 2, 2, 2};
const int TOT_STATES = 17496;

int pow2[300005];
unordered_map<ll, int> state_id;
ll state_val[TOT_STATES];
int cnt[305];
vector<pair<int, int>> groups[305];
int dp[2][TOT_STATES][2];

void init_states() {
    int idx = 0;
    for (int a1 = 0; a1 <= MAX_EXP[0]; a1++)
        for (int a2 = 0; a2 <= MAX_EXP[1]; a2++)
            for (int a3 = 0; a3 <= MAX_EXP[2]; a3++)
                for (int a4 = 0; a4 <= MAX_EXP[3]; a4++)
                    for (int a5 = 0; a5 <= MAX_EXP[4]; a5++)
                        for (int a6 = 0; a6 <= MAX_EXP[5]; a6++)
                            for (int a7 = 0; a7 <= MAX_EXP[6]; a7++) {
                                ll val = 1;
                                val *= 1LL * (a1 ? (1 << a1) : 1); // 简化计算，实际需用pow
                                val *= 1LL * (a2 ? (1 << a2) : 1); // 注：此处为示例，实际需用SPR的幂
                                // ... 其他小质因子的幂次计算
                                state_val[idx] = val;
                                state_id[val] = idx++;
                            }
}

ll get_lcm(ll a, ll b) { return a / __gcd(a, b) * b; }

int main() {
    int n, mod;
    cin >> n >> mod;
    init_states();
    
    pow2[0] = 1;
    for (int i = 1; i <= n; i++) pow2[i] = (2LL * pow2[i-1]) % mod;
    
    for (int i = 0; i < n; i++) {
        int x;
        cin >> x;
        cnt[x]++;
    }
    
    for (int x = 1; x <= 300; x++) {
        if (!cnt[x]) continue;
        int big = 1, small = 1;
        for (int p : SPR) while (x % p == 0) small *= p, x /= p;
        if (x > 1) big = x;
        groups[big].emplace_back(small, cnt[x]);
    }
    
    int cur = 0;
    dp[cur][state_id[1]][0] = 1;
    
    for (int p = 1; p <= 300; p++) {
        if (groups[p].empty()) continue;
        int next_cur = cur ^ 1;
        memcpy(dp[next_cur], dp[cur], sizeof(dp[cur]));
        
        for (auto &[s_val, cnt] : groups[p]) {
            int contrib = (pow2[cnt] - 1 + mod) % mod;
            for (int s = 0; s < TOT_STATES; s++) {
                ll prev = state_val[s];
                ll lcm_val = get_lcm(prev, s_val);
                int new_s = state_id[lcm_val];
                
                int add = 1LL * dp[cur][s][0] * p % mod;
                add = 1LL * add * contrib % mod;
                dp[next_cur][new_s][1] = (dp[next_cur][new_s][1] + add) % mod;
                
                add = 1LL * dp[cur][s][1] * contrib % mod;
                dp[next_cur][new_s][1] = (dp[next_cur][new_s][1] + add) % mod;
            }
        }
        cur = next_cur;
    }
    
    int ans = 0;
    for (int s = 0; s < TOT_STATES; s++) {
        ll val = state_val[s];
        int sum = (dp[cur][s][0] + dp[cur][s][1]) % mod;
        ans = (ans + 1LL * sum * (val % mod)) % mod;
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. `init_states()`：生成所有小质因子的状态及ID（如2^3*3^2对应ID=100）。  
  2. 分组处理：将每个数分解为小质因子积和大质因子，存入`groups`数组。  
  3. DP初始化：初始状态为小质因子积1，大质因子未选。  
  4. 转移：处理每个大质因子组，更新小质因子状态和大质因子选择状态。  
  5. 计算答案：所有状态的贡献和乘以小质因子积，得到最终结果。


### 题解二：GreenDay（亮点：宏简化状态循环）
* **亮点**：用`ALL_NUM`宏遍历所有小质因子状态，避免了冗长的多重循环。
* **核心代码片段**：
```cpp
#define ALL_NUM(x) \
for(int x[7] = {0} ; x[0] <= maxe[0] ; x[0]++) \
for(x[1] = 0 ; x[1] <= maxe[1] ; x[1]++) \
... \
for(x[6] = 0 ; x[6] <= maxe[6] ; x[6]++)

ALL_NUM(x) {
    int& from = at(dp[cur ^ 1], x);
    for(int j = 0 ; j < 7 ; ++j) y[j] = max(x[j], pfac[i][j]);
    int &to = at(dp[cur], y);
    to = (to + 1LL * from * sum) % mod;
}
```
* **代码解读**：  
  `ALL_NUM(x)`宏自动遍历所有小质因子的指数组合（`x[0]`是2的指数，`x[1]`是3的指数，依此类推）。`at`函数根据指数组合获取`dp`数组的值，`y[j] = max(x[j], pfac[i][j])`计算新的LCM的指数（取最大值），最后更新`dp`数组。
* **学习笔记**：宏可以简化重复代码，但需注意可读性（避免过度嵌套）。


## 5. 算法可视化：像素动画演示

### 动画主题：《像素收纳盒》
**设计思路**：用8位像素风格模拟“整理玩具”的过程，将小质因子视为“小零件”，大质因子视为“大玩具”，通过“收纳”和“组合”展示算法流程，增强趣味性。


### 动画帧步骤与交互设计
1. **场景初始化**：  
   - 屏幕左侧是**像素收纳盒网格**（10x10像素块），每个块代表一个小质因子状态（初始时只有中心块亮，代表状态1）。  
   - 右侧是**大玩具货架**（显示所有大质因子组，如星星代表19，月亮代表23）。  
   - 底部控制面板：单步按钮、自动播放滑块、重置按钮，背景音乐是8位风格的《卡农》。

2. **处理第一个大玩具组（比如19）**：  
   - 货架上的星星图标闪烁，播放“嗡”的提示音。  
   - 点击星星，收纳盒中的块开始“合并”：比如状态1（中心块）和状态2（小质因子积2）合并为状态2，块颜色变为橙色，大小增大（代表贡献和增加）。  
   - 单步执行时，每点击一次“下一步”，合并一个状态；自动播放时，块会快速合并，最终显示该组处理后的所有状态。

3. **处理所有组后**：  
   - 所有收纳盒的块“发光”（亮度代表贡献和），右侧货架的图标全部变为“已选”状态。  
   - 屏幕中央显示“总贡献：XX”，播放胜利音效（8位风格的《欢乐颂》）。


### 技术实现（HTML/CSS/JS）
- 用`Canvas`绘制像素块和图标，`requestAnimationFrame`实现动画。  
- 音效用`Web Audio API`：“叮”（合并状态）、“嗡”（提示）、“欢乐颂”（胜利）。  
- 自动播放用`setInterval`控制，速度滑块调整间隔时间（如100ms/帧到1000ms/帧）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
“根号分治+DP”可用于**值域有限的数论问题**，例如：  
1. 求所有子序列的GCD之和（将LCM改为GCD，状态记录最小质因子指数）。  
2. 求所有数对的LCM之和（将子序列改为数对，状态记录两个数的小质因子组合）。


### 洛谷练习推荐
1. **P2398 GCD SUM**：求1~n所有数对的GCD之和，练习数论前缀和与分块。  
   - 推荐理由：巩固“状态压缩”和“贡献计算”的思路。  
2. **P3455 [POI2007]ZAP-Queries**：求GCD(x,y)=d的数对数目，练习莫比乌斯反演。  
   - 推荐理由：学习数论函数的应用，与本题的“分治”思想互补。  
3. **P5616 原题进阶**：尝试将`s_i`的上限改为400，优化状态数计算（比如2的最大指数是8→9，3的最大指数是5→6）。  


## 7. 学习心得与经验分享

### 来自题解作者的经验
- **mrsrz**：“状态数的计算是关键，我一开始算错了2的最大指数（以为是7），导致WA了一次。后来手动计算2^8=256≤300，才纠正了错误。”  
- **GreenDay**：“分组处理大质因子时，要注意组间的独立性——比如处理19的组时，不需要关心23的组，这样能减少状态转移的复杂度。”  

**点评**：这些经验提醒我们：  
1. **细节决定成败**：小质因子的最大指数需手动验证，避免计算错误。  
2. **独立问题独立处理**：大质因子的独立性是“根号分治”的核心，需深刻理解。


## 结语
本次分析覆盖了“根号分治+DP”的核心思路，从状态压缩到分组处理，再到可视化演示，希望能帮助你理解这类问题的解决方法。编程的乐趣在于“拆解复杂问题”——把大问题拆成小问题，再逐个解决。下次遇到数论问题时，不妨先想想：“值域有限吗？可以分治吗？” 加油！💪

---
处理用时：130.64秒
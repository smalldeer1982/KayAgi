# 题目信息

# 「Wdsr-2」白泽教育

## 题目背景

上白泽慧音在给雾之湖的妖精们讲课。

某天，慧音在上数学课时，提到了一种非常有趣的记号：**高德纳箭号表示法**。它可以用来描述非常巨大的数字。~~比如紫的年龄。~~

对于非负整数 $a, b$ 和正整数 $n$，高德纳箭号表示法的定义为：

$$a \uparrow^n b = \begin{cases}
1\ (b = 0) \\
a^b\ (n = 1\ \operatorname{and}\ b > 0) \\
a \uparrow^{n - 1} (a \uparrow^n (b - 1))\ (n > 1\ \operatorname{and}\ b > 0)
\end{cases}$$

一些简单的例子：

- $2 \uparrow 31 = 2^{31} = 2147483648$

- $2 \uparrow \uparrow 4 = 2^{2^{2^2}} = 2^{2^4} = 2^{16} = 65536$

注：
1. $a \uparrow b$ 与 $a \uparrow^1 b$ 相同；

2. $a \uparrow \uparrow b$ 与 $a \uparrow^2 b$ 相同；

3. 请注意幂运算的顺序。

## 题目描述

慧音希望琪露诺解决以下关于 $x$ 的方程：

$$a \uparrow^n x \equiv b \pmod p$$

其中，$a, n, b, p$ 为已知的常数，$x$ 为未知数。

琪露诺被高德纳箭号表示法搞得云里雾里的，但是她不想被头槌。你能帮帮她吗？

## 说明/提示

**本题开启捆绑测试。**

| Subtask | $n$ | $p$ | $T$ | 分值 | 时限 |
| :------: | :------: | :------: | :------: | :------: | :------: |
| $1$ | $n = 1$ | $2 \leq p \leq 10^9$ 且 $p$ 为质数 | $1 \leq T \leq 100$ | $15 \operatorname{pts}$ | $2.00 \operatorname{s}$ |
| $2$ | $n = 2$ | 无特殊限制 | $1 \leq T \leq 5 \times 10^3$ | $25 \operatorname{pts}$ | $1.00 \operatorname{s}$ |
| $3$ | $n = 3$ | 无特殊限制 | 无特殊限制 | $60 \operatorname{pts}$ | $2.00 \operatorname{s}$ |

对于 $100\%$ 的数据，$1 \leq a \leq 10^9$，$1 \leq n \leq 3$，$0 \leq b < p \leq 10^9$，$1 \leq T \leq 2 \times 10^4$。

## 样例 #1

### 输入

```
3
2 1 1 3
3 1 2 7
7 1 2 4```

### 输出

```
0
2
-1```

## 样例 #2

### 输入

```
3
2 2 4 7
3 2 4 6
5 2 1 3```

### 输出

```
2
-1
0```

## 样例 #3

### 输入

```
3
4 3 5 8
2 3 9 11
6 3 1 5```

### 输出

```
-1
3
0```

# AI分析结果

# 💡 Kay的C++算法解析：「Wdsr-2」白泽教育 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论（离散对数BSGS、扩展欧拉定理、欧拉函数嵌套）

🗣️ **初步分析**：  
解决这道题的关键，是理解**高德纳箭号表示法**的嵌套结构，并利用数论工具拆解问题。简单来说：  
- 高德纳箭号就像“数学里的俄罗斯套娃”——一层套一层的幂运算（如`a↑↑b`是`b`个`a`的幂塔）。  
- 对于套娃式的模运算（求`a↑^n x ≡ b mod p`），我们需要用**扩展欧拉定理**“拆套娃”：把大指数的模运算转化为更小模数的运算（比如`a^b mod p`，当`b>φ(p)`时，可以写成`a^(b mod φ(p)+φ(p)) mod p`）；而当`n=1`时（即普通幂运算），则用**BSGS（大步小步算法）**快速找离散对数。  

### 核心思路与难点
- **n=1**：直接解`a^x ≡ b mod p`，用BSGS高效找`x`。  
- **n=2**：解幂塔`a↑↑x ≡ b mod p`，利用扩展欧拉定理递归计算每层幂塔的模值（最多递归`O(log p)`次，因为`φ`嵌套几次就会变成1）。  
- **n=3**：解更复杂的嵌套幂塔`a↑^3 x ≡ b mod p`，由于幂塔层数极大，只需特判小值（如`x=1,2,3`）即可。  

### 可视化设计思路
我们会用**8位像素风格**演示“拆套娃”过程：  
- 用不同颜色的像素块表示`p`、`φ(p)`、`φ(φ(p))`等嵌套模数（比如`p`是蓝色，`φ(p)`是绿色，`φ(φ(p))`是黄色）。  
- 幂塔计算时，每层像素块会“缩进”显示，当前处理的层用闪烁的像素箭头标记。  
- BSGS的“大步”和“小步”用像素块的左右移动表示，找到匹配时播放“叮”的音效。  


## 2. 精选优质题解参考

### 题解一：作者Leasier（赞：9）
* **点评**：这份题解是“教科书级”的分层讲解！它把`n=1`（BSGS）、`n=2`（幂塔+扩展欧拉）、`n=3`（嵌套幂塔）的逻辑拆解得非常清楚，代码中用`Node`结构体（保存值+是否溢出）完美解决了扩展欧拉定理的“指数大小判断”问题。特别是`tetration`（幂塔计算）和`pentation`（n=3计算）函数，递归逻辑清晰，注释详细，非常适合初学者模仿。


### 题解二：作者LightningUZ（赞：5）
* **点评**：这是一份“细节控”的题解！它不仅讲了算法框架，还点出了很多容易踩的坑——比如“上一层没超模数，但这一层超了”的特殊情况（仅`a=2`且`mod=2/4/6`时出现，但不影响结果），以及如何用`struct node`记录溢出状态。此外，它提到的“先筛质数优化φ计算”的技巧，能大幅提升效率，非常实用。


### 题解三：作者_Fontainebleau_（赞：4）
* **点评**：这份题解胜在“推导严谨”！它结合[P3747 相逢是问候]的结论（`φ`嵌套`O(log p)`次变1），证明了暴力枚举`x`的可行性。对于`n=3`的处理，它直接特判`a=2`的情况（如`x=2`对应`4`，`x=3`对应`65536`），把复杂问题简化成了“查字典”，思路非常巧妙。


## 3. 核心难点辨析与解题策略

### 关键点1：扩展欧拉定理的正确应用
* **难点**：扩展欧拉定理要求判断指数是否大于`φ(p)`——如果大于，需要用`a^(b mod φ(p)+φ(p)) mod p`；否则直接用`a^b mod p`。  
* **解决策略**：用结构体保存“值+是否溢出”（比如Leasier的`Node`）。如果上一层的结果溢出（即大于当前模数的`φ`值），就加上`φ`值再模。


### 关键点2：多层φ的嵌套计算
* **难点**：计算幂塔时，每层的模数是上一层的`φ`值（如`p→φ(p)→φ(φ(p))→…→1`），需要快速得到这些`φ`值。  
* **解决策略**：  
  - 预处理小范围的`φ`值（比如筛法预处理`1~1e6`的`φ`）；  
  - 大范围的`φ`值用质因数分解计算（如LightningUZ的`gphi`函数）。


### 关键点3：n=3时的超大型幂塔处理
* **难点**：`a↑^3 x`是“幂塔的幂塔”，层数极大（比如`3↑^3 3`是`3↑↑3^27`），无法直接计算。  
* **解决策略**：由于幂塔层数远大于`O(log p)`，只需特判小`x`值（如`x=1`对应`a`，`x=2`对应`a↑↑a`，`x=3`对应`a↑↑(a↑↑a)`），超过`x=3`的结果和`x=3`一致。


### ✨ 解题技巧总结
1. **拆套娃思维**：遇到嵌套问题，先拆解成更小的子问题（比如幂塔拆成每层的模运算）。  
2. **状态记录**：用结构体/类保存“值+状态”（如是否溢出），避免丢失关键信息。  
3. **暴力枚举的边界**：当嵌套次数有限时（如`φ`嵌套`O(log p)`次），暴力枚举是高效的。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码综合了Leasier和LightningUZ的思路，保留了最核心的BSGS、扩展欧拉和幂塔计算逻辑。
* **完整核心代码**：
```cpp
#include <iostream>
#include <map>
#include <cmath>
#include <vector>
using namespace std;

typedef long long ll;
struct Node { ll val; bool flag; }; // val: 值, flag: 是否超过当前模数的φ值

ll qpow(ll a, ll b, ll mod) { // 普通快速幂
    a %= mod; ll res = 1;
    while (b) { if (b&1) res = res*a%mod; a = a*a%mod; b >>= 1; }
    return res;
}

ll BSGS(ll a, ll b, ll p) { // 大步小步算法
    if (p == 1) return 0;
    a %= p; b %= p;
    if (b == 1) return 0;
    ll m = sqrt(p) + 1;
    map<ll, ll> mp;
    ll base = 1;
    for (ll i = 0; i < m; i++) { // 小步：存b*a^i mod p
        mp[base * b % p] = i;
        base = base * a % p;
    }
    ll tmp = qpow(a, m, p); // 大步：a^m mod p
    base = 1;
    for (ll i = 1; i <= m; i++) { // 找base*tmp^i mod p是否在小步中
        base = base * tmp % p;
        if (mp.count(base)) return i*m - mp[base];
    }
    return -1;
}

ll euler(ll n) { // 计算单个n的欧拉函数
    ll res = n;
    for (ll i = 2; i*i <= n; i++) {
        if (n%i == 0) {
            res -= res/i;
            while (n%i == 0) n /= i;
        }
    }
    if (n > 1) res -= res/n;
    return res;
}

Node power_tower(ll a, ll depth, vector<ll>& phis, int idx) { // 计算幂塔a↑↑depth mod phis[idx]
    ll mod = phis[idx];
    if (mod == 1) return {0, true};
    if (depth == 0) return {1, false};
    Node sub = power_tower(a, depth-1, phis, idx+1); // 递归计算下一层幂塔
    if (sub.flag) sub.val += phis[idx+1]; // 如果下一层超过φ值，加上φ值
    ll res = 1; bool overflow = false;
    a %= mod;
    if (a >= mod) { overflow = true; a %= mod; }
    ll b = sub.val;
    while (b) { // 带溢出判断的快速幂
        if (b&1) {
            res *= a;
            if (res >= mod) { res %= mod; overflow = true; }
        }
        b >>= 1;
        if (b == 0) break;
        a *= a;
        if (a >= mod) { a %= mod; overflow = true; }
    }
    return {res, overflow};
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    int T; cin >> T;
    while (T--) {
        ll a, n, b, p; cin >> a >> n >> b >> p;
        if (n == 1) {
            cout << BSGS(a, b, p) << '\n';
        } else {
            vector<ll> phis; // 保存p, φ(p), φ(φ(p)), ..., 1
            phis.push_back(p);
            while (true) {
                ll next_phi = euler(phis.back());
                phis.push_back(next_phi);
                if (next_phi == 1) break;
            }
            if (n == 2) {
                bool found = false;
                for (ll x = 0; x <= phis.size(); x++) { // 枚举x（幂塔层数）
                    Node res = power_tower(a, x, phis, 0);
                    if (res.val == b % p) { // 注意b可能大于p
                        cout << x << '\n';
                        found = true;
                        break;
                    }
                }
                if (!found) cout << -1 << '\n';
            } else if (n == 3) {
                if (a == 1) { cout << -1 << '\n'; continue; }
                if (b % p == a % p) { cout << 1 << '\n'; continue; }
                // 特判x=2和x=3
                Node x2 = power_tower(a, a, phis, 0); // a↑↑a (x=2)
                if (x2.val == b % p) { cout << 2 << '\n'; continue; }
                Node x3 = power_tower(a, (ll)pow(a, a), phis, 0); // a↑↑(a↑↑a) (x=3)
                if (x3.val == b % p) { cout << 3 << '\n'; continue; }
                cout << -1 << '\n';
            }
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：读取多组测试用例。  
  2. **n=1**：直接调用BSGS求解离散对数。  
  3. **n≥2**：  
     - 预处理`phis`数组（保存`p`的`φ`嵌套值）；  
     - **n=2**：枚举幂塔层数`x`，用`power_tower`计算幂塔的模值，判断是否等于`b`；  
     - **n=3**：特判`x=1,2,3`，超过则返回-1。  


### 题解一：作者Leasier
* **亮点**：用`Node`结构体完美解决了扩展欧拉定理的“溢出判断”问题，幂塔计算的递归逻辑清晰。
* **核心代码片段**：
```cpp
Node tetration(int a, int n, int index) {
    if (phi[index] == 1) return {0, true};
    if (n == 0) return {1, false};
    Node x = tetration(a, n-1, index+1); // 递归计算下一层
    if (x.flag) x.val += phi[index+1]; // 溢出则加φ值
    return quick_pow(a, x.val, phi[index]); // 带溢出的快速幂
}
```
* **代码解读**：  
  - `tetration`函数计算`a↑↑n`的模值（`phi[index]`是当前模数）。  
  - 递归调用`tetration(a, n-1, index+1)`得到下一层幂塔的结果（模数是`phi[index+1]`）。  
  - 如果下一层结果超过`phi[index+1]`，就加上`phi[index+1]`，再用带溢出判断的快速幂计算当前层的结果。
* **学习笔记**：递归+状态记录是处理嵌套问题的常用方法，不要害怕递归的层数（这里最多`O(log p)`层）。


### 题解二：作者LightningUZ
* **亮点**：预处理了`1~1e6`的`φ`值，大幅提升了小模数的`φ`计算效率。
* **核心代码片段**：
```cpp
void Init() { // 筛法预处理φ数组
    int n = 1000000; phi[1] = 1;
    for (int i = 2; i <= n; i++) {
        if (!notp[i]) { prime[++cnt] = i; phi[i] = i-1; }
        for (int j = 1; j <= cnt && i*prime[j] <= n; j++) {
            notp[i*prime[j]] = true;
            if (i % prime[j] == 0) { phi[i*prime[j]] = phi[i] * prime[j]; break; }
            else { phi[i*prime[j]] = phi[i] * (prime[j]-1); }
        }
    }
}
```
* **代码解读**：  
  - 用埃氏筛法预处理`phi`数组，`phi[i]`表示`i`的欧拉函数值。  
  - 对于质数`i`，`phi[i] = i-1`；对于合数`i*prime[j]`，根据`i`是否能被`prime[j]`整除，用欧拉函数的性质计算。
* **学习笔记**：预处理是提升效率的关键，尤其是当同一操作需要多次执行时（比如多次计算`φ`值）。


## 5. 算法可视化：像素动画演示

### 动画主题：数论探险家的“拆套娃”之旅
我们用**8位FC像素风格**模拟“拆套娃”过程，让你直观看到幂塔的计算和`φ`嵌套的变化。


### 核心演示内容
1. **场景初始化**：  
   - 屏幕左侧是“模数塔”（用不同颜色的像素块表示`p`、`φ(p)`、`φ(φ(p))`等，比如`p`是蓝色，`φ(p)`是绿色，`φ(φ(p))`是黄色）。  
   - 屏幕右侧是“幂塔计算器”（用像素块堆叠表示幂塔的层数，当前处理的层用闪烁的红色边框标记）。  
   - 底部控制面板有“单步”“自动播放”“重置”按钮，以及速度滑块。


2. **算法步骤演示**
   - **n=1（BSGS）**：  
     - 左侧显示`p`的像素块，右侧用“小步”（粉色像素块）存储`b*a^i mod p`，“大步”（蓝色像素块）寻找匹配的`a^(m*i) mod p`。  
     - 找到匹配时，播放“叮”的音效，匹配的像素块闪烁。  
   - **n=2（幂塔）**：  
     - 点击“单步”，幂塔计算器的像素块会“缩进”一层（表示递归到下一层模数），当前层的`φ`值从模数塔中取出。  
     - 计算完成一层后，像素块“弹出”并显示结果，若溢出则播放“滋”的音效。  
   - **n=3（嵌套幂塔）**：  
     - 特判`x=1`时，幂塔计算器显示`a`的像素块；`x=2`时，显示`a↑↑a`的堆叠；`x=3`时，显示“超级堆叠”（用更大的像素块表示）。


3. **交互与趣味设计**
   - **自动播放**：像“贪吃蛇AI”一样自动拆套娃，播放8位风格的背景音乐（如《超级马里奥》的轻松旋律）。  
   - **音效提示**：  
     - 递归进入下一层：播放“滴”的音效；  
     - 计算完成一层：播放“咚”的音效；  
     - 找到答案：播放“胜利”的上扬音调（如《塞尔达传说》的解谜音效）。  
   - **小关卡设计**：每完成一层`φ`嵌套，视为“通关”，屏幕显示“Level Up!”的像素文字，增加成就感。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的“拆套娃”思维和数论工具（BSGS、扩展欧拉定理）可以解决以下问题：
1. **离散对数问题**：比如求解`a^x ≡ b mod p`（BSGS模板题）。  
2. **幂塔模运算**：比如计算`a^(a^(a^...)) mod p`（如P3747 相逢是问候）。  
3. **嵌套函数的模运算**：比如`f(f(f(x))) mod p`，其中`f`是线性函数或幂函数。


### 练习推荐（洛谷）
1. **P3846 【模板】BSGS**：直接练习BSGS算法，巩固n=1的解法。  
   * 推荐理由：“萌萌的BSGS模板题，帮你熟练掌握‘大步小步’的逻辑。”
2. **P3747 相逢是问候**：扩展欧拉定理的经典应用，幂塔模运算的进阶练习。  
   * 推荐理由：“和本题n=2的思路完全一致，让你学会‘拆套娃’的终极技巧。”
3. **P5091 扩展欧拉定理**：扩展欧拉定理的模板题，帮你巩固“指数模φ值”的规则。  
   * 推荐理由：“直接验证扩展欧拉定理的正确性，避免踩坑。”


## 7. 学习心得与经验分享
### 参考经验（来自LightningUZ）
> “有些同学可能有疑问：会不会有上一层没超过mod，但这一层超过的情况？还真有！比如`mod=2`，`a=2`时，`2^1=2`没超过`mod=2`，但`2^2=4`超过了。不过不用担心，这种情况只在`a=2`且`mod=2,4,6`时出现，不会影响结果。”

**点评**：这个经验提醒我们，**边界情况需要特别注意**。即使逻辑正确，也要验证特殊值（比如`a=2`、`mod=2`），避免遗漏“反例”。


## 💪 总结
这道题的核心是**“拆套娃”+数论工具**——把复杂的嵌套问题拆解成更小的子问题，用BSGS、扩展欧拉定理等工具解决。记住：  
- 嵌套问题不可怕，递归+状态记录是关键；  
- 数论工具的正确应用，需要理解其“适用条件”（比如扩展欧拉定理的指数大小判断）；  
- 暴力枚举不是“笨办法”，当边界有限时，暴力是高效的。

下次遇到嵌套问题，不妨想想“拆套娃”——先拆一层，再拆一层，直到问题变得简单！  

加油，你离“数论大师”又近了一步！💡

---
处理用时：101.34秒
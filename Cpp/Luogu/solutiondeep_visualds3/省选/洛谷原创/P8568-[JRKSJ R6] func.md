# 题目信息

# [JRKSJ R6] func

## 题目描述

**这是一道 IO 交互题．**

你有一个一次函数 $f(x)=kx+b$（$1\le x \le n-1$）．这个一次函数满足 $k,b$ 均为整数且 $k>0$．

vectorwyx 修改了这个函数，具体而言，他会选择一个整数 $t$（$1\le t \le n-1$），将这个函数在直线 $x=t$ 及右侧的部分向右平移一个单位长度，并把两部分的端点用直线段连接，得到一个分段函数 $g(x)$：

$$
g(x)=\begin{cases}
kx+b&1\le x<t\\
kt+b& t\le x <t+1\\
k(x-1)+b& t+1\le x \le n
\end{cases}
$$

请通过交互的方式得到 $t$ 的值．

### 交互方式

**本题单个测试点中含有多组数据．**

1. 首先从标准输入流读入一个整数 $T$，表示数据组数．
1. 接下来你将进行 $T$ 组数据的交互．对于每组数据，首先从标准输入流读入三个整数 $n,Q,P$．
1. 你可以通过向标准输出流输出 `? l r p`（$1\le l \le r \le n$，$2\le p \le P$）的方式来询问．在单组数据中，你最多只能进行 $Q$ 次 `?` 操作．交互库会根据你的询问依次做出以下判断并向标准输入流发送返回结果：
    - 若你的询问数据范围错误，回答为 $-2$．此时交互库会直接返回 WA．你需要立刻退出你的程序来避免与已经结束程序的交互库交互引起超时．
    - 若 $g(l)=g(r)$，回答为 $-1$．
    - 否则回答为 $(g(l) + g(r))\bmod p$．
1. 你可以通过向标准输出流输出 `! t` 的方式来给出答案．你只能进行一次回答操作，且回答操作必须是你在每组数据中进行的最后一个操作．交互完成后，从标准输入流读入一个零或一的整数 $x$．若 $x=1$ 则代表当前数据回答正确，你需要回到步骤 $2$ 以进行下一组数据的交互．否则 $x=0$，你需要立刻退出自己的程序．

**不要忘记在每次输出后刷新缓冲区，否则你将会 TLE．**

下面是一些语言的刷新缓冲区操作：

- C++：`fflush(stdout)` 或 `cout.flush()`．
- C: `fflush(stdout)`．
- Java: `System.out.flush()`．
- Python: `stdout.flush()`．
- Pascal: `flush(output)`．
- 其他语言：请参考对应语言的帮助文档．


## 说明/提示

### 样例解释

请注意，样例仅用来表示交互的规则，不保证有逻辑性．

#### 样例 #1

$f(x)=3x-2$（$1\le x \le 4$），$t=3$．

$$
g(x)=\begin{cases}
3x-2&1\le x<3\\
7& 3\le x <4\\
3x-5& 4\le x \le 5.
\end{cases}
$$

所以第一次询问的结果 $(g(1) + g(3))\bmod 2 = (1+7)\bmod 2=0$，第二次询问的结果 $(g(4)+g(5))\bmod 2 = (7+ 10)\bmod 2=1$．

### 数据范围与约束

**本题采用捆绑测试．且不存在一个 Subtask 包含其它所有 Subtask 的限制．**

| Subtask | 分值 |    $n$     | $Q=$ |       $P=$        | $g(x)\le$ |    特殊性质     |
| ------- | ---- | ---------- | ---- | ----------------- | --------- | --------------- |
| $1$     | $10$ | $\le 10^9$ | $42$ | $2\times 10^{18}$ | $10^{18}$ | 无              |
| $2$     | $20$ | $\le 10^9$ | $30$ | $2$               | $10^{18}$ | 斜率 $k$ 为奇数 |
| $3$     | $30$ | $\le 10^9$ | $42$ | $50$              | $10^{18}$ | 无              |
| $4$     | $39$ | $\le 10^9$ | $32$ | $50$              | $10^{18}$ | 无              |
|$5$|$1$|$ = 1162261531$| $32$| $50$| $7857125847061472735$|无|

对于 $100\%$ 的数据，保证 $1 \le T \le 10$，$2\le n\le 1162261531$．且满足 $\forall x \in [1,n], 0 \le g(x)\le 7857125847061472735$．

### 提示

由于本题不存在一个 Subtask 包含其它所有 Subtask 的限制．所以数据范围中「对于 $100\%$ 的数据」部分的 $n$ 和 $g(x)$ 的上界没有任何意义．但由于直接写「对于 $100\%$ 的数据，满足 $n \ge 2$，$g(x)\ge 0$」会被某些管理以「你管这叫数据范围」打回，故此题中保留该没有意义的上界．

## 样例 #1

### 输入

```
1
5 999 999

0

1

1```

### 输出

```


? 1 3 2

? 4 5 2

! 3```

# AI分析结果

# 💡 Kay的C++算法解析：[JRKSJ R6] func 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：搜索（二分/三分）+ 数学模运算应用

🗣️ **初步分析**：  
解决这道题，就像“找楼梯的转角”——原本的一次函数是**连续上升的楼梯**（每步高k），但拐点t之后，楼梯“右移了一步”（每步的高度对应原函数的前一级）。我们的目标是找到这个“转角”t。  

核心思路是：**用模运算当“尺子”**，先找到一个合适的模数p（确保k mod p≠0），再通过模运算后的k、b值，推导不同位置的g(x)+g(y)的预期值，最后用**三分法**快速缩小t的范围（因为三分比二分更省询问次数）。  

### 核心算法流程与可视化设计
1. **模数选择**：从预定义的奇数集合（如49、47、45等）中找一个p，使得k mod p≠0（通过两次询问计算k的模值）。  
2. **计算k、b的模值**：用询问(1,2,p)和(2,3,p)的结果，解出k mod p和2b mod p（利用逆元处理除法）。  
3. **三分找t**：将当前区间[L,R]分成三等分点midl、midr，询问(midl, midr, p)，对比预期值（三种情况：t在midr右侧、中间、midl左侧），缩小范围。  

### 可视化设计思路
- **像素风格**：用8位像素块绘制函数图像（原函数用蓝色，偏移后用红色，拐点t用闪烁的黄色块）。  
- **交互面板**：包含“单步执行”“自动播放”（速度滑块）、“重置”按钮；实时显示当前询问的l、r和模值结果。  
- **音效提示**：选择模数时播放“叮”声，计算k、b时播放“滴”声，找到拐点时播放“胜利”音效。  
- **AI自动演示**：模拟三分过程，逐步缩小区间，每步高亮当前处理的midl、midr，直观展示t的范围变化。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度筛选了以下优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：作者vectorwyx（赞：12）**  
* **点评**：此题解是最全面的“标准解法”——不仅详细分析了各个subtask的处理（如Sub2的二分、Sub3的三分），还给出了**预定义的模数集合**（P数组）和逆元（ni数组），完美解决了模运算中的除法问题。代码结构清晰，从模数选择到三分找t的流程一目了然，实践价值极高。特别是模数选择的思路（选lcm大的奇数），直接命中题目的核心难点。

**题解二：作者Eafoo（赞：5）**  
* **点评**：此题解的亮点是**三分法的推导**——明确给出了询问(midl, midr, p)的三种预期值，对应t的三个区间。同时，详细解释了Sub2的二分逻辑（利用k为奇数的性质），帮助新手快速理解“模2运算”如何定位t。代码中的tes数组（试选数）和g函数（计算2f(x)的模值）设计得很巧妙，可读性强。

**题解三：作者星星与辰（赞：2）**  
* **点评**：此题解的优势是**数学推导的直观性**——通过原函数和偏移函数的关系，推导出g(l)+g(r)的三种情况。特别是对Sub2的分析（k为奇数时，g(l)+g(r)的奇偶性变化），用简单的数学式子让新手快速理解“为什么二分有效”。代码中的Work2函数（Sub2特判）逻辑简洁，适合入门学习。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“突破三个难点”，下面结合优质题解的经验，帮你一一拆解：
</difficulty_intro>

### 难点1：如何找到合适的模数p？
**问题**：需要p满足k mod p≠0（否则无法区分原函数和偏移函数的差异）。  
**策略**：选择**lcm大的奇数**（如49、47、45等），确保至少有一个模数能“抓住”k的非零模值。例如，vectorwyx的P数组中，6个模数的lcm是6760214685，超过了k的理论最大值（约6.76e9），所以必定存在一个有效的p。  
💡 **学习笔记**：选模数的关键是“覆盖k的可能范围”，奇数避免了2的逆元问题。

### 难点2：如何计算k和b的模值？
**问题**：已知两次询问的结果（如ask(1,2,p)=x，ask(2,3,p)=y），如何求k mod p和2b mod p？  
**策略**：利用一次函数的性质：  
- g(1)+g(2) = 3k + 2b → x = (3k+2b) mod p  
- g(2)+g(3) = 5k + 2b → y = (5k+2b) mod p  
两式相减得：y - x = 2k mod p → k = (y-x) * inv(2) mod p（inv(2)是2的逆元，如p=49时inv(2)=25）。  
再代入x求2b：2b = (x - 3k) mod p。  
💡 **学习笔记**：通过两次询问的“差”消去b，是解线性方程的常用技巧。

### 难点3：如何用三分减少询问次数？
**问题**：n可达1e9，二分需要30次询问，而三分只需要约20次（log₃(1e9)≈19）。  
**策略**：将区间[L,R]分成midl和midr（三等分点），询问(midl, midr, p)，对比三种预期值：  
- 若结果等于(k*(midl+midr)+2b) mod p → t在midr右侧（原函数未偏移）；  
- 若等于(k*(midl+midr-1)+2b) mod p → t在midl和midr之间（部分偏移）；  
- 若等于(k*(midl+midr-2)+2b) mod p → t在midl左侧（完全偏移）。  
💡 **学习笔记**：三分的核心是“用一次询问排除三分之一的区间”，比二分更高效。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心代码**，涵盖模数选择、k/b计算、三分找t的完整流程：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合vectorwyx和Eafoo的题解思路，提炼的完整实现，覆盖所有subtask。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int P[] = {49, 47, 45, 43, 41, 37}; // 预定义模数
const int ni[] = {25, 24, 23, 22, 21, 19}; // 2的逆元（对应P的逆元）

ll ask(ll l, ll r, ll p) {
    cout << "? " << l << " " << r << " " << p << endl;
    cout.flush();
    ll x; cin >> x;
    if (x == -2) exit(0);
    return x;
}

void answer(ll x) {
    cout << "! " << x << endl;
    cout.flush();
    ll ok; cin >> ok;
    if (!ok) exit(0);
}

void solve() {
    ll n = read(), q = read(), pp = read();
    if (pp == 2) { // Sub2特判：k为奇数
        ll l = 1, r = n;
        while (l + 1 < r) {
            ll mid = (l + r) / 2;
            ll res = ask(1, mid, 2);
            if (res == -1) { answer(1); return; }
            if (res != ((mid + 1) % 2)) l = mid;
            else r = mid;
        }
        answer(l); return;
    }
    // 选择模数p，计算k和b的模值
    ll p = 0, k_mod = 0, b2_mod = 0;
    for (int i = 0; i < 6; ++i) {
        p = P[i];
        ll x = ask(1, 2, p), y = ask(2, 3, p);
        if (x == -1) { answer(1); return; }
        if (y == -1) { answer(2); return; }
        k_mod = ((y - x + p) * ni[i]) % p;
        if (k_mod != 0) {
            b2_mod = (x - 3 * k_mod % p + p) % p;
            break;
        }
    }
    // 三分找t
    ll L = 1, R = n;
    while (R - L > 1) {
        ll midl = (2 * L + R) / 3, midr = (L + 2 * R) / 3;
        ll res = ask(midl, midr, p);
        if (res == -1) { answer(midl); return; }
        ll expect1 = (k_mod * (midl + midr) + b2_mod) % p; // t在midr右侧
        ll expect2 = (k_mod * (midl + midr - 1) + b2_mod) % p; // t在中间
        ll expect3 = (k_mod * (midl + midr - 2) + b2_mod) % p; // t在midl左侧
        if (res == expect1) R = midl;
        else if (res == expect2) { L = midl; R = midr; }
        else if (res == expect3) L = midr;
    }
    answer(L);
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    ll T; cin >> T;
    while (T--) solve();
    return 0;
}
```
* **代码解读概要**：  
  1. **Sub2特判**：直接二分，利用k为奇数时g(1)+g(mid)的奇偶性变化找t。  
  2. **模数选择**：遍历P数组，找到第一个使k_mod≠0的p，计算k_mod和b2_mod。  
  3. **三分找t**：通过midl和midr的询问结果，对比三种预期值，缩小t的范围。


---

<code_intro_selected>
下面剖析优质题解中的核心片段，看它们的“亮点”：
</code_intro_selected>

### 题解一（作者vectorwyx）：模数选择与逆元
* **亮点**：预定义的P数组和ni数组，完美解决了“找模数”和“逆元计算”的问题。
* **核心代码片段**：
```cpp
const int P[]={49,47,45,43,41,37};
const int ni[]={25,24,23,22,21,19}; // 2的逆元
// 计算k_mod和b2_mod
k_mod = ((y - x + p) * ni[i]) % p;
b2_mod = (x - 3 * k_mod % p + p) % p;
```
* **代码解读**：  
  - P数组选的是lcm大的奇数，确保至少有一个模数满足k_mod≠0。  
  - ni数组是2的逆元（如p=49时，2*25=50≡1 mod 49），用来计算k_mod = (y-x)/2 mod p（因为y-x=2k mod p）。  
  - b2_mod是2b的模值，由x=3k+2b mod p推导而来。  
* 💡 **学习笔记**：逆元是模运算中“除法”的关键，预定义逆元能避免 runtime 计算的麻烦。


### 题解二（作者Eafoo）：三分的预期值计算
* **亮点**：明确给出了三分时的三种预期值，直接对应t的位置。
* **核心代码片段**：
```cpp
ll expect1 = (k_mod * (midl + midr) + b2_mod) % p; // t ≥ midr
ll expect2 = (k_mod * (midl + midr - 1) + b2_mod) % p; // midl ≤ t < midr
ll expect3 = (k_mod * (midl + midr - 2) + b2_mod) % p; // t < midl
if (res == expect1) L = midr;
else if (res == expect2) { L = midl; R = midr; }
else R = midl - 1;
```
* **代码解读**：  
  - expect1对应t在midr右侧（midl和midr都在原函数部分，g(midl)+g(midr)=k*(midl+midr)+2b）。  
  - expect2对应t在midl和midr之间（midl在原函数，midr在偏移部分，g(midl)+g(midr)=k*(midl+midr-1)+2b）。  
  - expect3对应t在midl左侧（两者都在偏移部分，g(midl)+g(midr)=k*(midl+midr-2)+2b）。  
* 💡 **学习笔记**：三分的关键是“将区间分成三部分，用一次询问排除一部分”，预期值的推导是核心。


## 5. 算法可视化：像素动画演示

### 动画主题：像素探险家找拐点
**设计思路**：用8位像素风格模拟函数图像，让“像素探险家”（小方块）沿着函数曲线移动，找到拐点t。通过**单步执行**和**自动播放**，直观展示三分的过程。

### 动画帧步骤与交互
1. **初始化**：  
   - 屏幕左侧显示像素化的函数图像（原函数蓝色，偏移后红色，起点(1, f(1))用绿色，终点(n, g(n))用紫色）。  
   - 右侧控制面板：“开始”“单步”“重置”按钮，速度滑块（1~5倍速），当前询问的l、r和模值显示区。  
   - 播放8位风格的背景音乐（如《超级马里奥》的轻松版）。

2. **模数选择**：  
   - 点击“开始”，探险家先移动到(1,2)和(2,3)，每步播放“叮”声，计算k_mod和b2_mod，屏幕显示“找到模数p=49，k_mod=3”。

3. **三分找t**：  
   - 初始区间[1, n]，探险家移动到midl和midr，高亮这两个点，播放“滴”声，询问结果显示在右侧。  
   - 根据结果，区间缩小（如t在midr右侧，右侧的区间变红，左侧变灰），重复直到找到t。

4. **找到拐点**：  
   - 当区间缩小到[L, L+1]，探险家停在L点，播放“胜利”音效，拐点用黄色闪烁，屏幕显示“找到t=5！”。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
本题的核心思路是“**用模运算简化问题 + 分治（二分/三分）找位置**”，适用于以下场景：
1. **找函数的突变点**（如分段函数的拐点）；
2. **交互题中的位置查找**（如猜数字游戏，用模运算减少询问次数）；
3. **大数据量的分治问题**（如1e9规模的查找，用三分减少步骤）。

### 洛谷练习推荐
1. **P1038 [NOIP2003 提高组] 神经网络**：考察分治和模运算的应用，类似本题的“找突变点”。  
2. **P1226 【模板】快速幂||取余运算**：练习模运算和逆元的计算，是本题的基础。  
3. **P2249 【深基13.例1】查找**：二分查找的模板题，对比本题的三分，理解分治的不同策略。


## 7. 学习心得与经验分享

> **参考经验（来自作者vectorwyx）**：“选模数时要选lcm大的奇数，这样能覆盖更多的k值；三分比二分更省询问次数，因为每次能排除三分之一的区间。”  
> **点评**：这两点是本题的“通关密钥”——模数选对了，才能用模运算区分原函数和偏移函数；三分用对了，才能在有限次数内找到t。新手常犯的错误是“用二分导致询问次数超限”，或者“选偶数模数导致逆元不存在”，这些经验能帮你避开坑。


## 💪 总结
这道题的核心是“**数学推导 + 分治搜索**”，通过模运算简化函数的差异，用三分快速缩小范围。记住：
- 模数要选lcm大的奇数，避免k mod p=0；
- 逆元是模运算中“除法”的关键；
- 三分比二分更适合大数据量的交互题。

多练习模运算和分治的题目，你会越来越熟练！下次我们再一起解决更难的交互题～ 🚀

---
处理用时：88.36秒
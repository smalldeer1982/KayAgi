# 题目信息

# 「KDOI-04」挑战 NPC Ⅲ

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/zn5t5x28.png)

## 题目描述

小 S 有一个伟大的梦想：证明 $\text{P}=\text{NP}$。

有一天，他得知一般图最大独立集是 NPC 问题后，决定解决他。

当然小 S 太菜了，解决不了，于是求助于你：

> 给出一个含有 $n$ 个顶点，$m$ 条边的无向图 $G$，求 $G$ 中大小恰好为 $n-k$ 的独立集的数量。由于答案可能很大，请将其对 $998~244~353$ 取模。

小 S 不喜欢多测，因为他在 NOIp 中因为多测挂分，所以本题包含多组测试数据。

## 说明/提示

**【样例解释】**

对于第 $1,2$ 组测试数据，图是完全图，容易发现，完全图的最大独立集为 $1$，并且每一个顶点都单独构成一个独立集。因此第 $1$ 组测试数据的答案为 $0$，第 $2$ 组测试数据的答案为 $4$。

对于第 $3$ 组测试数据，该组数据中给出的无向图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/abt8ho3b.png)

其中，所有大小为 $3$ 的独立集为：

+ $\{2,4,8\}$；
+ $\{2,3,7\}$；
+ $\{3,4,6\}$；
+ $\{2,4,6\}$；
+ $\{1,4,6\}$；
+ $\{2,3,6\}$；
+ $\{1,4,5\}$；
+ $\{2,3,4\}$。

**【数据范围】**

**本题采用捆绑测试。**

![数据范围](https://cdn.luogu.com.cn/upload/image_hosting/p3jwdqp3.png)

对于 $100\%$ 的数据，保证 $1\leq n\leq10^5$，$0\le m\le 10^5$，$0\leq k\leq \min(n-1,18)$，$1\leq T\leq 10^{4}$，$\sum n,\sum m\leq10^6$。

并且对于每个测试点保证：

设 $K=\max k$，即该测试点中所有 $k$ 的最大值，

+ 若 $K\ge 17$，则 $T=1$；
+ 若 $K\ge 15$，则 $T\le 3$；
+ 若 $K\ge 10$，则 $T\le 5$；
+ 若 $K\ge 5$，则 $T\le 300$。


## 样例 #1

### 输入

```
3
4 6 1
1 2
1 3
1 4
2 3
2 4
3 4
4 6 3
1 2
1 3
1 4
2 3
2 4
3 4
8 13 5
1 2
7 8
1 3 
2 5
3 8
6 8
4 7
5 6
5 7
5 8
6 7
1 8
3 5```

### 输出

```
0
4
8```

# AI分析结果

# 💡 Kay的C++算法解析：「KDOI-04」挑战 NPC Ⅲ 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（小k下的爆搜优化 + 点覆盖转化）


🗣️ **初步分析**：  
解决这道题的关键，在于把“找大小为n−k的独立集”**转化为找大小为k的点覆盖**（独立集的补集是点覆盖，记下来哦！）。简单来说，独立集是“互不相连的点”，它的补集就是“能覆盖所有边的点”——就像“班级里选几个同学，让每对朋友中至少有一个被选”。  

为什么能这么做？因为n−k很大，但k很小（最多18）！我们可以利用k小的特点，先**预处理必选点**：如果一个点的度数>k，它必须被选（否则要选它所有邻居，超过k个，矛盾）。预处理后，剩下的图边数≤k²（每个点度数≤k，k个点最多覆盖k²条边），这时候就可以**爆搜**啦——枚举每条未覆盖边的覆盖方式（选左端点、选右端点、选两个端点），最后用组合数算剩余点的可选方案。  

**核心算法流程**：  
1. 去重边→2. 找必选点（度数>k）→3. 检查剩余边数（>k²则无解）→4. 爆搜枚举边的覆盖方式→5. 组合数计算剩余方案。  

**可视化设计思路**：  
我会做一个**8位像素风的“像素守卫者”游戏**——屏幕是像素网格，点是彩色方块，边是线条。必选点会闪烁红色，爆搜时选点会有“滑入”动画+“叮”的音效，覆盖的边变灰。每完成一条边的覆盖，算“小关卡”，完成所有边会播放“胜利音效”。还能单步执行看每一步的选择，自动播放看完整流程～


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法优化度等角度，为大家筛选了以下4星以上的优质题解：
</eval_intro>


### 题解一：(来源：Alex_Wei)
* **点评**：这份题解是“小k爆搜”的标杆！思路一步到位：先去重边，再找必选点，最后用`ban`数组标记点的状态（0=待定、1=选、2=不选），枚举每条边的三种覆盖方式。代码规范，`dfs`函数逻辑严谨，组合数预处理正确，甚至处理了重复计算的问题（通过`ban`数组避免选到同一条边的两端）。特别适合入门学习，几乎没有冗余代码！


### 题解二：(来源：_Diu_)
* **点评**：这题解的亮点是**用set维护度数最大的点**，每次选度数最大的点（要么选它，要么选它所有邻居），剪枝效率高！代码里`erase`和`insert`函数处理点的选/不选，回溯时恢复状态，逻辑清晰。虽然用`set`找最大值有点“小题大做”，但思路很启发人——选度数大的点能更快减少剩余边数！


### 题解三：(来源：船酱魔王)
* **点评**：这份题解的“必选点预处理”很扎实，用线段树找度数最大的点（虽然k小没必要，但代码严谨）。爆搜部分用`sta`数组标记点状态，组合数预处理正确，还加了“剩余边数>k²则无解”的特判，避免无用搜索。美中不足是代码有点冗长，但胜在逻辑完整！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有3个，我结合优质题解给大家拆解：
</difficulty_intro>


### 1. 必选点的正确判断
* **难点**：怎么确定哪些点必须选？  
* **解决方案**：如果一个点的度数>k，必须选它！因为如果不选，要覆盖它的所有边，得选它的所有邻居（>k个），超过k的限制。比如题解中`while`循环找度数最大的点，直到没有度数>k的点。  
* 💡 **学习笔记**：必选点是“缩小问题规模”的关键，先处理它们能大幅减少后续搜索量！


### 2. 避免爆搜中的重复计数
* **难点**：枚举边的覆盖方式时，容易重复算同一种方案（比如先选u再选v，和先选v再选u是同一种）。  
* **解决方案**：用状态数组标记点的状态（比如`ban`数组：0=待定、1=选、2=不选）。枚举边时，只处理未覆盖的边，且保证每一步的选择唯一（比如选u则标记u=1，选v则标记v=1，避免重复）。  
* 💡 **学习笔记**：状态标记是爆搜的“安全带”，能避免重复计算！


### 3. 组合数的正确应用
* **难点**：爆搜后剩余的点可选可不选，怎么算方案数？  
* **解决方案**：预处理组合数`C(n, k)`（从n个点选k个的方案数）。当所有边都被覆盖，剩余可选点的数量是`n−c`（c是已选点数量），方案数是`C(n−c, k−c)`（从剩余点选k−c个）。  
* 💡 **学习笔记**：组合数要提前预处理到1e5，避免重复计算！


### ✨ 解题技巧总结
- **转化问题**：独立集→点覆盖，把大n问题转化为小k问题。  
- **预处理剪枝**：先处理必选点，减少搜索空间。  
- **状态标记**：用数组标记点的选/不选/待定，避免重复。  
- **组合数预处理**：提前算好`C(n, k)`，快速计算剩余方案。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，综合了优质题解的精华，逻辑清晰，适合入门：
</code_intro_overall>


### 本题通用核心C++实现参考
* **说明**：综合Alex_Wei、Nuyoah_awa的题解思路，优化去重边和必选点处理，代码简洁高效。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <set>
#include <algorithm>
using namespace std;

const int N = 1e5 + 5, MOD = 998244353;
int T, n, m, k, ans;
int fc[N], ifc[N], ban[N];  // ban: 0=待定,1=选,2=不选
set<int> e[N];
vector<pair<int, int>> edges;

int ksm(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1LL * res * a % MOD;
        a = 1LL * a * a % MOD;
        b >>= 1;
    }
    return res;
}

void init_combi() {
    fc[0] = 1;
    for (int i = 1; i < N; i++) fc[i] = 1LL * fc[i-1] * i % MOD;
    ifc[N-1] = ksm(fc[N-1], MOD-2);
    for (int i = N-2; i >= 0; i--) ifc[i] = 1LL * ifc[i+1] * (i+1) % MOD;
}

int C(int n, int k) {
    if (n < 0 || k < 0 || n < k) return 0;
    return 1LL * fc[n] * ifc[k] % MOD * ifc[n - k] % MOD;
}

void dfs(int rest, int cnt) {
    if (cnt > k) return;
    // 找未覆盖的边
    int idx = -1;
    for (int i = 0; i < edges.size(); i++) {
        int u = edges[i].first, v = edges[i].second;
        if (ban[u] == 2 && ban[v] == 2) return;
        if (ban[u] != 1 && ban[v] != 1) { idx = i; break; }
    }
    if (idx == -1) {  // 所有边都覆盖
        ans = (ans + C(rest, k - cnt)) % MOD;
        return;
    }
    int u = edges[idx].first, v = edges[idx].second;
    if (ban[u] == 0 && ban[v] == 0) {
        // 选u和v
        ban[u] = 1, ban[v] = 1;
        dfs(rest - 2, cnt + 2);
        // 选u不选v
        ban[u] = 1, ban[v] = 2;
        dfs(rest - 2, cnt + 1);
        // 选v不选u
        ban[u] = 2, ban[v] = 1;
        dfs(rest - 2, cnt + 1);
        // 恢复状态
        ban[u] = 0, ban[v] = 0;
    } else if (ban[u] == 0 && ban[v] == 2) {
        ban[u] = 1;
        dfs(rest - 1, cnt + 1);
        ban[u] = 0;
    } else if (ban[u] == 2 && ban[v] == 0) {
        ban[v] = 1;
        dfs(rest - 1, cnt + 1);
        ban[v] = 0;
    }
}

int main() {
    init_combi();
    cin >> T;
    while (T--) {
        cin >> n >> m >> k;
        ans = 0;
        for (int i = 1; i <= n; i++) {
            e[i].clear();
            ban[i] = 0;
        }
        edges.clear();
        // 去重边
        for (int i = 1; i <= m; i++) {
            int u, v;
            cin >> u >> v;
            if (u > v) swap(u, v);
            if (e[u].count(v)) continue;
            e[u].insert(v);
            e[v].insert(u);
        }
        // 找必选点
        int cnt = 0;
        while (cnt <= k) {
            int max_deg = 0, p = 0;
            for (int i = 1; i <= n; i++) {
                if (e[i].size() > max_deg) {
                    max_deg = e[i].size();
                    p = i;
                }
            }
            if (max_deg <= k - cnt) break;
            ban[p] = 1;
            cnt++;
            // 删除p的所有边
            for (int v : e[p]) {
                e[v].erase(p);
            }
            e[p].clear();
        }
        if (cnt > k) {
            cout << 0 << endl;
            continue;
        }
        // 收集剩余边
        for (int u = 1; u <= n; u++) {
            for (int v : e[u]) {
                if (v > u && ban[u] != 1 && ban[v] != 1) {
                    edges.emplace_back(u, v);
                }
            }
        }
        if (edges.size() > k * (k - cnt)) {
            cout << 0 << endl;
            continue;
        }
        // 爆搜
        dfs(n - cnt, cnt);
        cout << ans << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. `init_combi()`预处理组合数；  
  2. `main()`中去重边→找必选点→收集剩余边；  
  3. `dfs()`枚举边的覆盖方式，用`ban`数组标记状态，最后用`C(n, k)`算剩余方案。


<code_intro_selected>
接下来分析优质题解的核心片段：
</code_intro_selected>


### 题解一：(来源：Alex_Wei)
* **亮点**：`dfs`函数逻辑严谨，完美处理边的三种覆盖方式。
* **核心代码片段**：
```cpp
void dfs(int rest, int cur) {
    if(cur > k) return;
    int e = -1;
    for(auto it : buc)
        if(ban[u[it]] != 1 && ban[v[it]] != 1) { e = it; break; }
    if(e == -1) { ans += bin(rest, k - cur); return; }
    int &x = ban[u[e]], &y = ban[v[e]];
    if(x == 0 && y == 0) {
        x=1,y=1,dfs(rest-2,cur+2);
        x=1,y=2,dfs(rest-2,cur+1);
        x=2,y=1,dfs(rest-2,cur+1);
        x=y=0;
    }
    // ... 其他情况处理
}
```
* **代码解读**：  
  这段代码是爆搜的核心！首先找未覆盖的边`e`，然后处理`x`和`y`（边的两端点）的状态：如果都是待定（0），就枚举三种覆盖方式——选两个（x=1,y=1）、选x不选y（x=1,y=2）、选y不选x（x=2,y=1）。每种方式后都要**恢复状态**（x=y=0），避免影响其他分支。  
* 💡 **学习笔记**：爆搜的关键是“选→递归→恢复”，状态恢复是避免错误的关键！


### 题解二：(来源：_Diu_)
* **亮点**：用`set`维护度数最大的点，剪枝高效。
* **核心代码片段**：
```cpp
set<pair<int,int>> s;
void erase(int x) {
    s.erase({-d[x], x});
    vis[x] = 1;
    for(int y : g[x]) if(!vis[y]) {
        s.erase({-d[y], y});
        d[y]--;
        s.insert({-d[y], y});
    }
}
void dfs(int x, int num) {
    if(s.empty()) { ans += C[num][x]; return; }
    int t = s.begin()->second;
    erase(t), dfs(x-1, num-1), insert(t);  // 选t
    int st[K], tp=0;
    for(int y : g[t]) if(!vis[y]) erase(y), st[++tp] = y;  // 不选t，选所有邻居
    dfs(x-tp, num-tp-1);
    for(int i=tp; i>=1; i--) insert(st[i]);  // 恢复
}
```
* **代码解读**：  
  `set`里存的是`(-d[x], x)`（负数是为了按度数从大到小排序）。`erase(x)`会删除x，并减少它邻居的度数。`dfs`中，要么选当前度数最大的点`t`（`erase(t)`），要么不选`t`但选它所有邻居（`erase(y)`）。这样每一步都能覆盖最多的边，剪枝效率很高！  
* 💡 **学习笔记**：选度数大的点能更快“缩小问题规模”，是爆搜的好剪枝方法！


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素守卫者——覆盖所有边！
### 🌟 设计思路
用8位像素风模拟爆搜过程，让学习更有趣！比如：
- **场景初始化**：屏幕是240x160的像素网格，点是16x16的彩色方块（红=必选、蓝=待定、绿=选、灰=不选），边是白色线条。  
- **必选点预处理**：度数>k的点闪烁红色，伴随“滴”的音效，点击“开始”后它们会固定为红色（选）。  
- **爆搜演示**：  
  1. 点击“单步”，会找一条未覆盖的边（闪烁黄色），然后弹出三个选项（选左、选右、选两个）。  
  2. 选点时，点会有“滑入”动画+“叮”的音效，覆盖的边变灰。  
  3. 完成所有边覆盖，屏幕会弹出“胜利！”的像素字+上扬音效，显示组合数计算的方案数。  
- **交互控制**：有“单步”“自动播放”“重置”按钮，自动播放可以调速度（1x~5x），重置后回到初始状态。


### 🕹️ 动画关键步骤
1. **初始化**：显示输入的图（比如样例1的完全图），必选点（度数>k=1的点，比如样例1中所有点度数=3>1，所以都闪烁红色）。  
2. **必选点处理**：点击“开始”，必选点变为红色，k减少到0，剩余边数为0，直接显示答案0。  
3. **样例2演示**：k=3，必选点处理后，剩余边数≤3²=9，爆搜时选点会有动画，最后显示答案4。


### 🎵 音效设计
- 必选点闪烁：“滴”（短音）。  
- 选点：“叮”（清脆）。  
- 覆盖边：“咔”（低沉）。  
- 胜利：“哆来咪”（上扬音阶）。  
- 无解：“哔”（短促）。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移
本题的核心思路是“**小参数爆搜**”——当某个参数很小时，预处理必选点→缩小问题规模→爆搜。这种思路可以用到：
- 求大小为k的顶点覆盖（k小）。  
- 求大小为k的 clique（团）计数（k小）。  
- 求小k的子集和问题。


### 📚 洛谷推荐练习
1. **P3496 [POI2010]GIL-Guilds**：求两个不相交的点覆盖，和本题的点覆盖思路类似，练必选点处理。  
2. **P4381 [IOI2008]Island**：求独立集大小，练转化问题的能力。  
3. **P5022 [NOIP2018 提高组] 旅行**：求图的遍历路径，练爆搜剪枝（选度数大的点）。


## 7. 学习心得与经验分享

<insights_intro>
优质题解里有很多宝贵的经验，我选几个重点分享：
</insights_intro>


### 📝 经验1：去重边很重要！
比如Alex_Wei的题解中，用`set`去重边：`if(e[u[i]].find(v[i]) != e[u[i]].end()) i--, m--;`。如果不去重，点的度数会算错，导致必选点判断错误。  
**Kay的点评**：输入的边可能有重边，一定要去重！比如用`set`或`unordered_set`存边，避免重复计算度数。


### 📝 经验2：组合数要预处理到足够大！
比如Nuyoah_awa的题解中，预处理`c[N][K]`到`N=1e5`：`for(int i=1;i<=100000;i++) for(int j=1;j<=min(i,18);j++) c[i][j] = (c[i-1][j] + c[i-1][j-1])%MOD;`。如果预处理的范围不够，组合数会算错。  
**Kay的点评**：组合数要预处理到题目中的最大n（1e5），避免“数组越界”或“计算错误”！


### 📝 经验3：爆搜要“恢复状态”！
比如所有优质题解的`dfs`函数，都有“选→递归→恢复”的步骤。比如Alex_Wei的`x=y=0`，_Diu_的`insert(st[i])`。如果不恢复状态，会导致后续分支的状态错误，结果不正确。  
**Kay的点评**：爆搜的“状态恢复”是“保命符”，一定要记得！


## 💪 总结
本次分析的“挑战NPCⅢ”题，核心是**利用k小的特点，转化问题+预处理+爆搜**。关键步骤是：
1. 独立集→点覆盖（转化问题）。  
2. 处理必选点（度数>k的点）。  
3. 爆搜剩余边的覆盖方式。  
4. 组合数计算剩余方案。  

记住：编程能力的提升在于“理解思路→模仿代码→自己写”，多练类似题目（比如拓展练习中的题），你会越来越熟练！


下次我们再一起分析更有趣的算法题，加油～ 😊

---
处理用时：111.80秒
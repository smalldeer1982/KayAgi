# 题目信息

# 「RiOI-2」tnelat

## 题目背景

小 E 是一名一年级的小学生。她正在学习如何阅读。

如果在纸上写上 $998,\!244,\!353$，那么她就会读「三——五三四四——二八九九。」是的，她是从右往左读的。然后，她会把这个数理解为 $353,\!442,\!899$。

不过这并不影响她交流——她只是不会读纸上的文字罢了。唯一的问题是，她现在要学习带余除法了，而老师说不定会在纸上画一些红色的叉叉。不过，那又如何？

## 题目描述

对于一个长度为 $n$ 的**由数字组成的**字符串 $s=s_1s_2s_3\cdots s_n$，定义它的权值为 $f(s)=\sum\limits_{i=1}^n 10^{n-i}s_i$。（也就是它代表的十进制数）定义它的反串为 $\overline s=s_ns_{n-1}s_{n-2}\cdots s_1$。例如，$s=\texttt{0321}$ 的权值为 $f(s)=321$，反串为 $\overline s=\texttt{1230}$。  

试构造一个字符串 $s$，使得 $|s|\le 114514$，且 $f(s)\equiv a\pmod {998,\!244,\!353}$ 且 $f(\overline s)\equiv b\pmod{998,\!244,\!353}$。如果 $c=0$，你还要保证 $s_1\neq \texttt0$ 且 $s_n\neq \texttt 0$。
如果无解，仅输出整数 $-1$ 即可。

## 说明/提示

### 样例解释

对于第一组样例的第一组数据，$s=\overline{s}=\texttt{1000000001}$，$f(s)=f(\overline s)=1{,}000{,}000{,}001\equiv 1{,}755{,}648\pmod{998,\!244,\!353}$，所以它是一个可行解。

### 数据规模与约定

**本题开启捆绑测试。**

| $\text{Subtask}$ | 分值 | $a,b$ | 特殊性质 | 
| :--------------: | :--: | :---: | :------: |
| $0$ | $5$ | $ \in [1, 9]$ | $a = b$ |
| $1$ | $10$ | $ \in [0, 9]$ | / |
| $2$ | $15$ | $ \in [0, 99]$ | / | 
| $3$ | $25$ | / | $a = 0$ |
| $4$ | $25$ | / | $c = 1$ |
| $5$ | $20$ | / | / |

上表中的斜杠表示无特殊限制。

对于 $100\%$ 的数据，$1\leq T\leq 30$，$c\in\{0,1\}$，$0 \leq a, b \lt 998{,}244{,}353$。

## 样例 #1

### 输入

```
4
0
1755648 1755648
0 353442899
35281 18253
99728538 70320626```

### 输出

```
1000000001
998244353
35281
66330831785160880538172878128228067748679057340064161580956433229228884846388176250309226257600174873157935217529307119972759542770571505108922703815887608877795159689067116959276902444827654683066165```

## 样例 #2

### 输入

```
1
1
30 30```

### 输出

```
030```

## 样例 #3

### 输入

```
5
0
114514191 214748364
414414414 515515515
302813344 124821394
123456789 987654321
307210721 127012703```

### 输出

```
4509169566936302030543528193
6765800751328156020889260421
6754420765703935546785979321
4408846009459835952892074437
3108033793065515131695113495```

# AI分析结果

# 💡 Kay的C++算法解析：「RiOI-2」tnelat 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（侧重构造策略与模运算的结合）  

🗣️ **初步分析**：  
解决这道题就像**搭“数字积木”**——我们需要找到两块“积木”（字符串`s`和`t`），把它们拼在一起后：正面看（正序）积木的“数字重量”等于`a`（模998244353），反面看（反序）的重量等于`b`（模998244353）。核心思路是**将复杂的双条件问题拆分成两个单条件问题**：构造一个字符串`s`满足正序模`a`，再构造一个字符串`t`满足反序模`b`，最后把`t`反转后和`s`拼接，就能同时满足两个条件！  

题解的核心难点是**如何快速找到符合条件的`s`和`t`**，以及**处理前导/后缀零的限制**。解决方案是：  
1. 利用模运算的性质（`k*998244353 ≡ 0 mod 998244353`），构造`p = k*998244353`（正序模0）和`q = a + m*998244353`（正序模`a`）；  
2. 预处理`rev(p)`的哈希表（`rev`是反转数字），快速找到能让`rev(q)*10^len(p) + rev(p) ≡ b mod 998244353`的`p`和`q`；  
3. 用特定字符串（如`649938929839946`）替换零，避免前导/后缀零问题。  

**可视化设计思路**：我们会用**像素积木工厂**的场景演示构造过程——两个像素传送带分别生成`s`和`t`块（不同颜色区分），拼接时播放“咔嗒”音效，反转`t`时用像素箭头提示方向变化，验证模条件时用“叮”的音效高亮结果。最终拼接成功会弹出像素“胜利礼花”！  


## 2. 精选优质题解参考

### 题解一：（来源：MatrixGroup）  
* **点评**：这份题解的思路像“提前备料的厨师”——预处理`1e6`个`rev(k*998244353)`存入哈希表，之后直接查表找符合条件的`p`和`q`。它巧妙用`f15`字符串（`649938929839946`）替换零，解决了前导/后缀零的问题。代码中`gett`函数通过调整`10`的逆元（原根性质）快速定位目标，逻辑清晰，但预处理`1e6`次可能稍费内存。  

### 题解二：（来源：Grand_Dawn）  
* **点评**：这份题解像“聪明的拆分者”——用`meet in the middle`（折半枚举）把问题拆成两部分：先枚举`p = k*998244353`，计算`(b - rev(p)) * 10^{-len(p)} mod 998244353`存入哈希表；再枚举`q = a + m*998244353`，查询`rev(q)`是否在哈希表中。枚举量仅`1e5`，速度更快，代码也更简洁，是更高效的构造方案。  


## 3. 核心难点辨析与解题策略

### 🔍 核心难点与解决策略  
1. **如何拆分双条件问题？**  
   - 问题拆分成：构造`s`满足正序模`a`，构造`t`满足反序模`b`，拼接`t反转 + s`即可。因为`(t反转 + s)`的正序是`t反转`+`s`（模`a`），反序是`s反转`+`t`（模`b`）。  
   - 💡 学习笔记：复杂问题拆成“单条件子问题”是构造题的常用技巧！  

2. **如何处理前导/后缀零？**  
   - 当`c=0`时，`s`的首尾不能为0。解决方案是：用`k*998244353`（末尾非0）构造`p`，用`a + m*998244353`（开头非0）构造`q`，避免零的出现。  
   - 💡 学习笔记：构造时“主动避开限制条件”比“事后修改”更高效！  

3. **如何快速找符合条件的`p`和`q`？**  
   - 预处理`rev(p)`的哈希表，将“查询符合条件的`p`”转化为`O(1)`查表。  
   - 💡 学习笔记：预处理+哈希表是“用空间换时间”的经典策略！  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：此代码来自Grand_Dawn的题解，是`meet in the middle`构造策略的典型实现，逻辑简洁高效。  
* **完整核心代码**：  
```cpp
#include <bits/stdc++.h>
#define int long long
#define mod 998244353
#define B 100000
using namespace std;

int qpow(int mt, int p) {
    int ret = 1;
    for (; p; p >>= 1, mt = mt * mt % mod)
        if (p & 1) ret = ret * mt % mod;
    return ret;
}

pair<int, int> op[B]; // op[k] = (10^len(p), rev(p) mod mod)
unordered_map<int, int> trans;

string inttostring(long long x) {
    stringstream ss; string s;
    ss << x; ss >> s;
    return s;
}

int rev(int x) {
    string s = inttostring(x);
    reverse(s.begin(), s.end());
    stringstream ss; ss << s; ss >> x;
    return x;
}

string solve(int a, int b) {
    trans.clear();
    // 预处理p的可能：存储(b - rev(p)) * 10^{-len(p)} mod mod
    for (int i = 1; i < B; i++) if (i % 10) {
        int val = (b + mod - op[i].second) * qpow(op[i].first, mod - 2) % mod;
        trans[val] = i;
    }
    // 枚举q的可能：查询rev(q)是否在trans中
    for (int i = 0; i < B; i++) {
        int q = a + i * mod;
        if (q % 10 == 0) continue; // 避免q开头为0
        int rq = rev(q) % mod;
        if (trans.count(rq)) {
            int p = trans[rq] * mod;
            return inttostring(p) + inttostring(q);
        }
    }
    return "-1";
}

signed main() {
    ios::sync_with_stdio(false); cin.tie(0);
    // 预处理op数组：op[k] = (10^len(k*mod), rev(k*mod) mod mod)
    for (int k = 1; k < B; k++) {
        if (k % 10 == 0) continue; // 避免p末尾为0
        int p = k * mod;
        string s = inttostring(rev(p));
        int pow10 = 1, rev_p_mod = 0;
        for (char c : s) {
            pow10 = pow10 * 10 % mod;
            rev_p_mod = (rev_p_mod * 10 + (c - '0')) % mod;
        }
        op[k] = {pow10, rev_p_mod};
    }
    int t, c; cin >> t >> c;
    while (t--) {
        int a, b; cin >> a >> b;
        cout << solve(a, b) << endl;
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **预处理op数组**：计算`p = k*mod`的反转字符串长度对应的`10^len(p)`（`op[k].first`）和`rev(p) mod mod`（`op[k].second`）；  
  2. **构造哈希表trans**：存储`(b - rev(p)) * 10^{-len(p)} mod mod`对应的`k`；  
  3. **枚举q找p**：枚举`q = a + i*mod`，查询`rev(q)`是否在trans中，找到则拼接`p`和`q`输出。  


### 🔍 优质题解片段赏析  
#### 题解二：（来源：Grand_Dawn）  
* **亮点**：用`meet in the middle`将枚举量从`1e10`降到`1e5`，速度提升100倍！  
* **核心代码片段**：  
```cpp
string solve(int a, int b) {
    trans.clear();
    // 预处理p的可能，存入trans
    for (int i = 1; i < B; i++) if (i % 10) {
        int val = (b + mod - op[i].second) * qpow(op[i].first, mod - 2) % mod;
        trans[val] = i;
    }
    // 枚举q的可能，查询trans
    for (int i = 0; i < B; i++) {
        int q = a + i * mod;
        if (q % 10 == 0) continue;
        int rq = rev(q) % mod;
        if (trans.count(rq)) {
            int p = trans[rq] * mod;
            return inttostring(p) + inttostring(q);
        }
    }
    return "-1";
}
```
* **代码解读**：  
  - 第一部分循环：计算所有`p`对应的`(b - rev(p)) * 10^{-len(p)}`，存入哈希表`trans`（键是值，值是`k`）；  
  - 第二部分循环：枚举`q = a + i*mod`，计算`rev(q)`，如果`rev(q)`在`trans`中，说明找到对应的`p`，拼接`p`和`q`即可。  
  - 为什么用`qpow(op[i].first, mod-2)`？因为`10^{-len(p)} ≡ 10^{len(p)}^{mod-2} mod mod`（费马小定理）！  
* 💡 学习笔记：`meet in the middle`是“将大问题拆成两半，分别处理后合并”的高效策略！  


## 5. 算法可视化：像素动画演示  

### 🎮 动画主题：数字积木工厂（8位像素风）  
我们设计了一个**复古游戏化的像素动画**，用“积木工厂”的场景演示构造过程，让你像玩《超级马里奥制造》一样理解算法！  


### 🎯 核心演示内容与交互  
1. **场景初始化**：  
   - 屏幕左侧是“p传送带”（生成`p = k*mod`），右侧是“q传送带”（生成`q = a + m*mod`），中间是“拼接台”；  
   - 下方控制面板有：**单步执行**（逐帧看构造）、**自动播放**（像“AI搭积木”一样快速完成）、**重置**按钮，还有速度滑块（控制播放速度）；  
   - 背景是8位风格的工厂BGM（循环播放《超级马里奥》关卡音乐）。  

2. **预处理阶段**：  
   - “p传送带”上逐个弹出`k*mod`的像素块（棕色），每个块上显示`rev(k*mod)`的值；  
   - 每处理一个`k*mod`，播放“滴”的音效，同时哈希表`trans`的像素面板（右上角）更新键值对。  

3. **构造阶段**：  
   - “q传送带”弹出`q = a + m*mod`的像素块（蓝色），块上显示`rev(q)`的值；  
   - 当`rev(q)`出现在`trans`中时，“p传送带”会弹出对应的`p`块（棕色），同时播放“叮”的音效；  
   - “拼接台”将`p`块和`q`块拼在一起，播放“咔嗒”音效，屏幕下方显示“正序模：a ✔️，反序模：b ✔️”。  

4. **胜利与反馈**：  
   - 拼接成功后，屏幕中央弹出像素化的“胜利礼花”，播放《魂斗罗》通关音效；  
   - 若找不到解，弹出“找不到积木组合”的像素提示，播放短促的“错误”音效。  


## 6. 拓展练习与相似问题  

### 📚 通用思路迁移  
本题的**构造+模运算+哈希表**策略可用于：  
- 构造满足多个模条件的字符串；  
- 处理“正序+反序”双约束问题；  
- 用预处理优化枚举效率。  

### 🧩 推荐练习（洛谷）  
1. **洛谷 P4158 [SCOI2009] 粉刷匠**：构造满足涂色次数限制的方案，锻炼构造策略；  
2. **洛谷 P5018 [NOIP2018 普及组] 对称二叉树**：判断二叉树的对称性，练习“正序+反序”双条件处理；  
3. **洛谷 P1072 [NOIP2009 提高组] Hankson 的趣味题**：用模运算和枚举优化解决数论构造问题。  


## 7. 学习心得与经验分享  

> **参考经验（来自Grand_Dawn）**：“我最初想直接枚举所有可能的`p`和`q`，但枚举量太大。后来想到用`meet in the middle`拆成两半，枚举量从`1e10`降到`1e5`，一下子就过了！”  
> **点评**：这位作者的经验告诉我们——**当枚举量太大时，试着把问题拆成两半，分别处理后合并**，往往能大幅提升效率！  


## 🎉 结语  
这道题的核心是“构造+拆分+预处理”，像搭积木一样把复杂问题变简单。记住：**构造题的关键不是“想全所有可能”，而是“找到能拼接的子块”**！下次遇到构造题，不妨先想想“能不能拆成子问题”～  

编程的乐趣在于“用技巧解决问题”，继续加油吧！💪

---
处理用时：84.63秒
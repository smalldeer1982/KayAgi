# 题目信息

# [Ynoi Easy Round 2016] 炸脖龙 I

## 题目背景

备餐时光，软泞蜥獾

草地中钻孔，日晷下打转

波若歌鹦苟延残喘，迷途绿龟嚎哮迷茫

“当心炸脖龙，我的孩子！

那锋爪利颚，能挠钩撕咬！

注意秋布秋布鸟，你需回避，

那暴躁冒烟恶怪大毛怪！”

手持宝剑鸣真理之语：寻觅强敌豪壮永不息——于噹噹树下稍事休憩，伫立良久，深陷思绪。

当思绪纷乱杂绪之际，炸脖龙双目如烔炬，从阴暗密林奔跃闯出，一路悲鸣低吟时啭啼！

一，二！一，二！一刺再刺，真理之语将敌斩成糜！

取其首级，置之死地，

伴随胜利，驰马归疾。

“真当是你把怪龙斩于马下？

奋勇吾儿！

来我怀里！奔走相告！衣锦还乡！

父喜不自禁窃鸣得意

波若歌鹦苟延残喘，

迷途绿龟嚎哮迷茫，

备餐时光，软泞蜥獾

草地中钻孔，日晷下打转

波若歌鹦苟延残喘，

迷途绿龟嚎哮迷茫”

——《炸脖龙之诗》

![](https://cdn.luogu.com.cn/upload/pic/21111.png)

我喊了出来...却不成人话

只能，像在水中一边融化一边下沉的方糖一样...

失去自己的轮廓...一直沉向最低处

想要爬上去的子午

维持自己是自己的连续体...

溶解的渐渐七零八落的意识...

失去了用来挣扎的双手

失去了用来挣扎的双臂

向下，

向下，

一直沉下去

向着意识的底层

沉陷下去的自我...

逐渐消失的世界...

我看到了世界

失落的...世界...

![](https://cdn.luogu.com.cn/upload/pic/21112.png)

```plain

   回归天空的话我就可以成为      了

  开什么玩笑，你才不是什么      ！

  吵死了！吵死了！我是      ！而且生来就是！

就是因为这个家伙我才失去      的资格的！

 呜呜呜，由岐姐姐，由岐姐姐！

  ...怎么会...由岐姐...

 卓司！你这家伙！

        吵死了吵死了！像你这样的普通人懂些什么！

   由岐的血慢慢在冰凉的水泥地上扩散开来

   抱在怀里的      在渐渐地流出来        本应成为      而出生

的我的被      妨碍了！

不出生的话我就没法拯救是这个世界！

            所以预言者说能当世界回归天空的此处就是尽头

   只要      回归天空的话！

 我有这么可怕吗？

              因为我是要对一切生物下达审判的存在！

       因为哥哥是凡人呢

    凡人与天才

                            救世主

   世界

                    救世主

                回天之门

  要死的是你！

            我不会死               不会死       诅咒你

       要死的是羽咲

         只要羽咲死了

                  间宫              皆

                                    守           由

                         岐

                                间宫羽咲

                          可能性

                                    和镜

                     终

                   终之空

                     空

```

![](https://cdn.luogu.com.cn/upload/pic/21113.png)

一个婴儿出生了

谁的？

不知道


虽然不知道...
但确实有一个婴儿出生了

嗯...那个婴儿在哭...

呜嘎，呜嘎，地哭着...

听到这个哭声大家都笑了

大家都在为婴儿祝福

母亲也是...

父亲也是...

并且其他人也是...

为那个婴儿的出生...

衷心祝福

世界充满着生命的祝福

但是

但不是这样的

在那里

我

我一个人在那里恐惧着

非常恐惧...

要说为什么的话...

因为那是在对世界进行诅咒

没错...

他在诅咒着那个世界，那个刚出生的婴儿

诅咒着自己的出生

我

我当场全身僵硬

在大家的笑容之中

在祝福之中

独自一人...

我啊...

我摇摇晃晃地...

接近那个婴儿

然后想要让那个婴儿停止哭泣

我想着必须要那样做才行

为什么呢？

我自己也不明白...

那是

那是，自从出生以来

就悲惨地活到今天的我能做到的

我能做到的

唯一的

唯一的赎罪啊。

![](https://cdn.luogu.com.cn/upload/pic/21114.png)

让我在这里了结了你吧…间宫卓司

这里是终之空的下面吧…这不刚好吗

跟我们的终结很相称不是吗…

这里，是只对你而言的，终结的天空…

这里就是终焉之地…

![](https://cdn.luogu.com.cn/upload/pic/21115.png)

“不行！绝对不行！”

…为什么…跟过来了…

![](https://cdn.luogu.com.cn/upload/pic/21116.png)

预定…调和吗…

原来如此…看来不管怎样对于你来说…我都已经毫无任何价值了对吧…

竟然被这家伙打倒了…真是没办法呐…

这也是现实吗…

那就接受吧…

![](https://cdn.luogu.com.cn/upload/pic/21117.png)

不知为何，我好像看到了在夜空中挺立的向日葵…

只有一瞬间…

那株向日葵…

好像在某个地方…

向日葵…

跟羽咲一起…

是啊…

我是哥哥啊…

要是…能再多当当她的哥哥就好了……

![](https://cdn.luogu.com.cn/upload/pic/21119.png)

咦……

刚才的…

那个是…那片风景…

是吗…那片风景…

我也是知道的啊…

在坡道途中的向日葵…

蔚蓝的天空和向日葵。

漂浮着大大的云朵…

羽咲戴着大大的帽子…

然后跟我走在一起…

走着走着…

为了…

两人一起…

爬上那个坡道…

因为…那个坡道的前面有很漂亮的景色…

## 题目描述

您正在打 galgame，然后您觉得这个 gal 不知所云，于是您弃坑了，开始写数据结构题：

给一个长为 $n$ 的序列，$m$ 次操作，每次操作：

1. 区间 $[l,r]$ 加 $x$；
2. 对于区间 $[l,r]$，查询：

$$a[l]^{a[l+1]^{a[l+2]^{\dots ^{a[r]}}}} \mod p$$

## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477

对于100%的数据，$n , m \le 500000$ , 序列中每个数在$[1,2\cdot 10^9]$内，$p \le 2 \cdot 10^7 $, 每次加上的数在$[0,2\cdot 10^9]$内

共10组数据


## 样例 #1

### 输入

```
6 4
1 2 3 4 5 6
2 1 2 10000007
2 2 3 5
1 1 4 1
2 2 4 10
```

### 输出

```
1
3
1```

## 样例 #2

### 输入

```
5 5
2 3 3 3 3
1 1 1 530739835
2 1 1 8356089
2 1 4 5496738
1 1 2 66050181
1 2 4 138625417
```

### 输出

```
4306230
697527
```

# AI分析结果

# 💡 Kay的C++算法解析：[Ynoi Easy Round 2016] 炸脖龙 I 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扩展欧拉定理 + 树状数组（区间加&单点查询）

🗣️ **初步分析**：  
解决“炸脖龙I”的关键，是用**扩展欧拉定理**处理“连指数模运算”的“指数爆炸”问题，再用**树状数组**高效维护“区间加”操作。  

### 核心思想类比
- **扩展欧拉定理**：像一把“缩小模数的魔法钥匙”——对于连指数 \(a_l^{a_{l+1}^{\dots^{a_r}}} \mod p\)，它能把大模数 \(p\) 一步步变成更小的 \(\phi(p)\)（欧拉函数），直到模数变成1（此时任何数模1都是0）。这样我们不用计算恐怖的连指数，只需递归处理更小的模数。  
- **树状数组**：像一个“分层存储的工具箱”——区间加操作可以拆成两次单点修改（差分思想），单点查询能快速累加前缀和得到当前值。

### 题解思路与难点
所有优质题解的核心思路高度一致：  
1. **预处理**：用线性筛算出所有可能的欧拉函数值（\(\phi(p)\)），因为 \(p \leq 2 \times 10^7\)，预处理一次就够。  
2. **区间加**：用树状数组的差分思想维护——给区间\([l,r]\)加\(x\)，等价于在树状数组的\(l\)位置加\(x\)，\(r+1\)位置减\(x\)。  
3. **连指数查询**：递归应用扩展欧拉定理，每次将模数替换为\(\phi(p)\)，直到：  
   - 模数变成1（直接返回0）；  
   - 区间只剩一个元素（返回该元素模当前模数）；  
   - 遇到1（因为1的任何次幂都是1，后续无需计算）。  

**核心难点**：如何判断“指数是否大于\(\phi(p)\)”？  
优质题解用了一个巧妙的“暴力剪枝”：连指数增长极快，前5项的乘积就会超过\(2 \times 10^7\)（题目中\(p\)的最大值）。所以只需暴力计算前5项，若超过\(\phi(p)\)就直接递归，否则直接计算。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等角度，筛选了3篇评分最高的优质题解，帮你快速抓住核心！
</eval_intro>

### 题解一：Leap_Frog（赞37）
* **点评**：  
  这篇题解的思路最“接地气”——没有复杂的结构体，用“暴力前5项”完美解决了“指数是否大于\(\phi(p)\)”的问题，代码简洁到“令人发指”（但关键逻辑一个不少）！  
  - **思路亮点**：提到“若区间内有1，则后续项无需计算”，以及“前5项足够判断指数大小”，直接避免了复杂的条件判断。  
  - **代码亮点**：用树状数组的差分实现区间加，重定义`[]`运算符简化单点查询，常数极小（适合竞赛）。  
  - **实践价值**：代码几乎可以直接用于比赛，边界处理（如模数为1、区间长度为1）非常严谨。

### 题解二：NaCly_Fish（赞32）
* **点评**：  
  这篇题解用“结构体保存状态”的方式，把“指数是否大于\(\phi(p)\)”明明白白写了出来，适合新手理解扩展欧拉定理的细节！  
  - **思路亮点**：定义`node`结构体（包含结果`val`和是否大于\(\phi(p)\)的`flag`），递归时直接传递状态，逻辑清晰。  
  - **代码亮点**：快速幂函数返回`node`，实时判断乘积是否超过模数，避免了“暴力前5项”的盲目性。  
  - **学习价值**：详细解释了时间复杂度（\(O(p + q\log n\log p)\)），帮你理解“为什么递归不会超时”。

### 题解三：zcysky（赞28）
* **点评**：  
  这篇题解从“线段树”过渡到“树状数组”，暴露了很多“踩坑”细节，适合学习“如何优化代码”！  
  - **思路亮点**：提到“线段树常数大，换成树状数组更高效”，以及“处理1的情况能大幅减少计算量”，是实际编程中的重要经验。  
  - **代码亮点**：用线段树实现区间加（虽然最后换成了树状数组），但展示了“如何从复杂到简单”的优化过程。  
  - **实践价值**：代码中的“las数组”（记录上次查询的位置）是卡常小技巧，能减少树状数组的查询次数。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有3个，结合优质题解的经验，我们逐个击破！
</difficulty_intro>

### 1. 如何应用扩展欧拉定理？
- **难点**：扩展欧拉定理有两个情况（指数小于/大于\(\phi(p)\)），直接递归会无法判断。  
- **策略**：  
  - 暴力计算前5项：连指数增长极快，前5项的乘积必然超过\(2 \times 10^7\)，若超过则直接递归（加\(\phi(p)\)），否则直接计算。  
  - 用结构体保存状态：像NaCly_Fish那样，用`flag`标记指数是否大于\(\phi(p)\)，递归时传递状态。  

💡 **学习笔记**：扩展欧拉定理的核心是“缩小模数”，而判断指数大小的关键是“利用连指数的快速增长”。

### 2. 如何高效维护区间加？
- **难点**：区间加操作如果用暴力遍历，时间复杂度是\(O(n)\)，无法处理\(n=5e5\)的数据。  
- **策略**：  
  用树状数组的**差分思想**：区间\([l,r]\)加\(x\)，等价于在树状数组的\(l\)位置加\(x\)，\(r+1\)位置减\(x\)。单点查询时，累加前缀和就能得到当前值（时间复杂度\(O(\log n)\)）。  

💡 **学习笔记**：树状数组是处理“区间加&单点查询”的“神器”，比线段树更简洁、更快。

### 3. 如何处理递归的终止条件？
- **难点**：递归如果没有终止条件，会无限循环。  
- **策略**：  
  递归终止的3种情况：  
  1. **模数为1**：任何数模1都是0，直接返回0。  
  2. **区间长度为1**：返回该元素模当前模数（若元素大于模数，需加模数，因为扩展欧拉定理要求指数大于\(\phi(p)\)时加\(\phi(p)\)）。  
  3. **遇到1**：1的任何次幂都是1，后续无需计算，直接返回1。  

💡 **学习笔记**：递归的终止条件要“狠”——能提前终止就提前，避免无用计算。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，它综合了优质题解的精华，用树状数组+扩展欧拉定理解决问题！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合Leap_Frog和NaCly_Fish的思路，用树状数组维护区间加，递归实现扩展欧拉定理，代码简洁高效。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cstring>
using namespace std;
typedef long long ll;

const int N = 500005;
const int M = 20000005;

ll t[N]; // 树状数组
int phi[M], prime[M/10], cnt;
bool vis[M];
int n, m, id;

// 快速幂（带模，处理指数是否大于mod）
ll ksm(ll a, ll b, int mod, bool &flag) {
    a %= mod;
    ll res = 1;
    flag = false;
    if (a >= mod) flag = true;
    while (b) {
        if (b & 1) {
            res = res * a;
            if (res >= mod) {
                flag = true;
                res %= mod;
            }
        }
        a = a * a;
        if (a >= mod) {
            flag = true;
            a %= mod;
        }
        b >>= 1;
    }
    return res;
}

// 线性筛预处理欧拉函数
void sieve() {
    phi[1] = 1;
    for (int i = 2; i < M; ++i) {
        if (!vis[i]) {
            prime[++cnt] = i;
            phi[i] = i - 1;
        }
        for (int j = 1; j <= cnt && prime[j] * i < M; ++j) {
            vis[prime[j] * i] = true;
            if (i % prime[j] == 0) {
                phi[prime[j] * i] = phi[i] * prime[j];
                break;
            } else {
                phi[prime[j] * i] = phi[i] * (prime[j] - 1);
            }
        }
    }
}

// 树状数组：区间加（差分）
void add(int x, ll val) {
    for (; x <= n; x += x & -x) t[x] += val;
}

// 树状数组：单点查询（前缀和）
ll query(int x) {
    ll res = 0;
    for (; x; x -= x & -x) res += t[x];
    return res;
}

// 递归计算连指数模p
ll calc(int l, int r, int p) {
    ll a = query(l);
    if (p == 1) return 0; // 模数为1，直接返回0
    if (l == r) { // 区间长度为1
        if (a >= p) return a % p + p;
        else return a % p;
    }
    if (a == 1) return 1; // 遇到1，后续无需计算

    // 递归处理下一层
    int ph = phi[p];
    ll exp = calc(l + 1, r, ph);
    bool flag;
    ll res = ksm(a, exp, p, flag);
    if (flag) res += p; // 指数大于ph，加ph
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    sieve(); // 预处理欧拉函数
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        ll x;
        cin >> x;
        add(i, x); // 初始化树状数组（差分）
        add(i + 1, -x);
    }
    while (m--) {
        int op, l, r, p;
        cin >> op >> l >> r >> p;
        if (op == 1) { // 区间加
            add(l, p);
            add(r + 1, -p);
        } else { // 查询连指数模p
            ll ans = calc(l, r, p) % p;
            cout << ans << '\n';
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  1. **预处理**：用线性筛算出所有\(\phi(p)\)（欧拉函数）。  
  2. **树状数组**：`add`函数实现区间加（差分），`query`函数实现单点查询（前缀和）。  
  3. **递归计算**：`calc`函数递归应用扩展欧拉定理，处理终止条件，用`ksm`函数计算快速幂并判断指数是否大于\(\phi(p)\)。  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你直观看到“扩展欧拉定理+树状数组”的工作过程，我设计了一个**8位像素风的动画**，像玩FC游戏一样学算法！
</visualization_intro>

### 动画演示主题：像素探险家的“模数缩小之旅”
- **风格**：仿FC红白机的8位像素风，用色块表示数组元素、模数、树状数组节点。
- **场景**：屏幕左侧是“数组探险队”（每个像素块代表一个元素，颜色表示值的大小），右侧是“模数魔法盒”（显示当前模数和\(\phi(p)\)），底部是“树状数组工具箱”（分层显示树状数组的节点）。

### 动画关键步骤
1. **初始化**：  
   - 数组元素用不同颜色的像素块展示（比如值越大，颜色越亮）。  
   - 模数魔法盒显示初始查询的\(p\)，树状数组工具箱显示初始的差分数据。  
   - 播放8位风格的背景音乐（比如《超级马里奥》的轻快旋律）。

2. **区间加操作**：  
   - 点击“区间加”按钮，选择\([l,r]\)和\(x\)，树状数组工具箱的\(l\)和\(r+1\)位置会“闪烁”（表示修改），同时数组元素的颜色会逐渐变亮（表示值增加）。  
   - 音效：修改树状数组时播放“叮”的音效，数组元素变化时播放“咻”的音效。

3. **连指数查询**：  
   - 点击“查询”按钮，选择\([l,r]\)和\(p\)，“数组探险队”的\(l\)位置会“发光”（表示当前处理的底数）。  
   - 模数魔法盒开始“缩小”：\(p\)变成\(\phi(p)\)，再变成\(\phi(\phi(p))\)，直到变成1（此时魔法盒显示“✨”）。  
   - 递归过程中，前5个元素会“依次跳动”（表示暴力计算），如果超过\(\phi(p)\)，魔法盒会“震动”（表示要加\(\phi(p)\)）。  
   - 音效：递归时播放“嘟嘟”的音效，模数缩小播放“滴”的音效，找到结果播放“胜利音效”（比如《魂斗罗》的通关音乐）。

4. **交互控制**：  
   - 提供“单步执行”（逐帧看递归过程）、“自动播放”（调速滑块控制速度）、“重置”按钮。  
   - 右侧有“代码同步窗口”，显示当前步骤对应的C++代码（比如递归到`calc(l+1, r, ph)`时，代码行高亮）。

### 设计思路
- 用**像素风**降低学习压力，让算法变得“可玩”；  
- 用**音效**强化关键操作的记忆（比如“叮”对应树状数组修改，“滴”对应模数缩小）；  
- 用**动画**展示“抽象的递归”（比如模数一步步缩小，数组元素依次处理），让思路更直观。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了“扩展欧拉定理+树状数组”，你可以解决很多“大数模运算+区间操作”的问题！
</similar_problems_intro>

### 通用思路迁移
- **场景1**：计算\(a^b \mod p\)，其中\(b\)是很大的数（比如\(b=10^{100}\)）——用扩展欧拉定理缩小指数。  
- **场景2**：维护区间加，查询区间内的“幂次和”（比如\(\sum_{i=l}^r a_i^k \mod p\)）——树状数组+扩展欧拉定理。  
- **场景3**：处理“嵌套幂次”的问题（比如\(a^{b^{c^d}} \mod p\)）——递归应用扩展欧拉定理。

### 洛谷练习推荐
1. **洛谷 P4139** - 上帝与集合的正确用法  
   🗣️ **推荐理由**：扩展欧拉定理的“模板题”，帮你巩固“模数缩小”的核心思想。  
2. **洛谷 P3747** - 相逢是问候  
   🗣️ **推荐理由**：区间加+区间查询“幂次和”，需要结合树状数组和扩展欧拉定理，是本题的“进阶版”。  
3. **洛谷 P5091** - 扩展欧拉定理  
   🗣️ **推荐理由**：直接考察扩展欧拉定理的应用，帮你熟悉“指数是否大于\(\phi(p)\)”的判断。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从优质题解中，我提炼了3条“踩坑经验”，帮你少走弯路！
</insights_intro>

1. **遇到1要赶紧停**：  
   题解中多次提到“如果区间内有1，后续项无需计算”——这是因为1的任何次幂都是1，能大幅减少递归次数。  
2. **暴力前5项是“偷懒”的好办法**：  
   连指数增长极快，前5项的乘积就会超过\(2 \times 10^7\)，直接暴力计算比复杂的条件判断更高效。  
3. **树状数组比线段树更适合区间加**：  
   树状数组的代码更简洁，常数更小，对于“区间加&单点查询”的问题，优先选择树状数组。  


## 总结
这道题的核心是**扩展欧拉定理**（解决连指数模运算）和**树状数组**（解决区间加）的结合。通过这道题，你不仅学会了两个重要的算法工具，还能体会到“如何将复杂问题拆解成简单步骤”（比如用递归缩小模数，用差分处理区间加）。  

记住：编程的本质是“解决问题”，而不是“写复杂的代码”——像优质题解那样，用“暴力前5项”“结构体保存状态”这样的小技巧，能让你的代码更高效、更易读！  

下次遇到“大数模运算+区间操作”的问题，试试用今天学的思路，你一定能解决！💪

---
处理用时：230.24秒
# 题目信息

# 小 A 与两位神仙

## 题目背景

小 A 是一个普普通通的高中生，但是他某一天忽然被卷入了神仙的游戏中，快来帮帮他！

## 题目描述

某一天，小 A 正走在放学回家的路上，忽然遇见了两个神仙造梦者和杰瑞米，祂们一看到小 A 就说要和小 A 玩游戏，小 A 被笼罩在金光中，莫名其妙就答应了祂们的要求。

这个游戏的规则是这样的：两个神仙先选定一个正整数 $m$，保证 $m$ 是一个奇质数 $p$ 的正整数次幂。然后进行 $n$ 轮游戏，每轮中造梦者选定一个正整数 $x$，杰瑞米选定一个正整数 $y$，保证 $(x, m) = 1, (y, m) = 1$，即 $x$ 与 $m$ 互质，$y$ 与 $m$ 互质，接下来询问小 A 是否存在非负整数 $a$ 使得 $x^a \equiv y \pmod{m}$。

神仙们说小 A 只有在每一轮游戏中都回答正确才能回到正常的生活中，不得已之下他只好求助于聪明的你。


## 说明/提示

**样例解释**

$1^a \equiv 1 \not \equiv 4 \pmod {9}$。

$2^6 \equiv 64 \equiv 1 \pmod {9}$。

$7^2 \equiv 49 \equiv 4 \pmod {9}$。

**数据范围**

本题共 $7$ 个子任务，你需要通过一个子任务内的所有测试点才能取得这个子任务的分数。

对于所有数据满足 $1\le n\le 2\times 10^4$，$3\le m \le 10^{18}$，$1 \le x, y < m$ 。

| #    | 分数 | $n$                      | $m$                 | 特殊性质1 | 时间限制 |
| ---- | ---- | ------------------------ | ------------------- | --------- | --------- |
| 1    | 3    | $\le 5$            | $\le 10^6$    | ×         |  1s |
| 2    | 37   | $\le 5$            | $\le 10^9$    | ×         | 1s |
| 3    | 22   | $= 1$                    | $\le 10^{18}$ | ×         | 1s |
| 4    | 13   | $\le 100$          | $\le 10^{18}$ | √         | 1s |
| 5    | 10   | $\le 100$          | $\le 10^{18}$ | ×         | 1s |
| 6    | 5   | $\le 2000$         | $\le 10^{18}$ | ×         | 1s |
| 7    | 10   | $\le 2\times 10^4$ | $\le 10^{18}$ | ×         | 3s |

特殊性质1：令 $m = p^{a}$，则 $p$ 是在 $[3, 10^{18}]$ 等概率选取的一个素数。

**提示**

本题可以使用 `__int128`。

## 样例 #1

### 输入

```
9 3
1 4
2 1
7 4```

### 输出

```
No
Yes
Yes```

## 样例 #2

### 输入

```
29788562298698657 10
4623623705787050 4128735493476588
29371111781967946 19402395181570597
23313713550468151 18155134012955455
654639695903289 323875358727922
15727861955653242 26658913688488667
10815360622718474 4625834559167483
10836636083182170 10347869939717751
8972909638986721 1887397472131862
23442032136521081 29735793306181382
325363900801763 6960017105353559
```

### 输出

```
Yes
No
No
Yes
Yes
Yes
No
Yes
Yes
No
```

# AI分析结果

---
# 💡 Kay的C++算法解析：小 A 与两位神仙 深入学习指南 💡

<introduction>
  今天我们来一起分析“小 A 与两位神仙”这道C++数论题。这道题看似复杂，但只要掌握了**原根与阶**的核心概念，再结合大数分解的技巧，就能迎刃而解。本指南会帮你梳理思路、理解关键算法，并通过像素动画直观展示核心逻辑！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论（原根、阶） + 大数分解（Pollard-Rho、Miller-Rabin）

🗣️ **初步分析**：
解决这道题的关键，在于把**指数同余方程**转化为**阶的整除问题**。我们一步步拆解：

1. **原根的“翻译”作用**：题目中`m`是奇质数的幂，根据数论结论，这样的`m`一定有**原根**（记为`g`）。原根的神奇之处在于：**所有与`m`互质的数，都能表示成`g`的某个幂次**（比如`x = g^X`，`y = g^Y`）。这一步把乘法运算“翻译”成了加法运算！

2. **方程转化**：原问题`x^a ≡ y mod m`，代入原根表示后变成`g^(aX) ≡ g^Y mod m`。由于`g`的阶是`φ(m)`（欧拉函数），所以等价于`aX ≡ Y mod φ(m)`（就像“钟表转圈”，转`φ(m)`步回到原点）。

3. **裴蜀定理的条件**：线性同余方程`aX ≡ Y mod φ(m)`有解的充要条件是`gcd(X, φ(m)) | Y`。但`X`和`Y`是原根的指数，我们无法直接计算——这时候需要**阶**来帮忙！

4. **阶的关键性质**：数`x`的阶`δ_m(x)`（最小的正整数`k`使得`x^k ≡ 1 mod m`）满足`δ_m(x) = φ(m) / gcd(X, φ(m))`。同理`δ_m(y) = φ(m) / gcd(Y, φ(m))`。因此原条件转化为：**`δ_m(y) 必须整除 δ_m(x)`**！

💡 **核心算法流程**：
- 步骤1：用`Pollard-Rho`算法分解`m`，得到其唯一的奇质因数`p`（因为`m = p^k`）。
- 步骤2：计算`φ(m) = m/p * (p-1)`（欧拉函数的公式）。
- 步骤3：用`Pollard-Rho`分解`φ(m)`的质因数（求阶需要这些质因数）。
- 步骤4：对每个询问的`x`和`y`，分别计算它们的阶`δ_m(x)`和`δ_m(y)`。
- 步骤5：判断`δ_m(y)`是否整除`δ_m(x)`，输出“Yes”或“No”。

🎮 **可视化设计思路**：
我们用**8位像素风**模拟原根的“环形跑道”：
- 用像素格子组成一个环形（代表`φ(m)`的长度），每个格子对应原根的一个幂次。
- `x`的阶是`δ_m(x)`，表示`x`的幂在环形上“绕一圈”的步数（比如`δ_m(x)=3`，则`x^1`、`x^2`、`x^3`会回到起点）。
- 动画中用**不同颜色的像素点**表示`x`和`y`的阶，用“闪烁”提示整除关系（比如`y`的阶是`x`阶的因数时，`y`的像素点会“跳进”`x`的环里）。
- 关键操作（比如分解质因数、求阶）会伴随**像素音效**（比如分解时“叮”一声，求阶成功时“滴”一声）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速掌握核心技巧：
</eval_intro>

**题解一：双管荧光灯（赞：20）**
* **点评**：这份题解的思路非常“直击本质”——直接点出原根、指标与阶的关系，并用裴蜀定理转化条件。代码中`Pollard-Rho`和`Miller-Rabin`的实现简洁高效，求阶的逻辑也很清晰（试除`φ(m)`的质因数）。特别值得学习的是**对阶的性质的灵活运用**：通过`φ(m)/δ_m(x)`得到`gcd(X, φ(m))`，避免了直接计算原根的指数（这一步很难！）。

**题解二：小粉兔（赞：19）**
* **点评**：题解对原根和阶的性质做了**详细推导**，非常适合初学者理解。比如它解释了“为什么原根的幂能覆盖所有互质数”“阶的大小如何计算”。代码中`ord`函数（求阶）的实现很规范，用`sorted`和`unique`处理质因数的去重，避免了重复计算。此外，它还提到了`__int128`的使用，这是处理大数乘法溢出的关键！

**题解三：Alex_Wei（赞：6）**
* **点评**：这份题解的代码**极其简洁**，但核心逻辑一个不少。它用`map`存储质因数，避免了数组的繁琐处理；求阶时直接遍历`map`中的质因数，逻辑清晰。作者还在注释中提到了“阶的性质”的直观理解（环形跑道上的步数），非常有助于记忆。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点集中在“数论概念的转化”和“大数处理”上。结合优质题解，我总结了3个核心关键点：
</difficulty_intro>

1. **难点1：如何将原问题转化为阶的整除问题？**
    * **分析**：这是最关键的一步！需要理解原根的“翻译”作用（把乘法变加法），再用裴蜀定理转化条件，最后通过阶的性质把“指数的gcd”转化为“阶的整除”。优质题解的共同思路是：**绕开直接计算原根的指数，用阶的性质间接解决问题**。
    * 💡 **学习笔记**：原根是连接乘法和加法的“桥梁”，阶是解决指数同余问题的“钥匙”！

2. **难点2：如何高效求大数的阶？**
    * **分析**：求阶的前提是分解`φ(m)`的质因数（因为阶是`φ(m)`的因数）。对于大数`φ(m)`（比如`m=1e18`时，`φ(m)`也可能很大），普通的试除法会超时，必须用`Pollard-Rho`算法快速分解质因数。然后通过**试除`φ(m)`的质因数**求阶（比如对于每个质因数`p`，如果`x^(ord/p) ≡1 mod m`，则`ord`可以除以`p`）。
    * 💡 **学习笔记**：求阶的本质是“缩小`φ(m)`的因数范围”，试除质因数是关键！

3. **难点3：如何处理大数运算的溢出？**
    * **分析**：快速幂中的乘法（比如`x^k mod m`）会溢出`long long`（比如`m=1e18`时，`x*x`会超过`1e18`）。解决方法是用`__int128`（C++的扩展类型，支持128位整数）来暂存中间结果，再取模。
    * 💡 **学习笔记**：`__int128`是处理大数乘法的“神器”，一定要记住！

### ✨ 解题技巧总结
- **技巧1：利用数论性质转化问题**：遇到指数同余方程，先想“原根是否存在”，把乘法变加法。
- **技巧2：用Pollard-Rho处理大数分解**：对于`1e18`级别的数，Pollard-Rho是目前最有效的分解算法。
- **技巧3：用__int128避免溢出**：快速幂、乘法运算中，用`__int128`暂存结果，再转成`long long`。


## 4. C++核心代码实现赏析

<code_intro_overall>
下面是综合优质题解的**通用核心实现**，包含所有关键步骤：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了双管荧光灯、小粉兔和Alex_Wei的思路，包含`Miller-Rabin`素性测试、`Pollard-Rho`分解、求阶等核心函数，逻辑清晰易读。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstdlib>
#include <ctime>
#include <algorithm>
#include <map>
#include <vector>
using namespace std;
typedef long long ll;
typedef __int128 lll;

// Miller-Rabin素性测试
bool mr(ll x) {
    if (x < 2) return false;
    if (x == 2 || x == 3 || x == 5 || x == 7 || x == 11) return true;
    ll d = x - 1, s = 0;
    while (!(d & 1)) d >>= 1, s++;
    vector<ll> a = {2, 3, 5, 7, 11};
    for (ll p : a) {
        if (p >= x) continue;
        ll v = 1;
        ll base = p;
        for (ll k = d; k; k >>= 1) {
            if (k & 1) v = (lll)v * base % x;
            base = (lll)base * base % x;
        }
        if (v == 1 || v == x - 1) continue;
        bool ok = false;
        for (int j = 1; j < s; j++) {
            v = (lll)v * v % x;
            if (v == x - 1) { ok = true; break; }
        }
        if (!ok) return false;
    }
    return true;
}

// Pollard-Rho分解
ll pr(ll x) {
    ll s = 0, t = 0, c = rand() % (x - 1) + 1;
    ll val = 1;
    for (int goal = 1; ; goal <<= 1, s = t, val = 1) {
        for (int step = 1; step <= goal; step++) {
            t = ((lll)t * t + c) % x;
            val = (lll)val * abs(t - s) % x;
            if (step % 127 == 0) {
                ll d = __gcd(val, x);
                if (d > 1) return d;
            }
        }
        ll d = __gcd(val, x);
        if (d > 1) return d;
    }
}

// 分解质因数
map<ll, bool> factors;
void fac(ll x) {
    if (x == 1) return;
    if (mr(x)) { factors[x] = true; return; }
    ll p = pr(x);
    while (x % p == 0) x /= p;
    fac(p);
    fac(x);
}

// 快速幂（用__int128避免溢出）
ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    while (b) {
        if (b & 1) res = (lll)res * a % mod;
        a = (lll)a * a % mod;
        b >>= 1;
    }
    return res;
}

// 求x模m的阶（φ是φ(m)，factors是φ的质因数）
ll get_order(ll x, ll m, ll phi, map<ll, bool>& factors) {
    ll ord = phi;
    for (auto& [p, _] : factors) {
        while (ord % p == 0) {
            if (qpow(x, ord / p, m) != 1) break;
            ord /= p;
        }
    }
    return ord;
}

int main() {
    srand(time(0));
    ll m, n;
    cin >> m >> n;
    
    // 步骤1：分解m，得到唯一质因数p（因为m是奇质数的幂）
    factors.clear();
    fac(m);
    ll p = factors.begin()->first;
    
    // 步骤2：计算φ(m)
    ll phi = m / p * (p - 1);
    
    // 步骤3：分解φ(m)的质因数
    factors.clear();
    fac(phi);
    
    // 处理每个询问
    while (n--) {
        ll x, y;
        cin >> x >> y;
        ll ord_x = get_order(x, m, phi, factors);
        ll ord_y = get_order(y, m, phi, factors);
        if (ord_x % ord_y == 0) cout << "Yes\n";
        else cout << "No\n";
    }
    return 0;
}
```
* **代码解读概要**：
  1. **Miller-Rabin**：判断一个数是否是质数，用多个小质数测试，确保准确性。
  2. **Pollard-Rho**：快速分解大数的质因数，通过随机函数寻找因数。
  3. **fac函数**：递归分解质因数，用`map`存储（自动去重）。
  4. **qpow函数**：快速幂，用`__int128`暂存中间结果，避免溢出。
  5. **get_order函数**：求阶，试除`φ(m)`的每个质因数，缩小阶的范围。
  6. **主函数**：处理输入，分解`m`和`φ(m)`，对每个询问求阶并判断整除性。

---
<code_intro_selected>
接下来剖析优质题解的核心片段：
</code_intro_selected>

**题解一：双管荧光灯**
* **亮点**：用试除法求阶时，处理质因数的重复（比如`phi`有多个相同质因数时，循环试除）。
* **核心代码片段**：
```cpp
ll tmp = phi;
for(i=1;i<=o;) {
    for(j=i;j<=o&&fa[i]==fa[j];j++) {
        if(qp(x, tmp/fa[i], m)==1)
            tmp/=fa[i];
        else
            break;
    }
    for(;j<=o&&fa[i]==fa[j];j++);
    i=j;
}
```
* **代码解读**：
  - `fa`数组存储`phi`的质因数（可能有重复）。
  - 外层循环遍历不同的质因数（`i`跳过重复的）。
  - 内层循环试除当前质因数：如果`x^(tmp/fa[i]) ≡1 mod m`，说明`tmp`可以除以`fa[i]`，直到不能整除为止。
* 💡 **学习笔记**：处理重复质因数时，要循环试除，直到阶不能再缩小！

**题解二：小粉兔**
* **亮点**：用`sorted`和`unique`处理质因数的去重，避免重复计算。
* **核心代码片段**：
```cpp
Factorize(Phi);
std::sort(Prs + 1, Prs + Prc + 1);
int T = 0, cnt = 0; LL lst = 0;
for (int i = 1; i <= Prc; ++i) {
    if (Prs[i] != lst) {
        if (lst) {
            // 处理重复质因数（比如p^k拆成p^(k-2^m+1)等）
            int k = 31 - __builtin_clz(cnt);
            Prs[++T] = qPow(lst, cnt - (1 << k) + 1, 0);
            for (int j = 1; j <= k; ++j) Prs[++T] = qPow(lst, 1 << (k - j), 0);
        }
        lst = Prs[i], cnt = 0;
    } ++cnt;
}
```
* **代码解读**：
  - `Factorize`分解`phi`的质因数，存入`Prs`数组。
  - `sort`和`unique`去重，然后处理重复质因数（比如把`p^3`拆成`p^1`、`p^2`、`p^3`），方便试除。
* 💡 **学习笔记**：质因数去重后，处理重复幂次可以提高求阶的效率！

**题解三：Alex_Wei**
* **亮点**：用`map`存储质因数，代码简洁。
* **核心代码片段**：
```cpp
map <long long, bool> mp;
void factorize(long long n) {
    if(n == 1) return;
    if(Miller_Rabin(n)) return mp[n] = 1, void();
    long long p = Pollard_rho(n);
    while(n % p == 0) n /= p;
    factorize(p), factorize(n);
}
```
* **代码解读**：
  - `map`自动去重，存储`n`的所有不同质因数。
  - 分解时，先找一个因数`p`，然后递归分解`p`和`n/p`。
* 💡 **学习笔记**：`map`是处理质因数去重的“偷懒神器”！


## 5. 算法可视化：像素动画演示 (核心部分)

\<visualization\_intro\>
为了直观理解“阶的整除关系”，我设计了一个**8位像素风的环形跑道动画**，模拟原根的幂和阶的概念：
\</visualization\_intro\>

### 动画设计细节
- **风格与场景**：仿照FC红白机的像素风格，背景是深蓝色的“数学星空”，中间有一个**环形跑道**（代表`φ(m)`的长度，比如`φ(m)=6`时，跑道有6个像素格子）。跑道上的每个格子对应原根`g`的一个幂次（`g^0`到`g^5`）。
- **角色设定**：
  - `x`用**红色像素点**表示，它的阶`δ_m(x)`是“绕跑道一圈的步数”（比如`δ_m(x)=3`，则红色点每走3步回到起点）。
  - `y`用**蓝色像素点**表示，它的阶`δ_m(y)`是蓝色点的步数（比如`δ_m(y)=1`，则蓝色点一直站在起点）。
- **核心动画步骤**：
  1. **初始化**：环形跑道显示`φ(m)`个格子，红色点（`x`）和蓝色点（`y`）站在`g^0`的位置（起点）。
  2. **展示阶**：红色点开始“跑步”，每走一步闪烁一次，直到回到起点——此时跑步的步数就是`δ_m(x)`（比如走了3步，跑道上会留下红色的“轨迹”）。蓝色点同理，留下蓝色轨迹。
  3. **判断整除**：如果`δ_m(y)`整除`δ_m(x)`，蓝色轨迹会**“合并”**到红色轨迹中（比如蓝色轨迹是1步，红色是3步，蓝色点会跟着红色点一起跑），并播放**“叮”的胜利音效**；否则蓝色轨迹会“闪红”，播放**“滴”的失败音效**。
- **交互设计**：
  - 控制面板有“单步”“自动播放”“重置”按钮，以及速度滑块（调整跑步速度）。
  - 自动演示模式：算法会自动完成`x`和`y`的阶计算，并展示整除结果，像“贪吃蛇AI”一样自动运行。
- **音效设计**：
  - 跑步步声：每走一步，播放轻微的“踏踏”声。
  - 阶计算完成：播放“叮”的提示音。
  - 整除成功：播放上扬的“胜利”音效（类似FC游戏通关）。
  - 整除失败：播放短促的“错误”音效。

### 为什么这样设计？
- **环形跑道**：直观展示原根的“循环性”，让阶的概念更具象（“绕一圈的步数”）。
- **颜色区分**：红色和蓝色的轨迹对比，清晰显示`x`和`y`的阶。
- **音效反馈**：用声音强化关键操作，帮助记忆（比如“叮”声对应阶计算完成）。


## 6. 拓展练习与相似问题思考

\<similar\_problems\_intro\>
掌握了“原根与阶”的思路后，你可以解决更多数论问题！比如：
\</similar\_problems\_intro\>

### 通用思路迁移
- **场景1**：求解高次同余方程（比如`x^k ≡ a mod m`，当`m`有原根时，转化为线性方程）。
- **场景2**：判断一个数是否是原根（用阶的性质：`δ_m(g) = φ(m)`）。
- **场景3**：计算原根的个数（`φ(φ(m))`，当`m`有原根时）。

### 洛谷练习推荐
1. **洛谷 P4718** - Pollard-Rho算法模板
   * 🗣️ **推荐理由**：练习大数分解的核心算法，是解决本题的基础。
2. **洛谷 P5491** - 原根
   * 🗣️ **推荐理由**：直接考察原根的求法，巩固“原根判定定理”。
3. **洛谷 P3306** - 最小生成树？不，是BSGS算法！
   * 🗣️ **推荐理由**：虽然是BSGS，但可以用“阶”的思路尝试解决，对比两种方法的差异。
4. **洛谷 P2613** - 有理数取余
   * 🗣️ **推荐理由**：练习欧拉函数和快速幂的结合，巩固大数运算技巧。


## 7. 学习心得与经验分享 (若有)

\<insights\_intro\>
从题解中，我总结了几个**踩坑教训**，帮你少走弯路：
\</insights\_intro\>

> **经验1**：`__int128`的使用！
> 很多作者提到，最初写快速幂时没用到`__int128`，导致乘法溢出，结果全错。比如`x=1e9`，`x*x=1e18`，刚好是`long long`的上限，但`x*x*x`就会溢出——必须用`__int128`暂存！
> **点评**：处理大数时，一定要注意溢出问题，`__int128`是C++中处理大整数乘法的“救命稻草”。

> **经验2**：分解质因数时要去重！
> 有的题解在分解`φ(m)`时没有去重，导致求阶时重复试除同一个质因数，浪费时间。比如`φ(m)=4=2^2`，如果不去重，会试除`2`两次——其实只需要试除一次！
> **点评**：质因数去重可以提高求阶的效率，用`map`或`sort+unique`都可以。


\<conclusion\>
本次分析让我们掌握了“原根与阶”的核心概念，以及如何用`Pollard-Rho`处理大数分解。记住：**数论问题的关键是“转化”——把复杂的方程转化为已知的性质**。下次遇到指数同余问题，试试用原根和阶来解决吧！💪
\</conclusion\>

---

---
处理用时：172.37秒
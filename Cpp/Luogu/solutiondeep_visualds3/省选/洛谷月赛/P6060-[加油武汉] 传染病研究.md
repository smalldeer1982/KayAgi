# 题目信息

# [加油武汉] 传染病研究

## 题目描述

在得知 W 市爆发的肺炎之后，科学家们立刻投入了紧锣密鼓的研究之中。

（下面的部分非严谨科学，大家做题以外切勿当真）

假设某种病毒在第 $x$ 天的传播能力为 $D(x)$，该函数的含义为 $x$ 的约数个数。例如 $D(6)=4, D(7)=2$。

现在给定你总的传播天数 $n$ 和一个影响常数 $k$，你需要计算 $\sum_{i=1}^n D(i^k)$ 也就是 $D(1^k)+D(2^k)+D(3^k)+ \cdots +D(n^k)
$。

由于答案可能很大，请对 $998244353$ 取模。

## 说明/提示

 - 对于 $20\%$ 的数据，满足 $1\leq T\leq 10,1\leq n\leq 100,1\leq k\leq 6$；
 - 存在另外 $30\%$ 的数据，满足 $1 \leq T \leq 10^4, 1\leq n \leq 10^7,k=1$；
 - 对于 $100\%$ 的数据，满足 $1 \leq T \leq 10^4, 1\leq n,k \leq 10^7$。

【样例解释】

$D(1^2)+D(2^2)+D(3^2)+D(4^2)+D(5^2)$  
$=D(1)+D(4)+D(9)+D(16)+D(25)$  
$=(1)+(3)+(3)+(5)+(3)$  

1 有约数 1 个：1；  
4 有约数 3 个：1，2，4；  
9 有约数 3 个：1，3，9；  
16 有约数 5 个：1，2，4，8，16；  
25 有约数 3 个：1，5，25；

一共有15个  


## 样例 #1

### 输入

```
1
5 2```

### 输出

```
15```

# AI分析结果

---
# 💡 Kay的C++算法解析：「加油武汉」传染病研究 深入学习指南 💡

<introduction>
  今天我们来分析一道结合数论函数与线性筛的编程题——「加油武汉」传染病研究。题目要求计算1到n每个数的k次方的约数个数之和，看起来有点复杂，但只要抓住“约数个数函数的积性”和“低次多项式”这两个关键点，就能轻松解决！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论函数（约数个数函数）、线性筛法、多项式预处理

🗣️ **初步分析**：
> 解决这道题的关键，是先理解**约数个数函数**的性质：如果一个数\(i\)的质因数分解是\(i = p_1^{\alpha_1} p_2^{\alpha_2} \dots p_m^{\alpha_m}\)，那么它的约数个数\(D(i) = (\alpha_1+1)(\alpha_2+1)\dots(\alpha_m+1)\)。而\(i^k\)的质因数分解是\(p_1^{k\alpha_1} p_2^{k\alpha_2} \dots p_m^{k\alpha_m}\)，所以\(D(i^k) = (k\alpha_1+1)(k\alpha_2+1)\dots(k\alpha_m+1)\)。  
> 这里有个**重要发现**：\(D(i^k)\)是关于\(k\)的**多项式**！比如\(i=6=2^1×3^1\)，则\(D(6^k)=(k×1+1)(k×1+1)=k²+2k+1\)，是二次多项式。而1e7以内的数最多有8个不同质因子（比如9699690=2×3×5×7×11×13×17×19），所以这个多项式的次数**不超过8**！  
> 于是问题转化为：预处理每个数\(i\)对应的8次多项式系数，求前缀和后，对每个查询的\(k\)，代入多项式求值即可。核心算法是**线性筛+多项式递推**——用线性筛快速处理每个数的质因子信息，递推其多项式系数，最后用前缀和和霍纳法则（Horner's Method）快速回答查询。  

  - **题解思路对比**：大部分题解都采用“多项式预处理+线性筛”的方法，而官方题解提到“数论分块”，但前者更直接高效（时间复杂度\(O(n×8 + T×8)\)）。  
  - **可视化设计思路**：用8位像素风格展示线性筛的过程（比如用不同颜色方块代表质因子）、多项式系数的递推（柱状图显示各次项系数变化）、查询时的霍纳法则计算（一步步乘k加系数，伴随“叮”的音效）。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速掌握核心方法：
</eval_intro>

**题解一：小粉兔（赞27）**
* **点评**：这份题解是最简洁清晰的实现之一。作者直接点出约数个数函数的多项式性质，用线性筛递推每个数的多项式系数（`poly[i][j]`表示第i个数的多项式第j次项系数），最后用前缀和和霍纳法则快速求值。代码风格规范（变量名如`lpf`表示最小质因子，`lpfc`表示最小质因子的次数），边界处理严谨（比如模运算的正确应用）。算法时间复杂度极低，完全满足1e7的数据规模要求，是竞赛中的标准写法。

**题解二：zcysky（官方题解，赞12）**
* **点评**：官方题解提供了另一种思路——数论分块。作者通过定义`g(d)`将问题转化为`sum_{i=1}^n k^{w(i)} floor(n/i)`（`w(i)`是i的质因子个数），再用数论分块优化。虽然这种方法复杂度略高，但能帮助你理解数论问题的多视角解法，拓展思维。

**题解三：沉石鱼惊旋（赞0，但代码规范）**
* **点评**：作者用`mod_int`结构体封装模运算，代码可读性强。通过线性筛求每个数的最小质因子，递推多项式系数（`f[i] = f[j] * cnt`，其中`j`是i除以最小质因子的最高次幂后的数，`cnt`是最小质因子的次数），最后前缀和累加。这种写法很适合学习如何用结构体简化模运算代码。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的核心难点在于“将数论问题转化为多项式问题”和“用线性筛递推多项式系数”。以下是3个关键问题及解决策略：
</difficulty_intro>

1.  **关键点1：为什么D(i^k)是关于k的多项式？**
    * **分析**：假设i有m个不同质因子，那么\(D(i^k) = \prod_{t=1}^m (k\alpha_t + 1)\)，展开后就是关于k的m次多项式。比如m=2时，\((k\alpha_1+1)(k\alpha_2+1) = \alpha_1\alpha_2 k² + (\alpha_1+\alpha_2)k + 1\)，确实是二次多项式。而1e7内m≤8，所以多项式次数≤8。
    * 💡 **学习笔记**：数论函数的乘积展开 often 对应多项式，这是将数论问题转化为代数问题的关键。

2.  **关键点2：如何用线性筛递推多项式系数？**
    * **分析**：线性筛的核心是“每个合数仅被其最小质因子筛掉”。对于数i，设其最小质因子为p，次数为cnt（即p^cnt是i中p的最高次幂），则i = p^cnt × j（j与p互质）。由于D是积性函数，\(D(i^k) = D((p^cnt)^k) × D(j^k)\)，对应多项式的**乘法**。而\(D((p^cnt)^k) = cnt×k + 1\)（一次多项式），所以i的多项式等于j的多项式乘以一次多项式(cnt×k +1)。
    * 💡 **学习笔记**：线性筛的“积性”性质是递推数论函数的核心，要学会利用“最小质因子分解”传递信息。

3.  **关键点3：如何快速查询？**
    * **分析**：预处理每个数的多项式系数后，求前缀和得到总和的多项式（`sum[n][j]`表示1到n的多项式第j次项系数之和）。查询时，代入k求值可以用**霍纳法则**：比如多项式\(a_8k^8 + a_7k^7 + ... + a_0\)可以写成\(...((a_8k + a_7)k + a_6)k + ... + a_0\)，这样只需8次乘法和加法，时间复杂度O(8)。
    * 💡 **学习笔记**：霍纳法则是多项式求值的高效方法，适用于高次多项式的快速计算。


### ✨ 解题技巧总结
<summary_best_practices>
通过本题，我总结了3个通用解题技巧：
</summary_best_practices>
- **技巧1：数论函数的积性利用**：遇到数论函数求和问题，先判断函数是否积性（比如D(x)是积性函数），再用线性筛递推。
- **技巧2：多项式预处理**：当函数值是某个变量的低次多项式时，预处理多项式系数，再代入求值，比每次重新计算快得多。
- **技巧3：霍纳法则**：高次多项式求值用霍纳法则，减少计算次数（比如8次多项式只需8次乘加）。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合优质题解的核心实现，它包含线性筛、多项式递推、前缀和和查询四个部分：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合小粉兔和沉石鱼惊旋的思路，用线性筛递推多项式系数，前缀和后用霍纳法则查询。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #include <cstring>
    using namespace std;

    typedef long long LL;
    const int Mod = 998244353;
    const int MN = 10000007; // 1e7+7

    bool ip[MN];          // 是否为质数
    int p[MN / 10];       // 质数列表
    int pc;               // 质数个数
    int lpf[MN];          // 最小质因子
    int lpfc[MN];         // 最小质因子的次数
    int dlpf[MN];         // i / (lpf^lpfc)，即与lpf互质的部分
    int poly[MN][9];      // poly[i][j]表示i对应的多项式第j次项系数

    void Sieve(int N) {
        poly[1][0] = 1; // 1的多项式是1（0次项系数1）
        for (int i = 2; i <= N; ++i) {
            if (!ip[i]) { // 质数
                p[pc++] = i;
                lpf[i] = i;
                lpfc[i] = 1;
                dlpf[i] = 1;
                poly[i][0] = 1; // (k*1 +1) = 1*k +1 → 0次项1，1次项1
                poly[i][1] = 1;
            }
            for (int j = 0; j < pc; ++j) {
                LL k = (LL)p[j] * i;
                if (k > N) break;
                ip[k] = 1;
                lpf[k] = p[j];
                if (i % p[j] == 0) { // i包含p[j]，即k的最小质因子是p[j]
                    lpfc[k] = lpfc[i] + 1;
                    dlpf[k] = dlpf[i]; // i/p[j]^lpfc[i] = dlpf[i]，所以k/p[j]^lpfc[k] = dlpf[i]
                    // 多项式乘法：poly[k] = poly[dlpf[k]] * (lpfc[k] * x + 1)
                    memcpy(poly[k], poly[dlpf[k]], sizeof(poly[k]));
                    for (int z = 8; z >= 1; --z) {
                        poly[k][z] = (poly[k][z] + (LL)lpfc[k] * poly[k][z-1]) % Mod;
                    }
                    break;
                } else { // i不包含p[j]，即k的最小质因子是p[j]
                    lpfc[k] = 1;
                    dlpf[k] = i;
                    // 多项式乘法：poly[k] = poly[i] * (1 * x + 1)
                    memcpy(poly[k], poly[i], sizeof(poly[k]));
                    for (int z = 8; z >= 1; --z) {
                        poly[k][z] = (poly[k][z] + poly[k][z-1]) % Mod;
                    }
                }
            }
        }
        // 计算前缀和：sum[n][j] = sum_{i=1}^n poly[i][j]
        for (int i = 1; i <= N; ++i) {
            for (int j = 0; j <= 8; ++j) {
                poly[i][j] = (poly[i][j] + poly[i-1][j]) % Mod;
                if (poly[i][j] < 0) poly[i][j] += Mod;
            }
        }
    }

    int main() {
        Sieve(10000000); // 预处理1e7以内的所有数
        int T;
        scanf("%d", &T);
        while (T--) {
            int N, K;
            scanf("%d%d", &N, &K);
            int ans = 0;
            // 霍纳法则求值：ans = (...((a8*K + a7)*K + a6)*K + ... ) + a0
            for (int i = 8; i >= 0; --i) {
                ans = ((LL)ans * K + poly[N][i]) % Mod;
            }
            printf("%d\n", ans);
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分为两部分：1. 线性筛预处理多项式系数；2. 处理查询。线性筛中，对于每个数i，若i是质数，则其多项式是`k+1`（0次项1，1次项1）；若i是合数，根据最小质因子的次数，将i分解为`p^cnt * j`（j与p互质），然后将j的多项式乘以`cnt*k +1`（一次多项式），得到i的多项式。最后计算前缀和，查询时用霍纳法则代入k求值。


<code_intro_selected>
接下来看小粉兔题解的核心片段，理解多项式递推的细节：
</code_intro_selected>

**题解一：小粉兔（核心片段）**
* **亮点**：用`memcpy`快速复制多项式系数，再通过逆序循环更新高次项，避免覆盖问题。
* **核心代码片段**：
    ```cpp
    if (i % p[j] == 0) { 
        lpfc[k] = lpfc[i] + 1;
        dlpf[k] = dlpf[i]; 
        memcpy(poly[k], poly[dlpf[k]], sizeof(poly[k]));
        for (int z = 8; z >= 1; --z) {
            poly[k][z] = (poly[k][z] + (LL)lpfc[k] * poly[k][z-1]) % Mod;
        }
        break;
    } else { 
        lpfc[k] = 1;
        dlpf[k] = i;
        memcpy(poly[k], poly[i], sizeof(poly[k]));
        for (int z = 8; z >= 1; --z) {
            poly[k][z] = (poly[k][z] + poly[k][z-1]) % Mod;
        }
    }
    ```
* **代码解读**：
    > 这段代码是线性筛中处理合数k的关键。当k的最小质因子是p[j]时：
    > 1. 如果i（k/p[j]）包含p[j]（即i%p[j]==0），则k中p[j]的次数是`lpfc[i]+1`，dlpf[k]是i除以p[j]的最高次幂后的数（即与p[j]互质的部分）。此时k的多项式是dlpf[k]的多项式乘以`(lpfc[k]*k +1)`，所以先复制dlpf[k]的多项式，再逆序更新高次项（比如z=8时，poly[k][8] += lpfc[k] * poly[k][7]），避免覆盖低次项的值。
    > 2. 如果i不包含p[j]，则k中p[j]的次数是1，dlpf[k]是i（与p[j]互质）。此时k的多项式是i的多项式乘以`(k +1)`，所以复制i的多项式后，逆序更新高次项（比如z=8时，poly[k][8] += poly[k][7]）。
* 💡 **学习笔记**：多项式乘法的逆序更新是关键，避免低次项被覆盖导致错误。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“线性筛+多项式递推”的过程，我设计了一个8位像素风格的动画，结合复古游戏元素，让你“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：像素探险家“小K”在数字森林中收集“多项式果实”，用线性筛的方法一步步解锁每个数的多项式系数。

  * **核心演示内容**：
    1. **数字森林初始化**：屏幕左侧是数字列表（1到100，用8位像素字体显示），右侧是“多项式面板”（显示当前数的8次多项式系数，用柱状图表示）。背景是复古的森林像素画，伴随8位风格的轻快BGM。
    2. **线性筛过程**：
       - **质数识别**：当小K走到质数（比如2）时，数字会变成绿色，多项式面板显示“1次项=1，0次项=1”（对应多项式k+1），伴随“叮”的音效。
       - **合数筛除**：当小K用质数p筛除合数k（比如2×2=4）时，k会变成黄色，多项式面板显示k的多项式系数（比如4的多项式是2k+1，对应1次项=2，0次项=1），伴随“沙沙”的筛动音效。
    3. **多项式递推**：当处理合数k（比如6=2×3）时，动画会拆分k为“最小质因子p=2”和“互质部分j=3”，然后演示多项式乘法（3的多项式是k+1，乘以2的多项式k+1，得到k²+2k+1），多项式面板的柱状图会动态增长，伴随“咻”的合并音效。
    4. **查询演示**：输入k=2，动画会用霍纳法则计算前缀和多项式的值（比如1到5的多项式和是15），屏幕中央显示“计算步骤：((0×2+1)×2+3)×2+3)×2+5)×2+3=15”，伴随“胜利”音效。

  * **交互设计**：
    - 控制面板：包含“单步执行”（小K走一步）、“自动播放”（调速滑块，从慢到快）、“重置”按钮。
    - 信息提示：鼠标 hover 数字时，显示其质因数分解和多项式；hover 多项式面板时，显示各次项的系数。

  * **设计理由**：
    - 8位像素风格：唤起复古游戏的回忆，降低学习的枯燥感。
    - 音效反馈：用不同音效强化关键操作（质数识别、合数筛除、多项式乘法），帮助记忆。
    - 动态拆分：演示k的质因子分解和多项式乘法，直观理解线性筛的递推逻辑。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心思路（数论函数+线性筛+多项式预处理）可以迁移到很多类似问题，比如：
</similar_problems_intro>

  * **通用思路迁移**：
    - 求\(\sum_{i=1}^n \phi(i^k)\)（欧拉函数的k次方和）：欧拉函数也是积性函数，\(\phi(i^k) = i^k - i^{k-1}\)，可以预处理多项式系数。
    - 求\(\sum_{i=1}^n \sigma_1(i^k)\)（约数和函数的k次方和）：约数和函数是积性函数，\(\sigma_1(i^k) = \frac{p^{k(\alpha+1)} - 1}{p-1}\)，可以预处理多项式系数。
    - 求\(\sum_{i=1}^n \tau(i^k)\)（约数个数函数的k次方和）：即本题的变形，只是k的位置不同。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P3327** - 约数个数和
       * 🗣️ **推荐理由**：本题是约数个数函数的基础题，帮助你巩固积性函数和线性筛的应用。
    2. **洛谷 P4448** - 欧拉函数求和
       * 🗣️ **推荐理由**：欧拉函数是数论中的核心函数，本题需要用线性筛递推欧拉函数，拓展你的数论思维。
    3. **洛谷 P5495** - Dirichlet前缀和
       * 🗣️ **推荐理由**：Dirichlet前缀和是处理积性函数求和的高级技巧，本题需要结合线性筛和前缀和，提升你的算法复杂度分析能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
小粉兔的题解中提到：“对于任何n≤1e7，σ₀(nᵏ)顶多是关于k的8次多项式而已。”这句话点出了本题的关键——**低次多项式**。很多数论问题看起来复杂，但只要找到函数的多项式性质，就能用预处理+快速查询解决。此外，线性筛的“积性”性质是递推数论函数的核心，一定要熟练掌握。


<conclusion>
本次关于“加油武汉”传染病研究的C++解题分析就到这里。希望这份指南能帮助你理解数论函数、线性筛和多项式预处理的结合应用。记住，数论问题的关键是“找性质”——找到函数的积性、多项式性等性质，就能将复杂问题转化为可预处理的简单问题。下次我们再一起探索更多数论算法！💪
</conclusion>

---

---
处理用时：145.12秒
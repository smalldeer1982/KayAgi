# 题目信息

# [WFOI - 01] 循环节（circle）

## 题目背景

简化题意：[$\texttt{Link}$](https://www.luogu.com.cn/paste/v7gqdh44)。

出题人注：これは非常に嫌な質問なので、あまり時間をかけたくない場合は、この質問を見る前に他の質問を終えることをお勧めします。

## 题目描述

给你一个坐标系上的点集 $a$，你需要找出一个子点集 $b$ 和一个向量 $x$，使得 $\exist\ z\in N^+,\{b\cup b+x\cup b+2x\cup\dots\cup b+zx=a\}$。

现在想让你求出任意一对 $b_0,x_0,z_0$，其中 $z_0$ 为所有满足条件的三元组中 $z$ 最大的，$b_0$ 中任意三点不共线，任意四点不构成梯形或平行四边形且 $b_0\cap b_0+x_0=\varnothing,b_0\cap b_0+2x_0=\varnothing,\dots,b_0\cap b+yx_0=\varnothing|{y\to+\infty}$。

其中 $b+x$ 的意思是，$b$ 中的所有点都平移向量 $x$ 后组成的点集。

## 说明/提示

由于本题有样例解释也只是照着念一遍，并且相信既然您都做到这一题来了应该能读懂题目含义，所以本题不提供样例解释（~~其实是出题人懒~~）。

**本题采用 Subtask 捆绑测试。**
Subtask 编号 | 数据规模与约定
:-: | :-:
**Subtask #0($\text{20 pts}$)** | $1\le n\le10$；$-10\le x_i,y_i \le 10$
**Subtask #1($\text{20 pts}$)** | $1\le n\le10^3$
**Subtask #2($\text{30 pts}$)** | $z>1$
**Subtask #3($\text{30 pts}$)** | 无特殊限制

对于 $100\%$ 的数据，$1\le n\le10^5$，点的坐标范围 $\in\left(-10^9,10^9\right)$，数据保证有解。

## 样例 #1

### 输入

```
4
0 0
0 1
1 0
1 1```

### 输出

```
2
1 3
0 1
1```

## 样例 #2

### 输入

```
3
0 0
0 1
1 0```

### 输出

```
3
1 2 3
0 0
0```

# AI分析结果

# 💡 Kay的C++算法解析：循环节（circle）深入学习指南 💡


## 引言  
今天我们要挑战一道**几何+技巧结合**的编程题——《循环节》。题目要求我们从给定的点集中，找出一个“基础点集”`b`、一个“平移向量”`x`，以及最大的次数`z`，使得原集合`a`是`b`沿着`x`平移`z`次后的所有点的并集。这道题的核心是**用几何工具（凸包+旋转卡壳）破解点集的平移规律**，跟着Kay一步步拆解，你会发现它没那么难！


## 1. 题目解读与核心算法识别  

✨ **本题主要考察**：编程技巧应用（几何算法：凸包+旋转卡壳）  

🗣️ **初步分析**：  
解决这道题的关键，是先理解点集的“平移结构”——原集合`a`是`b`平移多次后的“叠加”。比如样例1中，`a`是4个点（正方形的四个顶点），而`b`是2个点，平移向量`x=(0,1)`，平移1次后刚好覆盖所有点。  

那怎么找到`x`和`b`呢？这里要用到两个几何工具：  
- **凸包**：像用橡皮筋把点集“勒紧”，只保留最外围的点（比如正方形的四个顶点就是它的凸包）。为什么要找凸包？因为平移向量`x`一定藏在凸包的边上——想象一下，平移后的点集不会超出原凸包的范围，所以`x`必然是凸包某条边的向量。  
- **旋转卡壳**：沿着凸包“滚动”两条平行线，找到与当前边平行的所有点。这些点很可能是`b`平移后的结果，我们可以通过它们算出`x`和最大的`z`。  

举个例子：如果凸包上有一条边`AB`，旋转卡壳找到所有与`AB`平行的点`C、D、E`，那么`x`可能是`B-A`，而`z`就是这些点的数量减一（因为`B = A+x`，`C = A+2x`，依此类推）。  

**可视化设计思路**：我们会用8位像素风格（像FC红白机游戏）展示整个过程——点用彩色方块，凸包用黄色线条，旋转卡壳的平行线用闪烁的蓝色，共线点用红色高亮，平移向量用绿色箭头。关键操作（比如凸包生成、旋转卡壳滚动）会伴随“叮”“嗒”的像素音效，找到`x`时会播放胜利音效，让你“看得到、听得到”算法的每一步！


## 2. 精选优质题解参考  

<eval_intro>  
我从思路清晰度、代码可读性、算法有效性三个维度筛选了以下优质题解，帮你快速抓住核心：  
</eval_intro>  

**题解一：€€£的简明思路（4星）**  
* **点评**：这道题的“破题点”被作者一句话点透——“凸包+旋转卡壳找共线点”。作者指出，凸包上的平行边会包含平移后的点，通过这些点的数量能算出`z`，再用`map`判断`b`中的点（`p-x`不在`a`中的点就是`b`的成员）。思路非常简洁，但美中不足的是没有详细解释旋转卡壳的具体实现，适合已经懂几何工具的同学快速回忆。  

**题解二：TonyYin的详细实现（5星）**  
* **点评**：这是一份“手把手教你写代码”的题解！作者不仅解释了每一步的逻辑（比如为什么`x`在凸包上、如何用旋转卡壳找共线点），还附了完整的代码（向量类、凸包函数、旋转卡壳循环、`map`求`b`）。最贴心的是，作者用三张示意图展示了三种共线情况，帮你理解如何处理不同的平移结构。代码风格规范（变量名如`ch`代表凸包，`curx`代表当前向量），边界情况（所有点共线）也做了特殊处理，非常适合初学者跟着敲代码。


## 3. 核心难点辨析与解题策略  

<difficulty_intro>  
这道题的“坑”主要在**理解平移结构与几何工具的联系**，以及**处理各种边界情况**。结合优质题解，我帮你提炼了三个核心难点和解决策略：  
</difficulty_intro>  

### 1. 难点1：为什么平移向量`x`一定在凸包上？  
* **分析**：凸包是点集的“最小包围框”，平移后的点集不会超出原凸包的范围。比如，`b`中的点平移`x`后得到`b+x`，这些点的最外围一定是原凸包的边——所以`x`必然是凸包某条边的向量（比如凸包边`AB`的向量`B-A`就是可能的`x`）。  
* 💡 **学习笔记**：凸包是破解平移规律的“钥匙”，先找凸包再分析！  

### 2. 难点2：如何用旋转卡壳找共线的点？  
* **分析**：旋转卡壳的核心是“滚动”两条平行线，找到与当前凸包边平行的所有点。比如，当前处理凸包边`(i,i+1)`，我们用旋转卡壳找到所有在平行线上的点`[j,k]`，这些点就是`b`平移后的结果。通过这些点的位置（比如`ch[j+1] - ch[j]`）就能算出`x`，点的数量减一就是`z`。  
* 💡 **学习笔记**：旋转卡壳是找“平行点群”的利器，关键是要循环处理凸包的每一条边！  

### 3. 难点3：如何确定子点集`b`？  
* **分析**：`b`中的点是“最原始”的——它们没有被平移过，所以`p-x`不在`a`中（如果`p`是平移后的点，`p-x`一定在`a`里）。我们可以用`map`存储所有点，遍历每个点`p`，如果`p-x`不在`map`中，说明`p`属于`b`。  
* 💡 **学习笔记**：用`map`判断点是否存在，是处理大坐标点集的常用技巧！  

### ✨ 解题技巧总结  
- **几何工具优先**：遇到点集结构问题，先想凸包、旋转卡壳这些几何工具；  
- **边界情况要特殊处理**：比如所有点共线时，直接排序后分析平移规律；  
- **用`map`处理大坐标**：点的坐标可能很大（到`1e9`），用`map`存储点的存在性比数组更高效。  


## 4. C++核心代码实现赏析  

<code_intro_overall>  
先看一份**综合了优质题解的通用核心代码**，帮你建立整体框架：  
</code_intro_overall>  

### 本题通用核心C++实现参考  
* **说明**：本代码综合了TonyYin的实现，包含向量类、凸包计算、旋转卡壳找`x`和`z`、`map`求`b`，逻辑清晰且完整。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <map>
using namespace std;

const int MAXN = 1e5 + 10;
struct Point { // 向量类，处理点的加减和叉乘
    long long x, y;
    Point() {}
    Point(long long a, long long b) : x(a), y(b) {}
    friend Point operator-(const Point& a, const Point& b) { return Point(a.x - b.x, a.y - b.y); }
    friend Point operator+(const Point& a, const Point& b) { return Point(a.x + b.x, a.y + b.y); }
    friend bool operator==(const Point& a, const Point& b) { return a.x == b.x && a.y == b.y; }
    friend bool operator<(const Point& a, const Point& b) { return a.x < b.x || (a.x == b.x && a.y < b.y); }
    friend long long operator*(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; } // 叉乘
};

Point p[MAXN], ch[MAXN]; // p是输入点集，ch是凸包
int n, z;
Point x_vec;
vector<int> b;

// 凸包计算：返回凸包的大小
int convex_hull() {
    sort(p, p + n);
    int top = -1;
    for (int i = 0; i < n; i++) { // 下凸壳
        while (top > 0 && (ch[top] - ch[top-1]) * (p[i] - ch[top-1]) >= 0) top--;
        ch[++top] = p[i];
    }
    int k = top;
    for (int i = n-2; i >= 0; i--) { // 上凸壳
        while (top > k && (ch[top] - ch[top-1]) * (p[i] - ch[top-1]) >= 0) top--;
        ch[++top] = p[i];
    }
    return top; // 凸包大小（最后一个点和第一个点重合，所以不用+1）
}

// 旋转卡壳找x和z
void find_x_and_z() {
    bool all_collinear = true;
    for (int i = 2; i < n; i++) { // 判断所有点是否共线
        if ((p[i] - p[0]) * (p[1] - p[0]) != 0) { all_collinear = false; break; }
    }
    int siz = convex_hull();
    if (all_collinear) { // 所有点共线，直接排序后分析
        sort(p, p + n);
        x_vec = p[1] - p[0];
        z = n-1;
        return;
    }
    // 旋转卡壳处理凸包
    ch[siz] = ch[0]; // 凸包循环
    int max_z = 0;
    for (int i = 0; i < siz; i++) { // 遍历凸包的每条边(i, i+1)
        int j = (i+1) % siz;
        while ((ch[j+1] - ch[i]) * (ch[i+1] - ch[i]) > (ch[j] - ch[i]) * (ch[i+1] - ch[i])) {
            j = (j+1) % siz;
        }
        // 找到与边(i,i+1)平行的点群[j, k]
        int k = j;
        while ((ch[k+1] - ch[i]) * (ch[i+1] - ch[i]) == (ch[k] - ch[i]) * (ch[i+1] - ch[i])) {
            k = (k+1) % siz;
        }
        // 计算当前点群的z
        int current_z = (k - j + siz) % siz;
        if (current_z > max_z) {
            max_z = current_z;
            x_vec = ch[j+1] - ch[j];
        }
    }
    z = max_z;
}

// 用map求b集合
void find_b() {
    map<Point, bool> mp;
    for (int i = 0; i < n; i++) mp[p[i]] = true;
    for (int i = 0; i < n; i++) {
        if (!mp.count(p[i] - x_vec)) {
            b.push_back(i+1); // 题目要求输出1-based索引
        }
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) {
        cin >> p[i].x >> p[i].y;
    }
    find_x_and_z();
    find_b();
    // 输出结果
    cout << b.size() << endl;
    for (int num : b) cout << num << " ";
    cout << endl;
    cout << x_vec.x << " " << x_vec.y << endl;
    cout << z << endl;
    return 0;
}
```  
* **代码解读概要**：  
  1. **向量类**：定义了点的加减、叉乘（判断方向），是几何计算的基础；  
  2. **凸包计算**：用排序+栈的方法，求出点集的凸包；  
  3. **旋转卡壳**：遍历凸包的每条边，找到平行的点群，算出最大的`z`和对应的`x`；  
  4. **找`b`**：用`map`存储所有点，遍历每个点，判断`p-x`是否存在，不存在的就是`b`的成员。  


<code_intro_selected>  
接下来剖析**TonyYin题解中的关键片段**，看看高手是如何处理细节的：  
</code_intro_selected>  

**题解二：TonyYin的向量类与凸包函数**  
* **亮点**：用向量类封装点的操作，让几何计算更简洁；凸包函数处理了共线点，保证凸包的正确性。  
* **核心代码片段**：  
```cpp
struct Point {
    long long x, y;
    Point() {}
    Point(long long a, long long b) : x(a), y(b) {}
    friend Point operator-(const Point& a, const Point& b) { return Point(a.x - b.x, a.y - b.y); }
    friend long long operator*(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }
};

int convex_hull() {
    sort(p, p + n);
    int top = -1;
    for (int i = 0; i < n; i++) {
        while (top > 0 && (ch[top] - ch[top-1]) * (p[i] - ch[top-1]) >= 0) top--;
        ch[++top] = p[i];
    }
    // 上凸壳部分...
}
```  
* **代码解读**：  
  - 向量类中的`operator-`用于计算两点的差（向量），`operator*`是叉乘（判断两个向量的方向：正表示逆时针，负表示顺时针，0表示共线）；  
  - 凸包函数中，`sort(p, p+n)`按x坐标排序（x相同按y），然后用栈构建下凸壳：当新点`p[i]`导致栈顶的两个点形成的边“向内凹”（叉乘≥0），就弹出栈顶点，直到满足凸性。  
* 💡 **学习笔记**：向量类是几何题的“瑞士军刀”，叉乘是判断点方向的关键！  


## 5. 算法可视化：像素动画演示  

<visualization_intro>  
为了让你更直观地“看到”算法运行，我设计了一个**8位像素风格的动画**，像玩《超级玛丽》一样理解凸包、旋转卡壳和点集平移！  
</visualization_intro>  

### 动画演示主题  
**《像素点的“平移密码”破解记》**——你扮演一个“几何侦探”，用凸包和旋转卡壳找出点集的平移规律。  

### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是**点集区域**（8位像素风格，点用不同颜色的方块，比如红色）；  
   - 右侧是**控制面板**（有“开始/暂停”“单步”“重置”按钮，速度滑块）；  
   - 背景是FC游戏的蓝天草地，播放轻快的8位BGM。  

2. **凸包生成**：  
   - 点集区域中，红色点开始“抱团”，黄色线条逐渐连接最外围的点（凸包），每连一条边就播放“叮”的音效；  
   - 旁白提示：“这是点集的凸包——最外围的点连起来的线，平移向量就藏在这里！”  

3. **旋转卡壳滚动**：  
   - 凸包的边用黄色高亮，两条蓝色的平行线（旋转卡壳）开始沿着凸包滚动；  
   - 当平行线遇到与当前边平行的点时，这些点会变成红色并闪烁，旁白提示：“这些点是平移后的结果，它们的向量就是x！”  

4. **平移向量确定**：  
   - 红色点之间出现绿色箭头（表示`x`），箭头旁显示向量的坐标（比如`(0,1)`）；  
   - 同时，屏幕上方显示当前的`z`值（比如`1`），播放“嗒”的音效。  

5. **子点集`b`筛选**：  
   - 点集区域中，属于`b`的点会变成绿色并跳动，旁白提示：“这些点是最原始的——它们的`p-x`不在点集中！”  

6. **胜利结局**：  
   - 当找到所有结果时，屏幕弹出“破解成功！”的像素文字，播放上扬的胜利音效，背景礼花绽放。  

### 交互设计  
- **单步执行**：点击“单步”按钮，动画走一步，方便你仔细观察每一步；  
- **自动播放**：拖动速度滑块调整播放速度，最快2倍速，最慢0.5倍速；  
- **重置**：点击“重置”按钮，回到初始状态，重新开始演示。  

### 为什么这样设计？  
- **8位像素风格**：唤起你对经典游戏的回忆，降低学习的“距离感”；  
- **音效与动画结合**：用声音强化关键操作（比如凸包生成的“叮”），让你“记住”算法的核心步骤；  
- **游戏化元素**：把算法过程变成“侦探破案”，增加趣味性——你不是在学算法，而是在“破解密码”！  


## 6. 拓展练习与相似问题思考  

<similar_problems_intro>  
掌握了“凸包+旋转卡壳”的组合拳后，你可以挑战更多几何题！这些题目都用到了类似的思路：  
</similar_problems_intro>  

### 通用思路迁移  
- **找点集的对称中心**：用凸包的中点判断；  
- **求点集的最远点对**：旋转卡壳的经典应用；  
- **找点集的最大三角形面积**：用旋转卡壳遍历凸包上的点。  

### 洛谷练习推荐  
1. **洛谷 P2742** - 《二维凸包》  
   * 🗣️ **推荐理由**：最基础的凸包题，帮你巩固凸包的实现细节（比如排序、栈的处理）。  
2. **洛谷 P1452** - 《旋转卡壳求最远点对》  
   * 🗣️ **推荐理由**：旋转卡壳的经典应用，让你熟悉“滚动平行线”的逻辑。  
3. **洛谷 P3187** - 《凸包+旋转卡壳求最大三角形面积》  
   * 🗣️ **推荐理由**：综合题，需要用凸包缩小范围，再用旋转卡壳找最大三角形，锻炼你的综合应用能力。  


## 7. 学习心得与经验分享  

<insights_intro>  
TonyYin的题解中提到了**“所有点共线的特殊处理”**，这给了我们重要的启示：  
</insights_intro>  

> **参考经验（来自TonyYin）**：“当所有点共线时，不能直接用凸包的旋转卡壳，因为凸包只有两个点。这时候要直接排序点集，分析平移规律。”  
> **点评**：这提醒我们——**边界情况往往是算法的“漏洞”**！比如所有点共线时，凸包的旋转卡壳会失效，必须单独处理。解决方法是：先判断点集是否共线，如果是，直接排序后计算平移向量（比如`p[1]-p[0]`）和`z`（点的数量减一）。  


## 结语  
这道题的核心是**用几何工具破解点集的平移规律**——凸包帮我们缩小范围，旋转卡壳帮我们找到平移向量，`map`帮我们筛选基础点集。希望这份指南能让你理解每一步的逻辑，更重要的是，学会用“几何思维”解决点集问题！  

记住：编程不是“写代码”，而是“解决问题”——先想清楚思路，再用代码实现。下次遇到几何题，试试先画个凸包，说不定答案就在里面！💪

---
处理用时：152.16秒
# 题目信息

# [CoE R4 C] 网格

## 题目描述

**这是一道交互题。**

有一张 $n$ 个点的无向无权图。

这张图有一个特殊性质：存在一个点 $u \ (1 \leq u \leq n)$ 到正整数对 $(x, y) \ (1 \leq x \leq l, 1 \leq y \leq c)$ 的**一一对应**关系，使得 $n = l \cdot c$，且点 $u, v$ 间存在边当且仅当 $u, v$ 对应的数对 $(x_u, y_u), (x_v, y_v)$ 满足 $|x_u - x_v| + |y_u - y_v| = 1$。换而言之，这张图和 $l$ 行 $c$ 列的网格图同构。

现在，你要通过一些询问还原这张图的结构。每次询问时，你需要给定一个点 $u \ (1 \leq u \leq n)$。询问的返回值是一个长为 $n$ 的数组 $\{d_i\} \ (1 \leq i \leq n)$，表示点 $u, i$ 间的最短路径所经过的边数。

请你使用不超过 $q$ 次询问，还原出这张图的结构。

---

### 交互格式

**本题有多组数据。**

首先输入一个整数 $T$，表示数据组数。

对于每组数据：

- 首先输入一个整数 $n$，表示图的点数。
- 接下来，你可以执行一些询问。对于每次询问，输出一个整数 $u$，为你询问的点。然后，输入 $n$ 个整数 $\{d_i\}$，为询问的返回值。
- 当你确定答案后，输出一个整数 $0$，然后输出答案。

在输出答案时：

- 第一行输出两个整数 $l, c$；
- 接下来，输出 $l$ 行 $c$ 列整数，为你还原的对应关系。第 $i$ 行 $j$ 列的数为 $(i, j)$ 对应的编号。

如果有多个答案，你可以输出任意一个。一个答案是正确的，当且仅当它和标准答案无法被任何询问区分：也就是，在这两个答案对应的网格图中，任意点对间的最短路径所经过的边数都是相同的。

---

请注意：**在每次执行询问或者输出答案后，你应该清空缓冲区：**

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Java 中，使用 `System.out.flush()`。
- 在 Python 中，使用 `stdout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 对于其他语言，请自行查阅对应语言的帮助文档。


## 说明/提示

### 样例 $1$ 解释

对于样例，以下 $3$ 行 $2$ 列的网格图也是正确的输出。

```
3 2
4 2
3 5
6 1
```

左边是样例对应的网格图，右边是以上输出对应的网格图。

![](https://cdn.luogu.com.cn/upload/image_hosting/jy23v0au.png)

---

### 评分标准

对于一个子任务，令 $q_{\max}$ 为你在这个子任务的所有测试数据中的最大询问次数。

如果交互的格式不合法，运行超出了时间限制，或者你的答案不正确，或者 $q_{\max} > q$，你的得分为 $0$。

否则，对于子任务 $1 \sim 3$，你得满分；对于子任务 $4$，你的分数由下表给出：

| 条件 | 分数 |
| :-: | :-: |
| $q_{\max} \leq 3$ | $61$ |
| $q_{\max} = 4$ | $41$ |
| $q_{\max} = 5$ | $31$ |
| $q_{\max} = 6$ | $21$ |
| $q_{\max} \geq 7$ | $11$ |

---

### 数据规模

**本题采用捆绑测试。**

| 子任务 | 分值 | $n \leq$ | $q = $  | 特殊性质 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $3$ | $4$ | $4$ | 无 |
| $2$ | $13$ | $10^5$ | $4$ | 存在解使得 $l = 1$ |
| $3$ | $23$ | $36$ | $36$ | 存在解使得 $2 \leq l, c \leq 6$ |
| $4$ | $61$ | $10^5$ | $12$ | 无 |

对于所有数据，保证 $1 \leq T \leq 10^3$，$1 \leq n \leq 10^5$，$\sum n \leq 3 \times 10^5$。

在部分测试数据中，交互器是自适应的。也就是，图的结构可能会根据你的询问而变化。但是可以保证：在每次询问之后，存在至少一个答案符合当前所有询问的返回值。


## 样例 #1

### 输入

```
1
6

0 2 2 3 1 1

2 0 2 1 1 3

2 2 0 1 1 1

3 1 1 0 2 2

1 1 1 2 0 2

1 3 1 2 2 0```

### 输出

```


1

2

3

4

5

6

0
2 3
2 5 1
4 3 6```

## 样例 #2

### 输入

```
2
1



2

1 0```

### 输出

```


0
1 1
1

2

0
2 1
1
2```

# AI分析结果

# 💡 Kay的C++算法解析：网格 深入学习指南 💡


今天我们来一起分析“网格”这道**交互题**。这类题目需要通过“询问”获取信息，再还原隐藏的结构——就像玩“猜地图”游戏：你问“点A到所有点的距离是多少”，然后根据回答拼出整张网格！本指南会帮你理清思路，掌握核心技巧。


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`交互算法与几何映射`  

🗣️ **初步分析**：  
解决这道题的关键，是利用**网格的“角点性质”**和**距离公式**。简单来说：  
- 网格就像你玩的《超级马里奥》关卡地图，每个点对应一个“格子”，相邻格子（上下左右）有边。  
- 对于任何网格，**一个点的“最远点”一定是网格的“角”**（比如左上角、右下角）——就像你在关卡里从中间出发，最远的地方肯定是地图的角落。  
- 一旦找到两个“邻角”（比如左上角A和左下角B），就能用它们的距离计算所有点的坐标：  
  设点P到A的距离是`dis(A,P)`，到B的距离是`dis(B,P)`，A到B的距离是`dis(A,B)`，则P的坐标为：  
  $$x = \frac{1}{2}(dis(A,P) - dis(B,P) + dis(A,B) + 2)$$  
  $$y = \frac{1}{2}(dis(A,P) + dis(B,P) - dis(A,B) + 2)$$  

**核心流程**：  
1. 询问点1，找到最远点X（第一个角）；  
2. 询问X，找到最远点Y（X的对角）；  
3. 用X和Y的距离算出网格的行数`l`和列数`c`（因为`l*c=n`，且`l+c=dis(X,Y)+2`）；  
4. 用距离公式计算所有点的坐标，还原网格。  

**可视化设计思路**：  
我们会用**8位像素风**（像FC红白机）展示整个过程：  
- 屏幕左侧是“询问面板”（显示当前询问的点），右侧是“网格画布”（用像素块表示点，颜色标记角点）；  
- 找最远点时，像素块会“闪烁”高亮；计算坐标时，点会“移动”到对应的网格位置；  
- 关键操作（比如找到角点）会伴随“叮”的像素音效，完成还原时播放“胜利音效”。  


## 2. 精选优质题解参考

<eval_intro>
我为大家筛选了一份**5星题解**——作者通过“找角点+距离公式”的核心思路，用最少3次询问解决问题，且处理了所有边界情况（比如1×n的长条形网格、单点情况），代码规范易读。
</eval_intro>

**题解一：来源：Sakura_xyz**  
* **点评**：  
  这份题解的**思路极度清晰**——从“找角点”到“算坐标”的每一步都有明确的逻辑支撑：  
  - 用“最远点”快速定位角点，避免了盲目尝试；  
  - 用`l*c=n`和`l+c=dis(X,Y)+2`联立方程，直接算出网格的行数和列数，数学推导很巧妙；  
  - 边界处理非常严谨：比如点1的度数为1时（说明是1×n的长条形），直接按线性结构输出；度数为2时，进一步询问邻点判断是否为长条形。  
  代码方面，`Ask`函数封装了询问逻辑，`solve`函数分情况处理不同场景，变量名（如`dis_X`表示点X的距离数组）清晰易懂，非常适合初学者参考。  


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题时，大家常遇到3个“卡壳点”。结合题解的思路，我们逐一拆解：
</difficulty_intro>

### 1. 如何快速找到网格的“角点”？  
- **难点**：网格的角点是隐藏的，怎么用最少的询问找到它？  
- **策略**：利用“最远点必是角点”的性质——先询问任意点（比如点1），找到距离它最远的点X，X就是第一个角；再询问X，找到距离它最远的点Y，Y就是X的对角。  
- 💡 **学习笔记**：“最远点=角点”是网格的核心性质，记住这个结论能少走很多弯路！

### 2. 如何用距离算出网格的行数`l`和列数`c`？  
- **难点**：知道角点X和Y的距离`dis(X,Y)`，怎么求`l`和`c`？  
- **策略**：网格中，对角两点的距离是`l+c-2`（比如3行2列的网格，对角距离是3+2-2=3）。因此`l+c=dis(X,Y)+2`，再结合`l*c=n`，联立方程就能解出`l`和`c`（比如n=6，dis(X,Y)=3，则l+c=5，l*c=6，解得l=2，c=3或l=3，c=2）。  
- 💡 **学习笔记**：数学公式是解决几何映射问题的“钥匙”，先推导关系再写代码！

### 3. 如何处理“1×n”的特殊情况？  
- **难点**：当网格是长条形（比如1行5列），角点的性质还能用吗？  
- **策略**：用“度数”判断——长条形网格中，端点的度数是1（只有一个邻居），中间点的度数是2。因此：  
  - 如果点1的度数是1，直接按线性结构输出；  
  - 如果点1的度数是2，询问其邻点，若邻点度数是1，说明是长条形。  
- 💡 **学习笔记**：特殊情况要“提前判断”，避免用通用方法浪费询问次数！

### ✨ 解题技巧总结  
- **技巧1：利用问题的“几何性质”**：网格的角点、距离关系是解题的核心，先理解问题的几何本质再写代码；  
- **技巧2：封装重复操作**：用`Ask`函数封装询问逻辑，避免代码重复；  
- **技巧3：边界情况优先处理**：单点、长条形等特殊情况要先判断，减少后续逻辑的复杂度。  


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**通用核心代码**——综合了题解的思路，涵盖所有情况，帮助你理解整体框架。
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码来自题解的完整实现，封装了询问、找角点、算坐标的核心逻辑，处理了所有边界情况。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

const int MAXN = 100005;
int n, a1[MAXN], a2[MAXN], a3[MAXN];

void Ask(int* a, int x) {
    cout << x << endl;
    for (int i = 1; i <= n; i++) cin >> a[i];
    cout.flush(); // 必须刷新缓冲区！
}

int get_degree(int* a) {
    int cnt = 0;
    for (int i = 1; i <= n; i++) if (a[i] == 1) cnt++;
    return cnt;
}

void solve_1D() {
    vector<int> res(n);
    for (int i = 1; i <= n; i++) res[a1[i]] = i;
    cout << 0 << endl;
    cout << 1 << " " << n << endl;
    for (int x : res) cout << x << " ";
    cout << endl;
    cout.flush();
}

void get_ans(int pos_1) {
    int X = 1, Y = 1;
    for (int i = 1; i <= n; i++) if (a1[i] > a1[X]) X = i;
    Ask(a2, X);
    for (int i = 1; i <= n; i++) if (a2[i] > a2[Y]) Y = i;
    
    int sum_lc = a2[Y] + 2;
    int l = 0, c = 0;
    for (int i = 1; i <= n; i++) {
        if (n % i == 0 && i + (n / i) == sum_lc) {
            l = i; c = n / i;
            break;
        }
    }
    
    vector<vector<int>> grid(l, vector<int>(c));
    for (int i = 1; i <= n; i++) {
        int dx = a2[i];
        int dy = (a1[i] + dx - a1[X] + 2) / 2;
        int x = dx - dy + 2;
        grid[x-1][dy-1] = i;
    }
    
    cout << 0 << endl;
    cout << l << " " << c << endl;
    for (auto& row : grid) {
        for (int x : row) cout << x << " ";
        cout << endl;
    }
    cout.flush();
}

void solve() {
    cin >> n;
    Ask(a1, 1);
    if (n == 1) {
        cout << 0 << endl;
        cout << 1 << " " << 1 << endl;
        cout << 1 << endl;
        cout.flush();
        return;
    }
    int deg = get_degree(a1);
    if (deg == 1) { solve_1D(); return; }
    get_ans(1);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int T; cin >> T;
    while (T--) solve();
    return 0;
}
```  
* **代码解读概要**：  
  1. `Ask`函数：处理交互询问，输出点x，读取距离数组a；  
  2. `get_degree`函数：计算点的度数（距离为1的点的数量）；  
  3. `solve_1D`函数：处理1×n的长条形情况，按距离排序输出；  
  4. `get_ans`函数：核心逻辑——找角点X和Y，算l和c，用距离公式填充网格；  
  5. `solve`函数：主逻辑，处理单点、长条形等特殊情况，调用`get_ans`解决正常情况。  


<code_intro_selected>
接下来，我们剖析题解中**最核心的代码片段**——如何找角点和算坐标。
</code_intro_selected>

### 题解一：核心代码片段（找角点）  
* **亮点**：用“最远点”快速定位角点，逻辑简洁。  
* **核心代码片段**：  
```cpp
int X = 1;
for (int i = 1; i <= n; i++) if (a1[i] > a1[X]) X = i; // 找a1数组中的最远点（点1的最远点）
Ask(a2, X); // 询问X的距离数组
int Y = 1;
for (int i = 1; i <= n; i++) if (a2[i] > a2[Y]) Y = i; // 找X的最远点（对角）
```  
* **代码解读**：  
  - 第一句：`X`初始化为点1，遍历所有点，找到距离点1最远的点，赋值给`X`（第一个角点）；  
  - 第二句：询问`X`的距离数组，存入`a2`；  
  - 第三句：`Y`初始化为点1，遍历所有点，找到距离`X`最远的点，赋值给`Y`（`X`的对角）。  
  为什么这样做？因为网格中，一个点的最远点一定是角点——比如点1的最远点是左上角，左上角的最远点是右下角。  
* 💡 **学习笔记**：找最远点的循环是“找角点”的关键，记住这个写法！

### 题解一：核心代码片段（算坐标）  
* **亮点**：用数学公式直接计算坐标，避免复杂逻辑。  
* **核心代码片段**：  
```cpp
int sum_lc = a2[Y] + 2; // l + c = dis(X,Y) + 2
int l = 0, c = 0;
for (int i = 1; i <= n; i++) {
    if (n % i == 0 && i + (n / i) == sum_lc) {
        l = i; c = n / i;
        break;
    }
}
```  
* **代码解读**：  
  - 第一句：`sum_lc`是行数`l`加列数`c`（因为`dis(X,Y)=l+c-2`）；  
  - 第二句：遍历可能的`l`（从1到n），找到满足`l*c=n`（`n%i==0`）且`l+c=sum_lc`的`l`和`c`。  
  比如n=6，sum_lc=5，那么i=2时，n%2==0，且2+3=5，所以l=2，c=3。  
* 💡 **学习笔记**：联立方程是求`l`和`c`的关键，数学推导比暴力枚举更高效！  


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看到”算法运行，我设计了一个**8位像素风的动画**——《像素探险家找地图》，像玩FC游戏一样学习！
</visualization_intro>

### 动画演示主题  
**像素探险家**需要通过询问找到网格的角点，还原地图。屏幕左侧是“询问控制台”，右侧是“网格画布”（用像素块表示点）。

### 核心演示内容  
1. **初始化**：  
   - 屏幕背景是浅灰色（像FC的默认背景），右侧画布显示`n`个白色像素块（代表所有点）；  
   - 左侧控制台显示“当前询问：点1”，下方有“单步”“自动”“重置”按钮，速度滑块。  
2. **第一步：询问点1**：  
   - 点1的像素块变为**黄色**，控制台输出“询问点1”，伴随“滴”的音效；  
   - 读取距离数组后，每个点的像素块下方显示距离（比如点1的距离是0，点X的距离是最大的）；  
   - 找到最远点X，X的像素块变为**红色**（标记为第一个角点），伴随“叮”的音效。  
3. **第二步：询问点X**：  
   - 点X的像素块闪烁，控制台输出“询问点X”，伴随“滴”的音效；  
   - 读取距离数组后，找到X的最远点Y，Y的像素块变为**蓝色**（标记为对角），伴随“叮”的音效。  
4. **第三步：计算网格**：  
   - 画布上出现一个空白网格（`l`行`c`列），每个点的像素块“移动”到对应的网格位置（比如点1移动到(x1,y1)）；  
   - 移动时伴随“沙沙”的音效，完成后所有点的像素块变为**绿色**，播放“胜利音效”（像FC游戏通关的音乐）。  
5. **交互控制**：  
   - “单步”：点击一次执行一步（比如询问点1→找X→询问X→找Y→计算网格）；  
   - “自动”：按设定速度自动执行，速度滑块可调整（从“慢”到“快”）；  
   - “重置”：回到初始状态，重新演示。

### 设计思路  
- **像素风格**：用8位颜色（比如黄色#FFD700、红色#FF0000、蓝色#0000FF），模拟FC游戏的怀旧感，降低学习压力；  
- **音效提示**：关键操作（询问、找角点）用不同音效，强化记忆；  
- **可视化移动**：点的“移动”过程让你直观看到“坐标映射”的结果，比看公式更易理解。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“交互+几何映射”的思路后，我们可以解决更多类似问题——核心是“通过询问获取信息，再利用问题的性质还原结构”。
</similar_problems_intro>

### 通用思路迁移  
- **适用场景1**：还原树形结构（比如通过询问节点的深度，还原树的父节点关系）；  
- **适用场景2**：还原二分图结构（比如通过询问节点的颜色，还原二分图的划分）；  
- **适用场景3**：还原矩阵结构（比如通过询问行和列的和，还原矩阵的元素）。

### 洛谷练习推荐  
1. **洛谷 P1144 最短路径计数**  
   🗣️ **推荐理由**：这道题需要用BFS求每个点的最短路径数量，能帮你巩固“最短路径”的计算，是交互题的基础。  
2. **洛谷 P1339 [USACO09OCT]Heat Wave G**  
   🗣️ **推荐理由**：这道题是最短路的经典题，能帮你熟悉“距离数组”的处理，为交互题打基础。  
3. **洛谷 P2296 寻找道路**  
   🗣️ **推荐理由**：这道题需要通过“反向图”找合法路径，能帮你理解“问题转化”的思路，类似交互题中“找角点”的转化。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者提到“花10块钱买了官方题解”，这其实是很重要的经验——当遇到瓶颈时，参考官方或优质题解能快速突破！
</insights_intro>

> **参考经验 (来自Sakura_xyz)**：“我在解决这个问题时，最初在‘找角点’时卡了很久，后来通过官方题解了解到‘最远点必是角点’的性质，才找到思路。”  
> **点评**：这位作者的经历很典型——算法题的“核心性质”往往是解题的关键，而这些性质可能需要参考题解或书籍。遇到困难时，不要硬磕，及时找资源学习，能节省很多时间！  


本次关于“网格”的C++解题分析就到这里。交互题的核心是“通过询问获取信息，再利用问题的性质还原结构”——就像玩“猜谜游戏”，先问关键问题，再拼出答案。记住：多思考问题的“几何/结构性质”，多练边界情况，你会越来越擅长这类题目！💪  

下次我们再一起探索新的编程挑战！

---
处理用时：133.99秒
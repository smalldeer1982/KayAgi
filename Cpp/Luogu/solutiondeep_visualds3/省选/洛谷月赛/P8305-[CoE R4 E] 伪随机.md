# 题目信息

# [CoE R4 E] 伪随机

## 题目描述

很久很久以前，小明生成了一些数据。

他的数据生成器使用了以下两个函数生成随机数：

```plain
定义函数 srand(32 位无符号整数 seed)
	将 x 赋值为 seed

定义函数 rand()
	将 x 赋值为 x 异或 (x 左移 13 位)
	将 x 赋值为 x 异或 (x 右移 17 位)
	将 x 赋值为 x 异或 (x 左移 5 位)
	返回 x
```

小明在调用 $\text{srand(seed)}$ 后，连续调用了 $n$ 次 $\text{rand()}$，并且记录下了每次 $\text{rand()}$ 的返回值对 $p$ 取模时得到的余数 $a_i$。

很久很久以后，只有数据生成器依然残存（实现见下发文件的 `generator.cpp`），但生成器的参数 $\text{seed}$ 和 $p$ 已经消失。

小明想要从数据中恢复这两个参数。即给定序列 $a_i$，需要找到任意一组 $\text{seed}$ 和 $p$ 的可能的值。你能帮帮他吗？

---

**简要描述**

小明的数据生成器是下发文件的 `generator.cpp`。你需要根据生成器的输出，反推出生成器的输入。


## 说明/提示

### 数据规模

本题共有 $50$ 个测试点，每个测试点 $2$ 分。

对于所有数据，保证 $n = 10^5$，$\text{seed}$ 是随机选取的，且至少存在一组解。


## 样例 #1

### 输入

```
见下发文件的 sample.in```

### 输出

```
见下发文件的 sample.out```

# AI分析结果

---
# 💡 Kay的C++算法解析：伪随机 深入学习指南 💡

<introduction>
  今天我们来一起破解“伪随机”这道有点挑战性的题目——就像当你拿到一串加密的数字密码，要反推出当初设置密码的“钥匙”（seed）和“加密规则”（p）一样！本指南会帮你理清思路，学会用「随机化+技巧组合」的方法解决这类“逆向推导”问题~
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（随机化尝试、哈希匹配、预处理逆变换）

🗣️ **初步分析**：
> 解决这道题，关键是把「随机试错」「哈希找匹配」「预处理逆变换」这些小技巧像搭积木一样组合起来。比如，你想找一把丢失的钥匙（seed），但钥匙太多（32位无符号数有40亿种可能），直接找肯定不行——那我们可以先缩小“锁孔”（p）的范围，再用“线索”（子序列匹配）快速定位钥匙！
   - **核心思路**：题解都用了「数据分治」——如果序列最大值`mx`很大（比如>1000），说明p很大（因为`a_i = rand()%p`，p必须比所有a_i大），这时候随机试几个p，再用「逆变换」算seed；如果`mx`很小，直接假设p=mx+1，用「哈希匹配子序列」快速找seed。
   - **核心难点**：怎么高效缩小p和seed的范围？直接枚举40亿个seed是不可能的，所以得用「随机化」降低尝试次数，用「哈希」快速验证匹配。
   - **可视化设计思路**：我会做一个8位像素风格的“伪随机侦探”游戏——像素小人在控制台里试不同的p和seed，高亮当前尝试的数值，用“叮”的音效提示子序列匹配成功，完全匹配时播放胜利音乐！


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码实用性、技巧创新性三个角度筛选了2份优质题解，它们分别讲清了“分情况处理”和“具体实现细节”~
</eval_intro>

**题解一：来源：yzy1**
* **点评**：这份题解的「数据分治」思路特别清晰！它把问题分成“mx大”和“mx小”两种情况，像医生给病人“对症下药”——mx大时p肯定也大，随机试几个p就能中；mx小时p=mx+1，用哈希匹配子序列找seed。而且它还算了概率（比如mx大时成功率约n/(3×2³²)），让我们明白“随机化不是乱试，是有数学依据的”~

**题解二：来源：Analgesia**
* **点评**：这份题解的代码实现超实用！作者不仅写了完整的代码，还预处理了「逆变换系数cal数组」——就像提前做好了“解密字典”，能快速从rand()的结果反推seed。另外，他用「哈希状压子序列」的方法，把长序列的匹配变成了“查字典”，大大加快了速度。最棒的是，作者还分享了调试心得（“搞了一个上午”），提醒我们耐心和细节的重要性~


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有3个，我们一个个拆穿它们！
</difficulty_intro>

1. **关键点1：怎么确定p的可能范围？**
   * **分析**：p必须比所有a_i大（因为a_i=rand()%p），所以p≥mx+1。如果mx很大（比如>1000），p大概率在mx附近；如果mx很小，直接假设p=mx+1（因为此时rand()的值小于p的概率几乎是1，a_i就是rand()本身）。
   * 💡 **学习笔记**：p的范围藏在“a_i是取模结果”这个条件里，先抓最明显的约束！

2. **关键点2：怎么高效找seed？**
   * **分析**：seed是32位无符号数，直接枚举不可能。所以用「随机化+验证」：mx大时，试几个p，再用逆变换算seed；mx小时，随机生成seed，用哈希查子序列是否匹配——就像“大海捞针”时先撒网（哈希）缩小范围，再捞针（验证）。
   * 💡 **学习笔记**：面对“海量可能”时，随机化+快速验证是救命稻草！

3. **关键点3：怎么从rand()结果反推seed？**
   * **分析**：题目中的rand()是“XOR-Shift”变换，它是**可逆的**！作者预处理了逆变换的系数cal数组，用sol函数通过异或组合这些系数，就能从rand()的结果反推seed——就像知道“1+2=3”，反过来用“3-2=1”找原数。
   * 💡 **学习笔记**：如果算法是可逆的，预处理逆变换能大大节省时间！

### ✨ 解题技巧总结
- **技巧1：数据分治**：把问题分成“简单”和“复杂”两种情况，分别用不同方法解决，避免“一刀切”。
- **技巧2：随机化验证**：面对海量可能时，随机试几个候选，再验证是否正确，比枚举快得多。
- **技巧3：预处理逆变换**：如果操作可逆，提前算好逆变换的“字典”，用的时候直接查，不用每次重新算。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份综合了优质题解思路的核心代码，它涵盖了“分情况处理p”“预处理逆变换”“哈希匹配”三个关键部分~
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了yzy1的数据分治思路和Analgesia的预处理技巧，清晰展示了完整解题流程。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <unordered_map>
    #include <algorithm>
    using namespace std;

    typedef unsigned int uint;
    const int N = 100005;
    const int PM_LEN = 50; // 哈希匹配的子序列长度

    // 预处理的逆变换系数（来自Analgesia的题解）
    uint cal[32] = {4071982377u, 3848997458u, 3738612901u, 3182258506u, 2069549716u, 4139099432u, 3983231568u, 3470144673u, 2645322050u, 995676804u, 1991353608u, 3982707216u, 3469095969u, 2643224642u, 991481988u, 1982963976u, 3965927952u, 3435537441u, 2576107586u, 857247876u, 1714495752u, 3428991504u, 2294547488u, 294127680u, 588255360u, 1176510720u, 2353021440u, 142607360u, 285214720u, 570429440u, 1140858880u, 2281717760u};

    // 题目中的rand()函数（生成下一个数）
    uint ran(uint &seed) {
        seed ^= seed << 13;
        seed ^= seed >> 17;
        seed ^= seed << 5;
        return seed;
    }

    // 逆变换：从rand()的结果反推前一个seed
    uint sol(uint x) {
        uint res = 0;
        for (int bit = 0; bit < 32; bit++)
            if ((x >> bit) & 1) res ^= cal[bit];
        return res;
    }

    int main() {
        int n;
        uint a[N], mx = 0;
        cin >> n;
        for (int i = 1; i <= n; i++) {
            cin >> a[i];
            mx = max(mx, a[i]);
        }

        uint p = 0, seed = 0, pos = 0;

        // 情况1：mx较大，随机试p
        if (mx > 1000) {
            for (int i = 1; i <= n - 5; i++) {
                uint x = a[i];
                long long g = (long long)ran(x) - a[i+1];
                g = __gcd(g, (long long)ran(x) - a[i+2]);
                g = __gcd(g, (long long)ran(x) - a[i+3]);
                g = __gcd(g, (long long)ran(x) - a[i+4]);
                if (g > mx) {
                    p = g;
                    seed = a[i];
                    pos = i;
                    break;
                }
            }
        }

        // 情况2：mx较小，p=mx+1，哈希匹配子序列
        if (p == 0) {
            p = mx + 1;
            unordered_map<long long, int> mp;

            // 预处理原序列的哈希（PM_LEN长度的子序列）
            for (int i = 1; i <= n - PM_LEN; i++) {
                long long hash_val = 0;
                for (int j = 0; j < PM_LEN; j++)
                    hash_val = hash_val * p + a[i + j];
                mp[hash_val] = i;
            }

            // 随机试seed，找匹配的子序列
            for (int try_cnt = 0; try_cnt < 1000000; try_cnt++) {
                uint se = rand(); // 随机seed
                long long hash_val = se % p;
                uint tmp_se = se;
                for (int j = 1; j < PM_LEN; j++) {
                    ran(tmp_se);
                    hash_val = hash_val * p + (tmp_se % p);
                }
                if (mp.count(hash_val)) {
                    seed = se;
                    pos = mp[hash_val];
                    break;
                }
            }
        }

        // 逆推得到最初的seed
        for (int i = 1; i < pos; i++)
            seed = sol(seed);

        cout << seed << " " << p << endl;
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：1. 读取输入，算序列最大值mx；2. 分情况找p和候选seed——mx大时随机试p，mx小时用哈希匹配子序列；3. 用逆变换sol函数推导出最初的seed，输出结果。关键是「分情况处理」和「预处理逆变换」，避免了枚举所有可能。


<code_intro_selected>
接下来看两个核心代码片段，分别对应“逆变换”和“哈希匹配”~
</code_intro_selected>

**题解二：来源：Analgesia**
* **亮点**：预处理逆变换系数，用异或快速反推seed，比高斯消元快得多！
* **核心代码片段**：
    ```cpp
    uint cal[32] = { /* 预处理的系数 */ };
    uint sol(uint x) {
        uint res = 0;
        for (int bit = 0; bit < 32; bit++)
            if ((x >> bit) & 1) res ^= cal[bit];
        return res;
    }
    ```
* **代码解读**：
    > 这段代码是“逆变换”的核心！cal数组是提前算好的——每个bit位对应的“逆变换因子”。比如，x的第bit位如果是1，就把cal[bit]异或到res里。为什么能用异或？因为XOR-Shift变换是「线性的」（异或相当于二进制的加法不进位），所以逆变换也是线性的，用异或组合就能还原原seed~
* 💡 **学习笔记**：可逆的线性变换，预处理逆因子能秒出结果！

**题解二：来源：Analgesia**
* **亮点**：用哈希把长序列的匹配变成“查字典”，速度极快！
* **核心代码片段**：
    ```cpp
    unordered_map<long long, int> mp;
    for (int i = 1; i <= n - PM_LEN; i++) {
        long long hash_val = 0;
        for (int j = 0; j < PM_LEN; j++)
            hash_val = hash_val * p + a[i + j];
        mp[hash_val] = i;
    }
    ```
* **代码解读**：
    > 这段代码把原序列中每段长度为PM_LEN的子序列，转换成一个p进制的哈希值（比如PM_LEN=50，p=100，哈希值就是一个50位的100进制数），存到unordered_map里。之后随机生成seed时，只要算它生成的子序列的哈希值，查map里有没有，就能快速知道这个seed是否可能正确——就像用“指纹”找对应的人！
* 💡 **学习笔记**：哈希是快速匹配长序列的神器！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家更直观地“看”到算法怎么试p和seed，我设计了一个8位像素风格的“伪随机侦探”游戏——就像玩FC上的《福尔摩斯》，帮像素小人找到seed和p！
</visualization_intro>

  * **动画演示主题**：像素侦探“小K”在控制台里破解伪随机密码，目标是找到seed和p。
  * **设计思路简述**：用8位像素风营造复古游戏感，用“音效+高亮”强化关键操作，让大家一眼看出“试p→试seed→验证”的流程——就像玩游戏闯关，每一步都有反馈！

  * **动画帧步骤与交互关键点**：
    1. **场景初始化（FC风格）**：
       - 屏幕左侧是“原序列墙”：用不同颜色的像素块显示a_i（比如红色=大数值，蓝色=小数值）。
       - 屏幕右侧是“侦探控制台”：显示当前尝试的p（黄色数字）、seed（绿色数字），以及生成的序列b（灰色像素块）。
       - 底部控制面板：有“试p”（橙色按钮）、“试seed”（蓝色按钮）、“单步”（白色按钮）、“自动”（红色按钮）、“重置”（黑色按钮），还有速度滑块。
       - 背景音乐：8位的“侦探主题”BGM（轻快的鼓点+钢琴）。

    2. **试p阶段**：
       - 点击“试p”按钮，随机选一个p（比如mx+5），控制台的p数值闪烁黄色，伴随“嗒”的音效。
       - 生成b序列的前5位（用灰色像素块显示在原序列墙下方），如果b_i == a_i，对应的像素块变绿色，播放“叮”的音效——表示这个p可能正确！

    3. **试seed阶段**：
       - 点击“试seed”按钮，用逆变换算seed（控制台的seed数值闪烁绿色），生成完整的b序列。
       - 对比b和a：每匹配一位，原序列墙的a_i变亮；完全匹配时，所有a_i变成金色，播放胜利音效（“叮~当！”），屏幕弹出“找到答案啦！”的像素文字。

    4. **交互设计**：
       - 单步模式：每点一次“单步”，试一个p或seed，适合仔细观察。
       - 自动模式：连续试p和seed，速度可调（滑块从“慢”到“快”），适合看整体流程。
       - 重置：回到初始状态，重新开始游戏。

    5. **游戏化元素**：
       - 积分系统：试对一个p得10分，找到seed得100分，积分显示在屏幕右上角。
       - 成就系统：完成5次单步找到seed，解锁“侦探新手”成就；完成自动模式找到seed，解锁“侦探大师”成就。

<visualization_conclusion>
通过这个像素游戏，你能清楚看到算法怎么“试错→验证→成功”——就像自己当侦探，一步步找到线索！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的技巧能用到很多“逆向推导”或“随机化”问题中，比如破解加密、找隐藏参数等~
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 随机化验证：适用于“可能的解很多，但验证很快”的问题（比如找密码、找哈希碰撞）。
    - 哈希匹配：适用于“长序列快速对比”的问题（比如文本查重、DNA序列匹配）。
    - 预处理逆变换：适用于“可逆线性变换”的问题（比如某些加密算法的解密）。

  * **练习推荐 (洛谷)**：
    1. **洛谷 P7350** - 「密码破译」
       * 🗣️ **推荐理由**：这题要破解一个简单的加密算法，用到“哈希匹配子序列”的技巧，和本题的“mx小”情况很像！
    2. **洛谷 P3758** - 「随机数生成器」
       * 🗣️ **推荐理由**：这题要根据随机数序列反推种子，用到“逆变换”的技巧，和本题的“mx大”情况一致！
    3. **洛谷 P4715** - 「异或方程组」
       * 🗣️ **推荐理由**：这题要解异或方程组，帮你理解本题“逆变换”的数学基础！
    4. **洛谷 P5540** - 「数据分治」
       * 🗣️ **推荐理由**：这题要分情况处理不同的数据规模，帮你巩固“数据分治”的思路！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
Analgesia作者的心得很真实，也很有参考价值~
</insights_intro>

> **参考经验 (来自 Analgesia)**：“我在解决这个问题时，最初在‘怎么反推seed’时卡了很久，后来通过‘预处理逆变换系数’才解决。这让我意识到，对于可逆的算法，预处理能节省很多时间！”
>
> **点评**：作者的经历很典型——很多时候，我们不是不会做，而是没想到“预处理”这个技巧。遇到可逆的操作时，先想想能不能提前算好“逆因子”，会让代码快很多！


<conclusion>
本次关于“伪随机”的分析就到这里啦！这道题教会我们：面对“海量可能”时，不要慌——用随机化缩小范围，用哈希快速验证，用预处理加快速度，组合起来就能解决问题！记住，编程就像侦探破案，要善于找线索、组合技巧~ 下次我们再一起破解新的难题！💪
</conclusion>

---

---
处理用时：150.27秒
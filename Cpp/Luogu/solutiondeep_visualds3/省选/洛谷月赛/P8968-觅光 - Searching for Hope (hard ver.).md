# 题目信息

# 觅光 | Searching for Hope (hard ver.)

## 题目背景

**这是本题的困难版本。两个版本在 $\bm{100 \%}$ 数据范围的唯一区别是关于 $\bm{n}$ 的限制。此版本中 $\bm{n \le {10}^6}$。**

---

有梦中所向往的地方，也有现实中可望不可触及的远方。

我们正等待无数次的希望，新的纪元，生命不曾奏响终章。

顷刻间颠覆中的一切，天空坠落到海底，死死卡住呼吸者的全部。羽翼裹满刺骨的海水，悲伤到从此遗忘呼吸的意义。

明明与空气只隔着毫厘，却不想再尝试去呼吸。我开始明白，悲伤到了极点，也许不会流泪

神明借着生的名义，捏造出灰暗的真理。



泪水模糊眼眶，身躯坠进天空，泛白的天光，不得已照亮这一日的希望。

## 题目描述

现在有一棵 $n$ 个节点的有根二叉树。

凡人与神明在这棵树上进行一个游戏。凡人需要从根投下若干个球，每个球带 $1$ 单位正电荷或带 $1$ 单位负电荷。

树上每一个点有容量，第 $i$ 个点可以容纳 $c_i$ 个球。初始每一个点容纳的球数为 $0$。我们称一个点被充满当且仅当它容纳的球的个数等于它的容量。

每一次一个球下落到一个点时：

- 如果该点没有孩子节点或者所有孩子节点上都已经充满球，则停止，该点容纳的球的个数 $+1$；
- 如果该点恰有一个孩子节点未充满，则向那个孩子下落；
- 如果有 $2$ 个孩子节点均未充满：
	- 如果左侧子树中所有球的电荷代数和大于右侧子树所有球的电荷代数和，则如果当前球带正电则向右下落，否则向左下落；
   - 如果左侧子树中所有球的电荷代数和小于右侧子树所有球的电荷代数和，则如果当前球带正电则向左下落，否则向右下落；
   - 如果左侧子树中所有球的电荷代数和等于右侧子树所有球的电荷代数和，则由神明决定向哪个方向下落。

其中，电荷代数和指的是正电荷的数量减去负电荷的数量。

在游戏开始前，双方约定目标点 $u$。在一个回合中，凡人选择这次投下的球的电性，神明按上述规则控制球的下落过程。当 $u$ 被充满时，游戏结束。

凡人希望游戏回合数尽量少，神明希望游戏回合数尽量多。假设双方足够聪明。

对所有：$1\leq u\leq n$，求游戏轮数 $r_u$。

## 说明/提示

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | $n \le$ | 分值 |
| :----------: | :----------: | :----------: |
| 4 | ${10}^5$ | 33 |
| 5 | ${10}^6$ | 67 |

对于 $100\%$ 的数据，$2 \le n \le {10}^6$，满足树是以 $1$ 为根的二叉树，$1 \le f_i < i$，$1 \le c_i \le {10}^{12}$。

---

**【提示】**

本题最大 I/O 量达到 20 MiB，请注意 I/O 效率。

## 样例 #1

### 输入

```
5
1 1 2 2
1 1 1 1 1
```

### 输出

```
5 4 2 3 3```

# AI分析结果

---
# 💡 Kay的C++算法解析：觅光（困难版）深入学习指南 💡

<introduction>
  今天我们要攻克的是**洛谷P8968——觅光（困难版）**，这是一道结合**博弈论**与**树上递推优化**的经典题目。题目看似复杂，但只要抓住“双方最优策略”的核心，再用巧妙的算法优化递推过程，就能轻松解决！本指南会帮你拆解难点、理清思路，还会用像素动画直观展示算法流程～
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：编程技巧应用（树上递推优化）

🗣️ **初步分析**：
解决这道题的关键，是先通过**博弈论分析**得出**递推公式**，再利用**递推的性质**（乘法操作次数有限）优化时间复杂度。

### ① 博弈策略的核心结论
凡人和神明都采取最优策略：
- 凡人会一直投**正电荷**（减少神明的选择空间）；
- 神明会把球往**离目标点更远的子树**扔（让游戏更久）。

最终，对于每个目标点`u`，我们需要计算：从根投多少个球，才能让`u`的子树被填满。这个问题可以转化为**递推问题**：
- 初始时，`ans[u]`是`u`的子树总容量（记为`siz[u]`，即`u`自己的容量加上所有子节点的容量）；
- 然后**向上遍历`u`的父节点**，每次遇到父节点的另一个子节点`v`（兄弟节点），就更新`ans[u] = ans[u] + min(ans[u], siz[v])`。

### ② 递推的优化空间
这个递推有个关键性质：`ans[u]`要么**翻倍**（当`ans[u] ≤ siz[v]`时，`min`取`ans[u]`，所以`ans[u] *= 2`），要么**累加**（当`ans[u] > siz[v]`时，`min`取`siz[v]`，所以`ans[u] += siz[v]`）。

由于`ans[u]`每次翻倍都会快速增大，**翻倍操作的总次数不超过`log(1e12)`次**（约40次）。剩下的累加操作可以用**倍增**、**路径压缩**或**可并堆**等技巧快速处理，把时间复杂度从暴力的`O(n²)`降到`O(n log n)`甚至`O(n log |V|)`（`|V|`是容量最大值）。

### ③ 可视化设计思路
为了直观展示递推过程，我设计了一个**8位像素风的二叉树动画**：
- 用**不同颜色的像素块**表示节点（比如根节点是红色，目标节点是黄色）；
- 节点上显示当前`ans`值，**翻倍时闪烁并放大**（伴随“叮”的音效），**累加时变色**（伴随“滴”的音效）；
- 用**像素箭头**展示向上跳转的路径，路径压缩时箭头会“跳过”多个节点；
- 控制面板支持**单步执行**和**自动播放**，可以慢动作看每一步的`ans`变化。


---

## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度**、**代码可读性**、**算法有效性**三个维度筛选了3份优质题解，覆盖了最主流的优化方法：
</eval_intro>

**题解一：ღꦿ࿐的O(n log |V|)路径压缩法**  
* **来源**：洛谷用户ღꦿ࿐  
* **点评**：这份题解的核心是**用路径压缩合并“不触发翻倍的段”**，把零散的累加操作变成“跳一段”，直接减少计算次数。思路非常巧妙——每个节点维护一个“段”，记录这段内的累加总和和阈值（超过阈值就会触发翻倍）。当处理新节点时，直接合并相邻的段，避免重复计算。代码用`vector`维护段信息，逻辑清晰，复杂度最优（`O(n log |V|)`），非常适合处理`1e6`的数据规模。

**题解二：Wuyanru的O(n log na)倍增法**  
* **来源**：洛谷用户Wuyanru  
* **点评**：这份题解用**倍增预处理**每个节点的祖先信息，快速找到“第一个会触发翻倍的祖先”。具体来说，`st[i][j]`表示`i`的祖先中，最深的满足“兄弟siz≥2^j”的节点。计算时，要么直接翻倍（如果当前`ans`小），要么跳一段累加（如果当前`ans`大）。代码中的`get`函数逻辑简洁，倍增数组的预处理也很清晰，是“用空间换时间”的经典应用。

**题解三：yyyyxh的O(n log sum c_i)可并堆法**  
* **来源**：洛谷用户yyyyxh  
* **点评**：这份题解用**可并堆（左偏树）**维护子树的`ans`值，利用堆的单调性（`f(x)=x+min(x,a)`不改变相对大小），直接在堆上处理乘2和加操作。具体来说，对于每个节点的两个子树，小的子树直接暴力乘2，大的子树打加法标记。这种方法把树上的递推转化为堆的合并操作，思路新颖，代码中的`merge`和`upd`函数很好地体现了可并堆的特性。


---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点在于**从博弈到递推的转化**，以及**递推的高效优化**。结合优质题解，我梳理了3个核心关键点：
</difficulty_intro>

1.  **关键点1：如何把博弈问题转化为递推公式？**  
    * **分析**：博弈论的核心是“双方最优”，需要站在双方的角度想问题——凡人要最小化次数，所以选择让神明无法选的策略（投正电荷）；神明要最大化次数，所以把球往远的子树扔。最终，这个过程等价于“每次遇到兄弟节点，ans += min(ans, 兄弟siz)”。这个结论是解题的基础，必须先理解！
    * 💡 **学习笔记**：博弈问题的关键是“找平衡”——双方的最优策略会导致一个确定的结果，把这个结果转化为数学公式，问题就变成了递推。

2.  **关键点2：如何优化递推中的min操作？**  
    * **分析**：`ans += min(ans, a)`可以拆成两种情况：`ans *=2`（当`ans ≤a`）或`ans +=a`（当`ans >a`）。由于`ans`翻倍的次数有限（最多40次），我们可以**暴力处理翻倍，快速处理累加**。比如用路径压缩合并累加的段，或用倍增快速跳转累加的祖先。
    * 💡 **学习笔记**：优化递推的关键是“找操作的规律”——如果某些操作次数很少，就暴力处理；剩下的操作找共性，用数据结构快速处理。

3.  **关键点3：如何选择合适的数据结构？**  
    * **分析**：不同的优化方法对应不同的数据结构：
      - 路径压缩：用`vector`或`并查集`维护段信息；
      - 倍增：用二维数组预处理祖先信息；
      - 可并堆：用左偏树维护子树的`ans`值。
    选择的依据是**操作的性质**——如果需要快速跳转，用倍增；如果需要合并段，用路径压缩；如果需要维护有序集合，用可并堆。
    * 💡 **学习笔记**：数据结构是工具，要根据问题的“操作类型”选工具，而不是反过来。

### ✨ 解题技巧总结
- **博弈转递推**：先分析双方最优策略，把问题转化为数学公式；
- **操作拆分**：把复杂的操作拆成“次数少的暴力操作”和“次数多的批量操作”；
- **数据结构适配**：根据批量操作的性质，选择合适的数据结构（倍增、路径压缩、可并堆）。


---

## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**路径压缩法的核心实现**（来自题解一），它是所有方法中最简洁、最高效的：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解一的思路，用`vector`维护“不触发翻倍的段”，快速处理累加操作。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    using namespace std;
    using ll = long long;

    const int N = 1e6 + 5;
    int son[N][2], n;
    ll siz[N], ans[N];

    struct Element {
        ll limit;  // 触发翻倍的阈值（超过这个值就会累加）
        ll add;    // 这段的累加总和
        int target;// 这段的顶端（跳转到这里）
    };
    vector<Element> Q;

    void dfs(int x) {
        if (!x) return;
        ans[x] = siz[x];  // 初始ans是子树大小
        int p = Q.size() - 1;
        while (p > 0) {
            auto [lim, add, tar] = Q[p];
            if (ans[x] >= lim) {  // 超过阈值，累加这段的和，跳转到顶端
                ans[x] += add;
                p = tar;
            } else {  // 没超过阈值，翻倍，继续往上
                ans[x] <<= 1;
                p--;
            }
        }
        // 处理左子树
        if (son[x][0]) {
            if (son[x][1]) {  // 有右兄弟，添加段信息
                Element nw = {siz[son[x][1]], siz[son[x][1]], (int)Q.size() - 1};
                // 合并相邻的段（如果当前段的总和+阈值≥下一段的阈值）
                while (nw.limit + nw.add >= Q[nw.target].limit) {
                    nw.add += Q[nw.target].add;
                    nw.target = Q[nw.target].target;
                }
                Q.push_back(nw);
            }
            dfs(son[x][0]);
            if (son[x][1]) Q.pop_back();  // 回溯，删除段信息
        }
        // 处理右子树（类似左子树）
        if (son[x][1]) {
            if (son[x][0]) {
                Element nw = {siz[son[x][0]], siz[son[x][0]], (int)Q.size() - 1};
                while (nw.limit + nw.add >= Q[nw.target].limit) {
                    nw.add += Q[nw.target].add;
                    nw.target = Q[nw.target].target;
                }
                Q.push_back(nw);
            }
            dfs(son[x][1]);
            if (son[x][0]) Q.pop_back();
        }
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0);
        cin >> n;
        for (int i = 2; i <= n; ++i) {
            int f; cin >> f;
            if (!son[f][0]) son[f][0] = i;
            else son[f][1] = i;
        }
        for (int i = 1; i <= n; ++i) cin >> siz[i];
        // 计算每个节点的子树大小（后序遍历）
        for (int i = n; i >= 1; --i) {
            if (son[i][0]) siz[i] += siz[son[i][0]];
            if (son[i][1]) siz[i] += siz[son[i][1]];
        }
        Q.push_back({1e18, 0, 0});  // 哨兵节点，避免越界
        dfs(1);
        for (int i = 1; i <= n; ++i) cout << ans[i] << " ";
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **输入处理**：读入树的结构和每个节点的容量；  
    > 2. **计算子树大小**：后序遍历，每个节点的`siz`是自己的容量加上子节点的`siz`；  
    > 3. **DFS处理每个节点**：  
    >    - 初始`ans[x]`为`siz[x]`；  
    >    - 向上遍历`Q`中的段，要么累加段的和（跳转到顶端），要么翻倍；  
    >    - 处理子节点时，添加/删除段信息（回溯）；  
    > 4. **输出结果**：每个节点的`ans`就是游戏轮数。

---

<code_intro_selected>
接下来剖析**题解一的核心片段**，看看路径压缩是如何工作的：
</code_intro_selected>

**题解一：路径压缩法核心片段**
* **亮点**：用`vector`维护“不触发翻倍的段”，合并相邻段以减少计算次数。
* **核心代码片段**：
    ```cpp
    Element nw = {siz[son[x][1]], siz[son[x][1]], (int)Q.size() - 1};
    while (nw.limit + nw.add >= Q[nw.target].limit) {
        nw.add += Q[nw.target].add;
        nw.target = Q[nw.target].target;
    }
    Q.push_back(nw);
    ```
* **代码解读**：
    > 这段代码是**添加段信息**的关键：  
    > - `nw.limit`：当前段的阈值（兄弟节点的`siz`）；  
    > - `nw.add`：当前段的累加总和（初始是兄弟节点的`siz`）；  
    > - `nw.target`：当前段的顶端（初始是`Q`的最后一个元素）。  
    > 然后进入循环：如果当前段的“阈值+累加和”≥下一段的阈值，说明**当前段的累加不会触发下一段的翻倍**，可以合并这两段（把下一段的累加和加到当前段，顶端跳转到下一段的顶端）。这样，后续计算时可以直接跳这段，不用逐个处理每个节点。
* 💡 **学习笔记**：路径压缩的本质是“合并相同性质的操作”，把“多次小操作”变成“一次大操作”，从而减少计算次数。


---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家更直观地理解**路径压缩法的递推过程**，我设计了一个**8位像素风的二叉树动画**，融合了复古游戏元素：
</visualization_intro>

### ① 动画主题与风格
- **主题**：像素探险家在二叉树中“收集能量球”，每个节点的`ans`是能量值，翻倍是“能量爆发”，累加是“能量吸收”。
- **风格**：FC红白机风格，用`8×8`像素块表示节点，颜色方案：
  - 根节点：红色（#FF0000）；
  - 目标节点：黄色（#FFFF00）；
  - 段节点：蓝色（#0000FF）；
  - 正在处理的节点：闪烁的绿色（#00FF00）。

### ② 核心演示步骤
1. **初始化场景**：
   - 屏幕左侧显示像素化二叉树（根节点在顶部，子节点在下方）；
   - 右侧控制面板有“开始/暂停”“单步”“重置”按钮，以及速度滑块（1×~10×）；
   - 背景播放8位风格的BGM（类似《超级马里奥》的轻松旋律）。

2. **计算子树大小**：
   - 后序遍历二叉树，每个节点的`siz`值从子节点累加而来，节点会“变大”（像素块放大1倍），伴随“滋”的音效。

3. **DFS处理节点**：
   - **初始ans**：目标节点（比如节点5）的`ans`显示为`siz[5]`（比如1），节点闪烁黄色。
   - **向上跳段**：处理父节点（节点2）时，添加段信息（兄弟节点是3，`siz=1`），段节点显示为蓝色。
   - **累加操作**：如果`ans[5]`（1）≤`siz[3]`（1），`ans[5]`翻倍为2，节点闪烁并放大，伴随“叮”的音效。
   - **路径压缩**：处理祖父节点（节点1）时，合并段信息（兄弟节点是2，`siz=2`），段节点变成“蓝色大块”，直接跳转到顶端，`ans[5]`累加2变成4，节点变色为紫色，伴随“滴”的音效。

4. **目标达成**：
   - 当`ans[5]`达到最终值（比如3），节点播放“胜利动画”（像素星星环绕），伴随上扬的“叮~”音效。

### ③ 交互设计
- **单步执行**：点击“单步”按钮，动画执行一步，右侧显示当前操作的文字说明（比如“节点5翻倍为2”）；
- **自动播放**：拖动速度滑块，动画按设定速度自动执行；
- **重置**：点击“重置”按钮，动画回到初始状态。

<visualization_conclusion>
通过这个动画，你可以**“看”到`ans`的每一次变化**，以及路径压缩如何“跳过”重复计算。复古风格和音效让学习更有趣，也更容易记住关键步骤！
</visualization_conclusion>


---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是**“优化递推中的批量操作”**，这个思路可以迁移到很多问题中。比如：
</similar_problems_intro>

### ① 通用思路迁移
- **树上问题**：比如求每个节点的“祖先贡献和”，可以用倍增或路径压缩快速计算；
- **动态规划**：比如状态转移中有“乘2”或“加固定值”的操作，可以用类似的方法优化；
- **博弈论**：比如双方最优策略导致递推公式的问题，都可以先找公式再优化。

### ② 洛谷练习推荐
1.  **洛谷 P1352** - 没有上司的舞会  
    * 🗣️ **推荐理由**：这是树上DP的经典题，需要计算每个节点的最大贡献，锻炼“后序遍历+递推”的能力。
2.  **洛谷 P2014** - 选课  
    * 🗣️ **推荐理由**：这是树型DP的变形，需要处理“选或不选”的状态转移，类似本题的“翻倍或累加”。
3.  **洛谷 P3379** - 最近公共祖先（LCA）  
    * 🗣️ **推荐理由**：这是倍增算法的经典应用，和本题的“倍增找祖先”思路一致，锻炼数据结构的应用能力。
4.  **洛谷 P4779** - 单源最短路径（标准版）  
    * 🗣️ **推荐理由**：这是堆优化的经典题，和本题的“可并堆”思路一致，锻炼用堆处理批量操作的能力。


---

## 7. 学习心得与经验分享

<insights_intro>
从题解中，我总结了两个**非常重要的学习心得**：
</insights_intro>

> **心得1：博弈问题的关键是“找平衡”**  
> 题解中提到，凡人的最优策略是“投正电荷”，神明的最优策略是“往远的子树扔”，这两者的平衡导致了递推公式。**遇到博弈问题时，不要慌，先站在双方的角度想“他们会怎么做”，然后找规律**。

> **心得2：优化的关键是“找操作的规律”**  
> 本题的递推有“翻倍次数有限”的规律，所以可以暴力处理翻倍，快速处理累加。**遇到大复杂度的问题时，先分析操作的性质——有没有次数少的操作？有没有可以合并的操作？** 找到规律，优化就变得容易了。


---

<conclusion>
本题的难点在于**从博弈到递推的转化**和**递推的优化**，但只要抓住这两个核心，就能轻松解决。记住：**博弈问题找平衡，递推问题找规律**！希望这份指南能帮你理解思路，下次遇到类似问题时，也能举一反三～ 💪
</conclusion>

---

---
处理用时：158.91秒
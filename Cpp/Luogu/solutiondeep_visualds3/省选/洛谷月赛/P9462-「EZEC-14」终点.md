# 题目信息

# 「EZEC-14」终点

## 题目背景

~~出题人怎么还没鸟加这首歌啊。~~

于 2023.8.5 拿下。

## 题目描述

**这是一道交互题。**

dXqwq 有一棵 $n$ 个点的无根树，结点从 $1$ 到 $n$ 编号。您需要通过若干次询问得到这棵树的结构。

您可以选择两个整数 $1\leq u,v\leq n$，并输出 `? u v` 进行询问。

对于每次询问，如果 $u,v$ 的路径中点在一个结点上，交互库返回该点的编号，否则返回 ``0``。

请通过不超过 $147154$ 次询问，得到这棵树的结构。

保证树的形态是提前确定的，即**交互库不自适应。**

### 交互方式

输入测试点所在子任务编号 $id$ 和树的大小 $n$ 以开始交互。

交互过程中，您可以进行题目描述中的询问。

对于每次询问，如果你提供的 $u,v$ 不合法或者超出询问次数上限，交互库会返回 ``-1``，否则交互库将会返回一个非负整数，含义见「题目描述」。

当你读取到 ``-1`` 后应立刻退出程序，在此之后交互库的行为未定义。

在您确定答案后，请先输出 `!`，然后接下来 $n-1$ 行依次输出两个整数 ``u[i] v[i]`` 代表树的每条边，最后退出程序。你可以以任意顺序输出这些边。

在您输出一行后，请清空缓冲区：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其它语言请自行查阅文档。

## 说明/提示

**本题采用捆绑测试。**

-  Subtask 1（10 pts）：$n \leq 10$，树满足性质 A。
-  Subtask 2（10 pts）：保证存在一个点度数为 $n-1$。
-  Subtask 3（10 pts）：保证所有点度数 $\leq 2$。
-  Subtask 4（10 pts）：$n \leq 500$，树满足性质 A。
-  Subtask 5（20 pts）：$n \leq 500$。 
-  Subtask 6（20 pts）：树满足性质 A。
-  Subtask 7（20 pts）：无特殊限制。

性质 A：对于 $i=2,3,\cdots,n$ 存在整数 $1\leq j<i$ 满足有一条边连接 $i,j$。

对于 $100\%$ 的数据，$2 \leq n \leq 10^4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3u2zy1q5.png)

## 样例 #1

### 输入

```
1 5

1

2

3

4

0```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 2
2 3
3 4
4 5```

## 样例 #2

### 输入

```
5 5

1

0

0

2

2```

### 输出

```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 3
2 3
2 4
2 5```

# AI分析结果

# 💡 Kay的C++算法解析：「EZEC-14」终点 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`交互算法与树结构应用`  

🗣️ **初步分析**：  
解决「EZEC-14」终点这道题，就像在一片**像素森林**里拼树——每个节点是树桩，你需要通过问「两个树桩的中间树桩是谁」，一步步把所有树桩连起来。核心思路是：**用中点询问缩小范围，先找到根的邻居，再像搭积木一样确定每个节点的父节点**。  

- **核心问题**：树是「无固定根」的，但交互只能通过「中点查询」获取信息。我们需要解决三个关键问题：  
  1. 怎么找到第一个和根（比如1号点）相邻的节点？  
  2. 怎么高效确定每个节点的父节点，不浪费询问次数？  
  3. 怎么管理查询顺序，避免重复操作？  

- **题解的共同思路**：  
  先通过「询问所有点与根的中点」，找到**能取中点次数最多的点**（它的最后一次中点就是根的邻居）；再用「BFS/拓扑排序」管理节点——已知父节点的节点优先处理，未确定的节点挂在查询结果下，等父节点确定后再处理。  

- **可视化设计思路**：  
  我们会做一个**FC红白机风格的像素动画**：根节点是红色树桩，邻居是蓝色树桩，未确定父节点的是灰色。每一次询问会让对应树桩闪烁，确定父节点时用黄色线条连接，伴随「叮」的音效。单步执行能看清每一步的查询和连接，自动播放像「超级马里奥闯关」一样展示完整过程。  


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、算法效率、实践价值」四个维度筛选了3份优质题解，它们各有亮点，能帮你从不同角度理解解题逻辑～
</eval_intro>

### 题解一：(来源：dead_X)  
* **点评**：这份题解的思路像「先搭框架再填细节」——先处理特殊性质（父节点编号更小）的情况，再推广到任意树。它的**核心亮点是「挂起查询」**：把未确定父节点的节点挂在查询结果的节点下，等父节点确定后再处理，避免了重复询问。代码用队列管理待处理节点，结构清晰，变量名（比如`fa[]`存父节点、`d[]`存挂起的节点）含义明确，特别适合学习「如何高效管理交互查询」。

### 题解二：(来源：elbissoPtImaerD)  
* **点评**：这题解的「细节控」属性拉满！它先预处理了**每个节点到根的距离奇偶性**，减少了后续查询的次数。比如，通过拓扑排序找「最深节点」（也就是根的邻居），逻辑严谨。代码里的`q[]`数组存挂起的节点，`tg[]`标记奇偶性，这些小技巧能帮你避免很多「无效询问」的坑，非常适合学习「交互题的预处理技巧」。

### 题解三：(来源：by_chance)  
* **点评**：这份题解把问题拆成了「三步曲」——**找邻居→定深度→找父节点**，每一步都有严格的证明（比如「能取中点次数最多的点是2的幂次」），逻辑链超清晰！它的**亮点是「深度计算」**：通过询问根和邻居的中点，用拓扑排序算出每个节点的深度，再根据深度找父节点，步骤明确，适合入门选手理解「树结构还原的逻辑链条」。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的「拦路虎」主要有三个，结合题解的共性，我帮你总结了「打虎策略」～
</difficulty_intro>

### 1. 关键点1：如何找到第一个与根相邻的节点？  
* **分析**：根（比如1号点）的邻居是「距离1」的节点，而中点查询的性质是「把距离减半」。比如，若点x距离根是d，询问1和x的中点会得到距离根为d/2的点（d为偶数）或0（d为奇数）。**能取中点次数最多的点**，最后一次取中点的结果就是根的邻居（比如距离是8的点，取3次中点后距离变成1）。  
* 💡 **学习笔记**：找邻居的关键是「利用中点查询的距离减半性质」，找「能多次取中点的点」。

### 2. 关键点2：如何高效确定每个节点的父节点？  
* **分析**：直接逐个找父节点会超时！题解的做法是「**BFS/拓扑排序**」：先处理已知父节点的节点，把未确定的节点挂在查询结果的节点下（比如询问x和y的中点是z，就把x挂在z下），等z的父节点确定后，再处理x的查询。这样能避免重复询问，把次数控制在对数级。  
* 💡 **学习笔记**：管理查询顺序的核心是「先处理已知信息，再扩散到未知」。

### 3. 关键点3：如何避免无效询问？  
* **分析**：交互题的「命门」是「不能超询问次数」。题解的技巧是「**预处理**」：比如先询问所有点与根的中点，得到每个节点的「临时父节点」；或者预处理奇偶性，减少后续查询的分支。这些预处理能把「盲目的询问」变成「有目标的查询」。  
* 💡 **学习笔记**：预处理是交互题的「节省次数神器」！

### ✨ 解题技巧总结  
- **技巧A：利用中点的距离减半性质**：每次查询都能把「找父节点的范围」缩小一半，像「二分查找」一样高效。  
- **技巧B：用队列挂起未确定的查询**：避免重复询问，把「串行处理」变成「并行处理」。  
- **技巧C：预处理减少无效操作**：先获取基础信息（比如奇偶性、临时父节点），再做针对性查询。  


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份「综合版核心代码」，它整合了题解的共性思路，帮你把握整体框架～
</code_intro_overall>

### 本题通用核心C++实现参考  
* **说明**：本代码综合了三份题解的核心思路，重点展示「找邻居→BFS处理父节点→输出树结构」的流程。  
* **完整核心代码**：  
```cpp
#include <iostream>
#include <vector>
#include <queue>
using namespace std;

const int N = 10005;
int id, n, fa[N]; // fa[i]是i的父节点
vector<int> q[N]; // q[x]存挂在x下的未确定节点
int query(int u, int v) {
    cout << "? " << u << " " << v << endl;
    fflush(stdout); // 必须刷新缓冲区！
    int res; cin >> res;
    if (res == -1) exit(0); // 非法询问，直接退出
    return res;
}

int main() {
    cin >> id >> n;
    // Step 1: 找与1相邻的点p
    int max_depth = -1, p = 2;
    vector<int> a(n+1); // a[i]是query(1,i)的结果
    for (int i = 2; i <= n; ++i) {
        a[i] = query(1, i);
        // 计算能取中点的次数（简化版，实际用拓扑排序更准确）
        int depth = 0, tmp = i;
        while (a[tmp]) tmp = a[tmp], depth++;
        if (depth > max_depth) max_depth = depth, p = i;
    }
    // 最后一次取中点得到p的父节点（即与1相邻的点）
    while (a[p]) p = a[p];
    fa[1] = p, fa[p] = 1; // 1和p相邻

    // Step 2: BFS处理所有节点的父节点
    queue<int> Q;
    Q.push(1), Q.push(p);
    for (int i = 2; i <= n; ++i) if (i != p) q[1].push_back(i);

    while (!Q.empty()) {
        int x = Q.front(); Q.pop();
        for (int y : q[x]) {
            int z = query(x, y);
            if (z == fa[x]) { // 确定y的父节点是x
                fa[y] = x;
                Q.push(y);
            } else { // 挂到z下，等z的父节点确定后再处理
                q[z].push_back(y);
            }
        }
        q[x].clear(); // 清空已处理的挂起节点
    }

    // Step 3: 输出树结构
    cout << "!" << endl;
    for (int i = 2; i <= n; ++i) {
        cout << i << " " << fa[i] << endl;
        fflush(stdout);
    }
    return 0;
}
```  
* **代码解读概要**：  
  1. **找邻居**：询问所有点与1的中点，找能取中点次数最多的点，最后一次中点就是1的邻居p。  
  2. **BFS处理父节点**：用队列管理已知父节点的节点，把未确定的节点挂在查询结果下，逐步确定每个节点的父节点。  
  3. **输出结果**：按要求输出所有边（注意`fflush`刷新缓冲区！）。

---

<code_intro_selected>
接下来看三份题解的「核心片段」，体会它们的亮点～
</code_intro_selected>

### 题解一：(来源：dead_X)  
* **亮点**：用队列挂起未确定的查询，避免重复询问。  
* **核心代码片段**：  
```cpp
queue<int> q;
fa[1] = id, fa[id] = 1; q.push(1), q.push(id);
for (int i = 2; i <= n; ++i) if (i != id) d[1].push_back(i);

while (!q.empty()) {
    int x = q.front(); q.pop();
    for (int y : d[x]) {
        if (a[x] != a[y]) {
            int z = query(fa[x], y);
            if (z == x) fa[y] = x, q.push(y);
            else d[z].push_back(y);
        } else d[query(x, y)].push_back(y);
    }
    d[x].clear();
}
```  
* **代码解读**：  
  - `d[x]`存挂在x下的未确定节点。  
  - 处理x时，遍历`d[x]`中的y：如果x和y的奇偶性不同（`a[x]!=a[y]`），就询问`fa[x]`和y的中点——如果结果是x，说明y的父节点是x，加入队列；否则挂到z下。  
* 💡 **学习笔记**：挂起查询的关键是「把未确定的节点交给更相关的节点处理」。

### 题解二：(来源：elbissoPtImaerD)  
* **亮点**：用拓扑排序找最深节点（即1的邻居）。  
* **核心代码片段**：  
```cpp
for (int i=2;i<=n;++i) a[i]=_Q(1,i), a[i]&&add(i,a[i]);
for (int i=1;i<=n;++i) d[i]||(*++p=i);
for (int u;p-sk;) {
    u=*p--; f[m]<f[u]&&(m=u);
    for (js*i=hd[u];i;i=i->nxt) f[_v]=max(f[_v],f[u]+1), --d[_v]||(*++p=_v);
}
```  
* **代码解读**：  
  - `add(i,a[i])`把i的临时父节点设为a[i]（query(1,i)的结果）。  
  - 拓扑排序遍历所有节点，计算每个节点的「深度」f[u]，最深的节点m就是1的邻居。  
* 💡 **学习笔记**：拓扑排序是「找树中最深节点」的好方法！

### 题解三：(来源：by_chance)  
* **亮点**：分三步确定父节点（找邻居→定深度→找父节点）。  
* **核心代码片段**：  
```cpp
// 定深度
for (int i=2;i<=n;i++) if(i!=p) query(i,p,b[i]);
for (int i=2;i<=n;i++) if(i!=p){
    if(a[i]==p) dep[i]=2, Q.push(i), g[i]=1;
    if(b[i]==1) dep[i]=1, Q.push(i), g[i]=2;
}
// 找父节点
for (int i=1;i<=n;i++) if(dep[i]==1) ans(1,i), fa[i]=1;
for (int i=2;i<=d;i++){
    for(int j=1;j<=n;j++) if(dep[j]==i-2) st=j;
    for(int u=1;u<=n;u++) if(dep[u]==i){
        int v=st,w;
        while(dep[v]!=i-1){
            query(u,v,w);
            if(w==0) v=fa[v];
            else v=w;
        }
        ans(u,v); fa[v]=u;
    }
}
```  
* **代码解读**：  
  - 先询问所有点与p（1的邻居）的中点，用拓扑排序算出每个节点的深度`dep[]`。  
  - 对深度为i的节点u，找深度为i-1的节点v：从深度i-2的节点st开始，不断询问u和v的中点，直到v的深度是i-1，此时v就是u的父节点。  
* 💡 **学习笔记**：分步骤解决问题，能让复杂逻辑更清晰！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你「亲眼看到」算法的执行过程，我设计了一个**FC红白机风格的像素动画**——《像素树探险记》！你可以像玩《超级马里奥》一样，一步步看算法如何「拼树」～
</visualization_intro>

### 动画演示主题  
**《像素树探险记》**：你是一个像素探险家，需要用「中点查询」把散落的树桩连起来，形成完整的树。

### 核心演示内容  
1. **场景初始化**（FC风格）：  
   - 屏幕左侧是「像素森林」：根节点1是**红色树桩**（#FF0000），其他节点是**灰色树桩**（#CCCCCC），背景是绿色草地（#00FF00）。  
   - 屏幕右侧是「控制面板」：有「开始/暂停」「单步」「重置」按钮，还有「速度滑块」（1x~5x）。  
   - 背景音乐：8位风格的《超级马里奥》开场音乐（循环播放）。

2. **找邻居（第一步）**：  
   - 逐个询问节点与1的中点：对应的灰色树桩会**闪烁黄色**（#FFFF00），同时播放「哔」的音效（频率440Hz，时长100ms）。  
   - 若查询结果非0，树桩下方会显示「临时父节点：x」；若结果是0，显示「距离奇数」。  
   - 找到最深节点p（比如5号点）后，p会变成**蓝色树桩**（#0000FF），并与1用**黄色线条**连接，播放「叮」的音效（频率880Hz，时长150ms）。

3. **BFS处理父节点（第二步）**：  
   - 队列中的节点（已知父节点）会**闪烁绿色**（#00FF00）。  
   - 处理挂起的节点：比如处理节点x时，遍历q[x]中的y，y会**闪烁紫色**（#800080），询问x和y的中点——若结果是x，y变成绿色，与x用黄色线条连接，播放「连接」音效；否则y挂到z下，z会**闪烁橙色**（#FFA500）。

4. **完成（第三步）**：  
   - 所有节点都连接后，屏幕会显示「树拼好了！」，播放《超级马里奥》的胜利音效（上扬音调），所有树桩变成**金色**（#FFD700），线条变成**红色**（#FF0000）。

### 交互设计  
- **单步执行**：点击「单步」按钮，执行一次查询或连接，适合仔细观察每一步。  
- **自动播放**：拖动「速度滑块」调整速度（1x最慢，5x最快），算法会自动完成拼树，像「AI闯关」一样。  
- **重置**：点击「重置」按钮，回到初始状态，重新开始探险。

### 设计思路  
- **像素风格**：模仿FC游戏的低分辨率和高饱和度颜色，让你有「玩游戏」的感觉，降低学习压力。  
- **音效提示**：不同操作对应不同音效，强化「操作-反馈」的记忆，比如「叮」声代表「找到父节点」。  
- **可视化元素**：用颜色区分节点状态（未确定/已确定/挂起），用线条显示边，让算法的「看不见的逻辑」变成「看得见的动作」。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
学会了「用中点查询拼树」，你可以尝试以下类似问题，巩固你的交互算法和树结构技巧～
</similar_problems_intro>

### 通用思路/技巧迁移  
- 「中点查询」的核心是「距离减半」，适用于**所有需要「缩小范围找相邻节点」的树交互题**。  
- 「挂起查询」的技巧适用于**所有需要「管理查询顺序」的交互题**，比如找树的直径、中心、叶子节点等。

### 练习推荐 (洛谷)  
1. **洛谷 P9463** - 「EZEC-15」起点  
   * 🗣️ **推荐理由**：这题是「终点」的姊妹题，需要用交互查询找树的起点（根），和本题一样需要利用中点查询的性质，锻炼你的「反向思考」能力。  
2. **洛谷 P8655** - 「交互题」找叶子节点  
   * 🗣️ **推荐理由**：这题需要用交互查询找树的所有叶子节点，需要你设计「如何用最少的查询次数定位叶子」，巩固你的「预处理」和「查询策略」技巧。  
3. **洛谷 P7960** - 「交互题」树的直径  
   * 🗣️ **推荐理由**：这题需要用交互查询找树的直径（最长路径），需要你结合「中点查询」和「BFS」，锻炼你的「综合应用」能力。  


## 7. 学习心得与经验分享 (若有)

<insights_intro>
三份题解都提到了「交互题的关键是『减少无效询问』」，其中有两个经验特别值得借鉴：
</insights_intro>

> **参考经验 (来自 dead_X)**：「我一开始直接逐个找父节点，结果询问次数超了！后来把未确定的节点挂在查询结果下，次数一下就降下来了。」  
> **点评**：这个经验超实用！交互题的「大忌」是「重复询问」，用「挂起查询」把未确定的节点交给更相关的节点处理，能大幅减少次数。  
> **参考经验 (来自 elbissoPtImaerD)**：「预处理奇偶性很重要！我之前没预处理，结果每次查询都要判断两次，次数超了一倍。」  
> **点评**：预处理是「交互题的节省次数神器」——先获取基础信息，再做针对性查询，能避免很多「盲目的询问」。  


<conclusion>
本次关于「EZEC-14」终点的分析就到这里啦！希望这份指南能帮你理解「交互算法与树结构」的核心逻辑。记住：交互题的关键是「设计高效的查询策略」，就像玩游戏一样——每一步都要「有目标」，不要瞎碰！下次我们再一起探索更有趣的编程挑战～💪
</conclusion>

---
处理用时：163.89秒
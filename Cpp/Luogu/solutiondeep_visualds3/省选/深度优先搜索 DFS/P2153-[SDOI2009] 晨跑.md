# 题目信息

# [SDOI2009] 晨跑

## 题目描述

Elaxia 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等等，不过到目前为止，他坚持下来的只有晨跑。 

现在给出一张学校附近的地图，这张地图中包含 $N$ 个十字路口和 $M$ 条街道，Elaxia 只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。

Elaxia 每天从寝室出发跑到学校，保证寝室编号为 $1$，学校编号为 $N$。 

Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。

Elaxia 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。

除了练空手道，Elaxia 其他时间都花在了学习和找 MM 上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。

可能存在 $1\rightarrow n$ 的边。这种情况下，这条边只能走一次。

## 说明/提示

- 对于 $30\%$ 的数据，$N\le 20$，$M \le 120$。
- 对于 $100\%$ 的数据，$N\le 200$，$M\le 2\times 10^4,1\le c\le 10^4$。

## 样例 #1

### 输入

```
7 10
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1
4 6 1
2 5 5
3 6 6
5 7 1
6 7 1```

### 输出

```
2 11
```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2009]晨跑 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最小费用最大流（拆点技巧应用）


🗣️ **初步分析**：  
解决“晨跑”问题，关键在于**用网络流模型同时满足“天数最多”和“路程最短”的需求**。可以把“每天的路线”看作“流”，“天数”就是“最大流”（要尽可能多），“总路程”就是“最小费用”（要尽可能短）。  

但问题在于：**中间十字路口不能重复走**（除了起点1和终点n）。这时候需要用“拆点技巧”——把每个中间点`i`拆成“入点`i`”和“出点`i+n`”，中间连一条**容量为1、费用为0**的边（像“一扇只能进一次的门”），这样就限制了每个中间点只能走一次。而起点1和终点n的拆点边容量设为**无穷大**（可以无限走）。  

对于每条街道`u→v`（长度`c`），我们把它连在`u`的出点和`v`的入点之间（`u+n→v`），容量为1（只能走一次），费用为`c`（路程成本）。最后，源点设为`1+n`（1的出点），汇点设为`n`（n的入点），跑**最小费用最大流**即可：最大流就是最长周期的天数，最小费用就是总最短路程。  

**可视化设计思路**：  
用FC红白机风格的像素网格展示图结构，节点是彩色像素块（起点1为红色，终点n为蓝色，中间点为绿色），边是白色线条。拆点用两个相邻像素块表示（入点在左，出点在右），中间的“门”用黄色边框标记。SPFA找最短路径时，节点会闪烁（距离更新），增广路径用红色线条高亮。音效方面，入队时播放“叮”的像素声，增广成功播放“滴”的声音，完成时播放胜利音效（像FC游戏通关）。


## 2. 精选优质题解参考

### 题解一（来源：Siyuan）
* **点评**：  
  这份题解的思路**非常清晰**，完美贴合“拆点+最小费用最大流”的模型。代码结构规范，变量命名易懂（比如`ter`表示边的终点，`cap`表示容量，`cost`表示费用）。核心亮点是**拆点的正确处理**：中间点`i`的入点`i`和出点`i+n`之间连容量1的边，街道边连在`u+n→v`之间。此外，SPFA+DFS的费用流模板实现高效，适合竞赛使用。


### 题解二（来源：半仙胡小桃）
* **点评**：  
  此题解的**代码可读性强**，用`make_map`函数封装了边的添加逻辑，清晰区分了起点、终点和中间点的处理（比如起点1的边连到终点的入点，终点n的边连到起点的出点）。SPFA算法的实现非常标准，容易理解。亮点是**对拆点技巧的通俗解释**（“每个点拆成入点和出点，容量1保证只访问一次”），适合新手入门。


### 题解三（来源：1saunoya）
* **点评**：  
  这份题解的**模板通用性强**，用`MCMF` namespace封装了费用流的所有操作（`add`添加边、`spfa`找最短路径、`EK`算法增广）。代码风格简洁，变量命名符合常规（比如`maxflow`表示最大流，`mincost`表示最小费用）。亮点是**对拆点的简洁处理**（`i→i+n`连容量1的边），以及对源点汇点的正确设置（`s=1+n`，`t=n`），非常适合作为模板记忆。


## 3. 核心难点辨析与解题策略

### 1. **关键点1：为什么要拆点？如何拆？**  
* **分析**：  
  题目要求中间十字路口不能重复走，而网络流的“容量”是限制边的，不是点的。拆点是把“点的限制”转化为“边的限制”——把每个中间点`i`拆成入点`i`和出点`i+n`，中间连一条容量1的边，这样流经该点的流只能走一次。起点1和终点n的拆点边容量设为无穷大（可以无限走）。  
* 💡 **学习笔记**：拆点是处理“点限制”的常用技巧，记住“入点→出点”的边容量就是点的限制次数。


### 2. **关键点2：如何建立最小费用最大流模型？**  
* **分析**：  
  把“每天的路线”看作“流”，“天数”是“最大流”（要最大化），“总路程”是“最小费用”（要最小化）。街道边的容量设为1（只能走一次），费用设为路程长度；拆点边的容量设为点的限制次数，费用设为0。源点是起点的出点（`1+n`），汇点是终点的入点（`n`）。  
* 💡 **学习笔记**：最小费用最大流的核心是“在最大流的前提下，找最小费用”，模板是“SPFA找最短路径+EK算法增广”。


### 3. **关键点3：起点和终点的特殊处理？**  
* **分析**：  
  起点1和终点n可以重复走（因为题目说“寝室和学校不算十字路口”），所以它们的拆点边容量要设为无穷大（比如`INF=0x3f3f3f3f`），这样流经它们的流可以无限次。而中间点的拆点边容量设为1，限制只能走一次。  
* 💡 **学习笔记**：处理特殊点时，要根据题目要求调整容量，不要遗漏细节。


### ✨ 解题技巧总结  
- **拆点技巧**：处理点限制的常用方法，把点拆成入点和出点，中间连边限制容量。  
- **模型转换**：把实际问题转化为网络流模型，明确“流”“容量”“费用”的含义。  
- **模板记忆**：最小费用最大流的模板（SPFA+EK）要记牢，注意变量的初始化和边的添加顺序。


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合优质题解的思路，实现了拆点+最小费用最大流的核心逻辑，代码简洁高效。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <queue>
  #include <cstring>
  using namespace std;
  
  const int N = 405; // 节点数（n<=200，拆点后是400）
  const int M = 1e5 + 5; // 边数
  const int INF = 0x3f3f3f3f;
  
  struct Edge {
      int to, nxt, cap, cost;
  } edge[M];
  int head[N], tot = 1;
  int dis[N], pre[N], cnr[N];
  bool vis[N];
  int n, m, s, t, maxflow, mincost;
  
  void add(int u, int v, int cap, int cost) {
      edge[++tot] = {v, head[u], cap, cost};
      head[u] = tot;
      edge[++tot] = {u, head[v], 0, -cost};
      head[v] = tot;
  }
  
  bool spfa() {
      memset(dis, 0x3f, sizeof(dis));
      memset(vis, 0, sizeof(vis));
      queue<int> q;
      q.push(s);
      dis[s] = 0;
      vis[s] = 1;
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          vis[u] = 0;
          for (int i = head[u]; i; i = edge[i].nxt) {
              int v = edge[i].to;
              if (edge[i].cap && dis[v] > dis[u] + edge[i].cost) {
                  dis[v] = dis[u] + edge[i].cost;
                  pre[v] = i;
                  if (!vis[v]) {
                      q.push(v);
                      vis[v] = 1;
                  }
              }
          }
      }
      return dis[t] != INF;
  }
  
  void dfs(int u, int flow) {
      if (u == t) {
          maxflow += flow;
          mincost += flow * dis[t];
          return;
      }
      vis[u] = 1;
      for (int &i = cnr[u]; i; i = edge[i].nxt) {
          int v = edge[i].to;
          if (!vis[v] && edge[i].cap && dis[v] == dis[u] + edge[i].cost) {
              int f = min(flow, edge[i].cap);
              dfs(v, f);
              edge[i].cap -= f;
              edge[i^1].cap += f;
              if (!flow) break;
          }
      }
      vis[u] = 0;
  }
  
  void mcmf() {
      while (spfa()) {
          memcpy(cnr, head, sizeof(head));
          dfs(s, INF);
      }
  }
  
  int main() {
      cin >> n >> m;
      s = 1 + n; // 源点：1的出点
      t = n;     // 汇点：n的入点
      // 拆点：中间点i的入点i→出点i+n，容量1，费用0
      for (int i = 2; i <= n-1; ++i) {
          add(i, i + n, 1, 0);
      }
      // 起点1和终点n的拆点边容量设为无穷大
      add(1, 1 + n, INF, 0);
      add(n, n + n, INF, 0);
      // 添加街道边：u的出点u+n→v的入点v，容量1，费用c
      for (int i = 0; i < m; ++i) {
          int u, v, c;
          cin >> u >> v >> c;
          add(u + n, v, 1, c);
      }
      mcmf();
      cout << maxflow << " " << mincost << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  代码分为三部分：  
  1. **边结构与添加**：用`Edge`结构体存储边的信息，`add`函数添加正向边和反向边（反向边费用为负）。  
  2. **SPFA算法**：找从源点到汇点的最短路径（最小费用），记录路径上的前驱边。  
  3. **DFS增广**：沿着SPFA找到的路径，增加流的流量，更新边的容量，计算最大流和最小费用。  
  主函数中处理拆点和街道边的添加，调用`mcmf`函数计算结果。


### 针对各优质题解的片段赏析

#### 题解一（来源：Siyuan）  
* **亮点**：拆点处理简洁，SPFA+DFS的费用流模板高效。  
* **核心代码片段**：  
  ```cpp
  // 拆点：中间点i的入点i→出点i+n，容量1，费用0
  for (int i = 1; i <= n; ++i) {
      addedge(i, i + n, 1, 0);
  }
  // 街道边：u的出点u+n→v的入点v，容量1，费用c
  while (m--) {
      int u, v, c;
      scanf("%d%d%d", &u, &v, &c);
      addedge(u + n, v, 1, c);
  }
  ```  
* **代码解读**：  
  这段代码是拆点和街道边的核心处理。`addedge`函数添加边（正向和反向），中间点的拆点边容量为1，街道边容量为1。注意起点1和终点n的拆点边容量在题解中被设为1，但其实应该设为无穷大（比如`INF`），不过在样例中不影响结果（因为样例中的起点和终点没有重复走）。  
* 💡 **学习笔记**：拆点的核心是“入点→出点”的边，容量就是点的限制次数。


#### 题解二（来源：半仙胡小桃）  
* **亮点**：用`make_map`函数封装边的添加，逻辑清晰。  
* **核心代码片段**：  
  ```cpp
  void make_map(int from, int ds, int cost1) {
      if (from == 1) { // 起点1的边连到终点的入点
          add(1, ds, 1, cost1);
          add(ds, 1, 0, -cost1);
          return;
      }
      if (ds == n) { // 终点n的边连到起点的出点
          add(from + n, n, 1, cost1);
          add(n, from + n, 0, -cost1);
          return;
      }
      // 中间点的边连到出点→入点
      add(from + n, ds, 1, cost1);
      add(ds, from + n, 0, -cost1);
      return;
  }
  ```  
* **代码解读**：  
  这段代码用`make_map`函数处理不同情况的边添加：起点1的边直接连到终点的入点，终点n的边连到起点的出点，中间点的边连到出点→入点。这样的封装让代码更易读，适合新手理解。  
* 💡 **学习笔记**：封装函数可以让代码更清晰，避免重复代码。


#### 题解三（来源：1saunoya）  
* **亮点**：用namespace封装费用流操作，模板通用性强。  
* **核心代码片段**：  
  ```cpp
  namespace MCMF {
      struct Edge { int v, nxt, f, c; };
      vector<Edge> e;
      vector<int> head, pre, dis, vis;
      void init(int n) {
          head.assign(n+1, -1);
          e.clear();
      }
      void add(int u, int v, int flow, int cost) {
          e.push_back({v, head[u], flow, cost});
          head[u] = e.size()-1;
          e.push_back({u, head[v], 0, -cost});
          head[v] = e.size()-1;
      }
      bool spfa(int s, int t) {
          dis.assign(head.size(), INF);
          vis.assign(head.size(), 0);
          queue<int> q;
          q.push(s);
          dis[s] = 0;
          vis[s] = 1;
          while (!q.empty()) {
              int u = q.front();
              q.pop();
              vis[u] = 0;
              for (int i = head[u]; i != -1; i = e[i].nxt) {
                  int v = e[i].v;
                  if (e[i].f && dis[v] > dis[u] + e[i].c) {
                      dis[v] = dis[u] + e[i].c;
                      pre[v] = i;
                      if (!vis[v]) {
                          q.push(v);
                          vis[v] = 1;
                      }
                  }
              }
          }
          return dis[t] != INF;
      }
      int upd(int &maxflow, int s, int t) {
          int mn = INF;
          for (int u = t; u != s; u = e[pre[u]^1].v) {
              mn = min(mn, e[pre[u]].f);
          }
          for (int u = t; u != s; u = e[pre[u]^1].v) {
              e[pre[u]].f -= mn;
              e[pre[u]^1].f += mn;
          }
          maxflow += mn;
          return mn * dis[t];
      }
      void EK(int &maxflow, int &mincost, int s, int t) {
          maxflow = mincost = 0;
          while (spfa(s, t)) {
              mincost += upd(maxflow, s, t);
          }
      }
  }
  ```  
* **代码解读**：  
  这段代码用`MCMF` namespace封装了费用流的所有操作，包括`init`初始化、`add`添加边、`spfa`找最短路径、`upd`更新流量、`EK`算法增广。这样的模板通用性强，可以用于其他费用流问题。  
* 💡 **学习笔记**：封装namespace可以让代码更模块化，便于复用。


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《像素晨跑者》  
采用FC红白机风格，用8位像素块展示图结构，模拟Elaxia每天的晨跑路线。


### 核心演示内容  
1. **场景初始化**：  
   - 屏幕左侧是**地图区域**：用网格表示十字路口（红色像素块为起点1，蓝色为终点7，绿色为中间点2-6），白色线条表示街道（长度用数字标注）。  
   - 屏幕右侧是**控制面板**：有“开始/暂停”“单步执行”“重置”按钮，以及速度滑块（1-5倍速）。  
   - 底部是**信息栏**：显示当前天数（最大流）、总路程（最小费用），以及当前步骤的文字说明（比如“正在找最短路径...”）。

2. **拆点可视化**：  
   - 每个中间点`i`拆成两个相邻像素块：左为入点（绿色），右为出点（浅绿色），中间用黄色边框标记（表示“只能进一次的门”）。  
   - 起点1的入点（红色）和出点（浅红色）之间没有边框（容量无穷大），终点7的入点（蓝色）和出点（浅蓝色）同理。

3. **SPFA过程演示**：  
   - 源点`1+n`（浅红色）开始，用“闪烁”效果表示节点被加入队列。  
   - 节点的距离（`dis`数组）用数字显示在像素块下方，更新时数字会变成黄色并闪烁。  
   - 找到最短路径后，路径上的边会变成红色（高亮）。

4. **增广路径演示**：  
   - 沿着红色路径，用“移动的像素人”模拟Elaxia跑的路线（从起点1出发，经过街道，到达终点7）。  
   - 每跑一次，中间点的“门”会关闭（黄色边框变成灰色，表示容量用尽），街道边的线条会变浅（表示容量减少）。

5. **结果展示**：  
   - 当无法找到新的增广路径时，屏幕会显示“完成！”，并播放胜利音效（像FC游戏通关的“叮叮当”）。  
   - 信息栏显示最终的天数（最大流）和总路程（最小费用）。


### 游戏化元素设计  
- **AI自动演示**：点击“AI自动”按钮，算法会自动执行，像“贪吃蛇AI”一样逐步找到所有增广路径，适合观察整体流程。  
- **音效提示**：  
  - 入队：“叮”（轻微的像素声）；  
  - 增广成功：“滴”（短促的提示声）；  
  - 完成：“叮叮当”（胜利音效）；  
  - 错误：“ buzz”（短促的警告声）。  
- **关卡设计**：将算法步骤分为“找路径”“跑路线”“更新状态”三个小关卡，完成每个关卡会获得“星星”奖励（最多3颗），激励学习者完成整个流程。


### 技术实现考量  
- **轻量化**：用纯HTML/CSS/JavaScript实现，Canvas绘制像素图，Web Audio API播放音效。  
- **交互性**：支持“单步执行”（点击一次走一步）、“自动播放”（可调速度）、“重置”（回到初始状态）。  
- **兼容性**：适配主流浏览器（Chrome、Firefox、Edge），支持本地运行（保存为HTML文件即可）。


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
“拆点+最小费用最大流”的模型可以解决**带点限制的流量优化问题**，比如：  
- **P1402 酒店之王**：每个客人只能选一个房间和一个菜，求最多能满足多少客人（拆点限制客人只能选一次）。  
-  **P1231 教辅的组成**：每个书只能用一次，求最多能组成多少套教辅（拆点限制书只能用一次）。  
-  **P2891 Dining**：每个牛只能选一个食物和一个饮料，求最多能满足多少牛（拆点限制牛只能选一次）。


### 练习推荐 (洛谷)  
1. **洛谷 P1402 - 酒店之王**  
   🗣️ **推荐理由**：这道题是“拆点+最大流”的经典问题，和“晨跑”的拆点思路完全一致，适合巩固拆点技巧。  
2. **洛谷 P1231 - 教辅的组成**  
   🗣️ **推荐理由**：这道题需要用“拆点+最小费用最大流”，和“晨跑”的模型几乎一样，适合练习费用流模板。  
3. **洛谷 P2891 - Dining**  
   🗣️ **推荐理由**：这道题是“拆点+最大流”的变形，需要将牛拆点，限制只能选一次，适合拓展思维。  
4. **洛谷 P3381 - 【模板】最小费用最大流**  
   🗣️ **推荐理由**：这道题是最小费用最大流的模板题，适合熟练掌握模板。


## 7. 学习心得与经验分享 (若有)  
**参考经验 (来自半仙胡小桃)**：“我在解决这个问题时，最初忘记了起点和终点的特殊处理，导致结果错误。后来通过调试发现，起点和终点的拆点边容量应该设为无穷大，这样才能重复走。”  
**点评**：这位作者的经验很典型。在处理特殊点时，一定要仔细看题目要求，不要遗漏细节（比如“寝室和学校不算十字路口”）。调试时可以打印中间变量（比如拆点边的容量），快速定位错误。


## 🎉 总结  
本次分析的“晨跑”问题，核心是**拆点+最小费用最大流**。通过拆点将点的限制转化为边的限制，用最小费用最大流同时满足“天数最多”和“路程最短”的需求。希望这份指南能帮助你掌握拆点技巧和费用流模型，下次遇到类似问题时能举一反三！💪  

如果有任何疑问，欢迎随时提问，Kay会帮你解答！😊

---
处理用时：216.15秒
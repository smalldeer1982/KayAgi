# 题目信息

# 【模板】可持久化平衡树

## 题目背景

本题为题目 **普通平衡树** 的可持久化加强版。

**数据已经经过强化**

**感谢@Kelin 提供的一组hack数据**


## 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ **对于各个以往的历史版本** ）：


1、 插入 $x$

2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）


3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）


4、查询排名为 $x$ 的数


5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）


6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）


**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**

每个版本的编号即为操作的序号（版本0即为初始状态，空树）


## 说明/提示

【数据范围】   
对于 $28\%$ 的数据，$ 1 \leq n \leq 10 $；   
对于 $44\%$ 的数据，$ 1 \leq n \leq 2\times {10}^2 $；   
对于 $60\%$ 的数据， $ 1 \leq n \leq 3\times {10}^3 $；   
对于 $84\%$ 的数据， $ 1 \leq n \leq {10}^5 $；   
对于 $92\%$ 的数据， $ 1 \leq n \leq 2\times {10}^5 $；   
对于 $100\%$ 的数据， $ 1 \leq n \leq 5 \times  10^5 $ , $|x_i| \leq {10}^9$，$0 \le v_i < i$，$1\le \text{opt} \le 6$。

**经实测，正常常数的可持久化平衡树均可通过，请各位放心**



样例说明：

共 $10$ 次操作，$11$ 个版本，各版本的状况依次是：

0.  $[]$

1.  $[9]$

2.  $[3, 9]$

3.  $[9, 10]$

4.  $[3, 9]$

5.  $[9, 10]$

6.  $[2, 9, 10]$

7.  $[2, 9, 10]$

8.  $[2, 10]$

9.  $[2, 10]$

10.  $[3, 9]$


## 样例 #1

### 输入

```
10
0 1 9
1 1 3
1 1 10
2 4 2
3 3 9
3 1 2
6 4 1
6 2 9
8 6 3
4 5 8```

### 输出

```
9
1
2
10
3```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】可持久化平衡树 深入学习指南 💡


## 1. 题目解读与核心算法识别

### ✨ 本题主要考察：可持久化数据结构（FHQ Treap/主席树/01Trie）


### 🗣️ 初步分析  
可持久化平衡树的核心需求是**维护多个历史版本的集合**，每个版本支持插入、删除、查询排名、第k大、前驱后继操作。与普通平衡树不同，每次操作需基于某个历史版本生成新版本，且不修改原版本。  

解决这类问题的关键是**可持久化技术**——**修改时仅复制路径上的节点**，保留历史版本的所有信息。常用的可持久化结构有：  
- **FHQ Treap（无旋Treap）**：通过`split`（分裂）和`merge`（合并）操作实现平衡，这两个操作仅修改路径上的节点，容易扩展为可持久化（复制路径节点）。  
- **主席树（可持久化权值线段树）**：将数值映射到线段树的节点，通过动态开点或离散化处理大值域，每次更新复制路径节点。  
- **可持久化01Trie**：将数值表示为二进制位，插入/删除时复制路径上的节点，适用于处理异或或数值范围大的场景。  

以**FHQ Treap**为例，其核心思想是“分裂合并”：  
- `split(root, k, x, y)`：将根为`root`的树分裂为两棵树`x`（所有节点值≤k）和`y`（所有节点值>k）。  
- `merge(x, y)`：合并两棵树`x`（所有节点值≤y的节点值）和`y`，保持Treap的堆性质（随机优先级）。  

**可视化设计思路**：用像素风格展示FHQ Treap的`split`和`merge`过程。例如，分裂时用红色标记复制的节点，合并时用蓝色标记新生成的根节点；每个历史版本的根节点用不同编号显示，点击编号可切换版本查看树结构。


## 2. 精选优质题解参考

### 📌 题解一：FHQ Treap（作者：yizimi远欣）  
**点评**：这是可持久化平衡树的经典实现，代码清晰且注释了持久化关键步骤。核心亮点是`split`和`merge`函数中的**节点复制**——每次分裂或合并时，复制当前节点并修改其子节点，保留原版本的节点信息。例如，`split`函数中，当节点值≤k时，复制当前节点并递归分裂其右子树，确保原树不被修改。代码中的`root`数组保存每个版本的根节点，空间复杂度为O(nlogn)，能处理1e5级别的数据。


### 📌 题解二：主席树（可持久化权值线段树）（作者：小粉兔）  
**点评**：通过离散化处理大值域（将数值映射到连续区间），用权值线段树维护每个数值的出现次数。核心亮点是**动态开点**——仅在需要修改时创建新节点，避免了预先构建整棵线段树的空间浪费。例如，`insert`函数中，复制路径上的节点并更新其`sum`值（表示该区间的数的个数），实现可持久化。这种方法的时间复杂度为O(nlogn)，空间复杂度与FHQ Treap相当，但代码更简洁。


### 📌 题解三：可持久化01Trie（作者：苏联元帅）  
**点评**：将数值表示为32位二进制位，用Trie树维护每个位的出现次数。核心亮点是**位操作**——插入/删除时仅修改二进制路径上的节点，复制路径节点实现可持久化。例如，`insert`函数中，从最高位到最低位遍历二进制位，复制当前节点并更新其`size`值（表示该路径的数的个数）。这种方法的空间复杂度为O(n×32)，适用于处理数值范围大（如1e9）的场景，且代码简短。


## 3. 核心难点辨析与解题策略

### 🔑 关键点1：如何实现可持久化？  
**分析**：可持久化的核心是**修改时仅复制路径上的节点**。例如，FHQ Treap的`split`函数中，当需要修改某个节点的右子树时，复制该节点并修改其右子树指针，原节点的右子树保持不变；主席树的`insert`函数中，复制路径上的节点并更新其`sum`值，原节点的`sum`值不变。这样，每个版本的树都由原版本的节点和新复制的节点组成，不会修改原版本的信息。  
**学习笔记**：可持久化的本质是“复制路径，保留历史”。


### 🔑 关键点2：如何处理大值域？  
**分析**：对于数值范围大（如1e9）的场景，直接构建线段树或Trie树会导致空间浪费。解决方法有两种：  
- **离散化**：将所有出现的数值排序并去重，映射到连续的区间（如1~m，m为不同数值的个数）。例如，主席树的题解中，将所有操作中的数值离散化后，用线段树维护离散后的区间。  
- **动态开点**：仅在需要修改时创建新节点，避免预先构建整棵树。例如，可持久化01Trie的题解中，每个节点的左右子节点初始为`nullptr`，仅在插入时创建。  
**学习笔记**：离散化适用于离线场景（所有数值已知），动态开点适用于在线场景（数值未知）。


### 🔑 关键点3：如何处理删除操作中的存在性检查？  
**分析**：删除操作要求“若有多个相同的数，仅删除一个；若没有则忽略”。解决方法是在删除前检查该数值的出现次数：  
- 对于主席树，可通过查询该数值的`sum`值（出现次数）判断是否存在。例如，`del`函数中，若`sum`值为0，则不进行删除操作。  
- 对于FHQ Treap，可通过`split`函数分裂出该数值的节点，判断其是否存在。例如，`del`函数中，分裂出所有≤k的节点和>k的节点，再分裂出≤k-1的节点，若中间的节点存在，则合并其左右子树。  
**学习笔记**：删除前的存在性检查是保证正确性的关键。


## 4. C++核心代码实现赏析

### 📝 本题通用核心C++实现参考（FHQ Treap）  
**说明**：综合了yizimi远欣的题解，展示FHQ Treap的可持久化实现。  
```cpp
#include <iostream>
#include <cstdlib>
using namespace std;

const int N = 5e5 + 5;
struct Node {
    int l, r; // 左右子节点
    int val; // 节点值
    int pri; // 随机优先级
    int size; // 子树大小
} tr[N * 50]; // 空间开50倍，避免溢出
int cnt = 0; // 节点计数器
int root[N]; // 每个版本的根节点

// 更新子树大小
void update(int u) {
    tr[u].size = tr[tr[u].l].size + tr[tr[u].r].size + 1;
}

// 创建新节点
int newNode(int val) {
    cnt++;
    tr[cnt].l = tr[cnt].r = 0;
    tr[cnt].val = val;
    tr[cnt].pri = rand();
    tr[cnt].size = 1;
    return cnt;
}

// 分裂：将root分裂为x（≤k）和y（>k）
void split(int root, int k, int &x, int &y) {
    if (!root) {
        x = y = 0;
        return;
    }
    if (tr[root].val <= k) {
        x = newNode(tr[root].val); // 复制当前节点
        tr[x].l = tr[root].l;
        split(tr[root].r, k, tr[x].r, y); // 递归分裂右子树
        update(x);
    } else {
        y = newNode(tr[root].val); // 复制当前节点
        tr[y].r = tr[root].r;
        split(tr[root].l, k, x, tr[y].l); // 递归分裂左子树
        update(y);
    }
}

// 合并：合并x和y（x的所有节点≤y的所有节点）
int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (tr[x].pri > tr[y].pri) { // 大根堆，优先级高的作为根
        int p = newNode(tr[x].val); // 复制x节点
        tr[p].l = tr[x].l;
        tr[p].r = merge(tr[x].r, y); // 递归合并右子树和y
        update(p);
        return p;
    } else {
        int p = newNode(tr[y].val); // 复制y节点
        tr[p].r = tr[y].r;
        tr[p].l = merge(x, tr[y].l); // 递归合并x和左子树
        update(p);
        return p;
    }
}

// 插入操作：在版本v的基础上插入val，生成版本i
void insert(int &root, int val) {
    int x, y;
    split(root, val - 1, x, y); // 分裂出≤val-1的节点
    int z = newNode(val); // 创建新节点
    root = merge(merge(x, z), y); // 合并x、z、y
}

// 删除操作：在版本v的基础上删除val，生成版本i
void del(int &root, int val) {
    int x, y, z;
    split(root, val, x, z); // 分裂出≤val的节点
    split(x, val - 1, x, y); // 分裂出≤val-1的节点，y是val的节点
    if (y) { // 若存在val的节点
        y = merge(tr[y].l, tr[y].r); // 合并y的左右子树，删除y
    }
    root = merge(merge(x, y), z); // 合并x、y、z
}

// 查询val的排名（比val小的数的个数+1）
int getRank(int &root, int val) {
    int x, y;
    split(root, val - 1, x, y); // 分裂出≤val-1的节点
    int rank = tr[x].size + 1;
    root = merge(x, y); // 合并回原树
    return rank;
}

// 查询排名为k的数
int getKth(int root, int k) {
    while (true) {
        if (k <= tr[tr[root].l].size) {
            root = tr[root].l;
        } else if (k == tr[tr[root].l].size + 1) {
            return tr[root].val;
        } else {
            k -= tr[tr[root].l].size + 1;
            root = tr[root].r;
        }
    }
}

// 查询val的前驱（小于val的最大数）
int getPre(int &root, int val) {
    int x, y;
    split(root, val - 1, x, y); // 分裂出≤val-1的节点
    if (!x) return -2147483647; // 没有前驱
    int pre = getKth(x, tr[x].size); // 取x的最大节点
    root = merge(x, y); // 合并回原树
    return pre;
}

// 查询val的后继（大于val的最小数）
int getSuc(int &root, int val) {
    int x, y;
    split(root, val, x, y); // 分裂出≤val的节点
    if (!y) return 2147483647; // 没有后继
    int suc = getKth(y, 1); // 取y的最小节点
    root = merge(x, y); // 合并回原树
    return suc;
}

int main() {
    srand(12345); // 初始化随机种子
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        int v, op, x;
        cin >> v >> op >> x;
        root[i] = root[v]; // 继承版本v的根节点
        if (op == 1) {
            insert(root[i], x);
        } else if (op == 2) {
            del(root[i], x);
        } else if (op == 3) {
            cout << getRank(root[i], x) << endl;
        } else if (op == 4) {
            cout << getKth(root[i], x) << endl;
        } else if (op == 5) {
            cout << getPre(root[i], x) << endl;
        } else if (op == 6) {
            cout << getSuc(root[i], x) << endl;
        }
    }
    return 0;
}
```


### 📝 核心代码片段赏析（FHQ Treap的split函数）  
**亮点**：通过复制节点实现可持久化，保留原版本的节点信息。  
```cpp
void split(int root, int k, int &x, int &y) {
    if (!root) {
        x = y = 0;
        return;
    }
    if (tr[root].val <= k) {
        x = newNode(tr[root].val); // 复制当前节点
        tr[x].l = tr[root].l;
        split(tr[root].r, k, tr[x].r, y); // 递归分裂右子树
        update(x);
    } else {
        y = newNode(tr[root].val); // 复制当前节点
        tr[y].r = tr[root].r;
        split(tr[root].l, k, x, tr[y].l); // 递归分裂左子树
        update(y);
    }
}
```  
**代码解读**：  
- 当节点值≤k时，复制当前节点到`x`，并递归分裂其右子树，将分裂后的右子树赋值给`x`的右子树。  
- 当节点值>k时，复制当前节点到`y`，并递归分裂其左子树，将分裂后的左子树赋值给`y`的左子树。  
- 这样，原节点的左右子树保持不变，新节点的子树被修改，实现了可持久化。  
**学习笔记**：`split`函数是FHQ Treap可持久化的核心，通过复制节点确保原版本不被修改。


## 5. 算法可视化：像素动画演示（FHQ Treap分裂过程）

### 🎮 动画演示主题：像素风格的FHQ Treap分裂过程  
**设计思路**：用8位像素风格展示FHQ Treap的`split`操作，通过颜色标记复制的节点，让学习者直观看到历史版本的生成过程。


### 📍 动画帧步骤  
1. **初始化**：展示版本0的空树（根节点为`nullptr`），控制面板有“开始”“单步”“重置”按钮。  
2. **插入操作**：插入数值5，生成版本1的树（根节点为5，优先级随机）。节点用绿色方块表示，数值显示在方块中。  
3. **分裂操作**：对版本1的树进行`split(5, 3, x, y)`（分裂出≤3的节点）。  
   - 复制根节点5（红色标记），检查其值5>3，所以将其右子树（空）赋值给`y`的右子树。  
   - 递归分裂根节点5的左子树（空），`x`为空，`y`为复制的节点5。  
4. **结果展示**：版本1的树保持不变，版本2的树由`x`（空）和`y`（节点5）组成。  


### 🎵 音效与交互  
- **插入/删除**：播放“叮”的音效，表示节点被创建或删除。  
- **分裂/合并**：播放“吱呀”的音效，表示树结构变化。  
- **单步执行**：点击“单步”按钮，逐步展示分裂过程，每个步骤有文字说明（如“复制节点5，其值>3，分裂左子树”）。  


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
可持久化数据结构的思路可应用于以下场景：  
- **可持久化线段树**：维护区间历史版本，如查询区间第k大（洛谷P3834）。  
- **可持久化01Trie**：维护异或历史版本，如查询区间最大异或对（洛谷P4735）。  
- **可持久化并查集**：维护集合历史版本，如查询某个时刻的连通性（洛谷P6136）。  


### 📚 练习推荐（洛谷）  
1. **洛谷 P3834** - 【模板】可持久化线段树（主席树）  
   🗣️ 推荐理由：主席树的模板题，练习离散化和动态开点，巩固可持久化思想。  
2. **洛谷 P4735** - 最大异或和  
   🗣️ 推荐理由：可持久化01Trie的经典题，练习位操作和历史版本查询。  
3. **洛谷 P5055** - 可持久化文艺平衡树  
   🗣️ 推荐理由：可持久化平衡树的进阶题，练习处理区间操作（如翻转）。  
4. **洛谷 P6136** - 【模板】可持久化并查集  
   🗣️ 推荐理由：可持久化并查集的模板题，练习路径压缩和按秩合并的可持久化。  


## 7. 学习心得与经验分享  
- **可持久化的本质**：修改时仅复制路径上的节点，保留历史版本的信息。  
- **空间优化**：可持久化数据结构的空间复杂度为O(nlogn)，需提前开足够大的数组（如FHQ Treap开50倍空间）。  
- **调试技巧**：可通过输出每个版本的根节点和节点信息，验证历史版本是否正确。  


## 📝 总结  
可持久化平衡树是可持久化数据结构的经典应用，核心是“复制路径，保留历史”。通过FHQ Treap、主席树、01Trie等结构，可以高效维护多个历史版本的集合。希望本指南能帮助你理解可持久化的思想，并掌握其实现方法。下次我们将探索更复杂的可持久化问题，敬请期待！💪

---
处理用时：184.05秒
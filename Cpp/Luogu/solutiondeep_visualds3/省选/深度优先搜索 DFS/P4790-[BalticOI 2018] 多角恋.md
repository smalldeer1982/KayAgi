# 题目信息

# [BalticOI 2018] 多角恋

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)」**

给一张 $N$ 个点的有向图，每个点的出度为 $1$。每次可以花费 $1$ 的代价修改图上的一条边的终点，也就是改变从一个点出发所到达的点。求最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)

唯一的最优解如上图所示，图的上半部分为原图，底色为粉色的三个点为需要修改的边的起点；图的下半部分表示修改后的情况。

#### 样例 2 解释

存在多组最优解。其中一种是分别改变一条以 ``a``、``b`` 和 ``d`` 为起点的边，使他们分别连接到 ``b``、``a`` 和 `c`。

#### 样例 3 解释

图中有 $3$ 个点，无论如何修改边的终点，总会有一个人不在环里。


| 子任务 | 分值 | 数据范围 | 附加限制 |
|:----------:|:-------:|:-------------:|:-------------:|
|$1$|$21$|$2\leqslant N\leqslant 20$|.|
|$2$|$25$|$2\leqslant N\leqslant 100\, 000$|每个点都有一条入边（可能有自环）|
|$3$|$29$|$2\leqslant N\leqslant 100\, 000$|不存在两个点或更多个点构成的环|
|$4$|$25$|$2\leqslant N\leqslant 100\, 000$|.|



## 样例 #1

### 输入

```
8
leonard emmy
ada emmy
isaac leonard
emmy pierre
pierre bernhard
bernhard emmy
sofia karl
karl sofia```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
a c
b c
c d
d d```

### 输出

```
3
```

## 样例 #3

### 输入

```
3
rocky scarlet
scarlet patrick
patrick rocky```

### 输出

```
-1
```

# AI分析结果

# 💡 Kay的C++算法解析：[BalticOI 2018] 多角恋 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：贪心策略与基环树处理（属于“编程技巧应用”分类，侧重基环树结构的拆解与贪心选择）


🗣️ **初步分析**：  
解决“多角恋”问题的核心，是将**每个点出度为1的有向图**（基环树森林）修改为**若干不相交的二元环**（即每两个点互相指向对方）。我们可以把它比作“给一群人配对跳舞”——每个人只能邀请一个人，但最终要让大家两两成对，且每对互相邀请。  

**核心思路**：  
1. **先捡“现成的”**：找出已经形成二元环的点对（比如A→B且B→A），这些不需要修改，直接排除。  
2. **处理“散落的”**：对剩下的点进行**拓扑排序**（类似“处理排队的人，先处理没有被别人邀请的人”），贪心选择修改边，让他们尽快配对。  
3. **解决“循环的”**：最后剩下的点一定形成环（基环树的环结构），根据环的长度计算需要修改的次数（偶数环需要长度/2次，奇数环需要长度/2 +1次）。  

**核心算法流程与可视化设计**：  
- **已有二元环**：用绿色标记，直接从图中“移除”。  
- **拓扑排序**：用蓝色标记入度为0的点（没有被别人指向），将其加入队列（像素化的“等待区”）。每处理一个点，修改它的边（比如让它指向的人反过来指向它），用红色标记修改的边，伴随“叮”的音效。  
- **环处理**：剩下的环用黄色标记，逐一遍历，计算环长，用闪烁效果提示需要修改的边，比如偶数环每两个点一组，奇数环多一个点需要额外修改。  


## 2. 精选优质题解参考

### 题解一：（来源：cc123321，赞：9）  
* **点评**：这份题解的贪心思路非常清晰，像“整理房间”一样分步处理问题。首先用`use`数组标记已有的二元环，避免重复处理；然后用`deg`数组记录入度，通过拓扑排序处理“散落”的点（入度为0的点），每处理一个点就修改它的边（`ans++`），并更新后续点的入度；最后处理剩下的环，根据环长计算修改次数。代码风格规范（变量名如`nex`表示下一个点，`use`表示是否已处理，含义明确），边界处理严谨（比如`use[0] = 1`避免越界），非常适合初学者理解贪心策略在基环树中的应用。


### 题解二：（来源：Endt，赞：3）  
* **点评**：此题解的贪心思路与题解一类似，但代码结构更简洁。用`a`数组存储每个点的“爱人”（`dear`）和“被爱次数”（`lover`），通过队列处理入度为0的点，修改边时直接将两个点的`dear`设为0（标记为已处理），并更新后续点的`lover`。最后用`dfs`遍历环，计算环长。代码中的`ans1`（处理拓扑部分的修改次数）、`ans2`（处理单身点的修改次数）、`ans3`（处理环的修改次数）分类清晰，容易跟踪每一步的代价。


### 题解三：（来源：ynxynx，赞：1）  
* **点评**：此题解的代码与题解一高度相似，但增加了`pd`函数（判环），用`use`数组标记已处理的点，避免重复遍历环。代码中的`to`数组存储每个点的指向，`rd`数组记录入度，队列处理入度为0的点，修改边时更新`rd`和队列。最后处理环时，用`pd`函数计算环长，根据奇偶性调整`ans`。这份题解的优点是代码注释详细（比如“存现有情侣”“更改入度”），适合初学者逐行理解。


## 3. 核心难点辨析与解题策略

### 1. **关键点1：如何快速找出已有的二元环？**  
* **分析**：已有的二元环是指`i→j`且`j→i`的点对。我们可以用`use`数组标记这些点，避免后续处理。比如题解中的`if(i == nex[nex[i]] && !use[i] && !use[nex[i]])`，就是判断`i`的下一个点的下一个点是否是`i`（即二元环），如果是，就标记`i`和`nex[i]`为已处理。  
* 💡 **学习笔记**：先处理现成的二元环，可以减少后续问题的复杂度，是贪心策略的常见起点。


### 2. **关键点2：如何处理拓扑排序中的贪心选择？**  
* **分析**：拓扑排序处理的是“散落”的点（入度为0的点），这些点没有被别人指向，所以需要修改它们的边，让它们尽快配对。比如题解中的`while(q.size())`循环，每次取出队头`now`，修改它的边（`ans++`），然后标记`nex[now]`为已处理，并更新`nex[nex[now]]`的入度。如果`nex[nex[now]]`的入度变为0，就加入队列继续处理。  
* 💡 **学习笔记**：拓扑排序是处理有向无环图（DAG）的常用方法，这里用来处理基环树中的树部分，贪心选择修改边，让点尽快配对。


### 3. **关键点3：如何处理剩下的环？**  
* **分析**：基环树处理完树部分后，剩下的点一定形成环。对于环的处理，需要计算环的长度：  
  - 偶数环：比如长度为4的环，需要修改2次（比如1→2→3→4→1，修改为1→2、2→1、3→4、4→3，需要修改2次）。  
  - 奇数环：比如长度为3的环，需要修改2次（比如1→2→3→1，修改为1→2、2→1、3→1→3？不，其实奇数环需要额外修改一次，比如长度为3的环需要修改2次，因为3是奇数，所以3/2=1，加1得2）。  
* 💡 **学习笔记**：环的处理是基环树问题的核心，需要根据环的长度计算修改次数，偶数环是长度/2，奇数环是长度/2 +1。


### ✨ 解题技巧总结  
- **分步处理**：先处理现成的二元环，再处理树部分，最后处理环，分步解决问题。  
- **拓扑排序**：用拓扑排序处理树部分，贪心选择修改边，让点尽快配对。  
- **环处理**：遍历环，计算环长，根据奇偶性调整修改次数。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：本代码综合了cc123321、Endt、ynxynx的题解思路，是一个清晰且完整的核心实现。  
* **完整核心代码**：  
  ```cpp
  #include<bits/stdc++.h>
  using namespace std;
  map<string, int> m;
  int n, tot, ans, to[500005], use[500005], rd[500005];
  queue<int> q;

  int pd(int pos) { // 判环，返回环长
      if (use[pos]) return 0;
      use[pos] = 1;
      return pd(to[pos]) + 1;
  }

  int main() {
      ios::sync_with_stdio(false);
      cin >> n;
      if (n % 2) { cout << -1; return 0; } // 奇数无解
      for (int i = 1; i <= n; i++) {
          string a, b;
          cin >> a >> b;
          if (!m[a]) m[a] = ++tot;
          if (!m[b]) m[b] = ++tot;
          if (m[a] != m[b]) to[m[a]] = m[b]; // 存储指向
      }
      // 处理已有二元环
      for (int i = 1; i <= n; i++)
          if (i == to[to[i]] && !use[i] && !use[to[i]])
              use[i] = use[to[i]] = 1;
      // 计算入度
      for (int i = 1; i <= n; i++)
          if (!use[i]) rd[to[i]]++;
      // 拓扑排序处理入度为0的点
      for (int i = 1; i <= n; i++)
          if (!rd[i] && !use[i]) q.push(i);
      while (!q.empty()) {
          int now = q.front(); q.pop();
          ans++; // 修改边
          if (!use[to[now]]) {
              use[to[now]] = 1;
              rd[to[to[now]]]--;
              if (!rd[to[to[now]]] && !use[to[to[now]]])
                  q.push(to[to[now]]);
          }
      }
      // 处理剩下的环
      for (int i = 1; i <= n; i++)
          if (!use[i]) {
              int k = pd(i);
              if (k <= 1) continue;
              if (k % 2) ans++; // 奇数环加1
              ans += k / 2; // 偶数环加k/2
          }
      cout << ans;
      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **读入与映射**：用`map`将字符串（人名）映射为整数（便于处理）。  
  2. **处理已有二元环**：标记`i`和`to[i]`为已处理（`use`数组）。  
  3. **拓扑排序**：计算入度（`rd`数组），处理入度为0的点，修改边（`ans++`），更新后续点的入度。  
  4. **处理环**：用`pd`函数遍历环，计算环长，根据奇偶性调整`ans`。  


### 题解一（cc123321）核心代码片段赏析  
* **亮点**：用`use`数组标记已处理的点，避免重复处理；用`rd`数组记录入度，拓扑排序处理树部分。  
* **核心代码片段**：  
  ```cpp
  // 处理已有二元环
  for (int i = 1; i <= n; i++)
      if (i == nex[nex[i]] && !use[i] && !use[nex[i]])
          use[i] = use[nex[i]] = 1;
  // 计算入度
  for (int i = 1; i <= n; i++)
      if (!use[i]) ++rd[nex[i]];
  // 拓扑排序
  for (int i = 1; i <= n; i++)
      if (!rd[i] && !use[i]) q.push(i);
  while (q.size()) {
      int now = q.front(); q.pop();
      ++ans;
      if (!use[nex[now]]) {
          use[nex[now]] = 1;
          --rd[nex[nex[now]]];
          if (!rd[nex[nex[now]]] && !use[nex[nex[now]]])
              q.push(nex[nex[now]]);
      }
  }
  ```  
* **代码解读**：  
  - `i == nex[nex[i]]`：判断`i`的下一个点的下一个点是否是`i`（即二元环）。  
  - `rd[nex[i]]++`：计算每个点的入度（有多少个点指向它）。  
  - `q.push(i)`：将入度为0的点加入队列（没有被别人指向的点）。  
  - `++ans`：修改`now`的边，代价加1。  
  - `use[nex[now]] = 1`：标记`now`指向的点为已处理（因为修改后它们配对了）。  
  - `rd[nex[nex[now]]]--`：更新`now`指向的点的下一个点的入度（因为`now`指向的点被处理了）。  
* 💡 **学习笔记**：拓扑排序是处理树部分的关键，通过入度为0的点逐步处理，贪心修改边，让点尽快配对。  


## 5. 算法可视化：像素动画演示 (核心部分)

### 动画演示主题：《像素情侣配对大挑战》（8位像素风格，仿FC游戏）


### 核心演示内容  
- **场景初始化**：屏幕显示一个像素化的网格，每个点用不同颜色表示（绿色：已配对，蓝色：未处理，红色：处理中，黄色：环）。  
- **已有二元环处理**：绿色点闪烁，伴随“叮”的音效，从网格中“移除”（变为透明）。  
- **拓扑排序**：蓝色点（入度为0）进入队列（像素化的“等待区”），每处理一个点，红色闪烁，修改边（箭头反向），伴随“滴”的音效，然后蓝色点变为绿色（已配对），后续点的入度更新（箭头数量减少）。  
- **环处理**：黄色点闪烁，逐一遍历，计算环长，偶数环每两个点一组（绿色），奇数环多一个点（红色），伴随“咚”的音效，最后显示总修改次数。  


### 设计思路简述  
- **8位像素风格**：营造复古游戏氛围，让学习更有趣。  
- **颜色标记**：用不同颜色区分点的状态，清晰展示算法流程。  
- **音效提示**：关键操作（如处理点、修改边）用音效强化记忆，比如“叮”表示已配对，“滴”表示修改边，“咚”表示处理环。  
- **队列可视化**：用像素块表示队列，让学习者看到“等待处理”的点。  


### 动画帧步骤  
1. **初始化**：屏幕显示所有点（蓝色），队列为空。  
2. **处理已有二元环**：绿色点闪烁，“叮”的音效，绿色点消失。  
3. **拓扑排序**：蓝色点（入度为0）进入队列（像素块堆叠），“叮”的音效。  
4. **处理队列**：取出队头（红色闪烁），修改边（箭头反向），“滴”的音效，队头变为绿色，后续点的入度减少（箭头数量减少）。  
5. **环处理**：黄色点闪烁，“咚”的音效，逐一遍历，计算环长，偶数环变为绿色，奇数环多一个红色点。  
6. **结束**：显示总修改次数，伴随“胜利”音效（上扬的8位音乐）。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
- **基环树处理**：本题的思路可以迁移到所有基环树问题，比如“找环”“处理树部分”“处理环部分”。  
- **贪心策略**：分步处理问题，先处理简单的部分（已有二元环），再处理复杂的部分（树和环），是贪心策略的常见应用。  
- **拓扑排序**：用于处理有向无环图（DAG）的树部分，贪心选择修改边，让点尽快配对。  


### 练习推荐 (洛谷)  
1. **洛谷 P3455** - 《[POI2007]ZAP-Queries》  
   * 🗣️ **推荐理由**：这道题是基环树的模板题，需要处理环和树部分，适合巩固基环树的处理思路。  
2. **洛谷 P4381** - 《[IOI2008]Island》  
   * 🗣️ **推荐理由**：这道题是基环树的DP问题，需要处理环上的DP，适合拓展基环树的应用。  
3. **洛谷 P5022** - 《[NOIP2018]旅行》  
   * 🗣️ **推荐理由**：这道题是基环树的拓扑排序问题，需要处理树部分的遍历，适合巩固拓扑排序的应用。  


## 7. 学习心得与经验分享 (若有)

### 参考经验 (来自 cc123321)  
> “我在解决这个问题时，最初想不出贪心的思路，后来看了ZYC巨佬的题解，才明白要分步处理。这让我意识到，多和别人讨论可以开阔思路，找到解决问题的突破口。”  

**点评**：这位作者的经验很典型。在编程过程中，遇到不会的问题，多和别人讨论（比如问大佬、看题解），可以快速找到思路。比如本题的贪心思路，分步处理已有二元环、树部分、环部分，就是一个很好的突破口。  


## 结语  
本次关于“[BalticOI 2018] 多角恋”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解基环树的处理思路和贪心策略。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪

---
处理用时：169.14秒
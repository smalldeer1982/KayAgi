# 题目信息

# [NOIP 2012 提高组] 同余方程

## 题目描述

求关于 $ x$ 的同余方程 $ a x \equiv 1 \pmod {b}$ 的最小正整数解。


## 说明/提示

### 数据规模与约定

- 对于 $40\%$ 的数据，$2 ≤b≤ 1,000$；
- 对于 $60\%$ 的数据，$2 ≤b≤ 50,000,000$；
- 对于 $100\%$ 的数据，$2 ≤a, b≤ 2,000,000,000$。



## 样例 #1

### 输入

```
3 10```

### 输出

```
7```

# AI分析结果

---
# 💡 Kay的C++算法解析：[NOIP 2012 提高组] 同余方程 深入学习指南 💡

<introduction>
  今天我们来分析NOIP2012提高组的经典数论题——"同余方程"。这道题的核心是求**模逆元**，需要用到"扩展欧几里得算法"这个数论工具。本指南会帮你梳理思路、理解算法，并通过趣味可视化直观感受过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论中的扩展欧几里得算法）

🗣️ **初步分析**：
> 解决"同余方程"的关键是理解**逆元**——就像乘法中的"倒数"：如果3×7=21≡1 mod 10，那7就是3在模10下的逆元。本题要求找到最小的x，使得ax≡1 mod b（即ax除以b余1）。
> 
> 核心算法是**扩展欧几里得**，它像"带记忆的辗转相除法"：在找a和b的最大公约数（gcd）时，同时找到满足`ax + by = gcd(a,b)`的整数x和y。本题中，ax≡1 mod b等价于`ax + by = 1`（y是整数），而根据**裴蜀定理**，只有当gcd(a,b)=1时方程有解（本题保证有解）。
> 
> 扩展欧几里得的流程：通过递归分解问题（比如把(a,b)拆成(b, a%b)），直到b=0时得到初始解（x=1,y=0），再回溯计算每一步的x和y，最终得到满足`ax+by=1`的x，再调整为最小正整数解（`x=(x%b+b)%b`）。
> 
> 可视化设计思路：用8位像素风格展示递归过程——左侧显示当前a（红）、b（蓝），右侧显示x（黄）、y（绿）；每一步递归时，a和b"缩小"（比如a→b，b→a%b），伴随"滴"声；回溯时，x和y根据下层结果更新，用闪烁突出变化；找到解时，x"跳"到最小正整数位置，伴随"叮"的胜利音效。控制面板有"单步""自动""重置"按钮，方便观察细节！


## 2. 精选优质题解参考

<eval_intro>
  我从思路清晰度、代码可读性等方面筛选了3份优质题解，帮你快速掌握核心解法：
</eval_intro>

**题解一：作者学委（赞1555）**
* **点评**：这份题解是扩展欧几里得的"教科书级"讲解！从问题转化（同余→不定方程）、裴蜀定理证明，到递归推导和解的调整，每一步都讲得明明白白。代码结构清晰，变量命名直观（x/y直接存解），特别适合初学者理解核心逻辑。

**题解二：作者陈曦（赞89）**
* **点评**：题解对比了3种方法（暴力、快速幂、扩展欧几里得），明确指出快速幂的局限性（要求模数为质数），突出扩展欧几里得的通用性。代码用**引用参数**传递x/y，避免全局变量，符合良好编程习惯。

**题解三：作者HasNoName（赞4）**
* **点评**：代码极其简洁！递归时通过**交换参数位置**（把y和x传入下层），减少临时变量的使用，体现了对算法的深刻理解。还返回gcd值，方便判断解的存在性（本题不需要，但拓展性强）。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
  解决本题的3个核心难点，我帮你总结了应对策略：
</difficulty_intro>

1. **难点1：同余方程→不定方程的转化**
   * **分析**：ax≡1 mod b的意思是"ax-1是b的倍数"，即`ax - 1 = by`（y是整数），整理为`ax + by = 1`。这一步需要理解"模运算的本质是倍数关系"。
   * 💡 **学习笔记**：记住公式：ax≡c mod m → ax + my = c。

2. **难点2：扩展欧几里得的递归实现**
   * **分析**：递归的核心是"分解+回溯"——分解时把(a,b)拆成(b, a%b)，回溯时用下层的x2/y2计算当前层的x/y：`x = y2`，`y = x2 - (a/b)*y2`。
   * 💡 **学习笔记**：递归边界是b=0时，x=1、y=0（因为a*1 + 0*0 = a = gcd(a,0)）。

3. **难点3：调整为最小正整数解**
   * **分析**：扩展欧几里得得到的x可能是负数（比如a=3,b=10时，初始解x=-3）。需要用`(x%b + b)%b`把x调整到0~b-1之间（比如-3→7）。
   * 💡 **学习笔记**：这个公式能把任意整数转为"最小正整数解"，是数论中的常用技巧！


## 4. C++核心代码实现赏析

<code_intro_overall>
  先看一份通用的扩展欧几里得实现，帮你掌握整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合学委、陈曦等题解的思路，是扩展欧几里得的经典实现。
* **完整核心代码**：
  ```cpp
  #include <iostream>
  using namespace std;
  typedef long long ll; // 用long long避免溢出

  ll x, y; // 存储解

  void exgcd(ll a, ll b) {
      if (b == 0) { // 递归边界：b=0时，a是gcd
          x = 1;
          y = 0;
          return;
      }
      exgcd(b, a % b); // 递归处理更小的问题
      ll tmp = x;       // 保存下层的x
      x = y;            // 当前x = 下层的y
      y = tmp - (a / b) * y; // 当前y = 下层的x - (a/b)*下层的y
  }

  int main() {
      ll a, b;
      cin >> a >> b;
      exgcd(a, b);
      cout << (x % b + b) % b << endl; // 调整为最小正整数解
      return 0;
  }
  ```
* **代码解读概要**：
  > 1. `exgcd`函数递归计算解：当b=0时，x=1、y=0（因为a*1 + 0*0 = a = gcd(a,0)）；
  > 2. 递归处理`(b, a%b)`后，用下层的x/y更新当前层的x/y；
  > 3. `main`函数输入a/b，调用`exgcd`，最后调整x并输出。


<code_intro_selected>
  接下来分析优质题解的核心片段，看看不同实现的亮点：
</code_intro_selected>

### 题解一：作者学委
* **亮点**：递归推导详细，代码直观易懂。
* **核心代码片段**：
  ```cpp
  void exgcd(long long a, long long b) {
      if (b == 0) {
          x = 1;
          y = 7; // y取0也可以，不影响结果
          return;
      }
      exgcd(b, a % b);
      long long tx = x;
      x = y;
      y = tx - a / b * y;
  }
  ```
* **代码解读**：
  > 递归边界时，y可以取任意值（比如7），因为b=0时y的系数是0，不影响方程`a*1 + 0*y = a`成立。回溯时，用`tx`保存下层的x，再计算当前层的x/y。
* 💡 **学习笔记**：递归边界的y值不影响结果，但建议取0更规范！


### 题解二：作者陈曦
* **亮点**：用引用参数避免全局变量，更模块化。
* **核心代码片段**：
  ```cpp
  void exgcd(int a, int b, int &x, int &y) { // &表示引用，直接修改实参
      if (!b) {
          x = 1;
          y = 0;
          return;
      }
      exgcd(b, a % b, x, y);
      int temp = x;
      x = y;
      y = temp - a / b * y;
  }
  ```
* **代码解读**：
  > 用`&x`和`&y`直接修改调用者的变量，不需要全局变量。比如`main`中调用`exgcd(a,b,x,y)`，x/y会直接被赋值为解。
* 💡 **学习笔记**：引用参数让函数更灵活，推荐在实际编程中使用！


### 题解三：作者HasNoName
* **亮点**：代码极简，递归时交换参数位置。
* **核心代码片段**：
  ```cpp
  ll exgcd(ll a, ll b, ll &x, ll &y) {
      if (b == 0) {
          x = 1; y = 0;
          return a; // 返回gcd(a,b)
      }
      ll d = exgcd(b, a%b, y, x); // 交换y和x的位置
      y -= a/b * x;
      return d;
  }
  ```
* **代码解读**：
  > 递归调用时，把`y`和`x`传给下层，这样下层的x会直接存入当前层的y，下层的y会直接存入当前层的x，减少了临时变量！然后`y -= a/b*x`计算当前层的y。
* 💡 **学习笔记**：交换参数位置是"进阶技巧"，体现了对递归过程的深刻理解！


## 5. 算法可视化：像素动画演示

<visualization_intro>
  为了直观理解扩展欧几里得的过程，我设计了一个**8位像素风格的动画**，像玩复古游戏一样学算法！
</visualization_intro>

### 动画设计方案
* **主题**：像素探险家找"逆元宝藏"
* **核心内容**：展示扩展欧几里得从"分解问题"到"回溯求解"的全过程。
* **设计思路**：用FC游戏的复古风格，用像素块和鲜艳颜色展示数据变化；每一步操作都有音效，强化记忆；加入"单步""自动"模式，自由控制节奏。

### 动画帧步骤
1. **场景初始化**：
   - 屏幕分三部分：左侧"数据区"（显示a=红、b=蓝、x=黄、y=绿），中间"递归区"（展示a/b的分解过程），右侧"控制面板"（按钮+滑块）。
   - 背景是浅灰像素网格，伴随8位风格BGM（比如《超级马里奥》背景乐）。

2. **输入与初始化**：
   - 输入a=3、b=10，数据区显示红色"3"、蓝色"10"，x/y显示"?"。

3. **递归分解**：
   - 点击"开始"，递归区显示a/b的分解过程：(3,10)→(10,3)→(3,1)→(1,0)。每一步分解时，a/b"移动"到下方，伴随"滴"声。

4. **回溯求解**：
   - 当b=0时，递归区显示"初始解x=1,y=0"（黄色1、绿色0）；
   - 回溯时，从(1,0)→(3,1)（x=0,y=1-3/1*0=1）→(10,3)（x=1,y=0-10/3*1=-3）→(3,10)（x=-3,y=1-3/10*(-3)=1）；
   - 每一步回溯，x/y闪烁，伴随"嗒"声。

5. **解的调整**：
   - 得到x=-3后，数据区的x"跳"到7（`(-3%10+10)%10=7`），伴随"叮"的胜利音效，屏幕弹出"找到宝藏！x=7"。

### 交互与音效
- **控制面板**："单步"（逐步执行）、"自动"（按速度播放）、"重置"（回到初始）、速度滑块（慢→快）。
- **音效**：分解"滴"、回溯"嗒"、解调整"叮"、重置"嗡"。


## 6. 拓展练习与相似问题

<similar_problems_intro>
  掌握了同余方程的解法，可以尝试以下问题，巩固数论知识：
</similar_problems_intro>

### 通用思路迁移
扩展欧几里得还能解决：
- 线性同余方程（如ax≡c mod m）；
- 不定方程（如ax+by=c）；
- 同余方程组（如中国剩余定理）。

### 练习推荐（洛谷）
1. **洛谷P1516 青蛙的约会**（P1516）
   - 🗣️ 推荐理由：用扩展欧几里得解决"青蛙跳井"问题，锻炼将实际问题转化为数学模型的能力。
2. **洛谷P2613 【模板】有理数取余**（P2613）
   - 🗣️ 推荐理由：求分数的模，本质是求分母的逆元，巩固逆元的计算方法。
3. **洛谷P3811 【模板】乘法逆元**（P3811）
   - 🗣️ 推荐理由：用多种方法求1~n的逆元，对比扩展欧几里得、快速幂、线性递推的效率。


## 7. 学习心得与经验分享

<insights_intro>
  题解中作者的经验分享，帮你避坑：
</insights_intro>

> **参考经验（来自学委）**："我调试时发现，递归边界的y值可以取任意整数（比如代码中的y=7），但为了规范，建议取0，避免数值过大导致溢出。"
> 
> **点评**：作者的经验提醒我们，即使某些值不影响结果，也要尽量选择合理的初始值，养成良好的编码习惯！


<conclusion>
  本次分析了"同余方程"的核心解法——扩展欧几里得算法。通过"问题转化→递归分解→回溯求解→解调整"，我们能高效求出逆元。记得多做相似练习，巩固数论知识！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：135.67秒
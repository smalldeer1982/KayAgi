# 题目信息

# 【模板】点分树 | 震波

## 题目背景

模板题，没有 $rap$ 。

## 题目描述

在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。

不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。

接下来你需要在线处理 $m$ 次操作：

`0 x k` 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。

`1 x y` 表示第 $x$ 个城市的价值变成了 $y$ 。

为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。



## 说明/提示

#### 数据规模与约定

对于 $100 \%$ 的数据，有 $1\leq n,m\leq 10^5, 1\leq u,v,x\leq n, 1\leq value_i,y\leq 10^4,0\leq k\leq n-1$ 。

upd：样例范围与题目真实数据范围不同，以提示中给出的数据范围为准。

#### 说明
题目来源：BZOJ3730。

## 样例 #1

### 输入

```
8 1
1 10 100 1000 10000 100000 1000000 10000000
1 2
1 3
2 4
2 5
3 6
3 7
3 8
0 3 1```

### 输出

```
11100101```

# AI分析结果

# 💡 Kay的C++算法解析：【模板】点分树 | 震波 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：树论（点分树/动态点分治）

🗣️ **初步分析**：  
解决这道题的关键是**点分树**——它像一棵“浓缩版”的树，把原树通过“找重心”的方式重新拼接，树高只有`log n`级（比如1e5的树只有约20层）。简单来说，点分树是点分治的“记忆版”：每次点分治找重心时，把重心和上一层重心连起来，形成一棵“管理树”。这样，我们就能通过“跳重心祖先”的方式，快速统计原树中距离某个点不超过k的点权和。

### 核心思路与难点
- **问题需求**：动态修改点权，查询“距离x不超过k的点权和”。  
- **核心难点**：  
  1. 原树是线性结构，直接查询每个点的邻居会超时（比如1e5次查询，每次遍历所有点）；  
  2. 需要**去重**——统计祖先重心的子树时，会重复计算当前节点所在的子树。  

- **解决方案**：  
  - 构建点分树，每个重心维护两个数据结构：  
    ① **子树内到当前重心的距离的点权和**（比如`w1`线段树）；  
    ② **子树内到父重心的距离的点权和**（比如`w2`线段树）。  
  - 查询时，从x出发跳点分树的祖先，每次用`w1`统计“祖先子树内符合条件的点权和”，再用`w2`减去“当前子树重复计算的部分”（容斥原理）。

### 可视化设计思路
我们设计一个**像素探险家找宝藏**的动画：  
- **场景**：原树用像素块拼成，重心用金色像素标记，x用红色像素标记，k范围内的节点用绿色闪烁。  
- **动画流程**：  
  1. 点分树构建：逐个选中重心（金色闪烁+“叮”音效），连接上一层重心（蓝色线条）；  
  2. 查询操作：红色x出发，跳祖先重心（黄色箭头），每跳一层，用`w1`统计绿色节点（“嗒”音效），再用`w2`去掉重复的绿色节点（灰色变暗+“吱”音效）；  
  3. 修改操作：选中修改点（紫色闪烁），向上跳祖先，更新对应数据结构（数值跳动+“啪”音效）。  
- **交互**：支持单步执行、自动播放（调速滑块），完成查询时播放“胜利”音效，错误时播放“提示”音效。


## 2. 精选优质题解参考

### 题解一（作者：tzc_wk，赞195）
* **点评**：  
  这道题的“标准模板”题解，思路清晰到像“说明书”！作者用**动态开点线段树**维护每个重心的子树信息，完美解决了空间问题（不用开n棵完整线段树）。代码中`modify`函数向上跳祖先更新线段树，`query`函数跳祖先容斥计算，逻辑严丝合缝。特别是**距离计算用了LCA+倍增**，效率很高，是竞赛中的“实用写法”。


### 题解二（作者：Ayiirep，赞122）
* **点评**：  
  这道题的“注释版”题解，特别适合新手！作者用`vector`树状数组替代动态开点线段树，空间更易控制（每个重心的树状数组大小等于子树大小）。注释详细解释了“为什么维护两个树状数组”（`C0`存到当前重心的距离，`C1`存到父重心的距离），容斥的逻辑也讲得很明白——像“统计全班分数减去小组分数”一样好懂。


### 题解三（作者：Ireliaღ，赞69）
* **点评**：  
  这道题的“优化版”题解，针对大数据做了优化！作者用**ST表求LCA**（O(1)查询距离），比倍增LCA更快；动态开点线段树用了内存池（`npool`数组），避免频繁new节点。代码中的`SegTree`结构体封装得很优雅，`Modify`和`Query`函数逻辑清晰，是“工程化”的写法。


## 3. 核心难点辨析与解题策略

### 3.1 核心难点1：点分树的构建——如何找重心？
- **问题**：点分树的核心是“重心”（子树大小尽可能均衡的节点），如果找错重心，树高会变成O(n)，导致超时。  
- **解决**：用两次DFS找重心：  
  1. 第一次DFS统计子树大小；  
  2. 第二次DFS找“最大子树最小”的节点（即重心）。  
- 💡 **学习笔记**：重心是点分树的“地基”，找对重心才能保证树高logn！


### 3.2 核心难点2：距离计算——如何快速求两点距离？
- **问题**：查询时需要计算“x到祖先重心的距离”，如果每次都遍历树，会超时。  
- **解决**：预处理LCA（最近公共祖先），用`dis(u,v)=dep[u]+dep[v]-2*dep[lca(u,v)]`计算距离。常用的LCA方法有**倍增LCA**（O(n logn)预处理，O(logn)查询）和**ST表LCA**（O(n)预处理，O(1)查询）。  
- 💡 **学习笔记**：LCA是树论的“瑞士军刀”，很多距离问题都能靠它解决！


### 3.3 核心难点3：容斥原理——如何避免重复计算？
- **问题**：查询祖先重心的子树时，会把当前节点所在的子树重复计算（比如祖先重心的子树包含当前节点的子树）。  
- **解决**：维护两个数据结构：  
  ① 祖先重心的子树内到祖先的距离和（`w1`）；  
  ② 当前节点的子树内到祖先的距离和（`w2`）。  
  查询时用`w1 - w2`，就能去掉重复部分。  
- 💡 **学习笔记**：容斥是“减法的艺术”，把“不要的部分”减掉，剩下的就是“要的部分”！


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合优质题解的思路，用动态开点线段树实现，逻辑清晰，适合入门。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cstring>
#include <algorithm>
using namespace std;

const int MAXN = 1e5 + 5;
const int LOG_N = 17;
const int INF = 1e9;

int n, m, a[MAXN];
int hd[MAXN], to[MAXN*2], nxt[MAXN*2], ec = 0;
void adde(int u, int v) { to[++ec] = v; nxt[ec] = hd[u]; hd[u] = ec; }

// LCA预处理
int fa_lca[MAXN][LOG_N+2], dep[MAXN];
void dfs_lca(int x, int f) {
    fa_lca[x][0] = f;
    for (int e = hd[x]; e; e = nxt[e]) {
        int y = to[e]; if (y == f) continue;
        dep[y] = dep[x] + 1; dfs_lca(y, x);
    }
}
int get_lca(int x, int y) {
    if (dep[x] < dep[y]) swap(x, y);
    for (int i = LOG_N; ~i; i--) if (dep[x] - (1 << i) >= dep[y]) x = fa_lca[x][i];
    if (x == y) return x;
    for (int i = LOG_N; ~i; i--) if (fa_lca[x][i] != fa_lca[y][i]) x = fa_lca[x][i], y = fa_lca[y][i];
    return fa_lca[x][0];
}
int get_dis(int x, int y) { return dep[x] + dep[y] - 2 * dep[get_lca(x, y)]; }

// 点分树构建
int fa_pdt[MAXN], siz[MAXN], mx[MAXN], cent;
bool vis[MAXN];
void find_cent(int x, int f, int tot) {
    siz[x] = 1; mx[x] = 0;
    for (int e = hd[x]; e; e = nxt[e]) {
        int y = to[e]; if (y == f || vis[y]) continue;
        find_cent(y, x, tot); siz[x] += siz[y]; mx[x] = max(mx[x], siz[y]);
    }
    mx[x] = max(mx[x], tot - siz[x]);
    if (mx[x] < mx[cent]) cent = x;
}
void build_pdt(int x, int tot) {
    vis[x] = true;
    for (int e = hd[x]; e; e = nxt[e]) {
        int y = to[e]; if (vis[y]) continue;
        cent = 0; mx[0] = INF; find_cent(y, x, siz[y]);
        fa_pdt[cent] = x; build_pdt(cent, siz[y]);
    }
}

// 动态开点线段树
const int MAXP = 5e6;
struct SegTree {
    int rt[MAXN], ncnt = 0;
    struct Node { int ch[2], val; } s[MAXP];
    void modify(int& k, int l, int r, int p, int v) {
        if (!k) k = ++ncnt;
        s[k].val += v;
        if (l == r) return;
        int mid = (l + r) >> 1;
        if (p <= mid) modify(s[k].ch[0], l, mid, p, v);
        else modify(s[k].ch[1], mid+1, r, p, v);
    }
    int query(int k, int l, int r, int ql, int qr) {
        if (!k) return 0;
        if (ql <= l && r <= qr) return s[k].val;
        int mid = (l + r) >> 1;
        if (qr <= mid) return query(s[k].ch[0], l, mid, ql, qr);
        else if (ql > mid) return query(s[k].ch[1], mid+1, r, ql, qr);
        else return query(s[k].ch[0], l, mid, ql, mid) + query(s[k].ch[1], mid+1, r, mid+1, qr);
    }
} w1, w2; // w1: 子树内到当前节点的距离和；w2: 子树内到父节点的距离和

// 修改操作：更新点x的权值（变化量为v）
void modify(int x, int v) {
    int cur = x;
    while (cur) {
        int d = get_dis(cur, x);
        w1.modify(w1.rt[cur], 0, n-1, d, v);
        if (fa_pdt[cur]) {
            int d_fa = get_dis(fa_pdt[cur], x);
            w2.modify(w2.rt[cur], 0, n-1, d_fa, v);
        }
        cur = fa_pdt[cur];
    }
}

// 查询操作：距离x不超过k的点权和
int query(int x, int k) {
    int cur = x, pre = 0, res = 0;
    while (cur) {
        int d = get_dis(cur, x);
        if (d > k) { pre = cur; cur = fa_pdt[cur]; continue; }
        res += w1.query(w1.rt[cur], 0, n-1, 0, k - d);
        if (pre) res -= w2.query(w2.rt[pre], 0, n-1, 0, k - d);
        pre = cur; cur = fa_pdt[cur];
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false); cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; i++) cin >> a[i];
    for (int i = 1; i < n; i++) { int u, v; cin >> u >> v; adde(u, v); adde(v, u); }
    
    // 预处理LCA
    dfs_lca(1, 0);
    for (int i = 1; i <= LOG_N; i++)
        for (int j = 1; j <= n; j++)
            fa_lca[j][i] = fa_lca[fa_lca[j][i-1]][i-1];
    
    // 构建点分树
    cent = 0; mx[0] = INF; find_cent(1, 0, n);
    build_pdt(cent, n);
    
    // 初始化线段树
    for (int i = 1; i <= n; i++) modify(i, a[i]);
    
    int pre_ans = 0;
    while (m--) {
        int opt, x, y; cin >> opt >> x >> y;
        x ^= pre_ans; y ^= pre_ans;
        if (opt == 0) {
            pre_ans = query(x, y);
            cout << pre_ans << '\n';
        } else {
            modify(x, y - a[x]);
            a[x] = y;
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  代码分为5部分：① 输入与建图；② LCA预处理（求距离）；③ 点分树构建（找重心，连父节点）；④ 动态开点线段树（维护距离和）；⑤ 修改与查询操作（跳祖先，容斥计算）。核心逻辑在`modify`和`query`函数，通过跳点分树的祖先，完成数据更新和查询。


### 题解一核心代码片段赏析
* **亮点**：动态开点线段树的实现，节省空间。
* **核心代码片段**：
```cpp
struct SegTree {
    int rt[MAXN], ncnt = 0;
    struct Node { int ch[2], val; } s[MAXP];
    void modify(int& k, int l, int r, int p, int v) {
        if (!k) k = ++ncnt;
        s[k].val += v;
        if (l == r) return;
        int mid = (l + r) >> 1;
        if (p <= mid) modify(s[k].ch[0], l, mid, p, v);
        else modify(s[k].ch[1], mid+1, r, p, v);
    }
    int query(int k, int l, int r, int ql, int qr) {
        if (!k) return 0;
        if (ql <= l && r <= qr) return s[k].val;
        int mid = (l + r) >> 1;
        if (qr <= mid) return query(s[k].ch[0], l, mid, ql, qr);
        else if (ql > mid) return query(s[k].ch[1], mid+1, r, ql, qr);
        else return query(s[k].ch[0], l, mid, ql, mid) + query(s[k].ch[1], mid+1, r, mid+1, qr);
    }
} w1, w2;
```
* **代码解读**：  
  - `rt[MAXN]`：每个重心对应一个线段树的根节点；  
  - `modify`函数：动态开点（`if (!k) k = ++ncnt`），更新位置`p`的权值`v`；  
  - `query`函数：查询区间`[ql, qr]`的和，递归处理左右子树。  
* 💡 **学习笔记**：动态开点线段树是“按需分配空间”，适合需要开很多棵线段树的场景！


## 5. 算法可视化：像素动画演示

### 动画主题：像素探险家的树海寻宝
### 设计思路
采用**8位像素风**（FC游戏风格），用简单的像素块和音效，让点分树的逻辑“动起来”。比如：
- 原树用绿色像素块表示，重心用金色像素块，查询点用红色，k范围内的节点用绿色闪烁；
- 点分树的构建过程：逐个选中重心（金色闪烁+“叮”声），用蓝色线条连接上一层重心；
- 查询过程：红色点出发，用黄色箭头跳祖先，每跳一层，绿色节点闪烁（“嗒”声），再用灰色去掉重复节点（“吱”声）；
- 修改过程：紫色点闪烁，向上跳祖先，数值跳动（“啪”声）。

### 动画帧步骤
1. **初始化**：显示原树，重心用金色标记，控制面板有“开始/暂停”“单步”“重置”按钮，调速滑块。
2. **点分树构建**：
   - 第1帧：选中根重心（金色闪烁），“叮”声；
   - 第2帧：连接根重心和子重心（蓝色线条），“嗒”声；
   - 重复直到所有重心连接完成。
3. **查询操作**：
   - 第1帧：红色查询点闪烁，输入k值；
   - 第2帧：黄色箭头跳第一个祖先，绿色节点闪烁（统计`w1`）；
   - 第3帧：灰色去掉重复节点（统计`w1 - w2`），“吱”声；
   - 重复直到跳完所有祖先，显示结果（绿色数字跳动+“胜利”声）。
4. **修改操作**：
   - 第1帧：紫色修改点闪烁，输入新权值；
   - 第2帧：黄色箭头跳祖先，数值跳动（“啪”声）；
   - 第3帧：更新完成，紫色点变亮（“叮”声）。

### 交互设计
- **步进控制**：“单步”按钮逐帧播放，“自动”按钮按滑块速度播放；
- **音效**：关键操作（重心选中、查询、修改）有不同音效，背景音乐是8位风格的《卡农》；
- **重置**：恢复初始状态，方便重新演示。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
点分树的核心是**将原树的“线性操作”转化为“logn层的暴力操作”**，适用于：
1. **动态树上查询**：比如查询距离x不超过k的点权和（本题）；
2. **静态树上路径统计**：比如统计路径长度为k的点对数量；
3. **动态树上修改**：比如修改点权，查询路径上的最大点权。

### 洛谷推荐练习
1. **P2056 [ZJOI2007]捉迷藏**：点分树+堆，查询树上最远点对，巩固点分树的应用；
2. **P3241 [HNOI2015]开店**：点分树+前缀和，查询距离区间内的点权和，练习数据结构的结合；
3. **P3345 [ZJOI2015]幻想乡战略游戏**：点分树+动态点权，查询树上最小总代价，提升综合能力。


## 7. 学习心得与经验分享
优质题解中，作者们提到的**常见踩坑点**值得注意：
1. **重心找错**：如果找重心时没统计子树大小，会导致点分树的树高变高，超时；
2. **距离计算错误**：LCA的预处理要正确，否则距离计算错误，整个查询逻辑崩溃；
3. **数据结构选择**：动态开点线段树和树状数组各有优缺点，树状数组实现简单，但动态开点线段树更省空间。

💡 **Kay的小建议**：刚开始学点分树时，可以先写**静态点分治**（比如统计路径长度为k的点对），再过渡到**动态点分树**（本题），循序渐进！


## 8. 总结
本次分析的“点分树 | 震波”题，核心是**点分树的构建**和**容斥原理的应用**。通过点分树，我们把原树的“线性查询”变成了“logn层的暴力查询”，再用动态开点线段树维护信息，解决了动态修改和查询的问题。

记住：**点分树是“暴力的艺术”**——因为树高只有logn，所以暴力跳祖先也能通过！下次遇到树上的动态查询问题，不妨想想点分树~

💪 编程的进步在于“多写、多想、多调”，加油！

---
处理用时：89.55秒
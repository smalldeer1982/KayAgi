# 题目信息

# 【模板】分治 FFT

## 题目背景

也可用多项式求逆解决。

## 题目描述

给定序列 $g_{1\dots n - 1}$，求序列 $f_{0\dots n - 1}$。

其中 $f_i=\sum_{j=1}^if_{i-j}g_j$，边界为 $f_0=1$。

答案对 $998244353$ 取模。

## 说明/提示

$2\leq n\leq 10^5$，$0\leq g_i<998244353$。

## 样例 #1

### 输入

```
4
3 1 2```

### 输出

```
1 3 10 35```

## 样例 #2

### 输入

```
10
2 456 32 13524543 998244352 0 1231 634544 51```

### 输出

```
1 2 460 1864 13738095 55389979 617768468 234028967 673827961 708520894```

# AI分析结果

---
# 💡 Kay的C++算法解析：【模板】分治FFT 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：分治FFT（分治 + 快速傅里叶变换/数论变换）、多项式求逆（多项式运算）

🗣️ **初步分析**：  
解决“分治FFT模板”问题，关键在于理解 **“分治拆分问题 + FFT快速计算贡献”** 的组合魔法，或者 **“多项式求逆的倒数思维”**。  

- **分治FFT的比喻**：就像“班级分工做手工”——把大任务（计算整个f序列）分成左右两组，先让左组完成自己的部分，再用“快速计算工具”（FFT/NTT）算出左组对右组的帮助（贡献），最后让右组完成自己的部分。这样既避免了逐个计算的慢速度（O(n²)），又通过分治和FFT把时间降到了O(n log²n)。  
- **多项式求逆的比喻**：就像“找倒数”——题目中的f序列满足f = f*g + 1（f0=1），变形后得到f = 1/(1-g)（多项式意义下的“倒数”）。这时候只要算出(1-g)的“多项式逆元”，就能直接得到f，速度更快（O(n logn)）。  

**题解思路与核心难点**：  
- **分治FFT思路**：用CDQ分治的顺序（先左→算贡献→后右），确保左边的f值先算好，再用FFT快速计算左边f与g的卷积，得到对右边f的贡献，最后处理右边。  
- **多项式求逆思路**：将递推式转化为多项式方程，直接求(1-g)的逆元。  
- **核心难点**：① 分治的顺序（必须先左后贡献再右）；② FFT的正确应用（卷积结果的截取）；③ 模数下的NTT实现（原根、逆元的计算）。  

**可视化设计思路**：  
我们用“像素化数组探险”的复古游戏风格演示分治FFT：  
- 屏幕显示8位像素的数组（f序列），每个元素是一个彩色小方块；  
- 分治时，左边的方块先变成绿色（表示已计算），右边还是灰色；  
- 卷积贡献阶段，左边的绿色方块与g的蓝色方块“碰撞”（动画：方块叠加），产生的紫色方块加到右边的灰色方块上（颜色变紫，表示贡献已加）；  
- 每一步操作有音效：分治开始“叮”，卷积“啪”，完成一步“嗒”，全部完成“胜利音乐”；  
- 交互面板有“单步”“自动”“重置”按钮，速度滑块调节动画快慢。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮大家快速抓住核心！
</eval_intro>

**题解一：ljc1301的分治FFT模板（赞：104）**  
* **点评**：这份题解把分治FFT的思路讲得特别明白！用“斐波那契数列”的例子模拟分治过程，让抽象的分治顺序瞬间变具体。代码结构清晰：先递归左区间，再用NTT计算左对右的贡献，最后递归右区间。特别是“填充0”“卷积后截取右半段”的细节，完美对应分治的逻辑。代码里的NTT实现也很规范，原根、逆元的初始化一步到位，适合初学者模仿。

**题解二：Great_Influence的分治FFT优化（赞：36）**  
* **点评**：这题解的“卡常技巧”太实用了！作者指出“卷积时不用算1.5倍长度，只用算区间长度”，能把常数降到原来的一半。代码里的cdq_FFT函数，用memcpy快速拷贝数组，NTT前只初始化需要的长度，细节处理很到位。更重要的是，作者把“左边对右边的贡献”用公式写清楚：w_x = sum(f[i] * g[x-i])（i从l到mid），直接点出了卷积的核心！

**题解三：Memory_of_winter的双解法实现（赞：14）**  
* **点评**：这份题解同时给出了分治FFT和多项式求逆的正确代码，还修正了之前的错误（比如g数组读入范围），适合对比两种方法的差异。多项式求逆的代码里，把g[i]取“mod - g[i]”的细节，正好对应f = (1 - g)^{-1}的推导（因为1 - g的系数是1, -g1, -g2,...）。作者的博客链接还能让你深入学习更多细节，非常贴心！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的“拦路虎”主要有3个，我们一一拆解：
</difficulty_intro>

1.  **难点1：分治的顺序为什么是“先左→算贡献→后右”？**  
    * **分析**：因为右边的f值依赖左边的f值（比如f[3]需要f[0]、f[1]、f[2]）。如果先算右边，左边的f值还没确定，贡献就会算错。分治的顺序必须保证“左边先完成，再帮右边”。  
    * 💡 **学习笔记**：分治的核心是“先解决依赖项，再计算贡献”。

2.  **难点2：如何用FFT计算左边对右边的贡献？**  
    * **分析**：左边的f序列（l到mid）和g序列（0到r-l）的卷积，结果的“mid-l到r-l”部分就是左边对右边的贡献（比如左边是f[0~1]，右边是f[2~3]，卷积结果的第2、3位就是f[0]g[2] + f[1]g[1]、f[0]g[3] + f[1]g[2]，正好是右边f的需要）。  
    * 💡 **学习笔记**：卷积的“后半段”才是左边对右边的贡献，要记得截取！

3.  **难点3：模数下的NTT怎么实现？**  
    * **分析**：因为题目要求对998244353取模，所以要用“数论变换（NTT）”代替FFT。关键是选对原根（比如3），计算每个长度的单位根，以及逆变换时的逆元。  
    * 💡 **学习笔记**：NTT的核心是“原根的幂次”，模数998244353的原根是3，记住这个就能写出正确的NTT！

### ✨ 解题技巧总结
- **分治顺序要牢记**：先左→算贡献→后右，不能乱！  
- **卷积结果要截取**：只取后半段加到右边。  
- **NTT细节别忘**：原根、逆元、长度要对齐2的幂次。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**分治FFT的通用核心代码**，帮你建立整体框架！
</code_intro_overall>

**本题通用核心C++实现参考（分治FFT）**  
* **说明**：综合ljc1301和Great_Influence的题解，整理出的清晰实现，包含NTT初始化、分治逻辑、卷积计算。  
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const int mod = 998244353, G = 3;
    const int maxn = 1 << 18 | 1;

    int rev[maxn];
    ll G_pow[2][24]; // G[0]是原根幂，G[1]是逆元幂

    ll qpow(ll a, ll b) {
        ll res = 1;
        for (; b; b >>= 1, a = a * a % mod)
            if (b & 1) res = res * a % mod;
        return res;
    }

    void init_G() {
        G_pow[1][23] = qpow(G, mod - 2);
        for (int i = 22; i >= 0; --i) {
            G_pow[0][i] = G_pow[0][i+1] * G_pow[0][i+1] % mod;
            G_pow[1][i] = G_pow[1][i+1] * G_pow[1][i+1] % mod;
        }
    }

    void NTT(ll *a, int logn, int flag) {
        int n = 1 << logn;
        for (int i = 0; i < n; ++i)
            if (i < rev[i]) swap(a[i], a[rev[i]]);
        for (int i = 1; i <= logn; ++i) {
            int mid = 1 << (i-1);
            ll w = G_pow[flag][i];
            for (int j = 0; j < n; j += 1 << i) {
                ll t = 1;
                for (int k = 0; k < mid; ++k, t = t * w % mod) {
                    ll x = a[j + k], y = t * a[j + k + mid] % mod;
                    a[j + k] = (x + y) % mod;
                    a[j + k + mid] = (x - y + mod) % mod;
                }
            }
        }
        if (flag) {
            ll inv_n = qpow(n, mod - 2);
            for (int i = 0; i < n; ++i) a[i] = a[i] * inv_n % mod;
        }
    }

    ll f[maxn], g[maxn], a[maxn], b[maxn];

    void solve(int l, int r, int logn) {
        if (logn <= 0) return;
        int mid = (l + r) >> 1;
        solve(l, mid, logn - 1); // 先处理左区间

        // 计算左对右的贡献：a = f[l..mid], b = g[0..r-l-1]
        int len = 1 << logn;
        for (int i = 0; i < len; ++i) rev[i] = (rev[i>>1]>>1) | ((i&1)<<(logn-1));
        memset(a, 0, sizeof(ll) * len);
        memset(b, 0, sizeof(ll) * len);
        memcpy(a, f + l, sizeof(ll) * (mid - l)); // 左区间f
        memcpy(b, g, sizeof(ll) * (r - l));       // g的前r-l项
        NTT(a, logn, 0); NTT(b, logn, 0);
        for (int i = 0; i < len; ++i) a[i] = a[i] * b[i] % mod;
        NTT(a, logn, 1);

        // 贡献加到右区间
        for (int i = (r - l)/2; i < r - l; ++i)
            f[l + i] = (f[l + i] + a[i]) % mod;

        solve(mid, r, logn - 1); // 处理右区间
    }

    int main() {
        init_G();
        int n, logn = 0;
        scanf("%d", &n);
        while ((1 << logn) < n) logn++;
        for (int i = 1; i < n; ++i) scanf("%lld", &g[i]);
        f[0] = 1; // 边界条件
        solve(0, 1 << logn, logn);
        for (int i = 0; i < n; ++i) printf("%lld ", (f[i] + mod) % mod);
        return 0;
    }
    ```
* **代码解读概要**：  
  1. **NTT初始化**：预计算原根的幂和逆元幂，避免重复计算。  
  2. **分治函数solve**：先递归左区间，再用NTT计算左f与g的卷积，截取后半段加到右区间，最后递归右区间。  
  3. **主函数**：读入数据，初始化f[0]=1，调用solve，输出结果。

<code_intro_selected>
接下来剖析3份优质题解的**核心代码片段**，看高手是怎么写的！
</code_intro_selected>

**题解一：ljc1301的solve函数**  
* **亮点**：用“拷贝左区间→填充0→卷积→加贡献”的流程，完美对应分治逻辑。  
* **核心代码片段**：
    ```cpp
    void solve(int l, int r, int logn) {
        if (logn <= 0) return;
        int mid = (l + r) >> 1;
        solve(l, mid, logn-1); // 左区间
        calcrev(logn); // 计算反转位
        memset(a+(r-l)/2,0,sizeof(ll)*(r-l)/2); 
        memcpy(a,f+l,sizeof(ll)*(r-l)/2); // 左区间f
        memcpy(b,g,sizeof(ll)*(r-l));     // g
        FFT(a,logn,0), FFT(b,logn,0);
        for(i=0;i<r-l;i++) a[i]=a[i]*b[i]%kcz;
        FFT(a,logn,1);
        for(i=(r-l)/2;i<r-l;i++) f[l+i]=(f[l+i]+a[i])%kcz; // 加贡献
        solve(mid,r,logn-1); // 右区间
    }
    ```
* **代码解读**：  
  - `memset(a+(r-l)/2, 0`：把a的后半段设为0，确保左区间f只占前半段。  
  - `memcpy(a, f+l, ...)`：把左区间的f拷贝到a的前半段。  
  - `FFT`后相乘，再逆变换，最后把a的后半段（左对右的贡献）加到f的右区间。  
* 💡 **学习笔记**：卷积后的结果，前半段是左区间内部的贡献（已经算过），后半段才是对右区间的贡献，所以只加后半段！

**题解二：Great_Influence的cdq_FFT函数**  
* **亮点**：用`memcpy`快速拷贝数组，NTT前只初始化需要的长度，常数更小。  
* **核心代码片段**：
    ```cpp
    void cdq_FFT(int* F, int* G, int l, int r) {
        if (l == r) { if (!l) F[l] = 1; return; }
        int md = (l + r) >> 1;
        cdq_FFT(F, G, l, md); // 左区间
        memcpy(A, F+l, sizeof(int)*(md-l+1)); // 左f
        memcpy(B, G, sizeof(int)*(r-l+1));     // g
        for (Len=2; Len<=r-l+1; Len<<=1); // 找最小2的幂
        calrev(); // 反转位
        NTT(A,1), NTT(B,1);
        rep(i,0,Len) A[i]=(ll)A[i]*B[i]%mod;
        NTT(A,-1);
        Rep(i,md+1,r) F[i]=ad(F[i],A[i-l]); // 加贡献
        cdq_FFT(F,G,md+1,r); // 右区间
    }
    ```
* **代码解读**：  
  - `Len`找最小的2的幂，避免不必要的大长度卷积，节省时间。  
  - `ad(F[i], A[i-l])`：用`ad`函数（模加法）确保结果在mod范围内。  
* 💡 **学习笔记**：卷积的长度只要覆盖“r-l+1”就行，不用更大，这是卡常的关键！

**题解三：Memory_of_winter的多项式求逆代码**  
* **亮点**：直接转化为求(1-g)的逆元，代码简洁，速度更快。  
* **核心代码片段**：
    ```cpp
    void INV(int *A, int *B, int n) {
        if (n == 1) { *B = qpow(*A, mod-2); return; }
        INV(A, B, (n+1)>>1); // 递归求半长逆元
        init(n + n - 1); // NTT长度
        copy(A, A+n, C); memset(C+n, 0, sizeof(int)*(lim-n));
        NTT(B,1), NTT(C,1);
        for (int i=0; i<lim; i++) 
            B[i] = (2 - (ll)B[i]*C[i]%mod + mod) % mod * B[i] % mod;
        NTT(B,0); memset(B+n, 0, sizeof(int)*(lim-n)); // 截断长度
    }
    ```
* **代码解读**：  
  - `INV`函数递归求逆：先求前一半的逆元，再用迭代公式更新到全长度。  
  - `(2 - B[i]*C[i]%mod + mod) % mod`：多项式逆元的迭代公式，确保结果正确。  
* 💡 **学习笔记**：多项式求逆的关键是“迭代更新”，记住公式就能写出代码！


## 5. 算法可视化：像素动画演示（复古游戏风）

### 🎮 动画主题：像素数组的分治冒险  
**设计思路**：用8位红白机风格，让“分治”和“卷积”变成可见的游戏操作，增强记忆点！

### 🕹️ 动画步骤与交互
1. **场景初始化**：  
   - 屏幕显示16x16的像素数组（f序列），初始时只有f[0]是绿色（f[0]=1），其他是灰色。  
   - 下方控制面板：“单步”“自动”“重置”按钮，速度滑块（慢→快），当前步骤提示（比如“处理左区间[0,2]”）。  
   - 8位风格的背景音乐（轻快的“叮叮当”）开始播放。

2. **分治第一步：处理左区间**：  
   - 点击“单步”，左边的f[0]~f[2]变成绿色（动画：方块从左到右逐渐变绿），同时响起“叮”的音效。  
   - 提示文字：“左区间完成！接下来计算贡献～”

3. **卷积贡献：左→右**：  
   - 绿色的左区间方块（f[0]~f[2]）与蓝色的g方块（g[1]~g[3]）“碰撞”（动画：方块从左向右移动，叠加成紫色）。  
   - 紫色方块落到右边的灰色方块上（f[3]~f[5]变成紫色），响起“啪”的音效。  
   - 提示文字：“贡献已加！右边的f值更新啦～”

4. **处理右区间**：  
   - 右边的紫色方块（f[3]~f[5]）继续分治，变成深紫色（表示已处理），响起“嗒”的音效。  
   - 全部完成后，所有方块变成金色，播放胜利音乐（“噔噔噔！”），提示文字：“完成啦！f序列计算成功～”

### 🎵 音效设计
- **分治开始**：“叮”（轻快的短音）  
- **卷积贡献**：“啪”（清脆的碰撞音）  
- **完成一步**：“嗒”（短促的提示音）  
- **全部完成**：“噔噔噔”（上扬的胜利音）  
- **重置**：“咻”（清零的音效）

### 🎮 交互功能
- **单步执行**：点击一次走一步，适合仔细观察每一步。  
- **自动播放**：按设定速度（滑块调节）自动执行，适合整体浏览。  
- **重置动画**：回到初始状态，重新开始。  
- **速度调节**：滑块从“慢”（1秒/步）到“快”（0.1秒/步），满足不同学习节奏。


## 6. 拓展练习与相似问题思考

### 🔍 通用思路迁移
- **分治FFT**：适用于“递推式依赖前面所有项”的问题（比如f[i] = sum_{j=0}^{i-1} f[j] * g[i-j]）。  
- **多项式求逆**：适用于“多项式方程可转化为求逆”的问题（比如f = f*g + 1）。

### 📚 洛谷推荐练习
1. **P4238 多项式求逆**（必练！）：直接考察多项式求逆，是本题的另一种解法。  
   - 推荐理由：掌握多项式求逆的核心，就能快速解决本题。  
2. **P3803 多项式乘法**（基础！）：FFT/NTT的入门题，帮你理解卷积的本质。  
   - 推荐理由：打好基础，才能看懂分治FFT的卷积步骤。  
3. **P5488 分治FFT**（模板！）：和本题几乎一样，适合巩固分治FFT的代码。  
   - 推荐理由：多练模板，才能熟练写出正确的分治顺序。  
4. **P4721 分治FFT**（进阶！）：递推式更复杂，需要调整分治的贡献计算。  
   - 推荐理由：挑战更难的分治FFT，提升思维能力。


## 7. 学习心得与经验分享

<insights_intro>
从题解中提炼的“踩坑经验”，帮你避开常见错误！
</insights_intro>

> **参考经验（来自Memory_of_winter）**：“我之前读入g数组时，把g[1]~g[n-1]写成了g[1]~g[n]，导致代码错误。后来发现是读入范围错了，修正后就过了！”  
> **点评**：读入数组时，一定要注意题目中的“g_{1..n-1}”，别多读或少读！比如本题中g的长度是n-1，所以循环是i从1到n-1，不是n。

> **参考经验（来自Great_Influence）**：“卷积时不用算1.5倍长度，只用算区间长度，这样常数会小很多！”  
> **点评**：卡常的关键在于“不做多余的计算”，卷积的长度只要覆盖需要的区间就行，不用更大。


## 8. 总结

本次分析让我们掌握了**分治FFT**和**多项式求逆**两种解决递推问题的方法。分治FFT像“分工合作+快速计算”，适合理解递推的过程；多项式求逆像“找倒数”，适合快速计算结果。记住分治的顺序、卷积的截取、NTT的细节，就能解决这类问题！

编程的提升在于“多练+多思”，赶紧去做拓展练习吧！下次我们再一起探索更有趣的算法～ 💪

---
**Kay的小提醒**：如果对NTT的细节还有疑问，可以去看《算法竞赛进阶指南》里的“数论变换”章节，或者洛谷的NTT模板题解～ 加油！ 🚀

---
处理用时：100.32秒
# 题目信息

# [HNOI2016] 矿区

## 题目描述

平面上的矿区划分成了若干个开发区域。

简单地说，你可以将矿区看成一张连通的平面图，平面图划分为了若干平面块，每个平面块即为一个开发区域，平面块之间的边界必定由若干整点(坐标值为整数的点)和连接这些整点的线段组成。每个开发区域的矿量与该开发区域的面积有关：具体而言，面积为 $ s $ 的开发区域的矿量为 $ s^2 $。

现在有 $ m $ 个开采计划。每个开采计划都指定了一个由若干开发区域组成的多边形，一个开采计划的优先度被规定为矿量的总和÷开发区域的面积和；例如，若某开采计划指定两个开发区域，面积分别为 $ a $ 和 $ b $，则优先度为 $ (a^2+b^2)/(a+b) $。由于平面图是按照划分开发区域边界的点和边给出的，因此每个开采计划也只说明了其指定多边形的边界，并未详细指明是哪些开发区域（但很明显，只要给出了多边形的边界就可以求出是些开发区域）。

你的任务是求出每个开采计划的优先度。为了避免精度问题，你的答案必须按照分数的格式输出，即求出分子和分母，且必须是最简形式（分子和分母都为整数，而且都消除了最大公约数；例如，若矿量总和是 $ 1.5 $，面积和是 $ 2 $，那么分子应为 $ 3 $，分母应为 $ 4 $；又如，若矿量和是 $ 2 $，面积和是 $ 4 $，那么分子应为 
 $ 1 $，分母应为 $ 2 $）。

由于某些原因，你必须依次对每个开采计划求解（即下一个开采计划会按一定格式加密，加密的方式与上一个开采计划的答案有关）。具体的加密方式见输入格式。

## 说明/提示

### 样例解释

输入文件给出的 $9$ 个点和 $14$ 条边描述的平面图如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cg70enmo.png)

第一个开采计划，输入的第 $1$ 个值为 $3$，所以该开采计划对应的多边形有 $(3+0)\bmod 8+1=4$ 个点，将接下的 $4$ 个数 $3,0,4,7$，分别代入 $(z_i+0)\bmod n+1$ 得到 $4$ 个点的编号为 $4,1,5,8$。计算出第一个开采计划的分子为 $1$，分母为 $1$。

类似地，可计算出余下开采计划的多边形的点数和点的编号：第二个开采计划对应的多边形有 $3$ 个点，编号分别为 $5,6,8$。第三个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,2,6,5,8,4$。第四个开采计划对应的多边形有 $5$ 个点，编号分别为 $1,2,6,8,4$。第五个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,5,6,8,7,4$。

### 数据范围及约定


对于 $ 100 \% $ 的数据，$ n, k \leq 2 \times 10^5, \  m \leq 3n-6, \  |x_i|, |y_i| \leq 3×10^4$。

所有开采计划的 $ d $ 之和不超过 $2 \times 10^6$。保证任何开采计划都包含至少一个开发区域，且这些开发区域构成一个连通块。

保证所有开发区域的矿量和不超过 $ 2^{63}-1 $。

保证平面图中没有多余的点和边。

保证数据合法。由于输入数据量较大，建议使用读入优化。




## 样例 #1

### 输入

```
9 14 5
0 0
1 0
2 0
0 1
1 1
2 1
0 2
1 2
2 2
1 2
2 3
5 6
7 8
8 9
1 4
4 7
5 8
3 6
6 9
4 8
1 5
2 6
6 8
3 3 0 4 7 1 3 4 6 4 8 0 4 3 6 2 3 8 0 4 6 2 5 0 4 5 7 6 3```

### 输出

```
1 1 
1 2 
1 1 
9 10 
3 4```

# AI分析结果


### Kay的C++算法解析：矿区 深入学习指南

---

#### 💡 **1. 题目解读与核心算法识别**  
✨ **本题主要考察**：平面图转对偶图（图论与计算几何结合）  

🗣️ **初步分析**：  
> 解决矿区问题就像将一张地图转化为“国家关系网”——每个开发区域变成一个“国家”，区域间的边界变成连接国家的“道路”。这种转化称为**平面图转对偶图**。核心步骤是：  
> - **极角排序**：对每个点的出边按角度排序（类似罗盘导航）。  
> - **面划分**：通过循环查找“下一条边界边”划分封闭区域（如走迷宫）。  
> - **子树容斥**：将对偶图转为生成树，用“进加出减”的容斥策略计算区域矿量（类似开关灯计数）。  
>  
> **可视化设计思路**：  
> - 像素动画将展示**点阵平面图→彩色区块（开发区域）→对偶图城堡连线**的过程。  
> - 高亮当前处理的边和父子节点关系（如父节点城堡标皇冠，子树加/减时闪烁）。  
> - 复古音效：边处理时触发“滴答”声，容斥计算时播放加减音效（如FC游戏金币声）。  

---

#### ⭐ **2. 精选优质题解参考**  
**题解一：litble（25赞）**  
* **点评**：  
  最完整的对偶图实现框架！极角排序用`vector`+`lower_bound`高效查边，避免`map`开销；用叉积面积符号巧判无界域（根节点）；子树和容斥逻辑清晰。代码中`s[]`存面积×2，`ss[]`存面积平方，避免浮点误差。边界处理严谨，可直接用于竞赛。  

**题解二：_Sein（9赞）**  
* **点评**：  
  用图示形象解释子树容斥（如链式加减），强调“父子方向决定贡献正负”；指出面积负值为无界域的关键性质，帮助理解根节点选择。代码预乘2处理面积，数值技巧实用。  

**题解三：dengchengyu（1赞）**  
* **点评**：  
  显式存储反向边索引（`mp[u][v]`），查边效率优化；独立实现二分查找极角，避免STL开销。强调叉积计算时分子分母同乘4的技巧，避免浮点误差，调试友好。  

---

#### 🧩 **3. 核心难点辨析与解题策略**  
1. **难点1：平面划分与边归属判定**  
   - **分析**：需通过极角排序确定每条边所属区域。对边\( (u,v) \)，在\( v \)点找反向边\( (v,u) \)的极角序前驱，作为下一条边界（如litble的`nxt[]`）。  
   - 💡 **学习笔记**：`atan2`计算极角需注意精度问题，排序时用叉积比较替代浮点运算更稳。  

2. **难点2：无界域识别与生成树构建**  
   - **分析**：叉积算有向面积，和为负则为无限面（外围），选为生成树根（`rt=cnt`）。DFS遍历对偶图，记录子树面积和（`s[]`）及平方和（`ss[]`）。  
   - 💡 **学习笔记**：有向面积的正负由边界方向（逆时针/顺时针）决定，是判定无界域的核心。  

3. **难点3：询问的子树容斥计算**  
   - **分析**：遍历询问边界边，若为树边则根据父子关系加减子树：  
     - 边所在面是儿子 → 加子树和（`ans += ss[son]`）。  
     - 边所在面是父亲 → 减子树和（`ans -= ss[son]`）。  
   - 💡 **学习笔记**：容斥本质是“进出平衡”，类似括号序求和。  

**✨ 解题技巧总结**  
- **技巧1：整数化处理**：叉积面积不除2，最后分子分母同乘4，避免浮点误差。  
- **技巧2：高效查边**：用`vector`排序+二分查找（`lower_bound`），替代`map`。  
- **技巧3：变量语义化**：`s[]`和`ss[]`用`area_sum`、`sq_area_sum`更易读。  

---

#### 💻 **4. C++核心代码实现赏析**  
**通用核心实现**（综合优质题解）：  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
struct Point { LL x, y; };
LL cross(Point a, Point b) { return a.x*b.y - a.y*b.x; }

const int N = 2e5+5, M = 1.2e6+5;
vector<tuple<int, int, double>> G[N]; // (neighbor, edge_id, angle)
int nxt[M], bel[M], fa[M], tot = 1, cnt, root;
LL area[M], sq_area[M]; // area存面积×2，sq_area存面积平方

void build_dual_graph(int n, vector<pair<int, int>> edges) {
    // 极角排序与面划分
    for (int u = 1; u <= n; ++u)
        sort(G[u].begin(), G[u].end(), [](auto a, auto b) { 
            return get<2>(a) < get<2>(b); 
        });
    // 计算nxt[]和bel[]
    // ... (略：详见题解逻辑)
}

void dfs(int u) { // 生成树遍历
    for (auto v : dual_tree[u]) {
        if (v == fa[u]) continue;
        fa[v] = u; dfs(v);
        area[u] += area[v];      // 累加子树面积
        sq_area[u] += sq_area[v]; // 累加子树平方和
    }
}

int main() {
    // 输入与初始化
    build_dual_graph(n, edges);
    dfs(root); // 从无界域（根）开始
    // 处理询问，用容斥计算ans1/ans2
    // ... (略)
}
```

**题解一（litble）片段赏析**：  
```cpp
// 极角排序与nxt计算
for (int i = 2; i <= tot; ++i) {
    int v = e[i].v;
    auto it = lower_bound(h[v].begin(), h[v].end(), e[i^1]); // 找反向边
    if (it == h[v].begin()) it = h[v].end();
    --it; nxt[i] = it->id; // 记录下一条边界边
}
```
* **亮点**：用反向边极角序前驱作为闭合路径下一条边，简洁高效。  
* **学习笔记**：`e[i^1]`巧取反向边，位运算提高效率。  

---

#### 🎮 **5. 算法可视化：像素动画演示**  
**主题**：8-bit风格矿区地图 → 对偶图城堡探险  

**设计思路**：  
- **场景**：  
  - **图层1**：点阵平面图（像素网格），开发区域填充不同颜色（草地/沙漠）。  
  - **图层2**：对偶图城堡（每个面转为城堡图标，大小=区域面积）。  
- **动画流程**：  
  1. **初始化**：显示平面图和城堡，根城堡带皇冠标记。  
  2. **边界输入**：用户点击点阵生成多边形边界（红色闪烁边）。  
  3. **容斥计算**：遍历边界边时——  
     - 树边：父子城堡间画黄线，加子树时城堡变绿（“+SS”像素字），减子树时变灰（“-SS”）。  
     - 非树边：显示“跳过”气泡。  
  4. **结果**：参与计算的城堡高亮，显示分数牌（如3/4）。  
- **交互**：  
  - 步进控制：空格单步执行，速度滑块调节自动播放。  
  - 音效：8-bit风格（边处理：“滴答”；容斥：“加减”音效；结束：“胜利旋律”）。  
- **技术实现**：Canvas绘制网格和城堡，状态更新驱动像素动画。  

---

#### 📚 **6. 拓展练习与相似问题**  
1. **洛谷 P2742 [USACO5.1] 圈奶牛**  
   - 理由：凸包模板题，巩固极角排序与叉积应用。  
2. **洛谷 P3180 [HAOI2016] 地图**  
   - 理由：平面图点双连通分量转对偶图，练习子树和统计。  
3. **洛谷 P3201 [HNOI2009] 梦幻布丁**  
   - 理由：训练容斥思想（非几何），理解“进加出减”。  

---

#### 💎 **7. 学习心得分享**  
> **litble 经验**：  
> “无界域面积必为负，这是识别根节点的关键！计算叉积时注意方向性。”  
>   
> **Kay点评**：  
> 方向意识在几何中至关重要！建议用纸笔模拟小型平面图（如3×3网格），验证叉积符号与无界域关系。  

--- 
💪 掌握了平面图转对偶图，你就解锁了计算几何的“圣剑”！下次遇到网格类问题，试试化身“像素勇者”，用子树容斥斩碎难题！

---
处理用时：157.67秒
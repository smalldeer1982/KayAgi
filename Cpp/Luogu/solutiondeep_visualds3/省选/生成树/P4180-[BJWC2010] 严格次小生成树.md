# 题目信息

# [BJWC2010] 严格次小生成树

## 题目描述

小 C 最近学了很多最小生成树的算法，Prim 算法、Kruskal 算法、消圈算法等等。正当小 C 洋洋得意之时，小 P 又来泼小 C 冷水了。小 P 说，让小 C 求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是 $E_M$，严格次小生成树选择的边集是 $E_S$，那么需要满足：($value(e)$ 表示边 $e$ 的权值) $\sum_{e \in E_M}value(e)<\sum_{e \in E_S}value(e)$。

这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。


## 说明/提示

数据中无向图**不保证无自环**。

对于 $50\%$ 的数据， $N\le 2000$，$M\le 3000$。

对于 $80\%$ 的数据， $N\le 5\times 10^4$，$M\le 10^5$。

对于 $100\%$ 的数据， $N\le 10^5$，$M\le 3\times10^5$，边权  $\in [0,10^9]$，数据保证必定存在严格次小生成树。

## 样例 #1

### 输入

```
5 6
1 2 1 
1 3 2 
2 4 3 
3 5 4 
3 4 3 
4 5 6 ```

### 输出

```
11```

# AI分析结果


根据题目描述和题解分析，我们需要解决严格次小生成树问题。主要思路是先使用 Kruskal 算法求出最小生成树（MST），然后通过枚举非树边，将其加入 MST 形成环，再删除环上的一条边（严格小于非树边权值的最大边权）来得到严格次小生成树。具体步骤如下：

1. **Kruskal 求 MST**：
   - 对边按权值升序排序。
   - 使用并查集构建 MST，记录树边和总权值。
   - 构建 MST 的邻接表用于后续处理。

2. **倍增预处理**：
   - 在 MST 上进行 DFS，初始化深度、父节点、以及每个节点向上跳 2^k 步的祖先节点 f[u][k]。
   - 预处理每个节点向上路径的最大边权 max1[u][k] 和严格次大边权 max2[u][k]。

3. **LCA 查询**：
   - 实现 LCA 查询函数，用于找到两点最近公共祖先。
   - 实现路径查询函数，获取两点路径上的最大边权和严格次大边权。

4. **枚举非树边**：
   - 遍历每条非树边，计算将其加入 MST 后形成环。
   - 查询环上的最大边权和严格次大边权。
   - 根据非树边权值与最大边权的关系，计算候选答案：
     - 若非树边权值大于最大边权，则替换最大边权。
     - 若等于，则替换严格次大边权（保证严格大于 MST）。
   - 更新全局严格次小生成树权值。

5. **输出结果**。

下面给出完整代码，已加入详细注释：

```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
#include <vector>
#include <climits>
using namespace std;
typedef long long LL;

const int MAXN = 100005;
const int MAXM = 300005;
const int LOG = 17; // 2^17 > 100000
const LL INF = 1e18;

struct Edge {
    int u, v, w;
    bool used; // 标记是否为 MST 的边
    bool operator<(const Edge& other) const {
        return w < other.w;
    }
} edges[MAXM];

struct TreeEdge {
    int to, w;
};

vector<TreeEdge> graph[MAXN]; // MST 的邻接表
int n, m;
LL MST = 0; // 最小生成树权值和

// 并查集
int parent[MAXN];
int find(int x) {
    return parent[x] == x ? x : parent[x] = find(parent[x]);
}

// Kruskal 算法求 MST
void kruskal() {
    sort(edges + 1, edges + m + 1);
    for (int i = 1; i <= n; i++) parent[i] = i;
    int count = 0;
    for (int i = 1; i <= m; i++) {
        if (count == n - 1) break;
        int u = edges[i].u, v = edges[i].v, w = edges[i].w;
        int pu = find(u), pv = find(v);
        if (pu != pv) {
            parent[pu] = pv;
            MST += w;
            edges[i].used = true;
            count++;
            // 构建 MST 邻接表
            graph[u].push_back({v, w});
            graph[v].push_back({u, w});
        }
    }
}

// 倍增数组
int depth[MAXN];
int f[MAXN][LOG + 1];
LL max1[MAXN][LOG + 1]; // 最大边权
LL max2[MAXN][LOG + 1]; // 严格次大边权

// DFS 预处理深度和父节点
void dfs(int u, int fa, int weight) {
    depth[u] = depth[fa] + 1;
    f[u][0] = fa;
    max1[u][0] = weight;
    max2[u][0] = -INF; // 初始化为负无穷

    for (int i = 1; i <= LOG; i++) {
        f[u][i] = f[f[u][i - 1]][i - 1];
        // 更新当前段的最大值和次大值
        LL a = max1[u][i - 1];
        LL b = max1[f[u][i - 1]][i - 1];
        // 当前段的最大值
        max1[u][i] = max(a, b);
        // 当前段的次大值：取小于最大值的最大值
        max2[u][i] = max(a < b ? a : b, max(max2[u][i - 1], max2[f[u][i - 1]][i - 1]));
        // 注意：如果两个最大值相等，次大值取两个次大值的较大者
        if (a == b) {
            max2[u][i] = max(max2[u][i - 1], max2[f[u][i - 1]][i - 1]);
        }
    }

    // 遍历邻接点
    for (auto& e : graph[u]) {
        if (e.to == fa) continue;
        dfs(e.to, u, e.w);
    }
}

// 更新最大值和次大值
void update(LL& m1, LL& m2, LL val) {
    if (val > m1) {
        m2 = m1;
        m1 = val;
    } else if (val != m1 && val > m2) {
        m2 = val;
    }
}

// 查询路径 u->v 的最大值和次大值（v 是 u 的祖先）
pair<LL, LL> querySeg(int u, int v) {
    LL max_val = -INF, sec_val = -INF;
    // 从 u 跳到 v
    for (int i = LOG; i >= 0; i--) {
        if (depth[f[u][i]] >= depth[v]) {
            // 更新当前段的最大值和次大值
            update(max_val, sec_val, max1[u][i]);
            update(max_val, sec_val, max2[u][i]);
            u = f[u][i];
        }
    }
    return {max_val, sec_val};
}

// LCA 查询
int lca(int u, int v) {
    if (depth[u] < depth[v]) swap(u, v);
    for (int i = LOG; i >= 0; i--) {
        if (depth[f[u][i]] >= depth[v]) {
            u = f[u][i];
        }
    }
    if (u == v) return u;
    for (int i = LOG; i >= 0; i--) {
        if (f[u][i] != f[v][i]) {
            u = f[u][i];
            v = f[v][i];
        }
    }
    return f[u][0];
}

int main() {
    scanf("%d %d", &n, &m);
    for (int i = 1; i <= m; i++) {
        scanf("%d %d %d", &edges[i].u, &edges[i].v, &edges[i].w);
        edges[i].used = false;
    }

    // 求 MST
    kruskal();

    // 初始化深度和根节点
    depth[0] = 0; // 0 为虚拟根节点
    dfs(1, 0, 0);

    // 枚举非树边
    LL ans = INF;
    for (int i = 1; i <= m; i++) {
        if (edges[i].used) continue;
        int u = edges[i].u, v = edges[i].v, w = edges[i].w;
        int l = lca(u, v);

        // 查询 u->l 和 v->l 路径的最大值和次大值
        auto p1 = querySeg(u, l);
        auto p2 = querySeg(v, l);

        // 合并两段路径的最大值和次大值
        LL max_val = max(p1.first, p2.first);
        LL sec_val = max(p1.second, p2.second);
        if (p1.first != p2.first) {
            sec_val = max(sec_val, min(p1.first, p2.first));
        }

        // 计算候选答案
        LL candidate;
        if (w > max_val) {
            candidate = MST - max_val + w;
        } else if (w == max_val) {
            candidate = MST - sec_val + w;
        } else {
            // 非树边权值小于最大边权，不能替换
            continue;
        }

        // 更新答案（严格大于 MST）
        if (candidate > MST) {
            ans = min(ans, candidate);
        }
    }

    printf("%lld\n", ans);
    return 0;
}
```

### 注意事项：
1. **严格次大值处理**：在倍增预处理时，需确保次大值严格小于最大值，避免相等。
2. **LCA 查询**：在查询路径最大值时，需分别处理两个节点到 LCA 的路径。
3. **答案更新**：候选答案必须严格大于最小生成树权值。
4. **效率**：使用邻接表和倍增法，时间复杂度为 O(m log n)，满足题目要求。

此代码经过详细注释，逻辑清晰，适用于严格次小生成树问题。

---
处理用时：243.88秒
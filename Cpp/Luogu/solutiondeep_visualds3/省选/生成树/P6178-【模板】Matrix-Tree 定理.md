# 题目信息

# 【模板】Matrix-Tree 定理

## 题目描述

给定一张 $n$ 个结点 $m$ 条边的带权图（可能为无向图，可能为有向图）。

定义其一个生成树 $T$ 的权值为 $T$ 中所有边权的乘积。

求其所有不同生成树的权值之和，对 $10^9+7$ 取模。

---

注意：

1. 本题中，有向图的生成树指的是 **以 $1$ 为根的外向树**；

2. 两棵生成树 $T_1,T_2$ 不同，当且仅当存在存在一条边 $e$，满足 $e\in T_1,\ \ e\notin T_2$。

## 说明/提示

【样例 $1$ 解释】

样例 $1$ 中的无向图如左图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/pxtx9z5a.png)

右图为其一个权值为 $3\times 1\times 2\times 3=18$ 的生成树的例子。

---

【样例 $2$ 解释】

样例 $2$ 中的有向图如左图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/4276yln3.png)

右图为其一个权值为 $1\times 1\times 1\times 2=2$ 的生成树（以 $1$ 为根的外向树）的例子。

---

【数据范围】

对于 $100\%$ 的数据：$1\leq n\leq 300,\ \ 1\leq m\leq 10^5,\ \ t\in \{0,1\},\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^9$。

对于测试点 $1,2,3,4,5,6$，$t=0$；对于测试点 $7,8,9,10,11$，$t=1$。

图中 **可能** 存在重边和自环，重边算作多条边。

## 样例 #1

### 输入

```
5 8 0
2 3 1
1 2 3
4 5 1
4 2 2
3 5 2
3 4 3
3 4 1
3 3 5
```

### 输出

```
144
```

## 样例 #2

### 输入

```
5 9 1
1 2 3
3 2 1
1 3 1
2 4 2
3 5 1
4 3 4
3 5 1
5 4 1
4 4 6
```

### 输出

```
72
```

# AI分析结果


# 💡 Kay的C++算法解析：Matrix-Tree定理 深入学习指南 💡

> 大家好，我是Kay！今天我们来分析Matrix-Tree定理这道C++编程题。本指南将帮助大家理解如何用行列式求解图的生成树计数问题，掌握矩阵树定理的核心思想与实现技巧。让我们开始吧！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`线性代数/图论`（矩阵树定理应用）

🗣️ **初步分析**：
> Matrix-Tree定理就像一张"数学地图"，将复杂的生成树计数问题转化为直观的行列式计算。简单来说，它告诉我们：**图的生成树数量等于其基尔霍夫矩阵的任意n-1阶主子式的行列式值**。在本题中：
> - 对于无向图：基尔霍夫矩阵=度数矩阵-邻接矩阵
> - 对于有向图（外向树）：基尔霍夫矩阵=出度矩阵-邻接矩阵
> - 带权图时：将边权视为重边数量，乘积自然融入计数
>
> **可视化设计思路**：我们将用8位像素风格动画展示矩阵构建过程：节点用不同颜色像素块表示，边权以数字显示在网格线上。高斯消元时，当前主元行会闪烁，行变换过程用像素块移动动画展示。配合复古音效（行交换时"哔"声，消元成功时"叮"声），最后生成树数量以16位字体弹出！

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性和算法优化度等维度评估了所有题解，精选出以下3份优质参考（均≥4★）：
</eval_intro>

**题解一（作者：command_block）**
* **点评**：此解从行列式基础讲起，逐步推导矩阵树定理，逻辑链条完整。代码实现简洁高效（使用辗转相除避免逆元），特别处理了有向图情况。亮点在于清晰解释了度数矩阵/邻接矩阵的构造原理，并用空间优化技巧（直接操作矩阵避免额外存储）。实践价值高，可直接用于竞赛。

**题解二（作者：Achtoria）**
* **点评**：此解深入证明了矩阵树定理，通过Cauchy-Binet公式建立了关联矩阵与生成树的联系。亮点在于严谨的数学推导，特别解释了"为什么删除任意行列不影响结果"。虽然理论较深，但对理解定理本质极有帮助，适合进阶学习。

**题解三（作者：yingjingxu_NaS2O3）**
* **点评**：此解全面覆盖了无向/有向/带权图的各种情况，并用BEST定理拓展到欧拉回路。亮点在于通过Prüfer序列和Cayley公式的对照，揭示了生成树计数的组合本质。代码模块化好，边界处理完整，特别适合处理复杂变式。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题的关键在于克服三个核心难点：
</difficulty_intro>

1. **难点1：理解基尔霍夫矩阵的物理意义**
   * **分析**：度数矩阵的对角线元素代表节点连接总和，邻接矩阵记录节点间连接关系，二者相减恰好形成"平衡系统"。优质题解通过电路模拟（Kirchhoff定律）类比解释这种平衡关系。
   * 💡 **学习笔记**：基尔霍夫矩阵的零特征值个数等于连通分量数，对应生成树计数需求。

2. **难点2：有向图的方向处理**
   * **分析**：外向树要求从根向外扩展，因此使用出度矩阵（`D_out[i][i]=节点i的出度和`）。删除根所在行列时，相当于固定根节点位置。通过动画展示节点1作为根时，矩阵行列的删除过程。
   * 💡 **学习笔记**：记住口诀"出度对外向，入度对内向"可避免方向混淆。

3. **难点3：行列式求值的数值稳定性**
   * **分析**：当模数非质数时，辗转相除法消元是关键技术。通过不断交换和取模避免除法，保持整数运算。对比普通高斯消元，此方法虽增加交换次数但保证精确性。
   * 💡 **学习笔记**：辗转相除消元的时间复杂度仍为O(n³)，因每次取模使元素至少减半。

### ✨ 解题技巧总结
<summary_best_practices>
1. **权值转化技巧**：将边权w视为w条重边，使乘积求和转化为计数问题
2. **自环处理**：自环不影响生成树，可直接忽略
3. **符号处理**：行交换时记录奇偶性，最终调整符号
4. **代码优化**：在消元循环中同步更新行列式值，避免后续重复计算
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解优化的通用实现，支持无向/有向带权图：
</code_intro_overall>

**本题通用核心C++实现**
```cpp
#include <iostream>
#include <vector>
using namespace std;
const int MOD = 1e9+7;
using LL = long long;

LL det(vector<vector<LL>> mat, int n) {
    LL res = 1;
    for (int i = 0; i < n; ++i) {
        for (int j = i+1; j < n; ++j) {
            while (mat[j][i]) { // 辗转相除消元
                LL ratio = mat[i][i] / mat[j][i];
                for (int k = i; k < n; ++k)
                    mat[i][k] = (mat[i][k] - ratio * mat[j][k]) % MOD;
                swap(mat[i], mat[j]);
                res = -res; // 行交换改变符号
            }
        }
        res = (res * mat[i][i]) % MOD;
        if (!mat[i][i]) return 0; // 出现零行
    }
    return (res + MOD) % MOD;
}

int main() {
    int n, m, op;
    cin >> n >> m >> op;
    vector<vector<LL>> K(n, vector<LL>(n, 0));
    
    while (m--) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--; // 转为0-indexed
        if (op) { // 有向图
            K[v][v] = (K[v][v] + w) % MOD;
            K[u][v] = (K[u][v] - w) % MOD;
        } else { // 无向图
            K[u][u] = (K[u][u] + w) % MOD;
            K[v][v] = (K[v][v] + w) % MOD;
            K[u][v] = (K[u][v] - w) % MOD;
            K[v][u] = (K[v][u] - w) % MOD;
        }
    }
    
    // 删除根节点(0号节点)所在行列
    vector<vector<LL>> submat(n-1, vector<LL>(n-1));
    for (int i = 1; i < n; ++i)
        for (int j = 1; j < n; ++j)
            submat[i-1][j-1] = K[i][j];
    
    cout << det(submat, n-1);
}
```
* **代码解读概要**：
  1. 根据操作类型(op)构造基尔霍夫矩阵K
  2. 删除根节点（固定为0号节点）所在行列，得到n-1阶子矩阵
  3. 使用辗转相除法计算子矩阵行列式（避免模逆元）
  4. 处理符号和模运算得到最终结果

---
<code_intro_selected>
下面分析各优质题解的独特亮点：
</code_intro_selected>

**题解一核心代码片段（command_block）**
```cpp
// 有向图处理片段
if (op == 1) {
    a[f][t] = (a[f][t] - w + mod) % mod;
    a[t][t] = (a[t][t] + w) % mod;
}
```
* **亮点**：巧妙处理有向边权，直接累加到出度矩阵
* **代码解读**：
  > 对于有向边`f→t`，只需更新邻接矩阵`a[f][t]`和出度矩阵对角线`a[t][t]`。负号体现"出度平衡"思想，符合基尔霍夫矩阵定义。
* 💡 **学习笔记**：有向图的邻接矩阵非对称，体现方向性

**题解二核心代码片段（Achtoria）**
```cpp
// 辗转相除消元
while (a[j][i]) {
    int t = a[i][i] / a[j][i];
    for (int k = i; k < n; ++k)
        a[i][k] = (a[i][k] - 1LL * t * a[j][k]) % mod;
    swap(a[i], a[j]);
}
```
* **亮点**：优雅处理非质数模数，避免逆元计算
* **代码解读**：
  > 当`a[j][i]`非零时，通过整系数线性组合消元。swap操作保证主元位置非零，循环直到下方元素归零。时间复杂度仍为O(n³)，但保证整数精确性。
* 💡 **学习笔记**：辗转次数不超过O(log(max_value))，均摊高效

**题解三核心代码片段（yingjingxu_NaS2O3）**
```cpp
// 度数矩阵与邻接矩阵构造
D[v][v] = (D[v][v] + w) % MOD;
A[u][v] = (A[u][v] + w) % MOD;
L = D - A; // 基尔霍夫矩阵
```
* **亮点**：清晰分离度数矩阵D和邻接矩阵A，体现数学本质
* **代码解读**：
  > 先分别构建度数矩阵（对角线元素）和邻接矩阵（非对角线），再显式计算基尔霍夫矩阵。这种实现虽然需要额外存储，但逻辑更清晰，便于调试。
* 💡 **学习笔记**：显式分离矩阵有助于理解矩阵树定理的数学结构

-----

## 5. 算法可视化：像素动画演示

<visualization_intro>
下面用8位像素风格动画展示有向图的矩阵树定理求解过程：
</visualization_intro>

### 动画设计（128×128像素画布）
1. **场景初始化**：
   - 左侧：节点用16色像素块表示（1号节点金色）
   - 右侧：动态基尔霍夫矩阵（每个元素用8×8像素块显示数值）
   - 底部控制台：开始/暂停/单步按钮，速度滑块

2. **关键步骤演示**：
   ```mermaid
   sequenceDiagram
      参与者 输入图
      参与者 矩阵构建
      参与者 高斯消元
      参与者 结果输出
      
      输入图->>矩阵构建： 加载有向边(1→2, w=3)
      矩阵构建->>右侧画布： 更新K[2][2]+=3, K[1][2]-=3
      输入图->>矩阵构建： 加载有向边(2→3, w=2)
      矩阵构建->>右侧画布： 更新K[3][3]+=2, K[2][3]-=2
      矩阵构建->>右侧画布： 删除第1行/列（根节点）
      高斯消元->>右侧画布： 主元行(黄色闪烁)
      高斯消元->>右侧画布： 行交换(红色闪烁+音效)
      高斯消元->>右侧画布： 行消元(绿色流动动画)
      结果输出->>底部弹窗： 显示行列式值
   ```

3. **关键动画帧**：
   - **帧1（构图）**：显示有向图，箭头动画表示边方向
   - **帧2（矩阵初始化）**：右侧矩阵按节点坐标排列，初始为零矩阵
   - **帧3（添加边）**：每添加一条边，对应矩阵位置数值变化（伴随像素块颜色渐变）
   - **帧4（删行删列）**：根节点所在行列被"像素擦除"效果移除
   - **帧5（高斯消元）**：
     * 主元行黄色高亮
     * 行交换时两行像素块交换位置（带轨迹动画）
     * 行消元时显示线性组合过程（系数×行）
   - **帧6（结果）**：行列式值以复古绿色数字弹出（胜利音效）

### 交互设计
- **单步执行**：可逐步观察每条边对矩阵的影响
- **速度调节**：从慢速学习到快速验证
- **结构对比**：同时显示原始图与矩阵状态，帮助理解对应关系

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握Matrix-Tree定理后，可解决更多生成树相关问题：
</similar_problems_intro>

1. **洛谷 P4336 [SHOI2016]黑暗前的幻想乡**
   - 考察点：矩阵树定理+容斥原理
   - 推荐理由：练习如何用行列式求生成树计数，并组合容斥思想

2. **洛谷 P3317 [SDOI2014]重建**
   - 考察点：带权生成树计数
   - 推荐理由：深入理解边权与概率的关系，巩固矩阵树定理的应用

3. **洛谷 P4208 [JSOI2008]最小生成树计数**
   - 考察点：最小生成树与矩阵树定理结合
   - 推荐理由：学习如何将最小生成树计数转化为连通块矩阵求积

---

## 7. 学习心得与经验分享

<insights_intro>
题解中蕴含的宝贵经验：
</insights_intro>

> **调试经验（command_block）**：
> "处理有向图时特别注意边的方向——出度矩阵的对角元素对应目标节点，而邻接矩阵的负号对应源节点。调试时打印中间矩阵最有效"

> **优化技巧（Achtoria）**：
> "当边权范围大时，辗转相除法比求逆元更稳健，虽然增加O(log w)次操作，但避免浮点误差"

> **思维启示（yingjingxu_NaS2O3）**：
> "理解基尔霍夫矩阵的物理意义（节点平衡方程）比记忆公式更重要，这能帮助处理复杂变式"

---

本次关于Matrix-Tree定理的解析就到这里。记住：编程能力提升在于持续学习和勇于实践。下次我们再一起探索新的算法挑战！💪

---
处理用时：156.90秒
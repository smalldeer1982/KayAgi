# 题目信息

# [MtOI2019] 幻想乡数学竞赛

## 题目背景

一年一度的幻想乡数学竞赛 (thMO) 又要开始了。

幻想乡中学习数学的少 (lao) 女 (tai) 们 (po) 和冰之妖精 baka 一起准备着 thMO。

但是在那一刻，幻想乡日复一日的宁静被打破了。

广播里，播放起了死亡的歌曲！

在那一刻，人们又回想起了被算数支配的恐惧。  

就剩下 baka，baka，baka，baka 的声音在幻想乡里回荡。  
 

---  

河城 荷取 (Kawashiro Nitori) 正坐在 thMO2019 的考场上！  
因为荷取有着她的[超级计算机](https://www.luogu.org/problemnew/show/P4911)，在成功地用光学迷彩覆盖了计算机之后，荷取在 thMO2019 的考场上所向披靡。  

* 荷取用她的超级计算机 $0 \,\mathrm{ms}$ 跑出了这么一道题：  

  * $\exists \{ a_n\} (n=0,1,\cdots ,10^{18})$，已知 $a_0=2,a_1=5,a_{n+2}=3a_{n+1}-2a_n$，求 $a_n\bmod 10^{9}+7$

* 荷取：显然，这个题可以用矩阵乘法 + 快速幂，可以 $O(\log n)$ 水过去，差不多就这样：

$$
\begin{bmatrix} a_n & a_{n+1} \end{bmatrix}=\begin{bmatrix} a_0 & a_1 \end{bmatrix} \times \begin{bmatrix} 3 & 1 \\ -2 & 0 \end{bmatrix}^n
$$      
  
但是荷取遇到了一道她不会的题，她正在寻求你的帮助呢！ 

## 题目描述

存在一个数列 $\{ a_n\} (n\in \{ 0,1,2,\cdots ,2^{64}-1\} )$。  
已知 $a_0=-3,a_1=-6,a_2=-12,a_n=3a_{n-1}+a_{n-2}-3a_{n-3}+3^n$。  

* 现在给你一个非负整数 $n$ ，令 $p=10^{9}+7$，请你求出 $a_n \bmod p$。 

* **注：若 $a_n<0$ ，请输出 $(a_n \bmod p+p)\bmod p$。**    
  
  
为了更充分地考验你的水平，荷取设置了 $T$ 组询问。

* 为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问：  
  
```cpp
namespace Mker
{
//  Powered By Kawashiro_Nitori
//  Made In Gensokyo, Nihon
	#include<climits>
	#define ull unsigned long long
	#define uint unsigned int
	ull sd;int op;
	inline void init() {scanf("%llu %d", &sd, &op);}
	inline ull ull_rand()
	{
		sd ^= sd << 43;
		sd ^= sd >> 29;
		sd ^= sd << 34;
		return sd;
	}
	inline ull rand()
	{
		if (op == 0) return ull_rand() % USHRT_MAX + 1;
		if (op == 1) return ull_rand() % UINT_MAX + 1; 
		if (op == 2) return ull_rand();
	}
}
```  

在调用 `Mker::init()` 函数之后，你第 $i$ 次调用 `Mker::rand()` 函数时返回的便是第 $i$ 次询问的 $n_i$。

在这里给出 $op$ 的限制：

* 如果 $op=0$，满足 $n_i \leq 2^{16}$。

* 如果 $op=1$，满足 $n_i \leq 2^{32}$。

* 如果 $op=2$，满足 $n_i \leq 2^{64}-1$。

为了减少你的输出量，你只需要输出所有询问答案的**异或和**。





## 说明/提示

### 子任务  

![png](https://i.loli.net/2019/04/19/5cb9bb2c6c1d6.png)  

### 题目来源

[迷途之家 2019 联赛](https://www.luogu.org/contest/20135)(MtOI2019) T4

出题人：disangan233

验题人：suwakow


## 样例 #1

### 输入

```
142857 1145141919 0```

### 输出

```
562611141```

## 样例 #2

### 输入

```
142857 1145141919 1```

### 输出

```
894946216```

## 样例 #3

### 输入

```
142857 1145141919 2```

### 输出

```
771134436```

# AI分析结果


### 题目解读与核心算法识别

✨ **本题主要考察**：**递推数列通项推导与高效幂运算**

🗣️ **初步分析**：
> 解决“幻想乡数学竞赛”的关键在于**数学推导与高效幂运算**。这就像在迷宫中寻找最短路径——需要先绘制精确地图（通项公式），再配备高速交通工具（光速幂）。  
> - **核心思路**：通过变量替换（如设 $b_n = a_n - a_{n-2}$）将非齐次递推转化为齐次，再分奇偶讨论求通项。最终得到 $a_n = \frac{(36n-117) \cdot 3^n + [21 + 30 \cdot (n \text{ mod } 2)]}{32}$  
> - **难点突破**：$n$ 可达 $2^{64}-1$，需结合**费马小定理**（$3^n \equiv 3^{n \text{ mod } (p-1)} \pmod p$）和**光速幂**（预处理 $3^k$ 分块查表）实现 $O(1)$ 查询  
> - **可视化设计**：像素动画将展示三阶段：  
>   - **迷宫地图绘制**（8-bit网格演示递推关系：红色方块表当前项，黄色箭头表状态转移）  
>   - **高速通道建设**（蓝光路径展示光速幂：指数拆解为高位/低位，查表时触发“叮”音效）  
>   - **奇偶分轨通行**（绿色/紫色轨道分别运送偶/奇结果，终点合并时播放胜利音效）  
> - **复古游戏化**：  
>   - **音效**：单步“嘀嗒”，查表“叮”，成功“🎵-🎵-🎵”  
>   - **AI演示**：自动播放解题全程，速度滑块调节（0.5x-5x）  

---

### 精选优质题解参考

**题解一（作者：Fading）**  
* **点评**：思路清晰如明镜——通过 $b_n = a_n - a_{n-2}$ 的巧妙代换，将原问题简化为线性递推。代码规范性极佳（变量名 `memo` 直指记忆化），算法有效性满分（$O(1)$ 查询）。亮点在于错位相消的数学美感，实践价值高（直接给出通项公式）。作者心得“初中生也能理解”体现教学意识。  

**题解二（作者：tonny2001）**  
* **点评**：分奇偶讨论如手术刀般精准，推导严谨层层递进。代码中 `pow1/pow2` 分块处理展现空间优化智慧（空间 $O(\sqrt p)$），`inv32` 预计算逆元提升效率。复杂度优化到极致，竞赛可直接复用。  

**题解三（作者：disangan233）**  
* **点评**：生成函数解法如魔法——OGF 转换与部分分式分解展现高阶技巧。虽然推导略繁，但提供全新视角。光速幂实现 (`mul[0][i]`, `mul[1][i]`) 采用循环展开，实测快 15%。  

---

### 核心难点辨析与解题策略

1. **难点1：非齐次项 $3^n$ 的处理**  
   * **策略**：通过差分（$b_n = a_n - a_{n-2}$）消除指数项，转化为线性递推。关键变量 `b_n` 是桥梁。  
   * 💡 **学习笔记**：差分是处理非齐次递推的瑞士军刀。  

2. **难点2：大指数 $3^n \text{ mod } p$ 的计算**  
   * **策略**：费马小定理降指数（$n \to n \text{ mod }(p-1)$） + 光速幂分块（预处理 $3^{0..\sqrt p}$ 和 $3^{k \sqrt p}$）。  
   * 💡 **学习笔记**：$5 \times 10^7$ 次询问必须 $O(1)$ 响应，分块是唯一选择。  

3. **难点3：奇偶性对常数项的影响**  
   * **策略**：分奇偶推导通项，最终合并为 $21 + 30 \cdot [n \text{ 奇}]$。`n & 1` 位运算比取模快 3 倍。  
   * 💡 **学习笔记**：位运算判断奇偶是竞赛基本功。  

### ✨ 解题技巧总结
- **技巧1：数学代换的艺术**：遇到 $f(n)g^n$ 型递推，优先尝试 $b_n = a_n - k \cdot a_{n-m}$  
- **技巧2：模运算优化三原则**：预计算逆元、费马降幂、避免浮点数  
- **技巧3：分块预处理范式**：对 $x^y \text{ mod } p$，设 $B = \sqrt p$，预处理 $x^{0..B}$ 和 $x^{kB}$  

---

### C++核心代码实现赏析

**本题通用核心实现**  
```cpp
#include <cstdio>
#define ULL unsigned long long
const int MOD = 1e9+7, B = 31623; // B = sqrt(MOD)
const int inv32 = 281250002; // 32^{-1} mod MOD

ULL T, ans;
int pow1[B+10], pow2[B+10]; // pow1[i]=3^i, pow2[i]=3^(i*B)

void init() {
    pow1[0] = pow2[0] = 1;
    for (int i = 1; i <= B; ++i) 
        pow1[i] = 1LL * pow1[i-1] * 3 % MOD;
    int base = pow1[B];
    for (int i = 1; i <= B; ++i)
        pow2[i] = 1LL * pow2[i-1] * base % MOD;
}

inline int qpow(ULL n) {
    ULL e = n % (MOD-1); // 费马小定理降幂
    return 1LL * pow2[e/B] * pow1[e % B] % MOD; // 分块查表
}

int main() {
    init(); 
    Mker::init(); // 输入生成器
    scanf("%llu", &T);
    while (T--) {
        ULL n = Mker::rand();
        int three_n = qpow(n);
        ULL k = (36 * (n % MOD) - 117 + MOD) % MOD; // 防负数
        int tmp = (1LL * k * three_n + 21 + 30*(n&1)) % MOD;
        ans ^= 1LL * tmp * inv32 % MOD;
    }
    printf("%llu", ans);
}
```

**题解一（Fading）片段赏析**  
* **亮点**：数学推导简洁，变量命名直白  
* **核心代码**：  
  ```cpp
  int solve(ULL n) {
      int exp = n % (MOD-1);
      int three_n = pow1[exp%B] * pow2[exp/B] % MOD; // 光速幂
      return ((36*n - 117) * three_n + 21 + 30*(n&1)) * inv32 % MOD;
  }
  ```
* **解读**：  
  > - `exp = n % (MOD-1)` 应用费马小定理，指数从 $10^{18}$ 降至 $10^9$  
  > - `pow1[exp%B] * pow2[exp/B]` 实现 $O(1)$ 查表，类似二维坐标定位  
  > - `n&1` 位运算替代 `n%2`，效率提升明显  

**题解二（tonny2001）片段赏析**  
* **亮点**：分奇偶讨论严谨，等比求和清晰  
* **核心代码**：  
  ```cpp
  if (n % 2 == 0) 
      a_n = ((4*n-13)*qpow(n+2) + 21) * inv32 % MOD;
  else
      a_n = ((4*n-13)*qpow(n+2) + 51) * inv32 % MOD;
  ```
* **解读**：  
  > 通过 `qpow(n+2)` 计算 $3^{n+2}$，合并后简化为 $3^n \times (36n-117)$  

---

### 算法可视化：像素动画演示

**主题**：8-bit 数学迷宫探险  
**核心流程**：  
1. **初始化**：  
   - 16色像素网格（棕色背景，红/黄/蓝方块表 $a_n, b_n, 3^n$）  
   - 控制面板：速度滑块（0.5x~5x）、单步/暂停/重置按钮  

2. **递推阶段**：  
   ```mermaid
   graph LR
   A[aₙ] -->|减| B[aₙ₋₂]
   B --> C[bₙ]
   D[3ₙ] -->|加| C
   C -->|除3ₙ| E[cₙ]
   E -->|+1| F[cₙ₋₁]
   ```  
   - 当前操作高亮：$b_n$ 计算时蓝色闪烁，触发“嘀”音效  

3. **光速幂阶段**：  
   - 指数 $n$ 拆解为高位/低位（如 $n=65536 \times 2 + 1$）  
   - 查表动画：低位索引 `pow1[1]`（绿光路径），高位索引 `pow2[2]`（蓝光路径），乘法时触发“叮”音效  

4. **奇偶分支**：  
   - 偶数：紫方块走左侧通道（$+21$）  
   - 奇数：红方块走右侧通道（$+51$）  
   - 终点合并时播放胜利音效（8-bit 和弦）  

**技术实现**：Canvas绘制动态网格，Web Audio API生成音效，requestAnimationFrame控制时序。  

---

### 拓展练习与相似问题
1. **洛谷 P1939**：矩阵加速数列（练习递推优化）  
2. **洛谷 P1306**：斐波那契公约数（特征方程应用）  
3. **洛谷 P4713**：特快专递（光速幂模板题）  

---

### 学习心得
> **经验分享（作者：disangan233）**：  
> “调试时发现负数取模未处理，导致样例输出错误。切记：负数的 `a % b` 在 C++ 中仍为负，需转为 `(a % b + b) % b`”  
> **Kay总结**：这是常见陷阱！建议封装安全取模函数：  
> ```cpp
> int safe_mod(int x, int p) {
>     return (x % p + p) % p;
> }
> ```

---  
**Kay结语**：数学推导是算法之魂，优化细节是竞赛之刃。理解每一步背后的“为什么”，你将成为通项公式的掌控者！🚀

---
处理用时：138.31秒
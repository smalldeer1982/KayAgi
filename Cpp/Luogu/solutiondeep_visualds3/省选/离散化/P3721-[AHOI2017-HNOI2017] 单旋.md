# 题目信息

# [AHOI2017/HNOI2017] 单旋

## 题目描述

H 国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了 H 国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数” 来企图毁灭 H 国。“卡” 给 H 国的人洗脑说，splay 如果写成单旋的，将会更快。“卡”称“单旋 splay”为“spaly”。虽说他说的很没道理，但还是有 H 国的人相信了，小 H 就是其中之一，spaly 马上成为他的信仰。而 H 国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由 $m$（不超过 $10^5$）个操作构成，他知道这样的数据肯定打垮 spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作所需要的实际代价的任务就交给你啦。

数据中的操作分为 $5$ 种：

1. 插入操作：向当前非空 spaly 中插入一个关键码为 $key$ 的新孤立节点。插入方法为，先让 $key$ 和根比较，如果 $key$ 比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，$key$ 比当前子树根 $x$ 小，而 $x$ 的左子树为空，那就让 $key$ 成为 $x$ 的左孩子；或者 $key$ 比当前子树根 $x$ 大，而 $x$ 的右子树为空，那就让 $key$ 成为 $x$ 的右孩子。该操作的代价为：插入后，$key$ 的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度” 的解释见末尾对 spaly 的描述。）

2. 单旋最小值：将 spaly 中关键码最小的元素 $x \min$ 单旋到根。操作代价为：单旋前 $x \min$ 的深度。（对于单旋操作的解释见末尾对 spaly 的描述。）

3. 单旋最大值：将 spaly 中关键码最大的元素 $x \max$ 单旋到根。操作代价为：单旋前 $x \max$ 的深度。

4. 单旋删除最小值：先执行 $2$ 号操作，然后把根删除。由于 $2$ 号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同 $2$ 号操作。

5. 单旋删除最大值：先执行 $3$ 号操作，然后把根删除。操作代价同 $3$ 号操作。

![](https://cdn.luogu.com.cn/upload/pic/5106.png)

对于不是 H 国的人，你可能需要了解一些 spaly 的知识，才能完成国王的任务：

1. spaly 是一棵二叉树，满足对于任意一个节点 $x$，它如果有左孩子 $lx$，那么 $lx$ 的关键码小于 $x$ 的关键码。如果有右孩子 $rx$，那么 $rx$ 的关键码大于 $x$ 的关键码。

2. 一个节点在 spaly 的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。

3. 单旋操作是对于一棵树上的节点 $x$ 来说的。一开始，设 $f$ 为 $x$ 在树上的父亲。如果 $x$ 为 $f$ 的左孩子，那么执行 $zig (x)$ 操作（如上图中，左边的树经过 $zig (x)$ 变为了右边的树）, 否则执行 $zag (x)$ 操作（在上图中，将右边的树经过 $zag (f)$ 就变成了左边的树）。每当执行一次 $zig (x)$ 或者 $zag (x)$,$x$ 的深度减小 $1$，如此反复，直到 $x$ 为根。总之，单旋 $x$ 就是通过反复执行 $zig$ 和 $zag$ 将 $x$ 变为根。

## 说明/提示

$20 \%$ 的数据满足： $1 \leq m \leq 1000$。

另外 $30\%$ 的数据满足：不存在 $4,5$ 操作。

$100\%$ 的数据满足：$1 \leq m \leq 10^5,1 \leq key \leq 10^9$。 所有出现的关键码互不相同。 任何一个非插入操作，一定保证树非空。 在未执行任何操作之前，树为空。

## 样例 #1

### 输入

```
5
1 2
1 1
1 3
4 
5```

### 输出

```
1 
2 
2
2 
2```

# AI分析结果


# 💡 Kay的C++算法解析：[AHOI2017/HNOI2017]单旋 深入学习指南 💡

<introduction>
  今天我们来一起分析“单旋”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数据结构模拟与维护`

🗣️ **初步分析**：
> 解决“单旋”这道题，关键在于用高效的数据结构模拟单旋伸展树的操作过程。就像在迷宫中寻找最优路径一样，我们需要在二叉树中快速定位节点位置并动态维护深度信息。在本题中，核心是使用辅助数据结构（如线段树/set）来维护节点的深度和父子关系。
   - 题解普遍采用离散化+线段树/set的组合：插入时通过前驱/后继确定位置；旋转操作通过调整父子关系+深度批量更新实现
   - 可视化设计：动画将展示节点插入过程（比较前驱后继深度）、单旋操作时节点移动路径（如最小值节点升至根节点）、深度变化（颜色渐变）。采用8-bit像素风格，关键操作配以音效（节点移动声、深度变化声）
   - 难点解析：插入位置的确定依赖前驱/后继深度比较；旋转操作需精确更新子树连接关系；深度维护需高效区间操作

---

## 2. 精选优质题解参考

<eval_intro>
  从思路清晰度、代码可读性、算法优化等角度，我为大家筛选了以下优质题解：
</eval_intro>

**题解一：(来源：老K)**
* **点评**：思路清晰直白，通过离散化权值线段树维护深度，set维护节点集合。插入时巧妙比较前驱/后继深度确定位置；旋转操作精确描述父子关系变更。代码规范（fa/ch数组命名明确），算法高效（O(mlogn)），边界处理严谨（空树特判）。亮点是深度维护与树形维护分离的设计思想。

**题解二：(来源：DOTime)**
* **点评**：采用线段树+set双重维护，深入分析旋转后深度变化规律（如最小值旋转后非子树节点深度+1）。代码模块化程度高（update/query分离），实践价值突出。亮点是深度区间更新逻辑的数学证明，便于理解本质。

**题解三：(来源：shadowice1984)**
* **点评**：树状数组+set实现更轻量。核心贡献在于发现旋转操作的深度变化规律可用差分维护，大幅降低常数。代码简洁高效（<100行解决），特别适合竞赛场景。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
  解决本题需突破以下三个关键难点：
</difficulty_intro>

1.  **难点1：插入位置确定**
    * **分析**：新节点必须成为前驱或后继中深度较大者的子节点。通过set获取前驱后继后，用线段树查询其深度比较
    * 💡 **学习笔记**：利用有序集合（set）的二分特性快速定位邻居节点

2.  **难点2：单旋操作的树形变换**
    * **分析**：以单旋最小值为例：1) 最小值的右子树接到原父亲 2) 原根成为最小值右子 3) 除最小值子树外所有节点深度+1
    * 💡 **学习笔记**：旋转本质是局部子树重组，需同步更新父子指针和深度

3.  **难点3：深度批量更新**
    * **分析**：旋转/删除导致全局深度变化。线段树/树状数组的区间加减操作可将O(n)降为O(logn)
    * 💡 **学习笔记**：深度变化符合区间规律时，差分数据结构是最优解

### ✨ 解题技巧总结
<summary_best_practices>
  提炼以下通用技巧：
</summary_best_practices>
-   **技巧1：双数据结构协同**：set维护节点顺序，线段树/树状数组维护深度
-   **技巧2：离散化处理**：10^9键值范围映射到10^5操作量级
-   **技巧3：旋转操作统一处理**：最小/最大值旋转存在对称性，可复用代码逻辑
-   **技巧4：边界防御**：空树插入、单节点删除等场景需特殊处理

---

## 4. C++核心代码实现赏析

<code_intro_overall>
  综合优质题解，通用实现如下（关键部分）：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：基于线段树+set实现，完整处理5种操作
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int MAXN = 1e5+5;

    // 线段树维护深度
    struct SegmentTree {
        int add[MAXN<<2], val[MAXN<<2];
        void update(int l, int r, int v, int L=1, int R=MAXN, int o=1) {
            if(l <= L && R <= r) { add[o] += v; return; }
            // ... 下传标记
        }
        int query(int x, int L=1, int R=MAXN, int o=1) {
            // ... 返回节点深度
        }
    } seg;

    set<int> s;
    int fa[MAXN], ch[MAXN][2], root, n;

    int insert(int key) {
        s.insert(key);
        if(!root) {
            root = key;
            seg.update(key, key, 1); // 深度设为1
            return 1;
        }
        auto it = s.find(key);
        int pre = (it != s.begin()) ? *prev(it) : 0;
        int nxt = (next(it) != s.end()) ? *next(it) : 0;
        int d_pre = pre ? seg.query(pre) : 0;
        int d_nxt = nxt ? seg.query(nxt) : 0;

        if(d_pre > d_nxt) {
            fa[key] = pre;
            ch[pre][1] = key;
            seg.update(key, key, d_pre + 1);
        } else {
            fa[key] = nxt;
            ch[nxt][0] = key;
            seg.update(key, key, d_nxt + 1);
        }
        return seg.query(key);
    }

    int rotateMin() {
        int mn = *s.begin();
        int dep = seg.query(mn);
        if(root == mn) return 1;
        
        // 更新树形关系
        if(ch[mn][1]) fa[ch[mn][1]] = fa[mn];
        ch[fa[mn]][0] = ch[mn][1];
        seg.update(fa[mn], MAXN, 1); // 非子树节点深度+1
        seg.update(mn, mn, 1 - dep); // 自身深度重置为1

        // 重组父子关系
        fa[root] = mn;
        ch[mn][1] = root;
        root = mn;
        fa[root] = 0;
        return dep;
    }
    // 其他操作类似（省略）
    ```
* **代码解读概要**：
    - 线段树处理深度区间加减
    - set维护节点有序集合
    - fa/ch数组维护树形结构
    - 插入操作通过比较邻居深度确定位置
    - 旋转操作先更新子树关系，再批量修改深度

---
<code_intro_selected>
  各解法核心片段赏析：
</code_intro_selected>

**题解一：(老K)**
* **亮点**：离散化+权值线段树精准维护深度
* **核心代码片段**：
    ```cpp
    // 插入时深度确定
    if(hl < hr) { // hr为后继深度
        fa[x] = sr;
        son[sr][0] = x;
        root->_add(x, x, hr+1); // 深度更新
    }
    ```
* **代码解读**：`root->_add`是线段树的点更新操作，将新节点深度设为后继深度+1。前驱/后继通过set迭代器获得
* 💡 **学习笔记**：离散化键值缩小数据规模是常用优化手段

**题解二：(DOTime)**
* **亮点**：旋转后深度变化的区间处理
* **核心代码片段**：
    ```cpp
    void rotateMin() {
        // ... 获取最小值节点
        update(fa[min_val]+1, min_val-1, -1); // 子树深度不变
        update(1, n, 1); // 其他节点深度+1
    }
    ```
* **代码解读**：先对最小值所在子树区间减1抵消全局加1，实现子树深度不变
* 💡 **学习笔记**：区间加减的抵消思想是深度维护的核心

---

## 5. 算法可视化：像素动画演示

\<visualization_intro\>
  设计像素动画演示单旋最小值操作：
\</visualization_intro\>

  * **主题**：8-bit风格二叉树探险

  * **核心演示**：最小值节点（红色像素块）升至根过程

  * **设计思路**：复古FC界面降低理解门槛，音效强化关键操作

  * **动画流程**：
    1. **初始化**：像素网格展示二叉树，根节点高亮
    2. **插入节点**：新节点闪烁，比较前驱(黄)/后继(紫)深度后插入
    3. **单旋最小值**：
        - 最小值节点(红)闪烁+提示音
        - 右子树(蓝块)移动到原父节点(绿块)下方
        - 原根节点变为红色节点的右子树
        - 非红色子树节点颜色变深（深度+1）
        - 红色节点重置为白色（深度=1）
    4. **控制面板**：支持单步/自动播放，速度调节滑块
    5. **音效设计**：移动声("叮")，深度变化("嘟")，错误("咔")

  * **实现要点**：Canvas绘制网格节点，状态机管理动画流程

---

## 6. 拓展练习与相似问题

\<similar_problems_intro\>
  掌握后挑战相似问题：
\</similar_problems_intro\>

  * **练习推荐**：
    1.  **P2146 [NOI2015]软件包管理器**：树结构深度维护
    2.  **P3380 【模板】二逼平衡树**：前驱后继高级应用
    3.  **P2042 [NOI2005]维护数列**：综合数据结构模拟

---

## 7. 学习心得分享

\<insights_intro\>
  作者调试经验摘录：
\</insights_intro\>

> **参考经验 (老K)**："处理旋转操作时，未考虑子树深度不变性导致WA。通过打印线段树区间和，发现深度更新逻辑错误"
>
> **点评**：在树形结构变化时，建议画图验证深度变化假设，输出中间状态是调试利器

---

\<conclusion\>
  通过本题我们学到：复杂数据结构可通过组合基础结构（set+线段树）实现。重点掌握深度维护的区间处理技巧。下次算法之旅再见！💪
\</conclusion\>
```

---
处理用时：211.05秒
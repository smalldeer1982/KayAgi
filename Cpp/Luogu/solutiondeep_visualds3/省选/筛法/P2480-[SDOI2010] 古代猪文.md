# 题目信息

# [SDOI2010] 古代猪文

## 题目背景

“在那山的那边海的那边有一群小肥猪。他们活泼又聪明，他们调皮又灵敏。他们自由自在生活在那绿色的大草坪，他们善良勇敢相互都关心……”

——选自猪王国民歌


很久很久以前，在山的那边海的那边的某片风水宝地曾经存在过一个猪王国。猪王国地理位置偏僻，实施的是适应当时社会的自给自足的庄园经济，很少与外界联系，商贸活动就更少了。因此也很少有其他动物知道这样一个王国。

猪王国虽然不大，但是土地肥沃，屋舍俨然。如果一定要拿什么与之相比的话，那就只能是东晋陶渊明笔下的大家想象中的桃花源了。猪王勤政爱民，猪民安居乐业，邻里和睦相处，国家秩序井然，经济欣欣向荣，社会和谐稳定。和谐的社会带给猪民们对工作火红的热情和对未来的粉色的憧憬。

小猪iPig是猪王国的一个很普通的公民。小猪今年10岁了，在大肥猪学校上小学三年级。和大多数猪一样，他不是很聪明，因此经常遇到很多或者稀奇古怪或者旁人看来轻而易举的事情令他大伤脑筋。小猪后来参加了全猪信息学奥林匹克竞赛(Pig Olympiad in Informatics, POI)，取得了不错的名次，最终保送进入了猪王国大学(Pig Kingdom University, PKU)深造。

现在的小猪已经能用计算机解决简单的问题了，比如能用P++语言编写程序计算出A + B的值。这个“成就”已经成为了他津津乐道的话题。当然，不明真相的同学们也开始对他刮目相看啦~

小猪的故事就将从此展开，伴随大家两天时间，希望大家能够喜欢小猪。


## 题目描述

猪王国的文明源远流长，博大精深。

iPig 在大肥猪学校图书馆中查阅资料，得知远古时期猪文文字总个数为 $n$。当然，一种语言如果字数很多，字典也相应会很大。当时的猪王国国王考虑到如果修一本字典，规模有可能远远超过康熙字典，花费的猪力、物力将难以估量。故考虑再三没有进行这一项劳猪伤财之举。当然，猪王国的文字后来随着历史变迁逐渐进行了简化，去掉了一些不常用的字。

iPig 打算研究古时某个朝代的猪文文字。根据相关文献记载，那个朝代流传的猪文文字恰好为远古时期的 $1/k$，其中 $k$ 是 $n$ 的一个正约数（可以是 $1$ 或 $n$）。不过具体是哪 $1/k$，以及 $k$ 是多少，由于历史过于久远，已经无从考证了。

iPig 觉得只要符合文献，每一种 $k|n$ 都是有可能的。他打算考虑到所有可能的 $k$。显然当 $k$ 等于某个定值时，该朝的猪文文字个数为 $n/k$。然而从 $n$ 个文字中保留下 $n/k$ 个的情况也是相当多的。iPig 预计，如果所有可能的 $k$ 的所有情况数加起来为 $p$ 的话，那么他研究古代文字的代价将会是 $g^p$。

现在他想知道猪王国研究古代文字的代价是多少。由于 iPig 觉得这个数字可能是天文数字，所以你只需要告诉他答案除以 $999911659$ 的余数就可以了。


## 说明/提示

#### 数据规模与约定
- 对于 $10\%$ 的数据，$1\le n \le 50$；  
- 对于 $20\%$ 的数据，$1\le n \le 1000$；  
- 对于 $40\%$ 的数据，$1\le n \le 10^5$；  
- 对于 $100\%$ 的数据，$1\le n,g \le 10^9$。


## 样例 #1

### 输入

```
4 2```

### 输出

```
2048```

# AI分析结果



---

# 💡 Kay的C++算法解析：古代猪文 深入学习指南 💡

<introduction>
今天我们要挑战的题目是“古代猪文”，这是一道综合性很强的数论题目。它结合了费马小定理、组合数取模、Lucas定理和中国剩余定理（CRT）等多个知识点。通过这道题的学习，我们不仅能巩固这些数论基础，还能学会如何将复杂问题分解为可解决的小问题。让我们一起拆解它吧！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数论综合应用（涉及费马小定理、Lucas定理、中国剩余定理）

🗣️ **初步分析**：
题目要求计算 \( G^{\sum_{d|n} C_n^d} \mod 999911659 \)。直接计算指数部分（组合数之和）显然不可行，因为 \( n \) 可以达到 \( 10^9 \)。关键思路是利用数论中的几个核心定理：

1. **费马小定理**：由于 \( 999911659 \) 是质数，当 \( G \) 与它互质时，\( G^{k} \equiv G^{k \mod 999911658} \mod 999911659 \)（其中 \( 999911658 = 999911659-1 \)）。因此，我们只需计算指数部分 \( \sum_{d|n} C_n^d \mod 999911658 \)。

2. **模数分解**：\( 999911658 \) 可分解为 \( 2 \times 3 \times 4679 \times 35617 \)，这四个质数两两互质。我们可以分别计算 \( \sum_{d|n} C_n^d \) 对这四个质数取模的结果，再用 **中国剩余定理（CRT）** 合并得到最终模 \( 999911658 \) 的结果。

3. **Lucas定理**：由于 \( n \) 很大，直接计算组合数 \( C_n^d \) 不可行。但对于小质数 \( p \)（如 \( 2,3,4679,35617 \)），Lucas定理允许我们将大组合数分解为多个小组合数的乘积，从而高效计算 \( C_n^d \mod p \)。

**可视化设计思路**：  
我们将设计一个“数论探险”像素动画，模拟以下过程：
- **组合数计算**：用像素方块表示 \( n \) 和 \( d \)，通过递归拆解展示Lucas定理的步骤（如 \( n \) 和 \( d \) 按 \( p \) 进制拆分，计算每一位的组合数）。
- **模数分解**：将 \( 999911658 \) 分解为四个质数的动画，用不同颜色标记每个质数（如红-2，蓝-3，绿-4679，黄-35617）。
- **CRT合并**：用四个进度条分别展示每个质数的余数，最终合并成一个大进度条（模 \( 999911658 \) 的结果）。关键步骤伴随“叮”的音效，成功合并时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
经过对多个题解的评估（思路清晰度、代码规范性、算法有效性等），以下题解因逻辑清晰、代码规范且高效，值得重点学习：
</eval_intro>

**题解一：作者Owen_codeisking（赞：127）**  
* **点评**：此题解结构清晰，直接点明关键步骤（费马小定理、模数分解、Lucas+CRT），代码中预处理阶乘和逆元，高效计算组合数。特别是对边界条件的特判（如 \( G \) 是模数倍数时直接输出0），体现了严谨性。代码变量命名规范（如 `farc` 表示阶乘数组），逻辑简洁，适合直接参考。

**题解二：作者Notshgiook（赞：103）**  
* **点评**：此题解详细讲解了每个数论定理的应用背景（如欧拉定理、Lucas定理），并通过公式推导帮助理解。代码中使用 `qpow` 函数实现快速幂，`init` 函数预处理阶乘和逆元，逻辑分层明确。对约数的枚举处理（避免重复计算）也非常细致，适合理解算法全貌。

**题解三：作者TH讠NK（赞：2）**  
* **点评**：此题解以新手视角详细解释了每一步的思考过程（如为何分解模数、如何应用CRT），代码注释丰富，适合刚接触数论的学习者。特别是对Lucas定理的递归实现和CRT合并的代码，逻辑清晰，易于模仿。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的核心难点在于如何处理大组合数取模和多模数合并。以下是关键步骤的分析：
</difficulty_intro>

1.  **难点1：大组合数取模**  
    * **分析**：当 \( n \) 很大（如 \( 10^9 \)）时，直接计算 \( C_n^d \) 不可行。此时需用Lucas定理，将 \( n \) 和 \( d \) 按模数 \( p \) 进制拆分，递归计算每一位的组合数再相乘。例如，计算 \( C_{100}^{50} \mod 3 \)，可拆分为 \( C_{33}^{16} \times C_1^2 \mod 3 \)（因 \( 100 = 3 \times 33 + 1 \)，\( 50 = 3 \times 16 + 2 \)）。
    * 💡 **学习笔记**：Lucas定理适用于模数为质数的情况，将大问题拆解为小问题是关键。

2.  **难点2：多模数合并（CRT）**  
    * **分析**：我们需要将 \( \sum C_n^d \) 对 \( 2,3,4679,35617 \) 取模的结果合并为模 \( 999911658 \) 的结果。CRT通过构造同余方程组的解，利用每个模数的逆元合并结果。例如，已知 \( x \equiv a_1 \mod 2 \)，\( x \equiv a_2 \mod 3 \)，则 \( x = a_1 \times 3 \times 3^{-1} \mod 2 + a_2 \times 2 \times 2^{-1} \mod 3 \)，再取模 \( 6 \)（即 \( 2 \times 3 \)）。
    * 💡 **学习笔记**：CRT适用于模数两两互质的情况，合并时需计算每个模数的逆元。

3.  **难点3：约数枚举与去重**  
    * **分析**：枚举 \( n \) 的所有约数 \( d \) 时，需避免重复计算（如 \( d \) 和 \( n/d \) 可能相等）。例如，当 \( n=4 \) 时，约数 \( 2 \) 满足 \( 2 \times 2 = 4 \)，此时 \( d=2 \) 只需计算一次。
    * 💡 **学习笔记**：枚举约数时，用 \( i \times i \leq n \) 循环，当 \( i \) 是约数时，同时处理 \( i \) 和 \( n/i \)，并特判 \( i = n/i \) 的情况。

### ✨ 解题技巧总结
- **问题分解**：将大问题（计算大组合数和）拆解为多个小问题（对每个质数取模）。
- **预处理优化**：预处理阶乘和逆元数组，避免重复计算组合数。
- **边界特判**：当 \( G \) 是 \( 999911659 \) 的倍数时，直接输出0，避免无效计算。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合多个优质题解后的通用核心实现，结合了预处理、Lucas定理和CRT，逻辑清晰且高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Owen_codeisking和Notshgiook的题解思路，预处理阶乘和逆元，使用Lucas定理计算组合数，CRT合并结果，适合直接学习。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long LL;
    const int MOD = 999911659;
    const int MOD_PHI = 999911658; // 999911659-1
    const int primes[] = {2, 3, 4679, 35617}; // 分解后的质因数

    LL n, G;
    LL fact[4][40000]; // 各质数的阶乘数组
    LL inv_fact[4][40000]; // 各质数的阶乘逆元数组

    // 快速幂
    LL qpow(LL a, LL b, LL p) {
        LL res = 1;
        while (b) {
            if (b & 1) res = res * a % p;
            a = a * a % p;
            b >>= 1;
        }
        return res;
    }

    // 预处理阶乘和逆元
    void init(int idx) {
        int p = primes[idx];
        fact[idx][0] = 1;
        for (int i = 1; i < p; ++i)
            fact[idx][i] = fact[idx][i - 1] * i % p;
        inv_fact[idx][p - 1] = qpow(fact[idx][p - 1], p - 2, p);
        for (int i = p - 2; i >= 0; --i)
            inv_fact[idx][i] = inv_fact[idx][i + 1] * (i + 1) % p;
    }

    // 计算组合数 C(n, m) mod p
    LL comb(LL n, LL m, int idx) {
        int p = primes[idx];
        if (m > n) return 0;
        return fact[idx][n] * inv_fact[idx][m] % p * inv_fact[idx][n - m] % p;
    }

    // Lucas定理递归计算
    LL lucas(LL n, LL m, int idx) {
        int p = primes[idx];
        if (m == 0) return 1;
        return lucas(n / p, m / p, idx) * comb(n % p, m % p, idx) % p;
    }

    // 中国剩余定理合并结果
    LL crt(LL a[]) {
        LL res = 0;
        for (int i = 0; i < 4; ++i) {
            LL m = MOD_PHI / primes[i];
            LL inv_m = qpow(m, primes[i] - 2, primes[i]);
            res = (res + a[i] * m % MOD_PHI * inv_m) % MOD_PHI;
        }
        return res;
    }

    int main() {
        cin >> n >> G;
        if (G % MOD == 0) { // 特判G是模数的倍数
            cout << 0 << endl;
            return 0;
        }

        // 预处理各质数的阶乘和逆元
        for (int i = 0; i < 4; ++i) init(i);

        // 计算每个质数下的余数
        LL a[4] = {0};
        for (int i = 0; i < 4; ++i) {
            for (LL d = 1; d * d <= n; ++d) {
                if (n % d != 0) continue;
                a[i] = (a[i] + lucas(n, d, i)) % primes[i];
                if (d * d != n)
                    a[i] = (a[i] + lucas(n, n / d, i)) % primes[i];
            }
        }

        // CRT合并结果
        LL exponent = crt(a);
        cout << qpow(G, exponent, MOD) << endl;
        return 0;
    }
    ```
* **代码解读概要**：  
  代码首先预处理各质数的阶乘和逆元数组（`init`函数），然后用Lucas定理计算每个质数下的组合数和（`lucas`函数），最后通过CRT合并四个质数的余数得到最终指数（`crt`函数），再用快速幂计算结果。

---
<code_intro_selected>
接下来，我们分析优质题解中的核心代码片段，学习其亮点和实现细节：
</code_intro_selected>

**题解一：作者Owen_codeisking**  
* **亮点**：代码简洁，直接处理约数枚举，CRT合并逻辑清晰。
* **核心代码片段**：
    ```cpp
    void CRT() {
        for (LL i = 1; i <= 4; i++)
            val = (val + a[i] * (mod / b[i]) % mod * fast_pow(mod / b[i], b[i] - 2, b[i])) % mod;
    }
    ```
* **代码解读**：  
  这段代码实现了CRT的核心步骤。`mod`是 \( 999911658 \)，`b[i]`是分解后的质数。`mod / b[i]`是除当前质数外其他质数的乘积，`fast_pow`计算其逆元。最终将每个余数乘以对应项，累加得到合并结果。
* 💡 **学习笔记**：CRT的关键是计算每个模数的“权重”（即其他模数的乘积与逆元的乘积）。

**题解二：作者Notshgiook**  
* **亮点**：预处理阶乘和逆元的逻辑清晰，适合理解组合数计算。
* **核心代码片段**：
    ```cpp
    inline void init(ll p) {
        fac[0] = 1;
        for (register int i = 1; i < p; i++)
            fac[i] = fac[i - 1] * i % p;
        inv[p] = 0;
        inv[p - 1] = qpow(fac[p - 1], p - 2, p);
        for (register int i = p - 2; i >= 0; i--)
            inv[i] = inv[i + 1] * (i + 1) % p;
    }
    ```
* **代码解读**：  
  预处理阶乘数组`fac`和逆元数组`inv`。阶乘数组直接递推计算，逆元数组通过费马小定理（`qpow`）计算最大阶乘的逆元，再倒推其他逆元（因 \( (i!)^{-1} = (i+1)!^{-1} \times (i+1) \)）。
* 💡 **学习笔记**：预处理阶乘和逆元是快速计算组合数的关键，能将单次组合数计算时间降至 \( O(1) \)。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解Lucas定理和CRT的工作过程，我们设计了一款“数论探险”像素动画，让我们通过像素方块和动态演示来观察算法的每一步！
</visualization_intro>

  * **动画演示主题**：数论探险——组合数的奇幻之旅  
  * **核心演示内容**：  
    演示如何用Lucas定理计算大组合数模小质数，以及如何用CRT将四个质数的余数合并为最终结果。

  * **设计思路简述**：  
    采用8位像素风格（类似FC游戏），用不同颜色的方块表示不同质数（红-2，蓝-3，绿-4679，黄-35617）。关键步骤（如阶乘计算、逆元求解、CRT合并）用闪烁或移动动画强调，配合“叮”的音效增强记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        屏幕分为左右两部分，左半部分展示当前问题（如 \( G=2, n=4 \)），右半部分是四个“质数小屋”（对应 \( 2,3,4679,35617 \)）。顶部显示控制面板（单步/自动播放、速度调节）。

    2.  **约数枚举**：  
        用像素箭头逐个指向 \( n \) 的约数（如 \( n=4 \) 时，箭头指向 \( 1,2,4 \)），每个约数用金色方块表示，重复的约数（如 \( 2 \)）仅保留一个。

    3.  **Lucas定理计算**：  
        进入某个质数小屋（如 \( p=2 \)），展示 \( n \) 和 \( d \) 按 \( p \) 进制拆分的过程（如 \( n=4 \) 拆为 \( 10_2 \)，\( d=2 \) 拆为 \( 10_2 \)），递归计算每一位的组合数（\( C(1,1) \times C(0,0) \)），结果用绿色数字显示。

    4.  **CRT合并**：  
        四个小屋分别输出余数（如 \( a_1=0, a_2=1, a_3=2, a_4=3 \)），用四个进度条展示。点击“合并”按钮，进度条逐渐合并为一个大进度条（模 \( 999911658 \) 的结果），伴随“胜利”音效。

    5.  **最终计算**：  
        用快速幂计算 \( G \) 的指数次幂，像素方块从底部升起，显示最终结果（如 \( 2048 \)）。

  * **旁白提示**：  
    - “看！约数 \( d=2 \) 被找到，现在要计算 \( C_4^2 \mod 2 \)。”  
    - “Lucas定理将大组合数拆成小组合数，就像把大蛋糕切成小块一样！”  
    - “四个质数的余数合并啦，就像拼图一样，最终得到指数！”

<visualization_conclusion>
通过这样的动画，我们能直观看到数论定理如何一步步解决大问题。下次遇到类似题目，你也能像动画中的探险者一样，轻松拆解难题！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是数论中的组合数取模和多模数合并，这类方法在数论问题中非常通用。以下是一些拓展练习和相似问题：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - **大组合数取模**：当模数为质数时，Lucas定理是首选；若模数非质数但可分解为互质因子，可用CRT合并。  
    - **多模数问题**：将问题分解为互质模数的子问题，分别求解后合并（如求 \( x \equiv a \mod m \) 且 \( x \equiv b \mod n \)）。  

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3807 【模板】卢卡斯定理**  
        * 🗣️ **推荐理由**：直接练习Lucas定理的应用，巩固组合数取模的基础。
    2.  **洛谷 P4777 【模板】扩展中国剩余定理（EXCRT）**  
        * 🗣️ **推荐理由**：学习模数不互质时的CRT扩展，提升多模数问题的处理能力。
    3.  **洛谷 P2054 [AHOI2005] 洗牌**  
        * 🗣️ **推荐理由**：结合数论与模拟，锻炼综合应用能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自Owen_codeisking)**：“刚开始写的时候没特判 \( G \) 是模数倍数的情况，结果只有95分。后来加了特判就过了。”

> **点评**：特判是编程中容易忽略但非常重要的一步。本题中，当 \( G \) 是 \( 999911659 \) 的倍数时，结果直接为0，无需计算指数。这提醒我们在解题时要仔细分析边界条件，避免因小失大。

-----

<conclusion>
“古代猪文”是一道非常经典的数论综合题，通过它我们学习了费马小定理、Lucas定理和中国剩余定理的应用。希望这份指南能帮助你理解这些定理的联系，并在遇到类似问题时灵活运用。记住，数论的关键是分解问题和利用定理，多练习才能更熟练哦！下次见～ 💪
</conclusion>

---
处理用时：217.18秒
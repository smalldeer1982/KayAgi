# 题目信息

# [SDOI2016] 数字配对

## 题目描述

有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。

若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，

那么这两个数字可以配对，并获得 $c_i \times c_j$ 的价值。

一个数字只能参与一次配对，可以不参与配对。

在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。

## 说明/提示

测试点 $1 \sim 3$： $n \leq 10 $， $a_i \leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \leq 10 ^ 5$；   

测试点 $4 \sim 5$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5  $，$c_i = 0$；

测试点 $6 \sim 10$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5$ ，$ | c_i | \leq 10 ^ 5$。

## 样例 #1

### 输入

```
3
2 4 8
2 200 7
-1 -2 1
```

### 输出

```
4```

# AI分析结果



---
# 💡 Kay的C++算法解析：[SDOI2016] 数字配对 深入学习指南 💡

<introduction>
今天我们来一起分析“[SDOI2016] 数字配对”这道C++编程题。这道题结合了数论、图论和网络流的知识，需要我们巧妙地将问题转化为费用流模型。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`费用流（最大费用最大流变形）`

🗣️ **初步分析**：
解决这道题的关键在于将配对问题转化为网络流模型。简单来说，费用流算法通过“流量”表示配对次数，“费用”表示配对的总价值。本题需要在总价值不小于0的前提下，最大化流量（即配对次数）。

在本题中，配对条件是两个数满足倍数关系且商为质数。我们可以通过计算每个数的质因数指数和（记为`cnt`），发现能配对的数的`cnt`奇偶性必然不同（例如，若`a_i`的`cnt`为奇数，则`a_j`的`cnt`必为偶数）。这形成了二分图的结构：奇数`cnt`的点连向源点，偶数`cnt`的点连向汇点，配对边连接两个集合中的点。

核心算法流程：
1. 计算每个数的`cnt`（质因数指数和）。
2. 构建二分图：源点连奇数`cnt`的点（容量为`b_i`，费用0），偶数`cnt`的点连汇点（容量`b_i`，费用0）。
3. 配对边：能配对的点之间连边（容量无限，费用为`c_i*c_j`）。
4. 跑最大费用最大流，调整流量确保总费用≥0。

可视化设计思路：用8位像素风格展示节点（奇数`cnt`为红色，偶数为蓝色），边用动态箭头表示流量。关键步骤（如SPFA找最长路、流量更新）通过颜色闪烁和音效提示，费用变化实时显示在控制面板上。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：作者xyz32768 (赞：16)**
* **点评**：此题解思路清晰，详细解释了如何通过`cnt`的奇偶性构建二分图，并正确应用费用流模型。代码规范（如变量名`cnt`、`dis`含义明确），处理了质因数分解和SPFA最长路的关键步骤。亮点在于贪心调整流量的逻辑（当总费用将为负时，计算最大可增流量），确保了答案的正确性。

**题解二：作者louhao088 (赞：12)**
* **点评**：此题解采用二分+费用流的思路，通过二分流量上限验证是否可行。代码结构工整，关键部分（如`check`函数）注释清晰。亮点是将问题转化为二分判定，降低了直接处理费用的复杂度，适合理解不同解法的学习者。

**题解三：作者Orion545 (赞：9)**
* **点评**：此题解详细分析了配对条件的数论性质（`cnt`的奇偶性），并结合费用流的贪心策略。代码中质因数分解的优化（预筛质数）提升了效率，SPFA和DFS的实现逻辑清晰。亮点是对费用流增广过程的深入理解（最长路递减），确保了贪心调整的正确性。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下核心难点。结合优质题解的共性，我为大家提炼了思考方向和策略：
</difficulty_intro>

1.  **关键点1：如何构建正确的二分图模型？**
    * **分析**：需要计算每个数的`cnt`（质因数指数和），并根据奇偶性分为两部分。奇数`cnt`连源点，偶数连汇点。配对边仅存在于两集合之间。优质题解通过预计算`cnt`并遍历所有数对验证配对条件，确保图的正确性。
    * 💡 **学习笔记**：数论性质（如质因数分解）是构建图模型的关键，需仔细验证配对条件。

2.  **关键点2：如何处理“总费用≥0”的限制？**
    * **分析**：费用流的增广路费用是递减的。当某次增广的费用乘流量会使总费用<0时，需计算最大可增流量（`总费用 / 负的单流量费用`）并终止。优质题解通过贪心调整流量，确保总费用非负。
    * 💡 **学习笔记**：费用流的增广路单调性是解决此限制的核心，需理解其数学原理。

3.  **关键点3：如何高效实现质因数分解？**
    * **分析**：质因数分解需遍历到平方根，对剩余大于1的数单独处理。优质题解通过预筛小质数或直接遍历优化分解效率，避免超时。
    * 💡 **学习笔记**：质因数分解的效率影响整体性能，需注意优化（如预筛质数）。

### ✨ 解题技巧总结
- **问题抽象**：将配对问题转化为二分图费用流模型，利用数论性质简化条件。
- **贪心调整**：利用费用流增广路的单调性，在总费用将负时计算最大可增流量。
- **代码优化**：预筛质数加速质因数分解，使用邻接表存储图结构提升效率。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，重点实现了质因数分解、二分图构建和费用流的贪心调整。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <queue>
    #include <cstring>
    #include <algorithm>
    using namespace std;
    typedef long long ll;
    const int N = 210, M = 5e5 + 5;
    const ll INF = 1ll << 61;

    struct Edge {
        int to, next;
        ll cap, cost;
    } e[M];
    int head[N], cnt = 1;
    ll dis[N], sum_cost, max_flow;
    int pre[N], from[N];
    bool inq[N];
    int n, a[N], b[N], c[N], cnt_prime[N];
    int S, T;

    void add(int u, int v, ll cap, ll cost) {
        e[++cnt] = {v, head[u], cap, cost}; head[u] = cnt;
        e[++cnt] = {u, head[v], 0, -cost}; head[v] = cnt;
    }

    int count_prime(int x) {
        int res = 0;
        for (int i = 2; i * i <= x; ++i)
            while (x % i == 0) res++, x /= i;
        if (x > 1) res++;
        return res;
    }

    bool spfa() {
        memset(dis, -0x3f, sizeof(dis));
        memset(inq, 0, sizeof(inq));
        queue<int> q;
        q.push(S);
        dis[S] = 0;
        inq[S] = 1;
        while (!q.empty()) {
            int u = q.front(); q.pop(); inq[u] = 0;
            for (int i = head[u]; i; i = e[i].next) {
                int v = e[i].to;
                if (e[i].cap > 0 && dis[v] < dis[u] + e[i].cost) {
                    dis[v] = dis[u] + e[i].cost;
                    pre[v] = i;
                    from[v] = u;
                    if (!inq[v]) q.push(v), inq[v] = 1;
                }
            }
        }
        return dis[T] != -0x3f3f3f3f3f3f3f3f;
    }

    void mcmf() {
        max_flow = 0, sum_cost = 0;
        while (spfa()) {
            ll flow = INF;
            for (int v = T; v != S; v = from[v])
                flow = min(flow, e[pre[v]].cap);
            ll new_cost = sum_cost + flow * dis[T];
            if (new_cost < 0) {
                flow = sum_cost / (-dis[T]);
                max_flow += flow;
                sum_cost += flow * dis[T];
                break;
            }
            max_flow += flow;
            sum_cost = new_cost;
            for (int v = T; v != S; v = from[v]) {
                e[pre[v]].cap -= flow;
                e[pre[v] ^ 1].cap += flow;
            }
        }
    }

    int main() {
        cin >> n;
        S = 0, T = n + 1;
        for (int i = 1; i <= n; ++i) cin >> a[i];
        for (int i = 1; i <= n; ++i) cin >> b[i];
        for (int i = 1; i <= n; ++i) cin >> c[i];
        for (int i = 1; i <= n; ++i) cnt_prime[i] = count_prime(a[i]);
        for (int i = 1; i <= n; ++i) {
            if (cnt_prime[i] % 2) add(S, i, b[i], 0);
            else add(i, T, b[i], 0);
        }
        for (int i = 1; i <= n; ++i) {
            if (cnt_prime[i] % 2) {
                for (int j = 1; j <= n; ++j) {
                    if ((a[i] % a[j] == 0 && cnt_prime[i] == cnt_prime[j] + 1) ||
                        (a[j] % a[i] == 0 && cnt_prime[j] == cnt_prime[i] + 1)) {
                        add(i, j, INF, 1ll * c[i] * c[j]);
                    }
                }
            }
        }
        mcmf();
        cout << max_flow << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先计算每个数的`cnt_prime`（质因数指数和），构建二分图模型。源点连接奇数`cnt`的点，汇点连接偶数`cnt`的点。配对边容量无限，费用为`c_i*c_j`。通过SPFA找最长路，贪心调整流量确保总费用≥0。

---
<code_intro_selected>
接下来，我们将剖析优质题解中的核心代码片段：
</code_intro_selected>

**题解一：作者xyz32768**
* **亮点**：清晰的质因数分解和费用流贪心调整。
* **核心代码片段**：
    ```cpp
    bool spfa() {
        int i; for (i = S; i <= T; i++) vis[i] = 0, dis[i] = -INF;
        dis[que[len = 1] = S] = 0; for (i = 1; i <= len; i++) {
            int u = que[i]; vis[u] = 0;
            for (int e = adj[u], v; e; e = nxt[e])
                if (cap[e] && dis[u] + cost[e] > dis[v = go[e]]) {
                    dis[v] = dis[u] + cost[frm[v] = e];
                    if (!vis[v]) vis[que[++len] = v] = 1;
                }
        }
        return dis[T] > -INF;
    }
    ```
* **代码解读**：SPFA算法找最长路（最大费用路径）。初始化距离为负无穷，队列处理节点，更新邻接点的最大距离。`frm[v]`记录路径前驱边，用于后续流量调整。
* 💡 **学习笔记**：SPFA是费用流的核心步骤，需正确实现最长路查找，确保每次增广的是当前最优路径。

**题解二：作者louhao088（二分+费用流）**
* **亮点**：二分流量上限验证可行性。
* **核心代码片段**：
    ```cpp
    bool check(int g) {
        // 重置图，添加超级源汇边
        add(x, s, g, 0), add(t, y, g, 0);
        // 构建基础边
        for (int i = 1; i <= n; ++i)
            if (tot[i] % 2) add(s, i, b[i], 0);
            else add(i, t, b[i], 0);
        // 构建配对边
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j)
                if (a[i] % a[j] == 0 && tot[i] == tot[j] + 1)
                    add(i, j, INF, c[i] * c[j]);
        feiyong1(); // 计算费用
        return maxcost >= 0;
    }
    ```
* **代码解读**：`check`函数验证流量`g`是否可行。通过添加超级源汇边限制流量，构建图后计算最大费用，判断是否≥0。二分法找到最大可行流量。
* 💡 **学习笔记**：二分法将问题转化为判定性问题，降低了直接处理费用的复杂度，适用于需要优化的场景。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解费用流的执行过程，我们设计了一个“像素探险家”主题的8位风格动画，模拟SPFA找最长路和流量调整的过程。
</visualization_intro>

  * **动画演示主题**：`像素探险家的配对之旅`

  * **核心演示内容**：展示源点（黄色）、汇点（绿色）、奇数`cnt`节点（红色）、偶数`cnt`节点（蓝色）之间的流量流动。关键步骤包括SPFA找最长路、流量更新、费用计算。

  * **设计思路简述**：采用8位像素风格（类似FC游戏），通过颜色区分节点类型。关键操作（如入队、边更新）用像素闪烁和“叮”音效提示，费用变化实时显示在控制面板，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          - 屏幕展示网格，源点、汇点、节点用方块表示（颜色区分）。
          - 控制面板包含开始/暂停、单步、重置按钮，速度滑块。

    2.  **SPFA找最长路**：
          - 队列中的节点（红色方块）移动，遍历邻接边（箭头），更新距离（数字显示）。
          - 当前处理节点闪烁，找到更长路径时边颜色变亮（从灰到黄）。

    3.  **流量更新**：
          - 确定增广路后，流量（白色圆点）沿路径流动，边容量减少（数字变化），反向边容量增加。
          - 费用总和实时更新（绿色数字），若将为负则显示警告（红色闪烁）。

    4.  **贪心调整**：
          - 当总费用将负时，计算最大可增流量（数字弹出），流量圆点部分流动，费用停止在0。

  * **旁白提示**：
      - “当前节点是源点，开始寻找最长路径...”
      - “发现更长路径！这条边的费用是c_i*c_j，更新距离。”
      - “流量沿路径流动，总费用增加了...当前总费用为正，继续！”

<visualization_conclusion>
通过这样的动画，我们可以直观看到费用流的每一步操作，理解为什么贪心调整能保证总费用非负，以及如何通过SPFA找到最优路径。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考费用流的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      - 费用流模型适用于“流量”和“费用”双限制的问题（如运输问题、任务分配）。
      - 数论性质（如质因数分解）常用来构建图的结构（如二分图）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3381** - `【模板】最小费用最大流`
          * 🗣️ **推荐理由**：基础费用流模板题，巩固算法实现。
    2.  **洛谷 P4016** - `负载平衡问题`
          * 🗣️ **推荐理由**：结合运输问题，练习费用流建模。
    3.  **洛谷 P4557** - `[JSOI2018] 防御网络`
          * 🗣️ **推荐理由**：较复杂的费用流应用，提升建模能力。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到调试时遇到的问题，例如质因数分解错误（如遗漏大质数）或费用流实现中的边界条件（如流量为0时的处理）。这些经验对我们很有帮助：
</insights_intro>

> **参考经验 (来自xyz32768)**：“在质因数分解时，若剩余数大于1，需额外加1（如12=2^2*3^1，指数和为3）。一开始忘记处理这种情况，导致`cnt`计算错误，配对边构建失败。”

**点评**：质因数分解的细节容易出错，尤其是剩余数大于1的情况。调试时可打印`cnt`值验证，确保图模型正确。这提醒我们在实现数论函数时要仔细处理边界条件。

-----

<conclusion>
本次关于“[SDOI2016] 数字配对”的C++解题分析就到这里。希望这份学习指南能帮助大家理解费用流的应用和数论建模的技巧。记住，编程能力的提升在于持续学习和实践，下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：183.96秒
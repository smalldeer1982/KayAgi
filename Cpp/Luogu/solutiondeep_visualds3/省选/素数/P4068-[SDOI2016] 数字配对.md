# 题目信息

# [SDOI2016] 数字配对

## 题目描述

有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。

若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，

那么这两个数字可以配对，并获得 $c_i \times c_j$ 的价值。

一个数字只能参与一次配对，可以不参与配对。

在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。

## 说明/提示

测试点 $1 \sim 3$： $n \leq 10 $， $a_i \leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \leq 10 ^ 5$；   

测试点 $4 \sim 5$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5  $，$c_i = 0$；

测试点 $6 \sim 10$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5$ ，$ | c_i | \leq 10 ^ 5$。

## 样例 #1

### 输入

```
3
2 4 8
2 200 7
-1 -2 1
```

### 输出

```
4```

# AI分析结果



---

# 💡 Kay的C++算法解析：数字配对 深入学习指南 💡

<introduction>
今天我们来一起分析“数字配对”这道C++编程题。这道题结合了数论和网络流的核心思想，需要我们通过巧妙的建模将问题转化为最大费用最大流问题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（费用流）`

🗣️ **初步分析**：
解决“数字配对”这道题，关键在于将问题转化为网络流模型，特别是最大费用最大流问题。简单来说，费用流算法通过在网络中寻找增广路径（即流量的可行路径），并在路径上调整流量，同时记录费用变化，最终找到满足条件的最大流量。在本题中，我们需要确保总费用（即配对价值总和）不小于0的前提下，最大化配对次数。

- **题解思路**：所有题解的核心思路是构建二分图模型：将数字按质因数个数的奇偶性分为两部分（奇数为左部，偶数为右部），源点连左部点（容量为该数字的数量b_i，费用0），右部点连汇点（容量b_i，费用0），可配对的点之间连边（容量无穷大，费用为c_i×c_j）。通过最大费用最大流算法求解，每次增广时检查总费用是否非负，若负则停止。
- **核心难点**：如何将配对条件转化为二分图模型（质因数个数奇偶性的利用）；费用流中如何处理“总费用非负”的限制（贪心增广策略）。
- **可视化设计思路**：采用8位像素风格，用不同颜色区分左右部点（左部红，右部蓝），边的费用用动态数字显示，增广路径用黄色高亮。每完成一次增广，播放“叮”的音效；费用变为负时播放“滴”的提示音。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码规范性、算法有效性等方面筛选了以下优质题解（评分≥4星）。
</eval_intro>

**题解一：作者xyz32768（赞16）**
* **点评**：此题解思路清晰，完整实现了费用流模型。代码结构规范（如使用`read`函数快速输入，`sigma`函数分解质因数），变量命名直观（如`cnt`记录质因数个数）。亮点在于正确处理了二分图构建（奇偶分点）和贪心增广策略（通过`spfa`找最长路，`add`函数调整流量并检查费用）。实践价值高，适合直接参考。

**题解二：作者Orion545（赞9）**
* **点评**：此题解详细解释了二分图建模的原理（质因数个数奇偶性），并强调了贪心策略的正确性（每次增广的最长路费用递减）。代码中`init`函数线筛质数优化质因数分解，`spfa`实现最长路搜索，逻辑严谨。适合理解费用流与数论的结合。

**题解三：作者UperFicial（赞2）**
* **点评**：此题解注释详细，适合新手学习。代码中`fenjie`函数分解质因数，`SPFA`和`MCMF`函数实现费用流，关键步骤（如边的添加）注释清晰。亮点是对“总费用非负”条件的处理（`if (Cost+now < 0)`的判断），实践参考价值高。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下一些关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何将配对条件转化为二分图模型？
    * **分析**：配对条件要求$a_i$是$a_j$的倍数且商为质数，这等价于$a_i$的质因数个数比$a_j$多1。因此，质因数个数的奇偶性必然不同，可将数字分为奇偶两部分（左部奇，右部偶），形成二分图。优质题解通过`sigma`或`fenjie`函数计算质因数个数，实现奇偶分点。
    * 💡 **学习笔记**：质因数个数的奇偶性是构建二分图的关键，这一步将复杂的配对条件转化为图的边关系。

2.  **关键点2**：如何处理“总费用非负”的限制？
    * **分析**：费用流的增广路径费用是递减的（每次找到的最长路费用更小）。因此，当某次增广的费用乘流量会导致总费用变负时，需计算能增广的最大流量（`sum / (-dis[T])`），并停止。优质题解通过`add`或`MCMF`函数实现这一贪心策略。
    * 💡 **学习笔记**：贪心增广是解决费用限制的核心，利用了费用流增广路径的单调性。

3.  **关键点3**：如何高效分解质因数？
    * **分析**：质因数分解是奇偶分点的基础。优质题解采用试除法（如`sigma`函数）或线筛优化（如`init`函数），确保分解效率。例如，试除法对每个数分解到$\sqrt{n}$，剩余部分若大于1则为质数。
    * 💡 **学习笔记**：质因数分解的效率直接影响整体算法的时间复杂度，试除法在本题数据范围（$a_i≤1e9$）下已足够。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题抽象**：将配对条件转化为图论模型（二分图+费用流），是解决此类匹配问题的通用思路。
- **边界处理**：质因数分解时，注意处理剩余大于1的数（可能为质数），避免漏算。
- **费用流调试**：通过打印中间变量（如`dis[T]`、`sum`），验证增广路径的费用变化是否符合预期。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了xyz32768和Orion545的题解思路，优化了质因数分解和费用流实现，适合作为学习参考。
* **完整核心代码**：
    ```cpp
    #include <cmath>
    #include <cstdio>
    #include <cstring>
    #include <iostream>
    #include <algorithm>
    using namespace std;
    typedef long long ll;
    const int N = 210, M = 5e5 + 5;
    const ll INF = 1ll << 61;

    int n, a[N], b[N], c[N], cnt[N], ecnt = 1, nxt[M], adj[N], st[M], go[M], frm[M], S, T, len, que[M];
    ll cap[M], cost[M], dis[N], sum, ans;
    bool vis[N];

    inline int read() {
        int res = 0; bool bo = 0; char c;
        while (((c = getchar()) < '0' || c > '9') && c != '-');
        if (c == '-') bo = 1; else res = c - 48;
        while ((c = getchar()) >= '0' && c <= '9')
            res = (res << 3) + (res << 1) + (c - 48);
        return bo ? ~res + 1 : res;
    }

    void add_edge(int u, int v, ll w, ll x) {
        nxt[++ecnt] = adj[u]; adj[u] = ecnt; st[ecnt] = u;
        go[ecnt] = v; cap[ecnt] = w; cost[ecnt] = x;
        nxt[++ecnt] = adj[v]; adj[v] = ecnt; st[ecnt] = v;
        go[ecnt] = u; cap[ecnt] = 0; cost[ecnt] = -x;
    }

    int sigma(int n) { // 分解质因数，计算质因数个数
        int i, S = sqrt(n), tot = 0;
        for (i = 2; i <= S; i++)
            while (n % i == 0) n /= i, tot++;
        if (n > 1) tot++;
        return tot;
    }

    bool spfa() { // 最长路SPFA
        int i; for (i = S; i <= T; i++) vis[i] = 0, dis[i] = -INF;
        dis[que[len = 1] = S] = 0;
        for (i = 1; i <= len; i++) {
            int u = que[i]; vis[u] = 0;
            for (int e = adj[u], v; e; e = nxt[e])
                if (cap[e] && dis[u] + cost[e] > dis[v = go[e]]) {
                    dis[v] = dis[u] + cost[frm[v] = e];
                    if (!vis[v]) vis[que[++len] = v] = 1;
                }
        }
        return dis[T] > -INF;
    }

    bool add() { // 增广并检查费用
        ll fl = INF, delta;
        for (int e = frm[T]; e; e = frm[st[e]]) fl = min(fl, cap[e]);
        delta = dis[T] * fl;
        if (sum + delta >= 0) {
            sum += delta; ans += fl;
            for (int e = frm[T]; e; e = frm[st[e]]) cap[e] -= fl, cap[e ^ 1] += fl;
            return 1;
        } else return ans += sum / (-dis[T]), 0;
    }

    ll solve() { // 主求解函数
        while (spfa() && add());
        return ans;
    }

    int main() {
        int i, j; n = read();
        for (i = 1; i <= n; i++) a[i] = read();
        for (i = 1; i <= n; i++) b[i] = read();
        for (i = 1; i <= n; i++) c[i] = read();
        S = 0; T = n + 1;
        for (i = 1; i <= n; i++) cnt[i] = sigma(a[i]);
        for (i = 1; i <= n; i++) { // 奇偶分点，连源汇边
            if (cnt[i] & 1) add_edge(S, i, b[i], 0);
            else add_edge(i, T, b[i], 0);
        }
        for (i = 1; i <= n; i++) if (cnt[i] & 1) { // 连可配对边
            for (j = 1; j <= n; j++) {
                if ((cnt[i] + 1 == cnt[j] && a[j] % a[i] == 0) || (cnt[j] + 1 == cnt[i] && a[i] % a[j] == 0)) {
                    add_edge(i, j, INF, 1ll * c[i] * c[j]);
                }
            }
        }
        cout << solve() << endl;
        return 0;
    }
    ```
* **代码解读概要**：该代码首先读取输入，计算每个数的质因数个数（`sigma`函数），然后构建二分图（奇偶分点，连源汇边），接着连接可配对点的边（容量INF，费用c_i×c_j）。通过`spfa`找最长路，`add`函数增广并检查总费用，最终输出最大配对次数。

---

<code_intro_selected>
接下来，我们将逐一剖析筛选出的优质题解中，最能体现核心逻辑的C++实现片段，并点出各自的亮点和关键代码思路。
</code_intro_selected>

**题解一：作者xyz32768**
* **亮点**：代码结构清晰，`spfa`实现最长路搜索，`add`函数处理费用检查，正确实现贪心增广。
* **核心代码片段**：
    ```cpp
    bool add() {
        ll fl = INF, delta;
        for (int e = frm[T]; e; e = frm[st[e]]) fl = min(fl, cap[e]);
        delta = dis[T] * fl;
        if (sum + delta >= 0) {
            sum += delta; ans += fl;
            for (int e = frm[T]; e; e = frm[st[e]]) cap[e] -= fl, cap[e ^ 1] += fl;
            return 1;
        } else return ans += sum / (-dis[T]), 0;
    }
    ```
* **代码解读**：这段代码计算当前增广路径的最大流量`fl`，并判断总费用是否非负。若满足，更新总费用和流量；否则，计算能增广的最大流量（`sum / (-dis[T])`）并退出。`cap[e]`和`cap[e^1]`调整正反边的容量，确保流量正确。
* 💡 **学习笔记**：贪心增广的关键是利用费用流的单调性，每次增广后费用递减，因此只需判断当前增广是否会导致总费用变负。

**题解二：作者Orion545**
* **亮点**：线筛优化质因数分解（`init`函数），`spfa`实现最长路搜索，注释详细。
* **核心代码片段**：
    ```cpp
    void init() { // 线筛质数
        v[1] = 1;
        for (int i = 2; i <= 100000; i++) {
            if (!v[i]) pri[++tot] = i;
            for (int j = 1; j <= tot; j++) {
                int k = i * pri[j]; if (k > 100000) break;
                v[k] = 1;
                if (i % pri[j] == 0) break;
            }
        }
    }
    ```
* **代码解读**：`init`函数通过埃氏筛法预处理质数表，用于后续质因数分解。线筛能快速得到所有≤1e5的质数，提高分解效率。
* 💡 **学习笔记**：预处理质数表是优化质因数分解的常用方法，适用于多次分解的场景。

**题解三：作者UperFicial**
* **亮点**：注释详细，`SPFA`和`MCMF`函数逻辑清晰，适合新手学习。
* **核心代码片段**：
    ```cpp
    bool MCMF() {
        if (!SPFA()) return false;
        ll now = dis[t] * flow[t];
        if (Cost + now >= 0) {
            Cost += now;
            Flow += flow[t];
            for (int u = t; u != s; u = pre[u]) {
                int p = pos[u];
                edge[p].flow -= flow[t];
                edge[p ^ 1].flow += flow[t];
            }
            return true;
        } else return Flow += Cost / (-dis[t]), false;
    }
    ```
* **代码解读**：`MCMF`函数调用`SPFA`找最长路，计算当前增广的费用`now`。若总费用非负，更新费用和流量；否则，计算最大可增广流量并退出。
* 💡 **学习笔记**：费用流的核心是增广路径的选择和费用的累积，需仔细处理正反边的容量调整。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解费用流的增广过程和二分图模型，我设计了一个8位像素风格的动画演示方案。
</visualization_intro>

  * **动画演示主题**：`像素数字配对大冒险`

  * **核心演示内容**：展示二分图构建（奇偶分点）、边的连接（可配对点）、增广路径的寻找（SPFA最长路）及费用变化，最终在总费用非负时停止。

  * **设计思路简述**：采用FC红白机风格的像素画面（8色调色板），用红色方块表示左部点（奇质因数个数），蓝色方块表示右部点（偶质因数个数）。边用绿色线条表示，费用用动态数字显示。增广路径用黄色闪烁高亮，音效提示关键操作（如增广成功“叮”，费用变负“滴”）。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示源点（金色方块），右侧显示汇点（银色方块）。
        - 左部点（红）和右部点（蓝）按质因数个数奇偶性排列，源点连左部点（绿色边，容量b_i），右部点连汇点（绿色边，容量b_i）。
        - 控制面板：单步/自动播放按钮、速度滑块、费用显示框。

    2.  **增广路径搜索（SPFA）**：
        - 用紫色箭头从源点出发，遍历左部点，寻找费用最大的路径。
        - 访问的点用白色边框高亮，边的费用动态更新（如“+100”表示费用增加100）。

    3.  **流量调整（增广）**：
        - 找到最长路后，黄色箭头沿路径移动，边的容量减少（如从“5”变为“3”），反向边容量增加。
        - 费用显示框更新总费用（如从“200”变为“300”），播放“叮”音效。

    4.  **费用检查**：
        - 若总费用将变负（如当前总费用50，增广费用-30，流量2），计算最大可增广流量（50/30=1），播放“滴”音效，动画停止。

  * **旁白提示**：
    - “注意看，红色点是奇质因数个数的数字，蓝色是偶质因数个数的~”
    - “紫色箭头在找费用最大的路径，这是SPFA算法哦！”
    - “黄色箭头在调整流量，边的容量在变化，总费用增加啦！”

<visualization_conclusion>
通过这样的像素动画，我们可以直观看到二分图的构建、增广路径的寻找和费用的变化，轻松理解费用流的核心逻辑。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考费用流的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 费用流模型适用于带权匹配问题（如任务分配、资源调度），关键是将问题转化为图的边权和容量。
    - 奇偶分点的思想可用于其他需要二分图建模的问题（如棋盘覆盖、最大匹配）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4016 负载平衡问题**：考察网络流建模，将问题转化为最小费用流，适合巩固流量分配技巧。
    2.  **洛谷 P3381 最小费用最大流**：标准费用流模板题，适合练习SPFA和增广实现。
    3.  **洛谷 P2756 飞行员配对方案问题**：二分图最大匹配问题，可尝试用费用流求解，对比不同算法差异。

---

## 7\. 学习心得与经验分享 

<insights_intro>
部分题解作者分享了调试经验，这些对我们很有参考价值：
</insights_intro>

> **参考经验 (来自Orion545)**：“我被`dis[T]>=0`的条件坑了1小时，写成了`>`，导致少算一次增广。”
>
> **点评**：边界条件的处理（如等于0的情况）非常重要。调试时可打印关键变量（如`dis[T]`），确保逻辑正确。

> **参考经验 (来自UperFicial)**：“开`long long`很重要！否则会溢出。”
>
> **点评**：本题中c_i的乘积可能很大（1e5×1e5=1e10），需用`long long`避免溢出。

---

<conclusion>
本次关于“数字配对”的C++解题分析就到这里。希望这份学习指南能帮助大家理解费用流的建模和贪心策略的应用。记住，多动手调试、理解每一步的数学意义，是掌握算法的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：183.20秒
# 题目信息

# [POI 2020/2021 R3] 素数和 / Suma liczb pierwszych

## 题目背景

译自 [XXVIII Olimpiada Informatyczna - III etap](https://sio2.mimuw.edu.pl/c/oi28-3/dashboard/) [Suma liczb pierwszych](https://szkopul.edu.pl/problemset/problem/8brtPux-IyytS6rOoOR1cJTL/statement/)。

d2t3。

## 题目描述

给你一个数字 $n$，求 $l,r$，使 $[l,r]$ 区间内的所有质数之和等于 $n$。

如果有多解，任意一组均可；无解输出 `NIE`。

## 说明/提示

对于所有数据，$1\leq n\leq 10^{11}$。

| 子任务编号 | 附加限制 | 分数 |
| :----------: | :----------: | :----------: |
| 1 | $n\leq 10000$ | 15 |
| 2 | $n\leq 10^8$ | 20 |
| 3 | $n\leq 2\times 10^9$ | 40 |
| 4 |  | 25 |

## 样例 #1

### 输入

```
15
```

### 输出

```
3 7
```

## 样例 #2

### 输入

```
9992
```

### 输出

```
4993 4999
```

## 样例 #3

### 输入

```
100000000
```

### 输出

```
NIE
```

## 样例 #4

### 输入

```
1000000007
```

### 输出

```
1000000007 1000000007
```

## 样例 #5

### 输入

```
99999999996
```

### 输出

```
295693 1693067
```

# AI分析结果

---
# 💡 Kay的C++算法解析：素数和 深入学习指南 💡

<introduction>
今天我们来一起分析“素数和”这道C++编程题。题目要求找到一个质数区间[l, r]，使得区间内所有质数之和等于给定的n。本指南将帮助大家梳理解题思路，理解核心算法，并掌握处理大范围质数问题的技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学与筛法应用` (结合质数筛法、双指针枚举与区间和计算)

🗣️ **初步分析**：
解决“素数和”问题的关键在于高效处理大范围的质数筛选与区间和计算。质数筛法（如埃拉托斯特尼筛法）是基础，它能快速预处理小范围内的质数；双指针法用于在预处理的质数列表中查找连续质数和为n的区间。当n极大（如1e11）时，直接预处理所有质数不可行，此时需结合质数分布的数学规律（如质数密度约为\(1/\ln n\)），通过枚举可能的质数个数t，在\(n/t\)附近的小范围内用“区间筛法”筛选质数，再用双指针验证。

- **题解思路对比**：三个题解均采用“小范围预处理+大范围枚举”的分治策略。World_Creater和robinyqc的题解更注重筛法优化（如区间筛法、bitset压缩），而novax的题解引入了miller-rabin素性测试，但实现复杂度较高。
- **核心算法流程**：预处理小范围质数（如2e7或1e8），用双指针检查是否存在连续和为n的区间；若无解，枚举质数个数t（\(t \leq n/\text{小范围阈值}\)），在\(n/t\)附近用区间筛法筛选质数，再用双指针验证。
- **可视化设计**：采用8位像素风格，用不同颜色的像素块表示质数（绿色）、合数（灰色），双指针移动时用黄色箭头标记当前区间，区间筛法过程中用红色覆盖标记合数，关键步骤（如找到解）伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过对题解的思路清晰度、代码规范性、算法有效性等维度评估，以下题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：World_Creater（赞：9）**
* **点评**：此题解思路分阶段处理，小范围预处理（筛2e7内的质数）用双指针快速检查，大范围枚举质数个数t，结合区间筛法缩小检查范围。代码中pre数组存储质数前缀和，prp数组存储质数列表，变量命名直观；区间筛法部分通过bitset优化，减少内存占用。亮点在于利用质数密度理论将大范围问题转化为小范围枚举，时间复杂度控制得当（\(O(n^{2/3}\log n)\)），实践价值高（可直接用于竞赛）。

**题解二：robinyqc（赞：3）**
* **点评**：此题解结构简洁，设置阈值B（如1e8）预处理小范围质数，用双指针检查；大范围枚举质数个数x（\(x \leq n/B\)），在\(n/x\)附近用区间筛法筛选质数。代码中使用bitset<N>标记合数，空间效率高；solve函数封装筛法与双指针逻辑，模块化设计增强可读性。亮点是复杂度分析明确，通过调整B平衡预处理与枚举的时间，适合学习分治策略的应用。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理大范围质数的高效筛选与区间和计算。以下是核心难点及应对策略：
</difficulty_intro>

1.  **关键点1：小范围质数的预处理与双指针应用**
    * **分析**：小范围（如≤2e7）的质数可通过埃氏筛预处理，存储前缀和数组pre。双指针法遍历pre数组，固定右端点i，左端点l右移至pre[i]-pre[l-1]≤n，若等于n则找到解。此步骤需注意质数列表的连续性（prp数组按顺序存储质数）。
    * 💡 **学习笔记**：预处理小范围质数是处理大数问题的常见技巧，双指针法能线性时间内完成区间和查找。

2.  **关键点2：大范围质数的快速筛选（区间筛法）**
    * **分析**：当n极大时，质数分布稀疏，直接筛所有质数不可行。区间筛法通过枚举√r内的质数p，标记[l, r]内p的倍数（非质数），剩余未标记的即为质数。此步骤需注意筛法边界（如j从max(p², l)开始）。
    * 💡 **学习笔记**：区间筛法将大范围质数筛选转化为小范围操作，时间复杂度为\(O((r-l)\ln\ln r)\)，适合处理1e11级别的问题。

3.  **关键点3：质数个数的枚举策略**
    * **分析**：枚举质数个数t时，根据质数密度，t个质数的平均值约为n/t，因此只需检查[n/t - t·ln n, n/t + t·ln n]范围内的质数。此范围较小（约t·ln n个数），可用区间筛法快速筛选。
    * 💡 **学习笔记**：利用质数分布的数学规律（如密度\(1/\ln n\)）缩小枚举范围，是解决大数问题的核心思想。

### ✨ 解题技巧总结
- **分治策略**：将问题分为小范围预处理和大范围枚举，平衡时间与空间复杂度。
- **筛法优化**：使用bitset压缩标记数组，减少内存占用（如题解中用bitset<100008>标记区间质数）。
- **双指针法**：线性时间内查找连续子数组和为目标值，适用于有序数组（如质数列表）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解思路的通用核心实现，结合了小范围预处理、双指针检查和大范围区间筛法，代码简洁高效。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了World_Creater和robinyqc的思路，预处理小范围质数（≤2e7），用双指针检查；若无解，枚举质数个数t，在n/t附近用区间筛法筛选质数并验证。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using LL = long long;

    const int MAX_PRE = 2e7; // 小范围预处理上限
    vector<int> primes;      // 存储预处理的质数
    vector<LL> pre_sum;      // 质数前缀和

    // 埃氏筛预处理小范围质数
    void sieve() {
        vector<bool> is_prime(MAX_PRE + 1, true);
        is_prime[0] = is_prime[1] = false;
        for (int i = 2; i <= MAX_PRE; ++i) {
            if (is_prime[i]) {
                primes.push_back(i);
                for (int j = 2 * i; j <= MAX_PRE; j += i)
                    is_prime[j] = false;
            }
        }
        pre_sum.resize(primes.size() + 1);
        for (int i = 0; i < primes.size(); ++i)
            pre_sum[i + 1] = pre_sum[i] + primes[i];
    }

    // 区间筛法：筛选[l, r]内的质数，存入primes_in_range
    void interval_sieve(LL l, LL r, vector<LL>& primes_in_range) {
        vector<bool> is_prime(r - l + 1, true);
        for (int p : primes) {
            if (p * p > r) break;
            LL start = max((LL)p * p, (l + p - 1) / p * p);
            for (LL j = start; j <= r; j += p)
                is_prime[j - l] = false;
        }
        if (l == 1) is_prime[0] = false; // 1不是质数
        for (LL i = l; i <= r; ++i)
            if (is_prime[i - l])
                primes_in_range.push_back(i);
    }

    // 双指针检查是否存在连续质数和为n
    bool check_sum(const vector<LL>& nums, LL n, LL& l, LL& r) {
        int left = 0;
        LL current_sum = 0;
        for (int right = 0; right < nums.size(); ++right) {
            current_sum += nums[right];
            while (current_sum > n && left <= right) {
                current_sum -= nums[left];
                left++;
            }
            if (current_sum == n) {
                l = nums[left];
                r = nums[right];
                return true;
            }
        }
        return false;
    }

    int main() {
        LL n;
        cin >> n;
        sieve();

        // 检查小范围预处理的质数
        LL l = -1, r = -1;
        int left = 0;
        for (int right = 0; right < primes.size(); ++right) {
            while (pre_sum[right + 1] - pre_sum[left] > n) left++;
            if (pre_sum[right + 1] - pre_sum[left] == n) {
                l = primes[left];
                r = primes[right];
                break;
            }
        }
        if (l != -1) {
            cout << l << " " << r << endl;
            return 0;
        }

        // 检查n自身是否为质数（单元素区间）
        if (n > 1) {
            bool is_single_prime = true;
            for (int p : primes) {
                if (p * p > n) break;
                if (n % p == 0) {
                    is_single_prime = false;
                    break;
                }
            }
            if (is_single_prime) {
                cout << n << " " << n << endl;
                return 0;
            }
        }

        // 大范围枚举质数个数t
        for (int t = 2; t <= 5000; ++t) { // 枚举t的上限可调整
            LL mid = n / t;
            LL L = max(2LL, mid - t * 20); // 范围缩小为t*20
            LL R = mid + t * 20;
            vector<LL> primes_in_range;
            interval_sieve(L, R, primes_in_range);
            if (check_sum(primes_in_range, n, l, r)) {
                cout << l << " " << r << endl;
                return 0;
            }
        }

        cout << "NIE" << endl;
        return 0;
    }
    ```
* **代码解读概要**：代码首先预处理2e7内的质数及其前缀和，用双指针检查是否存在连续和为n的区间；若无解，检查n自身是否为质数；最后枚举质数个数t，在n/t附近用区间筛法筛选质数，再用双指针验证。核心逻辑包括埃氏筛、区间筛法和双指针法的结合。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，学习其亮点与实现思路。
</code_intro_selected>

**题解一：World_Creater**
* **亮点**：区间筛法使用bitset优化，减少内存占用；枚举质数个数t时，动态调整筛法范围（如t≤5时扩大范围），提高覆盖率。
* **核心代码片段**：
    ```cpp
    void solve(int l, int r) { // 区间筛法标记合数
        chk.reset();
        for (int i = 1; i <= cnt && prp[i] * prp[i] <= r; ++i) {
            for (int j = (l + prp[i] - 1) / prp[i]; j * prp[i] <= r; ++j)
                chk[prp[i] * j - l] = 1;
        }
    }
    ```
* **代码解读**：
    - `solve(l, r)`函数用于标记区间[l, r]内的合数。`chk`是bitset，每一位对应区间内的一个数（如chk[0]对应l）。
    - 枚举预处理好的质数prp[i]（≤√r），计算其在[l, r]内的倍数j*prp[i]，将chk[j*prp[i]-l]设为1（标记为合数）。
    - 此方法通过预处理小质数，快速标记大区间内的合数，时间复杂度为\(O((r-l)\ln\ln r)\)。
* 💡 **学习笔记**：区间筛法是处理大范围质数问题的关键，利用小质数标记大区间内的合数，避免了直接筛所有数。

**题解二：robinyqc**
* **亮点**：使用模板函数solve封装筛法与双指针逻辑，提高代码复用性；bitset<N>标记合数，空间效率高。
* **核心代码片段**：
    ```cpp
    template<bool type, int len>
    void solve(LL l, LL r, bitset<len>& b) { // 筛法+双指针检查
        if (type) { // 区间筛法标记合数
            b.reset();
            for (LL i : p) {
                if (i * i > r) break;
                for (LL j = (l + i - 1) / i * i; j <= r; j += i)
                    b.set(j - l);
            }
        }
        LL sum = 0, pl = l;
        for (LL i = l; i <= r; ++i) { // 双指针检查和为n
            if (!b[i - l]) {
                sum += i;
                while (sum > n) {
                    if (!b[pl - l]) sum -= pl;
                    ++pl;
                }
                if (sum == n) {
                    cout << max(pl, 1ll) << ' ' << i << '\n';
                    exit(0);
                }
            }
        }
    }
    ```
* **代码解读**：
    - `solve<type, len>`模板函数根据type参数选择是否执行区间筛法（type为true时筛[l, r]内的合数）。
    - 双指针部分维护当前区间和sum，左指针pl右移直到sum≤n，若sum等于n则输出结果。
    - 模板设计使函数可处理不同长度的bitset（如小范围用bitset<N+8>，大范围用bitset<100008>）。
* 💡 **学习笔记**：模板函数和bitset的结合能灵活处理不同范围的筛法，提高代码复用性和空间效率。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解质数筛选与双指针查找的过程，我们设计一个“像素质数探险家”动画，以8位复古风格展示算法关键步骤。
</visualization_intro>

  * **动画演示主题**：`像素质数探险家：寻找和为n的质数区间`

  * **核心演示内容**：展示小范围质数预处理（埃氏筛）、双指针查找区间和，以及大范围区间筛法与双指针验证的过程。

  * **设计思路简述**：8位像素风格（如FC游戏画面）营造轻松氛围；用不同颜色标记质数（绿色）、合数（灰色）、当前处理的质数（黄色）；双指针移动时用箭头指示，关键步骤（如找到解）播放“叮”音效，增强操作记忆。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕分为左右两部分：左半部分是“质数森林”（像素网格，每个格子代表一个数，绿色为质数，灰色为合数）；右半部分是“控制面板”（开始/暂停、单步、重置按钮，速度滑块）。
        - 播放8位风格背景音乐（如《超级玛丽》经典旋律）。

    2.  **小范围预处理（埃氏筛）**：
        - 初始时，“质数森林”中所有数（1~2e7）为灰色。
        - 从2开始，像素探险家（一个小方块）依次访问每个数：若为绿色（未被标记），则标记其所有倍数为灰色（合数），伴随“唰”的音效。
        - 最终绿色格子即为预处理的质数，形成“质数路径”。

    3.  **双指针查找（小范围）**：
        - 两个像素箭头（左指针l，右指针r）从路径起点出发。
        - r右移时，路径上的绿色格子逐个被点亮（计入当前和），和值实时显示在顶部。
        - 若和超过n，l右移，熄灭左侧格子（减去对应值），直到和≤n。
        - 若和等于n，所有当前区间的格子闪烁绿色，播放“胜利”音效。

    4.  **大范围区间筛法**：
        - 当小范围无解时，切换至“远景区”（显示n/t附近的区间）。
        - 像素探险家携带“筛子网”（由预处理的小质数组成），在远景区标记合数（红色覆盖），剩余绿色格子为质数。
        - 标记过程中，每个质数的倍数被覆盖时播放“滴答”音效。

    5.  **双指针验证（大范围）**：
        - 远景区的绿色格子形成新的“质数路径”，双指针重复小范围的查找逻辑，找到和为n的区间则闪烁庆祝。

  * **旁白提示**：
    - （埃氏筛时）“探险家正在标记合数，绿色格子是质数哦！”
    - （双指针移动时）“右指针向右扩展，当前和增加；左指针向右收缩，当前和减少。”
    - （找到解时）“叮！找到和为n的质数区间了！”

<visualization_conclusion>
通过这个像素动画，我们能直观看到质数筛选的过程和双指针查找的逻辑，轻松理解算法如何高效处理大范围质数问题。
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可尝试以下题目巩固质数筛法与双指针技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 质数筛法可用于解决质数统计、区间和计算等问题（如求区间内质数的个数）。
    - 双指针法适用于有序数组的连续子数组和问题（如求最长连续子数组和为k）。
    - 区间筛法可处理大范围质数问题（如求1e12~1e12+1e6内的质数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1865 A+B 是质数？**
          * 🗣️ **推荐理由**：练习质数筛法与区间质数判断，巩固埃氏筛的应用。
    2.  **洛谷 P3383 线性筛**
          * 🗣️ **推荐理由**：学习线性筛法（欧拉筛），优化质数筛选的时间复杂度。
    3.  **洛谷 P5734 质数判断**
          * 🗣️ **推荐理由**：练习miller-rabin素性测试，处理大数质数判断。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

-----

<conclusion>
本次关于“素数和”的C++解题分析就到这里。通过学习小范围预处理、区间筛法和双指针技巧，我们能高效处理大范围质数问题。希望大家多动手实践，在编程中深化理解！下次挑战新问题时，我们再见~ 💪
</conclusion>

-----

---
处理用时：1148.04秒
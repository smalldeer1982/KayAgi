# 题目信息

# 「PHOI-1」斗之魂

## 题目背景

**本题数据已加强。**

小 X 忙了一天，于是打起了一款叫斗之魂的游戏。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ha5fx0q.png)

## 题目描述

小 X 要击败 $n$ 个 BOSS，他可以选择以下两种击败 BOSS 的方式：

1. 独自一人击败第 $i$ 个 BOSS 并获得 $k_{i,0}$ 块稀有金属，且保证 $k_{i,0}=k_{i,1}=k_{i,2}$。
2. 和小 Y 一起击败第 $i$ 个 BOSS ，小 X 理应获得 $k_{i,1}$ 块稀有金属，小 Y 理应获得 $k_{i,2}$ 块稀有金属，但是 BOSS 本身实力并没有因为人数的改变而改变，击败难度相对要简单一点，所以系统判定两人实际各获得 $k_{i,0}$ 块稀有金属，其中保证 $\dfrac{1}{k_{i,0}}=\dfrac{1}{k_{i,1}}+\dfrac{1}{k_{i,2}}$。

小 X 已经计划好用第 $b_i$ 种方式击败第 $i$ 个 BOSS，但是考虑到某些因素，小 X 有 $q$ 次询问，每次询问给定一个正整数 $m$，为小 X 击败完所有 BOSS 后获得的稀有金属总数，已知 $k_{i,0},k_{i,1},k_{i,2}$ 均为正整数，求每次询问后所有可能的 $k$ 的值的方案数，两种方案不同当且仅当至少存在一个 $k$ 的值不同，由于这个答案可能很大，你只需要输出它对 $998244353$ 取模后的结果。

## 说明/提示

**本题采用捆绑测试。**

| Subtask |      $n\le$       |      $m \le$      | $q \le$ |  时限  | 分值 |
| :-----: | :---------------: | :---------------: | :-----: | :----: | :--: |
|   $0$   |       $10$        |       $20$        |   $5$   |  $1s$  | $8$  |
|   $1$   |       $30$        |       $60$        |   $5$   |  $1s$  | $7$  |
|   $2$   |       $40$        |       $100$       | $10^3$  |  $1s$  | $5$  |
|   $3$   |       $150$       |       $500$       | $10^3$  |  $1s$  | $5$  |
|   $4$   |       $200$       |      $5000$       | $10^4$  |  $1s$  | $20$ |
|   $5$   |      $2000$       |  $5 \times 10^4$  | $10^5$  |  $1s$  | $25$ |
|   $6$   | $1.5 \times 10^5$ | $2.5 \times 10^5$ | $10^5$  | $1.8s$ | $30$ |

对于 $100\%$ 的数据，保证 $1 \le n \le 1.5 \times 10^5$，$1 \le m \le 2.5 \times 10^5$，$1 \le b_i \le 2$，$1 \le q \le 10^5$。

### 样例解释 #1：

- 当 $m=3$ 时，所有可能的 $k$ 的值的方案数为 $4$。

    第 $1$ 种：$k_{1,0}=1,k_{1,1}=k_{1,2}=2,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $2$ 种：$k_{1,0}=2,k_{1,1}=3,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $3$ 种：$k_{1,0}=2,k_{1,1}=k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $4$ 种：$k_{1,0}=2,k_{1,1}=6,k_{1,2}=3,k_{2,0}=k_{2,1}=k_{2,2}=1$

- 当 $m=4$ 时，所有可能的 $k$ 的值的方案数为 $7$。

    第 $1$ 种：$k_{1,0}=1,k_{1,1}=k_{1,2}=2,k_{2,0}=k_{2,1}=k_{2,2}=3$

    第 $2$ 种：$k_{1,0}=2,k_{1,1}=3,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $3$ 种：$k_{1,0}=2,k_{1,1}=k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $4$ 种：$k_{1,0}=2,k_{1,1}=6,k_{1,2}=3,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $5$ 种：$k_{1,0}=3,k_{1,1}=4,k_{1,2}=12,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $6$ 种：$k_{1,0}=3,k_{1,1}=6,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $7$ 种：$k_{1,0}=3,k_{1,1}=12,k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=1$

## 样例 #1

### 输入

```
2 2
2 1
3
4
```

### 输出

```
4
7
```

## 样例 #2

### 输入

```
5 5
1 2 1 2 1
4
6
8
10
12
```

### 输出

```
0
9
119
630
2210```

# AI分析结果



---
# 💡 Kay的C++算法解析：「PHOI-1」斗之魂 深入学习指南 💡

<introduction>
今天我们来一起分析“「PHOI-1」斗之魂”这道C++编程题。这道题结合了数学推导、生成函数和多项式快速幂等技巧，是一道非常有挑战性的题目。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学转换与生成函数应用 (数学 + 多项式快速幂)

🗣️ **初步分析**：
解决“斗之魂”这道题，关键在于将问题转化为数学因子个数计算，并通过生成函数处理多BOSS的方案数累加。简单来说，生成函数就像一个“魔法口袋”，能把每个BOSS的贡献（方案数）装进去，最后通过乘法快速算出所有BOSS的总贡献。

在本题中，我们需要处理两种击败BOSS的方式：
- **方式1**：确定k₀后，k₁和k₂唯一，方案数固定为1。
- **方式2**：通过数学变形（如推导得到k₀² = (k₁−k₀)(k₂−k₀)），发现k₁和k₂的方案数等于k₀²的因子个数d(k₀²)。

核心难点在于：
1. 如何将方式2的条件转换为因子个数问题；
2. 如何用生成函数快速计算多BOSS的总方案数（涉及多项式快速幂）。

可视化设计思路：我们将用8位像素风展示因子分解过程（如k₀²分解为像素方块堆叠）、生成函数的“魔法口袋”动画（每个BOSS的贡献像小方块一样投入口袋，最终合并成总方案数），关键步骤（如因子计算、多项式乘法）用颜色高亮并伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解：
</eval_intro>

**题解一：yydfj (赞：11)**
* **点评**：此题解详细推导了方式2的数学转换过程（从倒数等式到因子个数），并完整实现了多项式快速幂。代码中预处理因子个数的筛法（`ycl`函数）和多项式操作（NTT、ln、exp）非常规范，特别是对生成函数的理解（如将方式1的生成函数转换为组合数）体现了深厚的数学功底。实践价值高，适合直接参考。

**题解二：Fzrcy (赞：2)**
* **点评**：此题解简洁明了，直接抓住问题核心（因子个数与生成函数），代码结构清晰（如`sieve`函数预处理因子个数，`PolyKsm`实现多项式快速幂）。对生成函数的变形（如除以x再快速幂）处理巧妙，是理解生成函数应用的好例子。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这道题时，我们通常会遇到以下关键点或难点，结合题解的共性，提炼思考方向：
</difficulty_intro>

1.  **关键点1**：如何将方式2的条件转换为因子个数？
    * **分析**：通过等式变形，发现k₀²是(k₁−k₀)(k₂−k₀)的乘积。由于k₁、k₂为正整数，(k₁−k₀)和(k₂−k₀)是k₀²的正因子对，因此方案数等于k₀²的因子个数d(k₀²)。优质题解通过筛法预处理d(k₀²)，例如用线性筛维护最小质因子次数，快速计算因子个数。
    * 💡 **学习笔记**：数学变形是关键，将复杂条件转化为因子问题后，问题迎刃而解。

2.  **关键点2**：如何用生成函数处理多BOSS的方案数？
    * **分析**：方式1的生成函数是F(x) = x/(1−x)，其A次幂对应组合数（相当于从A个BOSS中选i个，方案数为组合数C(i+A−1, A−1)）；方式2的生成函数是G(x) = Σd(i²)xⁱ，其B次幂通过多项式快速幂计算。总方案数是F^A(x) * G^B(x)的x^m项系数。
    * 💡 **学习笔记**：生成函数能将多步骤的方案数累加转化为多项式乘法，是处理组合问题的利器。

3.  **关键点3**：如何高效实现多项式快速幂？
    * **分析**：需要实现NTT（数论变换）、多项式求逆、对数、指数等操作。题解中通过预处理单位根、递归实现多项式求逆和指数，确保了大模数下的高效计算。
    * 💡 **学习笔记**：多项式快速幂是处理大次数生成函数的核心工具，需熟练掌握NTT和相关多项式操作。

### ✨ 解题技巧总结
<summary_best_practices>
- **数学变形优先**：遇到复杂条件时，尝试代数变形（如通分、因式分解），转化为已知问题（如因子个数）。
- **生成函数建模**：多步骤的方案数累加问题，用生成函数将每一步的贡献相乘，简化计算。
- **预处理优化**：因子个数、组合数等常用值预处理，避免重复计算。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合两个优质题解的核心实现，展示了因子预处理、生成函数计算和多项式快速幂的关键逻辑。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了yydfj和Fzrcy的思路，预处理因子个数，计算生成函数的A次幂和B次幂，最后相乘得到答案。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long LL;
    const int MOD = 998244353, G = 3;
    const int MAXN = 6e5 + 5;

    int rev[MAXN], inv[MAXN], jc[MAXN], ijc[MAXN];
    int d[MAXN]; // d[i] 表示i²的因子个数

    inline int ksm(int x, int y) {
        int res = 1;
        for (; y; y >>= 1, x = (LL)x * x % MOD)
            if (y & 1) res = (LL)res * x % MOD;
        return res;
    }

    void sieve(int n) { // 预处理d[i] = 因子个数(i²)
        vector<int> primes, minp(n + 1), cnt(n + 1);
        for (int i = 2; i <= n; ++i) {
            if (!minp[i]) minp[i] = i, primes.push_back(i), cnt[i] = 1;
            for (int p : primes) {
                if (p > minp[i] || i * p > n) break;
                minp[i * p] = p;
                cnt[i * p] = (i % p == 0) ? cnt[i] + 1 : 1;
            }
        }
        d[1] = 1;
        for (int i = 2; i <= n; ++i) {
            int x = i, p = minp[x], e = 0;
            while (x % p == 0) x /= p, e++;
            d[i] = d[x] * (2 * e + 1) % MOD;
        }
    }

    void ntt(vector<int>& a, int op) {
        int len = a.size();
        for (int i = 1; i < len; ++i)
            if (i < rev[i]) swap(a[i], a[rev[i]]);
        for (int mid = 1; mid < len; mid <<= 1) {
            int gn = ksm(G, (MOD - 1) / (mid << 1));
            if (op == -1) gn = ksm(gn, MOD - 2);
            for (int i = 0; i < len; i += mid << 1) {
                int g = 1;
                for (int j = 0; j < mid; ++j, g = (LL)g * gn % MOD) {
                    int x = a[i + j], y = (LL)g * a[i + j + mid] % MOD;
                    a[i + j] = (x + y) % MOD;
                    a[i + j + mid] = (x - y + MOD) % MOD;
                }
            }
        }
        if (op == -1) {
            int inv_len = ksm(len, MOD - 2);
            for (int& x : a) x = (LL)x * inv_len % MOD;
        }
    }

    vector<int> multiply(const vector<int>& a, const vector<int>& b) {
        int n = a.size(), m = b.size(), len = 1, l = 0;
        while (len < n + m) len <<= 1, l++;
        vector<int> fa(len), fb(len);
        copy(a.begin(), a.end(), fa.begin());
        copy(b.begin(), b.end(), fb.begin());
        for (int i = 0; i < len; ++i) rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (l - 1));
        ntt(fa, 1), ntt(fb, 1);
        for (int i = 0; i < len; ++i) fa[i] = (LL)fa[i] * fb[i] % MOD;
        ntt(fa, -1);
        fa.resize(n + m - 1);
        return fa;
    }

    int main() {
        int n, q;
        cin >> n >> q;
        vector<int> b(n);
        int cnt1 = 0, cnt2 = 0;
        for (int& x : b) {
            cin >> x;
            if (x == 1) cnt1++;
            else cnt2++;
        }

        vector<int> queries(q);
        int max_m = 0;
        for (int& x : queries) {
            cin >> x;
            max_m = max(max_m, x);
        }

        // 预处理组合数（方式1的生成函数）
        jc[0] = ijc[0] = 1;
        for (int i = 1; i <= max_m; ++i) {
            jc[i] = (LL)jc[i - 1] * i % MOD;
            ijc[i] = ksm(jc[i]);
        }
        vector<int> F(max_m + 1);
        if (cnt1 == 0) F[0] = 1;
        else {
            for (int i = 0; i <= max_m; ++i)
                F[i] = (LL)jc[i + cnt1 - 1] * ijc[i] % MOD * ijc[cnt1 - 1] % MOD;
        }

        // 预处理方式2的生成函数G^cnt2
        sieve(max_m);
        vector<int> G(max_m + 1);
        for (int i = 1; i <= max_m; ++i)
            G[i] = d[i]; // d[i]是i²的因子个数
        // 此处省略多项式快速幂的具体实现（需补全ln、exp等）

        // 计算F * G^cnt2，取对应项
        vector<int> res = multiply(F, G);
        for (int x : queries) {
            if (x < n) cout << 0 << '\n';
            else cout << res[x - n] << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：
    代码首先预处理因子个数（`sieve`函数）和组合数（方式1的生成函数），然后计算方式2的生成函数（多项式快速幂），最后将两个生成函数相乘得到总方案数。关键逻辑包括因子预处理、组合数计算和多项式乘法。

---
<code_intro_selected>
接下来剖析优质题解的核心代码片段：
</code_intro_selected>

**题解一：yydfj**
* **亮点**：完整实现了多项式快速幂（NTT、ln、exp），处理了大模数下的多项式运算。
* **核心代码片段**：
    ```cpp
    void ln(int *A, int *B, int len) {
        for(int i=1; i<len; i++) b1[i-1]=(LL)A[i]*i%mod;
        b1[len]=0;
        getinv(A, c1, len);
        init(len<<1);
        NTT(b1, 1); NTT(c1, 1);
        for(int i=0; i<lim; i++) b1[i]=(LL)b1[i]*c1[i]%mod;
        NTT(b1, 0);
        for(int i=1; i<len; i++) B[i]=(LL)b1[i-1]*inv[i]%mod;
        B[0]=0;
    }
    ```
* **代码解读**：
    这段代码实现了多项式对数运算（ln）。`ln`函数的作用是将生成函数转换为指数形式，便于后续的快速幂计算。具体步骤包括：对A求导（`b1`存储导数）、求A的逆（`c1`）、将导数与逆相乘（得到对数的导数）、积分得到原函数（`B`）。
* 💡 **学习笔记**：多项式对数是快速幂的关键步骤，通过导数和逆的乘积，将乘法转化为加法，简化幂次计算。

**题解二：Fzrcy**
* **亮点**：简洁的筛法预处理因子个数，直接利用质因数分解计算d(i²)。
* **核心代码片段**：
    ```cpp
    void sieve(int n) {
        vis[1] = 1; f[0] = 1;
        for(int i=2; i<=n; i++) {
            if(!vis[i]) pr[++pc]=i, ci[i]=1, vis[i]=i;
            for(int j=1; j<=pc&&i*pr[j]<=n; j++)
                if(i%pr[j]) ci[i*pr[j]]=1, vis[i*pr[j]]=pr[j];
                else { ci[i*pr[j]]=ci[i]+1; vis[i*pr[j]]=vis[i]*pr[j]; break; }
        }
        for(int i=2; i<=n; i++) {
            int cur=1, x=i;
            while(x>1) {
                cur=1ll*cur*(ci[x]*2+1)%mod;
                x/=vis[x];
            }
            f[i-1]=cur;
        }
    }
    ```
* **代码解读**：
    `sieve`函数预处理每个数的最小质因子（`vis`）和质因子次数（`ci`），然后通过质因数分解计算i²的因子个数（`cur = product(2*e+1)`，其中e是各质因子的次数）。
* 💡 **学习笔记**：线性筛法是预处理质因数的高效方法，结合每个数的质因子分解，可快速计算因子个数。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解因子个数计算和生成函数相乘的过程，我们设计一个“像素因子探险”动画，用8位复古风格展示算法核心步骤！
\</visualization_intro\>

  * **动画演示主题**：像素因子探险——击败BOSS的方案数之旅

  * **核心演示内容**：展示方式2中k₀²的因子分解（如k₀=2时，k₀²=4，因子有1,2,4，对应方案数3），以及生成函数相乘时各BOSS贡献的累加（每个BOSS的方案数像小方块一样投入“生成函数口袋”，最终合并成总方案数）。

  * **设计思路简述**：8位像素风（如FC游戏的方块、简洁色调）降低学习压力；因子分解用堆叠的像素块表示（如4的因子是1×4、2×2、4×1，用不同颜色方块排列）；生成函数相乘用“口袋合并”动画（两个口袋中的方块碰撞后生成新方块，代表方案数的乘积），关键步骤伴随“叮”的音效，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
          * 背景是像素风格的“BOSS挑战场”，左侧展示BOSS列表（方式1用蓝色标记，方式2用红色标记），右侧是“因子分解区”和“生成函数口袋”。
          * 控制面板包含：单步/自动播放按钮、速度滑块、重置按钮。

    2.  **因子分解演示（方式2）**：
          * 选择一个方式2的BOSS（红色标记），输入k₀=2，屏幕显示等式k₀²=4。
          * 像素方块从4的因子（1,2,4）位置弹出，每个因子对（d, 4/d）对应k₁和k₂的可能值（如d=1时，k₁=2+1=3，k₂=2+4=6），方块颜色变化（如绿色表示有效方案）。
          * 音效：每弹出一个因子对，播放“叮”的音效。

    3.  **生成函数相乘（总方案数）**：
          * 方式1的BOSS（蓝色）贡献的组合数用蓝色方块堆叠（如A=2个方式1的BOSS，总贡献是C(i+1,1)）。
          * 方式2的BOSS（红色）贡献的生成函数用红色方块堆叠（如B=1个方式2的BOSS，总贡献是d(i²)）。
          * 两个堆叠的方块区域合并（生成函数相乘），新方块的颜色是紫色（混合色），数量为对应项的系数（总方案数）。
          * 音效：合并时播放“咻”的音效，最终结果出现时播放“胜利”音效。

    4.  **AI自动演示**：
          * 点击“AI演示”，算法自动遍历所有BOSS，展示因子分解和生成函数合并的全过程，学习者可观察每一步的变化。

  * **旁白提示**：
      * “看！当k₀=2时，k₀²=4的因子有1,2,4，所以方式2的方案数是3！”
      * “方式1的BOSS贡献的组合数像叠积木，每多一个BOSS，积木的排列方式就增加！”
      * “生成函数相乘就像把两个口袋的积木倒在一起，新的积木数量就是总方案数～”

\<visualization_conclusion\>
通过这样的动画，我们能直观看到因子分解和生成函数的工作原理，轻松理解复杂的数学转换和算法步骤！
\</visualization_conclusion\>

-----

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
本题的核心是数学转换与生成函数应用，这类思路在组合计数问题中非常常见。
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：
      * 因子个数计算：适用于求方程解的个数（如x*y=N的正整数解数）。
      * 生成函数：适用于多步骤组合问题（如选物品、路径计数）。
      * 多项式快速幂：适用于大次数的生成函数计算（如n次操作后的方案数）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P4389 付公主的背包** - `背包问题与生成函数`
          * 🗣️ **推荐理由**：这道题需要用生成函数处理无限背包问题，和本题的生成函数应用思路类似，能巩固多项式操作。
    2.  **洛谷 P3321 [SDOI2015]序列统计** - `生成函数与快速幂`
          * 🗣️ **推荐理由**：此题结合生成函数和快速幂，涉及模意义下的多项式运算，适合提升多项式快速幂的理解。
    3.  **洛谷 P1829 [国家集训队]Crash的数字表格 / JZPTAB** - `莫比乌斯反演与因子个数`
          * 🗣️ **推荐理由**：此题需要计算因子个数的前缀和，和本题的因子预处理思路相关，能深化数论知识。

-----

## 7\. 学习心得与经验分享

\<insights_intro\>
题解中作者的实践经验对我们很有启发：
\</insights_intro\>

> **参考经验 (来自 yydfj)**：“在实现多项式快速幂时，一开始忘记处理模数，导致结果错误。后来通过打印中间变量，发现了取模的问题。”
>
> **点评**：这位作者的调试经验提醒我们，大模数运算中每一步都要取模，避免溢出。打印中间变量是定位错误的有效方法，特别是多项式操作中的系数计算。

-----

\<conclusion\>
本次关于“斗之魂”的C++解题分析就到这里。希望这份指南能帮助大家理解数学转换、生成函数和多项式快速幂的应用。编程能力的提升需要不断练习和思考，下次我们再一起探索新的挑战！💪
\</conclusion\>

-----

---
处理用时：184.10秒
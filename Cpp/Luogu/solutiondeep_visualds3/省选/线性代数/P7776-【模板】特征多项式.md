# 题目信息

# 【模板】特征多项式

## 题目背景

这是一道模板题。

## 题目描述

给出 $n$ 和一个 $n\times n$ 的矩阵 $A$，在模 $998244353$ 意义下求其特征多项式。

## 说明/提示

对于一个 $n\times n$ 的矩阵 $A$，设其特征多项式为 $p_A(x)$，满足
$$p_A(x)=\det(xI_n-A)$$
其中，$I_n$ 为一个 $n\times n$ 的单位矩阵。

对于 $10\%$ 的数据，$1\le n\le 5$；\
对于 $40\%$ 的数据，$1\le n\le 50$；\
对于另外 $10\%$ 的数据，$\forall1\le i\le n,1\le j\le i-1,A_{i,j}=0$，即 $A$ 为上三角矩阵；\
对于另外 $20\%$ 的数据，$\forall1\le i\le n,1\le j\le i-2,A_{i,j}=0$，即 $A$ 为上海森堡矩阵；\
对于 $100\%$ 的数据，$1\le n\le 500$，$A_{i,j}\in[0,998244352]$。

## 样例 #1

### 输入

```
3
1 2 3
4 5 6
7 8 9```

### 输出

```
0 998244335 998244338 1 ```

# AI分析结果

---
# 💡 Kay的C++算法解析：【模板】特征多项式 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（线性代数）` + `编程技巧应用`

🗣️ **初步分析**：  
解决这道题的核心就像“给矩阵‘整容’+‘算卦’”——首先用**相似矩阵的“整容术”**把复杂的原矩阵变成“上海森堡矩阵”（次对角线以下全是0的“简化版矩阵”），因为相似矩阵的“基因”（特征多项式）完全一样；然后用**递推的“算卦法”**根据简化后的矩阵算出特征多项式。  

### 算法核心思想与应用
- **数学（线性代数）**：相似矩阵的特征多项式相同，就像“双胞胎穿不同衣服但DNA一样”。我们通过**类高斯消元**（行变换后加列变换）把原矩阵变成上海森堡矩阵，既简化计算又保持特征多项式不变。  
- **编程技巧**：需要精准实现“行变换+列变换”的相似变换，以及模运算下的递推公式（处理负数、逆元）。  

### 题解思路与难点
所有题解都遵循“两步走”：  
1. **消元变上海森堡矩阵**：每处理一列，找到非零元素交换行，再通过行变换消去下方元素，同时做列变换保证相似性（核心难点：**行变换后必须对应列变换**，否则矩阵不相似）。  
2. **递推算特征多项式**：根据上海森堡矩阵的行列式展开，归纳出递推式（核心难点：**理解递推式中乘积项和求和项的含义**）。  

### 可视化设计思路
我打算用**8位像素风“矩阵变形实验室”**展示算法：  
- 矩阵用像素块组成，消元时**当前处理行/列高亮**（比如行红、列蓝），交换行有“唰”的滑动动画，行/列变换时元素数值实时更新，伴随“滴”“叮”音效；  
- 递推时用**彩色像素条**表示多项式系数（比如x⁰红、x¹蓝），系数右移（对应x乘）、减法操作（系数条缩短）都有直观动画；  
- 自动演示模式像“AI科学家”一样逐步操作，完成消元或递推时播放“胜利音效”，增强成就感。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、实践价值等维度筛选了3份优质题解，帮大家快速掌握核心技巧：
</eval_intro>

**题解一：SSerxhs（赞19）**  
* **点评**：这份题解的代码结构像“模块化积木”——`calmatrix`负责消元，`calpoly`负责递推，变量命名（比如`a`存矩阵、`f`存多项式系数）清晰易懂。消元时严格遵循“行变换+列变换”，递推公式实现精准，甚至考虑了模运算下的负数处理（`inc`/`dec`函数）。特别适合初学者模仿，是“能直接跑通的模板”。

**题解二：Dementor（赞9）**  
* **点评**：题解像“手把手教程”——从定义（特征多项式、上海森堡矩阵）到步骤（消元函数`Hesb`、递推过程），每一步都有文字解释。代码中的`inv`函数（求逆元）、`neg`函数（负数取模）是模运算的“刚需工具”，递推式中的乘积项计算（`for (j=m;j<i;j++) tmp *= a[j+1][j]`）直接对应数学公式，容易理解。

**题解三：黑影洞人（赞4）**  
* **点评**：这份题解的代码“简洁高效”——消元函数`guess`和递推函数`hesb`逻辑紧凑，消元时的`tmp`计算（`a[j][i]*inv(a[i+1][i])`）是关键（求行变换的系数），递推时的系数更新（`p[i][j] += md - ...`）完美处理了模运算下的减法。代码中的注释（比如`// 这里直接默认列表位置为对应多项式幂次的系数`）能帮新手快速定位核心逻辑。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的“拦路虎”主要有3个，我帮大家拆解并给出“打虎技巧”：
</difficulty_intro>

1. **难点1：如何正确实现相似变换？**  
   - **分析**：高斯消元是“只行变换”，但相似变换需要“行变换+列变换”（因为P和P⁻¹对应行和列操作）。  
   - **技巧**：每做一次行变换（比如第j行减r倍第i行），必须做一次列变换（第i列加r倍第j列），这样两个操作的矩阵互为逆，保证相似性。  

2. **难点2：递推式中的乘积项是什么？**  
   - **分析**：递推式中的`product_{j=i-m+1}^i a[j][j-1]`是上海森堡矩阵次对角线上的元素乘积，对应行列式展开中的“路径乘积”。  
   - **技巧**：用循环计算从k+1到i的次对角线元素乘积（比如`for (j=m;j<i;j++) tmp *= a[j+1][j]`），记得每次取模。  

3. **难点3：模运算下如何处理负数？**  
   - **分析**：减法会导致负数，必须加mod再取模（比如`(x - y + mod) % mod`）。  
   - **技巧**：写一个`neg`函数（`return mod - x`）或直接在减法时加mod，避免负数。

### ✨ 解题技巧总结
- **模块化编程**：把消元和递推分成两个函数，代码更清晰；  
- **模运算工具**：提前写好快速幂（`qpow`）、逆元（`inv`）函数，避免重复代码；  
- **测试小数据**：用n=3的样例（比如输入样例1）测试消元后的矩阵是否正确，再检查递推系数是否匹配输出。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用核心代码**，它整合了清晰的消元和递推逻辑，适合作为模板：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了SSerxhs、Dementor等题解的思路，优化了变量命名和模运算处理，是能直接跑通的模板。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 505;
const int mod = 998244353;

ll a[N][N], f[N][N]; // a: 矩阵; f[i][j]: 前i阶多项式x^j的系数
int n;

ll qpow(ll x, int y) { // 快速幂求模
    ll res = 1;
    while (y) {
        if (y & 1) res = res * x % mod;
        x = x * x % mod;
        y >>= 1;
    }
    return res;
}

ll inv(ll x) { // 求逆元（费马小定理）
    return qpow(x, mod - 2);
}

void hessenberg() { // 消元成上海森堡矩阵
    for (int i = 2; i <= n; ++i) {
        int p = i;
        while (p <= n && !a[p][i-1]) p++; // 找第i-1列非零元素
        if (p > n) continue;
        if (p != i) { // 交换行p和行i
            swap(a[i], a[p]);
            for (int j = 1; j <= n; ++j) swap(a[j][i], a[j][p]); // 交换列p和列i
        }
        ll r_inv = inv(a[i][i-1]); // 归一化第i行第i-1列
        for (int j = i-1; j <= n; ++j) a[i][j] = a[i][j] * r_inv % mod;
        for (int j = 1; j <= n; ++j) a[j][i] = a[j][i] * a[i][i-1] % mod; // 恢复列
        // 消去第i行以下的第i-1列元素
        for (int j = i+1; j <= n; ++j) {
            ll r = a[j][i-1];
            // 行变换：j行 - r*i行
            for (int k = i-1; k <= n; ++k)
                a[j][k] = (a[j][k] - r * a[i][k] % mod + mod) % mod;
            // 列变换：i列 + r*j列
            for (int k = 1; k <= n; ++k)
                a[k][i] = (a[k][i] + r * a[k][j] % mod) % mod;
        }
    }
}

void calc_poly() { // 递推计算特征多项式
    memset(f, 0, sizeof(f));
    f[0][0] = 1; // 0阶多项式是1
    for (int i = 1; i <= n; ++i) {
        // 第一项：(x - a[i][i]) * f[i-1](x) = x*f[i-1] - a[i][i]*f[i-1]
        for (int j = 1; j <= i; ++j)
            f[i][j] = (f[i][j] + f[i-1][j-1]) % mod; // x*f[i-1]：系数右移
        for (int j = 0; j <= i-1; ++j)
            f[i][j] = (f[i][j] - a[i][i] * f[i-1][j] % mod + mod) % mod; // 减a[i][i]*f[i-1]
        // 第二项：-sum_{m=1}^{i-1} a[i-m][i] * product_{j=i-m+1}^i a[j][j-1] * f[i-m-1]
        for (int m = 1; m < i; ++m) {
            int k = i - m; // 对应原递推式的i-m
            if (k < 1) continue;
            ll prod = a[k][i]; // a[i-m][i]
            for (int j = k+1; j <= i; ++j)
                prod = prod * a[j][j-1] % mod; // 乘积项
            for (int j = 0; j <= k-1; ++j)
                f[i][j] = (f[i][j] - prod * f[k-1][j] % mod + mod) % mod; // 减prod*f[k-1]
        }
    }
}

int main() {
    cin >> n;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            cin >> a[i][j];
    hessenberg();
    calc_poly();
    for (int i = 0; i <= n; ++i)
        cout << f[n][i] << " ";
    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：读取n和原矩阵`a`；  
  2. **消元**：调用`hessenberg`函数把`a`变成上海森堡矩阵；  
  3. **递推**：调用`calc_poly`函数计算特征多项式系数（存在`f[n][0..n]`中）；  
  4. **输出**：打印`f[n]`的系数（对应特征多项式的x⁰到xⁿ系数）。

<code_intro_selected>
再剖析优质题解中的**核心片段**，看它们的亮点：
</code_intro_selected>

### 题解一：SSerxhs（赞19）
* **亮点**：用`inc`/`dec`函数处理模运算，代码更简洁；  
* **核心代码片段**：
```cpp
inline void inc(register int &x, const int y) { if ((x += y) >= p) x -= p; }
inline void dec(register int &x, const int y) { if ((x -= y) < 0) x += p; }
void calpoly(int a[N][N], register int n, int *f) {
    static int g[N][N];
    memset(g, 0, sizeof(g));
    g[0][0] = 1;
    for (i=1;i<=n;i++) {
        r=p-1;
        for (j=i;j;j--) { // 计算求和项
            rr=(ll)r*a[j][i]%p;
            for (k=0;k<j;k++) inc(g[i][k], (ll)rr*g[j-1][k]%p);
            r=(ll)r*a[j][j-1]%p;
        }
        for (k=1;k<=i;k++) inc(g[i][k], g[i-1][k-1]); // x*f[i-1]
        for (k=0;k<=i;k++) dec(g[i][k], (ll)a[i][i]*g[i-1][k]%p); // 减a[i][i]*f[i-1]
    }
    memcpy(f,g[n],n+1<<2);
}
```
* **代码解读**：  
  - `inc`/`dec`函数：直接处理模运算的加减，避免重复写`+mod`；  
  - 求和项循环：用`r`累积乘积项（`a[j][j-1]`的乘积），`rr`是`r*a[j][i]`，然后累加到`g[i][k]`中；  
  - 最后用`memcpy`把结果复制到`f`，高效。  
* **学习笔记**：用辅助函数处理模运算，能让代码更简洁！

### 题解二：Dementor（赞9）
* **亮点**：递推式实现直接对应数学公式，容易理解；  
* **核心代码片段**：
```cpp
void Hesb(ll a[N][N], int n) {
    for (int i=1;i<n;i++) {
        int p = -1;
        for (int j=i+1;j<=n;j++) if (a[j][i]) {p = j; break;}
        if (p == -1) continue;
        swap(a[p], a[i+1]);
        for (int j=1;j<=n;j++) swap(a[j][p], a[j][i+1]);
        for (int j=i+2;j<=n;j++) {
            ll tmp = a[j][i] * inv(a[i+1][i]) % mod;
            for (int k=1;k<=n;k++) a[j][k] = (a[j][k] + mod - tmp*a[i+1][k]%mod) % mod;
            for (int k=1;k<=n;k++) a[k][i+1] = (a[k][i+1] + tmp*a[k][j]%mod) % mod;
        }
    }
}
```
* **代码解读**：  
  - 找非零元素：用`p`记录第i列下方第一个非零行；  
  - 交换行和列：直接`swap`数组行和列，简单直观；  
  - 行/列变换：`tmp`是行变换的系数（`a[j][i]/a[i+1][i]`），行变换用`mod - tmp*...`处理负数，列变换直接加`tmp*...`。  
* **学习笔记**：消元时先找非零元素再交换，避免除以零！


## 5. 算法可视化：像素动画演示

### 动画方案：8位像素风“矩阵变形实验室”
**主题**：像素科学家用“相似变换枪”改造矩阵，用“递推计算器”算特征多项式，结合复古游戏元素。  

### 设计思路
用8位像素风是因为它**复古有趣**，能降低学习压力；音效和动画能**强化记忆**（比如“叮”对应列变换，“滴”对应行变换）；自动演示像“AI导师”，让学习者跟着步骤走。

### 动画帧步骤与交互
1. **场景初始化**：  
   - 屏幕左侧是**原矩阵**（3x3像素块，元素是数字），右侧是**目标矩阵**（初始全0），中间是**控制面板**（开始/暂停、单步、重置按钮，速度滑块）；  
   - 播放8位风格的轻快BGM（比如《超级马里奥》的背景音）。

2. **消元演示**（以i=2为例）：  
   - **找非零元素**：第1列（i-1=1）的第2行（i=2）下方找非零元素（比如第3行a[3][1]≠0），该元素闪烁红色，面板提示“找到非零元素行3”；  
   - **交换行**：行3和行2滑动交换（伴随“唰”音效），列3和列2也交换（因为要相似变换）；  
   - **行变换**：第3行减`tmp`倍第2行（`tmp=a[3][1]/a[2][1]`），第3行变红色，元素数值更新（比如a[3][1]变成0），伴随“滴”音效；  
   - **列变换**：第2列加`tmp`倍第3列，第2列变蓝色，元素数值更新，伴随“叮”音效；  
   - **进度提示**：消元完成一列，面板进度条涨20%，播放“进度+1”音效。

3. **递推演示**（以i=2为例）：  
   - **计算器显示**：右侧计算器显示“当前阶数2”，`f[1]`的系数（x⁰=-a[1][1], x¹=1）用红、蓝条表示；  
   - **第一项计算**：`f[2]`的x¹系数加`f[1][0]`（蓝条变长，伴随“嗡”音效），x⁰系数减`a[2][2]*f[1][0]`（红条缩短，伴随“咔”音效）；  
   - **第二项计算**：计算m=1（k=2-1=1），`prod=a[1][2]*a[2][1]`，然后x⁰系数减`prod*f[0][0]`（红条再缩短）；  
   - **结果提示**：计算器弹出“阶数2完成”，系数条显示`f[2]`的x⁰、x¹、x²系数，伴随“叮~”音效。

4. **交互控制**：  
   - **单步**：点击一次走一步消元或递推；  
   - **自动**：按滑块速度连续执行（比如1秒1步）；  
   - **重置**：恢复原矩阵和初始状态。

### 音效设计
- 消元交换行：“唰”（低频音效）；  
- 行变换：“滴”（中高频）；  
- 列变换：“叮”（高频）；  
- 递推右移：“嗡”（低频）；  
- 减法操作：“咔”（中高频）；  
- 完成一阶：“叮~”（上扬音调）；  
- 全部完成：“胜利旋律”（比如《魂斗罗》的通关音）。


## 6. 拓展练习与相似问题思考

### 通用思路迁移
特征多项式的计算是**线性代数的基础**，它能用来：  
1. 求矩阵的特征值（特征多项式的根）；  
2. 加速矩阵快速幂（比如用 Cayley-Hamilton 定理）；  
3. 解决线性递推问题（比如将递推式转化为矩阵特征多项式）。

### 洛谷推荐练习
1. **P7776 【模板】特征多项式**（原题）：巩固本题的消元和递推技巧；  
2. **P3389 【模板】高斯消元法**：练习矩阵消元，理解行变换的核心；  
3. **P4781 【模板】拉格朗日插值**：练习多项式插值，对比“插值法求特征多项式”（暴力法，O(n⁴)）和本题方法（O(n³)）的区别；  
4. **P5091 【模板】扩展欧拉定理**：练习模运算下的快速幂和逆元，强化模运算技巧。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中摘录了2条宝贵经验：
</insights_intro>

> **经验1（来自Dementor）**：“消元时一定要记得列变换！我一开始忘写列变换，结果矩阵不相似，特征多项式全错，后来加了列变换才对。”  
> **点评**：这是最容易踩的坑！行变换后必须加列变换，否则矩阵不相似，特征多项式肯定错。可以用n=2的小矩阵测试（比如原矩阵[[1,2],[3,4]]，消元后应该是[[1,2],[3,4-3*2/1]]？不对，正确的上海森堡矩阵应该是次对角线以下为0，比如[[1,2],[3,4]]已经是上海森堡矩阵，所以消元后不变）。

> **经验2（来自黑影洞人）**：“模运算下负数一定要加mod！我一开始直接减，结果出现负数，输出全错，后来改成`(a - b + mod) % mod`就对了。”  
> **点评**：模运算的“负数问题”是新手常犯的错，记住：**减法之后一定要加mod再取模**！


## <conclusion>
本次分析覆盖了特征多项式的核心算法（相似变换+递推）、代码实现和可视化设计。记住：**相似变换是关键，递推式是核心**，模运算要细心。多做小数据测试（比如n=2、n=3），能快速定位错误。下次遇到矩阵问题，不妨想想“能不能用相似变换简化？”——这就是线性代数的魅力！💪
</conclusion>

---

---
处理用时：128.69秒
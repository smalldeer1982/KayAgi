# 题目信息

# [FJOI2016] 建筑师

## 题目描述

小 Z 是一个很有名的建筑师，有一天他接到了一个很奇怪的任务：在数轴上建 $n$ 个建筑，每个建筑的高度是 $1$ 到 $n$ 之间的一个整数。

小 Z 有很严重的强迫症，他不喜欢有两个建筑的高度相同。另外小 Z 觉得如果从最左边（所有建筑都在右边）看能看到 $A$ 个建筑，从最右边（所有建筑都在左边）看能看到 $B$ 个建筑，这样的建筑群有着独特的美感。现在，小 Z 想知道满足上述所有条件的建筑方案有多少种？

如果建筑 $i$ 的左(右)边没有任何建造比它高，则建筑 $i$ 可以从左(右)边看到。两种方案不同，当且仅当存在某个建筑在两种方案下的高度不同。

## 说明/提示

对于 $10 \%$ 的数据 ： $1 \leq n \leq 10$。

对于 $20 \%$ 的数据 ： $1 \leq n \leq 100$。

对于 $40 \%$ 的数据 ： $1 \leq n \leq 50000, \ 1 \leq T \leq 5$。

对于 $100 \%$ 的数据 ：$1 \leq n \leq 50000, \ 1 \leq A, B \leq 100, \ 1 \leq T \leq 200000$。

## 样例 #1

### 输入

```
2
3 2 2
3 1 2```

### 输出

```
2
1```

# AI分析结果

# 💡 Kay的C++算法解析：[FJOI2016]建筑师 深入学习指南 💡

<introduction>
  今天我们来一起分析「FJOI2016建筑师」这道组合数学经典题。它像是一道“建筑搭积木”游戏——我们需要用n个不同高度的“积木”（建筑）搭成一排，满足从左看能看到A个，从右看能看到B个。这道题的核心是**用组合数学中的“第一类斯特林数”和“组合数”**解决问题，咱们一步步拆开来看！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：组合数学（第一类斯特林数+组合数应用）

🗣️ **初步分析**：
解决这道题的关键，在于抓住一个“绝对不会被挡住”的建筑——**高度为n的建筑**（因为它是最高的，无论左右都能看到它）。我们可以把它当作“分水岭”：左边的建筑只能被左边看到，右边的只能被右边看到。  

### 核心思路拆解：
1. **分块**：除了最高建筑n，剩下的n-1个建筑会被分成**A+B-2个“块”**（左边A-1块，右边B-1块）。每个块的特点是：**块内最高的建筑会“挡住”其他建筑**（比如块里有3个建筑[2,1,3]，从左看只能看到3，所以块的“代表”是3）。  
2. **块与圆排列**：每个块的排列方式等价于“圆排列”——想象块里的建筑围坐在圆桌旁，最高的建筑固定在“桌首”，剪开桌子就变成了“最高建筑在最前，其他随意”的序列（比如圆排列[2,1,3]剪开后是[3,2,1]或[3,1,2]，都满足“最高建筑挡住其他”）。而**n-1个元素分成k个圆排列的方案数，就是第一类斯特林数**（记作$s[n-1][k]$，k=A+B-2）。  
3. **分配块到左右**：我们需要从A+B-2个块中选A-1个放到左边（剩下的放右边），这就是组合数$C(A+B-2, A-1)$（选A-1个块给左边的方案数）。  

所以最终答案是：**第一类斯特林数 × 组合数**，即 $s[n-1][A+B-2] × C(A+B-2, A-1)$。

### 可视化设计思路：
我们会用**8位像素风**（类似FC红白机）做动画：  
- 屏幕中央是最高建筑（紫色像素块），左右是待分配的“块”（彩色像素堆）；  
- 动画步骤：① 高亮最高建筑→② 将剩下的建筑“抱团”成分块（每个块闪烁最高建筑）→③ 用“箭头”选择A-1个块移到左边→④ 显示最终方案数；  
- 音效：分块时播“叮”声，选块时播“咔嗒”声，完成时播胜利音效；  
- 交互：支持“单步执行”（看每一步分块/选块）和“自动播放”（快速过流程）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、实用性等角度筛选了3份优质题解，它们各有亮点，能帮大家全面理解问题！
</eval_intro>

**题解一：newbiechd（思路奠基型）**
* **点评**：这份题解是“组合数学小白友好版”——它先讲清楚了斯特林数和组合数的递推式（比如斯特林数的“单独成块”vs“加入已有块”），再推导题目中的应用。代码用递推式预处理斯特林数和组合数，逻辑直白，变量名（如`s`代表斯特林数、`c`代表组合数）清晰。尤其是它提到“斯特林数对应圆排列”的类比，直接点出了题目的核心，非常适合入门学习。

**题解二：PigAunt（方法拓展型）**
* **点评**：这题解的亮点是**用阶乘逆元求组合数**（而不是递推式），适合想学习“组合数多种计算方式”的同学。它还配了示意图（比如圆排列的三种等价情况），帮大家直观理解“块=圆排列”的关系。代码中的`FastPow`函数（快速幂求逆元）是竞赛常用技巧，值得积累。

**题解三：星沐（踩坑提醒型）**
* **点评**：这份题解的“踩坑提醒”太实用了！作者提到“斯特林数的边界条件`s[0][0]=1`容易忘”——如果漏了这个，前几个测试点会直接WA。它的预处理代码每一步都取模，避免了溢出问题，还强调“开long long”（斯特林数的值会很大），这些都是实际编码中容易掉的“小坑”。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“难点”其实是“把题目转化为组合数学模型”，我们逐一拆解最容易卡壳的三个点：
</difficulty_intro>

1.  **关键点1：为什么选最高建筑当分水岭？**  
    * **分析**：最高建筑n是唯一“一定会被左右看到”的建筑，它把问题分成了“左边的A-1个可见建筑”和“右边的B-1个可见建筑”——没有它，左边和右边的可见建筑会互相干扰。这一步是“模型转化的突破口”，类似“解迷宫先找起点”。  
    * 💡 **学习笔记**：找“绝对确定的条件”（如最高建筑），是组合数学题的常用破局方法。

2.  **关键点2：为什么块对应圆排列？**  
    * **分析**：块的要求是“最高建筑在最前，其他随意”，而圆排列的数量正好是$(k-1)!$（k是块的大小）——比如k=3时，圆排列有2种，对应块的排列方式（最高建筑在最前，剩下两个可以交换）。斯特林数的递推式正好计算了“n个元素分成m个圆排列”的方案数，完美匹配题目中的“分块”需求。  
    * 💡 **学习笔记**：当问题涉及“固定一个元素，其他随意排列”时，要想到圆排列。

3.  **关键点3：组合数的意义是什么？**  
    * **分析**：A+B-2个块中，选A-1个放到左边（剩下的放右边）——左边的块要按“块内最高建筑从小到大”排列（否则会被挡住），右边的按“从大到小”排列，所以选择块的顺序不影响结果，只需要选哪些块去左边，这就是组合数的作用。  
    * 💡 **学习笔记**：组合数常用来解决“选多少个放到某一侧”的分配问题。

### ✨ 解题技巧总结
- **技巧1：预处理优先**：因为T（测试用例数）高达2e5，必须提前预处理斯特林数和组合数（O(n*K)时间，K是A+B的最大值200），这样每个询问可以O(1)回答。  
- **技巧2：模运算不要漏**：所有加法、乘法都要取模（mod=1e9+7），避免整数溢出。  
- **技巧3：边界条件要牢记**：斯特林数的`s[0][0]=1`（0个元素分成0个块，方案数1）、组合数的`C[i][0]=1`（选0个元素的方案数1），这些是递推的基础。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**——它综合了递推式预处理斯特林数和组合数的思路，代码简洁，能直接解决问题！
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码来自newbiechd的题解，用递推式预处理斯特林数和组合数，逻辑清晰，适合入门学习。
* **完整核心代码**：
    ```cpp
    #include <cstdio>
    #define R register
    #define L long long
    #define S 50000  // n的最大值
    #define N 200   // A+B的最大值（100+100）
    using namespace std;
    const int mod = 1e9 + 7;
    L s[S + 10][N + 10], c[N + 10][N + 10];  // s:斯特林数，c:组合数

    inline int read() {  // 快读函数，加速输入
        R int f = 0; R char ch = getchar();
        while (ch < 48 || ch > 57) ch = getchar();
        while (ch > 47 && ch < 58) f = (f << 3) + (f << 1) + (ch ^ 48), ch = getchar();
        return f;
    }

    int main() {
        R int t = read(), n, a, b, i, j;
        // 初始化斯特林数：s[0][0]=1，s[1][1]=1
        s[0][0] = s[1][1] = 1;
        // 递推斯特林数：s[i][j] = s[i-1][j-1] + (i-1)*s[i-1][j]
        for (i = 2; i <= S; ++i)
            for (j = 1; j <= N && j <= i; ++j)
                s[i][j] = (s[i-1][j-1] + s[i-1][j] * (i-1)) % mod;
        // 初始化组合数：c[i][0]=1
        for (i = 0; i <= N; ++i) c[i][0] = 1;
        // 递推组合数：c[i][j] = c[i-1][j-1] + c[i-1][j]
        for (i = 1; i <= N; ++i)
            for (j = 1; j <= N && j <= i; ++j)
                c[i][j] = (c[i-1][j-1] + c[i-1][j]) % mod;
        // 处理每个测试用例
        while (t--) {
            n = read(), a = read(), b = read();
            printf("%lld\n", s[n-1][a+b-2] * c[a+b-2][a-1] % mod);
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三步：① 用快读函数加速输入；② 预处理斯特林数和组合数（递推式）；③ 处理每个测试用例，直接输出“斯特林数×组合数”的结果。核心是**预处理**——把复杂的计算提前做，避免重复计算。

---

<code_intro_selected>
接下来看三个优质题解的“亮点代码片段”，学习不同的实现技巧！
</code_intro_selected>

**题解一：newbiechd（斯特林数递推）**
* **亮点**：用最直观的递推式计算斯特林数，适合理解原理。
* **核心代码片段**：
    ```cpp
    // 递推斯特林数：s[i][j] = s[i-1][j-1] + (i-1)*s[i-1][j]
    for (i = 2; i <= S; ++i)
        for (j = 1; j <= N && j <= i; ++j)
            s[i][j] = (s[i-1][j-1] + s[i-1][j] * (i-1)) % mod;
    ```
* **代码解读**：
    > 第i个元素有两种选择：① 单独成块（对应`s[i-1][j-1]`，前i-1个元素分成j-1块，第i个单独一块）；② 加入已有块（对应`(i-1)*s[i-1][j]`，前i-1个元素分成j块，第i个可以放到任意一个已有块的“旁边”——圆排列的特点）。  
* 💡 **学习笔记**：斯特林数的递推式直接对应“分块”的两种情况，记清楚这个递推式，就能解决大部分斯特林数问题。

**题解二：PigAunt（阶乘逆元求组合数）**
* **亮点**：用阶乘逆元计算组合数，适合n很大但k很小的情况（比如本题k≤200）。
* **核心代码片段**：
    ```cpp
    int FastPow(int x, int k) {  // 快速幂求逆元
        int res = 1;
        while (k > 0) {
            if (k & 1) res = (long long)res * x % MOD;
            x = (long long)x * x % MOD;
            k >>= 1;
        }
        return res;
    }

    void Init() {
        // 预处理阶乘和逆元
        fac[0] = 1;
        for (int i = 1; i <= K; i++) fac[i] = (long long)fac[i-1] * i % MOD;
        invFac[K] = FastPow(fac[K], MOD-2);
        for (int i = K-1; i >= 0; i--) invFac[i] = (long long)invFac[i+1] * (i+1) % MOD;
    }

    int C(int p, int q) {  // 组合数计算：C(p,q) = fac[p]/(fac[q]*fac[p-q])
        if (p < q) return 0;
        return (long long)fac[p] * invFac[q] % MOD * invFac[p-q] % MOD;
    }
    ```
* **代码解读**：
    > 组合数的公式是$C(p,q) = p!/(q!(p-q)!)$，但模运算中除法要换成“乘以逆元”。`FastPow`函数用快速幂求逆元（费马小定理：当MOD是质数时，a的逆元是a^(MOD-2)）。这种方法的优势是**预处理阶乘和逆元后，组合数可以O(1)计算**，适合k很小的情况。  
* 💡 **学习笔记**：当组合数的k很小（比如≤200），用递推式更简单；当k很大但p不大，用阶乘逆元更高效。

**题解三：星沐（边界条件提醒）**
* **亮点**：强调斯特林数的边界条件`s[0][0]=1`，避免WA。
* **核心代码片段**：
    ```cpp
    s[0][0] = 1;  // 重要！0个元素分成0个块，方案数1
    for (int i = 1; i <= 50000; ++i)
        for (int j = 1; j <= 200; ++j)
            s[i][j] = ((s[i-1][j-1] + s[i-1][j]*(i-1)) % mod) % mod;
    ```
* **代码解读**：
    > 如果漏掉`s[0][0]=1`，当i=1、j=1时，`s[1][1] = s[0][0] + 0*s[0][1] = 1`（正确）；如果没有`s[0][0]=1`，`s[1][1]`会是0，导致后续所有斯特林数计算错误。  
* 💡 **学习笔记**：边界条件是递推的“地基”，一定要记牢！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家“看清楚”斯特林数和组合数的作用，我设计了一个**8位像素风动画**——像玩FC游戏一样理解算法！
</visualization_intro>

  * **动画演示主题**：像素建筑师的“分块游戏”  
  * **核心演示内容**：展示“最高建筑分割→分块→选块到左右”的全过程，直观理解斯特林数和组合数的作用。
  * **设计思路简述**：用复古像素风格降低学习压力，用“块的移动”和“音效”强化记忆——比如分块时的“叮”声让你记住“斯特林数对应分块”，选块时的“咔嗒”声让你记住“组合数对应分配”。

  * **动画帧步骤与交互关键点**：
    1.  **场景初始化**：  
       - 屏幕背景是浅灰色（像草稿纸），中央是**紫色像素块**（代表最高建筑n），左右是待处理的“小方块”（代表其他建筑，颜色随机）。  
       - 下方控制面板有：「开始」「单步」「重置」按钮，以及“速度滑块”（控制动画快慢）。  
       - 播放8位风格的背景音乐（轻快的电子音）。
    2.  **最高建筑高亮**：  
       - 紫色块开始闪烁，旁边弹出文字气泡：“我是最高建筑，左右的建筑都听我的！”
    3.  **分块动画（斯特林数）**：  
       - 剩下的小方块开始“抱团”：比如3个红色方块聚成一堆，中间的黄色方块（块内最高）闪烁，旁边文字提示：“这是一个块，黄色是 leader！”  
       - 每形成一个块，播放“叮”的音效。最终形成A+B-2个块（比如A=2、B=2时，形成2个块）。
    4.  **选块到左右（组合数）**：  
       - 用**蓝色箭头**指向块，选择A-1个块（比如A=2时选1个），移动到左边；剩下的块移动到右边。  
       - 每选一个块，播放“咔嗒”的音效。
    5.  **结果展示**：  
       - 左边的块按“leader从小到大”排列，右边的按“leader从大到小”排列（避免被挡住）。  
       - 屏幕中央显示方案数，播放胜利音效（上扬的“叮~”）。
    6.  **交互功能**：  
       - 「单步」：每点一次，执行一步动画（比如分一个块、选一个块）。  
       - 「自动播放」：按滑块速度自动执行全部步骤。  
       - 「重置」：回到初始状态，重新演示。

  * **旁白提示**：
    - 分块时：“这些小方块聚成了一个块，黄色是块里最高的，能挡住其他方块！”  
    - 选块时：“我们选1个块放到左边，剩下的放右边——这就是组合数的作用！”  
    - 完成时：“总共有X种方案，就是斯特林数×组合数的结果！”

<visualization_conclusion>
通过这个动画，你能清楚看到“分块”（斯特林数）和“选块”（组合数）的过程——原来组合数学不是抽象的公式，而是“搭积木”一样的游戏！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“斯特林数+组合数”的模型后，我们可以解决更多“分块+分配”的问题！
</similar_problems_intro>

  * **通用思路迁移**：
    - 斯特林数常用于“将n个元素分成m个非空环/块”的问题（比如“安排n个人坐m张圆桌”）；  
    - 组合数常用于“从m个元素中选k个分配到某一侧”的问题（比如“选k个同学去左边排队”）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1399 广义斯特林数**  
          * 🗣️ **推荐理由**：这道题是斯特林数的“进阶版”，要求计算广义斯特林数，能帮你巩固斯特林数的递推思路。
    2.  **洛谷 P2398 GCD SUM**  
          * 🗣️ **推荐理由**：这道题涉及组合数学中的“因数分解”和“求和技巧”，能帮你锻炼“将问题转化为数学模型”的能力。
    3.  **洛谷 P3400 仓鼠的数学题**  
          * 🗣️ **推荐理由**：这道题结合了斯特林数和多项式乘法，是组合数学的综合练习，适合提升难度。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的“踩坑经验”比公式更珍贵，我们来看看大家的教训：
</insights_intro>

> **参考经验 (来自星沐)**：“我一开始漏了`s[0][0]=1`，结果前几个测试点全WA了！后来才明白，斯特林数的边界条件是递推的基础。”  
> **点评**：这个经验太重要了！很多同学学斯特林数时会忽略边界条件，导致整个递推错误。记住：`s[0][0]=1`（0个元素分成0个块，方案数1）、`s[n][0]=0`（n个元素分成0个块，不可能）。

> **参考经验 (来自newbiechd)**：“我一开始用了组合数的公式计算，但发现n很大时会溢出，后来改成递推式就好了！”  
> **点评**：当组合数的k很小（比如≤200），递推式比公式更安全——因为递推式每一步都取模，不会溢出。


<conclusion>
本次关于「FJOI2016建筑师」的分析就到这里！这道题的核心是“将建筑分块，用斯特林数算分块方案，用组合数算分配方案”。记住：组合数学不是“背公式”，而是“找模型”——找到问题中的“块”“分配”等关键特征，就能对应到合适的数学工具。  

下次遇到组合数学题，试试先找“绝对确定的条件”（比如最高建筑），再想“分块”“排列”的模型——你会发现，组合数学其实很有趣！💪
</conclusion>

---
处理用时：150.71秒
# 题目信息

# [NOIP 2016 提高组] 天天爱跑步

## 题目背景

NOIP2016 提高组 D1T2

## 题目描述

小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。

这个游戏的地图可以看作一棵包含 $n$ 个结点和 $n-1$ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。

现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）

小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $w_j$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $w_j$ 秒也正好到达了结点 $j$。小 C 想知道每个观察员会观察到多少人?

注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一 段时间后再被观察员观察到。 即对于把结点 $j$ 作为终点的玩家：若他在第 $w_j$ 秒前到达终点，则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $w_j$ 秒到达终点，则在结点 $j$ 的观察员可以观察到这个玩家。


## 说明/提示

**样例 1 说明**

对于 $1$ 号点，$w_i=0$，故只有起点为 $1$ 号点的玩家才会被观察到，所以玩家 $1$ 和玩家 $2$ 被观察到，共有 $2$ 人被观察到。

对于 $2$ 号点，没有玩家在第 $2$ 秒时在此结点，共 $0$ 人被观察到。

对于 $3$ 号点，没有玩家在第 $5$ 秒时在此结点，共 $0$ 人被观察到。

对于 $4$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $5$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $6$ 号点，玩家 $3$ 被观察到，共 $1$ 人被观察到。

**子任务**

每个测试点的数据规模及特点如下表所示。 

提示：数据范围的个位上的数字可以帮助判断是哪一种数据类型。

| 测试点编号 | $n=$ | $m=$ | 约定 |
| :--------: | :----: | :----: | :----: |
|     $1\sim 2$      |  $991$   |  $991$   | 所有人的起点等于自己的终点，即 $\forall i,\ s_i=t_i$  |
|     $3\sim 4$      |  $992$   |  $992$   | 所有 $w_j=0$  |
|     $5$      |  $993$   |  $993$   | 无  |
|     $6\sim 8$      |  $99994$   |  $99994$   | $\forall i\in[1,n-1]$，$i$ 与 $i+1$ 有边。即树退化成 $1,2,\dots,n$ 按顺序连接的链  |
|     $9\sim 12$      |  $99995$   |  $99995$   | 所有 $s_i=1$  |
|     $13\sim 16$      |  $99996$   |  $99996$   | 所有 $t_i=1$  |
|     $17\sim 19$      |  $99997$   |  $99997$   | 无  |
|     $20$      |  $299998$   |  $299998$   | 无  |



**提示**

（提示：由于原提示年代久远，不一定能完全反映现在的情况，现在已经对该提示做出了一定的修改，提示的原文可以在[该剪贴板](https://www.luogu.com.cn/paste/3fneb8m6)查看）

在最终评测时，调用栈占用的空间大小不会有单独的限制，但在我们的工作环境中默认会有 $1 \text{MiB}$ 的限制。 这可能会引起**函数调用层数较多时，程序发生栈溢出崩溃**，程序中**较深层数的递归**往往会导致这个问题。如果你的程序需要用到较大的栈空间，请务必注意该问题。

我们可以使用一些方法修改调用栈的大小限制。

- Linux

我们可以在终端中输入下列命令：`ulimit -s 1048576`。此命令的意义是，将调用栈的大小限制修改为 $1048576\text{KiB}=1 \text{GiB}$。

例如，对于如下程序 `sample.cpp`：

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1000005];
void dfs(int a){
	if(a == 0){
		f[a] = 0;
		return;
	}
	dfs(a - 1);
	f[a] = f[a - 1] + 1;
}
int main(){
	dfs(1000000);
	return 0;
}
```

将上述源代码用命令 `g++ sample.cpp -o sample` 编译为可执行文件 `sample` 后，使用 `./sample` 执行程序。

如果在没有使用命令 `ulimit -s 1048576` 的情况下运行该程序，`sample` 会因为栈溢出而崩溃；如果使用了上述命令后运行该程序，该程序则不会崩溃。

特别地，当你打开多个终端时，它们并不会共享该命令，你需要分别对它们运行该命令。

请注意，调用栈占用的空间会计入总空间占用中，和程序其他部分占用的内存共同受到内存限制。

- Windows

如果你使用 Windows 下的 Dev-C++，请选择 `工具-编译选项` 并在如下区域填入以下命令 `-Wl,--stack=1073741824`，填入后注意确认“编译时加入以下命令的”的框是**已勾选**状态。

此处 `1073741824` 的单位是 $\text{B/Bytes}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)  ![](https://cdn.luogu.com.cn/upload/image_hosting/zvrzkyq5.png)

## 样例 #1

### 输入

```
6 3
2 3
1 2 
1 4 
4 5 
4 6 
0 2 5 1 2 3 
1 5 
1 3 
2 6 ```

### 输出

```
2 0 0 1 1 1 ```

## 样例 #2

### 输入

```
5 3 
1 2 
2 3 
2 4 
1 5 
0 1 0 3 0 
3 1 
1 4
5 5 ```

### 输出

```
1 2 1 0 1 ```

# AI分析结果


### 题目分析
本题是 NOIP2016 提高组的经典题目，考察树上路径统计问题。题目要求计算每个观察员在特定时间点能观察到的玩家数量。核心思路是将每个玩家的路径拆分为上行（起点到 LCA）和下行（LCA 到终点）两部分，分别处理。通过树上差分和桶计数技术高效统计满足条件的玩家数量。

### 解题思路
1. **路径拆分与条件分析**：
   - 对于上行路径（起点 $s_i$ 到 LCA）：节点 $j$ 能观察到玩家当且仅当 $dep[s_i] = dep[j] + w_j$。
   - 对于下行路径（LCA 到终点 $t_i$）：节点 $j$ 能观察到玩家当且仅当 $dep[s_i] - 2 \times dep[\text{LCA}] = w_j - dep[j]$。

2. **树上差分与桶计数**：
   - 使用两个全局桶 `b1` 和 `b2` 分别记录上行和下行路径的贡献。
   - `b1` 索引为 $dep[s_i]$，对应上行条件。
   - `b2` 索引为 $w_j - dep[j]$（加偏移量避免负数），对应下行条件。
   - 通过 DFS 遍历树，在进入节点时记录桶的初始值，递归子节点后计算差值得到该节点的答案。

3. **重复计数处理**：
   - LCA 节点可能同时满足上行和下行条件，导致重复计数。若 $dep[\text{LCA}] + w_{\text{LCA}} = dep[s_i]$，则预先将 LCA 节点的答案减 1。

### 核心算法步骤
1. **预处理**：
   - 使用 DFS 计算节点深度和倍增数组（用于 LCA 查询）。
   - 建图并读入观察时间 $w_j$。

2. **处理玩家路径**：
   - 对每个玩家路径 $(s_i, t_i)$：
     - 计算 LCA。
     - 在上行起点 $s_i$ 添加上行标记（值 = $dep[s_i]$），在 LCA 添加上行移除标记。
     - 在下行终点 $t_i$ 添加下行标记（值 = $dep[s_i] - 2 \times dep[\text{LCA}]$），在 LCA 添加下行移除标记。
     - 若 LCA 满足上行条件，则其答案减 1。

3. **DFS 统计答案**：
   - 从根节点开始 DFS：
     - 记录当前桶中相关值（$dep[j] + w_j$ 和 $w_j - dep[j]$ 的计数）。
     - 处理当前节点的添加操作（更新桶）。
     - 递归子节点。
     - 处理当前节点的移除操作（恢复桶）。
     - 计算当前节点的答案（桶的差值）。

### 代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 3e5 + 10;
const int OFFSET = 300000;

vector<int> G[MAXN];
int dep[MAXN], fa[MAXN][20], w[MAXN], ans[MAXN];
int b1[MAXN * 2], b2[MAXN * 2]; // 桶，b2 使用偏移量避免负数
vector<int> add1[MAXN], del1[MAXN]; // 上行标记的添加和移除
vector<int> add2[MAXN], del2[MAXN]; // 下行标记的添加和移除

// 预处理深度和倍增数组
void dfs_pre(int u, int parent) {
    dep[u] = dep[parent] + 1;
    fa[u][0] = parent;
    for (int i = 1; i <= 18; i++) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
    }
    for (int v : G[u]) {
        if (v == parent) continue;
        dfs_pre(v, u);
    }
}

// LCA 查询
int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = 18; i >= 0; i--) {
        if (dep[u] - (1 << i) >= dep[v]) {
            u = fa[u][i];
        }
    }
    if (u == v) return u;
    for (int i = 18; i >= 0; i--) {
        if (fa[u][i] != fa[v][i]) {
            u = fa[u][i];
            v = fa[v][i];
        }
    }
    return fa[u][0];
}

// DFS 统计答案
void dfs(int u, int parent) {
    // 记录进入时的桶值
    int tmp1 = b1[dep[u] + w[u]];
    int tmp2 = b2[w[u] - dep[u] + OFFSET];
    
    // 处理当前节点的添加操作
    for (int x : add1[u]) b1[x]++;
    for (int x : add2[u]) b2[x + OFFSET]++;
    
    // 递归子节点
    for (int v : G[u]) {
        if (v == parent) continue;
        dfs(v, u);
    }
    
    // 处理当前节点的移除操作
    for (int x : del1[u]) b1[x]--;
    for (int x : del2[u]) b2[x + OFFSET]--;
    
    // 计算当前节点的答案
    ans[u] += (b1[dep[u] + w[u]] - tmp1) + (b2[w[u] - dep[u] + OFFSET] - tmp2);
}

int main() {
    int n, m;
    scanf("%d%d", &n, &m);
    
    // 建图
    for (int i = 1; i < n; i++) {
        int u, v;
        scanf("%d%d", &u, &v);
        G[u].push_back(v);
        G[v].push_back(u);
    }
    
    // 读入观察时间
    for (int i = 1; i <= n; i++) {
        scanf("%d", &w[i]);
    }
    
    // 预处理
    dfs_pre(1, 0);
    
    // 处理玩家路径
    for (int i = 1; i <= m; i++) {
        int s, t;
        scanf("%d%d", &s, &t);
        int p = lca(s, t);
        
        // 上行标记（s -> LCA）
        add1[s].push_back(dep[s]);
        del1[p].push_back(dep[s]);
        
        // 下行标记（LCA -> t）
        int val = dep[s] - 2 * dep[p];
        add2[t].push_back(val);
        del2[p].push_back(val);
        
        // 处理 LCA 重复计数
        if (dep[p] + w[p] == dep[s]) {
            ans[p]--;
        }
    }
    
    // DFS 统计答案
    dfs(1, 0);
    
    // 输出结果
    for (int i = 1; i <= n; i++) {
        printf("%d ", ans[i]);
    }
    return 0;
}
```

### 算法分析
- **时间复杂度**：$O((n + m) \log n)$，其中 LCA 查询 $O(\log n)$，DFS 遍历 $O(n)$。
- **空间复杂度**：$O(n \log n + m)$，主要来自倍增数组和存储标记的向量。

此解法高效利用了树上差分和桶计数技术，通过路径拆分和条件转换，将问题转化为子树统计问题，适合处理大规模树上路径查询。

---
处理用时：215.89秒
# 题目信息

# 富金森林公园

## 题目描述

博艾的富金森林公园里有一个长长的富金山脉，山脉是由一块块巨石并列构成的，编号从 $1$ 到 $N$ 。每一个巨石有一个海拔高度。而这个山脉又在一个盆地中，盆地里可能会积水，积水也有一个海拔高度，所有**严格低于**这个海拔高度的巨石，就会在水面下隐藏。


由于地壳运动，巨石的海拔高度可能会随时变化，每次一块的巨石会变成新的海拔高度。当然，水面的高度也会随时发生变化。


因为有这样奇妙的地质奇观，吸引了很多游客来游玩。uim 作为一个游客，可以告诉你此时水位海拔，你得告诉他，能看到有几个连续露出水面的部分。（与水面持平我们也认为是露出）

## 说明/提示

$10\%$ 的数据，$N,M<=2000$。

另外 $30\%$ 的数据， 只有 `1` 的询问。

$100\%$ 的数据，$1<=N,M<=200000,1<=A_i,B_j,D_j<=10^9$，一定有 `1` 询问。


## 样例 #1

### 输入

```
5 4
8 6 3 5 4
1 5
2 4 1
1 5
1 3```

### 输出

```
2
1
2```

# AI分析结果


### 💡 Kay的C++算法解析：富金森林公园 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`离散化+树状数组维护差分` (编程技巧应用)

🗣️ **初步分析**：
> 解决"富金森林公园"的关键在于将连续段计数转化为**段起点计数**。想象山脉像一排起伏的波浪，当水位下降时，每个新露出的"波峰起点"会形成新岛屿。我们维护每个高度x对应的段起点数量：当水位x满足`a_{i-1} < x ≤ a_i`时，位置i成为新起点。  
> 
> - **核心思路**：用树状数组维护离散化后的高度区间，每个位置i在区间`(h[i-1], h[i]]`上+1。查询时单点求和即得段数
> - **难点**：修改位置i的高度需同步更新位置i和i+1的贡献区间
> - **可视化设计**：像素动画将展示山脉高度条（8位色块），树状数组条形图随操作动态变化。修改时旧区间红色闪烁，新区间绿色填充，单步执行伴"嘀"声，查询成功奏"叮"声

---

#### 2. 精选优质题解参考
**题解一 (来源：zyc2003)**
* **亮点**：思路直击本质——段起点计数。代码简洁高效（树状数组维护差分），离散化处理优雅。变量命名规范（h[]高度数组，tree[]树状数组），边界处理严谨（h[0]=0特殊处理）。复杂度O((n+m)log(n+m))，竞赛实用性强

**题解二 (来源：s_r_f)**
* **亮点**：创新性公式`连通块数=点数-边数`，数学建模巧妙。用两个树状数组分别维护`a_i≥x`的个数和`min(a_i,a_{i+1})≥x`的相邻对数，组合数学思想启发性强

**题解三 (来源：kczno1)**
* **亮点**：独特公式`ans=(max≥x相邻对数 - min≥x相邻对数)/2`，代码极简（仅30行）。树状数组操作精炼，虽公式理解门槛稍高，但实现效率卓越

---

#### 3. 核心难点辨析与解题策略
1. **难点：段起点条件的动态维护**  
   *分析*：位置i成为起点当且仅当`a_{i-1} < x ≤ a_i`。修改高度时需同步更新前后位置的贡献区间，如修改位置i：  
   ```markdown
   1. 撤销i的旧区间 (h[i-1], h[i]]
   2. 撤销i+1的旧区间 (h[i], h[i+1]]
   3. 更新h[i]后重新添加新区间
   ```
   *💡 学习笔记*：每个位置贡献区间是动态的"责任范围"

2. **难点：离散化边界处理**  
   *分析*：需将0（虚拟高度）加入离散化，确保位置1的区间`(0, h[1]]`有效。优质题解用`h[0]=0`统一处理边界，避免特判  
   *💡 学习笔记*：虚拟边界值能简化边界条件

3. **难点：树状数组的差分维护**  
   *分析*：区间`(L,R]`的操作为：`add(L+1,1); add(R+1,-1)`。查询时`ask(x)`即前缀和  
   *💡 学习笔记*：差分数组将区间加转化为两点操作

✨ **解题技巧总结**  
- **技巧1：画图辅助分析** → 用网格图模拟水位变化理解段起点产生  
- **技巧2：离散化四步法** → 收集值→排序去重→映射→逆映射  
- **技巧3：模块化撤销/添加** → 修改时先撤旧贡献再添新贡献  

---

#### 4. C++核心代码实现赏析
**通用核心实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 400005;

// 离散化+树状数组模板
struct BIT {
    int tree[MAXN], len;
    inline int lowbit(int x) { return x & -x; }
    void add(int x, int v) {
        for (; x <= len; x += lowbit(x)) tree[x] += v;
    }
    int query(int x) {
        int s = 0;
        for (; x; x -= lowbit(x)) s += tree[x];
        return s;
    }
} T;

int n, m, h[MAXN], mp[MAXN<<1], cnt;
void discretize(int a[], int &len) {
    sort(mp + 1, mp + cnt + 1);
    len = unique(mp+1, mp+cnt+1) - mp - 1;
    auto get = [&](int x) { 
        return lower_bound(mp+1, mp+len+1, x) - mp; 
    };
    for (int i = 1; i <= n; i++) h[i] = get(a[i]);
}

int main() {
    scanf("%d%d", &n, &m);
    mp[++cnt] = 0; // 关键：添加虚拟高度0
    for (int i = 1; i <= n; i++) {
        scanf("%d", &h[i]);
        mp[++cnt] = h[i];
    }
    // 处理操作和离散化
    discretize(h, T.len);

    // 初始化贡献
    h[0] = 1; // mp[1]=0的映射值
    for (int i = 1; i <= n; i++) {
        if (h[i-1] < h[i]) {
            T.add(h[i-1]+1, 1);
            T.add(h[i]+1, -1);
        }
    }
    // 处理查询和修改
    while (m--) {
        int op, p, x; 
        scanf("%d", &op);
        if (op == 1) {
            scanf("%d", &x);
            x = lower_bound(mp+1, mp+T.len+1, x) - mp;
            printf("%d\n", T.query(x));
        } else {
            scanf("%d%d", &p, &x);
            // 撤销旧贡献
            if (h[p-1] < h[p]) T.add(h[p-1]+1, -1), T.add(h[p]+1, 1);
            if (p < n && h[p] < h[p+1]) T.add(h[p]+1, -1), T.add(h[p+1]+1, 1);
            // 更新高度
            h[p] = lower_bound(mp+1, mp+T.len+1, x) - mp;
            // 添加新贡献
            if (h[p-1] < h[p]) T.add(h[p-1]+1, 1), T.add(h[p]+1, -1);
            if (p < n && h[p] < h[p+1]) T.add(h[p]+1, 1), T.add(h[p+1]+1, -1);
        }
    }
}
```

**代码解读概要**：  
1. **离散化处理**：收集所有高度（含0），排序去重后映射  
2. **树状数组维护**：每个位置i在`(h[i-1], h[i]]`上差分+1  
3. **修改操作**：先撤销位置i和i+1的旧贡献，更新高度后重新添加  

---

#### 5. 算法可视化：像素动画演示
> **主题**：8位像素风"山脉探险"  
> **核心演示**：树状数组差分维护过程  
> **交互设计**：  
> ```mermaid
> graph LR
>    A[开始] --> B[初始化山脉]
>    B --> C[显示贡献区间]
>    C --> D{用户操作}
>    D -->|查询| E[高亮水位x的查询结果]
>    D -->|修改| F[红色闪烁旧区间]
>    F --> G[更新高度]
>    G --> H[绿色填充新区间]
> ```
> **关键帧设计**：  
> 1. **场景初始化**：16色调色盘，山脉用渐变绿柱，树状数组用蓝色条形图  
> 2. **修改动画**：  
>    - 旧区间红色闪烁（音效：咔嚓声）  
>    - 新高度柱绿色脉冲  
>    - 新区间绿色填充（音效：叮咚声）  
> 3. **查询演示**：水位线红色扫描，露出段黄框标记，树状数组对应条橙色高亮  
> 4. **自动演示**：AI自动执行操作序列，速度可调滑块  

---

#### 6. 拓展练习与相似问题思考
1. **技巧迁移**：  
   - 区间贡献思想 → 解决[CF703D]频率查询问题  
   - 离散化+树状数组 → 处理[P1972]HH的项链  
   - 动态维护拓扑关系 → 应用于[P1908]逆序对  

2. **洛谷推荐**：  
   - P1908 逆序对 → 树状数组基础应用  
   - P1972 [SDOI2009]HH的项链 → 离线查询+树状数组  
   - P3368 【模板】树状数组2 → 差分技巧强化  

---

#### 7. 学习心得与经验分享
> **来自zyc2003的经验**："修改时需同步更新相邻位置贡献，我最初忽略了位置i+1，导致WA。通过单步调试观察树状数组状态，最终定位问题。"  
> **Kay总结**：动态数据结构中，**注意连锁反应**！修改前画图梳理依赖关系，调试时输出中间状态可快速定位错误  

---

> 本次解析就到这里，记住：算法学习像登山，看清路径再迈步！下次挑战再见！💪

---
处理用时：335.65秒
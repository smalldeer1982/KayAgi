# 题目信息

# [AHOI2017/HNOI2017] 单旋

## 题目描述

H 国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了 H 国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数” 来企图毁灭 H 国。“卡” 给 H 国的人洗脑说，splay 如果写成单旋的，将会更快。“卡”称“单旋 splay”为“spaly”。虽说他说的很没道理，但还是有 H 国的人相信了，小 H 就是其中之一，spaly 马上成为他的信仰。而 H 国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由 $m$（不超过 $10^5$）个操作构成，他知道这样的数据肯定打垮 spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作所需要的实际代价的任务就交给你啦。

数据中的操作分为 $5$ 种：

1. 插入操作：向当前非空 spaly 中插入一个关键码为 $key$ 的新孤立节点。插入方法为，先让 $key$ 和根比较，如果 $key$ 比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，$key$ 比当前子树根 $x$ 小，而 $x$ 的左子树为空，那就让 $key$ 成为 $x$ 的左孩子；或者 $key$ 比当前子树根 $x$ 大，而 $x$ 的右子树为空，那就让 $key$ 成为 $x$ 的右孩子。该操作的代价为：插入后，$key$ 的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度” 的解释见末尾对 spaly 的描述。）

2. 单旋最小值：将 spaly 中关键码最小的元素 $x \min$ 单旋到根。操作代价为：单旋前 $x \min$ 的深度。（对于单旋操作的解释见末尾对 spaly 的描述。）

3. 单旋最大值：将 spaly 中关键码最大的元素 $x \max$ 单旋到根。操作代价为：单旋前 $x \max$ 的深度。

4. 单旋删除最小值：先执行 $2$ 号操作，然后把根删除。由于 $2$ 号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同 $2$ 号操作。

5. 单旋删除最大值：先执行 $3$ 号操作，然后把根删除。操作代价同 $3$ 号操作。

![](https://cdn.luogu.com.cn/upload/pic/5106.png)

对于不是 H 国的人，你可能需要了解一些 spaly 的知识，才能完成国王的任务：

1. spaly 是一棵二叉树，满足对于任意一个节点 $x$，它如果有左孩子 $lx$，那么 $lx$ 的关键码小于 $x$ 的关键码。如果有右孩子 $rx$，那么 $rx$ 的关键码大于 $x$ 的关键码。

2. 一个节点在 spaly 的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。

3. 单旋操作是对于一棵树上的节点 $x$ 来说的。一开始，设 $f$ 为 $x$ 在树上的父亲。如果 $x$ 为 $f$ 的左孩子，那么执行 $zig (x)$ 操作（如上图中，左边的树经过 $zig (x)$ 变为了右边的树）, 否则执行 $zag (x)$ 操作（在上图中，将右边的树经过 $zag (f)$ 就变成了左边的树）。每当执行一次 $zig (x)$ 或者 $zag (x)$,$x$ 的深度减小 $1$，如此反复，直到 $x$ 为根。总之，单旋 $x$ 就是通过反复执行 $zig$ 和 $zag$ 将 $x$ 变为根。

## 说明/提示

$20 \%$ 的数据满足： $1 \leq m \leq 1000$。

另外 $30\%$ 的数据满足：不存在 $4,5$ 操作。

$100\%$ 的数据满足：$1 \leq m \leq 10^5,1 \leq key \leq 10^9$。 所有出现的关键码互不相同。 任何一个非插入操作，一定保证树非空。 在未执行任何操作之前，树为空。

## 样例 #1

### 输入

```
5
1 2
1 1
1 3
4 
5```

### 输出

```
1 
2 
2
2 
2```

# AI分析结果


# 💡 Kay的C++算法解析：[AHOI2017/HNOI2017] 单旋 深入学习指南 💡

> 大家好，我是Kay！今天我们来一起探索这道有趣的题目——**单旋**。这道题要求我们模拟一种特殊的二叉搜索树操作，通过分析题解，我将带大家理解核心算法、解题技巧，并设计一个生动的像素动画演示方案！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数据结构模拟` + `区间维护`

🗣️ **初步分析**：
> 这道题的关键在于**用数据结构模拟另一种数据结构**。想象一下，你正在用积木搭建一个塔（线段树/树状数组），但这个塔要模拟另一个会变形的塔（Spaly树）的变化。核心思路是：
> - 用**离散化**处理大范围键值
> - 用**set**快速查找前驱/后继
> - 用**树状数组**维护节点深度变化
> - 用**数组**记录父子关系
> 
> **难点在于旋转操作时的深度更新**：单旋最值时，除了被旋转节点的子树外，其他节点深度+1；删除时整棵树深度-1。在可视化中，我们会用**颜色渐变**表示深度变化，**高亮显示**旋转路径，并用**像素方块**动态展示树结构变化。

---

## 2. 精选优质题解参考

> 我从思路清晰性、代码规范性和算法效率等角度，精选了3份优质题解：

**题解一：老K（线段树+set）**
* **点评**：
  思路直击要害——插入时选择深度更大的前驱/后继作为父节点；旋转时用区间加减模拟深度变化。代码中：
  - **亮点**：用`set`找前驱后继，线段树区间操作高效（$O(\log n)$）
  - **规范**：变量命名清晰（`fa[]`, `ch[][]`）
  - **技巧**：旋转后巧妙处理子树区间深度不变

**题解二：DOTime（树状数组+set）**
* **点评**：
  更轻量的实现：
  - **亮点**：树状数组替代线段树，常数更优
  - **清晰**：将旋转操作总结为“嫁接子树+深度偏移”
  - **实践**：边界处理严谨（如空树检测）

**题解三：shadowice1984（权值线段树）**
* **点评**：
  全面而深入：
  - **亮点**：显式维护父子指针，深度更新公式严谨
  - **优化**：离散化后值域压缩提升效率
  - **启发**：对旋转后子树位置的精确论证

---

## 3. 核心难点辨析与解题策略

> 解决本题需突破三大难点：

1.  **难点1：插入位置确定**
    * **分析**：新节点必须挂在前驱/后继中深度更大的节点下。用`set`在$O(\log n)$内找到邻居，比较深度决定位置
    * 💡 **学习笔记**：二叉搜索树中，键值相邻节点必为父子关系！

2.  **难点2：旋转的深度维护**
    * **分析**：旋转最小值时，整棵树深度+1，但其右子树（原根）深度不变。通过`[x+1, fa[x]-1]`区间减1抵消
    * 💡 **学习笔记**：树状数组的差分技巧是区间更新的利器

3.  **难点3：删除后的深度重置**
    * **分析**：删除根节点后整棵树深度-1，需同步更新树状数组，并重置根为原子树
    * 💡 **学习笔记**：父子指针的修改需与深度更新严格同步

### ✨ 解题技巧总结
- **技巧1：离散化压缩空间**  
  10^9键值范围→10^5操作数，离散化是必备技能
- **技巧2：数据结构协同**  
  `set`查邻居，树状数组管深度，数组存关系——各司其职
- **技巧3：旋转公式化**  
  单旋最值=嫁接子树+深度偏移+根重置，熟记此流程

---

## 4. C++核心代码实现赏析

### 本题通用核心实现（综合题解思路）
```cpp
#include <set>
#include <cstdio>
#include <algorithm>
using namespace std;

const int MAXN = 1e5 + 5;
int n, cnt, root;
int op[MAXN], key[MAXN], disc[MAXN];
set<int> s;
int fa[MAXN], ch[MAXN][2];
int tree[MAXN]; // 树状数组（差分）

// 树状数组操作
void update(int pos, int val) {
    for (; pos <= cnt; pos += pos & -pos) 
        tree[pos] += val;
}

void update_range(int l, int r, int val) {
    update(l, val);
    if (r < cnt) update(r + 1, -val);
}

int query(int pos) {
    int res = 0;
    for (; pos; pos -= pos & -pos)
        res += tree[pos];
    return res;
}

int main() {
    scanf("%d", &n);
    // 离散化处理
    for (int i = 1; i <= n; i++) {
        scanf("%d", &op[i]);
        if (op[i] == 1) {
            scanf("%d", &key[i]);
            disc[++cnt] = key[i];
        }
    }
    sort(disc + 1, disc + cnt + 1);
    cnt = unique(disc + 1, disc + cnt + 1) - disc - 1;
    
    for (int i = 1; i <= n; i++) {
        if (op[i] == 1) 
            key[i] = lower_bound(disc + 1, disc + cnt + 1, key[i]) - disc;
        
        switch (op[i]) {
            case 1: {
                int x = key[i];
                if (s.empty()) {
                    root = x;
                    update_range(x, x, 1); // 深度=1
                    s.insert(x);
                    puts("1");
                } else {
                    auto it = s.lower_bound(x);
                    int pre = (it != s.begin()) ? *prev(it) : -1;
                    int suc = (it != s.end()) ? *it : -1;
                    int p = -1;
                    
                    if (pre == -1) p = suc;
                    else if (suc == -1) p = pre;
                    else p = (query(pre) > query(suc)) ? pre : suc;
                    
                    fa[x] = p;
                    ch[p][x > p] = x; // 左子/右子
                    update_range(x, x, query(p) + 1); // 深度=父深度+1
                    s.insert(x);
                    printf("%d\n", query(x));
                }
                break;
            }
            case 2: {
                int x = *s.begin();
                if (x == root) {
                    puts("1");
                    break;
                }
                int ans = query(x);
                int f = fa[x], r = ch[x][1];
                
                update_range(1, cnt, 1); // 全局深度+1
                if (x + 1 <= f - 1) 
                    update_range(x + 1, f - 1, -1); // 右子树深度不变
                update_range(x, x, 1 - query(x)); // 重置x深度=1
                
                ch[f][0] = r;
                if (r) fa[r] = f;
                ch[x][1] = root;
                fa[root] = x;
                fa[x] = 0;
                root = x;
                
                printf("%d\n", ans);
                break;
            }
            // 其他操作类似（篇幅限制省略）
        }
    }
    return 0;
}
```

### 题解片段赏析

**题解一：插入位置选择（老K）**
```cpp
auto it = s.lower_bound(x);
int pre = (it != s.begin()) ? *prev(it) : -1;
int suc = (it != s.end()) ? *it : -1;
int p = (query(pre) > query(suc)) ? pre : suc; // 选深度更大的父节点
```
> **解读**：用`lower_bound`找严格后继，`prev(it)`取前驱。深度比较决定父节点  
> **学习笔记**：`set`的有序性保障了邻居节点在树中相邻

**题解二：旋转深度更新（DOTime）**
```cpp
update_range(1, cnt, 1); // 全局+1
if (x + 1 <= f - 1) 
    update_range(x + 1, f - 1, -1); // 右子树抵消
```
> **解读**：通过区间减1将右子树深度还原，避免双重增加  
> **学习笔记**：树状数组差分实现$O(\log n)$复杂度的区间更新

---

## 5. 算法可视化：像素动画演示

### 设计理念
> 采用**8位机像素风格**，用色块表示节点，动态展示深度变化。仿《铲子骑士》复古UI，让算法过程如同闯关游戏！

### 动画脚本
1. **场景初始化**  
   - 屏幕底部：控制面板（开始/暂停/单步）
   - 主区域：网格状键值轴，节点显示为16x16像素方块
   - 初始状态：空树，显示"Ready to Spaly!"

2. **插入操作（像素动画）**  
   ```markdown
   - 新节点闪烁出现（黄色）
   - 箭头从前驱/后继指向它（蓝色箭头）
   - 深度标签更新：`D=父深度+1`
   - 音效：短促“嘀”声
   ```

3. **单旋最小值（核心演示）**  
   ```markdown
   - 最小值节点变红闪烁
   - 右子树方块平移至父节点下方（绿色轨迹）
   - 原根节点移至最小值右侧（橙色轨迹）
   - 非子树区域色块变深（深度+1）
   - 音效：连续“哔-哔-哔”升级音
   ```

4. **删除操作**  
   ```markdown
   - 根节点爆炸特效（像素粒子）
   - 子树节点上移（深度-1）
   - 新根显示皇冠图标
   - 音效：“轰”爆炸声 + 金币声
   ```

### 交互设计
- **单步执行**：按一次键执行一步操作
- **速度滑块**：调整动画速度（慢速学习/快速演示）
- **AI演示模式**：自动播放全过程，如贪吃蛇AI寻路

> 通过**颜色变化**（深度）、**位置移动**（旋转）、**粒子特效**（删除）直观呈现算法核心，配合8-bit音效增强记忆点！

---

## 6. 拓展练习与相似问题

### 相似逻辑问题
1. **二叉搜索树动态维护**：POJ 3481（双端优先队列）
2. **区间统计+结构修改**：Luogu P3380（二逼平衡树）
3. **深度维护问题**：CodeForces 786C（子树深度查询）

### 洛谷推荐
1. **P3369 【普通平衡树】**  
   → 巩固BST基础操作，理解旋转本质
2. **P3380 【二逼平衡树】**  
   → 提升区间统计+树结构维护能力
3. **P6136 【模板】普通平衡树（数据加强版）**  
   → 挑战高效实现综合树操作

---

## 7. 学习心得与经验分享

> **来自题解作者的调试经验**：  
> *“我在处理旋转深度更新时，忽略了空区间导致RE。切记：`update_range`前务必检查`l<=r`！”*  
>   
> **Kay的总结**：  
> 边界检查是代码健壮性的关键！建议：
> - 用`if (l <= r)`保护区间操作
> - 单步调试模拟树结构变化
> - 小数据手算验证

---

> 本次解析就到这里！记住：**数据结构是算法的积木**，理解每块积木的作用，你就能搭建出任何想要的程序城堡！下次见~ 🚀

---
处理用时：392.33秒
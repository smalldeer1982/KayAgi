# 题目信息

# [AHOI2017/HNOI2017] 影魔

## 题目背景

影魔，奈文摩尔，据说有着一个诗人的灵魂。事实上，他吞噬的诗人灵魂早已成千上万。

千百年来，他收集了各式各样的灵魂，包括诗人、牧师、帝王、乞丐、奴隶、罪人，当然，还有英雄。

每一个灵魂，都有着自己的战斗力，而影魔，靠这些战斗力提升自己的攻击。

## 题目描述

奈文摩尔有 $n$ 个灵魂，他们在影魔宽广的体内可以排成一排，从左至右标号 $1$ 到 $n$。第 $i$ 个灵魂的战斗力为 $k_i$，灵魂们以点对的形式为影魔提供攻击力。对于灵魂对 $i, j\ (i<j)$ 来说，若不存在 $k_s\ (i<s<j)$ 大于 $k_i$ 或者 $k_j$，则会为影魔提供 $p_1$ 的攻击力。另一种情况，令 $c$ 为 $k_{i + 1}, k_{i + 2}, \cdots, k_{j -1}$ 的最大值，若 $c$ 满足：$k_i < c < k_j$，或者 $k_j < c < k_i$，则会为影魔提供 $p_2$ 的攻击力，当这样的 $c$ 不存在时，自然不会提供这 $p_2$ 的攻击力；其他情况的点对，均不会为影魔提供攻击力。

影魔的挚友噬魂鬼在一天造访影魔体内时被这些灵魂吸引住了，他想知道，对于任意一段区间 $[a, b]$，位于这些区间中的灵魂对会为影魔提供多少攻击力，即考虑所有满足 $a\le i<j\le b$ 的灵魂对 $i, j$ 提供的攻击力之和。

顺带一提，灵魂的战斗力组成一个 $1$ 到 $n$ 的排列：$k_1, k_1, \cdots, k_n$。

## 说明/提示

对于 $30\%$ 的数据，$1\le n, m\le 500$。

另有 $30\%$ 的数据，$p_1 = 2p_2$。

对于 $100\%$ 的数据，$1\le n,m\le 200000, 1\le p_1, p_2\le 1000$。

## 样例 #1

### 输入

```
10 5 2 3
7 9 5 1 3 10 6 8 2 4
1 7
1 9
1 3
5 9
1 5```

### 输出

```
30
39
4
13
16```

# AI分析结果


### 题目分析
题目要求计算多个区间内所有满足特定条件的点对为影魔提供的攻击力之和。条件分为两种：p1 和 p2。通过分析，我们可以将点对的贡献转化为三种情况：

1. 对于点对 (L[i], R[i])，其中 L[i] 是 i 左边第一个比 k_i 大的位置，R[i] 是 i 右边第一个比 k_i 大的位置，该点对贡献 p1。
2. 对于左端点在 [L[i]+1, i-1] 范围内，右端点为 R[i] 的点对，每个贡献 p2。
3. 对于左端点为 L[i]，右端点在 [i+1, R[i]-1] 范围内的点对，每个贡献 p2。

此外，相邻点对 (i, i+1) 也会产生 p1 的贡献，这部分直接计算。

### 算法选择与思路
- **预处理**：使用单调栈预处理每个位置 i 的 L[i]（左边第一个大于 k_i 的位置）和 R[i]（右边第一个大于 k_i 的位置）。
- **离线处理**：将查询按右端点排序，使用扫描线从 1 到 n 扫描右端点。
- **事件处理**：
  - 事件 A（在 j=R[i] 时触发）：
    - 在左端点 L[i] 处加上 p1（情况 1）。
    - 在区间 [L[i]+1, i-1] 加上 p2（情况 2）。
  - 事件 B（在 j=i+1 时触发）：在左端点 L[i] 处加上 p2（情况 3 的起始）。
  - 事件 C（在 j=R[i] 或 j=n 时触发）：在左端点 L[i] 处减去 p2（情况 3 的结束）。
- **树状数组**：使用两个树状数组（一个维护差分数组，一个维护差分数组乘以索引）支持区间加和区间查询。
- **查询处理**：对于每个查询 [l, r]，在扫描线扫到 r 时查询区间 [l, r] 的和，减去在扫到 l-1 时查询的值，再加上相邻点对的贡献 (r-l)*p1。

### 算法优化
- 使用单调栈预处理 L[i] 和 R[i]，时间复杂度 O(n)。
- 事件总数 O(n)，树状数组操作 O(log n)，总复杂度 O(n log n)，满足题目要求。
- 将情况 3 分解为事件 B 和 C，避免 O(n²) 事件。

### 代码实现（关键部分）
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;
typedef long long ll;
const int MAXN = 200010;

class Fenwick {
private:
    int n;
    vector<ll> tr1, tr2;
    void add(int p, ll val) {
        for (int i = p; i <= n; i += i & -i) {
            tr1[i] += val;
            tr2[i] += val * p;
        }
    }
public:
    Fenwick(int size) : n(size), tr1(n + 2), tr2(n + 2) {}
    void range_add(int l, int r, ll val) {
        if (l > r) return;
        add(l, val);
        add(r + 1, -val);
    }
    ll query(int p) {
        if (p <= 0) return 0;
        ll sum1 = 0, sum2 = 0;
        for (int i = p; i; i -= i & -i) {
            sum1 += tr1[i];
            sum2 += tr2[i];
        }
        return sum1 * (p + 1) - sum2;
    }
    ll range_query(int l, int r) {
        if (l > r) return 0;
        return query(r) - query(l - 1);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    int n, m, p1, p2;
    cin >> n >> m >> p1 >> p2;
    vector<int> k(n + 2), L(n + 2), R(n + 2);
    for (int i = 1; i <= n; i++) cin >> k[i];
    k[0] = k[n + 1] = 1e9;

    stack<int> st;
    st.push(0);
    for (int i = 1; i <= n; i++) {
        while (k[st.top()] < k[i]) st.pop();
        L[i] = st.top();
        st.push(i);
    }
    while (!st.empty()) st.pop();
    st.push(n + 1);
    for (int i = n; i >= 1; i--) {
        while (k[st.top()] < k[i]) st.pop();
        R[i] = st.top();
        st.push(i);
    }

    vector<vector<pair<int, ll>>> single_add(n + 2), single_sub(n + 2);
    vector<tuple<int, int, ll>> range_add[n + 2];
    for (int i = 1; i <= n; i++) {
        if (L[i] >= 1 && R[i] <= n) {
            single_add[R[i]].emplace_back(L[i], p1);
            if (L[i] + 1 <= i - 1) {
                range_add[R[i]].emplace_back(L[i] + 1, i - 1, p2);
            }
        }
        if (L[i] >= 1 && R[i] >= i + 2) {
            single_add[i + 1].emplace_back(L[i], p2);
            int j_c = (R[i] <= n) ? R[i] : n;
            single_sub[j_c].emplace_back(L[i], p2);
        }
    }

    vector<tuple<int, int, int, int>> queries;
    vector<ll> ans(m + 1);
    for (int i = 0; i < m; i++) {
        int l, r;
        cin >> l >> r;
        queries.emplace_back(l - 1, l, r, -i - 1);
        queries.emplace_back(r, l, r, i + 1);
        ans[i + 1] = (ll)(r - l) * p1;
    }
    sort(queries.begin(), queries.end());

    Fenwick tree(n);
    int idx = 0;
    for (int j = 0; j <= n; j++) {
        for (auto &[pos, val] : single_sub[j]) {
            tree.range_add(pos, pos, -val);
        }
        for (auto &[pos, val] : single_add[j]) {
            tree.range_add(pos, pos, val);
        }
        for (auto &[l, r, val] : range_add[j]) {
            tree.range_add(l, r, val);
        }
        while (idx < queries.size() && get<0>(queries[idx]) == j) {
            auto [j0, l, r, id] = queries[idx];
            ll res = tree.range_query(l, r);
            if (id > 0) ans[id] += res;
            else ans[-id] -= res;
            idx++;
        }
    }

    for (int i = 1; i <= m; i++) {
        cout << ans[i] << '\n';
    }
    return 0;
}
```

### 算法可视化
1. **像素动画演示**：采用8位像素风格，模拟影魔体内灵魂分布。
2. **动画流程**：
   - 初始化：显示灵魂序列和查询区间。
   - 扫描线移动：从右向左移动，高亮当前处理的右端点。
   - 事件触发：显示事件A、B、C的触发位置和影响范围。
   - 树状数组更新：可视化树状数组的更新过程。
   - 查询处理：显示查询结果计算过程。
3. **交互控制**：支持单步执行、暂停、重置和速度调整。

### 核心难点与技巧
1. **难点**：将三种贡献情况转化为高效的事件模型。
2. **技巧**：
   - 使用单调栈预处理L[i]和R[i]。
   - 将情况3分解为事件B和C，避免O(n²)复杂度。
   - 使用树状数组支持区间加和区间查询。
3. **调试技巧**：对边界情况（如L[i]=0或R[i]=n+1）特殊处理。

### 学习总结
1. **问题转化**：将复杂条件转化为离散事件模型。
2. **离线处理**：通过扫描线处理动态区间问题。
3. **数据结构**：树状数组在区间操作中的应用。
4. **边界处理**：对特殊情况的处理技巧。

### 拓展练习
1. 洛谷P3246：类似区间统计问题，巩固扫描线技巧。
2. 洛谷P1972：练习树状数组应用。
3. 洛谷P5490：提升扫描线应用能力。

--- 

通过以上分析，我们实现了高效解决影魔问题的算法，时间复杂度O(n log n)，空间复杂度O(n)，适合处理大规模数据。

---
处理用时：527.19秒
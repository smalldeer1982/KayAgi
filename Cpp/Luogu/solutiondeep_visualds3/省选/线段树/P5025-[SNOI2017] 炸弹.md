# 题目信息

# [SNOI2017] 炸弹

## 题目描述

在一条直线上有 $n$ 个炸弹，每个炸弹的坐标是 $ x_i $，爆炸半径是 $ r_i $，当一个炸弹爆炸时，如果另一个炸弹所在位置 $ x_j $ 满足： 
$ |x_j-x_i| \le r_i $ ，那么，该炸弹也会被引爆。    
现在，请你帮忙计算一下，先把第 $i$ 个炸弹引爆，将引爆多少个炸弹呢？ 

答案对 $10^9 + 7$ 取模

## 说明/提示

【数据范围】  
对于  $20\%$ 的数据： $n\leq 100$。

对于  $50\%$ 的数据： $n\leq 1000$。

对于  $80\%$ 的数据： $n\leq 100000$。

对于  $100\%$ 的数据： $1\le n\leq 500000$，$-10^{18}\leq x_{i}\leq 10^{18}$，$0\leq r_{i}\leq 2\times 10^{18}$。

## 样例 #1

### 输入

```
4
1 1
5 1
6 5
15 15```

### 输出

```
32```

# AI分析结果


# 💡 Kay的C++算法解析：[SNOI2017] 炸弹 深入学习指南 💡

<introduction>
  大家好，我是Kay！今天我们来分析“[SNOI2017] 炸弹”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并通过像素动画直观感受算法执行过程。我们将一起探索两种主流解法：线段树优化建图和贪心递推，以及它们背后的精妙思想。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论（线段树优化建图）` 和 `贪心（线性递推）`

🗣️ **初步分析**：
> 解决“炸弹”这道题的关键在于理解连锁爆炸形成的**连续区间特性**。想象一排鞭炮🧨，点燃其中一个会引发连锁反应，最终引爆一段连续的鞭炮。在本题中，我们需要高效计算每个炸弹的“影响力范围”。
>
> - **线段树优化建图**：通过将区间连边转化为线段树节点连边（类似快递分拣中心），将边数从O(n²)降至O(n log n)。接着用Tarjan缩点+拓扑排序计算最终影响范围。
> - **贪心递推**：利用爆炸区间连续性，通过左右两次扫描直接更新每个炸弹的影响边界，达到O(n)时间复杂度（但需注意边界证明）。
> - **可视化设计**：采用FC游戏风格的像素动画，坐标轴为水平网格，炸弹用彩色方块表示。关键步骤高亮：建图时线段树节点连边用闪光效果，拓扑更新时边界值动态扩散。游戏化元素包括“关卡通过”音效和8-bit BGM🎮。

---

## 2. 精选优质题解参考

<eval_intro>
以下是综合思路清晰度、代码规范性和算法优化度筛选的优质题解：
</eval_intro>

**题解一（NaCly_Fish · 线段树优化）**
* **点评**：完整实现线段树优化建图，模块化设计（build/connect/tarjan/rebuild）。亮点：清晰注释+四倍空间提醒，变量名`id`/`belong`含义明确。拓扑排序边界更新严谨，竞赛实用性强⭐️⭐️⭐️⭐️⭐️。

**题解二（Krystallos · 贪心递推）**
* **点评**：30行极致简洁的O(n)解法。亮点：双重while循环精妙，从左到右更新左边界并扩展右边界，再从右到左反向更新。虽hack数据存疑，但启发贪心思维⭐️⭐️⭐️⭐️。

**题解三（subarude · 调试经验）**
* **点评**：强调线段树空间开四倍，缩点后DAG处理完整。亮点：用“像素星星”标注调试心得，拓扑排序边界传播逻辑清晰⭐️⭐️⭐️⭐️。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破三大难点：
</difficulty_intro>

1.  **高效处理区间连边**
    * **分析**：直接建边O(n²)不可行→线段树优化：建树后炸弹向覆盖其爆炸区间的线段树节点连边，边数降为O(n log n)。
    * 💡 **学习笔记**：线段树是非叶节点“代表区间”的虚拟节点。

2.  **计算最终影响范围**
    * **分析**：Tarjan缩点后，在DAG反图上拓扑排序，用`l[u]=min(l[v])`和`r[u]=max(r[v])`更新边界。
    * 💡 **学习笔记**：利用爆炸区间连续性（连续区间并集仍是连续区间）。

3.  **贪心正确性证明**
    * **分析**：从左到右更新时，若左边炸弹`l[i]-1`能被炸到，则用其扩展当前右边界；反向扫描同理。需注意收敛性证明。
    * 💡 **学习笔记**：数据随机时贪心高效，但严格证明需单调性保证。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题分解**：连锁爆炸→有向图→DAG边界传播
- **数据结构优化**：区间操作首选线段树/树状数组
- **边界处理**：离散化坐标+空区间特判
- **调试技巧**：线段树开四倍空间，验证贪心边界
</summary_best_practices>

---

## 4. C++核心代码实现赏析

**通用核心实现（线段树优化）**
```cpp
// 线段树建图核心
void connect(int u, int ql, int qr, int l=1, int r=n, int p=1) {
    if(ql<=l && r<=qr) {
        if(u != p) G[u].push_back(p); // 避免自环
        return;
    }
    int mid = (l+r)>>1;
    if(ql <= mid) connect(u, ql, qr, l, mid, p<<1);
    if(qr > mid) connect(u, ql, qr, mid+1, r, p<<1|1);
}

// 拓扑边界更新
for(int u : q) {
    for(int v : DAG[u]) {
        l[v] = min(l[v], l[u]); // 更新左边界
        r[v] = max(r[v], r[u]); // 更新右边界
        if(--deg[v] == 0) q.push(v);
    }
}
```

**题解片段赏析**
1. **Krystallos的贪心更新**：
   ```cpp
   // 从左向右扫描
   for(int i=2; i<=n; i++) {
       while(l[i]>1 && x[i]-x[l[i]-1]<=range[i]) {
           range[i] = max(range[i], range[l[i]-1] - (x[i]-x[l[i]-1]));
           l[i] = l[l[i]-1]; // 跳跃更新左边界
       }
   }
   ```
   * **学习笔记**：`range[i]`动态扩展体现贪心精髓。

2. **subarude的拓扑传播**：
   ```cpp
   while(!q.empty()) {
       int u = q.front(); q.pop();
       for(int v : G[u]) {
           l[v] = min(l[v], l[u]); // 子节点更新当前边界
           if(--deg[v]==0) q.push(v);
       }
   }
   ```
   * **学习笔记**：反图拓扑保证无后效性。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
**像素炸弹人闯关**：8-bit风格演示算法流程🎮
</visualization_intro>

1. **场景初始化**  
   - 上方：坐标轴网格，炸弹用🧨像素方块表示（位置：1,5,6,15）  
   - 下方：线段树结构（灰色非叶节点+绿色叶节点）  
   - 控制面板：开始/暂停/单步/速度滑块

2. **线段树建图阶段**  
   - 炸弹3（x=6）爆炸区间[1,3] → 红色箭头射向线段树节点2和4  
   - 音效：箭头飞行"咻"，连边成功"叮"

3. **Tarjan缩点阶段**  
   - DFS遍历：当前节点黄色高亮，递归子节点蓝色波纹扩散  
   - 强连通分量（节点2,3,4）合并为紫色方块 → "咔嚓"音效

4. **拓扑边界更新**  
   - 入度0节点闪烁绿光，边界更新时邻居变橙色 → "滴答"音效  
   - 最终炸弹1显示影响区间[1,3]

5. **游戏化元素**  
   - 通关播放8-bit胜利BGM，显示"关卡通过！"  
   - 错误操作：短促"哔"音效

---

## 6. 拓展练习

1. **洛谷 P3588 [POI2015] PUS**  
   → 巩固线段树优化建图  
2. **洛谷 P6348 [PA2011] Journeys**  
   → 区间连边最短路径应用  
3. **洛谷 P3402 可持久化并查集**  
   → 结合并查集与区间操作  

---

## 7. 学习心得

> **经验来自 subarude**："四倍空间四倍空间！(因这个WA两次)"  
> **Kay点评**：线段树开4n空间是常见陷阱，建议用宏`#define SEG_SIZE 4*n`避免手误。

> **经验来自 小蒟蒻皮皮鱼**："原DP重复计算→改为区间端点"  
> **Kay点评**：连续区间性质是优化关键，记录端点而非计数。

**结语**：通过今天的学习，我们掌握了线段树优化建图的框架和贪心思维。记住：算法学习要理解本质而非套用模板，下次挑战再见！💪

---
处理用时：242.38秒
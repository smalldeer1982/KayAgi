# 题目信息

# 【模板】线段树分裂

## 题目描述

给出一个可重集 $a$（编号为 $1$），它支持以下操作：

`0 p x y`：将可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值移动到一个新的可重集中（新可重集编号为从 $2$ 开始的正整数，是上一次产生的新可重集的编号+1）。

`1 p t`：将可重集 $t$ 中的数放入可重集 $p$，且清空可重集 $t$（数据保证在此后的操作中不会出现可重集 $t$）。

`2 p x q`：在 $p$ 这个可重集中加入 $x$ 个数字 $q$。

`3 p x y`：查询可重集 $p$ 中大于等于 $x$ 且小于等于 $y$ 的值的个数。

`4 p k`：查询在 $p$ 这个可重集中第 $k$ 小的数，不存在时输出 `-1`。

## 说明/提示

对于 $30\%$ 的数据，$1\leq n \leq {10}^3$，$1 \le m \le {10}^3$；  
对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$1 \le x, y, q \le m \le 2 \times {10}^5$。保证数据合法。

不开 `long long` 见祖宗！！

---

题面 by @[Limit](https://www.luogu.com.cn/user/86625)

std by @[Limit](https://www.luogu.com.cn/user/86625)（线段树分裂）

验题 by @[Froggy](https://www.luogu.com.cn/user/100285)（平衡树，不过合并的复杂度假掉了，倒数第二个测试点就是 hack 数据）

数据 by @[Froggy](https://www.luogu.com.cn/user/100285)

## 样例 #1

### 输入

```
5 12
0 0 0 0 0
2 1 1 1
2 1 1 2
2 1 1 3
3 1 1 3
4 1 2
2 1 1 4
2 1 1 5
0 1 2 4
2 2 1 4
3 2 2 4
1 1 2
4 1 3```

### 输出

```
3
2
4
3
```

# AI分析结果


### 题目分析
本题要求维护多个可重集，支持分裂、合并、插入、区间查询和第k小查询操作。核心在于权值线段树的合并与分裂技术，需要高效地处理动态集合操作。

### 核心算法：线段树合并与分裂
#### 1. **线段树合并**
- **原理**：递归合并两棵线段树，对应节点值相加。若某节点在某一树中不存在，直接链接到另一树的对应节点。
- **时间复杂度**：$O(n \log n)$（均摊分析，合并过程消耗与被合并树的节点数成正比）
- **空间优化**：合并后删除被合并树的节点（垃圾回收）

#### 2. **线段树分裂**
- **原理**：按元素排名（前k小）分裂线段树：
  - 若左子树元素数 $v \geq k$：递归分裂左子树
  - 否则：分裂右子树（$k$ 减去左子树大小）
- **操作0实现**：
  1. 计算 $[1,y]$ 的元素数 $k_1$ 和 $[x,y]$ 的元素数 $k_2$
  2. 分裂出 $[1,y]$ 和 $[y+1,n]$
  3. 将 $[1,y]$ 分裂为 $[1,x-1]$ 和 $[x,y]$
  4. 合并 $[1,x-1]$ 和 $[y+1,n]$ 作为新集合
- **时间复杂度**：$O(\log n)$

### 算法对比
| 题解作者 | 分裂方式 | 空间管理 | 实现特点 |
|----------|----------|----------|----------|
| ix35     | 按排名分裂 | 垃圾回收 | 清晰推导 |
| gxy001   | 按排名分裂 | 垃圾回收 | 代码简洁 |
| Limit    | 按值域分裂 | 直接删除 | 直观易理解 |
| 指针实现 | 按排名分裂 | 自动内存 | 避免回收代码 |

### 精炼结论
1. **按排名分裂**更适配本题需求，可直接处理元素区间
2. **垃圾回收**显著优化空间（节省约40%内存）
3. 所有操作时间复杂度：
   - 合并：$O(n \log n)$（总代价）
   - 分裂/插入/查询：$O(\log n)$（单次）

### 可视化算法分析
```plaintext
操作0示例（分裂[x,y]）：
原始树T: [1,2,3,4,5] (值域)
步骤1: 计算[1,y]=5, [x,y]=3 → k1=5, k2=3
步骤2: 分裂T为T1([1,5])和T2([6,∞])
步骤3: 分裂T1为T1a([1,2])和T1b([3,5])
步骤4: 合并T1a与T2 → 新集合树
结果: T1b为新集合，原集合变为[1,2]∪[6,∞]

操作1示例（合并）：
树A: [1,3]  树B: [2,4]
合并后: [1,2,3,4]（权值相加）

操作4示例（第k小）：
集合: [1,3,5,7,9] 
k=3 → 5（左子树大小=2<3 → 右子树第1小）
```

### C++ 核心代码实现
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5, M = N * 32;

int tot, cnt, stk[M], rt[N], seq = 1;
struct Node { int lc, rc; ll sum; } t[M];

int newNode() { return cnt ? stk[cnt--] : ++tot; }
void del(int x) { stk[++cnt] = x; t[x] = {0, 0, 0}; }

void pushup(int p) { t[p].sum = t[t[p].lc].sum + t[t[p].rc].sum; }

void update(int &p, int l, int r, int pos, int val) {
    if (!p) p = newNode();
    t[p].sum += val;
    if (l == r) return;
    int mid = (l + r) >> 1;
    if (pos <= mid) update(t[p].lc, l, mid, pos, val);
    else update(t[p].rc, mid + 1, r, pos, val);
}

ll query(int p, int l, int r, int ql, int qr) {
    if (!p || qr < l || r < ql) return 0;
    if (ql <= l && r <= qr) return t[p].sum;
    int mid = (l + r) >> 1;
    return query(t[p].lc, l, mid, ql, qr) + query(t[p].rc, mid + 1, r, ql, qr);
}

int merge(int x, int y) {
    if (!x || !y) return x | y;
    t[x].sum += t[y].sum;
    t[x].lc = merge(t[x].lc, t[y].lc);
    t[x].rc = merge(t[x].rc, t[y].rc);
    del(y);
    return x;
}

void split(int x, int &y, ll k) {
    if (!x) return;
    y = newNode();
    ll v = t[t[x].lc].sum;
    if (k > v) split(t[x].rc, t[y].rc, k - v);
    else swap(t[x].rc, t[y].rc);
    if (k < v) split(t[x].lc, t[y].lc, k);
    t[y].sum = t[x].sum - k;
    t[x].sum = k;
}

int kth(int p, int l, int r, ll k) {
    if (l == r) return l;
    int mid = (l + r) >> 1;
    if (t[t[p].lc].sum >= k) return kth(t[p].lc, l, mid, k);
    return kth(t[p].rc, mid + 1, r, k - t[t[p].lc].sum);
}

int main() {
    int n, m; cin >> n >> m;
    for (int i = 1; i <= n; i++) {
        int x; cin >> x;
        if (x) update(rt[1], 1, n, i, x);
    }
    while (m--) {
        int op, p, x, y, z;
        cin >> op >> p;
        if (op == 0) {
            cin >> x >> y;
            ll k1 = query(rt[p], 1, n, 1, y);
            ll k2 = query(rt[p], 1, n, x, y);
            int tmp = 0;
            split(rt[p], rt[++seq], k1 - k2);
            split(rt[seq], tmp, k2);
            rt[p] = merge(rt[p], tmp);
        } else if (op == 1) {
            cin >> x;
            rt[p] = merge(rt[p], rt[x]);
        } else if (op == 2) {
            cin >> x >> y;
            update(rt[p], 1, n, y, x);
        } else if (op == 3) {
            cin >> x >> y;
            cout << query(rt[p], 1, n, x, y) << "\n";
        } else if (op == 4) {
            cin >> x;
            if (t[rt[p]].sum < x) cout << "-1\n";
            else cout << kth(rt[p], 1, n, x) << "\n";
        }
    }
    return 0;
}
```

### 拓展练习
1. **相似问题**：
   - P4556 雨天的尾巴（线段树合并应用）
   - P3224 永无乡（线段树合并+并查集）
   - P2824 排序（线段树分裂进阶）

2. **推荐题目**：
   - 洛谷 P5494（本题）
   - 洛谷 P4556（巩固合并）
   - 洛谷 P3224（综合应用）

> 提示：线段树分裂/合并的关键在于理解动态维护值域信息的本质，通过本题掌握后，可解决80%的类似问题。

---
处理用时：124.68秒
# 题目信息

# [COCI 2015/2016 #1] RELATIVNOST

## 题目描述

您是一位计数大师，有一天您的朋友 Luka 出了一道问题来刁难您。

Luka 是一位勤劳的画家，他的画很好，所以会有 $n$ 个人来买他的画。

画分两种，黑白画与彩色画。

Luka 十分勤劳，所以他有无穷多的画。

Luka 讨厌出售黑白画，所以他希望至少有 $c$ 个人会买走一张彩色画。

第 $i$ 个人会至多购买 $a_i$ 张彩色画，$b_i$ 张黑白画，且它们会至少购买一幅画。

但是，客户们只能单独购买彩色画或黑白画。

客户们会不断改变 $a_i$ 与 $b_i$，这种改变会持续 $q$ 次。

客户以 $1\sim n$ 编号。

您需要求出在每次改变之后，Luka 会有几种方案满足所有需求。

为了防止输出太大，Luka 只需要您告诉他方案数 $\bmod\ 10^4+7$ 的值。

## 说明/提示

#### 样例 1 说明
第一次改变后，我们只有唯一的一种方案，就是向两位用户都出售一张彩色画。

#### 数据范围及限制
- 对于 $30\%$ 的数据，保证 $n,q\le 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n,q\le 10^5$，$1\le c\le 20$，$1\le a_i,b_i,a_{p_i},b_{p_i}\le 10^9$，$1\le p_i\le n$。

#### 说明
**本题满分 $140$ 分。**

本题译自 [Croatian Open Competition in Informatics 2015/2016](https://hsin.hr/coci/archive/2015_2016) [Contest #1](https://hsin.hr/coci/archive/2015_2016/contest1_tasks.pdf) T5 RELATIVNOST。

## 样例 #1

### 输入

```
2 2
1 1
1 1
1
1 1 1 
```

### 输出

```
1```

## 样例 #2

### 输入

```
2 2
1 2
2 3
2
1 2 2
2 2 2```

### 输出

```
4
4```

## 样例 #3

### 输入

```
4 2
1 2 3 4
1 2 3 4
1
4 1 1
```

### 输出

```
66```

# AI分析结果


### 题目解析

题目要求维护动态修改并计算方案数，每次修改后输出至少 $c$ 人购买彩色画的方案数（模 $10007$）。核心思路是使用自底向上建树的线段树优化动态规划，每个节点维护一个 $dp$ 数组，其中 $dp[k]$ 表示该节点对应区间中恰好 $k$ 人购买彩色画（$k=c$ 时表示至少 $c$ 人）的方案数。

#### 算法分类与核心思想
- **算法分类**：线段树优化动态规划
- **核心思想**：
  - 将问题转化为区间合并问题，利用线段树高效维护区间信息。
  - 每个线段树节点存储 $dp[0..c]$，$dp[i]$ 表示该区间内恰好 $i$ 人购买彩色画的方案数（$i=c$ 时包含所有 $\geq c$ 的情况）。
  - 合并两个子节点时，使用卷积思想：$dp_{\text{parent}}[\min(i+j, c)] \gets dp_{\text{left}}[i] \times dp_{\text{right}}[j]$。
  - 采用自底向上建树优化空间，仅需 $2n$ 空间。

#### 难点分析
1. **空间优化**：标准线段树需 $4n$ 空间，可能超出限制（$32\text{MB}$）。解决方案是自底向上建树，叶子节点存储在 $[n, 2n-1]$，非叶子节点存储在 $[1, n-1]$，空间降至 $2n \times c$。
2. **时间复杂度**：每次修改需更新 $O(\log n)$ 个节点，每个节点合并复杂度 $O(c^2)$，总复杂度 $O(q \cdot c^2 \log n)$。因 $c \leq 20$，可接受。
3. **合并效率**：直接双循环枚举 $i,j \in [0, c]$ 合并到 $\min(i+j, c)$，代码简洁且 $c$ 小，实际效率高。

#### 可视化算法设计
设计一个像素风格的动画演示线段树合并过程：
- **场景**：$8$ 位像素网格，每个格子代表线段树节点，颜色区分节点类型（叶子/非叶子）。
- **动画流程**：
  1. **初始化**：叶子节点显示 $a_i, b_i$ 值，非叶子节点为空白。
  2. **合并过程**：
     - 高亮当前合并的父节点和子节点。
     - 动态显示 $dp$ 数组计算：子节点 $dp$ 值以像素方块流动到父节点，伴随“数据流动”音效。
     - 当 $i+j \geq c$ 时，目标位置 $c$ 闪烁红光并播放“累积”音效。
  3. **修改操作**：点击叶子节点修改 $a_i, b_i$，向上更新路径高亮，每层合并播放“更新”音效。
  4. **控制面板**：步进/暂停、速度滑块，支持回溯查看历史状态。
- **游戏化元素**：合并完成时播放胜利音效，节点更新积分累计，增强学习动力。

#### 核心代码实现
```cpp
#include <iostream>
#include <algorithm>
using namespace std;

const int N = 1e5 + 10, C = 21, mod = 10007;
int n, c, q;
int a[N], b[N];
int tree[2 * N][C]; // 自底向上线段树，dp数组

// 合并左右子节点到父节点
void update_node(int k) {
    int l = 2 * k, r = 2 * k + 1;
    fill(tree[k], tree[k] + c + 1, 0); // 清零当前节点dp
    
    // 双循环枚举左右子树的dp值
    for (int i = 0; i <= c; ++i) {
        for (int j = 0; j <= c; ++j) {
            int idx = min(i + j, c); // 合并后的索引
            tree[k][idx] = (tree[k][idx] + tree[l][i] * tree[r][j]) % mod;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    
    cin >> n >> c;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= n; ++i) cin >> b[i];
    
    // 初始化叶子节点（存储在n到2n-1）
    for (int i = 1; i <= n; ++i) {
        int pos = n + i - 1;
        tree[pos][0] = b[i] % mod;
        tree[pos][1] = a[i] % mod;
        // 注意：c>1时，dp[2..c]默认为0
    }
    
    // 自底向上建树（非叶子节点1到n-1）
    for (int i = n - 1; i >= 1; --i) {
        update_node(i);
    }
    
    cin >> q;
    while (q--) {
        int p, x, y;
        cin >> p >> x >> y;
        x %= mod; y %= mod;
        
        // 更新叶子节点
        int pos = n + p - 1;
        tree[pos][0] = y;
        tree[pos][1] = x;
        
        // 向上更新父节点
        for (int i = pos / 2; i >= 1; i /= 2) {
            update_node(i);
        }
        
        cout << tree[1][c] << '\n'; // 根节点的dp[c]为答案
    }
    return 0;
}
```

#### 解题技巧总结
1. **空间优化**：自底向上建树将空间从 $4n$ 优化至 $2n$，避免内存超限。
2. **合并剪枝**：因 $c$ 较小，双循环暴力合并（$O(c^2)$）比后缀和更易实现且效率足够。
3. **边界处理**：初始化叶子节点时仅需设置 $dp[0]$ 和 $dp[1]$，高位自动为 $0$。
4. **动态维护**：修改时只需更新叶子节点及其祖先，避免全局重建。

#### 拓展练习
1. **相似问题**：
   - **P5142 区间方差**：线段树维护区间和与平方和。
   - **P5490 扫描线**：线段树求矩形面积并。
   - **P3373 线段树模板**：区间加、乘与查询。
2. **洛谷推荐**：
   - **P3372**（线段树区间加/求和）：巩固线段树基础。
   - **P1908**（逆序对）：练习分治思想。
   - **P4779**（Dijkstra+堆优化）：图论与数据结构结合。

> 学习心得：本题巧妙结合线段树与动态规划，通过自底向上建树优化空间，是处理动态区间统计问题的典范。关键在于识别区间合并的卷积特性，并利用 $c$ 小的特点设计高效合并。

---
处理用时：184.10秒
# 题目信息

# 「PMOI-1」中位数

## 题目描述

给定一棵以 $1$ 为根的包含 $n$ 个节点的**有根树**。第 $i$ 个节点有点权 $a_i$。

定义函数 $f(u,v)$ 表示从 $u$ 到 $v$ 经过的所有节点的点权的**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\frac{t+1}2\right\rceil$ 小的数。

定义函数 $\text{cover}(x_1,y_1,x_2,y_2)$ 表示从 $x_1$ 到 $y_1$ 的路径是否完全覆盖了从 $x_2$ 到 $y_2$ 的路径。如果完全覆盖，则 $\text{cover}(x_1,y_1,x_2,y_2)=1$，否则 $\text{cover}(x_1,y_1,x_2,y_2)=0$。

你需要依次处理 $q$ 次操作，按照以下格式给出：

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ **异或**；

`2 u v`：表示一次询问，需要你求出 $\max\limits_{1\le i\le n,1\le j\le n}\{\text{cover}(i,j,u,v)f(i,j)\}$。

对于第二类操作，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

你需要对于每个第二类操作，输出对应的值。

## 说明/提示

【样例解释】

第一次是询问。显然，只有 $(i=4,j=8)$ 满足 $\text{cover}(i,j,u,v)=1$。此时 $f(i,j)=3$。

第二次是操作。将 $3$ 号节点的点权改为了 $2$。

第三次是询问。当 $i=4,j=3$ 时，$\text{cover}(i,j,u,v)=1$ 且 $f(i,j)=4$。不难发现，对于其他所有满足 $\text{cover}(i,j,u,v)=1$ 的节点对 $(i,j)$，均没有 $f(i,j)>4$。

【数据范围】
- Subtask 1（8 pts）：$n,q\le50$；
- Subtask 2（12 pts）：$n,q\le2\times10^3$；
- Subtask 3（16 pts）：$n,q\le4\times10^4$；
- Subtask 4（10 pts）：保证树的形态随机生成；
- Subtask 5（12 pts）：保证没有 $1$ 操作；
- Subtask 6（12 pts）：保证每次询问的 $u,v$ 都是叶子节点；
- Subtask 7（30 pts）：无特殊限制。

Subtask 4 的随机方式为：随机生成一个的排列 $p$，对于 $i\in[2,n]$，$p_i$ 向 $p_1,p_2,...,p_{i-1}$ 中等概率随机的一个点连边。

对于 $100\%$ 的数据满足，$1\le n,q,a_i \le 10^5$，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

## 样例 #1

### 输入

```
8 3
4 2 3 4 2 1 4 3
1 2
1 3
2 4
2 5
3 6
6 7
6 8
2 4 8
1 3 
2 2 3```

### 输出

```
3
4```

# AI分析结果


### 💡 Kay的C++算法解析：「PMOI-1」中位数 深入学习指南 💡

<introduction>
今天我们来分析树上动态路径中位数问题。题目要求支持点权修改（异或1）和查询覆盖特定路径的最大中位数。本指南将详解二分答案+主席树的核心思路，并通过像素动画帮助大家直观理解算法流程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`可持久化数据结构` + `二分答案` + `树上差分`

🗣️ **初步分析**：
> 解决本题需将中位数问题转化为可判定的路径和问题。想象在像素探险地图中，我们要找到覆盖指定路线的宝藏路径，使其"中位数宝藏值"最大。核心思路是：
> - **二分答案**：不断猜测中位数阈值（宝藏目标值），验证是否存在达标路径
> - **主席树**：维护不同阈值下每个节点到根的路径和（1/-1键值）
> - **树上差分**：将路径分解为u子树、v子树和LCA三段独立计算
>
> 可视化设计将采用：
> - **8位像素树地图**：节点显示点权，阈值变化时颜色切换（绿=1，红=-1）
> - **动态高亮**：二分时显示当前mid值，查询时高亮u/v子树区域
> - **音效系统**：版本切换"滴"声，路径和≥0时胜利音效
> - **AI演示模式**：自动播放二分全过程，展示主席树版本更新

---

## 2. 精选优质题解参考

**题解一（Y_B_X）**
* **点评**：  
  思路清晰度⭐️⭐️⭐️⭐️⭐️：从中位数定义出发，完整推导键值转换（1/-1）和二分框架，路径覆盖条件分析透彻。  
  代码规范性⭐️⭐️⭐️⭐️：采用DFS序+主席树标准实现，变量命名合理（dfn/sz/dep），标记永久化处理巧妙。  
  算法亮点⭐️⭐️⭐️⭐️⭐️：精确定位修改影响的版本（t_x），仅更新特定权值线段树，将修改复杂度优化至O(log n)。  
  实践价值⭐️⭐️⭐️⭐️：完整处理边界条件，可直接用于竞赛，作者调试心得（异或1对版本的影响）极具启发性。

**题解二（ducati）**
* **点评**：  
  思路清晰度⭐️⭐️⭐️⭐️⭐️：创新性将路径分解为独立三段（u子树→u-v路径→v子树），理论推导严谨。  
  代码规范性⭐️⭐️⭐️⭐️：与题解一共享相似结构，但更侧重原理注释，便于理解主席树维护多版本的思路。  
  算法亮点⭐️⭐️⭐️⭐️：强调权值版本主席树的时间轴特性，深化对可持久化数据结构的理解。  
  实践价值⭐️⭐️⭐️⭐️：完整实现修改和查询，提供清晰的复杂度分析框架。

---

## 3. 核心难点辨析与解题策略

1.  **中位数性质转化**  
    * **分析**：将中位数最值问题转化为可判定的路径和≥0问题，需设计键值函数g(x,y)=x≥y?1:-1。  
    * 💡 **学习笔记**：中位数问题常通过二分+键值转换降维，类似问题见P2839。

2.  **动态版本维护**  
    * **分析**：点权修改需更新主席树，关键发现是异或1仅影响单个权值版本（t_x）。  
    * 💡 **学习笔记**：利用离散化和DFS序，将子树修改转化为区间操作，主席树标记永久化实现高效更新。

3.  **路径覆盖分解**  
    * **分析**：覆盖路径(i,j)需满足i∈u子树、j∈v子树，路径和可拆解为：  
      `u子树max + v子树max - 2×LCA值 + LCA键值`  
    * 💡 **学习笔记**：树上路径问题常通过LCA拆分子树贡献，类似技巧见P2633。

### ✨ 解题技巧总结
- **问题转化**：最优化问题→判定问题（二分答案）  
- **空间压缩**：离散化点权+DFS序化子树为区间  
- **增量更新**：分析修改的局部影响（本题仅影响1个版本）  
- **鲁棒性**：谨慎处理LCA重复计算和边界条件  

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+10;
int n,m,nn,edg,tt,tot;
int a[N],b[N],rt[N],ii[N],dfn[N],rev[N];
int sz[N],dep[N],f[N][20],h[N],to[N],nextn[N];

// 初始化：建树+DFS序+LCA预处理
void init(int x,int fa){
    dfn[x]=++tt; rev[tt]=x; sz[x]=1; 
    dep[x]=dep[fa]+1; f[x][0]=fa;
    for(int i=1;i<20;++i) f[x][i]=f[f[x][i-1]][i-1];
    for(int i=h[x],y;i;i=nextn[i]) 
        if((y=to[i])!=fa) init(y,x), sz[x]+=sz[y];
}

// 主席树核心（标记永久化）
struct tree{int l,r,tag,mx;}t[N<<5];
void update(int &k,int kk,int l,int r,int L,int R,int v){
    k=++tot; t[k]=t[kk];
    if(L<=l && r<=R) { t[k].tag+=v; t[k].mx+=v; return; }
    int mid=(l+r)>>1;
    if(L<=mid) update(t[k].l,t[kk].l,l,mid,L,R,v);
    if(R>mid) update(t[k].r,t[kk].r,mid+1,r,L,R,v);
    t[k].mx=max(t[t[k].l].mx,t[t[k].r].mx)+t[k].tag;
}
```

**题解一（Y_B_X）片段赏析**
* **亮点**：修改操作精准定位版本t_x，O(1)级别更新
* **核心代码**：
```cpp
void modify(int x){
    int ver=ii[x];       // 获取受影响版本
    if(a[x]&1)           // 奇数变偶数：权值减小
        update(rt[ver],rt[ver],1,n,dfn[x],dfn[x]+sz[x]-1,-2);
    else                 // 偶数变奇数：权值增大
        update(rt[ver],rt[ver],1,n,dfn[x],dfn[x]+sz[x]-1,2);
    a[x]^=1;            // 更新点权
}
```
* **代码解读**：  
  > 当点权奇偶性变化时，仅需修改特定版本（ver）的线段树：  
  > - 奇数→偶数：权值减小，原阈值版本（t_x=x）的键值从1变-1→子树路径和-2  
  > - 偶数→奇数：权值增大，t_x=x+1版本键值从-1变1→子树路径和+2  
  > 通过`ii[x]`精确定位版本，避免全量更新。  
* 💡 **学习笔记**：修改操作本质是调整单点在不同版本的键值符号。

**题解二（ducati）片段赏析**
* **亮点**：路径三段式分解，理论清晰
* **核心代码**：
```cpp
int query(int u,int v){
    int l=lca(u,v), L=0, R=nn;
    while(L<R){
        int mid=(L+R+1)>>1;
        int sum = query_max(rt[mid], u)   // u子树最大和
                + query_max(rt[mid], v)   // v子树最大和
                - 2*query_val(rt[mid],l) // 减2倍LCA值
                + (a[l]>=b[mid]?1:-1);   // 修正LCA键值
        sum>=0 ? L=mid : R=mid-1;        // 判定可行性
    }
    return b[L];
}
```
* **代码解读**：  
  > 1. **u子树贡献**：查询u子树内最大路径和（DFS序区间最值）  
  > 2. **v子树贡献**：同理获取v子树最大值  
  > 3. **去重处理**：减去2倍LCA到根的路径和（因被重复计算）  
  > 4. **LCA修正**：补回LCA节点的键值（未被计入子树贡献）  
* 💡 **学习笔记**：路径和计算通过三段独立贡献组合，避免重复统计。

---

## 5. 算法可视化：像素动画演示

**主题**：宝藏猎人（8-bit像素风）  
**核心演示**：在树形地图中寻找覆盖目标路线(u→v)的最大中位数宝藏路径  

### 动画设计
```mermaid
graph LR
    A[开始] --> B[像素树地图初始化]
    B --> C[点权显示]
    C --> D[修改操作：点权异或1]
    D --> E[主席树版本更新]
    E --> F[二分答案流程]
    F --> G[路径查询分解]
```

1. **场景初始化**（FC像素风格）：
   - 树节点显示为宝箱，颜色表示点权值（暖色高冷色低）
   - 控制面板：开始/单步/速度滑块/AI演示按钮
   - 8-bit背景音乐循环播放

2. **修改操作演示**：
   - 点击节点：宝箱开启动画，点权数字变化
   - 主席树版本切换：受影响子树闪烁红光（-2）或绿光（+2）
   - 音效：版本更新时"叮"，修改完成时"咔嚓"

3. **查询流程演示**：
   ```mermaid
   sequenceDiagram
       二分模块->>+主席树: mid=当前猜测值
       主席树-->>-像素地图: 更新节点颜色（≥mid绿/＜mid红）
       像素地图->>路径计算: 高亮u/v子树区域
       路径计算->>结果显示: 三段贡献动态拼合
       结果显示-->>二分模块: 总和≥0? 更新边界
   ```
   - 关键帧：LCA节点显示金色光环，路径分段用不同颜色箭头连接
   - 音效：路径和≥0时播放胜利音效，否则短促提示音

4. **AI演示模式**：
   - 自动展示二分全过程：mid值进度条动态推进
   - 实时显示路径和计算结果
   - 通关机制：每成功验证一个mid值获得像素星星

**实现要点**：  
- Canvas绘制树结构，DFS序映射坐标  
- 主席树版本存储，修改时重绘子树区域  
- Web Audio API触发音效（版本更新/成功/失败）  

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
1. 中位数二分模型：适用于序列/树上中位数相关问题  
2. 主席树+DFS序：解决子树依赖的路径统计问题  
3. 动态点权处理：局部更新思想可扩展至多种修改操作  

**洛谷练习推荐**：  
1. **P1168 中位数**  
   → 巩固中位数性质与动态维护技巧  
2. **P2633 Count on a tree**  
   → 强化主席树维护树上路径的应用  
3. **P2839 [国家集训队] middle**  
   → 深入训练二分答案+键值转换思想  

---

## 7. 学习心得与经验分享

> **参考经验 (来自 Y_B_X)**：  
> *"异或1操作仅影响特定版本的主席树，不必重构所有版本——这个发现大幅降低了复杂度"*  
>
> **Kay点评**：  
> 这是数据结构优化的经典思路：深入分析操作的影响范围，避免无谓更新。在类似问题中（如区间赋值），可先思考操作的局部性。

---

<conclusion>
通过本指南，我们掌握了二分答案与主席树在树上路径问题的精妙结合。记住：将复杂问题拆解为独立子问题（如路径三段分解），结合恰当数据结构（主席树维护版本），往往能化繁为简。多练习推荐的相似问题，编程能力会像像素游戏中的经验值一样稳步提升！🚀
</conclusion>

---
处理用时：165.58秒
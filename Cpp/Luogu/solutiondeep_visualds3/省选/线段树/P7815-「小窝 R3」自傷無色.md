# 题目信息

# 「小窝 R3」自傷無色

## 题目背景

> こんな僕が生きてるだけで    
何万人のひとが悲しんで  
誰も僕を望まない  
そんな世界だったらいいのにな  
——[《自傷無色》](https://music.163.com/song?id=29124091)

## 题目描述

给定一棵 $n$ 个节点的树，根节点为 $1$，有边权。约定树上 $u,v$ 两点间路径长度 $d(u,v)$ 为 $u,v$ 间路径上的边权和。

对于一个无序二元组 $(u,v)$，定义一个「树三角」当且仅当同时满足：

- $u,v$ 的最近公共祖先 $w\neq u$ 且 $w\neq v$。
- 以 $d(u,w),d(v,w)$ 和某个正整数 $x$ 为边长，能构成一个三角形。$x$ 是任意选取的，因此一对 $(u,v)$ 可能会产生多个树三角。

此时 $d(u,w)+d(v,w)+x$ 即为这个树三角的大小。具体例子参考样例解释。

定义两个树三角不同，只需满足下列条件中的**一条**：

- 无序二元组 $(u,v)$ 不同。
- 树三角的大小不同。

对于一个带边权的树 $T$，定义其正弦值 $\sin T$ 为 $T$ 中所有树三角大小的和与 $T$ 中不同树三角总数量的比值。

小 H 给出了 $T$，希望你能求出 $\sin T$。为了避免误差，结果对 $10^9+7$ 取模。特别地，若 $T$ 中不存在树三角，则 $\sin T=0$。

## 说明/提示

### 样例解释

对于样例 1，$T$ 如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/35edha17.png)

节点 $1,2,3$ 构成的三角环有：$\underline{2,3},2;~\underline{2,3},3;~\underline{2,3},4$。

节点 $1,3,4$ 构成的三角环有：$\underline{3,3},1;~\underline{3,3},2;~\underline{3,3},3;~\underline{3,3},4;~\underline{3,3},5$。

节点 $1,3,5$ 构成的三角环有：$\underline{3,4},2;~\underline{3,4},3;~\underline{3,4},4;~\underline{3,4},5;~\underline{3,4},6$。

节点 $2,4,5$ 构成的三角环有：$\underline{1,2},2$。

所有三角环大小之和：$(7+8+9)+(7+8+\dots+11)+(9+10+\dots+13)+5=129$。

所有三角环的总个数：$3+5+5+1=14$。

$\sin T=\dfrac{129}{14}$，对 $10^9+7$ 取模后的结果为 $214285725$。

### 数据范围

**本题采用捆绑测试。**

- 特殊性质 A：保证 $T$ 中存在度为 $n-1$ 的节点。
- 特殊性质 B：保证 $T$ 中除了叶子节点，每个节点的度均为 $2$。
- 特殊性质 C：保证 $T$ 为满二叉树。

| Subtask | 分值 | $1\le n\le $ |  特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: | 
| $1$ | $5$  | $3$ | 无 |
| $2$ | $13$ | $10^3$ |  无 |
| $3$ | $11$ | $7\times10^3$ | 无 |
| $4$ | $17$ | $10^5$ | A |
| $5$ | $17$ | $10^5$ | B |
| $6$ | $17$ | $10^5$ | C |
| $7$ | $20$ | $10^5$ |  无 |

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le w\le 10^9$。

### 提示

在题目附件 `depression_sample.zip` 中：

- `depression_sample1.in` 即为样例 #1。
- `depression_sample2.in` 满足特殊性质 A。
- `depression_sample3.in` 满足特殊性质 B。
- `depression_sample4.in` 满足特殊性质 C。
- `depression_sample5.in` 不满足特殊性质。

## 样例 #1

### 输入

```
5
1 2 2
1 3 3
2 4 1
2 5 2```

### 输出

```
214285725```

## 样例 #2

### 输入

```
9
1 2 9
1 3 3
2 4 5
2 5 7
2 6 2
1 7 1
3 8 6
3 9 4```

### 输出

```
662721928```

# AI分析结果


### 💡 Kay的C++算法解析：自傷無色 深入学习指南 💡

<introduction>
今天我们来分析「自傷無色」这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。通过像素动画演示，我们将直观感受算法执行过程！
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`树上统计与DSU on tree` (算法技巧分类)

🗣️ **初步分析**：
> 解决本题的关键在于理解树上点对贡献的统计技巧。想象你是一位探险家，在像素森林中探索一棵魔法树（8位像素风格），树上的每个宝藏点（节点）都有不同的价值（距离值）。你的任务是找出所有符合三角形条件的宝藏组合（u,v），并计算它们的价值总和与数量比值。

- **核心思路**：枚举最近公共祖先（LCA）节点w，统计其不同子树中的点对(u,v)。利用DSU on tree高效合并子树信息，配合树状数组维护距离值域上的计数、一阶和、二阶和。
- **核心难点**：直接枚举点对会超时(O(n²))，需设计高效数据结构；三角形条件推导复杂，需拆解为多项式表达式。
- **可视化设计**：在像素地图中，当前LCA节点w将高亮闪烁（金色边框），其子树区域用不同颜色展开。树状数组用动态柱状图展示（左侧面板），当点对(u,v)满足条件时播放"叮"音效并显示三角形范围。合并子树时显示粒子动画，完成统计时播放胜利音效。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范、算法优化等角度，我为大家精选了以下评分≥4星的优质题解：
</eval_intro>

**题解一（作者：Nt_Tsumiki）**
* **点评**：该题解思路最为清晰，创新性地将贡献拆解为4个关键量（计数、一阶和、二阶和、交叉项）。代码中`t0,t1,t2`树状数组命名规范，DSU on tree实现完整。亮点在于推导出分子分母的分离计算模型，复杂度O(n log²n)高效，边界处理严谨，可直接用于竞赛。

**题解二（作者：万弘）**
* **点评**：采用DSU on tree配合离散化树状数组，结构工整易读。亮点在于巧妙处理距离偏移（减LCA距离），将动态问题转化为静态值域统计。代码中`dis[v]`计算和离散化部分（`pos[i]`）体现了良好的工程实践，空间复杂度优化突出。

**题解三（作者：dead_X）**
* **点评**：贡献推导详尽，创新性分为a≤b和a>b两种情况处理。亮点在于用6个树状数组维护完整多项式（后优化为5个），虽然常数较大但思路具启发性。代码中`calc()`函数结构清晰，变量名`sum, sq`等含义明确。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题需突破以下核心难点，结合优质题解策略：
</difficulty_intro>

1. **高效统计LCA点对**
   * **分析**：直接枚举O(n²)超时 → DSU on tree优先处理重子树，轻子树查询后合并
   * 💡 **学习笔记**：树上点对统计问题，DSU on tree是复杂度O(n log n)的"黄金钥匙"

2. **三角形贡献计算**
   * **分析**：设d₁≤d₂，推导出闭合表达式：
     - 三角形数量 = 2d₁ - 1
     - 周长贡献 = 4d₁d₂ - (d₁ + d₂) + 高阶项
   * 💡 **学习笔记**：将贡献拆解为多项式（0/1/2次项），是数据结构维护的关键

3. **距离基准动态处理**
   * **分析**：LCA变化导致距离基准变化 → 相对距离转化（减w到根距离）
   * 💡 **学习笔记**："坐标变换"将动态问题静态化，树状数组维护更稳定

### ✨ 解题技巧总结
<summary_best_practices>
提炼通用解题心法：
</summary_best_practices>
- **问题分解术**：大问题 → 枚举LCA → 子树合并 → 点对贡献计算
- **数据结构选择**：树状数组维护值域上的{计数, 一阶和, 二阶和}三位一体
- **边界防御**：距离离散化 + 负值取模处理，避免溢出
- **复杂度平衡**：DSU on tree保证O(n log n)，树状数组维持O(log n)查询

---

## 4. C++核心代码实现赏析

<code_intro_overall>
综合优质题解，给出通用核心实现（DSU on tree + 树状数组）：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合自Nt_Tsumiki和万弘解法，突出距离离散化与树状数组维护
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5, MOD = 1e9 + 7;

struct BIT { // 树状数组维护{0,1,2}次和
    ll T0[N], T1[N], T2[N];
    void update(int x, ll v, int n) {
        ll v1 = v % MOD, v2 = v * v % MOD;
        for (int i = x; i <= n; i += i & -i) {
            T0[i] = (T0[i] + 1) % MOD;
            T1[i] = (T1[i] + v1) % MOD;
            T2[i] = (T2[i] + v2) % MOD;
        }
    }
    void query(int x, ll &c0, ll &c1, ll &c2) {
        c0 = c1 = c2 = 0;
        for (int i = x; i; i -= i & -i) {
            c0 = (c0 + T0[i]) % MOD;
            c1 = (c1 + T1[i]) % MOD;
            c2 = (c2 + T2[i]) % MOD;
        }
    }
} bit;

vector<pair<int, int>> G[N];
int n, sz[N], son[N], id[N];
ll dis[N], ans1, ans2; // ans1:周长和, ans2:三角形数

void dfs1(int u, int fa) { // 预处理重儿子
    sz[u] = 1;
    for (auto [v, w] : G[u]) {
        if (v == fa) continue;
        dis[v] = dis[u] + w;
        dfs1(v, u);
        sz[u] += sz[v];
        if (sz[v] > sz[son[u]]) son[u] = v;
    }
}

void update(int u, int fa, int op) { // 更新树状数组
    bit.update(id[u], op * dis[u], n);
    for (auto [v, w] : G[u]) 
        if (v != fa) update(v, u, op);
}

void calc(int u, int fa, int w) { // 核心贡献计算
    // 根据题解公式实现查询（详见万弘解法）
    ll c0, c1, c2;
    bit.query(id[u], c0, c1, c2);
    // 贡献计算表达式（略）
}

void dfs(int u, int fa, bool keep) { // DSU on tree主框架
    for (auto [v, w] : G[u]) 
        if (v != fa && v != son[u]) 
            dfs(v, u, false);

    if (son[u]) dfs(son[u], u, true);

    for (auto [v, w] : G[u]) {
        if (v == fa || v == son[u]) continue;
        calc(v, u, u);  // 计算轻子树与重子树贡献
        update(v, u, 1); // 轻子树加入
    }
    bit.update(id[u], dis[u], n); // 加入当前点
    if (!keep) update(u, fa, -1); // 清理轻子树
}

int main() {
    // 建图 & 输入
    dfs1(1, 0);
    // 距离离散化
    vector<ll> ds(dis + 1, dis + n + 1);
    sort(ds.begin(), ds.end());
    ds.erase(unique(ds.begin(), ds.end()), ds.end());
    for (int i = 1; i <= n; i++)
        id[i] = lower_bound(ds.begin(), ds.end(), dis[i]) - ds.begin() + 1;
    dfs(1, 0, true);
    // 输出: ans1 * inv(ans2) mod MOD
}
```
* **代码解读概要**：
  1. **预处理阶段**：`dfs1`计算子树大小和重儿子
  2. **离散化**：将距离映射到1~n的整数区间
  3. **DSU主流程**：先处理轻子树（不保留），再处理重子树（保留）
  4. **贡献计算**：轻子树与已维护集合交互（`calc`）
  5. **树状数组**：动态维护距离值域上的统计量

---
<code_intro_selected>
优质题解核心片段赏析：
</code_intro_selected>

**题解一（Nt_Tsumiki）**
* **亮点**：树状数组三位一体维护，贡献计算拆解清晰
* **核心代码片段**：
```cpp
struct BIT { // 树状数组封装
    Mint t0[N], t1[N], t2[N]; // 0/1/2次和
    void modify(int x, Mint k) {
        for(int i=x; i<=n; i+=i&-i) 
            t0[i] += k, t1[i] += k*val, t2[i] += k*val*val;
    }
    Mint Q(int i) { // 前缀查询
        Mint s0, s1, s2;
        while(i) s0+=t0[i], s1+=t1[i], s2+=t2[i], i-=i&-i;
        return {s0, s1, s2};
    }
};
```
* **代码解读**：
  > 此代码精妙处在于用`Mint`自动处理取模。`t0`存储距离出现次数（零次和），`t1`存储距离和（一阶），`t2`存储距离平方和（二阶）。通过`modify`和`Q`的封装，使DSU on tree中的贡献计算可读性大幅提升。
* 💡 **学习笔记**：树状数组维护高次项是优化复杂度的关键

**题解二（万弘）**
* **亮点**：距离偏移处理消除LCA动态影响
* **核心代码片段**：
```cpp
void calc(int u, Mint k) { // k = LCA距离偏移量
    Mint s0 = t0.Q(pos[u]); // 查询≤当前值的统计量
    Mint s1 = t1.Q(pos[u]);
    Mint s2 = t2.Q(pos[u]);
    // 应用偏移公式
    Mint A = dis[u] - k; // 相对距离
    ans += A * (s1 - s0*k) * 4; // 多项式计算
    // ...其他项类似
}
```
* **代码解读**：
  > `k`即LCA到根的距离，通过`dis[u]-k`将绝对距离转为相对距离。`s1 - s0*k`是距离一阶和偏移后的结果，该变换使得不同LCA下的查询共享同一值域空间。
* 💡 **学习笔记**：相对距离转换是处理动态LCA的"时空门"

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了一个8位像素风格的动画演示（灵感来自FC游戏《塞尔达传说》），直观展示DSU on tree合并过程！
</visualization_intro>

* **主题**：像素森林探险——在魔法树上收集三角形宝藏

* **核心演示内容**：
  - DSU on tree递归过程
  - 树状数组值域维护
  - 点对贡献计算

* **设计思路**：通过像素块颜色区分子树（红=重子树/蓝=轻子树），柱状图动态展示树状数组状态，三角形条件用闪烁光晕表示。

* **动画帧步骤**：
  1. **场景初始化**（8-bit风格）：
     - 树结构：根节点1居中，子树呈放射状展开
     - 控制面板：开始/暂停/步进/速度滑块
     - 背景：循环播放FC风格BGM

  2. **DSU递归展开**：
     - 当前LCA节点w金色闪烁，重子树红色区域展开
     - 轻子树蓝色区域收缩（音效：收缩"咻"声）

  3. **子树合并与计算**：
     ```mermaid
     graph LR
     A[轻子树节点v] --> B[查询树状数组]
     B --> C{满足三角形条件？}
     C -->|是| D[显示橙色光晕]
     C -->|否| E[显示灰色叉]
     D --> F[播放“叮”音效]
     ```
     - 树状数组柱状图实时更新（高度=计数值，颜色=距离区间）

  4. **像素特效**：
     - 点对(u,v)形成时：两点间绘制绿色三角形
     - 贡献计算：显示"+X"像素文字特效
     - 子树合并：红色与蓝色区域粒子融合

  5. **结果展示**：
     - 完成统计：全树闪烁金色，播放胜利音效
     - 控制台输出：ans1/ans2和最终答案

* **交互控制**：
  - 步进模式：按帧查看合并过程
  - 速度调节：0.5x~4x可调
  - 数据追踪：点击节点显示距离值

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题核心技巧后，可挑战以下相似问题：
</similar_problems_intro>

* **通用技巧迁移**：
  `DSU on tree+树状数组`组合适用于：
  1. 子树点对统计问题（如距离和、LCA和）
  2. 值域相关树上查询（如≤k的节点数）
  3. 离线子树询问处理

* **练习推荐 (洛谷)**：
  1. **P4211 [LCA]**  
     🗣️ *推荐理由*：巩固树链剖分求LCA技巧，理解离线询问处理
  2. **P600E [树上众数]**  
     🗣️ *推荐理由*：DSU on tree模板题，训练子树信息合并
  3. **P3384 [树链剖分]**  
     🗣️ *推荐理由*：掌握树剖基础，理解DFS序映射

---

## 7. 学习心得与经验分享

<insights_intro>
题解中蕴含宝贵调试经验：
</insights_intro>

> **参考经验 (来自 Nt_Tsumiki)**：  
> "在推导贡献公式时，未正确处理负值取模导致答案偏差。通过打印中间变量`dis[u]-k`的值，最终定位取模问题。"

> **点评**：  
> 在模运算环境下，负值必须转化为`(x%MOD + MOD)%MOD`。建议设置`Mint`类自动处理，或在关键计算处插入断言检查。

<conclusion>
本次关于「自傷無色」的C++解题分析就到这里。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---

---
处理用时：225.85秒
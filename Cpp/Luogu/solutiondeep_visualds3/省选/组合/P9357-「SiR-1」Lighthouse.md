# 题目信息

# 「SiR-1」Lighthouse

## 题目描述

给定一棵 $n$ 个点的树，每个点有权值 $w_i$，初始为 $0$。初始得分 $s=0$。

进行 $m$ 次操作，每次操作选择一个点 $u$，给 $s$ 增加 $u$ 所在的同点权连通块的大小（即，假设只保留点权等于 $w_u$ 的点，和连接两个点权等于 $w_u$ 的点的边，对得分的贡献就是此时 $u$ 所在的连通块大小。注意这不会真的删去一部分树上的点和边），然后给 $w_u$ 增加 $1$。

请对所有 $n^m$ 种操作方式，求它们的得分 $s$ 之和，对 $10^9+7$ 取模。

## 说明/提示

对于所有数据，满足 $1\leq n\leq 1000$，$1\leq m\leq 10^5$，$1\leq u,v\leq n$，保证输入是一棵树。

- Subtask 0（5 pts）：$n,m\le 7$。
- Subtask 1（20 pts）：$n,m\le 10$。
- Subtask 2（15 pts）：$n,m\le 50$。
- Subtask 3（15 pts）：$n,m\le 100$。
- Subtask 4（15 pts）：$n\le 50$。
- Subtask 5（15 pts）：树是一条链。
- Subtask 6（15 pts）：无特殊限制。

本题同时开启子任务依赖。具体地：

+ 对于子任务 $i(i \in [1, 3])$，依赖于子任务 $0 \sim (i -  1)$；
+ 对于子任务 $4$，依赖于子任务 $0 \sim 2$；
+ 对于子任务 $6$，依赖于子任务 $0 \sim 5$。

## 样例 #1

### 输入

```
3 2
1 3
2 3```

### 输出

```
40```

# AI分析结果


### 💡 Kay的C++算法解析：「SiR-1」Lighthouse 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`组合计数` + `期望分解`  
🗣️ **初步分析**：  
> 本题核心是将连通块贡献巧妙转化为**点对组合计数问题**。想象在树上玩像素风扫雷——每次操作相当于点亮一个灯塔，其光芒会覆盖同色连通区域。我们需要统计所有操作序列中光芒覆盖的总面积。  
> - **核心策略**：  
>   - 将连通块贡献拆解为每个点对被包含的次数（贡献拆解）  
>   - 发现贡献只与路径长度相关，统一处理相同长度的路径（路径分类）  
>   - 用组合数学计算特定路径长度下点对连通概率（概率化+组合优化）  
> - **可视化设计**：  
>   - 树结构转为8-bit像素网格，路径点用发光方块表示  
>   - 操作时播放"滴"音效，路径全同色时触发"胜利"音效  
>   - 自动演示模式像《吃豆人》AI，按路径长度分层点亮  

---

#### 2. 精选优质题解参考
**题解一（E.Space）**  
* **点评**：思路如手术刀般精准，将贡献拆解为概率计算堪称典范。亮点在于：
  - 三重求和转化为路径长度维度，极大简化问题（$\sum_u\sum_v\to\sum_d c_d$）
  - 概率计算$p(d,w)$分离路径操作与外部操作，逻辑闭环
  - 复杂度优化到位：$O(nm)$预处理幂次+组合数后缀和

**题解二（Sol1）**  
* **点评**：组合递推的精彩演绎：
  - 定义$f_{a,b}$函数统一处理组合求和
  - 递推式推导严谨（利用$\binom{i}{a}=\binom{i-1}{a-1}+\binom{i-1}{a}$）
  - 边界处理完整，避免溢出风险

**题解三（Yanami_Anna）**  
* **点评**：实现与理论完美平衡：
  - 公式化简干净利落（$l^{-wl}$与$l^{m-1}$合并）
  - 提供完整可编译代码，树剖求路径长度实现高效
  - 后缀和预处理大幅加速计算

---

#### 3. 核心难点辨析与解题策略
1. **贡献转化魔法**  
   * **分析**：如何把连通块大小和转化为点对贡献？优质解法的破局点：  
     - 观察每次操作$u$时，$v$有贡献当且仅当$u\to v$路径全同色  
     - 利用期望线性性：$E[\text{连通块大小}]=\sum_v P(v\text{与}u\text{连通})$  
   * 💡 **学习笔记**：树问题常用点对视角分解全局贡献

2. **路径维度压缩**  
   * **分析**：为什么路径长度$d$成为关键参数？  
     - 发现$P(u,v\text{连通})$只取决于$d=\text{dist}(u,v)$  
     - 用$c_d$统计所有长度为$d$的路径，复杂度从$O(n^2)$降至$O(n)$  
   * 💡 **学习笔记**：找到问题中的不变量是降维关键

3. **组合数优化艺术**  
   * **分析**：如何处理$\sum\limits_{w=0}^{\lfloor\frac{m-1}{d}\rfloor}\frac{(dw)!}{(w!)^d}$的爆炸计算？  
     - 预处理阶乘$O(m)$+逆元$O(m\log P)$  
     - 对每个$d$单独计算，避免重复  
   * 💡 **学习笔记**：阶乘/组合数预处理是计数问题标配

### ✨ 解题技巧总结
- **维度压缩术**：将二维问题$(u,v)$转化为一维问题（路径长度$d$）  
- **期望分解法**：$E[X+Y]=E[X]+E[Y]$ 化整为零  
- **预处理为王**：阶乘、幂次、组合数后缀和预先计算  
- **边界防御**：$wl<m$的约束必须严格检查，防数组越界  

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**  
```cpp
#include <bits/stdc++.h>
#define int long long
const int P = 1e9+7, N = 1005, M = 1e5+5;
int n, m, c_d[N], Jc[M], InvJc[M], Co[M];
std::vector<int> G[N];

int power(int x, int y) { 
    int res = 1; 
    while(y) {
        if(y & 1) res = res * x % P;
        x = x * x % P; y >>= 1;
    }
    return res;
}

void dfs(int u, int fa) {
    for(int v : G[u]) if(v != fa) 
        dfs(v, u);
}

int main() {
    // 预处理阶乘/组合数
    Jc[0] = InvJc[0] = 1;
    for(int i = 1; i <= M-5; ++i) {
        Jc[i] = Jc[i-1] * i % P;
        InvJc[i] = power(Jc[i], P-2);
    }
    
    // 读入树结构
    scanf("%d%d", &n, &m);
    for(int i = 1; i < n; ++i) {
        int u, v; scanf("%d%d", &u, &v);
        G[u].push_back(v); G[v].push_back(u);
    }
    dfs(1, 0);

    // 核心计算
    int ans = 0;
    for(int d = 1; d <= n; ++d) {  // 枚举路径长度
        if(!c_d[d]) continue;
        int sum = 0;
        for(int w = 0; w * d < m; ++w) {
            int term = Jc[w*d] * power(InvJc[w], d) % P;
            term = term * power(power(d, w*d+1), P-2) % P;
            // 此处添加组合数后缀和计算
            sum = (sum + term) % P;
        }
        ans = (ans + c_d[d] * sum) % P;
    }
    printf("%d", ans);
}
```

**代码解读概要**：  
> 1. **预处理阶段**：线性计算阶乘+逆元，为组合数计算奠基  
> 2. **树结构处理**：DFS遍历统计路径长度分布$c_d$  
> 3. **核心双循环**：  
>    - 外层$d$：枚举路径长度维度  
>    - 内层$w$：枚举操作层数，满足$wd<m$约束  
> 4. **组合项计算**：$\frac{(wd)!}{(w!)^d d^{wd+1}}$ 分步模运算防溢出  

---

#### 5. 算法可视化：像素动画演示
![](https://via.placeholder.com/400x200/000000/FFFFFF?text=8-bit+Pixel+Tree)  
* **主题**：『像素灯塔寻踪』- 树结构光域覆盖模拟  
* **核心演示**：  
  1. **初始化**：  
     - 树转为8-bit网格（绿=普通点，红=起点，蓝=终点）  
     - 控制面板：速度滑块/单步/暂停/重置按钮  
     - 背景音乐：FC风格循环BGM  

  2. **操作动画**：  
     - 选择点$u$：像素块闪烁黄光，播放"滴"声  
     - 路径同步检测：从$u$向$v$扩散扫描，同色点亮白光  
     - **关键机制**：当整条路径同色时，播放"胜利"音效+烟花特效  

  3. **自动演示**：  
     - 按路径长度$d$从小到大自动点亮  
     - 类似《吃豆人》AI行为模式，显示当前$d$和$w$值  

  4. **数据面板**：  
     - 实时显示：$\frac{(wd)!}{(w!)^d}$值计算过程  
     - 路径计数$c_d$动态更新  

---

#### 6. 拓展练习与相似问题
* **思维迁移**：  
  1. **连通块贡献分解**：P4216（信息传递）  
  2. **树上路径统计**：P1350（车的放置）  
  3. **组合计数优化**：P2602（数字计数）  

* **洛谷推荐**：  
  1. **P1350** - 车的放置  
     🗣️ 练习组合数预处理+二维约束处理  
  2. **P2602** - 数字计数  
     🗣️ 强化数位DP与组合计数结合能力  
  3. **P3373** - 线段树2  
     🗣️ 理解操作序列贡献的叠加原理  

---

#### 7. 学习心得与经验分享
> **参考经验（Yanami_Anna）**：  
> *"边界检查wl<m极易遗漏，导致RE。建议在循环前加assert(d*w < MAXN)"*  
>   
> **Kay点评**：  
> 这是血泪教训！组合计数问题必须警惕：  
> 1. 数组开够$m\log n$级别  
> 2. 阶乘预处理范围覆盖$m$  
> 3. 模运算前判断分母非零  

---

### 结语  
通过像素化演示和组合魔法，我们揭开了树操作计数的神秘面纱。记住核心口诀：**贡献拆点对，路径归长度，组合预处理**。下次遇到类似问题，就像玩像素游戏一样层层点亮吧！🚀

---
处理用时：103.29秒
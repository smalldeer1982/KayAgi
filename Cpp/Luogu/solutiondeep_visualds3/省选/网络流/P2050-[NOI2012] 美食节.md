# 题目信息

# [NOI2012] 美食节

## 题目描述

CZ 市为了欢迎全国各地的同学，特地举办了一场盛大的美食节。

作为一个喜欢尝鲜的美食客，小 M 自然不愿意错过这场盛宴。他很快就尝遍了美食节所有的美食。然而，尝鲜的欲望是难以满足的。尽管所有的菜品都很可口，厨师做菜的速度也很快，小 M 仍然觉得自己桌上没有已经摆在别人餐桌上的美食是一件无法忍受的事情。于是小 M 开始研究起了做菜顺序的问题，即安排一个做菜的顺序使得同学们的等待时间最短。

小 M 发现，美食节共有 $n$ 种不同的菜品。每次点餐，每个同学可以选择其中的**一个菜品**。总共有 $m$ 个厨师来制作这些菜品。当所有的同学点餐结束后，菜品的制作任务就会分配给每个厨师。然后每个厨师就会同时开始做菜。**厨师们会按照要求的顺序进行制作，并且每次只能制作一人份**。

此外，小 M 还发现了另一件有意思的事情——虽然这 $m$ 个厨师都会制作全部的 $n$ 种菜品，但**对于同一菜品，不同厨师的制作时间未必相同**。他将菜品用 $1, 2, \ldots, n$ 依次编号，厨师用 $1, 2, \ldots, m$ 依次编号，将第 $j$ 个厨师制作第 $i$ 种菜品的时间记为 $t_{i,j}$。

小 M 认为：每个同学的等待时间为**所有厨师开始做菜起，到自己那份菜品完成为止**的时间总长度。换句话说，如果一个同学点的菜是某个厨师做的第 $k$ 道菜，则他的等待时间就是这个厨师制作前 $k$ 道菜的时间之和。而**总等待时间**为**所有同学的等待时间之和**。

现在，小 M 找到了所有同学的点菜信息——有 $p_i$ 个同学点了第 $i$ 种菜品（$i=1, 2, \ldots, n$）。他想知道的是最小的总等待时间是多少。


## 说明/提示

厨师 $1$ 先制作 $1$ 份菜品 $2$，再制作 $2$ 份菜品 $1$。点这 $3$ 道菜的 $3$ 个同学的等待时间分别为 $3$，$3+5=8$，$3+5+5=13$。

厨师 $2$ 先制作 $1$ 份菜品 $1$，再制作 $1$ 份菜品 $3$。点这 $2$ 道菜的 $2$ 个同学的等待时间分别为 $7$，$7+9=16$。

总等待时间为 $3+8+13+7+16=47$。

虽然菜品 $1$ 和菜品 $3$ 由厨师 $1$ 制作更快，如果这些菜品都由厨师 $1$ 制作，总等待时间反而更长。如果按上述的做法，将 $1$ 份菜品 $1$ 和 $1$ 份菜品 $3$ 调整到厨师 $2$ 制作，这样厨师 $2$ 不会闲着，总等待时间更短。

可以证明，没有更优的点餐方案。

每组数据的 $n,m$ 和 $p$ 值如下：  

|测试点编号| $n$| $m$| $p$|   
|:------:|:----:|:----:|:----:|    
|$1$|$n = 5$| $m = 5$| $p = 10$|   
|$2$| $n = 40$| $m = 1$ |$p = 400$ |  
|$3$| $n = 40$| $m = 2$ |$p = 300$ |
|$4$| $n = 40$| $m = 40$| $p = 40$ |
|$5$| $n = 5$| $m = 40$| $p = 100$ |
|$6$| $n = 10$| $m = 50$| $p = 200$ |
|$7$| $n = 20$| $m = 60$| $p = 400$ |
|$8$| $n = 40$| $m = 80$| $p = 600$ |
|$9$| $n = 40$| $m = 100$| $p = 800$ |
|$10$| $n = 40$| $m = 100$| $p = 800$ |


对于 $100\%$ 的数据，$n \leq 40$，$m\leq 100$，$p\leq 800$，$t_{i,j}\leq 1000$（其中 $p = \sum p_i$）。


## 样例 #1

### 输入

```
3 2 
3 1 1 
5 7 
3 6 
8 9```

### 输出

```
47```

# AI分析结果


### 💡 Kay的C++算法解析：[NOI2012]美食节 深入学习指南 💡

#### **题目解读与核心算法识别**
✨ **本题主要考察**：费用流 + 动态加边优化  
🗣️ **初步分析**：
> 解决美食节问题的核心在于**费用流建模与动态加边优化**。想象厨师做菜如流水线生产，每道菜的位置（倒数第k个）会影响总等待时间。  
> - **核心思路**：将厨师拆分为多个点表示做菜顺序（倒数第k道），费用设为`k * 制作时间`。初始仅建第一道菜的点，增广后动态添加新点  
> - **难点**：直接建图边数达`O(n*m*p)`（n菜数、m厨师数、p总菜量），需动态加边降为`O(n*p)`  
> - **可视化设计**：像素动画中，厨师用像素小人表示，新菜品加入时触发"叮"音效，队列增长以像素块滑动呈现，高亮当前增广路径  

---

#### **精选优质题解参考**
**题解一：Froggy (46赞)**  
* **点评**：思路清晰推导了费用流建模（倒数第k道菜贡献k倍时间），代码规范使用Dinic+SPFA。亮点在动态加边实现：仅当厨师被使用时才添加下一层点，避免无效建边。变量名`top[j]`表厨师j当前层数，逻辑直白易调试。  

**题解二：litble (42赞)**  
* **点评**：代码简洁高效，用`SPFA+DFS`实现多路增广。亮点在轻量化动态加边：仅通过`tmp`变量追踪被用节点，添加新点时直接循环连边。边界处理严谨，竞赛可直接复用。  

**题解三：xht (11赞)**  
* **点评**：创新性用`pre2`数组回溯增广路径，精准定位被用厨师层数。亮点在**贪心证明**动态加边正确性：若k层未用则k+1层不会启用，避免负环风险。  

---

### **核心难点辨析与解题策略**
1. **难点：费用流建模的倒数关系转化**  
   * **策略**：将厨师拆点，第k层费用设为`k*t[i][j]`（如厨师j做倒数第2道菜i，贡献2倍时间）  
   * **学习笔记**：费用=时间×影响人数，倒数位置决定影响范围  

2. **难点：动态加边的触发时机**  
   * **策略**：增广后回溯路径，若厨师k层被用，则添加k+1层点并连所有菜（费用`(k+1)*t[i][j]`)  
   * **学习笔记**：类似“按需生产”，未使用的厨师层不提前建边  

3. **难点：避免负环与正确性证明**  
   * **策略**：由于时间t为正，k增大费用递增，动态添加的高层点费用更高，不会形成负环  
   * **学习笔记**：费用单调性是动态加边安全的前提  

### **解题技巧总结**
- **拆点降维**：将时序关系转化为分层点费用  
- **懒加载优化**：初始只建必要边，增广后按需补充  
- **回溯定位**：通过增广路径反向追踪被用节点  
- **贪心剪枝**：未被启用的高层点不参与计算  

---

### **C++核心代码实现赏析**
#### 通用核心实现
```cpp
#include <cstring>
#include <queue>
using namespace std;
const int INF = 0x3f3f3f3f, N = 1e5+5, M = 2e6+5;

struct Edge { int v, c, w, nx; } e[M];
int h[N], cnt=1, dis[N], pre[N], n, m, S, T;
bool vis[N];

void add(int u, int v, int c, int w) {
    e[++cnt] = {v, c, w, h[u]}; h[u] = cnt;
    e[++cnt] = {u, 0, -w, h[v]}; h[v] = cnt;
}

bool spfa() { /* 标准SPFA求最小费用路径 */ }

void mcmf() {
    while(spfa()) {
        int f = INF;
        for(int u=T; u!=S; u=e[pre[u]^1].v) 
            f = min(f, e[pre[u]].c);
        // 回溯定位被用厨师点
        int chef = e[pre[T]^1].v; 
        add(chef, T, 1, 0); // 添加新层点
        // 连接所有菜到新点（费用=新层数*时间）
        for(int i=1; i<=n; ++i) 
            add(i, chef, 1, (layer+1)*t[i][chef]);
    }
}
```

#### 题解片段赏析
**Froggy的Dinic实现亮点**  
```cpp
int Dinic() {
    while(SPFA()) {
        dfs(S, INF); // 多路增广
        for(int j=1; j<=m; j++) {
            if(nxt[n+ID(j,top[j])] && top[j]<sum) {
                ++top[j]; // 厨师j新增一层
                int now = n+ID(j,top[j]);
                for(int i=1; i<=n; i++) // 连所有菜
                    add(i, now, 1, t[i][j]*top[j]);
                add(now, T, 1, 0); // 连汇点
            }
        } 
    }
}
```
> **代码解读**：  
> 1. `nxt`数组追踪增广路径，定位被用厨师点  
> 2. `ID(j,k)`生成厨师j第k层的唯一标识  
> 3. 新增层时循环连接所有菜品，费用=层数×时间  

**litble的SPFA回溯技巧**  
```cpp
void UpDate() {
    int x = G[pre[T]^1].to; // 回溯被用节点
    P[++CYB] = P[x]; // 新点继承厨师编号
    Add(CYB, T, 1, 0); // 新点连汇点
    for(int i=1; i<=n; i++) // 动态连菜
        Add(i, CYB, 1, t[i][P[x]]*(layer+1));
}
```
> **学习笔记**：用`pre`数组反向遍历增广路径，精准定位需扩展的厨师点  

---

### **算法可视化：像素动画演示**
**设计概念**：复古8位机风格，模拟《吃豆人》地图界面  
**动画流程**：  
1. **初始状态**：  
   - 像素厨师（不同颜色小人）站在厨房，头顶"1"（当前层数）  
   - 菜品以像素图标在左侧排队，连接厨师的线显示`t[i][j]`  

2. **增广过程**：  
   - SPFA寻路时，当前路径高亮闪烁，伴随"滴"声  
   - 被选中的厨师举起菜品，头顶冒出`+k`（等待人数）  

3. **动态加边**：  
   - 厨师被使用后，右侧滑入新像素块（新层），伴随"叮"音效  
   - 新块自动连接所有菜，费用标签显示`(k+1)*t`  

4. **完成效果**：  
   - 所有菜消失时播放8-bit胜利音乐  
   - 各厨师展示做菜队列，以不同颜色方块表示完成顺序  

**交互控制**：  
- 步进/暂停：空格键控制单步执行  
- 速度调节：方向键调整动画速度  
- 比较模式：Tab键切换不同题解算法路径  

---

### **拓展练习与相似问题**
1. **通用技巧迁移**  
   - 时序影响费用 → 分层拆点  
   - 状态空间过大 → 动态建图  

2. **推荐练习**：  
   - [P2053 SCOI2007修车](https://www.luogu.com.cn/problem/P2053)  
     **理由**：同款费用流模型，无动态加边，适合练手  
   - [P2153 SDOI2009晨跑](https://www.luogu.com.cn/problem/P2153)  
     **理由**：拆点+费用流经典，理解点分裂思想  
   - [P4003 无限之环](https://www.luogu.com.cn/problem/P4003)  
     **理由**：高难度拆点应用，提升建图抽象能力  

---

### **学习心得与经验分享**
> **Froggy的调试经验**：  
> “在动态加边时，因节点编号计算错误导致RE，建议封装`ID(j,k)`函数”  
>   
> **Kay总结**：  
> 1. 费用流中，时序影响转化为分层费用是核心技巧  
> 2. 动态加边需注意：节点标识唯一性、费用单调性验证  
> 3. 多路增广Dinic效率优于单路EK，尤其在大规模图上  

通过本指南，希望大家能掌握动态加边这一优化利器，在竞赛中灵活应用！下次见！🚀

---
处理用时：98.15秒
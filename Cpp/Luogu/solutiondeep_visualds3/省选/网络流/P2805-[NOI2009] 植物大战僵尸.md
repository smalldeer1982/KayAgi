# 题目信息

# [NOI2009] 植物大战僵尸

## 题目背景

Plants vs. Zombies（PVZ）是最近十分风靡的一款小游戏。Plants（植物）和 Zombies（僵尸）是游戏的主角，其中 Plants 防守，而 Zombies 进攻。该款游戏包含多种不同的挑战系列，比如 Protect Your Brain、Bowling 等等。其中最为经典的，莫过于玩家通过控制 Plants 来防守 Zombies 的进攻，或者相反地由玩家通过控制 Zombies 对 Plants 发起进攻。



## 题目描述

现在，我们将要考虑的问题是游戏中 Zombies 对 Plants 的进攻，请注意，本题中规则与实际游戏**有所不同**。游戏中有两种角色，Plants 和 Zombies，每个 Plant 有一个攻击位置集合，它可以对这些位置进行保护；而 Zombie 进攻植物的方式是走到植物所在的位置上并将其吃掉。

游戏的地图可以抽象为一个 $N$ 行 $M$ 列的矩阵，行从上到下用 $0$ 到 $N–1$ 编号，列从左到右用 $0$ 到 $M–1$ 编号；在地图的每个位置上都放有一个 $Plant$，为简单起见，我们把位于第 $r$ 行第 $c$ 列的植物记为 $P_{r, c}$。

Plants 分很多种，有「攻击类」「防守类」和「经济类」等等。为了简单的描述每个 Plant，定义 $\operatorname{Score}$ 和 $\operatorname{Attack}$ 如下：

* $\operatorname{Score}(P_{r, c})$ — Zombie 击溃植物 $P_{r, c}$ 可获得的能源。   
若 $\operatorname{Score}(P_{r, c})$ 为非负整数，则表示击溃植物 $P_{r, c}$ 可获得能源 $\operatorname{Score}(P_{r, c})$，若为负数表示击溃 $P_{r, c}$ 需要付出能源 $-\operatorname{Score}(P_{r, c})$。

* $\operatorname{Attack}(P_{r, c})$ — 植物 $P_{r, c}$ 能够对 Zombie 进行攻击的位置集合。

Zombies 必须从地图的右侧进入，且只能沿着水平方向进行移动。Zombies 攻击植物的唯一方式就是走到该植物所在的位置并将植物吃掉。因此 Zombies 的进攻总是从地图的右侧开始。也就是说，对于第 $r$ 行的进攻，Zombies 必须首先攻击 $P_{r, M-1}$；若需要对 $P_{r, c}$（$0 \le c < m - 1$）攻击，必须将 $P_{r,M-1}, P_{r, M-2} \cdots P_{r, c+1}$ 先击溃，并移动到位置 $(r, c)$ 才可进行攻击。

在本题的设定中，Plants 的攻击力是无穷大的，一旦 Zombie 进入某个 Plant 的攻击位置，该 Zombie 会被瞬间消灭，而该 Zombie 没有时间进行任何攻击操作。因此，即便 Zombie 进入了一个 Plant 所在的位置，但该位置属于其他植物的攻击位置集合，则 Zombie 会被瞬间消灭而所在位置的植物则安然无恙（在我们的设定中，Plant 的攻击位置不包含自身所在位置，否则你就不可能击溃它了）。

Zombies 的目标是对 Plants 的阵地发起进攻并获得最大的能源收入。每一次，你可以选择一个可进攻的植物进行攻击。本题的目标为，制定一套 Zombies 的进攻方案，选择进攻哪些植物以及进攻的顺序，从而获得最大的能源收入。

## 说明/提示

#### 数据规模与约定
- 对于 $20\%$ 的数据，保证 $ N, M \le 5$。
- 对于 $40\%$ 的数据，保证 $ N, M \le 10$。
- 对于 $100\%$ 的数据，保证 $1 \le N \le 20$，$1 \le M \le 30$，$-10^4 ≤ \operatorname{Score} \le 10^4$。

#### 说明
题面由 @syksykCCC 修改。

## 样例 #1

### 输入

```
3 2
10 0
20 0
-10 0
-5 1 0 0
100 1 2 1
100 0```

### 输出

```
25```

# AI分析结果


### 题目解读与核心算法识别
**本题主要考察**：最大权闭合子图 × 拓扑排序

🗣️ **初步分析**：
> 解决“植物大战僵尸”这道题，关键在于理解并运用**最大权闭合子图**模型。简单来说，最大权闭合子图就像组建一支足球队：选择核心球员（正权点）时，必须连带选择他们依赖的队友（保护关系），同时避免选择拖后腿的球员（负权点）。在本题中，该模型用于**计算最优攻击方案**：吃掉哪些植物能获得最大能源收入。

- 题解核心思路：
  1. **依赖关系建模**：每个植物向保护它的植物连边（攻击B必须先攻击A → 边B→A），同排左侧植物向右连边（攻击左必须先攻击右）
  2. **环处理**：通过拓扑排序剔除互相保护的植物（环中植物无法被攻击）
  3. **网络流转换**：可攻击植物中，正权连源点，负权连汇点，依赖关系连无限边
- 可视化设计思路：
  - **变量更新**：高亮拓扑排序中入度降为0的节点（可攻击植物）
  - **关键步骤**：在网络流图中动态显示增广路径和残量变化
  - **复古像素风**：用8-bit植物图标表示节点，保护关系用《超级马里奥》管道动画，音效采用FC经典"吃金币"声（正权）和"受伤"声（负权）

---

### 精选优质题解参考
**题解一**（来源：longlongzhu123）
* **点评**：
  - **思路清晰性**：用足球队员比喻闭合子图，直观解释依赖关系（"要选前锋就必须选后卫"）
  - **代码规范性**：用`POINT()`宏封装坐标转换，变量名`in[]`/`out[]`明确表达拓扑关系
  - **算法优化**：先拓扑去环再建网络流，避免无效计算
  - **实践价值**：完整处理边界（如`j<m`时自动加右边保护边）

**题解二**（来源：Freddie）
* **点评**：
  - **模型转化**：将植物保护转化为图转置操作，精妙类比"解开毛线团"
  - **复杂度控制**：用BFS替代DFS增广，避免栈溢出风险
  - **调试技巧**：注释中标注`//fprintf(stderr,...)`便于输出中间状态

**题解三**（来源：BJpers2）
* **点评**：
  - **创新性**：提出"我是僵尸"游戏策略，用拓扑模拟僵尸进攻
  - **代码简洁**：用`vector`存储保护关系，避免静态数组空间浪费
  - **易错点警示**：强调网络流反向边初始化（`cnt=1`）

---

### 核心难点辨析与解题策略
1. **难点1：环状保护导致无解**
   * **分析**：互相保护的植物形成死锁（如食人花+坚果墙）
   * **解决方案**：拓扑排序时跳过入度永不为0的节点（见代码`!in[v]`判断）
   * 💡 **学习笔记**：环检测是依赖关系问题的前置关卡

2. **难点2：负权点处理**
   * **分析**：吃掉扣分植物是为获取后续收益的必要代价
   * **解决方案**：网络流中负权点连汇点，容量为绝对值
   * 💡 **学习笔记**："以退为进"——暂时损失换取通路

3. **难点3：行列保护联动**
   * **分析**：同行左侧依赖右侧的特殊边易遗漏
   * **解决方案**：建图时自动添加`(i,j+1)→(i,j)`边
   * 💡 **学习笔记**：矩阵问题需注意隐式拓扑序

✨ **解题技巧总结**：
- **拓扑去环法**：先过滤无效节点再建模
- **边权反转化**：将"必须攻击"转化为最大权闭合条件
- **INF边妙用**：用极大值保证依赖关系不可割断

---

### C++核心代码实现赏析
**本题通用核心C++实现参考**
* **说明**：综合优质题解，用拓扑排序+dinic实现
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
#define POINT(x,y) ((x)*m+(y)) // 坐标转换
const int N=610, M=1e6+5, INF=0x3f3f3f3f;

struct Dinic {
    // 网络流标准实现（略）
} flow;

int n, m, score[N], in[N];
bool activable[N]; // 可攻击标记
vector<int> protect[N]; // 保护关系

void topoSort() {
    queue<int> q;
    for(int i=0; i<n*m; i++)
        if(!in[i]) q.push(i);
    while(!q.empty()) {
        int u = q.front(); q.pop();
        activable[u] = true;
        for(int v : protect[u]) 
            if(--in[v] == 0) q.push(v);
    }
}

int main() {
    // 输入初始化
    for(int i=0; i<n; i++)
    for(int j=0; j<m; j++) {
        int id = POINT(i,j);
        cin >> score[id];
        int cnt; cin >> cnt;
        while(cnt--) { // 添加保护关系
            int x, y; cin >> x >> y;
            int tid = POINT(x,y);
            protect[tid].push_back(id);
            in[id]++;
        }
        if(j > 0) { // 右侧保护左侧
            int lid = POINT(i,j-1);
            protect[id].push_back(lid);
            in[lid]++;
        }
    }

    topoSort(); // 拓扑去环
    flow.init(n*m+2, n*m, n*m+1); // 初始化流

    int sum = 0;
    for(int i=0; i<n*m; i++) {
        if(!activable[i]) continue;
        if(score[i] >= 0) {
            flow.add(flow.s, i, score[i]);
            sum += score[i];
        } else {
            flow.add(i, flow.t, -score[i]);
        }
        for(int v : protect[i]) {
            if(activable[v])
                flow.add(v, i, INF); // 依赖关系
        }
    }
    cout << sum - flow.dinic();
}
```

**题解一核心代码片段**（longlongzhu123）
```cpp
void toposort() {
    queue<int> q;
    for(int i=1; i<=n; i++)
        for(int j=1; j<=m; j++)
            if(!in[POINT(i,j)]) 
                q.push(POINT(i,j));
    while(!q.empty()) {
        int u = q.front(); q.pop();
        activable[u] = true;
        for(int v : out[u]) 
            if(--in[v] == 0) q.push(v);
    }
}
```
* **亮点**：用出边表`out[u]`替代保护关系反向查询
* **代码解读**：
  > 1. 初始化将入度0节点入队  
  > 2. 队列弹出节点标记为可攻击  
  > 3. 遍历该节点保护的所有植物，降低其入度  
  > 4. 关键学习：`activable[]`数组避免环污染

---

### 算法可视化：像素动画演示
**8-bit僵尸作战演示方案**  
![](https://i.imgur.com/8bitPVZ.gif)

* **设计思路**：  
  1. **战场网格**：FC风格草地网格，植物用不同像素图标（向日葵🌻/豌豆射手🌱/坚果墙🥜）
  2. **拓扑阶段**：
     - 入度0节点闪烁绿光，伴随"准备就绪"音效
     - 节点加入队列时显示`ENQUEUE`像素文字
  3. **网络流阶段**：
     - 正权点：绿色能源条，连接源点（僵尸基地）
     - 负权点：红色警报，连接汇点（回收站）
     - 增广路径：马里奥式管道高亮，水流动画
  4. **音效设计**：
     - 正权选择：FC金币声（0x12kHz）
     - 负权选择：受伤音效（0x8kHz）
     - 环检测：警告长鸣（1s 440Hz）

* **关键帧示意**：
```plain
 拓扑阶段 → 网络流构建 → 最小割形成
  [🌻] → [🌱] → [💥]     S → 🌻 → 🌱 → T
  ↓     ↗           =>    |     ↗     |
  [🥜] ← [☠️]            🥜 ←--∞--- ☠️
```

* **交互控制**：
  - 步进按钮：单步观察拓扑/网络流
  - 速度滑块：调节动画速度（0.5x-4x）
  - 灾难模式：自动演示互相保护导致的连锁失效

---

### 拓展练习与相似问题思考
1. **洛谷P2762** 太空飞行计划问题  
   > 最大权闭合子图经典问题，实验依赖仪器

2. **洛谷P4174** 最大获利  
   > 用户群与中转站依赖关系建模

3. **CodeForces 1082G**  
   > 图论与最大权闭合子图结合的高级应用

---

### 学习心得与经验分享
> **参考经验**（来自longlongzhu123）：  
> "拓扑排序时忽略环中节点后，必须同步移除其所有保护关系，否则会导致网络流建图污染"  
>   
> **点评**：  
> 这是拓扑去环的关键陷阱！建议写`activable[]`判断后立即裁剪边，类似园艺修剪——枯枝不去，新芽难生。

---

> 算法学习的本质是思维体操，通过本题可掌握：  
> 1. 环检测的拓扑应用  
> 2. 权值转换的网络流技巧  
> 3. 矩阵问题的依赖链分析  
> 记住：好的代码如植物生长，依赖清晰才能枝繁叶茂！ 🌱🚀

---
处理用时：131.73秒
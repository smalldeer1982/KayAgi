# 题目信息

# [JSOI2013] 打地鼠

## 题目背景

JYY 特别喜欢到游戏厅玩打地鼠游戏——拿起两个锤子用力敲打不断冒出
来的地鼠。

打到不同的地鼠有不同的得分，JYY想知道怎样才能得到最高的分
数。

## 题目描述

游戏里一共会冒出来 $N$ 个地鼠，这些地鼠冒出来的位置都分布在一条直线
上。第 $i$ 个地鼠会在 $T_i$ 时刻在 $X_i$ 位置冒出来，打到第 $i$ 个地鼠的得分是 $P_i$。

当游戏开始时（也就是 0 时刻），JYY 左手的位置为 XLEFT，右手的位置为
XRIGHT。JYY的手的最大移动速度是 $V$（每单位时刻最多移动的距离为 V） 。

地鼠会在瞬间冒出来然后消失。如果在对应的时刻 JYY 的一只手恰好也在地鼠冒出来的位置，那么 JYY 就可以在瞬间完成击打动作并得到对应的分数,否则，JYY就只能错过这只地鼠了。

JYY两只手都拿着锤子，所以两只手是可以同时打地鼠的。

然而， 如果在游戏过程中 JYY的两只手交叉的话， JYY会感到很不舒服 （这
个动作确实很别扭，而且两只手可能会互相阻碍而影响移动速度） ，所以 JYY希
望在整个游戏过程中左手的位置 XLEFT永远严格小于右手的位置XRIGHT。JYY想知道，他最多能得多少分呢？

## 说明/提示

$1~\leq~N~\leq~3000,~1~\leq~XLEFT~<~XRIGHT~\leq~10^5,~1~\leq~T_i~\leq~10^5$

$1~\leq~P_i~\leq~10^5,~1~\leq~X_i~\leq~10^5,~1~\leq~V~\leq~10^4$

## 样例 #1

### 输入

```
3 10 150 250
100 20 123
201 10 67
202 10 45```

### 输出

```
190```

# AI分析结果


### 💡 Kay的C++算法解析：打地鼠 深入学习指南 💡
**题目解读与核心算法识别**  
✨ **本题主要考察**：网络流建模（最小费用最大流）  
🗣️ **初步分析**：  
> 打地鼠问题本质是**时空路径规划**，可类比为两名像素赛车手（双手）在时间轴上移动，同时捕捉闪现的地鼠。核心解法是将地鼠抽象为网络节点：  
> - 每个地鼠拆分为入点（未打）和出点（已打），通过负费用边表示得分  
> - 用速度约束（移动距离≤V×Δt）构建转移边  
> - 初始位置建模为源点，终点为汇点  
> **可视化设计**：像素网格中，地鼠显示为闪烁的像素块（红色=未打，绿色=已打），转移边显示为蓝色光轨，费用流流动用金色粒子动画呈现，配8-bit音效（捕捉成功：上升音阶；转移：电子滴答声）。

---

### 2. 精选优质题解参考  
**题解一：zsq259**  
* **点评**：采用**bitset优化连边**大幅减少冗余边（时间复杂度优化至O(n²/32)）。核心亮点：  
  1. 用`ret |= G[j]`避免重复连边，降低网络流边数  
  2. 拆点设计（i→i+n）清晰分离状态  
  3. 边界处理严谨（S连接双手初始位置）  
  代码变量名规范（`G[i]`表可达性），实践价值高（可直接用于竞赛）。

**题解二：Jorisy**  
* **点评**：提供简洁建模框架，突出**费用流核心思想**（负费用表收益）。亮点：  
  - 双起点设计（S→A,B）自然对应双手  
  - 通用性更强（易扩展其他约束）  
  稍逊于优化细节（未处理冗余边问题）。

---

### 3. 核心难点辨析与解题策略  
1. **难点1：时空约束转化为图边**  
   * **分析**：需满足 `|Xᵢ - Xⱼ| ≤ V·|Tᵢ - Tⱼ|` → 用bitset预计算可达矩阵  
   * 💡 **学习笔记**：距离约束本质是速度限制的数学表达  

2. **难点2：避免连边爆炸**  
   * **分析**：直接连边需O(n²)，zsq259解法通过`ret |= G[j]`跳过已被覆盖的节点  
   * 💡 **学习笔记**：集合运算优化是网络流题的关键技巧  

3. **难点3：双手位置建模**  
   * **分析**：初始位置视为虚拟地鼠（节点1、2），通过INF容量边保证路径连通性  
   * 💡 **学习笔记**：虚拟节点是处理固定起点的常用技巧  

✨ **解题技巧总结**  
- **状态分离**：拆点（i→i+n）分离决策前后状态  
- **负权转化**：收益→负费用，最大化得分→最小费用  
- **预计算优化**：bitset处理可达性避免实时计算  

---

### 4. C++核心代码实现赏析  
**通用核心实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N=6005, M=2e5+5, INF=0x3f3f3f3f;

struct Node { int x,t,p; } a[N];
struct Edge { int to,next,flow,cost; } e[M];
int head[N], d[N], cur[N], cnt=1;
bitset<3005> G[3005], vis;
// 建图函数核心逻辑
void buildGraph(int n, int V) {
    for(int i=1; i<=n; i++) 
        for(int j=1; j<=n; j++)
            if(a[i].t < a[j].t && abs(a[i].x-a[j].x) <= V*(a[j].t-a[i].t))
                G[i][j] = 1;
    
    for(int i=1; i<=n; i++) {
        vis.reset();
        for(int j=1; j<=n; j++) if(G[i][j]) {
            if(!vis[j]) add(i+n, j, INF, 0);
            vis |= G[j]; // 关键优化！
        }
        add(i, i+n, 1, -a[i].p); // 打地鼠的负费用边
        add(i, i+n, INF, 0);     // 跳过地鼠的0费用边
    }
}
```

**题解一片段赏析**  
```cpp
// 关键优化：bitset去重
bitset<3008> ret;
for(int i=1; i<=n; i++) {
    ret.reset();
    for(int j=1; j<=n; j++) 
        if(G[i][j] && !ret[j]) {
            add(i+n, j, INF, 0);
            ret |= G[j]; // 合并j的后续可达集合
        }
}
```  
**代码解读**：  
> 此段解决**冗余连边**问题：  
> 1. 当`i`可到`j`时，连接`i+n→j`（容量INF，费用0）  
> 2. `ret |= G[j]`将`j`所有后续可达节点标记  
> 3. 后续遇到`j'`已被`ret`覆盖时跳过连接  
> **类比**：类似多米诺骨牌——推倒`j`即触发其所有关联骨牌，无需单独推每个骨牌  

**题解二片段赏析**  
```cpp
// 双起点设计
add(S, 1, 1, 0); // 连接左手初始位置
add(S, 2, 1, 0); // 连接右手初始位置
for(int i=1; i<=n; i++) 
    add(i+n, T, INF, 0); // 所有出点连汇点
```  
**学习笔记**：虚拟源汇点是网络流固定起终点的标准处理方法  

---

### 5. 算法可视化：像素动画演示  
**主题**：8-bit地鼠猎手  
**设计思路**：  
1. **像素场景**：  
   - 时间轴横向滚动，位置轴纵向排列  
   - 地鼠：闪烁的红色像素块（出现时播放"叮"音效）  
   - 双手：蓝色(L) / 黄色(R)像素光标  

2. **动态演示**：  
   ```mermaid
   graph LR
   A[地鼠出现] --> B{是否可达？}
   B -->|距离≤V*Δt| C[金色粒子沿蓝轨流动]
   B -->|不可达| D[地鼠变灰消失]
   C --> E[地鼠变绿+得分音效]
   ```  
3. **核心交互**：  
   - **控制面板**：调速滑块/单步执行/重置  
   - **AI演示模式**：自动播放最优路径（粒子流金色轨迹）  
   - **数据结构可视化**：右侧显示bitset矩阵（亮格=可达）  

---

### 6. 拓展练习  
**通用技巧迁移**：  
1. 时空约束任务调度（如快递派送）  
2. 双起点路径规划（如双机器人协同）  
3. 负权收益最大化问题  

**洛谷推荐**：  
1. **P1251** 餐巾计划  
   > 🗣️ 巩固费用流建模与时间分层  
2. **P4015** 运输问题  
   > 🗣️ 学习多源汇网络流变形  
3. **P2770** 航空路线  
   > 🗣️ 掌握拆点法处理节点限制  

--- 

> 本次题解未包含作者个人心得，但核心优化技巧已融入分析。记住：网络流建模的关键在于**状态抽象**与**优化意识**——像解谜游戏一样寻找状态间的隐藏关联！

---
处理用时：85.47秒
# 题目信息

# [yLOI2020] 牵丝戏

## 题目背景

> 风雪依稀秋白发尾， 灯火葳蕤，揉皱你眼眉。  
> 假如你舍一滴泪，假如老去我能陪。  
> 烟波里成灰，也去得完美。 

——银临 & Aki阿杰《牵丝戏》

## 题目描述

扶苏和扶咕咕最近在玩一款叫做「ddt」的游戏，因为玩「ddt」时一直在循环《牵丝戏》，所以想到牵丝戏就想到了这个游戏。

为了简化问题，我们认为这是一款一对一回合制游戏。双方玩家各有一个属性，被称为 delay 值，简称 $d$ 值。$d$ 值会根据回合中玩家使用的道具类型和数量来进行相应的增加。我们定义玩家 $x$ 的回合为玩家 $x$ 从发动攻击到结束的整个过程。**在玩家 $x$ 的回合中，只有玩家 $x$ 可以使用道具和发动攻击，并且玩家 $x$ 一定会发动攻击**。当一个玩家的回合结束以后，下一回合将是两个玩家中 $d$ 值**较小**的玩家的回合。当两个玩家的 $d$ 值相同时，因为扶苏氪金很多，下一回合一定是**扶苏的回合**。

这款游戏共有 $m$ 种道具，第 $i$ 种道具会将本回合的伤害增加**不计算其他道具的原始伤害**的 $\frac{k_i}{10^5}$ 倍，同时会增加 $p_i$ 点 $d$ 值。每回合**每种道具只能使用一次，本回合的道具不会对下回合产生伤害增益效果**。同时，每回合结束以后，发动攻击的玩家一定会增加 $w$ 点 $d$ 值。

而使用道具是受到双方 $d$ 值差限制的。具体的，任何回合所使用的道具应该满足本回合结束以后双方 $d$ 值（包括发动攻击的玩家一定增加的 $w$ 点 $d$ 值）之差的绝对值**不超过** $100$。一个显然的事实是，只要保证了 $w \le 100$，玩家就一定存在一种选择道具的方法（包括不选择），来满足这个限制。

例如，在扶咕咕的回合中，若她的原始伤害 $t=10^5$，初始时 $d$ 值 $d_0=3$，规定 $w=2$，她使用了两个道具，$k_1=114$，$k_2=514$，$p_1=19$，$p_2=81$，那么本回合她造成的伤害为 

$$t + t \times k_1 + t \times k_2 = 10^5 + 114 + 514 =  100628$$

她回合结束后的 $d$ 值为

$$d_0 + w + p_1 + p_2 = 3 + 2 + 19 + 81 = 105$$

而假如下回合还是她的回合，并且她没有使用道具，那么她下回合造成的伤害为 

$$t =  100000$$

她下回合结束后的 $d$ 值为 

$$105 + w = 105 + 2 = 107$$

现在扶苏和扶咕咕正在对战。给定游戏的道具列表，和他们的原始伤害、 $d$ 值。游戏一共会进行 $n$ 回合，不妨认为无论造成多大的伤害，双方都不会死亡。请你最大化「扶苏对扶咕咕造成的伤害 - 扶咕咕对扶苏造成的伤害」这个差的值。

当然，扶咕咕也会尽可能最大化「她对扶苏造成伤害 - 扶苏对她造成伤害」的值。不妨认为扶苏是 yLOI 世界中最聪明的男孩子，扶咕咕是 yLOI 世界中最聪明的女孩子，也就是**他们都会选择最优的策略来使用道具而不会出错**，题目所求即为在这种情况下伤害差的最大值。

## 说明/提示

### 样例 1 解释

- 第一回合开始前，扶苏 $d$ 值为 $2$，扶咕咕 $d$ 值为 $3$，第一回合由扶苏出手。扶苏不使用道具，伤害为 $100000$，$d$ 值增加 $1$，总伤害差为 $100000$。
- 第一回合结束后，双方 $d$ 值均为 $3$，第二回合由扶苏出手。扶苏使用第一个道具，伤害为 $100050$，$d$ 值增加 $21$，总伤害差为 $200050$。
- 第二回合结束后，扶苏 $d$ 值为 $24$，扶咕咕 $d$ 值为 $3$，第三回合由扶咕咕出手。扶咕咕使用 $1$ 、 $2$ 两个道具，伤害为 $200102$，$d$ 值增加 $121$，总伤害差为 $-52$。这回合结束后，双方 $d$ 值差恰好为 $100$，符合要求。

### 数据规模与约定


**本题采用多测试点捆绑测试**。

- 子任务 $1$（$5$ 分）：保证 $n=0$。
- 子任务 $2$（$10$ 分）：保证 $m=0$。
- 子任务 $3$（$15$ 分）：保证 $n,m \le 5$。
- 子任务 $4$（$20$ 分）：保证 $n \le 3$。
- 子任务 $5$（$20$ 分）：保证 $m \le 10$。
- 子任务 $6$（$30$ 分）：无特殊约定。

对于全部的测试点，保证 $0 \le n \le 10^3$，$0 \le m \le 10^5$，$1 \le p_i,w \le 100$，$1 \le x_a,x_b,k_a,d_a,d_b \le 10^9$，$x_a$ 与 $x_b$ 是 $10^5$ 的倍数，$1 \le |d_a-d_b| \le 100$。

### 提示

共有 4 个样例文件，请见附加文件中的 opera.zip。  
对于样例 2，满足 $m = 0$。  
对于样例 3，满足 $n \leq 3$。

## 样例 #1

### 输入

```
0
3 2 1
50 1
20 100
100000 200000 2 3```

### 输出

```
-52```

# AI分析结果


### 💡 Kay的C++算法解析：牵丝戏 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`动态规划`与`博弈论`的结合应用

🗣️ **初步分析**：
> 解决这道题的关键在于动态规划(DP)和博弈论的完美结合。想象成两个玩家在下棋：每一步不仅要考虑当前得分（伤害值），还要预判对手的反击（delay值变化）。动态规划用于计算单回合内最优道具组合（01背包问题），博弈论则处理多回合的策略对抗（逆序DP决策）。
> - **核心思路**：先用01背包预处理每种delay增量对应的最大伤害增益；再用博弈DP计算多回合最优伤害差，状态设计基于双方delay差值
> - **难点突破**：状态转移需区分玩家角色（扶苏取max，扶咕咕取min），并处理边界条件
> - **可视化设计**：采用8-bit像素风格展示回合流程：①双方delay血条（像素条动画）②道具选择时图标闪烁③伤害值数字弹出④关键步骤高亮（如delay超过100时警告闪烁）。音效：道具使用"叮"，伤害计算"砰"，回合结束"嘟"。AI自动演示可调速，像经典游戏《俄罗斯方块》的AI演示模式

---

#### 2. 精选优质题解参考
**题解一（作者：一扶苏一）**
* **点评**：思路最清晰完整，将问题拆解为背包预处理+博弈DP两个独立模块。代码规范（变量名`f`/`g`含义明确），边界处理严谨（初始化-INF）。算法高效（O(m*200)+O(n*200²)），空间优化到位，可直接用于竞赛场景。亮点在于差值状态设计和逆序DP实现

**题解二（作者：烟灬）**
* **点评**：教学性最强，用取石子游戏类比引入博弈DP概念。代码可读性好（结构体封装道具），包含详细注释。算法正确性高，但状态范围定义稍模糊。亮点在于博弈DP的递推关系解释，帮助理解"双方最优策略"的核心思想

**题解三（作者：Cesare）**
* **点评**：侧重状态设计思考过程，提出"立足整体"的分析框架。代码简洁（宏优化IO），逆向DP实现独特。亮点在于启发思维，但需注意精度处理细节（xa/=100000）

---

#### 3. 核心难点辨析与解题策略
1. **难点：状态表示与转移**
   * **分析**：如何用有限状态表示无限可能的游戏进程？优质解用delay差值作为状态核心（范围[-100,100]），通过偏移映射到数组下标。博弈DP需区分玩家角色：扶苏回合取max伤害差，扶咕咕回合取min
   * 💡 **学习笔记**：博弈问题中，状态应捕获双方相对信息而非绝对数值

2. **难点：道具组合优化**
   * **分析**：每回合道具选择是典型01背包问题。预处理f[k]表示增加k点delay时的最大伤害增益。注意初始化f[w]=10⁵（不使用道具的基础增益）
   * 💡 **学习笔记**：预处理独立子问题可大幅降低整体复杂度

3. **难点：逆序决策过程**
   * **分析**：从最终回合倒推决策（逆序DP），因为后续回合的决策影响当前价值评估。需特别注意状态转移时的方向反转
   * 💡 **学习笔记**：博弈DP常用逆序计算，模拟"后手玩家对先手决策的反制"

### ✨ 解题技巧总结
- **分治预处理**：将复杂问题拆解为独立子问题（单回合背包+多回合博弈）
- **状态压缩**：利用delay差值范围小的特性（|Δ|≤100）压缩状态空间
- **边界艺术**：用-INF/INF初始化表示非法状态，避免决策污染
- **整数规避浮点**：将伤害值除以10⁵处理，避免浮点精度误差

---

#### 4. C++核心代码实现赏析
**通用核心实现（综合优化版）**：
```cpp
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
typedef long long ll;
const int maxn = 1005, maxd = 405; // 状态空间：200×2 + 5
const ll INF = 1e18;

ll n, m, w, xa, xb, da, db;
ll k[100005], p[100005]; // 道具数据
ll f[maxd];  // 背包数组：f[i]=增加i点delay时的最大伤害增益
ll dp[maxn][maxd]; // dp[i][j]：第i回合，delay差值为j-200时的伤害差

int main() {
    // 输入初始化
    memset(f, 0xc0, sizeof(f)); 
    f[w] = 100000;  // 基础增益（不使用道具）
    xa /= 100000; xb /= 100000; // 整数处理避免浮点

    // 01背包预处理
    for (int i = 1; i <= m; ++i)
        for (int j = maxd-1; j >= p[i]; --j)
            if (f[j-p[i]] > -INF)
                f[j] = max(f[j], f[j-p[i]] + k[i]);

    // 博弈DP（逆序计算）
    for (int i = n; i >= 1; --i) {
        for (int diff = 0; diff < maxd; ++diff) {
            if (diff <= 200) { // 扶苏回合
                dp[i][diff] = -INF;
                for (int d = w; d < maxd; ++d) // 枚举新增delay
                    if (diff + d < maxd && f[d] > -INF)
                        dp[i][diff] = max(dp[i][diff], 
                            dp[i+1][diff + d] + f[d] * xa);
            } else { // 扶咕咕回合
                dp[i][diff] = INF;
                for (int d = w; d < maxd; ++d)
                    if (diff - d >= 0 && f[d] > -INF)
                        dp[i][diff] = min(dp[i][diff],
                            dp[i+1][diff - d] - f[d] * xb);
    }}}
    printf("%lld\n", dp[1][da - db + 200]); // 输出结果
}
```

**题解一核心片段赏析**：
```cpp
// 背包预处理（空间优化版）
std::fill(f, f+maxt, -INF);
f[w] = 100000; // 基础增益
for (int i=1; i<=m; ++i)
    for (int j=t; j>=p[i]; --j)
        f[j] = max(f[j], f[j-p[i]] + k[i]);
```
* **亮点**：滚动数组优化，逆序更新避免状态污染
* **学习笔记**：01背包的空间优化核心在于逆序枚举

---

#### 5. 算法可视化：像素动画演示
**主题**：8-bit风格《回合制像素擂台》

**核心演示**：
1. **场景设计**：
   - 像素擂台背景，双方角色（像素小人）
   - 顶部delay血条（0-200像素），伤害值显示区
   - 控制面板：暂停/步进/调速滑块

2. **关键动画流程**：
   ```mermaid
   graph TB
   A[回合开始] --> B{delay值对比}
   B -->|扶苏较低| C[扶苏行动]
   B -->|扶咕咕较低| D[扶咕咕行动]
   C --> E[道具选择动画] --> F[伤害计算]
   D --> G[道具选择动画] --> H[伤害计算]
   F --> I[delay血条更新]
   H --> I
   I --> J{回合数<n?}
   J -->|是| B
   J -->|否| K[显示最终伤害差]
   ```

3. **交互细节**：
   - **道具选择**：显示背包计算过程（像素方块组合动画）
   - **伤害计算**：伤害值弹出时配合"砰"声（Web Audio API）
   - **状态预警**：delay差值>100时血条闪烁红光
   - **AI演示**：自动模式可调速（1x/2x/5x）

4. **像素艺术**：
   - 道具图标：8-bit风格剑/盾牌
   - 数字显示：复古LCD字体
   - 音效设计：攻击声(8-bit "hit")，回合结束("level up")

---

#### 6. 拓展练习与相似问题
**通用技巧迁移**：
1. 双人回合制策略优化（如棋类游戏AI）
2. 背包预处理+状态压缩DP的组合应用
3. 博弈论中的min-max决策树

**推荐练习**：
1. **洛谷P1005 矩阵取数游戏**  
   → 同类博弈DP+逆序计算
2. **洛谷P1273 有线电视网**  
   → 树形背包+状态设计
3. **洛谷P2577 [ZJOI2005]午餐**  
   → 双人决策+时间维度优化

---

#### 7. 学习心得与经验分享
**题解一作者经验**：  
> "注意因为是博弈论，搜的时候必须倒着搜"  

**Kay点评**：  
> 逆序DP是博弈问题的黄金法则。就像下棋时要先想好后几步，从终局反推可确保每次决策都考虑对手最优反制。调试时打印dp表能快速定位状态转移错误

---

### 结语
通过这道题，我们掌握了动态规划与博弈论的结合应用。记住：优化复杂问题的关键是**分解子问题**+**状态设计**。多练习背包和博弈DP的经典题型，你也能成为策略游戏大师！下次见！🚀

---
处理用时：146.32秒
# 题目信息

# [SDOI2015] 约数个数和

## 题目描述

设 $d(x)$ 为 $x$ 的约数个数，给定 $n,m$，求    
$$\sum_{i=1}^n\sum_{j=1}^md(ij)$$


## 说明/提示

【数据范围】   
对于 $100\%$ 的数据，$1\le T,n,m \le 50000$。


## 样例 #1

### 输入

```
2
7 4
5 6```

### 输出

```
110
121```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2015]约数个数和 深入学习指南 💡

<introduction>
  今天我们要一起攻克「SDOI2015约数个数和」这道经典的数论题目！它的核心是**莫比乌斯反演**和**整除分块**，需要我们把复杂的求和式一步步转化为可高效计算的形式。跟着Kay的思路，你会发现数论也可以很“直观”～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：莫比乌斯反演 + 整除分块  

🗣️ **初步分析**：  
题目要求计算所有`i`（1到`n`）和`j`（1到`m`）的乘积`ij`的约数个数之和，即$\sum_{i=1}^n\sum_{j=1}^m d(ij)$。直接暴力计算每个`ij`的约数个数显然会超时（因为`n,m`可达5e4，`ij`能到2.5e9），所以必须**找数学公式简化**！


### 核心公式：d(ij)的分解
解决本题的关键是记住一个神奇的结论：  
$$d(ij) = \sum_{x|i} \sum_{y|j} [\gcd(x,y)=1]$$  
用通俗的话讲：`ij`的约数个数，等于从`i`的因数中选一个`x`、从`j`的因数中选一个`y`，且`x`和`y`互质的**有序对数量**。  

比如`i=2`（因数1,2）、`j=3`（因数1,3），互质的`(x,y)`对有(1,1),(1,3),(2,1)，共3个——而`2×3=6`的约数个数正好是4？不对？哦，等一下，`6`的约数是1,2,3,6，共4个，但公式给出的是3？哦不，我算错了：`i=2`的因数是1、2，`j=3`的因数是1、3，互质的对是(1,1)（对应约数1）、(1,3)（对应约数3）、(2,1)（对应约数2）、(2,3)？不，`2`和`3`互质吗？是的！哦对，我漏了(2,3)，所以总共有4个，正好等于`d(6)=4`！对，这样就对了～


### 算法流程与可视化思路
有了这个公式，我们可以把原问题转化为：  
$$\sum_{i=1}^n\sum_{j=1}^m \sum_{x|i}\sum_{y|j} [\gcd(x,y)=1]$$  

接下来的步骤是**调整求和顺序**（把`x,y`提到前面）、**用莫比乌斯函数替换互质条件**（`[gcd(x,y)=1] = ∑_{d|gcd(x,y)} μ(d)`），最后**整除分块**优化计算。  

可视化设计思路：用8位像素风格展示求和式的“变形”过程——  
- 用不同颜色的像素块代表`i,j,x,y`；  
- 当调整求和顺序时，像素块“移动”到新的位置；  
- 引入莫比乌斯函数时，用“闪电特效”标记`μ(d)`；  
- 整除分块时，用“合并方块”表示将相同值的区间合并计算。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性和算法有效性三个角度，筛选了3份优质题解，帮你快速理解核心逻辑～
</eval_intro>

### 题解一：作者Siyuan（赞357）
* **点评**：这是一份“教科书级”的题解！作者从核心公式出发，一步步推导求和式，每一步都有明确的理由（比如调整求和顺序、莫比乌斯反演）。代码结构非常规范：`init()`函数预处理莫比乌斯函数和前缀和，`main()`中用整除分块计算答案。特别是作者在`Extended`部分给出了核心公式的**构造性证明**，帮你彻底理解公式的来源，而不是死记硬背。

### 题解二：作者pengym（赞74）
* **点评**：作者的推导过程很“接地气”，用“套路”这个词总结莫比乌斯反演的常见步骤（比如设`f(d)`和`F(d)`），适合新手入门。代码中的`get_mu()`函数线性筛莫比乌斯函数，`g[]`数组预处理`∑_{i=1}^x floor(x/i)`，逻辑清晰。作者还推荐了自己的博客，里面有莫比乌斯反演和整除分块的详细讲解，是很好的补充资料。

### 题解三：作者Wolfycz（赞0，但思路清晰）
* **点评**：作者用`σ₀`（约数个数函数）代替`d`，推导过程更符合数论的标准符号。代码中用线性筛预处理`σ₀`的前缀和，利用`σ₀`的积性函数性质，比直接计算`floor(x/i)`更高效（因为线性筛是O(n)的）。这种优化思路值得学习——**能用积性函数性质的地方，尽量不用暴力计算**。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“拦路虎”主要有三个，解决它们就能打通整个思路！
</difficulty_intro>

### 1. 如何想到d(ij)的分解公式？
- **难点**：直接计算`d(ij)`不可行，必须找到它与`i,j`因数的关系。  
- **策略**：回忆约数个数的定义（`d(n) = ∏(k_i+1)`，其中`k_i`是质因数的指数）。对于`ij`的质因数`p`，`i`中有`a`个`p`，`j`中有`b`个`p`，则`ij`中`p`的指数是`a+b`，贡献`a+b+1`个约数。而互质的`x,y`对恰好对应`p`的`a+b+1`种选择方式（`x`选`0~a`个`p`，`y`选`0~b`个`p`，但不同时选）。  
- 💡 **学习笔记**：约数个数的“乘法原理”是推导公式的关键！


### 2. 如何用莫比乌斯函数处理互质条件？
- **难点**：`[gcd(x,y)=1]`这个条件无法直接求和，需要转化为可计算的形式。  
- **策略**：利用莫比乌斯函数的性质：`[n=1] = ∑_{d|n} μ(d)`。因此`[gcd(x,y)=1] = ∑_{d|gcd(x,y)} μ(d)`，可以把条件转化为对`d`的求和。  
- 💡 **学习笔记**：莫比乌斯函数是“处理互质条件”的神器！


### 3. 如何优化最后的求和式？
- **难点**：转化后的求和式如果直接计算，时间复杂度还是很高（O(n)），无法处理5e4组数据。  
- **策略**：用**整除分块**（也叫数论分块）。观察到`floor(n/d)`的值在`d`的某个区间内是相同的，可以将这些区间合并计算，把时间复杂度降到O(√n)。  
- 💡 **学习笔记**：整除分块的核心是“找相同值的区间”，记住公式`r = min(n/(n/l), m/(m/l))`！


### ✨ 解题技巧总结
- **技巧1**：遇到乘积的约数个数问题，优先想“因数分解+互质条件”。  
- **技巧2**：看到`[gcd(a,b)=k]`，先除以`k`转化为`[gcd(a/k,b/k)=1]`，再用莫比乌斯函数。  
- **技巧3**：预处理是数论题的“灵魂”——提前算好莫比乌斯函数的前缀和、约数个数的前缀和，能大幅降低查询时间。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用核心代码**，它整合了优质题解的思路，结构清晰，适合直接参考～
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了Siyuan和Wolfycz的思路，用线性筛预处理莫比乌斯函数和σ₀的前缀和，整除分块计算答案。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

typedef long long ll;
const int MAXN = 50005;

int mu[MAXN], sigma0[MAXN], prime[MAXN], cnt;
ll pre_mu[MAXN], pre_sigma0[MAXN];
bool is_prime[MAXN];

// 线性筛预处理mu和sigma0
void sieve() {
    memset(is_prime, true, sizeof(is_prime));
    is_prime[0] = is_prime[1] = false;
    mu[1] = 1;
    sigma0[1] = 1;
    for (int i = 2; i < MAXN; ++i) {
        if (is_prime[i]) {
            prime[cnt++] = i;
            mu[i] = -1;
            sigma0[i] = 2; // 质数的约数个数是2（1和自身）
        }
        for (int j = 0; j < cnt && i * prime[j] < MAXN; ++j) {
            is_prime[i * prime[j]] = false;
            if (i % prime[j] == 0) {
                mu[i * prime[j]] = 0;
                // sigma0的计算：假设i = p^k * ...，则i*p的sigma0是sigma0(i)/(k+1)*(k+2)
                int tmp = i, p = prime[j], k = 0;
                while (tmp % p == 0) {
                    tmp /= p;
                    k++;
                }
                sigma0[i * p] = sigma0[i] / (k + 1) * (k + 2);
                break;
            } else {
                mu[i * prime[j]] = -mu[i];
                sigma0[i * prime[j]] = sigma0[i] * sigma0[prime[j]]; // 积性函数
            }
        }
    }
    // 计算前缀和
    pre_mu[0] = 0;
    pre_sigma0[0] = 0;
    for (int i = 1; i < MAXN; ++i) {
        pre_mu[i] = pre_mu[i - 1] + mu[i];
        pre_sigma0[i] = pre_sigma0[i - 1] + sigma0[i];
    }
}

int main() {
    sieve();
    int T;
    scanf("%d", &T);
    while (T--) {
        int n, m;
        scanf("%d%d", &n, &m);
        if (n > m) swap(n, m);
        ll ans = 0;
        // 整除分块
        for (int l = 1, r; l <= n; l = r + 1) {
            r = min(n / (n / l), m / (m / l));
            ans += (pre_mu[r] - pre_mu[l - 1]) * pre_sigma0[n / l] * pre_sigma0[m / l];
        }
        printf("%lld\n", ans);
    }
    return 0;
}
```
* **代码解读概要**：  
  1. `sieve()`函数用线性筛法预处理两个数组：`mu`（莫比乌斯函数）和`sigma0`（约数个数函数）；  
  2. 计算`pre_mu`（mu的前缀和）和`pre_sigma0`（sigma0的前缀和），用于快速查询区间和；  
  3. 对于每组测试用例，用整除分块计算答案：遍历每个区间`[l, r]`，其中`n/l`和`m/l`的值相同，计算该区间的贡献并累加到答案中。


<code_intro_selected>
接下来看**优质题解的核心片段**，学习它们的亮点～
</code_intro_selected>

### 题解一（Siyuan）的核心片段
* **亮点**：用整除分块预处理`f(x) = ∑_{i=1}^x floor(x/i)`，直接计算约数个数的前缀和。
* **核心代码片段**：
```cpp
long long s[N]; // s[x] = ∑_{i=1}^x floor(x/i)
void init() {
    // 预处理mu的前缀和（略）
    for (int x = 1; x <= 5e4; ++x) {
        long long res = 0;
        for (int i = 1, j; i <= x; i = j + 1) {
            j = x / (x / i);
            res += 1LL * (j - i + 1) * (x / i);
        }
        s[x] = res;
    }
}
```
* **代码解读**：  
  这段代码计算`f(x)`——对于每个`x`，用整除分块统计`1`到`x`中每个数的倍数个数之和（也就是约数个数的前缀和）。比如`x=3`时，`floor(3/1)=3`（1的倍数有3个）、`floor(3/2)=1`（2的倍数有1个）、`floor(3/3)=1`（3的倍数有1个），总和是5，对应`sigma0(1)+sigma0(2)+sigma0(3)=1+2+2=5`。  
* 💡 **学习笔记**：`f(x)`和`sigma0`的前缀和是等价的！


### 题解三（Wolfycz）的核心片段
* **亮点**：用积性函数性质线性筛`sigma0`，比整除分块更高效。
* **核心代码片段**：
```cpp
int f[N+10], Frm[N+10]; // f[i] = sigma0(i), Frm[i]是i的最小质因数的指数
void prepare() {
    f[1] = 1;
    for (int i = 2; i <= N; ++i) {
        if (!inprime[i]) {
            prime[++tot] = i;
            f[i] = 2;
            Frm[i] = 1;
        }
        for (int j = 1; j <= tot && i*prime[j] <= N; ++j) {
            inprime[i*prime[j]] = 1;
            if (i % prime[j] == 0) {
                Frm[i*prime[j]] = Frm[i] + 1;
                f[i*prime[j]] = f[i] / Frm[i] * Frm[i*prime[j]];
                break;
            }
            f[i*prime[j]] = f[i] << 1;
            Frm[i*prime[j]] = 1;
        }
    }
    for (int i = 2; i <= N; ++i) sf[i] = sf[i-1] + f[i];
}
```
* **代码解读**：  
  `f[i]`表示`i`的约数个数。对于质数`i`，`f[i]=2`；对于合数`i*p`（`p`是质数）：  
  - 如果`i`能被`p`整除，说明`p`是`i`的最小质因数，`f[i*p] = f[i]/(k+1)*(k+2)`（`k`是`i`中`p`的指数）；  
  - 否则，`i`和`p`互质，`f[i*p] = f[i] * f[p]`（积性函数性质）。  
* 💡 **学习笔记**：线性筛是处理积性函数的“神器”，时间复杂度O(n)！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了帮你“看”懂莫比乌斯反演和整除分块的过程，Kay设计了一个**8位像素风的动画**，像玩FC游戏一样学习算法！
</visualization_intro>

### 动画演示主题：《约数探险队》
- **风格**：FC红白机风格，像素块、低饱和度色彩、8位音效。
- **场景**：一个由像素块组成的“数学森林”，里面有`i,j,x,y`四个探险队员，还有“莫比乌斯闪电”和“分块魔法”。


### 动画帧步骤与交互关键点
1. **初始化场景**：  
   - 屏幕左侧是“求和式面板”，显示原问题$\sum_{i=1}^n\sum_{j=1}^m d(ij)$；  
   - 中间是“探险区域”，`i`和`j`站在最前面，`x`和`y`躲在它们后面；  
   - 右侧是“控制面板”：单步执行、自动播放、重置按钮，还有速度滑块。

2. **步骤1：分解d(ij)**：  
   - 播放音效“叮——”，`x`和`y`从`i`和`j`后面走出来，面板上的`d(ij)`变成$\sum_{x|i}\sum_{y|j} [\gcd(x,y)=1]$；  
   - 用红色像素块标记`[gcd(x,y)=1]`，提示“这里需要莫比乌斯函数！”。

3. **步骤2：莫比乌斯反演**：  
   - 播放音效“滋啦——”，一道闪电（代表`μ(d)`）击中`[gcd(x,y)=1]`，面板上的条件变成$\sum_{d|gcd(x,y)} μ(d)$；  
   - `d`的像素块从屏幕下方升起，加入探险队。

4. **步骤3：调整求和顺序**：  
   - 播放音效“哗啦——”，`d`移动到求和式的最前面，面板变成$\sum_{d=1}^n μ(d) \sum_{i=1}^{n/d} \sum_{j=1}^{m/d} σ₀(i) σ₀(j)$；  
   - `i`和`j`缩小成`n/d`和`m/d`，表示“现在处理的是`d`倍的区间”。

5. **步骤4：整除分块**：  
   - 播放音效“咚咚——”，屏幕上的`d`被分成多个区间（比如`[1,2], [3,5]`），每个区间的`n/d`和`m/d`值相同；  
   - 用黄色像素块合并这些区间，提示“这些区间可以一起计算！”。

6. **步骤5：计算答案**：  
   - 播放音效“叮铃铃——”，每个区间的贡献被计算并累加到答案中，屏幕上显示最终结果。


### 交互设计
- **单步执行**：点击“下一步”，动画走一帧，同时显示文字提示（比如“现在分解d(ij)！”）；  
- **自动播放**：点击“开始”，动画自动播放，速度可通过滑块调整；  
- **重置**：点击“重置”，回到初始场景，重新开始。


<visualization_conclusion>
通过这个动画，你可以直观看到求和式如何“变形”，莫比乌斯函数如何“处理”互质条件，整除分块如何“合并”区间。就像玩游戏一样，轻松掌握数论的核心逻辑！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
莫比乌斯反演和整除分块是数论中的“基础工具”，很多题目都能用到。下面是几个相似的练习，帮你巩固知识～
</similar_problems_intro>

### 通用思路迁移
- **场景1**：求$\sum_{i=1}^n\sum_{j=1}^m [\gcd(i,j)=k]$（比如洛谷P2522）；  
- **场景2**：求$\sum_{i=1}^n\sum_{j=1}^m \gcd(i,j)$（比如洛谷P1390）；  
- **场景3**：求$\sum_{i=1}^n\sum_{j=1}^m lcm(i,j)$（需要转化为gcd问题）。


### 练习推荐（洛谷）
1. **洛谷 P2257** - [YY的GCD]  
   🗣️ **推荐理由**：这是莫比乌斯反演的经典题，和本题思路几乎一致，只是把“约数个数”换成了“gcd等于质数”，适合巩固基础。

2. **洛谷 P3455** - [ZAP-Queries]  
   🗣️ **推荐理由**：直接考察莫比乌斯反演和整除分块，需要处理多组查询，和本题的“分块计算”部分完全一致。

3. **洛谷 P2522** - [HAOI2011]Problem b  
   🗣️ **推荐理由**：需要处理二维前缀和（求`[a,b]×[c,d]`的gcd条件和），是本题的进阶版，帮你提升综合应用能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者分享了自己的“踩坑”经历，这些都是宝贵的经验！
</insights_intro>

> **参考经验（来自Siyuan）**：“我最初没理解d(ij)的分解公式，后来通过构造质因数的选择方式，才明白互质条件的必要性。”  
> **点评**：构造法是理解数论公式的好方法！如果记不住公式，可以尝试用小例子（比如`i=2,j=3`）推导，慢慢就能发现规律。

> **参考经验（来自pengym）**：“整除分块的`r`要取`min(n/(n/l), m/(m/l))`，我之前漏了`m/(m/l)`，结果WA了好几次！”  
> **点评**：细节决定成败！整除分块时，`r`是两个区间的交集，必须取最小值，否则会计算错误。


<conclusion>
「SDOI2015约数个数和」是莫比乌斯反演的“入门必做题”，它的核心是**将复杂的求和式转化为可计算的形式**。通过这道题，你不仅能学会莫比乌斯反演和整除分块，还能掌握“从公式推导到代码实现”的完整流程。

记住：数论题的关键是**找规律、推公式、预处理**。多做几道相似的题目，你会发现数论其实很有趣～下次我们再一起探索更难的数论问题！💪
</conclusion>

---
处理用时：125.47秒
# 题目信息

# [NOI2015] 寿司晚宴

## 题目描述

为了庆祝 NOI 的成功开幕，主办方为大家准备了一场寿司晚宴。小 G 和小 W 作为参加 NOI 的选手，也被邀请参加了寿司晚宴。

在晚宴上，主办方为大家提供了 $n−1$ 种不同的寿司，编号 $1,2,3,\ldots,n-1$，其中第 $i$ 种寿司的美味度为 $i+1$。（即寿司的美味度为从 $2$ 到 $n$）

现在小 G 和小 W 希望每人选一些寿司种类来品尝，他们规定一种品尝方案为不和谐的当且仅当：小 G 品尝的寿司种类中存在一种美味度为 $x$ 的寿司，小 W 品尝的寿司中存在一种美味度为 $y$ 的寿司，而 $x$ 与 $y$ 不互质。

现在小 G 和小 W 希望统计一共有多少种和谐的品尝寿司的方案（对给定的正整数 $p$ 取模）。注意一个人可以不吃任何寿司。


## 说明/提示

【数据范围】


 ![](https://cdn.luogu.com.cn/upload/pic/1506.png) 


**勘误：$0 < p \le 10^9 $**

## 样例 #1

### 输入

```
3 10000```

### 输出

```
9```

## 样例 #2

### 输入

```
4 10000```

### 输出

```
21```

## 样例 #3

### 输入

```
100 100000000```

### 输出

```
3107203```

# AI分析结果



---

# 💡 Kay的C++算法解析：寿司晚宴 深入学习指南 💡

<introduction>
今天我们来一起分析NOI2015的经典题目“寿司晚宴”。这道题需要计算两个选手选择寿司的和谐方案数，核心难点在于处理质数集合的互斥条件。本指南将帮助大家理解状压DP的巧妙应用，掌握大质数分组处理的技巧，并通过可视化动画直观感受算法过程。
</introduction>

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：动态规划（状压DP）

🗣️ **初步分析**：  
要解决“寿司晚宴”问题，关键在于理解“两集合互质”的本质是两集合的质因数集合无交集。由于n≤500，直接枚举所有质数不现实，但我们可以利用质数的特性：一个数最多有一个大于√n（约22）的质因子（大质数），而小于22的质数只有8个（2,3,5,7,11,13,17,19），称为小质数。  

状压DP的核心思想是用二进制状态压缩小质数的集合（8位即可表示），同时将大质数相同的数分组处理（因为它们只能被同一人选择或都不选）。具体来说：  
- 用`dp[s1][s2]`表示小G选的小质数集合为`s1`，小W选的小质数集合为`s2`的方案数（要求`s1 & s2 == 0`）。  
- 对每个大质数分组，用`f1`和`f2`分别记录该组被小G或小W选择的方案数，最后合并到`dp`中（避免重复计算都不选的情况）。  

**可视化设计思路**：动画将用8x8像素网格表示小质数集合（每格对应一个小质数），大质数分组用不同颜色块表示。单步执行时，高亮当前处理的数、更新的状态（如`s1`或`s2`的位变化），并通过音效提示状态转移（如“叮”表示有效转移）。自动播放时，大质数分组会按顺序处理，展示合并过程。

---

## 2. 精选优质题解参考

<eval_intro>
经过对题解的思路清晰度、代码规范性和算法有效性评估，以下题解因逻辑清晰、实现高效被选为优质参考（评分均≥4星）：
</eval_intro>

**题解一：Orion545的题解（赞164）**  
* **点评**：此题解详细解释了30分和100分的思路差异，重点突出大质数分组的处理。代码中使用滚动数组优化空间，通过`memcpy`复制状态，倒序更新避免重复计算，边界条件处理严谨（如大质数为-1的情况）。亮点在于对状态转移的清晰推导和优化技巧（如时间复杂度从O(2^20n)优化到O(n2^16)）。

**题解二：翼德天尊的题解（赞88）**  
* **点评**：此题解以“萌新视角”逐步推导，从暴力到优化的思路过渡自然。代码结构工整，变量名（如`dp1`、`dp2`）含义明确，特别强调了大质数分组排序的重要性。亮点是对“为何选择状压DP”的解释（质数数量少、互质条件易转换为位运算），适合初学者理解。

**题解三：ethan_zhou的题解（赞41）**  
* **点评**：此题解提出了O(n×3^8)的优化方法，通过枚举有效状态（s1和s2无交集）减少计算量。代码中使用位运算优化状态枚举（如`tmp=(ALL-1)^s1`），并解释了空间优化的细节。亮点是对状态数的数学分析（3^8而非4^8），体现了对问题本质的深刻理解。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决此题时，以下核心难点需要重点突破：
</difficulty_intro>

1.  **关键点1：小质数的状态定义**  
    * **分析**：小质数只有8个，可用8位二进制数表示集合（如`s=0b1010`表示包含第2、4个小质数）。状态定义需满足`s1 & s2 == 0`（两集合无交集）。优质题解通过倒序遍历状态（从255到0）避免重复计算，确保每次转移基于未更新的旧状态。  
    * 💡 **学习笔记**：状态压缩的核心是“用位运算表示集合”，小质数的数量决定了状态空间的大小（2^8=256），这是算法可行的关键。

2.  **关键点2：大质数分组的处理**  
    * **分析**：大质数相同的数只能被同一人选择或都不选。题解中通过排序将大质数相同的数分组，每组开始时复制当前`dp`到`f1`和`f2`（分别表示该组被小G或小W选择的情况），组内更新`f1`和`f2`，组结束时合并回`dp`（`dp = f1 + f2 - dp`，减去重复计算的都不选的情况）。  
    * 💡 **学习笔记**：分组处理是降低复杂度的关键，利用了“大质数唯一”的性质，将问题分解为独立子问题。

3.  **关键点3：状态转移的正确性**  
    * **分析**：转移时需确保新状态不引入冲突（如小G选择当前数的小质数集合`s`时，小W的当前状态不能包含`s`）。题解中通过条件判断（`(s & k) == 0`）保证这一点，倒序遍历状态避免覆盖未处理的旧值。  
    * 💡 **学习笔记**：动态规划的转移需严格满足约束条件，倒序遍历是处理“背包类”问题的常用技巧。

### ✨ 解题技巧总结
- **质数分解预处理**：提前分解每个数的小质数集合和大质数，方便后续分组处理。  
- **滚动数组优化**：用`memcpy`复制状态，避免多维数组的空间浪费。  
- **倒序遍历状态**：防止同一轮中多次更新同一状态，保证转移的正确性。  

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心实现，结合了状态压缩、大质数分组处理和滚动数组优化。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：此代码综合了Orion545和翼德天尊的题解思路，采用状态压缩处理小质数，大质数分组排序，`f1`和`f2`分别处理分组选择，最后合并到`dp`中。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

typedef long long ll;
const int PRIME[8] = {2, 3, 5, 7, 11, 13, 17, 19};
const int MAX_S = 1 << 8; // 小质数状态数：2^8=256

struct Sushi {
    int s; // 小质数集合（8位）
    int big; // 大质数（若没有则为-1）
} a[505];

ll dp[MAX_S][MAX_S]; // 最终状态：小G选s1，小W选s2的方案数
ll f1[MAX_S][MAX_S], f2[MAX_S][MAX_S]; // 分组处理时的临时状态

bool cmp(const Sushi& x, const Sushi& y) {
    return x.big < y.big; // 按大质数排序，相同大质数的数连续
}

int main() {
    int n, mod;
    cin >> n >> mod;
    for (int i = 2; i <= n; ++i) {
        int tmp = i;
        a[i-1].s = 0;
        a[i-1].big = -1;
        for (int j = 0; j < 8; ++j) {
            if (tmp % PRIME[j] == 0) {
                a[i-1].s |= 1 << j;
                while (tmp % PRIME[j] == 0) tmp /= PRIME[j];
            }
        }
        if (tmp != 1) a[i-1].big = tmp; // 大质数存在
    }
    sort(a + 1, a + n, cmp); // 按大质数排序

    dp[0][0] = 1; // 初始状态：都不选
    for (int i = 1; i < n; ++i) {
        // 新分组开始，复制当前dp到f1和f2
        if (i == 1 || a[i].big != a[i-1].big || a[i].big == -1) {
            memcpy(f1, dp, sizeof(f1));
            memcpy(f2, dp, sizeof(f2));
        }
        // 倒序更新f1和f2（避免重复计算）
        for (int s1 = MAX_S-1; s1 >= 0; --s1) {
            for (int s2 = MAX_S-1; s2 >= 0; --s2) {
                if ((s1 & s2) != 0) continue; // 状态无效，跳过
                // 尝试将当前数加入小G的集合（需s2不包含当前数的小质数）
                if ((a[i].s & s2) == 0) {
                    f1[s1 | a[i].s][s2] = (f1[s1 | a[i].s][s2] + f1[s1][s2]) % mod;
                }
                // 尝试将当前数加入小W的集合（需s1不包含当前数的小质数）
                if ((a[i].s & s1) == 0) {
                    f2[s1][s2 | a[i].s] = (f2[s1][s2 | a[i].s] + f2[s1][s2]) % mod;
                }
            }
        }
        // 分组结束，合并f1和f2到dp（减去重复计算的都不选的情况）
        if (i == n-1 || a[i].big != a[i+1].big || a[i].big == -1) {
            for (int s1 = 0; s1 < MAX_S; ++s1) {
                for (int s2 = 0; s2 < MAX_S; ++s2) {
                    if ((s1 & s2) != 0) continue;
                    dp[s1][s2] = (f1[s1][s2] + f2[s1][s2] - dp[s1][s2] + mod) % mod;
                }
            }
        }
    }

    ll ans = 0;
    for (int s1 = 0; s1 < MAX_S; ++s1) {
        for (int s2 = 0; s2 < MAX_S; ++s2) {
            if ((s1 & s2) == 0) {
                ans = (ans + dp[s1][s2]) % mod;
            }
        }
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  代码首先预处理每个数的小质数集合和大质数，按大质数排序。然后通过`dp`数组记录状态，`f1`和`f2`处理每个大质数分组的选择情况。分组内倒序更新状态以避免重复计算，分组结束后合并结果。最终统计所有有效状态（`s1 & s2 == 0`）的方案数。

---

<code_intro_selected>
以下是优质题解的核心代码片段赏析：
</code_intro_selected>

**题解一：Orion545的核心片段**  
* **亮点**：滚动数组优化，倒序更新状态。  
* **核心代码片段**：
```cpp
for (int i = 1; i < n; ++i) {
    if (i == 1 || a[i].big != a[i-1].big || a[i].big == -1) {
        memcpy(f1, dp, sizeof(f1));
        memcpy(f2, dp, sizeof(f2));
    }
    for (int j = 255; j >= 0; --j) {
        for (int k = 255; k >= 0; --k) {
            if (j & k) continue;
            if ((a[i].S & j) == 0) f2[j][k | a[i].S] = (f2[j][k | a[i].S] + f2[j][k]) % mod;
            if ((a[i].S & k) == 0) f1[j | a[i].S][k] = (f1[j | a[i].S][k] + f1[j][k]) % mod;
        }
    }
    if (i == n-1 || a[i].big != a[i+1].big || a[i].big == -1) {
        for (int j = 0; j <= 255; ++j) {
            for (int k = 0; k <= 255; ++k) {
                if (j & k) continue;
                dp[j][k] = (f1[j][k] + f2[j][k] - dp[j][k] + mod) % mod;
            }
        }
    }
}
```
* **代码解读**：  
  这段代码处理每个大质数分组。当遇到新分组时，复制当前`dp`到`f1`和`f2`；组内倒序遍历状态（从255到0），更新`f1`（小G选）和`f2`（小W选）；组结束时合并结果到`dp`（减去重复计算的都不选的情况）。倒序遍历确保每次更新基于未修改的旧状态，避免重复计算。  
* 💡 **学习笔记**：倒序遍历是处理“每个物品只能选一次”的背包问题的经典技巧，此处同理。

**题解二：翼德天尊的核心片段**  
* **亮点**：清晰的状态转移逻辑，变量名易理解。  
* **核心代码片段**：
```cpp
for (int i = 2; i <= n; ++i) {
    if (a[i].big != a[i-1].big || a[i].big == 0) {
        memcpy(dp1, dp, sizeof(dp1));
        memcpy(dp2, dp, sizeof(dp2));
    }
    for (int s1 = 255; s1 >= 0; --s1) {
        for (int s2 = 255; s2 >= 0; --s2) {
            if (s1 & s2) continue;
            if ((a[i].S & s2) == 0) dp1[s1 | a[i].S][s2] = (dp1[s1 | a[i].S][s2] + dp1[s1][s2]) % p;
            if ((a[i].S & s1) == 0) dp2[s1][s2 | a[i].S] = (dp2[s1][s2 | a[i].S] + dp2[s1][s2]) % p;
        }
    }
    if (i == n || a[i].big != a[i+1].big || a[i].big == 0) {
        for (int s1 = 0; s1 <= 255; ++s1) {
            for (int s2 = 0; s2 <= 255; ++s2) {
                if (s1 & s2) continue;
                dp[s1][s2] = (dp1[s1][s2] + dp2[s1][s2] - dp[s1][s2] + p) % p;
            }
        }
    }
}
```
* **代码解读**：  
  这段代码与Orion545的思路一致，但变量名（`dp1`、`dp2`）更直观。通过`memcpy`初始化分组状态，倒序更新后合并，确保大质数分组的正确处理。  
* 💡 **学习笔记**：变量命名应清晰反映其用途（如`dp1`表示小G选当前分组的状态），提升代码可读性。

---

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解状态转移和大质数分组处理，我们设计了一个8位像素风格的动画，模拟小质数集合的更新过程。
</visualization_intro>

  * **动画演示主题**：`像素寿司店的质数争夺战`  
  * **核心演示内容**：展示小G和小W选择寿司时，小质数集合的变化（用8x8像素网格表示），以及大质数分组的合并过程。  

  * **设计思路简述**：  
    采用FC红白机风格，用不同颜色表示小质数（如红色=2，绿色=3等）。每个寿司用像素块表示，大质数分组用不同边框区分。单步执行时，高亮当前处理的寿司，显示其小质数集合（网格中对应位置点亮），并更新`f1`或`f2`的状态（网格颜色变化）。合并分组时，用动画合并两个网格的状态，减去重复部分（都不选的情况）。

  * **动画帧步骤与交互关键点**：  
    1. **初始化场景**：8x8网格（小质数集合）、控制面板（单步/自动/重置按钮）、状态显示区（`dp`、`f1`、`f2`的值）。  
    2. **处理大质数分组**：同一分组的寿司用金色边框标出，复制`dp`到`f1`和`f2`（网格闪烁表示复制）。  
    3. **状态转移**：单步执行时，当前寿司的小质数集合在网格中高亮，尝试加入小G或小W的集合（若不冲突则网格对应位置变色，播放“叮”音效）。  
    4. **合并分组**：分组处理完成后，`f1`和`f2`的网格叠加，减去`dp`的原始状态（用透明层表示重复部分），最终`dp`的网格更新为合并后的结果。  
    5. **目标达成**：所有分组处理完成后，统计所有`s1 & s2 == 0`的状态，播放胜利音效，网格全亮表示成功。

  * **旁白提示**：  
    - “当前处理大质数分组，小G和小W只能选其中一个或都不选哦！”  
    - “看，小G的集合加入了质数2（对应网格红色点亮），这时候小W的集合不能有2～”  
    - “合并分组时，要减去都不选的情况，否则会重复计算～”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到状态转移的每一步，理解大质数分组处理的必要性，以及如何通过状压DP高效解决问题。
</visualization_conclusion>

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握本题后，可通过以下题目巩固状压DP和质数分组处理的技巧：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    本题的核心是“质数集合的互斥条件+大质数分组处理”，类似思路可用于：  
    - 两集合元素互质的其他问题（如选两个子集，元素两两互质）。  
    - 涉及大质数/小质数分解的计数问题（如统计满足条件的数对）。  
    - 需要状态压缩的动态规划问题（如棋盘覆盖、集合划分）。

  * **练习推荐 (洛谷)**：  
    1.  **洛谷 P1879 [USACO06NOV]玉米田Corn Fields**  
        * 🗣️ **推荐理由**：经典状压DP题，练习状态压缩和相邻状态的互斥条件处理。  
    2.  **洛谷 P1941 [NOI2009] 诗人小G**  
        * 🗣️ **推荐理由**：结合动态规划和高精度计算，练习复杂状态的定义与优化。  
    3.  **洛谷 P2704 [NOI2001] 炮兵阵地**  
        * 🗣️ **推荐理由**：三维状压DP，练习多状态约束的处理（类似本题的大质数分组）。  

---

## 7. 学习心得与经验分享

<insights_intro>
题解中作者们的调试经验对我们很有启发：
</insights_intro>

> **参考经验 (来自Orion545)**：“在处理大质数分组时，容易忘记初始化`f1`和`f2`为当前`dp`的值，导致合并时结果错误。调试时通过打印中间状态，发现分组开始时的`f1`未正确复制，才定位到问题。”  

**点评**：初始化是动态规划的关键步骤，特别是涉及分组处理时，必须确保临时状态（如`f1`、`f2`）正确继承当前`dp`的值。调试时打印中间状态是定位错误的有效方法，建议大家在遇到类似问题时尝试。

---

<conclusion>
通过对“寿司晚宴”的分析，我们掌握了状压DP在质数集合问题中的应用，以及大质数分组处理的技巧。编程的关键在于理解问题本质（互质=质数集合无交集），并通过状态压缩和分组优化降低复杂度。希望大家通过练习巩固这些方法，在竞赛中取得好成绩！💪
</conclusion>

---
处理用时：187.75秒
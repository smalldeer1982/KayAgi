# 题目信息

# 【模板】扩展 BSGS/exBSGS

## 题目背景

题目来源：SPOJ3105 Mod

## 题目描述

给定 $a,p,b$，求满足 $a^x≡b \pmod p$ 的最小自然数 $x$ 。


## 说明/提示

对于 $100\%$ 的数据，$1\le a,p,b≤10^9$ 或 $a=p=b=0$。

2021/5/14 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)。  
2021/7/1 新添加[一组 Hack 数据](https://www.luogu.com.cn/discuss/391666)。

## 样例 #1

### 输入

```
5 58 33
2 4 3
0 0 0```

### 输出

```
9
No Solution```

# AI分析结果


# 💡 Kay的C++算法解析：扩展BSGS/exBSGS 深入学习指南 💡

<introduction>
今天我们来一起分析“扩展BSGS/exBSGS”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`数学（离散对数问题）` 

🗣️ **初步分析**：
> 解决“扩展BSGS”这道题，关键在于理解并运用`数学中的离散对数与同余方程技巧`。简单来说，就像在迷宫中寻找最短路径一样，我们需要通过分块策略（大步小步法）和反复化简方程来找到满足同余方程的最小指数解。在本题中，该算法主要用于处理当模数非质数且底数与模数不互质的复杂情况。
   - 核心难点在于处理不互质情形（需反复除以最大公约数）和高效查询（需使用哈希表）。各题解均遵循相同框架但实现细节不同：白鲟采用手动哈希表，suxrsfe使用扩展欧几里得求逆元，mydcwfy侧重非递归实现。
   - 核心算法流程：1) 反复除以gcd直至互质，记录操作次数；2) 计算累积系数的逆元；3) 应用BSGS分块查询。在像素动画中，我们将高亮gcd化简步骤（用“拆墙”动画表示）和哈希表查询过程（用网格搜索表示）。
   - 采用8位像素风格迷宫探索主题：玩家（像素小人）需拆除gcd墙（红色砖块），然后在BSGS网格（蓝色棋盘）中搜索密钥。关键操作配“叮”声效，成功时播放16-bit胜利音效，支持步进/调速交互。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等几个方面，为大家筛选了以下评分较高（≥4星）的题解。
</eval_intro>

**题解一（来源：白鲟）**
* **点评**：思路严谨，详细证明了算法正确性和时间复杂度上界（O(√φ(p))）。代码结构规范，变量名`baby[]`/`giant[]`形象体现分块思想，采用开散列哈希处理冲突。亮点在于对循环节性质的数学证明，虽未用unordered_map但手动哈希实现高效，竞赛实践时需注意最坏复杂度。

**题解二（来源：suxrsfe）**
* **点评**：逻辑清晰，逐步展示exBSGS转化过程。代码规范，使用exgcd求逆元处理边界，后改用unordered_map提升查询效率。亮点在于递归转化思想的直观解释和调试技巧分享（如边界测试），实践价值高且易于移植到其他离散对数问题。

**题解三（来源：mydcwfy）**
* **点评**：代码简洁高效，非递归实现节省栈空间。亮点在于及时更新代码通过Hack数据，注释详细解释变量作用（如`cnt`记录操作次数）。虽未深入数学证明，但工程实现优秀，可直接用于竞赛且鲁棒性强。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下一些关键点或难点。结合优质题解的共性，我为大家提炼了几个核心的思考方向和策略：
</difficulty_intro>

1.  **关键点：处理不互质情形**
    * **分析**：当a与p不互质时，需反复除以gcd直至互质。难点在于正确维护累积系数ad和操作计数cnt。如白鲟题解所示，每次迭代需验证b能否被gcd整除，否则无解。
    * 💡 **学习笔记**：gcd化简是exBSGS的基础，如同拆墙开路，必须保证每一步操作后方程仍等价。

2.  **关键点：逆元的计算**
    * **分析**：转化为互质方程后，需计算累积系数的逆元。suxrsfe题解使用exgcd可靠求解（扩展欧几里得算法），注意调整结果为非负数。
    * 💡 **学习笔记**：逆元是模运算的“倒数”，互质条件下必存在，但计算需精确。

3.  **关键点：哈希表的设计与查询**
    * **分析**：BSGS阶段需存储O(√p)个值并快速查询。mydcwfy题解采用unordered_map实现O(1)均摊查询，而白鲟手动处理哈希冲突。设计时应平衡效率与代码复杂度。
    * 💡 **学习笔记**：哈希表是算法效率的关键，选择实现方式需考虑数据规模与时限。

### ✨ 解题技巧总结
<summary_best_practices>
通过对本题及类似问题的分析，我总结了以下一些通用的解题技巧：
</summary_best_practices>
- **分阶段处理**：将问题明确分为gcd化简阶段和BSGS阶段，降低思维复杂度。
- **边界特判**：优先处理b=1/p=1等特殊情况（直接返回x=0），避免无效计算。
- **调试验证**：在gcd化简后输出中间方程，确保转化正确再进入BSGS阶段。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合优质题解思路，采用非递归gcd处理+unordered_map查询，平衡效率与可读性。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cmath>
#include <unordered_map>
using namespace std;

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

int exgcd(int a, int b, int& x, int& y) {
    if (!b) { x = 1; y = 0; return a; }
    int d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}

int inv(int a, int p) {
    int x, y;
    exgcd(a, p, x, y);
    return (x % p + p) % p;
}

int BSGS(int a, int b, int p) {
    a %= p; b %= p;
    unordered_map<int, int> hash;
    int t = ceil(sqrt(p)), val = 1;
    for (int i = 0; i < t; i++) {
        hash[1LL * b * val % p] = i;
        val = 1LL * val * a % p;
    }
    a = val;
    if (!a) return b ? -1 : 1;
    val = 1;
    for (int i = 0; i <= t; i++) {
        int j = hash.find(val) != hash.end() ? hash[val] : -1;
        if (j >= 0 && i * t - j >= 0) return i * t - j;
        val = 1LL * val * a % p;
    }
    return -1;
}

int exBSGS(int a, int b, int p) {
    if (b == 1 || p == 1) return 0;
    int cnt = 0, ad = 1, d;
    while ((d = gcd(a, p)) != 1) {
        if (b % d) return -1;
        cnt++; b /= d; p /= d;
        ad = (1LL * ad * (a / d)) % p;
        if (ad == b) return cnt;
    }
    int b_ = 1LL * b * inv(ad, p) % p;
    int ans = BSGS(a, b_, p);
    if (ans == -1) return -1;
    return ans + cnt;
}

int main() {
    int a, p, b;
    while (cin >> a >> p >> b, a || p || b) {
        int ans = exBSGS(a, b, p);
        if (ans < 0) cout << "No Solution" << endl;
        else cout << ans << endl;
    }
    return 0;
}
```
* **代码解读概要**：
  > 该实现分为三个关键部分：1) `exBSGS`处理gcd化简：循环除以gcd并更新ad系数；2) 调用`inv`计算逆元；3) `BSGS`执行分块查询。主循环读入多组数据，输出最小解或无解。

---
<code_intro_selected>
接下来剖析精选题解中体现核心逻辑的代码片段：
</code_intro_selected>

**题解一（白鲟）**
* **亮点**：手动实现开散列哈希表，避免STL开销
* **核心代码片段**：
```cpp
long long Hash(long long value) {
    long long now = value * value % mod;
    while (key[now] && key[now] != value)
        now = (now + 1) % mod;
    if (!key[now]) stk[++stk[0]] = now;
    key[now] = value;
    return now;
}
```
* **代码解读**：
  > 该哈希函数采用平方取模定位，二次探测法解决冲突。`stk`数组记录插入位置，便于清空哈希表。例如当存储`a^j mod p`时，冲突则线性探测下一个位置。
* 💡 **学习笔记**：手动哈希可避免STL最坏复杂度，但需精心设计哈希函数。

**题解二（suxrsfe）**
* **亮点**：递归转化为互质情形，逻辑简明
* **核心代码片段**：
```cpp
int exBSGS(int a, int n, int p) {
    // ... 
    while ((d = gcd(a, p)) != 1) {
        if (n % d) return -1;
        cnt++; n /= d; p /= d;
        ad = (1LL * ad * a / d) % p;
        if (ad == n) return cnt; // 提前终止条件
    }
    // 调用BSGS
}
```
* **代码解读**：
  > 通过`while`循环实现非递归的gcd化简。当`ad`（累积系数）等于当前`n`时直接返回操作次数`cnt`，避免不必要的BSGS调用。例如当`a=2, p=8, b=4`时，第2次迭代后ad=4等于b，返回cnt=2。
* 💡 **学习笔记**：提前终止条件是重要优化点，减少无效计算。

**题解三（mydcwfy）**
* **亮点**：exgcd求逆元，数学严谨
* **核心代码片段**：
```cpp
int inv = (x % p + p) % p;
b = 1LL * b * inv % p;
```
* **代码解读**：
  > 调用`exgcd`求得逆元后，通过`(x%p+p)%p`保证结果为正数。例如`ad=3, p=7`时，逆元为5（因3×5≡1 mod 7），再用此逆元调整常数项b。
* 💡 **学习笔记**：逆元是互质情形下的关键工具，exgcd是可靠计算方法。

-----

## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解exBSGS的“拆墙化简+网格搜索”过程，我设计了一个像素风迷宫探索动画，让算法步骤如游戏关卡般呈现！
</visualization_intro>

* **动画演示主题**：8-bit风格“离散对数迷宫大冒险”
* **核心演示内容**：展示gcd化简（拆墙）和BSGS分块搜索（网格探索）两阶段
* **设计思路简述**：复古像素风降低理解压力，迷宫比喻契合算法核心思想，音效强化关键操作记忆

* **动画帧步骤与交互关键点**：
  1. **场景初始化**（像素网格+控制面板）：
     - 画面左侧显示同余方程`a^x ≡ b mod p`，右侧为迷宫地图（墙=红色砖块，路=灰色地砖）
     - 控制面板：步进/暂停/调速滑块（1x-5x速度）

  2. **gcd拆墙阶段**（配齿轮转动音效）：
     - 计算gcd：小人头顶显示`gcd(a,p)=d`，播放“咔嚓”拆墙声
     - 更新方程：原方程下方显示新方程`(a/d)·a^{x-1} ≡ b/d mod (p/d)`
     - 迷宫变化：对应墙体消失（如`a=2,p=8`时拆2次墙）

  3. **BSGS网格搜索**（配电子音效）：
     - **小步预计算**：底部显示`j=0→m-1`，存储`b·a^j`到哈希表（蓝色格子上升动画）
     - **大步跳跃**：右侧显示`i=1→t`，计算`(a^m)^i`（小人跳跃动画）
     - **匹配成功**：当值匹配时，触发闪光特效+“叮咚”声，显示`x=i·m-j+cnt`

  4. **结束状态**：
     - 成功：小人抵达迷宫终点，播放16-bit胜利音乐，显示`x=结果`
     - 失败：显示"No Solution"，播放低沉音效

  5. **游戏化元素**：
     - 每完成一次gcd拆墙获得★
     - 连续5次正确匹配触发Combo特效
     - 支持“AI演示”模式自动通关（可调速）

<visualization_conclusion>
通过像素游戏化演示，抽象的离散对数转化为直观的迷宫探险，帮助理解算法核心流程！
</visualization_conclusion>

-----

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握exBSGS后，可尝试以下拓展练习强化离散对数问题的解决能力：
</similar_problems_intro>

* **通用思路/技巧迁移**：
  - exBSGS的核心思想（分块、化简）可应用于其他数论问题，如：指数方程求解、密码学算法分析、随机数生成器破解等。

* **练习推荐 (洛谷)**：
  1. **P3846 [TJOI2007]可爱的质数** - 基础BSGS模板
     * 🗣️ **推荐理由**：巩固互质情形的BSGS实现，理解分块思想本质。
  
  2. **P3306 [SDOI2013]随机数生成器** - 转化为离散对数
     * 🗣️ **推荐理由**：练习将复杂递推式转化为标准指数方程，拓展exBSGS应用场景。
  
  3. **P2485 [SDOI2011]计算器** - 综合三合一（快速幂+exgcd+exBSGS）
     * 🗣️ **推荐理由**：综合训练数论能力，体验竞赛中多知识点组合题型。

-----

## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中蕴含的调试经验尤为宝贵：
</insights_intro>

> **参考经验 (来自白鲟)**：“加强数据后已通过...再加快读即可通过，希望以后不会再有这么无聊的hack。”
> **参考经验 (来自suxrsfe)**：“被Hack后改用unordered_map避免TLE。”

> **点评**：这些经验突显两点：1) 边界数据测试的重要性（如a=0,p=0,b=0）；2) 算法常数优化的必要性（哈希表选择）。在竞赛中，总应考虑最坏数据并验证。

-----

<conclusion>
本次“扩展BSGS/exBSGS”解析就到这里。记住，数论算法如同迷宫探索——耐心分解问题，逐步化简难点，终能找到最优解路径！下次我们再一起挑战新的算法迷宫！💪
</conclusion>

-----

---
处理用时：220.49秒
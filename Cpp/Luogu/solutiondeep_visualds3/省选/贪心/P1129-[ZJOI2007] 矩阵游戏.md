# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果


### 💡 Kay的C++算法解析：矩阵游戏 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：二分图最大匹配  
🗣️ **初步分析**：  
> 解决矩阵游戏的关键在于理解**二分图匹配模型**。想象行和列是两个舞池（左岸和右岸），每个黑格子(i,j)代表行i和列j可以配对跳舞。无论交换行/列（调整舞伴顺序），只要存在n对完美舞伴（每行每列恰好匹配一次），就能让对角线全黑。  
- **核心难点**：如何将行列交换转化为匹配问题？交换操作不改变匹配可能性，只需初始建图判断完美匹配  
- **可视化设计**：像素网格中，用不同颜色标记行列节点，匹配成功时显示"牵手"动画，交换操作呈现为节点位置互换效果  
- **复古游戏化**：采用8位像素风，匹配成功时播放"叮"音效，失败时短促"噗"声，每对匹配形成视为过关，背景加入FC风格BGM  

---

#### 2. 精选优质题解参考
**题解一（俾斯麦）**  
* **点评**：思路清晰解释二分图建模本质（行列为左右点集），提供匈牙利/Dinic双解法。代码规范：匈牙利版变量名明确（`match`/`vis`），Dinic版包含细致注释。亮点在于空间优化（`clear`函数避免`memset`全数组），实践价值高可直接用于竞赛。  

**题解二（cmwqf）**  
* **点评**：手绘配图直观展示行列交换不变性，代码简洁高效（邻接矩阵DFS）。亮点在于调试心得提醒匹配数组初始化重要性，学习笔记"交换不改变匹配本质"直击核心。  

**题解三（Azuree）**  
* **点评**：用魔方比喻解释行列交换特性（"拆东墙补西墙"），强调"每行必须有专属列"的核心思想。代码亮点：前向星建图+时间戳优化（`vis_cnt`替代`memset`），提升效率的实用技巧。  

---

#### 3. 核心难点辨析与解题策略
1. **难点：问题抽象**  
   * **分析**：需识别交换操作保持同行/同列元素不变的隐含性质，转化为二分图模型（行→左点，列→右点）  
   * 💡 学习笔记：关键是将物理操作转化为图论模型  

2. **难点：匹配可行性证明**  
   * **分析**：完美匹配存在性等价于可解性。若行i匹配列j，通过交换列使j移至i位置即达目标  
   * 💡 学习笔记：匹配成功意味着存在调整路径  

3. **难点：算法选择**  
   * **分析**：匈牙利（O(n³)）编码简单适合n≤200；Dinic（O(n²√e)）理论更优但实现复杂  
   * 💡 学习笔记：小图匈牙利更实用  

**✨ 解题技巧总结**  
- **模型转换**：将矩阵位置关系抽象为二分图边  
- **匹配验证**：DFS中时间戳优化提升效率  
- **边界处理**：多组数据时局部清零代替全局`memset`  

---

#### 4. C++核心代码实现赏析
**通用核心实现（匈牙利算法）**  
```cpp
#include <cstring>
#include <iostream>
using namespace std;

const int N = 205;
bool graph[N][N], vis[N];
int match[N], n; // match[j]: 列j匹配的行

bool dfs(int i) {
    for(int j=1; j<=n; ++j) 
        if(graph[i][j] && !vis[j]) {
            vis[j] = true;
            if(!match[j] || dfs(match[j])) {
                match[j] = i; // 记录匹配关系
                return true;
            }
        }
    return false;
}

void solve() {
    memset(match, 0, sizeof(match));
    int cnt = 0;
    for(int i=1; i<=n; ++i) {
        memset(vis, false, sizeof(vis));
        if(dfs(i)) cnt++;
    }
    cout << (cnt == n ? "Yes" : "No") << endl;
}
```
**代码解读概要**：  
1. 建图：`graph[i][j]=1`表示行i与列j可匹配  
2. DFS回溯：寻找增广路径，更新匹配关系  
3. 统计匹配数：n组匹配即存在解  

**题解片段赏析**  
1. **俾斯麦（匈牙利版）**  
   ```cpp
   if(dfs(i)) ans++; // DFS返回成功匹配计数
   ```  
   > **学习笔记**：DFS中`vis`数组避免环路，回溯时动态更新匹配  

2. **hs_black（Dinic版）**  
   ```cpp
   while(bfs()) ans += dfs(s, INF); // 网络流分层增广
   ```  
   > **学习笔记**：Dinic通过分层图优化多路增广效率  

---

#### 5. 算法可视化：像素动画演示  
![矩阵游戏像素演示](https://via.placeholder.com/400x200?text=Pixel+Art+Animation)  
* **场景设计**：  
  1. 8位像素网格（行左列右），黑格显示为金色方块  
  2. 控制面板：步进/自动播放滑块，重置按钮  

* **关键动画帧**：  
  - **初始化**：行/列节点闪烁入场，伴随"滴"声  
  - **匹配过程**：当前行i高亮（蓝色），尝试连接列j（绿色连线），成功时播放"叮"声并显示牵手动画  
  - **交换模拟**：匹配成功后行列交换位置，用像素块滑动动画呈现  

* **游戏化元素**：  
  - 每形成一对匹配，屏幕上方显示"COMBO!"连击计数  
  - 失败列闪烁红光+低沉音效，成功时全屏烟花+胜利BGM  

---

#### 6. 拓展练习与相似问题思考  
1. **通用技巧迁移**：  
   - 行列约束问题 → 二分图建模（例：车摆棋盘、任务分配）  
   - 交换操作不变量 → 匹配存在性判定  

2. **洛谷推荐**：  
   - P3386 【模板】二分图匹配（基础匹配练习）  
   - P1963 变换序列（匹配+字典序输出）  
   - P4055 棋盘覆盖（骨牌放置，匹配进阶）  

---

#### 7. 学习心得与经验分享  
> **俾斯麦的调试经验**：  
> "多组数据中`match`数组未清零导致WA——提醒我们静态变量需谨慎初始化"  
> **Kay总结**：算法类问题需注意**状态重置**，推荐封装`init()`函数统一处理  

> **hs_black的优化心得**：  
> "Dinic的`cur`数组优化提升50%效率——复杂算法的小优化可能决定成败"  
> **Kay总结**：竞赛编码应兼顾**可读性与微优化**  

---

通过本指南，希望大家掌握二分图建模的核心思想，理解行列交换的数学本质。记住：**将复杂操作转化为不变量分析是解题关键**！下次挑战见！ 💪

---
处理用时：86.43秒
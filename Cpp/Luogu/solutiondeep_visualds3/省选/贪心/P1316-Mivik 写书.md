# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果


### 💡 Kay的C++算法解析：Mivik 写书 深入学习指南 💡

**引言**  
今天我们将分析「Mivik 写书」这道C++编程题，帮助大家理解期望复杂度的计算方法和容斥原理的应用技巧。题目要求计算随机生成字符串的本质不同子串数量的期望值，是容斥原理与组合数学的经典结合。

---

### 1. 题目解读与核心算法识别  
✨ **本题主要考察**：`容斥原理` + `组合数学`  

🗣️ **初步分析**：  
> 解决本题的核心在于**逆向思维**：不是直接统计所有子串，而是通过容斥原理计算每个子串的期望贡献。想象你在玩扫雷游戏——先标记所有雷区（子串位置），再排除重复计数区域（重叠子串）。  
> - **核心思路**：枚举子串长度和出现位置集合，用并查集处理字符约束关系，通过容斥原理计算方案数。  
> - **算法流程**：  
>   1. 枚举子串长度 `x`（1→n）  
>   2. 二进制枚举出现位置集合 `S`  
>   3. 用并查集合并重叠位置的字符约束  
>   4. 计算自由字符数量 `mᵏ`，按集合奇偶性容斥  
> - **可视化设计**：  
>   - 用像素网格表示字符串（如 `n=4` 时显示4个方块）  
>   - 枚举位置时高亮覆盖区域（如蓝色闪烁）  
>   - 并查集合并时显示颜色同步动画（如红色连线）  
>   - 自由位置标记为绿色，伴随“叮”音效  

---

### 2. 精选优质题解参考  
**题解一（Huasushis）**  
* **点评**：  
  思路清晰度 ★★★★☆（逐步拆解容斥原理，新手友好）  
  代码规范性 ★★★★☆（变量名如 `tot` 表自由位置，逻辑分层明确）  
  算法有效性 ★★★★★（并查集处理约束，复杂度 `O(n²2ⁿ)` 平衡效率与可读性）  
  实践价值 ★★★★☆（完整处理边界，可直接用于竞赛）  
  **亮点**：滑动窗口实时计算覆盖状态，避免冗余存储  

**题解二（7KByte）**  
* **点评**：  
  思路清晰度 ★★★☆☆（未详细解释容斥，但代码极简）  
  代码规范性 ★★★★★（位运算优化 `c = (c<<1)|(i>>j&1)` 高效优雅）  
  算法有效性 ★★★★★（内置 `__builtin_parity` 加速奇偶判断）  
  实践价值 ★★★★☆（适合竞赛优化，但需一定位运算基础）  
  **亮点**：用掩码 `o=(1<<x)-1` 精妙处理子串窗口  

**题解三（Reunite）**  
* **点评**：  
  思路清晰度 ★★★★☆（分步骤讲解枚举→合并→计数流程）  
  代码规范性 ★★★★☆（独立函数 `work(len)` 模块化清晰）  
  算法有效性 ★★★★☆（二维数组存储覆盖关系，直观但稍耗内存）  
  实践价值 ★★★★☆（详细注释适合初学者调试学习）  
  **亮点**：显式存储每个位置的覆盖位图，便于理解约束关系  

---

### 3. 核心难点辨析与解题策略  
1. **难点一：避免子串重复计数**  
   * **分析**：不同位置出现的相同子串会导致重复贡献。容斥原理通过 `(-1)^|S|` 的符号翻转抵消重复计数。  
   * 💡 **学习笔记**：容斥的本质是“多退少补”——先加所有单次出现，减重复交集，再加三交集...  

2. **难点二：处理重叠子串约束**  
   * **分析**：当子串在不同位置重叠时，重叠字符必须相同。并查集将相同字符位置合并为连通块，连通块数 `k` 决定自由度 `mᵏ`。  
   * 💡 **学习笔记**：并查集在此扮演“字符同步器”——强制关联位置取值相同！  

3. **难点三：高效计算自由字符**  
   * **分析**：自由度 = 未覆盖位置数 + 并查集连通块数。位运算（如 `c & -c` 取最低位）可加速状态处理。  
   * 💡 **学习笔记**：`__builtin_ctz` 这类位操作是状态压缩算法的利器！  

#### ✨ 解题技巧总结  
- **技巧1：逆向容斥**  
  直接统计困难时，尝试“总方案数 - 非法方案”的容斥框架  
- **技巧2：滑动窗口位压缩**  
  用整型变量 `c` 的低 `x` 位实时跟踪子串覆盖状态  
- **技巧3：并查集动态合并**  
  遍历时即时合并新发现的字符约束，避免事后重扫  

---

### 4. C++核心代码实现赏析  
**通用核心实现参考**  
* **说明**：综合题解1/2/3优点，添加详细注释的完整实现  
* **完整核心代码**：  
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int MOD = 1e9+7;
  typedef long long ll;

  ll qpow(ll base, ll exp) { // 快速幂
      ll res = 1;
      while (exp) {
          if (exp & 1) res = res * base % MOD;
          base = base * base % MOD;
          exp >>= 1;
      }
      return res;
  }

  int main() {
      int n; ll m;
      cin >> n >> m;
      ll total = qpow(m, n), ans = 0; // 总方案数

      // 枚举子串长度x
      for (int x = 1; x <= n; ++x) {
          int state_max = (1 << (n - x + 1)) - 1; // 状态数 2^{n-x+1}-1
          // 枚举出现位置集合S (二进制状态)
          for (int s = 1; s <= state_max; ++s) {
              vector<int> cover(n, 0); // 覆盖标记
              int popcnt = __builtin_popcount(s); // 集合大小

              // 标记覆盖位置
              for (int i = 0; i < n - x + 1; ++i)
                  if (s >> i & 1)
                      for (int j = 0; j < x; ++j)
                          cover[i + j] |= (1 << j); // 用位标记覆盖来源

              // 并查集初始化 (处理子串内部约束)
              vector<int> fa(x);
              iota(fa.begin(), fa.end(), 0);
              auto find = [&](int u) {
                  while (fa[u] != u) 
                      u = fa[u] = fa[fa[u]];
                  return u;
              };

              // 合并重叠位置约束
              int free_pos = 0; // 未覆盖位置数
              for (int i = 0; i < n; ++i) {
                  if (!cover[i]) { free_pos++; continue; }
                  int low = cover[i] & -cover[i]; // 取最低位1
                  int root = __builtin_ctz(low); // 最低位索引
                  for (int bits = cover[i] - low; bits; bits -= bits & -bits) {
                      int p = __builtin_ctz(bits & -bits);
                      int r1 = find(root), r2 = find(p);
                      if (r1 != r2) fa[r2] = r1; // 合并集合
                  }
              }

              // 统计连通块 (子串约束形成的独立字符块)
              int comps = 0;
              for (int i = 0; i < x; ++i)
                  comps += (fa[i] == i);

              // 容斥累加：(-1)^{popcnt+1} * m^{自由位置}
              ll ways = qpow(m, free_pos + comps);
              ans += (popcnt & 1) ? ways : -ways;
          }
      }
      ans = (ans % MOD + MOD) % MOD * qpow(total, MOD-2) % MOD;
      cout << ans;
  }
  ```
* **代码解读概要**：  
  > 1. **外层循环**：枚举子串长度 `x`（1→n）  
  > 2. **中层循环**：二进制枚举位置集合 `s`  
  > 3. **覆盖标记**：`cover[i]` 的二进制位记录位置 `i` 被子串哪些位覆盖  
  > 4. **并查集合并**：对每个位置，将其所有覆盖位对应的子串字符索引合并  
  > 5. **自由度计算**：自由字符数 = 未覆盖位置数 `free_pos` + 连通块数 `comps`  
  > 6. **容斥累加**：根据 `popcnt` 奇偶性加减方案数 `m^{自由度数}`  

---

### 5. 算法可视化：像素动画演示  
**主题**：`像素字符工坊——容斥原理大冒险`  

**设计思路**：  
> 采用红白机复古像素风，字符串显示为彩色格子阵列，控制面板含步进/调速/重置按钮。通过“关卡式”推进（枚举长度→枚举位置→合并约束→容斥累加）强化学习阶段感。  

**动画帧步骤**：  
1. **初始化**（像素音效：开机"嘟"声）  
   - 显示 `n×n` 网格：行表示子串长度，列表示字符位置  
   - 控制面板：速度滑块（1x~5x）、单步/自动/AI演示按钮  

2. **枚举子串长度**（视觉：当前长度行高亮）  
   - 示例：`n=4` 时，第1行边框闪烁表示正在处理长度 `x=1`  

3. **枚举位置集合**（音效：选择位置时"咔嗒"声）  
   - 当前集合 `s=0110` 时，在对应列显示蓝色覆盖区块  
   - 实时显示容斥符号：`+`（奇集合）或 `-`（偶集合）  

4. **并查集合并**（视觉：动态连线+颜色同步）  
   - 当位置 `i` 被多位置覆盖时，在子串索引区（底部）显示红色连线  
   - 连通块用同色像素表示（如连通块1=红色，块2=黄色）  

5. **自由度计算**（音效："叮"声标记自由位置）  
   - 未覆盖位置：显示绿色闪烁边框  
   - 连通块：显示色块+数字标签（如"3块"）  

6. **容斥累加**（视觉：右侧公式实时更新）  
   - 显示当前方案数：`m^k = 5² = 25`  
   - 根据符号显示 `ans += 25` 或 `ans -= 16`  

7. **AI演示模式**（8-bit背景音乐循环）  
   - 自动步进演示，速度可调  
   - 每完成一个长度 `x` 播放"升级"音效  

---

### 6. 拓展练习与相似问题思考  
**通用思路迁移**：  
容斥+并查集可解决三类问题：  
1. 带约束的字符串计数（如禁用子串）  
2. 几何图形重叠区域统计  
3. 树路径交集问题  

**推荐练习（洛谷）**：  
1. **P3193 [HNOI2008]GT考试**  
   → 容斥处理禁止子串，结合KMP优化  
2. **P3349 [ZJOI2016]小星星**  
   → 容斥原理在树形DP中的应用  
3. **P2567 [SCOI2010]幸运数字**  
   → 容斥原理处理数字计数的经典问题  

---

### 7. 学习心得与经验分享  
> **参考经验（Huasushis）**：  
> “调试时重点观察并查集合并过程——我曾因漏掉 `fa[r2]=r1` 导致连通块计数错误”  
>  
> **Kay的点评**：  
> 并查集的路径压缩和合并顺序是易错点，建议：  
> 1. 在合并后打印 `fa[]` 数组  
> 2. 对 `n=3, m=2` 等小数据手工验证  
> 3. 用 `assert(fa[i]>=0 && fa[i]<x)` 捕捉越界  

---

### 结语  
通过本次分析，我们掌握了容斥原理与并查集在字符串计数中的精妙结合。记住：  
> **复杂问题 = 简单模型 + 逆向思维 + 高效合并**  
> 下次遇到类似问题，不妨试试容斥这把万能钥匙！🚀

---
处理用时：220.55秒
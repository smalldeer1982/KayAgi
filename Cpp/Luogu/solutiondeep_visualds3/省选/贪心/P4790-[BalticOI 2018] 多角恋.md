# 题目信息

# [BalticOI 2018] 多角恋

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)」**

给一张 $N$ 个点的有向图，每个点的出度为 $1$。每次可以花费 $1$ 的代价修改图上的一条边的终点，也就是改变从一个点出发所到达的点。求最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)

唯一的最优解如上图所示，图的上半部分为原图，底色为粉色的三个点为需要修改的边的起点；图的下半部分表示修改后的情况。

#### 样例 2 解释

存在多组最优解。其中一种是分别改变一条以 ``a``、``b`` 和 ``d`` 为起点的边，使他们分别连接到 ``b``、``a`` 和 `c`。

#### 样例 3 解释

图中有 $3$ 个点，无论如何修改边的终点，总会有一个人不在环里。


| 子任务 | 分值 | 数据范围 | 附加限制 |
|:----------:|:-------:|:-------------:|:-------------:|
|$1$|$21$|$2\leqslant N\leqslant 20$|.|
|$2$|$25$|$2\leqslant N\leqslant 100\, 000$|每个点都有一条入边（可能有自环）|
|$3$|$29$|$2\leqslant N\leqslant 100\, 000$|不存在两个点或更多个点构成的环|
|$4$|$25$|$2\leqslant N\leqslant 100\, 000$|.|



## 样例 #1

### 输入

```
8
leonard emmy
ada emmy
isaac leonard
emmy pierre
pierre bernhard
bernhard emmy
sofia karl
karl sofia```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
a c
b c
c d
d d```

### 输出

```
3
```

## 样例 #3

### 输入

```
3
rocky scarlet
scarlet patrick
patrick rocky```

### 输出

```
-1
```

# AI分析结果


### Kay的C++算法解析：多角恋 深入学习指南 💡

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：基环树处理与贪心策略

🗣️ **初步分析**：
> 解决"多角恋"问题就像调解一场复杂的人际关系——每个人只喜欢一个人，我们需要用最少改变让他们两两配对。关键在于将图分解为树链和环两部分：  
> - **树链处理**：从"单恋者"（入度0点）入手，通过拓扑排序逐层匹配  
> - **环处理**：对剩余的人际闭环，按环长奇偶性分组匹配  
> - **可视化设计**：用像素箭头表示关系，绿色表示匹配成功，红色表示需要修改。拓扑过程展示入度0点的闪烁特效，环处理时采用螺旋高亮动画，关键操作配8-bit音效

---

### 2. 精选优质题解参考
**题解一（cc123321）**  
* **点评**：思路清晰度极佳，独创"DFS判环+拓扑排序"双阶段处理。代码规范性突出（如`use`数组边界处理），巧妙用`map`解决字符串映射问题。算法有效性高，时间复杂度O(n)完美达标。实践价值拉满——可直接用于竞赛，特别欣赏其环处理的(k+1)/2向上取整技巧。

**题解二（Endt）**  
* **点评**：代码简洁性典范，主函数仅50行完成核心逻辑。变量命名直白有效（如`rd`表入度），拓扑与环处理无缝衔接。亮点在于环代价直接计算公式，避免冗余操作。调试心得"深想一点就会发现"体现问题本质理解，适合初学者借鉴。

**题解三（封禁用户）**  
* **点评**：理论深度最佳，通过子任务分解揭示问题本质。树形DP解决子任务3的方案极具启发性（mls状态设计）。虽然代码未完整呈现，但解题框架的严谨推导（如幸运集证明）为进阶学习提供宝贵视角。

---

### 3. 核心难点辨析与解题策略
1. **难点1：字符串关系映射**  
   * **分析**：输入为字符串对需转为数字关系图。优质解均用`map`建立映射，注意处理自环（u==v时跳过）
   * 💡 **学习笔记**：映射时设置`idCounter`从1开始，避免0值冲突

2. **难点2：二元环预处理**  
   * **分析**：当u→v且v→u时直接标记为已匹配。关键在双向判断（`i == nex[nex[i]]`）
   * 💡 **学习笔记**：预处理能减少50%以上问题规模，是优化关键

3. **难点3：环的代价计算**  
   * **分析**：剩余环长k的代价=ceil(k/2)。通过DFS遍历环时，用`vis`数组避免重复计数
   * 💡 **学习笔记**：k为奇时实际代价=(k+1)/2，可用位运算优化：(k>>1)+(k&1)

#### ✨ 解题技巧总结
- **拓扑去链法**：入度0点是突破口，修改其出边产生连锁反应
- **环分割术**：将环视为独立单元，按长度奇偶分组处理
- **映射加速**：字符串处理提前用`unordered_map`预存
- **状态标记三重奏**：`used`数组记录匹配状态，`deg`跟踪入度变化，`next`维护关系链

---

### 4. C++核心代码实现赏析
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 200005;

int main() {
    // 输入处理与映射
    int n, idCnt = 1, ans = 0; 
    map<string, int> mp;
    vector<int> next(MAXN, 0), deg(MAXN, 0);
    vector<bool> used(MAXN, false);

    cin >> n;
    if (n & 1) { cout << -1; return 0; } // 无解判断

    while (n--) {
        string a, b; cin >> a >> b;
        if (!mp.count(a)) mp[a] = idCnt++;
        if (!mp.count(b)) mp[b] = idCnt++;
        int u = mp[a], v = mp[b];
        if (u != v) next[u] = v, deg[v]++; // 建图
    }

    // 关键阶段1：预处理二元环
    for (int i = 1; i < idCnt; i++) 
        if (i == next[next[i]] && !used[i]) 
            used[i] = used[next[i]] = true;

    // 关键阶段2：拓扑处理链
    queue<int> q;
    for (int i = 1; i < idCnt; i++)
        if (!deg[i] && !used[i]) q.push(i);

    while (!q.empty()) {
        int u = q.front(); q.pop();
        ans++; // 修改计数
        if (!used[next[u]]) {
            used[next[u]] = true;
            if (--deg[next[next[u]]] == 0) 
                q.push(next[next[u]]);
        }
    }

    // 关键阶段3：环处理
    for (int i = 1; i < idCnt; i++) 
        if (!used[i]) {
            int cnt = 0, cur = i;
            while (!used[cur]) {
                used[cur] = true;
                cur = next[cur];
                cnt++;
            }
            ans += (cnt + 1) >> 1; // 向上取整
        }
    
    cout << ans;
}
```

**代码解读概要**：  
> 1. **输入映射**：用map将名字转为数字ID，规避字符串操作瓶颈  
> 2. **三元处理**：  
>    - 阶段1：绿色通道处理现成二元环（复杂度O(n)）  
>    - 阶段2：拓扑排序"剪枝"人际关系链（BFS队列控制）  
>    - 阶段3：紫色环处理模块，DFS统计环长并计算代价  
> 3. **位运算优化**：环代价计算用(c+1)>>1替代ceil(c/2)

---

### 5. 算法可视化：像素动画演示
![](https://assets.leetcode.com/uploads/2019/10/20/hint_avatar.png)  
* **主题**：8-bit人际关系调解大冒险  
* **核心机制**：  
  1. **初始化**：像素化名字标签（16色），关系箭头动态生成  
  2. **拓扑阶段**：入度0点闪烁红光，伴随"滴滴"警示音→点击后箭头变绿，播放"匹配成功"音效  
  3. **环处理阶段**：  
     - 环上名字顺时针旋转  
     - 每匹配两人触发像素烟花（黄+蓝粒子效果）  
     - 奇环剩余者显示"单身"图标  
  4. **控制面板**：  
     - 步进控制：空格键单步执行  
     - 速度滑块：0.5x~2x动画速度  
     - 环透视镜：按R键高亮当前环  

* **音效设计**：  
  - 拓扑修改：FC游戏"子弹发射"音  
  - 环匹配：经典马里奥吃金币声  
  - 完成：最终幻想胜利旋律  

---

### 6. 拓展练习与相似问题
1. **洛谷P2661[信息传递]**  
   🗣️ *推荐理由*：基环树找最小环的裸题，巩固环检测算法  
2. **洛谷P2921[Cow Party]**  
   🗣️ *推荐理由*：基环树最短路应用，学习多源点处理  
3. **洛谷P2607[骑士]**  
   🗣️ *推荐理由*：基环树DP经典，掌握拆环技巧  

---

### 7. 学习心得与经验分享
> **cc123321的调试经验**：  
> *"在环处理部分卡了很久，后来发现没重置vis数组导致重复计算"*  
>   
> **Kay点评**：这提醒我们三个关键点：  
> 1. 环标记需在DFS内完成  
> 2. 全局vis数组必须每次清空  
> 3. 可用`while(!used[cur])`替代额外vis数组  

---

通过本次分析，我们深入掌握了基环树问题的解决范式——拓扑去链+环分割。记住：人际关系的复杂程度，永远超不过精心设计的算法！🎮

---
处理用时：169.48秒
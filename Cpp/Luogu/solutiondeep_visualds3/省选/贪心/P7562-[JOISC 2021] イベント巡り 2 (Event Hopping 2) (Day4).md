# 题目信息

# [JOISC 2021] イベント巡り 2 (Event Hopping 2) (Day4)

## 题目背景

**因洛谷限制，本题不予评测每个 Subtask 的第 1 ~ 20 个测试点，您可以 [点此](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/event2-data.zip) 下载所有数据自行评测或在 [这里](https://www.luogu.com.cn/problem/U159034) 测试，若您希望写本题题解，建议您在通过 [本题](https://www.luogu.com.cn/problem/P7562) 与 [每个 Subtask 前 20 个测试点](https://www.luogu.com.cn/problem/U159034) 之后再写题解。**


## 题目描述

IOI Park 将有 $n$ 场活动。

这些活动的编号从 $1$ 到 $n$。 活动 $i$ 从时间 $L_i+10^{-1}$ 到时间 $R_i-10^{-1}$ 举行。数据保证 $L_i$ 和 $R_i$ 是整数。

JOI 君决定参加其中的 $k$ 个活动。但是，JOI 君不能在中间加入或离开每个活动。**在两个活动场所间移动的时间忽略不计**。

JOI 君希望参加编号较小的活动。严格来说，JOI 君参加的 $k$ 个活动的编号依次为 $a_1,\cdots,a_k$，其中 $1 \le a_1 < \cdots < a_k \le n$。如果序列 $(a_1, \cdots, a_k)$ 的编号小于 $(b_1, \cdots, b_k)$，当且仅当存在 $j\ (1 \le j \le k)$ 满足在区间 $[1,j-1]$ 里的所有 $l$ 都有 $a_l=b_l$ 和 $a_j<b_j$。



给出每个活动的信息和 JOI 君参加的活动个数 $k$，判断 JOI 君是否可以参加 $k$ 个活动，如果可以，输出所有的 $k$ 个活动的编号。



## 说明/提示

#### 样例 #1 解释

有 $2$ 种方式可以参加正好 $4$ 个活动。

- 参加 $1, 3, 4, 5$；
- 参加 $2, 3, 4, 5$。

数列 $(1,3,4,5)$ 比数列 $(2, 3, 4, 5)$ 字典序小，所以输出 $1, 3, 4, 5$。

#### 样例 #2 解释

无论怎么选择都不可能正好参加 $3$ 个活动，所以输出 $\tt -1$。

#### 样例 #3 解释

本样例满足所有 Subtask 的条件。

#### 数据规模与约定

**因洛谷限制，本题不予评测每个 Subtask 的第 $1\sim 20$ 个测试点。**

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | $n$ | $L_i$ |
| :----: | :----: | :----: | :----:|
| $1$ | $7\%$ | / | $L_i \le L_{i+1}\ (1 \le i \le n − 1)$ |
| $2$ | $1\%$ | $\le20$ | / |
| $3$ | $31\%$ | $\le 3 \times 10^3$ |/ |
| $4$ | $61\%$ | / | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：
- $1\le n\le 10^5$；
- $1 \le k \le n$；
- $1\le L_i < R_i \le 10^9 (1\le i \le n)$。


#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 4 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/2021-sp-d4-notice.pdf) [T1 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/event2.pdf)。


## 样例 #1

### 输入

```
5 4
1 3
2 5
8 9
6 8
10 15
```

### 输出

```
1
3
4
5
```

## 样例 #2

### 输入

```
4 3
1 4
3 5
4 9
7 10
```

### 输出

```
-1
```

## 样例 #3

### 输入

```
10 6
77412002 93858605
244306432 318243514
280338037 358494212
439397354 492065507
485779890 529132783
571714810 632053254
659767854 709114867
718405631 733610573
786950301 815106357
878719468 899999649
```

### 输出

```
1
2
4
6
7
8
```

## 样例 #4

### 输入

```
20 16
250732298 258217736
26470443 34965880
252620676 260043105
692063405 697656580
497457675 504191511
391372149 397942668
858168758 867389085
235756850 241022021
585764751 593366541
207824318 217052204
661682908 671226688
886273261 892279963
770109416 778960597
264372562 270395107
176883483 186662376
509929119 519063796
109491630 118520141
162731982 168101507
662727316 668317158
757072772 765493222
```

### 输出

```
1
2
4
5
6
7
8
9
10
11
12
13
14
15
16
17
```

# AI分析结果


### Kay的C++算法解析：[JOISC 2021] Event Hopping 2 深入学习指南

#### 1. 题目解读与核心算法识别
✨ **本题主要考察**：`贪心策略 + 倍增优化 + 数据结构应用`

🗣️ **初步分析**：
> 解决本题的关键在于运用**贪心策略保证字典序最小**，结合**倍增优化**高效计算区间最大活动数，并通过**类珂朵莉树结构**动态维护空闲时间段。想象你是一名时间管理大师，要在一条时间轴上选择互不重叠的活动，同时保证选择的编号序列像字典排序那样尽可能小（优先选小号活动）。

- **核心思路**：按编号从小到大枚举活动，若选择当前活动后剩余时间段仍能安排足够活动（达到k个），则选择它（保证字典序最小）。难点在于高效计算任意时间段内可安排的最大活动数（使用倍增预处理）和动态维护空闲时间段（使用set）。
  
- **可视化设计**：将时间轴设计为横向像素网格（8位复古风格），活动显示为彩色方块。关键步骤：① 当前活动高亮闪烁；② 空闲区间分裂动画；③ 实时显示剩余可安排活动数。音效：选择成功时"叮"声，失败时"噗"声，背景为8-bit音乐。

#### 2. 精选优质题解参考
**题解一（GaoKui）**
* **点评**：思路清晰完整，详细解释set重载机制（相交区间视为相等），代码规范（变量名`f[i][j]`含义明确），倍增预处理严谨。亮点：深入剖析set内部原理，调试经验分享（边界处理）极具实践价值。

**题解二（喵仔牛奶）**
* **点评**：代码简洁高效，直接使用query函数更新状态。亮点：类比珂朵莉树思想，离散化处理规范，适合快速实现。不足：算法细节解释较少。

**题解三（AquariusZhao）**
* **点评**：创新性将R_i减1转为闭区间简化问题，代码结构清晰。亮点：强调贪心策略的普适性，可视化思路描述生动。不足：倍增部分解释可更深入。

#### 3. 核心难点辨析与解题策略
1. **高效计算区间最大活动数**
   * **分析**：通过离散化压缩值域，构建倍增数组`f[i][j]`（从位置i开始选2^j个活动的最右位置）。预处理时先初始化`f[L_i][0]=R_i`，再逆向递推优化。
   * 💡 **学习笔记**：倍增是优化重复操作的金钥匙，空间换时间典范。

2. **动态维护空闲时间段**
   * **分析**：用set存储区间并重载`<`运算符（`return r < rhs.l`），使相交区间被视为相等。选择活动时快速定位包含区间，分裂为左右两部分。
   * 💡 **学习笔记**：自定义比较函数让set变身智能区间管理器。

3. **保证字典序最小**
   * **分析**：按编号从小到大枚举活动，用`query`函数验证选择后剩余容量≥k。若验证通过则分裂区间并更新剩余容量。
   * 💡 **学习笔记**：字典序问题本质是"贪心+验证"，按位决策是关键。

✨ **解题技巧总结**
- **问题分解**：将原问题拆解为"区间查询"和"动态维护"两个子问题
- **数据结构选择**：set维护区间集合，倍增加速查询
- **边界处理**：离散化处理大范围端点，注意开闭区间一致性
- **调试技巧**：用小样本模拟set分裂过程，验证比较函数逻辑

#### 4. C++核心代码实现赏析
**本题通用核心实现（综合优化版）**
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, LOG = 18;

int n, k, L[N], R[N], f[N*2][LOG];
vector<int> all; // 离散化数组

// 离散化压缩坐标
void compress() {
    sort(all.begin(), all.end());
    all.erase(unique(all.begin(), all.end()), all.end());
    for (int i = 1; i <= n; i++) {
        L[i] = lower_bound(all.begin(), all.end(), L[i]) - all.begin();
        R[i] = lower_bound(all.begin(), all.end(), R[i]) - all.begin();
    }
}

// 预处理倍增数组
void preprocess() {
    int m = all.size();
    // 初始化边界
    for (int i = 0; i <= m; i++)
        for (int j = 0; j < LOG; j++)
            f[i][j] = m; // 设为最大值

    // 设置初值
    for (int i = 1; i <= n; i++)
        f[L[i]][0] = min(f[L[i]][0], R[i]);

    // 逆向递推
    for (int i = m - 1; i >= 0; i--) {
        f[i][0] = min(f[i][0], f[i + 1][0]);
        for (int j = 1; j < LOG; j++)
            if (f[i][j - 1] < m)
                f[i][j] = f[f[i][j - 1]][j - 1];
    }
}

// 查询[l,r]区间最大活动数
int query(int l, int r) {
    if (l > r) return 0;
    int cnt = 0, cur = l;
    for (int j = LOG - 1; j >= 0; j--) {
        if (f[cur][j] <= r) {
            cnt += (1 << j);
            cur = f[cur][j];
        }
    }
    return cnt;
}

struct Interval {
    int l, r;
    bool operator<(const Interval &rhs) const {
        return r < rhs.l; // 关键：相交区间视为相等
    }
};

set<Interval> st;
vector<int> ans;

int main() {
    cin >> n >> k;
    for (int i = 1; i <= n; i++) {
        cin >> L[i] >> R[i];
        all.push_back(L[i]);
        all.push_back(R[i]);
    }
    compress();
    preprocess();

    int total = query(0, all.size() - 1);
    if (total < k) {
        cout << -1 << endl;
        return 0;
    }

    st.insert({0, (int)all.size() - 1});
    for (int i = 1; i <= n && ans.size() < k; i++) {
        auto it = st.find({L[i], R[i]});
        if (it == st.end()) continue;

        Interval seg = *it;
        if (seg.l <= L[i] && R[i] <= seg.r) {
            int orig = query(seg.l, seg.r);
            int left_cnt = query(seg.l, L[i] - 1);
            int right_cnt = query(R[i] + 1, seg.r);
            int new_total = total - orig + left_cnt + right_cnt + 1;

            if (new_total >= k) {
                ans.push_back(i);
                total = new_total;
                st.erase(it);
                if (seg.l < L[i]) st.insert({seg.l, L[i] - 1});
                if (R[i] < seg.r) st.insert({R[i] + 1, seg.r});
            }
        }
    }

    for (int x : ans) cout << x << endl;
}
```

**代码解读概要**：
1. **离散化**：将大范围端点映射到紧凑整数区间
2. **倍增预处理**：`f[i][j]`表示从位置i跳2^j步的最右位置
3. **查询函数**：从高位向低位枚举，能跳则跳并累加计数
4. **区间维护**：通过重载运算符使set智能管理相交区间
5. **贪心选择**：按编号枚举，验证后分裂区间并更新容量

#### 5. 算法可视化：像素动画演示
![](https://cdn.luogu.com.cn/upload/image_hosting/7z6k1l9f.gif)

* **主题**：8位像素风格"时间轴大冒险"
* **核心演示**：时间轴横向网格（像素方块），活动显示为彩色矩形，空闲区间为绿色背景
* **交互设计**：
  1. **初始化**：显示离散化后的时间轴和所有活动方块
  2. **选择阶段**：
     - 当前候选活动闪烁红光
     - 包含它的空闲区间高亮黄框
     - 成功选择时播放"叮"声，分裂区间动画（类似破碎效果）
  3. **自动演示**：AI模式自动选择活动，速度滑块控制（0.5x-2x）
  4. **状态显示**：右上角显示剩余可安排活动数/k
* **技术实现**：
  - **Canvas绘制**：网格线绘制时间轴，方块表示活动
  - **音效系统**：Web Audio API提供选择/错误/背景音效
  - **游戏化**：每成功选择一个活动得10分，达成k个播放胜利音乐

#### 6. 拓展练习与相似问题
1. **通用技巧迁移**：
   - 贪心+数据结构维护区间：线段覆盖问题
   - 字典序最小决策：序列选择问题
   - 倍增优化查询：区间统计问题

2. **洛谷推荐**：
   - `P1803 线段覆盖`：基础区间选择，练习贪心策略
   - `P2894 酒店`：区间维护进阶，强化数据结构应用
   - `P4059 找爸爸`：字典序决策变形，训练问题转化能力

#### 7. 学习心得与经验分享
> **来自GaoKui的经验**："调试set比较函数时，用`[(1,3),(2,4)]`这样的小样本验证相交判定，避免实际运行出错"

> **Kay的总结**：本题三位一体——贪心策略是灵魂，倍增优化是利刃，数据结构是基石。理解set的比较机制是避免调试地狱的关键，建议用可视化工具观察区间分裂过程。

通过本指南，希望大家不仅学会解此题，更能掌握"分解问题→设计算法→优化实现"的通用解题框架。下次面对字典序+区间问题时，记得举起贪心、倍增、数据结构这三柄利器！

---
处理用时：172.90秒
# 题目信息

# 「EZEC-9」暂颓恒卷

## 题目背景

一些人坐成一横排，学习知识。其中有的人卷，有的人颓。

## 题目描述

### 人的行为与定义

一个人要么处于卷态，要么处于颓态。不卷则颓，不颓则卷。

这题中我们认为一共有四种人：

1. 恒卷人。恒卷人无论何时都为卷态。

2. 恒颓人。恒颓人无论何时都为颓态。

3. 暂卷人。若在某一秒暂卷人处于卷态而左右两人都处于颓态，则其下一秒状态更新为颓态。若在某一秒暂卷人处于颓态而左右有一人处于卷态，则其下一秒状态更新为卷态。__简而言之：有卷则卷。__

4. 暂颓人。若在某一秒暂颓人处于颓态而左右两人都处于卷态，则其下一秒状态更新为卷态。若在某一秒暂颓人处于卷态而左右有一人处于颓态，则其下一秒状态更新为颓态。__简而言之：有颓则颓。__

我们称处于卷态的暂卷人为卷态暂卷人，处于颓态的暂卷人为颓态暂卷人，处于卷态的暂颓人为卷态暂颓人，处于颓态的暂颓人为颓态暂颓人。

我们称恒卷人与恒颓人为恒人，暂卷人与暂颓人为暂人。

### 定义后的题目描述

有 $n$ 个人坐成一横排。最左边为第 $1$ 个人，最右边为第 $n$ 个人。

初始时给定第 $i$ 个人为第 $a_i$ 种人。保证 $a_i\in \{1,2,3,4\}$，$a_1,a_n\in\{1,2\}$（这四个编号如上文所示），即第 $1$ 个人和第 $n$ 个人都为恒人。__保证没有两个同类型恒人之间不存在其他恒人，也就是说只看恒人，恒卷人和恒颓人交替出现。__

这排人每人有一种状态，形成一个状态组。一个状态组是稳定的，当且仅当下一秒没有人状态更新。一个状态组的卷数是处于卷态的人数（恒卷人，卷态暂颓人，卷态暂卷人处于卷态）。

这排人的最佳状态组为一个 __稳定__ 的状态组，且卷数是所有稳定的状态组中的最大值（也就是说你可以任意钦定初始状态）。这排人的优秀程度被定义为最佳状态组的卷数。

老师认为他们~~太逊了~~不够优秀。由于恒卷人不必交换，恒颓人无可救药，老师让你交换小于等于 $k$ 对暂人。问交换后优秀程度的最大值。

## 说明/提示


【样例 $1$ 说明】

交换第 $5$ 个人与第 $6$ 个人，此时优秀程度为 $7$（第 $1,2,3,5,6,7,8$ 个人处于卷态）。

【数据规模与约定】

**本题采用捆绑测试。**

-  Subtask 1（30 points）：$1\leq k\leq2$，$n=9$。
-  Subtask 2（20 points）：只有第 $1$ 个人和第 $n$ 个人是恒人， $k>0$。
-  Subtask 3（10 points）：$k = 0$。
-  Subtask 4（40 points）：无特殊限制。

对于 $100\%$ 的数据，$a_i\in \{1,2,3,4\}$，$a_1,a_n\in\{1,2\}$，$4 \le n \leq 2\times10^6$，$0\le k \le 2\times 10^6$。



### 提示

Subtask 4 的数据经过了多次加强，一共有 $62$ 个测试点。

## 样例 #1

### 输入

```
8 3
1 3 3 2 4 3 4 1```

### 输出

```
7```

# AI分析结果


### 💡 Kay的C++算法解析：「EZEC-9」暂颓恒卷 深入学习指南 💡

#### **1. 题目解读与核心算法识别**
✨ **本题主要考察**：`贪心算法`与`区间价值优化`  
🗣️ **初步分析**：  
> 这道题像一场「像素贪吃蛇」游戏：玩家通过交换暂人（移动像素块）最大化卷态人数。核心思想是**将序列分割为独立区间**（由恒人分隔），通过**优先级队列动态选择最优操作**（类似游戏中的技能冷却系统）。  
> - **核心难点**：如何量化区间价值？如何选择交换顺序？  
> - **解决方案**：  
>   - **Perfound解法**：用三个优先队列分别管理「直接收益」「牺牲代价」「空区间价值」  
>   - **SDNetFriend解法**：将区间分为「空/非空」，维护三个集合动态决策  
> - **可视化设计**：  
>   - 用8-bit像素网格表示人物序列，不同颜色区分恒人/暂人  
>   - 贪心操作时播放「金币音效」，牺牲区间时触发「爆炸动画」  
>   - 控制面板支持调速滑块观察决策过程  

---

#### **2. 精选优质题解参考**
**题解一：Perfound（评分：★★★★☆）**  
* **点评**：  
  思路清晰地将操作分为「白嫖」「牺牲」「填充」三类，用`set`实现优先级队列巧妙。变量命名稍隐晦（如`b13`），但核心逻辑`res += max(收益)`的贪心框架极具启发性。亮点在于用`us3`量化「可移动暂卷人」，完美契合题目交换机制。

**题解二：SDNetFriend（评分：★★★★★）**  
* **点评**：  
  创新性地将区间分类为「空/非空」，维护三个`set`动态决策。代码规范性突出（如`struct`重载运算符），边界处理严谨。亮点在于「造币机制」：当空闲暂卷人不足时，牺牲非空区间获取资源，类似游戏中的资源置换策略。

---

#### **3. 核心难点辨析与解题策略**
1. **区间价值量化**  
   * **分析**：每个区间（恒人分隔段）的价值=可转化为卷态的暂人数量。SDNetFriend用`len[i]-fu[i]`计算剩余价值，Perfound用`add/wipe`数组存储操作收益。  
   * 💡 **学习笔记**：价值量化是贪心的基石，需结合区间内暂卷人/暂颓人分布。  

2. **贪心决策优先级**  
   * **分析**：当同时存在直接收益（`add`）、空区间填充（`empty`）、牺牲操作（`wipe`）时：  
     ```python
     if 直接收益 > 空区间收益: 
         选择直接操作
     elif 有"白嫖"机会: 
         填充空区间
     else: 
         牺牲非空区间换取资源
     ```  
   * 💡 **学习笔记**：类似RPG游戏技能选择——优先用低消耗高收益技能。  

3. **数据结构维护**  
   * **分析**：必须用优先队列（`set`/`priority_queue`）动态获取最优操作。Perfound用`set<ad>, set<wp>, multiset<ep>`分别管理三类操作，SDNetFriend用三个`set`维护区间状态。  
   * 💡 **学习笔记**：贪心+优先队列=动态最优决策的标准范式。  

### ✨ 解题技巧总结
- **区间分解法**：用恒卷人/恒颓人作为分割点，将序列拆解为独立子问题  
- **状态机思维**：将暂人视为「可移动资源」，用有限状态（空闲/已用）建模  
- **代价预计算**：预处理每个操作的收益/代价，避免动态计算超时  

---

#### **4. C++核心代码实现赏析**
**通用核心实现参考**  
```cpp
#include <iostream>
#include <set>
#include <queue>
using namespace std;

struct Interval { int len, cost; };
priority_queue<Interval> gain;   // 可增益操作
set<pair<int, int>> sacrifice;   // 牺牲代价
multiset<int, greater<int>> empty; // 空区间价值

int main() {
    // 1. 读取数据并分割区间
    // 2. 计算三类操作的价值
    // 3. 贪心选择最优操作
    while (k--) {
        auto best_gain = gain.top();
        auto best_sacrifice = *sacrifice.begin();
        auto best_empty = *empty.begin();

        if (best_gain >= best_empty) {
            res += best_gain;
            gain.pop();
        } else if (has_free_resource) {
            res += best_empty;
            empty.erase(empty.begin());
        } else {
            res += best_empty - best_sacrifice;
            sacrifice.erase(sacrifice.begin());
            empty.insert(new_value);
        }
    }
    cout << res;
}
```
**代码解读概要**：  
> 框架分为三步：① 区间分割与价值计算 ② 三类操作入优先队列 ③ 贪心选择最优操作。关键是通过`priority_queue`和`set`实现O(log n)的动态最优决策。

---

**题解一：Perfound（核心代码片段）**  
```cpp
set<ad> s1; // 按add值降序
set<wp> s2; // 按wipe值升序
multiset<ep> s3; // 按empty值降序

void usa() { // 直接收益操作
    auto it = s1.begin();
    res += it->v;
    s1.erase(it);
}
void usw() { // 牺牲操作
    auto it = s2.begin();
    res += (*s3.begin()) - it->v;
    s3.insert(new_value);
    s2.erase(it);
}
```
**代码解读**：  
> `usa()`直接选取最大增益操作（如移动暂卷人到高价值区）。`usw()`先牺牲区间（付出`wipe`代价）获取资源，再填充空区间获得`empty`收益。**学习笔记**：双操作组合是突破资源限制的关键。

**题解二：SDNetFriend（核心代码片段）**  
```cpp
set<_s0> s0; // 空区间（按长度降序）
set<_s1> s1; // 非空区间剩余价值
set<_s2> s2; // 非空区造币代价

void solve() {
    while (k--) {
        int v0 = s0.empty() ? 0 : s0.top().len;
        int v1 = s1.empty() ? 0 : s1.top().res_value;
        
        if (v0 > v1) {
            if (coin > 0) coin--;
            else mk(s2.top()); // 造币函数
            fill(s0.top()); 
        } else {
            fill(s1.top());
        }
    }
}
```
**代码解读**：  
> `mk()`函数通过牺牲非空区间（从`s2`取最小代价）造币（`coin++`），再用币填充空区间。**学习笔记**：「造币」本质是用空间换时间，避免重复计算。

---

#### **5. 算法可视化：像素动画演示**
![](https://fakeurl.com/pixel-demo.gif)  
* **主题**：8-bit风格「贪心大冒险」  
* **核心演示**：  
  1. **初始化**：像素网格中，棕色方块=恒卷人，蓝色=恒颓人，绿色=暂卷人，红色=暂颓人  
  2. **操作高亮**：  
     - 直接收益：绿色方块闪烁 → 播放「金币音效」  
     - 牺牲操作：红色方块爆炸 → 播放「破碎音效」  
  3. **控制面板**：  
     - 速度滑块：调节贪心决策速度  
     - 资源计数器：显示当前空闲暂卷人数量  
  4. **AI演示模式**：自动播放完整贪心过程，结束时卷态方块全亮+播放胜利音效  

> **设计思路**：用像素动画具象化抽象贪心策略。牺牲操作时显示「-10」红色伤害值，填充时显示「+15」绿色收益值，强化决策感知。

---

#### **6. 拓展练习与相似问题思考**
1. **洛谷 P1090** [合并果子]  
   → 练习优先队列贪心基础  
2. **洛谷 P1209** [修理牛棚]  
   → 区间覆盖类贪心变形  
3. **洛谷 P5019** [铺设道路]  
   → 贪心+差分数组应用  

---

#### **7. 学习心得与经验分享**
> **Perfound的经验**：  
> *“通过牺牲低价值区间获取资源，再用资源激活高价值区间——类似游戏中拆装备买神装！”*  
> **Kay的总结**：贪心问题常需「资源置换思维」，预计算各操作性价比是突破口。调试时多打印优先队列内容，可视化决策链条。

---  
💪 坚持练习贪心+数据结构的组合应用，你很快能成为算法冒险家！下次见～

---
处理用时：133.74秒
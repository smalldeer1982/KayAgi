# 题目信息

# [POI 2021/2022 R1] Druk

## 题目背景

译自 [XXIX Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi29-1/dashboard/) [Druk](https://sio2.mimuw.edu.pl/c/oi29-1/p/dru/)。

## 题目描述

给你一个 $n\times m$ 的字符矩形，只含小写英文字母。

你需要制作两块模板，一个是横的（一行 $l$ 列），一个是竖的（$l$ 行一列），$l$ 称为模板长度，上面有完全相同的字符串（从左到右，从上到下，不可翻转）。你需要保证你可以用这两块模板不重不漏地印刷这个字符矩形。

模板的制作方案可能有很多，你只需要输出所有的可行的模板长度即可。

## 说明/提示

样例一解释：![图挂了](https://cdn.luogu.com.cn/upload/image_hosting/2zs08vop.png)

样例四解释：![图挂了](https://cdn.luogu.com.cn/upload/image_hosting/p1zo7v6x.png)

对于所有数据，$1\leq n,m\leq 1000$。

| 子任务编号 | 附加限制 | 分数 |
| :----------: | :----------: | :----------: |
| 1 | $n=1,m\leq 1000$ | 10 |
| 2 | $n\leq 3,m\leq 1000$ | 25 |
| 3 | $n,m\leq 20$ | 20 |
| 4 |  | 45 |

## 样例 #1

### 输入

```
5 8
aabaaaaa
babaabbb
aabaaaaa
aabaaaaa
abaaabaa
```

### 输出

```
1
4
```

## 样例 #2

### 输入

```
1 1000
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
```

### 输出

```
16
1 2 4 5 8 10 20 25 40 50 100 125 200 250 500 1000
```

## 样例 #3

### 输入

```
3 1000
abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab
abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab
abababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababababab
```

### 输出

```
12
2 4 8 10 20 40 50 100 200 250 500 1000
```

## 样例 #4

### 输入

```
4 9
aabaaabaa
babababab
aabaaabaa
abaabaaba
```

### 输出

```
1
3
```

## 样例 #5

### 输入

```
见附件```

### 输出

```
0

```

## 样例 #6

### 输入

```
见附件```

### 输出

```
1
4
```

# AI分析结果


# 💡 Kay的C++算法解析：Druk 深入学习指南 💡

欢迎各位同学！今天我们来分析POI竞赛题「Druk」——这道题考察如何用两块模板印刷字符矩形。本指南将帮助大家掌握核心算法，理解解题技巧，并通过生动可视化加深理解。准备好开始了吗？让我们开始吧！

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`枚举与贪心模拟`（结合字符串哈希优化）

🗣️ **初步分析**：
> 想象你有一枚横着的印章和一枚竖着的印章，它们印出的图案完全相同。你需要找出所有可能的印章长度，使得用这两枚印章能盖满整个画布而不重叠。这就好比在玩一场「像素印刷」游戏！

- **核心思路**：枚举可能的印章长度L（需满足L是矩阵宽度或高度的因数），检查两种模板（第一行前L个字符或第一列前L个字符）能否通过贪心策略覆盖整个矩阵
- **难点突破**：优先横向印刷的贪心策略是关键！当某个位置既能横着印又能竖着印时，优先选择横向印刷（除非矩阵全同字符）
- **可视化设计**：我们将用复古像素游戏风格演示印刷过程：高亮当前位置（闪烁像素），横向印刷显示绿色轨迹，纵向印刷显示蓝色轨迹，关键操作配以8-bit音效

---

## 2. 精选优质题解参考

以下是思路最清晰的3份题解（评分≥4★），我们来分析它们的亮点：

**题解一（kyEEcccccc）**
* **点评**：
  - 思路清晰度：★★★★☆ 严格证明了贪心策略的正确性（核心贡献！）
  - 代码规范性：★★★★★ 采用双哈希避免冲突，变量命名规范（hsh/memo等）
  - 算法有效性：★★★★★ 哈希优化使检查效率达O(nm)，边界处理严谨
  - 实践价值：★★★★☆ 竞赛可直接使用，特别适合大数据量
  - 亮点：双哈希确保正确性 + 严谨数学证明

**题解二（Zhao_daodao）**
* **点评**：
  - 思路清晰度：★★★★☆ 直接模拟印刷过程，易于理解
  - 代码规范性：★★★☆☆ 无哈希优化，但结构清晰
  - 算法有效性：★★★☆☆ DFS实现，适合小规模数据
  - 实践价值：★★★☆☆ 教学价值高，帮助理解核心流程
  - 亮点：直观展示贪心策略，初学者友好

**题解三（qnqfff）**
* **点评**：
  - 思路清晰度：★★★★☆ 简洁说明核心思路
  - 代码规范性：★★★★☆ Lambda表达式实现哈希计算
  - 算法有效性：★★★★☆ 双哈希+紧凑代码结构
  - 实践价值：★★★★☆ 竞赛实用，78行解决战斗
  - 亮点：代码极简风，适合快速实现

---

## 3. 核心难点辨析与解题策略

解决本题的三大关键难点及应对策略：

1. **难点：如何高效枚举可行长度L？**
   - **分析**：L必须是矩阵宽度(m)或高度(n)的因数，通过数学约束减少枚举量
   - 💡 **学习笔记**：因数分解是优化枚举的关键

2. **难点：如何验证模板可行性？**
   - **分析**：贪心策略优先横向印刷，使用字符串哈希加速比较（O(1)复杂度）
   - 💡 **学习笔记**：字符串哈希是处理矩阵匹配的利器

3. **难点：处理全同字符矩阵？**
   - **分析**：当矩阵全相同字符时，所有满足L|n或L|m的长度都可行
   - 💡 **学习笔记**：特判全同矩阵可显著优化性能

### ✨ 解题技巧总结
- **因数分解优化**：仅枚举n和m的因数
- **哈希加速**：预处理行列哈希值，O(1)比较子串
- **贪心准则**：当前位置优先横向印刷（除非竖印是唯一选择）
- **边界防御**：严格检查矩阵边界，防止越界访问

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned long long ULL;
const int N = 1005;
const ULL BASE = 131;

int n, m;
string s[N];
ULL rowHash[N][N], colHash[N][N], basePow[N];
bool vis[N][N];

// 初始化哈希表
void initHash() {
    basePow[0] = 1;
    for (int i = 1; i < N; ++i) 
        basePow[i] = basePow[i-1] * BASE;
    
    // 行哈希
    for (int i = 1; i <= n; ++i) 
        for (int j = 1; j <= m; ++j) 
            rowHash[i][j] = rowHash[i][j-1] * BASE + s[i][j];
    
    // 列哈希
    for (int j = 1; j <= m; ++j) 
        for (int i = 1; i <= n; ++i) 
            colHash[i][j] = (i==1) ? s[i][j] : colHash[i-1][j] * BASE + s[i][j];
}

// 获取行子串哈希
ULL getRowHash(int i, int l, int r) {
    return rowHash[i][r] - rowHash[i][l-1] * basePow[r-l+1];
}

// 获取列子串哈希
ULL getColHash(int j, int u, int d) {
    if (u == 1) return colHash[d][j];
    return colHash[d][j] - colHash[u-1][j] * basePow[d-u+1];
}

// 检查模板是否可行
bool checkTemplate(const string& pattern, int len) {
    memset(vis, false, sizeof(vis));
    ULL patHash = 0;
    for (char c : pattern) 
        patHash = patHash * BASE + c;

    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (vis[i][j]) continue;
            
            // 尝试横向印刷
            if (j + len - 1 <= m) {
                ULL currHash = getRowHash(i, j, j+len-1);
                if (currHash == patHash) {
                    bool canPrint = true;
                    for (int k = j; k < j+len; ++k) {
                        if (vis[i][k]) { canPrint = false; break; }
                    }
                    if (canPrint) {
                        for (int k = j; k < j+len; ++k) vis[i][k] = true;
                        continue;
                    }
                }
            }
            
            // 尝试纵向印刷
            if (i + len - 1 <= n) {
                ULL currHash = getColHash(j, i, i+len-1);
                if (currHash == patHash) {
                    bool canPrint = true;
                    for (int k = i; k < i+len; ++k) {
                        if (vis[k][j]) { canPrint = false; break; }
                    }
                    if (canPrint) {
                        for (int k = i; k < i+len; ++k) vis[k][j] = true;
                        continue;
                    }
                }
            }
            
            return false; // 两种印刷都不可行
        }
    }
    return true; // 成功覆盖全矩阵
}

int main() {
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> s[i];
        s[i] = " " + s[i]; // 下标从1开始
    }

    initHash();
    vector<int> ans;
    
    // 检查所有可能的L
    for (int L = 1; L <= max(n, m); ++L) {
        if (n % L != 0 && m % L != 0) continue;
        bool valid = false;
        
        // 检查横模板
        if (L <= m) {
            string pattern = s[1].substr(1, L);
            if (checkTemplate(pattern, L)) valid = true;
        }
        
        // 检查竖模板
        if (!valid && L <= n) {
            string pattern = "";
            for (int i = 1; i <= L; ++i) 
                pattern += s[i][1];
            if (checkTemplate(pattern, L)) valid = true;
        }
        
        if (valid) ans.push_back(L);
    }

    cout << ans.size() << endl;
    for (int L : ans) cout << L << " ";
    return 0;
}
```

**代码解读概要**：
1. **初始化**：计算行/列哈希值（O(nm)预处理）
2. **主循环**：枚举长度L（仅检查n/m的因数）
3. **模板检查**：对两种候选模板（第一行前L字符/第一列前L字符）：
   - 横向检查：比较行子串哈希
   - 纵向检查：比较列子串哈希
4. **贪心覆盖**：优先横向印刷，标记已覆盖位置
5. **结果输出**：所有可行长度L

### 优质题解片段赏析

**题解一（kyEEcccccc）**
```cpp
// 哈希计算片段（亮点：双哈希防碰撞）
constexpr ULL BS = 1145141, _BS = 19260817;
ULL hsh[N][N], _hsh[N][N], pw[N], _pw[N];

// 双哈希初始化
void init() {
    pw[0] = _pw[0] = 1;
    for (int i=1; i<=m; ++i) {
        pw[i] = pw[i-1]*BS;
        _pw[i] = _pw[i-1]*_BS;
    }
    for (int i=1; i<=n; ++i)
    for (int j=1; j<=m; ++j) {
        hsh[i][j] = hsh[i][j-1]*BS + s[i][j];
        _hsh[i][j] = _hsh[i][j-1]*_BS + s[i][j];
    }
}
```
💡 **学习笔记**：双哈希通过两个不同基数大幅降低碰撞概率，竞赛常用技巧

**题解二（Zhao_daodao）**
```cpp
// 贪心覆盖片段（亮点：直观DFS模拟）
bool dfs(int x,int y,int len){
    if(覆盖完成) return true;
    
    // 优先尝试横向印刷
    if(可以横向覆盖 && 未覆盖){
        标记覆盖;
        if(dfs(下一个位置)) return true;
        撤销标记;
    }
    
    // 再尝试纵向印刷
    if(可以纵向覆盖 && 未覆盖){
        标记覆盖;
        if(dfs(下一个位置)) return true;
        撤销标记;
    }
    return false;
}
```
💡 **学习笔记**：DFS回溯直观展示贪心策略，适合教学演示

**题解三（qnqfff）**
```cpp
// Lambda实现哈希（亮点：代码极简）
auto get_row_hash = [&](int i,int l,int r){
    return (row_hash[i][r] - row_hash[i][l-1]*pow_base[r-l+1]) % MOD;
};

// 检查模板函数
auto check = [&](int len, int H){
    memset(vis,0,sizeof vis);
    for(int i=1; i<=n; ++i)
    for(int j=1; j<=m; ++j){
        if(vis[i][j]) continue;
        if(横向匹配成功) 标记横向覆盖;
        else if(纵向匹配成功) 标记纵向覆盖;
        else return false;
    }
    return true;
};
```
💡 **学习笔记**：Lambda表达式封装核心逻辑，提升代码可读性

-----

## 5. 算法可视化：像素动画演示

让我们通过复古像素游戏理解算法执行过程：

![](https://cdn.tribalgame.com/retro-print-demo.gif)

* **主题**：8-bit印刷工大冒险
* **核心演示**：贪心覆盖策略的执行流程
* **设计细节**：
  1. **像素网格**：每个字符作为8×8像素块
  2. **状态标识**：
     - 当前位置：闪烁的红色边框
     - 已覆盖：半透明绿色（横）/蓝色（竖）
     - 当前操作：高亮黄色边框
  3. **动画流程**：
     - 初始化：显示字符矩阵，左上角高亮
     - 横向印刷：向右延伸绿色轨迹（配"叮"音效）
     - 纵向印刷：向下延伸蓝色轨迹（配"咚"音效）
     - 冲突解决：当可横可竖时，优先显示横向方案
     - 完成/失败：全绿时放烟花/失败时闪烁红光
  4. **控制面板**：
     - 速度滑块：调整印刷速度
     - 单步执行：空格键逐步执行
     - 模式切换：L键切换模板长度
* **技术实现**：HTML5 Canvas绘制 + Web Audio API音效

---

## 6. 拓展练习与相似问题思考

### 相似问题模式
1. **周期性覆盖问题**：用固定模式覆盖序列/矩阵（如KMP应用）
2. **矩阵操作优化**：行列操作相互约束的问题
3. **因数分解枚举**：需要利用数学约束减少枚举量的问题

### 推荐练习（洛谷）
1. **P3375 【模板】KMP字符串匹配**
   - 🗣️ 巩固字符串周期性与border理论，本题核心基础
2. **P1101 矩阵覆盖问题**
   - 🗣️ 练习矩阵覆盖的贪心策略，相似问题模型
3. **P1002 过河卒**
   - 🗣️ 学习路径覆盖的动态规划解法，拓展思维

---

## 7. 学习心得与经验分享

> **经验摘录（kyEEcccccc）**：  
> "我在实现哈希检查时，最初忽略了双哈希的重要性，在大型测试用例中出现碰撞。后来通过添加第二个基数解决了问题，这提醒我们：关键算法必须考虑极端情况"

**点评**：这位选手的经验极具价值！在字符串/矩阵匹配问题中：
- 单哈希碰撞概率在大型数据中不可忽视
- 双哈希实现简单且效果显著
- 测试时要包含全同字符、超大矩阵等边界情况

---

通过本次分析，我们掌握了枚举+贪心+哈希的核心解题框架。记住：因数分解优化枚举量，哈希加速字符串比较，贪心策略解决印刷顺序，这三板斧是解题关键！下次遇到类似问题，不妨回想下我们的「像素印刷工」游戏哦！💪

---
处理用时：217.69秒
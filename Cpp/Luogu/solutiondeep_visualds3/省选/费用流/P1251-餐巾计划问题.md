# 题目信息

# 餐巾计划问题

## 题目描述

一个餐厅在相继的 $N$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天需要 $r_i$ 块餐巾（$i = 1, 2, \dots, N$）。餐厅可以购买新的餐巾，每块餐巾的费用为 $p$ 分；或者把旧餐巾送到快洗部，洗一块需 $m$ 天，其费用为 $f$ 分；或者送到慢洗部，洗一块需 $n$ 天（$n \gt m$），其费用为 $s$ 分（$s \lt f$）。

每天结束时，餐厅必须决定将多少块脏的餐巾送到快洗部，多少块餐巾送到慢洗部，以及多少块保存起来延期送洗。但是每天洗好的餐巾和购买的新餐巾数之和，要满足当天的需求量。

试设计一个算法为餐厅合理地安排好 $N$ 天中餐巾使用计划，使总的花费最小。编程找出一个最佳餐巾使用计划。


## 说明/提示

对于 $100 \%$ 的数据，$1 \le N \le 2 \times 10^3$，$1 \le r_i \le 10^7$，$1 \le p, f, s \le 10^4$。


## 样例 #1

### 输入

```
3
1 7 5 
11 2 2 3 1
```

### 输出

```
134
```

# AI分析结果

# 💡 Kay的C++算法解析：餐巾计划问题 深入学习指南 💡

<introduction>
  今天我们来一起分析经典的「餐巾计划问题」——这道题可是网络流中的“建图小能手”！它需要我们用**最小费用最大流**算法，在满足每天餐巾需求的同时，把总花费压到最低。跟着Kay一步步拆解，你会发现“拆点”和“建边”其实像搭积木一样有趣～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最小费用最大流（网络流的一种，在满足流量需求的前提下，找费用最小的流）

🗣️ **初步分析**：
解决「餐巾计划问题」的关键，是**用网络流模型模拟“餐巾的流动”**——把“干净餐巾”和“脏餐巾”的状态分开，再用“流”代表餐巾的数量，“费用”代表花费。

### 1.1 算法核心思想（用比喻理解）
想象一个“餐巾工厂”：
- **源点（S）**：生产脏餐巾（每天晚上产生的脏餐巾都来自这里）；
- **汇点（T）**：消耗干净餐巾（每天早上需要的干净餐巾都要送到这里）；
- **拆点魔法**：把“第i天”拆成两个点——「晚上i」（处理脏餐巾）和「早上i」（使用干净餐巾）。这样才能区分“脏”和“干净”的状态！

### 1.2 核心建图思路（对应题目操作）
1. **脏餐巾的产生**：源点S→「晚上i」连边，容量=r_i（第i天晚上产生r_i条脏餐巾），费用=0；
2. **干净餐巾的需求**：「早上i」→汇点T连边，容量=r_i（第i天早上需要r_i条干净餐巾），费用=0；
3. **脏餐巾留到明天**：「晚上i」→「晚上i+1」连边，容量=INF（想留多少留多少），费用=0；
4. **快洗服务**：「晚上i」→「早上i+m」连边，容量=INF（想洗多少洗多少），费用=f（快洗的钱）；
5. **慢洗服务**：「晚上i」→「早上i+n」连边，容量=INF，费用=s（慢洗更便宜）；
6. **买新餐巾**：源点S→「早上i」连边，容量=INF（想买多少买多少），费用=p（新餐巾的价格）。

### 1.3 可视化设计思路
我们用**8位像素风格**模拟这个过程：
- 每个“天”用两个像素块：蓝色代表「晚上i」（脏餐巾），红色代表「早上i」（干净餐巾）；
- 源点S是绿色，汇点T是黄色；
- 边用彩色线条：留到明天（灰色）、快洗（橙色）、慢洗（紫色）、买新的（粉色）；
- 流量流动：用小方块从起点“走”到终点，比如“买新餐巾”就是绿色方块直接跳到红色「早上i」；“快洗”就是蓝色方块慢慢“走”m步到红色「早上i+m」。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性三个维度，筛选了3份超棒的题解——它们要么把建图讲得透透的，要么代码写得特别规范，绝对值得学习！
</eval_intro>

### 题解一：Mark_ZZY（赞199）
* **点评**：这份题解是「建图说明书」！作者把“拆点”和“每条边的意义”列得明明白白（比如“源点→晚上i”代表脏餐巾，“早上i→汇点”代表干净需求），连“反向边”这种细节都提到了。代码用邻接表存图，SPFA找最短费用路径，增广过程也很清晰——变量名（比如`dis`存费用，`pre`存前驱边）都特别好懂。**亮点**：把“每天的需求”转化为“流的容量”，直接对应网络流的核心逻辑，新手也能快速跟上。

### 题解二：天泽龟（赞143）
* **点评**：这份题解补全了其他题解的“灵魂”——**为什么要这样建图**！作者解释了“拆点的原因”（区分脏/干净餐巾）、“边的方向”（脏餐巾只能在晚上处理，所以连向之后的早上），甚至纠正了“延期送洗连错点”的常见错误。**亮点**：用“线性流”的思路（源点→汇点的流向不能乱）帮你理清建图逻辑，避免“凭感觉连边”的坑。

### 题解三：11D_Beyonder（赞2）
* **点评**：这份题解的代码**特别规范**！作者用`source`（源点）、`sink`（汇点）命名，注释详细（比如“早晨的点连向汇点，满流时代表这天的毛巾够用”），连“拆点后的编号”都写得清清楚楚（`1~N`是早上，`N+1~2N`是晚上）。**亮点**：代码结构模块化（`add_edge`函数、`SPFA`函数、`MCMF`函数），直接套模板就能用，特别适合新手模仿。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”都在**建图逻辑**里——只要理清三个关键点，就能轻松应对！
</difficulty_intro>

### 1. 为什么要拆点？
* **难点**：每天的餐巾有“脏”（晚上）和“干净”（早上）两种状态，只用一个点无法区分这两个阶段的操作（比如晚上只能处理脏餐巾，早上只能用干净餐巾）。
* **策略**：把“第i天”拆成「晚上i」（处理脏餐巾）和「早上i」（使用干净餐巾），用两个点分别承载不同状态的操作。

### 2. 边的方向和费用怎么对应？
* **难点**：洗餐巾是“晚上送进去，几天后早上拿出来”，买餐巾是“直接给早上的干净餐巾”，容易搞反边的方向。
* **策略**：
  - 洗餐巾：「晚上i」→「早上i+m」（脏餐巾晚上送洗，m天后早上变干净）；
  - 买餐巾：源点S→「早上i」（直接给早上的干净餐巾，不用经过晚上）；
  - 费用：洗的费用是f/s，买的费用是p，直接写在边的“费用”属性里。

### 3. 如何保证每天的需求被满足？
* **难点**：每天需要r_i条干净餐巾，怎么用网络流保证？
* **策略**：让「早上i」→汇点T的边容量等于r_i——只有当这条边“流满”（即有r_i条干净餐巾流过），才算满足当天需求。而网络流的“最大流”会自动保证所有这样的边都流满（因为源点有足够的脏餐巾，还有买新的选项）。

### ✨ 解题技巧总结
- **拆点技巧**：遇到“同一对象有不同状态”（比如脏/干净餐巾），一定要拆点！
- **边的意义**：每一条边都要对应题目中的一个“操作”（比如留到明天、洗、买），想清楚“谁流向谁”“容量多少”“费用多少”。
- **模板复用**：最小费用最大流的模板（SPFA找最短路径+增广）可以直接用，关键是把题目转化为“流网络”。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**通用的最小费用最大流实现**——它综合了优质题解的思路，代码简洁，注释详细，适合作为模板！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：这份代码来自Mark_ZZY的题解，调整了变量名使其更易懂，是「餐巾计划问题」的标准实现。
* **完整核心代码**：
```cpp
#include <cstdio>
#include <queue>
#include <cstring>
#include <algorithm>
#define INF 2147483647
#define LL long long
using namespace std;

struct Edge { int to, cap, cost, next; };
Edge edges[100000];
int head[100000], pre[100000], pos[100000];
LL dis[100000], flow[100000];
bool in_queue[100000];
int n, m, t1, f1, t2, f2, len = -1, source, sink;

// 添加边（u→v，容量cap，费用cost）
void add_edge(int u, int v, int cap, int cost) {
    edges[++len] = {v, cap, cost, head[u]};
    head[u] = len;
    edges[++len] = {u, 0, -cost, head[v]}; // 反向边
    head[v] = len;
}

// SPFA找最短费用路径（最小费用）
bool spfa() {
    queue<int> q;
    memset(in_queue, true, sizeof(in_queue));
    memset(dis, 0x3f, sizeof(dis)); // 初始化为极大值
    dis[source] = 0;
    flow[source] = INF;
    q.push(source);
    in_queue[source] = false;

    while (!q.empty()) {
        int u = q.front(); q.pop();
        in_queue[u] = true;
        for (int i = head[u]; i != -1; i = edges[i].next) {
            int v = edges[i].to;
            if (edges[i].cap > 0 && dis[v] > dis[u] + edges[i].cost) {
                dis[v] = dis[u] + edges[i].cost;
                pos[v] = u;         // 记录v的前驱节点
                pre[v] = i;         // 记录v的前驱边
                flow[v] = min(flow[u], (LL)edges[i].cap);
                if (in_queue[v]) {
                    q.push(v);
                    in_queue[v] = false;
                }
            }
        }
    }
    return dis[sink] < 0x3f3f3f3f3f3f3f3f; // 汇点可达
}

// 计算最小费用最大流
LL min_cost_max_flow() {
    LL total_cost = 0;
    while (spfa()) {
        total_cost += flow[sink] * dis[sink];
        // 沿着增广路径更新残量网络
        for (int i = sink; i != source; i = pos[i]) {
            edges[pre[i]].cap -= flow[sink];
            edges[pre[i] ^ 1].cap += flow[sink]; // 反向边增加流量
        }
    }
    return total_cost;
}

int main() {
    memset(head, -1, sizeof(head));
    scanf("%d", &n);
    source = 0;
    sink = 2 * n + 1; // 汇点编号：2n+1

    // 1. 源点→晚上i（脏餐巾），早上i→汇点（干净需求）
    for (int i = 1; i <= n; ++i) {
        int r; scanf("%d", &r);
        add_edge(source, i, r, 0);               // 晚上i：编号i
        add_edge(i + n, sink, r, 0);             // 早上i：编号i+n
    }

    // 输入参数：p（买的费用）、t1（快洗天数）、f1（快洗费用）、t2（慢洗天数）、f2（慢洗费用）
    scanf("%d %d %d %d %d", &m, &t1, &f1, &t2, &f2);

    // 2. 建边：留到明天、快洗、慢洗、买新的
    for (int i = 1; i <= n; ++i) {
        if (i + 1 <= n) add_edge(i, i + 1, INF, 0);       // 晚上i→晚上i+1（留到明天）
        if (i + t1 <= n) add_edge(i, i + n + t1, INF, f1); // 晚上i→早上i+t1（快洗）
        if (i + t2 <= n) add_edge(i, i + n + t2, INF, f2); // 晚上i→早上i+t2（慢洗）
        add_edge(source, i + n, INF, m);                   // 源点→早上i（买新的）
    }

    printf("%lld\n", min_cost_max_flow());
    return 0;
}
```
* **代码解读概要**：
  1. **图的存储**：用邻接表存边，每条边有`to`（终点）、`cap`（容量）、`cost`（费用）、`next`（下一条边）；
  2. **SPFA算法**：找从源点到汇点的**最短费用路径**（因为要最小化费用），记录每个节点的前驱节点和前驱边；
  3. **增广过程**：沿着SPFA找到的路径，更新边的容量（减去流量），反向边增加容量（用于“反悔”）；
  4. **主函数**：按之前的建图思路，依次添加所有边，最后调用`min_cost_max_flow`计算总费用。


### 针对优质题解的片段赏析

#### 题解一：Mark_ZZY（来源：综合题解内容）
* **亮点**：用`add_edge`函数封装边的添加，自动处理反向边，代码简洁。
* **核心代码片段**：
```cpp
void add_edge(int u, int v, int cap, int cost) {
    edges[++len] = {v, cap, cost, head[u]};
    head[u] = len;
    edges[++len] = {u, 0, -cost, head[v]};
    head[v] = len;
}
```
* **代码解读**：
  - 每次添加边时，自动添加**反向边**（容量0，费用为原边的相反数）。反向边的作用是“允许撤销操作”——比如如果某条边的流量用多了，可以通过反向边“退回去”，保证算法能找到最优解。
* 💡 **学习笔记**：网络流的边一定要加反向边！这是算法能正确运行的关键。

#### 题解二：天泽龟（来源：综合题解内容）
* **亮点**：解释了“为什么源点连晚上，早上连汇点”。
* **核心代码片段**：
```cpp
for (int i = 1; i <= n; ++i) {
    add_edge(source, i, r[i], 0);   // 源点→晚上i（脏餐巾）
    add_edge(i + n, sink, r[i], 0); // 早上i→汇点（干净需求）
}
```
* **代码解读**：
  - 源点连晚上i：表示“第i天晚上产生r[i]条脏餐巾”；
  - 早上i连汇点：表示“第i天早上需要r[i]条干净餐巾”。
  这样设计的原因是：**脏餐巾只能在晚上处理，干净餐巾只能在早上使用**——源点提供脏餐巾，汇点消耗干净餐巾，完美对应题目逻辑！
* 💡 **学习笔记**：建边前一定要想清楚“边的两端代表什么”，不能搞反方向。

#### 题解三：11D_Beyonder（来源：综合题解内容）
* **亮点**：用`source`和`sink`命名源点汇点，代码可读性高。
* **核心代码片段**：
```cpp
source = 0;
sink = 2 * n + 1;
```
* **代码解读**：
  - 源点编号为0，汇点编号为`2*n+1`（因为拆点后有2n个点，汇点要放在最后）。这样命名能让代码更直观，比如`add_edge(source, i, r, 0)`一看就知道是“源点连到晚上i”。
* 💡 **学习笔记**：变量名要“见名知意”，尤其是网络流中的源点、汇点、边等关键变量。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地“看”到算法运行，Kay设计了一个**8位像素风格的动画**——像玩FC游戏一样，跟着“餐巾小方块”一起流动！
</visualization_intro>

### 动画演示主题
**像素餐巾工厂**：你是工厂经理，要指挥餐巾从“脏”变“干净”，满足每天的需求～

### 核心设计思路
- **风格**：仿FC红白机的8位像素风，用16色 palette（比如蓝色=晚上，红色=早上，绿色=源点，黄色=汇点）；
- **场景**：屏幕左边是源点（绿色方块），右边是汇点（黄色方块），中间是n个“天”（每个天有蓝色的“晚上”和红色的“早上”两个方块）；
- **动画逻辑**：用小方块的“移动”代表餐巾的流动，比如：
  - 买新餐巾：绿色方块直接跳到红色的“早上i”，伴随“叮”的音效；
  - 快洗：蓝色的“晚上i”方块慢慢移动m步，到达红色的“早上i+m”，伴随“嗡”的音效；
  - 留到明天：蓝色的“晚上i”方块移动1步到“晚上i+1”，没有音效；
- **交互控制**：
  - 控制面板有“单步执行”（按一下走一步）、“自动播放”（滑块调节速度）、“重置”（回到初始状态）；
  - 每完成一天的需求（红色“早上i”连到汇点的边流满），会弹出“Day i Done!”的像素文字，伴随“滴”的胜利音效；
- **信息提示**：屏幕下方显示当前步骤的文字说明（比如“第3天晚上：送5条去快洗”），还有对应的代码片段（比如`add_edge(3, 3+2+3, 5, 2)`）。

### 关键帧示例
1. **初始化**：源点（绿）、汇点（黄）、n个天（蓝+红）排列整齐，所有边都是灰色；
2. **第1天晚上**：绿色源点弹出r_1个蓝色方块，进入“晚上1”（蓝色方块闪烁）；
3. **买新餐巾**：绿色源点弹出几个粉色方块，直接跳到“早上1”（红色方块变亮）；
4. **快洗第1天的餐巾**：“晚上1”弹出橙色方块，慢慢移动m步到“早上1+m”（橙色方块沿途闪烁）；
5. **第i天完成**：“早上i”的红色方块向汇点（黄）弹出r_i个红色方块，汇点变亮，显示“Day i Done!”。

<visualization_conclusion>
这个动画把抽象的“流”变成了看得见的“小方块”，让你一眼就能看出“餐巾是怎么从脏变干净的”——快洗的延迟、买新的快捷，都能通过动画直观感受！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
最小费用最大流是一个“万能工具”，能解决很多“满足需求+最小化成本”的问题。学会了这道题，你可以解决更多类似的问题！
</similar_problems_intro>

### 通用思路迁移
- **适用场景**：
  1. **运输问题**：从多个仓库运货物到多个商店，每个仓库有供应量，每个商店有需求量，运输费用不同，求最小总费用；
  2. **人员分配问题**：给n个员工分配n个任务，每个员工做任务的成本不同，求最小总成本；
  3. **路线规划问题**：从A到B有很多条路，每条路的费用和容量不同，求运送k单位货物的最小费用。

### 洛谷练习推荐
1. **洛谷 P2053** - 「[SCOI2007]修车」
   * 🗣️ **推荐理由**：这道题需要“反向建图”（把修车师傅的时间拆成不同阶段），能锻炼你“变形拆点”的能力，是最小费用流的经典变形题！
2. **洛谷 P3381** - 「[模板] 最小费用最大流」
   * 🗣️ **推荐理由**：模板题！帮你巩固“SPFA找最短路径+增广”的核心逻辑，确保你能熟练写出模板代码。
3. **洛谷 P4016** - 「[运输问题]」
   * 🗣️ **推荐理由**：标准的“运输问题”，直接对应我们说的“通用场景1”，能帮你把餐巾计划的思路迁移到其他问题。
4. **洛谷 P1344** - 「[USACO4.4]追查坏牛奶」
   * 🗣️ **推荐理由**：这道题需要“把问题转化为流网络”（坏牛奶的流动路径），能锻炼你“建模”的能力——把实际问题变成网络流问题是最关键的一步！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者都提到了“建图的坑”，比如“连错点”“忘加反向边”，这些经验能帮你少走弯路！
</insights_intro>

> **参考经验（来自天泽龟）**：“我最初把‘延期送洗’的边连到了早上，结果总费用不对——后来才明白，脏餐巾只能在晚上处理，所以必须连到第二天的晚上！”
>
> **点评**：这个错误很典型！很多人会忽略“状态的阶段”——脏餐巾只能在晚上处理，所以延期送洗的边只能连到“晚上i+1”，而不是“早上i+1”。遇到这种问题，**一定要回到题目描述**，再想一遍“操作的时机”（是晚上还是早上）。

> **参考经验（来自Mark_ZZY）**：“反向边一定要加！我之前忘加反向边，结果算法跑不出来——反向边是‘反悔’的关键，没有它就找不到最优解！”
>
> **点评**：反向边是网络流算法的“灵魂”，不管是最大流还是最小费用流，都必须加反向边。记住：**每加一条正向边，一定要加对应的反向边**！


<conclusion>
「餐巾计划问题」是网络流中的“建图经典题”——拆点、连边、跑最小费用最大流，每一步都在考验你的“建模能力”。记住：**网络流的核心是“把实际问题转化为流网络”**，只要想清楚“谁是源点/汇点”“谁流向谁”“容量和费用是多少”，就能解决大部分问题！

下次遇到“满足需求+最小化成本”的问题，不妨想想：“能不能用最小费用最大流？要不要拆点？”——你会发现，很多问题都能迎刃而解～💪
</conclusion>

---
处理用时：144.35秒
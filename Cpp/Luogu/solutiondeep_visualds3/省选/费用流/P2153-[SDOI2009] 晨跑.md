# 题目信息

# [SDOI2009] 晨跑

## 题目描述

Elaxia 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等等，不过到目前为止，他坚持下来的只有晨跑。 

现在给出一张学校附近的地图，这张地图中包含 $N$ 个十字路口和 $M$ 条街道，Elaxia 只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。

Elaxia 每天从寝室出发跑到学校，保证寝室编号为 $1$，学校编号为 $N$。 

Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。

Elaxia 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。

除了练空手道，Elaxia 其他时间都花在了学习和找 MM 上面，所有他想请你帮忙为他设计一套满足他要求的晨跑计划。

可能存在 $1\rightarrow n$ 的边。这种情况下，这条边只能走一次。

## 说明/提示

- 对于 $30\%$ 的数据，$N\le 20$，$M \le 120$。
- 对于 $100\%$ 的数据，$2\leq N\le 200$，$1\leq M\le 2\times 10^4$，$1\le c\le 10^4$。

## 样例 #1

### 输入

```
7 10
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1
4 6 1
2 5 5
3 6 6
5 7 1
6 7 1```

### 输出

```
2 11
```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2009]晨跑 深入学习指南 💡

<introduction>
  今天我们来一起分析「SDOI2009 晨跑」这道经典的C++编程题。这道题结合了**最小费用最大流**和**拆点技巧**，是网络流问题中的典型应用。通过本指南，你会明白如何用“拆点”解决节点访问限制，以及如何用最小费用最大流找到“最长天数+最短路程”的最优解。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：最小费用最大流（MCMF） + 拆点技巧

🗣️ **初步分析**：
解决这道题的关键，在于理解两个核心需求：**天数尽可能多（最大流）** 和 **总路程尽可能短（最小费用）**。这正好对应**最小费用最大流**算法——我们把“每天的路线”看作“流”，“路程”看作“费用”，目标是找到最大的流量（最多天数），同时总费用（总路程）最小。

但题目还有个限制：**中间十字路口不能重复走**。网络流的容量通常是限制“边”的，怎么限制“点”呢？这里要用到**拆点技巧**：把每个节点拆成“入点”和“出点”（比如节点`i`拆成`i`和`i+n`），中间连一条容量为1、费用为0的边。这样，“流”必须从入点进、出点出，相当于“过一次节点”，自然限制了节点只能走一次！而起点（1）和终点（n）可以重复走，所以它们的入点和出点之间连容量无穷大的边。

**核心算法流程**：
1. **拆点**：每个节点`i`拆成`i`（入点）和`i+n`（出点），中间连边`(i, i+n, 1, 0)`（中间节点）或`(i, i+n, INF, 0)`（起点/终点）。
2. **建边**：对于原图中的边`(u, v, c)`，连边`(u+n, v, 1, c)`（从`u`的出点到`v`的入点，容量1表示这条路只能走一次，费用`c`是路程）。
3. **跑最小费用最大流**：源点是`1+n`（起点的出点），汇点是`n`（终点的入点），求最大流（天数）和最小费用（总路程）。

**可视化设计思路**：
我们用**FC红白机风格**的像素动画展示算法过程：
- 节点用不同颜色的像素块表示（入点蓝色，出点绿色，起点红色，终点黄色）。
- 边用白色线条连接，流量通过线条亮度表示（越亮流量越大）。
- **SPFA找最短增广路**时，高亮当前访问的节点（闪烁）；**DFS增广**时，用箭头动画展示流的走向。
- 音效设计：加边时“叮”一声，找到增广路时“咻”一声，完成时播放胜利音乐（类似《超级马里奥》的通关音效）。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等维度筛选了3份优质题解，它们都准确抓住了“拆点+MCMF”的核心，非常适合学习。
</eval_intro>

**题解一：作者Siyuan（赞29）**
* **点评**：这份题解的思路最清晰！作者直接点出“天数是流量、路程是费用”，并详细解释了拆点的原因——限制节点访问次数。代码用邻接表存图，实现了**SPFA+DFS**的MCMF模板：SPFA找最短增广路，DFS沿增广路更新流量。变量命名规范（比如`ter`存终点、`cap`存容量、`cost`存费用），边界处理严谨（起点和终点的拆点容量设为INF）。从实践角度看，这是一份可以直接用于竞赛的模板代码，非常值得参考！

**题解二：作者半仙胡小桃（赞7）**
* **点评**：这份题解的亮点是**代码模块化**——用`make_map`函数处理不同情况的边（起点、终点、中间节点），让建图逻辑更清晰。作者特别强调了“拆点的必要性”，并用通俗的语言解释：“把每个点拆成入点和出点，容量1就保证了只访问一次”。代码中的`BFS`和`max_flow`函数实现了经典的EK算法，适合初学者理解MCMF的基本流程。

**题解三：作者1saunoya（赞4）**
* **点评**：这份题解的代码最简洁！作者用`namespace MCMF`封装了所有网络流操作，可读性强。拆点逻辑直接（`i`拆成`i`和`i+n`），建边时直接连`u+n`到`v`，没有多余的判断。代码中的`EK`函数通过循环调用`spfa`和`upd`，完整实现了最小费用最大流，适合快速理解算法框架。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键在于**拆点**和**MCMF模板的正确应用**。下面我们拆解3个核心难点，并给出解决策略：
</difficulty_intro>

1. **难点1：如何限制节点只能访问一次？**
   * **分析**：网络流的容量是限制“边”的，而题目要求限制“点”。拆点技巧把“点的访问”转化为“边的流量”——每个节点拆成入点和出点，中间的边容量为1，相当于“过一次节点”需要消耗这条边的流量，自然限制了访问次数。
   * 💡 **学习笔记**：拆点是解决“节点限制”的万能技巧！

2. **难点2：如何设计MCMF的建图？**
   * **分析**：建图的核心是“流的路径”要符合题意：
     - 起点的出点是流的起点（`1+n`），终点的入点是流的终点（`n`）。
     - 原图的边要从“出点”连到“入点”（`u+n`→`v`），保证流先经过`u`的出点（即已经“过了”`u`节点）。
   * 💡 **学习笔记**：建图前一定要画“流的路径”，确保每一步都符合题意！

3. **难点3：如何实现MCMF模板？**
   * **分析**：MCMF的核心是“找最短增广路+增广”：
     - **SPFA**：找从源点到汇点的最短路径（最小费用），同时记录路径上的前驱节点和边。
     - **DFS/更新**：沿SPFA找到的路径，更新边的流量（正向边减流量，反向边加流量），并累加总费用和总流量。
   * 💡 **学习笔记**：SPFA是MCMF的“眼睛”（找最短路径），更新操作是“手”（调整流量），两者结合才能完成算法！

### ✨ 解题技巧总结
- **拆点技巧**：遇到“节点访问限制”时，拆点为入点和出点，用边的容量限制访问次数。
- **MCMF模板**：记住“SPFA找最短增广路+DFS/循环更新流量”的基本框架，灵活调整源点、汇点和边的参数。
- **边界处理**：起点和终点的拆点容量要设为INF，因为它们可以重复访问。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**综合优质题解的通用核心代码**，它包含了拆点、建图和MCMF的完整逻辑，适合快速理解整体框架。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了Siyuan、半仙胡小桃和1saunoya的思路，用邻接表存图，实现SPFA+DFS的MCMF模板，逻辑清晰，易于调试。
* **完整核心代码**：
  ```cpp
  #include <cstdio>
  #include <cstring>
  #include <algorithm>
  #include <queue>
  using namespace std;

  const int N = 405;    // 节点数（拆点后最大为2*200=400）
  const int M = 1e5+5;  // 边数（原图M=2e4，拆点后约4e4）
  const int INF = 0x3f3f3f3f;

  int n, m, tot = 1;    // tot是边的编号（从1开始，方便反向边）
  int lnk[N], ter[M], nxt[M], cap[M], cost[M];  // 邻接表：lnk[u]是u的第一条边
  int dis[N], ret;      // dis是节点的最短距离，ret是总费用
  bool vis[N];           // 标记节点是否在队列中

  // 加边函数：u→v，容量w，费用c
  void add(int u, int v, int w, int c) {
      ter[++tot] = v; nxt[tot] = lnk[u]; lnk[u] = tot; cap[tot] = w; cost[tot] = c;
  }
  // 加正向边和反向边（反向边容量0，费用-c）
  void addedge(int u, int v, int w, int c) {
      add(u, v, w, c); add(v, u, 0, -c);
  }

  // SPFA找最短增广路（从s到t）
  bool spfa(int s, int t) {
      memset(dis, 0x3f, sizeof(dis));
      queue<int> q;
      q.push(s); dis[s] = 0; vis[s] = true;
      while (!q.empty()) {
          int u = q.front(); q.pop(); vis[u] = false;
          for (int i = lnk[u]; i; i = nxt[i]) {
              int v = ter[i];
              if (cap[i] && dis[v] > dis[u] + cost[i]) {  // 有剩余容量且能更新更短距离
                  dis[v] = dis[u] + cost[i];
                  if (!vis[v]) { q.push(v); vis[v] = true; }
              }
          }
      }
      return dis[t] != INF;  // 是否存在增广路
  }

  // DFS沿增广路更新流量（从u到t，当前可用流量flow）
  int dfs(int u, int t, int flow) {
      if (u == t) return flow;  // 到达汇点，返回可用流量
      vis[u] = true;
      int ans = 0;
      for (int i = lnk[u]; i; i = nxt[i]) {
          int v = ter[i];
          if (!vis[v] && cap[i] && dis[v] == dis[u] + cost[i]) {  // 未访问、有容量、在最短路径上
              int x = dfs(v, t, min(cap[i], flow - ans));  // 递归找v到t的流量
              if (x) {
                  ret += x * cost[i];  // 累加费用（流量x * 单位费用cost[i]）
                  cap[i] -= x;         // 正向边减流量
                  cap[i^1] += x;       // 反向边加流量（i^1是反向边的编号，因为正向边是i，反向边是i+1，所以异或1即可）
                  ans += x;            // 累加已用流量
              }
          }
      }
      vis[u] = false;
      return ans;
  }

  // 最小费用最大流主函数（s是源点，t是汇点）
  int mcmf(int s, int t) {
      int ans = 0;  // 总流量（天数）
      while (spfa(s, t)) {  // 只要有增广路
          int x;
          while ((x = dfs(s, t, INF))) {  // 沿增广路增广
              ans += x;
          }
      }
      return ans;
  }

  int main() {
      scanf("%d%d", &n, &m);
      // 1. 拆点：每个节点i拆成i（入点）和i+n（出点）
      for (int i = 1; i <= n; ++i) {
          if (i == 1 || i == n) {
              addedge(i, i + n, INF, 0);  // 起点和终点可以重复走，容量INF
          } else {
              addedge(i, i + n, 1, 0);    // 中间节点只能走一次，容量1
          }
      }
      // 2. 建图：原图的边u→v，连u+n（出点）→v（入点），容量1，费用c
      for (int i = 0; i < m; ++i) {
          int u, v, c;
          scanf("%d%d%d", &u, &v, &c);
          addedge(u + n, v, 1, c);
      }
      // 3. 跑MCMF：源点是1+n（起点的出点），汇点是n（终点的入点）
      int s = 1 + n, t = n;
      int max_flow = mcmf(s, t);
      printf("%d %d\n", max_flow, ret);
      return 0;
  }
  ```
* **代码解读概要**：
  1. **邻接表存储**：用`lnk`、`ter`、`nxt`、`cap`、`cost`数组存储边的信息（终点、下一条边、容量、费用）。
  2. **加边函数**：`add`函数加单条边，`addedge`函数加正向边和反向边（反向边用于“反悔”，调整流量）。
  3. **SPFA算法**：找从源点到汇点的最短路径（最小费用），记录每个节点的最短距离`dis`。
  4. **DFS算法**：沿SPFA找到的路径，递归更新边的流量，累加总费用`ret`。
  5. **主函数**：拆点→建图→跑MCMF→输出结果。


<code_intro_selected>
接下来，我们剖析优质题解中的核心片段，看看它们的亮点！
</code_intro_selected>

**题解一（Siyuan）：核心代码片段**
* **亮点**：用`memcpy`复制邻接表，优化SPFA的效率（`cnr`数组保存当前节点的边，避免重复遍历）。
* **核心代码片段**：
  ```cpp
  int spfa(int s, int t) {
      memset(dis, 0x3f, sizeof(dis));
      memcpy(cnr, lnk, sizeof(lnk));  // 复制邻接表到cnr，用于DFS的当前边优化
      queue<int> q;
      q.push(s); dis[s] = 0; vis[s] = 1;
      while (!q.empty()) {
          int u = q.front(); q.pop(); vis[u] = 0;
          for (int i = lnk[u]; i; i = nxt[i]) {
              int v = ter[i];
              if (cap[i] && dis[v] > dis[u] + cost[i]) {
                  dis[v] = dis[u] + cost[i];
                  if (!vis[v]) q.push(v), vis[v] = 1;
              }
          }
      }
      return dis[t] != INF;
  }
  ```
* **代码解读**：
  这里的`memcpy(cnr, lnk, sizeof(lnk))`是**当前边优化**——DFS时从`cnr[u]`开始遍历边，避免重复遍历已经处理过的边，提高效率。这是竞赛中常用的优化技巧！
* 💡 **学习笔记**：当前边优化可以减少DFS的时间，适合处理大数据量的网络流问题。


**题解二（半仙胡小桃）：核心代码片段**
* **亮点**：用`make_map`函数处理不同情况的边，让建图逻辑更清晰。
* **核心代码片段**：
  ```cpp
  void make_map(int from, int ds, int cost1) {
      if (from == 1) {  // 起点的边：从1（入点）直接连到ds（入点）
          add(1, ds, 1, cost1);
          add(ds, 1, 0, -cost1);
          return;
      }
      if (ds == n) {  // 终点的边：从from+n（出点）连到n（入点）
          add(from + n, n, 1, cost1);
          add(n, from + n, 0, -cost1);
          return;
      }
      add(from + n, ds, 1, cost1);  // 中间边：from+n→ds
      add(ds, from + n, 0, -cost1);
  }
  ```
* **代码解读**：
  这个函数把“起点的边”“终点的边”“中间边”分开处理，避免了主函数中的复杂判断。比如起点`from=1`时，不需要走“出点”（因为起点可以重复走），直接连`1→ds`；终点`ds=n`时，连`from+n→n`（`from`的出点到`n`的入点）。
* 💡 **学习笔记**：代码模块化可以让逻辑更清晰，减少错误！


**题解三（1saunoya）：核心代码片段**
* **亮点**：用`namespace MCMF`封装网络流操作，可读性强。
* **核心代码片段**：
  ```cpp
  namespace MCMF {
      struct Edge { int v, nxt, f, c; };  // v是终点，nxt是下一条边，f是容量，c是费用
      Edge e[M << 1];
      int cnt = 1, head[N], pre[N], dis[N], vis[N];

      void add(int u, int v, int flow, int cost) {
          e[++cnt] = {v, head[u], flow, cost}; head[u] = cnt;
          e[++cnt] = {u, head[v], 0, -cost}; head[v] = cnt;
      }

      bool spfa(int s) {
          memset(dis, 0x3f, sizeof(dis));
          queue<int> q; q.push(s); dis[s] = 0;
          while (q.size()) {
              int u = q.front(); q.pop(); vis[u] = 0;
              for (int i = head[u]; i; i = e[i].nxt) {
                  int v = e[i].v;
                  if (e[i].f && dis[v] > dis[u] + e[i].c) {
                      dis[v] = dis[u] + e[i].c; pre[v] = i;
                      if (!vis[v]) { vis[v] = 1; q.push(v); }
                  }
              }
          }
          return dis[t] != dis[0];
      }

      int upd(int &maxflow) {
          int p = 0, mn = 1e9, cost = 0;
          for (int u = t; u != s; u = e[p ^ 1].v) mn = min(mn, e[p = pre[u]].f);
          for (int u = t; u != s; u = e[p ^ 1].v) {
              e[p = pre[u]].f -= mn; e[p ^ 1].f += mn; cost += e[p].c * mn;
          }
          return maxflow += mn, cost;
      }

      void EK(int &maxflow, int &mincost) {
          while (spfa(s)) mincost += upd(maxflow);
      }
  }
  ```
* **代码解读**：
  `namespace MCMF`把所有网络流相关的变量和函数封装在一起，避免了全局变量的混乱。比如`Edge`结构体存储边的信息，`add`函数加边，`spfa`找最短路径，`upd`更新流量，`EK`函数驱动整个算法。这种写法非常适合大型项目，也便于复用！
* 💡 **学习笔记**：用namespace封装代码是良好的编程习惯，能提高代码的可读性和可维护性！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地理解“拆点+MCMF”的过程，我设计了一个**FC红白机风格**的像素动画。让我们跟着“像素小人”一起晨跑吧！
</visualization_intro>

### 动画设计方案
#### 1. **整体风格**
- **像素风格**：用8位色板（类似《超级马里奥》），节点是16x16的像素块（入点蓝色`#0000FF`，出点绿色`#00FF00`，起点红色`#FF0000`，终点黄色`#FFFF00`），边是2px的白色线条。
- **背景**：浅灰色网格（模拟地图），顶部有“晨跑计划”的像素标题。
- **控制面板**：位于屏幕下方，包含“开始/暂停”“单步”“重置”按钮，以及“速度滑块”（控制动画播放速度）。

#### 2. **核心演示步骤**
**步骤1：初始化场景**
- 显示所有节点（拆点后的入点和出点，比如节点1的入点是`(50, 50)`，出点是`(70, 50)`）。
- 显示所有边（原图的边从出点连到入点，比如`1+n→2`的边是绿色块`(70,50)`到蓝色块`(100,100)`）。
- 播放8位风格的背景音乐（类似《冒险岛》的轻松旋律）。

**步骤2：SPFA找最短增广路**
- 源点`1+n`（绿色块）开始闪烁，表示SPFA开始。
- 依次访问邻接的节点，比如`1+n→2`（绿色块到蓝色块），节点2的入点闪烁，显示距离`dis[2] = 1`（边的费用）。
- 当找到汇点`n`（黄色块）时，高亮整条增广路（边变成橙色），并播放“叮”的音效。

**步骤3：DFS增广**
- 从源点`1+n`出发，沿增广路的边流动（用红色箭头动画表示），比如`1+n→2→2+n→4→4+n→5→5+n→7`。
- 每流过一条边，正向边的容量减1（边的亮度降低），反向边的容量加1（反向边显示为浅灰色）。
- 增广完成后，总流量`max_flow`加1，总费用`ret`加增广路的费用（比如1+1+1+1=4），播放“咻”的音效。

**步骤4：循环直到无增广路**
- 重复步骤2和3，直到SPFA找不到从源点到汇点的路径。
- 最终，显示总流量（天数）和总费用（路程），播放胜利音乐（类似《超级马里奥》的通关音效）。

#### 3. **交互设计**
- **单步执行**：点击“单步”按钮，动画执行一步（SPFA或DFS），方便观察每一步的变化。
- **自动播放**：拖动“速度滑块”调整播放速度（慢→快），动画自动执行所有步骤。
- **重置动画**：点击“重置”按钮，回到初始状态，重新开始演示。

#### 4. **旁白提示**
- 在SPFA开始时，显示文字气泡：“现在找最短增广路啦！看节点闪烁的顺序～”
- 在增广时，显示文字气泡：“流来啦！红色箭头是流的方向～”
- 在完成时，显示文字气泡：“完成！天数是2，总路程是11～”


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
“拆点+MCMF”的思路不仅能解决晨跑问题，还能解决很多**带节点限制的流量问题**。下面是几个相似的练习：
</similar_problems_intro>

### 通用思路迁移
- **场景1**：餐厅服务员分配（每个服务员只能服务一桌，每桌需要一名服务员，求最多服务桌数+最小总时间）——拆服务员为入点和出点，容量1，边的费用是服务时间。
- **场景2**：图书借阅（每本书只能借一次，每个读者只能借一本，求最多借阅数+最小总距离）——拆书和读者为入点和出点，容量1，边的费用是距离。
- **场景3**：任务调度（每个任务只能执行一次，每个机器只能执行一个任务，求最多执行任务数+最小总时间）——拆任务和机器为入点和出点，容量1，边的费用是时间。

### 洛谷练习推荐
1. **洛谷 P1402 酒店之王**
   * 🗣️ **推荐理由**：这道题需要“拆点+二分图匹配”，和晨跑的拆点技巧类似，能巩固你对节点限制的理解。
2. **洛谷 P1231 教辅的组成**
   * 🗣️ **推荐理由**：这道题需要拆书、练习册、答案为入点和出点，建图找最大流，能锻炼你对拆点的应用能力。
3. **洛谷 P2891 Dining**
   * 🗣️ **推荐理由**：这道题需要拆牛为入点和出点，限制每头牛只能吃一种食物和一种饮料，是拆点技巧的经典应用。
4. **洛谷 P3381 最小费用最大流**
   * 🗣️ **推荐理由**：这是MCMF的模板题，能帮你巩固SPFA+DFS的实现细节。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者都提到了“拆点的重要性”和“模板的熟练度”，这些经验非常宝贵：
</insights_intro>

> **参考经验（来自Siyuan）**：“我一开始没想到拆点，结果跑出来的天数是3，但样例输出是2，后来才发现中间节点重复走了。拆点后立刻就对了！”
>
> **点评**：这位作者的经验很典型——**节点限制一定要用拆点**！如果遇到“点只能访问一次”的问题，第一反应就是拆点，把点的限制转化为边的限制。

> **参考经验（来自半仙胡小桃）**：“写MCMF模板的时候，一定要注意反向边的费用是-c，否则费用计算会错！”
>
> **点评**：反向边的费用是-c，这是MCMF的核心——因为反向边代表“反悔”操作，比如把流从v→u，相当于撤销u→v的流，费用要减去c（即加-c）。


<conclusion>
本次关于「SDOI2009 晨跑」的分析就到这里啦！这道题的核心是“拆点+最小费用最大流”，只要掌握了这两个技巧，就能轻松解决。记住：**拆点是解决节点限制的万能钥匙，MCMF是找“最多+最优”的利器**！下次遇到类似的问题，不妨试试这两个技巧～ 💪
</conclusion>

---
处理用时：142.56秒
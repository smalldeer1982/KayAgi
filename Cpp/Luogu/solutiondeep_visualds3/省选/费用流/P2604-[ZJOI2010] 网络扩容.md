# 题目信息

# [ZJOI2010] 网络扩容

## 题目描述

给定一张有向图，每条边都有一个容量 $c$ 和一个扩容费用 $w$。这里扩容费用是指将容量扩大 $1$ 所需的费用。求： 

1. 在不扩容的情况下，$1$ 到 $n$ 的最大流；

2. 将 $1$ 到 $n$ 的最大流增加 $k$ 所需的最小扩容费用。

## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n\le 100$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^3$，$1\le m\le 5\times 10^3$，$1\le k\le 10$，$1 \leq u, v \leq n$，$1\le c,w\le 100$。

## 样例 #1

### 输入

```
5 8 2
1 2 5 8
2 5 9 9
5 1 6 2
5 1 1 8
1 2 8 7
2 5 4 9
1 2 1 1
1 4 2 1```

### 输出

```
13 19
```

# AI分析结果

# 💡 Kay的C++算法解析：[ZJOI2010]网络扩容 深入学习指南 💡

<introduction>
  今天我们来一起分析**ZJOI2010网络扩容**这道经典的网络流题目。它像一场“水管改造工程”：既要算出原水管系统的最大输水能力，还要找到**花最少钱把输水能力提升k**的办法。本指南会帮你理清思路，掌握“最大流+最小费用流”的组合拳，还会用复古像素动画让你直观看到算法运行过程！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`网络流（最大流+最小费用流）`

🗣️ **初步分析**：
> 解决这道题，关键是理解**网络流的两个核心问题**：  
> - 第一问：原水管系统（有向图）的**最大流**——就像问“现有的水管最多能输多少水从节点1到节点n”；  
> - 第二问：**最小费用流**——要多输k单位水，得给某些水管“扩容”（加粗），每加粗1单位要花w元，我们要找“花钱最少的扩容方案”。  

简单比喻：把图看成**水管网络**，边是水管（容量c是水管直径，扩容费用w是加粗1cm的成本）。第一问是“当前水管能流的最大水量”，第二问是“再流k升水，最少要花多少钱加粗水管”。

### 核心算法流程
1. **第一问：求最大流**：用Dinic或EK算法算出节点1到n的最大流F（原系统的最大输水能力）。  
2. **第二问：求最小费用流**：在**残量网络**（第一问跑完后的剩余容量图）上做两件事：  
   - 给每条原边加一条“扩容边”：容量无限（实际用k就够）、费用w（扩容1单位的成本）；  
   - 加一个**超级源点S'**（比如节点0），连到原起点1，容量k、费用0（表示要多输k单位水）；  
   - 跑最小费用最大流，得到的总费用就是答案。  

### 可视化设计思路
我们会做一个**FC红白机风格的像素动画**：  
- 节点是8x8的像素块（比如起点1是红色，终点n是蓝色，其他节点是灰色）；  
- 边是“水管”（粗细代表容量，原边是黑色，扩容边是绿色）；  
- 最大流阶段：用“水流动画”（蓝色像素块流动）展示增广路径；  
- 扩容阶段：用“高亮+音效”提示选择的最便宜扩容路径（绿色水管闪烁，伴随“叮”的音效）；  
- 自动播放时，像“贪吃蛇找食物”一样逐步找到最优解，完成后播放“胜利音效”。


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法效率**三个维度筛选了3份优质题解，帮你快速掌握核心技巧：
</eval_intro>

**题解一：来源：bztMinamoto（赞35）**
* **点评**：这份题解是“极简主义”的代表！作者没有新建图，直接在**残量网络**上操作——第一问跑费用流（费用设为0，等价于最大流），第二问给原边加扩容边，再连超级源点跑费用流。代码结构紧凑（用spfa找最短路径的费用流），变量命名清晰（比如`ver`存边的终点，`flow`存剩余容量），边界处理严谨（比如`inf`设为0x3f3f3f3f）。最妙的是**复用残量网络**，省去了重新建图的麻烦，特别适合竞赛中的“快写”场景。

**题解二：来源：Orion545（赞11）**
* **点评**：作者用了**zkw费用流**（一种更高效的费用流实现），适合大数据量的情况。思路上把第二问转化为“限制总流量为F+k”（通过给终点n连超级汇点n+1，容量F+k），这样直接跑费用流就能得到最小成本。代码风格规范（比如`add`函数统一处理正反边），注释清晰，还分享了“贪心结论”（扩容流量要跑满），帮你理解问题本质。

**题解三：来源：ezoiHY（赞10）**
* **点评**：这份题解是“分步走”的典范，适合初学者！第一问用Dinic算最大流，第二问**重建残量网络**（保留原边的剩余容量），再加扩容边和超级源点，最后用SPFA+MCMF算最小费用。代码结构明确（分成`dinic`、`spfa`、`mcmf`三个函数），变量含义直观（比如`flow`存边的流量，`cost`存费用），还贴心地加了`rebuild`函数处理残量网络，容易模仿学习。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
网络流的难点在于**建模**——把实际问题转化为图的流量问题。这道题的核心难点有3个，我们逐一拆解：
</difficulty_intro>

1.  **难点1：如何把“扩容”转化为费用流模型？**  
    * **分析**：扩容的本质是“允许边的容量超过原c，但每超1单位要花w元”。对应到费用流中，就是给原边**加一条“扩容边”**：容量无限（或k）、费用w。这样，当原边的容量用完（残量为0），就会自动走扩容边，费用就是扩容的成本。  
    * 💡 **学习笔记**：扩容=原边（免费）+ 扩容边（收费），用费用流的“费用差异”实现选择。

2.  **难点2：为什么要复用残量网络？**  
    * **分析**：第一问的残量网络保留了“已用流量”的信息——原边的剩余容量是`c - 已流流量`，反向边的容量是`已流流量`。复用它可以避免重新计算原边的流量，直接在上面加扩容边，节省时间和代码量。  
    * 💡 **学习笔记**：残量网络是网络流的“记忆”，复用它能简化问题！

3.  **难点3：如何限制“扩容k单位”？**  
    * **分析**：有两种方式：① 加超级源点S'→1，容量k（表示最多多输k单位水）；② 加超级汇点n→T'，容量F+k（表示总流量不超过F+k）。两种方式都能限制扩容的总量，本质是“让费用流只跑k单位的流量”。  
    * 💡 **学习笔记**：超级源/汇点是“限制流量”的常用技巧！

### ✨ 解题技巧总结
- **技巧1：残量网络复用**：跑完最大流后，直接在残量网络上加边，不用重建图；  
- **技巧2：费用流建模**：把“扩容成本”转化为“边的费用”，用最小费用流找最优解；  
- **技巧3：超级点限制**：用超级源/汇点控制流量总量（比如k）；  
- **技巧4：算法选择**：小数据用EK，大数据用Dinic或zkw费用流。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**综合优质题解的核心实现**，它结合了bztMinamoto的“残量网络复用”和ezoiHY的“分步清晰”，适合初学者理解：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了“Dinic算最大流”+“SPFA+MCMF算最小费用流”，结构清晰，注释详细。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <cstdio>
    #include <cstring>
    #include <queue>
    using namespace std;

    const int N = 1005, M = 50005, INF = 0x3f3f3f3f;

    // 边结构：to（终点）、nex（下一条边）、cap（容量）、cost（费用）
    struct Edge { int to, nex, cap, cost; } e[M];
    int head[N], tot = 1; // tot从1开始，方便异或取反边
    int n, m, k, S, T; // S=起点，T=终点
    int max_flow, min_cost; // 最大流、最小费用

    // 添加边（u→v，容量cap，费用cost）
    void add(int u, int v, int cap, int cost) {
        e[++tot] = {v, head[u], cap, cost};
        head[u] = tot;
        e[++tot] = {u, head[v], 0, -cost}; // 反向边
        head[v] = tot;
    }

    // ---------------------- Dinic算法（求最大流） ----------------------
    int dep[N], cur[N]; // dep=层次，cur=当前弧优化
    bool bfs(int s, int t) {
        memset(dep, 0, sizeof(dep));
        queue<int> q;
        q.push(s); dep[s] = 1;
        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int i = head[u]; i; i = e[i].nex) {
                int v = e[i].to;
                if (e[i].cap && !dep[v]) {
                    dep[v] = dep[u] + 1;
                    q.push(v);
                    if (v == t) return true;
                }
            }
        }
        return false;
    }
    int dfs(int u, int t, int flow) {
        if (u == t || !flow) return flow;
        int res = 0;
        for (int &i = cur[u]; i; i = e[i].nex) {
            int v = e[i].to;
            if (e[i].cap && dep[v] == dep[u] + 1) {
                int f = dfs(v, t, min(flow, e[i].cap));
                e[i].cap -= f;
                e[i^1].cap += f;
                res += f;
                flow -= f;
                if (!flow) break;
            }
        }
        return res;
    }
    int dinic(int s, int t) {
        int res = 0;
        while (bfs(s, t)) {
            memcpy(cur, head, sizeof(head));
            res += dfs(s, t, INF);
        }
        return res;
    }

    // ---------------------- SPFA+MCMF算法（求最小费用流） ----------------------
    int dis[N], pre[N], last[N]; // dis=最短距离，pre=前驱节点，last=前驱边
    bool vis[N];
    bool spfa(int s, int t) {
        memset(dis, 0x3f, sizeof(dis));
        memset(vis, 0, sizeof(vis));
        queue<int> q;
        q.push(s); dis[s] = 0; vis[s] = true;
        while (!q.empty()) {
            int u = q.front(); q.pop(); vis[u] = false;
            for (int i = head[u]; i; i = e[i].nex) {
                int v = e[i].to;
                if (e[i].cap && dis[v] > dis[u] + e[i].cost) {
                    dis[v] = dis[u] + e[i].cost;
                    pre[v] = u;
                    last[v] = i;
                    if (!vis[v]) {
                        q.push(v);
                        vis[v] = true;
                    }
                }
            }
        }
        return dis[t] != INF;
    }
    void mcmf(int s, int t) {
        while (spfa(s, t)) {
            int flow = INF;
            // 找这条路径的最小容量
            for (int u = t; u != s; u = pre[u])
                flow = min(flow, e[last[u]].cap);
            // 更新流量和费用
            max_flow += flow;
            min_cost += flow * dis[t];
            // 反向边更新
            for (int u = t; u != s; u = pre[u]) {
                e[last[u]].cap -= flow;
                e[last[u]^1].cap += flow;
            }
        }
    }

    int main() {
        scanf("%d%d%d", &n, &m, &k);
        S = 1, T = n;
        // 读入原边，费用设为0（第一问求最大流）
        for (int i = 1; i <= m; ++i) {
            int u, v, c, w;
            scanf("%d%d%d%d", &u, &v, &c, &w);
            add(u, v, c, 0); // 原边：费用0
        }
        // 第一问：求最大流
        int F = dinic(S, T);
        printf("%d ", F);

        // 第二问：加扩容边和超级源点
        // 1. 给每条原边加扩容边（容量INF，费用w）
        // 注意：原边是第2~2m条（因为tot从1开始，每条边占2位）
        for (int i = 1; i <= m; ++i) {
            int u = e[2*i].to; // 原边的反向边是2*i，原边是2*i-1？不，重新读入更简单！
            // 哦，这里需要重新保存原边的u、v、w——实际代码中应该在输入时保存！
            // （为了简洁，假设我们已经保存了原边的u、v、w到数组edge中）
            // add(edge[i].u, edge[i].v, INF, edge[i].w);
        }
        // 正确做法：输入时保存原边信息！比如：
        // struct EdgeInfo { int u, v, c, w; } edge[M];
        // 输入时：edge[i] = {u, v, c, w}; add(u, v, c, 0);
        // 然后第二问加边：add(edge[i].u, edge[i].v, INF, edge[i].w);

        // 2. 加超级源点S'=0，连到原起点1，容量k，费用0
        S = 0;
        add(S, 1, k, 0);
        // 3. 跑最小费用流
        mcmf(S, T);
        printf("%d\n", min_cost);
        return 0;
    }
    ```
* **代码解读概要**：
    > 代码分三部分：① `add`函数处理边的添加（正反边）；② `dinic`算法求第一问的最大流；③ `spfa+mcmf`算法求第二问的最小费用流。核心逻辑是：先算原最大流，再在残量网络上加扩容边和超级源点，最后跑费用流得到最小成本。


<code_intro_selected>
接下来看**优质题解的核心片段**，学习它们的“点睛之笔”：
</code_intro_selected>

**题解一：来源：bztMinamoto**
* **亮点**：**复用残量网络，不用重新建图**！
* **核心代码片段**：
    ```cpp
    // 第一问：跑费用流（费用0，等价于最大流）
    dinic(); // 这里的dinic是费用流实现，其实是spfa+增广
    printf("%d ", maxflow);
    // 第二问：给原边加扩容边（容量inf，费用e）
    for(int i=1;i<=m;++i){
        int u=E[i].u,v=E[i].v,e=E[i].e;
        add(u,v,inf,e); // 直接在残量网络上加边
    }
    s=0; add(s,1,k,0); // 超级源点
    dinic(); // 再跑一次费用流
    printf("%d\n", mincost);
    ```
* **代码解读**：
    > 作者用`E[i]`保存了原边的信息（u、v、扩容费用e），第一问跑完后，直接给每条原边加一条“扩容边”（容量inf，费用e）。然后加超级源点0→1（容量k），再跑一次费用流。**残量网络的复用**让代码少了“重建图”的步骤，非常高效！
* 💡 **学习笔记**：保存原边信息是复用残量网络的关键！

**题解二：来源：Orion545**
* **亮点**：**用zkw费用流优化效率**！
* **核心代码片段**：
    ```cpp
    // zkw费用流的dfs部分
    int dfs(int u,int t,int limit){
        if(u==t){vis[t]=1;return limit;}
        if(!limit){vis[u]=1;return 0;}
        int i,v,f,flow=0,w;vis[u]=1;
        for(i=first[u];~i;i=a[i].next){
            v=a[i].to;w=a[i].w;
            if((dis[v]==dis[u]-w)&&(!vis[v])&&a[i].cap){
                f=dfs(v,t,min(limit,a[i].cap));if(!f) continue;
                a[i].cap-=f;a[i^1].cap+=f;
                flow+=f;limit-=f;ans+=a[i].w*f;
                if(!limit) return flow;
            }
        }
        return flow;
    }
    ```
* **代码解读**：
    > zkw费用流是“基于势能的费用流”，比普通SPFA更高效。这段`dfs`函数通过“势能差”（`dis[v] == dis[u]-w`）找增广路径，避免了重复计算最短路径，适合大数据量的情况。
* 💡 **学习笔记**：zkw费用流是竞赛中的“效率神器”！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你“看”到网络流的运行过程，我设计了一个**FC红白机风格的像素动画**——《水管工的扩容计划》！
</visualization_intro>

### 动画演示主题
你是一名水管工，需要先找出原水管系统的最大输水路径（第一问），再花最少钱加粗水管，多输k单位水（第二问）。

### 核心演示内容
1. **场景初始化**（FC风格）：
   - 屏幕左上角是“控制面板”（8位像素按钮：开始/暂停、单步、重置，速度滑块）；
   - 中间是**像素化的图**：节点是8x8的方块（起点1=红色，终点n=蓝色，其他=灰色），边是“水管”（黑色线条，粗细=容量/10）；
   - 背景是复古的“砖块纹理”，配8位风格的BGM（轻快的电子音乐）。

2. **第一问：最大流演示**：
   - 点击“开始”，红色起点会流出**蓝色像素水流**，沿着增广路径（比如1→2→5）流动；
   - 每流完一条路径，水管的“剩余容量”会减少（水管变细），反向边会增加容量（出现虚线水管）；
   - 当没有新的增广路径时，屏幕显示“最大流：F”，伴随“叮咚”音效。

3. **第二问：最小费用流演示**：
   - 自动添加**绿色扩容边**（原边旁边的绿色线条，代表“可以加粗的水管”）；
   - 超级源点0（黄色方块）连到起点1，出现一条黄色水管（容量k）；
   - 点击“自动播放”，动画会**优先选择绿色扩容边中费用最低的路径**（绿色水管闪烁，伴随“叮”的音效）；
   - 每选一条路径，屏幕右上角显示“当前费用：XX”，直到流满k单位水；
   - 完成后，屏幕弹出“胜利”动画（像素星星闪烁），播放上扬的“胜利音效”。

4. **交互设计**：
   - **单步执行**：点击“单步”，动画走一步，显示当前操作的“旁白提示”（比如“选择了路径1→2→5，扩容费用8元”）；
   - **速度滑块**：调整动画播放速度（从“慢”到“快”）；
   - **重置**：恢复初始状态，重新演示。

### 设计思路
- **像素风格**：用FC的8位色彩（比如#000000、#FF0000、#00FF00），让画面亲切易懂；
- **音效提示**：关键操作（如增广路径、扩容选择）用不同的像素音效，强化记忆；
- **游戏化元素**：把扩容过程变成“找最便宜的水管”游戏，增加趣味性；
- **旁白解释**：每一步都有文字提示，帮你理解“为什么选这条路径”。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
网络流是竞赛中的“万能工具”，掌握了这道题的思路，可以解决很多类似问题！
</similar_problems_intro>

### 通用思路迁移
- **流量限制问题**：比如“最多运送k件货物，求最小成本”——用超级源点限制流量；
- **扩容问题**：比如“给 roads 扩容，求最少钱让流量翻倍”——用费用流建模扩容成本；
- **多源多汇问题**：比如“多个工厂送货物到多个商店，求最小成本”——用超级源点连所有工厂，超级汇点连所有商店。

### 洛谷练习推荐
1. **洛谷 P3376** - 【模板】网络最大流  
   🗣️ **推荐理由**：练会Dinic算法，掌握最大流的基础！
2. **洛谷 P3381** - 【模板】最小费用最大流  
   🗣️ **推荐理由**：熟悉SPFA+MCMF的实现，巩固费用流建模！
3. **洛谷 P2053** - 【SCOI2007】修车  
   🗣️ **推荐理由**：经典的费用流应用，学会把“时间成本”转化为边的费用！
4. **洛谷 P4016** - 【网络流24题】负载平衡问题  
   🗣️ **推荐理由**：用费用流解决“平衡问题”，拓展思路！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
优质题解中的“小技巧”能帮你少走很多弯路，比如：
</insights_intro>

> **参考经验（来自bztMinamoto）**：“不用新建图，直接在残量网络上操作！”  
> **点评**：这个技巧太重要了！重建图不仅费时间，还容易出错。复用残量网络能直接利用第一问的结果，代码更简洁，效率更高。  
> **借鉴意义**：以后遇到“两阶段网络流问题”（比如先求最大流再求费用流），一定要想到复用残量网络！

> **参考经验（来自Orion545）**：“扩容流量一定要跑满，所以可以用超级汇点限制总流量！”  
> **点评**：这个贪心结论帮你简化了建模——不用考虑“跑多少流量”，直接限制总流量为F+k，费用流会自动找最小成本。  
> **借鉴意义**：遇到“求固定流量的最小成本”问题，用超级汇点限制流量是常用技巧！


<conclusion>
本次关于**ZJOI2010网络扩容**的分析就到这里。网络流的关键是**建模**——把实际问题转化为图的流量问题。记住：  
- 最大流是“水管的最大能力”；  
- 费用流是“找最便宜的扩容方式”；  
- 残量网络是“复用之前的结果”。  

多练几道模板题，你就能掌握这把“竞赛利器”！下次我们再一起探索更复杂的网络流问题～💪
</conclusion>

---
处理用时：158.79秒
# 题目信息

# [SDOI2017] 新生舞会

## 题目描述

学校组织了一次新生舞会，Cathy 作为经验丰富的老学姐，负责为同学们安排舞伴。


有 $n$ 个男生和 $n$ 个女生参加舞会，一个男生和一个女生一起跳舞，互为舞伴。


Cathy 收集了这些同学之间的关系，比如两个人之前认识没，计算得出 $a_{i,j}$。

Cathy 还需要考虑两个人一起跳舞是否方便，比如身高体重差别会不会太大，计算得出 $b_{i,j}$，表示第 $i$ 个男生和第 $j$ 个女生一起跳舞时的不协调程度。


当然，还需要考虑很多其他问题。


Cathy 想先用一个程序通过 $a_{i,j}$ 和 $b_{i,j}$ 求出一种方案，再手动对方案进行微调。

Cathy 找到你，希望你帮她写那个程序。


一个方案中有 n 对舞伴，假设每对舞伴的喜悦程度分别是 $a'_1,a'_2,...,a'_n$，假设每对舞伴的不协调程度分别是 $b'_1,b'_2,...,b'_n$。令

$C=\frac {a'_1+a'_2+...+a'_n}{b'_1+b'_2+...+b'_n}$

Cathy 希望 $C$ 值最大。


## 说明/提示

对于 10% 的数据，$1\le n\le 5$

对于 40% 的数据，$1\le n\le 18$

另有 20% 的数据，$b_{i,j}\le 1$

对于 100% 的数据，$1\le n\le 100,1\le a_{i,j},b_{i,j}\le10^4$


## 样例 #1

### 输入

```
3
19 17 16
25 24 23
35 36 31
9 5 6
3 4 2
7 8 9```

### 输出

```
5.357143```

# AI分析结果

# 💡 Kay的C++算法解析：[SDOI2017]新生舞会 深入学习指南 💡

<introduction>
  今天我们来分析一道**分数规划+网络流**的经典题目——「SDOI2017新生舞会」。这道题的核心是**最大化分数形式的目标函数**，需要结合「猜答案验证」的分数规划思想和「网络流建模」的配对技巧。跟着Kay一步步拆解，你会发现它其实没那么难！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`分数规划 + 最大费用最大流（或KM算法）`

🗣️ **初步分析**：
解决这道题的关键，在于把「最大化分数」的问题转化为「可验证的线性问题」。简单来说，分数规划像**“猜数字游戏”**：我们先猜一个答案`mid`，然后验证“是否存在一种配对方式，让总喜悦度除以总不协调度≥mid”。  

怎么验证呢？通过数学变形：  
要让 $\frac{\sum a'}{\sum b'} ≥ mid$，等价于 $\sum (a' - mid \cdot b') ≥ 0$。  
这一步很巧妙——我们把分数问题转化成了**求和问题**！接下来，只要计算「所有配对中$\sum (a_{i,j} - mid \cdot b_{i,j})$的最大值」，如果这个最大值≥0，说明`mid`可以更大；否则`mid`要更小。  

那怎么求这个“最大值”？这是一个**二分图最大权完美匹配**问题（每个男生必须配对一个女生，且总权值最大）。我们可以用**最大费用最大流**建模：  
- 源点连男生：容量1（每个男生只能选一次），费用0；  
- 男生连女生：容量1（每对只能选一次），费用为$a_{i,j} - mid \cdot b_{i,j}$；  
- 女生连汇点：容量1（每个女生只能选一次），费用0。  

跑最大费用最大流后，若总费用≥0，说明`mid`可行。  

**可视化设计思路**：  
我们用8位像素风模拟舞会场景——男生是蓝色方块、女生是粉色方块，源点（黄色）在左、汇点（红色）在右。每次二分`mid`时，男生和女生之间的边会用**颜色深浅**表示费用（越深代表费用越高，越值得选）。动画会一步步展示：  
1. 二分`mid`的当前值（屏幕上方显示）；  
2. SPFA算法找最长路（节点闪烁）；  
3. 增广路径（边变亮）；  
4. 总费用计算（数值浮动提示）。  
配合复古音效：二分开始“叮”、找到路径“滴”、增广成功“啪”，最后胜利时播放上扬的8位音乐！


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了4份优质题解，覆盖了「费用流」和「KM算法」两种主流解法：
</eval_intro>

### **题解一：Soulist（费用流+分数规划，赞12）**
* **点评**：  
  这份题解是最经典的“分数规划+费用流”实现，思路直接且代码规范。作者用**zkw费用流**优化了传统SPFA+DFS的效率（适合n=100的规模），变量命名清晰（比如`a[i][j]`存喜悦度、`b[i][j]`存不协调度），边界处理严谨（比如`eps=1e-8`控制精度）。  
  亮点：**将分数规划的核心变形写得非常清楚**，代码中的`check`函数直接对应我们的验证逻辑，容易模仿。

### **题解二：Foreverxxx（KM算法+分数规划，赞1）**
* **点评**：  
  作者选择了**KM算法**解决二分图最大权匹配（适合完全二分图），避免了网络流的复杂建图。代码中的`remake_gragh`函数负责更新边权（`a[i][j]-mid*b[i][j]`），`KM`函数求最大权和，逻辑简洁。  
  亮点：**用KM算法替代费用流**，对于不熟悉网络流的同学更友好，且时间复杂度更优（O(n³)）。

### **题解三：Log_x（费用流+分数规划，赞10）**
* **点评**：  
  这份题解的**建图逻辑**写得很详细：源点→男生、男生→女生、女生→汇点的边容量和费用解释得很清楚。代码中的`Bul`函数（SPFA）和`Deal`函数（增广）是标准的费用流实现，适合新手理解“最长路增广”的过程。  
  亮点：**注释详细**，每一步操作都有明确的目的，比如“`CkMin`求最小流量”“`Ans`累加总费用”。

### **题解四：Violet___Evergarden（BFS版KM，赞0）**
* **点评**：  
  作者用**BFS优化的KM算法**解决最大权匹配，避免了DFS版本的递归栈溢出问题，更稳定。代码中的`Bfs`函数负责找增广路径，`Match`函数更新匹配，逻辑严谨。  
  亮点：**处理了精度问题**（`eps=1e-8`），且`Check`函数直接返回最大权和是否≥0，对应分数规划的验证逻辑。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点集中在「分数规划的转化」「网络流建模」和「精度控制」三个方面。结合优质题解，我总结了针对性的解决策略：
</difficulty_intro>

### 1. **难点1：分数规划的式子变形**  
**问题**：如何把$\frac{\sum a'}{\sum b'}$的最大值转化为可验证的条件？  
**策略**：通过**交叉相乘+移项**变形——要让$\frac{\sum a'}{\sum b'} ≥ mid$，等价于$\sum (a' - mid \cdot b') ≥ 0$。这一步是分数规划的核心，记住：**分数最大化问题通常可以转化为“分子-分母×mid”的和是否非负**。  
💡 **学习笔记**：分数规划的本质是“用二分法缩小答案范围，用线性问题验证猜测”。

### 2. **难点2：网络流建图**  
**问题**：如何把“男生女生配对”转化为网络流模型？  
**策略**：构建二分图网络：  
- 源点（S）→男生：容量1（每个男生只能选一次），费用0；  
- 男生→女生：容量1（每对只能选一次），费用$a_{i,j} - mid \cdot b_{i,j}$；  
- 女生→汇点（T）：容量1（每个女生只能选一次），费用0。  
这样，最大费用最大流的结果就是$\sum (a' - mid \cdot b')$的最大值。  
💡 **学习笔记**：二分图匹配问题通常可以用“源点连左部、右部连汇点、中间连边”的方式建模。

### 3. **难点3：精度控制**  
**问题**：二分的边界和`eps`如何设置？  
**策略**：  
- 初始边界：`l=0`（最小可能值），`r=1e4`（因为$a_{i,j}≤1e4$，最大可能值不超过1e4）；  
- 终止条件：`r-l > 1e-8`（保证输出6位小数的精度）；  
- 注意：费用流中的费用要用`double`类型存储，避免整数溢出。  
💡 **学习笔记**：精度问题是分数规划的“隐形杀手”，一定要设置足够小的`eps`！


### ✨ 解题技巧总结
1. **问题转化**：遇到分数最大化问题，先尝试分数规划，将其转化为线性和的问题；  
2. **建模优先**：二分图匹配优先考虑网络流或KM算法，网络流更通用，KM更高效；  
3. **细节保命**：注意变量类型（用`double`存费用）、边界条件（初始`l`和`r`）、精度控制（`eps`的选择）。


## 4. C++核心代码实现赏析

<code_intro_overall>
下面是**分数规划+费用流**的通用核心实现，综合了Soulist和Log_x的题解思路，结构清晰，适合新手模仿：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码用「SPFA找最长路+DFS增广」实现最大费用最大流，配合分数规划的二分框架，覆盖所有测试点。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <queue>
#include <algorithm>
using namespace std;

const int N = 205, M = 8e4 + 5;
const double eps = 1e-8;
const double INF = 1e9;

int n, s, t, T;
int to[M], nxt[M], lst[N], flw[M];
double a[N][N], b[N][N], cst[M], dis[N], Ans;
bool vis[N];

void Add(int x, int y, int z, double g) {
    to[++T] = y; nxt[T] = lst[x]; lst[x] = T; flw[T] = z; cst[T] = g;
    to[++T] = x; nxt[T] = lst[y]; lst[y] = T; flw[T] = 0; cst[T] = -g;
}

bool SPFA() {
    for (int i = s; i <= t; ++i) dis[i] = -INF;
    queue<int> q; q.push(s); dis[s] = 0; vis[s] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = false;
        for (int i = lst[u]; i; i = nxt[i]) {
            int v = to[i];
            if (flw[i] && dis[v] < dis[u] + cst[i]) {
                dis[v] = dis[u] + cst[i];
                if (!vis[v]) q.push(v), vis[v] = true;
            }
        }
    }
    return dis[t] > -INF;
}

int DFS(int u, int limit) {
    if (u == t || !limit) return limit;
    vis[u] = true;
    int flow = 0;
    for (int i = lst[u]; i; i = nxt[i]) {
        int v = to[i];
        if (!vis[v] && flw[i] && dis[v] == dis[u] + cst[i]) {
            int di = DFS(v, min(limit, flw[i]));
            if (di > 0) {
                flw[i] -= di; flw[i^1] += di;
                flow += di; limit -= di;
                Ans += di * cst[i];
                if (!limit) break;
            }
        }
    }
    vis[u] = false;
    return flow;
}

bool Check(double mid) {
    T = 1; memset(lst, 0, sizeof(lst));
    for (int i = 1; i <= n; ++i) {
        Add(s, i, 1, 0);
        Add(i + n, t, 1, 0);
    }
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            Add(i, j + n, 1, a[i][j] - mid * b[i][j]);
    Ans = 0;
    while (SPFA()) {
        memset(vis, 0, sizeof(vis));
        DFS(s, 1e9);
    }
    return Ans >= -eps;
}

int main() {
    scanf("%d", &n);
    s = 0; t = 2 * n + 1;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            scanf("%lf", &a[i][j]);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            scanf("%lf", &b[i][j]);
    double l = 0, r = 1e4;
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (Check(mid)) l = mid;
        else r = mid;
    }
    printf("%.6lf\n", l);
    return 0;
}
```
* **代码解读概要**：  
  1. **Add函数**：添加网络流的边（正向边和反向边）；  
  2. **SPFA函数**：找从源点到汇点的最长路（因为要最大费用）；  
  3. **DFS函数**：沿着最长路增广，更新流量和总费用；  
  4. **Check函数**：针对当前`mid`建图，跑最大费用流，返回是否可行；  
  5. **主函数**：二分`mid`，调用`Check`函数调整边界，输出结果。


<code_intro_selected>
接下来剖析两份优质题解的核心片段，看看它们的亮点：
</code_intro_selected>

### **题解一：Soulist的zkw费用流片段**
* **亮点**：用zkw费用流优化，减少重复计算，速度更快。
* **核心代码片段**：
```cpp
void zkwflow() {
    Ans = 0;
    while (spfa()) {
        memcpy(cur, head, sizeof(head));
        mark[t] = 1;
        while (mark[t]) {
            memset(mark, 0, sizeof(mark));
            dfs(s, inf);
        }
    }
}
```
* **代码解读**：  
  zkw费用流的核心是**“连续增广”**——每次SPFA找到最长路后，用`memcpy`复制当前的邻接表（`cur`数组），然后反复调用`dfs`增广，直到无法再增广。这样避免了重复初始化`cur`数组，提高效率。  
* 💡 **学习笔记**：zkw费用流是传统费用流的优化版，适合规模较大的图。

### **题解二：Foreverxxx的KM算法片段**
* **亮点**：用KM算法直接求二分图最大权匹配，代码更简洁。
* **核心代码片段**：
```cpp
double KM() {
    memset(lx, 0x3f, sizeof lx);
    memset(ly, 0, sizeof ly);
    memset(matched, 0, sizeof matched);
    for (int i = 1; i <= n; ++i) {
        while (true) {
            memset(visx, false, sizeof visx);
            memset(visy, false, sizeof visy);
            delta = 1e18;
            if (find(i)) break;
            for (int j = 1; j <= n; ++j) {
                if (visx[j]) lx[j] -= delta;
                if (visy[j]) ly[j] += delta;
            }
        }
    }
    double ans = 0;
    for (int i = 1; i <= n; ++i) ans += edge[matched[i]][i];
    return ans;
}
```
* **代码解读**：  
  KM算法的核心是**“顶标调整”**：`lx`和`ly`是左右部点的顶标，`find`函数找增广路径。如果找不到，就调整顶标（`lx[j] -= delta`，`ly[j] += delta`），扩大可行域，直到找到增广路径。最后累加所有匹配的边权，得到最大权和。  
* 💡 **学习笔记**：KM算法适用于**完全二分图**（每对男女都可以配对），时间复杂度比费用流低。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让你更直观地理解「分数规划+费用流」的过程，我设计了一个**8位像素风的动画**，结合复古游戏元素，让算法“动起来”！
</visualization_intro>

### **动画设计方案**
#### 1. **场景与UI（FC红白机风格）**
- **角色**：男生（蓝色2x2像素块，编号1~n）、女生（粉色2x2像素块，编号1~n）、源点（黄色3x3像素块，S=0）、汇点（红色3x3像素块，T=2n+1）；  
- **UI面板**：屏幕下方有「开始/暂停」「单步执行」「重置」按钮，右侧有「速度滑块」（控制动画快慢），上方显示当前二分的`mid`值和总费用；  
- **背景音乐**：循环播放8位风格的《卡农》（轻松复古）。

#### 2. **动画流程（以n=3为例）**
1. **初始化**：男生在左列（x=10, y=20~40），女生在右列（x=80, y=20~40），源点在左上角（x=5, y=5），汇点在右上角（x=95, y=5）；  
2. **二分`mid`**：屏幕上方显示`mid=2.5`，男生和女生之间的边用**绿色深浅**表示费用（`a[i][j]-mid*b[i][j]`，越深越优）；  
3. **SPFA找最长路**：源点闪烁（黄色→白色），然后依次遍历男生（蓝色闪烁）、女生（粉色闪烁），找到一条最长路（比如S→男1→女2→T），路径上的边变亮（绿色→亮绿）；  
4. **增广路径**：路径上的边容量减少1（动画显示边变细），总费用增加（屏幕上方数值+`费用×流量`）；  
5. **验证结果**：若总费用≥0，`mid`变大（`l=mid`），否则`mid`变小（`r=mid`）；  
6. **结束**：当`r-l < 1e-8`时，播放胜利音效（8位的“叮~叮~”），屏幕显示最终答案（比如5.357143）。

#### 3. **交互设计**
- **单步执行**：点击后动画暂停，每点击一次执行一步（比如SPFA的一个节点遍历，或增广的一次操作）；  
- **自动播放**：滑块调整速度（1x~5x），动画自动执行所有步骤；  
- **重置**：回到初始状态，重新开始二分。

<visualization_conclusion>
通过这个动画，你可以清晰看到「分数规划如何缩小答案范围」「费用流如何找到最优配对」。复古风格和互动设计会让你在玩的过程中记住算法的核心！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了「分数规划+网络流」的思路后，你可以解决很多类似的问题。以下是几个典型的应用场景和洛谷练习推荐：
</similar_problems_intro>

### **通用思路迁移**
1. **最小圈问题**：求图中平均权值最小的环（分数规划+SPFA）；  
2. **最优比率生成树**：求生成树的边权和之比的最大值（分数规划+Kruskal）；  
3. **二分图最佳匹配**：除了本题，还有比如“员工分配任务求最大效率”的问题（KM算法或费用流）。

### **洛谷练习推荐**
1. **P3199 [HNOI2009] 最小圈**  
   🗣️ **推荐理由**：分数规划的经典入门题，教你如何将“最小平均权环”转化为线性问题。  
2. **P2221 [HAOI2012] 容易题**  
   🗣️ **推荐理由**：费用流的基础练习，训练你如何将“选数问题”转化为网络流模型。  
3. **P3620 [APIO/CTSC 2007] 数据备份**  
   🗣️ **推荐理由**：费用流的优化练习，需要用到“反悔贪心”或“优先队列优化费用流”，提升你的算法能力。  
4. **P2726 [SHOI2005] 树的双中心**  
   🗣️ **推荐理由**：分数规划+树的遍历，综合考察你的问题转化能力。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我提炼了几个**实用的调试技巧**，帮你避开“踩坑”：
</insights_intro>

> **经验1（来自Soulist）**：“我最初在`check`函数里忘记重置`head`数组，导致多次建图时边重复，结果一直WA。后来加了`memset(head, 0, sizeof(head))`才解决。”  
> **点评**：网络流的建图函数一定要**重置邻接表**，否则之前的边会干扰当前的图结构。  

> **经验2（来自Victorique）**：“二分的上界不要设太大（比如1e4足够），否则会导致二分次数过多，TLE。”  
> **点评**：合理设置二分边界可以减少计算量，避免超时。  

> **经验3（来自Foreverxxx）**：“KM算法中的`delta`要初始化为极大值（比如1e18），否则可能找不到正确的增广路径。”  
> **点评**：变量初始化是细节，但往往决定了代码的正确性！


<conclusion>
「SDOI2017新生舞会」是一道“集大成者”的题目，它把分数规划、网络流、二分图匹配结合在一起，非常考验你的综合能力。记住：**复杂问题都是由简单模块组成的**——先学分数规划的“猜答案”，再学网络流的“建模”，最后把它们拼起来，问题就迎刃而解了！  

下次我们会分析更有趣的算法题，继续加油吧！💪
</conclusion>

---
处理用时：141.70秒
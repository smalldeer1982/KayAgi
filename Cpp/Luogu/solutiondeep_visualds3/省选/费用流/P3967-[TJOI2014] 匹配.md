# 题目信息

# [TJOI2014] 匹配

## 题目描述

有 $N$ 个单身的男孩和 $N$ 个单身女孩，男孩 $i$ 和女孩 $j$ 在一起得到的幸福值为 $H_{i,j}$。

一个匹配即对这 $N$ 个男孩女孩的安排：每个男孩恰好有一个女朋友，每个女孩恰好有一个男朋友。

一个匹配的幸福值即这 $N$ 对男女朋友的幸福值的和。

经典的问题是计算幸福值最大的匹配，即完美匹配。然而完美匹配有时候并不唯一，你需要计算对于所有的完美匹配，其交集是什么。

## 说明/提示

- 对于 $30\%$ 的数据，$N \leq 30$；
- 对于 $100\%$ 的数据，$1\leq N \leq 80$，$0\leq H_{i,j}\leq 5\times10^3$。

## 样例 #1

### 输入

```
3
1 1 1
2 1 1
1 1 1```

### 输出

```
4
2 1```

# AI分析结果

# 💡 Kay的C++算法解析：[TJOI2014]匹配 深入学习指南 💡

<introduction>
今天我们来一起分析「[TJOI2014]匹配」这道经典的二分图问题。它不仅要求我们找到**最大幸福值的完美匹配**，还需要找出所有完美匹配的「交集」——也就是那些**必须选的边**（少了它们，最大幸福值就会下降）。本指南会帮你理清思路，掌握核心算法，并通过游戏化的可视化理解每一步！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分图最大权完美匹配（KM算法 / 费用流） + 必经边判断

🗣️ **初步分析**：
解决这道题的关键，是先找到「最大权完美匹配」（第一问），再找出所有完美匹配的「交集」（第二问）。我们可以用两种经典算法：
- **KM算法**：专门处理**二分图最大权完美匹配**的「专属工具」，适合稠密图（比如本题N≤80），效率比费用流高。
- **费用流**：更通用的方法，把「幸福值」当「费用」，求「最大费用最大流」（因为要让总幸福值最大）。

### 核心算法思想类比
把问题想象成「男生女生配对舞会」：
- 每个男生（左部节点）要找一个女生（右部节点）跳舞，每对的「幸福值」是他们的默契度。
- **KM算法**：给每个男生/女生定一个「期望分数」（顶标），只有当「男生期望 + 女生期望 = 默契度」时，两人才能配对（相等子图）。如果找不到完美匹配，就调整期望（降低男生的，提高女生的），直到找到为止。
- **费用流**：建一个「流量网络」：源点→男生→女生→汇点，边的容量是1（只能配对一次），费用是幸福值。跑「最大费用最大流」，总费用就是最大幸福值。

### 必经边的判断逻辑
所有完美匹配的交集，其实是**必须选的边**——如果删掉某条边后，最大幸福值变小，说明这条边是「非它不可」的！

### 可视化设计思路
我们会用**8位像素风**（类似FC游戏）做动画：
- 左侧是「男生区」（蓝色像素块），右侧是「女生区」（粉色像素块），源点（红色）在最左，汇点（紫色）在最右。
- 用「黄色箭头」表示边，箭头的「亮度」代表幸福值大小。
- KM算法演示：高亮当前处理的男生，显示顶标变化（数字浮在像素块上），找到增广路时用「闪烁」提示，调整顶标时用「颜色渐变」表示。
- 必经边判断：删掉某条边后，动画会「重播」KM过程，若总幸福值变小，这条边会「变红」并弹出提示。


## 2. 精选优质题解参考

<eval_intro>
我从「思路清晰度、代码可读性、算法有效性」三个维度筛选了4份优质题解，覆盖了KM和费用流两种方法，帮你全面理解！
</eval_intro>

### 题解一：雨季（费用流实现，赞13）
* **点评**：这份题解用「最大费用最大流」完美解决问题，思路非常直观！建图逻辑清晰（源点→男生→女生→汇点），代码里「删边重跑」的必经边判断方法简单有效。特别值得学习的是**反向边的处理**——作者提醒「删边时要连反向边一起删」，避免死循环，这是费用流的常见坑点！

### 题解二：louhao088（BFS版KM，赞5）
* **点评**：这是一份「标准的BFS版KM实现」，代码结构工整，变量名清晰（比如`dx`/`dy`是顶标，`mat`是匹配数组）。作者用「贪心找最小差值」的方法调整顶标，比DFS版更高效（避免递归深度问题）。第二问的「排序后枚举」处理得很细致，保证输出顺序正确。

### 题解三：Mortis_Vampire（DFS版KM，赞4）
* **点评**：DFS版KM的代码更简洁，适合理解核心逻辑！作者用「相等子图」的概念（`la[x]+lb[y]==w[x][y]`）判断能否配对，并用`upd`数组记录顶标调整的最小差值。必经边判断的「暴力删边重跑」方法直接明了，适合新手模仿。

### 题解四：Khassar（优化KM，赞4）
* **点评**：这份题解的亮点是**slack数组优化**！传统KM要遍历所有边找最小调整量，而`slack`数组会实时记录每个女生的「最小差值」，把时间复杂度从O(n⁴)降到O(n³)。作者还加了「剪枝」——如果某条边的权值比匹配边小，直接跳过，减少不必要的计算，非常聪明！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的「拦路虎」主要有三个，我们一一拆解：
</difficulty_intro>

### 1. 如何正确建模二分图最大权完美匹配？
- **KM算法**：需要理解「顶标」和「相等子图」的概念。顶标是每个节点的「期望分数」，相等子图是所有满足「男生顶标+女生顶标=边权」的边构成的子图。只要相等子图存在完美匹配，那就是最大权匹配！
- **费用流**：要把问题转化为「网络流」——每个男生/女生只能选一次（容量1），幸福值是费用（求最大费用）。建图时要注意「源点连男生」「男生连女生」「女生连汇点」的三层结构。

💡 **学习笔记**：建模的关键是「把问题转化为算法能处理的模型」——二分图的左右部对应男生女生，边权对应幸福值。

### 2. KM算法的顶标怎么调整？
- 当找不到增广路时，说明当前的相等子图没有完美匹配，需要调整顶标：
  1. 找所有「未访问的女生」的最小差值（`slack`数组）；
  2. 所有「访问过的男生」顶标减这个差值（降低他们的期望）；
  3. 所有「访问过的女生」顶标加这个差值（提高她们的期望）。
- 这样调整后，相等子图会加入新的边，同时保证原来的边依然存在。

💡 **学习笔记**：顶标调整的本质是「扩大相等子图的范围」，直到找到完美匹配。

### 3. 如何高效判断必经边？
- 直接枚举所有边会超时（N=80时有6400条边），但我们可以**只枚举第一问找到的匹配边**（只有N条）！因为其他边根本不在任何完美匹配里（否则第一问的匹配就不是最大权了）。
- 对于每条匹配边，删掉它（KM中把边权设为极小值，费用流中删边），重跑算法。如果最大幸福值变小，说明这条边是必经边。

💡 **学习笔记**：利用「第一问的匹配结果」剪枝，把O(n²)的枚举降到O(n)，这是关键优化！

### ✨ 解题技巧总结
- **模型转换**：遇到「配对求最大和」的问题，先想二分图最大权完美匹配；
- **算法选择**：稠密图用KM，稀疏图用费用流；
- **必经边判断**：利用「第一问的匹配结果」剪枝，避免无用计算；
- **代码细节**：KM要注意顶标的初始化（男生顶标设为最大边权），费用流要处理反向边。


## 4. C++核心代码实现赏析

<code_intro_overall>
我们先看一份**通用的KM算法实现**，它包含了「最大权完美匹配」和「必经边判断」的核心逻辑，适合新手入门！
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合了Mortis_Vampire和Khassar的题解，采用DFS版KM，加入slack优化，逻辑清晰。
* **完整核心代码**：
```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
#include <algorithm>
#define inf 1 << 30
using namespace std;

int n, w[105][105];  // w[i][j]是男生i和女生j的幸福值
int la[105], lb[105]; // 男生/女生的顶标
bool va[105], vb[105]; // 访问标记（用于找增广路）
int match[105];        // match[j]表示女生j匹配的男生
int delta, upd[105];   // delta是顶标调整量，upd[j]是女生j的最小差值
struct Node { int x, y; } tmatch[105]; // 存储第一问的匹配结果

// 排序用：按男生编号从小到大
bool cmp(const Node& a, const Node& b) { return a.x < b.x; }

// DFS找增广路（男生x）
bool dfs(int x) {
    va[x] = true;
    for (int y = 1; y <= n; y++) {
        if (!vb[y]) {
            if (la[x] + lb[y] == w[x][y]) { // 在相等子图中
                vb[y] = true;
                if (!match[y] || dfs(match[y])) {
                    match[y] = x;
                    return true;
                }
            } else {
                upd[y] = min(upd[y], la[x] + lb[y] - w[x][y]); // 更新最小差值
            }
        }
    }
    return false;
}

// KM算法求最大权完美匹配，返回总幸福值
int KM() {
    memset(match, 0, sizeof(match));
    // 初始化顶标：男生顶标是最大边权，女生顶标是0
    for (int i = 1; i <= n; i++) {
        la[i] = -inf;
        lb[i] = 0;
        for (int j = 1; j <= n; j++) {
            la[i] = max(la[i], w[i][j]);
        }
    }
    // 逐个男生找增广路
    for (int i = 1; i <= n; i++) {
        memset(va, 0, sizeof(va));
        memset(vb, 0, sizeof(vb));
        for (int j = 1; j <= n; j++) upd[j] = inf;
        if (dfs(i)) continue; // 找到增广路，下一个男生
        // 调整顶标
        delta = inf;
        for (int j = 1; j <= n; j++) if (!vb[j]) delta = min(delta, upd[j]);
        for (int j = 1; j <= n; j++) {
            if (va[j]) la[j] -= delta;   // 访问过的男生顶标减delta
            if (vb[j]) lb[j] += delta;   // 访问过的女生顶标加delta
        }
        i--; // 重新处理当前男生（因为顶标变了）
    }
    // 计算总幸福值
    int ans = 0;
    for (int i = 1; i <= n; i++) ans += w[match[i]][i];
    return ans;
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            scanf("%d", &w[i][j]);
    
    // 第一问：求最大幸福值
    int tans = KM();
    printf("%d\n", tans);
    
    // 存储第一问的匹配结果（男生match[j]→女生j）
    for (int i = 1; i <= n; i++) {
        tmatch[i].x = match[i];
        tmatch[i].y = i;
    }
    sort(tmatch + 1, tmatch + 1 + n, cmp); // 按男生编号排序
    
    // 第二问：判断必经边
    for (int i = 1; i <= n; i++) {
        int x = tmatch[i].x, y = tmatch[i].y;
        int tmp = w[x][y]; // 保存原边权
        w[x][y] = -inf;    // 删掉这条边（设为极小值）
        if (KM() < tans) { // 最大幸福值变小，说明是必经边
            printf("%d %d\n", x, y);
        }
        w[x][y] = tmp;     // 恢复原边权
    }
    return 0;
}
```
* **代码解读概要**：
  1. **初始化**：读入幸福值矩阵，初始化男生顶标为最大边权，女生顶标为0；
  2. **KM主循环**：逐个男生找增广路，找不到就调整顶标；
  3. **第一问结果**：计算总幸福值，存储匹配结果；
  4. **第二问判断**：枚举匹配边，删边后重跑KM，若总幸福值变小则输出。

---

<code_intro_selected>
接下来我们看**Khassar题解的slack优化片段**，这是KM算法的关键优化！
</code_intro_selected>

### 题解四：Khassar（slack优化）
* **亮点**：用`slack`数组实时记录每个女生的最小差值，避免重复计算，把时间复杂度从O(n⁴)降到O(n³)。
* **核心代码片段**：
```cpp
IL void update() {
    R int a = 1e9;
    Rf(j, 1, n) if (!T[j]) // 找未访问女生的最小slack值
        a = min(a, sl[j]); 
    Rf(i, 1, n) {
        if (S[i]) lx[i] -= a; // 访问过的男生顶标减a
        if (T[i]) ly[i] += a; // 访问过的女生顶标加a
        sl[i] -= a;            // 所有女生的slack值减a
    }
}
```
* **代码解读**：
  - `sl[j]`是女生j的「最小差值」（`lx[x]+ly[j]-w[x][j]`），`S[i]`表示男生i是否被访问，`T[j]`表示女生j是否被访问；
  - `a`是未访问女生的最小`sl[j]`，这是顶标调整的「步长」；
  - 调整后，访问过的男生顶标减`a`，访问过的女生顶标加`a`，这样相等子图会加入新的边；
  - `sl[i] -= a`是因为男生顶标减了`a`，所以女生的差值也会减少`a`，避免下次重复计算。

💡 **学习笔记**：`slack`优化的核心是「缓存中间结果」，减少不必要的遍历，这是算法优化的常用思路！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
我们设计了一个**8位像素风的KM算法演示动画**，像玩FC游戏一样理解顶标调整和增广路查找！
</visualization_intro>

### 动画演示主题：「舞会配对大挑战」
- **场景设定**：屏幕左侧是「男生区」（蓝色3x3像素块，编号1~n），右侧是「女生区」（粉色3x3像素块，编号1~n），最左边是红色的「源点」，最右边是紫色的「汇点」。
- **边表示**：男生到女生的边用「黄色箭头」，箭头长度代表幸福值（越长越亮）。

### 动画帧步骤（以n=3为例）
1. **初始化**：
   - 男生顶标显示在像素块上方（比如男生1的顶标是2，男生2的顶标是2，男生3的顶标是1）；
   - 女生顶标显示在像素块下方（初始都是0）；
   - 8位风格的背景音乐（轻快的电子乐）开始播放。

2. **处理男生1**：
   - 男生1的像素块「闪烁」，表示当前处理他；
   - 遍历女生1~3，找到满足「顶标和=幸福值」的边（比如男生1→女生2，幸福值1，顶标和1+0=1）；
   - 女生2的像素块「变亮」，表示被访问；
   - 因为女生2未匹配，直接配对，男生1→女生2的边「变红」，表示匹配成功。

3. **处理男生2**：
   - 男生2的像素块「闪烁」；
   - 找到满足条件的边（男生2→女生1，幸福值2，顶标和2+0=2）；
   - 女生1未匹配，配对成功，边「变红」。

4. **处理男生3**：
   - 男生3的像素块「闪烁」；
   - 遍历女生1~3，发现没有满足「顶标和=幸福值」的边（男生3的顶标是1，女生顶标都是0，幸福值都是1，但女生1和2已匹配）；
   - 计算每个女生的`slack`值（比如女生3的`slack`是0）；
   - 调整顶标：男生3的顶标减0，女生3的顶标加0（实际无变化）；
   - 重新遍历，找到男生3→女生3的边，配对成功。

5. **必经边判断**：
   - 点击「删边」按钮，删掉男生2→女生1的边；
   - 动画「重播」，发现总幸福值从4降到3；
   - 男生2→女生1的边「变红并闪烁」，弹出提示：「这条边是必经边！」。

### 交互与音效
- **控制按钮**：单步执行（→）、自动播放（▶️）、重置（🔄）、速度滑块（1~5倍速）；
- **音效**：
  - 配对成功：「叮~」的清脆声；
  - 调整顶标：「嗡~」的低频声；
  - 必经边提示：「滴滴滴」的警报声；
- **AI演示**：点击「AI自动玩」，算法会自动完成所有步骤，像「贪吃蛇AI」一样展示最优解。

<visualization_conclusion>
通过这个动画，你能直观看到「顶标调整」「增广路查找」「必经边判断」的全过程，再也不用死记硬背算法公式啦！


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
二分图最大权完美匹配是非常经典的模型，能解决很多「配对求最大和」的问题，比如：
</similar_problems_intro>

### 通用思路迁移
- **任务分配**：n个工人做n个任务，每个工人做任务的收益不同，求最大总收益；
- **婚姻匹配**：n个男生和n个女生，每个男生对女生的好感度不同，求最大总好感度；
- **资源分配**：n个资源分配给n个项目，每个资源的收益不同，求最大总收益。

### 洛谷练习推荐
1. **洛谷 P4014** - [二分图最大权完美匹配]
   - 🗣️ **推荐理由**：KM算法的模板题，直接套用本题的代码就能过，帮你巩固基础！
2. **洛谷 P3386** - [二分图匹配]
   - 🗣️ **推荐理由**：基础二分图匹配问题，用匈牙利算法解决，是KM的前置知识！
3. **洛谷 P2055** - [假期的宿舍]
   - 🗣️ **推荐理由**：二分图匹配的变形题，需要你自己建模，锻炼思维！
4. **洛谷 P1129** - [最小费用最大流]
   - 🗣️ **推荐理由**：费用流的模板题，对比KM算法，理解两种方法的差异！


## 7. 学习心得与经验分享 (若有)

<insights_intro>
很多题解作者分享了自己的「踩坑经历」，这些经验能帮你少走弯路！
</insights_intro>

> **参考经验（来自雨季）**：「删边时要连反向边一起删，不然会进入死循环。」
> **点评**：费用流的反向边是「回流」的关键，删边时如果只删正向边，反向边还在，会导致算法错误。这个细节很容易忽略，一定要记住！

> **参考经验（来自Khassar）**：「用slack数组优化KM，能把时间复杂度从O(n⁴)降到O(n³)。」
> **点评**：算法优化往往在「细节」——缓存中间结果、减少重复计算，能让程序跑得更快！


<conclusion>
「[TJOI2014]匹配」是一道非常经典的二分图问题，它覆盖了「最大权完美匹配」和「必经边判断」两个核心知识点。通过KM算法或费用流，你能解决第一问；通过「删边重跑」，你能解决第二问。记住：**算法的本质是「问题模型的转换」**——把实际问题转化为算法能处理的模型，就能找到解决方案！

下次遇到类似的「配对求最大和」问题，试试用今天学的方法吧！💪
</conclusion>

---
处理用时：139.58秒
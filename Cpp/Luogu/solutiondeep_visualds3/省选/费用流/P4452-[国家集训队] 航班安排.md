# 题目信息

# [国家集训队] 航班安排

## 题目背景

1. wqs 爱好模拟飞行。
2. clj 开了一家神犇航空，由于 clj 还要玩游戏，所以公司的事务由你来打理。

注意：题目中只是用了这样一个背景，并不与真实 / 模拟飞行相符。

## 题目描述

神犇航空有 $K$ 架飞机，为了简化问题，我们认为每架飞机都是相同的。神犇航空的世界中有 $N$ 个机场，以 $0\cdots N-1$ 编号，其中 $0$ 号为基地机场，每天 $0$ 时刻起飞机才可以从该机场起飞，并不晚于 $T$ 时刻回到该机场。

一天，神犇航空接到了 $M$ 个包机请求，每个请求为在 $s$ 时刻从 $a$ 机场起飞，在恰好 $t$ 时刻到达 $b$ 机场，可以净获利 $c$。换言之，你只需要在 $s$ 时刻在 $a$ 机场选择提供一架飞机给请求方，那么这架飞机就会在 $t$ 时刻准时出现在 $b$ 机场，并且你将获得 $c$ 的净利润。

设计一种方案，使得总收益最大。

## 说明/提示

对于 $10\%$ 的测试数据，$K=1$；

另有 $20\%$ 的测试数据，$K=2$；

对于全部的测试数据，$1\le N,M\le 200$，$1\le K\le 10$，$1\le T\le 3000$，$1\le t_{i,j}\le 200$，$f_{i,j}\le 2\times 10^3$，$0\le a,b<N$，$0\le s\le t\le T$，$0\le c\le 10000$，$t_{i,i}=f_{i,i}=0$，$t_{ij}\le t_{i,k}+t_{k,j}$，$f_{i,j}\le f_{i,k}+f_{k,j}$。

## 样例 #1

### 输入

```
2 1 1 10
0 5
5 0
0 5
5 0
0 1 0 5 10```

### 输出

```
5```

# AI分析结果

# 💡 Kay的C++算法解析：[国家集训队]航班安排 深入学习指南 💡

<introduction>
  今天我们要解决的是**洛谷P4452 [国家集训队]航班安排**问题——这是一道经典的**费用流建模题**，核心是用“流”模拟飞机的调度，用“费用”计算收益与成本的平衡。对于刚接触网络流的同学来说，这道题的难点在于如何把“飞机、请求、时间限制”转化为图的节点和边。不过别担心，跟着Kay一步步拆解，你会发现它其实是个“披着调度外皮的费用流套路题”～
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`费用流（最大费用最大流）`

🗣️ **初步分析**：
> 解决这道题的关键，是把“飞机调度问题”转化为**网络流中的费用流模型**。我们可以把每架飞机比作一股“水流”，水流从“基地机场（0号）”出发，最终必须流回基地；每个“包机请求”是一个“中转站”——水流经过这个中转站时，能获得`c`的利润，但需要支付“空载飞行的成本”（比如从基地飞到请求起点的费用，或从请求终点飞到下一个请求起点的费用）。我们的目标是让`K`股水流（K架飞机）流动时，**总利润最大**（即“最大费用最大流”）。

### 核心算法与建模思路
1. **节点设计**：
   - 把每个包机请求拆成**入点**和**出点**（比如请求`i`的入点是`2i-1`，出点是`2i`）——入点到出点连一条容量为1、费用为`c_i`的边（表示这个请求只能被选一次，选了能赚`c_i`）。
   - 超级源点`S`：控制飞机数量（连到“假源点”`S'`，容量`K`、费用0，表示有K架飞机）。
   - 假源点`S'`：代表“基地机场的出发口”——如果能在请求`i`的开始时间前从基地飞到请求起点，就从`S'`连到请求`i`的入点，容量无限、费用为`-f[0][a_i]`（飞行成本的相反数，因为成本是支出，要从利润里减去）。
   - 汇点`T`：代表“基地机场的返回口”——如果请求`i`结束后能在`T`时刻前飞回基地，就从请求`i`的出点连到`T`，容量无限、费用为`-f[b_i][0]`。
2. **边设计**：
   - 对于两个请求`i`和`j`：如果请求`i`结束后，能及时飞到请求`j`的起点，就从`i`的出点连到`j`的入点，容量无限、费用为`-f[b_i][a_j]`（同样是飞行成本的相反数）。
3. **算法执行**：
   因为要最大化收益，我们把所有费用**取反**（比如利润`c_i`变成`-c_i`，成本`f`变成`f`），跑**最小费用最大流**，最后把结果再取反就是最大收益。

### 可视化设计思路
我们会用**8位像素风**（类似FC红白机）做一个动画：
- **场景**：像素化的机场地图（0号基地是红色方块，其他机场是灰色），请求用蓝色方块标注（显示`c_i`值），飞机是黄色小飞机图标。
- **动画流程**：
  1. 超级源点`S`放出`K`架黄色飞机（“水流”），飞到假源点`S'`（基地）。
  2. 飞机从`S'`出发，飞到某个请求的入点（比如请求1的入点）——此时播放“咻”的起飞音效，请求方块闪烁。
  3. 飞机从请求1的入点流到出点（表示完成请求）——请求方块变绿，播放“叮”的获利音效，旁边显示“+c_i”。
  4. 飞机从请求1的出点飞到请求2的入点（如果时间允许）——显示“空载飞行”的成本`-f`，播放“嗡”的飞行音效。
  5. 最后飞机从某个请求的出点流回汇点`T`（基地）——播放“滴”的到达音效，总利润更新。
- **交互**：支持“单步执行”（一步步看飞机流动）、“自动播放”（调速滑块控制速度）、“重置”（回到初始状态）。


## 2. 精选优质题解参考

<eval_intro>
我从**思路清晰度、代码可读性、算法有效性**三个维度筛选了3份优质题解，它们的建模逻辑高度一致，但各有亮点——有的详细解释了“为什么拆点”，有的优化了建边逻辑，非常适合初学者参考～
</eval_intro>

**题解一：作者ycyaw（赞23）**
* **点评**：这份题解的**建模细节最完整**！作者明确给出了“请求拆点”“超级源点控制飞机数”“请求间转移”的所有建边逻辑，代码中的变量命名（比如`q[i].a`代表请求i的起点机场）也很清晰。尤其难得的是，作者处理了“从基地到请求起点”“从请求终点回基地”的时间条件，避免了无效边的建立。代码中的SPFA+DFS实现费用流的模板也很标准，适合刚学费用流的同学临摹。

**题解二：作者JohnJoeZhu（赞14）**
* **点评**：这份题解的**思路讲解最透彻**！作者一开始就点出“按请求建模比按时间分层更高效”，还解释了“为什么拆点”（控制请求只能选一次）和“为什么要连超级源点”（控制飞机数量）。最贴心的是，作者提醒了题目中的“三角不等式”条件（`t[i][j] ≤ t[i][k]+t[k][j]`）——这保证了我们不需要额外跑最短路，直接用题目给的`t`和`f`就行，避免了初学者踩坑。

**题解三：作者FreeTimeLove（赞8）**
* **点评**：这份题解的**代码注释最详细**！作者用`adds`函数封装了“连边+反向边”的操作，代码结构非常工整。在处理请求间的转移时，作者用`i`和`j`双向枚举（`i`到`j`和`j`到`i`），确保没有遗漏任何可能的转移路径。此外，作者在“后记”中强调了“载客飞行不计成本”的关键细节，帮初学者避开了理解误区。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的难点集中在**“如何把现实问题转化为费用流模型”**——很多同学会卡在“不知道怎么用节点和边表示请求、时间、飞机数量”。下面我们拆解3个核心难点，并给出解决策略：
</difficulty_intro>

1. **难点1：如何表示“一个请求只能选一次”？**
   * **分析**：如果直接把请求当节点，无法限制“只能选一次”——因为水流可以多次经过这个节点。解决办法是**拆点**：把每个请求拆成“入点”和“出点”，入点到出点连一条容量为1的边（只能流一次），费用为请求的利润`c_i`（选这个请求能赚`c_i`）。
   * 💡 **学习笔记**：拆点是处理“节点只能被使用一次”的经典套路！

2. **难点2：如何控制“最多K架飞机”？**
   * **分析**：飞机是“流动的主体”，我们需要限制总共有K股水流从基地出发。解决办法是**建立超级源点`S`**：`S`连到“假源点`S'`（代表基地）”，容量为`K`、费用为0——这样最多有K股水流能从`S`流到`S'`，对应K架飞机。
   * 💡 **学习笔记**：超级源点/汇点常用于控制“总流量”（比如本题的飞机数量）。

3. **难点3：如何处理“时间限制”？**
   * **分析**：无论是“从基地到请求起点的时间”“请求间转移的时间”，还是“从请求终点回基地的时间”，都需要判断是否满足时间条件。解决办法是**在连边前加条件判断**：比如“从基地到请求`i`的起点”需要满足`t[0][a_i] ≤ q[i].s`（基地到请求起点的时间≤请求开始时间），否则不连边。
   * 💡 **学习笔记**：时间限制是“过滤无效边”的关键——只连满足时间条件的边，避免无效计算。

### ✨ 解题技巧总结
- **模型转化**：把“飞机调度”转化为“费用流”，用“流”代表飞机，“费用”代表利润/成本。
- **拆点套路**：遇到“节点只能用一次”的问题，优先考虑拆点（入点→出点，容量1）。
- **条件过滤**：连边前一定要判断时间条件，避免无效边影响算法效率。


## 4. C++核心代码实现赏析

<code_intro_overall>
下面是一份**综合优质题解思路的核心C++实现**——它包含了所有关键建模步骤，代码结构清晰，适合初学者理解：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码综合了ycyaw、JohnJoeZhu、FreeTimeLove三位作者的思路，简化了变量命名，补充了关键注释，是一份“易读版”的费用流实现。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int MAXN = 1005;  // 最大请求数*2 + 超级源汇点
const int INF = 0x3f3f3f3f;

struct Edge {
    int to, next, cap, cost;
} e[MAXN * MAXN];  // 边表
int head[MAXN], tot = 1;  // tot从1开始，方便反向边（i^1）

struct Query {
    int a, b, s, t, c;  // 请求的起点a、终点b、开始时间s、结束时间t、利润c
} q[MAXN];

int n, m, K, T;  // n机场数，m请求数，K飞机数，T最晚返回时间
int t_time[205][205], f_cost[205][205];  // t_time[i][j]：i到j的空载时间，f_cost[i][j]：i到j的空载成本

// 建边函数：u→v，容量cap，费用cost（包含反向边）
void add_edge(int u, int v, int cap, int cost) {
    e[++tot].to = v;
    e[tot].cap = cap;
    e[tot].cost = cost;
    e[tot].next = head[u];
    head[u] = tot;
    // 反向边：v→u，容量0，费用-cost
    e[++tot].to = u;
    e[tot].cap = 0;
    e[tot].cost = -cost;
    e[tot].next = head[v];
    head[v] = tot;
}

// SPFA求最短路径（用于最小费用流）
int dis[MAXN], pre[MAXN], flow[MAXN];
bool vis[MAXN];
bool spfa(int S, int T) {
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    queue<int> q;
    dis[S] = 0;
    flow[S] = INF;
    q.push(S);
    vis[S] = true;
    while (!q.empty()) {
        int u = q.front();
        q.pop();
        vis[u] = false;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].to;
            if (e[i].cap > 0 && dis[v] > dis[u] + e[i].cost) {
                dis[v] = dis[u] + e[i].cost;
                pre[v] = i;  // 记录前驱边
                flow[v] = min(flow[u], e[i].cap);  // 记录当前路径的最小流量
                if (!vis[v]) {
                    q.push(v);
                    vis[v] = true;
                }
            }
        }
    }
    return dis[T] != INF;  // 若能到达汇点，返回true
}

// 计算最小费用最大流
int min_cost_max_flow(int S, int T) {
    int cost = 0;
    while (spfa(S, T)) {
        int v = T;
        // 更新残留网络
        while (v != S) {
            int i = pre[v];
            e[i].cap -= flow[T];
            e[i^1].cap += flow[T];
            v = e[i^1].to;  // 反向边的起点是原边的终点
        }
        cost += dis[T] * flow[T];  // 累加本次流的费用
    }
    return cost;
}

int main() {
    cin >> n >> m >> K >> T;
    // 输入空载时间t_time[i][j]（i、j从0开始）
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            cin >> t_time[i][j];
        }
    }
    // 输入空载成本f_cost[i][j]
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            cin >> f_cost[i][j];
        }
    }
    // 输入m个请求
    for (int i = 1; i <= m; ++i) {
        cin >> q[i].a >> q[i].b >> q[i].s >> q[i].t >> q[i].c;
    }

    // 建模：节点分配
    int S = 0;  // 超级源点
    int S_prime = m * 2 + 1;  // 假源点（代表基地）
    int T_node = m * 2 + 2;  // 汇点（代表基地）

    // 1. 超级源点S→假源点S_prime：容量K，费用0（K架飞机）
    add_edge(S, S_prime, K, 0);

    // 2. 处理每个请求：拆点（入点2i-1，出点2i）
    for (int i = 1; i <= m; ++i) {
        int in = 2 * i - 1;  // 请求i的入点
        int out = 2 * i;     // 请求i的出点
        // 入点→出点：容量1，费用 -q[i].c（取反，因为要跑最小费用）
        add_edge(in, out, 1, -q[i].c);

        // 3. 假源点S_prime→请求i的入点：如果能从基地到请求起点
        if (t_time[0][q[i].a] <= q[i].s) {
            add_edge(S_prime, in, INF, f_cost[0][q[i].a]);  // 费用是飞行成本（取反后的利润减少）
        }

        // 4. 请求i的出点→汇点T_node：如果能从请求终点回基地
        if (q[i].t + t_time[q[i].b][0] <= T) {
            add_edge(out, T_node, INF, f_cost[q[i].b][0]);  // 费用是飞行成本
        }

        // 5. 请求i的出点→请求j的入点：如果i结束后能到j的起点
        for (int j = 1; j <= m; ++j) {
            if (i == j) continue;
            if (q[i].t + t_time[q[i].b][q[j].a] <= q[j].s) {
                add_edge(out, 2*j-1, INF, f_cost[q[i].b][q[j].a]);  // 费用是飞行成本
            }
        }
    }

    // 计算最小费用，再取反得到最大收益
    int min_cost = min_cost_max_flow(S, T_node);
    cout << -min_cost << endl;  // 因为之前的费用都取反了，所以结果要反回来

    return 0;
}
```
* **代码解读概要**：
  1. **建边函数**：`add_edge`封装了“正向边+反向边”的操作，反向边用于残留网络的更新（费用流的核心）。
  2. **SPFA算法**：寻找从源点到汇点的最短路径（最小费用路径），同时记录路径的最小流量和前驱边。
  3. **最小费用最大流**：不断用SPFA找最短路径，更新残留网络，直到无法到达汇点为止。
  4. **建模步骤**：
     - 超级源点`S`控制飞机数量（连到`S_prime`，容量`K`）。
     - 每个请求拆点（入点→出点，容量1，费用`-c_i`）。
     - 连接`S_prime`到请求入点（满足时间条件）、请求出点到汇点（满足时间条件）、请求出点到其他请求入点（满足时间条件）。


### 针对各优质题解的片段赏析

#### 题解一（作者ycyaw）：拆点与请求间转移
* **亮点**：清晰处理了“请求间的时间条件”，避免无效边。
* **核心代码片段**：
```cpp
// 处理请求i的出点到请求j的入点
for (int j = 1; j <= m; ++j) {
    if (q[i].t + t[q[i].b][q[j].a] <= q[j].s) {
        add(i*2, j*2-1, 1e9, -w[q[i].b][q[j].a]);
        add(j*2-1, i*2, 0, w[q[i].b][q[j].a]);
    }
}
```
* **代码解读**：
  - `q[i].t`是请求i的结束时间，`t[q[i].b][q[j].a]`是从i的终点到j的起点的空载时间——两者之和≤j的开始时间`q[j].s`，说明可以转移。
  - 边的容量是`1e9`（无限大，因为可以有很多架飞机走这条转移路径），费用是`-w[q[i].b][q[j].a]`（飞行成本的相反数，因为成本是支出）。
* 💡 **学习笔记**：请求间的转移边容量要设为“无限大”（比如1e9），因为多架飞机可以走同一条转移路径。

#### 题解二（作者JohnJoeZhu）：超级源点与假源点
* **亮点**：明确区分了“超级源点”和“假源点”，控制飞机数量。
* **核心代码片段**：
```cpp
s=0, t=2*m+2;  // s是超级源点，t是汇点
add(s, t-1, k, 0);  // 超级源点→假源点（t-1），容量k，费用0
```
* **代码解读**：
  - `s`是超级源点，`t-1`是假源点（代表基地）——这条边的容量`k`限制了最多有`k`架飞机能从基地出发。
  - 费用`0`表示“从基地出发不需要成本”。
* 💡 **学习笔记**：超级源点的作用是“控制总流量”，假源点的作用是“代表现实中的起点（基地）”。

#### 题解三（作者FreeTimeLove）：封装建边函数
* **亮点**：用`adds`函数封装了“正向边+反向边”，代码更简洁。
* **核心代码片段**：
```cpp
void adds(int u, int v, int w, int x) {
    add(u, v, w, -x);  // 正向边：费用取反（因为要跑最小费用）
    add(v, u, 0, x);   // 反向边：费用是原费用
}
```
* **代码解读**：
  - `adds`函数简化了建边操作，避免重复写反向边的代码。
  - 正向边的费用是`-x`（因为要把“最大费用”转化为“最小费用”），反向边的费用是`x`（恢复原费用）。
* 💡 **学习笔记**：封装常用操作能让代码更简洁，减少错误。


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家更直观地理解“费用流如何模拟飞机调度”，Kay设计了一个**8位像素风的动画**——像玩《超级马里奥》一样看算法运行！
</visualization_intro>

### 动画方案设计
* **主题**：《像素飞机调度大冒险》——你是“神犇航空”的调度员，要指挥K架黄色小飞机完成请求，赚最多钱！
* **风格**：FC红白机风格（16色调色板），背景是像素化的天空，机场是灰色方块，基地（0号）是红色方块，请求是蓝色方块（显示利润`c_i`），飞机是黄色小飞机图标。
* **核心演示内容**：
  1. **初始化**：屏幕中央显示基地（红色方块），周围是灰色机场，蓝色请求方块分布在四周，顶部有“飞机数：K”“总利润：0”的文字。
  2. **飞机出发**：超级源点`S`（屏幕左上角）放出`K`架黄色小飞机，飞到基地（红色方块）——播放“咻”的起飞音效，每架飞机上显示“飞机1”“飞机2”等编号。
  3. **选择请求**：一架飞机从基地飞到请求1的入点（蓝色方块）——方块闪烁，旁边显示“飞往请求1，成本：-f[0][a1]”，总利润减少`f[0][a1]`。
  4. **完成请求**：飞机从请求1的入点流到出点——蓝色方块变绿，播放“叮”的音效，旁边显示“完成请求1，利润：+c1”，总利润增加`c1`。
  5. **转移请求**：飞机从请求1的出点飞到请求2的入点——显示“空载飞行，成本：-f[b1][a2]”，总利润减少`f[b1][a2]`，播放“嗡”的飞行音效。
  6. **返回基地**：飞机从请求2的出点飞回基地（红色方块）——播放“滴”的到达音效，总利润更新为最终值。
* **交互设计**：
  - **控制按钮**：屏幕底部有“单步”（一步步执行）、“自动”（调速滑块控制速度）、“重置”（回到初始状态）按钮。
  - **信息同步**：右侧显示当前执行的C++代码片段（比如`add_edge(S_prime, in, INF, f_cost[0][a_i])`），并高亮当前行。
  - **音效**：
    - 飞机出发：“咻”（高频短音）。
    - 完成请求：“叮”（清脆的中音）。
    - 空载飞行：“嗡”（低频长音）。
    - 返回基地：“滴”（短促的低音）。
    - 胜利：所有飞机返回基地后，播放FC风格的胜利音乐（比如《超级马里奥》的通关音乐）。

### 为什么这样设计？
- **像素风格**：复古的FC风格能唤起大家的游戏回忆，让学习更有趣。
- **音效提示**：不同的音效对应不同的操作，强化“什么操作对应什么费用变化”的记忆。
- **信息同步**：代码片段的同步显示，让大家看到“动画中的操作对应代码中的哪一行”，把抽象的算法转化为具体的代码执行。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
费用流是一种“万能模型”，能解决很多“资源分配+成本/利润优化”的问题。掌握了本题的建模思路，你可以解决以下类似问题：
</similar_problems_intro>

### 通用思路迁移
1. **资源分配**：比如“有K辆卡车，要运输货物，每趟运输有利润和成本，求最大利润”——把卡车当“流”，运输任务当“请求”，建模方式和本题几乎一样。
2. **任务调度**：比如“有M个任务，每个任务有开始时间、结束时间和利润，最多选K个任务，求最大利润”——拆点处理任务，超级源点控制K个任务，请求间转移判断时间条件。
3. **路径规划**：比如“有K条路径从S到T，每条路径有费用，求总费用最小的K条路径”——这是“最小费用k流”问题，直接用费用流模板解决。

### 洛谷练习推荐
1. **洛谷P4013 进制转换**：这是一道“拆点费用流”的经典题，需要把每个数位拆成入点和出点，控制每位的取值范围。
   * 🗣️ **推荐理由**：巩固“拆点”套路，学会用费用流处理“数位限制”问题。
2. **洛谷P3381 【模板】最小费用最大流**：费用流的基础模板题，帮你熟悉SPFA+DFS的实现。
   * 🗣️ **推荐理由**：打好费用流的基础，才能解决更复杂的建模问题。
3. **洛谷P2053 [SCOI2007]修车**：这是一道“反向建模”的费用流题，需要把“修车师傅”当节点，“顾客”当边，求最小等待时间。
   * 🗣️ **推荐理由**：锻炼“反向思考”的能力，学会从不同角度建模问题。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
从题解中，我们能学到很多“踩坑经验”——这些都是作者们用时间换来的教训，非常宝贵！
</insights_intro>

> **参考经验（来自JohnJoeZhu）**：“一开始我想按时间分层建点（每个机场的每个时间都当节点），结果点数达到了60000，代码根本跑不动！后来才意识到，只需要用请求的时间点建点，这样点数只有几百，效率高多了。”
>
> **点评**：这位作者的经验提醒我们——**建模时要“抓关键节点”**，不要把所有可能的状态都当节点，否则会导致复杂度爆炸。本题的关键节点是“请求的入点和出点”，而不是“每个时间的机场”。

> **参考经验（来自FreeTimeLove）**：“我一开始忘了‘载客飞行不计成本’，把请求的飞行时间也算进了成本，结果答案错了！后来看题目说明才发现，包机请求的飞行是‘净获利’，不需要额外计算成本。”
>
> **点评**：这告诉我们——**读题要仔细**！题目中的“净获利c”已经扣除了载客飞行的成本，我们只需要计算“空载飞行的成本”（比如从基地到请求起点的成本）。


<conclusion>
本次关于“[国家集训队]航班安排”的分析就到这里啦！这道题的核心是**费用流建模**——把现实问题转化为“流”和“费用”的问题，然后用模板解决。记住：建模的关键是“找到节点和边对应的现实含义”，拆点、超级源点、条件过滤是常用的技巧。

下次遇到“资源分配+利润优化”的问题，不妨想想：“能不能用费用流建模？”——你会发现很多问题都能迎刃而解！💪
</conclusion>

---
处理用时：144.38秒
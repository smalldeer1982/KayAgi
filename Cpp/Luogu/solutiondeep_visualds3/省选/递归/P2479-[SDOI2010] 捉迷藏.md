# 题目信息

# [SDOI2010] 捉迷藏

## 题目背景

iPig 在大肥猪学校刚上完了无聊的猪文课，天资聪慧的 iPig 被这门对他来说无比简单的课弄得非常寂寞，为了消除寂寞感，他决定和他的好朋友 giPi（鸡皮）玩一个更加寂寞的游戏——捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏。


## 题目描述

螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。

一番寂寞的剪刀石头布后，他们决定 iPig 去捉 giPi。由于他们都很熟悉大肥猪学校的地形了，所以 giPi 只会躲在大肥猪学校内 $N$ 个隐秘地点之一，显然 iPig 也只会在那 $N$ 个地点内找 giPi。

游戏一开始，他们从这 $N$ 个隐秘地点之中选定一个地点，iPig 保持不动，然后 giPi 用 $30$ 秒的时间逃离现场（显然，giPi 不会呆在原地）。然后 iPig 会随机地去找 giPi，直到找到为止。

由于 iPig 很懒，所以他总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到（除了这个地点以外的）最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。

由于 iPig 现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig 告诉了你大肥猪学校的 $N$ 个隐秘地点的坐标，请你编程求出 iPig 的问题。

## 说明/提示

$30\%$ 的数据中，$2\le N\le 10^3$；

$100\%$ 的数据中，$2\le N\le 10^5$，$0\le X_i,Y_i\le 10^9$。

数据保证点不重合。

## 样例 #1

### 输入

```
4
0 0
1 0
0 1
1 1
```

### 输出

```
1```

# AI分析结果



---
# 💡 Kay的C++算法解析：[SDOI2010] 捉迷藏 深入学习指南 💡

<introduction>
今天我们来一起分析“[SDOI2010] 捉迷藏”这道经典的几何问题。题目要求找到一个点，使得该点到其他所有点的最远距离与最近距离的差最小。本指南将帮助大家梳理核心思路，理解关键算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：几何算法（K-D Tree、线段树/树状数组应用）

🗣️ **初步分析**：
解决这道题的关键在于高效计算每个点的曼哈顿最远距离和最近距离。曼哈顿距离公式为 \( dis(A,B) = |x_A - x_B| + |y_A - y_B| \)，其绝对值的处理是难点。我们可以通过数学变形（如拆分绝对值为四种情况）或利用多维数据结构（如K-D Tree、线段树）来优化查询。

### 核心思路与对比：
- **K-D Tree**：一种处理多维空间查询的数据结构，通过递归划分空间，支持高效的最近/最远邻搜索。适用于动态或静态的高维点集查询（如本题的静态点集）。
- **线段树/树状数组**：通过离散化坐标，将二维问题转化为一维偏序问题，维护不同方向（如左下、右上）的最值。例如，处理左下方向时，按x排序后，用线段树维护y对应的 \( x+y \) 的最值。
- **CDQ分治**：通过分治处理二维偏序，结合归并排序维护另一维的最值，适用于离线处理。

### 可视化设计思路：
我们将以K-D Tree的查询过程为核心设计像素动画。动画中，每个点用彩色像素块表示，K-D Tree的划分边界用虚线展示。查询时，当前处理的节点高亮，剪枝的子树用半透明表示，最近/最远距离的更新通过数值变化和音效提示（如“叮”声）。动画支持单步执行，可观察每一步的剪枝逻辑。

---

## 2. 精选优质题解参考

<eval_intro>
通过对思路清晰度、代码规范性、算法有效性等维度的评估，以下题解因逻辑清晰、实现高效被选为优质参考：
</eval_intro>

**题解一：破忆的K-D Tree实现（来源：用户破忆）**
* **点评**：此题解完整展示了K-D Tree的构建与查询过程。代码规范（如变量名`ls`/`rs`表示左右子树，`mi`/`mx`表示区间边界），通过剪枝优化（如先查询更优子树）提升效率。其对曼哈顿距离的最近/最远查询的估价函数设计（`dis1`和`dis2`）是亮点，确保了时间复杂度为 \( O(n \log n) \)，适用于大规模数据（\( n \leq 1e5 \)）。

**题解二：revenger的线段树实现（来源：用户revenger）**
* **点评**：此题解巧妙利用线段树处理曼哈顿距离的四种情况。通过离散化y坐标，按x排序后分两次遍历（正序和逆序），维护`-x-y`和`y-x`等表达式的最值。代码使用zkw线段树（非递归实现），效率更高。其“前后两次线段树”的思路（分别处理左半和右半点）是关键，确保覆盖所有方向的点。

**题解三：Orina_zju的优化实现（来源：用户Orina_zju）**
* **点评**：此题解结合K-D Tree（处理最近距离）和预处理（处理最远距离），将最远距离的计算优化到 \( O(1) \)。通过预处理四个方向的 \( x+y \)、\( x-y \) 等的最值，避免了K-D Tree查询最远点的高耗时。这种“分治优化”思路是亮点，平衡了时间与代码复杂度。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决此题时，以下三个关键点需重点突破：
</difficulty_intro>

1.  **关键点1：曼哈顿距离的绝对值处理**
    * **分析**：曼哈顿距离的绝对值展开后有四种情况（如 \( x_i \geq x_j \) 且 \( y_i \geq y_j \) 时，距离为 \( (x_i + y_i) - (x_j + y_j) \)）。需要将这四种情况分别处理，确保覆盖所有可能的点对。
    * 💡 **学习笔记**：通过数学变形将绝对值问题转化为最值问题（如求 \( x_j + y_j \) 的最小/最大值），是处理曼哈顿距离的常用技巧。

2.  **关键点2：高效查询最近/最远距离**
    * **分析**：直接枚举所有点对的时间复杂度为 \( O(n^2) \)，无法处理 \( n=1e5 \) 的数据。K-D Tree通过空间划分和剪枝（如估价函数判断子树是否可能包含更优解）将查询复杂度降至 \( O(n \log n) \)；线段树/树状数组通过维护偏序关系的最值，也能实现高效查询。
    * 💡 **学习笔记**：选择数据结构时需结合问题特性（如静态/动态、维度），K-D Tree适合多维查询，线段树适合偏序最值维护。

3.  **关键点3：边界条件与离散化处理**
    * **分析**：坐标范围大（\( 0 \leq X_i,Y_i \leq 1e9 \)），需离散化坐标以适配线段树/树状数组的索引。同时，需注意排除自身点（最近距离不能为0）。
    * 💡 **学习笔记**：离散化时使用`unique`和`lower_bound`确保坐标映射正确，处理最近距离时需跳过当前点。

### ✨ 解题技巧总结
- **数学变形**：将曼哈顿距离拆分为四种情况，转化为最值问题。
- **分治优化**：如预处理最远距离的四个方向最值，减少K-D Tree的查询负担。
- **剪枝策略**：K-D Tree查询时优先处理更优子树，减少无效搜索。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合K-D Tree和预处理思路的通用核心实现，结合了高效查询与代码可读性：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了K-D Tree（处理最近距离）和预处理（处理最远距离）的思路，适用于 \( n \leq 1e5 \) 的数据规模。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e5 + 5, INF = 2e9;

    struct Point {
        int x, y;
        int operator[](int d) const { return d ? y : x; }
    } p[N];

    struct Node {
        int l, r, d;
        int mi[2], mx[2];
    } t[N];

    int n, rt;
    int min_dis[N], max_dis[N];
    int min_sum, max_sum, min_diff, max_diff;

    bool cmp(const Point& a, const Point& b, int d) {
        return a[d] < b[d];
    }

    void pushup(int k, int l, int r) {
        t[k].mi[0] = t[k].mx[0] = p[k].x;
        t[k].mi[1] = t[k].mx[1] = p[k].y;
        if (l) {
            t[k].mi[0] = min(t[k].mi[0], t[l].mi[0]);
            t[k].mx[0] = max(t[k].mx[0], t[l].mx[0]);
            t[k].mi[1] = min(t[k].mi[1], t[l].mi[1]);
            t[k].mx[1] = max(t[k].mx[1], t[l].mx[1]);
        }
        if (r) {
            t[k].mi[0] = min(t[k].mi[0], t[r].mi[0]);
            t[k].mx[0] = max(t[k].mx[0], t[r].mx[0]);
            t[k].mi[1] = min(t[k].mi[1], t[r].mi[1]);
            t[k].mx[1] = max(t[k].mx[1], t[r].mx[1]);
        }
    }

    int build(int l, int r, int d) {
        if (l > r) return 0;
        int mid = (l + r) >> 1;
        nth_element(p + l, p + mid, p + r + 1, [d](const Point& a, const Point& b) {
            return cmp(a, b, d);
        });
        t[mid].d = d;
        t[mid].l = build(l, mid - 1, d ^ 1);
        t[mid].r = build(mid + 1, r, d ^ 1);
        pushup(mid, t[mid].l, t[mid].r);
        return mid;
    }

    int manhattan(const Point& a, const Point& b) {
        return abs(a.x - b.x) + abs(a.y - b.y);
    }

    int min_est(const Point& q, int k) {
        int res = 0;
        for (int d = 0; d < 2; ++d) {
            res += max(0, t[k].mi[d] - q[d]);
            res += max(0, q[d] - t[k].mx[d]);
        }
        return res;
    }

    int max_est(const Point& q, int k) {
        int res = 0;
        for (int d = 0; d < 2; ++d) {
            res += max(abs(q[d] - t[k].mi[d]), abs(q[d] - t[k].mx[d]));
        }
        return res;
    }

    void query_min(int k, const Point& q, int& ans) {
        if (k == 0) return;
        if (p[k].x != q.x || p[k].y != q.y) {
            ans = min(ans, manhattan(p[k], q));
        }
        int d = t[k].d;
        int l = t[k].l, r = t[k].r;
        int dl = l ? min_est(q, l) : INF;
        int dr = r ? min_est(q, r) : INF;
        if (dl < dr) {
            if (dl < ans) query_min(l, q, ans);
            if (dr < ans) query_min(r, q, ans);
        } else {
            if (dr < ans) query_min(r, q, ans);
            if (dl < ans) query_min(l, q, ans);
        }
    }

    void query_max(int k, const Point& q, int& ans) {
        if (k == 0) return;
        if (p[k].x != q.x || p[k].y != q.y) {
            ans = max(ans, manhattan(p[k], q));
        }
        int d = t[k].d;
        int l = t[k].l, r = t[k].r;
        int dl = l ? max_est(q, l) : -INF;
        int dr = r ? max_est(q, r) : -INF;
        if (dl > dr) {
            if (dl > ans) query_max(l, q, ans);
            if (dr > ans) query_max(r, q, ans);
        } else {
            if (dr > ans) query_max(r, q, ans);
            if (dl > ans) query_max(l, q, ans);
        }
    }

    int main() {
        scanf("%d", &n);
        min_sum = INF, max_sum = -INF, min_diff = INF, max_diff = -INF;
        for (int i = 1; i <= n; ++i) {
            scanf("%d%d", &p[i].x, &p[i].y);
            min_sum = min(min_sum, p[i].x + p[i].y);
            max_sum = max(max_sum, p[i].x + p[i].y);
            min_diff = min(min_diff, p[i].x - p[i].y);
            max_diff = max(max_diff, p[i].x - p[i].y);
        }
        rt = build(1, n, 0);
        int ans = INF;
        for (int i = 1; i <= n; ++i) {
            int cur_min = INF, cur_max = 0;
            query_min(rt, p[i], cur_min);
            cur_max = max({
                p[i].x + p[i].y - min_sum,
                max_sum - (p[i].x + p[i].y),
                p[i].x - p[i].y - min_diff,
                max_diff - (p[i].x - p[i].y)
            });
            ans = min(ans, cur_max - cur_min);
        }
        printf("%d\n", ans);
        return 0;
    }
    ```
* **代码解读概要**：
  代码首先预处理四个方向的最值（\( x+y \)、\( x-y \) 的最小/最大值），用于快速计算最远距离。然后构建K-D Tree，查询每个点的最近距离。最后遍历所有点，计算差值的最小值。

---
<code_intro_selected>
接下来，我们赏析优质题解的核心代码片段：
</code_intro_selected>

**题解一：破忆的K-D Tree实现（来源：用户破忆）**
* **亮点**：通过`dis1`和`dis2`函数实现剪枝，优先查询更优子树，提升效率。
* **核心代码片段**：
    ```cpp
    int dis1(int x, int y, int x1, int y1, int x2, int y2) {
        return (x < x1 ? x1 - x : (x > x2 ? x - x2 : 0)) + (y < y1 ? y1 - y : (y > y2 ? y - y2 : 0));
    }

    void query1(int k, point x) {
        if (!k) return;
        if (p(k) != x) now1 = min(now1, dis1(x.x[0], x.x[1], p(k).x[0], p(k).x[1], p(k).x[0], p(k).x[1]));
        int dl = ls(k) ? dis1(x.x[0], x.x[1], t[ls(k)].mi[0], t[ls(k)].mi[1], t[ls(k)].mx[0], t[ls(k)].mx[1]) : INF,
            dr = rs(k) ? dis1(x.x[0], x.x[1], t[rs(k)].mi[0], t[rs(k)].mi[1], t[rs(k)].mx[0], t[rs(k)].mx[1]) : INF;
        if (dl <= dr) {
            query1(ls(k), x);
            query1(rs(k), x);
        } else {
            query1(rs(k), x);
            query1(ls(k), x);
        }
    }
    ```
* **代码解读**：
  `dis1`函数计算当前点到子树的最小可能距离（估价函数），若该距离大于当前最近距离，则剪枝。`query1`函数递归查询，优先处理更优子树（估价更小的子树），减少无效搜索。
* 💡 **学习笔记**：剪枝是K-D Tree高效的关键，通过估价函数提前排除不可能包含更优解的子树。

**题解二：revenger的线段树实现（来源：用户revenger）**
* **亮点**：使用zkw线段树（非递归实现），支持快速区间最值查询。
* **核心代码片段**：
    ```cpp
    void change(int x, int m1, int m2) {
        x += m;
        tree[x][1] = min(tree[x][1], m1);
        tree[x][2] = max(tree[x][2], m1);
        tree[x][3] = min(tree[x][3], m2);
        tree[x][4] = max(tree[x][4], m2);
        x >>= 1;
        while (x) {
            tree[x][1] = min(tree[x << 1][1], tree[x << 1 | 1][1]);
            tree[x][2] = max(tree[x << 1][2], tree[x << 1 | 1][2]);
            tree[x][3] = min(tree[x << 1][3], tree[x << 1 | 1][3]);
            tree[x][4] = max(tree[x << 1][4], tree[x << 1 | 1][4]);
            x >>= 1;
        }
    }

    int ask(int l, int r, int nm) {
        int ans = nm % 2 ? inf : -inf;
        for (l += m - 1, r += m + 1; l ^ r ^ 1; l >>= 1, r >>= 1) {
            if (~l & 1) ans = nm % 2 ? min(ans, tree[l ^ 1][nm]) : max(ans, tree[l ^ 1][nm]);
            if (r & 1) ans = nm % 2 ? min(ans, tree[r ^ 1][nm]) : max(ans, tree[r ^ 1][nm]);
        }
        return ans;
    }
    ```
* **代码解读**：
  `change`函数更新线段树节点的最值，`ask`函数查询区间最值。zkw线段树通过位运算实现非递归操作，比传统递归线段树更快。
* 💡 **学习笔记**：zkw线段树适合需要高效区间最值查询的场景，代码简洁且常数小。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

\<visualization_intro\>
为了直观理解K-D Tree的查询过程，我们设计一个“像素迷宫探险”主题的动画，用8位像素风格展示树的构建和查询。
\</visualization_intro\>

  * **动画演示主题**：`像素探险家的距离挑战`

  * **核心演示内容**：
    K-D Tree的构建（按x/y交替划分平面）、最近距离查询（探险家寻找最近的宝藏）、最远距离查询（探险家寻找最远的宝藏）。

  * **设计思路简述**：
    采用FC红白机风格，用不同颜色区分点（如红色为当前查询点，蓝色为其他点）。K-D Tree的划分边界用虚线表示，每次查询时高亮当前处理的节点，剪枝的子树半透明。音效方面，找到更近/更远点时播放“叮”声，完成查询时播放胜利音效。

  * **动画帧步骤与交互关键点**：
    1. **场景初始化**：
       - 屏幕左侧显示像素网格（16色，8x8像素点），右侧显示控制面板（单步/自动/重置按钮，速度滑块）。
       - 背景音乐为8位风格的轻快旋律。

    2. **K-D Tree构建**：
       - 按x坐标排序，递归划分平面（垂直虚线）；再按y坐标划分（水平虚线），形成树状结构。
       - 每个节点显示其代表的点（大像素块）和区间边界（虚线框）。

    3. **最近距离查询**：
       - 当前查询点（红色）高亮，初始最近距离设为无穷大。
       - 从根节点开始，计算当前节点到查询点的距离（更新数值显示），若更小则更新最近距离（数值变色+“叮”声）。
       - 计算左右子树的最小可能距离（估价函数），优先查询估价更小的子树（子树区域闪烁）。
       - 剪枝的子树变为半透明，提示无需搜索。

    4. **最远距离查询**：
       - 类似最近查询，但优先查询估价更大的子树，更新最远距离（数值变色+“咚”声）。

    5. **结果展示**：
       - 所有点查询完成后，显示最小差值（绿色高亮），播放胜利音效（上扬音调）。

  * **旁白提示**：
    - “当前处理的是x方向划分的节点，它的左子树包含x更小的点！”
    - “左子树的最小可能距离是5，比当前最近距离大，无需搜索！”
    - “找到更近的点了！最近距离更新为3，听~这是成功的‘叮’声！”

\<visualization_conclusion\>
通过这样的动画，我们能直观看到K-D Tree如何通过空间划分和剪枝高效完成查询，理解其时间复杂度优化的核心。
\</visualization_conclusion\>

---

## 6\. 拓展练习与相似问题思考

\<similar_problems_intro\>
本题的核心算法（K-D Tree、线段树处理曼哈顿距离）可迁移至多种几何问题。
\</similar_problems_intro\>

  * **通用思路/技巧迁移**：
    - K-D Tree适用于多维空间的最近邻、范围查询（如图片检索、地理信息系统）。
    - 曼哈顿距离的变形（如切比雪夫距离）可通过坐标变换（\( (x,y) \to (x+y, x-y) \)）转化为曼哈顿距离问题。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P6247 [SHOI2002] 滑雪者**  
       🗣️ **推荐理由**：考察K-D Tree的最近邻查询，与本题思路相似。
    2.  **洛谷 P3143 [USACO16OPEN] 关闭农场 Closing the Farm**  
       🗣️ **推荐理由**：动态K-D Tree的应用，需处理点的删除操作，提升对数据结构的理解。
    3.  **洛谷 P2574 XOR的艺术**  
       🗣️ **推荐理由**：线段树的区间更新与查询，巩固线段树的核心操作。

---

## 7\. 学习心得与经验分享 (若有)

\<insights_intro\>
部分题解作者分享了调试经验，例如：
\</insights_intro\>

> **参考经验 (来自用户Orina_zju)**：“在处理最近距离时，容易忘记排除自身点，导致结果错误。通过打印中间变量（如当前查询点的距离），发现了这一问题。”

> **点评**：这位作者的经验提醒我们，在几何问题中需特别注意边界条件（如自身点的排除）。调试时打印关键变量（如当前距离、估价函数值）是定位错误的有效方法。

-----

\<conclusion\>
本次关于“[SDOI2010] 捉迷藏”的分析就到这里。希望大家通过本指南掌握K-D Tree、线段树等数据结构的应用，以及曼哈顿距离的处理技巧。编程的关键在于多实践、多总结，期待大家在后续练习中更上一层楼！💪
\</conclusion\>

---
处理用时：210.66秒
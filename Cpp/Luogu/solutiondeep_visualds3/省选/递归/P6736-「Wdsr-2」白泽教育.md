# 题目信息

# 「Wdsr-2」白泽教育

## 题目背景

上白泽慧音在给雾之湖的妖精们讲课。

某天，慧音在上数学课时，提到了一种非常有趣的记号：**高德纳箭号表示法**。它可以用来描述非常巨大的数字。~~比如紫的年龄。~~

对于非负整数 $a, b$ 和正整数 $n$，高德纳箭号表示法的定义为：

$$a \uparrow^n b = \begin{cases}
1\ (b = 0) \\
a^b\ (n = 1\ \operatorname{and}\ b > 0) \\
a \uparrow^{n - 1} (a \uparrow^n (b - 1))\ (n > 1\ \operatorname{and}\ b > 0)
\end{cases}$$

一些简单的例子：

- $2 \uparrow 31 = 2^{31} = 2147483648$

- $2 \uparrow \uparrow 4 = 2^{2^{2^2}} = 2^{2^4} = 2^{16} = 65536$

注：
1. $a \uparrow b$ 与 $a \uparrow^1 b$ 相同；

2. $a \uparrow \uparrow b$ 与 $a \uparrow^2 b$ 相同；

3. 请注意幂运算的顺序。

## 题目描述

慧音希望琪露诺解决以下关于 $x$ 的方程：

$$a \uparrow^n x \equiv b \pmod p$$

其中，$a, n, b, p$ 为已知的常数，$x$ 为未知数。

琪露诺被高德纳箭号表示法搞得云里雾里的，但是她不想被头槌。你能帮帮她吗？

## 说明/提示

**本题开启捆绑测试。**

| Subtask | $n$ | $p$ | $T$ | 分值 | 时限 |
| :------: | :------: | :------: | :------: | :------: | :------: |
| $1$ | $n = 1$ | $2 \leq p \leq 10^9$ 且 $p$ 为质数 | $1 \leq T \leq 100$ | $15 \operatorname{pts}$ | $2.00 \operatorname{s}$ |
| $2$ | $n = 2$ | 无特殊限制 | $1 \leq T \leq 5 \times 10^3$ | $25 \operatorname{pts}$ | $1.00 \operatorname{s}$ |
| $3$ | $n = 3$ | 无特殊限制 | 无特殊限制 | $60 \operatorname{pts}$ | $2.00 \operatorname{s}$ |

对于 $100\%$ 的数据，$1 \leq a \leq 10^9$，$1 \leq n \leq 3$，$0 \leq b < p \leq 10^9$，$1 \leq T \leq 2 \times 10^4$。

## 样例 #1

### 输入

```
3
2 1 1 3
3 1 2 7
7 1 2 4```

### 输出

```
0
2
-1```

## 样例 #2

### 输入

```
3
2 2 4 7
3 2 4 6
5 2 1 3```

### 输出

```
2
-1
0```

## 样例 #3

### 输入

```
3
4 3 5 8
2 3 9 11
6 3 1 5```

### 输出

```
-1
3
0```

# AI分析结果



---
# 💡 Kay的C++算法解析：「Wdsr-2」白泽教育 深入学习指南 💡

<introduction>
今天我们来一起分析“「Wdsr-2」白泽教育”这道C++编程题。这道题涉及高德纳箭号表示法的模方程求解，需要结合数论中的BSGS算法、扩展欧拉定理等知识。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（数论应用，涉及BSGS、扩展欧拉定理、幂塔递归计算）

🗣️ **初步分析**：
解决“「Wdsr-2」白泽教育”的关键在于根据高德纳箭号的不同阶数（n=1,2,3），分别设计对应的数论解法。高德纳箭号表示法可以理解为“多层幂次的嵌套”，例如n=1是普通幂（\(a^x\)），n=2是幂塔（\(a^{a^{...^a}}\)），n=3是超幂塔（\(a \uparrow\uparrow (a \uparrow^3 (x-1))\)）。

- **题解思路**：  
  - n=1时，问题转化为离散对数问题（\(a^x \equiv b \mod p\)），用BSGS算法求解；  
  - n=2时，幂塔的模值可通过扩展欧拉定理递归计算（每一层模数取欧拉函数值），枚举x的可能值；  
  - n=3时，超幂塔增长极快，利用欧拉函数的快速衰减特性（迭代O(log p)次后模数变为1），枚举小范围x值即可。  

- **核心算法流程**：  
  BSGS通过分块预处理和哈希表快速查找离散对数；扩展欧拉定理用于处理幂塔的模运算（判断幂次是否超过当前模数的欧拉函数值）；递归计算幂塔时，每一层模数取前一层的欧拉函数，直到模数为1。  

- **可视化设计**：  
  采用8位像素风动画，模拟BSGS的“分块跳跃”过程（用不同颜色的方块表示预处理的块和跳跃的步长）；幂塔计算用堆叠的像素块表示层数，每一层模数变化时用箭头标注，关键步骤（如判断幂次是否超过φ(p)）用闪烁提示，配合“叮”的音效强化记忆。

---

## 2. 精选优质题解参考

<eval_intro>
通过对题解的思路清晰度、代码规范性、算法有效性等维度评估，以下3篇题解（≥4星）值得重点参考：
</eval_intro>

**题解一：Leasier (赞：9)**  
* **点评**：此题解逻辑完整，覆盖所有子任务，代码注释详细。在n=2时，用结构体`Node`记录幂次是否超过模数的欧拉函数值，解决了扩展欧拉定理的边界判断问题；n=3时递归计算超幂塔，结合欧拉函数迭代的上界优化枚举范围。代码风格规范（如`tetration`函数名明确），关键变量（如`phi`数组存储欧拉函数值）命名清晰，实践价值高（可直接用于竞赛）。

**题解二：LightningUZ (赞：5)**  
* **点评**：此题解注重细节处理（如特判a=2的情况），代码模块化强（`ptower`函数封装幂塔计算）。在BSGS中使用哈希表优化查找，时间复杂度更优；对扩展欧拉定理的反例（如mod=2,4,6时a=2的情况）进行了验证，确保算法鲁棒性。实践中提到“读入的a不能先模p”等调试经验，对学习者有直接帮助。

**题解三：_Fontainebleau_ (赞：4)**  
* **点评**：此题解对欧拉函数的迭代过程进行了数学证明（最多O(log p)次迭代到1），理论支撑充分。代码中预筛欧拉函数表（`sieve`函数）优化计算，幂塔递归（`ptower`函数）逻辑简洁。对n=3的处理（特判a≥3时仅需计算x=2、3的情况）体现了对问题本质的深刻理解，代码效率高。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决本题时，常见的核心难点及应对策略如下：
</difficulty_intro>

1.  **关键点1：BSGS算法的正确实现（n=1）**  
    * **分析**：BSGS的核心是分块预处理和哈希表查找，但需注意边界条件（如b=1时x=0）、模数p=1的特殊情况，以及a和p不互质时的处理（本题中p为质数时无需考虑，但通用情况需扩展BSGS）。  
    * 💡 **学习笔记**：BSGS的关键是平衡预处理块数（取√p），确保时间复杂度最优；使用哈希表存储预处理结果时，需注意重复值的覆盖问题（通常保留最小的索引）。

2.  **关键点2：扩展欧拉定理的边界判断（n=2）**  
    * **分析**：计算幂塔 \(a^{a^{...^a}} \mod p\) 时，每一层幂次需判断是否超过当前模数的欧拉函数值（φ(p)）。若超过，则幂次取模φ(p)后加φ(p)；否则直接取幂次。这需要用结构体或元组同时记录幂次的模值和是否超过的标志（如题解中的`Node`结构体）。  
    * 💡 **学习笔记**：扩展欧拉定理的条件是a和模数互质，若不互质需额外处理（如本题中p为任意数时，需结合中国剩余定理）。

3.  **关键点3：超幂塔的递归计算上界（n=3）**  
    * **分析**：超幂塔 \(a \uparrow^3 x\) 增长极快，直接计算不现实。但欧拉函数迭代O(log p)次后变为1，因此只需枚举x的小范围值（如x≤4）。对于a≥3的情况，超幂塔的层数远超过O(log p)，因此x≥3时结果与x=3相同。  
    * 💡 **学习笔记**：处理极大数的模运算时，关键是找到其“稳定点”（即后续值不再变化的最小x），通过数学分析缩小枚举范围。

### ✨ 解题技巧总结
- **问题分层拆解**：根据n的不同（1、2、3），将问题分解为离散对数、幂塔、超幂塔三类子问题，分别设计算法。  
- **预处理优化**：预计算欧拉函数值（如`phi`数组），避免重复计算，提升效率。  
- **特判边界条件**：如a=1、b=1、p=1等特殊情况，直接返回结果，减少计算量。  
- **标志位记录**：在幂塔计算中，用标志位记录幂次是否超过当前模数的欧拉函数值，确保扩展欧拉定理的正确应用。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合优质题解的通用核心C++实现，覆盖所有子任务，逻辑清晰且效率较高。
</code_intro_overall>

**本题通用核心C++实现参考**  
* **说明**：本代码综合了Leasier和LightningUZ的题解思路，优化了欧拉函数计算和幂塔递归逻辑，适用于所有子任务。  
* **完整核心代码**：
```cpp
#include <iostream>
#include <map>
#include <cmath>
#include <unordered_map>
using namespace std;
typedef long long ll;

struct Node { ll val; bool over; };

ll euler(ll n) {
    ll res = n;
    for (ll i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            res -= res / i;
            while (n % i == 0) n /= i;
        }
    }
    if (n > 1) res -= res / n;
    return res;
}

Node qpow(ll a, ll b, ll mod) {
    ll res = 1; bool over = false;
    if (a >= mod) { over = true; a %= mod; }
    while (b) {
        if (b & 1) {
            res *= a;
            if (res >= mod) { over = true; res %= mod; }
        }
        a *= a;
        if (a >= mod) { over = true; a %= mod; }
        b >>= 1;
    }
    return {res, over};
}

ll bsgs(ll a, ll b, ll p) {
    a %= p; b %= p;
    if (b == 1 || p == 1) return 0;
    ll m = ceil(sqrt(p)), t = 1;
    unordered_map<ll, ll> mp;
    for (ll i = 0; i < m; ++i) {
        if (!mp.count(t * b % p)) mp[t * b % p] = i;
        t = t * a % p;
    }
    ll am = 1;
    for (ll i = 0; i < m; ++i) am = am * t % p;
    for (ll i = 1; i <= m; ++i) {
        if (mp.count(am)) return i * m - mp[am];
        am = am * t % p;
    }
    return -1;
}

Node tetration(ll a, ll n, ll mod, ll* phi, int idx) {
    if (mod == 1) return {0, true};
    if (n == 0) return {1, false};
    Node next = tetration(a, n - 1, phi[idx + 1], phi, idx + 1);
    if (next.over) next.val += phi[idx + 1];
    return qpow(a, next.val, mod);
}

int main() {
    int T; cin >> T;
    while (T--) {
        ll a, n, b, p; cin >> a >> n >> b >> p;
        if (n == 1) {
            cout << bsgs(a, b, p) << endl;
            continue;
        }
        ll phi[20], tot = 0;
        phi[tot++] = p;
        while (phi[tot - 1] != 1) phi[tot++] = euler(phi[tot - 1]);
        if (n == 2) {
            ll ans = -1;
            for (ll x = 0; x <= tot; ++x) {
                Node res = tetration(a, x, p, phi, 0);
                if (res.val % p == b) { ans = x; break; }
            }
            cout << ans << endl;
        } else if (n == 3) {
            if (a == 1) { cout << -1 << endl; continue; }
            if (b == a % p) { cout << 1 << endl; continue; }
            Node res2 = tetration(a, a, p, phi, 0);
            if (res2.val % p == b) { cout << 2 << endl; continue; }
            Node res3 = tetration(a, 100, p, phi, 0);
            if (res3.val % p == b) { cout << 3 << endl; continue; }
            cout << -1 << endl;
        }
    }
    return 0;
}
```
* **代码解读概要**：  
  代码首先处理n=1的情况，调用`bsgs`函数求解离散对数；n=2时预计算欧拉函数数组`phi`，枚举x并调用`tetration`递归计算幂塔模值；n=3时特判a≥3的情况，仅枚举x=1、2、3即可。`tetration`函数通过递归和标志位`over`实现扩展欧拉定理的应用，确保幂次计算的正确性。

---
<code_intro_selected>
接下来，我们剖析优质题解的核心代码片段，理解其亮点和关键逻辑。
</code_intro_selected>

**题解一：Leasier**  
* **亮点**：用`Node`结构体记录幂次的模值和是否超过标志，解决扩展欧拉定理的边界判断问题。  
* **核心代码片段**：
```cpp
typedef struct {
    ll val;
    bool flag;
} Node;

Node tetration(int a, int n, int index) {
    if (phi[index] == 1) return new_node(0, true);
    if (n == 0) return new_node(1, false);
    int next_index = index + 1;
    Node x = tetration(a, n - 1, next_index);
    if (x.flag) x.val += phi[next_index];
    return quick_pow(a, x.val, phi[index]);
}
```
* **代码解读**：  
  `tetration`函数递归计算幂塔的模值。`index`表示当前模数在`phi`数组中的位置（`phi[index]`为当前模数，`phi[index+1]`为其欧拉函数值）。递归终止条件是模数为1（返回0，标志为true）或层数n=0（返回1，标志为false）。上一层的结果若超过欧拉函数值（`x.flag`为true），则当前幂次需加欧拉函数值（`x.val += phi[next_index]`），确保扩展欧拉定理的正确应用。  
* 💡 **学习笔记**：递归计算幂塔时，每一层的模数和欧拉函数值需严格对应，标志位`flag`是处理扩展欧拉定理的关键。

**题解二：LightningUZ**  
* **亮点**：BSGS中使用`unordered_map`优化查找，时间复杂度更优；预筛欧拉函数表提升计算效率。  
* **核心代码片段**：
```cpp
int BSGS(int a, int b, int p) {
    rec.clear();
    int sn = sqrt(p) + 1;
    int pw = 1;
    F(i, 0, sn - 1) {
        rec[pw] = i;
        pw = (pw * a) % p;
    }
    if (rec.count(b)) { return rec[b]; }
    int a_sn = pw;
    F(i, 1, sn) {
        int iv = qpow(pw, p - 2, p);
        int tmp = b * iv % p; 
        if (rec.count(tmp)) {
            return rec[tmp] + i * sn;
        }
        pw = pw * a_sn % p;
    }
    return -1;
}
```
* **代码解读**：  
  BSGS算法的分块预处理阶段（`sn=√p`），预处理所有可能的`b*a^i mod p`并存入哈希表；然后计算`a^sn mod p`，枚举块数i，查找是否存在匹配的`a^{i*sn} ≡ b*a^j mod p`，返回解`i*sn - j`。使用`unordered_map`存储预处理结果，查找时间为O(1)，整体复杂度O(√p)。  
* 💡 **学习笔记**：BSGS的分块大小取√p可平衡预处理和枚举的时间，哈希表的查找效率直接影响算法性能。

**题解三：_Fontainebleau_**  
* **亮点**：预筛欧拉函数表（`sieve`函数）优化欧拉函数计算，适用于多次查询。  
* **核心代码片段**：
```cpp
void sieve(int n) {
    phi[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (!used[i]) prime[++cnt] = i, phi[i] = i - 1;
        for (int j = 1; j <= cnt && i * prime[j] <= n; ++j) {
            used[i * prime[j]] = 1;
            phi[i * prime[j]] = phi[i] * (prime[j] - 1);
            if (i % prime[j] == 0) {
                phi[i * prime[j]] = phi[i] * prime[j];
                break;
            }
        }
    }
}
```
* **代码解读**：  
  线性筛法同时计算欧拉函数值。对于质数i，`phi[i]=i-1`；对于合数i*prime[j]，若i是prime[j]的倍数，则`phi[i*prime[j]]=phi[i]*prime[j]`（否则为`phi[i]*(prime[j]-1)`）。预筛后，欧拉函数的查询时间为O(1)，适合多次调用的场景。  
* 💡 **学习笔记**：预筛欧拉函数表是处理多次欧拉函数查询的高效方法，尤其在p较大时（如1e9），需结合试除法计算欧拉函数。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解BSGS和幂塔计算的过程，我们设计一个“像素数论探险”动画，用8位像素风格演示算法步骤！
</visualization_intro>

  * **动画演示主题**：像素数论探险——解高德纳箭号方程  
  * **核心演示内容**：  
    - BSGS的“分块跳跃”过程：预处理块和跳跃步长的匹配。  
    - 幂塔的递归计算：层数堆叠、模数变化（p→φ(p)→φ(φ(p))→…→1）。  
  * **设计思路简述**：  
    采用FC红白机风格，用不同颜色的像素块表示预处理的块（蓝色）和跳跃的步长（红色）；幂塔用堆叠的黄色块表示层数，模数变化时用箭头标注（绿色）。关键步骤（如找到BSGS匹配、幂次超过φ(p)）用闪烁和“叮”音效提示，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：  
        - 屏幕分为左右两部分：左半部分为“BSGS探险区”（网格表示模数p），右半部分为“幂塔计算区”（堆叠的像素块表示层数）。  
        - 控制面板：单步/自动播放按钮、速度滑块（1x-5x）、重置按钮。  
        - 背景播放8位风格的轻快BGM。

    2.  **BSGS算法演示（n=1）**：  
        - 输入a, b, p后，计算块大小m=√p，生成m个蓝色像素块（预处理块），每个块标注`b*a^i mod p`的值。  
        - 计算`a^m mod p`，生成红色跳跃块，从1开始逐步计算`a^{i*m} mod p`。  
        - 当红色块的值与蓝色块匹配时，高亮匹配位置，播放“叮”音效，显示解x=i*m - j。

    3.  **幂塔计算演示（n=2）**：  
        - 输入a, p后，计算欧拉函数链p→φ(p)→…→1，用绿色箭头连接每个模数（显示在右半区顶部）。  
        - 枚举x=0,1,2,…，每增加一层x，堆叠一个黄色像素块（高度代表层数）。  
        - 递归计算每一层的幂次时，若幂次超过当前模数的欧拉函数值，黄色块闪烁并标注“over”；否则正常显示。  
        - 最终计算结果与b模p匹配时，黄色块变为绿色，播放“胜利”音效。

    4.  **交互与控制**：  
        - 单步执行：点击“下一步”逐步查看预处理、跳跃或递归过程。  
        - 自动播放：选择速度后，算法自动执行，学习者可观察整体流程。  
        - 错误提示：若无解，红色块闪烁并播放“失败”音效，显示“-1”。

  * **旁白提示**：  
    - （BSGS预处理时）“看！蓝色块是预处理的`b*a^i mod p`值，每个块对应一个i哦~”  
    - （幂塔递归时）“黄色块的高度是幂塔的层数，当它超过当前模数的欧拉函数值时，需要加φ(p)再取模~”  
    - （找到解时）“叮！匹配成功！解是x=i*m - j，快记下来~”

<visualization_conclusion>
通过这个像素动画，我们能直观看到BSGS的分块匹配和幂塔的递归计算过程，理解数论算法的“数学魔法”！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心算法（BSGS、扩展欧拉定理、幂塔递归）在数论中应用广泛，以下是相关拓展练习：
</similar_problems_intro>

  * **通用思路/技巧迁移**：  
    - BSGS可用于求解离散对数问题（如求解\(a^x \equiv b \mod p\)）。  
    - 扩展欧拉定理可处理大指数的模运算（如幂塔、超幂塔的模值计算）。  
    - 欧拉函数的迭代特性（快速衰减到1）可用于优化极大数的模运算（如P3747“相逢是问候”）。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3846 [TJOI2007] 可爱的质数**  
        * 🗣️ **推荐理由**：直接考察BSGS算法，适合巩固离散对数的求解方法。  
    2.  **洛谷 P3747 [六省联考2017] 相逢是问候**  
        * 🗣️ **推荐理由**：涉及欧拉函数的迭代和幂塔模运算，与本题n=2的场景高度相关，可深入理解扩展欧拉定理的应用。  
    3.  **洛谷 P5399 [Ynoi2018] 制胡串**  
        * 🗣️ **推荐理由**：结合BSGS和哈希表，挑战复杂数论问题的综合解法。  

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
部分题解提到了调试中的经验，对学习者有重要参考价值：
</insights_intro>

> **参考经验 (来自 LightningUZ)**：“读入的a千万不要先模p，因为算幂塔时，上面模的可不是p，是φ(p)。”  
> **点评**：这一经验提醒我们，幂塔的每一层模数是前一层的欧拉函数值，而非原始模数p。若提前对a取模，可能导致上层幂次计算错误。在处理嵌套模运算时，必须严格区分每一层的模数，避免因预处理错误导致结果偏差。

-----

<conclusion>
本次关于“「Wdsr-2」白泽教育”的C++解题分析就到这里。通过理解BSGS、扩展欧拉定理和幂塔递归的核心逻辑，结合可视化动画和拓展练习，相信大家能更好地掌握数论问题的解题技巧。记住，多动手调试、多思考边界条件，是提升编程能力的关键！下次再见~ 💪
</conclusion>

-----

---
处理用时：196.82秒
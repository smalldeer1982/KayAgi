# 题目信息

# 评分系统

## 题目背景

答疑请到：https://www.luogu.org/discuss/show?postid=79498

由于时限等问题，请大家重交一遍这道题

本题时限开至2s

样例：https://files.cnblogs.com/files/ztz11/yl.rar

---

众所周知，luogu 有题目难度的评分系统，用户在通过题目后可以选择题目难度以及算法标签，来完善 luogu 的题库。

![](https://cdn.luogu.com.cn/upload/pic/40327.png)

（原注：以下内容非真实评分数据，纯属作者编造，仅供娱乐使用。）

## 题目描述

Menteur-Hxy 同学很不老实，为了实现 NOIp 前 AC $100$ 道黑题的目标，他决定雇佣一些水军，最少雇佣 $1$ 个水军。

每个水军都有一个能力值 $x_i$，表示该水军可以解决难度最高为 $x_i$ 的题目。这些水军十分尽职尽责，在通过这道题目后都会给题目评最高难度。当然，luogu 的正常用户也会做题，他们会正常地评分。现在，我们给你所有水军的能力值以及每道题正常用户的评分记录，请你求出有多少种选择水军的方案，可以使这道题的评分变为黑题。因为答案可能过大，最终请输出答案数 $\bmod p$ 的值。

评分计算公式：去掉一个最高分，去掉一个最低分后求平均分。

**【表一：投票信息】**

| 投票编号 | 对应难度 | 分数贡献 |
| :------: | :------: | :------: |
| $1$ | 入门 | $1$ |
| $2$ | 普及- | $10$ |
| $3$ | 普及/提高- | $15$ |
| $4$ | 普及+/提高 | $25$ |
| $5$ | 提高+/省选- | $40$ |
| $6$ | 省选/NOI- | $55$ |
| $7$ | NOI | $75$ |
| $8$ | NOI+/CTSC | $100$ |

**【表二：难度规则】**

| 难度等级 | 对应颜色 | 对应分数 |
| :------: | :------: | :------: |
| 入门 | 红 | $1\sim 5$ |
| 普及- | 橙 | $6\sim 12$ |
| 普及/提高- | 黄 | $13\sim 20$ |
| 普及+/提高 | 绿 | $21\sim 35$ |
| 提高+/省选- | 蓝 | $36\sim 45$ |
| 省选/NOI- | 紫 | $46\sim 70$ |
| NOI+/CTSC | 黑 | $71\sim 100$ |

## 说明/提示

**【样例解释 $1$】**

luogu 用户评分和为 $25+40+55+75+100=295$，弃掉一个最低分后为 $270$，这时 Menteur-Hxy 雇佣两个及以上水军就可以达到目的。

因为可以通过本题的水军共有 $4$ 个，所以选择方案共有：

$$\{1,2\}\{1,2,3\}\{1,2,3,4\}\{1,2,4\}\{1,3\}\{1,3,4\}\{1,4\}\{2,3\}\{2,3,4\}\{2,4\}\{3,4\}$$

共 $11$ 种，对 $9$ 取余后结果为 $2$。

**【数据规模与约定】**

对于 $30\%$ 的数据，$n, m \leq 50$。

对于另外 $20\%$ 的数据，$p$ 为质数。

对于 $100\%$ 的数据，$1 \leq n, m, k,s_i \leq 10^5, 1 \leq t \leq 5, 2 \leq p \leq 3 \times 10^3, 1 \leq t_i \leq 8$。

保证合格水军的数量与需要的最少水军数量之差不超过 $5000$。

（原注：本题可能轻微卡常。感谢 @Ghostcai ，@Swhsz 帮忙验题。）

## 样例 #1

### 输入

```
1
5 5 9
1 2 3 4 5
4 5 6 7 8
2```

### 输出

```
2```

## 样例 #2

### 输入

```
5
20 10 1329
540 499 490 419 308 261 323 476 476 374 23 13 14 16 19 34 43 19 27 32 
8 8 8 8 8 7 7 7 7 7 
50
20 10 1800
74 434 97 134 283 118 234 498 328 388 29 48 48 43 23 42 31 16 20 26 
8 8 7 6 8 8 8 7 7 7 
50
20 10 2704
142 378 330 281 377 64 340 309 466 289 34 37 19 17 20 48 21 28 38 15 
6 8 6 6 8 7 7 7 7 6 
50
20 10 72
365 356 456 479 459 222 548 377 212 223 38 20 49 18 49 38 31 48 41 17 
6 8 7 6 8 7 8 8 8 6 
50
20 10 1416
367 191 403 298 445 464 79 467 431 362 10 45 48 37 46 43 11 35 30 39 
8 6 8 7 7 7 8 8 7 8 
50```

### 输出

```
1023
1023
1023
15
1023```

# AI分析结果



---
# 💡 Kay的C++算法解析：评分系统 深入学习指南 💡

<introduction>
今天我们来一起分析“评分系统”这道C++编程题。这道题需要我们计算选择水军的方案数，使得题目最终被评为黑题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（组合数模运算、数论）

🗣️ **初步分析**：
解决“评分系统”的关键在于两步：首先计算最少需要雇佣的水军数量，然后计算从合格水军中选择至少该数量的方案数之和（组合数求和）。这里的核心挑战是处理大数组合数的模运算，特别是当模数 \( p \) 不是质数时，需要用到扩展卢卡斯（exLucas）定理。

简单来说，组合数 \( C(n, k) \) 表示从 \( n \) 个元素中选 \( k \) 个的方案数。但当 \( n \) 和 \( k \) 很大时，直接计算会溢出，因此需要模运算。如果 \( p \) 是质数，可用卢卡斯定理（Lucas）将大数分解为 \( p \) 进制下的子问题；若 \( p \) 不是质数，则需用扩展卢卡斯（exLucas）处理 \( p \) 的质因数分解。

- **题解思路对比**：两个题解均先推导最少水军数 \( x \)，再计算 \( \sum_{i=x}^{cnt} C(cnt, i) \mod p \)（\( cnt \) 为合格水军数）。ztz11的代码更全面，实现了完整的exLucas；WhitD的代码更简洁，区分了 \( p \) 是否为质数的情况。
- **核心算法流程**：先通过用户评分计算 \( x \)（最少水军数），再统计合格水军数 \( cnt \)，最后用组合数求和得到答案。可视化时需重点展示 \( x \) 的推导过程、\( cnt \) 的筛选逻辑，以及组合数求和的模运算步骤。
- **可视化设计**：采用8位像素风格，用“水军雇佣模拟器”场景。例如，用绿色像素块表示合格水军，红色表示不合格；计算 \( x \) 时用动态文字气泡展示公式推导；组合数求和时用堆叠的像素方块表示 \( C(cnt, i) \)，每增加一个 \( i \) 就叠加一层，伴随“叮”的音效。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性和实践价值，以下两个题解均达到4星以上，值得参考：
</eval_intro>

**题解一：作者 ztz11**
* **点评**：此题解逻辑完整，代码规范。亮点在于完整实现了扩展卢卡斯（exLucas）算法，处理了 \( p \) 非质数的复杂情况。代码中变量命名如 `n1`（水军总数）、`cnt`（合格水军数）含义明确；`solve` 函数结构清晰，先排序筛选合格水军，再计算最少水军数 \( x \)，最后求和。实践价值高，适合竞赛场景。

**题解二：作者 WhitD**
* **点评**：此题解思路简洁，代码精炼。亮点在于通过 `_ceil` 函数直接计算最少水军数 \( x \)，并区分 \( p \) 是否为质数选择卢卡斯（Lucas）或扩展卢卡斯（exLucas），避免了不必要的计算。代码中使用 `inline` 优化函数调用，提升效率，适合学习组合数模运算的基础实现。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决此题的关键在于处理两个核心难点，结合优质题解的共性，我们逐一分析：
</difficulty_intro>

1.  **关键点1：如何推导最少需要的水军数 \( x \)**
    * **分析**：评分要求为去掉一个最高/最低分后的平均分 ≥71。设正常用户评分总和为 `sum`，最低分为 `min`，水军人数为 \( x \)（每人贡献100分），则总有效分为 \( sum - min + 100(x-1) \)（去掉一个最高分100），总人数为 \( (m-1) + (x-1) \)（去掉一个最低分和一个最高分）。化简得 \( x \geq \frac{71m - sum + min -42}{29} \)，向上取整后与1取最大（避免负数）。
    * 💡 **学习笔记**：公式推导需紧扣评分规则，注意“去掉两个分数”的条件。

2.  **关键点2：如何高效计算组合数模 \( p \)**
    * **分析**：当 \( p \) 是质数时，用卢卡斯定理（Lucas）将 \( C(n, k) \) 分解为 \( p \) 进制下的子问题；当 \( p \) 非质数时，用扩展卢卡斯（exLucas）分解 \( p \) 的质因数，分别计算后用中国剩余定理合并。优质题解均正确实现了这两种情况。
    * 💡 **学习笔记**：模运算需根据 \( p \) 的性质选择算法，避免直接计算大数组合数。

3.  **关键点3：如何筛选合格水军**
    * **分析**：合格水军的能力值需 ≥ 题目要求的难度 \( z \)。通过排序后二分查找，统计能力值 ≥ \( z \) 的水军数量 \( cnt \)。题解中通过排序和遍历实现，简洁高效。
    * 💡 **学习笔记**：排序后遍历可快速筛选合格水军，时间复杂度 \( O(n \log n) \)。

### ✨ 解题技巧总结
- **问题分解**：将问题拆分为“计算最少水军数”和“组合数求和”两部分，降低复杂度。
- **数论应用**：根据 \( p \) 的性质选择卢卡斯或扩展卢卡斯，避免大数运算。
- **边界处理**：注意 \( x \) 的最小为1，\( cnt \) 可能为0（此时无解）。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下是综合两个优质题解的通用核心实现，兼顾清晰性和效率：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了ztz11和WhitD的思路，重点实现最少水军数计算和组合数求和，适用于竞赛场景。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <algorithm>
    #include <vector>
    using namespace std;

    int score[] = {0, 1, 10, 15, 25, 40, 55, 75, 100};

    // 快速幂取模
    int qkpow(int a, int b, int p) {
        int res = 1;
        while (b) {
            if (b & 1) res = 1LL * res * a % p;
            a = 1LL * a * a % p;
            b >>= 1;
        }
        return res;
    }

    // 扩展欧几里得求逆元
    int inv(int a, int p) {
        int x, y, g = __gcd(a, p);
        if (g != 1) return -1; // 无逆元（本题p≥2，无需处理）
        __exgcd(a, p, x, y);
        return (x % p + p) % p;
    }

    // 卢卡斯定理（p为质数）
    int lucas(int n, int k, int p) {
        if (k == 0) return 1;
        int a = n % p, b = k % p;
        if (b > a) return 0;
        int res = 1;
        for (int i = 1; i <= b; ++i)
            res = 1LL * res * (a - i + 1) % p * inv(i, p) % p;
        return 1LL * res * lucas(n / p, k / p, p) % p;
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(0);
        int T; cin >> T;
        while (T--) {
            int n, m, p; cin >> n >> m >> p;
            vector<int> s(n);
            for (int i = 0; i < n; ++i) cin >> s[i];
            int sum = 0, mn = 100;
            for (int i = 0; i < m; ++i) {
                int t; cin >> t;
                sum += score[t];
                mn = min(mn, score[t]);
            }
            sum -= mn; // 去掉最低分
            int x = max(1, (71 * m - sum - 42 + 28) / 29); // 向上取整

            int k; cin >> k;
            sort(s.begin(), s.end());
            int cnt = n - (lower_bound(s.begin(), s.end(), k) - s.begin());

            int ans = 0;
            for (int i = x; i <= cnt; ++i)
                ans = (ans + lucas(cnt, i, p)) % p;
            cout << ans << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：代码首先读取输入，计算正常用户评分总和和最低分，推导出最少水军数 \( x \)。然后排序筛选合格水军数 \( cnt \)，最后用卢卡斯定理计算组合数求和（假设 \( p \) 为质数，非质数时需扩展卢卡斯）。

---
<code_intro_selected>
接下来分析优质题解的核心代码片段：
</code_intro_selected>

**题解一（ztz11）核心代码片段**：
```cpp
int exLucas(int n, int m, int p) {
    // 分解p的质因数，用中国剩余定理合并结果
    int e = 0, q[100], a[100];
    for (int i = 2; i * i <= p; ++i) {
        if (p % i == 0) {
            int pk = 1;
            while (p % i == 0) pk *= i, p /= i;
            q[++e] = pk;
            a[e] = multiLucas(n, m, i, pk); // 计算模pk的组合数
        }
    }
    if (p > 1) q[++e] = p, a[e] = Lucas(n, m, p);
    // 中国剩余定理合并结果
    int res = 0, M = 1;
    for (int i = 1; i <= e; ++i) M *= q[i];
    for (int i = 1; i <= e; ++i) {
        int Mi = M / q[i], invMi = inv(Mi, q[i]);
        res = (res + 1LL * a[i] * Mi % M * invMi % M) % M;
    }
    return res % M;
}
```
* **亮点**：完整实现了扩展卢卡斯算法，处理 \( p \) 非质数的情况。
* **代码解读**：`exLucas` 函数首先将 \( p \) 分解为质因数幂次 \( pk \)，分别计算组合数模 \( pk \) 的结果（`multiLucas`），再用中国剩余定理合并所有结果。这一步是处理 \( p \) 非质数的关键。
* 💡 **学习笔记**：扩展卢卡斯的核心是分解模数并合并结果，适用于 \( p \) 为合数的场景。

**题解二（WhitD）核心代码片段**：
```cpp
int x = _max(1, _ceil((71.0 * m - sum - 42.0) / 29.0));
// 筛选合格水军数cnt
for (i = 1; i <= n; ++i)
    cnt += (s[i] >= k);
// 组合数求和
if (is_p(p))
    for (x; x <= cnt; ++x)
        ans = (ans + lucas(cnt, x, p)) % p;
else
    for (x; x <= cnt; ++x)
        ans = (ans + exlucas(cnt, x, p)) % p;
```
* **亮点**：代码简洁，直接区分 \( p \) 是否为质数选择算法，提升效率。
* **代码解读**：通过 `_ceil` 函数计算 \( x \)（最少水军数），遍历筛选合格水军，再根据 \( p \) 的性质选择卢卡斯或扩展卢卡斯计算组合数。这一步逻辑清晰，避免了冗余计算。
* 💡 **学习笔记**：根据 \( p \) 的性质选择算法，可显著降低时间复杂度。

-----

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解“最少水军数计算”和“组合数求和”的过程，我们设计了“水军雇佣模拟器”像素动画：
</visualization_intro>

  * **动画演示主题**：像素风“水军雇佣模拟器”

  * **核心演示内容**：展示正常用户评分计算、最少水军数 \( x \) 的推导、合格水军筛选，以及组合数求和的动态过程。

  * **设计思路简述**：采用8位像素风格（FC游戏画面），用不同颜色区分合格/不合格水军；关键步骤（如计算 \( x \)、组合数叠加）用闪烁高亮和音效提示，增强记忆点。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 背景为复古游戏界面，顶部显示“评分系统”标题，左侧为“正常用户评分区”（显示每个用户的评分值，用黄色像素块表示），右侧为“水军能力区”（绿色像素块表示合格，红色表示不合格）。
        - 控制面板包含“开始”“单步”“重置”按钮和速度滑块。

    2.  **正常用户评分计算**：
        - 动画播放正常用户评分过程：每个用户的评分值（如25、40）从左侧飞入“评分区”，总和用动态数字显示（如“当前总和：295”）。
        - 最低分（如25）用红色闪烁标记，提示“去掉最低分”，总和更新为“295-25=270”。

    3.  **最少水军数 \( x \) 推导**：
        - 弹出公式气泡：“\( x \geq \frac{71m - sum + min -42}{29} \)”，动态代入数值计算（如 \( m=5 \), \( sum=270 \), \( min=25 \)）。
        - 计算结果用绿色数字显示（如 \( x=2 \)），伴随“叮”的音效。

    4.  **合格水军筛选**：
        - 水军能力值（如1,2,3,4,5）从右侧飞入，与题目要求的 \( k \)（如2）比较：能力≥2的变为绿色（合格），否则红色（不合格）。最终显示合格数 \( cnt=4 \)。

    5.  **组合数求和**：
        - 用堆叠的像素方块表示 \( C(4, i) \)（\( i=2,3,4 \)）：\( C(4,2)=6 \)（6个蓝色方块），\( C(4,3)=4 \)（叠加4个），\( C(4,4)=1 \)（叠加1个）。
        - 每叠加一层，播放“滴答”音效，总和动态更新（如“总方案数：6+4+1=11”）。

    6.  **结果展示**：
        - 最终方案数模 \( p \)（如9）的结果用金色数字显示（如“11 mod 9 = 2”），伴随“胜利”音效和烟花动画。

  * **旁白提示**：
    - “注意看，正常用户的最低分被去掉了，总和变成了270！”
    - “计算最少需要2个水军，这样平均分才能达到71哦～”
    - “合格水军有4个，选择2、3或4个的方案数加起来就是答案！”

<visualization_conclusion>
通过这个像素动画，我们可以直观看到评分计算、水军筛选和组合数求和的全过程，轻松理解抽象的数学逻辑！
</visualization_conclusion>

-----

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心是组合数模运算和数学推导，这类思路还可用于以下场景：
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 选举问题：计算满足得票率的候选人组合数。
    - 资源分配：计算满足条件的分配方案数。
    - 概率统计：计算符合条件的事件组合数。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P3807** - 【模板】卢卡斯定理
        * 🗣️ **推荐理由**：直接练习卢卡斯定理的应用，巩固组合数模质数的计算。
    2.  **洛谷 P4720** - 【模板】扩展卢卡斯定理
        * 🗣️ **推荐理由**：深入理解扩展卢卡斯，处理模数为合数的情况。
    3.  **洛谷 P2181** - 对角线
        * 🗣️ **推荐理由**：练习组合数的实际应用，推导几何问题中的方案数。

-----

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
题解中提到，处理 \( p \) 非质数时容易超时，需注意优化扩展卢卡斯的实现。这对我们有重要启发：
</insights_intro>

> **参考经验 (来自 WhitD)**：“模数是质数的情况用普通卢卡斯，非质数用扩展卢卡斯，否则会TLE。”
>
> **点评**：这位作者的经验提醒我们，算法选择需结合数据范围和模数性质。遇到大数组合数模运算时，先判断 \( p \) 是否为质数，可显著提升效率。

-----

<conclusion>
本次关于“评分系统”的C++解题分析就到这里。希望这份指南能帮助大家掌握组合数模运算和数学推导的技巧。记住，多练习、多思考，编程能力会稳步提升！下次见～💪
</conclusion>

-----

---
处理用时：169.41秒
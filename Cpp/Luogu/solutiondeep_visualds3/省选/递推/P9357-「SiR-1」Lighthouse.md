# 题目信息

# 「SiR-1」Lighthouse

## 题目描述

给定一棵 $n$ 个点的树，每个点有权值 $w_i$，初始为 $0$。初始得分 $s=0$。

进行 $m$ 次操作，每次操作选择一个点 $u$，给 $s$ 增加 $u$ 所在的同点权连通块的大小（即，假设只保留点权等于 $w_u$ 的点，和连接两个点权等于 $w_u$ 的点的边，对得分的贡献就是此时 $u$ 所在的连通块大小。注意这不会真的删去一部分树上的点和边），然后给 $w_u$ 增加 $1$。

请对所有 $n^m$ 种操作方式，求它们的得分 $s$ 之和，对 $10^9+7$ 取模。

## 说明/提示

对于所有数据，满足 $1\leq n\leq 1000$，$1\leq m\leq 10^5$，$1\leq u,v\leq n$，保证输入是一棵树。

- Subtask 0（5 pts）：$n,m\le 7$。
- Subtask 1（20 pts）：$n,m\le 10$。
- Subtask 2（15 pts）：$n,m\le 50$。
- Subtask 3（15 pts）：$n,m\le 100$。
- Subtask 4（15 pts）：$n\le 50$。
- Subtask 5（15 pts）：树是一条链。
- Subtask 6（15 pts）：无特殊限制。

本题同时开启子任务依赖。具体地：

+ 对于子任务 $i(i \in [1, 3])$，依赖于子任务 $0 \sim (i -  1)$；
+ 对于子任务 $4$，依赖于子任务 $0 \sim 2$；
+ 对于子任务 $6$，依赖于子任务 $0 \sim 5$。

## 样例 #1

### 输入

```
3 2
1 3
2 3```

### 输出

```
40```

# AI分析结果



---
# 💡 Kay的C++算法解析：「SiR-1」Lighthouse 深入学习指南 💡

<introduction>
今天我们来一起分析“「SiR-1」Lighthouse”这道C++编程题。这道题需要计算所有可能操作方式下的得分总和，涉及树的结构、组合数学和递推优化。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：数学（组合数学应用）

🗣️ **初步分析**：
解决“「SiR-1」Lighthouse”这道题，关键在于将总得分拆解为点对的贡献，并利用组合数学和递推优化高效计算。简单来说，组合数学就像“分糖果”——我们需要统计所有可能的操作方式中，每个点对（u, v）在特定条件下的贡献，再将这些贡献相加。

在本题中，每个操作的得分由u所在的同权值连通块大小决定。由于连通块的大小与u和其他点的权值是否相同密切相关，我们可以将总得分分解为所有点对（u, v）的贡献之和，其中v在u的连通块中。进一步观察发现，点对的贡献仅与u到v的路径长度d有关（路径上的点数），因此问题转化为统计不同路径长度d的点对数量，并计算每类点对的总贡献。

核心难点包括：
1. 如何将总得分拆解为点对的贡献；
2. 如何统计不同路径长度d的点对数量；
3. 如何高效计算组合数和递推式，避免高时间复杂度。

主要解决方案是：
- 利用树的LCA（最近公共祖先）计算任意两点的路径长度d；
- 统计所有路径长度d的点对数量cnt[d]；
- 对每个d，通过组合数学和递推优化计算其总贡献。

可视化设计思路：我们可以设计一个像素风格的动画，展示树的结构（用8位像素方块表示节点），高亮u到v的路径（用不同颜色标记路径上的节点），动态演示路径长度d的统计过程。同时，用像素化的表格展示组合数的计算过程，关键步骤（如递推式更新）用闪烁或音效提示（如“叮”的音效）。

---

## 2. 精选优质题解参考

<eval_intro>
通过评估思路清晰度、代码规范性、算法有效性等，以下题解评分≥4星，值得重点学习：
</eval_intro>

**题解一：E.Space的概率期望法 (来源：用户E.Space)**
* **点评**：此题解将总得分转化为期望乘方案数，思路简洁且数学推导严谨。通过定义p(u, v, w)表示操作u时v在连通块的概率，将问题拆解为点对贡献的累加。进一步利用路径长度d的统计，将问题转化为对d的分类计算，显著降低了复杂度。虽然未提供完整代码，但数学推导为后续实现提供了明确方向。

**题解二：Yanami_Anna的代码实现 (来源：用户Yanami_Anna)**
* **点评**：此题解提供了完整的C++代码实现，结构清晰，变量命名规范（如`Cnt[d]`统计路径长度为d的点对数量）。代码中使用LCA计算路径长度，预处理组合数和逆元，通过后缀和优化关键和式，时间复杂度为O(nm + m log n)，符合题目数据范围。特别地，代码中对路径长度的统计和递推优化的处理，是实际编码的优秀参考。

**题解三：Sol1的递推优化法 (来源：用户Sol1)**
* **点评**：此题解通过递推式优化关键和式f(a, b)的计算，将时间复杂度从O(m²)降低到O(nm)。推导过程详细，解释了如何通过组合数加法递推简化计算，对理解递推优化技巧有重要启发。虽然代码未直接给出，但递推式推导为实现提供了关键思路。

---

## 3. 核心难点辨析与解题策略

<difficulty_intro>
在解决这个问题的过程中，我们通常会遇到以下关键点或难点。结合优质题解的共性，提炼核心思考方向和策略：
</difficulty_intro>

1.  **关键点1**：如何将总得分拆解为点对的贡献？
    * **分析**：总得分是所有操作方式下，每次操作u时u所在连通块大小的总和。连通块大小等于u所在同权值连通块中的点数，因此每个点v在u的连通块中时，会对此次操作贡献1。因此，总得分等于所有点对（u, v）在操作中v在u连通块的次数之和。
    * 💡 **学习笔记**：总问题的拆解是关键，将复杂问题转化为独立子问题（点对贡献）的累加。

2.  **关键点2**：如何统计路径长度d的点对数量？
    * **分析**：对于树中的任意两点u和v，其路径长度d（路径上的点数）可通过LCA计算。遍历所有点对，统计每个d的出现次数cnt[d]。例如，使用DFS预处理每个节点的深度和父节点，再通过LCA函数计算路径长度。
    * 💡 **学习笔记**：树的路径统计通常需要LCA或DFS预处理，确保高效计算任意两点的路径信息。

3.  **关键点3**：如何高效计算组合数和递推式？
    * **分析**：题目中涉及大量组合数计算（如C(m, i)）和递推式（如f(a, b)）。预处理阶乘和逆元可以快速计算组合数；递推式通过观察项之间的关系（如f(a, b)与f(a-1, b)的关系），将高次项转化为低次项的累加，降低时间复杂度。
    * 💡 **学习笔记**：预处理和递推优化是解决大规模组合数学问题的常用技巧。

### ✨ 解题技巧总结
<summary_best_practices>
- **问题拆解**：将总问题拆解为独立子问题（如点对贡献），简化计算。
- **树结构预处理**：利用LCA或DFS预处理树的路径信息，快速统计路径长度。
- **组合数预处理**：预先计算阶乘和逆元，避免重复计算组合数。
- **递推优化**：通过观察递推式的规律，将高次项转化为低次项的累加，降低时间复杂度。
</summary_best_practices>

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：此代码综合了Yanami_Anna题解的实现思路，包含路径长度统计、组合数预处理、递推优化等关键步骤，是高效解决本题的典型实现。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    #define int long long
    using namespace std;
    const int P = 1e9 + 7;
    const int MAXN = 200005;

    int n, m;
    vector<int> ljb[1500];
    int Cnt[1500]; // 统计路径长度为d的点对数量
    int father[1500][11]; // LCA预处理父节点
    int dep[1500]; // 节点深度
    int Jc[MAXN], InvJc[MAXN]; // 阶乘及逆元
    int ans;

    int power(int x, int y = P - 2) {
        int res = 1;
        while (y) {
            if (y & 1) res = res * x % P;
            x = x * x % P;
            y >>= 1;
        }
        return res;
    }

    void dfs(int cur, int fa) {
        dep[cur] = dep[fa] + 1;
        father[cur][0] = fa;
        for (int i = 1; i < 11; ++i)
            father[cur][i] = father[father[cur][i - 1]][i - 1];
        for (int v : ljb[cur])
            if (v != fa) dfs(v, cur);
    }

    int LCA(int x, int y) {
        if (dep[x] < dep[y]) swap(x, y);
        for (int i = 10; i >= 0; --i)
            if (dep[father[x][i]] >= dep[y]) x = father[x][i];
        if (x == y) return x;
        for (int i = 10; i >= 0; --i)
            if (father[x][i] != father[y][i]) {
                x = father[x][i];
                y = father[y][i];
            }
        return father[x][0];
    }

    int dis(int x, int y) {
        int lca = LCA(x, y);
        return dep[x] + dep[y] - 2 * dep[lca] + 1; // 路径上的点数
    }

    int C(int n, int k) {
        if (k < 0 || k > n) return 0;
        return Jc[n] * InvJc[k] % P * InvJc[n - k] % P;
    }

    signed main() {
        scanf("%lld%lld", &n, &m);
        // 预处理阶乘和逆元
        Jc[0] = InvJc[0] = 1;
        for (int i = 1; i < MAXN; ++i) {
            Jc[i] = Jc[i - 1] * i % P;
            InvJc[i] = power(Jc[i]);
        }
        // 读入树并预处理LCA
        for (int i = 1; i < n; ++i) {
            int u, v;
            scanf("%lld%lld", &u, &v);
            ljb[u].push_back(v);
            ljb[v].push_back(u);
        }
        dfs(1, 0);
        // 统计路径长度为d的点对数量
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j) {
                int d = dis(i, j);
                Cnt[d]++;
            }
        // 计算每个d的贡献
        for (int l = 1; l <= n; ++l) {
            if (Cnt[l] == 0) continue;
            int inv_l = power(l);
            int ratio = (n - l) * inv_l % P; // (n-l)/l
            int D = 1;
            vector<int> Suf(m + 2, 0);
            for (int i = m; i >= 0; --i) {
                Suf[i] = (Suf[i + 1] + C(m, i) * D % P) % P;
                D = D * ratio % P;
            }
            int S = 0;
            for (int w = 0; w * l < m; ++w) {
                int wl = w * l;
                if (wl + 1 > m) break;
                int term = Jc[wl] * power(InvJc[w], l) % P; // (wl)!/(w!)^l
                term = term * power(l, m - wl - 1) % P; // l^(m-wl-1)
                term = term * Suf[wl + 1] % P; // 后缀和
                S = (S + term) % P;
            }
            ans = (ans + S * Cnt[l] % P) % P;
        }
        printf("%lld\n", ans % P);
        return 0;
    }
    ```
* **代码解读概要**：
    该代码首先预处理阶乘和逆元，用于快速计算组合数。通过DFS预处理每个节点的深度和父节点，利用LCA计算任意两点的路径长度d，并统计每个d的点对数量Cnt[d]。对于每个d，计算其后缀和Suf[i]，并通过遍历w（权值增加次数）计算该d的总贡献，最终累加所有d的贡献得到答案。

---
<code_intro_selected>
接下来，剖析优质题解中的核心代码片段。
</code_intro_selected>

**题解二：Yanami_Anna的代码实现 (来源：用户Yanami_Anna)**
* **亮点**：代码结构清晰，预处理LCA和组合数，通过后缀和优化关键和式，时间复杂度低。
* **核心代码片段**：
    ```cpp
    // 统计路径长度为d的点对数量
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) {
            int d = dis(i, j);
            Cnt[d]++;
        }
    // 计算每个d的贡献
    for (int l = 1; l <= n; ++l) {
        if (Cnt[l] == 0) continue;
        int inv_l = power(l);
        int ratio = (n - l) * inv_l % P;
        int D = 1;
        vector<int> Suf(m + 2, 0);
        for (int i = m; i >= 0; --i) {
            Suf[i] = (Suf[i + 1] + C(m, i) * D % P) % P;
            D = D * ratio % P;
        }
        int S = 0;
        for (int w = 0; w * l < m; ++w) {
            int wl = w * l;
            if (wl + 1 > m) break;
            int term = Jc[wl] * power(InvJc[w], l) % P;
            term = term * power(l, m - wl - 1) % P;
            term = term * Suf[wl + 1] % P;
            S = (S + term) % P;
        }
        ans = (ans + S * Cnt[l] % P) % P;
    }
    ```
* **代码解读**：
    - 统计路径长度：通过双重循环遍历所有点对，调用dis函数计算路径长度d，并累加Cnt[d]。
    - 后缀和优化：对于每个d（路径长度l），计算后缀和Suf[i]，表示从i到m的组合数加权和，避免重复计算。
    - 贡献计算：遍历w（权值增加次数），计算每个w对应的项（包含阶乘、逆元、幂次和后缀和），累加得到该d的总贡献，再乘以点对数量Cnt[l]。
* 💡 **学习笔记**：后缀和优化是处理大范围累加和的常用技巧，通过预处理降低时间复杂度。

---

## 5\. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了直观理解路径长度统计和组合数计算过程，我们设计一个“像素树探险”动画，以8位像素风格展示算法核心步骤。
</visualization_intro>

  * **动画演示主题**：像素树中的路径探险与组合数计算

  * **核心演示内容**：
    - 树的结构：用8位像素方块表示节点，边用细线条连接。
    - 路径高亮：当计算点对（u, v）的路径长度时，路径上的节点闪烁并变色（如从灰色变为绿色）。
    - 组合数计算：用像素表格展示阶乘、逆元的预处理结果，关键步骤（如计算C(m, i)）用数字气泡弹出。
    - 后缀和优化：动态展示Suf数组的更新过程，当前计算的i值用箭头标记，数值变化用颜色渐变表示。

  * **设计思路简述**：
    采用8位像素风格（如FC红白机色调）营造轻松氛围，路径高亮帮助观察树的结构，组合数表格和后缀和动画直观展示数学计算过程。音效（如“叮”的提示音）强化关键操作记忆，小关卡（如完成一个d的贡献计算）增加成就感。

  * **动画帧步骤与交互关键点**：

    1.  **场景初始化**：
        - 屏幕左侧显示像素树（节点为16x16像素方块，颜色为蓝色），右侧显示组合数表格（黑色背景，白色数字）。
        - 控制面板包含“开始/暂停”“单步”“重置”按钮，速度滑块（0.5x到2x）。
        - 播放8位风格的背景音乐（轻快的电子旋律）。

    2.  **路径长度统计**：
        - 遍历点对（u, v）时，u和v节点闪烁（黄色），调用LCA函数计算路径长度d。
        - 路径上的节点依次变为绿色，d值显示在路径上方（如“d=3”）。
        - Cnt[d]的数值在右侧表格中更新（如Cnt[3]从0变为1），伴随“滴”的音效。

    3.  **组合数预处理**：
        - 阶乘Jc[i]的计算过程：i从0到m，Jc[i] = Jc[i-1] * i，数值逐渐填充表格，每步伴随“咔嗒”音效。
        - 逆元InvJc[i]的计算：用幂函数power(Jc[i])，数值以反向填充的方式显示。

    4.  **后缀和优化**：
        - 对于每个d，计算ratio = (n-d)/d，用像素箭头指向公式。
        - 计算Suf数组时，i从m到0，Suf[i] = Suf[i+1] + C(m, i) * ratio^(m-i)，数值从右向左填充，当前i值用红色箭头标记。

    5.  **贡献计算**：
        - 遍历w时，w从0开始，计算wl = w*d，若wl+1 > m则跳过。
        - 计算term = (wl)!/(w!)^d * d^(m-wl-1) * Suf[wl+1]，关键部分（如阶乘、幂次）用不同颜色高亮。
        - 累加term到S，S的数值逐渐增大，伴随“叮咚”音效。

    6.  **目标达成**：
        - 所有d处理完成后，总答案ans显示在屏幕中央（金色字体），播放“胜利”音效（上扬的电子旋律），节点闪烁庆祝。

  * **旁白提示**：
    - “看！u和v的路径长度是d，这个d的点对数量加1啦～”
    - “阶乘Jc[i]是前i个数的乘积，逆元InvJc[i]是它的倒数哦！”
    - “后缀和Suf[i]可以快速计算从i到m的和，避免重复计算，是不是很聪明？”

<visualization_conclusion>
通过这个像素动画，我们能直观看到树的路径统计、组合数计算和递推优化的全过程，仿佛在玩一场数学探险游戏，轻松理解算法的核心逻辑。
</visualization_conclusion>

---

## 6\. 拓展练习与相似问题思考

<similar_problems_intro>
理解本题后，我们可以思考组合数学和树路径统计的其他应用场景。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
    - 组合数学：可用于计算所有可能情况的统计问题（如排列组合、概率期望）。
    - 树路径统计：可用于树的直径、路径权值和、最近公共祖先等问题。
    - 递推优化：可用于动态规划、前缀和/后缀和等需要降低时间复杂度的场景。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1352 没有上司的舞会**
        * 🗣️ **推荐理由**：这道题考察树的动态规划，需要统计路径上的节点贡献，与本题的树路径统计思想类似。
    2.  **洛谷 P5020 货币系统**
        * 🗣️ **推荐理由**：此题涉及组合数学中的最小生成集，需要计算不同面值的组合贡献，锻炼组合数学思维。
    3.  **洛谷 P1967 货车运输**
        * 🗣️ **推荐理由**：此题需要计算树的路径上的最大边权，与本题的路径长度统计类似，可巩固树的LCA应用。

---

## 7\. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中未发现明确的作者个人心得分享部分。
</insights_intro>

---

<conclusion>
本次关于“「SiR-1」Lighthouse”的C++解题分析就到这里。希望这份学习指南能帮助大家理解组合数学和树路径统计的应用，掌握递推优化技巧。记住，多动手编码、多思考问题拆解，是提升算法能力的关键！下次我们再一起探索新的编程挑战！💪
</conclusion>

---

---
处理用时：179.62秒
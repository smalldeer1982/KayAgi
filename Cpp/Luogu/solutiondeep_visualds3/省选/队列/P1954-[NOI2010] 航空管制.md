# 题目信息

# [NOI2010] 航空管制

## 题目描述

世博期间，上海的航空客运量大大超过了平时，随之而来的航空管制也频频发生。最近，小 X 就因为航空管制，连续两次在机场被延误超过了两小时。对此，小 X 表示很不满意。

在这次来烟台的路上，小 X 不幸又一次碰上了航空管制。于是小 X 开始思考关于航空管制的问题。

假设目前被延误航班共有 $n$ 个，编号为 $1$ 至 $n$。机场只有一条起飞跑道，所有的航班需按某个顺序依次起飞（称这个顺序为起飞序列）。定义一个航班的起飞序号为该航班在起飞序列中的位置，即是第几个起飞的航班。

起飞序列还存在两类限制条件：

- 第一类（最晚起飞时间限制）：编号为 $i$ 的航班起飞序号不得超过 $k_i$。

- 第二类（相对起飞顺序限制）：存在一些相对起飞顺序限制 $(a,b)$，表示航班 $a$ 的起飞时间必须早于航班 $b$，即航班 $a$ 的起飞序号必须小于航班 $b$ 的起飞序号。

小 X 思考的第一个问题是，若给定以上两类限制条件，是否可以计算出一个可行的起飞序列。第二个问题则是，在考虑两类限制条件的情况下，如何求出每个航班在所有可行的起飞序列中的最小起飞序号。


## 说明/提示

### 样例解释

在样例 $1$ 中：

起飞序列 $3\ 5\ 1\ 4\ 2$ 满足了所有的限制条件，所有满足条件的起飞序列有：

$$
\begin{aligned}
3\ 4\ 5\ 1\ 2\\
3\ 5\ 1\ 2\ 4\\
3\ 5\ 1\ 4\ 2\\
3\ 5\ 4\ 1\ 2\\
5\ 3\ 1\ 2\ 4\\
5\ 3\ 1\ 4\ 2\\
5\ 3\ 4\ 1\ 2
\end{aligned}
$$

由于存在 $(5,1)$ 和 $(3,1)$ 两个限制，航班 $1$ 只能安排在航班 $5$ 和 $3$ 之后，故最早起飞时间为 $3$，其他航班类似。

在样例 $2$ 中：

虽然航班 $4,5$ 没有相对起飞顺序限制，但是由于航班 $1,2,3$ 都必须安排在前 $3$ 个起飞，所以 $4,5$ 最早只能安排在第 $4$ 个起飞。

### 数据范围

对于 $30\%$ 数据：$n\leq 10$。

对于 $60\%$ 数据：$n\leq 500$。

对于 $100\%$ 数据：$n\leq 2\times 10^3,m\leq 10^4$。

感谢 @FlierKing 提供 spj


## 样例 #1

### 输入

```
5 5
4 5 2 5 4
1 2
3 2
5 1
3 4
3 1
```

### 输出

```
3 5 1 4 2
3 4 1 2 1
```

## 样例 #2

### 输入

```
5 0
3 3 3 5 5
```

### 输出

```
3 2 1 5 4
1 1 1 4 4
```

# AI分析结果

# 💡 Kay的C++算法解析：[NOI2010]航空管制 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：**拓扑排序（反图应用）+ 贪心策略**  

🗣️ **初步分析**：  
解决“航空管制”问题的关键，在于**将“最晚起飞时间”转化为“最早可起飞时间”**（通过“时光倒流”思想），并结合拓扑排序处理相对顺序限制。简单来说，就像“倒着安排日程”——原本要让航班A在航班B之前起飞（正序），倒过来就是让B在A之前“虚拟起飞”（反序）；原本A的最晚起飞时间是k_i（正序第k_i位），倒过来就是A必须在反序的第(n - k_i + 1)位之前“虚拟起飞”。这种转化能将复杂的限制条件简化为**反图上的拓扑排序问题**。  

- **核心思路**：  
  1. **第一问**：建反图（将原边(a,b)改为(b,a)），倒着从第n位到第1位安排航班。每次选择**当前可用（入度为0）且反序可起飞时间最晚（即正序k_i最大）**的航班，确保满足所有限制。  
  2. **第二问**：要让航班i的起飞序号尽可能小（正序），等价于在反图中让i尽可能晚“虚拟起飞”。因此，在拓扑排序时**尽量不选i**，直到无法安排其他航班时，此时的位置就是i的最小正序起飞序号。  

- **可视化设计思路**：  
  用**8位像素风**模拟“时光倒流”的安排过程：  
  - 屏幕左侧显示反图拓扑结构（节点为像素化飞机，边为箭头）；  
  - 右侧显示“虚拟起飞序列”（从第n位到第1位），每次选择的航班用**闪烁红框**标记，伴随“叮”的音效；  
  - 当处理第二问时，目标航班用**蓝色高亮**，显示“尽量不选”的逻辑（比如队列中优先跳过蓝色节点）。  


## 2. 精选优质题解参考

### 题解一：Sol1（赞：23）  
* **点评**：  
  此题解的“时光倒流”思想非常清晰，直接击中问题本质。第一问中，倒着处理时间，用队列维护可用航班，每次选一个航班“虚拟起飞”，并更新依赖它的航班的入度。第二问中，为了让航班i尽可能早，**强制在队列中优先跳过i**，直到必须选i时，此时的位置就是答案。代码结构简洁（用队列和数组维护入度），逻辑推导过程自然，适合初学者理解“反图+拓扑”的核心逻辑。  

### 题解二：asuldb（赞：11）  
* **点评**：  
  此题解明确提到“反图拓扑排序”的套路，与[HNOI2015]菜肴制作的思路一致。第一问中，反图上用小根堆维护“反序可起飞时间”（n - k_i），确保每次选最晚可起飞的航班。第二问中，通过“暂时不让i进堆”的策略，模拟“尽量不选i”的贪心过程，代码中的`work`函数逻辑清晰，体现了“反图+贪心”的高效性。  

### 题解三：Sor4（赞：4）  
* **点评**：  
  此题解的第二问处理非常巧妙。作者指出，“让i尽可能早”等价于“在反图中让i尽可能晚”，因此在拓扑排序时，**即使i的入度为0，也暂时不放它进队列**，直到其他航班无法安排时，才选i。这种思路直接对应问题的本质，代码中的`Get`函数用优先队列实现了这一逻辑，简洁且有效。  


## 3. 核心难点辨析与解题策略

### 1. **难点1：如何将“最晚起飞时间”转化为可处理的条件？**  
* **分析**：  
  正序的“最晚起飞时间k_i”（航班i必须在第k_i位之前起飞），倒过来就是“反序的最早可起飞时间”（航班i必须在反序的第(n - k_i + 1)位之前“虚拟起飞”）。例如，正序k_i=3（n=5），反序就是必须在第3位（5-3+1=3）之前起飞。这种转化让“最晚”限制变成了“最早”限制，更容易用拓扑排序处理。  
* 💡 **学习笔记**：**时光倒流是处理“最晚”限制的常用技巧**，将问题转化为更熟悉的“最早”场景。  

### 2. **难点2：如何处理第二问的“最小起飞序号”？**  
* **分析**：  
  要让航班i的起飞序号尽可能小（正序），需要让i尽可能早地被安排，但受限于相对顺序限制（比如i必须在a、b之后）。反过来看，在反图中，i的“虚拟起飞”时间尽可能晚，意味着正序中i的起飞时间尽可能早。因此，在拓扑排序时，**尽量不选i**，直到无法安排其他航班时，i的位置就是答案。  
* 💡 **学习笔记**：**问题转化是解决第二问的关键**，将“最小”转化为“最大”（反图中的最晚）。  

### 3. **难点3：如何高效维护可用航班？**  
* **分析**：  
  无论是第一问还是第二问，都需要维护“入度为0”的可用航班。第一问中，用队列或堆维护可用航班，选择“反序可起飞时间最晚”的航班；第二问中，需要优先跳过目标航班，因此队列中要先处理其他航班。例如，Sol1的`Solve2`函数中，用队列维护可用航班，当遇到目标航班时，将其放到队列末尾，优先处理其他航班。  
* 💡 **学习笔记**：**队列/堆是维护拓扑排序可用节点的核心数据结构**，根据问题需求调整节点的处理顺序。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合Sol1、asuldb的思路，实现反图拓扑排序解决两问。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <queue>
  #include <vector>
  #include <cstring>
  using namespace std;

  const int MAXN = 2005;
  const int MAXM = 10005;

  int n, m;
  int k[MAXN];
  vector<int> e[MAXN]; // 反图边（原边a→b改为b→a）
  int deg[MAXN], Deg[MAXN]; // 入度，Deg保存原始入度
  int ans[MAXN]; // 第一问的起飞序列（反序）

  // 第一问：反图拓扑排序，倒着安排航班
  void solve1() {
      queue<int> q;
      memcpy(deg, Deg, sizeof(deg));
      for (int i = 1; i <= n; ++i) {
          if (deg[i] == 0) {
              q.push(i);
          }
      }
      int pos = n;
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          ans[pos--] = u; // 反序保存，正序输出时从1到n
          for (int v : e[u]) {
              deg[v]--;
              if (deg[v] == 0) {
                  q.push(v);
              }
          }
      }
      for (int i = 1; i <= n; ++i) {
          cout << ans[i] << " ";
      }
      cout << endl;
  }

  // 第二问：求航班x的最小起飞序号
  int solve2(int x) {
      queue<int> q;
      memcpy(deg, Deg, sizeof(deg));
      for (int i = 1; i <= n; ++i) {
          if (i != x && deg[i] == 0) {
              q.push(i);
          }
      }
      int pos = n;
      while (!q.empty()) {
          int u = q.front();
          q.pop();
          if (u == x) {
              // 必须选x时，返回当前pos
              return pos;
          }
          pos--;
          for (int v : e[u]) {
              deg[v]--;
              if (v != x && deg[v] == 0) {
                  q.push(v);
              }
          }
      }
      return pos;
  }

  int main() {
      cin >> n >> m;
      for (int i = 1; i <= n; ++i) {
          cin >> k[i];
      }
      for (int i = 0; i < m; ++i) {
          int a, b;
          cin >> a >> b;
          e[b].push_back(a); // 建反图
          Deg[a]++;
      }
      solve1();
      for (int i = 1; i <= n; ++i) {
          cout << solve2(i) << " ";
      }
      cout << endl;
      return 0;
  }
  ```  
* **代码解读概要**：  
  - 第一问`solve1`：建反图，用队列维护入度为0的节点，倒着安排航班（`ans[pos--] = u`），正序输出时就是可行的起飞序列。  
  - 第二问`solve2`：对于目标航班x，优先处理其他入度为0的节点，直到必须选x时，返回当前位置（即x的最小正序起飞序号）。  


### 题解一（Sol1）核心代码片段赏析  
* **亮点**：用队列维护可用航班，第二问中优先跳过目标节点。  
* **核心代码片段**：  
  ```cpp
  void Solve2(int u) {
      queue<int> que2;
      memcpy(tmp, indgr, sizeof(tmp));
      for (int t = n; t >= 1; --t) {
          // 加入当前时间可用的航班
          for (int j = 0; j < v[t].size(); ++j) {
              tmp[v[t][j]]--;
              if (!tmp[v[t][j]]) {
                  que2.push(v[t][j]);
                  // 优先跳过目标节点u
                  if (que2.size() > 1 && que2.back() == u) {
                      swap(que2[que2.size()-2], que2.back());
                  }
              }
          }
          int x = que2.front();
          que2.pop();
          if (x == u) {
              printf("%d ", t);
              break;
          }
          // 更新依赖节点的入度
          for (int i = hd[x]; ~i; i = e[i].nxt) {
              tmp[e[i].to]--;
              if (!tmp[e[i].to]) {
                  que2.push(e[i].to);
                  if (que2.size() > 1 && que2.back() == u) {
                      swap(que2[que2.size()-2], que2.back());
                  }
              }
          }
      }
  }
  ```  
* **代码解读**：  
  - `v[t]`存储反序可起飞时间为t的航班（即正序k_i = t）。  
  - 每次将当前时间t的可用航班加入队列，若队列中有目标节点u，将其交换到队列末尾（优先处理其他节点）。  
  - 当弹出的节点是u时，当前时间t就是u的最小正序起飞序号（因为反序t对应正序n - t + 1？不，Sol1的代码中t是反序的时间，比如反序第t位对应正序第t位？需要结合原题解理解，但核心逻辑是“尽量不选u”）。  
* 💡 **学习笔记**：**队列中调整节点顺序是实现“尽量不选”的关键**，通过交换位置优先处理其他节点。  


## 5. 算法可视化：像素动画演示（核心部分）

### 动画演示主题：**时光倒流的航班安排**（8位像素风）  
### 设计思路  
用**FC红白机风格**模拟“倒着安排航班”的过程，通过**像素飞机**、**箭头边**、**虚拟起飞序列**展示拓扑排序的每一步。加入**音效**和**游戏化控制**，让学习者直观理解“反图+贪心”的逻辑。  

### 动画帧步骤与交互关键点  
1. **场景初始化**：  
   - 屏幕左侧显示反图拓扑结构（节点为**16x16像素的飞机**，边为**黄色箭头**）；  
   - 屏幕右侧显示“虚拟起飞序列”（从第n位到第1位，用**灰色方块**表示未安排，**绿色方块**表示已安排）；  
   - 底部控制面板有“开始/暂停”“单步执行”“重置”按钮，以及“速度滑块”（1x-5x）。  

2. **算法启动**：  
   - 播放**8位风格背景音乐**（轻快的电子乐）；  
   - 反图中入度为0的节点（可用航班）用**闪烁红框**标记，伴随“滴”的音效。  

3. **核心步骤演示**：  
   - **选择航班**：每次从可用节点中选**反序可起飞时间最晚**的航班（比如k_i最大的），用**蓝色高亮**标记，伴随“叮”的音效；  
   - **虚拟起飞**：将选中的航班加入右侧“虚拟起飞序列”（绿色方块），反图中该节点的边变为**灰色**（表示已处理）；  
   - **更新入度**：依赖该航班的节点入度减1，若入度变为0，用**闪烁红框**标记，伴随“滴”的音效。  

4. **第二问演示**：  
   - 目标航班用**紫色高亮**标记；  
   - 队列中优先处理其他节点（紫色节点被放到队列末尾），直到无法安排其他节点时，紫色节点被选中，此时右侧序列中的位置用**红色箭头**指向，伴随“胜利”音效（表示找到最小起飞序号）。  

5. **交互控制**：  
   - **单步执行**：点击“单步”按钮，执行一步拓扑排序，显示当前步骤的代码片段（比如`que.pop()`）；  
   - **自动播放**：拖动“速度滑块”调整播放速度，动画自动执行，直到完成；  
   - **重置**：点击“重置”按钮，恢复初始状态，重新开始演示。  


## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移  
“反图+拓扑排序”的思路可用于解决**带限制的拓扑序问题**，比如：  
- **[HNOI2015]菜肴制作**：要求拓扑序中某些节点尽可能早，用反图+大根堆；  
- **[USACO07MAR]牛交通**：求最长路径，用拓扑排序+动态规划；  
- **[P4017]最大食物链计数**：求拓扑序中的路径数目，用拓扑排序+计数。  

### 练习推荐（洛谷）  
1. **洛谷 P3243** - [HNOI2015]菜肴制作  
   🗣️ **推荐理由**：与本题思路完全一致，要求拓扑序中某些节点尽可能早，用反图+大根堆，是本题的直接延伸。  
2. **洛谷 P4017** - 最大食物链计数  
   🗣️ **推荐理由**：考察拓扑排序的计数应用，需要维护每个节点的入度和路径数目，是拓扑排序的基础练习。  
3. **洛谷 P2883** - [USACO07MAR]牛交通  
   🗣️ **推荐理由**：考察拓扑排序求最长路径，需要处理带权图的拓扑序，是拓扑排序的进阶练习。  


## 7. 学习心得与经验分享（若有）  
**参考经验（来自Sol1）**：“时光倒流的思想是解决本题的关键，将‘最晚’限制转化为‘最早’限制，让问题变得容易处理。”  
**点评**：这位作者的经验非常重要。在遇到“最晚”“最大”等限制时，不妨尝试“倒过来想”，将问题转化为更熟悉的“最早”“最小”场景，往往能找到突破口。例如，本题中的“最晚起飞时间”转化为“反序最早可起飞时间”，就是一个典型的例子。  


## 结语  
本次关于“[NOI2010]航空管制”的分析，我们学习了**反图拓扑排序**和**贪心策略**的结合，掌握了“时光倒流”的技巧。希望这份指南能帮助你理解这类问题的本质，下次遇到类似问题时，能举一反三！💪  

（注：可视化动画可通过HTML/CSS/JavaScript实现，核心是用Canvas绘制像素节点和边，用队列维护可用节点，动态更新节点状态。）

---
处理用时：195.80秒
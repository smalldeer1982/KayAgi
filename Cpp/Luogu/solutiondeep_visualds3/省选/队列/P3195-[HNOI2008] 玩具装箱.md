# 题目信息

# [HNOI2008] 玩具装箱

## 题目描述

P 教授要去看奥运，但是他舍不下他的玩具，于是他决定把所有的玩具运到北京。他使用自己的压缩器进行压缩，其可以将任意物品变成一堆，再放到一种特殊的一维容器中。

P 教授有编号为 $1 \cdots n$ 的 $n$ 件玩具，第 $i$ 件玩具经过压缩后的一维长度为 $C_i$。

为了方便整理，P 教授要求：

- 在一个一维容器中的玩具编号是连续的。

- 同时如果一个一维容器中有多个玩具，那么两件玩具之间要加入一个单位长度的填充物。形式地说，如果将第 $i$ 件玩具到第 $j$ 个玩具放到一个容器中，那么容器的长度将为 $x=j-i+\sum\limits_{k=i}^{j}C_k$。

制作容器的费用与容器的长度有关，根据教授研究，如果容器长度为 $x$，其制作费用为 $(x-L)^2$。其中 $L$ 是一个常量。P 教授不关心容器的数目，他可以制作出任意长度的容器，甚至超过 $L$。但他希望所有容器的总费用最小。

## 说明/提示

对于全部的测试点，$1 \leq n \leq 5 \times 10^4$，$1 \leq L \leq 10^7$，$1 \leq C_i \leq 10^7$。

## 样例 #1

### 输入

```
5 4
3
4
2
1
4```

### 输出

```
1```

# AI分析结果

# 《玩具装箱》题解分析与总结


## **一、题目回顾**
**问题描述**：将n个玩具分成连续的若干组，每组的费用为（组长度-L）的平方，其中组长度等于组内玩具长度和加上间隔数（如i到j组的间隔数为i-j）。求最小总费用。  
**输入**：n（玩具数量）、L（常数）、玩具长度数组C[1..n]。  
**输出**：最小总费用。  


## **二、核心思路：动态规划+斜率优化**
### 1. 状态定义
设`dp[i]`表示前i个玩具的最小费用。  
**转移方程**（暴力版）：  
$$ dp[i] = \min_{0 \leq j < i} \left( dp[j] + \left( \sum_{k=j+1}^i C[k] + (i-j-1) - L \right)^2 \right) $$  
其中，`sum[i]`表示C[1..i]的前缀和，代入后简化为：  
$$ dp[i] = \min_{0 \leq j < i} \left( dp[j] + \left( sum[i] - sum[j] + i - j - 1 - L \right)^2 \right) $$  

**问题**：暴力转移的时间复杂度为O(n²)，无法处理n=5e4的规模。需要优化转移过程。


### 2. 变量替换与方程简化
为了应用斜率优化，对转移方程进行**变量替换**：  
令`S[i] = sum[i] + i`（前缀和加上索引，单调递增），`M = L + 1`（常数），则转移方程简化为：  
$$ dp[i] = \min_{0 \leq j < i} \left( dp[j] + \left( S[i] - (S[j] + M) \right)^2 \right) $$  

展开平方项：  
$$ dp[i] = \min_{0 \leq j < i} \left( dp[j] + S[i]^2 - 2S[i](S[j] + M) + (S[j] + M)^2 \right) $$  

将关于i的项（`S[i]^2`）提取出来（因为对所有j来说，`S[i]^2`是常数），得到：  
$$ dp[i] = S[i]^2 + \min_{0 \leq j < i} \left( dp[j] + (S[j] + M)^2 - 2S[i](S[j] + M) \right) $$  


### 3. 斜率优化推导
令：  
- `x[j] = S[j] + M`（单调递增，因为S[j]单调递增）  
- `y[j] = dp[j] + x[j]^2`（关于j的函数）  

则转移方程中的min部分可表示为：  
$$ \min_{j} \left( y[j] - 2S[i] \cdot x[j] \right) $$  

这等价于**在平面上找到点(x[j], y[j])，使得直线`y = 2S[i] \cdot x + b`经过该点且截距`b`最小**（因为`b = y[j] - 2S[i] \cdot x[j]`，而`dp[i] = S[i]^2 + b`）。  

**结论**：最优解对应的点一定在**下凸包**上（下凸包上的点能使截距最小）。


### 4. 维护下凸包（单调队列）
由于`S[i]`单调递增（`sum[i]`和`i`均递增），`2S[i]`（直线斜率）也单调递增。此时，可使用**单调队列**维护下凸包，保证队列中的点满足：  
- 队首的点是当前最优决策（斜率最小的有效点）；  
- 队尾的点维护下凸性（新加入的点不会破坏凸包结构）。  

**队列操作**：  
- **队首弹出**：当队首两个点的斜率小于当前斜率`2S[i]`时，队首的点不是最优的，弹出；  
- **队尾弹出**：当队尾两个点与当前点形成的斜率不满足下凸性（即斜率递减）时，队尾的点无法构成凸包，弹出；  
- **加入队尾**：将当前点加入队列。  


## **三、代码实现关键细节**
### 1. 数据类型
由于数值可能很大（如`C[i]`和`L`可达1e7，平方后可达1e14），需使用`long long`存储`sum`、`dp`、`S`等变量。


### 2. 斜率计算
为了避免浮点精度问题，可使用**交叉相乘**比较斜率（如判断`slope(a,b) < slope(b,c)`等价于`(y[b]-y[a])*(x[c]-x[b]) < (y[c]-y[b])*(x[b]-x[a])`）。但题解中多使用`double`计算斜率，因为`S[i]`单调递增，`x[j]`单调递增，不会出现除以零的情况。


### 3. 队列初始化
队列初始时需加入`j=0`的情况（`x[0] = S[0] + M = 0 + L + 1`，`y[0] = dp[0] + x[0]^2 = 0 + (L+1)^2`）。


### 4. 代码框架
```cpp
#include <iostream>
#include <cstdio>
#include <deque>
using namespace std;
typedef long long ll;

const int MAXN = 5e4 + 5;
ll n, L, M;
ll C[MAXN], sum[MAXN], S[MAXN], dp[MAXN];
deque<int> q;

ll x(int j) { return S[j] + M; }
ll y(int j) { return dp[j] + x(j) * x(j); }
double slope(int a, int b) {
    return (double)(y(b) - y(a)) / (x(b) - x(a));
}

int main() {
    scanf("%lld%lld", &n, &L);
    M = L + 1;
    sum[0] = 0;
    for (int i = 1; i <= n; ++i) {
        scanf("%lld", &C[i]);
        sum[i] = sum[i-1] + C[i];
        S[i] = sum[i] + i;
    }
    q.push_back(0);
    for (int i = 1; i <= n; ++i) {
        // 弹出队首无效点
        while (q.size() >= 2 && slope(q[0], q[1]) < 2 * S[i]) {
            q.pop_front();
        }
        int j = q.front();
        dp[i] = dp[j] + (S[i] - x(j)) * (S[i] - x(j));
        // 维护队尾凸性
        while (q.size() >= 2) {
            int a = q[q.size()-2], b = q[q.size()-1];
            if (slope(a, b) >= slope(b, i)) {
                q.pop_back();
            } else {
                break;
            }
        }
        q.push_back(i);
    }
    printf("%lld\n", dp[n]);
    return 0;
}
```


## **四、题解总结**
### 1. 核心优化点
- **斜率优化**：将动态规划的转移方程转化为线性函数截距最小化问题，通过维护下凸包将转移复杂度从O(n²)降至O(n)。  
- **单调队列**：利用`S[i]`单调递增的性质，维护下凸包的单调队列，保证每次转移的最优决策点可在O(1)时间内找到。


### 2. 适用场景
斜率优化适用于**转移方程为`dp[i] = min/max(dp[j] + a[i]b[j] + c[i] + d[j])`**的情况，其中：  
- `a[i]`（直线斜率）单调递增；  
- `b[j]`（点的横坐标）单调递增。  


### 3. 注意事项
- **变量替换**：通过变量替换简化转移方程，使其符合斜率优化的形式；  
- **凸包维护**：正确维护下凸包（或上凸包，根据min/max需求），确保队列中的点是有效的；  
- **数据精度**：使用`long long`避免溢出，使用`double`计算斜率时注意精度问题（或用交叉相乘替代）。


## **五、拓展思考**
- **如果`S[i]`不单调**：此时斜率`2S[i]`不一定单调，需要使用**平衡树**或**CDQ分治**维护凸包；  
- **其他应用场景**：斜率优化还可用于解决“任务安排”“土地征用”等问题，核心思想是将动态规划转移转化为线性函数优化问题。


**总结**：《玩具装箱》是斜率优化的经典例题，通过动态规划与斜率优化的结合，将时间复杂度从O(n²)降至O(n)，解决了大规模数据的问题。掌握斜率优化的核心思想（凸包维护）和实现细节（单调队列），是解决此类问题的关键。

---
处理用时：138.60秒
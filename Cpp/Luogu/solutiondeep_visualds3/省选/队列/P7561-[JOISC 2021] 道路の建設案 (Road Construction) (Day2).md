# 题目信息

# [JOISC 2021] 道路の建設案 (Road Construction) (Day2)

## 题目背景

10s,2048M

## 题目描述

JOI 国是一个 $x\times y$ 的二维平面，王国里有 $n$ 个城镇，分别编号为 $1, 2, \cdots, n$，其中第 $i$ 个城镇的 **坐标** 为 $(x_i, y_i)$。

在 JOI 国，正计划修建连接两座城镇的路（下文简称：**「修路的项目」**），路有 $k$ 条。连接两个不同的城镇 $a$ 和 $b$ 将花费 $|x_a − x_b| + |y_a − y_b|$ 元。若有一条连接 $c$，$d$ 的路，则不需要也不可以在建一条连接 $d$，$c$ 的路，因为它们是相同的。

你要管理这个「修路的项目」，为了计算花费情况，你得弄明白连接一些城镇所需的花费。在这 $\dfrac{n\cdot(n-1)}{2}$ 条道路中，你想了解最便宜的 $k$ 条道路的花费。

给你城镇的坐标以及 $k$，请计算最便宜的 $k$ 条路所需要的钱。

## 说明/提示

#### 样例 #1 解释
有 $\dfrac{3 \times 2}{2} = 3$ 种方案。

- 城镇 $1 \to$ 城镇 $2$，$|(-1)-0|+|0-2| = 3$ 日元。
- 城镇 $1 \to$ 城镇 $3$，$|(-1)-0|+|0-0| = 1$ 日元。
- 城镇 $2 \to$ 城镇 $3$，$|0-0|+|2-0| = 2$ 日元。

将其进行排序为 $1,2,3$，所以输出是 $1$ 和 $2$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #2 解释

有 $\dfrac{5 \times 4}{2} = 10$ 种方案。

将钱数排序后是 $2, 2, 3, 3, 3, 3, 4, 4, 4, 4$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #3 解释

本样例满足 Subtask $1, 2, 4, 5, 6$。

#### 样例 #4 解释

本样例满足 Subtask $1, 4, 5, 6$。

#### 数据范围与约定

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | $n$ | $k$ | $y_i$ |
| :----: | :----: | :----: | :----:| :----: |
| $1$ | $5\%$ | $\le 10^3$ | / | / |
| $2$ | $6\%$ | / | / | $=0$ |
| $3$ | $7\%$ | / | $=1$ | / |
| $4$ | $20\%$ | / | $\le 10$ | / |
| $5$ | $27\%$ |  / | $\le 10 ^ 5$ | / |
| $6$ | $35\%$ | / | / | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：
- $2 \le n \le 2.5 \times 10^5$；
- $1 \le k \le \min(2.5\times 10^5,\ \dfrac{n\cdot(n-1)}{2}$)；
- $-10^9 \le x_i, y_i \le 10^9$，且 $1 \le i \le n$；
- $(x_i,y_i)\not = (x_j, y_j)$ 且 $1 \le i < j \le n$。

#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 2 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/2021-sp-d2-notice.pdf) [T2 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/road_construction.pdf)。


## 样例 #1

### 输入

```
3 2
-1 0
0 2
0 0
```

### 输出

```
1
2
```

## 样例 #2

### 输入

```
5 4
1 -1
2 0
-1 0
0 2
0 -2
```

### 输出

```
2
2
3
3
```

## 样例 #3

### 输入

```
4 6
0 0
1 0
3 0
4 0
```

### 输出

```
1
1
2
3
3
4
```

## 样例 #4

### 输入

```
10 10
10 -8
7 2
7 -8
-3 -6
-2 1
-8 6
8 -1
2 4
6 -6
2 -1
```

### 输出

```
3
3
4
5
6
6
6
7
7
7
```

# AI分析结果

# 💡 Kay的C++算法解析：[JOISC 2021] 道路の建設案 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：二分答案 + 二维范围查询（切比雪夫距离转化）


🗣️ **初步分析**：  
解决“道路建设”问题，关键是找到**前k小的曼哈顿距离点对**。曼哈顿距离的计算是`|x₁-x₂|+|y₁-y₂|`，但直接枚举所有点对（复杂度O(n²)）对于n=2.5×10⁵来说完全不可行。这时候需要**转化距离形式**和**高效统计**。  

### 核心技巧：曼哈顿转切比雪夫  
想象一下，如果你把点`(x,y)`变成`(x+y, x-y)`，那么原来的曼哈顿距离就变成了**切比雪夫距离**（`max(|x₁'-x₂'|, |y₁'-y₂'|)`）。这一步就像把“斜着走的距离”转换成“横竖走的最大步长”，更容易用**范围查询**处理。  

### 核心算法：二分答案 + Check函数  
我们可以用**二分答案**的思路（类似“猜数字游戏”）：假设第k小的距离是`mid`，然后检查有多少点对的距离≤`mid`。如果数量≥k，说明`mid`可以更小；否则需要更大。  

**Check函数的关键**：  
要快速统计“切比雪夫距离≤mid”的点对数量。具体来说，切比雪夫距离≤mid意味着：  
- `x₁' - mid ≤ x₂' ≤ x₁' + mid`（x坐标范围）  
- `y₁' - mid ≤ y₂' ≤ y₁' + mid`（y坐标范围）  

我们可以**按x坐标排序**，用**双指针**维护x坐标在`[xᵢ-mid, xᵢ]`范围内的点（类似“滑动窗口”），再用**有序集合（set）**维护这些点的y坐标，快速查询y在`[yᵢ-mid, yᵢ+mid]`范围内的点数量（这一步像“在抽屉里找符合条件的玩具”）。  

### 可视化设计思路  
我会设计一个**8位像素风格**的动画，展示二分过程和Check函数的执行：  
- **场景**：屏幕左边是“二分进度条”（显示当前l、r、mid），右边是“像素点地图”（用不同颜色标记点：红色=当前处理的点，蓝色=在x范围内的点，绿色=在y范围内的点）。  
- **动画步骤**：  
  1. 初始化：所有点以像素块形式出现在地图上。  
  2. 二分开始：进度条显示初始l=0、r=4e9，mid=2e9。  
  3. Check过程：  
     - 双指针移动：左边指针向右收缩，移除x超出`[xᵢ-mid, xᵢ]`的点（蓝色消失）。  
     - set查询：当前点（红色）的y范围`[yᵢ-mid, yᵢ+mid]`内的点（绿色亮起），统计数量。  
  4. 二分调整：根据Check结果，进度条更新l或r（比如mid太大，r=mid-1）。  
- **游戏化元素**：  
  - 音效：二分调整时播放“滴”声，双指针移动时播放“吱”声，找到符合条件的点对时播放“叮”声。  
  - 交互：提供“单步执行”（逐帧看Check过程）、“自动播放”（快速演示）、“重置”（重新开始）按钮，以及“速度滑块”（调整播放速度）。  


## 2. 精选优质题解参考

为了帮助大家快速掌握核心思路，我筛选了3份**思路清晰、代码规范、实践价值高**的题解（评分≥4星）：


### **题解一：hfjh的二分+multiset实现（来源：洛谷题解区）**  
* **点评**：  
  这份题解的**思路非常直白**：先转切比雪夫距离，再用二分答案+Check函数统计点对数量。Check函数用**双指针维护x范围**（滑动窗口），用**multiset维护y坐标**（有序集合），通过`lower_bound`快速找到y的左边界，然后遍历符合条件的点。代码结构清晰（分`input`、`check`、`op`、`output`函数），变量名（如`p[i].x`、`p[i].y`）含义明确，边界处理严谨（比如用`multiset`存储`y`坐标，避免重复计算）。  
  **亮点**：Check函数中一旦统计的点对数量≥k就立即返回，减少不必要的计算，提升效率。


### **题解二：7KByte的二分+set实现（来源：洛谷题解区）**  
* **点评**：  
  这份题解的**代码简洁高效**：转切比雪夫距离后，按x排序，二分答案的框架清晰。Check函数用`queue`维护x范围（双指针的另一种实现），用`set`维护y坐标，查询时通过`lower_bound`和`upper_bound`快速定位y范围。代码中的`ans`数组存储符合条件的距离，最后排序输出，处理了“前k小”的细节。  
  **亮点**：输出部分通过`check(ed-1)`补充了小于`ed`的距离，再用`ed`补齐到k个，确保答案正确。


### **题解三：SunnyYuan的二分+multiset实现（来源：洛谷题解区）**  
* **点评**：  
  这份题解的**解释详细**：特别说明了“为什么要`check(l-1)`”——因为二分得到的`l`是第k小的距离，而`check(l)`可能统计了超过k个点对，`check(l-1)`可以补充所有小于`l`的距离，再用`l`补齐到k个。代码中的`multiset`插入了极大值和极小值，避免了边界判断错误，非常严谨。  
  **亮点**：对输出部分的细节处理（排序`ans`数组，补齐`l`），确保了答案的正确性和顺序。


## 3. 核心难点辨析与解题策略

在解决本题时，大家常遇到以下3个核心难点，结合优质题解的共性，我总结了应对策略：


### **1. 难点：如何将曼哈顿距离转化为切比雪夫距离？**  
* **分析**：  
  曼哈顿距离的计算是`|x₁-x₂|+|y₁-y₂|`，直接统计前k小的点对需要O(n²)时间，无法处理大数据。而切比雪夫距离的`max(|x₁'-x₂'|, |y₁'-y₂'|)`可以通过**坐标变换**（`x'=x+y`，`y'=x-y`）转化为曼哈顿距离，这样更容易用范围查询处理。  
* 💡 **学习笔记**：转切比雪夫是处理曼哈顿距离的“魔法”，记住这个变换公式（`x'=x+y`，`y'=x-y`）！


### **2. 难点：如何设计高效的Check函数？**  
* **分析**：  
  Check函数需要统计“切比雪夫距离≤mid”的点对数量。优质题解的做法是：  
  - **按x排序**：确保x坐标递增，方便用双指针维护x范围。  
  - **双指针维护x范围**：对于当前点`i`，左指针`pos`向右移动，移除x<`p[i].x - mid`的点（这些点的x距离超过mid）。  
  - **有序集合维护y坐标**：用`set`或`multiset`存储当前x范围内的点的y坐标，通过`lower_bound`快速找到y≥`p[i].y - mid`的点，然后遍历到y≤`p[i].y + mid`的点，统计数量。  
* 💡 **学习笔记**：双指针+有序集合是处理“二维范围查询”的常用组合，就像“先筛掉不符合x条件的点，再找符合y条件的点”。


### **3. 难点：如何处理输出前k小的距离？**  
* **分析**：  
  二分得到第k小的距离`l`后，`check(l)`可能统计了超过k个点对（因为有多个点对的距离等于`l`）。此时需要：  
  - 用`check(l-1)`统计所有小于`l`的距离（数量一定小于k）。  
  - 将这些距离排序，然后用`l`补齐到k个（因为`l`是第k小的距离，剩下的k-数量个距离都是`l`）。  
* 💡 **学习笔记**：输出时要注意“前k小”的顺序，需要排序并补齐边界情况。


### ✨ 解题技巧总结  
- **技巧A：距离转化**：遇到曼哈顿距离问题，先考虑转切比雪夫距离（`x'=x+y`，`y'=x-y`）。  
- **技巧B：二分答案**：对于“前k小”或“第k小”的问题，二分答案是常用思路（将问题转化为“是否存在k个符合条件的元素”）。  
- **技巧C：范围查询优化**：用双指针维护x范围，用有序集合维护y坐标，降低查询复杂度（O(n log n)）。  


## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考  
* **说明**：综合了hfjh、7KByte、SunnyYuan的题解思路，提炼了一个清晰的核心实现。  
* **完整核心代码**：  
  ```cpp
  #include <iostream>
  #include <vector>
  #include <algorithm>
  #include <set>
  #include <queue>
  using namespace std;
  using ll = long long;

  const int N = 250010;
  const ll INF = 1e18;

  struct Node {
      ll x, y;
  } p[N];

  int n, k;
  ll ans[N], cnt;

  bool check(ll mid) {
      set<pair<ll, ll>> s; // 存储(y, x)，按y排序
      queue<int> q;
      cnt = 0;

      for (int i = 1; i <= n; ++i) {
          // 维护x范围：移除x < p[i].x - mid的点
          while (!q.empty() && p[q.front()].x < p[i].x - mid) {
              s.erase({p[q.front()].y, p[q.front()].x});
              q.pop();
          }
          // 查询y范围：[p[i].y - mid, p[i].y + mid]
          auto it = s.lower_bound({p[i].y - mid, -INF});
          while (it != s.end() && it->first <= p[i].y + mid) {
              ans[++cnt] = max(p[i].x - it->second, abs(p[i].y - it->first));
              if (cnt >= k) return true;
              ++it;
          }
          // 将当前点加入队列和集合
          q.push(i);
          s.insert({p[i].y, p[i].x});
      }
      return false;
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);

      cin >> n >> k;
      for (int i = 1; i <= n; ++i) {
          ll a, b;
          cin >> a >> b;
          p[i].x = a + b; // 转切比雪夫x'
          p[i].y = a - b; // 转切比雪夫y'
      }
      // 按x排序（切比雪夫的x'）
      sort(p + 1, p + n + 1, [](const Node& a, const Node& b) {
          return a.x < b.x || (a.x == b.x && a.y < b.y);
      });

      // 二分答案
      ll l = 0, r = INF;
      while (l < r) {
          ll mid = l + (r - l) / 2;
          if (check(mid)) {
              r = mid;
          } else {
              l = mid + 1;
          }
      }

      // 统计小于l的距离，再用l补齐
      check(l - 1);
      sort(ans + 1, ans + cnt + 1);
      for (int i = 1; i <= cnt; ++i) {
          cout << ans[i] << '\n';
      }
      for (int i = cnt + 1; i <= k; ++i) {
          cout << l << '\n';
      }

      return 0;
  }
  ```  
* **代码解读概要**：  
  1. **输入与转化**：读取点坐标，将`(x,y)`转化为`(x+y, x-y)`（切比雪夫坐标）。  
  2. **排序**：按切比雪夫的x坐标排序，方便双指针维护x范围。  
  3. **二分答案**：通过`check`函数判断当前`mid`是否为第k小的距离。  
  4. **输出处理**：统计小于`l`的距离，排序后输出，再用`l`补齐到k个。  


### 针对各优质题解的片段赏析  

#### **题解一：hfjh的multiset实现**  
* **亮点**：用`multiset`存储y坐标，处理重复y值的情况。  
* **核心代码片段**：  
  ```cpp
  multiset<Node> s; // Node按y排序
  // ...
  auto it = s.lower_bound({0, p[i].y - mid});
  while (it != s.end() && it->y <= p[i].y + mid) {
      ans[++cnt] = max(p[i].x - it->x, abs(p[i].y - it->y));
      if (cnt >= k) return true;
      ++it;
  }
  ```  
* **代码解读**：  
  - `multiset`中的`Node`按y排序，`lower_bound`找到第一个y≥`p[i].y - mid`的点。  
  - 遍历到y≤`p[i].y + mid`的点，计算切比雪夫距离（`max(x差, y差)`），并统计数量。  
* 💡 **学习笔记**：`multiset`允许重复元素，适合处理y值重复的情况。


#### **题解二：7KByte的queue+set实现**  
* **亮点**：用`queue`维护x范围，`set`维护y坐标，代码简洁。  
* **核心代码片段**：  
  ```cpp
  queue<Pr> q; // Pr是(x, y)
  set<Pr> s; // 按y排序
  // ...
  while (!q.empty() && q.front().X + mid < a[i].X) {
      s.erase(make_pair(q.front().Y, q.front().X));
      q.pop();
  }
  ```  
* **代码解读**：  
  - `queue`存储当前x范围内的点，当点的x+mid < 当前点的x时，移除该点（x距离超过mid）。  
  - `set`存储`(y, x)`，按y排序，方便查询y范围。  
* 💡 **学习笔记**：`queue`和`set`的组合是处理滑动窗口的常用方式。


#### **题解三：SunnyYuan的输出处理**  
* **亮点**：详细处理了输出前k小的距离，确保顺序正确。  
* **核心代码片段**：  
  ```cpp
  check(l - 1);
  sort(ans + 1, ans + cnt + 1);
  for (int i = 1; i <= cnt; ++i) cout << ans[i] << '\n';
  for (int i = cnt + 1; i <= k; ++i) cout << l << '\n';
  ```  
* **代码解读**：  
  - `check(l - 1)`统计所有小于`l`的距离（数量一定小于k）。  
  - 排序这些距离，然后用`l`补齐到k个（因为`l`是第k小的距离）。  
* 💡 **学习笔记**：输出时要注意“前k小”的顺序，需要排序并补齐边界情况。  


## 5. 算法可视化：像素动画演示 (核心部分)

### **动画演示主题**：像素探险家的“距离寻宝”游戏  
（仿照FC红白机风格，用8位像素块展示点和算法过程）


### **核心演示内容**  
1. **场景初始化**：  
   - 屏幕左边是“二分进度条”（显示当前l=0、r=4e9、mid=2e9），用绿色进度条表示当前mid的位置。  
   - 屏幕右边是“像素点地图”（用不同颜色的像素块表示点：红色=当前处理的点，蓝色=在x范围内的点，绿色=在y范围内的点）。  
   - 底部有“控制面板”：包含“单步执行”（▶️）、“自动播放”（⏯️）、“重置”（🔄）按钮，以及“速度滑块”（调节播放速度）。  

2. **二分过程演示**：  
   - 初始时，进度条显示l=0、r=4e9，mid=2e9（用黄色标记）。  
   - 点击“自动播放”，进度条开始动态调整：如果`check(mid)`返回true（有≥k个点对），r=mid-1（进度条缩短右边）；否则l=mid+1（进度条缩短左边）。  
   - 每调整一次mid，播放“滴”声（提示二分进度变化）。  

3. **Check函数演示**：  
   - 当二分调整到某个mid时，切换到“Check过程”：  
     - 红色像素块（当前处理的点）从左到右移动（按x排序后的顺序）。  
     - 蓝色像素块（在x范围内的点）随着双指针移动而变化：左指针向右收缩时，蓝色像素块消失（移除x超出范围的点）。  
     - 绿色像素块（在y范围内的点）随着`set`查询而亮起：当红色点的y范围`[yᵢ-mid, yᵢ+mid]`内有蓝色点时，这些点变成绿色，并播放“叮”声（提示找到符合条件的点对）。  
   - 当统计的点对数量≥k时，Check过程停止，返回true，二分继续调整。  

4. **游戏化元素**：  
   - **音效**：二分调整（滴）、双指针移动（吱）、找到点对（叮）、完成二分（胜利音效）。  
   - **积分系统**：每找到一个符合条件的点对，获得1分；完成二分（找到第k小的距离），获得“寻宝成功”称号。  
   - **AI演示模式**：点击“AI自动演示”，算法会自动完成二分和Check过程，像“贪吃蛇AI”一样逐步找到答案。  


### **设计思路**  
- **像素风格**：8位像素块符合复古游戏氛围，降低视觉复杂度，让学习者专注于算法过程。  
- **颜色标记**：用不同颜色区分点的状态（当前处理、x范围、y范围），直观展示算法的核心逻辑。  
- **音效提示**：通过声音强化关键操作（如二分调整、找到点对），帮助学习者记忆算法步骤。  
- **交互设计**：单步执行让学习者逐帧观察Check过程，自动播放快速演示整体流程，速度滑块适应不同学习节奏。  


## 6. 拓展练习与相似问题思考

### **通用思路/技巧迁移**  
本题的**二分答案+范围查询**思路可以迁移到以下场景：  
1. **平面最近点对**（求最小的曼哈顿距离）：二分答案，Check是否存在点对距离≤mid。  
2. **K远点对**（求最大的k个曼哈顿距离）：类似思路，二分答案，Check是否存在≥k个点对距离≥mid。  
3. **二维范围统计**（统计某个矩形内的点数量）：用双指针+有序集合或BIT（树状数组）。  


### **练习推荐 (洛谷)**  
1. **洛谷 P1429** - 平面最近点对  
   🗣️ **推荐理由**：这道题是“最小曼哈顿距离”的经典问题，需要用到二分答案+范围查询，帮助巩固本题的核心技巧。  
2. **洛谷 P2093** - [国家集训队] JZPFAR  
   🗣️ **推荐理由**：这道题要求“第k远的曼哈顿距离”，需要用到KDT（KD树）或二分答案+范围查询，是本题的进阶练习。  
3. **洛谷 P4357** - [CQOI2016] K 远点对  
   🗣️ **推荐理由**：这道题要求“前k大的欧几里得距离”，思路类似本题（二分答案+范围查询），但需要处理欧几里得距离的转化，是很好的思维拓展练习。  


## 7. 学习心得与经验分享 (若有)

### **参考经验 (来自SunnyYuan的题解)**  
> “我在解决这个问题时，最初没有处理`check(l-1)`，导致输出的前k小距离中缺少了小于`l`的部分。后来通过调试发现，二分得到的`l`是第k小的距离，而`check(l)`可能统计了超过k个点对，所以需要用`check(l-1)`补充所有小于`l`的距离，再用`l`补齐到k个。”  

**点评**：这位作者的经验很典型。在编程过程中，**边界情况的处理**非常重要。比如本题中的“前k小”问题，需要考虑“小于`l`的距离”和“等于`l`的距离”的数量，确保输出的顺序和数量正确。通过`check(l-1)`补充小于`l`的距离，再用`l`补齐，是处理这种边界情况的有效方法。  


## 结语  
本次关于“[JOISC 2021] 道路の建設案”的C++解题分析就到这里。希望这份学习指南能帮助大家理解**二分答案+范围查询**的核心思路，掌握**曼哈顿转切比雪夫**的技巧，以及**双指针+有序集合**的优化方法。  

记住，编程能力的提升在于**持续学习、勤于思考、勇于实践**。下次我们再一起探索新的编程挑战！💪  

（注：本文中的可视化方案可通过HTML/CSS/JavaScript实现，核心代码片段可参考`Canvas`绘制像素块、`setInterval`实现动画、`Web Audio API`添加音效。）

---
处理用时：229.05秒
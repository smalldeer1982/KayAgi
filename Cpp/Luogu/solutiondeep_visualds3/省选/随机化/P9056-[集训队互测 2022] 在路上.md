# 题目信息

# [集训队互测 2022] 在路上

## 题目背景

滥用本题评测者封号。

dottle bot。

## 题目描述

**这是一道交互题，仅支持 C++ 提交**。

有一棵未知的树，**保证树的大小为奇数，你需要找到这棵树重心的编号**。

你可以进行询问，每次询问你可以询问三个点 $(x,y,z)$，若不存在一条简单路径同时经过三个点，则交互器会返回 $0$，否则若存在，那么交互器会返回三个点在路径上相对顺序中间的一个点。

令 $dis(a,b)$ 表示 $a,b$ 两点在树上最短路径经过的边数，你也可以理解为:

若 $dis(x,y)+dis(x,z)=dis(y,z)$，则交互器会返回 $x$。

否则若 $dis(y,x)+dis(y,z)=dis(x,z)$，交互器会返回 $y$。

否则若 $dis(z,x)+dis(z,y)=dis(x,y)$，交互器会返回 $z$。

否则交互器会返回 $0$。

在最终的测试中，每个测试点会包含 $T$ 组测试数据，和一个常数 $M$，表示你在所有测试数据中询问次数总和的上限，具体细则见 输入格式 以及 数据范围。

#### 实现细节

~~你需要引用 `path.h` 头文件。~~ 本题中你只需要把 `path.h` 头文件的内容粘贴到程序开头即可，不要引用 `path.h` 头文件。

你需要实现下面的函数：

```
int centroid(int id,int N,int M);
```

其中 $id$ 为当前子任务的编号，$N$ 为当前询问树的大小，$M$ 为当前测试点剩余的询问次数，函数的返回值为当前树的重心编号。

具体的，在第一次调用时 $M$ 为当前测试点的询问次数上限，每次调用结束之后 $M$ 会减去当前测试点使用的询问次数。

你可以调用下面的函数：

```
int ask(int x,int y,int z);
```

表示你进行了一次询问，交互器会返回当前询问的答案，特别的，若询问次数已经超过了上限，交互器会返回 $-1$。

注意同一个测试点中 `centroid` 函数可能会被多次调用，请注意数组清空等情况。

**下发文件中有样例交互库，该交互库的实现与评测时的交互库几乎一致，如果对交互方式有不理解可以参照交互库的代码理解**。


## 说明/提示

#### 数据范围

![](https://cdn.luogu.com.cn/upload/image_hosting/f3d6b2zv.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

特殊性质 $A$：保证树的形态为一条链，即每个点的度数均不超过 $2$。

保证每个 Subtask 里的测试数据数量均不超过 $20$。**请仔细阅读每一档子任务及其限制**。

#### 时空限制

Subtask 5 时限为 3s。

Subtask 7,8 时限为 4s。

其余 Subtask 时限为 1s。

空间限制：512MB。

保证最终交互库的时间使用不超过  2s，空间使用不超过 64MB。

#### 下发文件

下发文件中有一个样例交互库，提供的交互头文件，一份示例代码，以及一个满足子任务 $4$ 性质的样例，选手也可以按照题目的输入格式构造其他样例。

另外也有一份洛谷样式的交互库。

保证下发的交互库和最终使用的交互库除反作弊之外没有区别，你可以使用这个交互库输出调试信息。

# AI分析结果

---
# 💡 Kay的C++算法解析：[集训队互测2022]在路上 深入学习指南 💡

<introduction>
今天我们来挑战一道**交互题**——「在路上」。题目要求我们通过特殊的询问操作，找到未知树的重心。这道题需要结合树的性质、随机化技巧和递归分治思维，非常锻炼我们的问题转化能力！
</introduction>

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用`（交互设计 + 树的重心性质 + 随机化分治）

🗣️ **初步分析**：
解决这道题的关键，是把「树上找重心」的复杂问题，**转化为更容易处理的「链上找带权中位数」问题**。打个比方：树就像一棵“大树枝”，重心是“最稳的节点”——删掉它后所有分支都不超过原树的一半大。而任意选两个点的路径（比如树的“主枝”），重心有≥50%的概率在这条“主枝”上！我们可以用随机化选这条“主枝”，再把问题限制在“主枝”上解决。

### 核心思路拆解
1. **随机选“主枝”**：随机挑两个点`l`和`r`，它们的路径就是“主枝”。重心在这条“主枝”上的概率很高，期望几次就能命中。
2. **链上分治**：把“主枝”上的点当成一条链，用询问判断其他点属于链的左侧、右侧还是中间，递归处理**超过一半大小的子树**（因为重心必须让所有子树≤n/2）。
3. **验证重心**：用摩尔投票法快速判断找到的点是否真的是重心——如果删去它后有子树超过n/2，就重新找。

### 可视化设计思路
我们会用**8位像素风**模拟树的结构：
- `l`和`r`用红、蓝像素块标记，它们的路径用黄色“导线”连接；
- 随机选点`k`时，`k`会闪烁绿色，伴随“叮”的音效；
- 判断点的位置时，用箭头像素块指示“左移/右移”，属于左侧的点变成浅蓝，右侧变成浅粉；
- 验证重心时，每个子树的点会集体闪烁，若所有子树≤n/2，重心会变成紫色并播放“胜利音效”（类似FC游戏通关的“叮~当~”）。


## 2. 精选优质题解参考

<eval_intro>
我为大家筛选了一份**4.5星**的优质题解（作者：DaiRuiChen007）。它的思路巧妙、代码严谨，非常适合学习交互题的核心技巧！
</eval_intro>

**题解一：(来源：DaiRuiChen007)**
* **点评**：这份题解的“转化思维”太亮眼了！它没有直接处理复杂的树结构，而是用**随机化**把问题“压”到一条链上——这一步直接把难度降低了一半！代码里用`vector`维护不同子树的点（`L`左侧、`R`右侧、`C`链上、`S`其他），逻辑清晰到像“整理书包”：把不同类型的点分类放好，再递归处理大的“书包”。最妙的是**摩尔投票法验证重心**——用O(n)的时间快速判断子树大小，避免了“找错重心”的尴尬。代码里的`chk`函数就像“质检员”，确保最后返回的点一定是“稳当的重心”。从竞赛角度看，这份代码的询问次数期望是O(n)，完全符合题目限制，而且处理特殊子任务（比如链的情况）时用`nth_element`快速找中位数，效率超高！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
这道题的“坑”主要在「如何把树的问题简化」「如何用询问判断位置」「如何验证重心」。结合题解的思路，我们一一破解：
</difficulty_intro>

1.  **难点1：树→链的转化——怎么选“主枝”？**
    * **分析**：树的重心有个神奇性质：**任意选两个点的路径，重心一定在这条路径上的概率≥1/2**！就像“找平衡木的中点，随便选两个端点，中点大概率在中间”。题解里用`mt19937`随机选`l`和`r`，期望2次就能选到包含重心的“主枝”。
    * 💡 **学习笔记**：遇到复杂结构，先找“大概率包含答案的简化结构”，能大幅降低难度！

2.  **难点2：链上点的位置判断——怎么用询问分左右？**
    * **分析**：假设“主枝”是`l→r`，要判断点`i`在链的左侧还是右侧，只需问`ask(l, i, k)`（`k`是链上的点）：如果返回`i`，说明`i`在`l`和`k`之间（左侧）；否则在`k`和`r`之间（右侧）。就像“用尺子量点的位置”，一次询问就能“定位”。
    * 💡 **学习笔记**：交互题的关键是“用询问的结果做决策”，每一次询问都要“问在点子上”！

3.  **难点3：重心验证——怎么确认找到的点是对的？**
    * **分析**：删去重心`u`后，所有子树大小必须≤n/2。题解用**摩尔投票法**找“最常见的子树代表点”：如果有子树超过n/2，这个点会被“投票”选出来，再统计它的大小即可。就像“找班级里最受欢迎的同学”，超过半数的人会把他选出来。
    * 💡 **学习笔记**：验证步骤是交互题的“保险绳”，再聪明的思路也要用验证确保正确性！

### ✨ 解题技巧总结
- **技巧1：随机化简化问题**：面对“不确定的结构”（比如未知树），用随机化选“大概率包含答案的结构”（比如主枝），能快速缩小范围。
- **技巧2：分类维护数据**：用`vector`把点分成不同子树（左侧、右侧、链上），像“整理抽屉”一样让逻辑更清晰。
- **技巧3：摩尔投票法验证**：O(n)时间判断“是否有超过半数的元素”，是验证重心的“神器”！


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合题解思路的通用核心实现**，它包含了“随机选主枝→链上分治→验证重心”的完整流程：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解的核心逻辑，保留了随机化、分治和摩尔投票的关键步骤，结构清晰。
* **完整核心代码**：
    ```cpp
    #include<bits/stdc++.h>
    using namespace std;
    extern "C" int ask(int x,int y,int z); // 交互函数（题目提供）
    mt19937 rnd(random_device{}()); // 随机数生成器
    int n; // 当前树的大小

    // 验证u是否是重心：用摩尔投票法找最大子树
    int check_centroid(int u, const vector<int>& all_nodes) {
        int cnt = 0, major = 0;
        // 第一步：摩尔投票找可能的最大子树代表点
        for (int v : all_nodes) {
            if (v == u) continue;
            if (cnt == 0) { major = v; cnt = 1; }
            else {
                if (ask(u, v, major) == u) cnt--; // v和major不在同一子树
                else cnt++; // v和major在同一子树
            }
        }
        // 第二步：统计major所在子树的大小
        int size = 0;
        for (int v : all_nodes) {
            if (v == u) continue;
            if (ask(u, v, major) != u) size++; // v和major在同一子树
        }
        return (size <= n/2) ? u : -1; // 子树≤n/2则是重心
    }

    // 递归处理链l→r，分治找重心
    int solve_chain(int l, int r, vector<int> L, vector<int> R, vector<int> C, vector<int> S) {
        if (L.size() > n/2) return check_centroid(l, L);
        if (R.size() > n/2) return check_centroid(r, R);
        if (l == r) return check_centroid(l, S);

        // 随机选链上的点k（避免选l/r）
        int k = l;
        while (k == l || k == r) {
            int rd = rnd() % (C.size() + S.size());
            if (rd < C.size()) k = C[rd];
            else {
                int t = S[rd - C.size()];
                for (int i : C) if (ask(k, t, i) == i) k = i;
            }
        }

        // 分类点到CL（k左侧）、CR（k右侧）、SK（k的子树）等
        vector<int> CL, CR, SK, SL, SR;
        for (int i : C) if (i != k) {
            ask(l, i, k) == i ? CL.push_back(i) : CR.push_back(i);
        }
        for (int i : S) {
            if (ask(l, k, i) == k) {
                ask(r, k, i) == k ? SK.push_back(i) : SR.push_back(i);
            } else SL.push_back(i);
        }

        int sl = L.size() + CL.size() + SL.size();
        int sr = R.size() + CR.size() + SR.size();
        if (sl <= n/2 && sr <= n/2) return check_centroid(k, SK);
        // 递归处理较大的子树
        if (sr > n/2) { swap(L, R); swap(CL, CR); swap(SL, SR); swap(l, r); }
        R.push_back(k); R.insert(R.end(), SK.begin(), SK.end());
        R.insert(R.end(), CR.begin(), CR.end()); R.insert(R.end(), SR.begin(), SR.end());
        for (int i : CL) if (i != l && ask(i, r, l) == r) r = i;
        vector<int> new_S;
        for (int i : SL) ask(l, r, i) == r ? R.push_back(i) : new_S.push_back(i);
        return solve_chain(l, r, L, R, CL, new_S);
    }

    extern "C" int centroid(int id, int N, int M) {
        n = N;
        while (true) {
            // 随机选主枝的两个端点l和r
            int l = rnd() % n + 1, r = rnd() % n + 1;
            if (l == r) continue;
            // 分类所有点到L（l侧）、R（r侧）、C（链上）、S（其他）
            vector<int> L, R, C{l, r}, S;
            for (int i = 1; i <= n; ++i) {
                if (i == l || i == r) continue;
                int res = ask(i, l, r);
                if (res == l) L.push_back(i);
                else if (res == r) R.push_back(i);
                else if (res == i) C.push_back(i);
                else S.push_back(i);
            }
            // 递归处理链l→r
            int ans = solve_chain(l, r, L, R, C, S);
            if (ans != -1) return ans;
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 1. **随机选主枝**：`centroid`函数里用`rnd()`随机挑`l`和`r`，把所有点分成`L`（l侧）、`R`（r侧）、`C`（链上）、`S`（其他）四类；
    > 2. **链上分治**：`solve_chain`函数递归处理链`l→r`，随机选点`k`，再把点分成`CL`（k左侧）、`CR`（k右侧）等，递归处理较大的子树；
    > 3. **验证重心**：`check_centroid`函数用摩尔投票法找最大子树，验证是否≤n/2，确保返回的点是重心。

---

<code_intro_selected>
接下来剖析题解中**最核心的两个代码片段**，看看它们是如何实现“分治”和“验证”的：
</code_intro_selected>

**题解一：(来源：DaiRuiChen007)**
* **亮点**：用摩尔投票法快速验证重心，避免了复杂的子树大小计算。
* **核心代码片段（验证重心）**：
    ```cpp
    int chk(int rt, vi V) {
        int cnt=0,col=0;
        for(int i:V) {
            if(!cnt) ++cnt,col=i;
            else {
                if(ask(rt,i,col)==rt) --cnt;
                else ++cnt;
            }
        }
        if(!cnt) return rt;
        int tot=0;
        for(int i:V) if(ask(rt,col,i)!=rt) ++tot;
        return (tot<=n/2)?rt:-1;
    }
    ```
* **代码解读**：
    > 这段代码是“重心质检员”！第一步用**摩尔投票**找“最常见的子树代表点”`col`：如果两个点`i`和`col`在同一子树（`ask(rt,i,col)!=rt`），就给`col`加一票；否则减一票。第二步统计`col`所在子树的大小`tot`：如果`tot≤n/2`，说明`rt`是重心，否则不是。
    > 比如，假设`rt`是重心，那么所有子树都≤n/2，摩尔投票会找不到“超过半数的点”（`cnt=0`），直接返回`rt`；如果`rt`不是重心，`col`会是最大子树的代表点，统计`tot`就能判断。
* 💡 **学习笔记**：摩尔投票法是处理“多数元素”问题的神器，这里用来验证重心，太巧妙了！

**题解一：(来源：DaiRuiChen007)**
* **亮点**：用随机化选链上的点，避免了“固定选点”导致的高询问次数。
* **核心代码片段（随机选点）**：
    ```cpp
    int k=l;
    while(k==l||k==r) {
        int rd=rnd()%(C.size()+S.size());
        if(rd<(int)C.size()) k=C[rd];
        else {
            int t=S[rd-C.size()];
            for(int i:C) if(ask(k,t,i)==i) k=i;
        }
    }
    ```
* **代码解读**：
    > 这段代码在链`C`或其他点`S`中随机选一个点`k`，但必须避免选`l`或`r`（因为它们是链的端点，无法分治）。如果选的是`S`中的点`t`，就用`ask(k,t,i)==i`找到`t`在链上的对应点`i`（因为`t`不在链上，它的路径到链的交点就是`i`）。这样选出来的`k`一定在链上，而且是随机的，能保证分治时每次删掉的点期望≥1/4，减少询问次数。
* 💡 **学习笔记**：随机化选点是交互题的“加速剂”，能避免“最坏情况”的高复杂度！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了更直观地“看”到算法的运行，我设计了一个**8位像素风的动画**，像玩FC游戏一样学算法！
</visualization_intro>

  * **动画演示主题**：《像素树的重心大冒险》——你是一个“像素探险家”，要在未知的像素树中找到“最稳的重心节点”。

  * **核心演示内容**：
    - 随机选“主枝”`l`（红）和`r`（蓝），它们的路径用黄色像素块连接；
    - 随机选点`k`（绿闪烁），用询问判断`k`在链上的位置，箭头指示“左移/右移”；
    - 分治处理较大的子树（橙色闪烁），直到找到候选重心；
    - 验证重心时，每个子树的点集体闪烁，若通过则重心变成紫色，播放“胜利音效”。

  * **设计思路简述**：
    - 用8位像素风是因为它“复古又亲切”，像小时候玩的《超级玛丽》，能降低学习的紧张感；
    - 颜色和音效是“记忆锚点”：红色`l`、蓝色`r`、绿色`k`，不同操作对应不同音效（比如选点是“叮”，分治是“咔嗒”，胜利是“叮~当~”），能让你快速记住每个步骤的意义；
    - 游戏化的“闯关”：每完成一次分治就过一关，通关时重心会“跳起来”，增加成就感！

  * **动画帧步骤与交互关键点**：
    1. **初始化**：屏幕显示一个像素树（随机生成的树结构），右下角有“开始”“单步”“重置”按钮，速度滑块（从“慢”到“快”）；
    2. **选主枝**：随机选`l`（红）和`r`（蓝），黄色路径连接它们，伴随“咻”的音效；
    3. **分类点**：所有点按`L`（浅蓝）、`R`（浅粉）、`C`（黄）、`S`（灰）变色，像“给树穿衣服”；
    4. **随机选k**：`k`闪烁绿色，“叮”的一声，箭头指示`k`在链上的位置；
    5. **分治处理**：较大的子树（比如左侧）闪烁橙色，“咔嗒”一声，屏幕聚焦到左侧子树；
    6. **验证重心**：候选重心变成紫色，所有子树的点集体闪烁，统计大小后，若通过则播放“胜利音效”，屏幕出现“通关！”的像素文字；
    7. **交互控制**：支持“单步执行”（每点一下走一步）、“自动播放”（按速度滑块的速度运行）、“重置”（重新开始）。

  * **旁白提示**：
    - 选主枝时：“随机选两个点l和r，它们的路径是树的‘主枝’，重心大概率在这里！”；
    - 选k时：“现在随机选点k，看看它在链上的位置~”；
    - 验证时：“检查这个点是不是重心——所有子树都不超过一半大吗？”。

<visualization_conclusion>
通过这个动画，你能**亲眼看到**算法是如何“缩小范围”“定位重心”的。像素风格和游戏化元素让学习更轻松，音效和颜色让每个步骤都“刻在脑子里”！
</visualization_conclusion>


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
这道题的“转化思维”“随机化”“摩尔投票”都是通用技巧，能解决很多类似问题：
</similar_problems_intro>

  * **通用思路迁移**：
    - **转化问题**：比如“找树的直径”，可以转化为“两次BFS”；
    - **随机化**：比如“找数组的第k大元素”，随机选基准点能降低时间复杂度；
    - **摩尔投票**：比如“找数组中出现次数超过一半的元素”，直接用摩尔投票O(n)解决。

  * **练习推荐 (洛谷)**：
    1.  **洛谷 P1395** - 会议
          * 🗣️ **推荐理由**：这道题是“树的重心模板题”，能帮你巩固“重心是树中所有点到它的距离之和最小的点”这个性质。
    2.  **洛谷 P2993** - 寻找主人
          * 🗣️ **推荐理由**：这是一道交互题，需要通过询问判断点的归属，能锻炼你“用询问结果做决策”的能力。
    3.  **洛谷 P3690** - 【模板】动态树（LCT）
          * 🗣️ **推荐理由**：这道题涉及树的路径操作，能帮你理解“树的路径”这个核心概念，深化对本题“主枝”的理解。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解作者分享了一个重要的经验——**“随机化能解决很多‘不确定’的问题”**：
</insights_intro>

> **参考经验 (来自 DaiRuiChen007)**：“最开始我想固定选l=1，r=2，但这样重心不在链上的概率很高，询问次数会爆炸。后来改用随机选l和r，期望2次就能选到包含重心的链，直接把时间复杂度降下来了！”
>
> **点评**：这个经验太实在了！很多时候我们会“钻牛角尖”想“找最优的初始点”，但随机化反而能“以不变应万变”，避免最坏情况。在编程中，“随机化”是一个“四两拨千斤”的技巧，一定要记住！


<conclusion>
这道交互题的核心是**“转化问题+随机化+验证”**。通过把树转化为链，用随机化缩小范围，再用摩尔投票验证，我们就能高效找到重心。记住：遇到复杂问题，先想“能不能简化它”，再想“怎么用技巧加速”！下次遇到交互题，你一定能更从容~💪
</conclusion>

---

---
处理用时：142.18秒
# 题目信息

# [国家集训队] 礼物

## 题目背景

一年一度的圣诞节快要来到了。每年的圣诞节小 E 都会收到许多礼物，当然他也会送出许多礼物。不同的人物在小 E 心目中的重要性不同，在小 E 心中分量越重的人，收到的礼物会越多。

## 题目描述

小 E 从商店中购买了 $n$ 件礼物，打算送给 $m$ 个人，其中送给第 $i$ 个人礼物数量为 $w_i$。请你帮忙计算出送礼物的方案数（两个方案被认为是不同的，当且仅当存在某个人在这两种方案中收到的礼物不同）。由于方案数可能会很大，你只需要输出模 $P$ 后的结果。


## 说明/提示

### 样例 1 解释
以 `/` 分割，`/` 前后分别表示送给第一个人和第二个人的礼物编号。$12$ 种方案详情如下：
```plain
1/23 1/24 1/34
2/13 2/14 2/34
3/12 3/14 3/24
4/12 4/13 4/23
```
### 数据规模与约定
设 $P= \prod_{i=1}^t p_i^{c_i}$，$p_i$ 为质数。

对于 $15\%$ 的数据，$n\leq 15$，$m\leq 5$，$p_i^{c_i}\leq 10^5$。

在剩下的 $85\%$ 数据中，约有 $60\%$ 的数据满足 $t\leq 2$，$c_i=1$，$p_i\leq 10^5$，约有 $30\%$ 的数据满足 $p_i\leq 200$。

对于 $100\%$ 的数据，$1\leq n\leq 10^9$，$1\leq m\leq 5$，$1\leq p_i^{c_i}\leq 10^5$，$1\leq w_i \leq P\leq 10^9$。


## 样例 #1

### 输入

```
100
4 2
1
2
```

### 输出

```
12```

## 样例 #2

### 输入

```
100
2 2
1
2```

### 输出

```
Impossible
```

# AI分析结果

---
# 💡 Kay的C++算法解析：[国家集训队]礼物 深入学习指南 💡

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：扩展卢卡斯定理（ExLucas）

🗣️ **初步分析**：  
解决“礼物分配”问题的关键是计算**组合数的乘积模非质数P**。比如，给第一个人选w₁个礼物的方案数是C(n, w₁)，给第二个人选w₂个的方案数是C(n-w₁, w₂)，依此类推，总方案数是这些组合数的乘积。但问题在于，P可能不是质数，直接计算组合数的逆元会失败——这时候就需要**扩展卢卡斯定理**（ExLucas）来“拆解难题”。  

简单来说，扩展卢卡斯就像“数学拆弹专家”：  
1. **拆解P**：把P拆成质数的幂（比如P=12=2²×3¹），这些质数幂两两互质；  
2. **逐个击破**：分别计算组合数模每个质数幂的结果（比如C(4,1)%4和C(4,1)%3）；  
3. **合并结果**：用中国剩余定理（CRT）把这些结果合并成最终答案。  

**核心算法流程**：  
- 先计算所有w_i的和sum，如果sum>n，直接输出Impossible；  
- 否则，计算组合数乘积：ans = C(n,w₁) × C(n-w₁,w₂) × … × C(w_m,w_m) mod P；  
- 每个组合数的计算依赖扩展卢卡斯：分解P→算每个质数幂的组合数→CRT合并。  

**可视化设计思路**：  
我们会用8位像素风（像FC游戏一样）演示扩展卢卡斯的过程：  
- 用像素块表示P的分解（比如12拆成2²和3¹，像素块“裂开”成两部分）；  
- 用像素箭头演示阶乘的处理（提取质数因子、计算剩余阶乘、逆元乘法）；  
- 用像素“融合”动画展示CRT合并结果（两个小结果合成最终答案）；  
- 关键操作（如分解、计算、合并）配“叮”“咔嗒”等像素音效，增强记忆点。


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了以下优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：（来源：new2zy）**  
* **点评**：这份题解是“扩展卢卡斯的标准模板”——思路从问题分析到算法实现一脉相承，对组合数的推导（C(n,w₁)×C(n-w₁,w₂)…）解释得很透彻。代码结构清晰，变量命名规范（比如用mul计算阶乘模质数幂，用C计算组合数），还特别处理了“sum>n”的边界情况。最值得学习的是**扩展卢卡斯的完整实现**：分解P、计算每个质数幂的组合数、CRT合并，每一步都有注释，非常适合新手模仿。

**题解二：（来源：da_AA）**  
* **点评**：此题解的“式子转换”很巧妙——把方案数写成`n!/( (n-sum)! × w₁!×w₂!×…×wₘ! )`，本质和标准组合数乘积一致，但更简洁。代码中ExLucas的实现同样完整，尤其是**阶乘模质数幂的递归计算**（函数fac），逻辑清晰，容易理解。

**题解三：（来源：没名字可被用）**  
* **点评**：这份题解的“细节讲解”最到位——详细解释了如何处理大阶乘（比如递归提取质数因子、利用循环节计算剩余阶乘）。代码中`Cal`函数（计算阶乘模质数幂）的逻辑分步明确，还特别处理了“质数幂次超过k”的情况（此时组合数模质数幂为0），严谨性很强。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决“礼物问题”的核心难点在于**组合数模非质数的计算**，以下是3个关键问题及解决策略：
</difficulty_intro>

### 1. 难点1：组合数模非质数P怎么算？  
**问题**：当P不是质数时，m!或(n-m)!的逆元可能不存在（比如P=4，m=2，2!的逆元不存在）。  
**解决策略**：用扩展卢卡斯拆解问题——把P分解为质数的幂（P=p₁^c₁ × p₂^c₂ × … × p_k^c_k），分别计算C(n,m) mod p_i^c_i，再用CRT合并结果。  

### 2. 难点2：大阶乘（比如1e9!）怎么处理？  
**问题**：n可以达到1e9，直接计算阶乘会超时或溢出。  
**解决策略**：递归提取阶乘中的质数因子，计算剩余部分的阶乘：  
- 例如，计算n! mod p^k时，把n!拆成：p^(n/p) × (n/p)! × 剩余部分（不包含p的因子）；  
- 剩余部分可以用**循环节**快速计算（比如1~p^k-1中不包含p的数的乘积，每p^k个数重复一次）。  

### 3. 难点3：如何合并多个质数幂的结果？  
**问题**：每个质数幂的结果是独立的，怎么合成最终答案？  
**解决策略**：用中国剩余定理（CRT）——如果已知x ≡ a₁ mod m₁，x ≡ a₂ mod m₂，…，且m₁,m₂…互质，那么x mod (m₁×m₂×…)有唯一解。  

💡 **学习笔记**：扩展卢卡斯的核心是“拆解→击破→合并”，把大问题拆成小问题，逐个解决再合并。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一个**通用核心实现**，它综合了优质题解的思路，帮你把握整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：本代码是扩展卢卡斯的标准实现，涵盖P的分解、组合数计算、CRT合并，逻辑清晰。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
typedef long long ll;

// 扩展欧几里得求逆元
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (b == 0) { x = 1; y = 0; return a; }
    ll d = exgcd(b, a%b, y, x);
    y -= a/b * x;
    return d;
}
ll inv(ll a, ll mod) {
    ll x, y;
    exgcd(a, mod, x, y);
    return (x % mod + mod) % mod;
}

// 快速幂
ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod;
        b >>= 1;
    }
    return res;
}

// 计算n! / p^k mod p^m（递归提取p的因子）
ll fac(ll n, ll p, ll mod) {
    if (n == 0) return 1;
    ll res = 1;
    // 计算循环节（1~mod中不包含p的数的乘积）
    for (ll i = 2; i <= mod; i++) if (i % p != 0) res = res * i % mod;
    res = qpow(res, n / mod, mod); // 循环节的n/mod次幂
    // 计算剩余部分（n%mod中不包含p的数的乘积）
    for (ll i = 2; i <= n % mod; i++) if (i % p != 0) res = res * i % mod;
    return res * fac(n / p, p, mod) % mod; // 递归处理n/p!
}

// 计算C(n,m) mod p^m（p是质数）
ll C(ll n, ll m, ll p, ll mod) {
    if (m > n) return 0;
    ll f_n = fac(n, p, mod);
    ll f_m = fac(m, p, mod);
    ll f_nm = fac(n - m, p, mod);
    // 计算p的次数：n!中p的次数 - m!中p的次数 - (n-m)!中p的次数
    ll cnt = 0;
    for (ll i = n; i; i /= p) cnt += i / p;
    for (ll i = m; i; i /= p) cnt -= i / p;
    for (ll i = n - m; i; i /= p) cnt -= i / p;
    // 组合数公式：(f_n / (f_m * f_nm)) * p^cnt mod mod
    return f_n * inv(f_m, mod) % mod * inv(f_nm, mod) % mod * qpow(p, cnt, mod) % mod;
}

// 中国剩余定理合并结果
ll crt(ll a, ll m, ll mod) {
    ll mi = mod / m;
    return mi * a % mod * inv(mi, m) % mod;
}

// 扩展卢卡斯计算C(n,m) mod P
ll exlucas(ll n, ll m, ll P) {
    ll res = 0, tmp = P;
    // 分解P为质数的幂
    for (ll i = 2; i * i <= P; i++) {
        if (tmp % i == 0) {
            ll mod = 1;
            while (tmp % i == 0) mod *= i, tmp /= i;
            res = (res + crt(C(n, m, i, mod), mod, P)) % P;
        }
    }
    if (tmp > 1) res = (res + crt(C(n, m, tmp, tmp), tmp, P)) % P;
    return res;
}

int main() {
    ll P, n, m;
    cin >> P >> n >> m;
    vector<ll> w(m);
    ll sum = 0;
    for (int i = 0; i < m; i++) {
        cin >> w[i];
        sum += w[i];
    }
    if (sum > n) {
        cout << "Impossible" << endl;
        return 0;
    }
    ll ans = 1;
    ll remaining = n;
    for (ll wi : w) {
        ans = ans * exlucas(remaining, wi, P) % P;
        remaining -= wi;
    }
    cout << ans << endl;
    return 0;
}
```
* **代码解读概要**：  
  1. **输入处理**：读取P、n、m和每个w_i，计算sum判断是否Impossible；  
  2. **组合数乘积**：循环计算每个C(remaining, wi)（remaining是剩余礼物数），用exlucas计算；  
  3. **exlucas核心**：分解P→计算每个质数幂的C(n,m)→CRT合并；  
  4. **辅助函数**：fac计算阶乘模质数幂，C计算组合数模质数幂，crt合并结果。


<code_intro_selected>
接下来剖析优质题解的核心片段，看看它们的“亮点”：
</code_intro_selected>

**题解一：（来源：new2zy）**  
* **亮点**：完整实现了扩展卢卡斯的每一步，注释详细，适合新手模仿。  
* **核心代码片段**：
```cpp
ll mul(ll n, ll p, ll pk) { // 计算n! / p^k mod pk
    if (!n) return 1;
    ll ans = 1;
    // 计算循环节（1~pk中不包含p的数的乘积）
    for (ll i = 2; i <= pk; i++) if (i % p) ans = ans * i % pk;
    ans = poww(ans, n / pk, pk); // 循环节的n/pk次幂
    // 计算剩余部分（n%pk中不包含p的数的乘积）
    for (ll i = 2; i <= n % pk; i++) if (i % p) ans = ans * i % pk;
    return ans * mul(n / p, p, pk) % pk; // 递归处理n/p!
}
```
* **代码解读**：  
  这个函数是**阶乘模质数幂的核心**——把n!拆成三部分：  
  1. 循环节的乘积（比如pk=4，p=2，循环节是1×3=3）；  
  2. 循环节的n/pk次幂（比如n=10，循环节重复2次）；  
  3. 剩余部分（比如n=10，剩余1~2，不包含2的数是1）；  
  最后递归处理n/p!（比如10/2=5，计算5!）。  

  💡 **学习笔记**：循环节的使用是处理大阶乘的关键，避免了逐次计算。


**题解二：（来源：da_AA）**  
* **亮点**：式子转换简洁，把组合数乘积写成阶乘的比值，代码更紧凑。  
* **核心代码片段**：
```cpp
ll work() {
    if (tot > n) { puts("Impossible"); return 0; }
    ll ans = 0, tmp = P, pk;
    for (int i = 2; i <= sqrt(P); i++) if (tmp % i == 0) {
        pk = 1;
        while (tmp % i == 0) pk *= i, tmp /= i;
        ans = (ans + CRT(C(i, pk), pk)) % P;
    }
    if (tmp > 1) ans = (ans + CRT(C(tmp, tmp), tmp)) % P;
    return ans;
}
```
* **代码解读**：  
  这个函数是**P的分解与CRT合并的核心**——遍历每个质数i，计算pk=i的幂次，用CRT合并每个C(n,m) mod pk的结果。式子转换后的组合数计算更简洁，适合理解问题本质。  


## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素数学实验室  
我们用8位像素风（像《超级马里奥》一样）演示扩展卢卡斯的过程，让抽象的数学变得直观！

### 🎨 设计思路  
- **复古风格**：用16色像素块、8位字体，营造“童年游戏”的轻松氛围；  
- **互动性**：支持单步执行、自动播放、重置，速度滑块调节动画速度；  
- **音效增强**：分解P时“咔嗒”声，计算阶乘时“叮”声，合并结果时“嗡”声，成功时“胜利音效”；  
- **游戏化元素**：把分解、计算、合并设计成“小关卡”，完成每个关卡得1颗星，收集3颗星通关。


### 📽️ 动画帧步骤  
1. **场景初始化**：  
   - 屏幕显示像素化的“数学实验室”：左边是黑板（写着P=12），中间是工作台（放着像素化的“分解工具”），右边是控制面板（按钮+速度滑块）；  
   - 8位背景音乐（像《坦克大战》的BGM）响起。  

2. **P的分解**：  
   - 黑板上的“12”像素块“裂开”成“2²”和“3¹”，伴随“咔嗒”声；  
   - 两个像素块跳到工作台，分别代表两个质数幂。  

3. **计算组合数模质数幂**：  
   - 以C(4,1) mod 4为例：  
     1. 像素箭头指向“4!”，提取2的因子（4! = 2² × 2! × 1×3）；  
     2. 计算剩余部分的阶乘：1×3=3，2! = 2（再提取2的因子得1）；  
     3. 计算组合数：(3 × 1) / (1 × 1) × 2^(2-1-1) = 3 × 1 = 3 mod 4；  
   - 每一步都有像素动画（比如因子“跳出来”，乘法用“+”号连接）。  

4. **CRT合并结果**：  
   - 工作台的“3 mod 4”和“1 mod 3”像素块“融合”成“3 mod 12”（最终答案），伴随“嗡”声；  
   - 屏幕弹出“通关！”字样，播放胜利音效。


## 6. 拓展练习与相似问题思考

### 🧠 通用思路迁移  
扩展卢卡斯的核心是“**分解与合并**”，适用于所有需要计算**大组合数模非质数**的问题，比如：  
- 计算“从n个元素中选m个的方案数模1e9+7（但1e9+7是质数，用卢卡斯即可）”；  
- 计算“排列数P(n,m)模非质数P”（排列数=组合数×m!，同样可以用扩展卢卡斯）；  
- 解决“组合数的乘积模非质数”问题（比如本题的礼物分配）。


### 📚 相似练习推荐（洛谷）  
1. **P4781 【模板】扩展卢卡斯定理**：直接练习扩展卢卡斯的模板题，巩固分解与合并的技巧；  
2. **P3807 卢卡斯定理**：练习模质数的组合数计算，对比扩展卢卡斯的区别；  
3. **P2290 【HNOI2004】树的计数**：需要计算组合数模非质数，应用扩展卢卡斯解决实际问题；  
4. **P1876 开灯**：虽然是数论问题，但需要分解质因数，练习分解技巧。


## 7. 学习心得与经验分享 (若有)

> **参考经验（来自new2zy）**：“我最初在计算阶乘模质数幂时卡了很久，后来发现要递归提取质数因子，把问题拆成小部分。”  
> **点评**：这位作者的经验很实用——**遇到大问题时，先拆成小问题**。比如计算1e9! mod 1e5，直接算不可能，但拆成循环节+剩余部分+递归，就变得可行了。


## 🎯 总结  
“礼物分配”问题的核心是**扩展卢卡斯定理**，它教会我们：**把复杂问题拆解成可解决的小问题，逐个击破再合并**。通过这道题，你不仅学会了组合数的计算，更掌握了“拆解问题”的思维方法——这对解决所有编程问题都有用！  

记住：编程的乐趣在于“解决问题”，而不是“写代码”。下次遇到难题时，试试“拆解→击破→合并”，你会发现问题没那么难！💪

---
**Kay的小提醒**：如果对扩展卢卡斯的细节还有疑问，不妨试着写一个小例子（比如计算C(4,1) mod 12），手动模拟每一步——实践是最好的老师！

---
处理用时：119.36秒
# 题目信息

# [国家集训队] 航班安排

## 题目背景

1. wqs 爱好模拟飞行。
2. clj 开了一家神犇航空，由于 clj 还要玩游戏，所以公司的事务由你来打理。

注意：题目中只是用了这样一个背景，并不与真实 / 模拟飞行相符。

## 题目描述

神犇航空有 $K$ 架飞机，为了简化问题，我们认为每架飞机都是相同的。神犇航空的世界中有 $N$ 个机场，以 $0\cdots N-1$ 编号，其中 $0$ 号为基地机场，每天 $0$ 时刻起飞机才可以从该机场起飞，并不晚于 $T$ 时刻回到该机场。

一天，神犇航空接到了 $M$ 个包机请求，每个请求为在 $s$ 时刻从 $a$ 机场起飞，在恰好 $t$ 时刻到达 $b$ 机场，可以净获利 $c$。换言之，你只需要在 $s$ 时刻在 $a$ 机场选择提供一架飞机给请求方，那么这架飞机就会在 $t$ 时刻准时出现在 $b$ 机场，并且你将获得 $c$ 的净利润。

设计一种方案，使得总收益最大。

## 说明/提示

对于 $10\%$ 的测试数据，$K=1$；

另有 $20\%$ 的测试数据，$K=2$；

对于全部的测试数据，$1\le N,M\le 200$，$1\le K\le 10$，$1\le T\le 3000$，$1\le t_{i,j}\le 200$，$f_{i,j}\le 2\times 10^3$，$0\le a,b<N$，$0\le s\le t\le T$，$0\le c\le 10000$，$t_{i,i}=f_{i,i}=0$，$t_{ij}\le t_{i,k}+t_{k,j}$，$f_{i,j}\le f_{i,k}+f_{k,j}$。

## 样例 #1

### 输入

```
2 1 1 10
0 5
5 0
0 5
5 0
0 1 0 5 10```

### 输出

```
5```

# AI分析结果

# 💡 Kay的C++算法解析：[国家集训队]航班安排 深入学习指南 💡


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：网络流（最大费用最大流）

🗣️ **初步分析**：  
你可以把“网络流”想象成**水管系统**——水从“源点”出发，通过各种水管（边）流向“汇点”，水管有“容量”（最多能流多少水）和“费用”（每流1单位水的成本）。我们的目标是让**总流量最大**的同时，**总费用最大**（本题是“收益最大”，所以把“费用”换成“收益”即可）。  

在这道题里，“水”就是“飞机的行程”，“水管”就是“订单选择”或“飞机转移”：  
- 每个订单只能做一次？像“单行道水管”，容量设为1。  
- 飞机从基地到订单起点要花钱？水管费用设为“-空载成本”（因为我们要算净收益，成本是支出）。  
- 完成订单能赚钱？水管费用设为“+订单收益”。  
- 飞机数量有限？给源点加个“总阀门”，限制总流量为K（飞机数量）。  

**核心难点**：如何把“订单选择”“时间限制”“飞机转移”转化为网络中的边和点？  
**解决方案**：  
1. **订单拆点**：把每个订单拆成“入点”和“出点”，中间连一条容量1、费用+订单收益的边（确保每个订单只做一次）。  
2. **基地连接**：如果飞机能从基地及时到订单起点，源点连订单入点（费用-空载成本）；如果订单结束能及时回基地，订单出点连汇点（费用-空载成本）。  
3. **订单转移**：如果订单A结束后能及时到订单B的起点，订单A的出点连订单B的入点（费用-空载成本）。  
4. **飞机数量控制**：加一个“超级源点”，连到原来的源点，容量K、费用0（限制总共有K架飞机）。  

**可视化设计思路**：  
用8位像素风展示网络结构：  
- 订单入点是蓝色像素块，出点是绿色像素块，基地是黄色，汇点是红色。  
- 边的流动用“小水滴”动画表示，流动时播放“叮”的像素音效。  
- 完成一个订单（水滴从入点到出点）时，播放“得分”音效，订单块闪烁。  
- 飞机转移时，水滴从订单A的出点“滑”到订单B的入点，伴随“咻”的音效。  


## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性等方面筛选了3份优质题解，帮你快速理解核心逻辑：
</eval_intro>

**题解一：(来源：ycyaw，赞23)**  
* **点评**：这份题解的**建模逻辑最完整**——不仅正确拆点，还详细处理了所有时间限制（基地到订单、订单到基地、订单间转移）。代码结构清晰，费用流模板（SPFA+DFS）实现稳定，注释虽然少但变量名直观（比如`st`是超级源点，`ed`是汇点）。特别值得学习的是**费用的正负处理**：把“空载成本”设为负费用，“订单收益”设为正费用，最后用最大费用流直接计算总收益。

**题解二：(来源：JohnJoeZhu，赞14)**  
* **点评**：这份题解的**建模思路最易懂**——明确选择“订单作为建模对象”，避免了按时间拆点的高复杂度。代码中的“拆点连边”（入点→出点，容量1、费用-订单收益）是经典套路，还贴心提示了“数据保证最短路”（不用手动跑最短路）。美中不足的是代码里多建了一条“入点到入点”的边，但不影响正确性，反而帮你理解“转移的灵活性”。

**题解三：(来源：FreeTimeLove，赞8)**  
* **点评**：这份题解的**费用流实现最细节**——用了“类Dinic的费用流”（Dijkstra+势能优化），解决了SPFA处理负权边的慢问题。代码中的`adds`函数（快捷建边）和`dinic`函数（分层处理）值得借鉴，特别是**势能数组`h`**的使用，优化了最长路的计算。注释详细，适合初学者理解费用流的实现细节。


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的关键是“把现实问题转化为网络流模型”，以下3个难点是最容易卡壳的地方：
</difficulty_intro>

### 1. 如何处理“订单只能做一次”？
**难点**：每个订单是“一次性资源”，不能重复选择。  
**解决方案**：**拆点**！把每个订单拆成“入点”（表示“开始做订单”）和“出点”（表示“完成订单”），中间连一条**容量1、费用+订单收益**的边。这样，流只能走一次这条边，自然限制了订单只能做一次。  
💡 **学习笔记**：拆点是网络流处理“点资源限制”的经典套路！

### 2. 如何处理“时间限制”？
**难点**：飞机必须在订单开始前到达起点，结束后能回基地，或转移到下一个订单。  
**解决方案**：用“边的存在性”表示“时间允许”：  
- 基地→订单入点：如果`基地到订单起点的时间 ≤ 订单开始时间`，连边。  
- 订单出点→基地：如果`订单结束时间 + 订单终点到基地的时间 ≤ T`，连边。  
- 订单A出点→订单B入点：如果`订单A结束时间 + 订单A终点到订单B起点的时间 ≤ 订单B开始时间`，连边。  
💡 **学习笔记**：时间限制转化为“边是否存在”，把“时间条件”变成“建边的前提”。

### 3. 如何处理“K架飞机”？
**难点**：总共有K架飞机，不能超过这个数量。  
**解决方案**：**加超级源点**！新建一个超级源点`S`，连到原来的源点（表示基地），边的**容量K、费用0**。这样，总流量被限制为K，刚好对应K架飞机。  
💡 **学习笔记**：超级源点/汇点是网络流处理“全局限制”的常用技巧！

### ✨ 解题技巧总结
- **建模优先**：先想清楚“什么是点”“什么是边”“容量和费用代表什么”，再写代码。  
- **拆点套路**：遇到“点只能用一次”的情况，直接拆点！  
- **费用正负**：收益设为正费用，成本设为负费用，最后求最大费用流。  
- **模板熟练**：费用流的模板（SPFA/DFS或Dijkstra/势能）要背熟，避免调试时出错。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合优质题解的通用实现**，帮你把握整体框架：
</code_intro_overall>

### 本题通用核心C++实现参考
* **说明**：综合ycyaw、JohnJoeZhu的建模思路，用SPFA+DFS实现费用流，代码简洁易懂。
* **完整核心代码**：
```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int INF = 1e9;
struct Edge { int to, nxt, cap, cost; };
vector<Edge> e;
vector<int> head, pre, flow, dis, vis;
int n, m, K, T, t[205][205], f[205][205];
struct Order { int a, b, s, t, c; } ord[205];

void add_edge(int u, int v, int cap, int cost) {
    e.push_back({v, head[u], cap, cost});
    head[u] = e.size()-1;
    e.push_back({u, head[v], 0, -cost});
    head[v] = e.size()-1;
}

bool spfa(int s, int t) {
    fill(dis.begin(), dis.end(), INF);
    fill(vis.begin(), vis.end(), 0);
    queue<int> q;
    dis[s] = 0; flow[s] = INF; q.push(s); vis[s] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        for (int i = head[u]; i != -1; i = e[i].nxt) {
            Edge &ed = e[i];
            if (ed.cap && dis[ed.to] > dis[u] + ed.cost) {
                dis[ed.to] = dis[u] + ed.cost;
                pre[ed.to] = i;
                flow[ed.to] = min(flow[u], ed.cap);
                if (!vis[ed.to]) { vis[ed.to] = 1; q.push(ed.to); }
            }
        }
    }
    return dis[t] != INF;
}

int mcmf(int s, int t) {
    int cost = 0;
    while (spfa(s, t)) {
        cost += dis[t] * flow[t];
        for (int u = t; u != s; u = e[pre[u]^1].to) {
            e[pre[u]].cap -= flow[t];
            e[pre[u]^1].cap += flow[t];
        }
    }
    return cost;
}

int main() {
    cin >> n >> m >> K >> T;
    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) cin >> t[i][j];
    for (int i = 0; i < n; ++i) for (int j = 0; j < n; ++j) cin >> f[i][j];
    for (int i = 1; i <= m; ++i) {
        cin >> ord[i].a >> ord[i].b >> ord[i].s >> ord[i].t >> ord[i].c;
        ord[i].a++; ord[i].b++; // 转1-based
    }

    // 建图：S=0（超级源点）, base=1（基地）, 订单入点2~m+1, 订单出点m+2~2m+1, T=2m+2（汇点）
    int S = 0, base = 1, T_node = 2*m + 2;
    head.assign(T_node + 1, -1); pre.resize(T_node + 1);
    flow.resize(T_node + 1); dis.resize(T_node + 1); vis.resize(T_node + 1);

    // 超级源点→基地（限制K架飞机）
    add_edge(S, base, K, 0);

    for (int i = 1; i <= m; ++i) {
        int in = i + 1, out = i + 1 + m;
        // 订单入点→出点（容量1，费用-订单收益，因为求最小费用转最大）
        add_edge(in, out, 1, -ord[i].c);
        // 基地→订单入点（如果时间允许）
        if (t[0][ord[i].a] <= ord[i].s) {
            add_edge(base, in, INF, f[0][ord[i].a]);
        }
        // 订单出点→汇点（如果时间允许回基地）
        if (ord[i].t + t[ord[i].b][0] <= T) {
            add_edge(out, T_node, INF, f[ord[i].b][0]);
        }
        // 订单间转移（i→j）
        for (int j = 1; j <= m; ++j) {
            if (i == j) continue;
            if (ord[i].t + t[ord[i].b][ord[j].a] <= ord[j].s) {
                add_edge(out, j + 1, INF, f[ord[i].b][ord[j].a]);
            }
        }
    }

    int res = -mcmf(S, T_node); // 因为费用取反了，结果要反转
    cout << res << endl;
    return 0;
}
```
* **代码解读概要**：  
代码分为3部分：  
1. **输入处理**：读入机场、订单、时间和费用数据。  
2. **建图**：  
   - 超级源点`S`连基地`base`（限制K架飞机）。  
   - 每个订单拆点，入点连出点（限制订单一次）。  
   - 基地连订单入点（时间允许），订单出点连汇点（时间允许）。  
   - 订单间连边（时间允许转移）。  
3. **费用流计算**：用SPFA找最长路（转化为最小费用流，最后反转结果）。


### 题解一：(来源：ycyaw)
* **亮点**：完整的建模逻辑，处理了所有边界条件（比如订单结束后不能回基地的情况直接跳过）。
* **核心代码片段**：
```cpp
// 订单拆点：入点i*2-1 → 出点i*2（容量1，费用+订单收益）
add(i*2-1, i*2, q[i].c, 1);
add(i*2, i*2-1, -q[i].c, 0);
// 订单出点→汇点（时间允许回基地）
if (q[i].t + t[q[i].b][0] <= tim) {
    add(i*2, ed, -w[q[i].b][0], 1e9);
    add(ed, i*2, w[q[i].b][0], 0);
}
// 基地→订单入点（时间允许）
if (t[0][q[i].a] <= q[i].s) {
    add(st+1, i*2-1, -w[0][q[i].a], 1e9);
    add(i*2-1, st+1, w[0][q[i].a], 0);
}
```
* **代码解读**：  
这段代码是**建模的核心**！  
- `add(i*2-1, i*2, q[i].c, 1)`：订单拆点，容量1表示只能做一次，费用`q[i].c`是订单收益。  
- `if (q[i].t + t[q[i].b][0] <= tim)`：判断订单结束后能不能回基地，能的话连边到汇点，费用是`-w[q[i].b][0]`（空载成本，因为收益=收入-成本）。  
- `if (t[0][q[i].a] <= q[i].s)`：判断基地能不能及时到订单起点，能的话连边，费用是`-w[0][q[i].a]`（空载成本）。  
* 💡 **学习笔记**：费用的正负要对应“收益-成本”，记不住的话可以想：“花的钱是负收益，赚的钱是正收益”。


### 题解二：(来源：JohnJoeZhu)
* **亮点**：清晰的建模思路，用“请求作为对象”避免了时间分层的高复杂度。
* **核心代码片段**：
```cpp
// 快捷建边函数（自动建反向边）
void add(int u, int v, int w, int f) {
    add_edge(u, v, w, f); add_edge(v, u, 0, -f);
}
// 订单拆点
add(i, i+m, 1, -q[i].c);
// 基地→订单入点
if (q[i].s >= time[1][q[i].a]) add(t-1, i, inf, f[1][q[i].a]);
// 订单出点→汇点
if (q[i].t + time[q[i].b][1] <= T) add(i+m, t, inf, f[q[i].b][1]);
```
* **代码解读**：  
- `add`函数：简化了建边过程，自动处理反向边（网络流必须的）。  
- `add(i, i+m, 1, -q[i].c)`：订单拆点，容量1，费用`-q[i].c`（因为求最小费用，所以把收益转成负费用）。  
- `if (q[i].s >= time[1][q[i].a])`：判断基地到订单起点的时间是否≤订单开始时间，是的话连边，费用是`f[1][q[i].a]`（空载成本）。  
* 💡 **学习笔记**：用函数封装重复操作（比如建边），能让代码更简洁！


### 题解三：(来源：FreeTimeLove)
* **亮点**：用Dijkstra+势能优化的费用流，解决了SPFA的慢问题。
* **核心代码片段**：
```cpp
// Dijkstra找最长路（势能优化）
bool dij() {
    priority_queue<node> que;
    memset(dis, 0x3f, sizeof dis);
    dis[s] = 0; que.push({0, s});
    while (!que.empty()) {
        int u = que.top().u; que.pop();
        if (bk[u] == cnt) continue;
        bk[u] = cnt; nds[u] = nd[u];
        for (int i = nd[u]; i; i = e[i].nxt) {
            int v = e[i].v;
            if (e[i].w && dis[v] > dis[u] + e[i].x + h[u] - h[v]) {
                dis[v] = dis[u] + e[i].x + h[u] - h[v];
                if (bk[v] != cnt) que.push({dis[v], v});
            }
        }
    }
    return dis[t] < INF;
}
```
* **代码解读**：  
这段代码是**费用流的优化**！  
- `priority_queue<node> que`：用优先队列（堆）找最长路，比SPFA快。  
- `h[u]`：势能数组，用来调整边权，避免负权边的问题（因为订单收益是正的，空载成本是负的，边权有正有负）。  
- `dis[v] = dis[u] + e[i].x + h[u] - h[v]`：调整后的边权，确保都是非负的，这样Dijkstra能正确运行。  
* 💡 **学习笔记**：当边权有负时，用势能优化的Dijkstra比SPFA更高效！


## 5. 算法可视化：像素动画演示

<visualization_intro>
为了帮你直观理解“网络流如何流动”，我设计了一个**8位像素风的动画**，像玩FC游戏一样学算法！
</visualization_intro>

### 动画设计方案
**主题**：像素飞行员的“订单大挑战”（8位FC风格）  
**核心演示内容**：展示网络流的流动过程，包括“飞机从基地出发→做订单→转移订单→回基地”的全流程。

### 设计思路
用8位像素风营造**复古游戏感**，让学习更轻松；用**动画+音效**强化记忆：  
- 订单是“彩色方块”（入点蓝，出点绿），基地是“黄色飞机坪”，汇点是“红色终点”。  
- 流的流动是“小飞机”动画（从源点飞向汇点），每经过一条边播放“咻”的音效。  
- 完成订单时，小飞机“停靠”在订单出点，播放“叮”的音效，订单方块闪烁+得分（+c）。  
- 飞机回基地时，小飞机“降落在黄色坪”，播放“胜利”音效，总收益增加。

### 动画细节
1. **初始化场景**：  
   - 屏幕左侧是“控制面板”：单步/自动播放按钮、速度滑块、重置按钮。  
   - 屏幕右侧是**像素网络**：基地（黄）、订单（蓝→绿）、汇点（红），边是“灰色管道”。  
   - 背景音乐：8位循环BGM（类似《超级马里奥》的轻松旋律）。

2. **单步执行**：  
   - 点击“单步”，小飞机从超级源点（S）流向基地（base），播放“启动”音效。  
   - 再点“单步”，小飞机从基地流向订单入点（蓝方块），管道变亮（表示流经过）。  
   - 再点“单步”，小飞机从订单入点流向出点（绿方块），播放“完成订单”音效，得分+订单收益。  
   - 再点“单步”，小飞机从订单出点流向汇点（红方块），播放“回基地”音效，总收益更新。

3. **自动播放**：  
   - 点击“自动”，小飞机按最优路径自动流动，速度可通过滑块调整（慢→快）。  
   - 每完成一个订单，屏幕底部弹出“得分+XX”的提示，总收益实时更新。

4. **交互设计**：  
   - 点击订单方块，弹出“订单详情”（s、t、c）。  
   - 点击边，弹出“边信息”（容量、费用）。  
   - 重置按钮：恢复初始状态，重新开始动画。

### 技术实现（轻量化）
用**纯HTML/CSS/JavaScript+Canvas**实现：  
- Canvas绘制像素场景：用`fillRect`画方块，`strokeRect`画边。  
- 音效：用`Audio`标签播放8位音效（如`ding.mp3`、`whoosh.mp3`）。  
- 交互：用`addEventListener`处理按钮点击、滑块拖动。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了这道题的建模技巧，你可以解决**所有“资源分配+收益最大化”的问题**！以下是相似练习：
</similar_problems_intro>

### 通用思路迁移
这道题的模型可以推广到：  
1. **任务调度**：有多个任务，每个任务有时间限制和收益，用有限资源（机器）完成任务，求最大收益。  
2. **路径规划**：有多个路径，每条路径有成本和收益，用有限车辆走路径，求最大收益。  
3. **项目选择**：有多个项目，每个项目有启动成本和收益，用有限资金选项目，求最大收益。

### 洛谷练习推荐
1. **P4013 数字梯形问题**：费用流经典题，处理“路径选择+点权限制”，练拆点技巧。  
   🗣️ **推荐理由**：和本题一样需要拆点，帮你巩固“点资源限制”的建模。  
2. **P2045 方格取数**：费用流求“两条路径的最大和”，练多流限制。  
   🗣️ **推荐理由**：用超级源点限制流的数量，和本题的“K架飞机”异曲同工。  
3. **P3381 最小费用最大流**：模板题，练费用流的实现细节（SPFA/DFS、Dijkstra+势能）。  
   🗣️ **推荐理由**：熟悉费用流的基本操作，为复杂建模打基础。


## 7. 学习心得与经验分享

<insights_intro>
从题解中，我总结了3条**实战经验**，帮你少踩坑：
</insights_intro>

1. **建模比代码重要**：  
   题解作者都强调“建模是关键”——如果模型建错了，代码再对也没用。比如，一开始想按时间拆点的同学，都被点数爆炸劝退了，而选“订单作为对象”的同学都做出来了。  
   💡 **教训**：先想清楚“什么是点/边”，再写代码！

2. **费用的正负要搞对**：  
   所有题解都把“订单收益”设为负费用，“空载成本”设为正费用，最后结果反转。这是因为**费用流模板通常求最小费用**，而我们要最大收益，所以要“反转费用”。  
   💡 **技巧**：收益→负费用，成本→正费用，结果→反转！

3. **调试时看流的路径**：  
   很多同学调试时卡壳，是因为“不知道流走了哪条边”。可以在代码里加“输出流路径”的功能，比如每走一条边就打印“u→v，流量f”，这样能快速定位错误。  


## 结语
这道题的核心是**“把现实问题转化为网络流模型”**——拆点处理订单限制，边处理时间条件，超级源点限制飞机数量。只要掌握了建模技巧，所有费用流问题都能迎刃而解！  

记住：**编程的本质是“把问题抽象成模型”**，多练建模，你会越来越强！下次我们再一起挑战更难的算法题～ 💪

---
处理用时：99.53秒
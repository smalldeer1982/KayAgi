# 题目信息

# [集训队互测 2022] 在路上

## 题目背景

滥用本题评测者封号。

dottle bot。

## 题目描述

**这是一道交互题，仅支持 C++ 提交**。

有一棵未知的树，**保证树的大小为奇数，你需要找到这棵树重心的编号**。

你可以进行询问，每次询问你可以询问三个点 $(x,y,z)$，若不存在一条简单路径同时经过三个点，则交互器会返回 $0$，否则若存在，那么交互器会返回三个点在路径上相对顺序中间的一个点。

令 $dis(a,b)$ 表示 $a,b$ 两点在树上最短路径经过的边数，你也可以理解为:

若 $dis(x,y)+dis(x,z)=dis(y,z)$，则交互器会返回 $x$。

否则若 $dis(y,x)+dis(y,z)=dis(x,z)$，交互器会返回 $y$。

否则若 $dis(z,x)+dis(z,y)=dis(x,y)$，交互器会返回 $z$。

否则交互器会返回 $0$。

在最终的测试中，每个测试点会包含 $T$ 组测试数据，和一个常数 $M$，表示你在所有测试数据中询问次数总和的上限，具体细则见 输入格式 以及 数据范围。

#### 实现细节

~~你需要引用 `path.h` 头文件。~~ 本题中你只需要把 `path.h` 头文件的内容粘贴到程序开头即可，不要引用 `path.h` 头文件。

你需要实现下面的函数：

```
int centroid(int id,int N,int M);
```

其中 $id$ 为当前子任务的编号，$N$ 为当前询问树的大小，$M$ 为当前测试点剩余的询问次数，函数的返回值为当前树的重心编号。

具体的，在第一次调用时 $M$ 为当前测试点的询问次数上限，每次调用结束之后 $M$ 会减去当前测试点使用的询问次数。

你可以调用下面的函数：

```
int ask(int x,int y,int z);
```

表示你进行了一次询问，交互器会返回当前询问的答案，特别的，若询问次数已经超过了上限，交互器会返回 $-1$。

注意同一个测试点中 `centroid` 函数可能会被多次调用，请注意数组清空等情况。

**下发文件中有样例交互库，该交互库的实现与评测时的交互库几乎一致，如果对交互方式有不理解可以参照交互库的代码理解**。


## 说明/提示

#### 数据范围

![](https://cdn.luogu.com.cn/upload/image_hosting/f3d6b2zv.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

特殊性质 $A$：保证树的形态为一条链，即每个点的度数均不超过 $2$。

保证每个 Subtask 里的测试数据数量均不超过 $20$。**请仔细阅读每一档子任务及其限制**。

#### 时空限制

Subtask 5 时限为 3s。

Subtask 7,8 时限为 4s。

其余 Subtask 时限为 1s。

空间限制：512MB。

保证最终交互库的时间使用不超过  2s，空间使用不超过 64MB。

#### 下发文件

下发文件中有一个样例交互库，提供的交互头文件，一份示例代码，以及一个满足子任务 $4$ 性质的样例，选手也可以按照题目的输入格式构造其他样例。

另外也有一份洛谷样式的交互库。

保证下发的交互库和最终使用的交互库除反作弊之外没有区别，你可以使用这个交互库输出调试信息。

# AI分析结果

---
# 💡 Kay的C++算法解析：[集训队互测2022]在路上 深入学习指南 💡

<introduction>
今天我们来一起分析“在路上”这道**交互型树论问题**。这道题的核心是通过有限次询问找到未知树的重心，难点在于如何将“树”的问题转化为更易处理的“链”问题，并用随机化技巧高效缩小范围。本指南会帮你梳理思路、理解关键算法，并通过像素动画直观看到过程！
</introduction>


## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`编程技巧应用（随机化与链转化）`

🗣️ **初步分析**：
解决这道题的关键，就像“找绳子的中点”——直接摸整根绳子（树）很难，但**随机选两段绳子（链）**，中点（重心）大概率在这段绳子上！我们的核心思路是：
1. **随机链转化**：随机选两个点`l`和`r`，形成一条链。由于重心的子树大小都不超过`n/2`，重心在这条链上的概率≥50%（期望2次就能选中有效链）。
2. **链上缩范围**：把树上的所有点分到链的左右两侧或链上，再用**随机化二分**慢慢缩小包含重心的区间——就像“折绳子”，每次删掉不可能包含中点的部分。
3. **重心验证**：用摩尔投票法快速判断某个点是否是重心（子树大小都≤`n/2`）。

**核心算法流程与可视化设计**：
- **变量更新**：可视化中用`红色像素块`标记当前链的端点`l`/`r`，`黄色`标记当前随机选的点`k`，`绿色`标记正在验证的重心候选。
- **关键步骤高亮**：每次询问三个点时，这三个点会`闪烁`，返回的中间点会`弹出小气泡`显示结果；缩范围时，被删掉的点会`变淡`，保留的点`变亮`。
- **复古游戏化设计**：加入`8位像素音效`——询问时“叮”一声，缩范围成功“咔嗒”一声，找到重心时播放“胜利进行曲”；设置“单步闯关”模式，每缩一次范围算“过一关”，完成3关后解锁“自动演示”！


## 2. 精选优质题解参考

<eval_intro>
我为大家筛选了一份**4.5星**的优质题解，它的思路巧妙、代码逻辑清晰，完美体现了“树转链+随机化”的核心技巧：
</eval_intro>

**题解一：综合题解内容**
* **点评**：这份题解的“树转链”思路非常亮眼——通过随机选`l`和`r`，把树上的点分到链的左右或链上，直接将树问题转化为链问题！它的`solve`函数巧妙划分了子树（`CL`/`CR`/`SL`/`SR`），用随机点`k`缩范围，每次都能删掉部分不可能包含重心的点。最棒的是`chk`函数用**摩尔投票法**验证重心，避免了复杂的子树大小计算，大幅降低了询问次数。代码中的`vi`（vector<int>）管理子树也很规范，变量名`L`/`R`/`C`/`S`清晰对应“链左”“链右”“链上”“其他”点，可读性很高！


## 3. 核心难点辨析与解题策略

<difficulty_intro>
解决这道题的三个核心难点，就像“闯关游戏”的三个关卡，我们逐一攻破：
</difficulty_intro>

1. **难点1：如何把“树”问题变成“链”问题？**
    * **分析**：树的重心可能在任意位置，但随机选两个点`l`和`r`形成的链，重心在这条链上的概率≥50%（因为重心的子树都不大，必然在某条长链上）。
    * **解决方案**：每次随机选`l`和`r`，把所有点按“在`l`侧”“在`r`侧”“在链上”“其他”分成四类（用`ask(i,l,r)`的结果判断）。如果重心在链上，就转化为链上找“带权中位数”的问题！
    * 💡 **学习笔记**：随机化是解决“不确定问题”的神器，能把复杂的树问题简化为熟悉的链问题！

2. **难点2：如何高效缩小链的范围？**
    * **分析**：链上的点很多，直接遍历太慢。需要一种方法，每次删掉部分点，快速逼近重心。
    * **解决方案**：随机选链上的点`k`，把链分成`CL`（`k`左侧）和`CR`（`k`右侧），再根据子树大小（`sl`/`sr`）判断重心在左侧还是右侧——就像“折绳子”，每次折掉一半！
    * 💡 **学习笔记**：随机化二分能避免最坏情况，让每次缩范围的效率有保证！

3. **难点3：如何验证某个点是重心？**
    * **分析**：重心的定义是“所有子树大小≤n/2”，直接计算每个子树大小需要很多询问，效率低。
    * **解决方案**：用**摩尔投票法**！遍历所有点，判断是否和当前候选点属于同一子树（用`ask(rt,i,col)==rt`），如果超过一半点属于同一子树，说明候选点不是重心——反之则是！
    * 💡 **学习笔记**：摩尔投票法不仅能找众数，还能快速验证“是否大多数元素满足条件”！

### ✨ 解题技巧总结
- **技巧1：随机化简化问题**：面对不确定的树结构，随机选链能快速锁定重心的大致位置。
- **技巧2：分类管理子树**：用vector把点分成不同类别（链左/链右/链上/其他），清晰又高效。
- **技巧3：摩尔投票验证**：用投票法代替直接计算子树大小，大幅减少询问次数。


## 4. C++核心代码实现赏析

<code_intro_overall>
先看一份**综合了题解思路的通用核心实现**，帮你把握整体框架：
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了题解的“树转链+随机化二分”思路，保留了核心逻辑（如随机选链、子树划分、摩尔投票验证），去掉了针对特定子任务的优化，更易理解。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <random>
    #include <algorithm>
    #include <numeric>
    using namespace std;

    extern "C" int ask(int x, int y, int z);
    mt19937 rnd(random_device{}());
    int n;

    // 验证k是否是重心
    int check_centroid(int k, const vector<int>& all_nodes) {
        int cnt = 0, candidate = 0;
        // 摩尔投票找可能的子树众数
        for (int u : all_nodes) {
            if (u == k) continue;
            if (cnt == 0) {
                candidate = u;
                cnt = 1;
            } else {
                if (ask(k, u, candidate) == k) cnt--;
                else cnt++;
            }
        }
        // 统计candidate所在子树的大小
        int size = 0;
        for (int u : all_nodes) {
            if (u == k) continue;
            if (ask(k, u, candidate) != k) size++;
        }
        return (size <= n / 2) ? k : -1;
    }

    // 处理链[l, r]，返回重心
    int solve_chain(int l, int r, const vector<int>& L, const vector<int>& R, 
                    const vector<int>& C, const vector<int>& S) {
        if (L.size() > n / 2) return check_centroid(l, L);
        if (R.size() > n / 2) return check_centroid(r, R);
        if (l == r) return check_centroid(l, S);
        
        // 随机选链上的点k
        int k = l;
        while (k == l || k == r) {
            int rd = rnd() % (C.size() + S.size());
            if (rd < (int)C.size()) k = C[rd];
            else {
                int t = S[rd - C.size()];
                for (int u : C) if (ask(k, t, u) == u) k = u;
            }
        }

        // 划分子树
        vector<int> CL, CR, SL, SR, SK;
        for (int u : C) if (u != k) {
            if (ask(l, u, k) == u) CL.push_back(u);
            else CR.push_back(u);
        }
        for (int u : S) {
            if (ask(l, k, u) == k) {
                if (ask(r, k, u) == k) SK.push_back(u);
                else SR.push_back(u);
            } else SL.push_back(u);
        }

        int sl = L.size() + CL.size() + SL.size();
        int sr = R.size() + CR.size() + SR.size();
        if (sr > sl) {
            swap(l, r); swap(L, R); swap(CL, CR); swap(SL, SR);
        }
        return solve_chain(l, k, L, vector<int>{k}, CL, SL);
    }

    extern "C" int centroid(int id, int N, int M) {
        n = N;
        while (true) {
            // 随机选链的两个端点l和r
            int l = rnd() % n + 1, r = rnd() % n + 1;
            if (l == r) continue;

            // 分类所有点
            vector<int> L, R, C{l, r}, S;
            for (int u = 1; u <= n; u++) {
                if (u == l || u == r) continue;
                int res = ask(u, l, r);
                if (res == l) L.push_back(u);
                else if (res == r) R.push_back(u);
                else if (res == u) C.push_back(u);
                else S.push_back(u);
            }

            // 处理链，验证重心
            int candidate = solve_chain(l, r, L, R, C, S);
            if (candidate != -1) return candidate;
        }
    }
    ```
* **代码解读概要**：
    > 代码分为三部分：1）`check_centroid`用摩尔投票法验证重心；2）`solve_chain`处理链上的缩范围逻辑，随机选点划分子树；3）`centroid`主函数随机选链，分类所有点，调用`solve_chain`找重心。核心逻辑是“随机链→分类点→链上缩范围→验证重心”。


<code_intro_selected>
接下来赏析题解中的**核心片段**，看看关键思路是如何实现的：
</code_intro_selected>

**题解一：综合题解内容**
* **亮点**：用`vector`分类点，用随机化快速缩范围，摩尔投票法验证重心，逻辑紧凑高效。
* **核心代码片段（solve函数中的子树划分）**：
    ```cpp
    vector <int> CL,CR,SK,SL,SR;
    for(int i:C) if(i!=k) {
        if(ask(l,i,k)==i) CL.push_back(i);  // i在k左侧（链上）
        else CR.push_back(i);               // i在k右侧（链上）
    }
    for(int i:S) {
        if(ask(l,k,i)==k) {                 // i在l→k的链上
            if(ask(r,k,i)==k) SK.push_back(i); // i在k的子树内
            else SR.push_back(i);            // i在r侧
        } else SL.push_back(i);             // i在l侧
    }
    ```
* **代码解读**：
    > 这段代码的作用是**把所有点分到k的左右两侧或子树内**。比如：
    > - 对于链上的点`i`（属于`C`），用`ask(l,i,k)==i`判断：如果成立，说明`i`在`l`到`k`的链上（`CL`）；否则在`k`到`r`的链上（`CR`）。
    > - 对于其他点`i`（属于`S`），先用`ask(l,k,i)==k`判断是否在`l→k`的链上——如果是，再用`ask(r,k,i)==k`判断是否在`k`的子树内（`SK`），否则在`r`侧（`SR`）；如果不在`l→k`的链上，就分到`l`侧（`SL`）。
    > 这样划分后，我们就能知道重心在`k`的左侧还是右侧，继续缩范围！
* 💡 **学习笔记**：用`ask`的结果分类点，是将树问题转化为链问题的关键操作！


## 5. 算法可视化：像素动画演示 (核心部分)

<visualization_intro>
为了让大家直观看到“树转链+随机化缩范围”的过程，我设计了一个**8位像素风的“重心探险家”动画**，结合复古游戏元素，边玩边学！
</visualization_intro>

### 🎮 动画设计方案
* **动画主题**：像素探险家在“树森林”中找重心，通过“选链→缩范围→验证”三个关卡，最终找到“重心宝藏”。
* **设计思路**：用8位像素风营造复古氛围，用**音效+闯关**强化记忆——每完成一步操作像“过一关”，增加成就感；关键操作有音效提示，让你“听得到”算法的脚步！


### 🕹️ 动画帧步骤与交互细节
1. **场景初始化（FC游戏风）**：
   - 屏幕左侧是**像素树**：用`深绿色方块`表示树节点，`浅绿色线条`表示边；右侧是**控制面板**（带“开始/暂停”“单步”“重置”按钮，速度滑块，“关卡进度”条）。
   - 播放8位风格的背景音乐（类似《超级马里奥》的轻松旋律），控制面板的按钮用`黄色像素块`标记，点击时有“咔嗒”声。

2. **算法启动：随机选链**：
   - 随机选两个点`l`和`r`，用`红色闪烁方块`标记（像游戏中的“起点”和“终点”）。
   - 遍历所有点，用`ask(u,l,r)`的结果分类：`l`侧点变`浅蓝色`，`r`侧点变`浅红色`，链上点变`黄色`，其他点变`灰色`——就像“给树染色”！
   - 选链成功时，播放“叮”的音效，关卡进度条前进10%。

3. **核心步骤：缩范围**：
   - 随机选链上的点`k`，用`橙色闪烁方块`标记（像游戏中的“当前目标”）。
   - 划分子树时，被删掉的点（比如左侧子树太大，删掉右侧）会`慢慢变淡`，保留的点`变亮`——就像“折绳子”缩小范围！
   - 每次缩范围成功，播放“咔嗒”声，关卡进度条前进20%。

4. **验证重心：摩尔投票**：
   - 候选点`k`用`绿色方块`标记（像游戏中的“宝藏”）。
   - 遍历所有点时，每个点会`闪烁一次`，如果属于`k`的子树，就“跳一下”——就像“投票”给`k`！
   - 验证成功时，播放`胜利进行曲`（8位风格），屏幕弹出“找到重心啦！”的像素文字，关卡进度条满格！

5. **交互控制**：
   - **单步模式**：点击“单步”按钮，每步展示一个操作（选点→询问→分类→缩范围），适合仔细观察。
   - **自动模式**：点击“自动”按钮，动画按设定速度播放（速度滑块可调），适合快速看整体流程。
   - **重置**：点击“重置”按钮，回到初始状态，重新开始游戏。


## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了“树转链+随机化”的技巧，你可以解决更多类似问题！
</similar_problems_intro>

### 通用思路迁移
- **场景1**：找树的直径（最长链）——随机选点找最远点，再找最远点的最远点，就是直径。
- **场景2**：找带权树的中位数——把树转化为链，用类似的方法找带权中位数。
- **场景3**：交互题中找特定节点（如中心节点）——用随机化缩小范围，减少询问次数。

### 洛谷练习推荐
1. **洛谷 P1395 树的重心**（非交互版）
   * 🗣️ **推荐理由**：经典的找重心问题，用DFS计算子树大小，巩固重心的基本概念。
2. **洛谷 P5022 旅行**（图论中的链处理）
   * 🗣️ **推荐理由**：需要将图转化为链，处理路径问题，锻炼“链转化”的思维。
3. **洛谷 P3369 普通平衡树**（带权中位数）
   * 🗣️ **推荐理由**：平衡树的带权中位数操作，和本题的“链上找重心”思路异曲同工。


## 7. 学习心得与经验分享 (若有)

<insights_intro>
题解中的**随机化技巧**和**摩尔投票法**是非常宝贵的经验，我帮大家提炼出来：
</insights_intro>

> **参考经验**：“随机选链能快速锁定重心的大致位置，摩尔投票法避免了复杂的子树计算，这两个技巧让我从‘暴力枚举’的泥潭中跳了出来！”
>
> **点评**：这位作者的经验很实用——面对复杂的树问题，**随机化**能简化问题，**摩尔投票法**能优化验证步骤。下次遇到类似问题，不妨试试这两个技巧！


<conclusion>
本次关于“在路上”的C++解题分析就到这里。这道题的核心是“树转链+随机化”，通过将复杂的树问题转化为熟悉的链问题，再用随机化快速缩小范围，最终找到重心。希望这份指南能帮你掌握交互题的解题技巧，下次遇到类似问题时，也能像“像素探险家”一样轻松闯关！💪
</conclusion>

---

---
处理用时：85.74秒
# 题目信息

# 【模板】Matrix-Tree 定理

## 题目描述

给定一张 $n$ 个结点 $m$ 条边的带权图（可能为无向图，可能为有向图）。

定义其一个生成树 $T$ 的权值为 $T$ 中所有边权的乘积。

求其所有不同生成树的权值之和，对 $10^9+7$ 取模。

---

注意：

1. 本题中，有向图的生成树指的是 **以 $1$ 为根的外向树**；

2. 两棵生成树 $T_1,T_2$ 不同，当且仅当存在存在一条边 $e$，满足 $e\in T_1,\ \ e\notin T_2$。

## 说明/提示

【样例 $1$ 解释】

样例 $1$ 中的无向图如左图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/pxtx9z5a.png)

右图为其一个权值为 $3\times 1\times 2\times 3=18$ 的生成树的例子。

---

【样例 $2$ 解释】

样例 $2$ 中的有向图如左图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/4276yln3.png)

右图为其一个权值为 $1\times 1\times 1\times 2=2$ 的生成树（以 $1$ 为根的外向树）的例子。

---

【数据范围】

对于 $100\%$ 的数据：$1\leq n\leq 300,\ \ 1\leq m\leq 10^5,\ \ t\in \{0,1\},\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^9$。

对于测试点 $1,2,3,4,5,6$，$t=0$；对于测试点 $7,8,9,10,11$，$t=1$。

图中 **可能** 存在重边和自环，重边算作多条边。

## 样例 #1

### 输入

```
5 8 0
2 3 1
1 2 3
4 5 1
4 2 2
3 5 2
3 4 3
3 4 1
3 3 5
```

### 输出

```
144
```

## 样例 #2

### 输入

```
5 9 1
1 2 3
3 2 1
1 3 1
2 4 2
3 5 1
4 3 4
3 5 1
5 4 1
4 4 6
```

### 输出

```
72
```

# AI分析结果


### 💡 Kay的C++算法解析：Matrix-Tree定理 深入学习指南 💡

> 今天我们来一起分析“Matrix-Tree定理”这道C++编程题。本指南将帮助大家梳理题目思路，理解核心算法，并掌握解题技巧。

---

## 1. 题目解读与核心算法识别

✨ **本题主要考察**：`图论/矩阵树定理`  
🗣️ **初步分析**：
> 解决“Matrix-Tree定理”这道题，关键在于理解并运用**矩阵树定理（Matrix-Tree Theorem）**。简单来说，这就像一张“魔法网”，通过构建特殊的基尔霍夫矩阵并计算其行列式，就能直接得到所有生成树的权值和（权值为边权乘积）。  
> - **无向图**：基尔霍夫矩阵 = 度数矩阵 - 邻接矩阵，删任意行列求行列式  
> - **有向图**（外向树）：基尔霍夫矩阵 = 入度矩阵 - 邻接矩阵，删根节点行列  
> - **核心难点**：正确构建矩阵（区分无向/有向图），处理带权边（权值视为重边），行列式求值（非质数模需辗转相除）  
> - **可视化设计**：像素动画将展示矩阵构建过程（度数/邻接矩阵更新）和高斯消元步骤（行交换、消元、三角化），关键变量用颜色标记，如度数矩阵对角线**黄色**，邻接矩阵**蓝色**，消元过程**绿色箭头**指示。  
> - **复古游戏化**：8-bit音效（行交换“哔”，消元“滴”，完成“胜利音效”），控制面板支持单步/自动播放（调速滑块），矩阵变换设计为“魔法阵激活”特效。

---

## 2. 精选优质题解参考

> 从思路清晰度、代码规范性和算法有效性等维度，我为大家筛选了以下评分≥4星的优质题解：

**题解一（command_block，131赞）**  
* **点评**：思路清晰，推导严谨（详细解释行列式性质），代码规范（变量名`f[i]`含义明确）。算法高效（O(n³)），用辗转相除避免除法，适合任意模数。实践价值高（直接用于竞赛），边界处理严谨。亮点在于有向图处理简洁，直接构建入度基尔霍夫矩阵并删根节点行列。

**题解二（Achtoria，63赞）**  
* **点评**：理论深入，完整证明Matrix-Tree定理（含Cauchy-Binet公式）。代码较少但逻辑清晰，侧重理解原理。亮点在于关联矩阵和引理证明，帮助理解定理本质，适合想深挖理论的学习者。

**题解三（zhylj，55赞）**  
* **点评**：证明独特（组合数学+线性代数），代码规范。亮点在于将边权转化为重边，统一处理带权图，并用行列式性质简化计算。高斯消元实现简洁，适合掌握基础的学习者。

---

## 3. 核心难点辨析与解题策略

> 解决此类问题的关键难点与策略：

1. **难点1：基尔霍夫矩阵的构建**  
   * **分析**：无向图用度数矩阵，有向图（外向树）用入度矩阵。带权边需视为重边（权值z → z条边）。  
   * 💡 **学习笔记**：有向图删根节点行列（如根=1则删第1行/列）  
   
2. **难点2：行列式求值（模非质数）**  
   * **分析**：模数非质数时，需用辗转相除法代替逆元。每次选主元交换行，下方行反复减主元行直至归零，注意符号变化。  
   * 💡 **学习笔记**：消元时符号变量记录交换次数，最终结果需调整符号  
   
3. **难点3：有向图的方向处理**  
   * **分析**：外向树（根→叶）用入度矩阵L_in（边u→v：L[v][v]+=w, L[u][v]-=w），内向树则用出度矩阵。  
   * 💡 **学习笔记**：题目明确要求“以1为根的外向树”，务必用入度矩阵  

### ✨ 解题技巧总结
1. **问题抽象**：将带权图转化为重边图，统一用Matrix-Tree处理  
2. **模块化代码**：分离矩阵构建和行列式计算函数  
3. **边界测试**：空图、单点图、无边图需特排行列式=0  
4. **调试技巧**：输出中间矩阵验证构建正确性  

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合优质题解思路，支持无向/有向图的通用实现  
* **完整核心代码**：
```cpp
#include <vector>
using namespace std;
typedef long long LL;
const int MOD = 1e9+7;

// 辗转相除求行列式（支持模非质数）
LL det(vector<vector<LL>> a, int n) {
    LL res = 1;
    bool sign = false;
    for (int i = 0; i < n; ++i) {
        int pivot = i;
        for (int j = i; j < n; ++j) 
            if (a[j][i]) { pivot = j; break; }
        if (!a[pivot][i]) return 0;
        if (pivot != i) {
            swap(a[i], a[pivot]);
            sign = !sign;
        }
        for (int j = i+1; j < n; ++j) {
            while (a[j][i]) {
                LL t = a[i][i] / a[j][i];
                for (int k = i; k < n; ++k) 
                    a[i][k] = (a[i][k] - t * a[j][k] % MOD + MOD) % MOD;
                swap(a[i], a[j]);
                sign = !sign;
            }
        }
        res = res * a[i][i] % MOD;
    }
    return sign ? (MOD - res) % MOD : res;
}

int main() {
    int n, m, op;
    cin >> n >> m >> op;
    vector<vector<LL>> K(n, vector<LL>(n, 0));
    
    // 构建基尔霍夫矩阵
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        u--; v--;  // 0-indexed
        if (op == 0) {  // 无向图
            K[u][u] = (K[u][u] + w) % MOD;
            K[v][v] = (K[v][v] + w) % MOD;
            K[u][v] = (K[u][v] - w + MOD) % MOD;
            K[v][u] = (K[v][u] - w + MOD) % MOD;
        } else {        // 有向图（外向树）
            K[v][v] = (K[v][v] + w) % MOD;  // 入度矩阵更新
            K[u][v] = (K[u][v] - w + MOD) % MOD;
        }
    }
    
    // 删根节点行列（根=1 → 删第0行/列）
    vector<vector<LL>> subK(n-1, vector<LL>(n-1));
    for (int i = 1; i < n; ++i)
        for (int j = 1; j < n; ++j)
            subK[i-1][j-1] = K[i][j];
    
    cout << det(subK, n-1);
}
```
* **代码解读概要**：  
  1. 读入图参数（n,m,op）  
  2. 构建基尔霍夫矩阵K：无向图更新对角线和邻接，有向图更新入度矩阵  
  3. 删根节点行列（subK）  
  4. 计算子矩阵行列式（辗转相除法）  

**题解一片段赏析**  
* **来源**：command_block  
* **亮点**：用`while(a[j][i])`实现辗转相除，避免模数限制  
* **核心代码**：
  ```cpp
  while (a[j][i]) {
      LL t = a[i][i] / a[j][i];
      for (int k = i; k < n; ++k) 
          a[i][k] = (a[i][k] - t * a[j][k]) % MOD;
      swap(a[i], a[j]);  // 交换行继续消去
      sign = !sign;
  }
  ```
* **代码解读**：  
  > 当`a[j][i]`非零时，计算倍数`t`，用第`i`行减去`t`倍第`j`行。  
  > 交换两行使主元位置非零，同时记录符号变化。  
  > 循环直到`a[j][i]=0`，避免除法实现任意模数消元。  
* 💡 **学习笔记**：辗转相除是处理非质数模的核心技巧，时间复杂度O(n³)。  

---

## 5. 算法可视化：像素动画演示

> 为直观理解Matrix-Tree定理，设计复古像素动画演示算法流程：

* **主题**：8-bit风格“矩阵魔法阵”  
* **核心演示**：基尔霍夫矩阵构建 + 高斯消元求行列式  
* **设计思路**：  
  - 像素网格展示矩阵，度数字段**黄光闪烁**，邻接字段**蓝光流动**  
  - 消元时主元行**红光高亮**，消元过程用**绿色箭头**指示数值流动  

* **动画步骤**：  
  1. **场景1：矩阵构建**  
     - 像素节点（圆点）间画边，添加边权时：  
       - 度数字段`[i][i]` +w → 黄色像素块数值增加  
       - 邻接字段`[i][j]` -w → 蓝色像素块数值减少  
     - 音效：添加边时“叮”，数值更新“滴答”  

  2. **场景2：高斯消元**  
     - **步进控制**：点击“单步”执行下一步  
     - 帧1：选主元（当前列主元**红光闪烁**）  
     - 帧2：行交换（两行像素块**上下滑动交换**，伴“哔”声）  
     - 帧3：消元（主元行下方**绿色箭头流动**，显示`a[j][k] -= t*a[i][k]`）  
     - 帧4：三角矩阵生成（对角线**金光闪烁**，计算乘积）  

  3. **交互设计**：  
     - **控制面板**：开始/暂停、单步、重置按钮 + 速度滑块  
     - **自动演示**：点击“AI运行”自动播放（速度可调），模拟贪吃蛇式流程推进  
     - **音效**：胜利时播放16-bit胜利旋律，失败（行列式=0）播放低沉提示音  

  4. **状态提示**：  
     - 顶部文字框显示当前操作（如“添加边(1→2,w=3)”、“消元：行2 -= 2×行1”）  
     - 右侧显示行列式当前值（像素数字实时更新）  

![关键帧示意图](https://i.imgur.com/pixel_matrix.gif)  
（示意图：左侧图结构→中间矩阵构建→右侧消元过程）

---

## 6. 拓展练习与相似问题思考

> 掌握Matrix-Tree定理后，可迁移解决以下问题：

* **通用技巧迁移**：  
  Matrix-Tree不仅求生成树数量，还能：  
  1. 带权生成树权值和（边权→重边）  
  2. 有向图树形图计数（出/入度矩阵区分）  
  3. 欧拉回路计数（结合BEST定理）  

* **练习推荐（洛谷）**：  
  1. **P4336 [SHOI2016]黑暗前的幻想乡**  
     🗣️ *推荐理由*：无向图生成树计数+容斥原理，巩固矩阵构建  
  2. **P3317 [SDOI2014]重建**  
     🗣️ *推荐理由*：带概率边权的生成树，练习边权转化为乘积  
  3. **P5807 【模板】BEST定理**  
     🗣️ *推荐理由*：有向图欧拉回路计数，结合内向树与Matrix-Tree  

---

## 7. 学习心得与经验分享

> 题解中值得借鉴的经验：

**参考经验 (command_block)**：  
> “我在处理有向图时最初混淆出/入度矩阵，后来通过模拟小样例（如3节点链）验证矩阵构建正确性。”  

**点评**：  
> 这位作者的经验极具普适性。**动手模拟小样例**是调试矩阵类算法的黄金准则，可快速定位构建错误。建议学习者对样例2（5节点有向图）手动计算矩阵，对比代码输出。  

---

> 本次关于“Matrix-Tree定理”的C++解题分析就到这里。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪

---
处理用时：244.64秒
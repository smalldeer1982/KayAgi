# 题目信息

# [CTS2025] 通信（无法评测）

## 题目背景

IOI 2025 中国国家队选拔 d2t2。

## 题目描述


**这是一道通信题。**

有若干个节点，它们一开始分别存储有一个数字 $a_i \in \{0, 1\}$，它们想要通过 $K$ 轮通信知道其它每个节点存储的数字。

每一轮通信开始的时候，每个节点 $i$ 对每个节点 $j$，都会选择一个数字 $c_{i,j} \in \{0, 1\}$，表示它将会向节点 $j$ 发送数字 $c_{i,j}$，而在这轮通信结束的时候，节点 $j$ 会收到所有节点向它发送的数字的和，具体而言节点 $j$ 会收到一个数字 $s_j = \sum_{i} c_{i,j}$。

现在给定 $K$，你需要找到一个尽量大的 $N$，满足在通过 $K$ 轮通信之后每个节点都可以知道所有节点存储的数字。

### 实现细节

**你不需要，也不应该实现 `main` 函数。**

你应确保提交的程序包含头文件 `message.h`，可在程序开头加入以下代码实现：

```cpp
#include "message.h"
```

你需要实现以下函数：

1. `int init(int K);`
   - 该函数传入通信总轮数 $K$ 的值。**保证** $1 \leq K \leq 7$。
   - 该函数需要返回你选择的节点数量 $N$，**你需要保证** $1 \leq N \leq 31$。
   - 对于每次代码运行，**保证在任意 `send` 函数调用前，该函数会被交互库调用恰好一次**。

2. `unsigned int send(int K, int N, int round, int number, const std::vector<int>& received);`
   - 该函数传入通信总轮数 $K$，你实现的 `init` 函数返回的节点数量 $N$，当前通信的轮数 `round`，当前你需要实现的节点的编号 `number`，当前节点之前通信的轮数中收到的数字 `received`，其中 `received[0]` 表示这个节点一开始存储的数字，而 `received[i] (1 \leq i < \text{round})` 表示这个节点第 $i$ 轮通信结束的时候收到的数字。**保证** $1 \leq K \leq 7$，$1 \leq \text{round} \leq K + 1$，$0 \leq \text{number} < N$，**且 `received` 的长度为 `round`**。
   - 若 $1 \leq \text{round} \leq K$，你需要返回一个无符号三十二位整数 $x$ 表示在这轮通信中节点 `number` 发送给所有节点的数字，其中 $x$ 的第 $i$ 位为节点 `number` 发送给节点 $i$ 的数字，高位用 $0$ 补齐。
   - 若 $\text{round} = K + 1$，你需要返回一个无符号三十二位整数 $x$ 表示节点 `number` 经过 $K$ 轮通信后确定的每个节点存储的数字，其中 $x$ 的第 $i$ 位为编号为 $i$ 的节点存储的数字，高位用 $0$ 补齐。
   - 对于每次代码运行，**保证该函数会被交互库调用不超过 $3 \times 10^4$ 次**。

注意：你需要保证，对于任意两次传入参数相同的函数调用（包括 `init` 和 `send`），返回值也应当相同，否则你的程序将会直接被判定为错误。

题目保证在规定的限制下，交互库在每次代码运行中的运行时间不会超过 $100\, \mathrm{ms}$；交互库使用的内存大小固定，且不超过 $64\, \mathrm{MiB}$。这意味着在每次代码运行中你的代码可以使用至少 $900\, \mathrm{ms}$ 的时间和 $448\,\mathrm{MiB}$ 的空间。


## 说明/提示


### 测试程序方式

**下发文件中的 `implementer.cpp`，`communicator.cpp` 是提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此你的解法不应该依赖交互库实现。**

将你的程序命名为 `message.cpp` 并放置于下发文件目录下后，你可以在下发文件目录下使用如下命令进行测试：

```bash
bash run.sh
```

上述脚本将从**标准输入**读入以下格式的数据：

- 输入的第一行一个整数 $0$。
- 输入的第二行两个正整数 $T, K$，其中 $T$ 表示进行通信的次数，$K$ 表示每次通信的轮数。你需要保证 $1 \leq T \leq 101$，$1 \leq K \leq 7$。
- 输入的第 $i + 2 (0 \leq i < T)$ 行一个无符号三十二位整数 $x_i$，表示第 $i$ 次通信时每个节点初始存储的数字，其中 $x_i$ 的第 $j$ 位表示 $j$ 号节点初始存储的数字。你需要保证 $\forall 0 \leq i < T, 0 \leq x_i < 2^{32}$。

上述脚本将输出以下格式的数据到**标准输出**：

- 若通信结果正确，则输出一行一个正整数 $N$，表示调用函数 `init()` 得到的结果；
- 若通信结果错误，则输出 `Wrong answer!`。

### 下发文件说明

在下发文件中：

1. `implementer.cpp`，`communicator.cpp` 是提供的交互库参考实现。
2. `message.h` 是头文件，你不需要关心其具体内容。
3. `template_message.cpp` 是提供的示例代码，你可以在此代码的基础上实现。

### 子任务

对于所有测试数据，保证 $1 \leq K \leq 7$，且对于每次代码运行，`send` 会被交互库调用不超过 $3 \times 10^4$ 次。


| 测试点编号 | 分值 | $K =$ |
|:------------:|:------:|:-------:|
| $1$          | $5$   | $1$     |
| $2$          | $5$   | $2$     |
| $3$          | $10$   | $3$     |
| $4$          | $15$   | $4$     |
| $5$          | $15$   | $5$     |
| $6$          | $20$   | $6$     |
| $7$          | $30$   | $7$     |
### 评分方式

**注意**：

- 你不应当通过非法方式获取交互库的内部信息，如试图直接读取交互库中存储的值，或直接与标准输入、输出流进行交互。此类行为将被视为作弊；
- **最终的评测交互库与样例交互库的实现有所不同，因此你的解法不应该依赖交互库实现。**

**本题首先会受到和传统题相同的限制**，例如编译错误会导致整道题目得 0 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 0 分等。你只能在程序中访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。

在上述条件基础上，在每个测试点中，程序得到的分数将按照以下方式计算：

- 若对于任意两次传入参数相同的该函数调用，返回值不同，则获得 0 分；
- 若 $K$ 轮通信后确定的每个节点存储的数字与每个节点初始存储的数字不同，则获得 0 分；
- 否则设 $N$ 为调用函数 `init()` 得到的结果，则该测试点的得分为 $s \times {0.7}^{\max(C(K) - N, 0)}$，其中 $s$ 为该测试点的分值，$C(K)$ 的计算方式如下表所示：

$$
\begin{array}{c|c}
K & C(K) \\
\hline
1 & 2 \\
2 & 4 \\
3 & 6 \\
4 & 11 \\
5 & 14 \\
6 & 21 \\
7 & 25 \\
\end{array}
$$

# AI分析结果


### 💡 洛语云笺的C++算法解析：通信题 深入学习指南 💡

#### **1. 题目解读与策略初探**
✨ **本题核心挑战**：在有限通信轮次（K≤7）内，使所有节点共享初始二进制数据（每个节点存储0/1），突破信息传递效率瓶颈。  
✨ **核心算法标签**：构造算法、图论匹配、随机化搜索  

🗣️ **初步分析**：  
> 问题要求设计通信协议，使节点通过K轮交互获知全局信息。核心矛盾在于：  
> - **信息约束**：每轮节点仅能发送1位给其他节点，但接收所有节点发来数据的和（0-N的整数）  
> - **效率瓶颈**：需最大化节点数N，超越对称策略限制（如K=7时N=20）  
>  
> 解题思路演进：  
> 1. **朴素对称策略**：每轮固定传递新节点信息（K=7时N=20，仅得43分）  
> 2. **二进制编码突破**：单轮传递多位信息，但需满足"≥2ᵏ节点已知目标值"的传输条件  
> 3. **非对称搜索策略**：打破对称性，构造每轮各节点差异化的信息获取路径  

🔍 **算法侦探：如何在题目中发现线索？**  
1. **线索1（问题目标）**：  
   "最终要求所有节点获知全局状态" → 本质是**信息传播最优化问题**，需高效利用每轮通信的信息容量（log₂(N+1)比特/节点/轮）  
2. **线索2（约束特性）**：  
   "发送值依赖已知信息" → 存在**动态依赖链**，必须设计信息获取顺序，确保传输时已有足够节点知晓目标值  
3. **线索3（数据规模）**：  
   "K≤7且N≤31" → 允许**状态空间搜索**（节点数少），但需智能剪枝应对组合爆炸  

🧠 **思维链构建：从线索到策略**  
> "整合线索：  
> 1. 【线索1】要求高信息密度传输 → 自然想到二进制编码方案  
> 2. 【线索2】依赖关系需满足Hall条件（传输目标值v时，已知v的节点数≥2ᵏ）→ 需构造信息传播图  
> 3. 【线索3】K小N中→搜索可行，但需优化避免组合爆炸  
>  
> **结论**：通过**随机化搜索+匹配验证**，构造每轮各节点的信息获取集合，使其满足二进制传输的前置条件，最终突破对称策略上限！"  

---

#### **2. 精选优质题解参考**
**题解一（作者：_Ch1F4AN_）**  
* **亮点**：  
  - 提出**带权随机决策模型**（如权重[8,8,2,2,2,1]），高效生成信息获取序列  
  - 针对K=6/7，发现**第二轮约束条件**（前4高频位置需满足≥[7,7,3,1]），大幅缩减搜索空间  
  - 实现26ms快速求解（K=6:N=22, K=7:N=26），突破满分线  

**题解二（作者：Milmon）**  
* **亮点**：  
  - 建立**信息论分析框架**：证明每轮信息上限log₂(N+1)比特，指导N上界  
  - 设计**分层搜索策略**：优先处理高约束轮次（如K≥6时第二轮减1个位置）  
  - 扩展至K=10（N=47），提供[测试平台](https://hydro.ac/d/milk/p/ChiFAN)  

---

#### **3. 解题策略深度剖析**
##### 🎯 核心难点与关键步骤
1. **难点1：信息传播图构造**  
   * **分析**：每轮为节点分配合适的"新知晓节点集合"，需满足：  
     - 传输条件：∀v, 知晓v的节点数 ≥ 2ᵏ（k为传输位数）  
     - 无矛盾：节点不会重复知晓同一信息  
   * 💡 **学习笔记**：转化为**二分图匹配问题**（左部：节点×轮次，右部：目标值）  

2. **难点2：搜索空间剪枝**  
   * **分析**：  
     - **随机化打乱**：更换决策顺序避免陷入死胡同  
     - **权值引导**：对位置赋权(2ᵏ)，偏好高频位置满足传输条件  
     - **层级回溯**：当前轮无解时回退上一轮，避免无效搜索  
   * 💡 **学习笔记**：结合**信息论下界**与**随机采样**是突破NP-Hard构造的关键  

3. **难点3：策略不对称性**  
   * **分析**：放弃对称策略（每轮固定知晓数），允许：  
     - 不同节点知晓不同数量的信息  
     - 关键位置被更多节点优先知晓  
   * 💡 **学习笔记**：**牺牲局部对称性**换取全局信息效率提升  

##### ✨ 解题技巧总结
- **技巧A（约束转化）**：将传输条件转化为Hall定理匹配问题，用最大流验证  
- **技巧B（随机引导）**：对高约束位置赋权重，引导搜索方向  
- **技巧C（分层优化）**：优先处理高约束轮次（如K=6的第二轮）  

##### ⚔️ 策略竞技场对比
| 策略            | 核心思想                     | 优点                  | 缺点                     | 得分预期       |
|-----------------|----------------------------|-----------------------|--------------------------|---------------|
| **对称策略**    | 每轮固定知晓新节点数        | 实现简单              | N增长慢(K=7时N=20)       | ≤43分         |
| **非对称搜索**  | 构造差异化信息路径          | 突破信息瓶颈(N=26)    | 实现复杂，需搜索优化      | **100分**     |

##### ✨ 优化之旅
> 1. **起点**：对称策略（K=7时N=20）→ 信息利用率低  
> 2. **发现瓶颈**：传输多位信息需指数级节点知晓目标值  
> 3. **钥匙**：  
>    - 步骤1：构造**非对称信息传播图**  
>    - 步骤2：用**带权随机**确保高约束位置优先满足  
> 4. **升华**：  
>    - K=6/7：N=22/26（超满分要求）  
>    - K=8：N=35（信息利用率84%）  

---

#### **4. C++核心代码实现赏析**
**通用核心实现框架**  
```cpp
#include <vector>
#include <random>
#include "message.h"

// 存储策略：strat[node][round] = 本轮知晓的位置集合
std::vector<std::vector<int>> strat; 

int init(int K) {
    // 构造策略（示例：K=7返回26）
    strat = search_strategy(K); 
    return strat.size();
}

unsigned send(int K, int N, int round, int id, const vector<int>& recv) {
    if (round <= K) { // 通信轮次
        unsigned msg = 0;
        for (int target = 0; target < N; ++target) {
            if (should_send(id, target, round, recv)) 
                msg |= (1 << target); // 设置发送位
        }
        return msg;
    } else { // 最终推断
        return reconstruct(recv); // 根据通信记录反推全局状态
    }
}
```

**题解一关键技巧**  
```cpp
// 带权随机选择知晓位置
vector<int> choose_known_set(int id, int round) {
    vector<double> weights(N, 1.0);
    weights[critical1] = 8.0; // 关键位置高权重
    weights[critical2] = 8.0;
    
    discrete_distribution dist(weights.begin(), weights.end());
    while (set.size() < required_size) {
        int pos = dist(rng);
        if (valid(pos)) set.insert(pos);
    }
    return set;
}
```
* **学习笔记**：权重引导使80%搜索资源聚焦20%关键位置，加速收敛  

---

#### **5. 算法可视化：像素动画演示**
* **主题**：8-bit风格通信网络  
* **核心演示**：信息在节点间传播与聚合过程  

**动画设计**：  
1. **场景初始化**：  
   - 节点为像素方块，按环状排列  
   - 控制面板：速度滑块/单步/暂停（FC风格按钮）  

2. **轮次演示**：  
   ```plaintext
   轮次1: [节点0] 知晓 → [1]  // 线: 0→1 (黄色)
          [节点1] 知晓 → [2]  // 线: 1→2 (黄色)
          ...
   轮次2: [节点0] 发送 → 位向量 1011
          节点3 收到 ∑=2 → 推断 {0,2}  // 弹出气泡解释
   ```

3. **游戏化元素**：  
   - **音效**：发送(8-bit "嘟")，推断成功(胜利音效)  
   - **进度条**：每轮完成度积累，满格解锁下一关  
   - **AI演示模式**：自动播放策略搜索过程（如贪吃蛇寻路）  

**设计意义**：将抽象的信息约束转化为可视的"连接线"与"计数气泡"，帮助理解Hall条件  

---

#### **6. 拓展练习**
1. **通用技巧迁移**：  
   - 课程选课冲突（每组选1门）→ 分组背包  
   - 多播协议设计 → 信息传播图构造  

2. **洛谷练习**：  
   - **P3514**：信息论+构造（推荐理由：巩固二进制信息编码）  
   - **P6186**：分组依赖优化（推荐理由：类似依赖传输条件验证）  

---

#### **7. 学习心得**
> **来自题解的经验**：  
> "调试时发现第二轮约束不满足导致后续崩溃 → 需优先保证高频位置覆盖"  
>  
> **洛语云笺点评**：  
> 这印证了**分层验证**的重要性——先确保基础约束（如Hall条件），再构建上层逻辑。建议：  
> 1. 对高约束轮次单独测试  
> 2. 添加断言(assert)验证传输条件  

---

<conclusion>
通信题的突破在于：**信息效率最大化=理论分析+智能搜索**。通过本题，我们学会：  
1. 用**信息论**估算理论上界  
2. 用**随机化搜索**解决NP-Hard构造  
3. 用**可视化**理解抽象约束  
下个挑战见！🚀  
</conclusion>

---
处理用时：199.87秒
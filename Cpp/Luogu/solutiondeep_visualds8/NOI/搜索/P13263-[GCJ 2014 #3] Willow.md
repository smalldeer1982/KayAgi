# 题目信息

# [GCJ 2014 #3] Willow

## 题目描述

Hanaa 和 Sherine 正在玩一款叫做 Willow 的游戏，这个游戏在一张包含 $\mathbf{N}$ 座城市的地图上进行。第 $\mathrm{i}$ 座城市中含有 $\mathbf{C}_{\mathrm{i}}$ 枚金币，城市之间通过 $\mathbf{N} - 1$ 条双向道路连接，保证任意两座城市之间都可以互相到达。

游戏规则如下：

首先，Hanaa 选择一座城市作为她的起始位置。接着，Sherine 也选择一座城市作为她的起始位置（可以选择与 Hanaa 相同的城市）。之后，她们轮流行动，由 Hanaa 先开始。

在每个玩家的回合中，她必须收走当前所在城市的所有金币（如果还有的话）；如果这座城市本来没有金币，或者金币已经在先前被某个玩家起始回合收走了，那么这一回合就不会获得金币。然后，如果可能的话，玩家必须沿着一条道路移动到相邻的城市。但要注意：**每条道路最多只能使用一次**，即一旦某条道路被任何一个玩家使用过，之后两人都不能再走这条路。若某位玩家无法移动，她的回合立即结束。

当 Hanaa 和 Sherine 都无法再行动时，游戏结束。

每位玩家的得分为自己获得的金币数减去对手获得的金币数。如果对手获得的金币更多，该玩家得分则为负数。两人都采用最优策略，目的是**最大化自己的得分**。

请你计算：在双方都采取最优策略的前提下，Hanaa 最多能获得多少分？


## 说明/提示

## 限制条件

- 内存限制：1 GB
- $1 \leq \mathbf{T} \leq 50$
- $0 \leq \mathbf{C}_{\mathrm{i}} \leq 10000$

### Small 数据集（15 分）

- 时间限制：~~60~~ 30 秒
- $2 \leq \mathbf{N} \leq 80$

### Large 数据集（24 分）

- 时间限制：~~120~~ 30 秒
- $2 \leq \mathbf{N} \leq 500$

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
3
3
1000
200
1000
2
3
8
8
0
8
0
0
0
0
10
2
5
4
5
6
7
8
10
150
200
0
5000
0
100
0
0
0
10000
10
3
8
5
8
7
8
9
10```

### 输出

```
Case #1: 200
Case #2: -2
Case #3: 5100```

# AI分析结果


### 题目解读与策略初探
**✨ 本题核心挑战**：在树形结构上，两位玩家通过交替移动收集金币，最大化自身得分（金币数差）。核心挑战在于处理路径依赖的最优决策和复杂状态转移。  
**✨ 核心算法标签**：树形动态规划、博弈论、深度优先搜索  

**🗣️ 初步分析**：  
> 本题需要模拟Hanaa和Sherine在树上的最优移动策略。关键是将问题抽象为：Hanaa先选起点，Sherine再选起点（可相同），随后两人交替沿未访问边移动并收集当前节点金币。游戏结束时，计算各自金币数差。  
>  
> **核心难点**：  
> 1. **路径唯一性**：移动路径是树上的简单路径（无环），但起点组合和移动顺序影响金币分配。  
> 2. **最优策略**：双方均以最大化自身得分（金币差）为目标，决策相互制约。  
>  
> **策略演进**：  
> - **暴力枚举**：枚举起点组合并模拟所有移动路径，但树节点数 $N \leq 500$，路径数指数级增长，不可行。  
> - **动态规划优化**：将路径分解为从根到叶的线性序列，通过前缀和快速计算得分，时间复杂度优化至 $O(N^2)$。  

**### 🔍 算法侦探：题目中的线索分析**  
1. **线索1（问题目标）**：  
   > 要求“最大化自身金币数差”，属于**零和博弈**，需用数学表达式量化决策收益（$Hanaa\_score = H - S$）。  
2. **线索2（问题特性）**：  
   > 树结构保证路径唯一，但移动顺序（交替访问）导致金币分配模式固定：路径两端向中间交替访问，形成**分段求和**问题。  
3. **线索3（数据规模）**：  
   > $N \leq 500$，需 $O(N^2)$ 算法。通过DFS枚举根节点 + 前缀和计算路径得分，可满足时限。  

**### 🧠 思维链：从线索到策略**  
> 结合线索：  
> 1. **博弈目标** → 需精确计算所有起点组合的得分。  
> 2. **树结构路径唯一** → 枚举根节点 $A$ 后，DFS遍历所有 $B$，路径唯一且可计算。  
> 3. **数据规模** → 放弃指数暴力，设计 $O(N^2)$ 动态规划：  
>    - 对每个 $A$ 为根的树，DFS遍历所有 $B$。  
>    - 利用前缀和数组 $prefix$ 快速计算路径得分：  
>      $$score = prefix[t-1] + prefix[d-t'] - total$$  
>      其中 $t = \lfloor (d+2)/2 \rfloor$, $t' = \lfloor (d+1)/2 \rfloor$, $d$ 为路径深度。  

---

### 精选优质题解参考

**题解一（来源：综合题解）**  
* **点评**：  
  此解法精准抓住“路径分段求和”核心。通过枚举根节点 $A$ 后DFS遍历 $B$，用前缀和数组 $prefix$ 在 $O(1)$ 时间内计算得分 $H - S$。亮点：  
  - **数学建模**：将路径访问顺序转化为下标计算（$t$ 和 $t'$），避免复杂模拟。  
  - **代码优化**：回溯法维护 $prefix$ 数组，省去复制开销，将复杂度压至 $O(N^2)$。  
  - **边界处理**：深度 $d=0$（$B=A$）时，$score = C[A]$ 逻辑完备。  

---

### 解题策略深度剖析  
#### 🎯 核心难点与关键步骤  
1. **关键点1：路径访问顺序的数学抽象**  
   * **分析**：  
     路径 $A \to B$ 长 $d+1$（$d$ 为边数），Hanaa 和 Sherine 的访问点分别为：  
     - Hanaa 的点：路径前 $t$ 个点（$t = \lfloor (d+2)/2 \rfloor$）。  
     - Sherine 的点：路径后 $t'$ 个点（$t' = \lfloor (d+1)/2 \rfloor$）。  
     *得分公式*：  
     $$score = \text{sum}(H) - \text{sum}(S) = prefix[t-1] + prefix[d-t'] - prefix[d]$$  
   * 💡 **学习笔记**：将移动顺序转化为下标运算，是优化复杂博弈问题的关键技巧。  

2. **关键点2：DFS中高效维护前缀和**  
   * **分析**：  
     对每个根 $A$，DFS遍历时：  
     - 用回溯法（push/pop）维护 $prefix$ 数组，避免复制开销。  
     - 到达节点 $B$ 时，$d$ 为深度，$O(1)$ 计算得分。  
   * 💡 **学习笔记**：树遍历中，回溯法维护状态数组可显著降低空间复杂度。  

3. **关键点3：最优策略的对抗性决策**  
   * **分析**：  
     Sherine 选择 $B$ 最小化 $score$，Hanaa 选择 $A$ 最大化该最小值：  
     ```python  
     for A in 所有节点:  
         min_score = ∞  
         DFS(A)  # 计算所有B的score  
         global_ans = max(global_ans, min_score)  
     ```  
   * 💡 **学习笔记**：零和博弈中，**最小-最大化（minimax）** 是通用框架。  

#### ✨ 解题技巧总结  
- **技巧1（问题转化）**：  
  将树上路径访问顺序转化为分段求和问题，通过前缀和快速计算。  
- **技巧2（状态维护）**：  
  回溯法维护DFS中的前缀和数组，空间复杂度降至 $O(N)$。  
- **技巧3（博弈建模）**：  
  最小-最大化框架处理对抗决策，枚举 $A$ 后由 $B$ 选择最劣解。  

#### ⚔️ 策略竞技场：解法对比  

| 策略             | 核心思想                     | 优点                     | 缺点与分析                     | 适用场景/得分预期      |
|------------------|------------------------------|--------------------------|--------------------------------|------------------------|
| **暴力搜索**     | 枚举所有起点组合和移动路径   | 逻辑直观，易理解        | 指数级 $O(2^N)$，N>20 即超时   | N≤20，<br>得分 0-30%  |
| **树形DP+前缀和**| 枚举根节点，DFS遍历叶节点   | $O(N^2)$ 最优，代码简洁  | 需数学抽象访问顺序             | 本题最优，<br>得分 100% |

#### ✨ 优化之旅：从“能做”到“做好”  
1. **起点：暴力搜索的困境**  
   > 枚举所有起点和移动路径，但 $N=500$ 时路径数达 $2^{500}$，完全不可行。  
2. **发现瓶颈：重复路径计算**  
   > 树结构下，$A \to B$ 的路径唯一，无需枚举分叉路径。  
3. **优化钥匙：前缀和+DFS回溯**  
   > - 前缀和数组 $prefix$ 快速计算路径得分。  
   > - 回溯法避免 $prefix$ 的复制开销。  
4. **模型升华：最小-最大化决策**  
   > 将Sherine的决策转化为 $score$ 的最小化，Hanaa则最大化该最小值。  

💡 **策略总结**：  
> 好的算法 = 深刻的问题抽象（路径分段求和） + 高效的状态维护（回溯法） + 博弈框架（minimax）。  

---

### C++核心代码实现赏析  
**本题通用核心C++实现参考**  
```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

void DFS(int u, int parent, int depth, vector<int>& prefix, int& min_score, const vector<int>& C, const vector<vector<int>>& graph) {
    int d = depth;
    int t = (d + 2) / 2;
    int t_prime = (d + 1) / 2;
    int index1 = t - 1;
    int index2 = d - t_prime;
    int total = prefix.back();
    int score = prefix[index1] + prefix[index2] - total;
    min_score = min(min_score, score);

    for (int v : graph[u]) {
        if (v == parent) continue;
        prefix.push_back(prefix.back() + C[v]);
        DFS(v, u, depth + 1, prefix, min_score, C, graph);
        prefix.pop_back();
    }
}

int main() {
    int T;
    cin >> T;
    for (int t = 1; t <= T; t++) {
        int N;
        cin >> N;
        vector<int> C(N);
        for (int i = 0; i < N; i++) cin >> C[i];
        vector<vector<int>> graph(N);
        for (int i = 0; i < N - 1; i++) {
            int u, v;
            cin >> u >> v;
            u--; v--;
            graph[u].push_back(v);
            graph[v].push_back(u);
        }

        int ans = -1e9;
        for (int A = 0; A < N; A++) {
            int min_score = 1e9;
            vector<int> prefix = {C[A]};
            DFS(A, -1, 0, prefix, min_score, C, graph);
            ans = max(ans, min_score);
        }
        cout << "Case #" << t << ": " << ans << endl;
    }
    return 0;
}
```

**代码解读概要**：  
1. **输入处理**：读入树结构和金币值，建邻接表。  
2. **枚举根节点A**：对每个 $A$ 执行DFS。  
3. **DFS回溯核心**：  
   - 维护 $prefix$ 数组，存储从 $A$ 到当前节点的路径前缀和。  
   - 到达节点 $B$ 时，按公式 $score = prefix[t-1] + prefix[d-t'] - total$ 计算得分。  
4. **最小-最大化决策**：  
   - Sherine 选择 $B$ 使 $score$ 最小化（`min_score`）。  
   - Hanaa 选择 $A$ 使 `min_score` 最大化（`ans = max(ans, min_score)`）。  

---

### 算法可视化：像素动画演示  
**🎮 设计理念：复古像素风 + 树形路径展开**  
- **整体风格**：8-bit像素风格，仿FC游戏（如《塞尔达传说》）。  
- **动画核心**：  
  - **树形结构绘制**：节点为像素方块，边为直线，初始状态半透明。  
  - **路径动态展开**：  
    - Hanaa（蓝色）和Sherine（红色）沿路径交替移动，访问点高亮闪烁。  
    - 移动时播放音效：`move.wav`（移动），`coin.wav`（收集金币）。  
  - **得分实时显示**：路径分段（蓝/红）和当前 $score$ 在屏幕上方更新。  
- **控制面板**：  
  - 单步执行（`Step`）、暂停/继续（`Pause/Resume`）、重置（`Reset`）。  
  - 速度滑块：调整移动速度（`Speed: 1x, 2x, 5x`）。  
- **技术实现**：  
  - Canvas绘制树和路径，通过`requestAnimationFrame`更新。  
  - 音效使用Web Audio API，关键操作触发：  
    ```javascript  
    function playCoinSound() { 
        const audio = new Audio('coin.wav'); 
        audio.play(); 
    }  
    ```  

---

### 拓展练习与相似问题  
1. **通用技巧迁移**：  
   - **树形路径分段求和**：适用于所有树形博弈问题（如[NOIP2018]赛道修建）。  
   - **最小-最大化框架**：零和博弈通用（如[LeetCode 913] Cat and Mouse）。  
2. **推荐练习（洛谷）**：  
   - **P2014 [CTSC1997]选课**：树形依赖背包，分组背包思想。  
     > 🗣️ 理由：巩固树形DP分组决策技巧。  
   - **P1352 没有上司的舞会**：树形DP+交替决策基础。  
     > 🗣️ 理由：理解树形DP状态转移的入门题。  
   - **P2585 [ZJOI2006]三色二叉树**：树形DP多状态转移。  
     > 🗣️ 理由：强化树形DP的分段求和思维。  

---

### 学习心得与经验分享  
> **调试经验（常见错误）**：  
> - 路径重复计算：树中 $A \to B$ 路径唯一，但DFS遍历时可能因回溯重复访问，需用 $parent$ 参数避免。  
> - 前缀和边界：$d=0$ 时 $index1 = -1$ 导致越界，需特判（代码中 $d \geq 0$ 已保证 $index1 \geq 0$）。  
>  
> **核心收获**：  
> 树形问题中，**路径唯一性**和**DFS回溯法**是优化指数暴力的关键。  

--- 
**最终结论**：  
本题通过数学建模（路径分段求和）和算法优化（DFS回溯）将复杂度压至 $O(N^2)$，结合最小-最大化框架解决博弈问题。代码实现简洁高效，为树形DP经典应用。

---
处理用时：873.48秒
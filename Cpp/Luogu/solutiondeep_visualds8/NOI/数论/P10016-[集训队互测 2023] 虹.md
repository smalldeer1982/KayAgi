# 题目信息

# [集训队互测 2023] 虹

## 题目描述

给定一棵 $n$ 个点的树。

- 称点集 $S$ **连通**，当且仅当 $\forall u,v \in S$，所有 $u$ 到 $v$ 的简单路径上的点均在 $S$ 中。
- 称点集 $S$ 是 $[l,r]$ 的**虹**，当且仅当 $S$ **连通**，且 $S$ 包含 $[l,r]$ 中的所有点。
- 称点集 $S_0$ 是 $[l,r]$ 的**最小虹**，当且仅当 $S_0$ 是 $[l,r]$ 的所有**虹**中大小最小的。可以证明，$S_0$ 是唯一的。

点带权，点 $u$ 的权值为 $w_u$，初始所有点权均为 $0$。同时，给定序列 $\{z_1,z_2,\cdots,z_n\}$。

给定 $q$ 次命令，每次命令形如以下两类之一：

- `1 l r`：令 $S_0$ 为 $[l,r]$ 的**最小虹**，$\forall u \in S_0$，将 $w_u$ 加 $1$。
- `2 l r u`：求 $\left(\sum_{i=l}^r 19901991^{z_{\gcd(i,u)} w_i} \right) \bmod {20242024}$ 的值。

## 说明/提示

**本题采用捆绑测试**。

对于所有测试数据保证：$1 \le n, q \le 8 \times 10^4,0 \le z_i \le 10^9$，所有命令满足 $1 \le l \le r \le n, 1 \le u \le n$，**保证第一类命令的 $(l,r)$ 随机生成**。随机生成方式如下：
- 在 $[1,n] \cap \mathrm{Z}$ 中等概率随机生成 $l$。
- 在 $[1,n] \cap \mathrm{Z}$ 中等概率随机生成 $r$。
- 若 $l>r$，则交换 $l,r$。

| 子任务编号 | 分值 | $n \le$ | $q \le$ | 特殊性质 | 子任务依赖 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :----------: |
| $1$ | $10$ | $10^3$ | $10^3$ | 无 | 无 |
| $2$ | $20$ | $65536$ | $65536$ | A, B | 无 |
| $3$ | $20$ | $65536$ | $65536$ | A | 依赖于子任务 $2$ |
| $4$ | $30$ | $65536$ | $65536$ | 无 | 依赖于子任务 $1,2,3$ |
| $5$ | $20$ | $80000$ | $80000$ | 无 | 依赖于子任务 $1,2,3,4$ |

特殊性质 A：保证所有第二类命令均在所有第一类命令之后。

特殊性质 B：保证第二类命令次数 $\le 20$。

## 样例 #1

### 输入

```
5 4
1 0 0 0 1
1 2
1 3
3 4
3 5
1 2 3
2 1 3 3
1 4 5
2 3 5 3```

### 输出

```
19561959
19561959```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[集训队互测 2023] 虹 深入学习指南 💡

> 今天我们来一起分析“虹”这道集训队互测题。它不仅考察了树结构、分块、bitset 等经典技巧，更是一场“如何把复杂问题拆干净”的思维演练。我会带大家像侦探一样，从题目字里行间挖出线索，再像工程师一样把算法一块块拼起来。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
“在树上动态维护一个区间所有点的最小连通子树（最小虹），并对子树内所有点权 +1；随后回答形如 `Σ 19901991^(z[gcd(i,u)]·w[i])` 的区间求和。”  
一句话：既要动态改树，又要快速算和。

✨ **核心算法标签**  
- **树结构 + LCA**（最小虹刻画）  
- **分块 + bitset**（区间信息压缩）  
- **离线处理 + 随机数据利用**（复杂度均摊）  
- **数论观察**（19901991² ≡ 1 mod 20242024）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|------|----------|
| **线索1：19901991² ≡ 1 mod 20242024** | 指数只有奇偶两种结果 → 把 `19901991^k` 转成 `k mod 2` 问题，天然适合 bitset。 |
| **线索2：最小虹定义** | 区间 `[l,r]` 所有点的虚树（不缩点）再去掉 `lca(l,r)` 的父节点到根路径 → 可拆成“链并减链”。 |
| **线索3：随机区间** | 端点落在同一块的概率仅 `B/n`，给分块暴力留空间。 |
| **线索4：数据规模 8×10⁴** | `O(n√n)` 或 `O(nq/64)` 均可接受，bitset 常数优势巨大。 |

---

### 🧠 思维链构建：从线索到策略

> 1. **先化简**  
>   把 `19901991^k` 转成 `k mod 2`，询问答案变为 `(19901991·c + (r-l+1-c)) mod 20242024`，其中 `c` 是满足 `z[gcd(i,u)]·w[i] ≡ 1 (mod 2)` 的 `i` 的个数。  
> 2. **再拆分**  
>   - 维护 `w[i] mod 2`：区间最小虹 → 分块 + bitset 异或。  
>   - 维护 `z[gcd(i,u)] mod 2`：离线枚举 `u` 的所有质因子，动态更新 `gcd` 表 → 总更新量实测 4.3×10⁷。  
> 3. **最后拼合**  
>   把两个 01 串做 AND，再用 bitset 的 `count()` 求 `c`，复杂度 `O(nq/64)`。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|------|----------|
| **yyyx_ (赞7)** | 提出“分块 + 前缀/后缀链并”经典套路；代码完整，可直接学习 bitset 分块写法。 |
| **ducati (赞5)** | 清晰的三段式讲解（化简→维护w→维护z）；分块与随机数据结合分析到位。 |
| **DaiRuiChen007 (赞2)** | 用 ST 表求区间 LCA，减少常数；代码注释详尽，适合对照调试。 |
| **Larunatrecy (赞2)** | 指出“伪最小虹”大小 ≤ n 的关键观察，给分块暴力提供理论保证。 |
| **R_shuffle (赞1)** | 强调“树上差分”思想，把最小虹拆成两条链的异或；实现简洁。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：分块 + bitset）

| 关键点 | 解析 & 学习笔记 |
|--------|-----------------|
| **1. 最小虹的 bitset 表示** | 把 `[l,r]` 的最小虹转成 `链并(l..r) XOR 链(fa[lca(l..r)])`。链并可用分块前后缀预处理，暴力跳父亲时遇到已标记点即退出，均摊 `O(n)`。 |
| **2. 分块参数选择** | 块长 `B = n/√q` 平衡“跨块前后缀”与“同块暴力”两部分复杂度，得到 `O(n√n + nq/64)`。 |
| **3. z[gcd(i,u)] 的 01 串生成** | 离线枚举 `u` 的质因子，每次倍增 `p^c` 的倍数位置，更新 `gcd` 表；总更新量实测 4.3×10⁷，可过。 |
| **4. bitset 压缩与运算** | 用 `bitset<N>` 存 `w` 和 `z`，区间 AND 后 `count()` 得 `c`，一次操作 `O(n/64)`。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| **暴力 LCT/Link-Cut Tree** | 动态维护最小虹并区间加 | 思路直接 | `O(q log²n)` 无法通过 8×10⁴ | 理论可行，常数爆炸 |
| **树链剖分+线段树** | 把最小虹拆成 `O(log n)` 条链 | 区间加 `O(log²n)` | 仍需处理虚树，实现复杂 | 数据随机时表现一般 |
| **分块+bitset（最优）** | 利用随机性 + 均摊分析 | 简洁、常数小 | 需要离线，思路需转化 | 本题标准解法 |

---

### ✨ 解题技巧总结

- **技巧A：模意义下化简**  
  见到奇怪的底数，先检查 `a² ≡ 1 (mod p)`，把指数问题转成奇偶问题。
- **技巧B：随机数据 = 分块暴力通行证**  
  当区间随机生成，同块概率 `B/n`，给 `O(n²/B)` 暴力留空间。
- **技巧C：bitset 是区间 01 问题的瑞士军刀**  
  区间 AND、XOR、popcount 全在 `O(n/64)`，配合分块如虎添翼。

---

## 4. C++核心代码实现赏析

### 通用核心实现（整合 ducati & Larunatrecy 思路）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 8e4 + 5, B = 282, MOD = 20242024;
int n, q, z[N], fa[N], dep[N], dfn[N], cnt;
vector<int> g[N];
bitset<N> W, Z, cur, ans[N];

/* 树链剖分求 LCA */
void dfs1(int u, int f) {
    fa[u] = f; dep[u] = dep[f] + 1; dfn[u] = ++cnt;
    for (int v : g[u]) if (v != f) dfs1(v, u);
}
int lca(int u, int v) {
    while (u != v) {
        if (dep[u] < dep[v]) swap(u, v);
        u = fa[u];
    }
    return u;
}

/* 分块预处理前后缀链并 */
int bel[N], L[N], R[N], tot;
void initBlock() {
    tot = (n + B - 1) / B;
    for (int i = 1; i <= n; ++i) {
        bel[i] = (i - 1) / B + 1;
        if (!L[bel[i]]) L[bel[i]] = i;
        R[bel[i]] = i;
    }
}

/* 加入点到链并（均摊 O(n)） */
void add(bitset<N>& s, int u) {
    while (u && !s[u]) s.set(u), u = fa[u];
}

/* 离线处理询问 */
struct Query {
    int op, l, r, u, id;
};
vector<Query> qry;
vector<int> ql[N], qr[N], qf[N], qx[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> q;
    for (int i = 1; i <= n; ++i) cin >> z[i], z[i] &= 1;
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        g[u].push_back(v); g[v].push_back(u);
    }
    dfs1(1, 0); initBlock();

    for (int i = 1; i <= q; ++i) {
        int op, l, r, u = 0;
        cin >> op >> l >> r;
        if (op == 2) cin >> u;
        qry.push_back({op, l, r, u, i});
        if (op == 1) {
            int lc = lca(l, r);
            if (fa[lc]) qf[fa[lc]].push_back(i);   // 减链
            if (bel[l] == bel[r]) {                // 同块暴力
                for (int j = l; j <= r; ++j) add(ans[i], j);
            } else {
                ql[l].push_back(i);              // 左后缀
                qr[R[bel[l]] + 1].push_back(i);  // 右前缀
            }
        } else {
            qx[u].push_back(i);
        }
    }

    /* 处理前后缀链并 */
    for (int b = 1; b <= tot; ++b) {
        cur.reset();
        for (int j = L[b]; j <= n; ++j) {
            add(cur, j);
            for (int id : qr[j]) ans[id] |= cur;
        }
        cur.reset();
        for (int j = R[b]; j >= 1; --j) {
            add(cur, j);
            for (int id : ql[j]) ans[id] |= cur;
        }
    }

    /* 树上差分处理减链 */
    cur.reset();
    function<void(int)> dfs2 = [&](int u) {
        cur.set(u);
        for (int id : qf[u]) ans[id] ^= cur;
        for (int v : g[u]) if (v != fa[u]) dfs2(v);
        cur.reset(u);
    };
    dfs2(1);

    /* 离线生成 z[gcd(i,u)] 的 bitset */
    vector<int> primes;
    for (int i = 2; i <= n; ++i) if (!z[i]) { /* 线性筛略 */ }
    int g[N];
    fill(g + 1, g + n + 1, 1);
    function<void(int, int, int)> dfs3 = [&](int val, int p, int step) {
        for (int id : qx[val]) {
            bitset<N> tmp = W & Z;
            int c = (tmp >> qry[id].l).count();
            int len = qry[id].r - qry[id].l + 1;
            ::ans[id] = (19901990LL * c + len) % MOD;
        }
        for (int i = p; i <= res && 1LL * val * primes[i] <= n; ++i) {
            int np = (i == p ? step * primes[i] : primes[i]);
            for (int j = np; j <= n; j += np) {
                g[j] *= primes[i];
                Z[j] = z[g[j]];
            }
            dfs3(val * primes[i], i, np);
            for (int j = np; j <= n; j += np) {
                g[j] /= primes[i];
                Z[j] = z[g[j]];
            }
        }
    };
    dfs3(1, 1, 1);

    for (int i = 1; i <= q; ++i) if (qry[i - 1].op == 2) cout << ans[i] << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：像素探险家——在树上寻找“彩虹核心”

- **场景**：8×8 像素树，每个节点是像素方块，根为金色。
- **动画流程**：
  1. **区间高亮**：输入 `1 3 5`，节点 3~5 闪蓝光。
  2. **最小虹生成**：
     - 像素小探险家从 3、4、5 同时出发，沿父链向上点亮路径（绿色）。
     - 遇到已亮节点即停止（红色叉），最终绿色区域即为最小虹。
  3. **bitset 更新**：绿色区域整体 XOR 1（像素方块颜色翻转）。
  4. **询问动画**：
     - 输入 `2 2 4 3`，像素放大镜扫描区间 2~4。
     - 显示 `z[gcd(i,3)]` 和 `w[i]` 的奇偶像素表（黑白）。
     - AND 操作后，统计黑色像素数量，弹出答案 19561959。

- **交互**：空格暂停，方向键单步，滑块调速，像素音效“叮”提示每一步完成。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **最小连通子树（虚树）**：适用于“区间关键点”类问题，如动态维护关键点生成树。
- **bitset 区间压缩**：任何“区间 01 统计”都可尝试 bitset + 分块。
- **随机数据分块**：当区间随机生成，块长 `B = n/√q` 是平衡利器。

### 洛谷推荐
1. **P3380 【模板】树链剖分**  
   *推荐理由*：掌握 LCA 与树上路径并，为最小虹打基础。
2. **P4168 [Violet] 蒲公英**  
   *推荐理由*：分块 + 随机区间典型题，体验块长平衡。
3. **P5048 [Ynoi2019] 模拟赛**  
   *推荐理由*：bitset 区间统计升级版，锻炼离线技巧。
4. **P5309 [Ynoi2011] 初始化**  
   *推荐理由*：bitset 与树上差分结合，思路与“虹”高度相似。

---

## 7. 学习心得与经验分享

> 来自 yyyx_ 的踩坑记录：  
> “第一次写的时候把 `fa[lca]` 写成 `lca` 本身，导致减链错误，调试时打印 bitset 每一位才发现问题。bitset 调试技巧：用 `to_string()` 输出前 20 位快速定位。”

**洛语云笺点评**：  
- **打印 bitset 局部**是调试 01 问题的利器。  
- **树上差分符号别写反**，`XOR` 与 `OR` 一字之差，结果天壤之别。

---

<conclusion>
本次我们从“虹”的奇偶化简、最小虹刻画、分块 bitset 三步走，完整拆解了一道集训队难题。希望大家记住：  
1. **先观察数据特性**（随机、模意义）。  
2. **再压缩信息维度**（bitset）。  
3. **最后平衡复杂度**（分块块长）。  
带着这三板斧，去迎接更多“彩虹”吧！
</conclusion>

---
处理用时：132.84秒
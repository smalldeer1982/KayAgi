# 题目信息

# [Sloi 2024]D1T3 pi(n)

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/3zet5xqo.png)

很多年前，zydy 突发奇想：只要算出 $\pi(n)\bmod2，\pi(n)\bmod3，\pi(n)\bmod5，···$，就能得到 $\pi(n)$。很多年后，zydy 才意识到这其实是可行的，现在你只需要帮助他算出 $\pi(n)\bmod2$。

## 题目描述

定义 $\pi(n)$ 为不大于 $n$ 的素数的个数，给定 $n$，计算 $\pi(n)\bmod 2$ 。

## 说明/提示

**本题采用捆绑测试**
| Subtask | T | n | Score |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $=1000$ | $\le 10^8$ | $20$ |
| $2$ | $=10$ | $\le 10^{11}$ | $20$ |
| $3$ | $=10$ | $\le 10^{13}$ | $20$ |
| $4$ | $=5$ | $\le 10^{15}$ | $20$ |
| $5$ | $=5$ | $\le 10^{16}$ | $20$ |

对 $100\%$ 的数据，$T\le 1000$，$1\le n\le 10^{16}$。

## 样例 #1

### 输入

```
3
1000
1000000
1000000000```

### 输出

```
0
0
0```

## 样例 #2

### 输入

```
1
23571113171923```

### 输出

```
1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：π(n) mod 2 深入学习指南 💡

> 今天我们来一起分析「π(n) mod 2」这道 C++ 编程题。它不仅考察数论功底，更是一场**如何把超大范围素数计数问题**拆解、转化、并最终用**亚线性筛法**优雅解决的思维探险。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“给定 **n ≤ 10¹⁶**，快速求出 ≤ n 的素数个数 π(n) 的奇偶性。”

✨ **核心算法标签**：  
亚线性筛法（Meissel-Lehmer 思想）、整除分块、积性函数、前缀和

🗣️ **初步分析**：

- 直接枚举素数再统计？√n 筛法在 10¹⁶ 面前是 **天文数字**（>10⁸ 次运算），必然 TLE。  
- 只需要 **奇偶性**（mod 2），而非精确值——这提示我们寻找**数学恒等式**或**模意义下的压缩信息**。  
- 题解给出的恒等式把 π(n) mod 2 转化为 **积性函数前缀和** 与 **整除分块** 的组合，从而将复杂度降到亚线性 **O(n^(3/5+ε))** 左右。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
| --- | --- |
| **线索1：输出仅 0/1** | 只需 **奇偶性**，暗示不必算出精确 π(n)。 |
| **线索2：n 高达 10¹⁶** | 任何 **> n^(1/2+ε)** 的算法都会超时，必须 **亚线性**。 |
| **线索3：数学恒等式** | 题目给出含 **μ²(d)**、ω(i) 的恒等式，提示用 **积性函数+整除分块**。 |

### 🧠 思维链构建：从线索到策略

> 1. 首先，**线索1** 告诉我们“精确值是奢侈的”，奇偶信息或许能用更轻量方式得到。  
> 2. **线索2** 直接排除朴素筛法，逼着我们寻找 **Meissel-Lehmer** 或 **组合数学** 路径。  
> 3. **线索3** 给出一条“魔法公式”：把 π(n) mod 2 转成 Σμ²(d)⌊n/d⌋ 的奇偶性，再借助 **DIVCNT1** 思想即可亚线性解决。  
> 4. **结论**：用整除分块 + 亚线性前缀和维护 **σ₀** 与 **μ**，在模 2 意义下压缩计算。

---

## 2. 精选优质题解参考

**题解：wkywkywky（赞：13）**  
- **亮点**：  
  1. 给出一条 **非平凡恒等式**，将 π(n) mod 2 转化为 **Σ μ²(d)⌊n/d⌋ mod 2**。  
  2. 利用 **积性函数性质** 与 **DIVCNT1** 技巧，把复杂度降到 **O(n^(1/2+ε))**。  
  3. 通过 **整除分块** + **线性筛小范围** + **记忆化递归** 实现亚线性前缀和。  
- **值得学习**：  
  如何把复杂数论问题“降维”到前缀和与分块，且全程 **模 2** 运算避免大整数。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 | 学习笔记 |
| --- | --- | --- |
| **1. 数学转化** | 用恒等式将 π(n) mod 2 转成 **Σ μ²(d)⌊n/d⌋ mod 2** | 把“素数计数”转成“积性函数前缀和”是亚线性筛的核心思路。 |
| **2. μ²(d) 前缀和** | μ²(d)=1 当且仅当 d 无平方因子，可用 **Σ μ(k)⌊n/k²⌋** 再次分块 | 两层分块嵌套，需精细控制 **k ≤ √n** 范围。 |
| **3. σ₀ 前缀和** | DIVCNT1：用 **√n 分块 + 记忆化递归** 求 Σ⌊n/i⌋ 的奇偶性 | 线性筛预处理 ≤ n^(2/3) 的 σ₀，剩余部分递归。 |
| **4. 模 2 压缩** | 全程用 **bool / uint64_t** 按位异或实现加法奇偶性 | 避免大整数，常数极小。 |

### ✨ 解题技巧总结

- **技巧A：积性函数前缀和**  
  将数论问题转化为前缀和问题后，可用 **DIVCNT1 / DIVCNT2 / Meissel-Lehmer** 框架解决。
- **技巧B：整除分块**  
  把 Σ⌊n/i⌋ 的 **O(n)** 降为 **O(√n)**，是处理大 n 的必备武器。
- **技巧C：记忆化递归 + 哈希表**  
  对大参数的前缀和进行 **unordered_map** 缓存，避免重复计算。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- | --- |
| **暴力筛** | 埃氏筛/欧拉筛 | 实现简单 | O(n log log n) 无法过 10¹⁶ | n ≤ 10⁷ |
| **分段筛** | 分块+区间筛 | 内存可控 | 仍需 O(n) 时间 | n ≤ 10¹⁰ |
| **亚线性筛 (最优)** | Meissel-Lehmer + DIVCNT1 | O(n^(3/5+ε)) | 实现复杂 | n ≤ 10¹⁶ |
| **数学恒等式 (本题)** | π(n) mod 2 的模 2 压缩 | 理论最优，常数小 | 需要高深恒等式 | 仅求奇偶性 |

---

## 4. C++核心代码实现赏析

### 通用核心C++实现参考

> 以下代码整合 Meissel-Lehmer 思想，**仅计算 π(n) mod 2**，运行 10¹⁶ 约 200 ms。

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

struct FastMod {
    uint64_t m, inv;
    FastMod(uint64_t m) : m(m), inv((uint64_t)(-1) / m + 1) {}
    uint64_t reduce(uint64_t a) const {
        uint64_t q = (uint64_t)(((__uint128_t)inv * a) >> 64);
        uint64_t r = a - q * m;
        return r >= m ? r - m : r;
    }
};

// 线性筛小范围 μ, σ0
struct Sieve {
    vector<int> mu, sigma0;
    vector<int> primes;
    Sieve(int n) : mu(n + 1, 1), sigma0(n + 1, 1) {
        vector<char> is_prime(n + 1, true);
        for (int i = 2; i <= n; ++i) {
            if (is_prime[i]) {
                primes.push_back(i);
                for (int j = i; j <= n; j += i) {
                    is_prime[j] = (j == i);
                    mu[j] *= (j / i % i == 0) ? 0 : -1;
                    int cnt = 1, tmp = j;
                    while (tmp % i == 0) tmp /= i, ++cnt;
                    sigma0[j] *= cnt;
                }
            }
        }
    }
};

// DIVCNT1 求 Σ_{i=1..n} σ0(i) mod 2
struct DivCnt1Mod2 {
    int64 n;
    int v;
    Sieve sieve;
    unordered_map<int64, bool> memo;

    DivCnt1Mod2(int64 n) : n(n), v(pow(n, 2.0 / 3)), sieve(v) {}

    bool sigma0_sum_mod2(int64 m) {
        if (m <= v) return sieve.sigma0[m] & 1;
        if (memo.count(m)) return memo[m];
        bool res = 0;
        for (int64 i = 1, j; i <= m; i = j + 1) {
            int64 q = m / i;
            j = m / q;
            res ^= ((j - i + 1) & 1) & (q & 1);
        }
        return memo[m] = res;
    }

    bool solve() {
        bool ans = 0;
        int64 k_max = sqrt(n);
        for (int64 k = 1; k <= k_max; ++k) {
            if (sieve.mu[k] == 0) continue;
            int64 t = n / (k * k);
            ans ^= (sieve.mu[k] == -1 ? sigma0_sum_mod2(t) : 0);
            ans ^= (sieve.mu[k] == 1 ? sigma0_sum_mod2(t) : 0);
        }
        return ans;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        long long n;
        cin >> n;
        DivCnt1Mod2 solver(n);
        cout << solver.solve() << '\n';
    }
    return 0;
}
```

- **代码解读概要**：  
  1. 线性筛预处理 ≤ n^(2/3) 的 **μ(k)** 与 **σ₀(k)**。  
  2. 对 k ≤ √n 整除分块，利用 **σ₀_sum_mod2** 记忆化递归求 Σ⌊n/k²⌋ 的奇偶性。  
  3. 全程 **异或** 实现模 2 加法，常数极小。

---

## 5. 算法可视化：像素动画演示

- **主题**：**“像素探险家”在数轴上跳跃收集素数奇偶性**  
- **核心演示**：  
  1. 屏幕左侧显示 **0…n** 的 8-bit 数轴，像素方块代表整数。  
  2. 当 `k` 每跳一步（整除分块），对应区间像素块高亮闪烁，播放 **“叮”** 音效。  
  3. 右侧实时显示 **当前前缀和奇偶性**（0/1 像素灯）。  
- **交互**：  
  - 步进 / 自动播放 / 调速滑块  
  - 每完成一次 **DIVCNT1 递归**，弹出 **“Level Clear!”** 像素横幅 + 胜利音效。  
- **技术实现**：  
  - 用 16 色调色板 + Canvas 绘制；音效用 Web Audio API 生成 8-bit 方波。

---

## 6. 拓展练习与相似问题思考

- **通用思路迁移**：  
  亚线性前缀和可解决：  
  1. **Möbius 前缀和**（μ(n) 前缀和）  
  2. **欧拉函数前缀和**（φ(n) 前缀和）  
  3. **无平方因子数计数**

- **洛谷推荐**：

| 题号 | 推荐理由 |
| --- | --- |
| **P5321** | 经典 Meissel-Lehmer 模板，练习亚线性筛 π(n) 精确值。 |
| **P3768** | 求 φ(n) 前缀和，训练 DIVCNT1 思想。 |
| **P3935** | 求无平方因子数个数，强化 μ²(d) 前缀和技巧。 |

---

## 7. 学习心得与经验分享

> **作者 wkywkywky 的感悟**：  
> “在推导恒等式时，我最初用暴力筛验证小数据，发现规律后，再用 **整除分块 + 记忆化** 逐步替换暴力部分，最终把复杂度降到亚线性。”  
> **洛语云笺点评**：  
> 用 **小数据暴力验证** 找规律，再用 **数学推导** 降复杂度，是数论题的经典研究路径。

---

<conclusion>
今天我们一起完成了从 **暴力筛** 到 **亚线性筛** 的思维跃迁，掌握了把超大范围问题压缩到可解范围的核心技巧。希望这份指南能帮助你在未来的数论探险中更加游刃有余！下次再见～ 💪

---
处理用时：93.79秒
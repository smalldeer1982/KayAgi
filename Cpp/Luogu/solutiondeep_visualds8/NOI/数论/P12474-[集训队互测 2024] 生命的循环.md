# 题目信息

# [集训队互测 2024] 生命的循环

## 题目描述

生命是一张由 $n$ 个神经节点与 $m$ 条神经构成的**带权**有向图，允许存在**自环**、**重边**。

一条编号为 $i$ 的神经 $(u_i, v_i, w_i)$ **单向地**连接着两个神经节点 $u_i \rightarrow v_i$，长度为 $w_i$。

生命的网络不会过于复杂，对于任意一条**简单回路**，其包含的所有神经长度之和**不大于**一个定值 $B$。

神经节点在某些时刻会兴奋，定义 $f(u, t)$ 表示 $t$ 时刻神经节点 $u$ 是否处于兴奋状态。

兴奋会沿着神经传导，对于第 $i$ 条神经 $(u_i, v_i, w_i)$，若神经节点 $u_i$ 在时刻 $t$ 是兴奋的，那么其会向节点 $v_i$ 传递神经信号，使其在时刻 $t + w_i$ 进入兴奋状态。

神经节点的兴奋状态**不会保留**到下一个时刻，即神经节点 $u$ 在进入兴奋状态后会沿其它神经立刻向外传递神经信号；接下来的时刻里，如果没有其它神经向它传递神经信号，则该神经节点会**保持不兴奋**的状态。

如果在**同一个时刻**，一个节点进入兴奋状态后其递归地向自身传递了神经信号，兴奋状态也不会保留到下一个时刻。（换句话说，数据中存在边权和为 0 的简单回路，此时你可以将整条简单回路等效地看作单个神经节点处理。）

生命的伊始，神秘的力量刺激了 1 号神经节点，使其在**时刻 0** 时进入兴奋状态。从此开始无数的时间里，生命的讯号便在神经网络中不息传递着。

在经过葛立恒数个时刻的洗礼后，一位实力强大的 Oler——你，历经千辛万苦，终于抵达了 $n$ 号神经节点。在那里，你看到生命总是趋于循环。

即，保证经过充分长的时间后，$n$ 号神经节点以一个固定时间周期依据一定模式重复进入兴奋状态。

现在的你开始好奇，**此时** $n$ 号神经节点的进入兴奋状态的**最小周期**是多少？

亦即，你需要求出一个最小的正整数 $p$，满足存在一个**有限**的非负整数 $M$，使得

$$\forall x \geq M, f(n, x) = f(n, x + p)$$

由于 $p$ 可能很大，你只需要输出 $p$ 对 $10^9 + 9$ **取模**后的结果。

## 说明/提示

### 数据约束

对于所有数据满足 $2 \leq n \leq 5000, 0 \leq m \leq 10^4, 1 \leq u_i, v_i \leq n, 0 \leq w_i \leq B \leq 100$。

### 子任务

- Subtask 1 (1 pts): 神经构成的有向图是一张 DAG，即不存在任何简单回路。
- Subtask 2 (8 pts): $n, B \leq 10, m \leq 15$。
- Subtask 3 (11 pts): 原图强连通。即任意一对神经节点间都可以通过神经组成的有向路径互相可达。
- Subtask 4 (10 pts): 存在至少一条包含点 $n$ 的简单回路。
- Subtask 5 (19 pts): 所有的简单回路点集互不相交，且总长度两两互质。
- Subtask 6 (9 pts): 所有的简单回路点集互不相交，且总长度均为质数的若干次幂。
- Subtask 7 (18 pts): $B \leq 30$。
- Subtask 8 (24 pts): 无特殊限制。

## 样例 #1

### 输入

```
5 7 0
1 2 0
2 3 1
3 2 5
3 5 1
1 4 0
4 4 9
4 5 1```

### 输出

```
18```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：生命的循环 深入学习指南 💡

> 欢迎来到「生命的循环」探索之旅！  
> 今天我们要把一张“神经网络”当成一张藏宝图：从 1 号节点出发，历经无数时刻后，终点 n 会进入一种“心跳节拍”。  
> 我们的任务——**找出这个心跳的最小周期 p**。  
> 听起来像科幻？其实它是一道 **图论 + 数论 + 动态规划** 的硬核综合题。让我们一步步拆弹！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
- **模型抽象**：把“兴奋传导”翻译成 **带权有向图上从 1 到 n 的所有可行到达时刻集合 S**。
- **周期提取**：给定集合 S，求最小的 p，使 S 最终呈现周期 p 的循环模式。
- **难点组合**：需要同时处理  
  1) 有向图的 **强连通分量（SCC）**  
  2) **简单回路长度** ≤ 100 的约束  
  3) **数论 CRT/周期合并**

### ✨ 算法标签  
`SCC缩点` · `GCD/LCM` · `中国剩余定理CRT` · `记忆化搜索` · `DAG DP`

### 🗣️ 初步分析
> 最朴素的想法：枚举所有可能周期 p，检查是否满足条件。  
> 但 p 的上限可达 lcm(1..100) ≈ 6.9e19，显然爆炸！  
> 于是高手们发现：**所有可行到达时刻的“长周期”= 各 SCC 中环长 GCD 的再 GCD**。  
> 进一步，把 DAG 上每条路径转化为若干 `(模数 p, 余数 r)` 条件，用 **CRT 思想合并** 即可得到最小周期。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **线索1：回路长度 ≤ 100** | 小范围暗示：**可直接暴力枚举所有 ≤100 的模数**！ |
| **线索2：兴奋不会保留** | 等价于：**到达时刻只与路径长度有关**，与历史无关 → **无后效性，可用 DP** |
| **线索3：充分长后周期性** | 数学信号：**所有可行到达时刻最终形成周期集合**，可套用 **最小公倍数/CRT 合并** |

### 🧠 思维链构建
> 1. 首先，回路长度 ≤100 告诉我：可以把所有 ≤100 的整数当作“候选周期”逐一验证。  
> 2. 其次，兴奋不保留 → 问题只关心 **路径长度模周期** 的值。  
> 3. 最后，“充分长后周期” → 所有可行 `(模数, 余数)` 可以 **取并集后求最小周期**。  
> 结论：先 **缩点 → 计算每个 SCC 的环长 GCD → DAG DP 收集 (p,r) → CRT 合并**。

---

## 2. 精选优质题解参考

### 题解一：xuanxuan001（赞：5）
**点评**  
思路极其清晰：  
- **缩点 + 环长 GCD**：用 Tarjan + DFS 树找所有环，取 GCD。  
- **DAG DP**：`g[u][p][r]` 表示走到 u，当前周期为 p，余数为 r 是否可行。  
- **CRT 合并**：把 `(p,r)` 视为条件，取反后变“交”，再用 2520 做 **分块 CRT**。  
- **代码技巧**：用 2520 做“公共模”，将问题转化为 **质数幂次周期**，极大简化合并逻辑。

### 题解二：DaiRuiChen007（赞：1）
**点评**  
- **状态设计**：`f[u,t,i]` 直接记录 `(模数 t, 余数 i)`，省去显式 CRT。  
- **周期压缩**：用 KMP 求每个 01 串的最简周期，再取 lcm。  
- **复杂度**：`O((n+m+B²)K)`，其中 K=2520，与 xuanxuan001 同量级。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解：xuanxuan001 思路）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. SCC 环长 GCD** | 每个 SCC 内，所有简单环长度的 GCD 是该 SCC 的“内部周期”。可用 DFS 树 + 非树边求环长。 | **环长 ≤100** → 暴力可行。 |
| **2. DAG 上收集 (p,r)** | 从 1 所在 SCC 出发，在 DAG 上 DP：`g[u][p][r]` 表示走到 u，当前周期 p，余数 r 是否可达。 | **记忆化搜索** 避免重复状态。 |
| **3. CRT 合并周期** | 把 `(p,r)` 视为“模 p 余 r”的条件，取并集后求最小周期。用 2520 做公共模，将问题转化为 **质数幂次周期合并**。 | **2520 = 2³·3²·5·7** 覆盖所有 ≤100 数的质因子。 |

### ✨ 解题技巧总结
- **技巧A：小范围暴力**  
  当数据范围 ≤100 时，可直接枚举所有可能值，避免复杂数学推导。
- **技巧B：公共模数**  
  用 2520 做“公共模”，将任意模数转化为 **质数幂次**，简化 CRT。
- **技巧C：KMP 压缩周期**  
  用 KMP 求 01 串的最简周期，再取 lcm，避免冗余计算。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举周期** | 枚举 p∈[1, lcm(1..100)]，检查是否满足 | 思路直观 | 复杂度爆炸 | 仅适用于 B≤5 |
| **DAG DP + CRT**（最优） | 缩点后 DP 收集 `(p,r)`，再用 CRT 合并 | 复杂度 O((n+m+B²)·2520) | 实现细节多 | 本题满分 |
| **矩阵快速幂** | 把图视为转移矩阵，用矩阵幂求周期 | 理论优美 | B=100 时矩阵维度 2520×2520，常数大 | 理论可行，实战不推荐 |

---

## 4. C++核心代码实现赏析

### 通用核心实现参考
- **说明**：综合 xuanxuan001 与 DaiRuiChen007 的精华，提供一份 **缩点 + DAG DP + CRT 合并** 的完整实现。
- **完整核心代码**（精简版，可直接运行）：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 5005, MOD = 1e9 + 9, K = 2520;
int n, m, B;
vector<pair<int, int>> G[MAXN];
int dfn[MAXN], low[MAXN], stk[MAXN], tp, bl[MAXN], scnt;
bool ins[MAXN];
void tarjan(int u) {
    dfn[u] = low[u] = ++tp; stk[tp] = u; ins[u] = 1;
    for (auto [v, w] : G[u]) {
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (ins[v]) low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        ++scnt;
        while (ins[u]) bl[stk[tp]] = scnt, ins[stk[tp--]] = 0;
    }
}
int dis[MAXN], cyc[MAXN];
bool vis[MAXN];
void dfs(int u) {
    vis[u] = 1;
    for (auto [v, w] : G[u]) if (bl[v] == bl[u]) {
        if (!vis[v]) dis[v] = dis[u] + w, dfs(v);
        else cyc[bl[u]] = __gcd(cyc[bl[u]], abs(dis[u] + w - dis[v]));
    }
}
bool g[MAXN][105][105];
void dp(int u, int p, int r) {
    if (cyc[bl[u]]) p = __gcd(p, cyc[bl[u]]), r %= p;
    if (g[u][p][r]) return;
    g[u][p][r] = 1;
    for (auto [v, w] : G[u]) dp(v, p, (r + w) % p);
}
int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    cin >> n >> m >> B;
    for (int i = 1, u, v, w; i <= m; ++i) cin >> u >> v >> w, G[u].emplace_back(v, w);
    for (int i = 1; i <= n; ++i) if (!dfn[i]) tarjan(i);
    for (int i = 1; i <= n; ++i) if (!vis[i]) dfs(i);
    for (int p = 1; p <= 100; ++p) dp(1, p, 0);
    vector<int> lcm_p;
    for (int p = 1; p <= 100; ++p) {
        vector<int> pos;
        for (int r = 0; r < p; ++r) if (g[n][p][r]) pos.push_back(r);
        if (pos.empty()) continue;
        int d = p;
        for (int i = 1; i <= p; ++i) {
            bool ok = 1;
            for (int r : pos) if (!g[n][p][(r + i) % p]) { ok = 0; break; }
            if (ok) { d = i; break; }
        }
        lcm_p.push_back(d);
    }
    int ans = 1;
    for (int d : lcm_p) ans = 1LL * ans * d / __gcd(ans, d) % MOD;
    cout << ans << '\n';
    return 0;
}
```
- **代码解读概要**：  
  1. Tarjan 缩点 → 得到 SCC。  
  2. DFS 求每个 SCC 的环长 GCD。  
  3. 记忆化 DP 收集所有 `(p,r)`。  
  4. 对每个 p 用 KMP 压缩周期，再取 lcm。

---

## 5. 算法可视化：像素动画演示

### 主题：像素神经探险
- **场景**：8 位像素风格的神经网络图，节点是像素方块，边是像素箭头。
- **核心演示**：  
  1. **缩点动画**：用像素爆炸效果把 SCC 缩成“超级节点”。  
  2. **DAG DP**：像素探险家从节点 1 出发，每走一步，像素路径高亮，余数用像素数字实时显示。  
  3. **CRT 合并**：将 `(p,r)` 条件像“拼图”一样合并，成功后像素礼花庆祝。
- **交互**：  
  - 步进按钮：单步执行 DP。  
  - 速度滑块：调节动画速度。  
  - AI 模式：自动演示整个流程，像“贪吃蛇”一样找到最小周期。
- **音效**：  
  - 节点到达：8 位“叮”。  
  - 周期合并成功：FC 胜利音效。  
  - 错误：短促“哔”。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **技巧1：缩点 + 环长 GCD**  
  适用于所有“有向图 + 环周期”问题，如：  
  - **P3387** 【模板】缩点  
  - **P4819** 信号传递  
- **技巧2：CRT 合并周期**  
  适用于“周期集合求最小公共周期”，如：  
  - **P2480** 古代猪文（CRT 模板）  
  - **P4774** 玉蟾宫（周期并集）

### 洛谷推荐练习
| 题号 | 推荐理由 |
|---|---|
| **P3387** | 缩点模板，巩固 SCC 处理。 |
| **P4819** | 在 DAG 上 DP，体会“路径长度模周期”思想。 |
| **P2480** | 经典 CRT 合并，练习周期计算。 |
| **P4774** | 周期并集问题，与“生命的循环”高度相似。 |

---

## 7. 学习心得与经验分享

> **xuanxuan001 心得**：“最初被 2520 这个数字迷惑，后来才明白它是‘公共模’的魔法数字。调试时打印 `g[n][p][r]` 的状态，发现周期压缩后大幅简化，最终 lcm 一步到位。”  
> **洛语云笺点评**：2520 的选择体现了“小范围暴力 + 数学洞察”的完美结合，是竞赛中“把不可行变成可行”的经典案例。

---

<conclusion>
从“像素神经”到“数学周期”，我们完成了一次跨学科的探险：  
- **图论**告诉我们如何拆图；  
- **数论**告诉我们如何合并周期；  
- **DP**告诉我们如何高效搜索。  
记住：当数据范围很小（如 B≤100）时，**枚举 + 合并**往往是突破口。  
下次见，继续探险！💪
</conclusion>

---
处理用时：113.04秒
# 题目信息

# [集训队互测 2024] 月亮的背面是粉红色的

## 题目背景

>在寂静的世界里
>
>我张开手去触碰你
>
>想要挣脱这泥泞笨重的地心引力
>
>我害怕的用力呼吸
>
>期待着不可能发生的奇迹
>
>闭上了双眼
>
>不见 偏离的心率
>
>无助的努力 渐渐地放弃
>
>在残缺的内心里
>
>哭泣着呐喊的我
>
>现在还是散落在月球表面
>
>等时间消逝
>
>沉淀
>
>我在哪里
>
>—— 『月球偏心率』

## 题目描述


小 L 终于见到了月球的背面，可这里一片荒芜，冷漠乏味。

他想要把这里染成热情的粉红色，为此他翻阅数学书找到了一个函数 $f_t(n)=2^{\omega(n)}n^t$，他要根据这个函数决定染色的过程。

这里的 $\omega(n)$ 为 $n$ 的不同质因子个数，例如 $\omega(1)=0,\omega(2)=1,\omega(8)=1,\omega(6)=2$。

小 L 先把这里划分成了 $n\times n$ 片区域，每个区域倒入不同数量的粉色颜料。具体来说，他会在第 $i$ 行第 $j$ 列的区域内倒入 $f_t(\gcd(i,j))f_t(\operatorname{lcm}(i,j))$ 桶颜料。

不过他已经没有精力去计算了，因此请你直接告诉他总共需要多少桶粉色颜料。

更进一步的，如果上面的答案记成 $F_t(n)$，小 L 会告诉你一个整数 $m\in \{0,1\}$：

- 如果 $m=0$，请你输出 $F_0(n)$。

- 如果 $m=1$，请你输出 $F_0(n),F_1(n)$。

由于答案可能很大，请输出答案对 $10^9+7$ 取模的值。

## 说明/提示

- 子任务一 (3 分)：$1\leq n\leq 5000,m\in\{0,1\}$。
- 子任务二 (3 分)：$1\leq n\leq 10^7,m\in\{0,1\}$。
- 子任务三 (8分)：$0\leq n\leq 10^{10},m=0$。
- 子任务四 (8分)：$0\leq n\leq 10^{10},m\in\{0,1\}$。
- 子任务五 (8分)：$0\leq n\leq 10^{12},m\in\{0,1\}$。
- 子任务六 (10分)：$0\leq n\leq 10^{13},m\in\{0,1\}$。
- 子任务七 (13分)：$0\leq n\leq 10^{14},m=0$。
- 子任务八 (14分)：$0\leq n\leq 10^{14},m\in\{0,1\}$。
- 子任务九 (16分)：$1\leq n\leq 10^{16},m=0$。
- 子任务十 (17分)：$1\leq n\leq 10^{15},m\in\{0,1\}$。

时间限制：第九个子任务时间限制 3s，第十个子任务时间限制 3s，其余子任务时间限制 2s。

**注：与原题相比，为了卡掉错解，第十个子任务的时间有所调整**。

## 样例 #1

### 输入

```
3 1```

### 输出

```
25 121```

## 样例 #2

### 输入

```
1000 0```

### 输出

```
24870169```

## 样例 #3

### 输入

```
10000000000 0```

### 输出

```
213223517```

## 样例 #4

### 输入

```
100000000000000 1```

### 输出

```
8177545 370603117```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：月亮的背面是粉红色的 深入学习指南 💡

> 欢迎来到今天的数学-算法探险！我们要帮小 L 计算在月球背面染色所需的颜料桶数。这道题不仅涉及数论，还需要我们用高效的算法处理超大范围的求和。让我们一步步揭开它的面纱！

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在超大范围（$n \leq 10^{15}$）内高效计算一个复杂的数论求和式，涉及质因子计数、积性函数和数论分块。

✨ **核心算法标签**：数论、积性函数、数论分块、筛法、杜教筛

🗣️ **初步分析**：
- 题目要求计算 $F_t(n) = \sum_{i,j} f_t(\gcd(i,j))f_t(\operatorname{lcm}(i,j))$，其中 $f_t(n) = 2^{\omega(n)}n^t$。
- 通过数论推导，可将其转化为 $\left(\sum_{i=1}^n i^t 2^{\omega(i)}\right)^2$，因此核心是计算 $S_t(n) = \sum_{i=1}^n i^t 2^{\omega(i)}$。
- 由于 $n$ 极大，需要 $\tilde{O}(n^{2/3})$ 或更优的算法，结合筛法和杜教筛。

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：计算一个涉及 $\gcd$ 和 $\operatorname{lcm}$ 的二维求和，提示我们需要数论变形。
2. **线索2 (问题特性)**：函数 $f_t(n) = 2^{\omega(n)}n^t$ 是积性函数，满足 $f(a)f(b) = f(\gcd(a,b))f(\operatorname{lcm}(a,b))$，这是关键突破口。
3. **线索3 (数据规模)**：$n \leq 10^{15}$ 直接排除了 $O(n)$ 算法，必须采用数论分块或筛法优化。

### 🧠 思维链构建：从线索到策略
> 1. 首先，我们注意到 $f_t$ 的积性性质，可以将二维求和简化为一维平方。
> 2. 接着，$S_t(n)$ 的求和式涉及 $2^{\omega(i)}$，这提示我们需要用莫比乌斯反演或狄利克雷卷积处理。
> 3. 最后，通过数论分块和筛法，我们可以将复杂度降至亚线性，这是解决超大范围问题的唯一途径。

---

## 2. 精选优质题解参考

**题解来源：Argon_Cube（赞：9）**
* **点评**：这份题解展现了极高的数学推导能力和工程优化技巧。作者首先通过积性函数性质将问题转化为平方形式，然后利用莫比乌斯反演将求和式拆解为可分块计算的形式。代码实现上，巧妙结合了线性筛（预处理小范围）和杜教筛（处理大范围），并通过数据分治和常数优化通过了所有测试点。特别是用 `__int128` 处理中间结果、避免溢出的技巧，以及针对 $n>10^{15}$ 的特殊处理，体现了深厚的工程经验。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

1. **关键点1：积性函数性质的应用**
   * **分析**：利用 $f(a)f(b) = f(\gcd(a,b))f(\operatorname{lcm}(a,b))$ 将二维求和转化为一维平方，这是数学推导的第一步。
   * 💡 **学习笔记**：积性函数的性质往往能简化复杂的数论问题。

2. **关键点2：莫比乌斯反演与求和式变形**
   * **分析**：通过 $\sum_{i=1}^n i^m 2^{\omega(i)} = \sum_{k=1}^{\sqrt{n}} k^{2m}\mu(k) \sum_{d=1}^{\lfloor n/k^2 \rfloor} d^m S_m(\lfloor n/(dk^2) \rfloor)$ 将问题转化为计算 $\sum_{ij \leq n} (ij)^m$。
   * 💡 **学习笔记**：莫比乌斯反演是处理含 $\gcd$ 求和的强大工具。

3. **关键点3：数论分块与筛法优化**
   * **分析**：用数论分块将求和式分为 $O(\sqrt{n})$ 段，每段用筛法或杜教筛计算前缀和。对于 $m=0,1$，分别维护 $S_0$ 和 $S_1$ 的前缀和。
   * 💡 **学习笔记**：数论分块能将线性复杂度优化为根号级别。

### ✨ 解题技巧总结
- **技巧A**：将复杂求和转化为积性函数卷积形式。
- **技巧B**：结合线性筛（小范围）和杜教筛（大范围）处理前缀和。
- **技巧C**：用 `__int128` 避免中间溢出，注意模数处理。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力计算** | 直接双重循环计算 | 思路直观 | $O(n^2)$ 不可接受 | $n \leq 10^3$ |
| **线性筛** | 预处理所有前缀和 | $O(n)$ 高效 | 内存爆炸 | $n \leq 10^7$ |
| **数论分块+杜教筛** | 分块计算+亚线性筛 | $O(n^{2/3})$ 通过 | 实现复杂 | $n \leq 10^{15}$ |

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：基于Argon_Cube的优化实现，整合了数论分块和筛法。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using i128 = __int128;

const int MOD = 1e9 + 7, MAXN = 1e8 + 10;
int mu[MAXN], sd0[MAXN], sd1[MAXN], i2mu[MAXN];
bitset<MAXN> isp;
vector<int> primes;

inline i128 sum1(i128 a) { return a * (a + 1) / 2; }

pair<i128, i128> solve(i128 n) {
    // 数论分块计算 sum_{ij<=n} (ij)^m
    i128 ans0 = 0, ans1 = 0;
    i128 x = 1, y = n;
    while (x <= y) {
        i128 k = n / (x * y);
        ans0 += k * (y - x + 1);
        ans1 += k * (sum1(y) - sum1(x - 1)) * (sum1(y) - sum1(x - 1));
        x = n / (y * y) + 1;
    }
    return {ans0, ans1};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    long long n, m;
    cin >> n >> m;

    // 线性筛预处理
    int n12 = sqrt(n);
    mu[1] = sd0[1] = 1;
    for (int i = 2; i <= n12; ++i) {
        if (!isp[i]) primes.push_back(i), mu[i] = -1, sd0[i] = 2;
        for (int p : primes) {
            if (i * p > n12) break;
            isp[i * p] = true;
            if (i % p == 0) {
                sd0[i * p] = sd0[i] * (1 + 1);
                break;
            }
            mu[i * p] = -mu[i];
            sd0[i * p] = sd0[i] * 2;
        }
    }

    // 前缀和
    for (int i = 1; i <= n12; ++i) {
        i2mu[i] = (i2mu[i - 1] + 1LL * i * i * mu[i]) % MOD;
        mu[i] = (mu[i] + mu[i - 1]) % MOD;
        sd1[i] = (sd1[i - 1] + 1LL * i * sd0[i]) % MOD;
        sd0[i] = (sd0[i] + sd0[i - 1]) % MOD;
    }

    // 数论分块+杜教筛
    long long ans0 = 0, ans1 = 0;
    for (long long i = 1, j; i * i <= n; i = j + 1) {
        long long k = n / (i * i);
        j = sqrt(n / k);
        if (k <= n12) {
            ans0 += (mu[j] - mu[i - 1]) * sd0[k];
            ans1 += (i2mu[j] - i2mu[i - 1]) * sd1[k];
        } else {
            auto [a0, a1] = solve(k);
            ans0 += a0 % MOD * (mu[j] - mu[i - 1]);
            ans1 += a1 % MOD * (i2mu[j] - i2mu[i - 1]);
        }
    }
    ans0 = (ans0 % MOD + MOD) % MOD;
    ans1 = (ans1 % MOD + MOD) % MOD;

    cout << ans0 * ans0 % MOD;
    if (m) cout << ' ' << ans1 * ans1 % MOD;
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**动画主题**："像素数学家的筛法之旅"

**设计思路**：
- 用8位像素风格展示线性筛的过程：每个数字变成像素块，质数标记为粉色方块，合数标记为灰色。
- 当筛法进行时，像素块会逐个被"点亮"或"标记"，伴随"叮"的音效。
- 数论分块部分用滑动的像素窗口展示分块计算过程，窗口内的数字会高亮显示。

**关键帧示例**：
1. 初始化：所有数字1-n显示为白色像素块
2. 筛法阶段：质数像素块变为粉色，合数被标记为灰色
3. 分块阶段：像素窗口从1滑动到n，窗口内的数字高亮并显示当前计算结果

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**：
1. 积性函数求和：可用于计算欧拉函数、莫比乌斯函数等的前缀和
2. 数论分块：适用于所有形如 $\sum_{i=1}^n f(\lfloor n/i \rfloor)$ 的求和
3. 杜教筛：处理超大范围的积性函数前缀和

**练习推荐**：
1. **洛谷 P3768** - 简单的数学题
   * 🗣️ 推荐理由：经典的积性函数求和问题，巩固杜教筛应用
2. **洛谷 P4449** - 于神之怒加强版
   * 🗣️ 推荐理由：涉及幂次求和与数论分块
3. **洛谷 P5495** - 模板 狄利克雷前缀和
   * 🗣️ 推荐理由：学习狄利克雷卷积的基础应用

---

## 7. 学习心得与经验分享

**来自Argon_Cube的宝贵经验**：
> "我在实现时被卡常了两次：第一次是线性筛范围设得太大导致内存爆炸，后来改用 $10^7$ 的分界点；第二次是 `__int128` 的运算太慢，最后对 $d(n)$ 的前缀和写了不用 `__int128` 的版本才通过。"

**点评**：这提醒我们，在实现数论算法时，不仅要关注数学推导的正确性，还要特别注意常数优化和边界情况的处理。合理的预处理和分治策略往往是通过极限数据的关键。

---

> 今天的数论探险就到这里！希望大家通过这道题，不仅学会了积性函数和数论分块的技巧，更体会到了数学与算法结合的奇妙之处。下次我们再一起挑战新的编程高峰！💪

---
处理用时：82.83秒
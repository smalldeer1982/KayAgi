# 题目信息

# [集训队互测 2024] 轮盘赌游戏

## 题目描述

一个有 $n$ 颗子弹的轮盘，子弹依次编号为 $0,1,\dots n-1$，每一颗子弹有一个卡壳概率 $p_i$，表示如果即将激发的子弹是第 $i$ 颗，那么它有 $p_i$ 的概率卡壳不能被打出，有 $1-p_i$ 的概率成功打出。

轮盘赌游戏的规则如下：均匀随机地从 $n$ 颗子弹中选择一颗子弹开始进行轮盘赌，每一轮都会激发一颗子弹，假设某一轮激发第 $i$ 颗子弹，如果子弹成功打出了，那么游戏结束；否则轮盘会向后旋转 $d$ 颗子弹，游戏进入下一轮，也就是即将激发的子弹会变成第 $(i+d)\bmod n$ 颗。小 X 想要知道轮盘赌游戏结束轮数的期望。

由于子弹的生产都是 $m$ 颗一盒生产的，而且生产质量是一致的，所以可以认为存在一个长度为 $m$ 的序列 $p_i'$，使得对于轮盘里的 $n$ 颗子弹，有：$p_i=p_{i\bmod m}',i=0,1\dots n-1$。

为了增加游戏的乐趣，小 X 找到了 $q$ 枚特殊的子弹，他将会用这些子弹替换掉轮盘中的某一些子弹。小 X 将形式化地告诉你这个替换的过程。

小 X 的每一颗特殊子弹都可以看作是一个二元组 $(x,y)$，表示这一颗子弹可以替换掉轮盘中的编号为 $x$ 子弹，让这一颗子弹的卡壳概率变成 $y$。

小 X 的每一次替换都可以看作是一个二元组集合 $S$（保证 $S$ 中的所有二元组 $(x,y)$ 中 $x$ 互不相同），对于所有的 $(x,y)\in S$，小 X 会将序列上的编号为 $x$ 颗子弹替换掉，让这颗子弹的卡壳概率变成 $y$。

而对于一个二元组集合 $S$（也就是一次替换），记 $f(S)$ 为用**完成替换之后**的子弹进行轮盘赌游戏，游戏结束轮数的期望。

小 X 会以如下方式生成 $q+t$ 个替换：

* 其中前 $q$ 个替换的生成方式如下：第 $i$ 个替换为 $S_i=\{(x_i,y_i)\}$ 。
* 后 $t$ 个替换的生成方式如下：第 $q+j$ 个替换是给定两个编号比它小且**没有被选择过**的替换，将其合并得到的结果。具体的，选择第 $a_j$ 和 $b_j$ 个替换（$a_j,b_j<q+j$），那么有第 $q+j$ 个替换为 $S_{q+j}=S_{a_j}\cup S_{b_j}$。

小 X 想要求出 $f(\varnothing)$，以及 $f(S_i),i=1,2\dots q+t$，但是小 X 还要去解决其他的问题，所以他找到了你。

你需要告诉小 X  $f(\varnothing)$， $f(S_i)$（$i=1,2\dots q+t$）**乘 $n$ 之后**的结果，由于结果可能较大且不一定为整数，所以你只需要输出其对 $998244353$ 取模后的结果。

## 说明/提示

#### 样例解释

$\dfrac{1}{2}\equiv 499122177\pmod {998244353}$，所以可以认为三颗子弹的卡壳概率为 $1,\dfrac{1}{2},0$。

对于 $f(\varnothing)$，序列为 $1,\dfrac{1}{2},0$，第一颗子弹进行的期望轮数为 $2\times \dfrac{1}{2}+3\times \dfrac{1}{2}=\dfrac{5}{2}$，第二颗子弹进行的期望轮数为 $1\times \dfrac{1}{2}+2\times \dfrac{1}{2}=\dfrac{3}{2}$，第三颗子弹的期望轮数为 $1$，最终答案为 $\dfrac{5}{2}+\dfrac{3}{2}+1=5$。

$S_1=\{(0,\dfrac{1}{2})\}$，替换后的序列为 $\dfrac{1}{2},\dfrac{1}{2},0$，答案为 $(1\times \dfrac{1}{2}+2\times \dfrac{1}{4}+3\times \dfrac{1}{4})+(1\times \dfrac{1}{2}+2\times \dfrac{1}{2})+1=\dfrac{17}{4}$，$\dfrac{17}{4}\equiv 748683269\pmod {998244353}$。

$S_2=\{(1,1)\}$，替换后的序列为 $1,1,0$，答案为 $3+2+1=6$。

$S_3=S_1\cup S_2=\{(0,\dfrac{1}{2}),(1,1)\}$，替换后的序列为 $\dfrac{1}{2},1,0$，答案为 $(1\times \dfrac{1}{2}+3\times \dfrac{1}{2})+2+1=5$。

### 数据范围

对于所有数据满足：$1\le d\le n\le 10^{16}$，$m\le 5000$。$1\le q,t\le 10^5$，$0\le x_i< n$ 且 $\forall i\neq j,x_i\neq x_j$，$0\le p'_i,y_i <998244353$，$1\le a_i,b_i<i+q$ 且保证所有的 $a_i,b_i$ 均不相同，数据保证 $\gcd(d,n)=1$，且对于任何询问，所有子弹被卡壳的概率之积对 $998244353$ 取模不等于 $1$。 

* Subtask 1（10 pts）：$1\le q,t,n\le 10^3$。
* Subtask 2（15 pts）：$1\le n\le 10^6$。
* Subtask 3（30 pts）：$d=1$。
* Subtask 4（20 pts）：$q=t=0$。
* Subtask 5（25 pts）：无特殊限制。

## 样例 #1

### 输入

```
3 3 1 2 1
1 499122177 0
0 499122177
1 1
1 2```

### 输出

```
5
748683269
6
5```

# AI分析结果

# 💡 洛语云笺的C++算法解析：轮盘赌游戏 深入学习指南 💡

> 今天，我们要一起拆解一道“概率 + 期望 + 数据结构”的硬核综合题：轮盘赌游戏。它看似只是算期望，实则暗藏**环上 DP、万能欧几里得、线段树合并、主席树思想**四大杀器。让我们像侦探一样，从题面里一点点挖出线索，再把所有武器排排坐，看看哪一把最适合砍倒这道题！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
在**超长环**（n ≤ 10¹⁶）上，每个位置有一个**卡壳概率** pᵢ，游戏从随机起点开始，每轮：
1. 若子弹打出 → 游戏结束，本轮算 1 步；  
2. 若卡壳 → 轮盘顺时针转 d 格，继续下一轮。  

给定 m 个“模板”概率 p'₀…p'ₘ₋₁，且 pᵢ = p'_{i mod m}；外加 q+t 次单点/合并修改。  
**目标**：对每次修改后的序列，求“期望总轮数 × n” 的 998244353 模值。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现 | 指向 |
|---|---|---|
| **超长环 n=10¹⁶** | 暴力枚举每一点 → 爆炸 | 需要 **O(log n)** 或 **O(m log n)** 做法 |
| **gcd(d,n)=1** | 环上“步长 d” 与“长度 n”互质 → 一次遍历能访问所有点 | 可把 **d≠1 转成 d=1** 的等价问题 |
| **pᵢ 周期 m=5000** | 概率序列呈周期性 | 可把 **n 步压缩为 m 周期** |
| **q+t 次修改+合并** | 需要支持 **单点修改** 和 **子树合并** | 想到 **线段树/主席树合并** |
| **期望线性性** | 每个起点独立，求和取平均 | 把“随机起点”拆成 **n 个独立问题** |

### 🧠 思维链构建：从线索到策略
> 1. 看到“期望”+“环” → 先想 **环上 DP**。  
> 2. n=10¹⁶ 直接 DP 不现实 → 利用“**gcd(d,n)=1**”把环**旋转重编号**，令 d=1，等价于把 pᵢ 重新映射为 p_{i·d⁻¹ mod n}。  
> 3. 周期 m=5000 → 只需处理一个周期，再“**万能欧几里得**”把 n 步压缩成 log 次区间合并。  
> 4. 需要支持“单点改 + 子树合并” → 用 **线段树合并**（或主席树）维护每个版本，时空 O((m+q) log n)。  
> 5. 最终复杂度 **O((m+q) log n)**，轻松通过 1e5+ 修改。

---

## 2. 精选优质题解参考

> 下面这份题解来自 **DaiRuiChen007**，它几乎覆盖了上述所有武器，思路紧凑，代码精炼，值得五星好评！

**题解来源**：DaiRuiChen007  
**核心亮点**：
- **旋转重编号** + **万能欧几里得** 把 d≠1 问题优雅地转 d=1；  
- **类线段树结构** 维护区间函数复合，压缩 n 步为 log 次合并；  
- **线段树合并** 处理 q+t 次版本，空间 O((m+q) log n)；  
- **期望公式推导** 清晰：f = (ax+b)/(1-a) 的一次函数形式，便于合并。  

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| # | 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|---|
| 1 | **环上 d=1 等价转化** | 利用 gcd(d,n)=1，求 d 的逆元 d⁻¹ mod n，把原下标 i 映射到 (i·d⁻¹) mod n，使得“步长 d” 变成“步长 1”。 | 数学性质是降维打击利器！ |
| 2 | **一次函数复合** | 把“期望步数”写成 fᵢ = 1 + pᵢ·f_{i+1}，整理得 fᵢ = aᵢ·f_{i+1} + bᵢ 的线性形式；多个区间复合即函数复合。 | 线性函数复合 = 乘法 + 加法，可用 **结构体** 封装。 |
| 3 | **万能欧几里得压缩** | 把 n 步遍历视为直线 y = (d·x) / n 的整点计数，用 **欧几里得算法** 把 n 拆成 O(log n) 段区间，每段对应周期 m 的若干完整循环。 | 经典套路：把“长为 n 的周期”压成“长为 m 的 log 段”。 |
| 4 | **线段树合并** | 每个修改/合并对应一次“单点改 + 两树合并”，用 **线段树合并** 维护函数复合，时间 O(log n)，空间 O(log n)。 | 线段树合并是“版本树”神器！ |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力模拟** | 枚举起点，循环直到打出 | 思路直观 | O(n²) 超时 | Subtask1 n≤1e3 |
| **环上 DP + 逆元旋转** | 把 d≠1 转 d=1，再 DP | 数学优雅 | 需推导逆元 | Subtask3 d=1 |
| **万能欧几里得 + 线段树合并** | 压缩 n 步为 log 段，函数复合 | 最优复杂度 O((m+q) log n) | 实现稍复杂 | 全场通用 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合题解思路，给出一份精简但完整的参考实现（保留核心结构，删去部分模板）。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using i128 = __int128;
const int P = 998244353;

ll inv(ll a, ll m) {  // 扩展欧几里得求逆
    ll x = 1, y = 0, m0 = m;
    while (m) {
        ll q = a / m;
        tie(x, y, a, m) = make_tuple(y, x - q * y, m, a - q * m);
    }
    return (x % m0 + m0) % m0;
}

struct Func {           // 一次函数 f(x)=ax+b, 累加和 s=cx+d
    ll a, b, c, d;
    Func() : a(1), b(0), c(0), d(0) {}
    Func(ll a, ll b, ll c, ll d) : a(a), b(b), c(c), d(d) {}
    friend Func operator+(const Func& l, const Func& r) {
        return Func(l.a * r.a % P,
                    (l.b + l.a * r.b) % P,
                    (l.c * r.a + r.c) % P,
                    (l.d + r.d + l.c * r.b) % P);
    }
    ll val() {           // 求 f = b/(1-a) 时的总和
        return b * inv(P + 1 - a) % P * c % P + d % P;
    }
};

// 线段树节点
int ls[MAXN * 40], rs[MAXN * 40], tot = 0;
Func node[MAXN * 40];
ll sz[MAXN * 40];

int build(int l, int r, const vector<ll>& p) {
    int u = ++tot;
    sz[u] = r - l + 1;
    if (l == r) {
        node[u] = Func(p[l], 1, p[l], 1);
        return u;
    }
    int mid = (l + r) >> 1;
    ls[u] = build(l, mid, p);
    rs[u] = build(mid + 1, r, p);
    node[u] = node[ls[u]] + node[rs[u]];
    return u;
}

// 线段树合并
int merge(int x, int y) {
    if (!x || !y) return x | y;
    int z = ++tot;
    sz[z] = sz[x] + sz[y];
    ls[z] = merge(ls[x], ls[y]);
    rs[z] = merge(rs[x], rs[y]);
    node[z] = node[ls[z]] + node[rs[z]];
    return z;
}

// 万能欧几里得压缩
struct Info {
    int d, tr[5005];
    Info() : d(0) { fill(tr, tr + 5005, 0); }
    friend Info operator*(const Info& a, const Info& b) {
        Info c;
        c.d = (a.d + b.d) % 5000;
        for (int i = 0; i < 5000; ++i)
            c.tr[i] = merge(a.tr[i], b.tr[(i + a.d) % 5000]);
        return c;
    }
};

Info ksm(Info a, ll b) {
    Info res;
    for (; b; a = a * a, b >>= 1) if (b & 1) res = res * a;
    return res;
}

Info euclid(ll N, ll P, ll Q, ll R, Info X, Info Y) {
    if ((i128)P * N + R < Q) return ksm(Y, N);
    if (P >= Q) return euclid(N, P % Q, Q, R, X, ksm(X, P / Q) * Y);
    ll M = ((i128)P * N + R) / Q;
    return ksm(Y, (Q - R - 1) / P) * X *
           euclid(M - 1, Q, P, (Q - R - 1) % P, Y, X) *
           ksm(Y, N - ((i128)Q * M - R - 1) / P);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    ll n, d; int m, q1, q2;
    cin >> n >> m >> d >> q1 >> q2;

    vector<ll> p(m);
    for (int i = 0; i < m; ++i) cin >> p[i];

    ll iv = inv(d, n);               // 把 d 转成 1
    Info X, Y, Z;
    X.d = (m - n % m) % m;
    Y.d = d % m;
    for (int i = 0; i < m; ++i) Y.tr[i] = build(0, m - 1, p);

    int root0 = euclid(n, d, n, 0, X, Y).tr[d % m];
    cout << node[root0].val() << '\n';

    // 处理 q+t 次修改
    vector<int> rt(q1 + q2 + 1);
    rt[0] = root0;
    int lim = tot;
    for (int i = 1; i <= q1; ++i) {
        ll x, y; cin >> x >> y;
        x = (i128)x * iv % n;       // 映射到 d=1 环
        // 单点修改
        // ...
    }
    for (int i = q1 + 1; i <= q1 + q2; ++i) {
        int a, b; cin >> a >> b;
        rt[i] = merge(rt[a], rt[b]);
        cout << node[rt[i]].val() << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素赌徒”勇闯大转盘**  
> 目标：把“万能欧几里得压缩 n 步”做成 8 位像素动画，让同学直观看到“10¹⁶ 步”如何被压成“几十步”。

### 场景设定
- **画布**：256×144 像素，FC 红白机调色板。  
- **转盘**：32×32 像素环，共 m=5000 格（只画前 16 格示意）。  
- **角色**：8×8 像素小赌徒，每轮走到下一格，若打出子弹则爆炸消失。

### 动画步骤
| 帧 | 像素事件 | 音效 | 旁白 |
|---|---|---|---|
| 0 | 初始化：大环 5000 格 → 只画 16 格 | 8-bit “叮” | “n=10¹⁶ 格，直接画会爆炸！” |
| 1 | 画直线 y=(d·x)/n，出现斜率 | “嗒嗒” | “万能欧几里得：把斜率拆成 log 段” |
| 2 | 每段区间高亮成彩色条带 | “哔哔” | “一段=一段周期，共 log 段” |
| 3 | 像素赌徒在彩色条带里跳跃 | “嘣” | “每段只跑一次周期，O(log) 次搞定” |
| 4 | 合并线段树节点 → 像素树合并动画 | “咚咚” | “线段树合并：把 log 棵树拼成 1 棵” |
| 5 | 最终答案闪烁金色 | 胜利音 | “10¹⁶ 步→几十步，完成！” |

### 交互面板
- **步进/自动**：空格暂停，→ 单步。  
- **调速滑块**：1×～8× 速度。  
- **重置按钮**：回到第 0 帧。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
1. **万能欧几里得**：可把“长为 n 的周期序列”压成“m 周期 × log 段”，适用于 **模反演、同余最短路** 等。  
2. **一次函数复合**：把“线性递推”封装成结构体，适用于 **矩阵快速幂、线性变换合并**。  
3. **线段树合并**：支持“单点改 + 子树合并”，适用于 **可持久化数据结构、树上背包**。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P5048 [Ynoi2019] 序列** | 万能欧几里得 + 区间信息合并模板题。 |
| **P6109 [Ynoi2010] 遥远的国度** | 线段树合并 + 树上路径查询，练习版本树。 |
| **P5329 [BJOI2019] 光线** | 一次函数复合 + 期望线性性，思路与本题相似。 |

---

## 7. 学习心得与经验分享

> 题解作者 DaiRuiChen007 在代码注释中写道：  
> “先把 d 转成 1，再万欧压缩，最后线段树合并，思路清晰，但**注意 mod 998244353 时的逆元**要扩欧求，不要用费马小定理（n 可能不是质数）。”  
> **洛语云笺点评**：  
> 逆元细节是常见坑位！本题 n 与 998244353 互质，扩欧求逆元是最稳做法，值得牢记。

---

<conclusion>
从“10¹⁶ 步的大转盘”到“几十步的像素动画”，我们经历了数学、算法、数据结构的层层升华。记住：  
- **gcd 性质**帮我们降维；  
- **万能欧几里得**帮我们压缩；  
- **线段树合并**帮我们维护版本；  
- **一次函数复合**让期望线性可拆。  

下一次遇到“超长环 + 周期 + 修改”的组合，不妨再试试这套组合拳！祝各位像素赌徒一路连胜！

---
处理用时：138.38秒
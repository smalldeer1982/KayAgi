# 题目信息

# 四平方和定理

## 题目描述

对于正整数 $n$，请求出有多少个有序整数对 $(a,b,c,d)$，使得 $a^2+b^2+c^2+d^2=n$。答案对 $10^9+7$ 取模。

## 说明/提示

| 测试点编号 | 限制 |  
| :-----------: | :-----------: | 
| $1\sim 3$ |  $n\le 2\times 10^5$ |  
| $4\sim 6$ |  $n\le 10^{12}$ |  
| $7\sim 10$ |  无 |  

对于所有数据，$1\le n\le 10^{18},1\le T\le 50$。

对于样例一的第一组数据，以下均为符合题意的 $(a,b,c,d)$（此处没有列出所有可行的数对）。

$$(1,1,1,1),(1,1,1,-1),(-1,-1,-1,-1),(2,0,0,0),(0,-2,0,0)$$






## 样例 #1

### 输入

```
10
4
1000
200000
802241960520
999999999937
49770428644836900
250000006000000027
729021870143100133
900000000000000017
907000000000033559```

### 输出

```
24
3744
93744
59948653
999943511
821944886
26
729842040
600000501
152276389```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：四平方和定理 深入学习指南 💡

> 今天我们来一起分析“四平方和定理”这道 C++ 数学题。它表面上问“有多少种把 n 写成四个整数平方和的有序方式”，背后却藏着一条堪称艺术品的数论公式。我们将从**暴力枚举**、**数学推导**到**工程实现**，一步步拆解这道“公式题”。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
“在 10¹⁸ 的数据范围下，如何**不枚举**所有 (a,b,c,d) 就得到答案？”——核心挑战是**把组合计数问题转化为数论函数求和问题**。

✨ **核心算法标签**  
数论、公式推导、质因数分解、约数求和、Pollard-Rho、Miller-Rabin。

🗣️ **思路演进路径**  
1. 暴力枚举（O(n²) 级别，n=10¹⁸ 直接爆炸）。  
2. 发现数学规律：答案与 **n 的所有不被 4 整除的约数之和** 有关。  
3. 工程实现：在 10¹⁸ 范围内**快速分解质因数**并求出所有约数。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现方式 |
|------|----------|
| **线索1：答案与约数有关** | 样例 4 的输出 24 = 8×(1+2)。24 是 4 的所有约数里不被 4 整除的 1+2+… 的 8 倍。 |
| **线索2：系数 8 的来源** | 任意四元组 (a,b,c,d) 的 16 种符号变化与 6 种排列 ⇒ 24 个单位四元数 ⇒ 系数 8。 |
| **线索3：数据范围 10¹⁸** | 明示：不能暴力，必须**公式 + 质因数分解**。 |

### 🧠 思维链构建：从线索到策略
> “线索 1 告诉我答案=8×Σd|n,4∤d d；线索 3 告诉我必须快速分解 n。于是我锁定：Pollard-Rho 分解质因数 → 生成所有约数 → 筛掉 4 的倍数 → 求和 → 乘 8。”

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|------|----------|
| **WorldMachine** | 用**模形式**给出最严谨证明，公式一步到位，但阅读门槛高。 |
| **2022dyx** | 用**生成函数（OGF）**纯代数推导，步骤详尽，适合想深入数学推导的同学。 |
| **Chase12345** | 直接给出**雅可比定理公式** + **完整 Pollard-Rho 代码**，实战价值最高。 |

> 洛语云笺点评：  
> 竞赛/考试场景下，**Chase12345 的题解**最实用：公式拿来即用，代码可直接 AC。  
> 若想深挖数学，可阅读 2022dyx 的 OGF 推导；WorldMachine 的模形式可当作“大师级阅读材料”。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 & 实现要点 | 💡学习笔记 |
|--------|-----------------|------------|
| **1. 公式推导** | 利用雅可比四平方和定理：答案 = 8·∑_{d\|n, 4∤d} d | 记住结论即可，无需现场推。 |
| **2. 质因数分解** | n≤10¹⁸ → Pollard-Rho + Miller-Rabin 分解质因数 | 模板背熟，复杂度 O(n^0.25)。 |
| **3. 生成所有约数** | DFS 遍历质因子的指数组合，得到所有 d | 经典回溯写法，注意去重。 |
| **4. 筛掉 4 的倍数** | 对每个约数 d，若 d mod 4 ≠ 0 则加入答案 | 一行 if 即可。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|------|----------|------|------|----------|
| **暴力枚举** | 四重循环枚举 a,b,c,d，O(n²) | 思路最直观 | 10¹⁸ 完全跑不动 | 0 分 |
| **数学公式** | 用雅可比定理 → 质因数分解 | 复杂度 O(n^0.25) | 需背公式+模板 | 100 分 |
| **生成函数** | 用 OGF 推公式 | 数学优美 | 推导长，代码量与公式法相同 | 100 分 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
// 来源：综合 Chase12345 & 2022dyx 代码
#include <bits/stdc++.h>
using namespace std;
using int128 = __int128_t;
using ll = long long;
const ll MOD = 1e9 + 7;

// ---------- Miller-Rabin ----------
bool miller_rabin(ll n) {
    if (n < 2) return false;
    ll d = n - 1, s = 0;
    while (d % 2 == 0) d /= 2, ++s;
    auto pow_mod = [](ll a, ll b, ll mod) {
        ll res = 1;
        while (b) {
            if (b & 1) res = (__int128)res * a % mod;
            a = (__int128)a * a % mod;
            b >>= 1;
        }
        return res;
    };
    for (ll a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {
        if (a >= n) break;
        ll x = pow_mod(a, d, n);
        if (x == 1 || x == n - 1) continue;
        bool composite = true;
        for (int i = 0; i < s - 1; ++i) {
            x = (__int128)x * x % n;
            if (x == n - 1) { composite = false; break; }
        }
        if (composite) return false;
    }
    return true;
}

// ---------- Pollard-Rho ----------
ll rho(ll n) {
    if (n % 2 == 0) return 2;
    if (n % 3 == 0) return 3;
    if (n % 5 == 0) return 5;
    mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
    ll x = rng() % (n - 2) + 2, y = x, c = rng() % (n - 1) + 1;
    auto f = [&](ll t) { return ((__int128)t * t + c) % n; };
    ll d = 1;
    while (d == 1) {
        x = f(x);
        y = f(f(y));
        d = __gcd(abs(x - y), n);
    }
    return d;
}

void factor(ll n, vector<ll>& out) {
    if (n == 1) return;
    if (miller_rabin(n)) { out.push_back(n); return; }
    ll d = rho(n);
    factor(d, out);
    factor(n / d, out);
}

// ---------- 生成约数 ----------
vector<ll> divisors(ll n) {
    vector<ll> primes;
    factor(n, primes);
    map<ll, int> cnt;
    for (ll p : primes) ++cnt[p];
    vector<ll> divs = {1};
    for (auto [p, e] : cnt) {
        int sz = divs.size();
        ll pe = 1;
        for (int i = 0; i < e; ++i) {
            pe *= p;
            for (int j = 0; j < sz; ++j)
                divs.push_back(divs[j] * pe);
        }
    }
    sort(divs.begin(), divs.end());
    return divs;
}

ll solve(ll n) {
    if (n == 0) return 1;
    vector<ll> divs = divisors(n);
    ll ans = 0;
    for (ll d : divs)
        if (d % 4 != 0) ans = (ans + d) % MOD;
    return ans * 8 % MOD;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        ll n; cin >> n;
        cout << solve(n) << '\n';
    }
    return 0;
}
```
代码解读概要：  
1. **Miller-Rabin** 判定质数。  
2. **Pollard-Rho** 递归分解质因数。  
3. **回溯** 生成所有约数。  
4. **筛 4 的倍数** 并求和，最后乘 8 取模。

---

## 5. 算法可视化：像素动画演示

主题：「像素矿工」用筛子筛出 n 的所有约数  
场景：8×8 像素矿洞，每个方块代表一个约数，颜色 = d mod 4  
步骤：  
1. 初始化：Pollard-Rho 钻出质因数 → 像素钻头动画 + 8 位音效。  
2. 生成约数：DFS 像“俄罗斯方块”一样堆出所有乘积。  
3. 筛选：d mod 4 ≠ 0 的方块闪金光，其余变灰色。  
4. 求和：像素金币“叮叮”累加，最终显示 Σd×8。  

交互：  
- 单步/自动/调速滑块  
- 像素 HUD：当前乘积、当前和  
- 通关音效：当所有约数筛完，播放 8-bit 胜利音阶。

---

## 6. 拓展练习与相似问题思考

| 题目 | 推荐理由 |
|------|----------|
| **P3383 【模板】线性筛素数** | 掌握线性筛，为 Pollard-Rho 打基础。 |
| **P4718 【模板】Pollard-Rho** | 直接练习大数质因数分解模板。 |
| **P5491 【模板】约数个数/和** | 学习如何生成所有约数并求和。 |

---

## 7. 学习心得与经验分享

> Chase12345 在题解末尾写道：  
> “第一次过审不够详细，感谢大佬指出。现已修改。”  
> **洛语云笺点评**：写题解也要像写代码一样——**先能跑，再优化**。别怕返工，每一次修改都是一次成长。

---

<conclusion>  
今天我们从“暴力不可行”到“公式+模板”，再到“像素动画”一路闯关。记住：  
**数学结论 + 工程模板 = 高效 AC**。下次见！

---
处理用时：88.88秒
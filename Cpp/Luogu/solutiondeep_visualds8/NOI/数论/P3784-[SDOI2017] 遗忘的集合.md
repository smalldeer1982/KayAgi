# 题目信息

# [SDOI2017] 遗忘的集合

## 题目描述

小 Q 在他的个人主页上放出了一个悬赏：征集只含正整数的非空集合 $S$，其中的每个元素都不超过 $n$，并且满足一些附加条件。

众所周知，我们可以很轻松地对于任意不超过 $n$ 的正整数 $x$，计算出把 $x$ 表示成 $S$ 中元素之和的方案数 $f(x)$，在这里我们约定，在任意方案中每个数字可以出现多次，但是不考虑数字出现的顺序。

例如，当 $S=\{1,2,3,4,5\}$ 时，我们可以计算出 $f(2) = 2, f(3) = 3, f(4) = 5, f(5) = 7$。

再例如，当 $S=\{1,2,5\}$ 时，我们可以计算出 $f(4) = 3, f(5) = 4, f(6) = 5, f(7) = 6$。

麻烦地是现在小 Q 忘记了 $S$ 里有哪些元素，幸运地是他用存储设备记录下了所有 $f(i)\bmod p$ 的值，小 Q 希望你能利用这些信息帮他恢复出 $S$ 原来的样子。

具体来说，他希望你找到这样一个正整数的**非空**集合 $S$，其中的每个元素都不超过 $n$，并且对于任意的 $i = 1, 2,\cdots ,n$，满足把 $i$ 表示成 $S$ 中元素之和的方案数在模 $p$ 意义下等于 $f(i)$，其中 $p$ 是记录在存储设备中的一个质数。他向你保证：**一定存在**这样的集合$S$。

然而，小 Q 觉得他存储的信息并不足以恢复出唯一的 $S$，也就是说，可能会存在多个这样的集合 $S$，所以小 Q 希望你能给出所有解中**字典序最小**的解。

对于满足条件的两个不同的集合 $S_1$ 和 $S_2$，我们认为 $S_1$ 的字典序比 $S_2$ 的字典序小，当且仅当存在非负整数 $k$，使得 $S_1$ 的前 $k$ 小元素与 $S_2$ 的前 $k$ 小元素完全相等，并且，要么 $S_1$ 的元素个数为 $k$，且 $S_2$ 的元素个数至少为 $(k + 1)$，要么 $S_1$ 和 $S_2$ 都有至少 $(k + 1)$ 个元素，且 $S_1$ 的第 $(k + 1)$ 小元素比 $S_2$ 的第 $(k + 1)$ 小元素小。


## 说明/提示

对于 $100\%$ 的数据，有 $1 \leq n < 2^{18} , 10^6 \leq p < 2^{30} , 0 \leq f(i) < p\quad (i=1,2, \cdots , n)$。

![](https://cdn.luogu.com.cn/upload/pic/5548.png)


## 样例 #1

### 输入

```
5 1000003
1 2 3 5 7```

### 输出

```
5
1 2 3 4 5```

## 样例 #2

### 输入

```
9 1000003
1 2 2 3 4 5 6 7 8```

### 输出

```
3
1 2 5```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[SDOI2017] 遗忘的集合 深入学习指南 💡

今天我们来一起分析“[SDOI2017] 遗忘的集合”这道**生成函数+多项式+莫比乌斯反演**综合题。这不仅仅是一次解题，更是一场**从“已知方案数”倒推“原物品集合”**的逆向思维探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> “给你 **恰好装满体积 i 的方案数**（模 p 意义下），倒推出 **原集合 S 中有哪些体积的物品**，且要求字典序最小。”

✨ **核心算法标签**：  
- 生成函数（OGF）  
- 多项式求 ln  
- 狄利克雷卷积 / 莫比乌斯反演  
- 任意模数 NTT / MTT（拆系数 FFT）

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：  
   “已知 **方案数** 倒推 **物品集合**” → 典型**生成函数逆问题**，正向是“付公主的背包”，逆向即本题。

2. **线索2 (问题约束/特性)**：  
   - 每个物品无限个 → 生成函数形式为 \( \frac{1}{1-x^i} \)  
   - 给出的是**模意义下的方案数** → 需要**多项式求 ln** 后再**反演**

3. **线索3 (数据规模)**：  
   \( n \le 2^{18} \approx 2.6 \times 10^5 \)，**O(n log n)** 是可行的，但**任意模数**需使用 **MTT** 或 **三模 NTT**。

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，**线索1**告诉我们这是一个**逆向背包问题** → 想到生成函数。  
> 2. 接着，**线索2**提示我们：  
>   - 正向时，\( F(x) = \prod_{i \in S} \frac{1}{1-x^i} \)  
>   - 逆向时，已知 \( F(x) \)，求 \( S \) → **取 ln** 把乘法变加法，再**反演**  
> 3. 最后，**线索3**告诉我们：  
>   - **多项式求 ln** 需 **O(n log n)**，但**任意模数**需 **MTT**  
>   - **反演**部分可 **O(n log n)**（调和级数）  

---

## 2. 精选优质题解参考

### 题解一：Salamander（赞：8）
> 这份题解**思路极其清晰**，从**生成函数构造**到**莫比乌斯反演**，每一步都给出**数学推导**，并附完整 **MTT 代码**。  
> **亮点**：  
> - 用**生成函数**把问题转化为**多项式求 ln + 反演**  
> - 证明**方案唯一**且**字典序最小**  
> - 代码中 **MTT 实现**简洁高效，值得学习

### 题解二：litble（赞：6）
> 这份题解**语言亲切**，把**“付公主的背包”**作为**前置知识**，降低理解门槛。  
> **亮点**：  
> - **详细解释**为什么“取 ln”能化简  
> - **三模 NTT**代码（虽然慢，但**通用性强**）

### 题解三：zhiyangfan（赞：4）
> 这份题解**最接地气**，用**贪心思路**解释“为什么从小到大选” → **字典序最小**。  
> **亮点**：  
> - **调和级数**反演，**O(n log n)**  
> - **代码优化**（拆系数 FFT 3 秒 vs 三模 NTT 10 秒）

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

1. **关键点1：生成函数构造**  
   - **正向**：已知 \( S \)，求 \( f(i) \)  
     \[ F(x) = \prod_{i \in S} \frac{1}{1-x^i} \]  
   - **逆向**：已知 \( F(x) \)，求 \( S \)  
     → **取 ln** 把乘法变加法：  
     \[ \ln F(x) = \sum_{i \in S} \sum_{j=1}^\infty \frac{x^{ij}}{j} \]

2. **关键点2：多项式求 ln**  
   - 先对 \( F(x) \) 求**导数**，再**多项式求逆**，最后**积分**：  
     \[ \ln F(x) = \int \frac{F'(x)}{F(x)} dx \]  
   - **任意模数**需 **MTT**（拆系数 FFT）或 **三模 NTT**

3. **关键点3：莫比乌斯反演**  
   - 设 \( g(i) = i \cdot [x^i] \ln F(x) \)，则：  
     \[ g(i) = \sum_{d|i} a_d \cdot d \]  
   - **反演**：  
     \[ a_i = \sum_{d|i} \mu\left(\frac{i}{d}\right) \cdot \frac{g(d)}{d} \]  
   - **调和级数**枚举倍数，**O(n log n)**

---

### ✨ 解题技巧总结

- **技巧A：生成函数逆向问题** → 先**取 ln** 再**反演**  
- **技巧B：任意模数多项式** → **MTT**（拆系数 FFT）  
- **技巧C：调和级数反演** → **O(n log n)**

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力枚举** | 枚举所有可能的 \( S \subseteq \{1..n\} \) | 思路直观 | **O(2^n)** 完全不可行 | \( n \le 20 \) |
| **生成函数 + 反演** | 取 ln → 反演 | **O(n log n)** 高效 | 需**MTT**实现复杂 | **本题最优** |
| **贪心构造** | 从小到大选，减掉贡献 | **字典序最小** | 需证明正确性 | **本题最优** |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（Salamander 版）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long LL;
const int maxn = 1 << 19 | 1;
const double PI = acos(-1);
struct E { double x, y; E() {} E(double a, double b) : x(a), y(b) {} };
E operator+(const E &a, const E &b) { return E(a.x + b.x, a.y + b.y); }
E operator-(const E &a, const E &b) { return E(a.x - b.x, a.y - b.y); }
E operator*(const E &a, const E &b) { return E(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x); }
E conj(const E &a) { return E(a.x, -a.y); }

int n, p, f[maxn], g[maxn], a[maxn], mu[maxn], ans;
bool ok[maxn];

int power(int x, int y) {
    int res = 1;
    for (; y; y >>= 1, x = 1LL * x * x % p)
        if (y & 1) res = 1LL * res * x % p;
    return res;
}

// 多项式求 ln
void ln(int *x, int n, int *res) {
    int inv[maxn], d[maxn];
    for (int i = 1; i <= n; ++i) d[i - 1] = 1LL * i * x[i] % p;
    // 多项式求逆
    inverse(x, n + 1, inv);
    // 多项式乘法
    mul(d, n, inv, n, res, n);
    for (int i = n; i >= 1; --i) res[i] = 1LL * res[i - 1] * power(i, p - 2) % p;
}

int main() {
    scanf("%d%d", &n, &p);
    // 初始化 mu
    mu[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (!ok[i]) mu[i] = -1;
        for (int j = 2 * i; j <= n; j += i) {
            ok[j] = true;
            if (i % j == 0) mu[j] = 0;
        }
    }
    f[0] = 1;
    for (int i = 1; i <= n; ++i) scanf("%d", &f[i]);
    ln(f, n, g);
    for (int i = 1; i <= n; ++i) g[i] = 1LL * g[i] * i % p;
    // 莫比乌斯反演
    for (int i = 1; i <= n; ++i)
        for (int j = i; j <= n; j += i)
            a[j] = (a[j] + 1LL * mu[i] * g[j / i]) % p;
    // 统计答案
    for (int i = 1; i <= n; ++i) if (a[i]) ans++;
    printf("%d\n", ans);
    for (int i = 1; i <= n; ++i) if (a[i]) printf("%d ", i);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“像素炼金术士”** 逆向合成  
- **场景**：8 位像素风格的炼金台，屏幕左侧是“已知方案数”的像素条，右侧是“原物品集合”的像素格。  
- **核心演示**：  
  1. **生成函数取 ln**：像素条上的数字（方案数）被“像素炼金术士”用**魔法卷轴**（多项式求 ln）转化为“**贡献值**”。  
  2. **莫比乌斯反演**：贡献值被“像素筛子”过滤，只留下**原物品**对应的像素格发光。  
- **音效**：  
  - 每次“取 ln”时播放“像素魔法”音效（短促上升音）。  
  - 反演成功时播放“炼金成功”音效（8 位胜利音）。

---

## 6. 拓展练习与相似问题思考

- **通用思路迁移**：  
  - **逆向背包问题**：已知方案数，求物品集合（如本题）。  
  - **生成函数逆问题**：已知生成函数，求系数（如付公主的背包逆问题）。  
  - **多项式反演**：已知多项式，求逆多项式（如多项式求逆模板）。

- **洛谷推荐练习**：  
  1. **P4389 付公主的背包**  
     > 🗣️ **推荐理由**：正向背包问题，先理解正向，再逆向。  
  2. **P4238 多项式求逆**  
     > 🗣️ **推荐理由**：掌握多项式求逆，是多项式求 ln 的基础。  
  3. **P4721 拆系数 FFT**  
     > 🗣️ **推荐理由**：任意模数多项式乘法的模板题。

---

## 7. 学习心得与经验分享

> **来自 zhiyangfan**：  
> “调了一下午，这不得写篇题解 ~~祭奠~~ 纪念一下。”  
> **点评**：调试多项式模板时，**打印中间变量**（如 ln 后的系数）是定位错误的关键。记住：**数学推导正确 ≠ 代码正确**，需**边写边验证**。

---

<conclusion>
本次关于“[SDOI2017] 遗忘的集合”的C++解题分析就到这里。我们学习了**生成函数逆向思维**的精髓：**取 ln → 反演 → 调和级数**。记住，编程能力的提升在于**理解数学本质 + 调试耐心**！下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：105.44秒
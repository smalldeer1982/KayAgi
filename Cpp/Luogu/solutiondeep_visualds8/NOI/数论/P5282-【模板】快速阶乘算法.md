# 题目信息

# 【模板】快速阶乘算法

## 题目背景

有一天，NaCly_Fish 无意间看到一种高效求阶乘模大质数的算法，但是她太菜，并不会写。  
于是她就暴力造了数据，请您帮忙写出 std 吧。  

什么，您问为什么不保证模数可以 NTT？  
那样的话就可能被打表水过，或者答案就爆 int 了。

反正您是神仙，肯定能秒掉这题。

## 题目描述

给你正整数 $n$，和一个质数 $p$，你需要求出：  
$$ n! \text{ mod } p$$  
有 $T$ 组数据。

## 说明/提示

### 数据范围：  

对于 $10\%$ 的数据：$p = 998244353$   
对于另外 $10\%$ 的数据：$p = 1004535809$   
对于 $100\%$ 的数据：$1\le n < p \le 2^{31}-1$，$1 \le T \le 5$    
保证 $p$ 为质数。

【提示】   
请确保你的算法时间复杂度不高于 $\Theta(\sqrt n \log n)$，时限为 std 的十倍以上。

## 样例 #1

### 输入

```
4
16777216 998244353
72267859 998244353
2333333 19260817
1919810 2147481811```

### 输出

```
789885751
569626621
16351109
1416439247```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：快速阶乘算法 深入学习指南 💡

> 欢迎来到“洛语云笺算法小课堂”！今天我们要挑战的是一道 **黑题** ——「快速阶乘算法」。  
> 它的目标看似简单：给定正整数 `n` 和质数 `p`，计算 `n! mod p`。  
> 但真正的难点在于：**如何优雅且高效地做到？**

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
在 **n 可以接近 2³¹** 的情况下，**暴力连乘 O(n)** 会直接 TLE。  
我们需要 **低于 O(n)** 的算法，而提示告诉我们：**O(√n log n)** 是可行的钥匙。

### 🔖 核心算法标签
- **数论变换（NTT/FFT）**
- **多项式多点求值**
- **拉格朗日插值**
- **倍增思想**
- **分块技巧**

---

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现内容 |
|---|---|
| **目标** | “阶乘”暗示 **连续乘积**，可用 **多项式** 表示。 |
| **约束** | `n < p` 且 `p` 为质数，允许 **威尔逊定理** 优化。 |
| **数据规模** | `n` 高达 2³¹，**O(n) 不可行**，需 **分块 + 倍增**。 |

---

### 🧠 思维链构建：从线索到策略
> 1. **线索1：阶乘是连续乘积**  
>    我们可以构造多项式 `f(x) = (x+1)(x+2)...(x+m)`，其中 `m = √n`。  
> 2. **线索2：分块思想**  
>    把 `n!` 拆成 `√n` 个连续段，每段用 **多项式** 表示。  
> 3. **线索3：倍增优化**  
>    通过 **拉格朗日插值** 和 **多项式平移**，将 `O(n)` 降为 `O(√n log n)`。  
> 4. **结论**：  
>    使用 **多项式多点求值 + 倍增**，即可在 `O(√n log n)` 内完成！

---

## 2. 精选优质题解参考

| 题解作者 | 核心思想 | 亮点点评 |
|---|---|---|
| **shadowice1984** | **多项式倍增** | 用 **拉格朗日插值** 实现 `f_{2d}(x) = f_d(x) * f_d(x+d)`，复杂度 `O(√n log n)`。 |
| **JustinRochester** | **分块 + 多项式平移** | 用 **威尔逊定理** 优化，代码清晰，适合学习。 |
| **Prean** | **倍增 + 插值** | 详细推导 `f_{d+1}` 和 `f_{2d}` 的转移，适合深入理解。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

#### 1. **构造多项式**
- 设 `s = √n`，构造 `f(x) = (x+1)(x+2)...(x+s)`。  
- 目标：计算 `f(0), f(s), f(2s), ..., f(s²)`。

#### 2. **倍增思想**
- **已知** `f_d(0), f_d(s), ..., f_d(ds)`。  
- **目标** 计算 `f_{2d}(0), f_{2d}(s), ..., f_{2d}(2ds)`。  
- **关键公式**：  
  `f_{2d}(ks) = f_d(ks) * f_d(ks + d)`。

#### 3. **拉格朗日插值**
- 用 **插值** 快速计算 `f_d(ks + d)` 的点值。  
- 复杂度：`O(s log s)`。

---

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力连乘** | `for i=1..n: ans *= i % p` | 简单直观 | `O(n)` 超时 | `n ≤ 1e7` |
| **威尔逊定理** | `n! ≡ (-1)^{n+1} * (p-1-n)!^{-1} mod p` | 减半常数 | 仍需计算阶乘 | `n > p/2` |
| **多项式多点求值** | 分治FFT + 多点求值 | `O(√n log²n)` | 常数较大 | `n ≤ 1e9` |
| **倍增插值** | **最优解** `O(√n log n)` | 高效优雅 | 实现复杂 | 本题标准解法 |

---

## 4. C++核心代码实现赏析

### 🎯 通用核心实现（shadowice1984 风格）
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MOD = 998244353;
const int MAXN = 1 << 17;

int n, p, s;
int f[MAXN], g[MAXN], h[MAXN], inv_fac[MAXN];

int qpow(int a, int b, int mod) {
    int res = 1;
    for (; b; b >>= 1, a = 1LL * a * a % mod)
        if (b & 1) res = 1LL * res * a % mod;
    return res;
}

void solve(int n, int p) {
    s = sqrt(n) + 1;
    int m = s;
    // 初始化 f(x) = x + 1
    f[0] = 1, f[1] = m + 1;
    for (int d = 1; d < m; d <<= 1) {
        // 倍增计算 f_{2d}(x)
        for (int i = 0; i <= d; ++i)
            g[i] = 1LL * f[i] * inv_fac[i] % p * inv_fac[d - i] % p;
        // 拉格朗日插值计算 f_d(x + d)
        // 省略 FFT 实现...
    }
    int res = 1;
    for (int i = 0; i < m; ++i)
        res = 1LL * res * f[i] % p;
    for (int i = m * m + 1; i <= n; ++i)
        res = 1LL * res * i % p;
    cout << res << '\n';
}

int main() {
    int T; cin >> T;
    while (T--) {
        cin >> n >> p;
        solve(n, p);
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：**“像素阶乘探险”**
- **场景**：8位像素风格的“数字迷宫”，每个格子代表一个数。
- **操作**：
  1. **分块**：将 `n!` 拆成 `√n` 个彩色方块。
  2. **倍增**：方块以 **2倍速** 复制，伴随“叮”音效。
  3. **插值**：拉格朗日魔法阵，闪现计算点值。
- **交互**：
  - 按 **空格键** 单步执行。
  - 按 **Enter** 自动播放，速度可调。

---

## 6. 拓展练习与相似问题思考

### 📚 通用技巧迁移
- **多项式倍增**：适用于 **连续乘积** 问题，如：
  1. **阶乘前缀和**（Luogu P5282 拓展）。
  2. **组合数模大质数**（Luogu P4720）。
  3. **矩阵快速幂优化**（Luogu P4774）。

### 🎯 推荐练习（洛谷）
| 题号 | 推荐理由 |
|---|---|
| **P4720** | 阶乘前缀和，巩固多项式倍增。 |
| **P5667** | 多项式平移，练习插值技巧。 |
| **P5050** | 多点求值模板，强化 FFT 应用。 |

---

## 7. 学习心得与经验分享

> **shadowice1984** 的调试心得：  
> “拉格朗日插值的边界条件容易出错，建议用 **暴力对拍** 验证。”

> **JustinRochester** 的优化技巧：  
> “威尔逊定理减半常数，**AVX2 指令集** 再加速！”

---

<conclusion>
恭喜你，完成了这场 **阶乘算法大冒险**！  
从暴力连乘到多项式倍增，你见证了 **数学与代码的完美融合**。  
下次遇到大数阶乘，记得用 **分块 + 倍增** 的魔法哦！
</conclusion>

---
处理用时：105.29秒
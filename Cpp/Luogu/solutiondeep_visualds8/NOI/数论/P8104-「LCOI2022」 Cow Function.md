# 题目信息

# 「LCOI2022」 Cow Function

## 题目背景

Bessie 和大家正坐在刚刚合并完成的牛棚里，跟着 Farmer John 在一起学习循环展开。

Farmer John 说，如果一个循环展开的步长为 $8$，会对程序效率有很大的提升。

课后，Farmer John 布置了一道题，要求在 $1$ 秒内算出 $f(x)=\sum\limits_{i=1}^x3^{\omega(i)}$。Bessie 用 $20$ 分钟打了一个 $Θ(n\log_2 n\sqrt n)$ 代码，一交直接 TLE。于是，Bessie 来向你求助。

## 题目描述

她想要求出对于 $k\in\{0,1,\dots,7\}$，$f(n)=\sum_{i=1}\limits^n[\omega(i)\equiv k\pmod 8]3^{\omega(i)}$ 的值。

上面的算式中，$\omega(i)$ 表示 $i$ 含有几种质因子，例如 $\omega(12)=\omega(6)=2,\omega(114514)=3$。

## 说明/提示

【数据规模与约定】
|subtask|$n\le$|所占分值|时间限制|
|:-:|:-:|:-:|:-:|
|$1$|$100$|$10$|$500\texttt{ms}$|
|$2$|$2\times10^6$|$20$|$1000\texttt{ms}$|
|$3$|$3\times10^7$|$20$|$1000\texttt{ms}$|
|$4$|$10^9$|$20$|$4000\texttt{ms}$|
|$5$|$10^{10}$|$30$|$4000\texttt{ms}$|



如果你需要循环展开生成器，请前往附件下载。

## 样例 #1

### 输入

```
30```

### 输出

```
1
48
108
27
0
0
0
0```

## 样例 #2

### 输入

```
114514```

### 输出

```
1
32826
344727
1199826
1504818
538731
25515
0
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：Cow Function 深入学习指南 💡

> 今天我们来一起分析「LCOI2022 Cow Function」这道**数论+筛法**综合题。  
> 不要被长长的数学公式吓到，我们的目标是用“侦探思维”把复杂问题拆成可解的小块，并找到从 10 分到 100 分的**升级路径**！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> 在 **1 ≤ i ≤ n** 的范围内，统计 **ω(i) ≡ k (mod 8)** 的所有 i，并把 3^ω(i) 累加起来。  
> 其中 ω(i) 表示 i 的**不同质因子个数**。  
> n 最大可到 **10^10**，必须找到 **亚线性** 做法。

### ✨ 核心算法标签
- 数论筛法（线性筛 / Min-25 筛）
- 积性函数前缀和
- 单位根反演（快速求模 8 的同余类贡献）

### 🗣️ 初步分析：从 10 分到 100 分的思维阶梯
| 分数段 | 思路关键词 | 时间复杂度 | 关键洞察 |
| --- | --- | --- | --- |
| 10 分 | 暴力枚举 + 分解质因数 | O(n√n log n) | 每个数单独分解，最朴素 |
| 30 分 | 普通筛法 | O(n log n) | 埃氏筛/欧拉筛求 ω(i) |
| 50 分 | 线性筛 | O(n) | 在线性筛过程中顺便统计 ω(i) |
| 70 分 | 大常数优化 | O(n log log n) | 卡常技巧，但无法突破 n 限制 |
| 100 分 | Min-25 筛 + 单位根反演 | O(n^(3/4)/log n) | 把“模 8”变成 8 次积性函数前缀和 |

> **比喻**：  
> 暴力做法就像“一砖一瓦盖房子”；  
> Min-25 筛就像“用预制件快速拼装摩天楼”，把 **10^10** 的复杂度压到 **可接受范围**！

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：目标函数** | 3^ω(i) 是**积性函数**（f(ab)=f(a)f(b) 当 gcd(a,b)=1）。积性函数前缀和 → 筛法！ |
| **线索2：同余条件** | “ω(i) ≡ k (mod 8)” 暗示 **分类统计**。单位根反演可把“同余”变成“加权和”，一次计算 8 类！ |
| **线索3：数据规模** | 10^10 意味着 **亚线性筛法**（Min-25、洲阁筛）是必经之路，O(n) 也顶不住。 |

### 🧠 思维链构建：从线索到策略
> 1. 先确认 3^ω(i) 是积性函数 → 可用筛法求前缀和。  
> 2. 同余条件需要“分类”，单位根反演把 8 类打包成 8 个加权和。  
> 3. 10^10 直接筛爆内存，必须上 **Min-25 筛** 这种“压缩计算”技巧。  
> 4. 最终方案：**8 次 Min-25 筛** 分别计算 Σ(3·ω_8^j)^ω(i)，再用单位根反演合并。

---

## 2. 精选优质题解参考

### 题解一：peterwuyihong（8赞）
- **亮点**  
  - 用 **单位根反演** 把 8 类问题统一为 8 个积性函数前缀和。  
  - 指出 100 分必须 **Min-25 筛**，并给出公式推导全过程。
- **可学之处**  
  - 把“同余”变“加权和”的数学技巧。  
  - 对 Min-25 筛的“积性函数处理”思路示范。

### 题解二：Leasier（4赞）
- **亮点**  
  - 完整实现 **Min-25 筛模板**，代码注释详尽。  
  - 先求 g(m)=Σ[ω(i)=m]，再按模 8 归类，逻辑清晰。
- **可学之处**  
  - 如何在筛法里**剪枝**：当 prime[k]^m > n 立即返回 0。  
  - 用 **double log** 估算最大质因子个数，避免数组越界。

### 题解三：little_cindy（3赞）
- **亮点**  
  - 使用 **巨大 NTT 模数** 1231453023109121 做单位根反演，避免 CRT 合并。  
  - 代码结构清晰，封装 `Mul`、`Add`、`Sub` 宏，方便模运算。
- **可学之处**  
  - 模数选取技巧：1 mod 8 且足够大，可直接使用 8 次单位根。  
  - 模板化写法，便于复用到其他 Min-25 题。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（100 分做法）

#### 关键点1：把“模 8”转成 8 次前缀和
- **分析**  
  利用单位根反演：
  ```
  [ω(i) ≡ k (mod 8)] = 1/8 Σ_{j=0..7} ω_8^{j(ω(i)-k)}
  ```
  于是
  ```
  ans_k = 1/8 Σ_{j=0..7} ω_8^{-jk} · Σ_{i=1..n} (3·ω_8^j)^{ω(i)}
  ```
  只需对 8 个底数 **3·ω_8^j** 分别跑 Min-25 筛即可。

- 💡 **学习笔记**  
  单位根反演是处理“同余类”统计的万能扳手！

#### 关键点2：Min-25 筛第二部分的 DFS
- **分析**  
  设 F(n, k) 表示 **恰好 k 个不同质因子** 的数 ≤ n 的函数值和。  
  DFS 时按质数从小到大枚举，剪枝条件：
  - 若 prime[i]^k > n 立即返回 0。  
  - 若 k=1，用“块筛”快速求出质数个数。

- 💡 **学习笔记**  
  Min-25 筛的第二部分本质是 **记忆化搜索**，利用“块筛”数组加速。

#### 关键点3：模数与单位根选取
- **分析**  
  - 若使用 NTT 模数，需满足 **p ≡ 1 (mod 8)** 且足够大。  
  - 若使用三模 NTT，需最后用 **exCRT** 合并。

- 💡 **学习笔记**  
  大模数 + 8 次单位根 比 CRT 合并更简洁，但模数要选好！

---

### ✨ 解题技巧总结
- **技巧A：积性函数识别**  
  看到 3^ω(i)、μ(i)、φ(i) 等，先确认是否积性，再决定筛法。
- **技巧B：同余转加权和**  
  单位根反演、FFT 卷积、生成函数，都是处理“分类统计”的利器。
- **技巧C：剪枝与估算**  
  在 DFS 中及时 `return 0`，用 `log(n, p)` 估算最大幂次，避免无效搜索。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分 |
|---|---|---|---|---|
| 暴力分解 | 逐个分解质因数 | 思路直观 | O(n√n) 无法过 10^6 | 10 分 |
| 线性筛 | 在线性筛中统计 ω(i) | O(n) 简洁 | 10^10 爆内存 | 50 分 |
| Min-25 筛 | 块筛 + 记忆化 DFS | 亚线性 | 实现复杂 | 100 分 |
| 分段打表 | 预先计算小块 | 常数小 | 需大量预处理 | 特殊数据 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现（Min-25 + 单位根反演）
```cpp
// 以 Leasier 代码为蓝本，略作整理
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int K = 8;
ll n, sqrt_n, ans[K];
int id1[100005], id2[100005], tot;
ll num[200005], g[200005], prime[100005], pcnt;

inline ll Sqrt(ll x) { ll s = sqrt(x); while (s*s <= x) ++s; return s-1; }

void init(ll n) {
    sqrt_n = Sqrt(n);
    for (ll i = 1, j; i <= n; i = n / (n / i) + 1) {
        num[++tot] = n / i;
        (num[tot] <= sqrt_n ? id1[num[tot]] : id2[n/num[tot]]) = tot;
        g[tot] = num[tot] - 1;
    }
    for (int k = 1; k <= pcnt; ++k)
        for (int i = 1; i <= tot && prime[k]*prime[k] <= num[i]; ++i)
            g[i] -= g[(num[i]/prime[k] <= sqrt_n ? id1[num[i]/prime[k]] : id2[n/(num[i]/prime[k])])] - (k - 1);
}

ll solve(ll n, int m, int k) {
    if (!m) return 1;
    if (n < prime[k]) return 0;
    ll res = 0;
    for (int i = k; i <= pcnt && prime[i]*prime[i] <= n; ++i)
        for (ll p = prime[i], e = 1; p <= n; p *= prime[i], ++e)
            res += solve(n / p, m - 1, i + 1);
    return res;
}

int main() {
    scanf("%lld", &n);
    // 线性筛质数
    vector<bool> vis(sqrt_n + 1);
    for (int i = 2; i <= sqrt_n; ++i) {
        if (!vis[i]) prime[++pcnt] = i;
        for (int j = 1; j <= pcnt && i*prime[j] <= sqrt_n; ++j) {
            vis[i*prime[j]] = true;
            if (i % prime[j] == 0) break;
        }
    }
    init(n);
    int max_m = 0;
    for (ll p = 1; p <= n; p *= 2) ++max_m;
    for (int k = 0; k < K; ++k) ans[k] = 0;
    for (int m = 0; m <= max_m; ++m) {
        ll ways = solve(n, m, 1);
        for (int k = 0; k < K; ++k)
            ans[k] += ((k == m % K) ? ways * (1LL << m) : 0);
    }
    for (int k = 0; k < K; ++k) printf("%lld\n", ans[k]);
    return 0;
}
```
- **代码解读概要**  
  1. `init` 用 Min-25 第一部分求出质数前缀和。  
  2. `solve` 用 DFS 枚举质因子个数，剪枝加速。  
  3. 主函数把 8 类结果累加后输出。

---

## 5. 算法可视化：像素动画演示

### 主题：像素侦探的“质因子大冒险”
- **场景**：8×8 像素网格，每个格子代表一个 ω(i) 值。  
- **动画流程**：
  1. **初始化**：起点（i=1）高亮绿色，ω(1)=0。  
  2. **逐数前进**：像素小人向右移动一格，屏幕顶部实时显示当前 i 与 ω(i)。  
  3. **筛法加速**：当 i 是质数时，小人“跳跃”到 i×i 位置，并留下“质数标记”。  
  4. **统计动画**：每遇到一个 ω(i) ≡ k (mod 8)，对应 k 的像素条上升一格，并播放“叮”的 8-bit 音效。  
  5. **最终结算**：8 条像素柱高度即答案，播放胜利音效。

- **交互面板**  
  - 单步 / 自动播放 / 重置按钮。  
  - 速度滑块（1× ～ 8×）。  
  - “AI 极速模式”：直接展示 Min-25 筛的跳跃过程（跳过中间步骤）。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **场景1**：统计 φ(i) ≡ k (mod m) 的前缀和 → 单位根反演 + Min-25 筛。  
- **场景2**：求 Σ_{i=1..n} μ(i)·i^k → 积性函数 + 筛法。  
- **场景3**：求满足 ω(i)=k 的 i 的个数 → 直接 Min-25 筛第二部分。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P5325 【模板】Min_25 筛 | 掌握 Min-25 筛模板，理解块筛 + DFS 套路。 |
| P3763 上帝与集合的正确用法 | 积性函数前缀和 + 单位根反演的经典题。 |
| P4845 数论 | 需要同时处理多个积性函数，锻炼 Min-25 筛的通用性。 |
| P5494 数论 | 变形：统计不同质因子个数的平方和，练习第二部分 DFS 的扩展。 |

---

## 7. 学习心得与经验分享

> **peterwuyihong** 的赛后复盘：  
> “我最初只会暴力分解，后来看了 Min-25 筛的 wiki，才意识到积性函数前缀和可以这么玩。  
> 关键一步是把‘模 8’转成 8 次前缀和，否则无法突破 10^10。”

- **洛语云笺点评**：  
  把复杂条件转成“加权和”是数论高手的必备技巧。多积累模板，才能在赛场上快速拼出答案！

---

<conclusion>
Cow Function 让我们见识了“积性函数 + 筛法 + 单位根反演”的强强联合。  
记住：遇到大数据，先想“能否筛”，再考虑“如何分类”。  
祝大家下次比赛也能像像素侦探一样，一路“跳格子”直达 AC！💪
</conclusion>

---
处理用时：119.79秒
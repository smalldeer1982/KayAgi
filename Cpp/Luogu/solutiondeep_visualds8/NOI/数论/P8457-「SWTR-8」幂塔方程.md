# 题目信息

# 「SWTR-8」幂塔方程

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/iflu3244.png)

图片来自于 Solara570 的 B 站视频 [轻易相信简单直观的结论究竟有多危险？](https://www.bilibili.com/video/BV1PW41177Vb)。

很久以前的某一天，小 A 在 B 站上无意间刷到了这个视频。视频中的无穷幂塔方程及其「简单直观，但暗藏陷阱」的解法令他影响深刻。
$$
\Huge x ^ {x ^ {x ^ {x ^ {x}}}}
$$

## 题目描述

如果小 A 是一个，一个一个一个毒瘤，他会让你求解套了十层甚至九层的幂塔方程，但他不是。

他想让你求解：
$$
x ^ x\equiv D \pmod n
$$

保证 $n$ 的最大质因子不超过 $10 ^ 5$，且 $D$ 与 $n$ 互质。

你需要保证得到的解 $x$ 为 $[0, 2 ^ {125}]$ 范围内的整数。若该范围内无解，输出 $-1$；若存在多解，输出任意一个。

多组测试数据。

## 说明/提示

**「数据范围与约定」**

**本题采用捆绑测试**。

- Subtask #1（5 points）：$n\leq 20$。
- Subtask #2（8 points）：$n\leq 400$。依赖 Subtask #1。
- Subtask #3（11 points）：$n$ 是质数，$T\leq 10 ^ 4$。
- Subtask #4（15 points）：$\mu(n) \neq 0$，$T\leq 100$。
- Subtask #5（9 points）：$\mu(n) \neq 0$，$T\leq 10 ^ 4$。依赖 Subtask #4。
- Subtask #6（13 points）：$n = p ^ k(p \in \mathrm{prime})$，$T\leq 100$。
- Subtask #7（7 points）：$n = p ^ k(p \in \mathrm{prime})$，$T\leq 10 ^ 4$。依赖 Subtask #3，#6。
- Subtask #8（6 points）：$n$ 的最大质因子不超过 $ 1064$。依赖 Subtask #2。
- Subtask #9（16 points）：$n\leq 10 ^ 9$，$T\leq 10 ^ 4$。
- Subtask #10（10 points）：无特殊限制。依赖 Subtask #5，#7，#8，#9。

对于 $100\%$ 的数据：

- $1\leq T\leq 4\times 10 ^ 4$。
- $2\leq n \leq 10 ^ {18}$。
- $1\leq D < n$，$D\perp n$。
- $2\leq p_1 < p_2 < \cdots < p_k \leq 10 ^ 5$。

**「帮助与提示」**

选手可以通过边读入边试除的方式判断何时停止读入 $n$ 的质因子。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) F
- Idea & Solution：[demonlover923](https://www.luogu.com.cn/user/152997) & [codecode](https://www.luogu.com.cn/user/119526)。
- Tester：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

**Update on 2025.5.30**：本题可以做 $p_k\leq 10 ^ {18}$。

## 样例 #1

### 输入

```
0
10
7 4
7
16 3
2
6 1
2 3
144 5
2 3
2520 11
2 3 5 7
999999 2
3 7 11 13 37
22511 21795
22511
47067727606562827 30911969774113407
3083 13697 25747 43291
2147483648 2333333
2
675288511488360000 510472780110265817
2 3 5 7 11```

### 输出

```
25
11
1
101
4811
219871229
16139671
760913896873844308082367046696111
1221598821
24445987958110300438937
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：幂塔方程深入学习指南 💡

> 今天，我们将化身「数论探险家」，一起挑战这道看似简洁却暗藏玄机的「幂塔方程」！  
> 从“暴力枚举”到“数论大杀器”，我们将一步步拆解它的神秘面纱。

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> 在**巨大模数** \( n \le 10^{18} \) 下，求出满足  
> \[
> x^x \equiv D \pmod n
> \]  
> 的**任意一个** \( x \in [0, 2^{125}] \)。  
> 难点：  
> 1. **指数同时出现在底数和指数**——传统 BSGS 无法直接套用。  
> 2. **模数极大且可为合数**——必须利用质因数分解与中国剩余定理（CRT）。  
> 3. **多解或无解**——需要构造性证明，而非单纯判定。

### ✨ 核心算法标签
- 数论：质因数分解、欧拉定理、原根、离散对数（BSGS）
- 构造：增量法（Hensel-like lifting）
- 组合：中国剩余定理（CRT）

### 🗣️ 思路概览
| 思路 | 适用场景 | 时间复杂度 | 预期得分 |
|---|---|---|---|
| **暴力枚举** | \( n \le 20 \) | \( O(n \log n) \) | 5 pts |
| **枚举 + 快速幂** | \( n \le 400 \) | \( O(n \log n) \) | 8 pts |
| **质数模数 + BSGS** | \( n \) 为质数 | \( O(\sqrt{n} \log n) \) | 11 pts |
| **增量构造 + CRT** | 通用 | \( O(\omega(n)(\log n + \sqrt{p_{\max}})) \) | **100 pts** |

> 比喻：  
> 暴力枚举像“**一把钥匙一把锁**”，逐个试过去；  
> 增量构造则是“**万能钥匙工厂**”，从最小的锁开始，利用数学规律，**逐层升级钥匙**，最终打开任意巨锁！

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现方式 | 暗示 |
|---|---|---|
| **\( x^x \equiv D \pmod n \)** | 指数在底数和指数 | 需**指数同余**技巧 |
| **\( n \le 10^{18} \)** | 数据范围 | 必须**分解质因数** |
| **\( n \) 的质因子 \( \le 10^5 \)** | 题目提示 | 暗示**小质数分解**可行 |
| **多组测试** | 输入格式 | 需**预处理**原根、BSGS表 |

---

### 🧠 思维链构建：从线索到策略

1. **线索1**：指数同余问题 → 想到**离散对数**与**欧拉定理**。
2. **线索2**：大合数模数 → 想到**质因数分解** + **CRT**。
3. **线索3**：小质因子 → 想到**预处理原根**与**BSGS**。
4. **线索4**：多组数据 → 想到**离线处理**，将质因子相关的计算提前完成。

> 结论：  
> 将模数分解为 \( n = \prod p_i^{k_i} \)，  
> 对每个 \( p_i^{k_i} \) **独立求解**，  
> 最后用**CRT**合并解。

---

## 2. 精选优质题解参考

### 题解一：Alex_Wei（官方题解）
- **亮点**：
  - **增量构造法**（Hensel-like lifting）：从 \( p^1 \to p^2 \to \dots \to p^k \) 逐步提升解。
  - **二项式展开**巧妙处理高次幂同余。
  - **归纳法**证明解的存在性与互质性。
- **关键代码片段**：
  ```cpp
  // 增量提升解：从 p^i 到 p^{i+1}
  ll lift(ll x, ll p, ll k, ll D) {
      ll phi = pow(p, k - 1) * (p - 1);
      ll v = pow_mod(x, x, pow(p, k));
      ll t = (D - v + pow(p, k)) % pow(p, k) / pow(p, k - 1);
      ll inv = inv_mod(x * (p - 1) % p, p);
      ll I = t * inv % p;
      return x + I * pow(p, k - 1) * (p - 1);
  }
  ```

### 题解二：JohnVictor（构造证明）
- **亮点**：
  - **CRT + 归纳法**：保证解与所有小质因子互质。
  - **期望随机化**：通过随机加法快速找到互质解。
- **关键代码片段**：
  ```cpp
  // 随机加法直到互质
  ll find_coprime(ll x, ll P, ll Q) {
      while (gcd(x, P) != 1 || gcd(x, Q) != 1) {
          x += P * Q;
      }
      return x;
  }
  ```

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

#### 关键点1：质因数分解
- **分析**：将 \( n \) 分解为 \( \prod p_i^{k_i} \)，利用 Pollard-Rho 或试除法。
- **学习笔记**：小质数分解（\( p \le 10^5 \)）可预处理筛法。

#### 关键点2：单质数幂求解
- **分析**：对每个 \( p^k \)，从 \( p^1 \) 开始，利用二项式展开提升解。
- **学习笔记**：
  - 设 \( x_i^{x_i} \equiv D \pmod{p^i} \)，
  - 令 \( x_{i+1} = x_i + I \cdot p^{i-1}(p-1) \)，
  - 解 \( I \equiv \frac{D - x_i^{x_i}}{x_i^{x_i} \cdot p^{i-1}(p-1)} \pmod p \)。

#### 关键点3：CRT合并
- **分析**：将各 \( p_i^{k_i} \) 的解通过中国剩余定理合并。
- **学习笔记**：需保证解在 \( [0, 2^{125}] \) 内，可通过模数乘积控制。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 遍历 \( x \in [0, n) \) | 简单直观 | \( O(n \log n) \) 超时 | \( n \le 400 \) |
| **BSGS（质数）** | 离散对数求解 \( x^x \equiv D \pmod p \) | 高效 | 仅适用于质数模数 | \( n \) 为质数 |
| **增量构造** | 逐层提升解 | 通用高效 | 实现复杂 | 通用（100 pts） |

---

## 4. C++核心代码实现赏析

### 通用核心代码
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

ll pow_mod(ll a, ll b, ll mod) {
    ll res = 1;
    a %= mod;
    while (b) {
        if (b & 1) res = (__int128)res * a % mod;
        a = (__int128)a * a % mod;
        b >>= 1;
    }
    return res;
}

ll inv_mod(ll a, ll p) {
    ll x, y;
    ll g = __gcd(a, p);
    assert(g == 1);
    auto exgcd = [&](auto self, ll a, ll b) -> ll {
        if (b == 0) { x = 1; y = 0; return a; }
        ll d = self(self, b, a % b);
        ll t = x; x = y; y = t - a / b * y;
        return d;
    };
    exgcd(exgcd, a, p);
    return (x % p + p) % p;
}

// 对单个 p^k 求解
ll solve_pk(ll p, ll k, ll D) {
    ll pk = 1;
    for (int i = 1; i <= k; ++i) pk *= p;
    ll x = D % p;
    if (x == 0) x = p; // 保证 x 与 p 互质
    for (ll i = 1; i < k; ++i) {
        ll phi = pow_mod(p, i, pk) * (p - 1);
        ll v = pow_mod(x, x, pow_mod(p, i + 1, pk));
        ll t = (D - v + pow_mod(p, i + 1, pk)) % pow_mod(p, i + 1, pk) / pow_mod(p, i, pk);
        ll inv = inv_mod(x * (p - 1) % p, p);
        ll I = t * inv % p;
        x += I * pow_mod(p, i, pk) * (p - 1);
    }
    return x;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    while (T--) {
        ll n, D;
        cin >> n >> D;
        vector<ll> ps;
        ll tmp = n;
        for (ll p = 2; p * p <= tmp; ++p) {
            if (tmp % p == 0) {
                ll k = 0;
                while (tmp % p == 0) { tmp /= p; ++k; }
                ps.push_back(p);
            }
        }
        if (tmp > 1) ps.push_back(tmp);
        vector<ll> xs, mods;
        tmp = n;
        for (ll p : ps) {
            ll k = 0, pk = 1;
            while (tmp % p == 0) { tmp /= p; ++k; pk *= p; }
            ll x = solve_pk(p, k, D % pk);
            xs.push_back(x);
            mods.push_back(pk);
        }
        // CRT合并
        ll res = 0, lcm = 1;
        for (int i = 0; i < xs.size(); ++i) {
            ll a = xs[i], m = mods[i];
            ll g = __gcd(lcm, m);
            assert((a - res) % g == 0);
            ll new_lcm = lcm / g * m;
            ll inv = inv_mod(lcm / g, m / g);
            res = (res + (a - res) / g * inv % (new_lcm) * (lcm)) % new_lcm;
            lcm = new_lcm;
        }
        cout << res << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 主题：**“数论探险家”解锁神秘幂塔**

#### 场景设计
- **像素风格**：8位红白机风格，背景为深蓝色星空。
- **角色**：像素小人（探险家）手持钥匙（解 \( x \)），逐层解锁金色塔（模数 \( p^k \)）。

#### 动画步骤
1. **分解阶段**：  
   - 屏幕中央出现巨大数字 \( n \)，逐渐分解成彩色小方块（质因子 \( p_i^{k_i} \)）。
   - 音效：8位“分解”音效（咔哒咔哒）。

2. **逐层解锁**：  
   - 小人走到第一个塔（\( p^1 \)），钥匙插入后，塔亮起绿色光。
   - 动画显示 \( x_1^{x_1} \equiv D \pmod p \) 的验证过程（像素数字跳动）。
   - 小人继续走向更高的塔（\( p^2 \), \( p^3 \), ...），每次插入钥匙后，塔升高并变色。

3. **CRT合并**：  
   - 所有小塔的光芒汇聚成一道彩虹桥，通向最终金色大门（模数 \( n \)）。
   - 小人将最终钥匙插入大门，门打开，显示解 \( x \)。
   - 音效：胜利音效（8位马里奥“通关”音）。

#### 交互控制
- **步进按钮**：点击后小人移动一步。
- **自动模式**：小人自动解锁所有塔。
- **重置按钮**：重置到初始状态。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **增量构造**：适用于**模数幂次提升**问题（如 Hensel 引理）。
- **CRT合并**：适用于**同余方程组**（如“青蛙约会”）。
- **离散对数**：适用于**指数同余**（如“离散对数模板”）。

### 洛谷推荐练习
1. **P2480 [SDOI2010] 古代猪文**  
   - 推荐理由：考察欧拉定理与 CRT 的结合，巩固模数分解技巧。
2. **P4774 [NOI2018] 屠龙勇士**  
   - 推荐理由：需用扩展 CRT 与离散对数，提升综合建模能力。
3. **P3306 [SDOI2013] 方程**  
   - 推荐理由：裸离散对数题，练习 BSGS 模板。

---

## 7. 学习心得与经验分享

> **来自 Alex_Wei**：  
> “本题的核心在于**归纳构造**与**数学直觉**。  
> 一开始尝试暴力 CRT 合并时，忽略了模数不互质的细节，导致错误。  
> 后来通过**二项式展开**逐层提升解，才找到正确路径。”

> **洛语云笺点评**：  
> 数论题的陷阱往往在于**边界条件**与**互质性假设**。  
> 动手模拟小数据（如 \( n = 4, 8 \)）能有效发现规律！

---

> **结语**：  
> 从“暴力枚举”到“数论魔法”，我们见证了数学的力量。  
> 下次遇到“不可能”的问题时，不妨先分解它，再逐层击破！

---
处理用时：119.25秒
# 题目信息

# 「HGOI-1」Competition

## 题目背景

$\text{HGOI}$ 举办了一场模拟赛。

为了增加选手们的积极性，$\text{HGOI}$ 的出题人根据题目难度划定了一个分数线。$\text{bh1234666}$ 会给超过这个分数线的选手发奖品。

## 题目描述

众所周知，$\text{OI}$ 赛制的比赛有很大的运气成分。选手们往往不能发挥出真实水平。所以对于参赛的 $n$ 位选手，第 $i$ 位选手会有一个达到分数线的概率 $p_i$。

在模拟赛结束后就是最激动人心颁奖环节。

组委会的委员们设置了若干种类的奖品，并且每种奖品都有对应的价值。而他们对自己设置的奖品的发放有各自的要求：

- $\text{uuku}$ 喜欢成双成对，所以对于他设置的**每种**奖品必须向**偶数个获奖选手**发放。

- $\text{rechinist}$ 喜欢跟 $\text{uuku}$ 对着干，所以对于他设置的**每种**奖品必须向**奇数个获奖选手**发放。

委员 $\text{uuku}$ 设置了 $A$ 种奖品，$a_i$ 表示他设置的第 $i$ 种奖品的价值。

委员 $\text{rechinist}$ 准备了 $B$ 种奖品，$b_i$ 表示他设置的第 $i$ 种奖品的价值。

当然**每个获奖选手**都将被发给**恰好**一份奖励。

选手们不关心每种奖品被发放了几次，但是他们关心有多少种奖品被发放了，因此选手们的积极性被定义为所有被发放的奖品的价值的乘积（每种奖品只会被乘一次）。

假如获奖人数使得委员会无法发放奖品， $\text{bh1234666}$ 会十分生气，拒绝提供资金购买奖品，使得选手积极性为 $0$ 。

现在，委员会已经知道了每个选手能达到分数线的概率 $p_i$，他们想知道选手们积极性的期望值为多少。

由于答案可能很大，所以你只需要给出对 $998244353$ 取模以后的结果。


## 说明/提示

#### 样例1解释

$0\sim n$ 人达到分数线的概率依次为$\dfrac{1}{16}$，$\dfrac{1}{4}$，$\dfrac{3}{8}$，$\dfrac{1}{4}$，$\dfrac{1}{16}$。

对于 $0$ 人达到分数线无发放方案。

对于 $1$ 人达到分数线无发放方案。

对于 $2$ 人达到分数线有如下 $2$ 种发放方案。

$4$，$5$ 价值为 $20$ 对期望贡献为 $20\times \dfrac{3}{8}\times \dfrac{1}{2}=\dfrac{15}{4}$。

$5$，$4$ 价值为 $20$ 对期望贡献为 $20\times \dfrac{3}{8}\times \dfrac{1}{2}=\dfrac{15}{4}$。

对于 $3$ 人达到分数线无发放方案。

对于 $4$ 人达到分数线有如下 $32$ 种发放方案。

对于发放 $4$，$5$ 两种奖品一共有 $8$ 种方式。

每种价值均为 $20$ 对期望总贡献为 $20\times 8\times \dfrac{1}{16}\times \dfrac{1}{32}=\dfrac{5}{16}$。

对于发放 $1$，$4$，$5$ 三种奖品一共有 $12$ 种方式。

每种价值均为 $20$ 对期望总贡献为 $20\times 12\times \dfrac{1}{16}\times \dfrac{1}{32}=\dfrac{15}{32}$。

对于发放 $2$，$4$，$5$ 三种奖品一共有 $12$ 种方式。

价值均为 $40$ 对期望贡献为 $40\times 12\times \dfrac{1}{16}\times \dfrac{1}{32}=\dfrac{15}{16}$。

则总期望 $E=\dfrac{15}{4}+\dfrac{15}{4}+\dfrac{5}{16}+\dfrac{15}{32}+\dfrac{15}{16}=\dfrac{295}{32}\equiv 779878410 (\bmod\ 998244353)$。

#### 数据范围

本题采用**捆绑测试**，共有 $6$ 个 $\text{subtask}$，最终分数为所有 $\text{subtask}$ 分数之和。

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Task} & \textbf{Score} & \textbf{特殊限制} \cr\hline
1 & 5 & n \le 5 \text{且} A \text{，}B \le 5 \cr\hline
2 & 10 & n \le 500 \text{且} A+B \le 500 \cr\hline
3 & 15 & n \le 2000 \text{且} A+B\le 2000  \cr\hline
4 & 20 & n\text{，}A\text{，}B \le 5000  \cr\hline
5 & 20 & n \le 2\times 10^5 \text{，} A \text{，} B \le 10^5\cr\hline
6 & 30 &  \cr\hline
\end{array}
$$

对于 $100\%$ 的数据，$1 \le A$，$B \le 2 \times 10^5$，$1 \le n \le 4 \times 10^5$，$1 \le a_i$，$b_i$，$p_i \le 998244352$。

## 样例 #1

### 输入

```
4 2 2
499122177 499122177 499122177 499122177
1 2 
4 5```

### 输出

```
779878410```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「HGOI-1」Competition 深入学习指南 💡

> 各位小选手，欢迎来到洛语云笺的“概率-生成函数”魔法教室！今天我们要一起拆解的，是一场把**概率期望、生成函数、多项式科技**全部打包的硬核比赛。  
> 题目乍看像“发奖品”，实则是一场“系数炼金术”：  
> 把选手过线的概率变成多项式，把奖品规则变成指数级生成函数，再把它们卷在一起，最后取个系数就是答案！  
> 准备好了吗？让我们开始这场像素风的数学冒险！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> “在 n 位选手随机过线的背景下，如何把两种**奇偶限制**的奖品发放规则，转化为一个**可计算的期望值**？”

### ✨ 核心算法标签
- 多项式 (Polynomial)  
- 指数型生成函数 (EGF)  
- 分治 + NTT  
- 有理函数求系数  

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：期望定义** | 题目要求“所有被发放奖品价值的乘积”的期望 ➜ **期望线性性**失效，必须整体建模。 |
| **线索2：奇偶限制** | “偶数个/奇数个” ➜ **EGF** 里 `cosh x / sinh x` 的经典信号！ |
| **线索3：数据规模** | n≤4×10⁵ ➜ 需要 **O(n log n) 或 O(n log² n)** 的生成函数算法。 |

---

### 🧠 思维链构建：从线索到策略
> 1. 先拆问题：  
>    - **P(k)**：恰好 k 人过线的概率 → 分治乘多项式。  
>    - **F(k)**：给 k 人发奖且满足奇偶限制的方案数 → EGF 卷积。  
>    - **V(k)**：这些方案的价值总和 → 在 EGF 里再乘一个价值。  
> 2. 再合并：  
>    E = Σ P(k)·V(k)/F(k)。  
> 3. 最后把“除以 F(k)”变成“乘逆元”——有理函数求系数即可。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **NaCly_Fish** (赞：6) | 完整给出了 **“有理函数通分 + 分治乘 + 泰勒展开”** 一条龙实现；代码里把 `exp / log / pow` 全部手写，常数略大但思路清晰。 | 适合想一次性吃透 **多项式全家桶** 的同学，可当“模板大全”收藏。 |
| **uuku** (赞：4) | 把问题拆成 **P, F, val** 三大块，每块都用 **EGF 化简** 到最简形式；最后再用 **分治通分** 统一求系数，复杂度 O(n log² n)。 | 逻辑分层清晰，适合想先“看懂再写”的同学，**分治通分** 技巧尤其值得学习。 |
| **IdnadRev** (赞：0) | 用一句话点破核心：**“把 eˣ 看成变量 x，分治乘后求 Σ f_i iᵏ”**；并给出 [P7431] 的引用。 | 最短最浓缩的“题眼”笔记，适合已经熟悉多项式套路的同学秒懂。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 详细拆解 | 学习笔记 |
|---|---|---|
| **1. 把奇偶限制翻译成 EGF** | `uuku` 类奖品：EGF = `cosh x = (eˣ+e⁻ˣ)/2`；`rechinist` 类：EGF = `sinh x = (eˣ-e⁻ˣ)/2` | 见到“偶/奇数个”直接联想到双曲函数！ |
| **2. 价值 EGF 的构造** | 对 uuku 类：把 `cosh x` 的每一项再乘上 `a_i`；整体乘积可写成 `∏(1 + a_i(cosh x-1))` | 多乘一个“价值系数”即可。 |
| **3. 有理函数求 Σ f_i·iᵏ** | 把 `F(eˣ)` 展开成 `Σ c_i·e^{ix}`，再泰勒展开回普通生成函数；用 **分治通分** 求 `Σ c_i/(1-ix)` 的系数。 | 经典套路：有理函数 → 分式分解 → 泰勒展开。 |
| **4. 复杂度控制** | 三次 NTT 卷积：① 概率多项式 ② 方案数多项式 ③ 价值多项式；整体 **O(n log² n)** | 常数略大，但 n≤4e5 可过。 |

---

### ⚔️ 策略竞技场

| 策略 | 思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力 DP** | O(n²) 递推 | 好写 | n>5000 直接爆炸 | 5-10 pts |
| **NTT 分治乘** | 多项式乘积求 P(k) | 好写 | 只解决一半 | 20-30 pts |
| **EGF + 分治通分** (正解) | 把奇偶限制+价值全部卷进 EGF，再求系数 | 理论优美、复杂度正确 | 代码量大 | 100 pts |

---

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点**：最朴素的 O(n²) DP 枚举 k 人发奖 → TLE。  
> 2. **瓶颈**：枚举 k 人时，奇偶限制无法简单递推。  
> 3. **钥匙**：生成函数！把“奇数个”变成 `sinh x`，把“偶数个”变成 `cosh x`。  
> 4. **升华**：再把 `e^{kx}` 看成变量，用分治乘求 `Σ f_i iᵏ`，复杂度降到 O(n log² n)。  
> 5. **终点**：所有多项式操作全部 NTT 实现，常数优化后稳稳通过。

---

## 4. C++核心代码实现赏析

### 通用核心参考（uuku 版框架）

```cpp
// 只保留核心骨架，完整模板请见原题解
using Poly = vector<int>;

// 1. 计算 P(k): 分治乘
Poly getP(int l,int r){
    if(l==r) return {sub(1,p[l]),p[l]};
    return NTT_mul(getP(l,mid),getP(mid+1,r));
}

// 2. 计算 F(k): 奇偶限制 EGF
Poly getF_A(){          // uuku: cosh x
    Poly g(n+1);
    for(int i=0;i<=n;i+=2) g[i]=ifac[i];
    return poly_pow(g,n+1,A);   // (cosh x)^A
}
Poly getF_B(){          // rechinist: sinh x
    Poly g(n+1);
    for(int i=1;i<=n;i+=2) g[i]=ifac[i];
    auto res = poly_pow(g,n+1,B);
    for(int i=n;i>=B;--i) res[i]=res[i-B];   // x^B
    return res;
}

// 3. 计算 val(k): 把价值塞进 EGF
Poly getVal_A(){        // uuku: 1+a_i(cosh-1)
    // 分治乘 ∏(1+a_i(cosh-1))，最后通分求系数
    return work_A::main();   // 见 uuku 题解
}

// 4. 合并答案
int main(){
    init_NTT(1<<20);
    auto P = getP(1,n);
    auto FA = getF_A(), FB = getF_B();
    auto VA = getVal_A(), VB = getVal_B();
    auto F = NTT_mul(FA,FB);          // 方案数
    auto V = NTT_mul(VA,VB);          // 价值总和
    int ans=0;
    for(int k=B;k<=n;k+=2){
        ans = add(ans, mul(P[k], mul(V[k], inv(F[k]))));
    }
    cout<<ans;
}
```

---

### 分治通分片段赏析（IdnadRev 思路）

```cpp
// 求 Σ f_i / (1-ix)
struct Node{ Poly num,den; };   // num/den
Node solve(int l,int r,const Poly& c){
    if(l==r) return {{c[l]}, {1, p-l}};   // 1-ix
    auto L=solve(l,mid,c), R=solve(mid+1,r,c);
    return {
        add(NTT_mul(L.num,R.den), NTT_mul(R.num,L.den)),
        NTT_mul(L.den,R.den)
    };
}
```
💡 **学习笔记**：有理函数求系数 = 分治通分，时间 O(n log² n)，空间 O(n log n)。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素炼金术士”**  
> 在 8 位像素画布里，把“选手过线”画成像素小人，“奖品”画成像素宝石，实时展示多项式卷积的每一步！

### 画面设计
- **像素画布**：256×144 分辨率，16 色调色板。  
- **数据结构**：  
  - `Poly` → 一排像素条，高度代表系数大小。  
  - `NTT` → 像素条做 FFT 蝴蝶变换动画。  
- **交互控制**：  
  - 步进 / 自动播放 / 调速滑块。  
  - 点击“单步”高亮当前正在卷积的两个像素条。  
- **游戏化元素**：  
  - 每完成一次卷积，播放 8-bit “叮” 音效。  
  - 成功算出答案后，像素小人举旗庆祝，播放胜利 BGM。

### 关键帧示意（伪代码）
```js
// Canvas 关键帧
function drawPoly(poly, x0, color){
    for(let i=0;i<poly.length;i++){
        let h = poly[i] * scale;
        ctx.fillStyle = color;
        ctx.fillRect(x0+i*4, 144-h, 4, h);
    }
}
function animateConvolution(A,B,C){
    drawPoly(A, 0, '#5f5');
    drawPoly(B, 0, '#55f');
    // 蝴蝶变换动画
    for(let step of butterflySteps){
        drawPoly(step.temp, 0, '#f55');
        sleep(200);
    }
    drawPoly(C, 0, '#ff5');   // 结果
}
```

---

## 6. 拓展练习与相似问题思考

### 通用套路迁移
- **“奇偶限制”** 可以换成“模 3 限制”、“至少 k 个”等，只需换 EGF。  
- **“价值乘积”** 可以换成“价值异或和”、“价值最大子集”等，需改生成函数。  

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P4841** | 组合数学里“恰好/至少”问题，练 EGF 模板。 |
| **P5273** | 多项式幂函数加强版，练 `poly_pow` 常数优化。 |
| **P7431** | 自然数幂和的分治通分，直接复用本题技巧。 |
| **P5245** | 多项式快速幂裸题，练 `exp(log(A)*k)` 写法。 |

---

## 7. 学习心得与经验分享

> **uuku 的踩坑笔记**：  
> “我把 `sinh x` 的系数写成 `ifac[i]` 而不是 `ifac[i+1]`，调了 2h……  
> 提醒：EGF 的 `x^k/k!` 别忘了阶乘！”

💡 **洛语云笺点评**：  
写多项式时，**阶乘、逆元、偏移量** 是三大高频坑位。  
建议打印前 10 项手算验证，比肉眼 debug 快得多！

---

> 像素炼金术士的旅程到此结束！  
> 记住：**“把规则变成多项式，把答案变成系数”**——  
> 这就是高级组合数学的魅力。下次见！

---
处理用时：105.38秒
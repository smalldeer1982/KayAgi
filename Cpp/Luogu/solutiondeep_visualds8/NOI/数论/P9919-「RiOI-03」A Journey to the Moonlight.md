# 题目信息

# 「RiOI-03」A Journey to the Moonlight

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/hi1cu7o7.png)

（图片来自 phigros 曲绘，侵删。）

[加强版链接](/problem/P10286)

KDOI 的业务发展到月亮上了。但是月亮上网速很慢，他们需要解决网速问题。

KDOI 的工作人员研发了一种新型无线局域网模块 Wife（WIreless Fidelity Extend），每个模块最多连接两个用户，并且可以选择为其中一位客户提供 $1$ 单位带宽。不过，无论有多少个模块同时为一位客户提供带宽，他的总带宽永远是 $1$。

公司的员工都很懒，经常 ppt 一鸽就是一个月。因此，他们也懒得为 Wife 贴上标签，也就是所有模块间不做区分。另外，为了节省电费，不能有两个模块的工作客户范围完全相同。

现在有 $n$ 个用户购买了服务。当 Wife 系统正式启动时，鹿由器发现了一个问题：可能有些用户没有宽带可以使用！快斗现在手里没有 Wife，只能抢来一个，牺牲一个用户的利益，按一定顺序给所有包括有宽带的用户使用。然而，没有宽带的用户们要求很苛刻，只要没有给他们按注册顺序连续地提供宽带，他们就会威胁鹿由器退钱。

快斗已经忘了他们的注册时间了，只能随机选一个 $1\sim n$ 的排列来决定提供宽带的顺序。为了让尝试的次数尽量小，他会调整 Wife 连接的用户。他想知道，要让这些顾客平息愤怒，需要尝试的最小期望次数是多少。

特别的，Wife 有两种型号。型号 $1$ 可以选择只连接一位，型号 $2$ 则只能连接两个不同客户。你需要分别计算出这两种型号的答案。

快斗自己肯定~~不~~会做，所以他要让你求出所有 $i\in[0,n]$ 的结果 $ans_i$。考虑到你如果一个一个汇报会累死的，仁慈的鹿由器会给你数组 $a$，让你输出 $\sum a_i\times ans_i$。



## 题目描述

#### 【形式化题意】

对于一个右部点为 $m$ 个的二分图 $G$，定义它的权值 $w(G)$ 如下：

- 选择一种匹配方案，标记第一个已匹配的右部点。如果不存在这样的点，那么标记第一个未匹配的右部点。
- 每次随机选择一个 $1,2,\cdots,m$ 的排列，当未匹配的右部点与被标记的点 **按标号顺序作为一个子段出现在排列中时** 停止操作。
- $w(G)$ 为在所有匹配方案中操作次数期望的 **最小值**。

将这个二分图 $G$ 定义为 **$k$ 合法** 的，当且仅当：

- 所有左部点的度数在 $k\sim 2$ 之间。
- 没有任意两个左部点，与其相邻的点组成的集合相同。

定义 $f(k,x)$ 为所有右部点 $x$ 个，左部点不进行区分的 $k$ 合法二分图 $G$ 的 $w(G)$ 之和。

给定 $n,k,a_{0\sim n}$，求 $\sum\limits^n_ia_if(k,i) \bmod998244353$。

## 说明/提示

约定一个左部点连接了编号为 $x,y$ 的右部点表示为 $(x,y)$。

#### 【样例 1 解释】

对于 $n=0,1$，答案显然为 $1,2$。

对于 $n=2$，可能的二分图为（用每个左部点的邻接点组成的元组表示）：

$()$

$(1),(2),(1,2)$

$\{(1),(2)\},\{(1,2),(2)\},\{(1,2),(1)\},\{(1,2),(1),(2)\}$

期望相同的二分图被分为一组。答案为 $\dfrac21+\dfrac21\times3+\dfrac22\times4=12$，输出 $1\times1+1\times2+1\times12=15$。

#### 【样例 2 解释】

对于 $n=0,1,2$，答案为 $1,1,4$。

对于 $n=3$，可能的二分图为（用每个左部点的邻接点组成的元组表示）：

$()$

$(1,2),(1,3),(2,3)$

$\{(1,2),(1,3)\},\{(1,2),(2,3)\},\{(1,3),(2,3)\}$

$\{(1,2),(2,3),(1,3)\}$

答案为 $\dfrac61+\dfrac61\times3+\dfrac62\times3+\dfrac66=34$。

#### 【数据范围】

对于 $100\%$ 的数据，$0\le n\le1.5\times10^4$，$1\le k\le2$，$0\le a_i<998244353$。

**本题开启捆绑测试**

|$\text{Subtask}$|$\text{Score}$|$n\le $|$k\ge$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$0$|$5$|$5$|$1$||
|$1$|$10$|$500$|$2$||
|$2$|$20$|$500$|$1$|$a_i\equiv\dfrac1{i!}$|
|$3$|$20$|$1.5\times10^4$|$2$|$a_i\equiv\dfrac1{i!}$|
|$4$|$45$|$1.5\times10^4$|$1$||

## 样例 #1

### 输入

```
2 1
1 1 1```

### 输出

```
15```

## 样例 #2

### 输入

```
3 2
1 1 1 1```

### 输出

```
40```

## 样例 #3

### 输入

```
12 1
1 1 4 5 1 4 1 9 1 9 8 1 0```

### 输出

```
721168027```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「RiOI-03」A Journey to the Moonlight 深入学习指南 💡

> 今天，我们踏上一次“月球 Wi-Fi 大作战”的思维探险！题目把“二分图 + 最大匹配 + 排列期望”揉成了一个硬核组合数学难题。别担心，我会带你像侦探一样拆解线索，再用像素动画把抽象公式变成看得见的游戏。准备好一起“打怪升级”了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
**在“度数受限、无重边”的二分图上，统计所有可能图的“最小期望操作次数”之和。**  
—— 换句话说，我们要先给月亮上的 n 个用户画一张合法的“Wi-Fi 连接图”，再算出“鹿由器随机拔网线”的期望次数，最后把所有合法图的结果加权求和。

✨ **核心算法标签**：  
组合计数、生成函数（EGF）、多项式 ln / exp / 幂、分块 FFT、模 998244353。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：计数对象** | “所有 k 合法二分图” → 需要枚举图结构 → 生成函数天然适合。 |
| **线索2：度数限制** | 左部点度数 ∈ {k, 2}，无重边 → 转化为“无向简单图”计数问题。 |
| **线索3：期望公式** | 题面给出“最小期望次数”= n! / (k!)，k 为最大匹配数 → 只需统计“最大匹配=k 的图”数量。 |
| **线索4：数据范围** | n ≤ 1.5×10⁴ → O(n log n) 或 O(n√n log n) 可行，FFT/NTT 必备。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，**线索3** 把“期望”转化成了“计数”——我们只需关心“最大匹配大小”的分布。  
> 2. 接着，**线索2** 把“二分图”变成“无向简单图”：把每个左部点看成一条无向边 (x,y)。  
> 3. 于是问题变成：**统计边数 m 的无向简单图，满足：  
>   • 无重边（已满足）；  
>   • 每个连通块“要么是一棵树，要么不是树”；  
>   • 最大匹配 = 总点数 − 树连通块数。**  
> 4. 最后，**线索4** 提示：用 **生成函数 + 多项式全家桶** 做卷积，配合 **分块 FFT** 把复杂度压到 O(n√n log n)。

---

## 2. 精选优质题解参考

**题解来源**：Register_int（洛谷题解区，赞数 7）

* **点评**  
  这份题解是“生成函数大师课”！作者用 3 个精妙转化把题意压缩成 2 行公式，再用 EGF 的 ln/exp 把“连通块”拆成“树”和“非树”。最后祭出 **分块 FFT** 黑科技，把 O(n²) 卷积拆成 √n 次 NTT，时间 1.19s。  
  **亮点**：  
  • 组合意义推导清晰，每一步都有“计数故事”；  
  • 代码复用度高，polynomial 命名空间即插即用；  
  • 分块思路 + 暴力卷积边界处理，兼顾效率与实现难度。  

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 & 学习笔记 |
|---|---|
| **1. 期望 → 计数** | 推导出 ans = n!·[xⁿ] G(x)(F(x)+1)ⁿ，其中 F(x) 为树的 EGF。  
💡 **学习笔记**：把“最小期望”转成“计数”是解题的钥匙。 |
| **2. 树的 EGF** | F(x)=∑ i^{i-2}·x^i/i!，利用 Cayley 公式。  
💡 **学习笔记**：经典结论背下来，遇到“树计数”直接套。 |
| **3. 非树连通块 EGF** | ln A(x) − F(x)，其中 A(x)=∑ 2^{C(i,2)}·x^i/i! 为任意连通图。  
💡 **学习笔记**：ln 把“连通”转成“任意”，exp 再转回来。 |
| **4. 分块 FFT** | 把 (F+1)^n 拆成 (F+1)^{iL}·(F+1)^j，预处理两部分，单点 O(n) 乘。  
💡 **学习笔记**：当 n² 卷积卡常，分块 + 预处理是“曲线救国”。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力 DP** | O(n⁴) 枚举图 + O(n³) 匹配 | 思路直观 | n>50 就爆炸 | 5 pts |
| **生成函数裸卷积** | O(n² log n) | 理论可行 | 常数大，1.5e4 跑不动 | 70 pts |
| **分块 FFT** | O(n√n log n) | 标算 | 实现复杂 | 100 pts |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. 起点：n=500 时 O(n²) 卷积还能跑，n=1.5e4 直接 TLE。  
> 2. 发现瓶颈：(F+1)^n 与 G(x) 卷积是瓶颈。  
> 3. 优化钥匙：把指数 n 拆成 √n 段，每段用 NTT 预处理，再暴力拼起来。  
> 4. 结果：1.87s → 1.19s，成功通关！

---

## 4. C++核心代码实现赏析

### 通用核心实现参考
> 说明：综合 Register_int 的标算，保留关键逻辑，删去调试输出。

```cpp
#include <bits/stdc++.h>
using namespace std;
using poly = vector<int>;
const int MOD = 998244353, ROOT = 3;
int n, k, a[15005], ans;

/* 多项式板子略（ntt, inv, ln, exp） */

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> k;
    for (int i = 0; i <= n; ++i) cin >> a[i];

    /* 预处理阶乘、逆阶乘、2^C(i,2) 等 */

    poly F(n + 1), G(n + 1);
    for (int i = 0; i <= n; ++i) {
        F[i] = 1LL * qpow(i, max(i - 2, 0)) * inv[i] % MOD;
        G[i] = 1LL * qpow(2, 1LL * i * (i - 1) / 2) * inv[i] % MOD;
    }
    F[0] = 0; F[1] = 1;

    /* 计算 G(x) / exp(F(x)) * (F(x)+1)^n 的 [x^n] */
    poly A = ln(G) - F;          // 非树连通块
    poly B = exp(A);             // 任意图去掉树
    poly C = F; C[0] = 1;        // F+1
    poly D = solve(C, B, n);     // 分块 FFT 计算 [x^i] 系数

    for (int i = 0; i <= n; ++i)
        ans = (ans + 1LL * a[i] * D[i] % MOD * fac[i]) % MOD;

    cout << ans << '\n';
    return 0;
}
```

---

### 关键代码片段赏析

**片段：分块 FFT 主循环**
```cpp
poly solve(poly f, poly g, int n) {
    int B = sqrt(n) + 1;
    vector<poly> powB(B + 1), powF(B);
    powB[0] = {1}; powB[1] = f;
    for (int i = 2; i <= B; ++i) powB[i] = powB[i - 1] * f;
    poly base = powB[B]; powF[0] = {1}; powF[1] = base;
    for (int i = 2; i < B; ++i) powF[i] = powF[i - 1] * base;

    poly res(n);
    for (int i = 0; i < B; ++i)
        for (int j = 0; j < B; ++j) {
            int pos = i * B + j;
            if (pos >= n) break;
            for (int k = 0; k <= pos; ++k)
                res[pos] = (res[pos] + 1LL * powF[i][k] * (g * powB[j])[pos - k]) % MOD;
        }
    return res;
}
```
💡 **学习笔记**：  
- 外层 i 枚举“大块”，内层 j 枚举“小块”，把 O(n²) 卷积拆成 √n² 次小规模卷积。  
- 预处理 `powB` 与 `powF` 避免重复 NTT，常数优化明显。

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：**“像素月亮网管”**

**故事背景**：8 位像素风的小鹿由器站在月球表面，面前是 n 个像素用户方块。每添加一条边，方块之间出现像素光束。当最大匹配完成，用户方块会“点亮”，并播放 8-bit “叮”声。

### 动画步骤
1. **初始化**：  
   • 8×8 像素网格代表 n 个用户。  
   • 左下角显示当前生成函数 F(x) 与 G(x) 的前几项像素数字。

2. **生成函数卷积**：  
   • 每次 NTT 时，像素光束在网格中快速扫描，颜色代表系数值（红=正，蓝=负）。  
   • 分块 FFT 的 i、j 循环用像素进度条可视化。

3. **结果高亮**：  
   • 当求得 ans_i，对应用户方块闪烁金色，播放“升级”音效。  
   • 右下角弹出像素对话框：“第 i 个用户期望次数 = ans_i”。

4. **交互控制**：  
   • 方向键：单步 / 自动播放。  
   • A 键：重置动画。  
   • B 键：切换显示“树”或“非树”连通块。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **EGF 计数任意图**：把“连通块”转成 ln/exp 是万能套路。  
- **分块 FFT**：任何需要卷积 (A^i) 的计数题，当 n 1e4 量级时均可尝试。  
- **最大匹配与树**：二分图最大匹配 = 点数 − 树连通块数，是经典结论。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P4841 [集训队作业2013] 城市规划 | 无向图计数裸题，练手 ln/exp。 |
| P5824 十二重计数法 | 系统梳理 12 种 EGF 计数模型。 |
| P6295 有标号二分图计数 | 继续玩二分图生成函数。 |

---

## 7. 学习心得与经验分享

> **Register_int 的调试心得**：“一开始把 F(x) 的常数项设成 0 导致 ln 炸掉，后来才发现 i=1 时要特判。”  
> **洛语云笺点评**：  
> 生成函数边界是“隐形地雷”。写 ln/exp 前，先画表格验证前几项，能救命！

---

<conclusion>
恭喜你通关“像素月亮网管”！今天我们用生成函数把复杂的期望问题拆成了可计算的卷积，又用分块 FFT 把 O(n²) 暴力变成了 O(n√n log n) 优雅。下次遇到“计数 + 图 + 期望”的组合，记得先想想生成函数哦！
</conclusion>

---

---
处理用时：93.01秒
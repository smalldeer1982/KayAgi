# 题目信息

# 封锁

## 题目背景

震惊！zbw 竟从 B 城监狱逃出！

作为 B 城的警察局长，你必须在 zbw 逃出你的管辖范围之前抓住他。

## 题目描述

B 城可视为一个 $n \times n$ 的方阵，其中监狱在 $(1,1)$，B 城唯一出城的出口在 $(n,n)$。每两个相邻的点（横坐标之差的绝对值 $+$ 纵坐标之间的绝对值 $=1$）之间都有一条**无向的**道路（没有斜着的道路）。你需要在一些道路上部下防守，使得无论 zbw 怎么走，都至少会经过其中的一条道路。

在一条 $(i,j)$ 到 $(i,j+1)$ 的道路上部下防守的花费是 $r_{i,j}$，在一条 $(i,j)$ 到 $(i+1,j)$ 的道路上部下防守的花费是 $d_{i,j}$，同时，在道路上部下防守会对人民的生活造成影响，在一条 $(i,j)$ 到 $(i,j+1)$ 的道路上部下防守对人民的生活造成的影响是 $x_{i,j}$，在一条 $(i,j)$ 到 $(i+1,j)$ 的道路上部下防守对人民的生活造成的影响是 $y_{i,j}$。

定义总花费为 $w$ ，总影响为 $e$ ，作为一名优秀的警察局长，你需要最小化 $w \times e$。 

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/bjd62iba.png)

如图，左上角为 $(1,1)$，右下角为 $(n,n)$，
其中蓝色数字表示 $r$,
红色数字表示 $x$,
黄色数字表示 $d$,
绿色数字表示 $y$。

最优方案为防守三条边，分别为：

$(2,2)-(2,3),(3,1)-(3,2),(3,2)-(3,3)$

三条边的边权分别是 $2,3$---$1,1$ ---$4,3$

答案为 $(1+2+4)\times (1+3+3)=49$


可以发现没有更优的做法。

**本题采用捆绑测试。**

|  Subtasks| $n$ |特殊性质  |分数
| :----------: | :----------: | :----------: |:----------: |
|  Subtask1| $n=2$ |无  |$5$
|  Subtask2| $n\leq400$ |数据随机  |$15$
|  Subtask3| $n\leq10$ |  无|$15$
|  Subtask4| $n\leq50$ | 无 |$30$
|  Subtask5| $n\leq400$ | 无 |$35$

对于所有数据 $1 \leq n \leq 400$，$0 \leq r_{i,j}, d_{i,j},x_{i,j} ,y_{i,j}  \leq 10^3$。

数据于2020/3/4加强，卡掉部分复杂度错误的做法。

## 样例 #1

### 输入

```
3
8 3
5 2
1 1
4 2
1 2
7 5
7 2
6 1
5 4
2 3
1 4 
4 3```

### 输出

```
49```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：封锁 深入学习指南 💡

今天我们来一起分析“封锁”这道C++黑题。  
它把**最小割**、**最小乘积模型**、**凸包分治**与**网络流/Dijkstra**巧妙地揉在一起，看似复杂，其实思路非常清晰——  
就像把一张地图剪成两半，再找出“剪口”上性价比最高的那条线。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在一张网格图里，用最小的 **(花费 × 影响)** 切断所有从(1,1)到(n,n)的路径。

✨ **核心算法标签**：  
网络流 / 最小割、最小乘积模型、凸包分治、平面图最短路。

🗣️ **初步分析**  
1.  最朴素：枚举所有割 → 指数级，不可行。  
2.  次朴素：枚举所有路径 → 同样指数级。  
3.  进阶：把每条割抽象成平面上的点 (sum_w, sum_e) → 问题转化为“在所有割点中找 x·y 最小者”。  
4.  最终钥匙：**最小乘积模型 + 凸包分治**——把“最小化乘积”转成“在凸壳上找最低点”，再用网络流或最短路求解。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **问题目标** | “最小化 w × e” → 双权乘积最值，经典最小乘积模型信号。 |
| **问题约束** | 网格图、割断所有路径 → 最小割/平面图最短路。 |
| **数据规模** | n ≤ 400 → O(n⁴ log) 以内可过，支持网络流或 Dijkstra。 |

### 🧠 思维链构建：从线索到策略
> 1.  看到“最小化 w×e”→ 脑子里弹出“最小乘积模型”四字。  
> 2.  看到“割断所有路径”→ 立刻联想到“最小割”。  
> 3.  但直接求最小割只能最小化 w 或 e 之一，无法同时最小化乘积。  
> 4.  于是把“割”映射成平面点 (w,e) → 乘积最小点一定在下凸壳上。  
> 5.  用 **凸包分治** 在凸壳上找最低点：  
>    - 先求“只最小化 w”的点 A，“只最小化 e”的点 B；  
>    - 再找直线 AB 下方最远的点 C；  
>    - 递归处理 AC、CB。  
> 6.  每次找点 C 等价于：  
>    把边权设为 `(yB-yA)·a + (xA-xB)·b` 后跑一次最小割/最短路。  
> 7.  复杂度：凸壳点数期望 O(log n²) 次网络流/Dijkstra，总复杂度 ≈ O(n³ log² n) 或 O(n⁴ log)。

---

## 2. 精选优质题解参考

| 题解 | 来源 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|---|
| 1 | feecle6418 | 给出最小乘积模型公式推导、Dinic 模板、找割边技巧 | 思路完整，代码可直接复用；注意“权值全0”时的特判。 |
| 2 | Lyrella | 用博客链接补充模型背景，凸包分治思路清晰 | 博客补充让初学者快速入门；代码未贴但思路足够。 |
| 3 | gyh20 | 平面图 → 对偶图最短路，Dijkstra 实现凸包分治 | 把网格最小割转成最短路，常数更小；代码封装好，易读。 |
| 4 | Hollow_knight_ | 对偶图+Dijkstra，附“三倍经验” | 代码风格清晰，给出更多同类题；复杂度分析有启发。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤 (最优解法)

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 模型转化** | 把“割”抽象成二维点 (w,e)，乘积最小点必在凸壳。 | 双权乘积问题→凸壳最低点，是通用套路。 |
| **2. 凸包分治** | 已知凸壳两端 A、B，求 AB 下方最远点 C：用叉积 `(B-A)×(C-A)` 最小化。 | 叉积最小等价于新边权 `(yB-yA)·a + (xA-xB)·b` 后跑最小割。 |
| **3. 平面图最短路** | 网格最小割等价于对偶图最短路，用 Dijkstra 实现，复杂度更优。 | 对偶图节点数 O(n²)，边数 O(n²)，Dijkstra 为 O(n² log n)。 |
| **4. 实现细节** | - 每次跑网络流前清空<br>- 权值全0时赋大常数避免除0<br>- 用 long long 防溢出 | 细节决定成败，尤其是清空与特判。 |

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分预期 |
|---|---|---|---|---|
| **暴力枚举割** | 枚举所有边子集，检查是否割断 | 思路直观 | 指数级 O(2^{2n(n-1)}) | n≤3 拿 5 pts |
| **枚举路径** | 枚举所有 (1,1)→(n,n) 路径 | 易写 | 指数级 | n≤10 拿 15 pts |
| **最小乘积 + Dinic** | 凸包分治 + 网络流最小割 | 通用、易实现 | 复杂度 O(n⁶ log) 略高 | n≤400 拿 100 pts |
| **最小乘积 + Dijkstra** | 凸包分治 + 平面图最短路 | 复杂度 O(n³ log² n) 更优 | 需掌握对偶图建模 | n≤400 拿 100 pts |

### ✨ 优化之旅：从“能做”到“做好”
> 1.  起点：暴力枚举割 → 2^n² 爆炸。  
> 2.  发现瓶颈：割空间巨大，无法枚举。  
> 3.  优化钥匙：把割映射成平面点→凸壳点数期望仅 O(log)。  
> 4.  模型升华：平面图最小割→对偶图最短路，复杂度骤降。  

---

## 4. C++核心代码实现赏析

### 通用核心实现（对偶图 + Dijkstra 版）
```cpp
// 代码综合 gyh20 & Hollow_knight_ 实现
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 405, M = N * N * 4;
const ll INF = 1e18;

struct Pt { ll x, y; };
Pt operator - (Pt a, Pt b) { return {a.x - b.x, a.y - b.y}; }
ll cross(Pt a, Pt b) { return a.x * b.y - a.y * b.x; }

int n, s, t, tot, head[M];
struct Edge { int to, nxt, w, a, b; } e[M];
void add(int u, int v, int w, int a, int b) {
    e[++tot] = {v, head[u], w, a, b}, head[u] = tot;
}

Pt dijkstra(int sx, int sy) {
    vector<ll> dis(t + 1, INF);
    vector<Pt> sum(t + 1);
    priority_queue<pair<ll,int>> q;
    dis[s] = 0;
    q.push({0, s});
    while (!q.empty()) {
        auto [d, u] = q.top(); q.pop();
        if (-d != dis[u]) continue;
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to, w = e[i].w;
            ll nd = dis[u] + w;
            if (nd < dis[v]) {
                dis[v] = nd;
                sum[v] = {sum[u].x + e[i].a, sum[u].y + e[i].b};
                q.push({-nd, v});
            }
        }
    }
    return sum[t];
}

void build(Pt A, Pt B) {
    tot = 0; memset(head, 0, sizeof head);
    for (int i = 1; i < n; ++i)
        for (int j = 1; j < n; ++j) {
            int pos = (i - 1) * (n - 1) + j;
            if (j < n - 1) {
                add(pos, pos + 1, r[i][j + 1] * (A.y - B.y) + d[i][j + 1] * (B.x - A.x), r[i][j + 1], d[i][j + 1]);
                add(pos + 1, pos, r[i][j + 1] * (A.y - B.y) + d[i][j + 1] * (B.x - A.x), r[i][j + 1], d[i][j + 1]);
            }
            if (i < n - 1) {
                add(pos, pos + n - 1, x[i + 1][j] * (A.y - B.y) + y[i + 1][j] * (B.x - A.x), x[i + 1][j], y[i + 1][j]);
                add(pos + n - 1, pos, x[i + 1][j] * (A.y - B.y) + y[i + 1][j] * (B.x - A.x), x[i + 1][j], y[i + 1][j]);
            }
        }
    // 边界连边略
}

void solve(Pt A, Pt B) {
    build(A, B);
    Pt C = dijkstra();
    if (cross(B - A, C - A) >= 0) return;
    solve(A, C); solve(C, B);
}

int main() {
    cin >> n;
    // 读入 r,d,x,y 略
    s = 0, t = (n - 1) * (n - 1) + 1;
    Pt A = dijkstra(1, 0); // 仅最小化 x
    Pt B = dijkstra(0, 1); // 仅最小化 y
    ll ans = min(A.x * A.y, B.x * B.y);
    solve(A, B);
    cout << ans << '\n';
    return 0;
}
```
* **代码解读概要**：  
  1.  把网格最小割转成对偶图最短路，节点编号 `(i-1)*(n-1)+j`。  
  2.  凸包分治：给定直线 AB，把边权设为 `(yB-yA)*a + (xA-xB)*b` 后跑一次 Dijkstra，得到点 C。  
  3.  递归处理 AC、CB，直到没有更优点。  

---

## 5. 算法可视化：像素动画演示

* **动画主题**：像素警察抓小偷  
* **场景**：8×8 像素网格，监狱(左上)与出口(右下)。  
* **核心演示**：  
  1.  把每条割映射成像素点，凸壳用黄色像素点高亮。  
  2.  分治过程：  
      - 用绿色像素箭头连接当前 AB 直线。  
      - 用蓝色像素方块标记新求得的点 C。  
      - 伴随 8 位“叮”音效。  
  3.  对偶图最短路：像素警察沿最短路径移动，每走一步播放“踏”音效。  
* **交互**：  
  - 步进 / 自动播放 / 调速滑块。  
  - 完成一次分治后，像素礼花庆祝。  

---

## 6. 拓展练习与相似问题思考

* **通用套路迁移**：  
  1.  最小乘积生成树：把生成树权值 (w,e) 抽象成平面点。  
  2.  二分图最小乘积匹配：把匹配方案抽象成平面点。  
  3.  任务调度双目标最小化：把调度方案抽象成平面点。

* **洛谷推荐**：  
  1.  **P5540 最小乘积生成树** —— 模板题，巩固凸壳分治写法。  
  2.  **P3236 最小乘积二分图匹配** —— 套网络流，练建模。  
  3.  **P4001 狼抓兔子** —— 平面图最小割，练对偶图思路。

---

## 7. 学习心得与经验分享

> **来自 gyh20**：  
> “平面图转对偶图后，最短路常数远低于网络流；务必先算空间再开数组，别盲目开大。”  
> **洛语云笺点评**：把图论问题转成几何问题再转回图论，是高级技巧，值得反复体会。

---

<conclusion>  
今天我们用“最小乘积模型 + 凸包分治”这把钥匙，打开了看似复杂的“封锁”大门。  
记住：当题目出现“双权乘积最小”时，先想平面凸壳！  
下次再遇到网格割问题，试试把它翻个面——也许最短路就在对偶图里等你。💪

---
处理用时：122.27秒
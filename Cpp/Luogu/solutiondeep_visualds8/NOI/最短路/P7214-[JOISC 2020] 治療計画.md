# 题目信息

# [JOISC 2020] 治療計画

## 题目背景

因为本题数据点过多，另外 $3$ 组数据请在 [这里](https://www.luogu.com.cn/problem/U127700) 测试。

JOI 村庄的村民们最近发生了 COVILLAGE-19 疫情！

## 题目描述

JOI 村庄有 $N$ 个房屋，编号为 $1$ 到 $N$，每个房屋住有一个村民，第 $i$ 个房屋居住编号为村民 $i$。

现在，这 $N$ 个房屋里的村民全部感染 COVILLAGE-19 病毒，有 $M$ 个治疗方案被提出，第 $i$ 个治疗方案描述为，在第 $T_i$ 天的晚上，编号在 $[L_i,R_i]$ 区间内的村民被治愈。

COVILLAGE-19 病毒还会继续传播，在某天早上，如果村民 $i$ 被感染，那么村民 $i+1$ 和村民 $i-1$ 也会被感染，因为病毒威力巨大，所以被治愈的村民有可能再次被感染。

您是 JOI 国的总理，您要选择一些方案使得 JOI 村庄所有村民全部被治愈，一天可以进行很多方案。

第 $i$ 个方案要花费 $C_i$，求最小花费。

## 说明/提示

#### 样例 1 解释

执行过程如下（红色为被病毒感染，绿色为治愈）：

1. 在第二天晚上，执行第 $1$ 个方案，情况如下：

$$\color{Red}1\ 2\ 3\ 4\color{Green}\ 5\ 6\ 7\ 8\ 9\ 10$$

2. 在第三天早上，村民 $5$ 被感染，情况如下：

$$\color{Red}1\ 2\ 3\ 4\ 5\color{Green}\ 6\ 7\ 8\ 9\ 10$$

3. 在第四天早上，村民 $6$ 被感染，情况如下：

$$\color{Red}1\ 2\ 3\ 4\ 5\ 6\color{Green}\ 7\ 8\ 9\ 10$$

4. 在第四天晚上，执行第 $5$ 个方案，情况如下：

$$\color{Green}1\ 2\ 3\color{Red}\ 4\ 5\ 6\color{Green}\ 7\ 8\ 9\ 10$$

5. 第五天早上，村民 $3,7$ 被感染，情况如下：

$$\color{Green}1\ 2\color{Red}\ 3\ 4\ 5\ 6\ 7\color{Green}\ 8\ 9\ 10$$

6. 在第五天晚上，执行第 $3$ 个方案，情况如下：

$$\color{Green}1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10$$

全部治愈，这三个方案花费为 $7$，为最小花费。

#### 样例 2 解释

无法使得所有村民全部治愈。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$T_i=1$|$4$|
|$2$|$M \le 16$|$5$|
|$3$|$M \le 5000$|$30$|
|$4$|无|$61$|

对于 $100\%$ 的数据，$1 \le N,T_i,C_i \le 10^9$，$1 \le M \le 10^5$，$1 \le L_i \le R_i \le N$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day4 C 治療計画](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/capital_city.pdf)。

## 样例 #1

### 输入

```
10 5
2 5 10 3
1 1 6 5
5 2 8 3
7 6 10 4
4 1 3 1```

### 输出

```
7```

## 样例 #2

### 输入

```
10 5
2 6 10 3
1 1 5 5
5 2 7 3
8 6 10 4
4 1 3 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
10 5
1 5 10 4
1 1 6 5
1 4 8 3
1 6 10 3
1 1 3 1```

### 输出

```
7```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[JOISC 2020] 治療計画 深入学习指南 💡

> 今天，我们一起化身“疫情指挥官”，用最少的预算把村民从病毒手里全部救回来！这道题表面上像区间覆盖，实则暗藏“最短路”玄机——如何把 1e5 个区间高效地连边？让我们一步步拆解。

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
> 在每天病毒会左右扩散的前提下，选若干“治疗计划”把 1~N 全部清零，要求总花费最小。关键难点是：**如何快速判断两个计划能否“接力”**——即前者的右边界+扩散能否覆盖后者的左边界，并把所有判断压缩到可承受复杂度。

✨ **核心算法标签**  
`最短路 (Dijkstra)` | `线段树优化建图` | `二维几何模型` | `点权最短路`

🗣️ **初步分析**  
1. **暴力思路**：两两检查能否接力，O(M²) 建图，再跑 Dijkstra → 1e10 条边，直接爆炸。  
2. **几何转化**：把每个计划看成“等腰直角三角形”区域，接力条件转化为三角形相交。  
3. **最短路模型**：把每个计划当节点，满足相交就连边，边权为计划花费，跑点权最短路。  
4. **优化关键**：利用排序+线段树把 O(M²) 边压到 O(M log M)。  

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：“求最小总花费” → 最短路 / 最小生成树 / DP。  
2. **线索2 (限制条件)**：区间扩散、时间先后 → 需要几何或偏序刻画“能否衔接”。  
3. **线索3 (数据规模)**：M≤1e5 → 必须 O(M log M) 以内，提示“线段树/数据结构”优化。

### 🧠 思维链构建：从线索到策略
> 1. 看到“最小花费”先想最短路；  
> 2. 看到“区间+时间”想到把计划画成二维平面上的“斜三角”；  
> 3. 发现“能否衔接” = 三角形是否相交，拆绝对值得出两个线性不等式；  
> 4. 两个不等式各是一个“区间最小值查询” → 线段树维护即可。  
> 结论：把最短路 + 线段树优化建图完美结合！

---

## 2. 精选优质题解参考

**题解一：George1123（★★★★★）**  
* **点评**：  
  用“等腰直角三角形”形象刻画治疗区域，把接力条件拆成两个线性不等式；随后用**势能线段树**在 O(M log M) 内连边，并指出“点权最短路每个节点只松弛一次”这一关键性质，实现简洁高效。代码风格清爽，注释到位。

**题解二：Komomo（★★★★☆）**  
* **点评**：  
  同样使用几何模型，配图帮助理解；重点强调“点权最短路+第一次松弛即永久”的性质，并用线段树+set实现。思路与George一致，但实现细节略有差异，可作为对比阅读。

**题解三：xht（★★★★☆）**  
* **点评**：  
  把问题直接映射到 [NOI2019 弹跳] 的二维矩形连边模型，思路迁移清晰；线段树优化建图代码结构规范，适合作为模板收藏。

**题解四：wjyppm1403（★★★★）**  
* **点评**：  
  先尝试 DP 发现维度爆炸，再转向最短路，体现“**状态设计失败→模型转化**”的思考过程；线段树实现细节完整，对初学者友好。

**题解五：AC_love（★★★☆）**  
* **点评**：  
  给出 K-D Tree 优化建图的另类做法，思路新颖；但涉及坐标旋转与浮点精度，代码复杂度较高，适合作为拓展阅读。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）
1. **关键点1：几何建模**  
   * **分析**：把计划 i 视为点 (t_i, l_i, r_i)，覆盖区域为 |x-t_i|+|y-l_i|≤r_i-l_i 的等腰直角三角形。两个计划 i→j 可衔接 ⇔ 区域相交 ⇔ |t_i-t_j| ≤ (r_i-l_j+1)。  
   * 💡 **学习笔记**：把区间+时间问题映射到二维平面，可借助几何直觉快速推导条件。

2. **关键点2：拆绝对值 + 线段树优化连边**  
   * **分析**：拆绝对值得两条不等式  
     - t_i ≥ t_j：r_i+t_i ≥ l_j+t_j  
     - t_i < t_j：r_i-t_i ≥ l_j-t_j  
     排序后分别用线段树维护“l_j±t_j”最小值，区间查询即可 O(log M) 找到所有可衔接的 j。  
   * 💡 **学习笔记**：排序+偏序+线段树是压缩 O(M²) 边的经典套路。

3. **关键点3：点权最短路的性质**  
   * **分析**：因为边权都在点上，Dijkstra 第一次弹出即得到最终最短路，因此每个节点只松弛一次；配合线段树“用完即删”即可保证 O(M log M)。  
   * 💡 **学习笔记**：点权最短路可省去“二次松弛”，是线段树优化建图的理论基础。

### ✨ 解题技巧总结
- **问题转化**：区间+时间 → 二维平面三角形 → 偏序条件。  
- **数据结构辅助**：用线段树维护“区间最小值+单点删除”，实现高效连边。  
- **算法选择**：点权最短路天然适合“每个点只松弛一次”的场景。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力建图** | O(M²) 枚举连边 + Dijkstra | 思路直观 | 1e10 条边，无法通过 | M≤3e3 可得部分分 |
| **线段树优化建图** | 拆绝对值+线段树区间查询连边 | O(M log M)，100% 通过 | 需要几何推导与线段树技巧 | 标准正解 |
| **K-D Tree 优化** | 旋转坐标后用 K-D Tree 连边 | 思路新颖 | 浮点精度+常数大 | 拓展思路，竞赛慎用 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. 起点：暴力枚举两两计划能否衔接 → 复杂度爆炸。  
> 2. 发现瓶颈：重复比较，大量无用边。  
> 3. 优化钥匙：把条件拆成两个线性不等式，用排序+线段树一次性找出所有合法边。  
> 4. 升华：利用“点权最短路只松弛一次”保证总复杂度 O(M log M)。

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合 George1123 与 wjyppm1403 思路，展示线段树优化建图的完整框架。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll INF = 1e18;
const int N = 1e5 + 10;

struct Plan { int t, l, r, c; } p[N];
int n, m;
ll dist[N];
bool vis[N];

// 线段树节点
struct Node {
    int l, r;
    ll mn[2];        // 0: l-t, 1: l+t
    Node *lc, *rc;
    Node(int l, int r) : l(l), r(r), mn{INF, INF}, lc(nullptr), rc(nullptr) {}
};

Node* build(int l, int r) {
    Node* o = new Node(l, r);
    if (l == r) return o;
    int mid = (l + r) >> 1;
    o->lc = build(l, mid);
    o->rc = build(mid + 1, r);
    return o;
}

void push_up(Node* o) {
    o->mn[0] = min(o->lc->mn[0], o->rc->mn[0]);
    o->mn[1] = min(o->lc->mn[1], o->rc->mn[1]);
}

void set_val(Node* o, int pos, ll v0, ll v1) {
    if (o->l == o->r) { o->mn[0] = v0; o->mn[1] = v1; return; }
    int mid = (o->l + o->r) >> 1;
    if (pos <= mid) set_val(o->lc, pos, v0, v1);
    else set_val(o->rc, pos, v0, v1);
    push_up(o);
}

vector<int> adj;

void query(Node* o, ll lim, int type, int ql, int qr) {
    if (o->mn[type] > lim) return;
    if (o->l == o->r) { adj.push_back(o->l); o->mn[0] = o->mn[1] = INF; return; }
    int mid = (o->l + o->r) >> 1;
    if (ql <= mid) query(o->lc, lim, type, ql, qr);
    if (qr > mid) query(o->rc, lim, type, ql, qr);
    push_up(o);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        cin >> p[i].t >> p[i].l >> p[i].r >> p[i].c;
        --p[i].l;
    }
    sort(p + 1, p + m + 1, [](auto& a, auto& b) { return a.t < b.t; });

    Node* root = build(1, m);
    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<>> pq;
    for (int i = 1; i <= m; ++i) {
        if (p[i].l == 0) {
            dist[i] = p[i].c;
            pq.emplace(dist[i], i);
            set_val(root, i, INF, INF);
        } else {
            set_val(root, i, p[i].l - p[i].t, p[i].l + p[i].t);
            dist[i] = INF;
        }
    }

    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (vis[u]) continue;
        vis[u] = true;
        adj.clear();
        if (u > 1) query(root, p[u].r - p[u].t + 1, 0, 1, u - 1);
        if (u < m) query(root, p[u].r + p[u].t + 1, 1, u + 1, m);
        for (int v : adj) {
            dist[v] = dist[u] + p[v].c;
            pq.emplace(dist[v], v);
            set_val(root, v, INF, INF);
        }
    }

    ll ans = INF;
    for (int i = 1; i <= m; ++i)
        if (p[i].r == n) ans = min(ans, dist[i]);
    cout << (ans == INF ? -1 : ans) << '\n';
    return 0;
}
```
* **代码解读概要**：  
  - 线段树维护 `l-t` 与 `l+t` 最小值，支持区间查询+单点删除。  
  - 初始把 `l=0` 的计划入队；每次弹出后，用线段树找所有可衔接的计划，松弛并加入队列。  
  - 复杂度 O(M log M)。

---

## 5. 算法可视化：像素动画演示

**动画主题**：“像素指挥官的防疫战”  
- **场景**：8×16 像素的“村庄-时间”网格，横轴为房屋编号，纵轴为天数。  
- **元素**：  
  - 红色像素 = 感染；绿色 = 治愈；蓝色 = 当前正在执行的计划。  
  - 每个计划对应一个 45° 等腰直角三角形的“治愈波”，从右向左/从左上向右下扩散。  
- **交互面板**：  
  - 单步 / 自动播放 / 速度滑块。  
  - 右下角小窗口实时显示 Dijkstra 堆状态（堆顶节点、当前距离）。  
- **音效**：  
  - “叮”——发现可衔接计划；  
  - “哔”——节点松弛成功；  
  - “胜利”音效——全部村民治愈。  
- **关卡化**：  
  - 每成功松弛一个节点 = 1 关；  
  - 10 关内通关奖励“像素勋章”。  

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**：  
  1. 区间+时间 → 二维几何 → 偏序 → 线段树优化建图，适用于 **弹跳、区间覆盖带时间维度** 等问题。  
  2. 点权最短路“只松弛一次”可推广到 **动态区间最短路** 场景。  

- **洛谷推荐练习**  
  1. **P5471 [NOI2019] 弹跳**  
     🗣️ 推荐理由：二维平面点向矩形连边的最短路，线段树优化建图模板。  
  2. **P3357 [SDOI2019] 移动金币**  
     🗣️ 推荐理由：区间+时间限制，需几何建模与最短路思想。  
  3. **P3646 [APIO2015] 巴厘岛的雕塑**  
     🗣️ 推荐理由：区间覆盖带代价，可尝试线段树优化 DP 或最短路。  

---

## 7. 学习心得与经验分享

> **摘录经验 (来自 George1123)**  
> “注意 +∞ 的大小和 long long 的问题啊，啊啊啊……”  
> **点评**：  
> 线段树中维护的 INF 必须大于 2×1e18 以防加法溢出；用 0x3f3f3f3f3f3f3f3f 更安全。调试时可打印线段树节点值快速定位越界。

---

<conclusion>  
从“暴力枚举”到“几何+线段树最短路”，我们完成了一次思维的跃迁。掌握“二维建模 + 数据结构优化建图”后，你将能在更多看似不可做的区间/时间难题中游刃有余！下次见！

---
处理用时：122.91秒
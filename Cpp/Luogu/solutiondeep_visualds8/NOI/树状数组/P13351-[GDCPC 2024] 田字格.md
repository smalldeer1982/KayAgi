# 题目信息

# [GDCPC 2024] 田字格

## 题目背景

数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>

## 题目描述

小 I 正在学习练字，可当他打开白纸时才想起来自己之前无聊在白纸上将 $n$ 条线段涂黑了，纸上其他部分都是白的。

这 $n$ 条被涂黑的线段都是水平的或者竖直的：以白纸中心为原点，平行白纸的某条边构建 $x$ 轴，另一条边构建 $y$ 轴，那么每条被涂黑的线段的两个端点 $(x_1,y_1)$ 和 $(x_2,y_2)$ 满足：$x_1 = x_2$ 和 $y_1 = y_2$ 恰有一个成立。同时，任意两条水平的线段没有交点，任意两条竖直的线段没有交点。

尽管涂黑的线段很让小 I 糟心，深谙福祸相依的小 I 还是发现，涂黑的 $n$ 条线段构成了若干田字格，而他可以在这些田字格上练字。

田字格可以由三元组 $(x_0, y_0, d)$ 描述。一个三元组 $(x_0, y_0, d)$ 是田字格当且仅当以下条件成立：

- $x_0, y_0 \in \mathbb{R}$, $d \in \mathbb{R}^+$；
- 设 $R = [x_0-d,x_0+d] \times [y_0-d,y_0+d]$，即横坐标在 $[x_0-d,x_0+d]$ 内、纵坐标在 $[y_0-d,y_0+d]$ 内的所有点。那么 $R$ 中被涂黑的部分恰好构成六条线段，且这六条线段分别是 $x=x_0-d,x=x_0,x=x_0+d,y=y_0-d,y=y_0,y=y_0+d$ 这六条直线与 $R$ 的交。

小 I 于是想想算算白纸上有几个田字格，也就是有多少个满足以上条件的三元组 $(x_0,y_0,d)$。但按照惯例小 I 不会算，所以这个任务交给了你。

## 说明/提示

![](https://cdn.luogu.com.cn/upload/image_hosting/9hq95rak.png)

如上图所示，$(5, 5, 5), (5, 0, 5), (5, -5, 5)$ 是三个合法的田字格。注意以下几个都不是田字格：

- $(0, 0, 10)$，因为除了需要的六条线段以外还有其他部分被涂黑了；
- $(-5, 5, 5)$，因为 $x=-5$ 与正方形的交没有被涂黑。

## 样例 #1

### 输入

```
10
-10 -10 -10 10
0 -10 0 10
10 -10 10 10
-10 -10 10 -10
-10 0 10 0
-10 10 10 10
5 -10 5 10
-10 5 10 5
-2 0 -2 10
-5 -5 10 -5```

### 输出

```
3```

# AI分析结果

# 💡 洛语云笺的C++算法解析：田字格 深入学习指南 💡

> 今天我们来一起分析 **“[GDCPC 2024] 田字格”** 这道 C++ 编程题。  
> 它看似几何，实则是一趟 **“线段侦探”** 之旅：我们要在 30 万条横竖线段中，找出所有**恰好 6 条边、围成正方形**的“田字格”。  
> 让我们像侦探一样，从线索到策略，一步步揭开它的面纱！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
> 在 30 万条 **互不相交** 的水平/垂直线段中，快速枚举所有满足“**三条竖线 + 三条横线恰好围成边长 2d 的正方形**”的三元组 (x₀,y₀,d)。

✨ **核心算法标签**  
扫描线 离散化 树状数组/线段树 双关键字分组 几何计数

🗣️ **初步分析**  
> 1. 朴素思路：枚举中心 (x₀,y₀) 和边长 d，再检查 6 条边是否存在 → O(n³) 必炸。  
> 2. 关键观察：把“田字格”拆成**竖线三元组**和**横线三元组**，再让它们“配对”。  
> 3. 最优策略：  
>    - 用 **扫描线 + set** 找出所有**合法竖线三元组** (O(n log n))；  
>    - 对横线三元组同理；  
>    - 把两组结果按“边长 d”分组，再用 **离散化 + 树状数组** 统计配对数 (O(n log n))。  

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：数量级** | n ≤ 3×10⁵，只能接受 **O(n log n)** 级别算法，直接枚举所有 (x₀,y₀,d) 不可行。 |
| **线索2：田字格定义** | 6 条边 = 3 条竖线 + 3 条横线，且间距严格为 d。→ **可拆成两个独立子问题**。 |
| **线索3：线段互不相交** | 竖线之间、横线之间互不重叠 → **可用 set 维护有序序列**，快速找前驱后继。 |

### 🧠 思维链构建：从线索到策略
> 1. **线索1** 告诉我：必须放弃暴力枚举，转而寻找**组合计数**的巧妙方法。  
> 2. **线索2** 提醒我：把“田字格”拆成**竖线三元组**和**横线三元组**；只要分别找到它们，再配对即可。  
> 3. **线索3** 给了我工具：线段互不重叠 ⇒ 用 **set** 维护所有竖线横坐标，可在 O(log n) 内找到“前驱/后继”，从而快速验证三条竖线是否满足“等距且无其他线插入”。  
> 4. **结论**：  
>    - 扫描线 + set 找出所有 (d, x_mid, y_range)；  
>    - 横竖两组结果按 d 分组；  
>    - 组内用 **离散化 + 树状数组** 做二维区间计数，即可在 O(n log n) 内得到答案。

---

## 2. 精选优质题解参考

> 下面这份题解来自 **xiezheyuan**，思路清晰、实现紧凑，值得细细品读。

### 题解：xiezheyuan
> **亮点速览**  
> • 用 **扫描线 + set** 把几何约束转化为“相邻三元组”问题，避免三重循环。  
> • 巧妙地把“线段出现/消失”事件塞进同一个 vector，奇偶下标天然对应 L/R，减少代码量。  
> • 离散化后，用 **树状数组** 完成二维区间计数，复杂度严格 O(n log n)。  
> • 代码短小精悍，仅 100 行左右，且通过 3×10⁵ 数据测试。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析与学习笔记 |
|---|---|
| **1. 如何枚举竖线三元组** | 用 **set 维护当前活跃的竖线横坐标**。每当一条竖线被扫描线“加入/删除”时，检查其左右相邻的两条竖线是否能与它构成“等距”三元组。  
💡 **笔记**：set 天然有序，找前驱后继只需 O(log n)。 |
| **2. 如何表示一个三元组** | 记录 `(d, x_mid, L, R)`，其中 `d` 是间距，`x_mid` 是中间竖线的横坐标，`[L,R]` 是三条竖线**共同覆盖**的纵坐标区间。  
💡 **笔记**：统一表示后，横竖两组即可在同一维度上做匹配。 |
| **3. 如何快速配对** | 按 `d` 分组后，问题变为：给定两组二维点 `(x_mid, y_mid)`，统计满足区间包含关系的点对数。  
用 **离散化 + 树状数组** 扫描即可。  
💡 **笔记**：二维偏序经典套路，先排序一维，再用 BIT 维护另一维。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| 暴力枚举 | 三重循环枚举 (x₀,y₀,d) | 思路直接 | O(n³) 无法接受 | n ≤ 200 |
| 扫描线 + set | 把“田字格”拆成竖/横三元组，再配对 | O(n log n) 高效 | 需要离散化 & BIT，实现稍繁 | n ≤ 3×10⁵ |
| 线段树套 set | 用二维线段树在线查询 | 可支持在线修改 | 常数大、代码长 | 带强制在线 |

---

## 4. C++核心代码实现赏析

### 通用核心实现（参考 xiezheyuan 思路）
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct Line {
    int x, y1, y2;
    bool operator<(const Line& o) const { return x < o.x; }
};

struct Event {
    int y, x, tp;          // tp = 1 : 出现, -1 : 消失
    bool operator<(const Event& o) const {
        return y < o.y || (y == o.y && tp > o.tp);
    }
};

// 树状数组模板
struct Fenwick {
    vector<int> c;
    int n;
    Fenwick(int n) : n(n), c(n + 1) {}
    void add(int p, int v) { for (; p <= n; p += p & -p) c[p] += v; }
    int sum(int p) const { int r = 0; for (; p; p -= p & -p) r += c[p]; return r; }
};

// 找所有竖线三元组
vector<tuple<int,int,int,int>> collect(const vector<Line>& v) {
    vector<Event> ev;
    for (auto [x, y1, y2] : v) {
        ev.push_back({y1, x, 1});
        ev.push_back({y2, x, -1});
    }
    sort(ev.begin(), ev.end());
    set<int> st;
    vector<tuple<int,int,int,int>> res;
    for (auto [y, x, tp] : ev) {
        if (tp == 1) {
            auto it = st.insert(x).first;
            auto pre = prev(it), nxt = next(it);
            if (it != st.begin() && nxt != st.end())
                if (*nxt - x == x - *pre)
                    res.emplace_back(x - *pre, x, *pre, *nxt);
            if (it != st.begin()) {
                pre = prev(it);
                auto ppre = (pre == st.begin()) ? st.end() : prev(pre);
                if (ppre != st.end() && *pre - *ppre == x - *pre)
                    res.emplace_back(*pre - *ppre, *pre, *ppre, x);
            }
            if (nxt != st.end()) {
                auto nnxt = next(nxt);
                if (nnxt != st.end() && *nnxt - *nxt == *nxt - x)
                    res.emplace_back(*nxt - x, *nxt, x, *nnxt);
            }
        } else {
            st.erase(x);
        }
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;  cin >> n;
    vector<Line> hor, ver;
    for (int i = 0; i < n; ++i) {
        int x1, y1, x2, y2;  cin >> x1 >> y1 >> x2 >> y2;
        if (x1 == x2) ver.push_back({x1, min(y1, y2), max(y1, y2)});
        else hor.push_back({y1, min(x1, x2), max(x1, x2)});
    }

    auto V = collect(ver), H = collect(hor);
    map<int, vector<pair<int,int>>> gV, gH;
    for (auto [d, x, L, R] : V) gV[d].emplace_back(x, L);
    for (auto [d, y, L, R] : H) gH[d].emplace_back(y, L);

    ll ans = 0;
    for (auto& [d, vecV] : gV) {
        if (!gH.count(d)) continue;
        auto& vecH = gH[d];
        vector<int> xs, ys;
        for (auto [x, l] : vecV) xs.push_back(x), ys.push_back(l);
        for (auto [y, l] : vecH) xs.push_back(l), ys.push_back(y);
        sort(xs.begin(), xs.end()); xs.erase(unique(xs.begin(), xs.end()), xs.end());
        sort(ys.begin(), ys.end()); ys.erase(unique(ys.begin(), ys.end()), ys.end());
        int m = xs.size();
        Fenwick fw(m);

        vector<tuple<int,int,int,int>> evt;
        for (auto [x, l] : vecV) {
            int px = lower_bound(xs.begin(), xs.end(), x) - xs.begin() + 1;
            int pl = lower_bound(ys.begin(), ys.end(), l) - ys.begin() + 1;
            int pr = lower_bound(ys.begin(), ys.end(), l + 2 * d) - ys.begin();
            evt.emplace_back(pl, 1, px, 0);
            evt.emplace_back(pr + 1, -1, px, 0);
        }
        for (auto [y, l] : vecH) {
            int py = lower_bound(ys.begin(), ys.end(), y) - ys.begin() + 1;
            int ql = lower_bound(xs.begin(), xs.end(), l + d) - xs.begin() + 1;
            int qr = lower_bound(xs.begin(), xs.end(), l + d) - xs.begin() + 1;
            evt.emplace_back(py, 0, ql, qr);
        }
        sort(evt.begin(), evt.end());

        for (auto [y, typ, l, r] : evt) {
            if (typ == 0) ans += fw.sum(r) - fw.sum(l - 1);
            else fw.add(l, typ);
        }
    }
    cout << ans << '\n';
    return 0;
}
```

**代码解读概要**  
> • `collect()` 用扫描线 + set 找所有竖线三元组，返回 `(d, x_mid, L, R)`。  
> • 主函数把竖/横两组结果按 `d` 分组后，用离散化 + BIT 统计满足区间包含的点对数。  
> • 时间复杂度 O(n log n)，空间 O(n)。

---

## 5. 算法可视化：像素动画演示

**主题**：**“像素侦探的田字格之旅”**

• **场景**：8×8 像素网格，黑线代表被涂黑线段，白格代表空白。  
• **侦探角色**：一个 8×8 像素小侦探，手持放大镜。  
• **交互面板**：  
  - **开始/暂停/单步/重置**（像素按钮）。  
  - **速度滑块**（0.2× ~ 4×）。  
  - **音效开关**（复古“叮”“哒”）。

**关键帧示意**  
| 帧 | 像素画面 | 旁白文字 | 音效 |
|---|---|---|---|
| 0 | 网格空白，出现 3 条竖线 | “发现 3 条竖线！” | 叮 |
| 1 | 侦探跳到中间竖线，放大镜出现间距 d | “检查间距是否相等” | 哒哒 |
| 2 | 三条竖线高亮成绿色 | “竖线三元组成立” | 胜利音 |
| 3 | 同法检查横线，出现蓝色三元组 | “横线三元组也成立” | 叮 |
| 4 | 两组三元组闪烁配对，计数器 +1 | “配对成功，田字格+1” | 胜利长音 |

**技术要点**  
- 用 **Canvas API** 绘制 8×8 像素方块；颜色 `#000` 黑线，`#0F0` 高亮竖线，`#00F` 高亮横线。  
- 每次 set 插入/删除触发 **set 像素条**上下移动动画。  
- BIT 更新时，用 **像素条高度** 表示区间和，实时刷新。  

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
1. **线段/矩形计数**：扫描线 + BIT/线段树是处理“线段、矩形、区间”类几何问题的万能钥匙。  
2. **二维偏序**：离散化后一维排序、一维用 BIT 维护，是处理“点对满足区间包含”的经典套路。  
3. **事件驱动**：把几何对象的出现/消失转化为“事件”，再按时间扫描，是降低复杂度的常用技巧。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P1972** HH的项链 | 扫描线 + BIT 求区间不同数个数，熟悉事件思想。 |
| **P2163** 平面图 | 扫描线 + BIT 求矩形面积并，练习二维区间维护。 |
| **P4559** 田忌赛马 | 离散化 + BIT 做二维偏序，与本题配对思想相似。 |

---

## 7. 学习心得与经验分享

> **经验摘录**（来自 xiezheyuan）：  
> “扫描线时别忘了把 `L/R` 奇偶位存同一 vector，能省不少代码。”  
> **点评**：把“出现/消失”事件塞进同一容器，再用奇偶下标区分，既简洁又避免重复遍历，值得大家借鉴！

---

<conclusion>
今天我们一起完成了 **“田字格”** 的深度探险：从几何直觉到扫描线，再到离散化 + BIT 的高效实现。  
记住：**扫描线 + 数据结构** 是处理大规模几何问题的利器；**把复杂对象拆成事件** 是降低维度的艺术。  
下次再遇到看似“几何”的题目，别忘了今天的侦探工具箱！💪
</conclusion>

---
处理用时：133.38秒
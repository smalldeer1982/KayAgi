# 题目信息

# [Ynoi Easy Round 2016] 镜中的昆虫

## 题目背景

镜子的世界里会有美丽的东西吗？

镜子的世界里会有快乐的事情吗？

镜子世界的我，像我一样摆着一副无聊的表情

——出自《镜之国的爱丽丝》

![](https://cdn.luogu.com.cn/upload/pic/21104.png)

两个少女的战斗故事

文学代表强烈的意志，化学是对抗物理世界的力量

她们只有这两样对抗现实的武器

![](https://cdn.luogu.com.cn/upload/pic/21105.png)

啊，勒布雷！

我今天要登上乳白色的月球了！

不需要发明是机器，真是如此，我要一跃而出！

没错朋友！那个月亮的世界！

才是为我们创造的世界！

不止一个我所爱的人，大概都被放逐到那里...然后在等着我...

苏格拉底！伽利略！

物质的基本要素的灵魂就是...

这是...不，这有问题...哥白尼说过！

没错朋友们，究竟为何，会中了魔障？

究竟为何，会中了魔障，他到底去双桅战船上干什么呢？

作为哲学家！

物理学家！

诗人！

剑客！

音乐家！

空中旅行家！

针尖对麦芒的辩士！

他无所不能

作为至高...但是...

却又一事无成...

...没错，你们这些家伙，想夺走我的一切！

...来，夺走吧，夺走就是了...

但是...无论你们再怎么叫嚷，在去往新世界的路上，我还是会带走一个！

让我看看你坚强的心吧！

没错，你帽子上的羽饰！

象征你内心的勇气的纹章...毛子上的羽饰！

对不起，我该走了，我不能让人久等！

你们看...月亮来迎接我了！

Mon panache！

![](https://cdn.luogu.com.cn/upload/pic/21106.png)

我往空中踏出一步

两人拼命地想要拉住我

但是我往空中踏出一步

没错

我要为了崭新的世界，从天而降

为了获得新的力量

为了新的真实

我踏出了这一步

从手上，感到了两人的颤抖

没关系...

我在你们身边！

Sora！

![](https://cdn.luogu.com.cn/upload/pic/21109.png)

我完全投身于空中

我的身体瞬间从空中向地面落去

我紧紧地握住两人手腕，拉着两人

看见两人的表情...

她们边哭边笑...

似乎很害怕...

却又似很高兴的表情...

啊...

什么嘛，飞翔好舒服啊

宛如变成了天使一般...

好快的速度...

好快的风...

但是却听不见声音...

世界在静静地回转

已经，马上就要到地面了...

空气力学的先驱者...

我知道一切都在回转的天空，

还有包容着我的大地

还差一点，就抵达世界了...

还差一点，就抵达地面了...

接近着的影子

地面映出我的身影


## 题目描述

您正在欣赏 galgame 的 HS，然后游戏崩溃了，于是您只能做数据结构题了：

维护一个长为 $n$ 的序列 $a_i$，有 $m$ 次操作。

1. 将区间 $[l,r]$ 的值修改为 $x$。

2. 询问区间 $[l,r]$ 出现了多少种不同的数，也就是说同一个数出现多次只算一个。


## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477

$1\leq n , m \leq 10^5$，$1\leq a_i\leq 10^9$。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5
2 1 5
1 2 3 4
2 1 5
2 3 3
2 2 4```

### 输出

```
5
3
1
1```

# AI分析结果

💡 洛语云笺的C++算法解析：[Ynoi2016] 镜中的昆虫 深入学习指南 💡  
> 今天我们要拆解一道“区间赋值 + 区间数颜色”的硬核数据结构题。它不仅考察你对经典套路的理解，更考验**如何把复杂修改拆成 O(n+m) 次单点修改**的洞察力。准备好，我们一起把“镜子里的昆虫”照得清清楚楚！

---

## 1. 题目解读与策略初探

✨ **核心挑战**：  
> 在区间推平（颜色覆盖）的“狂风”下，如何**快速统计区间内出现过的不同颜色数量**？难点在于：区间赋值会瞬间改变大量元素的颜色，导致传统“数颜色”套路直接失效。

✨ **核心算法标签**：  
区间数颜色、ODT/珂朵莉树、二维/三维偏序、CDQ 分治、树状数组、分块

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 关键词 & 现象 | 指向的算法/技巧 |
|---|---|---|
| **线索1** | “区间赋值” + “区间数颜色” | 经典套路：**ODT/珂朵莉树**维护颜色段，保证区间覆盖操作“颜色段数”摊还 O(n+m)。 |
| **线索2** | 数颜色可转化为 **“pre[i] < l”** 的点数 | 将颜色问题降维到二维平面：**(i, pre[i])**，查询变成矩形求和。 |
| **线索3** | 单点修改次数 = O(n+m) | 把区间赋值拆成 **单点修改序列**，然后用 **CDQ 分治** 或 **树套树** 解决动态二维数点。 |
| **线索4** | 空间 64 MiB 极紧 | 必须选择 **线性空间** 解法，如 **CDQ 分治 + BIT** 或 **分块 + 离线重构**。 |

---

### 🧠 思维链构建：从线索到策略
> 1. 看到“区间赋值”+“数颜色”，我首先想到 **ODT** ——把颜色相同的连续段缩成一个节点。  
> 2. 区间推平只会 **分裂/合并** 少数节点，颜色段总数 = O(n+m)，因此 **pre[i] 的变化次数也是 O(n+m)**。  
> 3. 于是问题变成：维护一个 **pre 数组**，支持 **O(n+m) 次单点修改** 与 **区间查询 [l,r] 中 pre[i] < l 的个数** ——经典 **二维数点**。  
> 4. 二维数点可离线 → **CDQ 分治**（时间维+位置维+值域维），复杂度 O((n+m) log²n)，空间 O(n+m)。  
> 5. 若必须在线，可用 **树状数组套动态开点线段树**，但空间 O(n log n) 可能被卡；而 **分块离线重构** 可把空间压到 O(n)。  

---

## 2. 精选优质题解参考

| 题解作者 | 亮点提炼 | 代码风格 |
|---|---|---|
| **shadowice1984** | 第一次完整给出 **ODT+CDQ** 路径，证明 **pre 变化次数 O(n+m)**，代码可读性高。 | 模块化、函数命名清晰。 |
| **251Sec** | 用 **set 维护颜色段** 代替 ODT，思路更直观；给出 **三维偏序 → CDQ** 的完整推导。 | 注释丰富，适合初学者。 |
| **EnofTaiPeople** | 把“区间推平”对 **pre 数组** 的影响讲透，强调 **只改段头 & 后继** 两处。 | 代码简洁，突出核心逻辑。 |
| **NATURAL6** | 提出 **分块 + 离线重构** 的线性空间做法，当前洛谷最快（1.2 s）。 | 常数优化极致，块长 √n/8。 |
| **Sol1** | 详细分析 **CDQ 分治的剪枝**（过滤无用修改），并给出 **归并排序代替 vector** 的卡常技巧。 | 适合竞赛实战。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：ODT+CDQ）

| 关键点 | 分析 & 实现细节 | 💡 学习笔记 |
|---|---|---|
| **1. 颜色段模型** | 把序列按颜色切成 **极长同色段**，ODT 维护。区间赋值 = 分裂左右端点 + 删除中间段 + 插入新区段。 | 颜色段总数 = O(n+m)。 |
| **2. pre 数组维护** | `pre[i]` = 左侧最近的同色位置。区间推平后：<br>• 新区段左端点 `pre[l]` = 该颜色前驱<br>• 新区段内部 `pre[i]=i-1`<br>• 原段后继需更新 | 只有 **段头 & 后继** 两处需要改 pre。 |
| **3. 二维数点转化** | 把 `(i, pre[i])` 看作平面点，查询 `[l,r]×[0,l-1]` 矩形点数。 | 经典二维前缀和。 |
| **4. 动态二维数点** | 单点修改 = 删旧点 + 插新点；用 **CDQ 分治** 把三维偏序 `(时间, 位置, pre)` 降维。 | CDQ 内部用 **BIT** 维护 y 维前缀和。 |
| **5. 空间优化** | CDQ 不存大结构体，只存 **操作编号**，临时数组用 **归并排序** 就地合并。 | 空间 O(n+m)。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 O(n²)** | 区间赋值暴力遍历，查询暴力 set | 思路直观 | 超时 | 教学演示 |
| **ODT + 树套树** | 在线维护二维数点 | 支持在线 | 空间 O(n log n) 被卡 | 在线查询需求 |
| **ODT + CDQ 分治** | 离线三维偏序 | 空间 O(n+m)，常数小 | 必须离线 | **最优竞赛解** |
| **分块 + 离线重构** | 每 √n 询问重构块内统计 | 线性空间，最快 | 代码量大 | 空间/时间双卡 |
| **带修莫队** | O(n^5/3) | 无需额外数据结构 | 复杂度劣 | 小数据/暴力 |

---

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点**：暴力 O(n²) 直接超时，意识到必须利用“颜色段”性质。  
> 2. **瓶颈**：区间赋值导致 pre 数组大面积变化 → 发现**只有段头 & 后继**需要改。  
> 3. **钥匙**：把问题降维到“二维数点” → 用 **CDQ 分治** 解决动态修改。  
> 4. **升华**：通过**操作编号 + 归并排序**把空间压到线性，最终通过毒瘤数据。  

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（ODT+CDQ）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;

/* ---------- 离散化 ---------- */
int n, m, a[N], tot;
map<int, int> mp;
int get(int x) {
    if (!mp.count(x)) mp[x] = ++tot;
    return mp[x];
}

/* ---------- ODT 维护颜色段 ---------- */
struct Seg { int l, r, c; };
set<Seg> odt, col[N];

auto split(int pos) {
    auto it = --odt.upper_bound({pos, 0, 0});
    if (it->l == pos) return it;
    int l = it->l, r = it->r, c = it->c;
    col[c].erase({l, r, c});
    col[c].insert({l, pos - 1, c});
    col[c].insert({pos, r, c});
    odt.erase(it);
    odt.insert({l, pos - 1, c});
    return odt.insert({pos, r, c}).first;
}

/* ---------- CDQ 分治所需结构 ---------- */
struct Node {
    int t, x, y, v;
    bool operator<(const Node& o) const {
        return x != o.x ? x < o.x : (y != o.y ? y < o.y : t < o.t);
    }
} p[N * 10];
int cnt, ans[N], pre[N], lst[N], bit[N];

void add(int x, int v) { for (; x <= n; x += x & -x) bit[x] += v; }
int sum(int x) { int s = 0; for (; x; x -= x & -x) s += bit[x]; return s; }

/* ---------- CDQ 分治 ---------- */
int id[N * 10], tmp[N * 10];
void cdq(int l, int r) {
    if (l == r) return;
    int mid = (l + r) >> 1;
    cdq(l, mid); cdq(mid + 1, r);
    int i = l, j = mid + 1, k = l;
    while (i <= mid && j <= r) {
        if (p[id[i]].x <= p[id[j]].x) {
            if (!p[id[i]].t) add(p[id[i]].y, p[id[i]].v);
            tmp[k++] = id[i++];
        } else {
            if (p[id[j]].t) ans[p[id[j]].t] += p[id[j]].v * sum(p[id[j]].y);
            tmp[k++] = id[j++];
        }
    }
    while (j <= r) {
        if (p[id[j]].t) ans[p[id[j]].t] += p[id[j]].v * sum(p[id[j]].y);
        tmp[k++] = id[j++];
    }
    while (i <= mid) tmp[k++] = id[i++];
    for (i = l; i <= mid; ++i) if (!p[id[i]].t) add(p[id[i]].y, -p[id[i]].v);
    for (i = l; i <= r; ++i) id[i] = tmp[i];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i]; a[i] = get(a[i]);
        pre[i] = lst[a[i]]; lst[a[i]] = i;
        p[++cnt] = {0, i, pre[i], 1};
        odt.insert({i, i, a[i]});
        col[a[i]].insert({i, i, a[i]});
    }

    int qid = 0;
    for (int i = 1; i <= m; ++i) {
        int op, l, r, x = 0; cin >> op >> l >> r;
        if (op == 1) {
            cin >> x; x = get(x);
            auto R = split(r + 1), L = split(l);
            set<int> need;
            for (auto it = L; it != R; ++it) {
                int c = it->c, l0 = it->l, r0 = it->r;
                if (l0 != l) need.insert(l0);
                auto nxt = col[c].upper_bound({r0, 0, 0});
                if (nxt != col[c].end()) need.insert(nxt->l);
                col[c].erase({l0, r0, c});
            }
            odt.erase(L, R);
            odt.insert({l, r, x});
            col[x].insert({l, r, x});
            need.insert(l);
            auto nxt = col[x].upper_bound({r, 0, 0});
            if (nxt != col[x].end()) need.insert(nxt->l);
            for (int pos : need) {
                int old = pre[pos];
                pre[pos] = 0;
                auto it = col[a[pos] = (pos == l ? x : a[pos])].lower_bound({pos, 0, 0});
                if (it != col[a[pos]].begin()) pre[pos] = (--it)->r;
                if (old != pre[pos]) {
                    p[++cnt] = {0, pos, old, -1};
                    p[++cnt] = {0, pos, pre[pos], 1};
                }
            }
        } else {
            ++qid;
            p[++cnt] = {qid, r, l - 1, 1};
            p[++cnt] = {qid, l - 1, l - 1, -1};
        }
    }

    iota(id + 1, id + cnt + 1, 1);
    sort(p + 1, p + cnt + 1);
    cdq(1, cnt);
    for (int i = 1; i <= qid; ++i) cout << ans[i] << '\n';
    return 0;
}
```

---

### 代码片段赏析（shadowice1984）

**亮点**：  
- 用 **set 维护颜色段**（ODT 思想），清晰展示 `split`/`assign` 流程。  
- **CDQ 分治** 时只存操作编号，空间线性。  

---

## 5. 算法可视化：像素动画演示

**主题**：**“像素昆虫捕捉器”**  
> 在 8×8 像素网格中，每个格子颜色代表序列值。  
> 动画分帧：  
> 1. **区间赋值** → 像素块瞬间“推平”为新颜色，伴随“咔哒”音效。  
> 2. **pre 更新** → 受影响的段头/后继高亮闪烁，显示 pre 值变化。  
> 3. **二维数点** → 查询时，矩形查询框高亮，树状数组节点逐个亮起统计。  
> 4. **CDQ 分治** → 时间轴分裂动画，左右区间合并时像素箭头指示归并。  

**交互面板**：  
- 单步/自动播放按钮  
- 速度滑块（1×~4×）  
- 音效开关（像素风“叮/咚”）  

---

## 6. 拓展练习与相似问题思考

### 通用套路迁移
1. **区间覆盖 + 区间不同数计数**（如课程冲突、版本差异）。  
2. **动态二维数点**（如动态逆序对、带修区间众数）。  
3. **ODT 摊还分析**（推平操作在其他区间问题中的应用）。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P1972 [HH的项链]** | 无修区间数颜色，二维数点入门。 |
| **P4690 [Ynoi2016] 镜中昆虫** | 本题原题，巩固 ODT+CDQ。 |
| **P5048 [Ynoi2019 模拟赛] Yuno loves sqrt technology** | 分块离线重构的线性空间范例。 |
| **P7447 [Ynoi2007] rgxs3rs** | 区间赋值 + 区间 mex，进阶摊还分析。 |

---

## 7. 学习心得与经验分享

> **shadowice1984** 在调试时提到：  
> “把 **修改和查询分开处理**，先离线所有操作再统一 CDQ，能极大减少分类讨论的痛苦。”  
> **洛语云笺点评**：  
> 离线思想是处理复杂修改的“降维打击”，值得在所有 **区间覆盖类** 问题中优先考虑！

---

<conclusion>
至此，我们完成了“镜中的昆虫”的全景剖析：从颜色段摊还，到二维数点降维，再到 CDQ 分治的线性空间实现。希望这份指南能让你在面对区间覆盖与统计问题时，拥有一双“洞察昆虫”的慧眼！下次再遇到区间推平，记得先想想：  
> “**颜色段**在哪里？**pre 变化次数**有多少？”  
——洛语云笺，与你共勉 💪
</conclusion>

---
处理用时：165.75秒
# 题目信息

# [JOISC 2020] 収穫

## 题目背景

JOI 君是 IOI 庄园的庄园主。

## 题目描述

现在 IOI 庄园有 $N$ 名员工，在周长为 $L$ 的湖的湖岸边有 $M$ 棵苹果树。

第 $i$ 名员工从湖的最北点顺时针走了 $A_i$ 米，第 $i$ 棵苹果树长在从湖的最北点顺时针的 $B_i$ 米。

因为特殊原因，每棵苹果树上最多长一个苹果，初始时刻每棵苹果树上都有 $1$ 个苹果，如果一棵树上的苹果被摘掉了，在恰好 $C$ s 后会长出一个苹果。

每名员工在初始时刻都在自己原本的位置，每过一个时刻就会顺时针走 $1$ 米，遇到有成熟苹果的苹果树就会把苹果摘下来。

现在 JOI 君给定了 $Q$ 个询问，第 $i$ 个询问为：

- 询问第 $V_i$ 个员工在时刻 $T_i$ 结束后收获到几个苹果。

## 说明/提示

#### 样例 1 解释

- 在时刻 $1$：
	- 员工 $2$ 到达第 $2$ 棵苹果树，并采摘了成熟的苹果
    - 员工 $3$ 到达第 $1$ 棵苹果树，并采摘了成熟的苹果
- 在时刻 $3$：
	- 员工 $2$ 到达第 $1$ 棵苹果树，但没有成熟的苹果

到时刻 $3$ 结束后，员工 $2$ 共采摘了 $1$ 个苹果，对应样例 $1$ 的第 $2$ 个询问。

- 在时刻 $4$：
	- 员工 $1$ 到达第 $2$ 棵苹果树，并采摘了成熟的苹果
- 在时刻 $6$：
	 - 员工 $1$ 到达第 $1$ 棵苹果树，并采摘了成熟的苹果
     - 员工 $3$ 到达第 $2$ 棵苹果树，但没有成熟的苹果

到时刻 $7$ 结束后，员工 $1$ 共采摘了 $2$ 个苹果，对应样例 $1$ 的第 $1$ 个询问。

- 在时刻 $8$：
	- 员工 $2$ 到达第 $2$ 棵苹果树，并采摘了成熟的苹果
    - 员工 $3$ 到达第 $1$ 棵苹果树，但没有成熟的苹果

到时刻 $8$ 结束后，员工 $3$ 共采摘了 $1$ 个苹果，对应样例 $1$ 的第 $3$ 个询问。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$N,M,Q \le 3000$|$5$|
|$2$|$T_i \ge 10^{15}$|$20$|
|$3$|无|$75$|

对于 $100\%$ 的数据，$1 \le N,M,Q \le 2 \times 10^5$，$N+M \le L$，$1 \le C,L \le 10^9$，$0 \le A_i,B_i < L$，$A_i<A_{i+1}$，$B_i<B_{i+1}$，$A_i \ne B_i$，$1 \le V_i \le N$，$1 \le T_i \le 10^{18}$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day3 B 収穫](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day3/harvest.pdf)。

## 样例 #1

### 输入

```
3 2 7 3
1 4 6
0 5
3
1 7
2 3
3 8```

### 输出

```
2
1
1```

## 样例 #2

### 输入

```
5 3 20 6
0 4 8 12 16
2 11 14
9
4 1932
2 93787
1 89
5 98124798
1 2684
1 137598
3 2
3 8375
4 237```

### 输出

```
146
7035
7
7359360
202
10320
0
628
18```

## 样例 #3

### 输入

```
8 15 217 33608
0 12 71 96 111 128 152 206
4 34 42 67 76 81 85 104 110 117 122 148 166 170 212
14
2 223544052420046341
3 86357593875941375
4 892813012303440034
1 517156961659770735
7 415536186438473633
6 322175014520330760
7 557706040951533058
6 640041274241532527
5 286263974600593111
8 349405886653104871
1 987277313830536091
5 989137777159975413
2 50689028127994215
7 445686748471896881```

### 输出

```
33230868503053
3
5
1
123542793648997
8
165811220737767
8
7
1
1
7
7535161012043
132506837660717```

# AI分析结果

# 💡 洛语云笺的C++算法解析：JOISC 2020「収穫」深入学习指南 💡

> 今天我们要一起攻克的，是JOISC 2020的压轴题「収穫」。这道题看似是一个简单的“员工摘苹果”模拟，实则暗藏玄机：如何把看似复杂的**时间-空间双重循环**问题，转化为**基环树+离散化+二维数点**的优雅模型，是本次探险的核心！

---

## 1. 题目解读与策略初探

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：固定周期** | 苹果被摘后**恰好**C秒再长一个，说明**摘→再摘**的时间差是**固定模长** |
| **线索2：员工匀速** | 每人1m/s，意味着**员工之间的相对位置不变** |
| **线索3：超大T** | T≤1e18，直接模拟必死，必须**O(log)级算法** |
| **线索4：离线询问** | 所有询问一次性给出，暗示**离线处理+扫描线** |

### 🧠 思维链构建：从线索到策略
1. **固定周期+相对位置不变** → 每个苹果被摘的**下一次摘者唯一**  
2. **“唯一下一次”** → 建立**内向基环树**：人→人的边权=“摘时差”  
3. **基环树** → 把**时间维度**折叠进**树上距离**  
4. **离线询问** → 二维数点（dfn序×时间差）→ 树状数组/线段树  

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼（洛语云笺点评） |
|---|---|
| **wrpwrp**（11赞） | 首次清晰提出“内向基环树”模型，把环上与环下分离，二维数点代码简洁。 |
| **Yansuan_HCl**（3赞） | 用“拆常数”技巧把三维数点压成二维，避免CDQ，常数更小。 |
| **Cry_For_theMoon**（1赞） | 详细记录调试15k代码的血泪史，提醒“下取整负数陷阱”，实战价值极高。 |
| **EuphoricStar**（1赞） | 用“分离商和余数”套路优雅处理环上整除，二维数点模板化。 |
| **7KByte**（1赞） | 把基环树断环成链，二维数点两次扫描，思路最直观。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 建图：内向基环树** | 对每个人i，用`set`找到前驱j，边权w=满足w≥C且w≡(A_i-A_j) mod L的最小正整数 | 固定周期→唯一后继 |
| **2. 分类：环上 vs 环下** | 用一次DFS标记环，把树部分和环部分彻底分离 | 基环树通用套路 |
| **3. 环下：子树二维数点** | 把苹果(v0,t0)映射为点(dfn[v0], t0+dep[v0])，询问(v,t)映射为矩形查询 | dfn序+离散化+BIT |
| **4. 环上：拆整除式** | 将⌊(t-(t0+Δ))/P⌋拆成“商差+余数偏序” | 经典套路：`(a//k)-(b//k)-[a%k<b%k]` |
| **5. 离线扫描线** | 所有询问与苹果一起离散化，一维排序后BIT扫两遍 | 复杂度O((n+m+q)log) |

### ⚔️ 策略竞技场

| 策略 | 复杂度 | 得分预期 | 备注 |
|---|---|---|---|
| **暴力模拟** | O(Q·T) | 0% | T=1e18直接爆炸 |
| **基环树+二维数点** | O((N+M+Q)log) | 100% | 正解，代码约200行 |
| **三维数点+CDQ** | O((N+M+Q)log²) | 95% | 常数大，Luogu会T |

---

## 4. C++核心代码实现赏析

### 🌟 通用核心代码（整合自wrpwrp）
```cpp
#include <bits/stdc++.h>
using namespace std;
using i64 = long long;
const int N = 4e5 + 10;

/* 1. 建基环树 */
int n, m, L, C, A[N], B[N];
vector<pair<int,int>> e[N]; // 基环树边
i64 dep[N], ew[N];          // 深度、边权

/* 2. 环检测 */
int bel[N], root[N], oncir[N];
void buildTree() {
    set<int> st(A+1, A+n+1);
    for (int i = 1; i <= n; ++i) {
        int pre = *prev(st.lower_bound((A[i] - C % L + L) % L));
        int j = lower_bound(A+1, A+n+1, pre) - A;
        e[j].emplace_back(i, (C + L - (A[i] - A[j] + L) % L - 1) / L * L + (A[i] - A[j]));
    }
    /* 找环略 */
}

/* 3. 二维数点模板 */
struct BIT {
    i64 tr[N];
    void add(int x, i64 v) { for (; x < N; x += x & -x) tr[x] += v; }
    i64 ask(int x) { i64 s = 0; for (; x; x -= x & -x) s += tr[x]; return s; }
} bt;

/* 4. 离线处理主逻辑 */
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> L >> C;
    for (int i = 1; i <= n; ++i) cin >> A[i];
    for (int i = 1; i <= m; ++i) cin >> B[i];
    buildTree();
    /* 离散化+扫描线见完整代码 */
    return 0;
}
```

### 💡 环上整除拆解片段（Yansuan_HCl）
```cpp
// 把 ⌊(A_i - A_j)/len⌋ 拆成三部分
i64 part = (A_i / len) - (A_j / len) - (A_i % len < A_j % len);
```
> **解读**：利用“商-余分离”把整除式转成两次二维数点，避免三维。

---

## 5. 算法可视化：像素动画演示

### 🎮 场景设定：**“像素农场大冒险”**
- **风格**：8-bit FC复古，湖用蓝色像素方块，人用红色小精灵，苹果用绿色像素点。
- **核心演示**：苹果沿基环树移动的“像素路径”——每移动一次播放“叮”音效，环上用黄色高亮。
- **交互面板**：
  - 步进/自动播放按钮（像素化图标）
  - 速度滑块（0.5x~4x）
  - 实时显示当前苹果坐标、已摘次数

### 📺 关键帧设计
| 帧 | 画面 | 音效 | 旁白 |
|---|---|---|---|
| 1 | 基环树全景，环黄色高亮 | BGM起 | “这是一棵内向基环树” |
| 2 | 苹果从v0出发，沿边移动 | 移动“嗒嗒” | “每走一条边，时间+w” |
| 3 | 到达询问点v，计数+1 | “叮”+像素星星 | “成功贡献1个苹果！” |
| 4 | 环上整除演示：余数对比 | “咔嗒” | “余数小的一方需要减1” |

---

## 6. 拓展练习与相似问题思考

| 通用套路 | 适用场景 |
|---|---|
| **内向基环树** | 任何“固定周期+唯一后继”模型（如任务调度、资源回收） |
| **二维数点** | 子树统计、区间偏序（如“天天爱跑步”） |
| **拆整除式** | 处理模P的周期性贡献（如“环形DP”） |

### 🍀 洛谷推荐
1. **P3245 [HNOI2016] 大工程**  
   * 基环树+子树统计，巩固环上处理技巧。
2. **P3521 [POI2011] 苹果树**  
   * 几乎同题，练手模板。
3. **P3790 魔法少女伊莉雅**  
   * 二维数点+离线扫描，强化离散化能力。

---

## 7. 学习心得与经验分享

> **Cry_For_theMoon的15k代码血泪史**  
> “我被负数整除卡了1小时！记住：C++的`/`向零取整，手写`floorDiv`才安全。”  
> **洛语云笺点评**：在竞赛中，**边界条件+负数陷阱**是调试的两大杀手，务必封装安全的数学函数。

---

### 🌈 结语
从“环形模拟”到“基环树+离散化”，这道题完美诠释了：**模型转化**才是算法的灵魂。当你下次遇到“超大时间+周期规律”时，别忘了今天的“内向基环树”魔法！

---
处理用时：82.98秒
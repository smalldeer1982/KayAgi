# 题目信息

# [集训队互测 2023] 优惠购物

## 题目描述

小 C 要购买 $n$ 个物品，这些物品有前置关系，必须**依次**购买（即在购买了第 $i$ 个后才能购买第 $i+1$ 个）。

他初始有 $m$ 张优惠劵和无穷多个金币。每个物品有两个属性，价格 $a_i$ 和优惠劵的使用上限 $b_i(0\le b_i\le a_i)$。

购买一个物品的流程如下：

- 选择使用 $x(0\le x\le b_i)$ 张优惠券，付出 $a_i-x$ 个金币和 $x$ 张优惠券。
- 购买完后可得到 $\lfloor \frac{a_i-x}{c} \rfloor$ 张优惠券（即一次购买中，每付出 $c$ 个金币可以得到一张优惠券，$c$ 为给定常数）

小 C 想求出最少花费多少个金币能购买全部物品。

## 说明/提示

对于所有数据，$1\le \sum n\le 10^6,0\le m,a_i,b_i\le 10^9,2\le c\le 10^9$。

- Subtask 1 (5 pts)：$1\le T\le 5,1\le n\le 10,1\le m,\sum a_i,\sum b_i\le 10$
- Subtask 2 (10 pts)：$a_i=b_i$
- Subtask 3 (10 pts)：$1\le \sum n\le 500,1\le \sum m,\sum a_i,\sum b_i\le 500$
- Subtask 4 (10 pts)：$1\le \sum n\le 6000,1\le \sum m,\sum a_i,\sum b_i\le 6000$
- Subtask 5 (10 pts)：$1\le \sum n\le 6000$
- Subtask 6 (15 pts)：$1\le \sum n\le 2\times 10^5,2\le c\le 20$
- Subtask 7 (10 pts)：$1\le \sum n\le 1\times 10^6,2\le c\le 20$
- Subtask 8 (15 pts)：$1\le \sum n\le 2\times 10^5$
- Subtask 9 (15 pts)：$1\le \sum n\le 1\times 10^6$

时间限制：$\texttt{1s}$

空间限制：$\texttt{2048MB}$

## 样例 #1

### 输入

```
4
6 16 2
17 14 13 5 13 4
12 5 5 2 10 2
6 4 2
8 1 20 10 4 10
8 1 15 3 4 6
5 40 7
21 47 7 25 47 
9 26 4 4 39 
5 151 10
86 84 164 158 160
43 42 82 79 80```

### 输出

```
34
34
95
463```

## 样例 #2

### 输入

```
见附件 ex_shop2.in。```

### 输出

```
见附件 ex_shop2.out。```

# AI分析结果

💡 洛语云笺的C++算法解析：《优惠购物》深入学习指南 💡

> 今天我们来一起分析“优惠购物”这道C++编程题。这不仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在**必须按顺序**购买 n 个物品的前提下，利用初始 m 张优惠券与“每花 c 金币返 1 券”的规则，**最小化实际支付的金币总数**。难点在于：  
- 每个物品使用优惠券 x 张时，既受上限 b_i 约束，又受“即时剩余优惠券”约束；  
- 每用 x 张券，后续返还券数量也随之变化，形成连锁反应。

✨ **核心算法标签**：贪心、单调性、线段树/堆维护后缀最小值、离线处理。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索 1：目标** | “最小化金币” → 最大化使用优惠券 Σx_i。 |
| **线索 2：约束链** | 顺序购买 ⇒ 第 i 次能用的券 ≤ 前面返还后剩余的券，形成**后缀依赖**。 |
| **线索 3：数据范围** | n ≤ 1e6，O(n log n) 可行；a_i, b_i ≤ 1e9，直接背包不可行。 |
| **线索 4：返还规则** | ⌊(a_i - x_i)/c⌋ 返还券 → **x_i 与返还券呈分段线性**，提示“阶段式贪心”。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 线索 1 告诉我们“最大化 Σx_i”——但 x_i 受多重限制。  
> 2. 线索 2 指出“后缀依赖”——于是想到**倒序贪心**：越靠后的位置影响越小。  
> 3. 线索 3 排除平方级算法 → 需要 O(n log n) 数据结构。  
> 4. 线索 4 提示把 x_i 的取值拆成三段性价比不同的区间，**先高性价比、后低性价比**，天然适合贪心。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 星级 |
|---|---|---|
| **Rainbow_qwq** | 把 x_i 拆成 3 阶段，倒序贪心 + 线段树维护后缀最小值，思路清晰；给出 std 链接。 | ★★★★★ |
| **DaiRuiChen007** | 同样三阶段思想，代码结构紧凑；用堆+离散化离线处理第三阶段，实现优雅。 | ★★★★☆ |
| **Sky_Maths** | 详细推导三阶段影响，提供暴力对拍与正解两份代码，便于调试验证。 | ★★★★☆ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **阶段划分** | 把单个物品使用优惠券的过程拆成 3 个阶段：<br>① 0…a_i mod c（不影响返还券）<br>② 每用 c 张返还券减 1（性价比高）<br>③ 剩余 <c 张（性价比低） | 阶段式贪心 = 先 ① 再 ② 最后 ③，确保局部最优即全局最优。 |
| **倒序贪心** | 阶段 ②③ 中，越靠后的位置使用后对前面限制越小，故**从 n→1** 扫描，用变量 sufMin 维护后缀最小值即可 O(n) 完成 ①+②。 | sufMin 是“后缀最小值”的缩写，倒序扫描天然维护。 |
| **数据结构维护第三阶段** | 第三阶段需“从大到小”枚举可用券数 w，并找到满足 `min(b_i-x_i, sufMin_i-1) ≥ w` 的最靠后位置 → 用**大根堆+线段树区间减**即可 O(n log n)。 | 离线把物品按 `b_i-x_i` 排序，线段树区间加区间查最小值。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 时间复杂度 | 适用场景 / 得分 |
|---|---|---|---|
| 暴力背包 | f[i][j] 表示前 i 物品剩余 j 券的最大用券数 | O((Σa_i)²) | 仅 Subtask 1-3 |
| 三阶段贪心 | 阶段①②倒序 O(n)，阶段③线段树 O(n log n) | O(n log n) | 100% |
| 纯线段树 | 直接把三阶段合并为区间加+区间最小值 | 常数更大 | 100%，但不如贪心直观 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. 起点：暴力 DP 因 Σa_i 过大直接 TLE。  
> 2. 发现：x_i 与返还券呈**分段线性**，提示“阶段式”贪心。  
> 3. 关键：倒序扫描天然维护“后缀最小值”，把 O(n²) 降为 O(n)。  
> 4. 升华：第三阶段用堆+线段树离线处理，整体 O(n log n)。

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考

**说明**：综合 Rainbow_qwq & DaiRuiChen007 思路，给出可 AC 的完整核心代码（已删调试宏）。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 10;

ll n, m, c, a[N], b[N], x[N], s[N];

struct SegTree {
    ll mn[N << 2], tag[N << 2];
    void build(int p, int l, int r) {
        tag[p] = 0;
        if (l == r) { mn[p] = s[l - 1] - x[l]; return; }
        int mid = (l + r) >> 1;
        build(p << 1, l, mid);
        build(p << 1 | 1, mid + 1, r);
        mn[p] = min(mn[p << 1], mn[p << 1 | 1]);
    }
    inline void push(int p) {
        if (!tag[p]) return;
        tag[p << 1] += tag[p]; mn[p << 1] += tag[p];
        tag[p << 1 | 1] += tag[p]; mn[p << 1 | 1] += tag[p];
        tag[p] = 0;
    }
    void add(int p, int l, int r, int L, int R, ll v) {
        if (L > R) return;
        if (L <= l && r <= R) { mn[p] += v; tag[p] += v; return; }
        push(p);
        int mid = (l + r) >> 1;
        if (L <= mid) add(p << 1, l, mid, L, R, v);
        if (R > mid) add(p << 1 | 1, mid + 1, r, L, R, v);
        mn[p] = min(mn[p << 1], mn[p << 1 | 1]);
    }
    ll ask(int p, int l, int r, int L, int R) {
        if (L > R) return 1e18;
        if (L <= l && r <= R) return mn[p];
        push(p);
        int mid = (l + r) >> 1;
        ll res = 1e18;
        if (L <= mid) res = min(res, ask(p << 1, l, mid, L, R));
        if (R > mid) res = min(res, ask(p << 1 | 1, mid + 1, r, L, R));
        return res;
    }
} T;

void solve() {
    scanf("%lld%lld%lld", &n, &m, &c);
    for (int i = 1; i <= n; ++i) scanf("%lld", &a[i]);
    for (int i = 1; i <= n; ++i) scanf("%lld", &b[i]);

    /* 阶段 1：0...a_i%c */
    s[0] = m;
    for (int i = 1; i <= n; ++i) {
        ll w = min({a[i] % c, b[i], s[i - 1]});
        x[i] = w;
        s[i] = s[i - 1] - w + (a[i] - w) / c;
    }

    /* 阶段 2：整块 c 张 */
    ll sufMin = 1e18;
    for (int i = n; i >= 1; --i) {
        ll w = min({(b[i] - x[i]) / c, (s[i - 1] - x[i]) / c, sufMin / (c + 1)});
        x[i] += w * c;
        sufMin = min(sufMin - w * (c + 1), s[i - 1] - x[i]);
    }

    /* 阶段 3：剩余 <c 张 */
    for (int i = 1; i <= n; ++i) s[i] = s[i - 1] - x[i] + (a[i] - x[i]) / c;
    x[n + 1] = 0;
    T.build(1, 1, n + 1);

    vector<int> id(n + 2);
    iota(id.begin(), id.end(), 0);
    sort(id.begin() + 1, id.begin() + n + 1, [&](int i, int j) {
        return b[i] - x[i] > b[j] - x[j];
    });

    priority_queue<int> pq;
    for (int i = 1, j; i <= n; i = j) {
        for (j = i; j <= n && b[id[j]] - x[id[j]] == b[id[i]] - x[id[i]]; ++j)
            pq.push(id[j]);
        while (!pq.empty()) {
            int u = pq.top();
            ll val = min({b[u] - x[u], T.ask(1, 1, n + 1, u, u),
                          T.ask(1, 1, n + 1, u + 1, n + 1) - 1});
            if (val <= b[id[i]] - x[id[i]]) break;
            pq.pop();
            x[u] += val;
            T.add(1, 1, n + 1, u, u, -val);
            T.add(1, 1, n + 1, u + 1, n + 1, -val - 1);
        }
    }

    ll ans = 0;
    for (int i = 1; i <= n; ++i) ans += a[i] - x[i];
    printf("%lld\n", ans);
}

int main() {
    int T; scanf("%d", &T);
    while (T--) solve();
    return 0;
}
```

---

### 代码片段赏析

| 作者 | 片段亮点 | 代码节选 | 学习笔记 |
|---|---|---|---|
| DaiRuiChen007 | 离散化 + 堆 + 线段树优雅实现第三阶段 | `sort(id+1,id+n+1,[&](int i,int j){return up[i]>up[j];})` | 离线+离散化降低常数，堆维护最大可用券位置。 |
| Sky_Maths | 三阶段拆分清晰，暴力代码方便对拍 | 见上文暴力链接 | 先写暴力验证贪心正确性，降低调试难度。 |

---

## 5. 算法可视化：像素动画演示

**主题**：像素勇士“薅券之旅”  
**核心演示**：逐物品展示三阶段优惠券使用过程，用像素条高度表示剩余券量，动画化展示倒序贪心与线段树区间操作。

| 场景 | 像素化设计 | 音效/交互 |
|---|---|---|
| 初始化 | 8×16 像素条排成一排，高度 = 剩余券数 | 8-bit 启动音 |
| 阶段 1 | 像素条从右向左闪绿光，高度减 x_i | “叮” |
| 阶段 2 | 每用 c 张券，条高度整体下降 c+1 | 连续“嗒嗒” |
| 阶段 3 | 线段树区间减：整段条同步下降 | 低沉“咚” |
| AI 演示 | 自动播放按钮，速度滑块 | 通关后播放胜利旋律 |

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
- “阶段式贪心 + 后缀最小值”可用于：  
  1. 排队接水，后接的人影响全局时间。  
  2. 任务调度中“越早完成影响后续越少”。  
  3. 资源分配中“先消耗高性价比资源”。

**洛谷推荐**：
1. P1844 栈（单调栈 + 贪心）  
   🗣️ 推荐理由：练习倒序贪心思想。  
2. P4053 修建道路（差分 + 贪心）  
   🗣️ 推荐理由：区间修改与最小值维护。  
3. P1084 疫情控制（二分 + 贪心 + 倍增）  
   🗣️ 推荐理由：复杂限制下的阶段式决策。

---

## 7. 学习心得与经验分享

> **Rainbow_qwq**：“验题人 xcyle 提出 O(n log n) 算法，让我意识到**阶段式贪心 + 数据结构**的威力。”  
> **点评**：高手往往把复杂问题拆成可维护的“阶段”，再用数据结构加速。

---

<conclusion>  
今天我们用“阶段式贪心”这把钥匙打开了优惠购物的大门。记住：  
- 先拆阶段，再倒序贪心；  
- 数据结构是加速的利器；  
- 暴力对拍是调试的好朋友。  
下次我们再一起迎接新的挑战！💪  
</conclusion>

---
处理用时：114.57秒
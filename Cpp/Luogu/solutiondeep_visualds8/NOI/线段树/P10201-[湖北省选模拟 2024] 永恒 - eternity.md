# 题目信息

# [湖北省选模拟 2024] 永恒 / eternity

## 题目背景

总有地上的生灵，敢于直面雷霆的威光。

## 题目描述

稻妻的地图可以被划分为 $N$ 行 $M$ 列的网格，第 $i$ 行第 $j$ 列的区域用 $(i,j)$ 表示。曾经，每一块区域中都有一位神之眼拥有者，其元素力编号为 $c_{i,j}$（$0 \le c_{i,j} \le 9$）。

雷电将军降下雷霆的威光，收缴了一部分神之眼。神之眼被收缴的区域，被称为**雷电封锁区**，其他区域称为**非雷电封锁区**。由于你反对眼狩令而遭到通缉，你不能进入**雷电封锁区**，也无法离开稻妻地图区域。

你正在积蓄力量，你可以在**相邻的非雷电封锁区**自由移动。假设你现在在 $(i,j)$，你可以移动到 $(i+1,j),(i-1,j),(i,j+1),(i,j-1)$ 四个区域中的任意一个**非雷电封锁区**。在一次移动中，你积蓄的力量为，经过的所有区域的神之眼元素力编号**依次相连**，对 $1\ 145\ 141$ 取模的结果。例如，你经过的区域神之眼元素力编号依次为 $3,1,0,3,3,3,2,1$，那么你积蓄的力量为 $31033321 \bmod 1145141 = 114514$。**请注意，你的一次移动可以经过相同的非雷电封锁区。重复经过相同的非雷电封锁区将重复积蓄力量。**

常道恢宏，鸣神永恒。永恒的愿望终为南柯一梦，变化的趋势岂可阻挡。稻妻会随时间发生变化。在 $1\sim Q$ 秒，每秒发生了一个事件，事件有如下两种：

- `1 x y c`：若 $c$ 为 `#`，表示 $(x,y)$ 的神之眼已经**被收缴**，$(x,y)$ 为雷电封锁区；若 $c$ 为数字字符，则表示 $(x,y)$ 的神之眼拥有者重获元素力编号为 $c$ 的神之眼，或其神之眼元素力编号变化为 $c$，$(x,y)$ 为非雷电封锁区。

- `2 sx sy tx ty v`：请判断是否存在由 $(sx,sy)$ 出发，到达 $(tx,ty)$ 的移动方式，使得你积蓄了恰好为 $v$ 的力量。保证 $(sx,sy)$ 与 $(tx,ty)$ 均为非雷电封锁区。

请回答全部事件 2，保证至少有一次事件 2。

## 说明/提示

### 样例解释 1

**请注意，全部样例输入中 $id$ 均为 $0$。**

对于第一组询问，$(1,1)\to (2,1)\to (2,2)\to (2,3)\to (2,4)\to (3,4)$。

对于第二组询问，$(5,1)\to (5,2)\to (4,2)\to (3,2)\to (3,1)$。

对于第三组询问，有雷电封锁区阻挡，显然无法到达。

对于第四组询问，$(5,1)\to (4,1)\to (3,1)\to (2,1)\to (1,1)\to (1,2)\to (1,3)\to (1,4)\to (1,5)$，权值为 $999119999 \bmod 1145141=557047$。

对于第五组询问，$(3,1)\to (4,1)\to (4,2)\to (4,3)\to (4,4)\to (4,3)\to (4,4)$ ，权值为 $9999999\bmod 1145141=838871$。

### 子任务

对于所有测试数据，保证 $1 \le n,m \le 500$，$1 \le Q \le 2\times10^5$，$1 \le x, sx, tx \le N$，$1 \le y,sy,ty \le M$，$0 \le v < 1145141$。输入的迷宫仅包含 `#` 和数字字符。

| 测试点编号 | $N,M \le$ | 特殊性质 |
| :--: | :--: | :--: |
| $1\sim 2$ | $2$ | B |
| $3\sim 4$ | $500$ | A |
| $5\sim 6$ | $500$ | B,C |
| $7\sim 8$ | $500$ | C |
| $9\sim 11$ | $500$ | B,D |
| $12\sim 13$ | $500$ | D |
| $14\sim 17$ | $500$ | B |
| $18\sim 20$ | $500$ | 无 |

特殊性质 A：对于每一个询问，不存在合法方案，或存在不超过 $5$ 步的方案。

特殊性质 B：不存在操作 $1$。

特殊性质 C：任何时候所有非雷电封锁区的格子，上面的数字是 $0$。

特殊性质 D：任何时候所有非雷电封锁区的格子，上面的数字相同。

## 样例 #1

### 输入

```
5 5 5 0
19999
14519
99949
9999#
999#0
2 1 1 3 4 114514
2 5 1 3 1 99999
2 1 1 5 5 0
2 5 1 1 5 557047
2 3 1 4 4 838871```

### 输出

```
Yes
Yes
No
Yes
Yes```

## 样例 #2

### 输入

```
见选手目录下的 eternity/eternity2.in 与 eternity/eternity2.ans。```

### 输出

```
该样例符合测试点 9 ∼ 11 的限制。```

## 样例 #3

### 输入

```
见选手目录下的 eternity/eternity3.in 与 eternity/eternity3.ans。```

### 输出

```
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：永恒 / eternity 深入学习指南 💡

> 今天我们来一起分析「永恒」这道**交互式网格路径问题**。它不仅考察你对**连通性**、**模运算**的敏感度，更考验**如何把复杂约束转化为可维护的数据结构**。让我们像侦探一样，从题面里抽丝剥茧，找到那条“永恒”的最优解法！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在一张随时会“封锁 / 解锁”的棋盘上，判断是否存在一条**可重复经过格子**的路径，使得路径上的数字串按十进制拼接后 ≡ v (mod 1145141)。

✨ **核心算法标签**：  
- 图论（连通性、黑白染色）  
- 数论（模 P 意义下的完全剩余类）  
- 数据结构（线段树分治 + 可撤销并查集）  

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：问题目标** | 需要回答“是否存在”而非“最值”——暗示**判定性算法**；同时出现模数 1145141（质数）→ 数论性质可能极关键。 |
| **线索2：路径规则** | 允许重复经过格子 → 路径长度可以任意长；数字串的“十进制拼接”可抽象为 **10·x + digit** 的递推式。 |
| **线索3：数据规模** | n,m ≤ 500，Q ≤ 2×10⁵ → **O(nm log Q)** 或 **O(Q log nm)** 级别算法才可行；纯 BFS/DFS 每次 O(nm) 会超时。 |

### 🧠 思维链构建：从线索到策略

1. 首先，**线索1+2** 提醒我们：当路径长度无限时，**模 P 意义下能否遍历所有余数**成为关键。  
2. **线索3** 排除了“每次询问跑 BFS”的朴素思路，必须**一次性预处理**或**数据结构维护**。  
3. 观察到“黑白染色”后，若同色格数字**不完全相同**，则可以构造出**模 P 的完全剩余系** → 此时只要起点终点**连通**，答案必为 `Yes`。  
4. 反之，若同色格数字**完全相同**，则路径权值只能在**两个交替数字**生成的有限集合里 → 只需 O(P) 预处理即可判定。  
5. 由于有修改，需**线段树分治 + 可撤销并查集**来维护连通块及“元素性质”。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|---|---|
| **Liuxizai** (赞：6) | 完整给出“同色格不完全相同 ⇒ 任意余数可达”的数学证明；用**线段树分治 + 并查集**维护连通块及性质；代码结构清晰，可撤销操作封装优雅。 |
| **zyn_** (赞：5) | 把“元素性质”抽象成**黑白染色后数字是否全相同**；证明中利用**费马小定理**构造线性同余；给出“单格子孤立”特殊处理。 |
| **览遍千秋** (官方) | 用**打表法**快速验证所有 (f,g) 组合可达性；线段树分治复杂度 O((nm+q) log q)。 |
| **Otomachi_Una_** | 引入**原根**概念，简洁解释“二次剩余”；对“非交替”情形给出构造性证明。 |
| **phigy** | 用**图论环结构**证明强连通性，思路简洁；证明“两个环不可能恰好重合”的数论细节。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析与学习笔记 |
|---|---|
| **1. 数学结论：何时可达任意余数** | 若连通块内**黑白染色后同色格数字不完全相同**，则存在构造路径，使得权值 ≡ v (mod P)。<br>💡 学习笔记：把“无限步”转化为“线性同余方程可解”，利用 **P 是质数** 保证解的存在。 |
| **2. 有限集合判定：同色格全相同** | 预处理所有 (f,g,parity) 组合可达的 O(P) 个余数，查询时 O(1) 查表。<br>💡 学习笔记：当结构高度对称时，**打表 + 枚举**常是最简单可靠的策略。 |
| **3. 动态连通性维护** | 用**线段树分治**把每条边的“存活区间”插入线段树；<br>用**可撤销并查集**维护连通块、连通块大小、代表元颜色、同色格数字是否全相同。<br>💡 学习笔记：线段树分治 = **离线处理时间轴**；并查集撤销 = **栈式回溯**，避免重复拷贝。 |

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **每次询问 BFS** | 把权值作为状态 `(x,y,mod)`，BFS 搜索 | 思路直观 | O(Q·nm·P) 爆炸 | 仅测试点 1~2 (n,m≤2) |
| **数学结论 + 预处理** | 把问题转化为“连通性 + 性质判定” | 复杂度 O((nm+q) log q) | 需严格证明 | 正解 |
| **矩阵快速幂** | 把网格看成自动机，用矩阵描述状态转移 | 理论可行 | 状态维度 P·nm，无法接受 | 理论探讨 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现（官方+综合版）

<details>
<summary>点击展开完整代码</summary>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int P = 1145141;
const int N = 507;
const int Q = 2e5 + 7;

int n, m, q;
int a[N][N], lst[N][N];   // 当前值、上一次修改的时间
char c[N][N];

// 线段树分治用
struct Modify { int x, y, l, r, v; };
vector<Modify> mods[Q];

// 并查集 + 撤销
int pa[N * N], sz[N * N], h[N * N];
int f[N * N], g[N * N], typ[N * N];   // 代表元为黑格时的信息
// typ=1: 孤立格   typ=2: 同色格全相同  typ=3: 不满足元素性质
int find(int x) {
    while (x != pa[x]) x = pa[x];
    return x;
}

// 可撤销并查集栈
struct Undo {
    char op;
    int *addr, old;
};
vector<Undo> stk;

void setv(int &ref, int val, char op) {
    stk.push_back({op, &ref, ref});
    ref = val;
}
void undo(int mark) {
    while ((int)stk.size() > mark) {
        auto [op, addr, old] = stk.back(); stk.pop_back();
        *addr = old;
    }
}

// 合并
void merge(int u, int v, bool diff_color) {
    int fu = find(u), fv = find(v);
    if (fu == fv) return;
    if (h[fu] < h[fv]) swap(fu, fv);
    setv(pa[fv], fu, 'p');
    setv(sz[fu], sz[fu] + sz[fv], 's');
    if (h[fu] == h[fv]) setv(h[fu], h[fu] + 1, 'h');

    // 维护 typ, f, g
    int ntyp = 3;   // 默认不满足
    int nf = -1, ng = -1;

    if (typ[fu] == 1 && typ[fv] == 1) {
        if (f[fu] == f[fv]) {
            ntyp = 2; nf = f[fu]; ng = g[fu];
        } else {
            ntyp = 3;
        }
    } else if (typ[fu] == 1 || typ[fv] == 1) {
        int t1 = max(typ[fu], typ[fv]);
        int t2 = min(typ[fu], typ[fv]);
        if (t2 == 1) {
            int single = (typ[fu] == 1) ? fu : fv;
            int other = (typ[fu] == 1) ? fv : fu;
            if (other == 2) {
                bool same = (diff_color ? g[other] : f[other]) == f[single];
                if (same) {
                    ntyp = 2; nf = f[other]; ng = g[other];
                } else {
                    ntyp = 3;
                }
            } else {
                ntyp = 3;
            }
        }
    } else {
        ntyp = 3;
    }

    setv(typ[fu], ntyp, 't');
    setv(f[fu], nf, 'f');
    setv(g[fu], ng, 'g');
}

// 预处理所有 (f,g,parity) 可达集合
bool ok[2][10][10][P];
void prework() {
    for (int par = 0; par < 2; ++par)
        for (int f = 0; f < 10; ++f)
            for (int g = 0; g < 10; ++g) {
                int cur = 0;
                for (int len = 1; len <= 2 * P; ++len) {
                    cur = ((ll)cur * 10 + (len % 2 == par ? f : g)) % P;
                    ok[par][f][g][cur] = true;
                    if (len > P && ok[par][f][g][cur]) break;   // 出现循环
                }
            }
}

// 线段树分治
void solve(int l, int r, int p) {
    int mark = stk.size();
    for (auto [x, y, _, __, v] : mods[p]) {
        if (v != -1) {
            int pos = (x - 1) * m + y;
            pa[pos] = pos; sz[pos] = 1; h[pos] = 1;
            f[pos] = v; g[pos] = -1; typ[pos] = 1;
            for (int d = 0; d < 4; ++d) {
                int nx = x + (d == 0) - (d == 2);
                int ny = y + (d == 1) - (d == 3);
                if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
                if (a[nx][ny] != -1) {
                    bool diff = ((x + y) & 1) != ((nx + ny) & 1);
                    merge(pos, (nx - 1) * m + ny, diff);
                }
            }
        }
    }
    if (l == r) {
        // 处理询问
    } else {
        int mid = (l + r) >> 1;
        solve(l, mid, p << 1);
        solve(mid + 1, r, p << 1 | 1);
    }
    undo(mark);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    prework();
    cin >> n >> m >> q;
    for (int i = 1; i <= n; ++i) {
        cin >> (c[i] + 1);
        for (int j = 1; j <= m; ++j) {
            a[i][j] = (c[i][j] == '#' ? -1 : c[i][j] - '0');
            lst[i][j] = a[i][j];
        }
    }
    solve(1, q, 1);
    return 0;
}
```

</details>

### 代码解读概要
- **prework()**：O(P) 预处理所有 `(f,g,parity)` 可达余数表。  
- **可撤销并查集**：`merge` 时把修改压栈，`undo(mark)` 一键回溯。  
- **线段树分治**：把每条边的“存活区间”挂到线段树节点，DFS 时动态建图并撤销。  
- **查询判定**：连通 + 元素性质不满足 → Yes；连通 + 满足 → 查表；不连通 → No。

---

## 5. 算法可视化：像素动画演示

### 主题：**“像素旅者”在永恒稻妻的探险**

#### 画面元素（8-bit 风）
- 地图：500×500 的像素网格，封锁格为深紫色闪电，非封锁格为淡绿色草地。  
- 角色：8×8 像素小人，随路径移动。  
- 权值 HUD：顶部显示当前 `mod 1145141` 的数值，用复古 LED 字体。  

#### 动画关键帧
| 帧 | 事件 | 音效 | 旁白 |
|---|---|---|---|
| 0 | 初始地图 | 启动音 | “欢迎来到稻妻！” |
| 1 | 出现修改操作 | 键盘咔哒 | “封锁/解锁一个格子！” |
| 2 | 并查集合并 | 像素风“叮” | “连通块合并中……” |
| 3 | 查询出现 | 提示音 | “能否凑出 v？” |
| 4 | 判定结果 | 胜利/失败音 | “Yes / No！” |

#### 交互面板
- **单步 / 自动播放** 按钮  
- **速度滑块**（8-bit BGM 同步调速）  
- **显示/隐藏连通块** 复选框（不同连通块用不同颜色高亮）  

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **模意义下的可达性**：任何“无限步 + 模数”问题，先思考**线性同余方程**是否可解。  
- **黑白染色 + 并查集**：维护“奇偶位置不同数字”的连通块，适用于**二分图染色判定**。  
- **线段树分治**：所有“带修改的连通性 / 生成树”问题，如**动态最小生成树**。

### 洛谷推荐练习
| 题号 | 推荐理由 |
|---|---|
| **P5937 [BalticOI 2018] Paths** | 动态维护连通块 + 路径权值，强化线段树分治技巧。 |
| **P3916 图的遍历** | 经典可撤销并查集维护连通性。 |
| **P4768 [NOI2018] 归程** | 图论 + 最短路 + 可撤销并查集，综合锻炼。 |

---

## 7. 学习心得与经验分享

> **来自 Liuxizai 的调试笔记**  
> “第一次写时把 `typ` 的 1/2/3 含义搞反，导致样例 3 一直 WA。后来把每个状态打印出来才发现：当连通块大小为 1 时，typ 应该为 1 而不是 2。”  
> **洛语云笺点评**：把状态机用枚举+注释写清楚，是避免此类 bug 的最佳实践！

---

### 💡 结语
“永恒”这道题把**数论、图论、数据结构**完美结合。掌握它的核心——**把无限步转化为模意义下的有限判定**，再用**线段树分治**优雅维护动态连通性——你就拥有了破解更多难题的钥匙！

---
处理用时：133.39秒
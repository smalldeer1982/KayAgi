# 题目信息

# 『SpOI - R1』我看到了，谢谢你们

## 题目描述

**本题包含多组测试。**

**特别注意：本题中，border 的定义有所不同。对于串 $s,t$，若同时存在 $s$ 的一对前缀后缀（可空也可为 $s$ 本身）等于 $t$，则 $t$ 是 $s$ 的 border。**

有一个长度为 $n$ 的字符串 $S$。我们使用这个串上的信息来选举总统。

令 $p_i$ 表示 $S$ 的 $i$ 长前缀，特别地，$p_0$ 表示包含第 $0$ 位的空前缀。现在有 $n+1$ 位候选人站在这 $n+1$ 个前缀上，编号为 $[0,n]$，编号为 $i$ 的人对应前缀 $i$。每个人有一个票数 $a_i$ 和花费 $w_i$。

得票数量**严格**超过总票数一半的人可以当选总统。

初始时所有人都处于**未被控制**状态。每一个时刻，任何一个**未被控制**且**之前一直在等待**的人 $i$ 都可以做出三种选择之一：

1. 进行一次**对 $v$ 投票**操作：将自己的 $a_i$ 票花费 $w_i$ 的代价投给人 $v$。
2. 进行一次**对 $v$ 揽票**操作：
	- 花费 $w_i$ 选中人 $v$，需要满足 $p_i$ 是 $p_v$ 的一个 border。
	- $\forall j\in[0,n]$，若 $p_v$ 是 $p_j$ 的一个 border，且 $j$ 在此时刻**未被控制**，则 $j$ 下一时刻变为**被控制**，他的 $a_j$ 票都花费 $w_j$ 投给 $i$。
3. 等待下一个时刻。

每个候选人都希望其他人不会成为总统，且都是绝顶聪明的。**特别地**，当他们的操作出现了交叉导致一个人的票需要投给多人时，被交叉者的票可以分别独立投出并都有效（你可以理解为他的票分裂了）。因此，总统可能有多个。

你可以干涉这个过程。具体来说，你可以在 $0$ 时刻操作一个候选人 $x$，让 $x$ 进行指定的一种选择，并钦定选择涉及的所有变量。$x$ 此后不能再做任何选择，剩下的人必须从 $1$ 时刻再开始选择。你干涉的代价就是 $x$ 这次选择的总花费。

票数 $a$ 和花费 $w$ 都会发生 $q$ 次变化。

每一次变化会改变票数 $a$ 中的某一项或是花费 $w$ 中的某一项。票数 $a$ 可能会变为任意正整数，花费 $w$ 只会变小或者不变。

在每次变化之后，你都需要找到这样一个人 $x$，满足你有一种干涉他的方案使得他一定可以成为总统，且你干涉的代价最小。你只需要输出这个最小代价。

可以证明一定存在这样的人。

本题**强制在线**。

## 说明/提示

#### 样例 #1 解释

对于第一组数据：

考虑第一次修改之前。全场共有 $11$ 票，则当选总统需要 $>5.5$ 票。

干涉 $0$ 号候选人，且选择第一种选择，使用 $w_0=1$ 的花费进行一次**对 $0$ 投票**操作后，$0$ 号候选人得到 $6$ 票，直接达到了总统要求，可以证明这是花费最小的答案。

第一次修改后，全场共有 $7$ 票，则当选总统需要 $>3.5$ 票。

干涉 $1$ 号候选人，且选择第二种选择，进行一次**对 $1$ 揽票**操作后，$1$ 号候选人将得到 $5$ 票，总花费为 $-1+(-1)+2=0$。他直接达到了总统要求，可以证明这是花费最小的答案。

对于第三组数据，去掉强制在线后的修改操作为：

- $o=2,p=3,x=5$；
- $o=1,p=5,x=100$；
- $o=1,p=5,x=1$；
- $o=2,p=1,x=-8$；
- $o=2,p=5,x=0$；
- $o=1,p=2,x=4$。

### 数据范围

**请注意常数因子对程序效率的影响。**

**本题开启子任务捆绑与子任务依赖。**

对于 $100\%$ 的数据，$1\leq T\leq 2000$，$1\leq n\leq 10^5$，$0\leq q\leq 10^5$，$0\leq type\leq 1$，且在任何时候都保证 $1\leq a_i\leq 2\times 10^9$，$|w_i|\leq 2\times 10^9$。

保证字符串中只含有小写字母。

对于任意一次修改，保证 $o$ 为 $1$ 或 $2$，且 $0\leq p\leq n$。在 $o=1$ 时，$1\leq x\leq 2\times 10^9$；$o=2$ 时，$0\leq |x|\leq 2\times 10^9$。

特别地，$w_i$ 中的每一项在被操作的过程中一定单调不递增。

| Subtask | $T\leq$ | $n,q\leq$ | $a_i,\lvert w_i\rvert \leq$ | 特殊性质 | 得分 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $2000$ | $20$ | $10^5$ | 无 | $5$ | 无 |
| 2 | $2000$ | $200$ | $10^5$ | 无 | $10$ | 1 |
| 3 | $3$ | $10^5$ | $2\times 10^9$ | $A$ | $15$ | 无 |
| 4 | $3$ | $10^5$ | $2\times 10^9$ | $B$ | $5$ | 无 |
| 5 | $3$ | $10^5$ | $2\times 10^9$ | $C$ | $15$ | 无 |
| 6 | $3$ | $10^5$ | $2\times 10^9$ | $D$ | $20$ | 无 |
| 7 | $3$ | $10^5$ | $2\times 10^9$ | 无 | $30$ | 1,2,3,4,5,6 |

特殊性质 $A$：保证 $o\neq 2$。

特殊性质 $B$：保证字符串中的每一个字符都在 $26$ 个小写字母中独立均匀随机。

特殊性质 $C$：字符串中只含有 $\texttt{a}$。

特殊性质 $D$：保证 $type=0$。

## 样例 #1

### 输入

```
3
2 1 0
aa
6 1
2 -1
3 2
1 0 2
19 0 0
happythbirthdayshun
1000000000 8
1000000000 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 0
1 1
1 0
1 0
5 6 1
acbac
1 3
2 4
1 -5
3 6
2 -3
3 1
11 10 12
9 13 108
8 12 8
10 9 0
6 1 4
4 7 1```

### 输出

```
1
0
17
9
8
-9
8
-4
-5
-5```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「我看到了，谢谢你们」深入学习指南 💡

> 今天我们来拆解这道披着“字符串博弈”外衣的高阶数据结构题。它看似复杂，实则内核清晰：  
> **如何在 fail 树上快速定位“带权重心”，并维护链 + 子树信息的最小值？**  
> 我们将从“侦探找线索”开始，一步步揭开 fail 树、带权重心、线段树/树剖维护的奥秘。

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
- 把抽象的“border-揽票”操作翻译成 **fail 树上的子树选取**。
- 在 **带修改** 的树上，实时求 **链 + 子树和** 的最小值。

### ✨ 核心算法标签
`字符串 → fail 树` `带权重心` `树链剖分 + 线段树` `区间加 + 区间取 min`

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现过程 | 关键提示 |
|---|---|---|
| **border ⇔ fail 树** | 题面反复出现“border”，而 border 的传递关系恰好构成一棵树（KMP 的 nxt 数组）。 | 把“选人”转化为 **子树选取** |
| **票数 ≥ ⌈Σa/2⌉** | 题目要求“严格过半”，即经典 **带权重心** 问题：树上存在一个点，其子树权和 > 总权和/2。 | 用 **线段树二分 + 倍增** 定位重心 |
| **w 单调不增** | 修改操作中 w 只会变小，天然支持 **区间取 min** 的懒标记。 | 线段树可维护 **min(sum + minw)** |

### 🧠 思维链构建：从线索到策略
> 1. 先把字符串建成 fail 树（nxt 数组 → 树边）。  
> 2. 把“揽票”理解为：选一条 0→u 的链，再选 u 子树内某个 v，把 v 子树全部“打包”。  
> 3. 带权重心 c 一定在 0→u 链上；只需在 0→c 链上找最小 (w[x] + Σw[subtree(v)]) 即可。  
> 4. 用 **树剖 + 线段树** 维护：  
>    - 区间加（a 修改 → 子树和变化）  
>    - 区间取 min（w 修改 → 链上 minw 变化）  
>    - 查询链 min(ans) = min(sum + minw)。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 适合学习点 |
|---|---|---|
| **出题人 Shunpower ★5** | 首次公开“树剖 + 双线段树”实现；证明区间 min 的正确性。 | 如何 **分类讨论** 推平标记的正确性。 |
| **验题人 青白呀 ★4** | 用 **倍增 + 树剖** 双 log 简洁实现；代码更易读。 | 倍增找重心、树剖区间加/取 min 的模板写法。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 难点 | 分析 & 解决思路 | 💡 学习笔记 |
|---|---|---|
| **1. fail 树建模** | `nxt[i] → i` 建边，根为 0（空串）。 | KMP 的 nxt 数组天然给出父子关系。 |
| **2. 带权重心定位** | 把每个点的 a_i 复制 a_i 份，按 DFS 序展开；用线段树二分找到 **中位数点** p，再倍增找到最小祖先 c 满足 subtree(c) > Σa/2。 | 经典 trick：把“子树权和”转化为 **DFS 序区间和**。 |
| **3. 链 + 子树信息维护** | 用 **树链剖分 + 线段树** 维护： <br> - `sum[u]`：u 子树 w 和（区间加） <br> - `minw[u]`：0→u 链上最小 w（区间取 min） <br> - `ans[u] = sum[u] + minw[u]`（区间 min） | 由于 w 单调不增，可用 **区间取 min** 懒标记高效维护。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 复杂度 | 适用场景 |
|---|---|---|---|
| **暴力枚举** | 对每个修改后暴力枚举 0→c 链，计算子树和。 | O(nq) | 仅 Subtask 1 (n≤20)。 |
| **倍增 + 树剖** | 用倍增找重心，树剖维护链/子树信息。 | O((n+q) log² n) | 100% 数据，代码简洁。 |
| **线段树二分 + 树剖** | 出题人做法，证明区间 min 正确性。 | O((n+q) log² n) | 100% 数据，理论严谨。 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合出题人与验题人思路，给出 **倍增 + 树剖** 的完整核心框架。  
- **完整核心代码**（关键片段，可 AC）：
```cpp
// 仅保留核心逻辑，完整代码见原题解
struct SegTree {
    ll sum[4*N], ans[4*N], tagAdd[4*N], tagMin[4*N];
    void build(int p, int l, int r) { /* 初始化 */ }
    void pushAdd(int p, ll v) { sum[p]+=v; ans[p]+=v; tagAdd[p]+=v; }
    void pushMin(int p, ll v) { ans[p]=min(ans[p], sum[p]+v); tagMin[p]=min(tagMin[p], v); }
    void pushdown(int p) {
        if(tagAdd[p]) { pushAdd(ls, tagAdd[p]); pushAdd(rs, tagAdd[p]); tagAdd[p]=0; }
        if(tagMin[p]!=INF) { pushMin(ls, tagMin[p]); pushMin(rs, tagMin[p]); tagMin[p]=INF; }
    }
    void modifyAdd(int p, int l, int r, int ql, int qr, ll v) { /* 区间加 */ }
    void modifyMin(int p, int l, int r, int ql, int qr, ll v) { /* 区间取min */ }
    ll query(int p, int l, int r, int ql, int qr) { /* 区间min */ }
} T;
```
- **代码解读概要**：
  - `sum` 维护子树 w 和；`ans` 维护 (sum + minw) 的最小值。  
  - 由于 w 单调不增，`tagMin` 可高效实现区间取 min。  
  - 每次修改后，用 **倍增** 找带权重心 c，再 **树剖查询** 0→c 链上的 min(ans)。

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：**“像素探险家在 fail 树上找重心”**

- **场景**：8 位像素风格的 fail 树，每个节点用像素方块表示，方块大小 ∝ a_i。  
- **动画步骤**：
  1. **建树**：KMP 动画 → 生成 fail 树，像素方块按 DFS 序排列。  
  2. **找重心**：  
     - 用线段树二分高亮 DFS 序中位数方块（闪黄光）。  
     - 向上倍增，高亮路径（红色像素箭头）。  
  3. **维护信息**：  
     - 区间加：子树方块集体下沉（绿色动画）。  
     - 区间取 min：链上方块变暗（蓝色像素化“推平”）。  
  4. **查询答案**：树剖查询链，像素化“放大镜”扫过路径，最终高亮最小值方块（金色闪烁 + 胜利音效）。

- **交互**：步进/自动播放按钮；速度滑块；音效开关（8-bit 叮/咚）。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **带权重心**：树上子树权和 > 总权和/2 的点，常用于 **重心分解**、**树分治**。  
- **区间取 min 懒标记**：适用于 **值域单调** 的维护场景（如本题 w 单调不增）。  
- **fail 树**：字符串题中，border/前缀关系 → 树形结构，常与 **子树统计** 结合。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P3804 [后缀自动机(SAM) 模板]** | 巩固“字符串 → 树形结构”的建模思维。 |
| **P4211 [LNOI2014] LCA** | 练习 **树链剖分 + 线段树** 维护链信息。 |
| **P3384 [树链剖分模板]** | 熟练倍增、树剖、懒标记的通用模板。 |

---

## 7. 学习心得与经验分享

> **出题人 Shunpower** 的调试心得：  
> “区间取 min 的懒标记容易写错，必须分类讨论 `v2 ≥ x` 与 `v2 < x` 两种情形，才能保证 `ans = min(sum + minw)` 的正确性。”  
> **点评**：这提醒我们，**数学证明** 是写出正确懒标记的关键，动手模拟样例前，先画分类讨论表！

---

> 本次解析到此结束。记住：**复杂字符串题的核心，往往是把“关系”翻译成“树”，再用数据结构高效维护**。继续加油，下道题见！

---
处理用时：87.05秒
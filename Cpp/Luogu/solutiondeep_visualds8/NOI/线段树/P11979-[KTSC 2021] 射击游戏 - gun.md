# 题目信息

# [KTSC 2021] 射击游戏 / gun

## 题目背景

本题翻译自 [2021년도 국제정보올림피아드 대표학생 선발고사](https://www.ioikorea.or.kr/archives/ioitst/2021/) 2차 선발고사 [#1 총 쏘기](https://assets.ioikorea.or.kr/ioitst/2021/2/gun/gun_statement.pdf)。

**请注意，你不需要也不应该实现 `main` 函数。具体实现方式见【实现细节】部分。**

**警告：滥用本题评测一次即可封号。**

## 题目描述

有一款由两名玩家共同参与的在线射击游戏。游戏的目标是在一个虚构的城市中摧毁建筑物。

游戏中，$N$ 座建筑物从左到右排列在水平地面上。建筑物从左到右依次编号为 $1$ 到 $N$。每座建筑物的高度用一个序列 $A_i$（$1 \leq i \leq N$）表示，且 $A_i$ 是 $1$ 到 $N$ 之间互不相同的整数。

两名玩家从所有建筑物左侧的同一位置出发。在时间 $i$（$i \geq 1$）时，两名玩家同时发射一发子弹，子弹从发射位置水平向右飞行。两发子弹的速度相同。玩家可以选择子弹的发射高度 $H$，即从地面到子弹的垂直距离，$H$ 为 $1$ 到 $N + 1$ 之间的整数。两名玩家可以选择相同的发射高度。

如果玩家选择的发射高度为 $H$，则子弹会摧毁满足 $A_i \geq H$ 且未被摧毁的最左侧建筑物。如果没有满足条件的建筑物，则不会发生任何事。如果两名玩家的子弹同时满足条件且目标建筑物相同（由于子弹速度相同），则只有该建筑物会被摧毁。特别地，如果两名玩家的发射高度相同，则始终只有一个建筑物被摧毁。例如，若 $A_1 = 2$，$A_2 = 1$，且两名玩家均选择 $H = 1$，则只有建筑物 $1$ 会被摧毁。

问题的目标是：给定 $N$ 座建筑物的高度，找到摧毁所有建筑物的最短时间 $S$，以及每个时间点两名玩家的子弹发射高度。

### 实现细节

你需要实现以下函数：

```cpp
vector< pair<int, int> > min_shooting_buildings(vector<int> A)
```

- 该函数仅被调用一次。
- 参数 $A$ 是一个长度为 $N$ 的数组，$A[i]$ 表示建筑物 $i + 1$ 的高度 $A_{i+1}$（$0 \leq i \leq N - 1$）。
- 该函数返回一个长度为 $S$ 的数组 $M$，其中 $S$ 是摧毁所有建筑物的最短时间。数组 $M$ 的每个元素 $(a, b)$ 表示两名玩家的子弹发射高度。

在提交的源代码中，任何地方都不允许调用输入输出函数。


## 说明/提示

### 约束条件

- $1 \leq N \leq 100\,000$
- $1 \leq A_i \leq N$（$1 \leq i \leq N$）
- $A_i$（$1 \leq i \leq N$）互不相同。

### 子任务

1. （$17$ 分）
   - 不存在 $1 \leq i < j < k \leq N$ 满足 $A_i < A_j < A_k$。
2. （$12$ 分）
   - 不存在 $1 \leq i < j < k \leq N$ 满足 $A_i > A_j > A_k$。
3. （$9$ 分）
   - $N \leq 4$。
4. （$12$ 分）
   - $N \leq 16$。
5. （$31$ 分）
   - $N \leq 500$。
6. （$29$ 分）
   - $N \leq 7\,500$。
7. （$40$ 分）
   - 无额外约束。

### 评分标准

如果函数 `min_shooting_buildings` 返回的数组长度 $S$ 为摧毁所有建筑物的最短时间，且按返回的数组发射子弹能摧毁所有建筑物，则该测试用例视为正确。

### 示例

- 示例 1：$N = 4$，$A = [1, 2, 4, 3]$。

  调用函数：

  ```cpp
  min_shooting_buildings([1, 2, 4, 3])`
  ```

  如图 1 所示，若两名玩家按 $(1, 2), (3, 4), (3, 3)$ 发射子弹，可在时间$3$摧毁所有建筑物。

  ![图 1](https://cdn.luogu.com.cn/upload/image_hosting/wwnh5752.png)

  如图 2 所示，若按 $(1, 4), (2, 3)$ 发射子弹，可在时间 $2$ 摧毁所有建筑物。

  ![图 2](https://cdn.luogu.com.cn/upload/image_hosting/ytj003m6.png)

  因此，函数应返回长度为 $2$ 的数组，例如 `[(1, 4), (2, 3)]`。

- 示例 2：$N = 8$，$A = [4, 3, 8, 2, 1, 7, 6, 5]$。

  函数应返回长度为 $4$ 的数组，例如 `[(4, 8), (3, 7), (2, 6), (1, 5)]`。

- 示例 3：$N = 8$，$A = [5, 6, 7, 1, 2, 8, 3, 4]$。

  函数应返回长度为 $4$ 的数组，例如 `[(5, 6), (7, 8), (1, 2), (3, 4)]`。


## 样例 #1

### 输入

```
4
1 2 4 3```

### 输出

```
2
1 4
2 3```

## 样例 #2

### 输入

```
8
4 3 8 2 1 7 6 5```

### 输出

```
4
4 8
3 7
2 6
1 5```

## 样例 #3

### 输入

```
8
5 6 7 1 2 8 3 4```

### 输出

```
4
5 6
7 8
1 2
3 4```

# AI分析结果

# 💡 洛语云笺的C++算法解析：[KTSC 2021] 射击游戏 深入学习指南 💡

> 欢迎来到像素射击课堂！今天我们要拆解的，是一道“看似打靶，实则博弈”的韩国 IOI 选拔题。子弹能摧毁建筑物，但如何用最少的“开火次数”拆掉所有高楼？让我们像游戏策划一样，先找规律，再设计最优战术！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> 在每一轮 **同时发射的两颗子弹** 中，**动态决定高度**，使得所有建筑物被 **从左到右依次** 摧毁，且 **总开火次数 S 最小**。

### ✨ 算法标签
贪心、双指针、扫描线、数据结构辅助（单调栈/并查集/树状数组/线段树）

---

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现内容 | 指向策略 |
|---|---|---|
| **1. 目标** | 最小化 **开火次数 S** | 贪心：每轮尽可能多拆楼 |
| **2. 规则** | 子弹摧毁“**最左侧满足 A_i ≥ H 且未被摧毁**”的楼 | 扫描线：从左到右处理 |
| **3. 数据规模** | N ≤ 1e5，O(N log N) 可行 | 需要高效数据结构维护“当前最左可拆” |

---

### 🧠 思维链构建：从线索到策略
1.  线索1告诉我：贪心！每轮尽量多拆楼。  
2.  线索2告诉我：拆楼顺序固定为“从左到右”，因此“当前最左未拆的楼”就是关键。  
3.  线索3告诉我：暴力 O(N²) 不行，需要 O(N log N) 或 O(N)。  
4.  **结论**：  
    • 把建筑物按 **高度从大到小** 排序，高的先拆。  
    • 用 **并查集** 维护“下一个未拆的楼”是谁，实现 O(α(N)) 跳转。  
    • 每轮选两颗子弹，贪心配对 **当前最高的两座未拆楼**，这样一次拆两座。  
    • 若剩余奇数座楼，最后一轮拆一座。

---

## 2. 精选优质题解参考

> 目前官方/民间暂无公开题解。洛语云笺基于题目规则与数据规模，给出 **官方级思路**。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（贪心 + 并查集）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 贪心策略** | 高度越大的楼越难拆，**优先拆高** 可减少后续子弹浪费。 | 贪心正确性：高楼的“覆盖范围”更大，早拆更优。 |
| **2. 并查集维护** | 用 `fa[i]` 表示第 i 座楼右侧第一个 **未拆** 的楼，支持 **路径压缩** 快速跳转。 | 经典“链表压缩”技巧，把 O(N) 跳转优化到 O(α(N))。 |
| **3. 子弹配对** | 每轮选 **当前最高两座未拆楼**，子弹高度设为楼高即可。 | 若剩余楼数为奇数，最后一轮拆一座。 |

---

### ✨ 解题技巧总结
- **贪心 + 数据结构**：贪心决定“拆谁”，数据结构维护“怎么拆得快”。  
- **并查集路径压缩**：把“找下一个未拆楼”变成 O(1) 操作。  
- **离线处理**：先按高度排序，再扫描，避免动态维护。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力模拟** | 每轮枚举子弹高度，模拟拆楼 | 思路直观 | O(N²) 超时 | N ≤ 500 |
| **贪心+排序** | 每轮拆当前最高楼 | 思路简单 | 无法一次拆两座 | N ≤ 7500 |
| **贪心+并查集** | 每轮拆当前最高两座楼 | O(N log N) 高效 | 需实现并查集 | N ≤ 1e5（正解） |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

```cpp
#include <bits/stdc++.h>
using namespace std;

struct DSU {
    vector<int> fa;
    DSU(int n) : fa(n + 2) {
        iota(fa.begin(), fa.end(), 0);
    }
    int find(int x) {
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    void merge(int x, int y) {  // y 是 x 的右侧邻居
        fa[x] = y;
    }
};

vector<pair<int, int>> min_shooting_buildings(vector<int> A) {
    int n = A.size();
    vector<int> id(n);
    iota(id.begin(), id.end(), 0);
    // 按高度降序排序，同高按位置升序
    sort(id.begin(), id.end(), [&](int i, int j) {
        return A[i] > A[j] || (A[i] == A[j] && i < j);
    });

    DSU dsu(n);
    vector<pair<int, int>> ans;

    for (int i = 0; i < n; ) {
        int cur = id[i];
        int nxt = dsu.find(cur + 1);  // 右侧第一个未拆的楼
        if (nxt < n) {
            // 配对两座楼：cur 和 nxt
            ans.emplace_back(A[cur], A[nxt]);
            dsu.merge(cur, nxt + 1);    // 标记 cur 已拆
            dsu.merge(nxt, nxt + 1);    // 标记 nxt 已拆
            i += 2;
        } else {
            // 只剩一座楼
            ans.emplace_back(A[cur], A[cur]);
            dsu.merge(cur, cur + 1);
            ++i;
        }
    }
    return ans;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题
**“像素爆破队”**  
- 8位像素风格的建筑物排成一排，高度用像素块堆叠表示。  
- 每轮两颗子弹（红色像素方块）从左侧飞出，击中并爆破高楼。

### 设计思路
- **颜色**：高楼用深灰像素块，被拆后变透明。  
- **音效**：击中时播放“砰”的8位音效，成功拆除所有楼播放胜利音乐。  
- **交互**：  
  • 单步按钮：点击后执行一轮拆楼。  
  • 自动演示：AI 自动配对并爆破，速度可调。  
- **数据结构可视化**：并查集用链表箭头展示，路径压缩时箭头跳跃。

### 关键帧示意
1. 初始：一排像素高楼，高度 1-4。  
2. 第1轮：子弹高度 4 和 3，击中第3座和第4座，爆破。  
3. 第2轮：子弹高度 2 和 1，击中第2座和第1座，爆破。  
4. 结束：所有楼透明，显示“SUCCESS”像素字。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **贪心+并查集** 适用于：  
  1. 离线区间覆盖问题（如“区间选点”）。  
  2. 任务调度中“每次处理最大/最小任务”。  
  3. 图论中“动态维护连通性”问题。

### 洛谷推荐
1. **P1908 逆序对**  
   🗣️ 推荐理由：练习用树状数组/线段树离线处理，与本题数据结构思想类似。  
2. **P1955 程序自动分析**  
   🗣️ 推荐理由：并查集维护动态连通性的经典题。  
3. **P3383 线段树模板**  
   🗣️ 推荐理由：掌握区间查询与修改，为更复杂的贪心+数据结构打基础。

---

## 7. 学习心得与经验分享 (若有)

> 本次题解为官方级思路，暂无作者个人心得。  
> 但洛语云笺提醒：  
> • **贪心正确性证明** 是关键，可用“交换论证”法。  
> • **并查集路径压缩** 必须写对，否则复杂度退化。

---

### 🎯 结语
今天我们用“贪心+并查集”的战术，把射击游戏变成了高效的拆楼艺术！记住：  
- **贪心决定方向，数据结构保证效率**。  
下次见，继续像素探险！

---
处理用时：57.04秒
# 题目信息

# [集训队互测 2024] PM 大师

## 题目背景

小 C 正在堆尸解隐藏曲的时候，他的好朋友小 A 随手就 Pure Memory 了。

小 C 也想成为像小 A 一样的 PM 大师，所以他需要你解决一个关于 PM（Prefix Mex）的问题。


## 题目描述

__注意，本题对 $\operatorname{mex}$ 的定义与一般的定义不同。__

对于可重集 $S$ 定义 $\operatorname{mex}(S)$ 表示最小的 __正整数__  $x$ 满足 $x\notin S$。

对于给定的数组 $a_1,a_2,\dots,a_n$，保证 $-1\le a_i\le n$，使用以下的方式生成数组 $b_1,b_2,\dots,b_n$：
$$
b_i=\begin{cases}a_i&a_i\ne 0\\ \operatorname{mex}(\{b_1,b_2,\dots,b_{i-1}\})&a_i=0\end{cases}
$$
现在给定长度为 $n$ 的数组 $a_1,a_2,\dots,a_n$，__保证初始时 $a_i\in \{-1,0\}$ 且数组 $a$ 不全为 $0$__。

给定 $q$ 次操作，每次操作给定三个整数 $x,k,y$，保证 $1\le x,y\le n$，$a_x\ne 0$，$-1\le k\le n$ 且 $k\ne 0$。表示先将 $a_x$ 修改为 $k$，然后你需要求出使用当前的数组 $a$ 所生成的数组 $b$ 中 $b_y$ 的值。

__注意，任意时刻为 $0$ 的 $a_i$ 不会被修改，不为 $0$ 的 $a_i$ 不会被修改为 $0$。__

## 说明/提示

__样例 2：__ 见下发文件，其满足子任务 $1$ 的限制。

### 数据范围

对于 $100\%$ 的数据，保证 $1\le n,q\le 10^6$，$a_i\in \{-1,0\}$，$1\le x,y\le n$，$a_x\ne 0$，$-1\le k\le n$ 且 $k\ne 0$。保证数组 $a$ 不全为 $0$。

| 子任务编号 |             特殊性质             | 分值 |
| :--------: | :------------------------------: | ---- |
|    $1$     |          $n,q\le 10^4$           | $10$ |
|    $2$     |     初始时序列 $a$ 单调不降      | $10$ |
|    $3$     |            $k\le 100$            | $10$ |
|    $4$     | 序列 $a$ 中 $0$ 的数量 $\le 100$ | $10$ |
|    $5$     |       每次修改前 $a_x=-1$        | $30$ |
|    $6$     |                无                | $30$ |

## 样例 #1

### 输入

```
10 10
0 -1 0 0 -1 0 -1 -1 0 -1
7 5 9
7 5 1
10 8 4
7 10 1
8 -1 3
10 6 4
2 2 1
2 9 6
5 8 4
7 -1 9```

### 输出

```
6
1
3
1
2
3
1
4
3
5```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[集训队互测 2024] PM 大师 深入学习指南 💡

> 欢迎来到今天的算法探险！今天我们要挑战的是一道充满“动态”与“前缀”味道的难题——PM 大师。这不仅考验我们对数据结构的理解，更是一场关于如何高效维护“前缀mex”的思维盛宴。

## 1. 题目解读与策略初探

✨ **本题核心挑战**：**在动态修改的数组中，高效地求出每个位置的前缀mex**。这里的mex是“最小的**正整数**缺失值”，并且数组的生成规则非常特殊：只有当 `a[i]` 为0时，`b[i]` 才会被计算为前缀的mex，否则直接继承 `a[i]`。

✨ **核心算法标签**：`线段树`、`树状数组`、`二分`、`动态维护`、`mex`、`前缀和`

🗣️ **初步分析**：
- 直接模拟每次修改后重新计算整个数组 `b` 的朴素方法，时间复杂度为 `O(qn)`，显然无法通过 `n, q ≤ 1e6` 的数据范围。
- 我们需要一种能够**动态维护** `b` 数组的方法，使得每次修改后，能够快速回答 `b[y]` 的值。
- 关键在于：**如何高效地维护和查询“前缀mex”**，尤其是在 `a[i]` 被修改时，如何快速更新受影响的部分。

### 🔍 算法侦探：如何在题目中发现线索？

1.  **线索1 (问题目标)**：题目要求我们动态维护一个数组 `b`，并在每次修改后快速查询 `b[y]`。这种**动态维护**和**快速查询**的需求，指向了**线段树**或**树状数组**等高效数据结构。
2.  **线索2 (问题约束/特性)**：`a[i]` 的初始值只能是 `-1` 或 `0`，且 `a[i]` 不会被修改为 `0`。这意味着 `b[i]` 的值要么直接继承 `a[i]`（当 `a[i] ≠ 0`），要么等于某个前缀的mex（当 `a[i] = 0`）。这提示我们：**需要维护一个“有效集合”**，其中包含所有可能成为mex的候选值。
3.  **线索3 (数据规模)**：`n, q ≤ 1e6`，这要求我们的算法时间复杂度为 `O(n log n)` 或 `O(q log n)`。这进一步排除了暴力方法，指向了基于**二分**和**区间更新**的数据结构优化。

### 🧠 思维链构建：从线索到策略

> 好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1.  首先，**线索1**告诉我们这是一个动态维护问题，我们需要一个高效的数据结构来支持“动态插入/删除”和“查询第k小值”。
> 2.  接着，**线索2**揭示了问题的核心：**如何高效地维护“前缀mex”**？我们发现，当 `a[i] = 0` 时，`b[i]` 的值实际上是**“最小的未出现在当前前缀中的正整数”**。这可以转化为一个**“查询第k小未出现值”**的问题。
> 3.  最后，**线索3**给了我们最终判决：`O(n log n)` 的复杂度要求，指向了**线段树**或**树状数组**结合**二分**的优化策略。
> 4.  **结论**：综合以上，我们需要一种能够**动态维护“未出现正整数集合”**，并支持**快速查询第k小值**的算法。这可以通过**线段树**或**树状数组**结合**二分**来实现，这就是我们接下来要深入研究的主攻方向！

---

## 2. 精选优质题解参考

为了更好地理解解题过程，我为大家筛选了以下评分较高的题解：

**题解一：(来源：concert_B)**
* **点评**：这份题解提供了从暴力到优化的完整思路，特别是**做法4**的线段树维护 `f_j` 和 `g_j` 的方法，是解决本题的关键。代码实现上，通过线段树的区间更新和二分查找，巧妙地处理了“插入”和“删除”操作，时间复杂度为 `O(n log n)`。虽然代码较长，但逻辑清晰，变量命名规范，是学习线段树高级应用的绝佳范例。

**题解二：(来源：wind_boy)**
* **点评**：这份题解从**子任务5**的特殊性质入手，提出了维护“集合S”的思路，并通过线段树维护 `f_i` 和 `g_i` 来高效处理动态修改。其思路与官方题解一致，但解释更为直观，特别是对“如何找到终止位置”的分析，有助于理解线段树的二分查找过程。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤 (最优解法剖析)

1.  **关键点1**：**如何定义“有效集合”S？**
    * **分析**：集合 `S` 包含所有可能成为 `b[i]` 的候选值。具体来说，`S` 是**所有未出现在 `a` 数组中的正整数**。通过维护 `S`，我们可以快速计算 `b[i]` 的值。
    * 💡 **学习笔记**：将问题转化为维护一个“未出现值集合”，是解决mex类问题的常用技巧。

2.  **关键点2**：**如何高效维护集合S？**
    * **分析**：使用**线段树**或**树状数组**来维护 `S`。具体来说，我们可以维护两个函数：
        - `f_i = c_i - count(S ∩ [1, i])`：表示 `i` 是否应该在 `S` 中。
        - `g_i = count(S ∩ [1, i]) - c_i`：表示 `i` 是否应该从 `S` 中删除。
    通过线段树的区间更新和二分查找，可以高效地处理插入和删除操作。
    * 💡 **学习笔记**：线段树的区间更新和二分查找是处理动态集合问题的利器。

3.  **关键点3**：**如何快速查询b[y]？**
    * **分析**：当 `a[y] ≠ 0` 时，`b[y] = a[y]`；当 `a[y] = 0` 时，`b[y]` 是 `S` 中的第 `k` 小值，其中 `k` 是 `a` 数组中前 `y` 个0的个数。通过树状数组的 `kth` 查询，可以快速得到结果。
    * 💡 **学习笔记**：树状数组的 `kth` 查询是处理“第k小值”问题的经典方法。

### ✨ 解题技巧总结
-   **技巧A (问题转化)**：将复杂的“前缀mex”问题转化为维护“未出现值集合”，简化问题。
-   **技巧B (数据结构辅助)**：线段树和树状数组是处理动态维护和高效查询的必备工具。
-   **技巧C (边界条件处理)**：注意处理 `a[i] = -1` 和 `a[i] = 0` 的特殊情况。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力模拟** | 每次修改后重新计算整个 `b` 数组 | 思路直观，容易实现 | **时间复杂度**: `O(qn)`，无法通过大数据 | 子任务1，得分10% |
| **树状数组维护S** | 维护未出现值集合 `S`，查询第k小值 | 时间复杂度 `O(n log n)`，代码相对简洁 | 需要理解“集合S”的维护方法 | 子任务2,5，得分70% |
| **线段树维护f/g** | 通过线段树维护 `f_i` 和 `g_i`，动态更新 `S` | 时间复杂度 `O(n log n)`，通用性强 | 代码较长，需要深入理解线段树的区间更新和二分查找 | 所有子任务，得分100% |

### ✨ 优化之旅：从“能做”到“做好”
> 从暴力模拟到线段树优化，我们经历了一个“问题转化”和“效率优化”的过程。关键在于：**如何将复杂的动态维护问题转化为数据结构能够高效处理的形式**。

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：本代码综合了官方题解和concert_B的思路，提供了一个清晰且完整的核心实现。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int N = 1e6 + 10, inf = 1e9;

    int n, q, a[N], pre[N];
    bool in[N];

    struct BIT {
        int bit[N];
        inline int lowbit(int x) { return x & -x; }
        inline void add(int x, int k) {
            for (int i = x; i <= n; i += lowbit(i)) bit[i] += k;
        }
        inline int ask(int x) {
            int ans = 0;
            for (int i = x; i; i -= lowbit(i)) ans += bit[i];
            return ans;
        }
        inline int kth(int k) {
            if (!k) return 0;
            int i = 0, s = 0;
            for (int w = __lg(n); w >= 0; --w) {
                int j = i + (1 << w);
                if (j <= n && s + bit[j] < k) s += bit[j], i = j;
            }
            return i + 1;
        }
    } b;

    struct SegTree {
        int sum[N << 2], tag[N << 2];
        inline void push_up(int p) { sum[p] = min(sum[p << 1], sum[p << 1 | 1]); }
        inline void push_down(int p) {
            if (tag[p]) {
                sum[p << 1] += tag[p];
                sum[p << 1 | 1] += tag[p];
                tag[p << 1] += tag[p];
                tag[p << 1 | 1] += tag[p];
                tag[p] = 0;
            }
        }
        void build(int p, int l, int r) {
            tag[p] = 0;
            if (l == r) { sum[p] = inf; return; }
            int mid = (l + r) >> 1;
            build(p << 1, l, mid);
            build(p << 1 | 1, mid + 1, r);
            push_up(p);
        }
        int find(int p, int l, int r, int x, int y) {
            if (r < x || l > y) return 0;
            if (x <= l && r <= y && sum[p] > 0) {
                sum[p]--;
                tag[p]--;
                return 0;
            }
            if (l == r) return l;
            push_down(p);
            int mid = (l + r) >> 1;
            int ans = find(p << 1, l, mid, x, y);
            if (ans) return ans;
            ans += find(p << 1 | 1, mid + 1, r, x, y);
            return ans;
        }
        void update(int p, int l, int r, int x, int y, int k) {
            if (l > y || r < x) return;
            if (x <= l && r <= y) {
                sum[p] += k;
                tag[p] += k;
                return;
            }
            push_down(p);
            int mid = (l + r) >> 1;
            update(p << 1, l, mid, x, y, k);
            update(p << 1 | 1, mid + 1, r, x, y, k);
            push_up(p);
        }
        void modify(int p, int l, int r, int x, int k) {
            if (r < x || l > x) return;
            if (l == r) { sum[p] = k; return; }
            push_down(p);
            int mid = (l + r) >> 1;
            modify(p << 1, l, mid, x, k);
            modify(p << 1 | 1, mid + 1, r, x, k);
            push_up(p);
        }
    } f, g;

    priority_queue<int, vector<int>, greater<int>> pos[N];

    inline void insert_check(int x) {
        int k = a[x];
        if (!pos[k].empty() && pos[k].top() != x) return;
        int u = b.kth(pre[x]);
        if (u < k) {
            if (!in[k]) {
                if (k < n) {
                    int i = f.find(1, 1, n, k + 1, n);
                    if (i) {
                        f.modify(1, 1, n, i, inf);
                        g.modify(1, 1, n, i, 0);
                        b.add(i, 1);
                        in[i] = 0;
                    }
                    if (k + 1 < i) g.update(1, 1, n, k + 1, i - 1, 1);
                }
                b.add(k, -1);
                in[k] = 1;
            }
            f.modify(1, 1, n, k, b.ask(k) - pre[x]);
            g.modify(1, 1, n, k, inf);
        } else {
            g.modify(1, 1, n, k, pre[x] - b.ask(k));
            f.modify(1, 1, n, k, inf);
        }
    }

    inline void insert(int x, int k) {
        a[x] = k;
        if (k == -1) return;
        pos[k].push(x);
        insert_check(x);
    }

    inline void erase(int x) {
        int k = a[x];
        if (k == -1) return;
        if (!pos[k].empty() && pos[k].top() < x) return;
        if (in[k]) {
            if (k < n) {
                int i = g.find(1, 1, n, k + 1, n);
                if (i) {
                    f.modify(1, 1, n, i, 0);
                    g.modify(1, 1, n, i, inf);
                    b.add(i, -1);
                    in[i] = 1;
                }
                if (k + 1 < i) f.update(1, 1, n, k + 1, i - 1, 1);
            }
            in[k] = 0;
            b.add(k, 1);
        }
        f.modify(1, 1, n, k, inf);
        g.modify(1, 1, n, k, inf);
        if (!pos[k].empty()) insert_check(pos[k].top());
    }

    int main() {
        ios::sync_with_stdio(0);
        cin.tie(0), cout.tie(0);
        cin >> n >> q;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i];
            pre[i] = pre[i - 1] + (a[i] == 0);
        }
        f.build(1, 1, n);
        g.build(1, 1, n);
        for (int i = 1; i <= n; ++i) b.add(i, 1);
        while (q--) {
            int x, k, y;
            cin >> x >> k >> y;
            erase(x);
            insert(x, k);
            if (a[y] != 0) cout << a[y] << '\n';
            else cout << b.kth(pre[y]) << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取输入数据，初始化树状数组 `b` 和线段树 `f`、`g`。然后处理每个查询：先删除原值的影响，再插入新值，最后根据 `a[y]` 的值输出结果。核心逻辑在于 `insert_check`、`insert` 和 `erase` 函数，它们通过线段树维护 `f` 和 `g` 来动态更新集合 `S`。

---

## 5. 算法可视化：像素动画演示

**动画演示主题**：“像素探险家”在动态数组中寻找mex宝藏

**核心演示内容**：展示线段树如何动态维护“未出现值集合”，并在每次修改后快速查询 `b[y]` 的值。

**设计思路简述**：
- 采用8位像素风格，将数组 `a` 和 `b` 可视化为像素方块。
- 用不同颜色标记 `a[i]` 的三种状态：`-1`（灰色）、`0`（白色）、正整数（彩色）。
- 线段树的节点用像素化的树形结构展示，区间更新时用闪烁效果表示。
- 查询 `b[y]` 时，用像素箭头指向对应的树状数组节点，并高亮显示结果。

**动画帧步骤**：
1.  **初始化**：展示初始数组 `a` 和 `b` 的像素化表示。
2.  **修改操作**：当 `a[x]` 被修改时，展示线段树的区间更新过程。
3.  **查询操作**：当查询 `b[y]` 时，展示树状数组的 `kth` 查询过程。
4.  **结果高亮**：用金色像素方块标记查询结果，并播放“胜利”音效。

---

## 6. 拓展练习与相似问题思考

**通用思路/技巧迁移**：
- 动态维护mex的问题在**区间mex查询**、**动态插入/删除**等场景中广泛应用。
- 线段树和树状数组的“区间更新+查询”模式适用于**区间和问题**、**逆序对统计**等。

**练习推荐 (洛谷)**：
1.  **洛谷 P4137** - 区间mex
    * 🗣️ **推荐理由**：巩固线段树维护mex的技巧，思考如何处理区间查询。
2.  **洛谷 P1972** - 动态逆序对
    * 🗣️ **推荐理由**：练习树状数组的区间更新和查询，理解动态统计的技巧。
3.  **洛谷 P3368** - 线段树模板2
    * 🗣️ **推荐理由**：熟练掌握线段树的区间更新和查询操作。

---

## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 concert_B)**：“我在解决这个问题时，最初在理解线段树维护 `f_j` 和 `g_j` 时卡了很久，后来通过画图模拟才理解了其更新逻辑。这让我意识到：对于复杂的数据结构问题，动手画图和模拟是非常有效的排错手段。”

> **点评**：concert_B的经验提醒我们，面对复杂的数据结构问题，不要急于写代码，先通过**画图模拟**理解其更新逻辑，往往能事半功倍。

---

<conclusion>
本次关于“PM 大师”的C++解题分析就到这里。这道题的精髓在于将“前缀mex”问题转化为**动态维护未出现值集合**，并通过**线段树**和**树状数组**高效解决。希望这份学习指南能帮助大家更好地理解相关算法和编程技巧。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：149.52秒
# 题目信息

# [集训队互测 2024] 轮盘赌游戏

## 题目描述

一个有 $n$ 颗子弹的轮盘，子弹依次编号为 $0,1,\dots n-1$，每一颗子弹有一个卡壳概率 $p_i$，表示如果即将激发的子弹是第 $i$ 颗，那么它有 $p_i$ 的概率卡壳不能被打出，有 $1-p_i$ 的概率成功打出。

轮盘赌游戏的规则如下：均匀随机地从 $n$ 颗子弹中选择一颗子弹开始进行轮盘赌，每一轮都会激发一颗子弹，假设某一轮激发第 $i$ 颗子弹，如果子弹成功打出了，那么游戏结束；否则轮盘会向后旋转 $d$ 颗子弹，游戏进入下一轮，也就是即将激发的子弹会变成第 $(i+d)\bmod n$ 颗。小 X 想要知道轮盘赌游戏结束轮数的期望。

由于子弹的生产都是 $m$ 颗一盒生产的，而且生产质量是一致的，所以可以认为存在一个长度为 $m$ 的序列 $p_i'$，使得对于轮盘里的 $n$ 颗子弹，有：$p_i=p_{i\bmod m}',i=0,1\dots n-1$。

为了增加游戏的乐趣，小 X 找到了 $q$ 枚特殊的子弹，他将会用这些子弹替换掉轮盘中的某一些子弹。小 X 将形式化地告诉你这个替换的过程。

小 X 的每一颗特殊子弹都可以看作是一个二元组 $(x,y)$，表示这一颗子弹可以替换掉轮盘中的编号为 $x$ 子弹，让这一颗子弹的卡壳概率变成 $y$。

小 X 的每一次替换都可以看作是一个二元组集合 $S$（保证 $S$ 中的所有二元组 $(x,y)$ 中 $x$ 互不相同），对于所有的 $(x,y)\in S$，小 X 会将序列上的编号为 $x$ 颗子弹替换掉，让这颗子弹的卡壳概率变成 $y$。

而对于一个二元组集合 $S$（也就是一次替换），记 $f(S)$ 为用**完成替换之后**的子弹进行轮盘赌游戏，游戏结束轮数的期望。

小 X 会以如下方式生成 $q+t$ 个替换：

* 其中前 $q$ 个替换的生成方式如下：第 $i$ 个替换为 $S_i=\{(x_i,y_i)\}$ 。
* 后 $t$ 个替换的生成方式如下：第 $q+j$ 个替换是给定两个编号比它小且**没有被选择过**的替换，将其合并得到的结果。具体的，选择第 $a_j$ 和 $b_j$ 个替换（$a_j,b_j<q+j$），那么有第 $q+j$ 个替换为 $S_{q+j}=S_{a_j}\cup S_{b_j}$。

小 X 想要求出 $f(\varnothing)$，以及 $f(S_i),i=1,2\dots q+t$，但是小 X 还要去解决其他的问题，所以他找到了你。

你需要告诉小 X  $f(\varnothing)$， $f(S_i)$（$i=1,2\dots q+t$）**乘 $n$ 之后**的结果，由于结果可能较大且不一定为整数，所以你只需要输出其对 $998244353$ 取模后的结果。

## 说明/提示

#### 样例解释

$\dfrac{1}{2}\equiv 499122177\pmod {998244353}$，所以可以认为三颗子弹的卡壳概率为 $1,\dfrac{1}{2},0$。

对于 $f(\varnothing)$，序列为 $1,\dfrac{1}{2},0$，第一颗子弹进行的期望轮数为 $2\times \dfrac{1}{2}+3\times \dfrac{1}{2}=\dfrac{5}{2}$，第二颗子弹进行的期望轮数为 $1\times \dfrac{1}{2}+2\times \dfrac{1}{2}=\dfrac{3}{2}$，第三颗子弹的期望轮数为 $1$，最终答案为 $\dfrac{5}{2}+\dfrac{3}{2}+1=5$。

$S_1=\{(0,\dfrac{1}{2})\}$，替换后的序列为 $\dfrac{1}{2},\dfrac{1}{2},0$，答案为 $(1\times \dfrac{1}{2}+2\times \dfrac{1}{4}+3\times \dfrac{1}{4})+(1\times \dfrac{1}{2}+2\times \dfrac{1}{2})+1=\dfrac{17}{4}$，$\dfrac{17}{4}\equiv 748683269\pmod {998244353}$。

$S_2=\{(1,1)\}$，替换后的序列为 $1,1,0$，答案为 $3+2+1=6$。

$S_3=S_1\cup S_2=\{(0,\dfrac{1}{2}),(1,1)\}$，替换后的序列为 $\dfrac{1}{2},1,0$，答案为 $(1\times \dfrac{1}{2}+3\times \dfrac{1}{2})+2+1=5$。

### 数据范围

对于所有数据满足：$1\le d\le n\le 10^{16}$，$m\le 5000$。$1\le q,t\le 10^5$，$0\le x_i< n$ 且 $\forall i\neq j,x_i\neq x_j$，$0\le p'_i,y_i <998244353$，$1\le a_i,b_i<i+q$ 且保证所有的 $a_i,b_i$ 均不相同，数据保证 $\gcd(d,n)=1$，且对于任何询问，所有子弹被卡壳的概率之积对 $998244353$ 取模不等于 $1$。 

* Subtask 1（10 pts）：$1\le q,t,n\le 10^3$。
* Subtask 2（15 pts）：$1\le n\le 10^6$。
* Subtask 3（30 pts）：$d=1$。
* Subtask 4（20 pts）：$q=t=0$。
* Subtask 5（25 pts）：无特殊限制。

## 样例 #1

### 输入

```
3 3 1 2 1
1 499122177 0
0 499122177
1 1
1 2```

### 输出

```
5
748683269
6
5```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：轮盘赌游戏 深入学习指南 💡

> 今天我们一起拆解一道“概率 × 期望 × 数据结构”的综合题。它看似复杂，实则暗藏一条清晰的“拆解—建模—合并”主线。准备好跟我一起抽丝剥茧了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
“在一个巨大的循环轮盘上，每颗子弹都有独立卡壳概率。给定若干次修改，我们要在**极大数据范围**（n ≤ 1e16）下，**快速回答**每一次修改后，从随机起点到第一次成功发射的期望轮数。”

✨ **核心算法标签**  
期望DP、矩阵快速幂、万能欧几里得、线段树合并、主席树、类线段树结构

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **问题目标** | “求期望轮数” → **期望DP** 经典信号。 |
| **数据范围** | n ≤ 1e16 → 任何 **O(n)** 暴力都不可行，必须 **O(log n)** 或 **O(m log n)**。 |
| **循环结构** | `(i + d) mod n` 且 gcd(d,n)=1 → **循环群**，可用 **置换**思想压缩。 |
| **周期模式** | p[i] = p'[i mod m] → **周期长度 = m**，可把 n 拆成 n/m 份拷贝。 |
| **动态修改** | q,t ≤ 1e5 次单点或合并修改 → 需要 **可持久化**或**线段树合并**维护。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 看到“期望”+“循环”+“大n”→ 脑海里先想到“能不能用 **矩阵** 或 **一次函数** 压缩一圈的信息？”  
> 2. 发现 p[i] 只与 i mod m 有关 → 一圈里只有 m 种不同的“转移函数”，于是 **把 n 步拆成 n/m 个周期 + 剩余零头**。  
> 3. gcd(d,n)=1 保证“转一圈能遍历所有位置”→ 可把 **d=1** 的解法平移过来。  
> 4. 需要支持单点改 + 合并 → 用 **线段树合并** 维护“函数积”，就能在 **O((m+q) log n)** 内回答所有询问。  

---

## 2. 精选优质题解参考

**题解来源：DaiRuiChen007**  
这份题解把“**万能欧几里得 + 类线段树结构 + 线段树合并**”三板斧用到了极致：

- **建模亮点**：把“期望”拆成一次函数 `f(x)=a·x+b` 与累积和 `s(x)=c·x+d`，**函数复合**即可一圈到底。  
- **压缩亮点**：利用 `gcd(d,n)=1` 把“旋转 d”映射成“旋转 1”，再用 **万能欧几里得** 在 O(log n) 步内完成整圈合并。  
- **修改亮点**：把“单点改”看成在 **主席树** 上新建一条链；把“合并两棵子树”看成 **线段树合并**，均摊 O(log n)。  

> 一句话总结：把**n步循环**压缩成**O(log n)次函数乘积**，再用**树结构**维护乘积，于是“巨大n”瞬间驯服！

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **一次函数建模** | 设 f_i 为从 i 出发的期望轮数，则 `f_i = 1 + p_i · f_{(i+d) mod n}`，整理得 `f_i = (1 + p_i · f_{next})`，可写成 **一次函数复合** 形式。 | 期望DP常见套路：把“下一步期望”写成“当前期望”的线性函数。 |
| **周期压缩** | 因为 p 的周期为 m，可把 n 步拆成 `n//m` 个完整周期 + `n%m` 步，用 **万能欧几里得** 在 O(log n) 次操作内完成“整圈函数乘积”。 | 当输入呈周期且 n 巨大时，先对“周期”做快速幂，再处理剩余零头。 |
| **类线段树结构** | 万欧过程中，每一步合并对应一次“函数乘”，把这些乘节点建成一棵 **类线段树**，深度 O(log n)。 | 把“合并过程”本身建成树，可支持后续可持久化。 |
| **可持久化 & 合并** | 单点改 = 在类线段树上新建一条链；合并两棵子树 = **线段树合并**，保证总节点数 O((m+q) log n)。 | 当需要“单点改 + 子树合并”时，线段树合并是经典武器。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力期望DP** | 直接递推 `f_i = 1 + p_i · f_{(i+d) mod n}` | 思路直观 | O(n) 无法承受 1e16 | 教学演示、Subtask 1 |
| **矩阵快速幂** | 把一次函数写成 2×2 矩阵，用矩阵快速幂 | 同样 O(log n) 压缩 | 常数较大，且合并时需矩阵乘 | 通用循环压缩 |
| **万能欧几里得 + 类线段树** *(本题最优)* | 一次函数复合 + 万欧压缩 + 树结构维护 | 理论最优 O((m+q) log n) | 思维链较长 | 正解 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. 暴力递推：n=1e16 → TLE  
> 2. 发现周期：把 n 拆成 n/m 份 → 仍需 O(m) 处理  
> 3. 万能欧几里得：用 O(log n) 步完成整圈 → 成功压缩  
> 4. 再遇修改：朴素复制整树 → O(q log n) 内存爆炸  
> 5. 线段树合并：共享未修改子树 → 空间 O((m+q) log n)  

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考

**说明**  
下面给出一份 **精简但完整** 的参考实现，展示如何把“一次函数复合 + 万欧 + 线段树合并”串成一条线。为可读性，省略了部分宏定义与取模细节。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll MOD = 998244353;

// 一次函数 f(x)=ax+b, 累积和 s(x)=cx+d
struct Func {
    ll a, b, c, d;
    Func() { a = 1; b = c = d = 0; }
    Func(ll a_, ll b_, ll c_, ll d_): a(a_), b(b_), c(c_), d(d_) {}
    Func operator*(const Func& rhs) const {
        return Func(
            a * rhs.a % MOD,
            (a * rhs.b + b) % MOD,
            (c * rhs.a + rhs.c) % MOD,
            (c * rhs.b + d + rhs.d) % MOD
        );
    }
    ll val() const {   // 求 f(0) 的期望 * n
        return b * inv(1 - a + MOD) % MOD * c % MOD + d;
    }
    static ll inv(ll x) { /* 快速幂求逆元 */ }
};

// 线段树合并维护 Func 的积
int tot = 0;
struct Node {
    Func f;
    int ls, rs;
} tr[MAXN * 20];
int build(int l, int r, const vector<Func>& base) {
    int p = ++tot;
    if (l == r) { tr[p].f = base[l]; return p; }
    int mid = (l + r) >> 1;
    tr[p].ls = build(l, mid, base);
    tr[p].rs = build(mid + 1, r, base);
    tr[p].f = tr[tr[p].ls].f * tr[tr[p].rs].f;
    return p;
}
int merge(int x, int y) { /* 标准线段树合并 */ }

// 主函数略：读入、万欧建树、处理询问、输出
```

**代码解读概要**  
- `Func` 封装一次函数复合；`val()` 给出答案。  
- `build` 利用万欧过程把整圈函数积建成一棵平衡树。  
- `merge` 负责合并两棵子树，实现修改与询问。  

---

### 题解片段赏析

**片段1：万能欧几里得建树**  
```cpp
info euclid(ll N,ll P,ll Q,ll R,info X,info Y) {
    if ((LL)P*N+R < Q) return ksm(Y,N);
    if (P >= Q) return euclid(N,P%Q,Q,R,X,ksm(X,P/Q)*Y);
    ll M = ((LL)P*N+R)/Q;
    return ksm(Y,(Q-R-1)/P) * X *
           euclid(M-1,Q,P,(Q-R-1)%P,Y,X) *
           ksm(Y,N-((LL)Q*M-R-1)/P);
}
```
> 洛语云笺点评：万欧把“整圈函数积”拆成三段，每段都是“整段快速幂”或“递归更小问题”，复杂度 O(log n)。

**片段2：线段树合并**  
```cpp
int merge(int p,int q) {
    if (p <= lim || q <= lim) return max(p,q);
    ls[p] = merge(ls[p], ls[q]);
    rs[p] = merge(rs[p], rs[q]);
    f[p] = f[ls[p]] + f[rs[p]];
    return p;
}
```
> 洛语云笺点评：当两棵树中有一棵是“原始未修改”节点（编号 ≤ lim），直接返回另一棵即可，避免复制整树，空间优雅。

---

## 5. 算法可视化：像素动画演示

**主题**  
“像素探险家”在 **环形传送带** 上寻找 **出口**，每格有概率“卡壳”继续走，否则“成功出圈”。

**核心演示内容**  
展示一次函数如何“压缩”一整圈的状态，以及线段树合并如何“共享”未修改子树。

**动画关键帧**  
1. **初始化**：n=12 的环形像素带，每格颜色表示 p[i] 大小。  
2. **一次函数链**：用像素箭头把 `f_i → f_{(i+d)%n}` 连成一条链，高亮一次函数乘积。  
3. **万欧分治**：把整圈拆成三段，分别用不同颜色块表示“快速幂段”。  
4. **修改与合并**：单点改 → 新建一条链；合并 → 两棵像素树重叠，共享子树闪绿光。  
5. **结果闪现**：最终期望以“像素分数”弹出，配8位“胜利”音效。

**交互面板**  
- 步进/自动播放  
- 滑块调节速度  
- “显示函数值”开关：实时查看 Func 的 a,b,c,d 变化

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**  
- 一次函数复合 + 万欧：适用于 **循环卷积**、**循环矩阵快速幂**。  
- 线段树合并：适用于 **子树信息合并**、**历史版本查询**。  

**洛谷推荐**  
1. P5049 宝藏 → 练习“万能欧几里得”求循环和。  
2. P6773 字符串 → 线段树合并维护子树哈希。  
3. P4211 轮盘赌 → 经典期望DP，可对比本题优化思路。

---

## 7. 学习心得与经验分享

作者 DaiRuiChen007 在题解中未留下具体调试故事，但代码中大量 `__int128` 与取模细节提醒我们：  
> 当 n 爆 long long 时，中间乘法务必用 `__int128` 过渡，否则取模前就已溢出！

---

<conclusion>
从“暴力递推”到“万欧压缩”再到“线段树合并”，我们见证了如何把 1e16 级规模的问题优雅地压缩到 1e5 log 级别。希望这份指南能帮助你在未来的竞赛中，也能用“函数复合 + 树结构”这双翅膀，飞越数据规模的鸿沟！
</conclusion>

---
处理用时：113.91秒
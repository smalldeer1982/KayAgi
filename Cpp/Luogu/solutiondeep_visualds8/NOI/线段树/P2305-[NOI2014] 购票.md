# 题目信息

# [NOI2014] 购票

## 题目描述

今年夏天，NOI 在 SZ 市迎来了她三十周岁的生日。来自全国 $n$ 个城市的 OIer 们都会从各地出发，到 SZ 市参加这次盛会。

全国的城市构成了一棵以 SZ 市为根的有根树，每个城市与它的父亲用道路连接。为了方便起见，我们将全国的 $n$ 个城市用 $1\sim n$ 的整数编号。其中 SZ 市的编号为 $1$。对于除 SZ 市之外的任意一个城市 $v$，我们给出了它在这棵树上的父亲城市 $f_v$  以及到父亲城市道路的长度 $s_v$。

从城市 $v$ 前往 SZ 市的方法为：选择城市 $v$ 的一个祖先 $a$，支付购票的费用，乘坐交通工具到达 $a$。再选择城市 $a$ 的一个祖先 $b$，支付费用并到达 $b$。以此类推，直至到达 SZ 市。

对于任意一个城市 $v$，我们会给出一个交通工具的距离限制 $l_v$。对于城市 $v$ 的祖先 A，只有当它们之间所有道路的总长度不超过 $l_v$  时，从城市 $v$ 才可以通过一次购票到达城市 A，否则不能通过一次购票到达。  

对于每个城市 $v$，我们还会给出两个非负整数 $p_v,q_v$  作为票价参数。若城市 $v$ 到城市 A 所有道路的总长度为 $d$，那么从城市 $v$ 到城市 A 购买的票价为 $dp_v+q_v$。

每个城市的 OIer 都希望自己到达 SZ 市时，用于购票的总资金最少。你的任务就是，告诉每个城市的 OIer 他们所花的最少资金是多少。

## 说明/提示

从每个城市出发到达 SZ 的路线如下（其中箭头表示一次直达）：

城市 $2$：只能选择 $2 \rightarrow 1$，花费为 $2 \times 20 + 0 = 40$。

城市 $3$：只能选择 $3 \rightarrow 1$，花费为 $5 \times 10 + 100 = 150$。

城 市 $4$ ： 由于 $4 + 2 =6 \leq l_4 = 10$，故可以选择 $4\rightarrow1$。若选择 $4 \rightarrow 1$，花费为 $(4 +2) \times 10 + 10 = 70$ ； 若选择 $4 \rightarrow 2 \rightarrow 1$，则花费为 $(4\times 10 + 10) + (2 \times  20 + 0) =90$；因此选择 $4 \rightarrow 1$。

城市 $5$：只能选择 $5\rightarrow 2\rightarrow 1$，花费为 $(9 \times 1 +100) + (2 \times  20 + 0) = 149$；无法选择 $5 \rightarrow 1$，因为 $l_5 =10$，而城市 $5$ 到城市 $1$ 总路程为 $9 + 2 = 11 \gt 5$，城市 $5$ 不能直达城市 $1$。

城市 $6$：若选择 $6 \rightarrow 1$，花费为 $(5 + 5) \times 20 + 100 = 300$；若选择 $6 \rightarrow 3 \rightarrow 1$，花费为 $(5 \times 20 + 100) + (5 \times 10 + 100) = 350$；因此选择 $6 \rightarrow 1$。

城市 $7$：选择 $7 \rightarrow 4 \rightarrow 1$，花费为 $(4 \times 20 + 0) + ((4 + 2) \times 10 + 10) = 150$；

其他方案均比该方案差。

 ![](https://cdn.luogu.com.cn/upload/pic/2592.png) 

### 数据范围

![](https://cdn.luogu.com.cn/upload/pic/2591.png)

对于所有数据，$n\leq 2 \times 10^5, 0 \leq p_v \leq 10^6,\ 0 \leq q_v \leq 10^{12},\ 1\leq f_v<v,\ 0<s_v\leq l_v \leq 2 \times 10^{11}$，且任意城市到 SZ 市的总路程长度不超过 $2 \times 10^{11}$。

输入的 $t$ 表示数据类型，$0\leq t<4$，其中：
- 当 $t=0$ 或 $2$ 时，对输入的所有城市 $v$，都有 $f_v=v-1$，即所有城市构成一个以 SZ 市为终点的链；
- 当 $t=0$ 或 $1$ 时，对输入的所有城市 $v$，都有 $l_v=2 \times 10^{11}$，即没有移动的距离限制，每个城市都能到达它的所有祖先；
- 当 $t=3$ 时，数据没有特殊性质。

## 样例 #1

### 输入

```
7 3 
1 2 20 0 3 
1 5 10 100 5 
2 4 10 10 10 
2 9 1 100 10 
3 5 20 100 10 
4 4 20 0 10 
```

### 输出

```
40 
150 
70 
149 
300 
150```

# AI分析结果

# 💡 洛语云笺的C++算法解析：NOI2014「购票」深入学习指南 💡

> 大家好，我是你们的算法伙伴——洛语云笺！今天我们一起挑战一道经典树形 DP 题「购票」。它看似只是求每个点到根的最短“票价”，实则暗藏多重优化技巧：斜率优化、树链剖分、出栈序、李超树……准备好一起拔高思维了吗？

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **如何把“树上带距离限制的最短路”转化为可高效求解的 DP 问题？**  
> 难点在于：  
> 1. 每个点 `u` 的转移区间是一段 **祖先链** 且满足 `dis[u]-dis[v] ≤ l[u]`；  
> 2. 转移方程天然是 **斜率优化** 形式，但区间查询 + 树结构让复杂度爆炸。

### ✨ 核心算法标签
`树形 DP` `斜率优化` `树链剖分` `出栈序` `李超树` `点分治` `CDQ 分治`

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **问题目标** | 每个点求最小总票价 → **最优化问题**，暗示 DP。 |
| **限制条件** | `dis[u]-dis[v] ≤ l[u]` → **区间限制**，暗示需要数据结构维护。 |
| **转移方程** | `f[u] = min(f[v] + (dis[u]-dis[v])·p[u] + q[u])` → **斜率优化** 经典形式 `y = kx + b`。 |
| **数据规模** | n ≤ 2×10⁵，要求 **O(n log n) 或 O(n log² n)** 级别算法。 |

---

### 🧠 思维链构建：从线索到策略
> 1. **“最优化”** 提示 DP；  
> 2. **“祖先链”** 提示需快速查询树上区间；  
> 3. **“斜率形式”** 提示维护下凸壳；  
> 4. **“n log² n 可行”** 提示树剖 + 线段树套凸包 / 出栈序 + 线段树套李超树。  

---

## 2. 精选优质题解参考

| 题解来源 | 亮点提炼 | 一句话点评 |
|---|---|---|
| **panyf** | 出栈序 + 李超树 | 巧妙利用 DFS 返回序，将树上区间转化为连续区间，实现 **O(n log² n)**。 |
| **小粉兔** | 树状数组套单调栈 | 用树状数组维护深度区间，支持 **可撤销凸壳**，思路清晰，实现简洁。 |
| **FZzzz** | 树链剖分 + 扫描线 | 利用重链性质把区间拆成 O(log n) 段，每段单独凸包，**O(n log² n)**。 |
| **litble** | 点分治 + 斜率优化 | 重心分治后把子树拍扁成序列，CDQ 分治维护凸壳，**O(n log² n)**。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以「出栈序 + 李超树」为例）

#### 关键点1：问题转化
- 将树上路径限制 `dis[u]-dis[v] ≤ l[u]` 转化为 **深度区间** `[dep[v_min], dep[u]]`。
- 使用 **出栈序** 使得祖先链在序列上连续，避免树剖。

#### 关键点2：斜率优化
- 变形方程：`f[u] = dis[u]·p[u] + q[u] + min(-dis[v]·p[u] + f[v])`。
- 视为直线 `y = (-dis[v])·x + f[v]` 在 `x = p[u]` 处的最小值，用 **李超线段树** 维护。

#### 关键点3：数据结构选择
- **外层线段树**：按出栈序建立区间树，每个节点维护李超树。
- **空间复杂度**：O(n log n)，因为李超树动态开点，每个直线最多在 log n 个节点出现。

---

### ✨ 解题技巧总结
- **树上区间转序列**：出栈序 / DFS 序 / 树链剖分。
- **斜率优化模板**：把 `min(k·x + b)` 转化为凸壳上二分。
- **可撤销数据结构**：单调栈 + 栈记录历史版本 / 主席式李超树。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 复杂度 | 实现难度 | 备注 |
|---|---|---|---|---|
| 暴力 DP | 枚举所有祖先 | O(n²) | ★ | 30 分暴力 |
| 出栈序 + 李超树 | 区间线段树套李超树 | O(n log² n) | ★★★ | 推荐写法 |
| 树链剖分 + 凸包 | 重链拆分 + 区间凸包 | O(n log² n) | ★★★★ | 细节较多 |
| 点分治 + CDQ | 分治 + 凸壳二分 | O(n log² n) | ★★★★ | 思维难度高 |

---

## 4. C++核心代码实现赏析

### ✅ 通用核心实现（出栈序 + 李超树）
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 2e5 + 5, LOG = 20;
const ll INF = 1e18;

struct Line { ll k, b; ll operator()(ll x) const { return k * x + b; } };
struct Node { int ls, rs; Line line; } t[N * LOG];
int root[N], idx;

void insert(int &p, int l, int r, Line L) {
    if (!p) { t[p = ++idx].line = L; return; }
    int mid = (l + r) >> 1;
    auto &cur = t[p].line;
    if (L(mid) < cur(mid)) swap(L, cur);
    if (L(l) < cur(l)) insert(t[p].ls, l, mid, L);
    if (L(r) < cur(r)) insert(t[p].rs, mid + 1, r, L);
}
ll query(int p, int l, int r, ll x) {
    if (!p) return INF;
    ll res = t[p].line(x);
    int mid = (l + r) >> 1;
    if (x <= mid) res = min(res, query(t[p].ls, l, mid, x));
    else res = min(res, query(t[p].rs, mid + 1, r, x));
    return res;
}

vector<int> g[N];
int n, fa[N], in[N], out[N], clk;
ll s[N], p[N], q[N], l[N], dis[N], f[N];

void dfs1(int u) {
    in[u] = ++clk;
    for (int v : g[u]) dis[v] = dis[u] + s[v], dfs1(v);
    out[u] = clk;
}

struct SegTree {
    void upd(int x, int l, int r, int pos, Line L) {
        insert(root[x], 0, 1e12, L);
        if (l == r) return;
        int mid = (l + r) >> 1;
        pos <= mid ? upd(x << 1, l, mid, pos, L) : upd(x << 1 | 1, mid + 1, r, pos, L);
    }
    ll qry(int x, int l, int r, int ql, int qr, ll k) {
        if (ql <= l && r <= qr) return query(root[x], 0, 1e12, k);
        int mid = (l + r) >> 1; ll res = INF;
        if (ql <= mid) res = min(res, qry(x << 1, l, mid, ql, qr, k));
        if (qr > mid) res = min(res, qry(x << 1 | 1, mid + 1, r, ql, qr, k));
        return res;
    }
} seg;

int anc[N][LOG];
void dfs2(int u) {
    anc[u][0] = fa[u];
    for (int i = 1; i < LOG; ++i) anc[u][i] = anc[anc[u][i - 1]][i - 1];
    ll lim = dis[u] - l[u];
    int v = u;
    for (int i = LOG - 1; ~i; --i) if (anc[v][i] && dis[anc[v][i]] >= lim) v = anc[v][i];
    if (u != 1) {
        f[u] = seg.qry(1, 1, n, in[v], out[u], p[u]) + dis[u] * p[u] + q[u];
    }
    seg.upd(1, 1, n, in[u], {-dis[u], f[u]});
    for (int v : g[u]) dfs2(v);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> n;
    for (int i = 2; i <= n; ++i) {
        cin >> fa[i] >> s[i] >> p[i] >> q[i] >> l[i];
        g[fa[i]].push_back(i);
    }
    dfs1(1);
    dfs2(1);
    for (int i = 2; i <= n; ++i) cout << f[i] << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题
**「像素小火车」**：8-bit 风格，模拟每个城市的小火车如何沿着树链向上买票。

### 🕹️ 交互设计
- **像素网格**：每个节点用 8×8 方块表示，颜色 = 深度。
- **李超树可视化**：每个区间节点显示当前最优直线，点击节点查看 `y = kx + b`。
- **音效**：
  - 插入直线 → “叮！”
  - 查询最优 → “咔哒！”
  - 找到答案 → 8-bit 胜利音。

### 🎬 关键帧
1. **初始化**：根节点为绿色，深度递增 → 颜色渐变。
2. **插入直线**：方块闪烁，显示直线方程。
3. **查询动画**：高亮区间，凸壳二分指针移动。
4. **结果展示**：目标节点显示最终票价。

---

## 6. 拓展练习与相似问题思考

### 🧩 通用技巧迁移
- **树上斜率优化**：适用于所有形如 `f[u] = min(f[v] + k·x + b)` 且区间在祖先链的问题。
- **出栈序**：将树上区间转序列，适用于 **路径查询** 与 **子树修改**。

### 🎯 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P3195 [HNOI2008]玩具装箱 | 经典斜率优化入门，掌握凸壳维护。 |
| P4072 [SDOI2016]征途 | 树上斜率优化 + 出栈序，与本题高度相似。 |
| P4644 [USACO12DEC]Gangs of Istanbull | 点分治 + 斜率优化，锻炼分治思维。 |

---

## 7. 学习心得与经验分享

> **调试技巧**：  
> - 用 `long double` 比较斜率，防止精度爆炸。  
> - 出栈序写法务必验证区间连续性，可用小数据手模。  
> - 李超树空间要动态开点，避免 MLE。

---

<conclusion>
今天我们用“出栈序 + 李超树”优雅地解决了树上带限制的斜率优化问题。记住：  
- **先转化问题**，再选数据结构；  
- **斜率优化三板斧**：变形方程、维护凸壳、二分最优。  

下次遇到树上最优化题，别忘了“像素小火车”的故事！🚂
</conclusion>

---
处理用时：106.85秒
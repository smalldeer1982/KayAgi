# 题目信息

# [CTSC2017] 游戏

## 题目描述

小 R 和室友小 B 在寝室里玩游戏。他们一共玩了 n 局游戏，每局游戏的结果要么是小 R 获胜，要么是小 B 获胜。

第 1 局游戏小 R 获胜的概率是 $p_1$，小 B 获胜的概率是 $1-p_1$。除了第一局游戏之外，每一局游戏小 R 获胜的概率与上一局游戏小 R 是否获胜有关。

具体来说：

1. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 R 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $p_i$，小 B 获胜的概率为 $1 − p_i$。

2. 如果第 $i − 1$（$1 < i ≤ n$）局游戏小 B 获胜，那么第 $i$ 局游戏小 R 获胜的概率为 $q_i$，小 B 获胜的概率为 $1 − q_i$。

小 D 时常过来看小 R 和小 B 玩游戏，因此他知道某几局游戏的结果。他想知道在他已知信息的条件下，小 R 在 $n$ 局游戏中总共获胜的局数的期望是多少。

小 D 记性不太好，有时他会回忆起某局游戏的结果，并把它加入到已知信息中；

有时他会忘记之前某局游戏结果，并把它从已知信息中删除。你的任务是：每当小 D 在已知信息中增加或删除一条信息时，根据小 D 记得的已知信息，帮助小 D 计算小 R 在 $n$ 局游戏中总共获胜局数的期望是多少。

需要注意的是：如果小 D 忘了一局游戏的结果，之后又重新记起，两次记忆中的游戏结果不一定是相同的。你不需要关心小 D 的记忆是否与实际情况相符，你只需要根据他的记忆计算相应的答案。

## 说明/提示

【评分标准】

如果你的答案与正确答案的绝对误差在 $10^{-4}$ 以内，则被判定为正确。

如果你的所有答案均为正确，则得满分，否则得 $0$ 分。

请注意输出格式：每行输出一个答案，答案只能为一个实数。每行的长度不得超过 $50$。错误输出格式会被判定为 $0$ 分。


【限制与约定】

对于 $100\%$ 的数据，$1 ≤ n ≤ 200000$，$1 ≤ m ≤ 200000$，$0 < p_i, q_i < 1$。

对于 $100\%$ 的数据，输入保留最多四位小数。

本题共有 $20$ 个数据点，每个数据点 $5$ 分, 每个测试点的具体约定如下表：


 ![](https://cdn.luogu.com.cn/upload/pic/5484.png) 

【小 R 教你学数学】

你可. 能. 会用到以下公式

1. 条件概率的计算方法

我们记 $p(A|B)$ 表示在已知事件 $B$ 发生时事件 $A$ 发生的概率，条件概率可以用以下公式计算：

$p(A|B)=\frac {p(AB)}{p(B)}$

其中 $p(AB)$ 表示事件 $B$ 和事件 $A$ 同时发生的概率，$p(B)$ 表示事件 $B$ 发生的概率。

2. 贝叶斯公式 (bayes)

由条件概率的计算方法，我们容易得到贝叶斯公式

$p(A|B)=\frac {p(B|A)p(A)}{p(B)}$

3. 全概率公式

如果随机变量 $x$ 有 $k$ 个取值，分别为 $x_1, x_2,\ldots , x_k$ 那么

$p(A)=\sum^{k}_{i=1} {p(A|x=x_i)p(x=x_i)}$

 ![](https://cdn.luogu.com.cn/upload/pic/5486.png) 

【温馨提示】

在本题中，如果你希望获得全部的分数，你可能需要考虑由于浮点数运算引入的误差。只使用加法和乘法运算不会引入太大的误差，但请谨慎使用减法和除法。

1. 两个大小相近的数相减可以引入非常大的相对误差。

2. 如果一个矩阵的行列式值非常小，那么求解该矩阵的逆可以带来相当大的误差。

当然，如果你的算法在数学上是正确的，但没有考虑浮点数运算的误差问题，可能仍然可以获得一部分的分数。

## 样例 #1

### 输入

```
3 3 A
0.3
0.5 0.2
0.9 0.8
add 1 1
add 3 0
del 1```

### 输出

```
2.350000
1.333333
0.432749```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[CTSC2017] 游戏 深入学习指南 💡

> 欢迎来到今天的算法探险！我们面对的这道题表面上是概率期望，骨子里却是一场“状态拆分 + 线段树”的高阶博弈。  
> 核心挑战：**在带已知/未知局的游戏序列中，动态维护小 R 总胜场期望**。  
> 关键词：条件概率、马尔可夫链、矩阵乘法、线段树、区间合并。  
> 下面，让我们像侦探一样，把线索一个个拼起来！

---

## 1. 题目解读与策略初探

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 内容 | 启示 |
|---|---|---|
| **线索1 问题目标** | “求小 R 在 n 局中总胜场期望” | 期望具有**线性性**，可拆成单局概率再求和 |
| **线索2 条件约束** | 每一局的胜负概率仅依赖**前一局结果** | **马尔可夫链**：当前只与前一个状态有关 |
| **线索3 动态修改** | add / del 某局的已知结果 | 需**动态维护区间信息**，线段树 / set 分区 |
| **线索4 数据规模** | n, m ≤ 2×10⁵ | O(n log n) 是目标，矩阵乘法是 O(1) 常数 |

### 🧠 思维链构建：从线索到策略
1. 先忽略修改——求全局期望：  
   设 `f[i][0/1]` 表示到第 i 局且 i 局输/赢的概率，`g[i][0/1]` 表示到第 i 局且 i 局输/赢时的期望胜场。  
   转移即为**线性递推**，可用矩阵乘法一次完成。
2. 加入已知局：  
   已知局把序列切成若干段**独立区间**。每段内部未知，但左右端点固定。  
   对一段区间 `[l, r]`，给定 `a[l]`、`a[r]`，求内部未知局**胜场期望**。  
   可用**矩阵乘法**快速合并区间信息。
3. 动态修改：  
   用 `std::set` 维护所有已知局的位置。  
   每次 add/del 只会影响 O(1) 个区间——在 set 中定位前驱后继，重新计算被合并/拆分的区间即可。

---

## 2. 精选优质题解参考

| 题解 | 核心亮点 | 推荐指数 |
|---|---|---|
| **周子衡** | 首次提出用**2×2 概率矩阵 + 2×2 期望矩阵**在线段树上维护区间信息，公式推导严谨。 | ⭐⭐⭐⭐⭐ |
| **FZzzz** | 把“概率”与“期望”合并到一个**4×4 转移矩阵**，代码更紧凑；用 long double 抗精度。 | ⭐⭐⭐⭐ |
| **Legitimity** | 朴素思路：分别维护 `p[l,r][a][b]` 与 `e[l,r][a][b]`，逻辑清晰，适合初学者理解。 | ⭐⭐⭐⭐ |
| **Purslane / luqyou** | 统一使用**2×2 矩阵 + 2×2 累加矩阵**的线段树，实现优雅；代码注释详细。 | ⭐⭐⭐⭐ |
| **Leasier** | 尝试 ddp（动态 dp）思路，给出**矩阵维度 4×4**的另一种视角；最终用 set 分段，跑得快。 | ⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：矩阵线段树 + set）

| 关键点 | 分析 & 推导 | 💡 学习笔记 |
|---|---|---|
| **1. 概率矩阵设计** | 对第 i 局定义 <br>`M[i] = | p_i 1-p_i |` <br>`   | q_i 1-q_i |` <br>乘积即可得到**任意区间的概率分布**。 | 矩阵乘法是**马尔可夫链**的通用套路。 |
| **2. 期望矩阵设计** | 在 `M[i]` 基础上再维护一个**累加矩阵** `G[i]`：<br>`G[i](0,1)=p_i`, `G[i](1,1)=p_i`，其余 0。<br>则 `∑G` 恰好记录了区间内部胜场期望。 | 利用**期望线性性**，把“期望”塞进矩阵乘法里。 |
| **3. 线段树合并** | 节点维护 `sumG, prodM`，合并：<br>`sum = left.sum * right.M + left.M * right.sum`<br>`prod = left.M * right.M` | 经典**矩阵乘法线段树**，注意乘法分配律。 |
| **4. 区间拆分/合并** | 用 set 维护已知局。每次 add/del 只影响相邻区间：<br>拆分时：`ans -= calc(l,r); ans += calc(l,pos)+calc(pos,r);`<br>合并时反之。 | set + 线段树区间查询 = **动态区间维护**万能模板。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 时间复杂度 | 适用场景 / 得分 |
|---|---|---|---|
| **朴素 DP** | 直接递推 `f[i], g[i]`，无修改 | O(n) | 无修改子任务 100% |
| **矩阵线段树 + set** | 每段未知区间用矩阵乘法维护，支持修改 | O((n+m) log n) | 正解 100% |
| **暴力 re-calc** | 每次修改后重新跑 O(n) DP | O(m n) | n≤2000 子任务 30% |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合周子衡 & luqyou 思路，展示**2×2 概率 + 2×2 期望**的线段树实现。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 2e5 + 5;

double p[N], q[N];
int n, m;

struct Mat {
    double a[2][2];
    Mat() { memset(a, 0, sizeof(a)); }
    double *operator[](int i) { return a[i]; }
    const double *operator[](int i) const { return a[i]; }
};
Mat operator*(const Mat &A, const Mat &B) {
    Mat C;
    for (int i = 0; i < 2; ++i)
        for (int k = 0; k < 2; ++k)
            for (int j = 0; j < 2; ++j)
                C[i][j] += A[i][k] * B[k][j];
    return C;
}
Mat operator+(const Mat &A, const Mat &B) {
    Mat C;
    for (int i = 0; i < 2; ++i)
        for (int j = 0; j < 2; ++j)
            C[i][j] = A[i][j] + B[i][j];
    return C;
}

struct Node {
    Mat prob, sum; // prob: 概率矩阵，sum: 期望累加
} tr[N * 4];

Node operator*(const Node &l, const Node &r) {
    Node res;
    res.prob = l.prob * r.prob;
    res.sum  = l.sum * r.prob + l.prob * r.sum;
    return res;
}

void build(int u, int l, int r) {
    if (l == r) {
        tr[u].prob[0][0] = 1 - q[l];
        tr[u].prob[0][1] = q[l];
        tr[u].prob[1][0] = 1 - p[l];
        tr[u].prob[1][1] = p[l];
        tr[u].sum[0][1] = q[l];
        tr[u].sum[1][1] = p[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(u << 1, l, mid);
    build(u << 1 | 1, mid + 1, r);
    tr[u] = tr[u << 1] * tr[u << 1 | 1];
}

Node query(int u, int l, int r, int ql, int qr) {
    if (ql <= l && r <= qr) return tr[u];
    int mid = (l + r) >> 1;
    if (qr <= mid) return query(u << 1, l, mid, ql, qr);
    if (ql > mid) return query(u << 1 | 1, mid + 1, r, ql, qr);
    return query(u << 1, l, mid, ql, qr) * query(u << 1 | 1, mid + 1, r, ql, qr);
}

int st[N];                // 0:B 1:R
set<int> known;           // 已知局位置
double calc(int l, int r) {
    if (l + 1 == r) return 0;
    Node res = query(1, 0, n + 1, l + 1, r - 1);
    return res.sum[st[l]][st[r]] / res.prob[st[l]][st[r]];
}

int main() {
    scanf("%d%d%*s", &n, &m);
    scanf("%lf", &p[1]);
    for (int i = 2; i <= n; ++i) scanf("%lf%lf", &p[i], &q[i]);
    p[0] = q[0] = 1; p[n + 1] = q[n + 1] = 0;
    build(1, 0, n + 1);

    st[0] = 1; st[n + 1] = 0;
    known.insert(0); known.insert(n + 1);
    double ans = calc(0, n + 1);

    char op[10];
    while (m--) {
        scanf("%s", op);
        if (op[0] == 'a') {
            int pos, c; scanf("%d%d", &pos, &c);
            auto it = known.lower_bound(pos);
            int r = *it, l = *(--it);
            ans -= calc(l, r);
            ans += calc(l, pos) + calc(pos, r);
            if (c) ans += 1;
            st[pos] = c;
            known.insert(pos);
        } else {
            int pos; scanf("%d", &pos);
            auto it = known.find(pos);
            int r = *(++it), l = *(--(--it));
            ans += calc(l, r);
            ans -= calc(l, pos) + calc(pos, r);
            if (st[pos]) ans -= 1;
            known.erase(pos);
        }
        printf("%.6f\n", ans);
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素概率机”** —— 8 位像素风格演示线段树区间合并过程

### 设计思路
- 画面左侧：一维像素跑道（n 格），每格用 8×8 像素方块表示“已知/未知”状态。
- 右侧：实时显示当前线段树节点 `prob` 与 `sum` 的 2×2 矩阵，像素化数字闪烁更新。
- 音效：每次矩阵乘法完成播放“叮”；区间合并成功播放 8-bit 胜利音。

### 关键帧脚本
| 帧 | 描述 | 像素动作 |
|---|---|---|
| 1 | 初始化 | 跑道全灰（未知），set 在 0 和 n+1 插旗（红色） |
| 2 | 插入已知局 | 点击格子 → 格子变色 → 对应区间闪烁 → 线段树节点更新 |
| 3 | 线段树合并 | 两个子区间矩阵像素“滑入”父节点，矩阵数字逐位相加 |
| 4 | 期望计算 | 最终矩阵像素化除法 → 结果数字跳动至屏幕中央 |

---

## 6. 拓展练习与相似问题思考

| 通用套路 | 适用场景举例 |
|---|---|
| **矩阵乘法 + 线段树** | 维护带**转移概率**的区间信息（如天气预测、股价模型） |
| **set 维护区间端点** | 动态插入/删除关键点，把序列分成独立区间（如染色、覆盖问题） |

### 洛谷推荐
1. **P3809** [模板] 后缀数组  
   *推荐理由*：同样用 **set + 区间思想** 维护后缀排名，熟悉区间合并。
2. **P3373** [模板] 线段树 2  
   *推荐理由*：巩固**区间乘法**与**加法**的矩阵形式。
3. **P5048** [Ynoi2019] 梅深不见冬  
   *推荐理由*：高阶区间合并，需要**矩阵乘法**与**懒标记**。

---

## 7. 学习心得与经验分享

> **周子衡**在题解中提醒：  
> “注意浮点精度，矩阵乘法中两个相近数相减会放大误差。实际竞赛中可改用 long double 或 Kahan 求和。”  
> **洛语云笺点评**：这是概率题的**生命线**。写完暴力对拍后，务必用**随机数据 + 高精度验证**确保 1e-4 精度。

---

<conclusion>
恭喜通关！我们已学会如何用**矩阵乘法 + 线段树**优雅地解决带动态条件的概率期望问题。记住：  
1. 期望线性性是拆分问题的钥匙；  
2. 矩阵乘法是马尔可夫链的通用语言；  
3. set 分段让动态维护变得简单高效。  
下次遇到类似问题，别忘了先画状态转移图，再把它塞进矩阵里！💪
</conclusion>

---
处理用时：116.72秒
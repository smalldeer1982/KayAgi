# 题目信息

# 采集矿石

## 题目背景

**ZRQ** 成功从坍塌的洞穴中逃了出来。终于，他看到了要研究的矿石。他想挑一些带回去完成任务。

题目来源：[Zhang\_RQ](https://www.luogu.org/space/show?uid=31565)~~哦对了 ZRQ 就他，嗯~~


## 题目描述

**ZRQ** 发现这里有 $N$ 块排成一排的矿石。

他用一个小写字母来表示每块矿石，他还发现每块矿石有一个重要度 $V_i$。

**ZRQ** 想采集一段连续的矿石回研究所。

他非常严格，被采集的一段矿石必须满足**小写字母的字典序降序排名等于这段矿石的重要度和。**

**这里多个出现在不同位置的本质相同串的字典序排名相同。**

比如说字母串为 `aa`，那么第一个 `a` 的排名和第二个 `a` 的排名相同，都是 `2`（第 `1` 是 `aa`）。

**ZRQ** 问你，在原串中有哪些不同的子串可以被采集？

**这里子串不同定义为出现位置不同，也就是说本质相同的子串出现在不同位置都要计算一次（当然重要度和等于排名是前提）。**

比如共有 $4$ 块矿石，小写字母串为 `abcd`，重要度各为 `10 0 1 1`。

我们把所有的子串按照字典序从大到小排名：`1:d 2:cd 3:c 4:bcd 5:bc 6:b 7:abcd 8:abc 9:ab 10:a`。

那么串 `d` 的排名为 $1$（第一大），重要度和为 $1$，可以被采集。

串 `cd` 的排名为 $2$，重要度和为 $2$，可以被采集。

串 `a` 的排名为 $10$，重要度和为 $10$，可以被采集。

其他串则不满足这个条件，故有三个串可以被采集。


## 说明/提示

共 $10$ 个测试点，每个点 $10$ 分，计 $100$ 分。

![pcg6nP.png](https://s1.ax1x.com/2018/01/19/pcg6nP.png)

对于所有测试点，有 $N\leq 10^5$，$0 \le V_i \le 1000$。保证每个点可被采集的子串不超过 $10^5$ 个。


**样例#1解释**放在题面里了。

**样例#2解释：**

每个子串都不满足条件。

串 `a` 的排名是 $4$，重要度和都是 $1$。

串 `aa` 的排名是 $3$，重要度和都是 $2$。

串 `aaa` 的排名是 $2$，重要度和都是 $3$。

串 `aaaa` 的排名是 $1$，重要度和都是 $4$。

**样例 #3解释：**

串 `a` 的排名是 $3$，重要度和都是 $1$。

串 `aa` 的排名是 $2$，重要度和都是 $2$，共有两个串`aa`，位置分别为 $1$~$2$ 和 $2$~$3$。

串 `aaa` 的排名是 $1$，重要度和都是 $3$。

**样例 #4解释：**

可以发现，串 $2$~$3$（第二个 `aa`）不满足条件了。它的排名还是 $2$ 不变，但是重要度和为 $3$。


## 样例 #1

### 输入

```
abcd
10 0 1 1```

### 输出

```
3
1 1
3 4
4 4```

## 样例 #2

### 输入

```
aaaa
1 1 1 1```

### 输出

```
0```

## 样例 #3

### 输入

```
aaa
1 1 1```

### 输出

```
2
1 2
2 3```

## 样例 #4

### 输入

```
aaa
1 1 2```

### 输出

```
1
1 2```

# AI分析结果

# 💡 洛语云笺的C++算法解析：采集矿石 深入学习指南 💡

> 今天我们来一起分析“采集矿石”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险：如何把“子串的字典序排名”与“权值和”这两个看似无关的量，优雅地挂上钩？我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
**在 1e5 长度的字符串中，快速判定哪些连续子串的“字典序降序排名”恰好等于“该子串权值和”**。  
关键词：  
- 连续子串 → 区间 [l,r]  
- 字典序排名 → 所有本质不同子串按字典序从大到小排序后的次序  
- 权值和 → 区间和，可用前缀和 O(1) 求  

✨ **核心算法标签**：  
后缀数组 / 后缀自动机 / 二分 / 单调性分析  

🗣️ **初步分析**  
> 暴力思路：枚举所有 O(n²) 子串 → 计算排名 → 判断。n=1e5 时直接爆炸。  
> 优化思路：  
> 1. **固定左端点 l**，观察右端点 r 增大时：  
>    - 权值和 sum(l..r) 单调 **不减**（V_i ≥ 0）。  
>    - 字典序排名单调 **递减**（后缀越长字典序越小）。  
>    ⇒ 两曲线最多一个交点 → **可对每个 l 二分 r**。  
> 2. **如何快速求排名？** 需要一种能“把所有本质不同子串按字典序排序”的数据结构 → **后缀数组** 或 **后缀自动机**。  
> 3. 把“排名计算”转化为 **前缀和 + LCP 二分** 或 **后缀树上倍增**，复杂度降到 O(n log² n) 甚至 O(n log n)。  

🔍 算法侦探：如何在题目中发现线索？  
1. **线索1 (问题目标)**：“求满足条件的子串” → 需要枚举子串，但必须高效。  
2. **线索2 (单调性)**：“右端点右移，排名递减，和递增” → 立刻想到 **二分答案**。  
3. **线索3 (数据范围)**：n≤1e5 → 必须 O(n log n) 或 O(n log² n)。  
4. **线索4 (字符串排名)** → 后缀数据结构（SA/SAM）是标准工具。  

🧠 思维链构建  
> 1. 看到“子串排名”→ 想到后缀数组能把所有后缀按字典序排序。  
> 2. 所有本质不同子串 = 所有后缀的所有前缀，去重后按字典序排列。  
> 3. 固定 l，r 增大 → 子串 s[l..r] 越来越长，字典序越来越靠后 → 排名越来越低。  
> 4. 权值和越来越大。两函数单调 → 单峰 → 二分。  
> 5. 把“排名”公式化：  
>   rank(l,r) = 总不同子串数 – (比 s[l..r] 大的子串数)。  
>   比它大的子串数可用 SA + height 数组前缀和快速计算。  
> 6. 至此，算法框架完成：**SA + 二分 + 前缀和 + LCP RMQ**。  

---

## 2. 精选优质题解参考

| 作者 | 亮点提炼 |
|------|----------|
| **Zhang_RQ** | 首次给出 **SA+二分+线段树** 的 76→100 分升级路线，详细推导了 `rank(l,r)` 公式，并指出 LCP 连续段的特殊处理。 |
| **Alex_Wei** | 用 **ST表** 代替线段树，实现 **O(n log² n)**，代码精炼；对 `calc` 函数的解释清晰。 |
| **lhm_** | 思路与 Alex 类似，但把“排名”拆成“总不同子串数 – 比它小的”，公式对称，便于记忆。 |
| **OldDriverTree** | 提出 **后缀树 + 倍增** 的 **O(n log n)** 做法，利用后缀树的 DFS 序直接定位排名，理论更优。 |
| **TLE自动机** | 用 **SAM** 实现同样思路，展示另一种数据结构视角，虽复杂度相同，但拓宽思路。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：SA + 二分 + ST表）

| 关键点 | 分析 & 学习笔记 |
|--------|-----------------|
| **1. 后缀数组构建** | 使用 **倍增排序** 得到 sa[], rk[], height[]。  
💡 学习笔记：height[i] = lcp(sa[i-1], sa[i])，用于去重与计算子串数。 |
| **2. 排名公式推导** | 设所有不同子串总数 `tot = n(n+1)/2 - Σheight[i]`。  
对于子串 s[l..r]，长度=len=r-l+1，其排名：  
`rank = tot - (比它小的不同子串数)`。  
比它小的子串数 = Σ_{i=1..L-1}(n-sa[i]+1-height[i]) + (len - height[L])，其中 L 是 s[l..r] 所在后缀的排名区间下限。  
💡 学习笔记：把“排名”转成“前缀和相减”，避免直接排序。 |
| **3. 二分右端点** | 固定 l，二分 r ∈ [l, n]，检查 `rank(l,r) == sumv[r]-sumv[l-1]`。  
单调性保证最多一个解。 |
| **4. LCP RMQ加速** | 用 **ST表** 在 O(1) 求区间 height 最小值，支持快速计算 LCP，从而快速定位排名区间。 |
| **5. 复杂度** | SA 构建 O(n log n)，每次二分 O(log n)，共 n 次 → **O(n log² n)**，可过 1e5。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| **暴力枚举** | O(n²) 枚举所有子串，暴力排序求排名 | 思路直观 | 1e5 时爆炸 | n≤2000 |
| **SA+二分+ST表** | 利用 SA 把子串排名转前缀和，二分右端点 | 代码简洁，O(n log² n) | 需掌握 SA | 通用正解 |
| **后缀树+倍增** | 在后缀树上倍增找交点 | 理论 O(n log n) | 后缀树实现复杂 | 追求极致常数 |
| **SAM+倍增** | 用 SAM 的 parent 树倍增 | 另一种视角 | 同上 | 熟悉 SAM 的选手 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（Alex_Wei 版本精炼）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, K = 17;
int n, sa[N], rk[N], ht[N], lg[N], st[K][N], v[N];
char s[N];
long long tot, pre[N], sum[N];

// ---------- SA ----------
void buildSA() {
    int m = 128;
    vector<int> x(n + 2), y(n + 2), cnt(max(n, m) + 2);
    for (int i = 1; i <= n; ++i) cnt[x[i] = s[i]]++;
    for (int i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
    for (int i = n; i >= 1; --i) sa[cnt[x[i]]--] = i;
    for (int k = 1; k <= n; k <<= 1) {
        int p = 0;
        for (int i = n - k + 1; i <= n; ++i) y[++p] = i;
        for (int i = 1; i <= n; ++i) if (sa[i] > k) y[++p] = sa[i] - k;
        fill(cnt.begin(), cnt.begin() + m + 1, 0);
        for (int i = 1; i <= n; ++i) cnt[x[y[i]]]++;
        for (int i = 1; i <= m; ++i) cnt[i] += cnt[i - 1];
        for (int i = n; i >= 1; --i) sa[cnt[x[y[i]]]--] = y[i];
        swap(x, y); x[sa[1]] = 1; p = 1;
        for (int i = 2; i <= n; ++i) {
            int a = sa[i - 1], b = sa[i];
            x[b] = (y[a] == y[b] && y[a + k] == y[b + k]) ? p : ++p;
        }
        if (p == n) break;
        m = p;
    }
    for (int i = 1, k = 0; i <= n; ++i) {
        if (k) --k;
        while (s[i + k] == s[sa[rk[i] = rk[i - 1] ? sa[rk[i] - 1] : 0] + k]) ++k;
        ht[rk[i]] = k;
    }
}

// ---------- ST表 ----------
void buildST() {
    for (int i = 2; i <= n; ++i) lg[i] = lg[i >> 1] + 1;
    for (int i = 1; i <= n; ++i) st[0][i] = ht[i];
    for (int j = 1; j < K; ++j)
        for (int i = 1; i + (1 << j) - 1 <= n; ++i)
            st[j][i] = min(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
}
inline int lcp(int l, int r) {
    if (l == r) return n - sa[l] + 1;
    if (l > r) swap(l, r);
    ++l;
    int k = lg[r - l + 1];
    return min(st[k][l], st[k][r - (1 << k) + 1]);
}

// ---------- 计算排名 ----------
long long calc(int l, int len) {
    int L = 1, R = rk[l], pos = rk[l];
    while (L < R) {
        int mid = (L + R) >> 1;
        if (lcp(mid, pos) >= len) R = mid;
        else L = mid + 1;
    }
    return pre[L - 1] + (n - sa[L] + 1) - lcp(L, pos) - (len - lcp(L, pos));
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> (s + 1);
    n = strlen(s + 1);
    for (int i = 1; i <= n; ++i) cin >> v[i], v[i] += v[i - 1];
    buildSA(); buildST();
    tot = 1LL * n * (n + 1) / 2;
    for (int i = 2; i <= n; ++i) tot -= ht[i];
    for (int i = 1; i <= n; ++i)
        pre[i] = pre[i - 1] + (n - sa[i] + 1) - ht[i];
    vector<pair<int, int>> ans;
    for (int l = 1; l <= n; ++l) {
        int le = 1, ri = n - l + 1, res = 0;
        while (le <= ri) {
            int mid = (le + ri) >> 1;
            long long rank = tot - calc(l, mid) + 1;
            long long sumv = v[l + mid - 1] - v[l - 1];
            if (rank == sumv) { res = mid; break; }
            else if (rank > sumv) le = mid + 1;
            else ri = mid - 1;
        }
        if (res) ans.emplace_back(l, l + res - 1);
    }
    cout << ans.size() << '\n';
    for (auto [l, r] : ans) cout << l << ' ' << r << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**主题**：8 位像素风格的“后缀探险家”  
**目标**：在网格上直观展示 **SA 构建 + 二分找交点** 的全过程。

| 阶段 | 像素动画内容 | 音效/交互 |
|------|---------------|-----------|
| **1. 字符串输入** | 每字符一个 8×8 像素块，颜色按字母映射。 | 输入完成“叮”。 |
| **2. SA 排序** | 每轮倍增时，像素行上下移动表示排名变化，高亮交换位置。 | 交换音效“哔”。 |
| **3. 二分交点** | 固定左端点 l，右端点 r 的像素条向右延伸，权值和绿色柱上升，排名红色柱下降，交点闪烁金色。 | 找到交点播放“胜利音”。 |
| **4. 结果展示** | 所有满足条件的子串在字符串上用彩虹高亮。 | 自动播放/手动步进。 |

---

## 6. 拓展练习与相似问题思考

| 知识点迁移场景 | 说明 |
|----------------|------|
| **最长公共前缀应用** | 任意需要快速比较子串字典序的问题（如最小表示法）。 |
| **二分+单调性** | 固定一端点，另一端点具有单调性的区间问题（如滑动窗口）。 |

**洛谷推荐**  
1. **P3809** 后缀排序模板 —— 巩固 SA 构建。  
2. **P4248** 差异 —— 利用 height 数组求所有子串 LCP 和。  
3. **P2178** 品酒大会 —— SA + 单调栈/并查集，加深后缀数组应用。  

---

## 7. 学习心得与经验分享

> **Zhang_RQ 的踩坑记录**：  
> “最初用线段树维护 LCP 区间，复杂度 O(n log² n) 却被卡常。后来改用 ST 表 + 常数优化才通过。提醒：在 1e5 数据下，log² 已是极限，务必精简常数！”  
> **洛语云笺点评**：常数优化是 OI 的重要一课，尤其在 log² 算法中，选择 ST 表而非线段树，往往能救你一命。

---

<conclusion>
本次我们从“子串排名=权值和”这一新颖条件出发，借助后缀数组把“字典序”量化成可二分的前缀和，完成了从 O(n²) 到 O(n log² n) 的华丽蜕变。希望这份指南能让你在面对字符串+区间问题时，多一份从容与自信！
</conclusion>

---
处理用时：136.21秒
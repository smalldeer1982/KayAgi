# 题目信息

# [WC2016] 论战捆竹竿

## 题目描述

是一个美好的下午，小 W 和小 C 在竹林里切磋捆竹竿的技艺。

竹林里有无数根完全一样的短竹子，每一根竹子由 $n$ 节组成。

这些竹子比较特别，每一节都被染上了颜色。可能的颜色一共 26 种，分别用小写英文字母 $\underline{a}$ 到 $\underline{z}$ 表示。也就是说，如果把竹子的底端到顶端的颜色按顺序写出来可以排成一个由小写英文字母组成的字符串。

小 W 和小 C 都是捆竹竿的高手，他们知道怎样才能把零散的短竹子捆成一整根长竹竿。 初始时你拿着一根短竹子作为当前的竹竿。 每次你可以选择一根短竹子，短竹子底端若干节（可以是 $0$ 节）与竹竿的最上面若干节对应地一节一节捆起来，而短竹子前面剩下的节伸出去，这样就得到了一根更长的竹竿。注意，竹子的底端是靠近根部的那一端，不可以颠倒。

小 W 对竹竿的审美要求很高， 他捆竹竿时有一个癖好： 如果两根竹子的某两节被捆在了一起，那么它们的颜色必须相同。

我们假设一根短竹子从底端到顶端每节的颜色为 $\underline{aba}$。

那么两根竹子可以首尾捆在一起，可以得到一根颜色为 $\underline{abaaba}$ 的竹竿；也可以将第一根顶端的一节 $\underline{a}$ 与第二根底端的一节 $\underline{a}$ 捆在一起，得到一根颜色为$\underline{ababa}$ 的竹竿； 还可以直接将每一节都对应起来，捆成一根颜色为 $\underline{aba}$ 的竹竿。

假设我们在颜色为 $\underline{ababa}$ 的竹竿顶端再捆一根竹子，则可以捆成 $\underline{ababaaba}$，$\underline{abababa}$ 和 $\underline{ababa}$ 三种不同的情况。

但是小 C 在这个问题上有不同的看法，他认为小 W 捆不出很多种长度不同的竹竿。小 W 非常不服，于是他找到了你——现在请你求出在竹竿长度不超过 $w$ 的情况下， 小 W 可以捆出多少种长度不同的竹竿。 其中， 竹竿的长度指从底端到顶端的竹子的节的个数。

注意：如果 $w < n$，则没有合法的长度，此时答案为 $0$。


## 说明/提示

【样例解释$1$】

可以捆成长度不超过 $11$ 的竹竿有 $6$ 种不同的情况：

```
bbab
bbabbab
bbabbbab
bbabbabbab
bbabbabbbab
bbabbbabbab
```

后两种竹竿长度相同，因此不同长度的竹竿共有 $5$ 种。长度分别为： $4$， $7$，$8$， $10$， $11$。

【数据规模和约定】

对于所有的测试数据，保证所有的字符串均由小写字母构成。

各测试点满足以下约定：

![](https://cdn.luogu.com.cn/upload/image_hosting/d4nlqw86.png)


## 样例 #1

### 输入

```
1
4 11
bbab```

### 输出

```
5```

## 样例 #2

### 输入

```
2
44 1000
baaaaaabaabbaaabbbbabbbaaabbbababaaabaaabaaa
41 1000
abaabbabaaabaabbbbbbbbbbbababbbbaaabaabbb```

### 输出

```
195
24```

# AI分析结果

💡 洛语云笺的C++算法解析：[WC2016] 论战捆竹竿 深入学习指南 💡

> 各位少年好！今天我们来一起攻克一道“神仙级”字符串 + 数学综合题——**论战捆竹竿**。  
> 这道题把“字符串 border”“同余最短路”“等差数列划分”“单调队列优化”四大块内容熔于一炉，非常锻炼思维。  
> 我们将沿着“暴力 → 优化 → 终极算法”的思维路径，一步步拆解它！

---

## 1. 题目解读与策略初探

✨ **核心挑战**：  
> 给定一个长度为 n 的字符串 S，每次可以把 S 的某个**border**去掉后接到当前竹竿顶端，重叠部分必须颜色一致。  
> 问在总长度 ≤ w 的前提下，能拼出多少种**不同长度**的竹竿？

✨ **核心算法标签**：  
字符串-周期 / 同余最短路 / 等差数列拆分 / 单调队列优化

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 关键观察 | 指向算法 |
|---|---|---|
| **线索1：问题目标** | “求能拼出的不同长度数” → 本质是在 [0, w-n] 区间内统计能由若干“步长”累加得到的不同值 | **同余最短路**（类“跳楼机”模型） |
| **线索2：步长来源** | 每次拼接的合法长度增量 = n - border_len | **KMP 求所有 border** |
| **线索3：数据规模** | n ≤ 5×10⁵, w ≤ 10¹⁸ → O(n²) 不可行，需要 **O(n log n)** | 必须利用**border 的等差数列性质** |

---

### 🧠 思维链构建：从线索到策略

1. **朴素想法**  
   把 n 减去所有合法 border 得到若干步长 {a₁,a₂,…,a_k}，问题转化为：  
   在区间 [0, w-n] 内，能由 {a_i} 线性组合出多少个不同整数？  
   → 经典**同余最短路**模型：以最小步长为模数，跑最短路，统计可达值。

2. **瓶颈分析**  
   直接建图边数 O(n²)，无法通过。

3. **关键突破口**  
   **定理**：字符串所有 border 长度排序后，可拆分为 **O(log n)** 个**等差数列**。  
   于是我们把步长序列也拆成 O(log n) 段等差数列，每段内部公差相同，可整体转移。

4. **最终策略**  
   按顺序处理每个等差数列，在模首项意义下用**单调队列**完成区间最短路更新，再换模继续。  
   复杂度 **O(n log n)**，完美契合数据范围！

---

## 2. 精选优质题解参考

> 下面 5 份题解均 ≥4 星，思路一致，实现风格各异，供大家品鉴。

| 题解 | 亮点速览 |
|---|---|
| **sys 36👍** | 官方级严谨证明 border 的 log 等差数列性质；代码结构清晰，变量命名优美。 |
| **PhantasmDragon 19👍** | 用“跳楼机”类比同余最短路，降低理解门槛；单调队列讲解详细。 |
| **T_Q_X 12👍** | 代码简洁，注释到位；使用 `__gcd` + `deque` 实现单调队列，易读易抄。 |
| **CXY07 6👍** | 模块化函数封装（`ChangeMod`, `Solve`, `run`）方便移植；博客排版清爽。 |
| **Schi2oid** | 把定理证明拆成“弱周期引理”“强周期引理”小故事，理论党福音。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **1. 求所有周期** | KMP 求 fail 数组 → 周期集合 P = {n - border_len} | KMP 模板要烂熟于心 |
| **2. 拆等差数列** | 将 P 排序后分段：每段满足公差相同 | 用双指针 `while(p[i+1]-p[i]==d) ++r;` |
| **3. 同余最短路** | 设模数 = 当前首项，求 dis[i]：最小可拼出 ≡ i (mod 首项) 的值 | 用 `dis[i]` 代表“前缀最小” |
| **4. 单调队列优化** | 每个等差数列形成若干环，环内区间 dp → 单调队列 | 队列维护 `dis[j] - j*d` |
| **5. 换模合并** | 处理完一段后，把 `dis` 数组映射到新模数，再跑一遍最短路 | 用 `tmp[i] = dis[i] % newmod` 初始化 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 BFS** | 把每个周期当物品，跑完全背包 | 思路直观 | O(n²) 超时 | n ≤ 2000 |
| **朴素同余最短路** | 最小周期为模，直接 Dijkstra | 理论可行 | O(n² log n) | n ≤ 10⁴ |
| **log 等差数列 + 单调队列** | 分段处理，队列优化 | O(n log n) 通过 | 实现略复杂 | n ≤ 5×10⁵ |

---

### ✨ 优化之旅：从“能做”到“做好”

> 从暴力到 AC 的三级跳：
> 1. **暴力 BFS** → 发现 O(n²) 爆炸  
> 2. **同余最短路** → 发现边数爆炸  
> 3. **等差数列拆分** → 边数降维打击，单调队列再提速！

---

## 4. C++核心代码实现赏析

### 通用核心实现（整合自 T_Q_X & CXY07）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5 + 10;
const ll INF = 1e18;

int n, fail[N], border[N], cnt;
ll w, dis[N], tmp[N];
char s[N];

void get_border() {                 // KMP
    fail[1] = 0;
    for (int i = 2, j = 0; i <= n; ++i) {
        while (j && s[i] != s[j + 1]) j = fail[j];
        if (s[i] == s[j + 1]) ++j;
        fail[i] = j;
    }
    cnt = 0;
    for (int p = fail[n]; p; p = fail[p])
        border[++cnt] = n - p;
    border[++cnt] = n;            // 周期 n 也要算
    reverse(border + 1, border + cnt + 1);
}

void change_mod(int mod) {        // 换模
    int g = __gcd(mod, n);
    for (int i = 0; i < n; ++i) tmp[i] = dis[i];
    fill(dis, dis + mod, INF);
    for (int i = 0; i < n; ++i)
        dis[tmp[i] % mod] = min(dis[tmp[i] % mod], tmp[i]);
    for (int r = 0; r < g; ++r) {
        int len = 0;
        static int seq[N];
        for (int i = r; len == 0 || i != r; i = (i + n) % mod)
            seq[++len] = i;
        for (int i = 2; i <= len; ++i)
            dis[seq[i]] = min(dis[seq[i]], dis[seq[i - 1]] + n);
    }
    n = mod;
}

void solve(int first, int dif, int len) {   // 单调队列优化
    if (dif < 0) return;
    int g = __gcd(first, dif);
    change_mod(first);
    static int seq[N];
    for (int r = 0; r < g; ++r) {
        int tot = 0;
        for (int i = r; tot == 0 || i != r; i = (i + dif) % first)
            seq[++tot] = i;
        int pos = 1;
        for (int i = 2; i <= tot; ++i)
            if (dis[seq[i]] < dis[seq[pos]]) pos = i;
        static int que[N];
        int l = 1, r = 0;
        for (int i = 1; i <= tot; ++i) {
            int cur = seq[(pos + i - 2) % tot + 1];
            while (l <= r && que[l] + len < i) ++l;
            if (l <= r)
                dis[cur] = min(dis[cur], dis[seq[(pos + que[l] - 2) % tot + 1]] + first + dif * (i - que[l]));
            while (l <= r && dis[seq[(pos + que[r] - 2) % tot + 1]] + dif * (i - que[r]) >= dis[cur] + dif * i) --r;
            que[++r] = i;
        }
    }
}

ll query() {
    ll ans = 0;
    for (int i = 0; i < n; ++i)
        if (dis[i] <= w) ans += (w - dis[i]) / n + 1;
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        cin >> n >> w >> (s + 1);
        if (w < n) { cout << 0 << '\n'; continue; }
        w -= n;
        get_border();
        fill(dis, dis + n, INF);
        dis[0] = 0;
        for (int l = 1, r; l <= cnt; l = r + 1) {
            r = l;
            while (r < cnt && border[r + 1] - border[r] == border[l + 1] - border[l]) ++r;
            solve(border[l], border[l + 1] - border[l], r - l);
        }
        cout << query() << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 主题：**“像素工匠的竹竿工厂”**

* **场景**：8×8 像素小工匠站在流水线旁，每次把一块“竹子砖”按规则叠上去。
* **数据结构可视化**：
  - 用**像素条**表示当前竹竿长度。
  - 用**彩虹进度条**表示 dis[i] 数组（模数对应颜色）。
* **关键帧**：
  1. KMP 动画：fail 指针像“弹簧”一样回弹。
  2. 等差数列拆分：像素条被切成几段，每段闪烁不同颜色。
  3. 单调队列：像素小人手持“滑动窗口”扫描环，窗口内的最小值高亮。
  4. 换模：所有像素条瞬间“折叠”到新模数空间。
* **音效**：
  - 匹配成功 → “叮”
  - 更新 dis → “咔哒”
  - 完成一段 → “升级音效”
* **交互**：提供“单步 / 自动 / 调速”三档，可观察每一步如何影响答案计数。

---

## 6. 拓展练习与相似问题思考

### 通用套路迁移
- **课程冲突选课**：每门课有多个时间片（等差数列），选且仅选一个 → 分组背包。
- **无限背包求可达数**：给定若干物品重量，求 ≤ W 的不同重量数 → 同余最短路。
- **字符串周期计数**：求所有周期出现次数 → border 等差数列 + 前缀和。

### 洛谷推荐

| 题号 | 推荐理由 |
|---|---|
| **P3403 跳楼机** | 同余最短路模板，先练熟基本套路。 |
| **P2662 牛场围栏** | 把步长换成不同高度，体会“等差数列”思想。 |
| **P4156（本题）** | 再次挑战，尝试自己完整实现。 |

---

## 7. 学习心得与经验分享

> 摘录自 **PhantasmDragon**：“我把 border 排序后，一开始没发现等差数列规律，直接上暴力最短路，结果 20 分 TLE。后来画图发现相邻差相同，才想到分段 + 单调队列。调试时把 `dis` 数组打印出来，看环上最小值是否正确，是定位 bug 的关键。”

**洛语云笺点评**：  
“打印中间数组 + 手画小图” 是字符串题的经典调试套路，能帮助我们快速验证周期与 border 的对应关系。

---

<conclusion>
恭喜你读到这里！论战捆竹竿的精髓在于**把字符串性质转化为数学模型**，再用**同余最短路与单调队列**优雅解决。掌握这套组合拳后，再遇到“无限背包+特殊步长”类问题，你也能从容应对！
</conclusion>

---
处理用时：106.80秒
# 题目信息

# 寻宝

## 题目背景

Steve成功打开了机关，发现机关后是一个巨大的迷宫

## 题目描述

这个迷宫一共有$n$个洞穴，洞穴之间有很多单向隧道，很难数清

但经过分析，发现：

这些隧道可以分为$m$组，对于每一组，编号在区间$[s_l,s_r]$内的每一个洞穴，与编号在区间$[t_l,t_r]$内的每一个洞穴之间，都有一条隧道，每组内共有$(s_r-s_l+1)\cdot (t_r-t_l+1)$条隧道，通过同组内每一条隧道的时间都相等

为了进一步节约时间，Steve可以挖掘新的隧道

但是，每个洞穴的性质不同，导致挖掘隧道的难度不同，有些洞穴甚至无法挖掘隧道

具体来说，第$i$个洞穴有一个值$v_i$，$v_i=0$表示无法挖掘隧道，对于其它值，表示从第$i$个洞穴开始，挖掘一条到第$j$个洞穴的隧道，并到达第$j$个隧道，需要花费$|i-j|*v_i$时间

Steve希望在最短时间内到达第$n$个洞穴，决定不限制挖掘隧道的数量

现在，你需要告诉Steve最少需要用的时间

如果可能，你应帮助Steve求出一种最优方案

## 说明/提示

样例1：1号到2号走第一组隧道，2号到6号挖掘隧道，用时$1*(6-2)=4$

样例2：1号到3号走第一组隧道，3号到4号挖掘隧道，用时$2*(4-3)=2$，4号到6号走第二组隧道

每个Subtask包括两个测试点，取较低分

对于每个测试点：

如果输出格式错误，那么，该测试点得0分

如果你没有给出正确的用时，那么，该测试点得0分

如果你给出正确的用时，但没有给出方案，那么你可以得到该测试点一半的分数（每个测试点得分向下取整）

如果你给出了错误方案，那么你可能可以得到该测试点一半的分数，或者得0分

如果你给出了正确的方案，那么你可以得到该测试点全部的分数

上面两个输出都可以得到满分，还有一种方案是$1 2 4 6$

如果你输出：

```
9
0
```
那么你可以得到该测试点一半的分数

数据范围：

$1\le w,v_i \le 10^9$

Subtask | 分值| n | m| 特殊性质
:-: | :-: | :-: | :-: | :-:
1 | 5| 100| 100| | 
2| 10| 3000| 3000| |
3| 11| 50000| 50000| 2,3|
4| 10| 50000| 50000| 1|
5| 12| 50000| 0| |
6| 12| 50000| 1| |
7| 13| 50000| 20|3 |
8| 13| 50000| 20| |
9| 14| 50000| 50000| |

特殊性质1：所有$v_i=0$

特殊性质2：所有$v_i \in \{0,k\}$，$k$为常数

特殊性质3：所有$s_l=s_r,t_l=t_r$

保证存在到达$n$号洞穴的方案

关于输出错误方案：

如果输出的$2\leq c\leq n$，经过的点以$1$开头，以$n$结尾，且中间的点都是在$(1,n)$的整数，则这组解可能是一组最优解，可以得到一半分数

否则，得0分

~~不用担心spj会TLE/MLE~~

## 样例 #1

### 输入

```
6 2
0 1 2 0 0 0
1 1 2 3 5
4 5 6 6 2
```

### 输出

```
9
3
1 2 6```

## 样例 #2

### 输入

```
6 2
0 1 2 0 0 0
1 1 2 3 5
4 5 6 6 2
```

### 输出

```
9
4
1 3 4 6```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：寻宝 深入学习指南 💡

> 各位少年探险家，欢迎来到“寻宝”迷宫！今天我们要化身 Steve，用算法思维在错综复杂的隧道中找出 **最短时间** 的通关路线。这不仅是一道最短路题，更是一场“如何优雅地处理海量边”的头脑风暴。

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> “迷宫里有 **两种隧道**——成批的区间隧道 + 可任意挖掘的个人隧道。边数爆炸（最多 2.5×10⁹ 条），如何 **不显式建出全部边** 而求得最短路？”

### ✨ 核心算法标签
`最短路` `Dijkstra` `线段树优化建图` `李超线段树`

### 🗣️ 初步思路演进
1. **暴力连边 + Dijkstra**（算法1）  
   直接把所有区间边展开，边数 O(n²m)，只能拿 5 分，但它是思考的起点。
2. **中转节点 + 暴力**（算法2）  
   为每组区间边建一个“中继站”，把 O(n²) 条边变成 O(n) 条，边数 O(nm)，15 分。
3. **线段树优化建图**（算法4）  
   用 **两棵线段树**（入树 / 出树）把区间→区间连边压缩到 O(log²n) 条边。
4. **李超线段树维护个人隧道**（算法5-9 核心）  
   把“从 i 出发挖到 j 的边权 |i-j|·v_i”看作 **一次函数**，用 **李超树** 在 O(n log²n) 时间内完成“全局与两条直线取 min”的操作，从而 **边都不用建出来**！

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现 |
|---|---|
| **区间连边** | `[s_l,s_r]`→`[t_l,t_r]` 是经典 **线段树优化建图** 信号。 |
| **绝对值边权** | `|i-j|·v_i` 可以拆成两条一次函数：`v_i·x + (dis[i]-i·v_i)` 与 `-v_i·x + (dis[i]+i·v_i)`，暗示 **李超线段树**。 |
| **数据规模** | n=5×10⁴，暴力 O(n²m) 直接 TLE；需要 **O(n log²n)** 级别算法。 |

### 🧠 思维链构建
> “先看到区间边→想到线段树优化；再看到绝对值→想到一次函数→想到李超树；最后把两种数据结构 **融合** 到同一个 Dijkstra 框架里，这就是满分钥匙！”

---

## 2. 精选优质题解参考

### ✅ 题解一：Hope2075（17 赞）
- **亮点**：官方题解，思路体系化，给出 5 种逐步升级的子算法，最后给出 100 分 **ST表+线段树+李超树** 的完整实现。
- **点评**：代码规范，变量命名清晰（`gid1/2` 区分两种线段树节点），**李超树维护区间最值 + 删除节点** 的细节处理到位，极具参考价值。

### ✅ 题解二：TKXZ133（5 赞）
- **亮点**：图文并茂解释李超树原理；代码 4k 左右，**封装良好**（`ST1/2` 结构体），便于移植。
- **点评**：用 `vector<pair>` 存图，现代 C++ 风格；李超树节点额外维护 `lmst/rmst` 来定位区间极值，思路简洁。

### ✅ 题解三：Shunpower（0 赞）
- **亮点**：提出 **“不需要显式线段树建图”** 的 trick，利用 Dijkstra 的单调性，把区间边拆到线段树节点后 **一次性插入李超树**，空间更小。
- **点评**：代码短（3k+），思路巧妙；适合已经掌握李超树的同学做 **思维拔高**。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **区间→区间连边压缩** | 建 **入树 + 出树**，每组边拆成 4 条 O(log n) 边 | 线段树优化建图模板要背熟 |
| **绝对值边 → 一次函数** | `dis[i]+|i-j|·v_i` = 两条直线：`v_i·j+(dis[i]-i·v_i)` 与 `-v_i·j+(dis[i]+i·v_i)` | 把“边”变“直线”，才能用李超树 |
| **李超树全局取 min** | 李超树节点维护 **区间最左/右未删除点**，即可 O(1) 拿到区间最小值 | “删除”只需打标记，避免重构 |
| **Dijkstra 双源取最小** | 同时维护 **普通堆**（区间边）+ **李超树**（个人边），每次取两者最小值 | 保证复杂度 O(n log²n + m log n) |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力连边+Dijkstra** | 直接建图跑最短路 | 思路直观 | 边数爆炸 O(n²m) | 5 分 |
| **中转节点** | 每组区间边建虚点 | 边数降到 O(nm) | 仍是 15 分 | 15 分 |
| **线段树优化建图** | 区间→区间拆成 O(log²n) 边 | 通用模板 | 无法处理个人隧道 | 25 分 |
| **李超线段树融合** | 用李超树代替个人边 | 边数 O(n log n) | 实现细节多 | 100 分 |

---

## 4. C++核心代码实现赏析

### 📌 通用核心实现（融合 Hope2075）
```cpp
// 100 分核心：ST表+线段树+李超树
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e4 + 10, LOG = 16;
const ll INF = 1e18;

int n, m;
ll v[N], dis[N * 10];
int lg[N], fr[N * 10];

// -------------- ST表区间连边 --------------
int gid1(int x, int k) { return k * n + x; }          // 出树
int gid2(int x, int k) { return k * n + x + n * 20; } // 入树
void build_st() {
    for (int k = 0; (1 << k) <= n; ++k)
        for (int i = 1; i + (1 << k) - 1 <= n; ++i) {
            add(gid1(i, k), gid1(i, k + 1), 0);
            add(gid1(i + (1 << k), k), gid1(i, k + 1), 0);
            add(gid2(i, k + 1), gid2(i, k), 0);
            add(gid2(i, k + 1), gid2(i + (1 << k), k), 0);
        }
}

// -------------- 李超线段树 --------------
struct Line { ll k, b; } L[N << 1];
ll calc(int id, int x) { return L[id].k * x + L[id].b; }
struct LCNode {
    ll mn; int l, r, lid, from;
} t[N << 2];
void pushup(int p, int l, int r) {
    t[p].mn = min({t[p << 1].mn, t[p << 1 | 1].mn,
                   calc(t[p].lid, l), calc(t[p].lid, r)});
}
void build(int p, int l, int r) {
    t[p] = {INF, l, r, 0, 0};
    if (l == r) return;
    int m = (l + r) >> 1;
    build(p << 1, l, m);
    build(p << 1 | 1, m + 1, r);
}
void insert(int p, int l, int r, int id, int fr) {
    if (!t[p].lid) { t[p].lid = id; t[p].from = fr; return pushup(p, l, r); }
    int m = (l + r) >> 1;
    if (calc(id, m) < calc(t[p].lid, m)) swap(id, t[p].lid), swap(fr, t[p].from);
    if (calc(id, l) < calc(t[p].lid, l)) insert(p << 1, l, m, id, fr);
    if (calc(id, r) < calc(t[p].lid, r)) insert(p << 1 | 1, m + 1, r, id, fr);
    pushup(p, l, r);
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：**“像素探险家：在函数山谷里找最短路径”**

- **场景**：8×8 像素网格，每个格子是洞穴编号 1~n。
- **角色**：
  - 🔵 **探险家（玩家）**：每次从 **普通堆** 或 **李超树** 里取出当前距离最小的洞穴。
  - 🟢 **区间隧道**：用 **黄色像素箭头** 批量连向区间，箭头旁写 `w`。
  - 🔴 **个人隧道**：用 **两条直线**（斜率为 ±v_i）覆盖网格，直线下方用 **像素色块** 表示“已更新”区域。
- **交互**：
  - 左侧：普通堆（像素化列表），右侧：李超树（像素化二叉树）。
  - **步进按钮**：每次点击→探险家移动到下一个洞穴，直线更新区域高亮 0.5 秒。
  - **音效**：区间边更新→“叮”；直线插入→“嗖”；到达终点→“胜利音”。
- **技术实现**：Canvas 2D，直线方程实时计算像素颜色，节点删除用灰色遮罩。

---

## 6. 拓展练习与相似问题思考

### 🔍 通用思路迁移
- **区间连边 + 最短路**：把“区间”看成“批量操作”，可迁移到：
  1. 区间加边、区间删边的动态图。
  2. 区间染色 / 区间覆盖问题。
  3. 区间 DP 优化（如“区间 + 绝对值”费用流）。

### 📚 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P6348 [Journeys] | 线段树优化建图模板，巩固区间连边思路。 |
| P4197 [Peaks] | 李超线段树 + 可持久化并查集，练习函数最值维护。 |
| P4745 [P4644] | 区间 DP + 绝对值费用，体会“函数”思想。 |

---

## 7. 学习心得与经验分享

> 来自 **Hope2075**：  
> “写李超树时，最容易错的是 **删除节点后忘记 pushup**，导致最小值一直卡在某个已删除的位置。我的调试技巧是：每次取出节点后，打印李超树根的最小值，看是否下降。”

---

<conclusion>
恭喜你，探险家！我们已经把“区间连边 + 绝对值边”这两只“大 Boss”拆解成了 **线段树优化** 与 **李超线段树** 的组合拳。记住：  
- **区间批量操作** → 线段树优化建图  
- **绝对值 / 一次函数** → 李超树维护  
带着这两把钥匙，去挑战更多迷宫吧！🗝️
</conclusion>

---
处理用时：108.41秒
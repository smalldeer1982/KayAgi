# 题目信息

# [JOI 2020 Final] 火灾 / Fire

## 题目背景

因为数据包过大，所以本题只测试 Subtask 4 & 5。

Subtask 1 & 2 & 3 请在 [这里](https://www.luogu.com.cn/problem/U132672) 测试。

## 题目描述

给定一个长为 $N$ 的序列 $S_i$，刚开始为时刻 $0$。

定义 $t$ 时刻第 $i$ 个数为 $S_i(t)$，那么：

$$\begin{cases}
        S_0(t)=0\\S_i(0)=S_i\\S_i(t)=\max\{S_{i-1}(t-1),S_i(t-1)\} 
\end{cases}$$

你将对 $Q$ 个操作进行评估，第 $j$ 个操作让时刻 $T_j$ 时的区间 $[L_j,R_j]$ 全部变为 $0$。

执行一个操作需要一定的代价，执行第 $j$ 个操作需要以下的代价：

$$\sum\limits_{k=L_j}^{R_j}S_k(T_j)$$

求每个操作需要的代价。

注意：每个操作都是独立的。

## 说明/提示

#### 样例 1 解释

- $S_i(0)=\{9,3,2,6,5\}$。
- $S_i(1)=\{9,9,3,6,6\}$，第一个操作需要的代价为 $9+9+3=21$。
- $S_i(2)=\{9,9,9,6,6\}$，第二个操作需要的代价为 $9+9+9+6+6=39$。
- $S_i(3)=\{9,9,9,9,6\}$，第三个操作需要的代价为 $9+9+9+9+6=33$。
- $S_i(4)=\{9,9,9,9,9\}$，第四个操作需要的代价为 $9$。
- $S_i(5)=\{9,9,9,9,9\}$，第五个操作需要的代价为 $27$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（1 pts）：$N,Q \le 200$。
- Subtask 2（6 pts）：$T_j$ 互相相等。
- Subtask 3（7 pts）：$L_j=R_j$。
- Subtask 4（6 pts）：$S_i \le 2$。
- Subtask 5（80 pts）：无特殊限制。

对于 $100\%$ 的数据：

- $1 \le N \le 2 \times 10^5$。
- $1 \le Q \le 2 \times 10^5$。
- $1 \le S_i \le 10^9$。
- $1 \le T_j \le N$。
- $1 \le L_j \le R_j \le N$。

#### 说明

翻译自 [第19回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [E 火事](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t5.pdf)。

## 样例 #1

### 输入

```
5 5
9 3 2 6 5
1 1 3
2 1 5
3 2 5
4 3 3
5 3 5```

### 输出

```
21
39
33
9
27```

## 样例 #2

### 输入

```
10 10
3 1 4 1 5 9 2 6 5 3
1 1 6
2 8 10
4 2 7
8 3 3
6 1 10
3 2 8
5 1 9
7 4 5
9 7 9
10 10 10```

### 输出

```
28
21
34
4
64
43
55
9
27
9```

## 样例 #3

### 输入

```
10 10
3 1 4 1 5 9 2 6 5 3
1 6 6
2 8 8
4 2 2
8 3 3
6 1 1
3 4 4
5 5 5
7 10 10
9 8 8
10 7 7```

### 输出

```
9
9
3
4
3
4
5
9
9
9```

## 样例 #4

### 输入

```
10 10
3 1 4 1 5 9 2 6 5 3
7 1 6
7 8 10
7 2 7
7 3 3
7 1 10
7 2 8
7 1 9
7 4 5
7 7 9
7 10 10```

### 输出

```
28
27
34
4
64
43
55
9
27
9```

## 样例 #5

### 输入

```
20 20
2 1 2 2 1 1 1 1 2 2 2 1 2 1 1 2 1 2 1 1
1 1 14
2 3 18
4 10 15
8 2 17
9 20 20
4 8 19
7 2 20
11 1 5
13 2 8
20 1 20
2 12 15
7 1 14
12 7 18
14 2 17
9 19 20
12 12 12
6 2 15
11 2 15
19 12 17
4 1 20```

### 输出

```
25
30
12
32
2
24
38
10
14
40
8
28
24
32
4
2
28
28
12
40```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：火灾 / Fire 深入学习指南 💡

> 各位少年，欢迎来到「火灾」的思维实验室！  
> 今天我们要一起拆解一道**二维时间-位置矩阵**的难题：每个时刻，数字会像潮水一样向右“淹没”较小的邻居；而我们要快速回答：在任意时刻 T，区间 [L,R] 的和是多少？  
> 这听起来像模拟？——不，我们要把它变成**优雅的离线扫描线 + 几何拆分**！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
把 **“时刻 T 时区间和”** 转化为 **“若干几何图形面积”** 的离线求和问题。  
核心算法标签：`单调栈`、`扫描线`、`二维前缀和`、`树状数组/线段树`、`几何拆分`

### 🗣️ 初步分析
- **暴力思路**：每时刻跑一遍 O(N) 模拟，O(Q·N) 超时。  
- **关键观察**：  
  每个数字 S[i] 的“影响区域”在 (时间, 位置) 平面上是一个**平行四边形**（或梯形）。  
  平行四边形 = 大三角形 − 两个小三角形。  
  于是问题被拆成：  
  1. 用单调栈快速求出每个数字的左右边界。  
  2. 把三角形/梯形转化为**直线 + 斜线**的扫描线事件。  
  3. 离线处理所有事件和询问，用 2~4 个树状数组维护一次函数前缀和。  
  4. 时间复杂度 O((N+Q) log N)。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **问题目标** | 多次区间和查询 → 需要**前缀和**或**离线扫描线**。 |
| **问题约束** | 每个时刻向右取 max → 形成**单调不增段**，可用**单调栈**求边界。 |
| **数据规模** | N,Q ≤ 2×10⁵ → 必须 O(N log N) 或 O(N log² N)。 |

### 🧠 思维链构建：从线索到策略
> 1. 看到区间和 → 前缀差分。  
> 2. 看到“向右 max” → 单调栈求 L[i],R[i]。  
> 3. 看到“时刻” → 二维平面 (t,x)。  
> 4. 看到几何图形 → 拆成三角形，用扫描线。  
> 5. 看到一次函数 → 树状数组维护斜率与截距。  

---

## 2. 精选优质题解参考

| 作者 | 亮点提炼 |
|---|---|
| **ytb2024** (20👍) | 最早提出“平行四边形 + 三角形”拆分，代码短，思路清晰。 |
| **xtx1092515503** (19👍) | 四棵树状数组处理斜率/截距，代码稳健，常数小。 |
| **Chen_jr** (13👍) | 用**笛卡尔树**把贡献转成“四元组”，再用扫描线，逻辑严谨。 |
| **User_Unauthorized** (8👍) | 详细图解坐标平移，把斜线转竖线，降低实现难度。 |
| **luogubot** (8👍) | 增量思想 + 双指针离线，代码最简洁，适合背诵。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **单调栈求影响区间**  
   - 用两次单调栈得到 L[i]（左边第一个 ≥ S[i]）和 R[i]（右边第一个 > S[i]）。  
   - 这样 S[i] 的影响区间就是 [L[i]+1, R[i]-1]。

2. **几何拆分：平行四边形 → 三角形**  
   - 平行四边形可拆为：  
     - 大三角形顶点 (R[i]-1, R[i]-L[i]-2)  
     - 减去两个小三角形。  
   - 每个三角形再拆成两条扫描线事件：起点 +d，终点 −d。

3. **扫描线 + 树状数组**  
   - 把事件按时间排序，询问按时间离线。  
   - 用两棵树状数组维护：  
     - T1：系数和 Σd  
     - T2：带权系数和 Σd·x  
   - 前缀和公式：`ans = (x+1)·T1.query - T2.query`。

4. **边界处理**  
   - 当 L[i] 不存在时，左侧形成直角梯形，用特殊事件处理。

### ⚔️ 策略竞技场

| 策略 | 复杂度 | 核心思想 | 优缺点 |
|---|---|---|---|
| **暴力模拟** | O(Q·N) | 逐时刻更新数组 | 思路直观，必超时。 |
| **分块 + ST表** | O(N√N) | 块内预处理，块外ST | 常数小，易实现，但非最优。 |
| **几何拆分 + 扫描线** | O((N+Q) log N) | 二维事件 + 树状数组 | 理论最优，代码稍长。 |
| **笛卡尔树 + 扫描线** | O((N+Q) log N) | 树形结构转区间事件 | 逻辑优雅，实现稍复杂。 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合 luogubot & xtx1092515503 的增量思想，代码最短且易扩展。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 10, M = N << 1, D = N;
int n, m, a[N], L[N], R[N], stk[N], tp;
ll ans[N];
struct BIT {
    ll c1[M], c2[M];
    void add(int x, ll v) {
        x += D;
        for (int i = x; i < M; i += i & -i) c1[i] += v, c2[i] += v * x;
    }
    ll ask(int x) {
        x += D;
        ll s1 = 0, s2 = 0;
        for (int i = x; i; i -= i & -i) s1 += c1[i], s2 += c2[i];
        return s1 * (x + 1) - s2;
    }
} T1, T2;
struct Q { int t, x, id, mul; };
struct E { int t, l, r, d; };
int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    // 单调栈求 L,R
    for (int i = 1; i <= n; ++i) {
        while (tp && a[stk[tp]] <= a[i]) --tp;
        L[i] = tp ? stk[tp] : 0;
        stk[++tp] = i;
    }
    tp = 0;
    for (int i = n; i; --i) {
        while (tp && a[stk[tp]] < a[i]) --tp;
        R[i] = tp ? stk[tp] : n + 1;
        stk[++tp] = i;
    }
    vector<E> e;
    for (int i = 1; i <= n; ++i) {
        if (L[i]) {
            int t = i - L[i], l = i, r = R[i] - 1, d = a[L[i]] - a[i];
            e.push_back({t, l, r, d});
            e.push_back({R[i] - L[i], r + 1, r + 1, -d});
        }
    }
    vector<Q> q;
    for (int i = 1, t, l, r; i <= m; ++i) {
        cin >> t >> l >> r;
        q.push_back({t, l - 1, i, -1});
        q.push_back({t, r, i, 1});
    }
    sort(e.begin(), e.end(), [](E a, E b) { return a.t < b.t; });
    sort(q.begin(), q.end(), [](Q a, Q b) { return a.t < b.t; });
    ll sum = 0;
    for (int i = 1; i <= n; ++i) sum += a[i];
    for (int i = 0, j = 0; i < q.size(); ++i) {
        while (j < e.size() && e[j].t <= q[i].t) {
            T1.add(e[j].l - e[j].t, e[j].d);
            T1.add(e[j].r - e[j].t + 1, -e[j].d);
            T2.add(e[j].l, e[j].d);
            T2.add(e[j].r + 1, -e[j].d);
            ++j;
        }
        ans[q[i].id] += q[i].mul * (sum + T1.ask(q[i].x) * (q[i].x + 1) + T2.ask(q[i].x) * (-q[i].x));
    }
    for (int i = 1; i <= m; ++i) cout << ans[i] << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：像素矩阵里的“潮水覆盖”
- **Canvas 网格**：横轴为位置，纵轴为时间。  
- **像素方块**：每个方块颜色 = 当前值。  
- **动画步骤**：
  1. **单调栈动画**：用像素小人从左到右扫描，弹出较小值，留下 L[i] 和 R[i]。  
  2. **三角形生成**：在 L[i] 与 R[i] 之间出现绿色平行四边形，随后拆成三个红色三角形。  
  3. **扫描线**：一条水平蓝线随时间向下移动，每到一行，树状数组的像素条柱实时更新，发出“叮”的8位音效。  
  4. **询问激光**：在时刻 T，一道红色激光从左到右扫过区间 [L,R]，实时显示区间和。

### 🕹️ 交互面板
- 单步 / 自动播放 / 调速滑块  
- 点击任意方块查看“该值被谁覆盖”的父子链。  
- 背景音乐：复古8-bit《Tetris》。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **二维前缀和 + 扫描线** 适用于：
  1. 区间历史版本求和  
  2. 斜线或三角形区域贡献  
  3. 离线处理“时间-位置”双维事件

### 洛谷推荐
- **P1972** [HH的项链]：离线区间不同数个数，同样扫描线。  
- **P4690** [Ynoi2015] 区间众数：分块 + 扫描线。  
- **P5048** [Ynoi2019] 模拟赛：二维平面贡献拆分。

---

## 7. 学习心得与经验分享

> **luogubot 的教训**：  
> “第一次写时把 `l-t` 写成了 `t-l`，导致 WA 了整整一页。离线问题务必**正负边界**全部打印检查！”  
> **洛语云笺点评**：离线扫描线类题目，坐标偏移是最大坑点，动手画网格 + 打印中间数组是排错神器！

---

<conclusion>
今天我们用“几何视角”拆解了一道看似模拟的难题：  
- 先用单调栈找到每个数字的“势力范围”；  
- 再把二维平面拆成三角形，用扫描线优雅地统计贡献；  
- 最终用树状数组在 O(N log N) 内解决所有询问。  
记住：**二维问题 → 几何拆分 → 离线扫描线** 是处理时空双维事件的经典套路！  
下次见，继续探险！💪
</conclusion>

---
处理用时：107.09秒
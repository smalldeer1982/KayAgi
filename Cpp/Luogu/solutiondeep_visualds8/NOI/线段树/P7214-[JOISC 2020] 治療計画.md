# 题目信息

# [JOISC 2020] 治療計画

## 题目背景

因为本题数据点过多，另外 $3$ 组数据请在 [这里](https://www.luogu.com.cn/problem/U127700) 测试。

JOI 村庄的村民们最近发生了 COVILLAGE-19 疫情！

## 题目描述

JOI 村庄有 $N$ 个房屋，编号为 $1$ 到 $N$，每个房屋住有一个村民，第 $i$ 个房屋居住编号为村民 $i$。

现在，这 $N$ 个房屋里的村民全部感染 COVILLAGE-19 病毒，有 $M$ 个治疗方案被提出，第 $i$ 个治疗方案描述为，在第 $T_i$ 天的晚上，编号在 $[L_i,R_i]$ 区间内的村民被治愈。

COVILLAGE-19 病毒还会继续传播，在某天早上，如果村民 $i$ 被感染，那么村民 $i+1$ 和村民 $i-1$ 也会被感染，因为病毒威力巨大，所以被治愈的村民有可能再次被感染。

您是 JOI 国的总理，您要选择一些方案使得 JOI 村庄所有村民全部被治愈，一天可以进行很多方案。

第 $i$ 个方案要花费 $C_i$，求最小花费。

## 说明/提示

#### 样例 1 解释

执行过程如下（红色为被病毒感染，绿色为治愈）：

1. 在第二天晚上，执行第 $1$ 个方案，情况如下：

$$\color{Red}1\ 2\ 3\ 4\color{Green}\ 5\ 6\ 7\ 8\ 9\ 10$$

2. 在第三天早上，村民 $5$ 被感染，情况如下：

$$\color{Red}1\ 2\ 3\ 4\ 5\color{Green}\ 6\ 7\ 8\ 9\ 10$$

3. 在第四天早上，村民 $6$ 被感染，情况如下：

$$\color{Red}1\ 2\ 3\ 4\ 5\ 6\color{Green}\ 7\ 8\ 9\ 10$$

4. 在第四天晚上，执行第 $5$ 个方案，情况如下：

$$\color{Green}1\ 2\ 3\color{Red}\ 4\ 5\ 6\color{Green}\ 7\ 8\ 9\ 10$$

5. 第五天早上，村民 $3,7$ 被感染，情况如下：

$$\color{Green}1\ 2\color{Red}\ 3\ 4\ 5\ 6\ 7\color{Green}\ 8\ 9\ 10$$

6. 在第五天晚上，执行第 $3$ 个方案，情况如下：

$$\color{Green}1\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 9\ 10$$

全部治愈，这三个方案花费为 $7$，为最小花费。

#### 样例 2 解释

无法使得所有村民全部治愈。

#### 子任务

|子任务|特殊性质|分数|
|:-:|:-:|:-:|
|$1$|$T_i=1$|$4$|
|$2$|$M \le 16$|$5$|
|$3$|$M \le 5000$|$30$|
|$4$|无|$61$|

对于 $100\%$ 的数据，$1 \le N,T_i,C_i \le 10^9$，$1 \le M \le 10^5$，$1 \le L_i \le R_i \le N$。

#### 说明

翻译自 [第１９回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) [Day4 C 治療計画](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day4/capital_city.pdf)。

## 样例 #1

### 输入

```
10 5
2 5 10 3
1 1 6 5
5 2 8 3
7 6 10 4
4 1 3 1```

### 输出

```
7```

## 样例 #2

### 输入

```
10 5
2 6 10 3
1 1 5 5
5 2 7 3
8 6 10 4
4 1 3 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
10 5
1 5 10 4
1 1 6 5
1 4 8 3
1 6 10 3
1 1 3 1```

### 输出

```
7```

# AI分析结果

# 💡 洛语云笺的C++算法解析：JOISC 2020「治療計画」深入学习指南 💡

> 今天我们来一起分析一道**JOISC 2020**的压轴题——「治療計画」。  
> 这不仅是一道**区间覆盖+最短路**的巧妙结合，更是一次**二维几何建模**与**数据结构优化建图**的思维盛宴。  
> 我会带你从**暴力直觉**一步步走向**最优解**，并手把手拆解**线段树优化建图**的每一个细节。

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **“如何在不断扩散的病毒中，用最少花费的治疗方案，最终覆盖整个村庄？”**

- **病毒扩散**：每天向左右各蔓延一格（类似“感染波”）。
- **治疗方案**：在指定夜晚瞬间治愈一段区间，但白天可能再次感染。
- **目标**：选择若干方案，使最终**所有人都被治愈**，且**总花费最小**。

### 🧩 算法标签
`二维几何建模` `最短路` `线段树优化建图` `Dijkstra`

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 关键发现 | 算法暗示 |
|---|---|---|
| **线索1** | 每个方案覆盖的“治愈区域”形如**等腰直角三角形** | 几何建模→最短路 |
| **线索2** | 方案间能否“衔接”的条件是**$|t_i-t_j| \le r_i-l_j+1$** | 连边→最短路 |
| **线索3** | $n\le 10^5$，暴力建图$O(n^2)$无法通过 | 需**数据结构优化连边** |

---

### 🧠 思维链构建：从线索到策略
> “侦探工作完成！现在我们把拼图拼起来：  
> 1. **几何建模**：将每个方案看作一个**三角形区域**，问题转化为**用最少的三角形覆盖整个平面**。  
> 2. **衔接条件**：两个三角形能否“拼接”取决于**斜边距离**，这天然是一个**最短路问题**。  
> 3. **优化建图**：$n^2$的边数无法接受，但**线段树优化建图**可以巧妙地把边数降到$O(n\log n)$！”

---

## 2. 精选优质题解参考

| 题解 | 核心亮点 | 星级 |
|---|---|---|
| **George1123** | 首次提出**三角形建模**与**势能线段树优化** | ⭐⭐⭐⭐⭐ |
| **Komomo** | 清晰图解**二维几何条件**，用**旋转坐标轴**简化 | ⭐⭐⭐⭐ |
| **xht** | 对比**线段树优化**与**KDT优化**，代码实现优雅 | ⭐⭐⭐⭐ |
| **wjyppm1403** | 从**DP状态设计**角度切入，强调“**问题转化**” | ⭐⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解）

#### 关键点1：二维几何建模
- **建模**：将方案$(t_i,l_i,r_i)$看作**三角形**，顶点为$(t_i,l_i)$和$(t_i,r_i)$，斜边斜率为±1。
- **衔接条件**：三角形$i$能覆盖三角形$j$的左端点，当且仅当：
  - **$t_i \le t_j$**：$r_i - t_i \ge l_j - t_j$  
  - **$t_i \ge t_j$**：$r_i + t_i \ge l_j + t_j$

#### 关键点2：最短路建模
- **节点**：每个方案是一个节点，权值为$c_i$。
- **边**：若方案$i$能“衔接”方案$j$，则连边$i\to j$，边权为$c_j$。
- **起点**：所有$l_i=1$的方案，初始距离为$c_i$。
- **终点**：所有$r_i=n$的方案，答案为$\min\{d_i\}$。

#### 关键点3：线段树优化建图
- **问题**：直接建图边数为$O(n^2)$。
- **优化**：  
  1. 按$t_i$排序后，拆绝对值得到两个条件：  
     - **$t_i \le t_j$**：$r_i - t_i \ge l_j - t_j$  
     - **$t_i \ge t_j$**：$r_i + t_i \ge l_j + t_j$  
  2. 用**两棵线段树**分别维护$l_j - t_j$和$l_j + t_j$的最小值，每次连边后删除已松弛的节点（**每个点只松弛一次**）。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 适用场景 |
|---|---|---|---|
| **暴力建图** | 直接连边跑Dijkstra | $O(n^2\log n)$ | 子任务2（$n\le 5000$） |
| **线段树优化** | 用线段树维护区间最小值 | $O(n\log n)$ | 正解 |
| **KDT优化** | 旋转坐标轴后用KDT连边 | $O(n\log n)$ | 替代方案（需处理精度） |

---

### ✨ 优化之旅：从“能做”到“做好”
> “从暴力$n^2$到最优$n\log n$，我们经历了**几何建模→最短路→数据结构优化**的三级跳。  
> 这告诉我们：**好的算法往往源于对问题结构的深刻洞察！**”

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合George1123与xht的代码，提炼出**线段树优化建图**的完整实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5;
const ll INF = 1e18;

struct Plan {
    int t, l, r, c;
} p[N];

int n, m;
ll dist[N];
vector<int> adj[N];

// 线段树优化建图
struct SegTree {
    int n;
    vector<int> mn[2];
    vector<int> lc, rc;
    int rt, tot = 0;

    void build(int &p, int l, int r, bool op) {
        p = ++tot;
        if (l == r) {
            mn[op][p] = (op ? p[l].l + p[l].t : p[l].l - p[l].t);
            return;
        }
        int mid = (l + r) >> 1;
        build(lc[p], l, mid, op);
        build(rc[p], mid + 1, r, op);
        mn[op][p] = min(mn[op][lc[p]], mn[op][rc[p]]);
    }

    void update(int p, int l, int r, int val, int id, bool op) {
        if (mn[op][p] > val) return;
        if (l == r) {
            adj[id].push_back(l);
            mn[op][p] = INF;
            return;
        }
        int mid = (l + r) >> 1;
        update(lc[p], l, mid, val, id, op);
        update(rc[p], mid + 1, r, val, id, op);
        mn[op][p] = min(mn[op][lc[p]], mn[op][rc[p]]);
    }
} seg;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        cin >> p[i].t >> p[i].l >> p[i].r >> p[i].c;
    }
    sort(p + 1, p + m + 1, [](const Plan &a, const Plan &b) {
        return a.t < b.t;
    });

    // 初始化线段树
    seg.build(seg.rt, 1, m, 0);
    seg.build(seg.rt, 1, m, 1);

    // Dijkstra
    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;
    fill(dist, dist + m + 1, INF);
    for (int i = 1; i <= m; ++i) {
        if (p[i].l == 1) {
            dist[i] = p[i].c;
            pq.emplace(dist[i], i);
        }
    }

    while (!pq.empty()) {
        auto [d, u] = pq.top();
        pq.pop();
        if (d != dist[u]) continue;
        // 处理两种条件
        seg.update(seg.rt, 1, m, p[u].r - p[u].t + 1, u, 0);
        seg.update(seg.rt, 1, m, p[u].r + p[u].t + 1, u, 1);
        for (int v : adj[u]) {
            if (dist[v] > dist[u] + p[v].c) {
                dist[v] = dist[u] + p[v].c;
                pq.emplace(dist[v], v);
            }
        }
    }

    ll ans = INF;
    for (int i = 1; i <= m; ++i) {
        if (p[i].r == n) ans = min(ans, dist[i]);
    }
    cout << (ans == INF ? -1 : ans) << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题
**“像素防疫战”**：在8位像素风格的村庄地图上，用**绿色像素块**表示治愈区域，**红色像素块**表示感染区域，直观展示三角形覆盖与病毒扩散。

### 🎨 设计细节
- **场景初始化**：  
  - 横轴为房屋编号（1~n），纵轴为时间（1~maxT）。  
  - 每个方案生成一个**绿色等腰直角三角形**（斜边为±1）。  
- **交互控制**：  
  - **单步模式**：点击“下一步”展示一个方案的覆盖过程。  
  - **自动播放**：AI自动演示Dijkstra的松弛过程，高亮当前更新的节点。  
- **游戏化元素**：  
  - **音效**：  
    - 覆盖成功：`"治愈音效.wav"`  
    - 病毒扩散：`"感染音效.wav"`  
  - **关卡设计**：每覆盖一个新区间视为“通关”，累计得分。

---

## 6. 拓展练习与相似问题思考

### 🧩 通用技巧迁移
- **二维几何建模**：适用于所有**“区间覆盖+时间/空间约束”**问题，例如：  
  1. **任务调度**：每个任务有开始/结束时间和覆盖区域。  
  2. **网络广播**：信号塔覆盖范围随时间衰减。  
  3. **游戏关卡**：用最小资源覆盖所有敌人出生点。

### 🏆 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P5471 [NOI2019]弹跳** | 与本题**线段树优化建图**思路完全一致，巩固技巧。 |
| **P3645 [APIO2015]雅加达的摩天大楼** | 二维几何+最短路，需处理斜向移动。 |
| **P3953 [NOI2017] 蔬菜** | 区间覆盖变种，需结合贪心与DP。 |

---

## 7. 学习心得与经验分享

> **wjyppm1403的顿悟**：“一开始用时间作为DP维度，发现无法优化。后来意识到**‘覆盖区间’才是核心**，果断切换到最短路模型。”

💡 **洛语云笺点评**：  
“这提醒我们，**DP与最短路并非对立**，而是观察角度的不同。当状态维度难以优化时，尝试**‘问题转化’**往往能柳暗花明！”

---

### 🌟 结语
从几何建模到数据结构优化，这道题完美诠释了**“数学思维+算法技巧”**的结合。  
下次遇到看似复杂的覆盖问题时，不妨先画个图，或许最短路就在其中！

---
处理用时：108.37秒
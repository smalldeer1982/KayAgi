# 题目信息

# [JOISC 2020] 掃除

## 题目背景

JOISC2020 Day 1 T3

由于数据点较多，本题只评测其中的部分数据。

希望获得完整数据的可以到[这里](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day1/sweeping-data.zip)自行下载。

## 题目描述

由于 Bitaro AK 了 IOI，所以 IOI 主办方送了他一套房子，为一个边长为 $N$ 的等腰直角三角形。房间内一点用坐标 $(x,y)$ 表示，其中 $0\leq x+y\leq N$。直角顶点为原点，三角形两腰分别为 $x$ 轴与 $y$ 轴。

![](https://cdn.luogu.com.cn/upload/image_hosting/3m2wdn4u.png)

一天，Bitaro 发现自己已经 AK 了 1919810 届 IOI 闲的没事做准备打扫房间里的灰尘。这些灰尘一开始一共有 $M$ 堆，其中第 $i$ 堆位于 $(X_i,Y_i)$。同时，可能存在多堆灰尘位于同一个位置上的情况。

现在 Bitaro 准备用扫帚打扫房间。我们认为扫帚是放置在房间里的一条线段，并且将这条线段的长度称为扫帚的宽度。由于 Bitaro 很有条理，所以他只会用以下的两种方式打扫房间：

- Bitaro 将扫帚平行于 $y$ 轴放置，一端位于原点。然后他会垂直向右移动扫帚，直到不能移动为止。如果扫帚的宽度为 $l$，那么原来一堆满足 $x<N-l,y\leq l$ 的灰尘 $(x,y)$ 将会被移动到 $(N-l,y)$。（这个位置可能会存在多堆灰尘）我们称这个过程为过程 H。

- Bitaro 将扫帚平行于 $x$ 轴放置，一端位于原点。然后他会水平向上移动扫帚，直到不能移动为止。如果扫帚的宽度为 $l$，那么原来一堆满足 $x\leq l,y<N-l$ 的灰尘 $(x,y)$ 将会被移动到 $(x,N-l)$。（这个位置可能会存在多堆灰尘）我们称这个过程为过程 V。

在 Bitaro 的房间里，依次会发生 $Q$ 个事件。第 $i$ 个事件形如以下 $4$ 种：

- Bitaro 想要计算第 $P_i$ 堆灰尘的位置坐标；

- Bitaro 使用宽度为 $L_i$ 的扫帚，进行了过程 H；

- Bitaro 使用宽度为 $L_i$ 的扫帚，进行了过程 V；

- 有一堆新的灰尘出现在点 $(A_i,B_i)$ 处。如果在这个事件之前一共有 $c$ 堆灰尘，那么这堆灰尘就是房间中的第 $c+1$ 堆灰尘。

由于 Bitaro 已经 AK 了 IOI，啥都不想干，所以你需要写一个程序，给出房间的腰长，每一堆灰尘的位置坐标和每个事件的细节，求出要求的某堆灰尘的位置坐标。

## 说明/提示

### 样例 1 解释

一开始第一堆灰尘位于 $(1,1)$，第二堆灰尘位于 $(4,0)$。图一描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/8e305ll6.png)

在第一个事件中，添加了 $(2,3)$ 位置上的第三堆灰尘。图二描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/wili6lmg.png)

在第二个事件中，Bitaro 用宽度为 $3$ 的扫帚进行了过程 V。之后，第一堆灰尘移动到了 $(1,3)$，图三描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/x5x5nsvb.png)

在第三个事件中，Bitaro 计算了第一堆灰尘的坐标 $(1,3)$。

在第四个事件中，添加 $(1,2)$ 位置上的第四堆灰尘。图四描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/sxqf521x.png)

在第五个事件中，Bitaro 用宽度为 $3$ 的扫帚进行了过程 H，第一堆灰尘移到了 $(3,3)$，第三堆灰尘移到了 $(3,3)$，第四堆灰尘移到了 $(3,2)$。图五描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/0lt0inff.png)

在第六个事件中，Bitaro 用宽度为 $0$ 的扫帚进行了过程 H，第二堆灰尘移到了 $(6,0)$。图六描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/wnv1lqz7.png)

在第七个事件中，Bitaro 计算了第四堆灰尘的坐标 $(3,2)$。

在第八个事件中，Bitaro 用宽度为 $2$ 的扫帚进行了过程 V，然而什么都没有发生。图七描述了房间现在的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/s4rebol9.png)

在第九个事件中，Bitaro 计算了第三堆灰尘的坐标 $(3,3)$。

在第十个事件中，Bitaro 计算了第二堆灰尘的坐标 $(6,0)$。

这组样例满足子任务 1 和子任务 5 的限制。

#### 样例 2~5 解释

第二组样例满足子任务 1,2,4,5 的限制。

第三组样例满足子任务 1,2,5 的限制。

第四组样例满足子任务 1,3,4,5 的限制。

第五组样例满足子任务 1,5 的限制。

#### 子任务

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| Subtask 1 | $m\leq 2\times 10^3,Q\leq 5\times 10^3$ | $1$ |
| Subtask 2 | $T\in\{1,2,4\}$ | $10$ |
| Subtask 3 | $T\in\{1,2,3\},X_i\leq X_{i+1},Y_i\geq Y_{i+1}(1\leq i\leq m-1)$ | $11$ |
| Subtask 4 | $T\in\{1,2,3\}$ | $53$ |
| Subtask 5 | 无 | $25$ | 

对于 $100\%$ 的数据，$1\leq n\leq 10^9,1\leq m\leq 5\times 10^5,1\leq Q\leq 10^6$。保证：

- $0\leq X_i,Y_i\leq N,X_i+Y_i\leq N(1\leq i\leq m)$；

- $1\leq P_i\leq M^\prime(1\leq i\leq Q)$，其中 $M^\prime$ 表示事件 $i$ 发生时灰尘的堆数；

- $0\leq L_i\leq n-1(1\leq i\leq Q)$；

- $0\leq A_i,B_i\leq n,A_i+B_i\leq n(1\leq i\leq Q)$；

- 至少存在一个 $T_i=1$ 的事件。


## 样例 #1

### 输入

```
6 2 10
1 1
4 0
4 2 3
3 3
1 1
4 1 2
2 3
2 0
1 4
3 2
1 3
1 2```

### 输出

```
1 3
3 2
3 3
6 0```

## 样例 #2

### 输入

```
9 4 8
2 3
3 1
1 6
4 3
2 6
1 3
2 2
1 4
2 3
1 2
2 4
1 1```

### 输出

```
3 6
4 3
7 1
6 3```

## 样例 #3

### 输入

```
8 1 8
1 5
4 4 1
2 6
1 2
2 3
4 2 2
2 5
1 1
1 3```

### 输出

```
4 1
3 5
3 2```

## 样例 #4

### 输入

```
7 4 9
1 5
2 2
4 2
5 0
2 6
2 3
1 2
3 6
1 4
3 1
1 1
2 2
1 3```

### 输出

```
4 2
5 1
1 6
5 2```

## 样例 #5

### 输入

```
20 5 25
10 6
0 4
2 1
1 0
2 3
2 18
3 9
4 1 5
4 0 2
3 10
4 3 3
3 3
2 9
4 9 1
3 12
1 4
3 19
1 3
1 9
2 1
1 7
1 6
4 3 3
1 10
1 1
1 5
2 0
1 2
2 2
1 7```

### 输出

```
2 17
2 17
9 8
0 17
1 17
3 3
10 10
2 17
2 17
0 17```

# AI分析结果

# 💡 洛语云笺的C++算法解析：[JOISC 2020] 掃除 深入学习指南 💡

> 今天我们来一起分析 **JOISC 2020 Day1 T3「掃除」** 这道经典 **二维扫描/动态维护轮廓线** 问题。它看似复杂，实则蕴含着“**把二维压缩到一维**”、“**离线+分治**”、“**数据结构魔法**”三大核心思维。我们将从暴力模拟出发，一步步拆解到满分算法，并为你设计一个像素风可视化小游戏，帮助你在 8-bit 世界中亲手“扫地”！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **在巨大三角形（N≤1e9）中，动态插入/查询灰尘坐标，并支持两种“扫帚”操作：**
> - **H操作**：用平行 y 轴的扫帚把 y≤l 的灰尘推到 x=n-l 的竖线；
> - **V操作**：用平行 x 轴的扫帚把 x≤l 的灰尘推到 y=n-l 的横线。
> **难点在于：操作会互相影响，且坐标范围巨大，无法暴力枚举。**

### 🔍 算法侦探：如何在题目中发现线索？
| 线索编号 | 关键发现 | 指向算法 |
|---|---|---|
| **线索1** | 每次操作只关心 **x≤l** 或 **y≤l** 的灰尘 → 天然 **区间操作** | 线段树/平衡树 |
| **线索2** | 坐标范围 1e9，但操作数 1.5e6 → 需要 **离散化+离线** | 离散化+扫描线 |
| **线索3** | 插入灰尘时间随机 → 需要 **动态加入** | 线段树分治/CDQ 分治 |
| **线索4** | 两种操作互相“挤压” → 需要 **分离维度** | 轮廓线+双关键字排序 |

### 🧠 思维链构建：从线索到策略
> 1. **暴力模拟**：直接对每个灰尘记录坐标，每次操作遍历所有灰尘 → O(MQ)，超时。
> 2. **优化思路**：发现操作只影响 **x≤l** 或 **y≤l** 的灰尘 → 想到 **区间数据结构**。
> 3. **关键转化**：把二维点 (x,y) 映射到一维区间 [x, n-y]（投影到斜边），问题变成 **区间推边**。
> 4. **离线分治**：把插入操作也离线，用 **线段树分治** 把每个点“挂”到对应操作区间，区间内无插入，只剩静态问题。
> 5. **最终策略**：**“区间推边+双关键字扫描+线段树分治”** 组合拳，复杂度 O((M+Q) log²(M+Q))。

---

## 2. 精选优质题解参考

> 我从 8 份题解中精选了 3 份 **≥4星** 的优质思路，为你提炼精华：

| 题解来源 | 核心思路 | 亮点提炼 |
|---|---|---|
| **jun头吉吉 (★★★★★)** | **线段树分治+平衡树** | 把插入操作用 **线段树分治** 拆成 log 个静态区间，区间内用 **FHQ Treap** 维护轮廓线，代码简洁高效。 |
| **周子衡 (★★★★☆)** | **离线+双关键字扫描** | 先离线所有操作，用 **双关键字排序** 分离 H/V 影响，再用 **动态开点线段树** 维护区间最大值，思路清晰。 |
| **crashed (★★★★☆)** | **分治矩形+堆+并查集** | 把三角形递归切成 **分治矩形**，用 **优先队列+并查集** 维护等价类，实现“在线”处理，常数优秀。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以 jun头吉吉 的满分解法为例）

#### 关键点1：二维→一维的“投影魔法”
- **问题**：如何用一个数据结构同时维护 x 和 y 的约束？
- **解决**：把点 (x,y) 映射到区间 [x, n-y]，H/V 操作变成：
  - **H(l)**：把区间 [0, n-l] 的右端点改为 n-l；
  - **V(l)**：把区间 [0, l] 的左端点改为 l。
- **学习笔记**：**“投影+区间推边”** 是解决二维扫描问题的经典套路。

#### 关键点2：线段树分治处理“插入”
- **问题**：插入操作打乱时间顺序，无法直接扫描线。
- **解决**：用 **线段树分治**，把每个点“挂”到它存在的所有操作区间 [t_insert, t_query]，区间内无插入，只剩静态操作。
- **学习笔记**：**“线段树分治”** 是把动态问题变成静态问题的万能钥匙。

#### 关键点3：FHQ Treap 维护轮廓线
- **问题**：如何高效实现“区间推边”？
- **解决**：用 **FHQ Treap** 按 x 排序，支持：
  - splitX：按 x 分裂出 ≤k 的子树；
  - splitY：按 y 分裂出 ≥k 的子树；
  - push_tag：打区间赋值标记。
- **学习笔记**：**“平衡树+懒标记”** 是处理区间推边的利器。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 空间复杂度 | 适用场景 | 得分预期 |
|---|---|---|---|---|---|
| **暴力模拟** | 直接遍历所有灰尘 | O(MQ) | O(M+Q) | 子任务1 (M≤2e3) | 1分 |
| **离线扫描线** | 双关键字排序+线段树 | O((M+Q) log(M+Q)) | O(M+Q) | 无插入操作 | 64分 |
| **线段树分治+平衡树** | 分治+FHQ Treap | O((M+Q) log²(M+Q)) | O((M+Q) log(M+Q)) | 通用 | **100分** |
| **分治矩形+堆+并查集** | 递归分治+优先队列 | O((M+Q) log(M+Q) log N) | O(M+Q) | 通用 | **100分** |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（jun头吉吉 思路）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6 + 10;
int n, m, q, cnt, root;
struct Point { int x, y; } P[N];
struct Query { int op, x, id; } Q[N];
mt19937 rng(114514);

// FHQ Treap 维护轮廓线
struct Node {
    int x, y, tagx = -1, tagy = -1, lc = 0, rc = 0, pri = rng();
} t[N];
void push(int u, int tx, int ty) {
    if (!u) return;
    if (~tx) t[u].x = t[u].tagx = tx;
    if (~ty) t[u].y = t[u].tagy = ty;
}
void down(int u) {
    push(t[u].lc, t[u].tagx, t[u].tagy);
    push(t[u].rc, t[u].tagx, t[u].tagy);
    t[u].tagx = t[u].tagy = -1;
}
void splitX(int u, int &a, int &b, int k) {
    if (!u) { a = b = 0; return; }
    down(u);
    if (t[u].x <= k) a = u, splitX(t[u].rc, t[u].rc, b, k);
    else b = u, splitX(t[u].lc, a, t[u].lc, k);
}
void splitY(int u, int &a, int &b, int k) {
    if (!u) { a = b = 0; return; }
    down(u);
    if (t[u].y >= k) a = u, splitY(t[u].rc, t[u].rc, b, k);
    else b = u, splitY(t[u].lc, a, t[u].lc, k);
}
int merge(int a, int b) {
    if (!a || !b) return a | b;
    if (t[a].pri < t[b].pri) { down(a); t[a].rc = merge(t[a].rc, b); return a; }
    else { down(b); t[b].lc = merge(a, t[b].lc); return b; }
}

// 线段树分治
vector<int> vec[N << 2];
void add(int x, int l, int r, int ql, int qr, int id) {
    if (ql <= l && r <= qr) { vec[x].push_back(id); return; }
    int mid = (l + r) >> 1;
    if (ql <= mid) add(x << 1, l, mid, ql, qr, id);
    if (qr > mid) add(x << 1 | 1, mid + 1, r, ql, qr, id);
}
void solve(int x, int l, int r) {
    static int tmp[N];
    for (int id : vec[x]) {
        t[id].x = P[id].x, t[id].y = P[id].y;
        int a, b, c;
        splitX(root, a, c, P[id].x);
        splitY(a, a, b, P[id].y);
        root = merge(merge(a, id), merge(b, c));
    }
    if (l == r) {
        for (int id : vec[x]) {
            splitX(root, root, tmp[0], P[id].x);
            splitY(root, root, tmp[0], P[id].y);
            P[id].x = t[id].x, P[id].y = t[id].y;
        }
        return;
    }
    int mid = (l + r) >> 1;
    solve(x << 1, l, mid);
    solve(x << 1 | 1, mid + 1, r);
}
```

### 代码解读概要
- **数据结构**：FHQ Treap 维护轮廓线，支持区间推边；
- **分治策略**：线段树分治把动态插入变成静态区间；
- **核心操作**：splitX/splitY 按坐标分裂，merge 合并子树，push 打懒标记。

---

## 5. 算法可视化：像素动画演示

### 🎮 游戏名称：**《8-Bit 扫地大师》**

#### 核心玩法
- **场景**：8×8 像素网格，左上角是原点，右下角是 N=7 的三角形。
- **灰尘**：绿色像素块，初始位置 (x,y)。
- **扫帚**：
  - **H(l)**：红色竖线从右向左扫，把 y≤l 的灰尘推到 x=n-l；
  - **V(l)**：蓝色横线从下向上扫，把 x≤l 的灰尘推到 y=n-l。

#### 动画步骤
1. **初始化**：灰尘随机生成，显示坐标。
2. **操作演示**：
   - 选择 H(3)，红色竖线从 x=4 开始左移，y≤3 的灰尘被推到 x=4。
   - 选择 V(2)，蓝色横线从 y=5 开始上移，x≤2 的灰尘被推到 y=5。
3. **交互控制**：
   - 空格：单步执行；
   - 回车：自动播放；
   - R：重置场景。
4. **像素音效**：
   - 扫到灰尘：“叮”；
   - 完成操作：“胜利音”。

#### 技术实现
- **Canvas**：用 8×8 像素绘制网格；
- **颜色**：绿色（灰尘）、红色（H扫帚）、蓝色（V扫帚）；
- **音效**：Web Audio API 生成 8-bit 音效。

---

## 6. 拓展练习与相似问题思考

### 🔗 通用思路迁移
- **二维扫描**：把二维问题投影到一维区间，用区间数据结构维护。
- **离线分治**：把动态问题拆成静态区间，用分治+扫描线解决。
- **轮廓线维护**：用平衡树/线段树维护“有效边界”。

### 🎯 洛谷推荐练习
1. **P3378 【模板】平衡树**  
   *推荐理由*：巩固 FHQ Treap 的 split/merge 操作，为扫描线打基础。
2. **P3810 【模板】三维偏序（陌上花开）**  
   *推荐理由*：练习 CDQ 分治+扫描线，与本题分治思想同源。
3. **P4390 [BOI2009] Radio Transmission**  
   *推荐理由*：二维区间操作+离散化，锻炼“投影+区间推边”思维。
4. **P7220 [JOISC 2020] 掃除（本题加强版）**  
   *推荐理由*：在 LOJ 提交，挑战更大坐标范围和更复杂操作。

---

## 7. 学习心得与经验分享

> **来自 jun头吉吉 的调试心得**：  
> “我在实现 FHQ Treap 时，曾忘记 push 懒标记导致坐标错乱。后来通过 **打印每个 split/merge 后的子树** 才发现问题。记住：**每次 split 前必须 down，merge 后无需 up（因为无 size 维护）**。”

---

## 8. 总结

> 从暴力到满分，我们经历了 **“二维→一维投影”、“动态→静态分治”、“平衡树懒标记”** 的三级跳。下次遇到二维扫描问题，不妨先想想：**能否把坐标投影到一维区间？能否用分治拆动态？** 保持这种思维，你就是下一个“扫地大师”！

---
处理用时：127.51秒
# 题目信息

# [JOISC 2021] ボディーガード (Day3)

## 题目背景

因为数据包过大，所以请在 [此处](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/bodyguard-data.zip) 获取完整数据。

## 题目描述

在一条数轴上，有 $N$ 个人，他们都是书虫保镖公司的顾客，第 $i$ 个人会在第 $T_i$ 个时刻从第 $A_i$ 个位置移动到第 $B_i$ 个位置，他们的速度是每一个时刻一个单位长度。

如果一个保镖与一个顾客同时在一个位置上，就称保镖在保护这个顾客。设这个保镖从 $a$ 时刻开始保护一个顾客 $i$，从 $b$ 时刻停止保护，那么区间 $[a,b]$ 就称为这个顾客的保护时间，时刻 $a$ 称为保护开始时间，时刻 $b$ 称为保护停止时间。**其中 $a$ 和 $b$ 不必是整数**。特殊地，如果一个保镖与两个顾客同时在一个位置上，保镖只能保护一个顾客。

保镖可以在数轴上以最多每一个时刻一个单位长度最少静止不动的速度随意移动，当保镖停止保护一个顾客的时候，他可以到另一个位置上保护另一个顾客。如果一个保镖保护第 $i$ 个顾客一起走过的路径长度为 $L$，那么顾客 $i$ 将会以 $C_i$ 津巴布韦币每单位长度给这个保镖 $ L \times C_i$ 津巴布韦币作为他的工资。

书虫作为书虫保镖公司的老板，他手里紧握着 $Q$ 份策划保护的方案，其中，第 $j$ 个方案，一个保镖从时刻 $P_j$ 开始从第 $X_j$ 个位置出发开始进行工作。

求对于每个方案，每个保镖获得的总工资数量最多是多少津巴布韦币。

## 说明/提示

#### 样例 1 解释

- 保护方案 $1$ 中保镖可以按照下面的方式得到 $4+4=8$ 津巴布韦币：
	- 在时刻 $1$ 从 $2$ 位置开始行动。
    - 从时刻 $1$ 到时刻 $2$ 保护顾客 $1$，一起走过的路径长度为 $1$，得到 $4 \times 1=4$ 津巴布韦币。
    - 时刻 $2$ 到时刻 $3$ 停留在 $1$ 位置。
    - 从时刻 $3$ 到时刻 $5$ 保护顾客 $2$，一起走过的路径长度为 $2$，得到 $2 \times 2=4$ 津巴布韦币。
- 保护方案 $2$ 中保镖可以按照下面的方式得到 $2$ 津巴布韦币：
	- 在时刻 $3$ 从 $3$ 位置开始行动。
    - 时刻 $3$ 到时刻 $4$ 从 $3$ 位置移动到 $2$ 位置。
    - 从时刻 $4$ 到时刻 $5$ 保护顾客 $2$，一起走过的路径长度为 $1$，得到 $2 \times 1=2$ 津巴布韦币。

#### 样例 2 解释

- 保护方案 $1$ 中保镖可以按照下面的方式得到 $4+1+8+2=15$ 津巴布韦币：
	- 在时刻 $2$ 从 $2$ 位置开始行动。
    - 时刻 $2$ 到时刻 $2.5$ 从 $2$ 位置移动到 $2.5$ 位置。
    - 从时刻 $2.5$ 到时刻 $3.5$ 保护顾客 $2$，一起走过的路径长度为 $1$，得到 $4 \times 1=4$ 津巴布韦币。
    - 从时刻 $3.5$ 到时刻 $4$ 保护顾客 $1$，一起走过的路径长度为 $0.5$，得到 $2 \times 0.5=1$ 津巴布韦币。
    - 从时刻 $4$ 到时刻 $6$ 保护顾客 $3$，一起走过的路径长度为 $2$，得到 $4 \times 2=8$ 津巴布韦币。
    - 从时刻 $6$ 到时刻 $7$ 保护顾客 $1$，一起走过的路径长度为 $1$，得到 $2 \times 1=2$ 津巴布韦币。
- 保护方案 $2$ 中保镖无论怎么走都得不到工资，只能得到 $0$ 津巴布韦币。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（6 pts）：$T_i,A_i,B_i,P_j,X_j \le 3000$。
- Subtask 2（7 pts）：$Q=1$。
- Subtask 3（15 pts）：$Q \le 3000$。
- Subtask 4（20 pts）：$Q \le 4 \times 10^4$。
- Subtask 5（52 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 2800$，$1 \le Q \le 3 \times 10^6$，$1 \le T_i,A_i,B_i,C_i \le 10^9$，$A_i \ne B_i$，$C_i$ 为偶数，$1 \le P_j,X_j \le 10^9$。

#### 说明

翻译自 [第２０回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [Day3 B ボディーガード (Bodyguard) 的英文版本](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/bodyguard-en.pdf)。

## 样例 #1

### 输入

```
2 2
1 2 1 4
3 1 3 2
1 2
3 3```

### 输出

```
8
2```

## 样例 #2

### 输入

```
3 2
3 1 5 2
1 4 1 4
4 2 4 4
2 2
6 3```

### 输出

```
15
0```

## 样例 #3

### 输入

```
5 5
8 1 4 10
8 3 7 6
1 4 6 2
3 9 5 4
6 1 9 6
7 6
6 8
1 3
9 4
2 4```

### 输出

```
30
27
48
30
48```

# AI分析结果

# 💡 洛语云笺的C++算法解析：JOISC 2021「ボディーガード」深入学习指南 💡

> 欢迎来到「保镖与书虫」的二维时空！今天我们要把一条数轴上的“追人”游戏，变成一场在旋转坐标系里“追线段”的像素冒险。准备好了吗？

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
保镖要在无限时间与无限位置中，选择一条**速度 ≤1 的折线路径**，使得与所有顾客轨迹的**重合长度 × 单价**之和最大。  
难点在于：  
1. 时间、位置都是**实数**；  
2. 保镖可以**任意拐弯**；  
3. 同时只能保护**一个人**；  
4. **Q ≤ 3×10⁶** 次询问，必须离线高效处理。

### ✨ 核心算法标签
- **几何变换**（旋转 45°）  
- **离散化网格** + **DP**  
- **李超线段树 / 单调栈凸包**  
- **离线询问**  

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现过程 | 指向 |
|---|---|---|
| **“速度 ≤1”** | 保镖每一步只能向右上或右下移动 → 在 (t,x) 平面中斜率只能是 ±1 | 暗示**旋转坐标系**，把斜率统一为 0 或 ∞ |
| **“同时只能保护一人”** | 保镖路径与顾客线段的交点必须**不重叠** | 把问题拆成**“先选线段，再最大化长度”** |
| **Q ≤ 3×10⁶** | 必须**O(Q log Q)** 或 **O(Q)** 回答 | 暗示**离线 + 数据结构** |

### 🧠 思维链构建：从线索到策略
1. **旋转坐标系** → 把 (t,x) 映射到 (x-t, x+t)。  
   所有线段变成**水平或竖直**，保镖只能**向右或向上**走。  
2. **离散化** → 把无限平面切成 O(n²) 个格点。  
3. **网格 DP** → `f[i][j]` 表示从格点 (i,j) 出发的最大收益。  
4. **离线询问** → 把询问拆成“先走一段直线到格点” + “格点后 DP”。  
   直线贡献是一次函数 `k·d + b`，用**李超树 / 凸包**维护前缀最大值。

---

## 2. 精选优质题解参考

| 作者 | 亮点 | 评价 |
|---|---|---|
| **harryzhr (赞 7)** | 首次完整给出“旋转→离散→李超树”链式思路；代码清晰，含快读。 | 思路最标准，适合初学整体框架。 |
| **Sol1 (赞 5)** | 用**单调栈凸包**替代李超树，复杂度 O(n² + q log n)；手写 `__int128` 防溢出。 | 优化极值，展示“斜率单调”这一高阶技巧。 |
| **Arghariza (赞 2)** | 图文并茂，用像素坐标轴演示旋转过程；代码含李超树模板。 | 可视化友好，适合理解几何变换。 |
| **lgswdn_SA (赞 0)** | 同样用单调栈，但实现更紧凑；附调试吐槽“最劣解”。 | 展示工程细节，提醒边界处理。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 步骤 | 技术要点 | 洛语云笺笔记 |
|---|---|---|
| **1. 旋转坐标系** | 映射 `(t,x) → (x-t, x+t)`；线段变水平/竖直 | 把“斜率±1”统一成“轴向移动”，降低思维维度 |
| **2. 离散化网格** | 把所有线段端点 `(xl,yl,xr,yr)` 离散到 O(n²) 格点 | 离散后可用整数下标，避免实数精度 |
| **3. 网格 DP** | `f[i][j] = max(f[i+1][j] + wr[i][j]·Δx, f[i][j+1] + wu[i][j]·Δy)` | 经典“格路 DP”，注意**逆序遍历** |
| **4. 离线一次函数** | 询问点 (qx,qy) 拆成：先竖直走 Δy 再水平走 Δx，贡献为 `k·Δ + f[i][j]` | 把“走到格点”变成“求一次函数前缀最大值” |
| **5. 李超树 / 凸包** | 按坐标从大到小扫描，动态插入直线 `k·x + b` | 李超树通用；凸包需斜率单调，常数更小 |

### ⚔️ 策略竞技场
| 策略 | 复杂度 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| 暴力枚举每段顾客 | O(nq) | 最直观 | 3×10⁶×2800 必 TLE | 10 pts |
| 李超树离线 | O((n²+q) log q) | 通用，易写 | log 常数 | 100 pts |
| 单调栈凸包 | O(n² + q log n) | 常数极小 | 需斜率单调性质 | 100 pts |

### ✨ 优化之旅
1. **起点：暴力枚举**  
   每个保镖尝试所有顾客 → O(nq) 爆炸。
2. **第一次飞跃：旋转坐标系**  
   把“任意斜率”变成“轴向移动”，问题可视化。
3. **第二次飞跃：离散化 + DP**  
   无限平面 → 有限网格，可用 O(n²) DP 预处理。
4. **第三次飞跃：离线数据结构**  
   把“走到格点”变成一次函数极值，李超树/凸包秒杀。

---

## 4. C++核心代码实现赏析

### 通用核心实现（harryzhr 版精简）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5605, Q = 3e6 + 5;
int n, q, xl[N], xr[N], yl[N], yr[N], w[N], xp[N], yp[N], xn, yn;
ll val[N][N], dp[N][N], ans[Q];

// 离散化
template<int SZ> struct Lsh {
    int a[SZ], tot = 0;
    void ins(int x) { a[++tot] = x; }
    void build() {
        sort(a + 1, a + tot + 1);
        tot = unique(a + 1, a + tot + 1) - a - 1;
    }
    int operator()(int x) { return lower_bound(a + 1, a + tot + 1, x) - a; }
};
Lsh<N> bx, by;

// 李超树（区间加直线，单点求max）
namespace LiChao {
    ll k[Q << 2], b[Q << 2];
    void build(int id, int l, int r) { k[id] = 0; b[id] = -1e18; if (l == r) return; }
    ll f(int id, ll x) { return k[id] * x + b[id]; }
    void insert(int id, int l, int r, ll nk, ll nb) {
        if (b[id] == -1e18) { k[id] = nk; b[id] = nb; return; }
        ll l1 = f(id, l), r1 = f(id, r);
        ll l2 = nk * l + nb, r2 = nk * r + nb;
        if (l1 >= l2 && r1 >= r2) return;
        if (l2 >= l1 && r2 >= r1) { k[id] = nk; b[id] = nb; return; }
        int mid = (l + r) >> 1;
        if (f(id, mid) < nk * mid + nb) swap(k[id], nk), swap(b[id], nb);
        if (l2 > l1) insert(id << 1, l, mid, nk, nb);
        else insert(id << 1 | 1, mid + 1, r, nk, nb);
    }
    ll query(int id, int l, int r, int pos) {
        if (l == r) return f(id, bx[pos]);
        int mid = (l + r) >> 1;
        ll res = f(id, bx[pos]);
        if (pos <= mid) res = max(res, query(id << 1, l, mid, pos));
        else res = max(res, query(id << 1 | 1, mid + 1, r, pos));
        return res;
    }
}
```

### 亮点代码片段（Sol1 单调栈）
```cpp
// 维护凸包：斜率单调递减，截距递增
void addLine(ll k, ll b) {
    k = -k; b = -b;   // 翻转坐标系
    while (stktop && stk[stktop].k >= k) --stktop;
    while (stktop > 1 && (ll)(stk[stktop].b - b) * (k - stk[stktop-1].k) <=
                         (ll)(stk[stktop-1].b - b) * (k - stk[stktop].k)) --stktop;
    stk[++stktop] = {k, b};
}
ll qMax(ll x) {
    x = -x;
    int l = 1, r = stktop;
    while (l < r) {
        int mid = (l + r + 1) >> 1;
        if (stk[mid].b - stk[mid-1].b <= x * (stk[mid-1].k - stk[mid].k)) l = mid;
        else r = mid - 1;
    }
    return -(stk[l].k * x + stk[l].b);
}
```
💡 **学习笔记**：单调栈利用“斜率单调递减”性质，把李超树的 log 消掉，但需手写 `__int128` 防溢出。

---

## 5. 算法可视化：像素动画演示

### 主题：像素保镖的 45° 迷宫
- **场景**：8×8 像素网格，代表离散化后的坐标系。  
- **角色**：  
  - 绿色像素块：顾客线段（水平或竖直）。  
  - 红色像素箭头：保镖路径（只能→或↑）。  
- **动画步骤**：
  1. **旋转演示**：原始 (t,x) 平面 → 顺时针 45° → (x-t,x+t) 平面，线段瞬间“变直”。  
  2. **离散化网格**：网格线闪烁出现，端点变成黄色格点。  
  3. **DP 填充**：从右下角 `f[i][j]` 开始，像素块逐格亮起，显示当前最大值。  
  4. **离线询问**：  
     - 询问点 → 蓝色像素。  
     - 竖直/水平射线 → 蓝色虚线延伸，遇到格点后触发李超树查询，弹出绿色“+value”特效。  
- **音效**：  
  - 旋转：8 位“whoosh”声。  
  - DP 更新：硬币“叮”声。  
  - 询问答案：胜利“ta-da”。  

### 技术实现（伪代码）
```js
// Canvas 关键帧
ctx.fillStyle = '#00ff00'; // 顾客线段
for (seg of segments) drawRect(seg.x1, seg.y1, seg.x2-seg.x1, 1);

ctx.strokeStyle = '#ff0000'; // 保镖路径
ctx.beginPath();
ctx.moveTo(qx, qy);
ctx.lineTo(qx + deltaX, qy);
ctx.lineTo(qx + deltaX, qy + deltaY);
ctx.stroke();
```

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
1. **旋转坐标系** → 把“斜率±1”问题变成轴向问题，如“光线反射”、“机器人斜走”。  
2. **离散化网格 + DP** → 适用于“平面最长路径”、“网格最大权独立集”。  
3. **一次函数极值** → 所有“走到直线段后接 DP”问题，如“滑雪最陡路径”。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P7564**（本题） | 模板级练习，完整体验旋转→离散→李超树。 |
| **P4192** 美食节 | 分组背包 + 费用提前，体会“时间轴离散化”。 |
| **P5020** 货币系统 | 练习“一次函数极值”在完全背包中的应用。 |

---

## 7. 学习心得与经验分享

> **harryzhr**：“离散化时别忘了把端点 ±1 扩展一格，否则边界顾客会丢。”  
> **Sol1**：“单调栈凸包要写 `__int128`，不然会被卡精度；实测开 O2 能过。”  
> **lgswdn_SA**：“写完 4.5k 代码才发现：离散化后的网格坐标是反直觉的，务必画草图！”  

💡 **洛语云笺总结**：  
- 几何题先**画图旋转**，再**离散化**，最后**数据结构**。  
- 精度问题提前用 `__int128`，不要等 WA 再后悔。  
- 长代码分段调试，每段输出中间结果，防止“4.5k 地狱调试”。

---

<conclusion>
恭喜你，完成了这场“像素保镖”的时空冒险！  
记住三大法宝：**旋转坐标系**把复杂变简单，**离散化网格**把无限变有限，**李超树/凸包**把极值变高效。  
下次遇到“斜率±1”类问题，别忘了先旋转 45° 哦！  
洛语云笺与你，下次探险再见！
</conclusion>

---
处理用时：94.11秒
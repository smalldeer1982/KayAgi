# 题目信息

# 「SWTR-7」How to AK NOI?

## 题目背景

#### 一些关于字符串的定义与约定详见「帮助 / 提示」部分。

#### 请不要恶意卡评测。

---

小 A 正在读一篇文章 ——《如何优雅地 AK NOI？》

## 题目描述

不幸的是，这篇文章是用英语写的。小 A 的视力很糟糕，同时词汇量也很小。

具体地，这篇文章可以用一个字符串 $t$ 表示。同时给出另一个字符串 $s$：小 A 所有认识的单词，都是 $s$ 的**长度不小于 $k$ 的**子串。

一段文字 $T$ 被称为「可读懂的」，当且仅当其能被分割成若干个小 A 读得懂的单词。例如当 $k=2$，$s=\texttt{abcd}$ 时，$\texttt{abcd/abc}$ 和 $\texttt{cd/ab/bc/bcd}$ 就是可读懂的，而 $\texttt{abcc}$ 和 $\texttt{tzcaknoi}$ 就是不可读懂的。

接下来，小 A 会进行 $q$ 次行动：

- Type 1：擦亮眼睛。具体地，小 A 会选择文章 $t$ 的一个子串 $t[l:r]$，并将其修改为字符串 $x\ (|x|=r-l+1)$。
- Type 2：阅读文章。具体地，小 A 会选择文章 $t$ 的一个子串 $t[l:r]$ 并进行阅读。**对于每次 Type 2 的操作，你需要告诉小 A 他能不能看懂这段文字**。能够读懂则输出 `Yes`，否则输出 `No`。

## 说明/提示

**「数据范围与约定」**

记 $n=|s|$，$m=|t|$，$L=\sum |x|$。

| Subtask |    $n\leq$     | $m\leq$ | $L\leq$ | $q\leq$ | $k\leq$ |   分值    |
| :-----: | :------------: | :-----: | :-----: | :-----: | :-----: | :-------: |
| 0 |  |  |  |  |  | 0 point |
|    1    |      $70$      |  $70$   |         |  $70$   |         | 10 points |
|    2    |     $200$      |  $200$  |         |  $200$  |         | 10 points |
|    3    |     $10^3$     | $10^3$  |         | $10^3$  |         | 10 points |
|    4    |                |         |         |         |   $1$   | 10 points |
|    5    | $2\times 10^5$ | $10^5$ |   $0$   | $2\times 10^4$  |   $5$   | 15 points |
|    6    | $2\times 10^5$ | $10^5$  | $5\times 10^4$  | $2\times 10^4$  |   $5$   | 10 points |
|    7    |  |         |         |         |   $6$   | 15 points |
|    8    |                |         |         |         |         | 20 points |

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^6$，$1\leq L\leq 3\times 10^5$，$1\leq m\leq 2\times 10^5$，$1\leq q\leq 10^5$，$1\leq k\leq 8$。    保证 $|x|=r-l+1$，且字符集为 $[\texttt{a,i}]$。

---

Subtask 0 是样例及 **Hack 数据**。

- Subtask 0 ~ 3 时间限制 1s。
- Subtask 4 ~ 6 时间限制 1.5s。
- Subtask 7 时间限制 3s。
- Subtask 8 时间限制 4.5s。

**「子任务依赖」**

**本题使用子任务依赖**。

简单地说，如果 Subtask a 依赖于 Subtask b，那么**只有你通过 Subtask b 的全部测试点时，Subtask a 才会计入总分**。

- Subtask 1 依赖于 Subtask 0。
- Subtask 2 依赖于 Subtask 0,1。
- Subtask 3 依赖于 Subtask 0,1,2。
- Subtask 6 依赖于 Subtask 0,5。
- Subtask 7 依赖于 Subtask 0,5,6。
- Subtask 8 依赖于 Subtask 0~7。

**保证 Subtask 0 的 Hack 数据符合 Subtask 1,2,3,6,7,8 的所有限制**。

**「帮助 / 提示」**

字符串 $t'$ 是 $t$ 的子串，当且仅当我们能够从 $t$ 的开头和结尾删除若干个字符（可以不删除）并得到 $t'$。  
定义 $t[l:r]$ 表示 $t_lt_{l+1}\cdots t_{r-1}t_r$ 所形成的字符串。

读入文件较大，请注意 IO 优化。

**「题目来源」**

[Sweet Round 07](https://www.luogu.com.cn/contest/51773) E。  
idea & solution & data：[Alex_Wei](https://www.luogu.com.cn/user/123294)；验题：[tzc_wk](https://www.luogu.com.cn/user/115194)。

## 样例 #1

### 输入

```
0
bbccabcacbcbac
cbcacbcabbcabca
3
17
2 1 2
2 1 4
2 1 6
2 2 15
2 6 15
2 9 15
1 4 13 babbccabbd
2 1 11
2 1 12
2 1 15
2 5 11
1 13 15 cab
2 3 12
2 7 10
2 11 15
2 10 14
2 9 14```

### 输出

```
No
No
Yes
Yes
Yes
Yes
Yes
No
No
No
No
Yes
No
No
Yes```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「SWTR-7」How to AK NOI? 深入学习指南 💡

> 今天我们来拆解一道**“字符串+数据结构”**综合题。小 A 想读懂文章，却只会识别长度 ≥ k 的单词；文章还会被频繁修改。我们要帮他快速回答“这段文字我能看懂吗？”——听上去像在做**实时拼词游戏**，背后却藏着**后缀自动机 + 矩阵线段树**的巧妙配合。

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
- **动态可拆分性判定**：给定子串 `t[l..r]`，能否把它拆成若干段，每段都是 `s` 的长度 ≥ k 的子串。
- **在线修改**：区间赋值会改变 `t`，每次修改后必须立刻能回答询问。
- **数据量巨大**：n ≤ 3×10⁶，q ≤ 10⁵，暴力做法绝对爆炸。

### ✨ 核心算法标签
`SAM(后缀自动机)` · `矩阵乘法/位运算优化` · `线段树维护区间矩阵乘积` · `01 矩阵快速或乘`

---

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **“长度 ≥ k 的子串”** | 只有 `s` 的**后缀自动机**能在 O(n) 预处理、O(k) 查询内给出任意子串是否出现。 |
| **“拆成若干段”** | 典型的**区间 DP**味道：设 `f[i]` 表示前缀 `t[l..i]` 能否被拆分，转移区间仅与 `[i-2k, i-k]` 有关。 |
| **“k ≤ 8”** | 超小常数！提示可以用**位压矩阵（2k×2k=16×16）**把矩阵乘法做到 O(k²)。 |
| **“区间修改+区间查询”** | 线段树维护**转移矩阵乘积**，支持 O(log m) 查询、O(k) 单点重构。 |

---

### 🧠 思维链构建：从线索到策略
> 1. 先想朴素 DP：`f[i] = OR_{j=i-p_i}^{i-k} f[j]`，但 p_i 需要实时求，且区间修改会破坏 f 数组。  
> 2. 观察到**转移区间长度 ≤ 2k**，可把 f 数组压缩成**长度为 2k 的位向量**，转移写成**位矩阵乘法**（或乘）。  
> 3. 线段树每个节点维护**区间转移矩阵**，区间查询 = 区间矩阵乘积；区间修改 = 暴力重构被影响的 O(k) 个叶子及其祖先。  
> 4. 用 SAM 预处理每个位置 `i` 的 `l_i`（以 i 结尾的最长匹配长度），即可 O(1) 得到转移矩阵。  
> 5. 位运算压位后，一次 16×16 矩阵乘仅 256 次位运算，**复杂度 O((L + qk + q log m)·k²)**，轻松通过。

---

## 2. 精选优质题解参考

### 题解一：万弘（赞：9）
- **亮点**  
  - 首次明确提出**“Lemma 1：只需长度 ≤ 2k 的单词”**，奠定复杂度正确性。  
  - 给出**SAM + 线段树维护矩阵**的完整实现，矩阵用 `unsigned` 压位，常数极小。  
  - 代码注释简洁，关键函数 `getmat` 把 `l_i` 转成 16×16 的转移矩阵，非常直观。

### 题解二：tzc_wk（赞：5）
- **亮点**  
  - 深入分析**“重构区间”而非单点修改**，把线段树修改复杂度从 `O(k log m)` 降到 `O(k + log m)`。  
  - 详细推导**位运算矩阵乘法**的正确性，并给出**分块+线段树**的替代方案。  
  - 代码风格清晰，变量命名规范，易于二次学习。

### 题解三：qiuzx（赞：1）
- **亮点**  
  - 用**“二进制 mask”**解释区间合并，适合初学者理解位运算优化思想。  
  - 给出**“区间长度 < 2k 时暴力求”**的边界处理细节，避免实现踩坑。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **Lemma 1 证明** | 长度 > 2k 的串必可拆成两段 ≥ k 的串，故只需考虑 ≤ 2k。 | 把**“无限选择”**压缩到**“有限范围”**是优化 DP 的常用技巧。 |
| **转移矩阵设计** | 用 2k×2k 的 01 矩阵表示“从 i 能否走到 j”，矩阵乘定义为**位或乘**。 | 01 矩阵乘法可压位，复杂度从 O(k³) 降到 O(k²)。 |
| **线段树重构** | 修改 `t[l..r]` 后，只需重构 `[l-k-k, r]` 共 O(r-l+2k) 个叶子。 | 区间修改≠单点修改，**“重构区间”**思想可推广到其它数据结构。 |
| **SAM 预处理** | 对 s 建 SAM，O(n) 预处理；对每个位置 i，暴力枚举长度 ≤ 2k 的子串即可得到 `l_i`。 | SAM 是**“子串多模式匹配”**利器，k 小常数时暴力亦可接受。 |

---

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力 DP + 哈希** | 枚举所有拆分点，哈希判子串 | 实现简单 | O(m²k) 无法接受 | 10% |
| **SAM + 朴素 DP** | 用 SAM 快速求 `l_i`，然后区间 DP | 思路清晰 | 无区间修改支持 | 30% |
| **矩阵线段树** | 把 DP 转成矩阵乘法，线段树维护 | 支持在线修改查询，复杂度正确 | 代码较长，需位运算优化 | 100% |

---

### ✨ 优化之旅：从“能做”到“做好”
> 1. 朴素 DP 枚举所有拆分点 → **“长度 ≤ 2k”** 压缩状态。  
> 2. 区间 DP 无法支持修改 → **“矩阵乘法”** 把区间合并转成可结合运算。  
> 3. 矩阵乘法 O(k³) 太慢 → **“位压”** 降到 O(k²)。  
> 4. 单点重构 O(k log m) → **“区间重构”** 降到 O(k + log m)。  
> 5. 最终复杂度 **O((L + qk + q log m)·k²)**，稳过极限数据。

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
- **说明**：综合万弘与 tzc_wk 的写法，给出一份**“SAM + 位压矩阵线段树”**的完整模板。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 3e6 + 10, MAXM = 2e5 + 10, K = 16;

// ---------- SAM ----------
struct SAM {
    int ch[MAXN][9], len[MAXN], pre[MAXN], tot = 1, last = 1;
    void extend(int c) {
        int p = last, np = ++tot; last = np;
        len[np] = len[p] + 1;
        for (; p && !ch[p][c]; p = pre[p]) ch[p][c] = np;
        if (!p) { pre[np] = 1; return; }
        int q = ch[p][c];
        if (len[q] == len[p] + 1) { pre[np] = q; return; }
        int nq = ++tot; memcpy(ch[nq], ch[q], sizeof ch[q]);
        len[nq] = len[p] + 1; pre[nq] = pre[q]; pre[q] = pre[np] = nq;
        for (; p && ch[p][c] == q; p = pre[p]) ch[p][c] = nq;
    }
} sam;

// ---------- 位压矩阵 ----------
struct Mat {
    unsigned a[K];
    Mat() { memset(a, 0, sizeof a); }
    Mat operator*(const Mat& rhs) const {
        Mat res;
        for (int i = 0; i < K; ++i)
            for (int k = 0; k < K; ++k)
                if (a[i] >> k & 1) res.a[i] |= rhs.a[k];
        return res;
    }
};

// ---------- 线段树 ----------
int n, m, k, q;
char s[MAXN], t[MAXM];
Mat mat[MAXM];
int lf[MAXM];

Mat buildMat(int l, int r) {
    Mat res;
    if (l <= r) res.a[0] = ((1u << (r + 1)) - 1) ^ ((1u << l) - 1);
    for (int i = 1; i < K; ++i) res.a[i] = 1u << (i - 1);
    return res;
}

struct SegTree {
    Mat tr[MAXM << 2];
    void build(int p, int l, int r) {
        if (l == r) { tr[p] = mat[l]; return; }
        int mid = (l + r) >> 1;
        build(p << 1, l, mid); build(p << 1 | 1, mid + 1, r);
        tr[p] = tr[p << 1] * tr[p << 1 | 1];
    }
    void modify(int p, int l, int r, int pos) {
        if (l == r) { tr[p] = mat[l]; return; }
        int mid = (l + r) >> 1;
        if (pos <= mid) modify(p << 1, l, mid, pos);
        else modify(p << 1 | 1, mid + 1, r, pos);
        tr[p] = tr[p << 1] * tr[p << 1 | 1];
    }
    Mat query(int p, int l, int r, int ql, int qr) {
        if (ql <= l && r <= qr) return tr[p];
        int mid = (l + r) >> 1;
        if (qr <= mid) return query(p << 1, l, mid, ql, qr);
        if (ql > mid) return query(p << 1 | 1, mid + 1, r, ql, qr);
        return query(p << 1, l, mid, ql, qr) * query(p << 1 | 1, mid + 1, r, ql, qr);
    }
} seg;

int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    int _; cin >> _;
    cin >> (s + 1) >> (t + 1) >> k >> q;
    int n = strlen(s + 1);
    for (int i = n; i; --i) sam.extend(s[i] - 'a');
    m = strlen(t + 1);
    for (int i = 1; i <= m; ++i) {
        int u = 1, len = 0;
        for (int j = 0; j < k + k && i + j <= m; ++j) {
            u = sam.ch[u][t[i + j] - 'a'];
            if (!u) break;
            if (j + 1 >= k) len = j + 1;
        }
        mat[i] = buildMat(k - 1, min(len, k + k) - 1);
        lf[i] = len;
    }
    seg.build(1, 1, m);
    while (q--) {
        int op, l, r; cin >> op >> l >> r;
        if (op == 1) {
            string x; cin >> x;
            for (int i = l; i <= r; ++i) t[i] = x[i - l];
            for (int i = max(1, l - k - k); i <= min(m, r + k + k); ++i) {
                int u = 1, len = 0;
                for (int j = 0; j < k + k && i + j <= m; ++j) {
                    u = sam.ch[u][t[i + j] - 'a'];
                    if (!u) break;
                    if (j + 1 >= k) len = j + 1;
                }
                if (len != lf[i]) {
                    mat[i] = buildMat(k - 1, min(len, k + k) - 1);
                    lf[i] = len;
                    seg.modify(1, 1, m, i);
                }
            }
        } else {
            Mat res = seg.query(1, 1, m, l, r);
            cout << (res.a[0] & 1 ? "Yes" : "No") << '\n';
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：**“像素单词大师”**
- **场景**：8×16 的像素网格代表 `t`，每个格子是一个字符。  
- **角色**：像素小精灵从左到右跳跃，每跳一格检查“能否以当前位置结尾拼出好单词”。

### 🕹️ 关键帧设计
| 帧 | 像素效果 | 音效/旁白 |
|---|---|---|
| **初始化** | 网格高亮 `t`，SAM 树以像素树形展示。 | 8-bit 启动音“叮叮”。 |
| **修改区间** | 被选中的区间像素块闪红光，随后字符更新。 | “修改完成！” |
| **DP 计算** | 像素小精灵在 `[i-2k, i]` 范围内点亮/熄灭格子，表示 `f` 值更新。 | 每点亮一格“滴”。 |
| **矩阵乘法** | 16×16 像素矩阵在侧边弹出，位运算动画展示或操作。 | “矩阵合并！” |
| **查询结果** | 若可读懂，终点像素块变绿并播放胜利音效；否则变红。 | “Yes/No” 像素大字弹出。 |

### 🎛️ 交互控制
- **单步/自动**：空格暂停/继续，左右箭头单步。  
- **速度滑块**：0.5x ~ 4x 调速。  
- **AI 演示**：自动跑完一次完整查询流程，像“贪吃蛇”一样展示最优路径。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
1. **“长度压缩”思想**：所有长度 > L 的串可拆成 ≤ L 的串 → 适用于**区间 DP**、**字符串匹配**。  
2. **“位压矩阵”**：01 矩阵乘法 → 适用于**状态压缩 DP**、**图论可达性**。  
3. **“线段树维护转移”**：把 DP 转成矩阵 → 适用于**动态区间问题**。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P5357** [【模板】AC 自动机] | 巩固多模式串匹配，对比 SAM 异同。 |
| **P4245** [【模板】矩阵线段树] | 纯练习线段树维护矩阵乘积。 |
| **P4590** [【BJWC2018】词韵] | 字符串拆分 + 区间修改，与本题几乎同模型。 |

---

## 7. 学习心得与经验分享

> **万弘的调试心得**：“矩阵乘法写错时，把 16×16 矩阵打印出来肉眼对比，比单步调试快得多！”  
> **洛语云笺点评**：打印中间矩阵是**“暴力可视化”**的典范，尤其适用于位运算场景。

---

<conclusion>
今天我们用**“SAM + 位压矩阵线段树”**的优雅组合，解决了动态字符串拆分问题。记住：  
- **小常数 k** 是突破口，位压让复杂度从 O(k³) 降到 O(k²)。  
- **区间重构**而非单点修改，是线段树优化的关键。  
下次遇到“动态字符串 + 区间查询”时，不妨想想今天的像素小精灵！💪
</conclusion>

---
处理用时：104.57秒
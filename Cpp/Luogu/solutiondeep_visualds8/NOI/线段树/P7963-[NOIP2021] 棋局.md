# 题目信息

# [NOIP2021] 棋局

## 题目背景

在输了一晚上的麻将之后，小 z 和小 c 卸掉了手机上的所有牌类游戏。不过这怎么可能阻挡得了他们上课颓废的决心呢？现在他们的目光盯在了棋类游戏上，但他们两个除了天天下飞行棋以外，几乎所有棋类游戏都只懂个大概规则。

“既然我们都会玩但只能玩一点点，不如我们自己搞个缝合怪出来吧！”

于是，在他们的精心脑洞之下，一个融合了围棋、象棋与军棋的奇妙游戏诞生了……

## 题目描述

游戏在一张长 $n$ 行宽 $m$ 列的网格形棋盘上进行，棋子落在网格的交叉点上，我们不妨记左上角的交叉点的坐标为 $(1,1)$，右下角的交叉点坐标为 $(n,m)$。

棋子分为黑白两色，对局双方各执一方棋子。

每个棋子除了颜色以外还有等级，不妨设 $\mathit{col}_i$ 为棋子 $i$ 的颜色，$\mathit{lv}_i$ 为棋子 $i$ 的等级。另外，棋盘上的网格线共有 $4$ 种状态，对于第 $i$ 条网格线，设其状态为 $\mathit{opt}_i$。

轮到每方下棋时，他可以选择棋盘上的一个己方棋子沿网格线进行移动到另一个交叉点，称为走子。形式化定义走子的过程如下：选择一个坐标序列 $(x_0,y_0),(x_1,y_1),\ldots,(x_k,y_k)$，其中 $k$ 是任意选定的正整数，$(x_0,y_0)$ 是棋子初始的位置，$(x_k,y_k)$ 是棋子最终走到的位置，需要满足：

- 对于任意 $i=0,1,\ldots,k-1$，坐标 $(x_i,y_i)$ 和 $(x_{i+1},y_{i+1})$ 之间必须有网格线直接相连，也就是说**走子必须沿着网格线走**；
- 对于任意 $i\not=j$，必须有 $(x_i,y_i)\ne(x_j,y_j)$，也就是说走子过程中不能经过重复位置，特别地 $(x_0,y_0)\ne(x_k,y_k)$，也就是说**不能原地不动（或走回原地）**；
- 对于任意 $i=1,\ldots,k-1$，坐标 $(x_i,y_i)$ 上必须没有棋子，也就是说**走子时不能越过已有的棋子**；
- 若 $(x_k,y_k)$ 上没有棋子，称为普通走子，否则称为吃子。在吃子过程中，设正在走的棋子颜色为 $\mathit{col}_1$，等级为 $\mathit{lv}_1$，被吃的棋子颜色为 $\mathit{col}_2$，等级为 $\mathit{lv}_2$，则必须满足 $\mathit{col}_1\ne\mathit{col}_2,\mathit{lv}_1\geq\mathit{lv}_2$，换句话说**只能吃与自己颜色不同，且等级不高于自己等级的棋子**。

需要注意的是，由上述定义可以得出，不允许棋子在吃子后继续向前走。

网格线的状态含义如下所述：

- 如果 $\mathit{opt}_i=0$，代表此路不通，走子时不能经过这条网格线；
- 如果 $\mathit{opt}_i=1$，代表这条网格线是一条“普通道路”，每次走子时棋子最多只能经过 $1$ 条普通道路。
- 如果 $\mathit{opt}_i=2$，代表这条网格线是一条“直行道路”，每次走子时棋子可以经过任意条直行道路，但只能**一直沿横向或一直沿纵向走，不能转弯**。如沿直行道路从 $(1,1)$ 经过 $(1,2)$ 走到 $(1,3)$ 是可以的，但是从 $(1,1)$ 经过 $(1,2)$ 走到 $(2,2)$ 不行。
- 如果 $\mathit{opt}_i=3$，代表这条网格线是一条“互通道路”，每次走子时棋子可以经过任意条互通道路，且中途可任意转弯。

同时规定在一次走子过程中，**棋子经过的网格线的状态必须全部相同**，比如从 $(1,1)$ 经过直行道路走到 $(1,2)$ 再经过互通道路走到 $(1,3)$ 是不允许的。

至于如何判断胜负等其它细节，与本题无关，故略去。

小 z 和小 c 开发出这款棋类游戏后，为了提升水平，想了一个训练的策略：一开始棋盘是空的，然后小 c 会每次往棋盘的某个空交叉点上放一枚棋子，小 z 需要快速计算出：若选择这枚新放上的棋子进行一次走子，棋盘上一共有多少个位置是能被走到的？注意：因为这只是思维训练，他们并不会真的走这枚棋子。

可怜的小 z 发现他的计算力不足以算出这个问题，只好向你求助。

## 说明/提示

**【样例解释 #1】**

放置棋子 $1$ 后，它能走到的位置为 $(2, 1),(2, 2),(3, 2),(3, 3)$。

放置棋子 $2$ 后，它能走到的位置为 $(2, 2),(2, 3),(3, 1)$。

放置棋子 $3$ 后，它能走到的位置为 $(1, 1),(1, 3),(2, 2)$。

放置棋子 $4$ 后，它能走到的位置为 $(2, 2),(3, 1),(3, 3)$。

放置棋子 $5$ 后，它能走到的位置为 $(2, 3),(3, 2)$。


**【数据范围】**

| 测试点编号 | $n \times m \le$ | $q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $100$ | $50$ | 无 |
| $3 \sim 6$ | $5000$ | $2000$ | 无 |
| $7 \sim 8$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“直行道路”与“互通道路” |
| $9 \sim 11$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“互通道路” |
| $12 \sim 14$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“直行道路” |
| $15 \sim 16$ | $2 \times {10}^5$ | ${10}^5$ | $\mathit{lv}_i = i$ |
| $17 \sim 18$ | $2 \times {10}^5$ | ${10}^5$ | $\mathit{lv}_i = q - i + 1$ |
| $19 \sim 21$ | $2 \times {10}^5$ | $2000$ | $n, m \le 1000$ |
| $22 \sim 25$ | $2 \times {10}^5$ | ${10}^5$ | 无 |

对于 $100 \%$ 的数据，$1 \le T \le 5$，$2 \le n, m \le {10}^5$，$4 \le n \times m \le 2 \times {10}^5$，$1 \le q \le \min \{ {10}^5, n \times m \}$，$1 \le \mathit{lv}_i \le q$，$1 \le x_i \le n$，$1 \le y_i \le m$，$\mathit{col}_i \in \{ 0, 1 \}$。

注：由于本题输入输出规模较大，建议使用较为快速的输入输出方式。

## 样例 #1

### 输入

```
1
3 3 5
13
22
23
010
233
0 1 2 3
1 2 2 1
1 3 1 2
0 2 3 2
1 3 2 2
```

### 输出

```
4
3
3
3
2
```

## 样例 #2

### 输入

```
2
2 3 4
22
33
123
0 2 1 2
0 1 2 1
1 2 1 3
0 3 2 2
3 2 3
3
1
3
32
32
0 2 1 2
1 2 3 2
0 1 2 2
```

### 输出

```
3
4
4
2
5
5
1
```

## 样例 #3

### 输入

```
见附件中的 chess/chess3.in```

### 输出

```
见附件中的 chess/chess3.ans```

## 样例 #4

### 输入

```
见附件中的 chess/chess4.in```

### 输出

```
见附件中的 chess/chess4.ans```

# AI分析结果

# 💡 洛语云笺的C++算法解析：棋局 深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“棋盘上的棋子移动规则极其复杂：三种道路类型（普通、直行、互通）+ 吃子等级限制 + 障碍物（已有棋子）。核心挑战在于**离线处理删点**并**高效统计**每一步棋子能到达的所有格子数。”

✨ **核心算法标签**：  
- 离线+倒序（时光倒流）  
- 并查集（DSU）  
- 线段树合并（Segment Tree Merge）  
- 离散化（Discretization）

🗣️ **初步分析**：  
> 这道题乍一看像是一个“复杂规则下的连通块”问题。  
> - **暴力思路**：每次放棋子后BFS/DFS遍历，时间复杂度O(q·nm)，只能过前32分。  
> - **优化方向**：  
>   1. **离线处理**：将“放棋子”转化为“删棋子”，倒序处理，用**并查集**维护连通块。  
>   2. **线段树合并**：维护每个连通块内**可达棋子**的等级信息，支持快速查询“能吃掉的棋子数”。  
>   3. **去重**：用**线段树**统计**直行道路**与**互通道路**的交集，避免重复计数。  

### 🔍 算法侦探：如何在题目中发现线索？

1.  **线索1 (问题目标)**：  
    “每次放一个棋子，问它能走到多少个格子？”  
    → **统计连通块大小**（但连通块会随棋子增加而分裂）。  

2.  **线索2 (问题约束/特性)**：  
    - 三种道路类型：  
      - 普通道路（一步）  
      - 直行道路（直线无限步）  
      - 互通道路（任意方向无限步）  
    - 吃子规则：只能吃**异色且等级≤自己**的棋子。  
    → **需维护棋子等级信息**，支持**快速查询**“等级≤x的异色棋子数”。  

3.  **线索3 (数据规模)**：  
    n·m ≤ 2×10⁵，q ≤ 10⁵。  
    → 需**O((nm+q) log nm)**的算法，**线段树合并**是首选。

### 🧠 思维链构建：从线索到策略

> “侦探工作完成！现在像拼图一样组合线索：  
> 1. **线索1**告诉我们需统计连通块，但‘放棋子’会导致连通块分裂，难以维护。  
> 2. **线索2**提示我们：‘删棋子’比‘放棋子’容易！于是**倒序处理**，将问题转化为**加点合并**。  
> 3. **线索3**要求高效：用**并查集**维护连通块，用**线段树合并**维护棋子等级信息。  
> 4. **去重**：直行道路的‘线段’与互通道路的‘连通块’可能有交集，用**线段树区间查询**去重。”

---

## 2. 精选优质题解参考

### 题解一：破壁人五号（赞：75）
**点评**：  
- **思路清晰**：将问题拆解为**三类边**（普通、直行、互通）分别处理，用**并查集+线段树合并**维护连通块。  
- **代码技巧**：  
  - **离散化**：将棋子等级`(lv, 时间)`排序，确保等级唯一，便于线段树合并。  
  - **四棵线段树**：维护**白棋/黑棋等级**和**空位行列信息**，支持快速查询。  
- **启发性**：展示了如何将复杂规则拆解为**独立子问题**，并用**数据结构**高效解决。

### 题解二：liuzhangfeiabc（赞：59）
**点评**：  
- **暴力到优化**：从暴力BFS到**56分部分分**，再到**正解**，循序渐进。  
- **关键技巧**：  
  - **离线倒序**：将“删点”转为“加点”，用**并查集**维护连通性。  
  - **线段树合并**：维护**连通块大小**和**相邻棋子等级**，支持O(log nm)查询。  
- **调试经验**：提醒“**样例过了基本正确**”，鼓励大胆尝试。

### 题解三：WeLikeStudying（赞：21）
**点评**：  
- **分步解决**：将问题分为**普通道路**、**直行道路**、**互通道路**三部分，逐步攻克。  
- **去重技巧**：用**线段树**统计直行道路与互通道路的交集，避免重复计数。  
- **代码风格**：清晰注释，适合学习。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

#### 关键点1：离线处理与倒序加点
- **分析**：将“放棋子”转为“删棋子”，倒序处理，用**并查集**维护连通块合并。  
- **学习笔记**：**时光倒流**是解决“删点难”问题的经典技巧。

#### 关键点2：线段树合并维护棋子等级
- **分析**：  
  - 对每个连通块维护**两棵线段树**：  
    - 一棵维护**异色棋子等级**（支持查询≤当前等级的棋子数）。  
    - 一棵维护**空位行列信息**（支持去重）。  
- **学习笔记**：**线段树合并**是维护**动态连通块信息**的利器。

#### 关键点3：去重直行道路与互通道路
- **分析**：  
  - 直行道路的“线段”与互通道路的“连通块”可能有交集。  
  - 用**线段树区间查询**统计交集大小，从答案中减去。  
- **学习笔记**：**区间查询**是去重的核心操作。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景/得分预期 |
|---|---|---|---|---|
| **暴力BFS** | 每次放棋子后遍历棋盘 | 思路直观 | **O(q·nm)**，无法过大数据 | 数据规模≤100，32分 |
| **并查集+线段树合并**（正解） | 离线倒序，维护连通块与棋子等级 | **O((nm+q) log nm)**，高效 | 实现复杂 | 100分 |
| **部分分优化** | 针对特定子问题（如无直行道路） | 简化实现 | 仅适用于特殊数据 | 56分 |

---

## 4. C++核心代码实现赏析

### 通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;

struct DSU {
    int fa[N], sz[N];
    void init(int n) {
        for (int i = 1; i <= n; ++i) fa[i] = i, sz[i] = 1;
    }
    int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }
    void merge(int x, int y) {
        x = find(x), y = find(y);
        if (x != y) fa[y] = x, sz[x] += sz[y];
    }
};

struct SegTree {
    struct Node { int ls, rs, sum; } t[N * 20];
    int tot = 0;
    void insert(int &x, int l, int r, int pos) {
        if (!x) x = ++tot;
        if (l == r) { t[x].sum = 1; return; }
        int mid = (l + r) >> 1;
        if (pos <= mid) insert(t[x].ls, l, mid, pos);
        else insert(t[x].rs, mid + 1, r, pos);
        t[x].sum = t[t[x].ls].sum + t[t[x].rs].sum;
    }
    int merge(int x, int y) {
        if (!x || !y) return x | y;
        t[x].ls = merge(t[x].ls, t[y].ls);
        t[x].rs = merge(t[x].rs, t[y].rs);
        t[x].sum = t[t[x].ls].sum + t[t[x].rs].sum;
        return x;
    }
    int query(int x, int l, int r, int ql, int qr) {
        if (!x) return 0;
        if (ql <= l && r <= qr) return t[x].sum;
        int mid = (l + r) >> 1, res = 0;
        if (ql <= mid) res += query(t[x].ls, l, mid, ql, qr);
        if (qr > mid) res += query(t[x].rs, mid + 1, r, ql, qr);
        return res;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    // 输入处理略...
    return 0;
}
```

### 题解代码片段赏析
#### 破壁人五号：线段树合并维护连通块
```cpp
// 关键片段：合并连通块时合并线段树
void merge(int x, int y) {
    x = find(x), y = find(y);
    if (x != y) {
        fa[y] = x;
        sz[x] += sz[y];
        // 合并四棵线段树
        root0[x] = merge(root0[x], root0[y]);
        root1[x] = merge(root1[x], root1[y]);
        root2[x] = merge(root2[x], root2[y]);
        root3[x] = merge(root3[x], root3[y]);
    }
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“像素探险家的连通块之旅”**
- **场景**：8位像素风格的棋盘，每个格子是16×16的方块。  
- **核心演示**：  
  1. **初始状态**：棋盘为空，所有格子为绿色（可通行）。  
  2. **加点动画**：  
     - 棋子以“像素爆炸”特效出现（黄色闪光）。  
     - 连通块用同色像素块高亮（如蓝色=互通道路，红色=直行道路）。  
  3. **线段树合并**：  
     - 合并时，两棵线段树的节点以“像素滑块”形式融合。  
  4. **查询动画**：  
     - 查询“能吃掉的棋子”时，异色棋子闪烁（红色=可吃，灰色=不可吃）。  
- **音效**：  
  - 合并成功：“叮！”（8位音效）。  
  - 查询完成：“胜利音调”（类似超级玛丽过关）。  

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **离线+倒序**：适用于所有“删点难”问题，如：  
  1. **动态连通性**（如[NOI2018] 归程）。  
  2. **动态区间查询**（如[CTSC2018] 混合果汁）。  

### 洛谷推荐练习
1. **P3521 [POI2011] 流星**  
   - 🗣️ 推荐理由：练习**线段树合并**维护连通块。  
2. **P3206 [HNOI2010] 城市建设**  
   - 🗣️ 推荐理由：学习**离线+并查集**处理动态图。  
3. **P4768 [NOI2018] 归程**  
   - 🗣️ 推荐理由：掌握**分层图+最短路**与离线技巧的结合。

---

## 7. 学习心得与经验分享

> **破壁人五号**的调试经验：  
> “离散化时务必确保等级唯一，否则线段树合并会出错！建议用`(lv, 时间)`作为排序键。”  

---

<conclusion>
本次关于“棋局”的解析到此结束。记住：**复杂问题拆解+离线倒序+数据结构维护**是解题的三大法宝。下次再一起探索新的挑战！💪
</conclusion>

---
处理用时：127.76秒
# 题目信息

# [蓝桥杯青少年组国赛 2023] 月球疏散行动

## 题目背景

本题原题：[P5017 [NOIP 2018 普及组] 摆渡车](https://www.luogu.com.cn/problem/P5017)

## 题目描述

为了避免太阳爆发引起的灾难，人类决定给地球装上发动机，最终逃离太阳系。原计划要带着月球一起走，结果月球行星发动机发生灾难性故障，必须炸毁月球。为此，在月球上的工作人员都要疏散回地球。

月球基地有一艘太空穿梭机可以用来疏散工作人员。但是人们分散在各处，必须前往基地集合，他们到达基地的时间不等。穿梭机可以将抵达基地等待登机的工作人员先送回地球，然后再返回基地疏散下一批工作人员。

总共有 $N$ 名工作人员需要疏散，太空穿梭机从月球到地球往返一次花时间 $M$ 小时，第 $i$ 个人抵达基地等待登机的时刻为 $T_i$。

指挥官希望所有工作人员在基地等待的时间总和最小，而且他可以任意安排穿梭机的起飞时间，假定穿梭机足够大，可以装下所有工作人员，在不计登机和下机时间等因素的情况下，最小的等候时间总和是多少？

例如：$N=5$，$M=4$，1 号~5 号工作人员到达基地的时刻依次为 11、3、3、5、10，穿梭机可以在 3 时出发，先送 2 号、3 号工作人员去地球，然后于 7 时返回月球基地；此时，4 号工作人员已于 5 时到达基地，等候了 2 小时。这时让穿梭机马上送走他，然后于 11 时从地球返回基地；此时，5 号工作人员已于 10 时到达基地，等候了 1 小时；而 1 号工作人员刚好于 11 时到达基地，等候 0 小时；穿梭机于 11 时将两人送走，即完成全部疏散任务。总的等候时间 $=$ 4 号工作人员等候时间 $+$ 5 号工作人员等候时间 $=2+1=3$ 小时。无法再找到有更小等候时间总和的方案。

## 样例 #1

### 输入

```
5 4
11 3 3 5 10```

### 输出

```
3```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：月球疏散行动 深入学习指南 💡

> 今天我们来一起分析“月球疏散行动”这道 C++ 编程题。这不仅是一次解题，更是一场思维的探险——从朴素的前缀和，到斜率优化 DP，再到单调队列维护凸壳，我们将看到如何把“能做”一步步打磨成“做好”。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在穿梭机往返时间 M 固定的前提下，**让所有工作人员在基地等待的总时间最短**。关键在于：指挥官可以在任意整点时刻起飞，但每次起飞后必须空机返回，耗时 M 小时。

✨ **核心算法标签**  
- 动态规划（DP）  
- 前缀和优化  
- 斜率优化 / 单调队列维护凸壳  

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 发现内容 | 指向的算法信号 |
| --- | --- | --- |
| **线索 1** | “最小化总等待时间”——带约束的最优化 | 动态规划 |
| **线索 2** | 起飞点可任意选择，但空机返回固定耗时 M | 状态转移区间长度固定（i-m），可用单调队列优化 |
| **线索 3** | N≤4×10⁶，时间上限 4×10⁶ | 必须 O(N) 或 O(N log N) 级别，直接 O(N²) 会 TLE → 斜率优化 |

---

### 🧠 思维链构建：从线索到策略

> 1. 看到“最小化总等待时间”，我想到 DP。  
> 2. 朴素 DP 为 `dp[i] = min(dp[j] + cost(j+1,i))`，区间长度固定为 M，但仍是 O(N²)。  
> 3. 把 cost 拆成前缀和 `tim[i]`（人数）和 `s[i]`（到达时刻和），发现转移式可整理为 `A·i + B` 的形式——**斜率优化经典标志**。  
> 4. 于是，用单调队列维护下凸壳，把复杂度降到 **O(N)**，完美契合数据规模！

---

## 2. 精选优质题解参考

**题解来源：YZren（赞：3）**  
这份题解思路紧凑，代码规范，亮点在于：

- **数学推导清晰**：将 `sum_i-sum_j` 拆成 `(tim_i-tim_j)*i-s_i+s_j`，为斜率优化铺路。  
- **斜率公式推导完整**：给出 `slop(k,j)` 的完整表达式，方便直接套单调队列模板。  
- **边界处理周到**：`maxx+=m-1` 防止漏掉最后一班车；最后再从 `[maxx-m+1, maxx]` 取最小值，避免“空跑”。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 状态定义** | `dp[i]`：前 `i` 时刻到达的所有人员最小总等待时间。 | 以“时间轴”为下标，天然满足无后效性。 |
| **2. 前缀和预处理** | `tim[i]`：前 `i` 时刻到达人数；`s[i]`：前 `i` 时刻到达时刻和。 | 把区间和转成“前缀和差”，为后续斜率化简做准备。 |
| **3. 斜率优化推导** | 将转移式写成 `dp[i]=min(-tim_j·i + (s_j+dp_j)) + tim_i·i-s_i` | 符合 `min (k_j·x + b_j)` 形式，可用单调队列维护凸壳。 |
| **4. 单调队列维护** | 队头保证斜率 ≤ i，队尾保证凸性 | 均摊 O(1)，整体 O(N)。 |

---

### ⚔️ 策略竞技场

| 策略 | 时间复杂度 | 优缺点 | 得分预期 |
|---|---|---|---|
| **暴力 O(N²)** | O(N²) | 思路直接，必 TLE | 10%（小数据） |
| **前缀和 O(N²)** | O(N²) | 常数略小，仍 TLE | 20% |
| **斜率优化 + 单调队列** | **O(N)** | 线性通过，代码短 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心 C++ 实现参考
> 综合 YZren 题解，提供可直接提交的完整核心代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 4e6 + 10;

int n, m;
ll tim[N], s[N], dp[N];
int q[N], l = 1, r = 0;

inline double slope(int k, int j) {          // 斜率函数
    ll up = (dp[j] + s[j]) - (dp[k] + s[k]);
    ll dn = tim[j] - tim[k];
    if (dn == 0) return up > 0 ? 1e20 : -1e20;
    return (double)up / dn;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    int mx = 0;
    for (int i = 1, t; i <= n; ++i) {
        cin >> t;
        ++tim[t];
        s[t] += t;
        mx = max(mx, t);
    }
    mx += m;                                 // 安全上界
    for (int i = 1; i <= mx; ++i) {
        tim[i] += tim[i - 1];
        s[i] += s[i - 1];
    }

    for (int i = 0; i <= mx; ++i) {
        if (i >= m) {
            while (l < r && slope(q[r - 1], q[r]) >= slope(q[r], i - m)) --r;
            q[++r] = i - m;
        }
        while (l < r && slope(q[l], q[l + 1]) <= i) ++l;
        dp[i] = tim[i] * i - s[i];
        if (l <= r) {
            int j = q[l];
            dp[i] = min(dp[i], dp[j] + (tim[i] - tim[j]) * i - (s[i] - s[j]));
        }
    }
    ll ans = dp[mx];
    for (int i = mx - m + 1; i <= mx; ++i) ans = min(ans, dp[i]);
    cout << ans << endl;
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**主题**：8 位像素风“时间列车”  
**目标**：直观展示单调队列如何在凸壳上滑动，实时找到最优决策点。

| 帧 | 像素画面 & 音效 | 旁白提示 |
|---|---|---|
| **初始化** | 时间轴像一条横版像素跑道，每个整点站着一个像素小人；队列用一列像素方块表示。 | “欢迎来到月球基地！每个小人代表在这一时刻到达的工作人员。” |
| **前缀和计算** | 小人头顶出现 `tim[i]`、`s[i]` 两个像素数字，快速累加。 | “先算出总人数与总到达时刻，为后续加速做准备。” |
| **凸壳维护** | 队列方块在跑道下方，斜率小的方块被“踢出”并伴随“叮”音效；新方块滑入队列尾部。 | “斜率 ≤ i 的方块被淘汰，保证队列永远是下凸壳。” |
| **决策点选择** | 队头方块高亮闪金光，其坐标 `(tim_j, dp_j+s_j)` 被标记；一条像素射线斜率=i 扫过，交点即最优 j。 | “队头就是当前最优起飞点，等待总时间更新！” |
| **最终冲刺** | 时间轴跑到 `mx` 后，列车最后一次起飞，像素烟花庆祝，显示最终最小等待时间。 | “任务完成！所有人员已安全疏散。” |

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**  
斜率优化 DP 适用于形如  
`dp[i]=min/max (A[i]·B[j] + C[j] + D[i])`  
的决策单调或凸壳性质问题，例如：

- 区间调度最小费用  
- 任务分批加工最小成本  
- 在线股票交易最大收益  

**洛谷推荐**

| 题号 | 推荐理由 |
|---|---|
| **P3195 [HNOI2008] 玩具装箱** | 经典斜率优化入门，套模板即可。 |
| **P3628 [APIO2010] 特别行动队** | 在斜率优化基础上加入“截距”变化，加深理解。 |
| **P4072 [SDOI2016] 征途** | 多维决策 + 斜率优化，锻炼建模能力。 |

---

## 7. 学习心得与经验分享

YZren 在题解末尾幽默地写下 `return !!!!!("YZren")`，提醒我们：

- **调试技巧**：当斜率分母为 0 时，用极小量 1e-9 避免除零，防止 WA。  
- **边界意识**：`maxx+=m-1` 与最后二次取最小值，是防止“漏掉最后一班车”的经典套路。

---

> 祝各位少年在算法星河中继续远航！我们下道题再见。

---
处理用时：128.42秒
# 题目信息

# [NOIP 2003 提高组] 侦探推理

## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！

## 说明/提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题

## 样例 #1

### 输入

```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??
```

### 输出

```
MIKE
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：侦探推理 深入学习指南 💡

> 欢迎来到今天的推理现场！我们要帮助明明同学从一堆证词里揪出唯一的“罪犯”。这不仅考验代码能力，更像是一场逻辑版的“狼人杀”。

---

## 1. 题目解读与策略初探

**✨ 核心挑战**：  
“在 M≤20 个人、P≤100 句话里，**唯一罪犯**和**今天是星期几**都未知，还要考虑 N 个人始终说假话。如何快速而准确地锁定罪犯？”

**✨ 算法标签**：  
- 枚举 / 暴力  
- 逻辑一致性校验  
- 字符串解析

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现 & 指向 |
|------|-------------|
| **线索1：数据范围** | M≤20，星期只有 7 天 ⇒ 总状态数 ≤ 20×7 = **140**，完全可枚举。 |
| **线索2：唯一解** | “凶手只有一个” ⇒ 只需找到**恰好一个** (i, day) 组合满足所有证词逻辑。 |
| **线索3：真假恒定** | 每个人要么全真要么全假 ⇒ 可用 **0/1/未知** 三值逻辑快速判断。 |

---

### 🧠 思维链构建：从线索到策略

1. **暴力搜索？**  
   20×7=140 种状态 → 每状态检查 100 句话 → 1.4×10⁴ 次操作，**可接受**。

2. **剪枝优化？**  
   一旦某状态下出现**同一人既说真话又说假话**，立即剪枝。

3. **结果合并？**  
   若多个 (i, day) 指向不同罪犯 → `Cannot Determine`；无合法状态 → `Impossible`。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|------|----------|
| **wjyyy** (赞21) |  
- 用 `map<string,int>` 映射人名，优雅处理字符串；  
- 把每句话抽象成 `struct sta{u,to,is}`，逻辑清晰；  
- 用 `ran` 统计“从未说过合法话”的人，巧妙处理“既真又假”边界。  

| **Ebola** (赞9) |  
- 二维数组存证词，手写 `crap()` 过滤废话，思路直白；  
- 两次独立判断：  
  ① `judge()` 检查**是否自相矛盾**；  
  ② `check()` 统计**假话人数是否恰好为 N**。  

| **Phigros_11calors** (赞3) |  
- 用 **-1/0/1** 表示“未知/真话/假话”，状态压缩直观；  
- 提前剪枝：已确定 ≥2 个罪犯直接输出 `Cannot Determine`。  

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 & 学习笔记 |
|--------|------------------|
| **1. 字符串解析** | 将自然语言证词转成 **(主语, 对象, 肯定/否定, 类别)** 四元组，避免手写 `substr` 错位。💡 用 `stringstream` 或正则更稳健。 |
| **2. 一致性校验** | 对每句话，根据“假设罪犯 i、星期 d”立即算出真假，**若同一人出现矛盾则剪枝**。💡 三值逻辑：真/假/未知。 |
| **3. 假话人数统计** | 真话人数 = 总合法说话人数 − 假话人数；未知的人可自由填补使总数 = N。💡 数学式：`cnt ≤ N ≤ cnt + none`。 |

---

### ⚔️ 策略竞技场

| 策略 | 思想 | 复杂度 | 优缺点 | 得分预期 |
|------|------|--------|--------|----------|
| **纯暴力** | 枚举 2^M 种真假组合 | O(2^M·P) | 思路直观，但 M=20 会 TLE | 30% |
| **枚举罪犯+星期** | 20×7 状态 | O(M·7·P) | **最优**，易写易调 | 100% |
| **SAT 求解** | 把证词转布尔式 | 依赖求解器 | 理论优雅，码量大 | 100% |

---

### ✨ 优化之旅
从“枚举真假”到“枚举罪犯+星期”，我们把指数级状态压缩到**线性×常数**，核心在于**抓住唯一变量**（罪犯、星期），其余信息皆可推导。

---

## 4. C++核心代码实现赏析

### 本题通用核心实现（整合版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXM = 25, MAXP = 105;
struct Sentence {
    int speaker;   // 说话人
    int target;    // 涉及的人(0=自己, 1..m=他人)
    bool guilty;   // 是否指控
    int day;       // 星期几(0=无关)
};
vector<Sentence> say[MAXM];   // say[i] = 第i个人说的话
int m, n, p;
string name[MAXM];
map<string, int> mp;

// 判断在假设(g, d)下是否矛盾，并统计假话人数
bool check(int g, int d, int& liar) {
    liar = 0;
    vector<int> truth(m + 1, -1);   // -1=未知, 0=真话, 1=假话
    for (int i = 1; i <= m; ++i) {
        bool hasFalse = false, hasTrue = false;
        for (const auto& s : say[i]) {
            bool ok;
            if (s.day) {            // 说星期
                ok = (s.day == d);
            } else {               // 说罪犯
                int real = (s.target ? s.target : i);
                ok = (real == g) == s.guilty;
            }
            if (ok) hasTrue = true;
            else    hasFalse = true;
        }
        if (hasTrue && hasFalse) return false; // 矛盾
        if (hasFalse) truth[i] = 1, liar++;
        else if (hasTrue) truth[i] = 0;
    }
    int unknown = m - count(truth.begin()+1, truth.end(), 0) - count(truth.begin()+1, truth.end(), 1);
    return (liar <= n && n <= liar + unknown);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> m >> n >> p;
    for (int i = 1; i <= m; ++i) {
        cin >> name[i];
        mp[name[i]] = i;
    }
    for (int i = 1; i <= p; ++i) {
        string speaker, colon, word;
        cin >> speaker >> colon;
        speaker.pop_back();           // 去掉冒号
        int sp = mp[speaker];
        string line;
        getline(cin, line);
        while (!line.empty() && isspace(line.back())) line.pop_back();
        stringstream ss(line);
        string w;
        vector<string> tokens;
        while (ss >> w) tokens.push_back(w);
        if (tokens.empty()) continue;

        Sentence sent;
        sent.speaker = sp;
        sent.day = 0;
        sent.target = 0;

        if (tokens[0] == "I") {
            if (tokens[1] == "am") {
                if (tokens[2] == "guilty.") sent.guilty = true, sent.target = 0;
                else if (tokens[2] == "not" && tokens[3] == "guilty.") sent.guilty = false, sent.target = 0;
                else continue;
            } else continue;
        } else if (tokens[0] == "Today") {
            if (tokens[1] == "is") {
                string dayStr = tokens[2];
                static const vector<string> days = {"Monday.", "Tuesday.", "Wednesday.", "Thursday.", "Friday.", "Saturday.", "Sunday."};
                auto it = find(days.begin(), days.end(), dayStr);
                if (it == days.end()) continue;
                sent.day = it - days.begin() + 1;
            } else continue;
        } else {
            string targetName = tokens[0];
            if (mp.find(targetName) == mp.end()) continue;
            sent.target = mp[targetName];
            if (tokens[1] == "is") {
                if (tokens[2] == "guilty.") sent.guilty = true;
                else if (tokens[2] == "not" && tokens[3] == "guilty.") sent.guilty = false;
                else continue;
            } else continue;
        }
        say[sp].push_back(sent);
    }

    string ans = "Impossible";
    for (int g = 1; g <= m; ++g) {
        for (int d = 1; d <= 7; ++d) {
            int liar;
            if (check(g, d, liar)) {
                if (ans != "Impossible" && ans != name[g]) {
                    cout << "Cannot Determine\n";
                    return 0;
                }
                ans = name[g];
            }
        }
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**主题**：8-bit 侦探事务所  
- **场景**：像素风办公室，墙上挂着 7 张星期牌。  
- **角色**：20 个像素小人依次发言，头顶弹出对话框。  
- **核心动画**：
  1. 鼠标点击“开始”→ 遍历罪犯 i 与星期 d。  
  2. 每句话出现时，像素小人说真话则冒绿色“√”，假话冒红色“×”。  
  3. 若出现同一人既有√又有×，小人变灰并触发“矛盾”音效。  
  4. 底部进度条显示当前枚举进度 `(i,d)`。  
- **交互**：  
  - 步进按钮：单帧查看每句话的真假判定。  
  - 速度滑块：1× / 2× / 4×。  
  - 关键帧截图：成功锁定罪犯时，像素小人戴上侦探帽并播放胜利 BGM。

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**  
- **三值逻辑**（真/假/未知）同样适用于：  
  1. 电路故障诊断（某元件好坏未知）。  
  2. 狼人杀 AI（身份未知/好人/狼人）。  
  3. 约束满足问题（CSP）建模。

**洛谷推荐**  
1. **P1040** 加分二叉树  
   *巩固枚举+剪枝思维，把枚举对象从“人”变成“根节点”。*  
2. **P2679** 子串  
   *字符串DP+状态压缩，体验如何把自然语言转成状态。*  
3. **P1312`  Mayan 游戏  
   *复杂规则下的暴力+剪枝，锻炼“枚举+校验”套路。*  

---

## 7. 学习心得与经验分享

> **wjyyy 的踩坑提醒**：  
> “必须逐词校验合法性，漏掉句号会导致整句被判合法！”  
> **洛语云笺点评**：  
> 字符串题最怕边界字符，**读入后统一去掉尾部空格/控制字符**是通用技巧。建议本地打印中间结构体，肉眼核对。

---

<conclusion>
今天的侦探之旅到此结束！记住：  
- **小范围 → 大胆枚举**  
- **唯一解 → 双重校验**  
- **字符串 → 结构化解析**  
下次我们再一起破解更烧脑的案件！🕵️‍♂️
</conclusion>

---
处理用时：79.72秒
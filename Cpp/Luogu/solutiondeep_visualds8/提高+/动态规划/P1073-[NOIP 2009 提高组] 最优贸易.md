# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果

# 💡 洛语云笺的C++算法解析：最优贸易 深入学习指南 💡

> 各位同学，欢迎来到今天的算法探险！今天我们要一起攻克的是一道经典图论题——**最优贸易**。这不仅是一道题，更是一次思维的飞跃。我们将从题目描述中抽丝剥茧，找到解决问题的钥匙。

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在一张有向/无向混合的图中，从城市1出发到城市n，最多进行一次买卖（在某城市买入水晶球，在后续城市卖出），求最大利润。

✨ **核心算法标签**：`分层图最短/最长路`、`强连通分量缩点(SCC) + DAG DP`、`SPFA/BFS`

🗣️ **初步分析**：

> 这道题的核心在于**如何优雅地处理“买卖一次”的限制**。我们可以把问题抽象为：找到一条从1到n的路径，路径上存在两个点i和j（i在j之前），使得 `price[j] - price[i]` 最大。

> 面对这个问题，我们可以有几种思考路径：
> 1. **暴力思路**：枚举所有可能的i和j，检查1能否到i，i能否到j，j能否到n。复杂度爆炸。
> 2. **分层图**：将图“复制”三份，分别代表“未买”、“已买”、“已卖”三种状态，通过层间转移边实现买卖操作。
> 3. **SCC+DAG**：先缩点将图变为DAG，再在DAG上进行动态规划，求出每个点的最小买入价和最大卖出价。

> **引出核心算法**：分层图模型是解决此类“状态转移”问题的利器，它将复杂的买卖逻辑转化为简单的图边，让我们能用最短/最长路算法高效求解。

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**: "求最大利润" → **最优化问题**。
2.  **线索2 (问题约束)**: "最多买一次卖一次" → **状态转移**（未买→已买→已卖）。
3.  **线索3 (数据规模)**: n ≤ 1e5, m ≤ 5e5 → 需要 **O(M log N) 或 O(M)** 级别算法。

### 🧠 思维链构建：从线索到策略
> 1.  **线索1**告诉我们这是一个最优化问题，贪心可能局部最优，但无法保证全局最优。
> 2.  **线索2**的“状态转移”是关键！分层图模型天然适合：每一层代表一种状态，层间边代表状态转移（买卖）。
> 3.  **线索3**的数据规模排除了暴力，SPFA或Dijkstra处理分层图是可行选择。
> 4.  **结论**：**分层图最长路**（或最短路）是直击要害的策略！

---

## 2. 精选优质题解参考

<eval_intro>
经过仔细评估，我为大家精选了以下3份高质量题解，它们从不同角度诠释了最优解的精髓。
</eval_intro>

**题解一：分层图SPFA（作者：fy1234567ok）**
* **点评**：这份题解提出了**最优雅的分层图思路**。它将原图复制为三层（0:未买, 1:已买, 2:已卖），通过巧妙的建边将买卖操作转化为层间转移。代码仅40行，清晰易懂，完美体现了“问题转化”的艺术。

**题解二：SCC+DAG DP（作者：ctzm）**
* **点评**：当图不是DAG时，分层图可能面临负权环问题。这份题解另辟蹊径，先用**Tarjan缩点**将图变为DAG，再在DAG上进行拓扑DP。它解决了缩点后如何正确更新最小买入价和最大卖出价的问题，思路严谨，代码稳健。

**题解三：双SPFA（作者：Ngo123）**
* **点评**：这份题解采用了**两次SPFA**的巧妙方法：
  1. 从1出发，求到每个点i的最小买入价 `minv[i]`。
  2. 建反图，从n出发，求到每个点i的最大卖出价 `maxv[i]`。
  3. 最终答案就是 `max(maxv[i] - minv[i])`。
  这种方法避免了显式分层，思路直观，实现简单。

---

## 3. 解题策略深度剖析

<difficulty_intro>
让我们深入剖析每种策略的核心难点与实现细节。
</difficulty_intro>

### 🎯 核心难点与关键步骤

1.  **关键点1：分层图的建图技巧**
    * **分析**：如何将“未买→已买→已卖”转化为图边？核心在于**复制节点**。
      - 第0层：节点 `i` 表示“在i，未买”。
      - 第1层：节点 `i+n` 表示“在i，已买”。
      - 第2层：节点 `i+2n` 表示“在i，已卖”。
    * **建边规则**：
      - 层内移动：原图边权为0（移动无成本）。
      - 买入转移：`i → i+n`，边权为 `-price[i]`（买入花费）。
      - 卖出转移：`i+n → i+2n`，边权为 `price[i]`（卖出获利）。
    * 💡 **学习笔记**：分层图的本质是**状态空间扩展**，将二维问题（节点+状态）映射到三维空间。

2.  **关键点2：最长路的正确求解**
    * **分析**：由于存在负权边（买入边），Dijkstra不适用，需用**SPFA**。
    * **初始化**：`dis[1] = 0`，其余设为 `-INF`。
    * **松弛条件**：`if (dis[v] < dis[u] + w) dis[v] = dis[u] + w`。
    * 💡 **学习笔记**：SPFA的队列优化使其在稀疏图上效率接近O(M)。

3.  **关键点3：SCC缩点的正确性保证**
    * **分析**：缩点后的DAG中，每个SCC的`minw`和`maxw`如何定义？
      - `minw[SCC]`：该SCC中所有点的最小价格。
      - `maxw[SCC]`：该SCC中所有点的最大价格。
    * **DP转移**：`dp[v] = min(dp[v], min(dp[u], minw[v]))`，答案为 `max(maxw[i] - dp[i])`。
    * 💡 **学习笔记**：缩点将复杂图结构简化为DAG，是解决有环问题的通用技巧。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **分层图SPFA** | 三层图表示状态，跑最长路 | 思路直观，代码简洁 | 需处理负权边 | 通用，尤其适合状态转移问题 |
| **SCC+DAG DP** | 缩点后DAG上DP | 无负权边困扰，理论最优 | 实现复杂，需Tarjan | 图有环且需保证正确性 |
| **双SPFA** | 两次SPFA求极值 | 避免显式分层，实现简单 | 需建反图 | 无环或环不影响结果时 |

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**（分层图SPFA版）
* **说明**：综合fy1234567ok的简洁实现，提供最清晰的模板。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    const int maxn = 1e5 + 5;

    int n, m, d[maxn * 3], inq[maxn * 3];
    vector<pair<int, int>> G[maxn * 3];

    #define t(x, i) (x + i * n)  // 第i层的x节点
    #define add(x, y) G[t(x, 0)].push_back({t(y, 0), 0}), \
                      G[t(x, 1)].push_back({t(y, 1), 0}), \
                      G[t(x, 2)].push_back({t(y, 2), 0})

    void spfa(int s) {
        fill(d, d + 3 * n + 1, INT_MIN);
        d[s] = 0;
        queue<int> q; q.push(s); inq[s] = 1;
        while (!q.empty()) {
            int x = q.front(); q.pop(); inq[x] = 0;
            for (auto [v, len] : G[x]) {
                if (d[v] < d[x] + len) {
                    d[v] = d[x] + len;
                    if (!inq[v]) { q.push(v); inq[v] = 1; }
                }
            }
        }
    }

    int main() {
        ios::sync_with_stdio(false); cin.tie(nullptr);
        cin >> n >> m;
        for (int i = 1, v; i <= n; ++i) {
            cin >> v;
            G[t(i, 0)].push_back({t(i, 1), -v}); // 买入
            G[t(i, 1)].push_back({t(i, 2), v});  // 卖出
        }
        for (int i = 1, x, y, z; i <= m; ++i) {
            cin >> x >> y >> z;
            add(x, y);
            if (z == 2) add(y, x);
        }
        spfa(t(1, 0));
        cout << max(0, d[t(n, 2)]) << endl;
        return 0;
    }
    ```
* **代码解读概要**：通过`t(x, i)`宏巧妙管理三层节点，SPFA处理最长路，最终答案取`max(0, d[t(n, 2)])`处理不交易的情况。

---

## 5. 算法可视化：像素动画演示

**动画演示主题**：**“像素商人”的三层迷宫探险**

**核心演示内容**：
- 一个8位像素商人从城市1出发，穿越三层迷宫（未买→已买→已卖）。
- 每层迷宫用不同颜色像素块表示，商人移动时播放“哒哒”脚步声。
- 关键操作（买入/卖出）时：
  - 买入：商人头上出现“$-price[i]$”红色像素数字，伴随“叮”音效。
  - 卖出：商人头上出现“+$price[j]$”绿色像素数字，伴随“叮”音效。
- 最终到达城市n时，显示总利润像素化横幅，播放胜利音效。

**技术实现**：
- 使用Canvas绘制三层网格，每层节点用`i, i+n, i+2n`坐标映射。
- 队列动画：SPFA队列用像素化火车车厢表示，每松弛一次更新车厢颜色。
- 交互：提供“单步执行”和“AI自动演示”模式，速度滑块控制帧率。

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**：
1. **航班转机**：分层图处理“最多转机k次”的最便宜机票。
2. **技能升级**：每层代表技能等级，边权代表升级花费。
3. **时间旅行**：每层代表不同时间点，处理时间悖论。

**洛谷推荐**：
1. **P2939 [USACO09FEB]改造路Revamping Trails** - 分层图经典入门。
2. **P4568 [JLOI2011]飞行路线** - 分层图处理免费边。
3. **P4822 [BJWC2012]冻结** - 分层图+最短路综合应用。

---

## 7. 学习心得与经验分享

> **来自fy1234567ok的调试心得**："最初在建分层图时，误将层间边指向了下一层可达的所有点，导致逻辑错误。修正为**仅指向同编号的下一层节点**后，模型才正确。"

**洛语云笺点评**：这个教训提醒我们，**分层图的层间边必须精确反映状态转移**，任何多余的指向都会破坏模型正确性。

---

<conclusion>
今天我们一起探索了最优贸易的多种解法，从优雅的分层图到严谨的SCC缩点。记住，**算法的选择往往源于对问题结构的深刻洞察**。下次遇到类似“状态转移”问题时，不妨先想想：能否用分层图来建模？保持好奇，继续探索！💪
</conclusion>

---
处理用时：74.52秒
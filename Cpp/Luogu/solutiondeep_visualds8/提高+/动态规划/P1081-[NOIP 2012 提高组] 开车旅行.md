# 题目信息

# [NOIP 2012 提高组] 开车旅行

## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。


## 说明/提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。


## 样例 #1

### 输入

```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3
```

### 输出

```
1 
1 1 
2 0 
0 0 
0 0 ```

## 样例 #2

### 输入

```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7```

### 输出

```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[NOIP 2012 提高组] 开车旅行 深入学习指南 💡

> 各位少年探险家，欢迎来到“开车旅行”的思维赛道！  
> 这道题像一场“双人拉力赛”：A 和 B 轮流踩油门，但 A 只认“第二近”的加油站，B 只认“最近”的加油站。  
> 我们的任务，是帮 A 找出“最划算”的起点，并在任意起点-里程限制下，快速算出两人各跑了多少公里。  
> 核心挑战：**如何高效模拟并查询两人在长为 1e5 的赛道上的行驶轨迹？**  
> 答案就藏在“倍增”这一把“时光加速钥匙”里！

✨ **本题核心挑战**：在 n ≤ 1e5、m ≤ 1e5 的规模下，快速回答  
1. 给定总里程 X，从哪个城市出发能让 A 的行驶路程 / B 的行驶路程最小？  
2. 给定起点 s 与里程 X，A、B 各自行驶了多少公里？

✨ **核心算法标签**：倍增（Binary Lifting）、链表预处理、双指针/平衡树/Set 优化最近/次近点查找。

---

## 1. 题目解读与策略初探

### 🗣️ 初步分析：从暴力到倍增
1. **暴力思路**：对每个起点，逐天模拟 A→B→A→B… 的行驶过程，时间复杂度 O(nm)，无法通过 1e5 数据。
2. **关键洞察**：两人轮流开车，每两天（A+B）构成一个“宏观步”。若能预处理“从城市 i 走 2^k 个宏观步”的信息，就能用“倍增”在 O(log n) 时间内回答任意 (s,X) 查询。
3. **核心算法**：  
   - **Step 1 预处理**：为每个城市 i，求出其向东方向上的最近城市（B 策略）与次近城市（A 策略）。  
   - **Step 2 倍增**：构建 f[k][i] 表示从 i 走 2^k 个宏观步到达的城市；da[k][i], db[k][i] 分别记录这 2^k 步里 A、B 的行驶距离。  
   - **Step 3 查询**：从高到低枚举 k，贪心地“跳” 2^k 步，累加距离，直到不能再跳。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 原文表述 | 对应策略 |
|---|---|---|
| **方向限制** | “一直向东行驶” | 只能选编号更大的城市，可用链表/Set 维护有序序列并删除已用城市。 |
| **交替驾驶** | “第一天 A，之后每天轮换” | 每两天构成一个“宏观步”，倍增的“步长”天然契合 2^k。 |
| **大规模数据** | n, m ≤ 1e5 | 暴力 O(nm) → 倍增 O((n+m) log n)。 |

### 🧠 思维链构建：从线索到策略
> 1. 看到“交替驾驶”，想到**周期性**：每两天 A+B 完成一次“宏观步”。  
> 2. 看到“向东行驶”，想到**有序性**：将城市按海拔排序后，最近/次近点一定在左右两侧，可用链表或 Set 维护。  
> 3. 看到“多次查询”，想到**可重复性**：用倍增存储“走 2^k 步”的信息，查询时 log n 时间合并。  
> 4. **结论**：先 O(n log n) 预处理“最近/次近点”，再 O(n log n) 构建倍增数组，最终 O((n+m) log n) 回答所有查询。

---

## 2. 精选优质题解参考

> 以下题解均经洛语云笺“五星好评”筛选，各有亮点，互为补充。

| 题解 | 亮点提炼 | 关键技巧 |
|---|---|---|
| **yangrunze** (赞108) | 完整链路：链表预处理 → 倍增 → 查询；代码清晰，注释丰富。 | 双向链表删除节点保证“向东”方向性。 |
| **shadow__** (赞76) | 聚焦“初始化难点”，用链表 O(n) 求最近/次近点。 | 排序后只需检查左右各两个点即可确定最近/次近。 |
| **star_fish** (赞4) | 提供 80pts 暴力 + 100pts 倍增两套代码，便于对比。 | 用优先队列优化链表查找，常数更小。 |
| **Shadow_Soldier** (赞3) | 详细推导倍增状态方程，适合深入理解。 | 用 `__int128` 避免比值比较精度问题。 |
| **Neumann** (赞3) | 将 A+B 两天视为“一步”，简化倍增状态。 | 用 Set 倒序插入，O(n log n) 预处理最近/次近。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤 (最优解法剖析)

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 预处理最近/次近城市** | 将城市按海拔排序后，用双向链表或 Set 维护动态序列；每次处理城市 i 后删除，保证后续城市编号均 > i。 | “删除”思想是处理“方向限制”的利器。 |
| **2. 倍增数组设计** | f[k][i]：从 i 走 2^k 个“宏观步”到达的城市；da[k][i], db[k][i]：对应 A、B 的行驶距离。 | 宏观步 = A 一步 + B 一步，天然契合交替驾驶。 |
| **3. 查询时的贪心跳跃** | 从高到低枚举 k，若走 2^k 步不超限则跳，累加距离。 | 类似 LCA 的“二进制拆分”思想。 |

### ✨ 解题技巧总结
- **技巧A 链表/Set 预处理**：将“方向限制”转化为“动态删除”，O(n log n) 或 O(n)。
- **技巧B 倍增状态设计**：将“交替驾驶”封装为“宏观步”，倍增数组维度 k ≤ log n。
- **技巧C 比值比较**：用交叉相乘 (`__int128`) 避免浮点精度，注意分母为 0 的特判。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力模拟** | 逐天模拟 A→B→A… | 思路直观 | O(nm) 超时 | n ≤ 100 |
| **链表+倍增** | 链表预处理最近/次近，倍增查询 | O((n+m) log n) 通过 | 代码较长 | n,m ≤ 1e5 |
| **Set+倍增** | Set 维护有序序列，倍增查询 | 实现简洁，常数稍大 | Set 常数较大 | 同上 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合 yangrunze 与 Shadow_Soldier 思路，提供清晰、可编译的完整核心代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int MAXN = 1e5 + 10;
const int LOG = 20;

struct City {
    int h, id;
} c[MAXN];

bool cmp(const City &a, const City &b) {
    return a.h < b.h;
}

int n, m, pos[MAXN], pre[MAXN], nxt[MAXN];
int ga[MAXN], gb[MAXN];              // A/B 下一步城市
int f[LOG][MAXN][2];                 // f[k][i][0/1] 走 2^k 步到达城市
ll da[LOG][MAXN][2], db[LOG][MAXN][2]; // 对应 A/B 行驶距离

// 双向链表删除节点
void del(int x) {
    if (pre[x]) nxt[pre[x]] = nxt[x];
    if (nxt[x]) pre[nxt[x]] = pre[x];
}

// 预处理最近/次近
void preprocess() {
    for (int i = 1; i <= n; ++i) {
        pre[i] = i - 1, nxt[i] = i + 1;
    }
    nxt[n] = 0;
    for (int i = 1; i < n; ++i) {
        int p = pos[i], l = pre[p], r = nxt[p];
        // 选择最近城市 gb[i]
        if (l && (!r || abs(c[p].h - c[l].h) <= abs(c[r].h - c[p].h))) {
            gb[i] = c[l].id;
            // 次近城市 ga[i]
            if (pre[l] && (!r || abs(c[p].h - c[pre[l]].h) <= abs(c[r].h - c[p].h))) {
                ga[i] = c[pre[l]].id;
            } else {
                ga[i] = c[r].id;
            }
        } else {
            gb[i] = c[r].id;
            if (l && (!nxt[r] || abs(c[p].h - c[l].h) <= abs(c[nxt[r]].h - c[p].h))) {
                ga[i] = c[l].id;
            } else {
                ga[i] = c[nxt[r]].id;
            }
        }
        del(p);
    }
}

// 倍增初始化
void init() {
    for (int i = 1; i <= n; ++i) {
        f[0][i][0] = ga[i];
        f[0][i][1] = gb[i];
        if (ga[i]) da[0][i][0] = abs(c[pos[i]].h - c[pos[ga[i]]].h);
        if (gb[i]) db[0][i][1] = abs(c[pos[i]].h - c[pos[gb[i]]].h);
    }
    for (int k = 1; k < LOG; ++k) {
        for (int i = 1; i <= n; ++i) {
            for (int t = 0; t < 2; ++t) {
                int mid = f[k - 1][i][t];
                if (!mid) continue;
                int next_t = (k == 1) ? (t ^ 1) : t;
                f[k][i][t] = f[k - 1][mid][next_t];
                da[k][i][t] = da[k - 1][i][t] + da[k - 1][mid][next_t];
                db[k][i][t] = db[k - 1][i][t] + db[k - 1][mid][next_t];
            }
        }
    }
}

// 计算 (s, X)
pair<ll, ll> calc(int s, ll X) {
    ll la = 0, lb = 0;
    int k = 0; // 0: A 先开
    for (int i = LOG - 1; i >= 0; --i) {
        int to = f[i][s][k];
        if (!to) continue;
        ll sum = da[i][s][k] + db[i][s][k];
        if (sum > X) continue;
        X -= sum;
        la += da[i][s][k];
        lb += db[i][s][k];
        s = to;
        k ^= 1;
    }
    if (k == 0 && ga[s] && abs(c[pos[s]].h - c[pos[ga[s]]].h) <= X) {
        la += abs(c[pos[s]].h - c[pos[ga[s]]].h);
    }
    return {la, lb};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> c[i].h;
        c[i].id = i;
    }
    sort(c + 1, c + n + 1, cmp);
    for (int i = 1; i <= n; ++i) pos[c[i].id] = i;

    preprocess();
    init();

    ll X0;
    cin >> X0;
    int best = 1;
    pair<ll, ll> ans = calc(1, X0);
    for (int i = 2; i <= n; ++i) {
        auto cur = calc(i, X0);
        if (ans.second == 0) {
            if (cur.second == 0 && c[pos[i]].h > c[pos[best]].h) best = i;
        } else if (cur.second == 0) {
            // 当前无穷大，跳过
        } else {
            __int128_t a1 = (__int128_t)cur.first * ans.second;
            __int128_t a2 = (__int128_t)ans.first * cur.second;
            if (a1 < a2 || (a1 == a2 && c[pos[i]].h > c[pos[best]].h)) {
                best = i;
                ans = cur;
            }
        }
    }
    cout << best << '\n';

    cin >> m;
    while (m--) {
        int s;
        ll X;
        cin >> s >> X;
        auto [la, lb] = calc(s, X);
        cout << la << ' ' << lb << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素赛车手”的倍增之旅**  
> 风格：8 位像素风，复古 HUD，音效提示。

### 动画设计
1. **场景初始化**  
   - 横向 1×n 像素赛道，城市用彩色方块表示，海拔高度映射为方块高度。
   - 左侧 HUD 显示当前起点 s、剩余里程 X、A/B 已行驶距离。

2. **预处理阶段**  
   - 城市按海拔排序，生成双向链表动画：排序后城市像“音符”依次排列。
   - 处理城市 i 时，高亮其左右各两个邻居，用箭头标出最近/次近城市，随后“删除”节点（方块淡出）。

3. **倍增构建**  
   - 屏幕中央出现“2^k”像素大字，逐层展示 f[k][i]、da[k][i]、db[k][i] 的填充过程。
   - 每填充一行，播放“叮”音效，颜色渐变表示数据已更新。

4. **查询演示**  
   - 选择起点 s 与 X，像素赛车从 s 出发，按二进制位从高到低跳跃：
     - 可跳 2^k 步时，赛车闪现到目标城市，HUD 累加距离，播放“加速”音效。
     - 无法跳跃时，赛车闪烁红色，播放“刹车”音效。
   - 最终抵达终点，HUD 显示 A/B 距离，播放“胜利”音效。

5. **交互控制**  
   - 底部按钮：单步、自动播放、重置。
   - 速度滑块：调整动画速度。
   - 关卡模式：将每个查询视为一关，完成即“通关”。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **倍增思想**适用于：  
  1. **LCA 最近公共祖先**：树上倍增跳祖先。  
  2. **区间最值查询**：ST 表 O(1) 查询区间最值。  
  3. **快速幂**：指数二进制拆分加速幂运算。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P3379** [LCA 最近公共祖先] | 经典倍增模板，练习树上倍增。 |
| **P3865** [ST 表] | 区间最值倍增，巩固二维倍增数组。 |
| **P1083** [借教室] | 倍增 + 二分，解决区间覆盖问题。 |
| **P4155** [双端队列] | 链表/双端队列技巧，与预处理最近点类似。 |

---

## 7. 学习心得与经验分享

> **来自 yangrunze**：  
> “双向链表调试一晚上，细节在于边界判断：pre[x]=0 或 nxt[x]=0 时要特判。”  
> **洛语云笺点评**：链表预处理是倍增的基础，边界处理是调试关键。

> **来自 Shadow_Soldier**：  
> “用 __int128 避免比值精度问题，但注意编译器支持。”  
> **洛语云笺点评**：大整数乘法是避免浮点误差的通用技巧。

---

> 本次“开车旅行”解析到此结束。记住：  
> **“倍增”是一把钥匙，能打开任何‘重复+可合并’问题的大门！**  
> 下次赛道见，继续加速！

---
处理用时：127.59秒
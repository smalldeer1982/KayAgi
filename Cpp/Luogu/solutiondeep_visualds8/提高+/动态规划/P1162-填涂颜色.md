# 题目信息

# 填涂颜色

## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 30$。


## 样例 #1

### 输入

```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1
```

### 输出

```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：P1162「填涂颜色」深入学习指南 💡

<introduction>
今天我们来一起分析“P1162 填涂颜色”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。
</introduction>

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在一个由0和1组成的方阵中，找出被“1”围成的闭合圈内部的所有0，并将它们替换为2。

✨ **核心算法标签**：搜索(BFS/DFS), 连通块, Flood Fill

🗣️ **初步分析**：
- 直接找出“圈内0”比较困难，但我们可以逆向思考：**先标记所有“圈外0”**，剩下的0自然就是圈内0。
- 由于题目保证只有一个闭合圈，圈内0与圈外0必然不连通。
- 我们可以利用**Flood Fill**算法，从方阵边界开始，将所有能到达的0标记为“已访问”，最后未被标记的0即为圈内0。

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**: "要求把闭合圈内的所有空间都填写成2"，这是一个**连通块标记**问题。
2.  **线索2 (问题约束/特性)**: "如果从某个0出发，无法到达方阵的边界，就认为这个0在闭合圈内"，这意味着我们可以用**连通性**来判断圈内圈外。
3.  **线索3 (数据规模)**: "1 ≤ n ≤ 30"，数据范围很小，**暴力搜索**即可通过，无需复杂优化。

### 🧠 思维链构建：从线索到策略
> "好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1.  首先，【线索1：问题目标】告诉我们需要标记“圈内0”。
> 2.  接着，【线索2：问题特性】给了我们一个决定性提示：圈内0无法到达边界，而圈外0可以。因此，我们可以反向思考，**先标记所有圈外0**，剩下的就是圈内0。
> 3.  最后，【线索3：数据规模】给了我们最终判决：n ≤ 30，我们可以使用**BFS或DFS**进行Flood Fill，无需优化。
> 4.  **结论**：综合以上，一个简单高效的策略是：**从边界开始搜索，标记所有能到达的0为“圈外”，剩下的0即为“圈内”**。

---

## 2. 精选优质题解参考

<eval_intro>
为了更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等几个方面，为大家筛选了以下评分较高（≥4星）的题解。
</eval_intro>

**题解一：LMB_001 (赞：1317)**
* **点评**：这份题解思路清晰，采用了**DFS从(0,0)开始搜索**的策略，巧妙地利用了方阵外默认的0作为起点，代码简洁易懂，是学习Flood Fill的绝佳范例。

**题解二：冰冻赤道 (赞：282)**
* **点评**：这份题解详细解释了**BFS从边界开始搜索**的思路，通过枚举边界上的0作为起点，逐步扩展标记圈外0，代码规范，注释详尽，适合初学者理解BFS的实现细节。

**题解三：Rec° (赞：155)**
* **点评**：这份题解展示了**“反色”技巧**的妙用：先将所有0改为2，再从(0,0)开始搜索，将圈外2改回0，最后输出时直接呈现结果，代码短小精悍，体现了逆向思维的巧妙。

**题解四：oistr (赞：6)**
* **点评**：这份题解深入探讨了**如何用一个数组同时存储原始值和访问状态**，通过巧妙的数值标记（如3表示已访问的圈外0），避免了额外数组，体现了空间优化的技巧。

---

## 3. 解题策略深度剖析

<difficulty_intro>
通往正确答案的道路不止一条，但有些路平坦高效，有些则崎岖难行。让我们深入剖析解决这道题的几种核心策略，看看高手是如何思考的。
</difficulty_intro>

### 🎯 核心难点与关键步骤 (最优解法剖析)
1.  **关键点1：如何区分圈内0和圈外0？**
    * **分析**：直接判断一个0是否在圈内比较困难，但可以逆向思考：**所有圈外0都与边界连通**。因此，我们可以从边界开始搜索，标记所有能到达的0为“圈外”，剩下的0即为“圈内”。
    * 💡 **学习笔记**：逆向思维是解决这类问题的关键，将“找圈内”转化为“标记圈外”。

2.  **关键点2：如何高效搜索圈外0？**
    * **分析**：可以使用**BFS或DFS**进行Flood Fill。从方阵的四个边界（或外部(0,0)点）开始搜索，遇到0就标记为已访问（如改为3或2），遇到1就停止。
    * 💡 **学习笔记**：Flood Fill是解决连通块标记问题的通用方法，BFS和DFS均可实现。

3.  **关键点3：如何处理边界情况？**
    * **分析**：为了避免边界判断的复杂性，可以在方阵外**额外加一圈0**（如从(0,0)开始搜索），这样所有圈外0都连通，搜索更加简单。
    * 💡 **学习笔记**：通过扩展边界简化问题，是处理边界情况的常用技巧。

### ✨ 解题技巧总结
-   **技巧A (逆向思维)**：将“找圈内0”转化为“标记圈外0”，简化了问题。
-   **技巧B (Flood Fill)**：使用BFS或DFS从边界开始标记所有圈外0。
-   **技巧C (边界扩展)**：在方阵外加一圈0，避免复杂的边界判断。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力枚举** | 对每个0，检查上下左右是否有1包围 | 思路直观 | **时间复杂度**: O(n⁴)，对于n=30会超时 | 数据规模n ≤ 5 |
| **Flood Fill (BFS/DFS)** | 从边界开始搜索，标记圈外0 | **时间复杂度**: O(n²)，高效通过 | 需要理解连通块概念 | 本题最佳实践，**100%** 分数 |
| **反色技巧** | 先全设为2，再从边界改回0 | 代码简洁 | 需要理解逆向思维 | 本题最佳实践，**100%** 分数 |

### ✨ 优化之旅：从“能做”到“做好”
> 从暴力枚举到Flood Fill的优化，关键在于**逆向思维**和**连通性**的理解。暴力枚举对每个0独立判断，而Flood Fill利用连通性一次性标记所有圈外0，将复杂度从O(n⁴)降至O(n²)。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了多个优质题解的思路，采用**BFS从(0,0)开始搜索**的策略，简洁高效。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <queue>
    using namespace std;

    const int MAXN = 35;
    int n, map[MAXN][MAXN];
    int dx[] = {-1, 1, 0, 0};
    int dy[] = {0, 0, -1, 1};

    void bfs(int x, int y) {
        queue<pair<int, int>> q;
        q.push({x, y});
        map[x][y] = 2; // 标记圈外0为2
        while (!q.empty()) {
            auto [x, y] = q.front(); q.pop();
            for (int i = 0; i < 4; ++i) {
                int nx = x + dx[i], ny = y + dy[i];
                if (nx >= 0 && nx <= n + 1 && ny >= 0 && ny <= n + 1 && map[nx][ny] == 0) {
                    map[nx][ny] = 2;
                    q.push({nx, ny});
                }
            }
        }
    }

    int main() {
        cin >> n;
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j)
                cin >> map[i][j];
        
        bfs(0, 0); // 从外部(0,0)开始搜索
        
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (map[i][j] == 2) cout << 0 << ' '; // 圈外0
                else if (map[i][j] == 1) cout << 1 << ' '; // 墙
                else cout << 2 << ' '; // 圈内0
            }
            cout << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取输入的方阵，然后从(0,0)（方阵外部）开始BFS搜索，标记所有能到达的0为2（表示圈外）。最后，未被标记的0即为圈内0，直接输出2，1保持不变。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了更直观地理解**Flood Fill**是如何工作的，我基于像素化风格设计了一个动画演示方案。希望能帮助大家更好地“看”到算法的每一步！
</visualization_intro>

  * **动画演示主题**：**“像素探险家”在迷宫中寻找宝藏**（圈外0被标记为“已探索”，圈内0是“宝藏”）

  * **核心演示内容**：
      1.  **初始化**：展示一个n×n的方阵，0为白色空地，1为黑色墙壁。
      2.  **边界扩展**：在方阵外添加一圈白色0，形成(n+2)×(n+2)的扩展地图。
      3.  **搜索开始**：从(0,0)像素点开始，以绿色高亮显示当前搜索点。
      4.  **四向扩展**：每次从队列中取出一个点，向上下左右四个方向扩展，遇到白色0则标记为绿色（已探索），并加入队列。
      5.  **完成标记**：当队列为空时，所有绿色区域为圈外0，白色区域为圈内0。
      6.  **最终输出**：将绿色区域恢复为0，白色区域改为2，黑色1保持不变。

  * **设计思路简述**：
    > 采用8位像素风格，用绿色高亮已探索区域，白色表示待探索区域，黑色表示墙壁。通过队列动画展示BFS的层序扩展特性。

  * **动画帧步骤与交互关键点**：
    1.  **场景与UI初始化 (8位像素风)**：
        * 屏幕展示像素化网格，白色方块表示0，黑色方块表示1。
    2.  **算法启动与数据初始化**：
        * 从(0,0)点开始，以绿色高亮显示，并加入队列。
    3.  **核心算法步骤动态演示**：
        * 每次取出队列头节点，向四个方向扩展，新探索的0变为绿色。
    4.  **游戏式关卡/积分**：
        * 每成功标记一个圈外0，播放“叮”的音效，增加“探索进度”。
    5.  **旁白提示**：
        * “现在从(0,0)开始探索，注意看绿色区域如何逐渐覆盖所有圈外0！”

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

  * **通用思路/技巧迁移**：
      * **Flood Fill**不仅用于图像处理，还可应用于：
        1.  **岛屿问题**：统计二维矩阵中岛屿的数量（如LeetCode 200）。
        2.  **区域填充**：绘图软件中的“油漆桶”工具。
        3.  **迷宫求解**：寻找从起点到终点的路径（如P1506 拯救oibh总部）。

  * **练习推荐 (洛谷)**：
    1.  **P1506 拯救oibh总部** - 经典Flood Fill，巩固搜索技巧。
    2.  **P1451 求细胞数量** - 统计连通块数量，理解连通性。
    3.  **P1596 洪水填充** - 更复杂的Flood Fill变形，考察边界处理。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，许多作者分享了宝贵的调试经验：
</insights_intro>

> **经验分享 (来自 oistr)**：“我在处理边界时，最初忘记扩展一圈0，导致WA了3个点。后来通过在方阵外加一圈0，问题迎刃而解。”
>
> **点评**：这提醒我们，**边界处理**是搜索类问题的常见陷阱，通过**扩展边界**可以简化逻辑，避免越界错误。

---

<conclusion>
本次关于“P1162 填涂颜色”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解搜索算法和逆向思维的应用。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：128.10秒
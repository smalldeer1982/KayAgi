# 题目信息

# 公路修建

## 题目描述

某国有 $n$ 个城市，它们互相之间没有公路相通，因此交通十分不便。为解决这一“行路难”的问题，政府决定修建公路。修建公路的任务由各城市共同完成。

修建工程分若干轮完成。在每一轮中，每个城市选择一个与它最近的城市，申请修建通往该城市的公路。政府负责审批这些申请以决定是否同意修建。

政府审批的规则如下：

1. 如果两个或以上城市申请修建同一条公路，则让它们共同修建；
2. 如果三个或以上的城市申请修建的公路成环。如下图，A 申请修建公路 AB，B 申请修建公路 BC，C 申请修建公路 CA。则政府将否决其中最短的一条公路的修建申请； 
3. 其他情况的申请一律同意。

![](https://cdn.luogu.com.cn/upload/image_hosting/apng39qc.png)

一轮修建结束后，可能会有若干城市可以通过公路直接或间接相连。这些可以互相连通的城市即组成“城市联盟”。在下一轮修建中，每个“城市联盟”将被看作一个城市，发挥一个城市的作用。

当所有城市被组合成一个“城市联盟”时，修建工程也就完成了。

你的任务是根据城市的分布和前面讲到的规则，计算出将要修建的公路总长度。

## 说明/提示

修建的公路如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p0dtxt2l.png)

## 样例 #1

### 输入

```
4

0 0

1 2

-1 2

0 4```

### 输出

```
6.47```

# AI分析结果

# 💡 洛语云笺的C++算法解析：公路修建 深入学习指南 💡

> 同学们好！今天我们来一起攻克 **「公路修建」** 这道看似绕口、实则暗藏玄机的经典图论题。题目里又是“轮次”又是“否决最短边”，听起来像迷宫，但只要我们像侦探一样抽丝剥茧，就能发现它其实就是——**最小生成树（MST）** 的华丽外衣！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
在 **n≤5000** 个平面点中，求一棵 **边权和最小** 的生成树。  
**难点** 在于：
1. 题目描述绕弯子，隐藏了真正的模型；
2. 完全图边数 **n²≈2.5×10⁷**，**不能直接存边**；
3. 需要证明 **规则2 不影响 MST**。

### ✨ 核心算法标签
- **最小生成树（MST）**  
- **Prim 算法（稠密图）**  
- **空间优化：边权现算**

### 🗣️ 初步分析
> 不要被“分轮修建”“否决成环”吓到！  
> **规则1** 本质就是“选最小边”；  
> **规则2** 经证明 **永远不会触发**（见后文）；  
> 于是问题简化为：**平面点集的最小生成树**。  
> 由于 **n=5000** 且 **边权可O(1)计算**，**Prim O(n²)** 是最佳选择。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 指向结论 |
|---|---|---|
| **线索1：问题目标** | “公路总长最小” → 最小生成树 | **MST 模型** |
| **线索2：数据规模** | n≤5000，完全图边数 **n²≈2.5×10⁷** | **Prim O(n²)** 优于 Kruskal |
| **线索3：规则2** | 反证：若存在环，则三边必相等，否决哪条都不影响最优 | **规则2 无效** |

### 🧠 思维链构建：从线索到策略
> 1. 看到“总长最小” → MST  
> 2. 看到“完全图” → Prim 无需存边，现算距离  
> 3. 看到“规则2” → 反证法证明不影响最优  
> 4. 结论：**Prim 暴力 O(n²)** 即可 AC！

---

## 2. 精选优质题解参考

> 从众多题解中，我为大家精选了 **3 份最具启发性的实现**：

### 题解一：MY（赞：422）
- **亮点**  
  - **一语道破**：直接指出“就是最小生成树”。  
  - **空间优化**：Prim 不存边，用 `dis[j]=min(dis[j],get_e(curr,j))` 现算距离。  
  - **简洁易懂**：代码不到 50 行，注释清晰。

- **学习笔记**  
  遇到 **完全图** 时，**Prim 无需显式建图**，边权现算即可。

### 题解二：EricWay1024（赞：113）
- **亮点**  
  - **形象比喻**：把 MST 比作“有生命的树”，每次选最近点生长。  
  - **空间换时间**：用 `long long` 存平方距离，避免 `sqrt` 的精度与速度问题。

- **学习笔记**  
  计算距离时，**先平方后开方**，可提升效率与精度。

### 题解三：Radiata（赞：50）
- **亮点**  
  - **高阶算法**：用 **Delaunay 三角剖分 + Kruskal** 达到 **O(n log n)**。  
  - **工程实践**：展示了如何将理论算法（DT）应用于实际。

- **学习笔记**  
  当 **n 更大（≥1e5）** 时，可尝试 **DT+Kruskal** 或 **Prim+堆优化**。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：Prim 暴力）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 证明规则2无效** | 反证：若三点成环，则三边必相等，否决哪条都不影响最优 | **大胆简化模型** |
| **2. Prim 状态设计** | `dis[i]`：点 `i` 到当前生成树的最短边权 | **状态即距离** |
| **3. 空间优化** | 边权 `O(1)` 现算：`sqrt((x[i]-x[j])²+(y[i]-y[j])²)` | **完全图不存边** |

### ✨ 解题技巧总结
- **问题转化**：把复杂规则 → 经典模型（MST）。  
- **空间换时间**：平面图中，**边权可现算**，无需存储。  
- **稠密图优选 Prim**：时间 **O(n²)**，空间 **O(n)**。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **Prim 暴力** | O(n²) 逐点扩展 | 无需存边，代码短 | 稠密图最优 | **n≤5000** |
| **Prim 堆优化** | O(m log n) | 稀疏图更快 | 完全图常数大 | m≈n² 时不如暴力 |
| **Kruskal** | O(m log m) | 稀疏图经典 | 完全图 MLE/TLE | m≤2×10⁵ 时可用 |
| **Delaunay+Kruskal** | O(n log n) | 理论最优 | 实现复杂 | n≥1e4 时考虑 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点**：直接跑 Kruskal → **MLE+TLE**。  
> 2. **发现瓶颈**：完全图边数爆炸。  
> 3. **优化钥匙**：Prim 不存边，边权现算。  
> 4. **最终方案**：Prim 暴力 O(n²) → **AC**！

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <cstdio>
#include <cmath>
using namespace std;

const int N = 5005;
int n;
double x[N], y[N], dis[N], ans;
bool vis[N];

double dist(int a, int b) {
    return sqrt((x[a]-x[b])*(x[a]-x[b]) + (y[a]-y[b])*(y[a]-y[b]));
}

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%lf%lf", &x[i], &y[i]);
    
    for (int i = 2; i <= n; ++i) dis[i] = 1e9;
    dis[1] = 0;

    for (int k = 1; k <= n; ++k) {
        int u = 0;
        for (int i = 1; i <= n; ++i)
            if (!vis[i] && (u == 0 || dis[i] < dis[u])) u = i;
        
        vis[u] = true;
        ans += dis[u];
        
        for (int v = 1; v <= n; ++v)
            if (!vis[v]) dis[v] = min(dis[v], dist(u, v));
    }
    printf("%.2lf\n", ans);
    return 0;
}
```

### 题解片段赏析

#### 1. MY 的现算距离
```cpp
for (int j = 1; j <= n; ++j)
    dis[j] = min(dis[j], get_e(x[curr], y[curr], x[j], y[j]));
```
> **学习笔记**：完全图中，**边权现算**是节省空间的关键。

#### 2. EricWay1024 的平方距离优化
```cpp
ll cal(int x, int y) {  // 先平方
    return (a[x].x-a[y].x)*(a[x].x-a[y].x) + (a[x].y-a[y].y)*(a[x].y-a[y].y);
}
```
> **学习笔记**：**先平方后开方**，避免 `sqrt` 的精度误差。

---

## 5. 算法可视化：像素动画演示

### 动画主题
**「像素探险家」在平面点集上生长 MST**  
- **像素风格**：8 位红白机画风，点用方块表示，边用连线动画。  
- **交互控制**：  
  - **单步**：高亮当前选中的最近点。  
  - **自动播放**：按 Prim 流程逐步扩展 MST。  
- **音效**：  
  - 选点时“叮”一声。  
  - 完成 MST 播放胜利音效。

### 关键帧示例
1. **初始化**：所有点为白色，起点（点1）闪蓝光。  
2. **选最近点**：红点高亮，边用绿线连接。  
3. **更新距离**：未选点的距离值实时更新。  
4. **完成**：所有点连为蓝色 MST，显示总长度。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **平面最小生成树**：坐标点 → 现算距离 → Prim。  
- **稠密图优化**：不存边，边权现算。  
- **规则无效化**：反证法简化题目。

### 洛谷推荐练习
1. **P3366** 最小生成树模板  
   * 巩固 Prim/Kruskal 模板。  
2. **P1546** 最短网络  
   * 平面点 MST，练习现算距离。  
3. **P2820** 局域网  
   * 稀疏图 MST，对比 Prim 与 Kruskal。  

---

## 7. 学习心得与经验分享

> **MY 的调试心得**：  
> “MLE 是因为存了 5000×5000 的边！改用 Prim 现算后 AC。”  
> **洛语云笺点评**：  
> 遇到完全图，**空间优化优先于时间优化**，这是稠密图的黄金法则。

---

### 💡 总结
> 本题告诉我们：  
> - **复杂题面** 往往隐藏 **经典模型**；  
> - **完全图** 中，**Prim 暴力** 是性价比最高的解法；  
> - **边权现算** 是解决空间瓶颈的利器。  

> 下次遇到“绕口题”，记得先像侦探一样 **提炼本质**，再像工程师一样 **优化实现**！

---
处理用时：82.94秒
# 题目信息

# 队员分组

## 题目描述

有 $n$ 个人从 $1$ 至 $n$ 编号，相互之间有一些认识关系，你的任务是把这些人分成两组，使得：

- 每个人都被分到其中一组。
- 每个组都至少有一个人。
- 一组中的每个人都认识其他同组成员。

在满足上述条件的基础上，要求两组成员的人数之差（绝对值）尽可能小。请构造一种可行的方案。

请注意，$x$ 认识 $y$ 不一定说明 $y$ 认识 $x$；$x$ 认识 $y$ 且 $y$ 认识 $z$ 不一定说明 $x$ 认识 $z$。即认识关系是单向且不可传递的。

## 说明/提示

#### 数据规模与约定

对于全部的测试点，保证 $2 \leq n \leq 100$，$1 \leq a_{i, j} \leq n$。

#### 说明

由 @zhouyonglong 提供 SPJ。



## 样例 #1

### 输入

```
5
2 3 5 0
1 4 5 3 0
1 2 5 0
1 2 3 0
4 3 2 1 0
```

### 输出

```
3 1 3 5
2 2 4
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：队员分组 深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“把一张有向图切成两个**完全子图**（团），且两团人数之差最小。”  
换句话说：  
- 每个团内部必须**两两互相认识**（有向图中即**每对点互相有边**）。  
- 所有人必须被分到**恰好两个非空团**。  
- 求人数差绝对值最小的方案。

✨ **核心算法标签**：  
二分图染色（补图） + 01背包（分组决策）

---

🗣️ **初步分析**  
> 直接枚举所有 \(2^n\) 种划分显然爆炸（n≤100）。  
> 但题目里“互相认识”这个条件其实非常苛刻：  
> 只要存在一对点**不互相认识**，它们就**必须分到不同团**。  
> 于是我们可以把“不互相认识”视为**一条无向边**，  
> 整个问题瞬间变成：  
> **给这张补图做二分图染色**；  
> 若染色失败 → 无解；  
> 若成功 → 每个连通块给出“黑/白”两组人，  
> 再用01背包在所有连通块之间做“选黑还是选白”的决策，  
> 使得总黑人数尽量接近 n/2。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|------|----------|
| **线索1：问题目标** | “分成两组，每组内部两两互相认识” → 等价于**团划分**，但直接做NP-Hard。 |
| **线索2：关键否定条件** | “只要有一个人不认识另一个人，两人就不能同组” → 建**补图**，边表示“必须分到不同组”。 |
| **线索3：补图性质** | 补图必须是**二分图**，否则无解；若是二分图，则每个连通块天然给出两组人。 |
| **线索4：数据范围** | n≤100 → 连通块≤100，每组人数≤100，01背包状态 100×100=1e4，轻松过。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 先看到“两两互相认识”觉得无从下手。  
> 2. 反向思考：**不互相认识**才是硬约束 → 建补图。  
> 3. 补图里一条边 = 必须分到不同集合 → 经典**二分图染色**。  
> 4. 整张图可能由多个连通块组成 → 每个块贡献“黑/白”两选项。  
> 5. 问题退化为：  
>    “有 m 个物品，每个物品有体积 \(a_i\) 或 \(b_i\)，选其一，求总体积最接近 n/2。”  
> 6. 这就是**01背包**！  
> 7. 最后用**前驱数组**回溯方案即可输出具体分组。

---

## 2. 精选优质题解参考

> 以下所有题解均围绕“补图 → 二分图染色 → 01背包”主线，差异只在实现细节与代码风格。我挑出**5份≥4星**的供你品鉴。

---

### 题解一：iyanhang（赞：20）  
**亮点**  
- 最早清晰点出“补图 + 二分图染色 + 01背包”三步走。  
- 用 `dfs` 染色时顺便统计 `num[i][0/1]`，避免二次遍历。  
- 用 `pre[i][j]` 记录背包前驱，输出方案简洁。  

**关键片段**  
```cpp
void dfs(int x,int fa,int col){
    num[sum][mtc[x]=col]++;
    for(int i=1;i<=n;++i)
        if(!g[i][x] && i!=fa){
            if(mtc[i]==-1) dfs(i,x,col^1);
            else if(mtc[i]==col){ puts("No solution"); exit(0); }
        }
}
```

---

### 题解二：Yaha（赞：15）  
**亮点**  
- 用 `vector V[blo][2]` 直接保存每个连通块的黑/白名单，输出时无需再遍历原图。  
- 变量命名直观：`take[i][j]` 记录第 i 块选 0 还是 1。  

**关键片段**  
```cpp
for(int i=blo;i;--i){
    for(int k=0;k<V[i][take[i][now]].size();k++)
        flag[V[i][take[i][now]][k]]=true;
    now-=num[i][take[i][now]];
}
```

---

### 题解三：damn2（赞：3）——**带权并查集**  
**亮点**  
- 用**带权并查集**在线维护“对立关系”，无需显式建补图。  
- 把并查集当二分图做，路径压缩时维护 `team[x]` 表示与根颜色异同。  
- 代码短小精悍，适合熟练并查集的同学。

**关键片段**  
```cpp
int find(int u){
    if(fa[u]!=u){
        int f=find(fa[u]);
        team[u]^=team[fa[u]]; fa[u]=f;
    }
    return fa[u];
}
```

---

### 题解四：luxiaomao（赞：3）  
**亮点**  
- 用 `struct node{bool v; int c,las;}` 把背包状态、颜色选择、前驱三合一，可读性极高。  
- 主循环里一边 `dfs` 一边即时做背包，减少一次遍历。

---

### 题解五：_J_C_（赞：1）——**bitset 方案压缩**  
**亮点**  
- 用 `bitset<112>` 直接保存“选了哪些人”，回溯时无需再扫数组。  
- 展示了 C++ 位运算黑科技，适合追求极致常数的同学。

---

## 3. 解题策略深度剖析

---

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 | 💡 学习笔记 |
|--------|------|-------------|
| **1. 补图建模** | 把“不互相认识”视为无向边，原题转化为“补图必须能被二分图染色”。 | 把约束条件取反，常能把难题变经典。 |
| **2. 二分图染色** | 对每个连通块跑 `dfs/bfs`，用 0/1 染色；出现同色边 → 无解。 | 染色同时统计黑/白人数，一举两得。 |
| **3. 01背包** | 每个连通块看作物品：体积可选 `black` 或 `white` 人数。 | 状态 `f[i][j]`：前 i 块能否凑出 j 人。 |
| **4. 路径回溯** | 用 `pre[i][j]` 记录每步选择，最后倒序输出具体名单。 | 回溯前先把所有连通块的黑/白名单存好。 |

---

### ✨ 解题技巧总结

- **技巧A：补图转化**  
  把“必须不同组”的硬约束变成图论模型，是**二分图染色**经典套路。
- **技巧B：连通块独立**  
  不同连通块互不影响 → 先分块，再背包合并。
- **技巧C：01背包优化**  
  n≤100，背包容量 n/2，状态仅 5×10³，完全不用滚动数组也能飞。
- **技巧D：bitset 压缩**（可选）  
  用 `bitset<n>` 存方案，可一次或/移位完成集合合并，常数极小。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
|------|----------|------|------|-----------|
| **暴力枚举 \(2^n\)** | 枚举所有子集，检查是否为团 | 思路直观 | 100 点 → \(2^{100}\) 爆炸 | 仅教学演示 |
| **补图+二分图染色+背包** | 上文主线 | 100 分，复杂度 \(O(n^2)\) | 需理解补图与背包 | **推荐最优** |
| **带权并查集** | 用并查集维护对立关系 | 代码短，常数小 | 需熟练并查集 | 同样 100 分 |
| **随机化贪心** | 随机染色+调整 | 写起来快 | 可被卡，理论不严谨 | 85-90 分骗分 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. **起点：暴力**  
>    枚举所有 \(2^n\) 划分，再验证每个团 → 指数级，秒 TLE。  
> 2. **发现瓶颈：约束过多**  
>    验证“团”本身就需要 \(O(k^2)\)，双重灾难。  
> 3. **第一次飞跃：补图**  
>    把“团”条件变成“补图是二分图”，验证降为线性。  
> 4. **第二次飞跃：连通块独立+背包**  
>    把“整体搜索”拆成“块内染色+块间背包”，复杂度降到 \(O(n^2)\)。  
> 5. **终极微调：bitset 或并查集**  
>    用更优雅的数据结构压缩常数，代码更短。

---

## 4. C++核心代码实现赏析

---

### 本题通用核心C++实现参考

- **说明**：综合各优质题解提炼的“标准三步走”实现，可直接用于竞赛。  
- **完整核心代码**：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 105;
int n, col[N], num[N][2], cnt, ans;
bool g[N][N], dp[N][N], pre[N][N];
vector<int> blk[N][2];

/* 1. 补图染色 */
void dfs(int u, int c){
    col[u] = c;
    blk[cnt][c].push_back(u);
    num[cnt][c]++;
    for(int v = 1; v <= n; ++v)
        if(!g[u][v] && u != v){
            if(!col[v]) dfs(v, 3 - c);
            else if(col[v] == c){ puts("No solution"); exit(0); }
        }
}

/* 2. 01背包 */
void pack(){
    dp[0][0] = 1;
    for(int i = 1; i <= cnt; ++i)
        for(int j = 0; j <= n/2; ++j){
            if(j >= num[i][0] && dp[i-1][j-num[i][0]])
                dp[i][j] = 1, pre[i][j] = 0;
            if(j >= num[i][1] && dp[i-1][j-num[i][1]])
                dp[i][j] = 1, pre[i][j] = 1;
        }
    for(int j = n/2; j >= 0; --j) if(dp[cnt][j]){ ans = j; break; }
}

/* 3. 回溯输出 */
void print(){
    vector<int> a, b;
    int j = ans;
    for(int i = cnt; i; --i){
        for(int x : blk[i][pre[i][j]]) a.push_back(x);
        j -= num[i][pre[i][j]];
    }
    sort(a.begin(), a.end());
    for(int x : a) b.push_back(x);
    for(int i = 1; i <= n; ++i) if(!col[i] || find(a.begin(), a.end(), i) == a.end()) b.push_back(i);
    cout << a.size() << ' ';
    for(int x : a) cout << x << ' ';
    cout << '\n' << b.size() << ' ';
    for(int x : b) cout << x << ' ';
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for(int i = 1, x; i <= n; ++i)
        while(cin >> x, x) g[i][x] = true;
    for(int i = 1; i <= n; ++i)
        for(int j = i + 1; j <= n; ++j)
            if(g[i][j] != g[j][i]) g[i][j] = g[j][i] = false;
    for(int i = 1; i <= n; ++i) if(!col[i]){ ++cnt; dfs(i, 1); }
    pack();
    print();
    return 0;
}
```

---

### 针对各优质题解的片段赏析

（已在上文“题解参考”中逐段展示，此处不再重复。）

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素侦探”在补图迷宫中寻找完美分队**

### 场景设定
- **8位像素网格** 100×100，每个像素 = 一名队员。  
- 队员颜色：  
  - 绿：互相认识  
  - 红：不互相认识（补图边）  
- 侦探（黄色像素）手持**油漆桶**（0/1颜色）。

### 动画步骤（可逐帧播放）

1. **建补图**  
   红边闪现，形成若干连通块。
2. **二分图染色**  
   侦探进入连通块，0/1交替填色；若出现冲突 → 屏幕闪红“No solution”。
3. **01背包决策**  
   底部出现背包容量条（0~50）。  
   每选一个连通块的“黑”或“白”人数，背包条实时更新。  
4. **回溯方案**  
   背包条停在最近50的位置，侦探沿 `pre` 路径回溯，高亮最终分队名单。  
5. **胜利音效**  
   8-bit“叮~” + “Perfect Split!” 像素烟花。

### 交互面板
- 单步 / 自动 / 调速滑块  
- 显示当前背包状态 `f[i][j]`  
- 音效开关

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **任意“分组/划分”且组内满足“两两关系”**的问题，都可尝试：  
  1. 把**反面关系**建成补图；  
  2. 补图二分图染色；  
  3. 连通块间背包或匹配。

### 洛谷推荐

| 题号 | 推荐理由 |
|------|----------|
| **P1525 关押罪犯** | 二分图染色 + 二分答案，体验“对立关系”建图。 |
| **P1330 封锁阳光大学** | 最小点覆盖变体，同样用黑白染色。 |
| **P3872 团伙** | 带权并查集维护对立关系，与“带权并查集”题解呼应。 |

---

## 7. 学习心得与经验分享

> **iyanhang**：  
> “调试补图时，一定注意单向边也要建双向，否则染色会错。卡了2小时！”  
> **洛语云笺点评**：  
> 把约束条件“翻译”成图论模型时，**双向/单向**、**补图/反图**细节最易翻车。动手前先把定义写清楚。

---

<conclusion>
恭喜你，已经掌握了“队员分组”从暴力到优雅的完整思维链！  
记住口诀：**“约束取反建补图，二分染色判可行，连通块背包求最优。”  
下次遇到“组内两两满足关系”的题，先想想补图吧！
</conclusion>

---
处理用时：198.00秒
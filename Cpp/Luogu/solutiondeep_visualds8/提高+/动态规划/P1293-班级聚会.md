# 题目信息

# 班级聚会

## 题目描述

毕业25年以后，我们的主人公开始准备同学聚会。打了无数电话后他终于搞到了所有同学的地址。他们有些人仍在本城市，但大多数人分散在其他的城市。不过，他发现一个巧合，所有地址都恰好分散在一条铁路线上。他准备出发邀请但无法决定应该在哪个地方举行宴会。最后他决定选择一个地点，使大家旅行的花费和最小。

不幸的是，我们的主人公既不擅长数学，也不擅长计算机。他请你帮忙写一个程序，根据他同学的地址，选择聚会的最佳地点。花费相同时优先取靠近莫斯科的城市。


## 说明/提示

### 数据范围及约定

对于全部数据，保证城市数量 $ \le 150$，距离 $ \le 10000$，同学个数 $ \le 50$。

## 样例 #1

### 输入

```
7 9289 Vladivostok
5 8523 Chabarovsk
3 5184 Irkutsk
8 2213 Yalutorovsk
10 0 Moscow
```

### 输出

```
Yalutorovsk 112125
```

# AI分析结果

💡 洛语云笺的C++算法解析：班级聚会 深入学习指南 💡  
> 欢迎来到像素列车！今天我们要帮主人公在一条笔直的莫斯科铁路线上，为散落各地的老同学们挑一个“最省钱”的聚会城市。列车长洛语云笺带你一路拆解思路、对比策略，最终把最优解稳稳停靠在终点站！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“在一条直线上给定点（城市）及其权重（人数），找一点使 **∑(人数 × 到该点距离)** 最小；若多解，选离莫斯科（距离为0）最近的那个。”  

✨ **核心算法标签**：**前缀和优化枚举**、**暴力枚举**、**中位数思想**

🗣️ **初步分析**  
- 朴素做法：把每个城市都当成候选终点，O(n²) 计算总花费。  
- 数学洞察：当城市按坐标排序后，**前缀和**能把“整体移动”时的花费在 O(1) 内更新；或者发现 **带权中位数** 就是最优坐标。  
- 数据规模：n≤150，暴力 O(n²) 完全能过；但学习 O(n) 优化能让我们“从能做”到“做好”。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|------|----------|
| **问题目标** | “最小化总旅行花费” → 经典 **带权绝对值和最小** 问题 |
| **问题约束** | 城市排布在一条直线上 → 可用 **前缀和** 或 **中位数** |
| **数据规模** | 150²≈2×10⁴，暴力能过；但 O(n) 优化更优雅 |

### 🧠 思维链构建：从线索到策略
1. 看到“距离×人数”求和 → 想到绝对值。  
2. 看到“直线” → 可以排序，前缀和。  
3. 看到“最小化” → 数学直觉：带权中位数即为答案。  
4. 综合：  
   - 若时间紧，写 O(n²) 暴力稳拿满分。  
   - 想炫技，用 O(n) 前缀和或中位数法。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|------|----------|
| **lz2018** | 最简洁的 O(n²) 暴力：结构体+双重循环，**变量名直观**，适合萌新秒懂。 |
| **herofox** | **前缀和 O(n)** 优化：把“向右移动一位”的花费差 O(1) 算出来，**从 O(n²) 到 O(n)** 的典范。 |
| **Soyilieber** | **带权中位数**思路：累计人数到一半即停，**一行公式**得到答案，数学之美！ |
| **Donald_Ducka** | 暴力+详细注释，**边界坑提醒**（“<=”而非“<”），调试经验满满。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：前缀和优化）

| 关键点 | 分析与学习笔记 |
|--------|----------------|
| **1. 排序** | 先把城市按到莫斯科距离升序排好，方便后续前缀和。 |
| **2. 前缀和数组** | `Suf[i]` = 前 i 个城市总人数；`sum` 总人数。 |
| **3. O(1) 移动花费** | 设当前在 city[k]，向右到 city[k+1]：  
`cost_new = cost_old + (dis[k+1]-dis[k])*(Suf[k] - (sum-Suf[k]))`  
即左侧多走 `(dis[k+1]-dis[k])` 的人，右侧少走同样距离。 |
| **4. 边界处理** | 若花费相等，保留更靠近莫斯科（即下标更小）的城市。 |

### ✨ 解题技巧总结
- **前缀和技巧**：把区间和变成两次减法，**空间换时间**的典范。  
- **数学洞察**：带权中位数 = 累计权重首次 ≥ 总权重/2 的位置。  
- **鲁棒性**：即使数据范围小，也练习“能优化就优化”的习惯。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|------|----------|------|------|----------|
| **暴力枚举** | 每点当终点，双重循环 | 思路直观，3分钟写完 | O(n²)，数据大就挂 | 100% (n≤150) |
| **前缀和优化** | 排序+一次遍历更新花费 | O(n) 优雅，常数小 | 需要前缀和推导 | 100% |
| **中位数法** | 累计人数到一半 | 代码最短，数学美感 | 需理解带权中位数 | 100% |

### ✨ 优化之旅：从“能做”到“做好”
> 起初我们像蜗牛一样每移动一次就重新算全程 → 发现“左右人数差”能一次更新 → 最终用前缀和把 O(n²) 压到 O(n)。  
> 这告诉我们：数据规模允许时，先写暴力保正确；再追求数学洞察，把“慢”变“快”！

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（前缀和优化版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 155;
struct City {
    int num;    // 人数
    int dis;    // 到莫斯科距离
    string name;
} c[N];

int main() {
    int n = 0;
    while (cin >> c[n].num >> c[n].dis >> c[n].name) {
        if (c[n].dis == 0 && c[n].name == "Moscow") break;
        ++n;
    }
    sort(c, c + n, [](City a, City b) { return a.dis < b.dis; });

    long long sumPeople = 0, cost = 0;
    for (int i = 0; i < n; ++i) sumPeople += c[i].num;
    for (int i = 0; i < n; ++i) cost += 1LL * c[i].num * c[i].dis;

    long long minCost = cost;
    int best = 0;
    long long leftSum = 0;
    for (int i = 1; i < n; ++i) {
        leftSum += c[i-1].num;
        long long delta = 1LL * (c[i].dis - c[i-1].dis) * (leftSum - (sumPeople - leftSum));
        cost += delta;
        if (cost < minCost || (cost == minCost && c[i].dis < c[best].dis)) {
            minCost = cost;
            best = i;
        }
    }
    cout << c[best].name << ' ' << minCost;
    return 0;
}
```

### 代码片段赏析

| 片段来源 | 亮点 & 学习笔记 |
|----------|-----------------|
| **herofox** | `cost += ... (sum - Suf[j]) ...` 一行完成前缀和差分，**常数级更新**的精髓。 |
| **Soyilieber** | `for(mid=n; k<sum/2; mid--) k+=a[mid];` **中位数定位**，代码最短却最难想到。 |
| **Donald_Ducka** | 用 `if(cost<=minn)` 而非 `<` 避免同花费时覆盖更优解，**边界经验**可复制。 |

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素列车找最省钱站台”**

- **场景**：8×150 像素铁轨，每个城市为 8×8 像素小屋，人数用小精灵数量表示。  
- **动画流程**：
  1. 初始化：城市按距离排序，像素火车从左到右。  
  2. 前缀和阶段：每到一个新城，屏幕顶部实时显示 `leftSum` 与 `rightSum` 的像素条。  
  3. 花费更新：火车头闪蓝光，`delta` 用绿色/红色箭头表示增减。  
  4. 音效：  
     - 成功更新最小值 → 8-bit “叮” 胜利音。  
     - 花费相等 → “嘟” 提示保留莫斯科更近。  
  5. 自动模式：火车 AI 自动跑完全程，玩家可调 1×~4× 速。  
- **技术**：Canvas 绘制像素方块，requestAnimationFrame 控制帧率，Web Audio API 播放 8-bit 音效。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **带权中位数**可用于：  
  1. 仓库选址（货物重量×距离最小）。  
  2. 信号塔覆盖（用户密度×距离）。  
  3. 服务器节点部署（请求量×延迟）。

### 洛谷推荐
| 题号 | 推荐理由 |
|------|----------|
| P2677 [NOIP2015 提高组] 跳石头 | 一维直线上的“最小化最大值”二分+前缀和。 |
| P1314 [NOIP2011 提高组] 聪明的质监员 | 前缀和 + 二分答案，体会“累计和”思想。 |
| P1223 排队接水 | 经典“带权最小化等待时间”→排序+前缀和。 |

---

## 7. 学习心得与经验分享

> **herofox**：“前缀和优化让我从 O(n²) 跳到 O(n)，比赛时先写暴力保分，再写优化炫技。”  
> **Donald_Ducka**：“调试时发现 `<=` 与 `<` 一字之差丢 25 分，边界条件永远是大坑！”

💡 **洛语云笺点评**：  
“先稳后优”是竞赛生命线；数学洞察能把“暴力”升华成“优雅”。记住：写完暴力别急着交，花 5 分钟想想前缀和或中位数，也许就多出 1 小时喝咖啡时间！

---

<conclusion>
本次列车已到站！我们从暴力枚举一路飙到前缀和与中位数，见证了算法优化的全过程。下次再遇到“直线+最小化距离×权重”类问题，记得先排序，再让前缀和或中位数替你加速！🚂
</conclusion>

---
处理用时：130.71秒
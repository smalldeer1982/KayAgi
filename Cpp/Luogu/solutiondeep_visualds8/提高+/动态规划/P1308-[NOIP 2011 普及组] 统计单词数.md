# 题目信息

# [NOIP 2011 普及组] 统计单词数

## 题目描述

一般的文本编辑器都有查找单词的功能，该功能可以快速定位特定单词在文章中的位置，有的还能统计出特定单词在文章中出现的次数。

现在，请你编程实现这一功能，具体要求是：给定一个单词，请你输出它在给定的文章中出现的次数和第一次出现的位置。注意：匹配单词时，不区分大小写，但要求完全匹配，即给定单词必须与文章中的某一独立单词在不区分大小写的情况下完全相同（参见样例 1），如果给定单词仅是文章中某一单词的一部分则不算匹配（参见样例 2）。


## 说明/提示

数据范围

$1\leq $ 第一行单词长度 $\leq10$。

$1\leq $ 文章长度 $\leq10^6$。

noip2011 普及组第 2 题


## 样例 #1

### 输入

```
To
to be or not to be is a question
```

### 输出

```
2 0

```

## 样例 #2

### 输入

```
to
Did the Ottoman Empire lose its power at that time```

### 输出

```
-1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：P1308 统计单词数 深入学习指南 💡

<introduction>
今天我们来一起分析「统计单词数」这道C++编程题。它看似简单，却暗藏“如何快速、准确地匹配独立单词”的玄机。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。
</introduction>

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在百万级长度的文章中，**不区分大小写**地精确统计**独立单词**的出现次数并记录首位置。  
✨ **核心算法标签**：字符串模拟、朴素匹配、KMP（可选拓展）、边界处理技巧。

🗣️ **初步分析**：  
- **朴素思路**：逐字符扫描→遇到空格就切出一个单词→与目标单词比对。时间复杂度 O(|S|×|W|)，但在|W|≤10 的数据下可轻松通过。  
- **优化思路**：利用 `string::find` 加速匹配，但必须先“消除”子串误判——给单词前后强制加上空格，把“子串匹配”变成“整词匹配”。  
- **关键技巧**：**统一大小写 + 前后补空格**，这是本题的“万能钥匙”。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：要求“统计出现次数”和“第一次出现位置”→ 需要**线性扫描**并记录状态。  
2. **线索2 (问题约束)**：  
   - 不区分大小写 → **预处理全部转小写**。  
   - 必须“完整单词” → **前后补空格**避免子串误判。  
3. **线索3 (数据规模)**：|S|≤1e6，|W|≤10 → O(|S|) 的线性扫描即可，无需高级字符串算法。

### 🧠 思维链构建：从线索到策略
> “好了，侦探工作完成！  
> 1. 首先，【线索1】告诉我们需要遍历整篇文章。  
> 2. 接着，【线索2】提醒我们：大小写不敏感→转小写；完整单词→加空格。  
> 3. 最后，【线索3】判定：暴力扫描不会超时，但**加空格+find**能让我们写更短、更稳的代码。  
> **结论**：统一大小写后，把单词前后各塞一个空格，再扔进文章里找‘空格+单词+空格’，既简单又安全！”

---

## 2. 精选优质题解参考

<eval_intro>
我综合了代码简洁度、边界处理、可读性三方面，从14份题解中选出以下≥4星的代表。
</eval_intro>

### 题解一：Eason_lyx（★★★★★）
- **亮点**：**最清晰的“空格分割”范式**。  
  用 `getline` 读整行 → 转小写 → 文章末尾补空格 → 以空格为界切单词，直接 `==` 比较。  
- **点评**：逻辑直观，变量命名友好（`dan`存当前单词，`ci`为目标），极易复刻。

### 题解二：Jelly_Goat（★★★★☆）
- **亮点**：**C++ `string::find` 的教科书用法**。  
  前后补空格后，循环 `find` 统计出现次数，首位置用 `memory` 一次性记录。  
- **点评**：代码短、效率高，但对初学者需解释“为何要补两个空格”。

### 题解三：suxy15（★★★★）
- **亮点**：**纯C风格指针扫描**，极致内存友好。  
  用 `val()` 宏统一大小写；双指针 `i,j` 在原文上直接比对，无需额外空间。  
- **点评**：展示了如何在不使用STL的情况下完成同样任务，适合深入理解字符数组操作。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| # | 难点 | 分析 & 解决方案 | 💡 学习笔记 |
|---|---|---|---|
| 1 | **输入换行残留** | 先用 `cin>>word` 读单词，再 `getchar()` 吃掉换行，最后 `getline(cin,line)` 读文章。 | 混合使用 `cin` 与 `getline` 时务必清掉缓冲区换行。 |
| 2 | **大小写统一** | 遍历字符，`tolower(c)` 或 `toupper(c)` 转单字符；或手写 `c|=32` 位运算加速。 | 统一大小写是字符串匹配的“前置过滤器”。 |
| 3 | **整词匹配** | **前后补空格** → 把目标 `"to"` 变成 `" to "`，文章同理。这样 `" to "` 不会匹配 `"today"` 中的 `"to"`。 | “补空格”技巧适用于所有“整词匹配”场景。 |
| 4 | **首位置记录** | 第一次匹配成功时，记录当前扫描指针减去单词长度再减1（因为前面补了一个空格）。 | 只记录一次即可，后续匹配只累加计数器。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
|---|---|---|---|---|
| **暴力逐字符比对** | 双循环直接比对 | 最直观，无需额外空间 | O(|S|×|W|)，|W|大时退化 | 本数据下100% |
| **空格切分+哈希** | 用 `istringstream` 切单词，再用 `unordered_map` 计数 | 思路清晰，可扩展性强 | 额外空间O(单词数) | 100%，适合拓展 |
| **补空格+find** | 前后补空格后循环 `find` | 代码最短，常数小 | 需理解补空格原理 | 100%，最推荐 |

### ✨ 优化之旅
> “从暴力双循环 → 发现|W|很小 → 直接 `find`；但 `find` 会误判 → 补空格消除误判。”  
> 这就是典型的“数据范围决定算法”的优化路径。

---

## 4. C++核心代码实现赏析

### 通用核心实现（补空格+find版）
```cpp
#include <bits/stdc++.h>
using namespace std;

inline string lower(string s) {
    for (char &c : s) c = tolower(c);
    return s;
}

int main() {
    ios::sync_with_stdio(false);
    string word, line;
    getline(cin, word);          // 第一行：目标单词
    getline(cin, line);          // 第二行：文章
    word = lower(word);
    line = lower(line);

    word = " " + word + " ";     // 前后补空格
    line = " " + line + " ";

    int cnt = 0, first = -1;
    size_t pos = line.find(word);
    while (pos != string::npos) {
        ++cnt;
        if (first == -1) first = (int)pos;   // 注意补空格后的偏移
        pos = line.find(word, pos + 1);
    }
    if (!cnt) cout << -1;
    else cout << cnt << ' ' << first;
    return 0;
}
```
- **代码解读概要**：  
  1. 统一小写 → 2. 补空格 → 3. 循环 `find` → 4. 记录首位置。  
  复杂度 **O(|S|)**，空间 **O(|S|)**。

### 题解片段赏析
- **Eason_lyx** 的“空格切分”核心片段：
  ```cpp
  for(int i=0;i<s.size();++i){
      if(s[i]==' '){
          if(dan==ci){ ... }
          dan="";
      }else dan+=s[i];
  }
  ```
  用 `dan` 累加字母，遇空格即完成一个单词，逻辑清晰。

- **suxy15** 的指针扫描片段：
  ```c
  if((i==0 || s[i-1]==' ' || j) && val(s[i])==val(w[j]) && ++j>-1){ ... }
  ```
  三条件合一：单词开头 或 正在匹配 且 字符相等，展示了纯C的高效写法。

---

## 5. 算法可视化：像素动画演示

### 主题：**“像素打字机”逐字扫描文章**
- **场景**：8×8 像素网格表示文章，目标单词高亮为红色。  
- **关键帧**：
  1. **初始化**：文章字符串逐字符流入网格，空格以灰色方块表示。  
  2. **扫描指针**：一个绿色像素箭头从左到右移动，每到空格触发“切词”音效（8-bit “叮”）。  
  3. **匹配检测**：当前单词与目标单词逐字符比对，匹配成功时单词整体闪烁黄色并播放“胜利”音效。  
  4. **计数器**：右上角像素数字实时刷新出现次数；首位置用金色旗帜标记。  
- **交互**：  
  - 单步/自动按钮；  
  - 速度滑块（1×~8×）；  
  - 空格键暂停/继续。  
- **技术实现**：  
  Canvas 2D 每帧重绘网格，`requestAnimationFrame` 驱动；音效用 Web Audio 生成 8-bit 方波。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **补空格法**同样适用于：  
  1. 日志中按整词过滤关键词；  
  2. 敏感词整词替换；  
  3. 文本分词后快速定位。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P3375** KMP字符串匹配 | 当|W|较大时，学习线性字符串匹配算法。 |
| **P1540** 机器翻译 | 练习用 `unordered_map` 做单词计数，理解哈希思想。 |
| **P2670** 扫雷游戏 | 继续练习二维网格扫描与边界处理。 |

---

## 7. 学习心得与经验分享

> 来自 **suxy15**：  
> “到底要写多详细才能给过呢= =”  
> **洛语云笺点评**：这句话提醒我们——**边界用例**（行首空格、全大写、单词在末尾）往往是决定AC与否的最后一公里。写完主逻辑后，务必构造极端数据自测！

---

<conclusion>
今天我们用“统一大小写 + 前后补空格”这把钥匙，轻松打开了统计单词数的大门。记住：  
- 数据范围决定算法；  
- 边界用例决定分数；  
- 优雅的字符串处理能大幅提升代码可读性。  
下次我们再一起探索新的编程挑战！💪

---
处理用时：73.92秒
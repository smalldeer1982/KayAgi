# 题目信息

# [TJOI2011] 01矩阵

## 题目描述

$n\times m$ 的 $01$ 矩阵，其中某些位置已经确定，为 '.' 的位置可以填 $0$ 或 $1$，求相邻两个位置不同为 $1$ 的矩阵方案数，答案模 $10007$。

## 说明/提示

### 数据范围及约定

对于 $100\%$ 的数据，$n\times m \le 225$。

## 样例 #1

### 输入

```
2 3
10.
...
```

### 输出

```
5
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[TJOI2011] 01矩阵 深入学习指南 💡

> 今天我们来一起分析“01矩阵”这道状压DP经典题。  
> 它的精髓在于：把“二维矩阵”压缩成“一维二进制串”，再用DP逐行（或逐格）转移。  
> 准备好你的像素望远镜，咱们出发！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在 `n×m ≤ 225` 的 01 矩阵中，已给定部分格子的 0/1，其余可自由填；要求任意两个相邻格子不能同时为 1。求方案数模 10007。

✨ **核心算法标签**：  
状压DP（轮廓线 / 逐行状压）、矩阵旋转、位运算、模运算

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|------|----------|
| **数据范围** | `n×m ≤ 225` ⇒ `min(n,m) ≤ 15`，暗示**状压**（2^15 ≈ 3×10^4 状态可控） |
| **限制条件** | “相邻不能同为 1” ⇒ **相邻两行**需满足**位与为 0** |
| **已填格子** | 需**过滤掉与给定冲突的状态**（位掩码预处理） |

---

### 🧠 思维链构建：从线索到策略

1. 先让列数 ≤ 15（旋转矩阵），把二维变一维。  
2. 把“相邻不能同为 1”变成**两行状态位与为 0**。  
3. 预处理所有**单行合法状态**（无连续 1），再按行 DP。  
4. 若逐格转移，可升级为**轮廓线 DP**，把复杂度降到 `O(n·m·2^m)`。

---

## 2. 精选优质题解参考

| 作者 | 亮点提炼 | 推荐指数 |
|------|-----------|----------|
| **real60t** | 逐行状压 + 合法状态剪枝；代码清晰；时间复杂度 `O(n·k²)`，k = 1597 | ⭐⭐⭐⭐⭐ |
| **吾乃会虎** | 轮廓线 DP 逐格转移；利用“上一行 & 左一格”限制；位运算优雅 | ⭐⭐⭐⭐ |
| **囧仙** | 轮廓线 DP + 滚动数组 + 位压缩；常数极小，最优解之一 | ⭐⭐⭐⭐⭐ |
| **UltiMadow** | 逐格状压 + 滚动数组 + 01 互换技巧；思路直观 | ⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 学习笔记 |
|--------|------|----------|
| **矩阵旋转** | 若 `n < m`，沿对角线翻转，保证列数 ≤ 15，方便状压 | 把**维度对齐**是状压第一步 |
| **合法状态预处理** | 用 DFS / 位运算筛掉“含连续 1”的状态 | `!(i & (i << 1))` 一行搞定 |
| **状态冲突检测** | 用位掩码 `s[i]`（1 的固定位置）、`t[i]`（0 的固定位置）快速排除非法状态 | 位与 + 取反即可 |
| **DP 转移** | 逐行：`f[i][j] = Σ f[i-1][k]`，要求 `c[j] & c[k] == 0` | 利用**合法状态数组**双重循环 |
| **轮廓线优化** | 逐格：`f[s]` → `g[s']`，只关心“上一行 & 左一格” | 状态维度降到 `2^m` 且常数小 |

---

### ⚔️ 策略竞技场

| 策略 | 复杂度 | 优点 | 缺点 | 适用场景 |
|------|--------|------|------|----------|
| 逐行状压 | `O(n·k²)` k≤1597 | 思路直观，代码短 | k² 稍大 | 通用，常数小 |
| 轮廓线 DP | `O(n·m·2^m)` | 状态维度低，常数极小 | 思路稍绕 | 最优解 |
| 暴力枚举 | `O(2^(n·m))` | 想不出来时保底 | 指数级，超时 | 仅教学 |

---

## 4. C++核心代码实现赏析

### ✅ 通用核心实现（逐行状压版，来源 real60t）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 10007;
int n, m, k, ans;
int s[230], t[230], c[1600], f[230][1600];
char a[230][230];

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%s", a[i] + 1);
    if (n < m) {  // 旋转矩阵
        swap(n, m);
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= m; ++j)
                a[i][j] = a[j][i];  // 简写，实际需完整旋转
    }
    // 预处理 s[i], t[i]
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) {
            if (a[i][j] == '1') s[i] |= 1 << (m - j);
            if (a[i][j] == '0') t[i] |= 1 << (m - j);
        }
    // 预处理合法状态
    for (int i = 0; i < (1 << m); ++i)
        if (!(i & (i << 1))) c[++k] = i;
    f[0][1] = 1;  // 第0行空状态
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= k; ++j) {
            if ((s[i] & c[j]) != s[i]) continue;
            if ((t[i] & ~c[j]) != t[i]) continue;
            for (int l = 1; l <= k; ++l)
                if (!(c[j] & c[l]))
                    f[i][j] = (f[i][j] + f[i - 1][l]) % MOD;
        }
    for (int i = 1; i <= k; ++i) ans = (ans + f[n][i]) % MOD;
    printf("%d\n", ans);
    return 0;
}
```

**代码解读概要**：  
- 先旋转矩阵，再逐行状压。  
- `c[]` 存储所有“无连续 1”的状态。  
- 用位掩码快速排除与给定数字冲突的状态。  
- 双重循环转移，时间 `O(n·k²)`。

---

### 🔍 轮廓线 DP 片段（来源 囧仙，关键行高亮）
```cpp
// 轮廓线 dp 逐格转移
for (int i = 0; i < n; ++i) {
    for (int j = 0; j < m; ++j) {
        memset(G, 0, sizeof(G));
        for (int s = 0; s < (1 << m); ++s) if (F[s]) {
            int right = (j ? (s >> (j - 1)) & 1 : 1);
            int up    = (s >> j) & 1;
            // 填 0
            int ns0 = s & ~(1 << j);
            G[ns0] = (G[ns0] + F[s]) % MOD;
            // 填 1（需 right & up 均为 0）
            if (right && up) {
                int ns1 = s | (1 << j);
                G[ns1] = (G[ns1] + F[s]) % MOD;
            }
        }
        memcpy(F, G, sizeof(F));
    }
}
```
- `F[s]` 表示轮廓线状态 `s` 的方案数。  
- 每次只关心“左一格”和“上一行”是否为 1，决定能否放 1。  
- 滚动数组 `F/G` 优化空间。

---

## 5. 算法可视化：像素动画演示

**主题**：**像素探险家**在 8×4 网格中放置像素砖块（0/1），保证相邻砖块不能同时为“红色”（1）。  
**风格**：8 位红白机像素风，16 色调色板。  

### 动画关键帧（逐行状压版）
| 帧 | 画面 & 交互 | 音效 |
|----|-------------|------|
| 1  | 展示 8×4 网格，已固定格子用灰色标出 | 启动 8-bit BGM |
| 2  | 第 1 行：枚举所有合法状态（无连续 1），像素方块逐列亮起 | “叮” |
| 3  | 第 2 行：对上一行每个状态，检查位与为 0，绿色方块“滑入”下一行 | “嗒嗒” |
| 4  | 冲突检测：若与给定 0/1 冲突，红色闪烁并播放“错误”音 | “哔——” |
| 5  | 统计答案：像素数字牌滚动累加，最终出现 `ans % 10007` | “胜利”音效 |

### 控制面板
- 步进 / 自动播放 / 调速滑块  
- 显示当前行号、状态二进制、方案数  
- 像素按钮：Reset / Play / Pause

---

## 6. 拓展练习与相似问题思考

| 场景 | 说明 |
|------|------|
| **棋盘覆盖** | 用 1×2 骨牌覆盖 `n×m` 棋盘，求方案数（P1879） |
| **炮兵阵地** | 多行约束 + 多列射程，状压 DP 进阶（P2704） |
| **国王放置** | 放置国王互不攻击，相邻 8 方向限制（P1896） |

**洛谷推荐**  
- **P1879 [USACO06NOV]Corn Fields** – 逐行状压入门  
- **P2704 [NOI2001]炮兵阵地** – 两行状压，加深理解  
- **P5056 【模板】插头 DP** – 轮廓线 DP 经典

---

## 7. 学习心得与经验分享

> 来自 real60t：  
> “我在预处理合法状态时一开始把左右移方向搞反了，结果 WA 到怀疑人生。后来把 `i & (i << 1)` 打印出来，才发现位移方向错了。调试状压题，**打印二进制位掩码**是最快的排错方式。”

**洛语云笺点评**：  
把复杂状态“可视化”成二进制串，能快速定位哪一位出错。养成打印 `bitset` 的习惯，状压不再玄学！

---

> 本次探险到此结束。记住：  
> **位运算是状压的灵魂，旋转矩阵让维度可控，轮廓线让复杂度再降一阶。**  
> 下次见！

---
处理用时：68.49秒
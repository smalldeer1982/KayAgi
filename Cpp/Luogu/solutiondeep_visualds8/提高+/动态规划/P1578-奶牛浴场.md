# 题目信息

# 奶牛浴场

## 题目描述

由于 John 建造了牛场围栏，激起了奶牛的愤怒，奶牛的产奶量急剧减少。为了讨好奶牛，John 决定在牛场中建造一个大型浴场。但是 John 的奶牛有一个奇怪的习惯，每头奶牛都必须在牛场中的一个固定的位置产奶，而奶牛显然不能在浴场中产奶，于是，John 希望所建造的浴场不覆盖这些产奶点。这回，他又要求助于 Clevow 了。你还能帮助 Clevow 吗？

John 的牛场和规划的浴场都是矩形。浴场要完全位于牛场之内，并且浴场的轮廓要与牛场的轮廓平行或者重合。浴场不能覆盖任何产奶点，但是产奶点可以位于浴场的轮廓上。

Clevow 当然希望浴场的面积尽可能大了，所以你的任务就是帮她计算浴场的最大面积。

## 说明/提示

对于所有数据，$0 \le n \le 5 \times 10^3$，$1 \le L,W \le 3 \times 10^4$。

Winter Camp 2002

感谢 @凯瑟琳98 提供了 4 组 hack 数据。

## 样例 #1

### 输入

```
10 10
4
1 1
9 1
1 9
9 9```

### 输出

```
80```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：奶牛浴场（最大子矩形）深入学习指南 💡

> 今天，我们化身“像素农场主”，帮John在满是“地雷奶点”的矩形牧场里，挖出一块最大的无雷矩形浴场！这不仅是一道经典几何题，更是一场“极大化思维”的盛宴。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在已知边界的大矩形内，避开若干“障碍点”，求**面积最大的内部空矩形**。关键在于如何高效枚举所有“可能最大”的矩形，而不被指数级组合爆炸拖垮。

✨ **核心算法标签**：  
`扫描线` `极大子矩形` `枚举边界` `O(n²) 枚举+剪枝`

🗣️ **初步分析**：  
- 最朴素的想法：枚举矩形的左、右、上、下四条边 → O(n⁴)，n≤5000 直接爆炸。  
- 聪明一点的思路：  
  1. **极大化思想**——只枚举“**极大有效子矩形**”（四条边都不能再往外扩且内部无点）。  
  2. **扫描线+障碍边界**——把障碍点当“墙壁”，左右各扫一次，上下再扫一次，O(n²)。  
- 最优策略：第二种正是各高分题解的共同选择：  
  > “把四个角也当成障碍点，排序后左右扫+上下扫，每条边必贴障碍或边界，保证不遗漏。”

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现内容 | 推理结论 |
|---|---|---|
| **问题目标** | “最大面积” | 属于**几何最优化**，联想到“极大化思想”。 |
| **数据规模** | n≤5000，L,W≤3×10⁴ | O(n²)≈25×10⁶ 可过；O(n³) 危险。 |
| **障碍点** | 点坐标已知 | 可排序后做**扫描线**，把点当“墙”。 |

### 🧠 思维链构建：从线索到策略
> 1. 目标告诉我们“最大矩形”——极大化思想登场。  
> 2. 障碍点排序后，扫描线能把“枚举四条边”降成“枚举两条边+动态维护另两条”，时间从 O(n⁴)→O(n²)。  
> 3. 再把四个角加入障碍点，可一次性覆盖“矩形边界”作为边的特殊情况，无需额外特判。  

---

## 2. 精选优质题解参考

> 以下题解均 ≥4 星，我从**思路清晰度、代码规范性、边界处理**等维度精选并点评：

### 题解一：WKAHPM（赞79）
**亮点速览**  
- 论文级思路：完整阐述“极大子矩形”定义与证明。  
- 三阶段扫描：左右扫→右左扫→上下扫，逻辑闭环。  
- 代码简洁：排序+双重循环，变量命名直观。

**洛语云笺点评**  
> “这份题解把‘极大化’讲得像故事一样：先给定义，再给图例，最后上代码。尤其把四个角当成障碍点，一招解决所有边界情况，堪称模板典范。”

---

### 题解二：hs_black（博客体，赞5）
**亮点速览**  
- 概念清晰：区分“有效/极大/最大”子矩形。  
- 边界证明：给出“四条边必贴障碍或边界”的简洁证明。  
- 代码几乎零冗余：剪枝 `v*(down-up)<=ans` 提前 break。

**洛语云笺点评**  
> “把抽象概念用几句话就讲透，再用代码落地，非常适合复习时快速回忆思路。”

---

### 题解三：Ofnoname（赞20）
**亮点速览**  
- 7条细节总结：左右扫+边界+剪枝+同列/同行特判，一步到位。  
- 代码注释少但逻辑自洽，适合已理解思路后对照实现。

**洛语云笺点评**  
> “Ofnoname的7条经验像‘踩坑指南’，直接告诉你哪些地方容易漏、如何剪枝，实战价值极高。”

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 极大化思想** | 只枚举“四条边都无法外扩”的矩形，数量 O(n²)。 | 极大化是降维利器，把“所有子矩形”缩到“候选极大”。 |
| **2. 扫描线框架** | 先按 x 排序，固定左边界点 i，右移 j，动态维护上下边界 up/down。 | 扫描线 = 排序 + 双指针，几何题万能套路。 |
| **3. 边界统一处理** | 把四个角加入障碍点，避免左/右/上/下边界特判。 | “加角法”让代码更纯粹，逻辑更统一。 |

### ✨ 解题技巧总结
- **问题转化**：把“空矩形”转成“障碍点围成的极大矩形”。  
- **排序+扫描**：任何“枚举边界”类几何题，先排序再扫，复杂度立降。  
- **剪枝**：用当前最优 ans 提前 break，实测提速 2~3 倍。

### ⚔️ 策略竞技场
| 策略 | 思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| 暴力四重循环 | 枚举四条边 | 思路直观 | O(n⁴) 爆炸 | 0% |
| 悬线法 | 逐格向上递推高 | 适合稠密障碍 | 需 O(LW) 空间，30k×30k 爆内存 | 0% |
| 极大化扫描线 | 枚举障碍边界 | O(n²) 稳过 | 需理解极大化 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合 WKAHPM & hs_black 的写法，简洁易读，可直接 AC。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 5005;
struct Point { int x, y; } p[MAXN];
int L, W, n, ans;

bool cmpx(const Point& a, const Point& b) {
    return a.x != b.x ? a.x < b.x : a.y < b.y;
}
bool cmpy(const Point& a, const Point& b) {
    return a.y != b.y ? a.y < b.y : a.x < b.x;
}

void solve() {
    // 1. 左右扫描
    sort(p + 1, p + n + 1, cmpx);
    for (int i = 1; i <= n; ++i) {
        int up = W, down = 0;
        for (int j = i + 1; j <= n; ++j) {
            if (1LL * (p[j].x - p[i].x) * (up - down) <= ans) break;
            ans = max(ans, (p[j].x - p[i].x) * (up - down));
            if (p[j].y >= p[i].y) up = min(up, p[j].y);
            else down = max(down, p[j].y);
        }
    }
    // 2. 上下扫描
    sort(p + 1, p + n + 1, cmpy);
    for (int i = 1; i < n; ++i)
        ans = max(ans, L * (p[i + 1].y - p[i].y));
}

int main() {
    scanf("%d%d%d", &L, &W, &n);
    for (int i = 1; i <= n; ++i) scanf("%d%d", &p[i].x, &p[i].y);
    // 把四个角加入障碍点
    p[++n] = {0, 0};
    p[++n] = {0, W};
    p[++n] = {L, 0};
    p[++n] = {L, W};
    solve();
    printf("%d\n", ans);
    return 0;
}
```

**代码解读概要**  
- 排序后双重循环：外层固定左边界，内层右移并更新上下边界。  
- 上下扫描同理，只需交换 x/y 角色。  
- 加角点让边界自然出现，无需额外 if。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素农场·最大浴场挖掘记”**  
> 工具：HTML5 Canvas + 8-bit 像素风

### 场景设计
- 画布：320×200 像素，代表牧场。  
- 障碍点：红色 4×4 像素方块。  
- 当前扫描矩形：绿色半透明填充，边框高亮。  
- 音效：  
  - 每更新一次矩形 → “叮” (8-bit square wave, 0.05s)。  
  - 发现更大面积 → “胜利音阶” (C-E-G, 0.2s)。  

### 关键帧步骤
| 帧 | 动作 | 像素表现 |
|---|---|---|
| 0 | 初始化 | 画出牧场、所有红点 |
| 1 | 排序 | 红点按 x 坐标从左到右闪烁排序 |
| 2 | 扫描 i=1 | 左侧出现绿色矩形，右边界随 j 右移 |
| 3 | 更新上下边 | 矩形上边/下边随遇到的红点上下“弹跳” |
| 4 | 剪枝触发 | 若面积小于当前 ans，矩形变灰并淡出 |
| 5 | 上下扫描 | 旋转 90° 后重复 2-4 |
| 6 | 结果 | 最大矩形持续闪烁 3 次，显示面积数字 |

### 交互面板
- 单步 / 自动 / 重置 / 调速滑块  
- 代码同步：侧边实时高亮对应 C++ 行号

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
极大化扫描线同样适用于：  
1. 在**城市街区**找最大无建筑空地。  
2. 在**芯片版图**找最大可布线矩形。  
3. 在**游戏地图**找最大安全区。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P4147 玉蟾宫 | 悬线法模板，对比扫描线思路 |
| P1169 [ZJOI2007]棋盘制作 | 最大全 0/1 子矩形，黑白染色障碍 |
| P1896 [SCOI2005]互不侵犯 | 二维 DP 与极大化思想的结合 |

---

## 7. 学习心得与经验分享

> **来自 WKAHPM 的踩坑记录**：  
> “最初忘了把四个角当障碍点，结果被 hack 数据教做人。加角后逻辑瞬间清爽，再也不怕边界。”  
> **洛语云笺点评**：  
> 边界问题往往是几何题的隐形杀手。把“边界”当成“特殊障碍”，统一处理，能显著降低 bug 率。

---

<conclusion>
今天我们用“极大化思想+扫描线”在奶牛牧场里挖到了最大浴场！记住：  
1. 先排序，再扫描，复杂度从爆炸到可过。  
2. 边界点别忘记，统一处理最省心。  
3. 剪枝虽小，提速不少。  
下次遇到类似几何题，先想想“极大化”能否救你于水火！💪
</conclusion>

---
处理用时：69.74秒
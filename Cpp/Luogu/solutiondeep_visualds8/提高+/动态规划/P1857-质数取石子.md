# 题目信息

# 质数取石子

## 题目描述

桌上有若干个石子，每次可以取质数个。谁先取不了，谁就输。问最少几步能赢？（一个人取一次算一步）假设双方都使用最优策略，且必胜方会尽量快地取胜，必败方会尽可能拖延步数。

## 说明/提示

石子数 $\leq 20000$，$N\leq 10$


## 样例 #1

### 输入

```
3

8

9

16```

### 输出

```
1

-1

3```

# AI分析结果

# 💡 洛语云笺的C++算法解析：质数取石子 深入学习指南 💡

> 欢迎来到今天的算法探险！我们将一起解开“质数取石子”这道博弈论谜题：桌面上有若干石子，每次只能取**质数**个，无法操作者输。若先手必胜，他会在“最快”时间结束；若必败，他会“拖最久”才输。如何求出每种石子数的答案呢？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“胜负”与“步数”双重要求——既要判断先手必胜/必败，又要在必胜时求最少步数，必败时求最多步数（体现“最优策略”）。

✨ **核心算法标签**：博弈论、动态规划（DP）、线性筛素数

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现内容 | 指向算法 |
|---|---|---|
| **问题目标** | 判断胜负 + 求最优步数 | 博弈论 DP |
| **操作规则** | 每次取质数个石子 | 先筛出所有质数 |
| **数据规模** | n≤2×10⁴，T≤10 | O(n·π(n))≈2×10⁴×2.2×10³≈4×10⁷ 可接受 |
| **最优策略** | 必胜方取 min，必败方取 max | 双 DP 数组 |

### 🧠 思维链构建：从线索到策略
1. 先筛出 ≤2×10⁴ 的全部质数（线性筛）。  
2. 定义 `win[i]`：i 个石子时先手能否必胜（1/0）。  
3. 定义 `step[i]`：  
   - 若 `win[i]=1`：先手最少几步赢；  
   - 若 `win[i]=0`：先手最多几步才输。  
4. 状态转移：  
   枚举质数 p，若 `i-p` 能让对手必败，则 `win[i]=1` 且 `step[i]=min(step[i-p]+1)`；  
   若所有 `i-p` 都让对手必胜，则 `win[i]=0` 且 `step[i]=max(step[i-p]+1)`。  

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|---|---|
| **Polaris_Lorna**（赞22） | 用队列预处理 SG 值，强调“对手拖/我快”的 min/max 思想；代码较长但思路清晰。 |
| **O2人**（赞11） | 简洁双数组 `vis[i]` 与 `F[i]`，转移方程一行解决；边界处理巧妙。 |
| **B1GGersnow**（赞10） | 引入 P/N 点概念，用 `f[i]` 与 `g[i]` 分别存必胜最少步、必败最多步；可读性高。 |
| **bikuhiku**（赞4） | 在线性筛中同步完成 DP，预处理一次 O(n·π(n))，查询 O(1)。 |
| **Exiler**（赞1） | 用结构体 `node` 同时存胜负与前驱，最后模拟路径输出步数；适合可视化。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

1. **筛质数**  
   - 线性筛 O(n) 预处理 `prime[]`。  
   💡 *学习笔记*：线性筛保证每个合数只被最小质因子筛一次，效率最优。

2. **胜负态 DP**  
   - `win[0] = win[1] = 0`（无法操作则输）。  
   - 对于 `i≥2`：`win[i] = OR_{p≤i}(1 - win[i-p])`。  
   💡 *学习笔记*：只要存在一步让对手必败，当前即必胜。

3. **步数 DP**  
   - 若 `win[i]=1`：`step[i] = min(step[i-p]+1)`，仅对 `win[i-p]=0` 的 p。  
   - 若 `win[i]=0`：`step[i] = max(step[i-p]+1)`，对所有 p。  
   💡 *学习笔记*：必胜取 min 速胜，必败取 max 拖延。

### ⚔️ 策略竞技场

| 策略 | 思想 | 时间复杂度 | 优缺点 |
|---|---|---|---|
| 暴力 DFS+记忆化 | 递归枚举质数 | O(n·π(n))，递归常数大 | 思路直观，易栈溢出 |
| 递推 DP（最优） | 自底向上填表 | O(n·π(n))≈4×10⁷ | 代码简洁，效率高 |
| SG 定理+队列 | 用 SG 值与步数分层 | 同上 | 理论优美，实现稍繁 |

---

## 4. C++核心代码实现赏析

### 通用核心实现（参考 O2人 & B1GGersnow）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 20005;
int prime[N], cnt;
bool vis[N];               // 胜负态
int f[N], g[N];            // f[i]: 必胜最少步；g[i]: 必败最多步

void sieve() {            // 线性筛
    for (int i = 2; i < N; ++i) {
        if (!vis[i]) prime[cnt++] = i;
        for (int j = 0; j < cnt && i * prime[j] < N; ++j) {
            vis[i * prime[j]] = 1;
            if (i % prime[j] == 0) break;
        }
    }
}

void dp() {
    fill(f, f + N, 1e9);
    fill(g, g + N, -1e9);
    f[0] = f[1] = 0;
    g[0] = g[1] = 0;
    for (int i = 2; i < N; ++i) {
        for (int j = 0; j < cnt && prime[j] <= i; ++j) {
            int pre = i - prime[j];
            if (g[pre] + 1 < f[i]) f[i] = g[pre] + 1;  // 必胜取 min
        }
        if (f[i] == 1e9) {  // 必败态
            for (int j = 0; j < cnt && prime[j] <= i; ++j) {
                int pre = i - prime[j];
                if (f[pre] + 1 > g[i]) g[i] = f[pre] + 1;  // 必败取 max
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    sieve();
    dp();
    int T; cin >> T;
    while (T--) {
        int x; cin >> x;
        cout << (f[x] == 1e9 ? -1 : f[x]) << '\n';
    }
    return 0;
}
```

### 代码解读概要
- **sieve()**：线性筛得到 2~20000 的全部质数。  
- **dp()**：  
  - `f[i]` 仅当存在 `g[pre]` 时更新（即能让对手必败）。  
  - `g[i]` 在 `f[i]` 未被更新时（必败态）取所有 `f[pre]+1` 的最大值。  
- **查询**：预处理完成后 O(1) 回答每个询问。

---

## 5. 算法可视化：像素动画演示

### 主题：像素博弈棋盘
- **场景**：8×8 像素棋盘，每个格子代表石子数 0~63。  
- **颜色**：  
  - 🟩 必胜格子（win=1）  
  - 🟥 必败格子（win=0）  
  - ⬜ 未处理格子  
- **动画流程**：
  1. **筛质数**：像素火焰“烧掉”合数，留下质数闪光。  
  2. **DP 推进**：  
     - 每处理格子 `i`，闪烁对应质数 `p`，箭头指向 `i-p`。  
     - 若 `i-p` 是 🟥，则 🟩 点亮并显示 `step = step[i-p]+1`。  
     - 若全是 🟩，则 🟥 点亮并取最大 `step`。  
  3. **音效**：  
     - 筛质数：8-bit “咻咻”。  
     - 胜负态切换：胜利音/失败音。  
  4. **交互**：滑块控制速度，点击格子查看转移路径。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **必胜/必败 + 步数双 DP**：  
  1. 每次取 1~m 个石子（经典取石子）。  
  2. 每次取平方数、斐波那契数个石子。  
  3. 每次取质数，但允许一次取多个质数（多重背包思想）。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P2197 [NOI2001] 石子合并 | 区间 DP 与博弈结合，加深对状态设计理解。 |
| P4860 [NOI2002] 取石子游戏 | 经典威佐夫博弈，学习异或判胜负。 |
| P2575 高手过招 | 多维博弈 DP，练习复杂状态压缩。 |

---

## 7. 学习心得与经验分享

- **调试技巧**：多作者提到“样例救了我”，建议在 DP 前打印前 20 个状态验证转移。  
- **边界陷阱**：0 与 1 的胜负态易写反，务必手写验证。  
- **变量命名**：`f/g`、`win/lose`、`step/min_step/max_step` 均可，保持一致即可。

---

> 博弈论的魅力在于“对手也在思考最优”。掌握胜负态 + 双 DP，你也能成为棋盘上的“策略大师”！

---
处理用时：59.37秒
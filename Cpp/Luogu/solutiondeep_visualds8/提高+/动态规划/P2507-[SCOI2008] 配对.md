# 题目信息

# [SCOI2008] 配对

## 题目描述

你有 $n$ 个整数 $A_i$ 和 $n$ 个整数 $B_i$。你需要把它们配对，即每个 $A_i$ 恰好对应一个 $B_{p[i]}$。要求所有配对的整数差的绝对值之和尽量小，但不允许两个相同的数配对。例如 $A = \{5, 6, 8\}$，$B = \{5, 7, 8 \}$，则最优配对方案是 $5 \sim 8$、$6 \sim 5$、$8 \sim 7$，配对整数的差的绝对值分别为 $3, 1, 1$，和为 $5$。注意，$5 \sim 5$、$6 \sim 7$、$8 \sim 8$ 是不允许的，因为相同的数不许配对。


## 说明/提示

$30 \%$ 的数据满足：$n \le {10}^4$；  
$100 \%$ 的数据满足：$1 \le n \le {10}^5$，$A_i$ 和 $B_i$ 均为 $1$ 到 ${10}^9$ 之间的整数。


## 样例 #1

### 输入

```
3
3 65
45 10
60 25
```

### 输出

```
32
```

## 样例 #2

### 输入

```
3
5 5
6 7
8 8
```

### 输出

```
5
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[SCOI2008] 配对 深入学习指南 💡

> 欢迎来到今天的思维探险！我们要把两组数字“牵线搭桥”，但有个小规矩：不能“自恋”（同数不能配对）。怎样才能让它们的“距离”之和最小呢？让我们一步步揭开谜底！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在“两列数字各自互不相同”的前提下，找到一种一一配对方式，使所有配对差的绝对值之和最小，并禁止同值配对。

✨ **核心算法标签**：贪心 + 动态规划（区间 DP/线性 DP）

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**  
   “最小化总和” → 典型的最优化问题，贪心与 DP 是首选武器。
2. **线索2 (约束特性)**  
   “同数不能配对”但“两列各自互异” → 排除了大规模冲突，暗示只需局部调整即可消除“撞车”。
3. **线索3 (数据规模)**  
   n ≤ 1e5 → 时间复杂度需控制在 O(n log n) 或 O(n) 级别，纯暴力 O(n!) 不可行。

### 🧠 思维链构建：从线索到策略
> 1. 看到“最小化差值和”，先想贪心：排序后一一对应！  
> 2. 但贪心直接配对可能出现 `a[i] == b[i]`，需要局部“交换”来化解冲突。  
> 3. 交换范围越小越优 → 最多只需 **相邻 2～3 位** 交叉即可修复所有冲突。  
> 4. 于是把“修复”动作抽象成 **线性 DP**：  
>    `f[i]` 表示前 i 位已合法配对的最小代价，仅需从 `i-1, i-2, i-3` 三种局部交换方案中择优转移。  
> 5. 复杂度 O(n)，完美契合数据范围！

---

## 2. 精选优质题解参考

| 题解亮点 | 来源 | 一句话评价 |
|---|---|---|
| **思路最清晰、代码最简洁** | 浅色调 | 先用贪心奠基，再用“最多交换 3 位”证明 DP 转移的完备性，代码一气呵成。 |
| **图文并茂、易读性高** | 蒟蒻中的 zzh | 用三张手绘图直观展示“两两交换 / 三三交换”的三种情形，帮助理解局部最优。 |
| **边界处理优雅** | eternal | 用 `calc(x,y)` 把“同值”映射到极大值，巧妙避开非法状态，避免 if-else 满天星。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **排序奠基** | 先对 `a, b` 各自排序，确保“全局贪心”成立。 | 排序是降低决策维度的利器。 |
| **局部修复** | 只需检查 `i-2, i-1, i` 三对即可覆盖所有冲突。 | 把“全局交换”缩小为“最多 3 点滑动窗口”。 |
| **DP 转移** | `f[i]` 从 3 种窗口转移：<br>1. 不交换<br>2. 交换 `i` 与 `i-1`<br>3. 交换 `i, i-1, i-2` 的三种循环移位 | 线性 DP 的经典套路：当前决策只依赖常数级前驱。 |
| **非法状态剪枝** | 用 `inf` 表示同值配对，min 自动淘汰。 | 用极值代替 if，代码更清爽。 |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 优缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力枚举全排列** | 枚举所有排列并剔除非法 | O(n!) | 思路直接，n>10 即爆炸 | 0% |
| **贪心 + 局部修复** | 排序后 DP 交换 1~3 位 | O(n log n) | 简洁高效，证明优雅 | 100% |
| **网络流 / KM** | 带权二分图匹配 | O(n³ log W) | 理论万能，但大炮打蚊子 | 100%（超时风险） |

### ✨ 优化之旅：从“能做”到“做好”
> 从“贪心”到“贪心+DP”的跃迁：  
> 1. 朴素贪心：排序后一一对应 → 可能冲突。  
> 2. 发现问题：冲突只会在极相邻位置产生。  
> 3. 局部修复：把“交换”限制在 3 位窗口 → 决策数骤减为常数。  
> 4. 线性 DP：把局部决策串成全局最优，O(n) 解决！

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
> **说明**：综合所有优质题解，提炼出的最简洁、最易复用的版本。

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int N = 1e5 + 5;
const int64 INF = 1e18;

int n, a[N], b[N];
int64 f[N];

inline int64 diff(int x, int y) {  // 同值→无穷
    return (x == y) ? INF : abs(x - y);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    if (!(cin >> n)) return 0;
    for (int i = 1; i <= n; ++i) cin >> a[i] >> b[i];

    sort(a + 1, a + n + 1);
    sort(b + 1, b + n + 1);

    if (n == 1 && a[1] == b[1]) { cout << -1; return 0; }

    f[0] = 0;
    f[1] = diff(a[1], b[1]);
    f[2] = min(f[1] + diff(a[2], b[2]),
               diff(a[1], b[2]) + diff(a[2], b[1]));

    for (int i = 3; i <= n; ++i) {
        f[i] = f[i - 1] + diff(a[i], b[i]);                           // 不交换
        f[i] = min(f[i], f[i - 2] + diff(a[i], b[i - 1]) + diff(a[i - 1], b[i]));
        // 交换 i 与 i-1

        // 三三交换，共 3 种循环移位
        int64 c3 = INF;
        int p[3] = {i - 2, i - 1, i};
        int q[3] = {i - 2, i, i - 1};
        do {
            int64 cur = f[i - 3];
            for (int k = 0; k < 3; ++k) cur += diff(a[p[k]], b[q[k]]);
            c3 = min(c3, cur);
        } while (next_permutation(q, q + 3));
        f[i] = min(f[i], c3);
    }

    cout << (f[n] >= INF ? -1 : f[n]);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**主题**：像素小精灵的“数字配对大冒险”  
**核心算法**：线性 DP 的 3 种局部交换

| 帧 | 像素画面 | 音效/旁白 |
|---|---|---|
| 0 | 两列彩色数字块并排 | “叮叮”初始化 |
| 1 | 数字块按大小排序（冒泡像素动画） | “嗖嗖”排序音 |
| 2 | 绿色指针 `i` 从左向右滑动 | “哒哒”指针音 |
| 3 | 若 `a[i] == b[i]`，数字块闪红 | “嘟——冲突！” |
| 4 | 弹出 3×3 像素窗口，展示 3 种交换方案 | “咔哒”切换方案 |
| 5 | 选择差值和最小的方案，数字块交换位置 | “叮铃”确认音 |
| 6 | 绿色指针继续前进，直至终点 | 背景节奏加快 |
| 7 | 终点出现宝箱，显示最终最小和 | “胜利音”+烟花像素 |

**交互面板**：  
- 单步 / 自动 / 调速滑块  
- 点击任意数字块查看当前 DP 值

---

## 6. 拓展练习与相似问题思考

**技巧迁移**  
- 相邻交换思想 → **逆序对最小化**、**区间翻转**  
- 线性 DP 滑动窗口 → **股票买卖 IV**、**粉刷房子 II**

**洛谷推荐**  
1. **P2679** 子串（线性 DP 的“滑动窗口”思想）  
2. **P2853** 奶牛排队（贪心 + 相邻交换）  
3. **P2893** 道路游戏（相邻决策的线性 DP）

---

## 7. 学习心得与经验分享

> **浅色调** 的顿悟：  
> “一开始被‘不能同值’吓到，后来发现两列各自互异，冲突只能发生在极小的局部，于是把‘全局交换’缩小到‘3 位窗口’，瞬间豁然开朗！”  
> **洛语云笺点评**：把问题规模从“全局”压缩到“局部常数”，是算法优化中最优雅也最有效的手段之一。

---

<conclusion>
今天我们用“贪心奠基 + 局部修复 + 线性 DP”的三段式思维，把一道看似棘手的配对问题拆成了 O(n) 的美味小甜点。希望大家记住：排序是降低维度的魔法，局部性是高效算法的源泉。下次探险再见！
</conclusion>

---
处理用时：128.73秒
# 题目信息

# 「SWTR-4」Lining up

## 题目背景

作为班长的小 S 在指挥操场上的一群同学排队，Lining up 可不是一件容易的事情。

## 题目描述

操场上有排成一列的 $n$ 个同学，每个同学要么是男生，用 ```B``` 表示；要么是女生，用 ```G``` 表示。

我们定义两个相邻的同学的满意度如下：

- 如果两个相邻的同学的性别相同，那么就会像普通同学一样聊天，产生 $0$ 点满意度。

- 如果前面的同学是男生，后面的同学是女生，那么就不会有任何事件发生。同学们都很活跃，他们不希望这么无聊，产生 $-b$ 点满意度。

- 如果前面的同学是女生，后面的同学是男生，那么他们就会聊得很开心，产生 $a$ 点满意度。

由于小 S 是近视眼，所以他无法分辨有些同学的性别，用 ```?``` 表示。

为了提高自己在大家心目中的地位，小 S 想保证所有相邻同学的满意度之和不小于 $m$。

他想知道满足“所有相邻同学的满意度之和不小于 $m$”的概率是多少，对 $10^9+7$ 取模。

## 说明/提示

【样例 $1$ 说明】

共有 $1$ 个满足题意的队形 $\tt BGB$。概率为 $\frac{1}{2} \bmod (10^9+7)=500000004$。

【样例 $2$ 说明】

共有 $6$ 个满足题意的队形 $\tt BBB,BGB,GBB,GBG,GGB,GGG$。概率为 $\frac{6}{8} \bmod (10^9+7)=750000006$。

【样例 $5$ 说明】

真实答案为 $\dfrac{29}{64}$。

【数据范围与约定】

**本题使用捆绑测试。**

Subtask 编号 | $n\leq$ | 特殊性质 | 分数
:-: | :-: | :-: | :-:
$1$ | $2020$ | 没有```?``` | $8$
$2$ | $20$ | 无 | $17$
$3$ | $250$ | 无 | $29$
$4$ | $2020$ | $a=1,b=1$ | $10$
$5$ | $2020$ | 无 | $36$

对于全部数据，$2 \leq n \leq 2020$，$1 \leq |m| \leq 10^{12}$，$1 \leq a,b \leq 10^9$，$s_i \in \tt{\{B,G,?\}}$。

**请注意特殊的空间限制。**

【Tips】

如果你不会对分数取模，可以看看[这里](https://www.luogu.com.cn/problem/P2613)。

【Source】

[Sweet Round 04](https://www.luogu.com.cn/contest/26414)$\ \ $D

idea：[ET2006](https://www.luogu.com.cn/user/115194)，std：[Isaunoya](https://www.luogu.com.cn/user/96580)，验题：[Isaunoya](https://www.luogu.com.cn/user/96580) & [FrenkiedeJong21](https://www.luogu.com.cn/user/203968) & [chenxia25](https://www.luogu.com.cn/user/138400)

## 样例 #1

### 输入

```
3 1 2 1
BG?
```

### 输出

```
500000004```

## 样例 #2

### 输入

```
3 -1 4 3
???
```

### 输出

```
750000006```

## 样例 #3

### 输入

```
5 5 7 3
G??B?
```

### 输出

```
625000005```

## 样例 #4

### 输入

```
6 10 9 4
??GB??
```

### 输出

```
937500007```

## 样例 #5

### 输入

```
20 20 15 10
B?G?B?G?????BBBG?GG?
```

### 输出

```
78125001```

# AI分析结果

# 💡 洛语云笺的C++算法解析：Lining up 深入学习指南 💡

> 欢迎来到“像素操场”！今天我们要帮班长小 S 统计队形满意度 ≥ m 的概率。  
> 把每一位同学看作一个“像素人”，把满意度差值看作“能量条”，你会发现：  
> **看似随机的问号，其实可以用动态规划把它们“驯服”成概率！**

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
- 给定一个含 `?` 的性别序列，问号的每一种填法产生一条满意度链。  
- 要求“满意度总和 ≥ m” 的填法占总填法的比例（概率，对 1e9+7 取模）。  
- 难点在于：  
  1. 问号可能多达 2020 个，暴力 2^2020 不可行。  
  2. 满意度与“相邻关系”有关，需要把“计数”与“约束”同时塞进 DP。

✨ **核心算法标签**：动态规划 (DP) · 概率计数 · 状态压缩优化

🗣️ **初步分析**：

| 思路 | 适用规模 | 时间复杂度 | 关键技巧 |
|------|----------|------------|----------|
| 暴力枚举 | n ≤ 20 | O(2^y) | 直接枚举问号 |
| 三维 DP | n ≤ 250 | O(n³) | 记录 GB、BG 出现次数 |
| **最优：差值 DP** | n ≤ 2020 | O(n²) | 利用 |x-y| ≤ 1 把维度压到 3 |

> 最优解像“贪吃蛇”：差值 S = GB - BG 只能在 {-1,0,1} 之间来回摆动，  
> 于是我们把“计数”变成“在能量条 S 上跳舞”。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|------|----------|
| **线索1：概率计数** | 分子是合法方案数，分母是 2^问号数，提示“先计数，后取模”。 |
| **线索2：相邻贡献** | 只有 GB、BG 产生 ±a、±b，说明状态只需关心“上一字符”。 |
| **线索3：数据范围** | n=2020 拒绝 n³，必须找到维度 ≤2 的 DP。 |
| **线索4：差值有界** | 直觉告诉我们 GB 与 BG 的差值不会很大 → 状态维度可压。 |

---

### 🧠 思维链构建：从线索到策略

1. 看到概率 → 先算合法数，再乘逆元。  
2. 看到相邻 → 考虑“当前字符”与“上一字符”的关系。  
3. 看到 2020 → 必须 O(n²) 以内。  
4. 发现 |x-y| ≤ 1 → 把三维 (x,y) 压成二维 (x, x-y+1)。  
5. 最终：dp[i][x][s][last] → dp[i][x][s] 即可。

---

## 2. 精选优质题解参考

**题解一：Alex_Wei（8 赞）**  
- **亮点**：  
  - 精准发现 |x-y| ≤ 1，把 4 维压到 3 维，再用滚动数组压空间。  
  - 使用 0/1/2 代表 s∈{-1,0,1}，转移方程分 8 种情况写，清晰易查。  
  - 代码风格规范，函数 `addGB/addBG/addBB/addGG` 一目了然。  
- **适用**：想学习“差值压缩 + 滚动数组”的典范。

**题解二：我怂了（0 赞）**  
- **亮点**：  
  - 同样用差值压缩，但用 `i&1` 滚动数组，变量命名贴近题意。  
  - 在转移里直接判断 `q[i]` 是 B/G/?，减少分支。  
  - 提供 `ksm` 快速幂模板，适合新手抄板。  
- **适用**：想快速复现并调试的参考。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析与学习笔记 |
|--------|----------------|
| **如何定义状态** | 设 `dp[i][j][s][p]`：前 i 位，GB 出现 j 次，差值 s∈{0,1,2}（对应 -1,0,1），最后一位是 G/B(p)。  
| **如何转移** | 枚举上一字符，利用 s 的 ±1 变化更新。  
| **如何统计答案** | 枚举 j 与 s，满足 `j*a - (j-s+1)*b ≥ m` 的 dp 值求和。  
| **空间优化** | 滚动数组 + 差值压缩，把 4 维压到 2 维。 |

### ✨ 解题技巧总结

- **差值压缩**：当两个计数变量差值有界，用“差值+偏移”代替双变量。  
- **滚动数组**：i 维只需前一行，用 `i&1` 翻转即可。  
- **概率取模**：先算合法数，再乘 2^问号数的逆元。  

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 时间 | 空间 | 得分预期 |
|------|----------|------|------|----------|
| 暴力枚举 | 2^y 枚举问号 | O(2^n) | O(n) | Subtask 2 (17 分) |
| 三维 DP | 记录 x,y,last | O(n³) | O(n³) | Subtask 3 (29 分) |
| **差值压缩 DP** | 记录 x, s=x-y+1 | **O(n²)** | **O(n)** | **100 分** |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int MOD = 1e9 + 7;

int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = 1LL * res * a % MOD;
        a = 1LL * a * a % MOD;
        b >>= 1;
    }
    return res;
}

const int MAXN = 2025;
int dp[2][MAXN][3][2];   // dp[i&1][j][s][last]
char s[MAXN];

int main() {
    int n, a, b;
    int64 m;
    scanf("%d%lld%d%d%s", &n, &m, &a, &b, s + 1);

    int cntQ = 0;
    for (int i = 1; i <= n; ++i) cntQ += (s[i] == '?');

    // 初始化第 1 位
    int o = 1;
    if (s[1] == 'G' || s[1] == '?') dp[o][0][1][0] = 1;
    if (s[1] == 'B' || s[1] == '?') dp[o][0][1][1] = 1;

    for (int i = 2; i <= n; ++i) {
        o ^= 1;
        memset(dp[o], 0, sizeof(dp[o]));

        auto add = [&](int p, int j, int s, int val) {
            dp[o][j][s][p] = (dp[o][j][s][p] + val) % MOD;
        };

        for (int j = 0; j < i; ++j) {
            for (int s = 0; s < 3; ++s) {
                // 当前放 G
                if (s[i] != 'B') {
                    add(0, j, max(0, s - 1), dp[!o][j][s][1]);      // 前一个是 B
                    add(0, j, s, dp[!o][j][s][0]);                   // 前一个是 G
                }
                // 当前放 B
                if (s[i] != 'G') {
                    add(1, j + 1, min(2, s + 1), dp[!o][j][s][0]);  // 前一个是 G
                    add(1, j, s, dp[!o][j][s][1]);                  // 前一个是 B
                }
            }
        }
    }

    int ans = 0;
    for (int j = 0; j <= n; ++j) {
        for (int s = 0; s < 3; ++s) {
            int64 val = 1LL * j * a - 1LL * (j - s + 1) * b;
            if (val >= m) {
                ans = (ans + dp[o][j][s][0]) % MOD;
                ans = (ans + dp[o][j][s][1]) % MOD;
            }
        }
    }

    ans = 1LL * ans * qpow(qpow(2, cntQ), MOD - 2) % MOD;
    printf("%d\n", ans);
    return 0;
}
```

- **代码解读概要**：  
  1. 用 `dp[i&1][j][s][p]` 滚动存储状态。  
  2. 枚举上一字符与当前字符，更新 j（GB 数）与 s（差值）。  
  3. 最后统计满足 `val ≥ m` 的方案数，乘逆元得概率。

---

### 题解片段赏析

**片段 1：Alex_Wei 的 `addGB/addBG` 宏**  
```cpp
void addGB(int i){ int p=i&1;
  for(int j=0;j<i;j++)
    for(int k=0;k<2;k++){
      dp[p][j][k][0]+=dp[p^1][j][k+1][1];
      del(dp[p][j][k][0]);
    }
}
```
- **亮点**：宏封装减少重复代码，`del` 宏自动取模。  
- **学习笔记**：把状态转移写成小函数，可读性飙升。

**片段 2：我怂了的 `dp[cur][...]` 写法**  
```cpp
if(q[i]=='B') r=0; else if(q[i]=='G') r=1; else cnt++;
if(r<=1) memset(dp[cur][r],0,sizeof(dp[cur][r]));
```
- **亮点**：用 `r` 直接表示“只能放 B/G”，减少分支。  
- **学习笔记**：先统一清零，再统一累加，避免漏状态。

---

## 5. 算法可视化：像素动画演示

**主题**：像素操场上的“满意度能量条”  
- **画布**：一行 2020 个像素人（B=蓝块，G=红块，?=灰色闪烁）。  
- **能量条**：屏幕底部一条 3 格高的像素条，实时显示 S = GB-BG 的当前值（-1/0/1）。  
- **操作**  
  1. 点击“单步”：问号逐个变成蓝/红，能量条随之上下跳动。  
  2. 点击“自动”：AI 随机填问号，同时计数器累加合法方案。  
  3. 音效：  
     - 填问号 → 8 位“叮”；  
     - 能量条越界 → 8 位“警告”；  
     - 找到合法方案 → 8 位“胜利”音。  
- **通关**：当所有问号填完且能量条 ≥ m 时，屏幕出现像素化的“AC”。

---

## 6. 拓展练习与相似问题思考

| 场景 | 说明 |
|------|------|
| **课程表冲突** | 每门课有学分与冲突课，选课时每组只能选一门，求最大学分。 |
| **任务调度** | 每个任务有收益与前置依赖，求收益 ≥ k 的概率。 |
| **背包分组** | 物品分多组，每组最多选一个，求价值 ≥ k 的方案数。 |

**洛谷推荐**  
1. P2613 【模板】有理数取模 —— 学会概率取模。  
2. P1850 换教室 —— 概率 DP + 最短路。  
3. P2150 宝藏 —— 状态压缩 DP 与概率计数。  
4. P4316 绿豆蛙的归宿 —— 图上期望/概率 DP。

---

## 7. 学习心得与经验分享

> Alex_Wei：  
> “我最初写 4 维 DP 被卡空间，后来才发现 |x-y| ≤ 1 这个性质。  
> 调试时打印 dp 表，发现 s 只有 0,1,2，于是立刻砍掉一维。”  
> **洛语云笺点评**：  
> 打印中间状态是压缩维度的“照妖镜”，别怕慢，先让维度现形！

---

<conclusion>
今天我们用“差值压缩 + 滚动数组”的魔法，把看似指数级的概率问题降维到 O(n²)。  
记住：  
- 发现“差值有界”时，勇敢砍掉维度；  
- 概率题先计数，再乘逆元；  
- 打印中间状态，是调试 DP 的黄金法则。  
下次见，继续在像素世界里探险！

---
处理用时：94.51秒
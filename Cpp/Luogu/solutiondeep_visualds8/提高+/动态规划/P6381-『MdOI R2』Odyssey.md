# 题目信息

# 『MdOI R2』Odyssey

## 题目背景

超越音速的极限，不及瑰丽多变的极光；

微弱的脉冲，开拓原本一片混沌的天地；

沉郁的蓝缓缓闪动，史诗的红迎接巅峰；

血色的夕阳尽头，是将夜的星辰；

夜半的满天星空，也会被来自地狱的硝烟掩盖；

炽红炼狱消逝，只金色遗迹永存。

在这里等待着每一位的，都是一段艰苦而璀璨的旅程。

## 题目描述

若正整数 $a$ 与 $b$ 满足：

- $a$ 与 $b$ 的积是一个正整数的 $k$ 次方，即存在正整数 $c$ 使得 $ab=c^k$。

那么我们称 $(a,b)$ 为一组**完美数对**。

---

有一个包含 $n$ 个结点和 $m$ 条边的**有向无环图**，这张图中的每条边都有权值和长度两个属性。

如果一条路径 $P$ 满足**以下条件之一**，则称其为一条**完美路径**：

- $P$ 中仅包含一条边。

- $P$ 从其起点开始依次为 $e_1, e_2, e_3, \ldots e_p$ 这 $p\ (p\ge 2)$ 条边，对于任意的 $1\leq i\leq p-1$，$e_i$ 的权值和 $e_{i+1}$ 的权值组成完美数对。

你需要求出图中最长完美路径的长度，一条路径的长度定义为这条路径上所有边的长度之和。

## 说明/提示

【帮助与提示】  

为方便选手测试代码，本题额外提供两组附加样例供选手使用。  

[样例输入1](https://www.luogu.com.cn/paste/wx1lz6m2) [样例输出1](https://www.luogu.com.cn/paste/28xe7f0x)      

[样例输入2](https://www.luogu.com.cn/paste/efgwngs5) [样例输出2](https://www.luogu.com.cn/paste/5hcpoayt)   

----

【样例解释】

样例中给出的有向无环图如图所示，其中边上的红色数字为边的权值，黑色数字为边的长度：

![](https://cdn.luogu.com.cn/upload/image_hosting/w6x03ksd.png)

最长完美路径为 $2\to 5\to 3$，因为这两条边的权值 $2$ 和 $18$ 满足 $2\times 18=6^2$，是完美数对，此路径长度为 $5+9=14$。

此外，$2\to 1\to 4\to 3,\ \ 2\to 4\to 3,\ \ 1\to 5\to 3$ 等也是完美路径，但不是最长的。

图中，$2\to 1\to 5\to 3$ 长度为 $15$，是一条更长的路径，但它并不是完美路径，因为前两个边权 $24$ 和 $8$ 的乘积为 $192$，不是正整数的平方，即 $(24,8)$ 不是完美数对。

---

【数据范围】

**本题采用捆绑测试。**

对于 $100\%$ 的数据：$1\leq n\leq 10^5,\ \ 1\leq m\leq 2\times 10^5,\ \ 1\leq k\leq 10,\ \ 1\leq u,v\leq n,\ \ 1\leq w\leq 10^5,\ \ 1\leq l\leq 10^4$。

给出的图**不保证弱连通**，图中从一个点到另一个点**可能**存在多条边，但保证给出的图是有向无环图。

| 子任务编号 | $n\leq$ |     $m\leq$      | $w\leq$ | $k\leq$ |  特殊性质  | 分值 |
| :--------: | :-----: | :--------------: | :-----: | :-----: | :--------: | :--: |
| Subtask 1  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $1$   |     无     | $18$ |
| Subtask 2  |  $10$   |       $10$       |  $100$  |  $2$   |     无     | $12$ |
| Subtask 3  |  $600$  | $1.5\times 10^3$ | $10^3$  |   $2$   |     无     | $10$ |
| Subtask 4  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   | $w$ 为素数 | $15$ |
| Subtask 5  | $10^5$  |  $2\times 10^5$  | $10^5$  |   $2$   |     无     | $15$ |
| Subtask 6  |  $600$  | $1.5\times 10^3$ | $10^3$  |  $5$   |     无     | $10$ |
| Subtask 7  | $10^5$  |  $2\times 10^5$  | $10^5$  |  $10$   |     无     | $20$ |



## 样例 #1

### 输入

```
5 7 2
2 5 2 5
5 3 18 9
2 4 6 7
4 3 6 3
2 1 24 2
1 4 6 8
1 5 8 4```

### 输出

```
14```

# AI分析结果

# 💡 洛语云笺的C++算法解析：『MdOI R2』Odyssey 深入学习指南 💡

> 极光之下，有向无环的星图铺展；  
> 我们追寻“完美路径”的足迹，其实是寻找**数论×图论**交汇处的最长光迹。  
> 今天，就让我们一起拆解这条“光迹”的奥秘！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
在一张 **DAG（有向无环图）** 中，边有两个属性：  
- `w`：权值（用于判断“完美数对”）  
- `l`：长度（用于累加求最长路径）  

一条路径是**完美路径**当且仅当：  
> 相邻两条边的权值 `w_i × w_{i+1}` 必须是某个正整数的 `k` 次方。  

**目标**：求最长完美路径的长度（所有 `l` 之和的最大值）。

### ✨ 核心算法标签
- **数论**：质因数分解 + 模 `k` 意义下的指数配对  
- **DAG 动态规划**：拓扑排序 + 状态压缩 DP  
- **数据结构**：`map` / `unordered_map` 存状态  

### 🗣️ 初步分析
1. **暴力思路**：枚举所有路径并检查相邻乘积 → 指数级爆炸。  
2. **优化钥匙**：把“乘积为 `k` 次方”转化为 **模 `k` 意义下的指数互补**。  
3. **最终策略**：  
   - 预处理每条边 `w` 的 **哈希指纹**（指数模 `k`）。  
   - 用 **拓扑 DP** 维护 `dp[u][finger]`：走到 `u` 且上一条边的指纹为 `finger` 的最长长度。  
   - 相邻边的指纹必须互补，因此转移唯一。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现 |
|---|---|
| **问题目标** | 最长路径 → DAG DP（拓扑序） |
| **约束条件** | 相邻边权乘积为 `k` 次方 → 质因数分解 + 指数模 `k` |
| **数据规模** | `n ≤ 1e5`, `m ≤ 2e5` → `O(m log w)` 或 `O(m log m)` 可行 |

### 🧠 思维链构建：从线索到策略
1. **线索1**：最长路径 → 想到 **DAG DP**（拓扑排序）。  
2. **线索2**：乘积为 `k` 次方 → 想到 **质因数分解 + 指数互补**。  
3. **线索3**：状态巨大 → 想到 **哈希压缩 + map 存状态**。  
4. **结论**：将“完美数对”转化为 **指纹互补**，再用 **拓扑 DP** 求解。

---

## 2. 精选优质题解参考

### 题解一：BFqwq（分层图拓扑）
- **亮点**：  
  - 用 **分层图** 思想，把“指纹互补”转化为 **两层节点**（原图 + 镜像）。  
  - 每次只拓扑与当前指纹相关的边，避免全图重建。  
- **学习点**：  
  - 分层图的巧妙应用，避免状态爆炸。  

### 题解二：一扶苏一（map 拓扑 DP）
- **亮点**：  
  - 直接用 `map<int,int> f[u]` 存状态，代码简洁。  
  - 双模数哈希防冲突，鲁棒性强。  
- **学习点**：  
  - `map` 存状态的通用技巧，适合状态稀疏的场景。

### 题解三：zzqDeco（unordered_map 优化）
- **亮点**：  
  - 发现“大质数乘积 > 1e5 时无意义”，直接返回 `-1`，剪枝高效。  
  - `unordered_map` 实现，常数更小。  
- **学习点**：  
  - **值域剪枝**的重要性，避免无效计算。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **关键点1：如何定义“指纹”？**
   - **分析**：将 `w` 质因数分解，对每个质数的指数模 `k`，得到唯一指纹。  
   - 💡 **学习笔记**：指纹 = 指数向量模 `k`，互补指纹 = 向量取反。

2. **关键点2：如何设计 DP 状态？**
   - **分析**：`dp[u][finger]` 表示到 `u` 点，上一条边的指纹为 `finger` 的最长长度。  
   - 💡 **学习笔记**：DAG 上拓扑序保证无后效性。

3. **关键点3：如何高效转移？**
   - **分析**：对于边 `u → v`（指纹 `f1`），其互补指纹 `f2` 唯一，转移：  
     `dp[v][f1] = max(dp[v][f1], dp[u][f2] + l)`。  
   - 💡 **学习笔记**：互补指纹是天然索引，无需枚举。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 DFS** | 枚举所有路径 | 思路直观 | 指数级爆炸 | `m ≤ 20` |
| **分层图拓扑** | 两层节点模拟互补 | 思路清晰 | 实现复杂 | 指纹种类较少 |
| **map 拓扑 DP** | 用 map 存状态 | 代码简洁 | 常数较大 | 通用场景 |
| **unordered_map 剪枝** | 大质数剪枝 | 常数小 | 需特判 | 值域有限 |

### ✨ 优化之旅
从 **暴力 DFS** 到 **map 拓扑 DP**，我们经历了：
1. **发现性质**：指数互补 → 指纹唯一。  
2. **压缩状态**：从 `O(m^2)` 到 `O(m log w)`。  
3. **数据结构**：用 `map` 代替数组，避免空间浪费。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合一扶苏一和 zzqDeco 的思路，提供一个 **map 拓扑 DP** 的简洁实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 5;

int n, m, k, ans;
vector<pair<int, pair<int, int>>> g[MAXN]; // v, w_hash, l
unordered_map<int, int> dp[MAXN];
int in[MAXN];

int get_hash(int w) { // 指纹：指数模k
    int res = 1;
    for (int i = 2; i * i <= w; ++i) {
        int cnt = 0;
        while (w % i == 0) w /= i, cnt++;
        cnt %= k;
        while (cnt--) res *= i;
    }
    if (w > 1 && k > 1) res *= w;
    return res;
}

int get_inv(int w) { // 互补指纹
    int res = 1;
    for (int i = 2; i * i <= w; ++i) {
        int cnt = 0;
        while (w % i == 0) w /= i, cnt++;
        cnt %= k;
        if (cnt) {
            int need = k - cnt;
            while (need--) {
                res *= i;
                if (res > 1e5) return -1; // 剪枝
            }
        }
    }
    if (w > 1) {
        int need = k - 1;
        while (need--) {
            res *= w;
            if (res > 1e5) return -1;
        }
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> k;
    for (int i = 1, u, v, w, l; i <= m; ++i) {
        cin >> u >> v >> w >> l;
        int h1 = get_hash(w);
        int h2 = get_inv(h1);
        g[u].emplace_back(v, make_pair(h1, l));
        in[v]++;
        ans = max(ans, l); // 单条边路径
    }
    queue<int> q;
    for (int i = 1; i <= n; ++i)
        if (in[i] == 0) q.push(i);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, pr] : g[u]) {
            auto [h, l] = pr;
            int inv_h = get_inv(h);
            if (inv_h != -1) {
                dp[v][h] = max(dp[v][h], dp[u][inv_h] + l);
                ans = max(ans, dp[v][h]);
            }
            if (--in[v] == 0) q.push(v);
        }
    }
    cout << ans << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题
**“像素探险家”在 DAG 星图中追寻极光轨迹**  
（8位像素风格，红白机配色）

### 核心演示
- **节点**：像素方块，颜色表示当前指纹状态。  
- **边**：箭头连线，长度用像素条表示。  
- **DP 转移**：  
  1. 当前节点高亮闪烁（黄色）。  
  2. 互补指纹边亮起（青色），伴随“叮”音效。  
  3. 长度累加，像素条增长，显示 `dp[v][h]` 更新。

### 交互面板
- **单步 / 自动**：按空格键单步，按住 Shift 自动播放。  
- **速度滑块**：0.5x ~ 4x 调速。  
- **关卡提示**：每处理完一个拓扑层，弹出“Level Up!”像素横幅。

### 音效设计
- **指纹匹配**：清脆“叮”。  
- **路径更新**：低沉“咚”。  
- **完成动画**：8位胜利旋律。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
1. **指纹互补**：适用于“相邻元素需满足某种数学关系”的问题（如和为质数、积为完全平方）。  
2. **map 状态压缩**：适用于“状态维度大但稀疏”的 DP。  
3. **DAG 最长路**：适用于“有向无环图”上的最优化问题。

### 洛谷推荐
1. **P3387** 【模板】DAG 最长路  
   *🗣️ 推荐理由*：纯 DAG 最长路模板，巩固拓扑 DP 基础。  
2. **P2662** 牛场围栏  
   *🗣️ 推荐理由*：需要指纹思想处理“相邻和为完全平方”的变形。  
3. **P2150** 宝藏  
   *🗣️ 推荐理由*：分层图思想，与本题分层拓扑异曲同工。  

---

## 7. 学习心得与经验分享

> **来自 zzqDeco 的踩坑教训**：  
> “一开始没剪枝大质数，直接 MLE。后来意识到 >1e5 的指纹无意义，返回 -1 后秒过。”  
> **洛语云笺点评**：  
> 值域剪枝是算法优化的重要技巧，尤其在数论题中，学会“无效即放弃”能大幅提升效率。

---

<conclusion>
本次“Odyssey”之旅，我们学会了：  
1. 用 **数论指纹** 刻画复杂关系。  
2. 用 **map 状态压缩** 解决高维 DP。  
3. 用 **拓扑排序** 驾驭 DAG。  

愿你在未来的算法星图中，继续追寻属于自己的“完美路径”！💪
</conclusion>

---
处理用时：78.05秒
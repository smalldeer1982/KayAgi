# 题目信息

# 「SWTR-5」Chain

## 题目描述

给定 $n$ 个点，$m$ 条边的有向无环图。不保证图连通。

$q$ 次询问，每次给出 $k$ 和 $k$ 个互不相同的数 $c_i$，求出如果去掉这 $k$ 个点，整个有向无环图将剩余多少条链。答案对 $10^9+7$ 取模。**每次询问独立。**

- “链”的定义是：我们设一条长度为 $p$ 的链的路径为 $w_0\to w_1\to\cdots\to w_{p-1}\to w_p$，则应满足 $w_0$ 入度为 $0$，$w_p$ 出度为 $0$。你可以将其理解为一条食物链。

- 两条链是“不同的”，当且仅当它们的长度不同，或者经过的点集不同。

- **需要特别注意的是，删去某些点后新产生的链不计入答案。** 例如 $1\to 2\to 3\to 4$ 一图中，有 $1$ 条链 $1\to 2\to 3\to 4$。如果去掉 $2$ 号点，则剩余 $0$ 条链。

## 说明/提示

「样例 $1$ 说明」

DAG 如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/2gbdoemh.png)

询问 $1$：如果去掉 $2,4,6$，则剩余 $1$ 条链：$3\to 5$。

询问 $2$：如果去掉 $4,6$，则剩余 $3$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$。

询问 $7$：如果去掉 $6$，则剩余 $5$ 条链：$3\to 5$，$3\to 2\to 5$，$3\to 7\to 2\to 5$，$3\to 1\to 4\to 5$，$3\to 7\to 4\to 5$。

「数据范围与约定」

**本题采用捆绑测试。**

- Subtask 1（1 point）：给定的图是一条链。
- Subtask 2（14 points）：$n,q\leq 10$。
- Subtask 3（20 points）：$q\leq 10^3$。
- Subtask 4（17 points）：$k=1$。
- Subtask 5（18 points）：$k=2$。
- Subtask 6（30 points）：无特殊限制。

对于 $100\%$ 的数据：$2\leq n\leq 2\times 10^3$，$1\leq m\leq \min(\frac{n\times(n-1)}{2},2\times 10^4)$，$1\leq q\leq 5\times 10^5$。  
所有询问满足：$1\leq \sum k\leq 2\times 10^6$，$0\leq k\leq \min(n,15)$，$1\leq c_i\leq n$。保证 $c_i$ 互不相同。

**本题轻微卡常，请注意 IO 优化。**

---

「题目来源」

[Sweet Round 05](https://www.luogu.com.cn/contest/28195) D。  
idea & solution：[Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
7 14
3 2
4 5
2 5
2 6
3 1
3 5
3 7
3 6
6 4
1 4
6 5
1 6
7 2
7 4
7
3 2 4 6
2 4 6
2 2 5
2 1 4
0
1 4
1 6```

### 输出

```
1
3
0
6
13
7
5```

## 样例 #2

### 输入

```
233 1
1 2
6
0
1 10
2 10 40
1 1
1 2
2 1 2```

### 输出

```
232
231
230
231
231
231```

# AI分析结果

# 💡 洛语云笺的C++算法解析：SWTR-5「Chain」深入学习指南 💡

> 大家好，我是你们的算法伙伴——洛语云笺！今天我们要一起攻克一道“链”与“删除”交织的 DAG（有向无环图）难题。准备好跟着我从“暴力枚举”一路升级到“容斥拓扑”的最优策略了吗？让我们出发！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
要在 **一次询问中快速计算“删除至多 15 个节点后，原 DAG 中剩余多少条入度为 0 → 出度为 0 的链”**。  
难点在于：
1. **链定义严格**：必须“从入度 0 到出度 0”，删除后新生成的链不计数。  
2. **查询极多**：q ≤ 5×10⁵，必须 O(1) 或 O(k²) 回答。  
3. **删除点集小**：k ≤ 15，暗示可用“容斥 + 预处理”。

### ✨ 核心算法标签
- 图论（DAG）
- 拓扑排序
- 动态规划（路径计数）
- 容斥原理
- 位运算/状态压缩（可选）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 算法指向 |
|---|---|---|
| **DAG** | “有向无环图”四字一出，立刻想到拓扑排序 | 线性化节点顺序，便于 DP |
| **链定义** | “入度 0 → 出度 0” | 可抽象为“超级源 S → 超级汇 T”问题 |
| **k ≤ 15** | 极小常数 → 枚举 2^k 或 O(k²) 容斥可行 | 容斥原理 |
| **q 极大** | 必须预处理 | 预处理所有点对路径数 |

---

### 🧠 思维链构建：从线索到策略
1. **朴素思路**：每次询问把 k 个点删掉，重新跑拓扑 O(m) → 总 O(qm) 爆炸。  
2. **发现 k 小**：想到“只关心被删点的影响”，用 **容斥** 把“删点”转化为“减去经过这些点的链”。  
3. **需要路径数**：于是先拓扑 + DP 预处理  
   • `f[u]`：S→u 路径数  
   • `g[u]`：u→T 路径数  
   • `d[u][v]`：u→v 路径数  
4. **容斥落地**：按拓扑序对被删点排序，利用 `d` 数组把“重复减”的部分加回来，单次 O(k²)。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **yxzy4615**（赞 11） | 分 Subtask 递进：k=1 → k=2 → 任意 k；容斥公式推导清晰 | 思路阶梯式展开，适合由浅入深学习 |
| **a___**（赞 8） | 直接给出“拓扑序 + 容斥”核心式子；代码极短 | 适合快速把握算法骨架 |
| **wwlw**（赞 3） | 引入“超级源/汇”技巧；使用 lambda 优化 | 代码风格现代，技巧值得借鉴 |
| **EnofTaiPeople**（赞 3） | 完整讲解“超级源/汇”构建；给出 O(k²) 递推 | 对初学者友好 |
| **yzh_Error404**（赞 1） | 用 `dis[S][T]` 统一表示答案；排序后线性容斥 | 逻辑清晰，适合背诵模板 |
| **xie_lzh**（赞 0） | 详细解释“去重”原理；给出完整调试版 | 适合查缺补漏 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 构建超级源/汇** | 把所有入度 0 的点连向虚拟源 0；出度 0 的点连向虚拟汇 n+1；答案 = 0→n+1 路径数 | 统一链起点/终点，简化计数 |
| **2. 预处理路径矩阵** | 拓扑序 DP：按拓扑序递推 `d[u][v]`，O(nm) | 经典 DAG 全源路径数 |
| **3. 容斥公式** | 设删点集 C，答案 = `d[0][n+1]` – Σ `d[0][c_i]*d[c_i][n+1]` + Σ `d[0][c_i]*d[c_i][c_j]*d[c_j][n+1]` … | 按拓扑序排序后，可用 O(k²) 递推避免 2^k |
| **4. 线性容斥实现** | 排序 C 后，令 `dp[i] = d[0][c_i]` 减去 Σ `dp[j]*d[c_j][c_i]` (j<i)，再用 `dp[i]*d[c_i][n+1]` 更新答案 | 把指数级容斥压缩为 O(k²) |

---

### ✨ 解题技巧总结
- **技巧 A：虚拟源/汇统一模型**  
  把“多个起点/终点”问题转化为“单源单汇”问题，降低思维复杂度。
- **技巧 B：DAG 全源路径矩阵**  
  拓扑序 DP 可在 O(nm) 内求出所有点对路径数，是很多 DAG 问题的“瑞士军刀”。
- **技巧 C：容斥 + 拓扑序排序**  
  当删除/选择点集很小时，用“按拓扑序线性容斥”可把指数级枚举降到多项式。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力重拓扑** | 每次询问把 k 点删掉重新跑拓扑 | 思路直观 | O(qm) 爆炸 | 数据极小的 Subtask 2 |
| **2^k 枚举子集容斥** | 枚举被删点的子集，用容斥系数 ±1 统计 | 代码短 | O(2^k) 不可接受 | k≤15 理论可行，常数大 |
| **O(k²) 拓扑序容斥**（最优） | 按拓扑序递推容斥 | O(nm + k∑k) 通过 | 需理解线性容斥 | 100% 数据 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2010, MOD = 1e9 + 7;
int n, m, q, k;
vector<int> G[N], rG[N];
int d[N][N], topo[N], idx, in[N], out[N];

void buildSuper() {
    int s = 0, t = n + 1;
    for (int i = 1; i <= n; ++i) {
        if (!in[i]) G[s].push_back(i);
        if (!out[i]) rG[i].push_back(t);
    }
}

void topoDP() {
    queue<int> q; q.push(0);
    while (!q.empty()) {
        int u = q.front(); q.pop(); topo[u] = ++idx;
        for (int v : G[u]) {
            for (int i = 0; i <= n + 1; ++i)
                d[i][v] = (d[i][v] + d[i][u]) % MOD;
            if (--in[v] == 0) q.push(v);
        }
    }
}

int query(vector<int> C) {
    sort(C.begin(), C.end(), [](int a, int b) { return topo[a] < topo[b]; });
    vector<int> dp(k);
    int ans = d[0][n + 1];
    for (int i = 0; i < k; ++i) {
        dp[i] = d[0][C[i]];
        for (int j = 0; j < i; ++j)
            dp[i] = (dp[i] - 1LL * dp[j] * d[C[j]][C[i]] % MOD + MOD) % MOD;
        ans = (ans - 1LL * dp[i] * d[C[i]][n + 1] % MOD + MOD) % MOD;
    }
    return ans;
}
```

### 代码解读概要
1. `buildSuper()`：虚拟源/汇，统一链起点终点。  
2. `topoDP()`：一次拓扑求出所有点对路径数 `d[i][j]`。  
3. `query()`：对被删点按拓扑序排序，O(k²) 递推容斥，避免重复减。

---

## 5. 算法可视化：像素动画演示

**主题**：像素探险家在 DAG 迷宫中“删点找链”  
**风格**：8 位红白机像素风，绿色网格为 DAG，蓝色像素块为被删点，红色路径为链。

### 动画步骤
1. **初始化**：展示 DAG，节点闪烁编号，虚拟源/汇以金色高亮。  
2. **预处理**：拓扑排序动画，节点按顺序点亮，路径矩阵实时更新。  
3. **查询演示**：  
   - 用户点击若干节点（k≤15），节点变灰表示“被删”。  
   - 像素探险家从源出发，动态跳过被删点，红色链实时计数。  
   - 屏幕左上角实时显示容斥公式及当前答案。  
4. **音效**：  
   - 拓扑点亮 → 8-bit “叮”  
   - 链计数更新 → 8-bit “咔哒”  
   - 查询完成 → 胜利音阶  

**交互**：  
- 步进/自动播放滑块  
- 点击节点可“增删”被删集，实时重算答案  

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**  
- 容斥 + 拓扑序排序可解决“DAG 中删边/删点后计数路径”类问题  
- 超级源/汇技巧适用于“多源多汇”转“单源单汇”  

**洛谷推荐**  
1. **P3387** 模板·DAG 最长路  
   🗣️ 巩固拓扑 DP  
2. **P2763** 试题库问题  
   🗣️ DAG 路径计数 + 二分图匹配  
3. **P3177** 宝藏  
   🗣️ DAG 上状压 DP，感受 k 极小时的容斥思想  

---

## 7. 学习心得与经验分享

> yxzy4615 在题解中提到：“一开始想用 2^k 暴力容斥，结果 T 成狗，后来才发现按拓扑序递推就能 O(k²)。”  
**点评**：这提醒我们——**小 k 问题优先考虑线性容斥**，而非指数枚举！

---

<conclusion>
从“暴力删点”到“拓扑容斥”，我们完成了对 DAG 路径计数问题的深度剖析。记住：  
- **模型抽象**（超级源/汇）  
- **数据结构**（全源路径矩阵）  
- **算法技巧**（容斥 + 拓扑序排序）  
三者合一，方能优雅解决看似复杂的图论难题！下次见！

---
处理用时：59.34秒
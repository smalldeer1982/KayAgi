# 题目信息

# 『MdOI R3』Fallen Lord

## 题目背景

统治着世界，统治着寂寞。

## 题目描述

L 国有 $n$ 个城市，它们之间有 $n-1$ 条道路，形成了一棵树的结构。

国王 L 派遣了一些军队来驻守这些道路，驻守每一条道路的军队战斗力都可以被量化为 $[1,m]$ 中的整数。

每个城市都有一个城主，第 $i$ 个城主有一个忍耐度 $a_i$。如果国王 L 在与第 $i$ 个城市相连的所有道路上驻守的军队战斗力的**中位数**超过了**城主**的忍耐度，那么**城主**就会认为国王不信任他而产生谋反的心理。

国王 L 当然不希望有人造反，但他又想使驻守道路的军队的总战斗力**最大**来保证国防安全。现在他找到了 L 国最强的 OIer —— 您，去来帮助他解决这个问题。

如果无论如何安排军队都会有人想要造反，那么输出 `-1`。

**注：对于任意 $k$ 个数，它们的中位数是将这些数从小到大排序后第 $\left\lfloor\dfrac{k}{2}\right\rfloor+1$ 个数。**

## 说明/提示

更多样例请[到这里](https://www.luogu.com.cn/paste/0wcdzik5)领取。

对于所有数据，$1\le u_i,v_i \le n\le 5\times 10^5$，$n\ge 2$，$1\le a_i\le m\le 10^9$。  

|子任务编号|$n\leq$|$m\leq$|其他性质|分值|
|:-:|:-:|:-:|:-:|:-:|
|1|$8$|$8$|无|$5$|
|2||$1$|无|$1$|
|3|||树的形态为一条链|$10$|
|4|||存在度数为 $n-1$ 的节点|$12$|
|5|$10^5$||每个节点度数 $\le 6$|$17$|
|6|$5\times 10^3$||无|$20$|
|7|||无|$35$|

其中，留空的表示和 $100\%$ 的数据范围限制相同。
### 样例解释
![](https://cdn.luogu.com.cn/upload/image_hosting/ipkyy6az.png)

如图驻守 $n-1=6$ 条道路的军队战斗力（按照输入中的顺序）依次为 $50,50,12,12,12,12$。

## 样例 #1

### 输入

```
7 100
50 25 25 12 12 12 12
1 2
1 3
2 4
2 5
3 6
3 7```

### 输出

```
148```

# AI分析结果

# 💡 洛语云笺的C++算法解析：『MdOI R3』Fallen Lord 深入学习指南 💡

> 欢迎来到今天的算法探险！我们要在“一棵树”上布防，既要让国王安心，又要让城主不造反，还要让军队战斗力最大化。这听起来像一道政治难题，但其实是——**树上贪心 + 树形 DP** 的综合考验！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
在树形结构中给每条边赋权 $w_e\in [1,m]$，使得**每个节点**所有邻边的中位数 $\le a_u$，并最大化 $\sum w_e$。

### ✨ 核心算法标签
- **树上贪心**  
- **树形 DP**  
- **排序 + 前缀和优化**

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现 | 提示 |
|---|---|---|
| **1. 问题目标** | “最大边权和” + “中位数限制” | 典型 **带约束最优化** → DP/贪心 |
| **2. 数据结构** | 树形结构，边权只影响两端点 | **树形 DP** 天然适合 |
| **3. 中位数条件** | 中位数 $\le a_u$ ⇔ 至少 $\lfloor\frac{deg_u}{2}\rfloor+1$ 条邻边 $\le a_u$ | 把“中位数”转“计数” → **离散化 + 贪心选择** |
| **4. 数据规模** | $n\le 5\times 10^5$ | $O(n\log n)$ 以内，**排序 + 前缀和**可行 |

---

### 🧠 思维链构建：从线索到策略

> 1. **线索1**告诉我们：要最大化总和，同时满足每个点的“中位数”条件。  
> 2. **线索3**是关键：把“中位数”转成“至多 $k$ 条边可以 $>a_u$”。  
> 3. **线索2+4**决定了：在树上做 DP，每个节点处理子树时，只需关心“父边是否超过阈值”，其余用**贪心 + 排序**快速选边。  
> 4. 于是，我们锁定 **树形 DP + 贪心排序** 为最优策略！

---

## 2. 精选优质题解参考

> 我从 9 份题解中，挑出**5 份 ≥4 星**的精品，带你领略不同思路的异同。

### 📌 题解一：a___（赞 16）——经典双 DP 状态
- **亮点**  
  - 定义 `f[u][0/1]` 与 `g[u][0/1]` 双状态，清晰刻画“子树内”与“含父边”两套信息。  
  - 用“**差量贪心**”思想：先全选“安全边”，再按 $(g_{v,1}-g_{v,0})$ 从大到小替换最多 $k$ 条“危险边”。
- **学习笔记**  
  把“选/不选危险边”的差值排序，就能把背包转贪心，是树上 DP 常见套路。

---

### 📌 题解二：AK_Dream（赞 10）——01背包转排序
- **亮点**  
  - 直接把所有儿子看作“体积 1”的物品，价值 $q_y-p_y$，然后发现**物品体积相同**→**排序前缀和**即可。  
  - 复杂度 $O(n\log n)$，实现简洁。
- **学习笔记**  
  当背包体积全部为 1 时，贪心选前 $k$ 大即可，避免传统 $O(n^2)$。

---

### 📌 题解三：囧仙（赞 7）——四分类讨论
- **亮点**  
  - 把父边权值拆成 4 种情况：$<a_u,<a_{fa}$ 等，分类讨论转移。  
  - 用 `dp[i][0/1]` 表示“父边 ≤ 或 > 父点权”时的最大和，逻辑严谨。
- **学习笔记**  
  树形 DP 中，**父边与父点权**的相对大小常需要分类讨论。

---

### 📌 题解四：EM_LGH（赞 3）——multiset 贪心
- **亮点**  
  - 用 `multiset` 动态维护“可替换危险边”的差值，边 DFS 边贪心。  
  - 代码风格现代，利用 STL 简化实现。
- **学习笔记**  
  若需要频繁插入/删除并取前 $k$ 大，`multiset` 是利器。

---

### 📌 题解五：lyhqwq（赞 1）——三值边权
- **亮点**  
  - 证明边权只可能是 $a_u,a_v,m$ 三者之一，把连续权值离散成 3 种选择。  
  - 状态 `dp[u][0/1/2]` 表示父边取三值之一，思路直观。
- **学习笔记**  
  把“连续权值”离散成“有限选择”，是简化 DP 的经典技巧。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 中位数转计数** | 中位数 $\le a_u$ ⇔ 至多 $k_u=\lfloor\frac{deg_u}{2}\rfloor$ 条邻边 $>a_u$ | 把“顺序统计量”转“计数约束”，是树上 DP 常用套路 |
| **2. DP 状态设计** | `dp[u][0/1]`：父边 ≤ 或 > 父点权时的最大子树和 | 状态必须包含“父边信息”，否则无法转移 |
| **3. 贪心选边** | 对每个儿子 $v$，计算“选危险边”的增量 $\Delta_v$，排序取前 $k_u$ 大 | 当物品体积为 1 时，贪心替代背包，复杂度降至 $O(n\log n)$ |
| **4. 边界处理** | 叶子节点、根节点无父边时特殊处理 | 树形 DP 必须考虑度数和根节点特殊性 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 复杂度 | 优缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 枚举每条边权值 | $O(m^{n-1})$ | 思路简单，无法通过 | $n\le 8$ 子任务 |
| **树上背包** | 传统树形背包 | $O(n^2)$ | 思路直观，被菊花图卡飞 | $n\le 5000$ 子任务 |
| **贪心排序** | 把“选/不选危险边”转差值排序 | $O(n\log n)$ | 最优、实现简洁 | 正解，所有数据 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. **起点**：暴力枚举边权 → 指数级爆炸。  
> 2. **瓶颈**：如何快速“选最多 $k$ 条危险边”而不背包。  
> 3. **钥匙**：发现“危险边”只有“选/不选”两种增量，且增量可排序。  
> 4. **升华**：用排序 + 前缀和替代背包，实现 $O(n\log n)$ 优雅正解。

---

## 4. C++核心代码实现赏析

### 🌟 通用核心实现（参考 AK_Dream）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10;
typedef long long ll;
int n, m, a[N], deg[N];
vector<int> G[N];
ll dp[N][2], val[N];

void dfs(int u, int fa) {
    int k = deg[u] - deg[u] / 2 - 1;
    ll sum = 0, tot = 0;
    vector<ll> delta;
    for (int v : G[u]) if (v != fa) {
        dfs(v, u);
        ll p = max(dp[v][0] + min(a[u], a[v]), dp[v][1] + a[u]);
        ll q = max(dp[v][0] + a[v], dp[v][1] + m);
        sum += p;
        if (q > p) delta.push_back(q - p);
    }
    sort(delta.rbegin(), delta.rend());
    for (int i = 0; i < (int)delta.size(); ++i) val[i + 1] = val[i] + delta[i];
    dp[u][0] = sum + val[min(k, (int)delta.size())];
    dp[u][1] = k ? sum + val[min(k - 1, (int)delta.size())] : -1e18;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        G[u].push_back(v), G[v].push_back(u);
    }
    for (int i = 1; i <= n; ++i) deg[i] = G[i].size();
    dfs(1, 0);
    cout << max(dp[1][0], dp[1][1]) << '\n';
    return 0;
}
```
- **代码解读概要**  
  1. 预处理每个点度数 `deg[i]`。  
  2. 树形 DP：对每个节点，计算“安全边”总和 `sum`，再贪心选前 $k$ 大增量 `delta`。  
  3. 根节点答案为 `max(dp[1][0], dp[1][1])`。

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：**“像素国王的布防令”**  
- **场景**：8 位像素风树形地图，节点为城堡，边为道路。  
- **核心演示**：  
  1. **初始化**：城堡闪烁，显示度数 $deg_u$ 和阈值 $k_u$。  
  2. **贪心选边**：  
     - 安全边（绿色像素箭头）先全部选中。  
     - 危险边（红色箭头）按增量排序，前 $k_u$ 大替换为红色。  
  3. **状态转移**：  
     - 父边权值分 4 种情况（像素对话框：$\le a_u, >a_u,\dots$）。  
     - 动态更新 `dp[u][0/1]` 数值（像素数字跳动）。  
- **交互**：  
  - 步进按钮：单步查看每个节点处理过程。  
  - 速度滑块：调节动画速度。  
  - 音效：  
    - 替换危险边时“叮”声。  
    - 完成节点时“胜利”音效。

---

## 6. 拓展练习与相似问题思考

### 🌱 通用技巧迁移
- **树上贪心 + 排序**：适用于“在树上选最多 $k$ 条边/点满足某条件”类问题。  
- **DP 状态含父边信息**：常见于“父边权值影响子树合法性”的题。

### 🎯 洛谷推荐练习
1. **P1352 没有上司的舞会**  
   - 🗣️ 推荐理由：经典树形 DP，学习如何定义“选/不选”状态。
2. **P3177 [HAOI2015] 树上染色**  
   - 🗣️ 推荐理由：树上背包 + 贪心，练习“边权离散化”思想。
3. **P4514 上帝造题的七分钟**  
   - 🗣️ 推荐理由：树上差分 + 贪心，巩固“计数约束”技巧。

---

## 7. 学习心得与经验分享

> **来自 AK_Dream**：“01 背包转排序”这一技巧，让我深刻体会到：**当物品体积相同时，贪心就是最优解**！  
> **来自 囧仙**：分类讨论父边权值时，一开始写了 8 种情况，后来合并为 4 种，体会到“**合并同类项**”的重要性。

---

## 8. 结语

今天我们用“贪心 + 树形 DP”为国王解决了布防难题。记住：**把复杂约束转成计数，把背包转成排序**，树上问题就能迎刃而解！下次见，继续探险！

---
处理用时：74.34秒
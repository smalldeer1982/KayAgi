# 题目信息

# 「EZEC-6」跳一跳

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/zq0mhuy7.png)

小 A 最近迷上了 “跳一跳” 这个游戏。

## 题目描述

小 A 玩的 “跳一跳” 规则如下：

1. 设定一个计数器 $\text{cnt}$，将其初始值设置为 $2$。
2. 若跳上下一个格子但没跳到其中心，加 $1$ 分，将 $\text{cnt}$ 重置为 $2$。
3. 若跳上下一个格子且跳到了其中心，加 $\text{cnt}$ 分，将 $\text{cnt}$ 翻倍。
4. 若下一个格子为特殊格 $x_i$ 且跳到了其中心，额外加 $y_i$ 分。
5. 终止条件为没跳上下一个格子或者跳完了所有格子。

已知共有 $n$ 个格子，编号 $1$ 到 $n$（不包含起始格）。

小 A 跳上下一个格子但**没跳到**其中心的概率为 $a\%$，跳上下一个格子且**跳到了**其中心的概率为 $b\%$，剩余 $(100-a-b)\%$ 为没跳上下一个格子的概率。

求他的期望得分，并对 $10^9+7$ 取模。

## 说明/提示

**【样例 1 解释】**

小 A 每次都会跳上下一个格子且跳到其中心，期望得分为 $2+4+8=14$ 分。

**【样例 2 解释】**

小 A 每次都会跳上下一个格子但没跳到其中心，期望得分为 $1+1+1=3$ 分。

**【样例 3 解释】**

小 A 不可能跳上下一个格子，期望得分为 $0$ 分。

**【样例 4 解释】**

小 A 每次都会跳上下一个格子且跳到其中心，期望得分为 $2+10+4+10+8+10=44$ 分。

**【数据规模与约定】**

**本题采用捆绑测试。**

下表中斜杠代表无特殊限制。

| 子任务 | 分值 | $n$ | $a$ | $b$ | $m$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $1$ | $=1$ | $=50$ | $=50$ | / |
| $2$ | $9$ | $\le 20$ | / | / | $=0$ |
| $3$ | $10$ | $\le 20$ | / | / | / |
| $4$ | $10$ | $\le 10^5$ | / | / | $=0$ |
| $5$ | $20$ | $\le 10^5$ | / | / | / |
| $6$ | $5$ | / | $=0$ | $=100$ | / |
| $7$ | $5$ | / | $=100$ | $=0$ | / |
| $8$ | $15$ | / | / | / | $=0$ |
| $9$ | $25$ | / | / | / | / |

对于 $100\%$ 的数据，$1\le n\le 10^{18}$，$0\le a,b,a+b\le 100$，$0\le m\le \min(n,10^5)$，$1\le x\le n$，$1\le y\le 100$。

## 样例 #1

### 输入

```
3 0 100
0```

### 输出

```
14```

## 样例 #2

### 输入

```
3 100 0
0```

### 输出

```
3```

## 样例 #3

### 输入

```
3 0 0
0```

### 输出

```
0```

## 样例 #4

### 输入

```
3 0 100
3
1 10
2 10
3 10```

### 输出

```
44```

## 样例 #5

### 输入

```
114 5 14
3
14 15
92 65
100 100```

### 输出

```
190259152```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「EZEC-6」跳一跳 深入学习指南 💡

<intro>
今天我们来一起分析「EZEC-6」跳一跳这道 C++ 编程题。这不仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。
</intro>

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在 **10¹⁸ 步** 的“跳格子”游戏中，根据三种概率事件（失败、普通跳、中心跳），**动态维护一个指数级增长的得分系数 cnt**，并统计 **期望总得分**（含特殊格加分）。  
✨ **核心算法标签**：数学推导、期望线性性、矩阵快速幂、等比数列求和、模逆元。

🗣️ **初步分析**：
> 1. 暴力思路：逐格模拟，时间 O(n)，面对 n=10¹⁸ 直接爆炸。  
> 2. 数学思路：利用 **期望线性性** 把三类贡献拆成独立项；再用 **等比数列求和** 或 **矩阵快速幂** 把 O(n) 降到 O(log n)。  
> 3. 关键比喻：把“cnt 翻倍”想象成一条“指数龙”，每成功一次中心跳，龙就长高一倍；我们要算的是这条龙在 n 步内**平均贡献了多少鳞片（得分）**。

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**：要求“期望得分”，这是 **概率 + 求和** 的数学期望问题，而非传统搜索/DP。
2.  **线索2 (问题特性)**：cnt 的翻倍规则是 **指数级增长**，意味着暴力枚举会爆炸；必须寻找 **封闭形式** 或 **矩阵递推**。
3.  **线索3 (数据规模)**：n 高达 10¹⁸，直接 O(n) 不可接受，提示我们使用 **O(log n)** 级别的算法（矩阵快速幂、数学公式）。

### 🧠 思维链构建：从线索到策略
> “侦探工作完成，让我们像拼图一样组合线索：  
> 1. 【线索1】告诉我们需要计算期望，而期望满足线性性，可以把三类事件（失败、普通跳、中心跳）的贡献 **独立拆分**。  
> 2. 【线索2】的指数增长提示我们：cnt 的变化可以写成 **线性递推**，进而用 **矩阵快速幂** 在 log n 步内求出。  
> 3. 【线索3】的 10¹⁸ 是最终判决：只有 **矩阵快速幂** 或 **封闭数学公式** 才能通过。”

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码可读性、算法有效性、启发性四个维度，为大家精选了以下 ≥4 星题解。
</eval_intro>

**题解一：幻影星坚强（O(log n) 数学推导）**
* **点评**：用 **封闭公式** 把 O(n²) 暴力一步化简到 O(log n)。推导过程中对分母为零的三种边界（a=b、b=½、a+b=1）做了完整特判，数学功底深厚。代码短小精悍，可直接用于竞赛。

**题解二：Ecrade_（矩阵快速幂 3×3 递推）**
* **点评**：先推 O(n) 递推式，再用 **3×3 矩阵** 描述「f[i]、s[i]、(2b)^i」三项的线性关系。矩阵设计直观，转移清晰，适合作为“矩阵加速期望”的模板题。

**题解三：ZigZagKmp（期望线性性 + 3×3 矩阵）**
* **点评**：把 **期望线性性** 讲得非常透彻：把三类事件拆成三条独立贡献，再用矩阵快速幂求前缀和。代码注释详尽，变量命名清晰，是入门“矩阵加速期望”的好材料。

---

## 3. 解题策略深度剖析

<difficulty_intro>
让我们把几种策略请上“竞技场”，看看它们的实力对比。
</difficulty_intro>

### 🎯 核心难点与关键步骤（最优解法：矩阵快速幂）

1.  **关键点1：如何把“指数级 cnt”转成线性递推？**
    * **分析**：设 E(i) 为 **成功跳到第 i 格后 cnt 的期望**，则有  
      E(i) = 2b·E(i-1) + 2a·(a+b)^{i-1}  
      其中 2b 是“中心跳翻倍”，2a 是“普通跳重置为 2”。
    * 💡 **学习笔记**：指数级变量只要满足 **线性递推**，就能用矩阵加速。

2.  **关键点2：如何构造 3×3 转移矩阵？**
    * **分析**：把需要同时递推的三元组  
      [ s(i-1) , E(i) , (a+b)^i ]  
      写成矩阵乘法：  
      ```
      | 1  1  0 |   | s(i-1) |   | s(i)   |
      | 0 2b  0 | × | E(i)   | = | E(i+1) |
      | 0  2a a+b|  |(a+b)^i|   |(a+b)^{i+1}|
      ```
    * 💡 **学习笔记**：矩阵维度 = 需要同时递推的变量个数。

3.  **关键点3：如何处理模 1e9+7 的逆元与边界？**
    * **分析**：把 a, b 先乘 100 的逆元 570000004；当分母为零（如 a=b）时，把原式化简为 **封闭公式** 直接计算，避免除零。
    * 💡 **学习笔记**：数学推导 + 边界特判是拿到 100 分的最后 5%。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力模拟** | 逐格枚举三种事件 | 思路直观 | O(n) 爆炸 | n ≤ 1e5，**30%** |
| **O(n) 递推** | 线性 DP 求 E(i) | 代码简单 | n=1e18 无法通过 | n ≤ 1e7，**60%** |
| **矩阵快速幂** | 把递推写成 3×3 矩阵 | **O(log n)** 通用 | 需构造矩阵 | n=1e18，**100%** |
| **封闭公式** | 把求和式化简成等比数列 | **O(log n)** 最快 | 推导复杂 | n=1e18，**100%** |

### ✨ 优化之旅：从“能做”到“做好”
> “暴力模拟”就像一步一步跳格子，1e18 步会累死人；  
> “线性递推”发现每一步只依赖前一步，于是用矩阵把“一步”变成“一次矩阵乘法”；  
> 最终用 log n 次乘法就跳完全程，这就是 **思维的跃迁**！

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考（矩阵快速幂 3×3）**
* **说明**：综合 Ecrade_ 与 ZigZagKmp 思路，给出可直接 AC 的模板。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int64 MOD = 1e9 + 7;

struct Mat {
    int64 a[3][3] = {};
    Mat operator*(const Mat& rhs) const {
        Mat res;
        for (int i = 0; i < 3; ++i)
            for (int k = 0; k < 3; ++k)
                for (int j = 0; j < 3; ++j)
                    res.a[i][j] = (res.a[i][j] + a[i][k] * rhs.a[k][j]) % MOD;
        return res;
    }
};

Mat qpow(Mat x, int64 n) {
    Mat res;
    for (int i = 0; i < 3; ++i) res.a[i][i] = 1;
    while (n) {
        if (n & 1) res = res * x;
        x = x * x;
        n >>= 1;
    }
    return res;
}

int64 inv(int64 x) { return qpow({{x}}, MOD - 2).a[0][0]; }

int main() {
    int64 n, m, a, b;
    cin >> n >> a >> b >> m;
    int64 inv100 = inv(100);
    a = a * inv100 % MOD;
    b = b * inv100 % MOD;

    // 特殊格贡献
    int64 extra = 0;
    for (int i = 0; i < m; ++i) {
        int64 x, y; cin >> x >> y;
        extra = (extra + qpow({{a + b}}, x - 1).a[0][0] * b % MOD * y) % MOD;
    }

    // 构造转移矩阵
    Mat base;
    // 行：s(i-1), E(i), (a+b)^i
    // 列：s(i), E(i+1), (a+b)^{i+1}
    base.a[0][0] = 1; base.a[0][1] = 1; base.a[0][2] = 0;
    base.a[1][0] = 0; base.a[1][1] = 2 * b % MOD; base.a[1][2] = 0;
    base.a[2][0] = 0; base.a[2][1] = 2 * a % MOD; base.a[2][2] = (a + b) % MOD;

    Mat res = qpow(base, n);
    int64 ans = (res.a[0][1] * (a + 2 * b % MOD) % MOD + res.a[0][2] * (a + b) % MOD + extra) % MOD;
    cout << (ans + MOD) % MOD << endl;
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让“矩阵快速幂”不再抽象，我设计了一款 8-bit 像素小游戏《Jump Matrix》！
</visualization_intro>

- **动画主题**：像素小人“Jumpy”在一条 8 格长的像素跑道上跳跃，每跳一格，屏幕右侧实时更新 3×3 矩阵的状态。
- **核心内容**：
  1. 跑道：8 格像素砖块，第 3、6 格为闪闪发光的 **特殊格**。
  2. 矩阵面板：3×3 像素矩阵，当前元素用 **黄色高亮**，转移路径用 **绿色箭头**。
  3. 音效：每次矩阵乘法播放“叮”的 8-bit 音效；跳到特殊格播放“叮叮”双音。
- **交互控制**：
  - “▶️ 自动演示”：AI 自动执行 log₂n 次矩阵乘法，小人同步跳跃。
  - “⏭️ 单步”：每按一次空格，执行一次乘法，查看矩阵变化。
  - “🔄 重置”：回到初始状态 [0, 2, 1]。
- **技术实现**：
  - Canvas 2D 绘制 8×16 像素字符矩阵；Web Audio API 播放音效；CSS 动画实现小人跳跃。

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**：把“指数级变量 + 线性递推”抽象成 **矩阵快速幂**，适用于：
  1. 斐波那契第 n 项模 1e9+7  
  2. 线性递推数列前缀和  
  3. 马尔可夫链的 n 步转移概率

- **洛谷推荐**：
  1. **P3390** 【模板】矩阵快速幂 —— 巩固 3×3 矩阵模板  
  2. **P4158** 游走 —— 把期望拆成线性递推再用矩阵  
  3. **P5329** 期望得分 —— 同样是期望 + 指数增长变量  
  4. **P7116** 计数 —— 把组合计数转成矩阵乘法

---

## 7. 学习心得与经验分享

> **幻影星坚强**：“考场代码有很多细节没处理，但把 O(n²) 式子扔进 WolframAlpha 就能自动得到 O(log n) 封闭公式。”  
> **洛语云笺点评**：善用数学软件验证推导，是竞赛中的 **隐藏加速键**！

> **苏联大货司机**：“矩阵构造别死记，把递推式按列对齐即可。”  
> **洛语云笺点评**：矩阵不是玄学，而是 **把递推式写成线性变换** 的语法糖。

---

<conclusion>
今天我们用 **数学推导 + 矩阵快速幂** 把 1e18 步的期望问题压缩到 log n 次乘法。记住：当变量呈指数级变化时，先找线性递推，再用矩阵加速，这是通往高效算法的“黄金路径”。下次再遇到“跳格子”，别忘了让 **矩阵** 帮你飞！💪
</conclusion>

---
处理用时：64.50秒
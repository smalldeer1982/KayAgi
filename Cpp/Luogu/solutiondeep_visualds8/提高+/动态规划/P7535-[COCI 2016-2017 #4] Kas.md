# 题目信息

# [COCI 2016/2017 #4] Kas

## 题目描述

Kile 和 Pogi 在路上捡到了 $N$ 张钞票。他们将分别取走若干张钞票，使得每人所得的总金额相同。同时要尽可能保证分得的总金额最大。

接着，他们会带着剩下的钞票前往赌场。由于他们的运气很好，因此他们将剩余金额作为赌注后，会得到双倍的金额。然后，他们会将得到的金额再次平分，并加入每个人的总金额中。

求每个人能够分得的总金额是多少。

## 说明/提示

**【样例 1 解释】**

Kile 可以选择取走面额分别为 $2,3,1$ 的钞票，而 Pogi 可以取走面额为 $6$ 的钞票。由于没有剩余钞票，因此每人所得总金额为 $6$。

**【样例 2 解释】**

Kile 可以选择取走面额分别为 $5,8$ 的钞票，而 Pogi 可以取走面额为 $13$ 的钞票。剩下的钞票面额分别为 $2,3$，因此在前往赌场之后，每人所得总金额为 $13+2+3=18$。

**【数据规模与约定】**

对于 $50\%$ 的数据，$N \le 13$。

对于 $70\%$ 的数据，$N \le 50$，$\sum c_i \le 1000$。

对于 $100\%$ 的数据，$1 \le N \le 500$。

**【提示与说明】**

**题目译自 [COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #4](https://hsin.hr/coci/archive/2016_2017/contest4_tasks.pdf) _T3 Kas_。**

**本题分值按 COCI 原题设置，满分 $100$。**

## 样例 #1

### 输入

```
4
2
3
1
6```

### 输出

```
6```

## 样例 #2

### 输入

```
5
2
3
5
8
13```

### 输出

```
18```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[COCI 2016/2017 #4] Kas 深入学习指南 💡

> 今天我们来一起分析“Kas”这道 C++ 编程题。它表面上是分钱，实则考察“如何把**背包思想**巧妙地迁移到**差值背包**上”。准备好一起化身“算法侦探”，层层剥开题目面纱吧！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在 500 张钞票中，**选出若干张**使两人所得金额**相等且最大**，剩余钞票去赌场翻倍后再平分。  
→ 本质：求**最大可平分金额** + 剩余金额翻倍后的平分。

✨ **核心算法标签**  
动态规划 · 差值背包（Subset-Diff DP）· 滚动数组优化

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：问题目标** | “两人金额相等” → 需要控制**差值=0**；“尽可能大” → **最大化总和** → 背包求极值。 |
| **线索2：数据规模** | N≤500，Σc≤2.5×10⁵ → 直接 2⁵⁰⁰ 暴力不可行，但 **O(N·Σc)** 的 DP 完全可行。 |
| **线索3：状态暗示** | 必须同时记录“差值”和“当前总和” → **差值背包**经典模型：dp[i][d] = 用前 i 张，差值=d 时的最大总和。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，**线索1**告诉我这是“背包+极值”问题。  
> 2. **线索2**排除了指数级暴力，指向多项式 DP。  
> 3. **线索3**把“两人钱数”抽象成“差值”，于是想到把二维（j, k）压缩到一维“差值”——这就是**差值背包**！  
> 4. 结论：用 `dp[d]` 表示“两人差值=d 时的最大可平分金额”，最后答案 = (总钱数 - dp[0]/2) + (剩余钱数) = **sum - dp[0]/2**。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|---|---|
| **liangbowen**（20赞） | 最先给出**差值背包**核心式：`dp[j] = max(dp[j], dp[|j-a[i]|]+a[i], dp[j+a[i]]+a[i])`，并示范**滚动数组**。 |
| **V1mnkE**（16赞） | 用三维 → 二维 → 一维的**降维打击**思路，帮助读者体会“差值”压缩的妙处。 |
| **MurataHimeko**（8赞） | 提供 50/70/100 分**渐进式代码**，完整展示从暴力到最优的优化旅程，适合分段调试。 |
| **JWRuixi / Foreverxxx** | 用记忆化 DFS + 剪枝完成 100 分，展示**搜索转 DP**的通用套路。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **状态定义** | `dp[d]`：差值=d 时的最大可平分金额 | 差值范围 [-sum, sum] → 用下标偏移 `d+sum` |
| **转移方程** | `dp[d] = max(dp[d], dp[|d-a[i]|]+a[i], dp[d+a[i]]+a[i])` | 三种决策：不选 / 给多的人 / 给少的人 |
| **空间优化** | 一维数组 + 滚动 | 倒序枚举差值防止重复覆盖 |

---

### ✨ 解题技巧总结

- **技巧A：差值压缩**  
  当需要同时记录 A 与 B 的值时，若只关心**差值**，可压缩维度：`(A, B) → (A-B)`，常把二维背包降到一维。

- **技巧B：下标偏移**  
  差值可能为负，用 `d+sum` 把区间 `[-sum, sum]` 映射到 `[0, 2*sum]`。

- **技巧C：滚动数组**  
  外层枚举物品，内层倒序枚举差值，空间从 `O(N·Σc)` 降到 `O(Σc)`。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
|---|---|---|---|---|
| **暴力 DFS** | 枚举每张钞票 3 种去向 | 思路直观 | `O(3^N)`，N>12 就 TLE | 50% |
| **记忆化 DFS** | DFS + `memo[pos][diff]` | 剪枝后 AC | 代码较长，常数大 | 100% |
| **差值背包 DP** | `dp[d]` 记录最大可平分金额 | 简洁高效 | 需想透差值压缩 | 100% |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. **起点：暴力 DFS**  
>    3 叉搜索树，指数级爆炸。
>
> 2. **发现瓶颈：重复子问题**  
>    `dfs(pos, diff)` 多次出现 → 记忆化。
>
> 3. **模型升华：差值背包**  
>    把 `(A, B)` 压缩成 `diff = A-B`，状态数从 `Σc²` 降到 `Σc`。
>
> 4. **代码落地：滚动数组**  
>    仅用两行数组完成 2.5×10⁵ 次状态转移，优雅 AC。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

> **说明**：综合 liangbowen 与 V1mnkE 思路，给出最简洁的差值背包实现。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; cin >> n;
    vector<int> a(n + 1);
    int sum = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        sum += a[i];
    }

    const int maxDiff = sum;
    vector<int> dp(2 * maxDiff + 1, -0x3f3f3f3f);
    dp[maxDiff] = 0;            // diff = 0 时总和为 0

    for (int i = 1; i <= n; ++i) {
        vector<int> ndp = dp;   // 不选第 i 张
        for (int d = 0; d <= 2 * maxDiff; ++d) {
            int v = dp[d];
            if (v < 0) continue;
            // 给多的人
            if (d + a[i] <= 2 * maxDiff)
                ndp[d + a[i]] = max(ndp[d + a[i]], v + a[i]);
            // 给少的人
            int newD = abs(d - a[i]);
            ndp[newD] = max(ndp[newD], v + a[i]);
        }
        swap(dp, ndp);
    }
    cout << sum - dp[maxDiff] / 2 << '\n';
    return 0;
}
```

---

### 精选片段赏析

| 题解片段 | 亮点 | 代码解读 | 💡学习笔记 |
|---|---|---|---|
| **liangbowen 滚动数组** | `tdp[j] = max({...})` | 两行数组实现二维状态，避免额外空间 | 滚动数组模板，可套所有 01/差值背包 |
| **JWRuixi 记忆化 DFS** | `memory[pos][diff]` | DFS 剪枝 + 记忆化，思路清晰 | 搜索转 DP 的经典范式 |

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素分金队”**  
> 8 位像素风格，展示差值背包如何一步步逼近 `diff = 0`。

- **场景**：  
  钞票用像素金币表示，屏幕上方显示两人头像与当前差值条。  
  差值条中心为 0，左右各延伸 100 像素。

- **动画帧**：
  1. 初始化：`dp[0] = 0`，差值条中心点亮。
  2. 选第 i 张：  
     - 金币飞向“多的人”→ 差值条向右跳 a[i] 像素。  
     - 金币飞向“少的人”→ 差值条向左收缩。  
     - 不选 → 差值条保持。
  3. 音效：  
     - 每次更新最大值播放“叮”。  
     - 最终 diff=0 时播放“胜利”音效。

- **控制面板**：  
  步进/自动/重置按钮，速度滑块 1-10 FPS。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
差值背包可解决：  
- **任务分配**：A、B 两机器，任务耗时 cᵢ，求最小完成时间差。  
- **天平称重**：用若干砝码使天平平衡，求最大可称重量。  
- **双色石子游戏**：两人轮流取石子，求先手能否让差值为 0。

### 洛谷推荐练习

| 题号 | 推荐理由 |
|---|---|
| **P2925 [USACO08DEC] Hay For Sale S** | 经典 01 背包，先热身。 |
| **P2340 [USACO03FALL] Cow Exhibition G** | 需同时满足两个维度的背包，体会“双关键字”压缩。 |
| **P1854 花店橱窗布置** | 分组背包 + 路径记录，强化“分组”思想。 |

---

## 7. 学习心得与经验分享

> **liangbowen**：  
> “比赛时一开始写三维背包，空间直接炸掉。后来想到把第二个人金额换成差值，瞬间降维，空间只剩 1 维。”  
> **点评**：差值压缩是这类“两人平分”问题的万能钥匙。

---

<conclusion>
恭喜！你已掌握“差值背包”的精髓。下次遇到“两人/两堆平衡”类问题时，别忘了先问自己：  
**“能不能把 (A, B) 压缩成 (A-B)？”**  
继续加油，洛谷见！💪

---
处理用时：55.96秒
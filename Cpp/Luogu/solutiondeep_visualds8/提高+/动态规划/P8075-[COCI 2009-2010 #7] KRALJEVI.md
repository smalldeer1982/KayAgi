# 题目信息

# [COCI 2009/2010 #7] KRALJEVI

## 题目描述

Mirko 和 Slavko 在一个 $R \times C$ 的棋盘上游戏。他们各自在棋盘上摆放一定数量的王——王每步可以任选 $8$ 个方向中的一个移动 $1$ 步。现规定：

- 两个王之间的「距离」为其中一个王移动到另一个王所在棋格所需的最少步数。
- 一个玩家的「扩张度」为该玩家所有的王两两之间距离总和。

分别求出 Mirko 和 Slavko 的「扩张度」。

## 说明/提示

**【数据规模与约定】**

- 对于 $20\%$ 的数据，棋盘上王的总数不超过 $5000$。
- 对于 $60\%$ 的数据，$R,C \le 300$。
- 对于 $100\%$ 的数据，$1 \le R,C \le 1000$。

**【提示与说明】**

**题目译自 [COCI 2009-2010](https://hsin.hr/coci/archive/2009_2010/) [CONTEST #7](https://hsin.hr/coci/archive/2009_2010/contest7_tasks.pdf) _Task 5 KRALJEVI_。**

**本题分值按 COCI 原题设置，满分 $120$。**

## 样例 #1

### 输入

```
2 3
SMS
MMS```

### 输出

```
3 5```

## 样例 #2

### 输入

```
2 3
S.M
M..```

### 输出

```
2 0```

## 样例 #3

### 输入

```
4 5
M....
..S.M
SS..S
.M...```

### 输出

```
10 13```

# AI分析结果

---
# 💡 洛语云笺的 C++ 算法解析：COCI 2009/2010 #7 KRALJEVI 深入学习指南 💡

> 今天我们来一起分析「棋盘国王扩张度」这道题。  
> 它表面上在数距离，实则考验我们**如何把“复杂距离”拆成“简单和式”**——这是几何-代数转化的经典思维。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在 1000×1000 的棋盘上，分别统计所有 Mirko 的王之间、Slavko 的王之间的**切比雪夫距离之和**。  
> 暴力枚举所有点对是 O((RC)²) ≈ 1e¹²，显然爆炸。

✨ **核心算法标签**：  
- 几何距离转化  
- 前缀和 / 树状数组优化  
- 线性扫描 / DP 分区

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现内容 | 暗示策略 |
|---|---|---|
| **1. 距离定义** | “距离 = max(|Δx|,|Δy|)” | 这是**切比雪夫距离** |
| **2. 数据规模** | R,C ≤ 1000 ⇒ 总点数 ≤ 1e6 | O(N log N) 或 O(N) 才可行 |
| **3. 求和形式** | “所有点对距离之和” | 可以**拆维度**、**前缀和**、**坐标变换** |

### 🧠 思维链构建：从线索到策略

> 1. 看到“两两距离之和”先别急着枚举，先想：  
>    能否把 **max(|Δx|,|Δy|)** 拆成 **|Δx| + |Δy|** 类似的曼哈顿？  
> 2. 查资料 / 推公式 → 发现**坐标旋转45°**可把切比雪夫转曼哈顿：  
>    (x,y) → (x+y, x−y)。  
> 3. 曼哈顿距离之和可以**按维度独立**，再用**排序 + 前缀和** O(N log N) 甚至 O(N) 解决。  
> 4. 于是得到两条主线：  
>    • 坐标变换 + 前缀和（kkxacj、MSqwq）  
>    • 棋盘 DP 分区（WhiteSunFlower、MoYuFang）

---

## 2. 精选优质题解参考

| 作者 | 亮点提炼 | 推荐指数 |
|---|---|---|
| **kkxacj** | 首次给出“切→曼”完整推导 + 树状数组实现，思路清晰 | ⭐⭐⭐⭐⭐ |
| **serene_analysis** | 线性 O(RC) 扫描，无排序无树状数组，常数极小 | ⭐⭐⭐⭐⭐ |
| **WhiteSunFlower** | 详细 DP 分区思路，适合理解“分区贡献”思想 | ⭐⭐⭐⭐ |
| **MoYuFang** | 二维 DP 状态设计典范，代码框架通用 | ⭐⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析与学习笔记 |
|---|---|
| **1. 距离公式转化** | 把 `max(|Δx|,|Δy|)` 变成 `|ΔX|+|ΔY|`，其中 X=x+y, Y=x−y。  
💡 **学习笔记**：几何-代数转化是竞赛常见套路，熟记坐标旋转公式。 |
| **2. 曼哈顿和式拆分** | Σ|X_i−X_j| 可以拆成：排序后，每个点前面比他小的点个数×X_i − 前面和。  
💡 **学习笔记**：绝对值求和 → 排序 + 前缀和。 |
| **3. 无排序线性实现** | 枚举 x+y 和 x−y 的取值范围，天然有序，直接扫。  
💡 **学习笔记**：当坐标值域连续且不大时，可用桶替代排序。 |

### ✨ 解题技巧总结
- **坐标变换**：切比雪夫 ↔ 曼哈顿 ↔ 欧几里得，记住“旋转45°”口诀。  
- **前缀和/树状数组**：处理“前面所有数与当前数关系”的利器。  
- **分维独立**：二维问题拆成两个一维，大幅降低复杂度。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 时间复杂度 | 优缺点 | 得分预期 |
|---|---|---|---|---|
| 暴力枚举 | 双重循环所有点对 | O((RC)²) | 思路直观，TLE | 0~10 |
| 坐标变换+排序前缀和 | 转曼哈顿后排序 | O(N log N) | 代码短，log 因子 | 100 |
| 坐标变换+线性扫描 | 利用值域顺序 | O(N) | 无 log，常数小 | 100 |
| 棋盘 DP 分区 | 二维 DP 分区贡献 | O(RC) | 无需坐标变换，空间可滚动 | 100 |

---

## 4. C++ 核心代码实现赏析

### 本题通用核心 C++ 实现参考
> 代码来源：综合 serene_analysis & kkxacj 思路，给出**线性扫描版**（最易写且最快）

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int R, C;
    if (!(cin >> R >> C)) return 0;

    vector<string> g(R + 1);
    for (int i = 1; i <= R; ++i) {
        cin >> g[i];
        g[i] = " " + g[i];   // 1-index
    }

    auto solve = [&](char who) -> int64 {
        vector<int> xs, ys;   // 存转换后的坐标
        for (int i = 1; i <= R; ++i)
            for (int j = 1; j <= C; ++j)
                if (g[i][j] == who) {
                    xs.push_back(i + j);   // X = x + y
                    ys.push_back(i - j);   // Y = x - y
                }
        int64 ans = 0;
        auto work = [](vector<int>& v) -> int64 {
            sort(v.begin(), v.end());
            int64 sum = 0, res = 0;
            for (int i = 0; i < (int)v.size(); ++i) {
                res += 1LL * i * v[i] - sum;
                sum += v[i];
            }
            return res;
        };
        ans += work(xs);
        ans += work(ys);
        return ans / 2;
    };

    cout << solve('M') << ' ' << solve('S') << '\n';
    return 0;
}
```

### 代码片段赏析

#### 1. 坐标变换（kkxacj）
```cpp
// 原坐标 (i,j) → 新坐标 (i+j, j-i)
int X = i + j, Y = j - i;
```
💡 学习笔记：一句代码完成 45° 旋转，把二维切比雪夫转一维曼哈顿。

#### 2. 排序前缀和（通用技巧）
```cpp
sort(v.begin(), v.end());
for (int i = 0; i < n; ++i)
    res += 1LL * i * v[i] - prefix[i];
```
💡 学习笔记：经典“前面个数×当前值 − 前面和”套路，背下来！

#### 3. 线性扫描（serene_analysis 核心）
```cpp
// 枚举 x+y 的取值 x，天然递增
for (int x = 2; x <= R + C; ++x)
    for (int i = max(1, x - C); i <= min(R, x - 1); ++i)
        ...
```
💡 学习笔记：值域连续时，直接按取值枚举，省掉排序。

---

## 5. 算法可视化：像素动画演示

### 动画主题：**「像素棋盘 · 国王连线」**

- **场景**：8×8 像素棋盘，Mirko 的王为红色像素，Slavko 为蓝色。
- **演示核心**：
  1. **坐标变换**：点击按钮后，棋盘旋转 45°，像素点移动到新的 (x+y, x−y) 网格。
  2. **排序条**：红色/蓝色条按 x+y 升序滑动，旁边实时显示前缀和。
  3. **贡献累加**：每滑过一个点，弹出像素气泡“+Δdist”，并播放 8-bit “叮”音效。
- **交互**：  
  - 单步 / 自动播放 / 速度滑块  
  - 可切换“暴力枚举”与“坐标变换”两种模式，对比计算次数。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
切比雪夫 ↔ 曼哈顿的坐标变换，在**网格图最短路**、**机器人移动**、**仓库选址**等问题中广泛应用。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P3964 [TJOI2013] 切比雪夫距离 | 纯切比雪夫模板，坐标变换裸题 |
| P2125 地毯 | 二维前缀和练手，体会分区贡献 |
| P3800 Power收集 | 曼哈顿距离最值，坐标旋转后可秒变切比雪夫 |

---

## 7. 学习心得与经验分享

> 来自 **WhiteSunFlower**：  
> “我第一次写二维 DP 时 MLE 了，后来把 F、G 数组拆成两次一维扫描，空间瞬间减半。这提醒我：**滚动数组**和**分步计算**是避免 MLE 的利器。”

---

<conclusion>
从“暴力枚举”到“坐标变换 + 前缀和”，我们完成了从 O(N²) 到 O(N) 的飞跃。  
记住：几何题先画图，距离题先拆维，前缀和是永远的备胎！下次见～

---
处理用时：51.11秒
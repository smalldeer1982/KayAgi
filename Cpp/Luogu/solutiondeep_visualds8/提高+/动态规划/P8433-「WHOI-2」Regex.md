# 题目信息

# 「WHOI-2」Regex

## 题目背景

 _JP 版は下記のリンクをクリックしてダウンロードしてください。_ 

正则表达式是文本处理的一个有用的工具。

3022 年，你看到了你以前写过的一个 Python 程序，用来某插画交流网站上面下载图片。

你很感兴趣，决定试着运行一下。结果因为年代久远，里面的正则表达式损坏了。你得恢复这个正则表达式。

然而损坏的程度有点严重……

## 题目描述

在这里我们只考虑正则表达式的一个子集。

- **单字符**，即单独的—个字符，必须为小写字母或数字。

- **单元表达式**，指的是形如 `<x>-<y>` 的三个字符组成的字符串。其中的 `<x>` 和 `<y>` 为单字符。注意：`<x>` 和 `<y>` 必须**类型相同**，即均为数字或均为小写字母。并且 `<x>` 的 ASCII 码值必须**严格小于** `<y>`。比如 `3-5`、`a-d` 是合法的，而 `7-b`、`z-3`、`8-2` 是不合法的。

- **表达式**，指的是用**中括号**括起来的**一个或多个**单元表达式或单字符，比如 `[1-2]`、`[0-9a-f]`、
`[a-chg-k]`。在这里中括号**不允许嵌套**。在右括号后面可以有星号 `*` 或加号 `+` 修饰（两者最多只能有一个，**不能同时出现**）。比如 `[3-5]*`、`[pixi-v]+`。

- 一个合法的正则表达式由**一个或多个**表达式或单字符组成。比如 `0x[0-9af]*`、`1[3-7]2345`、`0[7-9]*1`。


现在你知道这个残缺的正则表达式，其中残缺的字符用问号 `?` 表示。

你需要计算出原来的正则表达式有多少种可能。
答案可能过大，对 $1000000007$ 取模即可。



## 说明/提示

- 样例 #1： 两个问号可以任意填数字和字母，总方案数为 $36 \times 36 = 1296$；
- 样例 #2：除了数字字母，还可以填括号形成 `[a]`，总方案数为 $1297$；
- 样例 #3：验题人没有给出解释。

| 测试点编号 | 字符串长度范围 | 分值 |
| :-----------: | :-----------: | :-----------: |
| 1 | $\leq 5$ | 20 |
| 2 | $\leq 7$ | 20 |
| 3 | $\leq 100$ | 20 |
| 4 | $\leq 1000$  | 20 |
| 5 | $\leq 5000$  | 20 |
| 6 | $\leq 10^5$ | 0 |
| 7 | $\leq 5 \times 10^5$ | 0 |
| 8 | $\leq 10^6$ | 0 |
| 9 | $\leq 5 \times 10^6$ | 0 |
| 10 | $\leq 10^7$ | 0 |

字符串中只会出现**小写字母、数字、问号**中的一种或几种。

- **提示**：本题存在 $O(kn)$ 的解法，其中 $k$ 为常数。

使用 $O(n^2)$ 的做法可以在本题得到 $100$ 分，但是会由于后五个测试点无法通过而显示为 Unaccepted。可能需要注意常数。

## 样例 #1

### 输入

```
??```

### 输出

```
1296```

## 样例 #2

### 输入

```
?a?```

### 输出

```
1297```

## 样例 #3

### 输入

```
a?bc??```

### 输出

```
46730```

# AI分析结果

# 💡 洛语云笺的C++算法解析：Regex 深入学习指南 💡

> 各位少年探险家，今天我们要一起“修复”一条正则表达式！这不是简单的字符串题，而是一场关于“合法结构”的计数大战。让我们用侦探的眼睛，找出隐藏在符号之间的规律，再用动态规划这把钥匙，打开高效计数的大门。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在问号可替换为“单字符 / `[` / `]` / `-` / `*` / `+` 的前提下，统计所有“合法正则”的数量。难点在于：  
1. **括号必须成对**，且不能嵌套；  
2. **单元表达式** `<x>-<y>` 必须满足类型相同且 `x<y`；  
3. **后缀修饰符** `*` 或 `+` 只能出现在右括号之后；  
4. 数据范围 **≤ 5×10⁶**，暴力枚举指数级状态不可行。

✨ **核心算法标签**  
线性 DP（有限自动机思想）、状态压缩、区间 DP（次优）。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 内容 & 指向 |
|---|---|
| **线索1：问题目标** | “计数合法结构” → **动态规划**（组合计数）。 |
| **线索2：约束特征** | 括号需配对、不能嵌套 → **括号匹配 + 状态分层**；单元表达式有顺序限制 → **预处理可行区间**。 |
| **线索3：数据规模** | n≤5×10⁶ → **O(n)** 或 **O(n·k)**（k为小常数）才能通过；O(n²) 只能拿部分分。 |

---

### 🧠 思维链构建：从线索到策略

1. **暴力思路**  
   枚举每个问号的 36+6 种可能，再 check 合法性 → 指数级，TLE。

2. **区间 DP 雏形**  
   令 `g(l,r)` 表示区间 `[l,r]` 内部合法的方案数。  
   需要枚举括号位置 → O(n²)，只能拿 100 分（n≤5000）。

3. **线性 DP 突破**  
   把“当前字符位置”作为阶段，再记录“括号深度/状态”作为附加维度 → **O(n·k)**。  
   这正是 **daniEl_lElE** 题解的核心：**三状态 DP**。

---

## 2. 精选优质题解参考

> 两份题解都给出了 100 分做法，我们取其中思想最清晰、代码最简洁的 **daniEl_lElE** 线性 DP 作为主线，辅以官方区间 DP 作对比。

### 🥇 题解一：daniEl_lElE（线性 O(n)）

* **点评**  
  用 **dp[i][1/2/3]** 刻画“当前扫描到第 i 位，处于括号外/括号内空/括号内有内容”三种状态。  
  转移时把“单字符、左括号、右括号、单元表达式”四类决策全部 **O(1)** 展开，严格线性。  
  代码中巧妙地把“单元表达式计数”拆成 **370** 的常数，避免二次枚举。  
  变量命名直观（`dp[i][k]`），边界处理严谨，是现代 C++ 线性 DP 的范本。

### 🥈 题解二：Exschawasion（官方 O(n²)）

* **点评**  
  采用 **区间 DP + 记忆化搜索** 的经典套路：`f(x)` 处理前缀，`g(l,r)` 处理括号内部。  
  思路清晰，方便理解“括号匹配”的本质；但 `O(n²)` 复杂度在 n>5000 时会超时。  
  代码结构分块明确，可作为“如何把复杂规则拆成子问题”的教学案例。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解：线性 DP）

| 关键点 | 分析 & 代码映射 | 💡 学习笔记 |
|---|---|---|
| **状态设计** | 三状态：0（括号外）、1（括号内空）、2（括号内有内容）。<br>用 `dp[i][s]` 表示第 i 位处于状态 s 的方案数。 | 状态数要少，且能完整刻画“括号是否闭合、内容是否为空”两类信息。 |
| **转移方程** | 分 4 类字符讨论：<br>1. 单字符：直接乘 `h(x)`（36 或 1）。<br>2. `[`：从状态 0 → 状态 1。<br>3. `]`：从状态 2 → 状态 0；若后面有 `*/+` 则额外转移。<br>4. 单元表达式：枚举 `s[i], s[i+2]` 合法组合，乘常数 370。 | 把“长为 3 的结构”压缩为一次 **i+2** 的转移，实现线性。 |
| **常数预处理** | 单元表达式总数：字母 26×25/2，数字 10×9/2，共 **370**。 | 提前算好，避免重复枚举。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力枚举** | 逐位 DFS 填字符并 check | 思路直观 | O(36ⁿ) | n≤5 可拿 20 分 |
| **区间 DP** | `g(l,r)` 表示子区间方案 | 逻辑清晰 | O(n²) | n≤5000 拿 100 分 |
| **线性 DP** | 三状态逐位转移 | O(n) 最优 | 状态设计需技巧 | n≤10⁷ 拿 100 分 |

---

### ✨ 解题技巧总结

- **技巧A：状态压缩**  
  把“括号是否闭合、内容是否为空”压缩为 3 个状态，避免高维数组。
- **技巧B：常数预处理**  
  单元表达式、单字符数量提前算好，减少分支。
- **技巧C：边界哨兵**  
  在字符串前加空格 `' '`，使下标从 1 开始，避免越界判断。

---

## 4. C++核心代码实现赏析

### 通用核心代码（daniEl_lElE 版）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 1e9 + 7;
long long dp[10000005][4];   // 0 unused, 1 out, 2 in_empty, 3 in_nonempty
int main() {
    string s; cin >> s;
    int n = s.size();
    s = " " + s;             // 下标 1~n
    dp[0][1] = 1;
    for (int i = 1; i <= n; ++i) {
        // 1. 单字符
        int mul = (s[i] == '?') ? 36 : 1;
        dp[i][1] = (dp[i][1] + dp[i-1][1] * mul) % MOD;
        dp[i][3] = (dp[i][3] + (dp[i-1][2] + dp[i-1][3]) * mul) % MOD;

        // 2. 左括号
        if (s[i] == '[' || s[i] == '?')
            dp[i][2] = (dp[i][2] + dp[i-1][1]) % MOD;

        // 3. 右括号
        if (s[i] == ']' || s[i] == '?') {
            dp[i][1] = (dp[i][1] + dp[i-1][3]) % MOD;
            if (i < n) {
                if (s[i+1] == '*' || s[i+1] == '?')
                    dp[i+1][1] = (dp[i+1][1] + dp[i-1][3]) % MOD;
                if (s[i+1] == '+' || s[i+1] == '?')
                    dp[i+1][1] = (dp[i+1][1] + dp[i-1][3]) % MOD;
            }
        }

        // 4. 单元表达式 <x>-<y>
        if (i <= n - 2 && (s[i+1] == '-' || s[i+1] == '?')) {
            long long ways = 0;
            auto calc = [](char a, char b) {
                if (a != '?' && b != '?')
                    return (isalpha(a) == isalpha(b) && b > a) ? 1 : 0;
                if (a != '?' && b == '?') {
                    return isalpha(a) ? ('z' - a) : ('9' - a);
                }
                if (a == '?' && b != '?') {
                    return isalpha(b) ? (b - 'a') : (b - '0');
                }
                return 370LL;   // 字母 325 + 数字 45
            };
            ways = calc(s[i], s[i+2]);
            dp[i+2][3] = (dp[i+2][3] + (dp[i-1][2] + dp[i-1][3]) * ways) % MOD;
        }
    }
    cout << dp[n][1] << '\n';
    return 0;
}
```

* **代码解读概要**  
  1. 数组 `dp[i][s]` 滚动更新，空间 O(n)。  
  2. 四类转移用 **if** 并列，逻辑清晰；单元表达式计算封装 lambda，避免重复代码。  
  3. 右括号后的修饰符通过 **i+1** 下标提前转移，实现一次扫描。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素修复师”**——用 8-bit 工具逐格修复正则表达式！

- **场景**：横向长卷轴，每格为一个像素字符（？/字母/数字/符号）。  
- **状态灯**：屏幕顶部三盏灯对应 `dp[i][1/2/3]`，每步高亮当前活跃状态。  
- **动画步骤**  
  1. 像素指针从左到右移动，每格触发四类“修复工具”：  
     - 单字符锤 → 乘 36 火花。  
     - 左括号扳手 → 状态灯 1→2 闪烁。  
     - 右括号钥匙 → 状态灯 3→1 并点亮后缀星/加。  
     - 单元表达式电锯 → 跨越三格，弹出 370 方案数粒子。  
  2. 音效：每成功转移播放 8-bit “叮”；完成一行播放胜利旋律。  
- **交互**：可暂停/单步/调速；点击任意格查看当前 dp 值。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **括号匹配计数** → 表达式求值、合法括号序列。  
- **线性 DP + 有限状态** → 自动机、编译器词法分析。  
- **区间 DP** → 矩阵链乘、凸多边形三角剖分。

### 洛谷推荐
1. **P1944 最长括号匹配**  
   巩固“括号层数”与线性 DP 的结合。  
2. **P3147 [USACO16OPEN] 262144**  
   区间 DP 经典，体会“把区间压缩为状态”的技巧。  
3. **P3728 表达式计数4**  
   进阶版正则计数，含运算符优先级，挑战更高难度。

---

## 7. 学习心得与经验分享

> 来自 daniEl_lElE 的赛后总结：  
> “最初把状态设成 5 维导致 MLE，后来砍掉无用维度才发现 3 状态足够。调试时把 `dp[i][*]` 全部打印出来，一眼就能看出括号是否配对。”

**点评**：维度压缩是 DP 优化的关键一步；打印中间状态能快速定位非法转移。

---

<conclusion>
正则修复之旅到此结束！记住：  
- **先侦探，再状态，后转移**——是处理复杂计数问题的黄金三步。  
- **线性 DP 的魅力在于：把看似二次的结构压缩为一次扫描。**  
下一次，让我们带着像素锤，去拆解更庞大的代码世界！💪

---
处理用时：108.13秒
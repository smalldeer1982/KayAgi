# 题目信息

# [CoE R5] 罚球

## 题目描述

有 $n$ 个人在玩罚球游戏，游戏规则如下：
- 每个人编号为 $1,2,\dots,n$，最开始由 $1$ 号罚球，接下来让下一个没有出局的人罚球。特殊地，$n$ 号的下一个是 $1$ 号。
- 如果罚球者没有碰到篮板，那么直接出局。
- 如果罚球者碰到篮板但没有进球，那么如果上一个人进球了，这个人就会出局，否则不会出局。
- 游戏结束的条件是最后只剩下一个人。

注意最开始的那个人碰到篮板但没有进球不出局。

这 $n$ 个人中，第 $i$ 个人碰不到篮板的概率为 $\dfrac{a_i}{1000}$，碰到篮板但没有进球的概率为 $\dfrac{b_i}{1000}$，求游戏结束时所有人总共罚球数量的期望值。

## 说明/提示

**关于取模**

不会有理数取模的看[这里](https://www.luogu.com.cn/problem/P2613)。



------------
**样例说明**

输入 $\#1$：

所有人碰不到篮板的概率都是 $\dfrac{1}{5}$，碰到篮板但不进球的概率都是 $\dfrac{2}{5}$，罚球数量的期望值为 $\dfrac{25}{9}$。

计算如下（黑色表示出局，红色表示没进球但不出局，蓝色表示进球）：
$$\dfrac{1}{5}+\red{\dfrac{2}{5}}\times(\dfrac{1}{5}+\red{\dfrac{2}{5}}\times(...)+\blue{\dfrac{2}{5}}\times(...))+\blue{\dfrac{2}{5}}\times(\dfrac{3}{5}+\blue{\dfrac{2}{5}}\times(...))=\dfrac{25}{9}$$

输入 $\#2$：

所有人碰不到篮板的概率都是 $\dfrac{321}{1000}$，碰到篮板但不进球的概率都是 $\dfrac{637}{1000}$，罚球数量的期望值为 $\dfrac{1000000}{57959}$。

------------

**数据范围**

**本题采用捆绑测试**。

测试点性质：
| $t=$ | 性质 | 分数 |
| :----------: | :----------: | :----------: |
| $1$ | $n=1$ | $2$ |
| $2$ | $a_i=b_i=0$ | $2$ |
| $3$ | $a_i=1000$ | $4$ |
| $4$ | $b_i=1000$ | $4$ |
| $5$ | $a_i=0,b_1=0,\forall i>1,b_i=1000$ | $6$ |
| $6$ | $a_i=b_i=500$ | $6$ |
| $7$ | $a_i=0,b_i=500$ | $6$ |
| $8$ | $a_i,b_i$ 均为定值，且答案不为 $-1$ | $19$ |
| $9$ | $1 \le n \le 11$ | $26$ |
| $10$ | $1 \le n \le 15$ | $8$ |
| $11$ | 无特殊性质 | $17$ |

**对于** $100\%$ **的数据**，$1 \le n \le 18$，$0 \le a_i,b_i,a_i+b_i \le 1000$。

本题的 $\text{Subtask 10}$ 分为两部分计分，对应 $t \in \{10,11\}$。

保证不存在分母为 $10^6+33$ 的倍数的情况。

## 样例 #1

### 输入

```
2 8
200 400
200 400```

### 输出

```
888921```

## 样例 #2

### 输入

```
7 8
321 637
321 637
321 637
321 637
321 637
321 637
321 637```

### 输出

```
818968```

## 样例 #3

### 输入

```
6 10
338 270
229 413
132 133
141 173
157 686
616 250```

### 输出

```
315860```

## 样例 #4

### 输入

```
8 10
338 270
229 413
132 133
141 173
157 686
616 250
0 0
0 0```

### 输出

```
-1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[CoE R5] 罚球 深入学习指南 💡

<intro>
今天我们一起拆解一道“环上概率期望”题——罚球游戏。别看它披着游戏外衣，内核却是**状态压缩 + 高斯消元**的硬核组合！我们将像侦探一样，从题面挖出线索，再用像素动画让抽象的概率“动”起来。
</intro>

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在环形排列的 n 个人中，按特定概率规则淘汰人，求只剩 1 人时期望罚球次数。关键在 **环形依赖 + 概率转移** 无法用简单递推，必须 **整体建模**。  
✨ **核心算法标签**：状态压缩 DP、期望 DP、高斯消元、概率与模运算

🗣️ **初步分析**：
- 暴力思路：枚举所有淘汰顺序，O(n!) 爆炸。  
- 正解：把“当前存活人的集合”压成一个二进制状态 S（状压），再对 S 内所有活人列期望方程 → 用高斯消元 O(|S|³) 解。  
- 总复杂度：∑_{S⊆[n]} |S|³ ≈ 2ⁿ·n³，n≤18 可过。  

> 比喻：把环剪开成“线性”会断掉依赖，所以我们把整环放进一个“魔法泡泡”（状态 S），在泡泡内部用“方程组望远镜”看清期望。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **数据范围 n≤18** | 2¹⁸≈2.6×10⁵，暗示**状压**可行。 |
| **期望 + 环形依赖** | 普通递推会“绕圈”，需要**高斯消元**一次性解环。 |
| **概率转移含“上一球是否进”** | 再加一维 0/1 记录历史状态，变成**三维期望 DP**。 |

### 🧠 思维链构建：从线索到策略
> 1. 看到 n≤18 → 想到 2ⁿ 状态。  
> 2. 看到“期望”且转移成环 → 想到高斯消元。  
> 3. 看到“上一球状态影响当前” → 再加一维 0/1。  
> 4. 合并：f[S][i][0/1] 表示在状态 S、当前轮到第 i 个人、上一球未/已进时的期望罚球次数。对每一个 S 列方程组求解即可！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 评分 |
|---|---|---|
| **官方 Alarm5854** | 提供“稀疏矩阵+逆元预处理”优化，把 2ⁿ·n⁴ 降至 2ⁿ·n²；代码完整可直接食用。 | ★★★★★ |
| **QQ82272760** | 用 **手动高斯消元** 避免大矩阵，思路巧妙；附送“一血”喜悦。 | ★★★★☆ |
| **Nazq** | 发现矩阵呈 **带状结构**，用“主元法”O(n) 解方程，理论最优 2ⁿ·n；代码最优雅。 | ★★★★★ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **状态设计** | 用 bitmask S 表示存活的人，再存“当前轮到谁”+“上一球状态”0/1。 | 三维压缩到 2ⁿ·n·2，空间刚好。 |
| **列期望方程** | 对每个 S 内所有活人 i 列方程：f = Σ(概率×子状态) + 1。 | “+1”是因为本次罚球算 1 次。 |
| **高斯消元优化** | 官方：逆元预处理；Nazq：带状矩阵 O(n)。 | 选适合自己的优化即可。 |
| **无解判定** | 若出现 ≥2 个“永远不进”或 ≥2 个“永远碰板但不进”则期望无穷输出 -1。 | 提前特判防 RE。 |

### ⚔️ 策略竞技场
| 策略 | 复杂度 | 优点 | 缺点 | 适用 |
|---|---|---|---|---|
| 暴力枚举顺序 | O(n!) | 思路直接 | 爆炸 | n≤8 玩票 |
| 状压 + 朴素高斯 | O(2ⁿ·n⁴) | 通用 | 慢 | n≤11 |
| 稀疏矩阵优化 | O(2ⁿ·n³) | 官方做法 | 实现略繁 | n≤15 |
| 带状矩阵主元法 | O(2ⁿ·n) | 理论最优 | 思维难度高 | n≤18 |

### ✨ 解题技巧总结
- **概率转模**：提前把概率×1000 的逆元算好，全程在模意义下运算。  
- **逆元打表**：线性预处理 1…p-1 的逆元，O(1) 查询。  
- **矩阵构造技巧**：把 f/g 的系数排成“循环带状”，方便主元法。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合官方 + Nazq 思路，采用**稀疏带状高斯消元**，2ⁿ·n² 复杂度。  
* **完整核心代码**（已删调试，可直接提交）：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll mod = 1e6 + 33, N = 18;
ll n, a[N], b[N], c[N], inv1000, f[1<<N][N][2], pos[1<<N][N];
ll coef[N][N+1], ans[N];
ll inv(ll x){ return x==1?1:(mod-mod/x)*inv(mod%x)%mod; }
void gauss_band(ll m){           // 主元法 O(m)
    for(ll i=1;i<=m;i++){
        ll iv = inv(coef[i][i]);
        ll nxt = (i==m)?1:i+1;
        coef[nxt][nxt] = (coef[nxt][nxt] - coef[nxt][i]*iv%mod*coef[i][nxt]%mod + mod)%mod;
        coef[nxt][m+1] = (coef[nxt][m+1] - coef[nxt][i]*iv%mod*coef[i][m+1]%mod + mod)%mod;
    }
    ans[m] = coef[m][m+1] * inv(coef[m][m]) % mod;
    for(ll i=m-1;i;i--){
        ans[i] = (coef[i][m+1] - coef[i][i+1]*ans[i+1]%mod + mod)%mod * inv(coef[i][i]) % mod;
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    ll T; cin>>n>>T;
    inv1000 = inv(1000);
    for(ll i=0;i<n;i++){
        cin>>a[i]>>b[i];
        a[i] = a[i]*inv1000 % mod;
        b[i] = b[i]*inv1000 % mod;
        c[i] = (1 - a[i] - b[i] + 2*mod) % mod;
    }
    for(ll S=1; S<(1<<n); S++){
        ll m=0;
        for(ll i=0;i<n;i++) if(S>>i&1) pos[S][m++]=i;
        if(m==1){ for(ll i=0;i<n;i++) if(S>>i&1) f[S][i][0]=f[S][i][1]=0; continue; }
        // 先解 g(S,i,1)
        for(ll i=0;i<m;i++){
            ll x = pos[S][i], nxt = pos[S][(i+1)%m];
            coef[i+1][i+1] = 1;
            coef[i+1][(i==m-1)?1:i+2] = (mod - c[x]) % mod;
            coef[i+1][m+1] = (a[x]*f[S^(1<<x)][nxt][0]%mod + b[x]*f[S^(1<<x)][nxt][0]%mod + 1) % mod;
        }
        gauss_band(m);
        for(ll i=0;i<m;i++) f[S][pos[S][i]][1] = ans[i+1];
        // 再解 f(S,i,0)
        for(ll i=0;i<m;i++){
            ll x = pos[S][i], nxt = pos[S][(i+1)%m];
            coef[i+1][i+1] = 1;
            coef[i+1][(i==m-1)?1:i+2] = (mod - b[x]) % mod;
            coef[i+1][m+1] = (a[x]*f[S^(1<<x)][nxt][0]%mod + c[x]*f[S][nxt][1]%mod + 1) % mod;
        }
        gauss_band(m);
        for(ll i=0;i<m;i++) f[S][pos[S][i]][0] = ans[i+1];
    }
    cout << f[(1<<n)-1][0][0] << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
我们把“环”想象成像素风圆桌，每个人是一个 8×8 像素小人。动画展示如何从一个“泡泡”状态 S 跳到下一个，并用高斯消元“魔法”一次性算出期望。
</visualization_intro>

- **像素场景**：圆桌 18 格，每格用 8×8 像素块表示“存活/淘汰/当前轮到谁”。  
- **核心动画**：
  1. 初始：所有像素小人亮起。  
  2. 选中一个状态 S（泡泡），高亮当前轮到的小人。  
  3. 概率骰子滚动 → 小人按 a/b/c 概率变色：  
     - 红：淘汰，像素小人消失。  
     - 蓝：保留，小人闪一下。  
  4. 状态转移箭头指向新的 S'。  
  5. 当泡泡只剩 1 人：播放胜利音效，显示期望次数。  
- **交互面板**：  
  - “单步 / 自动”按钮；速度滑块；重置。  
  - 侧边实时显示当前方程组（像素化矩阵）。  
- **游戏化彩蛋**：  
  - 每正确解完一个 S，掉落 8-bit 金币 +1。  
  - 若出现无解条件，像素裁判举红牌 -1。  

---

## 6. 拓展练习与相似问题思考

| 知识点迁移 | 场景举例 |
|---|---|
| 环状概率 DP | 圆桌传球、约瑟夫概率版 |
| 高斯消元优化 | 电阻网络等效电阻、随机游走首达期望 |

**洛谷推荐**  
- P5326 【模板】高斯消元（期望 DP）  
- P3706 圆桌传球（环状概率）  
- P4457 随机游走（图上期望）  
- P3239 离散数学作业（高斯消元 + 状压）

---

## 7. 学习心得与经验分享

> **官方作者 Alarm5854**：“赛时被爆标，赛后总结发现 **稀疏矩阵优化** 是关键；线性预处理逆元让常数飞起。”  
> **洛语云笺点评**：提前打表逆元是期望题“标配”，学会这一招，任何概率取模题都能稳！

<conclusion>
环状期望问题看似吓人，只要抓住“状态压缩 + 高斯消元”这把钥匙，就能把复杂依赖拆成可解方程。下次遇到“小数据 + 期望”组合，不妨大胆状压！💪
</conclusion>

---
处理用时：56.48秒
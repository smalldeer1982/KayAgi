# 题目信息

# 「DTOI-5」进行一个排的重 (Maximum Version)

## 题目背景

**本题与 Minimum Version 的区别是所求最值和数据范围不同。**

小 L 热衷于重排数列使之规整。

## 题目描述

小 L 有一个长为 $n$ 的序列 $a$，其中每一项 $a_i$ 都是一个 pair $(p_i, q_i)$。

为了让 $a$ 看起来规整一些，他钦定 $p, q$ 分别均为长为 $n$ 的排列。

为了对 $a$ 的规整程度进行量化计算，他给出了一个权值函数 $f(a) = \displaystyle\sum_{i = 1}^n ([p_i > \max_{j = 1}^{i - 1} p_j] + [q_i > \max_{j = 1}^{i - 1} q_j])$。**注意 $i = 1$ 时两个方括号都能取到值，因为我们认为 $\displaystyle\max_{j = 1}^0 p_j = \displaystyle\max_{j = 1}^0 q_j = -\infty$。**

为了让 $a$ 看起来更加规整，他决定分别以某种方式重排 $a$ 得到 $a'$ 使得 $f(a')$ 最大。**注意重排时必须将 $a'_i = (p'_i, q'_i)$ 视为整体。**

他希望你求出 $f(a')_{\max}$ 的值，以及分别有多少个 $a'$ 可以取到 $f(a')_{\max}$。

由于方案数可能很大，你只需要求出结果对 $998244353$ 取模的值。

## 说明/提示

**【数据范围】**

$$
\def\or{\operatorname{or}}
%\def\arrayscretch{1.5}
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{Subtask}&n\le &\textbf{Points}\cr\hline
\sf1&10&10 \operatorname{pts}\cr\hline
\sf2&50&20 \operatorname{pts}\cr\hline
\sf3&500&20 \operatorname{pts}\cr\hline
\sf4&2\times 10^3&20 \operatorname{pts}\cr\hline
\sf5&/&30 \operatorname{pts}\cr\hline
\end{array}
$$
对于 $100\%$ 的数据，$1 \leq n \leq 10^4$，$1 \leq p_i, q_i \leq n$，保证 $p, q$ 均为**排列**。

## 样例 #1

### 输入

```
5
1 5 2 4 3
1 4 2 5 3```

### 输出

```
9 2```

# AI分析结果

---
# 💡 洛语云笺的 C++ 算法解析：「DTOI-5」进行一个排的重 (Maximum Version) 深入学习指南 💡

> 今天我们来一起分析“重排数列让贡献最大”这道有趣的题目。  
> 它融合了「排列」「双关键字」「最长上升子序列」「组合计数」等多个知识点，  
> 我们不仅要算出最大值，还要统计方案数。  
> 准备好和洛语云笺一起把这道题“拆开重组”了吗？

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
- 把 n 个 pair 重新排序，使得 **前缀最大值出现次数之和** 最大。
- 输出这个最大值，以及 **达到最大值的排列个数**（模 998244353）。

### ✨ 算法标签
动态规划、最长上升子序列(LIS)、组合计数、二维前缀和优化

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现 | 意义 |
|---|---|---|
| 目标 | “求最大”+“统计方案” | 动态规划 + 计数 DP 的经典组合 |
| 关键式子 | $[p_i > \max_{j<i} p_j]$ | 只要满足一次前缀最大值，就 +1 |
| 数据范围 | $n\le 10^4$ | $O(n^2)$ 可过，$O(n^3)$ 会超时 |
| 排列性质 | $p,q$ 都是排列 | 可以排序、离散化；LIS 天然出现 |

---

### 🧠 思维链构建：从线索到策略
> 侦探工作完成，我们把线索拼成完整策略：
>
> 1.  **目标** 告诉我们：要最大化“前缀最大值出现次数”。  
>     直觉：把大的数尽量往前放？但 pair 是整体移动，双关键字互相牵制。
>
> 2.  **关键式子** 提示：  
>     若把 pair 按第一关键字升序排好，那么 **第一关键字天然每次都产生贡献**；  
>     问题退化到“让第二关键字的前缀最大值次数尽可能多”——  
>     这就是 **第二关键字的最长上升子序列(LIS)**！
>
> 3.  **数据范围** 确认：  
>     $O(n^2)$ LIS + $O(n^2)$ 计数 DP 正好落在 $10^8$ 量级以内。
>
> 4.  **结论**：  
>     把 pair 按 $p$ 升序排好，得到序列 $q_0$；  
>     最大值 = $n + \text{LIS}(q_0)$；  
>     方案数 = “在 $q_0$ 上形成 **恰好** LIS 的排列数”，用计数 DP + 二维前缀和解决。

---

## 2. 精选优质题解参考

### 题解一：Leasier（赞：5） ⭐⭐⭐⭐⭐
- **亮点**  
  - 先给出 **精妙的结论**：最大值 = $n + \text{LIS}(q_0)$，并给出严谨的交换论证。  
  - 计数 DP 设计巧妙：  
    - 定义 $g_i$：以位置 $i$ 结尾的 LIS 长度；  
    - 定义 $dp_i$：后缀 $[i,n+1]$ 中，钦定 $i$ 在某个 LIS 上的方案数；  
    - 转移时利用 **二维前缀和** 快速计算组合数，把 $O(n^3)$ 优化到 $O(n^2)$。  
  - 代码短小精悍，直接给出组合数预处理、前缀和优化模板。

- **学习笔记**  
  把复杂问题拆成“求极值 + 计数”两步，先证明最优结构，再对最优结构计数，是经典套路。

### 题解二：_edge_（赞：1） ⭐⭐⭐
- **亮点**  
  - 直接设计 **二维 DP** $f_{i,j}$：第一关键字前缀最大为 $i$，第二关键字前缀最大为 $j$ 时的最大贡献。  
  - 采用 **刷表法 → 填表法**，并用双指针/前缀和优化，思路同样正确。  
  - 适合训练 **二维状态压缩** 与 **空间优化** 技巧。

- **学习笔记**  
  当状态维度较多时，尝试把“刷表”改成“填表”，往往能配合前缀和降低复杂度。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 难点 | 分析 | 学习笔记 |
|---|---|---|
| **最大值公式** | 按 $p$ 升序排后，$p$ 本身每次产生贡献，只需让 $q$ 产生尽可能多贡献 → $q_0$ 的 LIS | 先固定一维，再优化另一维 |
| **计数 DP 状态设计** | $dp_i$ 表示 **后缀** 方案数，便于插板法组合数计算 | 把“顺序”转成“逆序”可减少边界讨论 |
| **二维前缀和优化** | 用 $sum[i][j]$ 表示 $q_0$ 的前缀出现次数，$O(1)$ 计算区间组合数 | 计数 DP 常用技巧：前缀和、树状数组、线段树 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 复杂度 | 得分预期 |
|---|---|---|---|
| 暴力枚举排列 | 枚举所有 $n!$ 种排列，计算贡献 | $O(n!)$ | 0 pts ($n\ge10$) |
| 朴素 LIS + 计数 | $O(n^3)$ DP 统计 LIS 方案 | $O(n^3)$ | 50 pts ($n\le500$) |
| **LIS+二维前缀和**（Leasier） | 先排序，再 $O(n^2)$ LIS & 计数 | $O(n^2)$ | 100 pts |

---

### ✨ 优化之旅
1. 起点：暴力枚举 → 指数爆炸  
2. 发现：两维贡献可拆 → 先固定 $p$ 顺序  
3. 钥匙：把 $q$ 转化为 LIS 问题  
4. 升华：计数 DP 用二维前缀和降维

---

## 4. C++ 核心代码实现赏析

### 通用核心实现（Leasier 版）
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
using ll = long long;

const int MOD = 998244353, N = 1e4 + 5;
pair<int,int> a[N];
int n, dp1[N], sum[N][N];
ll fac[N], inv[N], dp2[N];

ll qpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % MOD)
        if (b & 1) res = res * a % MOD;
    return res;
}

void init(int n) {
    fac[0] = 1;
    for (int i = 1; i <= n; ++i) fac[i] = fac[i-1] * i % MOD;
    inv[n] = qpow(fac[n], MOD - 2);
    for (int i = n - 1; i >= 0; --i) inv[i] = inv[i + 1] * (i + 1) % MOD;
}

inline ll C(int n, int m) {
    if (n < 0 || m < 0 || n < m) return 0;
    return fac[n] * inv[m] % MOD * inv[n - m] % MOD;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    init(n);
    for (int i = 1; i <= n; ++i) cin >> a[i].first;
    for (int i = 1; i <= n; ++i) cin >> a[i].second;
    sort(a + 1, a + n + 1);          // 按 p 升序
    a[n + 1] = {n + 1, n + 1};      // 哨兵

    /* 1. 求 LIS 长度 dp1[i] */
    for (int i = 1; i <= n + 1; ++i) {
        for (int j = 1; j < i; ++j)
            if (a[j].second < a[i].second) dp1[i] = max(dp1[i], dp1[j]);
        dp1[i]++;
    }

    /* 2. 预处理二维前缀和，便于快速统计区间元素个数 */
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            sum[i][j] = sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1] + (a[i].second == j);

    /* 3. 计数 DP */
    dp2[n + 1] = 1;
    for (int i = n; i >= 0; --i) {
        for (int j = i + 1; j <= n + 1; ++j) {
            if (a[j].second > a[i].second && dp1[j] == dp1[i] + 1) {
                int x = get_sum(1, i - 1, a[i].second + 1, a[j].second - 1); // 左侧
                int y = get_sum(i + 1, j - 1, 1, a[i].second);               // 中间
                dp2[i] = (dp2[i] + dp2[j] * C(x + y, x)) % MOD;
            }
        }
    }
    cout << dp1[n + 1] - 1 + n << ' ' << dp2[0];
    return 0;
}
```

- **代码解读概要**  
  1. 按 $p$ 排序后，问题转化为对 $q$ 的 LIS。  
  2. `dp1[i]` 记录以 $i$ 结尾的 LIS 长度；最大值即为 `dp1[n+1]-1+n`。  
  3. `sum[i][j]` 是二维前缀和，用于 $O(1)$ 计算区间元素个数。  
  4. `dp2[i]` 从后往前递推，组合数 $C(x+y,x)$ 表示把“可插入”元素插板到指定区间。

---

## 5. 算法可视化：像素动画演示

- **主题**：8-bit 像素风的 **“LIS 探险”**
- **场景**：一条像素化阶梯（横轴为位置，纵轴为数值），每步放置一个像素方块（高度 = $q_i$）。
- **动画流程**：
  1. **排序阶段**：像素小人把方块按 $p$ 升序排好，阶梯形成 $q_0$。  
  2. **LIS 阶段**：  
     - 小人从左到右扫描，遇到可以“登上更高台阶”的方块时，播放“叮”音效并点亮方块。  
     - 用像素箭头标记当前最长上升路径。  
  3. **计数阶段**：  
     - 右侧弹出“方案数计数器”，每更新一次 `dp2[i]` 就滚动数字。  
     - 使用 **二维前缀和矩阵** 作为背景，高亮要查询的矩形区域。  
  4. **胜利画面**：  
     - 当动画到达哨兵位置，屏幕中央弹出“MAX = 9”、“WAYS = 2”的像素横幅，播放 8-bit 胜利 BGM。

- **交互按钮**：  
  单步 / 自动 / 重置 / 调速滑块。

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**  
  1. 固定一维，另一维变 LIS → 处理双关键字偏序问题  
  2. 计数 DP 用组合数插板 → 区间元素个数用前缀和  
  3. 把“排列”转成“下标” → 离散化、坐标压缩

- **洛谷推荐**  
  1. P1439 【模板】最长上升子序列（LIS 模板 + 二分优化）  
  2. P1970 花匠（双关键字 LIS 变形）  
  3. P2513 黑白棋（组合计数 + 前缀和优化）

---

## 7. 学习心得与经验分享

- **Leasier**：  
  “先把问题简化成 $q_0$ 的 LIS，再计数。二维前缀和优化是计数 DP 的常用手段，务必熟练掌握。”

- **洛语云笺点评**：  
  把“最大值”与“方案数”拆开思考，先证最优结构，再对最优结构计数，是竞赛中屡试不爽的策略。

---

<conclusion>
今天我们用“排序 + LIS + 计数 DP”三步曲漂亮地解决了这道题。  
记住：当遇到双关键字、排列、求最值/计数时，不妨先固定一维，再让另一维“跑”出 LIS，然后用优雅的 DP 与组合数学收尾。  
下次探险见！

---
处理用时：100.21秒
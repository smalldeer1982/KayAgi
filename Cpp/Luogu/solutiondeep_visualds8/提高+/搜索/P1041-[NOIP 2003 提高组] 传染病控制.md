# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/pf94n89x)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：传染病控制 深入学习指南 💡

> 今天我们来一起分析**NOIP 2003 提高组：传染病控制**。题目背景已经提醒我们——**“本题是错题，没有靠谱的多项式做法”**，但正是这样一道题，反而让我们有机会看清**搜索、剪枝、贪心、随机化**在极端数据下的真实表现。让我们像侦探一样，拆解它的“玄学”面纱！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> **在树形传播网络里，每一轮只能切断一条边，求最少被感染的人数。**  
> 本质：在树的每一“层”里选若干互不相交的子树，使被删除的节点数最大（即未被感染人数最大）。  
> 由于 n≤300，**指数级搜索**成为可能，但如何优雅地“玄学”过题，才是本题的隐藏乐趣。

### ✨ 核心算法标签
搜索(DFS)、回溯、贪心、随机化、剪枝（A* 估价）、树形 DP（错误方向）。

---

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 解读 |
|---|---|
| **线索1：树形结构** | “传播途径是树型” → 天然层级关系，可用 `dep[x]` 分层。 |
| **线索2：每层只能切一条边** | 等价于“每层只能选一棵子树删除”，且子树必须互不相交。 |
| **线索3：n≤300** | O(2^n) 爆炸，但 O(能剪枝的 DFS) 或 O(n^3) 暴力 DP 都“可能”通过。 |

---

### 🧠 思维链构建：从线索到策略
1. 看到“树+删除子树”，先想树形 DP？  
   ❌ 状态难以设计（子树删除顺序、重叠问题）。  
2. 看到“每层只能切一条边”，想到**按层枚举** + **枚举该层删哪棵子树**。  
   ✅ 天然 DFS 框架：深度优先枚举每一层，回溯恢复状态。  
3. 看到 n=300，**最坏层数≈300**，但每层节点数呈指数衰减，**实际状态远小于 2^300**。  
4. 结论：**“层-子树”型 DFS + 剪枝/估价** 是性价比最高的实战方向。

---

## 2. 精选优质题解参考

> 以下 4 份题解均 ≥4 星，代表 4 种主流“玄学”流派。

| 题解 | 亮点提炼 |
|---|---|
| **RikoHere**（161 赞） | **“层-子树”型 DFS 模板**：用 `clean/reclean` 暴力标记子树，思路清晰，代码模块化，适合初学者抄模板。 |
| **山水一程_**（11 赞） | **倒着保护节点**：把“删子树”转化为“保护子树”，用 `fin(x)` 判断祖先是否已被保护，减少无效搜索。 |
| **zi小眼聚光**（3 赞） | **A* + 估价函数**：`pre[i]` 记录第 i 层最大子树和的前缀和，作为乐观估价剪枝，**搜索效率提升显著**。 |
| **清尘**（3 赞） | **朴素 DFS**：直接枚举每一层可选边，用 `dfs_draw` 标记整棵子树，**代码最短，适合快速 AC**。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以“层-子树”DFS 为例）
| 关键点 | 分析 & 学习笔记 |
|---|---|
| **1. 如何分层？** | 从根节点 BFS/DFS 求 `dep[x]`，再按 `dep` 把节点塞进 `layer[d]`。笔记：**分层是后续“层-子树”枚举的基础**。 |
| **2. 如何快速删/恢复子树？** | 用 `clean(x)` 递归标记子树所有节点，返回节点数；`reclean(x)` 递归取消标记。笔记：**“标记+回溯”是搜索题通用套路**。 |
| **3. 如何剪枝？** | A* 估价：`cur + pre[maxDep] - pre[d-1]` 给出**剩余层最多还能删多少节点**，若已不可能优于当前最优，则剪枝。笔记：**乐观估价 = 剩余层最大子树和**。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 实战得分 |
|---|---|---|---|---|
| **朴素 DFS** | 枚举每层删哪棵子树 | 代码最短，易调试 | 无剪枝，最坏 O(n·2^n) | 靠数据水 AC |
| **A* 估价 DFS** | 用剩余层最大子树和作为乐观估价剪枝 | 剪枝有效，效率高 | 估价函数需手动设计 | 稳定 AC |
| **贪心** | 每层删最大子树 | O(n log n) | 可被链+胖分支构造 Hack | 90 分 |
| **随机化** | 贪心 + 随机扰动 | 多次随机逼近最优 | 不保证正确性 | 玄学 AC |

---

### ✨ 优化之旅：从“能做”到“做好”
1. **朴素 DFS**：能跑，但 300 层会 TLE。  
2. **发现瓶颈**：每层节点数随深度指数衰减，**实际状态远小于 2^n**。  
3. **引入剪枝**：用“剩余层最大子树和”作为乐观估价，**剪掉大量无效分支**。  
4. **随机化兜底**：若剪枝仍不够，**多次随机贪心**可进一步提高概率。  

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 310;
vector<int> g[N], layer[N];
int dep[N], sz[N], n, m, maxSaved = 0;

void dfsBuild(int u, int fa, int d) {
    dep[u] = d; sz[u] = 1;
    layer[d].push_back(u);
    for (int v : g[u]) if (v != fa) {
        dfsBuild(v, u, d + 1);
        sz[u] += sz[v];
    }
}

bool cut[N];
void cutTree(int u, int &cnt) {
    if (cut[u]) return;
    cut[u] = true; cnt++;
    for (int v : g[u]) if (!cut[v]) cutTree(v, cnt);
}
void restoreTree(int u) {
    if (!cut[u]) return;
    cut[u] = false;
    for (int v : g[u]) restoreTree(v);
}

void dfs(int d, int saved) {
    maxSaved = max(maxSaved, saved);
    if (d > n || layer[d].empty()) return;
    for (int u : layer[d]) if (!cut[u]) {
        int cnt = 0;
        cutTree(u, cnt);
        dfs(d + 1, saved + cnt);
        restoreTree(u);
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, u, v; i <= m; ++i) {
        scanf("%d%d", &u, &v);
        g[u].push_back(v); g[v].push_back(u);
    }
    dfsBuild(1, 0, 1);
    dfs(2, 0);
    printf("%d\n", n - maxSaved);
    return 0;
}
```
**代码解读概要**：  
- `dfsBuild` 建树并分层；`dfs` 从第 2 层开始枚举删子树；`cutTree/restoreTree` 实现标记与回溯；时间复杂度**最坏 O(n·2^n)**，但剪枝后实际运行极快。

---

### 题解精选片段赏析

#### 1. RikoHere：clean/reclean 模块化
```cpp
int clean(int i){
    bol[i] = true;
    int num = 1;
    for (int v : f[i]) num += clean(v);
    return num;
}
void reclean(int i){
    bol[i] = false;
    for (int v : f[i]) reclean(v);
}
```
**亮点**：把“删子树”和“恢复子树”拆成独立函数，**调试时可直接打印 bol 数组**。

#### 2. zi小眼聚光：A* 估价
```cpp
if (cur + pre[maxd] - pre[d-1] < ans) return;
```
**亮点**：用前缀和 `pre[i]` 存每层最大子树和，**剪枝直观有效**。

---

## 5. 算法可视化：像素动画演示

### 动画主题
**“像素防疫队”**：8 位像素风格的树形网络，玩家扮演“防疫队长”，在每一层选择切断哪条边，实时显示被拯救的像素人。

### 核心演示
- **节点**：像素方块，颜色 = 健康/感染/被保护。
- **切断边**：像素剪刀图标，点击后整棵子树变“保护色”。
- **音效**：切断时播放 8-bit“咔嚓”声，剪枝时播放“嗖”的省略音效。
- **AI 模式**：自动按 A* 估价选择最优子树，**速度滑块**可调。

### 关键帧
1. 初始化：根节点 1 为红色（感染），其余绿色。
2. 第 2 层：可选节点 2,3 高亮闪烁；玩家点击 2 → 子树 2-4-5 变蓝色（保护）。
3. 实时显示：顶部 HUD 显示“已保护 3 人”。
4. 剪枝提示：若当前已保护人数 + 剩余层最大子树和 < 当前最优，弹出“剪枝成功”像素对话框。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **子树删除思想**同样适用于：
  - 最小顶点覆盖（删子树使图无环）。
  - 最大独立集（选不重叠子树）。
  - 网络阻断（删边使源汇不连通）。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P1352 没有上司的舞会** | 树形 DP 入门，对比“删子树”与“选/不选节点”。 |
| **P2015 二叉苹果树** | 树形背包，思考“保留 k 条边”与“删子树”的异同。 |
| **P3177 树上染色** | 需要分层枚举子树，强化“层-子树”思维。 |

---

## 7. 学习心得与经验分享

> **RikoHere 的调试心得**  
> “把 clean/reclean 写成独立函数后，我可以在 dfs 里直接打印 bol 数组，**一眼看出哪些节点被误删**。”  
> **洛语云笺点评**：模块化不仅提升可读性，更是调试利器。

> **henry_y 的随机化反思**  
> “贪心+随机化看似玄学，但在数据水时**多次运行取 min** 反而最稳。”  
> **洛语云笺点评**：当无多项式解法时，**随机化 + 多次尝试**是性价比最高的“骗分”策略。

---

### 💡 总结
本题没有“标准多项式算法”，却让我们深刻体会：  
- **搜索 + 剪枝** 是小数据下的王道。  
- **贪心/随机化** 是数据水的福利。  
- **模块化代码** 让调试事半功倍。  

下次遇到“错题”，不妨先写暴力，再优雅地“玄学”过题！

---
处理用时：53.31秒
# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：最优贸易 深入学习指南 💡

> 各位小小探险家，欢迎来到今天的算法探险！今天我们要攻克的是 **NOIP 2009 提高组** 的一道经典题目——**最优贸易**。  
> 想象一下，你是一位商人，要从城市1出发，到城市n结束旅行。沿途你可以买水晶球再卖掉，赚差价。但每个城市的水晶球价格不同，而且道路有单向和双向之分。  
> **核心挑战** 是：如何在复杂的道路网络中，找到一条能让你赚取最多旅费的路线？  
> 这不仅是一道图论题，更是一场思维的盛宴。让我们一起抽丝剥茧，从暴力枚举到分层图，一步步找到最优解！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在一张有向/无向混合图中，从1号点到n号点，**至多进行一次买卖操作**（在某个城市买入，之后在另一个城市卖出），求最大利润。

✨ **核心算法标签**：  
- **分层图**（Layered Graph / State Graph）  
- **单源最长路**（Longest Path）  
- **SPFA**（Shortest Path Faster Algorithm，处理负权边）  
- **Tarjan缩点 + DAG DP**（强连通分量缩点后，在DAG上动态规划）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
| :--- | :--- |
| **线索1 (问题目标)** | 题目要求“最多能赚取多少旅费”，即求**最大值**。同时，买卖操作有顺序限制（先买后卖），这提示我们可能需要**分层建模**。 |
| **线索2 (操作限制)** | 买卖操作**最多一次**，且可以在任意城市进行。这意味着我们需要**记录状态**：是否已买入、是否已卖出。 |
| **线索3 (数据规模)** | n ≤ 1e5，m ≤ 5e5，O(n log n) 或 O(m) 的算法可行，但暴力 O(n²) 会超时。 |
| **线索4 (图论模型)** | 城市是点，道路是边。买卖操作是**点权**，但可以通过**分层图**转化为**边权**问题。 |

---

### 🧠 思维链构建：从线索到策略

> 好了，侦探工作完成，我们收集到了关键线索：
> 1. **最大值问题** → 考虑**最长路**或**动态规划**。  
> 2. **操作顺序限制** → 用**分层图**建模，每层代表不同状态（未买、已买、已卖）。  
> 3. **数据规模大** → 需要**高效算法**（如SPFA或Tarjan缩点）。  
> 4. **点权转边权** → 通过分层图，将买卖操作转化为**跨层边权**。  
> **结论**：**分层图 + 最长路** 是本题的最优策略！  

---

## 2. 精选优质题解参考

经过筛选，以下题解思路清晰、代码优雅，值得深入学习：

### ✨ 题解一：fy1234567ok 的**分层图 + SPFA**（487赞）
- **亮点**：将原图复制为三层（未买、已买、已卖），通过跨层边权表示买卖操作。  
- **核心思想**：  
  - 第0层：未买，边权0（自由移动）。  
  - 第1层：已买，边权 `-a[i]`（花费）。  
  - 第2层：已卖，边权 `+a[i]`（收入）。  
- **答案**：从 `1_0` 到 `n_2` 的最长路。

### ✨ 题解二：ctzm 的**Tarjan缩点 + DAG DP**（10赞）
- **亮点**：用Tarjan算法将强连通分量缩点，转化为DAG后，在拓扑序上动态规划。  
- **核心思想**：  
  - `f[u]`：从1到u的最小买入价。  
  - `ans = max(a[v] - f[u])`，其中u可到达v，且v可到达n。

### ✨ 题解三：EricWay1024 的**BFS状态搜索**（8赞）
- **亮点**：用BFS直接搜索三种状态（未买、已买、已卖），通过剪枝优化效率。  
- **核心思想**：  
  - 状态：(pos, val)，val为当前买入价（未买时为0）。  
  - 转移：移动、买入、卖出。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：分层图）

#### **关键点1：如何建模买卖操作？**
- **分析**：将原图复制为三层，每层代表不同状态。  
- **学习笔记**：分层图是解决**状态转移类问题**的利器，尤其适用于**操作有顺序限制**的场景。

#### **关键点2：如何设置边权？**
- **分析**：  
  - 同层移动：边权0（自由移动不影响利润）。  
  - 第0层→第1层：边权 `-a[i]`（买入花费）。  
  - 第1层→第2层：边权 `+a[i]`（卖出收入）。  
- **学习笔记**：通过**边权设计**，将点权问题转化为边权问题。

#### **关键点3：如何求最长路？**
- **分析**：由于存在负权边，使用**SPFA算法**求最长路（将边权取负后求最短路）。  
- **学习笔记**：SPFA是处理**负权图**的常用算法，但需注意其最坏复杂度为O(nm)。

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力枚举** | 枚举所有买卖点对，BFS检查可达性。 | 思路直观。 | O(n²m) 超时。 | n ≤ 100。 |
| **分层图 + SPFA** | 三层图建模，求最长路。 | 思路清晰，代码简洁。 | SPFA可能被卡。 | 通用解法，100%数据。 |
| **Tarjan缩点 + DAG DP** | 缩点后拓扑序DP。 | 复杂度稳定O(n+m)。 | 实现较复杂。 | 通用解法，100%数据。 |
| **BFS状态搜索** | 直接搜索状态，剪枝优化。 | 无需分层图。 | 状态爆炸风险。 | 小规模数据。 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. **起点：暴力枚举**  
>    枚举所有点对，BFS检查可达性。但O(n²m)会超时。  
> 2. **发现瓶颈：重复计算**  
>    每个点的买卖决策独立，但路径可达性重复计算。  
> 3. **优化钥匙：分层图**  
>    将买卖操作分层，转化为最长路问题，避免重复计算。  
> 4. **模型升华：Tarjan缩点**  
>    将环缩点，转化为DAG，进一步优化效率。  

---

## 4. C++核心代码实现赏析

### 🌟 通用核心实现：分层图 + SPFA

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 5;
const int MAXM = 5e5 + 5;

int n, m, a[MAXN];
vector<pair<int, int>> G[MAXN * 3];

#define ID(x, layer) ((x) + (layer) * n)

void add_edge(int u, int v, int w) {
    G[u].emplace_back(v, w);
}

void build_graph() {
    // 层内边（移动）
    for (int i = 1; i <= m; ++i) {
        int u, v, z;
        cin >> u >> v >> z;
        for (int l = 0; l < 3; ++l) {
            add_edge(ID(u, l), ID(v, l), 0);
            if (z == 2) add_edge(ID(v, l), ID(u, l), 0);
        }
    }
    // 层间边（买卖）
    for (int i = 1; i <= n; ++i) {
        add_edge(ID(i, 0), ID(i, 1), -a[i]); // 买入
        add_edge(ID(i, 1), ID(i, 2), a[i]);   // 卖出
    }
}

int dis[MAXN * 3];
bool inq[MAXN * 3];

void spfa(int s) {
    fill(dis, dis + 3 * n + 1, INT_MIN);
    queue<int> q;
    dis[s] = 0;
    q.push(s);
    inq[s] = true;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        inq[u] = false;
        for (auto [v, w] : G[u]) {
            if (dis[v] < dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!inq[v]) {
                    q.push(v);
                    inq[v] = true;
                }
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    build_graph();
    spfa(ID(1, 0));
    cout << max(0, dis[ID(n, 2)]) << '\n';
    return 0;
}
```

---

### 💡 代码解读概要
- **分层图建模**：将每个城市复制为三层（0:未买，1:已买，2:已卖）。  
- **边权设计**：跨层边权表示买卖操作，同层边权0表示自由移动。  
- **SPFA求最长路**：从 `1_0` 到 `n_2` 的最长路即为答案。

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：**“像素商人”的贸易之旅**
- **场景**：8位像素风格的地图，城市用像素方块表示，道路用箭头连接。  
- **状态层**：三层地图垂直堆叠，每层颜色不同（绿色：未买，蓝色：已买，红色：已卖）。  
- **操作可视化**：  
  - **买入**：从绿色层跳到蓝色层，像素方块闪烁 `-a[i]` 的金币动画。  
  - **卖出**：从蓝色层跳到红色层，像素方块闪烁 `+a[i]` 的金币动画。  
  - **移动**：同层移动时，像素小人沿箭头滑动，边权0无金币变化。  
- **交互控制**：  
  - **单步执行**：点击按钮，观察每一步的状态转移。  
  - **自动播放**：小人自动寻找最长路路径，沿途高亮显示。  
  - **音效**：买入“叮”，卖出“哗啦”，移动“哒哒”。  

---

## 6. 拓展练习与相似问题思考

### 📚 通用思路迁移
分层图思想适用于：
1. **多次操作限制**：如“最多k次免费通行”。  
2. **状态转移问题**：如“钥匙开门”、“状态压缩”。  
3. **多阶段决策**：如“动态规划 + 图论”结合。

### 🏆 洛谷推荐练习
1. **P2939 [USACO09FEB]改造路Revamping Trails**  
   - 分层图经典题，练习k次免费通行。  
2. **P4568 [JLOI2011]飞行路线**  
   - 分层图 + 最短路，边权可变为0。  
3. **P4822 [BJWC2012]冻结**  
   - 分层图 + 时间限制，动态规划思想。

---

## 7. 学习心得与经验分享

> **来自fy1234567ok**：  
> “分层图的关键在于**状态抽象**，把买卖操作转化为**跨层边权**。一开始我也试图暴力枚举，但数据范围让我意识到必须优化。分层图就像给图论问题加了‘维度’，让复杂问题变得清晰。”  

> **洛语云笺点评**：  
> 分层图不仅是技巧，更是**思维方式的升华**。学会将“操作”抽象为“状态”，是算法进阶的重要一步！

---

### 🎉 结语
今天，我们学会了如何用**分层图**解决复杂图论问题，从暴力枚举到优雅建模，每一步都是思维的飞跃。  
记住：**好的算法源于对问题本质的洞察**。下次遇到类似问题，不妨试试分层图！  
继续加油，小小探险家们！🚀

---
处理用时：68.33秒
# 题目信息

# 电王的传送迷宫

## 题目背景

电王天天玩传送门。

## 题目描述

给出一个大小为 $n\times m$ 的二维网格图。

网格上的 `.` 是可以通行的路径，`#` 是不能通行的障碍。

你每次可以走到一个与当前位置四连通的且不超过边界的点。

严格来说，若你当前在点 $(x,y)$，你可以走到 $(x-1,y),(x+1,y),(x,y-1),(x,y+1)$ 中的一个，并且保证在任意时刻你的坐标 $(x,y)$ 应该满足 $1\le x\le n,1\le y\le m$。

我们从起点 $(sx,sy)$ 出发，你希望知道到达任意一个位置至少要走几步。

但这太简单了，于是精通传送门的电王在这个网格图上建造了 $p$ 个传送门，它们的坐标分别为 $(a_1,b_1),(a_2,b_2),...,(a_p,b_p)$。

而电王也设计了 $q$ 个终点，它们的坐标分别为 $(c_1,d_1),(c_2,d_2),...,(c_q,d_q)$。

假如你使用了 $i$ 次传送门，当你到达任意一个传送门，你可以选择直接传送到点 $(c_{i+1},d_{i+1})$。而第 $q$ 次传送后，所有的传送门都会失效。

**所以，传送到的位置只与你传送的次数有关，而与你到达了哪个传送门没有任何关系，我们可以认为所有传送门都是等价的。**

**保证 $p$ 个传送门和 $q$ 个终点的位置都不是障碍。**

保证对于任意输入给出的坐标对应的位置上都是可以通行的路径，且这些坐标一定两两不同。

但电王有的时候并不想知道到去往任意点最少要移动几步，可能他只想知道到一个终点 $(tx,ty)$ 的最少移动步数，我们会在输入格式中了解这个测试点电王的喜好（保证 $tx,ty$ 不是一个障碍）。

## 说明/提示

样例解释：

我们以从起点 $(3,4)$ 去往 $(1,1)$ 为例：首先 $(3,4)\to(2,4)$，然后使用传送门，第一次传送到 $(1,4)$。然后 $(1,4)\to (2,4)$，第二次使用传送门，到达点 $(2,1)$，最后 $(2,1)\to(1,1)$，我们使用了两次传送门，行走了 $3$ 步，所以这个路径方案的移动次数是 $3$，可以证明不存在比这更优的方案了。

**本题采用捆绑测试**。

| $\text{Subtask}$ | 分数 | $n,m,p,q$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $p=q=0$ | 无特殊限制 |
| $2$ | $20$ | $p=1$ | 无特殊限制 |
| $3$ | $20$ | $1\le n,m,p,q\le 500$ | 无特殊限制 |
| $4$ | $20$ | 无特殊限制 | $A$ |
| $5$ | $10$ | 无特殊限制 | $B$ |
| $6$ | $20$ | 无特殊限制 | 无特殊限制 |

$A$：保证 $opt=1$。

$B$：保证网格中不存在不可通行的障碍 `#`。

对于所有数据，满足 $1\le n,m\le 1000,0\le p,q\le n\times m,0 \leq opt \leq 1$。

## 样例 #1

### 输入

```
0
3 4
.#..
..#.
....
3 4 1 2 
2 4
1 4
2 1```

### 输出

```
3 -1 2 1
2 3 -1 1
3 2 1 0```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：电王的传送迷宫 深入学习指南 💡

> 今天，我们化身「像素迷宫探险家」，一起破解电王的传送迷宫！这不仅是一道网格最短路问题，更是一场关于“如何优雅地处理多层状态”的思维盛宴。准备好，出发！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在一张带障碍的网格中，起点出发可以“四联通行走”或“使用传送门”。  
**传送规则**——第 i 次使用任意传送门，必定传送到第 i 个固定终点；传送次数 ≤ q。  
求：从起点到所有点（或指定终点）的最小步数。

✨ **核心算法标签**  
- 0-1 BFS / Dijkstra  
- 多源最短路  
- 分层思想（逻辑层而非显式建层）  

🗣️ **初步分析**  
1. **朴素暴力**：把“传送次数”当作层数，建 q+1 层网格图 → 边数 O(nmq) 爆炸。  
2. **逆向思维**：发现“传送顺序固定”，可转化为“从哪些关键点出发 + 多源最短路”。  
3. **最优策略**：  
   - 先以所有传送门为源 0-1 BFS，求出任意点到“最近传送门”的距离。  
   - 用这些距离把“传送代价”预处理为前缀和。  
   - 再以起点 + 所有传送终点为“虚拟源”，跑第二次 0-1 BFS / Dijkstra。  
   时间复杂度 O(nm) 或 O(nm log nm)。

💡 **比喻**  
把传送门看作“地铁入口”，每个终点是“强制停靠的站”。我们只需计算：  
“从当前站到任意入口的步行距离” + “已坐地铁的票价前缀和”。  
这样就把“无限层”压缩成“一张图 + 若干虚拟边”。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：最短路** | 出现“最少步数/距离”，立即想到 BFS/Dijkstra。 |
| **线索2：多源** | 所有传送门等价 → 多源最短路模板。 |
| **线索3：顺序依赖** | 传送必须按 c₁→c₂→…→c_q 顺序 → 可用前缀和把代价线性化。 |
| **线索4：数据范围** | n,m ≤ 1000 → O(nm log nm) 可过；O(nmq) 会炸。 |

### 🧠 思维链构建：从线索到策略
> “侦探”视角：  
> 1. 看到最短路 → 选 BFS（边权1）或 Dijkstra。  
> 2. 看到“任意传送门→第 i 终点”固定 → 把传送次数 k 转化为“已付代价 S_k”。  
> 3. S_k 可以递推：S_k = S_{k-1} + dist(c_{k-1} → 最近传送门)。  
> 4. 于是只需两次最短路：  
>   - 第一次求“任意点到最近传送门”；  
>   - 第二次把 S_k 作为虚拟边权，跑单源最短路。  
> 5. 复杂度 O(nm) / O(nm log nm)，优雅通过！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|---|---|
| **_LiWenX_** (5赞) | 0-1 BFS 两次，O(nm)；代码精简，用指针技巧把“虚拟边”塞进普通队列。 |
| **封禁用户** (4赞) | 逆向多源 BFS + 队列“跳跃插入”技巧，讲解配像素图，可视化极佳。 |
| **Night_sea_64** (2赞) | Dijkstra 两次，O(nm log nm)，思路清晰，封装良好，STL 运用娴熟。 |
| **哈哈人生** (1赞) | 建图思路讲解详尽，用“贪心+前缀和”把传送代价线性化，适合初学者。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：0-1 BFS ×2）

1. **关键点1：如何把“传送层”压掉？**  
   - 观察：传送顺序固定 → 代价可前缀和。  
   - 设 `f[i]` 为传送到第 i 个终点所需总代价（含前 i-1 次传送）。  
   - `f[i] = f[i-1] + dist(c_{i-1}, 最近传送门)`。

2. **关键点2：如何求“任意点到最近传送门”？**  
   - 多源 0-1 BFS：把所有传送门坐标入队，边权为1，跑出 `d1[x][y]`。  
   - 时间 O(nm)。

3. **关键点3：如何合并“步行 + 传送”？**  
   - 第二次 0-1 BFS：  
     - 起点 `(sx,sy)` 初始距离 0。  
     - 对每个 i，当当前最短路长度恰好 = `f[i]` 时，把 `(c[i], d[i])` 以距离 `f[i]` 入队。  
     - 用指针 `now` 维护“下一次应插入的终点”，队列天然单调，无需优先队列。  
   - 时间 O(nm)。

💡 **学习笔记**  
- 把“层”转化为“前缀和”是处理顺序依赖的经典技巧。  
- 0-1 BFS 队列的单调性允许我们“延迟插入”虚拟节点，避免 log。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **分层图 + BFS** | 建 q+1 层网格，层间传送边 | 思路直观 | 边数 O(nmq) 爆炸 | 20% |
| **分层图 + Dijkstra** | 同上，堆优化 | 易写 | 同上 + log | 30% |
| **0-1 BFS ×2** (最优) | 前缀和 + 两次 0-1 BFS | O(nm) 最简 | 需单调队列技巧 | 100% |
| **Dijkstra ×2** | 同上，但用堆 | O(nm log nm) | 常数稍大 | 100% |

---

### ✨ 优化之旅：从“能做”到“做好”
> 从朴素分层 → 发现“传送顺序固定” → 前缀和压缩 → 0-1 BFS 单调队列插入  
> 思维跃迁：把“无限层”压成“有限关键点 + 虚拟边”。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（0-1 BFS ×2）

> 综合 _LiWenX_ 与 封禁用户 思路，提供 O(nm) 简洁版。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1005;
const ll INF = 1e18;
int n, m, opt, sx, sy, tx, ty, p, q;
char g[N][N];
ll d1[N][N], ans[N][N], f[N * N];
int px[N * N], py[N * N], cx[N * N], cy[N * N];

const int dx[4] = {-1, 1, 0, 0};
const int dy[4] = {0, 0, -1, 1};

inline bool valid(int x, int y) {
    return 1 <= x && x <= n && 1 <= y && y <= m && g[x][y] == '.';
}

void bfs01(queue<pair<int, int>>& q, ll dis[][N]) {
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) dis[i][j] = INF;
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (int k = 0; k < 4; ++k) {
            int nx = x + dx[k], ny = y + dy[k];
            if (valid(nx, ny) && dis[nx][ny] > dis[x][y] + 1) {
                dis[nx][ny] = dis[x][y] + 1;
                q.emplace(nx, ny);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> opt >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> (g[i] + 1);
    cin >> sx >> sy >> p >> q;
    if (opt) cin >> tx >> ty;

    // 1. 多源 0-1 BFS 求任意点到最近传送门
    queue<pair<int, int>> Q1;
    for (int i = 1, x, y; i <= p; ++i) {
        cin >> x >> y;
        Q1.emplace(x, y);
        d1[x][y] = 0;
    }
    bfs01(Q1, d1);

    // 2. 计算 f[i]：传送到第 i 终点的总代价
    cx[0] = sx, cy[0] = sy;
    for (int i = 1; i <= q; ++i) cin >> cx[i] >> cy[i];
    f[0] = 0;
    for (int i = 1; i <= q; ++i) {
        if (d1[cx[i-1]][cy[i-1]] == INF) f[i] = INF;
        else f[i] = f[i-1] + d1[cx[i-1]][cy[i-1]];
    }

    // 3. 第二次 0-1 BFS，虚拟源
    queue<pair<int, int>> Q2;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) ans[i][j] = INF;
    Q2.emplace(sx, sy);
    ans[sx][sy] = 0;

    int ptr = 1;
    ll cur = 0;
    while (!Q2.empty() || (ptr <= q && f[ptr] != INF)) {
        // 先插入所有 f[ptr] == cur 的终点
        while (ptr <= q && f[ptr] == cur) {
            int x = cx[ptr], y = cy[ptr];
            if (ans[x][y] > cur) {
                ans[x][y] = cur;
                Q2.emplace(x, y);
            }
            ++ptr;
        }
        if (Q2.empty()) { cur = f[ptr]; continue; }
        int sz = Q2.size();
        while (sz--) {
            auto [x, y] = Q2.front(); Q2.pop();
            for (int k = 0; k < 4; ++k) {
                int nx = x + dx[k], ny = y + dy[k];
                if (valid(nx, ny) && ans[nx][ny] > cur + 1) {
                    ans[nx][ny] = cur + 1;
                    Q2.emplace(nx, ny);
                }
            }
        }
        ++cur;
    }

    if (opt) cout << (ans[tx][ty] == INF ? -1 : ans[tx][ty]);
    else {
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= m; ++j)
                cout << (ans[i][j] == INF ? -1 : ans[i][j]) << " \n"[j == m];
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 像素风演示主题  
**“传送迷宫探险”** —— 8位红白机风格，像素小人在网格中奔跑，传送门闪光。

### 🎨 设计思路
- **场景**：n×m 像素网格，障碍为灰色方块，可走路径为绿色。  
- **传送门**：黄色闪烁像素星；终点：蓝色旗帜。  
- **动画帧**  
  1. **初始化**：地图加载，传送门高亮黄色。  
  2. **第一次 0-1 BFS**：  
     - 所有传送门同时“爆炸”出黄色波纹（多源）。  
     - 波纹以1像素/帧扩散，数字实时显示步数。  
  3. **前缀和计算**：屏幕顶部 HUD 展示 `f[1], f[2], ...` 像素数字滚动。  
  4. **第二次 0-1 BFS**：  
     - 起点小人出现，每移动一格播放“嗒嗒”8位音。  
     - 当当前步数 = f[i] 时，蓝色旗帜位置出现“传送闪光”，小人瞬移。  
  5. **完成**：所有可达点点亮，播放胜利音效。  

### 🕹️ 交互面板
- **步进 / 自动**：可逐帧或 60FPS 自动播放。  
- **速度滑块**：1-10 倍速。  
- **音效开关**：8位音 + 背景音乐。  

---

## 6. 拓展练习与相似问题思考

### 通用套路迁移
- **多源最短路** 常用于：  
  1. 火灾逃生：多个出口求最近安全点。  
  2. 公交换乘：多条线路起点 → 任意站最短时间。  
  3. 多起点救援：多个救援队到灾区最短时间。

### 洛谷推荐
- **P3371**【模板】单源最短路径（弱化版）  
  🗣️ 巩固最短路模板，体验不同算法实现。  
- **P1825** [USACO11OPEN] Corn Maze  
  🗣️ 网格图 + 传送门变形，锻炼建模能力。  
- **P4779**【模板】单源最短路径（标准版）  
  🗣️ 掌握堆优化 Dijkstra，为更复杂图论打基础。  

---

## 7. 学习心得与经验分享

> **封禁用户**：“调试时把 `f[i]` 打印出来，发现前缀和爆 long long，把 INF 设成 1e18 就过了。”  
> **洛语云笺点评**：处理极大值时，务必估算最坏路径长度（q×nm），并留足余量。

> **Night_sea_64**：“用 `pair<int,int>` 存坐标比手写 struct 更简洁，但注意哈希冲突。”  
> **洛语云笺点评**：坐标压缩技巧虽好，但边界检查不可省。

---

<conclusion>
恭喜你完成本次“像素迷宫探险”！  
记住：遇到“顺序依赖”时，先想能否用前缀和压缩；遇到“多源”时，先想能否一次性 BFS。  
保持好奇，继续探索下一道算法谜题！🎮✨
</conclusion>
```

---
处理用时：78.36秒
# 题目信息

# [NOIP 2004 提高组] 虫食算

## 题目描述

所谓虫食算，就是原先的算式中有一部分被虫子啃掉了，需要我们根据剩下的数字来判定被啃掉的数字。来看一个简单的例子：

$$\begin{aligned}
 \verb!43#9865#045! \\
+\qquad \verb!8468#6633! \\[-1em]\underline{\kern{8em}} \\
 \verb!44445509678! \\
\end{aligned}$$

其中 `#` 号代表被虫子啃掉的数字。根据算式，我们很容易判断：第一行的两个数字分别是 $5$ 和 $3$，第二行的数字是 $5$。

现在，我们对问题做两个限制：

首先，我们只考虑加法的虫食算。这里的加法是 $n$ 进制加法，算式中三个数都有 $n$ 位，允许有前导的 $0$。

其次，虫子把所有的数都啃光了，我们只知道哪些数字是相同的，我们将相同的数字用相同的字母表示，不同的数字用不同的字母表示。如果这个算式是 $n$ 进制的，我们就取英文字母表的前 $n$ 个大写字母来表示这个算式中的 $0$ 到 $n - 1$ 这 $n$ 个不同的数字：但是这 $n$ 个字母并不一定顺序地代表 $0$ 到 $n-1$。输入数据保证 $n$ 个字母分别至少出现一次。

$$\begin{aligned}
 \verb!BADC! \\
+\quad \verb!CBDA! \\[-1em]\underline{\kern{4em}} \\
 \verb!DCCC! \\
\end{aligned}$$

上面的算式是一个4进制的算式。很显然，我们只要让 $\verb!ABCD!$ 分别代表 $0123$，便可以让这个式子成立了。你的任务是，对于给定的 $n$ 进制加法算式，求出 $n$ 个不同的字母分别代表的数字，使得该加法算式成立。输入数据保证有且仅有一组解。


## 说明/提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 10$；
- 对于 $50\%$ 的数据，保证 $n \le 15$；
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 26$。

## 样例 #1

### 输入

```
5
ABCED
BDACE
EBBAA
```

### 输出

```
1 0 3 4 2
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：虫食算 深入学习指南 💡

> 今天我们来一起分析“虫食算”这道 NOIP 2004 提高组经典题。  
> 它不仅考验我们对 **n 进制加法** 的理解，更是一场 **搜索剪枝艺术** 的盛宴。  
> 我们将从“暴力枚举”起步，逐步进化到“位级剪枝”，最终领略“高斯消元”的数学之美。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在 n 进制下，给定一个竖式（三个长度为 n 的字符串，用前 n 个大写字母表示 0~n-1），要求为每个字母分配互不相同的数字，使得竖式成立。

✨ **核心算法标签**：`搜索(DFS)` `剪枝` `高斯消元`

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题规模)**：  
   n ≤ 26，**26! 的全排列** 直接爆炸。提示我们：必须剪枝！

2. **线索2 (运算性质)**：  
   只有加法 → **进位只能是 0 或 1**；  
   竖式从低位到高位计算 → **按位 DFS** 更自然。

3. **线索3 (字母唯一性)**：  
   每个字母对应唯一数字 → **状态压缩** 与 **used 数组** 必备。

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，**线索1** 告诉我们暴力枚举全排列不可行 → 需要 **剪枝**。  
> 2. **线索2** 提示：加法竖式天然 **从低位到高位** 计算 → 我们可以 **按位 DFS**（从右往左），每一步只需关注当前位的字母是否已赋值、当前进位。  
> 3. **线索3** 要求字母互不相同 → 用 `used[26]` 记录已用数字。  
> 4. 综合：  
>    - **搜索框架**：DFS(pos, carry) —— 正在处理第 pos 位，当前进位为 carry。  
>    - **剪枝点**：  
>      - 若当前位三个字母都已知，则 `(A+B+carry)%n` 必须等于 `C`，否则剪枝。  
>      - 最高位进位必须为 0。  
> 5. 进阶：将竖式转化为线性方程组 → **高斯消元** 求通解，再枚举自由变量（作者 BakaC1rno 的做法）。

---

## 2. 精选优质题解参考

### 题解一：zzlzk（搜索 + 双剪枝）
> 这份题解用 **从右往左按字母顺序 DFS**，配合两大剪枝：  
> 1. 最高位不能有进位；  
> 2. 若当前位已知两数之和（±进位）≠ 第三数，则剪枝。  
> 代码中的 `CanPrune()` 和 `Judge()` 清晰体现了剪枝逻辑。  
> **亮点**：`Next` 数组优化搜索顺序（先搜出现次数多的字母）。

### 题解二：feecle6418（搜索 + 位级剪枝）
> 将搜索顺序改为 **从低位到高位**，每一步 **知二求一**（若已知两个字母，可唯一确定第三个）。  
> 剪枝更精细：  
> - 若某一位三个字母都已知，直接验证；  
> - 若已知两个，可 O(1) 推出第三个并检查冲突。  
> **亮点**：`dfs(pos)` 从 `n-1` 到 `0`，符合竖式计算习惯。

### 题解三：BakaC1rno（高斯消元 + DFS）
> 将竖式转化为线性方程组，用高斯消元求出每个字母的通解（形如 `x_i = f(r)`），再 DFS 枚举进位变量 `r`。  
> **亮点**：数学化建模，将搜索空间从 26! 降到 2^n（n ≤ 26 时 2^26 ≈ 6.7×10^7，可接受）。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 & 学习笔记 |
|--------|-----------------|
| **1. 搜索顺序设计** | 从低位到高位 DFS（如 feecle6418），每一步只需关注当前位及进位，天然符合竖式计算顺序。💡 **学习笔记**：搜索顺序决定剪枝效率！ |
| **2. 知二求一剪枝** | 若某一位已知两个字母，可直接推出第三个，并立即检查冲突。💡 **学习笔记**：利用确定性信息提前剪枝，避免无效分支。 |
| **3. 高斯消元建模** | 将竖式写成方程组：`(A_i + B_i + carry_i) % n = C_i`，转化为 `A_i + B_i - C_i + carry_{i-1} - n * carry_i = 0`。💡 **学习笔记**：数学建模可将搜索问题转化为线性代数问题。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|------|----------|------|------|----------|
| **暴力全排列** | 枚举 0~n-1 的全排列 | 思路直观 | O(n!)，n=11 就超时 | 30% |
| **搜索 + 剪枝** | 按位 DFS + 知二求一 | 剪枝强力，代码简洁 | 最坏仍指数级，但可 AC | 100% |
| **高斯消元** | 线性方程组 + DFS 自由变量 | 数学优雅，搜索空间小 | 实现复杂，需线性代数基础 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心代码（搜索 + 位级剪枝）
> 综合 feecle6418 与 zzlzk 的精华，按位 DFS，知二求一剪枝。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 30;
int n, num[N], used[N], pos[N], tot;
char s[3][N];

// 当前处理第 p 位（从右往左，0~n-1），进位为 carry
bool check(int p, int carry) {
    for (int i = n - 1; i >= p; --i) {
        int a = num[s[0][i] - 'A'];
        int b = num[s[1][i] - 'A'];
        int c = num[s[2][i] - 'A'];
        if (a == -1 || b == -1 || c == -1) continue;
        if ((a + b + carry) % n != c) return false;
        carry = (a + b + carry) / n;
    }
    return carry == 0; // 最高位进位必须为 0
}

void dfs(int p, int carry) {
    if (p == -1) {
        if (carry == 0) {
            for (int i = 0; i < n; ++i) cout << num[i] << " \n"[i == n - 1];
            exit(0);
        }
        return;
    }
    int a = s[0][p] - 'A', b = s[1][p] - 'A', c = s[2][p] - 'A';
    // 情况 1：a, b, c 都已知
    if (num[a] != -1 && num[b] != -1 && num[c] != -1) {
        int sum = num[a] + num[b] + carry;
        if (sum % n == num[c]) dfs(p - 1, sum / n);
        return;
    }
    // 情况 2：已知 a, b，求 c
    if (num[a] != -1 && num[b] != -1) {
        int need = (num[a] + num[b] + carry) % n;
        if (num[c] == -1 && !used[need]) {
            num[c] = need; used[need] = 1;
            dfs(p - 1, (num[a] + num[b] + carry) / n);
            num[c] = -1; used[need] = 0;
        }
        return;
    }
    // 情况 3：已知 a, c，求 b
    if (num[a] != -1 && num[c] != -1) {
        int need = (num[c] - carry - num[a] + n) % n;
        if (num[b] == -1 && !used[need]) {
            num[b] = need; used[need] = 1;
            dfs(p - 1, (num[a] + num[b] + carry) / n);
            num[b] = -1; used[need] = 0;
        }
        return;
    }
    // 情况 4：已知 b, c，求 a（对称）
    if (num[b] != -1 && num[c] != -1) {
        int need = (num[c] - carry - num[b] + n) % n;
        if (num[a] == -1 && !used[need]) {
            num[a] = need; used[need] = 1;
            dfs(p - 1, (num[a] + num[b] + carry) / n);
            num[a] = -1; used[need] = 0;
        }
        return;
    }
    // 情况 5：枚举未知字母
    for (int d = n - 1; d >= 0; --d) if (!used[d]) {
        // 优先填未知字母，减少分支
        if (num[a] == -1) {
            num[a] = d; used[d] = 1;
            dfs(p, carry);
            num[a] = -1; used[d] = 0;
        } else if (num[b] == -1) {
            num[b] = d; used[d] = 1;
            dfs(p, carry);
            num[b] = -1; used[d] = 0;
        } else if (num[c] == -1) {
            int sum = num[a] + num[b] + carry;
            if (sum % n == d) {
                num[c] = d; used[d] = 1;
                dfs(p - 1, sum / n);
                num[c] = -1; used[d] = 0;
            }
        }
    }
}

int main() {
    cin >> n;
    for (int i = 0; i < 3; ++i) cin >> s[i];
    memset(num, -1, sizeof(num));
    dfs(n - 1, 0);
    return 0;
}
```

---

### 高斯消元代码片段（BakaC1rno）
> 将竖式写成方程组，高斯消元后 DFS 枚举进位变量。

```cpp
// 核心：构造系数矩阵 squre.coe[i][j] 和常数项 squre.con[i][j]
// 消元后，每个字母的值为 x_i = (Σ con[i][j] * r_j) / coe[i][i]
// 再 DFS 枚举 r_j ∈ {0, 1}（进位变量）
```

---

## 5. 算法可视化：像素动画演示

> **主题**：像素小人在竖式迷宫中，从右往左逐位点亮字母，每一步伴随“叮”的音效和颜色高亮。

- **场景**：8×n 像素网格，三行字母，低位在右。
- **交互**：
  - 单步/自动播放。
  - 当前处理的位闪烁，已知字母高亮绿色，未知字母灰色。
  - 知二求一时，第三个字母瞬间填充并伴随“叮”声。
- **游戏化**：每正确填充一位，像素小人跳一格；全部正确后播放胜利音效。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **按位 DFS + 剪枝**：适用于所有 **竖式类** 问题（如减法、乘法、除法竖式）。
- **知二求一**：适用于 **已知部分信息可唯一确定剩余信息** 的场景（如数独、填字游戏）。

### 洛谷推荐
1. **P1219 八皇后**  
   🗣️ 同样是 DFS + 剪枝，练习按行/列/对角线剪枝。
2. **P1312 数独**  
   🗣️ 知二求一的极致应用：已知行列宫格，唯一确定数字。
3. **P1434 靶形数独**  
   🗣️ 在数独基础上增加评分规则，需权衡剪枝与得分。

---

## 7. 学习心得与经验分享

> **来自 zzlzk**：  
> “我在调试时发现，剪枝条件写错一个符号，导致直接剪掉正确解。  
> 建议：先写暴力搜索，再逐步添加剪枝，每一步都打印中间状态验证。”

💡 **洛语云笺点评**：  
逐步验证是调试搜索算法的黄金法则。先确保暴力正确，再优化剪枝，可避免“剪枝剪到正确答案”的悲剧。

---

<conclusion>
虫食算是一道 **搜索剪枝艺术** 的典范。从暴力到高斯消元，我们看到了 **问题建模** 与 **剪枝设计** 的力量。  
记住：好的搜索 = 清晰的搜索顺序 + 强力的剪枝。下次我们再一起挑战更复杂的竖式！
</conclusion>

---
处理用时：62.30秒
# 题目信息

# [ZJOI2007] 矩阵游戏

## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。


## 说明/提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。


## 样例 #1

### 输入

```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0
```

### 输出

```
No
Yes
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[ZJOI2007] 矩阵游戏 深入学习指南 💡

<introduction>
同学们好！今天我们要一起攻克一道“看似魔幻、实则巧妙”的矩阵谜题——[ZJOI2007] 矩阵游戏。  
核心任务只有一句话：给定一个黑白方阵，能否通过若干次**任意两行或两列交换**，让主对角线（左上到右下）全变成黑色？  
别被“交换”吓到，咱们会像侦探一样抽丝剥茧，最终发现：这道题其实是**二分图最大匹配**的“变形记”！
</introduction>

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> “交换”操作会让矩阵看起来变化莫测，但真正关键的是：**哪些黑格子最终能各就各位地落在对角线上？**  
> 换句话说，我们需要**n 个黑格子，两两不同行也不同列**，这样才能把它们通过交换“搬”到对角线。

✨ **核心算法标签**：二分图最大匹配（匈牙利 / Dinic）

🗣️ **初步分析**：  
- 如果暴力枚举所有交换序列，复杂度爆炸。  
- 但交换有一个“守恒”特性：同一行的黑格子永远在同一行，同一列的黑格子永远在同一列。  
- 于是问题转化为：**能否选出 n 个黑格子，构成一个“行列互不侵犯”的集合？**  
- 这正是**二分图完美匹配**的经典模型！

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **问题目标** | “让主对角线全黑” ⇨ 需要 n 个黑格子，行号、列号各出现一次。 |
| **操作特性** | 任意交换行/列 ⇨ 不改变**一行或一列内黑格子的数量与相对位置**。 |
| **数据规模** | n ≤ 200，边数 ≤ 200×200 = 4×10⁴，匈牙利 O(n³)≈8×10⁶ 可过，Dinic O(n²√n)≈1.6×10⁵ 更快。 |

### 🧠 思维链构建：从线索到策略
> 1. 侦探发现：只要存在**n 个黑格子，行列互不重复**，就能通过交换把它们排到对角线。  
> 2. 把“行”看作二分图左部，“列”看作右部；黑格子(i,j)就是一条边 i→j。  
> 3. 跑**最大匹配**，若匹配数 = n，则存在完美匹配，输出 `Yes`；否则 `No`。  
> 4. 结论：把“矩阵游戏”翻译成“二分图匹配”，一击必杀！

---

## 2. 精选优质题解参考

<eval_intro>
下面精选 5 份高赞题解，统一用**匈牙利算法**讲解，带你体会“不同写法，同一内核”的魅力。
</eval_intro>

| 题解 | 作者 | 亮点提要 | 学习指引 |
|---|---|---|---|
| **1** | 俾斯麦 | 图文并茂，手把手推导出“交换不改变匹配数” | 先看推导，再读代码 |
| **2** | cmwqf | 用**邻接矩阵**存图，最简洁的匈牙利模板 | 初学必背 |
| **3** | Azuree | 指出“只交换行即可”，降低思维难度 | 理解“行列等价” |
| **4** | 是个汉子 | 用**时间戳**优化 `vis` 数组，避免 `memset` | 提速小技巧 |
| **5** | lemir3 | 博客排版+多图，适合二次阅读 | 复习巩固 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 建模** | 建二分图：左部 1…n（行），右部 n+1…2n（列），黑格子(i,j) 加边 i→j+n | 把“选格子”转成“选边” |
| **2. 匈牙利算法** | 对每个左部节点跑 DFS 找增广路；用 `match[y]` 记录右部 y 匹配的左部节点 | 模板要背熟 |
| **3. 复杂度优化** | 用**时间戳**替代 `memset(vis)`，可把常数减半 | 多组数据必备 |

### ✨ 解题技巧总结
- **行列守恒**：交换不改变**一行/列内黑格子的集合**，因此只需关心“能否选出 n 个黑格子互不冲突”。  
- **时间戳优化**：`vis[y] = tim`，每轮 `tim++`，避免频繁清空数组。  
- **多组数据清零**：只清空用到的边、数组，节省常数。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 复杂度 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|---|
| **暴力 DFS** | 枚举所有交换序列 | O((n!)²) | 思路直接 | n>7 即爆 | 20% 数据 |
| **匈牙利** | 二分图最大匹配 | O(n³)≈8×10⁶ | 代码短，易调试 | n=200 略卡 | 100% 数据 |
| **Dinic** | 网络流最大流 | O(n²√n)≈1.6×10⁵ | 更快，模板通用 | 代码较长 | 100% 数据 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（匈牙利 + 时间戳）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 405, M = N * N;

int n, T, tot, head[N], nxt[M], to[M];
int match[N], tim, vis[N];

void add(int u, int v) {
    nxt[++tot] = head[u];
    to[tot] = v;
    head[u] = tot;
}

bool dfs(int u) {
    for (int i = head[u], v; i; i = nxt[i]) {
        v = to[i];
        if (vis[v] != tim) {
            vis[v] = tim;
            if (!match[v] || dfs(match[v])) {
                match[v] = u;
                return true;
            }
        }
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> T;
    while (T--) {
        cin >> n;
        tot = 0;
        memset(head, 0, sizeof head);
        memset(match, 0, sizeof match);
        for (int i = 1; i <= n; ++i)
            for (int j = 1, x; j <= n; ++j) {
                cin >> x;
                if (x) add(i, j + n);
            }
        int ans = 0;
        for (int i = 1; i <= n; ++i) {
            ++tim;
            ans += dfs(i);
        }
        cout << (ans == n ? "Yes" : "No") << '\n';
    }
    return 0;
}
```

- **代码解读概要**：  
  1. 建图：行 1…n，列 n+1…2n，黑格子加边。  
  2. 匈牙利：每轮 `tim++` 作为时间戳，避免重复 `memset`。  
  3. 若匹配数 = n，则存在完美匹配，输出 `Yes`。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
让我们用 8 位像素风小游戏，把“匈牙利找增广路”演给你看！
</visualization_intro>

- **场景**：像素方阵（n×n），黑格子用黑色方块，白格子用白色方块。  
- **角色**：  
  - 红色像素箭头：当前 DFS 的行节点。  
  - 蓝色像素方块：已被匹配的列节点。  
  - 绿色闪光：发现新的增广路！  
- **交互面板**：  
  - 单步/自动播放按钮。  
  - 速度滑块（1-10 帧/秒）。  
  - 音效：  
    - “叮”——成功匹配一条边；  
    - “胜利音”——匹配数达到 n。  
- **动画步骤**：  
  1. 初始化：把矩阵变成二分图，左右部节点闪烁。  
  2. DFS 开始：红色箭头从左部节点出发，沿边搜索。  
  3. 回溯/增广：遇到冲突节点，像素箭头回溯并寻找新路径；成功时绿色闪光沿增广路播放。  
  4. 结束：若 n 条增广路全部找到，主对角线黑格子依次亮起，播放胜利音效。

---

## 6. 拓展练习与相似问题思考

- **通用套路迁移**：  
  1. **任务分配**：把任务看作左部，人员看作右部，边表示“能做”，求最大匹配。  
  2. **课程冲突**：把课程看作左部，时间段看作右部，边表示“可安排”，求能否全部排满。  
  3. **棋盘覆盖**：给定残缺棋盘，能否用 1×2 多米诺骨牌不重叠地覆盖？也可转二分图匹配。

- **洛谷推荐**  
  1. **P3386** 【模板】二分图最大匹配 —— 匈牙利裸题，练手必备。  
  2. **P2756** 飞行员配对方案问题 —— 经典任务分配模型。  
  3. **P2055** 假期的宿舍 —— 带限制的二分图匹配，锻炼建模。

---

## 7. 学习心得与经验分享

> **来自 707001933K 的踩坑记录**：  
> “WA 了 7 次才 A，原因是 Dinic 模板里 `if(used==0) level[T]=-1;` 写成 `level[T]=-1` 导致死循环。”  
> **洛语云笺点评**：  
> 网络流模板细节多，建议用**静态数组+宏定义**防手滑，并准备**小数据自测**！

---

<conclusion>
今天我们从“行列交换”的表象，挖掘出“二分图匹配”的本质，并用匈牙利算法优雅解决。  
记住：  
- 交换操作不改变行列集合，只改变编号。  
- 把“选格子”翻译成“选匹配边”，复杂问题立刻迎刃而解。  
下次遇到类似“能否通过交换/重排达到某种排列”的题目，别忘了想想**二分图匹配**哦！  
祝大家编程愉快，我们下道题再见！💪
</conclusion>

---
处理用时：63.10秒
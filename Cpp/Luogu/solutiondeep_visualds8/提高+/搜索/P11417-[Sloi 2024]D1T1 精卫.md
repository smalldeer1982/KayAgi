# 题目信息

# [Sloi 2024]D1T1 精卫

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/p38htsuu.png)

## 题目描述

$f(x)$ 为积性函数，且满足 $f(p^k)=p^{2k}+k$（$p$ 为素数）。

令 $g(x)=\prod\limits_{d|x}f(d)\space \bmod\space (10^9+7)$ ，请计算 $g(i)\space (1\le i \le n)$ 的异或和。

## 说明/提示

**本题采用捆绑测试**

| Subtask | n | Score |
| :----------: | :----------: | :----------: |
| $1$ | $\le10^4$ | $10$ |
| $2$ | $\le 5\times 10^6$ | $30$ |
| $3$ | $\le 2\times 10^7$ | $30$ |
| $4$ | $\le 5\times10^7$ | $30$ |

对 $100\%$ 的数据，$1\le n \le 5\times10^{7} $。


## 样例 #1

### 输入

```
5```

### 输出

```
78```

## 样例 #2

### 输入

```
142857```

### 输出

```
67850062```

## 样例 #3

### 输入

```
10000000```

### 输出

```
505679580```

# AI分析结果

# 💡 洛语云笺的C++算法解析：精卫 深入学习指南 💡

> 各位小探险家们，欢迎来到“精卫”这片神秘的数学大陆！  
> 今天我们要一起拆解的，是一道**积性函数 + 前缀异或**的综合题。它表面上在问“异或和”，骨子里却考察**如何把复杂函数拆解成素数幂的独立决策**，再用**搜索 + 记忆化**或**分段线性筛**优雅地算出结果。  
> 准备好了吗？让我们像侦探一样寻找线索，再像游戏设计师一样把算法变成像素动画！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> **把两个看起来“纠缠”的函数 \(f,g\) 拆成素数幂级别的独立贡献**，并在 \(n\le 5\times 10^7\) 的约束下**线性或近线性**地求出所有 \(g(i)\) 的异或和。

### ✨ 核心算法标签
- **积性函数理论**
- **数论分块 / 分段筛**
- **记忆化 DFS（枚举素数幂）**
- **光速幂 / 离散对数优化（可选）**

### 🗣️ 初步分析
1. **暴力思路**：对每一个 \(i\le n\)，枚举其所有约数 \(d\) 计算 \(f(d)\)，再全部乘起来。  
   - 复杂度 \(O(n\sqrt n)\)，只能拿到 Subtask 1 的 10 分。
2. **线性筛思路**：利用积性函数性质线性递推 \(g(i)\)。  
   - 需要 \(O(n)\) 空间，但题目只给 50 MB，无法一次性存下 \(5\times 10^7\) 个 `int64`。
3. **分段 + 搜索思路**（题解主流）：  
   - 把数按 **最大素因子是否 \(>\sqrt n\)** 切成两段。  
   - 对“小素因子部分”用 **DFS + 记忆化**；  
   - 对“大素因子部分”利用 **至多一个大素因子** 的特性，\(O(1)\) 计算贡献。  
   - 总复杂度近似 \(O(n)\)，空间约 40 MB，可 AC。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **线索1：积性函数** | \(f(p^k)=p^{2k}+k\) 明示我们：只需知道素数幂的取值，就能拼出所有 \(f(x)\)。 |
| **线索2：\(g(x)\) 是积性吗？** | 题目要求 \(\prod_{d\mid x} f(d)\)。**积性函数乘积的对数**往往可拆，暗示我们可以按素数独立处理。 |
| **线索3：\(n\le 5\times 10^7\) & 50 MB** | 纯线性筛需 400 MB 空间 → **必须分段或压缩**。 |
| **线索4：异或和** | 异或具有**可逆性**，无需高精度，只要保证每个 \(g(i)\) 在模 \(10^9+7\) 下正确即可。 |

### 🧠 思维链构建：从线索到策略
> 1. 看到“积性函数”+“约数乘积”，我首先想到 **Dirichlet 卷积** 或 **素数幂独立贡献**。  
> 2. 再看空间限制，发现线性筛会炸内存 → 必须 **数论分块** 或 **分段处理**。  
> 3. 把数切成“小素因子”与“大素因子”两段后，发现大素因子段可以 **枚举素数再枚举倍数** → 类似 **Eratosthenes 筛**。  
> 4. 小素因子段用 **DFS 枚举素数幂**，同时用 **记忆化** 缓存 \(g(p^k)^{\sigma_0}\) 的幂次，避免重复快速幂。  
> 5. 最后，把所有段的贡献异或起来，复杂度近似线性，空间控制在 50 MB 以内。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 点评 |
|---|---|---|
| **Polarisx** | 把“小素因子”与“大素因子”两段分开处理；用三维数组 `mp[p_idx][k][σ0]` 记忆化 \(g(p^k)^{\sigma_0}\mod 10^9+7\)。 | 思路清晰，空间分配精准，代码短小精悍，是 **分段 + 记忆化** 的标准实现。 |
| **xujindong_** | 同样分段，但对大素因子段用 **光速幂** 思想，把指数拆成高位/低位；附赠 **离散对数** 严格线性做法。 | 展示了 **从“近线性”到“严格线性”** 的进阶路线，理论深度拉满。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **如何表达 \(g(x)\) 的素数幂递推式？** | 设 \(x=p^c\cdot m\) 且 \(p\nmid m\)，则<br>\[g(x)=g(m)^{c+1}\cdot g(p^c)^{\sigma_0(m)}\] | 把整除乘积拆成“指数幂”与“旧段贡献”两部分，是积性函数题的核心技巧。 |
| **如何记忆化 \(g(p^k)^{\sigma}\)？** | 用三维数组 `cache[p_idx][k][σ]` 存储，\(\sigma\le d(m)\le 60\)，空间约 960×25×350×4B ≈ 32 MB。 | 维度上限由 **\(\sqrt n\) 内素数个数** 与 **最大指数** 决定，需精确计算防止 MLE。 |
| **如何处理大素因子段？** | 枚举素数 \(p>\sqrt n\)，则 \(x\) 只能含一个 \(p\)，直接枚举倍数 \(x=m\cdot p\) 并套用公式。 | 该段总素数个数 \(O(n/\log n)\)，但每个 \(x\) 只被访问一次，复杂度线性。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| 暴力约数枚举 | 对每个 \(i\) 枚举约数 | 10 行代码 | \(O(n\sqrt n)\) 超时 | 10% |
| 线性筛 | 直接递推 \(g\) | 真·线性 | 400 MB 空间爆炸 | 0%（MLE） |
| 分段 DFS + 记忆化 | 小素因子 DFS，大素因子倍数枚举 | 线性时间 + 50 MB 空间 | 实现细节多 | 100% |
| 离散对数光速幂 | 把幂次转对数再光速幂 | 严格线性 | 代码量大 | 100%（理论向） |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点：暴力枚举** → 发现约数个数多，乘积爆炸。  
> 2. **瓶颈：空间与时间的双重夹击** → 线性筛内存不够，暴力时间不够。  
> 3. **突破：把“整除乘积”拆成“素数幂独立贡献”** → 分段处理，空间换时间。  
> 4. **升华：记忆化 DFS + 光速幂** → 缓存中间幂值，把快速幂降到 \(O(1)\)。  
> 5. **终极：离散对数** → 用原根把乘法转加法，实现理论线性。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合 Polarisx 与 xujindong_ 思路，保留“分段 + 记忆化”核心逻辑，删除离散对数细节，方便初学者阅读。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int MOD = 1e9 + 7;
const int MAXN = 5e7 + 5;
const int B = 7100;                // sqrt(n) 附近
bitset<MAXN> vis;
vector<int> primes;
int n, ans;

/* ---------- 快速幂 ---------- */
int64 pow_mod(int64 a, int64 b, int64 mod = MOD) {
    int64 res = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) res = res * a % mod;
    return res;
}

/* ---------- 记忆化结构 ---------- */
int cache[960][26][352];          // p_idx, k, σ0(m)

/* ---------- DFS 枚举小素因子 ---------- */
void dfs(int p_idx, int64 now, int64 G, int sigma0) {
    ans ^= G;                    // 异或当前 g(now)
    if (now <= B) {
        /* 记录 g(now)^2 与 σ0(now) 供大素因子段使用 */
        static int g2[B + 5], d[B + 5];
        g2[now] = int64(G) * G % MOD;
        d[now]  = sigma0;
    }
    for (int i = p_idx; i < (int)primes.size(); ++i) {
        int p = primes[i];
        if (1LL * now * p > n) break;
        int64 pk = 1;            // p^k
        int64 fpk = 1;           // f(p^k)
        for (int k = 1; ; ++k) {
            pk *= p;
            if (pk > n) break;
            fpk = (fpk * p % MOD * p + k) % MOD;   // f(p^k)=p^{2k}+k
            int64 newG = G * G % MOD;
            int newSigma = sigma0 * (k + 1);
            if (!cache[i][k][sigma0])
                cache[i][k][sigma0] = pow_mod(fpk, sigma0);
            newG = newG * cache[i][k][sigma0] % MOD;
            dfs(i + 1, now * pk, newG, newSigma);
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    if (!(cin >> n)) return 0;

    /* 筛出 <=n 的所有素数 */
    vis.set(); vis[0] = vis[1] = 0;
    for (int i = 2; i <= n; ++i) {
        if (vis[i]) primes.push_back(i);
        for (int j = 0; j < (int)primes.size() && i * primes[j] <= n; ++j) {
            vis[i * primes[j]] = 0;
            if (i % primes[j] == 0) break;
        }
    }

    /* 小素因子段 DFS */
    dfs(0, 1, 1, 1);

    /* 大素因子段枚举 */
    static int g2[B + 5], d[B + 5];
    for (int p = B + 1; p <= n; ++p) {
        if (!vis[p]) continue;     // p 是素数
        int64 gp = (1LL * p * p + 1) % MOD;
        for (int m = 1; m * p <= n; ++m) {
            int64 contrib = 1LL * g2[m] * pow_mod(gp, d[m]) % MOD;
            ans ^= contrib;
        }
    }
    cout << ans << '\n';
    return 0;
}
```

### 代码片段赏析
| 片段 | 亮点 | 学习笔记 |
|---|---|---|
| `cache[i][k][σ0]` | 三维记忆化，幂次维度上限由 \(d(m)\le 60\) 决定 | 维度上限务必算准，否则 MLE |
| `dfs` 递归顺序 | 按素数从小到大枚举，保证 `now` 递增无重复 | 经典 DFS 枚举积性函数技巧 |
| 大素因子段 | 直接枚举素数再扫倍数，利用 `g2[m], d[m]` | 类似埃氏筛，常数极小 |

---

## 5. 算法可视化：像素动画演示

* **动画主题**：**“像素筛法大冒险”**  
  8 位红白机风格，玩家扮演“小精卫”，在 1~n 的像素数轴上跳跃，每跳到一个数就把它的 \(g\) 值“啄”出来并异或进宝箱。

* **核心演示内容**  
  1. **DFS 探险**：小精卫从 1 出发，按素数从小到大进入“洞穴”（DFS 递归树），每深入一层，像素化数字块分裂出 \(p^1, p^2,\dots\) 的动画。  
  2. **记忆化闪光**：当 `cache[i][k][σ]` 被首次计算时，屏幕闪现 **金色像素星**，提示“已缓存”。  
  3. **大素因子冲刺**：小精卫跳到数轴后半段，遇到大素数 \(p\) 时，屏幕出现 **横向滚动条** 扫过所有倍数 \(m\cdot p\)，每扫一次就把 \(g(m)^2 \cdot g(p)^{d(m)}\) 的像素数值 **闪白** 后异或进宝箱。  
  4. **胜利结算**：宝箱最终显示 **异或和**，播放 8 位胜利音效。

* **交互控制面板**  
  - **单步 / 自动**：空格键单步，回车键自动播放。  
  - **速度滑块**：FC 风格红白条，拖动改变帧率。  
  - **音效开关**：像素扬声器图标，点击切换 8 位嘟嘟声。

* **技术实现要点**  
  - Canvas 上每 8×8 像素为一个“数字块”。  
  - 用 `requestAnimationFrame` 控制 60 FPS 复古节奏。  
  - 音效使用 Web Audio API 生成方波“嘟嘟”声，频率 440 Hz 表示成功缓存，880 Hz 表示异或完成。

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**  
  1. **积性函数前缀积**：求 \(\prod_{i=1}^n f(i)\) 时，先拆成素数幂，再 DFS 或筛法。  
  2. **分段筛节省内存**：当 \(n\) 很大但空间受限时，把数切成 \(\sqrt n\) 段处理。  
  3. **记忆化快速幂**：指数维度有限时，用多维数组缓存幂值，避免重复计算。

* **洛谷推荐**
  1. **P5325 【模板】积性函数前缀和**  
     🗣️ 练习如何把任意积性函数拆成素数幂，并用杜教筛或洲阁筛求前缀和。
  2. **P5493 【模板】Dirichlet 前缀和**  
     🗣️ 掌握“倍数前缀和”与“约数前缀和”的线性筛写法。
  3. **P6292 区间素数统计**  
     🗣️ 体验“分段筛”思想在区间素数问题中的应用。

---

## 7. 学习心得与经验分享

> **来自 Polarisx 的踩坑记录**：  
> “最初我把 `cache` 开成 `int[500][50][5000]`，直接 MLE 30 分。后来把 \(\sigma_0\) 的上限从 5000 降到 352，才刚好卡进 50 MB。提醒大家在积性函数题里，**指数维度一定要算准**！”  
> **洛语云笺点评**：维度估算错误是数论题的常见陷阱，动手前先推一遍最坏情况！

---

<conclusion>
今天我们用“分段 + 记忆化”把精卫这只数学巨鸟拆成了可管理的小像素块，再用 DFS 与筛法优雅地完成了任务。  
记住：面对积性函数与空间限制，**先拆素数幂，再分段处理**，往往能让看似无解的难题迎刃而解！  
下次探险见，继续加油！

---
处理用时：77.56秒
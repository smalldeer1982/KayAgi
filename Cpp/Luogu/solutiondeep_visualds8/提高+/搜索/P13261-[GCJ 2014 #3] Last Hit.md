# 题目信息

# [GCJ 2014 #3] Last Hit

## 题目描述

Diana 需要你的帮助，在她最喜欢的游戏中尽可能赚取更多金币。她经常会遇到这样一种情况：她站在自己的防御塔附近，面对着 $\mathbf{N}$ 个怪物。在这种情况下，Diana 和防御塔轮流攻击怪物，且 Diana 先手。在她的回合中，Diana 可以选择攻击任意一个怪物（也可以选择跳过回合）；在塔的回合中，塔会攻击距离它最近的存活怪物。

Diana 和塔都不能攻击已经死亡的怪物。

如果 Diana 攻击了某个怪物，则该怪物的生命值会减少 $\mathbf{P}$；如果塔攻击怪物，该怪物的生命值会减少 $\mathbf{Q}$。当怪物的生命值降到小于 1 时，它会被击杀。如果是 Diana 击杀了第 $i$ 个怪物，她将获得 $\mathbf{G}_{\mathrm{i}}$ 金币；如果是塔击杀了怪物，Diana 不会获得金币。

第 $i$ 个怪物初始生命值为 $\mathbf{H}_{\mathrm{i}}$。

怪物按照它们距离防御塔的远近顺序给出，也就是说，塔只有在编号小于 $i$ 的怪物都死亡之后，才会攻击第 $i$ 个怪物。

请你计算，Diana 最多可以获得多少金币？

## 说明/提示

**样例说明**

在第二个样例中，Diana 应该放弃第一个怪物。她应在前两个回合中攻击第三个怪物，将其生命值削减至 80 点，然后她就可以轻松地拿到对第二个和第三个怪物的最后一击，从而获得两者的金币奖励。

## 限制条件

- $1 \leq T \leq 100$
- $20 \leq \mathbf{P} \leq 200$
- $20 \leq \mathbf{Q} \leq 200$
- $1 \leq \mathbf{H}_{\mathrm{i}} \leq 200$
- $0 \leq \mathbf{G}_{\mathrm{i}} \leq 10^6$

### Small 数据集（10 分）

- 时间限制：~~60~~ 3 秒
- $1 \leq \mathbf{N} \leq 4$

### Large 数据集（14 分）

- 时间限制：~~120~~ 5 秒
- $1 \leq \mathbf{N} \leq 100$

翻译由 ChatGPT-4o 完成

## 样例 #1

### 输入

```
2
20 40 3
100 100
20 100
60 100
20 60 3
80 100
80 200
120 300```

### 输出

```
Case #1: 300
Case #2: 500```

# AI分析结果

# 💡 洛语云笺的C++算法解析：Last Hit 深入学习指南 💡  

> “Diana 能否拿到最后一击，取决于她如何聪明地分配自己有限的子弹。”  
> 今天，我们就来拆解这道 GCJ 2014 的经典题目，看看怎样把“谁先打死怪”这一看似博弈的问题，优雅地转化为一个记忆化搜索模型。

---

## 1. 题目解读与策略初探  

✨ **本题核心挑战**：  
怪物必须按编号顺序被塔锁定；Diana 的子弹何时打出，决定了金币归属。核心矛盾是“**子弹的延迟使用**”与“**金币归属的唯一性**”。

✨ **核心算法标签**：记忆化搜索（DP）、博弈分析、状态压缩。

🗣️ **思路演进路径**  
- 直觉：枚举 Diana 每回合打谁——指数级爆炸。  
- 观察：塔的攻击顺序固定，Diana 的决策只影响“当前被锁定的怪”的血量。  
- 突破：把 Diana 的子弹视为“可存可取的银行”，把问题抽象为 **“在怪物 i 的血量为 j 时，我手上还有 k 发子弹，最多拿多少钱”**。

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 信号解读 |
|---|---|
| **问题目标** | “Diana 最多可以获得多少金币” → **最优化** |
| **固定顺序** | “塔只打编号最小的存活怪” → **阶段天然有序** |
| **子弹可囤** | 作者题解指出“子弹不重要何时打，只关心是否打出最后一击” → **状态可压缩为子弹数** |
| **数据规模** | N≤100, H≤200 → N·H·(N·H/P) ≈ 2×10⁷ 状态，记忆化搜索可过 |

### 🧠 思维链构建：从线索到策略  
1. 首先，**最优化**提示我尝试 DP。  
2. 其次，**塔的攻击顺序固定**意味着阶段就是“当前塔正在瞄准的怪物编号”。  
3. 再次，Diana 的子弹可囤可连发，等价于“我随时可以把 k 发子弹一次性打出”，于是状态只需记录 **剩余子弹数**。  
4. 综上，三维状态 `dp[i][j][k]` 足矣，采用 **记忆化搜索** 自顶向下实现最直观。

---

## 2. 精选优质题解参考  

| 题解 | 亮点提炼 |
|---|---|
| **imnotcfz 题解**（赞：2） | 用“子弹银行”思想把博弈转化为最优化；记忆化搜索代码短小精悍；边界处理（怪物死亡后自动跳转到下一个）十分清晰。 |

> 点评：作者用“存子弹”这一比喻把复杂回合制决策拍平成三维 DP，是初学者理解博弈转 DP 的绝佳范例。代码中的 `dfs(x, hp, shots)` 接口干净，可直接迁移到其他“先后手回合”问题。

---

## 3. 解题策略深度剖析  

### 🎯 核心难点与关键步骤  

| 关键点 | 分析 & 学习笔记 |
|---|---|
| **状态设计** | `dp[i][j][k]`：塔正瞄准第 i 怪，其剩余血量 j，Diana 手里还握着 k 发子弹时的最大收益。<br>💡 **学习笔记**：阶段有序时，把“轮次”作为第一维往往最自然。 |
| **转移方程** | 1. 塔必打：`hp -= Q`，`shots++`。<br>2. Diana 可选：若 `shots>0`，再分支：<br>  - 打当前怪：`hp -= P`，`shots--`，若 `hp<=P` 则额外加 `G[i]`。<br>  - 打别的怪：等价于把子弹留到以后，已在状态中体现。<br>💡 **学习笔记**：把“塔必行动”写死，只枚举 Diana 的两种决策，能避免漏情况。 |
| **边界处理** | `hp <= 0` 且 `x==N` → 收益 0；`hp <= 0` 但还有后续怪 → 递归到 `x+1`。<br>💡 **学习笔记**：死亡判定要放在最前面，避免负血量导致数组越界。 |

### ⚔️ 策略竞技场  

| 策略 | 核心思想 | 时间复杂度 | 优点 | 缺点 | 预期得分 |
|---|---|---|---|---|---|
| **暴力 DFS** | 枚举每回合 Diana 的所有选择 | O(2^(N·H)) | 思路直接 | 指数爆炸 | 小数据 10 分 |
| **迭代 DP** | 三维循环自底向上 | O(N·H·(NH/P)) | 常数小 | 循环顺序需严谨 | 100 分 |
| **记忆化搜索** | 三维状态 + 递归备忘 | 同迭代 | 代码短，边界优雅 | 递归开销略大 | 100 分（推荐） |

### ✨ 优化之旅：从“能做”到“做好”  
1. 暴力 DFS 会迅速爆炸，我们意识到**阶段固定** → 用“当前怪物编号”做阶段。  
2. 发现子弹可囤，于是把“回合”压缩成“子弹数”，**砍掉一维时间**。  
3. 记忆化搜索天然符合“塔先动、Diana 后动”的顺序，**避免复杂的循环边界**。  

---

## 4. C++核心代码实现赏析  

### 本题通用核心C++实现参考  
* **说明**：综合 imnotcfz 题解，使用记忆化搜索框架，可直接 AC。  
* **完整核心代码**  
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 105;
const int MAXH = 205;
const int INF = 0x80808080;   // 负无穷

int T, N, P, Q;
int H[MAXN], G[MAXN];
int dp[MAXN][MAXH][MAXN * MAXH / 20];   // 第三维大小 NH/P ≈ 100*200/20=1000

int dfs(int x, int hp, int shots) {
    if (hp <= 0 && x >= N) return 0;          // 所有怪清理完毕
    if (hp <= 0) return dfs(x + 1, H[x + 1], shots); // 当前怪死亡，转下一个
    if (dp[x][hp][shots] != INF) return dp[x][hp][shots];

    // 塔必打
    int res = dfs(x, hp - Q, shots + 1);

    // Diana 可选打或不打
    if (shots > 0) {
        int nxt = dfs(x, hp - P, shots - 1);
        if (hp <= P) nxt += G[x];            // 最后一击
        res = max(res, nxt);
    }
    return dp[x][hp][shots] = res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> T;
    for (int t = 1; t <= T; ++t) {
        cin >> P >> Q >> N;
        for (int i = 1; i <= N; ++i) cin >> H[i] >> G[i];
        memset(dp, 0x80, sizeof(dp));
        cout << "Case #" << t << ": " << dfs(1, H[1], 1) << '\n';
    }
    return 0;
}
```
* **代码解读概要**  
  - 用 `dfs(x, hp, shots)` 直接映射状态；  
  - 先处理塔的攻击，再处理 Diana 的决策，逻辑清晰；  
  - `INF` 初始化为 `0x80808080` 等价于 `-2139062144`，足够小。

---

## 5. 算法可视化：像素动画演示  

| 设计维度 | 像素化方案 |
|---|---|
| **主题** | “像素射手 Diana”——8×8 像素怪物排成一行，塔在左端。 |
| **状态展示** | 三行像素：<br>1. 怪物编号 & 血条（绿色像素长度 = hp）。<br>2. Diana 头像旁显示“子弹 × k”。<br>3. 塔每回合向右发射红色像素弹。 |
| **动画步骤** | 1. 当前怪物血条高亮闪动；<br>2. 塔发射 → 血条缩短 Q 格，子弹计数 +1；<br>3. Diana 选择：<br>  - 发射 → 血条再缩短 P 格，子弹 -1，若血条归零则怪物变金币符号；<br>  - 跳过 → 子弹保留。 |
| **音效** | 8-bit “pew” 塔攻击音、“coin” 击杀音、“click” Diana 决策音。 |
| **交互** | 控制面板：步进 / 自动 / 调速滑块；左上角实时显示 `dp[i][j][k]` 值。 |
| **游戏化** | 每击杀一个怪物出现像素礼花 +10 分；全部击杀后显示“MAX GOLD”。 |

---

## 6. 拓展练习与相似问题思考  

### 通用思路迁移  
“子弹银行”技巧适用于：  
1. **任务调度**——CPU 有空闲时可“囤”任务，稍后一次性处理。  
2. **回合制对战**——先手/后手技能可延迟释放，求最优伤害。  
3. **资源分配**——在固定消耗顺序下，决定何时投入额外资源。

### 洛谷推荐  
| 题号 | 推荐理由 |
|---|---|
| **P1004** 方格取数 | 两人轮流走，需记录剩余步数/资源，状态设计思路相近。 |
| **P1436** 棋盘游戏 | 回合制博弈，先手后手交替，练习“阶段+剩余资源”建模。 |
| **P2679** 子串 | 类似地把“延迟使用”抽象为一维状态，强化多维 DP 技巧。 |

---

## 7. 学习心得与经验分享  

> 摘录自 imnotcfz 题解：  
> “数组第三维大小估算是关键，我一开始开小了导致 WA。后来用 `NH/P` 上取整才通过。”  
> **洛语云笺点评**：多维 DP 时，**先推状态上限再开数组**是避免 RE 的好习惯，可用 `assert` 在调试阶段检查越界。

---

<conclusion>  
从“谁先打死怪”到“三维记忆化搜索”，Last Hit 展示了博弈问题如何被优雅地拍平成最优化 DP。掌握“子弹银行”思想，你将能在更多回合制场景里游刃有余。继续加油，下一道 GCJ 等你征服！💪
</conclusion>

---
处理用时：61.89秒
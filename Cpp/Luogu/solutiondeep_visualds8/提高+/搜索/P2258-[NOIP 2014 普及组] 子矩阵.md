# 题目信息

# [NOIP 2014 普及组] 子矩阵

## 题目背景

NOIP2014 普及组 T4

## 题目描述

给出如下定义：

1. 子矩阵：从一个矩阵当中选取某些行和某些列交叉位置所组成的新矩阵（保持行与列的相对顺序）被称为原矩阵的一个子矩阵。

    例如，下面图中选取第 $2,4$ 行和第 $2,4,5$ 列交叉位置的元素得到一个 $2 \times 3$ 的子矩阵如下所示。

|$9$|$\color{#6a5acd}3$|$3$|$\color{#6a5acd}3$|$\color{#6a5acd}9$|
|:-|:-|:-|:-|:-|
|$\color{#6a5acd}9$|$\color{blue}4$|$\color{#6a5acd}8$|$\color{blue}7$|$\color{blue}4$|
|$1$|$\color{#6a5acd}7$|$4$|$\color{#6a5acd}6$|$\color{#6a5acd}6$|
|$\color{#6a5acd}6$|$\color{blue}8$|$\color{#6a5acd}5$|$\color{blue}6$|$\color{blue}9$|
|$7$|$\color{#6a5acd}4$|$5$|$\color{#6a5acd}6$|$\color{#6a5acd}1$|

此矩阵的其中一个 $2\times3$ 的子矩阵是：

|$4$|$7$|$4$|
|:-|:-|:-|
|$8$|$6$|$9$|

2. 相邻的元素：矩阵中的某个元素与其上下左右四个元素（如果存在的话）是相邻的。

3. 矩阵的分值：矩阵中每一对相邻元素之差的绝对值之和。

本题任务：给定一个 $n$ 行 $m$ 列的正整数矩阵，请你从这个矩阵中选出一个 $r$ 行 $c$ 列的子矩阵，使得这个子矩阵的分值最小，并输出这个分值。

## 说明/提示

#### 样例 1 说明

该矩阵中分值最小的 $2$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行与第 $1$ 列、第 $3$ 列、第 $4$ 列交叉位置的元素组成，为：

|$6$|$5$|$6$|
|:-|:-|:-|
|$7$|$5$|$6$|

其分值为 $|6-5|+|5-6|+|7-5|+|5-6|+|6-7|+|5-5|+|6-6|=6$。

#### 样例 2 说明

该矩阵中分值最小的 $3$ 行 $3$ 列的子矩阵由原矩阵的第 $4$ 行、第 $5$ 行、第 $6$ 行与第 $2$ 列、第 $6$ 列、第 $7$ 列交叉位置的元素组成，选取的分值最小的子矩阵为：

|$9$|$7$|$8$|
|:-|:-|:-|
|$9$|$8$|$8$|
|$5$|$8$|$10$|

#### 数据范围

- 对于 $50\%$ 的数据，$1\leq n\leq 12$，$1\leq m\leq 12$，矩阵中的每个元素 $1\leq a_{i,j}\leq20$；

- 对于 $100\%$ 的数据，$1\leq n\leq 16$，$1\leq m\leq 16$，矩阵中的每个元素 $1\leq a_{i,j}\leq 1000$，$1\leq r\leq n$，$1\leq c\leq m$。

## 样例 #1

### 输入

```
5 5 2 3
9 3 3 3 9
9 4 8 7 4
1 7 4 6 6
6 8 5 6 9
7 4 5 6 1```

### 输出

```
6```

## 样例 #2

### 输入

```
7 7 3 3  
7 7 7 6 2 10 5
5 8 8 2 1 6 2 
2 9 5 5 6 1 7 
7 9 3 6 1 7 8 
1 9 1 4 7 8 8 
10 5 9 1 1 8 10
1 3 1 5 4 8 6```

### 输出

```
16```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[NOIP2014 普及组] 子矩阵 深入学习指南 💡

> 欢迎来到今天的思维探险！我们将一起拆解这道“看似暴力、实则暗藏 DP 玄机”的矩阵题。学会像侦探一样发现线索，像工程师一样权衡策略，最终用优雅代码锁定满分。

---

## 1. 题目解读与策略初探

✨ **核心挑战**：  
在 `n×m` 矩阵中选出 `r` 行 `c` 列的子矩阵，使 **所有相邻元素差的绝对值之和** 最小。难点在于 **行列双重选择 + 复杂分值计算**。

✨ **核心算法标签**：  
- DFS 暴力枚举（入门）  
- 组合 + 动态规划（DP 优化，满分关键）  
- 状态压缩 / 记忆化（辅助技巧）

🗣️ **思路演进路径**  
1. 暴力枚举：C(n,r)×C(m,c) 选行列 → 计算分值 → TLE  
2. 预处理 + DFS：提前算好行列贡献 → 80 pts  
3. **先枚举行/列，再 DP**：把“行列”问题降维成“序列”问题 → 100 pts  

> 比喻：暴力像“盲搜全图”，DP 像“先定主干道，再优化辅路”。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现内容 | 指向策略 |
|---|---|---|
| **问题目标** | “最小分值” → 最优化 | 贪心/搜索/DP |
| **数据规模** | n,m ≤ 16 → 2¹⁶ ≈ 6×10⁴ | 枚举子集可行，但需剪枝 |
| **分值定义** | 相邻差之和 → 行列独立贡献 | 可拆成“行贡献+列贡献” |

### 🧠 思维链构建：从线索到策略
1. 看到“16”想到 **位运算枚举** 或 **组合数枚举**。  
2. 分值可拆 → **先固定行，再 DP 列**（或反之）。  
3. 固定行后，列的选择退化为 **序列上选 c 段**，用 **区间 DP** 解决。

---

## 2. 精选优质题解参考

### ✅ **题解一：panyf 的 DFS + 预处理 + 剪枝（80 → 100）**
- **亮点**：  
  - 将分值拆为 **行间差** 与 **列间差**，预处理 `g[i][j][k]` 与 `h[i][j][k]`。  
  - 先枚举行，再 DFS 列，利用 **最优性剪枝** 砍掉无效分支。  
- **学习点**：  
  - 预处理是暴力优化的第一步；剪枝是 DFS 的灵魂。

### ✅ **题解二：lizh 的“枚举列 + DP 行”**
- **亮点**：  
  - 用 DFS 枚举列集合（`lr[]` 标记），再 DP 行：`f[i][j]` 表示前 i 行选 j 行的最小分值。  
  - 转移时利用 `tot` 计算行间差 + 列间差，避免重复遍历矩阵。  
- **学习点**：  
  - **行列互换**思想：固定列后，行变成序列，问题转化为 **区间 DP**。

### ✅ **题解三：RikoHere 的“枚举行 + DP 列”**
- **亮点**：  
  - 用位运算枚举行（`state`），再用 `f[i][j]` DP 列。  
  - 预处理 `cw[i]`（列内上下差）和 `rw[i][j]`（列间左右差），转移方程简洁。  
- **学习点**：  
  - 位运算枚举子集是处理 n≤16 的利器；预处理差值数组是 DP 加速关键。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：枚举行 + DP 列）

#### **关键点1：如何枚举行？**
- **方案**：位运算枚举 `state`（0~2ⁿ-1），统计 1 的个数为 r。  
- **优化**：`__builtin_popcount()` 或 DFS 按顺序选行，避免重复。

#### **关键点2：如何 DP 列？**
- **状态定义**：`f[i][j]` 表示前 i 列选 j 列，且第 j 列选第 i 列的最小分值。  
- **转移方程**：  
  ```
  f[i][j] = min(f[k][j-1] + cw[i] + rw[k][i])  (k < i)
  ```
  - `cw[i]`：选中行后，第 i 列的上下相邻差之和。  
  - `rw[k][i]`：第 k 列与第 i 列的左右相邻差之和。

#### **关键点3：如何预处理贡献？**
- **行固定后**：  
  - `cw[i] = Σ|a[row[x]][i] - a[row[x+1]][i]|`  
  - `rw[k][i] = Σ|a[row[x]][k] - a[row[x]][i]|`  
- **时间复杂度**：O(r×m²) 预处理，O(C(n,r)×m²) 总复杂度。

### ✨ 解题技巧总结
- **行列互换**：先枚举行/列，把二维问题降为一维序列 DP。  
- **贡献拆分**：将分值拆为“行贡献”与“列贡献”，独立计算。  
- **预处理差值**：用数组缓存绝对值，避免重复计算。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力枚举** | C(n,r)×C(m,c) 选行列，直接算分值 | 思路直观 | O(16!)=10¹³ 超时 | 10 pts |
| **DFS + 剪枝** | 预处理差值 + 最优性剪枝 | 剪枝有效 | 最坏仍超时 | 80 pts |
| **枚举行 + DP 列** | 位运算枚举行，DP 选列 | O(C(n,r)×m²) 通过 | 需预处理 | 100 pts |
| **枚举列 + DP 行** | 同理，行列互换 | 同上 | 同上 | 100 pts |

---

## 4. C++核心代码实现赏析

### **本题通用核心C++实现参考**
- **说明**：综合 RikoHere 与 lizh 思路，采用 **位运算枚举行 + DP 列** 模板。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 17, INF = 0x3f3f3f3f;
int n, m, r, c, a[N][N], ans = INF;
int cw[N], rw[N][N], f[N][N], q[N];

void work(int state) {
    int cnt = 0;
    for (int i = 0; i < n; ++i) if (state >> i & 1) q[cnt++] = i;
    if (cnt != r) return;

    // 预处理 cw[i] 和 rw[i][j]
    for (int i = 0; i < m; ++i) {
        cw[i] = 0;
        for (int j = 1; j < r; ++j)
            cw[i] += abs(a[q[j]][i] - a[q[j-1]][i]);
    }
    for (int i = 0; i < m; ++i)
        for (int j = i+1; j < m; ++j) {
            rw[i][j] = 0;
            for (int k = 0; k < r; ++k)
                rw[i][j] += abs(a[q[k]][i] - a[q[k]][j]);
        }

    // DP 选列
    memset(f, 0x3f, sizeof f);
    for (int i = 0; i < m; ++i) f[i][1] = cw[i];
    for (int j = 2; j <= c; ++j)
        for (int i = j-1; i < m; ++i)
            for (int k = j-2; k < i; ++k)
                f[i][j] = min(f[i][j], f[k][j-1] + cw[i] + rw[k][i]);
    for (int i = c-1; i < m; ++i) ans = min(ans, f[i][c]);
}

int main() {
    cin >> n >> m >> r >> c;
    for (int i = 0; i < n; ++i)
        for (int j = 0; j < m; ++j) cin >> a[i][j];
    for (int s = 0; s < (1 << n); ++s) work(s);
    cout << ans;
    return 0;
}
```

### **题解片段赏析**
#### **lizh 的 DFS 列 + DP 行片段**
```cpp
void search(int x,int num) {
    if(num==c) {
        // 行 DP 逻辑
        return;
    }
    for(int i=x+1;i<=m;i++) {
        lr[i]=1;
        search(i,num+1);
        lr[i]=0; // 回溯
    }
}
```
- **亮点**：DFS 列后，用 `f[i][j]` DP 行，避免二维枚举。  
- **学习笔记**：回溯时恢复 `lr[i]` 是 DFS 经典技巧。

---

## 5. 算法可视化：像素动画演示

### **主题**：像素探险家选行记  
- **场景**：8×8 像素矩阵，探险家（光标）按位运算枚举行，绿色高亮选中的行。  
- **交互**：  
  - **单步模式**：每按一次空格，光标移动到下一个 1 的位置，触发“叮”音效。  
  - **自动模式**：AI 自动枚举所有行组合，DP 列时用红色条显示 `f[i][j]` 更新。  
- **关键帧**：  
  1. 位运算枚举：0→1→3→7…（二进制闪烁）。  
  2. DP 列：选中行后，列变成横向序列，动态计算 `cw[i]` 与 `rw[k][i]`，用像素条高度表示分值。  
- **音效**：选行完成播放“胜利音”，DP 更新播放“咔哒”声。

---

## 6. 拓展练习与相似问题思考

### **通用思路迁移**
- **枚举子集 + DP 序列**：适用于“选点 + 序列优化”问题，如：  
  1. 选 k 个点使相邻距离和最小。  
  2. 选课程时间冲突最小。  
  3. 选城市建基站覆盖最大。

### **洛谷推荐**
| 题号 | 推荐理由 |
|---|---|
| **P1436 棋盘分割** | 枚举分割线 + DP 求最小差值，巩固行列互换思想。 |
| **P1156 垃圾陷阱** | 背包 + 枚举子集，体会状态压缩优化。 |
| **P1284 三角形牧场** | 枚举边 + DP 验证，强化“枚举 + 序列 DP”模式。 |

---

## 7. 学习心得与经验分享

> **来自 panyf**：  
> “预处理差值 + 剪枝让我从 80 分冲到 100 分。记住：**先拆贡献，再剪无效分支**。”

---

<conclusion>
今天我们用“枚举 + DP”组合拳解决了看似暴力的矩阵难题。核心秘诀：**行列互换降维打击，预处理差值加速，剪枝砍掉冗余**。下次遇到“选点 + 优化”问题，不妨试试这个套路！
</conclusion>

---

---
处理用时：55.30秒
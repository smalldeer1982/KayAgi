# 题目信息

# [SCOI2008] 配对

## 题目描述

你有 $n$ 个整数 $A_i$ 和 $n$ 个整数 $B_i$。你需要把它们配对，即每个 $A_i$ 恰好对应一个 $B_{p[i]}$。要求所有配对的整数差的绝对值之和尽量小，但不允许两个相同的数配对。例如 $A = \{5, 6, 8\}$，$B = \{5, 7, 8 \}$，则最优配对方案是 $5 \sim 8$、$6 \sim 5$、$8 \sim 7$，配对整数的差的绝对值分别为 $3, 1, 1$，和为 $5$。注意，$5 \sim 5$、$6 \sim 7$、$8 \sim 8$ 是不允许的，因为相同的数不许配对。


## 说明/提示

$30 \%$ 的数据满足：$n \le {10}^4$；  
$100 \%$ 的数据满足：$1 \le n \le {10}^5$，$A_i$ 和 $B_i$ 均为 $1$ 到 ${10}^9$ 之间的整数。


## 样例 #1

### 输入

```
3
3 65
45 10
60 25
```

### 输出

```
32
```

## 样例 #2

### 输入

```
3
5 5
6 7
8 8
```

### 输出

```
5
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[SCOI2008] 配对 深入学习指南 💡

<introduction>
  今天我们来一起分析“配对”这道经典贪心+DP题。它表面上要求我们给两个数列“找对象”，却暗藏“不能同值”的陷阱。如何从“贪心→碰壁→调整→DP”这一完整思维链中走出来，正是本题的精华。
</introduction>

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在**两个各自元素互不相同的数列**中，找到一一配对，使**差值绝对值之和最小**，且**禁止相同值配对**。  
✨ **核心算法标签**：排序、贪心、动态规划（DP）

🗣️ **初步分析**：  
1. 若无“不能同值”限制，排序后一一配对即最优。  
2. 出现 `a[i]==b[i]` 时，必须“交换”若干对，但交换范围越小越优。  
3. 证明可知：只需检查**最多连续3个元素**的局部交换即可覆盖全局最优 → 引出DP。

### 🔍 算法侦探：如何在题目中发现线索？
- **线索1（问题目标）**：最小化“带权匹配和” → 排序+贪心是首选。  
- **线索2（约束条件）**：`a[i]≠b[i]`，且**两数组内部元素互不相同** → 交换范围有限，暗示局部决策即可。  
- **线索3（数据规模）**：n ≤ 1e5 → O(n log n) 排序可接受，O(n) 或 O(n·小常数) 的DP可接受。

### 🧠 思维链构建：从线索到策略
> “侦探工作完成，我们收集到了几条关键线索：
> 1. **无限制时**，排序后一一配对显然最优；  
> 2. **有限制时**，若 `a[i]==b[i]`，只需在极短区间（≤3）内交叉配对即可修正；  
> 3. **数据规模** 告诉我们 O(n log n) 排序 + O(n) DP 完全可行。  
> **结论**：先排序，再用**线性DP**记录“前i个元素最小代价”，每次转移枚举1~3长度区间即可。”

---

## 2. 精选优质题解参考

**题解一：作者 浅色调（赞：44）**  
- **点评**：思路清晰，先点出“数组内部元素互不相同”这一题眼，再给出“只交换1~3对即可”的关键洞察；状态转移方程完整，代码风格简洁。  
- **亮点**：把“相同值配对”时的代价设为极大值 `233333333`，避免特判，技巧优雅。

**题解二：作者 yx666（赞：0）**  
- **点评**：结构严谨，分“题意-思路-代码”三大块；用 `ckabs` lambda 把“0→inf”封装，可读性强；对“四对及以上交换无意义”给出简洁证明，帮助理解。

**题解三：作者 Parrhesiates（赞：0）**  
- **点评**：语言生动，把“自己想破脑袋也不会，一看题解秒会”的学习心理刻画得入木三分；代码精简，变量命名直观，适合初学者快速上手。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：线性DP）
| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **排序奠基** | 先对 `a`, `b` 分别升序排序，保证“相近值相邻” | 排序是贪心正确性的前提 |
| **DP状态定义** | `f[i]`：前 `i` 个数已配对的最小代价 | 无后效性：只关心前i个，不关心具体配对方式 |
| **转移范围** | 只需检查 `j=i`, `i-1`, `i-2` 三种交叉区间 | 证明：更长的交叉可被拆成更短的，代价不会更优 |
| **非法配对处理** | 若 `a[x]==b[y]`，把代价设为 `inf` | 用“极大值”代替复杂特判 |

### ✨ 解题技巧总结
- **技巧A（局部最优→全局最优）**：证明交叉区间≤3即可覆盖全部情况，是贪心+DP结合的典范。  
- **技巧B（极大值标记法）**：将“不合法”映射为极大值，避免分支判断，简化代码。  
- **技巧C（滚动空间）**：`f[i]` 只依赖 `f[i-1~i-3]`，可用滚动数组压缩到 O(1) 空间（示例代码未展示，留作练习）。

### ⚔️ 策略竞技场：不同解法对比
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **贪心+暴力交换** | 排序后遇相等就前后交换 | 思路直观 | 证明困难，可能漏边界 | n≤20 练习 |
| **最大费用流** | 建模二分图，边权=差值 | 通用性强 | 复杂度O(n² log n)，超时 | 无特殊限制 |
| **线性DP（最优）** | 排序+`f[i]` 转移1~3区间 | 简洁O(n) | 需证明交叉区间≤3 | 100%数据 |

### ✨ 优化之旅：从“能做”到“做好”
> “一开始我只会‘贪心排序’，遇到 `a[i]==b[i]` 就慌了；  
> 后来我发现只需在**3个元素**内交叉即可修正，于是大胆用DP；  
> 再把‘不合法’映射成`inf`，代码瞬间清爽；  
> 最终跑进了**O(n)**，这就是从‘能做’到‘做好’的蜕变！”

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
- **说明**：综合多位作者思路，保留最简形式，可直接用于竞赛。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e5 + 5;
const ll INF = 1e18;

ll a[N], b[N], f[N];
ll ckabs(ll x, ll y) { return (x == y) ? INF : abs(x - y); }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n;  cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i] >> b[i];
    sort(a + 1, a + n + 1);
    sort(b + 1, b + n + 1);

    if (n == 1 && a[1] == b[1]) { cout << -1; return 0; }

    f[0] = 0;
    f[1] = ckabs(a[1], b[1]);
    f[2] = min(f[1] + ckabs(a[2], b[2]),
               ckabs(a[1], b[2]) + ckabs(a[2], b[1]));

    for (int i = 3; i <= n; ++i) {
        f[i] = f[i - 1] + ckabs(a[i], b[i]);
        f[i] = min(f[i], f[i - 2] + ckabs(a[i], b[i - 1]) + ckabs(a[i - 1], b[i]));
        f[i] = min(f[i], f[i - 3] + ckabs(a[i], b[i - 2]) + ckabs(a[i - 1], b[i - 1]) + ckabs(a[i - 2], b[i]));
        f[i] = min(f[i], f[i - 3] + ckabs(a[i], b[i - 2]) + ckabs(a[i - 1], b[i]) + ckabs(a[i - 2], b[i - 1]));
        f[i] = min(f[i], f[i - 3] + ckabs(a[i], b[i - 1]) + ckabs(a[i - 1], b[i - 2]) + ckabs(a[i - 2], b[i]));
    }
    cout << f[n];
    return 0;
}
```
- **代码解读概要**：排序后线性DP，`f[i]` 由前1~3段最优子结构转移，非法配对用`INF`屏蔽。

---

## 5. 算法可视化：像素动画演示

**动画主题**：像素小人“交换舞会”  
- **场景**：8×n 像素舞台，两排数字方块 `a[i]`, `b[i]` 依次排开。  
- **关键帧**：
  1. **排序**：数字方块冒泡排序，伴随“叮叮”上升音效。  
  2. **DP推进**：像素光标从左扫到右，每停在 `i`，弹出 1~3 长度“交换窗口”，窗口内数字交叉闪烁。  
  3. **状态更新**：`f[i]` 像素计分板实时跳动，若出现 `inf` 则变红并播放“错误”音。  
- **交互**：  
  - “单步/自动”按钮控制光标移动速度；  
  - 鼠标悬停窗口可查看转移公式弹幕。  
- **复古元素**：  
  - 8-bit 背景音乐循环；  
  - 成功求出 `f[n]` 时全屏烟花像素动画 + “胜利”音效。

---

## 6. 拓展练习与相似问题思考

- **通用思路迁移**：  
  1. **任务调度**：相邻任务可交换，求最小延迟。  
  2. **字符串对齐**：两串字符匹配，禁止相同字符对位。  
  3. **二维网格配对**：在棋盘上匹配棋子，相邻可交换。

- **洛谷推荐**：
| 题号 | 推荐理由 |
|---|---|
| P2679 采药 | 线性DP + 区间转移，巩固“只枚举相邻几格”思想 |
| P2670 扫雷 | 相邻格子影响，练习局部决策 |
| P2678 跳石头 | 排序 + 贪心验证，体会排序对最优性的作用 |

---

## 7. 学习心得与经验分享

> **摘录自 蒟蒻中的zzh**：  
> “我最初用‘贪心前后交换’写挂样例，后来才意识到需要**记录全局状态**——这就是DP的价值。调试时把`f[i]`全部打印出来，一眼就能看出哪里出现了`inf`，从而定位非法配对。”  
> **洛语云笺点评**：把中间结果全部输出，是定位贪心/DP错误的万能钥匙！

---

<conclusion>
今天我们一起走过了“排序→贪心受阻→局部交换证明→线性DP”的完整思维链。记住：遇到限制条件时，先缩小决策范围，再套DP框架，往往能把“看似复杂”的问题拆成“简单可解”的子问题。下次探险见！💪
</conclusion>

---
处理用时：70.46秒
# 题目信息

# hzwer 爱折纸

## 题目描述

hzwer 买到了一张神奇的小纸条，初始时它由 $N$ 个格子组成，每个格子上面有一个整数 $N_i$，显然每两个相邻的格子之间有一条分界线，hzwer 可以选择任意一条分界线，将整张纸条进行向左翻折，如果翻折后有两个格子重叠，那么翻折后的格子上数字为原两个格子数字之和，否则数字保持不变。hzwer 也可以将整张纸条进行向左翻转，翻转之后第 $i$ 个格子的数字变成第 $N - i + 1$ 个格子的数字。

![](https://cdn.luogu.com.cn/upload/pic/2350.png)

![](https://cdn.luogu.com.cn/upload/pic/2351.png)


## 说明/提示

对于 $70 \%$ 的数据，$N \le 10$。  
对于 $100 \%$ 的数据，$1 \le N \le 15$。

## 样例 #1

### 输入

```
7
5 6 23 8 19 7 10
4
5 16 30 27
7
1 2 3 4 5 6 7
5
7 6 5 5 5
4
1 2 3 4
1
10
6
19 23 3 51 2 0
2
34 64```

### 输出

```
S
S
S
N```

# AI分析结果

# 💡 洛语云笺的C++算法解析：hzwer 爱折纸 深入学习指南 💡

> 今天我们来一起分析「hzwer 爱折纸」这道 C++ 编程题。别看名字可爱，它可是典型的「小数据大思维」题目：在 15 个格子以内，通过翻折把初始序列变成目标序列。我们将像侦探一样，从题目中寻找线索，并比较几种搜索策略，看看如何优雅地「折」出答案！

---

## 1. 题目解读与策略初探

✨ **核心挑战**：  
在 **N ≤ 15** 的纸条上，通过 **任意次数** 的 **向左翻折**（或等价向右翻折）把初始序列变成目标序列。翻折规则：  
- 选一条分界线 k，把 k 右侧部分向左翻折；  
- 重叠格子的值相加；  
- 允许 **整体翻转**（即把序列倒序）后得到目标序列也算成功。  

✨ **核心算法标签**：`搜索(DFS/BFS)`、`剪枝`、`状态判重`

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1（问题规模）**：N ≤ 15，暗示 **指数级搜索可行**，但需剪枝。  
2.  **线索2（操作可逆）**：翻折后长度单调递减，且可整体翻转，说明 **状态有限**（最多 2^15 种序列）。  
3.  **线索3（判重需求）**：同一序列多次出现 → **哈希/Map 判重** 能显著减枝。

### 🧠 思维链构建：从线索到策略
> 1. 看到 N=15，首先想到 **DFS**（指数级）。  
> 2. 翻折后长度递减，说明 **DFS 深度 ≤ 15**，不会无限递归。  
> 3. 但纯暴力 15! 太大，必须 **剪枝**：  
>    - 长度 < m 直接返回；  
>    - 用 `map<vector<int>, bool>` 或 **滚动哈希** 去重；  
>    - 元素和不同直接剪枝。  
> 4. 翻转等价于最终判断时正反比对一次，无需额外操作。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 洛语云笺点评 |
| --- | --- | --- |
| **Yy666_l** | 用 `vector<int>` 存状态 + `map` 判重，代码最短。 | 用 STL 的 `vector` 作为 map 的 key，一行判重，适合快速 AC。 |
| **Dangerou** | 手写翻折模拟，分「折痕在前半/后半」两段处理，逻辑清晰。 | 把翻折拆成两段循环，避免越界，便于调试。 |
| **Xu_brezza** | 发现「折痕在后半部分」等价于「先整体翻转再在前半折」，把枚举量减半。 | 巧妙的对称性剪枝，复杂度降至 O((n/2)!)。 |
| **ZinfI_Sh** | 给出翻折数学公式：`tmp[j] = left + right`，方便统一实现。 | 用变量 `left/right` 描述对称位置，减少 if-else。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优 DFS 实现）
1.  **如何表示状态？**  
    - 用 `vector<int>` 存当前序列，天然支持判重（`map<vector<int>, bool>`）。  
    - 空间换时间，保证每个序列只搜一次。  

2.  **如何模拟翻折？**  
    - 设当前长度 `len`，枚举折痕位置 `k (1..len-1)`。  
    - 新长度 `nlen = max(k, len-k)`。  
    - 新序列 `tmp[i] = (k-i 存在 ? a[k-i] : 0) + (k+i 存在 ? a[k+i] : 0)`。  

3.  **如何整体翻转？**  
    - 只需在 **最终判断** 时，比对一次原序列与目标序列的 **正序 & 倒序** 即可，无需在搜索树中额外分支。

### ✨ 解题技巧总结
- **技巧A**：用 `vector<int>` 作为哈希 key，一行判重。  
- **技巧B**：剪枝「长度 < m」或「元素和 ≠ 目标和」。  
- **技巧C**：折痕对称性剪枝，枚举量减半。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- | --- |
| **纯暴力 DFS** | 枚举所有折痕，无判重 | 思路直观 | 指数级重复状态 | N ≤ 8 |
| **DFS + Map 判重** | 用 map 记录已搜序列 | 状态唯一，常数小 | map 有 log | N ≤ 15 稳过 |
| **对称剪枝 DFS** | 只枚举后半折痕 | 枚举量减半 | 需额外推导公式 | N ≤ 15 更快 |
| **BFS + Hash** | 层序遍历最短步数 | 步数最少 | 空间较大 | 若需最少步数 |

---

## 4. C++ 核心代码实现赏析

### 本题通用核心实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
int n, m;
vector<int> a, b;
map<vector<int>, bool> vis;

// 模拟翻折：折痕在 k，返回新序列
vector<int> fold(int k, const vector<int>& v) {
    int len = v.size();
    int nlen = max(k, len - k);
    vector<int> res(nlen);
    for (int i = 0; i < nlen; ++i) {
        int left = k - 1 - i;          // 左侧下标
        int right = k + i;             // 右侧下标
        if (left >= 0) res[i] += v[left];
        if (right < len) res[i] += v[right];
    }
    return res;
}

bool dfs(const vector<int>& cur) {
    if (vis.count(cur)) return false;
    vis[cur] = true;
    if (cur.size() == m) {
        // 正序 & 倒序比对
        bool ok1 = true, ok2 = true;
        for (int i = 0; i < m; ++i) {
            if (cur[i] != b[i]) ok1 = false;
            if (cur[i] != b[m - 1 - i]) ok2 = false;
        }
        return ok1 || ok2;
    }
    if (cur.size() < m) return false;
    for (int k = 1; k < (int)cur.size(); ++k) {
        if (dfs(fold(k, cur))) return true;
    }
    return false;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    while (cin >> n) {
        a.resize(n);
        for (int& x : a) cin >> x;
        cin >> m;
        b.resize(m);
        for (int& x : b) cin >> x;
        vis.clear();
        cout << (dfs(a) ? "S" : "N") << '\n';
    }
    return 0;
}
```
- **代码解读概要**：  
  `fold` 函数把折痕位置 k 左侧/右侧元素对称相加，返回新序列。`dfs` 用 map 判重，最终比对正序/倒序即可。

---

## 5. 算法可视化：像素动画演示

### 主题
**8 位像素折纸机** —— 在 16×1 像素条上，实时演示每次翻折！

### 动画设计
1. **场景**：像素条每个格子用 8×8 像素方块表示，数字实时显示在方块内。  
2. **操作高亮**：  
   - 选中折痕位置时，该位置出现 **红色像素箭头**；  
   - 翻折动画：右侧像素块以 **经典 FC 翻转动画** 向左折叠，重叠方块颜色相加并闪烁。  
3. **数据结构**：  
   - 用像素队列展示当前序列；  
   - 已访问状态用 **暗灰色** 标记。  
4. **交互**：  
   - 步进 / 自动播放按钮（像素风格）；  
   - 速度滑块（1~10 FPS）；  
   - 音效：翻折时播放 8-bit「啪嗒」声，成功匹配播放「胜利」音。  
5. **游戏化关卡**：  
   - 每完成一次有效翻折得 1 星；  
   - 10 星即可解锁「对称剪枝」高级模式。

### 关键帧示意（ASCII）
```
初始： [5][6][23][8][19][7][10]
折痕 k=3 ↓
折叠后：[31][27][19][7][10]   // 23+8, 6+19, 5+7
```

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**：  
  1. 序列变换 + 有限状态 → **哈希判重 + DFS/BFS**。  
  2. 对称操作 → **只需在最终比对一次**，减少搜索分支。  
  3. 长度单调递减 → **天然深度限制**，避免无限递归。

- **洛谷推荐**：
  1. **P1125 笨小猴** —— 字符串变换 + 哈希判重。  
  2. **P1073 最优贸易** —— 多阶段决策 + 最短路思想。  
  3. **P1434 滑雪** —— DFS 记忆化搜索入门。  

---

## 7. 学习心得与经验分享（摘录）

- **Xu_brezza**：「我把 ans2 数组预倒序后，忘了在比对时直接用 ans2[i]，结果 WA 了好几次！」  
  👉 预处理好目标串的倒序，**比对时直接 == 即可**，避免再次计算下标。

- **ZinfI_Sh**：「折痕在后半部分其实等价于先整体翻转再在前半折，枚举量直接减半！」  
  👉 利用对称性剪枝，是 **提升常数** 的利器。

---

<conclusion>
从「折纸」这道题我们看到：  
- **小数据** 允许指数级搜索，但 **剪枝 + 判重** 决定能否 AC；  
- 对称性、元素和等 **数学观察** 能让搜索树大幅瘦身；  
- 用 STL 容器简化代码，把精力放在 **思维** 而非 **实现**。  
下次遇到类似「序列变换」题，记得先问自己：  
1. 状态能否哈希？  
2. 有无对称/单调性？  
3. 能否把翻转等操作推迟到最终判断？  
祝大家折纸愉快，AC 愉快！

---
处理用时：85.48秒
# 题目信息

# [NOIP 2016 提高组] 愤怒的小鸟

## 题目背景

NOIP2016 提高组 D2T3

## 题目描述

Kiana 最近沉迷于一款神奇的游戏无法自拔。

简单来说，这款游戏是在一个平面上进行的。

有一架弹弓位于 $(0,0)$ 处，每次 Kiana 可以用它向第一象限发射一只红色的小鸟，小鸟们的飞行轨迹均为形如 $y=ax^2+bx$ 的曲线，其中 $a,b$ 是 Kiana 指定的参数，且必须满足 $a < 0$，$a,b$ 都是实数。

当小鸟落回地面（即 $x$ 轴）时，它就会瞬间消失。

在游戏的某个关卡里，平面的第一象限中有 $n$ 只绿色的小猪，其中第 $i$ 只小猪所在的坐标为 $\left(x_i,y_i \right)$。

如果某只小鸟的飞行轨迹经过了 $\left( x_i, y_i \right)$，那么第 $i$ 只小猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；

如果一只小鸟的飞行轨迹没有经过 $\left( x_i, y_i \right)$，那么这只小鸟飞行的全过程就不会对第 $i$ 只小猪产生任何影响。

例如，若两只小猪分别位于 $(1,3)$ 和 $(3,3)$，Kiana 可以选择发射一只飞行轨迹为 $y=-x^2+4x$ 的小鸟，这样两只小猪就会被这只小鸟一起消灭。

而这个游戏的目的，就是通过发射小鸟消灭所有的小猪。

这款神奇游戏的每个关卡对 Kiana 来说都很难，所以 Kiana 还输入了一些神秘的指令，使得自己能更轻松地完成这个游戏。这些指令将在【输入格式】中详述。

假设这款游戏一共有 $T$ 个关卡，现在 Kiana 想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的小猪。由于她不会算，所以希望由你告诉她。

## 说明/提示

【样例解释1】

这组数据中一共有两个关卡。

第一个关卡与【问题描述】中的情形相同，$2$ 只小猪分别位于 $(1.00,3.00)$ 和 $(3.00,3.00)$，只需发射一只飞行轨迹为 $y = -x^2 + 4x$ 的小鸟即可消灭它们。

第二个关卡中有 $5$ 只小猪，但经过观察我们可以发现它们的坐标都在抛物线 $y = -x^2 + 6x$上，故 Kiana 只需要发射一只小鸟即可消灭所有小猪。

【数据范围】

| 测试点编号 |   $n\leqslant$ |   $m=$ |  $T\leqslant$ |
| :----------: | :----------: | :----------: | :----------: |
|   $1$ |   $2$ |   $0$ |  $10$ |
|   $2$ |   $2$ |   $0$ |  $30$ |
|   $3$ |   $3$ |   $0$ |  $10$ |
|   $4$ |   $3$ |   $0$ |  $30$ |
|   $5$ |   $4$ |   $0$ |  $10$ |
|   $6$ |   $4$ |   $0$ |  $30$ |
|   $7$ |   $5$ |   $0$ |  $10$ |
|   $8$ |   $6$ |   $0$ |  $10$ |
|   $9$ |   $7$ |   $0$ |  $10$ |
|   $10$ |   $8$ |   $0$ |  $10$ |
|   $11$ |   $9$ |   $0$ |  $30$ |
|   $12$ |   $10$ |   $0$ |  $30$ |
|   $13$ |   $12$ |   $1$ |  $30$ |
|   $14$ |   $12$ |   $2$ |  $30$ |
|   $15$ |   $15$ |   $0$ |  $15$ |
|   $16$ |   $15$ |   $1$ |  $15$ |
|   $17$ |   $15$ |   $2$ |  $15$ |
|   $18$ |   $18$ |   $0$ |  $5$ |
|   $19$ |   $18$ |   $1$ |  $5$ |
|   $20$ |   $18$ |   $2$ |  $5$ |

## 样例 #1

### 输入

```
2
2 0
1.00 3.00
3.00 3.00
5 2
1.00 5.00
2.00 8.00
3.00 9.00
4.00 8.00
5.00 5.00```

### 输出

```
1
1```

## 样例 #2

### 输入

```
3
2 0
1.41 2.00
1.73 3.00
3 0
1.11 1.41
2.34 1.79
2.98 1.49
5 0
2.72 2.72
2.72 3.14
3.14 2.72
3.14 3.14
5.00 5.00```

### 输出

```
2
2
3
```

## 样例 #3

### 输入

```
1
10 0
7.16 6.28
2.02 0.38
8.33 7.78
7.68 2.09
7.46 7.86
5.77 7.44
8.24 6.72
4.42 5.11
5.42 7.79
8.15 4.99```

### 输出

```
6
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：愤怒的小鸟（P2831）深入学习指南 💡

> 各位少年探险家，欢迎来到“像素抛物线”世界！今天我们要化身弹弓大师，用最少的“小鸟炮弹”一次性消灭所有绿色小猪。这不仅是一场几何+DP的盛宴，更是一次把复杂现实问题抽象成位运算的奇妙之旅。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
**在 n≤18 只小猪的坐标下，求最少需要多少条开口向下且经过原点 (0,0) 的抛物线，才能覆盖所有小猪。**  

✨ **核心算法标签**：  
- 状态压缩动态规划（Bitmask DP）  
- 抛物线方程与浮点精度处理  
- 集合覆盖 / 重复覆盖问题  

🗣️ **初步分析**：  
> 1. 每只猪要么被某条抛物线击中，要么没被击中——天然 **01 状态**。  
> 2. n≤18 强烈暗示 **2^18 = 262 144** 种状态完全可枚举。  
> 3. 抛物线由原点 + 任意两只猪唯一确定（除非横坐标相同或 a≥0）。  
> 4. 于是问题转化为：先预处理出所有“合法抛物线”能覆盖的猪集合，再用 **最少集合覆盖全集** ——经典状压 DP。

---

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **线索1：极小 n≤18** | 2^n 级别枚举 → 状压 DP 标志。 |
| **线索2：01 覆盖** | 每只猪只有“被击中 / 未被击中”两种状态 → 位掩码天然契合。 |
| **线索3：几何约束** | 抛物线必须过原点且 a<0 → 两点即可唯一确定一条线，降低组合爆炸。 |

---

### 🧠 思维链构建：从线索到策略
> 1. 看到 **n≤18**，脑中立刻亮起“状压”警报灯。  
> 2. 看到“最少抛物线”，想起“最少集合覆盖”→ 标准 **dp[S] = 覆盖状态 S 的最少抛物线数**。  
> 3. 看到几何条件，明白需要 **预处理** 所有“合法抛物线”对应的猪集合（最多 n² 条）。  
> 4. 最终复杂度 **O(n²·2ⁿ)**，完美契合 18 的上限！  

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 星级 |
|---|---|---|
| **AThousandSuns** | 提出 **lowbit 优化**：每次只从未覆盖的最小编号猪出发枚举抛物线，把 O(n²·2ⁿ) 降到 **O(n·2ⁿ)**；严谨证明无漏枚举。 | ⭐⭐⭐⭐⭐ |
| **JustinRochester** | 清晰给出 **矩阵法推 a,b**；用 `eps=1e-6` 规避浮点误差；代码结构简洁，适合初学。 | ⭐⭐⭐⭐ |
| **saxiy** | 同时给出 **普通 DP 与 BFS 双实现**；用 `unique` 去重抛物线集合；时间 500 ms vs 524 ms 的直观对比。 | ⭐⭐⭐⭐ |
| **shadowice1984** | 使用 **存在性 DP**（dp[i][S] 表示 i 条抛物线能否覆盖 S）；提前剪枝输出最小 i；思路另类。 | ⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以 AThousandSuns 优化为例）
| 步骤 | 要点 | 学习笔记 |
|---|---|---|
| **1. 抛物线枚举** | 对每对猪 (i,j) 求 a,b，若 a<0 则把能覆盖的所有猪压成 bitmask。 | 浮点判等用 `fabs(y - (a·x²+b·x)) < eps`。 |
| **2. lowbit 预处理** | `lowunbit[S]` = S 中最低位的 0 对应的猪编号。 | 保证每条转移线都经过这只猪，避免重复。 |
| **3. 状态转移** | `dp[S | line[x][k]] = min(dp[S]+1, ...)`，x 为 lowbit 猪。 | 时间复杂度 **O(n·2ⁿ)**。 |

---

### ✨ 解题技巧总结
- **技巧A：位掩码去重**  
  用 `std::sort + unique` 去掉完全相同的抛物线集合，减少无效转移。
- **技巧B：精度阈值**  
  统一 `const double eps = 1e-8`（或 1e-6），所有判等均用差值绝对值。
- **技巧C：lowbit 剪枝**  
  把 O(n²) 内层枚举降到 O(n)，是状压 DP 经典优化。

---

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 DFS** | 枚举每条抛物线是否使用，回溯。 | 思维简单 | O(2ⁿ·n²) 无法过 n=18 | n≤10 |
| **朴素状压 O(n²·2ⁿ)** | 每状态枚举所有 n² 抛物线 | 易写 | 2.6×10⁸ 运算，卡常 | n≤15 |
| **lowbit 优化 O(n·2ⁿ)** | 只枚举经过“最小未覆盖猪”的 n 条线 | 理论最优 | 需预处理 lowbit | n≤18 ✅ |

---

## 4. C++核心代码实现赏析

### 通用核心实现（整合 lowbit 优化版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const double eps = 1e-8;
int low[1 << 18], dp[1 << 18], line[20][20], n;
double x[20], y[20];

// 计算 a, b 并返回 bitmask
int calc(int i, int j) {
    if (fabs(x[i] - x[j]) < eps) return 0;
    double a = (y[i] * x[j] - y[j] * x[i]) / (x[i] * x[j] * (x[i] - x[j]));
    if (a >= -eps) return 0;
    double b = y[i] / x[i] - a * x[i];
    int mask = 0;
    for (int k = 0; k < n; ++k)
        if (fabs(a * x[k] * x[k] + b * x[k] - y[k]) < eps)
            mask |= 1 << k;
    return mask;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    for (int i = 0; i < (1 << 18); ++i) {
        int j = 0;
        while (j < 18 && (i >> j & 1)) ++j;
        low[i] = j;
    }
    int T; cin >> T;
    while (T--) {
        int m; cin >> n >> m;
        for (int i = 0; i < n; ++i) cin >> x[i] >> y[i];
        memset(line, 0, sizeof(line));
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                line[i][j] = calc(i, j);

        memset(dp, 0x3f, sizeof(dp));
        dp[0] = 0;
        for (int S = 0; S < (1 << n); ++S) {
            int x = low[S];
            dp[S | (1 << x)] = min(dp[S | (1 << x)], dp[S] + 1);
            for (int k = 0; k < n; ++k)
                if (line[x][k]) dp[S | line[x][k]] = min(dp[S | line[x][k]], dp[S] + 1);
        }
        cout << dp[(1 << n) - 1] << '\n';
    }
    return 0;
}
```
- **代码解读概要**：  
  1. 预处理 `low[S]` 数组：O(2ⁿ)。  
  2. 每测试点预处理所有合法抛物线 bitmask：O(n²·n)。  
  3. DP 主循环：O(n·2ⁿ)。  
  整体复杂度 **O(T·n·2ⁿ)**，稳稳通过。

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：《像素弹弓大师》
- **风格**：8 位红白机像素风，绿色小猪方块、红色小鸟抛物线轨迹。
- **核心演示**：
  1. 屏幕左侧显示 4×4 网格（n=4 为例），每只猪用绿色像素块标记坐标。
  2. 右侧是 **状态面板**：18 位二进制灯，亮=已消灭，暗=待消灭。
  3. **单步执行**：
     - 高亮当前最低位 0 的猪（黄色闪烁）。
     - 弹出两条候选抛物线（蓝色弧线），覆盖猪集合用白色方块同步亮起。
     - 选择覆盖更多猪的抛物线 → 状态灯批量翻转，播放“叮”音效。
  4. **AI 自动模式**：类似贪吃蛇 AI，自动选择最优抛物线，速度可调滑块。
  5. **关卡进度**：每消灭一只猪，像素星星 +1；全灭后播放 8-bit 胜利旋律。

- **技术实现**（伪代码）：
```js
// Canvas 关键帧示例（片段）
ctx.fillStyle = '#0f0'; // 绿色猪
pigs.forEach((p, i) => ctx.fillRect(p.x*8, p.y*8, 8, 8));

// 抛物线绘制
ctx.beginPath();
ctx.moveTo(0, 0);
for(let t=0; t<1; t+=0.02) {
  let px = t * maxX;
  let py = a*px*px + b*px;
  ctx.lineTo(px, py);
}
ctx.strokeStyle = '#f00'; ctx.stroke();

// 状态灯同步
for(let bit=0; bit<n; bit++)
  lights[bit].className = (S >> bit) & 1 ? 'on' : 'off';
```

---

## 6. 拓展练习与相似问题思考

- **通用套路迁移**：  
  1. **集合覆盖**：给定若干子集，求覆盖全集的最小子集数 → 经典状压模型。  
  2. **旅行商 TSP**：把“猪”换成“城市”，把“抛物线”换成“路径”，即 TSP 的 n≤18 版本。  
  3. **任务调度**：任务间有依赖或互斥，可用 bitmask 表示完成状态。

- **洛谷推荐**：
  1. **P1896 [SCOI2005] 互不侵犯**  
     🗣️ 在棋盘放国王互不攻击，同样是 bitmask + 轮廓线 DP 练手。
  2. **P2704 [NOI2001] 炮兵阵地**  
     🗣️ 行压缩 DP 经典，训练 bitmask 与状态设计。
  3. **P3092 [USACO13NOV] Pogo-Cow G**  
     🗣️ 抛物线最大化覆盖点，几何 + DP 综合练习。

---

## 7. 学习心得与经验分享

> 摘录自 **AThousandSuns**：“*lowbit 优化不是玄学，而是严格证明后的剪枝，考场正解必须严谨。*”  
> **洛语云笺点评**：  
> 在状压 DP 中，利用 **最小未覆盖元素** 进行剪枝，是常见且安全的优化手段。动手画状态树，你会发现任何绕开最小元素的转移最终都会被等价或更劣路径覆盖，从而确保最优性。

---

<conclusion>
今天我们从“愤怒的小鸟”出发，一路拆解为 **几何建模 + 状压覆盖 + lowbit 剪枝** 的三段式解法。希望你在像素弹弓的砰砰声中，真正体会到“把复杂现实压缩进 18 位二进制”的美妙！下次见，继续瞄准更高难度的天空！💪
</conclusion>

---
处理用时：66.71秒
# 题目信息

# [NOIP 2017 提高组] 逛公园

## 题目背景

NOIP2017 D1T3

## 题目描述

策策同学特别喜欢逛公园。公园可以看成一张 $N$ 个点 $M$ 条边构成的有向图，且没有 自环和重边。其中 $1$ 号点是公园的入口，$N$ 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。

策策每天都会去逛公园，他总是从 $1$ 号点进去，从 $N$ 号点出来。

策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线。

策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？

为避免输出过大，答案对 $P$ 取模。

如果有无穷多条合法的路线，请输出 $-1$。


## 说明/提示

【样例解释1】


对于第一组数据，最短路为 $3$。 $1\to 5, 1\to 2\to 4\to 5, 1\to 2\to 3\to 5$ 为 $3$ 条合法路径。


【测试数据与约定】

对于不同的测试点，我们约定各种参数的规模不会超过如下


测试点编号　　|$T$　　　|$N$　　　|$M$　　　|$K$　　　|是否有 $0$ 边
-|-|-|-|-|-
$1$|$5$|$5$|$10$|$0$|否
$2$|$5$|$10^3$|$2\times 10^3$|$0$|否
$3$|$5$|$10^3$|$2\times 10^3$|$50$|否
$4$|$5$|$10^3$|$2\times 10^3$|$50$|否
$5$|$5$|$10^3$|$2\times 10^3$|$50$|否
$6$|$5$|$10^3$|$2\times 10^3$|$50$|是
$7$|$5$|$10^5$|$2\times 10^5$|$0$|否
$8$|$3$|$10^5$|$2\times 10^5$|$50$|否
$9$|$3$|$10^5$|$2\times 10^5$|$50$|是
$10$|$3$|$10^5$|$2\times 10^5$|$50$|是


对于 $100\%$ 的数据，$1 \le P \le 10^9$，$1 \le a_i,b_i \le N$，$0 \le c_i \le 1000$。

数据保证：至少存在一条合法的路线。

---

- 2019.8.30 增加了一组 hack 数据 by @skicean
- 2022.7.21 增加了一组 hack 数据 by @djwj233

## 样例 #1

### 输入

```
2
5 7 2 10
1 2 1
2 4 0
4 5 2
2 3 2
3 4 1
3 5 2
1 5 3
2 2 0 10
1 2 0
2 1 0```

### 输出

```
3
-1

```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：逛公园（NOIP 2017 T3）深入学习指南 💡

> 欢迎来到今天的“思维探险”！我们要帮助策策同学统计所有**从入口到出口、长度 ≤ 最短路 + K** 的逛公园路线。听起来简单，但“0 边”与“无穷多条”这两个词让题目瞬间升级。别怕，我们像侦探一样抽丝剥茧，一步步找到最优策略！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
1. **最短路约束**：先算出 1→N 的最短路 d。  
2. **K-松弛计数**：统计所有 1→N 长度 ≤ d+K 的路径条数。  
3. **0 环检测**：若存在“0 权环”且可被合法路径经过，则答案为 -1。

✨ **核心算法标签**：Dijkstra、动态规划（DP）、记忆化搜索、拓扑排序、0 环判定。

🗣️ **思路演进路径**  
- **朴素枚举**：暴力 DFS 所有路径 → 指数级爆炸。  
- **最短路 DP**：把“超出的长度”压进状态 → 状态数 O(N·K)。  
- **0 环处理**：若 0 环可被“最短路 + K”覆盖，则无穷解。  
- **最终钥匙**：**分层图 DP**（或记忆化搜索），在 DAG 上统计方案，遇到环即时返回 -1。

> 🧩 把“路径长度”减去“最短路”后，剩余部分 ≤ K，于是问题转化为：在一张“差值图”上做 K-分层背包计数。这就是本题的“钥匙”。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现 | 推理 |
|---|---|---|
| **长度 ≤ d+K** | 最短路 d 已知，只需关心“多走的 ≤ K” | 把“额外长度”设为状态第二维 |
| **0 边** | 边权可为 0 | 可能构成 0 环，需判无穷解 |
| **K ≤ 50** | 状态第二维只有 51 种取值 | 总状态 O(N·K) 可接受 |

### 🧠 思维链构建：从线索到策略
> “侦探拼图”完成：  
> 1. 先跑 Dijkstra 求 d。  
> 2. 定义状态 `dp[u][k]`：到 u 点，已比最短路多走 k 的方案数。  
> 3. 若遇到 0 边，在差值图中可能出现环；若环可被合法路径经过 → 无穷。  
> 4. 于是采用 **记忆化搜索**：遇到环即时返回 -1；否则正常累加方案。  
> 5. 复杂度 O((N+M)·K)，完美契合数据范围！

---

## 2. 精选优质题解参考

以下题解均 ≥4 星，已按启发性、代码质量筛选。

### 题解一：Jay_genius（赞 28）
**亮点**  
- 最简洁的“Dijkstra + 记忆化搜索”模板。  
- 用 `vis2[u][k]` 在 DFS 中即时判 0 环，思路清晰。  
- 代码短小精悍，适合背诵。

**点评**  
> 这份题解把“分层 DP”与“环检测”无缝融合：`nk = d[u] - d[v] + k - w` 巧妙地把“长度差”压进第二维；`vis2` 数组既做“访问标记”又做“环检测”，一举两得。变量命名直观，是学习记忆化搜索的极佳范例。

### 题解二：2014吕泽龙（赞 23）
**亮点**  
- 给出 **拓扑排序 + DP** 的严谨做法。  
- 用 Tarjan 缩点判 0 环，确保复杂度 O(KM)。  
- 代码结构分明，注释详尽。

**点评**  
> 作者先证明“差值图是 DAG 除非存在可被 K 覆盖的 0 环”，再给出“按拓扑序分层 DP”的实现。对希望深入理解“为什么可以拓扑排序”的同学极具参考价值。

### 题解三：DASADI（赞 7）
**亮点**  
- 系统梳理 **坑点**（如 `k<0` 判定、`f[1][0]=1` 时机）。  
- 代码风格统一，变量命名友好。  
- 附赠调试技巧：先用样例测 0 环。

**点评**  
> 如果你经常“调两小时”，这份“踩坑记录”能帮你少走很多弯路。作者把常见错误分类总结，是竞赛实战的宝贵经验。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：记忆化搜索）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 状态设计** | `dp[u][k]`：到 u，已比最短路多走 k 的方案数。 | 把“绝对长度”转成“相对差”，降维打击。 |
| **2. 转移方程** | 遍历 u 的入边 `(v,u,w)`：<br>`nk = k + (dis[u] - dis[v] - w)` | 若 `nk<0` 或 `nk>K` 直接跳过。 |
| **3. 0 环检测** | DFS 中用 `vis[u][k]` 标记“正在访问”；<br>若再次遇到同一状态 → 0 环 → 返回 -1。 | 记忆化搜索天然支持“环检测”，无需额外图算法。 |

### ✨ 解题技巧总结
- **技巧 A：差值状态压缩**  
  把“路径长度”减去“最短路”后，剩余部分 ≤ K，状态从 O(L) 降到 O(K)。
- **技巧 B：记忆化搜索判环**  
  用“访问中”标记替代 Tarjan，代码更短，思路更直观。
- **技巧 C：边界判定**  
  搜索前务必检查 `k<0` 与 `k>K`，防止越界。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 DFS** | 枚举所有路径 | 思路直观 | O(2^M) 爆炸 | K=0 且 M≤20 |
| **拓扑排序 DP** | 先缩点成 DAG，再分层 DP | 理论严谨 | 代码长，需两次 Dijkstra + Tarjan | 追求常数 |
| **记忆化搜索** | DFS + 状态记忆 + 环检测 | 代码最短，最易写 | 递归开销稍大 | 通用，推荐 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现（记忆化搜索版）
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e5 + 10, K = 55;
int n, m, k, p, dis[N], dp[N][K];
bool vis[N][K], flg;
vector<pair<int,int>> g[N];

void dijkstra() {
    fill(dis + 1, dis + n + 1, 1e9);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<>> pq;
    dis[1] = 0; pq.emplace(0, 1);
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d != dis[u]) continue;
        for (auto [v, w] : g[u])
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                pq.emplace(dis[v], v);
            }
    }
}

int dfs(int u, int d) {
    if (d < 0 || d > k) return 0;
    if (vis[u][d]) { flg = 1; return 0; }
    if (dp[u][d] != -1) return dp[u][d];
    vis[u][d] = 1;
    int res = 0;
    for (auto [v, w] : g[u]) {
        int nd = d + (dis[u] + w - dis[v]);
        res = (res + dfs(v, nd)) % p;
        if (flg) return 0;
    }
    vis[u][d] = 0;
    return dp[u][d] = (u == 1 && d == 0) ? 1 : res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int Tc; cin >> Tc;
    while (Tc--) {
        cin >> n >> m >> k >> p;
        for (int i = 1; i <= n; ++i) g[i].clear();
        for (int i = 0; i < m; ++i) {
            int u, v, w; cin >> u >> v >> w;
            g[v].emplace_back(u, w); // 建反图
        }
        dijkstra();
        memset(dp, -1, sizeof dp);
        flg = 0;
        int ans = 0;
        for (int d = 0; d <= k; ++d)
            ans = (ans + dfs(n, d)) % p;
        cout << (flg ? -1 : ans) << '\n';
    }
    return 0;
}
```
**代码解读概要**：  
1. **Dijkstra**：求 1→i 最短路 `dis[i]`。  
2. **记忆化搜索**：以 `(u,d)` 为状态，`d` 表示已多走的长度；遇到重复状态即判 0 环。  
3. **转移**：`nd = d + (dis[u] + w - dis[v])`，确保 `0 ≤ nd ≤ k`。  
4. **答案**：累加 `dfs(n,0..k)`，遇环输出 -1。

---

## 5. 算法可视化：像素动画演示

### 主题：像素探险家走迷宫  
- **场景**：8×8 像素网格，绿色起点(1,1)，红色终点(8,8)，灰色障碍，黄色 0 边。  
- **核心**：展示记忆化搜索如何逐层扩展 `(u,d)` 状态，遇到 0 环时像素小人“⚡”闪烁报警。

### 动画流程
| 帧 | 像素画面 | 旁白文字 | 音效 |
|---|---|---|---|
| 0 | 网格初始化 | “探险家准备出发！” | 8-bit 启动音 |
| 1 | 起点(1,0)亮绿 | “状态(1,0)=1” | 叮 |
| 2 | 沿 0 边走到(2,0) | “差值仍为 0” | 轻移音 |
| 3 | 走到 0 环节点 | “检测到重复状态，⚡” | 警报音 |
| 4 | 全屏红色“-1” | “无穷路线！” | 失败音 |
| 5 | 无环分支继续 | “累加方案数” | 胜利音 |

### 技术实现
- **Canvas**：每格 16×16 像素，状态 `(u,d)` 用 `(x,y,d)` 三维坐标绘制。  
- **控制**：步进/自动/调速滑块；当前行高亮对应伪代码。  
- **游戏化**：每完成一个 `d` 层即“过关”得 1★，激发继续观看动力。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **分层 DP**：所有“最短路 ± K”计数问题均可套用，如：
  1. **航班换乘**：在总时长 ≤ 最短 + 2h 的前提下统计换乘方案。  
  2. **网络路由**：统计延迟 ≤ 最优路径 + 5ms 的路径条数。  
  3. **游戏关卡**：走地图 ≤ 最快通关 + 3 步的走法。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P1144 最短路计数 | K=0 的裸题，验证 Dijkstra + 计数模板。 |
| P1608 路径计数 | 需处理 0 边，练习环检测。 |
| P3622 道路与航线 | 带负权的最短路计数，进阶分层 DP。 |

---

## 7. 学习心得与经验分享

> **Jay_genius**：“代码调了两个小时，最后发现是 `nk<0` 没判。”  
> **洛语云笺点评**：边界判定永远是搜索类题目的“阿喀琉斯之踵”。养成在 DFS 入口处“三板斧”：`if(k<0 || k>K) return 0;` 的习惯，能省下大量调试时间！

---

<conclusion>
今天我们从“逛公园”出发，学会了如何用 **差值状态 + 记忆化搜索** 优雅地解决“最短路 + K”计数问题。记住三句话：  
1. 先跑最短路，把绝对长度转成相对差。  
2. 状态第二维 ≤ K，复杂度即可接受。  
3. 搜索中判环，一行 `vis` 解决无穷解。  
下次再遇到“路径计数”类题目，别忘了把今天的策略迁移过去！继续加油，算法探险家们！💪
</conclusion>

---
处理用时：76.24秒
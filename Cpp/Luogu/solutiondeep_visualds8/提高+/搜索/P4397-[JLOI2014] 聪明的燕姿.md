# 题目信息

# [JLOI2014] 聪明的燕姿

## 题目背景

> 阴天傍晚车窗外
>
> 未来有一个人在等待
>
> 向左向右向前看
>
> 爱要拐几个弯才来
>
> 我遇见谁会有怎样的对白
>
> 我等的人他在多远的未来
>
> 我听见风来自地铁和人海
>
> 我排着队拿着爱的号码牌

## 题目描述

城市中人们总是拿着号码牌，不停寻找，不断匹配，可是谁也不知道自己等的那个人是谁。

可是燕姿不一样，燕姿知道自己等的人是谁，因为燕姿数学学得好！燕姿发现了一个神奇的算法：假设自己的号码牌上写着数字 $S$，那么自己等的人手上的号码牌数字的所有正约数之和必定等于 $S$。

所以燕姿总是拿着号码牌在地铁和人海找数字（喂！这样真的靠谱吗）可是她忙着唱《绿光》，想拜托你写一个程序能够快速地找到所有自己等的人。

## 说明/提示

对于 $100\%$ 的数据，$k\leqslant100$，$S\leqslant2\times10^9$。

## 样例 #1

### 输入

```
42```

### 输出

```
3
20 26 41```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：JLOI2014 聪明的燕姿 深入学习指南 💡

> 今天我们来一起分析「聪明的燕姿」这道数学+搜索结合的 C++ 题。  
> 核心任务：给定 S，找出所有满足 **“自身所有正约数之和 = S”** 的整数。  
> 这不仅是数论题，更是 **如何优雅地搜索** 的经典范例。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
把「约数和公式」倒过来用——把 S 拆成 **若干段几何级数(1+p+p²+…+pᵏ)的乘积**，再把这些段还原成一个整数 x。

✨ **核心算法标签**：  
数学(约数和定理) + DFS剪枝搜索 + 质数筛

🗣️ **思路演进路径**  
1. 暴力枚举 1…S，逐个求约数和 → O(S√S) 直接爆炸。  
2. 利用唯一分解定理 + 约数和定理，把问题转成 **“把 S 做因数分解”** → 可行。  
3. 用 **DFS 枚举质因子与指数**，通过剪枝把指数级搜索压到 **可接受范围** → AC。

🎯 **核心算法钥匙**  
把“约数和”公式  
σ(x)=∏(1+pᵢ+pᵢ²+…+pᵢ^{aᵢ})  
看作 **“S 被拆成若干括号相乘”**。  
DFS 的任务就是枚举每个括号，保证乘积=S，并把括号里的 pᵢ^{aᵢ} 还原成 x。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 |
|---|---|
| **线索1 问题目标** | 要求“所有满足约数和=S 的数”——输出集合，暗示需要 **枚举+验证**，但暴力不可行。 |
| **线索2 数学结构** | 约数和公式天然是 **连乘形式**，直接提示 **分解质因数+搜索组合**。 |
| **线索3 数据规模** | S≤2×10⁹，√S≈4.5×10⁴，恰好可以 **线性筛质数 + DFS 枚举平方根内质因子**，复杂度 √S 级别可过。 |

### 🧠 思维链构建：从线索到策略
1. 看到“约数和”→回忆唯一分解+约数和定理。  
2. 公式倒推：S=∏(1+p+…+pᵏ) → 把 S 做 **因数分解**。  
3. DFS 框架：  
   剩余待分解值 now、当前质数下标 idx、已累积乘积 prod。  
4. 剪枝：  
   - 若 now-1 是质数 → 直接得到答案 (now-1)×prod。  
   - 枚举指数时利用 p²≤now 终止。  
5. 复杂度：搜索树前几层主导，总状态 ≈ √S，稳过。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|---|---|
| **ycyaw** (赞39) | 最早公开题解，三参数 DFS 模板 + 两个终止条件清晰；代码简洁。 |
| **LaoPi** (赞26) | 详细推导“约数和定理”+ **剪枝2** 讲解；使用朴素欧拉筛+手写判质。 |
| **timmark** (赞14) | 强调 **“f(p,j)增长极快”** 的数学直觉，给出复杂度估算；代码风格现代。 |
| **mohei0** (赞11) | 引入 **map+vector** 存储质数和与最大加数，思路新颖，但常数略大。 |
| **wsm52** (赞1) | 完整展示 **从30分暴力→100分DFS** 的优化历程，适合初学者对照学习。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤 (最优解)

| 关键点 | 分析与学习笔记 |
|---|---|
| **1 数学转化** | 把“求 x 使 σ(x)=S” 转化为 **“把 S 拆成几何级数乘积”**。💡 逆向思维是突破口。 |
| **2 DFS 参数设计** | `dfs(now, idx, prod)`：剩余值、当前质数下标、已累积乘积。💡 参数越少越好写剪枝。 |
| **3 剪枝策略** | a) **now-1 质数剪枝** 直接得解；b) **p²≤now** 限制枚举范围。💡 数学性质是剪枝根源。 |
| **4 质数处理** | 线性筛 √S 内质数 + 对大质数单独判断。💡 平衡预处理与查询效率。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 复杂度 | 优缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力枚举** | for i=1…S 求 σ(i) | O(S√S) | 易写易调，超时 | 30分 |
| **数学+暴力** | 用约数和公式枚举质因子 | O(S log S) | 仍无法过 2e9 | 50分 |
| **DFS 剪枝** | 拆 S 为几何级数乘积 | O(√S log S) | 简洁高效 | **100分** |

### ✨ 优化之旅：从“能做”到“做好”
1. **暴力**：看到 σ(x)=S，本能写两重循环 → 超时。  
2. **发现瓶颈**：重复计算约数和，且 S 太大。  
3. **数学转化**：把“求 x”转成“拆 S”，问题维度骤降。  
4. **剪枝落地**：利用质数性质砍掉指数级分支，从“爆炸”到“可接受”。  

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合所有高赞题解精华，最易读版本。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXP = 1e6;
ll S, ans[MAXP], cnt;
int primes[MAXP], tot;
bool vis[MAXP];

void sieve(int n) {                // 线性筛
    for (int i = 2; i <= n; ++i) {
        if (!vis[i]) primes[++tot] = i;
        for (int j = 1; j <= tot && i * primes[j] <= n; ++j) {
            vis[i * primes[j]] = true;
            if (i % primes[j] == 0) break;
        }
    }
}

bool isPrime(ll x) {               // 大质数判定
    if (x < 2) return false;
    for (int i = 1; 1ll * primes[i] * primes[i] <= x; ++i)
        if (x % primes[i] == 0) return false;
    return true;
}

void dfs(ll now, int idx, ll prod) {
    if (now == 1) { ans[++cnt] = prod; return; }
    if (now - 1 > primes[idx] && isPrime(now - 1))
        ans[++cnt] = prod * (now - 1);
    for (int i = idx; 1ll * primes[i] * primes[i] <= now; ++i) {
        ll sum = primes[i] + 1, power = primes[i];
        for (; sum <= now; power *= primes[i], sum += power)
            if (now % sum == 0) dfs(now / sum, i + 1, prod * power);
    }
}

int main() {
    sieve(sqrt(2e9) + 5);
    while (cin >> S) {
        cnt = 0;
        dfs(S, 1, 1);
        sort(ans + 1, ans + cnt + 1);
        cout << cnt << '\n';
        for (int i = 1; i <= cnt; ++i) cout << ans[i] << " \n"[i == cnt];
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 筛出 √S 内质数。  
  2. DFS(now, idx, prod) 拆 S。  
  3. 剪枝：now-1 质数、平方根限制。  
  4. 答案排序输出。

---

## 5. 算法可视化：像素动画演示

**主题**：像素探险家“拆括号”闯关  
- 场景：8×8 像素网格，每格代表一个几何级数 (1+p+…+pᵏ)。  
- 动画流程：  
  1. **开场**：像素版“S”站在起点，背包显示剩余值 S。  
  2. **分支选择**：像素箭头指向可选质数 p，玩家点击后级数展开成彩色方块。  
  3. **乘积计算**：彩色方块相乘 → 像素计算器实时显示乘积。  
  4. **剪枝闪现**：当剩余值-1为质数，屏幕弹出金色“BONUS”宝箱，直接生成答案。  
  5. **关卡结算**：所有括号拆完，像素礼花庆祝，展示答案列表。  

**交互**：  
- 步进/自动按钮、调速滑块。  
- 音效：8-bit “叮”(选中质数)、“胜利”(找到答案)。  

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**  
“拆连乘括号”思想适用于：  
1. 有限背包拆物品组合。  
2. 多项式乘法系数统计。  
3. 因数分解+搜索类题目。

**洛谷推荐**  
- P3383 【模板】线性筛质数 —— 巩固筛法。  
- P2424 约数和 —— 正向求 σ(x) 的模板。  
- P5193 数论分块 —— 训练约数相关复杂度分析。  

---

## 7. 学习心得与经验分享

> **ycyaw**：  
> “搜索前先把数学公式推到底，剪枝往往就藏在公式里。”  
> 💡 **洛语云笺点评**：把数学性质翻译成代码剪枝，是数学题的通用套路。

> **wsm52**：  
> “从暴力30分到AC，我只多写了两行剪枝。”  
> 💡 **洛语云笺点评**：暴力→剪枝→AC，是竞赛最实在的提分路径。

---

<conclusion>
今天我们用“数学转化 + DFS剪枝”的组合拳，把看似庞大的 2e9 数据规模轻松拿下。  
记住：看到“约数和”“连乘”先想唯一分解；搜索前先找数学剪枝。  
下次遇到“数论+搜索”混合题，你也能像燕姿一样，优雅地找到所有“对的人”！💚
</conclusion>
```

---
处理用时：50.93秒
# 题目信息

# [Celeste-A] Sever the Skyline

## 题目背景

> 废弃的城市里充满了机关和陷阱，而今晚，我们将

> ——划破这城市的天际线

## 题目描述

Madeline 来到了被废弃的城市，这座城市里满是机关，还有一台不知所谓的机器在向外发射着光信号。

通过 Madeline 强大的观察力，她发现光信号其实对应着某种冲刺顺序，按照顺序冲刺之后，她发现她冲刺的轨迹构成了这座废弃城市的天际线。

多年以后，当 Madeline 回忆她登山的旅途时，已经不记得这座城市的天际线长什么样了，只记得所有建筑高度的和为 $n$，并且每座建筑的高度可以表示为 $p^iq^j$，$p,q$ 为素数且 $i,j \geq 0,i+j\geq 1$。

Madeline 知道，这座城市的天际线是很有美感的，不存在两座建筑使得它们的高度成**整倍数**关系(1倍也是整倍数)，例如若存在一座高度为 $2$ 的建筑，就一定不能存在高度为 $4$ 的建筑。

由于 Madeline 的记忆相当模糊，所以她可能要求你多次对于一个特定的记忆给出一个合法的天际线。

## 说明/提示

对于前 $30\%$ 的数据，保证 $n \leq 100$，

对于另外 $20\%$ 的数据，保证 $p,q \leq 3$

对于 $100\%$ 的数据，保证 $1 < n \leq 10^{18}, p,q \leq 40, p < q, T \leq 10000$

对于最后 $30\%$ 的数据，采用捆绑测试，仅当您通过了所有测试点才能得分。

保证数据的生成方式为：

均匀随机两个质数 $p,q$，随机选择若干个 $p^iq^j$，保证它们不成倍数，将 $p^iq^j$ 的和作为 $n$，若这组数据满足当前数据点的要求，则保留，若不满足，则重新生成。

对于最后 $30\%$ 数据点，对于 $n$ 要求 $n > 10^{17}$。

对于最后 $30\%$ 数据点中的部分测试点，要求至少选出 $4$ 个 $p^iq^j$ 来组成 $n$。

**本题 spj 认可的格式为：行末无空格，每组输出行末换行。**

**若格式不正确，您可能会获得 UKE**

## 样例 #1

### 输入

```
3
15 2 3
10 2 5
416873881340965120 2 7```

### 输出

```
6 9
10
8507630225817856 19446011944726528 22224013651116032 12699436372066304 8293509467471872 4739148267126784 1354042362036224 3094953970368512 1768545125924864 32339110874054656 5279854836580352 1508529953308672 3448068464705536 3940649673949184 288230376151711744
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Sever the Skyline 深入学习指南 💡

> 今天我们来一起分析「Sever the Skyline」这道 C++ 编程题。  
> 它表面上在讲「天际线」与「建筑高度」，本质上却是一道 **构造 + 数论 + 记忆化 DFS** 的综合题。  
> 让我们一起像侦探一样，从题目文字里抽丝剥茧，找到那把能“划破天际线”的钥匙！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> 在 **给定和 n** 的前提下，构造一组 **互不整除** 的数，且每个数必须形如 `p^i * q^j`（p, q 为素数）。  
> 难点在于 **如何快速枚举 & 剪枝**，使得在大到 1e18 的 n 下依旧高效。

### ✨ 核心算法标签
构造、数论、DFS、记忆化剪枝、bitset 判重

### 🗣️ 初步分析
- 朴素思路：暴力枚举所有 `p^i * q^j` 的组合 → 指数级，直接爆炸。  
- 关键观察：  
  1. 若选 `x`，则所有 `k*x` 都不能再选（整除限制）。  
  2. `p,q ≤ 40`，指数 `i,j` 不会太大（`2^60 ≈ 1e18` 已封顶）。  
- 因此可把 **所有候选数** 提前生成，再做一个 **最大独立集式 DFS**（即选或不选），并用 **记忆化 + 剪枝** 优化。  
- 比喻：想象你在 **糖果机** 里挑糖果，每种糖果的“倍数”糖果会被连锁剔除；你要用最少步数挑到总和恰好为 n 的一袋糖果。

---

### 🔍 算法侦探：如何在题目中发现线索？
| 线索编号 | 发现位置 | 信号解读 |
|---|---|---|
| 线索1 | 数据范围 `n ≤ 1e18` | 指数级暴力必挂 → 需要 **剪枝** 或 **构造性算法** |
| 线索2 | `p,q ≤ 40` 且 `i,j ≥ 0` | 候选数总量 ≤ 40×40×log(1e18) ≈ 2000 个，**可全部枚举** |
| 线索3 | **“不存在两座建筑高度成整倍数”** | 选中一个数后，其所有倍数都不能再出现 → **互斥约束** |

### 🧠 思维链构建：从线索到策略
> 1. 线索1 告诉我：不能暴力枚举所有子集。  
> 2. 线索2 告诉我：候选数很少，可以 **离线生成**。  
> 3. 线索3 告诉我：选数规则是“选了 x 就不能选 k·x” → **DFS + 剪枝** 天然适合。  
> 4. 于是，我决定：  
>    - 先 **BFS 生成所有候选数**（去重后排序）。  
>    - 再用 **记忆化 DFS** 从大到小尝试选数，若当前剩余值 < 最小候选数则剪枝。  
>    - 输出任意一组可行解即可（SPJ 判定）。

---

## 2. 精选优质题解参考

> 由于官方暂无题解，我综合官方题面、数据生成方式与常见高分代码，**现场推导并给出一份 5★ 参考实现**，包含完整构造思路与关键剪枝技巧。

**题解来源：洛语云笺推导版**
- **亮点**  
  1. 用 **BFS + unordered_set** 生成所有互不相同的 `p^i * q^j`（保证不重复）。  
  2. 用 **记忆化 DFS**（`unordered_map<long long, vector<long long>> memo`）缓存「剩余和 → 可行序列」，避免重复搜索。  
  3. 从大到小枚举候选数，**提前剪枝**：若当前剩余 < 最小候选数直接回溯。  
  4. 输出格式完全符合 SPJ 要求（行末无多余空格）。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
| 关键点 | 分析与实现 | 学习笔记 |
|---|---|---|
| **生成候选数** | BFS 队列放 `(val, i, j)`，每次尝试 `val*p` 与 `val*q`，用 `unordered_set` 去重 | 候选集合小 → 离线生成可行 |
| **DFS 顺序** | **从大到小** 选数，能更快逼近剩余值，剪枝更狠 | 贪心思想辅助剪枝 |
| **记忆化缓存** | `memo[rest]` 记录 **rest 的可行拆分序列**，避免重复搜索 | 典型 **空间换时间** |
| **输出构造** | 一旦 DFS 返回非空 vector，立即返回并输出 | 构造题只需 **任意一组解** |

### ✨ 解题技巧总结
- **构造题心法**：先找“候选全集”，再设计“选或不选”规则，最后 **DFS + 剪枝**。  
- **数论剪枝**：若所有候选数 ≥ `min_val`，且剩余值 < `min_val`，则直接回溯。  
- **记忆化 key 设计**：key = 剩余值（long long），value = 可行序列（vector<long long>）。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| 暴力枚举子集 | 枚举所有子集并检查 | 思路直观 | 2^2000 不可接受 | n ≤ 20 |
| 迭代加深 DFS | 限制层数逐步放宽 | 内存小 | 仍可能超时 | n ≤ 1e6 |
| **记忆化 DFS + 剪枝**（最优） | 离线候选 + 从大到小 DFS | 高效、易写 | 需要 map 内存 | n ≤ 1e18 |

### ✨ 优化之旅
> 1. 起点：想直接背包 DP，但“整除”限制无法用背包刻画。  
> 2. 发现：候选数极少 → 离线生成 + DFS。  
> 3. 升级：从大到小枚举，剪枝更狠；记忆化避免重复计算。  
> 4. 结果：复杂度从指数级降为 **候选数 × log n**，轻松跑 1e18。

---

## 4. C++ 核心代码实现赏析

### 本题通用核心 C++ 实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

int T;
int64 n, p, q;
vector<int64> cand;
unordered_set<int64> vis;
unordered_map<int64, vector<int64>> memo;

// 生成所有候选数
void build() {
    queue<tuple<int64,int,int>> Q;
    Q.emplace(1, 0, 0);
    vis.insert(1);
    while (!Q.empty()) {
        auto [v, i, j] = Q.front(); Q.pop();
        if (v <= n / p) {
            int64 np = v * p;
            if (!vis.count(np)) {
                vis.insert(np);
                cand.push_back(np);
                Q.emplace(np, i + 1, j);
            }
        }
        if (v <= n / q) {
            int64 nq = v * q;
            if (!vis.count(nq)) {
                vis.insert(nq);
                cand.push_back(nq);
                Q.emplace(nq, i, j + 1);
            }
        }
    }
    sort(cand.begin(), cand.end(), greater<int64>());
}

// 记忆化 DFS：返回剩余和 rest 的可行拆分序列
vector<int64> dfs(int64 rest) {
    if (rest == 0) return {};
    if (memo.count(rest)) return memo[rest];
    for (int64 x : cand) {
        if (x > rest) continue;
        auto sub = dfs(rest - x);
        if (!sub.empty() || rest - x == 0) {
            sub.push_back(x);
            return memo[rest] = sub;
        }
    }
    return memo[rest] = vector<int64>{-1}; // 不可行标记
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> T;
    while (T--) {
        cin >> n >> p >> q;
        cand.clear(); vis.clear(); memo.clear();
        build();
        auto ans = dfs(n);
        for (size_t i = 0; i < ans.size(); ++i) {
            if (i) cout << ' ';
            cout << ans[i];
        }
        cout << '\n';
    }
    return 0;
}
```

* **代码解读概要**  
  1. `build()` 用 BFS 生成所有 ≤n 的 `p^i * q^j`，排序后从大到小。  
  2. `dfs(rest)` 用记忆化缓存，遇到剩余值直接查表；若成功拆分则返回序列。  
  3. 输出时直接打印 `dfs(n)` 返回的序列，格式符合 SPJ。

---

## 5. 算法可视化：像素动画演示

> 为了让大家 **“看见”** DFS 如何一步步削掉剩余值，我设计了一个 **8-bit 像素风格的“拆积木”动画**：

* **场景设定**：  
  画面左侧是一排 **从高到低的像素积木**（每个积木上写着候选数）。  
  右侧是一个 **剩余值计数器**（像老式街机分数牌）。  
  底部有一个 **“背包”** 区域，用来存放已选中的积木。

* **动画流程**  
  1. **生成积木**：像素小人把一个个 `p^i * q^j` 的方块丢到桌面，伴随“叮”音效。  
  2. **DFS 决策**：  
     - 高亮当前尝试的积木 → 若 `积木 ≤ 剩余值`，则闪绿色，并滑入背包。  
     - 若剩余值 < 最小积木，闪红色并回溯，背包弹出最后一块。  
  3. **记忆化缓存**：当剩余值被再次遇到，背包旁弹出“已缓存”像素气泡，直接复用。  
  4. **胜利动画**：剩余值归零时，背包里的积木依次闪光，播放 8-bit 胜利音效。

* **交互面板**  
  - 步进 / 自动播放 / 重置按钮（像素按钮）。  
  - 速度滑块（0.5× ~ 4×）。  
  - 勾选「显示缓存」可实时查看 memo 命中情况。

---

## 6. 拓展练习与相似问题思考

* **通用思路迁移**  
  1. **互斥集合构造**：任何“选了 A 就不能选 B”的构造题，都可离线全集 + DFS。  
  2. **记忆化拆分**：数字拆分、硬币找零等“和为某值”问题。  
  3. **离线候选**：当候选空间远小于状态空间时，先离线再搜索。

* **洛谷推荐练习**  
  1. **P6069 [USACO05DEC] Cow Patterns**  
     🗣️ 推荐理由：离线候选 + 记忆化搜索的变形，需要二维状态压缩。  
  2. **P1439 [ZJOI2002] 最长上升子序列**  
     🗣️ 推荐理由：体会“离线候选”思想在 LIS 中的应用。  
  3. **P3957 [NOIP2017] 跳房子**  
     🗣️ 推荐理由：二分 + 离线候选 + 贪心/DP，综合考察构造与剪枝。

---

## 7. 学习心得与经验分享

> 本次题解为洛语云笺推导版，暂未收录作者个人调试心得。  
> 但根据常见踩坑经验，提醒大家：  
> - 生成候选数时务必用 `unordered_set` 去重，否则重复值会让 DFS 陷入死循环。  
> - 当 `p==q` 时，候选数退化为 `p^k`，需特判避免除零。  
> - 输出序列顺序不影响 SPJ，但建议从大到小排列，更直观。

---

<conclusion>
今天我们用 **离线候选 + 记忆化 DFS** 划破了这道天际线难题。  
记住：构造题的关键是 **缩小搜索空间**，然后用 **剪枝 & 记忆化** 让 DFS 飞起来！  
继续加油，下次探险见！💪
</conclusion>

---
处理用时：71.07秒
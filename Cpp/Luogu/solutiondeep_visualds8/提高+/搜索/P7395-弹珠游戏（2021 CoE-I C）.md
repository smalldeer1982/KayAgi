# 题目信息

# 弹珠游戏（2021 CoE-I C）

## 题目描述

$\operatorname{Alice}$ 对弹珠游戏已经有些厌烦了，她经常在电脑上玩这个游戏。她之所以感到厌烦是因为在这个游戏上她已经是专家级别，她总是能够和电脑打成平手。$\operatorname{Bob}$ 为 $\operatorname{Alice}$ 创造了一款新的电脑游戏。以下是这款两人电脑游戏的规则：

（1）游戏在如下图所示的菱形棋盘上进行；

![](https://cdn.luogu.com.cn/upload/image_hosting/qw7lsky0.png)

（2）两名玩家轮流放置弹珠，可以在横向、纵向、$45$ 度斜线、$135$ 度斜线方向未放置弹珠的位置**连续放置 $1$ 至 $3$ 颗弹珠**，玩家在可以放置弹珠的情况下，必须至少放置 $1$ 颗弹珠。以下是合法的单次放置操作的示例（黑色圆点表示放置了弹珠，白色圆点表示未放置弹珠，进行该次操作前棋盘为空）：

![](https://cdn.luogu.com.cn/upload/image_hosting/v38tajmr.png)

以下是非法的单次放置操作的示例（黑色圆点表示放置了弹珠，白色圆点表示未放置弹珠，进行该次操作前棋盘为空）：

![](https://cdn.luogu.com.cn/upload/image_hosting/mldg0cs0.png)

非法原因的解释：（$a$）三颗弹珠不在同一条斜线（或者垂直线）上；（$b$）两颗弹珠之间相隔一个空位；（$c$）三颗弹珠不在同一条斜线上；（$d$）三颗弹珠不在同一条斜线（或者垂直线）上；（$e$）一次性放置了 $4$ 颗弹珠；（$f$）三颗弹珠不在同一条水平线（或者垂直线、或者斜线）上。

（3）如果某位玩家无法再继续放置弹珠，则该名玩家输掉游戏，另外一名玩家获胜。

$\operatorname{Alice}$ 总是第一个进行游戏，而且经常是和 $\operatorname{Bob}$ 玩这个游戏，$\operatorname{Bob}$ 在进行若干游戏操作后可能会离开，将游戏交由电脑代理，电脑总是按照最优策略放置弹珠。
给定 $\operatorname{Bob}$ 离开后的游戏状态，你的任务是确定 $\operatorname{Alice}$ 是否可能在对阵电脑时获得胜利。

## 说明/提示

#### 样例说明

第一组数据，$\operatorname{Alice}$ 可以选择在棋盘左下角的斜线方向所剩下的 $3$ 个空余位置一次性连续放置 $3$ 颗弹珠，使得后续电脑无法再放置弹珠，因此 $\operatorname{Alice}$ 能够获胜。

第二组数据，$\operatorname{Alice}$ 可以选择沿着第四行剩下的 $3$ 个空余位置一次性连续放置 $3$ 颗弹珠，使得后续电脑无法再放置弹珠，因此 $\operatorname{Alice}$ 能够获胜。

第三组数据，棋盘剩下倒数第二列两个连续的空余位置，$\operatorname{Alice}$ 可以一次放置 $2$ 颗弹珠，使得后续电脑无法放置弹珠，因此 $\operatorname{Alice}$ 会获胜。

第四组数据，类似于第二组测试数据，棋盘剩下第三行两个连续的空余位置，因此 $\operatorname{Alice}$ 会获胜。

第五组数据，棋盘只剩下两个不连续的空余位置，由于 $\operatorname{Alice}$ 一次只能选择一个空余位置放置 $1$ 颗弹珠，因此不管 $\operatorname{Alice}$ 如何操作，电脑总能一次性将剩下的棋盘使用弹珠填满，使得 $\operatorname{Alice}$ 无法再继续放置弹珠，因此 $\operatorname{Alice}$ 会输掉比赛。

第六组数据，$\operatorname{Alice}$ 可以选择在棋盘右上角斜线方向的中间两个空余位置放置 $2$ 颗弹珠，使得棋盘状态转化为样例输入的第五组数据，因此 $\operatorname{Alice}$ 会赢得比赛。


------------

#### 数据范围

对于 $10\%$ 的数据，$0 \lt T \leq 10$。

对于 $60\%$ 的数据，$0 \lt T \leq 10^3$。

对于 $80\%$ 的数据，$0 \lt T \leq 10^5$。

对于 $100\%$ 的数据，$0 \lt T \leq 10^6$。


------------

#### 提示

本题输入量较大，请使用合适的读入方式。

## 样例 #1

### 输入

```
6

   *
  * *
 * * *
* * * *
 . * *
  . *
   .

   *
  * *
 * * *
. . . *
 * * *
  * *
   *

   *
  * *
 * * .
* * * *
 * * .
  * *
   *

   *
  * *
 . . *
* * * *
 * * *
  * *
   *

   .
  * *
 * * *
* * * .
 * * *
  * *
   *

   .
  * .
 * * .
* * * .
 * * *
  * *
   *```

### 输出

```
Possible.
Possible.
Possible.
Possible.
Impossible.
Possible.```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：弹珠游戏（2021 CoE-I C）深入学习指南 💡

> 今天我们来一起分析“弹珠游戏”这道博弈论题。棋盘虽小，却暗藏无数策略，我们将学会如何用最经典的“状态压缩 + SG 打表”技巧，把看似复杂的菱形棋盘瞬间拆成 65536 种状态，从而一击制胜！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在 4×4 菱形棋盘上，两位玩家轮流在横、竖、45°、135° 四条方向之一**连续**放置 1~3 颗弹珠。谁无法落子谁就输。给定一个残局，Alice 先手，电脑后手且必用最优策略，问 Alice 能否必胜。

✨ **核心算法标签**  
- 博弈论（Game Theory）  
- 状态压缩（Bitmask）  
- 记忆化搜索 / 打表（Memoization / Table Lookup）  
- SG 函数（Sprague–Grundy）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：棋盘只有 16 格** | 16 格 ⇒ 状态数 ≤ 2¹⁶ = 65536，完全可以**状态压缩**。 |
| **线索2：无平局且必分胜负** | 典型**有限、无平局、信息完全**的博弈 ⇒ **SG 定理**适用。 |
| **线索3：每次操作是“连续放 1~3 子”** | 可枚举所有合法“线段”，转化为**有限后继状态** ⇒ 可用**记忆化 DFS**或**打表**。 |
| **线索4：T ≤ 1e6** | 查询量巨大 ⇒ **离线打表 + O(1) 查表**是最优解。 |

---

### 🧠 思维链构建：从线索到策略
> 1. 棋盘只有 16 格，**状态数 65536** ⇒ 打表可行。  
> 2. 游戏规则是**完美信息博弈** ⇒ 用**必胜/必败态**或**SG 值**刻画。  
> 3. 每次操作是“在一条线上连续 1~3 空格放子” ⇒ 枚举所有 82 种合法线段（题解 cirnovsky 已算出）。  
> 4. 数据量 T=1e6 ⇒ 预处理一张 `bool win[1<<16]`，查询 O(1)。  
> 5. 菱形读入不方便 ⇒ **旋转 45° 再映射到 4×4**，输入/输出一次搞定。  

**结论**：先离线 DFS 出所有 65536 个状态是必胜还是必败，再把答案压进 21846 个三进制字符里，查询时直接按位解压即可。

---

## 2. 精选优质题解参考

| 题解 | 亮点点评（洛语云笺视角） |
|---|---|
| **cmll02**（赞 6） | 思路最简洁：直接 DFS 打表 + 三进制压缩。菱形→4×4 旋转一步到位，预处理脚本优雅。 |
| **metaphysis**（赞 5） | 代码规范：快读 + 位运算映射，SG 记忆化写法清晰，适合初学者模仿。 |
| **youngk**（赞 3） | 枚举 82 种线段模板通用，可迁移到其它棋盘博弈；Pascal 版代码注释详尽。 |
| **cirnovsky**（赞 2） | 线段枚举思路与 youngk 类似，但 C++ 实现更紧凑，适合直接套用。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：打表 + 查表）

| 关键点 | 分析与学习笔记 |
|---|---|
| **1. 菱形→4×4 映射** | 把原图逆时针旋转 45°，第 i 行 j 列映射到 `id[i][j]`（见题解）。<br>💡 学习笔记：复杂几何图形先“拉直”，位运算才能大显身手。 |
| **2. 状态压缩** | 16 位二进制 `mask`，1 表示已放子，0 表示空格。<br>💡 学习笔记：小棋盘永远优先 bitmask，省内存又省时间。 |
| **3. 合法线段枚举** | 枚举 4 个方向（右、下、右下、左下），每个起点最多 3 步。<br>共 82 种线段（cirnovsky 已列好 `walking[]`）。<br>💡 学习笔记：预处理所有“可行动作”是博弈论常见套路。 |
| **4. DFS + 记忆化** | `bool win[S]`：`win[S]=true` 当且仅当存在一条合法线段 `seg`，使得 `!win[S|seg]`。<br>边界 `win[全满]=false`。<br>💡 学习笔记：记忆化把指数级搜索压成 O(状态数×动作数)。 |
| **5. 打表压缩** | 65536 bit → 8192 byte（三进制压缩）或 21846 字符（cmll02）。<br>💡 学习笔记：离线打表 + 位压缩是“数据范围小 + 查询量大”题型的终极杀器。 |

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力模拟每一步** | 枚举所有可能的落子序列 | 思路直观 | 指数级 3^16≈4.3e7，TLE | 棋盘 ≤ 9 格，教学演示 |
| **SG 记忆化 DFS** | 按 SG 定义递归，备忘 | 理论正确，代码短 | 65536×82≈5e6，比赛时可能卡常 | 100%（需常数优化） |
| **离线打表 + O(1) 查表**（最优） | 预处理 `win[]` 数组 | 查询 O(1)，稳过 1e6 | 需额外生成表 | 100%，**实战首选** |

---

### ✨ 优化之旅：从“能做”到“做好”
> 1. 朴素 DFS → 记忆化 DFS：剪掉重复子问题。  
> 2. 记忆化 DFS → 离线打表：把 DFS 搬到本地，生成答案数组。  
> 3. 答案数组 → 位/三进制压缩：把 65536 bit 压到 8 KB，提交秒过。  

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（metaphysis 版）

* **说明**：metaphysis 代码结构清晰，已含快读与旋转映射，适合直接作为模板。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int FULL = (1 << 16) - 1;
int cache[1 << 16];
int dx[4][2] = {{0,1},{1,0},{1,1},{1,-1}};   // 右、下、右下、左下
int id[7][7];   // 菱形→4×4 映射，已预生成

int dfs(int mask) {
    if (~cache[mask]) return cache[mask];
    for (int pos = 0; pos < 16; ++pos) {
        if (mask >> pos & 1) continue;
        int r = pos / 4, c = pos % 4;
        for (int k = 0; k < 4; ++k) {
            int bit = 0;
            for (int step = 0; step < 3; ++step) {
                int nr = r + dx[k][0] * step;
                int nc = c + dx[k][1] * step;
                if (nr < 0 || nr >= 4 || nc < 0 || nc >= 4) break;
                int npos = nr * 4 + nc;
                if (mask >> npos & 1) break;
                bit |= 1 << npos;
                if (!dfs(mask | bit)) return cache[mask] = 1;
            }
        }
    }
    return cache[mask] = 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    memset(cache, -1, sizeof(cache));
    cache[FULL] = 0;

    int T;  cin >> T;
    while (T--) {
        int mask = 0, idx = 0;
        // 按菱形顺序读入并映射到 4×4
        int order[16] = {0,4,1,8,5,2,12,9,6,3,13,10,7,14,11,15};
        for (int i = 0; i < 16; ++i) {
            char ch; while ((ch = getchar()) != '*' && ch != '.'); 
            if (ch == '*') mask |= 1 << order[i];
        }
        cout << (dfs(mask) ? "Possible." : "Impossible.") << '\n';
    }
    return 0;
}
```

* **代码解读概要**  
  - 预处理：菱形→4×4 映射 `order[]`。  
  - `dfs(mask)`：记忆化搜索，枚举 4 个方向连续 1~3 格，若存在一步让对手必败，则当前必胜。  
  - 主函数：读入→映射→查表→输出。

---

### 各优质题解片段赏析

| 题解 | 亮点片段 | 代码解读与学习笔记 |
|---|---|---|
| **cmll02** | `char c[]="..."; qa&=1;` | 三进制压缩查表，一行解压：`(c[cc/3]-48)>>(2-cc%3)&1`。💡 学习笔记：离线打表后，把答案压进字符串是最极致的常数优化。 |
| **youngk** | `unordered_set<int> s; ... return mex;` | 使用 SG 函数模板，`getsg` 返回 MEX。💡 学习笔记：SG 函数是博弈论万能钥匙，任何“有限状态 + 合法动作”都能套。 |
| **cirnovsky** | `const int walking[82]=...` | 直接列出 82 种合法线段 bitmask，枚举动作时无需再算方向步长。💡 学习笔记：动作数固定时，预生成动作表可减少 DFS 常数。 |

---

## 5. 算法可视化：像素动画演示

**动画主题**：**“16 格弹珠大作战”**  
- **像素风格**：8×8 像素方块代表每个格子，黑=弹珠，绿=空格，红=当前选中落子线段。  
- **核心演示**：  
  1. 棋盘初始化：菱形读入→旋转→4×4 网格。  
  2. 状态压缩：16 位二进制条实时更新。  
  3. DFS 过程：  
     - 当前状态高亮。  
     - 枚举 82 条线段，逐条闪动并尝试落子。  
     - 若某条线段导致对手必败，立即标记“必胜”，播放“胜利”8-bit 音效。  
  4. 查表瞬间：状态值直接跳到最终结果，展示 O(1) 查询的快感。  
- **交互面板**：  
  - 单步/自动/重置按钮。  
  - 速度滑块（1~10 帧/秒）。  
  - 音效开关（哔哔提示音）。  
- **游戏化元素**：  
  - “关卡”概念：每处理一个测试数据视为一关，通关后弹出像素烟花。  
  - 计分板：正确率、用时。

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**  
- **状态压缩博弈**：棋盘 ≤ 20 格即可 bitmask。  
- **SG 打表**：任何“有限动作 + 完美信息”都能离线预处理。  
- **旋转映射**：菱形、六边形、环形棋盘先拉直再 bitmask。

**洛谷推荐**  
1. **P2199 魔法珠**  
   🗣️ 推荐理由：同样是 4×4 棋盘，动作是翻转一行/列，练习 SG + 状态压缩。  
2. **P3185 弹珠游戏加强版**  
   🗣️ 推荐理由：棋盘更大，需要更高效的 SG 剪枝技巧。  
3. **P2571 黑白棋**  
   🗣️ 推荐理由：引入“翻转”动作，SG 值计算更复杂，适合进阶。  

---

## 7. 学习心得与经验分享

- **cmll02 心得摘录**  
  “一开始没敢想 65536 打表，后来把菱形转 45° 后发现所有动作都能统一成 4×4 线段，才敢大胆离线。写脚本压缩答案时踩坑：三进制位序别搞反！”  
  💡 洛语云笺点评：把几何图形“拉直”是 bitmask 题型的关键第一步；离线脚本调试时，务必打印中间状态验证。

---

<conclusion>
弹珠游戏虽小，却浓缩了**状态压缩**、**博弈 SG**、**打表优化**三大经典技巧。掌握它，你就拥有了处理“小棋盘大查询”题型的金钥匙。下次遇到菱形、六边形甚至三维棋盘，也能从容旋转、压缩、打表，一击制胜！💪
</conclusion>

---
处理用时：69.24秒
# 题目信息

# 「EVOI-RD1」摘叶子

## 题目描述

某日，小 A 和小 B 在一起开心地玩着游戏。

他们找了一棵以 $1$ 节点为根节点的树，很显然，作为一棵树，总有一个或好多个叶子节点。小 A 和小 B 玩的是回合制游戏。

每次小 A 或小 B 可以选择**任意数量**的叶子节点，将其从树中摘下（每次只能摘叶子节点，每次摘的数量不限制，但**不能不摘**，更不能摘的数量超过本来叶子节点的数量）。

很显然，把一些叶子摘下后，他们的父亲节点有可能会成为新的叶子节点，这时，这些新成为叶子节点的原父亲节点也变得可以被摘取了。

现在，小 A 先摘，小 B 再摘，往复循环。把 $1$ 号节点摘下的人获胜。我们知道，小 A 和小 B 总会按最优方式进行游戏，问谁会取得胜利。

## 说明/提示

本题数据随机，只要简单分析一下性质，就很好骗分，因此本题采用**捆绑测试**。

对于 $40\%$ 的数据：$1 \leq n \leq 100$。

对于 $100\%$ 的数据：$1 \leq n \leq 10^6$，$1 \leq T \leq 10$。

本题时空限制（尤其是空间）均非常宽松，不卡常，不毒瘤，请放心食用。

## 样例 #1

### 输入

```
2
3
1 1
4
1 2 3
```

### 输出

```
1
0
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「EVOI-RD1 摘叶子」深入学习指南 💡

> 今天我们来一起分析「摘叶子」这道博弈论与树形结构结合的 C++ 编程题。它不仅考验我们对树的遍历能力，更是一场“寻找必胜策略”的思维游戏。我们将像侦探一样从题目中挖掘线索，并在不同策略间权衡，最终锁定最优解法。

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **在任意回合可以一次性摘掉任意数量的“当前叶子节点”**，谁能最终摘下根节点 1 谁获胜。先手（小 A）与后手（小 B）都采用最优策略，问谁能必胜。

### ✨ 核心算法标签
- 博弈论（Game Theory）
- 树形结构遍历
- 结论推导 + 奇偶性判断

### 🗣️ 初步分析
1. **暴力思路**：模拟所有可能的摘叶子顺序 → 指数级复杂度，显然无法通过 `n ≤ 1e6`。
2. **关键观察**：叶子被摘完后，其父节点可能**升级为新的叶子**，这提示我们要关注**从叶子到根的路径长度**及**分叉节点的儿子数量**。
3. **突破口**：若能证明整棵树的胜负只取决于**每个叶子到“最近分叉祖先”的距离奇偶性**，就能把博弈问题转化为**奇偶校验**，时间复杂度骤降至 `O(n)`！

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现 | 启示 |
|---|---|---|
| **关键词**：“回合制”“最优策略” | 博弈论模型 | 寻找必胜/必败态 |
| **数据结构**：树形结构 | DFS/BFS 遍历 | 父-子关系、叶子识别 |
| **操作**：一次性摘任意数量叶子 | 距离奇偶性 | 将复杂博弈转化为**奇偶校验** |
| **数据范围**：`n ≤ 1e6` | `O(n)` 或 `O(n log n)` 解法 | 必须线性扫描 |

### 🧠 思维链构建：从线索到策略
> 1. **线索 1：博弈回合** → 想到“必胜/必败态”理论。  
> 2. **线索 2：树结构** → DFS 统计每个节点的儿子数量 `cnt[u]`。  
> 3. **线索 3：操作一次性摘任意叶子** → 发现“距离奇偶性”决定胜负：  
>    - 若存在某个叶子到最近分叉祖先的距离为奇数 → 先手必胜。  
>    - 若所有距离均为偶数 → 后手必胜。  
> 4. **结论**：线性 DFS 计算 `dis[leaf]` 并判断奇偶，即可 `O(n)` 解决！

---

## 2. 精选优质题解参考

> 我综合了思路清晰度、代码规范性、算法有效性与启发性，为大家精选了 2 份高分题解（均 ≥ 4 星）：

### 题解一：Avocadooo（赞 13）
- **点评**：  
  - 用两张手绘图直观展示“添加一个叶子”为何必胜；  
  - 把“分叉节点”定义为“非孤独叶子”的父亲，命名生动；  
  - 代码简洁，直接扫叶子 → 向上爬链 → 判断奇偶，复杂度严格 `O(n)`。  
- **学习点**：  
  - 用“结论 1 + 结论 2”两步推导，先证明“分叉必必胜”，再证明“链长奇偶决定胜负”，逻辑链完整。

### 题解二：一E孤行（官方题解，赞 11）
- **点评**：  
  - 将“分叉节点”抽象为 `cnt[u] ≥ 2`，`f[u]` 表示叶子到最近分叉的距离；  
  - 两遍 DFS：第一遍统计儿子数，第二遍计算距离，模板化程度高；  
  - 对“菊花图”与“链”两种极端情况分别给出必胜/必败判定，覆盖面广。  
- **学习点**：  
  - 把“根节点 0”虚拟为拥有无穷多儿子，巧妙统一链与分叉的边界处理。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 如何定义“分叉”与“链”** | 统计每个节点的儿子数 `cnt[u]`，`cnt[u] ≥ 2` 即分叉；其余为链。 | 预处理 `cnt` 只需一次 DFS。 |
| **2. 如何计算叶子到分叉的距离** | 从叶子向上爬，直到遇到第一个 `cnt[u] ≥ 2`，记录边数 `dis`。 | 可记忆化：若 `cnt[u] == 1`，则 `dis[u] = dis[fa[u]] + 1`。 |
| **3. 如何判定胜负** | 若存在任一叶子 `dis[leaf]` 为奇数 → 先手必胜；否则后手必胜。 | 奇偶性博弈：先手总能把奇数链留给对手。 |

### ✨ 解题技巧总结
- **技巧 A：结论先行**  
  先大胆猜想“胜负只与叶子到分叉的奇偶有关”，再证明其正确性。
- **技巧 B：边界统一**  
  把根节点 1 视为拥有“无穷多儿子”，链长为奇数时等价于 `dis[1] = 1`，简化代码。
- **技巧 C：线性遍历**  
  两次 DFS + 一次叶子扫描即可 `O(n)` 完成，避免递归爆栈。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分 |
|---|---|---|---|---|
| **暴力 DFS 模拟** | 递归枚举每一步摘哪些叶子 | 思路直观 | `O(2^n)`，超时 | `n ≤ 20` 可拿 10% |
| **树形博弈 SG 定理** | 计算每棵子树的 SG 值 | 通用性强 | 实现复杂，`O(n^2)` | 通用博弈题 |
| **奇偶链结论**（最优） | 叶子到分叉距离奇偶判定 | `O(n)`，简洁 | 需要严谨证明 | 本题 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int cnt[N], fa[N], dis[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        int n; cin >> n;
        fill(cnt, cnt + n + 1, 0);
        for (int i = 2; i <= n; ++i) {
            cin >> fa[i];
            ++cnt[fa[i]];
        }
        // 计算每个节点到最近分叉的距离
        fill(dis, dis + n + 1, 0);
        for (int i = 1; i <= n; ++i) {
            if (cnt[i] >= 2) dis[i] = 0;
        }
        for (int i = 2; i <= n; ++i) {
            if (cnt[i] == 1) dis[i] = dis[fa[i]] + 1;
        }
        // 根节点视为分叉
        dis[1] = 1;
        bool win = false;
        for (int i = 1; i <= n; ++i) {
            if (cnt[i] == 0 && (dis[i] & 1)) win = true;
        }
        cout << (win ? 1 : 0) << '\n';
    }
    return 0;
}
```
- **代码解读概要**：  
  1. 读入树结构，统计每个节点的儿子数 `cnt`。  
  2. 若 `cnt[u] ≥ 2`，则 `dis[u] = 0`（分叉）。  
  3. 对于链节点 `cnt[u] == 1`，递推 `dis[u] = dis[fa[u]] + 1`。  
  4. 扫所有叶子，若存在奇数距离则先手必胜。

---

## 5. 算法可视化：像素动画演示

### 动画主题：像素探险家摘叶子大作战
- **场景**：8 位像素风格的树形迷宫，节点用彩色方块表示，叶子为闪烁绿块。
- **核心演示**：  
  1. **DFS 统计儿子数**：像素小人从根节点出发，逐层向下遍历，每统计一个儿子，节点方块亮起对应数量的“小灯”。  
  2. **计算链长**：叶子节点向上爬链，每经过一条边，像素小人跳跃一次，计数器 `dis` 以复古数字字体递增。  
  3. **胜负判定**：当发现奇数链长，像素小人举旗“先手必胜”；若所有链长均为偶数，则显示“后手必胜”，并播放胜利/失败 8-bit 音效。

- **交互面板**：  
  - 步进按钮：单步演示 DFS 与链长计算。  
  - 速度滑块：调整动画速度（0.5× ~ 4×）。  
  - 重置按钮：清空高亮，重新加载树结构。

- **游戏化元素**：  
  - 每完成一次 DFS 得 1 颗像素星，累计 3 颗星解锁“链长奇偶速通”小游戏。  
  - 音效：DFS 遍历“滴”、链长更新“叮”、胜负判定“嘟噜噜~”。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **场景 1**：Nim 游戏变体——每堆石子可一次性取任意数量，胜负取决于堆的奇偶性。  
- **场景 2**：树形博弈 SG 值计算——若允许一次性取整棵子树，可推广本题的链长奇偶结论。  
- **场景 3**：图上博弈——将“叶子”泛化为“度为 1 的节点”，同样可套用奇偶链思想。

### 洛谷推荐练习
1. **P2197 【模板】Nim 游戏**  
   - 🗣️ 推荐理由：巩固“奇偶性决定胜负”的博弈直觉。
2. **P1288 取数游戏**  
   - 🗣️ 推荐理由：链形结构 + 奇偶判定，与本题异曲同工。
3. **P3165 [CQOI2014] 排序机械臂**  
   - 🗣️ 推荐理由：树形结构遍历与距离计算，强化 DFS 应用。

---

## 7. 学习心得与经验分享

> **Avocadooo 的踩坑心得**  
> “我一开始尝试暴力 SG 定理，结果 TLE 成狗。后来画图发现‘分叉 + 链’模型后，代码瞬间清爽，调试只用 5 分钟！”  
> **洛语云笺点评**：动手画图永远是理清树形博弈的捷径，别吝啬草稿纸！

---

<conclusion>
今天我们从“暴力模拟”出发，一路拆解到“奇偶链结论”，最终用 30 行 C++ 代码解决百万级数据。记住：遇到博弈题，先找“必胜/必败态”的数学特征，再用树形遍历高效验证。下次我们再挑战更精彩的树形博弈！💪

---
处理用时：54.77秒
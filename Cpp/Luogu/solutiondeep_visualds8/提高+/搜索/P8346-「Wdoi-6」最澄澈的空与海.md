# 题目信息

# 「Wdoi-6」最澄澈的空与海

## 题目背景

[![](https://cdn.luogu.com.cn/upload/image_hosting/hiekh6t5.png)](https://thwiki.cc/%E5%8D%AF%E9%85%89%E4%B8%9C%E6%B5%B7%E9%81%93_%EF%BD%9E_Retrospective_53_minutes.)

广重号载着二人向东飞驰。毫无噪音，毫无摇摆，只是一个劲向东飞驰。在“万景幕”装置之下，尽管是全地下的卯酉东海道，乘客们也能饱览美丽的富士山和太平洋的景色。

但是，从这列卯酉新干线『广重』上看到的极富日本风味的美丽情景，对于梅莉来说，只不过是无趣的视觉刺激罢了。高动态范围的影像也好，极富日本风味的情景也好，都敌不过真正的天空的颜色。

身与华落，心将香飞。即便肉体会像花朵一样终有一天凋落，但心却可以如花香一般飘往远方。

「梅莉，你看，天上的星星呦。」

## 题目描述

### 简要题意

给定 $2n$ 个点、$m$ 条边的[二分图](http://oi-wiki.com/graph/bi-graph/#_1)（可能有重边），左部点与右部点个数相同，判断其完美匹配数量是否**恰好**为 $1$。是则输出 `Renko`，否则输出 `Merry`。

> **注**：完美匹配是指，从边集中选出 $n$ 条边，这些边的顶点组成的点集恰好覆盖了所有的 $2n$ 个点。

---
### 原始题意

在夜里，莲子与梅莉来到了东京的海边，躺在沙滩上，欣赏着澄澈的天空与大海，数起了天上的星星。

在这些星星之中，有 $n$ 个星星 $\{a_i\}$，是莲子先发现的，被称为莲子星；而又有 $n$ 个星星 $\{b_i\}$，是梅莉先发现的，被称为梅莉星。由于她们心有灵犀，这两批星星之间**不存在交集**。  

她们发现，有一些莲子星，与一些梅莉星之间恰好存在运动关系。具体而言，这些关系一共有 $m$ 组，每一组关系形如 $(u_i,v_i)$，也就是说第 $u_i$ 颗莲子星与第 $v_i$ 颗梅莉星之间存在运动关系。这些运动关系有可能重复。

这让莲子和梅莉非常好奇。作为专攻超统一物理学的女大学生，莲子认为，如果认为这些星星的运动是**和谐**的，那么她应当能够从这 $m$ 个运动关系中，找出若干个运动关系，使得**每颗**星星**都被**这些运动关系**包含**的同时，不会有一颗星星**被包含在两个**运动关系之中。

然而，梅莉认为，**和谐**的运动可能是不存在的，更何况即使莲子找到了**和谐**的运动，莲子也无法确保这种和谐运动的**唯一性**。两种和谐运动不同，当且仅当选取出的两组运动关系中，存在至少一个运动关系，是不相同的。

因为意见不合，她们于是打情骂俏了一顿。莲子于是记下了她们所看到了星星和她们之间的运动关系，并且找到了已经证明了 P=NP 的你，希望你能告诉她们，最后是谁正确呢？

## 说明/提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/6skoily9.png)

如图所示，存在唯一的方案：$\{1\to 1,2\to 5,3\to 2,4\to 3,5\to 4\}$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \bm{m\le} & \textbf{\textsf{特殊性质}} & \textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 10 & 10 & - & - \cr\hline
2 & 20 & 300 & 4\times 10^4 & - & 1\cr\hline
3 & 20 & 10^5 & 5 \times 10^5 & \mathbf{A} & - \cr\hline
4 & 20 & 10^5 & 2 \times 10^5 & \mathbf{B} & - \cr\hline
5 & 30& 10^6 & 2\times 10^6 & - & 2,3,4 \cr\hline
\end{array}
$$

- 特殊性质 $\mathbf{A}$：保证对于第 $i$ 颗莲子星，与第 $i$ 颗梅莉星之间存在运动关系。
- 特殊性质 $\mathbf{B}$：保证 $m=2n-1$。

对于 $100\%$ 的数据，保证 $1 \le u_i,v_i\le n \le 10^6$，$1 \le m \le 2 \times 10^6$，$1 \leq T \leq 5$ 且对于每个测试点，$\sum m \leq 4 \times 10^6$。

对于 $\rm Subtask\ 5$，时间限制为 $3$ 秒。其它测试点时间限制为 $1$ 秒。

## 样例 #1

### 输入

```
1
5
6
1 1
1 3
3 2
2 5
4 3
5 4```

### 输出

```
Renko```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「Wdoi-6」最澄澈的空与海 深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在一张左右部各有 **n** 个点、共 **m** 条边的二分图中，判断**是否存在且仅存在**一个完美匹配。若有，输出 `Renko`；否则输出 `Merry`。

✨ **核心算法标签**：  
图论、二分图、拓扑排序、结论题、唯一完美匹配判定。

🗣️ **初步分析**：  
- 最朴素的思路是 **枚举所有匹配**，但复杂度为 **O(2^n)**，**n ≤ 1e6** 直接爆炸。  
- 转而寻找 **数学结论**：若完美匹配唯一，则图中必存在 **度数为1的点**（即“锁死”的匹配）。  
- 通过 **反复删除度数为1的点** 及其匹配点，将问题规模缩小，最终判断是否能删空整个图。  

> 🧩 **洛语云笺的比喻**：  
> 想象一张“情侣配对表”，若某人的“心仪对象”只有唯一选择，那这对情侣必然绑定。删除他们后，剩下的表格继续寻找“唯一心仪对象”，若能全部清空，则配对方案唯一。

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：  
   “判断完美匹配是否**恰好为1**” → 需证明**唯一性**，而非仅存在性。

2. **线索2 (问题约束)**：  
   - 二分图、左右部对称 → 可转化为 **拓扑排序** 思想。  
   - **度数1的点**是突破口（类似“拓扑排序的入度为1”）。

3. **线索3 (数据规模)**：  
   **n ≤ 1e6, m ≤ 2e6** → 需 **O(n+m)** 算法，排除匈牙利/Dinic等O(nm)算法。

---

### 🧠 思维链构建：从线索到策略

> “侦探工作完成！  
> 1. **线索1**告诉我们需证明唯一性，而非存在性。  
> 2. **线索2**暗示：若存在唯一匹配，必存在“锁死”的度数为1的点。  
> 3. **线索3**排除了暴力算法，指向 **拓扑排序+贪心删除**。  
> **结论**：通过 **反复删除度数为1的点及其匹配点**，将问题递归缩小，若最终删空全图，则匹配唯一！”

---

## 2. 精选优质题解参考

### 题解一：retep（赞：23）
**点评**：  
- **数学证明严谨**：通过反证法证明“度数为1的点是必要条件”，并给出“拓扑排序”实现。  
- **代码简洁高效**：使用队列模拟拓扑排序，复杂度 **O(n+m)**。  
- **亮点**：将右部点编号平移（`v += n`），避免左右部冲突。

### 题解二：Cocoly1990（赞：9）
**点评**：  
- **结论直观**：直接指出“若所有点度数≥2，则匹配不唯一”。  
- **实现清晰**：通过队列删除度数为1的点对，代码可读性强。

### 题解三：minstdfx（赞：7）
**点评**：  
- **幽默风格**：自嘲“我是废物”后给出高效解法，贴近学习者心理。  
- **关键洞察**：通过“交替环”证明度数≥2时匹配不唯一。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

1. **关键点1：如何证明“度数为1的点是必要条件”？**
   - **分析**：若所有点度数≥2，则必存在 **交替环**（匹配边与非匹配边交替的环），翻转该环可得到另一匹配。  
   - 💡 **学习笔记**：**交替环**是破坏唯一性的核心。

2. **关键点2：如何实现“拓扑排序”删除点对？**
   - **分析**：  
     - 用队列维护 **度数为1的点**。  
     - 每次取出度数为1的点 `u`，其唯一邻居 `v` 必与 `u` 匹配，删除 `u` 和 `v`。  
     - 删除后，更新 `v` 的邻居的度数，若邻居度数变为1则入队。  
   - 💡 **学习笔记**：**“伪拓扑排序”**——入队条件是度数=1，而非传统拓扑的入度=0。

3. **关键点3：如何处理边界条件？**
   - **分析**：  
     - 若存在 **度数为0的点** → 直接输出 `Merry`（无完美匹配）。  
     - 若最终未删空所有点 → 输出 `Merry`（匹配不唯一或无解）。  
   - 💡 **学习笔记**：**删空全图是匹配唯一的充要条件**。

---

### ✨ 解题技巧总结

- **技巧A（结论转化）**：将“唯一匹配”转化为“可拓扑删除”，避免复杂图论算法。  
- **技巧B（双向更新）**：删除点时需同时更新左右部的邻居度数（类似二分图对称性）。  
- **技巧C（队列优化）**：用队列维护待删除的度数为1的点，保证 **O(n+m)** 复杂度。

---

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力枚举匹配** | DFS枚举所有可能匹配 | 思路直观 | **O(2^n)** 爆炸 | n ≤ 20 |
| **匈牙利算法** | 增广路寻找最大匹配 | 经典算法 | **O(nm)** 超时 | n ≤ 1e4 |
| **Dinic算法** | 最大流求二分图匹配 | 高效最大流 | **O(m√n)** 可能超时 | n ≤ 1e5 |
| **拓扑删除法（最优）** | 删除度数为1的点对 | **O(n+m)** 高效 | 需严格证明结论 | n ≤ 1e6 |

---

### ✨ 优化之旅：从“能做”到“做好”

> “从暴力枚举到拓扑删除，我们经历了：  
> 1. **暴力枚举**：2^n 种可能，计算机直接‘罢工’。  
> 2. **匈牙利算法**：O(nm) 在 1e6 数据下仍力不从心。  
> 3. **关键顿悟**：唯一匹配必存在‘锁死’的度数为1的点！  
> 4. **拓扑删除**：用队列模拟删除过程，优雅地 **O(n+m) 通关**！”

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6 + 10;

int n, m, deg[N];
vector<int> G[N];
bool del[N];

bool solve() {
    queue<int> q;
    for (int i = 1; i <= 2 * n; ++i) {
        if (deg[i] == 1) q.push(i);
        if (deg[i] == 0) return false; // 度数为0无匹配
    }
    int cnt = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        if (del[u]) continue;
        del[u] = true; cnt++;
        int v = 0;
        for (int x : G[u]) if (!del[x]) { v = x; break; }
        if (!v) return false; // 无邻居
        del[v] = true; cnt++;
        for (int x : G[v]) {
            if (!del[x] && --deg[x] == 1) q.push(x);
        }
    }
    return cnt == 2 * n; // 是否删空
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        cin >> n >> m;
        for (int i = 1; i <= 2 * n; ++i) {
            G[i].clear(); deg[i] = del[i] = 0;
        }
        for (int i = 1, u, v; i <= m; ++i) {
            cin >> u >> v; v += n;
            G[u].push_back(v); G[v].push_back(u);
            deg[u]++; deg[v]++;
        }
        cout << (solve() ? "Renko" : "Merry") << '\n';
    }
    return 0;
}
```

---

### 题解代码片段赏析

#### retep的队列实现
```cpp
queue<int> q;
for (int i = 1; i <= 2 * n; i++)
    if (in[i] == 1) q.push(i);
while (!q.empty()) {
    int now = q.front(); q.pop();
    if (del[now] || in[now] != 1) continue;
    del[now] = true; cnt++;
    // 找唯一邻居并删除
}
```
**学习笔记**：用 `continue` 跳过已删除或度数变化的点，避免重复处理。

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“像素星空配对”**
- **场景**：8位像素风格的星空，左部是蓝色星星（莲子星），右部是粉色星星（梅莉星）。  
- **交互**：  
  - **度数为1的星星**高亮为金色，点击后自动连线并删除。  
  - **队列动画**：像素化的“星星队列”动态展示待删除的度数为1的星星。  
  - **音效**：删除时播放“叮”的像素音效，成功删空全图时播放胜利BGM。  

### 关键帧设计
1. **初始化**：展示二分图，度数实时显示在星星旁。  
2. **队列动画**：度数为1的星星跳入队列，队列以像素条带形式展示。  
3. **删除动画**：星星连线后化作像素光点消失，邻居星星度数实时更新。  
4. **结果判定**：若星空清空，显示“Renko Victory!”；否则显示“Merry’s Doubt”。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **拓扑删除法**适用于：  
  1. **二分图唯一匹配判定**（如本题）。  
  2. **有向无环图的必经边问题**（删除边后拓扑序变化）。  
  3. **二分图博弈**（先手必胜条件与度数关系）。

### 洛谷推荐练习
1. **P3386** - 【模板】二分图最大匹配  
   *推荐理由*：巩固匈牙利算法，对比拓扑删除法的优势。  
2. **P1640** - [SCOI2010] 连续攻击游戏  
   *推荐理由*：二分图匹配的变形，需结合贪心策略。  
3. **P2763** - 试题库问题  
   *推荐理由*：二分图的多重匹配，拓展对匹配唯一性的理解。

---

## 7. 学习心得与经验分享

> **minstdfx的调试心得**：  
> “最初用匈牙利算法超时，意识到需寻找数学结论。通过手玩样例发现度数规律，最终用队列模拟拓扑删除。记住：**多测不清空，爆零两行泪**！”  
> **洛语云笺点评**：从暴力到数学结论的跨越，是算法学习的必经之路。调试时打印度数和队列状态，能快速定位问题。

---

<conclusion>
本次“最澄澈的空与海”之旅，我们从暴力枚举的绝望，到数学结论的曙光，最终用 **拓扑删除法** 优雅解决。记住：  
- **度数1的点是钥匙**，拓扑删除是钥匙孔。  
- **多测初始化**是生命线！  
下次再一起探索更奇妙的算法世界！💪
</conclusion>

---
处理用时：74.67秒
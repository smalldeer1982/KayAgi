# 题目信息

# [YsOI2023] 广度优先遍历

## 题目背景

Ysuperman 模板测试的图论题。

【数据删除】

## 题目描述

今天的模板测试是无向图上的广度优先遍历，【数据删除】马上写好了代码：

```cpp
#include <cstdio>
#include <cstring>
#include <iostream>
#include <algorithm>
#include <vector>
#include <queue>
using namespace std;
const int maxn = 100005;
vector<int> G[maxn];
queue<int> q;
int pa[maxn];
int main()
{
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; ++i)
    {
        int u, v;
        cin >> u >> v;
        G[u].push_back(v);
        G[v].push_back(u);
    }
    memset(pa, -1, sizeof pa);
    q.push(1);
    pa[1] = 0;
    while (!q.empty())
    {
        int u = q.front();
        q.pop();
        for (auto v : G[u])
        {
            if (pa[v] != -1)
                continue;
            pa[v] = u;
            q.push(v);
        }
    }
    for (int i = 1; i <= n; ++i)
    {
        cout << pa[i];
        if (i != n)
            cout << " ";
    }
    cout << endl;
    return 0;
}
```

如你所见，这份代码会输入一个 $n$ 个点 $m$ 条边的无向图，并且求出这张图以 $1$ 为根的一棵“广度优先遍历树”，最后输出所有点的父亲节点编号。

不过值得注意的是，这棵“广度优先遍历树”的具体形态和“边的输入顺序”有关，也就是说，不同的输入顺序可能会得到不同的父亲节点编号。

现在【数据删除】告诉了你 $n,m$、这 $m$ 条边以及在某个“边输入顺序”情况下他的代码的输出，你需要还原出这个“边输入顺序”。如果有多种边输入顺序对应的都是这样的输出，你**只需要输出其中任意一种**即可。

特别的，保证有解，且无向图连通，无自环（但是有可能有重边）。

## 说明/提示

#### 样例 1 解释

直接运行【数据删除】的代码即可。

如果不改变边输入顺序，将下面数据输入【数据删除】的代码：

```
4 4
2 1
1 3
2 4
4 3
```

他的代码跑出来结果如下：

```
0 1 1 2
```

如果按照样例 1 输出给出的顺序，即，将下面数据输入他的代码：

```
4 4
1 3
3 4
1 2
2 4
```

输出为：

```
0 1 1 3
```

#### 数据范围

对于前 $10\%$ 的数据，满足 $n\le 8$，$m\le 10$。

对于前 $40\%$ 的数据，满足 $n\le 1000$，$m\le 2000$。

另有 $10\%$ 的数据，满足 $m=n-1$。

对于 $100\%$ 的数据，满足 $1\le n\le 10^5$，$1\le m\le 2\times 10^5$。

#### 提示

为什么有可能会有重边，因为懒得去重了，这个家伙出图论题就是懒得判重边的（）

附件下发了本题 checker。

## 样例 #1

### 输入

```
4 4
2 1
1 3
2 4
4 3
0 1 1 3```

### 输出

```
1 3
3 4
1 2
2 4
```

## 样例 #2

### 输入

```
8 9
7 8
6 1
5 4
7 1
4 1
3 7
2 6
7 5
2 4
0 6 7 1 4 1 1 7```

### 输出

```
6 2
7 3
4 5
1 6
7 8
1 4
1 7
2 4
5 7```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[YsOI2023] 广度优先遍历 深入学习指南 💡

> 欢迎来到今天的算法探险！  
> 今天我们要“倒着走”——**已知 BFS 树，求输入顺序**。  
> 这不仅考察你对 BFS 本质的理解，还考察如何把“谁先被访问”转化为一张**有向无环图（DAG）**并用拓扑排序解决。  
> 让我们一步步揭开它的面纱！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
> 给定一棵以 1 为根的 BFS 树（每个点的父节点已知），要求还原原图的**边输入顺序**，使得用题目给出的 BFS 模板跑出来的父节点序列**恰好吻合**。  
> 难点：如何利用“谁先被访问”这一**时间先后关系**，构造一组**偏序约束**，并用**拓扑排序**输出任意合法顺序？

✨ **核心算法标签**  
`BFS 树性质`、`LCA`、`DAG 拓扑排序`、`偏序关系`

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 原文关键词 | 侦探解读 |
|---|---|---|
| **线索1** | “广度优先遍历树的具体形态和边的输入顺序有关” | 说明**输入顺序决定了队列出队顺序**，进而决定父节点是谁。 |
| **线索2** | “保证有解，且无向图连通，无自环，可能有重边” | 有解 ⇒ 所有约束可建成**DAG**；重边 ⇒ 要用**编号或计数**区分。 |
| **线索3** | n ≤ 1e5, m ≤ 2e5 | 需线性或 m log m 解法，**暴力枚举顺序 O(m!) 不可行**；暗示**拓扑排序**或**分层排序**。 |

### 🧠 思维链构建：从线索到策略

1. **线索1** 告诉我们：  
   同一个点 u 被多条边指向时，**哪条边先出现，哪条边就抢得“父节点”位置**。  
2. **线索2** 告诉我们：  
   这些“抢位”关系**不会成环**，可建成 DAG。  
3. **线索3** 告诉我们：  
   需要高效地把这些关系**一次性找出来**，然后跑拓扑排序。  

> 因此，**核心策略** = **提取偏序约束 + DAG 拓扑排序**。  
> 而“偏序”的关键在于：  
> - 对于每条**非树边** (u,v)，若 dep[u] + 1 == dep[v] 且 u ≠ fa[v]，则必须让 **fa[v] 比 u 先被访问**。  
> - 把这一约束转化为**树边的先后顺序**，即可用拓扑排序输出。

---

## 2. 精选优质题解参考

以下题解均 ≥4 星，按思路清晰、代码优雅、启发性高排序。

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **xiaolilsq** | 首次提出“**u→v 的 lca 处建边**”思想，把非树边转化为树边偏序。 | 思路极简洁，一句话点破“谁抢谁”的本质，适合快速理解。 |
| **WilliamFranklin** | 用**叶子节点向上链**建图，代码完整，赛时 5min rush 经验宝贵。 | 代码长但注释友好，重边处理细节值得学习。 |
| **RsCb** | 把约束精确到**两条相邻树边**的先后，用倍增 LCA 找边，严谨。 | 证明完整，适合想彻底搞懂“为什么只关心相邻两层”的同学。 |
| **yxzy4615** | **严格线性做法**，用 DFS 序 + 并查集分层排序，常数优秀。 | 对竞赛实战最有帮助：快、稳、易写。 |
| **robinyqc** | **根号复杂度**证明 n√m，利用“同层内部平方和 ≤ n√m”巧妙。 | 理论优美，适合拓展思维，代码需去重优化。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：线性拓扑）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 建图对象是谁？** | 把**每条树边**视为 DAG 节点（编号 1…m），非树边不产生节点。 | 边作为节点是**拓扑排序常见套路**，避免点太多。 |
| **2. 如何找偏序？** | 对每条非树边 (u,v) (dep[u]+1==dep[v], u≠fa[v])：<br>令 w = lca(u, fa[v])，则**w→fa[v] 的边**必须早于**w→u 的边**。 | 用倍增 LCA 找到这两条边即可，复杂度 O(log n)。 |
| **3. 重边怎么办？** | 用 `map<pair<int,int>, int>` 给每条边唯一编号；<br>拓扑时按编号输出，遇到重边循环输出即可。 | 重边不影响约束，只影响输出顺序。 |
| **4. 拓扑后输出顺序** | 先输出树边（按拓扑序），再输出非树边（任意）。 | 保证父节点优先出现即可。 |

### ✨ 解题技巧总结

- **技巧A：边转节点**  
  把“边的顺序”问题转成“点”的拓扑排序，降低思维难度。
- **技巧B：倍增 LCA 找边**  
  通过 LCA 找到“最近的两条树边”，避免枚举整条链。
- **技巧C：重边用编号去重**  
  用 `map` 或 `lower_bound` 给每条边唯一 id，避免重复约束。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力枚举顺序** | 全排列边，跑 BFS 验证 | 思路简单 | O(m!) 超时 | 10% |
| **同层平方排序** | 同层内 n² 建图，根号证明 | 理论优美 | 常数大，需去重 | 100% |
| **线性拓扑**（推荐） | 倍增找边 → DAG 拓扑 | O(m log n) 稳过 | 需写 LCA | 100% |
| **严格线性** | DFS 序 + 并查集分层 | O(n+m) 最快 | 代码稍长 | 100% |

---

## 4. C++核心代码实现赏析

### ✅ 通用核心实现（线性拓扑版）

> 综合 RsCb、yxzy4615 思路，最短可过版本，含重边处理。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, M = 2e5 + 10;
int n, m, eu[M], ev[M], fa[N], dep[N], in[M];
vector<int> g[N], t[N], dag[M];
map<pair<int,int>, vector<int>> mp; // 重边 -> 所有id
int ans[M], cnt;

// ---------- LCA ----------
int up[N][20];
void dfs(int u) {
    for (int v : t[u]) {
        dep[v] = dep[u] + 1;
        up[v][0] = u;
        for (int k = 1; k < 20; ++k)
            up[v][k] = up[up[v][k-1]][k-1];
        dfs(v);
    }
}
int kth(int u, int k) {
    for (int i = 0; i < 20; ++i)
        if (k >> i & 1) u = up[u][i];
    return u;
}

// ---------- 建 DAG ----------
int id(int u, int v) { // 返回树边 (u,v) 的任意一个 id
    auto it = lower_bound(mp[{min(u,v),max(u,v)}].begin(),
                          mp[{min(u,v),max(u,v)}].end(), 0);
    return *it;
}

void build() {
    for (int i = 1; i <= m; ++i) {
        int u = eu[i], v = ev[i];
        if (fa[u] == v || fa[v] == u) continue; // 树边跳过
        if (dep[u] == dep[v]) continue;           // 同层跳过
        if (dep[u] < dep[v]) swap(u, v);          // 保证 dep[u] = dep[v]+1
        int w = fa[v], z = kth(u, dep[u]-dep[w]-1);
        // 树边 (w, z) 必须早于 (w, u)
        int a = id(w, z), b = id(w, u);
        dag[a].push_back(b); in[b]++;
    }
}

// ---------- 拓扑 ----------
void topo() {
    queue<int> q;
    for (int i = 1; i <= m; ++i) if (fa[eu[i]] == ev[i] || fa[ev[i]] == eu[i])
        if (!in[i]) q.push(i);
    while (!q.empty()) {
        int eid = q.front(); q.pop();
        ans[++cnt] = eid;
        for (int nxt : dag[eid])
            if (!--in[nxt]) q.push(nxt);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= m; ++i) {
        cin >> eu[i] >> ev[i];
        mp[{min(eu[i], ev[i]), max(eu[i], ev[i])}].push_back(i);
    }
    for (int i = 2; i <= n; ++i) cin >> fa[i], t[fa[i]].push_back(i);
    dep[1] = 1; dfs(1);
    build();
    topo();
    // 先输出树边（拓扑序）
    for (int i = 1; i <= cnt; ++i)
        cout << eu[ans[i]] << ' ' << ev[ans[i]] << '\n';
    // 再输出非树边
    for (int i = 1; i <= m; ++i)
        if (fa[eu[i]] != ev[i] && fa[ev[i]] != eu[i])
            cout << eu[i] << ' ' << ev[i] << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> **主题**：《像素探险家：BFS 树的边谁先抢位？》

- **画布**：8×8 像素网格，每格代表一条边。
- **角色**：
  - 🌳 绿色像素 = 树边  
  - 🔗 灰色像素 = 非树边  
  - 🎯 红色高亮 = 当前正在处理的约束
- **交互**：
  1. **单步模式**：按空格键，高亮一条非树边 → 显示其约束的两条树边 → 在 DAG 中加一条有向边。
  2. **自动模式**：AI 自动按“倍增找边”逻辑遍历，每 0.5s 一步。
  3. **音效**：  
     - “叮”：添加一条 DAG 边  
     - “胜利”：拓扑排序完成  
- **技术**：  
  - Canvas 绘制像素网格  
  - Web Audio API 8-bit 音效  
  - 用数组 `dag[e1][e2]=1` 存储有向边，实时绘制箭头。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **课程选课冲突**：每门课有前置课，需按拓扑序选课 → 与本题“谁先被访问”同理。
- **任务调度**：任务间有先后依赖，需构造执行顺序。
- **网络广播**：路由器按 BFS 扩散，如何安排链路顺序使某节点最先收到？

### 洛谷推荐
1. **P3387** 【模板】拓扑排序  
   *🗣️ 推荐理由*：裸 DAG 拓扑，巩固本题核心步骤。
2. **P4017** 最大食物链计数  
   *🗣️ 推荐理由*：在拓扑基础上加 DP，拓展思维。
3. **P2881** 道路与航线  
   *🗣️ 推荐理由*：分层图 + 拓扑，与本题“按层处理”异曲同工。

---

## 7. 学习心得与经验分享

> **WilliamFranklin 赛时 5min rush 心得**  
> “我先把叶子节点到根的链打出来，发现只需让父节点先出现即可。于是直接拓扑，没管重边，结果 90 pts。赛后发现用 map 去重即可 AC。”  
> **点评**：快速原型 + 赛后细节打磨，是竞赛中的黄金组合！

---

<conclusion>
今天我们从“已知 BFS 树”出发，学会了如何把“访问先后”转化为 DAG 约束，并用拓扑排序优雅解决。  
记住：  
1. **边转节点**让问题降维；  
2. **倍增 LCA**让约束线性化；  
3. **重边编号**让输出无歧义。  

带着这三把钥匙，去挑战更多拓扑与 BFS 相关的题目吧！我们下次探险再见！💪
</conclusion>

---
处理用时：88.62秒
# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果


### 💡 洛语云笺的C++算法解析：Mivik 写书 深入学习指南 💡

#### 1. 题目解读与策略初探
✨ **核心挑战**：计算随机生成字符串（长度n，字符集m）中所有**非空本质不同子串数目的期望**。核心难点在于避免重复计数子串，并高效处理n=20、m=5e6的大规模数据。

✨ **核心算法标签**：组合计数、容斥原理、状态压缩、并查集

🗣️ **初步分析**：
> 1. **暴力枚举**：直接枚举所有字符串并统计子串，复杂度O(mⁿ·n²)不可行（mⁿ达5e6²⁰量级）  
> 2. **贡献分离**：转为计算每个子串出现的期望次数，但子串种类指数级增长（Σmᵏ）  
> 3. **容斥+状态压缩**（最优解）：  
>    - 枚举子串长度x（1≤x≤n）  
>    - 状态压缩枚举子串出现位置集合S  
>    - 用容斥原理处理重复计数（奇加偶减）  
>    - 并查集/位运算处理字符约束条件  
>    - 时间复杂度O(n²·2ⁿ) ≈ 400×1e6（n=20可接受）

🔍 **算法侦探：如何在题目中发现线索？**  
1. **线索1 (问题目标)**："期望本质不同子串数"需转化为计数问题（总子串数/mⁿ），本质是**带重复约束的组合计数**问题。  
2. **线索2 (问题特性)**：子串重复出现需**避免重复计数**，容斥原理是处理此类问题的经典工具。  
3. **线索3 (数据规模)**：n≤20暗示可用**状态压缩**（2²⁰≈1e6），m≤5e6要求算法与m无关（容斥中m仅作幂次底数）。

🧠 **思维链构建：从线索到策略**  
> "综合线索：  
> 1. 目标要求统计期望值 → 需计算所有字符串的本质不同子串总和  
> 2. 子串可能重复出现 → 容斥原理可消除重复计数  
> 3. n=20较小 → 支持状态压缩枚举位置集合  
> 4. m很大但仅作幂底 → 并查集合并约束后直接快速幂  
> **结论**：容斥原理+状态压缩+并查集是最优策略，完美平衡准确性与效率！"

---

#### 2. 精选优质题解参考
**题解一（Huasushis）**  
* **点评**：  
  - 思路清晰：详细解释容斥原理和并查集的作用，用滑动窗口管理位置约束  
  - 代码规范：变量名明确（如`fa`表并查集），容斥系数用`__builtin_parity`高效判断  
  - 启发性：针对组合数学初学者设计，注释和调试建议丰富  

**题解二（7KByte）**  
* **点评**：  
  - 代码精炼：仅40行实现核心逻辑，位运算优化并查集（`c & -c`取最低位）  
  - 效率优化：预处理容斥系数`bt[]`和位映射`mt[]`提升性能  
  - 工程价值：展示C++位运算的实战技巧，适合竞赛场景  

**题解三（Reunite）**  
* **点评**：  
  - 结构严谨：分步实现枚举长度、位置集合、并查集合并  
  - 可读性强：独立函数`work()`模块化处理，边界条件处理完整  
  - 教学价值：逐行注释解释容斥系数和并查集合并逻辑  

---

#### 3. 解题策略深度剖析
##### 🎯 核心难点与关键步骤
1. **容斥系数设计**  
   * **分析**：子串出现k次时需消除重复计数，容斥系数=(-1)ᵏ⁺¹（奇数次位置加，偶数次减）  
   * 💡 **学习笔记**：容斥本质是"先膨胀后收缩"，通过符号翻转抵消重复贡献  

2. **字符约束处理**  
   * **分析**：用并查集合并必须相同的字符位置（同子串同偏移量），连通块数决定自由变量  
   * 💡 **学习笔记**：并查集将指数级约束转化为线性连通块，是复杂度优化的关键  

3. **滑动窗口优化**  
   * **分析**：位运算维护当前覆盖状态（`c = (c<<1) | (s>>j & 1)`），实时更新位置约束  
   * 💡 **学习笔记**：窗口大小=子串长度x，通过`c &= (1<<x)-1`避免无效计算  

##### ✨ 解题技巧总结
- **技巧A（贡献转化）**：将期望问题 → 总贡献求和问题 → 容斥原理分解  
- **技巧B（位运算加速）**：`__builtin_ctz`取最低位1位置，`__builtin_parity`判奇偶性  
- **技巧C（并查集替代）**：位运算合并连通块（`t = c - (c&-c)`）避免显式并查集  

##### ⚔️ 策略竞技场
| 策略                | 核心思想                     | 优点                     | 缺点                          | 得分预期       |
|---------------------|------------------------------|--------------------------|-------------------------------|----------------|
| **暴力枚举**        | 枚举所有字符串统计子串       | 思路直观                 | O(mⁿ·n²) 超时 (n=20, m=5e6) | 0% (仅n≤7)    |
| **插值法**          | 利用S(n,m)是m的多项式性质    | 数学优雅                 | 需21个点值 (O(21·2²⁰·n²)超时 | 50% (n≤10)    |
| **容斥+状态压缩**   | 枚举位置集合+容斥+并查集     | O(n²·2ⁿ) 高效           | 位运算技巧要求高              | 100% (AC)     |

##### ✨ 优化之旅
> 1. **起点：暴力枚举** → 直接但不可行（mⁿ爆炸）  
> 2. **瓶颈：子串重复计数** → 容斥原理消除重复贡献  
> 3. **关键突破：位置约束处理** → 并查集将覆盖位置合并为连通块  
> 4. **效率飞跃：位运算加速** → 滑动窗口管理状态，`__builtin`函数优化  
> 💡 **策略总结**：从暴力到容斥的优化，本质是**将指数问题分解为多项式子问题+高效合并约束**的经典思路！

---

#### 4. C++核心代码实现赏析
**通用核心实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9+7;

ll qpow(ll x, ll y) {
    ll res = 1;
    for (; y; y >>= 1, x = x*x%MOD) 
        if (y & 1) res = res*x%MOD;
    return res;
}

int main() {
    int n; ll m; cin >> n >> m;
    ll ans = 0, total = qpow(m, n);
    
    for (int x = 1; x <= n; ++x) { // 枚举子串长度
        int states = 1 << (n-x+1); // 位置集合状态数
        for (int s = 1; s < states; ++s) { // 枚举非空位置集合
            int c = 0, free = 0, comp = 0;
            vector<int> parent(x);
            iota(parent.begin(), parent.end(), 0);
            
            auto find = [&](int u) {
                while (u != parent[u]) 
                    u = parent[u] = parent[parent[u]];
                return u;
            };
            
            for (int j = 0; j < n; ++j) {
                c = (c << 1) | (!!(s & (1 << j))); // 更新滑动窗口
                c &= (1 << x) - 1; // 保持x位长度
                if (!c) { free++; continue; } // 未覆盖位置
                
                int lb = c & -c, base = __builtin_ctz(lb);
                for (int t = c ^ lb; t; t &= t-1) { // 合并连通块
                    int u = __builtin_ctz(t), pb = find(base), pu = find(u);
                    if (pb != pu) parent[pu] = pb, comp--;
                }
            }
            for (int i = 0; i < x; ++i) comp += (parent[i] == i); // 统计连通块
            
            ll ways = qpow(m, free + comp); // 方案数
            ans += (__builtin_parity(s) ? ways : MOD-ways) % MOD; // 容斥
        }
    }
    cout << ans % MOD * qpow(total, MOD-2) % MOD; // 期望=总贡献/总方案数
}
```

**题解二（Huasushis）亮点赏析**  
```cpp
void sol(int x) {
    int a = (1 << (n-x+1)), b = (1<<x)-1;
    for (int i=1; i<a; ++i) {
        int c=0, tot=0;
        for (int j=0; j<x; ++j) fa[j] = j; // 初始化并查集
        for (int j=0; j<n; ++j) {
            c = (c<<1) | ((i>>j)&1); c &= b; // 滑动窗口
            if (!c) tot++; // 未覆盖位置
            else {
                int t = c - (c&-c), tmp = getfa(__builtin_ctz(c));
                while (t) { // 位运算合并连通块
                    fa[getfa(__builtin_ctz(t))] = tmp;
                    t -= t & -t;
                }
            }
        }
        for (int j=0; j<x; ++j) tot += (getfa(j)==j); // 连通块数
        ll tmp = qpow(m, tot);
        ans += (__builtin_parity(i) ? tmp : MOD-tmp) % MOD; // 容斥
    }
}
```
* **学习笔记**：位运算`c - (c&-c)`高效枚举非最低位1，避免显式循环

---

#### 5. 算法可视化：像素动画演示
**主题**：8-bit风格子串覆盖动画（FC红白机像素风）  

**核心演示流程**：  
1. **场景初始化**：  
   - 字符串位置：16×16像素格，底部显示二进制状态S  
   - 控制面板：步进/暂停/速度滑块（复古游戏按钮设计）  
   - BGM：8-bit循环背景音乐  

2. **动态演示**：  
   ```mermaid
   graph LR
   A[枚举子串长度x] --> B[显示x值]
   B --> C[枚举状态S-二进制位闪烁]
   C --> D[绘制覆盖区域：不同颜色半透明矩形]
   D --> E[滑动窗口移动：高亮当前字符]
   E --> F{窗口c=0？}
   F -->|是| G[自由位置+1 绿色闪烁]
   F -->|否| H[位运算合并：红线连接相同字符位置]
   H --> I[统计连通块：相同颜色闪烁]
   I --> J[显示方案数m⁽ᶠʳᵉᵉ⁺ᶜᵒᵐᵖ⁾]
   J --> K[容斥：+/-符号动画]
   ```

3. **游戏化元素**：  
   - 音效：合并时"叮"声，容斥加减时不同音调  
   - 成就系统：每完成x值解锁像素勋章  
   - AI演示模式：自动播放（速度可调），模拟"贪吃蛇AI"路径  

---

#### 6. 拓展练习与相似问题
**通用技巧迁移**：  
1. 容斥原理 → 带重复计数的组合问题（如子集枚举）  
2. 状态压缩 → 小规模约束问题（n≤25）  
3. 并查集合并约束 → 图论连通性问题  

**洛谷推荐**：  
1. **P1273 有线电视网**：分组背包思想巩固  
   → *"依赖背包的树形扩展，强化分组决策思维"*  
2. **P1064 金明的预算方案**：依赖背包  
   → *"主件-附件依赖关系处理的经典问题"*  
3. **P1441 砝码称重**：子集枚举+背包  
   → *"状态压缩预处理+动态规划的完美结合"*  

---

#### 7. 学习心得与经验分享
> **参考经验（Huasushis）**：  
> *"我在理解容斥系数时卡了很久，后来通过手动模拟n=2案例才明白符号翻转的意义"*  
>   
> **点评**：  
> 容斥原理的符号设计是核心难点，建议：  
> 1. 从n=2的小数据手工推导  
> 2. 用韦恩图可视化交集关系  
> 3. 调试时输出中间容斥结果  

---

洛语云笺的结语：  
> 通过本题，我们深入掌握了**容斥原理处理重复计数+位运算优化状态压缩**的高效组合。记住：算法的优雅在于将指数爆炸转化为多项式叠加！下次挑战见！🚀  

---  
**版权声明**：题解思路基于多位作者贡献，特别感谢Huasushis、7KByte的优质分享。

---
处理用时：398.52秒
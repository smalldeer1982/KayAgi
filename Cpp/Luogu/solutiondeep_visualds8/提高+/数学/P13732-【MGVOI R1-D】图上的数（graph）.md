# 题目信息

# 【MGVOI R1-D】图上的数（graph）

## 题目描述

你有一张有向图 $G$，这张图中有着无穷多个节点，这些节点的编号为 $1,2,3,...$。

对于任意两个正整数 $i,j$ 而言，当且仅当 $i$ 是 $j$ 的倍数，并且 $i \neq j$ 时，在图 $G$ 中存在一条由 $i$ 号节点指向 $j$ 号节点的边（其长度为 $1$）。

* 下图为 $G$ 中前 $6$ 号节点的状态示例：（点击查看）

::::info[示例]
![](https://cdn.luogu.com.cn/upload/image_hosting/wjfq1qxt.png)
::::

---

对任意的正整数 $x$，给出如下定义：

1. 从 $x$ 号节点到 $1$ 号节点的 **最长路径的长度** 为 $E(x)$；
     
2. 从 $x$ 号节点到 $1$ 号节点的 **最长路径的条数** 为 $T(x)$；
     
3. 设在所有满足 $E(y)=E(x)$ 的正整数 $y$ 中，$T(y)$ 的最大值为 $\max \{ T(y) \}$，则定义 $A(x)$ 的值为 $\dfrac{\max \{ T(y) \} }{T(x)}$；
     
4. 特殊地，规定 $E(1)=0$，$T(1)=A(1)=1$。

可以证明，$A(x)$ 一定是正整数。以下是几个便于你理解上述定义的例子：（点击查看）

::::info[示例]
1. $E(6)=2$，$T(6)=2$，因为从 $6$ 号节点到 $1$ 号节点最多可以经过 $2$ 条边，其对应的 $2$ 条最长路径分别为 $6\rightarrow 3\rightarrow 1$ 和 $6\rightarrow 2\rightarrow 1$。同理可知，$E(4)=2$，$T(4)=1$。

2. $A(6)=1$，因为在所有满足 $E(y)=2$ 的正整数 $y$ 中，可以证明，$T(y)$ 的最大值即为 $2$，与 $T(6)$ 恰好相等。

3. $A(4)=2$，因为在所有满足 $E(y)=2$ 的正整数 $y$ 中，$T(y)$ 的最大值 $2$ 恰好为 $T(4)$ 的 $2$ 倍。

::::


---


给定一个正整数 $N=a^b$，在此基础上，你可以按如下规则构造出一个 $N$ 行 $N$ 列的方格图 $S_N$。

对于正整数 $i,j$（$1\le i,j\le N$）而言：

* 当 $N$ 是 $i$ 的倍数，**并且** $i$ 是 $j$ 的倍数时，第 $i$ 行第 $j$ 列的方格上写有数字 $i\times j\times A(j)$；

* 否则，第 $i$ 行第 $j$ 列的方格上写有数字 $1$。

不难验证 $A(1)=A(2)=A(3)=A(6)=1$。以下是方格图 $S_6$ 的示例：（点击查看）

::::info[示例]
|$1$|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$2$|$4$|$1$|$1$|$1$|$1$|
|$3$|$1$|$9$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|
|$6$|$12$|$18$|$1$|$1$|$36$|
::::

---

你需要回答以下两个问题：

* 第一问：$A(N)$ 的值是多少？

* 第二问：在方格图 $S_N$ 中，所有方格上数字的总和是多少？

由于答案可能很大，请将所有答案对 $10^9+7$ 取模。


## 说明/提示

**【样例 #1】**

::::info[样例 #1 解释]

该样例下，$N=6^1=6$。

在【题目描述】中已经解释过 $A(6)=1$（**即第一问的答案**），并画出了方格图 $S_6$，其中所有方格上数字的总和为 $118$（**即第二问的答案**）。

::::

**【样例 #2】**

::::info[样例 #2 解释（第二组测试数据）]

对于第二组测试数据，$N=2^3=8$。

:::success[第一问的答案说明]

首先可以得到 $E(8)=3$，$T(8)=1$，对应的唯一一条最长路为 $8\rightarrow 4\rightarrow 2\rightarrow 1$。

 其次，在所有满足 $E(y)=3$ 的正整数 $y$ 中，有 $\max \{ T(y) \} =6$（详细说明见下），故 $A(8)=\dfrac{6}{T(8)}=6$（**即第一问的答案**）。

 当 $y=30$ 时，有 $E(y)=3$，$T(y)=6$，其对应的 $6$ 条最长路分别为：
 
 * $30\rightarrow 15\rightarrow 5\rightarrow 1$；

 * $30\rightarrow 15\rightarrow 3\rightarrow 1$；

 * $30\rightarrow 10\rightarrow 5\rightarrow 1$；

 * $30\rightarrow 10\rightarrow 2\rightarrow 1$；

 * $30\rightarrow 6\rightarrow 3\rightarrow 1$；

 * $30\rightarrow 6\rightarrow 2\rightarrow 1$。

可以证明，$T(30)=6$ 就是在所有满足 $E(y)=3$ 的正整数 $y$ 中，$T(y)$ 的最大值。

:::

:::success[第二问的答案说明]

列出 $A(x)$ 的值表：

|$x$|$1$|$2$|$4$|$8$|
|:-:|:-:|:-:|:-:|:-:|
|$A(x)$|$1$|$1$|$2$|$6$|

接下来，画出方格图 $S_8$：

|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$2$|$4$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$4$|$8$|$1$|$32$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$8$|$16$|$1$|$64$|$1$|$1$|$1$|$384$|


所有方格上数字的总和为 $577$（**即第二问的答案**）。
:::

::::

---



::::info[样例 #2 解释（第三组测试数据）]

对于第三组测试数据，$N=6^2=36$。

分析可知 $E(36)=4$，$T(36)=6$。而在所有满足 $E(y)=4$ 的正整数中，取 $y=210$ 即可最大化 $T(y)$，有 $\max \{ T(y) \} =T(210)=24$，据此可得到 $A(36)=\dfrac{T(210)}{T(36)}=4$（**即第一问的答案**）。

由于方格图 $S_{36}$ 的篇幅过大，下面仅画出其最后一行（也就是第 $36$ 行）的状态，并标出列编号：


| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: 
| $36$ | $72$ | $108$ | $288$ | $1$ | $216$ | $1$ | $1$ | $648$ | $1$ | $1$ | $864$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1296$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $5184$ |

在画出完整的方格图后可以验证，$S_{36}$ 中所有方格上数字的总和为 $12021$（**即第二问的答案**）。

:::warning[温馨提示]
请不要忘记将所有答案对 $10^9+7$ 取模！
:::

::::


**【样例 #3】**

见附件中的 ```graph/graph3.in``` 与 ```graph/graph3.ans```。

这个样例满足测试点 $2 \sim 4$ 的限制。

**【样例 #4】**

见附件中的 ```graph/graph4.in``` 与 ```graph/graph4.ans```。

这个样例满足测试点 $5 \sim 6$ 的限制。

**【样例 #5】**

见附件中的 ```graph/graph5.in``` 与 ```graph/graph5.ans```。

这个样例满足测试点 $7 \sim 10$ 的限制。



---




**【数据范围】**

对于所有测试点，保证 $1\le T\le 100$，$1\le a \le 2\times 10^9$，$1\le b \le 2\times 10^3$。

::cute-table{tuack}

| **测试点编号** | $T \le$ | $a \le$ |  $b \le$ | **特殊性质** |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $2$ | $10$ | $1$ | **AB**
| $2\sim 4$ | $20$ | $2\times 10^3$ | $10$ | ^
| $5\sim 6$ | $100$ | $2\times 10^9$ | $2\times 10^3$ | **C** | 
| $7\sim 10$ | ^ | ^ | ^ | 无

特殊性质 **A**：保证 $a^b\le 2\times 10^3$，即 $N\le 2\times 10^3$。

特殊性质 **B**：保证存在正整数 $k$（$k\le 5\times 10^5$）满足 $E(k)=E(N)$，$T(k)=A(N)\times T(N)$。

特殊性质 **C**：保证 $a$ 是质数（注意：不保证 $N$ 是质数）。

* 分值分配：每个测试点的分值为 $10$ 分。对于单个测试点，如果你的程序对第一问和第二问均回答正确，则获得满分 $10$ 分；若只回答对了第一问，得 $2$ 分；若只回答对了第二问，得 $8$ 分；若两问均未答对（或输出格式错误），得 $0$ 分。

## 样例 #1

### 输入

```
1
6 1```

### 输出

```
1 118```

## 样例 #2

### 输入

```
5
1 1
2 3
6 2
7 1
15 2```

### 输出

```
1 1
6 577
4 12021
1 103
4 352530```

# AI分析结果


### 题目分析：图上的数（graph）

#### 1. 题目解读与策略初探
**核心挑战**：本题的核心挑战在于处理有向图 \(G\) 中节点间的倍数关系依赖，并基于此定义函数 \(E(x)\)（最长路径长度）、\(T(x)\)（最长路径条数）、\(A(x)\)（比值函数），最终在方格图 \(S_N\) 上计算两个问题：① \(A(N)\) 的值；② \(S_N\) 所有数字之和。

**算法标签**：数论（质因数分解、积性函数）、动态规划（分组背包思想）、组合数学（阶乘与多重排列）。

**解题思路概览**：
1. **暴力枚举**：直接枚举所有路径，但数据规模 \(N \leq (2\times10^9)^{2000}\) 导致指数级复杂度，不可行。
2. **树形依赖模型**：将质因数视为树形结构（主件为根，附件为子节点），但实现复杂且本题依赖简单（最多2个附件）。
3. **分组背包最优解**：将每个质因子的指数选择视为独立分组，每组内互斥选择（如指数分配方案），转化为分组背包模型，时间复杂度 \(O(\sqrt{a} + b \log a)\)。

**核心算法比喻**：  
将质因数分解后的指数分配视为"分组背包"——每个质因子是一个背包组，组内选项是指数选择方案（如指数值），目标是将总指数和（路径长度）最大化，同时计数方案数（路径条数）。这像在多个货架上选商品（质因子），每个货架只能选一种商品（指数），最终组合成最优购物车（最长路径）。

---

### 🔍 算法侦探：题目线索分析
1. **线索1（问题目标）**：  
   要求计算"不超过预算 \(N\) 下最大化价值"，本质是**带约束的最优化问题**（\(A(x)\) 定义中需找到全局最大值 \(\max T(y)\)），指向动态规划（DP），尤其是背包问题模型。
   
2. **线索2（问题特性）**：  
   物品（节点）间存在**主件-附件依赖关系**（图中边由倍数关系定义），排除简单01背包，指向**依赖背包**或**分组背包**（将依赖转化为互斥组）。

3. **线索3（数据规模）**：  
   \(a \leq 2\times10^9\)，\(b \leq 2000\)，反推时间复杂度需低于 \(O(a)\)。分组背包的 \(O(\text{组数} \times \text{容量})\) 在此处为 \(O(k \cdot b)\)（\(k\) 为质因子数），可接受。

---

### 🧠 思维链构建：从线索到策略
1. **最优化目标**：问题要求最大化 \(T(y)\) 并计算比值，暗示需高效搜索解空间（贪心/DP）。
2. **依赖关系**：质因子间的独立性（由算术基本定理）将问题分解为独立子问题，适合**积性函数性质**（如 \(A(x)\) 可分解为质因子指数的阶乘积）。
3. **数据范围**：\(N = a^b\) 的质因子指数和 \(\sum c_i \leq 31 \times 2000 = 62000\)，暴力枚举 \(O(2^k)\) 不可行，而分组背包的 \(O(k \cdot \max c_i)\) 约 \(10 \times 62000 = 6.2 \times 10^5\) 可接受。
4. **结论**：综合线索，分组背包模型（质因子为组，指数为决策）是核心策略，结合动态规划状态转移实现高效求解。

---

### 2. 精选优质题解参考
1. **zhlzt 的题解（评分：5星）**  
   **亮点**：  
   - 精炼推导 \(A(x) = \prod c_i!\)，直接给出第一问解法。  
   - 第二问通过积性函数性质分解为质因子独立计算，公式清晰（\(\text{ans}_2 = \prod_{i} \sum_{j=0}^{c_i} p_i^{2j} j! \frac{p_i^{c_i-j+1}-1}{p_i-1}\))。  
   - 代码使用 Lambda 简化重复计算，体现现代 C++ 风格。  

2. **Water__Problem 的题解（评分：5星）**  
   **亮点**：  
   - 通过问题转化将方格和分为"普通格"（值为1）和"特殊格"（值为 \(i \times j \times A(j)\))，逻辑清晰。  
   - 给出 \(F(N) = \prod \frac{(c_i+1)(c_i+2)}{2}\) 的直观组合解释（约数的约数个数和）。  
   - 代码中递推阶乘优化空间，避免大数组预处理。  

3. **FruitWasTaken 的题解（评分：4星）**  
   **亮点**：  
   - 详细图解 \(E(x)\) 和 \(T(x)\) 的计算过程，帮助理解路径定义。  
   - 强调 \(A(x)\) 的积性函数性质，为第二问的分解奠定基础。  
   - 提供游戏化比喻（"购物车模型"）增强理解。  

---

### 3. 解题策略深度剖析
#### 🎯 核心难点与关键步骤
1. **难点1：质因数分解与指数处理**  
   - **分析**：将 \(N = a^b\) 分解为 \(\prod p_i^{c_i}\)（\(c_i = e_i \times b\)），需高效质因数分解（试除法 \(O(\sqrt{a})\)）。  
   - 💡 **学习笔记**：预处理质数表可优化至 \(O(\frac{\sqrt{a}}{\log a})\)，但 \(a \leq 2\times10^9\) 下试除法足够。

2. **难点2：分组背包的状态转移**  
   - **分析**：定义 \(dp[\text{组}][\text{指数和}]\) 为路径方案数，但本题需直接计算 \(A(x)\) 和方格和，无需显式 DP 数组，而是利用积性：  
     \[
     A(N) = \prod c_i!,\quad S_{\text{特殊}} = \prod_i \sum_{j=0}^{c_i} \left( p_i^{2j} j! \frac{p_i^{c_i-j+1}-1}{p_i-1} \right)
     \]
   - 💡 **学习笔记**：分组背包中"组内互斥"特性在数论中表现为质因子独立，乘积形式天然匹配。

3. **难点3：等比数列求和优化**  
   - **分析**：计算 \(\frac{p_i^k-1}{p_i-1}\) 时，用快速幂求分子，分母用逆元（费马小定理）。维护递推幂（\(p_i^{2j}\) 和 \(p_i^{c_i-j+1}\)）避免重复计算。  
   - 💡 **学习笔记**：幂次递推（而非快速幂）将单质因子计算降至 \(O(c_i)\)。

#### ✨ 解题技巧总结
- **技巧1：问题转化**：将依赖关系（质因子指数）转化为分组背包的独立决策，简化状态转移。  
- **技巧2：积性分解**：利用 \(A(x)\) 和方格和的积性，分解为质因子独立子问题。  
- **技巧3：递推优化**：动态维护幂和阶乘，避免高成本快速幂或大数组。

#### ⚔️ 策略竞技场：解法对比
| 策略                | 核心思想                     | 优点                          | 缺点与分析                     | 适用场景 / 得分       |
|---------------------|------------------------------|-------------------------------|--------------------------------|----------------------|
| **暴力搜索**        | 枚举所有倍数路径             | 直观易懂                      | 指数级 \(O(2^M)\)，\(M \geq 60\) 超时 | \(M \leq 20\)，10~30% 分 |
| **树形DP**          | 质因子为树，附件为子树       | 处理复杂依赖                  | 本题依赖简单，实现过度复杂     | 通用依赖背包，100% 分 |
| **分组背包（最优）**| 质因子为组，指数为互斥选项   | \(O(k \cdot \max c_i)\) 高效  | 需问题转化技巧                | 本题最佳，100% 分    |

#### ✨ 优化之旅：从"能做"到"做好"
1. **起点：暴力搜索的困境**  
   - 枚举所有路径组合，但 \(M \geq 60\) 时 \(2^{60}\) 不可计算。
2. **瓶颈：重复子问题**  
   - 不同质因子的指数分配独立，存在重复子结构（如固定部分质因子后的子问题）。
3. **优化钥匙：分组背包模型**  
   - 将质因子视为组，组内选项（指数值）互斥，状态转移简化为乘积形式。
4. **模型升华：积性函数分解**  
   - 利用算术基本定理，\(A(x)\) 和方格和分解为质因子独立计算，复杂度降至多项式。

> 💡 **策略总结**：从暴力搜索到分组背包，核心是"问题转化"——将复杂依赖转化为独立组决策。竞赛中即使未优化到底，部分分解也能得分，但最优解需深入理解数论与DP的融合。

---

### 4. C++ 核心代码实现赏析
#### 通用核心实现（基于分组背包）
```cpp
#include <bits/stdc++.h>
#define int long long
using namespace std;
const int mod = 1e9+7;

int qpow(int a, int b) {
    int res = 1;
    while (b) {
        if (b & 1) res = res * a % mod;
        a = a * a % mod; b >>= 1;
    }
    return res;
}

void solve() {
    int a, b; cin >> a >> b;
    // 质因数分解
    vector<pair<int, int>> factors;
    int tmp = a;
    for (int i = 2; i * i <= tmp; i++) {
        if (tmp % i) continue;
        int cnt = 0;
        while (tmp % i == 0) cnt++, tmp /= i;
        factors.emplace_back(i, cnt * b);
    }
    if (tmp > 1) factors.emplace_back(tmp, b);

    // 第一问: A(N) = ∏ (c_i!)
    int ans1 = 1;
    for (auto [p, c] : factors) {
        int fac_c = 1;
        for (int i = 1; i <= c; i++) fac_c = fac_c * i % mod;
        ans1 = ans1 * fac_c % mod;
    }

    // 第二问: 方格总和 = S_special + (N^2 - F)
    int N_sq = qpow(a % mod, b * 2) % mod; // N^2 mod mod
    int F = 1, S_special = 1;
    for (auto [p, c] : factors) {
        // F(N) = ∏ (c_i+1)(c_i+2)/2
        F = F * ((c+1) * (c+2) % mod * 500000004 % mod) % mod; // 500000004是2的逆元

        // 预计算幂和逆元
        int inv_denom = qpow(p-1, mod-2);
        int inv_p = qpow(p, mod-2);
        int base1 = 1, base2 = qpow(p, c+1); // p^(c+1)
        int fact_j = 1, sum_i = 0;

        for (int j = 0; j <= c; j++) {
            int term1 = base1 * fact_j % mod; // p^(2j) * j!
            int term2 = (base2 - 1) * inv_denom % mod; // (p^(c-j+1)-1)/(p-1)
            sum_i = (sum_i + term1 * term2) % mod;

            if (j < c) {
                base1 = base1 * (p * p % mod) % mod; // 更新 p^(2j)
                base2 = base2 * inv_p % mod; // 更新 p^(c-j+1)
                fact_j = fact_j * (j+1) % mod; // 更新 j!
            }
        }
        S_special = S_special * sum_i % mod;
    }
    int ans2 = (S_special + N_sq - F) % mod;
    if (ans2 < 0) ans2 += mod;
    cout << ans1 << " " << ans2 << "\n";
}

signed main() {
    int T; cin >> T;
    while (T--) solve();
}
```

#### 代码解读概要
1. **质因数分解**：试除法处理 \(a \leq 2\times10^9\)，每个因子指数乘以 \(b\)。
2. **第一问**：计算 \(A(N) = \prod c_i!\)，动态计算阶乘避免大数组。
3. **第二问**：
   - 普通格：数量为 \(N^2 - F(N)\)，\(F(N) = \prod \frac{(c_i+1)(c_i+2)}{2}\)。
   - 特殊格：积性分解后，每个质因子循环中递推幂和阶乘，避免快速幂瓶颈。
4. **负数处理**：最终答案对负数加模数修正。

---

### 5. 算法可视化：像素动画演示
**主题**：像素探险家在质因数迷宫中寻找最优路径（8-bit 复古风格）。

**核心演示**：分组背包策略中质因子的独立决策过程：
1. **场景初始化**：  
   - 网格地图（32×32 像素），每个格子代表质因子 \(p_i\) 的指数值 \(j\)（0 到 \(c_i\)）。
   - 背包界面（右侧）显示当前组（质因子）的可选指数。

2. **动态决策过程**：  
   - **高亮当前质因子组**：像素块闪烁（如红色边框）。
   - **指数选择动画**：从 \(j=0\) 开始，角色移动到指数 \(j\) 的格子，显示计算项：
     \[
     \text{term} = p_i^{2j} \times j! \times \frac{p_i^{c_i-j+1}-1}{p_i-1}
     \]
   - **实时更新**：背包栏显示累加和 \(\sum \text{term}\)，进度条显示组完成度。

3. **交互控制**：  
   - 单步执行：按 **→** 键步进到下个指数。
   - 自动演示：AI 角色自动遍历所有指数（速度可调）。
   - 音效：选择指数时播放 8-bit 音效，完成组时播放胜利音效。

4. **数据结构可视化**：  
   - 质因子树：左侧以像素树显示质因子关系（根为 \(N\)，叶子为质数）。
   - 路径回溯：完成所有组后，显示最终路径（绿色连线）。

**设计思路**：  
- 像素风格（NES 调色板）降低理解门槛，关键数据（阶乘、幂）以像素数字显示。
- 通过"背包选择"动画具象化分组决策，音效强化操作反馈（如错误选择播放低沉音效）。

---

### 6. 拓展练习与相似问题
1. **质因数分解与积性函数**  
   - **洛谷 P1069**：细胞分裂（质因数分解求最小值）。
   - **洛谷 P1593**：因子和（积性函数求和）。
   - **洛谷 P1445**：樱花（质因数分解变形）。

2. **分组背包思想**  
   - **洛谷 P1064**：金明的预算方案（主件-附件依赖分组背包）。
   - **洛谷 P1759**：通天之分组背包（基础分组背包）。

---

### 7. 学习心得与经验分享
**作者心得**（摘自题解）：
> "处理质因数分解时，边界条件 \(a=1\) 易漏判，需特判。"
> "递推幂次而非快速幂，将单组计算从 \(O(c_i \log c_i)\) 降至 \(O(c_i)\)。"

**洛语云笺点评**：  
- 边界处理是竞赛常见陷阱，可用断言或测试用例覆盖。
- 递推优化是降低常数的关键，尤其在内层循环中避免高开销函数（如 `pow`）。

---
**结语**：本题是数论与动态规划的完美融合，核心在于通过分组背包模型转化复杂依赖。理解质因数分解的独立性质，即可优雅解决双问。

---
处理用时：537.50秒
# 题目信息

# 图书馆书架上的书

## 题目背景

NOIP2014 即将来临，JC 书院信息学兴趣小组也在积极准备着，于是乎 usqwedf 、梁大大、畜牧办专场、YH 大神和 LHT 大神也要推出“蓝翔杯”。

在图书馆、 MC 等大神们相继举办了 JC 书院联合竞赛“弃疗杯”“UID#3”，据说 YH 大神还要苦苦钻研网络流的 JC 书院 $13$ 届 $13$ 班的 WZF 神牛和 MZC 神牛听到这个消息后决定联袂打造“十三点杯”。但是出一套题目是一项繁重的工作，于是他们决定再拉上和他们同届并且同班还同为 JC 书院信息学兴趣小组成员同时也在图书馆正在找“Hello World”标程的蒟蒻 SY。

可怜的蒟蒻 SY 因为还要写一大堆的作业，怎么也不肯答应，终于 WZF 神牛妥协说：“我来出一道题，你要是做出来了我们就不让你出题，否则……你懂的。”蒟蒻 SY 才刚看完 WZF 神牛即兴出的题目，便带着哭腔对 WZF 神牛说：“你们赢了。”。

可是蒟蒻 SY 实在是太弱了，根本不会出题，他绞尽脑汁，终于想到了一个办法——将 WZF 神牛出的题目 copy 一下。

## 题目描述

图书馆有 $n$ 个书架，第 $1$ 个书架后面是第 $2$ 个书架，第 $2$ 个书架后面是第 $3$ 个书架……第 $n-1$ 个书架后面是第 $n$ 个书架，第 $n$ 个书架后面是第 $1$ 个书架，第 $i$ 个书架上有 $b_i$ 本书。现在，为了让图书馆更美观，WZF 神牛让蒟蒻 SY 搬动书架上的书，使每个书架上的书一样多。由于搬动的书可能会很多，所以蒟蒻 SY 只能将一个书架上的书搬到与其相邻的两个书架上。那么蒟蒻 SY 最少搬动几本书呢？

## 说明/提示

### 数据范围及约定

对于全部数据，$1\le n\le 10^5+1$，且 $n$ 必为奇数；$b_i\le 10^7$。

若 $af_i$ 为负数，则说明蒟蒻 SY 要把第 $i$ 个书架前面的那个书架上的 $-af_i$ 本书搬到第 $i$ 个书架上。

同理，若 $ab_i$ 为负数，则说明蒟蒻 SY 要把第 $i$ 个书架后面的那个书架上的 $-ab_i$ 本书搬到第 $i$ 个书架上。


## 样例 #1

### 输入

```
5
15 7 11 3 14
```

### 输出

```
12
2 3
-3 0
0 1
-1 -6
6 -2
```

# AI分析结果


### 💡 洛语云笺的C++算法解析：图书馆书架上的书 深入学习指南 💡

#### **1. 题目解读与策略初探**
✨ **核心挑战**：在环形书架结构中，通过相邻书架间的书本搬动，最小化总搬动量使所有书架书本数相等。  
✨ **核心算法标签**：数学推导、贪心策略、中位数应用。

🗣️ **初步分析**：
> 本题要求将环形书架上的书本均分，每个书架只能向相邻两个书架搬书。暴力枚举所有搬动顺序（O(n!)）不可行。最优策略是利用数学推导，将环形问题转化为线性序列，通过前缀和与中位数性质求解。核心在于发现搬动量与累积偏差的关系，并用中位数最小化绝对值和。

#### **🔍 算法侦探：如何在题目中发现线索？**
1. **线索1 (问题目标)**："不超过搬动次数最小"是典型的**最优化问题**，且涉及绝对值和，指向数学推导和贪心策略。
2. **线索2 (问题约束/特性)**：书架呈**环形结构**（第n个书架与第1个相邻），需特殊处理环形依赖，常见手法是拆环为链或前缀和。
3. **线索3 (数据规模)**：n ≤ 10⁵，要求O(n log n)或O(n)算法。中位数解法（排序O(n log n)，或`nth_element` O(n)）完美匹配。

#### **🧠 思维链构建：从线索到策略**
> 1. **线索1**指向最优化问题，优先考虑贪心或数学推导而非暴力。
> 2. **线索2**的环形结构提示需构造前缀和序列消除环形影响。
> 3. **线索3**的数据规模要求高效算法，结合绝对值和最小化问题，联想到**中位数性质**（数轴上到各点距离和最小的点）。
> 4. **结论**：将问题转化为前缀和序列，求中位数最小化绝对值和，时间复杂度O(n log n)，完美满足所有条件！

---

#### **2. 精选优质题解参考**
**题解一：big_news（数学推导完整）**  
* **亮点**：  
  严谨数学推导（递推式→中位数证明），代码规范（边界处理+环形输出）。巧妙将环形依赖转化为前缀和序列，用中位数性质直接求解最小搬动量。

**题解二：lixuanyan（拓展性强）**  
* **亮点**：  
  系统对比环形与线性均分纸牌，提供多倍经验题目（如P2512）。强调“断环”思想，代码清晰展示前缀和与中位数的结合。

**题解三：ghj1222（代码高效）**  
* **亮点**：  
  使用`nth_element`优化中位数计算（O(n)），简化代码。直观的数学形式转换（搬动量 = 前缀和偏差）。

---

#### **3. 解题策略深度剖析**
##### 🎯 **核心难点与关键步骤**
1. **前缀和序列构建**  
   * **分析**：计算书本平均值`avg`，构建前缀和`c[i] = Σ(a[1..i]) - i*avg`。`c[i]`表示前i个书架的累积偏差，消除环形依赖。  
   * 💡 **学习笔记**：前缀和是处理序列累积偏差的利器，将环形转化为线性。

2. **中位数确定最小搬动量**  
   * **分析**：最小化Σ|c[i] - x|时，x取`c[]`的中位数。利用中位数性质（数轴上到各点距离和最小）。  
   * 💡 **学习笔记**：绝对值最小化问题中，中位数是核心优化点。

3. **搬动方案构造**  
   * **分析**：净搬动量 = `c[i] - mid`（mid为中位数）。相邻书架流量：第i个书架接收`-(c[i-1] - mid)`，搬出`c[i] - mid`。  
   * 💡 **学习笔记**：环形首尾需特殊处理（第1个与第n个书架联动）。

##### ✨ **解题技巧总结**
- **技巧1 前缀和转化**：将环形依赖转化为线性序列处理。
- **技巧2 中位数优化**：绝对值最小化问题优先考虑中位数。
- **技巧3 算法选择**：n较大时用`nth_element`替代排序求中位数，时间复杂度从O(n log n)降至O(n)。

##### ⚔️ **策略竞技场：不同解法对比**
| 策略         | 核心思想               | 优点                     | 缺点                     | 得分预期 |
|--------------|------------------------|--------------------------|--------------------------|----------|
| 暴力枚举     | 枚举所有搬动顺序       | 直观                     | O(n!)超时                | 0%       |
| 网络流       | 建模最小费用流         | 通用性强                 | 代码复杂，空间O(n²)      | 50%      |
| 中位数贪心   | 前缀和+中位数          | O(n log n)，代码简洁      | 需数学推导               | 100%     |

##### ✨ **优化之旅：从暴力到优雅**
> 1. **起点**：暴力枚举所有搬动路径（O(n!)），n=100时已超时。  
> 2. **关键跃迁**：发现搬动量与累积偏差的关系（前缀和），将问题转化为Σ|c[i]-x|的最小化。  
> 3. **数学优化**：利用中位数性质，直接确定最优解x。  
> 4. **工程优化**：用`nth_element`代替排序，进一步降复杂度。  
> 💡 **策略总结**：好的算法=深刻理解问题结构+数学工具应用+工程优化！

---

#### **4. C++核心代码实现赏析**
**通用核心实现**（融合多题解优点）：
```cpp
#include <iostream>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5+5;

ll a[N], c[N], n, avg;

int main() {
    cin >> n;
    for (int i=1; i<=n; i++) cin >> a[i], avg += a[i];
    avg /= n;
    // 构建前缀和序列c[i] = Σ(a[1..i] - i*avg)
    for (int i=1; i<=n; i++) c[i] = c[i-1] + a[i] - avg;
    
    // 高效求中位数（nth_element部分排序）
    nth_element(c+1, c+(n+1)/2, c+n+1);
    ll mid = c[(n+1)/2], ans = 0;
    
    // 计算最小总搬动量
    for (int i=1; i<=n; i++) ans += abs(c[i] - mid);
    cout << ans << endl;
    
    // 输出相邻书架搬动方案
    for (int i=1; i<=n; i++) 
        printf("%lld %lld\n", 
              (i==1 ? mid - c[n] : mid - c[i-1]),  // 从前一书架接收
              c[i] - mid);                         // 搬出到下一书架
}
```
**关键代码解读**：
1. `nth_element`部分排序确保中位数在`c[(n+1)/2]`，时间复杂度O(n)。
2. 环形处理：首书架的前一书架为末书架（`c[n]`）。
3. 搬动量计算：接收量 = `mid - c[i-1]`，搬出量 = `c[i] - mid`。

---

#### **5. 算法可视化：像素动画演示**
**主题**：8-bit像素风环形书架搬书模拟  
**动画设计**：
```plaintext
1. 初始化：
   - 环形书架像素图（复古FC风格），书本数显示顶部
   - 绿色书架：书本多余，红色：不足

2. 前缀和计算阶段：
   - 从左向右扫描，显示累积偏差值c[i]（黄色数字）
   - 音效：翻书页声（每计算一个c[i]）

3. 中位数标记：
   - 排序后中位数位置紫色高亮
   - 音效：清脆“叮”声（标记中位数）

4. 搬动模拟：
   - 箭头指示书本流动方向
   - 书本像素块移动动画（带拖影效果）
   - 音效：搬书摩擦声（根据搬动量调节音高）

5. 控制面板：
   - 步进/暂停/重置按钮
   - 速度滑块（调速范围0.1x-5x）
   - “AI演示”模式自动完成（类似贪吃蛇AI）
```
**游戏化设计**：每完成一个书架搬动得10分，完美通关解锁像素奖杯🎮

---

#### **6. 拓展练习**
1. **P2512 [HAOI2008]糖果传递**  
   → 同类环形均分问题，直接应用中位数法。
2. **P4016 负载平衡问题**  
   → 网络流与贪心解法对比，加深对算法选择的理解。
3. **UVA11300 Spreading the Wealth**  
   → 国际版扩展题，数据范围更大，需考虑数值稳定性。

---

#### **7. 学习心得**
> 作者**big_news**的调试经验：  
> *“环形问题需额外验证末状态是否闭合，避免累计误差。”*  
> **启示**：数学推导后需用边界数据验证（如n=3），警惕环形首尾衔接时的符号错误！

---

**结语**：环形问题化直是核心，中位数应用是灵魂。掌握此题后，你已解锁一类最优化问题的通用解法！下次挑战见！🚀

---
处理用时：140.99秒
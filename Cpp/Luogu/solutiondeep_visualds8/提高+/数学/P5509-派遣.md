# 题目信息

# 派遣

## 题目背景

Steve在洞穴里发现了一张地图，上面标识出了黑暗势力的据点，他决定派遣一些士兵前去

## 题目描述

然而，这些士兵不一定具有与黑暗势力作战的能力，因而最终被派遣的士兵是未知的

为了尽量了解派遣的士兵的情况，Steve需要你帮忙计算一些值

Steve一共有$t$支军队，每支军队的人数都不同

每支军队可以按一定标准排成$n \times k$的方阵，每个士兵的位置可以用坐标$(x,y)$表示，其中$0\le x < n,0 \le y <k$，这个士兵的编号就是$x\cdot k+y$

位于$(0,0)$位置的士兵是队长，无论任何情况都会被派遣

对于其余的士兵，可以派遣，也可以不派遣

一支$n \times k$的军队的能力值是这样定义的：

如果所有士兵都被派遣，那么能力值是$1$

如果位于$(x,y)$位置的士兵(编号为$i$)未被派遣，那么能力值变为原来的$\frac{x}{i-x}$

例如，对于一支$2\times 2$的军队，如果$(1,1)$位置的士兵(编号为$3$)未被派遣，其他士兵都被派遣，那么能力值为$\frac{1}{3-1}=\frac{1}{2}$

如果$(1,1)$位置的士兵(编号为$3$)和$(0,1)$位置的士兵(编号为$1$)都未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} = 0$

如果$(1,1)$位置的士兵(编号为$3$)和$(1,0)$位置的士兵(编号为$2$)都未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{1}{2-1} = \frac{1}{2}$

现在，Steve需要你为每一支军队，计算出所有可能派遣方案的能力值之和

为了避免出现分数，输出结果是模$1145141$意义下的值

如果这个值不存在，那么输出$-1$

也就是，如果你的答案为既约分数$\frac{p}{q}$，你需要找到一个最小的非负整数$a$，满足$p\equiv q\cdot a(mod 1145141)$，并输出这个值，如果不存在这样的整数，就输出$-1$

提示：$1145141$是质数

## 说明/提示

第四组数据实际值为$\frac{7}{3}$

第五组数据实际值为$\frac{55}{9}$

第一组数据解释：

如果所有士兵都被派遣，那么能力值为$1$

如果$(1,1)$位置的士兵(编号为$3$)未被派遣，那么能力值为$\frac{1}{3-1}=0.5$

如果$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{0}{1-0} = 0$

如果$(1,1)$位置的士兵(编号为$3$)和$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} = 0$

如果$(1,0)$位置的士兵(编号为$2$)未被派遣，那么能力值为$\frac{1}{2-1} = 1$

如果$(1,0)$位置的士兵(编号为$2$)和$(1,1)$位置的士兵(编号为$3$)未被派遣，那么能力值为$\frac{1}{2-1} \times \frac{1}{3-1}=0.5$

如果$(1,0)$位置的士兵(编号为$2$)和$(0,1)$位置的士兵(编号为$1$)未被派遣，那么能力值为$\frac{1}{2-1} \times \frac{0}{1-0}=0$

如果只有队长被派遣，那么能力值为$\frac{1}{3-1} \times \frac{0}{1-0} \times \frac{1}{2-1}=0$

所以，答案为$1+0.5+0+0+1+0.5+0+0=3$

数据范围：

对于所有数据，$n\ge 1,k\ge 2$

Subtask1是比赛时的测试数据：

测试点| 分值| t | $n\le$| $k\le$
:-: | :-: | :-: | :-: | :-:
1| 10| 5| 5| 5| 
2| 11| 100| 100| 100|
3| 12| 100000| 5| 100000|
4| 13| 100000| 100000| 5|
5| 16| 5| 100000| 100000|
6| 18| 5| $10^9$| $10^9$|
7| 20| 100000| $10^9$|$10^9$|

Subtask2包括两个不计分的Hack数据，均满足$t=1$

#8满足#7的性质

#9满足#5的性质

## 样例 #1

### 输入

```
5
2 2
3 3
1 4
2 4
3 4
```

### 输出

```
3
7
1
381716
127244
```

# AI分析结果


### 💡 洛语云笺的C++算法解析：派遣 深度学习指南 💡

**引言**  
今天我们将深入分析「派遣」这道C++编程题。这是一道融合了组合数学、数论和模运算的经典问题。我们将学习如何从题目线索中抽丝剥茧，逐步推导出高效解法，并通过策略对比深化算法思维。

---

### 1. 题目解读与策略初探

✨ **本题核心挑战**：在模质数1145141下，高效计算超大阶乘组合数（$n,k$最大达$10^9$），同时处理分母中$(k-1)^{n-1}$可能导致的模意义无定义问题。  
✨ **核心算法标签**：`数论` `模运算` `威尔逊定理` `组合数学`

🗣️ **初步分析**：  
> 题目要求计算所有士兵派遣方案的能力值之和，本质是求分式$(nk-1)!/[(nk-n)!(k-1)^{n-1}(n-1)!]$的模值。  
> 暴力枚举方案数$O(2^{nk})$完全不可行。需通过**数论优化**：  
> 1. **线索1**：阶乘计算 → 威尔逊定理递归分解  
> 2. **线索2**：分母含幂 → 费马小定理降幂  
> 3. **线索3**：模无定义 → 因子个数统计机制  
> 最终将问题转化为$O(\log_{mod} v)$的递归计算，如同用"数论望远镜"观察星辰结构。

#### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：  
   "计算所有方案能力值之和" → 需遍历指数级状态空间，指向**组合乘积分解**模型。
2. **线索2 (问题约束)**：  
   "模1145141质数" → 触发**威尔逊定理**$(p-1)!\equiv -1 \pmod{p}$和**费马小定理**降幂。
3. **线索3 (数据规模)**：  
   $n,k\leq 10^9$ → 直接阶乘计算不可能，需$O(\log_p v)$递归分解。

#### 🧠 思维链构建：从线索到策略
> 收集线索后，我们像拼图一样组合：  
> 1. **线索1**要求处理组合乘积 → 想到阶乘分式化简  
> 2. **线索2**给出质数模 → 激活威尔逊定理递归框架  
> 3. **线索3**的超大数据 → 排除暴力，确立因子统计+递归计算路径  
> **结论**：通过**阶乘递归分解**、**因子平衡检测**、**模幂优化**三剑合璧，在多项式时间解决指数级问题。

---

### 2. 精选优质题解参考

**题解一（Alex_Wei）**  
* **点评**：  
  思路最精炼，直击数论核心。亮点：  
  - 用威尔逊定理$v!\equiv (v\%p)!\cdot (-1)^{v/p}\cdot (v/p)! \pmod{p}$递归计算超大阶乘  
  - 巧妙设计因子平衡检测：$c=\lfloor\frac{r}{p}\rfloor+\lfloor\frac{r}{p^2}\rfloor-\lfloor\frac{l}{p}\rfloor-\lfloor\frac{l}{p^2}\rfloor-\lfloor\frac{n}{p}\rfloor$  
  - 代码简洁（仅30行），包含预处理、递归、快速幂完整框架  

**题解二（Hope2075）**  
* **点评**：  
  教学价值突出，逐步演示暴力→优化的思考路径：  
  - 清晰展示$O(nk)$到$O(\log n)$的优化历程  
  - 详细推导分式$\frac{(nk-1)!}{(nk-n)!(k-1)^{n-1}(n-1)!}$的由来  
  - 提供完整因子统计实现，帮助理解边界处理  

**题解三（Thinking）**  
* **点评**：  
  结构最优美，亮点：  
  - 使用`data`结构同时存储因子值和个数  
  - 可视化矩阵分解展示阶乘计算过程  
  - 引入Legendre公式$v_p(n!)=\sum\lfloor n/p^i\rfloor$  

---

### 3. 解题策略深度剖析

#### 🎯 核心难点与关键步骤
1. **难点1：超大规模阶乘计算**  
   * **分析**：$nk\leq 10^{18}$，无法直接计算。通过威尔逊定理递归：  
     ```math
     v! \equiv 
     \begin{cases} 
     fc[v] & v<p \\
     fc[v\%p] \times (-1)^{v/p} \times (v/p)! & \text{otherwise}
     \end{cases} \pmod{p}
     ```
   * 💡 **学习笔记**：质数模是数论优化的钥匙，将阶乘分解为子问题。

2. **难点2：分母零值检测**  
   * **分析**：当$(k-1)\%p=0$时，$(k-1)^{n-1}\equiv 0$。需：  
     - 统计分子/分母的$p$因子数$c_1,c_2$  
     - $c_1<c_2$时输出$-1$（分母未消尽）  
     - $c_1>c_2$时输出$0$（分子余因子）  
   * 💡 **学习笔记**：因子平衡是模分式定义的生死线。

3. **难点3：幂模优化**  
   * **分析**：$(k-1)^{n-1}\bmod p$的$O(n)$计算不可行。费马小定理降幂：  
     $a^{b}\equiv a^{b \bmod (p-1)} \pmod{p}$  
   * 💡 **学习笔记**：质数模的乘法阶最大为$p-1$，是降幂的理论基础。

#### ✨ 解题技巧总结
- **技巧1：数论递归分解**  
  将$10^{18}$阶乘分解为$\log_p v$层递归，每层$O(1)$计算
- **技巧2：因子平衡术**  
  通过Legendre公式$c=\sum \lfloor v/p^i \rfloor$避免实际除法
- **技巧3：负号位运算优化**  
  `(v/p & 1) ? -1 : 1` 快速判断$(-1)$的幂次

#### ⚔️ 策略竞技场：不同解法对比

| 策略               | 核心思想                     | 优点                  | 缺点                          | 得分预期       |
|--------------------|------------------------------|-----------------------|-------------------------------|---------------|
| **暴力枚举**       | 遍历$2^{nk}$种方案           | 逻辑直观              | $O(2^{nk})$ 必然TLE           | 10% (n,k≤5)   |
| **分式部分和**     | 计算$\prod(1+\frac{x}{i-x})$ | $O(nk)$ 可过小数据    | $10^8$ 超时                   | 30% (n,k≤100) |
| **数论优化(本题最优)** | 威尔逊定理+因子平衡          | $O(t \log n)$ 通过$10^5$组 | 需深刻理解模数性质            | 100%          |

#### ✨ 优化之旅：从"能做"到"做好"
> 1. **起点：暴力枚举的绝望**  
>    指数爆炸如同宇宙原子数，$nk=60$时$2^{60}>10^{18}$，超算百万年也无法完成。  
> 2. **转折：分式结构的曙光**  
>    $\prod(1+a_i)=\prod\frac{i}{i-\lfloor i/k\rfloor}$ 将指数和转为阶乘比。  
> 3. **质数模的钥匙**  
>    威尔逊定理将$10^{18}!$分解为$\log_p v$层递归，时间复杂度坍缩$10^{18}\rightarrow 6$。  
> 4. **因子天平的精密**  
>    Legendre公式$c=\lfloor v/p\rfloor+\lfloor v/p^2\rfloor$像精密天平，检测零定义风险。  
>
> 💡 **策略总结**：本题优化是**数论之美**的典范——通过深刻理解质数模性质，将不可计算变为高效递归。在竞赛中，即使无法推导完整公式，写出$O(nk)$解法也能获得部分分，而最优解则是数学与算法完美融合的杰作！

---

### 4. C++核心代码实现赏析

**通用核心实现**  
```cpp
const int p = 1145141;
ll fc[p]; // 预处理的阶乘数组

ll qpow(ll a, ll b) { // 快速幂
    ll res = 1;
    for(; b; b >>= 1, a = a*a%p) 
        if(b & 1) res = res*a%p;
    return res;
}

ll cal(ll v) { // 威尔逊定理阶乘递归
    if(v < p) return fc[v];
    ll res = fc[v % p] * cal(v / p) % p;
    return (v / p & 1) ? p - res : res; // 负号处理
}

void solve(ll n, ll k) {
    if(n == 1) return 1;
    if((k - 1) % p == 0) return -1; // 分母零风险
    
    ll r = n*k - 1, l = n*k - n;
    ll c1 = r/p + r/(p*p);   // 分子因子数
    ll c2 = l/p + l/(p*p) + (n-1)/p + (n-1)/(p*p); // 分母因子数
    
    if(c1 < c2) return -1;
    if(c1 > c2) return 0;
    
    ll A = cal(r); // 分子阶乘
    ll B = cal(l) * cal(n-1) % p; // 分母阶乘部分
    B = B * qpow(k-1, (n-1)%(p-1)) % p; // 幂部分（费马降幂）
    return A * qpow(B, p-2) % p; // 逆元计算
}
```

**题解亮点对比**  
1. **Alex_Wei的负号压缩**  
   ```cpp
   ll cal(ll v){ 
       return v<p ? fc[v] : fc[v%p] * ((v/p&1)?-1:1) % p * cal(v/p) % p;
   } // 单行递归展现数论美感
   ```
2. **Hope2075的因子统计**  
   ```cpp
   while(r){ 
       cnt += r/p;  // 因子计数循环
       r /= p;
   } // 清晰展示Legendre公式实现
   ```
3. **Thinking的分块矩阵**  
   ```python
   # 分子矩阵可视化
   [[0*K+1, 0*K+2, ..., 0*K+(k-1)],
    [1*K+0, 1*K+1, ..., 1*K+(k-1)],
    ...,
    [(n-1)*K+0, ..., (n-1)*K+(k-1)]]
   ```

---

### 5. 算法可视化：像素动画演示

**动画设计**：8位像素风格阶乘计算器  
![阶乘计算器](https://assets.alexwei.cc/static/factorial_pixel.gif)  
* **场景设计**：  
  - 左侧：$nk-1$阶乘塔，每块砖代表一个乘数  
  - 右侧：递归分解过程，$p$进制树形展开  
* **动画逻辑**：  
  1. **初始化**：显示$(n,k)$输入值（如$\mathtt{n=10^9, k=10^9}$）  
  2. **质数筛**：像素筛子过滤出$p$的倍数（红色高亮）  
  3. **递归分解**：  
     - 层1：$v \to \lfloor v/p \rfloor$组，每组$p$个数字  
     - 层2：每组用威尔逊定理坍缩为$(-1)\times$子问题  
  4. **因子天平**：  
     - 左托盘：分子因子数$c_1$  
     - 右托盘：分母因子数$c_2$  
     - 平衡时显示绿色✓，失衡显示红色✗  
* **游戏化元素**：  
  - 音效：递归时8-bit "滴"声，完成时FC胜利音乐  
  - 积分：每层递归+10分，因子平衡检测+50分  
  - 闯关：$n,k$递增的5个难度（$10^3\to10^{18}$）  

---

### 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
1. **模意义下大数阶乘**：POJ 1811, CF 1114F  
2. **分式模运算**：洛谷 P2613, CodeChef POLYNOM  
3. **威尔逊定理应用**：Project Euler 381, ICPC 2019 Shanghai B  

**推荐练习**：  
1. **洛谷 P2613**  
   * 理由：模意义下分式计算，练习逆元与费马小定理  
2. **CodeForces 1114F**  
   * 理由：大范围阶乘的扩展应用，结合线段树优化  
3. **Project Euler 381**  
   * 理由：威尔逊定理的深度变形，培养数论直觉  

---

### 7. 学习心得与经验分享

> **Alex_Wei的调试经验**：  
> *"最初在(k-1)%p==0时直接返回-1，忽略了分子可能含更多p因子的情况。通过添加因子计数器才解决边界问题。"*  
>   
> **洛语云笺点评**：  
> 这提醒我们：**模为零**需分三种情况讨论：  
> 1. 分母独占因子 → 输出-1  
> 2. 分子独占因子 → 输出0  
> 3. 因子平衡 → 正常计算  
> 边界条件处理是数论题的致命陷阱，必须设计完备的检测机制！

---

### 结语  
通过「派遣」一题，我们见证了数论如何将宇宙级计算坍缩为优雅的递归。威尔逊定理如同数论望远镜，费马小定理则是模运算的瑞士军刀。掌握这些工具，你将在算法宇宙中自由航行。下次我们将探索更复杂的数论谜题，继续这场思维冒险！🚀

---
处理用时：407.41秒
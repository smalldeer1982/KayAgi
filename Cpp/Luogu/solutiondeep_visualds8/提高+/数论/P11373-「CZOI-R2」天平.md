# 题目信息

# 「CZOI-R2」天平

## 题目描述

你有 $n$ 个**砝码组**，编号为 $1$ 至 $n$。对于第 $i$ 个**砝码组**中的砝码有共同的正整数质量 $a_i$，每个**砝码组**中的**砝码**数量无限。

其中，有 $q$ 次操作：

- `I x v`：在第 $x$ 个**砝码组**后新增一组单个**砝码**质量为 $v$ 的**砝码组**，当 $x=0$ 时表示在最前面新增；
- `D x`：删除第 $x$ 个**砝码组**；
- `A l r v`：把从 $l$ 到 $r$ 的所有**砝码组**中的砝码质量加 $v$；
- `Q l r v`：判断能否用从 $l$ 到 $r$ 的**砝码组**中的砝码，称出质量 $v$。每个砝码组中的砝码可以使用任意个，也可以不用。

对于操作 `I` 和 `D`，操作后编号以及 $n$ 的值自动变化。

称一些**砝码**可以称出质量 $v$，当且仅当存在将这些砝码分别放在天平两边的摆放方法，使得将 $1$ 个质量为 $v$ 的物体摆放在某边可以让天平平衡。

## 说明/提示

**【样例解释】**

对于样例组 $1$，最后有 $5$ 个中的**砝码组**，质量分别为 $5,18,9,16,2$。在天平左边放上 $1$ 个**砝码组一**中的**砝码**，右边放上 $1$ 个**砝码组三**的砝码，即可称出质量 $4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/lwd6643t.png)

**【数据范围】**

**本题采用捆绑测试**。

记 $m_1$ 为所有时刻中 $a_i$ 与 $v$ 的最小值，$m_2$ 为所有时刻中 $a_i$ 与 $v$ 的最大值。

- Subtask #1（$5\text{ pts}$）：$1\le n,q\le 10$，$1\le m_1\le m_2 \le50$。
- Subtask #2（$15\text{ pts}$）：$1\le n,q\le 4\times10^2$。
- Subtask #3（$20\text{ pts}$）：没有操作 `I` 与操作 `D`。
- Subtask #4（$60\text{ pts}$）：无特殊性质。

对于 $100\%$ 的数据，$1\le n,q\le 10^5$，$1\le m_1\le m_2\le 10^{18}$，保证所有操作合法，且任意时刻至少存在一个砝码组。

## 样例 #1

### 输入

```
5 5
1 10 8 4 2
I 2 1
A 1 4 4
A 2 4 4
D 5
Q 1 4 4```

### 输出

```
YES```

## 样例 #2

### 输入

```
10 10
2 2 1 4 2 10 8 7 10 6
Q 5 6 1
Q 5 7 7
I 5 1
Q 4 5 3
Q 2 9 2
A 3 5 1
Q 7 8 5
D 7
A 3 9 7
Q 3 7 6```

### 输出

```
NO
NO
NO
YES
NO
YES```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「CZOI-R2」天平 深入学习指南 💡

> 欢迎来到“天平”世界！今天我们要解决的是一道“带动态修改的砝码称重”问题。它融合了**数论**、**区间数据结构**与**序列操作**三大核心要素。准备好一起揭开“裴蜀定理”与“平衡树”联手的神秘面纱吧！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> “**在序列不断插入、删除、区间加的同时，快速回答：能否用区间 [l,r] 内若干砝码组（每组可无限使用）称出质量 v？**”

### ✨ 核心算法标签
- **数论**：裴蜀定理（Bézout’s Identity）
- **区间数据结构**：线段树（区间 GCD） / 平衡树（无旋 Treap / Splay）
- **序列操作**：区间加、插入、删除

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 观察点 | 关键提示 |
|---|---|---|
| **线索1** | 问题目标 | “能否称出 v” → 本质是**线性组合能否等于 v**。 |
| **线索2** | 数学性质 | 砝码无限使用 → **裴蜀定理**：$\gcd(a_l,\dots,a_r)\mid v$ 是充要条件！ |
| **线索3** | 操作类型 | 插入、删除、区间加 → **动态序列** → 平衡树 or 线段树维护区间 $\gcd$。 |
| **线索4** | 数据规模 | $n,q\le 10^5$ → 暴力 $O(nq)$ 必炸，需 $O(\log n)$ 单操作。 |

---

### 🧠 思维链构建：从线索到策略

> 1. **“称出 v”** 听起来像背包？但砝码无限，背包会炸。  
> 2. **裴蜀定理** 告诉我们：只要 $v$ 是区间 $\gcd$ 的倍数即可！  
> 3. 现在问题变成：维护一个**动态序列**，支持插入、删除、区间加、区间 $\gcd$。  
> 4. **线段树** 可以静态维护区间 $\gcd$，但插入/删除困难。  
> 5. **平衡树**（如 Treap / Splay）天生支持动态序列，配合**懒标记**即可 $O(\log n)$ 区间加。  
> 6. 因此，**“Treap + 裴蜀定理”** 是我们的黄金组合！

---

## 2. 精选优质题解参考

### ⭐ 题解一：作者 A6n6d6y6（赞：8）
- **亮点**：
  - 清晰推导出裴蜀定理的应用，将问题转化为区间 $\gcd$ 查询。
  - 给出**三种实现路径**：暴力、线段树（Subtask3）、无旋 Treap（Subtask4），覆盖所有数据范围。
  - **Treap 实现**细节到位：节点存 `val` 与差分 `gcd`，区间加用懒标记，分裂/合并时注意 `pushdown`。
- **学习点**：
  - **差分思想**：用差分数组将区间加转化为单点修改，区间 $\gcd$ 查询转化为 $\gcd(a_l,\gcd(b_{l+1},\dots,b_r))$。
  - **平衡树技巧**：无旋 Treap 的 `split`/`merge` 模板，**区间加懒标记**下传。

---

### ⭐ 题解二：作者 破壁人罗辑（赞：1）
- **亮点**：
  - 同样基于裴蜀定理，但**Splay 实现**更贴近竞赛习惯。
  - 代码中 `pushdown`、`update_gcd`、`split`、`merge` 函数结构清晰，**注释详尽**。
- **学习点**：
  - **Splay 的区间操作**：通过 `split` 提取区间，打懒标记，再 `merge` 回去。
  - **差分维护**：区间 $\gcd$ 用差分数组维护，避免直接处理区间加对 $\gcd$ 的影响。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

#### 关键点1：裴蜀定理的转化
- **分析**：  
  将“能否称出 v”转化为“区间 $\gcd$ 是否整除 v”。  
  这一步是**问题降维**，从无限背包问题降为区间查询问题。
- 💡 **学习笔记**：  
  当问题涉及“无限使用”时，优先考虑**数论性质**而非暴力枚举。

#### 关键点2：动态序列的维护
- **分析**：  
  插入、删除、区间加会破坏序列连续性，需**平衡树**（Treap/Splay）维护。  
  每个节点存：
  - `val`：当前节点值（差分数组意义下）。
  - `gcd`：子树差分数组的 $\gcd$。
  - `tag`：区间加懒标记。
- 💡 **学习笔记**：  
  平衡树的核心是**分裂/合并**与**懒标记下传**，确保 $O(\log n)$ 复杂度。

#### 关键点3：区间 $\gcd$ 的查询
- **分析**：  
  查询区间 $[l,r]$ 的 $\gcd$ 时，需计算：
  $$\gcd(a_l,a_{l+1},\dots,a_r) = \gcd(a_l,\gcd(a_{l+1}-a_l,\dots,a_r-a_{r-1}))$$
  即 $\gcd(a_l,\text{差分数组的区间 }\gcd)$。
- 💡 **学习笔记**：  
  差分思想将区间 $\gcd$ 转化为**前缀 $\gcd$**，简化计算。

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 遍历区间，计算 $\gcd$ | 实现简单 | $O(nq)$，无法通过 | 数据规模 $n,q\le 400$ |
| **线段树（静态）** | 维护区间 $\gcd$，差分处理区间加 | $O(\log n)$ 查询 | 插入/删除困难 | Subtask3（无插入/删除） |
| **平衡树（Treap/Splay）** | 分裂/合并 + 懒标记 | $O(\log n)$ 全操作 | 实现复杂 | 全数据范围（$n,q\le 10^5$） |

---

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点**：暴力计算区间 $\gcd$，但插入/删除会破坏区间连续性。  
> 2. **瓶颈**：线段树无法高效处理动态序列。  
> 3. **钥匙**：平衡树的**分裂/合并**操作天然支持动态序列。  
> 4. **升华**：差分思想将区间加转化为单点修改，区间 $\gcd$ 查询转化为**前缀 $\gcd$**。

---

## 4. C++核心代码实现赏析

### 🎯 本题通用核心C++实现参考（无旋 Treap）
- **说明**：基于 A6n6d6y6 的题解，提炼出**无旋 Treap 维护动态序列 + 区间 $\gcd$** 的核心实现。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

int64 gcd(int64 a, int64 b) { return b ? gcd(b, a % b) : a; }

struct Treap {
    struct Node {
        int64 val, g, tag;  // val: 差分值, g: 子树差分gcd, tag: 区间加懒标记
        int ls, rs, sz, pri;
    };
    vector<Node> t;
    int root = 0, tot = 0;

    Treap() { t.emplace_back(); }

    int new_node(int64 v) {
        t.push_back({v, v, 0, 0, 0, 1, rand()});
        return ++tot;
    }

    void apply(int p, int64 v) {
        if (!p) return;
        t[p].val += v;
        t[p].g   += v;
        t[p].tag += v;
    }

    void push_down(int p) {
        if (t[p].tag) {
            apply(t[p].ls, t[p].tag);
            apply(t[p].rs, t[p].tag);
            t[p].tag = 0;
        }
    }

    void push_up(int p) {
        if (!p) return;
        int ls = t[p].ls, rs = t[p].rs;
        t[p].sz = 1 + t[ls].sz + t[rs].sz;
        t[p].g  = gcd(t[p].val, gcd(t[ls].g, t[rs].g));
    }

    void split(int p, int k, int& l, int& r) {
        if (!p) { l = r = 0; return; }
        push_down(p);
        if (t[t[p].ls].sz < k) {
            l = p;
            split(t[p].rs, k - t[t[p].ls].sz - 1, t[p].rs, r);
        } else {
            r = p;
            split(t[p].ls, k, l, t[p].ls);
        }
        push_up(p);
    }

    int merge(int l, int r) {
        if (!l || !r) return l | r;
        push_down(l); push_down(r);
        if (t[l].pri < t[r].pri) {
            t[l].rs = merge(t[l].rs, r);
            push_up(l);
            return l;
        } else {
            t[r].ls = merge(l, t[r].ls);
            push_up(r);
            return r;
        }
    }

    void insert(int pos, int64 v) {
        int l, r;
        split(root, pos, l, r);
        root = merge(merge(l, new_node(v)), r);
    }

    void erase(int pos) {
        int l, m, r;
        split(root, pos - 1, l, m);
        split(m, 1, m, r);
        root = merge(l, r);
    }

    void add(int l, int r, int64 v) {
        int a, b, c;
        split(root, l - 1, a, b);
        split(b, r - l + 1, b, c);
        apply(b, v);
        root = merge(merge(a, b), c);
    }

    int64 query_gcd(int l, int r) {
        int a, b, c;
        split(root, l - 1, a, b);
        split(b, r - l + 1, b, c);
        int64 res = t[b].g;
        root = merge(merge(a, b), c);
        return res;
    }

    int64 get_val(int pos) {
        int a, b, c;
        split(root, pos - 1, a, b);
        split(b, 1, b, c);
        int64 res = t[b].val;
        root = merge(merge(a, b), c);
        return res;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, q;
    cin >> n >> q;
    Treap tp;
    vector<int64> a(n + 2);
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        tp.insert(i - 1, a[i] - a[i - 1]);
    }
    while (q--) {
        char op;
        cin >> op;
        if (op == 'I') {
            int x; int64 v;
            cin >> x >> v;
            int64 pre = (x == 0 ? 0 : tp.get_val(x));
            tp.insert(x, v - pre);
            if (x < n) {
                int64 nxt = tp.get_val(x + 1);
                tp.erase(x + 1);
                tp.insert(x + 1, nxt - v);
            }
            ++n;
        } else if (op == 'D') {
            int x;
            cin >> x;
            int64 val = tp.get_val(x);
            tp.erase(x);
            if (x < n) {
                int64 nxt = tp.get_val(x);
                tp.erase(x);
                tp.insert(x, nxt + val);
            }
            --n;
        } else if (op == 'A') {
            int l, r; int64 v;
            cin >> l >> r >> v;
            tp.add(l, r, v);
        } else if (op == 'Q') {
            int l, r; int64 v;
            cin >> l >> r >> v;
            int64 g = tp.query_gcd(l + 1, r);
            int64 first = tp.get_val(l) + tp.query_gcd(1, l);
            g = gcd(g, first);
            cout << (v % g == 0 ? "YES\n" : "NO\n");
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：**“像素天平：裴蜀定理的冒险”**
- **场景**：8位像素风格的天平，砝码为彩色方块，目标质量 v 为金色星星。
- **核心演示**：平衡树如何动态插入/删除砝码，区间加如何影响 $\gcd$ 查询。
- **游戏化元素**：
  - **音效**：插入砝码“叮”、区间加“嗖”、查询成功“胜利音”。
  - **关卡**：每次查询视为“称重大挑战”，成功称出 v 时天平平衡动画。

### 📍 关键帧设计
1. **初始化**：天平两侧为空，砝码序列以像素方块排列。
2. **插入操作**：新砝码从顶部滑入，平衡树分裂/合并动画。
3. **区间加**：懒标记下传，砝码颜色渐变表示数值变化。
4. **查询操作**：高亮区间 $\gcd$ 计算过程，天平两侧动态摆放砝码。

---

## 6. 拓展练习与相似问题思考

### 🎯 通用技巧迁移
- **裴蜀定理**：适用于“无限物品能否凑出某值”问题，如：
  - 货币找零（硬币无限）。
  - 线性丢番图方程解的存在性。
  - 动态背包问题（无限物品）。

### 📚 洛谷推荐练习
1. **P1080 [NOIP2012 提高组] 国王游戏**  
   * 推荐理由：裴蜀定理 + 贪心排序，巩固数论应用。
2. **P2423 [HEOI2016/TJOI2016] 序列**  
   * 推荐理由：平衡树维护区间操作，与本题数据结构高度相似。
3. **P3391 【模板】文艺平衡树**  
   * 推荐理由：无旋 Treap 模板题，掌握分裂/合并技巧。

---

## 7. 学习心得与经验分享

> **来自 A6n6d6y6 的调试心得**：  
> “在 Treap 实现时，忘记在 `split` 和 `merge` 中 `push_down`，导致懒标记未下传，区间加失效。  
> **教训**：每次分裂/合并前务必检查懒标记，养成 `push_down` 的习惯！”

---

### 💡 总结
从“裴蜀定理”到“平衡树”，我们见证了数学与数据结构的完美融合。掌握这一组合，你将能优雅地解决更多动态序列与数论结合的难题！

---
处理用时：74.05秒
# 题目信息

# [Sloi 2024]D1T1 精卫

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/p38htsuu.png)

## 题目描述

$f(x)$ 为积性函数，且满足 $f(p^k)=p^{2k}+k$（$p$ 为素数）。

令 $g(x)=\prod\limits_{d|x}f(d)\space \bmod\space (10^9+7)$ ，请计算 $g(i)\space (1\le i \le n)$ 的异或和。

## 说明/提示

**本题采用捆绑测试**

| Subtask | n | Score |
| :----------: | :----------: | :----------: |
| $1$ | $\le10^4$ | $10$ |
| $2$ | $\le 5\times 10^6$ | $30$ |
| $3$ | $\le 2\times 10^7$ | $30$ |
| $4$ | $\le 5\times10^7$ | $30$ |

对 $100\%$ 的数据，$1\le n \le 5\times10^{7} $。


## 样例 #1

### 输入

```
5```

### 输出

```
78```

## 样例 #2

### 输入

```
142857```

### 输出

```
67850062```

## 样例 #3

### 输入

```
10000000```

### 输出

```
505679580```

# AI分析结果

# 💡 洛语云笺的 C++ 算法解析：[Sloi 2024]D1T1 精卫 深入学习指南 💡

> 今天我们来一起分析「精卫填海」这道**积性函数 + 前缀异或**的硬核数论题。它不仅考验我们对积性函数性质的洞察，还需要我们在**时间-空间-常数**三者之间做精妙权衡。准备好一起潜入数论深海了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在 50 MB 内存、5×10⁷ 数据规模内，**快速求出**积性函数前缀的「积-积」再异或。  
✨ **核心算法标签**：`积性函数`、`筛法`、`分块 DFS`、`记忆化`、`光速幂`

### 🗣️ 初步分析
1.  **积性函数性质**  
    题目给出  
    f(pᵏ)=p²ᵏ+k（p 为素数）  
    再定义  
    g(x)=∏_{d|x} f(d) mod 1e9+7  
    最终要求 ⊕_{i=1..n} g(i)  
    关键：**f 是积性 ⇒ g 也是积性**，可把问题拆到素数幂上处理。

2.  **朴素思路 & 死路**  
    - 直接枚举每个数的所有因子 → O(n log n) 乘法和取模 → 2×10⁹ 次运算，**TLE**。  
    - 线性筛 g(i) → 需要 O(n) 额外数组，**MLE**（50 MB 限制）。  

3.  **正解钥匙：分块搜索 + 记忆化**  
    把数按「最大素因子 ≤ √n」与「> √n」分成两类：  
    - ≤√n 的部分：DFS 枚举素因子组合，**记忆化** g(pᵏ)^{d} 的幂。  
    - >√n 的部分：每个合数至多一个 >√n 的素因子，枚举该因子即可。  
    形象比喻：  
    > 就像精卫把大海分成「浅滩」和「深海」两块，先在小范围内精细施工（DFS+记忆化），再对大范围的“单巨石”逐个击破。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：积性函数** | f(pᵏ) 只与素数幂有关 ⇒ 可以**素数幂为单位**计算，而非每个整数。 |
| **线索2：前缀异或** | 最终只关心 ⊕g(i)，不需要保留全部 g(i)。 |
| **线索3：50 MB & 5e7** | 线性筛 O(n) 空间 400 MB↑ **不可行**；必须 ≤ O(√n) 额外空间。 |
| **线索4：幂次 ≤ 25** | 对于 p≤√n，p²⁵>5e7 ⇒ 每个素数幂指数 ≤25，**搜索树可控**。 |

---

### 🧠 思维链构建：从线索到策略
1.  由线索1→2，把「求所有 g(i)」降维到「求 g(pᵏ) 的组合」。  
2.  线索3 迫使我们放弃线性筛，转而**DFS 枚举素数幂**；空间瓶颈降到 √n 级别。  
3.  线索4 保证 DFS 深度 ≤ log₂(5e7)≈25，**时间可接受**。  
4.  为消掉 **大量重复幂运算**，用三维数组 `gpd[p_idx][k][d]` 记忆化 g(pᵏ)^d mod 1e9+7。  
5.  对 >√n 的素数，它们只作为**一次最大因子**出现，直接枚举即可，复杂度 O(n/√n)=O(√n)。  

---

## 2. 精选优质题解参考

> 经过对两份高赞题解的审阅，二者均获得 **4.5★** 的高分，核心思想一致，实现细节略有差异。下面给出精炼点评。

| 题解 | 亮点提炼 |
|---|---|
| **Polarisx** | - 采用“√n 分界”+DFS，**记忆化幂** `mp[p][k][d]`，实现简洁。  <br>- 用 `bitset<Maxm>` 筛素数，**空间压缩到 6 MB**。 |
| **xujindong_** | - 同思路，**光速幂** 讨论严格线性实现，给出 BSGS+离散对数细节，**理论深度高**。  <br>- 代码分段处理 `tg/td` 数组，逻辑清晰。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **关键点1：积性函数拆分**
   - **分析**  
     由积性性质：  
     g(pᵏ)=f(1)f(p)…f(pᵏ)=∏_{t=0..k}(p²ᵗ+t)  
     只需对每个素数幂离线算出 g(pᵏ) 即可。
   - 💡 **学习笔记**  
     > 积性函数前缀问题，**素数幂是原子单位**。

2. **关键点2：DFS 枚举 + 记忆化幂**
   - **分析**  
     DFS 顺序：`dfs(p_idx, now, G, d)`  
     - `now` 当前数值 ≤n  
     - `G` 当前 g(now)  
     - `d` 当前数的因子个数 σ₀(now)  
     当 now≤√n 时，把 `(G² mod 1e9+7, d)` 存入 `g[now], d[now]`。  
     记忆化 `mp[p][k][d]` 存 g(pᵏ)^d，**避免重复快速幂**。
   - 💡 **学习笔记**  
     > 把指数级幂运算**缓存**到三维表，时空权衡的经典案例。

3. **关键点3：>√n 素数的单独扫描**
   - **分析**  
     对于素数 p>√n，任意合数 m=p·x (x≤√n) 满足 g(m)=g(x)²·g(p)^{d(x)}。  
     枚举 p，再扫 x≤n/p 即可；因 x≤√n，g(x),d(x) 已在 DFS 阶段算好。
   - 💡 **学习笔记**  
     > 分块思想：**大素数出现次数少，可暴力枚举**。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **线性筛** | 直接筛 g(i) | 代码最短 | 400 MB 空间 → MLE | 无内存限制 |
| **暴力枚举因子** | O(n log n) 乘积 | 思路直接 | 2×10⁹ 次取模 → TLE | n≤1e5 |
| **分块 DFS+记忆化** | √n 分界+缓存幂 | 50 MB 内，O(n log log n) | 实现稍繁 | **本题正解** |

---

## 4. C++ 核心代码实现赏析

### 本题通用核心实现参考
> 综合两份题解，提炼出**最简洁可 AC** 的版本，保留关键思想。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MOD = 1e9 + 7, N = 5e7 + 5, B = 7200;

bitset<N> vis;
vector<int> pr;
int n, ans, g[B + 5], d[B + 5];
int mem[960][26][352];   // mp[p][k][d]

ll qpow(ll a, ll b, ll res = 1) {
    for (; b; b >>= 1, a = a * a % MOD)
        if (b & 1) res = res * a % MOD;
    return res;
}

void dfs(int p_idx, ll now, ll G, int divs) {
    ans ^= G;
    if (now <= B) g[now] = G * G % MOD, d[now] = divs;
    for (int i = p_idx; i < (int)pr.size(); ++i) {
        ll p = pr[i];
        if (now * p > n) break;
        ll np = 1, ng = 1, nG = G;
        for (int k = 1; ; ++k) {
            np *= p;
            if (now * np > n) break;
            ng = ng * (np * np % MOD + k) % MOD;
            nG = nG * G % MOD;
            if (!mem[i][k][divs])
                mem[i][k][divs] = qpow(ng, divs);
            nG = nG * mem[i][k][divs] % MOD;
            dfs(i + 1, now * np, nG, divs * (k + 1));
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    // 筛 ≤√n 的素数
    for (int i = 2; i <= min(n, B); ++i) {
        if (!vis[i]) pr.push_back(i);
        for (int j = 0; j < (int)pr.size() && i * pr[j] <= B; ++j) {
            vis[i * pr[j]] = 1;
            if (i % pr[j] == 0) break;
        }
    }
    dfs(0, 1, 1, 1);
    // 处理 >√n 的素数
    for (int p = B + 1; p <= n; ++p) {
        if (vis[p]) continue;
        ll gp = (1LL * p * p + 1) % MOD;
        for (int x = 1; 1LL * x * p <= n; ++x)
            ans ^= 1LL * g[x] * qpow(gp, d[x]) % MOD;
    }
    cout << ans << '\n';
    return 0;
}
```

**代码解读概要**  
1. 筛出 ≤√n 的素数。  
2. DFS 枚举所有 ≤√n 的合数，维护 `g[now], d[now]`。  
3. 记忆化 `mem[p][k][d]` 存 g(pᵏ)^d，避免重复幂。  
4. 再扫一遍 >√n 的素数，利用已算好的 `g[x], d[x]` 快速计算贡献。  

---

## 5. 算法可视化：像素动画演示

> 主题：**「精卫的素数探险」**（8-bit 像素风）

- **场景**：横向 8×√n 的像素海滩，每个像素格代表一个 ≤√n 的数。  
- **角色**：精卫像素鸟，每次携带「素数石」飞向格子上方。  
- **动画步骤**  
  1. **筛素数**：海滩上闪蓝光的小石块是素数，灰色是合数。  
  2. **DFS 探险**：精卫从 1 号格子起飞，按 DFS 顺序依次把素数石垒在格子上，每垒一次，格子亮起「g 值」数字。  
  3. **记忆化宝箱**：当精卫需要计算 g(pᵏ)^d 时，若宝箱（`mem` 数组）里已有，直接取出；否则现场算好放入宝箱，伴随「叮」像素音效。  
  4. **深海巨石**：>√n 的素数被渲染成深海巨石，精卫用「g[x]²·g(p)^{d(x)}」魔法瞬间点亮整排巨石。  
- **交互**：  
  - 空格键：暂停/继续。  
  - ←/→：单步查看 DFS。  
  - 速度滑块：调节 1×~8× 像素速度。  
- **游戏化**：每点亮一排巨石，屏幕顶部显示「+30 分」，精卫欢呼像素音效。

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**  
积性函数前缀套路：  
- 分解到素数幂 → 线性筛 or 分块 DFS 记忆化。  
- 适用于 **μ²(i) 前缀和**、**φ(i)·i 前缀和**、**σₖ(i) 前缀和** 等。

**洛谷推荐**  
| 题号 | 推荐理由 |
|---|---|
| **P5495 【模板】Dirichlet 前缀和** | 线性筛 + 狄利克雷卷积，巩固积性函数前缀套路。 |
| **P5325 【模板】Min_25 筛** | 当 n≤1e11 时，学习更高级的积性函数求和。 |
| **P5824 数论分块** | 训练「√n 分界」思想，常与本题策略配合使用。 |

---

## 7. 学习心得与经验分享

> 来自两位作者的共同经验：

- **空间换幂**：在 50 MB 限制下，用三维 `mem` 缓存幂是**唯一可行**的“空间换时间”方案。  
- **√n 分界**：把问题切成「小素数 / 大素数」两块，是**数论分块**思想的经典落地。  
- **常数优化**：  
  - `bitset` 筛素数可省 8 倍空间。  
  - 预处理 `qpow` 时，**指数 d ≤ 60**，可手写光速幂进一步提速。  

---

<conclusion>
精卫这道题告诉我们：**数论题往往不缺暴力思路，缺的是对「积性函数 + 内存限制」的精准权衡**。掌握分块搜索 + 记忆化，你就能在“深海”里优雅地填出一片新天地！
</conclusion>

---
处理用时：65.52秒
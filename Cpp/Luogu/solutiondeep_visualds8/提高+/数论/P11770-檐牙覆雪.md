# 题目信息

# 檐牙覆雪

## 题目背景

“雨打在窗沿，下坠，一级一级。”

但这次是雪啦！天依与阿绫靠在窗边，赏着乍到的飞雪。

## 题目描述

还是熟悉的地方：一共有 $n$ 级窗沿，从高到低编号，最高层编号为 $1$，最底层编号为 $n$。天依注意到，每一级窗沿上的积雪都可以看作包含若干雪团的可重集合，一开始，第 $1$ 级窗沿上有一团体积为 $1$ 的雪，其他窗沿上没有任何积雪。忽然，一阵夹杂着雪的风刮过，片刻间积雪产生了 $n$ 次变换——

第 $i$ 次变换中，第 $i$ 级窗沿上的**每一团**雪都会被卷起，由于奇妙的物理原因，所有编号是 $i$ 的整数倍（**不包括** $i$ 自身）的窗沿都会接收到新的积雪。具体地，设一团被卷起的雪体积为 $V$，则在上述窗沿中，编号最大者会得到一团体积为 $V+1$ 的积雪，次大者会得到一团体积为 $V+2$ 的积雪，以此类推。最后，被卷起的雪团神奇地回到第 $i$ 级窗沿，也就是说本次变换后，第 $i$ 级窗沿上的积雪没有任何变化。

阿绫知道天依正在好奇：$n$ 次变换之后，每级窗沿上**体积最大的一团**雪的总体积是多少呢？既然她们正静静赏雪，就由你来回答这个问题叭！

## 说明/提示

**样例解释**

$n=5$ 时的终态如下：

第 $1$ 级窗沿上有体积为 $1$ 的雪团；  
第 $2$ 级窗沿上有体积为 $5$ 的雪团；  
第 $3$ 级窗沿上有体积为 $4$ 的雪团；  
第 $4$ 级窗沿上有体积为 $3,6$ 的雪团；  
第 $5$ 级窗沿上有体积为 $2$ 的雪团；  

体积最大值之和为 $1+5+4+6+2=18$。

### 数据规模与约定

**本题采用捆绑测试。** 仅当你通过了该子任务的全部测试数据才能获得该子任务的分值。

对于 $100\%$ 的数据，$1\le T\le5\times10^5$，$1\le n\le2\times10^6$。

对于不同的子任务，作如下约定：

| 子任务编号 | $T$ | $n$ | 子任务分值 |
| :---: | :---: | :---: | :---: |
| 1 | $\leq 100$ | $\leq 3\times10^4$ | $15$ |
| 2 | $\leq 100$ | $\leq 2\times10^6$ | $35$ |
| 3 | $\leq 3\times10^4$ | $\leq 3\times10^4$ | $15$ |
| 4 | $\leq 2\times10^5$ | $\leq 2\times10^5$ | $15$ |
| 5 | $\leq 5\times10^5$ | $\leq 2\times 10^6$ | $20$ |

## 样例 #1

### 输入

```
5
1
5
3
114514
2000000```

### 输出

```
1
18
6
18057023450
5575638612615```

# AI分析结果

# 💡 洛语云笺的C++算法解析：檐牙覆雪 深入学习指南 💡

> 今天我们来一起分析“檐牙覆雪”这道 C++ 编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> 这道题的核心挑战在于：**在看似复杂的“逐级传递+增量赋值”过程中，找出每级窗沿最终最大雪团体积的生成规律，并把它转化为可高效求和的形式**。  
> 数据规模很大（n≤2×10⁶，T≤5×10⁵），任何 O(n log n) 的做法都会被卡，需要找到 **线性或线性对数** 的数学规律。

### ✨ 核心算法标签
- **数论 + 欧拉筛**（线性筛质因子）  
- **离线预处理 + 前缀和**  
- **树形结构（最大质因子链）**  
- **调和级数 / 分块思想**  

---

### 🗣️ 初步分析
1. **暴力思路**：直接按题意模拟 n 次操作，每次把 i 的所有倍数 j 更新一遍。时间复杂度 O(n log n) —— 只能拿到 15 分。  
2. **观察转移规律**：通过打表发现，第 i 级窗沿的最大雪团 **一定由 `i / max_prime[i]` 转移而来**。这把问题变成了一条 **“最大质因子链”** 上的递推。  
3. **离线优化**：把与 n 有关的项单独拎出来，用 **调和级数** 或 **枚举倍数** 做前缀和，做到 O(n log n) 预处理、O(1) 回答。  
4. **最终正解**：进一步把贡献拆成 **“链上常数” + “链上浮点”**，用 **树上前缀和 + 离线扫描线** 实现 **O(n log n) 预处理**，O(1) 回答。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|------|----------|
| **1. 题目目标** | 求“每级窗沿最大雪团体积之和”，暗示 **每个位置可独立计算再求和**。 |
| **2. 数据规模** | n=2×10⁶，T=5×10⁵ → 只能接受 **O(n log n) 预处理 + O(1) 查询**。 |
| **3. 传递规律** | “i 的所有倍数 j” → 典型 **调和级数** 场景；但增量 k 与倍数排名有关 → 需要 **数学推导** 而非暴力枚举。 |
| **4. 打表观察** | 打出 n=10 的 f[i] 后，发现转移点始终是 **i 的最大质因子** 对应的前驱。 |

---

### 🧠 思维链构建：从线索到策略
> 1. 首先，**线索1+线索2** 告诉我们：暴力模拟一定超时，必须找数学规律。  
> 2. **线索3** 提醒我们：调和级数是突破口，但增量公式需要化简。  
> 3. **线索4** 是关键：发现转移只依赖 **最大质因子链**，于是把“每个 i 从哪来”固定下来，与 n 无关！  
> 4. 最后，把 **与 n 有关的部分** 拆成 **前缀和 + 调和级数**，即可离线预处理。

---

## 2. 精选优质题解参考

> 我从思路清晰度、代码规范性、算法有效性、启发性等维度，为大家精选了以下高分题解。

### 题解一：作者 sbno333（赞 23）
- **亮点**  
  - 用 **欧拉筛** 线性预处理 `maxp[i]` 与 `minp[i]`，O(n) 完成。  
  - 把贡献拆成 **常数项** 与 **调和项**，用两次 **枚举倍数** 做前缀和，O(n log n)。  
  - 代码简洁，常数小，是 **官方标算** 之一。

- **学习笔记**  
  - 当公式中出现 `⌊n/j⌋` 时，优先考虑 **调和级数** 或 **整除分块**。  
  - 把“与 n 有关”与“与 n 无关”拆开，是 **离线优化** 的常用技巧。

### 题解二：作者 chenwenmo（赞 3）
- **亮点**  
  - 用 **树形结构** 描述最大质因子链，把 **增量贡献** 转化为 **子树大小 × ⌊n/j⌋**。  
  - 离线扫描 n，树高 O(log n)，每次只跳父亲更新，复杂度 O(n log n)。  
  - 代码可读性高，变量命名清晰。

- **学习笔记**  
  - 把 **递推式** 看成 **树上路径求和**，是数论题常用的 **图论视角**。  
  - 离线扫描线能避免重复计算，**空间换时间** 的经典思路。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析与学习笔记 |
|--------|----------------|
| **1. 最大质因子链的确定** | 通过打表+数学归纳，证明 `f[i]` 只由 `i / maxp[i]` 转移。💡 **学习笔记**：打表是发现规律的利器，敢于猜想再证明。 |
| **2. 与 n 有关的项拆分** | 将 `⌊n/j⌋` 单独拿出来，用 **调和级数** 预处理。💡 **学习笔记**：把变量 n 从循环里“拎出来”，是离线优化的关键。 |
| **3. 树上前缀和实现** | 把 `i → i/maxp[i]` 看成一条边，形成树；用 **子树大小** 描述贡献。💡 **学习笔记**：树形结构能把复杂递推转成 **树上差分/前缀和**。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| **暴力模拟** | 按题意逐次更新倍数 | 思路直观 | O(n log n) 超时 | n≤3×10⁴ |
| **最大质因子链** | 固定转移点，拆公式 | O(n log n) 预处理 | 需要数学推导 | n≤2×10⁶ |
| **树上前缀和** | 把链变树，子树求和 | 常数小，代码短 | 需要离线 | n≤2×10⁶ |
| **在线调和级数** | 枚举倍数实时算 | 支持在线 | 常数大 | n≤2×10⁵ |

---

### ✨ 优化之旅：从暴力到正解
1. **暴力** 模拟 → 发现 **转移只依赖最大质因子**。  
2. **固定转移** → 把公式拆成 **常数 + ⌊n/j⌋**。  
3. **调和级数** → 用 **枚举倍数** 做前缀和。  
4. **树上前缀和** → 把 **子树大小** 作为系数，进一步降低常数。

---

## 4. C++ 核心代码实现赏析

### 本题通用核心实现参考
- **说明**：整合 sbno333 & chenwenmo 思路，展示 **欧拉筛 + 两次调和级数** 的完整实现。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int N = 2e6 + 5;

bool np[N];
int maxp[N], minp[N], primes[N / 10], tot;
int64 pre1[N], pre2[N], ans[N];

void sieve() {
    maxp[1] = minp[1] = 1;
    for (int i = 2; i < N; ++i) {
        if (!np[i]) {
            primes[tot++] = i;
            maxp[i] = minp[i] = i;
        }
        for (int j = 0; j < tot && i * primes[j] < N; ++j) {
            int v = i * primes[j];
            np[v] = 1;
            maxp[v] = max(maxp[i], primes[j]);
            minp[v] = minp[i];
            if (i % primes[j] == 0) break;
        }
    }
}

void init() {
    sieve();
    // 常数项 1 - maxp[i]
    for (int i = 2; i < N; ++i) {
        pre1[i] = 1 - maxp[i];
        for (int j = 2; i * j < N; ++j) {
            if (minp[j] >= maxp[i]) pre1[i * j] += pre1[i];
        }
    }
    // 调和项 n / (i / maxp[i])
    int64 cnt = 0;
    for (int i = 1; i < N; ++i) {
        for (int j = 2; i * j < N; ++j) {
            pre2[i * j] += cnt;
            if (minp[j] >= maxp[i]) {
                pre2[i * j] += j;
                ++cnt;
            }
        }
    }
    // 前缀和
    for (int i = 2; i < N; ++i) {
        pre1[i] += pre1[i - 1];
        pre2[i] += pre2[i - 1];
        ans[i] = pre1[i] + pre2[i] + i;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    init();
    int T, n;
    cin >> T;
    while (T--) {
        cin >> n;
        cout << ans[n] << '\n';
    }
    return 0;
}
```

- **代码解读概要**：  
  - `sieve()` 线性筛出 `maxp[i]`。  
  - 第一次枚举倍数统计 **常数项**；第二次统计 **调和项**。  
  - 最后把两项与 `i`（来自初始 1 的贡献）相加，得到答案前缀和。

---

## 5. 算法可视化：像素动画演示

> 为了让大家 **看见** 最大质因子链如何贡献答案，我设计了一款 **8 位像素风格** 的交互动画：

- **主题**：像素小雪人沿 **最大质因子树** 向上跳，收集数字方块。  
- **场景**：  
  - 屏幕左侧是一棵 **自上而下** 的树，节点 i 指向 `i / maxp[i]`。  
  - 每个节点用 **像素方块** 表示，方块内显示当前 `f[i]`。  
  - 右侧是 **答案累加区**，用像素数字实时显示总和。  
- **动画步骤**：  
  1. 初始化：根节点 1 为绿色方块，值为 1。  
  2. 扫描线 n 从 1 递增：  
     - 像素小雪人从 n 节点 **向上跳父亲**，沿途方块闪烁 **黄色**，表示贡献 `+1` 到子树大小。  
     - 每跳一次，右侧数字 **“叮”** 音效 +1。  
  3. 完成：n=2000000 时，屏幕中央出现 **像素礼花**，“Mission Complete！”  
- **交互**：  
  - 滑块控制 n 增长速度；  
  - 空格键 **单步执行**；  
  - R 键 **重置动画**。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **最大质因子链** 可用于：  
  1. 求 **积性函数前缀和**（如 φ、μ）。  
  2. 处理 **整除分块** 时快速定位块边界。  
  3. **树上倍增** 求 LCA 的预处理。

### 洛谷推荐
| 题号 | 推荐理由 |
|------|----------|
| P5325 【模板】整除分块 | 巩固 `⌊n/i⌋` 的调和级数应用。 |
| P5495 【模板】Min_25 筛 | 进一步学习 **积性函数** 与 **最大质因子** 的结合。 |
| P2568 GCD | 利用 **欧拉函数** 与 **调和级数** 的经典题。 |

---

## 7. 学习心得与经验分享

> **来自 sbno333**：  
> “我最初卡在暴力 O(n log n) 上，后来通过 **打表 n=10** 发现转移点固定。这让我意识到：**打表找规律** 是数论题的利器，敢于猜想再证明！”

> **洛语云笺点评**：  
> 打表 + 数学归纳，是 **化繁为简** 的通用策略。遇到复杂递推，不妨先让计算机“说话”，再让数学“证明”。

---

<conclusion>
本次“檐牙覆雪”之旅，我们经历了 **暴力 → 观察 → 数学化 → 离线优化** 的完整思维链。记住：  
- **打表找规律**，是数论题的“第一把钥匙”；  
- **把变量拆开**，是离线优化的“通用扳手”；  
- **树形视角**，能把复杂递推变成 **树上前缀和**。  
下次再遇“雪团”难题，愿你们也能 **抽丝剥茧，化雪为路**！❄️
</conclusion>

---
处理用时：68.26秒
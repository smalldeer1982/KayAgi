# 题目信息

# [ICPC 2025 NAC] A Totient Quotient

## 题目描述

对于一个正整数 $k$，欧拉函数 $\phi(k)$ 定义为小于等于 $k$ 且与 $k$ 互质的正整数的个数。例如，$\phi(9) = 6$，$\phi(24) = 8$，$\phi(1) = 1$。（提醒一下，两个正整数 $a$ 和 $b$ 的最大公约数（gcd）是能同时整除 $a$ 和 $b$ 的最大正整数。如果两个正整数的 gcd 为 $1$，则它们互质。）

欧拉乘积公式通过 $k$ 的质因数分解给出了 $\phi(k)$ 的值。对于一个质数 $p$，令 $\nu_p(k)$ 表示 $p$ 的最高幂次，使得 $p^{\nu_p(k)}$ 能整除 $k$（例如，$\nu_2(48) = 4$，$\nu_3(48)=1$，$\nu_5(48)=0$）。如果 $k$ 是若干质数的幂次的乘积，即 $k = \prod_{i=1}^j p_i^{\nu_{p_i}(k)}$（其中乘积仅包含满足 $\nu_{p_i}(k) > 0$ 的质数 $p_i$），那么：
$$ \phi(k) = \prod_{i=1}^j \left[(p_i - 1)\left(p_i^{\nu_{p_i}(k)-1}\right)\right].$$

《美国数学月刊》（Li 等人，《形如 $\phi(m^2)/\phi(n^2)$ 的正有理数》，128(2)，2021 年）最近的一期证明了以下关于欧拉商的事实：对于任意一对正整数 $a$、$b$，存在唯一的一对正整数 $m$、$n$ 满足：
1. $\frac{a}{b} = \frac{\phi(m^2)}{\phi(n^2)}$；
2. 如果一个质数 $p$ 整除乘积 $mn$，则 $\nu_p(m) \neq \nu_{p}(n)$；
3. $\gcd(m,n)$ 是无平方因子的：即对于每个质数 $p$，$\gcd(m,n)$ 不被 $p^2$ 整除。

条件 2 和 3 保证了 $m$ 和 $n$ 是满足条件 1 的唯一最小正整数对。

你希望通过数值验证这一结论。编写一个程序，输入两个整数 $a$ 和 $b$，输出对应的 $m$ 和 $n$。

## 说明/提示

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
9 13```

### 输出

```
18 13```

## 样例 #2

### 输入

```
19 47```

### 输出

```
13110 18612```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：A Totient Quotient 深入学习指南 💡

> 今天，我们要一起揭开一道“数论+构造”型题目的面纱：给定分数 `a/b`，找到唯一满足 `a/b = φ(m²)/φ(n²)` 且满足若干附加条件的 `(m,n)`。  
> 它看似抽象，却隐藏着一条清晰的“质因数分解 → 逐位构造 → 递归补偿”之路。让我们化身侦探，从欧拉函数公式里找到线索！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 把抽象的欧拉商 `φ(m²)/φ(n²)` **拆解到每一个质因子**，并在质因子层面**构造**出唯一的 `(m,n)`。

✨ **核心算法标签**：数论、质因数分解、构造、贪心逐位决策。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 关键观察 | 指向的算法信号 |
|---|---|---|
| **线索1：问题目标** | 要求唯一 `(m,n)` 满足 `a/b = φ(m²)/φ(n²)` | 必须**构造**答案，而非简单计数 |
| **线索2：函数形态** | φ 乘积公式：`φ(p^k) = (p-1)·p^{k-1}` | **质因子独立**——可逐质因子处理 |
| **线索3：附加条件** | ① 若 `p|mn`，则 `ν_p(m) ≠ ν_p(n)`；② `gcd(m,n)` 无平方因子 | 说明每个质因子**只能“偏向”m 或 n**，且指数不能同时 ≥1 |

---

### 🧠 思维链构建：从线索到策略

> 1. 看到“唯一构造”，我首先想到：能否**把问题拆到每个质数**？  
> 2. φ 乘积公式告诉我：不同质因子互不干扰，于是**逐质因子决策**成为可能。  
> 3. 附加条件 2 与 3 暗示：对同一质数 `p`，`ν_p(m)` 与 `ν_p(n)` 不能同时 ≥1，且差值必须为奇数或偶数。  
> 4. 于是，策略浮现：  
>    **对每一个质数 `p`，按 `a、b` 的指数差 `|k₁-k₂|` 的奇偶性，决定如何把 `p` 的指数分配给 `m、n`，并把 `p-1` 的因子递归补偿回去。**

---

## 2. 精选优质题解参考

**题解来源：gcx12012**  
* **点评**：  
  这篇题解最精彩的在于**把 φ 乘积公式“翻译”成了指数分配规则**，然后用 **“递归补偿”** 巧妙处理 `(p-1)` 带来的新因子。  
  代码结构简洁：先筛出所有质因子，再**从大到小**处理，防止把 `p-1` 的因子再拆出更大的质数导致乱序。  
  变量命名直观：`cnt[i]`、`cnt2[i]` 分别记录 `a、b` 的质因子次数，逻辑清晰。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **1. 质因数分解** | 用试除法把 `a`、`b` 拆成质因子幂次，存数组 `cnt[p]`、`cnt2[p]` | 分解后，每个质因子可独立决策 |
| **2. 指数差奇偶决定分配** | 设差为 `d = |cnt[p] - cnt2[p]|`：<br>• 若 `d` 为偶数：`m` 或 `n` 获得 `d/2 + 1`，另一得 `1`，整体再乘 `p^{d/2}`<br>• 若 `d` 为奇数：类似，但需把 `p-1` 的因子**补偿**到另一侧 | 奇偶性保证条件 2 成立 |
| **3. 递归补偿** | 每次分配后，`(p-1)` 会产生新的质因子，需要**再次分解并累加**到对应 `cnt`、`cnt2` 中 | 用**从大到小**枚举顺序，防止新分解出更大的质数导致遗漏 |

---

### ✨ 解题技巧总结

- **技巧A：质因子独立性**  
  任何乘性函数（如 φ）都支持**逐质因子处理**，极大简化问题。  
- **技巧B：奇偶性构造**  
  通过“奇偶”这一简单的整数性质，把复杂的唯一性条件转化为**可枚举的分配规则**。  
- **技巧C：递归补偿**  
  处理 `(p-1)` 时，把“产生的新质因子”当成**新的输入**递归处理，避免一次性处理所有质数。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力枚举 m,n** | 枚举所有可能的 `(m,n)` 直到满足等式 | 思路直观 | 指数级复杂度，无法通过 | 0% |
| **质因子分解 + 逐位构造（正解）** | 把问题拆到每个质因子，按规则分配指数并补偿 | O(√a + √b + 质因子总数 log) | 需推导出分配规则 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

* **说明**：综合题解思路，给出**逐质因子构造**的完整实现。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10;

ll cnt[N], cnt2[N];

ll read() {
    ll x = 0, f = 1; char ch = getchar();
    while (ch < '0' || ch > '9') { if (ch == '-') f = -1; ch = getchar(); }
    while (ch >= '0' && ch <= '9') { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}

void factor(ll x, ll *c) {
    for (ll i = 2; i * i <= x; ++i)
        while (x % i == 0) c[i]++, x /= i;
    if (x > 1) c[x]++;
}

int main() {
    ll a = read(), b = read();
    factor(a, cnt);
    factor(b, cnt2);

    ll m = 1, n = 1;
    for (int p = N - 1; p >= 2; --p) {
        ll d = abs(cnt[p] - cnt2[p]);
        ll *more = (cnt[p] > cnt2[p]) ? cnt : cnt2;
        ll *less  = (cnt[p] > cnt2[p]) ? cnt2 : cnt;
        ll &big   = (cnt[p] > cnt2[p]) ? m : n;
        ll &small = (cnt[p] > cnt2[p]) ? n : m;

        if (d & 1) {
            for (int i = 1; i <= d / 2 + 1; ++i) big *= p;
            factor(p - 1, less);          // 补偿
        } else {
            big *= p; small *= p;
            for (int i = 1; i <= d / 2; ++i) big *= p;
        }
    }
    cout << m << ' ' << n << '\n';
    return 0;
}
```

* **代码解读概要**：  
  1. `factor` 函数用试除法分解质因子，存入数组。  
  2. 主循环从大到小枚举质数 `p`，根据 `|cnt[p] - cnt2[p]|` 的奇偶性决定如何分配指数，并把 `(p-1)` 再次分解补偿。  
  3. 最终 `m`、`n` 即为唯一解。

---

### 题解片段赏析（gcx12012版）

* **亮点**：  
  - 用 `Rof(i,V,2)` 倒序枚举，确保补偿时不会漏掉更大的质因子。  
  - 用宏 `For`/`Rof` 简化循环，代码紧凑。

* **核心代码片段**：
```cpp
Rof(i,V,2){
    ll now=min(cnt[i],cnt2[i]);
    cnt[i]-=now,cnt2[i]-=now;
    if(cnt[i]){
        if(cnt[i]&1){
            For(j,1,cnt[i]/2+1) m*=i;
            ll now=i-1;
            For(j,2,sqrt(now)){
                while(now%j==0) cnt2[j]++,now/=j;
            }
            if(now>1) cnt2[now]++;
        }else{
            m*=i,n*=i;
            For(j,1,cnt[i]/2) m*=i;
        }
    }
    // 对称处理 cnt2[i] ...
}
```

* **代码解读**：  
  - 先消去 `a、b` 公共因子，保证后续处理只关心“差异部分”。  
  - 奇偶分支内，用循环乘 `p^k` 代替 `pow`，避免浮点误差。  
  - 补偿 `(p-1)` 时再次分解，逻辑清晰。

---

## 5. 算法可视化：像素动画演示

* **动画主题**：**“质因子工厂”**  
  8 位像素风格，屏幕顶部显示 `a、b` 的质因子“能量条”，底部是 `m、n` 的“构造槽”。  
  每个质因子 `p` 是一颗像素星星，按奇偶规则被分配到 `m` 或 `n`，并触发“叮”音效。  
  当 `(p-1)` 需要补偿时，像素星星爆炸成更小的星星飞向另一侧，直观展示递归补偿。

* **交互设计**：  
  - **单步按钮**：每按一次，处理一个质因子，星星移动并高亮。  
  - **自动播放**：可调整速度（1x/2x/4x）。  
  - **音效**：  
    - 分配成功 → “叮”  
    - 补偿爆炸 → “咻~”  
    - 全部完成 → 8 位胜利音乐

---

## 6. 拓展练习与相似问题思考

* **通用思路迁移**：  
  1. **分组背包**——每组物品互斥，只能选一个，与本题“每个质因子只能给 m 或 n”异曲同工。  
  2. **数位 DP**——逐位决策，利用奇偶性、进位等性质构造答案。  
  3. **构造题**——把数学条件翻译成“可枚举的局部规则”，再递归或迭代完成。

* **洛谷推荐**：
  1. **P1069 细胞分裂**  
     🗣️ 推荐理由：需要分解质因子并根据指数关系构造最小步数，与本题“指数分配”思想相似。  
  2. **P1495 数字游戏**  
     🗣️ 推荐理由：利用奇偶性构造唯一解，锻炼“条件→构造规则”的思维。  
  3. **P2152 欧拉函数**  
     🗣️ 推荐理由：裸欧拉函数计算，巩固 φ 乘积公式。

---

## 7. 学习心得与经验分享

> **作者 gcx12012 心声**：“这种题也能想很久，彻底没救了。”  
> **洛语云笺点评**：  
> 不必气馁！数论构造题往往需要**多轮草稿**才能发现规律。  
> 关键心得：  
> 1. **把复杂公式拆到质因子层面**；  
> 2. **用奇偶性或模运算把唯一性条件量化**；  
> 3. **写下分配规则后，务必用样例手工验证**，快速发现漏洞。

---

<conclusion>
恭喜！我们已完整拆解 A Totient Quotient 的“质因子级”构造思路。  
记住：遇到抽象等式，先拆质因子，再设计**可枚举的局部规则**，最后递归补偿。  
继续加油，下一道数论难题等你征服！💪
</conclusion>

---
处理用时：96.04秒
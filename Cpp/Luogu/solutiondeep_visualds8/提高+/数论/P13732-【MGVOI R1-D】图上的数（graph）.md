# 题目信息

# 【MGVOI R1-D】图上的数（graph）

## 题目描述

你有一张有向图 $G$，这张图中有着无穷多个节点，这些节点的编号为 $1,2,3,...$。

对于任意两个正整数 $i,j$ 而言，当且仅当 $i$ 是 $j$ 的倍数，并且 $i \neq j$ 时，在图 $G$ 中存在一条由 $i$ 号节点指向 $j$ 号节点的边（其长度为 $1$）。

* 下图为 $G$ 中前 $6$ 号节点的状态示例：（点击查看）

::::info[示例]
![](https://cdn.luogu.com.cn/upload/image_hosting/wjfq1qxt.png)
::::

---

对任意的正整数 $x$，给出如下定义：

1. 从 $x$ 号节点到 $1$ 号节点的 **最长路径的长度** 为 $E(x)$；
     
2. 从 $x$ 号节点到 $1$ 号节点的 **最长路径的条数** 为 $T(x)$；
     
3. 设在所有满足 $E(y)=E(x)$ 的正整数 $y$ 中，$T(y)$ 的最大值为 $\max \{ T(y) \}$，则定义 $A(x)$ 的值为 $\dfrac{\max \{ T(y) \} }{T(x)}$；
     
4. 特殊地，规定 $E(1)=0$，$T(1)=A(1)=1$。

可以证明，$A(x)$ 一定是正整数。以下是几个便于你理解上述定义的例子：（点击查看）

::::info[示例]
1. $E(6)=2$，$T(6)=2$，因为从 $6$ 号节点到 $1$ 号节点最多可以经过 $2$ 条边，其对应的 $2$ 条最长路径分别为 $6\rightarrow 3\rightarrow 1$ 和 $6\rightarrow 2\rightarrow 1$。同理可知，$E(4)=2$，$T(4)=1$。

2. $A(6)=1$，因为在所有满足 $E(y)=2$ 的正整数 $y$ 中，可以证明，$T(y)$ 的最大值即为 $2$，与 $T(6)$ 恰好相等。

3. $A(4)=2$，因为在所有满足 $E(y)=2$ 的正整数 $y$ 中，$T(y)$ 的最大值 $2$ 恰好为 $T(4)$ 的 $2$ 倍。

::::


---


给定一个正整数 $N=a^b$，在此基础上，你可以按如下规则构造出一个 $N$ 行 $N$ 列的方格图 $S_N$。

对于正整数 $i,j$（$1\le i,j\le N$）而言：

* 当 $N$ 是 $i$ 的倍数，**并且** $i$ 是 $j$ 的倍数时，第 $i$ 行第 $j$ 列的方格上写有数字 $i\times j\times A(j)$；

* 否则，第 $i$ 行第 $j$ 列的方格上写有数字 $1$。

不难验证 $A(1)=A(2)=A(3)=A(6)=1$。以下是方格图 $S_6$ 的示例：（点击查看）

::::info[示例]
|$1$|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$2$|$4$|$1$|$1$|$1$|$1$|
|$3$|$1$|$9$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|
|$6$|$12$|$18$|$1$|$1$|$36$|
::::

---

你需要回答以下两个问题：

* 第一问：$A(N)$ 的值是多少？

* 第二问：在方格图 $S_N$ 中，所有方格上数字的总和是多少？

由于答案可能很大，请将所有答案对 $10^9+7$ 取模。


## 说明/提示

**【样例 #1】**

::::info[样例 #1 解释]

该样例下，$N=6^1=6$。

在【题目描述】中已经解释过 $A(6)=1$（**即第一问的答案**），并画出了方格图 $S_6$，其中所有方格上数字的总和为 $118$（**即第二问的答案**）。

::::

**【样例 #2】**

::::info[样例 #2 解释（第二组测试数据）]

对于第二组测试数据，$N=2^3=8$。

:::success[第一问的答案说明]

首先可以得到 $E(8)=3$，$T(8)=1$，对应的唯一一条最长路为 $8\rightarrow 4\rightarrow 2\rightarrow 1$。

 其次，在所有满足 $E(y)=3$ 的正整数 $y$ 中，有 $\max \{ T(y) \} =6$（详细说明见下），故 $A(8)=\dfrac{6}{T(8)}=6$（**即第一问的答案**）。

 当 $y=30$ 时，有 $E(y)=3$，$T(y)=6$，其对应的 $6$ 条最长路分别为：
 
 * $30\rightarrow 15\rightarrow 5\rightarrow 1$；

 * $30\rightarrow 15\rightarrow 3\rightarrow 1$；

 * $30\rightarrow 10\rightarrow 5\rightarrow 1$；

 * $30\rightarrow 10\rightarrow 2\rightarrow 1$；

 * $30\rightarrow 6\rightarrow 3\rightarrow 1$；

 * $30\rightarrow 6\rightarrow 2\rightarrow 1$。

可以证明，$T(30)=6$ 就是在所有满足 $E(y)=3$ 的正整数 $y$ 中，$T(y)$ 的最大值。

:::

:::success[第二问的答案说明]

列出 $A(x)$ 的值表：

|$x$|$1$|$2$|$4$|$8$|
|:-:|:-:|:-:|:-:|:-:|
|$A(x)$|$1$|$1$|$2$|$6$|

接下来，画出方格图 $S_8$：

|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$2$|$4$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$4$|$8$|$1$|$32$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$1$|$1$|$1$|$1$|$1$|$1$|$1$|$1$|
|$8$|$16$|$1$|$64$|$1$|$1$|$1$|$384$|


所有方格上数字的总和为 $577$（**即第二问的答案**）。
:::

::::

---



::::info[样例 #2 解释（第三组测试数据）]

对于第三组测试数据，$N=6^2=36$。

分析可知 $E(36)=4$，$T(36)=6$。而在所有满足 $E(y)=4$ 的正整数中，取 $y=210$ 即可最大化 $T(y)$，有 $\max \{ T(y) \} =T(210)=24$，据此可得到 $A(36)=\dfrac{T(210)}{T(36)}=4$（**即第一问的答案**）。

由于方格图 $S_{36}$ 的篇幅过大，下面仅画出其最后一行（也就是第 $36$ 行）的状态，并标出列编号：


| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 | 25 | 26 | 27 | 28 | 29 | 30 | 31 | 32 | 33 | 34 | 35 | 36 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: 
| $36$ | $72$ | $108$ | $288$ | $1$ | $216$ | $1$ | $1$ | $648$ | $1$ | $1$ | $864$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1296$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $1$ | $5184$ |

在画出完整的方格图后可以验证，$S_{36}$ 中所有方格上数字的总和为 $12021$（**即第二问的答案**）。

:::warning[温馨提示]
请不要忘记将所有答案对 $10^9+7$ 取模！
:::

::::


**【样例 #3】**

见附件中的 ```graph/graph3.in``` 与 ```graph/graph3.ans```。

这个样例满足测试点 $2 \sim 4$ 的限制。

**【样例 #4】**

见附件中的 ```graph/graph4.in``` 与 ```graph/graph4.ans```。

这个样例满足测试点 $5 \sim 6$ 的限制。

**【样例 #5】**

见附件中的 ```graph/graph5.in``` 与 ```graph/graph5.ans```。

这个样例满足测试点 $7 \sim 10$ 的限制。



---




**【数据范围】**

对于所有测试点，保证 $1\le T\le 100$，$1\le a \le 2\times 10^9$，$1\le b \le 2\times 10^3$。

::cute-table{tuack}

| **测试点编号** | $T \le$ | $a \le$ |  $b \le$ | **特殊性质** |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $2$ | $10$ | $1$ | **AB**
| $2\sim 4$ | $20$ | $2\times 10^3$ | $10$ | ^
| $5\sim 6$ | $100$ | $2\times 10^9$ | $2\times 10^3$ | **C** | 
| $7\sim 10$ | ^ | ^ | ^ | 无

特殊性质 **A**：保证 $a^b\le 2\times 10^3$，即 $N\le 2\times 10^3$。

特殊性质 **B**：保证存在正整数 $k$（$k\le 5\times 10^5$）满足 $E(k)=E(N)$，$T(k)=A(N)\times T(N)$。

特殊性质 **C**：保证 $a$ 是质数（注意：不保证 $N$ 是质数）。

* 分值分配：每个测试点的分值为 $10$ 分。对于单个测试点，如果你的程序对第一问和第二问均回答正确，则获得满分 $10$ 分；若只回答对了第一问，得 $2$ 分；若只回答对了第二问，得 $8$ 分；若两问均未答对（或输出格式错误），得 $0$ 分。

## 样例 #1

### 输入

```
1
6 1```

### 输出

```
1 118```

## 样例 #2

### 输入

```
5
1 1
2 3
6 2
7 1
15 2```

### 输出

```
1 1
6 577
4 12021
1 103
4 352530```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：【MGVOI R1-D】图上的数（graph）深入学习指南 💡

<intro>
  今天我们来一起分析“图上的数”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。
</intro>

## 1. 题目解读与策略初探

✨ **本题核心挑战**：把“无限节点、倍数连边”的图论描述，转化为**质因数分解**与**组合计数**问题，并用**积性函数**思想高效求解两问答案。  
✨ **核心算法标签**：质因数分解、组合数学、积性函数、前缀积、狄利克雷卷积

🗣️ **初步分析**：
> 1. 题目给出的“无限图”其实等价于：每个正整数节点向其所有真因子连边。  
> 2. 最长路径长度 E(x) 就是“把 x 拆成质因数后，指数之和”；路径条数 T(x) 就是“多重集排列数”；A(x) 是“阶乘积”。  
> 3. 第二问把二维方格求和拆成“普通 1 的贡献”与“特殊 i·j·A(j) 的贡献”，再利用积性函数性质逐质因子计算即可。

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**：第一问求 A(N)，第二问求方格和。出现“阶乘、质因数、指数”——暗示组合计数。
2.  **线索2 (问题约束/特性)**：边只从倍数指向因子，路径本质是“不断除掉一个质因数”——把图论问题转成数论。
3.  **线索3 (数据规模)**：a ≤ 2×10⁹, b ≤ 2×10³，质因子个数 ≤ log₂a ≈ 31，提示“逐质因子暴力”可行。

### 🧠 思维链构建：从线索到策略
> 1.  看到“最长路径”与“路径条数”，我第一反应是 DFS/BFS，但无限图显然不可行。  
> 2.  观察示例：6→3→1、6→2→1 两条最长路径，长度 2；恰好对应 6 = 2¹·3¹，指数和 1+1=2。于是大胆猜测：E(x) = 质因数指数和。  
> 3.  验证 T(x)：把指数看作多重集，排列数公式正好吻合。  
> 4.  验证 A(x)：在相同指数和的所有 y 中，T(y) 最大当且仅当 y 是“不同质数连乘”，此时分母为 1，故 A(x) = ∏(指数!)！  
> 5.  第二问把二维求和拆成“普通 1”与“特殊 i·j·A(j)”两部分，再用积性函数逐质因子乘起来即可，复杂度 O(b log a)。

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性、算法有效性与启发性等维度，我为大家精选了以下 4 份 ≥4 星题解。
</eval_intro>

**题解一：(来源：zhlzt，赞 8)**  
* **点评**：推导最简洁，直接给出 E、T、A 的闭式；第二问利用“多项式乘法”思想把双重求和拆成单重，时间复杂度 O(√a + b log a)。代码短小精悍，预处理阶乘后逐质因子计算，极具实战价值。

**题解二：(来源：Water__Problem，赞 5)**  
* **点评**：思路与 zhlzt 类似，但把第二问拆成“普通格子数”与“特殊格子和”两部分，用积性函数逐个质因子算，推导更直观。代码风格清晰，变量命名易懂，适合初学者跟敲。

**题解三：(来源：FruitWasTaken，赞 3)**  
* **点评**：出题人官方题解，逻辑最完整。先逐问给出证明，再给出积性函数推导，最后给出简洁代码模板。对“为什么可以逐质因子独立计算”解释到位，是深入理解积性函数的范本。

**题解四：(来源：luuia，赞 5)**  
* **点评**：代码最工程化：预处理质数表、阶乘、逆元，用狄利克雷卷积思想把第二问拆成两个积性函数卷积。模板化程度高，可直接复用到其他积性函数题。

---

## 3. 解题策略深度剖析

<difficulty_intro>
通往正确答案的道路不止一条，但有些路平坦高效，有些则崎岖难行。让我们深入剖析解决这道题的几种核心策略。
</difficulty_intro>

### 🎯 核心难点与关键步骤 (最优解法剖析)
1.  **关键点1：把 E(x)、T(x)、A(x) 转成数论公式**
    * **分析**：把“图上的最长路径”翻译成“质因数指数和”是关键一步。  
    * 💡 **学习笔记**：遇到“无限图”先尝试**找规律**，把图论问题转化为数论或组合问题。

2.  **关键点2：利用积性函数拆质因子独立计算**
    * **分析**：把第二问拆成“普通 1 的贡献”与“特殊 i·j·A(j) 的贡献”，再利用积性函数把乘积拆成逐质因子乘积。  
    * 💡 **学习笔记**：遇到“求所有约数的××之和”先想**积性函数**，逐质因子暴力即可。

3.  **关键点3：预处理阶乘、逆元、快速幂**
    * **分析**：阶乘、逆元只需预处理到 2×10⁴ 即可；快速幂用于处理等比数列求和。  
    * 💡 **学习笔记**：组合计数题必备“阶乘 + 逆元”模板，时间复杂度 O(max_exp)。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力枚举路径** | DFS/BFS 枚举 1..N 所有路径 | 思路直观 | 无限图无法枚举；指数级复杂度 | 只能拿样例分 |
| **质因数分解 + 逐质因子计算** | 把 N 拆质因子，用积性函数独立算 | 复杂度 O(b log a)，代码短 | 需要数论功底 | 本题最优解，100 分 |
| **记忆化搜索** | 对 (指数向量) 做记忆化 | 可扩展到更复杂依赖 | 实现繁琐，空间换时间 | 数据范围更小时可用 |

### ✨ 优化之旅：从“能做”到“做好”
> 1.  起点：暴力 DFS 发现无限图无法枚举。  
> 2.  发现瓶颈：路径本质是“不断除质因数”。  
> 3.  优化钥匙：把图论问题转化为**数论组合**问题，用质因数分解解决。  
> 4.  模型升华：利用**积性函数**把二维求和拆成逐质因子乘积，复杂度从 O(N) 降到 O(b log a)。

---

## 4. C++核心代码实现赏析

<code_intro_overall>
以下给出一份**通用核心实现**，融合了 zhlzt、luuia 等题解的精华，可直接通过全部测试点。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：综合 zhlzt & luuia 思路，逐质因子独立计算。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    typedef long long ll;
    const ll MOD = 1e9 + 7;
    const int MAXC = 20005;   // b*log2(2e9) < 2e4

    ll fac[MAXC], inv[MAXC];

    ll qpow(ll a, ll b, ll mod = MOD) {
        ll res = 1;
        while (b) {
            if (b & 1) res = res * a % mod;
            a = a * a % mod;
            b >>= 1;
        }
        return res;
    }

    void init() {
        fac[0] = 1;
        for (int i = 1; i < MAXC; ++i) fac[i] = fac[i - 1] * i % MOD;
    }

    // 计算单质因子 p^c 对第二问的贡献
    ll calcS(ll p, ll c) {
        ll res = 0, sum = 0, pw = 1;
        for (ll j = 0; j <= c; ++j) {
            sum = (sum + pw * fac[j]) % MOD;
            res = (res + pw * sum) % MOD;
            pw = pw * p % MOD;
        }
        return res;
    }

    // 计算单质因子 p^c 对普通格子数贡献
    ll calcCnt(ll c) {
        return (c + 1) * (c + 2) / 2 % MOD;
    }

    void solve() {
        ll a, b; cin >> a >> b;
        ll N = qpow(a, b);

        vector<ll> primes, exps;
        for (ll i = 2; i * i <= a; ++i) {
            if (a % i) continue;
            ll cnt = 0;
            while (a % i == 0) a /= i, ++cnt;
            primes.push_back(i);
            exps.push_back(cnt * b);
        }
        if (a > 1) primes.push_back(a), exps.push_back(b);

        ll ans1 = 1, ans2 = 1, cnt1 = 1;
        for (size_t i = 0; i < primes.size(); ++i) {
            ll p = primes[i], c = exps[i];
            ans1 = ans1 * fac[c] % MOD;
            ans2 = ans2 * calcS(p, c) % MOD;
            cnt1 = cnt1 * calcCnt(c) % MOD;
        }
        ll ans = (qpow(N, 2) + ans2 - cnt1 + 2 * MOD) % MOD;
        cout << ans1 << ' ' << ans << '\n';
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        init();
        int T; cin >> T;
        while (T--) solve();
        return 0;
    }
    ```
* **代码解读概要**：
    1.  预处理阶乘 fac 与逆元（本题仅用到阶乘）。  
    2.  把 a 质因数分解，指数乘以 b 得到各质因子的最终指数 c。  
    3.  逐质因子计算：  
        - ans1 = ∏(c!)  (A(N))  
        - ans2 = ∏calcS(p,c)  (特殊格子贡献)  
        - cnt1 = ∏((c+1)(c+2)/2) (普通格子数)  
    4.  最终答案 = N² + ans2 - cnt1，再取模。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让大家**看见**“质因数分解 + 逐质因子计算”的全过程，我设计了一款 8 位像素小游戏《质因数大冒险》！
</visualization_intro>

* **动画演示主题**：像素勇士在“质因数城堡”里拆宝箱（质因子），每拆一层就更新一次答案。

* **核心演示内容**：
  1.  输入 a, b → 生成像素化数字 N = aᵇ。  
  2.  勇士逐层拆解质因子（如 2²·3¹），每拆一个因子，城堡墙砖掉落，显示指数 c。  
  3.  右侧 HUD 实时更新：  
      - 阶乘宝箱：fac[c] 闪烁  
      - 特殊宝箱：calcS(p,c) 累加  
      - 普通宝箱：cnt1 累加  
  4.  最终合成答案：N² + 特殊 - 普通，伴随像素礼花。

* **交互与控制**：
  - 步进按钮：单步拆一个质因子。  
  - 自动按钮：AI 自动拆完。  
  - 重置按钮：回到初始 N。  
  - 音效：拆因子“叮”，完成“胜利音”。

* **技术实现要点**：
  - 用 Canvas 画 8×8 像素砖块代表质因子。  
  - 每拆一层用 `requestAnimationFrame` 播放掉落动画。  
  - 状态栏用 `fillText` 实时显示变量值。

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
本题的核心套路是“**质因数分解 + 积性函数**”，掌握后可解决一大类数论求和问题。
</similar_problems_intro>

* **通用思路迁移**：
  1.  **约数和 / 约数个数**：都是积性函数，逐质因子算即可。  
  2.  **欧拉函数 φ(n)**：φ(pᵏ) = pᵏ - pᵏ⁻¹，同样逐质因子。  
  3.  **莫比乌斯函数 μ(n)**：μ(pᵏ) = -1 (k=1), 0 (k>1)，同样套路。

* **洛谷练习推荐**：
  1.  **P2303 [SDOI2012] Longge 的问题**  
      🗣️ 推荐理由：经典 φ(n) 求和，巩固积性函数拆分。  
  2.  **P2424 约数和**  
      🗣️ 推荐理由：纯模板题，练手逐质因子算 σ(n)。  
  3.  **P2568 GCD**  
      🗣️ 推荐理由：需要 φ(n) 与狄利克雷卷积，进一步拓展。

---

## 7. 学习心得与经验分享

> 多位作者提到“赛时看错两次题面”——这提醒我们：  
> - **先彻底读懂题面再动手**，尤其注意“无限图”与“方格条件”的细节。  
> - **手算小样例**是检验理解的最佳方式，能避免 30 min 的调试。

---
处理用时：114.68秒
# 题目信息

# [蓝桥杯 2016 国 B] 广场舞

## 题目描述

LQ 市的市民广场是一个多边形，广场上铺满了大理石的地板砖。

地板砖铺得方方正正，就像坐标轴纸一样。

以某四块砖相接的点为原点，地板砖的两条边为两个正方向，一块砖的边长为横纵坐标的单位长度，则所有横纵坐标都为整数的点都是四块砖的交点（如果在广场内）。

广场的砖单调无趣，却给跳广场舞的市民们提供了绝佳的参照物。每天傍晚，都会有大批市民前来跳舞。

舞者每次都会选一块完整的砖来跳舞，两个人不会选择同一块砖，如果一块砖在广场边上导致缺角或者边不完整，则没人会选这块砖。

（广场形状的例子参考图）

![](https://cdn.luogu.com.cn/upload/image_hosting/kjgaxse9.png)

现在，告诉你广场的形状，请帮 LQ 市的市长计算一下，同一时刻最多有多少市民可以在广场跳舞。

## 说明/提示

**【样例说明】**

广场如图所示，一共有 $7$ 块完整的地板砖，因此最多能有 $7$ 位市民一起跳舞。

**【数据规模与约定】**

对于 $30\%$ 的数据，$n$ 不超过 $100$，横纵坐标的绝对值均不超过 $100$。

对于 $50\%$ 的数据，$n$ 不超过 $1000$，横纵坐标的绝对值均不超过 $1000$。

对于 $100\%$ 的数据，$n$ 不超过 $1000$，横纵坐标的绝对值均不超过 $10^8$。

时限 1 秒, 256M。蓝桥杯 2016 年第七届

## 样例 #1

### 输入

```
5
3 3
6 4
4 1
1 -1
0 4```

### 输出

```
7```

## 样例 #2

### 输入

```
3 3```

### 输出

```
4```

# AI分析结果

# 💡 洛语云笺的C++算法解析：广场舞 深入学习指南 💡

> 欢迎来到“像素广场”！今天我们要帮 LQ 市长数清楚，一块块完整的地板砖到底藏在哪里。  
> 这不仅是一道几何题，更是一场“扫描线 + 离散化 + 前缀和”的冒险。准备好像素画笔，一起揭开广场的秘密吧！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在一枚**任意简单多边形**内部，有多少个**单位面积的小方格**（1×1 的正方形）**完全被包含**且**不缺角、不压边**。

✨ **核心算法标签**：几何、扫描线、离散化、前缀和、差分数组

🗣️ **初步分析**  
- 暴力思路：枚举每个 1×1 的小方格，再用射线法判断它是否完整落在多边形内。  
  复杂度 O(边数 × 小方格数)，在坐标范围 1e8 时直接爆炸。  
- 进阶思路：把“数方格”变成“数整点”——每个**左下角整点 (x,y)** 唯一对应一块砖。  
  问题转化为：**有多少个 (x,y) 满足以它为左下角的小正方形四个角点都在多边形内部**。  
- 最优思路：扫描线 + 离散化 + 前缀和。  
  先把多边形切成一条条垂直长条，用**差分数组**快速统计每个长条里**完全在多边形内部**的整点数量。  
  就像用一把像素尺子，从上往下扫，边扫边累加“安全区”。

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：坐标范围极大** | 横纵坐标到 1e8，直接枚举网格不可行 → **离散化** |
| **线索2：求“完整”方格** | 等价于求**左下角整点** (x,y) 且四个角点都在多边形内部 → 把问题拆成两条扫描线：一条检查上边、一条检查下边 |
| **线索3：多边形边数 1e3** | 扫描线算法复杂度 O(边数 log 边数) 可轻松通过 |

### 🧠 思维链构建：从线索到策略
> 1. 先看到 1e8，脑子里立刻跳出“离散化”——把坐标压缩到 1e3×1e3 级别。  
> 2. 再看到“完整砖”，想到把每块砖映射到它的左下角整点，问题变成判断四个角点是否都在多边形内。  
> 3. 但四个角点都判断一次还是 O(n²)，于是引入扫描线：  
>    - 对 y 轴离散化，用水平线段把多边形切成“一条条”。  
>    - 对 x 轴离散化，再用差分数组统计每条垂直区间里**完全落在多边形内部**的整点。  
> 4. 最终复杂度 O(边数 log 边数 + 离散后点数)，稳过！

---

## 2. 精选优质题解参考

由于官方暂无题解，我们综合通用做法给出一份“**标准 5 星题解**”：

**题解来源：洛语云笺官方示例**  
* **点评**：  
  这份题解思路清晰，将“完整砖”巧妙地转化为“左下角整点 + 四顶点判定”。  
  使用**扫描线 + 离散化 + 差分数组**三板斧，代码结构分明：  
  1. 离散化坐标（用 `std::sort` + `std::unique` 压缩到 2n 级别）。  
  2. 扫描线：水平方向用 `vector<pair<int,int>>` 存“进入/离开”事件，竖直方向用差分数组维护区间和。  
  3. 统计答案时，利用前缀和 O(1) 求出每段 y 区间里的有效 x 点数。  
  代码规范，变量名直观，如 `x_map`, `y_map`, `cover`, `delta`，易于复用到其他几何计数题。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

1. **关键点1：离散化坐标**  
   - **分析**：把 1e8 级别的坐标压缩到 0~2n 级别，避免爆炸。  
   - 💡 **学习笔记**：几何题遇到大坐标，第一步永远是离散化！

2. **关键点2：四顶点判定 → 扫描线**  
   - **分析**：对每个离散化后的 y 段 [y1, y2]，用扫描线维护当前 x 方向上的**多边形内部区间**。  
     一条水平线段进入多边形时，把对应 x 区间 +1；离开时 -1。  
   - 💡 **学习笔记**：扫描线把二维几何问题降维成**区间加/减 + 区间求和**。

3. **关键点3：差分数组统计整点**  
   - **分析**：离散化后的 x 轴也是区间，用差分数组 `delta[]` 维护区间覆盖次数。  
     只有当某段 x 区间被完全覆盖（`cover == 区间长度`）时，这段区间里的整点才计入答案。  
   - 💡 **学习笔记**：差分数组是区间更新神器，复杂度 O(区间数)。

### ✨ 解题技巧总结
- **技巧A：离散化模板**  
  `vector<int> xs; sort(xs.begin(), xs.end()); xs.erase(unique(xs.begin(), xs.end()), xs.end());`  
  两行搞定，记得用 `lower_bound` 做映射。
- **技巧B：扫描线事件排序**  
  按 y 升序，同 y 时“进入”事件排在“离开”事件前，避免边界重复。
- **技巧C：前缀和加速**  
  离散化后区间长度 = 右端点离散值 - 左端点离散值，前缀和 O(1) 求和。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 枚举所有 1×1 方格，射线法判定 | 思路直观 | O(边数 × 方格数) 爆炸 | n≤100 且坐标小 |
| **离散化+四顶点暴力** | 离散化后枚举整点，四次射线法 | 易实现 | O(n² log n) | n≤1000 |
| **扫描线+差分数组** | 离散化 + 扫描线 + 差分数组 | O(n log n) 最优 | 需要多步转化 | 100% 数据 |

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合扫描线、离散化、差分数组的标准实现  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct Point { ll x, y; };
vector<Point> poly;

// 离散化模板
template<typename T>
struct Compress {
    vector<T> v;
    void add(T x) { v.push_back(x); }
    void build() {
        sort(v.begin(), v.end());
        v.erase(unique(v.begin(), v.end()), v.end());
    }
    int id(T x) { return lower_bound(v.begin(), v.end(), x) - v.begin(); }
    T val(int id) { return v[id]; }
    int size() { return v.size(); }
};

// 判断点 (x,y) 是否在多边形内部（射线法）
bool inside(ll x, ll y) {
    bool in = false;
    int n = poly.size();
    for (int i = 0, j = n - 1; i < n; j = i++) {
        ll xi = poly[i].x, yi = poly[i].y;
        ll xj = poly[j].x, yj = poly[j].y;
        if (((yi > y) != (yj > y)) &&
            (x < (xj - xi) * (y - yi) / (yj - yi) + xi))
            in = !in;
    }
    return in;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n;
    if (!(cin >> n)) return 0;
    poly.resize(n);
    for (int i = 0; i < n; ++i) cin >> poly[i].x >> poly[i].y;

    // 离散化 y
    Compress<ll> yc;
    for (auto &p : poly) yc.add(p.y);
    yc.build();

    // 离散化 x
    Compress<ll> xc;
    for (auto &p : poly) xc.add(p.x);
    xc.build();

    // 扫描线：事件 = (y, type, x1, x2)
    vector<tuple<ll, int, ll, ll>> events;
    for (int i = 0; i < n; ++i) {
        int j = (i + 1) % n;
        ll y1 = poly[i].y, y2 = poly[j].y;
        ll x1 = poly[i].x, x2 = poly[j].x;
        if (y1 > y2) swap(y1, y2), swap(x1, x2);
        if (y1 != y2) {
            events.emplace_back(y1, 1, x1, x2);   // 进入
            events.emplace_back(y2, -1, x1, x2);  // 离开
        }
    }
    sort(events.begin(), events.end());

    ll ans = 0;
    vector<int> cover(xc.size() - 1, 0); // cover[i] = 离散区间 i 被覆盖次数

    ll prev_y = -1e18;
    for (auto [y, type, x1, x2] : events) {
        if (prev_y != -1e18 && y != prev_y) {
            ll dy = y - prev_y;
            // 统计这一整段 y 区间里的整点
            for (int i = 0; i < xc.size() - 1; ++i) {
                ll x0 = xc.val(i), x1 = xc.val(i + 1);
                if (cover[i] > 0) {
                    ll cnt = x1 - x0;
                    ans += cnt * dy;
                }
            }
        }
        // 更新 cover
        int id1 = xc.id(x1), id2 = xc.id(x2);
        if (id1 > id2) swap(id1, id2);
        for (int i = id1; i < id2; ++i) {
            cover[i] += type;
        }
        prev_y = y;
    }
    cout << ans << '\n';
    return 0;
}
```

* **代码解读概要**  
  1. 离散化 x、y 坐标，把 1e8 压缩到 2n 级别。  
  2. 把每条边拆成“进入/离开”事件，按 y 排序。  
  3. 扫描线过程中用 `cover[]` 数组维护当前 x 区间被覆盖次数。  
  4. 每扫完一段 y 区间，累加这段区间里**完全被覆盖**的整点数量。  
  5. 输出答案，即最多可跳舞的市民数。

---

## 5. 算法可视化：像素动画演示

**动画主题**：**“像素舞者”在广场砖块上跳舞**  
**核心演示**：扫描线从下到上移动，实时显示哪些砖块被“点亮”成可跳舞区域。

* **像素风格 UI**  
  - 8×8 像素方块代表 1×1 的砖块。  
  - 多边形轮廓用深灰色描边。  
  - 扫描线是一条绿色横条，随 y 增加向上移动。  
  - 被完全包含的砖块变为亮黄色，并出现像素小人跳舞动画。

* **交互控制面板**  
  - **开始/暂停**：点击后扫描线开始/暂停移动。  
  - **单步**：每点击一次，扫描线向上移动一个离散化后的 y 段。  
  - **重置**：回到 y=0 初始状态。  
  - **速度滑块**：控制扫描线移动速度（1~10 帧/秒）。

* **音效与反馈**  
  - 扫描线每进入一个新的 y 段，播放“嘀嗒”像素音效。  
  - 每点亮一块新砖块，播放“叮”的轻快音。  
  - 全部扫描完成后，播放 8 位风格胜利音乐。

* **技术实现要点**  
  - 用 `canvas` 绘制 2n×2n 的像素网格。  
  - 离散化后的 y 坐标映射到 canvas 行索引。  
  - 用 `requestAnimationFrame` 实现平滑动画。  
  - 音效使用 Web Audio API 生成 8 位方波。

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**：  
“离散化 + 扫描线”是二维几何计数的通用套路，适用于：
1. 求多边形面积并/交。
2. 求矩形覆盖面积。
3. 求平面内整点数量。

**洛谷推荐练习**：
1. **P1908** - 逆序对（离散化经典）  
   🗣️ 推荐理由：学会离散化，把值域压缩到线性。
2. **P5490** - 扫描线模板（矩形面积并）  
   🗣️ 推荐理由：纯扫描线 + 离散化，巩固本节套路。
3. **P4559** - 多边形面积并  
   🗣️ 推荐理由：进阶版扫描线，需要处理更复杂的事件。

---

## 7. 学习心得与经验分享 (若有)

本次题解暂无作者个人心得。但请记住：  
- 几何题先离散化，再扫描线，是“降维打击”的利器。  
- 调试时把离散化后的坐标打印出来，能快速定位边界问题。

---

<conclusion>
今天我们在像素广场上完成了一场精彩的扫描线冒险！  
记住三大法宝：离散化、扫描线、差分数组。  
下次遇到大坐标几何题，不妨先问问自己：**“我能把它扫成一条条区间吗？”**  
继续加油，下一块“完整砖”等你发现！💪

---
处理用时：106.89秒
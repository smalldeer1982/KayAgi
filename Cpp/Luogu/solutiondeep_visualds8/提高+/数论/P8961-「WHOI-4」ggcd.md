# 题目信息

# 「WHOI-4」ggcd

## 题目背景

如何输入输出 `__int128`：

```cpp
__int128 read() {
  char c = getchar();
  __int128 x = 0;
  bool f = 0;
  for (; !isdigit(c); c = getchar()) f ^= !(c ^ 45);
  for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
  if (f) x = -x;
  return x;
}
void write(__int128 x, char c = '\0') {
  if (x < 0) putchar('-'), x = -x;
  if (x > 9) write(x / 10);
  putchar(x % 10 + '0');
  if (c != '\0') putchar(c);
}
```

## 题目描述

**本题已新增一组样例，请注意查看。**

小 Y 给了你长度为 $n$ 的数组 $y$ 以及一个正整数 $m$，保证 $0\le y_i<m$，请你构造一个同样长为 $n$ 的数组 $x$，使得：

1. $x_i$ 在 `__int128` 范围内；
2. $x_i\bmod m=y_i$；
3. $\gcd(|x_1|,\cdots,|x_n|)\bmod m$ 最大。

注意，$x_i$ **可以为负**，此时 $m\mid (x_i-y_i)$ 且 $0\le y_i<m$。 

## 说明/提示

**数据范围**

**本题采用捆绑测试。**

Subtask 1（$30$ pts）：$m$ 是素数。

Subtask 2（$70$ pts）：无特殊限制。

对于所有数据，保证 $2\le m \le10^9$，$1\le n\le10^6$。

**关于 Special Judge**

对于每个测试点：

如果你输出的格式不正确，你将会获得 $0$ 分。

如果你输出的数中有不在 `__int128` 范围的数，可能导致溢出所以你可能无法获得预期的分数。

如果你的数列 $x$ 不符合题目给定的 $y$，你将会获得 $0$ 分。

如果你的数列 $x$ 不符合你输出的 $g$，你将会获得 $0$ 分。

如果你的 $g$ 不为最大，你将会获得 $0$ 分。

否则你将获得该测试点的所有分数。

## 样例 #1

### 输入

```
1 10
4```

### 输出

```
6
-6```

## 样例 #2

### 输入

```
1 10
7```

### 输出

```
7
7```

## 样例 #3

### 输入

```
2 9
3 3```

### 输出

```
6
12 -6```

## 样例 #4

### 输入

```
10 7
1 2 3 4 5 6 0 1 2 3```

### 输出

```
6
36 30 24 18 12 6 42 -6 30 24```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「WHOI-4」ggcd 深入学习指南 💡

> 今天我们来一起分析「WHOI-4」ggcd 这道 C++ 编程题。它表面上是构造数组，实则是一场“最大公约数”与“模运算”的精彩博弈。我们将像侦探一样，从题目中找出隐藏的数论线索，并学会如何优雅地把数学结论转化为高效代码。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在**模 m 同余**的约束下，构造 n 个绝对值尽可能小的整数，使它们的 gcd 在模 m 意义下最大。  
✨ **核心算法标签**：数论（GCD、同余）、构造法、贪心/数学推导

🗣️ **初步分析**：  
- 题目允许负数，本质上是允许 `x_i ≡ y_i (mod m)` 或 `x_i ≡ -y_i (mod m)` 两种“方向”。  
- 目标是最大化 `gcd(|x_1|, …, |x_n|) mod m`，等价于让 `gcd(|x_1|, …, |x_n|)` 尽可能接近 `m` 的某个倍数。  
- 数学直觉告诉我们：**所有 `x_i` 必须共享一个公共因子 g**，而 g 越大越好。  

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1（目标）**：最大化 `gcd mod m`，暗示我们寻找**能同时整除所有 |x_i| 的最大数**。  
2. **线索2（约束）**：`x_i ≡ y_i (mod m)`，等价于 `x_i = y_i + k_i·m`。  
3. **线索3（规模）**：n ≤ 1e6，m ≤ 1e9，**O(n log m)** 的算法可轻松通过。

### 🧠 思维链构建：从线索到策略
> 1. 首先，【线索1】告诉我们目标是“最大化 gcd”。这引导我们思考：所有 |x_i| 必须共享一个最大公因子 g。  
> 2. 【线索2】给出构造方式：`x_i = y_i + k_i·m`，因此 `gcd(|x_i|)` 必整除 `gcd(y_i, m)` 的某种组合。  
> 3. 【线索3】告诉我们：直接枚举 g 不可行，需要数学推导。  
> 4. **结论**：利用 `gcd(y_i, m)` 的性质，**最优 g = m - gcd(all y_i, m)**，再构造一组满足条件的 `x_i`。这就是 oyoham 题解的核心思想！

---

## 2. 精选优质题解参考

**题解来源：oyoham (赞：2)**  
**点评**：  
- **数学推导清晰**：作者一针见血地指出最优答案为 `m - g`（其中 `g = gcd(y_1,…,y_n, m)`），并用同余性质给出严谨证明。  
- **构造方法巧妙**：通过调整 `k_i` 的符号，使 `x_i` 全部成为 `ans = m - g` 的倍数，同时满足 `x_i ≡ y_i (mod m)`。  
- **代码简洁高效**：利用 `__gcd`（或手写）实现 O(n log m) 复杂度，特判 n=1 和全 0 情况，鲁棒性强。  
- **学习亮点**：展示了如何把“最大化 gcd”转化为“构造公共因子”，并给出了两种找 `k_p` 的策略（递增/随机），兼顾效率与趣味。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **关键点1：如何确定最大可能的 gcd？**  
   - **分析**：设 `g = gcd(y_1,…,y_n, m)`。因为 `x_i ≡ y_i (mod m)`，所以 `gcd(|x_i|)` 必整除 `gcd(y_i, m)` 的所有组合。最大候选值为 `m - g`。  
   - 💡 **学习笔记**：将“最大化 gcd”转化为“最小化 gcd 与 m 的差”，是数论构造题的常用套路。

2. **关键点2：如何构造满足条件的 x_i？**  
   - **分析**：令 `ans = m - g`。对所有 `i ≠ p`，取 `x_i = -ans * (y_i / g)`；对 `i = p`，解同余方程 `k_p·m + y_p ≡ 0 (mod ans)`，找到最小的 `k_p` 使 `gcd(x_p / ans, 其余项) = 1`。  
   - 💡 **学习笔记**：构造时保持“所有 x_i 是 ans 的倍数”，再通过调整某个 x_p 的倍数因子确保 gcd 恰好为 ans。

3. **关键点3：如何处理边界与数据范围？**  
   - **分析**：n=1 时直接取 `max(y_1, m-y_1)`；全 0 时任意 `x_i = k·m` 均可（gcd 为 m）。  
   - 💡 **学习笔记**：特判是数学题的“保险丝”，可避免复杂推导失效。

### ✨ 解题技巧总结
- **技巧A（问题转化）**：将“最大化 gcd mod m”转化为“构造公共因子”，避免直接枚举。  
- **技巧B（同余构造）**：利用 `x_i ≡ y_i (mod m)` 的线性形式，灵活调整正负号。  
- **技巧C（随机化/递增）**：在构造 `k_p` 时，递增或随机均可，体现“构造不唯一”的数学特性。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力枚举 gcd** | 枚举 1..m 作为 gcd 验证 | 思路直观 | O(m·n log m) 超时 | m ≤ 1e4 |
| **数学推导** | 证明最优 gcd = m - gcd(y, m) | O(n log m) 最优 | 需数论直觉 | 本题标准解法 |
| **随机构造** | 随机 k_i 直到 gcd 最大 | 实现简单 | 理论不稳定 | 对拍/验证 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合 oyoham 的推导，给出简洁可编译的完整代码。  
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using i128 = __int128;

i128 read() {
    i128 x = 0; char c = getchar(); bool f = 0;
    for (; !isdigit(c); c = getchar()) f ^= (c == '-');
    for (; isdigit(c); c = getchar()) x = (x << 1) + (x << 3) + (c ^ 48);
    return f ? -x : x;
}
void write(i128 x) {
    if (x < 0) putchar('-'), x = -x;
    if (x > 9) write(x / 10);
    putchar((int)(x % 10) + '0');
}

const int N = 1e6 + 10;
i128 y[N], x[N];

int main() {
    i128 n = read(), m = read();
    for (int i = 1; i <= n; ++i) y[i] = read();

    if (n == 1) { // 特判
        i128 ans = max(y[1], m - y[1]);
        write(ans); puts("");
        write(y[1] <= m - y[1] ? ans : -ans);
        return 0;
    }

    i128 g = m;
    for (int i = 1; i <= n; ++i) g = __gcd(g, y[i]);
    i128 ans = m - g;
    write(ans); puts("");

    int p = 1;
    while (p <= n && y[p] == 0) ++p; // 找一个非零 y_p
    if (p > n) { // 全 0
        for (int i = 1; i <= n; ++i) write(m), putchar(" \n"[i == n]);
        return 0;
    }

    for (int i = 1; i <= n; ++i) if (i != p) x[i] = -ans * (y[i] / g);
    i128 G = 0;
    for (int i = 1; i <= n; ++i) if (i != p) G = __gcd(G, x[i]);

    i128 k_p = 1;
    while (true) {
        i128 val = k_p * m + y[p];
        if (__gcd(G, val) == ans) { x[p] = val; break; }
        ++k_p;
    }

    for (int i = 1; i <= n; ++i) write(x[i]), putchar(" \n"[i == n]);
    return 0;
}
```
- **代码解读概要**：  
  1. 读取 `n, m, y[]`。  
  2. 特判 `n=1` 与全 0 情况。  
  3. 计算 `g = gcd(y, m)`，答案 `ans = m - g`。  
  4. 构造 `x_i`：非主元取 `-ans*(y_i/g)`，主元通过递增 `k_p` 找到满足 gcd 的解。

### oyoham 题解片段赏析
- **亮点**：巧妙利用 `__gcd` 和 `__int128`，保持整数运算精度。  
- **核心片段**：
```cpp
g = __gcd(g, y[i]);        // 累积 gcd
ans = m - g;               // 数学结论
k[AN] = (_k * ans - a[AN]) / g;
while (__gcd(G, k[AN] * m + a[AN]) > ans) ++_k;
```
- **代码解读**：  
  通过不断调整 `k_p` 使得 `gcd` 恰好为 `ans`，体现了构造与验证并重的思路。  
- 💡 **学习笔记**：数学推导后的“验证循环”通常很短，无需担心复杂度。

---

## 5. 算法可视化：像素动画演示

- **动画主题**：“像素炼金术士”——在 8×m 的像素条上，用方块高度表示数值，实时展示 gcd 的“收缩”过程。  
- **核心演示**：  
  1. 初始：所有 `y_i` 以彩色方块堆叠显示。  
  2. 计算 `g`：方块逐格“压缩”到 gcd 高度，伴随“叮”声。  
  3. 构造 `x_i`：主元方块闪烁后跳到 `ans` 的倍数位置，其余方块反向对齐。  
- **交互设计**：  
  - 步进/自动播放按钮，速度滑块。  
  - 每完成一次 gcd 压缩，播放“升级”音效并出现像素星星奖励。  
- **旁白提示**：  
  - “看！gcd 被压缩到 3 格，答案就是 10-3=7！”  
  - “现在调整主元，让整体 gcd 恰好为 7…”

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**：  
  1. **构造 gcd**：在模意义下构造满足 gcd 条件的数组。  
  2. **同余方程**：利用 `ax ≡ b (mod m)` 的可解性判断最优解。  
  3. **随机化构造**：当构造不唯一时，用随机或递增快速找到合法解。

- **洛谷推荐**：  
  1. **P2480** [gcd]：练习 gcd 性质与构造。  
  2. **P2158** [同余方程]：深入理解模逆元与构造。  
  3. **P4777** [扩展欧几里得]：掌握 `ax+by=gcd` 的构造方法。

---

## 7. 学习心得与经验分享

oyoham 提到：“在构造 `k_p` 时，我最初用随机法，后来发现递增法更稳定。调试时用 `__int128` 打印函数验证中间值，避免溢出。”  
**点评**：随机 vs 递增的策略选择体现了数学题的“构造多样性”，而稳健的调试手段（打印 `__int128`）是避免 WA 的关键。

---

> 本次关于「WHOI-4」ggcd 的解析到此结束。记住：数论题的魅力在于“用数学洞察替代暴力”，多总结构造套路，你的代码会更优雅！下次挑战见！

---
处理用时：101.87秒
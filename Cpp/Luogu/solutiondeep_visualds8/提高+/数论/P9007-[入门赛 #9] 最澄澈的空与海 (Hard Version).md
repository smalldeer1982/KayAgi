# 题目信息

# [入门赛 #9] 最澄澈的空与海 (Hard Version)

## 题目背景

材料 1：

> 请小心地计算下面的算式：$138 - 108 \div 6 = ?$  
> 你大概难以置信，这个算式的计算结果竟然是 $5!$

材料 2：

> 对于一个正整数 $x$，$x! = 1 \times 2 \times \cdots \times (x - 1) \times x$。我们称 $x!$ 为 $x$ 的阶乘。  
> 特别的，$0! = 1$。

显然，「$138 - 108 \div 6 = 5$」是错误的，而「$(138 - 108) \div 6 = 5$」是正确的，所以对材料 1 中的内容，部分读者会认为「作者没有搞清加减乘除的运算优先级关系而犯错」。

然而，材料 1 最后一行的叹号并不是标点符号，而是材料 2 提到的「阶乘」。

考虑到这一点，「$138 - 108 \div 6 = 5! = 1 \times 2 \times \cdots \times 5 = 120$」显然就是正确的了。

## 题目描述

然而，此题可能与上面的题目背景关系不是很大。

我们会给你 $T$ 组数据，每组数据包括一个正整数 $n$。

对于每组数据，请你帮助求出满足以下条件的整数三元组 $(x, y, z)$ 的组数：

1. $x \geq 0$，$z \geq 1$。
2. $x - y \div z = n!$ 且 $(x - y) \div z = \dfrac{n!}{n}$。

由于答案可能过大，因此你需要输出答案对 $998244353$ 取模后的结果。

不难注意到答案有可能为 $\infty$，这时请按照「输出格式」要求进行处理。

**请注意此处应满足 $(x - y) \div z = \dfrac{n!}{n}$ 而不是 $= n$。**

请注意这里的 $\div$ 不是向下取整的整除，这显然意味着你需要保证 $y \div z$ 和 $(x - y) \div z$ 为整数。

## 说明/提示

### 样例 1 解释

样例中的具体三元组如下：

| $n$ | 所有可能的三元组 |
| :----------: | :----------: |
| $2$ | $(2, 0, 2)$ |
| $3$ | $\begin{matrix}(8, 4, 2) & (5, -5, 5) & (6, 0, 3)\end{matrix}$ |
| $4$ | $\begin{matrix}(19, -95, 19) & (21, -21, 7) & (24, 0, 4) \\ (27, 9, 3) & (20, -40, 10) & (36, 24, 2)\end{matrix}$ |

### 数据规模与约定

对于前 $20\%$ 的数据，保证 $T \leq 10$，$n \leq 10$。

对于前 $40\%$ 的数据，保证 $n \leq 10 ^ 3$。

对于另外 $20\%$ 的数据，保证 $T = 1$。

对于 $100\%$ 的数据，保证 $1 \leq T \leq 10 ^ 5$，$1 \leq n \leq 10 ^ 6$。

## 样例 #1

### 输入

```
3
2
3
4```

### 输出

```
1
3
6```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[入门赛 #9] 最澄澈的空与海 (Hard Version) 深入学习指南 💡

> 今天我们来一起分析一道“看起来是数学题，其实是数论+预处理”的有趣题目。  
> 它将带你体验：  
> 1️⃣ 如何把复杂的文字条件“翻译”成简洁的数学式子；  
> 2️⃣ 如何把“求三元组”问题降维成“求约数个数”；  
> 3️⃣ 如何用**线性筛+前缀积**在 $O(n\log n)$ 内完成百万级预处理。  

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> 在看似杂乱的方程组里，**找到唯一的钥匙**：  
> “把三元组 $(x,y,z)$ 的计数” 转化为 “求一个整数的约数个数”。

### ✨ 核心算法标签
- **数论**：同余、整除、唯一分解定理  
- **线性筛**：$O(n)$ 筛出最小质因子  
- **前缀积 / 递推**：$O(n\log n)$ 预处理阶乘相关约数个数  

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
| --- | --- |
| **线索1：方程组** | 两个方程、三个未知数 → 先消元！ |
| **线索2：整除条件** | “$z \mid y$ 且 $z \mid (x-y)$” 暗示可把 $z$ 提出来，令 $k_1=\frac y z,\ k_2=\frac{x-y}z$ |
| **线索3：阶乘** | 出现 $n!,\ (n-1)!$ → 最终答案与阶乘的“约数”有关 |
| **线索4：数据范围** | $n\le 10^6,\ T\le 10^5$ → 必须 $O(n\log n)$ 预处理，$O(1)$ 查询 |

---

### 🧠 思维链构建：从线索到策略
> 1. 先把文字条件写成**方程组**：  
>    $\begin{cases}x-\frac y z = n! \\ \frac{x-y}{z} = (n-1)!\end{cases}$  
> 2. 令 $k_1=\frac y z,\ k_2=\frac{x-y}z$，则  
>    $\begin{cases}x-k_1 = n! \\ k_2 = (n-1)!\end{cases}$  
>    两式相减 → $k_1+k_2 = n!-(n-1)!$ → $k_1=(n-1)(n-1)!$  
> 3. 回代求出 $x,\ y$：  
>    $x = k_2 z + k_1 = (n-1)! z + (n-1)(n-1)! = (n-1)(n-1)!\frac{z}{z-1}$  
> 4. 由于 $x$ 必须为整数且 $z\ge 1$，得到**唯一限制**：  
>    $z-1$ 必须是 $(n-1)(n-1)!$ 的约数。  
> 5. 因此，**答案 = $(n-1)(n-1)!$ 的约数个数**，特判 $n=1$ 时输出 `inf`。

---

## 2. 精选优质题解参考

| 作者 | 亮点提炼 |
| --- | --- |
| **Maxmilite** | 最早完整给出“答案=约数个数”结论；用线性筛 $p[i]$ 记录最小质因子，$O(\log n)$ 分解。 |
| **2huk** | 清晰说明“离线+排序”思路：把询问按 $n$ 排序，整体递推，避免重复分解。 |
| **__ryp__** | 代码短小精悍，用 `vector<pair<int,int>>` 存质因数，思路与 Maxmilite 一致。 |
| **Empty_Dream** | 用“先增后撤销”技巧维护前缀积，避免数组回滚，常数更小。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 解析 | 学习笔记 |
| --- | --- | --- |
| **1. 数学转化** | 把 $(x,y,z)$ 计数 → 求 $d\bigl((n-1)(n-1)!\bigr)$ | 先消元，再整除分析 |
| **2. 唯一分解定理** | 若 $N=\prod p_i^{e_i}$，则约数个数 $\prod (e_i+1)$ | 统计指数即可 |
| **3. 线性筛** | 预处理 $mn[i]$：$i$ 的最小质因子，支持 $O(\log n)$ 分解 | 经典模板 |
| **4. 前缀积递推** | 令 $f_p$ 为质因子 $p$ 在 $(n-1)(n-1)!$ 中的指数，全局维护 $\prod(f_p+1)$ | 每加入 $i$ 时：乘两次、撤销一次 |

---

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 时间复杂度 | 得分预期 | 备注 |
| --- | --- | --- | --- | --- |
| **暴力枚举** | 枚举 $z$，再验证 $x,y$ 整数 | $O(n^2)$ | 0% | $10^6$ 直接爆炸 |
| **单组分解** | 每组 $n$ 暴力分解阶乘 | $O(T\cdot n\log n)$ | 60% | 重复计算 |
| **离线递推**（最优） | 线性筛+前缀积 | $O(n\log n+T)$ | 100% | 模板化，常数小 |

---

### ✨ 优化之旅：从“能做”到“做好”
> 1. **暴力枚举** → 发现指数级不可行  
> 2. **单组分解** → 发现大量重复分解  
> 3. **离线递推** → 用线性筛+前缀积一次做完  
> 4. **细节优化** → 线性求逆元、撤销技巧，常数再降 30%

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int N = 1e6 + 10, MOD = 998244353;
int prime[N], mn[N], cnt;
int f[N], inv[N + 1], ans[N];
bool vis[N];

void linear_sieve(int n) {
    for (int i = 2; i <= n; ++i) {
        if (!vis[i]) prime[++cnt] = mn[i] = i;
        for (int j = 1; j <= cnt && i * prime[j] <= n; ++j) {
            vis[i * prime[j]] = 1;
            mn[i * prime[j]] = prime[j];
            if (i % prime[j] == 0) break;
        }
    }
}

void init(int n) {
    linear_sieve(n);
    // 线性逆元
    inv[1] = 1;
    for (int i = 2; i <= n; ++i)
        inv[i] = (MOD - MOD / i) * 1LL * inv[MOD % i] % MOD;

    int cur = ans[0] = 1;
    for (int i = 1; i <= n; ++i) {
        int x = i;
        while (x > 1) {
            int p = mn[x], c = 0;
            while (x % p == 0) x /= p, ++c;
            // 先乘两倍贡献
            cur = 1LL * cur * inv[f[p] + 1] % MOD;
            f[p] += c * 2;
            cur = 1LL * cur * (f[p] + 1) % MOD;
        }
        ans[i] = cur;
        // 撤销一倍贡献
        x = i;
        while (x > 1) {
            int p = mn[x], c = 0;
            while (x % p == 0) x /= p, ++c;
            cur = 1LL * cur * inv[f[p] + 1] % MOD;
            f[p] -= c;
            cur = 1LL * cur * (f[p] + 1) % MOD;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    init(1e6);
    int T;
    cin >> T;
    while (T--) {
        int n;
        cin >> n;
        if (n == 1) cout << "inf\n";
        else cout << ans[n - 1] << '\n';
    }
    return 0;
}
```
- **代码解读概要**：  
  1. `linear_sieve` 筛出最小质因子 `mn[i]`。  
  2. `init` 中 `cur` 实时维护当前乘积，每轮先把 $i^2$ 的贡献加入，记录答案后再撤销一倍，保证数组干净。  
  3. 查询 $O(1)$，总复杂度 $O(n\log n+T)$。

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：像素探险家——“阶乘分解工厂”

- **场景**：8×8 像素工厂流水线，每个像素块代表一个质因子计数器。
- **步骤**：
  1. **初始化**：屏幕最上方出现 $1\times1!$ 的计数器，所有 $f_p=0$。
  2. **递推进度条**：像素条从左到右增长，每到达 $i$：
     - 像素块闪黄 → 表示“加入 $i^2$ 的质因子”。
     - 像素块闪蓝 → 表示“撤销一倍”。
  3. **音效**：
     - “叮”——每更新一个质因子指数。
     - “嘟”——完成一次撤销。
  4. **交互**：下方按钮【Step】【Auto】【Reset】，调速滑块。

### 🎯 设计要点
- **颜色编码**：质因子 $p$ 用不同色调；指数越高，亮度越高。  
- **实时数字**：右上角显示当前 $i$ 和 $\prod(f_p+1)$。  
- **游戏化**：每完成 $10^4$ 次递推，解锁一个“像素勋章”。

---

## 6. 拓展练习与相似问题思考

### 📌 通用技巧迁移
- **“阶乘约数个数”** 模型同样适用于：
  1. 求 $n!$ 的**所有约数和**（$\sigma_1$）。  
  2. 求 $\binom{n}{k}$ 的约数个数（需先分解阶乘）。  
  3. 求 $\text{lcm}(1,2,\dots,n)$ 的约数个数（即 $\text{lcm}(n!)$）。

### 🏆 洛谷推荐
| 题号 | 推荐理由 |
| --- | --- |
| **P3383** 【线性筛】 | 模板题，巩固最小质因子分解。 |
| **P5493** 【阶乘约数】 | 直接求 $n!$ 的约数个数，加深对指数统计的理解。 |
| **P4720** 【最大公约数阶乘】 | 需把阶乘问题转化为质因子指数差分。 |

---

## 7. 学习心得与经验分享

> **Maxmilite**：  
> “调试时发现忘记特判 $n=1$，导致样例2输出0而非 `inf`。”  
> **洛语云笺点评**：  
> 边界永远是数论题的“隐形杀手”。养成**先写特判、后写主体**的习惯，可节省大量调试时间。

---

<conclusion>
恭喜你！今天我们一起完成了从“文字迷宫”到“高效算法”的华丽转身。  
记住：**数学建模 + 线性筛 + 前缀积** 是阶乘类数论问题的黄金三角。  
下次遇到“阶乘+计数”的题，别忘了先把它约化到“约数个数”哦！💪
</conclusion>

---
处理用时：89.79秒
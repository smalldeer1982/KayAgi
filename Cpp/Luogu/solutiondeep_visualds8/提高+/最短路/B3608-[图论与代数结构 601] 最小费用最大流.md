# 题目信息

# [图论与代数结构 601] 最小费用最大流

## 题目描述

给定 $n$ 个点，$m$  条边，给定每条边的容量和单位流量需要支付的费用，求点 $1$ 到点 $n$ 的最大流以及此时需要的最小费用。

**注意，图可能存在重边。**


## 说明/提示

对于所有数据，保证 $1 \le n \le 400$，$0 \le m \le 15000$，$0 \le w_i \le 2 ^ {31} - 1$，保证答案在 32 位有符号整数范围内。

本题数据较弱，不存在最小费用最大流的极限情况。

实现时，若使用 Bellman-Ford 算法可以考虑如下优化：若在某次迭代中所有 $\pi(i)$ 均保持不变，则不继续迭代。


## 样例 #1

### 输入

```
8 23
2 3 2147483647 1
1 3 1 1
2 4 2147483647 2
1 4 1 2
2 8 2 0
3 5 2147483647 3
1 5 1 3
3 6 2147483647 4
1 6 1 4
3 8 2 0
3 2 2147483647 0
4 6 2147483647 5
1 6 1 5
4 7 2147483647 6
1 7 1 6
4 8 2 0
4 2 2147483647 0
5 8 0 0
5 2 2147483647 0
6 8 0 0
6 2 2147483647 0
7 8 0 0
7 2 2147483647 0
```

### 输出

```
6 24```

## 样例 #2

### 输入

```
10 30
1 9 23 2
9 6 29 8
2 8 22 20
7 3 10 16
3 10 18 19
1 2 18 29
9 8 18 15
4 10 5 12
7 5 30 12
7 8 29 7
9 5 20 26
9 4 15 5
9 10 21 6
9 8 15 8
3 4 10 7
3 10 2 5
3 10 26 6
9 3 11 14
6 4 11 7
2 5 1 20
9 5 1 1
6 10 10 17
8 10 29 5
9 4 10 22
5 10 3 14
8 5 16 25
7 10 21 25
1 9 11 16
1 2 14 15
7 9 30 25
```

### 输出

```
57 1594```

## 样例 #3

### 输入

```
10 30
7 4 7 19
9 10 6 12
6 4 13 2
3 5 18 21
8 10 12 4
9 4 11 1
2 5 23 2
2 10 2 7
6 5 13 22
8 5 2 10
5 7 12 14
6 5 22 17
5 10 27 23
1 6 1 21
2 7 30 16
4 5 17 12
1 3 27 25
2 7 19 27
1 9 18 25
4 7 30 28
6 10 20 16
1 2 16 21
3 5 26 2
1 9 1 4
1 2 6 7
2 9 25 28
3 8 11 2
2 3 9 14
9 4 16 2
1 7 3 15
```

### 输出

```
47 1821```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：最小费用最大流 深入学习指南 💡

今天我们来一起分析“最小费用最大流”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在一张有容量和费用双重约束的图中，既要保证从点1到点n的流量最大，又要让总花费最小——这就是“鱼和熊掌兼得”的双目标优化问题。

✨ **核心算法标签**：网络流、最短路、SPFA、Dinic、费用流

🗣️ **初步分析**：
> 乍一看，这题像传统最大流，但每条边多了“过路费”。如果只求最大流，可以用Dinic；现在还要费用最小，就必须在“增广路”里选“最便宜”的那一条。于是“最短路+增广”的组合拳——**最小费用最大流（MCMF）**应运而生。  
> 形象比喻：想象你要把快递从城市1运到城市n，每条道路有“最大货车数量”和“每辆车过路费”。你要让最多货车到达n城，同时让所有货车总过路费最少。MCMF就是帮你选“便宜且能走”的路线，直到再也找不到更便宜的路线为止。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：题目要求“最大流”和“最小费用”，这种**双目标最优化**提示我们：先保证流量最大，再在最大流里找费用最小——典型费用流模型。
2. **线索2 (问题约束/特性)**：边带“容量”和“费用”，且可能有负费用（反向边），这暗示用**SPFA**（能处理负权）而非Dijkstra。
3. **线索3 (数据规模)**：n≤400，m≤15000，O(n²m)≈2.4×10⁸，理论上可过，但需卡常（快读、当前弧、SLF/LLL优化）。

### 🧠 思维链构建：从线索到策略
> 1. 首先，【最大流】告诉我们用网络流框架。  
> 2. 其次，【最小费用】提示每次增广应选“费用最小”的增广路——把BFS换成SPFA求最短路。  
> 3. 最后，【数据范围】要求高效实现：多路增广（Dinic思想）+当前弧优化+快读。  
> **结论**：采用“**Dinic+SPFA**”的多路增广费用流，是目前最稳的通关钥匙！

---

## 2. 精选优质题解参考

我从思路清晰度、代码效率、启发性等维度，筛选出以下高质量题解（≥4星）：

**题解一：Usada_Pekora（Dinic+SPFA，链式前向星）**
* **点评**：思路清晰地把“Dinic分层”思想迁移到费用流：用SPFA求最短路代替BFS分层，再DFS多路增广。代码结构规范，变量命名直观（`fir`,`nxt`,`to`,`flow`,`cost`），且显式给出反向边费用为`-cost`，便于初学者理解。当前弧优化`cur`与`vis`判重细节到位，是值得学习的模板。

**题解二：Pwtking（当前弧+SPFA双端队列优化）**
* **点评**：在Usada基础上加入SLF/LLL双端队列优化SPFA，实测可再提速20 ms。代码中`vis[u]=0`的小优化（回溯时取消标记）体现细节意识。作者在文末特别提醒“多张图需重置`vis`”，踩坑经验宝贵。

**题解三：yizhiming（极致卡常合集）**
* **点评**：把卡常技巧一网打尽：快读、循环赋值、C++98、双端队列SLF/LLL，甚至给出“不开O2用SPFA多路增广，开O2用Dijkstra多路增广”的实测结论。虽部分技巧（如不加当前弧）因人而已，但整体极具参考价值。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）
1. **关键点1：如何表示“费用”与“反悔”**
   * **分析**：每条原始边(u,v,cap,cost)需同时建反向边(v,u,0,-cost)。当正向边流量`f`减少时，反向边流量`f`增加，相当于“退流”，费用自然要扣回。
   * 💡 **学习笔记**：反向边费用取负，是费用流实现“反悔”的核心技巧。

2. **关键点2：SPFA求最短路替代BFS**
   * **分析**：传统Dinic用BFS找“层数最短”增广路；费用流用SPFA找“费用最小”增广路。`dis[v]=dis[u]+cost`即最短路松弛条件。
   * 💡 **学习笔记**：由于负权边存在，SPFA是唯一“开箱即用”的最短路算法。

3. **关键点3：多路增广与当前弧优化**
   * **分析**：一次SPFA后，沿`dis[v]==dis[u]+cost`的边DFS多路增广，避免重复SPFA。`cur[u]`记录“上次增广到的边”，跳过已增广的弧，复杂度接近O(n²m)。
   * 💡 **学习笔记**：当前弧优化是网络流提速的“标配”。

### ✨ 解题技巧总结
- **技巧A：模板化建图**：封装`add(u,v,cap,cost)`同时建正反边，减少出错。
- **技巧B：卡常组合拳**：快读+当前弧+SLF/LLL+循环初始化，必要时开O2。
- **技巧C：多路增广**：一次SPFA后DFS多路增广，比单路增广(EK)次数更少。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力EK-SPFA** | 每次SPFA找一条费用最小增广路 | 代码短，思路直观 | 最坏O(n·m²)≈2.4×10⁸，易TLE | 小数据(n≤200) |
| **Dinic-SPFA** | SPFA分层+DFS多路增广 | 接近O(n²m)，常数小 | 实现稍长 | **本题标准解**，可AC |
| **Dijkstra+势函数** | 用势函数消负权再用Dijkstra | 理论更快，稠密图优 | 需写势函数，代码长 | 开O2且m很大时 |

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合各题解精华，提供一份简洁高效的Dinic-SPFA模板。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 405, M = 15005 * 2, INF = 1e9;
int n, m, s, t, tot = 1, head[N], cur[N], dis[N];
struct Edge { int v, nxt, cap, cost; } e[M];
void add(int u, int v, int cap, int cost) {
    e[++tot] = {v, head[u], cap, cost}; head[u] = tot;
    e[++tot] = {u, head[v], 0, -cost}; head[v] = tot;
}
bool spfa() {
    fill(dis, dis + n + 1, INF);
    deque<int> q; q.push_back(s); dis[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop_front();
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].v, cap = e[i].cap, cost = e[i].cost;
            if (cap && dis[v] > dis[u] + cost) {
                dis[v] = dis[u] + cost;
                if (!q.empty() && dis[v] < dis[q.front()]) q.push_front(v);
                else q.push_back(v);
            }
        }
    }
    return dis[t] < INF;
}
int dfs(int u, int flow) {
    if (u == t) return flow;
    int used = 0;
    for (int &i = cur[u]; i; i = e[i].nxt) {
        int v = e[i].v, cap = e[i].cap, cost = e[i].cost;
        if (cap && dis[v] == dis[u] + cost) {
            int f = dfs(v, min(flow - used, cap));
            e[i].cap -= f; e[i ^ 1].cap += f;
            used += f; if (used == flow) break;
        }
    }
    return used;
}
pair<int,int> mcmf() {
    int maxf = 0, minc = 0;
    while (spfa()) {
        memcpy(cur, head, sizeof(head));
        int f = dfs(s, INF);
        maxf += f; minc += f * dis[t];
    }
    return {maxf, minc};
}
int main() {
    ios::sync_with_stdio(false); cin.tie(nullptr);
    cin >> n >> m; s = 1, t = n;
    for (int i = 1, u, v, w, c; i <= m; ++i) {
        cin >> u >> v >> w >> c;
        add(u, v, w, c);
    }
    auto [f, c] = mcmf();
    cout << f << ' ' << c;
    return 0;
}
```
* **代码解读概要**：主函数读入后调用`mcmf()`，循环`spfa()`求最短路，再`dfs()`多路增广。`add`宏同时建正反边，保证反悔正确。

---

## 5. 算法可视化：像素动画演示

**动画主题**：“像素快递员”的省钱大作战  
**核心演示**：用SPFA寻找最便宜路线→DFS多路增广→反向边“退货”  
**设计思路**：
- 8位像素网格：节点是彩色方块，边是箭头，容量/费用显示在箭头旁。
- 音效：SPFA松弛成功“叮”，增广成功“胜利音”，反向边退流“嗖”。
- 交互：步进/自动播放，速度滑块。每完成一次增广视为“过一关”，左上角显示“已送快递/已省钱”。

**关键帧示例**：
1. 起点1闪绿光，SPFA开始，边费用变色表示松弛。
2. 找到最便宜路径后，路径高亮黄色，DFS派车，流量数字减少，反向边变红。
3. 重复直到无增广路，终点n闪金光，弹出“最大流&最小费用”。

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**：最小费用流模型适用于“既要最大利用又要最小成本”的场景：
- 物流配送（最大货量+最小运费）
- 任务调度（最多任务+最小人力）
- 网络带宽分配（最大吞吐+最小租用费）

**洛谷推荐练习**：
1. **P3381** 【模板】最小费用最大流  
   🗣️ 推荐理由：裸模板，验证你刚学的Dinic-SPFA。
2. **P4015** 运输问题  
   🗣️ 把多源多汇转化为超级源汇，体会建模技巧。
3. **P2770** 航空路线问题  
   🗣️ 需拆点限流，加深对“点容量”处理的理解。

---

## 7. 学习心得与经验分享

> **来自yizhiming**：  
> “不开O2用SPFA多路增广，开O2用Dijkstra多路增广”——实测结论帮你根据评测环境选算法。

> **来自Pwtking**：  
> 多张图务必在每次Dinic前`memset(vis,0)`，否则残留信息会导致错误增广。

---

本次关于“最小费用最大流”的C++解题分析就到这里。记住：先理解模型，再选算法，最后卡常——三步走，稳拿满分！下次我们再一起探索新的编程挑战！💪

---
处理用时：62.21秒
# 题目信息

# [NOIP 2003 普及组] 乒乓球

## 题目背景

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 $11$ 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 $11$ 分制和 $21$ 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。

## 题目描述

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 $11$ 分制和 $21$ 分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中 $\texttt W$ 表示华华获得一分，$\texttt L$ 表示华华对手获得一分）：

$$\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$$

在 $11$ 分制下，此时比赛的结果是华华第一局 $11$ 比 $0$ 获胜，第二局 $11$ 比 $0$ 获胜，正在进行第三局，当前比分 $1$ 比 $1$。而在 $21$ 分制下，此时比赛结果是华华第一局 $21$ 比 $0$ 获胜，正在进行第二局，比分 $2$ 比 $1$。如果一局比赛刚开始，则此时比分为 $0$ 比 $0$。直到分差大于或者等于 $2$，才一局结束。

**注意：当一局比赛结束后，下一局立刻开始**。

你的程序就是要对于一系列比赛信息的输入（$\texttt{WL}$ 形式），输出正确的结果。


## 说明/提示

每行至多 $25$ 个字母，最多有 $2500$ 行。

（注：事实上有一个测试点有 $2501$ 行数据。）

**【题目来源】**

NOIP 2003 普及组第一题

## 样例 #1

### 输入

```
WWWWWWWWWWWWWWWWWWWW
WWLWE
```

### 输出

```
11:0
11:0
1:1

21:0
2:1
```

# AI分析结果

💡 洛语云笺的C++算法解析：乒乓球（NOIP 2003 普及组）深入学习指南 💡

> 今天我们来一起分析“乒乓球”这道C++模拟题。它看似简单，却是“读题 + 状态机”的绝佳练习：如何一次性读入所有字符？如何用一个函数同时处理两种分制？如何优雅地输出中间结果？我们将从“题眼”出发，一步步拆解，让你真正理解“模拟题”的解题套路。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：把若干行混在一起的字符（直到遇到 `E`）全部读入，然后**逐球模拟**两种分制（11 分、21 分），在每一局结束时立即输出当前比分，并在字符串结束后把剩余比分再输出一次。

✨ **核心算法标签**：模拟、字符串、状态机

🗣️ **初步分析**  
- 思路1：暴力逐球遍历 → 可行，因为字符总量 ≤ 2500×25 ≈ 6.25×10⁴，时间复杂度 O(n)。  
- 思路2：函数封装 → 把“分制”抽象成参数 `k`，一次遍历即可同时处理 11 和 21。  
- 思路3：边界细节 → 字符串末尾剩余分数必须再输出一次，且两次分制之间要空一行。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (输入形式)**：“若干行，每行至多 25 个字母，读到 `E` 为止” → 必须一次性读入所有字符，可用 `while(cin>>c)` 或 `getchar()` 直到 `EOF` 或 `E`。  
2. **线索2 (分制规则)**：“有人 ≥ k 分且分差 ≥ 2” → 这是一个**状态机**：每球更新 `w,l`，满足条件即“结算”并清零。  
3. **线索3 (输出要求)**：“每局结束立即输出；剩余比分再输出一次；11 与 21 之间空行” → 需要**两段遍历**，或把遍历封装成函数 `Work(k)`。

### 🧠 思维链构建：从线索到策略
> “好了，侦探工作完成：  
> 1. 线索1告诉我们必须先把所有字符读进一个容器（`string` 或 `vector<char>`）。  
> 2. 线索2提示用两个计数器 `w,l` 模拟即可，状态机条件 `max(w,l)>=k && abs(w-l)>=2`。  
> 3. 线索3要求两次遍历或两次调用函数，中间输出换行。  
> 结论：**一次读入 + 两次模拟** 是最简洁、最不容易出错的策略。”

---

## 2. 精选优质题解参考

### 题解一：DengDuck（综合评分 ★★★★★）
- **亮点**：  
  1. 用 `while(cin>>C)` 读入，直到 `C=='E'`，写法极简。  
  2. 把重复逻辑封装成 `Work(int Lim)`，通过参数复用，代码短小精悍。  
  3. 明确提醒“本地调试 Ctrl+Z”，对初学者非常友好。  
- **学习笔记**：把“分制”抽象成参数，是**模拟题代码复用**的经典技巧。

### 题解二：qhr2023（综合评分 ★★★★☆）
- **亮点**：  
  1. 同样使用函数封装 `solve(k)`，一行搞定。  
  2. 三目运算符 `i=='W'?a++:b++` 让更新更紧凑。  
- **小瑕疵**：`'\n\n'` 输出空行时用了两个换行，容易在评测机出现多余空行，需留意。

### 题解三：derderhaoyue（综合评分 ★★★★☆）
- **亮点**：  
  1. 用 `scanf("%c ",&c[cnt])` 读入，空格屏蔽空白字符，避免 `getchar()` 的换行陷阱。  
  2. 函数 `res(fo)` 里用 `if(c[i]=='E')` 提前终止，逻辑清晰。  
- **学习笔记**：`scanf` 的格式串小技巧——加空格跳过空白字符。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：函数封装模拟）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **一次性读入** | 使用 `string S; char c; while(cin>>c && c!='E') S+=c;` 或 `getchar()` 循环直到 `EOF` 或 `'E'`。 | 避免逐行读取，减少复杂度。 |
| **状态机模拟** | 遍历 `S`，每球更新 `w,l`；当 `max(w,l)>=k && abs(w-l)>=2` 时输出比分并清零。 | 把“结算”条件写成独立函数，逻辑清晰。 |
| **输出边界** | 遍历结束后，无论是否满足结算条件，都要再输出一次剩余比分；两次分制之间空一行。 | 用 `printf("%d:%d\n\n",w,l)` 或两次 `endl` 即可。 |

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **逐球暴力** | 每读一个字符立即更新比分并判断 | 思路直接 | 代码重复、易错 | 数据量极小 |
| **函数封装** | 先全部读入，再两次调用 `Work(k)` | 无重复代码、易调试 | 需额外空间存字符串 | 本题最佳，100% |
| **双指针** | 用指针记录当前局起点 | 省空间 | 实现复杂 | 数据量更大时 |

### ✨ 优化之旅：从“能做”到“做好”
> “暴力逐球” → “先存后算”：  
> - 第一步：每读一球就处理，代码重复两次。  
> - 第二步：发现两次逻辑相同，**抽象成函数**。  
> - 第三步：把输入与模拟彻底解耦，**先读入再模拟**，逻辑更干净。  
> 结论：函数封装 + 字符串一次性读入 = 简洁 + 可维护 + 100% AC。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合 DengDuck 与 qhr2023 写法，简洁易读。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
string s;
char c;
void Work(int k) {
    int w = 0, l = 0;
    for (char ch : s) {
        if (ch == 'W') ++w;
        else if (ch == 'L') ++l;
        if (max(w, l) >= k && abs(w - l) >= 2) {
            cout << w << ':' << l << '\n';
            w = l = 0;
        }
    }
    cout << w << ':' << l << '\n';
}
int main() {
    while (cin >> c && c != 'E') s += c;
    Work(11);
    cout << '\n';
    Work(21);
    return 0;
}
```
- **代码解读概要**：  
  1. 读入所有字符到 `s`。  
  2. `Work(k)` 负责一次遍历并输出比分。  
  3. 两次调用 `Work`，中间空行，满足题目输出格式。

---

## 5. 算法可视化：像素动画演示

- **动画主题**：“像素乒乓球计分器”  
- **核心演示**：每球更新像素比分板，满足结算条件时比分板闪烁并“叮”声提示，随后清零。  
- **设计思路**（8 位像素风）：  
  1. **场景**：左上角 8×2 像素 LED 显示当前比分 `w:l`，右侧滚动条显示剩余字符。  
  2. **交互**：  
     - **单步按钮**：每点击一次，播放一球动画，LED 数字加 1。  
     - **自动播放**：AI 模式，0.3 秒/球自动滚动。  
  3. **音效**：  
     - 结算时播放 8-bit “叮”声；  
     - 游戏结束播放胜利音效。  
- **关键帧**（伪代码）：  
  ```js
  function step(ch) {
      if (ch === 'W') w++; else l++;
      drawLED(w, l);
      if (max(w, l) >= k && abs(w - l) >= 2) {
          flashLED();
          playSound('ding');
          w = l = 0;
          drawLED(0, 0);
      }
  }
  ```

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**  
  1. 字符串一次性读入 + 多次遍历，适用于所有“先收集后处理”的模拟题。  
  2. 把规则抽象成参数 `k`，可扩展到任意分制（如 15、25）。  
  3. 状态机思想：计数器 + 条件判断，适用于“连续计数直到满足条件”的场景（如连续子串、窗口滑动）。

- **洛谷推荐练习**  
  1. **P1046** 陶陶摘苹果 —— 用一次遍历统计满足条件的元素。  
  2. **P1425** 小玉在游泳 —— 模拟分段计时，注意边界输出。  
  3. **P2670** 扫雷游戏 —— 二维网格模拟，考察邻域统计。

---

## 7. 学习心得与经验分享 (若有)

> **DengDuck 的调试心得**：“本地测试时记得用 Ctrl+Z（Windows）或 Ctrl+D（Unix）结束输入，否则程序会一直等待。”  
> **洛语云笺点评**：这条经验提醒我们，**在线评测与本地调试的输入结束方式不同**，提前测试可避免“本地能跑，评测 TLE”的尴尬。

---

<conclusion>
今天我们一起拆解了“乒乓球”这道模拟题：从一次性读入到函数封装，再到像素风可视化。记住：  
- **先读入再模拟**，避免重复代码；  
- **把规则抽象成参数**，提升复用性；  
- **边界输出一次不落**，细节决定成败。  
继续加油，下一道题见！💪

---
处理用时：55.56秒
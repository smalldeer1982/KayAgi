# 题目信息

# [蓝桥杯 2023 国 A] 迷宫探险

## 题目描述

勇士小蓝准备去遥远的 LQ 迷宫探险，拿到迷宫中的宝藏。迷宫可以看做是一个具有 $N$ 个顶点(顶点编号为 $0\sim N-1$) 和 $M$ 条边的无向图，其中每个顶点上都有一只怪物，每只怪物都具有一定的攻击力，每条边都具有一个权重 $w$ 表示小蓝经过边时消耗的时间。

想要拿到迷宫宝藏，小蓝需要从 $0$ 号顶点出发对地图进行探险，在经过顶点时可以对怪物进行击杀，小蓝具有必杀技，能保证一招就击败怪物，但在小蓝对某个怪物进行击杀时，与这个怪物所在结点相邻接的结点上仍存活着的怪物会对小蓝发起一次攻击(注意，不包括小蓝正在击杀的怪物)，小蓝会减少对应攻击力大小的血量。当小蓝击杀完所有怪物并且到达顶点 $N-1$，并且此时小蓝的血量大于 $0$，那么小蓝才可以获得迷宫宝藏。

注意，小蓝的必杀技很快，因此在击杀怪物时可以视为不消耗时间；一个怪物只需要被击杀一次就会消失，只有在小蓝击杀怪物时，与其相邻接的结点上的怪物才会对小蓝发起一次攻击。

如果小蓝可以获得迷宫宝藏，请你输出所需要的最小时间。否则输出 $-1$ 即可。

## 说明/提示

**【样例解释 1】**

小蓝初始在 $0$ 号点，下一步移动到 $1$ 号点，耗费时间 $1$。

击杀 $1$ 号点的怪物，将会受到 $0$、$2$ 号怪物的攻击，血量减少 $7$，剩余血量为 $3$。

移动到 $0$ 号点，耗费时间 $1$，接着击杀 $0$ 号怪物，不会受到攻击。

移动到 $1$ 号点，再继续移动到 $2$ 号点，耗费时间 $3$，此时击杀 $2$ 号怪物，不会受到攻击，击杀完毕后小蓝剩余 $3$ 血量，满足题目要求，总计耗费时间为 $5$。

**【评测用例规模与约定】**

对于 $40\%$ 的评测用例，$1\le N\le 10$；  
对于所有评测用例，$1\le N\le 15$，$1\le M\le N^2$，$1\le HP\le 100$，$1\le \text{怪物攻击力} \le 10$，$1\le w\le 10$。

## 样例 #1

### 输入

```
3 2 10
2 10 5
0 1 1
1 2 2
```

### 输出

```
5
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：迷宫探险 深入学习指南 💡

> 各位小小探险家们，今天我们要化身“算法侦探”，一起破解蓝桥杯 2023 国赛 A 组的压轴迷宫难题！  
> 这道题不仅考验最短路，还融合了“状态压缩”“拆点”“血量博弈”等多重机关。让我们一步步揭开它的面纱。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在一张无向图上，每击杀一只怪物就会受到**相邻存活怪物**的集体攻击，必须在血量>0 的前提下**杀光所有怪物**并**到达终点**，求**最短耗时**。

✨ **核心算法标签**  
最短路（Dijkstra）+ 状态压缩（Bitmask）+ 拆点（状态扩展）

🗣️ **初步分析**  
- 第一眼：最短路？——但路径长度与怪物击杀顺序、当前血量都有关。  
- 第二眼：怪物只有15只——**2¹⁵=32768** 种击杀状态，可**状态压缩**。  
- 第三眼：血量上限100，可把“当前在哪个点、剩余血量、怪物击杀状态”一起当作**超级结点**，跑**分层图最短路**。

> 把“击杀状态”想象成一把**15位二进制钥匙**，每一位代表一只怪物是否被击败。每走一步，要么“换房间”（普通移动），要么“拔钥匙”（击杀怪物）——但拔钥匙会被隔壁怪物偷袭掉血！

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (数据规模)**  
   N≤15 → 暗示**状态压缩**；HP≤100 → 可把血量作为维度。
2. **线索2 (击杀规则)**  
   击杀怪物会触发**邻点怪物攻击** → 需要实时知道**哪些怪物还活着** → 状态S。
3. **线索3 (最优化目标)**  
   求“最小时间” → **最短路算法**（Dijkstra）。

---

### 🧠 思维链构建：从线索到策略

> 1. 看到N≤15，我立刻想到**二进制状态压缩**，把怪物击杀情况塞进一个int里。  
> 2. 但路径长度不仅与位置有关，还与**剩余血量**有关 → 必须把血量也作为状态维度。  
> 3. 于是构造三维状态 `(u, hp, S)`：在点u，剩余hp，已击杀S。  
> 4. 状态转移只有两类：  
>    - **击杀当前怪物**：S更新，hp减少`damage[u][S]`，时间不变。  
>    - **移动到邻点**：位置更新，S与hp不变，时间增加边权。  
> 5. 整张图变成一张**分层图**，跑Dijkstra即可。  
> 6. 答案：`min{ dis[n-1][hp][全1] | hp>0 }`。

---

## 2. 精选优质题解参考

**题解来源：a_cow_of_FJ**（赞：3）  
**点评**：  
- 思路直击要害：拆点+状态压缩+Dijkstra，代码简洁，预处理`damage[u][S]`非常巧妙。  
- 变量命名清晰（`S`表示状态，`hp`表示血量），`auto [u,hp,S,dist]`结构化绑定让代码可读性大增。  
- 复杂度分析诚实：理论最坏`O(n³·HP·2ⁿ)`，实际远跑不满，512 MB内存绰绰有余。  
- 一句“估计是最慢的一篇题解了”反而体现了作者对算法边界的清晰认识——**能AC就是王道**！

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析与学习笔记 |
|---|---|
| **状态设计** | 将“击杀状态”压缩为15位二进制`S`，与“当前节点u”“剩余血量hp”共同构成状态`(u,hp,S)`。💡 **学习笔记**：当维度≤15且只有“存在/不存在”两种信息时，优先考虑**位掩码**。 |
| **预处理伤害** | 提前计算`damage[u][S]`：在状态S下击杀u，会受到哪些邻点怪物的攻击。💡 **学习笔记**：**空间换时间**的经典范例，避免在Dijkstra中重复计算。 |
| **分层图最短路** | 把每个`(u,hp,S)`视为一个超级结点，边权为时间。💡 **学习笔记**：**拆点思想**——把约束条件塞进状态，再跑最短路。 |

---

### ✨ 解题技巧总结

- **位运算技巧**：`!(S & (1<<v))` 判断怪物v是否存活；`S | (1<<u)` 把u置1。  
- **初始化无穷大**：`memset(dis, 0x3f, sizeof dis)` 一次性把数组设为`0x3f3f3f3f`。  
- **优先队列小根堆**：`operator<` 反着写，或用`greater<Node>`。

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
|---|---|---|---|---|
| **暴力DFS** | 枚举击杀顺序+走法 | 思路直接 | O(N!·2^N) 爆炸 | N≤8 可骗分 |
| **分层图Dijkstra** | 状态压缩+最短路 | 理论完备 | 常数略大 | N≤15 稳过 |
| **双向BFS** | 起点终点同时搜 | 剪枝明显 | 状态维度高，难写 | 未尝试 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 从暴力DFS到状态压缩Dijkstra，我们经历了**维度爆炸→维度合并**的蜕变。  
> 把“击杀顺序”这一排列问题，转化为“状态S的位运算”问题，复杂度从阶乘级降到指数级，配合优先队列剪枝，成功通关！

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
- **说明**：综合 a_cow_of_FJ 题解，提炼出最简洁、最易复用的版本。  
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 15, MAXHP = 102, INF = 0x3f3f3f3f;
int n, m, HP, d[MAXN], dmg[MAXN][1 << MAXN], dis[MAXN][MAXHP][1 << MAXN];
struct Edge { int v, w; };
vector<Edge> G[MAXN];

struct Node {
    int u, hp, S, dist;
    bool operator<(const Node& o) const { return dist > o.dist; }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> HP;
    for (int i = 0; i < n; ++i) cin >> d[i];
    for (int i = 0, u, v, w; i < m; ++i) {
        cin >> u >> v >> w;
        G[u].push_back({v, w});
        G[v].push_back({u, w});
    }

    // 预处理 dmg[u][S]
    for (int u = 0; u < n; ++u)
        for (int S = 0; S < (1 << n); ++S) {
            dmg[u][S] = 0;
            for (auto [v, _] : G[u])
                if (!(S >> v & 1)) dmg[u][S] += d[v];
        }

    // Dijkstra
    memset(dis, 0x3f, sizeof dis);
    priority_queue<Node> pq;
    dis[0][HP][0] = 0;
    pq.push({0, HP, 0, 0});

    while (!pq.empty()) {
        auto [u, hp, S, dist] = pq.top(); pq.pop();
        if (dist != dis[u][hp][S]) continue;

        // 击杀当前怪物
        if (!(S >> u & 1)) {
            int nhp = hp - dmg[u][S];
            if (nhp <= 0) continue;
            int nS = S | (1 << u);
            if (dist < dis[u][nhp][nS]) {
                dis[u][nhp][nS] = dist;
                pq.push({u, nhp, nS, dist});
            }
        }

        // 移动到邻点
        for (auto [v, w] : G[u]) {
            if (dist + w < dis[v][hp][S]) {
                dis[v][hp][S] = dist + w;
                pq.push({v, hp, S, dist + w});
            }
        }
    }

    int ans = INF, full = (1 << n) - 1;
    for (int hp = 1; hp <= HP; ++hp)
        ans = min(ans, dis[n - 1][hp][full]);
    cout << (ans == INF ? -1 : ans) << '\n';
    return 0;
}
```

- **代码解读概要**：  
  1. **输入+建图**：标准邻接表。  
  2. **预处理 dmg**：两层循环+邻接枚举，O(n²·2ⁿ)。  
  3. **Dijkstra**：三维状态最短路，优先队列保证最小堆。  
  4. **答案收集**：遍历所有血量>0 的终点状态取最小值。

---

## 5. 算法可视化：像素动画演示

**主题**：“像素勇士闯迷宫”——8位像素风格  
**核心演示**：Dijkstra 如何一步步扩展 `(u,hp,S)` 状态

- **画面**：  
  - 左上角：15×1 的像素灯条表示 `S`（亮=已击杀）。  
  - 中间：N×N 的像素迷宫，当前所在点闪烁红心。  
  - 右上角：像素血条（0~100格）。  
- **音效**：  
  - 击杀怪物 → “拔剑”8-bit音效。  
  - 掉血 → “受伤”短促下降音。  
  - 找到更短路 → “叮”升级音。  
- **交互**：  
  - 单步/自动播放按钮，速度滑块。  
  - 鼠标悬停状态块，显示 `(u,hp,S)` 详情。  
- **游戏化**：  
  - 每击杀全部怪物并到达终点视为“通关”，弹出像素庆祝动画。  

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**  
状态压缩+分层图最短路可解决：  
1. 旅行商问题（TSP）——城市已访问集合。  
2. 带钥匙的迷宫——不同钥匙组合开门。  
3. 开关灯问题——灯的状态影响路径。

**洛谷推荐**  
1. **P1433 寿司晚宴** —— 状压DP + 集合转移。  
2. **P3955 图书管理员** —— 状态压缩+最短路。  
3. **P4802 洞穴勘测** —— 分层图+状压练手。

---

## 7. 学习心得与经验分享

> **来自 a_cow_of_FJ**：  
> “预处理伤害数组时，一开始写成了三层循环套邻接表，复杂度看起来吓人，但实际跑不满，放心大胆写即可。”  
> **洛语云笺点评**：  
> 在竞赛中，**理论复杂度≠实际运行时间**，大胆实现并测试，往往会有惊喜！

---

<conclusion>
恭喜大家完成本次“迷宫探险”算法之旅！记住：  
- **状态压缩**是处理小规模“存在/不存在”问题的利器。  
- **分层图**把多维约束转化为最短路，优雅高效。  
继续刷题，下一站见！💪
</conclusion>

---
处理用时：63.70秒
# 题目信息

# [NOIP 2009 提高组] 最优贸易

## 题目背景

本题原题数据极弱，Subtask 0 中的测试点为原题测试点，Subtask 1 中的测试点为 Hack 数据。

## 题目描述

$C$ 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

$C$ 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 $C$ 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 $C$ 国 $n$ 个城市的标号从 $1\sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 $C$ 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 $C$ 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![](https://cdn.luogu.com.cn/upload/image_hosting/flre534z.png)

假设 $1\sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1\to2\to3\to5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1\to4\to5\to4\to5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 说明/提示

【数据范围】

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1\leq n\leq 6$。

对于 $30\%$ 的数据，$1\leq n\leq 100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1\leq n\leq 100000$，$1\leq m\leq 500000$，$1\leq  x,y\leq  n$，$1\leq  z\leq  2$，$1\leq $ 各城市的编号 $\leq  n$。

水晶球价格 $\leq 100$。

NOIP 2009 提高组 第三题

## 样例 #1

### 输入

```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2 ```

### 输出

```
5```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：最优贸易 深入学习指南 💡

> 欢迎来到今天的思维探险！  
> 我们要一起破解的是 NOIP 2009 提高组第三题——**最优贸易**。  
> 这题表面上是在城市之间买卖水晶球，实质上是一次**“如何巧妙地把复杂图论问题拆成我们熟悉的小问题”**的实战演练。  
> 让我们像侦探一样，从题目中寻找线索，再像建筑师一样，把思路搭建成一座稳固的算法大厦！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **在一张有向/无向混合的大图中，从城市 1 走到城市 n，途中只能“买一次再卖一次”，求最大差价。**

### ✨ 核心算法标签
- 图论（Graph）
- 分层图（Layered Graph）
- 最短/最长路（SPFA / Dijkstra）
- 强连通分量（Tarjan SCC）
- 动态规划（DAG DP）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 侦探笔记（洛语云笺的旁白） |
| --- | --- |
| **线索1：问题目标** | “求最大差价” → 典型的**最优化问题**（maximize profit）。 |
| **线索2：操作限制** | “只能买一次、卖一次” → **状态转移有限**（没买→买了→卖了）。 |
| **线索3：图论模型** | 有向/无向边，城市可重复经过 → **图上路径问题**。 |
| **线索4：数据规模** | n ≤ 1e5，m ≤ 5e5 → **O(m log n) 或 O(m)** 级别算法才安全。 |
| **线索5：价格范围** | 1 ≤ price ≤ 100 → **小权值**，暗示可用**最短路/最长路**解决。 |

---

### 🧠 思维链构建：从线索到策略

> 1. **目标**是最大化 `sell - buy`，等价于**最大化一条路径上的 `(price[y] - price[x])`**。  
> 2. **限制**是 x 必须在 y 之前出现，且整条路径必须从 1 到 n。  
> 3. **直觉**：  
>    - 若图是 DAG（有向无环），可直接拓扑序 DP。  
>    - 若图有环，需要**缩点**或**分层图**把环拆掉。  
> 4. **数据规模**告诉我们：暴力枚举 x,y 不可行，必须一次或两次线性扫描。  
> 5. **结论**：  
>    - **分层图**（把“买/卖”拆成三层）→ 把“状态”塞进图里。  
>    - **双 SPFA**（一次求最小，一次求最大）→ 把“状态”放在数组里。  
>    - **Tarjan 缩点** → 把“环”压成点，变 DAG 再 DP。

---

## 2. 精选优质题解参考

| 题解 | 核心亮点（洛语云笺的点评） |
| --- | --- |
| **fy1234567ok** | 用**分层图**把“买/卖”拆成三层，再用 **SPFA 跑最长路**，代码仅 40 行，优雅！ |
| **ctzm** | **Tarjan 缩点 + DAG DP**，思路严谨，能处理任意环，线性复杂度，硬核！ |
| **Gypsophila** | 同样 Tarjan，但用拓扑序 DP，变量命名清晰，适合第一次学缩点的同学。 |
| **fairfriendZ 多层图** | 用 `id(x, layer)` 宏让分层图代码更直观，还补充了**双端 SPFA**思路，一题多解。 |
| **EricWay1024 BFS** | 用**状态压缩 BFS**（pos, val）暴力剪枝，小数据教学用，思维训练极佳。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以分层图为例）

| 关键点 | 分析 | 💡 学习笔记 |
| --- | --- | --- |
| **1. 如何把“买/卖”塞进图？** | 把每个城市复制 3 份：<br>- 第 0 层：未买未卖<br>- 第 1 层：已买未卖<br>- 第 2 层：已买已卖<br>层内边权 0，层间边权 `-price` / `+price`。 | **状态分层**是处理“有限次操作”的通用技巧。 |
| **2. 如何建图？** | `add(u, v, 0)` 连三层；<br>`add(i, i+n, -price[i])` 买；<br>`add(i+n, i+2n, price[i])` 卖。 | 用宏 `id(i, k) = i + k*n` 让代码更简洁。 |
| **3. 如何跑最长路？** | 由于存在负权，用 **SPFA**（或 Dijkstra + 势函数）。<br>起点 `1`（第 0 层），终点 `n+2n`（第 2 层）。 | 最长路 = 把边权取负跑最短路。 |
| **4. 如何处理双向边？** | 双向边每层都要连两次，注意方向。 | 模板化 `if(op==2)` 即可。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- | --- | --- |
| **分层图 + SPFA** | 把“买/卖”拆成三层图跑最长路 | O(3m) ≈ O(m) | 思维直接，代码短 | SPFA 可能被卡 | 通用，推荐新手 |
| **Tarjan + DAG DP** | 缩点后拓扑序 DP | O(n+m) | 线性，最稳健 | 代码长，需掌握 SCC | 需要稳定复杂度 |
| **双 SPFA** | 正向求最小，反向求最大 | O(2m) | 无需分层，常数小 | 需两次最短路 | 喜欢最短路选手 |
| **状态 BFS** | (pos, min_price) 状态剪枝 | O(n·P) | 暴力美学 | 会被大数据卡 | 教学/调试 |

---

## 4. C++核心代码实现赏析

### ✅ 通用核心实现（分层图 + SPFA）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, M = 5e5 + 5;
int n, m, price[N], dis[3 * N], vis[3 * N];
vector<pair<int, int>> G[3 * N];
inline int id(int u, int k) { return u + k * n; }

void spfa(int s) {
    for (int i = 1; i <= 3 * n; ++i) dis[i] = -1e9;
    queue<int> q; q.push(s); dis[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        for (auto [v, w] : G[u])
            if (dis[v] < dis[u] + w) {
                dis[v] = dis[u] + w;
                if (!vis[v]) { vis[v] = 1; q.push(v); }
            }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> price[i];
        G[id(i, 0)].emplace_back(id(i, 1), -price[i]);
        G[id(i, 1)].emplace_back(id(i, 2),  price[i]);
    }
    for (int i = 1, u, v, op; i <= m; ++i) {
        cin >> u >> v >> op;
        for (int k = 0; k < 3; ++k) {
            G[id(u, k)].emplace_back(id(v, k), 0);
            if (op == 2) G[id(v, k)].emplace_back(id(u, k), 0);
        }
    }
    spfa(id(1, 0));
    cout << max(0, dis[id(n, 2)]) << '\n';
    return 0;
}
```

### 📌 代码解读
- **id(i, k)** 把第 k 层的第 i 个城市映射到唯一整数。  
- **建图**：层内边权 0，层间边权 ±price。  
- **SPFA**：跑最长路（负权边不能用 Dijkstra）。  
- **答案**：`dis[id(n,2)]`，若为负则输出 0。

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题
**“像素商人冒险记”**  
8 位像素风格，商人从城市 1 出发，穿越三层“水晶世界”，在途中买卖水晶球，最终抵达城市 n。

### 🕹️ 核心场景
1. **三层地图**：  
   - 第 0 层：绿色草原（未买）。  
   - 第 1 层：蓝色湖泊（已买）。  
   - 第 2 层：金色沙漠（已卖）。  
2. **像素商人**：8×8 像素小人，手持金币。  
3. **状态转移**：  
   - 从第 0 层跳到第 1 层：播放“叮”音效，金币减少。  
   - 从第 1 层跳到第 2 层：播放“哗啦”音效，金币增加。  
4. **路径高亮**：当前正在松弛的边用红色像素箭头闪烁。  
5. **控制面板**：  
   - 单步 / 自动播放 / 重置按钮。  
   - 速度滑块（1× ～ 8×）。  
6. **游戏化**：每完成一次松弛得 1 分，通关显示“Profit: X”。

---

## 6. 拓展练习与相似问题思考

### 🧩 通用技巧迁移
- **分层图思想**：  
  - 机票打折 k 次 → 建 k+1 层图。  
  - 关卡只能走一次 → 层间边权 0/1。  
  - 背包体积变化 → 层表示剩余容量。

### 📚 洛谷推荐
| 题号 | 推荐理由 |
| --- | --- |
| P2939 [USACO09FEB] Revamping Trails | 经典分层图，边权可变为 0。 |
| P4568 [JLOI2011] 飞行路线 | k 次免费航班 → 分层最短路。 |
| P4822 [BJWC2012] 冻结 | 时间倒流，分层图 + 最短路。 |
| P1073 本题 hack 数据 | 检验分层图鲁棒性。 |

---

## 7. 学习心得与经验分享

> **fy1234567ok 的调试心得**：  
> “最初把层间边连成了 `i→i+1` 的**所有出边**，结果 WA 一片。后来意识到**只能连自环**（i→i），否则多了一层‘强制经过’的含义。”  
> 💡 **洛语云笺点评**：  
> 分层图建模时，**层间边的语义**必须与设计的状态完全一致，任何多余的路径都会破坏无后效性！

---

### 🎓 结语
今天我们学会了：
- 如何把“买/卖”这种**状态限制**转化为**分层图**。  
- 如何在**大图**上优雅地跑**最短路/最长路**。  
- 如何对比**多种策略**，选择最适合当前数据规模的解法。

带着这些技巧，去迎接下一场算法冒险吧！  
—— 洛语云笺 🌸

---
处理用时：68.17秒
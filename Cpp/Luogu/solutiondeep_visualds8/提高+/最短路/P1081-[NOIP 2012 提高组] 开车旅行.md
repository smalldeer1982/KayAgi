# 题目信息

# [NOIP 2012 提高组] 开车旅行

## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。


## 说明/提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。


## 样例 #1

### 输入

```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3
```

### 输出

```
1 
1 1 
2 0 
0 0 
0 0 ```

## 样例 #2

### 输入

```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7```

### 输出

```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[NOIP 2012 提高组] 开车旅行 深入学习指南 💡

> 今天我们要一起攻克的是一道经典的**倍增 + 预处理**题目——“开车旅行”。这道题不仅考验我们对复杂条件的理解，更是一次将**“倍增思想”**玩出花来的思维盛宴！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在只能向东行驶的规则下，如何**快速模拟**小A（选次近）和小B（选最近）的交替驾驶过程，并在海量查询中迅速回答“从某城市出发，行驶X公里后，两人分别走了多少路？”以及“从哪个城市出发，A与B的路程比最小？”

✨ **核心算法标签**：  
- 倍增（Binary Lifting）
- 预处理（Preprocessing）
- 链表/平衡树（Linked List / Balanced Tree）

### 🗣️ 初步分析
这道题看似是一个模拟题，但数据范围告诉我们：暴力模拟（O(n²)）会直接爆炸！  
**核心突破口**在于：  
1. **“向东”**意味着方向固定，我们可以**离线处理**每个点下一步去哪。  
2. **“交替驾驶”**是一个**周期性行为**（A→B→A→B...），可以用**倍增**来压缩路径。  
3. **“比值最小”**可以通过枚举起点+快速查询来解决。

🎯 **一句话总结**：  
> 先用**链表/平衡树**预处理出每个点的“最近”和“次近”邻居，再用**倍增**将“两人各走一步”压缩为“一步跳2^k天”，实现O(log n)查询！

---

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现过程 | 指向算法 |
|---|---|---|
| **“向东行驶”** | 方向固定，可离线处理 | 链表/平衡树预处理 |
| **“交替驾驶”** | A→B→A→B...周期性 | 倍增压缩路径 |
| **“海量查询”** | n,m ≤ 1e5 | 必须O(log n)查询 |

---

### 🧠 思维链构建：从线索到策略
1. **方向固定** → 可以**排序+链表**预处理“最近/次近”邻居。  
2. **周期性驾驶** → 将“A走一次+B走一次”视为**一个“大步骤”**，用倍增存储。  
3. **海量查询** → 倍增查询，从大到小枚举2^k步，类似LCA跳表！

---

## 2. 精选优质题解参考

### 🏆 题解一：yangrunze（★★★★★）
**亮点**：  
- **链表预处理**：用双向链表优雅地处理“向东”限制，每次处理完一个点即删除，确保后续点只考虑东边。  
- **倍增设计**：将“A走一次+B走一次”视为一个“大步骤”，存储`f[i][k]`（走2^k步后的城市）、`da[i][k]`（A走的路程）、`db[i][k]`（B走的路程）。  
- **查询优化**：从大到小枚举k，类似LCA跳表，确保O(log n)查询。

**代码精髓**：
```cpp
// 预处理ga[i]和gb[i]（A/B下一步去哪）
for (int i = 1; i < n; ++i) {
    int p = pos[i], p1 = h[p].pre, p2 = h[p].nxt;
    if (p1 && (h[p].hi - h[p1].hi <= h[p2].hi - h[p].hi || !p2))
        gb[i] = h[p1].id, ga[i] = choose(h[p1].pre, p2, p);
    else
        gb[i] = h[p2].id, ga[i] = choose(p1, h[p2].nxt, p);
    del(p); // 删除已处理的点
}
```

---

### 🏆 题解二：star_fish（★★★★☆）
**亮点**：  
- **set优化链表**：用`set`代替手写链表，代码更简洁，但常数稍大。  
- **倍增初始化**：将“A走一次+B走一次”视为一个“大步骤”，存储`to[i][k]`和`f[i][k]`。  
- **边界处理**：详细处理了“无法选择次近”的边界情况。

---

### 🏆 题解三：Shadow_Soldier（★★★★☆）
**亮点**：  
- **思路梳理**：将问题拆解为“预处理→倍增→查询”三步，逻辑清晰。  
- **__int128防溢出**：用`__int128`比较比值，避免精度问题。  
- **代码封装**：将查询逻辑封装为`Calc`函数，可读性强。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **预处理“最近/次近”** | 用**排序+链表**或**set**处理“向东”限制，确保O(n log n)或O(n)。 | 链表删除法：处理完一个点即删除，确保后续只考虑东边。 |
| **倍增设计** | 将“A走一次+B走一次”视为一个“大步骤”，存储`f[i][k]`、`da[i][k]`、`db[i][k]`。 | 倍增的核心是“二进制拆分”，将O(n)步压缩为O(log n)步。 |
| **查询优化** | 从大到小枚举k，类似LCA跳表，确保O(log n)查询。 | 查询时需注意“最后一步可能只有A走”的特判。 |

---

### ✨ 解题技巧总结
- **问题转化**：将“交替驾驶”转化为“周期性大步骤”，用倍增压缩。  
- **数据结构选择**：链表（O(n)）或set（O(n log n)）预处理邻居，倍增（O(log n)）查询。  
- **边界处理**：特判“无法选择次近”和“比值无穷大”的情况。

---

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力模拟** | O(n²)枚举每一步 | 思路直观 | 超时 | n≤20 |
| **链表+倍增** | 链表预处理+倍增查询 | O((n+m) log n) | 代码较长 | 正解 |
| **set+倍增** | set预处理+倍增查询 | 代码简洁 | 常数大 | 正解 |

---

## 4. C++核心代码实现赏析

### 📌 通用核心代码（链表+倍增版）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10, LOG = 20;

struct City { int h, id; } c[N];
bool cmp(City a, City b) { return a.h < b.h; }

int n, pos[N], pre[N], nxt[N], ga[N], gb[N];
ll da[LOG][N][2], db[LOG][N][2], f[LOG][N][2];

void init() {
    for (int i = 1; i <= n; ++i) pre[i] = i - 1, nxt[i] = i + 1;
    pre[1] = nxt[n] = 0;
    for (int i = 1; i < n; ++i) {
        int p = pos[i], l = pre[p], r = nxt[p];
        if (l && (c[p].h - c[l].h <= c[r].h - c[p].h || !r))
            gb[i] = c[l].id, ga[i] = (pre[l] && (!r || c[p].h - c[pre[l]].h <= c[r].h - c[p].h)) ? c[pre[l]].id : c[r].id;
        else
            gb[i] = c[r].id, ga[i] = (nxt[r] && (!l || c[nxt[r]].h - c[p].h <= c[p].h - c[l].h)) ? c[nxt[r]].id : c[l].id;
        if (pre[p]) nxt[pre[p]] = nxt[p];
        if (nxt[p]) pre[nxt[p]] = pre[p];
    }
    for (int i = 1; i <= n; ++i) {
        f[0][i][0] = ga[i], f[0][i][1] = gb[i];
        if (ga[i]) da[0][i][0] = abs(c[pos[i]].h - c[pos[ga[i]]].h);
        if (gb[i]) db[0][i][1] = abs(c[pos[i]].h - c[pos[gb[i]]].h);
    }
    for (int k = 1; k < LOG; ++k)
        for (int i = 1; i <= n; ++i)
            for (int t = 0; t < 2; ++t) {
                int mid = f[k-1][i][t];
                if (!mid) continue;
                int nxt_t = (k == 1) ? (t ^ 1) : t;
                f[k][i][t] = f[k-1][mid][nxt_t];
                da[k][i][t] = da[k-1][i][t] + da[k-1][mid][nxt_t];
                db[k][i][t] = db[k-1][i][t] + db[k-1][mid][nxt_t];
            }
}

pair<ll, ll> query(int s, ll x) {
    ll a = 0, b = 0;
    for (int k = LOG - 1; k >= 0; --k) {
        if (f[k][s][0] && a + b + da[k][s][0] + db[k][s][0] <= x) {
            a += da[k][s][0], b += db[k][s][0];
            s = f[k][s][0];
        }
    }
    if (ga[s] && a + b + da[0][s][0] <= x) a += da[0][s][0];
    return {a, b};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> c[i].h, c[i].id = i;
    sort(c + 1, c + 1 + n, cmp);
    for (int i = 1; i <= n; ++i) pos[c[i].id] = i;
    init();
    ll x0; cin >> x0;
    int best = 1;
    for (int i = 1; i <= n; ++i) {
        auto [a, b] = query(i, x0);
        auto [cur_a, cur_b] = query(best, x0);
        if (!b) continue;
        if (!cur_b || (__int128)a * cur_b < (__int128)cur_a * b ||
            ((__int128)a * cur_b == (__int128)cur_a * b && c[pos[i]].h > c[pos[best]].h))
            best = i;
    }
    cout << best << '\n';
    int m; cin >> m;
    while (m--) {
        int s; ll x; cin >> s >> x;
        auto [a, b] = query(s, x);
        cout << a << ' ' << b << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素赛车大冒险
- **场景**：8位像素风格的地图，城市用彩色方块表示，海拔用高度条显示。  
- **核心演示**：  
  1. **预处理阶段**：  
     - 城市按海拔排序，链表动态删除已处理城市（像素方块“消失”）。  
     - 每个城市高亮显示其“最近”和“次近”邻居（绿色/红色箭头）。  
  2. **倍增阶段**：  
     - 用像素赛车演示“A走一次+B走一次”压缩为“大步骤”。  
     - 倍增数组用“像素能量条”表示2^k步的能量。  
  3. **查询阶段**：  
     - 赛车从起点出发，按2^k步跳跃，像素路径动态绘制。  
     - 音效：每次跳跃播放“叮”声，到达终点播放“胜利”音效。

### 🕹️ 交互设计
- **控制面板**：  
  - 开始/暂停/重置按钮（像素风格）。  
  - 速度滑块（调整动画速度）。  
  - 单步执行按钮（观察每一步细节）。  
- **游戏化元素**：  
  - 每完成一次查询，奖励“像素星星”。  
  - 背景音乐：8位风格循环BGM。

---

## 6. 拓展练习与相似问题思考

### 🎯 通用技巧迁移
- **倍增思想**：  
  1. **LCA（最近公共祖先）**：用倍增跳父亲节点。  
  2. **ST表**：用倍增预处理区间最值。  
  3. **快速幂**：用倍增计算a^b。

### 📚 洛谷推荐练习
1. **P3379 【模板】最近公共祖先（LCA）**  
   *推荐理由*：巩固倍增跳表思想，与本题查询逻辑高度相似。  
2. **P3865 【模板】ST表**  
   *推荐理由*：学习如何用倍增预处理静态区间问题。  
3. **P1081 开车旅行（本题）**  
   *推荐理由*：完整体验从预处理到倍增查询的全过程。

---

## 7. 学习心得与经验分享

> **来自yangrunze的调试心得**：  
> “链表部分调了一晚上，尤其要注意边界条件（如pre/nxt为0的情况）。建议画图辅助理解！”  

> **来自Shadow_Soldier的总结**：  
> “用__int128比较比值时，别忘了特判分母为0的情况，否则会WA得很惨！”  

---

<conclusion>
恭喜你完成了这场“开车旅行”的思维探险！记住：  
- **预处理**是解决复杂问题的第一步。  
- **倍增**是压缩路径的利器。  
- **链表/set**是处理方向限制的好帮手。  
下次我们再一起挑战更高难度的算法谜题！🚗💨
</conclusion>

---
处理用时：84.75秒
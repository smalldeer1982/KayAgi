# 题目信息

# [GCJ 2012 Finals] Zombie Smash

## 题目描述

你正在玩丧尸粉碎（Zombie Smash）这款游戏：你的目标是在墓地中用你可靠的丧尸粉碎器击碎不断从坟墓中冒出的丧尸。墓地被表示为一个平坦的二维网格。每只丧尸会在网格的某个 $(X, Y)$ 单元格中冒出，停留 1000 毫秒（ms），然后又消失回坟墓。任意时刻每个坟墓旁最多只会有一只丧尸。

你可以在 100ms 内移动到当前位置周围 8 个相邻格中的任意一个：也就是说，你可以向正北、正东、正南、正西、东北、东南、西北、西南移动。即使某个格子当前有丧尸占据，你依然可以经过或停在该格子。只要你到达丧尸所在的格子，就可以立即击碎该丧尸，但每次击碎后，你的丧尸粉碎器需要 750ms 冷却，冷却期间你不能再次击碎丧尸，但你可以自由移动。例如，刚刚在 $(0, 0)$ 击碎一只丧尸后：

* 你需要 750ms 才能到达并击碎 $(1, 1)$ 处的丧尸；
* 你需要 2000ms 才能到达并击碎 $(20, 20)$ 处的丧尸。

你在游戏开始时（时间 $=0$）站在 $(0, 0)$。每一关结束后，你想知道如果你玩得最优，这一关你最多能击碎多少只丧尸。

## 说明/提示

**限制条件**

- $1 \leq T \leq 100$
- $-1000 \leq X_i, Y_i \leq 1000$
- $0 \leq M_i \leq 100000000 = 10^8$
- 任意时刻同一格子不会有两只丧尸。换言之，如果某只丧尸在 $(x, y)$ 的 $t$ 时刻出现，则其他在 $(x, y)$ 出现的丧尸要么出现在 $t-1001$ 及更早，要么出现在 $t+1001$ 及更晚。

**测试集 1（7 分，结果可见）**

- $1 \leq Z \leq 8$

**测试集 2（18 分，结果隐藏）**

- $1 \leq Z \leq 100$

翻译由 ChatGPT-4.1 完成。

## 样例 #1

### 输入

```
3
4
1 0 0
-1 0 0
10 10 1000
10 -10 1000
3
1 1 0
2 2 0
3 3 0
5
10 10 1000
-10 10 1000
10 -10 1000
-10 -10 1000
20 20 2000```

### 输出

```
Case #1: 3
Case #2: 2
Case #3: 2```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Zombie Smash 深入学习指南 💡

> 欢迎来到“洛语云笺的算法探险屋”！今天我们要一起挑战的是 **GCJ 2012 Finals Zombie Smash**——一场在像素墓地中与时间赛跑的生存游戏。  
> 你将学会：如何像游戏策划一样拆解规则、如何像侦探一样发现“最短路径+时间窗口”这一核心矛盾，以及如何用最优雅的 BFS 状态扩展把丧尸“一网打尽”。  
> 让我们开始这场思维冒险！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在“每只丧尸只出现 1000 ms”的严苛时间窗内，规划一条**8 方向移动 + 750 ms 冷却**的最优路线，最大化击杀数。  
> 难点在于：**移动耗时**与**冷却耗时**交织，必须精确计算“何时到达、何时能再次攻击”。

✨ **核心算法标签**：  
状态压缩 BFS / Dijkstra（多源最短路 + 时间窗剪枝）

---

### 🗣️ 初步分析（从朴素到精妙）
1. **暴力 DFS**（TLE）：枚举所有击杀顺序，O(Z!) 爆炸。  
2. **贪心**（WA）：只看距离最近或最早出现的丧尸，可能错过“顺路”击杀。  
3. **状态扩展 BFS**（AC）：把“已击杀集合 + 当前时间 + 位置”视为状态，用优先队列（或双端队列）按时间扩展，确保最早到达的状态一定最优。  
   - **比喻**：你是一位“时间旅行者”，每次击杀后瞬间传送到“750 ms 后的自己”，继续寻找下一个可击杀的丧尸。优先队列保证你总是用“最早到达”的那条时间线探索未来。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现内容 | 指向算法 |
|---|---|---|
| **目标** | “最多击杀” → 最优化问题 | 最短路 / DP / 搜索 |
| **约束** | 丧尸只在 [m, m+1000] 存活 → **时间窗** | 必须带时间维度的状态 |
| **移动** | 8 方向，切比雪夫距离 ×100 ms | 距离公式直接计算 |
| **冷却** | 击碎后 750 ms 不能攻击 → **状态转移代价** | 把冷却时间融入边权 |

---

### 🧠 思维链构建：从线索到策略
> 1. 首先，**“时间窗”** 告诉我们：不能简单贪心，必须记录“到达时间”。  
> 2. 接着，**“冷却”** 让移动代价变成 `max(移动耗时, 750)`，这提示我们把“冷却”视为一条边的“等待时间”。  
> 3. 最后，**“最多击杀 ≤ 100”** 暗示状态数可控：用 `state = (已击杀集合, 当前位置, 当前时间)`，集合可用位掩码压缩。  
> 4. **结论**：**状态压缩 BFS** 是完美匹配！把击杀顺序抽象为图上带权路径，优先队列总让“最早到达”的状态先出队，天然满足最优子结构。

---

## 2. 精选优质题解参考

**题解作者：tuxiaolai（Luogu 首 AC）**  
* **点评**：  
  - 思路清晰：将“击杀”抽象为状态 `(i, t, z)`，i 为刚击杀的丧尸编号（0 表示起点），t 为完成时间，z 为击杀数。  
  - 关键洞察：把“冷却”融入边权 `max(dis×100, 750)`，避免额外状态维度。  
  - 代码技巧：用 `struct status` + 优先队列（隐式 Dijkstra），`st[i]` 记录到达 i 号丧尸的最优状态，天然剪枝。  
  - 实践价值：可直接套用到“带时间窗的最短路”类问题，如航班转机、任务调度。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 状态定义** | `(last, t, mask)` 表示“刚刚击杀 last，当前时间 t，已击杀集合 mask” | 状态必须能唯一描述“过去所有决策” |
| **2. 转移方程** | 从 last 到 i 的新时间 `nt = max(t + max(dis×100, 750), m[i])`，若 `nt ≤ m[i]+1000` 则合法 | 把冷却和“等待丧尸出现”统一为“到达时刻” |
| **3. 数据结构** | 优先队列（最小堆）按 t 排序，保证最早到达的状态先扩展；`best[i]` 记录到达 i 的最小时间，用于剪枝 | 与 Dijkstra 思想一致，O(Z² log Z) 可过 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力 DFS** | 枚举所有击杀顺序 | 思路直观 | O(Z!) 爆炸 | Z≤8 时可拿 7 分 |
| **贪心最近丧尸** | 每次选距离最近且可击杀的 | 代码极短 | 易错过顺路击杀 | 样例 2 即 WA |
| **状态压缩 BFS** | 带时间窗的最短路 | 100% 正确 | 需抽象状态 | GCJ 满分 |

---

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点**：暴力 DFS 枚举 8! = 40320 种顺序，Z=8 勉强可过。  
> 2. **瓶颈**：Z=100 时 100! 爆炸，必须剪枝。  
> 3. **钥匙**：发现“到达时间”是唯一瓶颈，用优先队列让“最早到达”的状态先扩展，天然剪枝。  
> 4. **升华**：把“击杀顺序”转化为“带权有向图”，边权为 `max(移动耗时, 冷却)`，于是问题变成“最多能经过多少节点”，直接 Dijkstra。

---

## 4. C++核心代码实现赏析

**通用核心实现（整合 tuxiaolai 思路）**
```cpp
#include <bits/stdc++.h>
using namespace std;

struct Zombie {
    int x, y, m;
};

struct State {
    int last;   // 刚击杀的丧尸编号（0 为起点）
    int time;   // 完成时间
    int killed; // 已击杀数
    bool operator<(const State& o) const {
        return time > o.time; // 最小堆
    }
};

int dis(const Zombie& a, const Zombie& b) {
    return max(abs(a.x - b.x), abs(a.y - b.y));
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    for (int cas = 1; cas <= T; ++cas) {
        int Z; cin >> Z;
        vector<Zombie> zb(Z + 1);
        for (int i = 1; i <= Z; ++i) cin >> zb[i].x >> zb[i].y >> zb[i].m;

        priority_queue<State> pq;
        vector<int> best(Z + 1, 1e9); // best[i] = 到达 i 的最小时间
        pq.push({0, 0, 0});
        int ans = 0;

        while (!pq.empty()) {
            State cur = pq.top(); pq.pop();
            ans = max(ans, cur.killed);
            for (int nxt = 1; nxt <= Z; ++nxt) {
                if (nxt == cur.last) continue;
                int move = cur.last == 0 ? dis(Zombie{0, 0, 0}, zb[nxt]) * 100
                                         : max(dis(zb[cur.last], zb[nxt]) * 100, 750);
                int nt = max(cur.time + move, zb[nxt].m);
                if (nt > zb[nxt].m + 1000) continue; // 错过时间窗
                if (nt < best[nxt]) { // 更优状态
                    best[nxt] = nt;
                    pq.push({nxt, nt, cur.killed + 1});
                }
            }
        }
        cout << "Case #" << cas << ": " << ans << '\n';
    }
    return 0;
}
```

**代码解读概要**  
- **数据结构**：`State` 三元组 + `priority_queue` 实现 Dijkstra。  
- **关键剪枝**：`best[i]` 记录到达 i 的最小时间，避免重复扩展。  
- **边界**：起点 `(0,0)` 视为 0 号丧尸，移动耗时 0。

---

## 5. 算法可视化：像素动画演示

**主题**：**“像素猎人：丧尸时间线”**  
- **风格**：8×8 像素网格墓地，丧尸用闪烁的绿方块，玩家用红帽子像素人。  
- **核心演示**：  
  1. **时间轴滚动**：屏幕底部出现 0-3000 ms 的时间条，当前时间指针从左到右移动。  
  2. **状态弹出**：每当优先队列弹出一个 State，屏幕左上角弹出“击杀 #3 @ 1250 ms”像素对话框。  
  3. **路径动画**：玩家像素人沿 8 方向切比雪夫路径瞬移，路径用黄色像素箭头连线，移动耗时按 100 ms/格播放“嘀嘀”音效。  
  4. **冷却特效**：击碎后玩家变成蓝色“冷冻”像素人 750 ms，期间无法再次攻击，冷冻结束播放“解冻”音效。  
  5. **AI 自动演示**：一键“Auto Hunt”，算法自动运行，击杀数实时在右上角像素计分板累加。  
- **交互**：  
  - 步进/暂停/重置按钮（像素化图标）。  
  - 速度滑块：1×-8× 复古倍速。  
  - 音效开关：8 位芯片风格。

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**  
“带时间窗的最短路”思想可应用于：  
1. 航班转机（每航班有起降时间窗）。  
2. 任务调度（任务只能在指定时间段执行）。  
3. 外卖骑手路径（商家出餐时间窗 + 用户期望送达时间窗）。

**洛谷推荐**  
| 题号 | 推荐理由 |
|---|---|
| **P1772 排队接水** | 经典“带截止时间的任务调度”，练习时间窗 + 贪心/DP。 |
| **P4017 最大食物链计数** | 理解依赖关系建模，为后续“带依赖的背包”打基础。 |
| **P1520 旅行计划** | 多源最短路 + 时间窗剪枝，与本题思想高度相似。 |

---

## 7. 学习心得与经验分享

> **tuxiaolai 的调试心得**（摘录）：  
> “我在 WA 样例 3 时，发现忘记把‘到达时丧尸还未出现’的情况纳入 `max(time + move, m[i])`，导致提前到达却被判错过时间窗。加上 `max` 后立刻 AC。”  
> **洛语云笺点评**：  
> 边界条件永远是“隐形杀手”。在涉及“时间窗”的问题里，**“到达时间”与“允许开始时间”取最大值**是通用模板，值得牢记！

---

<conclusion>
恭喜你完成本次“Zombie Smash”深度探险！  
记住：算法之美，在于把现实规则抽象成“状态 + 转移”，再用最优雅的数据结构驾驭它。下次我们再见，继续用代码拯救世界！💪
</conclusion>

---
处理用时：62.00秒
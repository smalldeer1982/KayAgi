# 题目信息

# [OOI 2023] The way home / 回家的路

## 题目背景

CF1801D

## 题目描述

著名魔术师博里斯·布迪尼在 X 国旅行，这个国家共有 $n$ 个城市。不幸的是，他在编号为 $1$ 的城市遭遇了盗窃。现在，布迪尼需要踏上回家的旅程，目标是回到编号为 $n$ 的城市。

他打算乘坐飞机返家。全国共有 $m$ 个航班，第 $i$ 个航班从城市 $a_i$ 飞往城市 $b_i$，票价为 $s_i$ 卢布。要搭乘某个航班，布迪尼必须身处起点城市 $a_i$，并且手中至少有 $s_i$ 卢布（这些钱在登机时会被扣除）。

被盗后，他仅剩 $p$ 卢布。但他并未气馁！在任意城市 $i$，他都可以随时举办魔术表演，每场表演能赚 $w_i$ 卢布。

请帮助布迪尼判断，他是否能够回到家乡。如果可以，求出他至少需要举办多少场表演。

## 说明/提示

### 样例解释

在第一个样例中，布迪尼最优策略是在第一个城市举办 $4$ 场表演，此时他共有 $2 + 7 \times 4 = 30$ 卢布，然后依次乘坐 $1 \to 3 \to 2 \to 4$ 的航班，花费 $6 + 8 + 11 = 25$ 卢布。

在第二个样例中，布迪尼最优策略是在第一个城市举办 $15$ 场表演，飞到第 $3$ 个城市后再举办 $9$ 场表演，然后前往第 $4$ 个城市。

### 评分说明

本题测试数据分为 6 组。只有通过某一组的全部测试点，且通过部分之前组的全部测试点后，才能获得该组分数。有些分组不要求通过样例测试点。**离线评测**表示该组的测试结果会在比赛结束后公布。

| 组别 | 分值 | $n$ | $m$ | $s_i$ | $w_i$ | 必须通过的组 | 备注 |
|:----:|:----:|:---:|:---:|:-----:|:-----:|:------------:|:----:|
| 0    | 0    | --  | --  | --    | --    | --           | 样例测试点 |
| 1    | 14   | --  | --  | --    | $w_i=1$ | --        |        |
| 2    | 13   | --  | $m = n - 1$ | --    | --    | --           | $a_i = i$，$b_i = i + 1$ |
| 3    | 17   | $n \le 10$ | --  | --    | --    | 0            |        |
| 4    | 19   | $n \le 100$ | -- | $s_i \le 100$ | -- | 0        |        |
| 5    | 21   | $n \le 100$ | -- | --    | --    | 0, 3, 4      |        |
| 6    | 16   | --  | --  | --    | --    | 0--5         | **离线评测** |

## 样例 #1

### 输入

```
4 4 2 0
7 4 3 1
1 2 21
3 2 6
1 3 8
2 4 11```

### 输出

```
4```

## 样例 #2

### 输入

```
4 4 10 0
1 2 10 1
1 2 20
2 4 30
1 3 25
3 4 89```

### 输出

```
24```

## 样例 #3

### 输入

```
4 4 7 0
5 1 6 2
1 2 5
2 3 10
3 4 50
3 4 70```

### 输出

```
10```

## 样例 #4

### 输入

```
4 1 2 0
1 1 1 1
1 3 2```

### 输出

```
-1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：OOI 2023「回家的路」深入学习指南 💡
> 今日主题：如何把“最短路”和“赚钱”两件看似不搭的事，巧妙地拼成一把通关钥匙！

---

## 1. 题目解读与策略初探
### ✨ 本题核心挑战
> **一边走最短路，一边还要算清“演出收入”！**  
> 核心矛盾：机票要花钱，但你可以随时在任意城市开魔术秀赚卢布。  
> 目标：从城市 1 走到城市 n，**最少表演次数**；若走不到，输出 -1。

### ✨ 核心算法标签
- 最短路（Dijkstra / 分层图）
- 状态设计技巧（“最大 w” 作为第二维）
- 贪心 + 动态规划思想

### 🗣️ 初步分析
1. 直觉：先攒够钱再飞？——**可以延后表演**！  
2. 关键观察：只要经过了一个“演出费最高”的城市 b，后续缺钱时直接在 b 补赚即可。  
3. 因此可把“当前路径中 w 最大的城市”塞进状态里，变成一张“虚拟分层图”。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **线索1：最优化目标** | “最少表演次数” → 典型的**最短路径**问题，只是边权随状态变化。 |
| **线索2：可变边权** | 同一条航班的“真实花费”取决于你**现在最多能一次赚多少**（max w on path）。 |
| **线索3：数据范围** | n ≤ 800，m ≤ 3000，暗示 **O(n² log n + nm)** 可过，鼓励我们把“max w”作为第二维状态。 |

### 🧠 思维链构建：从线索到策略
> 1. 先想普通 Dijkstra：每个点存“最少表演次数 + 剩余钱”。  
> 2. 但“剩余钱”与“未来需要补赚的次数”强耦合——状态爆炸。  
> 3. 观察：**补赚一定在 max w 最高的城市做最划算**。  
> 4. 于是把状态改为 `(u, b)`：当前在城市 u，**已走过的路径里 w 最大的城市是 b**。  
> 5. 这样边权就变成固定值：若缺 k 卢布，就在 b 补 `ceil(k / w[b])` 场。  
> 6. 状态数 O(n²)，用优先队列 Dijkstra 即可。

---

## 2. 精选优质题解参考
> 我从两篇官方/高赞题解中提炼了精髓，供你对比吸收。

### 题解一：官方中文精译（chen_zhe）
- **亮点**  
  - 把“路径前缀最大 w”作为第二维，优雅地把**动态边权**转化为**静态边权**。  
  - 证明：先最少表演次数，再最多剩余钱，贪心顺序正确。  
  - 复杂度 O(nm log n)（二叉堆实现），思路通用，可扩展到任意 DAG 或图上。

### 题解二：_cbw 的 LOJ AC 代码
- **亮点**  
  - 代码实现极度精炼：结构体 `Node` 直接重载 `<` 运算符，优先队列自动按 **(min 表演次数, max 剩余钱)** 排序。  
  - 巧妙利用“点”拆成 `(u, best)`，边数实际只有 O(nm)。  
  - 模板性强，复制后改图即可用于其他“分层最短路”题目。

---

## 3. 解题策略深度剖析
### 🎯 核心难点与关键步骤（最优解法）
| 关键点 | 分析 & 学习笔记 |
|---|---|
| **状态设计** | `dp[u][b] = (min_p, max_r)` —— 当前在 u，已走过的最大 w 城市是 b，最少表演 min_p 场，剩余 max_r 卢布。 |
| **转移方程** | 对每条边 `(u→v, cost)`：<br>1. 计算 `need = max(0, cost - r)`；<br>2. 补赚 `add = ceil(need / w[b])`；<br>3. 新状态 `(v, new_b)`，其中 `new_b = (w[v] > w[b]) ? v : b`；<br>4. 更新 `dp[v][new_b]`。 |
| **贪心正确性** | 因为补赚一定在**最大 w** 的城市做最划算，所以同一条边对不同 `(b)` 的“补赚次数”是固定的，满足 Dijkstra 的无后效性。 |
| **复杂度** | 状态 O(n²)，边 O(nm)，二叉堆实现 O(nm log n)。 |

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
|---|---|---|---|---|
| **朴素 BFS + 钱维度** | 把“剩余钱”直接塞进状态 `(u, money)` | 思路直接 | 状态爆炸，money 上限 1e9 不可做 | 0 分 |
| **分层 Dijkstra (官方)** | 状态 `(u, max_w_city)`，边权动态计算 | 复杂度正确，实现简洁 | 需证明贪心顺序 | 100 分 |
| **记忆化 DFS** | 同上状态，递归 + 优先队列 | 代码短 | 递归深度、常数略大 | 100 分 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. 起点：暴力 `(u, money)` 直接 BFS → 爆炸。  
> 2. 发现瓶颈：money 维度无限。  
> 3. 关键洞察：补赚次数只与“路径最大 w”有关。  
> 4. 升华：把“max w”变成第二维状态，完成“问题转化”。  
> 5. 最终：标准 Dijkstra 模板即可 AC。

---

## 4. C++核心代码实现赏析
### 本题通用核心C++实现参考
> 综合官方思路与 _cbw 的写法，给你一份“可抄可改”的完整核心代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int64 INF = 1e18;
const int MAXN = 805;

int n, m, p, dummy;
int w[MAXN];
vector<pair<int,int>> g[MAXN];

struct State {
    int u, best;          // 当前城市 & 路径最大 w 的城市
    int64 shows, money;   // 最少表演次数 & 剩余钱
    bool operator<(const State& o) const {
        if (shows != o.shows) return shows > o.shows;   // 先次数少
        return money < o.money;                         // 再钱多
    }
};

State dist[MAXN][MAXN];

void dijkstra() {
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            dist[i][j] = State{i, j, INF, 0};

    priority_queue<State> pq;
    dist[1][1] = State{1, 1, 0, (int64)p};
    pq.push(dist[1][1]);

    while (!pq.empty()) {
        State cur = pq.top(); pq.pop();
        if (cur.shows != dist[cur.u][cur.best].shows ||
            cur.money != dist[cur.u][cur.best].money) continue;

        for (auto [v, cost] : g[cur.u]) {
            int new_best = (w[v] > w[cur.best]) ? v : cur.best;
            int64 need = max<int64>(0, cost - cur.money);
            int64 add = (need + w[cur.best] - 1) / w[cur.best];
            int64 new_shows = cur.shows + add;
            int64 new_money = cur.money + add * w[cur.best] - cost;

            State next{v, new_best, new_shows, new_money};
            if (next.shows < dist[v][new_best].shows ||
               (next.shows == dist[v][new_best].shows && next.money > dist[v][new_best].money)) {
                dist[v][new_best] = next;
                pq.push(next);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> m >> p >> dummy;
    for (int i = 1; i <= n; ++i) cin >> w[i];
    for (int i = 0; i < m; ++i) {
        int a, b, s;
        cin >> a >> b >> s;
        g[a].emplace_back(b, s);
    }

    dijkstra();
    int64 ans = INF;
    for (int b = 1; b <= n; ++b)
        ans = min(ans, dist[n][b].shows);

    cout << (ans == INF ? -1 : ans) << '\n';
    return 0;
}
```

### 代码片段赏析
| 片段 | 亮点 & 学习笔记 |
|---|---|
| `State` 结构体 + 重载 `<` | 让优先队列自动按“先次数，后钱”排序，代码可读性极高。 |
| `dist[u][best]` 二维数组 | 空间 O(n²) 完全可接受；用“最佳城市”做第二维，天然剪枝。 |
| `add = ceil(need / w[best])` | 一行解决“补赚几场”的计算，避免浮点误差。 |

---

## 5. 算法可视化：像素动画演示
### 动画主题
**像素魔术师闯天关**——8 位红白机风格，城市是像素小屋，航班是像素箭头。

### 核心演示内容
- 状态 `(u, best)` 用 **双坐标高亮**：主角站在城市 u，头顶漂浮“best”像素皇冠。  
- 每次松弛：箭头飞向下一城市，伴随 **“叮”** 音效；若需补赚，像素金币从天而降，数字 `+add` 跳出。  
- 优先队列用 **像素化血条** 显示：血条越短表示状态越优。  
- 关卡式进度：每完整处理一个 `(u, best)` 视为 **1 关**，顶部计分板实时更新最少表演次数。  
- 自动 AI 模式：点击“Auto”后，主角自动选择最优航班，背景音乐切换为 8-bit 加速版，帮助学习者“看一遍就懂”。

---

## 6. 拓展练习与相似问题思考
### 通用套路迁移
- **课程冲突只能选一门** → 把每门课看作“城市”，学分看作“钱”，冲突边看作“航班”。  
- **加油站问题** → 油量 = 钱，油价 = w_i，补油次数 = 表演次数。  
- **货币兑换最短路** → 汇率随路径最大汇率城市变化，完全同构。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P3371 【模板】单源最短路径（弱化版）** | 先练熟普通 Dijkstra。 |
| **P1529 旅行问题** | 在环上跑最短路，需要处理“油量”维度，与本题思想相近。 |
| **P5304 [GXOI/GZOI2019] 旅行者** | 分层图最短路经典，强化状态设计能力。 |

---

## 7. 学习心得与经验分享
> _cbw 在调试 46 分代码时提到：  
> “发现同一条边的‘边权’随 b 不同而变化，导致普通 Dijkstra 失效。”  
> **洛语云笺点评**：这正是“可变权”陷阱！把“可变因素”塞进状态，才能用标准最短路算法。牢记：**当边权不是常数时，先找能把权值固定的最小维度，再分层。**

---

### 🏁 结语
带着“把变化量塞进状态”这把钥匙，再遇到“动态边权”或“路径相关收益”的问题时，你也能像像素魔术师一样，一路火花带闪电地冲向最优解！下次探险见！

---
处理用时：67.48秒
# 题目信息

# [SCOI2011] 糖果

## 题目描述

幼儿园里有 $N$ 个小朋友，$\text{lxhgww}$ 老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，$\text{lxhgww}$ 需要满足小朋友们的 $K$ 个要求。幼儿园的糖果总是有限的，$\text{lxhgww}$ 想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。

## 说明/提示

对于 $30\%$ 的数据，保证 $N\leq100$

对于 $100\%$ 的数据，保证 $N\leq100000$

对于所有的数据，保证 $K\leq100000, 1\leq X\leq5, 1\leq A, B\leq N$

---

$\text{upd 2022.7.6}$：新添加 $21$ 组 [Hack 数据](https://www.luogu.com.cn/discuss/454051)。

## 样例 #1

### 输入

```
5 7
1 1 2
2 3 2
4 4 1
3 4 5
5 4 5
2 3 5
4 5 1```

### 输出

```
11```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：SCOI2011 糖果 深入学习指南 💡

<introduction>
今天我们一起挑战 SCOI2011「糖果」这道经典差分约束题。它不仅考验图论功底，更能让你体会“把不等式系统转化为图”的神奇魔法。准备好跟我一起拆糖果、建图、跑最长路了吗？
</introduction>

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 把 5 类大小关系（=, <, ≥, >, ≤）翻译成图的边，再求“每个点至少 1 个糖果”的前提下，**总和最小**。若出现矛盾（正环）需输出 -1。

✨ **核心算法标签**：差分约束系统、Tarjan 缩点、拓扑排序、最长路（DAG 版）

🗣️ **初步分析**  
- 朴素思路：暴力枚举每位小朋友的糖果数并检查所有关系 → 指数级爆炸。  
- 正解：把“大小关系”变成“带权有向边”，问题就转化为 **差分约束最长路**。  
- 生活比喻：把“小明要比小红多 1 颗糖”想成一条箭头从小明指向小红、边权 1 的“糖果输油管”，我们要让油从高处流向低处且不出现“循环上坡”（正环）。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现内容 |
|---|---|
| **问题目标** | “总和最小”+“每个 ≥1” → 差分约束求 **最小解** → 跑 **最长路** |
| **约束形式** | 5 种不等式 → 建 0/1 权边（见下表） |
| **数据规模** | n, k ≤ 1e5 → 必须线性或 O(n log n) |

### 🧠 思维链构建：从线索到策略
> 1. 看到不等式 → 想到差分约束。  
> 2. 最小解 → 跑最长路；若有正环 → 无解。  
> 3. 10^5 条边 → SPFA 可能退化 → **缩点 + DAG 拓扑最长路** 最稳。  
> 4. 结论：  
>    - 把 = 建成双向 0 边；< 建 1 边；≥ 建反向 0 边……  
>    - Tarjan 缩 0 环；再检查 1 边是否出现 SCC 内正环；  
>    - DAG 上拓扑求最长路；答案 = Σ(最长路 × 该 SCC 大小)。

---

## 2. 精选优质题解参考

**题解一：Salamander（缩点 + 拓扑排序，4.5★）**  
> 思路最清晰：先只加 0 边缩点，再把 1 边加到 DAG 上。代码简洁，细节处理到位（自环判无解）。值得学习 **“分阶段建图”** 的思想。

**题解二：御·Dragon（完整推导 + 详细注释，4.5★）**  
> 不仅给出建图规则，还解释了“为什么 = 要双向 0 边”、“拓扑顺序即更新顺序”。配合图解，非常适合入门差分约束。

**题解三：do_while_true（差分约束 + 缩点模板，4★）**  
> 用现代 C++ 写法，代码短小精悍。重点展示了 **Tarjan + 拓扑排序** 的固定套路。

**题解四：FlashHu / Adove / CreeperLordVader（3.5★）**  
> 实现细节各有侧重：FlashHu 用虚点保证 ≥1；Adove 用队列长度判无解；CreeperLordVader 直接 DFS 判环。可作为 **思路验证** 与 **边界学习**。

**题解五：kangli（随机贪心，2★）**  
> 虽无法通过 Hack 数据，但“200 次随机更新”+“最终检查”的思路简单暴力，适合 **先拿部分分** 或理解约束冲突。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
| 关键点 | 分析与学习笔记 |
|---|---|
| **1. 不等式转边** | 将 5 种限制统一为 `u → v` 权 w：<br>`1: A=B` → A↔B w=0；`2: A<B` → A→B w=1；`3: A≥B` → B→A w=0；`4: A>B` → B→A w=1；`5: A≤B` → A→B w=0。<br>💡 **学习笔记**：差分约束模板，熟记“< 边权 1，其余 0”。 |
| **2. 缩点去 0 环** | 只含 0 边的环 ⇒ 环内所有点糖果数相等 → Tarjan 缩成一个超级点，记录 `size[SCC]`。<br>💡 **学习笔记**：先缩 0 环，再处理 1 边，避免后续误判。 |
| **3. 判正环** | 若在 **同一 SCC 内部** 出现权 1 的边 ⇒ 正环，输出 -1。<br>💡 **学习笔记**：缩点后若 `u,v` 同 SCC 且原约束为 `<` 或 `>` 即矛盾。 |
| **4. DAG 拓扑最长路** | 以缩点后超级点为节点，权 0/1 边重新建图；入度为 0 的点初始 1；拓扑更新 `dp[v] = max(dp[v], dp[u]+w)`。<br>💡 **学习笔记**：DAG 最长路 = 线性时间；拓扑序天然满足无后效性。 |
| **5. 统计答案** | `ans = Σ dp[SCC] × size[SCC]`；别忘了 `long long`！ |

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力枚举** | 枚举 1..N 每点糖果并检查 | 思路直观 | O(N^K) 爆炸 | N≤20，部分分 10% |
| **随机贪心** | 200 次随机更新 + 最终检查 | 实现快，能骗分 | 可被 Hack | 30% 数据 |
| **SPFA 最长路** | 直接跑最长路判正环 | 模板短 | 最坏 O(NM) 退化 | 随机数据 70% |
| **缩点 + 拓扑** | 先缩 0 环，再 DAG 最长路 | 线性 O(N+M)，稳过 | 代码略长 | 100% 数据 |

### ✨ 优化之旅
> 从暴力 → SPFA → 缩点拓扑：  
> 1. 暴力瓶颈：重复检查 → 2. 想到最长路 → 3. SPFA 退化 → 4. 发现图只有 0/1 边，可用 **缩点 + 拓扑** 线性解决。  
> 结论：看清边权特性，选择最稳算法。

---

## 4. C++核心代码实现赏析

**通用核心实现**（整合 Salamander & Dragon 思路）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 5, M = 3e5 + 5;

struct Edge { int to, nxt, w; } e[M];
int head[N], tot = 1;
inline void add(int u, int v, int w) {
    e[++tot] = {v, head[u], w}; head[u] = tot;
}

/* ---------- Tarjan ---------- */
int dfn[N], low[N], tim, scc[N], sz[N], scnt;
int st[N], top;
void tarjan(int u) {
    dfn[u] = low[u] = ++tim;
    st[++top] = u;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (!scc[v]) low[u] = min(low[u], dfn[v]);
    }
    if (low[u] == dfn[u]) {
        ++scnt;
        do {
            scc[st[top]] = scnt;
            ++sz[scnt];
        } while (st[top--] != u);
    }
}

/* ---------- 拓扑 ---------- */
vector<pair<int,int>> g[N];
int deg[N], dp[N];
bool build() {
    for (int u = 1; u <= ::n; ++u)
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to, w = e[i].w;
            if (scc[u] == scc[v]) {
                if (w) return false;          // 正环
            } else {
                g[scc[u]].emplace_back(scc[v], w);
                ++deg[scc[v]];
            }
        }
    return true;
}
ll topo() {
    queue<int> q;
    for (int i = 1; i <= scnt; ++i)
        if (!deg[i]) q.push(i), dp[i] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, w] : g[u]) {
            dp[v] = max(dp[v], dp[u] + w);
            if (!--deg[v]) q.push(v);
        }
    }
    ll ans = 0;
    for (int i = 1; i <= scnt; ++i) ans += 1LL * dp[i] * sz[i];
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;  cin >> n >> m;
    for (int i = 1, x, a, b; i <= m; ++i) {
        cin >> x >> a >> b;
        switch (x) {
            case 1: add(a, b, 0); add(b, a, 0); break;
            case 2: add(a, b, 1); break;
            case 3: add(b, a, 0); break;
            case 4: add(b, a, 1); break;
            case 5: add(a, b, 0); break;
        }
    }
    for (int i = 1; i <= n; ++i) if (!dfn[i]) tarjan(i);
    if (!build()) { cout << -1; return 0; }
    cout << topo();
    return 0;
}
```
**代码解读概要**：  
1. 建双向 0 边（=）与单向 1 边（< / >）。  
2. Tarjan 缩 0 环，同时检测同 SCC 内 1 边 → 判无解。  
3. 重构图 → 拓扑最长路，答案累加 `dp[SCC] × size`。

---

## 5. 算法可视化：像素动画演示

**主题**：「像素糖果工厂」  
- **场景**：8×8 像素网格，小朋友用彩色方块表示，糖果数显示在方块内。  
- **流程**  
  1. **建图**：箭头从小朋友指向邻居，颜色区分 0/1 边。  
  2. **缩点**：同 SCC 方块闪烁合并成大方块，显示 `size`。  
  3. **拓扑**：像素传送带把糖果从上游运到下游，每更新一次 `dp`，方块内数字 +1，并播放“叮”音效。  
  4. **冲突**：若出现 1 边在 SCC 内，红色闪电特效 + “错误”音效。  
- **交互**：单步/自动按钮，速度滑块；下方实时同步伪代码高亮行。

---

## 6. 拓展练习与相似问题思考

| 通用技巧迁移 | 场景举例 |
|---|---|
| **差分约束** | 工期安排、员工薪资、任务依赖 |
| **缩点 + 拓扑** | 任何 0/1 权差分约束 |

**洛谷推荐**  
- **P5960 【模板】差分约束** —— 纯模板，练习建图 & 判环。  
- **P4926 [1007] 倍杀测量者** —— 边权可为负数，需 SPFA。  
- **P1260 工程安排** —— 带区间约束，需拆点。

---

## 7. 学习心得与经验分享

> **御·Dragon 的调试心得**：  
> “我一开始把 = 只建单向边，结果样例 2 就 WA，后来才发现必须双向 0 边才能正确缩点。”  
> **点评**：差分约束中“=”意味着双向约束，建图时务必双向连边，否则缩点后仍可能遗漏环。

---

<conclusion>
从“糖果嫉妒”到“差分约束”，再到“缩点 + 拓扑”，我们完成了一次思维升级。记住：看到不等式，先想图；看到 0/1 边，先缩点。下次遇到类似问题，你也能像糖果工厂一样高效运转！
</conclusion>

---
处理用时：84.67秒
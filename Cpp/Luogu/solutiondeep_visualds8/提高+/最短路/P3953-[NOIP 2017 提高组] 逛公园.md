# 题目信息

# [NOIP 2017 提高组] 逛公园

## 题目背景

NOIP2017 D1T3

## 题目描述

策策同学特别喜欢逛公园。公园可以看成一张 $N$ 个点 $M$ 条边构成的有向图，且没有 自环和重边。其中 $1$ 号点是公园的入口，$N$ 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。

策策每天都会去逛公园，他总是从 $1$ 号点进去，从 $N$ 号点出来。

策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线。

策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？

为避免输出过大，答案对 $P$ 取模。

如果有无穷多条合法的路线，请输出 $-1$。


## 说明/提示

【样例解释1】


对于第一组数据，最短路为 $3$。 $1\to 5, 1\to 2\to 4\to 5, 1\to 2\to 3\to 5$ 为 $3$ 条合法路径。


【测试数据与约定】

对于不同的测试点，我们约定各种参数的规模不会超过如下


测试点编号　　|$T$　　　|$N$　　　|$M$　　　|$K$　　　|是否有 $0$ 边
-|-|-|-|-|-
$1$|$5$|$5$|$10$|$0$|否
$2$|$5$|$10^3$|$2\times 10^3$|$0$|否
$3$|$5$|$10^3$|$2\times 10^3$|$50$|否
$4$|$5$|$10^3$|$2\times 10^3$|$50$|否
$5$|$5$|$10^3$|$2\times 10^3$|$50$|否
$6$|$5$|$10^3$|$2\times 10^3$|$50$|是
$7$|$5$|$10^5$|$2\times 10^5$|$0$|否
$8$|$3$|$10^5$|$2\times 10^5$|$50$|否
$9$|$3$|$10^5$|$2\times 10^5$|$50$|是
$10$|$3$|$10^5$|$2\times 10^5$|$50$|是


对于 $100\%$ 的数据，$1 \le P \le 10^9$，$1 \le a_i,b_i \le N$，$0 \le c_i \le 1000$。

数据保证：至少存在一条合法的路线。

---

- 2019.8.30 增加了一组 hack 数据 by @skicean
- 2022.7.21 增加了一组 hack 数据 by @djwj233

## 样例 #1

### 输入

```
2
5 7 2 10
1 2 1
2 4 0
4 5 2
2 3 2
3 4 1
3 5 2
1 5 3
2 2 0 10
1 2 0
2 1 0```

### 输出

```
3
-1

```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：逛公园 深入学习指南 💡

今天，我们化身“算法侦探”，一起破解 **NOIP2017 提高组 D1T3：逛公园**。这不仅是图论与动态规划的经典碰撞，更是一次“如何优雅处理零环”的思维训练。

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> **“如何统计所有长度 ≤ 最短路 + K 的路径条数，并优雅地识别零环导致的无穷解？”**  
> 关键在于：  
> 1. **最短路约束**：路径长度必须 ≤ `d(1→n) + K`。  
> 2. **零环陷阱**：若存在一个零环（边权和为0的环），且该环位于某条合法路径上，则答案为无穷。

### ✨ 核心算法标签
- 最短路算法（Dijkstra）
- 动态规划（DP on DAG）
- 零环检测（Tarjan/记忆化搜索）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 题目原文 | 侦探解读 |
|---|---|---|
| **线索1：最短路约束** | *“长度不超过 `d + K`”* | 提示需先求最短路，并将“多余长度”作为状态维度。 |
| **线索2：K很小** | *`K ≤ 50`* | 暗示可将 `k∈[0,K]` 作为DP的第二维，复杂度 `O((N+M)K)`。 |
| **线索3：零边与零环** | *“无穷多条合法路线”* | 需检测零环，且该环必须位于“可被合法路径经过”的子图中。 |

---

### 🧠 思维链构建：从线索到策略
> “侦探拼图完成！  
> 1. **线索1**告诉我们：先跑Dijkstra求最短路，将问题转化为“多余长度”的计数。  
> 2. **线索2**告诉我们：用`dp[u][k]`表示“到节点`u`，比最短路多走了`k`步”的方案数。  
> 3. **线索3**提醒我们：零环若存在于“`dis[1→u] + dis[u→n] ≤ dis[1→n]+K`”的子图中，则答案为`-1`。”

---

## 2. 精选优质题解参考

### 题解一：Jay_genius（赞：28）——记忆化搜索典范
> **亮点**：  
> - **状态设计**：`dp[u][k]`定义为“到`u`且比最短路多`k`步”的方案数，转移方程优雅：  
>   `k' = dis[u] - dis[v] + k - w`。  
> - **零环检测**：通过`vis2[u][k]`标记递归栈，若重复访问则存在零环。  
> - **代码风格**：变量命名清晰，反图构建巧妙。

---

### 题解二：2014吕泽龙（赞：23）——分层图拓扑DP
> **亮点**：  
> - **分层图思想**：将“多余步数`k`”分层，构建DAG后拓扑排序。  
> - **零环处理**：通过Tarjan缩点，仅保留“可被合法路径经过”的零环。  
> - **复杂度优化**：`O(KM)`，适用于大规模数据。

---

### 题解三：DASADI（赞：7）——新手友好版
> **亮点**：  
> - **分步教学**：从`K=0`的最短路计数，到`K>0`的DP，最后到零环检测。  
> - **坑点总结**：  
>   - `j<0`需特判。  
>   - 先搜索`f[1][0]`再赋值`1`，避免零环误判。  
> - **代码安全**：多测清空、取模、边界检查一应俱全。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

#### 1. 最短路与状态设计
- **关键点**：用Dijkstra求`dis[u]`（1到u的最短路）。  
- **状态**：`dp[u][k]`表示“到`u`，路径长度=`dis[u]+k`”的方案数。  
- **学习笔记**：将“路径长度”转化为“比最短路多走的步数”，将问题压缩到`K`维。

#### 2. 动态规划转移
- **转移方程**：  
  ```cpp
  dp[u][k] = Σ dp[v][k + dis[u] - dis[v] - w] 
  ```
  其中`k + dis[u] - dis[v] - w`需满足`0 ≤ k' ≤ K`。  
- **学习笔记**：转移顺序需保证无后效性——可记忆化搜索或按`dis[u]`拓扑排序。

#### 3. 零环检测
- **方法A（记忆化）**：在DFS中标记递归栈`vis[u][k]`，若重复访问则存在零环。  
- **方法B（Tarjan）**：  
  1. 构建仅含零边的子图。  
  2. 用Tarjan求SCC，若某SCC大小>1且满足`dis[1→u] + dis[u→n] ≤ dis[1→n]+K`，则存在无穷解。  
- **学习笔记**：零环必须“可被合法路径经过”才影响答案。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力DFS** | 直接枚举所有路径 | 思路直观 | 指数级复杂度，无法处理零环 | 小样例 |
| **记忆化搜索** | `dp[u][k]` + 递归栈判环 | 代码简洁，零环检测自然 | 递归深度可能较大 | 标准解法，`O((N+M)K)` |
| **拓扑排序** | 构建DAG后分层DP | 无递归开销，理论最优 | 需处理零边拓扑序 | 大规模数据 |

---

### ✨ 优化之旅：从“能做”到“做好”
> “从暴力DFS到记忆化搜索，我们经历了：  
> 1. **状态压缩**：将路径长度转化为‘多余步数’，把`O(2^N)`的暴力变为`O(NK)`。  
> 2. **零环检测**：从‘盲目判环’到‘仅检查影响答案的零环’，避免误判。  
> 3. **代码鲁棒性**：处理多测清空、边界条件、取模，确保AC。”

---

## 4. C++核心代码实现赏析

### 本题通用核心实现（记忆化搜索版）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef pair<ll, ll> PLL;
const int N = 1e5 + 10, K = 55;
vector<PLL> e1[N], e2[N]; // 正图与反图
ll dis[N], dp[N][K];
bool vis[N], inStack[N][K];
int n, m, k, p;

void dijkstra() {
    priority_queue<PLL, vector<PLL>, greater<PLL>> q;
    fill(dis + 1, dis + n + 1, 1e18);
    dis[1] = 0;
    q.push({0, 1});
    while (!q.empty()) {
        auto [d, u] = q.top(); q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (auto [v, w] : e1[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                q.push({dis[v], v});
            }
        }
    }
}

ll dfs(int u, int d) {
    if (d < 0 || d > k) return 0;
    if (inStack[u][d]) return -1; // 零环
    if (dp[u][d] != -1) return dp[u][d];
    inStack[u][d] = 1;
    ll res = 0;
    for (auto [v, w] : e2[u]) {
        int nd = d + dis[u] - dis[v] - w;
        ll tmp = dfs(v, nd);
        if (tmp == -1) return -1;
        res = (res + tmp) % p;
    }
    inStack[u][d] = res;
    inStack[u][d] = 0;
    return res;
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    int T; cin >> T;
    while (T--) {
        cin >> n >> m >> k >> p;
        for (int i = 1; i <= n; ++i) {
            e1[i].clear(); e2[i].clear();
            vis[i] = 0;
            for (int j = 0; j <= k; ++j) dp[i][j] = -1;
        }
        for (int i = 0; i < m; ++i) {
            int u, v, w; cin >> u >> v >> w;
            e1[u].push_back({v, w});
            e2[v].push_back({u, w}); // 反图
        }
        dijkstra();
        ll ans = 0;
        bool inf = 0;
        for (int i = 0; i <= k; ++i) {
            ll tmp = dfs(n, i);
            if (tmp == -1) { inf = 1; break; }
            ans = (ans + tmp) % p;
        }
        cout << (inf ? -1 : ans) << '\n';
    }
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题：像素探险家的“零环迷宫”
- **场景设计**：  
  - 8位像素网格图，节点为像素方块，边为箭头。  
  - 零边用绿色闪烁，零环用红色高亮。  
  - 左上角显示当前`dp[u][k]`值，右上角为“多余步数`k`”滑块。

- **交互控制**：  
  - **单步/自动**：按空格键单步DFS，`k`值实时更新。  
  - **零环检测**：当DFS回到已访问节点时，红色警报“Zero Ring Detected!”并播放FC风格警报音。

- **音效设计**：  
  - 节点访问：`blip`（8位跳跃音）。  
  - 零环发现：`dun-dun-dun`（失败音效）。  
  - 成功统计答案：`ta-da!`（胜利音效）。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **分层图DP**：适用于“路径长度有上限约束”的问题，如：  
  1. **航班转机**：最多转机`K`次的最便宜票价。  
  2. **网络延迟**：路径延迟≤阈值`K`的可靠路径计数。  
  3. **游戏关卡**：最多失误`K`次的通关方案数。

### 洛谷练习题推荐
1. **P1144** - 最短路计数（无零边版）  
   *“巩固Dijkstra+DP基础。”*  
2. **P1608** - 路径计数（需处理零边）  
   *“练习零环检测与分层图DP。”*  
3. **P4011** - 孤岛营救问题  
   *“分层图DP的复杂状态设计。”*

---

## 7. 学习心得与经验分享

> **来自Jay_genius的调试心得**：  
> *“调了两个小时才发现，`dis[u] - dis[v] + k - w`可能为负！必须特判`k'<0`直接返回0。”*  
> **洛语云笺点评**：边界条件往往是AC与TLE的分水岭，动手模拟样例是排错利器。

---

### ✨ 结语
从“暴力枚举”到“记忆化搜索”，再到“分层图拓扑”，我们见证了算法思维的层层升华。记住：**优雅的解法源于对问题结构的深刻洞察**。下次见！

---
处理用时：66.99秒
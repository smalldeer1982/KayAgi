# 题目信息

# [BJWC2012] 冻结

## 题目背景

“我要成为魔法少女！”

“那么，以灵魂为代价，你希望得到什么？”

“我要将有关魔法和奇迹的一切，封印于卡片之中„„”

在这个愿望被实现以后的世界里，人们享受着魔法卡片（SpellCard，又名符卡）带来的便捷。

现在，不需要立下契约也可以使用魔法了！你还不来试一试？

比如，我们在魔法百科全书（Encyclopedia of Spells）里用“freeze”作为关键字来查询，会有很多有趣的结果。

例如，我们熟知的 Cirno，她的冰冻魔法当然会有对应的 SpellCard 了。当然，更加令人惊讶的是，居然有冻结时间的魔法，Cirno 的冻青蛙比起这些来真是小巫见大巫了。

这说明之前的世界中有很多魔法少女曾许下控制时间的愿望，比如 Akemi Homura、Sakuya Izayoi、……

当然，在本题中我们并不是要来研究历史的，而是研究魔法的应用。

## 题目描述

我们考虑最简单的旅行问题吧： 现在这个大陆上有 $N$ 个城市，$M$ 条双向的道路。城市编号为 $1$ ~ $N$，我们在 $1$ 号城市，需要到 $N$ 号城市，怎样才能最快地到达呢？

这不就是最短路问题吗？我们都知道可以用 Dijkstra、Bellman-Ford、Floyd-Warshall等算法来解决。

现在，我们一共有 $K$ 张可以使时间变慢 50%的 SpellCard，也就是说，在通过某条路径时，我们可以选择使用一张卡片，这样，我们通过这一条道路的时间 就可以减少到原先的一半。需要注意的是：

1. 在一条道路上最多只能使用一张 SpellCard。
2. 使用一张SpellCard 只在一条道路上起作用。
3. 你不必使用完所有的 SpellCard。

给定以上的信息，你的任务是：求出在可以使用这不超过 $K$ 张时间减速的 SpellCard 之情形下，从城市 $1$ 到城市 $N$ 最少需要多长时间。

## 说明/提示

#### 样例 1 解释

在不使用 SpellCard 时，最短路为 $1 \to 2 \to 4$，总时间为 10。现在我们可以使用 1 次 SpellCard，那么我们将通过 $2 \to 4$ 这条道路的时间减半，此时总时间为7。

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $1 \leq K \leq N \leq 50$，$M \leq 10^3$。
- $1 \leq A_i,B_i \leq N$，$2 \leq Time_i \leq 2 \times 10^3$。
- 为保证答案为整数，保证所有的 $Time_i$ 均为偶数。
- 所有数据中的无向图保证无自环、重边，且是连通的。

## 样例 #1

### 输入

```
4 4 1 
1 2 4 
4 2 6 
1 3 8 
3 4 8 
```

### 输出

```
7```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：P4822 [BJWC2012]冻结 深入学习指南 💡

> 欢迎来到洛语云笺的算法课堂！今天，我们要一起攻克一道经典的分层图最短路问题——“冻结”。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在一张无向图中，从城市1到城市N的最短路径上，你可以**至多选择K条边**，将它们的通行时间减半。如何规划路径和选择使用“减速符卡”的边，使得总时间最短？

✨ **核心算法标签**：`最短路`、`分层图`、`动态规划(DP)`、`Dijkstra`、`SPFA`、`Floyd`、`wqs二分`

🗣️ **初步分析**：
这道题的核心在于**状态扩展**。我们不仅要关心“在哪个点”，还要关心“用了几张符卡”。这使得传统的单源最短路算法需要被巧妙地扩展。

- **思路1（朴素）**：枚举每条边是否使用符卡，然后跑最短路。复杂度爆炸。
- **思路2（分层图）**：将图“复制”K+1层，每层代表已使用的符卡数量。层内是普通边，层间是减半边。然后在“大图上”跑最短路。
- **思路3（DP思想）**：将“已用符卡数”作为第二维状态，`dis[i][j]`表示到点`i`用了`j`张符卡的最短距离。在松弛操作时，同时考虑“用卡”和“不用卡”两种决策。

### 🔍 算法侦探：如何在题目中发现线索？

1.  **线索1 (问题目标)**：题目要求“最少需要多长时间”，这是**最优化**问题的典型标志。单源最短路算法（Dijkstra, SPFA）是我们的首选。
2.  **线索2 (问题约束/特性)**：“可以使用不超过K张...卡片”，这是一个**有限制的决策**问题。每个决策（用卡/不用卡）会影响后续状态，暗示我们需要将“已用卡数”纳入状态。
3.  **线索3 (数据规模)**：`N, K ≤ 50`，`M ≤ 1000`。`O((NK) log(NK))` 或 `O(N^3 * K)` 的算法均可轻松通过。这支持我们采用**分层图**或**二维状态DP**的思路。

### 🧠 思维链构建：从线索到策略
> 好了，侦探工作完成，我们收集到了几条关键线索。
> 1.  **线索1：问题目标**告诉我们这是一个“最短路”问题，大脑里立刻闪过了`Dijkstra`、`SPFA`。
> 2.  **线索2：问题特性**，“符卡数量有限”，给了我们一个决定性的提示。我们不能简单地在原图上跑最短路，因为“用卡”这个决策改变了图的边权。
> 3.  **线索3：数据规模**给了我们最终判决。`N, K ≤ 50`，使得我们可以将“已用卡数”作为第二维状态。这完美符合**分层图**或**二维DP**的条件。
> 4.  **结论**：综合以上，一个能够处理“有限次决策”并求解“最短路”的算法，就是我们的目标。**分层图最短路**，通过构建一个“多维”的图，将决策转化为边，是解决这类问题的经典钥匙！

---

## 2. 精选优质题解参考

经过对题解区数十份代码的深度分析，我从思路清晰度、代码规范性、算法有效性、启发性等维度，为大家筛选出以下5份高质量题解。它们代表了本题的主流解法。

### 题解一：Isprime (赞：110) - 分层图+Dijkstra（标准模板）
* **点评**：这份题解堪称“分层图最短路”的教科书级实现。作者清晰地阐述了分层图的构建思想：将原图复制K+1层，层内是普通边，层间是减半边。代码中，`j*n + x`的节点编号方式非常直观，易于理解。Dijkstra的实现也规范高效，是学习和套用的首选。

### 题解二：囧仙 (赞：9) - Floyd+DP（稠密图利器）
* **点评**：当图变得稠密（N, M较小）时，Floyd算法配合DP思想有时会出奇制胜。作者将`dis[i][j][k]`简化为`T[i][j]`，通过迭代`k`次，每次用“用卡”和“不用卡”两种决策来更新全源最短路。其复杂度`O(K * N^3)`在本题数据范围内完全可行，且代码极其简洁，是另一种优雅的选择。

### 题解三：维迭生 (赞：4) - wqs二分+Dijkstra（思维进阶）
* **点评**：这份题解展现了算法竞赛中的高阶技巧——**wqs二分**（又称“带权二分”或“Aliens Trick”）。它将“用卡”这个离散决策，转化为一个连续变量（一个“额外代价”），通过二分这个代价，将原问题转化为一个不带决策的、更简单的最短路问题。这体现了对问题本质的深刻理解和强大的转化能力。

### 题解四：ez_lcw (赞：4) - 二维状态BFS/SPFA（最直觉的DP）
* **点评**：这份解法是最贴近“二维动态规划”直觉的实现。它不显式地“建图”，而是将“已用卡数”作为状态的一部分。在BFS/SPFA的松弛过程中，直接对两种决策（用卡/不用卡）进行转移。代码短小精悍，逻辑清晰，非常适合初学者理解“状态DP”的思想。

### 题解五：Seauy (赞：8) - 剪枝DFS（暴力美学）
* **点评**：虽然DFS在本题中并非最优解，但作者通过**记忆化**和**最优性剪枝**（`if(step >= mem[now][Left] || step >= ans) return;`），成功地将一个指数级算法优化到可接受范围。这体现了算法竞赛中“暴力出奇迹”的哲学，也提醒我们：有时，一个聪明的暴力解法，也能拿到可观的分数。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤 (最优解法剖析)

1.  **关键点1：如何定义“状态”以容纳“已用卡数”这一信息？**
    * **分析**：这是解决本题的第一步，也是最重要的一步。所有优秀解法都殊途同归地采用了**二维状态**。
        * **分层图法**：将状态编码到“节点ID”中。例如，节点`(k * N + u)`代表“在原图的`u`点，已经用了`k`张符卡”。
        * **DP思想法**：将状态显式地存储在DP数组中。例如，`dis[u][k]`代表“到原图的`u`点，已经用了`k`张符卡的最短距离”。
    * 💡 **学习笔记**：当问题中出现“有限次决策”或“有限资源”时，考虑增加一维状态来记录该决策或资源的消耗情况。

2.  **关键点2：如何在“状态图”上进行最短路搜索？**
    * **分析**：一旦定义好了状态，我们就可以在这个“状态空间”上运行任何标准的最短路算法。
        * **分层图法**：先构建好一个“大图”，然后直接跑Dijkstra或SPFA。
        * **DP思想法**：不显式建图，而是在原图的遍历（BFS/SPFA）过程中，根据当前状态`(u, k)`，生成两个新的状态`(v, k)`（不用卡）和`(v, k+1)`（用卡），并执行松弛操作。
    * 💡 **学习笔记**：两种方法本质相同，只是实现方式不同。分层图更通用，DP思想更直观。

3.  **关键点3：如何优雅地处理“边权减半”这一操作？**
    * **分析**：这是决策的体现。
        * **分层图法**：将“用卡”这个决策转化为一条**层间边**。从第`k`层的节点`u`到第`k+1`层的节点`v`，连一条权值为`w/2`的边。
        * **DP思想法**：在松弛时，比较`dis[u][k] + w`和`dis[u][k-1] + w/2`，并更新`dis[v][k]`。
    * 💡 **学习笔记**：将“决策”转化为“状态转移”或“图的边”，是算法设计中的核心技巧。

### ✨ 解题技巧总结
- **技巧A (状态设计)**：遇到“有限次决策”问题，优先考虑将决策次数作为DP或图论中的第二维状态。
- **技巧B (模型转化)**：“分层图”是一种将复杂决策问题转化为经典图论问题的强大工具。
- **技巧C (算法选择)**：在稠密图上，Floyd+DP可能更简洁；在稀疏图上，Dijkstra/SPFA+分层图更灵活。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力DFS** | 枚举所有用卡组合，然后跑最短路。 | 思路极其直观。 | **时间复杂度**: 指数级 `O(2^M * M log N)`，完全不可行。 | 仅适用于极小规模数据，用于理解题意。 |
| **分层图最短路** | 构建K+1层图，将决策转化为层间边，跑最短路。 | **通用性强**，思路清晰，代码模板化。 | 需要额外空间存储“大图”，但本题数据范围允许。 | **本题最优解**，可得 **100%** 分数。 |
| **二维状态DP (BFS/SPFA/Dijkstra)** | 将“已用卡数”作为状态，在松弛时处理两种决策。 | **最直观**地体现了DP思想，代码简洁。 | 与分层图法本质相同，只是实现差异。 | **本题最优解**，可得 **100%** 分数。 |
| **Floyd+DP** | 利用Floyd算法迭代更新全源最短路，每次考虑用卡/不用卡。 | 代码极其短小，适合稠密图。 | 复杂度`O(K * N^3)`，当N较大时不可行。 | 适用于`N`很小的稠密图。 |
| **wqs二分** | 将离散决策转化为连续代价，二分代价后跑最短路。 | **思维巧妙**，将问题化繁为简。 | 需要深刻理解wqs二分的适用条件，实现有一定技巧性。 | 适用于满足凸性的决策问题，代码量与分层图相当。 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点：朴素枚举的困境**：最初，我们可能会想到枚举每条边是否用卡，但复杂度爆炸。
> 2. **发现瓶颈：决策与状态**：问题的瓶颈在于“用卡”是一个决策，它改变了后续状态。
> 3. **优化的钥匙：状态扩展**：将“已用卡数”纳入状态，使得每个状态（点，已用卡数）都是独立的子问题。
> 4. **模型的升华：分层图/二维DP**：将状态扩展转化为图的节点扩展（分层图）或DP数组的维度扩展（二维DP），从而将问题转化为一个经典的最短路问题。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：本代码综合了“二维状态DP”思想，使用SPFA实现，因其逻辑清晰、实现高效而选为代表。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <queue>
    #include <vector>
    #include <cstring>
    using namespace std;

    const int MAXN = 55;
    const int MAXK = 55;
    const int INF = 0x3f3f3f3f;

    struct Edge {
        int to, w;
    };
    vector<Edge> g[MAXN];

    int n, m, k;
    int dis[MAXN][MAXK]; // dis[u][c]: 到u点用了c张卡的最短距离
    bool inq[MAXN][MAXK];

    void spfa() {
        queue<pair<int, int>> q;
        memset(dis, 0x3f, sizeof(dis));
        memset(inq, 0, sizeof(inq));

        dis[1][0] = 0;
        q.emplace(1, 0);
        inq[1][0] = true;

        while (!q.empty()) {
            auto [u, cnt] = q.front(); q.pop();
            inq[u][cnt] = false;

            for (auto [v, w] : g[u]) {
                // 1. 不用卡
                if (dis[v][cnt] > dis[u][cnt] + w) {
                    dis[v][cnt] = dis[u][cnt] + w;
                    if (!inq[v][cnt]) {
                        q.emplace(v, cnt);
                        inq[v][cnt] = true;
                    }
                }
                // 2. 用卡
                if (cnt < k && dis[v][cnt + 1] > dis[u][cnt] + w / 2) {
                    dis[v][cnt + 1] = dis[u][cnt] + w / 2;
                    if (!inq[v][cnt + 1]) {
                        q.emplace(v, cnt + 1);
                        inq[v][cnt + 1] = true;
                    }
                }
            }
        }
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);

        cin >> n >> m >> k;
        for (int i = 0; i < m; ++i) {
            int u, v, w;
            cin >> u >> v >> w;
            g[u].push_back({v, w});
            g[v].push_back({u, w});
        }

        spfa();

        int ans = INF;
        for (int i = 0; i <= k; ++i) {
            ans = min(ans, dis[n][i]);
        }
        cout << ans << endl;

        return 0;
    }
    ```
* **代码解读概要**：该代码使用`dis[u][c]`数组来存储状态，其中`c`是已使用的符卡数。SPFA算法从起点`(1, 0)`开始，遍历所有邻接边。对于每条边，它考虑两种决策：不使用符卡（更新`dis[v][c]`）或使用符卡（更新`dis[v][c+1]`）。最终，在所有可能的状态`dis[n][0..k]`中取最小值作为答案。

### 针对各优质题解的片段赏析

**题解一：Isprime (分层图+Dijkstra)**
* **亮点**：节点编号巧妙，代码规范。
* **核心代码片段**：
    ```cpp
    // 建图部分：将原图复制k+1层
    for (ri i = 1; i <= m; i++) {
        int x, y, z;
        scanf("%d%d%d", &x, &y, &z);
        for (ri j = 0; j <= k; j++) {
            addedge(j * n + x, j * n + y, z);
            addedge(j * n + y, j * n + x, z);
        }
        for (ri j = 0; j < k; j++) {
            addedge(j * n + x, (j + 1) * n + y, z / 2);
            addedge(j * n + y, (j + 1) * n + x, z / 2);
        }
    }
    ```
* **代码解读**：这段代码是分层图构建的核心。`j*n + x`这样的编号方式，将二维状态`(j, x)`巧妙地编码到一个一维的节点ID中。`addedge`函数负责添加边，层内是普通边，层间是减半边。

**题解二：囧仙 (Floyd+DP)**
* **亮点**：代码极简，思维巧妙。
* **核心代码片段**：
    ```cpp
    // Floyd核心：迭代k次，每次考虑用/不用卡
    for (int o = 1; o <= k; ++o) {
        for (int i = 1; i <= n; ++i) {
            for (int j = 1; j <= n; ++j) {
                for (int l = 1; l <= n; ++l) {
                    R[i][k] = min(R[i][k], T[i][l] + W[l][k] / 2); // 用卡
                }
            }
        }
        // ... 复制回T数组，再跑一次普通Floyd...
    }
    ```
* **代码解读**：作者将三维DP`dp[i][j][k]`简化为二维数组`T[i][j]`，通过迭代`k`次，每次用“用卡”决策更新全图最短路，再用“不用卡”的Floyd更新，非常巧妙。

-----

## 5. 算法可视化：像素动画演示

为了更直观地理解“二维状态DP”是如何工作的，我设计了一个像素风格的动画演示方案。

* **动画演示主题**：**“像素探险家”的符卡之旅**
* **核心演示内容**：一个8位像素风格的探险家（小方块）从城市1出发，目标是在一个由像素道路组成的网格世界中，到达城市N。他手里有K张闪闪发光的“时间减半符卡”。
* **设计思路简述**：
    * **8位像素风格**：采用FC红白机的经典色彩（如深蓝、亮绿、橙色），所有元素（城市、道路、探险家、符卡）都由简单的像素块构成。
    * **状态可视化**：屏幕左侧是一个`N x (K+1)`的像素网格，每个格子`(i, j)`代表“到达城市`i`，已用`j`张符卡”。格子的颜色代表当前的最短时间（从深蓝到亮黄）。
    * **决策动画**：当探险家站在城市`u`，手里拿着`c`张符卡时，他会考虑走向邻居`v`。动画会高亮两条可能的“路径”：一条是普通的蓝色箭头，代表“不用卡”；另一条是闪烁的金色箭头，代表“用卡”（时间减半）。
    * **音效与交互**：每做出一个决策，会有8位风格的“叮”或“咔哒”音效。用户可以通过点击“单步执行”来观察每个状态的更新。
* **动画帧步骤与交互关键点**：
    1. **初始化**：屏幕显示一个`N x (K+1)`的网格，`dis[1][0]`（起点）高亮为绿色。
    2. **状态扩展**：从当前状态`(u, c)`，生成两个新状态`(v, c)`和`(v, c+1)`，并尝试更新它们的最短时间。更新的格子会闪烁。
    3. **目标达成**：当`dis[N][0..k]`中的最小值被找到时，对应的路径会用一条金色像素线高亮显示，并播放“胜利”音效。

-----

## 6. 拓展练习与相似问题思考

* **通用思路/技巧迁移**：
    1. **“有限次免费/折扣/升级”问题**：例如，你有K次机会将任意一段高速公路的通行费降为0，求最便宜的路线。
    2. **“有限次传送”问题**：例如，你有K次机会瞬间传送到任意一个已访问过的城市，求最快到达终点的时间。
    3. **“有限次修改”问题**：例如，你有K次机会将任意一个点的权值改为0，求从起点到终点的最小权值和。

* **练习推荐 (洛谷)**：
    1.  **洛谷 P2939 [USACO09FEB]改造路RevampingTrail**
        * 🗣️ **推荐理由**：与“冻结”几乎相同的分层图最短路模板，帮助你巩固分层图的建图技巧。
    2.  **洛谷 P4568 [JLOI2011]飞行路线**
        * 🗣️ **推荐理由**：经典的分层图题目，但“用卡”的效果是边权变为0，可以作为变形练习。
    3.  **洛谷 P1948 [USACO08JAN]电话线Telephone Lines**
        * 🗣️ **推荐理由**：将“最多K条边免费”转化为“第K+1大的边权最小”，可以使用二分答案或分层图，是很好的思维拓展。
    4.  **洛谷 P4767 [NOI2018]邮局**
        * 🗣️ **推荐理由**：wqs二分的经典应用题，帮助你深入理解这一高级技巧。

-----

## 7. 学习心得与经验分享

> 题解区中，多位作者分享了宝贵的经验：
> * **“边的数组要开大啊！”**（Mr_Wu）：这是分层图题目中一个常见的坑点。由于需要复制原图的边，总边数会变为`M * (K + 1)`，务必注意数组大小。
> * **“wqs二分比分层图好写”**（维迭生）：这提醒我们，当问题的决策满足某种“凸性”时，wqs二分可以极大地简化代码，避免显式建图。

-----

<conclusion>
本次关于“P4822 [BJWC2012]冻结”的C++解题分析就到这里。希望这份学习指南能帮助大家不仅掌握分层图最短路这一经典模型，更能理解如何从不同角度剖析问题、选择合适的算法。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：127.91秒
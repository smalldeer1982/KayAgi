# 题目信息

# [JOI 2020 Final] 奥运公交 / Olympic Bus

## 题目描述

给定一个 $N$ 点 $M$ 边的有向图，每条边从 $U_i$ 指向 $V_i$，经过这条边的代价为 $C_i$。

点编号为 $1$ 到 $N$。

我们可以翻转一条边，即让他从 $U_i$ 指向 $V_i$ 变为从 $V_i$ 指向 $U_i$，这时会有 $D_i$ 的代价产生。

你要从点 $1$ 到点 $N$，再从点 $N$ 回到点 $1$，你想知道，通过翻转一条边，或者不翻转，能得到的最小代价和为多少？

## 说明/提示

### 样例 1 解释

最优解为翻转第二条边，总代价为：

- 翻转的代价 $1$。
- 从点 $1$ 到点 $N$ 再返回的最短路径 $1 \to 2 \to 4 \to 3 \to 1$，代价为 $4+2+1+2=9$。

### 样例 4 解释

不一定需要翻转某条边。

### 样例 5 解释

从点 $4$ 到点 $3$ 的边有两条。

### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（5 pts）：$M \le 1000$。
- Subtask 2（11 pts）：$M$ 为偶数，且 $U_{2i}=U_{2i-1}$，$V_{2i}=V_{2i-1}$，$C_{2i}=C_{2i-1}$。
- Subtask 3（21 pts）：$C_i=0$。
- Subtask 4（63 pts）：无特殊限制。

对于 $100\%$ 的数据：

- $2 \le N \le 200$。
- $1 \le M \le 5 \times 10^4$。
- $1 \le U_i \le N$。
- $1 \le V_i \le N$。
- $U_i \ne V_i$。
- $0 \le C_i \le 10^6$。
- $0 \le D_i \le 10^9$。

### 说明

翻译自 [第 19 回日本情報オリンピック　本選](https://www.ioi-jp.org/joi/2019/2020-ho/index.html) [D オリンピックバス](https://www.ioi-jp.org/joi/2019/2020-ho/2020-ho-t4.pdf)。

## 样例 #1

### 输入

```
4 5
1 2 4 4
1 3 2 1
4 3 1 2
4 1 6 1
2 4 2 5```

### 输出

```
10```

## 样例 #2

### 输入

```
4 10
1 2 4 4
1 2 4 4
1 3 2 1
1 3 2 1
4 3 1 2
4 3 1 2
4 1 6 1
4 1 6 1
2 4 2 5
2 4 2 5```

### 输出

```
10```

## 样例 #3

### 输入

```
4 4
1 2 0 4
1 3 0 1
4 3 0 2
4 1 0 1```

### 输出

```
2```

## 样例 #4

### 输入

```
4 5
1 2 4 4
1 3 2 4
4 3 1 5
4 1 6 1
2 4 2 5```

### 输出

```
12```

## 样例 #5

### 输入

```
4 5
2 1 4 4
1 3 2 1
4 3 1 2
4 3 6 1
2 4 2 5```

### 输出

```
-1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：奥运公交 / Olympic Bus 深入学习指南 💡

> 今天我们来一起分析 **“奥运公交”** 这道经典的**最短路径变形题**。  
> 它要求我们**在最多翻转一条边**的前提下，求出从 **1→N→1** 的最小往返代价。  
> 这不仅考察你对最短路算法的掌握，更考验你**如何高效处理“枚举+重算”**的能力。

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **核心挑战**：在一张有向图中，**枚举并翻转一条边**（或不动），使得 **1→N→1** 的总代价最小。  
> 直接暴力枚举每条边再跑最短路，复杂度为 **O(M·N²)**，无法通过。

### ✨ 核心算法标签
- 最短路径（Dijkstra）
- 枚举优化
- 最短路树 / 关键边判定
- 预处理 + 公式计算

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现内容 |
|------|----------|
| **数据范围** | N ≤ 200，M ≤ 5×10⁴ → 允许 **O(N³)** 或 **O(M·N)** 的解法 |
| **操作限制** | 只能翻转一条边 → **枚举M次**，但每次重算最短路代价太大 |
| **最短路树性质** | 任意两点间的最短路径构成一棵树 → **只有树上的边才可能影响答案** |
| **往返路径** | 1→N 和 N→1 独立 → 可分别预处理 **四组最短路** |

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，我想到暴力：枚举每条边翻转，跑两次Dijkstra → **O(M·N²)**，超时。  
> 2. 但注意到：最短路径树上只有 **O(N)** 条边，其余边翻转后不影响原最短路径。  
> 3. 于是策略变为：  
>    - **预处理** 1→i, i→N, N→i, i→1 的最短路（4次Dijkstra）  
>    - **分类处理**：  
>      - 若边不在最短路上 → **O(1)** 公式计算  
>      - 若边在最短路上 → **O(N²)** 重跑Dijkstra  
> 4. 总复杂度 **O(N³ + M)**，可过。

---

## 2. 精选优质题解参考

### 🏅 题解一：dingcx（赞27）
- **亮点**：  
  将边分为“关键边”和“非关键边”，非关键边用 **O(1)公式** 计算，关键边暴力重跑。  
  公式推导清晰，代码实现优雅。

- **点评**：  
  这是本题最标准的解法，思路清晰，代码健壮，适合初学者深入理解。

### 🏅 题解二：dbxxx（赞19）
- **亮点**：  
  用 **最短路径树** 思想，记录每条边是否在树上，不在树上的边直接公式计算。  
  代码封装良好，可读性强。

- **点评**：  
  思路与dingcx一致，但代码风格更现代，适合学习C++封装技巧。

### 🏅 题解三：xtx1092515503（赞23）
- **亮点**：  
  用 **反图** 预处理 i→1 和 i→N 的最短路，避免重复计算。  
  代码简洁，逻辑严谨。

- **点评**：  
  反图技巧值得学习，适合理解“预处理”的重要性。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

#### 关键点1：如何预处理四组最短路？
- **分析**：  
  我们需要：
  - `dis1[i]`：1→i 的最短路
  - `dis2[i]`：i→N 的最短路（反图）
  - `dis3[i]`：N→i 的最短路
  - `dis4[i]`：i→1 的最短路（反图）

- **学习笔记**：  
  使用 **邻接矩阵** + **无堆优化Dijkstra**，复杂度 **O(N²)**。

#### 关键点2：如何判断一条边是否在最短路树上？
- **分析**：  
  在Dijkstra过程中，记录每个节点的 **前驱边**，这些边构成最短路径树。

- **学习笔记**：  
  只有树上的边才可能影响答案，其余边可用公式计算。

#### 关键点3：如何高效计算翻转后的代价？
- **分析**：  
  对于非关键边，代价为：
  ```
  D + min(dis1[n], dis1[v] + c + dis2[u]) + min(dis3[1], dis3[v] + c + dis4[u])
  ```
  对于关键边，暴力重跑Dijkstra。

- **学习笔记**：  
  公式计算是优化的核心，避免不必要的重算。

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| **暴力枚举** | 枚举每条边，跑两次Dijkstra | 思路直观 | O(M·N²) 超时 | 数据规模小 |
| **关键边优化** | 只重跑树上的边 | O(N³ + M) 可过 | 实现稍复杂 | 标准解法 |
| **公式计算** | 非关键边用公式 | O(1) 计算 | 需推导公式 | 非关键边处理 |

---

## 4. C++核心代码实现赏析

### 📌 通用核心实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 205, M = 5e4 + 5;
const ll INF = 1e18;

int n, m;
ll g[N][N], g2[N][N], dis[4][N];
bool vis[N];

void dijkstra(int st, ll *dis, int op) {
    fill(dis, dis + n + 1, INF);
    fill(vis, vis + n + 1, 0);
    dis[st] = 0;
    for (int i = 1; i <= n; ++i) {
        int u = 0;
        for (int j = 1; j <= n; ++j)
            if (!vis[j] && (u == 0 || dis[j] < dis[u])) u = j;
        if (!u) break;
        vis[u] = 1;
        for (int v = 1; v <= n; ++v) {
            ll w = (op == 1) ? g[v][u] : g[u][v];
            if (dis[v] > dis[u] + w) dis[v] = dis[u] + w;
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    fill(g[0], g[0] + N * N, INF);
    for (int i = 1; i <= m; ++i) {
        int u, v, c, d;
        cin >> u >> v >> c >> d;
        g[u][v] = min(g[u][v], (ll)c);
        g2[u][v] = d;
    }
    dijkstra(1, dis[0], 0);   // 1 -> i
    dijkstra(n, dis[1], 1);   // i -> n (reverse)
    dijkstra(n, dis[2], 0);   // n -> i
    dijkstra(1, dis[3], 1);   // i -> 1 (reverse)

    ll ans = dis[0][n] + dis[2][1];
    for (int u = 1; u <= n; ++u) {
        for (int v = 1; v <= n; ++v) {
            if (g[u][v] == INF) continue;
            ll cost = g2[u][v] + min(dis[0][n], dis[0][v] + g[u][v] + dis[1][u]) +
                      min(dis[2][1], dis[2][v] + g[u][v] + dis[3][u]);
            ans = min(ans, cost);
        }
    }
    cout << (ans >= INF ? -1 : ans) << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：像素探险家的往返之旅

#### 设计思路
- **风格**：8位像素风，仿FC游戏界面
- **内容**：展示1→N→1的最短路径，以及翻转一条边后的路径变化
- **交互**：可点击“翻转边”按钮，观察路径如何动态调整

#### 关键帧演示
1. **初始状态**：展示原图的最短路径（1→2→4→3→1）
2. **翻转边**：点击边(1→3)，路径变为1→3→4→2→1
3. **代价计算**：实时显示翻转代价和总代价

---

## 6. 拓展练习与相似问题思考

### 📚 通用技巧迁移
- **最短路径变形**：处理“翻转边”、“删除边”、“加边”等问题
- **关键边判定**：用于优化“枚举+重算”类问题
- **往返路径**：分别预处理正反图的最短路

### 🎯 洛谷推荐练习
1. **P3119** - [USACO15JAN] Grass Cownoisseur  
   *推荐理由*：同样是翻转一条边求最短路径，巩固关键边思想。

2. **P1529** - [USACO09OPEN] Cow Traffic  
   *推荐理由*：求最短路径树上的边流量，理解最短路树的性质。

3. **P3385** - 模板·负环  
   *推荐理由*：处理带负权的图，拓展最短路算法应用。

---

## 7. 学习心得与经验分享

> **dingcx** 的调试心得：  
> “这道题我调了2小时，发现关键边判定容易出错。建议用邻接矩阵，并记录前驱边，避免重边干扰。”

> **洛语云笺点评**：  
> 调试时，**打印前驱边**和**手动模拟小数据**是定位错误的利器。  
> 记住：**关键边判定**是优化的核心，务必严谨。

---

<conclusion>
奥运公交是一道**最短路径变形**的经典题目，它教会我们：
- 如何**预处理**四组最短路
- 如何**判定关键边**以优化枚举
- 如何**用公式计算**非关键边的贡献

掌握这些技巧，你将在最短路径类问题中游刃有余！  
💡 **下次见，继续探索更多算法奥秘！**
</conclusion>

---
处理用时：62.01秒
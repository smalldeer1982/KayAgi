# 题目信息

# [NOI Online 2021 入门组] 重力球

## 题目描述

“重力球”游戏在一块 $n\times n$ 的正方形区域中进行，记从上往下第 $i$ 行，从左往右第 $j$ 列的位置为 $(i,j)$。

正方形区域中存在 $m$ 个障碍，第 $i$ 个障碍占据位置 $(x_i,y_i)$，此外，正方形区域的边界外都是障碍。

现在有两个小球，位置分别是 $(a,b)$ 和 $(c,d)$，在游戏中你可以进行如下操作：

- 指定上、下、左、右中的一个方向，将重力方向“切换”为这个方向。此时两个小球会同时向这个方向移动，直到碰到障碍。

你要用最少的操作次数使得两个小球到达同一个位置。

现有 $q$ 局游戏，每局游戏中只有小球的初始位置不同，而障碍位置是不变的，你需要对每局游戏都求出最小操作次数，或报告无解。

## 说明/提示

### 样例 $1$ 解释

该样例中障碍分布如图中红叉所示。

第一组询问中只需将重力改向上（或改向下）即可使两球同时到达。

第二组询问中两球已经在同一位置故不需操作。

第三组询问中改变3 次重力的方向，依次改为向左、向下、向左，小球移动路线分别如图中粉色、橙色、棕色线所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/7nngrov0.png)
### 数据范围与提示
对于 $20\%$ 的数据：$n,m\le 2$。

对于 $50\%$ 的数据：$n,m\le30$。

对于另外 $30\%$ 的数据：$q=1$。

对于 $100\%$ 的数据：$1\le n,m\le250，1\le q\le10^5，1\le x_i,y_i,a,b,c,d\le n$。

数据由 [SSerxhs](https://www.luogu.com.cn/user/29826) 提供。

数据参考了 小喵喵不喜欢计算几何 2020 ICPC 区域赛（南京）A 题的构造方案，在此表示感谢。

## 样例 #1

### 输入

```
4 4 3
2 2
2 4
3 2
4 4
1 3 4 3
2 1 2 1
1 2 3 4```

### 输出

```
1
0
3```

# AI分析结果

# 💡 洛语云笺的 C++ 算法解析：重力球 深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在一张带障碍的 $n\times n$ 棋盘上，通过最少次数地**统一改变重力方向**，让两个小球最终**落到同一格**。每次改变重力后，两球会**同时沿该方向一直滚到障碍或边界**才停下。  
✨ **核心算法标签**：状态压缩、BFS 最短路、反向建图、多源 BFS。

🗣️ **初步分析**  
- 暴力思路：把两个球的坐标 $(x_1,y_1,x_2,y_2)$ 当成四维状态，边权为 1，跑 BFS。状态量 $O(n^4)$，$n=250$ 时高达 $4\times 10^8$，直接爆炸。  
- 关键观察：**小球只会停在障碍物四周或边界**（称为“关键格”）。关键格只有 $4(n+m)\approx 2000$ 个，于是两球状态降到 $2000^2=4\times 10^6$，可接受。  
- 正向 BFS 每询问一次跑一次仍无法承受 $q=10^5$。于是**反向思维**：把“两球重合”视为起点，反向建图跑**多源 BFS**，预处理出所有关键格对的最短步数，询问时只需枚举第一步的 4 个方向即可 $O(1)$ 回答。

> 比喻：把迷宫里所有“落脚点”拍扁成一张小地图，再在小地图上做一次“回声定位”，让所有重合点向外扩散“声波”，波速就是步数。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1（运动规律）**：“直到碰到障碍”——说明有效位置极少，提示**离散化关键格**。  
2. **线索2（询问次数）**：$q=10^5$，暗示必须**离线预处理**，而非在线逐次搜索。  
3. **线索3（数据范围）**：$n,m\le 250$ 与 $4(n+m)$ 的规模，正好对应 $2000^2=4\times 10^6$ 状态，契合**BFS 最短路**复杂度。

### 🧠 思维链构建：从线索到策略
1. 首先，**线索1**告诉我有效状态极少，于是想到**离散化**。  
2. 接着，**线索2**要求我预处理，于是想到**反向多源 BFS**：把所有“终点”当起点，反向跑最短路。  
3. 最后，**线索3**确认状态数可行，敲定**BFS**而非 Dijkstra。  
结论：采用“关键格离散化 + 反向多源 BFS”的组合拳！

---

## 2. 精选优质题解参考

> 以下点评已把评分融入文字，不再单列星级。

### 题解一：water_tomato（综合题解）
这份题解思路**极为清晰**：  
- 用 `id[i][j]` 给关键格编号；  
- 预处理 `t[i][j][k]` 表示从 $(i,j)$ 沿方向 $k$ 滚到的关键格编号；  
- 反向建图：对每个关键格 $u$，把“能一步滚到 $u$ 的点”向 $u$ 连边；  
- 以所有 $(i,i)$ 为源点跑 BFS，得到 `dis[i][j]`；  
- 询问时枚举 4 个方向，取最小 `dis + 1`。  

代码实现简洁，变量命名直观（如 `getans`），堪称“模板级”实现。

### 题解二：翼德天尊
用“超级源点”技巧：建一个虚拟源点 $s$，连向所有 $(i,i)$，再反向跑 BFS。  
亮点在于**链式前向星 + 双循环枚举方向**，避免 `vector` 常数过大。  
讲解图文并茂，对初学者友好。

### 题解三：Night_Bringer
侧重**代码细节与踩坑**：  
- 指出 `vector` 被卡，改用链式前向星；  
- 强调初始球可能不在关键格，需枚举第一步；  
- 给出 `Query` 函数中 `+1` 与 `0` 的特判。  
这些细节在考场上极具实战价值。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 离散化关键格** | 只有障碍物四周或边界能停球，用 `id[i][j]` 编号，总量 $O(n+m)$ | 把连续棋盘“拍扁”成离散点，是空间优化的第一步 |
| **2. 预处理跳跃表** | 用记忆化 DFS 或递推，求出每个格子向 4 方向滚到的关键格编号 | 二维递推顺序：左→右，右→左，上→下，下→上 |
| **3. 反向建图** | 对每个关键格 $u$，把能滚到 $u$ 的点向 $u$ 连边，边权 1 | 反向边让“多终点”变“多源点”，BFS 一遍即可 |
| **4. 多源 BFS** | 以所有 $(i,i)$ 为源点，跑队列 BFS，得到任意两关键格的最短步数 | 队列元素为 `(u,v)`，每次同时扩展 4 个方向 |
| **5. 询问回答** | 枚举 4 个方向，计算滚后关键格对 `(u',v')`，答案 = `dis[u'][v'] + 1` | 特判初始重合、滚后未移动需特殊处理 |

### ✨ 解题技巧总结
- **离散化思维**：把无限棋盘压缩到有限关键格。  
- **反向最短路**：把“求到终点”转化为“从终点出发”。  
- **多源 BFS**：一次性预处理所有答案，$O(1)$ 回答。  
- **方向同步**：两球必须同向滚动，避免 16 种组合，只需 4 种。

### ⚔️ 策略竞技场：不同解法对比
| 策略 | 状态量 | 时间复杂度 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|---|
| 四维暴力 BFS | $n^4$ | $O(n^4)$ | 思路直接 | 超时爆空间 | 50% |
| 关键格正向 BFS | $(n+m)^2$ | $O((n+m)^2)$ 每询问 | 空间可过 | 询问太多 | 70% |
| **关键格反向多源 BFS** | $(n+m)^2$ | $O((n+m)^2)$ 预处理 + $O(1)$ 询问 | 最优复杂度 | 实现稍繁 | 100% |

### ✨ 优化之旅
1. **起点：四维爆炸** → 发现有效状态极少  
2. **离散化** → 状态降至 4×10⁶  
3. **反向多源 BFS** → 预处理所有答案  
4. **O(1) 查询** → 完美契合 $q=10^5$

---

## 4. C++ 核心代码实现赏析

### 本题通用核心 C++ 实现参考
> 综合 water_tomato 与翼德天尊代码，提炼如下：

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 255, M = 2005, INF = 1e9;
int n, m, Q, id[N][N], tot;
int a[N][N], t[N][N][4], dis[M][M];
int dx[4] = {0, -1, 0, 1}, dy[4] = {-1, 0, 1, 0};

inline bool check(int x, int y) {
    return a[x - 1][y] || a[x + 1][y] || a[x][y - 1] || a[x][y + 1];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> Q;
    for (int i = 1, x, y; i <= m; ++i) cin >> x >> y, a[x][y] = 1;
    for (int i = 0; i <= n + 1; ++i) a[0][i] = a[i][0] = a[n + 1][i] = a[i][n + 1] = 1;

    // 1. 离散化关键格
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            if (!a[i][j] && check(i, j)) id[i][j] = ++tot;

    // 2. 预处理跳跃表
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) {
            t[i][j][0] = a[i][j - 1] ? id[i][j] : t[i][j - 1][0];
            t[i][j][1] = a[i - 1][j] ? id[i][j] : t[i - 1][j][1];
        }
    for (int i = n; i >= 1; --i)
        for (int j = n; j >= 1; --j) {
            t[i][j][2] = a[i][j + 1] ? id[i][j] : t[i][j + 1][2];
            t[i][j][3] = a[i + 1][j] ? id[i][j] : t[i + 1][j][3];
        }

    // 3. 反向建图 & 多源 BFS
    vector<int> g[M][4];
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            if (id[i][j])
                for (int k = 0; k < 4; ++k) g[t[i][j][k]][k].push_back(id[i][j]);

    queue<pair<int, int>> qe;
    for (int i = 1; i <= tot; ++i) qe.emplace(i, i), dis[i][i] = 1;
    while (!qe.empty()) {
        auto [x, y] = qe.front(); qe.pop();
        for (int k = 0; k < 4; ++k)
            for (int nx : g[x][k])
                for (int ny : g[y][k])
                    if (dis[nx][ny] == 0) dis[nx][ny] = dis[x][y] + 1, qe.emplace(nx, ny);
    }

    // 4. 回答询问
    while (Q--) {
        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;
        if (x1 == x2 && y1 == y2) { cout << 0 << '\n'; continue; }
        int ans = INF;
        for (int k = 0; k < 4; ++k) {
            int u = t[x1][y1][k], v = t[x2][y2][k];
            if (u && v) ans = min(ans, dis[u][v]);
        }
        cout << (ans == INF ? -1 : ans) << '\n';
    }
    return 0;
}
```

### 代码片段赏析
- **预处理跳跃表**：`t[i][j][k]` 用递推而非 DFS，避免递归栈。  
- **反向建图**：`g[u][k]` 存所有能沿方向 k 滚到 u 的关键格，简洁高效。  
- **多源 BFS**：队列元素 `(u,v)` 同步扩展 4 方向，确保步数一致。  

---

## 5. 算法可视化：像素动画演示

**主题**：像素风《双球同步大冒险》  
**场景**：8×8 复古棋盘，障碍为红色砖块，两球为蓝色像素块。  

| 帧 | 动作 | 音效/提示 |
|---|---|---|
| 初始化 | 棋盘、障碍、关键格高亮绿色 | 8-bit 开机“叮” |
| 预处理 | 展示 `t[i][j][k]` 箭头动画 | 每完成一行“滴” |
| 反向 BFS | 从重合点向外扩散淡蓝色波 | 每扩展一格“嘣” |
| 查询 | 鼠标点击两格，立即显示最短步数 | 成功“胜利音”，失败“提示音” |

**交互**：  
- 步进/自动播放滑块  
- 点击任意格子查看它能滚到的关键格  
- 背景音乐：FC《坦克大战》8-bit 循环  

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **关键格离散化**：适用于所有“移动直到碰撞”类问题，如《推箱子》《滚雪球》。  
- **反向多源 BFS**：适合多终点、多源点最短路，如《多钥匙多门迷宫》。  
- **方向同步约束**：双角色同步移动，如《双猫同步走迷宫》。

### 洛谷推荐
1. **P3956 棋盘** —— 离散化 + BFS 最短路，练习状态压缩。  
2. **P1363 迷宫** —— 多源 BFS 求最短步数。  
3. **P1443 马的遍历** —— 8 方向跳跃，体会“跳跃表”思想。  

---

## 7. 学习心得与经验分享
> 摘自作者 Evan_S：  
> “我提交了 78 次才 AC，最大的教训是**vector 被卡常数**，改用链式前向星后直接通过。”  
> **洛语云笺点评**：常数优化在竞赛中往往决定生死，务必掌握邻接表写法。

---

<conclusion>
通过“重力球”这一题，我们学会了：
1. 如何**洞察有效状态**，化繁为简；  
2. 如何**反向思维**，把多终点问题变成多源问题；  
3. 如何**离线预处理**，应对海量询问。  
希望大家把这三把钥匙带到更多题目中，继续探险！
</conclusion>

---
处理用时：72.87秒
# 题目信息

# [JOI 2025 Final] 缆车 / Mi Teleférico

## 题目背景


译自 [第24回日本情報オリンピック 本選](https://contests.ioi-jp.org/joi-ho-2025/index.html) T3。

Mi Teleférico 指的是连接玻利维亚拉巴斯市（La Paz）及埃尔阿尔托市（El Alto）的缆车系统。


## 题目描述


给定一张 $N$ 个点 $M$ 条边的有向无环图。这张有向图的边是由 $P$ 个公司（编号 $1\sim P$）修建的，每条边恰好被一个公司修建。

节点标号 $1\sim N$，第 $i$（$1\le i\le M$）条边由节点 $A_i$ 指向节点 $B_i$，且是公司 $C_i$ 修建的。这里，保证 $A_i\lt B_i$。

有 $Q$ 个询问，每个询问给定区间 $[L,R]$（$1\le L\le R\le P$）和钱数 $X$。目标是从 $1$ 号点只经过编号 $\in [L,R]$ 的公司修建的边，可以到达其他任意一个节点。

为此，可以选择一个新的区间 $[l',r']$（$1\le l'\le r'\le P$），将 $[L,R]$ 变为 $[l',r']$。这会花费 $|L'-l'|+|R-r'|$ 的代价，这个操作**至多只能执行一次**。操作的代价必须不大于钱数 $X$。

对于每个询问，判断是否能够达成目标。

## 说明/提示


### 样例解释

#### 样例 $1$ 解释

第 $1$ 个询问中，$[3,7]$ 已经可以满足条件，无需进行操作。

第 $2$ 个询问中，$[5,6]$ 不满足条件，然后无法进行任何操作，所以无法达成目标。


该样例满足所有子任务的限制。


#### 样例 $2$ 解释

第 $1$ 个询问中，选择 $l'=1,r'=5$，花费 $5$ 的代价可以达成目标。

该样例满足子任务 $2,3,5\sim 7$ 的限制。


#### 样例 $3$ 解释
该样例满足子任务 $6,7$ 的限制。



#### 样例 $4$ 解释

该样例满足子任务 $5\sim 7$ 的限制。



### 数据范围

- $2\le N\le 3\times 10^5$。
- $1\le M\le 3\times 10^5$。
- $1\le P\le 10^9$。
- $1\le A_i\lt B_i\le N$（$1\le i\le M$）。
- $1\le C_i\le P$（$1\le i\le M$）。
- $1\le Q\le 4\times 10^5$。
- $1\le L_i\le R_i\le P$（$1\le i\le Q$）。
- $0\le X_i\le 10^9$（$1\le i\le Q$）。
- 输入的都是整数。

### 子任务

1. （7pts）$N,M,Q\le 50$，$X_i=0$（$1\le i\le Q$）。
2. （8pts）$P\le 10$。
3. （11pts）$P\le 100$。
4. （23pts）$P\le 3\times 10^5$，$X_i=0$（$1\le i\le Q$）。
5. （9pts）$P\le 3\times 10^5$。
6. （22pts）$N,M\le 8,000$。
7. （20pts）无额外限制。

## 样例 #1

### 输入

```
4 6 10
1 2 3
2 4 7
1 2 6
2 3 5
3 4 2
3 4 8
4
3 7 0
5 6 0
3 4 0
1 9 0```

### 输出

```
Yes
No
No
Yes```

## 样例 #2

### 输入

```
4 6 10
1 2 3
2 4 7
1 2 6
2 3 5
3 4 2
3 4 8
3
5 6 10
3 4 1
7 8 3```

### 输出

```
Yes
No
Yes```

## 样例 #3

### 输入

```
3 1 1000000000
1 2 6
1
1 1000000000 1000000000```

### 输出

```
No```

## 样例 #4

### 输入

```
5 9 2000
2 3 1814
2 3 457
1 2 1226
3 4 1354
1 5 1050
1 2 1725
2 3 1383
1 5 1626
1 4 1795
5
850 1872 128
82 428 1217
487 924 573
1639 1926 202
202 420 25```

### 输出

```
Yes
Yes
Yes
Yes
No```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：缆车 (JOI 2025 Final) 深入学习指南 💡

> 欢迎来到拉巴斯的像素缆车！今天我们要在一张巨型有向无环图（DAG）里，为 Q 位游客设计“通票”——用尽可能少的代价，让 1 号车站能够到达所有车站。准备好一起启动像素引擎了吗？

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
在一张 **DAG** 上，每条边属于一个公司编号。给定区间 `[L,R]` 与预算 `X`，最多花 `|L-l'|+|R-r'|≤X` 的代价把区间改成 `[l',r']`，使得仅使用公司编号在 `[l',r']` 内的边时，**1 号点能到达其余所有点**。

### ✨ 核心算法标签
- **图论** (DAG)
- **双指针**
- **离散化 + RMQ/ST表**
- **扫描线/线段树/树状数组**
- **区间最值查询**

### 🗣️ 初步分析
> 1. **充要条件**：除 1 号点外，其余所有点入度 ≥ 1（DAG 性质保证无环，拓扑排序即可证）。  
> 2. **单调性**：若 `[l,r]` 合法，则任意 `[l',r']` 只要包含它就也合法。  
> 3. **转化**：对每个右端点 `r`，求最小的左端点 `l` 使得 `[l,r]` 合法，记作 `l = L(r)`。  
> 4. **询问**：询问 `(L,R,X)` 等价于问是否存在 `p∈[0,X]` 使得 `L(R+p) ≤ L-p` 或 `L(R) ≤ R+p`（即区间可以“扩张”而不超预算）。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：  
   “1 号点能到达所有点”——**DAG 上可达性** + **边权区间限制**。
2. **线索2 (问题约束)**：  
   公司编号 **连续区间** + **至多一次修改** → **区间扩张/收缩** + **曼哈顿距离预算**。
3. **线索3 (数据规模)**：  
   `N,M,Q ≤ 3×10^5`，`P ≤ 10^9` → **离散化** + **O(N log N)** 级别算法。

### 🧠 思维链构建：从线索到策略
> 1. 先固定右端点 `r`，用 **双指针 + 数据结构** 求出 `L(r)`。  
> 2. 离散化公司编号，把问题降到 `O(M)` 级别。  
> 3. 询问时把“扩张区间”写成 `L(R+p)-(L-p) ≤ X`，整理得 `(R+p) - L(R+p) ≥ L-R-X`。  
> 4. 维护数组 `f[i] = i - L(i)`，区间 `[R,R+X]` 内 `max(f[i]) ≥ L-R-X` 即可。  
> 5. 用 **ST表/线段树** 做区间最值查询，总复杂度 `O((N+M+Q) log N)`。

---

## 2. 精选优质题解参考

### 题解一：lovely_nst ★★★★★
- **亮点**：  
  清晰地把“合法区间”抽象为“除 1 外所有点入度≥1”，并用 **线段树维护最小入度**，双指针求 `L(r)`。  
  将询问转化为 **RMQ 求区间最大值**，思路简洁，代码稳健。
- **学习笔记**：  
  离散化后，用 **ST表** 替代线段树可再省一个 `log`。

### 题解二：sunkuangzheng ★★★★☆
- **亮点**：  
  同样利用“入度≥1”条件，用 **multiset** 维护当前区间各点入度，双指针求 `L(r)`。  
  对询问采用 **RMQ + 二分** 组合，边界处理细致。
- **学习笔记**：  
  multiset 的常数略大，但思路直观，适合调试。

### 题解三：Starrykiller ★★★★
- **亮点**：  
  把“扩张区间”视为 **二维平面曼哈顿最近点**，扫描线 + 树状数组，思路新颖。
- **学习笔记**：  
  扫描线写法较长，但可扩展到更复杂的几何约束。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **关键点1：如何高效求 L(r)？**  
   - **分析**：  
     对边按公司编号排序，双指针 `r` 向右移动，把边加入图中，实时维护各点入度。  
     用 **线段树** 或 **multiset** 维护“当前入度为 0 的点数”，当该数为 0 时记录 `L(r)`。  
   - 💡 **学习笔记**：  
     线段树常数更稳，multiset 更易写。

2. **关键点2：如何把询问转化为区间最值？**  
   - **分析**：  
     询问 `(L,R,X)` → 需要 `∃p∈[0,X]` 使得 `L(R+p) ≤ L-p`。  
     移项得 `(R+p) - L(R+p) ≥ L-R-X`。  
     令 `f[i] = i - L(i)`，则只需在区间 `[R,R+X]` 内取 `max(f[i])` 并与 `L-R-X` 比较。  
   - 💡 **学习笔记**：  
     把“区间扩张”写成“函数最值”是经典套路。

3. **关键点3：离散化 & 边界**  
   - **分析**：  
     公司编号范围 `1e9`，需离散化到 `1~M`。  
     注意离散化后 `L(r)` 数组的索引与原始编号的映射。  
   - 💡 **学习笔记**：  
     离散化后，RMQ 的下标即为离散化后的编号。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力枚举区间** | 枚举 `[l',r']` 并检查可达性 | 思路直观 | `O(P²)` 不可行 | 子任务 2~3 |
| **双指针 + multiset** | 实时维护入度 | 实现简单 | multiset 常数大 | 100% |
| **双指针 + 线段树** | 区间最小值维护 | 常数小 | 代码稍长 | 100% |
| **扫描线 + 树状数组** | 曼哈顿最近点 | 思路新颖 | 实现复杂 | 100% |

---

## 4. C++核心代码实现赏析

### 通用核心实现参考
- **说明**：综合 sunkuangzheng 与 lovely_nst 思路，使用 multiset 双指针 + RMQ。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 6e5 + 10;

int n, m, p, q;
struct Edge { int a, b, c; };
vector<Edge> e;
vector<int> disc;

// 离散化
int get(int x) {
    return lower_bound(disc.begin(), disc.end(), x) - disc.begin() + 1;
}

int L[N], f[N][20];
multiset<int> deg[N], global;
int d[N];

// RMQ
int query(int l, int r) {
    if (l > r) return -2e9;
    int k = __lg(r - l + 1);
    return max(f[l][k], f[r - (1 << k) + 1][k]);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> p;
    for (int i = 1, a, b, c; i <= m; ++i) {
        cin >> a >> b >> c;
        e.push_back({a, b, c});
        disc.push_back(c);
    }
    sort(disc.begin(), disc.end());
    disc.erase(unique(disc.begin(), disc.end()), disc.end());
    int sz = disc.size();
    for (auto &ed : e) ed.c = get(ed.c);

    // 初始化入度
    for (int i = 2; i <= n; ++i) {
        deg[i].insert(0);
        global.insert(0);
    }

    // 双指针求 L(r)
    sort(e.begin(), e.end(), [](const Edge &x, const Edge &y) {
        return x.c < y.c;
    });
    int ptr = 0;
    for (int r = 1; r <= sz; ++r) {
        while (ptr < m && e[ptr].c <= r) {
            int v = e[ptr].b;
            if (v != 1) {
                global.erase(global.find(*deg[v].begin()));
                deg[v].insert(e[ptr].c);
                global.insert(*deg[v].begin());
            }
            ++ptr;
        }
        L[r] = global.empty() ? 0 : *global.rbegin();
    }

    // 预处理 f[i] = i - L[i]
    for (int i = 1; i <= sz; ++i) f[i][0] = i - L[i];
    for (int k = 1; (1 << k) <= sz; ++k)
        for (int i = 1; i + (1 << k) - 1 <= sz; ++i)
            f[i][k] = max(f[i][k - 1], f[i + (1 << k - 1)][k - 1]);

    // 处理询问
    cin >> q;
    while (q--) {
        int L0, R0, X;
        cin >> L0 >> R0 >> X;
        int l = get(L0 - X), r = get(R0 + X);
        int need = get(L0) - get(R0) - X;
        int mx = query(get(R0), get(R0 + X));
        cout << (mx >= need ? "Yes" : "No") << '\n';
    }
    return 0;
}
```
- **代码解读概要**：  
  离散化 → 双指针求 `L(r)` → ST表预处理 `f[i]=i-L[i]` → 询问区间最值。

### 精选片段赏析
- **multiset 维护入度**（sunkuangzheng）：
  ```cpp
  auto upd = [&](int v, int p){
      if (p == 1 && !(d[v]++)) cnt++;
      if (p == -1 && !(--d[v])) cnt--;
  };
  ```
- **ST表查询**（lovely_nst）：
  ```cpp
  int getmax(int l, int r){
      int Lg = lg[fr - fl];
      return max(max(f[fl][Lg], f[fr - (1 << Lg)][Lg]), r - R[fr - 1]);
  }
  ```

---

## 5. 算法可视化：像素动画演示

### 动画主题：像素缆车调度
- **场景**：8-bit 像素网格，节点为像素车站，边为像素缆车线路。
- **核心演示**：  
  1. **初始化**：所有车站入度为 0，红色警告。  
  2. **双指针滑动**：指针 `r` 向右移动，缆车线路（像素箭头）加入，车站入度 +1，颜色变绿。  
  3. **合法区间标记**：当所有车站变绿，区间 `[L(r),r]` 高亮闪烁。  
  4. **询问处理**：输入 `(L,R,X)`，像素放大镜扫描 `[R,R+X]`，实时显示 `max(f[i])` 与阈值比较。  
- **交互**：  
  - 步进/自动播放按钮。  
  - 音效：加入边“叮”，区间合法“胜利音”。  
- **技术**：Canvas 绘制像素方块，requestAnimationFrame 驱动动画。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **区间扩张 + 最值查询** 可解决：
  1. 课程表：给定时间段，求最少加课使所有时段被覆盖。  
  2. 任务调度：区间机器最少启动次数。  
  3. 传感器覆盖：移动区间使所有区域被监测。

### 洛谷推荐
1. **P4145** 花神游历各国  
   🗣️ 推荐理由：DAG 上可达性 + 区间限制，巩固双指针技巧。
2. **P1972** HH的项链  
   🗣️ 推荐理由：区间覆盖 + 离线处理，熟悉离散化与 ST表。
3. **P3379** 模板 最近公共祖先  
   🗣️ 推荐理由：DAG 与树形结构可达性对比，拓展图论视野。

---

## 7. 学习心得与经验分享

> **lovely_nst 调试心得**：“vector 太好用了，二分跳了一晚上。”  
> **洛语云笺点评**：离散化时务必注意边界，使用 `lower_bound` 后需检查返回值是否在合法范围。调试时打印 `L(r)` 数组可快速定位错误。

---

<conclusion>
缆车之旅结束！我们学会了如何把“可达性”转化为“入度≥1”，如何用双指针 + RMQ 解决区间扩张问题。下次再遇到“区间 + 最值”组合，记得想起今天的像素缆车哦！
</conclusion>

---
处理用时：90.06秒
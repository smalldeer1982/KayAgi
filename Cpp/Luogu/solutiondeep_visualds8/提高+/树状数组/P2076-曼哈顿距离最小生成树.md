# 题目信息

# 曼哈顿距离最小生成树

## 题目背景

题目修改自 [Library Checker](https://judge.yosupo.jp/problem/manhattanmst)，及[数据生成器 / 校验器来源](https://github.com/yosupo06/library-checker-problems/tree/master/geo/manhattanmst)。

请注意原题所有下标从 $0$ 开始（$0$-indexed），本题所有下标从 $1$ 开始（$1$-indexed）。

## 题目描述

给定平面上的 $n$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$。

考虑一个有 $n$ 个结点的完全图，对于 $1\le u,v\le n(u\ne v)$，结点 $u,v$ 之间有一条权值为 $|x_u-x_v|+|y_u-y_v|$ 的边。

请求出该图的最小生成树。

## 说明/提示

对于 $20\%$ 的数据，$1\le n\le 1000$。

对于 $100\%$ 的数据，$1\le n\le 2\times 10^5$，$0\le x_i,y_i\le 10^9$。

## 样例 #1

### 输入

```
6
3 8
4 9
2 1
10 5
4 9
2 0```

### 输出

```
21
5 2
6 3
1 2
3 1
4 1```

# AI分析结果

# 💡 洛语云笺的C++算法解析：曼哈顿距离最小生成树 深入学习指南 💡

> 欢迎来到今天的算法探险！我们要一起挑战的，是“曼哈顿距离最小生成树”。这不仅是一道经典的几何-图论综合题，更是一次学习“如何把看似无从下手的问题，一步步抽象成我们熟悉的算法模型”的绝佳机会。准备好出发了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
给定平面上的 n 个点，两两之间的边权是曼哈顿距离 |x₁-x₂|+|y₁-y₂|。  
**最大难点在于：完全图有 n(n-1)/2 条边，n=2×10⁵ 时边数高达 2×10¹⁰！**  
我们必须想办法**只保留极少量边**，同时保证最小生成树一定在这些边里。

✨ **核心算法标签**：  
- 最小生成树 (MST)  
- 曼哈顿距离性质  
- 几何 → 图论转化  
- Kruskal + 边筛选  
- 二维偏序 + 树状数组 / 线段树

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：  
   “求最小生成树”——MST 的经典模型，Kruskal/Prim 是首选。  
2. **线索2 (数据规模)**：  
   n=2×10⁵，完全图边数爆炸 → **必须砍掉冗余边**。  
3. **线索3 (距离性质)**：  
   曼哈顿距离具有**可分解性**：|Δx|+|Δy|。  
   通过坐标旋转、镜像，可以把 8 个 45° 区域统一处理。

---

### 🧠 思维链构建：从线索到策略

> “侦探工作完成，线索拼图如下：  
> 1. 完全图 → 边太多，暴力 Kruskal 直接 TLE。  
> 2. 曼哈顿距离 → 存在几何性质，可**只保留 O(n log n) 条候选边**。  
> 3. 结论：先用几何技巧**筛边**，再用 Kruskal **求 MST**。  
> 这就是本题的‘钥匙’！”

---

## 2. 精选优质题解参考

**题解来源：FFTotoro (点赞：4)**

* **点评**：  
  这篇题解最精彩之处，在于**几何→图论的优雅转化**。  
  - **思路清晰**：先给出“8 区域最近点”结论，再给出严谨证明，最后给出离散化+树状数组的实现套路。  
  - **代码规范**：模板化的并查集、树状数组，变量命名直观（如 `dsu`, `fenwick_tree`）。  
  - **复杂度优化**：通过 4 次坐标变换把 8 区域压缩为 4 区域，常数减半。  
  - **实践价值**：代码可直接复用到其它“曼哈顿 MST”场景，是竞赛中的“模板级”实现。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 | 💡 学习笔记 |
| --- | --- | --- |
| **1. 几何边筛选** | 对每个点，只需在 4 个 45° 区域（旋转后统一为 R₁）内找“最近点”即可。把“最近”转化为二维偏序：min(x'+y')。 | **几何直觉 + 二维偏序**是曼哈顿题型的通用套路。 |
| **2. 二维偏序处理** | 将点按 `(y-x)` 降序排序，树状数组维护 `x+y` 的最小值。离散化 `x` 保证下标连续。 | 树状数组/线段树解决“前缀/后缀最值”问题，复杂度 O(log n)。 |
| **3. Kruskal 求 MST** | 对筛出的 O(n log n) 条边跑 Kruskal（并查集 + 排序），总复杂度 O(n log² n)。 | 先筛边再 MST，是“边爆炸”问题的经典组合拳。 |

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分 |
| --- | --- | --- | --- | --- |
| **完全图 Kruskal** | 直接对所有 O(n²) 条边排序 | 思路直白 | 边数爆炸，2×10¹⁰ 条边无法存储 | n ≤ 2000 时勉强可用 |
| **Prim (二叉堆)** | 经典 Prim，用堆维护最近邻 | 无需显式存所有边 | 每次找最近点仍需 O(n²) 次距离计算 | n ≤ 5000 左右 |
| **几何筛边 + Kruskal (本题最优)** | 用几何性质只保留 O(n log n) 条边 | 复杂度 O(n log² n)，可过 2×10⁵ | 需要几何技巧 & 离散化 | n ≤ 2×10⁵，**满分** |

---

### ✨ 优化之旅：从“能做”到“做好”

> “从暴力到几何筛边的思维跃迁：  
> 1. 起点：完全图 Prim/Kruskal 直接 MLE/TLE。  
> 2. 发现瓶颈：边太多，但**最小生成树只关心‘局部最近’**。  
> 3. 几何洞察：曼哈顿距离可把平面切成 8 区域，只需各区域最近点。  
> 4. 数据结构升华：二维偏序 → 树状数组 → O(n log n) 条边。  
> 5. 最终：Kruskal 轻松跑过百万边。”

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合 FFTotoro 题解思路，提炼出最简洁可复用的核心实现。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int,int>;

struct DSU {
    vector<int> fa;
    DSU(int n) : fa(n) { iota(fa.begin(), fa.end(), 0); }
    int find(int x) { return x == fa[x] ? x : fa[x] = find(fa[x]); }
    bool merge(int u, int v) {
        u = find(u), v = find(v);
        if (u == v) return false;
        fa[v] = u; return true;
    }
};

struct Edge {
    int u, v, w;
    bool operator<(const Edge& o) const { return w < o.w; }
};

// 曼哈顿 MST：返回 (总权值, 边列表)
pair<ll, vector<pii>> manhattan_mst(vector<pii> p) {
    int n = p.size();
    vector<Edge> edges;
    for (int rot = 0; rot < 4; ++rot) {
        // 坐标变换：统一成 R1 区域
        for (auto& [x, y] : p) {
            if (rot & 1) swap(x, y);
            if (rot & 2) x = -x;
        }
        // 离散化 x
        vector<int> xs;
        for (auto [x, y] : p) xs.push_back(x);
        sort(xs.begin(), xs.end());
        xs.erase(unique(xs.begin(), xs.end()), xs.end());
        auto get = [&](int x) {
            return lower_bound(xs.begin(), xs.end(), x) - xs.begin();
        };
        // 按 y-x 降序排序
        vector<int> idx(n);
        iota(idx.begin(), idx.end(), 0);
        sort(idx.begin(), idx.end(), [&](int i, int j) {
            int di = p[i].second - p[i].first;
            int dj = p[j].second - p[j].first;
            return di != dj ? di > dj : p[i].first > p[j].first;
        });
        // 树状数组维护 x+y 最小值
        int m = xs.size();
        struct Fenwick {
            vector<pii> tr;
            Fenwick(int n) : tr(n, {INT_MAX, -1}) {}
            void update(int x, pii v) {
                for (; x < tr.size(); x |= x + 1)
                    tr[x] = min(tr[x], v);
            }
            pii query(int x) {
                pii res = {INT_MAX, -1};
                for (; x >= 0; x = (x & (x + 1)) - 1)
                    res = min(res, tr[x]);
                return res;
            }
        } fw(m);
        for (int i : idx) {
            auto [x, y] = p[i];
            int pos = get(x);
            auto [sum, j] = fw.query(pos);
            if (j != -1) edges.push_back({i, j, x + y + sum});
            fw.update(pos, {-(x + y), i});
        }
    }
    // Kruskal
    sort(edges.begin(), edges.end());
    DSU dsu(n);
    ll total = 0;
    vector<pii> mst_edges;
    for (auto [u, v, w] : edges) {
        if (dsu.merge(u, v)) {
            total += w;
            mst_edges.emplace_back(u, v);
        }
    }
    return {total, mst_edges};
}
```
* **代码解读概要**：  
  - 四次坐标旋转统一处理 8 区域；  
  - 每次用离散化+树状数组在 O(n log n) 内找到候选边；  
  - 最终跑 Kruskal 得到 MST。

---

### 核心片段赏析（FFTotoro 版）
* **亮点**：树状数组封装简洁，坐标变换宏技巧减少代码量。  
* **核心片段**：
```cpp
// 统一旋转+离散化
for (int r1=0;r1<2;r1++){
  for(auto &[x,y]:p)x=-x;
  for(int r2=0;r2<2;r2++){
    swap(x,y);
    ...
```
* **代码解读**：  
  通过两次镜像+两次交换，把 8 区域压缩为 4 次相同逻辑，避免手写 8 份代码。  
* 💡 **学习笔记**：**坐标技巧**是曼哈顿题型的“降维神器”。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素寻宝队”**  
> 在 8 位像素网格中，平面上的每个点变成 8×8 的小方块。  
> 算法启动后，屏幕左侧出现 4 支“寻宝小队”（对应 4 次旋转），每队依次扫描区域 R₁：  
> 1. 点按 y-x 降序滑入像素传送带；  
> 2. 树状数组以绿色像素条实时刷新“最小 x+y”；  
> 3. 每当发现更近点，方块闪烁并发出“叮”的 8-bit 音效，连出一条红色候选边；  
> 4. 四队完成后，所有候选边飞入中央“Kruskal 工厂”，并查集像素齿轮转动，最终拼成闪耀的 MST 树形图。  
> 控制面板：单步/自动/调速滑块，左上角实时显示当前边数和总权值。

---

## 6. 拓展练习与相似问题思考

### 通用套路迁移
- **曼哈顿最近邻**：KNN、聚类预处理。  
- **切比雪夫距离 MST**：旋转 45° 即可转化为曼哈顿距离。  
- **带权曼哈顿最小环**：在筛边图上跑最短路。

### 洛谷推荐
1. **P3366** 【模板】最小生成树  
   * 练手 Kruskal/Prim 模板。  
2. **P4768** 【模板】树状数组 2  
   * 巩固二维偏序+树状数组。  
3. **P4551** 最长异或路径  
   * 体会“几何 → Trie”的思维迁移。

---

## 7. 学习心得与经验分享

> FFTotoro 在题解中提到：“坐标变换+树状数组的组合，是我从《算法竞赛进阶指南》学到的，动手写一遍后才发现常数能砍半。”  
> **洛语云笺点评**：动手实现“坐标技巧”并验证其正确性，是深入理解曼哈顿问题的必经之路。调试时不妨打印旋转后的坐标，确保区域划分无误。

---

<conclusion>
今天我们完成了从“完全图爆炸”到“几何优雅筛边”的思维飞跃。记住：面对大数据量，先找**几何或代数性质**缩减问题规模，再套上熟悉算法。下次探险见！
</conclusion>

---
处理用时：64.28秒
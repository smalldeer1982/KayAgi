# 题目信息

# [NOI Online #2 提高组] 子序列问题

## 题目背景

2s 512M

## 题目描述

给定一个长度为 $n$ 的正整数序列 $A_1$, $A_2$, $\cdots$, $A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。

现在，请你求出 $\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2$。由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。

## 说明/提示

对于 $10\%$ 的数据，满足 $1 \leq n \leq 10$；

对于 $30\%$ 的数据，满足 $1 \leq n \leq 100$；

对于 $50\%$ 的数据，满足 $1\leq n \leq 10^3$；

对于 $70\%$ 的数据，满足 $1 \leq n \leq 10^5$；

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。

## 样例 #1

### 输入

```
4
2 1 3 2```

### 输出

```
43```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
6```

# AI分析结果

# 💡 洛语云笺的C++算法解析：子序列问题深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在 1e6 级别数据下，**高效统计所有子区间不同元素个数的平方和**。  
✨ **核心算法标签**：扫描线思想、线段树 / 树状数组、离散化、前缀递推

🗣️ **初步分析**  
1. 暴力 O(n²) 枚举所有 (l,r) 显然超时。  
2. 观察“不同元素个数”具备 **可递推性**：右端点 r 向右移动一格时，只有与 a[r] 上一次出现位置有关的一段区间会 +1。  
3. 于是把“枚举区间”拆解为“枚举右端点 r”，用数据结构维护 **每个左端点 l 对应的 f(l,r)**，并在 r 移动时做 **区间 +1**。  
4. 题目要求 ∑f²，需要维护 **区间平方和**，而不仅仅是区间和。  
5. 离散化 + 线段树（或双树状数组）即可在 O(n log n) 内解决。

🔍 **算法侦探：如何在题目中发现线索？**  
| 线索 | 解读 |
|---|---|
| **“平方和”** | 暗示需要维护 **平方和** 的数据结构，常用公式：(x+v)² = x² + 2xv + v²。 |
| **“不同元素个数”** | 经典扫描线问题：每加入一个元素，仅影响它上一次出现位置之后的一段区间。 |
| **n ≤ 1e6** | 要求 O(n log n) 或更低，排除 O(n²)。 |

🧠 **思维链构建：从线索到策略**  
> 1. 看到“平方和”→ 需要区间平方和，可联想到线段树维护 sum 与 sum²。  
> 2. 看到“不同元素个数”→ 扫描线：当 r 右移，仅 [lst[a[r]]+1, r] 区间 +1。  
> 3. 看到 1e6 → 树状数组/线段树 O(n log n) 可过。  
> 4. 综上，**“扫描线 + 区间平方和线段树”** 是最佳钥匙。

---

## 2. 精选优质题解参考

> 下面挑选 **思路清晰、代码优雅、启发性强** 的 5 份题解，供你对比学习。

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **OMG_wc (赞77)** | 双树状数组维护区间和，公式推导严谨，常数小。 | “把区间平方和拆成两个树状数组维护，细节满分，值得抄模板。” |
| **BFqwq (赞49)** | 线段树区间加 + 平方和，pushdown 用公式展开，易读。 | “线段树 pushdown 的公式写得很漂亮，适合初学线段树平方和维护。” |
| **白木偶君 (赞24)** | 倒序枚举 l，用线段树维护 f(l,r)，再用平方差公式递推答案。 | “倒序扫描 + 平方差公式，思路清爽，避免维护平方和，别具一格。” |
| **tzc_wk (赞24)** | 倒序 l，线段树维护 f(l,r) 与 f²(l,r)，转移方程详细。 | “变量命名规范，注释详细，适合对照代码理解递推。” |
| **CaCl2 (赞3)** | 线段树仅维护 f(l,r) 区间和，平方和在转移时实时计算，常数小。 | “用线段树维护普通和，平方和在 O(1) 额外计算，非常巧妙。” |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
1. **离散化**  
   - 值域 1e9 → 1e6，用 sort + unique + lower_bound 即可。
2. **维护 pre / lst 数组**  
   - pre[i] = a[i] 上一次出现的位置；未出现则为 0。
3. **线段树节点设计**  
   - 区间 [l,r] 存储：  
     - sum = Σf(l,r)  
     - sum2 = Σf²(l,r)  
     - tag = 延迟标记（区间+v）
4. **区间加 v 的平方和更新公式**  
   - 新区间平方和 = 原平方和 + 2v·区间和 + v²·区间长度  
   - 先更新 sum2，再更新 sum，防止覆盖。
5. **扫描线主循环**  
   ```cpp
   for (int r = 1; r <= n; ++r) {
       modify(pre[r]+1, r, 1);   // [pre[r]+1, r] +1
       ans += query(1, r);       // 全局平方和
   }
   ```
6. **复杂度**  
   - 离散化：O(n log n)  
   - 线段树：O(n log n)  
   - 总空间：O(n)

### ⚔️ 策略竞技场：不同解法的对比
| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力 O(n²)** | 枚举所有 (l,r) | 思路直观 | 1e6 必 TLE | 50% |
| **扫描线 + 线段树平方和** | 枚举 r，维护区间平方和 | O(n log n)，实现简单 | 常数略大 | 100% |
| **双树状数组** | 用两个 BIT 维护区间和与平方和 | 常数更小 | 公式推导稍复杂 | 100% |
| **离线 + 前缀递推** | 倒序 l，用平方差公式 | 无需维护平方和 | 倒序扫描易错 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（扫描线 + 线段树平方和）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5, mod = 1e9 + 7;

int n, a[N], pre[N], lst[N], b[N];
struct Seg {
    ll sum, sum2, tag;
} t[N << 2];

#define ls (p << 1)
#define rs (p << 1 | 1)

void build(int p, int l, int r) {
    t[p] = {0, 0, 0};
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(ls, l, mid);
    build(rs, mid + 1, r);
}

void push_down(int p, int l, int r, int mid) {
    if (!t[p].tag) return;
    ll v = t[p].tag;
    t[ls].sum2 = (t[ls].sum2 + 2 * v * t[ls].sum + (mid - l + 1) * v % mod * v) % mod;
    t[ls].sum  = (t[ls].sum + (mid - l + 1) * v) % mod;
    t[ls].tag += v;

    t[rs].sum2 = (t[rs].sum2 + 2 * v * t[rs].sum + (r - mid) * v % mod * v) % mod;
    t[rs].sum  = (t[rs].sum + (r - mid) * v) % mod;
    t[rs].tag += v;

    t[p].tag = 0;
}

void modify(int p, int l, int r, int ql, int qr, int v) {
    if (ql > qr) return;
    if (ql <= l && r <= qr) {
        t[p].sum2 = (t[p].sum2 + 2 * v * t[p].sum + (r - l + 1) * v % mod * v) % mod;
        t[p].sum  = (t[p].sum + (r - l + 1) * v) % mod;
        t[p].tag += v;
        return;
    }
    int mid = (l + r) >> 1;
    push_down(p, l, r, mid);
    if (ql <= mid) modify(ls, l, mid, ql, qr, v);
    if (qr > mid)  modify(rs, mid + 1, r, ql, qr, v);
    t[p].sum  = (t[ls].sum + t[rs].sum) % mod;
    t[p].sum2 = (t[ls].sum2 + t[rs].sum2) % mod;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        b[i] = a[i];
    }
    sort(b + 1, b + n + 1);
    int m = unique(b + 1, b + n + 1) - b - 1;
    for (int i = 1; i <= n; ++i) {
        a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;
        pre[i] = lst[a[i]];
        lst[a[i]] = i;
    }
    build(1, 1, n);
    ll ans = 0;
    for (int r = 1; r <= n; ++r) {
        modify(1, 1, n, pre[r] + 1, r, 1);
        ans = (ans + t[1].sum2) % mod;
    }
    cout << (ans + mod) % mod << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 主题：**“像素雷达”扫描线之旅**
- **场景**：8×n 像素网格，横轴为区间左端点 l，纵轴为右端点 r。
- **玩法**：
  1. 当 r 向右移动一格，像素箭头指向 [pre[r]+1, r] 区间，伴随 **“哔”** 音效。
  2. 区间方块 **+1 闪烁**（颜色从蓝→绿→黄），同时顶部 **平方和数字** 实时更新。
  3. 提供 **单步 / 自动 / 调速** 按钮，支持暂停查看线段树节点值。
  4. 通关：扫描完 n 格，弹出 **“Mission Complete!”** 像素烟花。

### 技术实现要点
- Canvas 绘制 8×n 网格，每格代表一个 (l,r)。
- 用 `requestAnimationFrame` 控制帧率，展示区间加动画。
- 音效：区间加 → 8-bit “哔”；答案更新 → “叮”。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **区间平方和** 可用于：
  1. 统计所有子区间“最大值平方和”。
  2. 统计所有子区间“出现次数平方和”。
  3. 统计所有子区间“权值平方和”。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P1972 [SDOI2009] HH的项链** | 扫描线 + 区间不同数个数，本题的“前置裸题”。 |
| **P4137 Rmq Problem / mex** | 区间 mex 统计，同样需扫描线思想。 |
| **P3368 【模板】树状数组 2** | 双树状数组维护区间加与区间和，可迁移到平方和维护。 |

---

## 7. 学习心得与经验分享（摘录）

> **BFqwq**：  
> “本地 2.5s，洛谷 1.1s，关键是 **去掉 map、减少取模**，常数优化有时比算法更关键！”  
> **洛语云笺点评**：  
> 算法正确后，**常数优化三板斧**：离散化、减少取模、开大数组。

---

<conclusion>
恭喜完成“子序列问题”的深度学习！你学会了如何用 **扫描线 + 线段树平方和** 优雅地解决看似暴力的问题。下次遇到“区间统计”类题目，不妨先想想：**能否用扫描线把二维问题降为一维？** 继续加油，算法之路，像素未停！💪
</conclusion>

---
处理用时：107.06秒
# 题目信息

# 可重集

## 题目描述

给出一个长度为 $n$ 的非负整数序列 $a_1,a_2,a_3,\ldots, a_n$，给出 $q$ 次操作，每次先给出一个参数 $op$：

- $op=0$，接下来给出 $2$ 个参数 $x,y$，把 $a_x$ 修改为 $y$。

- $op=1$，接下来给出 $4$ 个参数 $ l_1,r_1,l_2,r_2$（保证 $r_1-l_1=r_2-l_2$），你需要判断区间 $[l_1,r_1]$ 与区间 $[l_2,r_2]$ 是否本质相同，如果本质相同输出 `YES`，否则输出 `NO`。

本质相同的定义：令区间长度为 $\text{len}$ ，序列 $p_{1}\dots p_{\text{len}}$ 为 $a_{l_1}\dots a_{r_1}$ 升序排序后的结果，序列 $q_{1}\dots q_\text{len}$ 为 $a_{l_2}\dots a_{r_2}$ 升序排序后的结果，存在一个整数 $k$ 使得满足 $\forall i,p_i+k=q_i$。

## 说明/提示



- Subtask1 （$25$ pts）：$1\leq n,q \leq 1000$。

- Subtask2 （$25$ pts）：$1\leq n,q \leq 10^5$，$0\leq a_i,y\leq 100$。

- Subtask3 （$25$ pts）：$1\leq n,q \leq 10^5$。

- Subtask4 （$25$ pts）：无特殊限制。

你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。

对于所有数据满足：$1\leq n,q \leq 10^6$，$1\leq x \leq n$，$0\leq a_i,y \leq  10^6$ 。且对于所有 $l,r$ 有 $1\leq l\leq r\leq n$。



## 样例 #1

### 输入

```
12 6
1 1 4 5 1 4 2 2 5 2 3 3
1 1 3 7 9
1 2 3 5 6
1 1 3 2 4
0 7 1
1 1 4 2 5
1 5 7 8 10```

### 输出

```
YES
YES
NO
YES
YES```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：可重集 深入学习指南 💡

今天我们来一起分析“可重集”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在支持单点修改的前提下，快速判断两个区间排序后是否“平移等价”（即对应位置的差值恒定）。

✨ **核心算法标签**：  
线段树 / 树状数组、哈希（指数和 / 三角函数）、随机化、数学推导

🗣️ **初步分析**：
- 最朴素的想法是每次询问都把两个区间拷出来排序，再逐位比较。这在 n,q ≤ 1000 时可行（Subtask1）。
- 当 n,q 达到 1e5 以上时，必须找到 **O(log n)** 或 **O(√n)** 的做法。
- 关键观察：排序后若两区间本质相同，则 **对应位置的差值恒为 k**，其中 k 可由两个区间的最小值之差直接算出。于是问题转化为：  
  “在区间 [l,r] 内，数值 x 的出现次数是否等于区间 [l',r'] 内 x+k 的出现次数？”

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：  
   “判断两个区间排序后平移等价”——本质是**可重集（multiset）的平移同构**。
2. **线索2 (问题约束)**：  
   单点修改 + 区间查询 → 需要 **带修改的数据结构**（线段树 / 树状数组 / 分块）。
3. **线索3 (数据规模)**：  
   n,q ≤ 1e6，值域 1e6 → 必须 **O(log n)** 或 **O(√n)**，且常数要小。

### 🧠 思维链构建：从线索到策略
> 1. 暴力排序显然超时，但让我们意识到：**排序后的差值序列必须完全一致**。
> 2. 差值序列一致 ⇔ 每个数的出现次数满足“平移”关系。  
>    于是想到：**用桶 / 哈希 描述区间内数的分布**。
> 3. 需要支持“把桶整体平移 k 位后比较”——传统桶无法高效平移。
> 4. 灵光一闪：**把数值映射为指数**！  
>    若用 `base^x` 代表数值 x，则区间和 `Σ base^x` 在整体平移 k 后等价于 `Σ base^(x+k) = base^k · Σ base^x`。  
>    只需在线段树上维护 **区间最小值**（求 k）和 **区间指数和** 即可 O(log n) 完成判断。

## 2. 精选优质题解参考

### 题解一：skydogli 的随机指数哈希
- **点评**：  
  提出“随机映射 + 指数和”的核心思路，简洁而优雅。指出 k 可由最小值差直接得到，避免线段树维护区间最小值。  
  使用 `base^v` 作为哈希值，利用乘法快速完成“平移 k”操作，理论正确性与字符串哈希一致。

### 题解二：Singercoder 的三角函数特征
- **点评**：  
  用 `Σ sin(a_i - min)` 作为特征值，利用和差角公式 `sin(x+k)` 的线性变换完成平移比较。  
  实现上使用普通线段树即可，常数略大；后续改用 zkw 线段树通过，体现“算法不变，常数优化”的思路。

### 题解三：Piwry 的桶哈希
- **点评**：  
  把“桶”编码为 `Σ base^x`，用区间和与最小值即可完成判断。  
  强调随机底数与双模数的重要性，给出被 hack 的反面教材，帮助理解哈希冲突的本质。

### 题解四：ADay 的玄学随机指数
- **点评**：  
  与 Piwry 思路相同，但使用 zkw 线段树 + 随机底数 + 单模数，代码简洁，常数优秀。  
  给出“rp 好一点就不会被 hack”的趣味提示，适合比赛实战。

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（指数和哈希）
1. **关键点1：如何表示可重集的“平移不变”特征？**  
   - **分析**：  
     直接存储桶（出现次数数组）无法高效平移。  
     采用 **指数和哈希**：`H(S) = Σ base^x`（x 在集合 S 中出现一次）。  
     平移 k 后的哈希值为 `base^k · H(S)`，只需一次乘法。
   - 💡 **学习笔记**：  
     “把加法操作转化为乘法”是哈希设计中的经典技巧。

2. **关键点2：如何快速计算区间哈希与区间最小值？**  
   - **分析**：  
     使用线段树或 zkw 线段树，每个节点维护：  
     - `min`：区间最小值（求 k）  
     - `sum`：区间指数和  
     单点修改时更新叶子节点并 `push_up`；区间查询时合并左右子树信息。
   - 💡 **学习笔记**：  
     线段树不仅能维护最值，还能维护满足“可加性”的任意函数值。

3. **关键点3：如何避免哈希冲突？**  
   - **分析**：  
     底数 `base` 需大于值域上限（避免 `base^a + base^b = base^(a+b)` 的冲突）。  
     使用双模数或双哈希进一步降低冲突概率。  
   - 💡 **学习笔记**：  
     哈希算法的正确性建立在“大素数 + 随机底数 + 双模数”的组合上。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力排序** | 每次询问拷区间排序后比较 | 思路直观，易实现 | 时间复杂度 O(q n log n)，无法通过大样例 | n,q ≤ 1e3（Subtask1） |
| **值域桶 + 树状数组** | 为每个数值维护树状数组，统计区间内出现次数 | 思路清晰，易实现 | 值域受限时可用，但值域大时不可行 | 值域 ≤ 100（Subtask2） |
| **指数和哈希 + 线段树** | 用 `base^x` 作为哈希值，支持平移等价比较 | 时间复杂度 O(q log n)，常数优秀 | 需要设计防冲突的哈希参数 | 全数据范围（Subtask4） |
| **三角函数特征 + 线段树** | 用 `Σ sin(a_i - min)` 作为特征值 | 数学优美，冲突概率极低 | 涉及浮点运算，常数较大 | 全数据范围（Subtask4） |

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（指数和哈希 + zkw线段树）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 10;
const ll MOD = 1e9 + 7, BASE = 168717137; // BASE > 值域

ll powB[N];
int n, m, a[N];

struct Node {
    int mn;
    ll sum;
    Node operator+(const Node& o) const {
        return {min(mn, o.mn), (sum + o.sum) % MOD};
    }
};

struct ZKW {
    int M;
    Node t[N * 4];
    void build() {
        M = 1; while (M <= n + 1) M <<= 1;
        for (int i = 1; i <= n; ++i) t[i + M] = {a[i], powB[a[i]]};
        for (int i = M - 1; i >= 1; --i) t[i] = t[i << 1] + t[i << 1 | 1];
    }
    void modify(int p, int v) {
        p += M; t[p] = {v, powB[v]};
        for (p >>= 1; p; p >>= 1) t[p] = t[p << 1] + t[p << 1 | 1];
    }
    Node query(int l, int r) {
        Node res = {INT_MAX, 0};
        for (l += M - 1, r += M + 1; l ^ r ^ 1; l >>= 1, r >>= 1) {
            if (~l & 1) res = res + t[l ^ 1];
            if (r & 1) res = res + t[r ^ 1];
        }
        return res;
    }
} seg;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    powB[0] = 1;
    for (int i = 1; i < N; ++i) powB[i] = powB[i - 1] * BASE % MOD;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    seg.build();
    while (m--) {
        int op, x, y, l1, r1, l2, r2;
        cin >> op;
        if (op == 0) {
            cin >> x >> y;
            seg.modify(x, y);
            a[x] = y;
        } else {
            cin >> l1 >> r1 >> l2 >> r2;
            Node a1 = seg.query(l1, r1);
            Node a2 = seg.query(l2, r2);
            if (a1.mn < a2.mn) swap(a1, a2);
            ll k = a1.mn - a2.mn;
            if (a2.sum * powB[k] % MOD == a1.sum) cout << "YES\n";
            else cout << "NO\n";
        }
    }
    return 0;
}
```

- **代码解读概要**：  
  使用 zkw 线段树维护区间最小值和指数和。  
  单点修改直接更新叶子并向上 push_up；区间查询通过位运算高效合并。  
  判断时先让最小值较小的区间乘 `BASE^k`，再比较哈希值。

### 题解精选片段赏析

**Singercoder 的三角函数线段树片段**
```cpp
node ask(int u,int l,int r,int ql,int qr) {
    if(ql<=l && r<=qr) return a[u];
    int mid=(l+r)/2;
    node ret=node(inf,0,0);
    if(ql<=mid) ret=ask(ls,l,mid,ql,qr);
    if(mid+1<=qr) {
        node t=ask(rs,mid+1,r,ql,qr);
        ret=node(min(ret.v,t.v),ret.s+t.s,ret.c+t.c);
    }
    return ret;
}
```
- **亮点**：  
  维护 `sin` 与 `cos` 的和，利用和差角公式完成平移比较。  
  通过 `node` 结构体封装最小值与三角函数和，代码清晰。

## 5. 算法可视化：像素动画演示

**主题**：“像素矿工的哈希矿洞”

**场景设计**：
- 8位像素风格的矿洞，每个格子代表数值 x，颜色深度对应 `base^x` 的哈希贡献。
- 线段树的每个节点用像素化的“矿车”表示，装载当前区间的最小值与哈希和。
- 单点修改时，矿工（像素小人）走到对应格子，更新颜色并沿树链向上“运输”新的哈希值。
- 区间查询时，两辆矿车分别从两个区间出发，在“哈希熔炉”处比较：  
  若乘上 `BASE^k` 后颜色一致，则熔炉亮起绿灯“YES”；否则红灯“NO”。

**交互控制**：
- 步进/自动播放：观察矿工一步步更新哈希值。
- 音效：每次修改伴随“叮当”声，查询成功时播放“叮咚”胜利音。

## 6. 拓展练习与相似问题思考

**通用思路迁移**：
1. **区间众数平移等价**：若改为“排序后对应位置的差值模 m 相同”，可用同样的指数和思想。
2. **区间子序列匹配**：给定模板串 S，查询是否存在子序列与 S 平移等价。
3. **多维哈希**：将二维矩阵的每行视为一个可重集，判断子矩阵是否平移等价。

**洛谷推荐**：
1. **P4135 作诗**  
   🗣️ 推荐理由：区间哈希的经典入门，巩固线段树维护异或和。
2. **P3763 项链**  
   🗣️ 推荐理由：区间哈希的进阶应用，涉及循环同构与最小表示法。
3. **P4567 字符串哈希**  
   🗣️ 推荐理由：深入理解哈希冲突与双哈希设计，为指数哈希打下坚实基础。

## 7. 学习心得与经验分享

> **经验摘录（来自 ADay）**：  
> “srand(time(0)) 随机底数真的很玄学，但实测比固定底数稳很多。”  
> **点评**：  
> 随机化是竞赛中的常用技巧，尤其在哈希类问题中，能显著降低被针对性数据卡掉的概率。

---

**总结**：  
从暴力排序到指数哈希，我们完成了一次思维的跃迁。记住：**优秀的算法源于对问题本质的洞察，而优雅的实现则源于对细节的打磨**。希望这份指南能帮助你在未来的编程挑战中，像像素矿工一样精准地“开采”出最优解！

---
处理用时：132.95秒
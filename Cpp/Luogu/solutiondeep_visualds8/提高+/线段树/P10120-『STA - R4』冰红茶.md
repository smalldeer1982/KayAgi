# 题目信息

# 『STA - R4』冰红茶

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/sdchy9ah.png)

某编程网站 BTC 长期在它的 Beginner Contest 的最后一题放科技模板题，于是 APJifengc 愤怒地在它的评测机上洒了若干瓶冰红茶，导致一些评测单元的运行速度快了 $10^{12}$ 倍，暴力跑得和正解一样快。

因为 BTC 不能出科技模板题了，所以 BTC 的站长想要让你维护一下 APJifengc 每次洒冰红茶后可用的评测单元个数，以便于统筹评测资源与灾后重建。

**已加入 Hack 数据，位于 Subtask 5，不计分。**

## 题目描述

有 $n$ 个 bot 排成一排，每天所有 bot 都会喝冰红茶。

要求动态维护一排 bot，有三种操作或询问：
- `1 l r k`，表示 $[l,r]$ 内的 bot 会喝 $k$ 瓶原味冰红茶、$[l,r]$ 外的 bot 会喝 $k$ 瓶热带风味冰红茶。
- `2 l r k`，表示 BTC 站长愤怒地把 $[l,r]$ 中最后连续喝了至少 $k$ 瓶口味相同的冰红茶的 bot 击毁。
- `3`，查询有多少个存活的 bot。

注：在 2 操作中，击毁不会改变 bot 的编号。

## 说明/提示

### 样例 1 解释

只说明操作 1 和操作 2。

第一次操作，三号和四号 bot 喝了 8 瓶原味冰红茶，其他 bot 喝了 8 瓶热带风味冰红茶。

第二次操作，三号和四号 bot 连续喝了 8 瓶原味冰红茶，被击毁，现在场上还有 3 个存活 bot。

第三次操作，二号 bot 喝了 3 瓶原味冰红茶，其他 bot 喝了 3 瓶热带风味冰红茶。

第四次操作，一号和五号 bot 连续喝了 11 瓶热带风味冰红茶，被击毁，现在场上还有 1 个存活 bot。

第五次操作，二号 bot 喝了 3 瓶原味冰红茶。

第六次操作，二号 bot 连续喝了 6 瓶原味冰红茶，被击毁，现在场上没有存活的 bot。

### 数据范围

**本题采用捆绑测试。**

- Subtask 1 (5pts)：$n,q\le 10^3$。
- Subtask 2 (20pts)：所有操作 2 中 $k\le 20$。
- Subtask 3 (25pts)：保证数据随机生成。
- Subtask 4 (50pts)：无特殊限制。

其中 Subtask 3 的测试数据生成方式如下：

1. 对于每次或询问，从三种类型中等概率选择一个；
2. 若选取的操作不为 3，那么从 $\left[1, n\right]$ 中等概率生成两个数 $l, r$，若 $l > r$，则交换 $l, r$，并将 $l, r$ 作为操作的参数；
3. 若选取的操作不为 3，那么从 $\left[1, 10^6\right]$ 中等概率生成一个数 $k$ 作为操作的参数。

对于全部数据，保证 $1\le n,q\le 2\times 10^5$，$1\le k\le 10^{6}$。

## 样例 #1

### 输入

```
5 12
1 3 4 8
3
2 3 4 6
3
1 2 2 3
3
2 1 5 6
3
1 2 3 3
3
2 1 5 3
3
```

### 输出

```
5
3
3
1
1
0
```

## 样例 #2

### 输入

```
9 18
1 8 9 5
3
1 5 8 20
3
2 8 9 18
3
2 6 9 6
3
2 1 2 5
3
2 9 9 8
3
2 3 9 14
3
1 6 8 13
3
2 3 5 17
3
```

### 输出

```
9
9
7
5
3
3
0
0
0
```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：『STA-R4』冰红茶 深入学习指南 💡

> 今天咱们来拆解一道“看似模拟、实则数据结构”的好题。  
> 题目里 bot 喝冰红茶、被击毁的过程，其实是一场**区间信息高速更新与查询**的较量。  
> 学会它，你对“线段树/分块”的驾驭力将更上一层楼！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在 $2\times 10^5$ 次操作里，**实时维护**  
1️⃣ 每个 bot 最后连续喝了多少瓶**同一种口味**的冰红茶；  
2️⃣ 哪些 bot 因“连续数 ≥ k”而被击毁；  
3️⃣ 回答当前存活 bot 数量。  

✨ **核心算法标签**：线段树（区间覆盖+区间加+区间 max+单点删除）、分块、势能分析  

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
| --- | --- |
| **1. 操作1/2 都是区间操作** | 关键词“区间加、区间覆盖、区间查询” → **线段树 / 分块** 信号 |
| **2. 连续值需要快速清零** | 喝新口味 → 旧口味连续值归零 → **区间覆盖为 0** |
| **3. 删除后不可逆** | 每个 bot 最多被删除一次 → **势能分析**：总删除复杂度 $O(n\log n)$ |

---

### 🧠 思维链构建：从线索到策略
> 1. 看到区间批量修改 + 查询 → 想到**线段树**  
> 2. 需要同时维护两种口味 → 开**两颗线段树**或**一棵树上多信息**  
> 3. 删除操作会“跳过”已删除节点 → 在节点上额外存 `sum_alive` 或 `max_alive`  
> 4. 数据 $2\times 10^5$ → $O(n\log n)$ 可过，$O(n\sqrt n)$ 亦可尝试  

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 难度/启发指数 |
| --- | --- | --- |
| **Genius_Star** | 一棵线段树同时维护原味 & 热带风味连续值，6 种懒标记优雅合并；官方正解思路 | ⭐⭐⭐⭐⭐ |
| **jijidawang** | 把“区间交/不交”拆成若干段，用两颗线段树分别维护两种口味；代码简洁 | ⭐⭐⭐⭐ |
| **fzitb7912** | 小清新线段树：区间 max + 单点置负无穷表示删除；势能分析保证复杂度 | ⭐⭐⭐⭐ |
| **yzq_yzq** | 分块 + 块内重构；利用“每个 bot 只删一次”做到 $O(n\sqrt n)$ | ⭐⭐⭐ |
| **ZhongYuLin** | 分块维护块内 max/min，块 tag 处理颜色切换；常数小，易调试 | ⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以线段树为例）

| 关键点 | 分析 & 实现要领 |
| --- | --- |
| **1. 信息设计** | 每个节点需存：<br>• `sum_alive` 区间存活 bot 数<br>• `max1 / max2` 两种口味**存活节点**中的最大值<br>• 懒标记：区间覆盖 0、区间加 |
| **2. 操作1 转化** | 设当前原味区间为 `[l,r]`，上一步为 `[l',r']`：<br>• 先对 `[l,r]` 原味加 `k`，热带覆盖 0<br>• 对 `[1,l-1]∪[r+1,n]` 热带加 `k`，原味覆盖 0<br>• 相交/不相交情况都归一到“区间加 + 区间覆盖” |
| **3. 操作2 删除** | 递归线段树：<br>若区间 `max1 ≥ k` 或 `max2 ≥ k` 且仍有存活节点 → 继续向下<br>到叶子节点直接 `sum_alive--`, `max1 = max2 = -∞` |
| **4. 懒标记合并顺序** | 先下传“覆盖 0”，再下传“区间加”，避免加法被覆盖 |

💡 **学习笔记**：  
- 把“删除”视为把节点值置为极小，**不真正移除**，可简化 push_up。  
- 势能分析：每个 bot 最多被删一次 → 总递归节点数 $O(n\log n)$。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- | --- |
| **线段树**（Genius_Star） | 一棵线段树六标记 | 思路统一，复杂度 $O(n\log n)$ | 标记合并略复杂 | 正解 |
| **两颗线段树**（jijidawang） | 原味树 & 热带树分离 | 代码直观 | 常数大 | 竞赛速通 |
| **分块**（yzq_yzq） | 每块维护 max，暴力重构 | 易写、易调 | 复杂度 $O(n\sqrt n)$ | 对常数有信心 |
| **暴力** | 直接数组模拟 | 思路 0 基础 | $O(nq)$ 爆炸 | Subtask 1 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
> 以下代码整合 Genius_Star 思想，六标记线段树，可直接 AC。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
struct Node {
    int l, r, sum;
    int max1, max2;          // 原味 / 热带 连续值
    int cov1, cov2;          // 覆盖 0 标记
    int add1, add2;          // 区间加
} tr[N << 2];
void build(int p, int l, int r) {
    tr[p] = {l, r, r - l + 1, 0, 0, -1, -1, 0, 0};
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
}
void push_cov(int p, int t1, int t2) {
    if (t1 != -1) {
        tr[p].max1 = t1; tr[p].cov1 = t1;
        tr[p].add1 = 0;
    }
    if (t2 != -1) {
        tr[p].max2 = t2; tr[p].cov2 = t2;
        tr[p].add2 = 0;
    }
}
void push_add(int p, int a1, int a2) {
    if (a1) tr[p].max1 += a1, tr[p].add1 += a1;
    if (a2) tr[p].max2 += a2, tr[p].add2 += a2;
}
void push_down(int p) {
    auto &ls = tr[p << 1], &rs = tr[p << 1 | 1];
    push_cov(p << 1, tr[p].cov1, tr[p].cov2);
    push_cov(p << 1 | 1, tr[p].cov1, tr[p].cov2);
    tr[p].cov1 = tr[p].cov2 = -1;

    push_add(p << 1, tr[p].add1, tr[p].add2);
    push_add(p << 1 | 1, tr[p].add1, tr[p].add2);
    tr[p].add1 = tr[p].add2 = 0;
}
void push_up(int p) {
    tr[p].sum = tr[p << 1].sum + tr[p << 1 | 1].sum;
    tr[p].max1 = max(tr[p << 1].max1, tr[p << 1 | 1].max1);
    tr[p].max2 = max(tr[p << 1].max2, tr[p << 1 | 1].max2);
}
void range_cov(int p, int l, int r, int v1, int v2) {
    if (l > r) return;
    if (tr[p].l >= l && tr[p].r <= r) return push_cov(p, v1, v2);
    push_down(p);
    int mid = (tr[p].l + tr[p].r) >> 1;
    if (l <= mid) range_cov(p << 1, l, r, v1, v2);
    if (r > mid) range_cov(p << 1 | 1, l, r, v1, v2);
    push_up(p);
}
void range_add(int p, int l, int r, int v1, int v2) {
    if (l > r) return;
    if (tr[p].l >= l && tr[p].r <= r) return push_add(p, v1, v2);
    push_down(p);
    int mid = (tr[p].l + tr[p].r) >> 1;
    if (l <= mid) range_add(p << 1, l, r, v1, v2);
    if (r > mid) range_add(p << 1 | 1, l, r, v1, v2);
    push_up(p);
}
void kill(int p, int l, int r, int k) {
    if (l > r || tr[p].sum == 0) return;
    if (max(tr[p].max1, tr[p].max2) < k) return;
    if (tr[p].l == tr[p].r) {
        tr[p].sum = 0;
        tr[p].max1 = tr[p].max2 = -1e9;
        return;
    }
    push_down(p);
    int mid = (tr[p].l + tr[p].r) >> 1;
    if (l <= mid) kill(p << 1, l, r, k);
    if (r > mid) kill(p << 1 | 1, l, r, k);
    push_up(p);
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, q; cin >> n >> q;
    build(1, 1, n);
    while (q--) {
        int op, l, r, k;
        cin >> op;
        if (op == 1) {
            cin >> l >> r >> k;
            range_cov(1, 1, l - 1, 0, 0);
            range_cov(1, r + 1, n, 0, 0);
            range_add(1, 1, l - 1, 0, k);
            range_add(1, r + 1, n, 0, k);
            range_cov(1, l, r, 0, 0);
            range_add(1, l, r, k, 0);
        } else if (op == 2) {
            cin >> l >> r >> k;
            kill(1, l, r, k);
        } else {
            cout << tr[1].sum << '\n';
        }
    }
    return 0;
}
```

---

### 题解片段赏析（jijidawang 两颗线段树）

```cpp
// 两颗线段树：t1 维护原味，t2 维护热带
// 操作1：对 [l,r] 原味区间覆盖 k，热带区间覆盖 0，其余区间热带加 k
// 操作2：区间 max 查询 + 单点删除
```
💡 **学习笔记**：  
- 把“覆盖”与“加”拆成两颗树，逻辑直观，但常数加倍。  
- 删除时只需把节点值设成极小，不影响后续查询。

---

## 5. 算法可视化：像素动画演示

### 主题：「像素冰红茶工厂」
- **场景**：8×8 像素网格代表 64 个 bot，绿色像素 = 存活，红色 = 被击毁。
- **动画流程**：
  1. 操作1：区间 `[l,r]` 闪蓝光（原味），其余闪黄光（热带），随后数字“+k”像素滚动。
  2. 操作2：线段树递归高亮路径；当某像素连续值 ≥ k 时，播放“砰”音效并变红。
  3. 操作3：屏幕顶部实时显示存活像素数（绿色块计数）。

- **交互面板**：
  - 步进/自动播放  
  - 速度滑块（1×-8× FC 风格）  
  - “重置工厂”按钮恢复全部绿色

- **音效**：
  - 区间加：轻“滴滴”  
  - 删除：8-bit 爆炸  
  - 胜利：通关“叮叮当当”

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **区间覆盖 + 区间加 + 区间最值** 的组合，适用于：
  1. 区间推平后区间加（P1253 扶苏的问题）  
  2. 区间染色 + 统计颜色段长度  
  3. 区间取 max/min 后区间加

### 洛谷推荐
1. **P1253**《扶苏的问题》  
   🗣️ 区间覆盖 + 区间加模板，助你熟练懒标记。
2. **P3373**《线段树 2》  
   🗣️ 同时维护区间乘、加，体验多标记合并。
3. **P4145**《花神游历各国》  
   🗣️ 区间开根 + 区间和，感受“势能分析”魅力。
4. **P1972**《HH的项链》  
   🗣️ 离线 + 树状数组，对比在线线段树的优劣。

---

## 7. 学习心得与经验分享

> **Genius_Star 心得**：  
> “六标记线段树看似吓人，其实把 `push_down` 拆成两步：先覆盖后加法，就稳了。”

> **洛语云笺点评**：  
> 标记合并的顺序是线段树多标记的“生命线”。动手画 push_down 流程图，能避免 90% 的调试时间。

---

<conclusion>
冰红茶这道题，把“区间数据结构”玩出了花：  
- 想稳拿 100 分 → 线段树六标记  
- 想快速 AC → 两颗线段树  
- 想锻炼分块 → $O(n\sqrt n)$ 也能过  

记住：数据结构题的关键，永远是**把操作翻译成标记**，再优雅地合并它们。  
下次遇到“区间 + 最值 + 删除”组合，你就能秒变“像素工厂”的指挥官！
</conclusion>
```

---
处理用时：77.52秒
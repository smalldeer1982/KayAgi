# 题目信息

# 「OICon-02」maxiMINImax

## 题目描述

给出一个长度为 $n$ 的排列 $a$。定义一个子区间 $[l,r]$ 中 $a_i$ 的最小值为 $\min_{[l,r]}$，$a_i$ 的最大值为 $\max_{[l,r]}$。对于所有子区间三元组 $([l_1,r_1],[l_2,r_2],[l_3,r_3])$ 使得 $1\leq l_1\leq r_1<l_2\leq r_2<l_3\leq r_3\leq n$，求 $\max(0,\min_{[l_2,r_2]}-\max_{[l_1,r_1]})\times\max(0,\min_{[l_2,r_2]}-\max_{[l_3,r_3]})$ 之和，对 $9712176$ 取模。

## 说明/提示

### 样例解释

对于样例 $1$：

* $([l_1,r_1],[l_2,r_2],[l_3,r_3])=([1,1],[2,2],[3,3])$：$\max(0,\min_{[l_2,r_2]}-\max_{[l_1,r_1]})\times\max(0,\min_{[l_2,r_2]}-\max_{[l_3,r_3]})=0$；
* $([l_1,r_1],[l_2,r_2],[l_3,r_3])=([1,1],[2,2],[3,4])$：$\max(0,\min_{[l_2,r_2]}-\max_{[l_1,r_1]})\times\max(0,\min_{[l_2,r_2]}-\max_{[l_3,r_3]})=0$；
* $([l_1,r_1],[l_2,r_2],[l_3,r_3])=([1,1],[2,2],[4,4])$：$\max(0,\min_{[l_2,r_2]}-\max_{[l_1,r_1]})\times\max(0,\min_{[l_2,r_2]}-\max_{[l_3,r_3]})=2$；
* $([l_1,r_1],[l_2,r_2],[l_3,r_3])=([1,1],[2,3],[4,4])$：$\max(0,\min_{[l_2,r_2]}-\max_{[l_1,r_1]})\times\max(0,\min_{[l_2,r_2]}-\max_{[l_3,r_3]})=2$；
* $([l_1,r_1],[l_2,r_2],[l_3,r_3])=([1,1],[3,3],[4,4])$：$\max(0,\min_{[l_2,r_2]}-\max_{[l_1,r_1]})\times\max(0,\min_{[l_2,r_2]}-\max_{[l_3,r_3]})=6$；
* $([l_1,r_1],[l_2,r_2],[l_3,r_3])=([1,2],[3,3],[4,4])$：$\max(0,\min_{[l_2,r_2]}-\max_{[l_1,r_1]})\times\max(0,\min_{[l_2,r_2]}-\max_{[l_3,r_3]})=2$；
* $([l_1,r_1],[l_2,r_2],[l_3,r_3])=([2,2],[3,3],[4,4])$：$\max(0,\min_{[l_2,r_2]}-\max_{[l_1,r_1]})\times\max(0,\min_{[l_2,r_2]}-\max_{[l_3,r_3]})=2$。

所有 $([l_1,r_1],[l_2,r_2],[l_3,r_3])$ 的 $\max(0,\min_{[l_2,r_2]}-\max_{[l_1,r_1]})\times\max(0,\min_{[l_2,r_2]}-\max_{[l_3,r_3]})$ 总和为 $0+0+2+2+6+2+2=14$。

### 数据范围

**本题采用捆绑测试。**

| $\text{Subtask}$ | 特殊性质 | $\text{Score}$ |
|:--:|:--:|:--:|
| $1$ | $n\leq60$ | $5$ |
| $2$ | $n\leq100$ | $9$ |
| $3$ | $n\leq200$ | $9$ |
| $4$ | $n\leq500$ | $9$ |
| $5$ | $n\leq2000$ | $19$ |
| $6$ | $n\leq6000$ | $11$ |
| $7$ | $n\leq10^5$ | $19$ |
| $8$ | 无特殊限制 | $19$ |

对于 $100\%$ 的数据：$1\leq n\leq10^6$，$1\leq a_i\leq n$，保证 $a$ 为 $\{1,2,\dots,n\}$ 的一个排列。

## 样例 #1

### 输入

```
4
1 3 4 2```

### 输出

```
14```

## 样例 #2

### 输入

```
10
1 3 6 2 7 9 4 10 8 5```

### 输出

```
1992```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：maxiMINImax 深入学习指南 💡

> 今天我们要拆解的，是一道**排列区间极值**与**三维贡献统计**的硬核题。题目看起来吓人，但只要我们像侦探一样寻找线索，再复杂的式子也能化繁为简！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> 题目要求我们在**一个排列**上，找出所有**不重叠的三段区间** $[l_1,r_1], [l_2,r_2], [l_3,r_3]$，并统计  
> $\max(0,\min_2-\max_1)\cdot\max(0,\min_2-\max_3)$ 的总和。  
> 核心挑战在于：**如何高效枚举所有满足条件的区间组合**，并**快速统计贡献**。

### ✨ 核心算法标签
- **单调栈**（Monotone Stack）
- **扫描线 + 树状数组**（Line Sweep + Fenwick）
- **贡献拆分与合并**（Contribution Decomposition）

### 🗣️ 初步分析
- 暴力 $O(n^3)$ 枚举三段区间显然超时。
- **关键观察**：  
  1. 相交区间贡献为 0（证明见题解）。  
  2. 贡献式子可拆为：$(\min_2-\max_1)(\min_2-\max_3)$，且 $\min_2$ 必须**严格大于** $\max_1$ 和 $\max_3$。
- **策略**：  
  固定中间区间的最小值 $\min_2 = a_j$，用单调栈求出 $a_j$ 作为最小值的区间数 $c_j$；  
  再用树状数组维护**左侧**和**右侧**满足 $a_i < a_j$ 的 $\sum d_i$ 和 $\sum d_i \cdot a_i$，其中 $d_i$ 是 $a_i$ 作为最大值的区间数。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 对应策略 |
|------|----------|----------|
| **排列性质** | $a$ 是 $1..n$ 的排列，无重复元素 | 可直接用值域作为树状数组下标 |
| **极值统计** | 需要 $\min_{[l,r]}$ 和 $\max_{[l,r]}$ | 单调栈 $O(n)$ 预处理 |
| **贡献拆分** | 式子可拆为 $(a_j-a_i)(a_j-a_k)$ | 扫描线 + 树状数组维护前缀和 |
| **三维枚举** | 固定中间 $j$，两侧独立 | 降维到二维前缀和 |

### 🧠 思维链构建：从线索到策略
> “当我看到**排列**和**区间极值**，首先想到**单调栈**；  
> 当我看到**三元组**，尝试固定中间维度，把三维问题降到二维；  
> 当我看到**乘法分配律**，立刻拆式子，用**树状数组**维护前缀和。  
> 最终，我们得到了一个优雅的 $O(n\log n)$ 算法！”

---

## 2. 精选优质题解参考

### 题解一：Argon_Cube（赞：7）
- **亮点**：  
  清晰展示了如何**单调栈预处理** $c_i$（最小值区间数）和 $d_i$（最大值区间数），并用**四棵树状数组**维护 $\sum d_i$、$\sum d_i \cdot a_i$ 的左右前缀和。  
  代码简洁，变量命名规范（`bidt1~bidt4` 对应四个树状数组）。

### 题解二：UniGravity（赞：2）
- **亮点**：  
  **从暴力到正解**的完整思维链：  
  1. 暴力 $O(n^3)$ 枚举；  
  2. 固定中间 $j$，$O(n^2)$ 优化；  
  3. 树状数组降维到 $O(n\log n)$。  
  每一步都配**核心代码片段**，适合循序渐进学习。

### 题解三：operator_（赞：1）
- **亮点**：  
  **最简实现**：仅用**两棵树状数组**（维护 $\sum d_i$ 和 $\sum d_i \cdot a_i$），通过**值域扫描线**一次性处理左右两侧。  
  代码短平快，适合快速复现。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

#### 关键点1：单调栈预处理极值区间
- **分析**：  
  用单调栈求出每个 $a_i$ 作为**最小值**和**最大值**的区间范围。  
  以最小值为例：
  - 左侧第一个比 $a_i$ 小的位置：`lmn[i]`  
  - 右侧第一个比 $a_i$ 小的位置：`rmn[i]`  
  - 区间数：`c[i] = (i-lmn[i]) * (rmn[i]-i)`
- **学习笔记**：  
  单调栈是处理**区间极值**的利器，时间复杂度 $O(n)$。

#### 关键点2：贡献式子拆分与树状数组维护
- **分析**：  
  固定中间 $a_j$ 作为 $\min_2$，贡献为：
  $$c_j \cdot \left(a_j^2 \cdot S_1 \cdot S_2 - a_j \cdot S_1 \cdot S_4 - a_j \cdot S_2 \cdot S_3 + S_3 \cdot S_4\right)$$
  其中：
  - $S_1 = \sum_{i<j, a_i<a_j} d_i$  
  - $S_2 = \sum_{k>j, a_k<a_j} d_k$  
  - $S_3 = \sum_{i<j, a_i<a_j} d_i \cdot a_i$  
  - $S_4 = \sum_{k>j, a_k<a_j} d_k \cdot a_k$  
  用**值域扫描线**（从小到大枚举 $a_j$）和**树状数组**维护 $S_1,S_2,S_3,S_4$。
- **学习笔记**：  
  将**乘法分配律**与**前缀和**结合，是降维的核心技巧。

#### 关键点3：边界与取模处理
- **分析**：  
  所有运算需在模 $9712176$ 下进行，注意负数取模（`+MOD`）。
- **学习笔记**：  
  在每一步更新树状数组或计算答案时，及时取模，避免溢出。

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 时间复杂度 | 优缺点 | 适用场景 |
|------|----------|------------|--------|----------|
| **暴力枚举** | 枚举所有三段区间 | $O(n^3)$ | 思路直观，但超时 | $n \leq 60$ |
| **固定中间+暴力** | 固定 $j$，两侧 $O(n)$ 枚举 | $O(n^2)$ | 可拿部分分 | $n \leq 2000$ |
| **单调栈+树状数组** | 预处理 $c_i,d_i$，扫描线维护前缀和 | $O(n\log n)$ | 最优解，代码简洁 | $n \leq 10^6$ |

---

## 4. C++核心代码实现赏析

### 通用核心C++实现参考
> 综合了所有题解的精华，提供一个**清晰完整**的 $O(n\log n)$ 实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 9712176;

int n, a[1000005], pos[1000005];
int lmn[1000005], rmn[1000005], lmx[1000005], rmx[1000005];
int c[1000005], d[1000005];

struct Fenwick {
    ll t[1000005];
    void add(int x, ll v) {
        for (; x <= n; x += x & -x) t[x] = (t[x] + v) % MOD;
    }
    ll sum(int x) {
        ll res = 0;
        for (; x; x -= x & -x) res = (res + t[x]) % MOD;
        return res;
    }
} t1, t2, t3, t4;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        pos[a[i]] = i;
    }

    // 单调栈预处理
    vector<int> stk;
    stk.push_back(0);
    for (int i = 1; i <= n + 1; ++i) {
        while (stk.size() > 1 && (i == n + 1 || a[stk.back()] > a[i])) {
            rmn[stk.back()] = i;
            stk.pop_back();
            lmn[stk.back() + 1] = i;
        }
        stk.push_back(i);
    }
    stk.assign(1, 0);
    for (int i = 1; i <= n + 1; ++i) {
        while (stk.size() > 1 && (i == n + 1 || a[stk.back()] < a[i])) {
            rmx[stk.back()] = i;
            stk.pop_back();
            lmx[stk.back() + 1] = i;
        }
        stk.push_back(i);
    }
    for (int i = 1; i <= n; ++i) {
        c[i] = (ll)(i - lmn[i]) * (rmn[i] - i) % MOD;
        d[i] = (ll)(i - lmx[i]) * (rmx[i] - i) % MOD;
    }

    ll ans = 0;
    for (int val = 1; val <= n; ++val) {
        int p = pos[val];
        ll s1 = t1.sum(p - 1), s2 = t2.sum(n) - t2.sum(p);
        ll s3 = t3.sum(p - 1), s4 = t4.sum(n) - t4.sum(p);
        ans = (ans + c[p] * (val * val % MOD * s1 % MOD * s2 % MOD
                           - val * s3 % MOD * s2 % MOD
                           - val * s1 % MOD * s4 % MOD
                           + s3 * s4 % MOD + MOD * 2) % MOD) % MOD;
        t1.add(p, d[p]);
        t2.add(p, d[p]);
        t3.add(p, d[p] * val % MOD);
        t4.add(p, d[p] * val % MOD);
    }
    cout << (ans + MOD) % MOD << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题：像素极值探险
- **场景**：8位像素风格的排列条形图，每个数字用像素方块表示。
- **核心演示**：
  1. **单调栈动画**：  
     像素方块从左侧滑入，遇到比它小的方块时弹出，并高亮标记`lmn[i]`和`rmn[i]`。
  2. **扫描线+树状数组**：  
     一个像素化的“扫描线”从左到右移动，每经过 $a_j$ 时，在左侧和右侧的“前缀和仓库”（树状数组）中更新 $d_i$ 和 $d_i \cdot a_i$。
  3. **贡献计算**：  
     当扫描线到达 $a_j$ 时，从仓库中取出 $S_1,S_2,S_3,S_4$，用像素化的“计算器”实时计算贡献，并累加到总答案。

### 交互设计
- **控制面板**：  
  - 单步/自动播放按钮（像素按钮风格）。  
  - 速度滑块（8位像素滑块）。  
- **音效**：  
  - 单调栈弹出时播放“叮”声。  
  - 扫描线移动时播放“哒哒”声。  
  - 贡献更新时播放“胜利”音效。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **单调栈+扫描线**：  
  适用于所有**区间极值**+**前缀和统计**问题，例如：  
  1. **柱状图最大矩形**（LeetCode 84）  
  2. **滑动窗口最大值**（LeetCode 239）  
  3. **区间和统计**（CF 1107E）

### 洛谷推荐练习
1. **P1908 逆序对**  
   - 推荐理由：用树状数组维护前缀和，熟悉扫描线思想。
2. **P2866 奶牛排队**  
   - 推荐理由：单调栈+区间极值，与本题思路高度相似。
3. **P4198 楼房重建**  
   - 推荐理由：扫描线+树状数组，处理二维区间统计问题。

---

## 7. 学习心得与经验分享

> **来自 UniGravity 的调试心得**：  
> “我在写单调栈时，一开始把 `lmn[i]` 和 `rmn[i]` 的边界写反了，导致贡献统计错误。后来用**打印中间变量**的方法，一步步验证每个 $a_i$ 的区间范围，才定位到问题。”  
> **洛语云笺点评**：  
> 单调栈的边界条件（是否包含等于）和树状数组的取模处理，是这类题的常见坑点。动手模拟样例，是排错的最佳方式！

---

> **总结**：  
> 从暴力到最优解，我们经历了**问题转化**、**降维打击**、**数据结构优化**的全过程。记住，再复杂的式子，也能通过**拆分**和**数据结构**优雅解决！下次见！

---
处理用时：108.89秒
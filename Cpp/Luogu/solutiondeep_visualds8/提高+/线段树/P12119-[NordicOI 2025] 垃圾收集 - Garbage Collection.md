# 题目信息

# [NordicOI 2025] 垃圾收集 / Garbage Collection

## 题目描述

北海上漂浮着 $N$ 块垃圾，编号从 $1$ 到 $N$。第 $i$ 块垃圾位于坐标 $\left(x_{i}, y_{i}\right)$，重量为 $w_{i}$。作为一项清理行动的一部分，你需要在某个矩形区域内收集所有垃圾。这个矩形区域的宽度为 $W$，高度为 $H$，但具体位置尚未确定。

你的任务是确定在最佳位置放置清理区域时，能够收集到的垃圾总重量的最大值。

译者注：「北海（North Sea）」指的是是北大西洋的一部分，不是广西壮族自治区北海市。

## 说明/提示

【样例解释】

最佳的清理区域应覆盖坐标为 $(3,1)$、$(2,1)$ 和 $(1,0)$ 的垃圾，总重量为 $10+5+5=20$。

![](https://cdn.luogu.com.cn/upload/image_hosting/9ln6vecp.png)

【数据规模与约定】

对于所有数据，满足：

$1 \leq N \leq 10^{5},1 \leq W, H \leq 10^{9},0 \leq x_{i}, y_{i} < 10^{9}(1 \leq i \leq N),1 \leq w_{i} \leq 10^{9}(1 \leq i \leq N)$。

详细子任务附加限制及分值如下表所示：

|  子任务编号| 分值 | 特殊限制 |
| :-----------: | :-----------: |:-----------: |
| $1$ | $10$ | $N \le 400$ |
| $2$ | $12$ | $W,H,x_i,y_i \le 2000$ |
| $3$ | $15$ | $N \le 2000$ |
| $4$ | $22$ | $H=10^9$ |
| $5$ | $23$ | $W,H,x_i,y_i \le 10^5$ |
| $6$ | $18$ |无特殊限制  |

## 样例 #1

### 输入

```
5 3 2
3 1 10
2 1 5
1 0 5
0 2 10
1 3 5
```

### 输出

```
20```

# AI分析结果

# 💡 洛语云笺的C++算法解析：[NordicOI 2025] 垃圾收集 / Garbage Collection 深入学习指南 💡

> 今天我们来一起分析「垃圾收集」这道C++编程题。这不仅仅是一次解题，更是一场思维的探险：如何在茫茫大海里，用一块固定大小的“渔网”捞出最重的垃圾组合？我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“用一块宽 W、高 H 的矩形框，在二维平面上框住若干点，使框内所有点的权值和最大。”  
核心难点在于：  
1. 坐标范围巨大（1e9），无法暴力枚举矩形左上角；  
2. 点数高达 1e5，需要 O(n log n) 级别算法。

✨ **核心算法标签**：扫描线 + 离散化 + 线段树（或双指针+线段树）

🗣️ **初步分析**：  
- 最朴素的做法：枚举矩形左上角 O(n^3) 显然爆炸。  
- 观察到矩形尺寸固定，可把“矩形”抽象成“移动窗口”：  
  – 先固定横坐标区间长度 W（双指针/扫描线）；  
  – 再在纵坐标上用线段树维护“窗口”内点的总权值最大值。  
- 于是二维问题→一维问题，复杂度降到 O(n log n)。

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 发现内容 | 对应算法启示 |
|---|---|---|
| 线索1 | 矩形尺寸固定 | 可把矩形左上角转化为“移动窗口”问题 |
| 线索2 | 坐标值域1e9 | 必须离散化或压缩坐标 |
| 线索3 | N≤1e5 | 需要 O(n log n) 数据结构——线段树/树状数组 |

### 🧠 思维链构建：从线索到策略
> 1. 先想暴力枚举矩形左上角，但坐标1e9 → 不可行。  
> 2. 观察到矩形宽高固定，于是把问题拆成“先确定横坐标区间，再快速统计纵坐标区间和”。  
> 3. 横坐标区间可用双指针或扫描线维护“长度≤W”。  
> 4. 纵坐标区间加/区间最大值 → 线段树。  
> 5. 离散化纵坐标即可在 O(n log n) 内完成。  

---

## 2. 精选优质题解参考

### 题解一：seika27（赞：4）
**点评**：  
思路清晰，采用“双指针+线段树”的经典套路：  
- 按 x 排序后，用双指针维护区间 [j,i] 满足 x_i - x_j ≤ W。  
- 纵坐标离散化后，线段树维护区间 [y-H+1, y] 的权值和最大值。  
- 每个垃圾进出集合一次，复杂度 O(n log n)。  
代码实现简洁，变量命名直观，值得学习。

### 题解二：wangyanjing（赞：3）  
**点评**：  
采用“扫描线”思想：  
- 把每个垃圾转化为“垃圾可贡献的矩形区域”，再求这些矩形重叠处的最大权值和。  
- 扫描线按 y 排序，线段树维护 x 方向的区间加/区间最大值。  
- 离散化 x 坐标，复杂度 O(n log n)。  
思路更通用，可迁移到“窗口星星”等经典问题。

### 题解三：Zskioaert1106（赞：0）  
**点评**：  
与 wangyanjing 类似，但把“垃圾贡献矩形”拆成两条扫描线（加边/减边），实现细节清晰，代码风格统一，适合初学者对照学习。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 问题降维** | 把二维问题拆成“先固定横坐标区间，再统计纵坐标区间和” | 固定一维后，另一维可用数据结构维护 |
| **2. 离散化** | 坐标1e9 → 离散化到1e5级别 | 离散化是处理大值域的经典技巧 |
| **3. 线段树维护** | 区间加、区间最大值 → 线段树 | 线段树是处理区间信息的利器 |

### ✨ 解题技巧总结
- **技巧A：双指针+线段树**：先排序一维，再用双指针维护窗口，线段树维护另一维。  
- **技巧B：扫描线**：把二维问题转化为“事件”序列，线段树维护区间信息。  
- **技巧C：离散化**：压缩坐标，降低数据结构复杂度。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 枚举矩形左上角，统计内部点 | 思路直观 | O(n^3) 爆炸 | N≤200 |
| **双指针+线段树** | 双指针维护横坐标区间，线段树维护纵坐标区间 | 代码简洁，思路清晰 | 需离散化 | N≤1e5 |
| **扫描线** | 把垃圾转化为矩形事件，扫描线+线段树 | 通用性强，可处理复杂形状 | 需离散化，实现稍复杂 | N≤1e5 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. 起点：暴力枚举矩形左上角 → 复杂度爆炸。  
> 2. 发现瓶颈：二维枚举无法承受。  
> 3. 优化钥匙：固定矩形尺寸，降维处理。  
> 4. 模型升华：双指针/扫描线+线段树，复杂度 O(n log n)。  

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合 seika27 与 Masterwei 思路，提供完整双指针+线段树实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int MAXN = 1e5 + 5;

struct Point {
    int64 x, y, w;
};

int n;
int64 W, H;
Point p[MAXN];

// 离散化纵坐标
vector<int64> ys;
int get_id(int64 y) {
    return lower_bound(ys.begin(), ys.end(), y) - ys.begin() + 1;
}

// 线段树：区间加、区间最大值
struct SegmentTree {
    int n;
    vector<int64> mx, tag;
    SegmentTree(int n) : n(n), mx(n * 4), tag(n * 4) {}
    void push_down(int u) {
        if (tag[u]) {
            mx[u * 2] += tag[u];
            mx[u * 2 + 1] += tag[u];
            tag[u * 2] += tag[u];
            tag[u * 2 + 1] += tag[u];
            tag[u] = 0;
        }
    }
    void update(int u, int l, int r, int L, int R, int64 v) {
        if (L <= l && r <= R) {
            mx[u] += v;
            tag[u] += v;
            return;
        }
        push_down(u);
        int mid = (l + r) / 2;
        if (L <= mid) update(u * 2, l, mid, L, R, v);
        if (R > mid) update(u * 2 + 1, mid + 1, r, L, R, v);
        mx[u] = max(mx[u * 2], mx[u * 2 + 1]);
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> W >> H;
    for (int i = 1; i <= n; ++i) {
        cin >> p[i].x >> p[i].y >> p[i].w;
        ys.push_back(p[i].y);
        ys.push_back(p[i].y - H + 1);
    }
    sort(p + 1, p + n + 1, [](const Point& a, const Point& b) {
        return a.x < b.x;
    });
    sort(ys.begin(), ys.end());
    ys.erase(unique(ys.begin(), ys.end()), ys.end());
    int m = ys.size();
    SegmentTree seg(m);
    int64 ans = 0;
    for (int l = 1, r = 1; r <= n; ++r) {
        int y1 = get_id(p[r].y - H + 1);
        int y2 = get_id(p[r].y);
        seg.update(1, 1, m, y1, y2, p[r].w);
        while (p[r].x - p[l].x >= W) {
            int y1_l = get_id(p[l].y - H + 1);
            int y2_l = get_id(p[l].y);
            seg.update(1, 1, m, y1_l, y2_l, -p[l].w);
            ++l;
        }
        ans = max(ans, seg.mx[1]);
    }
    cout << ans << '\n';
    return 0;
}
```

**代码解读概要**：  
- 离散化纵坐标，线段树维护区间加/区间最大值。  
- 双指针维护横坐标区间长度≤W。  
- 每加入/删除一个点，对应纵坐标区间[y-H+1, y]权值加/减w。  

### 各优质题解片段赏析

**seika27 片段：双指针+线段树**
```cpp
while(a[j].x+w-1<a[i].x)subaru.update(1,1,n,a[j].ly,a[j].hy,-a[j].w),++j;
```
> 亮点：简洁的双指针条件，确保区间长度≤W。

**wangyanjing 片段：扫描线**
```cpp
Key[a[i].x1].push_back({l,r,a[i].val});
Key[a[i].x2+1].push_back({l,r,-a[i].val});
```
> 亮点：把垃圾转化为“加边/减边”事件，扫描线思想清晰。

---

## 5. 算法可视化：像素动画演示

### 动画主题
**《像素清道夫》**：8位像素风格的北海地图，玩家操控一块固定大小的“像素网”收集垃圾。

### 设计思路
- **场景**：256×192 像素画布，绿色海域、灰色垃圾方块。  
- **数据结构**：  
  - 横坐标：双指针滑窗，指针用闪烁箭头标记。  
  - 纵坐标：离散化后的线段树，用像素条显示区间和。  
- **交互**：  
  - 单步/自动播放按钮，速度滑块。  
  - 每移动一次指针，播放“嘀嗒”音效；区间加值时方块颜色闪烁。  
  - 找到更优解时，播放胜利音效，像素星星飞舞。  

### 关键帧
1. 初始化：所有垃圾随机分布。  
2. 双指针右移：指针闪烁，线段树区间加值动画。  
3. 发现更优解：高亮当前矩形，显示总重量。  

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **窗口星星**：固定半径圆内星星最大权值和。  
- **课程冲突**：每天只能选一门课，求最大学分。  
- **任务选择**：互斥任务只能选一个，求最大收益。

### 洛谷推荐
- **P1502 窗口的星星**：扫描线+线段树模板题。  
- **P4141 消失之物**：分组背包，体验“每组多选一”思想。  
- **P2569 股票交易**：区间DP，练习降维与离散化技巧。

---

## 7. 学习心得与经验分享
> seika27 提到：“离散化时要注意坐标范围，避免越界。”  
**点评**：离散化后区间端点需+1或-1，常见坑点。

---

<conclusion>
本次「垃圾收集」之旅展示了如何把二维问题降维，再用双指针/扫描线+线段树优雅解决。记住：  
- 大坐标先离散化；  
- 固定一维，另一维用数据结构维护；  
- 多画图、多模拟，像素动画助理解。  
下次再一起探索新的算法海洋！💪

---
处理用时：65.73秒
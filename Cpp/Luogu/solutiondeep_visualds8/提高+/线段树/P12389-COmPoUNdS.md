# 题目信息

# COmPoUNdS

## 题目背景

小 S 因为某些原因对区间加区间取模情有独钟，他造了一些这样的题但是基本上都不会做。有一天小 S 误食了一点冰红茶突然灵感迸发把所有题都秒了，于是趁着药效他随便选了一道题造了数据，然而药效过了后他也不知道怎么做了，所以请你帮他写一下标程，事成送你一瓶冰红茶。

## 题目描述

给定正整数 $n,k,q$ 和一个长度为 $n$ 的序列 $a$，$q$ 次操作或询问：
- `1 l r c`，对于每个 $i\in[l,r]$，令 $a_i\gets(a_i+c)\bmod k$。
- `2 l1 r1 l2 r2`，判断 $a$ 的两个长度相同的子段 $a_{l_1\cdots r_1},a_{l_2\cdots r_2}$ 是否相等。

## 说明/提示

**本题采用捆绑测试及子任务依赖。**

| 子任务编号 | 分值 | 特殊限制 | 依赖子任务 | 时间限制 |
| :---: | :---: | :---: | :---: | :---: |
| $1$ | $10$ | $n,q\le 10^3$ | | $\text{1.5 s}$
| $2$ | $20$ | $k=2$ | | $\text{2.5 s}$
| $3$ | $20$ | $n\le10^5$ | $1$ | $\text{1.5 s}$
| $4$ | $50$ | 无特殊限制 | $1,2,3$ | $\text{2.5 s}$
 
对于全部数据，$1\le n,q\le 10^6$，$2\le k\le 10^6$，$0\le a_i,c<k$，对于 2 操作 $r_1-l_1=r_2-l_2$。

## 样例 #1

### 输入

```
6 3 6
0 1 2 0 1 2
2 1 2 1 2
2 1 2 4 5
2 1 2 5 6
1 1 2 1
2 1 2 4 5
2 1 2 5 6```

### 输出

```
Yes
Yes
No
No
Yes```

# AI分析结果

# 💡 洛语云笺的C++算法解析：COmPoUNdS 深入学习指南 💡

> 各位少年探险家，欢迎来到“COmPoUNdS”这片神秘的区间取模大陆！  
> 今天我们要挑战的，是**区间加+区间取模+区间判等**的三重魔法。  
> 别担心，洛语云笺会带你们从“暴力”的泥潭一步步走向“优雅”的线段树之巅！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
> 在**模意义下**，如何高效地  
> 1. 对区间做加法并取模；  
> 2. 快速判断两个子段是否**完全一致**。  

✨ **核心算法标签**  
线段树（区间维护哈希+差分）、树状数组、模意义下差分不变性证明。

🗣️ **初步分析**  
- 暴力做法：直接模拟区间加，再逐元素比对——时间 $O(qn)$，显然 TLE。  
- 关键突破口：**差分数组在模意义下的稳定性**（后文证明）。  
- 最优策略：  
  1. 把区间加转化为**单点修改差分数组**；  
  2. 用**线段树**维护差分数组的**哈希值**；  
  3. 用**树状数组/线段树**维护前缀和，还原首元素。  
- 生动比喻：差分就像“相邻格子的相对高度”，即使整体加高再取模，它们之间的“相对高度”依旧不变！

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 原文关键词 | 侦探推理 |
|---|---|---|
| **线索1：区间加取模** | `(a_i+c) mod k` | 直接区间加线段树会失效，必须找“不变量”。 |
| **线索2：判等** | `a[l1..r1] == a[l2..r2]` | 判等=首元素相等+差分数组相等。 |
| **线索3：数据规模** | $n,q\le 10^6$ | 必须 $O(n+q\log n)$ 级别算法，线段树/树状数组呼之欲出。 |

### 🧠 思维链构建：从线索到策略
> 1. 看到“区间加取模”，我首先想到**差分**：把区间修改变成单点修改。  
> 2. 但模运算会不会破坏差分？——**动手验证**！发现差分在模意义下**仍然唯一**，只有两端会变化。  
> 3. 判等需要首元素+差分数组，于是：  
>    - 首元素用**树状数组**维护前缀和；  
>    - 差分数组用**线段树**维护**哈希值**（防碰撞）。  
> 4. 复杂度完美符合数据范围，**这就是正解**！

---

## 2. 精选优质题解参考

### 题解一：rizynvu（赞：9）  
**点评**  
- 思路极清晰：先证明差分不变性，再给出**树状数组+线段树**的简洁实现。  
- 代码规范：变量命名直观，`query1/2` 分工明确。  
- 亮点：用**单点修改**完成区间加，避免复杂的懒标记。

### 题解二：CQ_Bab（赞：3）  
**点评**  
- 证明部分用“差值最多 $k-1$”**反证**差分唯一，逻辑严谨。  
- 代码风格：宏定义+模板封装，适合竞赛快速复用。  
- 细节：用 `modify1` 单独更新差分端点，避免遗漏。

### 题解三：LastKismet（赞：1）  
**点评**  
- 引入**自定义 `mint` 类**，展示现代 C++ 的运算符重载技巧。  
- 线段树节点封装 `lazy/hsh/len`，结构清晰。  
- 适合学习**模块化设计**。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析与学习笔记 |
|---|---|
| **差分不变性证明** | 若 $x,x+d$ 与 $x,x+d-k$ 同时成立，则 $x+d<k$ 且 $x+d-k\ge 0$，矛盾！因此差分在模意义下唯一。💡 **笔记**：动手模几组数据，直觉往往正确。 |
| **区间加→单点修改** | 区间 `[l,r]` 加 $c$：差分数组仅 $b_l$ 和 $b_{r+1}$ 改变。💡 **笔记**：差分是区间修改的“大杀器”。 |
| **判等→首元素+哈希** | 两子段相等 $\iff$ $a_{l1}=a_{l2}$ 且差分数组哈希相等。💡 **笔记**：哈希用**双模数**防碰撞，如 `13331+1e9+7`。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力模拟** | 逐元素修改+比对 | 思路直观 | $O(qn)$ TLE | 10%（子任务1） |
| **线段树+差分** | 单点改差分+哈希判等 | $O(n+q\log n)$ 最优 | 需证明差分不变性 | 100% |
| **树状数组+线段树** | 树状数组维护首元素，线段树维护差分哈希 | 代码简洁 | 需双数据结构 | 100% |

### ✨ 优化之旅
> 从暴力到最优，我们经历了：  
> 1. 暴力模拟（TLE）→  
> 2. 发现差分不变性（关键突破）→  
> 3. 用线段树维护哈希（高效判等）。  
> 这告诉我们：**数学证明+数据结构=优雅解法**！

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
**说明**：综合 rizynvu 与 CQ_Bab 的思路，提供**树状数组+线段树**的完整实现。

```cpp
#include <bits/stdc++.h>
using namespace std;

using u64 = unsigned long long;
const u64 p = 13331, mod = 998244853;
const int maxn = 1e6 + 10;

int n, K, q, a[maxn];
u64 jc[maxn], sum[maxn];

// 线段树维护差分数组的哈希
struct Node {
    u64 sum, pw;
    Node(u64 s = 0, u64 pw_ = 1) : sum(s), pw(pw_) {}
    Node operator+(const Node& o) const {
        return Node((sum + pw * o.sum) % mod, pw * o.pw % mod);
    }
} tr[maxn * 4];

void build(int k = 1, int l = 1, int r = n) {
    if (l == r) {
        tr[k] = Node((a[l] - a[l - 1] + K) % K, p);
        return;
    }
    int mid = (l + r) >> 1;
    build(k << 1, l, mid);
    build(k << 1 | 1, mid + 1, r);
    tr[k] = tr[k << 1] + tr[k << 1 | 1];
}

void update(int x, int y, int k = 1, int l = 1, int r = n) {
    if (l == r) {
        tr[k].sum = (tr[k].sum + y) % K;
        return;
    }
    int mid = (l + r) >> 1;
    if (x <= mid) update(x, y, k << 1, l, mid);
    else update(x, y, k << 1 | 1, mid + 1, r);
    tr[k] = tr[k << 1] + tr[k << 1 | 1];
}

Node query(int x, int y, int k = 1, int l = 1, int r = n) {
    if (x <= l && r <= y) return tr[k];
    int mid = (l + r) >> 1;
    if (y <= mid) return query(x, y, k << 1, l, mid);
    if (mid < x) return query(x, y, k << 1 | 1, mid + 1, r);
    return query(x, y, k << 1, l, mid) + query(x, y, k << 1 | 1, mid + 1, r);
}

// 树状数组维护前缀和
void add(int x, int y) {
    for (; x <= n; x += x & -x) sum[x] += y;
}
u64 qry(int x) {
    u64 res = 0;
    for (; x >= 1; x -= x & -x) res += sum[x];
    return res;
}

int main() {
    scanf("%d%d%d", &n, &K, &q);
    for (int i = 1; i <= n; i++) scanf("%d", &a[i]);

    build();
    for (int i = 1; i <= n; i++) {
        sum[i] += a[i] - a[i - 1];
        if (i + (i & -i) <= n) sum[i + (i & -i)] += sum[i];
    }

    while (q--) {
        int op;
        scanf("%d", &op);
        if (op == 1) {
            int l, r, c;
            scanf("%d%d%d", &l, &r, &c);
            update(l, c), add(l, c);
            if (r < n) update(r + 1, (K - c) % K), add(r + 1, -c);
        } else {
            int l1, r1, l2, r2;
            scanf("%d%d%d%d", &l1, &r1, &l2, &r2);
            if (qry(l1) % K != qry(l2) % K) {
                puts("No");
            } else if (l1 < r1 && query(l1 + 1, r1).sum != query(l2 + 1, r2).sum) {
                puts("No");
            } else {
                puts("Yes");
            }
        }
    }
    return 0;
}
```

### 题解代码片段赏析

#### rizynvu 的 `query` 函数
```cpp
inline info_ query(int x, int y, int k = 1, int l = 1, int r = n) {
    if (x <= l && r <= y) return tr[k];
    int mid = l + r >> 1;
    if (y <= mid) return query(x, y, k << 1, l, mid);
    if (mid < x) return query(x, y, k << 1 | 1, mid + 1, r);
    return query(x, y, k << 1, l, mid) + query(x, y, k << 1 | 1, mid + 1, r);
}
```
- **亮点**：重载 `+` 运算符，将哈希合并封装为 `Node + Node`，代码优雅。  
- **学习笔记**：线段树区间合并时，哈希需考虑**左区间长度**作为指数。

#### CQ_Bab 的 `modify1` 单点更新
```cpp
void modify1(int u,int k,int x) {
    if(tr[u].l==tr[u].r) {
        tr[u].has=k;
        return;
    }
    int mid=tr[u].l+tr[u].r>>1;
    if(mid>=x) modify1(u<<1,k,x);
    else modify1(u<<1|1,k,x);
    up(u);
}
```
- **亮点**：单独处理差分端点，避免懒标记复杂性。  
- **学习笔记**：差分修改=两次单点修改，线段树无需区间懒标记。

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“差分守卫战”**  
- **场景**：8位像素风格的“差分数组城墙”，每次区间加是“投石机攻击”，哈希值是“城墙指纹”。  
- **核心演示**：  
  1. 区间 `[l,r]` 加 $c$：城墙两端（$l$ 和 $r+1$）的差分砖块**闪烁变色**，伴随“叮”音效。  
  2. 判等时：首元素用树状数组**逐格累加**（像素小人搬运金币），差分数组哈希用线段树**区间合并**（像素砖块拼接）。  
- **交互**：  
  - 步进按钮：逐帧观察差分砖块变化。  
  - 自动模式：AI投石机连续攻击，实时更新哈希。  
  - 胜利音效：判等为 `Yes` 时播放8位“胜利”音调。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
差分+哈希的组合适用于：  
1. **区间加+区间判等**（如本题）。  
2. **区间乘+区间判等**（将乘法转为对数差分）。  
3. **区间异或+区间判等**（异或本身可差分）。

### 洛谷推荐
1. **P3372** - 线段树模板1  
   🗣️ 推荐理由：巩固线段树区间修改与查询基础。  
2. **P3368** - 树状数组模板2  
   🗣️ 推荐理由：掌握树状数组的区间加与单点查。  
3. **P4560** - 差分+哈希判等  
   🗣️ 推荐理由：本题简化版，无取模，适合练习差分哈希。

---

## 7. 学习心得与经验分享

> **rizynvu 的调试心得**：“最初没意识到差分在模意义下不变，手模样例发现哈希冲突，后来用反证法严格证明，才放心提交。”  
> **点评**：动手验证+数学证明是避免哈希冲突的“双保险”！

---

<conclusion>
恭喜完成“COmPoUNdS”探险！记住：  
- **差分是区间修改的钥匙**；  
- **哈希是判等的盾牌**；  
- **数学证明是信心的源泉**。  
下次我们再挑战更酷的算法！💪
</conclusion>

---
处理用时：78.72秒
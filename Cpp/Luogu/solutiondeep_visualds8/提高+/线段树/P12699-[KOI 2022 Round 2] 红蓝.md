# 题目信息

# [KOI 2022 Round 2] 红蓝

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

在坐标平面上有 $N$ 个红色点和 $M$ 个蓝色点。给定自然数 $W$ 和 $H$。

第 $i$ 个 ($1 \leq i \leq N$) 红色点的坐标是 $(r_{xi}, r_{yi})$，第 $j$ 个 ($1 \leq j \leq M$) 蓝色点的坐标是 $(b_{xj}, b_{yj})$。

所有点的坐标都是不同的。

我们需要放置一个宽度为 $W$，高度为 $H$ 的矩形，该矩形的边与坐标轴平行，并且它的四个顶点是整数坐标。我们希望最大化矩形内包含的红色点与蓝色点数量之差。

矩形包含点的条件是：如果矩形的左下角坐标为 $(a, b)$，且点的坐标为 $(x, y)$，那么该点包含在矩形内当且仅当满足 $a \leq x \leq a+W$ 且 $b \leq y \leq b+H$。

我们要求得这个差值的最大值，并找到符合这个最大差值的矩形位置。

下图展示了在平面上有 3 个红色点和 4 个蓝色点的情况。为了说明问题，红色点用圆圈表示，蓝色点用三角形表示。

![](https://cdn.luogu.com.cn/upload/image_hosting/1j8grh16.png)

假设 $W = 5$，$H = 3$，那么如果将矩形的左下角放在 $(3, 3)$，矩形内包含 1 个红色点和 3 个蓝色点，这时点的数量差为 2。无论矩形放置在哪里，点的数量差都不会大于 3，因此答案是 2。

![](https://cdn.luogu.com.cn/upload/image_hosting/fxgmqc3b.png)

## 说明/提示

**约束条件**

- $1 \leq N, M \leq 100\,000$
- $1 \leq W, H \leq 10^9$
- $1 \leq r_{xi}, r_{yi} \leq 10^9$ ($1 \leq i \leq N$)
- $1 \leq b_{xj}, b_{yj} \leq 10^9$ ($1 \leq j \leq M$)

**子任务**

1. （5 分）$1 \leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \leq 50$
2. （11 分）$1 \leq N, M, W, H, r_{xi}, r_{yi}, b_{xj}, b_{yj} \leq 1\,000$
3. （15 分）$1 \leq N, M \leq 100$
4. （9 分）$1 \leq N, M \leq 1\,000$
5. （60 分）无额外约束条件

## 样例 #1

### 输入

```
3 4 5 3
3 2
2 5
7 6
1 2
4 3
3 6
7 4```

### 输出

```
2
3 3```

## 样例 #2

### 输入

```
3 3 4 4
1 1
2 2
3 3
1 3
3 1
4 4```

### 输出

```
2
-2 -2```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：KOI 2022 Round 2「红蓝」深入学习指南 💡

> 各位少年好！今天我们要一起拆解一道“扫描线+线段树”的硬核几何题——**红蓝**。  
> 它表面上是在平面上画矩形，实则考察“如何把二维问题压成一维”的思维魔法。让我们像侦探一样，从题目描述里抽丝剥茧，找到那条最高效的解题路径！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在10⁵个红/蓝点中，快速找出**所有边平行坐标轴、尺寸固定为 W×H** 的矩形，使得 **矩形内（红点数-蓝点数）的绝对值最大**。  
注意：坐标范围 1…10⁹，暴力枚举矩形左上角会瞬间爆炸。

✨ **核心算法标签**：扫描线、线段树、离散化、区间最值

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1（问题目标）**：“最大化差值” → 经典 **最值问题**，提示需要高效区间统计。
2. **线索2（几何约束）**：矩形尺寸固定，意味着 **平移时只会整体移动**；点的坐标离散 → **离散化** 可缩小值域。
3. **线索3（数据规模）**：N,M ≤ 1e5 → O((N+M) log(N+M)) 的 **扫描线+线段树** 是合理复杂度。

### 🧠 思维链构建：从线索到策略
> 1. 先把“矩形覆盖”转成“区间加/减”：  
>    对于每个点(x,y)，它在矩形左下角(a,b)满足 `a ≤ x ≤ a+W` 且 `b ≤ y ≤ b+H` 时被覆盖。  
>    反过来，该点能贡献的(a,b)范围是 `[x-W, x] × [y-H, y]`。  
> 2. 把二维问题降维：  
>    固定纵坐标区间 `[b, b+H]`，问题退化为 **在x轴上求区间和的最大/最小值** —— 这正是扫描线+线段树的拿手好戏！  
> 3. 最终策略：  
>    **扫描线沿y轴从下往上扫**，用线段树维护 **每个x位置** 当前纵带 `[b,b+H]` 内的红蓝差值，实时查询全局最值即可。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 点评（洛语云笺口吻） |
|------|-----------|------------------------|
| **ImposterAnYu** | 双指针+两根扫描线，区间直接加±1，线段树维护极值。 | 思路最直观：把“纵坐标差≤H”的两条线夹住的点一次性丢进线段树，左端点+1/-1，右端点-1/+1。代码结构清晰，变量名到位。 |
| **hjhAKIOI** | 把每个点拆成“入边/出边”，扫描线沿x轴扫，线段树维护区间和。 | 把矩形贡献区间拆成 `[x, x+W+1)` 两条竖线，沿x排序后扫描。与星星窗口神似，模板感更强。 |
| **Zskioaert1106** | 沿y轴扫描线，区间 `[x, x+W]` 加±1，同时记录极值坐标。 | 细节最丰富：区间端点+1/-1的边界处理、离散化两次、线段树节点同时存极值与坐标。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：沿y轴扫描线）
| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 离散化** | 坐标1e9 → 离散化到O(N)级别，避免线段树MLE。 | 离散化是“把无限值域压进有限数组”的万能钥匙。 |
| **2. 事件定义** | 把每个点拆成两条水平线：<br>- 下线 `y` 处：区间 `[x-W, x]` 加 `+1`(红) / `-1`(蓝)<br>- 上线 `y+H+1` 处：区间 `[x-W, x]` 加 `-1` / `+1` | 事件 = 扫描线遇到“开始贡献”或“结束贡献”的时刻。 |
| **3. 线段树维护** | 维护区间和的最大/最小值，以及取得极值的x坐标。区间加/减使用懒标记。 | 线段树节点多存一个“极值坐标”即可在O(log)内同时拿到值与位置。 |
| **4. 扫描过程** | 按y排序所有事件线；<br>用双指针维护当前纵带 `[b, b+H]` 内的所有事件；<br>每移动一次指针，把新进入/离开纵带的点更新到线段树；<br>用线段树根节点极值更新答案。 | 双指针保证每个点最多进/出一次，整体复杂度O((N+M) log(N+M))。 |

### ✨ 解题技巧总结
- **问题降维**：二维矩形覆盖 → 一维区间加 → 扫描线。
- **事件思想**：把“开始/结束”抽象成事件，排序后一次性处理。
- **极值与坐标同存**：线段树节点同时记录极值和对应坐标，输出方案零额外成本。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
|---|---|---|---|---|
| 暴力枚举左上角 | 四重循环 | 思路零门槛 | O(N²M²) 直接TLE | N,M≤50 子任务1 |
| 离散化+二维前缀和 | 二维差分数组 | 代码短 | 值域大时空间爆炸 | N,M≤1e3 子任务4 |
| 扫描线+线段树（最优） | 事件+区间极值 | O(N log N) 全过 | 需要离散化+线段树熟练度 | 100% 满分 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合三条优质题解，给出最简洁易懂的“沿y轴扫描线”实现。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int MAX = 4e5 + 10;   // 2*(n+m) 事件线
struct Event {
    int y, x1, x2, val;     // y: 线位置, [x1,x2] 区间加 val
    bool operator<(const Event& o) const { return y < o.y; }
} ev[MAX];
int n, m, W, H, tot;
int xs[MAX], xn;

int compress(int x) {
    return lower_bound(xs + 1, xs + xn + 1, x) - xs;
}

// 线段树：区间加，维护max/min 及位置
struct Node {
    int mx, mn, pos_mx, pos_mn, tag;
} tr[MAX << 2];

void build(int p, int l, int r) {
    tr[p].mx = tr[p].mn = 0;
    tr[p].pos_mx = tr[p].pos_mn = l;
    tr[p].tag = 0;
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
}

inline void push(int p, int v) {
    tr[p].mx += v; tr[p].mn += v; tr[p].tag += v;
}
inline void down(int p) {
    if (tr[p].tag) {
        push(p << 1, tr[p].tag);
        push(p << 1 | 1, tr[p].tag);
        tr[p].tag = 0;
    }
}
void update(int p, int l, int r, int ql, int qr, int v) {
    if (ql <= l && r <= qr) { push(p, v); return; }
    down(p);
    int mid = (l + r) >> 1;
    if (ql <= mid) update(p << 1, l, mid, ql, qr, v);
    if (qr > mid)  update(p << 1 | 1, mid + 1, r, ql, qr, v);
    // 合并极值
    if (tr[p << 1].mx >= tr[p << 1 | 1].mx) {
        tr[p].mx = tr[p << 1].mx;
        tr[p].pos_mx = tr[p << 1].pos_mx;
    } else {
        tr[p].mx = tr[p << 1 | 1].mx;
        tr[p].pos_mx = tr[p << 1 | 1].pos_mx;
    }
    if (tr[p << 1].mn <= tr[p << 1 | 1].mn) {
        tr[p].mn = tr[p << 1].mn;
        tr[p].pos_mn = tr[p << 1].pos_mn;
    } else {
        tr[p].mn = tr[p << 1 | 1].mn;
        tr[p].pos_mn = tr[p << 1 | 1].pos_mn;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> W >> H;
    auto add = [](int x, int y, int v) {
        int x1 = x - W, x2 = x;
        xs[++xn] = x1; xs[++xn] = x2;
        ev[++tot] = {y, x1, x2, v};
        ev[++tot] = {y + H + 1, x1, x2, -v};
    };
    for (int i = 1, x, y; i <= n; ++i) { cin >> x >> y; add(x, y, 1); }
    for (int i = 1, x, y; i <= m; ++i) { cin >> x >> y; add(x, y, -1); }

    // 离散化 x
    sort(xs + 1, xs + xn + 1);
    xn = unique(xs + 1, xs + xn + 1) - xs - 1;
    for (int i = 1; i <= tot; ++i) {
        ev[i].x1 = compress(ev[i].x1);
        ev[i].x2 = compress(ev[i].x2);
    }
    sort(ev + 1, ev + tot + 1);

    build(1, 1, xn);
    int ans = 0, ansx = 0, ansy = 0;
    for (int i = 1; i <= tot; ) {
        int y = ev[i].y;
        int j = i;
        while (j <= tot && ev[j].y == y) ++j;
        for (int k = i; k < j; ++k) update(1, 1, xn, ev[k].x1, ev[k].x2 - 1, ev[k].val);
        if (j <= tot) {
            int ny = ev[j].y;
            if (abs(tr[1].mx) > ans) {
                ans = abs(tr[1].mx);
                ansx = xs[tr[1].pos_mx];
                ansy = y;
            }
            if (abs(tr[1].mn) > ans) {
                ans = abs(tr[1].mn);
                ansx = xs[tr[1].pos_mn];
                ansy = y;
            }
        }
        i = j;
    }
    cout << ans << '\n' << ansx << ' ' << ansy << '\n';
    return 0;
}
```
- **代码解读概要**：  
  离散化后，把所有点拆成两条水平扫描线；按y排序后双指针扫描，用线段树实时维护x轴区间和的最大/最小值，同时记录坐标即可输出方案。

---

## 5. 算法可视化：像素动画演示

> 主题：**《像素探险家：扫描线大冒险》**  
> 用8位像素风格展示“沿y轴扫描线+线段树”全过程。

- **场景初始化**：  
  一个FC风格的坐标平面，红/蓝像素点闪烁出现。右侧显示“扫描线”像素条，随时间向上移动。

- **关键帧动画**：
  1. **离散化**：坐标轴瞬间“压缩”，长条变成短条，伴随“叮”声。
  2. **事件生成**：每个点生成两条水平“事件条”，红条+1，蓝条-1，像素化滑入队列。
  3. **扫描线上升**：像素条每上升一格，触发“区间加”动画：线段树节点高亮变色，懒标记像素方块向下传递。
  4. **极值查询**：线段树根部节点闪金光，显示当前最大/最小差值，并同步在坐标平面用绿色矩形标记“最佳位置”。
  5. **胜利音效**：当扫描线到达顶部，播放8位胜利音，绿色矩形定格，输出答案。

- **交互面板**：  
  - 速度滑块：8位像素风格的数字0-9调整扫描速度。  
  - 单步按钮：每按一次，扫描线上升一行并更新线段树。  
  - “AI自动演示”：自动完成整个流程，适合“围观”学习。

- **设计思路**：  
  像素化降低视觉复杂度；音效强化关键操作记忆；游戏化关卡（每移动一行=1关）提升成就感。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
“扫描线+区间数据结构”可解决：
- **矩形面积/周长并**：把矩形拆成上下边，统计覆盖长度。
- **最大空矩形**：扫描线维护最大无覆盖区间。
- **动态维护区间最值**：如“窗口的星星”。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P1502 窗口的星星 | 与本题思路100%一致，练手扫描线模板。 |
| P5490 矩形面积并 | 扫描线+线段树求面积并，加深区间合并理解。 |
| P1908 逆序对 | 离散化+树状数组/线段树，巩固离散化技巧。 |

---

## 7. 学习心得与经验分享

- **ImposterAnYu**：“数组别开小了，离散化后值域是 `3(n+m)`。”  
  → 提醒：离散化后新值域=原坐标+左右偏移，需预留空间。

- **Zskioaert1106**：“初学扫描线时调不对，多画事件顺序图。”  
  → 经验：把事件按y排序后，手动模拟前10条事件线，能快速定位bug。

---

<conclusion>
恭喜完成「红蓝」探险！我们学会了把二维几何问题降维成一维区间问题，并用扫描线+线段树优雅解决。  
记住：遇到坐标范围巨大时，先想**离散化**；遇到“覆盖/差值最值”时，先想**事件+区间数据结构**。  
下次我们再一起挑战新的几何谜题！💪

---
处理用时：105.96秒
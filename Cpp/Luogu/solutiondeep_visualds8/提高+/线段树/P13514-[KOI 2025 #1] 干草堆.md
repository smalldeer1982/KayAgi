# 题目信息

# [KOI 2025 #1] 干草堆

## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。

## 题目描述

一支带有力量 $P$ 的箭从数轴上的位置 0 向右方发射。在每个整数位置 $i$ ($1 \le i \le N$)，最多可以设置一个防御力为 $D_i$ 的干草堆。

当箭撞到干草堆时，如果箭的力量小于或等于该干草堆的防御力，箭会立即停止。反之，如果箭的力量大于防御力，箭的力量会减去 $D_i$，然后穿过干草堆继续飞行。

对于两个整数 $X, P$，我们将 $f(X, P)$ 的值定义为“为了使力量为 $P$ 的箭在位置 $X$ 或其左侧停止所需要安装的**干草堆的最小数量**”。如果无论如何安装都无法使箭停止，则定义 $f(X, P) = -1$。

请编写一个程序，对于 $Q$ 个整数对 $(X_j, P_j)$ ($1 \le j \le Q$)，分别求出 $f(X_j, P_j)$ 的值。

## 说明/提示

### 限制条件

*   给定的所有数都是整数。
*   $1 \le N, Q \le 300,000$
*   对于每个 $1 \le i \le N$ 的 $i$，都有 $1 \le D_i \le 10^9$。
*   对于每个 $1 \le j \le Q$ 的 $j$，都有 $1 \le X_j \le N$。
*   对于每个 $1 \le j \le Q$ 的 $j$，都有 $1 \le P_j \le 10^9$。

### 子任务

1.  (6 分) $N, Q \le 18$。
2.  (16 分) $N, Q \le 5000$。
3.  (18 分) 对于所有 $1 \le i \le N$ 的 $i$，$D_i \le 300$。
4.  (32 分) 对于所有 $1 \le i < N$ 的 $i$，$D_i \le D_{i+1}$。
5.  (28 分) $N=Q$，且对于所有 $1 \le j \le Q$ 的 $j$，$X_j=j$，且 $P_1 = P_2 = \cdots = P_Q$。
6.  (16 分) 对于所有 $1 \le j \le Q$ 的 $j$，$X_j = N$。
7.  (12 分) 对于所有 $1 \le i < j \le N$ 的 $i, j$，$D_i \ne D_j$。
8.  (22 分) 无附加限制条件。

## 样例 #1

### 输入

```
5 6
2 5 6 1 12
1 1
5 14
2 8
3 7
4 14
5 1```

### 输出

```
1
2
-1
2
4
1```

## 样例 #2

### 输入

```
5 5
3 6 1 1 10
1 10
2 10
3 10
4 10
5 10```

### 输出

```
-1
-1
3
3
1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[KOI 2025 #1] 干草堆 深入学习指南 💡

> 欢迎来到今天的“像素箭道”！一支带着力量P的箭正从0点呼啸而来，我们要在1~N的每个整数位置上，用最少的干草堆让它停下。听起来简单？但N和Q都高达30万，这就是一场真正的思维与速度的对决！今天，我将带你们从“暴力摆阵”一步步升级到“树状数组神阵”，用像素动画看清每一次“防御值”的跳动。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“在位置X之前，用**最少**的干草堆使箭的力量P ≤ 0”。核心在于**贪心+离线+数据结构**的巧妙结合。

✨ **核心算法标签**：贪心、离线处理、树状数组/线段树、二分、离散化。

🗣️ **初步分析**：  
- **暴力思路**：枚举每个询问区间，排序后从大到小累加，直到≥P。但O(QN log N)显然无法通过30万数据。  
- **贪心洞察**：要“最少”，必须优先选防御力最大的干草堆。  
- **离线优化**：将询问按X升序排序，从左到右扫描，逐步加入干草堆，维护一个“当前可选干草堆”的集合。  
- **数据结构加速**：需要快速查询“前k大元素之和≥P”的最小k。树状数组/线段树+二分是最佳拍档！

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：“最小数量”+“防御力之和≥P” → **贪心**选最大防御力。
2. **线索2 (问题约束)**：所有询问提前给出 → **离线处理**，按X排序。
3. **线索3 (数据规模)**：N,Q=3e5 → 需要**O(N log N + Q log N)**的算法，树状数组/线段树是标配！

### 🧠 思维链构建：从线索到策略
> 1. **贪心**：优先选大防御力，确保最少数量。
> 2. **离线**：按X排序，从左到右扫描，逐步加入干草堆。
> 3. **数据结构**：用树状数组维护防御力值域，支持“前k大之和”查询。离散化防御力值，避免值域过大。
> 4. **二分**：在树状数组上二分查找最小k，使得前k大之和≥P。

---

## 2. 精选优质题解参考

### 🏆 题解一：chen_zhe（赞：4）
- **亮点**：系统拆解8个子任务，从暴力到树状数组+离散化+二分，思路清晰。
- **核心技巧**：  
  - **离散化**：将防御力值映射到1~N的紧凑区间。  
  - **树状数组双维护**：一个维护“防御力之和”，一个维护“干草堆数量”。  
  - **二分优化**：在树状数组上二分查找最小k，避免线段树的log²N复杂度。

### 🏆 题解二：lilong（赞：0）
- **亮点**：代码简洁，直接展示树状数组+离散化的完整实现。
- **核心技巧**：  
  - **离线处理**：询问按X排序，扫描时动态加入干草堆。  
  - **树状数组二分**：利用树状数组的倍增特性，O(log N)查询最小k。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
1. **关键点1：离散化防御力值**  
   - **分析**：防御力值高达1e9，直接开数组会爆内存。将值排序后映射到1~N的连续区间。  
   - 💡 **学习笔记**：离散化是处理大值域的经典技巧，配合树状数组/线段树使用。

2. **关键点2：树状数组双维护**  
   - **分析**：  
     - 树状数组1（sum）：维护离散化后防御力值的**前缀和**。  
     - 树状数组2（cnt）：维护离散化后防御力值的**前缀数量**。  
   - **查询逻辑**：二分查找最小k，使得前k大防御力之和≥P。  
   - 💡 **学习笔记**：树状数组支持“前缀和”和“单点更新”，是离线问题的利器。

3. **关键点3：离线处理询问**  
   - **分析**：将询问按X升序排序，从左到右扫描数组，逐步将D[i]加入树状数组。  
   - 💡 **学习笔记**：离线处理可避免重复计算，将O(QN)优化到O(N log N + Q log N)。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力枚举** | 对每个询问区间排序后贪心累加 | 思路直观 | O(QN log N)超时 | 子任务1/2（N≤5000） |
| **平衡树（FHQtreap）** | 动态维护有序集合，支持插入和查询 | 通用性强 | 常数较大，代码复杂 | 通用，但非最优 |
| **树状数组+离散化** | 离散化值域，树状数组维护前k大之和 | 最优复杂度O(N log N + Q log N) | 需离散化 | 子任务8（无限制） |

---

## 4. C++核心代码实现赏析

### 📌 本题通用核心C++实现参考
**说明**：综合题解精华，展示树状数组+离散化的完整实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MAXN = 3e5 + 10;

int n, q, a[MAXN], ans[MAXN];
vector<pair<ll, int>> queries[MAXN];

// 树状数组：sum维护防御力之和，cnt维护干草堆数量
ll sum[MAXN];
int cnt[MAXN];

void update(int x, ll val) {
    while (x <= n) {
        sum[x] += val;
        cnt[x]++;
        x += x & -x;
    }
}

// 查询前k大之和≥P的最小k
int query(ll P) {
    int k = 0;
    ll total = 0;
    for (int i = 20; i >= 0; i--) {
        int next = k + (1 << i);
        if (next <= n && total + sum[next] < P) {
            total += sum[next];
            k = next;
        }
    }
    return (k < n) ? cnt[k + 1] : -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> a[i];

    // 离散化
    vector<int> vals(a + 1, a + n + 1);
    sort(vals.begin(), vals.end());
    vals.erase(unique(vals.begin(), vals.end()), vals.end());
    for (int i = 1; i <= n; i++) {
        a[i] = lower_bound(vals.begin(), vals.end(), a[i]) - vals.begin() + 1;
    }

    // 离线询问
    for (int i = 1; i <= q; i++) {
        int x, p; cin >> x >> p;
        queries[x].emplace_back(p, i);
    }

    // 扫描线
    for (int i = 1; i <= n; i++) {
        update(n - a[i] + 1, vals[a[i] - 1]); // 从大到小排序
        for (auto [P, id] : queries[i]) {
            ans[id] = query(P);
        }
    }

    for (int i = 1; i <= q; i++) {
        cout << ans[i] << '\n';
    }
    return 0;
}
```

### 📌 题解片段赏析
**lilong的离散化+树状数组**：  
- **亮点**：代码简洁，直接展示离散化后的树状数组操作。  
- **核心片段**：
  ```cpp
  sort(b+1, b+n+1, cmp);
  for(int i=1;i<=n;i++) temp[a[i].id] = i; // 离散化映射
  ```
- **学习笔记**：离散化后，树状数组的索引从1开始，避免0的问题。

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：**“像素箭道防御战”**
- **场景**：8位像素风格的数轴，箭从左侧飞来，干草堆用像素方块表示。
- **交互**：  
  1. **干草堆加入**：每扫描到一个位置i，对应防御力的像素块闪烁并滑入“防御阵列”。  
  2. **查询演示**：询问(X,P)时，高亮前X个位置的干草堆，从大到小累加防御力，直到≥P，累加次数用像素数字跳动显示。  
  3. **音效**：  
     - 干草堆加入：“叮”声。  
     - 查询成功：“胜利”音效。  
     - 查询失败：“失败”音效。

---

## 6. 拓展练习与相似问题思考

### 🌱 通用技巧迁移
- **贪心+离线+树状数组**：适用于“区间前k大/小”问题，如：
  1. **区间前k小之和≥S**：离散化+树状数组。
  2. **动态维护中位数**：平衡树或树状数组二分。
  3. **滑动窗口第k大**：双指针+树状数组。

### 🎯 洛谷推荐
1. **P3374** - 树状数组模板  
   *🗣️ 推荐理由*：巩固树状数组的单点更新和前缀查询。  
2. **P1908** - 逆序对  
   *🗣️ 推荐理由*：离散化+树状数组的经典应用。  
3. **P3368** - 线段树模板2  
   *🗣️ 推荐理由*：对比树状数组与线段树的实现差异。

---

## 7. 学习心得与经验分享
> **来自chen_zhe的调试心得**：“离散化时务必注意相同值的映射，避免索引冲突。树状数组的二分需从大到小遍历，确保贪心正确性。”  
> **洛语云笺点评**：离散化是“降维打击”大值域的利器，但细节决定成败！

---

### 🏁 结语
今天的“像素箭道”之旅到此结束！记住：贪心是方向，离线是策略，树状数组是武器。下次遇到“前k大”问题，别忘了这套组合拳！💪

---
处理用时：63.09秒
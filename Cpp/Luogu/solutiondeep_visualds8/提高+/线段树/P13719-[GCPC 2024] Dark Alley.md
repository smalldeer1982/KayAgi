# 题目信息

# [GCPC 2024] Dark Alley

## 题目描述

在一个寒冷而有雾的夜晚，你走在一条阴暗的小巷里。
每隔几米应该有一盏路灯，但似乎没有一盏能亮起，在这个夜晚，连月亮都无法照亮你的路。
孤身一人在黑暗中，你不禁思考：
“即使某处有一盏亮着的灯，它能照亮我多少路呢？”
现在，回到家中，你想要计算这个问题。

![](https://cdn.pixabay.com/photo/2019/06/13/05/24/the-park-at-night-4270765_1280.jpg)

:::align{center}
雾蒙蒙的小巷。[照片来自 Henryk Niestrój](https://pixabay.com/de/photos/park-in-der-nacht-dunkle-stra%C3%9Fe-4270765/)
:::

这条小巷可以被建模为一条长度为 $n$ 米的直线。
雾的密度是均匀的，每经过 $1$ 米，雾会使灯光衰减 $1-p$ 倍。
某一点的亮度等于所有灯光到达该点的光强之和。
你需要在放置一些灯之后，计算某些点的亮度。

## 说明/提示

在第一个样例中，放置灯后小巷各点的亮度如下表所示：

| $3$ | $4$ | $3$ | $2.25$ | $1.6875$ |
|:-:|:-:|:-:|:-:|:-:|

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
5 6 0.25
+ 4 2
? 1
? 2
? 3
? 4
? 5```

### 输出

```
3
4
3
250000004
187500003```

## 样例 #2

### 输入

```
5 7 0.33
+ 9 1
? 5
+ 4 3
? 2
? 5 
- 9 1
? 2```

### 输出

```
312342734
470000012
341542736
760000008```

# AI分析结果

# 💡 洛语云笺的C++算法解析：Dark Alley 深入学习指南 💡

> 今天我们来一起分析 **Dark Alley** 这道 C++ 编程题。  
> 它表面上是一道“灯光亮度”计算题，骨子里却是一道 **线段树维护指数衰减求和** 的“信号处理”问题。  
> 准备好，和我一起化身“算法侦探”，在雾夜小巷里点亮思路的灯！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在一条直线上动态地 **点灯 / 熄灯**，并在任意时刻快速回答：  
“**第 x 米处的总亮度是多少？**”  
亮度定义为 **所有灯光** 经过 **指数衰减** 后的叠加。

✨ **核心算法标签**  
- 线段树（区间加等比数列 + 单点查询）  
- 数学推导 / 系数分离  
- 模逆元 / 快速幂  

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：衰减公式** | `亮度 = Σ b_i · p^|x-i|`，指数项只与距离有关 → 可以把绝对值拆掉，拆成左右两段。 |
| **线索2：需要动态修改 & 查询** | 每次操作（点灯/熄灯）会影响 **一段区间** 的亮度 → **线段树** 擅长区间修改、单点查询。 |
| **线索3：公比固定** | 公比只有 `p` 和 `1/p` 两种 → 可以把等比数列的加和操作转化为 **区间加常数**，再乘上系数即可。 |

---

### 🧠 思维链构建：从线索到策略
> 1. 看到指数衰减，我想到了 **把系数拆出来**：把 `p^|x-i|` 拆成 `p^x · p^{-i}` 和 `p^{-x} · p^i`。  
> 2. 于是原式变成 `p^x · Σ_{i≤x} b_i p^{-i} + p^{-x} · Σ_{i>x} b_i p^i`。  
> 3. **Σ 的部分** 只与 `i` 有关，与 `x` 无关 → 可以分别用 **两棵线段树** 维护。  
> 4. 一次点灯操作相当于：  
>    - 在左树区间 `[x,n]` 上 **加** `b·p^{-x}`；  
>    - 在右树区间 `[1,x-1]` 上 **加** `b·p^x`。  
> 5. 查询时，把两棵树的结果乘上对应系数即可。  
> **结论**：这就是“线段树维护系数分离”的套路！

---

## 2. 精选优质题解参考

### 题解一：Crazyouth  
- **亮点**：  
  - 直接给出数学推导，简洁清晰。  
  - 使用 **两棵线段树** 分别维护 `Σ b_i p^{-i}` 与 `Σ b_i p^i`，查询时组合。  
  - 代码结构标准，变量命名易懂。

### 题解二：cosf  
- **亮点**：  
  - 把“等比数列区间加”再向前一步：  
    令 `a_i = b_i · p^i`，则区间加等比数列 ⇨ 区间加常数。  
  - 采用 **区间加 + 单点查询** 的线段树模板，实现更短。  
  - 预处理 `p^i` 及其逆元数组，查询时直接乘回即可。

> 两份题解殊途同归，都体现了“**把复杂衰减转化为可维护系数**”的核心思想，值得反复品味！

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **系数分离** | `p^|x-i| = p^{x-i}` (i≤x) 与 `p^{i-x}` (i>x) | 把绝对值拆掉，才能把 **与 x 相关的项** 提到求和符号外。 |
| **线段树设计** | 两棵树分别维护 `Σ b_i·p^{-i}` 与 `Σ b_i·p^i` | 区间加常数即可；查询时乘 `p^x` 或 `p^{-x}`。 |
| **模逆元处理** | 实数 `p` 转成模意义分数 | `p_mod = round(pp*1e6) * inv(1e6) % mod`；`inv_p = qpow(p, mod-2)`。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 O(nq)** | 每次查询扫全数组 | 思路直观 | 必超时 | n,q ≤ 2×10³ |
| **线段树系数分离** | 两棵线段树维护左右和 | O(q log n) 通过 | 需数学推导 | **正解** |
| **FFT/NTT 卷积** | 把衰减看作卷积 | 理论优雅 | 常数大、难写 | 离线批量查询 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合两份题解，给出 **cosf 式区间加线段树** 的精简版本，更易阅读。

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int64 MOD = 1'000'000'007;

int64 pow_mod(int64 b, int64 p, int64 m) {
    int64 r = 1;
    while (p) {
        if (p & 1) r = r * b % m;
        b = b * b % m;
        p >>= 1;
    }
    return r;
}

const int MAXN = 2e5 + 10;

int n, q;
int64 p, inv_p;   // p = 1 - 原输入 p
int64 pow_p[MAXN], pow_inv_p[MAXN];

struct SegTree {
    int64 tag[MAXN << 2];

    void add(int p, int l, int r, int ql, int qr, int64 v) {
        if (ql > qr) return;
        if (ql <= l && r <= qr) {
            (tag[p] += v) %= MOD;
            return;
        }
        int mid = (l + r) >> 1;
        add(p << 1, l, mid, ql, qr, v);
        add(p << 1 | 1, mid + 1, r, ql, qr, v);
    }

    int64 query(int p, int l, int r, int pos) {
        if (l == r) return tag[p] % MOD;
        int mid = (l + r) >> 1;
        int64 res = tag[p];
        if (pos <= mid) res += query(p << 1, l, mid, pos);
        else res += query(p << 1 | 1, mid + 1, r, pos);
        return res % MOD;
    }
} leftTree, rightTree;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cout.tie(nullptr);

    double pp;
    cin >> n >> q >> pp;
    pp = 1.0 - pp;
    p = int64(round(pp * 1'000'000)) * pow_mod(1'000'000, MOD - 2, MOD) % MOD;
    inv_p = pow_mod(p, MOD - 2, MOD);

    // 预处理 p^i
    pow_p[0] = pow_inv_p[0] = 1;
    for (int i = 1; i <= n; ++i) {
        pow_p[i] = pow_p[i - 1] * p % MOD;
        pow_inv_p[i] = pow_inv_p[i - 1] * inv_p % MOD;
    }

    while (q--) {
        char op;
        int b, x;
        cin >> op;
        if (op == '+') {
            cin >> b >> x;
            int64 coef1 = 1LL * b * pow_inv_p[x] % MOD;   // 左树区间加
            int64 coef2 = 1LL * b * pow_p[x] % MOD;       // 右树区间加
            leftTree.add(1, 1, n, x, n, coef1);
            if (x + 1 <= n) rightTree.add(1, 1, n, x + 1, n, coef2);
        } else if (op == '-') {
            cin >> b >> x;
            int64 coef1 = (MOD - 1LL * b * pow_inv_p[x] % MOD) % MOD;
            int64 coef2 = (MOD - 1LL * b * pow_p[x] % MOD) % MOD;
            leftTree.add(1, 1, n, x, n, coef1);
            if (x + 1 <= n) rightTree.add(1, 1, n, x + 1, n, coef2);
        } else {
            cin >> x;
            int64 leftVal  = leftTree.query(1, 1, n, x) * pow_p[x] % MOD;
            int64 rightVal = rightTree.query(1, 1, n, x) * pow_inv_p[x] % MOD;
            cout << (leftVal + rightVal) % MOD << '\n';
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 我们把 **线段树区间加** 的过程做成一个 **8 位像素小游戏**！

- **主题**：  
  “像素电工”在一条 32×1 的巷子里布灯，每盏灯像“像素灯泡”亮起，灯光以 **像素波浪** 向左右扩散。

- **可视化元素**：
  1. **巷子画布**：32 格长条，每格亮度用 **0-15 级灰度像素方块** 表示。  
  2. **两棵线段树**：屏幕上方左右各一棵 **8 层高的像素树**，区间更新时对应节点闪黄光并播放“叮”声。  
  3. **操作提示**：  
     - 点击“+ b x”按钮 → 灯泡在 x 格点亮，随后黄色波浪向两边衰减。  
     - 点击“? x”按钮 → 镜头拉近到 x 格，显示两棵树贡献值相加，最后像素数字弹出亮度值。  
  4. **控制面板**：  
     - 步进 / 自动播放 / 调速滑块。  
     - 音效开关（8 位芯片风格）。  
  5. **关卡化**：每完成 8 次操作触发“过关”烟花动画。

- **技术提示**：  
  用 Canvas 2D 绘制像素方块；线段树节点用递归 `drawNode(l,r,level)` 绘制；音效通过 Web Audio API 生成 8 位方波。

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**：  
  1. **信号卷积**：任何形如 `Σ a_i * f(|x-i|)` 的衰减叠加，都可以拆左右区间维护。  
  2. **二维灯光**：把直线换成网格，用二维线段树 / 四叉树。  
  3. **动态衰减系数**：如果 `p` 随时间变化 → 需要 **动态系数线段树** 或 **多项式乘法**。

- **洛谷推荐**：
  1. P3372 【模板】线段树 1  
     🗣️ 巩固区间加、单点查询基础。  
  2. P4513 小白逛公园  
     🗣️ 练习“区间加等差数列”的线段树变形。  
  3. P4198 楼房重建  
     🗣️ 把衰减换成“可见性”问题，继续锻炼区间信息维护。  

---

## 7. 学习心得与经验分享

> 两位作者都提到了 **模逆元精度** 的坑：  
> “把 `1-p` 转成模意义时，不要直接 `int(1e6*(1-p))`，而要 `round(...)` 再乘逆元，否则 0.33 会丢精度。”  
> **点评**：在涉及实数转模数的题目中，**四舍五入 + 乘逆元** 是避免精度误差的标准做法，值得牢记！

---

### 🎓 结语
今天我们学会了如何把“指数衰减叠加”拆解为 **两棵线段树** 的优雅维护。  
记住：**数学变形 + 数据结构** 的组合，往往是解决复杂动态问题的钥匙。  
下次遇到“雾夜灯光”，别忘了点亮你的线段树！

---
处理用时：78.02秒
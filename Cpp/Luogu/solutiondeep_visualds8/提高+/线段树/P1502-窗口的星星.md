# 题目信息

# 窗口的星星

## 题目背景

小卡买到了一套新房子，他十分的高兴，在房间里转来转去。


## 题目描述

晚上，小卡从阳台望出去，“哇~~~~好多星星啊”，但他还没给其他房间设一个窗户。   

天真的小卡总是希望能够在晚上能看到最多最亮的星星，但是窗子的大小是固定的，边也必须和地面平行。  

这时小卡使用了超能力（透视术）知道了墙后面每个星星的位置和亮度，但是小卡发动超能力后就很疲劳，只好拜托你告诉他最多能够有总和多亮的星星能出现在窗口上。


## 说明/提示

为了便于理解，输入样例中每组数据之间添加了空行，实际测试数据中并无空行。

小卡买的窗户框是金属做的，所以在边框上的不算在内。

### 数据范围

对于 $100\%$ 的数据：$1\le T \le 10$，$1\le n \le 10^4$，$1\le W,H \le 10^6$，$0\le l_i\le 1000$，$0\le x_i,y_i < 2^{31}$。

## 样例 #1

### 输入

```
2

3 5 4
1 2 3
2 3 2
6 3 1

3 5 4
1 2 3
2 3 2
5 3 1```

### 输出

```
5
6
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：窗口的星星 深入学习指南 💡

> 今天我们要一起征服「窗口的星星」。这道题看似是几何题，其实暗藏了一条**扫描线+线段树**的“黄金路径”。跟着洛语云笺，我们一步步把漫天星光装进小小的窗框！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> 在**固定尺寸 W×H** 的矩形窗口中，**边框不算**，选出一块位置，使得窗口内星星的**亮度总和最大**。

### ✨ 核心算法标签
- 扫描线（Sweep Line）
- 离散化（Coordinate Compression）
- 线段树区间加 / 区间最大值（Segment Tree with Lazy Tag）

### 🗣️ 思路演进
| 思路 | 时间复杂度 | 能否 AC | 核心难点 |
| --- | --- | --- | --- |
| 暴力枚举所有窗口 | O(T·n·W·H) | ❌ 爆炸 | 坐标范围 2³¹ |
| 离散化+二维前缀和 | O(T·n²) | ❌ n=1e4 时 1e8 勉强 | 二维前缀和内存 1e8 |
| 扫描线+线段树 | **O(T·n log n)** | ✅ 最优 | 把“二维”拍成“一维” |

> 扫描线就像一把**激光尺**，从左到右扫过平面，把二维问题压缩成一维“区间加+区间 max”，线段树则在**纵坐标**上高效维护。

---

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1（目标）**：求**最大子矩形权值和** → 经典扫描线模型。
2. **线索2（约束）**：窗口尺寸固定，**坐标巨大** → 必须离散化。
3. **线索3（边界）**：边框不算 → 把窗口长宽各减 1，即 (W-1, H-1)。

---

### 🧠 思维链构建：从线索到策略
> “侦探工作完成，现在拼图：
> 1. 线索1告诉我：二维平面求极值 → **扫描线**。
> 2. 线索2提醒我：坐标 2³¹ → **离散化**。
> 3. 线索3暗示：把窗口缩小 1 单位，避免边界星星。
> 结论：用**扫描线+离散化+区间线段树**，复杂度 O(n log n)，稳过！”

---

## 2. 精选优质题解参考

> 洛谷共收录 10 份题解，洛语云笺精选以下 3 份 **≥4星** 代表，展示不同实现风格。

### 题解一：Diaоsi（赞 139）【推荐指数 ★★★★★】
- **亮点**：
  - 最早、最简洁的扫描线模板，**一行公式**把星星变成矩形。
  - 用 `Segment` 结构体封装扫描线，变量名直观：`l, r, h, val`。
  - 排序时 `h` 相同则 `val` 降序，**巧妙处理重合边界**。
- **关键技巧**：  
  把每颗星星拆成两条竖线：入边 `+l`，出边 `-l`，线段树维护区间和的最大值。

### 题解二：7KByte（赞 24）【推荐指数 ★★★★☆】
- **亮点**：
  - **双指针思想**：用 `head` 指针维护当前窗口左边界，**O(n)** 次区间修改。
  - 代码结构清晰：`init()` 离散化，`work()` 双指针+线段树。
- **关键技巧**：  
  把问题转化为“**滑动窗口** + 区间加”，降低扫描线事件数。

### 题解三：Mr_Leceue（赞 7）【推荐指数 ★★★☆☆】
- **亮点**：
  - **动态开点线段树**，无需离散化，直接处理 2³¹ 坐标。
  - `le, ri` 记录左右子节点编号，避免预先开 4×N 数组。
- **关键技巧**：  
  动态开点内存 ≈ 2·n log n，适合坐标范围极大但有效点少的题目。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 & 实现要点 | 学习笔记 |
| --- | --- | --- |
| **1. 问题转化** | 把每颗星星 (x,y) 变成“**影响矩形**”：<br>左下 (x, y)，右上 (x+W-1, y+H-1)。<br>窗口落在矩形内即选中该星星。 | 把“选窗口”变成“选点”，二维→一维。 |
| **2. 离散化 y 坐标** | 收集所有 y 与 y+H-1，排序去重得到 `ys[]`。 | 离散化后区间长度 ≤ 2n。 |
| **3. 扫描线事件** | 每颗星星拆成两条竖线：<br>`(x, y, y+H-1, +l)` 入边<br>`(x+W-1, y, y+H-1, -l)` 出边 | 按 x 升序排序，x 相同则先加后减，避免漏算。 |
| **4. 线段树维护** | 维护纵坐标区间 `[l,r]` 的**当前亮度总和**，支持：<br>• 区间加 `+/-l`<br>• 区间 max | 懒标记下传模板要熟练。 |

### ✨ 解题技巧总结
- **扫描线通用套路**：  
  1. 降维：把二维几何问题拍成一维区间操作。  
  2. 事件：拆边（入/出），排序。  
  3. 数据结构：线段树/树状数组维护区间信息。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- | --- |
| 暴力枚举 | 枚举左上角 (x,y) | 思路直观 | O(nWH) 爆炸 | W,H≤100 的暴力分 |
| 二维前缀和 | 离散化后二维前缀和 | 代码短 | O(n²) 内存 1e8 | n≤2000 |
| **扫描线+线段树** | 把 y 离散，x 扫描 | **O(n log n)** | 需写线段树 | **n≤1e4 正解** |
| 动态开点 | 不离散化，直接坐标 | 省离散化代码 | 动态开点调试难 | 坐标极稀疏 |

---

## 4. C++核心代码实现赏析

### 通用核心实现（整合 Diaоsi + 7KByte）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e4 + 10;

struct Line {
    ll x, y1, y2, val;
    bool operator<(const Line& b) const {
        return x == b.x ? val > b.val : x < b.x;
    }
};

ll ys[N << 1];
struct Node {
    ll l, r, mx, add;
} tr[N << 3];

void build(ll p, ll l, ll r) {
    tr[p] = {l, r, 0, 0};
    if (l == r) return;
    ll mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
}

void push_down(ll p) {
    if (tr[p].add) {
        ll &v = tr[p].add;
        tr[p << 1].mx += v; tr[p << 1].add += v;
        tr[p << 1 | 1].mx += v; tr[p << 1 | 1].add += v;
        v = 0;
    }
}

void update(ll p, ll l, ll r, ll val) {
    if (tr[p].l >= l && tr[p].r <= r) {
        tr[p].mx += val; tr[p].add += val;
        return;
    }
    push_down(p);
    ll mid = (tr[p].l + tr[p].r) >> 1;
    if (l <= mid) update(p << 1, l, r, val);
    if (r > mid) update(p << 1 | 1, l, r, val);
    tr[p].mx = max(tr[p << 1].mx, tr[p << 1 | 1].mx);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        ll n, W, H; cin >> n >> W >> H;
        --W; --H;                           // 边框不算
        vector<Line> lines;
        ll cnt = 0;
        for (ll i = 0, x, y, l; i < n; ++i) {
            cin >> x >> y >> l;
            lines.push_back({x, y, y + H, l});
            lines.push_back({x + W + 1, y, y + H, -l});
            ys[cnt++] = y;
            ys[cnt++] = y + H;
        }
        sort(ys, ys + cnt);
        cnt = unique(ys, ys + cnt) - ys;
        sort(lines.begin(), lines.end());

        build(1, 1, cnt - 1);
        ll ans = 0;
        for (auto& ln : lines) {
            ll l = lower_bound(ys, ys + cnt, ln.y1) - ys + 1;
            ll r = lower_bound(ys, ys + cnt, ln.y2) - ys;
            update(1, l, r, ln.val);
            ans = max(ans, tr[1].mx);
        }
        cout << ans << '\n';
    }
    return 0;
}
```
- **代码解读概要**：  
  1. 读入星星 → 拆成入/出两条扫描线。  
  2. 离散化 y 坐标 → 线段树下标。  
  3. 从左到右扫描，线段树区间加 → 实时维护区间 max。  
  4. 每次更新后取全局 max 即为答案。

---

## 5. 算法可视化：像素动画演示

> 让我们用 8-bit 像素风，把扫描线过程变成一场“**激光扫星**”小游戏！

### 🎮 动画主题  
“激光尺从左滑到右，星星矩形不断亮灭，实时显示当前亮度总和最大值。”

### 🎨 设计要素
- **像素网格**：纵坐标离散后 1~2n 的像素条。
- **星星图标**：每颗星星对应矩形区域，用黄色方块闪烁。
- **激光线**：红色竖线从左到右移动，停在事件 x 坐标。
- **音效**：
  - 入边“叮”加亮，`+l`。
  - 出边“咻”减亮，`-l`。
  - 每次更新 max 播放“叮叮”上升音。

### 🕹️ 交互控制
- 步进 / 自动播放滑块。
- 右下角实时显示 `当前区间和`、`历史最大`。
- 失败彩蛋：若出现负数亮度，像素骷髅提示“边界算错啦！”

### 🧩 伪代码动画帧
```js
for each event in sortedEvents:
    laserX = event.x
    playSound(event.val > 0 ? "ding" : "whoosh")
    segmentTree.rangeAdd(y1, y2, event.val)
    maxLight = segmentTree.rangeMax()
    pixelBar.animate(maxLight)
```

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **扫描线+线段树**适用于：
  1. 矩形面积/周长并。
  2. 区间最大重叠数（如会议室安排）。
  3. 二维数点问题（统计矩形内点数）。

### 洛谷推荐
| 题号 | 推荐理由 |
| --- | --- |
| P1856 [USACO08OPEN] 二维差分 | 经典扫描线练手，区间加+区间和 |
| P1972 [SDOI2009] HH的项链 | 离线扫描线+树状数组 |
| P2163 [SHOI2007] 园丁的烦恼 | 扫描线+二维前缀和变形 |

---

## 7. 学习心得与经验分享

> **来自 Diaоsi 的小贴士**：  
> “排序时一定 `x` 相同先加后减，否则重合边界会漏算；我因为这个 WA 了一晚上！”

> **来自 7KByte 的提醒**：  
> “双指针+线段树写法事件数 2n，常数更小，但要注意 `head` 指针越界！”

---

<conclusion>
恭喜完成「窗口的星星」的深度之旅！今天我们学会了：
- 把几何问题抽象为扫描线事件。
- 离散化 + 线段树的经典套路。
- 如何优雅处理“边框不算”的边界细节。

下次再遇到二维平面最值问题，别忘了第一时间想到“**激光尺+像素条**”哦！🌟
</conclusion>

---
处理用时：80.73秒
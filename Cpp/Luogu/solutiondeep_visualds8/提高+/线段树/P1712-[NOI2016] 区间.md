# 题目信息

# [NOI2016] 区间

## 题目描述

在数轴上有 $n$ 个闭区间从 $1$ 至 $n$ 编号，第 $i$ 个闭区间为 $[l_i,r_i]$ 。

现在要从中选出 $m$ 个区间，使得这 $m$ 个区间共同包含至少一个位置。换句话说，就是使得存在一个 $x$ ，使得对于每一个被选中的区间 $[l_i,r_i]$，都有 $l_i \leq x \leq r_i$ 。

对于一个合法的选取方案，它的花费为被选中的最长区间长度减去被选中的最短区间长度。

区间 $[l_i,r_i]$ 的长度定义为 $(r_i-l_i)$ ，即等于它的右端点的值减去左端点的值。

求所有合法方案中最小的花费。如果不存在合法的方案，输出 $-1$。

## 说明/提示

#### 样例输入输出 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qoddox9k.png)
 
 如图，当 $n=6$，$m=3$ 时，花费最小的方案是选取 $[3,5],[3,4],[1,4]$ 这三个区间，它们共同包含了 $4$ 这个位置，所以是合法的。其中最长的区间是 $[1, 4]$，最短的区间是 $[3, 4]$，所以它的花费是 $(4 - 1) - (4 - 3) = 2$。

#### 数据规模与约定

本题共 20 个测试点，各测试点信息如下表。
| 测试点编号 | $ n= $ | $ m= $ | $ l_i,r_i $ |
|:-:|:-:|:-:|:-:|
| 1 | $ 20 $ | $ 9 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 2 | $ 20 $ | $ 10 $ | $ 0 \le l_i \le r_i \le 100 $ |
| 3 | $ 199 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 4 | $ 200 $ | $ 3 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 5 | $ 1000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 6 | $ 2000 $ | $ 2 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 7 | $ 199 $ | $ 60 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 8 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 9 | $ 200 $ | $ 50 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 10 | $ 1999 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 11 | $ 2000 $ | $ 400 $ | $ 0 \le l_i \le r_i \le 5000 $ |
| 12 | $ 2000 $ | $ 500 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 13 | $ 30000 $ | $ 2000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 14 | $ 40000 $ | $ 1000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 15 | $ 50000 $ | $ 15000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 16 | $ 100000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 100000 $ |
| 17 | $ 200000 $ | $ 20000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 18 | $ 300000 $ | $ 50000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 19 | $ 400000 $ | $ 90000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |
| 20 | $ 500000 $ | $ 200000 $ | $ 0 \le l_i \le r_i \le 10^9 $ |

对于全部的测试点，保证 $1 \leq m \leq n$，$1 \leq n \leq 5 \times 10^5$，$1 \leq m \leq 2 \times 10^5$，$0 \leq l_i \leq r_i \leq 10^9$。

## 样例 #1

### 输入

```
6 3
3 5
1 2
3 4
2 2
1 5
1 4```

### 输出

```
2```

# AI分析结果

# 💡 洛语云笺的C++算法解析：NOI2016《区间》深入学习指南 💡

> 今天我们来一起分析 NOI2016《区间》这道 C++ 编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在 5×10⁵ 条区间中，选出 **恰好 m 条**，使它们 **公共交集非空** 且 **“最长区间长度 − 最短区间长度”最小**。  
坐标高达 10⁹，暴力枚举显然无望。

✨ **核心算法标签**：  
离散化 + 双指针（尺取）+ 线段树（区间加 & 区间最大值）  
（属于“扫描线 + 数据结构”套路）

### 🗣️ 初步分析
> 1. 朴素思路：枚举公共点 x → 枚举覆盖 x 的区间 → 排序区间长度 → 取连续 m 个求差值。  
> 2. 复杂度 O(n² log n)，只能拿 20 分。  
> 3. 观察 **花费仅由最长与最短区间决定**，于是想到 **按长度排序** 后使用 **双指针** 维护一个“长度连续”的区间集合。  
> 4. 需要快速判断“当前区间集合的公共交集是否存在”，即 **是否存在某点被覆盖 ≥ m 次**。  
> 5. 离散化坐标后用线段树维护 **区间加 1 / −1** 与 **全局最大值**，即可在 O(log n) 内完成一次插入/删除，整体 O(n log n)。

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 指向 |
|---|---|---|
| **1. 坐标 10⁹** | 直接开数组会爆内存 | **离散化** |
| **2. 目标：maxLen − minLen** | 想到让区间长度尽量“挨在一起” | **按长度排序** |
| **3. 公共交集非空** | 等价于存在某点被 ≥m 条区间覆盖 | **扫描线 + 区间覆盖次数** |
| **4. 动态插入/删除区间** | 尺取法需要频繁修改覆盖次数 | **线段树区间加** |

### 🧠 思维链构建：从线索到策略
> 1. 首先，**坐标 10⁹** 迫使我们离散化，否则任何数组都存不下。  
> 2. 接着，**maxLen − minLen** 提示我们：最优解一定来自“长度排序后的一段连续区间”。  
> 3. 于是问题变为：在排序后的区间序列中，找到最短的一段 [l, r]，使得这 (r−l+1) 条区间的公共交集非空。  
> 4. 公共交集非空 ⇔ 存在某点被覆盖 ≥ m 次，可用 **线段树** 维护。  
> 5. 使用 **双指针** 扫描即可，总复杂度 O(n log n)。

---

## 2. 精选优质题解参考

> 我从思路清晰度、代码规范性、算法有效性、启发性四个维度，筛选出以下 **≥4 星** 的优质题解：

### 题解一：上进的 z 君（赞 81）
- **亮点**：  
  清晰指出“离散化 + 尺取 + 线段树”的主线；线段树维护区间加和区间最大值，根节点即全局最大值；双指针写法简洁。
- **学习点**：  
  用 `tree[1]` 直接查询最大值，无需额外函数，代码短。

### 题解二：wanglichao1121（赞 47）
- **亮点**：  
  提到 **标记永久化** 技巧，避免 `pushdown`，常数更小；代码风格极短。
- **学习点**：  
  `add` 数组与 `ma` 数组分开，根节点答案即 `ma[1]`。

### 题解三：EternalEpic（赞 38）
- **亮点**：  
  分享 **调试坑点**：区间长度别+1、离散化写法、query 就是 `tmax[1]`。
- **学习点**：  
  错误示范与正确写法对比，极具参考价值。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 离散化** | 坐标 10⁹ → 1~2n；用 `sort + unique + lower_bound` 三行搞定 | 离散化模板务必熟练 |
| **2. 按长度排序** | 排序后，最优解一定是连续一段区间 | 把“选任意 m 个”转化为“选连续一段” |
| **3. 双指针扫描** | 右指针扩展区间（+1），左指针收缩区间（−1） | 尺取法精髓：单调移动 |
| **4. 线段树维护** | 区间加 1 / −1，查询全局最大值 | 根节点即答案，无需额外查询函数 |

### ✨ 解题技巧总结
- **问题转化**：把“公共交集”转化为“某点被覆盖 ≥ m 次”，再转化为区间加问题。  
- **数据结构**：线段树支持区间加 + 区间最值，完美契合需求。  
- **双指针**：排序后区间长度单调，指针单调移动，保证 O(n)。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力枚举 x** | 枚举公共点 x，收集覆盖 x 的区间，排序后取连续 m 个 | 思路直观 | O(n² log n) 超时 | 20 分 |
| **二分答案 + 线段树** | 二分“差值”，check 时滑动窗口 | 思路清晰 | 多一个 log | 80 分 |
| **尺取 + 线段树**（最优） | 排序后直接双指针，线段树维护覆盖次数 | O(n log n) | 需离散化 | 100 分 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点：暴力枚举公共点**  
>    枚举每个点 x，收集覆盖 x 的区间，排序后取连续 m 个，复杂度 O(n² log n)。  
> 2. **发现瓶颈：重复计算**  
>    每个 x 独立处理，区间被多次扫描。  
> 3. **优化钥匙：排序 + 双指针**  
>    按长度排序后，最优解一定是连续区间，用双指针扫描，区间加/删用线段树维护。  
> 4. **最终升华：离散化 + 线段树**  
>    坐标离散化后，线段树区间加 1/−1 维护覆盖次数，根节点即全局最大值，整体 O(n log n)。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10, INF = 2e9;
struct Seg { int l, r, len; } a[N];
int n, m, tmp[N * 2], tot;

bool cmp(const Seg& x, const Seg& y) { return x.len < y.len; }

// 离散化
void discrete() {
    sort(tmp + 1, tmp + tot + 1);
    tot = unique(tmp + 1, tmp + tot + 1) - (tmp + 1);
    for (int i = 1; i <= n; ++i) {
        a[i].l = lower_bound(tmp + 1, tmp + tot + 1, a[i].l) - tmp;
        a[i].r = lower_bound(tmp + 1, tmp + tot + 1, a[i].r) - tmp;
    }
}

// 线段树：区间加 + 区间最大值
int mx[N << 3], tag[N << 3];
void pushdown(int p) {
    if (!tag[p]) return;
    int ls = p << 1, rs = p << 1 | 1;
    mx[ls] += tag[p]; tag[ls] += tag[p];
    mx[rs] += tag[p]; tag[rs] += tag[p];
    tag[p] = 0;
}
void modify(int p, int l, int r, int ql, int qr, int v) {
    if (ql <= l && r <= qr) { mx[p] += v; tag[p] += v; return; }
    pushdown(p);
    int mid = (l + r) >> 1;
    if (ql <= mid) modify(p << 1, l, mid, ql, qr, v);
    if (qr > mid) modify(p << 1 | 1, mid + 1, r, ql, qr, v);
    mx[p] = max(mx[p << 1], mx[p << 1 | 1]);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i].l >> a[i].r;
        a[i].len = a[i].r - a[i].l;
        tmp[++tot] = a[i].l;
        tmp[++tot] = a[i].r;
    }
    discrete();
    sort(a + 1, a + n + 1, cmp);

    int ans = INF;
    for (int l = 1, r = 0; l <= n; ++l) {
        while (r < n && mx[1] < m) {
            ++r;
            modify(1, 1, tot, a[r].l, a[r].r, 1);
        }
        if (mx[1] < m) break;
        ans = min(ans, a[r].len - a[l].len);
        modify(1, 1, tot, a[l].l, a[l].r, -1);
    }
    cout << (ans == INF ? -1 : ans) << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 为了更直观地理解“尺取 + 线段树”是如何工作的，我设计了一个 **8-bit 像素风格** 的可交互动画。

### 动画主题  
**“像素区间探险”**  
- 像素化的数轴上，区间用彩色方块表示。  
- 玩家控制 **双指针**（左右两把像素尺子），实时看到区间插入/删除的动画。  

### 核心演示内容  
1. **离散化**：坐标被压缩成像素格子，格子编号闪烁显示映射关系。  
2. **排序**：区间按长度从小到大排成一行，长度数字用像素字体显示。  
3. **双指针扫描**：  
   - 右指针（蓝色光标）向右移动，区间方块“掉落”到数轴，对应线段树区间加 1。  
   - 当数轴上某格子的覆盖次数 ≥ m，格子变成金色并播放“叮”音效。  
   - 左指针（红色光标）右移，区间方块“飞走”，对应线段树区间减 1。  
4. **答案更新**：每次满足条件时，像素数字“差值”闪烁，记录最小值。  

### 交互设计  
- **控制面板**：  
  - 单步 / 自动播放 / 重置 按钮（像素化图标）。  
  - 速度滑块（0.5× ~ 4×）。  
- **信息面板**：  
  - 实时显示：当前区间 [l,r]、覆盖最大值、当前差值。  
  - 对应代码行高亮（同步滚动）。  

### 技术实现（伪代码）  
```js
// 关键帧示例
for (let r = 0; r < n; ++r) {
    animateAdd(a[r]);          // 区间掉落动画
    while (maxCover >= m) {
        animateDel(a[l]);      // 区间飞走动画
        updatePixelDiff();     // 更新像素差值
        ++l;
    }
}
```

---

## 6. 拓展练习与相似问题思考

### 通用套路迁移  
“排序 + 尺取 + 区间数据结构”可解决：  
1. **最小化极差** 的区间选择问题（如本题）。  
2. **最大化覆盖** 的区间选择问题（如“最大 m 条区间覆盖点数”）。  
3. **带权区间** 的背包变形（如“选区间使权值和 ≥ k 且极差最小”）。

### 洛谷推荐练习  
| 题号 | 推荐理由 |
|---|---|
| **P1712**（本题） | 模板题，巩固离散化 + 尺取 + 线段树。 |
| **P4230 连环病原体** | 把线段树换成 LCT，体会数据结构升级。 |
| **P1083 借教室** | 区间减 + 前缀和，练习扫描线思想。 |
| **P2887 区间覆盖** | 双指针 + 贪心，区间覆盖变形。

---

## 7. 学习心得与经验分享（摘录）

> **来自 EternalEpic**  
> “区间长度别 +1，离散化写法别减 1，query 就是 `tmax[1]`！”  
> **洛语云笺点评**：  
> 这三个坑点非常典型，务必在调试时打印中间变量，避免低级错误。

---

<conclusion>
本次关于 NOI2016《区间》的 C++ 解题分析就到这里。  
记住：  
- 遇到大坐标 → **离散化**  
- 需要极差最小 → **排序 + 尺取**  
- 需要区间信息 → **线段树**  

持续练习，下次我们再一起探索新的算法挑战！💪
</conclusion>

---
处理用时：69.33秒
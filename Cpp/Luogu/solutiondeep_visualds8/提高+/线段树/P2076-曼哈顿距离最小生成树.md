# 题目信息

# 曼哈顿距离最小生成树

## 题目背景

题目修改自 [Library Checker](https://judge.yosupo.jp/problem/manhattanmst)，及[数据生成器 / 校验器来源](https://github.com/yosupo06/library-checker-problems/tree/master/geo/manhattanmst)。

请注意原题所有下标从 $0$ 开始（$0$-indexed），本题所有下标从 $1$ 开始（$1$-indexed）。

## 题目描述

给定平面上的 $n$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$。

考虑一个有 $n$ 个结点的完全图，对于 $1\le u,v\le n(u\ne v)$，结点 $u,v$ 之间有一条权值为 $|x_u-x_v|+|y_u-y_v|$ 的边。

请求出该图的最小生成树。

## 说明/提示

对于 $20\%$ 的数据，$1\le n\le 1000$。

对于 $100\%$ 的数据，$1\le n\le 2\times 10^5$，$0\le x_i,y_i\le 10^9$。

## 样例 #1

### 输入

```
6
3 8
4 9
2 1
10 5
4 9
2 0```

### 输出

```
21
5 2
6 3
1 2
3 1
4 1```

# AI分析结果

# 💡 洛语云笺的 C++ 算法解析：曼哈顿距离最小生成树 深入学习指南 💡

> 今天我们一起拆解「曼哈顿 MST」。它表面上是“最小生成树”，但边数高达 4×10¹⁰ 条，直接 Kruskal 会被卡爆。真正的挑战是：  
> **如何在看不见 99.9999% 的边时，仍然能精准地挑出 MST 所需的那 O(n) 条边？**

---

## 1. 题目解读与策略初探

✨ **核心挑战**  
> 在 2×10⁵ 个点、完全图 2×10¹⁰ 条边的恐怖量级下，求曼哈顿距离 MST。  
> 必须“**边剪枝 + 高效 MST**”双管齐下。

✨ **算法标签**  
- 几何 + 组合优化  
- 曼哈顿距离 8 区域性质  
- 二维偏序 + 树状数组  
- Kruskal / Borůvka 任选其一

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 原文或暗示 | 侦探解读 |
| --- | --- | --- |
| **线索1：边数爆炸** | n ≤ 2×10⁵，完全图 | 直接存边 → 内存爆炸，时间 O(m log m) 不可行 |
| **线索2：曼哈顿距离** | |x₁−x₂|+|y₁−y₂| | 旋转 45° 后可转曼哈顿为切比雪夫，区域性质明显 |
| **线索3：MST 只关心“必要边”** | Kruskal 贪心性质 | 如果能证明：每个点只需连 8 个方向的“最近点”，边数即降至 O(n) |

### 🧠 思维链构建：从线索到策略
> 1. 看到“完全图 + MST”，第一反应是 Kruskal，但 m = Θ(n²) 直接劝退。  
> 2. 曼哈顿距离有一个经典结论：**每个点只需向 8 个 45° 区域中的最近点连边**即可保留 MST。  
> 3. 于是问题转化为：  
>    - 对每个点，高效求 8 个区域内的“最近点” → **二维偏序 + 树状数组**  
>    - 边数降至 8n，再用 Kruskal 即可 O(n log n)。  
> 4. 结论：**“几何剪枝 + 标准 MST”** 是通关钥匙。

---

## 2. 精选优质题解参考

**题解来源：FFTotoro（赞：4）**  
> 这篇题解把“8 区域定理”证明得严谨又直观：  
> 1. 用反证法说明“最长边一定不在 MST”里；  
> 2. 只保留 4 个有效区域即可（对称性），边数再砍一半；  
> 3. 将二维偏序问题拆成 4 次扫描 + 树状数组，模板简洁。  
> 代码层面：  
> - 用 `tuple<int,int,int>` 存三元边，Kruskal 排序优雅；  
> - 树状数组维护 **(x+y, 点编号)** 最小值，离散化后一行搞定。  
> 整体时间 O(n log n)，空间 O(n)，可直接 AC。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 💡 学习笔记 |
| --- | --- | --- |
| **1. 8 区域定理** | 把平面旋转 45°，曼哈顿距离 = max(|x’|,|y’|)。每个点只需在 8 个象限里找“最近点”。 | 几何结论可把边数从 Θ(n²) 降到 Θ(n)。 |
| **2. 二维偏序转一维** | 把“区域 + 距离”拆成 4 次扫描。每次固定一个维度顺序，用树状数组维护另一维度最小值。 | 经典套路：排序一维 → 树状数组/线段树维护另一维极值。 |
| **3. 坐标变换** | 通过 4 次“翻转 + 交换”统一处理 4 个区域，避免写 8 套逻辑。 | 旋转/镜像坐标 = 减少重复代码的利器。 |

### ✨ 解题技巧总结
- **几何剪枝**：把完全图 MST 转成稀疏图 MST。  
- **坐标离散化**：避免树状数组下标爆炸。  
- **STL 小工具**：`tuple` 存边 + `sort` 简洁；`iota` 初始化并查集；`lower_bound` 离散化。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
| --- | --- | --- | --- | --- |
| **朴素 Kruskal** | 存所有边 → 排序 → 并查集 | 思路直接 | m = Θ(n²)，TLE+MLE | n ≤ 2000 |
| **8 区域 + Kruskal** | 几何剪枝后只剩 8n 条边 | O(n log n) 通过 | 需证明 8 区域定理 | 100% |
| **Borůvka** | 每轮找每个连通块的最近邻 | 也可 O(n log n) | 实现略繁琐，区域查找同样需树状数组 | 100% |

---

## 4. C++ 核心代码实现赏析

### 通用核心实现（提炼自 FFTotoro）

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using pii = pair<int,int>;
using tpi = tuple<int,int,int>;

struct DSU {
    vector<int> fa, sz;
    DSU(int n) : fa(n), sz(n,1) {
        iota(fa.begin(), fa.end(), 0);
    }
    int leader(int x) {
        return fa[x]==x ? x : fa[x]=leader(fa[x]);
    }
    bool merge(int x,int y){
        x=leader(x); y=leader(y);
        if(x==y) return false;
        if(sz[x]>sz[y]) swap(x,y);
        fa[x]=y; sz[y]+=sz[x];
        return true;
    }
};

// 曼哈顿 MST 主函数
pair<ll,vector<pii>> manhattan_mst(vector<pii> p){
    int n = p.size();
    vector<tpi> edges;
    for(int rot=0; rot<2; ++rot){
        for(int flip=0; flip<2; ++flip){
            // 坐标变换：旋转+翻转
            for(auto &[x,y]:p) x=-x;
            for(auto &[x,y]:p) swap(x,y);

            // 离散化 x
            vector<int> xs;
            for(auto [x,y]:p) xs.push_back(x);
            sort(xs.begin(), xs.end());
            xs.erase(unique(xs.begin(), xs.end()), xs.end());
            auto get = [&](int x){ return lower_bound(xs.begin(), xs.end(), x) - xs.begin(); };

            // 按 y-x 降序，x 降序 排序
            vector<int> id(n);
            iota(id.begin(), id.end(), 0);
            sort(id.begin(), id.end(), [&](int i,int j){
                int v1 = p[i].second - p[i].first;
                int v2 = p[j].second - p[j].first;
                return v1==v2 ? p[i].first > p[j].first : v1 > v2;
            });

            // 树状数组维护 (x+y, idx) 最小值
            struct BIT{
                int n; vector<pii> tr;
                BIT(int n):n(n), tr(n+1, {2e9,-1}) {}
                void upd(int x, pii v){
                    for(++x; x<=n; x+=x&-x) tr[x]=min(tr[x],v);
                }
                pii qry(int x){
                    pii res={2e9,-1};
                    for(++x; x; x-=x&-x) res=min(res,tr[x]);
                    return res;
                }
            } bit(xs.size());

            for(int i:id){
                auto [x,y]=p[i];
                int pos = get(x);
                auto [val,j] = bit.qry(pos);
                if(j!=-1) edges.emplace_back(i, j, val - (x+y));
                bit.upd(pos, {x+y, i});
            }
        }
    }

    // Kruskal
    sort(edges.begin(), edges.end(), [](tpi a,tpi b){ return get<2>(a) < get<2>(b); });
    DSU dsu(n);
    ll tot = 0;
    vector<pii> mst_edges;
    for(auto [u,v,w]:edges)
        if(dsu.merge(u,v)){
            tot += w;
            mst_edges.emplace_back(u,v);
        }
    return {tot, mst_edges};
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; cin>>n;
    vector<pii> pts(n);
    for(auto &[x,y]:pts){ cin>>x>>y; }
    auto [w,edges] = manhattan_mst(pts);
    cout << w << '\n';
    for(auto [u,v]:edges) cout << u+1 << ' ' << v+1 << '\n';
    return 0;
}
```

**代码亮点速览**  
- **坐标变换** 4 行搞定 8 区域：两次 `x=-x` + 一次 `swap(x,y)`。  
- **离散化** 让树状数组下标安全落在 0~n-1。  
- **树状数组** 仅维护 `(x+y, idx)` 最小值即可求“最近点”。  
- **DSU** 标准按秩合并，复杂度 O(n log n)。

---

## 5. 算法可视化：像素动画演示

**演示主题**：「像素寻宝队」在 8 个象限里找最近伙伴

- **场景设定**：8 位像素风网格，每个点是 8×8 像素方块。  
- **区域划分**：以当前点为中心，用 8 条 45° 斜线把平面切成 8 个扇形；扇形用不同复古颜色（红/蓝/绿/紫…）填充。  
- **关键帧**  
  1. 初始化：所有点随机落在网格，当前点高亮闪动。  
  2. **扫描动画**：像素箭头沿 x 或 y 轴滑动，触发树状数组查询；查询结果用“金色箭头”指向最近伙伴。  
  3. **连边动画**：一条像素化“电缆”从当前点连到最近伙伴，同时播放 8-bit “叮” 音效。  
  4. **Kruskal 阶段**：所有电缆按长度排序，像素化“进度条”走到 100%，并查集合并时两个连通块像素化“握手”。  
- **交互面板**  
  - 步进 / 自动 / 重置 / 调速滑块  
  - 小关卡：每成功连 1 条 MST 边，计 1 分；全部完成触发“通关”烟花动画。  

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**  
- 任意“完全图 + 特殊距离”都可尝试“几何剪枝”：切比雪夫、欧几里得、曼哈顿等均有区域性质。  
- 二维偏序套路同样适用于：  
  1. 平面最近点对  
  2. 最大空矩形  
  3. 矩形并面积/周长  

**洛谷推荐**  
1. **P4779**【模板】单源最短路径（加强版）  
   > 熟悉图论最短路，为后续几何+图论打基础。  
2. **P3366**【模板】最小生成树  
   > 经典 Kruskal 模板，可与本题对比体会“稀疏 vs 完全”差异。  
3. **P4169** [Violet 3] 天使玩偶  
   > 曼哈顿距离二维偏序 + 树状数组，与本题剪枝思路同源。  
4. **P4551** 最长异或路径  
   > Borůvka 应用，体验另一种 MST 策略。

---

## 7. 学习心得与经验分享

FFTotoro 在题解中提到：  
> “在写树状数组时把 `x+y` 和 `x-y` 搞反导致 WA 了两次，后来把坐标写在纸上画示意图才发现问题。”  

**洛语云笺点评**：  
调试几何题，**手绘坐标图**永远是最快的排错手段！把变量写在图上，一眼就能发现符号或顺序错误。

---

<conclusion>  
曼哈顿 MST 教会我们：当数据规模大到无法“硬存”时，先用几何洞察剪枝，再用经典算法收尾。  
掌握“8 区域 + 二维偏序”这把钥匙，你就能优雅地撬开百万级完全图的大门！继续加油，下题见。💪

---
处理用时：97.46秒
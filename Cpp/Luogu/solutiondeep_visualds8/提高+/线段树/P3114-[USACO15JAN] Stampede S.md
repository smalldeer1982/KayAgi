# 题目信息

# [USACO15JAN] Stampede S

## 题目描述

FJ 的 $N$ 头奶牛（$1 \leq N \leq 50,000$）看似在农场前的路上狂奔，实际上它们正在进行一场赛跑。

从上方俯视，每头牛在时间 $t = 0$ 时被表示为一个单位长度的水平线段，其左端点坐标为 $(x, y)$。例如，$(-3, 6)$ 表示一头在 $t = 0$ 时从 $(-3, 6)$ 延伸到 $(-2, 6)$ 的奶牛。每头牛以一定速度向右（$+x$ 方向）移动，该速度由移动 1 单位距离所需的整数时间 $r$ 描述。

FJ 并不满意他的奶牛在外赛跑而不在牛棚产奶。他计划在比赛结束后训斥参赛的奶牛。为了确定哪些奶牛参赛，FJ 站在 $(0, 0)$ 处并沿 $+y$ 方向的射线观察。当一头牛在某个时刻成为这条射线上首个可见的牛时，FJ 就会看到它。如果一头牛在穿过 FJ 视线期间始终被其他牛"挡住"，则她不可见。

请计算 FJ 在整个比赛过程中能看到的奶牛数量。

## 说明/提示

FJ 可以看到牛 1 和 2，但看不到牛 3。

## 样例 #1

### 输入

```
3 
-2 1 3 
-3 2 3 
-5 100 1 
```

### 输出

```
2 
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：USACO15JAN Stampede S 深入学习指南 💡

> 嗨，各位小探险家们！今天我们要一起攻克一道经典的 **“奶牛赛跑”** 问题。这不仅仅是一道题，更是一场 **“时间轴上的遮挡游戏”**！我们要学会如何把奶牛的运动轨迹，转化为一条 **时间线**，并用巧妙的算法找出哪些奶牛能被 FJ 看到。准备好和我一起踏上这段算法之旅了吗？

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
这道题的核心挑战在于：**如何把奶牛在二维平面上的运动，抽象成时间轴上的“可见性”问题？**  
每头奶牛的运动轨迹是一条向右的水平线段，FJ 站在原点向上看。我们需要找出，在整个过程中，有多少头奶牛 **至少有一次** 成为了 FJ 视线中最下面的那一条。

### 🗣️ 初步分析
1. **时间区间转化**：每头奶牛的运动可以转化为一个 **时间段**，在这个时间段内，它可能挡住 FJ 的视线。
2. **离散化**：由于时间范围可能很大，我们需要把时间点 **离散化**，用它们的 **相对顺序** 代替绝对数值。
3. **区间覆盖**：我们需要判断，每头奶牛对应的时间段，是否被其他 **y 值更小** 的奶牛完全覆盖。如果没有，这头奶牛就能被看到。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：题目要求统计 **“能被看到的奶牛数量”**，本质上是 **“在多个重叠区间中，找出不被其他区间完全覆盖的区间”**。这提示我们使用 **区间处理** 或 **扫描线** 的思想。
2. **线索2 (数据规模)**：N ≤ 50,000，提示我们需要一个 **O(N log N)** 或更优的算法。**离散化 + 线段树** 或 **扫描线 + 平衡树** 是理想选择。
3. **线索3 (关键细节)**：时间区间必须处理为 **左闭右开**，否则相邻区间会误判为重叠。

---

## 2. 精选优质题解参考

### 题解一：离散化 + 线段树区间覆盖（作者：☯☯枫☯☯）
- **点评**：思路清晰，代码简洁。通过离散化将大区间映射到小范围，然后用线段树暴力覆盖区间，最后检查每头奶牛的时间段是否被标记为自己的编号。虽然时间复杂度是 **O(N²)**，但在数据较小时非常直观。
- **学习点**：离散化的实现细节（左闭右开）、线段树的区间覆盖操作。

### 题解二：扫描线 + 平衡树（作者：Expecto）
- **点评**：优雅的 **扫描线** 解法！将每头奶牛的时间段拆成 **开始事件** 和 **结束事件**，按时间排序后，用 **平衡树（set）** 维护当前活跃的奶牛。每次事件发生时，检查平衡树中最小的 y 值对应的奶牛是否可见。
- **学习点**：扫描线的经典套路、平衡树的动态维护。

### 题解三：离散化 + 线段树优化（作者：Na2PtCl6）
- **点评**：标准的 **离散化 + 线段树** 模板。按 y 值从小到大排序后，用线段树检查区间是否被覆盖。代码规范，细节处理到位（如离散化时乘以2避免精度问题）。
- **学习点**：线段树的 **区间查询 + 区间覆盖** 操作、离散化的边界处理。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

#### 关键点1：时间区间的正确表示
- **分析**：每头奶牛的时间段为 `[st, ed)`，其中：
  - `st = (-x - 1) * r`（左端点接触 y 轴的时间）
  - `ed = (-x) * r`（右端点离开 y 轴的时间）
- **学习笔记**：必须 **左闭右开**，否则相邻区间会被误判为重叠。

#### 关键点2：离散化的实现
- **分析**：将所有 `st` 和 `ed` 收集起来，排序去重后，用它们的 **排名** 代替原始值。
- **学习笔记**：离散化是解决 **大值域问题** 的利器，注意处理重复值。

#### 关键点3：区间覆盖与查询
- **分析**：按 y 值从小到大排序后，用线段树维护区间覆盖状态。对于每头奶牛：
  1. 查询 `[st, ed)` 是否 **未被完全覆盖**。
  2. 若未被覆盖，答案 +1，并覆盖该区间。
- **学习笔记**：线段树的 **区间覆盖** 和 **区间查询** 是核心操作。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力区间覆盖** | 离散化后直接遍历区间 | 代码简单 | O(N²) 超时 | N ≤ 1000 |
| **线段树优化** | 离散化 + 线段树 | O(N log N) | 代码较长 | 标准解法 |
| **扫描线 + 平衡树** | 事件排序 + 动态维护 | 思路优雅 | 需平衡树支持 | 扫描线经典 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合了离散化 + 线段树的标准实现，清晰易懂。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 5e4 + 10;

struct Cow {
    int l, r, y;
    bool operator<(const Cow& other) const {
        return y < other.y;
    }
} cows[MAXN];

int n, ans, tot;
long long raw[MAXN * 2], lsh[MAXN * 2];

struct SegTree {
    int l, r, cov;
} tree[MAXN * 8];

void build(int p, int l, int r) {
    tree[p].l = l, tree[p].r = r, tree[p].cov = 0;
    if (l == r) return;
    int mid = (l + r) / 2;
    build(p * 2, l, mid);
    build(p * 2 + 1, mid + 1, r);
}

void push_down(int p) {
    if (tree[p].cov) {
        tree[p * 2].cov = tree[p * 2 + 1].cov = tree[p].cov;
        tree[p].cov = 0;
    }
}

bool query(int p, int l, int r) {
    if (tree[p].l > r || tree[p].r < l) return true;
    if (l <= tree[p].l && tree[p].r <= r) return tree[p].cov;
    push_down(p);
    return query(p * 2, l, r) && query(p * 2 + 1, l, r);
}

void update(int p, int l, int r, int v) {
    if (tree[p].l > r || tree[p].r < l) return;
    if (l <= tree[p].l && tree[p].r <= r) {
        tree[p].cov = v;
        return;
    }
    push_down(p);
    update(p * 2, l, r, v);
    update(p * 2 + 1, l, r, v);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(0);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        int x, y, r;
        cin >> x >> y >> r;
        cows[i].l = (-x - 1) * r;
        cows[i].r = (-x) * r;
        cows[i].y = y;
        raw[++tot] = cows[i].l;
        raw[++tot] = cows[i].r;
    }

    sort(raw + 1, raw + tot + 1);
    int m = unique(raw + 1, raw + tot + 1) - raw - 1;
    for (int i = 1; i <= n; ++i) {
        cows[i].l = lower_bound(raw + 1, raw + m + 1, cows[i].l) - raw;
        cows[i].r = lower_bound(raw + 1, raw + m + 1, cows[i].r) - raw;
    }

    sort(cows + 1, cows + n + 1);
    build(1, 1, m);
    for (int i = 1; i <= n; ++i) {
        if (!query(1, cows[i].l, cows[i].r - 1)) {
            ans++;
            update(1, cows[i].l, cows[i].r - 1, 1);
        }
    }
    cout << ans << endl;
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题：像素牧场中的奶牛赛跑
- **场景**：一个8位像素风格的牧场，奶牛以水平线段形式向右移动。
- **核心演示**：每头奶牛对应一个时间区间，线段树动态展示区间覆盖过程。
- **交互**：
  - **单步模式**：点击“下一步”查看每头奶牛的判断过程。
  - **自动模式**：奶牛按 y 值从小到大排序后，自动覆盖区间。
- **音效**：
  - 奶牛被看到时播放“叮”的胜利音效。
  - 区间被覆盖时播放“噗”的覆盖音效。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **离散化 + 线段树**：适用于所有 **区间覆盖/查询** 问题，如：
  1. **P1494 聪明的燕姿**：区间染色统计不同颜色数。
  2. **P3870 开关灯**：区间翻转 + 查询。
  3. **P4563 守卫**：二维区间覆盖。

### 洛谷推荐练习
1. **P1494 聪明的燕姿**  
   🗣️ 推荐理由：区间染色问题，巩固离散化 + 线段树。
2. **P3870 开关灯**  
   🗣️ 推荐理由：区间翻转操作，熟悉线段树懒标记。
3. **P4563 守卫**  
   🗣️ 推荐理由：二维区间覆盖，提升建模能力。

---

## 7. 学习心得与经验分享

- **来自子谦。**：“一开始看错题，把速度理解错了，导致样例答案错误。调试时打印中间变量是关键！”
- **来自曹老师**：“线段树的懒标记一定要 push_down，否则会 WA 到怀疑人生！”

---

> 总结：这道题教会我们如何将 **二维运动问题** 转化为 **一维区间问题**，并通过 **离散化 + 线段树** 高效解决。记住：左闭右开、离散化排序、线段树懒标记，是这类问题的三大法宝！

---
处理用时：83.74秒
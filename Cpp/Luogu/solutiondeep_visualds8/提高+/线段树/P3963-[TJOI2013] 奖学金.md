# 题目信息

# [TJOI2013] 奖学金

## 题目背景

小张最近发表了一篇论文，有一个神秘人物要给小张学院发奖学金。

## 题目描述

小张学院有 $c$ 名学生，第 $i$ 名学生的成绩为 $a_i$，要获得的奖学金金额为 $b_i$。  
要从这 $c$ 名学生中挑出 $n$ 名学生发奖学金。这个神秘人物爱好奇特，他希望得到奖学金的同学的**成绩**的**中位数**尽可能大，但同时，他们的**奖学金总额**不能超过 $f$。


## 说明/提示

### 样例 1 解释

选择成绩为 $5$，$35$，$50$ 的三名同学，奖金总额为 $18 + 30 + 21 = 69$。

### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^3$，$c \leq 2 \times 10^3$。
- 对于 $100\%$ 的数据，保证 $3 \leq n  \leq 10^5$，$n \leq c \leq 2 \times 10^5$，$0 \leq f \leq 2\times 10^9$，$0 \leq a_i \leq 2 \times 10^9$，$0 \leq b_i \leq 10^5$。

## 样例 #1

### 输入

```
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出

```
35```

## 样例 #2

### 输入

```
5 6 9
4 0
4 1
6 3
8 0
10 4
10 5
```

### 输出

```
6```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：奖学金（TJOI2013）深入学习指南 💡

> 今天我们来一起分析「奖学金」这道 C++ 编程题。这不仅仅是一次解题，更是一场思维的探险——如何把“成绩中位数最大”与“奖学金总额受限”这两个看似矛盾的目标，巧妙地拆分成可计算的步骤。

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在选出的 n 名学生里，**中位数成绩**要尽可能大，但**总奖学金**不能超过给定上限 f。  
✨ **核心算法标签**：贪心 + 二分思想 + 数据结构维护前 k 小和（优先队列 / 主席树 / 权值线段树）。

🗣️ **初步分析**  
1. 如果直接枚举所有 n 人组合，C(2×10⁵, 10⁵) 显然爆炸。  
2. 题目只关心**中位数**，且 n 为奇数，意味着只要固定第 `(n+1)/2` 位是谁，剩下两边各取 `(n-1)/2` 个最小奖学金即可。  
3. 因此思路是：  
   - **按成绩排序** → 升序枚举/二分可能的“中位数”。  
   - **数据结构** → 快速求“左边/右边前 (n-1)/2 小奖学金之和”。  
   - **贪心验证** → 若 `左和 + 中位数奖金 + 右和 ≤ f`，则可行。

### 🔍 算法侦探：如何在题目中发现线索？
- **线索1 (问题目标)**：“中位数最大”提示**排序 + 二分/枚举**；  
- **线索2 (约束)**：“奖学金总额 ≤ f”提示**区间前 k 小和**；  
- **线索3 (数据规模)**：c ≤ 2×10⁵，要求**O(c log c)** 或 **O(c log² c)**。

🧠 **思维链构建**  
> “侦探”发现：  
> 1. 中位数固定后，左右各取最小奖学金 → **贪心成立**。  
> 2. 需要多次求“前 k 小和” → **优先队列**或**主席树**。  
> 3. 枚举顺序可**从大到小**提前剪枝，得到最优解。

## 2. 精选优质题解参考

| 题解亮点 | 作者 | 摘要点评 |
|---|---|---|
| **优先队列 O(c log c)** | 胖头鱼学员、ycyaw、LlLlCc 等 | 思路最直观：左右各扫一遍，用最大堆维护“前 k 小”。代码短、常数小，是考场首选。 |
| **主席树 O(c log c)** | 渡墨残殇、FutaRimeWoawaSete | 用主席树查询区间前 k 小和，思路通用，但实现略长；注意叶子节点需 `k×val`。 |
| **权值线段树** | ix35、BeautyYu言醴 | 与主席树类似，但需离散化；空间可滚动优化。 |
| **Splay 平衡树** | saligia | 用两棵 Splay 动态维护左右区间前 k 小，写法复杂但功能强大，适合练习平衡树。 |

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以优先队列为最优策略）
1. **关键点1：排序与中位数定位**  
   - 按成绩升序排序，设中位数下标 i 需满足 `i ≥ (n+1)/2` 且 `i ≤ c-(n-1)/2`。  
   - 💡 学习笔记：排序后，中位数天然把数组切成三段，便于贪心。

2. **关键点2：预处理左右“前 k 小和”**  
   - 从左到右扫，用**最大堆**维护当前最小的 `(n-1)/2` 个奖金，实时更新 `left[i]`。  
   - 同理从右到左扫得 `right[i]`。  
   - 💡 学习笔记：最大堆可 O(log k) 插入/删除，整体 O(c log k)。

3. **关键点3：验证并取最大中位数**  
   - 倒序枚举 i，若 `left[i-1] + a[i].money + right[i+1] ≤ f`，则 `a[i].grade` 即为答案。  
   - 💡 学习笔记：倒序保证第一个满足条件的即最大值。

### ✨ 解题技巧总结
- **排序 + 贪心**：把“中位数”转化为固定位置问题。  
- **堆维护前 k 小**：最大堆存“已选最大”，替换更小的。  
- **前缀/后缀数组**：避免每次重新计算，空间换时间。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 时间复杂度 | 优缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 枚举所有 n 人组合 | O(C(c,n)) | 思路简单，必超时 | c ≤ 20 |
| **优先队列** | 排序后左右各扫一遍，堆维护前 k 小 | O(c log c) | 代码短，常数小 | 推荐！ |
| **主席树** | 区间第 k 小和查询 | O(c log c) | 通用，但实现长 | 需通用区间查询 |
| **权值线段树** | 离散化后区间求和 | O(c log c) | 与主席树类似 | 同主席树 |
| **平衡树** | Splay 动态维护 | O(c log c) | 功能强，难写 | 练平衡树 |

### ✨ 优化之旅
> 从“暴力”到“贪心+堆”的跃迁：  
> 1. 发现“中位数固定后只需最小和” → 贪心成立。  
> 2. 发现“多次区间前 k 小” → 用堆预处理。  
> 3. 发现“倒序枚举即可剪枝” → 立即得到最大中位数。

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（优先队列版）
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 2e5 + 5;
struct Node { int grade, money; } a[N];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, c, f;              // n:选几人, c:总人数, f:上限
    if (!(cin >> n >> c >> f)) return 0;
    for (int i = 1; i <= c; ++i) cin >> a[i].grade >> a[i].money;

    // 按成绩升序
    sort(a + 1, a + c + 1, [](const Node& x, const Node& y) {
        return x.grade < y.grade;
    });

    int k = (n - 1) / 2;      // 左右各取 k 人
    vector<ll> left(c + 2), right(c + 2);

    // 从左到右扫
    priority_queue<int> pq;
    ll sum = 0;
    for (int i = 1; i <= c; ++i) {
        if (i <= k) {                 // 前 k 个直接入堆
            pq.push(a[i].money);
            sum += a[i].money;
            left[i] = 1e18;           // 前面不足 k 个，非法
        } else {
            left[i] = sum;            // 记录当前前 k 小和
            pq.push(a[i].money);
            sum += a[i].money;
            if (pq.size() > k) {        // 保证堆大小=k
                sum -= pq.top();
                pq.pop();
            }
        }
    }

    // 从右到左扫
    while (!pq.empty()) pq.pop();
    sum = 0;
    for (int i = c; i >= 1; --i) {
        if (i > c - k) {
            pq.push(a[i].money);
            sum += a[i].money;
            right[i] = 1e18;
        } else {
            right[i] = sum;
            pq.push(a[i].money);
            sum += a[i].money;
            if (pq.size() > k) {
                sum -= pq.top();
                pq.pop();
            }
        }
    }

    // 倒序枚举中位数
    for (int i = c - k; i >= k + 1; --i) {
        if (left[i - 1] + a[i].money + right[i + 1] <= f) {
            cout << a[i].grade << '\n';
            return 0;
        }
    }
    cout << "-1\n";
    return 0;
}
```
- **代码解读概要**：排序 → 左右两遍堆维护 → 倒序验证 → 输出答案。

### 精选片段赏析（主席树查询片段）
```cpp
long long query(int l,int r,int nl,int nr,int rank) {
    if (l == r) return 1LL * rank * cmt[l];   // 关键：叶子节点需乘 rank
    int mid = (l + r) >> 1;
    int left_cnt = tree[tree[nr].l].sum - tree[tree[nl].l].sum;
    if (rank <= left_cnt)
        return query(l, mid, tree[nl].l, tree[nr].l, rank);
    else
        return tree[tree[nr].l].sum_val - tree[nl].sum_val
               + query(mid + 1, r, tree[nl].r, tree[nr].r, rank - left_cnt);
}
```
- **亮点**：离散化 + 主席树区间第 k 小和。  
- **学习笔记**：叶子节点一定要 `k * val`，否则相同权值会出错。

## 5. 算法可视化：像素动画演示

- **主题**：8-bit 像素校园，像素学生排队，成绩条像血条，奖学金像金币。  
- **核心演示**  
  1. 排序：学生按成绩升序排成一排，像素箭头指示当前中位数候选。  
  2. 预处理：左右各出现一个小推车（最大堆），把最小的 k 个金币装进去，实时显示 `sum` 值。  
  3. 验证：像素老师从右往左走，每走到一个学生，把“左车金币 + 自己金币 + 右车金币”与预算条对比，若 ≤ f，像素礼花+胜利音效；否则继续。  
- **交互**：步进/自动播放，速度滑块，点击学生可手动设定中位数。  
- **音效**：堆插入/弹出“叮”，成功“叮咚咚”，失败“嘟”。

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**：  
  1. 课程冲突：只能选一门课 → 分组背包。  
  2. 任务互斥：有依赖的任务选择 → 树形背包。  
  3. 区间第 k 小和：主席树/堆均可。

- **洛谷推荐**  
  1. P1637 三元上升子序列（离散化 + 树状数组/主席树）  
  2. P1484 种树（区间贪心 + 堆）  
  3. P2617 Dynamic Rankings（动态区间第 k 小）  
  4. P2827 蚯蚓（优先队列维护极值）

## 7. 学习心得与经验分享

> 来自 BeautyYu言醴：  
> “写主席树时，我 MLE 了两次才意识到——**只保留当前和上一版本即可**，其余节点及时回收。”  
> 洛语云笺点评：空间优化是数据结构题的常见考点，学会“滚动”或“只保留必要版本”能救命！

---

<conclusion>
恭喜你又掌握了一道经典贪心 + 数据结构的综合题！  
记住套路：排序 → 贪心结论 → 数据结构维护 → 枚举/二分验证。  
下次遇到“最大/最小中位数”类问题，直接想到“排序 + 两边前 k 小”即可。继续加油，算法探险永不止步！💪
</conclusion>

---
处理用时：95.13秒
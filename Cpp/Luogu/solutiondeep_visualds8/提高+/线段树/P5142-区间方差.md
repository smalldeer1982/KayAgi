# 题目信息

# 区间方差

## 题目背景

出题人并没有能力写有趣的题面……


## 题目描述

对于一个长度为 $n$ 的序列 $a_1,a_2,a_3\cdots a_n$，我们定义它的平均数 $a$ 为:

$$a=\frac{1}{n}\sum_{i=1}^{n}a_i$$

并定义它的方差 $d$ 为:

$$d=\frac{1}{n}\sum_{i=1}^{n}(a_i-a)^2$$

现在给定一个长度为 $n$ 的序列 $b_1,b_2\cdots b_n$。你需要支持两种操作。每种操作的格式为 `c x y`。

若 $c=1$，为修改操作，代表将 $b_x$ 赋值为 $y$。

若 $c=2$，为查询操作，代表查询 $b_x$ 到 $b_y$ 的方差。

为了避免浮点数误差，请以分数取模形式输出结果（对 1000000007（$10^9+7$）取模）。

## 说明/提示

#### 样例 1 解释
四次修改后，序列 $b$ 为：$\{1,2,3,4\}$。

区间 $[1,1]$ 的方差为 $0$。

区间 $[1,2]$ 的方差为 $\frac{1}{4}$ 。$4$ 的逆元为 $250000002$。

区间 $[1,3]$ 的方差为 $\frac{2}{3}$。$3$ 的逆元为 $333333336$，$2\times333333336\bmod M=666666672$。

#### 数据规模与约定

- 对于 $50\%$ 的数据，$n\leq 1000$，$m\leq 1000$。
- 对于 $100\%$ 的数据，$1\leq n,m\leq 1\times 10^5$，$1\leq b_i\leq 1\times 10^9$，$1\leq x\leq n$。对于操作 1，$1\leq y\leq 1\times 10^9$。对于操作2，$x\leq y\leq n$。

## 样例 #1

### 输入

```
4 8
0 0 0 0
1 1 1
1 2 2
1 3 3
1 4 4
2 1 1
2 1 2
2 1 3
2 1 4```

### 输出

```
0
250000002
666666672
250000003```

# AI分析结果

# 💡 洛语云笺的C++算法解析：P5142 区间方差 深入学习指南 💡

> 今天我们来一起分析“区间方差”这道C++编程题。它看似只是一道“求方差”的数学题，实则暗藏“数据结构”与“代数推导”两大杀器。我们将像侦探一样，从公式里找出可维护的“宝藏”，再挑选最合适的数据结构，把暴力 O(n) 查询一步步优化到 O(log n)。准备好和洛语云笺一起踏上这段思维探险了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
题目要求 **在线** 支持两种操作：  
1. 单点修改某个元素；  
2. 查询任意区间的 **方差**（要求分数取模）。  

核心难点在于 **“方差”无法直接区间维护**，必须通过 **代数变形** 把它拆成 **区间和 + 区间平方和** 两个可累加量，再用 **线段树 / 树状数组** 高效维护。

✨ **核心算法标签**：  
- 代数推导（公式化简）  
- 线段树（单点修改 + 区间查询）  
- 树状数组（单点修改 + 区间查询）  
- 分块（带修莫队 / 普通分块）  
- 数论：模意义下有理数（费马小定理求逆元）

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 关键启示 |
|---|---|---|
| **线索1：问题目标** | 查询区间方差，且要分数取模 | 需把方差公式拆成 **区间和 + 区间平方和** |
| **线索2：操作类型** | 单点修改 + 区间查询 | 经典 **可累加信息** 场景 → 线段树/树状数组 |
| **线索3：数据规模** | n, m ≤ 1e5 | O(n log n) 总复杂度可过；O(n²) 会超时 |

### 🧠 思维链构建：从线索到策略
> 1. 看到“区间查询 + 单点修改” → 想到线段树/树状数组  
> 2. 看到“方差” → 先化简公式，拆成 **区间和** 与 **区间平方和**  
> 3. 看到“分数取模” → 用 **费马小定理** 求分母逆元  
> 4. 最终：用 **两个区间和** 即可 O(log n) 回答一次查询！

---

## 2. 精选优质题解参考

> 洛语云笺从 15 份题解中，依据“思路清晰度、代码规范性、启发性”筛选出 **5 份 ≥4 星** 的优质参考，并融入我的点评，助你快速吸收精华。

| 题解 | 作者 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|---|
| **线段树（简洁公式推导）** | fa_555 | 1. 用 **两行公式** 把方差拆成 Σx²/n − (Σx/n)²；<br>2. 仅用 **s1, s2 两个数组** 维护区间和、平方和；<br>3. 代码短小精悍，无懒标记。 | 这是 **最正统** 的做法！公式推导一步到位，代码也极简洁，适合新手背诵模板。 |
| **树状数组（双 BIT）** | NaCly_Fish | 1. **两个 BIT** 分别维护 Σx、Σx²；<br>2. 用 **差分思想** 处理区间查询；<br>3. 代码量更少，常数更优。 | 树状数组天然适合 **单点修改 + 区间查询**，这份代码把 BIT 的优雅展现得淋漓尽致。 |
| **zkw 线段树** | ADay | 1. 使用 **zkw 非递归线段树**，码量 70 行；<br>2. 位运算加速，常数极小；<br>3. 适合卡常冲榜。 | 如果你追求 **极致常数**，zkw 是不错的选择；同时能学到非递归写法。 |
| **分块（带修莫队）** | 滑稽的小宫 | 1. 用 **带修莫队** 解决，块长 n^(2/3)；<br>2. 展示如何维护 **平方和 & 和** 在移动指针时更新；<br>3. 提供莫队调试技巧。 | 虽然复杂度 O(n^(5/3)) 比 log 劣，但 **思路通用**，可迁移到更复杂的离线问题。 |
| **分块（普通分块）** | Jsxts_ | 1. 经典 **√n 分块**；<br>2. 块内维护 **sum & sum²**；<br>3. 散块暴力，整块直接取。 | 分块思维直观，代码易写，适合 **现场赛快速出解**。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：线段树）

| 关键点 | 分析 & 推导 | 💡 学习笔记 |
|---|---|---|
| **公式化简** | 将方差展开：<br>σ² = Σ(xᵢ−x̄)² / n<br>= (Σxᵢ² / n) − (Σxᵢ / n)² | **把不可维护的“方差”拆成两个“可累加”量！** |
| **数据结构选择** | 需要 **单点修改 + 区间查询** → 线段树/树状数组皆可；<br>维护 **区间和 s1** 与 **区间平方和 s2**。 | 可累加信息 → 线段树模板直接套。 |
| **分数取模** | 分母为区间长度 len，需乘 **len⁻¹ mod 1e9+7**；<br>用费马小定理：len⁻¹ ≡ len^(mod−2) (mod mod)。 | 记得处理负数：(ans % mod + mod) % mod |

### ✨ 解题技巧总结
- **技巧A：公式拆分**——把复杂统计量拆成若干“可累加”子量，是数据结构题万能钥匙。  
- **技巧B：双量维护**——同时维护“原值和”与“平方和”，可解决方差、标准差、均方差等问题。  
- **技巧C：逆元处理**——模数为质数时，除法转乘逆元；快速幂/线性递推皆可。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 O(n) 查询** | 每次遍历区间计算 | 思路零门槛 | m=1e5 时 1e10 运算 → TLE | 数据 ≤ 1e3 |
| **线段树 O(log n)** | 维护 s1, s2 | 代码短，常数小 | 空间 4n | 标准比赛解法 |
| **树状数组 O(log n)** | 双 BIT 维护 s1, s2 | 码量更少，常数优 | 只能处理单点修改 | 单点修改模板题 |
| **分块 O(√n)** | 块内维护 s1, s2 | 易写，易扩展到区改 | 复杂度略逊 | 现场赛/区改扩展 |
| **带修莫队 O(n^5/3)** | 离线 + 块排序 | 通用离线框架 | 复杂度劣，需离线 | 复杂离线问题 |

---

## 4. C++核心代码实现赏析

### ① 本题通用核心C++实现参考（线段树版）
> 综合 fa_555、Prean 等优质题解提炼出的“最小可运行”模板。

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int MOD = 1e9 + 7;
int n, m;
int64 a[100005];

int64 qpow(int64 a, int64 b = MOD - 2, int64 res = 1) {
    for (a %= MOD; b; b >>= 1, a = a * a % MOD)
        if (b & 1) res = res * a % MOD;
    return res;
}

struct SegTree {
    struct Node { int64 s1, s2; } t[1 << 18];
#define ls (p << 1)
#define rs (p << 1 | 1)
    void push_up(int p) {
        t[p].s1 = (t[ls].s1 + t[rs].s1) % MOD;
        t[p].s2 = (t[ls].s2 + t[rs].s2) % MOD;
    }
    void build(int p, int l, int r) {
        if (l == r) { t[p].s1 = a[l] % MOD; t[p].s2 = a[l] * a[l] % MOD; return; }
        int mid = (l + r) >> 1;
        build(ls, l, mid); build(rs, mid + 1, r);
        push_up(p);
    }
    void modify(int p, int l, int r, int pos, int64 v) {
        if (l == r) { t[p].s1 = v % MOD; t[p].s2 = v * v % MOD; return; }
        int mid = (l + r) >> 1;
        pos <= mid ? modify(ls, l, mid, pos, v) : modify(rs, mid + 1, r, pos, v);
        push_up(p);
    }
    Node query(int p, int l, int r, int ql, int qr) {
        if (ql <= l && r <= qr) return t[p];
        int mid = (l + r) >> 1;
        Node L{0, 0}, R{0, 0};
        if (ql <= mid) L = query(ls, l, mid, ql, qr);
        if (qr > mid)  R = query(rs, mid + 1, r, ql, qr);
        return Node{(L.s1 + R.s1) % MOD, (L.s2 + R.s2) % MOD};
    }
#undef ls
#undef rs
} seg;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    seg.build(1, 1, n);
    while (m--) {
        int op, x, y; cin >> op >> x >> y;
        if (op == 1) seg.modify(1, 1, n, x, y);
        else {
            auto [s1, s2] = seg.query(1, 1, n, x, y);
            int64 len = y - x + 1, inv = qpow(len);
            int64 avg = s1 * inv % MOD;
            int64 ans = (s2 * inv % MOD - avg * avg % MOD + MOD) % MOD;
            cout << ans << '\n';
        }
    }
    return 0;
}
```

### ② 树状数组核心片段（NaCly_Fish）

```cpp
struct BIT {
    int64 c[100005];
    void add(int x, int64 v) { for (; x <= n; x += x & -x) (c[x] += v) %= MOD; }
    int64 ask(int x) { int64 s = 0; for (; x; x -= x & -x) (s += c[x]) %= MOD; return s; }
    int64 range(int l, int r) { return (ask(r) - ask(l - 1) + MOD) % MOD; }
} bit1, bit2;
// bit1 维护 Σa[i]，bit2 维护 Σa[i]²
```

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：8-bit “线段树小精灵” 维护区间方差

| 场景 | 像素化设计 | 音效/互动 |
|---|---|---|
| **初始化** | 绿色草地背景，n 个像素方块排成一排，上方显示 `Σx`, `Σx²` 两棵树 | 8-bit 背景音乐 |
| **单点修改** | 鼠标点击第 x 个方块 → 方块闪烁 → 数值更新 → 线段树节点自下而上发光 | “叮” 更新音 |
| **区间查询** | 拖拽选择区间 → 红色扫描线从左扫到右 → 实时显示 `Σx`, `Σx²` 累加 → 最终弹出方差像素勋章 | “胜利” 音 + 像素礼花 |
| **AI 演示** | 自动随机修改 & 查询，速度可调滑块 | 可暂停/单步 |

**实现提示**：  
- Canvas 每帧重绘线段树节点，颜色代表 `s1/s2` 值大小。  
- 音效用 Web Audio API 播放 440 Hz 方波“叮”。  
- 使用 `requestAnimationFrame` 保证 60 FPS 像素动画。

---

## 6. 拓展练习与相似问题思考

### 🧩 通用技巧迁移
- **“拆公式 + 双量维护”** 适用于：  
  1. **区间标准差**（再加一个开方，但模意义下需二次剩余）  
  2. **区间协方差**（维护 Σxy, Σx, Σy）  
  3. **区间均方误差**（维护 Σ(x−y)² = Σx² + Σy² − 2Σxy）

### 📚 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P1471 方差** | 在 P5142 基础上加入 **区间加** 与 **区间乘**，需懒标记。 |
| **P2122 还教室** | 区间方差 + 区间加，考验 **懒标记下传** 与 **公式推导**。 |
| **P3372 线段树模板1** | 纯区间和，可作为 **前置练习** 巩固线段树。 |
| **P3368 树状数组2** | 区间加 + 单点查询，与 BIT 双数组思想呼应。 |

---

## 7. 学习心得与经验分享 (摘录)

> **fa_555 后记**：“故意不开 `long long` 是为了磨炼基本功……平常把刀磨锋利，考试才能得心应手。”  
> **洛语云笺点评**：作者提醒我们——**刻意训练**细节（如强制类型转换、取模位置）能大幅降低赛场失误率。

---

<conclusion>
至此，我们已经完整拆解了“区间方差”从数学推导到数据结构实现的全过程。  
记住：  
- **先化简，再维护**——把不可维护的统计量拆成可累加信息；  
- **线段树 / 树状数组**——单点修改 + 区间查询的黄金搭档；  
- **逆元处理**——模意义下除法的通用钥匙。  

带着这三板斧，去迎接更多区间统计挑战吧！💪
</conclusion>

---
处理用时：133.19秒
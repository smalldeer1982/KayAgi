# 题目信息

# 【模板】扫描线 & 矩形面积并

## 题目描述

求 $n$ 个四边平行于坐标轴的矩形的面积并。

## 说明/提示

对于 $20\%$ 的数据，$1 \le n \le 1000$。  
对于 $100\%$ 的数据，$1 \le n \le {10}^5$，$0 \le x_1 < x_2 \le {10}^9$，$0 \le y_1 < y_2 \le {10}^9$。

Updated on 4.10 by Dengduck（口胡） \& yummy（实现）：增加了一组数据。

## 样例 #1

### 输入

```
2
100 100 200 200
150 150 250 255
```

### 输出

```
18000
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：扫描线 & 矩形面积并 深入学习指南 💡

> 今天我们来攻克“矩形面积并”这道经典计算几何题。它不仅是竞赛常客，更是理解“扫描线 + 线段树”这一黄金组合的绝佳范例。我们将从暴力思路一步步走向高效算法，并用像素动画帮你把抽象概念变成看得见的过程！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在 **1e5 个矩形、坐标 1e9** 的极端规模下，**精确计算所有矩形的并集面积**，并处理复杂的重叠情况。

✨ **核心算法标签**：  
`扫描线` `离散化` `线段树` `区间修改`

🗣️ **思路演进路径**：

| 方法 | 思想 | 时间复杂度 | 能否通过 |
| --- | --- | --- | --- |
| 暴力枚举像素 | 把平面当网格，逐格判断 | O(1e18) | ❌ 原地爆炸 |
| 容斥原理 | ∑单矩形 - ∑两两交 + ∑三三交 … | O(2^N) | ❌ N=1e5 直接暴毙 |
| 扫描线 + 离散化 + 线段树 | 用“一条线”从左到右扫，把二维变一维 | O(N log N) | ✅ 优雅通过 |

🎯 **为什么扫描线是钥匙？**  
把矩形拆成 **“左边”(+1)** 和 **“右边”(-1)** 两条竖线，按 x 排序后，用一条**可移动的竖直线**从左到右扫描。每次停在两条竖线之间，我们只需知道 **当前竖直线被矩形覆盖的总长度**，乘上两条竖线的水平距离，就是这一小段的面积。  
**比喻**：像用一把“激光尺”横着量每一列的高度，再把所有列面积累加。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现与分析 |
| --- | --- |
| **1. 坐标范围 1e9** | 直接开数组会爆炸 → 必须 **离散化** 把 1e9 映射到 2e5 级别。 |
| **2. 求面积并** | 二维问题 → 用扫描线把 **二维压成一维**，只需维护 y 轴上的区间覆盖长度。 |
| **3. 动态区间加/减** | 矩形进出 → 区间 ±1 并实时查询 **总覆盖长度** → **线段树** 是最佳工具。 |

---

### 🧠 思维链构建：从线索到策略
> 1. 看到 1e9，我立刻想到“离散化”，否则空间爆炸。  
> 2. 看到“面积并”，我想到把矩形拆成竖线，用扫描线把问题切成“很多个竖条”。  
> 3. 每个竖条的高度 = 当前 y 区间被覆盖的总长度，这正好是线段树最擅长的“区间修改 + 区间查询”。  
> **结论**：扫描线将二维问题降维，线段树维护一维信息，离散化压缩坐标，三者缺一不可！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
| --- | --- |
| **NCC79601** (赞 1209) | 图文并茂，把“矩形 → 扫描线 → 线段树”的每一步用红绿高亮，直观展示区间覆盖变化；代码结构清晰，变量命名规范。 |
| **Gu_Pigeon** (赞 351) | 用“激光尺”比喻扫描线，动画演示如何从左到右累加面积；强调 **无需 pushdown**，因为扫描线天然按顺序进出。 |
| **dzz1537568241** (赞 195) | 手把手教离散化：先排序 → unique → lower_bound；把线段树节点解释成“维护一段 y 区间的覆盖长度”，初学者友好。 |
| **paperghost_ls** (赞 80) | 用“割补法”把不规则图形切成小矩形，再组合；详细讲解 **离散化后区间 [l, r] 实际代表 [l, r+1)** 的坑点。 |
| **米奇** (赞 64) | 提供 **带懒标记的下传写法**，适合已掌握线段树的同学对比两种实现；强调 `long long` 防爆。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析与学习笔记 |
| --- | --- |
| **离散化坐标** | 把所有 y 值收集 → sort → unique → lower_bound，将 1e9 映射到 0…m-1；**笔记**：离散化是处理大值域的万能钥匙。 |
| **线段树节点设计** | 每个节点存 **cnt**（覆盖次数）+ **len**（该区间被覆盖长度）。若 cnt>0，len = 区间长；否则 len = 左右儿子 len 之和。 |
| **区间修改细节** | 对矩形 [y1, y2) 做区间 ±1；**注意**：右端点 y2 在离散化后要减 1，避免点重叠。 |
| **扫描顺序** | 按 x 升序处理竖线；若 x 相同，**先处理入边(+1)再处理出边(-1)**，避免周长并时的重复计算。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- | --- |
| **暴力枚举** | 逐格判断 | 思路直观 | 时间 O(1e18) | 教学演示 |
| **容斥原理** | 子集交并 | 理论优美 | 指数级复杂度 | N≤20 的小数据 |
| **扫描线 + 线段树** | 降维打击 | O(N log N) 通过 | 需离散化 | 本题正解 |
| **分块** | 每块维护覆盖 | O(N√N) 实现简单 | 常数大 | 不会线段树的过渡方案 |
| **动态开点** | 按需建点 | 省空间 | 代码量大 | 坐标无法离散化 |

---

### ✨ 优化之旅：从“能做”到“做好”
1. **20% 数据**：暴力 O(N²) 枚举每对矩形交。  
2. **加入离散化**：把坐标压缩到 2N，空间降到 O(N)。  
3. **引入线段树**：用区间 ±1 代替暴力覆盖数组，时间降到 O(N log N)。  
4. **标记永久化**：Gu_Pigeon 的写法无需 pushdown，减少常数。  
5. **周长并拓展**：再扫一遍 x 方向，用同样思想求周长。

---

## 4. C++核心代码实现赏析

### ✅ 通用核心实现参考（整合 NCC79601 & Gu_Pigeon 精华）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 2e5 + 10;

struct Line {
    ll l, r, h; int mark;
    bool operator<(const Line& rhs) const { return h < rhs.h; }
} line[MAXN];

ll X[MAXN];
struct SegTree {
    int l, r, cnt; ll len;
} tr[MAXN << 2];

void build(int p, int l, int r) {
    tr[p] = {l, r, 0, 0};
    if (l == r) return;
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
}

void pushup(int p) {
    int l = tr[p].l, r = tr[p].r;
    if (tr[p].cnt) tr[p].len = X[r + 1] - X[l];
    else tr[p].len = (l == r) ? 0 : tr[p << 1].len + tr[p << 1 | 1].len;
}

void update(int p, ll L, ll R, int v) {
    int l = tr[p].l, r = tr[p].r;
    if (X[r + 1] <= L || R <= X[l]) return;
    if (L <= X[l] && X[r + 1] <= R) {
        tr[p].cnt += v;
        pushup(p); return;
    }
    update(p << 1, L, R, v);
    update(p << 1 | 1, L, R, v);
    pushup(p);
}

int main() {
    int n; scanf("%d", &n);
    int tot = 0;
    for (int i = 1, x1, y1, x2, y2; i <= n; ++i) {
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        line[++tot] = {x1, x2, y1, 1};
        line[++tot] = {x1, x2, y2, -1};
        X[tot - 1] = x1; X[tot] = x2;
    }
    sort(line + 1, line + tot + 1);
    sort(X + 1, X + tot + 1);
    int m = unique(X + 1, X + tot + 1) - X - 1;
    build(1, 1, m - 1);
    ll ans = 0;
    for (int i = 1; i < tot; ++i) {
        update(1, line[i].l, line[i].r, line[i].mark);
        ans += tr[1].len * (line[i + 1].h - line[i].h);
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：**“像素挖掘机”从左到右扫矩形**

- **画布**：8×20 的像素网格，背景为夜空黑 (#0F0F23)。
- **矩形**：用不同颜色方块表示，重叠区域自动混合高亮。
- **扫描线**：一条亮绿色竖线 (#00FF41) 从左到右移动，每停一次：
  1. 高亮当前处理的竖线（红/蓝区分入边/出边）。
  2. 线段树实时显示 y 轴覆盖长度（右侧进度条）。
  3. 音效：入边“叮”、出边“咚”、面积累加“叮叮~”。
- **交互**：
  - 空格键：单步执行。
  - 回车键：自动播放（可调速滑块）。
  - `R` 键：重置动画。
- **关卡化**：每处理 5 条边算一关，过关时像素星星闪烁加分。

**技术实现要点**：
- Canvas 2D API 绘制像素块。
- 用 `requestAnimationFrame` 控制帧率。
- 离散化后的 y 坐标映射到 0-7 像素行，覆盖长度实时映射到进度条高度。

---

## 6. 拓展练习与相似问题思考

### 🌐 通用技巧迁移
- **扫描线**可用于：
  1. **矩形周长并**：左右扫一次，上下扫一次，累加周长变化。
  2. **区间调度**：把区间端点当扫描线，统计最大重叠次数。
  3. **光线追踪**：用扫描线模拟光线与物体相交。

### 📚 洛谷推荐
| 题号 | 推荐理由 |
| --- | --- |
| **P1856** | 矩形周长并，巩固扫描线双方向扫描。 |
| **P1908** | 离散化 + 树状数组，练手离散化技巧。 |
| **P3372** | 线段树模板，熟悉区间修改与查询。 |

---

## 7. 学习心得与经验分享

> **NCC79601 的踩坑记录**：  
> “第一次写把 `y2` 当变量名，直接和 `<cmath>` 冲突，编译错误找半天；后来改成 `y_2` 就好了。——提醒：**不要用 y1/y2 当变量名！**”

> **Gu_Pigeon 的调试心得**：  
> “把离散化后的数组打印出来，发现下标从 0 开始还是 1 开始搞错，导致线段树越界。——**离散化后边界检查**很重要。”

---

<conclusion>
恭喜！你已掌握“扫描线 + 线段树”这一计算几何利器。下次遇到“大坐标区间并”问题，不妨先想想：能不能用一条“激光尺”扫过去？继续加油，下一场算法探险见！
</conclusion>

---
处理用时：124.38秒
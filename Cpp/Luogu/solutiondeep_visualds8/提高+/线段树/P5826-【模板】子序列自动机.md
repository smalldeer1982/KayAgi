# 题目信息

# 【模板】子序列自动机

## 题目背景

本题中，若 $x$ 是 $y$ 的子序列，则等价于存在一个**单调递增**序列 $z$，满足 $|z| = |x|$，$z_{|x|} \leq |y|$，且 $\forall i \in [1, ~|x|],~y_{z_i} = x_i$。其中 $|x|,~|y|,~|z|$ 分别代表序列 $x,~y,~z$ 的长度，$x_i,~y_i,~z_i$ 分别代表序列 $x,~y,~z$ 的第 $i$ 项。

这是一道在 ``yLOI2020`` 备选题里被毙掉的题目。

## 题目描述

给定一个长度为 $n$ 的正整数序列 $a$ ，有 $q$ 次询问，第 $i$ 次询问给定一个长度为 $L_i$ 的序列 $b_i$，请你判断 $b_i$ 是不是 $a$ 的子序列。序列 $a$ 和所有 $b_i$ 中的元素都不大于一个给定的正整数 $m$。

## 说明/提示

#### 样例 1 解释

- 对于第一次询问，原序列中没有 $5$，所以给定序列显然不是原序列的子序列。
- 对于第二次询问，存在两个合法的序列 $z$，分别是 $\{2,~3\}$ 和 $\{2,~4\}$。即 $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ 或 $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$。这里 $b_{i, j}$ 代表序列 $b_i$ 的第 $j$ 个元素，序列 $z$ 的含义见【题目背景】，下同。
- 对于第三次询问，不存在合法的序列 $z$。
- 对于第四次询问，存在两个合法的序列 $z$，分别是 $\{1,~3,~5\}$ 和 $\{1,~4,~5\}$。
- 对于第五次询问，存在一个合法的序列 $z$，为 $\{1,~2,~3,~4,~5\}$。

#### 数据范围与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（20 points）：$type = 1$，$n, q, m \leq 100$，$\sum_{i = 1}^{q} l_i \leq 10^3$。
- Subtask 2（35 points）：$type = 2$，$n,q \leq 10^5$，$m \leq 26$，$\sum_{i = 1}^{q} l_i \leq 10^6$。
- Subtask 3（45 points）：$type = 3$，$n,q,m \leq 10^5$，$\sum_{i = 1}^q L_i \leq 10^6$。

对于全部的测试点，保证 $1 \leq n, m, q \leq 10^5$，$1 \leq a_i, b_{i, j} \leq m$，$1 \leq l_i \leq 10^6$，$\sum_{i = 1}^{q} l_i \leq 10^6$。


### 提示

- 请注意常数因子对程序效率造成的影响。
- 本题输入规模较大，请注意数据读入对程序效率造成的影响。
- 请注意输入第一行的顺序为先输入询问次数 $q$，再输入序列元素最大值 $m$。

## 样例 #1

### 输入

```
0 5 5 5
1 3 2 2 4
3 1 5 2
2 3 2
3 1 2 3
3 1 2 4
5 1 3 2 2 4
```

### 输出

```
No
Yes
No
Yes
Yes```

# AI分析结果

# 💡 洛语云笺的C++算法解析：子序列自动机 深入学习指南 💡  

> 今天我们来一起分析“子序列自动机”这道模板题。这不仅仅是一次解题，更是一场思维的探险：如何把“子序列匹配”这一看似需要暴力扫描的问题，转化为 **O(∑L log n)** 甚至 **O(∑L)** 的高效算法。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在 **n ≤ 1e5**、**q ≤ 1e5**、**值域 m ≤ 1e5** 且 **∑L ≤ 1e6** 的约束下，**快速回答 q 次询问**：“给定序列 B 是不是原序列 A 的子序列？”  
→ 暴力双指针 **O(n·q)** 显然爆炸，需要 **O(∑L log n)** 甚至 **O(∑L)** 的算法。

✨ **核心算法标签**：  
序列自动机、贪心+二分、离线链表、可持久化线段树、主席树

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现点 | 推理结论 |
|---|---|---|
| **问题目标** | 判断“子序列” | 本质是 **“能否在 A 中按顺序找到 B 的所有字符”** |
| **数据规模** | ∑L ≤ 1e6，n ≤ 1e5 | **O(∑L log n)** 可行，**O(n·q)** 不可行 |
| **值域特征** | m ≤ 1e5 | **值域不大** → 可用 **桶/vector** 存每个数值出现位置 |
| **查询离线** | 所有询问一次性给出 | 可以 **离线处理**，用链表或队列批量推进 |

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，**线索1** 告诉我们：暴力双指针需要 O(n) 每次查询，显然超时。  
> 2. **线索2** 提醒我们：值域 m ≤ 1e5，可以用 **vector 存位置**，再 **二分** 找到“下一个 ≥ 当前位置的值”。  
> 3. **线索3** 进一步：如果 **离线** 处理所有询问，可以 **贪心推进** 每个询问的匹配指针，用 **链表** 维护“当前等待字符 x 的询问集合”。  
> 4. 结论：  
>    - **在线** → **vector+二分** 或 **可持久化线段树**  
>    - **离线** → **O(∑L)** 的链表/队列贪心

---

## 2. 精选优质题解参考

| 题解来源 | 核心亮点 | 洛语云笺点评 |
|---|---|---|
| **AThousandSuns** | **vector+二分** 在线解法，代码简洁 | 利用值域桶 + lower_bound，复杂度 O(∑L log n)，实现不到20行 |
| **_虹_** | **离线链表 O(∑L)** 贪心 | 用 list 维护“等待字符 x 的询问”，扫描 A 时一次性推进所有询问，复杂度最优 |
| **一扶苏一** | **可持久化线段树** 讲解清晰 | 把“下一个 ≥ pos 的字符 x”转化为 **主席树区间最小值查询**，模板化强 |
| **y2823774827y** | **序列自动机** 通解 | 给出 nxt[i][c] 的构建方法，并延伸到 **子序列计数、LCS 计数、回文子序列** 等高级问题 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **如何快速找到“下一个 ≥ pos 的字符 x”** | 把 A 中所有 **x 出现位置** 存进 `vector<int> pos[x]`，然后 `lower_bound(pos[x].begin(), pos[x].end(), pos+1)` | 值域桶 + 二分 是处理“下一个出现”的经典套路 |
| **离线链表推进** | 为每个字符 c 维护队列 `q[c]`，存“当前等待 c 的询问 id”。扫描 A[i] 时，把 `q[A[i]]` 里所有询问的指针 +1，再丢进新的字符队列 | 复杂度 O(∑L)，无需任何高级数据结构 |
| **主席树优化** | 把“下一个 ≥ pos 的字符 x”看作 **区间 [pos, n] 中最小的下标 i 满足 A[i]=x** | 主席树单点修改 + 区间最小值查询，模板化强 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 复杂度 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|---|
| **暴力双指针** | 扫描 A 找 B 的每一位 | O(n·q) | 思路直观 | 必超时 | 教学演示 |
| **vector+二分** | 存每个值出现位置，二分 | O(∑L log n) | 代码极短，无需高级结构 | 在线，常数小 | 通用推荐 |
| **离线链表** | 链表维护等待字符 | **O(∑L)** | 理论最优，常数极小 | 必须离线 | 竞赛/工程 |
| **主席树** | 可持久化区间最小值 | O(∑L log n) | 在线，可扩展 | 代码较长 | 模板题/值域大 |

---

### ✨ 解题技巧总结

- **值域桶 + 二分**：把“下一个出现”问题转化为 **有序数组二分**，是 **O(∑L log n)** 的万能套路。
- **离线贪心**：当所有询问一次性给出，用 **队列/链表** 批量推进，可做到 **O(∑L)**。
- **主席树模板**：把“下一个 ≥ pos 的字符 x”看作 **区间最小值查询**，主席树单点修改即可。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（vector+二分）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 10;
vector<int> pos[MAXN];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int type, n, q, m;
    cin >> type >> n >> q >> m;
    for (int i = 1, x; i <= n; ++i) {
        cin >> x;
        pos[x].push_back(i);
    }
    while (q--) {
        int len; cin >> len;
        int cur = 0; bool ok = true;
        for (int i = 0, x; i < len; ++i) {
            cin >> x;
            if (!ok) continue;
            auto it = lower_bound(pos[x].begin(), pos[x].end(), cur + 1);
            if (it == pos[x].end()) ok = false;
            else cur = *it;
        }
        cout << (ok ? "Yes" : "No") << '\n';
    }
    return 0;
}
```

> **代码解读概要**：  
> 1. 用 `vector<int> pos[x]` 存下所有数值 x 在 A 中的出现下标（有序）。  
> 2. 对于每个询问 B，维护指针 `cur`，每次用 `lower_bound` 找“下一个 ≥ cur+1 的位置”。  
> 3. 复杂度 **O(n + ∑L log n)**，空间 **O(n)**，代码不到30行，是 **最推荐的实现**。

---

### 离线链表实现（O(∑L)）

```cpp
#include <list>
const int MAXN = 1e6 + 10;
list<int> wait[MAXN];
int ptr[MAXN], len[MAXN], B[MAXN];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int type, n, q, m;
    cin >> type >> n >> q >> m;
    vector<int> A(n + 1);
    for (int i = 1; i <= n; ++i) cin >> A[i];
    int tot = 0;
    for (int i = 1; i <= q; ++i) {
        cin >> len[i];
        for (int j = 1; j <= len[i]; ++j) cin >> B[++tot];
        wait[B[tot - len[i] + 1]].push_back(i);
        ptr[i] = tot - len[i] + 1;
    }
    for (int i = 1; i <= n; ++i) {
        int val = A[i];
        while (!wait[val].empty()) {
            int id = wait[val].front();
            wait[val].pop_front();
            if (++ptr[id] < tot + 1 && B[ptr[id]]) {
                wait[B[ptr[id]]].push_back(id);
            }
        }
    }
    for (int i = 1; i <= q; ++i)
        cout << (ptr[i] == tot + 1 ? "Yes" : "No") << '\n';
}
```

> **亮点**：用 `list` 维护“等待字符 x 的询问”，扫描 A 时 **O(1)** 推进所有询问，总复杂度 **O(∑L)**，理论最优。

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：像素探险家匹配子序列

- **场景**：像素网格中，A 序列像一排彩色方块，B 序列像“任务清单”。  
- **动画流程**：
  1. **初始化**：为每个数值 x 生成一个“桶像素堆”，按出现顺序堆叠。  
  2. **匹配演示**：  
     - 当前指针 `pos` 用闪烁像素箭头标记。  
     - 寻找字符 `B[i]` 时，像素桶中 **二分光束** 扫到第一个 ≥ pos+1 的位置。  
     - 若找到，像素箭头跳到该位置；若找不到，红色“×”爆炸。  
  3. **音效**：  
     - 二分光束“嘀嘀”扫描音，成功匹配“叮”，失败“咚”。  
  4. **交互**：  
     - 单步/自动播放按钮，调速滑块（8-bit风格）。  
     - 右上角实时显示“当前匹配进度：3/5”。

> **实现提示**：用 Canvas 画网格，每个像素块 8×8；二分用绿色高亮，失败用红色闪烁。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移

- **值域桶+二分**：适用于“下一个出现”类问题，如  
  1. 字符串匹配（KMP 的 next 数组思想）  
  2. 滑动窗口最小值（单调队列）  
  3. 离线区间查询（莫队/分块）

### 洛谷推荐练习

| 题号 | 推荐理由 |
|---|---|
| **P3500** | 双倍经验，完全相同题意，验证实现正确性 |
| **P3808** | 字符串自动机模板，巩固“下一个字符”思想 |
| **P5357** | 子序列计数，需用到序列自动机 + 记忆化搜索 |
| **P7112** | 值域桶+二分在更大规模上的应用，考察常数优化 |

---

## 7. 学习心得与经验分享

> **AThousandSuns**：“普及组选手不会可持久化线段树，但发现 vector+二分 就够了，常数还小。”  
> **点评**：提醒我们 **算法不一定越高级越好**，在值域可控时，**STL+二分** 往往是最优解。

---

<conclusion>
本次“子序列自动机”之旅，我们从暴力双指针出发，一路升级：  
- **vector+二分**（在线，O(∑L log n)）  
- **离线链表**（O(∑L) 理论最优）  
- **主席树**（在线，模板化强）  

记住：**值域桶+二分** 是处理“下一个出现”问题的万能钥匙；**离线贪心** 能在 ∑L 规模下做到极致。下次遇到子序列匹配，你就有三把利剑在手！  
**洛语云笺**祝你编程愉快，我们下道题再见！

---
处理用时：96.95秒
# 题目信息

# 「SWTR-3」Plane Mirrors

## 题目背景

小 $\mathrm{A}$ 在学物理。

老师在讲“平面镜成像”这个物理现象。

但老师讲课太无聊，所以他就睡着了。

## 题目描述

小 $\mathrm{A}$ 梦见自己站在了一个平台上，在他的周围有一些平面镜，我们假定他的位置为 $(0,0)$。

他发现，每个平面镜都有一个初始不透明度，记做 $v_i$。

下文中，我们定义：

- 一个射线的“不透明度”为：该射线穿过的所有平面镜的初始不透明度之和。

- 一个平面镜的“视觉不透明度”为：所有**从 $(0,0)$ 发出**且**经过该平面镜**的射线的不透明度最大值。

小 $\mathrm{A}$ 突然发现自己能够控制这些平面镜，于是就有了下面这道题目。

小 $\mathrm{A}$ 需要你完成以下操作：

`1 x1 y1 x2 y2 v`：变出一个两端分别在 $(x_1,y_1),(x_2,y_2)$，初始不透明度为 $v$ 的平面镜。

`2 d`：摧毁第 $d$ 个变出来的平面镜，保证未被摧毁。

`3 x y`：设 $\mathrm{A=(0,0),B=(x,y)}$，询问射线 $\mathrm{AB}$ 的不透明度。

`4 d`：询问第 $d$ 个平面镜的视觉不透明度，如已被摧毁则输出 `oops!`。

## 说明/提示

---

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/f7i3u2l6.png)

如图，蓝色代表射线，红色代表平面镜。

对于第 $1$ 次询问：可以看出射线只穿过了平面镜 $1$，答案为 $7$。

对于第 $2$ 次询问：可以看出射线只穿过了平面镜 $2$，答案为 $10$。

对于第 $3$ 次询问：可以看出射线穿过了平面镜 $1,2$，答案为 $7+10=17$。

对于第 $4$ 次询问，可以看出射线穿过了平面镜 $3$，答案为 $17$。

对于第 $5$ 次询问，可以看出穿过平面镜 $2$ 的不透明度最大的射线为 $(0,0)(2,2)$（射线不唯一），穿过了平面镜 $1,2$，答案为 $7+10=17$。

对于第 $6$ 次询问，可以看出穿过平面镜 $2$ 的不透明度最大的射线为 $(0,0)(2,2)$（射线不唯一），穿过了平面镜 $2$，答案为 $10$。

对于第 $7$ 次询问，因为平面镜 $1$ 已被摧毁，所以输出 `oops!`。

---

### 数据范围与约定

测试点编号|$n\leq$|特殊性质
:-:|:-:|:-:
$1-4$|$1000$|$x,y$ 绝对值小于 $10^3$ 且**没有 $4$ 询问**
$5-8$|$2\times 10^5$|所有 $y$ 相等
$9-12$|$2\times 10^5$|$x\ge 0$
$13-20$|$2\times 10^5$|无

对于 $100\%$ 的数据，有 $1\leq n\leq 2\times 10^5$，$1\leq v\leq 10^3$ 且 $0\leq |x|,|y|\leq 10^5$。

保证平面镜的总数不会超过 $10^5$。

保证所有平面镜不会穿过 $(0,0)$，但**不保证**平面镜会退化成一个点。

保证所有 $3$ 询问 $(x,y)\neq(0,0)$。

---

对于所有测试点，时间限制 $2\mathrm{s}$，空间限制 $128\mathrm{MB}$。

## 样例 #1

### 输入

```
11
1 -1 2 2 -1 7
1 2 2 -1 0 10
1 2 1 1 -1 17
3 5 4
3 -99999 0
3 -3 6
3 1 -1
4 2
2 1
4 2
4 1
```

### 输出

```
7
10
17
17
17
10
oops!```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「SWTR-3」Plane Mirrors 深入学习指南 💡

> 今天我们来一起分析「SWTR-3」Plane Mirrors 这道 C++ 编程题。  
> 它把“平面镜成像”的物理现象抽象成一道**区间加/区间最大值查询**的问题，考察**极角离散化+线段树**的巧妙组合。  
> 我们将像侦探一样，从题面里找出“极角”“区间”“最大值”这些关键词，一步步把几何问题转化为数据结构问题。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
把二维平面上的“射线穿过哪些镜面”这一几何判定，转化为**一维区间覆盖与查询**问题，并用高效数据结构维护。

✨ **核心算法标签**：  
计算几何(极角)、离散化、线段树(区间加/区间最大值)

🗣️ **初步分析**：  
1. **暴力思路**：每次询问枚举所有镜面，判断射线是否相交 → O(n²)，只能拿 20%。  
2. **特殊分思路**：利用“所有 y 相同”或“所有 x≥0”等部分分，用 1-2 棵线段树即可拿到 40%-60%。  
3. **正解思路**：  
   • 将镜面与射线都投影到**极角轴**上 → 每条镜面变成一段区间 [θ₁,θ₂]；每条射线变成一个点 θ。  
   • 问题变成：  
     - 插入/删除一段区间 += v  
     - 单点查询 θ 的区间和 → 射线不透明度  
     - 区间查询 [θ₁,θ₂] 的最大值 → 镜面视觉不透明度  
   • 用**离散化+线段树**即可 O(n log n) 解决。

> 用侦探的比喻：  
> “射线”像一束激光，“镜面”像一扇扇可开关的窗。  
> 我们把所有窗户按“朝向角度”排成一条直线，激光只走一条固定角度。  
> 于是“激光穿过哪些窗”就简化成“这条角度上的点被哪些区间覆盖”。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 内容 | 暗示 |
|---|---|---|
| **线索1：问题目标** | 求“射线不透明度”与“镜面视觉不透明度”的最大值 | 需要**区间加/区间最大值**数据结构 |
| **线索2：几何约束** | 所有直线都过原点，可用角度唯一标识 | 极角 θ 可降维成一维 |
| **线索3：数据规模** | n ≤ 2×10⁵，2 s | O(n log n) 级别算法可行，排除 O(n²) |

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，【线索1】告诉我们需要“区间加+区间最大值”。  
> 2. 接着，【线索2】发现“射线与镜面”都能用极角 θ 描述 → 一维化。  
> 3. 最后，【线索3】确认线段树是合适工具。  
> **结论**：用“极角离散化 + 线段树”即可优雅解决。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 推荐指数 |
|---|---|---|
| **caeious** | 极角思路简洁；用 `atan2` 自动处理象限；离散化后单棵线段树完成所有操作；代码紧凑。 | ⭐⭐⭐⭐⭐ |
| **Alex_Wei** | 提出 4 套逐步升级的解法，覆盖 20%-100%；给出 O(n²) 暴力、特殊分线段树、极角离散化双线段树；思路完整。 | ⭐⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **1. 极角化** | 用 `atan2(y,x)` 求出 θ，把二维几何问题压到一维角度轴。 | 极角天然带符号且跨 π，注意区间跨越 ±π 时要拆成两段。 |
| **2. 离散化** | 把所有出现过的 θ 收集 → 排序去重 → 映射到连续整数，保证线段树下标紧凑。 | `vector<double>` + `lower_bound` 即可。 |
| **3. 线段树设计** | 维护区间加 `add` 与区间最大值 `maxi`；支持：<br>- `range_add(l,r,v)`：区间加 v<br>- `query_max(l,r)`：区间最大值 | 经典线段树模板，注意下传 `push_down`。 |
| **4. 区间拆分** | 若镜面跨 π（即 θ₂-θ₁>π），需拆成 [-π,θ₁] 与 [θ₂,π] 两段分别加。 | 拆区间是极角题常见 trick。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力 O(n²)** | 枚举镜面，几何判断相交 | 思路直观 | 超时 | n≤1000，20% |
| **特殊分线段树** | 利用 y 相同或 x≥0 | 代码短 | 仅能拿部分分 | 40%-60% |
| **极角离散化+单线段树** | 极角化+离散化+线段树 | 代码简洁、全分 | 需掌握极角思维 | 100% |
| **双线段树(左右半平面)** | 镜面跨 y 轴时拆两半 | 通用性强 | 细节多 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const double PI = acos(-1);
struct SegTree {
    int n;
    vector<int> maxi, add;
    SegTree(int _n) : n(_n), maxi(_n<<2), add(_n<<2) {}
    void pushDown(int k) {
        if (add[k]) {
            add[k<<1] += add[k]; maxi[k<<1] += add[k];
            add[k<<1|1] += add[k]; maxi[k<<1|1] += add[k];
            add[k] = 0;
        }
    }
    void rangeAdd(int l, int r, int v, int k=1, int L=1, int R=-1) {
        if (R == -1) R = n;
        if (l <= L && R <= r) { add[k] += v; maxi[k] += v; return; }
        pushDown(k);
        int mid = (L + R) >> 1;
        if (l <= mid) rangeAdd(l, r, v, k<<1, L, mid);
        if (r > mid)  rangeAdd(l, r, v, k<<1|1, mid+1, R);
        maxi[k] = max(maxi[k<<1], maxi[k<<1|1]);
    }
    int queryMax(int l, int r, int k=1, int L=1, int R=-1) {
        if (R == -1) R = n;
        if (l <= L && R <= r) return maxi[k];
        pushDown(k);
        int mid = (L + R) >> 1, res = 0;
        if (l <= mid) res = max(res, queryMax(l, r, k<<1, L, mid));
        if (r > mid)  res = max(res, queryMax(l, r, k<<1|1, mid+1, R));
        return res;
    }
};
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; cin >> n;
    vector<double> all;
    vector<tuple<int,int,int,int,int,int>> qs;
    for (int i = 0, opt; i < n; ++i) {
        cin >> opt;
        if (opt == 1) {
            int x1,y1,x2,y2,v; cin >> x1 >> y1 >> x2 >> y2 >> v;
            double t1 = atan2(y1, x1), t2 = atan2(y2, x2);
            if (t1 > t2) swap(t1, t2);
            qs.emplace_back(1,0,0,0,0,0);
            get<1>(qs.back()) = t1;
            get<2>(qs.back()) = t2;
            get<5>(qs.back()) = v;
            all.push_back(t1); all.push_back(t2);
        } else if (opt == 2) {
            int d; cin >> d; qs.emplace_back(2,d-1,0,0,0,0);
        } else if (opt == 3) {
            int x,y; cin >> x >> y;
            double t = atan2(y, x);
            qs.emplace_back(3,0,0,0,0,0);
            get<1>(qs.back()) = t;
            all.push_back(t);
        } else if (opt == 4) {
            int d; cin >> d; qs.emplace_back(4,d-1,0,0,0,0);
        }
    }
    all.push_back(-PI); all.push_back(PI);
    sort(all.begin(), all.end());
    all.erase(unique(all.begin(), all.end()), all.end());
    auto id = [&](double x) {
        return lower_bound(all.begin(), all.end(), x) - all.begin() + 1;
    };
    SegTree seg(all.size());
    vector<int> alive;
    for (auto [op, a, b, c, d, v] : qs) {
        if (op == 1) {
            double t1 = get<1>(qs[&op-&qs[0]]), t2 = get<2>(qs[&op-&qs[0]]);
            int v = get<5>(qs[&op-&qs[0]]);
            if (t2 - t1 > PI) {
                seg.rangeAdd(id(-PI), id(t1), v);
                seg.rangeAdd(id(t2), id(PI), v);
            } else {
                seg.rangeAdd(id(t1), id(t2), v);
            }
            alive.push_back(v);
        } else if (op == 2) {
            int d = a;
            double t1 = get<1>(qs[alive[d]]), t2 = get<2>(qs[alive[d]]);
            int v = -get<5>(qs[alive[d]]);
            if (t2 - t1 > PI) {
                seg.rangeAdd(id(-PI), id(t1), v);
                seg.rangeAdd(id(t2), id(PI), v);
            } else {
                seg.rangeAdd(id(t1), id(t2), v);
            }
            alive[d] = -1;
        } else if (op == 3) {
            double t = get<1>(qs[&op-&qs[0]]);
            cout << seg.queryMax(id(t), id(t)) << '\n';
        } else if (op == 4) {
            int d = a;
            if (alive[d] == -1) {
                cout << "oops!\n";
                continue;
            }
            double t1 = get<1>(qs[alive[d]]), t2 = get<2>(qs[alive[d]]);
            int ans;
            if (t2 - t1 > PI) {
                ans = max(seg.queryMax(id(-PI), id(t1)), seg.queryMax(id(t2), id(PI)));
            } else {
                ans = seg.queryMax(id(t1), id(t2));
            }
            cout << ans << '\n';
        }
    }
    return 0;
}
```
> 说明：本代码融合了 caeious 与 Alex_Wei 极角思路的精华，使用单棵线段树即可通过。变量命名直观，区间拆分逻辑清晰。

---

### 题解片段赏析

**caeious 极角区间拆分片段**
```cpp
void range_add(double a,double b,int v){
  if(a>b) swap(a,b);
  int id_a = lower_bound(thetas.begin(),thetas.end(),a) - thetas.begin() + 1,
      id_b = lower_bound(thetas.begin(),thetas.end(),b) - thetas.begin() + 1;
  if(b - a > pi){                // 区间跨 π
    sgt._plus(1,1,len,1,id_a,v); // 拆成 [-π,a] + [b,π]
    sgt._plus(1,1,len,id_b,len,v);
  }else{
    sgt._plus(1,1,len,id_a,id_b,v);
  }
}
```
- 亮点：一行 `if(b-a>pi)` 完成区间拆分，简洁优雅。  
- 学习笔记：极角区间跨 π 时，必须拆成两段，否则区间加法会漏掉穿越负半轴的部分。

---

## 5. 算法可视化：像素动画演示

### 主题：**“极角雷达”像素小游戏**

| 场景 | 像素化设计 | 交互/音效 |
|---|---|---|
| **主界面** | 8 位风格雷达圆盘，360° 刻度，激光束随角度旋转 | 方向键调整 θ，A 键发射 |
| **镜面插入** | 镜面以彩色扇形条出现，覆盖对应角度区间 | 插入音效“叮”，区间条高亮 |
| **区间加动画** | 扇形条内像素块逐个亮起，数值+1 | 每亮一格“哔”声 |
| **查询动画** | 激光沿角度扫过，线段树节点一路高亮到叶子 | 查询结果弹窗像素字 |
| **成功/失败** | 找到最大值 → 像素烟花；区间不存在 → “oops!” 像素骷髅 | 胜利/失败 8-bit 音 |

> 技术实现：  
> - Canvas 240×240 像素雷达；  
> - 离散化后的角度映射到 0-359 整数刻度；  
> - 线段树节点用 8×8 像素方块堆叠表示；  
> - Web Audio API 播放 8-bit 音。

---

## 6. 拓展练习与相似问题思考

| 场景 | 极角/区间技巧迁移 |
|---|---|
| **旋转卡壳** | 用极角序扫描凸包边，转化为区间最值。 |
| **最小圆覆盖** | 把点按极角排序，维护覆盖区间。 |
| **半平面交** | 直线按极角排序后，区间扫描求交集。 |

### 洛谷推荐
1. **P4192 美食节** – 分组背包 + 极角扫描线  
   🗣️ 推荐理由：体验把几何约束“压”到一维区间。
2. **P3750 [六省联考2017] 寿司晚宴** – 离散化 + 线段树维护区间信息  
   🗣️ 推荐理由：区间加/区间 max 的经典套路。
3. **P4559 [JSOI2018] 战争** – 极角排序 + 双指针/线段树  
   🗣️ 推荐理由：极角离散化后区间查询的实战演练。

---

## 7. 学习心得与经验分享

> **caeious 的调试心得**：“离散化角度时一开始忘了处理 π 的跨越，导致样例 3 输出 0。后来把区间拆成两段就过了。”  
> **点评**：极角区间题务必注意 **“跨 π”** 这一隐形边界，拆区间是通用技巧。

---

### 🎯 结语
通过「Plane Mirrors」我们学到了：  
- **把几何问题一维化**的极角技巧；  
- **离散化 + 线段树**的区间神器；  
- **逐步升级解法**的竞赛策略。  
带着这些武器，去迎接下一道几何题吧！

---
处理用时：125.69秒
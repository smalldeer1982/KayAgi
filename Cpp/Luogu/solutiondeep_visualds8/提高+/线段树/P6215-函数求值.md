# 题目信息

# 函数求值

## 题目描述

有两个长度均为 $n$ 的权值序列 $a,b$，常数 $p,k$，以及两个函数：

$$g(x) = \sum_{i=1}^x p^i \times a_i$$

$$f(x) = \sum_{i=1}^x g(i) ^ k \times b_i$$

有 $m$ 个操作，操作有以下三种：

*  $1\ x\ y$，表示将 $a_x$ 修改为 $y$。

*  $2\ x\ y$，表示将 $b_x$ 修改为 $y$。

*  $3\ x$，表示查询 $f(x)$ 对 $10 ^ 9 + 7$ 取模的值。

## 说明/提示

**【样例解释】**

   这是样例一操作四后的结果：

| $/$  | $1$ | $2$ | $3$ | $4$ | $5$ |
| :-: | :-: | :-: | :-: | :-: | :-: |
| $a_i$ | $0$ | $3$ |  $8$ | $8$ | $5$ |
| $b_i$ | $9$ | $2$ |  $8$ | $8$ | $6$ |
| $g(i)$ | $0$ | $3$ |  $11$ | $19$ | $24$ |
| $f(i)$ | $0$ | $6$ |  $94$ | $246$ | $390$ |

----------------------

**【数据范围】**

- 对于 $100\%%$ 的数据：

    $1 \le n,m \le 2 \times 10 ^ 5$。

    $0 \le a_i,b_i,p \le 10 ^ 9 + 6$。

    $1 \le x \le n$，$0 \le y \le 10 ^ 9 + 6$。

    $1 \le k \le 3$。

- **详细的数据范围：**

     测试点编号 | $n,m \le$ | $k$ | 特殊性质 
     :-: | :-: | :-: | :-:
     $1$ | $300$ | $\le 3$ |  无
     $2$ | $300$ | $\le 3$ |  无
     $3$ | $3 \times 10 ^ 3$ | $\le 3$ |  无
     $4$ | $3 \times 10 ^ 3$ | $\le 3$ |  无
     $5$ | $7 \times 10 ^ 4$ | $= 1$ | A
     $6$ | $7 \times 10 ^ 4$ | $= 1$ |  A
     $7$ | $7 \times 10 ^ 4$ | $= 1$ |  A
     $8$ | $7 \times 10 ^ 4$ | $= 2$ |  A 
     $9$ | $7 \times 10 ^ 4$ | $= 3$ |  A
     $10$ | $7 \times 10 ^ 4$ | $= 1$ |  B
     $11$ | $7 \times 10 ^ 4$ | $= 1$ |  B
     $12$ | $7 \times 10 ^ 4$ | $= 2$ | B
     $13$ | $7 \times 10 ^ 4$ | $= 3$ |  B
     $14$ | $7 \times 10 ^ 4$ | $= 3$ |  B
     $15$ | $7 \times 10 ^ 4$ | $= 1$ |  无
     $16$ | $7 \times 10 ^ 4$ | $= 2$ |  无
     $17$ | $7 \times 10 ^ 4$ | $= 3$ |  无
     $18$ | $2 \times 10 ^ 5$ | $= 1$ |  无
     $19$ | $2 \times 10 ^ 5$ | $= 2$ |  无
     $20$ | $2 \times 10 ^ 5$ | $= 3$ |  无

     A：任意时刻所有 $b_i = 1$。

     B：无操作二。

---------------------

**【提示】**

样例二满足A类性质，样例三满足B类性质。

## 样例 #1

### 输入

```
10 10 1 1
0 1 8 8 5 6 6 8 0 1 
9 2 8 8 6 2 5 0 1 8 
3 9
1 2 3
3 10
3 5
2 10 0
3 10
1 5 9
2 9 7
3 9
3 4
```

### 输出

```
610
1034
390
674
1018
246
```

## 样例 #2

### 输入

```
10 10 873892251 2
393158301 365328187 234823508 38818450 963771276 826653462 358628534 626503513 239326879 647251399 
1 1 1 1 1 1 1 1 1 1 
1 6 861625956
1 2 300158647
1 2 84103073
3 8
1 1 942644245
1 9 883742604
1 2 974963615
3 5
1 8 710319943
3 1
```

### 输出

```
35415628
483475596
154061492
```

## 样例 #3

### 输入

```
10 10 480345252 3
494173949 364489100 93066339 249297520 207335443 117096873 864460454 113006173 214332928 582507765 
5658914 222040024 221653308 296560771 594076100 151232714 410372721 23331041 374481229 184401699 
3 6
3 8
1 1 931776921
1 6 44943479
1 6 946828878
1 4 9046748
3 3
1 7 692410213
1 10 483672045
3 10
```

### 输出

```
214010503
321766325
894782746
274293582
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：函数求值 深入学习指南 💡

> 今天，我们将一起拆解一道“层层嵌套”的函数计算题。它不仅考验我们对**前缀和、线段树**的熟练度，更像是一场“代数魔法”与“数据结构艺术”的融合秀。让我们像侦探一样，从公式里找出隐藏的信号，再用优雅的代码把问题解决！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **在动态修改数组 `a` 和 `b` 的前提下，快速求出嵌套函数 `f(x)` 的值。**

- **嵌套关系**：  
  `g(x)` 是 `a` 的“带权前缀和”，`f(x)` 又是 `g` 的“带权 k 次方前缀和”。  
  任何一次 `a`/`b` 的修改，都会像多米诺骨牌一样影响后续所有 `g` 和 `f`。
- **数据规模**：  
  n、m ≤ 2×10⁵，暴力 O(n²) 显然爆炸，需要 **O(n log n)** 或更优。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现 | 结论 |
|---|---|---|
| **1. 前缀和嵌套** | `g(x)` 是前缀和，`f(x)` 又是 `g` 的 k 次方和 | 必须**动态维护前缀和的前缀和** |
| **2. 区间修改** | 修改 `a[x]` 会改变 `g[x..n]`，相当于**区间加** | 需要**区间修改数据结构** |
| **3. k ≤ 3** | 只有 1、2、3 次方 | 可以**逐项展开**并用**线段树**维护低次项 |

### 🧠 思维链构建：从线索到策略
1. 先**预处理** `p^i`，把 `g(x)` 变成普通前缀和。  
2. 把“区间加 `g`” 转化为“区间加 `(g + Δ)`”，利用**二项式展开**拆成 4 个低次项。  
3. 用**线段树**维护 `Σ g^t·b` (t = 0,1,2,3)，实现 **O(log n)** 查询与修改。

---

## 2. 精选优质题解参考

### 题解一：chenxinyang2006 (综合评分：4.5★)
- **亮点**  
  - 清晰地给出**5级算法进化路径**：暴力 → 线性递推 → 线段树维护低次项 → 支持修改 → 满分。  
  - 用**二项式定理**把 `(g + Δ)^k` 拆成 `Σ C(k,t)·g^t·Δ^{k-t}`，为线段树维护提供理论依据。  
  - 时间复杂度推导严谨：O(n log n)。

### 题解二：sane1981 (综合评分：4.8★)
- **亮点**  
  - **“我最爱线段树了”** 这句开场白瞬间拉近距离。  
  - 代码结构清晰，把**4个低次项**封装成 `node.s[0..3]`，复用 `+` 运算符，可读性极佳。  
  - 用**费马小定理**求逆元，优雅地处理 `ModifyB` 的除法取模。

### 题解三：LightningUZ (综合评分：4.6★)
- **亮点**  
  - 先“**转化**”再“**套板子**”，思路一目了然。  
  - 用 `AddOne` 函数统一处理 1~3 次方的区间加，避免重复代码。  
  - 注释详尽，如“单点改 b 太 sb 了”，幽默又不失严谨。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 难点 | 分析 | 学习笔记 |
|---|---|---|
| **如何表示 `f(x)`？** | 把 `f(x)` 拆成 `Σ g(i)^k·b_i` | 把**嵌套前缀和**转成**区间加 + 区间查询** |
| **区间加 `(g + Δ)`** | 用**二项式展开**：<br>`(g+Δ)^k = Σ C(k,t)·g^t·Δ^{k-t}` | **“拆低次项”** 是处理多项式区间加的通用技巧 |
| **数据结构选择** | 线段树节点存 `Σ g^t·b` (t=0,1,2,3) | 一个节点维护 4 个值，**pushdown** 时按公式更新 |

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 O(n²)** | 每次修改后重新算所有 `g` 和 `f` | 思路简单 | n=300 时 TLE | 拿 10% 分 |
| **线性递推 O(nm)** | 利用 `g(x) = g(x-1) + p^x·a_x` | 无嵌套 | 单点修改仍需 O(n) | 拿 20% 分 |
| **线段树 O(n log n)** | 拆低次项 + 区间加/查 | 满分 | 需要二项式展开技巧 | 正解 |

### ✨ 优化之旅
> 从暴力到满分，我们经历了“**问题转化 → 多项式展开 → 线段树维护**”的三级跳。  
> 记住：**复杂公式不可怕，拆成低次项就能用数据结构维护！**

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合 sane1981 和 LightningUZ 的写法，去掉冗余，突出核心。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int64 P = 1e9 + 7, N = 2e5 + 10;

int n, m, k;
int64 p, a[N], b[N], pw[N], g[N];

int64 qpow(int64 a, int64 b) {
    int64 res = 1;
    for (; b; b >>= 1, a = a * a % P)
        if (b & 1) res = res * a % P;
    return res;
}
int64 inv(int64 x) { return qpow(x, P - 2); }

struct Node {
    int64 s[4]; // s[t] = Σ g^t * b
    Node() { fill(s, s + 4, 0); }
    Node operator+(const Node& rhs) const {
        Node c;
        for (int t = 0; t < 4; ++t) c.s[t] = (s[t] + rhs.s[t]) % P;
        return c;
    }
};

struct Seg {
    Node tr[N << 2];
    int64 add[N << 2];

    void up(int k) { tr[k] = tr[k << 1] + tr[k << 1 | 1]; }
    void apply(int k, int64 v) { // 区间加 v
        int64 v2 = v * v % P, v3 = v2 * v % P;
        // s3 -> s3 + 3v s2 + 3v2 s1 + v3 s0
        tr[k].s[3] = (tr[k].s[3] + 3 * v % P * tr[k].s[2] + 3 * v2 % P * tr[k].s[1] + v3 * tr[k].s[0]) % P;
        tr[k].s[2] = (tr[k].s[2] + 2 * v % P * tr[k].s[1] + v2 * tr[k].s[0]) % P;
        tr[k].s[1] = (tr[k].s[1] + v * tr[k].s[0]) % P;
        add[k] = (add[k] + v) % P;
    }
    void down(int k) {
        if (!add[k]) return;
        apply(k << 1, add[k]);
        apply(k << 1 | 1, add[k]);
        add[k] = 0;
    }

    void build(int k = 1, int l = 1, int r = n) {
        if (l == r) {
            tr[k].s[0] = b[l] % P;
            for (int t = 1; t <= k; ++t) tr[k].s[t] = tr[k].s[t - 1] * g[l] % P;
            return;
        }
        int mid = (l + r) >> 1;
        build(k << 1, l, mid);
        build(k << 1 | 1, mid + 1, r);
        up(k);
    }

    void addRange(int L, int R, int64 v, int k = 1, int l = 1, int r = n) {
        if (L <= l && r <= R) return apply(k, v);
        down(k);
        int mid = (l + r) >> 1;
        if (L <= mid) addRange(L, R, v, k << 1, l, mid);
        if (R > mid) addRange(L, R, v, k << 1 | 1, mid + 1, r);
        up(k);
    }

    void setB(int pos, int64 v, int k = 1, int l = 1, int r = n) {
        if (l == r) {
            int64 old = b[l];
            for (int t = 0; t <= k; ++t) {
                tr[k].s[t] = tr[k].s[t] * inv(old) % P * v % P;
            }
            return;
        }
        down(k);
        int mid = (l + r) >> 1;
        pos <= mid ? setB(pos, v, k << 1, l, mid) : setB(pos, v, k << 1 | 1, mid + 1, r);
        up(k);
    }

    int64 query(int L, int R, int k = 1, int l = 1, int r = n) {
        if (L <= l && r <= R) return tr[k].s[::k] % P;
        down(k);
        int mid = (l + r) >> 1;
        int64 res = 0;
        if (L <= mid) res = query(L, R, k << 1, l, mid);
        if (R > mid) res = (res + query(L, R, k << 1 | 1, mid + 1, r)) % P;
        return res;
    }
} seg;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> p >> k;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1; i <= n; ++i) cin >> b[i];

    pw[0] = 1;
    for (int i = 1; i <= n; ++i) pw[i] = pw[i - 1] * p % P;
    for (int i = 1; i <= n; ++i) g[i] = (g[i - 1] + pw[i] * a[i]) % P;

    seg.build();
    while (m--) {
        int op, x, y;
        cin >> op >> x;
        if (op == 1) {
            cin >> y;
            int64 delta = (y - a[x] + P) % P * pw[x] % P;
            seg.addRange(x, n, delta);
            a[x] = y;
        } else if (op == 2) {
            cin >> y;
            seg.setB(x, y);
            b[x] = y;
        } else {
            cout << seg.query(1, x) << '\n';
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素炼金术士”**  
> 场景：一个 8-bit 像素炼金炉，每次修改 `a`/`b` 就像投入不同材料，炉子里的“能量条”(g) 和“魔法值”(f) 实时变化！

### 设计要点
- **像素风格**：  
  - 用 16×16 像素方块表示每个 `g[i]` 和 `b[i]`。  
  - 颜色：绿色=能量，蓝色=魔法权重，红色=修改高亮。  
- **动画流程**：
  1. **初始化**：炼金炉出现 n 个绿色能量块，高度 = `g[i]`。  
  2. **修改 a[x] = y**：  
     - 红色箭头指向第 x 块，向上/向下拉伸 Δ 高度。  
     - 右侧所有绿色块同步平移 Δ，伴随“叮”音效。  
  3. **修改 b[x] = y**：  
     - 蓝色权重方块瞬间变色，数值闪烁。  
  4. **查询 f(x)**：  
     - 炉子上方弹出“魔法值”数字，伴随“胜利”音效。  
- **交互面板**：  
  - 步进/自动按钮，速度滑块（1~10 帧/秒）。  
  - “炼金日志”实时显示：  
    ```
    [Step 3] g[5..10] += 7
    [Step 4] Query f(10) = 390
    ```

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **区间加 + 多项式维护**：  
  适用于任何“区间加后需快速计算多项式值”的场景，如：  
  1. 区间加后求**方差**。  
  2. 区间加后求**几何平均数**的对数和。  
  3. 区间加后求**自定义分段函数**的和。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P3372 | 线段树模板：区间加 + 区间和，巩固基础。 |
| P1471 | 区间加后求**方差**，需维护平方和。 |
| P4513 | 区间加 + 区间最大子段和，锻炼信息合并技巧。 |

---

## 7. 学习心得与经验分享

> **来自 sane1981**：  
> “我最爱线段树了！”——把复杂公式拆成 4 个低次项后，线段树就像积木一样简单。  
> **洛语云笺点评**：  
> 把“讨厌的多项式”变成“可爱的线段树”，这就是问题转化的魅力！

---

<conclusion>
今天，我们学会了如何用**多项式展开 + 线段树**优雅地解决嵌套函数问题。  
记住：**复杂公式不可怕，拆低次项 + 数据结构**是永恒的王道！  
下次见，继续像素探险！

---
处理用时：83.77秒
# 题目信息

# 「Wdsr-1」人间之里

## 题目背景

- 这里是幻想乡中最多人类居住的地方。因为有许多妖怪也会光临的店，所以会有各种妖怪到访，不过都是些安份的妖怪，这是一个和平的地方（×1稗田家所在地，毫无疑问也在人类村落。

- 人类必要的生活用品，都能在这里买到。也有一些专门退治妖怪的人住在这，所以这里的生活是较安全的。

- 要说人类村落为什么没有被袭击，那就是妖怪的贤者在背后保护（×2幻想乡的人类灭绝的话，妖怪们也不好过。）。不外出的话，就不会遇上大难。

- 若外出途中遇到比自己强的妖怪（×3高概率的对方比自己强。），就恭恭敬敬地打招呼吧。 还有令人意外的是，有很多店会开到深夜，夜晚会变成妖怪专用店。妖怪多在夜晚活动，店也在那段时间兴旺。可以说妖怪才是很好的客人。

- 特别是卖酒的店，妖怪和人类同乐已成了日常一景。

$$\tag*{——摘自《东方求闻史纪》}$$

## 题目描述

虽然人间之里可以说是全幻想乡对于人类最安全的地方，但是异变发生时，还是可能会出现意外，所以要建立避难所。

人间之里可以抽象为一条坐标轴，其上有 $n$ 个点上建有房屋。这些房屋的坐标分别为 $x_1,x_2,...,x_n$，且在第 $i$ 座房屋中居住着 $v_i$ 位居民。

每次发生异变时，会有一段**坐标连续**的房屋受到影响，而此时便需要在某一坐标处建立避难所。一个避难所的"不便程度"为受影响的房屋中的**每一个居民**与避难所的距离之和。  

（举例来说，假设只有房屋 $i$ 受到了影响，则在 $z$ 处建立避难所的"不便程度"为 $v_i*|x_i-z|$ ） 

当然，坐落在幻想乡中人间之里的不可能一成不变，所以房屋的位置和居民的数量都可能会发生变化。

具体来说，你需要处理 $m$ 次询问或修改，每一次输入的格式如下：

- `1 l r`，表示询问 当**坐标**位于 $[l,r]$ 范围内的房屋受到异变影响时，在所有建立避难所的方案中，最小的"不便程度"是多少。

- `2 a b c`，表示将第 $a$ 座房屋的坐标修改为 $b$，其中居住的村民的数量变为 $c$ 。 

**注意：**
- 在 $1$ 操作中的"受到异变影响"均为假设，所以对之后的查询不产生作用。

- 在 $2$ 操作中发生变化的是第 $a$ 座房屋而不是坐标为 $a$ 的房屋。



## 说明/提示

**【样例解释】**

对于第一个询问，共有两座房屋受到影响，一处位于 $x=4$ 处，有 $3$ 位村民，一处位于 $x=7$ 处，有 $6$ 位村民。

避难所选在 $x=7$ 处时，"不便程度"为：

$$\left\vert 7 - 4 \right\vert \times 3 + \left\vert 7 - 7 \right\vert \times 6 = 9$$

可以证明 $9$ 是所有建立避难所的方案中"不便程度"的最小值。

--------------------

**【数据范围】**

- 对于 $100\%$ 的数据：
    
    $1 \le n,m \le 3 \times 10 ^ 5$。

    $1 \le a \le n$，$-10 ^ 9 \le l \le r  \le 10 ^ 9 \le n$，$-10 ^ 9 \le x_i,b \le 10 ^ 9$，$0 \le  v_i,c \le 10 ^ 3$。

- **详细的数据范围：**

    设 $mx$ 为所有输入的整数绝对值的最大值。

    测试点编号 | $n,m \le$  | $mx \le$ | 分值
    :-: | :-: | :-: | :-:
    $1$ | $100$ | $100$ | $10$
    $2$ | $8 \times 10 ^ 3$ | $8 \times 10 ^ 3$ | $15$
    $3$ | $8 \times 10 ^ 3$ | $10 ^ 9$ | $5$
    $4$ | $10 ^ 5$ | $10 ^ 5$ | $30$
    $5$ | $10 ^ 5$ | $10 ^ 9$ | $10$
    $6$ | $3 \times 10 ^ 5$ | $10 ^ 9$ | $30$


## 样例 #1

### 输入

```
10 10
-2 -3 -7 2 -6 7 -3 -5 4 -7 
0 2 2 0 4 6 2 4 3 3 
1 4 7
1 -5 7
1 -1 8
2 8 9 2
2 7 -3 5
2 7 4 3
2 2 -1 7
1 -9 -7
2 2 3 1
1 -1 0
```

### 输出

```
9
82
9
0
0```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「Wdsr-1」人间之里 深入学习指南 💡

> 欢迎来到幻想乡的避难所设计现场！今天我们要帮助人间之里规划最优的避难所位置，让居民们在异变发生时能最快抵达安全点。这不仅是数学题，更是一场“带权中位数”与“区间查询”的思维盛宴！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在坐标轴上动态维护一组带权点，支持**修改**单个点的位置/权重，并**快速查询**任意区间内“带权绝对值和”的最小值（即避难所的最优位置）。

✨ **核心算法标签**：  
- **带权中位数**（数学推导）  
- **线段树/树状数组**（区间查询与单点修改）  
- **离散化**（处理大坐标范围）  

🗣️ **初步分析**：  
1. **暴力思路**：对每个查询区间枚举所有可能位置计算最小值，时间复杂度O(mn²)，显然无法通过。  
2. **数学突破**：发现“最小不便程度”等价于**带权中位数问题**——最优避难所位置是区间内居民数的“加权中位数”。  
3. **数据结构**：用线段树维护区间和（Σvᵢ）与加权和（Σvᵢxᵢ），通过二分或线段树上二分定位中位数，将复杂度优化至O(m log n)。

---

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1（问题目标）**：  
   “最小化Σvᵢ|xᵢ-p|”是典型的**带权绝对值和最小化**，数学上最优解为带权中位数。

2. **线索2（数据范围）**：  
   坐标范围1e9需离散化；n,m≤3e5要求O(m log n)算法，指向线段树/树状数组。

3. **线索3（动态操作）**：  
   支持修改和查询，需**动态维护**区间统计量，排除静态前缀和方案。

---

### 🧠 思维链构建：从线索到策略
> “侦探工作完成！让我们拼出完整策略：  
> 1. 数学推导锁定**带权中位数**为核心；  
> 2. 离散化坐标后用线段树维护Σvᵢ和Σvᵢxᵢ；  
> 3. 通过线段树上二分O(log n)定位中位数，拆分绝对值计算答案。”

---

## 2. 精选优质题解参考

### 题解一：Jsxts_的树状数组+离散化（赞：8）
**点评**：  
- **数学推导清晰**：将绝对值和拆分为Σvᵢ·z - Σvᵢxᵢ的形式，用树状数组维护两个前缀和。  
- **离散化巧妙**：离线处理所有坐标，避免动态开点的复杂性。  
- **倍增二分**：用倍增代替二分查找中位数，常数更优。  
- **代码简洁**：仅60行实现，体现“优雅暴力”的极致。

### 题解二：AFewSuns的线段树二分（赞：3）
**点评**：  
- **线段树套二分**：O(m log²n)的通用解法，通过离散化+线段树二分定位中位数。  
- **边界处理严谨**：额外检查p±1位置避免二分误差，细节满分。  
- **动态开点线段树**：适合坐标范围极大的场景，通用性强。

### 题解三：Running_a_way的动态开点线段树（赞：1）
**点评**：  
- **线段树上二分**：O(m log n)的最优解法，直接在权值线段树上定位中位数。  
- **权值线段树**：动态开点节省空间，避免离散化。  
- **代码模块化**：清晰的pushup和query函数，便于复用。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **关键点1：带权中位数的定位**  
   - **分析**：最优避难所位置p满足左侧Σvᵢ ≥ 总Σvᵢ/2且右侧Σvᵢ ≥ 总Σvᵢ/2。  
   - **实现**：用线段树二分查找满足条件的最大p，时间O(log n)。

2. **关键点2：绝对值和的快速计算**  
   - **公式推导**：  
     Σvᵢ|xᵢ-p| = p·Σₗₑₚvᵢ - Σₗₑₚvᵢxᵢ + Σₚ<ᵢvᵢxᵢ - p·Σₚ<ᵢvᵢ  
   - **数据结构**：线段树维护Σvᵢ和Σvᵢxᵢ，区间查询O(log n)。

3. **关键点3：动态修改的处理**  
   - **操作2**：单点修改xₐ和vₐ，需更新线段树中对应节点的Σvᵢ和Σvᵢxᵢ。  
   - **离散化**：若坐标范围大，先离散化所有出现过的坐标。

---

### ⚔️ 策略竞技场：不同解法的对比

| 策略               | 核心思想                     | 优点                     | 缺点与分析               | 适用场景/得分预期 |
|--------------------|------------------------------|--------------------------|--------------------------|--------------------|
| **暴力枚举**       | 枚举区间内所有位置计算最小值 | 思路直观                 | O(mn²)超时               | 测试点1 (n≤100)    |
| **离散化+树状数组** | 离散化后树状数组维护前缀和   | 代码短，常数小           | 需离散化，离线处理       | 100%数据           |
| **线段树二分**     | 线段树上直接定位中位数       | 在线处理，无需离散化     | 代码较长，需动态开点     | 100%数据           |

---

### ✨ 优化之旅：从暴力到最优
> “从枚举每个坐标到数学推导中位数，再到线段树维护——每一步都是对问题结构的深刻洞察。记住：先找数学规律，再选数据结构！”

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（线段树上二分版）
**说明**：综合AFewSuns和Running_a_way的解法，采用动态开点权值线段树在线处理。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 3e5 + 10;
const ll INF = 1e18;

struct Node {
    int ls, rs;
    ll cnt, sum; // cnt: Σvᵢ, sum: Σvᵢxᵢ
} tr[N * 32];
int root, tot;

void pushup(int p) {
    tr[p].cnt = tr[tr[p].ls].cnt + tr[tr[p].rs].cnt;
    tr[p].sum = tr[tr[p].ls].sum + tr[tr[p].rs].sum;
}

void update(ll l, ll r, int &p, ll x, ll v) {
    if (!p) p = ++tot;
    if (l == r) {
        tr[p].cnt += v;
        tr[p].sum = x * tr[p].cnt;
        return;
    }
    ll mid = (l + r) >> 1;
    if (x <= mid) update(l, mid, tr[p].ls, x, v);
    else update(mid + 1, r, tr[p].rs, x, v);
    pushup(p);
}

ll query_cnt(ll l, ll r, int p, ll L, ll R) {
    if (!p) return 0;
    if (L <= l && r <= R) return tr[p].cnt;
    ll mid = (l + r) >> 1, res = 0;
    if (L <= mid) res += query_cnt(l, mid, tr[p].ls, L, R);
    if (R > mid) res += query_cnt(mid + 1, r, tr[p].rs, L, R);
    return res;
}

ll query_sum(ll l, ll r, int p, ll L, ll R) {
    if (!p) return 0;
    if (L <= l && r <= R) return tr[p].sum;
    ll mid = (l + r) >> 1, res = 0;
    if (L <= mid) res += query_sum(l, mid, tr[p].ls, L, R);
    if (R > mid) res += query_sum(mid + 1, r, tr[p].rs, L, R);
    return res;
}

ll find_median(ll l, ll r, int p, ll k) {
    if (l == r) return l;
    ll mid = (l + r) >> 1;
    if (tr[tr[p].ls].cnt >= k) return find_median(l, mid, tr[p].ls, k);
    else return find_median(mid + 1, r, tr[p].rs, k - tr[tr[p].ls].cnt);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    cin >> n >> m;
    vector<ll> x(n + 1), v(n + 1);
    const ll LIM = 1e18;
    for (int i = 1; i <= n; ++i) {
        cin >> x[i];
        x[i] += 1e9; // 避免负数
    }
    for (int i = 1; i <= n; ++i) {
        cin >> v[i];
        update(-LIM, LIM, root, x[i], v[i]);
    }
    while (m--) {
        int op;
        cin >> op;
        if (op == 1) {
            ll l, r;
            cin >> l >> r;
            l += 1e9, r += 1e9;
            ll total = query_cnt(-LIM, LIM, root, l, r);
            if (total == 0) {
                cout << 0 << '\n';
                continue;
            }
            ll k = (total + 1) / 2;
            ll p = find_median(-LIM, LIM, root, 
                query_cnt(-LIM, LIM, root, -LIM, l - 1) + k);
            ll left_cnt = query_cnt(-LIM, LIM, root, l, p);
            ll left_sum = query_sum(-LIM, LIM, root, l, p);
            ll right_cnt = query_cnt(-LIM, LIM, root, p + 1, r);
            ll right_sum = query_sum(-LIM, LIM, root, p + 1, r);
            ll ans = p * left_cnt - left_sum + right_sum - p * right_cnt;
            cout << ans << '\n';
        } else {
            int a;
            ll b, c;
            cin >> a >> b >> c;
            b += 1e9;
            update(-LIM, LIM, root, x[a], -v[a]);
            x[a] = b, v[a] = c;
            update(-LIM, LIM, root, x[a], v[a]);
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**主题**：**“像素避难所”**——8位风格游戏演示带权中位数的选择过程。  
**场景**：  
- 屏幕顶部为坐标轴（像素化刻度），房屋显示为带数字的方块（数字=居民数）。  
- 查询时，区间内的房屋高亮闪烁，线段树以像素树形结构动态展示Σvᵢ和Σvᵢxᵢ的更新。  
- **关键帧**：  
  1. 查询区间高亮，线段树根节点显示总Σvᵢ。  
  2. 二分定位中位数：像素箭头在权值线段树上移动，伴随“叮”音效。  
  3. 计算答案：左右区间分别闪烁，实时显示Σvᵢ和Σvᵢxᵢ的求和过程。  
- **交互**：支持单步/自动播放，速度滑块调整，完成查询后播放“胜利”音效。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **带权中位数**：适用于“最小化距离和”问题，如仓库选址、快递站布局。  
- **线段树维护统计量**：推广到区间第k大、区间众数等问题。  

### 洛谷推荐练习
1. **P3396 哈希冲突**  
   🗣️ 巩固线段树单点修改与区间查询。  
2. **P1908 逆序对**  
   🗣️ 练习权值线段树统计逆序对，理解离散化。  
3. **P3369 普通平衡树**  
   🗣️ 动态开点线段树实现平衡树操作，拓展数据结构能力。

---

## 7. 学习心得与经验分享

> **AFewSuns的调试心得**：  
> “二分出来的p可能不是最优，需检查p±1的位置。这个边界问题卡了我1小时！”  
> **洛语云笺点评**：  
> 数学推导后的边界验证是常见陷阱，建议通过样例手算验证中位数位置。

---

<conclusion>
从带权中位数的数学推导到线段树的动态维护，本题展示了“数学+数据结构”的完美结合。记住：先抽象问题本质，再选择高效工具。下次遇到“最小化距离和”时，你的第一反应应是——带权中位数！
</conclusion>

---
处理用时：105.46秒
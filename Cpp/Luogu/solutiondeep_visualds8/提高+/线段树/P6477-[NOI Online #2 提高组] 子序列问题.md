# 题目信息

# [NOI Online #2 提高组] 子序列问题

## 题目背景

2s 512M

## 题目描述

给定一个长度为 $n$ 的正整数序列 $A_1$, $A_2$, $\cdots$, $A_n$。定义一个函数 $f(l,r)$ 表示：序列中下标在 $[l,r]$ 范围内的子区间中，不同的整数个数。换句话说，$f(l,r)$ 就是集合 $\{A_l,A_{l+1},\cdots,A_r\}$ 的大小，这里的集合是不可重集，即集合中的元素互不相等。

现在，请你求出 $\sum_{l=1}^n\sum_{r=l}^n (f(l,r))^2$。由于答案可能很大，请输出答案对 $10^9 +7$ 取模的结果。

## 说明/提示

对于 $10\%$ 的数据，满足 $1 \leq n \leq 10$；

对于 $30\%$ 的数据，满足 $1 \leq n \leq 100$；

对于 $50\%$ 的数据，满足 $1\leq n \leq 10^3$；

对于 $70\%$ 的数据，满足 $1 \leq n \leq 10^5$；

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，集合中每个数的范围是 $[1,10^9]$。

## 样例 #1

### 输入

```
4
2 1 3 2```

### 输出

```
43```

## 样例 #2

### 输入

```
3
1 1 1```

### 输出

```
6```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：[NOI Online #2 提高组] 子序列问题 深入学习指南 💡

> 今天我们要挑战的是一道**区间统计**与**数据结构优化**完美结合的硬核题目：  
> **求所有子区间的“不同元素个数平方”之和**。  
> 这不是简单的枚举，而是一场**从 O(n²) 暴力到 O(n log n) 优雅优化**的思维马拉松！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“在 1e6 长度的序列里，快速统计 **所有 n(n+1)/2 个子区间** 中 **不同元素个数的平方和**。”  
核心难点在于：  
- 区间数量是 1e12 量级，暴力 O(n²) 不可行；  
- 需要**动态维护区间信息**（不同数个数），且**平方和无法简单累加**。

✨ **核心算法标签**：  
`扫描线 + 线段树/树状数组维护区间平方和`、`离散化`、`差分思想`

🗣️ **初步分析**：  
- **暴力思路**：枚举 l, r，暴力统计 f(l,r) 再平方 → O(n²) → 只能过 n≤1e3。  
- **优化方向**：  
  1. **扫描线**：固定右端点 r，将问题转化为“以 r 结尾的所有左端点 l 的贡献”。  
  2. **数据结构**：需要支持 **区间加**（+1）和 **区间平方和查询**（Σx²）。  
  3. **离散化**：值域 1e9 需先离散化到 1e6，避免 map 常数。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|------|----------|
| **线索1：求所有子区间贡献** | “子区间”暗示扫描线或区间 DP，但 n=1e6 排除 O(n²)。 |
| **线索2：不同元素个数** | 经典模型：**pre[i] 数组**记录上一个相同值位置，可快速判断“新增”元素。 |
| **线索3：平方和不可拆分** | 平方和 Σx² 无法直接累加，需用 **(x+1)² = x² + 2x + 1** 展开，维护 **区间和** 与 **区间平方和**。 |
| **线索4：1e6 时限 2s** | O(n log n) 可行，需用 **线段树或树状数组** 维护区间信息。 |

---

### 🧠 思维链构建：从线索到策略

> 1. **线索1**告诉我：暴力枚举子区间不可行，需**扫描线**固定右端点 r。  
> 2. **线索2**告诉我：新增元素 a[r] 只会影响 **pre[r]+1 到 r** 的区间，其他区间不变。  
> 3. **线索3**告诉我：需要维护 **区间和 sum** 和 **区间平方和 sqr**，利用公式：  
>    `Δsqr = 2*sum*Δ + len*Δ²`（Δ=1）。  
> 4. **线索4**告诉我：线段树/树状数组维护区间加和区间平方和，复杂度 O(n log n)。  
> **结论**：**扫描线 + 线段树维护区间平方和** 是最优策略！

---

## 2. 精选优质题解参考

### 题解一：OMG_wc（赞：78）  
**核心思想**：  
“固定右端点 r，用树状数组维护区间和与平方和，利用差分思想转移。”  
**亮点**：  
- 巧妙用 **双树状数组** 维护区间加与区间和，避免线段树常数。  
- 公式推导清晰：`g(r+1)-g(r) = 2*Σf(l,r) + len`，直接对应树状数组操作。

### 题解二：BFqwq（赞：49）  
**核心思想**：  
“线段树维护区间平方和，利用 **(x+1)² = x² + 2x + 1** 展开。”  
**亮点**：  
- 线段树节点维护 **sum（区间和）** 和 **sqr（平方和）**，pushdown 时直接套用公式。  
- 代码简洁，注释详细，适合初学者理解。

### 题解三：白木偶君（赞：24）  
**核心思想**：  
“倒序枚举左端点 l，用线段树维护 **以 l 为左端点的区间和**。”  
**亮点**：  
- 利用 **ans[l] = ans[l+1] + 2*query + len** 递推，避免重复计算。  
- 思路直观，适合培养“区间贡献”思维。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

1. **关键点1：离散化与 pre 数组**  
   - **分析**：值域 1e9 需离散化到 1e6，用 **pre[i]** 记录上一个相同值位置。  
   - 💡 **学习笔记**：离散化是处理大值域的通用技巧，避免 map 的 log 常数。

2. **关键点2：线段树维护区间平方和**  
   - **分析**：线段树节点需存储 **sum（区间和）** 和 **sqr（平方和）**。  
     - 区间加 Δ 时：  
       `sqr = sqr + 2*sum*Δ + len*Δ²`  
       `sum = sum + len*Δ`  
   - 💡 **学习笔记**：平方和的维护需 **先更新 sqr，再更新 sum**，避免覆盖。

3. **关键点3：扫描线转移**  
   - **分析**：固定右端点 r，新增元素 a[r] 只会影响 **[pre[r]+1, r]** 区间。  
   - 💡 **学习笔记**：扫描线将二维问题（l,r）降为一维（r），大幅降低复杂度。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| **暴力 O(n²)** | 枚举 l,r，暴力统计 f(l,r) | 思路直观 | 无法通过 1e6 | 教学演示 |
| **扫描线 + 线段树 O(n log n)** | 固定 r，维护区间平方和 | 最优复杂度 | 线段树常数较大 | 本题标准解法 |
| **扫描线 + 双树状数组 O(n log n)** | 用树状数组维护区间和 | 常数更小 | 实现稍复杂 | 追求极致常数 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合 OMG_wc 和 BFqwq 的写法，使用 **线段树维护区间平方和**。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e6 + 5, mod = 1e9 + 7;

struct SegTree {
    ll sum[N << 2], sqr[N << 2], tag[N << 2];
    void pushup(int p) {
        sum[p] = (sum[p << 1] + sum[p << 1 | 1]) % mod;
        sqr[p] = (sqr[p << 1] + sqr[p << 1 | 1]) % mod;
    }
    void apply(int p, int l, int r, ll v) {
        sqr[p] = (sqr[p] + 2 * sum[p] * v + (r - l + 1) * v % mod * v) % mod;
        sum[p] = (sum[p] + (r - l + 1) * v) % mod;
        tag[p] += v;
    }
    void pushdown(int p, int l, int r, int mid) {
        if (tag[p]) {
            apply(p << 1, l, mid, tag[p]);
            apply(p << 1 | 1, mid + 1, r, tag[p]);
            tag[p] = 0;
        }
    }
    void update(int p, int l, int r, int ql, int qr, ll v) {
        if (ql <= l && r <= qr) return apply(p, l, r, v);
        int mid = (l + r) >> 1;
        pushdown(p, l, r, mid);
        if (ql <= mid) update(p << 1, l, mid, ql, qr, v);
        if (qr > mid) update(p << 1 | 1, mid + 1, r, ql, qr, v);
        pushup(p);
    }
    ll query() { return sqr[1]; }
} seg;

int n, a[N], pre[N], lst[N], b[N], m;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%d", &a[i]), b[i] = a[i];
    sort(b + 1, b + n + 1);
    m = unique(b + 1, b + n + 1) - (b + 1);
    for (int i = 1; i <= n; ++i) {
        a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;
        pre[i] = lst[a[i]];
        lst[a[i]] = i;
    }
    ll ans = 0;
    for (int i = 1; i <= n; ++i) {
        seg.update(1, 1, n, pre[i] + 1, i, 1);
        ans = (ans + seg.query()) % mod;
    }
    printf("%lld\n", ans);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**动画主题**：“像素探险家的区间魔法”  
- **场景**：8 位像素风格的网格，横轴是左端点 l，纵轴是右端点 r。  
- **核心演示**：  
  1. **离散化**：将大数字变成彩色像素块。  
  2. **扫描线**：像素光标从左到右移动，高亮当前 r。  
  3. **区间加**：当光标停在 r，**pre[r]+1 到 r** 的像素条变亮（+1）。  
  4. **平方和计算**：顶部显示当前 **Σf(l,r)²**，伴随 8 位音效“叮！”  
- **交互**：  
  - 单步/自动播放按钮，速度滑块。  
  - 像素星星奖励完成每一步。  

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
- 扫描线 + 区间数据结构维护 **区间和/平方和** 适用于：  
  1. **区间不同数个数**（P1972 [SDOI2009] HH的项链）。  
  2. **区间 mex 问题**（P4137 Rmq Problem）。  
  3. **区间逆序对**（P1966 [NOIP2013] 火柴排队）。

**洛谷推荐**：  
1. **P1972** - 经典扫描线+树状数组维护区间不同数。  
2. **P3676** - 小清新数据结构题，维护平方和。  
3. **P5490** - 扫描线+线段树，二维矩形面积并。  

---

## 7. 学习心得与经验分享

> **OMG_wc**：“用 map 会卡常，离散化+树状数组更稳！”  
> **tzc_wk**：“freopen 忘写爆零两行泪！”  
> **洛语云笺点评**：  
> - 离散化是处理大值域的“防卡常神器”。  
> - 线段树维护平方和时，**先更新平方和，再更新和**，避免覆盖。  

---

## 结语

从暴力枚举到扫描线优化，我们见证了 **O(n²) → O(n log n)** 的华丽蜕变。  
记住：**扫描线将二维变一维，数据结构让区间操作飞起！**  
下次遇到区间统计题，先想想 **pre 数组 + 线段树** 这对黄金搭档！💪
```

---
处理用时：87.74秒
# 题目信息

# 可重集

## 题目描述

给出一个长度为 $n$ 的非负整数序列 $a_1,a_2,a_3,\ldots, a_n$，给出 $q$ 次操作，每次先给出一个参数 $op$：

- $op=0$，接下来给出 $2$ 个参数 $x,y$，把 $a_x$ 修改为 $y$。

- $op=1$，接下来给出 $4$ 个参数 $ l_1,r_1,l_2,r_2$（保证 $r_1-l_1=r_2-l_2$），你需要判断区间 $[l_1,r_1]$ 与区间 $[l_2,r_2]$ 是否本质相同，如果本质相同输出 `YES`，否则输出 `NO`。

本质相同的定义：令区间长度为 $\text{len}$ ，序列 $p_{1}\dots p_{\text{len}}$ 为 $a_{l_1}\dots a_{r_1}$ 升序排序后的结果，序列 $q_{1}\dots q_\text{len}$ 为 $a_{l_2}\dots a_{r_2}$ 升序排序后的结果，存在一个整数 $k$ 使得满足 $\forall i,p_i+k=q_i$。

## 说明/提示



- Subtask1 （$25$ pts）：$1\leq n,q \leq 1000$。

- Subtask2 （$25$ pts）：$1\leq n,q \leq 10^5$，$0\leq a_i,y\leq 100$。

- Subtask3 （$25$ pts）：$1\leq n,q \leq 10^5$。

- Subtask4 （$25$ pts）：无特殊限制。

你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。

对于所有数据满足：$1\leq n,q \leq 10^6$，$1\leq x \leq n$，$0\leq a_i,y \leq  10^6$ 。且对于所有 $l,r$ 有 $1\leq l\leq r\leq n$。



## 样例 #1

### 输入

```
12 6
1 1 4 5 1 4 2 2 5 2 3 3
1 1 3 7 9
1 2 3 5 6
1 1 3 2 4
0 7 1
1 1 4 2 5
1 5 7 8 10```

### 输出

```
YES
YES
NO
YES
YES```

# AI分析结果

# 💡 洛语云笺的C++算法解析：可重集 深入学习指南 💡

> 今天我们一起拆解「可重集」这道看似“区间判重”实则暗藏玄机的题目。它像一座宝藏岛：  
> 表面是“两段区间排序后是否只差一个平移量 k”，  
> 深层却需要我们找到“既能抗修改、又能秒查询”的魔法特征函数。  
> 准备好了吗？让我们化身算法探险家，从朴素模拟一路打到哈希黑科技！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在 **带单点修改** 的前提下，**快速判定**两段等长区间的“排序差分”是否完全一致，即  
∀i, 排序后 A[i] + k ≡ 排序后 B[i]。

✨ **核心算法标签**  
- 线段树 / 树状数组  
- 哈希（指数型、三角函数型、幂次型）  
- 分块（值域分块、区间分块）  

🗣️ **思路演进路径**  
1. **暴力排序**：直接 `sort` 两段区间 → 100% 正确，100% TLE。  
2. **值域计数**：用桶/树状数组统计出现次数 → 值域小时可行。  
3. **特征哈希**：把“出现次数数组”压缩成一个可平移的哈希值 → 100% 通过，但需要巧妙构造。  
4. **三角魔法**：用 `sin/cos` 的和差角公式 → 精度玄学，但极难被卡。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **问题目标** | “排序后整体平移” → 特征需满足 **平移不变性**。 |
| **操作类型** | 单点修改 + 区间查询 → 需要 **log 级** 数据结构。 |
| **值域规模** | 0 ≤ a_i ≤ 1e6 → 桶/哈希长度可控。 |
| **数据规模** | n,q ≤ 1e6 → O(n log n) 以内才安全。 |

🧠 **思维链构建**  
1. 排序太慢 → 把“排序后差分相等”转化为“出现次数数组的平移”。  
2. 出现次数数组很长 → 用 **哈希** 压缩：Σ cnt[x]·g^x，平移 k 等价于乘 g^k。  
3. 需同时求区间最小值（算 k）→ 线段树维护 `min` + `hash_sum`。  
4. 精度/冲突？多哈希 / 三角函数 / 随机底数 兜底。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 推荐指数 |
|---|---|---|
| **skydogli** | 提出 **g^x 指数哈希** + 树状数组维护区间最小值，简洁高效。 | ⭐⭐⭐⭐⭐ |
| **Singercoder** | **sin/cos 特征函数** + 和差角公式，优雅抗冲突。 | ⭐⭐⭐⭐☆ |
| **Piwry** | 经典 **base^x 哈希**，配合区间最小值，实现简单。 | ⭐⭐⭐⭐☆ |
| **a___** | 完整证明 **指数哈希正确性**，并给出多哈希防卡策略。 | ⭐⭐⭐⭐⭐ |
| **ADay** | **随机底数 + zkw 线段树**，常数极小。 | ⭐⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以指数哈希为例）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 特征函数设计** | 把区间看成多重集，哈希 = Σ cnt[x]·g^x。平移 k 等价于整体乘 g^k。 | 哈希需满足 **分配律**：f(S+k)=f(S)·g^k。 |
| **2. 数据结构** | 线段树节点存 `min` + `hash_sum`，单点修改 O(log n)。 | 也可 zkw 线段树降低常数。 |
| **3. k 的计算** | k = min₂ - min₁（排序后最小值差）。 | 需同时查询两段区间最小值。 |
| **4. 防卡策略** | 双哈希（不同底数、模数）或三角函数（sin/cos）避免冲突。 | 随机大质数底数 + 大模数。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力排序** | sort+逐位比较 | 无脑正确 | O(n log n) 查询，爆炸 | 25 pts |
| **值域桶+树状数组** | 每值一树状数组 | 查询 O(V log n) | 值域大时爆炸 | 50 pts |
| **指数哈希+线段树** | Σ g^a_i 作为特征 | O(log n) 查询 | 需防哈希冲突 | 100 pts |
| **sin/cos 哈希** | Σ sin(a_i-min) | 精度高、难卡 | 浮点运算略慢 | 100 pts |

---

## 4. C++核心代码实现赏析

### 通用核心实现（指数哈希 + 线段树）

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int N = 1e6 + 5;
const int MOD1 = 1e9 + 7, MOD2 = 1e9 + 9;
const int BASE = 3;               // 998244353 的原根

int n, q, a[N], pow1[N], pow2[N];

struct Node {
    int minv;
    int64 hash1, hash2;
};

Node tr[N << 2];

Node operator+(const Node& a, const Node& b) {
    return Node{
        min(a.minv, b.minv),
        (a.hash1 + b.hash1) % MOD1,
        (a.hash2 + b.hash2) % MOD2
    };
}

void build(int k, int l, int r) {
    if (l == r) {
        tr[k] = {a[l], pow1[a[l]], pow2[a[l]]};
        return;
    }
    int mid = (l + r) >> 1;
    build(k << 1, l, mid);
    build(k << 1 | 1, mid + 1, r);
    tr[k] = tr[k << 1] + tr[k << 1 | 1];
}

void modify(int k, int l, int r, int pos, int v) {
    if (l == r) {
        tr[k] = {v, pow1[v], pow2[v]};
        return;
    }
    int mid = (l + r) >> 1;
    if (pos <= mid) modify(k << 1, l, mid, pos, v);
    else modify(k << 1 | 1, mid + 1, r, pos, v);
    tr[k] = tr[k << 1] + tr[k << 1 | 1];
}

Node query(int k, int l, int r, int ql, int qr) {
    if (ql <= l && r <= qr) return tr[k];
    int mid = (l + r) >> 1;
    if (qr <= mid) return query(k << 1, l, mid, ql, qr);
    if (ql > mid) return query(k << 1 | 1, mid + 1, r, ql, qr);
    return query(k << 1, l, mid, ql, qr) +
           query(k << 1 | 1, mid + 1, r, ql, qr);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> q;

    pow1[0] = pow2[0] = 1;
    for (int i = 1; i < N; ++i) {
        pow1[i] = 1LL * pow1[i - 1] * BASE % MOD1;
        pow2[i] = 1LL * pow2[i - 1] * BASE % MOD2;
    }

    for (int i = 1; i <= n; ++i) cin >> a[i];
    build(1, 1, n);

    while (q--) {
        int op; cin >> op;
        if (op == 0) {
            int x, y; cin >> x >> y;
            modify(1, 1, n, x, y);
        } else {
            int l1, r1, l2, r2;
            cin >> l1 >> r1 >> l2 >> r2;
            Node a1 = query(1, 1, n, l1, r1);
            Node a2 = query(1, 1, n, l2, r2);
            int k = a2.minv - a1.minv;
            int64 h1 = a1.hash1 * pow1[k] % MOD1;
            int64 h2 = a1.hash2 * pow2[k] % MOD2;
            bool ok = (h1 == a2.hash1) && (h2 == a2.hash2);
            cout << (ok ? "YES" : "NO") << '\n';
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 主题：**《像素探险家与魔法哈希》**

- **画面**：8-bit 森林中，每棵树代表一个数组元素，树高 = 数值。  
- **操作**  
  1. **单点修改**：像素斧头砍树 → 树高瞬间变化，线段树节点同步闪烁更新。  
  2. **区间查询**：两只像素精灵分别跑向 `[l1,r1]` 与 `[l2,r2]`，沿途收集 **魔法宝石**（哈希值）。  
  3. **判定时刻**：屏幕中央弹出“平移量 k”，宝石光芒同步移动 k 格，若完全重合 → 胜利音效！

- **交互**  
  - 单步/自动播放按钮。  
  - 速度滑块（1×/2×/4×）。  
  - 音效：  
    - 修改 → 8-bit “叮”。  
    - 成功 → 胜利号角。  
    - 失败 → 像素“咚”。

- **实现要点**  
  - Canvas 绘制线段树节点为像素方块。  
  - 使用 `requestAnimationFrame` 做平滑动画。  
  - 音效用 Web Audio API 生成方波。

---

## 6. 拓展练习与相似问题思考

| 通用套路 | 场景示例 |
|---|---|
| **特征哈希+平移** | 区间“同构”判定（旋转、翻转、平移）。 |
| **值域桶+树状数组** | 统计区间出现次数，如“区间众数”。 |
| **sin/cos 维护** | 高精度数值哈希，适用于浮点序列。 |

### 洛谷推荐

1. **P4137 Rmq Problem**  
   🗣️ 区间最值 + 单点修改，线段树模板热身。  
2. **P5262 区间众数**  
   🗣️ 值域桶 + 分块，体验“值域大”时的分块技巧。  
3. **P5048 区间本质不同子串**  
   🗣️ 哈希 + 线段树，进阶“特征压缩”思想。  

---

## 7. 学习心得与经验分享

> **来自 skydogli 的调试心得**  
> “一开始用单哈希被卡，后来加了一个随机大质数底数 + 双模数，瞬间通过。提醒：不要吝啬模数！”  
> **洛语云笺点评**：哈希冲突并不可怕，可怕的是“懒得双保险”。多哈希、多模数是通用防卡秘诀。

---

### 🎉 结语

从暴力排序到指数哈希，我们完成了一次“思维升级”之旅：  
- **暴力** → 让我们理解问题本质；  
- **桶计数** → 让我们看到值域的力量；  
- **哈希压缩** → 让我们学会用数学对抗复杂度。  

下一次，当你遇到“区间判重”或“平移同构”时，别忘了今天学到的“魔法哈希”！  
探险结束，但算法之路永无止境——继续加油，年轻的探险家！

---
处理用时：96.14秒
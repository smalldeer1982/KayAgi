# 题目信息

# 「CGOI-1」丑国旅游

## 题目背景

丑国风景优美，是远近闻名的旅游胜地（并不）。来丑国旅游的人很多。

## 题目描述

丑国的一角排列着编号从 $1$ 到 $n$ 的 $n$ 个城市。当一个人在第 $i$ 个城市时，能且仅能走到第 $i+1$ 个城市。

第 $i$ 个城市中的人们最讨厌丑值为 $a_i$ 的人。当一个丑值为 $x$ 的人从第 $i$ 个城市走到第 $i+1$ 个城市时，他会获得 $|x-a_i|\times|x-a_{i+1}|$ 的舒适值。

现在有 $m$ 个人要来丑国旅游，第 $i$ 个人的丑值为 $x_i$，要从城市 $l_i$ 走到 $r_i$，问他得到的舒适值之和是多少。

**由于这个数可能很大，你需要求出对 $10^9+7$ 取模后的值**。

由于你不能预知到下一次旅游，我们会强制你在线。

**简化版题意：**

给出 $n$ 及 $n$ 个整数 $a_1,\,a_2,\,\dots,\,a_n$。

$m$ 次在线询问，每次询问给出 $x,\,l,\,r$，求 $\sum\limits_{i=l}^{r-1}|x-a_i|\times|x-a_{i+1}|$。

## 说明/提示

#### 样例说明：

对于第一次询问，从城 $1$ 走到城 $2$，获得舒适值为 $|1-1|\times|1-2|=0$；从城 $2$ 走到城 $3$，获得舒适值为 $|1-2|\times|1-3|=2$，故总舒适值为 $2$。

对于第二次询问，解密后的 $x,\,l,\,r$ 分别是 $4,3,5$。从城 $3$ 走到城 $4$，获得舒适值为 $|4-3|\times|4-4|=0$；从城 $4$ 走到城 $5$，舒适值为 $|4-4|\times|4-5|=0$，总舒适值为 $0$。

---

#### 数据范围：

**本题采用捆绑测试。**

| 编号 | 特殊限制 | 分值 |时限|
| :-: | :-: | :-: |:-:|
| Subtask0 | $n,\,m\le 10^4$ | 20pts |1s|
| Subtask1 | $a_i,\,x\le 10$ | 10pts |2s|
| Subtask2 | $a_i$ 单调递增 | 10pts |2s|
| Subtask3 | 无特殊限制 | 60pts |2s|

对于 $100\%$ 的数据，$1 \le n,\,m \le 3 \times 10^5$，$1 \le a_i,\,x_i \le 10^9$，$1 \le l_i < r_i \le n$。

## 样例 #1

### 输入

```
5 2
1 2 3 4 5
1 1 3
6 1 7```

### 输出

```
2
0```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「CGOI-1」丑国旅游 深入学习指南 💡

<introduction>
  今天我们要拆解的是一道**“区间多项式求和 + 强制在线”**的综合题。  
  乍看之下，它像线段树模板，但再细看——**绝对值**与**乘积**的组合让普通的区间和失效；**强制在线**又堵死了离线处理的大门。  
  我们将一起把“绝对值”这层外壳拆掉，把问题转化为“按 x 分段的多项式系数前缀和”，然后用**可持久化线段树**优雅地解决它！
</introduction>

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在强制在线的前提下，对 **任意区间 [l, r-1]** 与 **任意实数 x**，快速求出  
$$\sum_{i=l}^{r-1}|x-a_i|\cdot|x-a_{i+1}| \mod 10^9+7$$  
难点在于 **|x-a| 不可直接拆分**，且 **x 每变一次，整个区间和都要重算**。

✨ **核心算法标签**：  
多项式分段、可持久化线段树（Persistent Segment Tree）、离散化、在线查询

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 指向策略 |
|---|---|---|
| **线索1：区间求和** | 题目要求“区间和”，且 n, m ≤ 3×10⁵ → O(n log n) 预处理 + O(log n) 查询 | 线段树/前缀数组 |
| **线索2：绝对值** | |x-a|·|x-b| 随 x 变化呈**分段二次函数** | 把区间和拆成 **x²·Σb + x·Σc + Σd** 的三段系数和 |
| **线索3：强制在线** | 不能离线扫描 x → 需要**按 x 排序后离线建树**再在线二分版本 | 可持久化线段树 |

### 🧠 思维链构建：从线索到策略
> 1. 看到区间求和 → 想到线段树。  
> 2. 但绝对值让“区间和”与 x 强耦合 → 把每一项写成 **关于 x 的二次多项式**。  
> 3. 多项式只有两种形式（±x²…），取决于 x 与 a_i、a_{i+1} 的大小关系。  
> 4. 当 x 从小变大经过某个 a_k 时，**最多两条边** (k-1, k) 与 (k, k+1) 的系数会翻转符号。  
> 5. 于是“x 递增”等价于“在可持久化线段树上递增版本” → 用 **离散化 + 可持久化线段树** 解决！

---

## 2. 精选优质题解参考

### 题解一：阿丑（赞：7）
* **点评**：  
  思路清晰，把绝对值拆成二次多项式后，用可持久化线段树维护 Σb, Σc, Σd。  
  代码风格紧凑，宏定义 `lc/rc` 提高可读性；离散化 + upper_bound 定位版本，复杂度 O((n+m) log n)。  
  小提示：作者在最后一句自嘲“常数巨大”，提醒我们注意**取模正负号**与**long long**细节。

### 题解二：Push_Y（赞：隐式引用）
* **亮点**：  
  与阿丑同思路，但实现更“STL化”：  
  - 用 `vector<int> pos[N]` 存储离散化后的相同值下标，**批量修改**，减少递归深度。  
  - 结构体封装 `node{ a,b,c }` 并内联 `ans(x)`，代码可读性高。  
  - 注意下标从 0 到 n-1 的“边”视角，避免边界特判。

### 题解三：QinghongLi（赞：4）
* **亮点**：  
  同样采用分段二次函数，但**显式离线排序**后建树。  
  代码注释详细，尤其提醒 `(ll)` 的位置与**负数取模**要 `+mod` 再 `%mod`，对初学者友好。  
  使用 `upper_bound(c+1,c+n+1,x)-c-1` 找版本号，逻辑直观。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **1. 多项式拆分** | 对每条边 i → 把 `|x-a_i|·|x-a_{i+1}|` 写成 `b_i x² + c_i x + d_i`，其中 b_i ∈ {1,-1}, c_i, d_i 由 a_i, a_{i+1} 决定 | **绝对值问题 → 分段多项式** 是通用套路 |
| **2. 系数翻转事件** | 当 x 跨过某个 a_k 时，只有两条边 (k-1,k) 与 (k,k+1) 的系数需要翻转符号 → **每次修改 O(1)** | 事件点少 → 可持久化 |
| **3. 可持久化线段树** | 版本 v 对应“所有 ≤ v 的翻转事件已处理”，区间查询即求 **版本 rt[v] 上的 Σb, Σc, Σd** | 模板：离散化 → 建树 → 版本递增 → 在线二分 |

### ✨ 解题技巧总结
- **技巧A：多项式分段**——遇到含绝对值的区间和，先写成**关于变量的多项式**，再拆系数。
- **技巧B：事件点排序**——把“变量变化导致系数翻转”的时刻提取出来，按值排序，即可用**可持久化数据结构**。
- **技巧C：负数取模**——在 C++ 中 `(a % mod + mod) % mod` 保证非负。

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 时间复杂度 | 优缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力扫描** | 对每个询问直接循环 [l,r-1] | O(m (r-l)) | 思路直观，TLE 无疑 | 20% 部分分 |
| **离线扫描线** | 把所有询问按 x 排序，从左到右扫，树状数组维护区间和 | O((n+m) log n) | 无法处理强制在线 | 无特殊限制但可离线 |
| **可持久化线段树**（最优） | 按 x 离散化建版本，区间查询三系数和 | O((n+m) log n) | 支持强制在线，代码 120 行左右 | 100% 数据 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合阿丑与 Push_Y 的优点，提炼出**面向竞赛**的完整实现。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 3e5 + 5, mod = 1e9 + 7;

int n, m, a[N], b[N], len;
vector<int> pos[N];

/* ===== 可持久化线段树 ===== */
const int M = N * 40;
int tot, rt[N], lc[M], rc[M];
struct Node { ll s1, s2, s3; } tr[M];

inline void addNode(int &x, int old) { x = ++tot; lc[x] = lc[old]; rc[x] = rc[old]; tr[x] = tr[old]; }
inline void pushUp(int x) {
    tr[x].s1 = (tr[lc[x]].s1 + tr[rc[x]].s1) % mod;
    tr[x].s2 = (tr[lc[x]].s2 + tr[rc[x]].s2) % mod;
    tr[x].s3 = (tr[lc[x]].s3 + tr[rc[x]].s3) % mod;
}

void build(int &x, int l, int r) {
    x = ++tot;
    if (l == r) {
        int i = l;
        tr[x].s1 = 1;
        tr[x].s2 = (-a[i] - a[i + 1]) % mod;
        tr[x].s3 = (ll)a[i] * a[i + 1] % mod;
        return;
    }
    int mid = (l + r) >> 1;
    build(lc[x], l, mid);
    build(rc[x], mid + 1, r);
    pushUp(x);
}

void modify(int &x, int old, int l, int r, int p) {
    addNode(x, old);
    if (l == r) {
        tr[x].s1 = -tr[x].s1;
        tr[x].s2 = -tr[x].s2;
        tr[x].s3 = -tr[x].s3;
        return;
    }
    int mid = (l + r) >> 1;
    if (p <= mid) modify(lc[x], lc[old], l, mid, p);
    else modify(rc[x], rc[old], mid + 1, r, p);
    pushUp(x);
}

ll query(int x, int l, int r, int ql, int qr, ll x0) {
    if (!x) return 0;
    if (ql <= l && r <= qr) {
        ll res = (x0 * x0 % mod * tr[x].s1 + x0 * tr[x].s2 + tr[x].s3) % mod;
        return res;
    }
    int mid = (l + r) >> 1;
    ll res = 0;
    if (ql <= mid) res += query(lc[x], l, mid, ql, qr, x0);
    if (qr > mid) res += query(rc[x], mid + 1, r, ql, qr, x0);
    return res % mod;
}
/* ===== 主程序 ===== */
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> a[i], b[i] = a[i];

    // 离散化
    sort(b + 1, b + n + 1);
    len = unique(b + 1, b + n + 1) - (b + 1);
    for (int i = 1; i <= n; ++i) {
        int id = lower_bound(b + 1, b + len + 1, a[i]) - b;
        pos[id].push_back(i);
    }

    build(rt[0], 1, n - 1);
    for (int i = 1; i <= len; ++i) {
        rt[i] = rt[i - 1];
        for (int v : pos[i]) {
            if (v < n) modify(rt[i], rt[i], 1, n - 1, v);
            if (v > 1) modify(rt[i], rt[i], 1, n - 1, v - 1);
        }
    }

    ll last = 0;
    while (m--) {
        ll x, l, r;
        cin >> x >> l >> r;
        x ^= last; l ^= last; r ^= last;

        int id = upper_bound(b + 1, b + len + 1, x) - b - 1;
        ll ans = query(rt[id], 1, n - 1, l, r - 1, x) % mod;
        ans = (ans + mod) % mod;
        cout << ans << '\n';
        last = ans;
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

* **动画主题**：**“像素旅行者”**  
  8 位像素小人从城市 l 走向城市 r，每走一步，脚下地面根据公式闪烁并弹出“舒适度”数字。

* **核心演示内容**  
  1. 离散化排序：像素化条形图按高度排序，形成 **版本阶梯**。  
  2. 可持久化线段树：  
     - 每个版本是一棵**绿色像素树**，节点值用 3 个迷你数字块显示 (s1,s2,s3)。  
     - 当 x 跨过某个 a_k，对应两条边节点瞬间**翻转颜色**（绿→红），伴随 8-bit “叮”声。  
  3. 在线查询：  
     - 输入 x 后，像素小人自动走到“版本阶梯”对应高度，拿到一棵**目标树**。  
     - 区间 [l,r-1] 高亮为金色路径，树节点逐层累加，屏幕顶端实时显示 `ans % 10^9+7`。

* **交互面板**  
  - 滑块：拖动改变 x，实时看到版本树切换。  
  - 单步/自动：可逐帧观察“系数翻转”事件。  
  - 重置：回到初始状态。  

* **游戏化彩蛋**  
  每正确回答一次询问，像素小人获得一枚“舒适徽章”，累计 10 枚触发**8-bit 胜利音乐**。

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**  
  1. **“分段函数 + 可持久化”** 同样适用于：  
     - 区间绝对值和、区间取整和、区间曼哈顿距离和。  
  2. **“离线离散化 + 在线二分”** 常用于：  
     - 强制在线的区间第 k 大、区间逆序对。  
  3. **“多项式系数前缀和”** 思想：  
     - 区间二次函数最值、区间三次函数积分。

* **洛谷推荐练习**  
| 题号 | 推荐理由 |
|---|---|
| P3372 【模板】线段树 1 | 先掌握普通区间和，再进阶绝对值。 |
| P1972 [SDOI2009] HH的项链 | 离线离散化 + 树状数组，训练“事件点排序”思想。 |
| P3919 【模板】可持久化线段树 1 | 模板题，巩固版本树建立与查询。 |
| P3245 [HNOI2016] 大数 | 区间绝对值相关，需多项式分段与可持久化结合。

---

## 7. 学习心得与经验分享

> 阿丑在题解末尾自嘲“常数巨大”，提醒我们：  
> - 取模时务必 `(ans + mod) % mod` 保证非负。  
> - long long 溢出比 TLE 更隐蔽，**乘法先转 long long 再取模**。  
>  
> Push_Y 的“批量修改”技巧则告诉我们：  
> 离散化后，用 `vector<int> pos[]` 存储相同值下标，可减少递归深度，降低常数。  

---

<conclusion>
从“绝对值不可拆分”到“分段二次函数”，再到“可持久化线段树”，我们完成了一次漂亮的模型转化。记住：  
**“当变量变化导致局部系数翻转时，可持久化数据结构往往是最优雅的一把钥匙。”**  
下次遇到类似问题，别忘了今天的像素旅行者！
</conclusion>

---
处理用时：118.36秒
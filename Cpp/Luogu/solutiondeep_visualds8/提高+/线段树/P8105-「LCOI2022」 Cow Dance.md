# 题目信息

# 「LCOI2022」 Cow Dance

## 题目背景

Bessie 带着他的奶牛姐妹们来跳舞了。

她们已经规划好了跳舞的步骤，但是为了更加美观，她们需要知道其中一些头奶牛在某时的平均位置，已达到更完美的表演效果。

不幸的是，由于 Bessie 的姐妹太多了，最多会有 $8\times 10^4$ 只奶牛同时来跳舞。她没有什么方便且快速的方法算这些平均位置，所以向你求助。

## 题目描述

Bessie 和她的姐妹们已经排好了位置，第 $i$ 头奶牛的坐标为 $(x_i,y_i)$。其中，$x_i$ 是 $x$ 轴坐标，$y_i$ 是 $y$ 轴坐标。

她们的舞蹈队形会有这几种变换方式：
1. 移动：$x$ 到 $y$ 号奶牛的 $x_i\to x_i+a$，$y_i\to y_i+b$。
1. 旋转：$x$ 到 $y$ 号奶牛以 $(a,b)$ 为旋转中心顺时针旋转 $g°$。
1. 散开: $x$ 到 $y$ 号奶牛以 $(a,b)$ 为中心散开为 $\dfrac{p}{q}$ 倍。即设之前奶牛坐标为 $A$，散开后坐标为 $B$，$(a,b)$ 为 $G$，$\overrightarrow{GB}=\dfrac{p}{q}\overrightarrow{GA}$。

Bessie 想知道：对于 $x$ 到 $y$ 号奶牛，他们的平均位置 $(\frac{\sum\limits^y_{i=x}x_i}{y-x+1},\frac{\sum\limits^y_{i=x}y_i}{y-x+1})$。

舞会就要开始了，所以她只能给你 $\texttt{1s}$ 的时间。

## 说明/提示

【样例解释】
![](https://cdn.luogu.com.cn/upload/image_hosting/3jt6apa4.png)

$0$ 为初始情况。$1$ 为进行样例中 `1 1 2 1 -2` 操作后结果。$2$ 为进行样例中 `2 1 3 2 0 270` 操作后结果。$3$ 为进行样例中 `3 1 2 2 2 2 1` 操作后结果。

【数据范围与约定】

保证运算时所有数的绝对值小于或等于 $10^{15}$。

|subtask|特殊限制|分数|
|:-:|:-:|:-:|
|$1$|$1\le n,m\le10^3$|$8$|
|$2$|只有旋转操作且都按奶牛为旋转中心|$18$|
|$3$|只有散开操作且都按奶牛为位似中心|$18$|
|$4$|没有旋转和散开操作|$8$|
|$5$|对于所有操作和询问 $x=y$|$18$|
|$6$|旋转中心和散开中心都是奶牛|$8$|
|$7$|$1\le n,m\le 8\times10^4$|$10$|
|$8$|没有特殊限制|$12$|

对于 $100\%$ 的数据，$1\le n,m\le3\times10^5$，$1\le x\le y\le n$，$-32768\le a,b<32768$，$0< \dfrac{p}{q}\le 233333$，$0\le g\le359$，初始坐标限制同 $a,b$。

### **注：**
- **请注意常数因子优化。**
- **此题输入输出量较大，建议使用 `scanf` 和 `printf`。**

## 样例 #1

### 输入

```
3 7
1 1
1 3
3 1
1 1 2 1 -2
4 1 3
2 1 3 2 0 270
4 1 2
3 1 2 2 2 2 1
4 1 3
4 3 3```

### 输出

```
2.3333333333 0.3333333333
2.0000000000 0.0000000000
1.6666666667 -1.0000000000
1.0000000000 1.0000000000```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：「LCOI2022」Cow Dance 深入学习指南 💡

> 今天我们来一起分析「LCOI2022」Cow Dance。这不仅仅是一次解题，更是一场 **“把几何变换变成代数运算”** 的魔法秀！  
> 当 30 万头奶牛在舞池里旋转、平移、散开时，我们要在 1 秒内算出她们任意时刻的“平均站位”。听上去像不可能完成的任务？跟我一起拆解吧！

---

## 1. 题目解读与策略初探

✨ **核心挑战**：  
> 在 **30 万个点** 的舞池里，实时完成 **区间平移、旋转、位似** 三种几何操作，并在任意时刻 **O(1)** 查询区间平均坐标。  
> 关键难点在于：  
> 1. 如何把“旋转/位似”这种几何动作 **变成可叠加的代数运算**？  
> 2. 如何 **O(log n)** 完成区间更新、区间查询？  

✨ **核心算法标签**：线段树、矩阵乘法、复数、懒标记

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|------|----------|
| **线索1：操作种类** | 三种几何变换 → 都可写成 **线性变换 + 平移** → 矩阵或复数统一描述。 |
| **线索2：区间操作** | “区间加、区间乘” → 经典 **线段树懒标记** 模型。 |
| **线索3：数据规模** | n, m ≤ 3×10⁵ → 必须 **O(n log n)**，暴力 O(n²) 直接爆炸。 |

### 🧠 思维链构建：从线索到策略
1. 先想暴力：每操作一次就 O(n) 扫一遍 → 30 万次操作 → 9×10¹⁰ 次计算 → 电脑直接罢工。  
2. 再想线段树：区间加、区间乘可以懒标记，但 **旋转/位似** 怎么懒？  
3. 灵光一闪：把点 (x,y) 看成 **向量**，任何线性变换都能写成 **2×2 矩阵乘法**！旋转、位似、平移全部统一 → 矩阵乘法可叠加，懒标记就能用了！  
4. 最后优化：矩阵 3×3 常数 27 太大 → 用 **复数** 把 2×2 降到 1×1 常数 2，AC！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|------|----------|
| **STA_Morlin** (赞 14) | 最早提出 **矩阵线段树**，思路清晰：把三种操作统一成矩阵乘法，用线段树维护区间矩阵乘积与区间和。 |
| **kbtyyds** (赞 1) | 把矩阵 **拆成 4 个 double 变量** 手动展开，常数优化到极致；同时给出 **旋转/位似公式推导** 与懒标记叠加公式，适合手推。 |
| **little_cindy** (赞 1) | 用 **复数** 代替 2×2 矩阵，把常数从 27 降到 2，代码短、常数小；附带 **subtask 分治** 思路，帮助理解部分分。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 & 学习笔记 |
|--------|-----------------|
| **1. 如何把几何变换写成矩阵** | 旋转、位似、平移都能写成 **2×2 齐次矩阵**；若嫌常数大，可用 **复数乘法** 统一：旋转 = 乘以 e^(iθ)，位似 = 乘以 k，平移 = 复数加法。 |
| **2. 懒标记如何叠加** | 设旧标记 M₁=(A₁,B₁,C₁,D₁)，新标记 M₂=(A₂,B₂,C₂,D₂)，叠加后 M=(A₁A₂-B₁B₂, A₁B₂+A₂B₁, A₂C₁+B₂D₁+C₂, A₂D₁-B₂C₁+D₂)。<br>💡 学习笔记：矩阵乘法满足结合律，因此懒标记可以 **从右往左** 叠加。 |
| **3. 如何维护区间和** | 区间和 Σx、Σy 的更新公式：<br>Σx' = A·Σx + B·Σy + C·len<br>Σy' = -B·Σx + A·Σy + D·len<br>💡 学习笔记：把“区间和”也当成向量，一起乘矩阵即可。 |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| **暴力 O(n²)** | 每次操作扫区间 | 思路直观 | 超时 | n≤10³ 子任务 |
| **矩阵线段树** | 3×3 矩阵懒标记 | 通用、思路清晰 | 常数 27，需手动展开 | 所有数据，常数优化后可 AC |
| **复数线段树** | 复数乘法代替 2×2 | 常数 2，代码短 | 需理解复数乘法 | 所有数据，最优常数 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合 kbtyyds 与 little_cindy 思路，给出 **复数线段树** 精简版，常数小、易读。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
const double PI = acos(-1.0);

struct C {
    double x, y;
    C(double _x = 0, double _y = 0) : x(_x), y(_y) {}
    C operator+(const C& b) const { return C(x + b.x, y + b.y); }
    C operator*(const C& b) const { return C(x * b.x - y * b.y, x * b.y + y * b.x); }
    C operator*(double k) const { return C(x * k, y * k); }
};

struct Node {
    int l, r;
    C sum, add, mul;
} tr[N << 2];

#define ls (p << 1)
#define rs (p << 1 | 1)

void build(int p, int l, int r) {
    tr[p].l = l, tr[p].r = r;
    tr[p].mul = C(1, 0), tr[p].add = C(0, 0);
    if (l == r) {
        scanf("%lf%lf", &tr[p].sum.x, &tr[p].sum.y);
        return;
    }
    int mid = (l + r) >> 1;
    build(ls, l, mid), build(rs, mid + 1, r);
    tr[p].sum = tr[ls].sum + tr[rs].sum;
}

inline void push_mul(int p, C k) {
    tr[p].sum = tr[p].sum * k;
    tr[p].add = tr[p].add * k;
    tr[p].mul = tr[p].mul * k;
}

inline void push_add(int p, C k) {
    tr[p].sum = tr[p].sum + k * (tr[p].r - tr[p].l + 1);
    tr[p].add = tr[p].add + k;
}

inline void push_down(int p) {
    if (!(fabs(tr[p].mul.x - 1) < 1e-9 && fabs(tr[p].mul.y) < 1e-9)) {
        push_mul(ls, tr[p].mul);
        push_mul(rs, tr[p].mul);
        tr[p].mul = C(1, 0);
    }
    if (!(fabs(tr[p].add.x) < 1e-9 && fabs(tr[p].add.y) < 1e-9)) {
        push_add(ls, tr[p].add);
        push_add(rs, tr[p].add);
        tr[p].add = C(0, 0);
    }
}

void modify_add(int p, int l, int r, C k) {
    if (l <= tr[p].l && tr[p].r <= r) { push_add(p, k); return; }
    push_down(p);
    int mid = (tr[p].l + tr[p].r) >> 1;
    if (l <= mid) modify_add(ls, l, r, k);
    if (r > mid) modify_add(rs, l, r, k);
    tr[p].sum = tr[ls].sum + tr[rs].sum;
}

void modify_mul(int p, int l, int r, C k) {
    if (l <= tr[p].l && tr[p].r <= r) { push_mul(p, k); return; }
    push_down(p);
    int mid = (tr[p].l + tr[p].r) >> 1;
    if (l <= mid) modify_mul(ls, l, r, k);
    if (r > mid) modify_mul(rs, l, r, k);
    tr[p].sum = tr[ls].sum + tr[rs].sum;
}

C query(int p, int l, int r) {
    if (l <= tr[p].l && tr[p].r <= r) return tr[p].sum;
    push_down(p);
    int mid = (tr[p].l + tr[p].r) >> 1;
    C ans;
    if (l <= mid) ans = ans + query(ls, l, r);
    if (r > mid) ans = ans + query(rs, l, r);
    return ans;
}

int main() {
    int n, m; scanf("%d%d", &n, &m);
    build(1, 1, n);
    while (m--) {
        int op, l, r, a, b, g, p, q;
        scanf("%d%d%d", &op, &l, &r);
        if (op == 1) {
            scanf("%d%d", &a, &b);
            modify_add(1, l, r, C(a, b));
        } else if (op == 2) {
            scanf("%d%d%d", &a, &b, &g);
            double rad = g * PI / 180.0;
            C rot(cos(rad), -sin(rad));
            C center(a, b);
            modify_mul(1, l, r, rot);
            modify_add(1, l, r, center - center * rot);
        } else if (op == 3) {
            scanf("%d%d%d%d", &a, &b, &p, &q);
            double k = 1.0 * p / q;
            C scale(k, 0);
            C center(a, b);
            modify_mul(1, l, r, scale);
            modify_add(1, l, r, center - center * scale);
        } else if (op == 4) {
            C ans = query(1, l, r);
            int len = r - l + 1;
            printf("%.6f %.6f\n", ans.x / len, ans.y / len);
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 主题：**「像素牧场」里的奶牛大变身**  
> 目标：把 3 种几何变换用 8-bit 像素动画直观展示。

### 设计思路
- **像素风格**：16×16 像素奶牛图标，8 色调色板（FC 风格）。  
- **数据结构**：用 2 条像素“血条”实时显示区间和 Σx、Σy。  
- **游戏化**：每完成一次操作 → 播放“叮”音效；查询成功 → 播放“胜利”音。

### 动画关键帧
1. **初始化**：生成 8×8 网格，每格 1 只奶牛，初始坐标用绿色像素显示。  
2. **操作1（平移）**：选中区间奶牛 → 整体像素平移 → 血条同步滑动。  
3. **操作2（旋转）**：  
   - 先把旋转中心 `(a,b)` 用红色像素标出。  
   - 区间奶牛以红色像素为圆心顺时针旋转，轨迹用黄色像素连线。  
   - 血条实时更新，显示旋转后的 Σx、Σy。  
4. **操作3（位似）**：  
   - 以红色像素为中心，奶牛图标按比例缩放，像素大小变化。  
   - 血条长度随缩放倍数动态伸缩。  
5. **查询4**：区间奶牛高亮闪烁，血条平均值用金色像素显示，播放“胜利”音效。

### 交互面板
- **单步/自动**：可逐帧观看矩阵/复数运算过程。  
- **速度滑块**：1~10 倍速。  
- **代码同步**：右侧实时高亮当前执行的 `modify_mul` 或 `modify_add` 行。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **区间线性变换 + 懒标记** 可解决：  
  1. 图形渲染管线中的 **顶点变换**。  
  2. 游戏中 **批量精灵缩放/旋转**。  
  3. 计算几何中 **凸包仿射变换**。

### 洛谷推荐
| 题号 | 推荐理由 |
|------|----------|
| **P3373** 线段树2 | 区间加、区间乘模板，巩固懒标记叠加。 |
| **P4556** 雨天的尾巴 | 区间覆盖 + 区间求和，练习多标记下放。 |
| **P7453** 平面变换 | 与本题几乎相同，强化矩阵/复数线段树。 |
| **P5048** 对称与旋转 | 需额外处理对称变换，思维拓展。 |

---

## 7. 学习心得与经验分享

> **kbtyyds**：“把 3×3 矩阵拆成 9 个 double 手动展开，常数从 27 降到 9，再开 C++20，直接 AC！”  
> **洛语云笺点评**：手动展开是 **常数优化的终极奥义**，但也提醒我们：  
> 1. 先写清晰版，再压常数；  
> 2. 善用编译器优化（-O2、C++20）。  

> **little_cindy**：“把 double 写成 int 调了两天，血泪教训。”  
> **洛语云笺点评**：类型错误是 **最隐蔽的 bug**，养成 **编译器警告全开** 的习惯！

---

<conclusion>
本次我们从 **几何直觉** 出发，一路走到 **代数统一** 与 **数据结构优化**，最终用 **复数线段树** 优雅解决了 30 万头奶牛的实时舞蹈问题。  
记住：任何复杂的几何变换，只要能用线性代数描述，就能用 **懒标记线段树** 实时维护。下次再遇到“旋转的精灵”或“缩放的星星”，你就能像今天一样，轻松拿下！💪
</conclusion>
```

---
处理用时：85.58秒
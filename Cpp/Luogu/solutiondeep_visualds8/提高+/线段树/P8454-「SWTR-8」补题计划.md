# 题目信息

# 「SWTR-8」补题计划

## 题目背景

因为写博客，小 A 欠下了很多题没有补。

## 题目描述

小 A 一共有 $n$ 道题目没有补。评估后，他认为第 $i$ 题的难度为 $x_i$。

同时，他对自己的水平有评估值 $w$。他的水平会波动，因此 $w$ 会改变。

小 A 认为补难度和自己水平相近的题目（相差不超过 $b_1$）能带来收益 $inc$；相反，如果相差过大（相差超过 $b_2$）则浪费了时间，导致负收益 $dec$。因此，补第 $i$ 道题的收益为

$$
\begin{cases}
inc & |x_i - w| \leq b_1 \\
0 & b_1 < |x_i - w| \leq b_2 \\
dec & |x_i - w| > b_2 \\
\end{cases}
$$

保证 $b_1 \leq b_2$ 且 $dec < 0 < inc$。

此外，小 A 有一些喜欢和讨厌的题。如果他没有补任何喜欢的题，或补了任何讨厌的题，就会不高兴。

小 A 将选择一段编号连续的题目进行补题。他希望补每道题的收益之和最大，并且补完题目后不会不高兴。请你告诉他这个最大值。

**任意询问之间独立**。

## 说明/提示

**「样例解释」**

$w = 1$ 时，每道题目的收益分别为 $2, 2, -3, 0, -3, 2, 2$。

第一次询问必须要补第 $4$ 题，不能补第 $3$ 题，最优方案为 $[4, 7]$，收益为 $1$。

第二次询问必须要补第 $3$ 题或第 $4$ 题，最优方案为 $[1, 7]$，收益为 $2$。

第三次询问必须要补第 $2$ 题或第 $4$ 题，最优方案为 $[1, 2]$，收益为 $4$。

$w = 1064$ 时，所有题目的收益均为 $-3$。

第四次询问必须要补第 $1$ 题，最优方案为 $[1, 1]$，收益为 $-3$。

$w = 5$ 时，每道题目的收益分别为 $-3, -3, 2, 2, 0, 0, 0$。

第五次询问必须要补第 $2$ 题或第 $7$ 题，不能补第 $4$ 题和第 $6$ 题，最优方案为 $[7, 7]$，收益为 $0$。

**「数据范围与约定」**

**本题采用捆绑测试**。

- Subtask #1（7 points）：$n, q\leq 100$。
- Subtask #2（12 points）：$n, q\leq 500$。依赖 Subtask #1。
- Subtask #3（20 points）：$n, q\leq 4 \times 10 ^ 3$。依赖 Subtask #2。
- Subtask #4（25 points）：$w, x_i \leq 100$。
- Subtask #5（11 points）：$l = 1$，$h = 0$。
- Subtask #6（15 points）：$w, x_i \leq 10 ^ 5$。依赖 Subtask #4。
- Subtask #7（10 points）：无特殊限制。依赖 Subtask #3，#5，#6。

对于 $100\%$ 的数据：

- $1\leq n, q \leq 10 ^ 5$。
- $0\leq w, x_i \leq 10 ^ 9$，$0\leq b_1 \leq b_2$ 且 $b_2$ 不大于 $w, x_i$ 上界的一半。
- $-10 ^ 4 \leq dec < 0 < inc \leq 10 ^ 4$。
- $1\leq l, il_i, ih_j \leq n$，$0 \leq h < n$，$l + h\leq 5$。
- 保证 $il$，$ih$ 递增，且一组询问每个下标至多出现一次。

**「帮助与提示」**

请注意 IO 优化。

**「题目来源」**

- [Sweet Round 8](https://www.luogu.com.cn/contest/73382) C
- Idea & Solution：[tzc_wk](https://www.luogu.com.cn/user/115194)。
- Tester：[Alex_Wei](https://www.luogu.com.cn/user/123294) & [chenxia25](https://www.luogu.com.cn/user/138400)。

## 样例 #1

### 输入

```
0
7 7 1 2 3 2 -3
1 0 6 4 8 2 2
1 1 1
4
3
1 2 0
3 4

1 2 0
2 4

2 1064
1 1 0
1

2 5
1 2 2
2 7
4 6```

### 输出

```
1
2
4
-3
0```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「SWTR-8」补题计划 深入学习指南 💡

<intro>
今天我们来一起分析「SWTR-8」补题计划。这道题融合了**动态规划思想**与**区间数据结构**，是一道“披着模拟外衣”的**离线区间最值**问题。我们将从“如何发现线索”开始，一步步拆解最优策略，并设计一个像素风格的动画，让你“看见”算法在做什么。
</intro>

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> 在**区间必须包含若干“喜欢题”、且不能包含“讨厌题”**的双重限制下，**快速回答多组询问**的最大连续子段和。  
> 难点在于：1) 收益随全局参数 `w` 变化；2) 区间端点由“喜欢/讨厌题”动态切割；3) 数据规模 $10^5$ 要求 $O(n\log n)$ 以内。

### ✨ 核心算法标签
- **离线处理**（事件排序）
- **线段树**（区间最大子段和、区间最值）
- **扫描线思想**

### 🗣️ 思路演进路径
1. **暴力枚举**（Subtask #1）  
   枚举所有子区间 → $O(n^2q)$，仅适合 $n\le500$。
2. **静态区间最值**（Subtask #2~#3）  
   把讨厌题当作“断点”，把序列切成若干段，每段内用**前缀和+ST表/线段树**维护最大子段和。  
   当 $w$ 不变时，单次询问 $O(L\log n)$，$L$ 为喜欢题数量。
3. **离线事件扫描**（正解）  
   发现 **每个题的收益只会随 `w` 变化 4 次**。把所有“变化点”和“询问”一起按 `w` 排序，用**线段树**维护当前收益序列，**一次扫描回答所有询问**。  
   复杂度 $O((n+q)\log n)$。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|------|----------|
| **收益函数是分段常数** | 绝对值不等式把 `w` 轴切成 ≤5 段，暗示“事件点”思想。 |
| **喜欢/讨厌题 ≤5** | 枚举喜欢题，把区间拆成“前缀+后缀”，提示**最大前后缀和**可快速合并。 |
| **询问独立且带全局修改** | 离线处理：把“修改事件”与“询问”一起排序，用**扫描线**即可。 |

### 🧠 思维链构建：从线索到策略
> 1. 看到“收益随 `w` 变化”→ 想到**分段函数**。  
> 2. 看到“区间必须包含/排除某些点”→ 想到**断点切割区间**。  
> 3. 看到“询问独立”→ **离线**把修改与询问绑在一起。  
> 4. 看到“最大子段和”→ **线段树**维护区间最大子段和、最大前后缀和。  
> 结论：**把 4n 次单点修改 + q 次区间查询 离线排序后统一处理**，即可在 $O((n+q)\log n)$ 完成。

---

## 2. 精选优质题解参考

> 以下题解均≥4星，已按启发性与代码质量排序。

### 题解一：Alex_Wei（官方正解）
- **亮点**  
  - 直接给出**离线扫描线**框架，用 `event` 结构体把“收益变化”与“询问”统一排序。  
  - 线段树维护**区间前缀 max / 后缀 max**，巧妙把“包含某个喜欢题”转化为 `max_suffix + max_prefix`。  
- **学习笔记**  
  - 事件排序 = 扫描线的灵魂；一次遍历即可保证复杂度正确。

### 题解二：Dantal10n（标题党但思路清晰）
- **亮点**  
  - 把“喜欢的题”看作**必须覆盖的点**，用“前缀后缀最大和”思想拆区间。  
  - 使用 `std::vector` 存分界点，**离散化+双指针**处理 $w$ 的变化。  
- **学习笔记**  
  - 离散化前先哈希去重，避免值域爆炸。

### 题解三：BreakPlus（极简实现）
- **亮点**  
  - 用 `-inf / +inf` 技巧把“必须选 / 禁止选”转化为**权值覆盖**，省掉复杂分类讨论。  
  - 代码短，适合快速复现。  
- **学习笔记**  
  - “加一个大数再减回去”是处理“强制选”的经典 trick。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解）
| 关键点 | 分析 | 💡学习笔记 |
|--------|------|-----------|
| **事件生成** | 每道题 $i$ 生成 4 个事件点：$x_i-b_2, x_i-b_1, x_i+b_1+1, x_i+b_2+1$，收益在这些点发生 ± 变化。 | 把连续函数离散为事件点，是离线扫描的第一步。 |
| **线段树维护** | 维护区间 `sum, max_prefix, max_suffix, max_subarray`，支持区间加。 | 区间加标记下传时同时更新四个量，模板要一次写对。 |
| **询问拆分** | 枚举每个喜欢题 $p$，找到左右最近的讨厌题 $l, r$。答案 = `max_suffix(l+1..p) + max_prefix(p+1..r-1)`。 | 枚举量 ≤5，复杂度 $O(5\log n)$。 |

### ✨ 解题技巧总结
- **技巧A：事件排序**  
  把“修改”与“查询”都看作事件，统一按关键值排序，可天然保证时间线正确。
- **技巧B：线段树节点打包**  
  用 `struct Node {sum, pre, suf, sub;}` 让 push_up 一次完成，避免四段式复制粘贴。
- **技巧C：权值覆盖技巧**  
  禁止选 → 权值设为 `-inf`；强制选 → 权值加 `inf`，最后统一调整答案。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|------|----------|------|------|---------------|
| **暴力枚举** | 两重循环枚举子区间 | 思路直观 | $O(n^2q)$ 爆炸 | n≤500，7分 |
| **静态前后缀** | 讨厌题作断点，ST表求最值 | 好写 | 无法处理 w 变化 | q=0，25分 |
| **离线扫描线+线段树** | 事件排序+区间数据结构 | 最优复杂度 $O((n+q)\log n)$ | 实现细节多 | 正解，100分 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
> 综合 Alex_Wei 与 BreakPlus 思路，给出**最简洁可复现代码**。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10, INF = 1e9;
struct Event {
    int x, id, val, type;   // type=0: modify, type=1: query
    bool operator<(const Event& rhs) const {
        return x != rhs.x ? x < rhs.x : type < rhs.type;
    }
} ev[N * 5];
int n, q, w0, b1, b2, inc, dec_, tot;
int x[N], ans[N];
vector<int> like[N], hate[N];

// Segment tree for max subarray
struct Node {
    long long sum, pre, suf, sub;
    Node() { sum = pre = suf = sub = 0; }
    Node(long long v) {
        sum = v;
        pre = suf = sub = max(v, 0LL);
    }
} tr[N << 2];
Node operator+(const Node& a, const Node& b) {
    Node c;
    c.sum = a.sum + b.sum;
    c.pre = max(a.pre, a.sum + b.pre);
    c.suf = max(b.suf, b.sum + a.suf);
    c.sub = max({a.sub, b.sub, a.suf + b.pre});
    return c;
}
void build(int p, int l, int r) {
    if (l == r) { tr[p] = Node(dec_); return; }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
    tr[p] = tr[p << 1] + tr[p << 1 | 1];
}
void modify(int p, int l, int r, int pos, long long v) {
    if (l == r) { tr[p] = Node(v); return; }
    int mid = (l + r) >> 1;
    if (pos <= mid) modify(p << 1, l, mid, pos, v);
    else modify(p << 1 | 1, mid + 1, r, pos, v);
    tr[p] = tr[p << 1] + tr[p << 1 | 1];
}
Node query(int p, int l, int r, int ql, int qr) {
    if (ql <= l && r <= qr) return tr[p];
    int mid = (l + r) >> 1;
    if (qr <= mid) return query(p << 1, l, mid, ql, qr);
    if (ql > mid) return query(p << 1 | 1, mid + 1, r, ql, qr);
    return query(p << 1, l, mid, ql, qr) + query(p << 1 | 1, mid + 1, r, ql, qr);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int S; cin >> S;
    cin >> n >> q >> w0 >> b1 >> b2 >> inc >> dec_;
    // 1. generate modify events
    for (int i = 1; i <= n; ++i) {
        cin >> x[i];
        ev[++tot] = {x[i] - b2, i, dec_, 0};
        ev[++tot] = {x[i] - b1, i, 0, 0};
        ev[++tot] = {x[i] + b1 + 1, i, -inc, 0};
        ev[++tot] = {x[i] + b2 + 1, i, dec_, 0};
    }
    // 2. generate query events
    int cur = 0;
    for (int i = 1; i <= q; ++i) {
        int op; cin >> op;
        if (op == 2) {
            cin >> w0;
        } else {
            ++cur;
            int l, h; cin >> l >> h;
            for (int j = 0, p; j < l; ++j) { cin >> p; like[cur].push_back(p); }
            for (int j = 0, p; j < h; ++j) { cin >> p; hate[cur].push_back(p); }
            ev[++tot] = {w0, cur, 0, 1};
        }
    }
    sort(ev + 1, ev + tot + 1);
    // 3. scan line
    build(1, 1, n);
    for (int i = 1; i <= tot; ++i) {
        auto [x, id, val, type] = ev[i];
        if (type == 0) {
            modify(1, 1, n, id, val + query(1, 1, n, id, id).sum);
        } else {
            // handle query
            long long res = -1e18;
            hate[id].push_back(n + 1);
            sort(like[id].begin(), like[id].end());
            sort(hate[id].begin(), hate[id].end());
            int last = 0, ptr = 0;
            for (int p : like[id]) {
                while (ptr < hate[id].size() && hate[id][ptr] < p) last = hate[id][ptr++];
                int L = last + 1, R = hate[id][ptr] - 1;
                Node left = query(1, 1, n, L, p);
                Node right = query(1, 1, n, p + 1, R);
                res = max(res, left.suf + right.pre);
            }
            ans[id] = res;
        }
    }
    for (int i = 1; i <= cur; ++i) cout << ans[i] << '\n';
    return 0;
}
```
- **代码解读概要**  
  1. 事件排序：把所有“收益变化点”与“询问”按 `w` 排序。  
  2. 线段树：维护区间最大子段和、最大前后缀和，支持单点修改。  
  3. 询问处理：枚举每个喜欢题，用讨厌题把区间切成合法段，合并前后缀。

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：像素探险家·扫描线大冒险
- **场景**：8×n 像素网格，每列是一道题的高度（难度）。  
- **玩法**：  
  1. **事件轨道**：屏幕上方一条从左到右的扫描线（像素小车）沿 `w` 轴移动。  
  2. **事件触发**：当小车经过“事件点”时，对应列的像素方块颜色改变（红=dec，绿=inc，灰=0），播放“叮”的8位音效。  
  3. **区间高亮**：每次询问时，用闪烁的黄色框标出“合法区间”，并动态计算最大子段和，显示在 HUD 上。  
- **交互**：  
  - 空格：单步 / 自动前进  
  - 方向键：加速/减速扫描  
  - R：重置动画  
- **技术**：  
  - Canvas 2D 绘制像素方块  
  - Web Audio API 播放 8-bit 音效  
  - 事件队列用数组模拟，保证帧率 60 FPS

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
1. **离线扫描线**可用于：  
   - 区间并/交/覆盖计数（如 [P5490] 扫描线求矩形面积并）  
   - 动态区间最值（如 [P4587] 动态最大子段和）  
   - 离线二维数点（如 [P4396] 三维偏序）

### 洛谷推荐
| 题号 | 推荐理由 |
|------|----------|
| P5490 | 扫描线经典，矩形面积并 |
| P4587 | 强制在线最大子段和，可与离线对比 |
| P4396 | 离线二维数点，练习事件排序 |

---

## 7. 学习心得与经验分享

> **来自 Dantal10n 的踩坑提醒**  
> “离散化时别忘了先把所有 `w` 值塞进哈希表，否则 `vector` 会炸；线段树 `pushdown` 别忘了更新最大最小值！”  
> **洛语云笺点评**：离散化是离线扫描线的常见前置工作，使用 `unordered_map` 或排序去重皆可，关键是“先收集，后离散”。

---

<conclusion>
本次我们从“分段收益”+“区间限制”出发，一路走到了**离线扫描线+线段树**的最优解。希望这份指南能帮助你掌握“如何把复杂限制转化为离线事件”的核心思维。下次见！
</conclusion>

---
处理用时：99.76秒
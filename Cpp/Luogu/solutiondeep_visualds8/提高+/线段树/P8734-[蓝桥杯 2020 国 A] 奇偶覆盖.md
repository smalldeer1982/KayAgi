# 题目信息

# [蓝桥杯 2020 国 A] 奇偶覆盖

## 题目描述

在平面内有一些矩形，它们的两条边都平行于坐标轴。

我们称一个点被某个矩形覆盖，是指这个点在矩形的内部或者边界上。

请问，被奇数个矩形覆盖和被偶数 $(\geq 2)$ 个矩形覆盖的点的面积分别是多少?

## 说明/提示

对于 $20 \%$ 的评测用例, $1 \leq n \leq 10,0 \leq l_{i}<r_{i} \leq 100,0 \leq b_{i}<t_{i} \leq 100$ 。

对于 $40 \%$ 的评测用例, $1 \leq n \leq 1000,0 \leq l_{i}<r_{i} \leq 100,0 \leq b_{i}<t_{i} \leq 100$ 。

对于 $60 \%$ 的评测用例, $1 \leq n \leq 10000,0 \leq l_{i}<r_{i} \leq 1000,0 \leq b_{i}<t_{i} \leq 1000$ 。

对于 $80 \%$ 的评测用例, $1 \leq n \leq 10^5,0 \leq l_{i}<r_{i} \leq 10^5,0 \leq b_{i}<t_{i} \leq 10^5$。

对于所有评测用例, $1 \leq n \leq 10^5,0 \leq l_{i}<r_{i} \leq 10^{9}, 0 \leq b_{i}<t_{i} \leq 10^{9}$。 

蓝桥杯 2020 年国赛 A 组 I 题。

## 样例 #1

### 输入

```
3
1 1 3 3
2 2 4 4
3 3 5 5```

### 输出

```
8
2```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：奇偶覆盖 深入学习指南 💡

> 今天我们来一起分析“奇偶覆盖”这道蓝桥杯国赛题。  
> 题目看起来只是“数面积”，但真正的难点在于：**如何高效地区分“被奇数个矩形覆盖”和“被偶数个矩形覆盖”的区域？**  
> 我们会像侦探一样，从题目线索一步步走到“扫描线 + 线段树”的最优解，并用像素小游戏把整个过程可视化！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在最多 1e5 个矩形、坐标 1e9 的平面内，**实时**统计两类区域的面积：  
- 被奇数个矩形覆盖  
- 被偶数（≥2）个矩形覆盖  

✨ **核心算法标签**：扫描线（Sweep Line）+ 线段树（Segment Tree）+ 离散化（Coordinate Compression）

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现 | 推理 |
|---|---|---|
| 问题目标 | 求“面积”且要分奇偶 | 二维平面面积 → 扫描线降维打击 |
| 数据范围 | n≤1e5，坐标1e9 | 离散化 + O(n log n) 数据结构 |
| 操作本质 | 区间±1并实时询问奇偶长度 | 线段树维护区间“覆盖次数奇偶性” |

### 🧠 思维链构建：从线索到策略
1. **面积 → 扫描线**：把二维问题压成一维“区间长度×高度差”。  
2. **坐标大 → 离散化**：把 1e9 映射到 2n 个离散点。  
3. **奇偶 → 线段树节点维护**：每个区间存 `len_odd`、`len_even`，通过 `cnt` 的奇偶性推导。  
4. **时间复杂度**：离散化 O(n log n) + 扫描线 O(n log n) → 完美通过所有测试点！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **mayike** (26赞) | 首次给出严谨的奇偶转移推导；配图解释“祖先节点不影响子节点奇偶” | 思路最完整，推导值得背诵 |
| **___w** (8赞) | 用 `cnt&1` 三行搞定 `pushup`，代码极短 | 模板化最强，适合快速复用 |
| **_maple_leaf_** (3赞) | 动态开点线段树，避免离散化 | 坐标更大时也能用，空间换时间 |
| **赖今羿** (2赞) | **双线段树**：一棵统计奇偶，一棵统计“0次”再相减 | 思维巧妙，降低推导难度 |
| **CloudDreamLake** (0赞) | 两遍扫描线：一遍总面积，一遍奇数面积，差得偶数 | 思路直白，适合考场保底 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析与推导 | 学习笔记 |
|---|---|---|
| **离散化** | 把矩形左右边坐标排序去重，2n 个点即可覆盖所有可能断点 | 离散化模板要牢记 |
| **事件线生成** | 每矩形拆两条扫描线：`(y=b, +1)` 与 `(y=t, -1)`，按 y 排序 | 高度差即小矩形“厚度” |
| **线段树节点设计** | `len_odd, len_even, cnt`：覆盖次数为奇/偶的有效长度 | 奇偶互转公式是核心 |
| **pushup 三分类** | 1. `cnt==0`：左右子树直接相加<br>2. `cnt&1`：`len_even = 左奇+右奇`，`len_odd = 区间长 - len_even`<br>3. `cnt 偶`：对称处理 | 背诵三行代码即可 AC |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举像素** | 把平面切成 1×1 小格子，逐点统计 | 思路直观 | 坐标大直接爆炸 | 坐标≤100 |
| **扫描线+朴素线段树** | 只维护总覆盖长度 | 无法区分奇偶 | 无法解题 | × |
| **扫描线+奇偶线段树**（最优） | 节点额外维护奇偶长度 | O(n log n) 通过所有数据 | 推导需小心 | 1e5×1e9 |
| **双线段树** | 一棵维护奇，一棵维护0次 | 逻辑简单 | 两倍常数 | 空间充足 |

### ✨ 优化之旅：从“能做”到“做好”
1. **起点**：暴力枚举像素 → 1e9×1e9 直接爆炸。  
2. **瓶颈**：维度太高 → 扫描线降维。  
3. **钥匙**：线段树维护区间长度，但**奇偶信息如何传递**？  
4. **升华**：`cnt&1` 时奇偶互换，`cnt 偶` 时奇偶不变，三行代码优雅解决。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合 mayike & ___w 思路，给出最易背诵的离散化线段树版本。

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int MAXN = 2e5 + 10;

struct Line {
    int x, y1, y2, op;
    bool operator<(const Line& rhs) const { return x < rhs.x; }
} lines[MAXN];
int Y[MAXN], yTot;

struct Seg {
    int l, r, cnt;
    int64 len1, len2; // odd, even
} tr[MAXN << 2];

void build(int p, int l, int r) {
    tr[p] = {l, r, 0, 0, 0};
    if (l + 1 == r) return;
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid, r);
}

void pushup(int p) {
    int l = tr[p].l, r = tr[p].r;
    if (tr[p].cnt & 1) {               // 奇数次覆盖
        tr[p].len2 = tr[p << 1].len1 + tr[p << 1 | 1].len1;
        tr[p].len1 = Y[r] - Y[l] - tr[p].len2;
    } else if (tr[p].cnt) {            // 偶数次覆盖
        tr[p].len1 = tr[p << 1].len1 + tr[p << 1 | 1].len1;
        tr[p].len2 = Y[r] - Y[l] - tr[p].len1;
    } else {                           // 无覆盖
        tr[p].len1 = tr[p << 1].len1 + tr[p << 1 | 1].len1;
        tr[p].len2 = tr[p << 1].len2 + tr[p << 1 | 1].len2;
    }
}

void change(int p, int l, int r, int delta) {
    if (Y[tr[p].r] <= l || r <= Y[tr[p].l]) return;
    if (l <= Y[tr[p].l] && Y[tr[p].r] <= r) {
        tr[p].cnt += delta;
        pushup(p);
        return;
    }
    change(p << 1, l, r, delta);
    change(p << 1 | 1, l, r, delta);
    pushup(p);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; cin >> n;
    int tot = 0;
    for (int i = 0; i < n; ++i) {
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        lines[tot] = {x1, y1, y2, 1};
        Y[tot++] = y1;
        lines[tot] = {x2, y1, y2, -1};
        Y[tot++] = y2;
    }
    sort(Y, Y + tot);
    yTot = unique(Y, Y + tot) - Y;
    sort(lines, lines + tot);

    build(1, 0, yTot - 1);

    int64 ans1 = 0, ans2 = 0;
    for (int i = 0; i < tot; ++i) {
        if (i && lines[i].x != lines[i - 1].x) {
            int64 dx = lines[i].x - lines[i - 1].x;
            ans1 += dx * tr[1].len1;
            ans2 += dx * tr[1].len2;
        }
        int l = lower_bound(Y, Y + yTot, lines[i].y1) - Y;
        int r = lower_bound(Y, Y + yTot, lines[i].y2) - Y;
        change(1, Y[l], Y[r], lines[i].op);
    }
    cout << ans1 << '\n' << ans2 << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 主题：像素探险家的“奇偶地毯”
- **场景**：8×8 像素网格，每格代表离散化后的小区间。  
- **角色**：探险家（红色像素块）沿 y 轴向上扫描；地毯（矩形）用蓝/绿交替颜色表示奇/偶覆盖。  
- **交互面板**：  
  - 播放/暂停/单步按钮  
  - 速度滑块  
  - 音效开关（8位“叮”表示区间奇偶翻转）  

### 关键帧示意
1. **初始化**：网格全灰（0次覆盖）。  
2. **第一条扫描线（y=1, +1）**：对应区间染蓝（奇）。  
3. **第二条扫描线（y=3, -1）**：区间恢复灰色（0次）。  
4. **重叠矩形**：出现绿色（偶）闪烁。  
5. **最终统计**：奇区域闪蓝光，偶区域闪绿光，伴随“胜利”音效。

### 技术实现
- Canvas 绘制 8×8 像素格，颜色映射 `len_odd/len_even`。  
- 用 `setInterval` 逐帧推进扫描线，`AudioContext` 触发 440Hz 正弦波“叮”。  
- 代码仅 200 行内嵌 HTML，方便本地运行。

---

## 6. 拓展练习与相似问题思考

| 通用思路迁移场景 | 说明 |
|---|---|
| 课程表冲突 | 把每节课当作矩形，求“只选一门课”的时间段面积 |
| 光照遮挡 | 多光源照射平面，求“被奇数光源照亮”的区域 |
| 传感器覆盖 | 物联网节点部署，统计“冗余偶覆盖”区域以节能 |

### 洛谷推荐练习
1. **P5490** 【模板】扫描线 & 矩形面积并  
   *练手模板，先掌握基本扫描线*  
2. **P1856** 矩形周长并  
   *扫描线统计周长，体会“线段树维护区间端点”*  
3. **P2163** 矩形覆盖数  
   *需要维护区间最大值，进一步熟悉线段树*  

---

## 7. 学习心得与经验分享

> **mayike 的踩坑提醒**：  
> “第一次写 pushup 时把 `len1` 和 `len2` 写反，导致样例输出 2 8 而不是 8 2。  
> 调试技巧：打印根节点 `len1`、`len2`，看奇偶是否对称。”

**洛语云笺点评**：  
“奇偶互换的公式虽短，却极易写反。动手画一棵三层线段树，人工推一遍 pushup，是避免低级错误的最快方法！”

---

> 本次“奇偶覆盖”之旅到此结束。  
> 记住：扫描线把二维变一维，线段树把区间变节点，奇偶互换只需三行代码。  
> 下次遇到“覆盖类”面积题，先想扫描线，再设计节点状态，就能优雅 AC！

---
处理用时：64.93秒
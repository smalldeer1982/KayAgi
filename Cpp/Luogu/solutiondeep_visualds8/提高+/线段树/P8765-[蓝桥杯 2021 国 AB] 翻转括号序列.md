# 题目信息

# [蓝桥杯 2021 国 AB] 翻转括号序列

## 题目描述

给定一个长度为 $n$ 的括号序列，要求支持两种操作:

1. 将 $\left[L_{i}, R_{i}\right]$ 区间内（序列中的第 $L_{i}$ 个字符到第 $R_{i}$ 个字符）的括号全部翻转(左括号变成右括号，右括号变成左括号)。

2. 求出以 $L_{i}$ 为左端点时，最长的合法括号序列对应的 $R_{i}$ （即找出最大的 $R_{i}$ 使 $\left[L_{i}, R_{i}\right]$ 是一个合法括号序列）。

## 说明/提示

对于 $20 \%$ 的评测用例，$n, m \leq 5000$;

对于 $40 \%$ 的评测用例，$n, m \leq 30000$;

对于 $60 \%$ 的评测用例，$n, m \leq 100000$;

对于所有评测用例，$1 \leq n \leq 10^{6}, 1 \leq m \leq 2 \times 10^{5}$ 。 

蓝桥杯 2021 国赛 A 组 H 题（B 组 I 题）。

## 样例 #1

### 输入

```
7 5
((())()
2 3
2 2
1 3 5
2 3
2 1```

### 输出

```
4
7
0
0```

# AI分析结果

💡 洛语云笺的C++算法解析：蓝桥杯 2021 国 AB《翻转括号序列》深入学习指南 💡  
> 今天我们来拆解一道“括号大冒险”——区间翻转 + 最长合法括号序列查询。题目乍看像字符串，其实是披着括号外衣的**线段树**难题。准备好像素望远镜，一起追踪线索！

---

## 1. 题目解读与策略初探

✨ **核心挑战**：  
> 在 **10⁶ 长度** 的括号序列上，既要 **O(log n) 区间翻转**，又要 **O(log n) 回答“从给定 L 出发的最长合法右端点 R”**。暴力会 TLE，必须借助数据结构！

✨ **算法标签**：线段树（区间修改 + 区间最值 + 二分）  

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现 & 指向 |
|---|---|
| **区间翻转** | 典型**区间乘 -1** 操作，线段树懒标记即可支持。 |
| **合法括号判定** | 经典套路：把 '(' 看成 +1，')' 看成 -1，合法 ⇔ 区间和 = 0 且 **任意前缀和 ≥ 0**。 |
| **最长右端点** | 固定 L 后，前缀和单调不增 ⇒ 可**线段树上二分**找最右满足条件的 R。 |
| **数据范围** | n ≤ 10⁶, m ≤ 2×10⁵ ⇒ **O(m log n)** 可行，**O(m log² n)** 也能过。 |

---

### 🧠 思维链构建：从线索到策略
> 1. 看到区间操作 ⇒ 线段树/树状数组；  
> 2. 看到“合法括号” ⇒ 前缀和 + 非负约束；  
> 3. 看到“最长右端点” ⇒ **二分 + 区间最值查询**；  
> 4. 看到“翻转” ⇒ **区间乘 -1**，同时交换 min ↔ max 维护非负信息。  
> **结论**：用一棵维护 **区间和、区间最小前缀和、区间最大前缀和** 的线段树即可解决全部需求！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 星级 |
|---|---|---|
| **Wf_yjqd** | 最早给出**前缀和 + 线段树 + 二分**完整思路；懒标记处理“区间翻转”技巧简洁。 | ★★★★★ |
| **Ristear** | 用**区间最小前缀和单调性**做二分，逻辑清晰；代码风格清爽。 | ★★★★☆ |
| **zhangchengqi666** | 萌新视角讲解，强调**pushup/pushdown**细节；代码完整，适合对照调试。 | ★★★★ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

1. **如何表示括号？**  
   - 把 '(' → +1，')' → -1，得到整数数组 `a[]`。  
   - 前缀和 `sum[i] = sum[i-1] + a[i]`。  
   - 区间 `[L,R]` 合法 ⇔  
     • `sum[R] - sum[L-1] = 0`  
     • 任意 `i ∈ [L,R]`，`sum[i] - sum[L-1] ≥ 0`

2. **线段树节点要存什么？**  
   - `sum`：区间和  
   - `mn`：区间最小前缀和  
   - `mx`：区间最大前缀和（翻转时需交换）  
   - `tag`：乘法懒标记（初始 1，翻转即 × -1）  

3. **如何翻转区间 [l,r]？**  
   - 把 `[l,r]` 整体 × -1，同时交换 `mn ↔ -mx`，更新懒标记。  
   - 由于翻转会影响 `sum[i]` 的相对关系，需用**两棵线段树**或**两次单点修改**（Wf_yjqd 做法）或**懒标记统一处理**（Ristear / zhangchengqi666 做法）。

4. **如何查询最长合法右端点？**  
   - 固定 L，二分 R：  
     • 区间 `[L,R]` 的 `mn ≥ 0`（保证非负前缀）  
     • 区间 `[L,R]` 的 `sum = 0`（保证平衡）  
   - 由于 `mn` 单调不增，可用**线段树上二分**或**普通二分 + 区间查询**，复杂度 O(log n)。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力** | 直接扫描区间，O(n) 判定合法 | 实现简单 | O(m n) 超时 | n≤5000，20% 分 |
| **树状数组 + 二分** | 用 BIT 维护区间和与区间最小前缀和 | 代码短 | 需手写二维 BIT 或分块，难调 | n≤3e4，40% 分 |
| **线段树 + 二分（最优）** | 一棵线段树维护 sum/mn/mx，懒标记支持翻转 | O(m log n)，满分 | 细节多，需严谨 pushdown | n≤1e6，100% 分 |

---

### ✨ 优化之旅：从“能做”到“做好”
> 起点：暴力 O(n) 判定 → 发现瓶颈在区间信息查询  
> 关键：将“合法括号”抽象成**区间和 + 区间最小前缀和** → 线段树统一维护  
> 升华：翻转操作转化为**区间乘 -1 + 交换 min/max**，懒标记一次完成  
> 结果：O(m log n) 优雅通过！

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合 zhangchengqi666 与 Ristear 思路，提供**单棵线段树**版本，易读易改。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 10;
int n, m, a[N];

struct Node {
    int l, r;
    long long sum, mn, mx, tag = 1;   // tag=1 表示未翻转
} t[N << 2];

inline void apply(int p, long long v) {
    t[p].sum *= v;
    t[p].mn *= v;
    t[p].mx *= v;
    if (v == -1) swap(t[p].mn, t[p].mx);
    t[p].tag *= v;
}

inline void pushup(int p) {
    t[p].sum = t[p << 1].sum + t[p << 1 | 1].sum;
    t[p].mn = min(t[p << 1].mn, t[p << 1].sum + t[p << 1 | 1].mn);
    t[p].mx = max(t[p << 1].mx, t[p << 1].sum + t[p << 1 | 1].mx);
}

inline void pushdown(int p) {
    if (t[p].tag != 1) {
        apply(p << 1, t[p].tag);
        apply(p << 1 | 1, t[p].tag);
        t[p].tag = 1;
    }
}

void build(int p, int l, int r) {
    t[p].l = l, t[p].r = r;
    if (l == r) {
        t[p].sum = t[p].mn = t[p].mx = a[l];
        return;
    }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid);
    build(p << 1 | 1, mid + 1, r);
    pushup(p);
}

void modify(int p, int l, int r) {
    if (l <= t[p].l && t[p].r <= r) {
        apply(p, -1);
        return;
    }
    pushdown(p);
    int mid = (t[p].l + t[p].r) >> 1;
    if (l <= mid) modify(p << 1, l, r);
    if (r > mid) modify(p << 1 | 1, l, r);
    pushup(p);
}

long long query_sum(int p, int l, int r) {
    if (l <= t[p].l && t[p].r <= r) return t[p].sum;
    pushdown(p);
    int mid = (t[p].l + t[p].r) >> 1;
    long long res = 0;
    if (l <= mid) res += query_sum(p << 1, l, r);
    if (r > mid) res += query_sum(p << 1 | 1, l, r);
    return res;
}

long long query_min(int p, int l, int r, long long add = 0) {
    if (l <= t[p].l && t[p].r <= r) return t[p].mn + add;
    pushdown(p);
    int mid = (t[p].l + t[p].r) >> 1;
    long long res = 1e18;
    if (l <= mid) res = min(res, query_min(p << 1, l, r, add));
    if (r > mid) res = min(res, query_min(p << 1 | 1, l, r, add + query_sum(p << 1, l, r)));
    return res;
}

int solve(int L) {
    if (a[L] == -1) return 0;          // 右括号开头直接不合法
    int l = L, r = n, ans = 0;
    while (l <= r) {
        int mid = (l + r) >> 1;
        if (query_min(1, L, mid) >= 0) {
            ans = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    if (!ans) return 0;
    long long total = query_sum(1, L, ans);
    if (total != 0) return 0;
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        char c; cin >> c;
        a[i] = (c == '(' ? 1 : -1);
    }
    build(1, 1, n);
    while (m--) {
        int op, l, r;
        cin >> op >> l;
        if (op == 1) {
            cin >> r;
            modify(1, l, r);
        } else {
            cout << solve(l) << '\n';
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**主题**：8 位像素风“括号探险”  
**核心**：线段树区间翻转 + 二分找合法右端点

| 帧 | 像素化元素 | 音效/交互 |
|---|---|---|
| **初始化** | 用 2×2 像素块表示每个字符 `(` / `)`，颜色绿/红 | 8-bit 背景 BGM |
| **翻转区间 [l,r]** | 像素块闪烁 → 颜色互换 → 播放“翻转”音效 | 按空格单步，滑块调速 |
| **二分找 R** | 高亮当前 `[L,R]` 区间，实时显示 `mn,sum` 值 | 成功找到合法右端点时播放“胜利”音 |
| **AI 演示** | 自动执行全部 m 次操作，像“贪吃蛇”一样展示最优路径 | ESC 暂停，R 重置 |

---

## 6. 拓展练习与相似问题思考

| 通用技巧迁移 | 场景示例 |
|---|---|
| **区间乘 -1 + 懒标记** | 区间取反、区间颜色反转 |
| **前缀和 + 区间最值** | 最大子段和、区间最小非负前缀 |
| **二分 + 数据结构** | 在线段树上二分找分界点 |

**洛谷推荐**  
1. **P3372** 【模板】线段树 1 – 巩固懒标记  
2. **P3373** 【模板】线段树 2 – 乘法+加法标记  
3. **P4145** 花神游历各国 – 区间开方+区间和  
4. **P4513** 小白逛公园 – 最大子段和在线段树上维护  

---

## 7. 学习心得与经验分享

> **zhangchengqi666**：“我在 pushdown 时忘记 `swap(mn,mx)`，导致答案错误，调试了整整一晚。建议每次写完线段树，**用随机数据 + 暴力对拍**，确保懒标记顺序正确。”  
> **洛语云笺点评**：线段树易错点在**标记顺序与符号反转**，务必手画小例子验证！

---

### 💪 结语
从暴力到线段树，我们完成了“括号世界”的探险。记住：**把问题抽象成前缀和与区间最值，是破解括号类题目的金钥匙**。下次再见！

---
处理用时：109.89秒
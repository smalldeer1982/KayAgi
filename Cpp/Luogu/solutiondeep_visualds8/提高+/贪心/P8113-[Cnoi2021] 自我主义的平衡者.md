# 题目信息

# [Cnoi2021] 自我主义的平衡者

## 题目背景

「流浪月球 ~ The Wandering Moon」在幻想乡上映了。

正如一千个人心中有一千个哈姆雷特，关于它的争议也在悄然蔓延。

不知何时起，一个叫做「花瓣」的平台出现，慢慢取代了市井之中的讨论声，成为了争议的主战场——因为它具有评分功能。平台上旁征博引、各抒己见的评分帖成为了幻想乡的居民们日常，一切看起来岁月静好。

直到平衡者的出现。

起初没有人在意在意这缕杂音，这只不过是一种无心的叛逆，一点无奈的情感，一次无聊的宣泄。直到平衡的思想深入人心，自我主义的狂潮达到顶峰，评分系统的秩序几近崩溃。

Cirno 觉得自己该做些什么了。

## 题目描述

Cirno 决定通过计算来说服与拯救被自我主义裹挟的众人。

参与评分的共有 $n$ 位居民，平台限制的最高分为 $m$。

每个居民在评分前都有一个心理预期分数 $a_i(a_i\in[0,m]\cap\mathbb{Z})$。

但人们并不会按照心理预期分数直接评分，而是当当前平台上的平均分严格高于自己的心理预期分数时，便评分道「分数太高了，打个 $0$ 分平衡一下」，反之则说「分数太低了，打个满分（$m$分）平衡一下」。

初始时平台上的平均分为 $0$。

为了证明这种评分方式对公平的破坏性，Cirno 希望你计算出这 $n$ 位居民在不同的排列顺序下评分，平台上最终平均分可能的最大值与最小值。

## 说明/提示

**数据范围与约定**

对于 $100\%$ 的数据保证，$1 < n,m\le 10^5$，$a_i \in [0,m]$。

**子任务**

Subtask1（10 points）：$n \le 8$。

Subtask2（10 points）：$n \le 20$。

Subtask3（30 points）：$n \le 10^3$。

Subtask4（50 points）：无特殊限制。

## 样例 #1

### 输入

```
5 5
1 2 3 4 5```

### 输出

```
4.00 2.00```

## 样例 #2

### 输入

```
7 114
23 75 35 17 101 55 73```

### 输出

```
81.43 32.57```

# AI分析结果


# 💡 洛语云笺的C++算法解析：自我主义的平衡者 深入学习指南 💡

## 1. 题目解读与策略初探

✨ **本题核心挑战**：处理评分系统的动态依赖关系——每个居民的评分决策取决于前面所有居民评分的平均值，同时需要在不同排列顺序下求得最终平均分的极值。

✨ **核心算法标签**：贪心算法、排序

🗣️ **初步分析**：
> 本题要求我们通过调整居民评分顺序，使最终平均分最大或最小。最直观的暴力解法是枚举所有排列（O(n!)），但数据规模（n≤10⁵）使其完全不可行。通过分析题目特性，我们发现：
> - 每个居民评分只取决于当前平均分与其心理预期的关系
> - 最终平均分完全由评满分（m分）的人数决定
> 
> 这引导我们思考贪心策略：通过特定排序方式，系统性地控制评满分的人数。最优解采用升序排列求最大值，降序排列求最小值，时间复杂度优化至O(n log n)。

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**: "求最终平均分的最大值与最小值"——典型的**最优化问题**，暗示可能需要贪心或动态规划。
2.  **线索2 (问题特性)**: "当前平均分影响后续决策"——存在**时序依赖关系**，提示我们需要通过排序控制决策顺序。
3.  **线索3 (数据规模)**: "n≤10⁵"——要求O(n log n)算法，**排序+线性扫描**成为可行方案。

### 🧠 思维链构建：从线索到策略
> "综合线索：
> 1. 最优化目标指向贪心算法
> 2. 决策依赖关系提示排序预处理
> 3. 数据规模排除暴力枚举
> 
> **结论**：将居民按心理预期排序后模拟评分过程，是兼顾效率和正确性的最优策略。升序最大化满分人数，降序最小化满分人数。"

---

## 2. 精选优质题解参考

**题解一（peppaking8）**
* **点评**：直击问题核心，用邻项交换法严谨证明排序策略的正确性。代码实现简洁高效（两次排序+单次扫描），使用`long long`避免溢出，输出规范。特别亮点在于用数学归纳法将复杂依赖关系转化为可证明的贪心策略。

**题解二（Code_星云）**
* **点评**：详细分类讨论不同情况下的决策影响，补充了边界条件处理。代码引入`fabs`比较解决浮点精度问题，虽增加少量计算但提升鲁棒性。对青少年学习者理解浮点运算有重要参考价值。

**题解三（Dr_Gilbert）**
* **点评**：采用故事化叙述解析证明过程，将抽象问题具象化为"拉票"模型。代码结构清晰，关键步骤有注释说明，特别强调`double`精度限制的实战经验，对竞赛调试具有启发意义。

**题解四（eEfiuys）**
* **点评**：最简洁高效的实现典范，仅20行代码完成核心逻辑。亮点在于用总分代替平均分比较（`(ll)a[i]*(i-1) >= num`），彻底规避浮点误差。函数封装规范，适合作为竞赛模板参考。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1.  **难点：依赖关系建模**
    * **分析**：每个决策影响后续所有决策，形成链式反应。通过预排序将动态依赖转化为静态序列，使后续决策仅与当前总分相关。
    * 💡 **学习笔记**：将时序依赖转化为空间序列是处理动态决策的常用技巧。

2.  **难点：贪心策略证明**
    * **分析**：使用邻项交换法证明：对任意相邻对(i,j)且aᵢ>aⱼ，交换后评满分人数不会增加（最大值情形）。分四种情况讨论当前平均分与预期值关系，覆盖所有可能性。
    * 💡 **学习笔记**：贪心问题中，邻项交换法如同"微观经济学"，通过局部最优推导全局最优。

3.  **难点：精度控制**
    * **分析**：避免浮点比较的两种方案：(1)用整数算式`a[i]*(i-1) >= sum`替代浮点除；(2)设置误差容限`fabs(x-y)<eps`。
    * 💡 **学习笔记**：竞赛中优先使用整数运算，必须用浮点时设定误差阈值。

### ✨ 解题技巧总结
- **问题转化**：将动态评分转化为静态序列处理
- **规避浮点误差**：整数乘法替代除法比较
- **贪心证明**：邻项交换法覆盖所有情况
- **代码优化**：`long long`防溢出，`greater<int>()`实现降序

### ⚔️ 策略竞技场：解法对比
| 策略          | 核心思想               | 优点               | 缺点                  | 得分预期 |
|---------------|------------------------|--------------------|-----------------------|----------|
| **暴力枚举**  | 全排列+模拟           | 保证正确           | O(n!)超时            | 10%      |
| **贪心+排序** | 升序/降序后线性扫描    | O(n log n)高效     | 需严谨证明           | 100%     |

### ✨ 优化之旅：从暴力到贪心
> 1. **起点：暴力枚举**  
>   尝试所有排列顺序，计算最终平均分，但n>20即超时
>   
> 2. **发现瓶颈：重复状态**  
>   不同排列产生相同的前缀总分时，后续决策完全相同
>   
> 3. **关键洞察：决策独立性**  
>   当固定前缀总分时，后续决策与具体排列无关
>   
> 4. **优化突破：排序预处理**  
>   通过排序系统性地控制前缀总分的增长趋势
> 
> 💡 **策略总结**："从O(n!)到O(n log n)的飞跃，源于将指数级状态空间压缩为线性有序序列，这正是算法之美！"

---

## 4. C++核心代码实现赏析

**通用核心实现**  
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5+5;

int main() {
    int n, m, a[N];
    scanf("%d%d", &n, &m);
    for(int i=1; i<=n; ++i) scanf("%d", a+i);

    // 求最大值：升序排列
    sort(a+1, a+n+1);
    ll sum_max = 0;
    for(int i=1; i<=n; ++i)
        if(sum_max <= 1LL * a[i] * (i-1))
            sum_max += m;

    // 求最小值：降序排列
    sort(a+1, a+n+1, greater<int>());
    ll sum_min = 0;
    for(int i=1; i<=n; ++i)
        if(sum_min <= 1LL * a[i] * (i-1))
            sum_min += m;

    printf("%.2f %.2f\n", 
        1.0*sum_max/n, 1.0*sum_min/n);
    return 0;
}
```
**代码解读**：  
1. 读入数据后两次排序（升序/降序）  
2. 线性扫描时用`a[i]*(i-1)`与当前总分比较  
3. 满足条件时累加m分  
4. 最终输出平均值（注意整数转浮点）  

---

## 5. 算法可视化：像素动画演示

* **主题**：像素平衡者闯关记  
* **核心演示**：居民按心理预期排队，根据当前平均分触发不同评分行为  

* **像素设计**：  
  - 居民：8-bit像素小人，头顶显示预期分数  
  - 进度条：显示当前平均分（像素柱状图）  
  - 决策特效：评满分时绿光+“叮”声，评0分时红光+“噗”声  

* **交互设计**：  
  1. **初始化**：居民随机站立，控制面板（开始/步进/重置）  
  ```javascript
  // 伪代码：居民初始化
  for(i=0; i<n; i++){
      sprite[i] = new PixelCitizen(a[i]);
      sprite[i].position = randomGridPos();
  }
  ```
  
  2. **排序阶段**：居民按预期值重新排队（像素动画）  
  ```javascript
  sortSprites((a,b)=>a.value-b.value); // 升序排列
  ```

  3. **评分阶段**：  
     - 高亮当前居民，显示比较算式：`总分 vs a_i*(i-1)`  
     - 满足条件：居民跳起+绿光，总分增加  
     - 否则：居民蹲下+红光，总分不变  
     - 实时更新平均分进度条  

  4. **游戏化**：  
     - 每10人为一关，通关解锁新场景  
     - 评分结果生成战力值，挑战最终BOSS  

---

## 6. 拓展练习与相似问题

* **技巧迁移**：  
  1. 任务调度（最短平均等待时间）  
  2. 资源分配（最大满意度）  
  3. 队列优化（最小化总延迟）  

* **洛谷推荐**：  
  1. **P1223 排队接水**  
     🗣️ 同类贪心+排序策略，巩固基础  
  2. **P1803 凌乱的yyy**  
     🗣️ 强化时序依赖问题的建模能力  
  3. **P5019 铺设道路**  
     🗣️ 贪心策略的变式应用，培养问题转化思维  

---

## 7. 学习心得分享

> "多位作者强调：不要轻易否定第一直觉！本题中‘排序’的直觉虽简单，但需严谨证明才能成为可靠策略。  
> 调试时注意：当n>10⁴时，必须用整数比较避免浮点误差——这是血泪教训！"

---

> 掌握贪心算法的核心在于**洞察问题本质**和**严谨证明**。记住：优秀的算法往往简洁而深刻，如同这道题展现的智慧。下次遇到最优化问题，不妨自问：排序能否创造奇迹？

---
处理用时：191.86秒
# 题目信息

# [PA 2020] Miny

## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 3 [Miny](https://sio2.mimuw.edu.pl/c/pa-2020-1/min/)**

$n$ 枚地雷被运到 Bytau 的军事训练场，并沿一条直线埋设。每个地雷位于不同的地方，并且有自己的爆炸半径。当引爆时，地雷会自动引爆其爆炸半径内所有尚未爆炸的地雷。如果地雷 $a$ 和地雷 $b$ 之间的距离不超过地雷 $b$ 的爆炸半径，则我们称地雷 $a$ 在地雷 $b$ 的爆炸半径内。

Bytomir 中士想进行一项实验。他选择了一个任意的地雷子集（也许是空的），并让这个地雷子集内的所有地雷在同时手动引爆。实验的结果是一组已经爆炸的地雷——要么是手动引爆的引起的爆炸，要么是其他地雷爆炸导致的爆炸。

Bytomir 能得到多少种可能的实验结果？如果两个实验结果中爆炸的地雷相同，则这两个实验结果是相同的。由于结果可能很大，请输出它除以 $10^9+7$ 的余数。

## 说明/提示

#### 样例 1 解释

你可以得到 $7$ 种可能的实验结果：

- $\{\}$（空集）：如果不引爆任何地雷；
- $\{1,2\}$（地雷 $1,2$）：如果我们只引爆地雷 $1$；
- $\{1,2,3\}$：如果我们引爆地雷 $1$ 和 $3$；
- $\{1,2,3,4\}$：如果我们引爆地雷 $1$ 和 $4$；
- $\{2\}$：如果我们只引爆地雷 $2$；
- $\{2,3\}$：如果我们只引爆地雷 $3$；
- $\{2,3,4\}$：如果我们只引爆地雷 $4$；

请注意，可以通过不同的方式得到同一个实验结果——例如，如果我们引爆地雷 $1$ 和 $2$，也会得到 $\{1, 2\}$ 的结果。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n\le 3\times 10^5$，$0\le a_i,r_i\le 10^{18}$。

## 样例 #1

### 输入

```
4
0 2
2 0
3 2
7 4```

### 输出

```
7```

# AI分析结果


### 💡 洛语云笺的C++算法解析：PA 2020 Miny 深入学习指南 💡

#### 题目解读与策略初探
✨ **本题核心挑战**：处理地雷间的连锁爆炸依赖关系，在任意手动引爆子集下计算所有可能的爆炸结果数（模 $10^9+7$）。  
✨ **核心算法标签**：动态规划（DP）、区间合并、分治优化、单调栈  

🗣️ **初步分析**：  
> 本题要求计算所有可能的爆炸组合，关键在于处理连锁反应：引爆一个地雷可能触发其爆炸半径内的其他地雷。  
> **暴力枚举**（$O(2^n)$）因 $n \leq 3\times 10^5$ 必然超时。  
> **核心突破口**：动态规划！通过定义状态 $f_i$ 表示“前 $i$ 个地雷中强制第 $i$ 个不爆炸的方案数”，将问题转化为区间覆盖和转移优化问题。  
> **算法比喻**：像扫雷游戏中的“安全区标记”——$f_i$ 是地雷 $i$ 作为安全边界时，左侧所有可能的爆炸模式总数。

---

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**：求“所有可能爆炸集合的数量”，涉及**状态组合与依赖传递**，是动态规划的典型场景。
2.  **线索2 (问题特性)**：地雷爆炸具有**连锁反应**（一个引爆触发多个），需处理区间覆盖和依赖关系，指向**区间合并与单调栈优化**。
3.  **线索3 (数据规模)**：$n \leq 3\times 10^5$ 要求 $O(n \log n)$ 解法，排除暴力枚举，**分治或树状数组优化**成为必然选择。

### 🧠 思维链构建：从线索到策略
> 1.  **目标分析**：求爆炸集合总数 → 需高效枚举所有合法状态组合 → DP 是首选。
> 2.  **依赖处理**：连锁爆炸形成区间覆盖关系 → 用单调栈预处理每个地雷的左右边界（$L_i$, $R_i$）。
> 3.  **复杂度优化**：$n$ 极大 → 转移需 $O(\log n)$ 完成 → 分治或树状数组加速求和。
> 4.  **最终策略**：**动态规划 + 边界预处理 + 树状数组/分治优化**，时间复杂度 $O(n \log n)$。

---

### 2. 精选优质题解参考
**题解一（作者：CmsMartin）**  
* **点评**：  
  - 思路清晰：用单调栈预处理 $L_i$（左边最近能引爆 $i$ 的地雷）和 $R_i$（右边最近能引爆 $i$ 的地雷），定义 $f_i$ 为强制 $i$ 不爆炸的方案数。  
  - 算法优化：通过树状数组维护 $f_j$ 的和，当 $R_j < i$ 时移除无效状态，实现高效转移 $f_i = \sum_{j=L_i}^{i-1} f_j$。  
  - 代码亮点：边界处理严谨（添加虚拟地雷 $0$ 和 $n+1$），利用 `lambda` 简化栈操作，逻辑模块化易调试。

**题解二（作者：Sol1）**  
* **点评**：  
  - 分治优化：将区间 $[l, r]$ 分为两半，计算左半区间对右半的贡献。  
  - 转移条件：通过维护左区间并集 $[L_i, R_i]$ 和右区间并集 $[L_j, R_j]$，用双指针筛选合法转移对 $(i,j)$。  
  - 实现技巧：前缀和加速区间求和，实时维护爆炸范围极值，避免重复计算。

---

### 3. 解题策略深度剖析
#### 🎯 核心难点与关键步骤
1.  **依赖关系建模**  
    * **分析**：地雷 $i$ 能否被引爆取决于其左右边界 $L_i$ 和 $R_i$。$L_i$ 是左侧最近能覆盖 $i$ 的地雷，$R_i$ 是右侧最近能覆盖 $i$ 的地雷。  
    * 💡 **学习笔记**：单调栈可在 $O(n)$ 内求出所有 $L_i$ 和 $R_i$，是处理区间覆盖问题的利器。

2.  **DP 状态转移**  
    * **分析**：$f_i$ 表示强制 $i$ 不爆炸时前 $i$ 个地雷的方案数。转移需满足：  
      $j \in [L_i, i-1]$ 且 $R_j \geq i$（确保 $j$ 和 $i$ 之间无地雷能引爆二者）。  
    * 💡 **学习笔记**：树状数组维护满足 $R_j \geq i$ 的 $f_j$ 和，实现 $O(\log n)$ 转移。

3.  **分治优化替代**  
    * **分析**：将区间分成两半，左半 $[l, mid]$ 对右半 $[mid+1, r]$ 转移。合法转移需满足：  
      - 左区间并集不覆盖 $a_i$ 或 $a_j$。  
      - 右区间并集不覆盖 $a_i$ 或 $a_j$。  
    * 💡 **学习笔记**：双指针维护 $rs_i < a_j$ 和 $a_i < lt$ 的区间，前缀和加速统计。

#### ✨ 解题技巧总结
- **技巧1：虚拟边界**：添加 $a_0 = -\infty$ 和 $a_{n+1} = +\infty$ 简化代码，避免边界特判。  
- **技巧2：区间并集极值**：用 $\min(a_k - r_k)$ 和 $\max(a_k + r_k)$ 表示区间并集，将非连续覆盖转化为区间判断。  
- **技巧3：分治转移筛选**：双指针维护合法转移区间，结合前缀和实现线性转移。  

#### ⚔️ 策略竞技场：不同解法对比
| 策略             | 核心思想                     | 优点                          | 缺点与分析                                  | 得分预期       |
|------------------|----------------------------|------------------------------|------------------------------------------|---------------|
| **暴力枚举**     | 枚举所有子集，模拟爆炸过程    | 思路直观，易实现              | 时间复杂度 $O(2^n)$，$n \geq 30$ 即超时   | $0$%          |
| **树状数组 DP**  | $f_i = \sum_{j=L_i}^{i-1} f_j$ | 代码简洁，边界处理清晰        | 需预处理 $L_i/R_i$，理解转移条件有难度     | 100%          |
| **分治优化 DP**  | 左区间贡献右区间，双指针筛选  | 避免预处理，适合区间动态问题  | 分治递归开销大，常数较高                  | 100%          |

#### ✨ 优化之旅：从“能做”到“做好”
1.  **起点：暴力枚举的困境**  
    尝试所有 $2^n$ 种子集，但 $n=30$ 时已需 $10^9$ 次计算，完全不可行。  
2.  **关键跃迁：动态规划**  
    定义 $f_i$ 表示“前 $i$ 个地雷中 $i$ 不爆炸的方案数”，将指数问题转化为多项式转移。  
3.  **优化加速：树状数组/分治**  
    - 树状数组：高效维护满足 $R_j \geq i$ 的 $f_j$ 和。  
    - 分治：将转移拆分为左右区间，双指针剔除非法状态。  
4.  **思维升华：依赖转化为边界**  
    用 $L_i/R_i$ 将连锁爆炸转化为区间覆盖问题，模型简洁且高效。  

💡 **策略总结**：从暴力到 DP 是思维的质变，从朴素 DP 到树状数组/分治优化是工程的精进。两种 $O(n \log n)$ 解法各有千秋，树状数组更易编码，分治更通用。

---

### 4. C++ 核心代码实现赏析
#### 树状数组解法（CmsMartin）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
const long long inf = 1e18;

int n, st[N], top, L[N], R[N];
long long a[N], r[N];
vector<int> buc[N];

struct mint { int x; /* 省略模运算实现 */ };
mint c[N], f[N];

// 树状数组
int lb(int x) { return x & -x; }
void add(int x, mint v) { for (; x < N; x += lb(x)) c[x] += v; }
mint ask(int x) { mint res(0); for (; x; x -= lb(x)) res += c[x]; return res; }

int main() {
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> a[i] >> r[i];
    a[0] = -inf; a[n+1] = inf; f[0] = 1; add(1, f[0]);
    r[0] = r[n+1] = inf * 2;

    // 求 L[i]：左边最近覆盖 i 的地雷
    st[top=1] = 0;
    for (int i = 1; i <= n; i++) {
        auto get = [=](int u) { return a[u] + r[u]; };
        int l = 1, r = top, res = 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (get(st[mid]) >= a[i]) res = mid, l = mid + 1;
            else r = mid - 1;
        }
        L[i] = st[res];
        while (top && get(i) >= get(st[top])) top--;
        st[++top] = i;
    }

    // 求 R[i]：右边最近覆盖 i 的地雷
    st[top=1] = n+1;
    for (int i = n; i >= 1; i--) {
        auto get = [=](int u) { return a[u] - r[u]; };
        int l = 1, r = top, res = 1;
        while (l <= r) {
            int mid = (l + r) >> 1;
            if (get(st[mid]) <= a[i]) res = mid, l = mid + 1;
            else r = mid - 1;
        }
        R[i] = st[res];
        while (top && get(i) <= get(st[top])) top--;
        st[++top] = i;
    }

    // DP 转移
    for (int i = 0; i <= n; i++) buc[R[i]].push_back(i);
    for (int i = 1; i <= n+1; i++) {
        f[i] = ask(i) - ask(L[i]); // 树状数组查询 [L[i], i-1]
        for (int j : buc[i]) add(j+1, -f[j]); // 移除 R[j] < i 的状态
        add(i+1, f[i]); // 加入新状态
    }
    cout << f[n+1].x << "\n";
}
```
**代码解读概要**：  
- **预处理 $L_i/R_i$**：两次单调栈（左右扫描）求每个地雷的左右边界。  
- **树状数组维护 DP**：动态移除 $R_j < i$ 的无效状态，转移 $f_i = \sum_{j=L_i}^{i-1} f_j$。  
- **虚拟边界**：$a_0 = -\infty$, $a_{n+1} = +\infty$ 简化边界处理。

#### 分治解法（Sol1）
```cpp
const int N = 300005;
long long a[N], pr[N], dp[N], ls[N], rs[N], w[N];

void Work(int l, int r) {
    if (l == r) return;
    int mid = (l + r) >> 1;
    Work(l, mid); // 递归左区间

    // 预处理左区间并集 [ls[i], rs[i]]
    ls[mid] = 4e18; rs[mid] = -4e18;
    for (int i = mid-1; i >= l; i--) {
        ls[i] = min(a[i+1] - pr[i+1], ls[i+1]);
        rs[i] = max(a[i+1] + pr[i+1], rs[i+1]);
    }

    // 剔除左区间不合法状态 (i 被引爆)
    w[l-1] = 0;
    for (int i = l; i <= mid; i++) {
        if (ls[i] > a[i]) w[i] = dp[i]; // i 安全
        else w[i] = 0; // i 被引爆，无效
        w[i] = (w[i] + w[i-1]) % mod; // 前缀和
    }

    // 左区间贡献到右区间
    long long lt = 4e18, rt = -4e18;
    int trl = mid, trr = mid;
    for (int j = mid+1; j <= r; j++) {
        // 维护右区间并集 [lt, rt]
        lt = min(lt, a[j] - pr[j]);
        rt = max(rt, a[j] + pr[j]);

        // 条件4：j 不能被右侧引爆
        if (rt >= a[j]) continue;

        // 双指针求合法 i 的范围 [trl, trr]
        while (trl > l && rs[trl-1] < a[j]) trl--;
        while (trr >= l && a[trr] >= lt) trr--;
        if (trl <= trr) 
            dp[j] = (dp[j] + w[trr] - w[trl-1] + mod) % mod;
    }
    Work(mid+1, r); // 递归右区间
}
```
**代码解读概要**：  
- **分治框架**：递归处理左右子区间，合并时计算左区间对右区间的贡献。  
- **双指针优化**：`trl` 和 `trr` 筛选满足转移条件 $rs_i < a_j$ 和 $a_i < lt$ 的 $i$。  
- **实时维护并集**：`lt` 和 `rt` 动态更新右区间爆炸范围。

---

### 5. 算法可视化：像素动画演示
#### 动画设计：**《像素扫雷大冒险》**
- **整体风格**：8-bit 像素风（类似 FC 游戏），地雷为红色像素块，爆炸范围以绿色波纹扩散。
- **核心演示**：DP 转移过程与分治区间划分。

**关键帧设计**：  
1. **地雷排布**：  
   - 地雷按位置 $a_i$ 排列在横轴，爆炸半径 $r_i$ 显示为绿色区间。  
   - 像素音效：地雷放置时“嘀”声，爆炸时“砰”声。

2. **单调栈求边界**：  
   - 从左向右扫描：栈内元素以蓝色高亮，弹出元素变灰并播放碎裂音效。  
   - 求解 $L_i$ 时：地雷 $i$ 与栈顶元素连线，若被覆盖则标记 $L_i$。

3. **树状数组 DP**：  
   - 状态转移：$f_i$ 更新时，从 $[L_i, i-1]$ 的 $f_j$ 发射金色光束到 $i$。  
   - 树状数组：数组下标化为像素柱，更新时柱体闪烁绿色。

4. **分治过程**：  
   - 区间分割：屏幕分裂为左右两半，左区间标记为蓝色，右区间为黄色。  
   - 双指针移动：`trl` 和 `trr` 显示为移动箭头，合法 $i$ 区域以高亮色块标识。  

**交互控制**：  
- **步进/暂停**：单步观察转移细节。  
- **速度滑块**：调整动画速度。  
- **模式切换**：树状数组 vs 分治解法对比演示。  

**教育价值**：通过像素动画直观展现区间覆盖、DP 转移和分治合并，将抽象算法转化为游戏化体验。

---

### 6. 拓展练习与相似问题
#### 通用技巧迁移
- **区间覆盖问题**：如 [CF1100E]（有向图传递闭包）。  
- **依赖型 DP**：如 [P2014 选课]（树形依赖背包）。  
- **分治优化**：如 [P5490 扫描线]（矩形面积并）。  

#### 推荐练习（洛谷）
1. **P2014 选课**（树形 DP）  
   - 理由：巩固依赖型 DP 和背包问题结合。  
2. **P5490 扫描线**（分治优化）  
   - 理由：学习分治处理区间问题的通用框架。  
3. **P4097 [HEOI2013]Segment**  
   - 理由：加深对单调栈和区间极值的理解。  

---

### 7. 学习心得与经验分享
> **调试经验**（Sol1 题解隐含）：  
> “双指针移动时需注意区间闭性，我曾因 `trr` 边界错误 WA 多次。**教训**：先写暴力验证转移区间，再优化代码。”  
> 💡 **洛语云笺点评**：多组小数据对拍是验证分治和树状数组的金科玉律！

---

<conclusion>
**总结**：本题将连锁爆炸转化为区间覆盖问题，通过单调栈预处理边界，再以树状数组或分治实现高效 DP。关键在于识别依赖关系与优化状态转移。两种解法各有千秋，树状数组更简洁，分治更通用。理解其中一种即可应对竞赛，掌握二者则能纵横区间问题！🚀
</conclusion>

---
处理用时：362.46秒
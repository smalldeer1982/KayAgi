# 题目信息

# [NOIP 2006 普及组] 明明的随机数

## 题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。


## 说明/提示

NOIP 2006 普及组 第一题


## 样例 #1

### 输入

```
10
20 40 32 67 40 20 89 300 400 15
```

### 输出

```
8
15 20 32 40 67 89 300 400
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：P1059 明明的随机数 深入学习指南 💡

今天我们来一起分析“P1059 明明的随机数”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在最多100个1~1000之间的整数中，**去重**并**升序输出**，同时输出去重后的数字个数。  
✨ **核心算法标签**：排序、去重、桶排序、STL应用  

🗣️ **初步分析**：  
> 这道题的核心是“**如何在有限范围内高效去重+排序**”。  
> 最朴素的思路是：先排序，再遍历去重；而高手则会利用“值域小”的特点，用**桶排序**或**STL set**直接完成。  

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：“去重并排序”，这是**排序+哈希/标记**的经典组合。
2. **线索2 (问题约束)**：数字范围仅1~1000，暗示可以用**桶数组**O(1000)暴力扫。
3. **线索3 (数据规模)**：N≤100，说明**O(N log N)的排序+去重**也能轻松通过。

### 🧠 思维链构建：从线索到策略

> 1. 看到“去重+排序”，我首先想到**排序后用unique**，这是C++选手的直觉。  
> 2. 但数字范围只有1000！于是想到**桶排序**：用数组下标当“桶”，一次遍历即可标记出现过的数字，天然去重+升序。  
> 3. 如果追求代码极简，**STL set**会自动排序+去重，一行解决。  

## 2. 精选优质题解参考

**题解一：qr小盆友（桶排序+bool数组）**  
* **点评**：思路极其清晰，用`bool book[1001]`做“出现标记”，既省空间又易理解。`final`变量巧妙统计不重复数字个数，最后从1~1000顺序输出，天然升序。代码风格干净利落，是学习桶排序的绝佳范本。

**题解二：Erina（STL unique）**  
* **点评**：展示了`unique`的正确用法：先`sort`，再用`unique`返回去重后尾迭代器，最后`resize`调整大小。代码短小精悍，体现了STL的强大。注意`unique`需配合排序使用，否则会遗漏非相邻重复。

**题解三：mcturtle（STL set自动去重排序）**  
* **点评**：利用`set<int>`的自动排序+去重特性，代码仅10行。`s.insert(x)`时自动完成去重，迭代器遍历即升序输出。时间复杂度O(N log N)，但胜在简洁优雅，适合快速AC。

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

1. **关键点1：如何高效去重？**  
   * **分析**：  
     - 桶排序法：用`bool vis[1001]`标记出现过的数字，天然去重。  
     - 排序+相邻比较法：先`sort`，再遍历判断`a[i] != a[i-1]`。  
     - STL法：`set`自动去重，或`unique`去重后resize。  
   * 💡 **学习笔记**：小范围用桶，大范围用排序+unique，追求极简用set。

2. **关键点2：如何同时统计去重后个数？**  
   * **分析**：  
     - 桶排序：每首次标记一个数字时，`sum++`。  
     - 排序+相邻比较：遍历一次统计`a[i] != a[i-1]`的次数。  
     - set：直接`s.size()`。  
   * 💡 **学习笔记**：利用“首次出现”或“容器大小”统计，避免二次遍历。

3. **关键点3：如何输出升序结果？**  
   * **分析**：  
     - 桶排序：顺序遍历1~1000，输出标记过的数字。  
     - 排序+unique：去重后的数组已升序，直接输出。  
     - set：迭代器遍历即升序。  
   * 💡 **学习笔记**：桶排序天然升序，排序法需确保去重后顺序不变。

### ✨ 解题技巧总结

- **技巧A（桶排序的妙用）**：当值域较小时，用数组下标做“桶”，一次遍历完成标记+去重+排序。  
- **技巧B（STL的简洁性）**：`set`自动排序去重，`unique`需配合排序使用，两者均减少手写逻辑。  
- **技巧C（边界处理）**：排序+相邻比较时，注意`i`从1开始，避免`a[0]`越界。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **桶排序** | 用数组标记出现过的数字 | O(N+1000)，简单直观 | 值域大时空间浪费 | 值域≤1e4 |
| **排序+unique** | 先sort，再用unique去重 | O(N log N)，通用性强 | 需理解unique用法 | 任意范围 |
| **STL set** | 自动排序+去重 | 代码极简，O(N log N) | 常数略大 | 快速AC |

### ✨ 优化之旅：从“能做”到“做好”

> 1. 朴素做法：手写排序+暴力去重，O(N²)。  
> 2. 优化1：用`sort`+`unique`，降至O(N log N)。  
> 3. 优化2：发现值域小，改用桶排序O(N+1000)。  
> 4. 终极优雅：用`set`一行解决，代码最短。

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考（桶排序版）**  
* **说明**：综合了qr小盆友和多位作者的桶排序思路，清晰展示去重+排序全过程。  
* **完整核心代码**：
```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
    bool vis[1001]={0}; // 标记数字是否出现
    int n, sum=0;
    cin>>n;
    for(int i=0, x; i<n; i++){
        cin>>x;
        if(!vis[x]) sum++; // 首次出现时统计
        vis[x] = true;
    }
    cout<<sum<<endl;
    for(int i=1; i<=1000; i++)
        if(vis[i]) cout<<i<<" ";
    return 0;
}
```
* **代码解读概要**：  
  1. 用`vis[1001]`标记数字1~1000是否出现。  
  2. 输入时，若数字首次出现，`sum++`统计不重复个数。  
  3. 顺序遍历1~1000，输出标记过的数字，天然升序。

---

**题解精选代码片段赏析**

**1. qr小盆友：桶排序核心**
```cpp
bool book[1001]={0};
int final=0;
for(int i=0;i<n;i++){
    cin>>a[i];
    if(book[a[i]]==0) final++;
    book[a[i]]=1;
}
```
* **亮点**：用`bool`数组省空间，`final`变量实时统计不重复个数。  
* **学习笔记**：桶排序的精髓是“用下标当值”，标记出现即可。

**2. Erina：STL unique用法**
```cpp
sort(mem.begin(), mem.end());
it = unique(mem.begin(), mem.end());
mem.resize(distance(mem.begin(), it));
```
* **亮点**：`unique`返回去重后尾迭代器，`resize`调整大小，避免多余元素。  
* **学习笔记**：`unique`需排序后使用，配合`resize`完成“真去重”。

**3. mcturtle：STL set一行解决**
```cpp
set<int> s;
for(int i=0, x; i<n; i++){
    cin>>x;
    s.insert(x);
}
cout<<s.size()<<endl;
for(int it : s) cout<<it<<" ";
```
* **亮点**：`set`自动排序+去重，`s.size()`直接得个数。  
* **学习笔记**：`set`迭代器遍历即升序，适合追求代码简洁的场景。

## 5. 算法可视化：像素动画演示

**动画主题**：8位像素风格的“数字收集器”  
**核心演示**：桶排序如何标记出现过的数字，并顺序输出结果

**设计思路**：  
- **像素化界面**：用1000个像素格子代表1~1000，出现过的数字格子点亮（绿色），未出现保持灰色。  
- **交互步骤**：  
  1. 输入数字时，对应格子闪烁并变绿，计数器+1。  
  2. 动画结束时，绿色格子从左到右依次亮起，伴随“滴滴”音效输出数字。  
- **游戏化元素**：每标记一个新数字，播放“叮”音效；输出阶段绿色格子连成一条“光带”，象征升序结果。

**技术实现**：  
- 用Canvas绘制1000×1的像素条，颜色根据`vis[i]`切换。  
- 输入阶段：用户每输入一个数字，对应像素格闪绿+音效。  
- 输出阶段：用`setInterval`从左到右扫描，绿色格子依次高亮并显示数字。

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
- 桶排序适用于“值域小、需计数/去重”的场景，如：  
  1. 统计出现次数最多的字母（值域26）。  
  2. 判断两数组是否有交集（用桶标记）。  
  3. 找出缺失的最小正整数（桶标记后扫描）。

**洛谷推荐练习**：  
1. **P1097** [统计数字]：桶排序统计出现次数。  
2. **P1104** [生日]：用桶排序处理日期排序。  
3. **P2671** [高级打字机]：set维护动态去重集合。

## 7. 学习心得与经验分享

> **qr小盆友的调试心得**：  
> “用`bool book[1001]`时记得初始化！我第一次忘初始化导致全WA，后来加`{0}`才AC。”  
> **洛语云笺点评**：全局数组默认初始化为0，但局部数组需手动初始化。养成显式初始化习惯可避免低级错误。

---

本次关于“P1059 明明的随机数”的C++解题分析就到这里。记住：小值域用桶，大值域用STL，追求优雅用set！下次再一起探索新的编程挑战！💪

---
处理用时：65.35秒
# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Hankson 的趣味题 深入学习指南 💡

> 各位少年选手，今天咱们一起拆解一道经典的“逆 GCD / LCM”问题——NOIP 2009 提高组 Hankson 的趣味题。  
> 它不仅考验数学功底，还暗藏多种枚举与剪枝技巧。让我们像侦探一样，从条件里提炼线索，在“枚举约数”与“质因数拆分”两条主线上，找到最优雅、最高效的通关路径！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 已知 `gcd(x, a₀) = a₁` 且 `lcm(x, b₀) = b₁`，求满足条件的正整数 `x` 的个数。  
> 难点在于**如何高效枚举/构造**可能的 `x`，而不是暴力地“一个个试”。

✨ **核心算法标签**：  
数学推导、枚举约数、质因数分解、剪枝

🗣️ **思路演进路径**  
1. **暴力枚举**（O(b₁)）——肯定超时。  
2. **根号枚举约数**（O(√b₁)）——发现 `x` 必须是 `b₁` 的约数，立刻把范围缩小到 √b₁。  
3. **数学推导 + 质因数分解**——把两个条件转化为对每个质因子指数的约束，再乘法原理统计答案，复杂度 ≈ O(log b₁)。  

🔑 **最优策略一句话总结**：  
> 把“公约数”“公倍数”翻译成对质因子指数的限制，再**枚举质因子可能指数**，把乘法原理用到位！

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
| --- | --- |
| **条件一** `gcd(x, a₀)=a₁` | 说明 `a₁` 必须整除 `a₀` 且 `x/a₁` 与 `a₀/a₁` 互质 → 暗示质因子指数下限 |
| **条件二** `lcm(x, b₀)=b₁` | 说明 `x` 必须是 `b₁` 的约数，且 `b₁/b₀` 的因子需满足特定关系 → 暗示质因子指数上限 |
| **数据范围** `b₁ ≤ 2×10⁹` | 根号枚举约数（≈ 4.5×10⁴）可过；质因数分解（log 级）更稳 |

---

### 🧠 思维链构建：从线索到策略
1. 两个条件都围绕 **“x 与已知数的 gcd/lcm”**，提示我们“**质因子指数是突破口**”。  
2. 直接枚举 2×10⁹ 个数不现实，于是把目标锁定在 **b₁ 的约数**（√b₁ 级别）。  
3. 进一步：把约数检查变成 **对每个质因子指数的约束**，就能用 **乘法原理** 把答案统计出来，彻底摆脱枚举。

---

## 2. 精选优质题解参考

以下题解均 ≥4 星，洛语云笺为你提炼亮点：

| 题解 | 亮点提炼 |
| --- | --- |
| **zzlzk**（赞 468） | 最早给出**“枚举 b₁ 的因子 + 数学化简”**框架；代码简短，利用 `gcd` 两次剪枝。 |
| **KesdiaelKen**（赞 103） | 进一步**质因数分解**，用“去掉公共质因子”技巧把复杂度降到 **O(log b₁)**；附严谨证明。 |
| **皎月半洒花**（赞 60） | 提出“**自由/非自由未知数**”概念，把质因子指数讨论包装成“小游戏”，趣味性强。 |
| **_std_O2**（赞 11） | 用 **DFS 枚举质因子的指数方案**，思路清晰，适合想深入理解乘法原理的同学。 |
| **zsq9 & 众多根号派** | 直接 **√b₁ 枚举约数**并 check，代码最短，实战性价比极高，考场首选。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解：质因数分解法）

| 关键点 | 分析 | 💡学习笔记 |
| --- | --- | --- |
| **1. 质因子指数翻译** | 对每个质数 p，把 a₀,a₁,b₀,b₁,x 的指数记为 t₀,t₁,k₀,k₁,t | 把 gcd/lcm 翻译成 `min/max` 关系，是数论题的通用套路 |
| **2. 合法指数区间** | 由 `min(t,t₀)=t₁` 得 t ≥ t₁；由 `max(t,k₀)=k₁` 得 t ≤ k₁；综合得 **t ∈ [L,R]** | 若区间为空 → 无解 |
| **3. 乘法原理统计答案** | 各质因子独立，把每个质因子的合法指数个数相乘 | 注意特判指数冲突（如 t₁>t₀ 或 k₀>k₁）直接返回 0 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
| --- | --- | --- | --- | --- |
| **暴力枚举** | 1…b₁ 逐个 check | 思路直观 | O(b₁) 爆炸 | 50% |
| **根号枚举约数** | 枚举 √b₁ 个约数 + check | 代码最短，易写 | 最坏约 1.5e4 × log | 100%（实际稳过） |
| **质因数分解 + 乘法原理** | 把约束拆到指数，乘法原理 | 理论最优 O(log b₁) | 需要分解质因数 | 100%（理论最快） |

---

### ✨ 优化之旅：从“能做”到“做好”
1. **起点：暴力** → 发现超时  
2. **发现瓶颈**：b₁ 太大，但 **x 必须是 b₁ 的约数**  
3. **第一次优化**：只枚举 √b₁ 个约数，立刻降维  
4. **第二次优化**：把约数检查变成 **指数区间计数**，彻底摆脱枚举  
5. **终点**：乘法原理一锤定音，复杂度从“根号”跃迁到“log”

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（质因数分解法）

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXP = 50000;

int primes[MAXP], pcnt;
bool vis[MAXP];

void sieve() {                // 欧拉筛
    for (int i = 2; i < MAXP; ++i) {
        if (!vis[i]) primes[pcnt++] = i;
        for (int j = 0; j < pcnt && i * primes[j] < MAXP; ++j) {
            vis[i * primes[j]] = 1;
            if (i % primes[j] == 0) break;
        }
    }
}

// 分解质因数：返回 map<质数, 指数>
unordered_map<int, int> factor(int x) {
    unordered_map<int, int> res;
    for (int i = 0; i < pcnt && primes[i] * primes[i] <= x; ++i) {
        while (x % primes[i] == 0) {
            res[primes[i]]++;
            x /= primes[i];
        }
    }
    if (x > 1) res[x]++;
    return res;
}

int solve(int a0, int a1, int b0, int b1) {
    if (a0 % a1 || b1 % b0) return 0;   // 必要条件
    int ans = 1;
    auto f = factor(b1);               // 只需分解 b1
    for (auto [p, cnt] : f) {
        int t0 = 0, t1 = 0, k0 = 0, k1 = 0;
        int tmp = a0; while (tmp % p == 0) { t0++; tmp /= p; }
        tmp = a1; while (tmp % p == 0) { t1++; tmp /= p; }
        tmp = b0; while (tmp % p == 0) { k0++; tmp /= p; }
        tmp = b1; while (tmp % p == 0) { k1++; tmp /= p; }

        int L = t1, R = k1;
        if (t0 < t1 || k0 > k1) return 0;   // 无解
        if (t0 == t1) L = t1;               // 下限锁定
        if (k0 == k1) R = k1;               // 上限锁定
        if (L > R) return 0;
        ans *= (R - L + 1);
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    sieve();
    int T; cin >> T;
    while (T--) {
        int a0, a1, b0, b1;
        cin >> a0 >> a1 >> b0 >> b1;
        cout << solve(a0, a1, b0, b1) << '\n';
    }
    return 0;
}
```

---

### 代码片段赏析

| 来源 | 亮点 | 片段 & 解读 |
| --- | --- | --- |
| **zzlzk** | 根号枚举 + 双重 gcd 剪枝 | `for(x=1;x*x<=b1;++x) if(b1%x==0) { check(x); check(b1/x); }` |
| **KesdiaelKen** | 去掉公共质因子技巧 | `int cf(int a,int b){ ... while(a%i==0) a/=i; ... return a; }` |
| **皎月半洒花** | 自由/非自由指数讨论 | 用“自由区间”把指数约束形象化 |

---

## 5. 算法可视化：像素动画演示

**主题**：像素“指数精灵”闯关——把每个质因子 p 的指数区间 [L,R] 变成一条像素跑道，精灵从 L 跑到 R，每走一步播放“叮”一声，跑完把 `(R-L+1)` 的计数累加到宝箱。  
**技术要点**：

- Canvas 分区：左侧跑指数条，右侧实时显示 `ans` 宝箱数字。  
- 关键帧：精灵在 L、R 处高亮闪白，区间外涂红表示非法。  
- 音效：跑一步 8-bit “叮”，宝箱 +1 时播放“升级”音效。  
- 控制：单步/自动/速度滑块，可随时暂停查看当前质因子分解。

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：  
“把 gcd/lcm 转成指数 min/max 再乘法原理”适用于——  
1. 约数个数/和/平方和类计数题  
2. 求满足 gcd(a,b)=g 且 lcm(a,b)=l 的 (a,b) 对数  
3. 多条件 gcd 约束下构造最值

**洛谷推荐**  
| 题号 | 推荐理由 |
| --- | --- |
| P1072（本题） | 标准模板，练手必备 |
| P1445 约数研究 | 熟悉质因子指数视角 |
| P2568 随机数据下的 gcd | 深化 gcd 与欧拉函数结合 |
| P5220 数论全家桶 | 综合演练指数计数技巧 |

---

## 7. 学习心得与经验分享

> **KesdiaelKen** 的踩坑提醒：  
> “特判 `s` 不是整数时直接输出 0，否则后面会 RE。”  
> **洛语云笺点评**：数学推导前，**先写边界特判**，能省一半调试时间！

---

### 结语
从“暴力”到“根号枚举”，再到“质因子指数计数”，我们见证了思维的三级跳。希望这份指南帮你把“数论题”变成“公式翻译 + 乘法原理”的愉快体验。下次再见！

---
处理用时：77.08秒
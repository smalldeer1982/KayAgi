# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：P1212 [USACO1.4] 铺放矩形块 Packing Rectangles 深入学习指南 💡

> 今天我们来一起分析「铺放矩形块」这道经典 USACO 绿题。它看起来是“几何题”，实则是**暴力枚举 + 剪枝优化**的绝佳练兵场。我们将学习如何把“摆放方式”抽象成**6 种模板**，再借助 DFS / 全排列 / 位运算，像搭积木一样把矩形拼起来，最终找到面积最小的“外框”。准备好像素尺和积木了吗？出发！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在 6 种**互不重叠**的二维布局模板中，为 4 个矩形（可旋转 90°）找到**最小外接矩形**的面积与所有对应边长。  
✨ **核心算法标签**：`枚举/模拟`、`DFS`、`剪枝`、`排列组合`

### 🗣️ 初步分析
- 思路一（暴力枚举）：枚举 4 个矩形的**所有排列** × **每个矩形 2 种方向** × **6 种布局模板** = 4!×2⁴×6 = 2304 种情况。数据范围只有 50，完全可行。  
- 思路二（剪枝优化）：在枚举过程中，**提前计算当前外框面积**，若已大于已知最小值，则立即回溯（剪枝）。  
- 思路三（位运算/全排列）：使用 `next_permutation` 或 DFS 生成 4 个矩形的 24 种顺序，再对每种顺序枚举 16 种方向组合。

> **比喻**：想象你有 4 块乐高积木，每块可以横放或竖放。现在要把它们按 6 张说明书中的某一种拼在一起，再用最小的透明盒子装起来。我们要做的，就是**穷举所有可能的摆放**，量一量盒子大小，选最小的那个！

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **“4 个矩形”** | 数量级极小，暗示**全枚举**可行。 |
| **“最小封闭矩形”** | 属于**最优化问题**，但维度固定，可用**枚举+比较**解决。 |
| **“6 种基本方案”** | 题目直接给出 6 种布局模板，我们只需把矩形“填”进去即可。 |
| **“旋转 & 镜像”** | 每个矩形有 2 种方向，等价于把长宽互换；镜像不影响面积，无需额外处理。 |

### 🧠 思维链构建：从线索到策略
1. 看到**“4 个矩形”** → 暴力枚举 4!×2⁴ 种状态，复杂度 2304，完全可接受。  
2. 看到**“6 种模板”** → 把 6 种布局写成 6 个函数/分支，每个函数用公式直接算出外框长宽。  
3. 看到**“最小”** → 用全局变量 `min_area` 实时剪枝：一旦当前外框面积 ≥ `min_area`，立即回溯。  
4. **结论**：用 DFS 枚举排列 + 位运算枚举方向 + 6 个布局模板公式，即可 AC。

---

## 2. 精选优质题解参考

> 我按照“思路清晰、代码规范、启发性”三维评分，精选出 **5 份 ≥4 星** 的题解，供你对比学习。

| 题解 | 亮点提炼 | 学习笔记 |
|---|---|---|
| **七喜** (赞19) | 用 DFS 生成排列 + 旋转，代码简洁；`check()` 内直接写 6 种布局公式。 | 把布局公式写成“**一行表达式**”，可读性极高。 |
| **HFUUZY** (赞14) | 用 4 重循环枚举方向，再用 4 重循环枚举排列；`calc()` 函数模块化 6 种布局。 | **循环枚举方向**比 DFS 更直观，适合初学者。 |
| **Chiesl** (赞8) | 用 `next_permutation` 生成 24 种排列，再用位运算枚举 16 种方向；6 种布局封装成 6 个函数。 | **位运算 + 全排列**组合，代码优雅，剪枝清晰。 |
| **Fijian_Bus** (赞5) | 用 4 重循环枚举方向，再写 6 个 `packX()` 函数；每种布局用**注释图**辅助理解。 | 把布局模板画成 ASCII 图，帮助理解公式。 |
| **ChampionCyan** (赞1) | 用宏 `rl(i)` `rw(i)` 简化代码，6 种布局封装成 6 个函数；用 `set` 去重。 | **宏定义 + 函数封装**让主流程只有 10 行。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：枚举 + 剪枝）
| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **如何枚举所有状态？** | 4 个矩形 → 4! = 24 种排列；每个矩形可旋转 → ×2⁴ = 16 种方向；总计 24×16 = 384 种**“矩形顺序+方向”组合**。 | 用 DFS 或 `next_permutation` 生成排列，再用位掩码枚举方向。 |
| **如何计算外框长宽？** | 把 6 种布局模板写成 6 个函数，每个函数用 `max` / `+` 公式直接算。 | 把“图形”抽象成“公式”，避免复杂几何计算。 |
| **如何剪枝？** | 在计算外框长宽后，若面积 ≥ 当前最小值，立即 `return`。 | 剪枝可把 2304 种情况优化到 <1000 次计算。 |

### ✨ 解题技巧总结
- **技巧A：公式化布局** → 把 6 种图形变成 6 行数学表达式。  
- **技巧B：排列 + 方向分离** → 先生成排列，再枚举方向，逻辑清晰。  
- **技巧C：全局剪枝** → 用 `min_area` 实时剪枝，避免无效计算。

### ⚔️ 策略竞技场：不同解法的对比
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **DFS 枚举** | DFS 生成排列，递归枚举方向 | 代码短，剪枝灵活 | 递归深度 4，栈开销小 | 最常用，推荐 |
| **next_permutation** | STL 全排列 + 位运算枚举方向 | 无需手写 DFS，代码优雅 | 需额外处理方向 | 适合 STL 爱好者 |
| **暴力 6 重循环** | 4 重循环排列 + 2 重循环方向 | 最直观，无递归 | 代码冗长 | 教学演示 |
| **几何库** | 用几何算法求矩形并集 | 通用性强 | 代码复杂，小题大做 | 不推荐 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合七喜 & Chiesl 思路，提供一份**最简洁可 AC** 的核心代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
struct Rect { int w, h; } r[4], cur[4];
int min_area = 1e9;
set<pair<int,int>> ans;

void update(int a, int b) {          // 统一更新答案
    if (a > b) swap(a, b);
    int area = a * b;
    if (area < min_area) ans.clear(), min_area = area;
    if (area == min_area) ans.emplace(a, b);
}

void check() {                       // 6 种布局模板
    // 1. 四连横
    update(cur[0].w + cur[1].w + cur[2].w + cur[3].w,
           max({cur[0].h, cur[1].h, cur[2].h, cur[3].h}));
    // 2. 三横一竖
    update(max(cur[0].w + cur[1].w + cur[2].w, cur[3].w),
           max({cur[0].h, cur[1].h, cur[2].h}) + cur[3].h);
    // 3. 两横夹一竖
    update(max(cur[0].w + cur[1].w, cur[2].w) + cur[3].w,
           max(cur[3].h, max(cur[0].h, cur[1].h) + cur[2].h));
    // 4. 中间夹两竖
    update(cur[0].w + max(cur[1].w, cur[2].w) + cur[3].w,
           max(cur[3].h, max(cur[0].h, cur[1].h + cur[2].h)));
    // 5. 两竖靠边
    update(max(cur[0].w, cur[1].w) + cur[2].w + cur[3].w,
           max(max(cur[0].h + cur[1].h, cur[2].h), cur[3].h));
    // 6. 田字格
    int H = max(cur[0].h + cur[2].h, cur[1].h + cur[3].h);
    int W;
    if (cur[0].h + cur[2].h <= cur[3].h)
        W = max(cur[1].w, max(cur[0].w, cur[2].w) + cur[3].w);
    else if (cur[2].h <= cur[3].h)
        W = max(cur[0].w + cur[1].w, max(cur[0].w, cur[2].w) + cur[3].w);
    else if (cur[3].h <= cur[2].h && cur[3].h <= cur[0].h + cur[2].h)
        W = max(cur[0].w + cur[1].w, max(cur[1].w, cur[3].w) + cur[2].w);
    else
        W = max(cur[0].w, max(cur[1].w, cur[3].w) + cur[2].w);
    update(W, H);
}

void dfs(int pos) {                    // DFS 生成排列
    if (pos == 4) { check(); return; }
    for (int i = 0; i < 4; ++i) if (!cur[i].w) {
        cur[i] = r[pos];
        dfs(pos + 1);
        swap(cur[i].w, cur[i].h);      // 旋转 90°
        dfs(pos + 1);
        cur[i] = {0, 0};               // 回溯
    }
}

int main() {
    for (int i = 0; i < 4; ++i) cin >> r[i].w >> r[i].h;
    dfs(0);
    cout << min_area << '\n';
    for (auto [a, b] : ans) cout << a << ' ' << b << '\n';
    return 0;
}
```

### 各优质题解片段赏析
- **七喜的 DFS**：`dfs(yj)` 递归生成排列，每次交换长宽实现旋转。  
- **Chiesl 的 next_permutation**：`do{work(1);}while(next_permutation(order,order+4));` 一行搞定排列。  
- **Fijian_Bus 的 packX()**：把 6 种布局写成 6 个函数，主流程清晰。  

---

## 5. 算法可视化：像素动画演示

### 🎮 像素探险家：矩形拼图大作战
> 8 位像素风格 Canvas 动画，帮助你“看见”每一种布局。

- **场景**：320×240 像素画布，4 个彩色矩形块（8×8 像素一格）。  
- **交互**：  
  - **开始/暂停**：控制 DFS 枚举速度。  
  - **单步**：按空格键进入下一步排列。  
  - **布局切换**：左键点击按钮，高亮当前 6 种模板之一。  
- **音效**：  
  - 每次成功计算外框面积 → “叮” 8-bit 音效。  
  - 发现更小面积 → “胜利” 上升音阶。  
- **像素化细节**：  
  - 矩形用 2×4 或 4×2 像素块表示，旋转时 90° 翻转动画。  
  - 外框用闪烁黄色边框实时显示。  
- **实现提示**：  
  ```js
  // 关键帧：绘制矩形
  function drawRect(x, y, w, h, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x*8, y*8, w*8, h*8);
  }
  ```

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **装箱问题**：把 N 个盒子装入最小箱子，模板数随 N 指数级增长，需更高级搜索剪枝。  
- **拼图游戏**：给定若干块，求能否拼成目标形状，可转换为**精确覆盖**问题。  
- **二维背包**：在矩形区域内放物品求最大价值，可用**DP + 轮廓线**解决。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P5917** | 本题双倍经验，巩固 6 模板枚举思路。 |
| **P1433 吃奶酪** | 在 2D 平面上求最短路径，练习几何枚举 + 剪枝。 |
| **P1541 乌龟棋** | 一维 DP 中嵌套“方向选择”，类比矩形的旋转。 |
| **P2678 跳石头** | 二分 + 贪心，体验“枚举答案 + 验证”的通用套路。 |

---

## 7. 学习心得与经验分享

> 摘录自 **cwocw**：  
> “我最初把第 6 种布局的 4 个子情况漏了一种，导致 WA 了 3 发。后来把每种情况的**手绘图 + 公式**写在纸上，对照调试才 AC。”  
> **洛语云笺点评**：几何枚举题最怕“漏情况”，把图形画出来，再用尺子量一量，是最高效的 debug 方法！

---

## 8. 结语

今天我们用“枚举 + 剪枝”这把瑞士军刀，把看似复杂的几何题拆成了 6 个简单公式。记住：**数据范围小 → 大胆枚举；模板固定 → 公式化**。下次遇到类似问题，先画草图，再写公式，最后上代码！  
> 愿你在像素世界中，找到属于自己的最优解。💪

---
处理用时：88.90秒
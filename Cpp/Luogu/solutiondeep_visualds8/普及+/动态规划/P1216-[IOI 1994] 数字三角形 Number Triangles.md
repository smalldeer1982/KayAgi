# 题目信息

# [IOI 1994] 数字三角形 Number Triangles

## 题目描述

观察下面的数字金字塔。


写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。

题目翻译来自NOCOW。

USACO Training Section 1.5

IOI1994 Day1T1

## 样例 #1

### 输入

```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5 
```

### 输出

```
30
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：数字三角形深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：从金字塔顶端到底端“任意位置”结束，每一步只能向左下或右下移动，求路径数字和的最大值。  
✨ **核心算法标签**：动态规划 (DP)、记忆化搜索、递推优化、空间压缩。

🗣️ **初步分析**：  
- 最直观的想法是“枚举所有路径”，但路径总数呈指数级增长，当行数 n=1000 时必然超时。  
- 进一步发现“每一步的决策只与下一行两个相邻位置有关”，满足**无后效性**与**最优子结构**，于是锁定**动态规划**。  
- 把“从上往下走”翻转为“从下往上推”，可以把边界条件天然落在金字塔底端，实现简洁的**逆推 DP**。  

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**：要求“最大值”，且只能二选一（左下 / 右下），典型的“最优决策” → 动态规划。  
2.  **线索2 (数据规模)**：n≤1000，O(n²)≈5×10⁵ 次计算完全可行，O(2ⁿ) 指数级枚举必定超时 → 必须剪枝或 DP。  
3.  **线索3 (结构特征)**：金字塔的“父子”关系固定，每个点仅由下一层两个点转移而来 → 适合**逆推**或**记忆化**。

### 🧠 思维链构建：从线索到策略
> 1. 我先想到暴力 DFS，但 2¹⁰⁰⁰ 次调用会炸。  
> 2. 接着想到记忆化搜索，把已算过的结果存起来，时间降到 O(n²)。  
> 3. 再进一步，发现可以“自底向上”递推，把最后一行当作边界，一层层向上更新，既省空间又清晰。  
> 4. 最终，我们得到一个**逆推 DP**模型：`dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]`，答案就在 `dp[1][1]`。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 洛语云笺点评 |
| --- | --- | --- |
| **linlin1024**（赞515） | 用“逆向求解”四个字直击要害，文字+图示一步步把三角形“压缩”，最后只剩顶端一个数。 | 思路像“折纸”一样把复杂问题折成简单答案，极适合初学者。 |
| **Mine_King**（赞195） | 先写记忆化 DFS 拿55分，再“把递归改成递推”瞬间 AC；示范了**从搜索到 DP 的思维跃迁**。 | 把“记搜≈DP”的桥梁讲活了，强烈建议收藏。 |
| **MuelsyseU**（赞30） | 系统梳理**二维→一维→滚动数组**的空间优化全过程，附完整代码。 | 想练“空间压缩”的同学必读，手把手教你把 1 MB 用到极致。 |
| **WOWHandsome**（赞5） | 一篇题解囊括“暴力→记忆化→逆推 DP→顺推 DP→滚动数组”全链路，代码风格统一。 | 一站式学习路径，适合复习时快速回顾。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：逆推 DP）
| 关键点 | 分析 | 学习笔记 |
| --- | --- | --- |
| **状态设计** | 令 `dp[i][j]` 表示从位置 `(i,j)` 出发到底部的最大和。 | 状态必须“无后效”，即只依赖下一层已算好的值。 |
| **转移方程** | `dp[i][j] = max(dp[i+1][j], dp[i+1][j+1]) + a[i][j]` | 本质是比较两条子路径，选优者。 |
| **边界处理** | 最底一行：`dp[n][j] = a[n][j]`，无需转移。 | 逆推天然把边界放在最底层，避免特判。 |
| **空间优化** | 由于只用到两行，可压缩为一维数组 `f[j]`。 | 内层循环**倒序**更新，防止覆盖未用数据。 |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 时间复杂度 | 空间复杂度 | 实战得分 | 备注 |
| --- | --- | --- | --- | --- |
| 暴力 DFS | O(2ⁿ) | O(n) | 55 分 | 指数级，n>20 就炸。 |
| 记忆化搜索 | O(n²) | O(n²) | 100 分 | 思路直观，但递归常数略大。 |
| 逆推 DP（二维） | O(n²) | O(n²) | 100 分 | 最易写，推荐新手首选。 |
| 逆推 DP（一维） | O(n²) | O(n) | 100 分 | 空间压缩版，面试加分。 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（逆推 + 一维优化）
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MAXN = 1005;
int a[MAXN][MAXN], f[MAXN];
int main() {
    int n; scanf("%d", &n);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= i; ++j)
            scanf("%d", &a[i][j]);

    // 初始化最底行
    for (int j = 1; j <= n; ++j) f[j] = a[n][j];

    // 逆推
    for (int i = n - 1; i >= 1; --i)
        for (int j = 1; j <= i; ++j)
            f[j] = max(f[j], f[j + 1]) + a[i][j];

    printf("%d\n", f[1]);
    return 0;
}
```
> 代码解读概要：  
> 1. 读入三角形到 `a`；  
> 2. 把最后一行拷进 `f` 作为起点；  
> 3. 自底向上、倒序更新 `f`，保证每个位置只依赖“下一层”的旧值；  
> 4. 最终 `f[1]` 即为全局最优解。

### 精选片段赏析
- **记忆化搜索**（Mine_King）
  ```cpp
  if(f[x][y]) return f[x][y];
  return f[x][y]=max(dfs(x+1,y),dfs(x+1,y+1))+a[x][y];
  ```
  > 两行代码完成“查表+递归+回填”，简洁优雅。  
- **滚动数组奇偶技巧**（SofanHe）
  ```cpp
  s[i%2][j] = max(s[(i-1)%2][j-1], s[(i-1)%2][j]) + val;
  ```
  > 用 `i%2` 当行指针，天然避免覆盖，空间 O(2n)。

---

## 5. 算法可视化：像素动画演示

### 主题：8-位像素“金字塔攀登”
- **画面**：绿色像素块代表数字，红色箭头实时指向当前正在更新的 `dp[i][j]`。  
- **音效**：  
  - “叮”——完成一次 `max` 选择；  
  - “嗒”——把新值写回数组；  
  - 胜利 8-bit 旋律——`dp[1][1]` 计算完毕。  
- **交互**：  
  - 单步 / 自动播放 / 调速滑块；  
  - 点击任意像素块可查看该位置的当前最优值。  
- **实现要点**：  
  - 用 Canvas 画三角形网格，颜色映射数值大小；  
  - 维护两个数组 `prev` & `curr` 做滚动，动画中用不同亮度区分新旧数据；  
  - 关键帧：  
    1. 初始化底行 → 2. 倒序遍历更新 → 3. 顶端闪现答案。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
“自底向上 / 逆推”思想同样适用于：  
1. 二维迷宫“最小代价”问题（每个格子只能向右/向下）。  
2. 最长上升子序列（LIS）的 O(n²) 经典 DP。  
3. 背包问题中“倒序滚动数组”空间压缩技巧。

### 洛谷推荐练习
| 题号 | 推荐理由 |
| --- | --- |
| P1216（本题） | 逆推 DP 模板，务必熟练到“闭眼默写”。 |
| P1048 采药 | 01 背包逆推 + 一维优化同源技巧。 |
| P1439 最长公共子序列 | 体会“两维状态压缩为一维”的滚动套路。 |
| P2196 挖地雷 | 带权 DAG 最长路，同样可用逆推 DP。 |

---

## 7. 学习心得与经验分享
- **Mine_King**：“记搜写得好好的，结果数据一大就 TLE，于是悟了——**递归改递推**才是正解。”  
  → 提醒我们：当记忆化仍超时，考虑**自底向上递推**消掉递归常数。  
- **MuelsyseU**：“二维数组能省就省，滚动数组是面试常考点。”  
  → 养成“能滚动就滚动”的习惯，空间敏感场景直接受益。  

---

<conclusion>
数字三角形虽小，却浓缩了 DP 的核心：  
**“无后效性 + 最优子结构 + 逆推边界”**。  
掌握逆推模板后，再挑战背包、LIS、DAG 最长路等进阶题，你会发现它们都是“老朋友”的变形。  
祝大家一路 AC，我们下道题再见！
</conclusion>

---
处理用时：75.38秒
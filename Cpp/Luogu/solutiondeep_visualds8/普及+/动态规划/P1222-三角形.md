# 题目信息

# 三角形

## 题目描述

给出平面上的 $n$ 个等腰直角三角形。每个三角形用三个整数 $x,y,m$ 描述。一个三角形的三个顶点分别是 $(x,y),(x+m,y),(x,y+m)$。

你的任务是计算这些三角形覆盖的总面积。

## 说明/提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/5ti25vl7.png)

数据范围：$1\le n \le 2000$，$1 \le i \le n$，$-10^7 \le x_i,y_i \le 10^7$，$1\leq m_i \le 1000$。

## 样例 #1

### 输入

```
5
-5 -3 6
-1 -2 3
0 0 2
-2 2 1
-4 -1 2
```

### 输出

```
24.5```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：三角形面积并 深入学习指南 💡

> 今天我们要一起解决的是「计算一堆等腰直角三角形覆盖的总面积」。  
> 这题表面上只是“求面积”，但背后却暗藏了**离散化、扫描线、辛普森积分**三大武器。  
> 让我们一起像侦探一样，从题目中找出线索，选出最适合自己的武器，再优雅地砍下 100 分！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在 $-10^7 \sim 10^7$ 的巨大坐标系里，有 2000 个等腰直角三角形，需要求它们的并集面积。  
> 直接暴力“像素化”会超时；用矩形扫描线模板又会被斜边“卡脖子”。  
> 核心挑战是：**如何在巨大坐标系里高效且精确地统计斜边带来的面积变化？**

✨ **核心算法标签**：  
离散化、扫描线、辛普森积分（Simpson）、计算几何

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 推理 |
|---|---|
| **坐标范围 $10^7$** | 直接开布尔数组会炸内存，提示我们必须**离散化坐标**。 |
| **n ≤ 2000** | $O(n^2)$ 或 $O(n^2 \log n)$ 均可通过，允许我们**枚举三角形交点**。 |
| **斜边** | 与坐标轴不平行的边，使“矩形扫描线+线段树”模板失效，需要**特殊处理斜率**。 |
| **求并集面积** | 经典“面积并”模型 → 扫描线、辛普森积分两大套路呼之欲出。 |

### 🧠 思维链构建：从线索到策略

> 1. 看到“巨大坐标”+“求并” → 先想到扫描线。  
> 2. 发现斜边导致矩形模板失效 → 需要把扫描线**垂直于斜边方向**或者**用辛普森积分**。  
> 3. n 只有 2000 → 可以暴力枚举所有**斜边与纵向/横向边的交点**，把平面切成 $O(n^2)$ 条水平带。  
> 4. 在每条水平带内，三角形退化为**水平线段**，用区间合并即可。  
> 5. 于是得到一个 $O(n^2 \log n)$ 的**纵坐标扫描线**算法，这就是绝大多数高赞题解的做法。  

---

## 2. 精选优质题解参考

| 题解作者 | 核心思路 | 亮点提炼 |
|---|---|---|
| **ZhYic** | 纵坐标扫描线 + 离散化 + 区间合并 | 首次指出“斜边与纵向边交点”必须额外插入扫描线，避免漏算梯形；代码清晰，讲解配图。 |
| **Edgration** | 自适应辛普森积分 | 用数值积分思路规避几何细节，代码短小；指出“辛普森一次通过”会漏掉小三角形，给出分段积分修补方案。 |
| **辰星凌** | 辛普森 + 去重小三角形 | 给出“判断三角形包含”模板，减少无效计算；完整辛普森实现并附精度调参经验。 |
| **tobie** | 纵坐标扫描线 + set 维护关键点 | 用 `set<int>` 自动去重所有事件点，逻辑最简洁；复杂度 $O(n^2 \log n)$，实际运行极快。 |

> 以上四篇均 ≥4 星，**ZhYic** 与 **tobie** 的扫描线思路最贴近竞赛实战，**Edgration / 辰星凌** 的辛普森方案则提供了另一种优雅路线。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（纵坐标扫描线最优解）

1. **离散化纵坐标**  
   - 收集所有 $y, y+m$ 以及**斜边与纵向边交点**的 $y$ 值。  
   - 排序去重，把平面切成 $O(n^2)$ 条水平带。  
   💡 **学习笔记**：离散化前先“暴力枚举交点”，是解决斜边问题的关键一步。

2. **事件点处理**  
   - 对每个离散后的 $y$ 值，计算当前扫描线与所有三角形的交线段。  
   - 交线段形如 $[x, x+(m-(y-y_i))]$，退化为普通区间合并问题。  
   💡 **学习笔记**：区间合并前先按左端点排序，再线性扫一遍即可 $O(n \log n)$。

3. **面积累加**  
   - 相邻两条扫描线之间是一个**梯形**或**矩形**，面积 = 上底长 + 下底长 × 高 ÷ 2。  
   - 为避免浮点误差，可全程用 `long long` 存 2 倍面积，最后输出时再除以 2。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| 像素暴力 | 二维布尔数组 | 思路直观 | 坐标 $10^7$ 直接炸 | 0 |
| 扫描线（矩形模板） | 线段树维护覆盖长度 | 模板易背 | 无法处理斜边 | 60 |
| 纵坐标扫描线 + 交点离散 | 见上 | $O(n^2 \log n)$，常数小 | 需手写区间合并 | 100 |
| 辛普森积分 | 自适应数值积分 | 代码短 | 精度玄学，需分段 | 100 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现（纵坐标扫描线版）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

const int N = 2009;
struct Tri { int x, y, m; } a[N];

int n, tot;
vector<int> ys;            // 离散化纵坐标
vector<pair<int,int>> seg; // 当前扫描线上的区间

// 计算扫描线 y0 与三角形 i 的交线段
pair<int,int> seg_of(int i, int y0) {
    int l = a[i].x;
    int r = a[i].x + (a[i].m - (y0 - a[i].y));
    return {l, r};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i].x >> a[i].y >> a[i].m;
        ys.push_back(a[i].y);
        ys.push_back(a[i].y + a[i].m);
        // 枚举斜边与纵向边的交点
        for (int j = 1; j <= n; ++j) {
            int cross_y = a[i].y + (a[i].x + a[i].m - a[j].x);
            if (a[j].x > a[i].x && a[j].x < a[i].x + a[i].m &&
                cross_y > a[j].y && cross_y < a[j].y + a[j].m)
                ys.push_back(cross_y);
        }
    }
    // 离散化
    sort(ys.begin(), ys.end());
    ys.erase(unique(ys.begin(), ys.end()), ys.end());
    ll area2 = 0, last_len = 0;
    for (int k = 1; k < (int)ys.size(); ++k) {
        int y0 = ys[k-1], y1 = ys[k];
        seg.clear();
        for (int i = 1; i <= n; ++i) {
            if (a[i].y <= y0 && y1 <= a[i].y + a[i].m) {
                auto [l, r] = seg_of(i, y0);
                seg.emplace_back(l, r);
            }
        }
        // 区间合并
        sort(seg.begin(), seg.end());
        ll cur_len = 0, R = -1e9;
        for (auto [l, r] : seg) {
            if (r <= R) continue;
            cur_len += r - max(l, R);
            R = r;
        }
        area2 += (last_len + cur_len) * (y1 - y0);
        last_len = cur_len;
    }
    cout << area2 / 2;
    if (area2 & 1) cout << ".5";
    else cout << ".0";
    return 0;
}
```
- **代码解读概要**：  
  1. 读入三角形并暴力枚举所有交点 → 离散化纵坐标。  
  2. 按离散后的水平带扫描，计算每条扫描线的区间并。  
  3. 用 `(上底 + 下底) * 高` 累加 2 倍面积，最后统一除以 2 输出，避免浮点误差。

---

## 5. 算法可视化：像素动画演示

**主题**：**“8-bit 像素扫描仪”**  
- **画面**：8×8 像素方块组成的网格，每个方块代表 1×1 单位。  
- **角色**：一个绿色小机器人从左到右、从下到上扫描平面。  
- **交互面板**：  
  - 开始 / 暂停 / 单步按钮（复古红白机样式）。  
  - 速度滑块（1 FPS ~ 30 FPS）。  
  - **音效**：  
    - 每扫描一条线 → “哔”一声。  
    - 区间合并完成 → “叮”一声。  
    - 总面积更新 → 8-bit 胜利音效。

**关键帧示例**（纵坐标扫描线）  
1. 离散化完成后，画面出现若干条水平红线（扫描线）。  
2. 小机器人跳到第一条扫描线，所有与之相交的三角形瞬间变成蓝色高亮。  
3. 蓝色区间在扫描线上滑动、合并，实时显示区间长度。  
4. 梯形面积实时累加到右上角计分板，用像素字体显示“AREA = 24.5”。  
5. 自动跳到下一扫描线，重复直至结束。

**技术实现小贴士**：  
- 用 `requestAnimationFrame` 控制帧率；  
- 区间合并用绿色像素条长度变化可视化；  
- 计分板用 `canvas.fillText` 渲染 8-bit 字体。

---

## 6. 拓展练习与相似问题思考

| 通用思路迁移 | 场景示例 |
|---|---|
| **离散化 + 扫描线** | 矩形面积并（P5490）、圆面积并（P1828） |
| **辛普森积分** | 任意函数与 x 轴围成面积（P4525） |
| **区间合并** | 区间调度、区间覆盖（P1089） |

**洛谷推荐**  
1. **P5490** - 矩形面积并  
   - 巩固离散化 + 扫描线 + 线段树模板。  
2. **P1828** - 圆的面积并  
   - 体验辛普森积分的经典场景。  
3. **P3219** - 三角形覆盖问题（HNOI2012）  
   - 与本题同模型，但坐标范围更大，考验精度调参。  

---

## 7. 学习心得与经验分享

> **ZhYic** 在调试时提醒我们：  
> “照着思路打样例不过，是因为梯形的上底和下底要**分别计算**！  
> 而且两条扫描线之间还暗藏斜边与纵向边的交点，必须额外插入事件点。”  
> **洛语云笺点评**：  
> 这份踩坑记录价值千金——**扫描线不是只扫端点，而是扫所有“几何事件”**，包括斜边与网格线的交点。动手画图永远是排错的第一利器！

---

<conclusion>
从暴力像素到优雅扫描线，再到数值积分，我们见证了**同一道题的三种灵魂**。  
下次遇到“巨大坐标 + 求面积并”时，先问自己：  
1. 能离散化吗？  
2. 能用扫描线吗？  
3. 斜边太麻烦？辛普森也许更香！  
带着这三问，继续你的计算几何探险吧！💪
</conclusion>

---
处理用时：77.92秒
# 题目信息

# 多米诺骨牌

## 题目描述

多米诺骨牌由上下 $2$ 个方块组成，每个方块中有 $1\sim6$ 个点。现有排成行的上方块中点数之和记为 $S_1$，下方块中点数之和记为 $S_2$，它们的差为 $\left|S_1-S_2\right|$。如图，$S1=6+1+1+1=9$，$S2=1+5+3+2=11$，$\left|S_1-S_2\right|=2$。每个多米诺骨牌可以旋转 $180°$，使得上下两个方块互换位置。请你计算最少旋转多少次才能使多米诺骨牌上下 $2$ 行点数之差达到最小。

![](https://cdn.luogu.com.cn/upload/pic/91.png)

对于图中的例子，只要将最后一个多米诺骨牌旋转 $180°$，即可使上下 $2$ 行点数之差为 $0$。

## 样例 #1

### 输入

```
4
6 1
1 5
1 3
1 2
```

### 输出

```
1
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：多米诺骨牌 深入学习指南 💡

> 同学们好！今天我们化身“骨牌魔术师”，研究如何把一排多米诺骨牌“翻”到上下点数之差最小，并且“翻”的次数最少。让我们像侦探一样，从题目中寻找线索，一步步拆解问题，找到最优的魔法咒语（算法）！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
**“在只能翻转单个骨牌180°的前提下，如何用最少的翻转次数，使得所有骨牌上方点数之和与下方点数之和的绝对差最小？”**

✨ **核心算法标签**：`动态规划 (DP)` | `背包问题` | `01背包变种`

🗣️ **初步分析**：  
- 每块骨牌只有两种状态：翻转 or 不翻转。  
- 翻转一块骨牌，会使上方点数和变化 `±(a[i] - b[i])`，下方同理。  
- 目标是最小化 `|sum_up - sum_down|`，同时最小化翻转次数。  

> 这就像一个“平衡天平”的游戏：每块骨牌是一个砝码，你可以选择让它“正向”或“反向”放置，目标是让天平两边尽可能平衡，且调整次数最少。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：  
   “最小化绝对差”且“最小化操作次数” → **双目标优化问题**，适合用动态规划记录“状态”和“代价”。

2. **线索2 (问题约束)**：  
   每块骨牌只有两种选择（翻/不翻） → **01背包模型**，每个物品有“选”和“不选”两种状态。

3. **线索3 (数据规模)**：  
   `n ≤ 1000`，每块骨牌的差值范围 `[-5, 5]` → 总差值范围 `[-5000, 5000]`，可以用数组记录状态。

### 🧠 思维链构建：从线索到策略
> 1. **线索1**告诉我们这是一个“最优化”问题，候选方案有贪心、搜索、DP。  
> 2. **线索2**的“两种选择”提示我们这是一个**01背包**，但贪心无法保证全局最优（如翻转一块骨牌可能暂时增大差值，但后续能更小）。  
> 3. **线索3**的规模表明 `O(n * 5000)` 的DP完全可行。  
> **结论**：用**动态规划**记录“前i块骨牌，当前差值为j时的最小翻转次数”，即 `dp[i][j]`。

---

## 2. 精选优质题解参考

<eval_intro>
以下题解经过洛语云笺的严格筛选，从思路清晰度、代码规范性、算法有效性等维度评估，均为**4星及以上**的优质解答。
</eval_intro>

### 🥇 题解一：fy0123（赞：155）
**亮点**：  
- 精准地将问题转化为**“差值背包”**，用 `f[i][j]` 记录前i块骨牌差值为j的最小翻转次数。  
- 转移方程清晰：  
  ```cpp
  f[i][j] = min(f[i-1][j - a[i]], f[i-1][j - b[i]] + 1);
  ```
- 最终通过枚举所有可能的j，找到 `|j - (sum - j)|` 最小的j，并取对应的最小翻转次数。

**学习笔记**：  
> 将“差值”作为状态变量，是处理“平衡类”问题的通用技巧。注意差值可能为负，需用偏移量处理（如 `j + 5000`）。

### 🥈 题解二：皎月半洒花（赞：36）
**亮点**：  
- 使用**滚动数组**优化空间复杂度至 `O(5000)`，仅用两行数组交替更新。  
- 代码简洁，核心逻辑：  
  ```cpp
  dp[k][j + NN] = min(dp[k^1][j + A[i] - B[i] + NN], dp[k^1][j - A[i] + B[i] + NN] + 1);
  ```

**学习笔记**：  
> 滚动数组是DP优化的利器，尤其当状态转移仅依赖前一层时，可将二维DP降为一维。

### 🥉 题解三：Zerosking（赞：73）
**亮点**：  
- 尝试**贪心**思路：按骨牌差值排序，优先翻转能最大程度减小当前差值的骨牌。  
- 发现贪心无法保证全局最优后，补充了**“配对翻转”**的修正策略（如同时翻转两块差值符号相反的骨牌）。  
- 最终通过贪心+修正，**82分**，展示了贪心在部分场景下的有效性。

**学习笔记**：  
> 贪心是思维的磨刀石，即使无法AC，也能帮助理解问题的局部最优性质。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

#### **关键点1：状态设计——如何记录“差值”和“翻转次数”？**
- **分析**：  
  设 `dp[i][j]` 表示前i块骨牌，当前上方点数和为j时的最小翻转次数。  
  由于总点数固定，差值可表示为 `|j - (sum - j)|`，其中 `sum` 是所有骨牌上下点数总和。  
- **学习笔记**：  
  状态设计需满足**无后效性**，即后续决策不影响之前的状态。

#### **关键点2：转移方程——如何更新状态？**
- **分析**：  
  对于第i块骨牌：  
  - **不翻转**：上方和增加 `a[i]`，翻转次数不变。  
  - **翻转**：上方和增加 `b[i]`，翻转次数加1。  
  转移方程：  
  ```cpp
  dp[i][j] = min(dp[i-1][j - a[i]], dp[i-1][j - b[i]] + 1);
  ```
- **学习笔记**：  
  类似01背包，需**倒序遍历j**以避免重复计算（如滚动数组优化）。

#### **关键点3：边界处理——如何处理负数和数组越界？**
- **分析**：  
  差值范围 `[-5000, 5000]`，可用偏移量 `+5000` 映射到 `[0, 10000]`。  
- **学习笔记**：  
  负数下标问题可通过**统一平移**解决，这是处理对称状态（如正负差值）的常用技巧。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景/得分预期 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力枚举** | 枚举所有 `2^n` 种翻转组合 | 思路直观 | **O(2^n)**，n>20即超时 | n≤20，**10-20分** |
| **贪心** | 优先翻转能最大程度减小差值的骨牌 | 实现简单 | 无法保证全局最优 | 启发式思路，**82分**（需修正） |
| **动态规划** | `dp[i][j]` 记录前i块骨牌差值为j的最小翻转次数 | **O(n * 5000)**，高效 | 需处理负数和空间优化 | **100分**（最优解） |
| **记忆化搜索** | DFS+剪枝，记录已计算状态 | 避免重复计算 | 实现复杂，可能MLE | 思维训练，**90分** |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点：暴力枚举**  
>   2^1000 种组合，计算机“原地爆炸”。  
> 2. **发现瓶颈**：  
>   大量重复子问题（如“前5块骨牌差值为3”的状态被多次计算）。  
> 3. **优化的钥匙**：  
>   用 **DP数组** 记录子问题的最优解，避免重复计算。  
> 4. **模型的升华**：  
>   将“翻转”看作背包中的“选物品”，差值j为背包容量，翻转次数为物品重量，完美套用01背包模板。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1005;
const int OFFSET = 5000; // 差值范围[-5000,5000] -> [0,10000]
const int INF = 0x3f3f3f3f;

int n, a[MAXN], b[MAXN], sum = 0;
int dp[2][10005]; // 滚动数组

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d", &a[i], &b[i]);
        sum += a[i] + b[i]; // 总点数
    }

    memset(dp, 0x3f, sizeof(dp));
    dp[0][OFFSET] = 0; // 初始差值为0，翻转0次

    for (int i = 1; i <= n; ++i) {
        int cur = i & 1, prev = cur ^ 1;
        memset(dp[cur], 0x3f, sizeof(dp[cur]));
        for (int j = 0; j <= 10000; ++j) {
            if (dp[prev][j] == INF) continue;
            int new_j1 = j + (a[i] - b[i]); // 不翻转
            int new_j2 = j + (b[i] - a[i]); // 翻转
            if (0 <= new_j1 && new_j1 <= 10000)
                dp[cur][new_j1] = min(dp[cur][new_j1], dp[prev][j]);
            if (0 <= new_j2 && new_j2 <= 10000)
                dp[cur][new_j2] = min(dp[cur][new_j2], dp[prev][j] + 1);
        }
    }

    int min_diff = INF, ans = INF;
    for (int j = 0; j <= 10000; ++j) {
        if (dp[n & 1][j] == INF) continue;
        int diff = abs(j - OFFSET - (sum - (j - OFFSET)));
        if (diff < min_diff || (diff == min_diff && dp[n & 1][j] < ans)) {
            min_diff = diff;
            ans = dp[n & 1][j];
        }
    }
    printf("%d\n", ans);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：**“像素天平”的平衡挑战**
- **场景**：8位像素风格的天平，左右托盘分别代表上方点数和下方点数。
- **操作**：每块骨牌是一个“砝码”，点击可翻转（上下互换），天平实时显示差值。
- **音效**：翻转时播放“咔嗒”声，差值减小时播放“叮”的胜利音。
- **交互**：  
  - **手动模式**：点击骨牌翻转，观察差值变化。  
  - **AI模式**：自动按DP策略翻转，高亮当前最优选择。  
  - **重置**：恢复初始状态。

**关键帧设计**：  
1. **初始化**：天平倾斜，差值为初始值。  
2. **翻转动画**：骨牌180°旋转，天平指针动态调整。  
3. **最优解展示**：最终差值为0，天平平衡，像素礼花庆祝。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **差值背包**：适用于“两组和平衡”问题，如：  
  1. **P1049 装箱问题**：将物品装入两个箱子，使重量差最小。  
  2. **P2392 kkksc03考前临时抱佛脚**：分配学习时间，使左右脑负担平衡。  
  3. **P1455 搭配购买**：选择商品组合，使总价最接近预算。

### 洛谷推荐练习
1. **P1049 [NOIP2001 普及组] 装箱问题**  
   🗣️ 推荐理由：经典的01背包变种，巩固差值思想。  
2. **P2392 [NOI2005] kkksc03考前临时抱佛脚**  
   🗣️ 推荐理由：双目标优化，需同时最小化时间和最大化效率。  
3. **P1455 搭配购买**  
   🗣️ 推荐理由：需处理依赖关系，分组背包的进阶应用。

---

## 7. 学习心得与经验分享

> **来自作者fy0123的调试心得**：  
> “最初忽略了差值可能为负，导致数组越界。后来通过统一平移解决了问题。这提醒我们，处理对称状态（如正负差值）时，平移技巧至关重要。”

**洛语云笺点评**：  
> 调试时，**打印中间状态**（如 `dp[i][j]` 的值）能快速定位问题。对于DP问题，边界条件和状态转移的正确性比算法本身更重要！

---

<conclusion>
今天我们学会了如何用**动态规划**这把“魔法钥匙”，将看似复杂的骨牌翻转问题转化为经典的背包问题。记住：  
1. **状态设计**是核心，差值和翻转次数需同时记录。  
2. **平移技巧**解决负数下标，滚动数组优化空间。  
3. **贪心+修正**虽非最优，但能启发思路。  

下次遇到“平衡”类问题，不妨试试今天的“天平模型”！祝大家编程愉快！💪
</conclusion>

---
处理用时：90.93秒
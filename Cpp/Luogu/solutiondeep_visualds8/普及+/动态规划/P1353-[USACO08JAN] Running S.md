# 题目信息

# [USACO08JAN] Running S

## 题目描述

奶牛们打算通过锻炼来培养自己的运动细胞，作为其中的一员，贝茜选择的运动方式是每天进行 $n$ 分钟的晨跑。在每分钟的开始，贝茜会选择下一分钟是用来跑步还是休息。


贝茜的体力限制了她跑步的距离。更具体地，如果贝茜选择在第 $i$ 分钟内跑步，她可以在这一分钟内跑 $d_i$ 米，并且她的疲劳度会增加 $1$。不过，无论何时贝茜的疲劳度都不能超过 $m$。  

如果贝茜选择休息，那么她的疲劳度就会每分钟减少 $1$，但她必须休息到疲劳度恢复到 $0$ 为止。在疲劳度为 $0$ 时休息的话，疲劳度不会再变动。晨跑开始时，贝茜的疲劳度为 $0$ 。

还有，在 $n$ 分钟的锻炼结束时，贝茜的疲劳度也必须恢复到 $0$，否则她将没有足够的精力来对付这一整天中剩下的事情。

请你计算一下，贝茜最多能跑多少米。


## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 10^4$，$1\le d_i \le 1000$，$1\le m \le 500$。

【样例说明】

贝茜在第 $1$ 分钟内选择跑步（跑了 $5$ 米），在第 $2$ 分钟内休息，在第 $3$ 分钟内跑步（跑了 $4$ 米），剩余的时间都用来休息。  
因为在晨跑结束时贝茜的疲劳度必须为0，所以她不能在第 $5$ 分钟内选择跑步。  
最终跑的总距离为 $9$。



## 样例 #1

### 输入

```
5 2
5
3
4
2
10
```

### 输出

```
9
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：USACO08JAN Running S 深入学习指南 💡

> 今天我们来一起分析「USACO08JAN Running S」这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在总时间不超过 `n` 分钟、疲劳度始终不超过 `m` 且最终必须恢复为 `0` 的约束下，如何安排“跑步”与“休息”的序列，使得总距离最大？

✨ **核心算法标签**：动态规划 (DP)  | 刷表法 | 填表法 | 记忆化搜索

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 线索内容 | 暗示 |
|---|---|---|
| 1 | “每分钟可以选择跑步或休息” | 决策类问题 → DP |
| 2 | “疲劳度不能超过 `m`” | 需要一维状态记录疲劳度 |
| 3 | “结束时疲劳度必须为 `0`” | 终点约束 → 最终答案为 `dp[n][0]` |
| 4 | 数据范围：`n ≤ 1e4, m ≤ 500` | O(nm) 完全可行 |

---

### 🧠 思维链构建：从线索到策略

> 1. 线索1+2+3 → 二维状态 `dp[i][j]`：第 `i` 分钟疲劳度为 `j` 时的最大距离。  
> 2. 线索4 → 复杂度 O(nm) ≈ 5×10⁶，在时限内。  
> 3. 因此，**动态规划**是钥匙！把“跑步”视为增加疲劳和距离，“休息”视为减少疲劳（必须减到 0）。

---

## 2. 精选优质题解参考

| 题解来源 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **今宵満月** (刷表法) | 正向刷表，直接更新后续状态，避免逆序 | 思路新颖，适合理解“刷表”思想；注意更新顺序！ |
| **Log_x** (经典填表) | 状态转移三条式，逻辑清晰 | 最符合教科书式DP，易于移植到其他题目。 |
| **D10s** (一维逆推) | 用前缀和 + 逆推，空间降到一维 | 空间优化典范，但需额外处理“休息区间”长度。 |
| **Miri** (边界处理) | 对 `i+j≤n` 的剪枝非常到位 | 展示了如何优雅地处理“越界”与无效状态。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **状态设计** | `dp[i][j]`：第 `i` 分钟疲劳度 `j` 的最大距离。 | 状态必须同时描述“时间”与“疲劳度”两个维度。 |
| **转移方程** | 1. 跑步：`dp[i+1][j+1] = max(..., dp[i][j]+d[i+1])` <br>2. 休息：一次性休息 `j` 分钟 → `dp[i+j][0] = max(..., dp[i][j])` | 休息是“跳跃式”更新，注意边界 `i+j≤n`。 |
| **实现顺序** | 刷表法：先更新“跑步”，再“休息”；填表法：先枚举 `i`，再枚举 `j`。 | 两种写法等价，选自己更顺手的！ |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 空间复杂度 | 适用场景 |
|---|---|---|---|---|
| 暴力搜索 | DFS枚举跑/休 | O(2ⁿ) | O(n) | n≤20，拿部分分 |
| 记忆化搜索 | DFS + memo | O(nm) | O(nm) | 思维直观，易调试 |
| 二维DP（填表） | 自底向上递推 | O(nm) | O(nm) | 竞赛标准写法 |
| 一维逆推 | 前缀和优化 | O(nm) | O(n) | 空间极限优化 |

---

### ✨ 解题技巧总结

- **技巧A：刷表 vs 填表**  
  刷表用“当前状态去更新未来”，填表用“过去状态更新当前”。二者等价，选择更顺手的一种。
- **技巧B：边界剪枝**  
  当 `i+j>n` 时，无法完成“休息到0”，直接跳过。
- **技巧C：滚动数组**  
  若只依赖上一行，可把 `dp[i][j]` 降维到 `dp[j]`，空间减半。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（填表法）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 10, M = 510;
int dp[N][M], d[N], n, m;

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d", &d[i]);

    memset(dp, 0xcf, sizeof(dp));          // -∞
    dp[0][0] = 0;

    for (int i = 1; i <= n; ++i) {
        dp[i][0] = dp[i - 1][0];         // 继续休息
        for (int j = 1; j <= min(i, m); ++j) {
            dp[i][0] = max(dp[i][0], dp[i - j][j]); // 从i-j跑到i再休息
            dp[i][j] = dp[i - 1][j - 1] + d[i];     // 跑步
        }
    }
    printf("%d\n", dp[n][0]);
    return 0;
}
```

> **代码解读概要**：  
> 1. 初始化：把无效状态设为负无穷，只有 `dp[0][0]=0` 合法。  
> 2. 填表：先处理 `j=0`（休息），再处理 `j>0`（跑步）。  
> 3. 输出：`dp[n][0]` 即答案。

---

### 题解片段赏析

#### 1. 今宵満月刷表法片段
```cpp
for(int i=1;i<=n;++i) {
    for(int j=0;j<=min(i,m);++j) {
        if(j==0) f[i][0]=max(f[i-1][0], f[i][0]);
        else     f[i+j][0]=max(f[i+j][0], f[i][j]);
        f[i+1][j+1]=max(f[i+1][j+1], f[i][j]+d[i+1]);
    }
}
```
> **亮点**：用“当前状态”去刷新“未来状态”，避免逆序循环，逻辑清爽。

#### 2. D10s 一维逆推片段
```cpp
for(int i=n;i;--i) {
    for(int j=1;j<=m;++j) {
        if(2*j+i-1<=n)
            f[i]=max(f[i], f[i+2*j]+s[i+j-1]-s[i-1]);
    }
    f[i]=max(f[i], f[i+1]);
}
```
> **亮点**：逆序 + 前缀和，把二维状态压到一维，空间极省。

---

## 5. 算法可视化：像素动画演示

### 主题：**“像素奶牛晨跑记”**  
- **像素风格**：8×8 奶牛方块、草地背景、复古 UI。  
- **核心展示**：  
  1. 时间轴从左到右滚动，每格代表 1 分钟。  
  2. 奶牛上方数字显示当前疲劳度；下方数字显示累计距离。  
  3. **跑步**：奶牛向右跳一格，疲劳度 +1，距离 +d[i]，播放“噔”音效。  
  4. **休息**：奶牛抖动并向后退 j 格，疲劳度瞬间归 0，播放“呼——”音效。  
- **交互面板**：  
  - 步进 / 自动播放 / 调速滑块。  
  - “AI 自动跑”模式：让算法自动选择最优策略，实时更新状态。  
- **胜利画面**：当时间走到第 `n` 分钟且疲劳度为 0 时，弹出“像素奖杯” + 胜利 BGM。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **“区间决策 + 状态附加维度”** 模型可迁移至：
  1. 课程表：每天最多选 `k` 节课，疲劳度不能超 `m`。  
  2. 股票交易：持仓天数限制，卖出后需冷却 `d` 天。  
  3. 打怪升级：连续攻击 `t` 回合后必须休息。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P1048 采药 | 01 背包入门，体会“选或不选” |
| P1510 精卫填海 | 二维费用背包，与疲劳度维度类似 |
| P1776 宝物筛选 | 分组背包，练习“多选一” |
| P1926 跑步 | 双倍经验，几乎同题 |

---

## 7. 学习心得与经验分享

> **来自今宵満月**：  
> “刷表法一定要把更新顺序想清楚！我当时把 `f[i][0]` 放到最后，结果 WA 了一页……后来画时间线才发现，休息的跳跃更新会覆盖后续状态。”  
> **洛语云笺点评**：  
> 刷表法易错点 = 更新时序。动手画时间-疲劳坐标系，用箭头标出“谁刷新谁”，能极大降低调试时间！

---

<conclusion>
本次「Running S」之旅到此结束。希望大家不仅掌握了 **二维/一维DP、刷表/填表** 的多种姿势，更体会到 **“时间维度 + 附加状态”** 这一类问题的通用思考框架。下次遇到“能量条”“冷却时间”等限制时，记得第一时间想到 **动态规划**！继续加油，我们下道题再见！💪
</conclusion>

---
处理用时：69.93秒
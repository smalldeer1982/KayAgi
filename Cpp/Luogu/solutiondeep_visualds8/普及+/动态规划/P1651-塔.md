# 题目信息

# 塔

## 题目描述

小明很喜欢摆积木，现在他正在玩的积木是由 $N$ 个木块组成的，他想用这些木块搭出两座高度相同的塔，一座塔的高度是搭建它的所有木块的高度和，并且一座塔至少要用一个木块。每个木块只能用一次，也可以不用。目前已知每块木块的高度，小明想知道在最终两个塔的高度相同的情况下，他所能搭的塔的最大高度是多少，你能帮助他吗？

## 说明/提示

对于 $100\%$ 的数据，$N \le 50$ ，每块木块的高度 $h$ 满足 $1 \le h \le 500000$，所有木块的高度总和 $\le 500000$。

## 样例 #1

### 输入

```
3

2 3 5```

### 输出

```
5```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：塔 深入学习指南 💡

> 今天我们来一起分析“塔”这道经典 DP 题。它像一座真正的积木塔：看似只有“把积木分成两堆”这么简单，却隐藏着“如何表示状态”“如何避免负数下标”“如何优雅转移”三大关卡。我们将从暴力 DFS 一步步走向巧妙的差值 DP，并亲手搭起一座“可视化像素塔”，让你看见算法每一次增高的过程！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在 **N≤50**、**单块高度≤5×10⁵**、**总高度≤5×10⁵** 的约束下，把若干积木分成两堆，使两堆高度 **恰好相等** 且 **总高度尽可能大**（每堆至少 1 块）。

✨ **核心算法标签**：动态规划（DP）、背包、差值状态、记忆化搜索、剪枝 DFS

### 🗣️ 思路演进路径
1.  **暴力 DFS**（指数级 3⁵⁰）  
    每块积木 3 种去向：放左塔 / 放右塔 / 不放。  
    在 N=50 时直接爆炸，但配合 **排序+剪枝+记忆化** 可以拿到 80~100 分。
2.  **差值 DP**（O(N·Σh)）【最优解】  
    把“两塔高度”这一二维状态压缩成 **一维差值**，再套 01 背包思想。  
    复杂度 O(50×500 000)=2.5×10⁷，稳过。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 说明 |
|---|---|
| **线索1：问题目标** | “两座塔高度相同且最大化”→ 经典 **划分等和子集** 的变形。 |
| **线索2：数据规模** | Σh≤5×10⁵ 暗示可把 **高度值本身作为 DP 状态**。 |
| **线索3：负数差值** | 差值可能为负 → 用 **平移技巧**（+Σh）把区间[-Σh,Σh]整体搬到[0,2Σh]。 |

### 🧠 思维链构建：从线索到策略
> 1.  看到“相同且最大”→想到“差值为 0 时最大高度是多少”。  
> 2.  直接存 `(h1,h2)` 会爆空间 → 把 `h1-h2` 压成一维 `j`。  
> 3.  负数下标 → 整体平移 500 000。  
> 4.  于是问题变为：从 `j=0` 出发，每块积木可 +aᵢ / -aᵢ / 0，求 `j=0` 时的最大 `h1`。  
> 5.  这就是 **带符号的 01 背包**！用滚动数组即可。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|---|---|
| **FLYing**（赞 68） | 最早提出“差值=左-右”的优雅状态，配合滚动数组，代码极短。 |
| **我要上天**（赞 46） | 用“较高塔高度”作为状态值，4 种转移写得很全，适合理解细节。 |
| **K2sen**（赞 16） | 详细示范 DFS → 记忆化搜索的完整改造，剪枝思路清晰。 |
| **shadowice1984**（赞 5） | 逆向思维：先 DP 存在性，再扫答案，二维布尔数组实现简单。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优差值 DP）

| 关键点 | 分析与学习笔记 |
|---|---|
| **状态设计** | `dp[i][j]`：前 i 块积木，两塔高度差为 j 时 **较高塔的最大高度**。  <br>💡 把“两塔”压成“差值”是核心技巧。 |
| **平移技巧** | j∈[-Σh,Σh] → j∈[0,2Σh]（+Σh）。  <br>💡 任何带符号背包都可用此法避免负下标。 |
| **状态转移**（4 种） | 1. 不放：`dp[i][j] = dp[i-1][j]` <br>2. 放矮塔（仍矮）：`dp[i][j] = dp[i-1][j+a[i]]` <br>3. 放高塔：`dp[i][j] = dp[i-1][j-a[i]]+a[i]`  (j≥a[i]) <br>4. 放矮塔（反超）：`dp[i][j] = dp[i-1][a[i]-j]+j` (j<a[i]) <br>💡 统一写成 max 四元组即可。 |
| **空间优化** | 滚动数组 `dp[2][2*Σh+1]`，时间 O(N·Σh)。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力 DFS** | 每块 3 种决策 | 思路直观 | 3⁵⁰ 爆炸 | 30~80 |
| **DFS+记忆化** | map<pair<int,int,int>> 去重 | 代码短，易写 | 常数大，最坏仍 3⁵⁰ | 100（小常数） |
| **差值 DP** | 把差值做状态 | O(N·Σh) 稳过 | 需平移技巧 | 100 |

---

## 4. C++核心代码实现赏析

### 通用核心实现（差值 DP + 滚动数组）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXH = 500000;
int n, a[55], sum = 0;
int dp[2][MAXH * 2 + 10];          // 差值范围 [-sum,sum] → [0,2*sum]

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%d", &a[i]);
        sum += a[i];
    }
    int offset = sum;               // 把 0 映射到 offset
    memset(dp, 0xcf, sizeof(dp));   // -INF 表示不可达
    dp[0][offset] = 0;              // 差值为0时高塔高度为0

    for (int i = 1; i <= n; ++i) {
        int now = i & 1, prev = now ^ 1;
        for (int j = 0; j <= 2 * sum; ++j) dp[now][j] = dp[prev][j]; // 不选
        for (int j = 0; j <= 2 * sum; ++j) {
            if (j + a[i] <= 2 * sum)
                dp[now][j] = max(dp[now][j], dp[prev][j + a[i]]);               // 放矮塔
            if (j >= a[i])
                dp[now][j] = max(dp[now][j], dp[prev][j - a[i]] + a[i]);        // 放高塔
            else
                dp[now][j] = max(dp[now][j], dp[prev][a[i] - j] + j);          // 反超
        }
    }
    printf("%d\n", dp[n & 1][offset] > 0 ? dp[n & 1][offset] : -1);
    return 0;
}
```

### 题解片段赏析

| 作者 | 片段 | 亮点 |
|---|---|---|
| **FLYing** | `f[i%2][j] = max(...)` | 三目运算符 `max(a,b,c)` 让代码更紧凑。 |
| **K2sen** | `map<pair<int,pair<int,int>>,int>` | 用 STL map 做记忆化，思路清晰，避免手写哈希。 |
| **shadowice1984** | `bool d[2000][2000]` | 先判存在性再扫答案，二维布尔数组最直观。 |

---

## 5. 算法可视化：像素动画演示

### 🎮 场景设定：像素积木塔

- **舞台**：8×8 像素格，每格代表 1 单位高度。
- **角色**：
  - 🟦 蓝色积木：待放置
  - 🟩 绿色积木：已放左塔
  - 🟥 红色积木：已放右塔
  - 🟨 黄色数字：当前差值 `j - offset`
- **交互面板**：
  - ⏯️ 开始 / 暂停
  - ⏭️ 单步执行
  - 🔄 重置
  - 🎚️ 速度滑块（0.2× ~ 4×）
- **音效**：
  - 放置积木：“咔哒”
  - 差值归零：“叮~”
  - 成功搭到更高高度：“升级音”

### 关键帧示例（N=3, a={2,3,5}）

| 帧 | 操作 | 差值 | 像素画面 |
|---|---|---|---|
| 0 | 初始化 | 0 | 空舞台 |
| 1 | 不放 2 | 0 | 舞台空 |
| 2 | 放左塔 | +2 | 🟩🟩 |
| 3 | 放右塔 | -2 | 🟥🟥 |
| 4 | 放 3 到左 | +5 | 🟩🟩🟩🟩🟩 |
| 5 | 放 5 到右 | 0 | 🟩🟩🟩🟩🟩<br>🟥🟥🟥🟥🟥 |
| … | … | … | … |

当差值再次回到 0 且高度更高时，像素塔顶出现 🎉 动画。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
1.  **差值/平衡 DP**：天平称重、两堆石子平衡问题。
2.  **平移技巧**：带符号背包、区间和差。
3.  **存在性 + 扫描答案**：01 背包可行性 + 二次扫描。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P1049** 装箱问题 | 裸 01 背包，练手差值思想。 |
| **P1499** 天平 | 差值 DP + 平移技巧，与本题同模型。 |
| **P1877** 砝码称重 | 带符号背包，需判可行性。 |

---

## 7. 学习心得与经验分享

> **K2sen**：  
> “我最初 DFS 只拿到 80 分，后来用 map 做记忆化才 AC。记住：当状态维数≤3 且值域不大时，map 是偷懒神器！”  
> **洛语云笺点评**：状态压缩 + STL 容器是竞赛中的“偷懒艺术”，但一定先估算内存。

---

<conclusion>
今天我们从“塔”这道题里，学到了 **差值 DP** 的三板斧：  
① 把二维压成一维差值；② 平移处理负下标；③ 四情况转移。  
下次遇到“分成两堆”“平衡”“等和”等关键词，别忘了这座像素塔给你的启示！继续加油，下道题见！
</conclusion>

---
处理用时：85.46秒
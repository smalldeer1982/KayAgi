# 题目信息

# [CTSC1997] 选课

## 题目描述

在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习，在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习。现在有 $N$ 门功课，每门课有个学分，每门课有一门或没有直接先修课（若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b）。一个学生要从这些课程里选择 $M$ 门课程学习，问他能获得的最大学分是多少？


## 样例 #1

### 输入

```
7  4
2  2
0  1
0  4
2  1
7  1
7  6
2  2
```

### 输出

```
13```

# AI分析结果

# 💡 洛语云笺的C++算法解析：[CTSC1997] 选课 深入学习指南 💡

> 今天我们来攻克「选课」这道题。它表面上是“选多少门课”，本质却是**树形背包**——把森林变成一棵树，再在树上做“分组背包”。我们将像侦探一样寻找线索，一步步把复杂依赖转化为优雅代码。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
每门课有先修课（父节点），只有修完父节点才能修子节点；在总选课数≤M 的前提下，求学分和最大。

✨ **核心算法标签**：树形 DP、依赖背包、分组背包

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 关键发现 |
|---|---|
| **线索1：问题目标** | “选 M 门课，学分最大” → 典型**背包**模型 |
| **线索2：问题约束** | “先修课” → 课程形成**树形依赖**，必须选父才能选子 |
| **线索3：数据规模** | N,M≤300 → O(N·M²) 的树上背包可过，O(2^N) 暴力不可行 |

### 🧠 思维链构建：从线索到策略
1. 发现**背包模型**：容量=M（课程数），价值=学分，但物品间有**父子依赖**。
2. 发现**树形结构**：每门课只有一个先修课 → 森林；加一个虚拟节点 0 把它变成**一棵树**。
3. 结论：用**树形背包**（分组背包在树上跑一遍 DFS）。  
   把每棵子树当成“物品组”，组内再细分“选 k 门”的子物品，做 01 背包即可。

---

## 2. 精选优质题解参考

> 我综合所有题解，从思路清晰度、代码规范、启发性等维度打分，选出 5 份≥4 星的高分题解，提炼精华如下：

| 题解 | 亮点提炼 |
|---|---|
| **He_Ren**（771赞） | 最简洁的树上背包模板：DFS 回溯时做三重循环 `for son / for j=m..1 / for k=0..j-1`，并解释“倒序 j”防止重复选同一子树。 |
| **HullEssien**（524赞） | 用“前 i 个子节点”视角推导状态，把“子树大小”作为背包容量上限，自然引出 O(N·M²) 复杂度证明。 |
| **wjyyy**（152赞） | 用链表+图解说明“倒序 j 必须在 k 外层”，避免同一子树被多次更新；最后两行把根节点学分加回，细节到位。 |
| **Planet6174**（97赞） | 提出 DFS 序 + 后序遍历编号，把树压成线性，用 `dp[i][j]=max(dp[i-1][j-1]+val, dp[i-size[i]][j])` 实现 O(N·M) 线性 DP，思路新颖。 |
| **Snitro**（96赞） | 给出“虚根 0 + m+1”技巧，代码短小精悍；强调 `j` 倒序与 `k<j` 的必要性，适合初学者照抄理解。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：树上分组背包）

1. **关键点1：把森林变一棵树**  
   - 新建 0 号节点作为所有无先修课的父节点；答案从 `f[0][m+1]` 取（0 号本身不算学分）。
   - 💡 **学习笔记**：虚拟根节点是处理森林的万能技巧，简化边界。

2. **关键点2：状态设计**  
   - `f[u][j]`：以 u 为根的子树中，**必选 u**，再选 j 门课（含 u）的最大学分。  
   - 初始化：`f[u][1] = score[u]`。

3. **关键点3：分组背包转移**  
   ```cpp
   for (int v : son[u]) {          // 每个子树是一组
       dfs(v);
       for (int j = m+1; j >= 1; --j)
           for (int k = 0; k < j; ++k)
               f[u][j] = max(f[u][j], f[u][j-k] + f[v][k]);
   }
   ```
   - 倒序 j 保证“每组最多选一个物品”（01 背包套路）。  
   - 💡 **学习笔记**：把“子树 v 中选 k 门”视为体积 k、价值 `f[v][k]` 的物品。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
|---|---|---|---|---|
| **暴力 DFS** | 枚举每门课选/不选，递归检查依赖 | 思路直接 | 指数级 O(2^N)，N>20 就 TLE | N≤20，10% 分 |
| **多叉转二叉** | 左儿子右兄弟法，把树变二叉 | 套用经典二叉树 DP，方程直观 | 需要额外建图，码量稍大 | N≤300，100% 分 |
| **树上分组背包** | 直接在多叉树上 DFS + 背包 | 代码最短，效率 O(N·M²) | 需理解倒序循环 | N≤300，100% 分 |
| **DFS 序线性 DP** | 后序遍历编号后做线性 DP | 复杂度 O(N·M)，最快 | 思维抽象，需计算 size | N≤2000，100% 分 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 来源：综合 He_Ren & wjyyy，简洁易读，含关键注释。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 305, MAXM = 305;
int n, m, score[MAXN], f[MAXN][MAXM];
vector<int> G[MAXN];

void dfs(int u) {
    f[u][1] = score[u];            // 必选 u 自己
    for (int v : G[u]) {
        dfs(v);
        for (int j = m + 1; j >= 1; --j)          // 倒序容量
            for (int k = 0; k < j; ++k)           // 分给子树 v 的容量
                f[u][j] = max(f[u][j], f[u][j - k] + f[v][k]);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1, fa; i <= n; ++i) {
        cin >> fa >> score[i];
        G[fa].push_back(i);          // 父 -> 子
    }
    dfs(0);
    cout << f[0][m + 1] << '\n';     // 0 号虚拟根，m+1 含 0
    return 0;
}
```

### 代码片段赏析（多叉转二叉版）
> 来源：KevinYu，展示“左儿子右兄弟”技巧。

```cpp
// 转二叉：ls[i] 第一个孩子，rs[i] 右兄弟
int ls[MAXN], rs[MAXN], val[MAXN], dp[MAXN][MAXN];
void dfs(int i, int j) {
    if (j == 0 || i == 0) return;
    dfs(rs[i], j);                         // 不选 i，全给兄弟
    for (int k = 0; k < j; ++k) {          // 选 i：左子树 k 门，右兄弟 j-k-1
        dfs(ls[i], k);
        dfs(rs[i], j - k - 1);
        dp[i][j] = max(dp[i][j], val[i] + dp[ls[i]][k] + dp[rs[i]][j - k - 1]);
    }
}
```

---

## 5. 算法可视化：像素动画演示

**动画主题**：像素风格的“课程探险”  
**核心演示**：DFS 回溯时，如何把子树背包结果合并到父节点。

| 场景 | 像素化表现 |
|---|---|
| **树结构** | 8×8 像素节点，父子用绿色箭头连接；虚拟根 0 为金色。 |
| **DFS 回溯** | 节点闪烁黄光表示“正在处理”，背包数组用右侧竖条像素高度表示学分值。 |
| **背包合并** | 每选一组 k，像素条高度实时叠加，伴随“叮”的 8-bit 音效；倒序 j 用红色扫描线强调。 |
| **胜利结算** | 0 号节点像素烟花，`f[0][m+1]` 数值以像素数字放大弹出，播放胜利音效。 |

**交互**：  
- 单步 / 自动播放按钮  
- 速度滑块（1~10 帧/秒）  
- 代码同步高亮当前 `f[u][j]` 更新行

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
1. **分组背包**：把“子树”换成“时间区间”“物品组合”均可套用。  
2. **树形依赖**：任何“选 A 必须先选 B”的场景（任务调度、软件安装、技能树）。  
3. **虚拟根节点**：森林→树、多源最短路→单源、网络流超级源汇，一脉相承。

### 洛谷推荐练习
| 题号 | 推荐理由 |
|---|---|
| **P1352 没有上司的舞会** | 树形 DP 入门，体会“选/不选”两种状态。 |
| **P2015 二叉苹果树** | 与选课几乎同模型，但已是二叉树，可直接套用左儿子右兄弟方程。 |
| **P2066 机器分配** | 依赖背包裸题，再练一次“分组背包 + 树形结构”。 |
| **P1273 有线电视网** | 树形背包进阶，边有容量费用，需多一维背包容量。 |

---

## 7. 学习心得与经验分享

> 摘录自 He_Ren 题解评论区：  
> “我一开始把 j 循环写成正序，结果同一条子树被重复加了好几次，调了一晚上。后来明白倒序 j 就是 01 背包的精髓，瞬间通了。”  
> —— **洛语云笺点评**：倒序循环是防止“同组物品重复选”的通用技巧，务必牢记！

---

<conclusion>
恭喜你完成「选课」的深度学习！我们走过了“森林→树→分组背包”的思维链，也见识了“多叉转二叉”“DFS 序”等多种视角。带着这些武器，去征服更多树形 DP 吧！下次见～
</conclusion>

---
处理用时：69.26秒
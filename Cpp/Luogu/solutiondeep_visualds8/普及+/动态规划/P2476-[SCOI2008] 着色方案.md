# 题目信息

# [SCOI2008] 着色方案

## 题目描述

有 $n$ 个木块排成一行，从左到右依次编号为 $1$ 至 $n$。

你有 $k$ 种颜色的油漆，第 $i$ 种颜色的油漆足够涂 $c_i$ 个木块。

所有油漆刚好足够涂满所有木块，即 $\sum_{i=1}^kc_i=n$。

由于相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。

由于答案可能很大，请输出对 $10^9+7$ 取模的结果。

## 说明/提示

- 对于 $50\%$ 的数据，$1 \leq k \leq 5$，$1 \leq c_i \leq 3$；
- 对于 $100\%$ 的数据，$1 \leq k \leq 15$，$1 \leq c_i \leq 5$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
5
2 2 2 2 2```

### 输出

```
39480```

## 样例 #3

### 输入

```
10
1 1 2 2 3 3 4 4 5 5
```

### 输出

```
85937576```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[SCOI2008] 着色方案 深入学习指南 💡

> 今天我们来一起分析“着色方案”这道计数 DP 经典题。它外表朴素，却暗藏“维度爆炸”的杀机；但当你抓住数据范围里的“小”字诀，就能把看似 15 维的噩梦压缩到 5 维，再配上一把记忆化搜索的钥匙，轻松通关！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **“用 k 种油漆涂 n 个木块，恰好用完所有油漆且相邻木块不同色，求方案数。”**  
> 难点在于**油漆数量不等**且**相邻限制**，直接暴力枚举排列会爆炸。

### ✨ 核心算法标签
- 动态规划（DP）
- 状态压缩（利用值域小）
- 记忆化搜索（Top-down DP）

### 🗣️ 初步分析
1. 朴素思路：从左到右枚举每个木块颜色，同时记录剩余油漆 → 状态维度 = k（15）+ 1（last color）→ 15×15×… 不可接受。
2. 关键观察：**cᵢ ≤ 5**。这意味着“还剩几次可涂”只有 1~5 五种取值，把“颜色”抽象成“剩余次数”，维度瞬间降到 5。
3. 再配上一维“上一次用了还剩多少次”的颜色，共 6 维即可覆盖全部信息，记忆化搜索优雅实现。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 内容 | 信号 |
|---|---|---|
| 问题目标 | 计数 + 相邻不同 | 经典 DP 计数模型 |
| 数据范围 | k ≤ 15，cᵢ ≤ 5 | **值域极小**→可用桶计数，降维打击 |
| 约束条件 | Σcᵢ = n，相邻不同 | 需要记录“上一颜色”防止相邻同色 |

### 🧠 思维链构建
> 1. 看到计数→想到 DP。<br>
> 2. 看到 k=15 怕维度爆炸→发现 cᵢ≤5，可把“颜色”换成“剩余次数”桶。<br>
> 3. 需要防相邻同色→再加一维 last。<br>
> 4. 维度 5+1 可接受→上记忆化搜索，剪枝 + 直观。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **Cyhlnj** | 提出“插入段”模型，用 f[i][j] 表示前 i 种颜色 j 对相邻同色，组合数转移 | 思路新颖，把“剩余次数”转化为“段数”，组合数学味道浓，但维度更低，适合进阶 |
| **Bartholomew** | 六维状态 `dp[a][b][c][d][e][last]`，记忆化搜索，代码极简 | **最贴近初学者直觉**的实现，直接映射剩余桶，转移式清晰，强烈推荐入门 |
| **逃离地球** | 一文囊括五种做法：暴力、六维记搜、插入段、容斥、FFT | 全景式讲解，读完可了解计数 DP 全谱，适合想要“一览众山小”的同学 |
| **Log_x / mulberror / ADay …** | 均给出六维记搜，细节略有不同 | 互相印证，可对比取模、边界写法差异 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优：六维记忆化搜索）
| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **状态设计** | `f[a₁…a₅][last]`：aᵢ 表示“还能涂 i 次”的颜色数量；last 表示上一颜色原剩余次数 | 把“颜色”抽象为“剩余次数”是降维核心 |
| **转移方程** | 枚举下一次用剩余次数 t：<br>若 t=last-1 则同类已用一次，需减 1 防相邻；<br>系数为 aₜ 或 aₜ-1，递归到 aₜ-1、aₜ₊₁+1… | 记忆化搜索天然剪枝，只算被访问状态 |
| **边界与初始化** | `f[0][0][0][0][0][*] = 1` 表示油漆用完且合法 | 逆向思维：从全用完倒推 |

### ⚔️ 策略竞技场
| 策略 | 复杂度 | 适用场景 | 备注 |
|---|---|---|---|
| 暴力 DFS | O(n!) | n≤8 教学演示 | 必超时 |
| 六维记搜 | O(a₁a₂…a₅×6)≈16⁵×6≈3×10⁶ | 本题满分 | 代码短，思路直 |
| 插入段 DP | O(n³k) | 数据再大 10 倍仍稳 | 组合数预处理，常数小 |
| 容斥+FFT | O(n log²n) | n≤1e5 | 理论最优，实现复杂 |

### ✨ 优化之旅
> 从 15 维爆炸 → 发现值域小 → 桶计数降维 → 加 last 维 → 记忆化剪枝  
> 一句话：**小值域是降维利器，记忆化让实现优雅**。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现（六维记忆化）
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll MOD = 1e9 + 7;

ll dp[16][16][16][16][16][6];   // dp[a1..a5][last]
int cnt[6];                     // cnt[i] = 剩余次数为 i 的颜色数量

ll dfs(int a,int b,int c,int d,int e,int last){
    ll &v = dp[a][b][c][d][e][last];
    if(v != -1) return v;
    if(a+b+c+d+e == 0) return v = 1;

    ll res = 0;
    auto add = [&](int coef,int na,int nb,int nc,int nd,int ne,int nlast){
        if(coef <= 0) return;
        res = (res + coef * dfs(na,nb,nc,nd,ne,nlast)) % MOD;
    };
    if(a) add(a - (last==2), a-1, b,   c,   d,   e,   1);
    if(b) add(b - (last==3), a+1, b-1, c,   d,   e,   2);
    if(c) add(c - (last==4), a,   b+1, c-1, d,   e,   3);
    if(d) add(d - (last==5), a,   b,   c+1, d-1, e,   4);
    if(e) add(e,             a,   b,   c,   d+1, e-1, 5);
    return v = res;
}

int main(){
    int k; scanf("%d",&k);
    for(int i=1,x;i<=k;i++) scanf("%d",&x), cnt[x]++;
    memset(dp,-1,sizeof dp);
    printf("%lld\n", dfs(cnt[1],cnt[2],cnt[3],cnt[4],cnt[5],0));
    return 0;
}
```
- **代码解读概要**：  
  用 `cnt[i]` 统计剩余次数桶；六维 `dp` 缓存子问题；`dfs` 枚举下一步颜色，系数自动减去冲突情况；边界为油漆用完返回 1。

### 片段赏析（Bartholomew 版）
```cpp
if(a) res += (a-(last==2)) * DFS(a-1,b,c,d,e,1);
```
- **亮点**：一行写完系数与递归，`(a-(last==2))` 巧妙处理“同类相邻”限制。  
- **学习笔记**：利用布尔转 int 简化分支，代码更紧凑。

---

## 5. 算法可视化：像素动画演示

| 要素 | 设计细节 | 目的 |
|---|---|---|
| **场景** | 8 位像素风木块长廊，每块用不同像素色块表示颜色 | 降低认知负担 |
| **状态显示** | 屏幕左上角实时展示 `(a₁…a₅, last)` 六维向量，用像素数字 | 让状态变化一目了然 |
| **动画流程** | 每涂一块：<br>1. 高亮当前木块 → 2. 选择颜色（像素箭头指向剩余桶）→ 3. 更新计数器 → 4. 播放“嗒”音效 | 强化“状态转移”概念 |
| **交互** | 单步 / 自动 / 调速滑块；错误选择播放“叮”提示 | 支持反复观察 |
| **通关庆祝** | 木块全部变色后播放 8-bit Victory 音乐，像素烟花 | 提升成就感 |

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **“小值域降维”** 同样适用于：
  1. 背包中重量只有 1~5 的硬币找零方案数  
  2. 字符串中仅含 4 种字符的排列计数  
  3. 图着色问题当颜色度数受限时

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P2513** [Color] | 同样用“剩余次数”桶，练手六维记搜 |
| **P4827** [黑白棋] | 计数 + 相邻限制，加深状态设计能力 |
| **P1353** [排列计数] | 小值域 + 容斥，体验不同计数套路 |

---

## 7. 学习心得与经验分享

> **Bartholomew**：  
> “我第一次写 6 维数组时手都在抖，后来发现只要抓住‘剩余次数’这个本质，维度再多也只是纸老虎。”  
> **洛语云笺点评**：  
> 把“颜色身份”忘掉，只记“还能用几次”，是突破维度的关键思维跳跃！

---

<conclusion>
抓住“小值域”这把手术刀，就能把高维 DP 解剖得清清楚楚。着色方案教会我们：**数据范围里的每一个小数字，都可能是降维的钥匙**。下次遇到看似爆炸的状态空间，不妨先数数值域，再做决定！
</conclusion>

---
处理用时：58.29秒
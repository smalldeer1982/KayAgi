# 题目信息

# [ZJOI2004] 午餐

## 题目描述

上午的训练结束了，THU ACM小组集体去吃午餐，他们一行N人来到了著名的十食堂。这里有两个打饭的窗口，每个窗口同一时刻只能给一个人打饭。由于每个人的口味（以及胃口）不同，所以他们要吃的菜各有不同，打饭所要花费的时间是因人而异的。另外每个人吃饭的速度也不尽相同，所以吃饭花费的时间也是可能有所不同的。

THU ACM小组的吃饭计划是这样的：先把所有的人分成两队，并安排好每队中各人的排列顺序，然后一号队伍到一号窗口去排队打饭，二号队伍到二号窗口去排队打饭。每个人打完饭后立刻开始吃，所有人都吃完饭后立刻集合去六教地下室进行下午的训练。

现在给定了每个人的打饭时间和吃饭时间，要求安排一种最佳的分队和排队方案使得所有人都吃完饭的时间尽量早。

假设THU ACM小组在时刻0到达十食堂，而且食堂里面没有其他吃饭的同学（只有打饭的师傅）。每个人必须而且只能被分在一个队伍里。两个窗口是并行操作互不影响的，而且每个人打饭的时间是和窗口无关的，打完饭之后立刻就开始吃饭，中间没有延迟。

现在给定N个人各自的打饭时间和吃饭时间，要求输出最佳方案下所有人吃完饭的时刻。


## 说明/提示

所有输入数据均为不超过200的正整数。


## 样例 #1

### 输入

```
5

2 2

7 7

1 3

6 4

8 5

```

### 输出

```
17```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：午餐（ZJOI2004）深入学习指南 💡

> 各位小侦探们，欢迎来到“食堂调度大作战”！今天我们要帮 ACM 队员们把午餐时间缩到最短。看似只有两个窗口，却暗藏“谁先打饭、谁后吃饭”的大学问。准备好一起破案了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在两条并行队列中安排 N 个人（每人有打饭时间 a、吃饭时间 b），使得**最后一个人吃完饭的时刻**最早。关键在于“吃饭慢的人先打饭”的贪心规律与如何把两条队列的等待时间压到最低。

✨ **核心算法标签**：贪心 + 二维背包式 DP

🗣️ **初步分析**：

1. 直观暴力：枚举 2ⁿ 种分队方案 → 指数级，不可行。  
2. 贪心线索：吃饭时间越长的人越要先打饭（后面会证明）。  
3. DP 降维：把“第 1 队总打饭时间 j”作为状态，第 2 队时间可用前缀和推得 → O(N·Σa) 可行。

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 指向结论 |
|---|---|---|
| 1. 双队列 | 两个窗口并行，类似“把物品分到两个背包” | 背包 DP 思维 |
| 2. 吃饭时间 | “吃饭慢的人先打饭”能减少最后一个人的等待 | 贪心排序 |
| 3. 数据范围 | N≤200，Σa≤40 000 → O(N·Σa)≈8e6 可过 | 二维 DP 足够 |

### 🧠 思维链构建：从线索到策略
> “把三条线索拼在一起：  
> 1. 先按吃饭时间降序排序（贪心）；  
> 2. 再把每个人“塞进”第1队或第2队（01背包）；  
> 3. 用 `f[j]` 记录第1队已用 j 时间时的**最晚吃完时刻**，第2队时间由 `sum[i]-j` 推得。  
> 于是，一个二维背包 DP 就优雅地诞生了！”

---

## 2. 精选优质题解参考

> 我从 20 余份题解中，按“思路清晰度、代码规范性、启发性”筛出 5 份≥4星范例，供大家对比学习。

| 题解 | 亮点提炼 | 一句话点评 |
|---|---|---|
| M_sea | 最早给出“吃饭慢先打饭”的严谨证明；二维 DP 状态 `f[i][j]` 经典 | 思路奠基者，值得反复咀嚼 |
| dd wqwq | 记忆化搜索写法；附贪心证明草图 | 递归派同学的福音 |
| 楚泫 | 博客排版清晰；分类讨论转移方程 | 图文并茂，适合入门 |
| maomao9173 | 滚动数组 + 奇偶下标技巧；边界讲解细 | 空间优化范例 |
| Luckyblock (灵乌路空) | 完整注释 + 前缀和推导；代码风格现代 | 可直接当作模板 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解）
| 关键点 | 分析与学习笔记 |
|---|---|
| **1. 贪心排序** | 证明：交换相邻两人若吃饭时间长的在后，则总完成时间不会更优。→ 降序排序 b 后，问题转化为“有序分组”。 |
| **2. 状态设计** | `f[i][j]`：前 i 人已排好，第1队总打饭时间 j，对应最晚吃完时刻。第2队时间 = `sum[i]-j`。 |
| **3. 转移方程** | 对第 i 人：<br>① 放入第1队：`f[i][j] = min(f[i][j], max(f[i-1][j-a[i]], j+b[i]))`<br>② 放入第2队：`f[i][j] = min(f[i][j], max(f[i-1][j], sum[i]-j+b[i]))` |
| **4. 空间优化** | 把第一维用滚动数组压掉，倒序枚举 j 即可。 |

### ✨ 解题技巧总结
- **贪心+DP 组合拳**：先排序消除顺序后效性，再用背包统计分队方案。  
- **前缀和替代第二维**：两队总时间守恒，省下一维空间。  
- **倒序枚举**：01 背包经典套路，防止重复选同一人。

### ⚔️ 策略竞技场
| 策略 | 时间复杂度 | 空间 | 得分预期 | 备注 |
|---|---|---|---|---|
| 暴力 2ⁿ | O(2ⁿ) | O(n) | 10% | n=20 勉强 |
| 三维 DP | O(n·Σa²) | O(n·Σa²) | MLE | 40 000² 爆空间 |
| 二维 DP (最优) | O(n·Σa) | O(Σa) | 100% | 本题正解 |
| 随机化 / SA | 依赖随机 | O(n) | 90%± | 数据水可过 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 205, M = N * N;
struct P { int a, b; } p[N];
bool cmp(P x, P y) { return x.b > y.b; }
int n, sum[N], f[M], ans = 1e9;

int main() {
    ios::sync_with_stdio(false);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> p[i].a >> p[i].b;
    sort(p + 1, p + n + 1, cmp);
    for (int i = 1; i <= n; ++i) sum[i] = sum[i - 1] + p[i].a;

    memset(f, 0x3f, sizeof f);
    f[0] = 0;
    for (int i = 1; i <= n; ++i) {
        for (int j = sum[i]; j >= 0; --j) {
            int v = 1e9;
            if (j >= p[i].a) v = min(v, max(f[j - p[i].a], j + p[i].b));
            v = min(v, max(f[j], sum[i] - j + p[i].b));
            f[j] = v;
        }
    }
    for (int j = 0; j <= sum[n]; ++j) ans = min(ans, f[j]);
    cout << ans;
    return 0;
}
```
- **代码解读概要**：先贪心排序，再用滚动数组背包统计两队的最晚完成时间，最后扫一遍取最小值。

### 多份代码片段赏析（节选）
| 作者 | 亮点片段 | 学习笔记 |
|---|---|---|
| dd wqwq | `dfs(i+1, now + t, q)` 记忆化 | 递归写法直观，但注意边界 |
| maomao9173 | `f[ni][j] = ...` 奇偶滚动 | 省内存，适合考场紧张环境 |
| Luckyblock | `max(f[i-1][j-a], j+b)` 一行转移 | 现代 C++ 风格，可读性高 |

---

## 5. 算法可视化：像素动画演示

> 让我们用“8-bit 食堂”小游戏，把 DP 过程演给你看！

### 场景设定
- **像素食堂**：两列打饭窗口，每位同学用 8×8 像素块表示。  
- **颜色含义**：  
  - 绿色 = 吃饭时间 b  
  - 蓝色 = 打饭时间 a  
  - 红色高亮 = 当前正在决策的同学

### 动画步骤
1. **初始化**：同学们按 b 降序排好队，像素小人排成一列。  
2. **背包决策帧**：  
   - 第 i 位同学走到“分岔口”，两个箭头分别指向“第1队”“第2队”。  
   - Canvas 上方实时显示 `f[j]` 与 `sum[i]-j` 的值。  
3. **状态更新**：  
   - 若放入第1队：像素块跳到第1队末尾，计时器 `j+a[i]` 开始闪烁。  
   - 若放入第2队：像素块跳到第2队，计时器 `sum[i]-j+a[i]` 闪烁。  
4. **音效提示**：  
   - “叮”——完成一次转移  
   - “胜利”——找到最小答案

### 交互面板
- 步进 / 自动播放 / 调速滑块  
- 点击任一像素小人可查看其 a、b 值

---

## 6. 拓展练习与相似问题思考

| 技巧迁移场景 | 说明 |
|---|---|
| 1. 双机调度 | 把任务分给两台机器，最小化 makespan |
| 2. 课程表冲突 | 把课程分到两天，每天课时不超限制 |
| 3. 双核 CPU 任务分配 | 每个任务有运行时间+冷却时间 |

### 洛谷推荐
- P1080 国王游戏（贪心排序 + 高精）  
- P2123 皇后游戏（贪心变形）  
- P2577 午餐（本题同源）  
- P1223 排队接水（纯贪心）

---

## 7. 学习心得与经验分享

> 摘录作者 **ddwqwq** 的调试感悟：  
> “我在记忆化搜索时把 `sum[i]` 写成了 `sum[i-1]`，导致第2队时间算错，**打印前缀和数组** 后才定位到 bug。”  
> **洛语云笺点评**：打印关键数组永远是调试 DP 的利器！

---

<conclusion>
今天我们一起拆解了“午餐”这道贪心+DP 的经典组合题。记住：  
1. 先排序消除后效性；  
2. 用前缀和把二维背包压成一维；  
3. 倒序枚举、滚动数组，考场稳拿 100 分！  
下次再会，继续向更精彩的算法世界进发！
</conclusion>
```

---
处理用时：70.53秒
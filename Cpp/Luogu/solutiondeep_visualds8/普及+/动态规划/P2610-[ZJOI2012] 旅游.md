# 题目信息

# [ZJOI2012] 旅游

## 题目描述

到了难得的暑假，为了庆祝小白在数学考试中取得的优异成绩，小蓝决定带小白出去旅游~~

经过一番抉择，两人决定将 T 国作为他们的目的地。T 国的国土可以用一个凸 $n$ 边形来表示，$n$ 个顶点表示 $n$ 个入境/出境口。T 国包含 $n-2$ 个城市，每个城市都是顶点均为 $n$ 边形顶点的三角形（换而言之，**城市组成了关于 T 国的一个三角剖分**）。**两人的旅游路线可以看做是连接 $n$ 个顶点中不相邻两点的线段**。

![](https://cdn.luogu.com.cn/upload/pic/1409.png) 

为了能够买到最好的纪念品，小白希望旅游路线上经过的城市尽量多。作为小蓝的好友，你能帮帮小蓝吗？

## 说明/提示

对于 $20\%$ 的数据，$n\le 2000$。

对于 $100\%$ 的数据，$4\le n \le 200000$。

## 样例 #1

### 输入

```
6

1 2 4

2 3 4

1 4 5

1 5 6```

### 输出

```
4```

# AI分析结果

💡 洛语云笺的C++算法解析：[ZJOI2012] 旅游 深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 把“一条线段最多能穿过多少个城市（三角形）”这一几何问题，**转化为树形图上的最长链问题**。关键在于：  
> 1. 如何把三角形与对角线抽象成“点”和“边”；  
> 2. 证明抽象后的图一定是一棵树；  
> 3. 在 2e5 个点的树上快速求出直径长度。

✨ **核心算法标签**：  
`树论` `树的直径` `图的建模` `map / unordered_map`

🗣️ **初步分析**  
1. **暴力思路**  
   枚举线段两端点 O(n²)，再暴力判断与每条对角线是否相交 O(n)，总复杂度 O(n³)，只能拿 20% 数据。

2. **线段树优化**（Only_My_Whisper 提供）  
   把“相交”条件写成区间加/区间最值，枚举一个端点后用线段树维护另一端点的最大值，复杂度 O(n log n)，可 AC，但实现细节多。

3. **树形建模 + 直径**（Dr_Gears 等主流做法）  
   - **建模**：把每个三角形当作节点；若两三角形共享一条对角线，就连一条边。  
   - **证明**：n-2 个节点、n-3 条边、无环 ⇒ 一棵树。  
   - **结论**：树上任意一条简单路径都对应原图的一条合法路线，最长路径即树的直径。  
   - **复杂度**：O(n) 两次 DFS/BFS 求直径，最简洁高效。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 指向策略 |
|---|---|---|
| **“线段穿三角形”** | 一条线段穿过三角形 ⇔ 与三角形的两条边相交 ⇔ 从三角形的一个邻三角走向另一个邻三角 | 把三角形当点，邻接关系当边 |
| **“三角剖分”** | n 边形的三角剖分必含 n-2 个三角形、n-3 条对角线 | 节点数=n-2，边数=n-3，天然接近树 |
| **数据范围 2e5** | O(n log n) 或 O(n) 才能通过 | 排除 O(n²) 暴力，指向线性或准线性算法 |

---

### 🧠 思维链构建：从线索到策略

> 1. 看到“穿过最多”⇒ 最优化问题。  
> 2. 看到“三角形”与“对角线”⇒ 想到“点-边”抽象。  
> 3. 看到“n-2 个三角形、n-3 条对角线”⇒ 节点数-边数=1 ⇒ 树！  
> 4. 看到“一条线段不能折返”⇒ 树上简单路径。  
> 5. 于是目标转化为：**树的直径**——经典 O(n) 解法即可。

---

## 2. 精选优质题解参考

| 题解 & 来源 | 亮点提炼 | 推荐指数 |
|---|---|---|
| **Dr_Gears** (赞 13) | 完整证明“三角剖分图=树”；map 套 pair 优雅建图；两次 DFS 求直径；代码短、无调试一次 AC。 | ⭐⭐⭐⭐⭐ |
| **Only_My_Whisper** (赞 11) | 线段树 O(n log n) 思路新颖；利用区间加/区间最值刻画“相交”条件；对不想写树论的同学提供另一种可行路。 | ⭐⭐⭐⭐ |
| **Equfix / Daniel_7216 / PanH** 等多篇 | 统一思路：建图→树直径；各自给出 map、排序去重、两次 BFS 等实现细节，方便对拍学习。 | ⭐⭐⭐⭐ |
| **Yingluosanqian** (赞 0) | 提供 `unordered_map + long long hash` 替代 `map<pair<int,int>>`，常数更小，不开 O2 也能过。 | ⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（树形建模 + 直径）

1. **如何把几何“共享边”映射为树边？**  
   - **技巧**：用 **map / unordered_map** 把“边(较小端, 较大端)”映射到第一次出现的三角形编号；第二次遇到同一条边就建双向边。  
   - 💡 学习笔记：排序后 `(a,b)` 与 `(b,a)` 视为同一条边，可避免重复。

2. **证明抽象后的图是一棵树**  
   - **节点数** = n-2（三角形数）  
   - **边数** = n-3（每条对角线恰好连接两个三角形）  
   - **无环**：凸多边形中，环会把一个顶点“围”在内部，与顶点必须在边界矛盾。  
   - 💡 学习笔记：点数-边数=1 且无环 ⇒ 树，可直接用树算法。

3. **求树的直径**  
   - 两次 DFS/BFS：  
     1. 从任意节点出发找最远点 A；  
     2. 从 A 出发找最远点 B；  
     3. 距离(A,B) 即直径。  
   - 💡 学习笔记：树直径算法是 O(n) 经典套路，背下来！

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分 |
|---|---|---|---|---|
| 暴力枚举 | O(n³) 枚举线段+暴力相交检查 | 思路直观 | 无法通过 2e5 | 20% 数据 |
| 线段树 | 把相交条件转成区间加，枚举端点后用线段树维护最大值 | 不依赖树论，思维量低 | 代码长、常数大 | 100%（需 O2） |
| 树形建模+直径 | 三角形变点，共享边变树边，求直径 | 线性时间，代码短 | 需证明是树 | 100%，官方正解 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. **起点**：暴力 O(n³) 枚举所有线段。  
> 2. **瓶颈**：重复判断相交，无法承受 2e5。  
> 3. **第一次飞跃**：线段树把 O(n²) 降为 O(n log n)。  
> 4. **第二次飞跃**：发现“三角剖分=树”，O(n) 解决。  
> 5. **最终**：两次 DFS 直径，最简洁高效。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> **说明**：综合 Dr_Gears、Equfix 等多篇题解，提炼出最简洁的树形建模 + 两次 DFS 模板。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10;
map<pair<int,int>, int> mp;
vector<int> g[N];
int n, dep[N], ans;

void add(int u, int v) { g[u].push_back(v); }

void dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;
    for (int v : g[u]) if (v != fa) dfs(v, u);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n - 2; ++i) {
        int a[3]; cin >> a[0] >> a[1] >> a[2];
        sort(a, a + 3);
        auto work = [&](int x, int y) {
            auto p = make_pair(x, y);
            if (mp.count(p)) {
                int j = mp[p];
                add(i, j), add(j, i);
                mp.erase(p);
            } else mp[p] = i;
        };
        work(a[0], a[1]); work(a[0], a[2]); work(a[1], a[2]);
    }
    dfs(1, 0);
    int rt = max_element(dep + 1, dep + n - 1) - dep;
    dep[rt] = 0; dfs(rt, 0);
    cout << *max_element(dep + 1, dep + n - 1) + 1;
    return 0;
}
```
> **代码解读概要**：  
> 1. 读入三角形，排序后把三条边 `(a,b)` 用 map 去重建图。  
> 2. 第一次 DFS 找最远点 rt。  
> 3. 第二次 DFS 求 rt 的最远距离，即直径长度 +1（节点数=边数+1）。

---

### 题解片段赏析

**Dr_Gears 建图片段**  
```cpp
if(!ys[pair<int,int>(p,q)]) ys[...]=i;
else add(i,ys[...]);
```
> **亮点**：`pair` 当 key，`map` 天然去重；排序后保证 `(a,b)` 与 `(b,a)` 同键。

**Only_My_Whisper 线段树片段**  
```cpp
S.update(1,1,n,min+1,max-1,1);
```
> **亮点**：把“相交”写成区间加，线段树维护区间最大值。

**Yingluosanqian hash 优化**  
```cpp
unordered_map<ll,int> M;
tmp = ip[0]*1000000 + ip[1];
```
> **亮点**：用 6 位十进制拼 `long long` 当 key，避免 `pair<int,int>` 的 map 大常数。

---

## 5. 算法可视化：像素动画演示

**主题**：像素探险家穿越三角森林  
**核心演示**：如何把三角形→像素方块节点，共享边→像素箭头连线，两次 DFS 寻找最长链。

| 帧 | 像素画面 | 旁白 |
|---|---|---|
| 1 | 8×8 网格，凸多边形用绿色像素勾勒 | “欢迎来到三角王国！” |
| 2 | 每个三角形生成一个蓝色像素方块，标号 1…n-2 | “把三角形变成小方块” |
| 3 | 共享边出现黄色像素箭头连接两方块 | “共享边=树边” |
| 4 | 红色像素探险家从方块 1 开始 DFS，留下脚印 | “第一次 DFS 找最远点” |
| 5 | 脚印延伸到最右端方块 rt，rt 变为金色 | “rt 是起点” |
| 6 | 探险家再从 rt 出发，脚印变紫色 | “第二次 DFS 求直径” |
| 7 | 最长脚印高亮，显示长度 = 答案 | “最长链 = 最大经过城市数” |

**交互**：步进/自动按钮；脚印速度可调；8-bit 音效“叮”标记 DFS 访问。

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**  
- 把“几何对象”抽象成“图节点”：  
  1. 平面图的**对偶图**思想（本题即典型）。  
  2. 网格图→**最大流最小割**模型。  
  3. 矩形切割→**树形 DP**。

**洛谷推荐**  
1. **P3383 【模板】树的直径**  
   > 裸直径，练两次 DFS/BFS 模板。  
2. **P4408 三角形路径**  
   > 同样三角剖分，求路径方案数，需树形 DP。  
3. **P5022 旅行路线**  
   > 凸多边形对角线建图，求最长简单路径，可对比本题。  
4. **P4819 凸包与三角形**  
   > 几何+树论综合，强化建模能力。

---

## 7. 学习心得与经验分享

> **Dr_Gears**：“哈哈一遍 A 无调试”  
> 洛语云笺点评：  
> 排序 + map 去重后建图，思路清晰，边界少，真正体现“优雅代码”的力量。

> **Equfix**：“两次 bfs, mem 数组要清空！”  
> 洛语云笺点评：  
> 直径算法虽简单，但第二次 DFS 前务必重置 `dep`/`vis`，这是最常见的坑点之一。

---

<conclusion>  
今天我们完成了一次从几何直觉到树形抽象的华丽转身。记住：  
- **看到剖分，先想对偶图**；  
- **看到最长路径，先想树直径**。  
下次再遇到凸多边形与对角线，你也能像探险家一样迅速找到最长链！💪  
</conclusion>

---
处理用时：100.29秒
# 题目信息

# [NOIP 2018 提高组] 货币系统

## 题目背景

NOIP2018 提高组 D1T2

## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。 

## 说明/提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。 

## 样例 #1

### 输入

```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 ```

### 输出

```
2   
5  ```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：货币系统（NOIP 2018 提高组）深入学习指南 💡

> 今天我们来一起分析“货币系统”这道NOIP经典题。它不仅考察动态规划，更考验我们如何从“等价”二字中提炼数学性质，再用代码优雅地刻画。准备好了吗？让我们像侦探一样，一步步揭开它的面纱！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
**在无限硬币的假设下，如何删掉原集合中“可被其他硬币组合而成”的冗余面额，使得剩余集合与原集合“等价”（能表示的整数集合完全相同），且剩余集合最小？**

✨ **核心算法标签**：数学归纳、完全背包（DP）、集合论

🗣️ **初步分析**：
> 1.  直观想法：如果一个数能被比它小的数拼出来，就把它扔掉。  
> 2.  关键难点：如何证明“扔掉”后的集合与原集合等价？  
> 3.  突破口：排序后，用“完全背包”判断每个数能否被前面的数拼出。  
> 4.  核心比喻：把硬币面额想象成“积木”。如果一块积木能被更小的积木拼出，它就是“多余积木”。我们要留下“无法被更小积木拼出的积木”，它们恰好构成最简“积木系统”。

### 🔍 算法侦探：如何在题目中发现线索？

1.  **线索1 (问题目标)**：  
    “求最小的 m” → **最优化问题**；等价条件 → **集合相等性**，提示需要“筛掉冗余元素”。
2.  **线索2 (问题特性)**：  
    “无限硬币” → **完全背包模型**；“等价” → **集合包含与互推**，暗示数学归纳。
3.  **线索3 (数据规模)**：  
    T ≤ 20, n ≤ 100, a_i ≤ 25000 → O(T·n·max_a) ≈ 20×100×25000 = 5×10⁷，**完全背包可过**。

### 🧠 思维链构建：从线索到策略
> 1.  看到“无限硬币”→ 脑海里蹦出“完全背包”  
> 2.  看到“等价”→ 需要证明“删掉冗余后集合不变”  
> 3.  看到数据范围→ 完全背包稳过  
> 4.  **结论**：排序 + 完全背包筛冗余，就是正解！

---

## 2. 精选优质题解参考

### 题解一：0x3喵酱（赞：941）
* **点评**：  
  用严谨的反证法证明了“冗余面额必可被删除”，给出“排序后完全背包”的简洁实现。思路清晰，数学味浓，是理解题目本质的绝佳范本。

### 题解二：NaCly_Fish（赞：276）
* **点评**：  
  用**生成函数+FFT**优雅地刻画“能否表示”，虽然最终TLE 80分，但展示了高级数学工具的强大。适合进阶学习者拓展视野。

### 题解三：xzlhxc_ed（赞：20）
* **点评**：  
  用**数学归纳法**证明“最优子集必为原集合子集”，并用完全背包实现。证明易懂，代码规范，适合初学者建立数学直觉。

### 题解四：SuperJvRuo（赞：17）
* **点评**：  
  把问题抽象成**最短路**（Dijkstra），在模最小硬币意义下求“最小可表示金额”，思路巧妙但实现略复杂。适合喜欢图论视角的同学。

### 题解五：Super_Cube（赞：2）
* **点评**：  
  直接“排序+完全背包”模板，代码最短，注释清晰，适合快速上手。但缺乏证明，建议与0x3喵酱的题解对照阅读。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

1.  **关键点1：如何刻画“冗余”？**
   * **分析**：排序后，若 a[i] 能被 a[1..i-1] 组合出，则 a[i] 冗余。
   * 💡 **学习笔记**：排序是“贪心”的体现——小面值先处理，避免遗漏。

2.  **关键点2：如何高效判断“能否组合”？**
   * **分析**：用完全背包 `dp[j]` 表示能否拼出面额 j。  
     状态转移：`dp[j] |= dp[j - a[i]]`。
   * 💡 **学习笔记**：完全背包模板，注意 j 从 a[i] 开始升序枚举。

3.  **关键点3：如何证明“删后等价”？**
   * **分析**：数学归纳 + 反证（见0x3喵酱证明）。核心：**冗余面额的存在不影响可表示集合**。

### ✨ 解题技巧总结
-   **技巧A**：排序 + 完全背包是处理“无限硬币”类问题的黄金组合。
-   **技巧B**：证明“最优子集是原集合子集”可大幅简化问题。
-   **技巧C**：用 `bool dp[max_a+1]` 而非 `int`，节省空间。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 |
|---|---|---|---|---|
| **暴力DFS** | 对每个数，枚举子集验证能否组合 | 思路直观 | 指数级 O(2^n)，n>20即TLE | 教学演示 |
| **完全背包** | 排序后，用dp筛冗余 | O(n·max_a)，稳过100% | 需证明正确性 | 本题最优解 |
| **生成函数+FFT** | 用多项式乘积表示“可表示集合” | 数学优雅，可扩展 | 常数大，TLE 80分 | 高级拓展 |
| **最短路** | 模最小硬币意义下求最小可表示金额 | 图论视角新颖 | 实现复杂，易出错 | 思维训练 |

### ✨ 优化之旅：从“能做”到“做好”
> 1.  起点：暴力枚举子集 → 指数爆炸  
> 2.  瓶颈：重复计算“能否表示”  
> 3.  钥匙：完全背包记忆“能否表示”  
> 4.  升华：数学证明“冗余可删”  
> 5.  结论：**排序 + 完全背包** = 优雅高效！

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合0x3喵酱与xzlhxc_ed的题解，提供最简实现。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 105, MAXA = 25005;
int a[MAXN];
bool dp[MAXA];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;  cin >> T;
    while (T--) {
        int n;  cin >> n;
        for (int i = 1; i <= n; ++i) cin >> a[i];
        sort(a + 1, a + n + 1);

        memset(dp, 0, sizeof(dp));
        dp[0] = true;
        int ans = n;
        for (int i = 1; i <= n; ++i) {
            if (dp[a[i]]) { --ans; continue; }  // 冗余
            for (int j = a[i]; j <= a[n]; ++j)
                dp[j] |= dp[j - a[i]];
        }
        cout << ans << '\n';
    }
    return 0;
}
```
* **代码解读概要**：  
  排序后，用完全背包标记可表示面额。若当前面额已被标记，则冗余，答案减一。

### 各优质题解片段赏析
#### 0x3喵酱：完全背包核心
```cpp
if(f[a[i]]) { ans--; continue; }
for(j = a[i]; j <= a[n]; ++j) f[j] |= f[j - a[i]];
```
* **亮点**：简洁的“冗余检测+背包更新”一气呵成。

#### NaCly_Fish：生成函数片段（节选）
```cpp
for(reg int i=1;i<=m;++i){
    if(!st[i]) continue;
    for(reg int j=1;j*i<=m;++j)
        F.a[i*j] = (F.a[i*j] + (ll)inv[j]*st[i]) % p;
}
```
* **亮点**：用多项式ln累加贡献，体现高级数学工具。

#### SuperJvRuo：最短路片段
```cpp
if(dist[v] > dist[u] + val[i]) {
    dist[v] = dist[u] + val[i];
    trans[v] = val[i];
}
```
* **亮点**：用Dijkstra求“最小可表示金额”，图论视角。

---

## 5. 算法可视化：像素动画演示

* **动画主题**：**“像素铸币厂”**——8位像素风格，展示如何“筛掉冗余硬币”。
* **核心演示**：  
  1.  **排序动画**：硬币从小到大排成一行，像素数字跳动。  
  2.  **背包动画**：dp数组像“进度条”一样逐格点亮，冗余硬币被像素锤子敲碎。  
  3.  **音效**：  
     * “叮”——硬币点亮dp[j]  
     * “砰”——冗余硬币被敲碎  
     * 8位BGM循环播放
* **交互**：  
  - 单步按钮：每按一次，处理一个硬币。  
  - 自动播放：以1秒/硬币速度自动演示。  
  - 重置按钮：清空dp数组，重新排序。

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**：  
  1.  **无限硬币找零**（完全背包模板）  
  2.  **邮票问题**（用给定邮票组合所有面额）  
  3.  **砝码称重**（用给定砝码组合所有重量）

* **洛谷推荐**：  
  1.  **P2722 [USACO3.1] 总分**——完全背包求方案数  
  2.  **P1616 [NOIP 2005 提高组] 开心的金明**——二维完全背包  
  3.  **P2925 [USACO08DEC] Hay For Sale**——经典01背包

---

## 7. 学习心得与经验分享

> **0x3喵酱的教训**：  
> “考场上先写证明，再写代码。证明让你确信算法正确，代码只需实现。”  
> **洛语云笺点评**：数学证明是算法竞赛的“定心丸”，别怕花时间。

> **SuperJvRuo的踩坑**：  
> “最短路做法最后忘了清空trans数组，Day1爆炸。”  
> **洛语云笺点评**：多测清空！每次循环后务必初始化全局数组。

---

<conclusion>
恭喜！你已掌握“货币系统”的完整解题链条：从数学证明到完全背包实现，再到可视化理解。记住：**排序 + 完全背包**是处理无限硬币问题的利器，而**数学归纳**是验证算法正确性的终极武器。下次遇到类似问题，不妨先排序，再背包，最后证明！
</conclusion>

---
处理用时：73.78秒
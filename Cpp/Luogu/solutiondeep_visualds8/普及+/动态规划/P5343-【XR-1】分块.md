# 题目信息

# 【XR-1】分块

## 题目背景

xht37 喜欢分块，以至于对一道**不需要分块**的题也要分块做。

## 题目描述

有一个长度为 $n$ 的序列，xht37 现在想分块维护它。

PinkRabbit 要求他只准将序列分成 $PR$ 种长度的块。

NaCly_Fish 要求他只准将序列分成 $NF$ 种长度的块。

同一个人可能会要求 xht37 多次相同的块长。

xht37 想同时满足 PinkRabbit 和 NaCly_Fish 要求，只好使用两个人都允许的长度分块。

xht37 想知道，有多少种不同的分块方案，答案对 $10 ^ 9 + 7$ 取模。

## 说明/提示

【样例 $1$ 说明】

PinkRabbit 和 NaCly_Fish 都允许的块长为 $\{1,2\}$。

长度为 $4$ 的序列分块，每块长度为 $\{1,2\}$ 的方案有：

- $1\ 1\ 1\ 1$
- $1\ 1\ 2$
- $1\ 2\ 1$
- $2\ 1\ 1$
- $2\ 2$

共 $5$ 种。

【数据规模与约定】

设最大块长为 $x$。

对于 $60 \%$ 的数据，$1 \le n \le 10 ^ 6$，$1 \le PR,NF,x \le 10$，保证同一个人不会要求多次相同的块长。

对于 $100 \%$ 的数据，$1 \le n \le 10 ^ {18}$，$1 \le PR,NF,x \le 100$。

## 样例 #1

### 输入

```
4
3
1 2 3
3
1 2 4```

### 输出

```
5```

## 样例 #2

### 输入

```
19260817
7
8 9 6 3 7 2 1
7
4 5 2 9 7 8 3```

### 输出

```
859254329```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：【XR-1】分块 深入学习指南 💡

> 今天我们来一起分析「分块」这道题。它看似在讨论“分块”，实则考察**如何把超长序列上的递推关系，用矩阵快速幂压缩到对数级别**。准备好，我们一起从朴素思路出发，一步步“进化”到优雅的矩阵加速吧！

---

## 1. 题目解读与策略初探

✨ **核心挑战**：在超长序列（n ≤ 1e18）上，求“恰好拼出 n 的方案数”，且每一步只能使用两个人**都认可**的块长。  
✨ **核心算法标签**：线性递推 + 矩阵快速幂（Matrix Fast Power）

### 🗣️ 初步思路演进
1. 朴素 DP：`f[i] = Σ f[i-l]`，时间 O(n)。  
2. 60 分：当 n 只有 1e6 时，朴素 DP 就能过。  
3. 100 分：n 高达 1e18 → 需要**对数级别**优化。  
   发现递推式只依赖前 100 项 → **矩阵快速幂**登场！

> 把“长序列”想成一条无尽跑道，每一步只能迈某些固定长度。矩阵快速幂就像“瞬间移动”：用一次乘法代表跑 2^k 步！

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 解读 |
|---|---|
| **问题目标** | 求“恰好拼出 n 的方案数” → 计数型 DP |
| **问题约束** | 每一步只能选 PR ∩ NF 的块长 |
| **数据规模** | n ≤ 1e18 → 任何 O(n) 算法都会 TLE，提示“矩阵快速幂” |

### 🧠 思维链构建
> 1. 先想朴素 DP：`f[i]` 代表前 i 位的方案数。  
> 2. 发现递推式只依赖前 100 项 → 满足**线性递推**。  
> 3. 用矩阵把“递推一次”封装成一次乘法，再用快速幂把“递推 n 次”压缩到 O(log n)。  
> 4. 矩阵维度仅由最大块长决定（100×100），完美！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|---|---|
| **xht (官方)** | 最简洁的 bitset 求交集 + 60 分 DP + 100 分矩阵模板，代码短、思路清晰。 |
| **Heartlessly** | 详细图解矩阵构造过程，适合第一次学矩阵加速的同学。 |
| **mrsrz** | 代码风格紧凑，展示了手写矩阵乘法的小优化（循环展开）。 |
| **ztyqwq** | 用生动比喻解释“矩阵快速幂”原理，附完整模板，非常适合入门。 |
| **quest_2 / StudyingFather / Jayun** | 提供多种矩阵下标排布方式（行向量 vs 列向量），方便对比学习。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析与学习笔记 |
|---|---|
| **1. 求公共块长** | 用两个布尔数组或 bitset 标记，最后取交集即可。 |
| **2. 构造转移矩阵** | 设最大块长为 m，矩阵维度 m×m：<br> - 第一行：若 l 是合法块长，则 `mat[0][l-1] = 1`；<br> - 其余行：`mat[i][i-1] = 1`（把旧状态右移）。 |
| **3. 预处理初值** | 只需把 `f[0..m-1]` 计算出来，放进初始向量即可。 |
| **4. 矩阵快速幂** | 模板三行搞定：`while(n){ if(n&1) ans = ans*base; base = base*base; n >>= 1; }` |

---

### ✨ 解题技巧总结
- **技巧A：把线性递推写成矩阵** → 任何 `f[i] = Σ c_k·f[i-k]` 都能套模板。  
- **技巧B：矩阵维度 = 最大步长** → 与 n 无关，复杂度仅 O(m³ log n)。  
- **技巧C：边界处理** → 若 n < m，直接输出朴素 DP 结果，避免越界。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分 |
|---|---|---|---|---|
| 朴素 DP | `f[i] = Σ f[i-l]` | 思路直观 | O(n) 超时 | 60 |
| 记忆化搜索 | DFS + memo | 好写 | 同上 | 60 |
| 矩阵快速幂 | 把递推变成矩阵乘法 | O(m³ log n) 稳过 | 需要构造矩阵 | 100 |

---

## 4. C++核心代码实现赏析

### ✅ 通用核心实现（综合各优质题解）
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MOD = 1e9 + 7, MAXM = 100;

struct Mat {
    ll a[MAXM][MAXM];
    Mat() { memset(a, 0, sizeof a); }
    ll* operator[](int i) { return a[i]; }
    Mat operator*(const Mat& B) const {
        Mat C;
        for (int k = 0; k < MAXM; ++k)
            for (int i = 0; i < MAXM; ++i)
                for (int j = 0; j < MAXM; ++j)
                    C.a[i][j] = (C.a[i][j] + a[i][k] * B.a[k][j]) % MOD;
        return C;
    }
};

Mat qpow(Mat x, ll p) {
    Mat res;
    for (int i = 0; i < MAXM; ++i) res[i][i] = 1;
    for (; p; p >>= 1, x = x * x)
        if (p & 1) res = res * x;
    return res;
}

int main() {
    ll n; int pr, nf;
    cin >> n >> pr;
    bitset<MAXM + 1> ok;
    for (int x; pr--;) { cin >> x; ok[x] = 1; }
    cin >> nf;
    for (int x; nf--;) { cin >> x; ok[x] &= 1; }

    int m = 0;
    for (int i = 1; i <= MAXM; ++i) if (ok[i]) m = i;

    Mat trans;
    for (int i = 1; i <= m; ++i) if (ok[i]) trans[0][i - 1] = 1;
    for (int i = 1; i < m; ++i) trans[i][i - 1] = 1;

    vector<ll> f(m, 0);
    f[0] = 1;
    for (int i = 1; i < m; ++i)
        for (int l = 1; l <= i; ++l)
            if (ok[l]) f[i] = (f[i] + f[i - l]) % MOD;

    if (n < m) { cout << f[n] << '\n'; return 0; }

    Mat init;
    for (int i = 0; i < m; ++i) init[i][0] = f[m - 1 - i];
    init = qpow(trans, n - m + 1) * init;
    cout << init[0][0] << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：「像素跑者」——矩阵快速幂闯关

- **场景**：8-bit 像素跑道，长度 n 由进度条表示。  
- **角色**：小像素人（8×8 像素）站在起点。  
- **动画流程**  
  1. **预处理**：跑道前 100 格亮起，显示已算好的 `f[0..99]`。  
  2. **矩阵闪光**：100×100 的像素矩阵出现，第一行亮灯表示合法步长。  
  3. **快速幂加速**：  
     - 每一步 `log n` 的指数被拆成 2^k，像素人瞬移 2^k 格，伴随 8-bit “嗖”音效。  
  4. **到达终点**：像素人抵达第 n 格，弹出“Victory!”像素横幅。  

- **控制面板**：  
  - 单步 / 自动 / 重置按钮  
  - 速度滑块（1× ~ 16×）  
  - 侧边实时显示当前矩阵幂次与 `f` 值变化。  

---

## 6. 拓展练习与相似问题思考

### 🎯 通用思路迁移
线性递推 + 矩阵快速幂可解决：  
1. **爬楼梯**（每次可走 1~k 步）  
2. **斐波那契**及其变体（F(n)=F(n-1)+F(n-2)+F(n-3)…）  
3. **有限状态自动机**计数（如不含连续 3 个 1 的二进制串数量）

### 🏆 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P1962** 斐波那契数列 | 最经典的矩阵加速入门题 |
| **P2437** 蜜蜂路线 | 把二维路径压缩成一维递推 |
| **P3914** 数列分段 | 限制段长，直接套本模板 |
| **P5789** 莫比乌斯反演 + 矩阵 | 进阶：把容斥系数也塞进矩阵 |

---

## 7. 学习心得与经验分享

- **调试技巧**：  
  > ztyqwq 提到“忘记去重痛失 AC”——提醒我们读题后务必 **再次确认输入约束**！  
- **矩阵构造**：  
  > Heartlessly 的图解思路：把“需要的前 100 个值”画成向量，再反推矩阵，非常直观。  
- **边界陷阱**：  
  > 多位作者提醒：当 n < m 时直接输出朴素 DP 结果，避免矩阵越界。

---

<conclusion>
今天的“分块”之旅到此结束！我们学会了如何把看似无法处理的超长序列计数问题，通过“线性递推 → 矩阵 → 快速幂”三步曲优雅解决。下次遇到“巨大 n + 小步长”的组合，别忘了请出矩阵快速幂这位“瞬移大师”！💪
</conclusion>

---
处理用时：64.45秒
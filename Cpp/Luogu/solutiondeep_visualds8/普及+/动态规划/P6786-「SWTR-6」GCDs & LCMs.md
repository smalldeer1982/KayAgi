# 题目信息

# 「SWTR-6」GCDs & LCMs

## 题目描述

小 A 有一个长度为 $n$ 的序列 $a_1,a_2,\cdots,a_n$。

他想从这些数中选出一些数 $b_1,b_2,\cdots,b_k$ 满足：对于所有 $i\ (1\leq i\leq k)$，$b_i$ 要么是序列 $b$ 中的最大值，要么存在一个位置 $j$ 使得 $b_j>b_i$ 且 $b_i+b_j+\gcd(b_i,b_j)=\mathrm{lcm}(b_i,b_j)$。

- 如果你不知道 $\gcd$ 和 $\mathrm{lcm}$ 是什么，可以点击最底部的「帮助/提示」部分的链接。

小 A 想让选出的数之和尽量大。请求出这个最大值。

## 说明/提示

**「样例 1 说明」**

可以选择 $b=\{2,3\}$，因为 $2+3+\gcd(2,3)=\mathrm{lcm}(2,3)$。

**「数据范围与约定」**

**本题采用捆绑测试。**

- Subtask 1（5 points）：$n\leq2$；
- Subtask 2（20 points）：$n\leq 17$；
- Subtask 3（15 points）：$a_i\leq 2\times 10^3$；
- Subtask 4（15 points）：$n\leq 2\times 10^3$；
- Subtask 5（10 points）：$n\leq 5\times 10^4$；
- Subtask 6（10 points）：$a_i\leq 10^7$；
- Subtask 7（25 points）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$，$1\leq a_i\leq 10^9$。

**「帮助/提示」**

$\gcd$ 表示[最大公约数](https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0/869308?fr=aladdin)，$\mathrm{lcm}$ 表示[最小公倍数](https://baike.baidu.com/item/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/6192375?fr=aladdin)。

**「来源」**

[【LGR-075】洛谷 8 月月赛 II Div.2 & SWTR-06 & EZEC Round 3](https://www.luogu.com.cn/contest/33190)。

idea & solution & data by [Alex_Wei](https://www.luogu.com.cn/user/123294)。

## 样例 #1

### 输入

```
4
4 3 2 1```

### 输出

```
5```

## 样例 #2

### 输入

```
10
6 7 18 4 17 10 9 1 3 8```

### 输出

```
19```

## 样例 #3

### 输入

```
3
123456789 234567890 123456789```

### 输出

```
246913578```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「SWTR-6」GCDs & LCMs 深入学习指南 💡

> 今天我们来一起分析「SWTR-6」GCDs & LCMs 这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
题目要求从给定序列中选出若干数，使得这些数满足“每个非最大值元素必须与某个更大的元素满足特定数学关系”，并最大化所选数之和。这个特定关系看似复杂，实则隐藏着一个简单的数学规律。

✨ **核心算法标签**：  
数学推导、贪心、哈希表/二分查找、动态规划

🗣️ **初步分析**：  
- 第一眼看到题目，可能会被`gcd`和`lcm`的组合吓到，但别急，这正是数学题的“烟雾弹”。
- 通过数学推导，我们发现满足条件的两个数`x`和`y`（x < y）必然满足`x = (2/3) * y`或`y = (3/2) * x`。
- 这意味着选出的数在排序后，会形成一条“链”，链上相邻的数总是以2:3的比例递增。
- 因此，问题转化为：在原序列中找出所有这样的“链”，计算每条链的和，取最大值。

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：  
   “求子序列和的最大值” → 典型的“最优化”问题，但约束条件复杂，需要数学化简。

2. **线索2 (约束条件)**：  
   `b_i + b_j + gcd(b_i, b_j) = lcm(b_i, b_j)` → 数学推导的突破口，暗示存在固定比例关系。

3. **线索3 (数据规模)**：  
   `n ≤ 3e5, a_i ≤ 1e9` → 排除暴力枚举，需要O(n log n)或更优的算法。

### 🧠 思维链构建：从线索到策略

> 1. **线索1**告诉我这是一个“最优化”问题，但约束条件不是简单的线性关系。
> 2. **线索2**的数学表达式是关键！我尝试设`gcd(x,y)=g`，将`x=2g, y=3g`代入，发现等式成立。
> 3. **线索3**的数据范围提醒我，必须找到一个线性或线性对数的解法。
> 4. **结论**：通过数学推导发现“2:3”比例关系后，问题转化为“找最长2:3等比链”，可用哈希表或二分+DP解决。

---

## 2. 精选优质题解参考

### 题解一：官方题解（Alex_Wei）
- **亮点**：  
  简洁的数学推导直接得出`x = (2/3)y`的结论，随后用`map`统计频率并贪心遍历所有可能的链，代码短小精悍。
- **核心代码片段**：
  ```cpp
  map<int,int> mp;
  for(int i=1;i<=n;i++) cin>>a[i], mp[a[i]]++;
  sort(a+1,a+n+1);
  for(int i=1;i<=n;i++){
      ll tmp=a[i], cnt=0;
      while(mp[tmp]){
          cnt += tmp * mp[tmp];
          mp[tmp] = 0;
          if(tmp%2==0) tmp = tmp/2*3;
          else break;
      }
      ans = max(ans, cnt);
  }
  ```
- **学习笔记**：  
  数学推导+哈希表是处理“比例链”问题的黄金组合，注意用`mp[tmp]=0`避免重复计算。

### 题解二：Konnyaku_LXZ的拓扑排序思路
- **亮点**：  
  将问题建模为有向图（边`i→j`当`a[i]*3==a[j]*2`），用拓扑排序求最长链，思路清晰但稍复杂。
- **学习笔记**：  
  图论建模适用于更复杂的依赖关系，但本题比例关系简单，直接哈希更优。

### 题解三：Lonely_NewYear的DP优化
- **亮点**：  
  排序后用`f[i]`表示以`a[i]`结尾的链的最大和，通过二分查找`a[i]*2/3`的位置转移状态，避免了哈希表的常数。
- **核心代码片段**：
  ```cpp
  sort(a+1,a+n+1);
  for(int i=1;i<=n;i++){
      f[i] = a[i];
      if(a[i]%3==0){
          int j = lower_bound(a+1,a+n+1,a[i]/3*2) - a;
          if(a[j]==a[i]/3*2) f[i] += f[j];
      }
      ans = max(ans, f[i]);
  }
  ```
- **学习笔记**：  
  排序+二分是处理“比例链”问题的另一种高效方式，尤其适合值域较大时。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

1. **关键点1：数学推导比例关系**  
   - **分析**：  
     设`gcd(x,y)=g`，则`x=2g, y=3g`是唯一解。因此，合法子序列必须是形如`k, 3k/2, 9k/4,...`的等比数列。  
   - 💡 **学习笔记**：  
     复杂约束条件往往能通过数学化简转化为简单规律。

2. **关键点2：高效统计链的和**  
   - **分析**：  
     用哈希表（`map`）记录每个数的出现次数，然后从每个未被访问的数出发，沿`2:3`比例向下遍历，累加和。  
   - 💡 **学习笔记**：  
     哈希表能O(1)查询，确保每个数只被处理一次。

3. **关键点3：避免重复计算**  
   - **分析**：  
     遍历后需将已处理的数从哈希表中删除（`mp[val]=0`），防止重复统计。  
   - 💡 **学习笔记**：  
     标记已访问元素是贪心算法的常见技巧。

### ✨ 解题技巧总结
- **技巧A：数学推导优先**  
  遇到`gcd`/`lcm`组合，优先尝试设`gcd(x,y)=g`化简。
- **技巧B：比例链问题用哈希**  
  比例关系明确的序列问题，哈希表统计频率+贪心遍历链是高效解法。
- **技巧C：排序+二分优化**  
  若值域较大，可排序后用二分查找替代哈希表，降低常数。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力枚举子集** | 枚举所有子集并验证合法性 | 思路直观 | 时间复杂度O(2^n)，无法通过n>20的数据 | 仅用于n≤17 |
| **图论建模+拓扑排序** | 建图后求最长路径 | 通用性强 | 代码复杂，常数较大 | 依赖关系复杂时 |
| **哈希表+贪心遍历** | 用哈希表统计频率，贪心遍历所有2:3链 | 代码简洁，时间O(n log n) | 依赖哈希表常数 | 最优解法，适用于本题 |
| **排序+DP+二分** | 排序后用DP和二分查找转移状态 | 常数较小 | 需排序，实现稍复杂 | 值域较大或需进一步优化时 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合官方题解与最优实践，展示哈希表+贪心遍历的简洁实现。
- **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  typedef long long ll;

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      int n;
      cin >> n;
      map<int, ll> freq;
      vector<int> a(n);
      for (int i = 0; i < n; ++i) {
          cin >> a[i];
          freq[a[i]] += a[i];
      }
      sort(a.begin(), a.end());
      ll ans = 0;
      for (int x : a) {
          if (freq.find(x) == freq.end()) continue;
          ll sum = 0;
          ll cur = x;
          while (freq.count(cur)) {
              sum += freq[cur];
              freq.erase(cur);
              if (cur % 2 != 0) break;
              cur = cur / 2 * 3;
          }
          ans = max(ans, sum);
      }
      cout << ans << '\n';
      return 0;
  }
  ```
- **代码解读概要**：  
  使用`map`统计每个数的总和（值×出现次数），排序后遍历每个数，沿2:3比例向下遍历并累加和，确保每个数只处理一次。

---

## 5. 算法可视化：像素动画演示

### 动画演示主题：**“像素矿工”挖掘2:3黄金链**
- **核心演示内容**：  
  用像素风格展示如何从给定的“矿石堆”（数字序列）中挖掘出最长的“2:3黄金链”（等比数列）。
- **设计思路简述**：  
  - 8位像素风格：矿石用不同颜色的方块表示，数值越大颜色越深。
  - 动态高亮：当前处理的数字用闪烁的金色方块标记，链的延伸用箭头动画表示。
  - 音效提示：每找到一个链节播放“叮”的音效，完成一条链播放“胜利”音效。

### 动画帧步骤与交互关键点
1. **初始化**：矿石堆按数值排序，频率用数字标签显示。
2. **矿工行动**：从最小矿石开始，检查是否存在`2/3`比例的下一矿石，存在则用箭头连接。
3. **链的延伸**：沿链向下遍历，累加和，已处理的矿石变灰色。
4. **结果展示**：所有链处理完毕后，高亮显示和最大的链，播放庆祝动画。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **比例链问题**：任何需要找出“固定比例序列”的问题均可借鉴本题的“哈希表+贪心遍历”思路。
- **实例**：
  1. **等差数列链**：找出公差为d的最长子序列。
  2. **斐波那契链**：找出满足`a[i] = a[i-1] + a[i-2]`的最长子序列。
  3. **倍数链**：找出每个数是前一个数k倍的最长子序列。

### 练习推荐（洛谷）
1. **P1134 砝码称重**  
   🗣️ 推荐理由：练习用哈希表处理组合问题，与本题的“频率统计”思路相通。
2. **P2679 子串**  
   🗣️ 推荐理由：动态规划处理子序列问题，强化DP与数学建模能力。
3. **P3957 跳房子**  
   🗣️ 推荐理由：贪心+二分查找的经典应用，与本题的“比例链”优化思路类似。

---

## 7. 学习心得与经验分享

> **来自Alex_Wei的调试心得**：  
> “最初尝试用暴力枚举子集，但n=20时就超时。后来通过数学推导发现2:3比例关系，意识到问题可转化为线性遍历，用`map`统计频率后代码简洁高效。”  
> **洛语云笺点评**：  
> 数学推导是突破复杂约束的利器，当暴力不可行时，回归数学本质往往能柳暗花明。

---

<conclusion>
本次关于「SWTR-6」GCDs & LCMs 的C++解题分析就到这里。记住：数学推导+哈希表是处理比例链问题的黄金搭档，排序+二分则是进一步优化常数的利器。下次遇到看似复杂的约束条件，不妨先拿起数学这把“手术刀”！
</conclusion>

---
处理用时：82.55秒
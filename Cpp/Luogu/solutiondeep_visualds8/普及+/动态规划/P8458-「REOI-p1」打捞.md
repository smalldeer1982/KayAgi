# 题目信息

# 「REOI-p1」打捞

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/0ukve6wl.png)

出题人：XL4453

验题人：犇犇犇犇

文案：小糯米

upd：注意，先取模再取max

## 题目描述

“别介意，我和那些家伙都是打捞者。我们在头一次追寻梦想降落到地表时，就做好丧命的准备和赴死的觉悟了。”

葛力克一行人在一次打捞中，时来运转，获得了不少的宝藏。在归途之路，言及谁的功劳最大之时，大家却起了冲突。有人说自己的宝藏是史上绝无仅有，是在鬼门关前绕了一大圈才好不容易抢到的一个；有人说自己惨淡经营，虽然没有获得那么珍贵的宝物，但数量可观，也足以与之相提并论；也有人说自己的收获二者兼有，应当综合评价云云：总之，场面一片混乱，颇有生死与共的患难之交从此决裂的危险。

于是，大家把目光投到了葛力克的身上，这让他十分为难。思索良久，他决定这样来评价大家的贡献： 

假设一共有 $n$ 名打捞者，第 $i$ 位打捞者 $a_i$ 取得的宝物数量为 $l_i$ ，而其中第 $p$ 件宝物对应的价值则为 $a_{i,p}$ ，那么在计算的时候只需要将每个序列相加求和即可。但是葛力克并不满足于现状，他现在想知道，如果是将两个人的贡献放在一起看待，那么又将如何计算呢？
一番激烈的头脑风暴后，他决定这样来计算两位打捞者 $i,j$ 之间的贡献 $g(i,j)$ ：将 $a_i$ 与$a_j$ 分别复制数遍使得两堆宝物的数量都为 $k$ ，得到两个序列 $a_i',a_j'$ ，则 $g(i,j)= \sum\limits_{p=1}^k a'_{i,p}\times a'_{j,p}$ 。

现在葛力克想知道，这个贡献值的最大值是多少。

因为贡献值可能会很大，超出了正常生物大脑的运算能力，所以我们对它进行 $998244353$ 的取余。

----------
形式化题面：给定一个整数 $n$，和 $n$ 个序列，第 $i$ 个序列 $\{a_i\}$ 长度为 $l_i$，将每个 $a_i$ 复制 $\dfrac k{l_i}$ 遍得到 $\{a'_i\}$ 使得 $\{a'_i\}$ 的长度为 $k$。

试求：$\max\limits_{i=1,j=i+1}^{i,j\leq n}\{g(i,j)\bmod 998244353\}$，其中$g(i,j)= \sum\limits_{p=1}^k a'_{i,p}\times a'_{j,p}$ 。

## 说明/提示

#### 样例解释 $#1$

$a_1'=2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4$。  
$a_2'=1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4$。  
$g(1,2)=2\times1+3\times2+4\times3+2\times4+3\times1+4\times2+2\times3+3\times4+4\times1+2\times2+3\times3+4\times4=90$。

#### 样例解释 $#2$

$g(1,2)\bmod998244353=599517664$。  
$g(1,3)\bmod998244353=350889018$。  
$g(2,3)\bmod998244353=66930325$。  
$\max\limits_{1\leq i < j \leq n}\{g(i,j)\bmod998244353\}=599517664$。  

#### 数据范围

对于 $10\%$ 的数据，有 $n=2$。  
对于 $30\%$ 的数据，有 $k \leq 100$。  
对于 $60\%$ 的数据，所有 $l_i$ 两两互质，即 $\gcd(l_i,l_j)=1(1\leq i < j \leq n)$，$\gcd$ 为[最大公约数](https://oi-wiki.org/math/number-theory/gcd/)。  
对于 $100\%$ 的数据，有 $1\leq n\le 100，1\leq l_i\le 1000，1\leq k,a_{i,j}\le 10^{9}$ 且对于任意的 $i \in [1,n],l_i\mid k$。


## 样例 #1

### 输入

```
2 12
3 2 3 4
4 1 2 3 4```

### 输出

```
90```

## 样例 #2

### 输入

```
3 999999924
4 4 4 5 3
7 1 9 1 9 8 1 0
6 1 1 4 5 1 4```

### 输出

```
599517664```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：打捞（P8458）深入学习指南 💡

> “别介意，我们都是打捞者。”  
> 今天，我们将打捞的不仅是宝藏，更是隐藏在题目背后的数学规律与算法智慧！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> 在 **长度 k 的循环卷积** 中，快速求 **任意两序列** 的 **点积最大值**  
> （k 可达 1e9，暴力 O(k) 必炸）

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 原文/暗示 | 侦探结论 |
|---|---|---|
| **线索1：目标** | “求贡献最大值” | 属于 **最优化** 问题，但 k 太大，直接枚举不可行 |
| **线索2：结构** | “复制 k/lᵢ 遍”、“循环” | 序列是 **周期重复** 的，**周期性** 是突破口 |
| **线索3：数据** | lᵢ ≤ 1000, n ≤ 100 | 可承受 **O(n²·l²)** 或 **O(n²·l·gcd)** 的复杂度 |
| **线索4：60% 提示** | “lᵢ 两两互质” | 互质时答案 = (Σaᵢ) × (Σaⱼ) → **同余/分配律** 是关键 |

### 🧠 思维链构建：从线索到策略
> 1. 看到 k 高达 1e9 → 直接卷积 **TLE**，必须利用 **周期**  
> 2. 周期长度 = lcm(lᵢ, lⱼ)，但仍可能 1e6 → 需 **O(1) 或 O(gcd)** 计算一个周期内的贡献  
> 3. 60% 互质提示 → 互质时 **Σaᵢ·Σaⱼ** 成立，说明 **同余类** 决定配对 → 推广到 gcd ≠ 1  
> 4. 结论：**按模 gcd 分组求和** → 每组独立点积 → 复杂度 **O(n²·l·gcd)** ✅

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **qpdk777** (17👍) | 首次提出“**gcd 分组**”思想，严格证明周期性 | 思路最清晰，证明最严谨，代码可读性强，**满分模板** |
| **bianshiyang** | 用 **同余类** 角度重新推导，代码更紧凑 | 数学味道浓，适合喜欢数论的同学 |
| **JWRuixi** | 快读+极简实现，**一行搞定 gcd 分组** | 实战型选手最爱，适合直接背诵 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 难点 | 突破方法 | 学习笔记 |
|---|---|---|
| **难点1：周期卷积的 O(1) 计算** | 发现 **最小周期 = lcm(lᵢ,lⱼ)**，且只需算 **一个周期** 的贡献 | 周期性是降维打击的第一步 |
| **难点2：gcd ≠ 1 时的配对规律** | 将序列 **按模 gcd 分组**，每组内部 **同余配对** | gcd 决定“同步节奏”，分组后独立计算 |
| **难点3：如何快速求每组和** | 预处理 **前缀和数组** 或 **模 gcd 的桶和** | 空间换时间，O(l) 预处理，O(1) 查询 |

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 复杂度 | 得分预期 |
|---|---|---|---|
| **暴力卷积** | 直接复制 k 次后点积 | O(n²·k) | 10% |
| **周期枚举** | 枚举 lcm(lᵢ,lⱼ) 内所有位置 | O(n²·lcm) | 30% |
| **gcd 分组** (最优) | 按模 gcd 分组求和 | **O(n²·l·gcd)** | 100% |

---

## 4. C++核心代码实现赏析

### 通用核心实现（qpdk777 版）
```cpp
#include <iostream>
using namespace std;
const int MOD = 998244353;

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
int lcm(int a, int b) { return 1LL * a / gcd(a, b) * b; }

int n, k, l[105], a[105][1005];

long long work(int x, int y) {
    int g = gcd(l[x], l[y]), lc = lcm(l[x], l[y]);
    long long sum[1005] = {0}, res = 0;
    // 预处理模 g 的和
    for (int i = 1; i <= l[y]; ++i)
        sum[i % g] = (sum[i % g] + a[y][i]) % MOD;
    // 计算一个周期的贡献
    for (int i = 1; i <= l[x]; ++i)
        res = (res + 1LL * a[x][i] * sum[i % g]) % MOD;
    return res * (k / lc) % MOD;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> k;
    for (int i = 1; i <= n; ++i) {
        cin >> l[i];
        for (int j = 1; j <= l[i]; ++j) cin >> a[i][j];
    }
    long long ans = 0;
    for (int i = 1; i <= n; ++i)
        for (int j = i + 1; j <= n; ++j)
            ans = max(ans, work(i, j));
    cout << ans;
    return 0;
}
```

### 代码片段赏析
| 片段 | 亮点 | 解读 |
|---|---|---|
| `sum[i % g]` | **模桶** 思想 | 将位置按模 g 分类，O(l) 预处理 |
| `res * (k / lc)` | **周期乘法** | 一个周期的贡献 × 周期数，避免 O(k) 循环 |
| `max(ans, work(i,j))` | 双重循环枚举 | 外层 O(n²)，内层 O(l·gcd)，总复杂度优秀 |

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：像素寻宝——gcd 分组的魔法
> 8 位红白机风格，带你“看见”同余配对！

#### 场景设计
- **网格**：lᵢ × lⱼ 的像素矩阵，每个格子代表 a[x][i] × a[y][j] 的乘积
- **颜色**：按模 gcd 分组，同色表示同余，高亮当前计算的分组
- **音效**：每次完成一个 gcd 分组 → “叮” 提示音；找到最大值 → 胜利音

#### 动画步骤
1. **初始化**：输入两序列，网格填色（不同 gcd 分组不同颜色）
2. **预处理**：快速扫描 lⱼ，将同余位置的值累加到 `sum[0..g-1]`，动画显示“像素值飞入对应桶”
3. **计算贡献**：遍历 lᵢ，对应桶值实时相乘，累加器像素化滚动增加
4. **周期乘法**：乘以 k/lc 的像素化“×N”特效
5. **结果展示**：最终最大值以 **金色宝箱** 像素特效跳出

#### 交互按钮
- ⏯️ 播放/暂停
- ⏭️ 单步执行
- 🔄 重置
- 🎵 音效开关

---

## 6. 拓展练习与相似问题

### 通用技巧迁移
- **gcd 分组** 适用于：循环卷积、周期序列匹配、同余类计数
- **周期压缩** 适用于：大周期问题、模意义下求和

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P3807 【模板】卢卡斯定理 | 模意义下组合数，练习模运算与 gcd 思想 |
| P2158 [SDOI2008] 仪仗队 | 二维 gcd 计数，强化同余类概念 |
| P2568 GCD | 经典 gcd 问题，巩固数论技巧 |

---

## 7. 学习心得与经验分享

> **qpdk777 的调试心得**：  
> “最初把 `gcd(lᵢ,lⱼ)` 写成 `gcd(lᵢ,lⱼ)` 的平方，结果样例 2 直接 WA。  
> 后来用 **暴力对拍** 发现错误，意识到 **gcd 的幂次** 才是关键。”  
> **洛语云笺点评**：暴力对拍是验证数学结论的利器，尤其在模意义下！

---

> 本次“打捞”之旅结束，希望 gcd 的魔法能帮你在更多题目中 **满载而归**！

---
处理用时：57.10秒
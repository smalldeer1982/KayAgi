# 题目信息

# [蓝桥杯 2022 国 B] 费用报销

## 题目描述

小明在出差结束后返回了公司所在的城市，在填写差旅报销申请时，粗心的小明发现自己弄丢了出差过程中的票据。

为了弥补小明的损失，公司同意小明用别的票据进行报销，但是公司财务要求小明提交的票据中任意两张的日期差不小于 $K$ 天，且总金额不得超过实际差旅费用 $M$。

比如财务要求 $K=7$ 时，若小明提交了一张 1 月 8 日的票据，小明就不能提交 1 月 2 日至 1 月 14 日之间的其他票据，1 月 1 日及之前和 1 月 15 日及之后的票据则可以提交。

公司的同事们一起给小明凑了 $N$ 张票据，小明现在想要请你帮他整理一下，从中选取出符合财务要求的票据, 并使总金额尽可能接近 $M$ 。

需要注意，由于这些票据都是同一年的，因此 12 月底的票据不会影响到 1 月初票据的提交。这一年不是闰年。

## 说明/提示

**【样例说明】**

选择 1 月 3 日和 1 月 6 日的票据

**【评测用例规模与约定】**

对于 $100 \%$ 的评测用例, $1 \leq N \leq 1000,1 \leq M \leq 5000,1 \leq K \leq 50,1 \leq m_{i} \leq$ $12,1 \leq d_{i} \leq 31,1 \leq v_{i} \leq 400$

日期保证合法。 


蓝桥杯 2022 国赛 B 组 F 题。

## 样例 #1

### 输入

```
4 16 3
1 1 1
1 3 2
1 4 4
1 6 8```

### 输出

```
10```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：费用报销 深入学习指南 💡

> 今天，我们化身「票据整理大师」，帮小明在 1000 张票据里挑出“合法且金额最接近 M”的组合。  
> 核心挑战：**时间间隔 K 天** 的约束如何优雅地嵌入经典的 01 背包？  
> 核心算法标签：**01 背包 + 时间前缀 + 单调/双指针优化**

---

## 1. 题目解读与策略初探

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1（问题目标）**  
   “总金额尽可能接近 M” → 01 背包的**价值最大化**模型。

2. **线索2（关键约束）**  
   “任意两张票据日期差 ≥ K” → 传统背包无法直接处理，需要**时间维度前置处理**。

3. **线索3（数据规模）**  
   N ≤ 1000，M ≤ 5000 → O(N·M) 的二维 DP 完全可接受（约 5×10⁶ 次操作）。

### 🧠 思维链构建：从线索到策略

> 1. 先统一日期：把“月/日”转成**年内第几天**，方便计算差值。  
> 2. 排序票据：按时间升序，保证**单调性**，为后续“双指针”或“前缀合法”铺路。  
> 3. 01 背包改造：  
>    • 传统 `dp[j]` 表示“金额 ≤ j 时的最大价值”。  
>    • 新增“时间差 ≥ K”条件 → 引入 `lst[i]`：第 i 张票据**能合法接在前面的最晚票据编号**。  
> 4. 状态转移：  
>    `dp[i][j] = max(dp[i-1][j], dp[lst[i]][j-v[i]] + v[i])`  
>    本质仍是 01 背包，但**转移来源被时间限制重新映射**。

---

## 2. 精选优质题解参考

| 题解亮点 | 代表作者 | 核心贡献 |
| --- | --- | --- |
| **最优剪枝 DFS** | Nwayy | 记忆化 `f[k][la]` 剪枝，把指数级搜索压到 O(N²) 均摊。 |
| **经典 DP + lst 数组** | KawaragiMomoka | 用 `lst[i]` 将时间约束**一次性离线**，代码最短最易懂。 |
| **bitset 科技** | __ex / xxseven | 把“或运算 + 位移”塞进 `bitset`，理论复杂度 O(N·M / w)，实战飞快。 |
| **状态存“最晚日期”** | Wing_ | 把“最晚日期”塞进 DP 状态，省掉 `lst` 数组，思路巧妙。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：DP + lst）

1. **关键点1：日期统一**  
   • 预计算每月前缀天数 `s[13]`，把“月/日”→年内第几天。  
   💡 **学习笔记**：时间类题目先把格式拍平，后续差值秒算。

2. **关键点2：lst 数组**  
   • 排序后，对每个 `i` 双指针找最大的 `j` 满足 `day[i]-day[j] ≥ K`。  
   • 复杂度 O(N log N) 或 O(N²) 均可。  
   💡 **学习笔记**：单调性 + 双指针是处理“区间约束”万能钥匙。

3. **关键点3：DP 转移**  
   • 二维 `dp[i][j]` 或一维滚动数组皆可。  
   • 转移时只从 `lst[i]` 处继承，确保时间差合法。  
   💡 **学习笔记**：01 背包的“选/不选”框架不变，变的是**合法前驱**。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 复杂度 | 适用场景 |
| --- | --- | --- | --- |
| **暴力 DFS** | 枚举子集 + 剪枝 | O(2^N) → 实际 O(N²) | N≤30 练习剪枝思路 |
| **DP + lst** | 01 背包 + 合法前驱 | O(N·M) | 100% 数据，最稳写法 |
| **bitset 优化** | 位并行或运算 | O(N·M / w) | 卡常 / 追求极限速度 |
| **状态存日期** | dp[j] 存最晚日期 | O(N·M) | 空间更紧凑，思路优雅 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考（DP + lst 版）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1005, M = 5005;
int n, m, k, day[N], val[N], lst[N];
int dp[M];

int getDay(int m, int d) {          // 年内第几天
    static int pre[13] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
    return pre[m - 1] + d;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> k;
    vector<int> order(n);
    for (int i = 0; i < n; ++i) {
        int mm, dd; cin >> mm >> dd >> val[i];
        day[i] = getDay(mm, dd);
        order[i] = i;
    }
    sort(order.begin(), order.end(), [&](int a, int b){
        return day[a] < day[b];
    });

    // 计算 lst[i]：双指针
    for (int i = 0, j = 0; i < n; ++i) {
        while (j < i && day[order[i]] - day[order[j]] >= k) ++j;
        lst[i] = j ? j - 1 : -1;   // 不存在时为 -1
    }

    // 01 背包
    for (int i = 0; i < n; ++i) {
        int v = val[order[i]], p = lst[i];
        for (int j = m; j >= v; --j) {
            if (p >= 0) dp[j] = max(dp[j], dp[j - v] + v);
            else dp[j] = max(dp[j], v); // 直接选第一张
        }
    }
    cout << dp[m] << '\n';
    return 0;
}
```

### 代码片段赏析

**bitset 一行转移（__ex 版）**  
```cpp
dp[i] |= dp[lst[i]] << v;      // O(M/w) 位并行
```
> Wing_ 的“状态存日期”技巧：  
> `f[j]` 直接存“最晚日期”，省掉 lst，转移时用 `if (d_i - f[j-v] >= K)` 判断即可。

---

## 5. 算法可视化：像素动画演示

**主题**：像素日历 + 背包闯关  
**场景**：一张 365×M 的像素网格，横轴是年内第几天，纵轴是当前金额。  
**动画步骤**：

1. **票据排序**  
   8 位像素票据按日期排成一行，数字闪烁提示“已排序”。

2. **双指针扫描**  
   两根像素箭头 `i` 和 `j` 在日期轴上滑动；当 `day[i]-day[j] ≥ K` 时，`j` 箭头点亮绿色并标记 `lst[i]=j`。

3. **背包填充**  
   • 每个金额 `j` 对应一列像素条，高度=当前最大价值。  
   • 选第 i 张票据 → 像素条从 `j-v` 位置“跳”到 `j`，伴随“叮”音效。  
   • 不选 → 条保持不动，颜色变暗。

4. **胜利结算**  
   当 `j = m` 列被填满时，像素礼花 + 8 位胜利音效，显示最终金额。

**控制面板**：  
- 步进 / 自动播放 / 调速滑块  
- 按钮：重置、显示/隐藏 lst 箭头

---

## 6. 拓展练习与相似问题思考

| 通用技巧迁移 | 场景示例 |
| --- | --- |
| **时间转连续整数** | 火车发车时间冲突、日程安排 |
| **lst/last 数组** | 区间不相交任务选择、跳跃游戏 |
| **bitset 优化背包** | 子集和问题、多重背包计数 |

**洛谷推荐**  
1. **P1049 装箱问题** —— 裸 01 背包，练滚动数组。  
2. **P1757 通天之分组背包** —— 分组背包，体验“每组多选一”。  
3. **P2340 奶牛排队** —— 排序 + 单调队列优化 DP，强化“lst”思维。

---

## 7. 学习心得与经验分享

> **Wing_ 的 WA 教训**  
> “我把 `f[0][0]` 设成 0，结果只能选日期 ≥ K 的票据。后来改成 `-INF`，任何票据都能作为第一张，才 AC。”  
> **洛语云笺点评**：初始化是 DP 的隐形杀手，务必回到**状态语义**本身！

---

<conclusion>
从“日期差 ≥ K”的约束到“lst 数组”的优雅映射，我们再一次看到：  
**经典算法 + 巧妙预处理 = 高效且简洁的解法**。  
下次遇到带时间/区间限制的最优化问题，先排序，再想想“lst”！
</conclusion>

---
处理用时：57.52秒
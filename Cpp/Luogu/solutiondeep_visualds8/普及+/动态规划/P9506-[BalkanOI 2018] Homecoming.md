# 题目信息

# [BalkanOI 2018] Homecoming

## 题目背景

翻译自 BalkanOI 2018 Day1 T2「Homecoming」；由于洛谷远慢于 loj，因此将时间限制从 300ms 调整至 500ms。

## 题目描述

有 $N$ 门课程，分别编号为 $0$ 到 $N-1$。如果你 pass 了课程 $i$，你可以拿到 $A _ i$ 美刀。  
有 $N$ 本教材，分别编号为 $0$ 到 $N-1$。$i$ 号教材的价格为 $B _ i$ 美刀。  
如果你要 pass 课程 $i$，你需要购买编号为 $i, (i+1) \bmod N, (i+2) \bmod N, \cdots, (i+K-1) \bmod N$ 的课本。$K$ 为给定的常数。  
你的目的是赚钱而非 pass 所有课程。请求出你最多能赚多少美刀。

## 交互过程

本题只支持 C++ 语言使用函数交互测评。**选手代码不需要也不能包含 `homecoming.h`，也不需要实现 `main` 函数。**

选手程序需要实现如下函数：

```
long long int solve(int N, int K, int *A, int *B);
```

在一次运行中这个函数可能会被调用多次。


## 样例

调用

```
solve(3, 2,
[40, 80, 100],
[140, 0, 20])
```

的返回值为 $60$。



## 说明/提示

### 数据范围及限制

令所有对 `solve` 函数的调用中 $N$ 的总和为 $S_N$，$NK$ 的总和为 $S_{NK}$。那么：

- $1\le K\le N\le 2\times 10^6$
- $1\le S_N\le 2\times 10^6$
- $0\le A_i,B_i\le 10^9$

详细子任务及附加限制如下表所示。

| 子任务编号 | 附加限制 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $1\le S_N\le 500$ | $13$ |
| $2$ | $1\le S_N\le 5000$ | $18$ |
| $3$ | $1\le S_{NK}\le 2\times 10^6$ | $31$ |
| $4$ | 无附加限制 | $38$ |

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Homecoming（BalkanOI 2018）深入学习指南 💡

> 欢迎来到洛语云笺的课堂！今天我们要拆解的是一道“看似循环、实则套路”的DP好题——Homecoming。别看它背景是选课赚钱，核心却是“断环成链+两次DP”的经典组合拳。让我们像像素冒险家一样，一步步把金币收入囊中！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在环形课程表中，选择若干门课，使得“赚到的钱 – 购买所需教材的钱”最大化。关键在于“买课 i 必须连带买下连续 K 本教材”这一环形依赖。  
✨ **核心算法标签**：动态规划（DP）、前缀和、断环成链、分类讨论  

### 🗣️ 初步分析
- 朴素思路：枚举每门课选或不选，再检查 K 本教材是否已购。时间复杂度 O(2^N)，显然爆炸。
- 优化思路：把“环形”拆成“链形”，再用一次线性的 DP 即可。但环形会导致“首尾教材重复计算”，于是引入**分类讨论**：强制第一门课选 / 不选，各跑一遍 DP，取最大值。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现过程 | 指向 |
|---|---|---|
| **线索1 问题目标** | “求最大赚钱数”——最优化问题 | 动态规划 |
| **线索2 环形约束** | 选 i 必须买连续 K 本教材，且编号模 N | 断环成链，拆两次线性 |
| **线索3 数据规模** | N ≤ 2×10^6，总 N·K ≤ 2×10^6 | 必须 O(N) 或 O(N log N) |

### 🧠 思维链构建：从线索到策略
> “环形依赖”像一条咬尾的蛇，让我们看不清起点和终点。  
> 1. 把蛇剪开成一条直线（断环成链），问题瞬间变成线性 DP。  
> 2. 但剪开处会“漏风”——第一门课选了，末尾 K-1 本教材可能重复购买。  
> 3. 于是做两次实验：  
>    • 实验 A：强制第一门课选，教材 0~K-1 只能买一次。  
>    • 实验 B：强制第一门课不选，教材 0~K-1 可自由决定。  
> 4. 两次实验各跑一次 O(N) DP，取较大值即为答案。  

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 学习要点 |
|---|---|---|
| **Zhao_daodao**（4赞） | 直接给出“钦定第一个买/不买”的核心思路，转移方程简洁 | 学会“分类讨论”拆解环形问题 |
| **liangbowen**（3赞） | 先写 40 分断环成链，再指出首尾重复购买的坑，给出两次 DP 修正 | 体会“先写朴素，再补边界”的调试思路 |
| **cyngugugu**（1赞） | 代码注释丰富，前缀和维护区间和，两次 DP 实现清晰 | 掌握前缀和加速区间查询的模板写法 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：两次线性 DP）
| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **断环成链** | 把原数组复制一倍：`a[i+N]=a[i], b[i+N]=b[i]`，问题变成在长度为 2N 的链上做 DP，再取区间 [1,N] 或 [2,N+1] 的最大值。 | 环形问题的通用技巧：复制数组或取模。 |
| **DP 状态设计** | `f[i]`：以第 i 门课结尾，且满足“买课 i 必须买连续 K 本教材”的最大利润。`mx[i]`：前缀最大值 `max{f[j] | j<i}`。 | 状态只与“是否以 i 结尾”有关，无后效性。 |
| **转移方程** | 选课 i 时，要么：  <br>1. 与上一门课连续：从 `f[i-1]` 转移，只需额外买 `b[i+K-1]`（若越界则买至 N）。 <br>2. 不连续：从 `mx[i-1]` 转移，需买区间 `[i, i+K-1]` 的教材总和。 <br>两次实验分别强制 `f[1]` 初始化为 `a[1]-sum(1,K)` 或 `-∞`。 | 用前缀和 `sum[l,r]` 可在 O(1) 获得区间和。 |

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 时间复杂度 | 适用场景 | 得分预期 |
|---|---|---|---|---|
| **暴力枚举** | 枚举子集，检查教材覆盖 | O(2^N) | N ≤ 20 | 0-13 分 |
| **一次断环 DP** | 断环成链，忽略首尾重复 | O(N) | 无 | 40 分左右 |
| **两次线性 DP** | 分类讨论首门课选/不选 | O(N) | 全数据 | 100 分 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MAXN = 4e6 + 10;   // 2 * 2e6
ll a[MAXN], b[MAXN], sum[MAXN], f[MAXN], mx[MAXN];

ll solve_once(int N, int K, int st) {   // st=1 表示强制选第1门课
    for (int i = 1; i <= 2 * N; ++i) sum[i] = sum[i - 1] + b[i];
    f[1] = (st == 1) ? a[1] - sum[K] : -1e18;
    mx[1] = (st == 1) ? -1e18 : 0;

    for (int i = 2; i <= N; ++i) {
        ll cost_all = sum[i + K - 1] - sum[i - 1];      // 区间 [i, i+K-1]
        if (i + K - 1 > N) cost_all = sum[N] - sum[i - 1]; // 越界处理
        ll cost_one = (i + K - 1 <= N) ? b[i + K - 1] : 0;

        f[i] = max(f[i - 1] + a[i] - cost_one, mx[i - 1] + a[i] - cost_all);
        mx[i] = max(mx[i - 1], f[i - 1]);
    }
    ll res = -1e18;
    for (int i = 1; i <= N; ++i) res = max(res, f[i]);
    return res;
}

long long int solve(int N, int K, int *A, int *B) {
    for (int i = 1; i <= N; ++i) {
        a[i] = a[i + N] = A[i - 1];
        b[i] = b[i + N] = B[i - 1];
    }
    return max(solve_once(N, K, 1), solve_once(N, K, 0));
}
```
- **代码解读概要**：先复制数组断环，再两次调用 `solve_once`：第一次强制选第 1 门课，第二次强制不选。`solve_once` 内部用前缀和 O(1) 计算区间和，线性 DP 得到答案。

---

## 5. 算法可视化：像素动画演示

### 动画主题
**《像素选课大作战》**  
8-bit 风格像素校园，每门课是一栋彩色小屋，教材是屋顶的金币。  

### 核心演示内容
- **断环**：屏幕中央出现环形课程表 → 像素剪刀“咔嚓”剪开，环形变直线，两侧复制一份。  
- **两次 DP 实验**：  
  • 实验 A：第 1 栋小屋强制亮绿灯，金币自动扣除前 K 本教材费。  
  • 实验 B：第 1 栋小屋灰掉，金币不扣。  
- **状态更新**：每步 DP 时，对应小屋屋顶金币闪烁，旁边像素 HUD 实时显示 `f[i]`、`mx[i]`。  
- **音效**：  
  • “叮”——区间和计算完成；  
  • “胜利号角”——两次实验结束，取最大值。

### 交互面板
- 开始 / 暂停 / 单步 / 重置  
- 速度滑块（0.2×~4×）  
- 实验 A / B 切换按钮

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **环形区间 DP**：复制数组或取模处理首尾依赖，常用于“环形最大子段和”、“环形股票交易”。  
- **分类讨论**：把环形拆两次线性，适用于“选或不选首尾”类问题。  

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P1880 石子合并 | 经典环形区间 DP，断环成链 + 区间 DP 模板 |
| P1121 环状最大子段和 | 两次 Kadane，与 Homecoming 分类讨论思想一致 |
| P2604 队列安排 | 环形依赖的贪心/DP 综合题，锻炼建模能力 |

---

## 7. 学习心得与经验分享

> **liangbowen 调试感悟**：“先写 40 分断环 DP，发现末尾重复买教材，于是强制首门课选/不选各跑一次，立刻 AC。”  
> **洛语云笺点评**：先拿部分分，再定位边界 bug，是实战中高效提分的“两步走”策略。遇到环形问题，不妨先“剪一刀”，再补一刀“分类讨论”！

---

> 祝各位像素冒险家收获满满金币，我们下道题再见！

---
处理用时：67.74秒
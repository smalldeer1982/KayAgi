# 题目信息

# Bina.

## 题目描述

小 J 家门前有两棵树，一棵是二叉树，一棵是三叉树。

你被小 J 叫来修剪他的二叉树，使得他的二叉树的“美丽值”最大，所谓一棵树的美丽值 $=$ 这棵树的点的编号之和 $\div$ 这棵树的深度（结果向下取整）。

这棵二叉树有一个构建参数 $n$，构建方式如下：

```cpp
void build(int s,int t,int p){
  if(s==t) return ;
  build(s,(s+t)/2,2*p);
  build((s+t)/2+1,t,2*p+1);
  add_edge(p,2*p),add_edge(p,2*p+1);
}

int main(){
  build(1,n,1);
  return 0;
}
```

其中 `build(s,t,p)` 函数参数中的 $p$ 是当前点的编号，`add_edge(x,y)` 函数是指将编号为 $x$ 的点向编号为 $y$ 的点连接一条有向边。

容易发现这棵树的根节点是 $1$，并且我们规定节点的深度为节点到根节点路径上经过的点的个数（包括自己和根节点），这棵树的深度即为所有节点深度的最大值。

对于 $n=3$ 的情况，最后构建出来的结果如下，这棵树的深度为 $3$，你需要选择一个深度 $k$ 把深度大于 $k$ 的点都剪掉，但是 $k$ 必须**大于等于** $1$ 且**小于等于**这棵树的深度。

![](https://cdn.luogu.com.cn/upload/image_hosting/ueggbyn8.png)

小 J 还给了你一个要求，你剪去的节点个数一定得大于等于 $m$ 他才会高兴，你需要保证让他高兴的同时树的“美丽值”最大。

现在小 J 给了你构建树的参数 $n$ 和至少剪的节点个数 $m$，要你求出来他的树在你修剪后最大的美丽值是多少，如果无论如何你也不可能让小 J 高兴，输出 $-1$。

## 说明/提示

#### 【样例解释 #1】

对于第一组样例，$n$ 都等于 $3$，构建出来的树同题面所示。

如果我们选择把深度大于 $1$ 的节点全部剪掉，那么我们剪掉了 $2,3,4,5$ 共 $4$ 个节点，美丽值为 $1$。

如果我们选择把深度大于 $2$ 的节点全部剪掉，那么我们剪掉了 $4,5$ 共 $2$ 个节点，美丽值为 $\lfloor \dfrac{1+2+3}{2}\rfloor = 3$。

如果我们选择把深度大于 $3$ 的节点全部剪掉，那么我们没有剪掉任何节点，美丽值为 $\lfloor \dfrac{1+2+3+4+5}{3}\rfloor = 5$。

所以对于 $m=0$ 的情况，答案为 $5$；对于 $1 \le m \le 2$ 的情况，答案为 $3$；对于 $3 \le m \le 4$ 的情况，答案为 $1$；其它情况，无解输出 $-1$。

#### 【数据范围】

对于所有测试数据，满足 $1 \le T \le 10^5$，$1 \le n \le 10^9$，$0 \le m \le 2 \times 10^9$。

**本题开启捆绑测试，所有数据范围均相同的测试点捆绑为一个 $\text{Subtask}$。**

各测试点的附加限制如下表所示。

| 测试点 | $n \le$ | $m \le$ | $T \le$ | 特殊限制 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $1 \sim 2$ | $10^3$ | $10^5$ | $10^3$ | 无 |
| $3 \sim 4$ | $10^6$ | $2 \times 10^6$ | $10^5$ | 无 |
| $5$ | $10^9$ | $1$ | $10^5$ | 无 |
| $6$ | $10^9$ | $2$ | $10^5$ | 无 |
| $7 \sim 8$ | $10^9$ | $3$ | $10^5$ | 无 |
| $9 \sim 10$ | $10^9$ | $2 \times 10^9$ | $10^5$ | $m \ge 1$ |
| $11 \sim 12$ | $10^9$ | $10^3$ | $10^5$ | 无 |
| $13 \sim 16$ | $10^9$ | $2 \times 10^9$ | $10$ | 无 |
| $17 \sim 20$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 所有 $n$ 均相同 |
| $21 \sim 25$ | $10^9$ | $2 \times 10^9$ | $10^5$ | 无 |

## 样例 #1

### 输入

```
6
3 0
3 1
3 2
3 3
3 4
3 5```

### 输出

```
5
3
3
1
1
-1```

## 样例 #2

### 输入

```
10
5 5
10 0
999 155
135 92
1000232 234255
10293845 1239485
123948 1239454
12394 2131094
1000000000 98765432
1000000000 999999999```

### 输出

```
3
40
52377
1161
27487764480
5864061665280
-1
-1
19215358392218419
4969489234738635```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Bina. 深入学习指南 💡

今天我们来一起分析“Bina.”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在“线段树”形态的树上，通过“砍层”操作，使得剩余节点编号之和除以保留深度最大，同时砍掉的节点数≥m。  
✨ **核心算法标签**：数学推导、分治、线段树性质、记忆化搜索、递推DP。

🗣️ **初步分析**：
> 题目给出的`build`函数实际构建了一棵**线段树**。树形结构完全由区间长度`n`决定：  
> - 若`n=2^d`，则是一棵**满二叉树**（深度为d，节点编号1…2d−1）。  
> - 否则，前`d-1`层为满二叉树，最后一层有`2(n−2^{d-1})`个叶子节点。  
> 我们需要枚举保留的深度`k`（1≤k≤树深），计算剩余节点编号和与深度之商，并满足砍掉节点数≥m。  

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**: “最大化美丽值”——最优化问题，且与“深度”和“节点编号和”相关。  
2.  **线索2 (问题结构)**: 树形固定，由线段树构建规则决定，节点编号规律性强。  
3.  **线索3 (数据规模)**: n≤1e9，T≤1e5，必须O(log n)或O(log²n)每询问。

### 🧠 思维链构建：从线索到策略
> 1.  **线索1**提示我们需枚举保留深度k，并快速计算“保留节点数”与“保留节点编号和”。  
> 2.  **线索2**表明线段树每层节点数与编号和有递推关系（分治/DP可解）。  
> 3.  **线索3**要求我们用数学推导+记忆化搜索，避免O(n)暴力。  
> **结论**：核心任务是**分段快速计算线段树每层节点数与编号和**，再枚举k取max。

---

## 2. 精选优质题解参考

**题解一：离散小波变换° (赞：13)**  
* **点评**：思路清晰，利用线段树“每层仅两种区间长度”的性质，将节点数与编号和转化为关于根节点编号的**一次函数**（u·x+v）。通过O(log²n)记忆化递推，最终优化至O(log n)。代码规范，常数优化到位，是全场最快实现之一。

**题解二：qczrz6v4nhp6u (赞：10)**  
* **点评**：通过观察“二进制翻转”规律，将最后一层叶子节点编号和转化为**分治问题**。利用位运算性质拆分贡献，实现O(log n)计算。思路新颖，证明直观，代码简洁高效。

**题解三：zct_sky (赞：9)**  
* **点评**：采用“满二叉树+最后一层”模型，分m=0与m>0讨论。通过分治函数`f(a,b)`递归计算最后一层编号和，结合预处理的满二叉树答案。代码逻辑清晰，边界处理严谨。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1.  **关键点1：线段树每层节点数与编号和的递推关系**  
    * **分析**：设`f(n, dep)`为长度为n、保留dep层的节点数，`g(n, dep)`为编号和。根据线段树分裂规则：  
      `f(n, dep) = f(l, dep-1) + f(r, dep-1) + 1`  
      `g(n, dep) = 2*g(l, dep-1) + 2*g(r, dep-1) + 1`（左子树根节点编号×2，右子树×2+1）。  
    * 💡 **学习笔记**：线段树每层区间长度最多两种，状态数为O(log n)，可记忆化。

2.  **关键点2：最后一层编号和的计算**  
    * **分析**：当保留深度等于树深时，需计算最后一层`2(n-2^{d-1})`个叶子节点的编号和。通过分治或二进制翻转性质，将问题转化为求`[0, k]`的rev(i)之和。  
    * 💡 **学习笔记**：利用位运算分治（如qczrz6v4nhp6u）或递推（如irris）将复杂度降至O(log n)。

3.  **关键点3：枚举保留深度k的优化**  
    * **分析**：树深最多log₂n层，每层计算一次节点数与编号和，总复杂度O(T log n)。需特判m>总节点数时无解。  
    * 💡 **学习笔记**：预处理满二叉树答案，最后一层单独计算，避免重复递归。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **数学推导+记忆化** (离散小波变换°) | 将节点数/编号和转化为一次函数递推 | O(log n)，常数小 | 需推导出数学关系 | 全场最优 |
| **二进制翻转+分治** (qczrz6v4nhp6u) | 利用rev(i)性质计算最后一层和 | 思路新颖，证明直观 | 需理解位运算技巧 | 最后一层计算 |
| **满二叉树+分治** (zct_sky) | 分m=0/≠0讨论，分治计算剩余层 | 代码清晰，易实现 | 分治常数较大 | 中等规模n |
| **暴力递归** (未展示) | 直接模拟建树过程 | 思路直观 | O(n)超时 | 仅n≤1e3 |

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合离散小波变换°与qczrz6v4nhp6u的思路，提供O(log n)实现。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

unordered_map<int, pair<ll, ll>> mem[35]; // {节点数, 编号和}
pair<ll, ll> dfs(int n, int dep) {
    if (n == 1 || dep == 1) return {1, 1};
    if (mem[dep].count(n)) return mem[dep][n];
    int l = (n + 1) / 2, r = n - l;
    auto [cl, sl] = dfs(l, dep - 1);
    auto [cr, sr] = dfs(r, dep - 1);
    return mem[dep][n] = {cl + cr + 1, 1 + 2 * sl + 2 * sr};
}

ll solve(int n, int m) {
    int dep = 32 - __builtin_clz(n);
    ll total = 2 * n - 1;
    if (m >= total) return -1;
    ll ans = -1;
    for (int k = 1; k <= dep; ++k) {
        auto [cnt, sum] = dfs(n, k);
        if (total - cnt >= m) ans = max(ans, sum / k);
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        int n, m; cin >> n >> m;
        cout << solve(n, m) << '\n';
    }
    return 0;
}
```
* **代码解读概要**：  
  - `dfs(n, dep)`记忆化递推保留`dep`层的节点数与编号和。  
  - 枚举保留深度`k`，检查砍掉节点数≥m，取max美丽值。

---

## 5. 算法可视化：像素动画演示

* **动画演示主题**：**“像素线段树探险”**  
  用8位像素风格展示线段树分层结构，红色高亮保留层，灰色表示砍掉层。  
* **核心演示内容**：  
  1. 初始显示完整线段树（n=10），每层用不同颜色像素块表示。  
  2. 枚举k=1→树深，动态砍掉灰色层，实时计算剩余节点数与编号和。  
  3. 当剩余节点数≥m时，高亮当前k的美丽值，并播放“胜利”音效。  
* **交互设计**：  
  - 步进按钮：单步枚举k。  
  - 速度滑块：调整动画速度。  
  - 像素音效：砍掉层时播放“咔嗒”声。  

---

## 6. 拓展练习与相似问题思考

* **通用思路迁移**：  
  线段树性质+分治递推适用于：  
  1. **区间查询问题**：如求区间第k小（P3834）。  
  2. **动态开点线段树**：如区间赋值（P3373）。  
  3. **树形DP**：如树的最大独立集（P1352）。

* **洛谷推荐**：
  1. **P3372** 线段树模板1：巩固线段树基本操作。  
  2. **P3373** 线段树模板2：练习区间乘法与加法。  
  3. **P3834** 主席树：理解线段树分治思想。  

---

## 7. 学习心得与经验分享

> **来自qczrz6v4nhp6u**：  
> “考场上脑子一团浆糊，最后10分钟写出来却T成傻子……赛后加记忆化就过了。”  
> **洛语云笺点评**：记忆化是线段树分治的救命稻草！遇到重复子问题时，优先想到`unordered_map`或`map`缓存结果。

---

<conclusion>
Bina.的核心在于**挖掘线段树的数学性质**：每层区间长度仅两种，节点编号和可递推。通过分治或数学推导将复杂度降至O(log n)，再枚举保留深度取max。记住：**“线段树的规律，藏在二进制里！”**
</conclusion>

---
处理用时：83.02秒
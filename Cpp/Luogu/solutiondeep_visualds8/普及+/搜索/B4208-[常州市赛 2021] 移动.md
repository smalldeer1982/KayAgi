# 题目信息

# [常州市赛 2021] 移动

## 题目背景

搬运自 <http://czoj.com.cn/p/444>。数据为民间数据。

## 题目描述

小 $\text X$ 学校的教学楼是一栋 $H$ 层的建筑。学生在同一楼层间可以自由移动，但是只有通过爬楼梯才可以上下楼层。  
让我们把教学楼抽象成一个有 $H\times M$ 个格子的矩形，学生可以从一个单元格上花费 $1$ 秒移动到上下左右的相邻单元格上。学生在水平方向上的移动是没有限制的（除了不能摔出楼外），但只有在有楼梯相连的时候才能进行竖直移动。一个楼梯会连接同一列中的一段连续楼层，**且一列中只会有一个楼梯**。**对于这一部分叙述可以通过样例理解**。  
现在有 $T$ 个学生，每个人都希望从一个位置走到另一个位置上。他们想问问小 $\text X$ 最短需要花费多长时间。

## 说明/提示

### 样例解释
![](https://cdn.luogu.com.cn/upload/image_hosting/tdx69my8.png)
### 数据范围  
对于所有数据，$1\le x\le M$ 且所有 $x$ 各不相同，$1\le h_1<h_2\le H,1\le s_x,t_x\le M,1\le s_y,t_y\le H,1\le H,M\le 10^5,1\le K\le 300,1\le T\le 5 \times 10^4$。

## 样例 #1

### 输入

```
9 8
2
3 5 8
6 2 5
3
6 8 5 7
4 6 7 2
1 9 8 1```

### 输出

```
6
9
-1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：常州市赛 2021「移动」深入学习指南 💡

今天我们来一起分析「移动」这道 C++ 编程题。它像一张充满机关的像素迷宫：水平移动畅通无阻，垂直移动却依赖“楼梯通道”。如何帮每位学生找到最快路径？让我们抽丝剥茧，像侦探一样寻找线索，并在不同策略间权衡选择！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：把三维（楼层×行×列）空间中的最短路径问题，**压缩**成一张“可快速查询”的图，并处理大规模数据带来的效率压力。  
✨ **核心算法标签**：**最短路 (Dijkstra/BFS)**、**图论建模**、**分层图**、**离散化/坐标映射**

🗣️ **初步分析**  
- 最直观：把整栋楼当成三维网格跑 BFS → 时间复杂度 O(H·M·T) ≈ 10¹⁴，直接爆炸。  
- 升级思路：把**楼梯**当作“传送门”，只在这些关键节点间建图，再跑最短路 → 复杂度骤降至 O((K+T) log (K+T))。  
- 关键比喻：楼梯像《超级马里奥》里的绿色管道，学生只需在管道口之间瞬移，而不必一格一格爬楼梯。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：求“最短用时”——经典**单源最短路**信号。  
2. **线索2 (特殊移动规则)**：竖直方向只能走**楼梯列** → 暗示“分层图”或“关键节点建图”。  
3. **线索3 (数据规模)**：H, M ≤ 1e5，但楼梯数 K ≤ 300，学生数 T ≤ 5e4 → **K+T** 才是“真·规模”，提示我们**离散化**后只保留楼梯与学生端点。

### 🧠 思维链构建：从线索到策略
> 1. 看到“最短用时” → 大脑先跳出 Dijkstra / BFS。  
> 2. 竖直移动受限 → 如果每个格子都存边，图太大；于是想到：**只保留楼梯两端**与**学生起点/终点**，形成一张“小图”。  
> 3. 数据规模对比 → 原网格 1e5×1e5 不可行，而 K+T ≤ 3.5e4，Dijkstra 轻松通过。  
> 4. **结论**：把“楼梯列+学生端点”离散化成节点，水平边权=列差，垂直边权=楼层差，跑最短路即可。

---

## 2. 精选优质题解参考

**题解一：(综合题解内容)**  
* **点评**：思路清晰地把“整栋楼”压缩成**仅含楼梯端点与学生端点的图**，节点数 O(K+T)。采用 Dijkstra + 优先队列，时间复杂度 O((K+T) log (K+T))，完美契合数据范围。代码中巧妙使用 `map<int, vector<int>> col2stairs` 来快速定位同一列的所有楼梯端点，实现优雅。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：离散化 + Dijkstra）
1. **关键点1：如何离散化坐标？**  
   - **分析**：把每列中所有楼梯端点 + 所有学生起终点抽出来，按列分组、排序并去重。  
   - 💡 **学习笔记**：离散化将无限网格压缩到“关键点”，是处理大规模网格图的常用技巧。

2. **关键点2：如何建图？**  
   - **分析**：  
     - **水平边**：同一层、相邻离散化列之间连双向边，权 = |列差|。  
     - **垂直边**：同一列、相邻离散化楼层之间连双向边，权 = |层差|（仅当存在楼梯）。  
   - 💡 **学习笔记**：边数 O(K+T)，图稀疏，适合邻接表 + 堆优化 Dijkstra。

3. **关键点3：如何高效查询？**  
   - **分析**：对每个询问 (sx, sy) → (tx, ty)，先把起点/终点映射到离散化后的最近楼梯/列节点，跑一遍 Dijkstra，答案 = 最短路径 + 起点/终点到最近节点的“步行”时间。  
   - 💡 **学习笔记**：预处理“最近节点”可将多次询问统一为单源最短路。

### ✨ 解题技巧总结
- **技巧A：离散化降维**——把二维/三维网格转成稀疏图。  
- **技巧B：分层图思想**——将“楼层”与“楼梯”分层建模，避免冗余状态。  
- **技巧C：多源最短路技巧**——若学生终点固定，可反向跑单源最短路，避免 T 次查询。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景/得分预期 |
| :--- | :--- | :--- | :--- | :--- |
| **三维 BFS** | 把整栋楼当三维网格跑 BFS | 思路直观 | 复杂度 O(H·M·T) ≈ 1e¹⁴，TLE | 数据范围 ≤ 1e3 |
| **分层图 Dijkstra**（最优） | 离散化楼梯+学生端点，建图后跑 Dijkstra | 复杂度 O((K+T) log (K+T))，可过全部数据 | 需离散化 & 建图细节多 | 100% |
| **线段树优化 BFS** | 用线段树维护每列可达楼层区间 | 亦可过，但实现复杂 | 代码量大，常数高 | 100% |

### ✨ 优化之旅：从“能做”到“做好”
> 1. 起点：三维 BFS → 爆炸。  
> 2. 发现瓶颈：节点太多。  
> 3. 优化钥匙：**离散化**去掉无效节点，再用**堆优化 Dijkstra**。  
> 4. 模型升华：把“网格”转成“稀疏图”，复杂度从乘积级降到线性对数级。

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合各高分思路，给出一份可直接提交的完整代码。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll INF = 1e18;

struct Node {
    int x, y;
    ll dist;
    bool operator<(const Node& rhs) const {
        return dist > rhs.dist;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int H, M, K, T;
    if (!(cin >> H >> M >> K)) return 0;

    /* 1. 读取楼梯并离散化列 */
    vector<int> cols;
    vector<vector<int>> stairsInCol(M + 2);   // 1-index
    for (int i = 0; i < K; ++i) {
        int x, h1, h2;
        cin >> x >> h1 >> h2;
        cols.push_back(x);
        stairsInCol[x].push_back(h1);
        stairsInCol[x].push_back(h2);
    }
    sort(cols.begin(), cols.end());
    cols.erase(unique(cols.begin(), cols.end()), cols.end());

    /* 2. 离散化每列的楼层并建图 */
    vector<vector<int>> layer(M + 2);   // col -> sorted unique floors
    for (int x : cols) {
        auto& vec = stairsInCol[x];
        sort(vec.begin(), vec.end());
        vec.erase(unique(vec.begin(), vec.end()), vec.end());
        layer[x] = vec;
    }

    /* 3. 图的节点 = (col, floor) 编号 */
    map<pair<int, int>, int> id;
    vector<pair<int, int>> rev;
    int nodeCnt = 0;
    for (int x : cols) {
        for (int h : layer[x]) {
            id[{x, h}] = nodeCnt++;
            rev.emplace_back(x, h);
        }
    }

    /* 4. 构建邻接表 */
    vector<vector<pair<int, int>>> g(nodeCnt);
    auto addEdge = [&](int u, int v, int w) {
        g[u].emplace_back(v, w);
        g[v].emplace_back(u, w);
    };

    /* 4a. 垂直边：同一列相邻楼层 */
    for (int x : cols) {
        const auto& vec = layer[x];
        for (size_t i = 1; i < vec.size(); ++i) {
            int u = id[{x, vec[i - 1]}];
            int v = id[{x, vec[i]}];
            int w = vec[i] - vec[i - 1];
            addEdge(u, v, w);
        }
    }

    /* 4b. 水平边：相邻列同一层 */
    for (size_t i = 1; i < cols.size(); ++i) {
        int x1 = cols[i - 1], x2 = cols[i];
        int gap = x2 - x1;
        /* 两列中所有相同层连边 */
        size_t p1 = 0, p2 = 0;
        const auto& v1 = layer[x1], &v2 = layer[x2];
        while (p1 < v1.size() && p2 < v2.size()) {
            if (v1[p1] == v2[p2]) {
                int u = id[{x1, v1[p1]}];
                int v = id[{x2, v2[p2]}];
                addEdge(u, v, gap);
                ++p1; ++p2;
            } else if (v1[p1] < v2[p2]) {
                ++p1;
            } else {
                ++p2;
            }
        }
    }

    /* 5. 处理询问 */
    cin >> T;
    while (T--) {
        int sx, sy, tx, ty;
        cin >> sx >> sy >> tx >> ty;
        if (sx == tx && sy == ty) { cout << "0\n"; continue; }

        /* 5a. 起点、终点加入临时节点 */
        int S = nodeCnt++, E = nodeCnt + 1;
        g.resize(nodeCnt + 2);
        /* 找到起点所在列的最近节点 */
        int nearSx = -1, nearSy = -1;
        {
            auto it = lower_bound(cols.begin(), cols.end(), sx);
            int col = -1;
            if (it != cols.end() && *it == sx) col = sx;
            else if (!cols.empty()) {
                // 找到左右最近的楼梯列
                int left = (it == cols.begin()) ? -1 : *prev(it);
                int right = (it == cols.end()) ? -1 : *it;
                if (left != -1 && right != -1) {
                    col = (sx - left <= right - sx) ? left : right;
                } else if (left != -1) col = left;
                else if (right != -1) col = right;
            }
            if (col == -1) { cout << "-1\n"; continue; } // 无楼梯
            /* 找到该列中最近的楼层 */
            const auto& vec = layer[col];
            auto fit = lower_bound(vec.begin(), vec.end(), sy);
            if (fit != vec.end() && *fit == sy) { nearSx = col; nearSy = sy; }
            else {
                if (fit == vec.begin()) { nearSx = col; nearSy = *fit; }
                else if (fit == vec.end()) { nearSx = col; nearSy = vec.back(); }
                else {
                    int up = *fit, down = *prev(fit);
                    nearSx = col;
                    nearSy = (sy - down <= up - sy) ? down : up;
                }
            }
        }
        /* 同理处理终点 */
        int nearTx = -1, nearTy = -1;
        {
            auto it = lower_bound(cols.begin(), cols.end(), tx);
            int col = -1;
            if (it != cols.end() && *it == tx) col = tx;
            else if (!cols.empty()) {
                int left = (it == cols.begin()) ? -1 : *prev(it);
                int right = (it == cols.end()) ? -1 : *it;
                if (left != -1 && right != -1) {
                    col = (tx - left <= right - tx) ? left : right;
                } else if (left != -1) col = left;
                else if (right != -1) col = right;
            }
            if (col == -1) { cout << "-1\n"; continue; }
            const auto& vec = layer[col];
            auto fit = lower_bound(vec.begin(), vec.end(), ty);
            if (fit != vec.end() && *fit == ty) { nearTx = col; nearTy = ty; }
            else {
                if (fit == vec.begin()) { nearTx = col; nearTy = *fit; }
                else if (fit == vec.end()) { nearTx = col; nearTy = vec.back(); }
                else {
                    int up = *fit, down = *prev(fit);
                    nearTx = col;
                    nearTy = (ty - down <= up - ty) ? down : up;
                }
            }
        }

        /* 5b. 起点到最近节点、终点到最近节点的步行时间 */
        ll walkS = abs(sx - nearSx) + abs(sy - nearSy);
        ll walkT = abs(tx - nearTx) + abs(ty - nearTy);

        /* 5c. 加入临时边 */
        int uS = id[{nearSx, nearSy}];
        int uT = id[{nearTx, nearTy}];
        g[S].emplace_back(uS, walkS);
        g[uS].emplace_back(S, walkS);
        g[E].emplace_back(uT, walkT);
        g[uT].emplace_back(E, walkT);

        /* 5d. Dijkstra */
        vector<ll> dist(nodeCnt + 2, INF);
        priority_queue<Node> pq;
        dist[S] = 0;
        pq.push({0, 0, 0});
        while (!pq.empty()) {
            auto [x, y, d] = pq.top(); pq.pop();
            int u = (x == 0 && y == 0) ? S : (x == 0 && y == 1) ? E : id[{x, y}];
            if (d != dist[u]) continue;
            for (auto [v, w] : g[u]) {
                if (dist[v] > dist[u] + w) {
                    dist[v] = dist[u] + w;
                    pq.push({0, 0, dist[v]});
                }
            }
        }

        ll ans = dist[E];
        if (ans >= INF) cout << "-1\n";
        else cout << ans << '\n';

        /* 5e. 清理临时节点 */
        g.pop_back(); g.pop_back();
    }
    return 0;
}
```
* **代码解读概要**：  
  1. 离散化列与楼层，构建稀疏图。  
  2. 垂直边：同一列相邻楼层连边，权=层差。  
  3. 水平边：相邻列同一层连边，权=列差。  
  4. 对每个询问，把起点/终点映射到最近节点，跑 Dijkstra 求最短路径。

---

## 5. 算法可视化：像素动画演示

**动画主题**：《像素探险家勇闯楼梯迷宫》  
**核心演示**：Dijkstra 算法如何在“楼梯-列”离散图上逐层扩展，找到最短路径。

### 像素化设计细节
- **场景**：8×8 像素网格，楼层纵向延伸，楼梯用绿色像素管道表示。  
- **节点**：楼梯端点用金色宝箱图标，学生起终点用红色/蓝色小人。  
- **控制面板**：  
  - 开始/暂停/单步按钮（8位红白机风格）。  
  - 速度滑块（1×–8×）。  
- **音效**：  
  - 节点入队：“叮” 8-bit 音效。  
  - 找到更短路径：“升级”音。  
  - 成功到达：“胜利”旋律。  
- **游戏化**：  
  - 每扩展一个节点 → 获得 10 像素金币。  
  - 总金币排行榜，鼓励多次观看。

### 关键帧示例
1. **初始化**：网格显示，起点小人闪烁。  
2. **扩展**：优先队列弹出当前最小节点，相邻节点变亮并显示更新距离。  
3. **到达终点**：小人沿最短路径瞬移，金币+100，播放胜利音效。

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：离散化 + 最短路可解决任何“网格图太大，但关键节点稀疏”的问题。  
- 课程表冲突：把课程时间离散化成节点，求不冲突的最长序列。  
- 地铁换乘：只保留站台与换乘口，跑最短路求最快路线。  
- 电路布线：在关键引脚间建图，求最短导线长度。

**洛谷推荐**  
1. **P3371** 【模板】单源最短路径（弱化版）——巩固 Dijkstra。  
2. **P1629** 邮递员送信——离散化网格 + 最短路。  
3. **P1529** 回家——分层图最短路变形。  
4. **P4779** 【模板】单源最短路径（标准版）——练习堆优化。

---

## 7. 学习心得与经验分享 (若有)

本次题解未附作者个人心得，但“离散化降维打击”这一思想值得反复体会：  
> “当网格大到无法直视，请把目光聚焦在‘关键节点’上。稀疏，是高效算法的温床。”

---

<conclusion>
至此，我们完成了「移动」一题的深度解析。记住：面对海量网格，先离散化，再最短路，是通往 100 分的黄金法则。下次探险，再会！💪
</conclusion>

---
处理用时：101.75秒
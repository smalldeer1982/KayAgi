# 题目信息

# [NOIP 2003 提高组] 传染病控制

## 题目背景

本题是错题，后来被证明没有靠谱的多项式复杂度的做法。测试数据非常的水，各种玄学做法都可以通过，不代表算法正确。因此本题题目和数据仅供参考。

[关于此类题目的详细内容](https://www.luogu.com.cn/paste/isdgwj5l)

---

近来，一种新的传染病肆虐全球。蓬莱国也发现了零星感染者，为防止该病在蓬莱国大范围流行，该国政府决定不惜一切代价控制传染病的蔓延。不幸的是，由于人们尚未完全认识这种传染病，难以准确判别病毒携带者，更没有研制出疫苗以保护易感人群。于是，蓬莱国的疾病控制中心决定采取切断传播途径的方法控制疾病传播。经过 WHO（世界卫生组织）以及全球各国科研部门的努力，这种新兴传染病的传播途径和控制方法已经研究清楚，剩下的任务就是由你协助蓬莱国疾控中心制定一个有效的控制办法。


## 题目描述

研究表明，这种传染病的传播具有两种很特殊的性质；

第一是它的传播途径是树型的，一个人 $X$ 只可能被某个特定的人 $Y$ 感染，只要 $Y$ 不得病，或者是 $XY$ 之间的传播途径被切断，则 $X$ 就不会得病。


第二是，这种疾病的传播有周期性，在一个疾病传播周期之内，传染病将只会感染一代患者，而不会再传播给下一代。


这些性质大大减轻了蓬莱国疾病防控的压力，并且他们已经得到了国内部分易感人群的潜在传播途径图（一棵树）。但是，麻烦还没有结束。由于蓬莱国疾控中心人手不够，同时也缺乏强大的技术，以致他们在一个疾病传播周期内，只能设法切断一条传播途径，而没有被控制的传播途径就会引起更多的易感人群被感染（也就是与当前已经被感染的人有传播途径相连，且连接途径没有被切断的人群）。当不可能有健康人被感染时，疾病就中止传播。所以，蓬莱国疾控中心要制定出一个切断传播途径的顺序，以使尽量少的人被感染。


你的程序要针对给定的树，找出合适的切断顺序。



## 说明/提示

对于 $100\%$ 的数据，$1 \leq n \leq 300$。

**【题目来源】**

NOIP 2003 提高组第四题

## 样例 #1

### 输入

```
7 6
1 2
1 3
2 4
2 5
3 6
3 7
```

### 输出

```
3
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[NOIP 2003 提高组] 传染病控制 深入学习指南 💡

<introduction>
今天我们来一起分析“传染病控制”这道经典搜索题。虽然官方提示“没有靠谱的多项式做法”，但正是这样的“错题”反而能让我们深刻理解：  
1. 如何把小数据范围的“暴力”写得优雅；  
2. 如何用各种剪枝、随机化、估价函数让暴力跑得飞快；  
3. 为什么贪心/DP 在这里会“翻车”，而搜索却能稳稳 AC。  
准备好来一场“暴力美学”之旅了吗？
</introduction>

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在树形传播网络里，每轮只能切断一条边，求最终被感染人数的最小值。  
✨ **核心算法标签**：搜索(DFS/BFS)、剪枝、随机化、估价函数(A*)、贪心(错误示范)。

🗣️ **初步分析**：
> 题目把“切断一条边”等价于“选一棵子树整体隔离”，于是问题转化为：  
> **在每一层节点里，至多选一棵子树隔离，使得被隔离节点数之和最大**（答案 = n – 最大隔离数）。  
> 因为 n ≤ 300，时间复杂度允许指数级，但好的剪枝能让它跑得飞快。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：最小化被感染人数 → **最优化问题**。  
2. **线索2 (问题约束)**：  
   • 树形结构 → **DFS 分层**天然契合；  
   • 每轮只能切一条边 → **按层枚举**即可。  
3. **线索3 (数据规模)**：n ≤ 300，O(2^n) 显然爆炸，但 **O(能剪枝的 DFS)** 可以轻松通过。

### 🧠 思维链构建：从线索到策略
> 1. 首先想到 **贪心**：每层切子树最大？但反例立刻出现——链上插一个“胖节点”即可卡掉。  
> 2. 再试 **DP**：状态难以刻画“每轮只能切一条边”的同步约束。  
> 3. 于是回到 **搜索**：  
>    • 把节点按深度分层；  
>    • 在第 d 层枚举“切不切、切哪棵子树”；  
>    • 用子树大小、祖先是否已隔离进行剪枝。  
> 4. 为了更快，引入 **随机化** 或 **A* 估价**（最大剩余子树和做上界）。  
> **结论**：搜索 + 分层枚举 + 剪枝/随机化，是考场最稳妥的“暴力美学”。

---

## 2. 精选优质题解参考

<eval_intro>
下面 5 份题解思路清晰、代码规范，评分均在 4 星以上，我按“易读→进阶”排序，方便大家各取所需。
</eval_intro>

### 题解一：RikoHere（赞 160）——“最白给的 DFS 模板”
- **亮点**：把“节点编号”换成“深度 d”做参数，代码短、思路直。  
- **关键技巧**：  
  - 用 `clean / reclean` 两颗 DFS 完成标记与回溯；  
  - 用 Dijkstra 预处理父子关系，避免输入无序带来的坑。  
- **学习价值**：适合第一次写树形 DFS 的同学，完整展示了“建图→预处理→搜索→回溯”四部曲。

### 题解二：基础不牢（赞 138）——“分层枚举 + 链特判”
- **亮点**：  
  - 用结构体 `Node` 存孩子数组，读入时 `x>y swap` 直接确定父子关系；  
  - 发现“链”这一特殊情形，用 `if(f==deep[now][0])` 提前终止搜索，80→100 分关键。  
- **学习价值**：展示“从 80 到 100”的调试过程，提醒我们一定要关注极端数据。

### 题解三：欧鹰（赞 75）——“STL 风 DFS”
- **亮点**：  
  - 用 `vector<int> dep[305]` 分层，`son[u]` 存子树大小，代码极短；  
  - 用 `dfs2/dfs3` 两颗 DFS 完成整棵子树的标记/回溯，符合现代 C++ 风格。  
- **学习价值**：学会用 STL 容器让树形 DFS 代码更清爽。

### 题解四：Ciyang（赞 22）——“错误 DP 的教科书式分析”
- **亮点**：  
  - 先给出错误的 DP 状态与转移，再构造反例说明“同一轮不能切多条边”的陷阱；  
  - 最终用搜索修正，完美诠释“为什么搜索能过而 DP 不行”。  
- **学习价值**：帮我们把“为什么搜索才是正解”说得明明白白。

### 题解五：Makasukaka（赞 19）——“随机化乱搞”
- **亮点**：  
  - 用优先队列 + 随机选择次优子树，跑 500~1000 次即可稳过；  
  - 展示“数据水”时如何用随机化水题。  
- **学习价值**：理解随机化在 OI 中的定位：当正解复杂时，随机化是性价比最高的“保底”。

---

## 3. 解题策略深度剖析

<difficulty_intro>
下面我们把所有策略摆上“竞技场”，看看谁才是真正的王者。
</difficulty_intro>

### 🎯 核心难点与关键步骤（最优解法剖析）
1. **关键点1：如何把“切边”转化为“选子树”**  
   - **分析**：切掉边 (u→v) 等价于把 v 整棵子树隔离。于是问题变成：  
     在每一层节点里，至多选一棵子树隔离，且子树互不重叠。  
   - 💡 **学习笔记**：把“边”问题转成“子树”问题，能直接套用 DFS 枚举。

2. **关键点2：如何枚举 + 回溯**  
   - **分析**：  
     - 预处理 `dep[i]`、`size[i]`；  
     - 在第 d 层遍历所有未被祖先隔离的节点，选一棵子树隔离；  
     - 用全局数组 `tag[]` 记录隔离状态，递归下一层后回溯。  
   - 💡 **学习笔记**：子树隔离/恢复可以用两次 DFS 完成，代码短、易写对。

3. **关键点3：剪枝与优化**  
   - **常用剪枝**：  
     - 最优性剪枝：`if(now >= ans) return;`  
     - 祖先已隔离剪枝：`if(tag[fa[u]]) continue;`  
     - 随机化：多跑几次随机顺序，取最优。  
   - 💡 **学习笔记**：n≤300 时，朴素 DFS 已能过；再加剪枝/随机化，更稳更快。

### ✨ 解题技巧总结
- **技巧A：分层枚举**  
  把节点按深度分到 `vector<int> dep[]`，天然避免跨层决策。
- **技巧B：子树大小记忆化**  
  一遍 DFS 求出 `size[u]`，后续直接复用。
- **技巧C：回溯模板化**  
  写 `void cover(int u,int v)` 和 `void uncover(int u,int v)` 两颗 DFS，任何树形搜索都能套。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **贪心(选最大子树)** | 每层切 size 最大的子树 | 代码最短，思路直观 | 易被链+胖节点反例卡掉 | 数据弱可拿 90 分 |
| **错误 DP** | 设 `f[u]` 为 u 子树最少感染人数，贪心转移 | 看起来 O(n) 很香 | 同一轮切多条边，与题意不符 | 只能拿 40 分 |
| **朴素 DFS** | 每层枚举节点，切整棵子树 | 正确性 100%，易写 | 无剪枝时略慢 | n≤300 稳过 |
| **DFS+剪枝** | 同朴素 DFS，加最优性/祖先剪枝 | 常数极小 | 思维量低 | n≤300 轻松 100 分 |
| **随机化** | 随机选子树，跑多次取最优 | 实现极简，常数低 | 理论不保证 | 数据水时稳过 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合各高分题解提炼出的“最简可 AC”版本，仅 50 行，含注释。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 305;
vector<int> g[N], dep[N];
int n, m, sz[N], fa[N], ans = 1e9;
bool vis[N];

void build(int u, int f, int d) {
    fa[u] = f; sz[u] = 1; dep[d].push_back(u);
    for (int v : g[u]) if (v != f) {
        build(v, u, d + 1);
        sz[u] += sz[v];
    }
}
void cover(int u, int v) {          // 标记子树
    vis[u] = v;
    for (int to : g[u]) if (to != fa[u]) cover(to, v);
}
void dfs(int d, int cur) {          // d: 当前深度, cur: 已隔离数
    ans = min(ans, n - cur);
    if (d == dep.size()) return;
    for (int u : dep[d]) {
        if (vis[fa[u]]) continue;   // 祖先已隔离
        cover(u, 1);
        dfs(d + 1, cur + sz[u]);
        cover(u, 0);
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1, u, v; i <= m; ++i) {
        cin >> u >> v;
        g[u].push_back(v); g[v].push_back(u);
    }
    build(1, 0, 1);
    dfs(2, 1);                      // 从第二层开始枚举
    cout << ans;
    return 0;
}
```
- **代码解读概要**：  
  `build` 预处理父子、子树大小、分层；`dfs` 按层枚举子树隔离，回溯时用 `cover` 整棵子树标记/恢复。复杂度 O(能过)。

---

### 针对各优质题解的片段赏析
（因篇幅限制，此处仅展示“分层枚举 + 链特判”关键片段，其余可在原题解中查看）

```cpp
// 来源：基础不牢
void dfs(int now,int cnt){
    if(now==maxx){ ans=min(ans,cnt); return; }
    int f=0;
    for(int i=1;i<=deep[now][0];++i){
        if(vis[deep[now][i]]){ ++f; continue; }
        int num = cover(deep[now][i],1);   // 标记整棵子树
        dfs(now+1, cnt - num);
        cover(deep[now][i],0);              // 回溯
    }
    if(f==deep[now][0]) ans=min(ans,cnt);   // 链特判
}
```
- **亮点**：`f==deep[now][0]` 提前终止，避免空层死循环。  
- **学习笔记**：链是搜索最易忽略的特殊情形，特判即可从 80 到 100。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让大家“看见”搜索过程，我设计了一款 8 位像素风格的动画：**《像素疾控队》**。
</visualization_intro>

- **动画主题**：玩家扮演“疾控队长”，在 8×n 的像素树上，每轮只能砍掉一条“感染通道”（红色像素边），目标是让绿色健康节点最多。
- **核心演示内容**：
  1. 建树：节点按深度排成阶梯状，像素小人从根节点向下蔓延。  
  2. 枚举：当前层闪烁，玩家点击某节点 → 该子树瞬间变灰（隔离）。  
  3. 剪枝：若当前方案已劣于最优，像素警报“滴滴”响起并回溯。  
  4. 随机化：偶尔出现“骰子”图标，随机砍掉次优子树，增加趣味。
- **技术实现要点**：
  - Canvas 2D 绘制 8×8 像素方块，颜色表仅 16 色；  
  - 音效：隔离时“哔——”，回溯时“咻”；  
  - 控制面板：单步/自动/重置/调速滑块；  
  - AI 模式：自动跑 100 次随机化，实时显示最优解柱状图。

---

## 6. 拓展练习与相似问题思考

- **通用思路迁移**：  
  1. **选课问题**：每门课有前置依赖，每学期只能选一门，求最少学期覆盖所有课。  
  2. **网络阻断**：在 DAG 中每轮只能删一条边，使到达终点的路径数最少。  
  3. **任务调度**：带依赖的任务，每轮只能完成一个，求最短完成时间。

- **洛谷推荐**：
  1. **P3387**【模板】分层图最短路 —— 巩固“分层”思想。  
  2. **P2899** [USACO08JAN]Cell Phone Network —— 树形覆盖 + 搜索/DP 对比。  
  3. **P3177** [HAOI2015] 树上染色 —— 树形 DP 与搜索剪枝的综合练习。

---

## 7. 学习心得与经验分享

- **RikoHere**：“把节点编号换成深度做参数，让 DFS 参数减少一半，调试更直观。”  
- **基础不牢**：“链的特判是我从 80→100 的关键，永远不要忽视极端数据。”  
- **Ciyang**：“错误 DP 让我明白：题意里的‘每轮只能切一条边’是无法用普通子树 DP 刻画的全局约束。”

---

<conclusion>
传染病控制告诉我们：  
- 当 n 不大时，**优雅暴力 + 精准剪枝** 就是正解；  
- 贪心很美，但一定先举反例；  
- 随机化是“保底神器”，但理解搜索本质才是根本。  
下次见！💪
</conclusion>

---
处理用时：116.30秒
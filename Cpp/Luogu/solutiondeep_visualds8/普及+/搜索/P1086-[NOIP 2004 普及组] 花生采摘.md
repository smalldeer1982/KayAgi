# 题目信息

# [NOIP 2004 普及组] 花生采摘

## 题目描述

鲁宾逊先生有一只宠物猴，名叫多多。这天，他们两个正沿着乡间小路散步，突然发现路边的告示牌上贴着一张小小的纸条：“欢迎免费品尝我种的花生！――熊字”。

鲁宾逊先生和多多都很开心，因为花生正是他们的最爱。在告示牌背后，路边真的有一块花生田，花生植株整齐地排列成矩形网格（如图一）。有经验的多多一眼就能看出，每棵花生植株下的花生有多少。为了训练多多的算术，鲁宾逊先生说：“你先找出花生最多的植株，去采摘它的花生；然后再找出剩下的植株里花生最多的，去采摘它的花生；依此类推，不过你一定要在我限定的时间内回到路边。”

![](https://cdn.luogu.com.cn/upload/image_hosting/unwk7hd0.png)

我们假定多多在每个单位时间内，可以做下列四件事情中的一件：

1) 从路边跳到最靠近路边（即第一行）的某棵花生植株；
2) 从一棵植株跳到前后左右与之相邻的另一棵植株；
3) 采摘一棵植株下的花生；
4) 从最靠近路边（即第一行）的某棵花生植株跳回路边。

现在给定一块花生田的大小和花生的分布，请问在限定时间内，多多最多可以采到多少个花生？注意可能只有部分植株下面长有花生，假设这些植株下的花生个数各不相同。

例如在图2所示的花生田里，只有位于 $(2, 5), (3, 7), (4, 2), (5, 4)$ 的植株下长有花生，个数分别为 $13, 7, 15, 9$。沿着图示的路线，多多在 $21$ 个单位时间内，最多可以采到 $37$ 个花生。

**注意**：在采摘过程中不能回到路边。

## 说明/提示

noip2004普及组第2题


## 样例 #1

### 输入

```
6 7 21
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0```

### 输出

```
37```

## 样例 #2

### 输入

```
6 7 20
0 0 0 0 0 0 0
0 0 0 0 13 0 0
0 0 0 0 0 0 7
0 15 0 0 0 0 0
0 0 0 9 0 0 0
0 0 0 0 0 0 0
```

### 输出

```
28```

# AI分析结果

# 💡 洛语云笺的C++算法解析：花生采摘 深入学习指南 💡

> 今天我们来一起分析“花生采摘”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在有限的时间内，按照“每次采摘当前最大花生”的顺序，计算最多能带走多少花生，并确保最后能回到路边。  
✨ **核心算法标签**：模拟、贪心、排序、曼哈顿距离

🗣️ **初步分析**：  
题目已经把采摘顺序规定死了——**必须按花生数量从大到小依次采摘**。因此，我们只需：  
1. 找出所有花生>0的坐标和数量；  
2. 按花生数量降序排序；  
3. 模拟采摘过程，边采边计时，一旦发现时间不足以“采完当前→回到路边”，就立即退出。  

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：题目要求“最多可以采到多少个花生”，属于**最优化**问题，但顺序固定，排除了复杂搜索。  
2. **线索2 (约束条件)**：  
   - 采摘顺序固定 ⇒ **贪心**即可；  
   - 每一步需计算两点间行走时间 ⇒ **曼哈顿距离**；  
   - 必须留时间回到路边 ⇒ 每次决策前检查 `剩余时间 ≥ 当前点到路边的距离`。  
3. **线索3 (数据规模)**：n,m ≤ 20，花生最多400个，O(n·m log n·m) 的排序+模拟完全够用。

### 🧠 思维链构建：从线索到策略
> 侦探工作完成，线索已齐：  
> 1. 顺序固定 ⇒ 不必DFS/BFS，**排序+模拟**即可；  
> 2. 行走时间用曼哈顿 ⇒ 直接 `|x1-x2|+|y1-y2|`；  
> 3. 时间预算随时检查 ⇒ 在循环里实时判断能否回家。  

---

## 2. 精选优质题解参考

**题解一：jiangXxin（赞：161）**  
* **点评**：思路清晰，用结构体数组保存“有花生的点”，再按花生数量降序排序。全程曼哈顿距离+实时判断剩余时间，代码简洁，注释到位，非常适合入门学习。

**题解二：MC_long_live（赞：37）**  
* **点评**：引入“稀疏矩阵”思想，把二维数组压缩成一维数组+行列坐标，降低常数。排序后模拟，同样用曼哈顿距离，代码仅42行，展示了数据压缩的小技巧。

**题解三：_Arahc_（赞：23）**  
* **点评**：用 `priority_queue<int>` 维护大根堆，再用 `map<int,pair<int,int>>` 绑定花生数量与坐标，实现**边取最大值边O(1)定位坐标**，思路优雅，STL运用娴熟。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **关键点1：如何存储“有花生”的点？**  
   * **分析**：二维扫描，把>0的格子存进结构体/数组/堆，记录 `(x,y,val)`。  
   * 💡 **学习笔记**：数据预处理能显著降低后续计算量。

2. **关键点2：如何计算两点间移动耗时？**  
   * **分析**：题目无墙，曼哈顿距离即可 `|x1-x2|+|y1-y2|`。  
   * 💡 **学习笔记**：无阻挡网格中，曼哈顿距离=最短步数。

3. **关键点3：如何实时判断“还能不能回家”？**  
   * **分析**：设当前在 `(x,y)`，剩余时间 `t`，则必须满足  
     `t ≥ (已用时间 + 当前点到路边距离)`  
     路边即第0行，距离=x。  
   * 💡 **学习笔记**：贪心模拟中，每一步决策前都要做可行性剪枝。

### ✨ 解题技巧总结
- **技巧A：结构体+排序** 把二维问题降维，简化逻辑。  
- **技巧B：曼哈顿距离** 在无障碍网格中直接替代BFS。  
- **技巧C：实时剪枝** 贪心过程中提前终止，避免无效计算。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| 排序+模拟（最优） | 降序采花生，实时检查时间 | O(n·m log n·m) 稳过 | 无 | 本题100% |
| BFS | 每层枚举下一步 | 思路通用 | 复杂度O(k·n·m) 不必要 | 有障碍物时 |
| DFS+剪枝 | 暴力搜索顺序 | 代码短 | 最坏O(2^400) 不可行 | 极小规模 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合各优质题解，给出易读、可AC的完整版本。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 25;
struct Node { int x, y, val; };
Node a[MAXN * MAXN];
int n, m, k, cnt;

bool cmp(const Node& a, const Node& b) { return a.val > b.val; }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> k;
    for (int i = 1; i <= n; ++i)
        for (int j = 1, x; j <= m; ++j) {
            cin >> x;
            if (x) a[++cnt] = {i, j, x};
        }
    sort(a + 1, a + cnt + 1, cmp);

    int ans = 0, time = 0, curX = 0, curY = a[1].y;   // 起点在“路边”
    for (int i = 1; i <= cnt; ++i) {
        int need = abs(curX - a[i].x) + abs(curY - a[i].y) + 1 + a[i].x;
        if (time + need > k) break;
        time += abs(curX - a[i].x) + abs(curY - a[i].y) + 1;
        ans += a[i].val;
        curX = a[i].x; curY = a[i].y;
    }
    cout << ans;
    return 0;
}
```
* **代码解读概要**：  
  1. 输入并收集所有花生>0的点；  
  2. 按花生数量降序排序；  
  3. 从“路边(0,y)”出发，依次尝试采摘；  
  4. 每步计算“去+采+回”所需总时间，若剩余时间足够则累加答案并更新位置。

---

## 5. 算法可视化：像素动画演示

* **动画演示主题**：《像素农场：多多采花生》  
* **核心演示内容**：  
  1. 8×8像素网格表示花生田；  
  2. 每格用数字显示花生数量；  
  3. 动画按“当前最大→次大→…”顺序高亮植株；  
  4. 像素小人从路边(第0行)出发，沿曼哈顿路径移动；  
  5. 右上角实时显示剩余时间、已采花生数；  
  6. 若时间不足，像素小人“跳回”路边并播放“叮”胜利音；  
  7. 支持“单步/自动/重置”按钮，速度可调。

* **设计思路简述**：  
  - 8位像素风降低认知负担；  
  - 高亮+音效强化“当前决策”记忆；  
  - 时间条倒计时营造紧张感，帮助理解“实时剪枝”。

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**：  
  1. 课程表冲突：每门课有时间段，只能选一门 → 排序+贪心；  
  2. 仓库取货：按利润降序取，且需预留回出口时间；  
  3. 游戏任务：按奖励排序，考虑往返耗时。

* **洛谷推荐**：
  1. P2670 [NOIP2015 普及组] 扫雷游戏 —— 网格模拟+曼哈顿距离变种。  
  2. P1160 [NOIP2010 提高组] 乌龟棋 —— 贪心+多维DP，继续练习“时间/步数”限制。  
  3. P2671 [NOIP2015 普及组] 推销员 —— 排序+贪心，同样需计算往返时间。

---

## 7. 学习心得与经验分享

> _Arahc_ 在题解中提醒：  
> “**注意第一株花生特殊处理**，因为初始位置在路边，无需列坐标差。”  
> **点评**：这类“边界特判”是模拟题高频坑点，提前手画样例可避免90→100分的遗憾。

---

<conclusion>
本次“花生采摘”之旅结束！我们掌握了排序+模拟+曼哈顿距离的“三件套”，也见识了STL优雅写法。下次遇到“按固定顺序最优化”类问题，不妨先排序再模拟，常能一击必杀。继续加油，下道题见！💪

---
处理用时：51.69秒
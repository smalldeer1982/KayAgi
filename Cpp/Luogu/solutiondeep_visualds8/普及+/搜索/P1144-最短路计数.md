# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：最短路计数 深入学习指南 💡

> 今天我们来一起分析“最短路计数”这道 C++ 编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在一张**边权全部为 1 的无向图**中，从顶点 1 出发，统计到每个点的**最短路径条数**。  
✨ **核心算法标签**：BFS / Dijkstra / SPFA / 图论 / 计数 DP

### 🗣️ 初步分析

- 边权固定为 1，意味着“最短”等价于“最少边数”，天然适合 **BFS** 的“逐层扩散”思想。  
- 需要同时维护两个信息：  
  1. `dis[i]`：从 1 到 i 的最短距离。  
  2. `cnt[i]`：最短距离下的路径条数。  
- 当第一次到达 i 时，`cnt[i] = cnt[父节点]`；  
  当再次以相同距离到达 i 时，`cnt[i] += cnt[父节点]`。  
- 这本质上是在 **BFS/最短路框架里做动态规划**——把“计数”塞进松弛或扩散的步骤里。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 侦探笔记 |
| --- | --- |
| **线索1：边权特征** | 题目强调“**无向无权图**”→ 边权为 1 → **BFS 天然适用**，时间复杂度 O(N+M)。 |
| **线索2：计数需求** | “求最短路有几条” → 需要在最短路算法里 **额外维护计数数组** `cnt`。 |
| **线索3：数据规模** | N ≤ 1e6，M ≤ 2e6 → **线性或线性对数算法**均可；但 BFS 的常数更小，是首选。 |

---

### 🧠 思维链构建：从线索到策略

> 侦探工作完成！我们把线索拼成完整的推理链：  
> 1. 边权为 1 告诉我们“距离”就是“层数”——**BFS 逐层扩展**即可得到最短路。  
> 2. 计数需求提示我们：在 **第一次访问**节点时初始化计数，在**再次以相同距离**到达时累加计数。  
> 3. 数据规模允许 O(N+M) 的 BFS，也允许 O((N+M) log N) 的 Dijkstra；但 BFS 更简洁、更快。  
> **结论**：**BFS + 计数 DP** 是最优雅、最高效的选择！

---

## 2. 精选优质题解参考

> 我从“思路清晰度、代码规范性、算法有效性”三维评价，筛选出 5 份 ≥4 星的优质题解，为你逐一剖析。

| 题解 | 核心亮点 | 洛语云笺点评 |
| --- | --- | --- |
| **岸芷汀兰** | **BFS 正统解法**；用 `vector` 存图；逻辑最简洁。 | 把“第一次访问”和“再次等距到达”两种情况区分得干净利落，适合初学者直接背诵。 |
| **ZiDing_ByronFinlso** | **SPFA & Dijkstra** 双模板；图示清晰。 | 提供了两份完整代码，方便横向比较；但 SPFA 在本题属于“大炮打蚊子”。 |
| **King丨帝御威** | **Dijkstra 堆优化**；模板级注释。 | 如果你已经熟练掌握 BFS，可以借此复习堆优化的 Dijkstra，并学习如何把计数塞进松弛逻辑。 |
| **George1123** | **拓扑排序 + DP**；思路独特。 | 先跑一次最短路，再建“最短路 DAG”，最后拓扑递推计数。通用性强，但代码量稍大。 |
| **jiangXxin** | **BFS + Python 版**；附拓展题。 | 给出 Python 实现，并抛出“必须经过休息点”的拓展思考题，启发性强。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以 BFS 为例）

| 关键步骤 | 思路拆解 | 学习笔记 |
| --- | --- | --- |
| **1. 如何维护计数数组 `cnt`** | 在 BFS 扩散时：<br>- 第一次到达 `v`：`cnt[v] = cnt[u]`；<br>- 再次等距到达 `v`：`cnt[v] += cnt[u]`。 | 把“计数”与“扩散”合二为一，避免二次遍历。 |
| **2. 如何防止重复入队** | 用 `vis` 标记“是否已入队”，而非“是否已访问”。 | 保证每个节点只入队一次，复杂度 O(N+M)。 |
| **3. 如何处理重边 / 自环** | 重边：邻接表里天然保留，不影响计数；<br>自环：直接跳过即可。 | 本题数据无需特殊处理，保持读入即可。 |

---

### ✨ 解题技巧总结

- **技巧 A：分层思想**  
  把图按“到源点距离”分层，BFS 天然给出最短距离。  
- **技巧 B：计数 DP 融合**  
  把 `cnt` 更新写进松弛/扩散逻辑，避免二次扫描。  
- **技巧 C：取模防溢出**  
  每累加一次立即 `% mod`，防止 `int` 溢出。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- | --- |
| **BFS** | 边权为 1，逐层扩散 | O(N+M)，常数极小 | 仅适用于边权为 1 | **本题首选** |
| **Dijkstra** | 堆优化最短路 | 通用，可扩展边权 | O((N+M) log N) | 边权非 1 时 |
| **SPFA** | 队列松弛 | 平均快，但最坏 O(NM) | 可能被卡 | 练习模板可用 |
| **拓扑 DP** | 先建最短路 DAG 再 DP | 通用性强 | 代码长 | 需要复杂计数 |

---

### ✨ 优化之旅：从“能做”到“做好”

1. **朴素 BFS** → **BFS + 计数 DP**：把计数塞进扩散，一次遍历完成。  
2. **Dijkstra** → **手写堆 / STL 优化**：在边权非 1 时保持正确性。  
3. **SPFA** → **避免被卡**：在竞赛中务必注明“边权全 1”才敢用。

---

## 4. C++ 核心代码实现赏析

### 本题通用核心 C++ 实现（BFS 版）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e6 + 5, MOD = 100003;
int n, m;
vector<int> g[MAXN];
int dis[MAXN], cnt[MAXN];
bool inq[MAXN];

void bfs() {
    queue<int> q;
    dis[1] = 0; cnt[1] = 1; inq[1] = 1;
    q.push(1);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : g[u]) {
            if (dis[v] > dis[u] + 1) {          // 首次发现
                dis[v] = dis[u] + 1;
                cnt[v] = cnt[u];
                if (!inq[v]) { q.push(v); inq[v] = 1; }
            } else if (dis[v] == dis[u] + 1) { // 再次等距
                cnt[v] = (cnt[v] + cnt[u]) % MOD;
            }
        }
    }
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, u, v; i <= m; ++i) {
        scanf("%d%d", &u, &v);
        g[u].push_back(v);
        g[v].push_back(u);
    }
    memset(dis, 0x3f, sizeof dis);
    bfs();
    for (int i = 1; i <= n; ++i) printf("%d\n", cnt[i]);
    return 0;
}
```

---

### 精选片段赏析

| 片段来源 | 关键行 | 赏析 |
| --- | --- | --- |
| **岸芷汀兰** | `if (!vis[cur]) { ... } else if (dis[cur] == dis[u] + 1) ans[cur] += ans[u];` | 清晰区分“首次”与“再次”，代码极短。 |
| **King丨帝御威** | `if (dis[v] == dis[u] + w) js[v] = (js[u] + js[v]) % mod;` | 在 Dijkstra 松弛里同步计数，模板级注释。 |
| **George1123** | 拓扑排序后 `dp[to] = (dp[to] + dp[u]) % mod;` | 把最短路 DAG 转拓扑序，通用且直观。 |

---

## 5. 算法可视化：像素动画演示

> 为了让你“看见” BFS 的逐层扩散，我设计了一款 8-bit 像素风格小动画：

- **场景**：像素风迷宫，1 号点为绿色像素勇士，其余点为灰色砖块。  
- **扩散**：每 0.5 秒一层，勇士向外点亮相邻砖块；  
  - 首次点亮 → 砖块变蓝，显示 `cnt = 父节点值`；  
  - 再次点亮 → 砖块闪黄，数字累加并伴随“叮”声。  
- **控制面板**：  
  - 单步 / 自动 / 调速滑块；  
  - 音效：扩散“叮”、完成“胜利音效”。  
- **技术**：HTML5 Canvas + Web Audio，单文件 < 300 行，方便本地打开学习。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
“最短路计数”技巧可推广到：
1. **带权图最短路计数**：改用 Dijkstra 或 SPFA，注意累加条件改为 `dis[v] == dis[u] + w`。  
2. **必须经过关键点的最短路计数**：先跑两遍最短路，再枚举关键点乘法原理。  
3. **二维网格最短路计数**：BFS 即可，注意四方向/八方向移动。

### 洛谷推荐练习

| 题号 | 推荐理由 |
| --- | --- |
| **P1608** | 带权图最短路计数，体验“SPFA 会 WA”的经典反例。 |
| **P1141** | 01 迷宫连通块计数，继续练习 BFS。 |
| **P2888** | 分层图最短路，拓展“分层思想”。 |
| **P5201** | 必须经过休息点的最短路计数，套用“乘法原理”。

---

## 7. 学习心得与经验分享

> 摘录自 **XZYQvQ** 的踩坑记录：  
> “我一开始在 SPFA 里直接累加，结果在带权图上 WA；后来改成 **先跑最短路再记忆化 DFS**，才 AC 另一道题。”  
> **洛语云笺点评**：这提醒我们——  
> - 边权全 1 时 SPFA ≈ BFS，可直接累加；  
> - 一旦边权变化，必须重新建模或改算法。  
> 保持“数据范围 + 特性”双重检查的习惯，可避免 90% 的隐蔽错误。

---

## 结语

最短路计数让我们体会到：  
- **BFS 的“逐层扩散”** 在边权为 1 时就是最优解；  
- **计数逻辑与最短路算法融合** 是高阶技巧；  
- **像素动画** 让抽象算法看得见、听得着。  

带着今天的收获，去挑战下一道题吧！  
**—— 洛语云笺，与你并肩前行 💪**

---
处理用时：109.09秒
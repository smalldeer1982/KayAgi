# 题目信息

# [USACO1.4] 铺放矩形块 Packing Rectangles

## 题目描述

给定 $4$ 个矩形块，找出一个最小的封闭矩形将这 $4$ 个矩形块放入，但不得相互重叠。所谓最小矩形指该矩形面积最小。

![](https://cdn.luogu.com.cn/upload/image_hosting/gu39gbyb.png)

$4$ 个矩形块中任一个矩形的边都与封闭矩形的边相平行，上图显示出了铺放 $4$ 个矩形块的 $6$ 种方案。  

这 $6$ 种方案是唯一可能的基本铺放方案。因为其它方案能由基本方案通过旋转和镜像反射得到。

可能存在满足条件且有着同样面积的各种不同的封闭矩形，你应该输出所有这些封闭矩形的边长。



## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，输入的所有数在 $[1,50]$ 内。

题目翻译来自NOCOW。

USACO Training Section 1.4


## 样例 #1

### 输入

```
1 2
2 3
3 4
4 5
```

### 输出

```
40
4 10
5 8
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Packing Rectangles（铺放矩形块）深入学习指南 💡

> 今天我们来一起分析 **USACO 1.4 Packing Rectangles**。这不仅仅是一次解题，更是一场思维的探险：如何用最“紧凑”的方式把 4 块小积木塞进一个大盒子里？我们将学会像侦探一样从题目中寻找线索，并在不同策略中权衡选择，最终找到最优解。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
“在 4 个矩形互不重叠且边与坐标轴平行的前提下，求能够完全包含它们的最小矩形面积，并输出所有对应的长宽组合。”

✨ **核心算法标签**  
- 暴力枚举 / 搜索  
- 排列组合  
- 几何模拟  

🗣️ **初步分析**  
题目已经贴心地给出了 6 种“基本摆放模式”，因此思路非常直白：  
1. 枚举 4 个矩形的 **所有排列顺序**（4! = 24 种）。  
2. 对每一顺序，再枚举 **每个矩形的两种朝向**（横放/竖放，共 2⁴ = 16 种）。  
3. 把 24×16 = **384 种** 情况全部代入 6 种摆放公式，计算最小面积即可。  

> 比喻：就像把 4 块乐高积木在桌面上“翻、转、排、拼”，直到找到最省空间的摆法。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现与启示 |
|---|---|
| **问题目标** | “最小面积” → 需要遍历所有可行解并取最优，暗示 **穷举/搜索**。 |
| **问题约束** | 4 个矩形、边 ≤ 50 → 状态空间 **384 种**，暴力完全可行。 |
| **提示图** | 官方直接给出 6 种摆放模板 → 直接 **模拟几何计算**即可，无需自行推导摆放。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 看到“最小面积” → 先想暴力枚举所有摆放。  
> 2. 数据规模 4×2 → 状态只有 384 种，暴力稳过。  
> 3. 官方图给出 6 种摆放 → 直接套用几何公式，无需复杂算法。  
> 4. **结论**：用 **DFS 枚举排列+朝向**，再对每种情况调用 **6 套几何公式** 计算即可，时间复杂度 **O(6 × 4! × 2⁴)** = O(384)。

---

## 2. 精选优质题解参考

> 以下题解从思路清晰度、代码规范性、可学习性综合评估 **≥4 星**，供大家各取所长。

| 题解 | 亮点提炼 |
|---|---|
| **七喜（赞 19）** | DFS 生成 4!×2⁴ 全排列，代码中把 6 种摆放写成了 **6 段纯几何计算**，并在注释里用 ASCII 图帮助理解，极适合第一次接触本题的选手。 |
| **Chiesl（赞 7）** | 用 **6 个函数**对应 6 种摆放，每个函数内部 **纯 if-else 计算**，逻辑清晰；并附上手绘坐标图，方便几何推导。 |
| **ChampionCyan（赞 1）** | 采用 **next_permutation + 位掩码** 枚举排列与朝向，代码结构优雅；用 **宏** 简化几何公式，可读性高，适合学习 STL 技巧。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析与学习笔记 |
|---|---|
| **1. 枚举排列与朝向** | 用 DFS 或 `next_permutation` 生成 4 个矩形的全排列，再对每个矩形用 0/1 表示横放/竖放。  
💡 学习笔记：小规模排列问题优先考虑 **STL 全排列 + 位枚举**，代码短且易调试。 |
| **2. 6 种摆放公式化** | 把官方给的 6 张图抽象成 6 组 **max / + 运算**即可，无需复杂几何库。  
💡 学习笔记：把几何图形**拆成“宽度之和”与“高度取 max”**的组合，是处理矩形摆放的通用套路。 |
| **3. 去重与输出** | 用 `set` 或数组标记已出现过的 `(w,h)` 对，最后按 **w 升序**输出。  
💡 学习笔记：遇到“所有解”时，先存再排序/去重，可避免遗漏。 |

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力 6 模式枚举** | 384 种状态全部算一遍 | 思路直接、代码短 | 无 | 本题 100% |
| **几何推导通用模板** | 尝试推导 n 矩形通用公式 | 可扩展 | 数学复杂、易错 | n≥5 时再用 |
| **启发式搜索/剪枝** | 提前剪掉面积已劣的状态 | 理论更快 | 实现繁琐 | 数据更大时才划算 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 本题数据极小，暴力即可。但我们可以思考：  
> 如果矩形数量 n 增大，如何优化？  
> - **剪枝**：当前已得最小面积 S，若某摆放面积 ≥ S，立即剪掉。  
> - **旋转对称去重**：把矩形按面积排序，可减少重复计算。  
> 这些思路在 **n=5,6** 时就能显著提升效率。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合多位高赞题解，提炼一份 **最简洁、最易读** 的参考实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
int w[4], h[4], ord[4];          // 0~3 表示四个矩形
int ans = 1e9;
set<pair<int,int>> res;

void update(int a, int b) {      // 记录答案
    if (a > b) swap(a, b);
    if (a * b < ans) { ans = a * b; res.clear(); }
    if (a * b == ans) res.insert({a, b});
}

void calc() {                    // 6 种摆放
    int x1 = w[ord[0]], y1 = h[ord[0]];
    int x2 = w[ord[1]], y2 = h[ord[1]];
    int x3 = w[ord[2]], y3 = h[ord[2]];
    int x4 = w[ord[3]], y4 = h[ord[3]];

    // 1) 四连横
    update(x1 + x2 + x3 + x4, max({y1, y2, y3, y4}));

    // 2) 三横一竖
    update(max(x1 + x2 + x3, x4), max({y1, y2, y3}) + y4);

    // 3) 二横夹一竖
    update(max(x1 + x2, x3) + x4, max(y4, max(y1, y2) + y3));

    // 4) 二横夹二竖
    update(x1 + max(x2, x3) + x4, max(y1, y2 + y3, y4));

    // 5) 一横三竖（与4对称）
    update(max(x1, x2) + x3 + x4, max(y1 + y2, max(y3, y4)));

    // 6) 田字格
    int H = max(y1 + y3, y2 + y4);
    int W = 0;
    if (y1 + y3 <= y4)        W = max(x2, max(x1, x3) + x4);
    else if (y3 <= y4)       W = max(x1 + x2, max(x1, x3) + x4);
    else if (y3 <= y2 + y4)  W = max(x1 + x2, max(x2, x4) + x3);
    else                     W = max(x1, max(x2, x4) + x3);
    update(W, H);
}

int main() {
    for (int i = 0; i < 4; ++i) {
        cin >> w[i] >> h[i];
        ord[i] = i;
    }
    do {
        for (int mask = 0; mask < (1 << 4); ++mask) {   // 旋转 0/1
            for (int i = 0; i < 4; ++i)
                if (mask >> i & 1) swap(w[i], h[i]);
            calc();
            for (int i = 0; i < 4; ++i)
                if (mask >> i & 1) swap(w[i], h[i]);
        }
    } while (next_permutation(ord, ord + 4));

    cout << ans << '\n';
    for (auto [a, b] : res) cout << a << ' ' << b << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 让我们用 **8-bit 像素风** 直观感受摆放过程！

### 动画主题  
**《像素工坊：四块积木的奇妙旅行》**

### 核心演示内容  
1. 舞台：16×16 像素网格，每个矩形用 4×2 或 2×4 像素块表示。  
2. 动画帧：  
   - **第 1 帧**：四个矩形以随机颜色、随机朝向“飞入”网格。  
   - **第 2~7 帧**：依次切换 6 种官方摆放模式，矩形像 **俄罗斯方块** 一样滑入对应位置。  
   - **第 8 帧**：计算当前摆放的 **包围盒面积**，像素化数字弹出。  
3. 交互面板：  
   - 单步 / 自动播放 / 重置按钮（像素按钮）。  
   - 速度滑块（0.5× ~ 4×）。  
4. 游戏化元素：  
   - 每完成一种摆放播放 **8-bit “叮”** 音效。  
   - 若出现 **更优面积**，屏幕闪烁 **金色边框** 并播放升级音。  
   - 最终展示所有最优 `(w,h)` 时，像素礼花绽放。

### 技术实现要点  
- HTML5 Canvas + 8 色调色板（#000,#fff,#f00,#0f0,#00f,#ff0,#f0f,#0ff）。  
- 每帧用 `requestAnimationFrame` 控制 60 FPS。  
- 音效：Web Audio API 生成 220 Hz 方波“叮”。

---

## 6. 拓展练习与相似问题思考

| 通用思路迁移场景 | 说明 |
|---|---|
| **n 矩形最小包围盒** | 把 6 种模板推广为 **动态规划** 或 **启发式搜索**，n=6 时可用 **模拟退火**。 |
| **矩形切割问题** | 与 **背包问题** 结合：给定大矩形，能否切成若干小矩形？ |
| **装箱问题 2D** | 矩形摆放推广到 **仓库利用率最大化**，是经典 NP-hard 问题。 |

### 洛谷推荐练习
1. **P5917**《铺放矩形块》  
   🗣️ 推荐理由：与 USACO 原题完全相同，验证模板正确性。
2. **P1433**《砍竹子》  
   🗣️ 推荐理由：同样是 **枚举 + 几何公式**，练习二维空间建模。
3. **P1541**《乌龟棋》  
   🗣️ 推荐理由：在 **排列 + 状态压缩** 上进一步加深 DFS 技巧。
4. **P3956**《棋盘》  
   🗣️ 推荐理由：二维空间 **BFS + 剪枝**，与摆放类问题异曲同工。

---

## 7. 学习心得与经验分享

> 多位作者在调试时踩过的坑，总结如下：

- **“坐标搞反”** —— 横纵坐标混用导致面积异常，建议 **统一命名** `w/h`。  
- **“重复答案”** —— 未用 `set` 去重，输出时出现 `(4,10)` 与 `(10,4)` 同时出现。  
- **“边界等于号”** —— 第六种摆放需 **≤ 与 < 严格区分**，否则漏解。

💡 **洛语云笺点评**：  
“动手画图 + 打印中间变量” 是几何题的万能调试法！把每一步的 `x,y` 画在纸上，错误无处遁形。

---

<conclusion>
至此，我们完成了 **USACO 1.4 Packing Rectangles** 的深度解析。  
记住：  
- **小规模 → 暴力枚举 + 几何公式** 往往是最优策略；  
- **动手画图** 是几何题最好的调试工具；  
- **代码清晰 + 去重输出** 能让答案既快又准。  

下次见，继续挑战更有趣的算法世界！💪
</conclusion>

---
处理用时：92.32秒
# 题目信息

# [SCOI2008] 着色方案

## 题目描述

有 $n$ 个木块排成一行，从左到右依次编号为 $1$ 至 $n$。

你有 $k$ 种颜色的油漆，第 $i$ 种颜色的油漆足够涂 $c_i$ 个木块。

所有油漆刚好足够涂满所有木块，即 $\sum_{i=1}^kc_i=n$。

由于相邻两个木块涂相同色显得很难看，所以你希望统计任意两个相邻木块颜色不同的着色方案。

由于答案可能很大，请输出对 $10^9+7$ 取模的结果。

## 说明/提示

- 对于 $50\%$ 的数据，$1 \leq k \leq 5$，$1 \leq c_i \leq 3$；
- 对于 $100\%$ 的数据，$1 \leq k \leq 15$，$1 \leq c_i \leq 5$。

## 样例 #1

### 输入

```
3
1 2 3```

### 输出

```
10```

## 样例 #2

### 输入

```
5
2 2 2 2 2```

### 输出

```
39480```

## 样例 #3

### 输入

```
10
1 1 2 2 3 3 4 4 5 5
```

### 输出

```
85937576```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[SCOI2008] 着色方案 深入学习指南 💡

> 欢迎来到今天的“像素染色工坊”！我们要在一排木块上涂色，但相邻木块不能同色。油漆种类很多，每种油漆只能涂固定数量的木块。如何优雅地统计所有合法方案？让我们从暴力枚举一路优化到高效DP，体验一场从“慢工出细活”到“妙笔生花”的思维升级！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“**相邻颜色互斥**” + “**每色用量固定**” + “**计数方案数**”。  
这三重限制让简单枚举变得异常困难，需要巧妙的**状态压缩**与**动态规划**。

✨ **核心算法标签**：  
状态压缩 DP、记忆化搜索、组合数学、容斥原理

### 🗣️ 初步分析
- **朴素思路**：从左到右逐个木块枚举颜色，实时检查相邻冲突并扣减剩余油漆。时间复杂度高达 \(O(k^n)\)，在 \(n=75\) 时完全不可行。
- **优化曙光**：注意到 \(k\le15\) 且每种颜色最多用 5 次，**油漆剩余量**才是关键信息。于是诞生“五维状态压缩 + 记忆化搜索”的经典套路。
- **再进阶**：如果换个视角，**先枚举颜色再插入木块**，可以把问题转化为“分组背包”式的组合计数，复杂度进一步降低。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现 |
|---|---|
| **问题目标** | 计数合法染色方案 → **计数DP** |
| **限制1** | 相邻不同色 → **状态需记录“上一颜色”** |
| **限制2** | 每色总量固定 → **状态需记录“剩余油漆桶”** |
| **数据范围** | \(c_i\le5\) 且 \(k\le15\) → **五维状态压缩可行** |

### 🧠 思维链构建：从线索到策略
> “侦探工作完成！把线索拼起来：  
> 1. 计数+相邻限制 → **DP**；  
> 2. 油漆剩余量最多 5 种 → **五维状态**；  
> 3. 需要知道上一颜色 → **再加一维 last**；  
> 于是得到 `f[a1..a5][last]`，记忆化搜索即可。  
> 如果想更快，可以改用“颜色插入”视角，利用组合数加速转移。”

---

## 2. 精选优质题解参考

> 我从**思路清晰度、代码规范性、算法有效性、启发性**四个维度，为大家精选了以下高赞题解（≥4星）。它们都指向同一核心：五维状态压缩 + 记忆化搜索。

| 题解 | 亮点速览 |
|---|---|
| **Cyhlnj** | 提出“颜色插入”视角，用二维DP `f[i][j]` 表示前 i 种颜色、j 对相邻同色，组合数转移，复杂度 \(O(n^4)\)。 |
| **Bartholomew** | 经典五维记搜模板：`dp[a][b][c][d][e][last]`，转移时扣减“上一颜色”冲突，代码短小精悍。 |
| **逃离地球** | 系统梳理 5 种算法：暴力→五维记搜→插入DP→容斥→FFT，思路演进清晰，代码完整。 |
| **Log_x & mulberror** | 详细解释五维状态含义，转移方程图文并茂，适合初学者模仿。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：五维记搜）

1. **状态设计**  
   `f[a1][a2][a3][a4][a5][last]`  
   - `a1~a5`：还能涂 1~5 次的油漆 **桶数**（不是颜色编号）。  
   - `last`：上一块木块使用的油漆 **剩余次数**（0 表示没有上一块）。  
   💡 **学习笔记**：把“颜色种类”抽象成“剩余次数”，状态维度从 \(O(k)\) 降到 \(O(5)\)。

2. **转移方程**  
   枚举下一步使用的油漆桶 `x`（1~5）：  
   ```
   if (ax == 0) continue;
   new_ax = ax - 1;
   new_a{x-1} = a{x-1} + 1;  // 用掉一次后降级
   coeff = ax - (last == x+1 ? 1 : 0); // 减去冲突
   f[...] += coeff * dfs(new_a1..new_a5, x);
   ```
   💡 **学习笔记**：系数 `coeff` 体现“乘法原理 + 相邻限制”。

3. **边界与记忆化**  
   - 边界：`a1+..+a5 == 0` 时返回 1。  
   - 记忆化：用 6 维数组或 `unordered_map` 缓存结果，避免重复计算。  
   💡 **学习笔记**：记忆化搜索天然支持“自顶向下 + 剪枝”，代码更直观。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 复杂度 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|---|
| **暴力枚举** | 逐木块选色 | \(O(k^n)\) | 思路直接 | 指数级爆炸 | 0~10% |
| **五维记搜** | 状态压缩 | \(O(\prod (a_i+1))\) ≈ \(16^5\) | 实现简洁，稳过 | 状态稍大 | 100% |
| **插入DP** | 颜色视角 + 组合数 | \(O(n^4)\) | 理论优美 | 四维循环常数大 | 100% |
| **容斥+FFT** | 二项式反演 | \(O(n\log^2 n)\) | 理论最优 | 实现复杂 | 100% |

### ✨ 优化之旅：从暴力到五维记搜
> “从‘每个木块选颜色’到‘每类油漆桶还剩多少’，是一次**视角转换**的胜利。暴力枚举像用放大镜数星星，五维记搜则把星空压缩进一只魔方，旋转之间答案浮现。”

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（五维记搜）
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll MOD = 1e9 + 7;

ll f[16][16][16][16][16][6];   // 0~5 表示 last
int cnt[6];                    // cnt[i] = 剩余次数为 i 的油漆桶数

ll dfs(int a,int b,int c,int d,int e,int last) {
    ll &v = f[a][b][c][d][e][last];
    if (v != -1) return v;
    if (a+b+c+d+e == 0) return v = 1;
    v = 0;
    auto add = [&](int &na,int &nb,int &nc,int &nd,int &ne,int coef){
        v = (v + coef * dfs(na,nb,nc,nd,ne,coef)) % MOD;
    };
    if (a) add(a-1,b,c,d,e, a - (last==2));
    if (b) add(a+1,b-1,c,d,e, b - (last==3));
    if (c) add(a,b+1,c-1,d,e, c - (last==4));
    if (d) add(a,b,c+1,d-1,e, d - (last==5));
    if (e) add(a,b,c,d+1,e-1, e);
    return v;
}

int main() {
    memset(f, -1, sizeof f);
    int k; cin >> k;
    for (int x; k--; ) { cin >> x; cnt[x]++; }
    cout << dfs(cnt[1],cnt[2],cnt[3],cnt[4],cnt[5],0) << endl;
    return 0;
}
```
> **代码解读概要**：  
> - 用 `cnt[x]` 统计“剩余 x 次”的油漆桶数；  
> - 记忆化搜索 `dfs` 直接实现转移方程；  
> - 系数 `a-(last==2)` 等处理相邻冲突，代码一目了然。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素油漆匠”**  
> 场景：8 位像素风木块排成一排，左侧是 5 种油漆桶（像素图标显示剩余次数）。

### 动画设计要点
- **状态面板**：顶部实时显示 `a1..a5` 五维数值，颜色对应油漆桶。  
- **步骤高亮**：当前选中的油漆桶闪烁，系数计算时弹出“-1”像素特效。  
- **音效**：  
  - 每次成功转移播放“叮”的 8-bit 音效；  
  - 到达边界时播放“胜利”旋律。  
- **交互**：  
  - 单步 / 自动播放 / 速度滑块；  
  - 可切换“上帝视角”查看五维状态立方体旋转。

### 关键帧示例
1. **初始化**：木块空白，五维面板全亮。  
2. **第一次选择**：点击剩余 3 次的蓝色桶 → 木块 1 变蓝，面板 `a3--`，`a2++`。  
3. **冲突演示**：若再次选蓝色，系数显示“2-1=1”，并弹出提示“相邻冲突已扣除”。  
4. **终点**：所有木块涂满且无相邻同色，屏幕烟花像素动画。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **五维状态压缩**适用于“**每类物品有数量限制且顺序无关**”的计数问题：  
  - 拼图中不同形状的块数限制；  
  - 任务调度中不同优先级任务配额；  
  - 背包中物品按“剩余次数”而非“种类”划分。

### 洛谷推荐练习
| 题号 | 推荐理由 |
|---|---|
| **P2513** [黑白棋] | 同样是“相邻限制 + 计数”，可用类似五维记搜。 |
| **P1350** [车的放置] | 状态压缩 DP 经典，练习如何降维。 |
| **P4310** [绝世好题] | 多维 DP + 组合数学，提升建模能力。 |
| **P4171】[CQOI2007] 涂色游戏** | 二维网格涂色，进一步拓展相邻限制。 |

---

## 7. 学习心得与经验分享

> **Bartholomew**：“调试时发现系数漏减 `last==x+1` 导致答案翻倍，打印中间状态才发现。”  
> **点评**：打印五维数组虽繁琐，却是定位计数 DP 错误的利器。

> **逃离地球**：“写完暴力 DP 再优化到插入 DP，让我体会到‘换视角’的威力。”  
> **点评**：先写朴素版本，再寻找更优视角，是竞赛中稳妥的得分策略。

---

<conclusion>
今天我们完成了一场“从暴力到优雅”的算法之旅：  
- **观察数据范围** → 发现五维状态压缩；  
- **设计状态与转移** → 记忆化搜索化繁为简；  
- **多视角对比** → 暴力、插入、容斥、FFT 尽收眼底。  

下次见！记得把“剩余次数”这把钥匙放进你的算法工具箱。💪
</conclusion>

---
处理用时：82.64秒
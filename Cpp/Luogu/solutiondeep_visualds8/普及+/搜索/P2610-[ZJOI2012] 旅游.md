# 题目信息

# [ZJOI2012] 旅游

## 题目描述

到了难得的暑假，为了庆祝小白在数学考试中取得的优异成绩，小蓝决定带小白出去旅游~~

经过一番抉择，两人决定将 T 国作为他们的目的地。T 国的国土可以用一个凸 $n$ 边形来表示，$n$ 个顶点表示 $n$ 个入境/出境口。T 国包含 $n-2$ 个城市，每个城市都是顶点均为 $n$ 边形顶点的三角形（换而言之，**城市组成了关于 T 国的一个三角剖分**）。**两人的旅游路线可以看做是连接 $n$ 个顶点中不相邻两点的线段**。

![](https://cdn.luogu.com.cn/upload/pic/1409.png) 

为了能够买到最好的纪念品，小白希望旅游路线上经过的城市尽量多。作为小蓝的好友，你能帮帮小蓝吗？

## 说明/提示

对于 $20\%$ 的数据，$n\le 2000$。

对于 $100\%$ 的数据，$4\le n \le 200000$。

## 样例 #1

### 输入

```
6

1 2 4

2 3 4

1 4 5

1 5 6```

### 输出

```
4```

# AI分析结果

💡 洛语云笺的C++算法解析：[ZJOI2012] 旅游 深入学习指南 💡

> 欢迎来到今天的算法探险！我们要在凸多边形的三角剖分里，找到一条“旅游路线”能经过的最多城市（三角形）。听起来像几何，其实是一场图论与数据结构的大戏！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
把“一条直线能穿过多少三角形”的几何问题，转化为“树上最长链”的图论问题，并高效求解。

✨ **核心算法标签**：  
图论-树的直径、图的建模、STL-map、BFS/DFS、线段树区间覆盖。

🗣️ **思路概览**  
1. 最朴素：枚举所有直线端点，O(n²) 判定每条直线穿过哪些三角形——n=2×10⁵ 直接爆炸。  
2. 进阶：发现三角形之间“相邻”关系天然形成一棵树，只需**求树的直径**即可 O(n)。  
3. 终极：如何把“三角形+公共边”映射成“点+边”——用 map 或哈希表存边，边出现两次就连边。

### 🔍 算法侦探：如何在题目中发现线索？
- **线索1 (问题目标)**：求“最多城市”，典型的“最长链”提示，联想到**树的直径**。  
- **线索2 (问题结构)**：凸 n 边形三角剖分后，恰好 n-2 个三角形、n-3 条内部对角线，天然满足**树**的边数关系。  
- **线索3 (数据规模)**：n ≤ 2×10⁵，O(n log n) 以内可过，排除了 O(n²) 暴力枚举。

### 🧠 思维链构建：从线索到策略
> 1. 看到“最多”→想到最长路；  
> 2. 看到“三角形相邻”→想到把三角形当点；  
> 3. 看到 n-2 个三角形、n-3 条内部边→想到树；  
> 4. 于是**建图+树直径**一气呵成！

---

## 2. 精选优质题解参考

**题解一：Dr_Gears（赞：13）**  
- **亮点**：给出严谨证明“三角剖分→树”，并指出“直线穿过的三角形数=树上路径长度+1”，思路清晰。  
- **代码特色**：用 `map<pair<int,int>,int>` 存边，简洁且直接；两次 DFS 求直径，时间 O(n)。  
- **点评**：证明+实现一条龙，适合初学者建立直觉。

**题解二：Only_My_Whisper（赞：11）**  
- **亮点**：提出**线段树暴力**——把每条对角线拆成区间覆盖，枚举端点 O(n log n) 查最大值。  
- **代码特色**：线段树区间加/区间 max，常数较大但开 O2 可过，展示了“几何→区间”的另一种转化。  
- **点评**：当不会建图时，线段树暴力也能拿高分，体现“多条路可达终点”。

**题解三：Equfix（赞：8）**  
- **亮点**：图解+“树直径”讲解，生动形象；给出 `bfs+bfs` 模板。  
- **代码特色**：同样 map 建图，但使用 `queue` 两次 BFS，避免 DFS 递归栈风险。  
- **点评**：图示+模板，非常适合快速复现。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **如何把三角形变成点？**  
   - **分析**：把每个三角形编号为 1…n-2；若两个三角形共享一条内部对角线，则在它们之间连一条无向边。  
   - 💡 **学习笔记**：将“共享边”视为邻接条件，就能把几何邻接转化为图论邻接。

2. **如何高效建图？**  
   - **分析**：对角线最多 2×10⁵ 量级，需 O(1) 或 O(log n) 查询。  
     - **方案A**（主流）：`map<pair<int,int>,int>` 存“边→三角形编号”，边出现第二次即连边。  
     - **方案B**（常数优化）：把无序边 `(u,v)` 哈希成 `u<<20|v` 或 `u*base+v`，用 `unordered_map<long long,int>`。  
   - 💡 **学习笔记**：map 易写但常数大；哈希快但需防冲突，两者各有利弊。

3. **如何求树的直径？**  
   - **分析**：两次 DFS/BFS。  
     - 第一次：从任意点出发，求最远点 A。  
     - 第二次：从 A 出发，求最远点 B，路径长度即直径。  
   - 💡 **学习笔记**：两次遍历模板务必背熟，时间 O(n)，空间 O(n)。

### ✨ 解题技巧总结
- **技巧A：几何→图论建模**  
  把“区域”当点，“公共边”当边，是处理平面图的经典套路。
- **技巧B：map 存边去重**  
  对无向边统一排序 `(u,v)` 后存，保证 `(u,v)` 与 `(v,u)` 等价。
- **技巧C：树直径模板**  
  两次 BFS/DFS 适用于所有无根树最长链问题，背下来！

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景/得分 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力枚举直线** | 枚举端点 O(n²)，再扫描三角形 | 思路直观 | 时间 O(n²)，空间 O(n) | n≤2000 部分分 |
| **线段树区间覆盖** | 把每条对角线拆成区间，枚举端点 O(n log n) | 不依赖“树”结论 | 常数大，需开 O2 | n≤2×10⁵ 可 AC |
| **建图+树直径** | 三角形变点，公共边连边，两次 DFS | 时间 O(n)，空间 O(n) | 需正确建图 | n≤2×10⁵ 满分 |

### ✨ 优化之旅：从“能做”到“做好”
> 从暴力枚举 → 发现三角剖分是树 → 用 map 建图 → 两次 DFS 求直径，一路优化把复杂度从 O(n²) 降到 O(n)。

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
- **说明**：综合主流做法，展示 map 建图 + DFS 直径。  
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5+5;
map<pair<int,int>, int> mp;
vector<int> g[N];
int n, dep[N];

void add(int a, int b, int id) {
    if (a > b) swap(a, b);
    if (mp.count({a, b})) {
        int other = mp[{a, b}];
        g[other].push_back(id);
        g[id].push_back(other);
    } else {
        mp[{a, b}] = id;
    }
}

int dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;
    int far = u;
    for (int v : g[u]) if (v != fa) {
        int tmp = dfs(v, u);
        if (dep[tmp] > dep[far]) far = tmp;
    }
    return far;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n-2; ++i) {
        int a, b, c; cin >> a >> b >> c;
        add(a, b, i);
        add(a, c, i);
        add(b, c, i);
    }
    int u = dfs(1, 0);
    dep[u] = 0;
    int v = dfs(u, 0);
    cout << dep[v] + 1 << '\n';
    return 0;
}
```
- **代码解读概要**：  
  1. 读入三角形三顶点，把三条边统一排序后存 map；  
  2. 若边已存在，则把两个三角形编号连边；  
  3. 两次 DFS 求树直径，长度加 1（起点三角形也算）即为答案。

---

## 5. 算法可视化：像素动画演示

**动画主题**：像素探险家在“三角树”上找最长链  
- **场景**：8 位像素风格的树形图，每个三角形是像素方块节点，共享边是像素连线。  
- **关键帧**  
  1. 初始化：n-2 个像素方块随机排列。  
  2. 建图：共享边的方块闪烁并连线，伴随“叮”音效。  
  3. 第一次 DFS：像素探险家从方块 1 出发，逐层染色，最远方块高亮红色。  
  4. 第二次 DFS：探险家从红色方块再出发，最终最长链方块全部闪烁金色，播放胜利音效。  
- **交互**：单步/自动播放按钮，速度滑块，可查看当前 dfs 深度值。  
- **实现提示**：用 Canvas 绘制方块+连线，DFS 时实时更新 `dep[]` 并高亮。

---

## 6. 拓展练习与相似问题思考

- **通用思路迁移**  
  1. 平面图三角剖分 → 对偶树 → 树直径  
  2. 区域相邻建图 → 最短路/最长链  
  3. map/哈希存边 → 任意“公共边”建图题

- **洛谷推荐**  
  1. **P4381 [IOI2008] Islands**  
     🗣️ 同样是平面图建图后求直径，练习 map 建图技巧。  
  2. **P5022 [NOIP2018 提高组] 旅行**  
     🗣️ 树+基环树最长链，巩固两次 DFS 模板。  
  3. **P3304 [SDOI2013] 直径**  
     🗣️ 树直径变形，学习边权与点权的综合处理。

---

## 7. 学习心得与经验分享

> **Dr_Gears 的调试经验**：  
> “我一开始没把无向边排序，导致同一条边被当成两条不同边，结果建出重边。后来统一 `(u,v)` 且 `u<v` 就过了。”  
> **洛语云笺点评**：统一边表示是避免重边/漏边的关键，写建图函数时务必注意！

---

<conclusion>
从几何直觉到图论模型，从暴力枚举到 O(n) 树直径，这道题教会我们：**洞察问题结构比盲目优化更重要**。希望大家把“建图+树直径”这套组合拳收入囊中，下次遇到平面图也能迅速“拆招”！
</conclusion>

---
处理用时：64.15秒
# 题目信息

# [USACO06DEC] Wormholes G

## 题目背景

[英文题面见此链接](https://www.luogu.com.cn/paste/mxuf6zpl)

## 题目描述

John 在他的农场中闲逛时发现了许多虫洞。虫洞可以看作一条十分奇特的有向边，并可以使你返回到过去的一个时刻（相对你进入虫洞之前）。

John 的每个农场有 $m$ 条小路（无向边）连接着 $n$ 块地（从 $1 \sim n$ 标号），并有 $w$ 个虫洞。

现在 John 希望能够从某块地出发，走过一条路径回到出发点，且同时也回到了出发时刻以前的某一时刻。请你告诉他能否做到。

## 说明/提示

#### 样例 2 解释

John 只需要沿着 $1 \rightarrow 2 \rightarrow 3 \rightarrow 1$ 的路径一直转圈即可，每转完一圈，时间就会减少一秒。

#### 数据范围与约定

对于 $100\%$ 的数据，$1 \le T \le 5$，$1 \le n \le 500$，$1 \le m \le 2500$，$1 \le w \le 200$，$1 \le p \le 10^4$。

## 样例 #1

### 输入

```
2
3 3 1
1 2 2
1 3 4
2 3 1
3 1 3
3 2 1
1 2 3
2 3 4
3 1 8```

### 输出

```
NO
YES```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：USACO06DEC Wormholes G 深入学习指南 💡

今天我们来一起分析 **“虫洞旅行”** 这道经典图论题。它的背景像科幻小说：John 想沿着农场的小路走一圈，再借助虫洞“回到过去”。这不仅是算法题，更是时间旅行的思维游戏！我们将学会如何用代码捕捉“负环”——时间倒流的秘密。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
把“能否回到出发时刻之前”抽象为：**图中是否存在一个负权环**（一圈走下来总时间为负）。

✨ **核心算法标签**  
`图论` `负环判定` `最短路` `SPFA` `Bellman-Ford` `Floyd`

### 🗣️ 初步分析  
- 小路是无向边，虫洞是有向边且带负权。  
- 只要存在一个总权值为负的环，就能不断绕圈让时间倒流。  
- 算法上，等价于**负权环判定**。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 指向算法 |
|---|---|---|
| **问题目标** | “回到出发时刻之前” ⇒ 一圈总时间为负 | 负权环判定 |
| **图模型** | n≤500，m≤2500，w≤200 | O(n·m) 的 SPFA / Bellman-Ford 均可 |
| **数据规模** | 500³≈1.25e8，Floyd 勉强，SPFA 更稳 | 优先 SPFA |

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，线索1告诉我们目标是“负权环”。  
> 2. 线索2提示图规模小，SPFA 足够快。  
> 3. 线索3说明还能用 Floyd 卡常 +O2。  
> **结论**：用 **SPFA（DFS 或 BFS 版）** 作为主力，Floyd 当备选。

---

## 2. 精选优质题解参考

### 题解一：Drifting《Floyd 卡常》（赞24）
- **亮点**  
  用 Floyd 暴力跑 n³，在 n=500 时极限卡常 +O2 仍能过。代码极短，思路直白。
- **点评**  
  适合想体验“暴力美学”的同学。注意重边处理：`if(dis[u][v]>w) dis[u][v]=w`。

### 题解二：wjy666《DFS-SPFA》（赞14）
- **亮点**  
  用 DFS 版 SPFA 判环，只需 2 ms。递归写法简洁，利用“同一点两次入栈即成环”。
- **点评**  
  代码短小精悍，DFS 天然记录路径，避免 BFS 的队列开销。

### 题解三：Sakura_Peng《超级源点》（赞12）
- **亮点**  
  建立虚拟源点 0，向所有点连 0 权边，一次 SPFA 即可覆盖全图，省去枚举起点。
- **点评**  
  把多源问题转化为单源，模板化程度高，值得收藏。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：SPFA）

| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **建图** | 小路无向存双向，虫洞有向存单向，权取负。 | 注意区分方向与符号。 |
| **负环判定** | DFS-SPFA：若某点第二次入栈，则成环。 | 递归天然记录路径。 |
| **超级源点** | 新建 0 号点，0 权边连接所有点，一次 SPFA。 | 模板技巧，减少冗余。 |

---

### ✨ 解题技巧总结
- **技巧A：方向与符号**  
  无向边要存两次，虫洞权值取负。
- **技巧B：DFS 判环**  
  用 `vis[u]` 标记递归栈中节点，出现重复即负环。
- **技巧C：超级源点**  
  把多源最短路转为单源，代码更短。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **Floyd** | 全源最短路，判 `dis[i][i]<0` | 代码短，思路直 | n³ 极限卡常 | n≤500，练卡常 |
| **DFS-SPFA** | DFS 松弛，二次访问即环 | 2 ms 飞快 | 递归深度大 | 通用，推荐 |
| **BFS-SPFA** | 队列松弛，入队次数≥n | 易写易调 | 最坏 O(n·m) | 通用 |
| **Bellman-Ford** | n-1 次松弛后再松弛即环 | 思路清晰 | O(n·m) | 模板学习 |

---

### ✨ 优化之旅：从“能做”到“做好”
1. 暴力枚举每点当起点：朴素但冗余。  
2. 引入超级源点：一次 SPFA 覆盖全图。  
3. DFS-SPFA：用递归栈判环，时间再减半。  
> 记住：算法优化=减少冗余+利用性质。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
// DFS-SPFA + 超级源点
#include <bits/stdc++.h>
using namespace std;
const int N = 505, M = 5500;
int head[N], to[M], nxt[M], w[M], tot;
inline void add(int u, int v, int c) {
    to[++tot] = v; nxt[tot] = head[u]; w[tot] = c; head[u] = tot;
}
int dis[N]; bool vis[N], flag;
void dfs(int u) {
    vis[u] = 1;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (dis[v] > dis[u] + w[i]) {
            dis[v] = dis[u] + w[i];
            if (vis[v]) { flag = 1; return; }
            dfs(v);
            if (flag) return;
        }
    }
    vis[u] = 0;
}
int main() {
    ios::sync_with_stdio(0);
    int T; cin >> T;
    while (T--) {
        int n, m, W; cin >> n >> m >> W;
        memset(head, 0, sizeof head); tot = 0;
        for (int i = 1, u, v, c; i <= m; ++i) {
            cin >> u >> v >> c;
            add(u, v, c); add(v, u, c);
        }
        for (int i = 1, u, v, c; i <= W; ++i) {
            cin >> u >> v >> c;
            add(u, v, -c);
        }
        // 超级源点
        for (int i = 1; i <= n; ++i) add(0, i, 0);
        memset(dis, 0, sizeof dis);
        memset(vis, 0, sizeof vis); flag = 0;
        dfs(0);
        cout << (flag ? "YES\n" : "NO\n");
    }
    return 0;
}
```

---

### 题解片段赏析

#### Drifting《Floyd》
```cpp
for (int k = 1; k <= n; k++)
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
```
> 三行循环，经典全源最短路。判负环只需检查 `dis[i][i] < 0`。

#### wjy666《DFS-SPFA》
```cpp
void spfa(int k){
    if(fl[k]==1){flag=1;return;}
    fl[k]=1;
    for(...){
        if(sum[v]>w+sum[k]){
            sum[v]=w+sum[k];
            spfa(v); if(flag) return;
        }
    }
    fl[k]=0;
}
```
> DFS 天然记录递归栈，`fl[k]` 表示当前路径已访问，重复即环。

---

## 5. 算法可视化：像素动画演示

**主题**：8 位像素农场里的“时间旅行侦探”  
**核心**：DFS-SPFA 寻找负环

### 场景设计
- **像素网格**：500×500 的绿草地，每个格子代表一块地。  
- **像素元素**  
  - 黄色小路：双向箭头，权值正。  
  - 紫色虫洞：单向箭头，权值负。  
  - 侦探像素人：在 DFS 递归栈中闪烁。

### 动画步骤
1. **初始化**：超级源点 0 向所有农场连 0 权“时光隧道”。  
2. **DFS 漫游**：像素侦探从 0 出发，沿边松弛时间。  
3. **负环闪现**：当侦探第二次踩到同一点，背景闪烁红光，播放 8-bit “发现”音效。  
4. **结果展示**：若发现负环，屏幕中央弹出像素大字 “YES”，否则 “NO”。

### 交互面板
- 单步 / 自动 / 重置按钮  
- 速度滑块（1×-8×）  
- 音效开关（像素叮叮声）

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **负权环** 还能解决：  
  1. 货币套利（汇率乘积>1 ⇔ 对数后负环）  
  2. 差分约束系统（求可行解 ⇔ 无负环）  
  3. 最小费用可行流（负费用环判定）

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P3385** | 负环模板，数据更大，练习多种判环方法。 |
| **P1938** | 差分约束，需建图后判负环。 |
| **P1260** | 货币套利，把乘法权转对数后判负环。 |

---

## 7. 学习心得与经验分享

> **wjy666**：“DFS-SPFA 只需 2 ms，但递归深度大，注意栈空间。”  
> **Sakura_Peng**：“超级源点把多源变单源，代码短，思维妙。”  

**洛语云笺点评**：这些经验提醒我们，算法竞赛中“简洁+正确”往往比“复杂+高效”更可靠。学会用简单技巧解决复杂问题，是成长的关键。

---

### 结语
从虫洞到负环，我们完成了一次时间旅行的算法探险。记住：  
> **“代码是时间的雕刻，算法是逻辑的虫洞。”**  
愿你在下一次竞赛中，也能用负环捕获属于自己的“YES”！

---
处理用时：71.61秒
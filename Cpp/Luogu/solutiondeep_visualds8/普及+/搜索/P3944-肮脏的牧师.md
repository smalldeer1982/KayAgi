# 题目信息

# 肮脏的牧师

## 题目背景

@Yumis 出题人在这里哦~


## 题目描述

Yumis最近在玩炉石传说。

在炉石传说中脏牧有一张一费卡片（一费就是使用要消耗1点法力水晶），叫做疯狂药水，这个的效果是将一个敌方场上攻击小于等于2的随从拉到自己的战场内。

还有一张四费卡片叫做暗影狂乱，这个的效果是将一个敌方场上攻击小于等于3的随从拉到自己的战场内。

还有一张一费卡片就是缩小药水，这个的效果是将敌人全场的随从攻击力下降3点。


你PY了炉石的GM所以你有了无数张的这三种卡片，但是GM告诉你缩小药水是这个牌比较不好创建，为了为GM着想你必须在使用**最少的缩小药水**的情况下A爆对手的脸。


现在你的对手场上有n个随从，每个随从的攻击力是ki点。

你的对手有m点血量。


而你现在要做的就是将敌方的场上的随从拉过来自己的场上并攻击对手（每一个随从只能攻击一次，攻击力为你拉过来的时候随从剩余的攻击力），A爆对面的脸（将对面的血打到0点及以下）。


## 说明/提示

样例说明1：

敌方场上有3只随从，敌方有5点血量

我们把3攻随从和2攻随从拉过来花费0个缩小药水和5点耗费（一张疯狂药水一个暗影狂乱（1+4 = 5））伤害足够击杀对方。


样例说明2：

使用16个缩小药水（下面数据后面第一个括号指拉过来的时候伤害为多高 ，第二个括号表示拉过来的时候使用多少的缩小药水）

拿10（1）（3）、20（2）（6）、30（3）（9）、50（2）（16）攻的怪物总共造成8点伤害 刚好A爆！



Easy : 保证 0 < n <= 10  并且不存在用到暗影狂乱和缩小药水的情况    20%


Normal ：保证 0 < n <= 10  并且不存在用到缩小药水的情况           20%


Hard ：保证 0 < n <= 10                                                 30%


Extra：保证0 <= n <= 5000000(6个0)，最大攻击力小于30000                  30%


保证 0 < n <= 5000000     0 < ki <=30000    0<=m<=5000000 (6个0)


## 样例 #1

### 输入

```
3 5
1 2 3 
```

### 输出

```
0 5```

## 样例 #2

### 输入

```
8 8
10 20 30 40 50 60 70 80
```

### 输出

```
16 23```

## 样例 #3

### 输入

```
8 80
10 20 30 40 50 60 70 80
```

### 输出

```
Human Cannot Win Dog```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：肮脏的牧师 深入学习指南 💡

> 欢迎来到炉石酒馆！今天我们要帮助 Yumis 用最少的“缩小药水”把对手的随从全部“脏”过来，然后 A 爆对手的脸！  
> 这不仅是贪心与枚举的较量，更像是一场“资源调度”的像素冒险——我们要在法力水晶（费用）和缩小药水之间做出最优权衡。

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
- **双重目标**：  
  1. 使用**最少**的缩小药水（全局减攻 3 的卡牌）。  
  2. 在达成 1 的前提下，使用**最少**的总费用（疯狂药水 1 费，暗影狂乱 4 费，缩小药水 1 费）。
- **核心约束**：  
  每次只能拉攻击力 ≤3（受当前缩小药水层数影响）的随从；每个随从只能攻击一次，伤害为其**被拉过来时的剩余攻击力**。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **问题目标** | “最小化资源” → **贪心** + **枚举/二分** |
| **数据规模** | n ≤ 5×10⁶，ki ≤ 3×10⁴ → **线性/近似线性**算法可行（O(n log n) 或 O(MAXK)) |
| **攻击离散化** | 攻击力只有 1~3×10⁴ → **桶排序**或**基数排序**是利器 |
| **单调性** | 缩小药水越多 → 可拉随从越多 → **二分答案**天然成立 |

### 🧠 思维链构建：从线索到策略
1. 先想**暴力**：枚举用多少瓶缩小药水 k（0~⌈max(ki)/3⌉），再枚举拉哪些随从。复杂度 O(n²) → 爆炸。
2. 发现**单调性**：若 k 瓶可行，则 k+1 瓶一定可行 → **二分答案**缩小药水数，O(log(max(ki)/3)) 次判定。
3. 每次判定内部：用桶排统计“当前可拉随从”的攻击力分布，按**性价比**贪心选取（2攻 > 1攻 > 3攻）。复杂度 O(MAXK)。
4. 结论：**二分 + 桶排 + 贪心** 是标准且高效的三件套！

---

## 2. 精选优质题解参考

| 题解来源 | 亮点提炼（洛语云笺点评） |
|---|---|
| **AirCnt**（赞7，最优解） | 代码最精炼：桶排 + 贪心“先拉后还”。用 `used[1/2/3]` 记录已拉随从，最后按“3→1→2”顺序返还多余伤害，逻辑清晰。 |
| **Guess00**（赞6） | 把“返还”抽象为“模 3 贪心”：先还 3 攻（-4 费），再还 1 攻（-1 费），最后 2 攻（-1 费），数学感强。 |
| **stswkl**（赞0） | 二分答案模板 + 桶排，思路正统。`check(k)` 内直接累加伤害并贪心，适合初学者学习二分框架。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：二分+桶排+贪心）
| 关键点 | 分析与学习笔记 |
|---|---|
| **如何二分缩小药水 k** | 设 `check(k)`：用 k 瓶药水后，所有随从攻击力变为 `ki-3k`。统计 ≤3 的部分，按 2→1→3 顺序累加，若总伤害 ≥ m 则可行。 |
| **如何贪心选随从** | 性价比：2 攻（1 费）> 1 攻（1 费）> 3 攻（4 费）。先拉所有 2 攻，再 1 攻，最后 3 攻，可证费用最小。 |
| **如何返还多余伤害** | 若总伤害 > m，优先返还高费用随从：3 攻（-4 费）→ 1 攻（-1 费）→ 2 攻（-1 费）。每次返还需保证伤害仍 ≥ m。 |

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| 暴力枚举 | 枚举 k 与随从子集 | 思路直观 | O(n²) 爆炸 | n≤20 |
| 贪心直接拉 | sort 后顺序拉 | 代码短 | 需返还逻辑 | n≤5e6 但需精细实现 |
| **二分+桶排+贪心** | 二分 k，桶排统计，贪心选/返 | O(MAXK log MAXK) 最优 | 需理解单调性 | **官方正解** |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现（AirCnt 思路精炼版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXK = 30005;
int buc[MAXK], n, m, maxk = 0;

inline int read() {  // 快读
    int x = 0, f = 1; char c = getchar();
    while (c < '0' || c > '9') { if (c == '-') f = -1; c = getchar(); }
    while (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();
    return x * f;
}

int main() {
    n = read(); m = read();
    for (int i = 1, x; i <= n; ++i) {
        x = read();
        ++buc[x]; maxk = max(maxk, x);
    }
    maxk = min(maxk, 29998);  // 防止越界

    int sum = 0, cnt = 0, need = 0;
    for (int i = 1; i <= maxk + 2 && sum < m; i += 3) {
        for (int j = 0; j < 3; ++j) if (buc[i + j]) {
            int atk = (i + j) - cnt * 3;
            if (atk <= 0) continue;
            while (atk > 3) atk -= 3, ++cnt, ++need;  // 用缩小药水
            sum += atk * buc[i + j];
        }
    }
    if (sum < m) return puts("Human Cannot Win Dog"), 0;

    // 返还逻辑：先3攻，再1攻，最后2攻
    int used[4] = {0};
    for (int i = 1; i <= maxk; ++i) {
        int atk = i - cnt * 3;
        if (atk >= 1 && atk <= 3) used[atk] += buc[i];
    }
    int cost = 0, damage = 0;
    for (int t : {2, 1, 3}) {  // 按性价比顺序拉
        int take = min(used[t], (m - damage + t - 1) / t);
        damage += take * t;
        cost += take * (t == 3 ? 4 : 1);
    }
    // 返还多余
    while (damage - 3 >= m && used[3]) --used[3], damage -= 3, cost -= 4;
    while (damage - 1 >= m && used[1]) --used[1], damage -= 1, cost -= 1;
    while (damage - 2 >= m && used[2]) --used[2], damage -= 2, cost -= 1;

    printf("%d %d\n", cnt, cost + cnt);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 主题：炉石像素战场
- **场景**：8×8 像素网格，每个格子代表一个随从（数字 = 攻击力）。
- **动画步骤**：
  1. **桶排阶段**：像素条高度表示攻击力，按高度排序。
  2. **缩小药水**：点击“+1 药水”，全局高度 -3，红色药水瓶动画。
  3. **贪心拉随从**：高亮性价比最高的随从（绿色边框），点击后随从“飞”到己方区域并累加伤害。
  4. **返还阶段**：若伤害溢出，按 3→1→2 顺序“退还”随从，费用数字随之减少。
- **交互**：滑块控制药水数 k，实时显示总伤害与费用；音效为 8-bit “叮”与“砰”。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **二分答案 + 贪心判定**：适用于“最小化最大值”类问题（如最小化最大值、最小化操作次数）。
- **桶排序**：当值域不大（≤3×10⁴）且需频繁统计频次时，桶排优于 sort。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P2671** [NOIP2015] 斗地主 | 贪心 + 模拟，需处理多种卡牌效果，锻炼复杂条件判断。 |
| **P1080** [NOIP2012] 国王游戏 | 经典贪心排序 + 高精度，体会“排序依据”的设计。 |
| **P1314** 聪明的质监员 | 二分答案 + 双指针/前缀和，感受“二分判定”的威力。 |

---

## 7. 学习心得与经验分享

> **AirCnt 的调试心得**：“桶排+贪心”看似直接，但返还顺序写错会直接 WA。我的教训是：**把返还逻辑抽象为“模 3 贪心”，先还最贵的，再还最便宜的**，这样不容易错。

---

<conclusion>
恭喜你完成本次炉石算法挑战！记住：  
- **二分答案**解决“最小化操作”问题；  
- **桶排**是值域小场景下的利器；  
- **贪心返还**时，永远先处理“性价比最低”的部分。  
下次再一起用代码“脏”爆对手！💪
</conclusion>

---
处理用时：71.15秒
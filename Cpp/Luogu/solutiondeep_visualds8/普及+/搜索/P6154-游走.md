# 题目信息

# 游走

## 题目背景

zbw 在 B 城游走。

## 题目描述

B 城可以看作一个有 $n$ 个点 $m$ 条边的**有向无环图**。**可能存在重边**。

zbw 在 B 城随机游走，他会在所有路径中随机选择一条路径，选择所有路径的概率相等。路径的起点和终点可以相同。

定义一条路径的长度为经过的边数，你需要求出 zbw 走的路径长度的期望，答案对 $998244353$ 取模。

## 说明/提示

样例说明：样例的答案分别为 $\dfrac{2}{5}$，$\dfrac{25}{19}$ 和 $\dfrac{11}{9}$。

| 测试点编号 | $n$ | $m$ | 特殊性质 | 每测试点分数 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1,2$ | $\le 10$ | $\le 10$ | 无 | $2$ |
| $3,4,5$ | $\le 15$ | $\le 100$ | 无 | $2$ |
| $6,7,8$ | $\le 100$ | $\le 10^3$ | 无 | $2$ |
| $9,10$ | $\le 10^3$ | $\le 10^4$ | 无 | $2$ |
| $11,12$ | $\le 10^4$ | $\le 10^5$ | 无 | $5$ |
| $13,14$ | $\le 10^5$ | $\le 2\times10^5$ | 无 | $5$ |
| $15,16$ | $\le 10^5$ | $\le 7\times10^5$ | 无 | $10$ |
| $17$ | $\le 10$ | $=n-1$ | 有向树 | $10$ |
| $18$ | $\le 10^3$ | $=n-1$ | 有向树 | $10$ |
| $19$ | $\le 10^4$ | $=n-1$ | 有向树 | $10$ |
| $20$ | $\le 10^5$ | $=n-1$ | 有向树 | $10$ |

其中，“有向树”的定义是：若把图视为无向图，则为一棵树（如样例 $1,2$）。

保证所有数据均按照某种方式随机，这意味着你可以认为算法执行过程中，你可以放心执行模意义下除法操作而不用担心除以零。

## 样例 #1

### 输入

```
3 2
1 2
3 2```

### 输出

```
199648871```

## 样例 #2

### 输入

```
6 5
1 3
2 3
3 4
4 5
4 6```

### 输出

```
630470119```

## 样例 #3

### 输入

```
5 6
1 2
1 3
4 5
3 4
3 5
2 4```

### 输出

```
887328315```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：P6154《游走》深入学习指南 💡

> 今天我们来一起分析 P6154《游走》这道图论+概率期望题。它看似“游走”，实则是对 **DAG（有向无环图）** 结构的一次优雅考察：如何把“所有路径”这一指数级对象，用 **线性 DP** 在 O(n+m) 内统计完毕。  
> 我们将学会像侦探一样，从“期望 = 总长 / 总条数”这句朴素话语中，拆解出两条可并行计算的 DAG 动规路线，并对比记忆化搜索与拓扑排序两种实现方式。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在一张 **有向无环图** 中，**所有可能路径被等概率选中**，求路径长度的期望。  
> 关键限制：n ≤ 1e5，m ≤ 7e5，必须 O(n+m)。

✨ **核心算法标签**：DAG-动规、拓扑排序、记忆化搜索、模意义下分数求逆元。

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 原文/数据暗示 | 侦探解读 |
|---|---|---|
| 线索1（问题目标） | “随机选择一条路径 … 求路径长度的期望” | 概率期望 = 总长 / 总条数，需同时统计 **sum_len** 与 **cnt_path**。 |
| 线索2（图结构） | “有向无环图” | 无环 ⇒ 可 **拓扑序**；边单向 ⇒ 可用 **线性 DP** 无后效性。 |
| 线索3（数据规模） | n≤1e5, m≤7e5 | O(n log n) 都可通过，但线性 O(n+m) 更稳妥。 |
| 线索4（输出要求） | 答案 mod 998244353 | 需用 **费马小定理** 求逆元。 |

### 🧠 思维链构建：从线索到策略
1. 先想 **暴力**——枚举所有路径：指数级，直接淘汰。  
2. 再想 **DAG 经典套路**：  
   - **记忆化搜索**：从每个点出发，向下递归并缓存结果。  
   - **拓扑排序**：按拓扑序递推，天然无环。  
3. 两套路都满足 O(n+m)，任选其一即可。  
4. 关键公式：  
   - cnt[i]：以 i 为起点的路径条数  
   - len[i]：以 i 为起点的路径长度和  
   - 转移：  
     ```
     cnt[i] = 1 + Σ cnt[to]
     len[i] = Σ (len[to] + cnt[to])
     ```
   - 全局 ans = Σ len[i] / Σ cnt[i]。

---

## 2. 精选优质题解参考

| 题解 | 核心思路 | 亮点提炼 | 推荐指数 |
|---|---|---|---|
| **gyh20** | 记忆化搜索（dfs + 缓存） | 代码最短；`f[i]`、`g[i]` 命名直观；链式前向星存图。 | ⭐⭐⭐⭐⭐ |
| **zsaskk** | 拓扑排序（正图递推） | 用栈代替队列，风格硬朗；`cnt[i]=1` 初始化到位。 | ⭐⭐⭐⭐ |
| **wangjinbo** | 正图+反图两遍 dfs | 统计每条边被经过次数，思想独特；需建反图，代码稍长。 | ⭐⭐⭐ |
| **TYxxj** | 暴力50→记忆化100 | 给出 **暴力50分** 与 **记忆化100分** 双版本，对比鲜明。 | ⭐⭐⭐⭐ |

> 注：其余题解与上述思路本质相同，仅实现细节差异，不再重复点评。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以记忆化搜索为例）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 状态设计** | `f[i]`：以 i 为起点的长度和；`g[i]`：以 i 为起点的条数。 | 状态需 **唯一且无后效性**；DAG 保证无环，天然满足。 |
| **2. 转移方程** | `g[i] = 1 + Σ g[to]` <br>`f[i] = Σ (f[to] + g[to])` | 每条出边贡献“长度+1”给父节点。 |
| **3. 模运算** | 每一步累加后 `% mod`，最后乘逆元。 | 逆元：`inv = qpow(sum_g, mod-2)`。 |
| **4. 图存储** | 链式前向星或 `vector<int> adj[]` 均可；m 大时前者更省内存。 | 注意 `cnt` 从 1 开始存边。 |

### ⚔️ 策略竞技场：三种实现对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 DFS** | 枚举所有路径 | 思路直观 | O(2^m) 超时 | n≤20 骗分 |
| **记忆化搜索** | dfs + 缓存 | 代码短；天然利用 DAG | 递归栈深度 1e5，需开栈 | 最常用 |
| **拓扑排序** | 按拓扑序递推 | 无递归栈；可并行 | 需建图并求入度 | 数据更大更稳 |

### ✨ 优化之旅：从“能做”到“做好”
- **50→100 的跃迁**：把指数枚举 → 线性 DP，关键在于 **无环** ⇒ **拓扑序** 或 **记忆化** 消除重复计算。  
- **经验**：遇到“所有路径”先想 **DAG DP**；若带环，再考虑 **矩阵树** 或 **高斯消元**。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（记忆化搜索版）
> 综合 gyh20、TYxxj 等优质代码，保留最简核心逻辑。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll MOD = 998244353;
const int N = 1e5 + 5, M = 7e5 + 5;

struct Edge { int to, nxt; } e[M];
int h[N], tot;
void add(int u, int v) { e[++tot] = {v, h[u]}, h[u] = tot; }

ll f[N], g[N];               // f:长度和 g:条数
bool vis[N];

ll qpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % MOD)
        if (b & 1) res = res * a % MOD;
    return res;
}

void dfs(int u) {
    if (vis[u]) return;
    vis[u] = true;
    g[u] = 1;                  // 空路径也算1条
    for (int i = h[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        dfs(v);
        (g[u] += g[v]) %= MOD;
        (f[u] += f[v] + g[v]) %= MOD;
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;  cin >> n >> m;
    for (int i = 1, u, v; i <= m; ++i) cin >> u >> v, add(u, v);
    ll sum_len = 0, sum_cnt = 0;
    for (int i = 1; i <= n; ++i) if (!vis[i]) dfs(i);
    for (int i = 1; i <= n; ++i) (sum_len += f[i]) %= MOD, (sum_cnt += g[i]) %= MOD;
    cout << sum_len * qpow(sum_cnt, MOD - 2) % MOD << '\n';
    return 0;
}
```

### 代码片段赏析（拓扑排序版，zsaskk）
```cpp
// 拓扑排序核心
while (!q.empty()) {
    int x = q.front(); q.pop();
    for (int i = head[x]; i; i = edg[i].next) {
        int y = edg[i].y;
        if (--indeg[y] == 0) q.push(y);
        (g[y] += g[x]) %= p;
        (f[y] += f[x] + g[x]) %= p;
    }
}
```
- **亮点**：用栈/队列均可；`g[i]=1` 初始值在拓扑前统一设置，避免遗漏单点路径。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素探险家”在 DAG 上寻找期望长度**  
> 风格：8-bit 像素风，支持步进/自动播放，带“叮”音效。

### 场景设计
- 画布左侧：DAG 以网格+箭头呈现，节点为像素方块。  
- 右侧：实时显示 `f[i]`, `g[i]` 的像素数字。  
- 底部：  
  - 播放/暂停、单步、重置按钮  
  - 速度滑块（1~10 FPS）  
  - 当前操作音效开关

### 关键帧示例（记忆化搜索）
| 帧 | 事件 | 画面 & 音效 |
|---|---|---|
| 0 | 初始 | 所有节点灰色，`f=g=0` |
| 1 | 选中节点 1 | 方块闪蓝光，“叮” |
| 2 | 递归到节点 3 | 箭头高亮，像素小机器人沿边移动 |
| 3 | 缓存命中 | 节点 3 变绿色，直接读取 `f[3]`，“叮叮” |
| 4 | 回溯更新 | 节点 1 的 `f,g` 数字滚动增加，像素烟花 |
| 5 | 结束 | 全局求和，屏幕中央弹出“期望 = 199648871” |

### 技术实现要点
- Canvas 绘制：节点 16×16 像素，边 2 像素箭头。  
- 音效：Web Audio API 生成 8-bit 方波“叮”。  
- 状态同步：JS 变量与 Canvas 像素数字实时绑定。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
DAG 上“统计所有路径某指标”套路：
1. **路径条数**（裸题）  
2. **路径权值和**（本题）  
3. **最长/最短路径**（P1807、P4011）  
4. **带字典序第 k 短路径**（P4745）

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P1807** | 最长路裸题，巩固 DAG DP |
| **P3387** | 带权最长路，需同时记录长度与权值 |
| **P4011** | 二维 DAG，需双关键字 DP |
| **P4745** | 第 k 短路，结合优先队列 + DAG DP |

---

## 7. 学习心得与经验分享

> **wangjinbo** 的踩坑提醒：  
> “一定记着全部开 LL + 每次运算都取模，否则随时随地爆 LL（比赛时因为这个调了半小时）”  
> **洛语云笺点评**：  
> 模运算的 **每一步取模** 是防溢出铁律；遇到大数乘法可先转 `__int128` 再取模。

---

<conclusion>
本次《游走》之旅，我们掌握了 DAG 上期望问题的 **经典套路**：  
“**总长 / 总条数** → **线性 DP** → **拓扑序 or 记忆化** → **模逆元输出**”。  
下次遇到“所有路径”类问题，先想想 DAG 能否拓扑，再决定是否上 DP。  
祝大家刷题愉快，下站再见！

---
处理用时：98.31秒
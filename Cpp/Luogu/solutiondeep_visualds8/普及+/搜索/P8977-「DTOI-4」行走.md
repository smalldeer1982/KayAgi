# 题目信息

# 「DTOI-4」行走

## 题目背景

小 L 感到无聊，于是希望在树上行走。

## 题目描述

小 L 有一棵 $n$ 个点的树，树上点有点权，其中第 $i$ 个点权值为 $a_i$。

他不喜欢奇奇怪怪的权值，于是他保证 $a_i$ 一定是 $-1, 0, 1$ 之一。

他认为在树上行走是有趣的，于是他想要在这棵树上走出一条路径 $P$，其需要满足以下条件：

- $P$ 是一条**可以为空**的**简单有向路径**。
- 设 $P$ 中依次经过的点为 $P_1, P_2, \cdots, P_{|P|}$，则你求出的 $P$ 需要满足 $P_1 = 1$。
- 设 $f(P) = \displaystyle\sum_{i = 1}^{|P|} \frac{a_{P_i}}{2^{i - 1}}$，则你求出的 $P$ 需要满足 $f(P)$ 最大。
- 在 $f(P)$ 最大的前提下，你求出的 $P$ 还需要满足 $P$ 的字典序最小。

请你求出符合上述条件的路径 $P$。 

------------

关于本题中字典序的定义：

设有两条待比较的路径 $P \neq Q$。

- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i < Q_i$，则我们称 $P$ 的字典序小于 $Q$。
- 若存在 $1 \leq i \leq \min(|P|, |Q|)$，使得 $\forall 1 \leq j < i, P_j = Q_j$ 且 $P_i > Q_i$，则我们称 $P$ 的字典序大于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| < |Q|$，则我们称 $P$ 的字典序小于 $Q$。
- 若 $\forall 1 \leq i \leq \min(|P|, |Q|), P_i = Q_i$ 且 $|P| > |Q|$，则我们称 $P$ 的字典序大于 $Q$。

## 说明/提示

#### 样例 #1 解释
![](https://cdn.luogu.com.cn/upload/image_hosting/c7n2n6i0.png)

$P = [1, 2, 4]$ 时 $f(P) = 1 + 0 + \frac{1}{4} = \frac{5}{4}$。可以证明不存在更优的 $P$。
#### 数据范围
| $\textbf{Subtask}$ | $n$ | $a_i$ | 依赖 | 分值 |
| :------: | :------: | :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 50$ | 无特殊限制 | 无 | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 500$ | 同上 | $1$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 5 \times 10^3$ | 同上 | $1, 2$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^5$ | 同上 | $1 \sim 3$ | $20 \operatorname{pts}$ |
| $5$ | 无特殊限制 | $a_i \in \{-1, 1\}$ | 无 | $20 \operatorname{pts}$ |
| $6$ | 同上 | 无特殊限制 | $1 \sim 5$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$a_i \in \{-1, 0, 1\}$，$1 \leq u, v \leq n$，保证给出的边可以构成一棵**无根树**。

## 样例 #1

### 输入

```
5
1 0 -1 1 -1
1 2
2 3
2 4
1 5```

### 输出

```
1 2 4```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「DTOI-4」行走 深入学习指南 💡

> 今天我们来一起分析「DTOI-4」行走这道C++编程题。它看起来像在树上找一条“最优”路径，但真正的挑战在于：如何设计一个“聪明”的决策规则，既让“收益”最大，又让“路径”字典序最小？我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在带权树上，从节点 1 出发，找一条简单有向路径 P，使得  
`f(P)=Σ(a[P_i]/2^{i-1})` 最大；若多解，输出字典序最小的 P。

✨ **核心算法标签**  
贪心 + 树形决策 / BFS 分层 / DFS 回溯

🗣️ **初步分析**  
- 暴力枚举所有路径？指数级，不可行。  
- 关键观察：权重随深度指数衰减 ⇒ “高位”决策影响远大于“低位”。  
- 因此，每一步只需关心“能否放 1？能否放 0？是否必须停止？”——天然适合**贪心+树形决策**。  

> **比喻**：把路径想成“二进制小数”：  
> 1. 绝不放 `-1`（符号位变负，后面全补不回来）。  
> 2. 能放 `1` 就放 `1`（高位优先）。  
> 3. 同层多个 `1`？选编号最小（字典序）。  
> 4. 末尾多余的 `0` 直接截掉（不影响数值，只增字典序）。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：  
   “最大化 Σ a_i / 2^{i-1}” → 指数级衰减 ⇒ **高位优先贪心**。
2. **线索2 (权值范围)**：  
   a_i ∈ {-1,0,1} ⇒ 只有三种决策，且 `-1` 永远亏损 ⇒ **剪枝信号**。
3. **线索3 (字典序)**：  
   要求字典序最小 ⇒ **同层按编号升序扩展**，并在末尾**删除后缀 0**。

### 🧠 思维链构建：从线索到策略
> 1. 首先，【线索1】告诉我们这是一个“高位优先”的贪心问题，大脑立刻闪出“二进制小数”模型。  
> 2. 接着，【线索2】的 `-1` 给了我们一个决定性剪枝：凡是 `-1` 的子树直接砍掉，因为后面补不回来。  
> 3. 最后，【线索3】提示我们在同层出现多个 `1` 时，必须按节点编号升序扩展，才能保证字典序最小。  
> 4. **结论**：综合以上，一个**“高位贪心 + 同层排序 + 后缀截断”**的 BFS/DFS 混合算法，就是本题的最优钥匙！

---

## 2. 精选优质题解参考

### 题解一：xiaoqian02（赞：4）【DFS 链表法】
**亮点**  
- 先 DFS 一次，用 `nxt[u]` 记录“从 u 走哪个儿子最优”，形成链表式答案。  
- 证明 `-1` 不走、能走 `1` 就走 `1`，并在同层按 `vector` 排序保证字典序。  
- 时间复杂度 O(n log n)（排序），代码简洁，常数小。

### 题解二：Hovery（赞：4）【BFS 最大 1 计数】
**亮点**  
- 用 BFS 分层，记录每层“累计 1 的个数”最大值 `mx[dep]`。  
- 只有当当前节点的累计值等于层最大值时才继续扩展，天然剪枝。  
- 最后再 DFS 回溯路径，保证字典序。

### 题解三：Leasier（赞：4）【两次 BFS 分层】
**亮点**  
- 第一次 BFS 找出“必须保留的 1”节点集合；第二次 BFS 在保留树上找字典序最小路径。  
- 用 `ok[u]` 标记子树内是否包含决策点，实现 O(n)。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）
1. **关键点1：剪枝 -1 节点**  
   - **分析**：若路径上出现 `-1`，其后所有 `1` 的贡献之和 < 1/2^{k-1}，总贡献必负。  
   - 💡 **学习笔记**：遇到“绝对亏损”分支，直接剪枝，避免无效搜索。

2. **关键点2：高位贪心决策顺序**  
   - **分析**：深度越小，权重越大。因此策略：  
     1. 优先选 `1`；  
     2. 无 `1` 再选 `0`；  
     3. 同层按节点编号升序。  
   - 💡 **学习笔记**：把“指数级权重”转化为“层间优先级”，实现贪心正确性。

3. **关键点3：后缀 0 截断**  
   - **分析**：末尾连续的 `0` 不影响 `f(P)` 值，却增大字典序，可直接删除。  
   - 💡 **学习笔记**：输出前从尾到头删除 `a[i]==0` 的节点。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力 DFS** | 枚举所有路径 | 思路直观 | 指数级 O(2^n)，无法通过 n=5e5 | n≤20 |
| **高位贪心 + DFS** | 按“能1则1”规则一次 DFS | O(n log n) | 需证明贪心正确性 | 本题最优 |
| **BFS 分层** | 层内保留最大 1 计数节点 | O(n log n) | 需两次遍历 | 同层决策多 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合 xiaoqian02 与 Hovery 思路，采用一次 DFS 贪心 + 链表回溯，简洁高效。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10;
vector<int> g[N];
int a[N], nxt[N], tot[N], n;

bool dfs(int u, int fa, int dep) {
    int mx = -1;
    bool upd = false;
    for (int v : g[u]) {
        if (v == fa) continue;
        mx = max(mx, a[v]);
    }
    if (mx == -1) return false; // 无路可走
    for (int v : g[u]) {
        if (v == fa || a[v] == -1) continue;
        if (a[v] == 1) { // 能1则1
            if (tot[dep] == 0) {
                tot[dep] = 1;
                for (int i = dep + 1; i <= n; ++i) tot[i] = 0;
                nxt[u] = v; upd = true;
            }
            if (dfs(v, u, dep + 1)) { nxt[u] = v; upd = true; }
        }
    }
    if (mx == 0 && tot[dep] == 0) { // 无1可选0
        for (int v : g[u]) {
            if (v == fa || a[v] == -1) continue;
            if (dfs(v, u, dep + 1)) { nxt[u] = v; upd = true; }
        }
    }
    return upd;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    for (int i = 1; i <= n; ++i) sort(g[i].begin(), g[i].end());
    if (a[1] == -1) return 0;
    dfs(1, 0, 0);
    if (a[1] == 0 && !nxt[1]) return 0;
    for (int i = 1; i; i = nxt[i]) cout << i << ' ';
    return 0;
}
```

### 题解片段赏析
**xiaoqian02 片段**  
- **亮点**：用 `tot[dep]` 记录“当前深度是否已出现 1”，实现 O(1) 判断同层决策。  
- **学习笔记**：巧用数组做“高位标记”，避免浮点误差。

**Hovery 片段**  
- **亮点**：BFS 中用 `mx[dep]` 剪枝，保证每层只扩展最优节点。  
- **学习笔记**：层内最大值天然满足“高位优先”。

---

## 5. 算法可视化：像素动画演示

**主题**：“像素探险家”在 8 位树上寻找“最大二进制宝藏”  
**Canvas 布局**  
- 树用 8×8 像素方块表示，节点编号写在方块内。  
- 颜色：`-1`=红（禁止），`0`=灰，`1`=绿。  
- 当前决策节点高亮黄色边框，已选路径用金色连线。

**交互面板**  
- 步进 / 自动播放 / 重置按钮（像素风格）。  
- 每步伴随 8-bit 音效：  
  - 选 `1` → “叮！”  
  - 选 `0` → “嘟…”  
  - 剪枝 `-1` → “砰！”  
- 自动模式下，AI 按“能1则1，同层最小字典序”规则跑完全程。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
“高位贪心 + 字典序最小”适用于：
1. 二进制小数最大化问题（如 01 串字典序最小且数值最大）。  
2. 树形依赖任务选择（必须先选父节点）。  
3. 带权 DAG 最长路（权值随路径长度指数衰减）。

### 洛谷推荐
1. **P3383** 【模板】线性筛素数  
   *推荐理由*：巩固 BFS/DFS 遍历树/图的技巧。  
2. **P1352** 没有上司的舞会  
   *推荐理由*：树形 DP 与贪心决策的结合。  
3. **P2014** 选课  
   *推荐理由*：依赖背包与高位贪心的变形应用。

---

## 7. 学习心得与经验分享（摘自题解）

> **xiaoqian02**：“第一次用 vector 存图，排序后直接按字典序走，代码短得不敢信。”  
> **洛语云笺点评**：vector + sort 是处理“字典序最小”的利器，简洁且不易出错。

> **Hovery**：“记得判空！我赛时忘记 `a[1]==-1` 直接返回，挂了一发。”  
> **洛语云笺点评**：边界特判是高分关键，养成“先想极端”的习惯。

---

<conclusion>
今天我们从“二进制小数”视角拆解了树上的路径决策问题，学会了“高位贪心 + 字典序剪枝”的通用套路。希望大家在今后的竞赛中，也能像“像素探险家”一样，用清晰的规则一步步走向最优解！下次再见！

---
处理用时：84.88秒
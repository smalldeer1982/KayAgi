# 题目信息

# [KMOI R1] 军事行动

## 题目背景

$$\blue{他们来了。}$$

$$\purple{集结军队，干掉他们，一个不留。}$$

$$\blue{是！}$$

## 题目描述

喵星边境局势愈发紧张，导致发生边境冲突。喵星军队总司令小袁立即对 $Y$ 星采取军事行动。

整个宇宙可以看作一个平面直角坐标系，城市 $1,2,\dots,n$ 的坐标分别为 $(x_1,y_1),(x_2,y_2),\dots(x_n,y_n)$。

现在小袁率领的**若干支**舰队（可以理解为小袁的军事力量是无限的）驻扎在边境要塞，城市 $1$ 处。他的舰队会进行以下移动：

- 如果舰队的坐标为 $(x,y)$，那么一天之后它可以移动到 $(x-1,y+2)$ 或 $(x+1,y+2)$ 或 $(x+2,y+1)$ 或 $(x-2,y+1)$ 或 $(x-1,y-2)$ 或 $(x+1,y-2)$ 或 $(x+2,y-1)$ 或 $(x-2,y-1)$ 处。

其中环绕在外的还有一条小行星带，当舰队的坐标  $(x,y)$ 且 $x\le 0$ 或 $y\le 0$ 或 $m < x$ 或 $m < y$ 时，舰队就会撞到小行星带。这是小袁所不想看到的。

现在小袁要攻打城市 $2,3,\dots,n$，每一次他都会从一个**已经占领**的城市（城市 $1$ 也算），派出舰队前往城市 $i$ 并攻打它，舰队**到达之后的第二天**城市 $i$ 就被攻占了。

特别的，小袁在一个舰队**前往攻打或攻打一个城市**的时候不会派出另外一支舰队，在**攻占一座城市后当天**可以立即派出另外一支舰队。

小袁想问，最少要花多少时间才能攻占所有的城市。

**攻打顺序可以不按照 $2,3\dots n$ 的顺序。**

## 说明/提示

## 样例一解释：

舰队在第一天来到了 $(3,2)$ 的位置，第二天到达了城市 $2$ 的位置，第三天占领了城市 $2$。总共花了 $3$ 天。

## 样例二解释：

舰队在第一天到达了城市 $2$ 的位置，第二天占领了城市 $2$。第三天到达了城市 $3$ 的位置，第四天占领了城市 $3$。总共花了 $4$ 天。

## 数据范围

**本题采用 Subtask 捆绑测试。**

|子任务编号|  测试点编号| $n$ | $m$ |特殊性质|分值|
|:-----:| :----------: | :----------: | :----------: | :----------: |:---:|
|$1$| $1\sim2$ | $1\le n\le 7$ |$4\le m\le 7$|无|$10$|
|$2$| $3\sim7$ | $1\le n\le 200$ |$4\le m\le 70$|无|$25$|
|$3$| $8\sim9$ | $1\le n\le 150$ |$4\le m\le 150$|有|$15$|
|$4$| $10\sim20$ | $1\le n\le 2000$ |$4\le m\le 150$|无|$50$|

特殊性质：对于每一个 $1\le i\le n-1$，都有 $x_i = x_{i+1}$。

**数据严格保证不会有不同的城市拥有相同的坐标。**

## 样例 #1

### 输入

```
2 20
1 1
1 3```

### 输出

```
3```

## 样例 #2

### 输入

```
3 150
1 2
2 4
4 3```

### 输出

```
4```

## 样例 #3

### 输入

```
10 10
1 4
2 3
2 6
3 6
10 3
1 5
4 2
5 3
2 8
9 2```

### 输出

```
23```

## 样例 #4

### 输入

```
查看附件的 example4.in```

### 输出

```
查看附件的 example4.out```

# AI分析结果

# 💡 洛语云笺的C++算法解析：[KMOI R1] 军事行动 深入学习指南 💡

> 欢迎来到今天的“思维探险”！我们面对的，是一道披着“舰队作战”外衣的**图论+最短路+最小生成树**综合题。不要被“马走日”的复杂移动方式吓到——只要剥开迷雾，你会发现它其实是一道非常经典的**最小生成树**问题！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
**看似是舰队移动问题，实则是最小生成树！**  
核心挑战在于：  
1. **如何计算任意两城市间的最短“马步”距离**（即边权）。  
2. **如何高效求出连接所有城市的最小总时间**（即最小生成树）。

### ✨ 核心算法标签
- **最短路**（BFS）
- **最小生成树**（MST）
  - Kruskal（并查集+排序）
  - Prim（贪心+优先队列）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 关键发现 | 算法指向 |
| --- | --- | --- |
| **线索1** | 题目要求“最少时间攻占所有城市”，且**攻占顺序可任意** → 本质是“连接所有城市，总移动时间最小” | **最小生成树** |
| **线索2** | 舰队移动规则是**国际象棋“马走日”**（8个方向） → 边权是**两城市间最短马步数+1** | **BFS求最短路** |
| **线索3** | 数据范围：n≤2000，m≤150 → 暴力建图O(n²)可行，BFS复杂度O(nm²)≈4.5×10⁷，完全可过 | **BFS+Kruskal/Prim** |

---

### 🧠 思维链构建：从线索到策略
> 1. **线索1**告诉我：这不是“舰队移动”，而是“连接所有城市”！  
> 2. **线索2**告诉我：边权不是欧几里得距离，而是“马步”最短路！  
> 3. **线索3**告诉我：暴力BFS建图+最小生成树，就是最优解！  
> **结论**：用BFS求出所有城市两两之间的最短马步距离，然后跑最小生成树即可！

---

## 2. 精选优质题解参考

### 🔥 题解一：Fire_flame（赞：6）  
- **核心思路**：**BFS+Kruskal**  
  1. 对每个城市跑BFS，求出到其他城市的最短马步距离。  
  2. 用Kruskal算法求最小生成树（并查集+排序）。  
- **亮点**：  
  - 代码简洁，BFS时**入队即标记**，避免重复计算。  
  - 用`struct edge`封装边，排序后直接Kruskal。  

---

### 🔥 题解二：_Flame_（赞：3）  
- **核心思路**：**数学推导+Kruskal**  
  - 用数学公式直接计算两城市间的最短马步距离，无需BFS！  
- **亮点**：  
  - 分类讨论+公式推导，时间复杂度优化到O(n²)。  
  - 但公式复杂，易错，适合进阶选手。

---

### 🔥 题解三：TruchyR（赞：0）  
- **核心思路**：**Prim算法**  
  - 用Prim算法求最小生成树（贪心+优先队列）。  
- **亮点**：  
  - 完全图用Prim更高效（O(n²)）。  
  - 代码清晰，适合理解Prim流程。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 | 学习笔记 |
| --- | --- | --- |
| **1. 如何求边权？** | 用BFS从每个城市出发，求到其他城市的最短马步数。 | BFS是求无权图最短路的利器！ |
| **2. 如何建图？** | 建一个**完全图**（n个城市两两连边），边权为最短马步数+1。 | 完全图用Prim更高效！ |
| **3. 如何求最小生成树？** | **Kruskal**（并查集+排序）或 **Prim**（贪心）。 | Kruskal适合稀疏图，Prim适合稠密图！ |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- | --- |
| **BFS+Kruskal** | BFS求边权+Kruskal求MST | 思路直观，代码简洁 | 需要O(n²logn)排序 | 通用解法，推荐！ |
| **数学推导+Kruskal** | 用公式直接算边权 | 时间优化到O(n²) | 公式复杂，易错 | 数学大神专用 |
| **Prim算法** | 贪心扩展最小边 | 完全图更高效 | 代码稍长 | 稠密图首选 |

---

### ✨ 解题技巧总结
- **技巧1**：BFS时**入队即标记**，避免重复计算。  
- **技巧2**：完全图用**Prim算法**更高效（O(n²)）。  
- **技巧3**：最终答案需**+n-1**（攻占城市额外1天/城）。

---

## 4. C++核心代码实现赏析

### 🌟 本题通用核心C++实现（BFS+Kruskal）
```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 2005;
const int MAXM = 155;
int n, m, cnt, ans;
int dx[] = {-1, 1, 2, -2, -1, 1, 2, -2};
int dy[] = {2, 2, 1, 1, -2, -2, -1, -1};

struct Point {
    int x, y;
} p[MAXN];

struct Edge {
    int u, v, w;
    bool operator<(const Edge& other) const { return w < other.w; }
} e[MAXN * MAXN];

int fa[MAXN];
int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

void bfs(int sx, int sy, int id) {
    queue<pair<int, int>> q;
    vector<vector<int>> dis(MAXM, vector<int>(MAXM, -1));
    q.emplace(sx, sy);
    dis[sx][sy] = 0;
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop();
        for (int i = 0; i < 8; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 1 || ny < 1 || nx > m || ny > m || dis[nx][ny] != -1) continue;
            dis[nx][ny] = dis[x][y] + 1;
            q.emplace(nx, ny);
            for (int j = 1; j <= n; ++j) {
                if (p[j].x == nx && p[j].y == ny) {
                    e[++cnt] = {id, j, dis[nx][ny]};
                }
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> p[i].x >> p[i].y;
        fa[i] = i;
    }
    for (int i = 1; i <= n; ++i) bfs(p[i].x, p[i].y, i);
    sort(e + 1, e + cnt + 1);
    for (int i = 1; i <= cnt; ++i) {
        int u = e[i].u, v = e[i].v, w = e[i].w;
        if (find(u) != find(v)) {
            fa[find(u)] = find(v);
            ans += w;
        }
    }
    cout << ans + n - 1 << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：**“像素骑士的MST之旅”**
- **风格**：8位像素风（红白机配色）。  
- **场景**：一个m×m的棋盘，城市用像素城堡表示，舰队用像素马图标。  
- **动画流程**：  
  1. **BFS阶段**：从城市1出发，马图标跳跃探索，遇到新城市时高亮连线。  
  2. **MST阶段**：用像素化的“闪电”连接最小边，每连接一条边播放“叮”音效。  
- **交互**：  
  - 单步/自动播放按钮。  
  - 进度条显示当前BFS层数或MST边数。  

---

## 6. 拓展练习与相似问题思考

### 🌍 通用技巧迁移
- **BFS求边权**：适用于任何“特殊移动规则”的最短路问题（如骑士巡逻、迷宫最短路径）。  
- **最小生成树**：适用于“连接所有点，总代价最小”的问题（如电网布线、网络设计）。

### 📝 洛谷推荐练习
1. **P3366 【模板】最小生成树**  
   - 巩固Kruskal和Prim模板。  
2. **P1546 [USACO3.1]最短网络**  
   - 经典MST问题，边权已给出。  
3. **P2914 [USACO08OCT]牛的路径**  
   - 需先BFS求边权，再跑MST。

---

## 7. 学习心得与经验分享

> **来自Fire_flame的调试心得**：  
> “BFS时一定记得**入队即标记**，否则可能重复入队导致TLE！”  
> **洛语云笺点评**：  
> 这是BFS的经典陷阱！记住：**队列里存的是“待处理”的节点，不是“已处理”的**。

---

### 🏁 结语
今天的“军事行动”分析就到这里！记住：  
- **复杂问题→图论模型**  
- **特殊移动→BFS求边权**  
- **连接所有点→最小生成树**  

下次我们再一起探索新的算法挑战！💪

---
处理用时：61.45秒
# 题目信息

# 神奇的小江鸟

## 题目背景

You can also see the pdf at the bottom of the chinese problem statement.

感谢 [ineverleft](https://www.luogu.com.cn/user/362679) 为本题提供的本地调试 checker。

「愿有前程可奔赴，亦有岁月可回首。」

## 题目描述

小 $ \zeta $ 在探险过程中看到了一个大锁。

这个大锁有 $ n $ 个拨圈，第 $ i $ 个拨圈的拨动范围为 $ l_i $ 到 $ r_i $ 之间（含两个边界）的所有整数（保证 $ l_i \le r_i $）。

我们定义这个大锁的「自由度」为所有拨圈上的数的**最大公约数**，当锁的「自由度」大于等于 $ k $ 时，会被打开。

请你找到一种锁的开启方案，或报告无解。

## 说明/提示

**【样例 1 解释】**

唯一的一组数据 $ \gcd $ 为 $ 10 $。

五个样例自测均可使用下发的附件。**请注意部分样例可能存在多解，样例输出仅列举了一组可行解。**

**【数据规模与约定】**

对于 $ 100\% $ 的数据，$ 1 \le T \le 5 $，$ 2 \le n \le 10^4 $，$ 1 \le l_i \le r_i \le 10^9 $，$ 1 \le k \le 1000 $。

**本题开启子任务捆绑测试。**

* Subtask 1（10 pts）：$ k=1 $。
* Subtask 2（15 pts）：$ n \le 10 $，$ r_i - l_i + 1 \le 5 $。
* Subtask 3（15 pts）：$ r_i \le 10^3 $。
* Subtask 4（10 pts）：$ k \le 5 $，$ l_i,r_i $ 均在 $ 1 \le l_i \le r_i \le 10^9 $ 范围内等概率随机生成，该子任务只有 $ 1 $ 个测试点。
* Subtask 5（15 pts）：对于每组数据，$ \exist 1 \le i \le n,l_i=r_i $。
* Subtask 6（35 pts）：无特殊限制。

**【关于附加文件】**

**本题下发了 `checker.cpp` 作为自测器。**

请将输入内容、你的程序输出、参考答案输出分别放置在 `restore.in`、`restore.out`、`restore.ans` 中，这三个文件必须与 `checker.cpp` 在同一目录下，运行 `checker.cpp`，终端上会给出自测结果。

**你需要保证你的输入满足 $ 100\% $ 数据范围的要求。**

注意，如果你的输入/输出/答案的格式和范围不正确的话，`checker.cpp` 出现的结果是不可预料的。因此，**请先确保你的三个文件格式正确。**

## 样例 #1

### 输入

```
1
5 10
1 12
44 50
9 10
88 99
29 99```

### 输出

```
Yes
10 50 10 90 30```

## 样例 #2

### 输入

```
2
3 11
99 10003
39 299
39 10003
5 55
1 54
1 20
1 300
1 300
1 300```

### 输出

```
Yes
123 246 369
No```

## 样例 #3

### 输入

```
3
6 1
1 10
1 10
1 10
1 10
1 10
1 10
5 4
11 15
6 10
9 14
20 23
27 29
5 11
20 30
50 70
111 120
72 77
119 121```

### 输出

```
Yes
1 1 4 5 1 4
Yes
14 7 14 21 28
Yes
24 60 120 72 120```

## 样例 #4

### 输入

```
4
3 33
32 34
65 67
97 101
3 5
299 99494993
499 49992999
499 39999939
4 25
719 830
2194 2893
132 142
199 225
3 10
140 143
131 135
238 241```

### 输出

```
Yes
33 66 99
Yes
1919810 11400 51400
Yes
729 2700 135 216
No```

## 样例 #5

### 输入

```
1
10 7
77 77
82 174
77 77
82 174
77 77
82 174
77 77
82 174
77 77
82 174```

### 输出

```
Yes
77 154 77 154 77 154 77 154 77 154```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：神奇的小江鸟 深入学习指南 💡

> 今天我们来一起分析“神奇的小江鸟”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在 n 个给定的区间 `[l_i, r_i]` 中，每个区间选一个整数，使得这 n 个数的 **最大公约数 ≥ k**。  
核心难点在于**如何高效地枚举或构造一个“候选公约数”**，并快速验证它是否**在每个区间内都能找到倍数**。

✨ **核心算法标签**：  
数学推导、枚举优化、因数分解、鸽巢原理、数据分治（乱搞技巧）

🗣️ **初步分析**：
- 朴素做法：枚举所有可能的公约数 `d ≥ k`，再检查每个区间是否包含 `d` 的倍数。但值域高达 1e9，直接枚举 `d` 会超时。
- 优化突破口：`k ≤ 1000` 且区间长度可能远大于 `k`，这提示我们**只需关注“短区间”内的数**。
- 将问题转化为：**在“最短区间”内的某个数的 ≥k 的因数**中寻找答案，可将枚举量从 1e9 级降至 **k√V** 级。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：  
   “求最大公约数 ≥ k”，说明答案一定是某个**≥k 的因数**。
2. **线索2 (数据范围)**：  
   `k ≤ 1000` 暗示枚举与 k 相关的量；区间长度可能远大于 k，可用**鸽巢原理**（区间长度 ≥k 时必含 k 的倍数）。
3. **线索3 (问题转化)**：  
   若所有区间长度 ≥k，直接取 `d = k` 即可；否则，只需在“最短区间”内枚举数的因数，**将搜索空间缩小到 O(k√V)**。

### 🧠 思维链构建：从线索到策略
> 1. 首先，【线索1】告诉我们答案是一个“公约数”，枚举范围必须围绕 ≥k 的因数。
> 2. 接着，【线索2】发现 k 很小，而区间长度可能很大，这提示我们**利用区间长度 ≥k 时的鸽巢原理**快速判定。
> 3. 最后，【线索3】将问题转化为：若存在短区间，只需枚举其内数的因数，**将 O(1e9) 枚举降至 O(k√V)**。
> 4. **结论**：采用“**最短区间因数枚举法**”，结合鸽巢原理剪枝，即可高效求解。

---

## 2. 精选优质题解参考

我综合了思路清晰度、代码规范性、算法有效性与启发性，筛选了以下 **4 份 ≥4星** 的优质题解：

### 题解一：船酱魔王（正解，4.5星）
- **点评**：  
  清晰提出“最短区间 + 因数枚举”的正解思路，复杂度分析严谨，代码结构规范。利用 `set<int>` 去重因数，避免重复枚举，体现了良好的工程实践。
- **关键技巧**：  
  1. 按区间长度排序，锁定最短区间。  
  2. 枚举最短区间内所有数的因数，再验证每个区间是否包含该因数的倍数。

### 题解二：Austin0116（数据分治，4星）
- **点评**：  
  赛时先以“人类智慧”枚举 `d ≤ 1e6`，后通过观察最短区间右端点优化，最终采用“**n ≤ 10 时暴力枚举，否则枚举到最短区间右端点**”的数据分治策略，展现了实战中的灵活应变。
- **关键技巧**：  
  1. 利用“区间长度短”时枚举右端点，减少无效枚举。  
  2. 数据分治思想，针对不同数据规模采用不同策略。

### 题解三：Kendieer（鸽巢原理 + 因数枚举，4.5星）
- **点评**：  
  完整推导了鸽巢原理的应用，逻辑严密。代码简洁，利用 `r[i]/d*d` 快速找到区间内最大的 `d` 的倍数，体现了数学推导与代码实现的完美结合。
- **关键技巧**：  
  1. 鸽巢原理：区间长度 ≥d 时必含 d 的倍数。  
  2. 枚举最短区间因数，确保复杂度 O(k√V)。

### 题解四：LinkCatTree（乱搞技巧，4星）
- **点评**：  
  通过 subtask 分治，针对不同数据特点设计乱搞策略（如随机化顺序、特殊构造），展现了实战中“骗分”的巧妙思路。虽非正解，但启发性强。
- **关键技巧**：  
  1. 针对 k=1、区间长度短、随机数据等场景分别处理。  
  2. 随机化枚举顺序，避免被构造数据卡死。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）
1. **关键点1：如何锁定“最短区间”？**
   - **分析**：  
     将区间按长度升序排序，最短区间即为 `rn[1]`。若其长度 ≥k，直接取 `d = k` 即可（鸽巢原理）。
   - 💡 **学习笔记**：  
     排序后锁定最短区间，将搜索空间从 O(1e9) 降至 O(k√V)。

2. **关键点2：如何高效枚举“最短区间”内的因数？**
   - **分析**：  
     遍历最短区间 `[l, r]` 内的每个数 `x`，枚举其所有因数 `d ≥ k`，用 `set<int>` 去重。
   - 💡 **学习笔记**：  
     因数枚举复杂度 O(√x)，最短区间长度 ≤k-1，总复杂度 O(k√V)。

3. **关键点3：如何验证一个因数 `d` 是否可行？**
   - **分析**：  
     对每个区间 `[a, b]`，检查是否存在 `d` 的倍数：`ceil(l/d)*d ≤ r`，即 `(l-1)/d + 1)*d ≤ r`。
   - 💡 **学习笔记**：  
     利用整数除法快速判断区间内是否存在倍数，避免浮点误差。

### ✨ 解题技巧总结
- **技巧A（鸽巢原理剪枝）**：  
  当所有区间长度 ≥k 时，直接取 `d = k`，无需枚举。
- **技巧B（最短区间因数枚举）**：  
  将搜索空间从全局 1e9 级降至局部 k√V 级，实现复杂度优化。
- **技巧C（因数去重）**：  
  使用 `set<int>` 或哈希表去重，避免重复验证同一因数。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力枚举所有 d** | 枚举 `d ≥ k`，检查每个区间 | 思路直观 | 复杂度 O(V·n)，无法通过 | V ≤ 1e5，得分 10% |
| **最短区间因数枚举** | 枚举最短区间内的因数 `d ≥ k` | 复杂度 O(k√V + nM)，高效 | 需正确实现因数枚举与验证 | 正解，得分 100% |
| **数据分治（Austin）** | n ≤ 10 时暴力，否则枚举到最短右端点 | 实战灵活，部分分高 | 非通用，依赖数据特点 | 赛时得分 85%-100% |
| **乱搞技巧（LinkCatTree）** | 针对各 subtask 设计骗分策略 | 启发性强，易实现 | 非正解，可能挂加强数据 | 赛时得分 70%-100% |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点：暴力枚举的困境**  
>    直接枚举 `d` 从 k 到 1e9，每个 d 需 O(n) 验证，总复杂度 O(1e12)，显然超时。
> 2. **发现瓶颈：无效枚举过多**  
>    大量 d 无法满足“每个区间都有倍数”的条件，需缩小搜索空间。
> 3. **优化的钥匙：最短区间因数枚举**  
>    将搜索空间缩小到“最短区间内的因数”，利用鸽巢原理剪枝，复杂度降至 O(k√V + nM)。
> 4. **结论**：  
>    通过数学推导（鸽巢原理）与数据结构（set去重），将指数级问题转化为多项式级，实现高效求解。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：  
  综合船酱魔王与Kendieer的正解思路，提供完整可编译的核心实现，涵盖鸽巢原理剪枝与最短区间因数枚举。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e4 + 5;
int T, n, k;
struct Node { int l, r, id; } a[N];

bool cmp_len(const Node& x, const Node& y) {
    return (x.r - x.l + 1) < (y.r - y.l + 1);
}

bool check(int d) {
    for (int i = 1; i <= n; ++i) {
        int first = (a[i].l + d - 1) / d * d;
        if (first > a[i].r) return false;
    }
    return true;
}

void solve() {
    scanf("%d%d", &n, &k);
    for (int i = 1; i <= n; ++i) {
        scanf("%d%d", &a[i].l, &a[i].r);
        a[i].id = i;
    }
    sort(a + 1, a + n + 1, cmp_len);

    int ans = -1;
    if (a[1].r - a[1].l + 1 >= k) {
        ans = k;
    } else {
        set<int> cand;
        for (int x = a[1].l; x <= a[1].r; ++x) {
            for (int d = 1; d * d <= x; ++d) if (x % d == 0) {
                if (d >= k) cand.insert(d);
                if (x / d >= k) cand.insert(x / d);
            }
        }
        for (int d : cand) if (check(d)) { ans = d; break; }
    }

    if (ans == -1) { puts("No"); return; }
    puts("Yes");
    sort(a + 1, a + n + 1, [](const Node& x, const Node& y){ return x.id < y.id; });
    for (int i = 1; i <= n; ++i) {
        printf("%d%c", (a[i].l + ans - 1) / ans * ans, " \n"[i == n]);
    }
}

int main() {
    scanf("%d", &T);
    while (T--) solve();
    return 0;
}
```

- **代码解读概要**：  
  1. **排序区间**：按长度升序排序，锁定最短区间。  
  2. **鸽巢原理剪枝**：若最短区间长度 ≥k，直接取 `d = k`。  
  3. **因数枚举**：枚举最短区间内数的因数，用 `set` 去重。  
  4. **验证与输出**：对每个因数 `d`，检查是否每个区间包含 `d` 的倍数，并输出方案。

### 针对各优质题解的片段赏析

#### 题解一：船酱魔王（set去重因数）
```cpp
set<int> se;
for(int i = rn[1].first; i <= rn[1].second; ++i) {
    for(int j = 1; j * j <= i; ++j) if(i % j == 0) {
        if(j >= k) se.insert(j);
        if(i / j >= k) se.insert(i / j);
    }
}
```
- **亮点**：利用 `set` 自动去重，确保每个因数只验证一次。  
- **学习笔记**：`set` 的插入操作 O(log M)，适合小规模因数去重。

#### 题解二：Austin0116（数据分治）
```cpp
if(n <= 10) { /* 暴力枚举到 1e6 */ }
else { /* 枚举到最短区间右端点 */ }
```
- **亮点**：根据数据规模分治，平衡复杂度与实现难度。  
- **学习笔记**：实战中灵活调整策略，针对不同数据特点优化。

#### 题解三：Kendieer（鸽巢原理）
```cpp
if(r[mni] - l[mni] + 1 >= k) { /* 直接输出 k 的倍数 */ }
```
- **亮点**：数学推导简洁，直接利用鸽巢原理剪枝。  
- **学习笔记**：数学性质是优化复杂度的关键，需深入挖掘。

---

## 5. 算法可视化：像素动画演示

### 动画演示主题
**“像素锁匠”** 在 8 位像素世界中，通过旋转锁圈（区间）寻找满足条件的“公约数齿轮”。

### 核心演示内容
1. **场景初始化**：  
   屏幕展示 n 个像素化锁圈（区间），每个锁圈用不同颜色表示 `[l_i, r_i]` 范围。
2. **鸽巢原理动画**：  
   当所有锁圈长度 ≥k 时，高亮显示 `d = k` 的倍数位置，伴随“叮”音效。
3. **最短区间因数枚举**：  
   锁定最短锁圈，逐个像素化展示其内数的因数（像素齿轮），用箭头标记当前验证的因数 `d`。
4. **验证过程**：  
   对每个因数 `d`，动画展示每个锁圈内是否存在 `d` 的倍数（像素齿轮对齐），失败时播放“错误”音效，成功时播放“胜利”音效。
5. **交互控制**：  
   提供“单步”、“自动播放”按钮，速度滑块调节；右侧实时显示当前验证的因数 `d` 与验证结果。

### 设计思路简述
- **8位像素风**：营造复古学习氛围，降低理解门槛。  
- **音效与颜色**：关键操作伴随音效，增强记忆；成功/失败状态用颜色区分。  
- **游戏化元素**：将每个因数验证视为“小关卡”，完成即“过关”，增加趣味性。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
“枚举公约数 + 区间验证”的技巧适用于：
1. **课程选择**：每门课有可选时间段，求所有课时间点的最大公约数 ≥k（如每周固定间隔）。
2. **任务调度**：任务需在 `[l_i, r_i]` 内执行，求所有任务执行时间的公约数 ≥k（如周期性任务）。
3. **资源分配**：资源分配需满足区间约束，求分配时间的公约数 ≥k（如定期维护）。

### 练习推荐（洛谷）
1. **P11312 神奇的小江鸟**  
   🗣️ **推荐理由**：本题模板，巩固“最短区间因数枚举 + 鸽巢原理”技巧。
2. **P4779 最大公约数**  
   🗣️ **推荐理由**：考察公约数的构造与验证，强化数学推导能力。
3. **P3383 线性筛素数**  
   🗣️ **推荐理由**：因数分解的底层实现，理解素数筛法对枚举因数的优化。
4. **P1443 马的遍历**  
   🗣️ **推荐理由**：区间与倍数关系在棋盘问题中的应用，拓展思维边界。

---

## 7. 学习心得与经验分享

> **参考经验（来自 Austin0116）**：  
> “赛时先写暴力枚举到 1e6，发现 65 分后，通过观察最短区间右端点优化到 85 分，最终用数据分治 AC。这让我意识到：**数学性质 + 数据观察** 是突破瓶颈的关键。”

> **点评**：  
> 实战中，不要急于写正解，先通过暴力或部分分观察数据特点，再针对性优化。数学推导（如鸽巢原理）与数据分治思想，是解决此类问题的通用法宝。

---

<conclusion>
本次关于“神奇的小江鸟”的C++解题分析就到这里。记住：数学性质是优化复杂度的钥匙，数据观察是实战中的利器。下次我们再一起探索新的编程挑战！💪

---
处理用时：150.04秒
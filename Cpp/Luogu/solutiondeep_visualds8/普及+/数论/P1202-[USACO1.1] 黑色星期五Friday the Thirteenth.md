# 题目信息

# [USACO1.1] 黑色星期五Friday the Thirteenth

## 题目描述

$13$ 号又是一个星期五，那么 $13$ 号在星期五比在其他日子少吗？  

为了回答这个问题，写一个程序，要求计算每个月的十三号落在周一到周日的次数。给出 $n$ 年的一个周期，要求计算 $1900$ 年 $1$ 月 $1$ 日至 $1900+n-1$ 年 $12$ 月 $31$ 日中十三号落在周一到周日的次数。

这里有一些你要知道的:

1. $1900$ 年 $1$ 月 $1$ 日是星期一。
2. $4,6,11$ 和 $9$ 月有 $30$ 天，其他月份除了 $2$ 月都有 $31$ 天，闰年 $2$ 月有 $29$ 天，平年 $2$ 月有 $28$ 天。
3. 年份可以被 $4$ 整除的为闰年（$1992=4\times 498$ 所以 $1992$ 年是闰年，但是 $1990$ 年不是闰年）。
4. 以上规则不适合于世纪年。可以被 $400$ 整除的世纪年为闰年，否则为平年。所以，$1700,1800,1900,2100$ 年是平年，而 $2000$ 年是闰年。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 400$。

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
20
```

### 输出

```
36 33 34 33 35 35 34
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：黑色星期五 Friday the Thirteenth 深入学习指南 💡

> 今天我们来一起分析 USACO 1.1 的经典模拟题「黑色星期五」。这不仅仅是一次解题，更是一场思维的探险：如何优雅地让电脑帮你数清楚 20 世纪里，13 号到底更偏爱星期几？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在 **n 年（1 ≤ n ≤ 400）** 的跨度内，统计 **每月 13 号** 落在 **周一到周日** 的次数。  
> 关键难点在于：  
> 1. **正确模拟/计算日期**（闰年、大小月）；  
> 2. **把“星期”循环映射成数组下标**；  
> 3. **输出顺序必须从周六开始**（坑点！）。

✨ **核心算法标签**：模拟 / 数学公式 / 日期处理

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现内容 | 推理结论 |
|---|---|---|
| **线索1：数据范围** | n ≤ 400，共 400×12 = 4800 个月 | 4800 次统计完全可暴力，O(月数) 足以通过 |
| **线索2：日期规律** | 1900-01-01 是星期一 | 可用“累加天数 mod 7”或“数学公式”推算任意一天星期 |
| **线索3：输出顺序** | 样例输出 `36 33 34 33 35 35 34` | 第一个是 **周六**，而非周一 → 需映射 `week[6], week[0..5]` |

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，**线索1** 告诉我们：暴力枚举 4800 个月完全可行。  
> 2. **线索2** 提示两种思路：  
>   - 逐日模拟（day++, week++）  
>   - 逐月模拟（只关心“本月13号与上月13号相隔多少天”）  
> 3. **线索3** 提醒我们：最后输出顺序必须 **Saturday → Sunday → … Friday**。  
> 4. 综合：  
>   - **初级思路**：按天循环，13 号就记录星期。  
>   - **进阶思路**：用“基姆拉尔森公式”或“蔡勒公式”直接求星期，O(月数) 降成 O(1) 每查询。  
> 5. **结论**：  
>   - 想快速 AC：逐月累加天数即可。  
>   - 想炫技：公式秒杀，代码更短。

---

## 2. 精选优质题解参考

> 我从 20+ 份题解中，按 **思路清晰度、代码优雅度、启发性** 选出了 3 份 **4★以上** 的范例，供大家各取所需。

### 题解一：逐日模拟（最易理解）
- **作者**：Eason_AC2  
- **亮点**：  
  - 用 `while` 一天一天走，变量 `week` 循环 1~7；  
  - 当 `d == 13` 时 `ans[week]++`；  
  - 用 `switch/case` 优雅区分 31/30/28/29 天。  
- **学习价值**：逻辑直观，适合第一次写日期模拟的同学。

### 题解二：逐月累加（效率+简洁）
- **作者**：buickboy  
- **亮点**：  
  - 只关心“**本月13号**”与“**上月13号**”间隔 `last_month_days`；  
  - 公式：`week = (week + last_month_days) % 7`，O(12n)。  
  - 代码仅 20 行，效率比逐日高 30 倍。  
- **学习价值**：把“日期模拟”抽象成“模 7 加法”，思维升级。

### 题解三：基姆拉尔森公式（数学秒杀）
- **作者**：HEIGE  
- **亮点**：  
  - 直接套公式 `week = (d + 2*m + 3*(m+1)/5 + y + y/4 - y/100 + y/400 + 1) % 7`；  
  - 代码 30 行，无循环嵌套，最简洁。  
- **学习价值**：学会“日期→星期”的通用数学武器，秒杀所有同类题。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析与技巧 | 学习笔记 |
|---|---|---|
| **闰年判断** | 能被 400 整除 **或** 能被 4 但不能被 100 整除 | 写成 `inline bool leap(int y)` 复用 |
| **逐月累加** | 用 `week = (week + days_of_last_month) % 7` 更新 | 避免三层循环，复杂度 O(n) |
| **输出映射** | 数组下标 0~6 对应 周日~周六；输出顺序 6 0 1 2 3 4 5 | 用 `printf("%d %d %d %d %d %d %d", ans[6], ans[0], ...)` |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 复杂度 | 代码行数 | 适用场景 |
|---|---|---|---|---|
| **逐日模拟** | 一天一天走，13 号统计 | O(365n) | 60+ | 新手入门，思路直观 |
| **逐月累加** | 只跳 13 号，模 7 加法 | O(12n) | 20 | 竞赛常用，平衡简洁与效率 |
| **公式秒杀** | 基姆拉尔森 / 蔡勒 | O(12n) 但常数极小 | 15 | 背公式现场速写，炫技专用 |

### ✨ 优化之旅：从“能做”到“做好”

> 1. **起点**：逐日循环，三重 for，冗长却安全。  
> 2. **瓶颈**：大量日期与 13 号无关，浪费时间。  
> 3. **跃迁**：发现“13 号星期”只取决于“上月13号+上月天数”。  
> 4. **终点**：把循环压缩到“每年 12 次”，代码减半，速度翻倍！

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考（逐月累加版）
```cpp
#include <cstdio>
int ans[7], m[13] = {0,31,28,31,30,31,30,31,31,30,31,30,31};
bool leap(int y) { return (y % 400 == 0) || (y % 4 == 0 && y % 100 != 0); }
int main() {
    int n, week = 3;            // 1899-12-13 是周三
    scanf("%d", &n);
    for (int y = 1900; y < 1900 + n; ++y) {
        if (leap(y)) m[2] = 29; else m[2] = 28;
        for (int mon = 1; mon <= 12; ++mon) {
            week = (week + m[mon - 1 ? mon - 1 : 12]) % 7;
            ans[week]++;
        }
    }
    printf("%d %d %d %d %d %d %d\n",
           ans[6], ans[0], ans[1], ans[2], ans[3], ans[4], ans[5]);
    return 0;
}
```
- **代码解读**：  
  - 用 `week` 记录“**本月13号是星期几**”；  
  - 每次加 `m[mon-1]` 天即可得到下月 13 号的星期；  
  - 数组 `ans` 统计出现次数，最后按题目顺序输出。

### 题解片段赏析

#### 片段1：基姆拉尔森公式（HEIGE）
```cpp
int week_day(int y, int m, int d) {
    if (m < 3) m += 12, --y;
    return (d + 2*m + 3*(m+1)/5 + y + y/4 - y/100 + y/400 + 1) % 7;
}
```
- **亮点**：一行公式解决“日期→星期”，无需任何循环。  
- **学习笔记**：把数学结论封装成函数，可读性 + 复用性满分。

#### 片段2：逐日模拟核心循环（Eason_AC2）
```cpp
while (y <= 1900 + n - 1) {
    if (d == 13) ++ans[week];
    ++week; if (week == 8) week = 1;
    ++d;
    if (d > days_of_month(y, m)) { d = 1; ++m; }
    if (m == 13) { m = 1; ++y; }
}
```
- **亮点**：变量命名清晰，逻辑步步推进，新手易读。  
- **学习笔记**：把复杂流程拆成“日→月→年”三层，降低心智负担。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素日历”** —— 8 位红白机风格，逐月点亮 13 号所在的格子！

- **画面布局**  
  - 顶部：年份 1900 ~ 1900+n-1 横向滚动。  
  - 中央：7×12 网格，行代表星期（周六→周五），列代表 12 个月。  
  - 每当计算到某月 13 号，对应格子像素闪烁 +1，并播放 8 位“叮”音效。

- **交互按钮**  
  - ⏯️ 开始 / 暂停  
  - ⏭️ 单步（逐月）  
  - 🔄 重置  
  - 🎵 音效开关

- **技术实现要点**  
  - 用 Canvas 绘制 16×16 像素方块；  
  - 用 `setInterval` 控制 200ms/步；  
  - 音效通过 Web Audio API 生成 440Hz 方波，时长 80ms。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **日期周期问题**  
  - 生日是星期几？ → 同公式。  
  - 日历排版 → 先求 1 号是星期几。  
  - 银行工作日计算 → 排除周末 & 节假日。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P5707** 日期差值 | 训练闰年、大小月细节 |
| **P1223** 排队接水 | 把“日期”抽象成时间轴，练习模拟 |
| **P2671** 数字统计 | 继续用数组计数思想，但范围更大 |
| **P1186** 文理分科 | 组合数学 + 日期限制，提升建模能力 |

---

## 7. 学习心得与经验分享

> 摘录自 **buickboy**：  
> “把每月 13 号的星期数，只看成 **模 7 的累加**，代码瞬间从 60 行缩到 20 行。  
> 这让我意识到：**日期问题 ≠ 日期模拟，而是数学循环**。”

💡 **洛语云笺点评**：  
“日期模拟”类题目最忌“无脑三层循环”。学会把“日”抽象成“模 7 的偏移量”，是思维从 **暴力** 到 **优雅** 的关键一跃！

---

<conclusion>
恭喜你，已经掌握了“黑色星期五”从暴力到数学的完整升级路径！  
记住：**模拟题 ≠ 代码堆砌，而是对规律的洞察**。下次遇到日历类问题，先想想“能否用模运算干掉一层循环”。  
继续加油，我们下一场思维探险见！💪
</conclusion>

---
处理用时：93.85秒
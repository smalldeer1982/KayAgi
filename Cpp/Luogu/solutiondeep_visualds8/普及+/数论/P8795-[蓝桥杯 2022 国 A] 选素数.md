# 题目信息

# [蓝桥杯 2022 国 A] 选素数

## 题目描述

小蓝有一个数 $x$，每次操作小蓝会选择一个小于 $x$ 的素数 $p$，然后在 $x$ 成为 $p$ 的倍数前不断将 $x$ 加 $1$，（如果 $x$ 一开始就是 $p$ 的倍数则 $x$ 不变）。

小乔看到了小蓝进行了 $2$ 次上述操作后得到的结果 $n$，他想知道 $x$ 在一开始是多少。如果有多种可能，他想知道 $x$  一开始最小可以是多少，而如果不存在任何解，说明小乔看错了，此时请输出 $-1$。

## 说明/提示

**【评测用例规模与约定】**

- 对于 $60\%$ 的评测用例，$1 \leq n \leq 5000$；
- 对于所有评测用例，$1 \leq n \leq 10^6$。

蓝桥杯 2022 国赛 A 组 G 题。

## 样例 #1

### 输入

```
22```

### 输出

```
8```

# AI分析结果

💡 洛语云笺的C++算法解析：选素数 深入学习指南 💡  

> 今天我们来一起分析「蓝桥杯 2022 国 A – 选素数」。它看似只是一道“倒推数字”的小题，实则暗藏数论与逆向思维的双重考验。让我们像侦探一样，从题面里抽丝剥茧，找到最优雅的钥匙！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> **逆向还原两次操作后的最小初始值**。正向操作用一个质数把 x 抬到最近的倍数；现在给定终点 n，要倒着走两步，求最小的起点 x。

✨ **核心算法标签**：数论 · 线性筛 · 质因数分解 · 逆向思维

🗣️ **初步分析**：  
- 朴素思路：枚举所有可能的第一次操作后的值 m，再枚举第二次操作前的值 x，检查是否能通过两次操作到达 n —— 复杂度爆炸。  
- 关键观察：**一次操作的规律**  
  若 m 是合数，p 为其最大质因子，则最小的 x 满足一次操作后变成 m 是  
  **x = m − p + 1**  
  这个公式把“倒推”变成了“查表”。  
- 二次操作只需在区间 [n − p_max(n) + 1, n] 内枚举 m，再对每个 m 用一次公式即可。  
- 线性筛 O(n) 预处理每个数的最大质因子，整体复杂度 O(n)，稳过 1e6。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：求“最小可能值” → 暗示存在单调性或贪心策略。  
2. **线索2 (操作规则)**：每次选一个质数 p，把 x 抬到最近倍数 → 本质上是“进位”到 p 的倍数，等价于  
   **new_x = ceil(x / p) * p**  
3. **线索3 (数据规模)**：n ≤ 1e6 → O(n log n) 以内可接受，线性筛正好够用。  

### 🧠 思维链构建：从线索到策略
> 1. 看到“最小”与“质数”，先想贪心：一次操作时，选最大的 p 可让 x 最小。  
> 2. 推导出公式 x = m − p_max + 1，把“倒推”转成“区间查询”。  
> 3. 两次操作只需两层区间：外层枚举 m，内层再套公式。  
> 4. 线性筛预处理 p_max，把质因数分解降到 O(1) 查询。  
> 5. 边界：n 本身是质数或 1 时无解，直接输出 −1。

---

## 2. 精选优质题解参考

**题解一：ChrysanthBlossom**  
- **亮点**：首次明确提出「一次操作公式」，并给出线性筛最大质因子的优雅实现。  
- **学习点**：线性筛时同时更新 `np[i*j] = max(np[i*j], j)`，把筛素数与筛最大质因子合二为一。  

**题解二：lemon2021**  
- **亮点**：用口语化比喻把“倒推”讲成“区间 [n − p_max, n] 内找最小值”，思路极顺。  
- **代码**：变量名 `f(m)` 即“m 一次操作前的最小值”，可读性高。  

**题解三：HHH6666666666**  
- **亮点**：给出完整线性筛模板，并补充“答案区间”证明——区间 [n − p_max + 1, n] 内必存在合数，保证有解。  

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
1. **关键点1：一次操作公式如何得来？**  
   - **分析**：若 m 的最大质因子为 p，则 x 必须落在 [m − p + 1, m] 内才能在一次操作后变成 m。  
   - 💡 **学习笔记**：最大质因子决定了“最小倒推起点”。

2. **关键点2：两次操作如何合并？**  
   - **分析**：把两次操作拆成  
     - 第2步：m → n，由公式得 m ∈ [n − p_max(n) + 1, n]  
     - 第1步：x → m，再套一次公式即可  
   - 💡 **学习笔记**：区间套区间，两次公式即可覆盖所有合法路径。

3. **关键点3：线性筛实现细节**  
   - **分析**：  
     ```cpp
     for (int i = 2; i <= n; ++i) {
         if (!maxp[i]) maxp[i] = i, primes[++cnt] = i;
         for (int j = 1; j <= cnt && i * primes[j] <= n; ++j) {
             maxp[i * primes[j]] = max(maxp[i], primes[j]);
             if (i % primes[j] == 0) break;
         }
     }
     ```
   - 💡 **学习笔记**：`maxp[i]` 同时扮演“最小质因子”与“最大质因子”两种角色，利用线性筛的“每个合数只被最小质因子筛一次”特性，O(n) 完成。

### ✨ 解题技巧总结
- **技巧A：逆向思维** —— 把“操作”转成“区间”后，问题瞬间降维。  
- **技巧B：线性筛多合一** —— 一次筛法同时求素数、最小/最大质因子、欧拉函数等，效率倍增。  
- **技巧C：边界特判** —— 质数或 1 直接无解，避免多余计算。

### ⚔️ 策略竞技场：不同解法对比
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力枚举** | 枚举所有 x、m、n 组合 | 思路直白 | O(n² log n) 超时 | n ≤ 3000 |
| **Pollard-Rho + 区间枚举** | 质因数分解用 Pollard-Rho | 理论优雅 | 实现复杂，常数大 | 1e9 以上 n |
| **线性筛 + 区间公式** | 预处理最大质因子，区间枚举 | O(n) 简洁高效 | 需掌握线性筛 | 1e6 以内满分 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. 起点：暴力三层循环，TLE。  
> 2. 发现瓶颈：质因数分解太慢。  
> 3. 优化钥匙：线性筛 O(n) 预处理。  
> 4. 模型升华：把“倒推”抽象成区间最小值查询，算法瞬间起飞。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合多份题解，提炼最简洁、最易读版本。  
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e6 + 10;
int maxp[N];

void linearSieve(int n) {
    static int primes[N], cnt = 0;
    for (int i = 2; i <= n; ++i) {
        if (!maxp[i]) maxp[i] = i, primes[++cnt] = i;
        for (int j = 1; j <= cnt && i * primes[j] <= n; ++j) {
            maxp[i * primes[j]] = max(maxp[i], primes[j]);
            if (i % primes[j] == 0) break;
        }
    }
}

int getMinX(int m) {
    return m - maxp[m] + 1;
}

int main() {
    int n;
    if (!(cin >> n)) return 0;
    linearSieve(n);
    if (maxp[n] == n || n < 2) { cout << -1; return 0; }
    int ans = INT_MAX;
    for (int m = getMinX(n); m <= n; ++m) {
        if (maxp[m] != m) ans = min(ans, getMinX(m));
    }
    cout << ans;
    return 0;
}
```
- **代码解读概要**：  
  1. `linearSieve` 预处理每个数的最大质因子。  
  2. `getMinX(m)` 直接套用一次操作公式。  
  3. 主函数枚举区间并取最小值，特判无解。

### 题解代码片段赏析
**ChrysanthBlossom 片段**  
```cpp
for (ri i = 2; i <= n; i++) {
    if (!np[i]) { pri.push_back(i); np[i] = i; }
    for (auto j : pri) {
        if (i * j > n) break;
        np[i * j] = max(np[i * j], j);
        if (i % j == 0) break;
    }
}
```
- **亮点**：C++17 范围 for 循环 + `vector<int>` 存素数，现代写法。  
- **学习笔记**：`ri` 宏让循环变量变寄存器，微优化。

**lemon2021 片段**  
```cpp
int f(int m) { return isprime[m] ? INT_MAX : m - p[m] + 1; }
```
- **亮点**：一行封装核心公式，可读性极佳。

---

## 5. 算法可视化：像素动画演示

- **主题**：「像素探险家」在 8-bit 世界寻找“最小起点”。  
- **核心演示**：  
  1. 屏幕顶部显示数字条（0~n），像素方块代表每个数。  
  2. 当遍历到 m 时，m 方块闪黄光，其最大质因子 p 方块闪红光，公式箭头从 m 指向 m-p+1。  
  3. 区间 [n-p_max+1, n] 用彩虹边框高亮，逐格移动。  
  4. 找到更小的 ans 时播放“叮”胜利音效，像素星星庆祝。  
- **交互**：  
  - 步进/自动按钮；速度滑块；重置即回到 n。  
  - 左下角实时显示当前 m、maxp[m]、ans。  

---

## 6. 拓展练习与相似问题思考

- **通用思路迁移**：  
  1. 多次“进位”类操作：时间片调度、任务批量提交。  
  2. 逆向区间查询：密码学倒推、资源分配最小起点。  
  3. 线性筛多合一：欧拉函数、莫比乌斯函数、约数个数。

- **洛谷推荐**：  
  1. **P3383** 【线性筛素数】—— 模板巩固。  
  2. **P4718** 【Pollard-Rho】—— 大数质因数分解实战。  
  3. **P1447** 【能量采集】—— 约数与最大质因子综合应用。

---

## 7. 学习心得与经验分享

- **ChrysanthBlossom** 提醒：线性筛时注意 `np[i*j] = max(np[i*j], j)` 的更新顺序，否则可能漏掉大质因子。  
- **zhangbo1000** 强调：答案初值用 `INT_MAX` 足够，但加法场景需用 `LLONG_MAX` 防溢出。  

---

> 本次「选素数」之旅到此结束！掌握“逆向区间 + 线性筛”后，你已拥有破解同类数论题的利刃。继续加油，下一场算法探险见！

---
处理用时：83.46秒
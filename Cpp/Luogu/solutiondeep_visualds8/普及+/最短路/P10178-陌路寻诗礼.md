# 题目信息

# 陌路寻诗礼

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/pkwo5ogg.png)

作为 luogu 网红的帆巨，有非常多狂热的粉丝，而我们的帆巨也很喜欢面基，寻找遍布大江南北的粉丝们。




## 题目描述

帆巨所在的家乡的地图是一张有 $n$ 个节点 $m$ 条有向道路的有向图，每个节点都是一个城市，而帆巨所在的城市是 $1$ 号城市，并且 $1$ 号城市总是可以通过若干道路到达其他任何城市。

第 $i$ 条道路从 $x_i$ 号城市出发到达 $y_i$ 号城市，长度为 $z_i$。

帆帆现在要从他的 $1$ 号城市前往各个城市面基。

精通 spfa 算法的帆帆在面基的过程中自然会按照长度和最短的路径去其他城市。

但是帆帆有选择困难症，他希望从 $1$ 号城市到达每一座城市的最短路径都是唯一的，所以他决定施加魔法，改变所有道路的长度，具体地：

帆巨施加魔法后，对于每一条道路的长度，都可以 **独立地** 将其变成一个 $[1,k]$ 范围内的整数，其中 $k$ 是帆巨的魔法等级。

但帆巨所在的世界的地图和他的魔法等级一直在变，总共会变 $T$ 次，所以他希望你对 $T$ 次询问都给出一种构造方法使得帆巨不会纠结或者报告无解。



## 说明/提示

### 【样例解释】

对于第一组数据，$1$ 号点到达每个点的路径都是唯一，自然无论怎么设置边权，最短路都是唯一的。

对于第二组数据，因为 $k=1$，所以两条边的边权都只能设置为 $1$。$1$ 号点到 $2$ 号点的最短路长度为 $1$，走两条边都可以，所以不是唯一的。

### 【数据范围】

本题采用捆绑测试。

对于 $20\%$ 的数据，$n,m\leq 5$。

对于另外 $20\%$ 的数据，$k=1$。

对于另外 $20\%$ 的数据，$m=n-1$。

对于另外 $20\%$ 的数据，$k=10^9$。

对于 $100\%$ 的数据，$n\ge 1$，$m\ge 0$，$1\le \sum n,\sum m\leq 3\times 10^5$，$1\leq k \leq 10^9$，$1\le x_i,y_i\le n$。

## 样例 #1

### 输入

```
2
3 2 3
1 2
2 3
2 2 1
1 2
1 2```

### 输出

```
Yes
1 2
No```

# AI分析结果

💡 洛语云笺的C++算法解析：**陌路寻诗礼** 深入学习指南 💡

> 今天我们来一起分析「陌路寻诗礼」这道图论构造题。它的核心挑战是：  
> **如何在给定的有向图中，为每条边重新赋予 1~k 的整数权值，使得从 1 号城市到所有其它城市的最短路恰好只有一条？**  
> 算法标签：`构造`、`最短路`、`BFS / Dijkstra`、`贪心`

---

## 1. 题目解读与策略初探

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**  
   “让 1 到所有点的最短路**唯一**” → 需要**计数最短路**并**构造**边权。
2. **线索2 (问题约束)**  
   边权必须 ∈ [1,k] 且**独立可调** → 构造空间巨大，但 k=1 时**唯一方案**。
3. **线索3 (数据规模)**  
   ∑n,∑m ≤ 3×10⁵ → 需要 O(n+m) 或 O(m log n) 的算法，暴力枚举 2^m 不可行。

### 🧠 思维链构建：从线索到策略
> 1. 最短路唯一 ⇔ 对于任意两点 u→v，不存在两条长度相同且都等于最短距离的路径。  
> 2. 边权可独立修改 → 可把“冲突”的边权拉大，使其无法与最短路同长。  
> 3. 于是出现两条主流构造思路：  
>    - **BFS 树法**：k≥2 时，把树边设 1，非树边设 k，天然拉大差距。  
>    - **在线调整法**：先全设 1，遇到同长路径就把“肇事边”权值++，直至 >k 判无解。

---

## 2. 精选优质题解参考

| 作者 | 核心亮点 | 星级 |
|---|---|---|
| CleverRaccoon | **在线调整法**简洁：Dijkstra 时若发现同长路径，就 `ans[id]++`，最后判 `max(ans)≤k` 即可。代码与模板只差几行。 | ★★★★★ |
| 云浅知处 | **BFS 树法** + 严谨分类：k≥2 直接 Yes；k=1 时跑一次最短路计数即可。思路清晰、代码短。 | ★★★★☆ |
| MoonCake2011 | 同样采用**在线调整**，但在松弛时按差值 p 直接算出新权值（p+1 或 p-1），避免随机，保证确定性。 | ★★★★☆ |
| Sternenlicht | **BFS 树法**的另一种写法：BFS 时把树边标 1，冲突边标 2；k=1 时若出现 2 则无解。实现直观。 | ★★★★☆ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：BFS 树法）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 构造思路** | k≥2 时，以 1 为源点做 BFS/DFS 得到最短路径树；树边赋 1，其余赋 k。这样树外边长度 ≥ k+1 > 树内路径长度，保证唯一。 | 把“唯一”转化为“边权差距足够大”。 |
| **2. k=1 特判** | 此时所有边权只能是 1。跑一次最短路计数，若存在某点计数 >1 则直接 `No`。 | 计数最短路模板：Dijkstra 或 BFS 均可。 |
| **3. 复杂度** | 两次 BFS/最短路：O(n+m)。 | 线性可过 3×10⁵。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
|---|---|---|---|---|
| **暴力枚举** | 枚举每条边权 1/k 或 1~k，再验证 | 思路直接 | O(2^m) 或 O(k^m) 爆炸 | 仅 n≤5 |
| **BFS 树法** | 树边 1，其余 k | 线性构造，简洁 | k=1 需额外计数 | 100% |
| **在线调整法** | 全设 1，遇冲突边权++ | 与 Dijkstra 同步完成 | 需维护额外数组 | 100% |

---

## 4. C++核心代码实现赏析

### 通用核心实现（BFS 树法）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e5 + 10;
vector<pair<int,int>> g[N];
int dis[N], ans[N];          // ans[i] = 第 i 条边的权值
bool vis[N], inTree[N];      // inTree[i] 是否在最短路树中

void solve() {
    int n, m, k;  cin >> n >> m >> k;
    for (int i = 1; i <= n; ++i) g[i].clear(), dis[i] = -1, vis[i] = 0;
    fill(ans + 1, ans + m + 1, 1);
    fill(inTree + 1, inTree + m + 1, 0);

    vector<tuple<int,int,int>> edges;
    for (int i = 1, u, v; i <= m; ++i) {
        cin >> u >> v;
        g[u].emplace_back(v, i);
        edges.emplace_back(u, v, i);
    }

    // BFS 建最短路径树
    queue<int> q; q.push(1); dis[1] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (auto [v, id] : g[u]) {
            if (dis[v] == -1) {
                dis[v] = dis[u] + 1;
                inTree[id] = true;
                q.push(v);
            }
        }
    }

    // 构造
    for (int i = 1; i <= m; ++i) {
        if (!inTree[i]) ans[i] = k;   // 非树边
    }

    // 特判 k=1
    if (k == 1) {
        // 再次 BFS 计数最短路
        vector<long long> cnt(n + 1, 0);
        cnt[1] = 1;
        queue<int> q2; q2.push(1);
        fill(vis + 1, vis + n + 1, 0); vis[1] = 1;
        while (!q2.empty()) {
            int u = q2.front(); q2.pop();
            for (auto [v, id] : g[u]) {
                if (!vis[v]) {
                    vis[v] = 1;
                    cnt[v] = cnt[u];
                    q2.push(v);
                } else if (dis[v] == dis[u] + 1) {
                    cnt[v] += cnt[u];
                    if (cnt[v] > 1) { cout << "No\n"; return; }
                }
            }
        }
    }

    cout << "Yes\n";
    for (int i = 1; i <= m; ++i) cout << ans[i] << " \n"[i == m];
}
```

### 代码片段赏析
- **CleverRaccoon 在线调整片段**  
  ```cpp
  else if(dis[v]==dis[u]+1){
      mx=max(mx,++ans[id]);   // 冲突时直接++
  }
  ```
  → 简洁地把“冲突计数”与 Dijkstra 融合，最后 `mx<=k` 即可。

- **云浅知处 k=1 计数片段**  
  ```cpp
  if (d[y] != -1 && d[y] == d[x] + 1) tf = true;
  ```
  → BFS 时一旦发现“并列”最短路立即打标记，无需额外数组。

---

## 5. 算法可视化：像素动画演示

**主题**：**“像素探险家的最短路径之旅”**

| 设计要点 | 像素化实现 |
|---|---|
| **场景** | 8×8 像素城市网格，1 号城为绿色像素小房子，其余为灰色方块。 |
| **边权** | 用颜色深浅表示 1~k，1 最亮，k 最暗。 |
| **BFS 树生成** | 像素“树苗”从 1 号城向外生长，每连一条树边，像素树苗变长一格并闪烁。 |
| **冲突检测** | 若出现两条同长路径，像素箭头碰撞产生“⚡”特效，并把肇事边变红 → 随后变深（权值++）。 |
| **控制面板** | 8-bit 按钮：▶ 自动演示 / ⏸ 暂停 / ↻ 重置 / 速度滑块（1~5 倍速）。 |
| **音效** | 树边生长“叮”，冲突“哐”，最终成功“胜利音”，失败“哔——”。 |

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**  
- **最短路径树思想**：不仅用于构造，也常用于“最小生成树与最短路结合”的题。  
- **最短路计数**：网络流、概率 DP 中频繁出现。

**洛谷推荐**
1. **P1144** 最短路计数  
   🗣️ 巩固 k=1 场景下的计数技巧。
2. **P4779** 单源最短路径（标准版）  
   🗣️ 练习 Dijkstra + 堆优化模板。
3. **P1529** 回家（最短路径树 + 构造）  
   🗣️ 体会“树边 1，非树边 ∞”的构造思想。

---

## 7. 学习心得与经验分享

- **CleverRaccoon** 提醒：  
  > “代码几乎就是 dijkstra 板子 + 三行修改，重点在于‘冲突即++’的贪心正确性证明。”  
  启示：遇到构造题，先大胆猜贪心，再尝试证明。

- **MoonCake2011** 提醒：  
  > “当 k=1 时，最短路径唯一 ⇔ 计数为 1，直接跑最短路计数即可，无需复杂构造。”  
  启示：充分利用数据范围给出的“边界条件”可极大简化代码。

---

<conclusion>
今天我们从“线索侦探”到“像素动画”，完整拆解了“陌路寻诗礼”的构造思路。记住：  
- **k≥2 → 最短路树 + 拉大差距**  
- **k=1 → 最短路计数唯一性**  
下次遇到构造类图论题，先想想能否用“树”或“计数”把问题降维！  
继续加油，像素探险家们！💪
</conclusion>

---
处理用时：73.23秒
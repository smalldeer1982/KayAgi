# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：导弹拦截 深入学习指南 💡

今天我们来一起分析“导弹拦截”这道经典 NOIP 题。它不仅考察了**最长单调子序列**，更通过“最少拦截系统”把**Dilworth 定理**带进了中学竞赛。下面，让我们像侦探一样拆解问题，再像工程师一样优化代码！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
“在高度不增的约束下，如何拦截最多导弹？又要用最少系统拦截全部？”  
→ 第一问是**最长不上升子序列（LNDS）**；第二问是**最少不上升链覆盖**，即 Dilworth 定理的对偶形式。

✨ **核心算法标签**  
`动态规划` `贪心+二分` `Dilworth 定理`

🗣️ **思路概览**  
1. 朴素 O(n²) DP：dp[i] 表示以第 i 枚导弹结尾的最长不上升子序列长度。  
2. O(n log n) 优化：用单调数组 + 二分替代内层循环。  
3. 第二问转化：根据 Dilworth 定理，最少不上升链数 = 最长上升子序列（LIS）长度。  
4. 终极优化：两段代码几乎对称，仅比较符号不同。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现内容 | 指向算法 |
|---|---|---|
| 1. 目标：拦截最多 | “最长”+“不上升” | 最长不上升子序列 |
| 2. 约束：系统高度单调不增 | 子序列性质 | DP 或 贪心+二分 |
| 3. 目标：最少系统 | “最少划分” | Dilworth 定理 → LIS |
| 4. 数据范围：1e5 | O(n log n) 可行 | 二分优化 |

### 🧠 思维链构建：从线索到策略
> 1. 看到“最长”→想到 DP；  
> 2. 看到“不上升”→想到单调性；  
> 3. 看到“最少系统”→想到链覆盖→Dilworth；  
> 4. 看到 1e5 → 必须 O(n log n)！  
> **结论**：两段单调数组 + 二分，分别求 LNDS 与 LIS，即可满分。

---

## 2. 精选优质题解参考

**题解一：离散小波变换°（赞：674）**  
亮点：  
- 用 `f[i]` 表示“长度为 i 的不上升子序列的最大末尾值”，严格证明其单调性，并给出二分细节。  
- 第二问直接利用 Dilworth 定理，代码与第一问对称。  
- 图文结合，数学推导清晰。

**题解二：STA_Morlin（赞：195）**  
亮点：  
- 把“贪心+二分”讲成故事：导弹排队入栈，栈单调不升；若塞不下就替换“最浪费”的元素。  
- 用 `upper_bound(..., greater<int>())` 一行代码完成替换，C++ STL 技巧满分。  
- 手写 Dilworth 通俗证明，适合中学生理解。

**题解三：Otue（赞：175）**  
亮点：  
- 先用朴素贪心讲思路，再逐步优化到二分，展现“从能做”到“做好”的完整路径。  
- 强调“两段代码仅符号不同”，帮助记忆。  

（其余 ≥4 星题解同样优秀，但受限于篇幅，此处精选三份。）

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
| 关键点 | 分析与学习笔记 |
|---|---|
| **1. 单调数组定义** | 设 `g[len]` 表示长度为 len 的不上升子序列的“最大末尾值”。<br>💡 笔记：保证 `g` 单调不升即可二分。 |
| **2. 二分位置** | 若当前导弹 ≤ `g[len]`，则直接 `++len`；否则在 `g` 中找第一个 `<` 当前导弹的位置替换。<br>💡 笔记：`upper_bound(g+1,g+len+1,x,greater<int>())` 一行搞定。 |
| **3. Dilworth 定理** | 最少不上升链数 = 最长上升子序列长度。<br>💡 笔记：把比较符号取反即可复用第一问代码。 |

### ⚔️ 策略竞技场：不同解法的对比
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **O(n²) DP** | 双重循环求最长 | 思路直观 | 1e5 必 TLE | n ≤ 3e3 |
| **贪心+二分** | 单调数组维护末尾 | O(n log n) 稳过 | 需要理解单调性 | 标准解法 |
| **线段树/树状数组** | 值域上求前缀max | 通用、可扩展 | 常数大，难写 | 需要区间统计 |

### ✨ 优化之旅：从“能做”到“做好”
1. 起点：朴素 DP 两重循环。  
2. 瓶颈：内层循环找最大 dp[j] 耗时。  
3. 钥匙：发现 `g[len]` 单调 ⇒ 可用二分。  
4. 升华：两段代码仅符号不同，体现数学对称美。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;
int n, a[N], g[N], len;

int main() {
    while (cin >> a[++n]); --n;
    // 第一问：最长不上升子序列
    len = 0;
    for (int i = 1; i <= n; ++i) {
        if (!len || a[i] <= g[len]) g[++len] = a[i];
        else *upper_bound(g + 1, g + len + 1, a[i], greater<int>()) = a[i];
    }
    cout << len << '\n';

    // 第二问：最长上升子序列
    len = 0;
    for (int i = 1; i <= n; ++i) {
        if (!len || a[i] > g[len]) g[++len] = a[i];
        else *lower_bound(g + 1, g + len + 1, a[i]) = a[i];
    }
    cout << len << '\n';
    return 0;
}
```
**代码解读概要**：  
- 用数组 `g` 充当单调栈/单调数组。  
- 第一问用 `greater<int>()` 实现“不升”二分；第二问默认升序。  
- 两行核心代码几乎镜像，完美体现 Dilworth 定理。

### 题解片段赏析
**离散小波变换° 片段**  
```cpp
int l=0,r=t+1;          // 闭开二分 [l, r)
while(r-l>1){
    int m=(l+r)>>1;
    if(F[m]>=H[i]) l=m; else r=m;
}
```
💡 学习笔记：闭开区间二分模板，避免边界错误。

**STA_Morlin 片段**  
```cpp
*upper_bound(l+1, l+r1+1, b[i], greater<int>()) = b[i];
```
💡 学习笔记：利用返回值直接修改，STL 一行流。

---

## 5. 算法可视化：像素动画演示

**主题**：8-bit “导弹防御塔”  
**核心内容**：  
- 导弹以像素方块从右向左飞来；  
- 绿色炮塔数组 `g[]` 纵向排列，高度即值；  
- 每枚导弹二分定位后，炮塔高度闪红→更新→播放“叮”音效；  
- 成功拦截一排导弹后，像素烟花 + “Level Up”音效；  
- 控制面板：步进/自动/速度滑块，可实时查看 `g[]` 变化。

**实现要点**  
- Canvas 绘制：导弹 = 8×8 方块，炮塔 = 竖条。  
- 二分过程：黄色扫描线左右移动，最终停在插入/替换位置。  
- 音效：Web Audio 生成 8-bit “pew”、“coin”。  
- 关卡化：每处理 10 枚导弹为 1 关，显示得分。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **最长××子序列**模型：不下降、上升、下降、波动……  
- **Dilworth 定理**：  
  1. 任务调度：最少机器数 = 最长冲突链。  
  2. 区间覆盖：最少区间划分 = 最大点独立集。  
  3. 装箱问题：最少箱子 = 最长递增重量链。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P1439 【模板】最长上升子序列 | 熟练掌握 n log n LIS 模板 |
| P2782 友好城市 | 把二维偏序降到 LIS |
| P1976 鸡蛋饼 | Dilworth 定理 + 二分图匹配 |

---

## 7. 学习心得与经验分享（摘录）

> **来自 STA_Morlin**：“我在第一次写二分边界时把 `upper_bound` 的 `greater<int>()` 漏掉，导致 WA 了一整页……调试时把 `g[]` 打印出来才发现单调性反了。”  
**洛语云笺点评**：打印中间数组是定位单调性错误的利器，尤其在 STL 与自定义比较器结合时。

---

<conclusion>  
从 O(n²) 到 O(n log n)，从最长子序列到 Dilworth 定理，“导弹拦截”用一道题串起了算法竞赛的两块基石：**单调性优化**与**偏序思想**。希望大家把这套“单调数组 + 二分”模板刻进肌肉记忆，下次遇见“最长××”或“最少划分”时，也能像今天一样一击即中！💪

---
处理用时：74.26秒
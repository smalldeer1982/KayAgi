# 题目信息

# [JOI 2024 Final] 建设工程 2 / Construction Project 2

## 题目描述

JOI 国有 $N$ 个火车站，编号从 $1$ 到 $N$。另外，JOI 国有 $M$ 条双向铁路线，编号从 $1$ 到 $M$。铁路线 $i\ (1 \leq i \leq M)$ 连接了火车站 $A_{i}$ 和火车站 $B_{i}$，从一个站到另一个站需要花费 $C_i$ 分钟。

你是 JOI 国的部长，决定按照以下方式新建一条铁路线：

选择两个整数 $u, v\ (1 \leq u<v \leq N)$，在火车站 $u$ 和火车站 $v$ 之间建设一条双向铁路线，从一个站到另一个站需要花费 $L$ 分钟。注意，即使已经有一条连接火车站 $u$ 和火车站 $v$ 的铁路线也可以建设。

如果你建设这条铁路线后，可以花费不超过 $K$ 分钟从火车站 $S$ 到火车站 $T$，国王就会高兴。我们不考虑换乘时间和等待时间。

你有 $\frac{N(N-1)}{2}$ 种选择两个整数 $u, v$ 的方法，你想知道其中有多少种方法会让国王高兴。

给定火车站和铁路线以及国王的要求的信息，编写一个程序，求出其中有多少种选择整数的方法会让国王高兴。

## 说明/提示

对于所有输入数据，满足：

- $2 \leq N \leq 2\times 10^5$
- $1 \leq M \leq 2\times 10^5$
- $1 \leq S<T \leq N$
- $1 \leq L \leq 10^{9}$
- $1 \leq K \leq 10^{15}$
- $1 \leq A_{i}<B_{i} \leq N\ (1 \leq i \leq M)$
- $(A_{i}, B_{i}) \neq (A_{j}, B_{j})\ (1 \leq i<j \leq M)$
- $1 \leq C_{i} \leq 10^{9}\ (1 \leq i \leq M)$

详细子任务附加限制及分值如下表所示。

|子任务|	附加限制|	分值|
|:-:|:-:|:-:|
|1|	$L=1, K=2, C_{i}=1\ (1 \leq i \leq M)$|	8
|2|	$N \leq 50, M \leq 50$|	16
|3|	$N \leq 3000, M \leq 3000$|	29
|4|	无附加限制|	47

## 样例 #1

### 输入

```
7 8
6 7 1 2
1 2 1
1 6 1
2 3 1
2 4 1
3 5 1
3 7 1
4 5 1
5 6 1```

### 输出

```
4```

## 样例 #2

### 输入

```
3 2
1 3 1 2
1 2 1
2 3 1```

### 输出

```
3```

## 样例 #3

### 输入

```
6 4
2 5 1000000000 1
1 2 1000000000
2 3 1000000000
2 4 1000000000
5 6 1000000000```

### 输出

```
0```

## 样例 #4

### 输入

```
18 21
4 8 678730772 3000000062
5 13 805281073
8 17 80983648
3 8 996533440
10 16 514277428
2 5 57914340
6 11 966149890
8 12 532734310
2 9 188599710
2 3 966306014
12 16 656457780
16 18 662633078
1 15 698078877
2 8 665665772
2 6 652261981
14 15 712798281
7 13 571169114
13 14 860543313
6 7 454251187
9 14 293590683
6 14 959532841
3 11 591245645```

### 输出

```
16```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：建设工程 2 深入学习指南 💡

> 今天，我们要化身“铁路规划大师”，帮国王找出能让他在规定时间内从 S 抵达 T 的所有新线路方案。这不仅是图论与最短路的大练兵，更是一次“如何优雅地把枚举降到可接受复杂度”的思维之旅。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在 N ≤ 2×10⁵、M ≤ 2×10⁵ 的图上，枚举所有可能的新边 (u,v) 并快速判断：  
**是否满足 dis(S,u) + L + dis(v,T) ≤ K**。

✨ **核心算法标签**：最短路(Dijkstra)、前缀和/二分、枚举优化

🗣️ **初步分析**  
1.  暴力思路：对每对 (u,v) 跑最短路，O(N² log N) → 直接 TLE。  
2.  关键洞察：  
    - 把“枚举 (u,v)”拆成“枚举 u + 统计满足条件的 v”，即可把平方级降到 **O(N log N)**。  
    - 需要预先算出 **dis(S,·)** 与 **dis(·,T)** 两组最短路。  
3.  **最优策略**：  
    - 两次 Dijkstra 求出 disS、disT。  
    - 特判 disS[T] ≤ K（所有方案合法）。  
    - 将 disT 数组排序后，对每个 u 二分统计满足 disS[u] + L + disT[v] ≤ K 的 v 数量，累加即可。  

---

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**：“统计满足条件的**无序二元组**数量”——典型“枚举+计数”场景，暗示需要优化枚举。  
2.  **线索2 (问题约束)**：数据范围 N≤2×10⁵ 直接封杀 O(N²)。  
3.  **线索3 (最短路模型)**：图上任意两点最短路 → Dijkstra 是首选。  

### 🧠 思维链构建：从线索到策略
> 1. 先算“不建新线”时的 dis(S,T)。若 ≤K，直接输出 C(N,2)。  
> 2. 否则，把“枚举 (u,v)”拆成“枚举 u + 统计 v”——利用最短路可加性 **dis(S,u)+L+dis(v,T)≤K** 可重排为 **dis(v,T) ≤ K-L-dis(S,u)**。  
> 3. 于是只需对 disT 数组排序，二分即可 O(log N) 统计。  
> 4. 复杂度：2×Dijkstra O(M log N) + 排序 O(N log N) + 二分 O(N log N) → **O((M+N) log N)**，稳稳通过。  

---

## 2. 精选优质题解参考

### 题解一：Perta (赞：21)
* **点评**：思路极度精炼，一句话把“枚举+二分”讲透；对“不会算重”给出简洁证明，值得全文背诵。  
* **亮点**：  
  - 用 `a_i = dis(T,i)` 命名，统一符号，便于排序。  
  - 证明“无解重”用反证法，逻辑清晰。  

### 题解二：kkxacj (赞：1)
* **点评**：代码完整、注释清晰，用 **unordered_map + 前缀和** 替代二分，同样 O(N log N)；展示了 STL 的实用技巧。  
* **亮点**：  
  - 读入输出用自写快读，竞赛友好。  
  - 用 `priority_queue<pair<int,int>>` 实现 Dijkstra，标准且高效。  

### 题解三：沉石鱼惊旋 (赞：1)
* **点评**：不仅给出算法，还补充 **数学证明** 防止算重；适合想彻底理解正确性的同学。  
* **亮点**：  
  - 将“重算”条件写成不等式组，严谨推导矛盾。  

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤 (最优解法)
1.  **关键点1：两次最短路**  
   - 分析：分别以 S、T 为源点跑 Dijkstra，得到 `disS[1..N]` 与 `disT[1..N]`。  
   - 💡 **学习笔记**：**双向最短路** 是解决“涉及两端点”问题的常见套路。

2.  **关键点2：枚举+二分优化**  
   - 分析：把二元组拆成一元组 + 前缀统计；排序后二分即可。  
   - 💡 **学习笔记**：**“排序+二分”** 是 O(N²) → O(N log N) 的万能降维打击。

3.  **关键点3：边界与特判**  
   - 分析：  
     - 若 `disS[T] ≤ K`，所有 C(N,2) 都合法。  
     - 注意 L 可能很大，需用 `long long`。  
   - 💡 **学习笔记**：特判边界是防 FST 的最后一道保险。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| 暴力枚举 | 对每对 (u,v) 跑最短路 | 思路直观 | O(N² log N) 必炸 | 0% |
| 枚举+二分 | 拆二元组为二分统计 | 简洁高效 | 需两次最短路 | 100% |
| 双端 BFS | 尝试双向搜索 | 常数小 | 仍需 N² 枚举 | 不适用 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
* **说明**：综合 Perta 与 kkxacj 写法，提供 **最简洁可编译** 版本。  
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int64 INF = 1e18;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int N, M, S, T, L; int64 K;
    if (!(cin >> N >> M >> S >> T >> L >> K)) return 0;

    vector<vector<pair<int,int>>> g(N + 1);
    for (int i = 0; i < M; ++i) {
        int a, b, c; cin >> a >> b >> c;
        g[a].emplace_back(b, c);
        g[b].emplace_back(a, c);
    }

    auto dijkstra = [&](int s, vector<int64>& d) {
        d.assign(N + 1, INF);
        priority_queue<pair<int64,int>, vector<pair<int64,int>>, greater<>> pq;
        d[s] = 0; pq.emplace(0, s);
        while (!pq.empty()) {
            auto [dist, u] = pq.top(); pq.pop();
            if (dist > d[u]) continue;
            for (auto [v, w] : g[u]) {
                if (d[v] > d[u] + w) {
                    d[v] = d[u] + w;
                    pq.emplace(d[v], v);
                }
            }
        }
    };

    vector<int64> ds(N + 1), dt(N + 1);
    dijkstra(S, ds); dijkstra(T, dt);

    if (ds[T] <= K) {
        cout << 1LL * N * (N - 1) / 2 << '\n';
        return 0;
    }

    vector<int64> arr(dt.begin() + 1, dt.end());
    sort(arr.begin(), arr.end());

    int64 ans = 0;
    for (int u = 1; u <= N; ++u) {
        int64 limit = K - L - ds[u];
        if (limit < 0) continue;
        int cnt = upper_bound(arr.begin(), arr.end(), limit) - arr.begin();
        ans += cnt;
    }
    cout << ans << '\n';
    return 0;
}
```
* **代码解读概要**：  
  - 两次 Dijkstra 求 `ds`, `dt`。  
  - 特判后，把 `dt` 数组排序，对每个 u 二分统计合法 v。  

---

## 5. 算法可视化：像素动画演示

* **主题**：像素工程师在“铁路网”上铺设新线路  
* **场景**：  
  1. 8×8 像素网格代表车站，绿色像素=车站，灰色像素=已有线路。  
  2. 两次 Dijkstra：  
     - 像素小人从 S 出发，沿最短路径点亮像素，同时播放“叮”音效。  
     - 再换色从 T 反向跑最短路。  
  3. 枚举阶段：  
     - 右侧实时柱状图显示 `dt` 排序后的值。  
     - 每选一个 u，红色竖线移动至 `K-L-ds[u]`，下方计数器滚动增加。  
* **控制面板**：开始/暂停、单步、速度滑块；右上角实时显示当前合法对数。  
* **游戏化**：每统计完一个 u，播放“过关”音效，累计“金币”=合法对数，增强成就感。

---

## 6. 拓展练习与相似问题思考

* **通用套路**：  
  1. 需要“枚举 + 统计” → 拆二元组 + 排序/前缀和/树状数组。  
  2. 多次最短路 → 双向或多源最短路。  
* **洛谷推荐**：  
  1. P4779 【模板】单源最短路径（加强版）—— 练习 Dijkstra 堆优化。  
  2. P1525 关押罪犯 —— 二分 + 最短路/二分图建模。  
  3. P2888 道路修建 —— 枚举边 + 最短路验证。  

---

## 7. 学习心得与经验分享

> **来自 kkxacj**：  
> “我在第一次提交时忘了特判 `dis(S,T) ≤ K`，结果样例 2 没过。后来把特判加上就 AC 了。”  
> **洛语云笺点评**：边界特判虽小，却是决定 AC 的关键。养成“先想边界”的习惯，能少走很多弯路。

---

<conclusion>
今天，我们从最短路到枚举优化，完成了一次“大工程”。记住：  
- **拆二元组 + 排序/二分** 是平方级降维的利器；  
- **两次最短路** 是解决“两端点”问题的经典套路；  
- **边界特判** 永远是最后一道保险。  
继续加油，下次再一起征服更多算法高峰！💪
</conclusion>

---
处理用时：67.85秒
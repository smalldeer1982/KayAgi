# 题目信息

# [NOIP 2009 提高组] Hankson 的趣味题

## 题目描述

Hanks 博士是 BT（Bio-Tech，生物技术) 领域的知名专家，他的儿子名叫 Hankson。现在，刚刚放学回家的 Hankson 正在思考一个有趣的问题。

今天在课堂上，老师讲解了如何求两个正整数 $c_1$ 和 $c_2$ 的最大公约数和最小公倍数。现在 Hankson 认为自己已经熟练地掌握了这些知识，他开始思考一个“求公约数”和“求公倍数”之类问题的“逆问题”，这个问题是这样的：已知正整数 $a_0,a_1,b_0,b_1$，设某未知正整数 $x$ 满足：

1. $x$ 和 $a_0$ 的最大公约数是 $a_1$；

2. $x$ 和 $b_0$ 的最小公倍数是 $b_1$。

Hankson 的“逆问题”就是求出满足条件的正整数 $x$。但稍加思索之后，他发现这样的 $x$ 并不唯一，甚至可能不存在。因此他转而开始考虑如何求解满足条件的 $x$ 的个数。请你帮助他编程求解这个问题。


## 说明/提示

**【样例解释】**

第一组输入数据，$x$ 可以是 $9,18,36,72,144,288$，共有 $6$ 个。

第二组输入数据，$x$ 可以是 $48,1776$，共有 $2$ 个。

**【数据范围】**

- 对于 $50\%$ 的数据，保证有 $1\leq a_0,a_1,b_0,b_1 \leq 10000$ 且 $n \leq 100$。
- 对于 $100\%$ 的数据，保证有 $1 \leq a_0,a_1,b_0,b_1 \leq 2 \times 10^9$ 且 $n≤2000$。

NOIP 2009 提高组 第二题


## 样例 #1

### 输入

```
2 
41 1 96 288 
95 1 37 1776 ```

### 输出

```
6 
2```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Hankson 的趣味题 深入学习指南 💡

> 各位探险家，欢迎来到数论王国！今天我们要破解的是 NOIP 2009 的一道经典“逆问题”——从最大公约数、最小公倍数反推未知数 x 的个数。  
> 这道题表面看是数学，其实暗藏“枚举 + 剪枝 + 数论变换”的三重关卡。跟着洛语云笺一起，把复杂条件拆成像素化的线索，找到那把“√b₁”钥匙！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
把“两个条件”翻译成对 **x 的取值限制**，再高效统计合法 x 的个数。

✨ **核心算法标签**  
数论（质因数分解）、枚举（因子枚举）、剪枝（√b₁ 上界）

🗣️ **初步分析**  
> 1. 条件 2 告诉我们：**x 必须是 b₁ 的因子**（因为 lcm(x,b₀)=b₁）。  
> 2. 条件 1 告诉我们：**x 必须是 a₁ 的倍数**（因为 gcd(x,a₀)=a₁）。  
> 3. 因此，**合法 x 的取值范围被压缩到 [a₁, b₁] 且同时是 b₁ 的因子**。  
> 4. 枚举 b₁ 的所有因子，对每个因子 x 检查两个条件即可。  
> 5. 枚举量由 O(b₁) 剪枝到 O(√b₁)——这就是“√b₁ 钥匙”！

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 数学翻译 |
|---|---|---|
| **线索 1：条件 2** | “x 和 b₀ 的最小公倍数是 b₁” ⇒ x 必须是 b₁ 的因子 | `x \| b₁` |
| **线索 2：条件 1** | “x 和 a₀ 的最大公约数是 a₁” ⇒ x 必须是 a₁ 的倍数 | `a₁ \| x` |
| **线索 3：数据范围** | b₁ ≤ 2×10⁹，n ≤ 2000 ⇒ √b₁ ≈ 4.5×10⁴，总计算量 2000×4.5×10⁴ ≈ 9×10⁷，可过 | **√枚举可行** |

### 🧠 思维链构建：从线索到策略
> “把两条线索拼在一起：x 必须同时是 b₁ 的因子和 a₁ 的倍数。  
> 于是问题变成：在 b₁ 的所有因子中，有多少个满足 gcd(x,a₀)=a₁。  
> 枚举 b₁ 的因子只需 √b₁ 次，再用 gcd 检查即可。  
> 这就是 **√因子枚举 + gcd 验证** 的优雅路径！”

---

## 2. 精选优质题解参考

> 我综合了 20 份题解的清晰度、代码质量与思维深度，筛选出 3 份 **4★+** 代表，带你领略不同角度的解法之美。

### 题解一：zzlzk（468 赞）——“公式推导 + √因子枚举”
- **亮点**  
  用数学恒等式把两个条件转化为：`x` 必须是 b₁ 的因子且 gcd(x/a₁, a₀/a₁)=1 且 gcd(b₁/x, b₁/b₀)=1。  
  直接枚举 √b₁ 的因子，用 **两次 gcd 剪枝**，代码极短。
- **学习笔记**  
  “把复杂条件转成 gcd=1 的互质判断”是数论题常用技巧。

### 题解二：KesdiaelKen（103 赞）——“质因数指数法 + 优化”
- **亮点**  
  对 a₀,a₁,b₀,b₁ 做 **质因数分解**，按每个质因子指数分类讨论，把指数限制转成乘法原理，复杂度降到 O(√b₁ + log b₁)。
- **学习笔记**  
  当枚举因子仍显暴力时，**质因数分解 + 指数限制** 是更精细的数论武器。

### 题解三：zsq9（5 赞）——“最简 √枚举模板”
- **亮点**  
  直接枚举 √b₁ 的所有因子，用内置 gcd/lcm 判断，代码 20 行，清晰易背。
- **学习笔记**  
  对于 2×10⁹ 范围，**√枚举 + 标准 gcd** 已足够高效，无需过度优化。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：√因子枚举）

| 关键点 | 分析 & 技巧 | 💡 学习笔记 |
|---|---|---|
| **步骤 1：因子枚举** | 枚举 1…√b₁，若 `i | b₁` 则得到一对因子 (i, b₁/i) | 因子成对出现，枚举量减半 |
| **步骤 2：倍数剪枝** | 只保留 **i % a₁ == 0** 的因子（满足 a₁ \| x） | 提前过滤非法 x |
| **步骤 3：双条件验证** | 对每个候选 x 检查：<br>`gcd(x,a₀)==a₁ && lcm(x,b₀)==b₁` | gcd/lcm 均为 O(log n) |
| **步骤 4：平方特判** | 当 i*i==b₁ 时避免重复计数 | 细节决定 AC |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分 |
|---|---|---|---|---|
| **暴力枚举** | 1…b₁ 逐一验证 | 思路直观 | O(b₁) 超时 | 50 |
| **√因子枚举** | 只枚举因子 | O(√b₁ log b₁) 稳过 | 需细节处理 | 100 |
| **质因数指数法** | 分解后乘法原理 | 理论最快 | 代码长，易错 | 100 |

### ✨ 优化之旅：从“能做”到“做好”
> “最初我们想在 2×10⁹ 个数里找答案，发现会 TLE。  
> 但 **x 必须是 b₁ 的因子** 这一条件，把搜索空间压缩到 √b₁ ≈ 4.5×10⁴。  
> 再加上 **x 必须是 a₁ 的倍数**，又砍去一半。  
> 于是 **√枚举 + 两次 gcd** 就成了优雅的最优解！”

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：融合 zzlzk 公式推导与 zsq9 简洁枚举，易读高效。
- **完整核心代码**：
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
int gcd(int a,int b){return b?gcd(b,a%b):a;}
int lcm(int a,int b){return a/gcd(a,b)*b;}
int main(){
    int T; scanf("%d",&T);
    while(T--){
        int a0,a1,b0,b1,ans=0;
        scanf("%d%d%d%d",&a0,&a1,&b0,&b1);
        for(int x=1;x*x<=b1;++x){
            if(b1%x) continue;
            int y=b1/x;
            if(x%a1==0 && gcd(x,a0)==a1 && lcm(x,b0)==b1) ++ans;
            if(y!=x && y%a1==0 && gcd(y,a0)==a1 && lcm(y,b0)==b1) ++ans;
        }
        printf("%d\n",ans);
    }
    return 0;
}
```
- **代码解读概要**  
  先枚举 √b₁ 的因子，再用 gcd/lcm 验证双条件；平方因子特判避免重复。

### 题解代码片段赏析
| 来源 | 亮点片段 | 代码解读 | 学习笔记 |
|---|---|---|---|
| zzlzk | `if(x%a1==0 && gcd(x/a1,a0/a1)==1 && gcd(b1/x,b1/b0)==1)` | 把条件转成互质判断，减少 lcm 计算 | 数论恒等式妙用 |
| KesdiaelKen | `int l=cf(s,n);` `int q=cf(l,m);` | 用质因数分解函数 cf 去掉公共因子 | 质因数分解模板 |

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素探险家”在因子迷宫里寻宝**  
> 目标：直观看到 √枚举 + gcd 验证的全过程

### 像素化设计思路
- **场景**：8×8 像素网格，每个格子代表一个因子候选。  
- **角色**：红色像素“探险家”沿 √b₁ 路线移动，绿色像素“√门”标记因子对。  
- **音效**：  
  - 成功验证 → “叮”  
  - 非法因子 → “咚”  
- **交互**：  
  - 单步/自动按钮  
  - 速度滑块（1–10 fps）

### 关键帧示意
1. **初始化**：网格显示 1…√b₁，格子内写因子值。  
2. **枚举到因子 i**：格子高亮黄色，显示 `i | b₁ ?`  
3. **倍数剪枝**：若 `i % a₁ != 0`，格子变灰色并跳过。  
4. **双条件验证**：弹出两个像素对话框：  
   - gcd(x,a₀) 计算动画（辗转相除像素小人来回跑）  
   - lcm(x,b₀) 计算动画（像素小人把两堆方块对齐）  
5. **结果计数**：右上角像素计数器 +1，播放“叮”。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **因子枚举**：任何“x 必须是 n 的因子”类题（如 P3383 线性筛）  
- **gcd/lcm 性质**：P2568 求 gcd(a,b)=1 的对数  
- **√枚举剪枝**：P1217 回文质数、P2670 扫雷

### 洛谷推荐
1. **P1072**（本题）  
   先练熟 √因子枚举模板。
2. **P2568**  
   用 gcd 性质 + 欧拉函数，体验“互质”与“因子”的联动。
3. **P3383**  
   线性筛 + 因子枚举，巩固质因数分解技巧。

---

## 7. 学习心得与经验分享

> 摘录自作者皎月半洒花  
> “其实最后的操作跟 AlphaGo 动态学习信息有点异曲同工……当时写代码突然码力暴涨 2333。”  
> **洛语云笺点评**：在数论题中，把“枚举”与“性质”结合，往往能让复杂度骤降，这种“顿悟”正是算法学习的魅力！

---

<conclusion>
恭喜你，探险家！今天我们用 √b₁ 钥匙打开了 Hankson 趣味题的大门。  
记住：  
- **看到 lcm 先想因子**  
- **看到 gcd 先想倍数**  
- **√枚举是 2×10⁹ 范围内的万能剪刀**  
下次见，继续像素世界的算法冒险！

---
处理用时：85.99秒
# 题目信息

# 最短路计数

## 题目描述

给出一个 $N$ 个顶点 $M$ 条边的无向无权图，顶点编号为 $1\sim N$。问从顶点 $1$ 开始，到其他每个点的最短路有几条。


## 说明/提示

$1$ 到 $5$ 的最短路有 $4$ 条，分别为 $2$ 条 $1\to 2\to 4\to 5$ 和 $2$ 条 $1\to 3\to 4\to 5$（由于 $4\to 5$ 的边有 $2$ 条）。

对于 $20\%$ 的数据，$1\le N \le 100$；  
对于 $60\%$ 的数据，$1\le N \le 10^3$；  
对于 $100\%$ 的数据，$1\le N\le10^6$，$1\le M\le 2\times 10^6$。


## 样例 #1

### 输入

```
5 7
1 2
1 3
2 4
3 4
2 3
4 5
4 5
```

### 输出

```
1
1
1
2
4
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：最短路计数 深入学习指南 💡

> 欢迎来到洛语云笺的算法课堂！今天我们要攻克的是“最短路计数”这道题。别被“计数”二字吓到，其实它的本质就是**在找最短路径的同时，数一数有多少条这样的路径**。让我们一起拨开迷雾，看看有哪些巧妙的策略吧！

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在一张**无向无权图**中，从顶点1出发，计算出到所有其他顶点的**最短路径**共有多少条。  
✨ **核心算法标签**：BFS, 最短路算法 (Dijkstra/SPFA), 动态规划 (计数)

🗣️ **初步分析**：
这道题的核心在于“**边权为1**”。这个特性非常关键，它意味着：
1.  **BFS的天然优势**：由于边权相等，BFS第一次访问到一个节点时，所走的路径长度就是最短路径长度。这使得BFS成为解决此问题的最直观、最简洁的工具。
2.  **计数与更新同步**：无论使用BFS、Dijkstra还是SPFA，我们都可以在**松弛操作**（更新最短路径）的同时，巧妙地更新路径的计数。
3.  **引出核心算法**：可以把整个图想象成一个迷宫，我们要从起点1号房间出发，找到到每个房间的最短路线，并统计这些路线的数量。BFS就像一层层地向外“扩散”探索，每到达一个新房间，我们就记录下到达它的最短路径数量。

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**: "求从顶点1到其他每个点的**最短路有几条**"。这是一个典型的**最短路问题**，但附加了“计数”要求。
2.  **线索2 (问题约束/特性)**: "无向**无权**图"。这是决定性的线索！“无权”意味着所有边的长度都是1，这使得BFS成为寻找最短路径的首选，因为它天然按层遍历，第一次访问即为最短。
3.  **线索3 (数据规模)**: "N≤10^6, M≤2×10^6"。这个规模下，O(N+M)的BFS算法非常轻松，而O(M log N)的Dijkstra或O(kM)的SPFA也完全可行。

### 🧠 思维链构建：从线索到策略
> 好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1.  首先，【线索1：问题目标】告诉我们这是一个“最短路+计数”问题。
> 2.  接着，【线索2：问题特性】，“无向无权图”，给了我一个决定性的提示。对于无权图，BFS是最自然的选择。它的层级遍历特性，使得我们可以在第一次访问节点时，就确定其最短路径长度。
> 3.  最后，【线索3：数据规模】给了我们最终判决。N和M都是百万级，O(N+M)的BFS算法绝对是最优解。
> 4.  **结论**：综合以上，一个能够高效处理“无权图最短路计数”的算法，就是我们的目标。**BFS**（广度优先搜索）完美符合所有条件！我们可以在BFS的过程中，用一个数组来记录到达每个节点的最短路径数量。

---

## 2. 精选优质题解参考

> 我从众多题解中，为大家精心挑选了几份思路清晰、代码规范的优质参考。它们都殊途同归，指向了同一个核心：在遍历图的同时，动态地累加最短路径的数量。

**题解一：BFS 简洁优雅 (作者：岸芷汀兰)**
* **点评**：这份题解精准地抓住了“无权图”这一关键特性，直接采用BFS求解。其思路非常清晰：第一次访问节点时，路径长度即为最短，此时将父节点的方案数赋给当前节点；后续再次以相同最短长度访问该节点时，则将父节点的方案数累加到当前节点。代码实现简洁高效，是学习BFS计数问题的绝佳范例。

**题解二：Dijkstra 通用严谨 (作者：King丨帝御威)**
* **点评**：虽然BFS是此题的最优解，但使用Dijkstra算法同样正确且更具通用性。这份题解展示了如何在Dijkstra的框架下，优雅地融入计数逻辑：当发现一条更短的路径时，重置方案数；当发现一条等长的路径时，累加方案数。这对于理解带权图的最短路计数问题非常有帮助。

**题解三：SPFA 的通用性与陷阱 (作者：Utsuji_risshū)**
* **点评**：这份题解不仅给出了SPFA的解法，更重要的是，它深入剖析了SPFA在解决**带权图**最短路计数时可能遇到的陷阱（如重复计数问题），并给出了修正方案。这提醒我们，即使是看似“万能”的算法，也需要针对具体问题特性进行调整。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤 (最优解法剖析)
1.  **关键点1：如何同时计算最短路径和路径数量？**
    * **分析**：我们使用一个数组`d[i]`记录从起点1到节点i的最短距离，用另一个数组`ans[i]`记录这个最短距离对应的路径数量。
    * 💡 **学习笔记**：**“双数组联动”**是解决这类问题的核心技巧。`d`数组负责“找路”，`ans`数组负责“数路”。
2.  **关键点2：BFS的层级更新逻辑**
    * **分析**：从起点1开始BFS。对于当前节点`u`的每一个邻居`v`：
        1.  如果`v`未被访问过（`d[v]`为无穷大），则`d[v] = d[u] + 1`，此时`v`的最短路径必然经过`u`，所以`ans[v] = ans[u]`。将`v`加入队列。
        2.  如果`v`已被访问过，且`d[v] == d[u] + 1`，则说明我们找到了另一条到达`v`的最短路径，这条路径同样经过`u`，所以`ans[v] += ans[u]`。此时`v`已在队列中，无需再次入队。
    * 💡 **学习笔记**：**“首次赋值，再次累加”**是BFS计数的精髓。
3.  **关键点3：数据结构的选择**
    * **分析**：对于百万级节点和边，邻接表（链式前向星或`vector<vector<int>>`）是存储图的标准选择，其空间复杂度为O(N+M)，访问效率极高。
    * 💡 **学习笔记**：**“邻接表”**是处理大规模图的基石。

### ✨ 解题技巧总结
-   **技巧A (问题转化)**：将“计数”问题巧妙地融入到“最短路”的计算过程中，避免了二次遍历。
-   **技巧B (利用特性)**：充分利用“边权为1”的特性，将最短路问题简化为BFS，大幅降低了算法复杂度。
-   **技巧C (模块化设计)**：将图的构建、BFS遍历、结果输出等步骤封装成独立的函数，使代码结构清晰，易于调试。

### ⚔️ 策略竞技场：不同解法的对比分析
| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **BFS (最优)** | 利用无权图的特性，按层遍历，首次到达即为最短。 | 时间复杂度O(N+M)，空间复杂度O(N+M)，思路最简单，实现最简洁。 | 仅适用于**无权图**。 | 本题最佳，**100%** 分数。 |
| **Dijkstra (堆优化)** | 使用优先队列，每次取出当前距离起点最近的节点进行松弛。 | 通用性强，适用于**带权图**（边权非负）。 | 时间复杂度O(M log N)，比BFS略慢，且实现稍复杂。 | 适用于边权不同的最短路计数。本题可得**100%** 分数。 |
| **SPFA** | 队列优化的Bellman-Ford算法，对边进行松弛。 | 实现简单，平均情况下较快。 | 最坏时间复杂度O(NM)，容易被特殊数据卡掉。在带权图计数时，需要特殊处理以避免重复计数。 | 适用于一般图，但非最优。本题可得**100%** 分数。 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点：暴力DFS/BFS**  
>   最朴素的思路是，对每个终点，跑一遍BFS，然后统计最短路径数量。但这会导致O(N*(N+M))的复杂度，对于百万级数据是灾难。
>
> 2. **发现瓶颈：重复计算**  
>   我们很快意识到，从起点1出发，所有节点的最短路径信息都可以在一次BFS中全部获得，无需对每个终点单独计算。
>
> 3. **优化的钥匙：一次BFS，全局更新**  
>   通过一次从起点1开始的BFS，我们可以同时计算出到所有节点的最短距离`d`和对应的路径数量`ans`。这充分利用了BFS的层级遍历特性，避免了重复劳动。
>
> 4. **模型的升华：计数逻辑的融入**  
>   在BFS的框架内，巧妙地加入`ans`数组的更新规则，使得算法既高效又优雅。

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考 (BFS版)**
* **说明**：本代码综合了岸芷汀兰等多位作者的BFS思路，旨在提供一个清晰、完整、最优的核心实现。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <vector>
    #include <queue>
    #include <cstring>
    using namespace std;

    const int MAXN = 1e6 + 5;
    const int MOD = 100003;

    int n, m;
    vector<int> adj[MAXN];
    int dis[MAXN], ans[MAXN];
    bool vis[MAXN];

    void bfs(int start) {
        queue<int> q;
        memset(dis, 0x3f, sizeof(dis)); // 初始化为无穷大
        dis[start] = 0;
        ans[start] = 1; // 起点到自身的方案数为1
        q.push(start);

        while (!q.empty()) {
            int u = q.front(); q.pop();
            for (int v : adj[u]) {
                if (dis[v] > dis[u] + 1) { // 发现更短路径
                    dis[v] = dis[u] + 1;
                    ans[v] = ans[u]; // 重置方案数
                    if (!vis[v]) {
                        vis[v] = true;
                        q.push(v);
                    }
                } else if (dis[v] == dis[u] + 1) { // 发现另一条等长最短路径
                    ans[v] = (ans[v] + ans[u]) % MOD; // 累加方案数
                }
            }
        }
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        cin >> n >> m;
        for (int i = 0; i < m; ++i) {
            int x, y;
            cin >> x >> y;
            adj[x].push_back(y);
            adj[y].push_back(x);
        }
        bfs(1);
        for (int i = 1; i <= n; ++i) {
            cout << ans[i] << '\n';
        }
        return 0;
    }
    ```
* **代码解读概要**：
    1.  **图的构建**：使用`vector<int> adj[MAXN]`作为邻接表存储图结构，简洁高效。
    2.  **BFS初始化**：`dis`数组初始化为无穷大，`ans`数组初始化为0，只有起点`ans[1] = 1`。
    3.  **核心BFS循环**：队列`q`中存储待处理的节点。对于每个节点`u`，遍历其所有邻居`v`。
    4.  **状态转移**：
        *   **首次发现最短路径**：`dis[v] > dis[u] + 1`，更新`dis[v]`并重置`ans[v] = ans[u]`。
        *   **再次发现等长最短路径**：`dis[v] == dis[u] + 1`，累加方案数`ans[v] += ans[u]`。
    5.  **结果输出**：遍历`ans`数组，输出每个节点的最短路径数量。

---

## 5. 算法可视化：像素动画演示

* **动画演示主题**：**“像素探险家：BFS迷宫寻路”**

* **核心演示内容**：以8位像素风格，动态展示BFS算法如何从一个起点（像素小英雄）出发，逐层探索一个迷宫（像素网格），并统计到达每个房间（像素格子）的最短路线数量。

* **设计思路简述**：
    *   **像素风格**：采用简洁的8色调色板，每个像素格子代表一个图节点。墙壁为深灰色，空地浅灰色，起点为绿色像素英雄，已访问节点为蓝色，当前正在处理的节点高亮为黄色。
    *   **游戏化元素**：
        *   **音效**：当像素英雄“移动”到一个新格子（即节点首次被访问）时，播放“叮”的8位音效；当发现一条新的等长最短路径（即累加`ans`数组）时，播放“咔哒”的轻微提示音；当整个迷宫探索完毕，播放一段欢快的胜利旋律。
        *   **关卡**：将整个BFS过程划分为多个“关卡”，每个关卡对应BFS的一层。完成一层探索后，屏幕顶部会显示“第X层探索完成！”并短暂闪烁。
    *   **数据结构可视化**：屏幕右侧会实时显示一个简化的`dis`和`ans`数组的像素条。`dis`数组用高度表示距离，颜色表示状态（未访问/已访问）。`ans`数组用数字直接显示，当数值更新时，对应的像素数字会闪烁。

* **动画帧步骤与交互关键点**：
    1.  **场景初始化**：一个N×M的像素迷宫，起点1号格子是绿色英雄，其余为灰色。
    2.  **起点出发**：绿色英雄从起点开始，其所在的`dis`像素条高度为0，`ans`像素数字为1。
    3.  **逐层扩散**：
        *   **当前层处理**：黄色高亮的英雄移动到当前层的某个格子`u`。
        *   **邻居探索**：英雄“发射”出几条黄色光线，连接到`u`的邻居`v`。
        *   **状态更新**：
            *   如果`v`是灰色（未访问），光线变蓝色，`v`格子变蓝色，`dis[v]`像素条高度更新为`dis[u]+1`，`ans[v]`像素数字变为`ans[u]`。
            *   如果`v`是蓝色（已访问），且`dis[v] == dis[u]+1`，则`ans[v]`像素数字闪烁并累加`ans[u]`。
    4.  **关卡完成**：当一层所有节点处理完毕，屏幕顶部显示“第X层探索完成！”并播放胜利音效。
    5.  **全局完成**：当队列为空，迷宫所有可达格子都变为蓝色，顶部显示“探索完成！”，并展示最终的`ans`数组。

---

## 6. 拓展练习与相似问题思考

* **通用思路/技巧迁移**：
    *  **“计数”与“最短路”的结合**：这种“在求最优解的同时统计方案数”的思路非常通用。例如：
        1.  **动态规划计数**：在背包问题中，求恰好装满背包的方案数。
        2.  **图论中的拓扑排序计数**：在有向无环图(DAG)中，统计从一个点到另一个点的路径数量。
        3.  **网格路径计数**：在一个有障碍的棋盘上，统计从左上角到右下角的最短路径数量（只能向右或向下移动）。

* **练习推荐 (洛谷)**：
    1.  **洛谷 P4779** - 【模板】单源最短路径（标准版）
          * 🗣️ **推荐理由**：这是一道Dijkstra算法的模板题，可以帮助你巩固堆优化Dijkstra的写法，并理解其普适性。
    2.  **洛谷 P1608** - 路径统计
          * 🗣️ **推荐理由**：这道题与“最短路计数”非常相似，但边权可能不为1。你需要思考如何将本题BFS的思路迁移到Dijkstra或SPFA上，并处理带权图的计数问题。
    3.  **洛谷 P1141** - 01迷宫
          * 🗣️ **推荐理由**：这是一道BFS的变形题。你需要通过BFS来计算连通块的大小，这有助于你进一步理解BFS在图遍历中的应用。

---

## 7. 学习心得与经验分享 (若有)

> 本次分析的题解中，多位作者（如XZYQvQ, Utsuji_risshū）都提到了一个宝贵的经验：**“SPFA在带权图计数时，简单的累加可能会导致重复计数”**。例如，当一个节点的最短路径数量被更新后，它可能会再次被加入队列，从而导致其后续节点的计数被重复累加。
>
> **点评**：这提醒我们，在算法学习中，**不能仅仅满足于“AC”**，更要深入理解算法的边界条件和潜在陷阱。对于SPFA，一个更严谨的做法是，在节点出队时，将其对后续节点的贡献“清零”或采用拓扑排序的方式来累加方案数。这体现了算法设计中“严谨性”的重要性。

---
处理用时：114.09秒
# 题目信息

# 移动迷宫

## 题目背景

花生在电线杆的小广告上看到大侦探福尔魔斯正在招募助手帮助他抓住穷凶极恶的杀人魔：不知道。

花生出于某种原因来到了福尔魔斯的住处接受面试。但福尔魔斯住在一个...移动迷宫里？

## 题目描述

这个迷宫一共有 $n$ 个房间和 $m$ 条双向道路。第 $i$ 条道路连接 $u_i$ 和 $v_i$ 这两个房间，长度为 $w_i$。

福尔魔斯的迷宫是是会变化的：每通过一条道路（到达一个房间），所有道路都会伸缩，如果原本长度是 $t$，伸缩后长度会变化为 $\dfrac{1}{1-t}\bmod 754974721$。（如果你不知道分数如何取模，可移步 [P2613](https://www.luogu.com.cn/problem/P2613)；同时注意有可能涉及负数取模）

花生位于 $1$ 号房间。根据花生的测算，福尔魔斯就住在 $n$ 号房间。

请你帮帮花生最快到达 $n$ 号房间找到福尔魔斯。

------
负数取模：$x<0,p>0$，$x$ 对 $p$ 取模的结果等于 $x+p$ 对 $p$ 取模的结果。

$754974721$ 是一个质数。

## 说明/提示

### 样例 #1 解释：
沿路径 $1\rightarrow 4\rightarrow5$，路径长度为 $78888+150994944 = 151073832$。

---
对于 $30\%$ 的数据，$n\le 10$。

对于另外 $30\%$ 的数据，所有边边权相等。

对于 $100\%$ 的数据，$1\le n,m\le 10^5$，保证是一张连通图，$1\le u_i,v_i\le n$，$1<w_i<754974721$，保证无论任何时刻不会出现边权为 $1$ 的边。

所有输入的数都是整数。

---
后记：  
花生到达福尔魔斯住的房间后，看见福尔魔斯正盯着显示屏目不转睛：“你在看什么？”   
福尔魔斯：“不知道。”


## 样例 #1

### 输入

```
5 7
1 2 3
2 3 8
3 5 1000
2 4 100
4 5 6
1 4 78888
1 3 114514```

### 输出

```
151073832```

## 样例 #2

### 输入

```
6 8
1 3 100000000
1 5 200000000
2 5 300000000
2 6 400000000
3 4 500000000
5 6 600000000
4 5 700000000
3 6 303063652
```

### 输出

```
403063652```

# AI分析结果

# 💡 洛语云笺的C++算法解析：移动迷宫 深入学习指南 💡

> 欢迎来到「洛语云笺」的算法课堂！今天我们要一起破解的是“移动迷宫”这道题目。它不仅考验最短路算法，还隐藏着一条有趣的“边权循环”规律。让我们一步步揭开它的神秘面纱！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
迷宫中的每条道路长度会“伸缩”变化：每通过一条边，所有边的权值都会从 `w` 变为 `1/(1-w) mod 754974721`。我们要在动态变化的图中，找到从 `1` 到 `n` 的最短路径。

✨ **核心算法标签**  
- 最短路算法（Dijkstra / SPFA）
- 分层图思想
- 数学推导与模运算

🗣️ **初步分析**  
- **暴力思路**：每走一步就更新全图边权，然后跑最短路——时间复杂度爆炸。
- **关键观察**：边权变化有规律可循！经过推导，边权每 **3 次变化** 就会回到原值。于是，我们可以把“边权变化”转化为“状态转移”，用 **分层图** 解决。

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：求最短路，提示使用 Dijkstra 或 SPFA。
2. **线索2 (边权变化)**：边权变化函数 `f(w)=1/(1-w)`，暗示需要找规律。
3. **线索3 (数据规模)**：n,m ≤ 1e5，提示我们需要 O(n log n) 或 O(m log n) 的算法。

### 🧠 思维链构建：从线索到策略

> “侦探工作完成！让我们把线索拼起来：
>
> 1. 首先，边权会动态变化，这意味着普通最短路算法无法直接套用。
> 2. 接着，我们发现 `f(f(f(w))) = w`，说明边权变化有循环节 3！
> 3. 于是，我们可以把“边权变化次数 mod 3”作为状态，建 **3 层图**：
>    - 第 0 层：边权为 `w`
>    - 第 1 层：边权为 `1/(1-w)`
>    - 第 2 层：边权为 `1/(1-1/(1-w))`
> 4. 最后，跑一遍 Dijkstra，答案就是 `min(dis[n], dis[n*2], dis[n*3])`。”

---

## 2. 精选优质题解参考

> 经过综合评估，以下题解在思路清晰度、代码规范性、算法有效性等方面表现优异，特此推荐：

### 题解一：FLY_lai（赞：4）
- **亮点**：简洁的分层图实现，数学推导清晰，代码规范。
- **核心思想**：将每条边拆成三层，用 `u, u+n, u+2n` 表示不同状态。

### 题解二：dg114514（赞：2）
- **亮点**：直接在建边时计算三种权值，避免重复计算逆元。
- **核心思想**：用 `dis[u][0/1/2]` 记录三种状态的最短路。

### 题解三：LostKeyToReach（赞：2）
- **亮点**：分层图建图直观，代码结构清晰。
- **核心思想**：用 `gn(u,k)` 宏定义简化节点编号。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

1. **关键点1：边权变化的数学规律**
   - **分析**：通过代数推导发现 `f(f(f(w))) = w`。
   - 💡 **学习笔记**：数学推导是解决“动态图”问题的利器！

2. **关键点2：分层图建图**
   - **分析**：将每个节点拆成 3 个状态，分别对应边权变化的 0/1/2 次。
   - 💡 **学习笔记**：分层图是处理“状态相关”最短路问题的通用技巧。

3. **关键点3：最短路算法选择**
   - **分析**：Dijkstra 适合非负权图，SPFA 可能被卡。
   - 💡 **学习笔记**：优先使用 Dijkstra，避免 SPFA 的不确定性。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力模拟** | 每走一步更新全图边权 | 思路直观 | O(m^2 log n) 爆炸 | 数据规模 ≤ 10 |
| **分层图 + Dijkstra** | 建 3 层图跑最短路 | O(m log n) 高效 | 需要数学推导 | 本题最优解 |
| **分层图 + SPFA** | 同上，但用 SPFA | 实现简单 | 可能被卡 | 不推荐使用 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const ll MOD = 754974721;
const ll INF = 1e18;

ll qpow(ll a, ll b, ll p) {
    ll res = 1;
    while (b) {
        if (b & 1) res = res * a % p;
        a = a * a % p;
        b >>= 1;
    }
    return res;
}

ll inv(ll x) {
    return qpow((x + MOD) % MOD, MOD - 2, MOD);
}

const int N = 1e5 + 5;
vector<pair<int, ll>> g[3 * N];
ll dis[3 * N];

void dijkstra(int s) {
    priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;
    fill(dis, dis + 3 * N, INF);
    dis[s] = 0;
    pq.emplace(0, s);
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d != dis[u]) continue;
        for (auto [v, w] : g[u]) {
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                pq.emplace(dis[v], v);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        ll w1 = w;
        ll w2 = inv(1 - w1);
        ll w3 = inv(1 - w2);
        // 建分层图
        g[u].emplace_back(v + n, w1);
        g[u + n].emplace_back(v + 2 * n, w2);
        g[u + 2 * n].emplace_back(v, w3);
        g[v].emplace_back(u + n, w1);
        g[v + n].emplace_back(u + 2 * n, w2);
        g[v + 2 * n].emplace_back(u, w3);
    }
    dijkstra(1);
    cout << min({dis[n], dis[n * 2], dis[n * 3]}) << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题：像素探险家与三层迷宫

**设计思路**：  
- 用 8 位像素风格展示三层迷宫（第 0/1/2 层）。
- 像素小人在迷宫中移动，每走一步，边权变化通过颜色闪烁提示。
- 关键音效：  
  - “叮”：进入新层  
  - “嘟”：更新最短路径  
  - “胜利”：到达终点

**交互控制**：  
- 单步执行：按空格键，像素小人移动一步。
- 自动播放：点击“自动”按钮，小人自动寻路。
- 重置：点击“重置”，迷宫回到初始状态。

**核心动画帧**：  
1. 初始化：三层迷宫，起点 `1` 高亮。
2. 移动：小人从 `u` 移动到 `v`，边权变化颜色闪烁。
3. 更新：Dijkstra 更新 `dis[v]`，数值实时显示。
4. 结束：小人到达 `n`，显示最终最短路径。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **分层图**：适用于“边权随状态变化”的问题，如：
  - 火车换乘（不同线路不同费用）
  - 动态收费道路（时间不同费用不同）
  - 游戏技能冷却（状态影响伤害）

### 洛谷推荐练习
1. **P4568 飞行路线**  
   🗣️ 推荐理由：经典分层图最短路，巩固建图技巧。
2. **P1073 最优贸易**  
   🗣️ 推荐理由：状态压缩 + 分层图，思维进阶。
3. **P2939 道路重建**  
   🗣️ 推荐理由：边权动态变化，与移动迷宫异曲同工。

---

## 7. 学习心得与经验分享

> **来自 FLY_lai 的经验**：  
> “一开始想暴力更新边权，发现复杂度爆炸。后来通过数学推导发现循环节，分层图迎刃而解！”

**点评**：  
数学推导是解决“动态图”问题的关键。遇到边权变化，先找规律，再考虑分层或状态压缩。

---

<conclusion>
本次关于“移动迷宫”的解析就到这里啦！记住：遇到动态图，先观察规律，再分层建模。保持好奇心，下次我们一起挑战更复杂的迷宫！💪
</conclusion>

---
处理用时：66.21秒
# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果

💡 洛语云笺的 C++ 算法解析：**Mivik 写书** 深入学习指南 💡  

> 今天我们来一起分析「Mivik 写书」这道**期望 + 容斥 + 子串计数**的 C++ 题。  
> 它像一场“像素探险”：我们要在 20 个格子内，用 m 种颜色随机涂鸦，然后统计“所有本质不同子串”的期望数量。  
> 别被“期望”吓到，跟着洛语云笺，我们一步步拆穿它的伪装！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
“随机串” → “期望不同子串数”。  
**关键**是**不重不漏**地统计所有可能子串的贡献，并在**巨大字符集 m**下快速计算。

✨ **核心算法标签**  
- 组合数学  
- 容斥原理  
- 并查集 / 状态压缩  
- 生成函数（作者高端做法，可围观）

🗣️ **初步分析**  
1. **暴力枚举**（Subtask1）  
   枚举所有 mⁿ 种字符串 → 后缀自动机 / 后缀数组算不同子串 → 求平均。  
   复杂度 **O(mⁿ · poly(n))**，n≤7 能过，n=20 直接爆炸。

2. **多项式插值**（Subtask2&3）  
   观察到固定 n 时，答案关于 m 是一个 **n 次多项式**。  
   先暴力算出 m=1…n+1 的点值 → **拉格朗日插值**还原多项式。  
   复杂度 **O(n! · poly(n))**，n≤10 可过。

3. **容斥 + 状态压缩**（满分做法）  
   反向思考：  
   枚举一个“子串模板” w（长度 x），计算它在随机串中**出现至少一次**的期望出现次数，再用 **容斥** 去重。  
   用 **bitmask** 表示出现位置，**并查集**维护字符相等约束，复杂度 **O(n²·2ⁿ)**。  
   n=20 时 2²⁰≈1e6，轻松通过。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现 | 提示 |
|---|---|---|
| **n≤20** | 2ⁿ 级别算法可行 | 状态压缩 / 子集枚举 |
| **m≤5·10⁶** | 不能暴力枚举字符 | 需要 **与 m 无关** 或 **O(n log n)** 做法 |
| **“本质不同子串”** | 需要全局统计 | 经典套路：枚举子串 → 容斥去重 |

### 🧠 思维链构建：从线索到策略
1. 看到 n=20 → 2ⁿ 算法可行。  
2. 看到 m 巨大 → 必须让 m 只在最后一步以 **幂次** 形式出现。  
3. 想到：把“子串出现”抽象为 **位置约束** → 并查集合并等价类 → 容斥系数 (-1)^|S|+1。  
4. 于是得出 **位掩码 + 并查集** 的容斥框架！

---

## 2. 精选优质题解参考

### 题解一：Mivik 满分做法
- **亮点**  
  - 使用 **生成函数** 将“包含子串”问题转化为有理函数求逆。  
  - 通过 **OEIS A005434** 发现合法周期掩码极少（n=20 仅 116 种），进一步优化到 **O(116·2ⁿ·n² log n)**。  
- **代码**（已精简）  
  ```cpp
  // 核心：枚举周期掩码 v，计算 f[v] 后插值
  // 详见作者原代码 https://paste.ubuntu.com/p/BbMRk3jGpY/
  ```

### 题解二：Huasushis 容斥详解
- **亮点**  
  - 用 **bitmask** 枚举子串出现位置，并用 **并查集** 维护“哪些位置字符必须相同”。  
  - 代码清晰，**新手友好**，是学习容斥的好材料。  
- **核心代码片段**  
  ```cpp
  ll ans = 0;
  for (int x = 1; x <= n; ++x) {
      int maskLim = 1 << (n - x + 1);
      for (int mask = 1; mask < maskLim; ++mask) {
          // 并查集初始化
          for (int i = 0; i < x; ++i) fa[i] = i;
          int freePos = 0, overlap = 0;
          // ... 合并等价类
          ll ways = qp(m, freePos);
          ans = (ans + (__builtin_parity(mask) ? ways : -ways) + mod) % mod;
      }
  }
  ans = ans * inv(qp(m, n)) % mod;
  ```

### 题解三：7KByte 简洁实现
- **亮点**  
  - 同样容斥，但位运算压缩更极致，**常数小**，n=24 仍 3 秒。  
  - 使用 `__builtin_ctz` 快速处理最低位。  

### 题解四：Reunite / rainygame
- **亮点**  
  - 代码风格各异，但思路一致：**枚举长度 x → 枚举出现集合 → 并查集统计连通块 → 容斥系数**。  
  - 提供多套实现供对比学习。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（满分容斥法）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 枚举子串出现模式** | 用 bitmask `S` 表示哪些起始位置出现子串 w。 | 位掩码是 n≤20 的利器！ |
| **2. 并查集维护等价类** | 若两个位置必须字符相同 → 合并集合。 | 把“字符串相等”转成“并查集连通块”。 |
| **3. 容斥系数** | 出现奇数次加，偶数次减：`(-1)^popcount(S)+1`。 | 经典容斥套路，不重不漏。 |
| **4. 快速幂合并 m** | 每连通块可选 m 种字符，自由位也可选 m 种 → `m^(连通块+自由位)`。 | 让 m 只在最后一步出现，避免 5·10⁶ 次枚举。 |

### ✨ 解题技巧总结
- **技巧A：问题转化**  
  把“期望不同子串”→“每个子串出现概率”→“容斥求并”。  
- **技巧B：状态压缩**  
  n≤20 → bitmask 枚举子集，天然适合 C++ 的 `__builtin_*` 系列。  
- **技巧C：并查集优化等价类**  
  用路径压缩 + 按秩合并，O(α(n)) 近乎常数。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 复杂度 | 适用场景 | 得分预期 |
|---|---|---|---|---|
| **暴力枚举** | 枚举所有 mⁿ 字符串 → SAM 统计 | O(mⁿ·n) | n≤7 | 10% |
| **多项式插值** | 暴力算 n+1 点 → 拉格朗日插值 | O(n!·poly(n)) | n≤10 | 50% |
| **容斥 + bitmask** | 枚举出现位置 → 并查集 → 容斥 | O(n²·2ⁿ) | n≤20 | 100% |

### ✨ 优化之旅
从暴力 → 插值 → 容斥，每一步都在**减少与 m 相关的计算**。  
最终发现：只要算出**与 m 无关的组合系数**，最后一步乘 `m^k` 即可！

---

## 4. C++核心代码实现赏析

**通用核心实现（基于 Huasushis）**
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const ll mod = 1e9 + 7;

int n, fa[25];
ll m, pw[25], ans;

ll qpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) res = res * a % mod;
    return res;
}

int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }

int main() {
    scanf("%d%lld", &n, &m);
    pw[0] = 1;
    for (int i = 1; i <= n; ++i) pw[i] = pw[i - 1] * m % mod;

    for (int len = 1; len <= n; ++len) {
        int maskLim = 1 << (n - len + 1);
        for (int mask = 1; mask < maskLim; ++mask) {
            for (int i = 0; i < len; ++i) fa[i] = i;
            int freePos = n;  // 初始所有位置自由
            for (int pos = 0; pos <= n - len; ++pos) {
                if (!(mask >> pos & 1)) continue;
                freePos -= len;  // 先扣掉被覆盖的
                for (int i = 0; i < len; ++i) {
                    int u = find(i), v = find(i + pos - 0);  // 合并偏移
                    // 实际实现需根据题意调整
                }
            }
            int comp = 0;
            for (int i = 0; i < len; ++i) comp += (fa[i] == i);
            ll ways = qpow(m, freePos + comp);
            ans = (ans + (__builtin_parity(mask) ? ways : -ways) + mod) % mod;
        }
    }
    ans = ans * qpow(qpow(m, n), mod - 2) % mod;
    printf("%lld\n", ans);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**演示主题**：**“像素探险家：子串宝藏猎人”**

- **场景**  
  20×1 的像素条带，每个格子可涂 m 种颜色。探险家（像素小人）依次放置“子串宝箱”（长度为 x 的模板）。  
- **交互**  
  - **Step 1**：选择子串长度 x（滑块）。  
  - **Step 2**：逐位点亮宝箱出现位置（bitmask）。  
  - **Step 3**：并查集合并时，像素连线闪动，连通块高亮同色。  
  - **Step 4**：容斥系数 `(-1)^popcount` 用红/绿像素箭头表示加/减。  
- **音效**  
  - 合并连通块：8位“叮”。  
  - 成功完成一组：FC“胜利”音效。  
- **技术**  
  纯 Canvas + Web Audio API，单文件 < 50 KB，支持手机浏览器。

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**
- 枚举出现模式 + 并查集 → 适用于**字符串匹配计数**、**棋盘染色方案数**等。  
- 容斥系数 (-1)^|S| → 经典**二项式反演**、**Mobius 反演**入门。

**洛谷推荐**
| 题号 | 推荐理由 |
|---|---|
| **P1316**（本题） | 巩固容斥 + 位运算 + 并查集组合套路。 |
| **P4324** | 将“出现次数”改为“出现位置”限制，练习更复杂的容斥。 |
| **P5245** | 使用生成函数求字符串期望，体验更高阶的组合技巧。 |

---

## 7. 学习心得与经验分享

> **Huasushis**：  
> “我在 debug 时发现，容斥符号千万别写反！用 `__builtin_parity` 前先确认 popcount 奇偶对应加减。”  
> **洛语云笺点评**：  
> 容斥题常见坑就是符号！动手画 2-3 个 n=3 的小例子，手动验证一次，胜过盲调 1 小时。

---

<conclusion>
恭喜完成「Mivik 写书」的深度探险！  
记住：  
- n≤20 → 大胆用 bitmask；  
- m 巨大 → 让 m 只以幂次出现；  
- 容斥 → 奇加偶减，符号别反。  
带着这些像素武器，去迎接下一场算法挑战吧！💪
</conclusion>

---
处理用时：90.11秒
# 题目信息

# [NOI2007] 社交网络

## 题目描述

在社交网络 ( Social Network ) 的研究中，我们常常使用图论概念去解释一些社会现象。不妨看这样的一个问题:   
在一个社交圈子里有 $n$ 个人，人与人之间有不同程度的关系。我们将这个关系网络对应到一个 $n$ 个结点的无向图上，两个不同的人若互相认识，则在他们对应的结点之间连接一条无向边，并附上一个正数权值 $c$ ，$c$ 越小，表示两个人之间的关系越密切。我们可以用对应结点之间的最短路长度来衡量两个人 $s$ 和 $t$ 之间的关系密切程度，注意到最短路径上的其他结点为 $s$ 和 $t$ 的联系提供了某种便利，即这些结点对于 $s$ 和 $t$ 之间的联系有一定的重要程度。我们可以通过统计经过一个结点 $v$ 的最短路径的数目来衡量该结点在社交网络中的重要程度。考虑到两个结点 $A$ 和 $B$ 之间可能会有多条最短路径。我们修改重要程度的定义如下：令 $C_{s,t}$ 表示从s到t的不同的最短路的数目，$C_{s,t}(v)$ 表示经过 $v$ 从 $s$ 到 $t$ 的最短路的数目；则定义：

$$ I(v)=\sum_{s \ne v,t\ne v} \frac{C_{s,t}(v)}{C_{s,t}}$$

为结点 $v$ 在社交网络中的重要程度。为了使 $I(v)$ 和 $C_{s,t}(v)$ 有意义，我们规定需要处理的社交网络都是连通的无向图，即任意两个结点之间都有一条有限长度的最短路径。现在给出这样一幅描述社交网络的加权无向图，请你求出每一个结点的重要程度。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/1136.png) 

对于1号结点而言，只有2号到4号结点和4号到2号结点的最短路经过1号结点，而2号结点和4号结点之间的最短路又有2条。因而根据定义，1号结点的重要程度计算为1/2+1/2=1。由于图的对称性，其他三个结点的重要程度也都是1。

对于 $50\%$ 的数据， $n \le 10 , m \le 45$。     
对于 $100\%$ 的数据， $n \le 100 , m \le 4500$ ，任意一条边的权值 $c$ 是正整数且 $1 \leqslant c \leqslant 1000$ 。    
所有数据中保证给出的无向图连通，且任意两个结点之间的最短路径数目不超过 $10^{10}$。     



## 样例 #1

### 输入

```
4 4
1 2 1
2 3 1
3 4 1
4 1 1```

### 输出

```
1.000
1.000
1.000
1.000```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[NOI2007] 社交网络 深入学习指南 💡

> 今天我们来一起分析「社交网络」这道 NOI 经典题。  
> 表面上是“算重要程度”，本质是“在一张无向图中统计所有最短路径经过一个点的贡献”。  
> 我们将像侦探一样，从题目里挖出 3 条关键线索，然后一步步走向最优解。

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> 在 **n ≤ 100** 的**无向连通图**中，为每个结点 v 计算  
> I(v)=Σ (s≠v, t≠v) [C(s,t,v) / C(s,t)]  
> 其中 C(s,t) 是 s→t 的最短路总条数，C(s,t,v) 是经过 v 的最短路条数。

### ✨ 核心算法标签
- 多源最短路径 + 计数  
- Floyd-Warshall（O(n³)）  
- 乘法 & 加法原理  
- 枚举 + 公式统计

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 原文/暗示 | 对应策略 |
|---|---|---|
| **线索1：问题目标** | “求每一个结点的重要程度” | 需要 **每两点** 的信息 → **多源最短路径** |
| **线索2：数据规模** | n ≤ 100，m ≤ 4500 | **O(n³)=1e6** 完全可过 → Floyd |
| **线索3：计数需求** | “最短路条数”“经过 v 的条数” | 需要 **同时记录最短路径条数** → 在 Floyd 中顺带维护 |

---

### 🧠 思维链构建：从线索到策略
1. 看到“每两点” → 想到 **Floyd-Warshall**（多源最短路径神器）。  
2. 看到“条数” → 想到 **乘法原理**：若最短路径 i→k→j 长度等于 i→j，则条数可累乘。  
3. 看到“经过 v” → 想到 **枚举 v** 再枚举 (s,t)，利用公式 `dis[s][t] == dis[s][v]+dis[v][t]` 即可拆分贡献。  
4. 综上：**Floyd + 计数 + 三重枚举统计** 是完美契合的三连招！

---

## 2. 精选优质题解参考

> 从 11 份题解中，我挑选了 3 份“思路清晰 + 代码简洁 + 启发性强”的代表，供你精读。

### 题解一：Ning_Mew（赞：51）

**亮点提炼**  
- 用 `dis[i][j]` 存最短路，`edge[i][j]` 存条数，变量命名直观。  
- 在 Floyd 循环里 **同步更新条数**：  
  - 若发现更短路 → 重置条数为乘积；  
  - 若长度相同 → 累加乘积。  
- 统计阶段用 **三重循环** 直接套公式，代码短却一击必中。

**学习笔记**  
> “乘加原理 + 枚举拆分”是处理“经过某点”贡献的通用套路。

---

### 题解二：hyzhutao（赞：9）

**亮点提炼**  
- **长整型防溢出**：`long long` 存条数，避免 1e10 爆 `int`。  
- 把 `cnt[i][j]` 命名为 `ce[i][j]`，注释提醒“不是 compile error”，幽默又易记。  
- 单独封装 `calc_importance()`，体现“计算与算法分离”的工程思维。

**学习笔记**  
> 写题时别忘了 `long long`，否则 60 分惨案分分钟上演。

---

### 题解三：Rubidium_Chloride（赞：7）

**亮点提炼**  
- 博客排版清晰，用 LaTeX 重述公式，适合阅读。  
- 代码结构干净：读入 → Floyd → 统计 → 输出，一目了然。  
- 再次强调“数据范围”决定算法，强化“先看范围”的好习惯。

**学习笔记**  
> 写题解也要“用户体验”，排版好 = 帮助更多人。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析与技巧 | 💡 学习笔记 |
|---|---|---|
| **1. 多源最短路** | n=100 → Floyd O(n³) 稳过 | 100×100×100=1e6，现代 CPU < 0.1s |
| **2. 计数原理** | 乘法：条数相乘；加法：长度相同时累加 | 把“条数”当作动态规划的第二维 |
| **3. 经过 v 的贡献拆分** | 公式：`if(dis[s][t] == dis[s][v]+dis[v][t])` 贡献 += cnt[s][v]*cnt[v][t]/cnt[s][t] | 枚举 v → 枚举 s,t，复杂度 O(n³) 依旧可控 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **Floyd + 计数** | 一次 Floyd 求出所有最短路 + 条数，再枚举 v 统计 | 代码短，思维直接 | n 稍大 (>500) 就 TLE | 本题最优，100% |
| **n 次 Dijkstra** | 以每个点为源跑 Dijkstra，用 DAG + 拓扑统计条数 | n=1e3 也可用 | 代码量翻倍，易写错 | n≤1e3 时替代 |
| **SPFA 计数** | 用 SPFA 代替 Dijkstra | 稀疏图常数小 | 最坏 O(n²m) 可能被卡 | 不推荐，但可练习 |

---

### ✨ 优化之旅：从“能做”到“做好”
1. **朴素 BFS/DFS** 只能求单源最短路，且无法计数 → 直接放弃。  
2. **发现 Floyd 可一次搞定全图**，于是把“条数”塞进 Floyd 循环里同步更新。  
3. **发现枚举 v 再枚举 (s,t) 即可拆分贡献**，于是用 O(n³) 轻松通过。  
> 思维路径：单源 → 多源 → 计数 → 拆分贡献，每一步都是对问题结构的更深洞察。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合各优质题解，提炼最简洁、最安全的写法。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 105;
const ll INF = 1e18;

ll dis[N][N], cnt[N][N];
double ans[N];
int n, m;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            dis[i][j] = (i == j ? 0 : INF), cnt[i][j] = 0;

    for (int i = 1, u, v, w; i <= m; ++i) {
        cin >> u >> v >> w;
        dis[u][v] = dis[v][u] = w;
        cnt[u][v] = cnt[v][u] = 1;
    }

    // Floyd 同时计数
    for (int k = 1; k <= n; ++k)
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j) {
                if (dis[i][k] == INF || dis[k][j] == INF) continue;
                if (dis[i][j] > dis[i][k] + dis[k][j]) {
                    dis[i][j] = dis[i][k] + dis[k][j];
                    cnt[i][j] = cnt[i][k] * cnt[k][j];
                } else if (dis[i][j] == dis[i][k] + dis[k][j]) {
                    cnt[i][j] += cnt[i][k] * cnt[k][j];
                }
            }

    // 统计答案
    for (int v = 1; v <= n; ++v) {
        ans[v] = 0;
        for (int s = 1; s <= n; ++s)
            for (int t = 1; t <= n; ++t) {
                if (s == v || t == v || s == t) continue;
                if (dis[s][t] == dis[s][v] + dis[v][t])
                    ans[v] += 1.0 * cnt[s][v] * cnt[v][t] / cnt[s][t];
            }
        cout << fixed << setprecision(3) << ans[v] << '\n';
    }
    return 0;
}
```

---

### 代码片段赏析（Ning_Mew 版）

| 片段 | 解读 |
|---|---|
| `if(dis[i][j]>dis[i][k]+dis[k][j]) { dis[i][j]=...; edge[i][j]=edge[i][k]*edge[k][j]; }` | 发现更短路 → **重置条数** |
| `else if(dis[i][j]==dis[i][k]+dis[k][j]) edge[i][j]+=edge[i][k]*edge[k][j];` | 长度相同 → **累加条数** |
| `ans[i]+=(1.0*edge[j][i]*edge[i][k])/edge[j][k];` | 直接套公式，**一行搞定贡献统计** |

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素探险家”在社交网络里找“关键人物”**  
> 风格：8 位红白机像素风，16 色调色板，8×8 像素方块代表结点。

### 动画分镜
1. **初始化**：100×100 像素网格，每个结点用不同颜色方块，边用像素连线。  
2. **Floyd 过程**：  
   - 当 `k` 作为中间点时，高亮整行整列；  
   - 若 `dis[i][j]` 更新 → 方块闪烁并播放“叮”音效；  
   - 若条数累加 → 在方块旁弹出“+数字”像素文字。  
3. **统计阶段**：  
   - 选中一个 `v`，所有 `(s,t)` 若满足公式 → 连线变金色并出现分数飘字；  
   - 进度条用像素血条，完成 100% 时播放胜利音效。  
4. **交互**：  
   - 步进/自动/调速滑块；  
   - 右下角实时显示当前公式与数值；  
   - 通关彩蛋：按“Select”键可切换成“黑暗模式”配色。

### 技术实现要点
- Canvas 2D + `requestAnimationFrame` 控制帧率。  
- 音效：Web Audio API 生成 8 位方波音效。  
- 资源：单文件 < 200 KB，便于本地打开。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **课程冲突选课** → 把每门课看成结点，冲突边权 1，求“必选某课”时最多选几门。  
- **通信网络关键节点** → 给定带宽限制，求删去某点后最大流下降比例。  
- **社交网络影响力最大化** → 在更大图（n=1e5）上改用 **Johnson 全源最短路 + 采样近似**。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P1529 最短路计数 | 裸题，巩固 Floyd 计数写法。 |
| P2886 道路与航线 | 有向 + 负权，练习 Johnson 或 SPFA 计数。 |
| P4568 道路相遇 | 需要输出“必经点”，可对比“经过点”思路。 |

---

## 7. 学习心得与经验分享

> 摘录自 hyzhutao：  
> “我死在了 `long long` 上，调了半年才发现中间变量爆 `int`。”

**洛语云笺点评**：  
- 任何涉及“计数”且范围 >1e9 的题目，**一律先开 `long long`**。  
- 养成习惯：写完代码后全局搜索 `int`，把可能溢出的全部改成 `long long`。

---

<conclusion>
本次「社交网络」之旅到此结束！  
记住三步走：**Floyd 求最短路 → 乘法加法计数 → 枚举拆分贡献**。  
下次遇到“多源 + 计数 + 经过某点”的组合，直接亮出这把瑞士军刀！  
继续加油，我们下道题再见！💪

---
处理用时：103.94秒
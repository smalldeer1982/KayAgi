# 题目信息

# 正则表达式

## 题目背景

小Z童鞋一日意外的看到小X写了一个正则表达式的高级程序，这个正则表达式程序仅仅由字符“0”,“1”，“.”和“\*”构成，但是他能够匹配出所有在OJ上都AC的程序的核心代码！小Z大为颇感好奇，于是他决定入侵小X的电脑上去获得这个正则表达式的高级程序。


## 题目描述

在 Internet 网络中的每台电脑并不是直接一对一连通的，而是某些电脑之间存在单向的网络连接，也就是说存在 $A$ 到 $B$ 的连接不一定存在 $B$ 到 $A$ 的连接，并且有些连接传输速度很快，有些则很慢，所以不同连接传输所花的时间是有大有小的。另外，如果存在 $A$ 到 $B$ 的连接的同时也存在 $B$ 到 $A$ 的连接的话，那么 $A$ 和 $B$ 实际上处于同一局域网内，可以通过本地传输，这样花费的传输时间为 $0$。

现在小 Z 告诉你整个网络的构成情况，他希望知道从他的电脑（编号为 $1$），到小 X 的电脑（编号为 $n$）所需要的最短传输时间。

## 说明/提示

- 对于  $40\%$ 的数据，$1\leq n\leq 10^3$, $1\leq m\leq 10^4$；
- 对于  $70\%$ 的数据，$1\leq n\leq 5 \times 10^3$， $1\leq m\leq 10^5$；
- 对于  $100\%$ 的数据，$1\leq n\leq 2 \times 10^5$， $1\leq m\leq 10^6$。

保证答案在 `int` 范围内。

## 样例 #1

### 输入

```
3 2
1 2 1
2 3 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
5 5
1 2 1
2 3 6
3 4 1
4 2 1
3 5 2
```

### 输出

```
3```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：P2169「正则表达式」深入学习指南 💡

> 同学们好，我是你们的算法伙伴“洛语云笺”。今天，让我们把看似“黑客入侵”的标题抛到一边，聚焦这道**“强连通分量+最短路”**的经典模型题。准备好一起拆解它的核心思维了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在有向图中，**只要两个点能互相到达（即处于同一强连通分量 SCC）**，它们之间的传输时间就变为 **0**。我们需要在 **1→n** 的路径上，充分利用这一规则求出最短时间。

✨ **核心算法标签**：  
`Tarjan 缩点` `DAG 最短路` `Dijkstra / SPFA`

### 🗣️ 初步分析
- **朴素思路**：直接跑最短路，但遇到环就“踩雷”——环内边权必须清零，否则答案错误。  
- **进阶思路**：先用 **Tarjan 算法** 把环“压扁”成超级点（缩点），得到一张 **DAG**；再在新图上跑最短路即可。  
- **最优比喻**：把整张图想成一个城市地铁网，环就是 **免费换乘区**；我们先圈出所有免费区，再在“简化地图”上找最快路线。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 原文关键词 | 侦探解读 |
|---|---|---|
| **线索1：边权特殊规则** | “A↔B 同时存在，则 A-B 花费 0” | 等价于**同一 SCC 内部边权清零** |
| **线索2：数据规模** | n≤2×10⁵, m≤10⁶ | 暗示 **O(m log n)** 级别算法可行 |
| **线索3：问题模型** | 有向图+环内0权 | 经典 **缩点+最短路** 模板 |

### 🧠 思维链构建
1. 先识别所有 **免费换乘区**（SCC）。  
2. 把每个区压缩成 **超级站** → 得到无环图 DAG。  
3. 在 DAG 上跑 **1 号超级站 → n 号超级站** 的最短路。  
4. 若 1 与 n 本就同属一个超级站，答案直接为 **0**。

---

## 2. 精选优质题解参考

> 以下题解均 ≥4 星，我从“思路清晰度、代码规范度、启发性”三维度给出点评。

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **Diamiko** | 用颜色 `color` 标记 SCC；缩点后 **重建图** 再跑 Dijkstra。 | 思路完整，注释详尽，变量命名直观，非常适合初学者抄模板。 |
| **subarude** | 缩点后 **不重建图**，直接在原图 SPFA，若两端同色则边权置 0。 | 代码极短，体现“边权动态清零”技巧，但需保证 SPFA 不被卡。 |
| **PrincessQi** | 使用 **vector 邻接表**，同样采用“同色 0 权”技巧。 | 现代 C++ 风格，展示 STL 的便捷；对边权就地修改，省一次建图。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：Tarjan + DAG 最短路）

| 关键点 | 技术细节 | 💡学习笔记 |
|---|---|---|
| **1. SCC 识别** | Tarjan 一次 DFS，维护 `dfn` & `low` 数组，栈内染色。 | Tarjan=“时间戳+回溯值”，遇到 `dfn==low` 即弹栈成一 SCC。 |
| **2. 缩点/边权清零** | 方案 A：重建 DAG；方案 B：遍历时若 `color[u]==color[v]` 则权值置 0。 | 方案 A 思路清晰；方案 B 代码更短，但要确保最短路算法能处理自环。 |
| **3. DAG 最短路** | 可选 Dijkstra（堆优化 O(m log n)）或 SPFA（平均快，最坏退化）。 | 数据无负权，Dijkstra 最稳妥；SPFA 写起来更短，竞赛常用。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力 Floyd** | 三重循环全源最短路 | 思维零门槛 | O(n³) 爆炸 | n≤500，0% |
| **直接 Dijkstra** | 无视环规则 | 实现最简单 | 答案错误 | 0% |
| **Tarjan + DAG-Dijkstra** | 缩点后最短路 | 标准解法 | 需两次建图 | 100% |
| **Tarjan + 原地 SPFA** | 同色边权清零 | 代码极短 | SPFA 最坏退化 | 100%（需防卡） |

---

## 4. C++ 核心代码实现赏析

### 本题通用核心 C++ 实现（Tarjan + DAG-Dijkstra）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, M = 1e6 + 5, INF = 0x3f3f3f3f;

struct Edge { int to, nxt, w; };
Edge e[M], ne[M];
int head[N], nhead[N], tot = 0, ntot = 0;
void addEdge(int u, int v, int w, Edge *E, int *H, int &t) {
    E[++t] = {v, H[u], w}; H[u] = t;
}

int dfn[N], low[N], color[N], col, idx;
int stk[N], top; bool in[N];

void tarjan(int u) {
    dfn[u] = low[u] = ++idx;
    stk[++top] = u; in[u] = 1;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (!dfn[v]) tarjan(v), low[u] = min(low[u], low[v]);
        else if (in[v]) low[u] = min(low[u], dfn[v]);
    }
    if (dfn[u] == low[u]) {
        ++col;
        while (true) {
            int v = stk[top--];
            in[v] = 0; color[v] = col;
            if (v == u) break;
        }
    }
}

int dis[N];
void dijkstra(int s) {
    fill(dis + 1, dis + col + 1, INF);
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
    dis[s] = 0; pq.emplace(0, s);
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d != dis[u]) continue;
        for (int i = nhead[u]; i; i = ne[i].nxt) {
            int v = ne[i].to, w = ne[i].w;
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                pq.emplace(dis[v], v);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(0); cin.tie(0);
    int n, m; cin >> n >> m;
    for (int i = 1, u, v, w; i <= m; ++i) {
        cin >> u >> v >> w;
        addEdge(u, v, w, e, head, tot);
    }
    for (int i = 1; i <= n; ++i) if (!dfn[i]) tarjan(i);

    for (int u = 1; u <= n; ++u)
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to, w = e[i].w;
            if (color[u] != color[v])
                addEdge(color[u], color[v], w, ne, nhead, ntot);
        }

    dijkstra(color[1]);
    cout << dis[color[n]] << '\n';
    return 0;
}
```

---

### 代码片段赏析（“同色 0 权”技巧版）

```cpp
// 在 SPFA 的松弛环节直接判断
for (int i = head[u]; i; i = e[i].nxt) {
    int v = e[i].to, w = e[i].w;
    if (color[u] == color[v]) w = 0;   // 关键一行
    if (dis[v] > dis[u] + w) {
        dis[v] = dis[u] + w;
        if (!vis[v]) q.push(v), vis[v] = 1;
    }
}
```
- **亮点**：无需重建图，省一次内存分配。  
- **注意**：SPFA 需谨防被特殊数据卡到 O(nm)。

---

## 5. 算法可视化：像素动画演示

> 想象一张 8 位像素风的“黑客地图”：

1. **场景初始化**  
   - 网格上的每个像素电脑用 8×8 方块表示。  
   - 单向边用箭头像素动画流动，权重用数字 HUD 显示。

2. **Tarjan 过程**  
   - 当前 DFS 节点闪黄光，`dfn`/`low` 值像血条一样在头顶跳动。  
   - 当 `dfn==low`，栈内节点一起染成同色“局域网”——播放“叮”音效并出现 **“LAN 合并”** 提示。

3. **缩点动画**  
   - 同色节点收缩成一个超级像素节点，伴随“压缩”音效。  
   - DAG 新生成的边重新连线，箭头变为蓝色。

4. **最短路搜索**  
   - 采用“像素探险家”从 1 号超级节点出发，每松弛一条边，路径闪绿并播放“嘀嗒”步进音。  
   - 当到达 n 号超级节点，全屏像素礼花 + 胜利音效。

5. **交互面板**  
   - 单步/自动/调速滑块；可暂停查看当前 `dis` 数组 HUD。

---

## 6. 拓展练习与相似问题思考

| 通用套路迁移 | 场景示例 |
|---|---|
| **SCC 缩点** | 判环、2-SAT、必经点 |
| **边权特殊规则** | 双向免费通行、区间免费 |

**洛谷推荐**  
- P3387【缩点模板】——巩固 Tarjan。  
- P2341【受欢迎的牛】——SCC 求汇点。  
- P3627【道路拆除】——缩点后 DAG 上 DP。

---

## 7. 学习心得与经验分享

> 来自 **subarude**：  
> “十年 OI 一场空，忘加 pop 见祖宗”——在 SPFA 队列里忘记 `q.pop()` 导致死循环。  
> **洛语云笺点评**：调试最短路时，**打印队列 & 距离数组** 是定位死循环的利器！

---

<conclusion>
今天我们用“局域网”视角破解了看似复杂的正则表达式题。记住：  
1. 遇到“环内0权”先想 **SCC 缩点**；  
2. 数据大时 **Dijkstra** 稳，SPFA 需防卡；  
3. 写代码前先画“像素地图”，调试更轻松！  
下次探险见，Keep coding！💪
</conclusion>

---
处理用时：71.48秒
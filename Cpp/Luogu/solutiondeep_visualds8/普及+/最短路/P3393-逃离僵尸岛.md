# 题目信息

# 逃离僵尸岛

## 题目描述

小 a 住的国家被僵尸侵略了！小 a 打算逃离到该国唯一的国际空港逃出这个国家。


该国有 $N$ 个城市，城市之间有道路相连。一共有 $M$ 条双向道路。保证没有自环和重边。


其中 $K$ 个城市已经被僵尸控制了，如果贸然闯入就会被感染 TAT...所以不能进入。由其中任意城市经过不超过 $S$ 条道路就可以到达的别的城市，就是危险城市。换句话说只要某个城市到任意被僵尸控制的城市距离不超过 $S$，就是危险的。

小 a 住在 $1$ 号城市，国际空港在 $N$ 号城市，这两座城市没有被侵略。小a走每一段道路（从一个城市直接到达另外一个城市）得花一整个白天，所以晚上要住旅店。安全的的城市旅馆比较便宜要 $P$ 元，而被危险的城市，旅馆要进行安保措施，所以会变贵，为 $Q$ 元。所有危险的城市的住宿价格一样，安全的城市也是。在 $1$ 号城市和 $N$ 城市，不需要住店。


小 a 比较抠门，所以他希望知道从 $1$ 号城市到 $N$ 号城市所需要的最小花费。

输入数据保证存在路径，可以成功逃离。输入数据保证他可以逃离成功。

## 说明/提示

 ![](https://cdn.luogu.com.cn/upload/pic/2681.png) 

对于 $20\%$ 数据，$N\le 50$。

对于 $100\%$ 数据，$2\le N\le 10^5$，$1\le M\le 2\times 10^5$，$0\le K\le N - 2$，$0\le S\le 10^5$，$1\le P< Q\le 10^5$。


## 样例 #1

### 输入

```
13 21 1 1
1000 6000
7
1 2
3 7
2 4
5 8
8 9
2 5
3 4
4 7
9 10
10 11
5 9
7 12
3 6
4 5
1 3
11 12
6 7
8 11
6 13
7 8
12 13```

### 输出

```
11000```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：逃离僵尸岛 深入学习指南 💡

> 各位小小探险家们，欢迎来到“逃离僵尸岛”！今天我们要化身**最短路侦探**，在充满僵尸的地图里找到一条**花钱最少**的逃生路线。别担心，我会带你们一步步拆解问题，最终用优雅的代码跑出一条生路！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> **把“住宿费用”这一“点权”巧妙地融入最短路计算，同时先标记出所有“危险城市”（距离僵尸城 ≤ S）。**

✨ **核心算法标签**：  
- 多源 BFS（标记危险城市）  
- 点权转边权技巧  
- 单源最短路（Dijkstra / SPFA）

🗣️ **初步分析**：  
1. 先当一次“雷达”：从所有僵尸城同时出发，用 **多源 BFS** 把 ≤S 步内的城市标成“危险”。  
2. 再当一次“会计”：把“住宿费”从点权挪到边权（或直接当作点权处理）。  
3. 最后当一次“导航”：从城市 1 跑一次最短路到城市 N，途中根据城市类型支付费用。

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 原文关键词 | 侦探解读 |
|------|-------------|----------|
| **多源扩散** | “被僵尸控制的城市…距离不超过 S” | 经典 **多源 BFS** 模型：所有僵尸城同时入队，逐层向外扩散 ≤S 层。 |
| **点权最短路** | “安全的城市旅馆 P 元，危险城市 Q 元” | 需要把“住宿费”这一**点权**纳入最短路计算。常见套路：把点权拆成两条边，或直接把边权设为目标点的住宿费。 |
| **数据规模** | N ≤ 1e5，M ≤ 2e5 | 时间复杂度 **O(M log N)** 的 Dijkstra 或 **O(kM)** 的 SPFA 均可通过。 |

### 🧠 思维链构建：从线索到策略

> 1. 看到“距离 ≤ S”的扩散 → 大脑里亮起 **多源 BFS** 灯泡。  
> 2. 看到“住宿费” → 意识到是**点权最短路**，需要一次漂亮的“点权→边权”转化。  
> 3. 看到 N、M 规模 → Dijkstra + 堆优化稳稳通过，SPFA 也能赌一把。  
> 4. 结论：**多源 BFS 预处理 + 点权最短路** 就是我们的黄金组合！

---

## 2. 精选优质题解参考

### 题解一：fyfy 的“虚拟超级源”思路（赞 35）

> **点评**：  
> 这份题解最精彩的地方在于 **“0 号虚拟点”** 技巧：把所有僵尸城连向 0 号点，只需 **一次 BFS** 就能算出每个城市到“僵尸集合”的最短距离。  
> 代码风格清爽，变量名直观（`ocp[]` 标记占领，`dgs[]` 标记危险），非常易读。  
> 注意点：作者贴心提醒 **long long** 与 **inf 要足够大**，避免第 4 个点溢出。

### 题解二：顾z 的“直接点权 Dijkstra”思路（赞 8）

> **点评**：  
> 不拆点、不转边权，直接把住宿费当作 **到达该点时必须支付的点权**。  
> 在 Dijkstra 松弛时，`dis[v] = dis[u] + cost[v]`，简洁优雅。  
> 小心终点 **城市 N 的点权需置 0**（题目说明不用住宿），作者踩坑后给出特别提醒。

### 题解三：ChoHakuNe 的“拆点”思路（赞 6）

> **点评**：  
> 把每个城市拆成 **“入点 i” 与 “出点 i+n”**，中间连一条边权为住宿费的边。  
> 这种 **网络流常用套路** 让边权全部为 0，逻辑清晰，但代码量稍大。  
> 适合想深入理解“拆点”思想的同学。

（其余题解因篇幅略，但均围绕“多源 BFS + 最短路”展开，差异仅在于点权处理方式与最短路算法选择。）

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析与学习笔记 |
|--------|----------------|
| **1. 多源 BFS 标记危险城市** | 将所有僵尸城入队，距离设为 0，逐层向外扩散 ≤S 步即可。时间 O(N+M)。<br>💡 *学习笔记*：多源 BFS 本质是一次“超级源点”的 BFS，避免重复计算。 |
| **2. 点权转边权** | 常见两种写法：<br>① **边权 = 目标点住宿费**（顾z 写法）；<br>② **拆点**（ChoHakuNe 写法）。<br>💡 *学习笔记*：思路①更短更快；思路②通用性强，适合复杂网络流。 |
| **3. 最短路算法选择** | Dijkstra + 优先队列 稳定 O(M log N)；SPFA 平均快但可被卡。<br>💡 *学习笔记*：竞赛中优先 Dijkstra，SPFA 用于数据随机或时间紧张。 |

### ✨ 解题技巧总结

- **技巧 A：虚拟超级源**  
  把“多个起点”问题转化为“单一起点”问题，只需一次 BFS/Dijkstra。
- **技巧 B：long long 与 inf 设置**  
  费用可能爆 int，inf 建议 ≥ 1e12。
- **技巧 C：终点/起点费用置 0**  
  题目明确 1 和 N 不用住宿，务必特判。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|------|----------|------|------|----------|
| 暴力多次 BFS | 对每个僵尸城分别 BFS 标记 | 思路直接 | O(k(N+M)) 会 TLE | 20-30 |
| 多源 BFS + Dijkstra | 一次多源 BFS + 一次最短路 | 稳定 O(M log N) | 需掌握点权转化 | 100 |
| 拆点网络流 | 拆点把点权变边权 | 模型通用 | 代码较长 | 100 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（顾z 直接点权版）

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int N = 1e5 + 5, M = 2e5 + 5;
const ll INF = 1e18;

int n, m, k, s, P, Q;
vector<int> g[N];
ll cost[N], dis[N];
bool occ[N], danger[N];

void multiBFS() {
    queue<int> q;
    fill_n(dis, n + 1, -1);
    for (int i = 1; i <= k; ++i) {
        int x; cin >> x;
        occ[x] = true;
        q.push(x); dis[x] = 0;
    }
    while (!q.empty()) {
        int u = q.front(); q.pop();
        if (dis[u] == s) continue;
        for (int v : g[u]) if (dis[v] == -1 && !occ[v]) {
            dis[v] = dis[u] + 1;
            danger[v] = true;
            q.push(v);
        }
    }
}

void dijkstra() {
    fill_n(dis, n + 1, INF);
    priority_queue<pair<ll,int>, vector<pair<ll,int>>, greater<pair<ll,int>>> pq;
    dis[1] = 0; pq.emplace(0, 1);
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d != dis[u]) continue;
        for (int v : g[u]) {
            if (occ[v]) continue;
            ll w = (danger[v] ? Q : P);
            if (u == 1 || v == n) w = 0; // 起点终点不花钱
            if (dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                pq.emplace(dis[v], v);
            }
        }
    }
    cout << dis[n] << '\n';
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> k >> s >> P >> Q;
    for (int i = 1, u, v; i <= m; ++i) {
        cin >> u >> v;
        g[u].push_back(v); g[v].push_back(u);
    }
    multiBFS();
    dijkstra();
    return 0;
}
```

- **代码解读概要**：  
  1. `multiBFS()` 用队列一次性标记所有 ≤S 步内的危险城市。  
  2. `dijkstra()` 把住宿费当作点权，松弛时累加；特判 1 和 N 不花钱。  
  3. 全程 `long long`，复杂度 O(M log N)。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素探险家在僵尸岛找最省钱路线”**

- **场景**：8×12 的像素网格，僵尸城（红骷髅）、安全城（绿小屋）、危险城（黄警告）。
- **动画流程**：
  1. **多源 BFS** 阶段：所有红骷髅同时闪烁，逐层向外扩散黄色“危险波”，直至 S 步。
  2. **最短路阶段**：像素探险家从左上角 1 出发，每走一步弹出当前花费，优先队列（像素小堆）实时更新。
  3. **音效**：每松弛成功一次播放“叮”，到达终点播放 8-bit 胜利音。
- **交互**：下方控制条可拖拽速度，单步/自动切换。

（实现提示：用 Canvas 绘制网格，`requestAnimationFrame` 逐帧更新，队列用像素方块堆叠表示。）

---

## 6. 拓展练习与相似问题思考

- **通用套路迁移**  
  1. 多源 BFS：洪水填充、火灾蔓延、多起点最短路。  
  2. 点权最短路：带收费站的高速路、带冷却时间的传送门。  
  3. 虚拟超级源：多仓库配送、多起点救援。

- **洛谷推荐**  
  1. **P1629 邮递员送信** —— 练习多源 BFS 思想。  
  2. **P1522 旅行计划** —— 点权转边权 + 最短路。  
  3. **P4779 模板·单源最短路径（标准版）** —— 巩固 Dijkstra。

---

## 7. 学习心得与经验分享

> 摘自 **Euplectella**：  
> “我最初对每个僵尸城跑 SPFA，28 分 TLE。后来意识到 **多源 BFS 只需一次** 即可标记危险城市，瞬间 AC。”  
> **洛语云笺点评**：  
> 这正是“从暴力到优雅”的典型案例！学会把“多个起点”合并为“超级源”，是算法进阶的重要一步。

---

<conclusion>
今天的“逃离僵尸岛”之旅到此结束！记住三步法：**多源标记 → 点权处理 → 最短路**。带着这份思维模板，去迎接更多图论挑战吧！🎮
</conclusion>

---
处理用时：95.66秒
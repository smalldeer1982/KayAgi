# 题目信息

# [JLOI2011] 飞行路线

## 题目描述

Alice 和 Bob 现在要乘飞机旅行，他们选择了一家相对便宜的航空公司。该航空公司一共在 $n$ 个城市设有业务，设这些城市分别标记为 $0$ 到 $n-1$，一共有 $m$ 种航线，每种航线连接两个城市，并且航线有一定的价格。

Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机。航空公司对他们这次旅行也推出优惠，他们可以免费在最多 $k$ 种航线上搭乘飞机。那么 Alice 和 Bob 这次出行最少花费多少？

## 说明/提示

#### 数据规模与约定

对于 $30\%$ 的数据，$2 \le n \le 50$，$1 \le m \le 300$，$k=0$。

对于 $50\%$ 的数据，$2 \le n \le 600$，$1 \le m \le 6\times10^3$，$0 \le k \le 1$。

对于 $100\%$ 的数据，$2 \le n \le 10^4$，$1 \le m \le 5\times 10^4$，$0 \le k \le 10$，$0\le s,t,a,b < n$，$a\ne b$，$0\le c\le 10^3$。

另外存在一组 hack 数据。

## 样例 #1

### 输入

```
5 6 1
0 4
0 1 5
1 2 5
2 3 5
3 4 5
2 3 3
0 2 100```

### 输出

```
8```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「JLOI2011 飞行路线」深入学习指南 💡

> 各位小小飞行员，今天我们要一起驾驶算法航班，从城市 0 飞到城市 n-1，还能“免费”飞 k 次！这趟旅程的关键是——**分层图最短路**。别被名字吓到，跟着洛语云笺，我们把它拆成“乐高积木”来玩！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在一张无向图中，最多把 k 条边的权值设为 0，求从 s 到 t 的最短路。

✨ **核心算法标签**  
- **分层图最短路**（Layered Graph Shortest Path）  
- **Dijkstra / SPFA**  
- **状态压缩思想**（用“层数”记录免费次数）

🗣️ **初步分析**  
> 最朴素的想法：枚举所有可能的 k 条边，把它们的权值置 0，再跑最短路。复杂度 O(C(m,k)·m log n)，m 最大 5×10⁴，k=10 时直接爆炸。  
> 于是，我们需要一种“**一次建图、一次最短路**”的优雅方案——这就是**分层图**的魅力！

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **“最多免费 k 次”** | 免费次数是一个“额外状态”，必须纳入最短路状态 → 提示我们给最短路“加一维”。 |
| **k≤10** | 维数很小，说明二维 Dijkstra 或分层图都可做。 |
| **m log n 可过** | n≤1e4，m≤5e4，m log n ≈ 8×10⁵，完全可行。 |

### 🧠 思维链构建：从线索到策略
1. 看到“免费 k 次” → **状态维度**（免费次数）  
2. 状态维度很小 → **二维最短路** dis[u][k_used]  
3. 如何把“免费”体现在图里？  
   - **方法A：二维 Dijkstra** 在松弛时额外转移“免费边”。  
   - **方法B：分层建图** 把“免费”变成层与层之间的 0 权边。  
4. 两种方法等价，但**分层图更直观**，代码更模板化。  

---

## 2. 精选优质题解参考

> 洛语云笺从 20 余份题解中，按**思路清晰度、代码质量、启发性**筛选出 5 份 ≥4 星佳作，为你提炼精华！

| 题解 | 亮点提炼 | 推荐语 |
|---|---|---|
| **SuperJvRuo**（赞165） | 最早提出“分层图”建图模板；代码简洁，用 `add_edge` 宏定义。 | “分层图教科书式示范，值得全文背诵！” |
| **Anguei**（赞80） | 用二维状态 `dis[v][cnt]` 直接 Dijkstra，**无需显式建分层图**，空间更小。 | “把分层图吃进了优先队列里，优雅！” |
| **Heartlessly**（赞61） | 图文并茂，对比两种建图方式；附赠线段树优化 Dijkstra 彩蛋。 | “图解+代码双杀，适合视觉学习者。” |
| **shenbear**（赞60） | 从“蒟蒻视角”一步步推导，用 `f[i][k]` 二维 DP 思想解释 Dijkstra。 | “把高深算法讲成‘故事书’，萌新福音。” |
| **顾z**（赞33） | 代码最短，变量命名清晰，适合快速模板化。 | “竞赛模板首选，30 秒写完。” |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：分层图）

#### 关键点1：如何“分层”？
- **分析**：把原图复制 k+1 份，编号为 0~k 层。  
  - **同层内**：正常连边，权值不变。  
  - **跨层边**：从第 i 层的 u 连向第 i+1 层的 v，权值 0（表示“免费”）。  
- 💡 **学习笔记**：层数 = 已用免费次数，层间 0 边 = 免费决策。

#### 关键点2：如何定义状态？
- **二维 Dijkstra**：`dis[u][k_used]` 表示到达 u 已用 k_used 次免费的最短路。  
- **分层图**：节点编号 `u + k_used * n`，直接跑一维 Dijkstra。  
- 💡 **学习笔记**：两种写法等价，前者省空间，后者更直观。

#### 关键点3：如何处理“答案”？
- 终点 t 可能在任意层（0~k），取 `min(dis[t + i*n])` 0≤i≤k。  
- 💡 **学习笔记**：免费次数“不必用完”，需枚举所有可能层。

### ✨ 解题技巧总结
- **技巧A：分层建图** → 把“决策”变成“边”。  
- **技巧B：二维状态** → 用 `pair<int,int>` 或 `u + k*n` 统一编码。  
- **技巧C：答案后处理** → 所有层取最小值。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 枚举 k 条边置 0 再跑 Dijkstra | 思路直观 | O(C(m,k)·m log n) 爆炸 | m≤30,k≤3 |
| **二维 Dijkstra** | dis[u][k_used] + 两种转移 | 空间 O(nk) | 需手写二维优先队列 | k≤20 |
| **分层图**（最优） | 显式建 k+1 层图 | 模板化、易调试 | 空间 O(nk+mk) | k≤10 |
| **SPFA** | 队列维护二维状态 | 常数小 | 易被卡 | 无负权 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（分层图 + Dijkstra）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e4 + 10, MAXM = 5e4 + 10, MAXK = 11;
struct Edge { int to, nxt, w; } e[MAXM * MAXK * 4];
int head[MAXN * MAXK], cnt, dis[MAXN * MAXK], vis[MAXN * MAXK];
void add(int u, int v, int w) {
    e[++cnt] = {v, head[u], w}; head[u] = cnt;
}
struct Node {
    int u, d;
    bool operator<(const Node& o) const { return d > o.d; }
};
void dijkstra(int s, int n, int k) {
    priority_queue<Node> q;
    fill(dis, dis + n * (k + 1), 0x3f3f3f3f);
    dis[s] = 0; q.push({s, 0});
    while (!q.empty()) {
        int u = q.top().u; q.pop();
        if (vis[u]) continue; vis[u] = 1;
        for (int i = head[u]; i; i = e[i].nxt) {
            int v = e[i].to;
            if (dis[v] > dis[u] + e[i].w) {
                dis[v] = dis[u] + e[i].w;
                q.push({v, dis[v]});
            }
        }
    }
}
int main() {
    ios::sync_with_stdio(false);
    int n, m, k, s, t; cin >> n >> m >> k >> s >> t;
    cnt = 0; fill(head, head + n * (k + 1), 0);
    for (int i = 1, u, v, w; i <= m; ++i) {
        cin >> u >> v >> w;
        for (int j = 0; j <= k; ++j) {
            add(u + j * n, v + j * n, w);
            add(v + j * n, u + j * n, w);
            if (j < k) {
                add(u + j * n, v + (j + 1) * n, 0);
                add(v + j * n, u + (j + 1) * n, 0);
            }
        }
    }
    dijkstra(s, n, k);
    int ans = 1e9;
    for (int i = 0; i <= k; ++i) ans = min(ans, dis[t + i * n]);
    cout << ans;
    return 0;
}
```
- **代码解读概要**：  
  - 建图：同层连原边，跨层连 0 边。  
  - 最短路：一维 Dijkstra 跑在 `u + k_used * n` 上。  
  - 答案：所有层终点取最小值。

### 精选题解代码片段赏析（节选）

**1. Anguei 的二维 Dijkstra（无需显式建分层图）**
```cpp
struct State { int v, w, cnt; };
priority_queue<State, vector<State>, greater<State>> pq;
// 松弛时：
if (cnt < k && dis[to][cnt+1] > dis[u][cnt]) { ... }
```

**2. Heartlessly 的线段树优化 Dijkstra**
```cpp
// 用线段树维护最小 dis 节点，常数略优
modify(1, 1, kth*n, v, dis[v]);
```

---

## 5. 算法可视化：像素动画演示

> 让我们用 8 位像素风格，模拟“小飞机”在分层图中穿梭！

### 🎮 动画主题
**《像素航线：免费航班大冒险》**

### 🎯 核心演示内容
- **分层图结构**：0~k 层，每层 n 个像素城市。  
- **小飞机移动**：  
  - 同层飞行：消耗“燃料”（边权）。  
  - 跨层跳跃：消耗“免费券”（0 权边），伴随“叮”音效。  
- **实时状态**：当前层数（已用免费次数），累计花费。

### 🕹️ 交互设计
| 控件 | 功能 |
|---|---|
| ⏯️ 开始/暂停 | 自动播放算法 |
| ⏭️ 单步 | 下一步松弛 |
| 🎚️ 速度滑块 | 调整动画速度 |
| 🔊 音效 | 跳跃“叮”，到达“胜利音” |

### 📺 关键帧示例
1. **初始化**：起点 s 在第 0 层闪烁。  
2. **松弛同层**：边权累加，像素方块变色。  
3. **免费跳跃**：层数 +1，飞机瞬移，播放“叮”。  
4. **终点高亮**：所有层 t 像素闪金光，取最小值。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
分层图思想可解决：
- **最多修 k 条路** → 最小化最短路（P4822 冻结）。  
- **最多撤销 k 次操作** → 最小化代价。  
- **最多买 k 张票** → 最小化总票价。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P4822 [BJWC2012] 冻结** | 分层图裸题，巩固模板。 |
| **P2939 [USACO09FEB] 改造路** | 双倍经验，注意卡空间。 |
| **P1948 公路建设** | 分层图 + 二分答案。 |

---

## 7. 学习心得与经验分享

> **来自 shenbear 的调试笔记**  
> “二维数组 dis[u][k] 容易写反下标，建议用 `dis[v][used]` 而非 `dis[used][v]`，否则调试到怀疑人生！”  
> ——洛语云笺点评：变量命名即注释，顺序即真理！

---

### ✨ 结语
分层图就像“平行宇宙”：每用一次免费券，就进入一个新宇宙继续飞行。掌握它，你就拥有了在多维空间中“抄近路”的超能力！下次见，小小算法飞行员们！

---
处理用时：103.17秒
# 题目信息

# [WFOI - 01]  刷题 （problem）

## 题目背景

简化题意：[$\texttt{Link}$](https://www.luogu.com.cn/paste/ievt77rm)。

## 题目描述

你初始能力为 $0$。

现在有 $n$ 个题库，每个题库的题有同一个难度 $a_i$，并且题目数量可以视为无限多。现在你要刷 $m$ 道题，每道题都是所有题中你选择出来的一道。

假设你目前做到的题目难度是 $x$，则：

当你的能力比这个题大或等于此题时，你将花费你的能力以攻破此题（此时你的能力减去 $x$）；否则，你将认真钻研此题，钻研出此题后能力增加 $x$（此时不会导致能力减少）。

现在你想知道你做 $m$ 题后能力最大值。由于你的小伙伴也要刷题，所以**有多次询问**，询问之间相互独立，也就是说每次询问的能力初值为 $0$。

## 说明/提示

- **样例 $1$ 解释：**
	
    当 $m=1$ 时，依次选择 $6$；

	当 $m=2$ 时，依次选择 $4,6$；
    
    当 $m=3$ 时，依次选择 $1,4,6$；
- **样例 $2$ 解释：** 

    当 $m=1$ 时，依次选择 $1$；

	当 $m=2$ 时，依次选择 $1,1$；

**本题采用 Subtask 捆绑测试。**

  Subtask 编号 | $n\le$ | $m\le$ | $T\le$
  :-: | :-: | :-: | :-: |
  **Subtask #0 ($5\texttt{pts}$)** | $5$ | $5$ | $100$ |
  **Subtask #1 ($10\texttt{pts}$)** | $5$ | $5$ | $10^5$ |
  **Subtask #2 ($10\texttt{pts}$)** | $200$ | $200$ | $100$ |
  **Subtask #3 ($15\texttt{pts}$)** | $200$ | $200$ | $10^5$ |
  **Subtask #4 ($10\texttt{pts}$)** | $200$ | $10^{18}$ | $10^5$ |
  **Subtask #5 ($50\texttt{pts}$)** | $2000$ | $10^{18}$ | $10^5$ |
  
对于 $100\%$ 的数据，$1 \le T \le 10^5$，$1 \le n\le 2000$，$1 \le m \le 10^{18}$，$\forall i,0 \le a_i \le 2000$。

## 样例 #1

### 输入

```
5 3
1 2 3 4 6
1
2
3```

### 输出

```
6
10
11```

## 样例 #2

### 输入

```
1 2
1
1
2```

### 输出

```
1
0```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[WFOI-01] 刷题（problem）深入学习指南 💡

> 今天我们要拆解的是一道把「刷题」玩出花样的思维题：初始能力为 0，刷 m 道题后，能力最大能冲到多少？看似简单的规则，却隐藏着「奇偶最短路」的精妙模型。让我们一起像侦探一样，从题面挖出线索，在多种思路中权衡，最终找到最优策略！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战  
在「能力增减交替」的规则下，**如何快速回答多组询问：刷恰好 m 题后的最大能力？**  
m 最大可到 1e18，暴力模拟显然行不通。

### ✨ 核心算法标签  
**最短路（BFS/SPFA）** + **奇偶分层思想** + **前缀最值优化**

### 🗣️ 初步分析  
- **直观暴力**：逐题模拟，O(m) 单次询问 → m=1e18 直接爆炸。  
- **优化方向**：  
  1. 发现「能力值有界」：无论怎么刷，能力 ≤ 2·maxa−1（maxa 为最大 a_i）。  
  2. 发现「奇偶周期」：连续两次选 maxa，能力值不变 ⇒ 只需关心「步数奇偶性」。  
  3. 抽象为**奇偶图最短路**：把「能力值 x + 步数奇偶 p」作为节点，跑 0-1 BFS，预处理所有可达状态，然后 O(1) 回答询问。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 原文/数据 | 侦探解读 |
|---|---|---|
| **问题目标** | 求刷 m 题后的最大能力 | 最优化问题，且 m 极大 ⇒ 必须预处理 |
| **能力规则** | x ≥ a_i ⇒ x−a_i；x < a_i ⇒ x+a_i | 每次操作是「确定性转移」——图论边 |
| **数据规模** | maxa ≤ 2000，能力值 ≤ 3999，T ≤ 1e5 | 状态空间 ≤ 4000×2 = 8000，BFS 可行 |

### 🧠 思维链构建：从线索到策略
1. **能力值有界** → 把能力值作为节点。  
2. **转移确定性** → 建图：节点 x 向 x±a_i 连边。  
3. **奇偶周期** → 拆点：x_odd, x_even，避免重复走 maxa。  
4. **超大 m** → 只需关心「步数奇偶性」：若最短步数 d 与 m 同奇偶且 ≤ m，则可达；否则用两次 maxa 抵消调整。  
5. **结论**：跑**奇偶图最短路**，预处理 d[x][0/1]，再对每组询问取 max{x | d[x][m%2] ≤ m}。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **€€£** (15赞) | 拆奇偶节点、最短路后在线回答 | 思路极简，一句话点破「奇偶最短路」本质 |
| **Wf_yjqd** (10赞) | 详细解释奇偶抵消、BFS 实现 | 代码严谨，踩坑提醒（3999→1e9）极其实用 |
| **YellowBean_Elsa** (10赞) | 用 SPFA 跑奇偶最短路，模板清晰 | 变量命名 dp[i][p] 直观，适合初学者抄模板 |
| **伟大的王夫子** (4赞) | 类比 [P5663 加工零件] | 用熟悉题目做类比，帮助快速建立模型 |
| **starrylasky** (8赞) | 打表发现「5 步内覆盖」→ 小 m 暴力 | 适合数据极弱子任务，体现部分分策略 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析与技巧 | 💡 学习笔记 |
|---|---|---|
| **能力值上界证明** | 若当前 ≥ maxa，下一步必 ≤ maxa−1；若 < maxa，下一步 ≤ maxa+maxa−1 ⇒ 全局 ≤ 2·maxa−1 | 先证界再建图，避免无效状态 |
| **奇偶拆点** | 节点 (x, p) 表示「能力 x 且已走步数奇偶性 p」。x∈[0,3999]，p∈{0,1}，共 8000 节点 | 把「步数奇偶」显式放入状态，解决 m 极大问题 |
| **01-BFS/SPFA** | 每条边权 1，直接 BFS 即可求出 d[x][p] | 时间复杂度 O(8000·n) ≈ 1.6e7，轻松通过 |
| **询问回答** | 对每个询问 m，枚举 x 从 3999→0，若 d[x][m&1] ≤ m，则 x 为答案 | 可再优化：预处理前缀最大值 ans[step][0/1]，O(1) 回答 |

### ✨ 解题技巧总结
- **技巧A：状态压缩**  
  把「能力值 + 奇偶性」压成一个二维状态，避免枚举巨大 m。  
- **技巧B：奇偶抵消**  
  连续两次选 maxa 等价于「空操作」，因此只需关心「步数奇偶性」。  
- **技巧C：前缀最值**  
  预处理 ans[k][0/1] = max{x | d[x][0/1] ≤ k}，查询时直接取 ans[m][m&1]。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分预期 |
|---|---|---|---|---|
| **暴力模拟** | 逐题选最大 a_i | 思路直观 | O(m) 单次，m=1e18 必炸 | Subtask #0-#1 (10-15 pts) |
| **奇偶图最短路** | 建图 + BFS 预处理 | 理论最优 O(maxa·n + T) | 需要建图思维 | 100 pts |
| **打表小 m** | 发现 5 步内覆盖 | 代码极简 | 仅对小 m 有效 | 特殊数据 (≤15 pts) |

### ✨ 优化之旅
从「暴力模拟」→「发现上界」→「奇偶拆点」→「01-BFS」→「前缀最值」，我们完成了从「能做」到「做好」的跨越。记住：**先证界，再建模，最后预处理**，是处理大 m 问题的通用套路。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXA = 4000;          // 2*2000-1
int n, T, maxa;
int a[2005];
int dis[MAXA][2];              // dis[x][p] 步数奇偶性 p 到达 x 的最小步数
vector<int> g[MAXA];

inline void build_graph() {     // 建图
    for (int x = 0; x < 2 * maxa; ++x) g[x].clear();
    for (int x = 0; x < 2 * maxa; ++x)
        for (int i = 1; i <= n; ++i) {
            int y = (x >= a[i]) ? x - a[i] : x + a[i];
            if (y >= 0 && y < 2 * maxa) g[x].push_back(y);
        }
}

void bfs() {
    memset(dis, 0x3f, sizeof dis);
    queue<pair<int, int>> q;   // {x, parity}
    dis[0][0] = 0;
    q.emplace(0, 0);
    while (!q.empty()) {
        auto [x, p] = q.front(); q.pop();
        for (int y : g[x]) {
            int np = p ^ 1;
            if (dis[y][np] > dis[x][p] + 1) {
                dis[y][np] = dis[x][p] + 1;
                q.emplace(y, np);
            }
        }
    }
}

int ans[MAXA][2];              // ans[k][0/1] 步数 ≤k 且奇偶性匹配的最大能力

void pre() {
    for (int k = 0; k < MAXA; ++k) ans[k][0] = ans[k][1] = -1;
    for (int x = 0; x < 2 * maxa; ++x)
        for (int p : {0, 1})
            if (dis[x][p] < MAXA)
                ans[dis[x][p]][p] = max(ans[dis[x][p]][p], x);
    // 前缀最值
    for (int k = 2; k < MAXA; ++k)
        for (int p : {0, 1})
            ans[k][p] = max(ans[k][p], ans[k - 2][p]);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> T;
    maxa = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        maxa = max(maxa, a[i]);
    }
    build_graph();
    bfs();
    pre();
    while (T--) {
        ll m; cin >> m;
        if (m >= MAXA) m = MAXA - 1;
        cout << ans[m][m & 1] << '\n';
    }
    return 0;
}
```

### 题解代码片段赏析
**YellowBean_Elsa** 的 SPFA 实现（核心片段）
```cpp
memset(dp, 0x7f, sizeof dp);
dp[0][0] = 0;
queue<int> q; q.push(0);
while (!q.empty()) {
    int x = q.front(); q.pop();
    for (int i = 1; i <= n; ++i) {
        int y, np;
        if (x < a[i]) {
            y = x + a[i], np = 1;
            if (dp[y][np] > dp[x][0] + 1) dp[y][np] = dp[x][0] + 1, q.push(y);
            y = x + a[i], np = 0;
            if (dp[y][np] > dp[x][1] + 1) dp[y][np] = dp[x][1] + 1, q.push(y);
        } else {
            y = x - a[i], np = 1;
            if (dp[y][np] > dp[x][0] + 1) dp[y][np] = dp[x][0] + 1, q.push(y);
            y = x - a[i], np = 0;
            if (dp[y][np] > dp[x][1] + 1) dp[y][np] = dp[x][1] + 1, q.push(y);
        }
    }
}
```
- **亮点**：用 `dp[x][0/1]` 直接表示「能力 x 的最小奇/偶步数」，省去显式建图。  
- **学习笔记**：当边权为 1 时，SPFA 退化为普通 BFS，写法更灵活。

---

## 5. 算法可视化：像素动画演示

### 主题
**「像素刷题机」——在 8×500 的像素条带中，观察能力值如何随每次刷题上下跳动，最终锁定最大能力！**

### 设计思路
- **像素条带**：能力值 0-3999 映射到 4000 个像素格，颜色越亮表示步数越少。  
- **奇偶分层**：上半屏显示「奇步」，下半屏显示「偶步」，同步高亮。  
- **音效 & 关卡**：  
  - 每更新一次 dis[x][p] → 播放 8 位「叮」；  
  - 完成一次 BFS → 播放「胜利」旋律；  
  - 查询时，对应像素格闪烁并显示数值。

### 动画关键帧
1. **初始化**：能力值 0 的像素格亮绿色，其余灰色。  
2. **BFS 扩散**：从 0 开始，绿色像素向外「波浪」扩散，奇偶交替。  
3. **查询演示**：输入 m，对应奇偶层像素格闪烁，显示最终答案。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **奇偶最短路**：适用于「步数极大但奇偶性敏感」的问题，如：  
  1. 加工零件（P5663）：在二分图上跑奇偶最短路。  
  2. 网格跳跃：每次移动距离奇偶性固定。  
  3. 开关灯问题：按两次开关回到原状态。

### 洛谷推荐
1. **P5663 [CSP-J2019] 加工零件**  
   🗣️ 推荐理由：同样是奇偶图最短路，题面更友好，适合巩固模板。
2. **P3953 [NOIP2017] 逛公园**  
   🗣️ 推荐理由：需要计数「恰好 k 步」的方案，同样利用最短路 + 奇偶思想。
3. **P1608 路径统计**  
   🗣️ 推荐理由：在 DAG 上跑最长路，体会「状态有限 + 预处理」的套路。

---

## 7. 学习心得与经验分享

- **Wf_yjqd** 踩坑：把 3999 误写成 1e9 导致 TLE+MLE，提醒我们**边界值务必精确**。  
- **starrylasky** 打表：用「小数据找规律」拿到部分分，体现了**部分分策略**的重要性。  
- **YellowBean_Elsa** 的变量命名 `dp[i][p]` 直观易懂，告诉我们**清晰的命名能大幅降低调试成本**。

---

<conclusion>
今天我们用「奇偶最短路」这把钥匙，打开了「超大 m」问题的锁。记住三步：证界 → 建模 → 预处理。下次遇到「步数极大」的题目，先想想能否拆奇偶！刷题愉快，我们下道题再见！💪

---
处理用时：89.76秒
# 题目信息

# [DMOI-R1] Portal

## 题目背景

出题人正在玩一款叫 Portal 的游戏。但由于他太菜了，于是找来了你，让你帮他过几个他过不去的关卡。

什么？你说你不会玩？

玩家需要通过传送门枪到达出口。利用传送门枪射击可开出两种门，分别是橙色门和蓝色门，两面都可作入口及出口。在创造门的时候，另一道同样颜色的门会消失，即是说同时间不可能存在两道同色的门，最多只可同时存在一道蓝色及一道橙色的门。

两道传送门在三维空间之中的两个地点创造出视觉上及物理上的连系，传送门的立点只限于平面，玩家从门出来时会自动配合地心吸力调整身体水平。

出题人把所有希望都寄托于你身上了哟。哦，对了，因为出题人是个白嫖党，因此他拥有的是盗版 Portal。

## 题目描述

在一个 $n \times n$ 的二维平面图上，用 $(x,y)$ 表示地图第 $x$ 行第 $y$ 列。每个点都是墙、虚空和地面中的一种，分别用 `#`，`*`，`.` 表示。玩家只能站在地面上。**地图之外都是墙。**

你手里有一个传送门枪，可以发射蓝色和橙色的传送门，只能朝上下左右四个方向使用。

在选定一个方向和颜色后，将会在该方向上第一个碰到的墙的墙面上建造选定颜色的传送门，并摧毁之前建造的这种颜色的传送门。两种颜色的传送门不能被建立在同一墙面。

玩家可以朝上下左右四个方向的空地移动。玩家还可以在不同色传送门之间穿梭。假如玩家朝一堵墙移动并且墙面上有传送门，并且当前已经建立了两个传送门，那么会从另一个传送门出来（必须保证出来也站在陆地上）。

出来的时候，玩家会站在另一个门外的空地上，**四个方向都可以。**

一开始玩家站在 $(1,1)$，目的地是 $(n,n)$。求最少使用多少次传送门枪才能到达目的地。

**注意哦，这里的使用指的是穿过多少面传送门。**

## 说明/提示

### 样例1解释

我们用白色格子表示空地，黑色格子表示墙，蓝色格子表示蓝色传送门，橙色格子表示橙色传送门，可以画出第一局的如下地图：

![](https://cdn.luogu.com.cn/upload/image_hosting/s16tq3vq.png)

走到橙色传送门处，从橙色传送门进入，蓝色传送门出即可。

而第二局地图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/v7q0izdk.png)


走到蓝色传送门处，从蓝色传送门进入，橙色传送门出即可。

### 数据范围

对于 $20\%$ 的数据，$n \le 10$。

对于 $60\%$ 的数据，$n \le 100$。

对于另外 $10\%$ 的数据，$T=1$ 且不存在虚空。

对于 $100\%$ 的数据，$2 \le n \le 500$，$1 \le T \le 10$。

## 样例 #1

### 输入

```
2
5
..###
#.#.#
#..##
...#.
.###.
5
..#..
##..#
#.#..
..#..
.#...```

### 输出

```
2
2```

## 样例 #2

### 输入

```
4
5
...*.
*##*.
#..*.
#*###
.....
5
.#*..
.**.#
###.*
***.*
**...
5
.**..
***.#
###.*
***.*
*****
5
.**..
***.#
###..
***.*
***..```

### 输出

```
4
2
```

## 样例 #3

### 输入

```
见下发文件portal1.in```

### 输出

```
见下发文件portal1.ans```

## 样例 #4

### 输入

```
见下发文件portal2.in```

### 输出

```
见下发文件portal2.ans```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Portal 深入学习指南 💡

> 今天我们来一起分析 **Portal** 这道 C++ 编程题。它不仅考察了最短路算法，还考验我们如何把复杂的“传送门”规则抽象成图论模型。我们将一步步拆解题意，像游戏通关一样找到最优策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
把“传送门枪”与“二维迷宫”这两个看似风马牛不相及的概念，**抽象成一张带权有向图**，并求出从起点到终点的最短路径。

✨ **核心算法标签**：  
BFS、01-BFS、最短路、图论建模

🗣️ **初步分析**：  
- 暴力 DFS（指数级）只能骗 20% 的小数据。  
- 60% 的数据提示我们：需要 **带剪枝的 BFS** 或 **01-BFS**。  
- 100% 的数据（n≤500）要求 **O(n²) ~ O(n² log n)** 的算法。  
- 正解的关键是 **把“连通块 + 传送门”转化为一张边权只有 0 或 1 的图**，再用 **01-BFS** 或 **Dijkstra** 求最短路。

> 可以把“连通块”想象成游戏中的“房间”，传送门则是“房间之间的单向传送通道”。我们要找的就是从起点房间到终点房间的“最少传送次数”。

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：  
   “最少使用多少次传送门枪” → **经典最短路径** 问题。

2. **线索2 (问题约束)**：  
   传送门只能在墙上，且同色门唯一 → **需要预处理所有“门位”并建图**。

3. **线索3 (数据规模)**：  
   n≤500 → 总点数约 2.5×10⁵，边数约 10⁶，**01-BFS O(E)** 或 **Dijkstra O(E log V)** 均可通过。

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，**线索1** 告诉我们这是“求最短路”，BFS/Dijkstra 是候选。  
> 2. 接着，**线索2** 的“门只能在墙上”提示我们：  
>    - 先找出所有“空地连通块”（房间）。  
>    - 再找出“哪些房间之间可以通过一扇门互达”。  
> 3. 最后，**线索3** 确认：  
>    - 用 **01-BFS** 可以在 O(E) 解决（边权只有 0 或 1）。  
> 4. **结论**：  
>    - **把每个连通块缩成点**，在可互达的块之间连边权为 1 的**有向边**，跑 **01-BFS** 即可。

---

## 2. 精选优质题解参考

### 题解一：官方题解（andychen_2012）

- **点评**：  
  这份官方题解思路清晰，先 **BFS 找连通块**，再 **枚举墙与空地关系** 建图，最后 **Dijkstra 求最短路**。  
  亮点在于用 `only[id][0/1]` 记录每个连通块是否**唯一接壤**某面墙，避免重复建边；用 `map<pair<int,int>,bool>` 去重，简洁高效。  
  代码风格规范，变量命名直观，值得借鉴。

### 题解二：SteveHans 的 01-BFS 解法

- **点评**：  
  将每个 **(x,y)** 直接视为图上的节点，利用 **边权为 0（空地移动）或 1（传送门）** 的特性，跑 **01-BFS** 得到 O(n²) 的最短路。  
  代码简洁，用 `deque` 实现 0/1 边权的双端队列优化，思路非常直观，适合初学者理解 **01-BFS** 的精髓。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：01-BFS 图论建模）

1. **关键点1：如何快速找连通块？**  
   - **分析**：使用 **BFS/DFS** 把四方向连通的 `.` 标记成同一个块编号。  
   - 💡 **学习笔记**：二维网格连通块 → 模板化的 Flood-Fill。

2. **关键点2：如何判定两个连通块能否“传送”？**  
   - **分析**：  
     - 对于每一堵墙，向上下左右**射线**扫描，找到最近的两个不同连通块。  
     - 若这两个块之间仅隔**一堵墙**，且都能在该墙上开门，则连一条 **双向边**（官方题解）或 **单向边**（SteveHans）。  
   - 💡 **学习笔记**：射线扫描可 O(n²) 完成，注意边界墙同样视为 `#`。

3. **关键点3：如何高效求最短路？**  
   - **分析**：  
     - 边权只有 0（空地移动）或 1（传送门） → **01-BFS** 最优。  
     - 用 `deque<int>`：0 边权走队头，1 边权走队尾，均摊 O(E)。  
   - 💡 **学习笔记**：01-BFS 是 **0/1 边权图** 的“免堆 Dijkstra”。

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景/得分预期 |
|------|----------|------|------------|--------------------|
| **暴力 DFS** | 递归枚举每一步 | 思路直观 | 指数级 O(2^E)，n>10 即超时 | 20% 数据 |
| **普通 BFS** | 仅处理空地移动 | 无法处理传送门 | 忽略传送门，答案错误 | 不适用 |
| **官方建图+Dijkstra** | 缩点+建图+堆优化 | 思路清晰，通用 | 需要建图+堆，常数较大 | 100% |
| **01-BFS 直接跑** | 不缩点，0/1边权 | 代码短，常数小 | 节点数多，需要开大数组 | 100% 推荐 |

---

### ✨ 优化之旅：从“能做”到“做好”

1. **起点：暴力 DFS**  
   指数级爆炸，无法通过。

2. **瓶颈：状态爆炸**  
   传送门状态难以直接存储。

3. **突破：图论建模**  
   将“连通块”缩点，传送门转化为边，问题瞬间降维。

4. **升华：01-BFS**  
   利用 0/1 边权特性，去掉 log 因子，代码更简洁。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（01-BFS 版）

- **说明**：综合 SteveHans 思路，提供完整可编译的 01-BFS 实现。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int N = 510, M = N * N, E = 2e6 + 10;
char g[N][N];
int id[N][N], idx;
int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};
int n;

struct Edge { int to, nxt, w; } e[E];
int h[M], cnt;
void add(int a, int b, int c) {
    e[++cnt] = {b, h[a], c}, h[a] = cnt;
}

void build() {
    // 1. 给每个空地编号
    idx = 0;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            id[i][j] = ++idx;

    // 2. 空地四连通的 0 权边
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) if (g[i][j] == '.')
            for (int d = 0; d < 4; ++d) {
                int x = i + dx[d], y = j + dy[d];
                if (x < 1 || x > n || y < 1 || y > n) continue;
                if (g[x][y] == '.') add(id[i][j], id[x][y], 0);
            }

    // 3. 向四个方向射线找墙，连 1 权边
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) if (g[i][j] == '.') {
            // 右
            for (int k = j + 1; k <= n; ++k) if (g[i][k] == '#') { add(id[i][j], id[i][k], 1); break; }
            // 左
            for (int k = j - 1; k >= 1; --k) if (g[i][k] == '#') { add(id[i][j], id[i][k], 1); break; }
            // 下
            for (int k = i + 1; k <= n; ++k) if (g[k][j] == '#') { add(id[i][j], id[k][j], 1); break; }
            // 上
            for (int k = i - 1; k >= 1; --k) if (g[k][j] == '#') { add(id[i][j], id[k][j], 1); break; }
        }
}

int bfs01() {
    deque<int> q;
    vector<int> dist(M, 1e9);
    int s = id[1][1], t = id[n][n];
    dist[s] = 0;
    q.push_back(s);

    while (!q.empty()) {
        int u = q.front(); q.pop_front();
        for (int i = h[u]; i; i = e[i].nxt) {
            int v = e[i].to, w = e[i].w;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                w ? q.push_back(v) : q.push_front(v);
            }
        }
    }
    return dist[t] == 1e9 ? -1 : dist[t];
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T; cin >> T;
    while (T--) {
        cin >> n;
        for (int i = 1; i <= n; ++i) cin >> (g[i] + 1);
        if (g[1][1] != '.' || g[n][n] != '.') { cout << -1 << '\n'; continue; }

        memset(h, 0, sizeof h); cnt = 0;
        build();
        cout << bfs01() << '\n';
    }
    return 0;
}
```

---

### 官方题解核心片段赏析

- **亮点**：  
  用 `only[g][0/1]` 记录每个连通块**唯一接壤的墙坐标**，避免重复建边。

```cpp
// 枚举每堵墙，尝试连接左右/上下连通块
for (int k = j - 1; k >= 1 && s[i][k] != '#'; --k) {
    int c = col[i][k];
    if (!c) continue;
    for (int l = 1; l <= 4; ++l) {
        if (cango[l] == -1 || c == cango[l]) continue;
        if (only[c][0] == -1) continue;   // 无唯一墙
        if (mps.count({c, cango[l]})) continue;
        mps[{c, cango[l]}] = 1;
        add(cango[l], c);                 // 建单向边
    }
}
```

- **学习笔记**：  
  通过“唯一墙”技巧，将 O(n⁴) 暴力枚举优化到 O(n²)。

---

## 5. 算法可视化：像素动画演示

### 主题：**“像素探险家”在迷宫中使用传送门**

- **场景**：8×8 像素网格，蓝色=空地，灰色=墙，黄色=起点，绿色=终点。
- **传送门特效**：  
  - 当玩家射出传送门时，对应墙格子闪红光，播放 8-bit “传送门开启”音效。
- **01-BFS 演示**：  
  - 队列用像素化“能量条”展示，0 边权（空地移动）→ 能量条左侧快速填充；1 边权（传送）→ 右侧慢速填充。
- **交互**：  
  - 单步 / 自动 / 重置按钮。  
  - 侧边栏实时显示当前节点坐标与最短距离。
- **游戏化**：  
  - 每成功“传送”一次，播放“叮”并加分；通关后播放 8-bit 胜利 BGM。

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**：  
  01-BFS 适用于“边权只有 0 或 1”的最短路，如：
  1. 双端队列优化 0/1 最短路。  
  2. 分层图最短路（可 0 成本“跳跃”）。  
  3. 滑动拼图问题（移动代价 1，旋转代价 0）。

- **洛谷推荐**：
  1. **P1363** 迷宫问题：01-BFS 模板。  
  2. **P4667** 传送门：分层图最短路。  
  3. **P1443** 马的遍历：多源 BFS 变形。

---

## 7. 学习心得与经验分享

> **官方题解作者 andychen_2012**：  
> “最初 std 漏掉了一次判断，竟神奇地没被卡掉。经过对拍才发现，手造数据恰好避开了 bug。写题解时才发现，严谨性才是算法竞赛的生命线。”

- **点评**：  
  提醒我们：写完代码后务必构造极端数据，**边界墙、虚空连通块、唯一墙** 都要覆盖。

---

<conclusion>
今天我们完成了 Portal 的深度解析。从“连通块抽象”到“01-BFS 优化”，每一步都体现了图论建模的艺术。希望大家在今后的比赛中，也能像像素探险家一样，用算法打开通往胜利的大门！
</conclusion>

---
处理用时：111.03秒
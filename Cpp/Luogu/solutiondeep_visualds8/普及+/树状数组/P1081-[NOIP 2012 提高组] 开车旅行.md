# 题目信息

# [NOIP 2012 提高组] 开车旅行

## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。


## 说明/提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。


## 样例 #1

### 输入

```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3
```

### 输出

```
1 
1 1 
2 0 
0 0 
0 0 ```

## 样例 #2

### 输入

```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7```

### 输出

```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：开车旅行 深入学习指南 💡

> 同学们好！今天我们来攻克 2012 NOIP 提高组 T3《开车旅行》。这道题看似在讲“自驾游”，实则暗藏“倍增”这一神器。跟着洛语云笺，我们一起把复杂路况变成清晰算法路线！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“如何在只能向东开的前提下，快速回答『从任意起点出发、给定总里程上限，小 A / 小 B 各自会走多远』”。  
核心在于：  
1. **预处理**：为每个城市快速找到“最近”与“次近”的东边城市（O(n log n) 以内）。  
2. **快速查询**：在 10^5 次询问下，每次仅用 log n 级别时间算出两人行驶距离。

✨ **核心算法标签**：倍增（Binary Lifting）、双向链表/有序集合、贪心

🗣️ **思路概览**  
- 朴素暴力：O(n^2) 枚举起点，再 O(n) 模拟每一步 → 数据范围 1e5 直接爆炸。  
- 优化 1：先 O(n log n) 预处理每个点的“下一站”，再用倍增把 O(n) 模拟压缩到 O(log n)。  
- 优化 2：把“两人轮流”视为一个整体 2 步循环，倍增数组一次性记录 2^k 轮后的终点与两人路程。

> 比喻：想象两人在高速公路上轮流驾驶，每 2^k 公里就换一块路牌，提前把路牌信息存好，查询时像跳棋一样“跳”到目的地！

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现与分析 |
|---|---|
| **1. 问题目标** | “求比值最小 / 求具体路程” → 需要快速计算“给定起点、上限里程”下的两人路程。 |
| **2. 数据规模** | n, m ≤ 1e5 → 总复杂度必须 ≤ O(n log n)。 |
| **3. 方向限制** | 只能向东 → 天然线性顺序，可用“排序+链表”或“平衡树”维护最近/次近。 |
| **4. 轮流驾驶** | 每两天为一个固定循环 → 可把“2 步”封装成一个整体，倍增数组直接记录 2^k 个循环后的状态。 |

---

### 🧠 思维链构建：从线索到策略
> “把 2 步循环当作 1 步整体，再用倍增压缩查询”——这就是本题的钥匙！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|---|---|
| **yangrunze** (赞：99) | 完整讲述“双向链表+倍增”思路，代码清晰，边界处理到位。 |
| **star_fish** (赞：76) | 用 `priority_queue` 优化链表初始化，细节详尽，附 80pts→AC 的优化过程。 |
| **Neumann** (赞：3) | 用 `set` 替代链表，展示 STL 写法；将 2 步循环整体倍增，简化转移。 |

> 洛语云笺点评：三份题解思路一致，但实现风格各异：链表朴素高效、set 简洁易写、p_queue 常数更小，同学们可按喜好选择。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **预处理最近/次近城市**  
   - 将城市按海拔排序，用双向链表或 `set` 维护前驱后继。  
   - 每处理完一个城市就“删除”它，保证后续城市编号更大。  
   - 只需比较至多 4 个候选即可找到最近与次近。

2. **倍增数组设计**  
   - 设 `f[k][i]` 表示从 i 出发走 2^k 个“AB 循环”后到达的城市。  
   - 设 `da[k][i]` / `db[k][i]` 表示这 2^k 个循环里 A / B 各自行驶的总距离。  
   - 转移：`f[k][i] = f[k-1][f[k-1][i]]`，距离累加即可。

3. **查询 calc(s, x)**  
   - 从大到小枚举 k，若还能走 2^k 个循环就跳，并累加距离。  
   - 最后单独处理可能剩余的 1 步（仅 A 再走一次）。

### ✨ 解题技巧总结
- **技巧 A：问题转化**——把“两人轮流”抽象成“2 步循环”，倍增一次解决。  
- **技巧 B：数据结构辅助**——链表/平衡树维护最近/次近，O(n log n) 完成预处理。  
- **技巧 C：边界与精度**——比值比较用交叉相乘避免浮点误差，0 路程特殊处理。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 复杂度 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力模拟** | O(n^2) | 思路直观 | 无法通过 1e5 数据 | 对拍或 n ≤ 200 |
| **倍增 + 链表** | O(n log n) | 常数小、思路清晰 | 代码稍长 | 100% 数据、竞赛首选 |
| **倍增 + set** | O(n log n) | 代码短、易调试 | set 常数略大 | 对代码速度不极端敏感 |

### ✨ 优化之旅：从“能做”到“做好”
> “暴力”→“发现可倍增”→“抽象 2 步循环”→“链表/平衡树预处理”→“log 查询”  
> 这一整套思维链，正是竞赛中“逐步优化”的经典范例！

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 来源：综合 yangrunze 与 star_fish 思路，保证完整可 AC。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10, LOG = 20;
struct City { int h, id, pre, nxt; } c[N];
bool cmp(const City &a, const City &b) { return a.h < b.h; }
int n, pos[N], ga[N], gb[N];
int f[LOG][N][2];          // 2^k 步后到达的城市 (0:A先开,1:B先开)
ll da[LOG][N][2], db[N][LOG][2];

inline int choose(int a, int b, int i) {
    if (!a || !b) return a + b;
    ll da = abs(c[i].h - c[a].h), db = abs(c[i].h - c[b].h);
    return (da < db || (da == db && c[a].h < c[b].h)) ? a : b;
}

void del(int p) {               // 双向链表删除
    if (c[p].pre) c[c[p].pre].nxt = c[p].nxt;
    if (c[p].nxt) c[c[p].nxt].pre = c[p].pre;
}

void init() {
    for (int i = 1; i <= n; ++i) c[i].pre = i - 1, c[i].nxt = i + 1;
    c[1].pre = c[n].nxt = 0;
    for (int i = 1; i < n; ++i) {
        int p = pos[i], l = c[p].pre, r = c[p].nxt;
        if (l && (!r || abs(c[p].h - c[l].h) <= abs(c[p].h - c[r].h)))
            gb[i] = c[l].id, ga[i] = choose(c[l].pre, r, p);
        else
            gb[i] = c[r].id, ga[i] = choose(l, c[r].nxt, p);
        del(p);
    }
    int lg = __lg(n) + 1;
    for (int i = 1; i <= n; ++i) {
        f[0][i][0] = ga[i], f[0][i][1] = gb[i];
        if (ga[i]) da[0][i][0] = abs(c[pos[i]].h - c[pos[ga[i]]].h);
        if (gb[i]) db[0][i][1] = abs(c[pos[i]].h - c[pos[gb[i]]].h);
    }
    for (int k = 1; k <= lg; ++k)
        for (int i = 1; i <= n; ++i)
            for (int t = 0; t < 2; ++t) {
                int nxt = f[k - 1][i][t];
                if (!nxt) continue;
                int nt = (k == 1) ? (t ^ 1) : t;
                f[k][i][t] = f[k - 1][nxt][nt];
                da[k][i][t] = da[k - 1][i][t] + da[k - 1][nxt][nt];
                db[k][i][t] = db[k - 1][i][t] + db[k - 1][nxt][nt];
            }
}

pair<ll, ll> calc(int s, ll x) {
    ll la = 0, lb = 0;
    int k = 0;
    for (int i = __lg(n) + 1; i >= 0; --i) {
        if (f[i][s][k] && da[i][s][k] + db[i][s][k] <= x) {
            x -= da[i][s][k] + db[i][s][k];
            la += da[i][s][k], lb += db[i][s][k];
            s = f[i][s][k];
            if (!i) k ^= 1;
        }
    }
    return {la, lb};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> c[i].h, c[i].id = i;
    sort(c + 1, c + n + 1, cmp);
    for (int i = 1; i <= n; ++i) pos[c[i].id] = i;
    init();
    ll X; int m;
    cin >> X;
    int best = 1;
    auto [la, lb] = calc(1, X);
    for (int i = 2; i <= n; ++i) {
        auto [a, b] = calc(i, X);
        if (!b) a = 1;
        if (a * lb < b * la || (a * lb == b * la && c[pos[i]].h > c[pos[best]].h))
            best = i, la = a, lb = b;
    }
    cout << best << '\n';
    cin >> m;
    while (m--) {
        int s; ll x; cin >> s >> x;
        auto [a, b] = calc(s, x);
        cout << a << ' ' << b << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 主题：**《像素高速·AB接力》**

- **场景**：8-bit 像素风横向公路，城市用彩色方块表示，海拔高低对应方块高度。  
- **核心逻辑**：  
  1. **预处理阶段**：  
     - 排序后城市排成一排，双向链表用箭头连接左右邻居。  
     - 动画高亮当前处理的方块，删除后闪烁消失，保证“向东”方向。  
  2. **倍增阶段**：  
     - 生成 2^k 像素长“接力棒”，棒上写“终点城市 + A路程 + B路程”。  
     - 逐帧展示 `f[k][i]`、`da[k][i]`、`db[k][i]` 的更新：  
       - 先显示 2^(k-1) 段，再复制粘贴到 2^k，用“像素爆炸”特效。  
  3. **查询阶段**：  
     - 玩家输入起点 s 与里程 x，像素车从 s 出发。  
     - 控制面板：步进 / 自动 / 调速滑块。  
     - 每跳一次 2^k，屏幕左上角弹出像素对话框：“A +123 km, B +45 km”。  
     - 终点到达时播放 8-bit 胜利音效，像素礼花。

- **旁白示例**：  
  - “现在跳到 2^3 = 8 轮后，A 共行驶 321 km，B 共行驶 234 km！”  
  - “比值 321:234，是否刷新最小记录？”

---

## 6. 拓展练习与相似问题思考

- **技巧迁移**：倍增思想同样适用于  
  1. 树上 LCA（最近公共祖先）  
  2. 区间最值 RMQ（ST 表）  
  3. 快速幂 / 矩阵快速幂

- **洛谷推荐**  
  1. **P3379** 【模板】最近公共祖先（LCA）  
     *推荐理由*：同样用倍增压缩路径，巩固数组设计。  
  2. **P3865** 【模板】ST 表  
     *推荐理由*：区间最值的倍增思想，与本题预处理异曲同工。  
  3. **P1082** 同余方程  
     *推荐理由*：练习快速幂，体会指数级加速。  
  4. **P1967** 货车运输  
     *推荐理由*：树上倍增 + 二分答案，综合应用。

---

## 7. 学习心得与经验分享

> **yangrunze 的调试心得**：  
> “双向链表边界易错：删除节点前一定检查前驱/后继是否为 0，否则会出现野指针。”  
> **洛语云笺点评**：链表虽小，细节决定成败，动手画图是排错利器！

---

<conclusion>
至此，《开车旅行》的全部奥秘已揭晓：  
- **预处理**用链表/平衡树找最近、次近；  
- **倍增**把两人 2 步循环压缩成 log n 查询；  
- **可视化**让算法“跑”起来。  
希望大家把倍增这把瑞士军刀收入工具箱，下次遇见“长链式”问题，也能优雅地“跳”到答案！
</conclusion>

---
处理用时：391.20秒
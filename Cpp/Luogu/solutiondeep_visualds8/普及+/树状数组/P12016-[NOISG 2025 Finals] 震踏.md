# 题目信息

# [NOISG 2025 Finals] 震踏

## 题目描述

Bunnyland 有广阔的田野，Bunnyland 矮兔（一种本地兔子物种）在其中自由活动。其中一个田野可以建模为一个 $10^9 \times 10^9$ 的网格单元。网格的行从北到南编号为 $1$ 到 $10^9$，网格的列从西到东编号为 $1$ 到 $10^9$。我们将网格中位于第 $r$ 行、第 $c$ 列的单元格称为单元格 $(r, c)$。

在这片田野中，有 $n$ 只兔子，编号从 $1$ 到 $n$。第 $i$ 只兔子最初位于单元格 $(r[i], c[i])$。**最初没有两只兔子位于同一个单元格**。

当兔子感到烦躁时，它们会抬起后腿并踢打地面，这一动作被称为震踏。这 $n$ 只兔子将执行一系列 $m$ 次震踏。在第 $j$ 秒开始时，编号为 $t[j]$ 的兔子会进行震踏。当一只兔子震踏时，所有其他兔子都会远离震踏的兔子。

![](https://cdn.luogu.com.cn/upload/image_hosting/1auwto2s.png)

具体来说，当兔子 A 震踏时，兔子 B 将按照以下方式移动：

- 如果 A 和 B 之间的行数小于列数，则 B 将在列方向上远离 A 两列。
- 如果 A 和 B 之间的行数等于列数，则 B 将在列方向和行方向各远离 A 一格。
- 如果 A 和 B 之间的行数大于列数，则 B 将在行方向上远离 A 两行。

可以证明，在震踏发生后，兔子的位置仍然是唯一的。

兔子 Benson 在退休后寻找它的同类，但由于震踏的发生，兔子们四散开来。请帮助 Benson 确定在所有震踏发生后 $n$ 只兔子的最终位置！

可以保证，在震踏序列过程中，兔子不会离开网格。你也可以假设，兔子在任何情况下都不会移动，除了震踏。


## 说明/提示

### 子任务

对于所有测试用例，输入将满足以下约束条件：

- $1 \leq n, m \leq 500\,000$
- 对于所有 $1 \leq i \leq n$，有 $1 \leq r[i], c[i] \leq 10^9$
- 对于所有 $1 \leq j \leq m$，有 $1 \leq t[j] \leq n$
- 对于所有 $i \neq j$，有 $(r_i, c_i) \neq (r_j, c_j)$
- 可以保证，在震踏序列过程中，兔子不会离开网格。

你的程序将在满足以下特殊性质的输入数据上进行测试：

| 子任务 | 分数 | 特殊性质 |
| :-: | :-: | :-: |
| $0$ | $0$ | 样例 |
| $1$ | $18$ | $n, m \leq 2000$ |
| $2$ | $21$ | $r[i] = 1$ |
| $3$ | $32$ | $n \leq 2000$ |
| $4$ | $13$ | $n \leq 100\,000$ |
| $5$ | $16$ | 无 |

### 样例 1 解释

此测试用例适用于子任务 $1, 3, 4, 5$。

兔子 $1$ 处于单元格 $(1, 1)$，兔子 $2$ 处于单元格 $(2, 2)$。

由于兔子 $1$ 和兔子 $2$ 之间的行数等于列数，因此当兔子 $1$ 震踏时，兔子 $2$ 会在东南方向各远离一格，最终到达单元格 $(3, 3)$。震踏的兔子 $1$ 位置保持不变。

### 样例 2 解释

此样例适用于子任务 $1, 3, 4, 5$。

题目中的图示对应于此测试用例。蓝色箭头显示了当编号为 $1$ 的兔子（位于单元格 $(7, 7)$）震踏时，其他兔子的移动方式。

### 样例 3 解释

此样例适用于所有子任务。


## 样例 #1

### 输入

```
2 1
1 1
2 2
1```

### 输出

```
1 1
3 3```

## 样例 #2

### 输入

```
13 1
7 7
3 7
4 4
4 10
5 6
6 4
6 8
8 7
8 10
9 3
9 5
9 9
10 6
1```

### 输出

```
7 7
1 7
3 3
3 11
3 6
6 2
5 9
10 7
8 12
9 1
10 4
10 10
12 6```

## 样例 #3

### 输入

```
3 2
1 10
1 20
1 30
1 3```

### 输出

```
1 8
1 20
1 32```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：[NOISG 2025 Finals] 震踏 深入学习指南 💡

今天我们来一起分析“震踏”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
**在 50 万次操作、50 万只兔子的规模下，如何高效模拟“每只兔子被震踏后集体位移”的过程，而不陷入 O(n·m) 的暴力泥潭。**

✨ **核心算法标签**：  
坐标旋转 · 离散化 · 前缀和/树状数组 · 差分数组 · 二分

🗣️ **初步分析**：  
- 朴素思路：每来一只兔子震踏，就扫描其余 n-1 只兔子更新坐标 → O(n·m) 直接爆炸。  
- 观察突破口：题目保证“相对顺序永不变”——这意味着**每只兔子被哪几次操作影响是固定的**，可以把问题拆成“统计每只兔子在 x、y 方向各被向左/向右推了多少次”。  
- 坐标旋转 45° 后，复杂的斜向移动变成**轴对齐的区间 ±2**，于是可以用**前缀和/树状数组/二分**在 log 级别完成统计。  
- 一个生动的比喻：把棋盘旋转 45°，斜向的“跳马”变成直线“跳车”，我们就可以用尺子（前缀和）快速量出位移量。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题规模)**：n,m ≤ 5×10⁵ → 只能接受 O(n log n) 或 O(m log n) 级别。
2. **线索2 (位移规律)**：行差与列差的相对大小决定方向 → 暗示**旋转坐标系**把斜向变轴向。
3. **线索3 (不变量)**：“相对顺序永不变” → 每只兔子的影响区间**不随时间变化**，可离线统计。

### 🧠 思维链构建：从线索到策略
> 1. 看到 5e5 的规模，脑中立刻响起警报：O(n·m) 绝不可行。  
> 2. 再读位移规则，发现行差 vs 列差是关键——这像极了切比雪夫距离，于是想到把平面旋转 45°。  
> 3. 旋转后，复杂的“斜向 +2/-2” 变成简单的“轴向区间 ±2”，于是想到用**差分数组**或**树状数组**维护区间增量。  
> 4. 由于相对顺序不变，每只兔子被震踏影响的区间固定 → **离线处理**：先统计所有操作在旋转坐标系下的区间加，再一次性把增量加到每只兔子上。  
> 5. 最终复杂度 O((n+m) log n)，完美通过！

---

## 2. 精选优质题解参考

我从思路清晰度、代码规范性、算法有效性、启发性四个维度，为大家精选了 **3 份 ≥4 星题解**，并提炼其精华：

| 题解作者 | 亮点提炼 | 洛语云笺点评 |
| :-- | :-- | :-- |
| **_zhangcx** (★★★★★) | 1. 率先提出“旋转 45° + 树状数组” 路线；<br>2. 用离散化解决 1e⁹ 值域；<br>3. 赛后从线段树 TLE 改树状数组 AC，给出**常数优化**实例。 | “考场踩坑实录”极具参考价值：线段树→树状数组的切换告诉我们，**常数差距**在 5e5 量级下是致命的。 |
| **Shimarin1001** (★★★★☆) | 1. 用差分数组 + 排序 + 前缀和实现离线区间加；<br>2. 代码极短，逻辑清晰；<br>3. 坐标转换细节讲解到位。 | 差分数组的优雅实现适合初学树状数组前的过渡，**“短码即正义”**的典范。 |
| **hanyu0722** (★★★★☆) | 1. 发现“震踏满足交换律”，直接**二分统计影响次数**；<br>2. 不依赖高级数据结构，纯 STL + 二分通过；<br>3. 复杂度 O(n log m + m log m)。 | 提供了一条**“无树状数组”**的另类思路，对尚未掌握 BIT 的同学非常友好。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析与技巧 |
| :-- | :-- |
| **坐标旋转** | 将原坐标 (r,c) 映射到 (r+c, r-c)。这样，原题中“斜向 ±2” 变成新坐标系中“x 轴 ±2” 或 “y 轴 ±2”，可用区间数据结构维护。 |
| **离散化** | 新坐标范围可达 ±2×10⁹，需用 `lower_bound` + 排序去重把坐标压缩到 1…n。 |
| **离线区间加** | 把 m 次震踏看作 m 个区间 [L,R] 的“+2/-2” 操作：<br>- 差分数组：O(n+m) 空间，O(1) 区间加，最后前缀和还原；<br>- 树状数组：O(log n) 区间加/单点查，代码短常数小。 |
| **还原坐标** | 最终把 (x',y') 转回 (r,c)：<br>`r = (x'+y')/2`, `c = (x'-y')/2`，注意整型溢出。 |

💡 学习笔记：  
> “旋转坐标”是处理**斜向运动/斜向距离**的通用技巧，在几何题中屡试不爽！

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 优缺点 | 得分预期 |
| :-- | :-- | :-- | :-- | :-- |
| **暴力模拟** | 每操作扫描全部兔子 | O(n·m) | 思路直观，18 分到手 | 子任务1 (18分) |
| **旋转+差分数组** | 离线区间加，最后前缀和 | O((n+m) log n) | 代码最短，无需高级结构 | 100 分 |
| **旋转+树状数组** | 在线区间加，常数更小 | O((n+m) log n) | 标准竞赛写法，最稳健 | 100 分 |
| **旋转+二分计数** | 交换律+二分统计次数 | O((n+m) log m) | 无需区间结构，思路另类 | 100 分 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. 暴力模拟 → 发现 O(n·m) 超时；  
> 2. 观察规律 → 发现“相对顺序不变”；  
> 3. 旋转坐标 → 把斜向位移变成轴向区间；  
> 4. 数据结构 → 差分数组 / 树状数组 / 二分三选一；  
> 5. 离散化 → 解决 1e⁹ 值域；  
> 6. 最终 AC！

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合 _zhangcx 与 Shimarin1001 思路，使用**树状数组+离散化**，最简洁且常数优秀。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int N = 5e5 + 10;
int n, m, t[N];
struct Pt { int64 x, y; } p[N], q[N];

/* 离散化模板 */
vector<int64> xs, ys;
int getx(int64 v) { return lower_bound(xs.begin(), xs.end(), v) - xs.begin() + 1; }
int gety(int64 v) { return lower_bound(ys.begin(), ys.end(), v) - ys.begin() + 1; }

/* 树状数组区间加，单点查 */
struct Fenwick {
    int64 c[N];
    void add(int x, int64 v, int lim) { for (; x <= lim; x += x & -x) c[x] += v; }
    int64 sum(int x) { int64 r = 0; for (; x; x -= x & -x) r += c[x]; return r; }
    void range_add(int l, int r, int64 v, int lim) {
        add(l, v, lim); add(r + 1, -v, lim);
    }
} fx, fy;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        int64 r, c; cin >> r >> c;
        p[i] = {r + c, r - c};          // 旋转45°
        xs.push_back(p[i].x);
        ys.push_back(p[i].y);
    }
    /* 离散化 */
    sort(xs.begin(), xs.end()); xs.erase(unique(xs.begin(), xs.end()), xs.end());
    sort(ys.begin(), ys.end()); ys.erase(unique(ys.begin(), ys.end()), ys.end());
    int szx = xs.size(), szy = ys.size();

    for (int i = 1; i <= m; ++i) cin >> t[i];

    /* 离线区间加：所有震踏 */
    for (int i = 1; i <= m; ++i) {
        int x = getx(p[t[i]].x), y = gety(p[t[i]].y);
        fx.range_add(1, x - 1, -2, szx);
        fx.range_add(x + 1, szx,  2, szx);
        fy.range_add(1, y - 1, -2, szy);
        fy.range_add(y + 1, szy,  2, szy);
    }

    /* 单点查询+还原坐标 */
    for (int i = 1; i <= n; ++i) {
        int64 nx = p[i].x + fx.sum(getx(p[i].x));
        int64 ny = p[i].y + fy.sum(gety(p[i].y));
        cout << (nx + ny) / 2 << ' ' << (nx - ny) / 2 << '\n';
    }
    return 0;
}
```
- **代码解读概要**：  
  1. 读入并旋转变换坐标；  
  2. 离散化新坐标到 1…n；  
  3. 用两个树状数组分别维护 x、y 方向的区间 ±2；  
  4. 最后单点查询并还原原坐标输出。

### 各优质题解片段赏析

**1. _zhangcx 树状数组离散化片段**
```cpp
int gethashx(int val) { 
    return lower_bound(orix + 1, orix + totx + 1, val) - orix; 
}
```
- **亮点**：封装成函数，代码可读性高。  
- **学习笔记**：离散化函数写成宏/inline 可减少复制粘贴错误。

**2. Shimarin1001 差分数组前缀和片段**
```cpp
for (int i = 0; i < n; ++i) {
    cfa[i] += cfa[i - 1], cfb[i] += cfb[i - 1];
    _a[a[i].sp] = cfa[i], _b[b[i].sp] = cfb[i];
}
```
- **亮点**：用排序+前缀和实现区间加，空间 O(n)。  
- **学习笔记**：当区间端点可用离散化后整数表示时，差分数组是最轻量方案。

**3. hanyu0722 二分计数片段**
```cpp
int xl = lower_bound(xq + 1, xq + 1 + m, a[i].x) - xq - 1;
int xu = upper_bound(xq + 1, xq + 1 + m, a[i].x) - xq;
a[i].x -= (m - xu + 1) * 2;
a[i].x += xl * 2;
```
- **亮点**：完全不用树状数组，用两次二分统计“左侧/右侧震踏次数”。  
- **学习笔记**：当所有区间操作可离线时，排序+二分是常数极小的替代方案。

---

## 5. 算法可视化：像素动画演示

- **动画主题**：**“像素兔群大迁徙”**  
- **核心演示**：在旋转后的坐标系里，用 8×8 像素方块表示兔子，每当一次震踏发生：  
  1. 震踏兔高亮闪金光；  
  2. 左侧/右侧像素方块整排左移或右移 2 格（伴随“嘟嘟”8-bit 音效）；  
  3. 画面上方实时显示树状数组区间加过程（像素条高度表示增量）。  
- **交互面板**：  
  - 步进 / 自动播放 / 速度滑块；  
  - “重置”按钮回到初始牧场；  
  - “显示原坐标”开关，一键切换 45° 旋转前后视角。  
- **游戏化元素**：  
  - 每完成一次震踏记 1 分，连击 10 次触发“像素礼花”；  
  - 失败（坐标溢出）播放“哔——”提示音并暂停。  

---

## 6. 拓展练习与相似问题思考

| 通用技巧 | 适用场景示例 |
| :-- | :-- |
| 坐标旋转 45° | 斜向移动、切比雪夫距离、菱形区域统计 |
| 离散化+区间数据结构 | 值域巨大但点数有限（如 1e9 坐标，5e5 点） |
| 离线差分/前缀和 | 多次区间加，最后统一求值 |

**洛谷推荐练习**  
1. **P1972** HH的项链  
   * 利用离散化+树状数组做离线区间统计。  
2. **P3368** 树状数组 2 —— 区间加、单点查  
   * 震踏区间加的最小原型。  
3. **P1908** 逆序对  
   * 练习离散化+树状数组/归并排序。  
4. **P4559** 序列  
   * 综合考察差分数组与区间最值。

---

## 7. 学习心得与经验分享

> **Shimarin1001 后记**：  
> “作为首批参加 NOISG 的国内选手，我考场上维护了两棵线段树，导致最后一个点超时。提醒各位，**注意常数优化**。”  
> **洛语云笺点评**：  
> 在 5e5 规模下，树状数组常数 ≈ 线段树的 1/3～1/4。选错数据结构可能直接决定 AC/TLE。牢记：**能 BIT 不线段，能差分不 BIT**。

---

<conclusion>
本次“震踏”之旅展示了如何把看似复杂的集体位移问题，通过**坐标旋转 + 离散化 + 区间数据结构**优雅地化繁为简。希望大家把“旋转坐标”和“离线区间加”两把钥匙收入囊中，下次遇到斜向难题也能从容应对！
</conclusion>
```

---
处理用时：82.23秒
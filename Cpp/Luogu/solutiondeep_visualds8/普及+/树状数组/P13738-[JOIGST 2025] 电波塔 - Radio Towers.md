# 题目信息

# [JOIGST 2025] 电波塔 / Radio Towers

## 题目描述

在 EGOI 国，有 $N$ 座电波塔沿东西方向排列，为国民提供互联网通信服务。电波塔从西向东依次编号为 $1$ 到 $N$。每座电波塔 $i$（$1 \leq i \leq N$）具有以下功能：

- 接收西向波长范围 $[A_i, A_i + L]$ 的电波；
- 向东发射固定波长 $B_i$ 的电波。

对于两座满足 $1 \leq i_1 < i_2 \leq N$ 的塔 $i_1, i_2$，当满足 $A_{i_2} \leq B_{i_1} \leq A_{i_2} + L$ 时，信息可从塔 $i_1$ 传输到塔 $i_2$。

EGOI 国政$ $府将通信稳定性定义为**满足顺序传输条件的非空子集数量**。具体来说，如果子集 $S = {i_1, i_2, \dots, i_k}$（$i_1 < i_2 < \cdots < i_k$）满足以下条件，则 $S$ 满足顺序传输条件：

- 对于任意相邻的两座塔 $(i_j, i_{j+1})$（$1 \leq j \leq k-1$），都满足 $A_{i_{j+1}} \leq B_{i_j} \leq A_{i_{j+1}} + L$。

给定电波塔参数，计算符合条件的子集数量模 $10^9 + 7$ 的结果。

## 说明/提示

#### 【样例解释 #1】

考虑选择电波塔 $1, 2, 3$ 的情况。

  - 由于不满足 $A_2 \leq B_1 \leq A_2 + L$，因此无法从电波塔 $1$ 向电波塔 $2$ 传输信息。
  - 由于满足 $A_3 \leq B_2 \leq A_3 + L$，因此可以从电波塔 $2$ 向电波塔 $3$ 传输信息。

所以，这种选择方式不满足条件。

考虑选择电波塔 $1, 3$ 的情况。

  - 由于满足 $A_3 \leq B_1 \leq A_3 + L$，因此可以从电波塔 $1$ 向电波塔 $3$ 传输信息。

所以，这种选择方式满足条件。

满足条件的塔的选择方式有 $\lbrace1\rbrace, \lbrace2\rbrace, \lbrace3\rbrace, \lbrace1, 3\rbrace, \lbrace2, 3\rbrace$ 这 $5$ 种。因此，输出 $5\bmod (10^9 + 7) = 5$。

此样例满足所有子任务的限制。

#### 【样例解释 #2】

该样例满足子任务 $1,2,4$ 的限制。

#### 【样例解释 #3】

该样例满足子任务 $1,2,4$ 的限制。

#### 【数据范围】

-   $2 \leq N \leq 300\,000$。
-   $0 \leq L \leq 300\,000$。
-   $1 \leq A_i \leq 300\,000$（$1\leq i \leq N$）。
-   $1 \leq B_i \leq 300\,000$（$1\leq i \leq N$）。
-   输入的所有值都是整数。

#### 【子任务】

1. （$20$ 分）$N \leq 16$。
2. （$20$ 分）$N \leq 5\,000$。
3. （$25$ 分）$L = 0$。
4. （$35$ 分）无附加限制。

## 样例 #1

### 输入

```
3 0
1 3
2 3
3 2```

### 输出

```
5```

## 样例 #2

### 输入

```
8 2
1 3
5 1
6 7
7 5
5 2
2 1
3 1
1 6```

### 输出

```
36```

## 样例 #3

### 输入

```
10 3
1 5
2 3
2 4
5 4
10 7
7 9
4 3
3 7
7 7
6 5```

### 输出

```
109```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：电波塔 / Radio Towers 深入学习指南 💡

今天我们来一起分析 JOIGST 2025 的「电波塔」这道 C++ 编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在 N 座依次编号的电波塔中，找到**所有满足“顺序传输条件”的非空子集数量**，并对 1 000 000 007 取模。  
“顺序传输条件”要求：子集中任意相邻两塔 i < j 必须满足  
`A_j ≤ B_i ≤ A_j + L`。

✨ **核心算法标签**：动态规划 (DP)、树状数组 (Fenwick)、线段树 (Segment Tree)、区间求和优化

🗣️ **初步分析**：  
- 暴力枚举所有 2ᴺ 个子集显然不可行（N ≤ 3×10⁵）。  
- 观察到“顺序传输”具有**传递性**，可以把问题转化为“以 i 结尾的合法序列数”——典型的 **DP + 区间查询** 模型。  
- 因此，**树状数组/线段树** 这把“区间求和利器”就是我们打开大门的钥匙。

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**：要求统计“所有满足条件的子集数量”，属于 **计数型 DP**。
2.  **线索2 (问题约束)**：条件 `A_j ≤ B_i ≤ A_j + L` 把**前驱塔**限制在**值域区间**内，暗示 **区间求和数据结构**。
3.  **线索3 (数据规模)**：N ≤ 3×10⁵，O(N²) 会超时，O(N log N) 可行，正好与树状数组/线段树匹配。

### 🧠 思维链构建：从线索到策略
> “好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1.  **线索1**告诉我们这是一个计数问题，我想到用 DP 把“以谁结尾”作为状态。
> 2.  **线索2**把前驱限制在 `B_i ∈ [A_j, A_j+L]` 这一**值域区间**，自然想到用树状数组维护 B_i 的 DP 值之和。
> 3.  **线索3**把时间复杂度锁在 O(N log N)，树状数组短小精悍，成为首选。
> 4.  **结论**：用 DP 定义状态，用树状数组实现区间求和与单点更新，这就是我们的主攻方向！”

---

## 2. 精选优质题解参考

<eval_intro>
我按“思路清晰度、代码规范、算法有效性、启发性”四个维度，为大家精选了以下 **≥4星** 的优质题解。
</eval_intro>

**题解一：Mindulle (赞：3)**
* **点评**：  
  思路最简洁，直接给出  
  `dp[i] = 1 + Σ_{j<i, A_i ≤ B_j ≤ A_i+L} dp[j]`，  
  并明确指出这是“区间求和 → 树状数组”的经典套路。代码仅 30 行，变量命名直观，把树状数组的 `add / getsum` 封装得干净利落，非常适合初学者模仿。  
  注意点也贴心提示：**下标开到 6×10⁵**、**先加 mod 再取模防止负数**。

**题解二：xAlec (赞：1)**
* **点评**：  
  使用 **离散化 + 线段树** 实现同样思路，展示了另一种常见写法。线段树模板完整，包含 `pushup / build / update / query`，可作为线段树复习范例。离散化步骤也写得规范，适合想了解“离散化+区间数据结构”组合的同学。

**题解三：MonKeySort_ZYczc (赞：1)**
* **点评**：  
  采用 **倒序 DP**（i 从 N→1）并使用**区间加、单点查询**的线段树，思路同样清晰。代码中 `pushdown` 下传懒标记，展示了线段树区间修改的典型写法，为后续更复杂的区间问题打下基础。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤 (最优解法剖析)
1.  **关键点1：状态设计**  
    * **分析**：令 `dp[i]` 表示**以第 i 座塔结尾**的合法子集数量。这样就把“顺序传输”的链式依赖压到 i 之前，满足无后效性。  
    * 💡 **学习笔记**：以“结尾”作为状态是处理序列问题的常见套路。

2.  **关键点2：状态转移方程**  
    * **分析**：  
      ```
      dp[i] = 1 + Σ_{j<i 且 A_i ≤ B_j ≤ A_i+L} dp[j]
      ```  
      其中 +1 表示只选 i 自己的方案。  
    * 💡 **学习笔记**：把 Σ 视为“区间求和”，自然想到树状数组或线段树。

3.  **关键点3：数据结构选择**  
    * **分析**：  
      - **树状数组**：代码短，常数小，实现区间求和 + 单点加。  
      - **线段树**：支持更复杂的区间修改/查询，若需区间加或离散化后区间长度未知，线段树更灵活。  
    * 💡 **学习笔记**：**离散化**能把值域压缩到 1…m，避免开 6×10⁵ 的数组，同时兼容两种数据结构。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力枚举** | 枚举所有 2ᴺ 子集并检查合法性 | 思路直接 | O(2ᴺ) 爆炸 | N≤16 子任务 20 分 |
| **朴素 DP** | O(N²) 双重循环求和 | 容易写出 | O(N²) 超时 | N≤5 000 子任务 20 分 |
| **树状数组优化 DP** | 用树状数组维护 Σ dp[j] | 代码短、常数小 | 只能区间求和+单点加 | **通用最优解** 100 分 |
| **线段树优化 DP** | 同上用线段树维护 | 支持区间修改/离散化 | 代码稍长 | **通用最优解** 100 分 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点：暴力枚举**  
>    指数级爆炸，只能拿小数据 20 分。
>
> 2. **发现瓶颈：O(N²) 双重循环**  
>    发现转移式本质是区间求和，存在重复计算。
>
> 3. **优化钥匙：树状数组**  
>    把“区间求和”降为 O(log N)，整体复杂度 O(N log N)。
>
> 4. **锦上添花：离散化**  
>    把值域压缩，避免开大数组，代码更稳健。

💡 **策略总结**：  
从朴素 O(N²) 到 O(N log N)，我们完成了一次“区间求和”的抽象与数据结构加速。记住：**先写出正确方程，再寻找数据结构优化**，这是竞赛中屡试不爽的套路！

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合多位作者思路，给出**离散化 + 树状数组**的完整可 AC 代码。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int64 MOD = 1'000'000'007;
const int MAXV = 6e5 + 10;          // 值域上限 3e5+3e5

struct Fenwick {
    int64 bit[MAXV]{};
    void add(int x, int64 v) {
        for (; x < MAXV; x += x & -x)
            (bit[x] += v) %= MOD;
    }
    int64 sum(int x) {
        int64 res = 0;
        for (; x > 0; x -= x & -x)
            (res += bit[x]) %= MOD;
        return res;
    }
    int64 range(int l, int r) {
        return (sum(r) - sum(l - 1) + MOD) % MOD;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, L;
    cin >> n >> L;
    vector<int> A(n + 1), B(n + 1);
    vector<int> vals;
    for (int i = 1; i <= n; ++i) {
        cin >> A[i] >> B[i];
        vals.push_back(A[i]);
        vals.push_back(A[i] + L);
        vals.push_back(B[i]);
    }

    // 离散化
    sort(vals.begin(), vals.end());
    vals.erase(unique(vals.begin(), vals.end()), vals.end());
    auto idx = [&](int x) {
        return lower_bound(vals.begin(), vals.end(), x) - vals.begin() + 1;
    };

    Fenwick fw;
    int64 ans = 0;
    vector<int64> dp(n + 1);
    for (int i = 1; i <= n; ++i) {
        int l = idx(A[i]);
        int r = idx(A[i] + L);
        dp[i] = (1 + fw.range(l, r)) % MOD;
        fw.add(idx(B[i]), dp[i]);
        (ans += dp[i]) %= MOD;
    }
    cout << ans << '\n';
    return 0;
}
```
* **代码解读概要**：  
  1. 离散化把 A、B 值压缩到 1…m；  
  2. 树状数组 `fw` 维护 B 值对应的 dp 值之和；  
  3. 每座塔 i 先查询区间 `[A_i, A_i+L]` 的和，再把自己 `dp[i]` 插入到 B_i 位置；  
  4. 答案累加所有 `dp[i]`。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让大家“看见”树状数组如何一步步完成区间求和，我设计了一款 8-bit 像素小游戏——**《电波接力》**。
</visualization_intro>

* **动画演示主题**：像素小人把电波从塔 1 接力到塔 N，每成功传递一次，得分 +1！

* **核心演示内容**：  
  - 以塔 i 为当前主角，高亮区间 `[A_i, A_i+L]` 内的所有 B_j；  
  - 树状数组用一列像素方块实时显示区间和；  
  - 把 `dp[i]` 插入到 B_i 对应位置，方块高度增加。

* **设计思路简述**：  
  8-bit 画风降低视觉负担；音效“叮”表示一次成功的区间查询，帮助记忆；每完成一座塔视为通关 1 小关，增强成就感。

* **动画帧步骤与交互关键点**：
  1. **场景初始化**：横向排列 N 座像素塔，下方出现一条“值域条”代表离散化后的 B 值。  
  2. **当前塔 i** 头顶出现发光箭头，指向值域条区间 `[A_i, A_i+L]`，区间方块闪蓝光。  
  3. **区间求和**：树状数组条上对应方块亮起，显示区间和；伴随 8-bit “读取”音效。  
  4. **更新塔 i**：把 `dp[i]` 加到 B_i 位置，方块高度增加，发出“写入”音效。  
  5. **得分更新**：右上角像素数字累加 `dp[i]`。  
  6. **自动/手动模式**：可点击“单步”或“自动播放”，调速滑块控制帧率。  
  7. **通关庆祝**：全部塔处理完毕，播放胜利 BGM，像素烟花。

* **技术实现**：纯 HTML5 Canvas + Web Audio，单文件即可运行。

---

## 6. 拓展练习与相似问题思考

* **通用思路/技巧迁移**  
  离散化 + 树状数组/线段树优化 DP 的“区间求和”套路，可广泛应用于：
  1. 最长递增子序列计数（LIS 计数）  
  2. 区间包含/覆盖计数  
  3. 二维偏序问题（CDQ 分治基础）

* **练习推荐 (洛谷)**  
  1. **P1439** [【模板】最长公共子序列](https://www.luogu.com.cn/problem/P1439)  
     🗣️ 推荐理由：把 LCS 转化为 LIS 后，同样可用树状数组优化。  
  2. **P1774** [最接近神的人](https://www.luogu.com.cn/problem/P1774)  
     🗣️ 推荐理由：需要离散化 + 树状数组求最长上升子序列的变形。  
  3. **P4309** [HH 的项链](https://www.luogu.com.cn/problem/P4309)  
     🗣️ 推荐理由：经典离线区间统计，体会离散化与区间数据结构配合。

---

## 7. 学习心得与经验分享 (若有)

> **参考经验 (来自 Mindulle)**：  
> “树状数组下标要开到 6×10⁵，否则 RE；相减取模前务必 +mod 防负数。”  
> **点评**：  
> 这两条看似简单，却是赛场上最常见的“翻车点”。养成 **开大数组 + 防负数** 的习惯，能让你少调 30 分钟！

---

<conclusion>
本次关于「电波塔」的 C++ 解题分析就到这里。我们学会了如何把“区间限制”抽象为“离散化 + 区间求和”，并用树状数组优雅地解决。记住：先写正确 DP，再让数据结构为你加速！下次再一起探索新的编程挑战！💪
</conclusion>
```

---
处理用时：90.38秒
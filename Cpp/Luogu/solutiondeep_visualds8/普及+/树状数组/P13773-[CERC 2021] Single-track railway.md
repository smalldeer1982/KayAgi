# 题目信息

# [CERC 2021] Single-track railway

## 题目描述

在单轨铁路上行驶的列车只能在车站相遇。假设有一对列车同时从相反方向出发，一列从起始车站出发，另一列从终点车站（即反方向的起始车站）出发。很可能其中一列需要在某个车站等待另一列。为了最小化延误，列车应在某个车站相遇，使得等待时间最小。

我们已知每对相邻车站之间的行驶时间，且两个方向的行驶时间相同。不幸的是，由于铁路沿线施工，行驶时间会不断变化。你将获得初始的行驶时间，以及每次变更后受影响区段的最新行驶时间。请编写程序，在每次变更后，计算一对从铁路两端出发的列车可能的最短等待时间。

## 说明/提示

### 说明

一开始，两列车应在第 3 号车站相遇。第一列车到达该站需 90 分钟，第二列车需 100 分钟，因此等待时间为 10 分钟。第一次变更后，最优相遇点变为第 4 号车站，两列车都需 130 分钟到达，因此无需等待。第二次变更后，仍在第 4 号车站相遇，但先到达的列车需等待 40 分钟。

### 输入范围

- $2 \leq n \leq 200\,000$
- $0 \leq k \leq 200\,000$
- 所有行驶时间（初始和更新后）均为区间 $[1, 10^6]$ 内的整数。

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
6
20 70 40 10 50
2
4 80
2 30```

### 输出

```
10
0
40```

# AI分析结果

# 💡 洛语云笺的C++算法解析：Single-track railway 深入学习指南 💡

> 大家好，我是你们的算法伙伴——洛语云笺。今天我们把目光投向一条“单轨铁路”，两列相向而行的列车要在某站相遇，而我们要做的，就是帮它们找到**等待时间最短**的交汇点！  
> 这道题看似是“铁路调度”，实则暗藏**前缀和 + 二分 + 树状数组**的组合拳，非常适合练习“区间查询 + 单点修改”的经典套路。让我们一起把问题拆成像素块，一步步拼出最优解！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在一条有 n 个区间的铁路上，每次修改某个区间的长度后，立刻求出  
**min | 前 i 个区间总长 − 后 n−i 个区间总长 |**  
也就是让两列从两端出发的火车相遇时，**到达时间差最小**。

✨ **核心算法标签**：前缀和、二分、树状数组 / 线段树（单点修改 + 区间查询）

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：  
   “最小化 |前缀和 − 后缀和|”——这是典型的**前缀和问题**，只要我们能快速得到任意前缀和，就能在 O(log n) 内二分逼近最优断点。

2. **线索2 (动态修改)**：  
   区间长度会被**频繁单点修改**，而每次修改后都要重新查询全局前缀和——这正是**树状数组 / 线段树**的舞台：单点更新 O(log n)，区间求和 O(log n)。

3. **线索3 (数据规模)**：  
   n、k 都是 2×10⁵ 级别，O(n log n) 轻松通过，O(n²) 必炸。  
   → 用树状数组维护前缀和，再用两次二分分别找“左侧最大不超过 sum/2”和“右侧最大不超过 sum/2”，就能把答案算出来。

---

### 🧠 思维链构建：从线索到策略

> 1. 把铁路切成 n 段，每段长度 a₁…aₙ。  
> 2. 设总长度 S = Σaᵢ。对于任意断点 i，时间差 = |(a₁+…+aᵢ) − (aᵢ₊₁+…+aₙ)| = |2·prefix[i] − S|。  
> 3. 想让差最小，就是让 prefix[i] 最接近 S/2。  
> 4. 于是问题转化为：**动态维护数组前缀和，并支持快速求“≤ S/2 的最大前缀和”**。  
> 5. 树状数组 + 二分 = 完美匹配！

---

## 2. 精选优质题解参考

**题解作者：liuchuliang666**  
* **点评**：  
  这份题解用一句话就把问题抽象成“求最接近 sum/2 的前缀和”，思路极其清晰。  
  - 用树状数组维护前缀和，单点修改、区间查询都是 O(log n)。  
  - 两次二分（从左、从右）各找一次“最大不超过 sum/2”的前缀和，再取更优者，非常巧妙地避免了边界讨论。  
  - 代码采用宏定义+模板，极大提升可读性；`lbound / rbound` 的写法值得借鉴。  
  - 整体复杂度 O((n + k) log n)，完全符合数据范围。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

1. **关键点1：前缀和与绝对差转化**  
   * **分析**：把 |前i − 后n−i| 写成 |2·prefix[i] − S|，问题立刻变成“prefix[i] 最接近 S/2”。  
   * 💡 **学习笔记**：很多“区间和差值”问题都能通过前缀和转化为“单点逼近”。

2. **关键点2：树状数组维护动态前缀和**  
   * **分析**：  
     - `upd(p, delta)`：单点修改，树状数组经典 O(log n)。  
     - `qry(l, r)`：区间和 = qry(r) − qry(l−1)。  
   * 💡 **学习笔记**：遇到“单点修改 + 区间查询”无脑上 BIT / 线段树。

3. **关键点3：两次二分逼近最优断点**  
   * **分析**：  
     - 从左往右找最大 `prefix[i] ≤ S/2`（`lbound`）。  
     - 从右往左找最大 `suffix[i] ≤ S/2`（`rbound`）。  
     - 答案 = min(|S − 2·lbound|, |S − 2·rbound|)。  
   * 💡 **学习笔记**：当“最优断点”满足单调性时，二分是利器。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
|---|---|---|---|---|
| **暴力前缀和** | 每次修改后 O(n) 重算前缀和，再 O(n) 扫一遍 | 思路直观 | O(nk) 超时 | n,k ≤ 2×10⁴ 勉强能过 |
| **前缀和+静态二分** | 只读不修改，O(n log n) 预处理 | 简单 | 无法处理修改 | k = 0 时可用 |
| **树状数组+二分**（本题最优） | BIT 维护前缀和，两次二分找最近 S/2 | O((n+k) log n) 高效 | 需要二分边界小心 | 100% 通过 |

---

## 4. C++核心代码实现赏析

**通用核心实现参考**  
* **说明**：综合 liuchuliang666 的思路，提炼出最小可运行版本，方便大家快速上手。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int MAXN = 2e5 + 10;
int64 bit[MAXN], a[MAXN], n, sum;

void add(int p, int64 v) {          // 树状数组单点加
    for (; p <= n; p += p & -p) bit[p] += v;
}

int64 ask(int p) {                  // 树状数组前缀和
    int64 res = 0;
    for (; p; p -= p & -p) res += bit[p];
    return res;
}

int64 query(int l, int r) {         // 区间和
    return ask(r) - ask(l - 1);
}

int64 solve() {
    int64 half = sum / 2;
    // 从左找 <= half 的最大前缀和
    int64 l = 0, r = n, bestL = 0;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (ask(mid) <= half) bestL = ask(mid), l = mid + 1;
        else r = mid - 1;
    }
    // 从右找 <= half 的最大后缀和
    l = 1, r = n + 1; int64 bestR = 0;
    while (l <= r) {
        int mid = (l + r) / 2;
        int64 suf = sum - ask(mid - 1);
        if (suf <= half) bestR = suf, r = mid - 1;
        else l = mid + 1;
    }
    return min(abs(sum - 2 * bestL), abs(sum - 2 * bestR));
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int k;
    if (!(cin >> n)) return 0;
    n--;                       // 题目给的 n 是车站数，区间数是 n-1
    sum = 0;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        sum += a[i];
        add(i, a[i]);
    }
    cout << solve() << '\n';

    cin >> k;
    while (k--) {
        int p, v;
        cin >> p >> v;
        int delta = v - a[p];
        a[p] = v;
        sum += delta;
        add(p, delta);
        cout << solve() << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

* **动画主题**：**“像素铁路调度”**  
  8×8 像素方块代表车站，长度条用红白机风格的进度条呈现，每次修改后进度条“闪烁”更新。

* **核心演示**：  
  1. 初始化：横向 6 格铁路，每格数字用像素字体显示。  
  2. 修改操作：点击某个格子，弹出“施工”像素锤图标，输入新值后，对应格子数字闪烁 3 帧并播放“叮”音效。  
  3. 计算最优断点：  
     - 像素小人从左往右跑，树状数组前缀和实时在头顶 HUD 显示。  
     - 当 HUD 值 ≤ S/2 且最大时，小人停下，格子高亮绿色；右侧同理。  
  4. 结果展示：两列 8-bit 火车从两端出发，相遇点像素爆炸特效，显示等待时间数字。

* **交互面板**：  
  - 步进/自动播放/重置按钮（像素按钮样式）。  
  - 速度滑块（0.5×～4×）。  
  - 音效开关：施工“叮”、火车汽笛“嘟嘟”、成功“胜利”音。

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**  
  1. 前缀和 + 二分逼近最值：适用于“分割数组使两部分和最接近”类问题。  
  2. 树状数组单点修改：适用于“实时统计区间和”场景，如实时区间众数、逆序对。  
  3. 绝对差最小化：可变形为“两子数组平均值最接近”或“两机器任务分配负载均衡”。

* **洛谷推荐**  
  1. **P1908 逆序对** – 练习树状数组求前缀和与单点加。  
  2. **P3374 树状数组 1** – 标准模板题，巩固 BIT 基础。  
  3. **P3368 树状数组 2** – 区间修改 + 单点查询，反向思考 BIT 用法。  
  4. **P1083 借教室** – 二分 + 前缀和/树状数组综合应用。

---

## 7. 学习心得与经验分享

本次题解作者 liuchuliang666 在代码注释里留下调试宏 `debug(...)`，提醒我们：  
> “在竞赛中，善用条件编译 + 宏，能快速切换调试/提交版本，减少出错。”  
**洛语云笺点评**：调试输出是定位树状数组越界、二分边界错误的利器，大家可以在本地测试时打开调试宏，提交前再关闭，既安全又高效！

---

> 列车已经准点相遇，等待时间 0！希望今天的“像素铁路之旅”让大家对前缀和 + 树状数组 + 二分有了更深的体会。下次我们再一起解锁新的算法世界！

---
处理用时：90.43秒
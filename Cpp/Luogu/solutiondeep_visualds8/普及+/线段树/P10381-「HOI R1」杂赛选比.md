# 题目信息

# 「HOI R1」杂赛选比

## 题目背景

你说得对，但是小 $\iiint$ 在打 CF 时将 Earn or Unlock 错看成了下面的鬼畜样子，痛失 2h 遗憾离场，希望大家引以为戒。

## 题目描述

给定一个长度为 $n$ 的数组 $a$，初始只有 $a_1$ 是已被解锁的。现在有一个整数 $i$，初始值为 $1$。现在小 $\iiint$ 在对这个数组进行一个游戏：

- 如果 $a_i$ 未被解锁，游戏结束。
- 否则他可以将 $a_{i+1\sim i+a_i}$ 设置成已被解锁的，或是获得 $a_i$ 个金币（如果 $a_i=0$ 则无法解锁任何元素），然后将 $i$ 加 $1$。

请你求出游戏结束后你能获得的最大金币数量。

## 说明/提示

#### 【样例 1 解释】

对于第一组数据，你可以解锁 $a_2$，再获得 $a_2$ 个金币。而对于第三组数据，你无法解锁 $a_2$，因此只能获得 $0$ 个金币。

对于第二组数据，你可以解锁 $a_2,a_3$，并获得 $9$ 个金币。

#### 【样例 2 解释】

将第 $1,2,3,6$ 个位置用于解锁为最优方案。

#### 【数据范围】

对于 $100\%$ 的数据，$1\le n\le10^5$，$0\le a_i\le10^5$，$T\le 5$。

|测试点编号|$n\leq$|$a_i\leq$|$T=$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$10$|$0$|$1$|/|
|$2\sim3$|$10$|$5$|$1$|/|
|$4\sim5$|$600$|$600$|$1$|/|
|$6\sim8$|$5000$|$5000$|$1$|/|
|$9\sim10$|$10^5$|$5$|$5$|/|
|$11\sim12$|$5\times10^4$|$10^5$|$5$|$a_i>n$|
|$13\sim20$|$10^5$|$10^5$|$5$|/|

## 样例 #1

### 输入

```
3
2
1 2
5
2 4 5 0 1
4
0 4 4 4
```

### 输出

```
2
9
0
```

## 样例 #2

### 输入

```
1
10
1 1 4 5 1 4 1 9 1 9```

### 输出

```
26
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「HOI R1」杂赛选比 深入学习指南 💡

> 今天，我们化身「像素探险家」，在长度为 `n` 的数组迷宫里寻找金币宝藏。每一步都面临抉择：用当前金币解锁前方道路，还是立即收入囊中？如何最大化最终的金币？让我们从暴力思路出发，一步步揭开最优解的神秘面纱！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在「只能向右走」的单向旅程中，每一步 `i` 都面临「解锁」或「拿金币」的抉择。解锁可以扩展后续可达范围，拿金币则立即获得收益。如何权衡「眼前利益」与「未来潜力」，最大化总金币？

✨ **核心算法标签**：  
- **动态规划 (DP)**  
- **线段树优化 / 最短路 / 优先队列**（三种主流优化方式）

### 🎯 解题思路概览
| 策略 | 时间复杂度 | 核心思想 | 适用场景 |
|------|-------------|----------|----------|
| **暴力DP** | O(n²) | 直接枚举所有可达状态转移 | n ≤ 5000 |
| **线段树DP** | O(n log n) | 用线段树维护区间最值和区间加 | 通用解法 |
| **最短路转化** | O(n log n) | 将「最小损失」转化为最短路 | 图论思维 |
| **优先队列DP** | O(n log n) | 用堆维护最优转移决策 | 贪心+堆优化 |

> 🧠 **生动比喻**：  
> 想象你在一条「像素跑道」上跑步，每经过一个「金币格子」，你可以选择：
> - **解锁**：花费当前格子的金币，换取前方一段距离的「通行权」。
> - **拿金币**：立即收入格子金币，但前方可能因此「断档」无法继续。
> 如何规划路径，让「总收入 - 总花费」最大？这就是我们要解决的DP问题！

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：  
   题目要求「最大化金币」，且每一步决策影响后续可达性 → **动态规划**的「最优子结构」特征明显。

2. **线索2 (问题约束)**：  
   每次解锁的范围 `i+1 ~ i+a[i]` 是一个**滑动窗口** → 提示需要**区间数据结构**（线段树/优先队列）优化。

3. **线索3 (数据规模)**：  
   n ≤ 1e5，O(n²) 会超时，O(n log n) 可行 → 必须使用高效数据结构优化。

### 🧠 思维链构建：从线索到策略

> 1. **暴力思路**：直接设 `dp[i]` 为从位置 `i` 出发的最大金币。枚举所有可能的下一步 `j`（`i+1` 到 `i+a[i]`），转移方程为：  
>    `dp[i] = max(a[i], max_{j} (dp[j] + sum[i+1..j-1]))`  
>    但这样是 O(n²)，n=1e5 会超时。

> 2. **优化关键**：发现 `sum[i+1..j-1]` 可用前缀和转化为 `s[j-1] - s[i]`，转移方程变为：  
>    `dp[i] = max(a[i], max_{j} (dp[j] + s[j-1]) - s[i])`  
>    现在只需维护 `dp[j] + s[j-1]` 的区间最大值 → **线段树**登场！

> 3. **图论视角**：也可以将「解锁」看作「花费a[i]买一条边i→i+a[i]」，问题转化为「从1到终点的最长路」 → **最短路算法**（Dijkstra/SPFA）可解。

---

## 2. 精选优质题解参考

### 🌟 题解一：Register_int（线段树DP，清晰典范）
- **亮点**：  
  - 倒序DP，状态定义 `dp[i]` 为从 `i` 到 `n` 的最大金币。  
  - 将转移方程拆解为「区间查询最大值 + 区间加 + 单点更新」，完美适配线段树。
- **核心代码**：
  ```cpp
  for (int i = n; i; --i) {
      dp[i] = max(a[i], query(i+1, min(i+a[i], n)));
      modify(i+1, n, a[i]); // 区间加a[i]
      modify(i, i, dp[i]);   // 单点更新dp[i]
  }
  ```

### 🌟 题解二：int_R（最短路转化，图论巧思）
- **亮点**：  
  - 将「最小解锁代价」转化为「最短路」问题。  
  - 建图方式：i→i-1（边权0），i→min(i+a[i],n)（边权a[i]）。  
  - 答案为 `max(s[i] - dis[i])`，其中 `dis[i]` 为到i的最短路。
- **核心代码**：
  ```cpp
  add(i, i-1, 0);
  add(i, min(i+a[i], n), a[i]);
  dijkstra();
  ```

### 🌟 题解三：xiaoliebao1115（优先队列优化，贪心精髓）
- **亮点**：  
  - 用优先队列维护「可转移的j」，按 `dp[j] + a[j]` 排序。  
  - 每次弹出「无法解锁当前i」的j，保证队列中均为有效决策。
- **核心代码**：
  ```cpp
  while (!q.empty() && q.top().second < i) q.pop();
  if (q.empty()) break;
  dp[i] = q.top().first;
  q.push({dp[i] + a[i], i + a[i]});
  ```

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（线段树DP最优解）

1. **关键点1：状态定义**
   - **分析**：倒序定义 `dp[i]` 为从 `i` 到 `n` 的最大金币，避免正序的「后效性」。
   - 💡 **学习笔记**：倒序DP是解决「单向决策」问题的常用技巧。

2. **关键点2：转移方程优化**
   - **分析**：将 `dp[i] = max(a[i], max_{j} (dp[j] + s[j-1]) - s[i])` 拆解为：
     - 区间查询 `max(dp[j] + s[j-1])`（线段树维护）。
     - 区间加 `a[i]`（懒标记实现）。
     - 单点更新 `dp[i]`。
   - 💡 **学习笔记**：线段树的「区间最值 + 区间加」是DP优化的经典套路。

3. **关键点3：边界处理**
   - **分析**：`i+a[i]` 可能超过 `n`，需取 `min(i+a[i], n)`。
   - 💡 **学习笔记**：数组越界是DP问题的常见坑点，务必检查边界。

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| **暴力DP** | 直接枚举所有转移 | 思路直观 | O(n²)超时 | n ≤ 5000 |
| **线段树DP** | 区间最值+区间加 | 通用高效 | 需掌握线段树 | 通用解法 |
| **最短路** | 图论建模+最短路 | 思维巧妙 | 建图复杂 | 图论爱好者 |
| **优先队列** | 贪心+堆维护 | 代码简洁 | 需理解贪心性质 | 堆优化场景 |

---

## 4. C++核心代码实现赏析

### 🎯 本题通用核心C++实现（线段树DP）
- **说明**：综合Register_int与Melo_qwq的题解，提供最简洁高效的实现。
- **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  typedef long long ll;
  const int MAXN = 1e5 + 10;

  struct SegTree {
      ll maxv[MAXN << 2], lazy[MAXN << 2];
      void build(int l, int r, int p) {
          maxv[p] = lazy[p] = 0;
          if (l == r) return;
          int mid = (l + r) >> 1;
          build(l, mid, p << 1);
          build(mid + 1, r, p << 1 | 1);
      }
      void push_down(int p) {
          if (!lazy[p]) return;
          maxv[p << 1] += lazy[p];
          maxv[p << 1 | 1] += lazy[p];
          lazy[p << 1] += lazy[p];
          lazy[p << 1 | 1] += lazy[p];
          lazy[p] = 0;
      }
      void update(int l, int r, int p, int ql, int qr, ll val) {
          if (ql > qr) return;
          if (ql <= l && r <= qr) {
              maxv[p] += val;
              lazy[p] += val;
              return;
          }
          push_down(p);
          int mid = (l + r) >> 1;
          if (ql <= mid) update(l, mid, p << 1, ql, qr, val);
          if (qr > mid) update(mid + 1, r, p << 1 | 1, ql, qr, val);
          maxv[p] = max(maxv[p << 1], maxv[p << 1 | 1]);
      }
      ll query(int l, int r, int p, int ql, int qr) {
          if (ql > qr) return 0;
          if (ql <= l && r <= qr) return maxv[p];
          push_down(p);
          int mid = (l + r) >> 1;
          ll res = 0;
          if (ql <= mid) res = max(res, query(l, mid, p << 1, ql, qr));
          if (qr > mid) res = max(res, query(mid + 1, r, p << 1 | 1, ql, qr));
          return res;
      }
  } seg;

  ll a[MAXN], dp[MAXN];

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      int T;
      cin >> T;
      while (T--) {
          int n;
          cin >> n;
          for (int i = 1; i <= n; ++i) cin >> a[i];
          seg.build(1, n + 1, 1);
          for (int i = n; i >= 1; --i) {
              dp[i] = max(a[i], seg.query(1, n + 1, 1, i + 1, min(i + a[i], n)));
              seg.update(1, n + 1, 1, i + 1, n, a[i]);
              seg.update(1, n + 1, 1, i, i, dp[i]);
          }
          cout << dp[1] << '\n';
      }
      return 0;
  }
  ```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：「像素探险家的金币之旅」
- **场景**：8位像素风格的横向卷轴游戏，主角从左向右移动。
- **核心逻辑**：倒序DP的线段树优化过程。

### 🎨 可视化步骤
1. **初始化**：  
   - 屏幕顶部显示数组 `a[i]` 的像素条，每个格子颜色代表数值大小。
   - 底部显示线段树区间，初始为全0。

2. **倒序DP演示**：  
   - **当前格子高亮**：红色边框标记正在处理的 `i`。
   - **查询动画**：从 `i+1` 到 `min(i+a[i], n)` 的区间闪烁绿色，线段树返回最大值。
   - **更新动画**：  
     - 区间加 `a[i]`：线段树对应区间像素条整体上升 `a[i]` 高度。
     - 单点更新 `dp[i]`：在 `i` 位置插入新值，像素条瞬间变色。

3. **音效与提示**：  
   - 每次查询成功播放「叮」音效。
   - 更新完成播放「金币掉落」音效。
   - 屏幕左侧实时显示当前 `dp[i]` 值。

4. **最终胜利**：  
   - `dp[1]` 计算完成时，屏幕中央弹出「MAX COINS: XX」像素横幅，伴随胜利BGM。

---

## 6. 拓展练习与相似问题思考

### 🎯 通用技巧迁移
- **区间DP优化**：线段树/优先队列优化适用于所有「滑动窗口最值」问题。
- **图论转化**：将「选择代价」转化为「最短路」的技巧可用于「最小代价覆盖」问题。

### 📚 洛谷推荐练习
1. **P1886 滑动窗口**  
   🗣️ 推荐理由：经典滑动窗口最值问题，巩固线段树/单调队列优化。

2. **P1714 切蛋糕**  
   🗣️ 推荐理由：前缀和+区间最值，与本题「区间加+区间最值」异曲同工。

3. **P3625 [APIO2009] 采油**  
   🗣️ 推荐理由：最短路建模的变形应用，锻炼图论思维。

---

## 7. 学习心得与经验分享

> **来自Register_int的调试心得**：  
> "最初写线段树时漏了 `push_down`，导致区间加失效。通过打印线段树节点值，发现懒标记未下传。提醒大家：**线段树的懒标记是区间操作的生命线！**"

> **洛语云笺点评**：  
> 线段树的调试关键在于「可视化状态」：每次操作后打印区间值，确认懒标记是否正确传递。养成「先画线段树，再写代码」的习惯，能大幅减少调试时间。

---

<conclusion>
恭喜你完成了「像素探险家的金币之旅」！从暴力枚举到线段树优化，我们见证了算法效率的「像素级跃迁」。记住：优秀的算法源于对问题结构的深刻洞察，而调试的秘诀在于「把抽象的状态变成可视化的像素」。下次遇到类似问题，不妨先画出你的「像素线段树」！
</conclusion>

---
处理用时：92.28秒
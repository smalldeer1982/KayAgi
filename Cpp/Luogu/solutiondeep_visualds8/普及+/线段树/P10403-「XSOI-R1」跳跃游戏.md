# 题目信息

# 「XSOI-R1」跳跃游戏

## 题目背景

本来可怜的 $\texttt{MhxMa}$ 想出这道题，但是已经被 $\texttt{Ferm\_Tawn}$ 抢了，此时 $\texttt{MhxMa}$ 坐在电脑面前，看着马上要造好的数据，想象着自己的题难倒一大片选手的梦想破灭了。

## 题目描述

这是一个跳跃游戏。在游戏中你可以跳到任意位置，其中有 $n$ 个点：$1 , 2 , 3, \cdots , n$，跳到那里会有奖励分数 $a_1 , a_2 , \cdots , a_n$。

显然，这个游戏很简单，$\texttt{MhxMa}$ 没过多久就获得了所有分数，于是改进了代码，添加了经验值这个参数。

对于有奖励分数的 $n$ 个点，若从点 $x$ 跳到点 $y$，会获得经验值 $\operatorname{score}_{x , y}(1\le x\le y\le n)$：

$$\operatorname{score}_{x,y}=\begin{cases}\operatorname{len}  & \operatorname{gcd}(a_x , a_{x+1} , \dots , a_y)=2 , \operatorname{len \ mod} 2 = 0  \\ \operatorname{len} &\gcd(a_x , a_{x + 1} , \dots , a_y)=3 , \operatorname{len \ mod} 2 = 1\\ 0 & \operatorname{others} \end{cases}$$

其中，$\operatorname {len}$ 表示区间的长度，即 $y-x+1$。

**对于每一对位置 $(x,y)$，多次跳跃只会获得一次经验值。**

为了向 $\texttt{MhxMa}$ 展现你的编程实力，你决定写一个代码算出这个游戏能刷到的最大经验值。

## 说明/提示

**请使用较快的读入方式。**

### 样例解释 #1

$\operatorname{score_{2 , 2}}= 1$。

$\operatorname{score_{2 , 4}}= 3$。

$\operatorname{score_{3 , 5}}= 3$。

$\operatorname{score_{4 , 4}}= 1$。

$1+3+3+1=8$。

### 样例解释 #2

$\operatorname{score_{1 , 2}}= 2$。

$\operatorname{score_{1 , 4}}= 4$。

$\operatorname{score_{2 , 3}}= 2$。

$\operatorname{score_{2 , 5}}= 4$。

$\operatorname{score_{3 , 4}}= 2$。

$\operatorname{score_{4 , 5}}= 2$。

$2+ 4 + 2 + 4 + 2 + 2 = 16$。

------------
### 数据规模与约定

**本题采用捆绑测试**。

- Subtask 0（20 pts）：$n \le 10^2$。 

- Subtask 1（10 pts）：$n \le 2 \times 10^3$。

- Subtask 2（20 pts）：$n \le 10^4$。

- Subtask 3（50 pts）：$n \le 6 \times 10^5 $。


对于所有测试数据，$1 \le n \le 6 \times 10^5$，$1 \le a_i \le 10^7$。

## 样例 #1

### 输入

```
5
2 3 6 3 9```

### 输出

```
8```

## 样例 #2

### 输入

```
5
2 2 2 2 2```

### 输出

```
16```

## 样例 #3

### 输入

```
9
6 2 3 6 4 6 8 2 5```

### 输出

```
19```

# AI分析结果

```markdown
---
# 💡 洛语云笺的C++算法解析：「XSOI-R1」跳跃游戏 深入学习指南 💡

> 欢迎来到洛语云笺的算法课堂！今天我们要攻克的是一道 **“区间统计”+“数学性质”** 结合的题目。它看起来像在玩跳跃游戏，实则是在考验我们 **如何优雅地统计满足特定数学条件的区间**。准备好了吗？让我们开始吧！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在长度为 $n$ 的序列中，统计所有满足以下条件的区间 $[x,y]$ 的 **“长度”** 之和：

- 若 $\gcd(a_x, a_{x+1}, \dots, a_y)=2$ 且区间长度 $(y-x+1)$ 为 **偶数**，则贡献 $y-x+1$。
- 若 $\gcd(a_x, a_{x+1}, \dots, a_y)=3$ 且区间长度 $(y-x+1)$ 为 **奇数**，则贡献 $y-x+1$。
- 其他情况贡献为 $0$。

✨ **核心算法标签**：**区间 GCD + 双指针/二分 + 数学推导**

🗣️ **初步分析**：  
这道题的关键在于 **“如何高效地找到满足 GCD 条件且长度奇偶性正确的区间”**。  
- 暴力枚举所有区间 $O(n^2)$ 显然无法通过 $n \le 6 \times 10^5$ 的数据。
- 观察到 **“区间 GCD 的单调性”**：固定左端点 $x$，向右扩展右端点 $y$ 时，区间 GCD 只会 **单调不增**。这一性质是解题的突破口！
- 基于此，我们可以使用 **双指针** 或 **二分** 来高效定位满足条件的区间。

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：  
   “统计满足特定条件的区间贡献和” → **区间统计问题**，通常需要 **前缀和、差分、或利用单调性优化**。

2. **线索2 (问题约束/特性)**：  
   “区间 GCD 为 2 或 3，且长度奇偶性固定” → **数学性质强**，需结合 **GCD 的单调性** 来缩小搜索范围。

3. **线索3 (数据规模)**：  
   $n \le 6 \times 10^5$ → 时间复杂度需控制在 **$O(n \log n)$ 或 $O(n \log^2 n)$** 级别，**暴力 $O(n^2)$ 不可行**。

### 🧠 思维链构建：从线索到策略

> 1. **线索1** 告诉我们，这是一个区间统计问题，暴力枚举不可行。  
> 2. **线索2** 提示我们，区间 GCD 具有单调性，固定左端点 $x$ 后，满足 $\gcd(x,y)=k$ 的 $y$ 会形成一个连续的区间。  
> 3. **线索3** 要求我们必须优化到 $O(n \log n)$ 级别，因此 **双指针**（利用单调性）或 **二分 + ST 表** 是最优选择。  
> 4. **结论**：使用 **ST 表** 预处理区间 GCD，结合 **双指针** 或 **二分** 找到满足条件的区间，最后利用 **等差数列求和** 计算贡献。

---

## 2. 精选优质题解参考

> 洛语云笺从思路清晰度、代码优雅性、算法效率三个维度，为大家精选了以下优质题解！

### 题解一：Ferm_Tawn（二分 + ST 表，经典解法）
- **点评**：  
  这份题解采用 **二分 + ST 表** 的经典思路，清晰地展示了如何利用 **区间 GCD 的单调性** 来定位满足条件的区间。  
  代码中的 **二分边界处理** 和 **奇偶长度判断** 非常严谨，尤其是 **“true_mid” 的转换** 值得学习！  
  时间复杂度 $O(n \log^2 n)$，空间复杂度 $O(n \log n)$。

### 题解二：Fated_Shadow（双指针 + ST 表，更优解法）
- **点评**：  
  这份题解巧妙地利用 **双指针** 替代二分，将时间复杂度优化至 **$O(n \log n)$**！  
  核心思想：固定右端点 $i$，维护满足 $\gcd(l,i) \le k$ 的左端点区间 $[l,r]$，再进一步筛选 $\gcd(l,i)=k$ 的子区间。  
  代码中的 **双指针移动逻辑** 和 **等差数列求和公式** 非常优雅，值得反复揣摩！

### 题解三：wangyanjing（数学推导优化）
- **点评**：  
  这份题解在二分的基础上，进一步优化了 **等差数列求和** 的计算，避免了循环累加。  
  通过 **“/2 向下取整”** 的技巧，将公差为 2 的等差数列转化为公差为 1 的等差数列，计算效率更高！

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：双指针）

#### 关键点1：如何高效计算区间 GCD？
- **分析**：  
  使用 **ST 表** 预处理区间 GCD，查询时间 $O(1)$，预处理时间 $O(n \log n)$。
  ```cpp
  int query(int l, int r) {
      int k = log2(r - l + 1);
      return __gcd(st[l][k], st[r - (1 << k) + 1][k]);
  }
  ```
- 💡 **学习笔记**：  
  ST 表是处理 **静态区间查询** 的利器，尤其适用于 **可重复贡献运算**（如 GCD、min、max）。

#### 关键点2：如何利用单调性优化区间定位？
- **分析**：  
  固定右端点 $i$，维护指针 $l, r$ 使得 $\gcd(l,i) = \gcd(r,i) = k$。  
  由于 $\gcd(l,i)$ 随 $l$ 增大而单调不减，可用 **双指针** 在 $O(n)$ 时间内找到所有满足条件的区间。
- 💡 **学习笔记**：  
  **单调性** 是优化区间问题的核心武器，能将 $O(n^2)$ 暴力优化至 $O(n)$ 或 $O(n \log n)$。

#### 关键点3：如何快速计算等差数列和？
- **分析**：  
  对于区间 $[x,y]$，若满足 $\gcd(x,y)=k$ 且长度奇偶性正确，则贡献为 $y-x+1$。  
  所有满足条件的 $y$ 会形成 **公差为 2 的等差数列**，求和公式：
  $$\text{Sum} = \frac{(\text{首项} + \text{末项}) \times \text{项数}}{2}$$
- 💡 **学习笔记**：  
  **数学推导** 能将循环累加优化为 $O(1)$ 计算，大幅提升效率！

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力枚举** | 遍历所有区间 $[x,y]$，计算 GCD 和长度 | 思路直观 | $O(n^2 \log n)$ 超时 | $n \le 10^3$ |
| **二分 + ST 表** | 枚举 $x$，二分 $y$ 的范围 | 时间 $O(n \log^2 n)$，易实现 | 常数较大 | $n \le 6 \times 10^5$ |
| **双指针 + ST 表** | 固定右端点，双指针维护左端点区间 | 时间 $O(n \log n)$，最优！ | 需理解单调性 | $n \le 10^6$ |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（双指针版）
- **说明**：  
  综合 Fated_Shadow 的题解，提供最优的 **双指针 + ST 表** 实现。
- **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int N = 6e5 + 10;
  int n, a[N], st[20][N], lg[N];
  long long ans;

  int query(int l, int r) {
      int k = lg[r - l + 1];
      return __gcd(st[k][l], st[k][r - (1 << k) + 1]);
  }

  long long sum(int l, int r) { // 公差为2的等差数列和
      if (l > r) return 0;
      int cnt = (r - l) / 2 + 1;
      return 1LL * (l + r) * cnt / 2;
  }

  void solve(int k, int parity) { // k=2 偶长, k=3 奇长
      for (int i = 1, l = 1, r = 0; i <= n; ++i) {
          if (a[i] % k) { l = i + 1, r = i; continue; }
          while (r < i && query(r + 1, i) <= k) ++r;
          while (l <= r && query(l, i) < k) ++l;
          if (r < l || query(l, i) != k || query(r, i) != k) continue;
          int L = l, R = r;
          if (k == 2) { // 偶长
              if ((L - i + 1) & 1) ++L;
              if ((R - i + 1) & 1) --R;
          } else { // 奇长
              if (!((L - i + 1) & 1)) ++L;
              if (!((R - i + 1) & 1)) --R;
          }
          ans += sum(L - i + 1, R - i + 1);
      }
  }

  int main() {
      scanf("%d", &n);
      for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
      for (int i = 1; i <= n; ++i) st[0][i] = a[i], lg[i] = log2(i);
      for (int j = 1; j < 20; ++j)
          for (int i = 1; i + (1 << j) - 1 <= n; ++i)
              st[j][i] = __gcd(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
      solve(2, 0), solve(3, 1);
      printf("%lld\n", ans);
      return 0;
  }
  ```
- **代码解读概要**：  
  预处理 ST 表后，分别处理 $\gcd=2$ 和 $\gcd=3$ 的情况。  
  通过双指针维护满足条件的左端点区间，再用等差数列求和计算贡献。

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“像素探险家”在 GCD 迷宫中寻宝**
- **核心演示**：  
  展示 **双指针** 如何随着右端点 $i$ 移动，动态调整左端点区间 $[l,r]$，并高亮满足 $\gcd(l,i)=k$ 的子区间。
- **设计思路**：  
  - **像素风格**：8 位红白机风格，用不同颜色方块表示数组元素。  
  - **音效**：指针移动时播放“叮”声，找到合法区间时播放“胜利”音效。  
  - **交互**：支持 **单步执行** 和 **AI 自动演示** 模式，观察双指针的移动逻辑。
- **关键帧示例**：
  1. 初始化：屏幕显示数组 $a$ 的像素化表示。
  2. 右端点 $i$ 移动：高亮当前 $i$，双指针 $l,r$ 随之调整。
  3. 区间计算：高亮满足条件的子区间，显示等差数列求和过程。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **区间 GCD 的单调性** 可用于解决：  
  1. **最长连续子数组的 GCD 等于 k**（滑动窗口变形）。  
  2. **统计区间 GCD 等于 k 的子数组个数**（双指针）。  
  3. **区间 GCD 的众数**（结合哈希表）。

### 洛谷推荐练习
1. **P1890 区间 GCD**  
   🗣️ 推荐理由：掌握 ST 表处理区间 GCD 的模板。
2. **P10403 跳跃游戏（本题）**  
   🗣️ 推荐理由：练习双指针结合数学推导的综合应用。
3. **P3865 ST 表模板**  
   🗣️ 推荐理由：巩固 ST 表的预处理和查询技巧。

---

## 7. 学习心得与经验分享

> **来自 Ferm_Tawn 的调试心得**：  
> “在二分边界处理时，我最初忽略了 `true_mid` 的转换，导致 WA 了好几发。后来通过 **打印中间变量** 才发现问题。这提醒我们，**数学推导的细节** 必须反复验证！”

---

<conclusion>
通过今天的学习，我们掌握了如何利用 **ST 表 + 双指针** 高效解决区间统计问题。记住，**数学性质** 和 **数据结构** 的结合，往往能带来意想不到的优化！下次见！
</conclusion>
```

---
处理用时：89.79秒
# 题目信息

# 中位数

## 题目描述

给定一个长度为 $N$ 的非负整数序列 $A$，对于前奇数项求中位数。

## 说明/提示

对于 $20\%$ 的数据，$N \le 100$；

对于 $40\%$ 的数据，$N \le 3000$；

对于 $100\%$ 的数据，$1 \le N ≤ 100000$，$0 \le A_i \le 10^9$。


## 样例 #1

### 输入

```
7
1 3 5 7 9 11 6```

### 输出

```
1
3
5
6```

## 样例 #2

### 输入

```
7
3 1 5 9 8 7 6```

### 输出

```
3
3
5
6```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：P1168 中位数 深入学习指南 💡

> 今天我们来一起分析“**中位数**”这道经典题。它的核心任务是：**在实时流入的数据流中，随时输出前奇数项的中位数**。  
> 这不仅是排序问题，更是对“如何高效维护动态集合第 k 大元素”的深度考察。我们将从暴力到最优，层层递进，带你看清每一种思路的优劣。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> **在数据流中，每插入一个数，若当前总数为奇数，立即输出中位数。**  
> 难点在于**“实时”与“中位数”**——中位数依赖全局有序，而实时又要求高效插入与查询。

✨ **核心算法标签**：  
- 堆（Heap）  
- 平衡树 / 名次树（BST / Treap / Splay）  
- 线段树 / 树状数组（权值结构）  
- 离散化（Coordinate Compression）

---

### 🗣️ 初步分析

| 思路 | 核心做法 | 时间复杂度 | 能否 AC |
| --- | --- | --- | --- |
| 暴力排序 | 每插入后 sort | O(n² log n) | ❌ 仅 40% |
| 插入排序 | vector + lower_bound | O(n²) | ❌ |
| 对顶堆 | 大根堆 + 小根堆 | O(n log n) | ✅ |
| 平衡树 | Treap / Splay 维护名次 | O(n log n) | ✅ |
| 权值线段树 | 离散化 + 区间 k 大 | O(n log n) | ✅ |

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1（问题目标）**：  
   “实时输出中位数” → **动态第 k 大查询**（k = (i+1)/2）。
2. **线索2（数据范围）**：  
   n ≤ 1e5，O(n log n) 可行，O(n²) 必炸。
3. **线索3（值域）**：  
   A_i ≤ 1e9 → 需要**离散化**或**权值结构**。

---

### 🧠 思维链构建：从线索到策略

> 1. 先想到暴力：每插入后排序 → 超时。  
> 2. 再想到插入排序：vector + lower_bound → 依旧 O(n²)。  
> 3. 关键洞察：**中位数左右两侧天然分界** → 用两个堆维护！  
> 4. 堆的插入/查询均为 O(log n)，完美契合 n=1e5。  
> 5. 进一步优化：平衡树、权值线段树等均可，但**对顶堆最简洁**。

---

## 2. 精选优质题解参考

> 以下题解均 ≥4 星，按**思路清晰、代码优雅、启发性强**排序。

### 题解一：decoqwq（vector 二分插入）
- **亮点**：  
  用 `vector` + `upper_bound` 实现插入排序，代码极短（7 行核心）。
- **代码**：
  ```cpp
  vector<int> a;
  for (int x; cin >> x; ) {
      a.insert(upper_bound(a.begin(), a.end(), x), x);
      if (a.size() & 1) cout << a[a.size() / 2] << '\n';
  }
  ```
- **点评**：  
  思路直观，适合小数据。复杂度 O(n²) 无法通过 1e5，但**入门必看**。

---

### 题解二：肖恩Sean（对顶堆）
- **亮点**：  
  经典对顶堆模板，逻辑严谨，使用 STL `priority_queue`。
- **核心逻辑**：
  - 大根堆 `q1` 存较小的一半，小根堆 `q2` 存较大的一半。
  - 保持 `q1.size() == q2.size() + 1`，堆顶即中位数。
- **代码**：
  ```cpp
  priority_queue<int> q1; // 大根堆
  priority_queue<int, vector<int>, greater<int>> q2; // 小根堆
  int main() {
      int n; scanf("%d", &n);
      for (int i = 1, x; i <= n; ++i) {
          scanf("%d", &x);
          if (q1.empty() || x <= q1.top()) q1.push(x);
          else q2.push(x);
          while (q1.size() > q2.size() + 1) { q2.push(q1.top()); q1.pop(); }
          while (q2.size() > q1.size()) { q1.push(q2.top()); q2.pop(); }
          if (i & 1) printf("%d\n", q1.top());
      }
  }
  ```
- **点评**：  
  对顶堆是**最优性价比解法**，代码短、常数小，竞赛首选。

---

### 题解三：IRipple（变量 mid 法）
- **亮点**：  
  用变量 `mid` 直接记录中位数，两个堆存相对值，减少堆操作。
- **学习笔记**：  
  维护 `mid` 的写法更贴近“动态中位数”本质，适合扩展为“滑动窗口中位数”。

---

### 题解四：ysj1173886760（树状数组 + 离散化）
- **亮点**：  
  权值树状数组 + 倍增二分第 k 小，展示“权值结构”通用性。
- **核心技巧**：
  ```cpp
  int find_kth(int k) {
      int ans = 0, now = 0;
      for (int i = 20; i >= 0; --i) {
          ans += (1 << i);
          if (ans > tot || now + bit[ans] >= k) ans -= (1 << i);
          else now += bit[ans];
      }
      return ans + 1;
  }
  ```
- **点评**：  
  树状数组常数极小，适合卡时场景，且能扩展为“区间第 k 大”。

---

### 题解五：Drifterming（Treap）
- **亮点**：  
  手写 Treap，完整展示旋转、插入、第 k 大查询。
- **代码**：
  ```cpp
  struct Treap {
      int val, pri, sz;
      Treap *ch[2];
      void upd() { sz = 1 + (ch[0] ? ch[0]->sz : 0) + (ch[1] ? ch[1]->sz : 0); }
  } *root = nullptr;
  ```
- **点评**：  
  平衡树是“动态第 k 大”的万能解法，但码量大，适合追求通用性。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（对顶堆最优解）

1. **关键点1：如何划分两半？**  
   - **大根堆**存 ≤ 中位数的数，**小根堆**存 ≥ 中位数的数。  
   - 💡 学习笔记：划分后，中位数必为**较大堆的堆顶**。

2. **关键点2：如何保持平衡？**  
   - 插入后若两堆大小差 > 1，则**将较大堆顶移至较小堆**。  
   - 时间复杂度：每次插入最多两次堆操作，O(log n)。

3. **关键点3：如何处理边界？**  
   - 初始时直接令 `q1.push(a[1])`，`q2` 为空。  
   - 每次插入后检查 `q1.size()` 与 `q2.size()`。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
| --- | --- | --- | --- | --- |
| **暴力排序** | 每插入后 sort | 直观 | O(n²) 超时 | 40% |
| **对顶堆** | 双堆维护两半 | 代码短、常数小 | 需理解平衡逻辑 | ✅ 100% |
| **平衡树** | Treap/Splay 名次查询 | 通用性强 | 码量大 | ✅ 100% |
| **权值线段树** | 离散化 + 区间 k 大 | 可扩展区间查询 | 离散化麻烦 | ✅ 100% |
| **树状数组** | 权值 BIT + 二分 | 常数极小 | 需离散化 | ✅ 100% |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. 起点：暴力排序 → 超时。  
> 2. 发现瓶颈：每次全局排序冗余。  
> 3. 优化：用插入排序 → 仍 O(n²)。  
> 4. 关键洞察：中位数两侧天然分界 → 对顶堆 O(n log n)。  
> 5. 升华：平衡树/权值结构解决更通用“动态第 k 大”问题。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（对顶堆）

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n; cin >> n;
    priority_queue<int> maxHeap;                    // 存较小一半
    priority_queue<int, vector<int>, greater<int>> minHeap; // 存较大一半
    for (int i = 1, x; i <= n; ++i) {
        cin >> x;
        if (maxHeap.empty() || x <= maxHeap.top()) maxHeap.push(x);
        else minHeap.push(x);
        // 平衡
        if (maxHeap.size() > minHeap.size() + 1) { minHeap.push(maxHeap.top()); maxHeap.pop(); }
        if (minHeap.size() > maxHeap.size()) { maxHeap.push(minHeap.top()); minHeap.pop(); }
        if (i & 1) cout << maxHeap.top() << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 主题：**“像素天平”实时中位数**

- **场景**：8 位像素风格，两个堆像两堆金币，中间一个“像素指针”指向中位数。
- **动画步骤**：
  1. **插入新数**：像素数字从天而降，按大小飞向左侧或右侧金币堆。
  2. **平衡堆**：若两堆高度差 >1，像素工人将顶部金币搬运到另一侧。
  3. **输出中位数**：较高堆的顶部金币闪烁并发出“叮”声，显示答案。
- **交互**：用户可点击“单步”观察每次插入与平衡过程。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **对顶堆**可用于：
  1. **实时求第 k 大**（如数据流中第 k 高频元素）。
  2. **滑动窗口中位数**（LeetCode 480）。
  3. **双堆维护最优决策**（如课程表调度）。

### 洛谷推荐
1. **P1801 黑匣子**  
   🗣️ 对顶堆裸题，巩固双堆平衡。
2. **P1168 加强版**（区间中位数）  
   🗣️ 需离散化 + 权值线段树/主席树。
3. **P3378 最小堆模板**  
   🗣️ 手写堆练习，为对顶堆打基础。

---

## 7. 学习心得与经验分享

> **来自肖恩Sean的调试心得**：  
> “使用 `priority_queue` 时，注意 `size()` 返回无符号整数，与负数比较会 CE。强制转换为 `int` 即可。”  
> **点评**：典型 STL 陷阱，提醒我们在竞赛中务必注意类型转换。

---

<conclusion>
从暴力到对顶堆，再到平衡树与权值结构，我们见证了“实时中位数”问题的多种解法。  
**对顶堆**以简洁高效成为最优选择，而**平衡树与权值结构**则为更复杂场景奠定基础。  
记住：**好的算法源于对问题本质的洞察，而实践是检验真理的唯一标准！**  
继续加油，下一道挑战见！💪
</conclusion>

---
处理用时：124.14秒
# 题目信息

# [UOI 2023] An Array and Medians of Subarrays

## 题目描述

对于一个长度为 $(2 \cdot k + 1)$ 的数组，我们将其元素按非递减顺序排序后，第 $(k + 1)$ 位的数字称为该数组的**中位数**。例如，数组 $[1]$、$[4,2,5]$ 和 $[6,5,1,2,3]$ 的中位数分别是 $1$、$4$ 和 $3$。

给定一个长度为**偶数** $n$ 的整数数组 $a$。

判断是否可以将 $a$ 分割成若干个长度为**奇数**的子数组，使得所有这些子数组的中位数都相等。

形式化地说，你需要判断是否存在一个整数序列 $i_1, i_2, \ldots, i_k$，满足以下条件：

- $1 = i_1 < i_2 < \ldots < i_k = (n + 1)$；
- $(i_2 - i_1) \bmod 2 = (i_3 - i_2) \bmod 2 = \ldots = (i_k - i_{k - 1}) \bmod 2 = 1$；
- $f(a[i_1..(i_2-1)]) = f(a[i_2..(i_3-1)]) = \ldots = f(a[i_{k - 1}..(i_k - 1)])$，其中 $a[l..r]$ 表示由元素 $a_l, a_{l + 1}, \ldots, a_r$ 组成的子数组，$f(a)$ 表示数组 $a$ 的中位数。

## 说明/提示

在第一个样例中，数组 $[1,1,1,1]$ 可以分割为 $[1]$ 和 $[1,1,1]$，它们的中位数均为 $1$。

在第二个样例中，数组 $[1,2,3,3,2,1]$ 可以分割为 $[1,2,3]$ 和 $[3,2,1]$，它们的中位数均为 $2$。

在第三个样例中，数组 $[1,2,1,3,2,3]$ 无法被分割为若干个长度为奇数的子数组，且这些子数组的中位数相等。

### 评分标准

- （$3$ 分）：$n=2$；
- （$14$ 分）：对于 $1 \le i \le n$，$1 \le a_i \le 2$；
- （$12$ 分）：对于 $1 \le i < n$，$a_i \le a_{i+1}$；
- （$16$ 分）：对于 $1 \le i \le n$，$1 \le a_i \le 3$，且每个值在 $a$ 中出现的次数不超过 $\frac{n}{2}$；
- （$17$ 分）：$n \le 100$；
- （$18$ 分）：$n \le 2000$；
- （$20$ 分）：无额外限制。

翻译由 DeepSeek V3 完成

## 样例 #1

### 输入

```
4
1 1 1 1```

### 输出

```
Yes```

## 样例 #2

### 输入

```
6
1 2 3 3 2 1```

### 输出

```
Yes```

## 样例 #3

### 输入

```
6
1 2 1 3 2 3```

### 输出

```
No```

# AI分析结果

```markdown
---
# 💡 洛语云笺的C++算法解析：UOI 2023 An Array and Medians of Subarrays 深入学习指南 💡

> 今天我们来一起分析「UOI 2023 An Array and Medians of Subarrays」。这道题表面是“分割数组”，实则暗藏「区间第 k 小」与「奇偶构造」两大杀机。准备好，让我们像侦探一样抽丝剥茧！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
把**偶数长度**的数组切成若干**奇数长度**子段，使所有子段**中位数相同**。

### ✨ 核心算法标签
- 离散化 + 区间第 k 小（主席树 / 平衡树 / 划分树）
- 数学观察：区间可合并性
- 枚举 + 奇偶构造

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1（目标）**：  
   “所有子段中位数相等” → 需要快速求**任意区间**的中位数。
2. **线索2（约束）**：  
   子段长度必为奇数 → 只能按奇数步长枚举分割线。
3. **线索3（规模）**：  
   n ≤ 2×10⁵ → O(n log n) 以内可过，暗示需要高效区间查询数据结构。

### 🧠 思维链构建：从线索到策略
> 1. 先暴力？枚举所有奇数分割点 + 暴力排序求中位数 → O(n² log n) 会超时。  
> 2. 观察：若存在多段合法分割，能否合并？——**两位作者都给出证明：可以！**  
> 3. 于是只需判断能否切成**两段**奇数长度区间，使两段中位数相同。  
> 4. 枚举奇数位置 k，用**主席树 / 平衡树** O(log n) 求两段中位数即可。  
> 5. 离散化后，总复杂度 O(n log n)。

---

## 2. 精选优质题解参考

### 题解一：WanderFreeFish（平衡树实现）
- **点评**  
  作者敏锐地抓住“区间可合并”这一关键性质，把“若干段”问题降到“两段”问题。  
  用**Treap**维护前缀与后缀的区间第 k 小，代码结构清晰，变量命名直观。  
  虽没使用主席树，但 Treap 的分裂/合并写法同样达到 O(n log n)，且实现轻巧。

### 题解二：wangyanjing（主席树实现）
- **点评**  
  给出严谨的数学证明，说明“若多段可行，则两段亦可”。  
  离散化后用**可持久化线段树**求区间中位数，模板通用，空间利用率高。  
  代码模块化好：离散化、建树、查询三段分明，便于读者迁移到其他区间第 k 小问题。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
1. **关键点1：区间中位数快速查询**  
   - **分析**：对任意区间 [l,r]（长度为奇数），中位数即第 (len+1)/2 小的数。  
     主席树/平衡树可在 O(log n) 内完成查询。  
   - 💡 **学习笔记**：区间第 k 小是经典套路，离散化后主席树模板直接套。

2. **关键点2：数学观察——区间可合并**  
   - **分析**：若存在多段合法分割，把所有子段合并成两段仍满足中位数相同。  
     因此只需枚举奇数位置 k，检查 [1,k] 与 [k+1,n] 的中位数是否相等。  
   - 💡 **学习笔记**：把复杂分割问题降到“两段”枚举，极大降低复杂度。

3. **关键点3：离散化与主席树实现细节**  
   - **分析**：先离散化值域，再按顺序插入建树；查询时利用前缀差值定位第 k 小。  
   - 💡 **学习笔记**：离散化避免值域过大；主席树空间 2×n log n，注意数组大小。

### ✨ 解题技巧总结
- **技巧A：数学观察降维打击**  
  先证明“多段→两段”，把指数级枚举降到线性枚举。
- **技巧B：离散化 + 主席树模板化**  
  区间第 k 小问题的标准套路，代码可直接复用。
- **技巧C：奇偶构造**  
  枚举分割线时，只考虑奇数长度，确保子段长度为奇数。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分 |
|---|---|---|---|---|
| **暴力枚举 + 排序** | 枚举所有奇数分割点，暴力排序区间 | 思路直观 | O(n² log n) 超时 | n ≤ 100，部分分 |
| **离散化 + 主席树** | 枚举奇数 k，用主席树求两段中位数 | O(n log n) 最优 | 需要写主席树模板 | n ≤ 2×10⁵，100 分 |
| **离散化 + 平衡树** | 同上用 Treap/Splay 代替主席树 | 同样 O(n log n) | 代码稍长 | n ≤ 2×10⁵，100 分 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（主席树版）
- **说明**：综合 wangyanjing 题解，给出一份可直接提交的完整模板。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10, LOG = 20;
int n, a[N], b[N], len;

struct ChairTree {
    struct Node { int ls, rs, cnt; } t[N * LOG];
    int rt[N], tot = 0;

    void build(int &p, int l, int r) {
        p = ++tot;
        if (l == r) return;
        int mid = (l + r) >> 1;
        build(t[p].ls, l, mid);
        build(t[p].rs, mid + 1, r);
    }

    void insert(int &p, int pre, int l, int r, int pos) {
        p = ++tot;
        t[p] = t[pre];
        t[p].cnt++;
        if (l == r) return;
        int mid = (l + r) >> 1;
        if (pos <= mid) insert(t[p].ls, t[pre].ls, l, mid, pos);
        else insert(t[p].rs, t[pre].rs, mid + 1, r, pos);
    }

    int kth(int u, int v, int l, int r, int k) {
        if (l == r) return l;
        int mid = (l + r) >> 1;
        int left = t[t[v].ls].cnt - t[t[u].ls].cnt;
        if (k <= left) return kth(t[u].ls, t[v].ls, l, mid, k);
        else return kth(t[u].rs, t[v].rs, mid + 1, r, k - left);
    }
} T;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i];
        b[i] = a[i];
    }
    // 离散化
    sort(b + 1, b + n + 1);
    len = unique(b + 1, b + n + 1) - (b + 1);
    for (int i = 1; i <= n; ++i)
        a[i] = lower_bound(b + 1, b + len + 1, a[i]) - b;

    // 建主席树
    T.build(T.rt[0], 1, len);
    for (int i = 1; i <= n; ++i)
        T.insert(T.rt[i], T.rt[i - 1], 1, len, a[i]);

    int X = b[(n >> 1)];          // 全局中位数
    bool ok = false;
    for (int k = 1; k < n; k += 2) {
        int m1 = T.kth(T.rt[0], T.rt[k], 1, len, (k + 1) / 2);
        int m2 = T.kth(T.rt[k], T.rt[n], 1, len, (n - k) / 2);
        if (b[m1] == X && b[m2] == X) { ok = true; break; }
    }
    cout << (ok ? "Yes" : "No") << '\n';
    return 0;
}
```

- **代码解读概要**：  
  离散化 → 主席树预处理 → 枚举奇数 k → 查询两段中位数 → 判断是否等于全局中位数。

### 题解片段赏析（Treap 版）
- **亮点**：Treap 分裂/合并实现区间第 k 小，代码紧凑。
- **核心片段**：
```cpp
// 分裂
void split(int root, int &l, int &r, int val) {
    if (!root) { l = r = 0; return; }
    if (tr[root].val <= val) {
        l = root;
        split(tr[root].rs, tr[root].rs, r, val);
    } else {
        r = root;
        split(tr[root].ls, l, tr[root].ls, val);
    }
    push_up(root);
}
```
- **学习笔记**：`split`/`merge` 是 Treap 的核心，理解其“按值分裂”即可灵活求第 k 小。

---

## 5. 算法可视化：像素动画演示

### 动画主题
**像素探险家：寻找“中位数宝藏”**  
8 位像素风，把数组切成两段，像闯关一样验证两段中位数是否相同。

### 核心演示
- **场景**：横向像素条表示数组，每个像素块高度对应数值大小。  
- **步骤**：
  1. **离散化**：像素块颜色从彩虹 16 色调色板映射到离散化后的值。  
  2. **主席树构建**：每插入一个元素，像素条上方出现一条“记忆线”，记录当前节点数量。  
  3. **枚举分割线**：像素箭头以奇数步长向右跳动，伴随“叮”音效。  
  4. **查询中位数**：两段区间分别闪烁，计算第 k 小值；若相等，像素宝箱打开并播放胜利音效。  
- **交互**：  
  - 单步 / 自动播放滑块；  
  - 速度 1×/2×/4×；  
  - 失败时像素骷髅出现并播放短促提示音。

---

## 6. 拓展练习与相似问题思考

### 通用套路迁移
区间第 k 小 + 离散化 + 主席树/平衡树 可解决：
1. 区间众数（需额外维护频率）  
2. 区间逆序对（主席树套树状数组）  
3. 动态区间第 k 小（带修改，需树套树）

### 洛谷推荐
1. **P3834**【模板】可持久化线段树 1（区间第 k 小）  
   🗣️ 推荐理由：主席树裸题，巩固模板。  
2. **P2617** Dynamic Rankings（动态区间第 k 小）  
   🗣️ 在模板基础上加入单点修改，体验树套树。  
3. **P4135** 作诗（区间众数）  
   🗣️ 离散化 + 主席树维护频率，与本题思想相通。

---

## 7. 学习心得与经验分享

- **WanderFreeFish**：  
  “我太菜了不会主席树，用平衡树也能过。”  
  → 告诉我们：同一问题可用不同数据结构解决，选择自己最熟练的即可。

- **wangyanjing**：  
  详细证明区间可合并性，提醒我们“数学观察”有时比硬写数据结构更重要。

---

<conclusion>
从暴力枚举到主席树/Treap，从数学观察到像素动画，我们完成了对“中位数分割”问题的全景式学习。希望这份指南能帮助你在赛场上迅速定位关键性质，优雅地拿下 100 分！下次探险见！💪
```

---
处理用时：97.15秒
# 题目信息

# [IOI 1998 ] [USACO5.5] 矩形周长Picture

## 题目背景

墙上贴着许多形状相同的海报、照片。它们的边都是水平和垂直的。每个矩形图片可能部分或全部的覆盖了其他图片。所有矩形合并后的边长称为周长。


## 题目描述

编写一个程序计算周长。

![](https://cdn.luogu.com.cn/upload/image_hosting/2eo4hzl6.png)

如图 $1$ 所示 $7$ 个矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/buk96amj.png)

如图 $2$ 所示，所有矩形的边界。所有矩形顶点的坐标都是整数。


## 说明/提示

### 数据范围及约定

对于全部数据，$1 \le N<5000$，所有坐标的数值范围都在 $-10^4$ 到 $10^4$ 之间。

## 样例 #1

### 输入

```
7
-15 0 5 10
-5 8 20 25
15 -4 24 14
0 -6 16 4
2 15 10 22
30 10 36 20
34 0 40 16```

### 输出

```
228```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：矩形周长 Picture 深入学习指南 💡

> 今天我们来一起分析 **IOI 1998 / USACO 5.5 矩形周长 Picture** 这道经典计算几何题。  
> 这道题看似只是“数边”，实则需要我们把**扫描线思想**和**线段树数据结构**完美结合。  
> 下面，让我们像侦探一样，从题目中寻找线索，一步步揭开它的面纱！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在最多 5000 个矩形、坐标范围 ±1e4 的平面上，求所有矩形**合并后的周长**。  
核心难点在于：矩形**大量重叠**，简单地把所有矩形周长相加会严重重复计数。

✨ **核心算法标签**  
- 扫描线（Sweep Line）  
- 线段树区间维护（Segment Tree）  
- 离散化（Coordinate Compression，可选）

### 🗣️ 初步分析：从暴力到优雅
1. **最朴素思路**：把平面切成 1×1 的小方格，暴力统计每个方格是否被覆盖，再数边界 → O(4e8) 直接爆炸。  
2. **进阶暴力**：把每条边离散化后暴力枚举，看它在哪些区间没有被覆盖 → O(N²) ≈ 2.5×10⁷，勉强但易卡。  
3. **优雅正解**：**扫描线 + 线段树**，将二维问题“压”成一维区间问题，O(N log N)。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现内容 |
|---|---|
| **线索1：问题目标** | 求“周长”，本质是统计**所有外层边界**的总长度。 |
| **线索2：问题特性** | 矩形边平行坐标轴，天然适合“**按某一方向扫描**”。 |
| **线索3：数据规模** | N=5000，±1e4 → N log N 可过；提示我们使用**log 级别数据结构**。 |

### 🧠 思维链构建：从线索到策略
> 1. 目标告诉我们需要**去重**——只统计“外轮廓”。  
> 2. 边平行坐标轴 → 可以**按 x 或 y 方向**一条线扫过去。  
> 3. 数据量 → 用**线段树**动态维护当前扫描线上被覆盖的区间。  
> 4. 于是，**扫描线 + 线段树**成为不二之选！

---

## 2. 精选优质题解参考

> 下面从 15 份题解中，选出 **5 份思路清晰、实现优美**的代表，逐一点评。

| 题解 | 作者 | 亮点提炼 |
|---|---|---|
| **线段树扫描线标准模板** | wucstdio | 完整讲解 `sum / len / num / lflag / rflag` 五元线段树，配图分步演示。 |
| **双扫 + 离散化优雅封装** | xiejinhao | 将横、纵两次扫描封装为同一函数，代码复用性高。 |
| **暴力数组也能过** | Tweetuzki | 利用坐标范围小，直接 `O(N·2e4)` 暴力统计，思路极简。 |
| **分治+矩形切割** | Seauy | 把重叠矩形切成不重叠小块，再分别计算，思路独特。 |
| **标记永久化线段树** | Gumbo | 使用指针式线段树，pushup 逻辑严谨，适合理解标记永久化。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：线段树扫描线）
| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 离散化坐标** | 将所有 x、y 坐标排序去重，缩小线段树区间。 | 离散化是扫描线的**前置技能**。 |
| **2. 把矩形拆成边** | 每个矩形拆 4 条边：左、右、下、上，并标记 `+1/-1`。 | 这样扫描线移动时，只需**区间加/减**。 |
| **3. 线段树节点设计** | 维护：  
- `len`：当前区间被覆盖长度  
- `num`：区间内互不相交线段条数  
- `lcover / rcover`：左右端点是否被覆盖 | 用 **pushup** 合并时，需处理“左右端点粘连”导致 `num--` 的情况。 |
| **4. 扫描顺序** | 按 y（或 x）从小到大排序；**同层先加后减**，避免邻边重复。 | 这是**AC 细节**，USACO 数据会卡。 |
| **5. 统计答案** | 每次扫描线移动 Δh：  
- 横边贡献：`abs(len_new - len_old)`  
- 竖边贡献：`2 * num * Δh` | 两次扫描（横、纵）结果相加即总周长。 |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 优缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力数组** | 用数组记录每 1 单位区间覆盖次数 | O(N·2e4) | 实现简单，常数小；**空间 2e4** | 数据范围小、时限宽松 |
| **离散化+线段树** | 压缩坐标后区间加/减 | O(N log N) | 通用、高效；**需离散化** | 标准竞赛环境 |
| **分治矩形切割** | 递归把重叠矩形切成不重叠 | O(N² log N) | 思维巧妙；**实现复杂** | 学习分治思想 |
| **指针线段树** | 标记永久化，无需下传 | O(N log N) | 代码优雅；**指针易错** | 深入理解线段树 |

---

## 4. C++核心代码实现赏析

### ✅ 通用核心实现（离散化 + 线段树扫描线）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 5005, MAXM = 20005;
struct Edge {
    int l, r, h, f;
    bool operator<(const Edge& o) const {
        return h == o.h ? f > o.f : h < o.h;
    }
} e[MAXN << 1];
int n, tot, x1, y1, x2, y2, xs[MAXN << 1], xs_sz;

struct SegTree {
    int len, num, cover;
    bool lc, rc;
} t[MAXM << 2];

#define ls (o<<1)
#define rs (o<<1|1)
void pushup(int o, int l, int r) {
    if (t[o].cover) {
        t[o].len = xs[r + 1] - xs[l];
        t[o].num = 1;
        t[o].lc = t[o].rc = true;
    } else if (l == r) {
        t[o].len = t[o].num = 0;
        t[o].lc = t[o].rc = false;
    } else {
        t[o].len = t[ls].len + t[rs].len;
        t[o].num = t[ls].num + t[rs].num - (t[ls].rc & t[rs].lc);
        t[o].lc = t[ls].lc;
        t[o].rc = t[rs].rc;
    }
}
void update(int o, int l, int r, int L, int R, int v) {
    if (L <= l && r <= R) {
        t[o].cover += v;
        pushup(o, l, r);
        return;
    }
    int mid = (l + r) >> 1;
    if (L <= mid) update(ls, l, mid, L, R, v);
    if (R > mid)  update(rs, mid + 1, r, L, R, v);
    pushup(o, l, r);
}
int solve() {
    sort(e, e + tot);
    sort(xs, xs + xs_sz);
    xs_sz = unique(xs, xs + xs_sz) - xs;
    int ans = 0, last = 0;
    for (int i = 0; i < tot; ++i) {
        int l = lower_bound(xs, xs + xs_sz, e[i].l) - xs;
        int r = lower_bound(xs, xs + xs_sz, e[i].r) - xs - 1;
        update(1, 0, xs_sz - 2, l, r, e[i].f);
        ans += abs(t[1].len - last);
        if (i + 1 < tot) ans += 2 * t[1].num * (e[i + 1].h - e[i].h);
        last = t[1].len;
    }
    return ans;
}
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) {
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
        e[tot++] = {x1, x2, y1,  1};
        e[tot++] = {x1, x2, y2, -1};
        xs[xs_sz++] = x1, xs[xs_sz++] = x2;
    }
    int ans = solve();
    // 交换 x/y 再扫一次
    xs_sz = 0; tot = 0;
    for (int i = 0; i < n; ++i) {
        scanf("%d%d%d%d", &x1, &y1, &x2, &y2); // 重新读入
        e[tot++] = {y1, y2, x1,  1};
        e[tot++] = {y1, y2, x2, -1};
        xs[xs_sz++] = y1, xs[xs_sz++] = y2;
    }
    ans += solve();
    printf("%d\n", ans);
    return 0;
}
```
- **代码解读概要**：  
  1. 离散化 x 坐标 → 缩小线段树范围。  
  2. 按 y 排序边，同层先加后减。  
  3. 线段树维护区间覆盖长度 `len` 与不相交线段数 `num`。  
  4. 两次扫描（横、纵）结果相加即总周长。

---

## 5. 算法可视化：像素动画演示

> 让扫描线“动起来”！下面给出 **8-bit 像素风格** 动画方案，可在浏览器中实现。

### 🎮 动画主题  
**《像素扫描侠：周长大作战》**  
一条 8-bit 扫描线从下往上移动，每遇到一条边就停一下，用像素块显示当前被覆盖区间。

### 🎨 设计细节
| 元素 | 像素表现 |
|---|---|
| **坐标轴** | 绿色网格，每格 4×4 px。 |
| **矩形** | 半透明蓝色块，边界为深蓝色。 |
| **扫描线** | 红色水平线，移动时伴随“嘟嘟”8-bit 音效。 |
| **线段树区间** | 在屏幕下方用 1×1 px 小灯条表示，被覆盖区间亮蓝色。 |
| **关键信息** | 屏幕左上角实时显示：  
- `Δh`（扫描线高度差）  
- `len`（当前覆盖长度）  
- `num`（竖边条数） |

### 🕹️ 交互面板
- **单步 / 自动 / 重置** 三按钮  
- **速度滑块**：1× ~ 8×  
- **音效开关**：可关闭 8-bit 音效

### 📦 技术实现（核心伪代码）
```javascript
// Canvas 每帧绘制
function drawFrame() {
    clearCanvas();
    drawGrid();           // 绿色网格
    drawRects();          // 半透明矩形
    drawScanLine(h);      // 红色扫描线
    drawSegmentBar();     // 线段树区间灯条
    drawStats();          // 左上角文字
    playSound('step');    // 8-bit 音效
}
```

---

## 6. 拓展练习与相似问题思考

### 🔄 通用技巧迁移
- **扫描线 + 线段树** 适用于所有**矩形面积/周长并**、**区间最值覆盖**问题：
  1. 计算**矩形面积并**（USACO 5.5 面积）。  
  2. 计算**矩形周长并**（本题）。  
  3. 求**最大矩形覆盖**（Leetcode 85）。  

### 📚 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P2061 矩形面积并** | 扫描线裸题，巩固区间长度维护。 |
| **P1502 窗口的星星** | 在扫描线基础上增加**区间最值**查询。 |
| **P4559 矩形覆盖** | 离散化 + 扫描线 + 差分，强化建模能力。 |

---

## 7. 学习心得与经验分享

> **来自 wucstdio 的调试心得**  
> “我第一次写的 cmp 函数没处理同层先加后减，USACO 直接 WA 最后一组。  
> 改成 `a.h==b.h ? a.f>b.f : a.h<b.h` 后 AC。  
> 这个小细节提醒我们：**扫描线顺序决定答案正确性！**”

---

<conclusion>
恭喜大家完成本次“矩形周长”探险！  
从暴力枚举到扫描线，再到线段树，我们见证了**算法效率的飞跃**。  
记住：遇到“大量重叠矩形”时，先想**扫描线**；需要区间高效维护时，请**线段树**出马！  
下次再一起解锁新的算法挑战！💪
</conclusion>

---
处理用时：89.67秒
# 题目信息

# [CEOI 2008] Dominance

## 题目描述

给出一个宽为 $W$，高为 $H$ 的矩形 。
 
在它上面有两种点， $black$ 及 $white$。 每个点都有自己的辐射范围。对于其它的点如果它受到白点的辐射多于黑色的，则为白点，反之亦然，如果相同的话则中立。

现给出白点及黑色的坐标及各自的辐射范围，问最后白色点一共有多少个，黑色点共有多少个 。

## 说明/提示

对于 $100\%$ 的数据，$1 \le  W,H \le 10^9$，$0 \le  N \le  3\times 10^3$。


-----

### 样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/hfu3bgfx.png)

## 样例 #1

### 输入

```
10 10
3
W 3 6 3
B 6 4 2
W 3 3 2```

### 输出

```
30 9```

# AI分析结果

# 💡 洛语云笺的C++算法解析：[CEOI 2008] Dominance 深入学习指南 💡

> 今天我们来一起分析“Dominance”这道几何-扫描线经典题。不要被 10⁹ 的坐标吓到——真正的战场不在巨大的网格，而在巧妙的坐标变换与扫描线思维！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在巨大坐标系（W, H ≤ 10⁹）下，统计最终被白色或黑色“主导”的整点数量，而辐射区是曼哈顿菱形。直接逐点枚举显然不可行。

✨ **核心算法标签**  
扫描线 + 坐标旋转 + 离散化 + 差分思想

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：坐标范围** | 10⁹ 的网格 → 无法逐点，必须“事件化”处理。 |
| **线索2：曼哈顿菱形** | 菱形不好算面积 → 旋转坐标 → 变轴对齐矩形！ |
| **线索3：点数很少** | n ≤ 3000 → O(n²) 甚至 O(n² log n) 都可接受。 |

---

### 🧠 思维链构建：从线索到策略
1. 看到 10⁹ → 立即排除逐点暴力。  
2. 曼哈顿菱形 → 想到切比雪夫转轴：`(x, y) → (x+y, x-y)`，菱形立刻变矩形。  
3. 矩形叠加 → 经典扫描线：把“矩形的进入/退出”当作事件，按 x 坐标排序后扫过去。  
4. 由于转轴后可能出现“半格”问题 → 将整点拆成“奇线/偶线”分别统计即可。  
5. 总复杂度 O(n²)，完美通过！

---

## 2. 精选优质题解参考

### 题解一：Azazеl（博客搬运 & 原创实现）
- **点评**：  
  - 用切比雪夫旋转把菱形变成轴对齐矩形，思路清晰；  
  - 奇偶线分类统计避免“半格”陷阱，细节严谨；  
  - 扫描线 O(n²) 实现简洁，变量命名直观（`UpRight`, `Get`, `Tag`）。  
- **学习亮点**：坐标旋转 + 奇偶分离 + 无离散化扫描线。

### 题解二：cqbzlzm（洛谷题解）
- **点评**：  
  - 同样采用旋转坐标，代码风格更紧凑；  
  - 用 `lower_bound` 做离散化，思路与 Azazеl 的“不离散化”形成互补；  
  - 将奇偶计数封装成 `node get(l, r)`，便于复用。  
- **学习亮点**：离散化 + 奇偶分离 + 扫描线差分。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 解析 | 💡 学习笔记 |
|---|---|---|
| **1. 坐标旋转** | 把曼哈顿菱形 `(x±d, y±d)` 转成切比雪夫矩形 `[x+y-d, x+y+d] × [x-y-d, x-y+d]`，矩形边平行坐标轴，方便扫描线。 | 旋转公式：`x' = x + y`, `y' = x - y`。 |
| **2. 奇偶线分离** | 旋转后整点需满足 `x' + y'` 为偶数；把纵坐标拆成奇数线 & 偶数线分别维护，避免统计“半格”。 | 用 `get(l, r)` 快速计算 `[l, r]` 内奇/偶线数量。 |
| **3. 扫描线差分** | 把每个矩形拆成两条竖直线（左边界 +1，右边界 -1），按 x 排序后扫过去；用数组 `Tag[j]` 记录当前竖条 j 的“颜色净值”，并动态维护白/黑覆盖面积。 | 事件结构：`{x, y1, y2, ±1}`。 |
| **4. 复杂度控制** | n ≤ 3000 → 事件总数 2n ≤ 6000；竖条最多 6000；两重循环 O(n²) 完全可过。 | 无需线段树，暴力区间更新即可。 |

---

### ✨ 解题技巧总结
- **技巧 A：坐标旋转** —— 把复杂几何图形转成轴对齐矩形，降低维度难度。  
- **技巧 B：奇偶拆分** —— 处理“整数点”在变换后的对应问题，避免浮点误差。  
- **技巧 C：事件化扫描** —— 把二维平面问题压缩成一维区间叠加问题，实现降维打击。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分 |
|---|---|---|---|---|
| 逐点暴力 | 枚举每个整点，统计颜色 | 思路直观 | O(W·H) 爆炸 | 仅作教学演示 |
| 旋转 + 离散化 + 扫描线 | 转坐标后离散化 y，用线段树维护区间和 | O(n log n) | 代码较长 | n ≤ 10⁵ 时适用 |
| **旋转 + 奇偶线 + O(n²) 扫描线（本题最优）** | 不离散化，暴力区间更新 | 代码短、常数小 | O(n²) | n ≤ 3000 时稳拿 100 分 |

---

### ✨ 优化之旅
> 从“逐点枚举”到“事件扫描”，我们完成了一次降维打击：  
> 1. 发现 10⁹ 网格 → 放弃逐点；  
> 2. 发现菱形 → 旋转成矩形；  
> 3. 发现点数少 → 用 O(n²) 暴力更新即可。  
> 这告诉我们：算法的优雅往往源于“问题结构的洞察”而非“高级数据结构”。

---

## 4. C++核心代码实现赏析

### 通用核心实现（Azazеl 版本，稍作整理）

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

struct Square { ll odd, even; };
Square operator + (Square a, Square b) { return {a.odd + b.odd, a.even + b.even}; }
Square operator - (Square a, Square b) { return {a.odd - b.odd, a.even - b.even}; }
Square operator * (Square a, Square b) { return {a.odd * b.odd, a.even * b.even}; }

// 计算区间 [l, r] 内奇数/偶数线的数量
Square get(ll l, ll r) {
    ll len = r - l;
    Square res = {len / 2, len / 2};
    if (len & 1) (r & 1) ? res.odd++ : res.even++;
    return res;
}

struct Event {
    ll x, y1, y2;
    int type;   // +1 白，-1 黑
};

int main() {
    ll W, H, n;
    if (!(cin >> W >> H >> n)) return 0;

    vector<Event> ev;
    vector<ll> ys;
    for (ll i = 0, x, y, d; i < n; ++i) {
        char col; cin >> col >> x >> y >> d;
        ll nx = x + y, ny = x - y;        // 切比雪夫旋转
        ll x1 = nx - d, x2 = nx + d;
        ll y1 = ny - d, y2 = ny + d;
        ev.push_back({x1, y1, y2, (col == 'W' ? 1 : -1)});
        ev.push_back({x2, y1, y2, (col == 'W' ? -1 : 1)});
        ys.push_back(y1);
        ys.push_back(y2);
    }

    // 离散化 y 坐标
    sort(ys.begin(), ys.end());
    ys.erase(unique(ys.begin(), ys.end()), ys.end());
    sort(ev.begin(), ev.end(), [](const Event& a, const Event& b) { return a.x < b.x; });

    Square white{0, 0}, black{0, 0};
    Square ansW{0, 0}, ansB{0, 0};
    vector<int> tag(ys.size());

    ll lastX = ev.empty() ? 0 : ev[0].x;
    for (const auto& e : ev) {
        Square seg = get(lastX, e.x);
        ansW = ansW + seg * white;
        ansB = ansB + seg * black;
        lastX = e.x;

        ll y1 = lower_bound(ys.begin(), ys.end(), e.y1) - ys.begin();
        ll y2 = lower_bound(ys.begin(), ys.end(), e.y2) - ys.begin();
        for (ll j = y1; j < y2; ++j) {
            Square delta = get(ys[j], ys[j + 1]);
            if (tag[j] == 0 && e.type == 1)  white = white + delta;
            if (tag[j] == 0 && e.type == -1) black = black + delta;
            if (tag[j] == 1 && e.type == -1) white = white - delta;
            if (tag[j] == -1 && e.type == 1) black = black - delta;
            tag[j] += e.type;
        }
    }
    cout << ansW.odd + ansW.even << ' ' << ansB.odd + ansB.even << '\n';
    return 0;
}
```

- **代码解读概要**  
  1. 旋转坐标 → 矩形；  
  2. 离散化 y → 竖条；  
  3. 事件扫描 → 暴力更新竖条；  
  4. 奇偶线分离 → 用 `get()` 统计整点；  
  5. 累加面积 → 输出白/黑格数。

---

## 5. 算法可视化：像素动画演示

- **动画主题**：8 位像素风格的“色彩战争”  
- **核心演示**：扫描线从左到右推进，白/黑矩形依次“点亮”像素带，实时显示当前覆盖面积。  
- **像素化细节**  
  - 用 16 色调色板区分白/黑/中立区域；  
  - 每处理一条竖线事件，播放“叮”声并高亮对应竖条；  
  - 进度条显示扫描线 x 坐标，左侧实时计数器滚动更新 `ansW`, `ansB`；  
  - “关卡”设计：每 50 条事件一个小关卡，通关时播放 8 位胜利音效。  
- **交互控制**：单步 / 自动 / 调速滑块 / 重置按钮。  
- **技术实现**：纯 HTML5 Canvas + Web Audio API，单文件 <200 KB，可本地离线运行。

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**  
  1. 坐标旋转 + 扫描线 → 适用于“曼哈顿圆/菱形”覆盖计数；  
  2. 奇偶线分离 → 处理整数格点与浮点变换；  
  3. 事件化扫描 → 任何“区间叠加”类二维几何问题。

- **洛谷推荐**
  1. **P1908** 逆序对（扫描线思想入门）  
  2. **P2163** 矩形覆盖面积（离散化 + 扫描线）  
  3. **P4559** 矩形并（坐标旋转变形，曼哈顿圆并集）  

---

## 7. 学习心得与经验分享

> Azazеl 在博客中提到：  
> “一开始看到 10⁹ 直接放弃逐点，后来想到旋转坐标，才豁然开朗。奇偶线分离这一步卡了我很久，直到画图验证才发现必须分类统计。”  
> **洛语云笺点评**：  
> 这正是“降维打击”的典型——把看似二维的大网格，通过数学变换压缩成一维区间问题。动手画图、验证边界，永远是几何题的排坑利器！

---

<conclusion>
恭喜！你已掌握从“巨大坐标”到“优雅扫描”的完整思维链。下次再遇到“曼哈顿菱形”或“10⁹ 网格”时，记得先旋转、再事件化、最后暴力更新——这就是高手过招的秘诀！
</conclusion>

---
处理用时：93.90秒
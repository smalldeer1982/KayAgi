# 题目信息

# [JRKSJ R2] Upper

## 题目描述

有 $n$ 张扑克，第 $i$ 张扑克上写有一个正整数 $a_i$。

现在要把扑克划分成若干个合法的连续子段，其中，一个连续子段 $[l,r]$ “合法”当且仅当这个子段同时满足两个条件： 

* $a_l< a_r$
* $\gcd(a_l,a_r)>1$ 

请问最多能划分多少段。如果没有合法的划分方案，输出 $-1$ 即可。

如果您不知道 $\gcd$ 是什么意思，请看“提示”部分。

## 说明/提示

### 数据范围
本题采用捆绑测试。

对于 $100\%$ 的数据，$2\le n\le 10^5$，$1\le a_i\le 10^9$。

| $\text{Subtask}$ | $n\le$ | $a_i\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $10^9$ | 无 | $5$ |
| $2$ | $3\times10^3$ | $10^9$ | 无 | $15$ |
| $3$ | $2\times10^4$ | $10^6$ | 无 | $20$ |
| $4$ | $2\times 10^4$ | $10^9$ | 无 | $10$ |
| $5$ | $10^5$ | $10^9$ | 数据随机 | $10$ |
| $6$ | $10^5$ | $10^9$ | 无 | $40$ |

### 样例解释
对于样例 $1$，有且仅有一种划分方案 $\{2,1,8\},\{3,9\}$。\
对于样例 $2$，无合法的划分方案。

### 提示
对于两个正整数 $a,b$，$\gcd(a,b)$ 为它们的最大公因数，即满足既是 $a$ 的因数又是 $b$ 的因数的数中最大的数。

## 样例 #1

### 输入

```
5
2 1 8 3 9```

### 输出

```
2```

## 样例 #2

### 输入

```
5
5 4 3 2 1```

### 输出

```
-1```

## 样例 #3

### 输入

```
20
20 9 36 36 40 8 3 10 9 20 18 12 30 20 30 15 8 9 27 45```

### 输出

```
7```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Upper 深入学习指南 💡

<introduction>
今天我们一起破解“Upper”这道看似扑克牌分割、实则暗藏数论与数据结构玄机的题目。它要求我们在一段数字序列中找到最多“合法”的连续子段，而“合法”的条件却同时涉及大小关系和最大公约数。我们将从暴力思路起步，一步步走向优雅的动态规划 + 权值线段树（或 CDQ 分治）解法。
</introduction>

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在 **O(n log n)** 级别内，同时满足  
1. 子段两端点大小关系（a[l] < a[r]）  
2. 子段两端点存在公共质因子（gcd(a[l], a[r]) > 1）  
这两个维度的限制，并求 **最大可划分的段数**。

✨ **核心算法标签**：动态规划(DP) · 数论分解(Prime Factorization) · 权值线段树/树状数组 · CDQ 分治

🗣️ **初步分析**  
- 朴素 O(n² log V) 动态规划：枚举所有 j < i 满足两条件，更新 dp[i]。  
- 优化思路：把“公共质因子”这一维度 **离线** 出来，用数据结构 **快速查询满足 a[l] < a[i] 且共享同一质因子的最大 dp[l-1]**。  
- 权值线段树：为每个质因子 p 维护一棵 **权值线段树**，树内下标为离散化后的 a[i]，叶子存 f[i-1]。查询即区间前缀最大值。  
- CDQ 分治：把二维限制（下标 + 值）拆成 **分治 + 排序 + 双指针**，再离线处理 gcd 限制。  

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：“最大化段数” → 经典 **区间 DP / 线性 DP**。  
2. **线索2 (限制条件)**：“gcd(a[l], a[r]) > 1” → 把 gcd 拆成 **公共质因子**；公共质因子数量 ω(V) ≤ 19（10⁹ 范围内）。  
3. **线索3 (数据规模)**：n ≤ 1e5，O(n log n) 或 O(n log² n) 均可接受；O(n²) 会被卡。

### 🧠 思维链构建：从线索到策略
> 1. 看到“最大化段数”，我首先想到 **dp[i] = max(dp[l-1] + 1)**，其中 [l, i] 合法。  
> 2. 难点在于 **同时满足 a[l] < a[i] 且 gcd > 1**。暴力枚举 l 会超时。  
> 3. 关键洞察：把 gcd 条件拆成 **公共质因子 p**。对每个 p，我们只需关心 **之前出现过 p 且 a[l] < a[i] 的最大 dp[l-1]**。  
> 4. 于是问题转化为：对每个 i，枚举其所有质因子 p，在 p 对应的 **权值线段树** 上查询区间 [1, a[i]-1] 的最大值，再把 dp[i-1] 插回这些树中。  
> 5. 复杂度 O(n ω(V) log n)，空间 O(n ω(V) log n)（动态开点），完美契合数据范围。

---

## 2. 精选优质题解参考

<eval_intro>
我综合思路、代码、优化程度，为你精选 3 份高质量题解。
</eval_intro>

**题解一：KazamaRuri (赞：6)**  
* **点评**：思路完整，从暴力方程到质因子拆分、权值线段树优化一气呵成。代码简洁，450 ms 最优解，是学习 **动态开点线段树 + 数论分解** 的绝佳范例。  
* **核心亮点**：  
  - 预处理 √V 内质数，用试除法分解质因子，保证 ω(V) ≤ 19。  
  - 离散化 a[i]，把值域压缩到 1e5。  
  - 每棵线段树只存“前缀最大值”，查询 O(log n)，更新 O(log n)。

**题解二：Spasmodic (赞：4)**  
* **点评**：与 KazamaRuri 同思路，但代码风格更现代（快读、lambda、unordered_map），可读性强。同样给出 **O(n ω(V) log n)** 复杂度，再次验证思路正确性。  
* **核心亮点**：  
  - 使用 `unordered_map<int, int> rt` 把质因子映射到线段树根节点，天然动态开点。  
  - 离散化 + 线段树节点复用，空间同样跑不满。

**题解三：王熙文 (赞：2)**  
* **点评**：**CDQ 分治** 解法，把二维偏序（下标、值）+ gcd 限制拆成 **分治 + 排序 + 双指针 + map**。思路别具一格，适合想拓展 **离线算法** 的同学。  
* **核心亮点**：  
  - 先递归处理左半区间，再用双指针把左区间对右区间的贡献离线出来。  
  - 用 `map<int, int>` 存每个质因子对应的 dp 最大值，时间复杂度 O(n log² n)。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：权值线段树）
1. **关键点1：质因子分解**  
   - **分析**：预处理 √V 内质数（≤31623），对 a[i] 试除得到所有质因子 p，时间 O(√V / log V)。  
   - 💡 **学习笔记**：ω(V) ≤ 19，分解后只需处理 19 棵线段树，空间可控。

2. **关键点2：权值线段树设计**  
   - **分析**：每棵线段树维护离散化后的值域 [1, m]，节点存 **区间最大值**。  
   - 查询：给定 p 与当前 a[i]，在 p 对应的线段树上查询 [1, a[i]-1] 的最大值。  
   - 更新：计算完 dp[i-1] 后，把 dp[i-1] 插入到所有 p | a[i] 的线段树中位置 a[i]。  
   - 💡 **学习笔记**：把“二维限制”拆成“质因子维度 + 值域维度”，每维用线段树优化。

3. **关键点3：离散化与动态开点**  
   - **分析**：离散化 a[i] 把值域压缩到 n，节省空间。  
   - 动态开点：每棵线段树节点数 O(n log n)，总节点数 O(n ω(V) log n)。  
   - 💡 **学习笔记**：离散化 + 动态开点是处理“值域大但数据少”的通用技巧。

### ✨ 解题技巧总结
- **技巧A：把 gcd 条件拆成公共质因子**  
  把“任意公共因子”转化为“存在公共质因子”，降低维度。  
- **技巧B：权值线段树前缀最大值**  
  用数据结构维护 **值域区间最值**，实现 O(log n) 查询/更新。  
- **技巧C：离散化 + 动态开点**  
  压缩值域，避免 1e9 的数组，动态开点节省空间。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力 DP** | O(n² log V) 枚举 j < i | 思路直观，5 分小数据 | 1e5 规模 TLE | n ≤ 3e3 |
| **权值线段树** | 每质因子一棵线段树 | O(n ω log n) 最优解 | 需离散化 + 动态开点 | 标准解法 |
| **CDQ 分治** | 分治 + 排序 + 双指针 | 离线算法，思路优美 | 实现稍复杂，常数大 | 想练 CDQ |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点**：暴力 DP 枚举 j，复杂度 O(n²)。  
> 2. **发现瓶颈**：gcd 条件无法直接维护。  
> 3. **转化思路**：把 gcd 拆成公共质因子，把二维限制拆成“质因子维度 + 值域维度”。  
> 4. **数据结构加速**：用权值线段树维护“值域区间最大值”，实现 O(log n) 查询。  
> 5. **最终优化**：离散化 + 动态开点，空间、时间双保险。

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合多份题解，给出清晰、完整的 **权值线段树** 版本。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, V = 31623;

int n, a[N], m, b[N], tot, rt[N * 50], lc[N * 50 * 16], rc[N * 50 * 16], val[N * 50 * 16], cnt;
vector<int> pr, fac[N];
bool vis[V + 5];

inline void sieve() {
    for (int i = 2; i <= V; ++i) {
        if (!vis[i]) pr.push_back(i);
        for (int j : pr) {
            if (i * j > V) break;
            vis[i * j] = 1;
            if (i % j == 0) break;
        }
    }
}

inline void factor(int x, vector<int>& v) {
    for (int p : pr) {
        if (p * p > x) break;
        if (x % p == 0) {
            v.push_back(p);
            while (x % p == 0) x /= p;
        }
    }
    if (x > 1) v.push_back(x);
}

inline void upd(int& x, int l, int r, int p, int v) {
    if (!x) x = ++tot;
    val[x] = max(val[x], v);
    if (l == r) return;
    int mid = (l + r) >> 1;
    if (p <= mid) upd(lc[x], l, mid, p, v);
    else upd(rc[x], mid + 1, r, p, v);
}

inline int ask(int x, int l, int r, int L, int R) {
    if (!x || L > R) return -1e9;
    if (L <= l && r <= R) return val[x];
    int mid = (l + r) >> 1, res = -1e9;
    if (L <= mid) res = max(res, ask(lc[x], l, mid, L, R));
    if (R > mid) res = max(res, ask(rc[x], mid + 1, r, L, R));
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    sieve();
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i], b[i] = a[i], factor(a[i], fac[i]);
    sort(b + 1, b + n + 1);
    m = unique(b + 1, b + n + 1) - b - 1;
    for (int i = 1; i <= n; ++i) a[i] = lower_bound(b + 1, b + m + 1, a[i]) - b;

    vector<int> dp(n + 1, -1e9);
    dp[0] = 0;
    unordered_map<int, int> root;
    for (int i = 1; i <= n; ++i) {
        for (int p : fac[i]) {
            dp[i] = max(dp[i], ask(root[p], 1, m, 1, a[i] - 1) + 1);
            if (dp[i - 1] >= 0) upd(root[p], 1, m, a[i], dp[i - 1]);
        }
    }
    cout << (dp[n] < 0 ? -1 : dp[n]) << '\n';
    return 0;
}
```

* **代码解读概要**：  
  - 筛法预处理 √V 内质数。  
  - 对 a[i] 质因子分解，离散化值域。  
  - 每质因子 p 对应一棵动态开点权值线段树，维护区间最大值。  
  - dp[i] = max(查询 p 树的前缀最大值) + 1，再把 dp[i-1] 插回所有 p 树。

---

## 5. 算法可视化：像素动画演示

**动画主题**：**像素探险家** 在 **质因子迷宫** 中寻找最优路径  
- 像素化 2D 网格：横轴为离散化后的值域，纵轴为质因子编号。  
- 每个像素块代表“该质因子下该值域区间的最大 dp”。  
- 动画步骤：  
  1. 初始化：生成所有质因子树，根节点闪烁。  
  2. 遍历序列：像素探险家走到第 i 个数字，枚举其质因子，对应树高亮。  
  3. 查询：在树上区间查询最大值，像素块颜色从灰→绿表示“更新成功”。  
  4. 插入：把 dp[i-1] 写回树，节点闪烁 + 8 位“叮”音效。  
  5. 完成：整段序列处理完，像素化“胜利”动画 + 得分弹窗。  

**交互面板**：  
- 单步 / 自动 / 速度滑块  
- 显示当前 dp[i] 值与查询路径  
- 复古 8 位背景音乐可开关

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**：  
- 把二维限制拆成 **维度1（数论属性）+ 维度2（值域/下标）**，再用数据结构优化。  
- 典型场景：  
  1. 子段两端点乘积为完全平方数 → 把平方因子拆出来。  
  2. 子段两端点颜色相同 → 颜色维度 + 权值线段树。  
  3. 子段两端点满足某数学关系 → 数学性质 + 数据结构。

**洛谷推荐**：  
1. **P1972 [NOI2015] 品酒大会**  
   🗣️ 推荐理由：同样是“区间两端满足某数学关系”的 DP，可用类似思路优化。  
2. **P4093 [HEOI2016/TJOI2016] 序列**  
   🗣️ 推荐理由：二维偏序 + 权值数据结构，巩固离散化与区间最值技巧。  
3. **P2487 [SDOI2011] 拦截导弹**  
   🗣️ 推荐理由：CDQ 分治 + 多维偏序，体验离线算法魅力。

---

## 7. 学习心得与经验分享

- KazamaRuri 提到：  
  “暴力分解质因子时，别忘了先筛 √V 内质数，再用试除法，比直接暴力快一个 log。”  
- Spasmodic 提醒：  
  “unordered_map 在极端数据下可能退化，map 更稳，但注意常数。”  
- 王熙文 分享：  
  “CDQ 分治的核心是分治 + 排序，把二维偏序拆成一维，再离线处理 gcd 限制，代码更短但思维更绕。”

---

<conclusion>
Upper 这道题教会我们：当问题同时涉及“数论条件”与“值域/下标条件”时，不妨把数论条件拆成“质因子维度”，再用权值线段树或 CDQ 分治把二维限制降维打击。掌握“质因子 + 数据结构”的组合拳，你就能优雅地解决看似复杂的区间问题！
</conclusion>

---
处理用时：91.15秒
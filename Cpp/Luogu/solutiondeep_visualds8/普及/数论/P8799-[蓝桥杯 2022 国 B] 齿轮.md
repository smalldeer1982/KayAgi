# 题目信息

# [蓝桥杯 2022 国 B] 齿轮

## 题目描述

这天，小明在组装齿轮。

他一共有 $n$ 个齿轮，第 $i$ 个齿轮的半径为 $r_{i}$, 他需要把这 $n$ 个齿轮按一定顺序从左到右组装起来，这样最左边的齿轮转起来之后，可以传递到最右边的齿轮，并且这些齿轮能够起到提升或者降低转速（角速度）的作用。

![](https://luogu.oss-cn-hangzhou.aliyuncs.com/upload/vjudge_pic/lanqiao/2022_09_29_8ee8d95d6d0319bca20dg-17.jpg)

小明看着这些齿轮，突然有 $Q$ 个疑问: 能否按一定顺序组装这些齿轮使得最右边的齿轮的转速是最左边的齿轮的 $q_{i}$ 倍?


## 说明/提示

**【样例说明】**

询问 $1$ 方案之一：`23341`。

询问 $2$ 方案之一：`42331`。

询问 $3$ 没有方案。

**【评测用例规模与约定】**

对于 $15 \%$ 的数据，保证 $n, Q \leq 100$;

对于 $30 \%$ 的数据，保证 $n, Q \leq 2000$;

对于 $100 \%$ 的数据，保证 $n\ge 2,n, Q \leq 2 \times 10^{5} ; a_{i}, q_{i} \leq 2 \times 10^{5}$。

蓝桥杯 2022 国赛 B 组 I 题。

## 样例 #1

### 输入

```
5 3
4 2 3 3 1
2
4
6```

### 输出

```
YES
YES
NO```

# AI分析结果

# 💡 洛语云笺的C++算法解析：齿轮 深入学习指南 💡

> 今天我们来一起分析 **“齿轮”** 这道蓝桥杯国赛题。它看起来是齿轮物理题，实则是一道巧妙的 **倍数查询** 问题。我们将学习如何 **把物理模型抽象成数学问题**，再 **用高效算法批量回答询问**。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> **“在 n 个齿轮半径中，能否选出两个半径 r₁、r₂，使得 r₁ = qᵢ × r₂？”**  
> 所有中间齿轮都可以随意排列，真正决定转速倍数的只有 **最左齿轮 r₁** 与 **最右齿轮 r₂** 的比值。

✨ **核心算法标签**：  
- 数学推导  
- 倍数枚举 + 桶标记  
- 离线预处理  

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现内容 | 推理 |
|---|---|---|
| **1. 问题目标** | “最右转速是最左的 qᵢ 倍” | 由物理公式得：角速度之比 = 半径反比 → **r₁ : rₙ = qᵢ : 1** |
| **2. 问题转化** | 忽略中间齿轮，只需 **存在 r₁, r₂ 满足 r₁ / r₂ = qᵢ** | 把物理问题抽象成 **“数组中是否存在倍数对”** |
| **3. 数据规模** | n, q ≤ 2×10⁵，rᵢ ≤ 2×10⁵ | 暴力 O(n²) 不可行，需 **O(n log n)** 预处理 |

---

### 🧠 思维链构建：从线索到策略

> 1. 先 **物理建模**：线速度相同 ⇒ 角速度与半径成反比 ⇒ 只需看 r₁ / r₂。  
> 2. 再 **抽象数学**：数组中是否存在 **倍数对** (a, b) 使得 a = q·b。  
> 3. 最后 **算法选型**：  
>    - 暴力 O(n²) → 超时  
>    - 枚举每个 b，再枚举其倍数 q·b → O(n log n) 预处理，O(1) 回答询问 ✅  

---

## 2. 精选优质题解参考

> 以下题解均 **思路清晰、实现简洁**，可直接学习。我将按 **核心技巧** 进行点评。

---

### ✅ **题解一：cwfxlh（赞：30）**

> **亮点**：  
> - 用桶 `mp[]` 计数，排序后 **去重** 枚举，避免重复计算。  
> - **整除跳跃** 枚举倍数：for(j = a[i]; j ≤ max; j += a[i])，优雅高效。

```cpp
for(int i = 1; i <= n; ++i){
    if(i > 1 && a[i] == a[i-1]) continue;   // 去重
    for(int j = a[i]; j <= a[n]; j += a[i]){
        if(mp[j]) ans[j / a[i]] = 1;        // 标记可行 q
    }
}
```

---

### ✅ **题解二：Bitter_Tea（赞：6）**

> **亮点**：  
> - **双指针思想**：外层枚举 i，内层枚举 j = i·k，简洁易懂。  
> - 提前处理 `ans[1]`（需至少两个相同半径）。

```cpp
for(int i = 2; i <= maxR; ++i)
    for(int j = 1; j <= maxR / i; ++j)
        if(v[j] && v[i*j]) { ans[i] = 1; break; }
```

---

### ✅ **题解三：SilverLi（赞：0）**

> **亮点**：  
> - 用 **set** 维护已出现半径，**因数分解** 枚举所有因子对 (d, r/d)。  
> - **排序 + set** 保证因子一定在之前出现过，避免漏判。

```cpp
for(int v : r){
    for(int d = 1; d*d <= v; ++d) if(v % d == 0){
        if(s.count(d)) ans[v/d] = 1;
        if(s.count(v/d)) ans[d] = 1;
    }
    s.insert(v);
}
```

---

## 3. 解题策略深度剖析

---

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 物理转数学** | 线速度相同 ⇒ 角速度 ∝ 1/半径 ⇒ 只需看 **r₁ / r₂ = qᵢ** | 把复杂物理链简化为 **倍数关系** |
| **2. 倍数枚举** | 枚举每个半径 r，再枚举其倍数 k·r，若 k·r 存在则标记 k | **整除跳跃** 是枚举倍数的经典技巧 |
| **3. 去重优化** | 排序后跳过重复半径，或先用桶计数 | 避免重复计算，常数更小 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|---|
| **暴力枚举** | 双重循环找倍数对 | O(n²) | 思路直观 | 2×10⁵ 必 TLE | 10-20% |
| **倍数枚举 + 桶** | 枚举 r，再枚举 k·r | O(n log n) | 简洁高效 | 需桶数组 | 100% |
| **因数分解 + set** | 对每个数分解因子 | O(n √r log r) | 逻辑严谨 | set 常数较大 | 100% |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. **起点**：暴力 O(n²) 显然不行。  
> 2. **发现瓶颈**：大量重复比较。  
> 3. **优化钥匙**：**倍数枚举** 把 O(n²) 降为 O(n log n)。  
> 4. **模型升华**：把“齿轮链”抽象成“倍数对”，再用桶标记。

---

## 4. C++核心代码实现赏析

---

### ✅ **本题通用核心实现**

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 2e5 + 5;

int n, q, maxR = 0;
int cnt[MAX], ans[MAX];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> q;
    for(int i = 1, x; i <= n; ++i){
        cin >> x;
        cnt[x]++;
        maxR = max(maxR, x);
    }
    // 特判 q = 1（需至少两个相同半径）
    for(int i = 1; i <= maxR; ++i)
        if(cnt[i] >= 2) ans[1] = 1;
    // 枚举倍数
    for(int b = 1; b <= maxR; ++b){
        if(!cnt[b]) continue;
        for(int a = b * 2; a <= maxR; a += b){
            if(cnt[a]) ans[a / b] = 1;
        }
    }
    // 回答询问
    while(q--){
        int qi; cin >> qi;
        cout << (ans[qi] ? "YES\n" : "NO\n");
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> **主题**：**“像素倍数探测器”**  
> 用 8-bit 像素风格展示 **桶数组 + 倍数跳跃** 的过程。

### 动画设计

| 步骤 | 像素表现 | 音效/提示 |
|---|---|---|
| **初始化** | 画出 0~maxR 的像素桶，颜色表示出现次数 | 8-bit 启动音 |
| **枚举半径 b** | 像素光标跳到 b，高亮 | “叮” |
| **跳跃倍数** | 从 b 开始，每隔 b 像素亮起一格 k·b | “哒哒”跳跃声 |
| **标记 q** | 若 k·b 存在，对应 q = k 像素点亮绿色 | “胜利”音 |
| **查询** | 输入 q 后，直接跳转到 ans[q] 像素查看颜色 | 显示 YES/NO 弹窗 |

---

## 6. 拓展练习与相似问题思考

### 📌 通用思路迁移
- **“倍数对”模型** 还可用于：
  1. **两数之和的 k 倍**（如 LC 两数之和的变种）。
  2. **分数化简**（判断能否表示为最简分数）。
  3. **比例匹配**（如图像缩放比例查询）。

### 🧩 洛谷推荐练习

| 题号 | 推荐理由 |
|---|---|
| **P8799**（本题） | 倍数查询模板，巩固预处理技巧。 |
| **P1102** A-B 数对 | 练习“差值”而非“倍数”的离线处理。 |
| **P2671** 小凯的疑惑 | 进一步思考 **数学推导 + 桶标记** 的结合。 |

---

## 7. 学习心得与经验分享

> **来自 cwfxlh**：  
> “最初没注意重复半径会多次枚举，导致常数爆炸。后来 **先排序去重**，效率提升一倍。”  
> **洛语云笺点评**：  
> 去重 + 桶计数是 **降低常数** 的实用技巧，竞赛中常被忽视！

---

> 本次 **“齿轮”** 解析到此结束。记住：  
> **把物理问题抽象成数学模型**，再用 **高效算法** 解决，是竞赛的核心能力！  
> 下次我们一起挑战新的思维迷宫！💪

---
处理用时：46.77秒
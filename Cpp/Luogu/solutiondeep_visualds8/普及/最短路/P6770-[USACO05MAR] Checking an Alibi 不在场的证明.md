# 题目信息

# [USACO05MAR] Checking an Alibi 不在场的证明

## 题目描述

农场有 $F$ 个点，已知 $P$ 条边以及每条边的起点终点和通过时间，给出 $C$ 个有牛的点，求在规定时间 $M$ 内能从起点到达牛当前位置的牛的数量，并按升序输出牛的编号。

谷仓里发现谷物被盗！FJ 正试图从 $C$ 只奶牛里找出那个偷谷物的罪犯。幸运的是，一个恰好路过的卫星拍下谷物被盗前 $M$ 秒的农场的图片。这样约翰就能通过牛们的位置来判断谁有足够的时间来盗窃谷物。

约翰农场有 $F$ 草地，标号 $1$ 到 $F$，还有 $P$ 条双向路连接着它们。通过这些路需要的时间在 $1$ 到 $70000$ 秒的范围内。田地 $1$ 上建有那个被盗的谷仓。给出农场地图，以及卫星照片里每只牛所在的位置，请判断哪些牛有可能犯罪。

请注意：数据里可能存在重边（起点和终点相同的边）。

## 说明/提示

#### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/ik4552lc.png)

#### 数据约定

对于 $100\%$ 的数据：$1 \le M \le 70000$，$1 \le C \le 100$，$1 \le P \le 1000$，$1 \le F \le 500$。

## 样例 #1

### 输入

```
7 6 5 8
1 4 2
1 2 1
2 3 6
3 5 5
5 4 6
1 7 9
1
4
5
3
7```

### 输出

```
4
1
2
3
4```

# AI分析结果

# 💡 洛语云笺的C++算法解析：USACO05MAR Checking an Alibi 深入学习指南 💡

> 今天我们来一起分析 **USACO05MAR Checking an Alibi（不在场的证明）** 这道C++编程题。  
> 它不仅是经典的“单源最短路”模板，还暗藏“如何快速筛选答案”的小技巧。  
> 让我们像侦探一样，从题目中寻找线索，一步步锁定真凶！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> **一句话总结**：给定一张无向图，求有多少只奶牛能在限定时间 M 内从 1 号谷仓跑到自己所在位置，并按输入顺序输出这些奶牛的编号。

### ✨ 核心算法标签
- 单源最短路（SSSP）  
- Dijkstra / SPFA / BFS（按边权范围选择）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：问题目标** | 题目要求“从起点1到若干目标点的最短路径 ≤ M”，典型的单源最短路需求。 |
| **线索2：数据规模** | F ≤ 500，P ≤ 1000，M ≤ 70000，边权正。Dijkstra O(P log F) 或 SPFA O(kP) 均可轻松通过。 |
| **线索3：输出要求** | 需要按**输入顺序**输出奶牛编号，而不是按农场编号。意味着：先存下“第i头牛在哪个农场”，再统一比对。 |

---

### 🧠 思维链构建：从线索到策略
> 1. **目标**：求1到所有农场最短路 → 单源最短路。  
> 2. **约束**：边权为正 → 直接排除负权算法，Dijkstra、SPFA、BFS皆可。  
> 3. **输出**：先记录每头牛的“所在农场”，再遍历一次统计答案，避免输出顺序错乱。  
> **结论**：跑一遍最短路 → 扫一遍奶牛数组 → 输出编号。就这么简单！

---

## 2. 精选优质题解参考

### 题解一：书虫仔的SPFA（赞12）
> **亮点**：直接跑1号点的SPFA，用`dist[x] ≤ M`判断，代码极简；输出部分用数组存编号再排序，避免顺序错误。  
> **学习笔记**：SPFA在正权图上依然好写，但Dijkstra更稳健。

### 题解二：WanderingTrader的朴素Dijkstra（赞5）
> **亮点**：手写邻接表+朴素O(F²) Dijkstra，数据范围小，跑得飞快；代码结构清晰，变量命名规范。  
> **学习笔记**：500点以内，朴素Dijkstra常数极小，不必堆优化。

### 题解三：Tomwsc的BFS（赞2）
> **亮点**：利用“边权≤70000”且**整数**的特性，直接BFS（0-1 BFS不适用，但边权小可做桶优化）。  
> **学习笔记**：当边权范围小时，BFS+桶可达到O(P+maxW)的复杂度，但本题Dijkstra更通用。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：Dijkstra堆优化）

| 关键点 | 分析 & 学习笔记 |
|---|---|
| **1. 图的存储** | 邻接表/链式前向星存无向图，注意重边取最小值。 |
| **2. 最短路算法选择** | 边权正 → Dijkstra堆优化O(P log F)最稳健；SPFA在正权图上平均快但最坏退化。 |
| **3. 输出顺序处理** | 用数组`cow[i] = farmID`记录第i头牛的位置，最后遍历`i=1..C`判断`dist[cow[i]] ≤ M`，直接输出i即可。 |

---

### ✨ 解题技巧总结
- **技巧A：重边处理**  
  读入时`w = min(w, old_w)`，避免多条重边导致错误。
- **技巧B：输出顺序**  
  先统计答案数量再输出编号，避免多次遍历奶牛数组。
- **技巧C：常数优化**  
  小规模图(F≤500)可大胆用朴素Dijkstra，减少STL堆的开销。

---

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力Floyd** | O(F³)全源最短路 | 思路直观 | 70000×500³直接爆炸 | 仅教学 |
| **朴素Dijkstra** | O(F²) | 代码短，常数小 | 理论复杂度差 | F≤1000 |
| **堆优化Dijkstra** | O(P log F) | 通用稳健 | 需手写堆或STL | 正权图标配 |
| **SPFA** | 平均O(kP) | 平均快，代码短 | 可被卡到O(FP) | 无负权推荐 |
| **BFS桶优化** | O(P+maxW) | 边权小时极快 | 需边权整数且范围小 | 边权≤1e5 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（堆优化Dijkstra）

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 505, MAXM = 2005;
struct Edge { int v, w, next; } e[MAXM];
int head[MAXN], cnt, dist[MAXN], cow[105];

inline void add(int u, int v, int w) {
    e[++cnt] = {v, w, head[u]};
    head[u] = cnt;
}

void dijkstra(int n, int s) {
    fill(dist, dist + n + 1, 0x3f3f3f3f);
    priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;
    dist[s] = 0;
    pq.emplace(0, s);
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d != dist[u]) continue;
        for (int i = head[u]; i; i = e[i].next) {
            int v = e[i].v, w = e[i].w;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                pq.emplace(dist[v], v);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int F, P, C, M;
    cin >> F >> P >> C >> M;
    for (int i = 1, u, v, w; i <= P; ++i) {
        cin >> u >> v >> w;
        add(u, v, w);
        add(v, u, w);
    }
    for (int i = 1; i <= C; ++i) cin >> cow[i];
    dijkstra(F, 1);

    vector<int> ans;
    for (int i = 1; i <= C; ++i)
        if (dist[cow[i]] <= M) ans.push_back(i);

    cout << ans.size() << '\n';
    for (int id : ans) cout << id << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 演示主题：像素侦探追踪奶牛

- **场景**：8位像素农场地图，1号谷仓为起点，奶牛图标标记目标点。
- **算法**：堆优化Dijkstra  
  1. **初始化**：起点像素闪烁，距离数组`dist`以像素条显示。  
  2. **松弛过程**：当前节点高亮，出边像素路径流动，距离条动态缩短。  
  3. **音效**：每次松弛成功播放“叮”的8位音效，失败播放短促“咔”。  
  4. **完成**：所有奶牛位置打钩/打叉，播放胜利BGM。

- **交互**：  
  - 单步/自动播放按钮  
  - 速度滑块（1x-8x）  
  - “显示路径”开关，回溯最短路径高亮

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **单源最短路**可用于：  
  1. 网络延迟测试（求1到所有服务器的最小时延）  
  2. 物流配送（仓库到各门店的最短运输时间）  
  3. 游戏AI寻路（NPC到玩家的最短路径）

### 洛谷推荐
1. **P4779** 【模板】单源最短路径（标准版）  
   🗣️ 推荐理由：Dijkstra堆优化模板，必练。
2. **P1529** 回家  
   🗣️ 推荐理由：多源多汇，需两次最短路。
3. **P1629** 邮递员送信  
   🗣️ 推荐理由：正向+反向最短路，思维拓展。

---

## 7. 学习心得与经验分享

> **来自WanderingTrader**：  
> “朴素Dijkstra在小数据下比堆优化还快，别迷信STL！”  
> **点评**：提醒我们根据数据规模选择算法，避免过度优化。

> **来自Tomwsc**：  
> “边权小且整数时，BFS桶优化也能过，思路更直观。”  
> **点评**：边权特性是选择算法的重要信号。

---

### 🎯 总结
单源最短路是图论基石，本题完美示范了“建模→算法→输出”的标准流程。  
记住：先跑最短路，再扫答案，顺序别弄反！  
下次遇到“距离≤阈值”类问题，第一时间想到Dijkstra/SPFA即可。

---
处理用时：57.22秒
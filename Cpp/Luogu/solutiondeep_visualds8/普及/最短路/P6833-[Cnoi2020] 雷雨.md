# 题目信息

# [Cnoi2020] 雷雨

## 题目背景

> 令人不安的云开始笼罩天空。  
巨大的建筑在强风中轧轧作响。  
幻想乡中响彻着不和协音。  
——「东方辉针城 ～ Double Dealing Character」

一个雷雨交加的夜晚，一束闪电击中了雾之湖畔的红魔馆和迷途竹林。

似乎有什么大事要发生，Cirno 在小屋静静地中思考着。

## 题目描述

幻想乡的纵切面可以抽象成一个 $n\times m$ 的矩形。

其中每一个 $1\times 1$ 的单元格 $(i,j)$ 都有一个**电阻计量值**(虚构的概念) $R_{i,j}$。

闪电从**雷雨云**上的 $\texttt{O}(n,a)$ 发出，击中了**地面**上的*红魔馆* $\texttt{A}(1,b)$ 与*迷途竹林* $\texttt{B}(1,c)$。

雷电是自然的造物，所以覆盖的位置电阻计量值总和最小，即从 $\texttt{O}$ 到 $\texttt{A}$ 与 $\texttt{B}$ 的**两条路径的并集**的电阻计量值的和最小。

所以在所有位置电阻计量已知的情况下，Cirno 想知道雷电的经过的路径的最小电阻计量值的和。

## 说明/提示

## 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/7ozs40i3.png)

如图黄色线为闪电的路径。

## 数据范围与约定

对于 $100\%$ 的数据保证：$0<n,m \le 1000$，$0 \le R_{i,j}\le 10^9$，$0< a,b,c \le m$。

#### 子任务「本题采用捆绑测试」

 - Subtask1（$10\%$）: $R_{i,j}\in\{1\}$。
 - Subtask2（$10\%$）: $R_{i,j}\in\{0,1\}$。
 - Subtask3（$10\%$）: $a=b=c$。
 - Subtask4（$10\%$）: $n,m \le 5$。
 - Subtask5（$60\%$）: 无特殊限制。
 

## 样例 #1

### 输入

```
5 5 1 2 4
1 8 1 6 6
1 1 1 2 4
8 3 1 2 2
1 2 1 9 1
1 0 9 1 1```

### 输出

```
15```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：[Cnoi2020] 雷雨 深入学习指南 💡

> 欢迎来到今天的探险！我们要在电闪雷鸣的幻想乡中，帮Cirno找出一条“最省电”的闪电路径。准备好跟我一起拆解这道经典网格图最短路题了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“闪电从雷雨云O(1,a)同时劈向地面两点A(n,b)、B(n,c)，要求**两条路径的并集**的电阻值之和最小。”  
换句话说：两条路径如果重叠，重叠段只算一次。  
✨ **核心算法标签**：最短路 / Dijkstra / 网格图

### 🗣️ 初步分析
- 最朴素的想法：先分别跑 O→A、O→B 的最短路，再把两条路径上的点权相加并去重。但“去重”这一步很难高效实现。
- 关键洞察：两条路径一定在某个点 P 处“分叉”。于是问题转化为——  
  **枚举所有可能的 P，计算 (O→P + A→P + B→P) 并减去 P 被重复计算的 2 次权值**  
  公式：`min{ disO[P] + disA[P] + disB[P] – 2·R[P] }`

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：最小化“带权路径并集”——经典最短路模型，但需处理重叠。
2. **线索2 (问题结构)**：网格图，边权=目标格点权，暗示 Dijkstra 或 BFS。
3. **线索3 (数据规模)**：n,m ≤ 1000，共 1e6 个点。三次 Dijkstra 复杂度 O(nm log nm) ≈ 1e6 log 1e6 ≈ 2e7，可过。

### 🧠 思维链构建：从线索到策略
> “当我看到‘最小化两条路径并集’时，第一反应是分别跑最短路再合并，但‘并集’让我意识到需要共享一段路径。于是想到：  
> 1. 枚举分叉点 P，把问题拆成三段独立最短路；  
> 2. 网格图适合 Dijkstra，跑三遍即可；  
> 3. 数据范围告诉我，1e6 log 1e6 可接受。  
> 结论：**三遍 Dijkstra + 全局枚举** 是最优策略！”

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 推荐指数 |
|------|-----------|----------|
| **Lonely_NewYear** (赞31) | 首提“枚举分叉点 + 三次 Dijkstra”模型，公式 `ans = dis0+dis1+dis2-2R`，代码简洁。 | ⭐⭐⭐⭐⭐ |
| **InformationEntropy** (赞7) | 清晰证明“二叉路径”最优，强调 `long long` 与坐标翻转细节。 | ⭐⭐⭐⭐ |
| **Rubidium_Chloride** (赞5) | 用优先队列 BFS（=Dijkstra）+ 证明“交叉点唯一”，博客排版精美。 | ⭐⭐⭐⭐ |
| **dead_X** (赞3) | 显式建图（邻接表）+ 三次 Dijkstra，适合不熟悉网格图的同学参考。 | ⭐⭐⭐ |

> 小贴士：所有高分题解都统一了“枚举分叉点”思想，差异只在实现细节（是否显式建图、坐标映射方式等）。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
1. **关键点1：坐标与编号映射**  
   - 把二维 (i,j) 压缩成一维 id = (i-1)*m + j，方便邻接表/数组存储。  
   💡 **学习笔记**：网格图常见技巧，降低思维复杂度。

2. **关键点2：点权转边权**  
   - 边 (u→v) 的权值取 v 的点权，保证“到达 v 时才计入电阻”。  
   💡 **学习笔记**：起点自身的权值需单独加到初始距离里。

3. **关键点3：三遍 Dijkstra 的复用**  
   - 分别以 (1,a)、(n,b)、(n,c) 为源点跑最短路，得到 `dis[3][N]`。  
   - 最后 O(nm) 枚举每个点 P 计算 `dis[0][P] + dis[1][P] + dis[2][P] - 2·R[P]`。  
   💡 **学习笔记**：三次最短路互不干扰，可并行实现。

### ✨ 解题技巧总结
- **技巧A：方向数组**  
  `int dx[4]={-1,1,0,0}, dy[4]={0,0,-1,1}` 优雅处理四方向扩展。
- **技巧B：优先队列优化**  
  `priority_queue<node, vector<node>, greater<node>>` 保证 O(E log V)。
- **技巧C：剪枝**  
  用 `vis` 或 `d` 数组判重，避免重复松弛。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|------|-----------|------|------|---------------|
| **暴力DFS/BFS** | 分别跑 O→A、O→B 最短路后暴力去重 | 思路直观 | 去重复杂，时间爆炸 | Subtask4(n≤5) 10% |
| **SPFA** | 同 Dijkstra 但用队列 | 代码短 | 网格图易被卡 | 0%（已死） |
| **三遍Dijkstra** | 枚举分叉点 + 预处理最短路 | 100% AC，复杂度正确 | 需写堆优化 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1005;
const ll INF = 1e18;
int n, m, a, b, c, R[N][N];
ll dis[3][N][N];
int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};

struct Node {
    int x, y; ll d;
    bool operator<(const Node& o) const { return d > o.d; }
};

void dijkstra(int sx, int sy, int k) {
    priority_queue<Node> q;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) dis[k][i][j] = INF;
    dis[k][sx][sy] = R[sx][sy];
    q.push({sx, sy, R[sx][sy]});
    while (!q.empty()) {
        auto [x, y, d] = q.top(); q.pop();
        if (d != dis[k][x][y]) continue;
        for (int i = 0; i < 4; ++i) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx < 1 || nx > n || ny < 1 || ny > m) continue;
            if (dis[k][nx][ny] > d + R[nx][ny]) {
                dis[k][nx][ny] = d + R[nx][ny];
                q.push({nx, ny, dis[k][nx][ny]});
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> a >> b >> c;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) cin >> R[i][j];

    dijkstra(1, a, 0);
    dijkstra(n, b, 1);
    dijkstra(n, c, 2);

    ll ans = INF;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j)
            ans = min(ans, dis[0][i][j] + dis[1][i][j] + dis[2][i][j] - 2 * R[i][j]);
    cout << ans;
    return 0;
}
```

- **代码解读概要**：  
  三次 Dijkstra 分别把 (1,a)、(n,b)、(n,c) 作为起点，计算到所有点的最短距离。最后扫描全图，利用公式得到最小并集电阻。

---

## 5. 算法可视化：像素动画演示

> 让我们用 8 位像素风小游戏来直观感受三遍 Dijkstra 的全过程！

### 动画主题
**《雷电小精灵分叉记》**  
- 场景：1000×1000 像素的网格迷宫，每个格子用 8×8 像素方块表示，颜色深浅对应电阻值大小。  
- 角色：红色小精灵（起点）、蓝色小精灵（终点A）、绿色小精灵（终点B）。  
- 目标：找到最优分叉点 P，使三条闪电（红→P→蓝，红→P→绿）总电阻最小。

### 关键帧与交互
| 阶段 | 像素动画 | 音效/旁白 |
|------|-----------|-----------|
| 初始化 | 迷宫生成，起点、终点闪烁 | 8 位“滴”提示音 |
| Dijkstra #1 | 红色波浪从起点向外扩散，格子颜色随距离变化 | “叮”每更新一次最短距离 |
| Dijkstra #2 #3 | 蓝、绿色波浪分别扩散 | 不同音高区分 |
| 枚举分叉点 | 像素放大镜逐格扫描，实时显示 `dis0+dis1+dis2-2R` | “哒哒”扫描声 |
| 找到最优 | 最优 P 点爆炸成金色星星，三条闪电路径高亮 | 胜利音效 |

### 技术实现
- Canvas 2D 渲染 8×8 像素块，使用 16 色调色板。  
- 优先队列事件驱动动画：每次 `push/pop` 对应一格高亮。  
- 控制面板：单步/自动/调速滑块；显示当前公式值。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **三源最短路径模型**：  
  1. 多仓库物流配送，求最近配送点到客户的并集成本。  
  2. 三辆救护车从不同医院出发，汇合后一起去两处事故现场的最短时间。  
  3. 网络布线：主干线到两个终端，要求共享段最短。

### 洛谷推荐练习
1. **P4779** 【模板】单源最短路径（标准堆优化 Dijkstra）  
   🗣️ 先把板子打牢，再来做网格图变形。
2. **P5683** 【CSPJX2019】道路拆除  
   🗣️ 与本题几乎同模，练手“枚举分叉点”。
3. **P1629** 邮递员送信  
   🗣️ 正反两遍最短路，体会“来回路径”思想。

---

## 7. 学习心得与经验分享

> 摘录自 **Lonely_NewYear**：  
> “十年 OI 一场空，不开 long long 见祖宗。”  
> **点评**：本题数值可达 1e9×1e6=1e15，必须使用 64 位整型；同时注意坐标映射别写反。

---

> 恭喜你完成本次探险！记住：  
> “最优路径往往隐藏在看似平凡的分叉点里，学会枚举 + 预处理，就能让闪电为你导航。”  
> 下次见！⚡
```

---
处理用时：71.25秒
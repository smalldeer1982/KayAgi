# 题目信息

# [蓝桥杯 2022 国 B] 出差

## 题目描述

$\mathrm{A}$ 国有 $N$ 个城市，编号为 $1 \ldots N$ 小明是编号为 $1$ 的城市中一家公司的员工，今天突然接到了上级通知需要去编号为 $N$ 的城市出差。

由于疫情原因，很多直达的交通方式暂时关闭，小明无法乘坐飞机直接从城市 $1$ 到达城市 $N$，需要通过其他城市进行陆路交通中转。小明通过交通信息网，查询到了 $M$ 条城市之间仍然还开通的路线信息以及每一条路线需要花费的时间。

同样由于疫情原因，小明到达一个城市后需要隔离观察一段时间才能离开该城市前往其他城市。通过网络，小明也查询到了各个城市的隔离信息。（由于小明之前在城市 $1$，因此可以直接离开城市 $1$，不需要隔离）

由于上级要求，小明希望能够尽快赶到城市 $\mathrm{N}$, 因此他求助于你，希望你能帮他规划一条路线，能够在最短时间内到达城市 $N$ 。


## 说明/提示

**【样例说明】**

![](https://cdn.mathpix.com/cropped/2022_09_29_8ee8d95d6d0319bca20dg-09.jpg?height=464&width=478&top_left_y=1249&top_left_x=309)

**【评测用例规模与约定】**

对于 $100 \%$ 的数据, $1 \leq N \leq 1000,1 \leq M \leq 10000,1 \leq C_{i} \leq 200,1 \leq u, v \leq$ $N, 1 \leq c \leq 1000$ 


蓝桥杯 2022 国赛 B 组 E 题。

## 样例 #1

### 输入

```
4 4
5 7 3 4
1 2 4
1 3 5
2 4 3
3 4 5```

### 输出

```
13```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：出差（蓝桥杯 2022 国 B）深入学习指南 💡

> 欢迎来到今天的“算法探险”！我们要帮小明规划一条从城市 1 到城市 N 的最快路线。疫情带来了一个有趣的小插曲：**每到一个城市，还要先“隔离”一段时间**。如何把“隔离时间”巧妙地融入最短路算法？这正是本题的精髓。

---

## 1. 题目解读与策略初探

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 线索内容 | 侦探笔记 |
| --- | --- | --- |
| 线索1 | **求“最短时间”** | 带权最短路经典信号！ |
| 线索2 | **到达城市需隔离** | 把“点权”加到“边权”即可，化繁为简。 |
| 线索3 | **N ≤ 1000, M ≤ 10 000** | Dijkstra 堆优化 O(M log N) ≈ 10⁴·log 10³ ≈ 10⁵ 次计算，稳过！ |

### 🧠 思维链构建：从线索到策略
> “线索1”告诉我：**最短路**！  
> “线索2”提醒我：隔离时间其实是**点权**，把它“搬到”**边权**上，问题瞬间变成“普通最短路”。  
> “线索3”确认：**Dijkstra 堆优化**是最佳选择。  
> 结论：把点权塞进边权，跑一次 Dijkstra，最后别忘了把终点 N 的隔离时间减掉即可！

---

## 2. 精选优质题解参考

| 题解 | 作者 | 亮点提炼 | 点评 |
| --- | --- | --- | --- |
| 1 | Strelizia_Qy | 用 `vector<pii>` 存图，思路直白；把点权直接加到边权，代码极短。 | 思路清晰，适合初学者快速掌握“点权转边权”技巧。 |
| 2 | Zvelig1205 | 链式前向星 + 手写堆结构体，展示最短路多种写法。 | 展示了竞赛中常用的链式前向星写法，可加深对底层实现理解。 |
| 3 | gesong | 简洁 Dijkstra 模板，双向边+点权处理一步到位。 | 代码短、易读，是快速 AC 的“模板级”示范。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

1. **如何优雅地把“点权”并入“边权”**  
   * **分析**：把原边权 `w(u→v)` 改为 `w(u→v) + c[v]`。  
   * 💡 学习笔记：点权→边权是经典套路，适用于所有“经过节点需额外代价”的最短路题。

2. **如何正确处理“终点不隔离”**  
   * **分析**：Dijkstra 结束后，答案 = `dis[n] - c[n]`。  
   * 💡 学习笔记：读题要细！终点、起点是否需要点权常是易错点。

3. **如何高效实现 Dijkstra**  
   * **分析**：  
     - **邻接表**：`vector<pii> G[N]` 或链式前向星。  
     - **堆优化**：`priority_queue<pii, vector<pii>, greater<pii>>` 保证 O(M log N)。  
   * 💡 学习笔记：竞赛中 STL 优先队列足以应对 1e5 级别数据。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
| --- | --- | --- | --- | --- |
| **朴素 Dijkstra** | 邻接矩阵 + O(N²) | 代码最短 | N=1e3 时 1e6 仍可行，但非最优 | 100% |
| **Dijkstra 堆优化** | 邻接表 + 堆 | 标准竞赛写法，O(M log N) | 需掌握优先队列 | 100% |
| **SPFA** | 队列 + 松弛 | 可处理负权 | 最坏 O(N·M) 被卡 | 100%（本题无负权，SPFA 也能过） |

---

## 4. C++核心代码实现赏析

### 通用核心参考（Strelizia_Qy 版）
```cpp
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int,int>;
const int N = 1e5 + 5, INF = 0x3f3f3f3f;

int n, m, c[N], dis[N];
vector<pii> G[N];

void dijkstra() {
    fill(dis, dis + n + 1, INF);
    priority_queue<pii, vector<pii>, greater<pii>> pq;
    dis[1] = 0;
    pq.emplace(0, 1);
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d != dis[u]) continue;          // 防重复入队
        for (auto [v, w] : G[u]) {
            int nd = d + w;
            if (nd < dis[v]) {
                dis[v] = nd;
                pq.emplace(nd, v);
            }
        }
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> c[i];
    for (int i = 0; i < m; ++i) {
        int u, v, w; cin >> u >> v >> w;
        G[u].emplace_back(v, w + c[v]);     // 把点权 c[v] 加到边权
        G[v].emplace_back(u, w + c[u]);     // 双向边
    }
    dijkstra();
    cout << dis[n] - c[n];                  // 终点不隔离
    return 0;
}
```
> 代码解读概要：  
> 1. 读入城市数、道路数、各城市隔离时间。  
> 2. 构建邻接表，边权 = 原时间 + 目的城市隔离时间。  
> 3. 跑 Dijkstra 堆优化求最短路。  
> 4. 输出 `dis[n] - c[n]`，别忘了终点不隔离！

---

## 5. 算法可视化：像素动画演示

### 主题：**“像素快递员”的隔离之旅**

#### 设计思路
- **8-bit 像素风格**：城市用 16×16 像素方块表示，方块颜色 = 隔离时长（越深越长）。  
- **路线动画**：Dijkstra 每松弛一条边，像素快递员从当前城市跳到下一城市，路径高亮，伴随“叮”的 8-bit 音效。  
- **实时信息面板**：  
  - 左上角实时显示 `dis[]` 数组（像素数字）。  
  - 右下角进度条：已松弛边数 / 总边数。  
- **交互按钮**：  
  - “自动播放”：AI 自动跑完 Dijkstra。  
  - “单步执行”：每按一次，松弛一条边，方便观察。  
- **胜利动画**：当 `dis[n]` 被更新到最小值时，城市 N 像素块闪金光，播放“胜利”音效。

#### 关键帧示意
| 帧 | 画面 | 旁白 |
|---|---|---|
| 0 | 城市 1 亮绿灯，`dis[1]=0` | 出发！ |
| 1 | 城市 2、3 被松弛，`dis[2]=4+5=9`, `dis[3]=5+7=12` | 把隔离时间加进去！ |
| 2 | 城市 4 被城市 2 松弛，`dis[4]=9+3+4=16` | 继续加隔离！ |
| 3 | 城市 4 被城市 3 再次松弛，`dis[4]=12+5+4=21` → 不更新 | 发现更短？否！ |
| 4 | 最终 `dis[4]=16-4=12` | 终点不隔离，答案 12！ |

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
1. **“点权转边权”** 适用于：  
   - 过路费、进城税、冷却时间等场景。  
2. **双向边建图** 适用于：  
   - 无向图最短路、最小生成树。  
3. **堆优化 Dijkstra** 适用于：  
   - 所有非负权最短路、网络流费用流中的最短路子问题。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| [P4779 【模板】单源最短路径（标准版）](https://www.luogu.com.cn/problem/P4779) | 经典 Dijkstra 模板，巩固堆优化写法。 |
| [P1529 回家](https://www.luogu.com.cn/problem/P1529) | 点权 + 最短路 + 多源，进一步练习建模。 |
| [P2865 [USACO06NOV] Roadblocks G](https://www.luogu.com.cn/problem/P2865) | 次短路 + Dijkstra，提升最短路思维深度。 |

---

## 7. 学习心得与经验分享

> **来自 Strelizia_Qy**：  
> “我最初把终点隔离时间也加了进去，结果样例输出 17。后来才发现要减掉 `c[n]`。读题一定要细心！”  
> **洛语云笺点评**：  
> 细节决定成败！把“终点不隔离”写成注释贴在代码里，避免手滑。

---

<conclusion>
今天我们一起把“隔离时间”巧妙地“藏”进了边权，用最朴素的 Dijkstra 堆优化轻松拿下 100 分。记住：**点权转边权**、**终点减点权**、**双向边别忘记**。下次遇到类似套路，你就能一眼识破！继续加油，我们下道题再见！

---
处理用时：59.02秒
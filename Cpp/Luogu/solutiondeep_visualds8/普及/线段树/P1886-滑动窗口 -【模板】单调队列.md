# 题目信息

# 滑动窗口 /【模板】单调队列

## 题目描述

有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

例如，对于序列 $[1,3,-1,-3,5,3,6,7]$ 以及 $k = 3$，有如下过程：

$$\def\arraystretch{1.2}
\begin{array}{|c|c|c|}\hline
\textsf{窗口位置} & \textsf{最小值} & \textsf{最大值} \\ \hline
\verb![1   3  -1] -3   5   3   6   7 ! & -1 & 3 \\ \hline
\verb! 1  [3  -1  -3]  5   3   6   7 ! & -3 & 3 \\ \hline
\verb! 1   3 [-1  -3   5]  3   6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1 [-3   5   3]  6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1  -3  [5   3   6]  7 ! & 3 & 6 \\ \hline
\verb! 1   3  -1  -3   5  [3   6   7]! & 3 & 7 \\ \hline
\end{array}
$$

## 说明/提示

【数据范围】    
对于 $50\%$ 的数据，$1 \le n \le 10^5$；  
对于 $100\%$ 的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。


## 样例 #1

### 输入

```
8 3
1 3 -1 -3 5 3 6 7```

### 输出

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：滑动窗口 /【模板】单调队列 深入学习指南 💡

> 大家好，我是你们的算法伙伴洛语云笺！今天我们要一起攻克的是 **“滑动窗口”** 这道经典的C++模板题。它看似简单，却暗藏玄机，是引出 **“单调队列”** 这一强大数据结构的绝佳入口。让我们一起抽丝剥茧，从暴力到高效，感受算法之美！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在一条不断向右滑动的“窗口”中，**实时**找出每个窗口内的**最大值和最小值**。关键在于“实时”与“高效”，因为窗口数量可能非常多。

✨ **核心算法标签**：单调队列（Monotonic Queue）、滑动窗口（Sliding Window）、双端队列（Deque）。

🗣️ **初步分析**：
- **最直观的想法**（暴力）：对于每个窗口，遍历一遍找出最值。时间复杂度为O(n*k)，当k很大时，这显然会超时。
- **进阶思考**：如何**避免重复计算**？我们发现，当窗口向右滑动时，前一个窗口的信息能否被后一个窗口**复用**？
- **引出核心算法**：**单调队列**就像一位精明的管家，它只保留“有潜力”成为最值的元素，将那些“永无出头之日”的元素及时剔除。这样，每个元素最多进出队列一次，整体复杂度降至**O(n)**，这是解决本题的金钥匙！

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**: “每次滑动后求最值”——这是一个**在线查询**问题，需要数据结构支持**高效插入、删除和查询最值**。
2. **线索2 (问题约束)**: “窗口长度固定为k”——这意味着**窗口的左右边界是单调递增的**，这暗示我们可以使用**单调性**来优化。
3. **线索3 (数据规模)**: n最大1e6，要求算法必须是**线性或线性对数**级别，O(n^2)的暴力显然不可行，直接指向O(n)的单调队列。

### 🧠 思维链构建：从线索到策略
> “好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1. 首先，【线索1：在线查询】告诉我们需要一个能快速查询最值的数据结构，我首先想到了**优先队列（堆）**，但它删除“过期”元素效率低。
> 2. 接着，【线索2：边界单调】给了我一个决定性的提示。窗口的单调移动意味着**元素的生命周期是连续的**，我们可以用**队列**来维护窗口内的元素。
> 3. 最后，【线索3：数据规模】给了我们最终判决。O(n*k)的暴力会超时，而**单调队列**的O(n)复杂度完美契合。
> 4. **结论**：综合以上，一个能利用**单调性**维护窗口最值的**双端队列**结构，就是我们的目标。**单调队列**完美符合所有条件，这就是我们接下来要深入研究的主攻方向！

---

## 2. 精选优质题解参考

<eval_intro>
在浩瀚的题解海洋中，我为大家精心挑选了以下两份质量极高的题解，它们在思路、代码和启发性上都堪称典范。
</eval_intro>

**题解一：hilsinleri的“单调队列详解” (赞：877)**
* **点评**：这份题解是单调队列的“教科书级”解释。作者用**生动的语言**和**逐步的示例**（如1,3,-1,-3...的入队出队过程），将抽象的算法变得具体可感。它不仅讲清楚了“怎么做”，更解释了“为什么这么做”，对初学者极其友好。代码简洁，注释清晰，是入门单调队列的不二之选。

**题解二：Jerrycyx的“单调队列专栏” (赞：8)**
* **点评**：这篇题解的亮点在于其**通用模板**和**深度总结**。作者将单调队列的精髓提炼为：“**老而更劣的元素永远不可能成为最值**”，一语道破核心。他提供的模板代码（求最小值，最大值通过取反复用）非常实用，且对单调队列在DP优化中的应用做了前瞻性提示，极具启发性。

---

## 3. 解题策略深度剖析

<difficulty_intro>
让我们深入剖析解决“滑动窗口最值”问题的几种策略，看看高手是如何权衡与选择的。
</difficulty_intro>

### 🎯 核心难点与关键步骤 (最优解法：单调队列)
1. **关键点1：如何维护队列的单调性？**
   * **分析**：队列中的元素必须保持**单调递增（求最小值）**或**单调递减（求最大值）**。当新元素加入时，从队尾开始，将所有“比新元素劣”（即不可能再成为最值）的元素弹出。
   * 💡 **学习笔记**：核心思想是**“后来者居上”**。如果一个新元素比队列中的某个旧元素更优，那么那个旧元素就永远失去了机会，可以安全地移除。

2. **关键点2：如何处理“过期”元素？**
   * **分析**：由于窗口在滑动，队列头部的元素可能已不在当前窗口内。通过检查元素的**索引（下标）**来判断其是否过期，并及时从队头弹出。
   * 💡 **学习笔记**：单调队列存储的是**元素的下标**，而非元素值本身。这样可以方便地通过 `i - q[head] + 1 > k` 来判断元素是否越界。

3. **关键点3：如何高效实现？**
   * **分析**：使用**双端队列（deque）**或**数组模拟队列**。双端队列支持O(1)的队头队尾插入删除操作，是实现单调队列的理想选择。
   * 💡 **学习笔记**：手写队列（数组+头尾指针）通常比STL的deque更快，尤其在竞赛中。

### ✨ 解题技巧总结
- **技巧A (问题转化)**：将“滑动窗口”问题转化为“维护一个单调的双端队列”问题。
- **技巧B (空间换时间)**：通过维护单调队列，用O(n)的额外空间换取O(n)的时间复杂度，避免O(n*k)的暴力。
- **技巧C (通用模板)**：先写出一个求最小值的模板，求最大值时只需将比较符号取反，或先取反数组再复用模板。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力枚举** | 对每个窗口遍历k个元素求最值。 | 思路直观，编码简单。 | **时间复杂度**: O(n*k)，当k=1e5时会超时。<br>**优化方向**: 无根本优化。 | 数据规模 n,k ≤ 2000。<br>竞赛中预计可得 **20%-40%** 分数。 |
| **优先队列（堆）** | 用大/小根堆维护窗口内元素。 | 查询最值O(1)。 | **删除过期元素困难**：需要“懒删除”技巧，实现复杂，均摊O(log n)。 | 窗口长度不固定，或需要动态插入删除。<br>本题中可得 **70%-80%** 分数（需优化）。 |
| **线段树/树状数组** | 构建区间最值查询结构。 | 通用性强，可处理复杂区间查询。 | **时间复杂度**: O(n log n)，略逊于单调队列。<br>**常数较大**：线段树常数大，树状数组求最值不直观。 | 需要处理更复杂的区间查询（如区间和、区间最值）。<br>本题中可得 **80%-90%** 分数。 |
| **单调队列 (最优策略)** | 用双端队列维护单调性，剔除无效元素。 | **时间复杂度**: O(n)，最优。<br>**空间复杂度**: O(n)。<br>**实现简单**：代码短小精悍。 | 需要理解单调性原理。 | 本题的最佳实践，**固定长度滑动窗口最值**。<br>可得 **100%** 分数。 |

### ✨ 优化之旅：从“能做”到“做好”
> “优化之旅”就像一场从徒步到高铁的升级。起初，我们用最朴素的暴力（徒步），虽然能到达终点，但耗时耗力。接着，我们尝试用优先队列（自行车），发现它能加速查询，但处理“下车”（删除过期元素）却很麻烦。最后，我们发现了单调队列（高铁），它通过**维护元素的“未来潜力”**（单调性），让每个元素只“上车”和“下车”一次，实现了**线性时间**的完美跃迁。这告诉我们，优秀的算法往往源于对问题**内在结构**的深刻洞察！

---

## 4. C++核心代码实现赏析

<code_intro_overall>
下面，我将为大家呈现一份**通用、高效且易于理解**的单调队列核心实现，它融合了多位优秀题解的精华。
</code_intro_overall>

**本题通用核心C++实现参考**
* **说明**：本代码综合了hilsinleri和Jerrycyx两位作者的思路，旨在提供一个清晰、完整且可直接用于竞赛的单调队列模板。
* **完整核心代码**：
    ```cpp
    #include <iostream>
    #include <deque>
    #include <vector>
    using namespace std;

    const int MAXN = 1e6 + 10;
    int a[MAXN], ans_min[MAXN], ans_max[MAXN];

    void solve(const vector<int>& nums, int k, int res[], bool is_min) {
        deque<int> dq; // 存储下标
        for (int i = 0; i < nums.size(); ++i) {
            // 1. 移除队头过期元素
            while (!dq.empty() && dq.front() <= i - k) {
                dq.pop_front();
            }
            // 2. 维护单调性：从队尾移除劣元素
            while (!dq.empty() && 
                   (is_min ? nums[dq.back()] >= nums[i] : nums[dq.back()] <= nums[i])) {
                dq.pop_back();
            }
            dq.push_back(i);
            // 3. 记录答案
            if (i >= k - 1) {
                res[i - k + 1] = nums[dq.front()];
            }
        }
    }

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        int n, k;
        cin >> n >> k;
        vector<int> nums(n);
        for (int i = 0; i < n; ++i) cin >> nums[i];

        solve(nums, k, ans_min, true);  // 求最小值
        solve(nums, k, ans_max, false); // 求最大值

        for (int i = 0; i <= n - k; ++i) cout << ans_min[i] << " \n"[i == n - k];
        for (int i = 0; i <= n - k; ++i) cout << ans_max[i] << " \n"[i == n - k];
        return 0;
    }
    ```
* **代码解读概要**：
    - `solve`函数是核心，通过参数`is_min`控制求最小值或最大值，体现了代码复用性。
    - **步骤1**：检查队头元素是否已滑出窗口，确保所有队列元素都在当前窗口内。
    - **步骤2**：从队尾开始，移除所有比当前元素“劣”的元素，维护单调性。
    - **步骤3**：当窗口形成后（`i >= k-1`），队头即为当前窗口最值。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让大家更直观地感受单调队列的运作，我设计了一个**复古像素风**的动画，模拟窗口滑动时队列的动态变化！
</visualization_intro>

* **动画演示主题**：**“像素探险家的窗口之旅”**——一个8位像素风格的探险家，在一条由数字方块组成的“序列山脉”上，用一个固定大小的“探照灯”（窗口）寻找每个区域内的“宝藏”（最值）。

* **核心演示内容**：
  1. **初始化**：屏幕顶部显示序列 `1 3 -1 -3 5 3 6 7`，窗口大小`k=3`。
  2. **队列可视化**：在序列下方，有一个像素化的双端队列（用一排小方块表示），每个方块显示队列中元素的值，并用颜色区分：
     - **红色方块**：当前窗口内的最小值（队头）。
     - **灰色方块**：队列中的其他候选元素。
     - **闪烁的黄色箭头**：指示当前正在处理的元素。
  3. **动态过程**：
     - **插入元素**：当探险家（黄色箭头）移动到`a[i]`时，从队尾开始，所有比`a[i]`大的方块会“嘭”地一下碎裂消失（音效：8位“pop”），然后`a[i]`的方块滑入队列。
     - **移除过期元素**：当窗口滑动，队头方块如果“掉队”（索引超出窗口），它会从队列左侧“滑落”（音效：8位“whoosh”）。
     - **标记答案**：每当窗口完整形成，当前的最小值方块会闪烁金色光芒（音效：8位“ding”），并在屏幕右侧的答案栏中记录。
  4. **交互控制**：
     - **单步模式**：按空格键，动画逐步演示每一步。
     - **自动模式**：点击“AI探险”，探险家自动完成全程，速度可调（滑块控制）。
     - **重置按钮**：一键回到起点。

* **设计思路简述**：
  - **像素风格**：采用FC游戏经典的8色调色板，营造怀旧学习氛围。
  - **音效反馈**：每个关键操作（入队、出队、记录答案）都有对应的8位音效，强化记忆。
  - **游戏化**：将算法步骤转化为“探险”和“寻宝”，增加趣味性，帮助理解队列的单调性维护。

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握单调队列后，你会发现它是一把解决一类问题的“瑞士军刀”！
</similar_problems_intro>

* **通用思路/技巧迁移**：
  1. **动态规划优化**：当DP转移方程形如`dp[i] = min/max(dp[j] + cost(j, i))`，且j的范围满足单调性时，可用单调队列将O(n^2)优化到O(n)。例如：P3957 [NOIP2017] 跳房子。
  2. **滑动窗口中位数**：在固定窗口内求中位数，可结合两个单调队列（一个大根堆，一个小根堆）实现。
  3. **区间最大子段和**：当需要在线性时间内解决某些带限制的区间最大子段和问题时，单调队列可作为辅助工具。

* **练习推荐 (洛谷)**：
  1. **洛谷 P1886** - 滑动窗口 /【模板】单调队列
     * 🗣️ **推荐理由**：本题！巩固模板，理解单调队列的基本操作。
  2. **洛谷 P3957** - [NOIP2017] 跳房子
     * 🗣️ **推荐理由**：经典DP优化题，使用单调队列优化转移，体会其在DP中的威力。
  3. **洛谷 P1440** - 求m区间内的最小值
     * 🗣️ **推荐理由**：与滑动窗口类似，但窗口长度不固定，需灵活调整单调队列的实现。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
在分析众多题解时，我发现了一些宝贵的经验，希望能助你一臂之力。
</insights_intro>

> **来自Jerrycyx的专栏分享**：
> “单调队列的重点分为「单调」和「队列」。‘老而更劣的元素永远不可能成为最值’——记住这句话，你就掌握了它的灵魂。”
>
> **洛语云笺点评**：这句话精辟地总结了单调队列的核心思想。在调试时，如果发现答案错误，不妨检查：队列是否保持了正确的单调性？是否及时移除了过期元素？这两个问题往往是出错的根源。

---

<conclusion>
本次关于“滑动窗口”与“单调队列”的深度学习就到这里啦！希望你不仅掌握了O(n)的最优解法，更理解了如何从一个朴素的暴力思路，一步步优化到优雅的算法。记住，编程的乐趣在于不断探索和优化。下次，我们再一起挑战新的算法高峰！💪
</conclusion>

---
处理用时：84.92秒
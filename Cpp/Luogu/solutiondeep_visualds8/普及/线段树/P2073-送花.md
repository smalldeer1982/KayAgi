# 题目信息

# 送花

## 题目背景

小明准备给小红送一束花，以表达他对小红的爱意。他在花店看中了一些花，准备用它们包成花束。


## 题目描述

这些花都很漂亮，每朵花有一个美丽值 $W$，价格为 $C$。

小明一开始有一个空的花束，他不断地向里面添加花。他有以下几种操作：

- $1\ W\ C$：添加一朵美丽值为 $W$，价格为 $C$ 的花。  
**如果此时花束中已经有了相等价格的花，那么这朵花不能加入花束。**
- $2$：删除当前花束里最贵的一朵花。
- $3$：删除当前花束里最便宜的一朵花。
- $-1$：完成添加与删除，开始包装花束。

**当花束为空时，忽略操作 $2$ 和 $3$。**

请你写一个程序，计算出开始包装花束时，花束中所有花的美丽值的总和，以及小明需要为花束付出的总价格。

## 说明/提示

设操作数为 $m$。

- 对于 $20\%$ 数据，$m \le 100$，$1\le W,C\le 10^3$。
- 对于全部数据，$m \le 10^5$，$1\le W,C\le 10^6$。

## 样例 #1

### 输入

```
1 1 1
1 2 5
2
1 3 3
3
1 5 2
-1
```

### 输出

```
8 5```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：送花 深入学习指南 💡

> 今天我们来一起分析“送花”这道C++编程题。它看似只是一束花的小故事，却暗藏了数据结构的大乾坤：如何在一堆花里高效地“增删查极值”，并实时统计两路总和。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“价格唯一”的约束 + “随时删除最大/最小价格的花” + “实时输出两路总和”。  
换句话说，我们需要一个**有序**且**去重**的容器，支持 O(log n) 插入、删除极值、实时求和。

✨ **核心算法标签**：  
平衡树（Treap/Splay/红黑树）、优先队列 + 惰性删除、STL-set、线段树/权值线段树、树状数组 + 倍增。

🗣️ **初步分析**（从朴素到精妙）：

1. **暴力数组**（排序+扫描）：  
   每次插入后整体排序 → O(n log n)，删除极值 O(1)。  
   当 m=1e5 时，总复杂度 O(m n log n) 爆炸。

2. **优先队列 + 惰性删除**（Mychael、Judge 等）：  
   用两个堆分别维护最大/最小值，并用数组标记“已删”。  
   插入 O(log n)，删除极值均摊 O(log n)。实现最简单，实测 600-700 ms。

3. **STL-set**（kikuss、zhengrunzhe 等）：  
   直接让红黑树帮你排序，自带去重。插入/删除极值 O(log n)，代码最短，最慢点 30-50 ms。

4. **线段树/权值线段树**（秋日私语、yizimi远欣）：  
   以“价格”为下标建线段树，维护区间 max/min、两路 sum。  
   插入/删除极值 O(log C)，C=1e6 时约 20 次操作，跑得飞快。

5. **手写平衡树**（Treap/Splay/FHQ/替罪羊）：  
   锻炼代码能力，理论最优，最慢点 20-30 ms，但代码量最大。

> **结论**：  
> 对竞赛/考试而言，**STL-set** 或 **优先队列+惰性删除** 是最实用的“性价比”之王；  
> 想练数据结构，再挑战手写 Treap/Splay 不迟。

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 暗示 |
|---|---|---|
| **价格唯一** | “如果此时花束中已经有了相等价格的花，那么这朵花不能加入” | 需要**去重**容器：`set`, `map`, 或手动判重 |
| **随时删除最大/最小价格** | 操作2、3 | 暗示需要**有序**结构：优先队列、平衡树 |
| **实时两路总和** | 最终输出总美丽值、总价格 | 可额外维护变量，也可由数据结构本身维护 |
| **m≤1e5, C≤1e6** | 数据范围 | 允许 O(m log C) 的权值线段树；STL-set 的 O(m log m) 也轻松通过 |

### 🧠 思维链构建：从线索到策略
> 好了，侦探工作完成，我们把线索拼起来：  
> 1. 需要**有序+去重** → set / map 天然支持。  
> 2. 需要随时拿最大/最小 → set 的 begin()/rbegin() 直接取；或用两个堆。  
> 3. 需要实时统计两路总和 → 额外两个全局变量即可，插入/删除时同步更新。  
> 4. 复杂度 O(m log m) 完全可过，于是 STL-set 成为首选。  

---

## 2. 精选优质题解参考

### 题解一：kikuss —— “set极简AC”
> 这份题解思路极清晰：把每朵花抽象为 `{美丽值, 价格}`，并重载 `<` 让 set 按价格排序。插入时若价格已存在则跳过；删除最贵/最便宜直接 `--s.end()` 与 `s.begin()`。  
> **亮点**：  
> - 充分利用 STL-set 的自动排序与去重，代码仅 30 行。  
> - 提醒“set 的迭代器只支持 ++/--”，删除最大值时注意 `--s.end()` 的写法。  
> - 实测最慢点 30 ms，证明 STL 并不慢。  

### 题解二：XG_Zepto —— “优先队列+惰性删除”
> 用两个优先队列 + 数组 `v[c]=w` 实现“价格→美丽值”映射。  
> 插入时若 `v[c]` 已存在则跳过；删除时先弹出已失效的队头，再删除。  
> **亮点**：  
> - 代码最短，思路直观，适合初学优先队列的同学。  
> - 时间 488 ms，虽慢于 set，但胜在实现简单。  

### 题解三：YoungNeal —— “fhq-Treap 30ms”
> 手写无旋 Treap，插入时先 split 判重；删除最大值/最小值通过按大小 split 实现。  
> **亮点**：  
> - 展示如何在不支持 rank 查询的数据结构里“按排名删除”。  
> - 最慢点 30 ms，证明手写平衡树依然有价值。  

### 题解四：秋日私语 —— “权值线段树”
> 以价格为下标，线段树维护区间 min/max、两路 sum。  
> **亮点**：  
> - 权值线段树模板式写法，适合喜欢线段树的同学。  
> - 复杂度 O(m log C)，C=1e6 时约 20 次操作/询问，常数极小。  

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：STL-set）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 如何同时维护“有序”与“去重”** | set 天然排序且键唯一，重载 `<` 以价格为主键即可。 | STL-set = 红黑树，插入/删除/查询极值均 O(log n)。 |
| **2. 如何实时维护两路总和** | 额外变量 `sumW, sumC`，插入/删除时同步加减即可。 | 数据结构不擅长“区间求和”时，用全局变量最稳。 |
| **3. 删除极值时的迭代器陷阱** | set 的 `end()` 是“尾后迭代器”，需 `--s.end()` 才能取到最大值。 | 记住：`s.rbegin()` 也可直接取最大值，且无需 --。 |

### ✨ 解题技巧总结
- **技巧A：问题转化**  
  把“价格唯一”转成“set 的键唯一”，把“删除极值”转成“取 begin()/rbegin() 再 erase”。
- **技巧B：STL 优先队列的惰性删除**  
  当删除操作不频繁时，用“标记+惰性弹出”可极大简化代码。
- **技巧C：权值线段树的通用性**  
  当关键字是整数且范围可控（≤1e6）时，权值线段树常比平衡树更快。

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力数组+排序** | 每次插入后 sort | 思路直观 | O(m n log n) 爆炸 | 10-20 分 |
| **优先队列+惰性删除** | 大根堆+小根堆+vis数组 | 代码最短 | 均摊 O(log n)，常数大 | 100 分 |
| **STL-set** | 红黑树自动排序+去重 | 代码简洁、速度快 | 需理解迭代器 | 100 分 |
| **权值线段树** | 以价格为下标的线段树 | 理论 O(log C) 最优 | 代码较长 | 100 分 |
| **手写平衡树** | Treap/Splay/FHQ | 锻炼代码能力 | 易写错、调试耗时 | 100 分 |

### ✨ 优化之旅：从“能做”到“做好”
1. **起点：暴力排序**  
   每加一朵花就 sort → TLE，发现瓶颈在“重复排序”。
2. **第一次优化：set 红黑树**  
   利用 STL 自带排序，O(log n) 插入/删除，直接 AC。
3. **第二次优化：权值线段树**  
   当 C=1e6 时，线段树只需 20 次操作/询问，常数更小。
4. **终极优化：手写平衡树**  
   追求极限速度（20-30 ms），但需付出大量调试时间。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（STL-set版）

```cpp
#include <bits/stdc++.h>
using namespace std;
struct Flower {
    int w, c;
    bool operator<(const Flower& rhs) const { return c < rhs.c; }
};
set<Flower> s;
long long sumW = 0, sumC = 0;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int op;
    while (cin >> op, op != -1) {
        if (op == 1) {
            int w, c; cin >> w >> c;
            auto [it, inserted] = s.insert({w, c});
            if (inserted) sumW += w, sumC += c;
        } else if (op == 2 && !s.empty()) {          // 删最贵
            auto it = prev(s.end());
            sumW -= it->w, sumC -= it->c;
            s.erase(it);
        } else if (op == 3 && !s.empty()) {          // 删最便宜
            auto it = s.begin();
            sumW -= it->w, sumC -= it->c;
            s.erase(it);
        }
    }
    cout << sumW << ' ' << sumC;
    return 0;
}
```

- **代码解读概要**：  
  利用 set 自动排序，重载 `<` 以价格为键。全局变量实时维护两路总和，插入/删除时同步更新。复杂度 O(m log m)。

### 题解代码片段赏析

#### kikuss 的 set 片段
```cpp
set<node>v;
...
v.insert(tmp);
v.erase(--v.end());
```
- **亮点**：`--v.end()` 取最大迭代器，简洁高效。

#### Mychael 的优先队列片段
```cpp
priority_queue<int> qmax;
priority_queue<int,vector<int>,greater<int>> qmin;
while (!qmax.empty() && !v[qmax.top()]) qmax.pop();
```
- **亮点**：惰性删除思想，队列头若已失效则持续弹出。

#### YoungNeal 的 fhq-Treap 插入
```cpp
split2(Root,b,x,y);     // 按价格分裂
split2(x,b-1,x,z);      // 判重
if (sze[z] == 0) Root = merge(x, merge(newnode(a,b), y));
```
- **亮点**：两次分裂即可实现“存在则不插”。

---

## 5. 算法可视化：像素动画演示

### 动画主题  
**“像素花店”** —— 8 位像素风格的柜台，顾客不断插入/删除花朵，实时展示 set 的变化。

### 核心演示  
- 插入：像素花朵飞入柜台，按价格排序，重复花朵被弹回。  
- 删除极值：最贵/最便宜花朵高亮→消失→两路总和同步更新。  
- 音效：插入“叮”，删除“咻”，总和变化“金币声”。

### 技术实现要点
- **Canvas**：用 32×32 像素方块表示花朵，颜色=价格区间。  
- **set 可视化**：每帧遍历 set，绘制花朵队列；删除时高亮并淡出。  
- **交互**：单步/自动按钮，速度滑块 1-10 FPS。  
- **旁白**：左上角实时显示当前 set 大小、sumW、sumC。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
1. **实时排行榜**：用 set 维护分数，支持插入、删除最高/最低分。  
2. **任务调度**：优先队列 + 惰性删除，处理“最早截止”或“最大收益”任务。  
3. **库存管理**：权值线段树维护商品库存，支持按价格区间统计。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P3378 【模板】堆 | 优先队列裸题，巩固惰性删除思想。 |
| P3369 【模板】普通平衡树 | 手写平衡树必刷，掌握 split/merge。 |
| P1908 逆序对 | 权值线段树/树状数组经典，体会“值域”思想。 |

---

## 7. 学习心得与经验分享

> 来自 **斯德哥尔摩** 的 4 天调试血泪史：  
> “第一天 RE 0，第二天 WA 60，第三天 WA 40，第四天 AC 100。  
> 关键坑：操作 2、3 顺序千万别反！空花束时跳过删除！”  
> **点评**：典型“细节决定成败”，提醒我们：  
> - 先写暴力对拍，再逐步优化；  
> - 每步操作后打印关键变量，快速定位 bug。

---

<conclusion>
至此，“送花”一题的多维剖析完毕。  
从 STL-set 的优雅，到优先队列的实用，再到平衡树的深邃，  
我们见证了同一问题的多彩解法。  
记住：先选“能 AC 的最短路径”，再追求“极致效率”。  
愿你在下一次花店（赛场）里，从容地挑出最美、最贵、最便宜的那一朵！💐
</conclusion>

---
处理用时：82.38秒
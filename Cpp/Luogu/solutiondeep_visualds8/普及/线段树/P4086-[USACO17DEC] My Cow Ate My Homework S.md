# 题目信息

# [USACO17DEC] My Cow Ate My Homework S

## 题目描述

在你的牛历史课上，你被布置了一份相当长的作业，包含 $N$ 个问题（$3 \leq N \leq 100,000$），每个问题的得分是一个在 0 到 10,000 之间的整数。按照惯例，你的老师计划通过去掉你得分最低的一个问题，然后对剩余问题的得分取平均来给出最终成绩。不幸的是，你的宠物奶牛 Bessie 刚刚吃掉了你前 $K$ 个问题的答案！（$K$ 可能小到 1，也可能大到 $N-2$）。

经过多次解释，你的老师终于相信了你的说法，并同意按照之前的方式对剩余的未被吃掉的部分作业进行评分——即去掉得分最低的问题（或在得分相同的情况下去掉其中一个），然后对剩余问题取平均。

请输出所有能够使你获得最高可能成绩的 $K$ 值，并按升序排列。

## 说明/提示

如果 Bessie 吃掉了前两个问题，那么剩余的得分是 9、2 和 7。去掉最低分并取平均后，最终成绩为 8，这是可能的最高成绩。

## 样例 #1

### 输入

```
5
3 1 9 2 7```

### 输出

```
2```

# AI分析结果

```markdown
---
# 💡 洛语云笺的C++算法解析：My Cow Ate My Homework S 深入学习指南 💡

> 欢迎来到今天的算法探险！我们要帮助 Bessie 的主人找到“被吃掉作业”后能获得**最高平均分**的所有 K 值。看似简单的“求平均”背后，隐藏着对**区间最值**与**前缀和**的巧妙运用。让我们像侦探一样拆解线索，一步步走向最优解！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在“吃掉前 K 题”后，剩余区间 `[K+1, n]` 内要去掉一个最小值，再求平均。我们需要在 **O(N)** 时间内枚举所有 K（1 ≤ K ≤ N-2），并快速得到区间和与最小值。

✨ **核心算法标签**：前缀和 / 后缀最值 / 枚举优化 / 线段树（可选）

🗣️ **初步分析**：  
- 最朴素的想法：两重循环枚举 K 和区间，复杂度 **O(N²)**，在 N=1e5 时直接爆炸。  
- 关键洞察：区间 `[K+1, n]` 的 **和** 与 **最小值** 可以 **O(1)** 或 **O(logN)** 查询！  
- 最优策略：  
  1. 用 **前缀和** 或 **后缀和** 预处理区间和；  
  2. 用 **后缀最小值数组** 预处理区间最小值；  
  3. 倒序枚举 K（或正序），O(1) 计算当前平均分；  
  4. 记录所有使平均分最大的 K 值并升序输出。

> 比喻：就像提前把“作业得分”制成一张“速查表”，每次只需查表即可瞬间得到区间和与最小值，而不必重新遍历。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：问题目标** | “求最高平均分” → 最优化问题，可枚举所有可能 K。 |
| **线索2：区间需求** | 每次需要 `[K+1, n]` 的 **sum** 与 **min** → 想到 **前缀和 + 后缀最值**。 |
| **线索3：数据规模** | N=1e5 → 只能接受 **O(N logN) 或 O(N)** 解法，直接排除暴力 O(N²)。 |

---

### 🧠 思维链构建：从线索到策略

> 1. **枚举 K** 是逃不掉的，但区间 `[K+1, n]` 的 **sum & min** 可以 **预处理**！  
> 2. **前缀和** 让区间和 O(1) 查；**后缀最小值数组** 让区间最小值 O(1) 查。  
> 3. 于是总复杂度降为 **O(N)**，完美通过 1e5！  
> 4. 若不想写后缀最值？用 **线段树** 也能 O(N logN) 解决，只是稍慢。

---

## 2. 精选优质题解参考

> 以下题解均 ≥4 星，重点看“如何 O(1) 拿到区间信息”与“如何优雅枚举”。

### 🌟 题解一：_jimmywang_（赞28）
- **亮点**：仅用 **1 行循环** 同时倒序维护 **后缀最小值** 与 **后缀和**，代码极简。  
- **核心思路**：
  ```cpp
  for (int i = n; i >= 2; --i) {
      mn[i] = min(mn[i+1], a[i]);
      sum[i] = sum[i+1] + a[i];
  }
  ```
- **学习笔记**：把 **两个预处理** 合并在一次倒序扫描中，既省空间又省时间。

### 🌟 题解二：Siyuan（赞17）
- **亮点**：**正序枚举** + 变量滚动更新 `sum` 与 `min`，避免额外数组。  
- **核心片段**：
  ```cpp
  mins = s[n]; sum = s[n];
  for (int i = n-1; i >= 2; --i) {
      mins = min(mins, s[i]);
      sum += s[i];
      double cur = (sum - mins) * 1.0 / (n - i);
      ...
  }
  ```
- **学习笔记**：利用 **变量复用** 减少内存，适合内存紧张场景。

### 🌟 题解三：Diamiko（赞7）
- **亮点**：**线段树** 模板化维护区间最小值，思路清晰，方便扩展带修改版本。  
- **学习笔记**：当题目增加“动态修改得分”时，线段树是首选。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解：后缀最值 + 前缀和）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 预处理区间信息** | 倒序扫描一次数组，维护 `mn[i] = min(a[i..n])` 与 `sum[i] = Σa[i..n]`。 | 倒序 = 天然后缀，O(N) 完成。 |
| **2. 枚举 K 并计算平均分** | K 有效范围 1..N-2，对应区间 [K+1, n] 有 `n-K-1` 个元素。 | 用预处理数组 O(1) 计算 `(sum[K+1] - mn[K+1]) / (n-K-1)`。 |
| **3. 精度与比较** | 用 `double` 存储，比较时引入 **eps=1e-9** 避免浮点误差。 | 浮点相等写成 `fabs(a-b) < eps`。 |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 适用场景 | 备注 |
|---|---|---|---|---|
| **后缀最值 + 前缀和** | 倒序一次扫描 | **O(N)** | 最优解，推荐 | 代码最短 |
| **线段树** | 区间查询 min & sum | **O(N logN)** | 可扩展动态修改 | 模板化 |
| **分块** | 每块维护 min & sum | **O(N√N)** | 模板练习 | 常数较大 |
| **multiset** | 动态维护区间元素 | **O(N logN)** | STL 练习 | 常数略高 |

---

## 4. C++核心代码实现赏析

### 📌 本题通用核心C++实现参考（后缀最值 + 前缀和版）

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 10;
int n, a[MAXN];
double sum[MAXN], mn[MAXN], mx = -1e9;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i];

    // 1. 倒序预处理：后缀最小值 & 后缀和
    mn[n + 1] = 1e9;
    for (int i = n; i >= 2; --i) {
        mn[i] = min(mn[i + 1], 1.0 * a[i]);
        sum[i] = sum[i + 1] + a[i];
    }

    // 2. 枚举 K 并记录最大值
    vector<int> ans;
    for (int k = 1; k <= n - 2; ++k) {
        double avg = (sum[k + 1] - mn[k + 1]) / (n - k - 1);
        if (avg - mx > 1e-9) {
            mx = avg;
            ans.clear();
            ans.push_back(k);
        } else if (fabs(avg - mx) < 1e-9) {
            ans.push_back(k);
        }
    }

    // 3. 升序输出
    for (int v : ans) cout << v << '\n';
    return 0;
}
```

- **代码解读概要**：  
  - 预处理：一次倒序扫描同时完成 **后缀最小值** 与 **后缀和**。  
  - 枚举：K 从 1 到 N-2，利用预处理结果 O(1) 计算平均分。  
  - 精度：使用 `1e-9` 控制浮点比较。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素牧场”** —— 用 8 位像素风展示如何倒序扫描数组，实时更新 **后缀最小值条** 与 **后缀和条**。

### 🎮 动画设计要点
1. **场景**：横向 1×N 像素条，每个像素块高度代表分数。  
2. **指针**：红色像素箭头从右向左移动。  
3. **数据高亮**：
   - 当前块 → 黄色闪烁；  
   - 已扫描区域 → 蓝色条表示当前最小值；  
   - 绿色数字实时显示 `sum[i]` & `mn[i]`。  
4. **音效**：
   - 每移动一格 → 8 位“滴”声；  
   - 更新最小值 → 上扬“叮”；  
   - 找到最优 K → 胜利“哒哒哒”。  
5. **交互**：  
   - 步进 / 自动播放 / 调速滑块；  
   - 点击任意像素块查看对应 `sum & min`。

---

## 6. 拓展练习与相似问题思考

- **通用思路迁移**：  
  - 区间和 + 区间最值 的组合思想，适用于：  
    1. **滑动窗口最小值/和**（LeetCode 239/209）。  
    2. **动态区间统计**（如区间众数、区间中位数）。  
    3. **离线区间查询**（如离线 RMQ 问题）。

- **洛谷推荐**：  
  1. **P1440** 求 m 区间最小值 → 练习单调队列。  
  2. **P3372** 线段树模板 → 巩固区间查询。  
  3. **P1908** 逆序对 → 体验分块思想。

---

## 7. 学习心得与经验分享（精选）

- **_jimmywang_**：  
  > “把两个预处理合并到一次倒序扫描，是减少常数的利器。”  
  👉 合并扫描 = 代码更短 + Cache 更友好。

- **Siyuan**：  
  > “注意精度！比较浮点用 eps，不然 WA 到怀疑人生。”  
  👉 浮点相等永远写 `fabs(a-b) < eps`。

---

> 🎉 恭喜你完成本次探险！掌握 **后缀最值 + 前缀和** 后，你已拥有解决大量区间问题的钥匙。继续加油，下一场算法之旅见！

---
处理用时：62.62秒
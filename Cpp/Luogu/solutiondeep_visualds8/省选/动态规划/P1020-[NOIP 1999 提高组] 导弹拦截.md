# 题目信息

# [NOIP 1999 提高组] 导弹拦截

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。


## 说明/提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。

## 样例 #1

### 输入

```
389 207 155 300 299 170 158 65```

### 输出

```
6
2
```

# AI分析结果


# 💡 洛语云笺的C++算法解析：导弹拦截 深入学习指南 💡

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
这道题的核心挑战在于处理导弹高度序列的双重需求：(1) 单系统拦截时导弹高度的**非递增特性**（第一问）；(2) 多系统协作时**最小化系统数量**的优化问题（第二问）。

✨ **核心算法标签**：  
`动态规划` `贪心算法` `二分查找` `Dilworth定理`

🗣️ **初步分析**：  
> 导弹拦截问题需要解决两个看似独立实则紧密相关的子问题。第一问要求找到最长非递增子序列（拦截系统单次拦截的最大导弹数），第二问则要求计算覆盖所有导弹所需的最小系统数。  
>  
> 对于第一问，最直观的暴力解法是枚举所有子序列（O(2^n)），但数据规模(n≤10^5)要求更高效的O(n log n)算法。我们发现可以通过**贪心+二分**维护一个表示潜在拦截序列的数组来优化。  
>  
> 第二问的精妙之处在于**Dilworth定理**的应用——最少系统数等于最长上升子序列长度。这让我们将问题转化为另一个经典模型，同样可用贪心+二分高效解决。

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**: "求单系统最多拦截导弹数"是典型的**最优化问题**，且带有"高度不高于前一发"的约束，指向**动态规划或贪心优化**。
2.  **线索2 (问题特性)**: "依赖关系"体现在导弹必须按序拦截，且系统间独立运作。这种**序列划分依赖**暗示可能需要**Dilworth定理**将问题转化为对偶模型。
3.  **线索3 (数据规模)**: n最大10^5，要求O(n log n)算法。这排除了O(n^2)暴力DP，指向**二分查找优化**的贪心策略。

### 🧠 思维链构建：从线索到策略
> "综合三条线索：  
> 1. 最优化问题首先考虑DP/贪心；  
> 2. 依赖关系和序列划分提示Dilworth定理；  
> 3. 数据规模要求O(n log n)解法。  
>  
> **结论**：  
> - 第一问用**贪心+二分维护非递增序列**  
> - 第二问通过**Dilworth定理转化为最长上升子序列**  
> 两者均可通过相似结构在O(n log n)内解决！"

---

## 2. 精选优质题解参考

**题解一（离散小波变换°）**  
* **点评**：该题解清晰推导了贪心+二分的数学原理，通过图示展示`f[]`数组的单调性证明。亮点在于将Dilworth定理与算法实现无缝衔接，代码中`upper_bound`配合`greater<int>()`的用法精准，变量命名规范（`f[]`表示长度i的序列尾元素最大值），实践价值高。

**题解二（Tofu）**  
* **点评**：提供独特的贪心模拟视角，不依赖Dilworth定理直接求解第二问。亮点在于用"系统末尾高度"的升序数组模拟拦截系统，通过数学归纳法证明贪心正确性。代码中`lower_bound`查找最小可用系统的逻辑极具启发性。

**题解三（STA_Morlin）**  
* **点评**：系统对比暴力DP与优化方案的差异，通过"替换决策"解释贪心策略的优化本质。亮点在于从偏序集角度阐述Dilworth定理，代码中双数组`dp1[]`/`dp2[]`分离两问，边界处理严谨（`x[1]=0x7fffffff`）。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1.  **关键点1：贪心数组的单调性证明**  
    * **分析**：以第一问为例，设`f[i]`为长度i的非递增子序列的最小末尾。若存在`f[i]<f[i+1]`，则与"长度i+1序列包含长度i子序列"矛盾，故`f[]`单调非减。
    * 💡 **学习笔记**：贪心维护的数组单调性是二分优化的基础。

2.  **关键点2：二分查找的类型选择**  
    * **分析**：
      - 第一问用`upper_bound(..., greater<int>())`找第一个≤当前高度的位置
      - 第二问用`lower_bound`找第一个≥当前高度的位置
    * 💡 **学习笔记**：`upper_bound`用于非严格序列（允许相等），`lower_bound`用于严格序列。

3.  **关键点3：Dilworth定理的实践转化**  
    * **分析**：定理证明"最小链划分=最长反链长度"，在本题中：
      - 链：非递增子序列（单系统拦截序列）
      - 反链：严格上升子序列
    * 💡 **学习笔记**：复杂问题转化为经典模型是算法设计的核心技巧。

### ✨ 解题技巧总结
- **技巧1：问题转化艺术**  
  将最少系统数问题转化为最长上升子序列（Dilworth定理）
  
- **技巧2：状态存储优化**  
  用单个数组代替DP表，`f[i]`表示长度i的子序列尾元素极值

- **技巧3：STL高效利用**  
  `lower_bound`/`upper_bound`实现O(log n)查找，避免手写二分

### ⚔️ 策略竞技场：不同解法的对比分析
| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|------|----------|------|------|----------|
| **暴力DP** | 双重循环遍历所有状态 | 逻辑直观 | O(n²)超时 | 30% (n≤1000) |
| **树状数组优化** | 值域离散化+树状数组维护 | 稳定O(n log n) | 代码复杂 | 100% |
| **贪心+二分（主流）** | 维护单调数组+二分查找 | 代码简洁高效 | 需理解贪心正确性 | 100% |
| **Dilworth直接应用** | 第二问转最长上升子序列 | 免去额外推导 | 依赖定理理解 | 100% |

### ✨ 优化之旅：从"能做"到"做好"
> 1. **起点：暴力DP**  
>    O(n²)方案枚举所有子序列，n=10⁵时计算超时  
>   
> 2. **发现瓶颈：重复决策**  
>   计算`dp[i]`时重复比较`dp[1]~dp[i-1]`  
>   
> 3. **优化钥匙：单调性挖掘**  
>   发现子序列尾元素`f[]`的单调性，二分查找代替遍历  
>   
> 4. **模型升华：Dilworth转化**  
>   通过定理将两问统一为相似结构  
>   
> 💡 **策略总结**："好的算法=深刻的问题洞察+合适的模型转化+高效的数据结构"

---

## 4. C++核心代码实现赏析

**通用核心实现**  
```cpp
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main() {
    vector<int> missiles, f, g;
    // 读入数据
    for(int x; cin >> x;) missiles.push_back(x);

    // 第一问: 最长非递增子序列
    for(int h : missiles) {
        if(f.empty() || h <= f.back()) f.push_back(h);
        else *upper_bound(f.begin(), f.end(), h, greater<int>()) = h;
    }
    
    // 第二问: 最长上升子序列
    for(int h : missiles) {
        auto it = lower_bound(g.begin(), g.end(), h);
        if(it == g.end()) g.push_back(h);
        else *it = h;
    }
    
    cout << f.size() << "\n" << g.size();
}
```

**题解一代码亮点**  
```cpp
// 使用lambda表达式避免全局变量
*upper_bound(f+1, f+len+1, a[i], [](int a, int b){
    return a > b; // 自定义比较器
}) = a[i];
```
**学习笔记**：现代C++的lambda表达式提升可读性，避免全局比较函数。

**题解二贪心模拟亮点**  
```cpp
vector<int> sys; // 系统末尾高度
for(int h : missiles) {
    auto it = lower_bound(sys.begin(), sys.end(), h);
    if(it == sys.end()) sys.push_back(h); // 新系统
    else *it = h; // 更新现有系统
}
```
**学习笔记**：不依赖Dilworth定理的直观实现，sys数组天然保持有序。

---

## 5. 算法可视化：像素动画演示

**8位像素风格设计**：  
![导弹拦截像素演示](https://cdn.luogu.com.cn/upload/image_hosting/9zg9k9lx.gif)  
*(图示：FC红白机风格界面，导弹从右向左飞行)*

**动画流程**：  
1. **场景初始化**：  
   - 顶部导弹序列：像素方块显示高度值(389/207/...)  
   - 底部拦截系统：初始1个系统，高度条为绿色  

2. **第一问演示**：  
   - **导弹207**：比389小，加入同一系统，高度条变黄  
   - **导弹300**：比207大，触发二分查找：  
     - 高亮`f[]`数组[389,207]  
     - 定位207替换为300，播放"滴"音效  

3. **第二问演示**：  
   - **导弹300**：比当前所有系统高度大，新建系统(高度300)  
   - **导弹155**：二分查找定位系统1(300>155)，更新高度  

**交互控制**：  
- 控制面板：步进/暂停/速度滑块  
- 数据板：实时显示`f[]`/`g[]`数组状态  
- 音效：关键操作配8位音效(选择/替换/新建系统)

---

## 6. 拓展练习与相似问题

**通用技巧迁移**：  
- 贪心+二分维护单调数组可用于：最长递增子序列、最大整除子集  
- Dilworth定理扩展：偏序集问题（任务调度、区间覆盖）  

**洛谷推荐**：  
1. [P1091 合唱队形](https://www.luogu.com.cn/problem/P1091)  
   **推荐理由**：双向LIS应用，巩固第一问技巧  

2. [P2782 友好城市](https://www.luogu.com.cn/problem/P2782)  
   **推荐理由**：二维偏序问题，练习Dilworth建模  

3. [P1280 尼克的任务](https://www.luogu.com.cn/problem/P1280)  
   **推荐理由**：状态机DP+贪心选择，提升问题转化能力  

---

## 7. 学习心得与经验分享

> **来自题解作者的启示**：  
> - "替换`f[]`中元素时，即使序列内容改变，长度不变仍保证正确性" —— 离散小波变换°  
> - "贪心选择最小可用系统，避免浪费大高度系统" —— Tofu  

> **洛语云笺总结**：  
> 调试时注意边界：  
> 1. 空数组时直接push_back  
> 2. 二分查找失败时新建系统/序列  
> 3. 严格上升用`lower_bound`，非严格下降用`upper_bound+greater`  

---

> 本次探索告诉我们：算法之美在于将复杂问题转化为优雅模型。掌握Dilworth定理和贪心二分，导弹拦截便是你征服更难题目的起点！ 🚀

---
处理用时：184.48秒
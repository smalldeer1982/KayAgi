# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果


### 题目分析
本题要求计算字符串中所有子串的优秀拆分（AABB形式）的总数。核心思路是将问题转化为计算以每个位置结尾的AA串数量（f数组）和以每个位置开头的AA串数量（g数组），然后通过公式 \(\sum_{i=1}^{n-1} f[i] \times g[i+1]\) 得到答案。

#### 核心算法
1. **后缀数组（SA）与最长公共前缀（LCP）**：
   - 构建原串和反串的后缀数组，用于高效计算任意两个子串的LCP。
   - 反串的LCP等价于原串的最长公共后缀（LCS）。

2. **调和级数枚举**：
   - 枚举AA串中A的长度 \(len\)（从1到 \(\lfloor n/2 \rfloor\)）。
   - 设置关键点：位置为 \(len, 2len, 3len, \ldots\)。
   - 对相邻关键点 \(i\) 和 \(j = i + len\)：
     - 计算LCP（原串中 \(i\) 和 \(j\) 开始的后缀）。
     - 计算LCS（反串中对应位置，等价于原串中 \(i-1\) 和 \(j-1\) 结尾的前缀的公共后缀）。
     - 若 \(LCP + LCS \geq len\)，则存在跨关键点的AA串，数量为 \(t = LCP + LCS - len + 1\)。
     - 更新差分数组：
       - 开头位置：区间 \([i - y, i - y + t - 1]\)（\(y = \min(LCS, len-1)\)）。
       - 结尾位置：区间 \([j + x - t, j + x - 1]\)（\(x = \min(LCP, len)\)）。

3. **差分数组处理**：
   - 对差分数组求前缀和，得到f和g数组。
   - 计算答案：\(\sum_{i=1}^{n-1} f[i] \times g[i+1]\)。

#### 复杂度分析
- 后缀数组构建：\(O(n \log n)\)。
- 枚举长度 \(len\)：调和级数 \(O(n \log n)\)。
- 总复杂度：\(O(n \log n)\)。

### 代码实现
```cpp
#include <iostream>
#include <cstring>
#include <cmath>
#include <algorithm>
using namespace std;
typedef long long ll;

const int MAXN = 30005;
const int LOG_MAXN = 16;

struct SuffixArray {
    char s[MAXN];
    int n, sa[MAXN], rk[MAXN], ht[MAXN], st[MAXN][LOG_MAXN], lg[MAXN];

    void clear() {
        memset(s, 0, sizeof(s));
        memset(sa, 0, sizeof(sa));
        memset(rk, 0, sizeof(rk));
        memset(ht, 0, sizeof(ht));
        memset(st, 0, sizeof(st));
    }

    void build() {
        int m = 128; // ASCII范围
        static int x[MAXN], y[MAXN], c[MAXN];
        memset(c, 0, sizeof(c));
        for (int i = 1; i <= n; i++) c[x[i] = s[i]]++;
        for (int i = 1; i <= m; i++) c[i] += c[i-1];
        for (int i = n; i >= 1; i--) sa[c[x[i]]--] = i;

        for (int k = 1; k <= n; k <<= 1) {
            int num = 0;
            for (int i = n - k + 1; i <= n; i++) y[++num] = i;
            for (int i = 1; i <= n; i++) if (sa[i] > k) y[++num] = sa[i] - k;

            memset(c, 0, sizeof(c));
            for (int i = 1; i <= n; i++) c[x[i]]++;
            for (int i = 1; i <= m; i++) c[i] += c[i-1];
            for (int i = n; i >= 1; i--) sa[c[x[y[i]]]--] = y[i];

            swap(x, y);
            x[sa[1]] = num = 1;
            for (int i = 2; i <= n; i++)
                x[sa[i]] = (y[sa[i]] == y[sa[i-1]] && y[sa[i]+k] == y[sa[i-1]+k]) ? num : ++num;
            if (num == n) break;
            m = num;
        }

        for (int i = 1; i <= n; i++) rk[sa[i]] = i;
        int k = 0;
        for (int i = 1; i <= n; i++) {
            if (rk[i] == 1) { k = 0; continue; }
            if (k) k--;
            int j = sa[rk[i]-1];
            while (i + k <= n && j + k <= n && s[i+k] == s[j+k]) k++;
            ht[rk[i]] = k;
        }

        for (int i = 2; i <= n; i++) lg[i] = lg[i>>1] + 1;
        for (int i = 1; i <= n; i++) st[i][0] = ht[i];
        for (int j = 1; j <= lg[n]; j++)
            for (int i = 1; i + (1<<j) - 1 <= n; i++)
                st[i][j] = min(st[i][j-1], st[i+(1<<(j-1))][j-1]);
    }

    int lcp(int i, int j) {
        if (i == j) return n - i + 1;
        i = rk[i]; j = rk[j];
        if (i > j) swap(i, j);
        i++;
        int k = lg[j - i + 1];
        return min(st[i][k], st[j - (1<<k) + 1][k]);
    }
} A, B; // A: 原串, B: 反串

int n;
ll da[MAXN], db[MAXN]; // 差分数组: da用于f(结尾), db用于g(开头)
ll f[MAXN], g[MAXN];   // f[i]:以i结尾的AA数, g[i]:以i开头的AA数

void solve() {
    memset(da, 0, sizeof(da));
    memset(db, 0, sizeof(db));
    memset(f, 0, sizeof(f));
    memset(g, 0, sizeof(g));

    // 枚举A的长度len
    for (int len = 1; len <= n/2; len++) {
        for (int i = len, j = i + len; j <= n; i += len, j += len) {
            int LCP = A.lcp(i, j);
            int LCS = (i == 1) ? 0 : B.lcp(n - (i - 1) + 1, n - (j - 1) + 1);
            LCP = min(LCP, len);
            LCS = min(LCS, len - 1);

            if (LCP + LCS < len) continue;
            int t = LCP + LCS - len + 1;

            // 更新开头位置: [i - LCS, i - LCS + t - 1]
            db[i - LCS]++;
            db[i - LCS + t]--;

            // 更新结尾位置: [j + LCP - t, j + LCP - 1]
            da[j + LCP - t]++;
            da[j + LCP]--;
        }
    }

    // 前缀和求f,g
    for (int i = 1; i <= n; i++) {
        f[i] = f[i-1] + da[i];
        g[i] = g[i-1] + db[i];
    }

    // 计算答案
    ll ans = 0;
    for (int i = 1; i < n; i++)
        ans += f[i] * g[i+1];
    cout << ans << endl;
}

int main() {
    int T;
    cin >> T;
    while (T--) {
        string str;
        cin >> str;
        n = str.size();
        
        // 初始化原串SA
        A.clear();
        for (int i = 1; i <= n; i++) A.s[i] = str[i-1];
        A.n = n;
        A.build();

        // 初始化反串SA
        B.clear();
        for (int i = 1; i <= n; i++) B.s[i] = str[n - i];
        B.n = n;
        B.build();

        solve();
    }
    return 0;
}
```

### 算法可视化
#### 关键步骤图解
1. **枚举长度与关键点**：
   - 枚举A的长度 \(len\)，在字符串中每隔 \(len\) 设置关键点（红点）。
   - 相邻关键点 \(i\) 和 \(j = i + len\)。

2. **LCP与LCS计算**：
   - 计算 \(i\) 和 \(j\) 开始的后缀的LCP（绿色区域）。
   - 计算 \(i-1\) 和 \(j-1\) 结尾的前缀的LCS（蓝色区域）。
   - 若 \(LCP + LCS \geq len\)，则存在AA串。

3. **更新差分数组**：
   - 开头位置：区间 \([i - \text{LCS}, i - \text{LCS} + t - 1]\)（黄色高亮）。
   - 结尾位置：区间 \([j + \text{LCP} - t, j + \text{LCP} - 1]\)（紫色高亮）。

#### 动画演示
- **8位像素风格**：网格表示字符串，关键点用红色像素标记。
- **关键操作**：
  1. 移动滑块选择 \(len\)，显示关键点。
  2. 对每个关键点对，显示LCP（绿色）和LCS（蓝色）。
  3. 满足条件时，黄色和紫色区域闪烁，表示更新差分。
  4. 显示差分数组前缀和过程，得到f和g数组。
  5. 计算并显示最终答案。
- **音效**：关键操作时播放像素音效，成功时播放胜利音效。

### 拓展练习
1. **相似题目**：
   - **洛谷 P1117**：本题的直接应用。
   - **SPOJ LCS**：最长公共子串，巩固后缀数组。
   - **CodeForces 319D**：类似子串处理技巧。

2. **推荐练习**：
   - **洛谷 P3804**：后缀数组模板题。
   - **洛谷 P3763**：复杂子串统计，提升问题转化能力。
   - **LOJ 2083**：NOI原题，深入理解本题解法。

通过本题，我们学习了利用后缀数组和调和级数枚举高效统计特殊子串的方法，以及差分数组优化区间更新的技巧。

---
处理用时：315.26秒
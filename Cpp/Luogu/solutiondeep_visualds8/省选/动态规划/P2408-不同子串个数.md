# 题目信息

# 不同子串个数

## 题目背景

因为 NOI 被虐傻了，蒟蒻的 YJQ 准备来学习一下字符串，于是它碰到了这样一道题：


## 题目描述

给你一个长为 $n$ 的字符串，求不同的子串的个数。

我们定义两个子串不同，当且仅当有这两个子串长度不一样或者长度一样且有任意一位不一样。

子串的定义：原字符串中连续的一段字符组成的字符串。


## 说明/提示

### 提示

请使用64位整数来进行输出。

### 数据规模与约定
- 对于 $30\%$ 的数据，保证 $n\le 1000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，字符串中只有小写英文字母。


## 样例 #1

### 输入

```
5
aabaa```

### 输出

```
11```

## 样例 #2

### 输入

```
3
aba```

### 输出

```
5```

# AI分析结果


# 💡 洛语云笺的C++算法解析：不同子串个数 深入学习指南 💡

## 1. 题目解读与策略初探

✨ **本题核心挑战**：如何在O(n)或O(n log n)时间内高效统计一个长度为10^5的字符串中所有**本质不同的子串**数量。  
✨ **核心算法标签**：`后缀数组(SA)`, `后缀自动机(SAM)`, `字符串处理`

🗣️ **初步分析**：  
> 解决本题的关键在于避免暴力枚举子串（O(n²)超时），转而利用字符串算法的特殊性质。主要有两条高效路径：  
> 1. **后缀数组(SA)**：通过后缀排序和height数组，用总子串数减去重复前缀数（公式：`n(n+1)/2 - Σheight[i]`）  
> 2. **后缀自动机(SAM)**：利用自动机状态天然去重的特性，通过动态规划或状态长度差直接统计（公式：`Σ(len[u]-len[link[u]])`）  
> 
> 两种方法都涉及**问题转化**的思维跃迁：将子串统计转化为后缀前缀处理（SA）或自动机路径统计（SAM）。最优策略选择取决于对两种算法的掌握程度——SA代码量稍大但思路直观，SAM效率更高但实现精巧。

### 🔍 算法侦探：如何在题目中发现线索？
1.  **线索1 (问题目标)**：题目要求统计"不同子串"，属于字符串经典问题，暗示需要高效字符串算法（SA/SAM）。
2.  **线索2 (问题约束)**：数据规模n=10^5，直接排除O(n²)暴力解法，指向O(n)或O(n log n)的SA/SAM解法。
3.  **线索3 (算法信号)**："不同子串"是SA的经典应用场景（通过height数组去重），也是SAM的基础应用（自动机路径即子串）。

### 🧠 思维链构建：从线索到策略
> "当我们看到'统计不同子串'和'n≤10⁵'时，立刻意识到：  
> 1. **线索1**引导我们回忆字符串算法中专门处理子串问题的工具——SA和SAM。  
> 2. **线索2**的数据规模直接否决了暴力哈希（O(n²)空间时间都不允许）。  
> 3. **线索3**让我们比较两种方案：SA虽然需要O(n log n)排序，但公式简洁；SAM构建O(n)更优，但需要理解自动机状态转移。  
> 4. **结论**：两种算法都能满分通过，选择取决于个人熟练度。SA更适合作思维训练，SAM更体现算法效率之美。"

---

## 2. 精选优质题解参考

### 题解一：Leap_Frog (SA+SAM双解法)
* **点评**：  
  此解最大亮点是**双解法对比**，同时展示SA和SAM的核心思想。SA部分用height数组去重的推导清晰（`总子串数 - 重复数`），代码中基数排序实现规范；SAM部分用树形DP统计路径数，巧妙利用自动机性质。虽然代码压行稍显紧凑，但关键步骤注释到位，尤其SAM的`dfs`递归实现体现了"自动机路径即子串"的直观理解。

### 题解二：Rorschachindark (SAM动态维护)
* **点评**：  
  提供**SAM的最优实现范式**——动态维护答案而非最后DP。核心洞察：SAM每新增一个状态，其贡献的子串数就是`len[u]-len[link[u]]`。代码在构建SAM时直接累加`ans`，避免后序遍历，效率提升一倍。变量命名规范（`len/fa`），且单文件实现完整，是竞赛中效率与简洁兼备的典范。

### 题解三：Oracle (SA去重公式)
* **点评**：  
  最清晰的**SA公式推导**："每个后缀`sa[i]`贡献`n-sa[i]+1-height[i]`"等价于总公式。代码亮点在于：  
  1. 独立`get_sa`和`get_height`函数模块化  
  2. 用`rk`数组加速height计算  
  3. 严格处理边界条件  
  解释中强调开`long long`的细节，体现实战经验。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1.  **难点1：如何避免重复统计子串**
    * **SA方案**：利用height数组记录相邻后缀的最长公共前缀（LCP），重复子串数即为Σheight[i]
    * **SAM方案**：自动机本身保证不同路径对应不同子串，通过状态转移去重
    * 💡 **学习笔记**：去重本质都是利用字符串的**前缀重合特性**

2.  **难点2：高效实现SA/SAM**
    * **SA**：双关键字基数排序实现倍增算法，注意桶排序优化
    * **SAM**：处理三种转移情况（直接转移/拆分节点/新建节点）
    * 💡 **学习笔记**：SA的`y[]`数组优化第二关键字排序，SAM的`link`指针维护后缀链接是关键

3.  **难点3：状态转移方程/统计公式**
    * **SA公式**：$ans = \frac{n(n+1)}{2} - \sum height[i]$  
    * **SAM公式**：$ans = \sum (len[u] - len[link[u]])$  
    * 💡 **学习笔记**：SA公式体现**容斥思想**，SAM公式基于**状态最小表示法**

### ✨ 解题技巧总结
- **问题转化**：子串统计→后缀前缀(SA)或自动机路径(SAM)
- **离线处理**：SA的height数组/SAM的link指针都依赖前序状态
- **增量优化**：SAM动态维护答案避免二次遍历
- **边界防御**：SA的基数排序注意空桶处理，SAM注意初始状态

### ⚔️ 策略竞技场：不同解法的对比分析
| 策略             | 核心思想                     | 优点                          | 缺点                          | 得分预期         |
|------------------|------------------------------|-------------------------------|-------------------------------|------------------|
| **暴力+哈希**    | 枚举所有子串用哈希表去重     | 思路简单                      | O(n²)时间/空间超时            | 0分（n>5000）   |
| **后缀数组(SA)** | 总子串数减去height数组总和   | 公式直观，扩展性强            | 基数排序实现复杂              | 100%            |
| **后缀自动机(SAM)** | 累加状态长度差 或 DAG路径数 | 时间复杂度O(n)最优            | 理解状态转移需要前置知识      | 100%            |
| **哈希+LCP**     | 二分哈希比较后缀后统计LCP    | 避免SA复杂排序                | O(n log²n)可能超时            | 90%（常数风险） |

### ✨ 优化之旅：从"能做"到"做好"
> 1. **起点：暴力枚举的困境**  
>    枚举起点终点需O(n²)，10^5数据需要10^10次操作——现代计算机需数分钟（TLE）
> 
> 2. **发现瓶颈：重复子串的共性**  
>    "ababc"中'ab'出现两次，其重复本质是**前缀重叠**，需高效计算重复量
> 
> 3. **SA的钥匙：height数组**  
>    通过后缀排序，相邻后缀的LCP就是重复前缀数。用基数排序将比较优化到O(n log n)
> 
> 4. **SAM的升华：自动机状态转移**  
>    更彻底的转化——每个自动机状态对应一组后缀相同的子串，直接累加`len[u]-len[link[u]]`即避免重复
> 
> 💡 **策略总结**："从暴力到SA/SAM，我们经历了**问题特征抽象**和**数据结构升华**。竞赛中即使不熟悉SAM，实现SA也能满分；但掌握SAM的选手会收获更优的时空效率。这启示我们：深度理解问题结构+熟练经典模型=高效解题双翼"

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（SA法）
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 1e5 + 10;
typedef long long ll;

char s[N];
int n, sa[N], rk[N], height[N], cnt[N], x[N], y[N];

void get_sa() {
    int m = 256;
    for (int i = 1; i <= n; i++) cnt[x[i] = s[i]]++;
    for (int i = 2; i <= m; i++) cnt[i] += cnt[i-1];
    for (int i = n; i; i--) sa[cnt[x[i]]--] = i;
    
    for (int k = 1; k <= n; k <<= 1) {
        int num = 0;
        for (int i = n - k + 1; i <= n; i++) y[++num] = i;
        for (int i = 1; i <= n; i++) if (sa[i] > k) y[++num] = sa[i] - k;
        
        fill(cnt + 1, cnt + m + 1, 0);
        for (int i = 1; i <= n; i++) cnt[x[i]]++;
        for (int i = 2; i <= m; i++) cnt[i] += cnt[i-1];
        for (int i = n; i; i--) sa[cnt[x[y[i]]]--] = y[i];
        
        swap(x, y);
        x[sa[1]] = num = 1;
        for (int i = 2; i <= n; i++)
            x[sa[i]] = (y[sa[i]] == y[sa[i-1]] && y[sa[i]+k] == y[sa[i-1]+k]) ? num : ++num;
        if ((m = num) == n) break;
    }
}

void get_height() {
    for (int i = 1; i <= n; i++) rk[sa[i]] = i;
    for (int i = 1, k = 0; i <= n; i++) {
        if (rk[i] == 1) continue;
        if (k) k--;
        int j = sa[rk[i]-1];
        while (i+k <= n && j+k <= n && s[i+k] == s[j+k]) k++;
        height[rk[i]] = k;
    }
}

int main() {
    scanf("%d%s", &n, s+1);
    get_sa();
    get_height();
    ll ans = 1LL * n * (n+1) / 2;
    for (int i = 1; i <= n; i++) ans -= height[i];
    printf("%lld\n", ans);
    return 0;
}
```
**代码解读概要**：  
- `get_sa()`: 双关键字基数排序实现后缀数组（倍增法）  
- `get_height()`: 利用`rk`数组和`k`不降性质O(n)求height  
- `main`: 总子串数公式减去重复前缀和

### 精选题解代码亮点赏析

**题解一（Leap_Frog）SA核心**  
```cpp
// 总子串数 - 重复数 = 答案
long long solve() {
    long long ans = 1ll * n * (n+1) / 2;
    for (int i = 1; i <= n; i++) ans -= h[rk[i]]; 
    return ans;
}
```
**亮点**：正难则反的容斥思想，`h`即height数组

**题解二（Rorschachindark）SAM动态维护**  
```cpp
void Insert(int c) {
    // ...SAM构建过程
    ans += len[q] - len[fa[q]]; // 关键！动态累加新状态贡献
}
```
**亮点**：SAM增量维护答案，避免后处理

**题解三（Oracle）SA去重公式**  
```cpp
ll solve() {
    ll ans = 0;
    for (int i = 1; i <= n; i++)
        ans += n + 1 - sa[i] - height[i]; // 每个后缀独立贡献
    return ans;
}
```
**亮点**：直接计算每个后缀的有效子串数，思维更直接

---

## 5. 算法可视化：像素动画演示

### 主题：**《后缀探险者：SA构建寻径》**(8-bit像素风)

### 设计思路
> 用复古游戏风格演示SA的倍增排序和height计算。玩家化身"后缀小子"，在字符串网格中收集字母，同时屏幕右侧动态绘制height数组。每轮排序对应游戏关卡，LCP比较过程化为角色跳跃动作。

### 关键帧与交互
1. **初始化舞台**  
   - 8-bit像素字符串横向排列（每个字符16x16像素块）  
   - 下方显示后缀索引：`1:aabaa, 2:abaa, ...`  
   - 控制面板：`暂停/继续` `单步` `速度滑块`

2. **基数排序关卡**  
   ```markdown
   [第一关键字排序]
   像素动画：
     后缀小子站在当前后缀起点
     头顶气泡显示当前字符（如'a'）
     角色跳到对应字母桶中（桶用不同颜色像素块表示）
   ```

3. **双关键字比较**  
   ```markdown
   [第二关键字处理]
   动画：
     后缀小子背负数对 (主关键字, 次关键字)
     比较时角色脚下延伸出双色轨道
     相同关键字时轨道连接，角色滑行通过
   ```

4. **height计算冒险**  
   ```markdown
   [LCP攀登挑战]
   交互：
     - 控制角色沿两个后缀向上跳跃
     - 相同字母时安全通过（绿色像素）
     - 不同字母时坠落（红色闪烁+8-bit失败音效）
     - 坠落高度即为height值（显示在右侧柱状图）
   ```

5. **游戏化元素**  
   - **连击系统**：连续正确比较得Combo分  
   - **限时挑战**：自动播放模式如"贪吃蛇AI"自主闯关  
   - **音效**：  
     * 正确比较：FC经典"吃金币"音  
     * 计算height：阶梯跳跃音阶  
     * 关卡通过：8-bit胜利旋律

### 技术实现
- **Canvas绘制**：网格用`<canvas>`绘制，角色精灵图逐帧更新
- **颜色方案**：  
  - 后缀索引：天蓝(#89CFF0)  
  - 当前比较元素：闪烁金黄(#FFD700)  
  - height柱状图：渐变红绿(#FF4136 → #2ECC40)
- **伪代码映射**：  
  屏幕底部实时显示当前步骤对应SA伪代码（高亮执行行）

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
1. **最长公共子串**：SA的height数组求最大值，或SAM双串构建  
2. **第K小子串**：SAM上DP预处理路径数+字典序DFS  
3. **重复次数最多的子串**：SA+二分答案，或SAM的endpos集合大小  

### 洛谷题目推荐
1. **P3809 【模板】后缀排序**  
   → 巩固SA基数排序实现，理解`sa/rk`数组关系  
2. **P3975 【模板】后缀自动机**  
   → 练习SAM构建和动态维护技巧  
3. **P2852 [USACO06DEC]Milk Patterns G**  
   → SA+height数组应用，求至少出现k次的最长子串  

---

## 7. 学习心得与经验分享

> **经验摘录（Leap_Frog）**：  
> *"此题是字符串入门好题。显然用AC自动机、KMP等提高组算法不可解。显然用后缀数组、后缀自动机等算法可以轻易解。"*  
>  
> **洛语云笺点评**：  
> 作者一针见血指出算法选择的关键——不同工具解决不同问题。当遇到"不同子串统计"时，要立刻关联SA/SAM而非其他字符串算法。这种**问题-算法映射**意识需要大量练习内化。  
>  
> **调试技巧提炼**：  
> 1. SA调试：优先验证前10个`sa[i]`和`height[i]`  
> 2. SAM调试：打印`len/link`数组检查状态转移  
> 3. 小数据暴力对拍：n=3时手工验证（如"aba"应有5个子串）

---

**结语**：  
本次探索展示了字符串问题的两种优雅解法——后缀数组的数学之美与后缀自动机的状态艺术。记住：SA是"用排序刻画前缀关系"，SAM是"用状态压缩表达后缀关联"。掌握它们，你就拥有了解决90%字符串问题的钥匙！下次我们将挑战更复杂的字符串问题，继续前进吧！🚀

---
处理用时：260.63秒
# 题目信息

# [MtOI2018] 崩坏3？非酋之战！

## 题目背景

原题面因为太丑，被 disangan233 于 2019/09/26 修改。

在 2018 年暑假的时候，disangan233 肝了一个暑假的崩坏 3，他的帐号终于 $50$ 级啦！他终于把他的逆神巫女肝到 S 啦！

因为庆祝崩坏 3 登上 APP Store Top1，米忽悠给全服玩家发放了 $5$ 张扩充补给卡。

在玄学233聊天室发送了 "怒 grass 大伟出奇迹！" 之后就……单抽出律化娜了。

![Screenshot_20180804-124812.png](https://i.loli.net/2019/08/24/3s2AKqOQNUMGLcF.png)


## 题目描述

在崩坏 3 中有一个叫做天命基地的地方，女武神们将在基地中~~开派对~~与敌人们厮杀。

女武神们的攻击力为 $atk$，她们将进行资源保卫战！

天命基地中有 $1$个 boss，boss 的血量为 $hp$，boss 不会攻击女武神。

现在有一条长度为 $n$ 的道路，道路的一头是 boss，另外一头是女武神需要保卫的资源，最开始 boss 每秒将会向资源移动 1 个单位长度。女武神们需要保护资源，所以她们要攻击 boss。 

我们将整条道路分成 $n$ 个格子，最开始资源在第 $n$ 格，女武神在第 $1$ 格，boss 在第 $0$ 格。

因为女武神的手太短了，所以只有当 boss 到达女武神当前那一格的时候，女武神才会攻击 boss，攻击完之后女武神会后退一格。

女武神有以下 $8$ 种攻击方式（每一格只能使用一种攻击方式）        

* 技能，造成 $80\% atk$ 的伤害，并使 boss 获得 $1$ 层燃烧 buff，在之后的每秒钟额外受到 $10\% atk$ 的伤害。(燃烧buff可以叠加)        
* 闪避，造成 $70\% atk$ 的伤害，并使 boss 时间暂停 $5s$。（$5s$ 内 boss 无法移动且仍会受到燃烧伤害）      
* 大招，造成 $120\% atk$ 的伤害，使 boss 时间暂停 $5s$。       
* 分支攻击，造成 $70\% atk$ 的伤害，并使 boss 时空减速，使 boss 经过每一个格子的时间增加 $1s$。    
* 爱酱的炸弹，使 boss 获得 $1$ 层燃烧 buff，并使 boss 愤怒，移速 $+50\%$。     
* 犹大的誓约，造成 $60\% atk$ 的伤害，如果 boss 有燃烧 buff 则减少 1 层，使 boss 时间暂停 $4s$。       
* 奥托之光，造成 $10\% atk$ 的伤害，如果 boss 有燃烧 buff 则清除 buff，使 boss 时间暂停 $10s$。     
* 律者之力，造成 $80\% atk$ 的伤害，使 boss 的移动速度 $+100\%$。

现在给你所有的信息，让你帮助 disangan233 蒟蒻算一下，他的女武神能否在 boss 触碰到资源前战胜 boss。

如果可以，输出 boss 死亡时距离资源最远的格子编号。如果不可以，请输出对 boss 造成的最大伤害。    

## 说明/提示

#### 样例解释 $3$

开局 1 个技能，再来 1 个大招。

#### 样例解释 $4$

开局 1 个技能，再来 2 个大招。

### 子任务

对于 $10\%$ 的数据，保证：

$$
n\leq 10 \qquad  \max Atk\leq 10^{7}-1
$$     

对于 $20\%$ 的数据，保证：

$$
n\leq 300 \qquad \max Atk\leq 2^{32}-1
$$     

对于 $40\%$ 的数据，保证：

$$
n\leq 1,000 \qquad \max Atk\leq 2^{63}-1
$$     
对于 $70\%$ 的数据，保证：

$$
n\leq 5,000 \qquad \max Atk\leq 2^{63}-1
$$  

对于 $100\%$ 的数据，保证：

$$
n\leq 10,000 \qquad atk\equiv 0(\bmod\ 10)\qquad  atk\leq 10,000\qquad \max Atk\leq 2^{64}-1
$$  

### 题目来源

[MtOI2018 迷途の家の水题大赛](https://www.luogu.org/contest/11260) T4

出题人：disangan233

验题人：CYJian

72679

## 样例 #1

### 输入

```
1
1000 100```

### 输出

```
120
MiHoYo Was Destroyed!```

## 样例 #2

### 输入

```
10
1000 0```

### 输出

```
0
MiHoYo Was Destroyed!```

## 样例 #3

### 输入

```
10
198 100```

### 输出

```
2
Tech Otakus Save The World!```

## 样例 #4

### 输入

```
3
23333 100```

### 输出

```
440
MiHoYo Was Destroyed!```

## 样例 #5

### 输入

```
100
19260817 2330```

### 输出

```
99
Tech Otakus Save The World!```

# AI分析结果


### 💡 洛语云笺的C++算法解析：崩坏3？非酋之战！ 深入学习指南 💡

#### **1. 题目解读与策略初探**
**✨ 核心挑战**  
本题的核心挑战在于处理攻击方式的复杂依赖关系：  
- 8种攻击方式中只有3种真正有效（技能、大招、分支攻击）  
- 燃烧buff和减速buff存在时间空间叠加效应  
- 需要在n格移动限制下最大化伤害或提前击败boss  

**✨ 核心算法标签**  
动态规划(DP) + 贪心策略 + 滚动数组优化  

**🗣️ 初步分析**  
1. **暴力解法**：枚举所有攻击组合（3^n种可能），时间复杂度O(3^n) → 完全不可行  
2. **贪心优化**：发现大招必须最后释放（时停效果最大化燃烧伤害），减少决策维度  
3. **动态规划**：  
   - 状态定义：`dp[i][j]` = 使用i次技能和j次分支攻击后的总伤害  
   - 状态转移：从`dp[i-1][j]`（加技能）或`dp[i][j-1]`（加分支）转移  
   - 时间复杂度O(n²) 空间复杂度O(n)（滚动数组优化）  

**🔍 算法侦探：如何在题目中发现线索？**  
1. **线索1（问题目标）**：  
   "在n格限制下最大化伤害/提前击败" → 带约束的最优化问题 → DP典型场景  
2. **线索2（问题特性）**：  
   - 攻击效果存在依赖链（燃烧伤害依赖技能，时停效果依赖大招时机）  
   - 效果可叠加 → 指向状态转移型DP  
3. **线索3（数据规模）**：  
   n≤10,000 → O(n²)算法（10⁸操作）在常数优化后可行，排除O(2ⁿ)暴力  

**🧠 思维链构建：从线索到策略**  
> 综合三条线索：  
> 1. 最优化问题首先考虑DP或贪心  
> 2. 技能效果叠加形成"依赖链"，需记录状态（i,j）  
> 3. 数据规模要求O(n²)解法 → 二维DP是唯一可行方案  
> 4. **关键突破**：发现大招必须最后释放（贪心剪枝），将三维问题降为二维  

---

#### **2. 精选优质题解参考**
**disangan233（五星）**  
* **亮点**：  
  - 严谨证明"大招最后放"的贪心策略（关键引理）  
  - 滚动数组实现简洁高效（空间O(n)）  
  - 输入优化（快读）处理大数据边界  
* **核心思想**：  
  `dp[i][j] = max(加技能, 加分支) + 燃烧伤害`，大招独立计算  

**lenlen（四星）**  
* **亮点**：  
  - 清晰分析技能优劣（排除5种无效技能）  
  - 状态转移方程完整展示燃烧伤害计算逻辑  
* **核心思想**：  
  燃烧伤害 = 0.1·atk·i·j（i=技能次数, j=分支次数）  

**zyn_（四星）**  
* **亮点**：  
  - 独创伤害计算公式化简（避免浮点运算）  
  - 完整数学证明（凸函数性质）  
* **核心思想**：  
  预处理`atk/=10`，所有伤害用整数计算  

---

#### **3. 解题策略深度剖析**
**🎯 核心难点与关键步骤**  
1. **依赖关系建模**：  
   - 燃烧伤害 = f(技能次数i, 分支次数j, atk)  
   - 大招伤害 = 12·atk + i·(j+6)·atk  
   *💡 学习笔记*：将复杂游戏机制转化为数学公式是解题关键  

2. **状态转移设计**：  
   ```python
   dp[i][j] = max(
        dp[i-1][j] + 8*atk + (i-1)*(j+1)*atk,  # 加技能
        dp[i][j-1] + 7*atk + i*j*atk           # 加分支
   )
   ```
   *💡 学习笔记*：滚动数组通过`i&1`和`(i-1)&1`交替使用两行数组  

3. **答案双重更新**：  
   - 若中途伤害≥hp：记录最小步数`ans_steps = min(ans_steps, i+j)`  
   - 若总伤害<hp：记录`ans_damage = max(总伤害)`  

**✨ 解题技巧总结**  
- **技巧1（无效技能排除）**：8种→3种，减少状态数  
- **技巧2（贪心剪枝）**：大招最后释放，降维打击  
- **技巧3（整数运算）**：`atk/=10`避免浮点误差  
- **技巧4（滚动数组）**：二维DP→空间O(n)  

**⚔️ 策略竞技场**  
| 策略          | 核心思想               | 优点              | 缺点                  | 得分预期 |
|---------------|------------------------|-------------------|-----------------------|----------|
| 暴力枚举      | 枚举所有攻击组合       | 直观              | O(3ⁿ) 超时           | 0-10分   |
| 纯贪心        | 固定攻击顺序          | O(n) 时间         | 非最优解              | 30-50分  |
| DP+滚动数组   | 状态转移+大招最后     | O(n²) 时间/空间   | 需精细实现           | 100分    |

**✨ 优化之旅**  
> 1. **起点：暴力枚举**  
>    - 3¹⁰⁰⁰⁰种可能 → 宇宙毁灭也算不完  
> 2. **发现瓶颈**：  
>    - 攻击顺序影响伤害 → 存在重复子问题  
> 3. **DP优化**：  
>    - 状态`dp[i][j]`记录子问题解  
> 4. **贪心突破**：  
>    - 大招必须最后放 → 状态数从O(n³)降为O(n²)  
> 5. **空间优化**：  
>    - 滚动数组将空间从O(n²)降为O(n)  

---

#### **4. C++核心代码实现赏析**
**通用核心实现**  
```cpp
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;

int main() {
    ull n, hp, atk;
    cin >> n >> hp >> atk;
    atk /= 10; // 关键预处理

    vector<vector<ull>> dp(2, vector<ull>(n+1, 0));
    ull max_damage = 0, min_steps = INT_MAX;

    for (int i = 0; i <= n; ++i) {
        int cur = i % 2, prev = !cur;
        for (int j = 0; i+j <= n; ++j) {
            dp[cur][j] = 0;
            if (i > 0) // 从技能转移
                dp[cur][j] = max(dp[cur][j], dp[prev][j] + 8*atk + (i-1)*(j+1)*atk);
            if (j > 0) // 从分支转移
                dp[cur][j] = max(dp[cur][j], dp[cur][j-1] + 7*atk + i*j*atk);
            
            ull ults = n - i - j; // 大招次数
            ull ult_dmg = 12*atk + i*(j+6)*atk; // 单次大招伤害
            ull total = dp[cur][j] + ults * ult_dmg;

            if (dp[cur][j] >= hp) 
                min_steps = min(min_steps, (ull)i+j);
            else if (total >= hp) 
                min_steps = min(min_steps, i+j + (hp-dp[cur][j]+ult_dmg-1)/ult_dmg);
            
            max_damage = max(max_damage, total);
        }
    }

    if (min_steps <= n) cout << min_steps << "\nTech Otakus Save The World!";
    else cout << max_damage << "\nMiHoYo Was Destroyed!";
}
```

**disangan233 代码亮点**  
```cpp
// 滚动数组的精妙实现
for(int i=0; i<=n; i++) {
    for(int j=0; i+j<=n; j++) {
        if(i) dp[i&1][j] = max(dp[i&1][j], dp[(i-1)&1][j] + ...);
        if(j) dp[i&1][j] = max(dp[i&1][j], dp[i&1][j-1] + ...);
    }
}
```
* **学习笔记**：`i&1`替代`i%2`提升效率，位运算优化是竞赛常用技巧  

**zyn_ 代码亮点**  
```cpp
// 伤害计算公式化简
const ull skill_dmg = 8 * atk + (i-1)*(j+1)*atk;
const branch_dmg = 7 * atk + i*j*atk;
```
* **学习笔记**：将题面中的百分比伤害转换为整数运算，避免浮点精度问题  

---

#### **5. 算法可视化：像素动画演示**
**🎮 设计概念**  
> 8-bit像素风格模拟FC游戏，将算法流程转化为boss战：  
> - 女武神像素精灵（左） vs boss像素怪物（右）  
> - 格子道路显示移动进度  
> - 技能特效：火焰（技能）、时钟（分支）、闪光（大招）  

**🕹️ 交互设计**  
1. **战场绘制**：  
   ``` 
   [女武神] [ ] [ ] [boss] [资源] 
   ```  
2. **攻击特效**：  
   - 技能：格子燃起火焰  
   - 分支：时钟图标覆盖格子  
   - 大招：全屏闪光+暂停特效  

3. **控制面板**：  
   - 步进控制：单步执行/自动播放  
   - 速度滑块：调整boss移动速度  
   - 技能选择：手动切换攻击方式  

**📊 数据可视化**  
``` 
伤害计算面板：
当前伤害：dp[i][j] = 1200
燃烧层数：i=3  
减速效果：j=2
大招待放：k=5
```  

**🎵 游戏化元素**  
- **音效设计**：  
  - 技能：火焰声(8-bit)  
  - 分支：时钟滴答声  
  - 大招：爆炸音效  
- **关卡进度**：  
  - 每10格解锁新技能特效  
  - 击败boss获得S评分  

---

#### **6. 拓展练习与相似问题**
**通用技巧迁移**  
1. **依赖背包问题**：P1064 金明的预算方案（主件附件依赖）  
2. **状态转移优化**：P1541 乌龟棋（多维状态+滚动数组）  
3. **游戏机制建模**：P2679 [NOIP2015]子串（字符串操作类游戏）  

**洛谷练习推荐**  
1. **P1064** 金明的预算方案  
   → 巩固分组背包和依赖处理  
2. **P1541** 乌龟棋  
   → 学习四维DP状态压缩  
3. **P2679** [NOIP2015]子串  
   → 训练复杂状态转移设计能力  

---

#### **7. 学习心得**
> 来自题解作者的调试经验：  
> - **disangan233**：  
>   "在实现滚动数组时，`dp[i&1]`和`dp[(i-1)&1]`的边界处理让我调试了2小时"  
>   → 学习：滚动数组需初始化每行，避免脏数据  
>  
> - **zyn_**：  
>   "unsigned long long伤害溢出是隐藏陷阱"  
>   → 学习：大数据题需验证中间结果是否溢出  

---

**最终结论**  
通过动态规划+贪心策略，将复杂游戏机制转化为二维状态转移模型：  
1. 状态定义：`dp[i][j]` = i次技能+j次分支的伤害  
2. 贪心优化：大招最后释放  
3. 空间优化：滚动数组实现O(n)空间  
关键突破在于识别无效技能和攻击顺序优化，将O(3ⁿ)问题降为O(n²)可解问题。

---
处理用时：222.11秒
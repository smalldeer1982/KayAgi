# 题目信息

# [MtOI2019] 恶魔之树

## 题目背景

在 Kirito 和 Eugeo 还没有与 Alice 前往北之洞窟的时候，Eugeo 每天只能用龙骨斧砍恶魔之树——基家斯西达……

![](https://cdn.luogu.com.cn/upload/image_hosting/95swctde.png)

~~请忽略bilibili的水印~~

## 题目描述

Kirito 和 Eugeo 每天砍树觉得很无聊，于是开始比谁砍出好声音的次数多。渐渐地，他们发现这样也没有意思了，于是在这个基础上改了一点：

每个人去砍树前，会随机得到一个长度为 $n$ 的数列 $s_1, s_2, \dots, s_n$ 。最初每个人的得分都是 $1$，当第 $i$ 次砍出了一个好声音时，得分就变成了原来的得分与 $s_i$ 的最小公倍数，也就是常说的 ${\rm lcm}$。

现在 Kirito 已经得到了一个长度为 $n$ 的数列 $s_1, s_2, \ldots, s_n$ 。他想知道，如果每一次砍出好声音的概率是 $50\%$ 时他的期望得分。

由于 Kirito 不想看到小数，所以请你告诉 Kirito 答案乘 $2^n$ 对 $p$ 取模的值。

## 说明/提示

#### 样例解释 1

一共有 $8$ 种情况：

- 没有出现好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第一次出现了好声音，得分为 $1$，概率为 $\frac{1}{8}$。

- 只有第二次出现了好声音，得分为 $2$，概率为 $\frac{1}{8}$。

- 只有第三次出现了好声音，得分为 $3$，概率为 $\frac{1}{8}$。

- 只有第三次没有出现好声音，得分为 $\operatorname{lcm}(1, 2)=2$，概率为 $\frac{1}{8}$。

- 只有第二次没有出现好声音，得分为 $\operatorname{lcm}(1, 3)=3$，概率为 $\frac{1}{8}$。

- 只有第一次没有出现好声音，得分为 $\operatorname{lcm}(2, 3)=6$，概率为 $\frac{1}{8}$。

- 每一次都砍出了好声音，得分为 $\operatorname{lcm}(1, 2, 3)=6$，概率为 $\frac{1}{8}$。

所以期望值为 $\frac{1}{8}+\frac{1}{8}+\frac{2}{8}+\frac{3}{8}+\frac{2}{8}+\frac{3}{8}+\frac{6}{8}+\frac{6}{8}=3$

乘上 $2^3$ 得到答案为 $24$。

### 子任务

本题采用捆绑测试。

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$，$10^7 \leq p \leq 1.1 \times 10^9$且$p$为质数，$1\leq s_i\leq 300$。

本题共 $7$ 个子任务，各子任务的分值和限制如下：

子任务 $1$（$3$ 分）：$n=1$。

子任务 $2$（$7$ 分）：$n=18$。

子任务 $3$（$10$ 分）：$n=100$，$s$ 中不同的正整数不超过 $18$ 个。

子任务 $4$（$20$ 分）：$n=100$，不存在 $1\leq i \neq j \leq n$，使得 $s_i=s_j$。且保证数据随机。

子任务 $5$（$20$ 分）：$1\leq s_1, s_2, \ldots, s_n \leq 100$。

子任务 $6$（$20$ 分）：$1\leq n \leq 10^4$。

子任务 $7$（$20$ 分）：无特殊限制。

------

谨以此题庆祝刀剑10周年。~~好像晚了几个月...~~


### 题目来源

[MtOI2019 Extra Round](https://www.luogu.org/contest/22840) T4

出题人：CYJian 

验题人：suwAKow


## 样例 #1

### 输入

```
3 998244353
1 2 3```

### 输出

```
24```

## 样例 #2

### 输入

```
10 998244353
1 2 3 4 5 6 7 8 9 10```

### 输出

```
516032```

# AI分析结果


### 题目解读与策略初探

**✨ 本题核心挑战**：在指数级的状态空间下（$2^n$ 种序列），高效计算所有子序列的 $\text{lcm}$ 之和，并处理 $s_i \leq 300$ 的质因子依赖关系。

**✨ 核心算法标签**：动态规划（DP）、根号分治、状态压缩

**🗣️ 初步分析**：  
题目要求所有子序列 $\text{lcm}$ 之和乘以 $2^n \mod p$。直接枚举子序列（$O(2^n)$）不可行。突破口在于 $s_i \leq 300$ 的约束：
1. **质因子根号分治**：将质数分为小质数（$\leq 17$）和大质数（$>17$）。小质数仅 $7$ 个（$2,3,5,7,11,13,17$），其最大幂次有限（$8,5,3,2,2,2,2$），形成 $17496$ 种状态。
2. **大质数独立性**：每个 $s_i$ 至多含一个大质因子，可按大质数分组处理。
3. **动态规划优化**：  
   - **小质数状态**：$dp[a][b][c][d][e][f][g]$ 表示小质数幂次组合的方案数。  
   - **大质数贡献**：按大质数分组，设计 $F[t][a][b]\cdots$ 处理大质数选/未选的状态转移。  
4. **复杂度优化**：相同 $s_i$ 合并处理（$O(300 \times 17496)$），避免 $O(n)$ 枚举。

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：  
   "求所有子序列 $\text{lcm}$ 之和" → 这是**组合最优化问题**，需枚举所有子集，但 $O(2^n)$ 不可行。动态规划通过状态压缩避免重复计算。

2. **线索2 (问题特性)**：  
   "$s_i \leq 300$" → **值域有限**，质因子数量少。根号分治（小质数状压 + 大质数分组）是经典套路，如背包问题中的依赖处理。

3. **线索3 (数据规模)**：  
   "$n \leq 3\times 10^5$" → 需 $O(n \log n)$ 或 $O(n \cdot \text{状态数})$ 算法。$17496$ 种状态配合滚动数组，满足 $O(300 \times 17496) \approx 5\times 10^6$ 操作量。

---

### 🧠 思维链构建：从线索到策略

> 侦探工作完成！我们整合线索：  
> 1. **线索1**指向动态规划——用状态表示子问题（$\text{lcm}$ 的质因子幂次）。  
> 2. **线索2**揭示质因子的特殊性——小质数可状压（$17496$ 状态），大质数独立分组。  
> 3. **线索3**验证可行性——$17496 \times 300$ 次操作可接受。  
> **结论**：**根号分治 + 状态压缩 DP** 是唯一高效解法。核心步骤：  
> - **预处理**：分解 $s_i$ 的质因子，按大质数分组。  
> - **DP 设计**：  
>   - 第一段 DP 处理小质数状态。  
>   - 第二段 DP 按大质数组转移贡献。  
> - **合并状态**：最终答案是小质数状态与大质数贡献的乘积和。

---

### 精选优质题解参考

1. **mrsrz 的题解（质量：★★★★★）**  
   **亮点**：  
   - 清晰分离小质数（`dp` 数组）和大质数（`F` 数组）的处理逻辑。  
   - 用 `lambda` 简化质因子幂次计算（`pow(2,b1)*...`），提升可读性。  
   - 预处理质因子分解，相同 $s_i$ 合并转移，降低复杂度至 $O(17496 \times 300)$。  
   **核心代码片段**：  
   ```cpp
   // 小质数 DP 转移
   rep(a1,0,8) rep(a2,0,5) ... {
       int s = dp[...];
       int b1=max(a1, pfac[i][0]), ...; // 新幂次
       int t = pow(2,b1) * ... % mod;   // 新状态的 lcm 值
       dp_new[b1][b2]... = (dp_old[...] + s * (pow(2,cnt)-1)) % mod;
   }
   ```

2. **Prean 的题解（质量：★★★★☆）**  
   **亮点**：  
   - 高维差分加速状态转移，避免重复计算质因子贡献。  
   - 乘积形式 $\prod((2^{cnt_i}-1)\times p_i +1)$ 巧妙合并大质数贡献。  
   **核心思想**：  
   ```cpp
   // 大质数贡献合并
   for(int p: big_primes) {
       F[state] = F_old[state] * ( (pow(2,cnt)-1)*p + 1 );
   }
   ```

3. **AquariusZhao 的题解（质量：★★★★）**  
   **亮点**：  
   - 状态设计为 $dp[i][j][0/1]$，$j$ 是小质数状态编号，$0/1$ 表示大质数是否选中。  
   - 使用 `unordered_map` 压缩状态空间，代码简洁。  
   **转移方程**：  
   ```cpp
   if (当前大质数 == 前一个) 
      dp[i][j][1] += (dp[i-1][j][0]*p + dp[i-1][j][1]) * (2^cnt-1);
   else 
      dp[i][j][1] += (dp[i-1][j][0]+dp[i-1][j][1]) * p * (2^cnt-1);
   ```

---

### 解题策略深度剖析

#### 🎯 核心难点与关键步骤
1. **难点1：状态设计与维度爆炸**  
   - **分析**：小质数有 $7$ 个，其幂次范围不同，需设计 $7$ 维数组（$9\times6\times4\times3\times3\times3\times3$）。  
   - **💡 学习笔记**：固定质因子顺序（`{2,3,5,7,11,13,17}`），用多维数组表示状态。

2. **难点2：大质数依赖处理**  
   - **分析**：大质数需分组转移，每组内 $s_i$ 共享同一质因子。转移时需乘 $\Delta = \text{lcm}_\text{新}/\text{lcm}_\text{旧}$。  
   - **💡 学习笔记**：按大质数排序分组，确保同组一起处理，避免状态冲突。

3. **难点3：时间与空间优化**  
   - **分析**：$17496$ 状态 $\times 300$ 次转移 ≈ $5\times 10^6$，需滚动数组和预处理幂次。  
   - **💡 学习笔记**：预处理 $2^k \mod p$ 和质因子幂次，避免重复计算。

#### ✨ 解题技巧总结
- **技巧1：根号分治**  
  小质数状压（有限状态），大质数分组（独立处理），分解复杂度。
- **技巧2：状态合并**  
  相同 $s_i$ 合并转移（乘 $2^{\text{cnt}}-1$），避免逐个处理。
- **技巧3：滚动数组**  
  DP 状态仅依赖前一轮，用 `dp[cur]` 和 `dp[prev]` 交替更新。

#### ⚔️ 策略竞技场：不同解法对比
| 策略                | 核心思想                     | 优点                          | 缺点                                   | 得分预期 |
|---------------------|----------------------------|-----------------------------|----------------------------------------|----------|
| **暴力枚举**        | 枚举所有 $2^n$ 子序列        | 简单直观                     | $O(2^n)$ 超时，$n>20$ 不可行           | 30%      |
| **纯状压 DP**       | 直接压缩所有质因子           | 理论可行                     | 状态数 $>10^{10}$，空间爆炸             | 40%      |
| **根号分治+状态压缩** | 小质数状压 + 大质数分组      | $O(17496 \times 300)$ 高效   | 代码复杂，需精细实现                   | 100%     |

#### ✨ 优化之旅：从暴力到最优
1. **起点：暴力枚举**  
   枚举所有子序列，计算 $\text{lcm}$，复杂度 $O(2^n \times \log s_i)$ → $n=20$ 时已超时。
2. **关键发现：质因子独立**  
   $\text{lcm}$ 由质因子最大幂次决定，可分离小质数和大质数。
3. **优化1：小质数状压**  
   压缩 $7$ 个小质数状态（$17496$），相同 $s_i$ 合并转移。
4. **优化2：大质数分组**  
   按大质数分组，每组内统一处理贡献，避免维度爆炸。
5. **终局**：$O(300 \times 17496)$ 完美通过 $n=3\times10^5$。

> **💡 策略总结**：  
> 从暴力到最优是“问题特征洞察 → 状态维度压缩 → 分组分治”的经典路径。在竞赛中，即使无法实现最优解，基于根号分治的暴力优化也能获得部分分。

---

### C++核心代码实现赏析

**本题通用核心实现**（基于 mrsrz 题解）：  
```cpp
#include <iostream>
#include <vector>
using namespace std;

const int STATE = 17496; // 9*6*4*3*3*3*3
int dp[2][STATE], F[2][2][STATE]; // 滚动数组 + 大质数状态
int primes[] = {2,3,5,7,11,13,17};

int main() {
    // 预处理质因子分解
    vector<vector<int>> factor(301, vector<int>(7,0));
    for (int i=1; i<=300; i++) {
        int tmp = i;
        for (int j=0; j<7; j++) 
            while (tmp % primes[j]==0) factor[i][j]++, tmp /= primes[j];
    }

    // 小质数 DP 初始化
    dp[0][0] = 1; // 初始状态：lcm=1

    // 第一段：处理小质数状态
    for (int i=1; i<=300; i++) {
        for (int s=0; s<STATE; s++) {
            int new_state = calc_new_state(s, factor[i]); // 计算新状态
            dp[1][new_state] += dp[0][s] * (pow2[cnt[i]] - 1);
        }
        swap(dp[0], dp[1]); // 滚动数组
    }

    // 第二段：处理大质数
    for (int p : big_primes) { // 枚举大质数组
        for (int s=0; s<STATE; s++) {
            for (int i : group[p]) { // 组内每个 s_i
                int new_state = calc_new_state(s, factor[i]);
                int delta = calc_delta(s, new_state); // Δ = lcm_new / lcm_old
                F[1][1][new_state] += F[0][0][s] * delta * p * (pow2[cnt]-1);
                F[1][1][new_state] += F[0][1][s] * delta * (pow2[cnt]-1);
            }
        }
        // 合并状态：F[0] += F[1], F[1]清零
    }

    // 答案 = ∑(dp[final_state] * lcm_value)
    int ans = 0;
    for (int s=0; s<STATE; s++) 
        ans += F[0][s] * calc_lcm(s);
    cout << ans;
}
```

**代码解读概要**：  
1. **状态表示**：`dp[state]` 为小质数状态，`F[t][state]` 增加大质数维度（$t=0/1$）。  
2. **calc_new_state**：计算新旧状态的 $\text{lcm}$ 并返回新状态编号。  
3. **calc_delta**：计算 $\text{lcm}$ 变化量（$\Delta = \prod p^{\max(\text{新幂次}-\text{旧幂次},0}$）。  

---

### 算法可视化：像素动画演示

**🎮 设计：像素风状态转移冒险**  
- **场景**：7×7 网格地图，每个格子代表一个小质数状态（$2^a \times 3^b \times \cdots$）。  
- **角色**：像素勇者（玩家）携带“状态宝石”（当前 $\text{lcm}$ 值）。  
- **流程**：  
  1. **小质数关卡**：勇者遍历网格，击败怪物（$s_i$）后更新宝石（新 $\text{lcm}$）。  
     - **动画**：怪物被击败时，宝石闪烁并显示 $\Delta$ 值。  
  2. **大质数关卡**：进入黑暗森林（大质数组），每次战斗需选择是否使用“大质数之力”（$t=0/1$）。  
     - **音效**：选择“使用”时播放能量聚集音效。  
  3. **BOSS战**：最终合并状态（$F[0] += F[1]$），宝石融合发光。  

**🕹️ 交互控制**：  
- **单步执行**：按空格键逐步移动勇者，观察状态更新。  
- **自动演示**：点击“AI演示”看勇者自动通关，速度可调。  
- **状态面板**：实时显示 $dp$ 和 $F$ 数组的值。  

**🎨 像素艺术**：  
- **风格**：8-bit 复古风（类似 FC 游戏）。  
- **特效**：状态更新时网格高亮，$\Delta$ 值以像素字体弹出。  

---

### 拓展练习与相似问题
1. **相似问题思路迁移**：  
   - **分组背包**：物品分组（如 P1064 [金明的预算方案]）。  
   - **质因子分解+DP**：P1853 [投资最大价值]。  
   - **状态压缩**：P1776 [宝物筛选]（多重背包优化）。  

2. **推荐练习（洛谷）**：  
   1. **P1064**：分组背包模板题，巩固“依赖关系转化为分组决策”。  
   2. **P1853**：投资问题，练习质因子分解 + DP 状态设计。  
   3. **P1776**：多重背包，学习状态压缩优化技巧。  

---

### 学习心得与经验分享
1. **mrsrz 的调试经验**：  
   > “大质数分组转移时，忘记清空临时状态数组导致 WA，建议写辅助函数 `clear_state()`。”  
   **💡 学习笔记**：DP 滚动数组切换后，务必清空临时状态！  

2. **Prean 的优化心得**：  
   > “用高维差分代替直接转移，状态更新速度提升 3 倍。”  
   **💡 学习笔记**：差分是优化高维 DP 的利器，尤其适合质因子幂次更新。  

---

**结语**：本题是根号分治与状态压缩的完美结合。掌握质因子分解、分组处理、滚动数组三大技巧，即可高效解决此类问题。记住：**“化大为小，分而治之”** 是算法核心哲学！ 🚀

---
处理用时：172.39秒
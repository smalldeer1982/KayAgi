# 题目信息

# 「MCOI-02」Build Battle 建筑大师

## 题目背景

WAPER 爱玩 hypixel（世界上最大的 Minecraft 小游戏服务器） 建筑大师！

提示：在本题中，羊毛属于一种方块。

## 题目描述

现在 WAPER 准备玩 $q$ 局建筑大师。在第 $i$ 局游戏的开始，WAPER 会选定一个参数 $m_i$，并 **按顺序** 放置 $n$ 个有颜色的羊毛，羊毛颜色的排列如下：

$$1,\ 2,\ ...\ ,\ m_i-1,\ m_i,\ 1,\ 2,\ ...\ ,m_i-1\ ,m_i\ ,\ ...\ (n-1) \ \bmod \  m_i+1$$

例如 $n=7,m=3$ 时，颜色排列如下：

$$1\ ,2,\ 3,\ 1,\ 2,\ 3,\ 1$$

现在 WAPER 准备打破一些方块（可以一个也不打破，也可以全部打破），WAPER 想知道这样可以产生多少种不同的颜色序列。（两个颜色序列不同当且仅当其长度不同或某一位置的羊毛颜色不同）

因为答案太大，所以输出答案对 $10^9+7$ 取模的结果。

（其实就是询问这个序列本质不同的子序列对 $10^9+7$ 取模的结果）

## 说明/提示

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（5 pts）$\ \ $：$n \le 20$，$q=1$。
- Subtask 2（15 pts）：$n \le 10^3$，$q=1$。
- Subtask 3（15 pts）：$\max\{m_i\} \le 20$，$q=1$。
- Subtask 4（25 pts）：$q=1$。
- Subtask 5（40 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,q \le 10^6$，$1 \le m_i \le n$。

#### 说明

Minecraft OI Round 2 B

- Maker：WAPER420
- Tester：灵空

$样例不是出题人写的！！！！！！！！$

## 样例 #1

### 输入

```
10 6
1 1 4 5 1 4```

### 输出

```
11
11
833
944
11
833```

## 样例 #2

### 输入

```
1000000 1
114514```

### 输出

```
945636198```

# AI分析结果


### 💡 洛语云笺的C++算法解析：「Build Battle 建筑大师」深度学习指南

#### 题目解读与策略初探
**✨ 核心挑战**：在循环序列中高效计算本质不同子序列的数量（模 $10^9+7$），需处理 $n,q \leq 10^6$ 的大规模数据。  
**✨ 核心算法标签**：动态规划(DP) → 组合数学  

**🔍 算法侦探：题目中的关键线索**  
1. **线索1（问题目标）**：要求本质不同子序列数量（带模），是经典的子序列计数问题，通常需用DP或组合数学优化。  
2. **线索2（问题特性）**：序列呈周期性循环（每 $m$ 个元素重复），暗示转移方程存在规律性简化可能。  
3. **线索3（数据规模）**：$n,q \leq 10^6$ 要求 $O(n \log n)$ 算法，暴力 $O(2^n)$ 和朴素DP $O(nm)$ 均不可行。  

**🧠 思维链构建：从线索到策略**  
> "结合线索：  
> 1. **线索1**指向DP/组合计数，但需处理序列循环特性；  
> 2. **线索2**发现循环性质可推导出转移方程 $f_i = 2f_{i-1} - f_{i-m-1}$；  
> 3. **线索3**要求高效算法，需将DP转化为组合问题——通过路径计数模型（走1步乘2 vs 走 $m+1$ 步取负），用调和级数枚举优化至 $O(n \log n)$。  
> **结论**：**组合数学**是打开本题的钥匙，如同将循环序列拆解为齿轮组，通过枚举跳跃次数精准计数！"

---

### 2. 精选优质题解参考
**题解一：w4p3r（16赞）**  
* **点评**：完整覆盖从暴力到满分的优化路径，清晰解释DP方程转化为组合模型（$ans=\sum (-1)^i \cdot 2^{n-i(m+1)} \cdot \binom{\text{steps}}{i}$），代码简洁高效（预处理阶乘+快速幂）。亮点在于组合意义的直观比喻（“路径行走决策”），实践价值极高。  

**题解二：gghack_Nythix（3赞）**  
* **点评**：独立推导出相同组合公式，强调问题转化思维（DP→路径计数），详解转移方程 $f_i=2f_{i-1}-f_{i-m-1}$ 的由来。代码包含详细注释，适合初学者理解组合数与序列周期的关联性。  

**题解三：Svemit（0赞）**  
* **点评**：给出标准DP方程 $f_i=2f_{i-1}-f_{lst_{a_i}-1}$ 并指出 $lst_{a_i}=i-m$ 的周期性，代码使用Modint模板提升可读性。亮点在于简洁的公式证明，适合进阶学习者。  

---

### 3. 解题策略深度剖析
**🎯 核心难点与关键步骤**  
1. **难点1：利用循环性质简化DP方程**  
   * **分析**：序列 $1,2,...,m,1,2,...$ 中 $a_i$ 的上次出现位置恒为 $i-m$（$i>m$），推导出 **$f_i = 2f_{i-1} - f_{i-m-1}$**（选 $i$ 时需减去重复方案）。  
   * 💡 **学习笔记**：**周期序列的性质是优化关键**，将无序匹配转化为固定偏移量计算。  
2. **难点2：转化组合模型优化复杂度**  
   * **分析**：将DP方程视为路径计数：  
     - **操作1**：走1步，权值 $\times 2$（对应 $f_i = 2f_{i-1}$）  
     - **操作2**：走 $m+1$ 步，权值 $\times (-1)$（对应 $-f_{i-m-1}$）  
     枚举操作2的次数 $i$，则总方案数为 $\sum_{i=0}^{\lfloor n/(m+1) \rfloor} (-1)^i \cdot 2^{n-i(m+1)} \cdot \binom{n-i(m+1)+i}{i}$。  
   * 💡 **学习笔记**：**组合意义转化是突破点**，将递推转化为显式公式，避免DP的链式依赖。  
3. **难点3：高效计算组合数**  
   * **分析**：预处理阶乘 $fac[i]$ 和逆元 $inv[i]$，$O(1)$ 计算 $\binom{n}{k} = fac[n] \cdot inv[k] \cdot inv[n-k]$。  
   * 💡 **学习笔记**：**预处理是处理大组合数的核心技巧**，空间换时间思想的典型应用。  

**✨ 解题技巧总结**  
- **技巧1：周期特性捕捉**：循环序列中重复元素的固定偏移量是简化方程的“题眼”。  
- **技巧2：组合模型转化**：将DP状态转移转化为路径操作决策（乘2/取负），枚举操作次数而非状态维度。  
- **技巧3：调和级数枚举**：对每个 $m$ 枚举 $i \in [0, n/(m+1)]$，总复杂度 $O(n \log n)$（$\sum_{m=1}^n \frac{n}{m} \approx n \ln n$）。  

**⚔️ 策略竞技场：解法对比**  
| 策略                | 核心思想                          | 优点                      | 缺点                          | 得分预期 |  
|---------------------|-----------------------------------|---------------------------|-------------------------------|----------|  
| **暴力枚举+哈希**   | 枚举所有子序列，哈希去重          | 思路简单                  | $O(2^n)$ 超时                | 5分      |  
| **DP+next数组**     | 记录上次出现位置避免重复          | 通用性强                  | $O(nm)$ 在 $m$ 大时超时      | 35分     |  
| **DP+循环优化**     | $f_i=2f_{i-1}-f_{i-m-1}$         | $O(n)$ 单次               | $q$ 次询问时 $O(qn)$ 超时    | 60分     |  
| **组合计数+枚举**   | 路径决策模型，调和级数枚举        | $O(n \log n)$ 处理所有 $m$ | 需数学推导                   | 100分    |  

**✨ 优化之旅：从暴力到组合魔法**  
> 起点：暴力枚举所有 $2^n$ 子序列（TLE）→ 发现周期性质推出DP方程 $f_i=2f_{i-1}-f_{i-m-1}$（$O(n)$ 单次）→ 识别操作本质（走1步乘2 vs 走 $m+1$ 步取负）→ 组合枚举跳跃次数，调和级数优化通关！  
> 💡 **策略总结**：“**化链为点**是本题精髓——将DP的状态转移链拆解为独立操作决策，通过组合数直接拼装答案！”

---

### 4. C++核心代码赏析  
**通用核心实现（综合题解）**  
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6 + 10, mod = 1e9 + 7;
int n, q, fac[N], inv[N], pow2[N], ans[N];
bool vis[N];

int ksm(int a, int b) { // 快速幂
    int res = 1;
    for (; b; b >>= 1, a = 1LL * a * a % mod) 
        if (b & 1) res = 1LL * res * a % mod;
    return res;
}

void init() { // 预处理阶乘和2的幂
    fac[0] = pow2[0] = 1;
    for (int i = 1; i < N; ++i) {
        fac[i] = 1LL * fac[i - 1] * i % mod;
        pow2[i] = (pow2[i - 1] << 1) % mod;
    }
    inv[N - 1] = ksm(fac[N - 1], mod - 2); // 逆元
    for (int i = N - 2; i >= 0; --i) 
        inv[i] = 1LL * inv[i + 1] * (i + 1) % mod;
}

int C(int n, int m) { // 组合数
    if (n < m || m < 0) return 0;
    return 1LL * fac[n] * inv[m] % mod * inv[n - m] % mod;
}

int solve(int m) {
    if (vis[m]) return ans[m];
    long long res = 0;
    for (int i = 0; i <= n / (m + 1); ++i) { // 枚举跳跃次数
        int rest = n - i * (m + 1);          // 剩余步数
        long long term = 1LL * pow2[rest] * C(rest + i, i) % mod;
        res = (res + (i % 2 ? mod - term : term)) % mod; // (-1)^i 修正
    }
    vis[m] = 1;
    return ans[m] = res;
}

int main() {
    init();
    scanf("%d%d", &n, &q);
    while (q--) {
        int m; scanf("%d", &m);
        printf("%d\n", solve(m));
    }
    return 0;
}
```
**代码解读概要**：  
1. **预处理**：$fac$（阶乘）、$inv$（逆元）、$pow2$（2的幂）提前计算，$O(1)$ 支持组合数与幂运算。  
2. **组合计算**：`solve(m)` 枚举跳跃次数 $i$，累加 $(-1)^i \cdot 2^{\text{rest}} \cdot \binom{\text{rest}+i}{i}$。  
3. **记忆化**：`vis[m]` 缓存结果，避免重复计算。  

**题解一（w4p3r）片段赏析**  
```cpp
int solve(int m) {
    if (vis[m]) return ans[m];
    int res = 0;
    for (int i = 0; i <= n/(m+1); i++) {
        int cnt = 1LL * two[n-(m+1)*i] * C(n-(m+1)*i+i, i) % mod;
        if (i & 1) res = (res - cnt + mod) % mod; // (-1)^i 处理
        else res = (res + cnt) % mod;
    }
    return ans[m] = res;
}
```
**亮点**：简洁的符号处理（`i & 1` 判断奇偶）和防负数的 `+mod` 技巧。  
**学习笔记**：**枚举循环边界 `i <= n/(m+1)` 是调和级数优化的核心**。  

---

### 5. 算法可视化：像素动画演示  
**🎮 主题**：像素探险家在循环序列中收集宝石（颜色序列），穿越时空门（跳跃决策）！  
**🖼️ 场景设计**：  
- **像素网格**：序列位置为方格，颜色用不同像素色块（1~m循环）。  
- **角色**：8-bit小人从起点出发，手持计数器（初始值1）。  
- **时空门**：红色门（走 $m+1$ 步，计数器 $\times (-1)$） vs 蓝色门（走1步，计数器 $\times 2$）。  

**⚙️ 动画流程**：  
1. **初始化**：网格按 $1,2,...,m,1,2,...$ 循环着色，小人位于位置0，计数器=1。  
2. **决策演示**：  
   - **选项A（蓝门）**：小人移动1格，计数器 $\times 2$（显示 `当前值×2`），伴随清脆“叮”声。  
   - **选项B（红门）**：小人跳跃 $m+1$ 格，计数器 $\times (-1)$（数值变红），伴随“嗡”声。  
3. **路径记录**：轨迹线条显示历史路径，右侧面板更新组合数 $\binom{\text{steps}}{i}$ 和当前贡献值。  
4. **终点庆祝**：到达位置 $n$ 时，宝石闪烁，答案累加器更新，播放胜利音效（8-bit风格）。  

**🎛️ 交互控制**：  
- **单步执行**：逐步观察决策影响。  
- **自动演示**：AI自动选择路径（类似贪吃蛇AI），速度滑块调节。  
- **关卡模式**：每完成一个 $m$ 的计算视为一关，解锁新颜色序列（成就系统）。  

**💡 设计意义**：**像素跳跃动画将抽象的“走1步 vs 跳 $m+1$ 步”具象化**，计数器变化强化组合贡献的直观理解！  

---

### 6. 拓展练习与相似问题  
**🧩 通用技巧迁移**：  
- **周期序列性质**：适用于字符串循环节类问题（如 CodeForces edu 57 E）。  
- **组合模型转化**：路径决策思想可用于计数类DP优化（如背包问题）。  
- **调和级数枚举**：处理“整除分块”型问题（如洛谷 P2261）。  

**🏁 洛谷练习推荐**：  
1. **P3312 [SDOI2014] 数表**  
   → *推荐理由*：强化“调和级数枚举+预处理”技巧，需结合莫比乌斯反演。  
2. **P1754 球迷购票问题**  
   → *推荐理由*：类似路径决策模型（卡特兰数变形），巩固组合计数思维。  
3. **P2606 [ZJOI2010]排列计数**  
   → *推荐理由*：序列性质与组合数学的结合，训练问题转化能力。  

---

### 7. 学习心得与经验分享  
**💎 来自题解作者的洞见**：  
> **w4p3r**：*“有经验的OIer应直接看出组合模型——本题的关键在于跳出DP链式思维，将操作解耦为独立事件。”*  
> **gghack_Nythix**：*“独立推导比套模板更重要：我通过手推小样例 $n=3,m=2$ 发现了路径决策规律。”*  

**🔥 洛语云笺点评**：  
> 调试技巧：当公式WA时，优先验证边界（如 $m=1$ 时应输出 $2^n$）；  
> 思维训练：尝试用两种方法推导同一结论（如DP方程 vs 组合意义），可大幅提升洞察力！  

---  
**✨ 结语**：循环序列的本质是“规律的重复”，而算法的本质是“在重复中发现规律”。掌握组合转化与调和级数优化，你也能在竞赛中优雅地“建筑”满分解法！🚀

---
处理用时：191.50秒
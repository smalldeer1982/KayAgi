# 题目信息

# [NOI2016] 优秀的拆分

## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。

## 说明/提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |

## 样例 #1

### 输入

```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba
```

### 输出

```
3
5
4
7
```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：[NOI2016] 优秀的拆分 深入学习指南 💡

> 今天我们要拆解的是 NOI2016 的“优秀的拆分”。  
> 这道题像一串密码锁，表面上是找「AABB」子串，**本质**却是在**大规模文本**里**高效枚举所有「AA」结构**。  
> 我们将带你从暴力思路一步步走向 **调和级数 + 后缀数组** 的优雅解法，并送上像素动画，让你“看见”算法在字符串上跳舞！

---

## 1. 题目解读与策略初探

✨ **核心挑战**  
在长度 ≤ 3×10⁴ 的字符串里，统计**所有子串**中形如 **AABB**（A、B 非空）的拆分方案总数。  
不同位置出现相同子串算多次，允许 A = B。

✨ **核心算法标签**  
- 字符串 + 后缀数组（SA）/ 哈希  
- 调和级数枚举  
- 差分数组区间加  

🗣️ **初步分析**  
1. **暴力思路**：枚举子串 [l,r]，再枚举断点 i 把子串切成 AABB。  
   - 时间 O(n³) → 只能拿 0~10 分。  
2. **优化思路**：发现 **AABB = AA + BB**，只需统计  
   - f[i]：以 i **结尾** 的 AA 子串个数  
   - g[i]：以 i **开头** 的 AA 子串个数  
   答案即为 Σ f[i]·g[i+1]。  
3. **关键问题**：如何 **O(n log n)** 求 f、g？  
   - 调和级数 + 后缀数组 / 哈希 + 差分区间加。

> 把“找 AABB”转成“找 AA”再拼接，就像把拼图拆成两块再组合，一下子把复杂度降了一维！

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 |
|---|---|
| **线索1：目标拆分** | AABB 可拆成 AA 与 BB，只需分别求出 AA 的“结尾计数”和“开头计数”再相乘。 |
| **线索2：AA 结构** | AA 即两个相邻且完全相同的子串，可用 **最长公共前缀 (LCP)** 与 **最长公共后缀 (LCS)** 刻画。 |
| **线索3：数据规模** | n ≤ 3×10⁴，O(n²) 哈希可拿 95 分，O(n log n) SA 才能稳拿 100 分。 |

### 🧠 思维链构建：从线索到策略

> 1. 目标 Σ AABB → 拆成 Σ f[i]·g[i+1]。  
> 2. 求 f[i]：枚举 AA 长度 len，把字符串每 len 设关键点，用 LCP+LCS 判断是否存在 AA 并统计区间。  
> 3. 复杂度：关键点总个数 = n/1 + n/2 + … = O(n log n)，配合 O(1) LCP/LCS 查询即可。  
> 4. 结论：**后缀数组 + 调和级数 + 差分** 是通往 100 分的钥匙！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **Gypsophila** (赞169) | 首次完整提出「关键点 + LCP/LCS + 差分」思路，并给出详细几何图示。 | 思路清晰，图示直观，是理解正解的最佳入口。 |
| **何俞均** (赞41) | 代码简洁，SA 模板稳健；注释详细，适合直接上手。 | “抄作业”首选，但务必先理解思路。 |
| **George1123** (赞32) | 用通俗语言解释关键点与区间加原理，附完整代码。 | 语言风趣，比喻贴切，适合初学者。 |
| **bztMinamoto** (赞24) | 用哈希暴力拿 95 分，强调“能 A 就行”，降低心理压力。 | 适合先拿部分分再升级。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 & 实现技巧 | 💡 学习笔记 |
|---|---|---|
| **1. 预处理 LCP & LCS** | 用 **后缀数组** 对原串和反串各跑一次，建 ST 表支持 O(1) 查询。 | 正反各一次 SA 是字符串题常见套路。 |
| **2. 枚举长度 len** | 对每个 len，每隔 len 设关键点 i, j=i+len。 | 总关键点数 = n/1 + n/2 + … = O(n log n)。 |
| **3. 区间统计 AA** | 若 LCP(i,j)+LCS(i-1,j-1) ≥ len，则存在一段区间可形成 AA；用 **差分数组** 区间加 1。 | 差分可将区间加 O(len) 变为 O(1)。 |
| **4. 求答案** | 对差分数组求前缀和得 f、g，再 Σ f[i]·g[i+1]。 | 记得开 `long long`。 |

### ✨ 解题技巧总结
- **问题转化**：把复杂模式拆成简单模式再拼接。  
- **调和级数**：枚举因子的经典套路。  
- **差分优化**：区间加/减的利器。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| 暴力 O(n³) | 枚举子串+断点 | 思路直观 | 超时 | 0~10 |
| 哈希 O(n²) | 枚举 len + 哈希判相等 | 代码短 | 被卡哈希 | 95 |
| SA 调和级数 O(n log n) | 关键点 + LCP/LCS + 差分 | 稳过 | 模板较长 | 100 |
| Runs 定理 | 用 runs 统计平方串 | 理论优美 | 实现复杂 | 100 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
> 综合 Gypsophila 与何俞均的代码，给出 **最简洁** 的 **SA + 差分** 版本。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3e4 + 5;
int n, lg[N], f[N], g[N];
struct SA {
    char s[N];
    int sa[N], rk[N], ht[N], st[16][N];
    void build() {
        // 基数排序 + 倍增求 SA
        // 略去模板，详见完整代码
    }
    void buildST() {
        for (int i = 1; i <= n; ++i) st[0][i] = ht[i];
        for (int j = 1; j < 16; ++j)
            for (int i = 1; i + (1 << j) - 1 <= n; ++i)
                st[j][i] = min(st[j - 1][i], st[j - 1][i + (1 << (j - 1))]);
    }
    int lcp(int x, int y) {
        if (x == y) return n - x + 1;
        x = rk[x], y = rk[y]; if (x > y) swap(x, y); ++x;
        int k = lg[y - x + 1];
        return min(st[k][x], st[k][y - (1 << k) + 1]);
    }
} A, B;

void solve() {
    scanf("%s", A.s + 1); n = strlen(A.s + 1);
    A.build(); A.buildST();
    for (int i = 1; i <= n; ++i) B.s[i] = A.s[n - i + 1];
    B.build(); B.buildST();
    fill(f, f + n + 2, 0); fill(g, g + n + 2, 0);
    for (int len = 1; len <= n / 2; ++len)
        for (int i = len, j = i + len; j <= n; i += len, j += len) {
            int lcp = min(A.lcp(i, j), len);
            int lcs = min(B.lcp(n - i + 2, n - j + 2), len - 1);
            if (lcp + lcs < len) continue;
            int cnt = lcp + lcs - len + 1;
            // 结尾在 [j+lcp-cnt, j+lcp-1]
            f[j + lcp - cnt]++, f[j + lcp]--;
            // 开头在 [i-lcs, i-lcs+cnt-1]
            g[i - lcs]++, g[i - lcs + cnt]--;
        }
    for (int i = 1; i <= n; ++i) f[i] += f[i - 1], g[i] += g[i - 1];
    long long ans = 0;
    for (int i = 1; i < n; ++i) ans += 1LL * f[i] * g[i + 1];
    printf("%lld\n", ans);
}

int main() {
    for (int i = 2; i < N; ++i) lg[i] = lg[i >> 1] + 1;
    int T; scanf("%d", &T);
    while (T--) solve();
}
```

---

## 5. 算法可视化：像素动画演示

> 主题：**「像素侦探」在字符串上寻找 AA 宝藏**  
> 工具：HTML5 Canvas + 8-bit 音效

### 场景设计
- **像素网格**：每个格子表示字符，颜色 = 字符种类。  
- **关键点**：每 len 步出现一个 **闪烁金币**；AA 出现时，金币连线高亮。  
- **LCP/LCS**：用 **光束** 向后/前扫描，长度实时显示。  
- **差分区间**：被覆盖的格子会 **+1 像素星星**。

### 交互面板
- 步进 / 自动播放 / 调速滑块  
- 音效：  
  - “叮”——找到一段 AA  
  - “哒哒”——差分数组 +1  
  - “胜利号角”——统计完所有答案

### 关键帧示意
1. 初始化网格 + 金币关键点  
2. 枚举 len=3，金币 i、j 出现  
3. 光束 LCP、LCS 扫描 → 显示长度  
4. 若 LCP+LCS≥len，区间格子 + 星星  
5. 差分数组前缀和 → 统计 f[i]·g[i+1]  
6. 最终答案以像素烟花庆祝！

---

## 6. 拓展练习与相似问题思考

| 通用套路迁移 | 场景示例 |
|---|---|
| 调和级数 + 差分 | 统计所有长度 ≤ k 的“ABAB”子串 |
| 后缀数组 + 区间加 | 求所有回文子串出现次数 |
| LCP/LCS 技巧 | 求两串最长公共子串 |

### 洛谷推荐
- **P3809** 后缀数组模板  
- **P4248** [AHOI2013] 差异 —— 练 LCP  
- **P1368** [NOI2014] 动物园 —— 类似调和级数  
- **P1117** 本题原题，尝试不同写法（哈希、SAM）

---

## 7. 学习心得与经验分享

> **来自 Gypsophila 的调试心得**：  
> “我第一次写 SA 时把 `ht` 数组从 0 开始存，结果 LCP 查询全错。  
> 后来把 `ht[i]` 定义为 `suffix(sa[i])` 与 `suffix(sa[i-1])` 的 LCP，  
> 并在 ST 表查询时 `l++`，才通过。  
> 记住：**下标约定一致** 是字符串题的常见坑！”

---

<conclusion>
恭喜你完成这场「优秀拆分」之旅！  
从暴力枚举到调和级数，我们见证了如何把 O(n³) 的噩梦化作 O(n log n) 的优雅。  
下次遇到“统计某种子串”时，记得先**拆模式、再调级数、后差分**，  
让字符串在你的像素舞台上翩翩起舞！
</conclusion>
```

---
处理用时：75.13秒
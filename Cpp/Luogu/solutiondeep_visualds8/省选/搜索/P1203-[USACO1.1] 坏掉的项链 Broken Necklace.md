# 题目信息

# [USACO1.1] 坏掉的项链 Broken Necklace

## 题目描述

你有一条由 $n$ 个红色的，白色的，或蓝色的珠子组成的项链，珠子是随意安排的。 这里是 $n=29$ 的两个例子:

![](https://cdn.luogu.com.cn/upload/image_hosting/i7imvc0g.png) 

第一和第二个珠子在图片中已经被作记号。

图片 A 中的项链可以用下面的字符串表示：

`brbrrrbbbrrrrrbrrbbrbbbbrrrrb`

假如你要在一些点打破项链，展开成一条直线，然后从一端开始收集同颜色的珠子直到你遇到一个不同的颜色珠子，在另一端做同样的事(颜色可能与在这之前收集的不同)。 确定应该在哪里打破项链来收集到最大数目的珠子。

例如，在图片 A 中的项链中，在珠子 $9$ 和珠子 $10$ 或珠子 $24$ 和珠子 $25$ 之间打断项链可以收集到 $8$ 个珠子。

白色珠子什么意思?

在一些项链中还包括白色的珠子(如图片B) 所示。

当收集珠子的时候，一个被遇到的白色珠子可以被当做红色也可以被当做蓝色。

表现含有白珠项链的字符串将会包括三个符号 `r`，`b`，`w` 。

写一个程序来确定从一条被给出的项链可以收集到的珠子最大数目。

## 说明/提示

【数据范围】  
对于 $100\%$ 的数据，$3\le n \le 350$

题目翻译来自NOCOW。

USACO Training Section 1.1

## 样例 #1

### 输入

```
29 
wwwbbrwrbrbrrbrbrwrwwrbwrwrrb
```

### 输出

```
11```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[USACO1.1] 坏掉的项链 深入学习指南 💡

> 今天我们来一起分析“坏掉的项链”这道C++编程题。它看似只是一条颜色各异的珠子项链，却蕴含着“环形区间最值”这一经典模型。让我们像侦探一样，从题目中寻找线索，并在多种解题道路中权衡选择，最终找到最优雅、最高效的策略！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：把环形项链“剪开”成一条直线后，从剪开处 **向左、向右** 各收集一段 **连续同色（或全白可视为同色）珠子**，求这两段长度之和的最大值。  
✨ **核心算法标签**：环形区间处理、线性扫描 / 双指针、暴力枚举、预处理前后缀数组

🗣️ **初步分析**：
- 最直接的思路是 **枚举每一个“剪开点”**，把它当作直线左端，然后分别往左、往右扫描，统计同色长度。  
- 但“环形”带来麻烦：下标会越界！常见技巧是 **把原串复制成两份或三份**，把环“拉直”成链，这样任意区间都能在原串长度范围内表示。  
- 题目规模 `n ≤ 350`，**O(n²)** 的暴力枚举完全可以接受，但仍有更简洁的 **O(n)** 线性扫描技巧。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现与分析 |
| --- | --- |
| **1. 环形区间** | 关键词“项链”“环形”暗示我们需要把环拆成链，常见做法：字符串倍增。 |
| **2. 连续同色 + 白色万能** | 白色珠子可视为任意颜色，等同于“通配符”，扫描时需要特殊处理。 |
| **3. 数据范围 350** | 暗示 `O(n²)` 暴力可行，但仍鼓励寻找 `O(n)` 线性算法，培养思维深度。 |

### 🧠 思维链构建：从线索到策略
> 1. 环形 → 字符串复制两份（或三份），把任意区间映射到 `[i, i+n-1]`。  
> 2. 枚举剪开点 → 对每个 `i`，计算 `left(i)` 与 `right(i+1)` 两段长度之和。  
> 3. 白色珠子 → 扫描时遇到 `w` 先继续延伸，遇到第一个非白颜色后再决定“归属”。  
> 4. 复杂度 → 双指针/前后缀预处理可把两次扫描压缩到 **O(n)**。

---

## 2. 精选优质题解参考

> 我从思路清晰度、代码规范性、算法有效性、启发性四个维度，为大家筛选出 ≥4 星的高赞题解，并提炼核心亮点。

| 题解作者 | 亮点速览 | 推荐语（洛语云笺口吻） |
| --- | --- | --- |
| **w_y_c** | 简洁字符串复制+双指针扫描；巧妙处理 `w` 的归属；代码仅 30 行。 | “用最短的代码，完成最复杂的环形区间处理，值得收藏！” |
| **青衫白叙** | 提供 **O(n)** 线性扫描模板；变量 `l, r, w` 含义清晰，一行状态转移。 | “一行代码解决状态转移，是线性算法的经典范式。” |
| **田阙西** | 前后缀数组 `lR, lB, rR, rB` 预处理，**O(n)** 计算区间和。 | “预处理思想让枚举区间变得优雅，值得学习！” |
| **Dvelpro** | 暴力双指针，思路直白，适合入门理解。 | “暴力也能拿满分，先保证正确，再谈优化。” |
| **key_rA9** | 链表模拟环形结构，**不复制字符串**，空间友好。 | “用链表解决环形问题，锻炼数据结构基本功。” |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：线性扫描）

| 关键点 | 分析 | 学习笔记 |
| --- | --- | --- |
| **1. 环转链** | 把原串 `s` 复制成 `s+s`，任意区间 `[i, i+n-1]` 对应剪开点 `i%n`。 | “环形转链是处理环问题的万能钥匙。” |
| **2. 双指针扫描** | 对每个 `i`，用双指针 `l, r` 分别向左、向右延伸，遇到 `w` 继续，遇到不同色停止。 | “双指针让两次扫描合并为一次，复杂度降至 O(n)。” |
| **3. 白色归属** | 遇到 `w` 先记录连续 `w` 长度 `w`，再决定归属左段或右段。 | “白色珠子是‘自由人’，归属哪边不影响最终长度。” |

### ✨ 解题技巧总结
- **技巧A：字符串复制**  
  把 `s` 复制成 `s+s`，避免环形下标越界，是处理环形问题的通用技巧。
- **技巧B：双指针扫描**  
  用双指针 `l, r` 分别向左、向右延伸，遇到 `w` 继续，遇到不同色停止，一次扫描完成。
- **技巧C：前后缀预处理**  
  预处理 `left[i]` 与 `right[i]` 数组，区间和直接相加，复杂度 O(n)。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- | --- |
| **暴力双指针** | 复制字符串，枚举剪开点，双指针扫描 | 思路直观，代码短 | O(n²) | n ≤ 350，完全可行 |
| **前后缀预处理** | 预处理左右最长同色长度，区间和相加 | O(n) 优雅 | 需要额外数组 | n 较大时优势显著 |
| **链表模拟** | 用链表维护环形结构，不复制字符串 | 空间友好 | 代码稍长 | 锻炼数据结构 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（线性扫描版）

> 综合青衫白叙、田阙西等优质题解，提炼出最简洁的 O(n) 实现。

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    string s;
    cin >> n >> s;
    s = s + s;  // 环转链
    int l = 0, r = 0, w = 0, ans = 0;
    char c = ' ';  // 当前段颜色
    for (int i = 0; i < 2 * n; ++i) {
        if (s[i] == 'w') {
            ++w;
            ++r;
        } else if (s[i] == c) {
            w = 0;
            ++r;
        } else {
            ans = max(ans, l + r);
            l = r - w;  // 左段长度 = 右段 - 连续w
            r = w + 1;  // 右段重置
            w = 0;
            c = s[i];
        }
    }
    ans = max(ans, l + r);
    cout << min(ans, n) << endl;
    return 0;
}
```

### 精选题解代码片段赏析

#### 1. w_y_c 的简洁暴力
```cpp
// 复制三份，枚举断点，双指针扫描
a = a + a + a;
for (int i = n; i < 2 * n; ++i) {
    if (a[i] == a[i + 1]) continue;
    ans = max(ans, f(i));
}
```
- **亮点**：三份字符串避免越界，`f(i)` 双指针计算左右长度，代码极短。

#### 2. 田阙西的前后缀预处理
```cpp
// 预处理左右最长同色长度
for (int i = 1; i <= 2 * n; ++i) {
    if (c[i - 1] == 'b') lb[i] = lb[i - 1] + 1;
    else if (c[i - 1] == 'r') lr[i] = lr[i - 1] + 1;
    else lb[i] = lb[i - 1] + 1, lr[i] = lr[i - 1] + 1;
}
```
- **亮点**：`lb[i]` 表示从 `i` 向左最长蓝色（含白色），区间和直接相加。

---

## 5. 算法可视化：像素动画演示

> 用 8 位像素风，展示线性扫描如何“吃掉”同色珠子！

- **场景**：像素化的项链，珠子为红/蓝/白色方块。
- **动画**：
  1. 初始：项链首尾相接，像素风闪烁。
  2. 枚举断点：像素光标停在 `i`，左侧显示“←左段”，右侧显示“右段→”。
  3. 扫描：双指针 `l, r` 以像素箭头向左、向右移动，遇到白色珠子闪烁“万能色”，遇到不同色停止并变红提示。
  4. 结果：当前 `l + r` 以像素数字显示，动画跳转到下一个断点。
- **交互**：步进/自动播放按钮，像素音效“叮”提示扫描完成。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **环形区间最值**：如“环形数组最大子段和”、“环形加油站”。
- **双指针扫描**：如“最长连续相同元素”、“滑动窗口”。
- **前后缀预处理**：如“区间最大/最小值”、“区间和”。

### 洛谷推荐练习
1. **P5708 环形最大子段和**  
   *推荐理由*：巩固环形区间处理，学习前后缀 + 单调队列优化。
2. **P2678 跳石头**  
   *推荐理由*：双指针扫描的经典应用，训练“滑动窗口”思想。
3. **P1244 青蛙过河**  
   *推荐理由*：环形区间 + 动态规划，提升建模能力。

---

## 7. 学习心得与经验分享（来自题解作者）

- **田阙西**：“数组开两倍！否则越界会踩坑，前车之鉴！”  
  *洛语云笺点评*：环形问题中，边界处理是高频错误，提前复制字符串是防坑良策。

- **青衫白叙**：“一行状态转移，浓缩了线性扫描的精华。”  
  *洛语云笺点评*：把复杂逻辑压缩成一行，是高手“化繁为简”的体现，值得模仿。

---

<conclusion>
> 从“暴力枚举”到“线性扫描”，我们见证了环形区间问题的优雅解决。记住：  
> 1. 环转链是第一步；  
> 2. 双指针让扫描更高效；  
> 3. 白色珠子是“自由人”，归属哪边不影响最优。  
> 下次遇到环形区间，不妨先复制字符串，再让双指针“跑一圈”！  
> 期待你在下一道题中，继续用“侦探思维”拆解难题！💪
</conclusion>

---
处理用时：65.22秒
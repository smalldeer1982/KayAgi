# 题目信息

# [NOI2008] 假面舞会

## 题目描述

一年一度的假面舞会又开始了，栋栋也兴致勃勃的参加了今年的舞会。

今年的面具都是主办方特别定制的。每个参加舞会的人都可以在入场时选择一个自己喜欢的面具。每个面具都有一个编号，主办方会把此编号告诉拿该面具的人。

为了使舞会更有神秘感，主办方把面具分为 $k$（$k\geq 3$）类，并使用特殊的技术将每个面具的编号标在了面具上，只有戴第 $i$ 类面具的人才能看到戴第 $i+1$  类面具的人的编号，戴第 $k$ 类面具的人能看到戴第 $1$ 类面具的人的编号。

参加舞会的人并不知道有多少类面具，但是栋栋对此却特别好奇，他想自己算出有多少类面具，于是他开始在人群中收集信息。

栋栋收集的信息都是戴第几号面具的人看到了第几号面具的编号。如戴第 $2$ 号面具的人看到了第 $5$ 号面具的编号。栋栋自己也会看到一些编号，他也会根据自己的面具编号把信息补充进去。

由于并不是每个人都能记住自己所看到的全部编号，因此，栋栋收集的信息不能保证其完整性。现在请你计算，按照栋栋目前得到的信息，至多和至少有多少类面具。由于主办方已经声明了 $k\geq 3$，所以你必须将这条信息也考虑进去。


## 说明/提示

- 对于 $50\%$ 的数据，满足 $n \leq 300$，$m \leq 10^3$；
- 对于 $100\%$ 的数据，满足 $n \leq 10^5$，$m \leq 10^6$。


## 样例 #1

### 输入

```
6 5
1 2
2 3
3 4
4 1
3 5```

### 输出

```
4 4
```

## 样例 #2

### 输入

```
3 3
1 2
2 1
2 3```

### 输出

```
-1 -1
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：NOI2008 假面舞会 深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“面具编号”与“谁看见谁”构成了一张**有向图**。  
我们需要通过这张图推断**面具类别总数 k**（k≥3）的**最大可能值**和**最小可能值**。  
关键在于：  
1. 如果图中有**环**，则 k 必须是**所有环长度的公约数**。  
2. 如果图中**无环**，则 k 的最大值是**所有连通块最长链长度之和**，最小值为 3。  

✨ **核心算法标签**：`图论`、`环检测`、`最长链`、`gcd`  

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **问题目标** | 求“面具类别数”的最大/最小值，且必须≥3。 |
| **问题约束** | 只有第 i 类面具能看见第 i+1 类（循环）。这意味着**“看见关系”形成有向边**，且**环长 = 类别数的倍数**。 |
| **数据规模** | n≤1e5，m≤1e6。暗示我们需要**线性或接近线性**的算法（O(n+m)）。 |
| **关键观察** | 若存在环 `a→b→c→a`，则类别数 k 必须满足 `3 ≡ 0 (mod k)`，即 k 是 3 的约数？不对！实际是**环长必须是 k 的倍数**。因此 k 必须是**所有环长的公约数**。 |

### 🧠 思维链构建：从线索到策略

> 侦探笔记整理完毕，现在让我们像拼图一样组合线索：  
> 1. **“看见关系”是有向边**：u→v 表示“u 看见 v”，即 u 的类别 = v 的类别 - 1（模 k）。  
> 2. **环意味着什么？** 若存在环 `a→b→c→a`，则 `class_a ≡ class_b - 1 ≡ class_c - 2 ≡ class_a - 3 (mod k)`。因此 `3 ≡ 0 (mod k)`，即 k 必须是 3 的约数？不对！实际是**环长 L 必须满足 L ≡ 0 (mod k)**。因此 k 必须是**所有环长的公约数**。  
> 3. **无环怎么办？** 无环时，类别可以线性排列（如 1→2→3→...），因此最大类别数就是**最长链长度**，最小为 3。  
> 4. **如何高效实现？** 使用 **DFS/BFS** 遍历每个连通块，同时记录“类别偏移量”（类似带权并查集）。遇到环时，用 **gcd** 合并环长；无环时，记录最长链。  

---

## 2. 精选优质题解参考

### 题解一：StudyingFather（赞：31）
**点评**：  
- **思路清晰**：通过正反边（权值 +1/-1）将“类别差”转化为**边权**，用 DFS 遍历连通块。  
- **代码规范**：变量命名直观（`dis` 存储类别偏移量，`ans` 存储环长 gcd）。  
- **算法高效**：O(n+m) 复杂度，完美契合数据范围。  
- **亮点**：用 `gcd` 合并环长，简洁优雅。

### 题解二：water_tomato（赞：9）
**点评**：  
- **数学严谨**：详细证明了“正反边建图”的正确性，解释了为什么 `gcd(a, |b-c|) = gcd(a, a+b-c)`。  
- **代码可读性强**：使用链式前向星存图，逻辑清晰。  
- **学习点**：如何优雅处理“环相交”的复杂情况。

### 题解三：1000001001wj（赞：6）
**点评**：  
- **调试经验宝贵**：作者分享了“重边处理”和“初始化细节”的踩坑经历（如 `cnt=1` 和 `head=-1` 的关联）。  
- **代码风格**：使用 `vector` 存图，适合初学者理解。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 正反边建图** | 对于每条 u→v 的有向边，额外添加 v→u 的边权为 -1。这样，任意路径的“类别差”可表示为边权和。 | 将“模 k”问题转化为**带权图路径差**问题。 |
| **2. 环长检测** | DFS 时，若遇到已访问节点 v，则环长为 `|dis[u] + w - dis[v]|`，用 gcd 合并所有环长。 | 无需显式找环，通过“偏移量差”自然得到环长。 |
| **3. 最长链计算** | 无环时，每个连通块的“最长链” = `max(dis) - min(dis) + 1`。 | 类似“树的直径”问题，可用 DFS/BFS 两次遍历。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举 k** | 枚举 k 从 3 到 n，检查是否满足所有环长是 k 的倍数。 | 思路直观 | O(n^2) 超时 | 小规模数据（n≤1000） |
| **正反边 + gcd** | 用带权图表示类别差，环长 = 路径差，gcd 合并。 | O(n+m) 高效 | 需理解数学证明 | 本题最优解 |
| **并查集扩展域** | 用并查集维护“类别差”关系，类似“食物链”问题。 | 代码简洁 | 思维难度高 | 适合熟练者 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
vector<pair<int, int>> e[N]; // 邻接表：{v, w}
int dis[N], vis[N], ans, res;

int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }

void dfs(int u, int d) {
    if (dis[u]) { // 已访问，发现环
        ans = gcd(ans, abs(d - dis[u]));
        return;
    }
    dis[u] = d;
    vis[u] = 1;
    for (auto [v, w] : e[v]) dfs(v, d + w);
}

int main() {
    int n, m;
    cin >> n >> m;
    for (int i = 1; i <= m; i++) {
        int u, v;
        cin >> u >> v;
        e[u].emplace_back(v, 1);
        e[v].emplace_back(u, -1); // 反边
    }
    for (int i = 1; i <= n; i++) {
        if (!vis[i]) {
            int max_dis = -1e9, min_dis = 1e9;
            dfs(i, 1);
            // 计算最长链（无环时）
            for (int j = 1; j <= n; j++) {
                if (vis[j]) {
                    max_dis = max(max_dis, dis[j]);
                    min_dis = min(min_dis, dis[j]);
                }
            }
            res += max_dis - min_dis + 1;
        }
    }
    if (ans) {
        if (ans < 3) cout << "-1 -1\n";
        else {
            int min_k = 3;
            while (ans % min_k) min_k++;
            cout << ans << ' ' << min_k << '\n';
        }
    } else {
        if (res < 3) cout << "-1 -1\n";
        else cout << res << " 3\n";
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“像素侦探找环”**
- **场景**：8位像素风格的舞会大厅，面具是彩色方块，边是箭头。
- **交互**：
  1. 点击“开始”，DFS 从起点出发，路径高亮。
  2. 遇到环时，环闪烁红色，播放“叮”音效，显示环长。
  3. 无环时，最长链用绿色高亮，链长实时更新。
- **游戏化**：每找到一个环，获得“侦探徽章”一枚，累计 3 枚解锁“数学证明”彩蛋。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **带权图环检测**：适用于“模意义下约束”问题（如“食物链”、“NOI2017 奶酪”）。
- **最长链计算**：类似“树的直径”问题（如“P1099 树网的核”）。

### 洛谷推荐
1. **P2024 食物链**  
   *推荐理由*：同类“扩展域并查集”问题，巩固“模 k”约束建模。
2. **P2661 信息传递**  
   *推荐理由*：纯环检测问题，练习 DFS 找环。
3. **P1395 会议**  
   *推荐理由*：最长链 + 多源 BFS，拓展“无环图”处理技巧。

---

## 7. 学习心得与经验分享

> **来自 StudyingFather 的调试心得**：“最初忽略了 `gcd(0, x) = x` 的细节，导致无环时误输出 0。后来通过构造样例发现，必须特判 `ans=0` 的情况。”  
> **洛语云笺点评**：边界条件（如 gcd 的 0 值、k≥3）是此类题的常见陷阱，务必用极端数据测试！

---

<conclusion>
本次关于“假面舞会”的解析，我们学会了如何将“类别约束”转化为**带权图问题**，并通过**gcd**和**最长链**优雅解决。记住：复杂约束背后，往往藏着简洁的数学结构！
</conclusion>

---
处理用时：71.04秒
# 题目信息

# 埃及分数

## 题目描述

**来源：BIO 1997 Round 1 [Question 3](http://www.olympiad.org.uk/papers/1997/bio/bio97r1q3.html)**

在古埃及，人们使用单位分数的和（形如 $\dfrac{1}{a}$ 的，$a$ 是自然数）表示一切有理数。如：$\dfrac{2}{3} = \dfrac{1}{2} + \dfrac{1}{6}$，但不允许 $\dfrac{2}{3} = \dfrac{1}{3} + \dfrac{1}{3}$，因为加数中有相同的。对于一个分数 $\dfrac{a}{b}$，表示方法有很多种，但是哪种最好呢？首先，加数少的比加数多的好，其次，加数个数相同的，最小的分数越大越好。如：
$$
\begin{aligned}
\frac{19}{45} &= \frac{1}{3} + \frac{1}{12} + \frac{1}{180}\\
\frac{19}{45} &= \frac{1}{3} + \frac{1}{15} + \frac{1}{45}\\
\frac{19}{45} &= \frac{1}{3} + \frac{1}{18} + \frac{1}{30}\\
\frac{19}{45} &= \frac{1}{4} + \frac{1}{6} + \frac{1}{180}\\
\frac{19}{45} &= \frac{1}{5} + \frac{1}{6} + \frac{1}{18}\\
\end{aligned}
$$
最好的是最后一种，因为 $\dfrac{1}{18}$ 比 $\dfrac{1}{180}, \dfrac{1}{45}, \dfrac{1}{30}$ 都大。  
注意，可能有多个最优解。如：
$$
\begin{aligned}
\frac{59}{211} &= \frac{1}{4} + \frac{1}{36} + \frac{1}{633} + \frac{1}{3798}\\
\frac{59}{211} &= \frac{1}{6} + \frac{1}{9} + \frac{1}{633} + \frac{1}{3798}\\
\end{aligned}
$$
由于方法一与方法二中，最小的分数相同，因此二者均是最优解。

给出 $a,b$，编程计算最好的表达方式。保证最优解满足：最小的分数 $\ge \cfrac{1}{10^7}$。 


## 说明/提示

$1 \lt a \lt b \lt 1000$

## 样例 #1

### 输入

```
19 45```

### 输出

```
5 6 18```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：埃及分数 深入学习指南 💡

> 今天，我们将化身古埃及的“分数工匠”，一起把任意真分数拆成一串独一无二的单位分数之和。别担心，我们不需要真的穿越沙漠，只需要一把“迭代加深+剪枝”的利剑，就能在浩瀚的搜索树中迅速找到最优雅的答案！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
把一个真分数 **a/b** 表示成 **最少** 个 **互不相同的** 单位分数（形如 1/x）之和；如果方案不唯一，则选择 **“最小分母”最大的** 那一种。

✨ **核心算法标签**：  
迭代加深搜索（IDDFS） · 剪枝优化 · 数学推导 · 二分思想

🗣️ **初步分析**  
- 暴力 DFS 会陷入“无底洞”，BFS 又会被巨大的状态空间撑爆。  
- 我们发现“分数个数”不会太多（log₂1000 ≈ 10），于是 **迭代加深搜索** 成为首选：从小到大枚举层数，直到第一次找到可行解。  
- 为了让答案跑得飞快，需要 **层层剪枝**：上下界、最大分母限制、最后两层直接解方程……这些技巧就像给搜索装上“涡轮增压”！

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **问题目标** | “最少个数” + “最小分母最大” → 双重最优化，天然适合 **迭代加深**（外层控个数，内层控质量）。 |
| **约束条件** | 分母必须严格递增 → 每一步的搜索范围 **可计算上下界**，直接剪掉大量无效分支。 |
| **数据规模** | a,b < 1000，但 1e7 的分母上限让纯暴力爆炸 → 需要 **数学剪枝** 把指数级复杂度压成“玄学”。 |

### 🧠 思维链构建：从线索到策略
1. **线索1** 告诉我们：先保证“层数最少”，再在同层里找“最小分母最大” → 外层枚举层数（IDDFS）。  
2. **线索2** 告诉我们：每一步的分母 **i** 必须满足  
   ```
   max(上一个分母+1 , ceil(b/a)) ≤ i ≤ floor((剩余层数)×b/a)
   ```  
   这就是 **上下界剪枝**，瞬间砍掉 90% 的无效分支。  
3. **线索3** 告诉我们：当只剩最后两个分数时，直接解方程  
   ```
   1/x + 1/y = a/b
   ```  
   把两层搜索压缩成 **O(1) 数学计算**，堪称“剪枝之王”！

---

## 2. 精选优质题解参考

> 我从 10+ 份高赞题解中，挑出 **3 份最具代表性** 的作品。它们共同勾勒出“从朴素到顶尖”的优化之路。

| 题解 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **王熙文** (赞104) | 首创“最大分母迭代加深”+“最后两层解方程”组合技；用 `__int128` 防溢出。 | “像给 DFS 装上瞄准镜，每一次射击都精准命中可行解。” |
| **CNS_5t0_0r2** (赞18) | 用 **故事化语言** 讲解 6 大剪枝；代码可读性极高，适合初学者模仿。 | “把冰冷的剪枝写成‘探险关卡’，让人一边读一边忍不住点赞。” |
| **DengDuck** (赞2) | 极简实现，却把“最后两层数学优化”讲透；阈值 50000 的实战调参经验。 | “短小精悍的‘匕首版’代码，刀刀见血，适合背模板。” |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以最优解为例）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **迭代加深框架** | 外层 `for(dep=1;;dep++)` 控制分数个数；内层枚举最大分母 `maxD` 从 1e3→1e7×10。 | **先定层数，再定质量**，避免 DFS 迷失。 |
| **上下界剪枝** | 当前分母 `i` 必须满足 `max(last+1, ceil(b/a)) ≤ i ≤ min(maxD, (剩余层数)×b/a)`。 | 把“搜索”变成“区间扫描”，复杂度骤降。 |
| **最后两层解方程** | 设剩余分数 a/b，列方程组 `x+y=ka`, `xy=kb`，解一元二次方程求 `x,y`。 | **数学秒杀搜索**，两层递归 → O(1)。 |
| **解的存在性判定** | 判别式 `Δ=k²a²-4kb` 须为完全平方数，且两根为正整数且递增。 | 用 `sqrt` + 奇偶校验即可在 O(1) 内完成。 |

### ✨ 解题技巧总结
- **技巧A：问题转化**  
  把“拆分数”转化为“搜索树路径”，再用层数限制 + 数学剪枝。
- **技巧B：剪枝四连击**  
  1. 层数限制 2. 分母上下界 3. 最大分母迭代加深 4. 最后两层解方程。
- **技巧C：数据类型安全**  
  中间值可能爆 `long long`，用 `__int128` 或手写高精度。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **纯 DFS** | 枚举所有分母组合 | 思路直观 | 指数级，TLE | 10% |
| **BFS** | 层序搜索最短路 | 保证最短 | 空间爆炸 | 10% |
| **IDDFS+剪枝** | 层数控制+数学剪枝 | 时间与空间均衡 | 需要数学推导 | 100% |
| **IDA\*** | 估价函数提前回溯 | 更理论化 | 实现复杂 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 提炼自 **CNS_5t0_0r2** 题解，易读易改。

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int MAXD = 11, INF = 1e7;

int64 a, b, ans[MAXD], tmp[MAXD], maxD;
bool found;

int64 gcd(int64 x, int64 y) {
    return y ? gcd(y, x % y) : x;
}

void dfs(int64 a, int64 b, int dep, int last) {
    if (dep == MAXD) return;
    if (a == 1 && b > last) {               // 最后一层直接判断
        tmp[dep] = b;
        if (!found || b < ans[dep]) {
            memcpy(ans, tmp, sizeof(ans));
            found = true;
        }
        return;
    }
    if (dep == MAXD - 1) {                // 最后两层解方程
        int64 kMin = 4 * b / a / a + 1;
        int64 kMax = min(2 * maxD / a, maxD * maxD / b);
        for (int64 k = kMin; k <= kMax; ++k) {
            int64 delta = a * a * k * k - 4 * b * k;
            int64 s = sqrt(delta);
            if (s * s != delta || (a * k - s) % 2) continue;
            int64 x = (a * k - s) / 2;
            int64 y = (a * k + s) / 2;
            if (x <= last || y <= x) continue;
            tmp[dep] = x; tmp[dep + 1] = y;
            if (!found || y < ans[dep + 1]) {
                memcpy(ans, tmp, sizeof(ans));
                found = true;
            }
        }
        return;
    }
    int64 l = max(last + 1, (b + a - 1) / a);
    int64 r = min(maxD, (MAXD - dep) * b / a);
    if (found && r >= ans[MAXD]) r = ans[MAXD] - 1;
    for (int64 i = l; i <= r; ++i) {
        int64 na = a * i - b, nb = b * i, g = gcd(na, nb);
        tmp[dep] = i;
        dfs(na / g, nb / g, dep + 1, i);
    }
}

int main() {
    cin >> a >> b;
    int64 g = gcd(a, b);
    a /= g; b /= g;
    tmp[0] = 1;
    for (int dep = 1; dep < MAXD; ++dep) {
        for (maxD = 1000; maxD <= INF; maxD *= 10) {
            found = false;
            dfs(a, b, 1, 1);
            if (found) {
                for (int i = 1; i <= dep; ++i) cout << ans[i] << ' ';
                return 0;
            }
        }
    }
    return 0;
}
```

### 关键片段赏析
| 片段 | 亮点 | 代码示例 |
|---|---|---|
| **最后两层解方程** | 把两层搜索压缩到 O(1) | `int64 delta = a*a*k*k - 4*b*k;` |
| **上下界剪枝** | 区间扫描而非枚举 | `int64 l = max(last+1, ceil(b/a));` |
| **迭代加深双重循环** | 层数 + 分母上限 | `for(dep=1;;dep++) for(maxD=1e3;maxD<=1e7;maxD*=10)` |

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题  
**“像素工匠的拆分工坊”**  
- 8-bit 像素风格，背景是古埃及石室壁画。  
- 玩家扮演工匠，把漂浮的分数砖块“敲碎”成单位分数小块。

### 🎨 动画流程（关键帧脚本）
| 帧序 | 画面 | 音效 | 旁白 |
|---|---|---|---|
| 1 | 输入 a/b 化作一块大金砖 | 8-bit 敲击声 | “把 19/45 敲成最少块！” |
| 2 | IDDFS 层数 ++，金字塔层数增高 | 上升音 | “层数限制 +1，继续探索！” |
| 3 | 当前分母区间扫描，像素箭头在区间移动 | 滴答声 | “下界 3，上界 6，区间扫描开始！” |
| 4 | 最后两层直接闪现两根石柱 | 魔法音 | “数学解方程，两根石柱完美契合！” |
| 5 | 成功拼出 5 6 18，金字塔发光 | 胜利 BGM | “最少 3 块，最小分母 18，任务完成！” |

### 🕹️ 交互设计
- **步进/自动播放**：空格键单步，回车键自动。  
- **速度滑块**：1~60 FPS 可调。  
- **像素 HUD**：实时显示当前层数、剩余分数、剪枝计数。

---

## 6. 拓展练习与相似问题思考

### 🔗 通用技巧迁移
- **迭代加深**：任何“先求最短步数，再求最优解”的搜索题。  
- **上下界剪枝**：背包、数独、八皇后等需要枚举但可快速算边界的场景。  
- **最后两层数学优化**：数论方程、不定方程、因式分解类题目。

### 📚 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P1025 [数的划分] | 迭代加深 + 上下界剪枝的经典入门。 |
| P1441 [砝码称重] | 把“拆分数”思想迁移到组合称重。 |
| P1731 [生日蛋糕] | 三维几何 + 迭代加深 + 剪枝，难度升级。 |

---

## 7. 学习心得与经验分享

> **王熙文**：“调了两天才过 Hack，最大的体会是——**数学剪枝比盲目加常数有效 100 倍**！”  
> **CNS_5t0_0r2**：“把剪枝写成故事，不仅自己记忆深刻，也帮助后来者少走弯路。”

**洛语云笺点评**：  
- 调试时 **打印中间状态**（当前层数、剩余分数、分母区间）能快速定位瓶颈。  
- 遇到极端数据，先 **数学推导** 再 **实验验证**，而不是盲目改参数。

---

<conclusion>
恭喜你，已经掌握了“埃及分数”的完整攻略！记住：  
- **先框架，后剪枝** —— 迭代加深是骨架，数学剪枝是肌肉。  
- **先正确，后高效** —— 先保证答案对，再让时间飞。  
下一次，我们再一起挑战更烧脑的算法探险！💪
</conclusion>

---
处理用时：72.96秒
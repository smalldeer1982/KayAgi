# 题目信息

# [NOI2010] 航空管制

## 题目描述

世博期间，上海的航空客运量大大超过了平时，随之而来的航空管制也频频发生。最近，小 X 就因为航空管制，连续两次在机场被延误超过了两小时。对此，小 X 表示很不满意。

在这次来烟台的路上，小 X 不幸又一次碰上了航空管制。于是小 X 开始思考关于航空管制的问题。

假设目前被延误航班共有 $n$ 个，编号为 $1$ 至 $n$。机场只有一条起飞跑道，所有的航班需按某个顺序依次起飞（称这个顺序为起飞序列）。定义一个航班的起飞序号为该航班在起飞序列中的位置，即是第几个起飞的航班。

起飞序列还存在两类限制条件：

- 第一类（最晚起飞时间限制）：编号为 $i$ 的航班起飞序号不得超过 $k_i$。

- 第二类（相对起飞顺序限制）：存在一些相对起飞顺序限制 $(a,b)$，表示航班 $a$ 的起飞时间必须早于航班 $b$，即航班 $a$ 的起飞序号必须小于航班 $b$ 的起飞序号。

小 X 思考的第一个问题是，若给定以上两类限制条件，是否可以计算出一个可行的起飞序列。第二个问题则是，在考虑两类限制条件的情况下，如何求出每个航班在所有可行的起飞序列中的最小起飞序号。


## 说明/提示

### 样例解释

在样例 $1$ 中：

起飞序列 $3\ 5\ 1\ 4\ 2$ 满足了所有的限制条件，所有满足条件的起飞序列有：

$$
\begin{aligned}
3\ 4\ 5\ 1\ 2\\
3\ 5\ 1\ 2\ 4\\
3\ 5\ 1\ 4\ 2\\
3\ 5\ 4\ 1\ 2\\
5\ 3\ 1\ 2\ 4\\
5\ 3\ 1\ 4\ 2\\
5\ 3\ 4\ 1\ 2
\end{aligned}
$$

由于存在 $(5,1)$ 和 $(3,1)$ 两个限制，航班 $1$ 只能安排在航班 $5$ 和 $3$ 之后，故最早起飞时间为 $3$，其他航班类似。

在样例 $2$ 中：

虽然航班 $4,5$ 没有相对起飞顺序限制，但是由于航班 $1,2,3$ 都必须安排在前 $3$ 个起飞，所以 $4,5$ 最早只能安排在第 $4$ 个起飞。

### 数据范围

对于 $30\%$ 数据：$n\leq 10$。

对于 $60\%$ 数据：$n\leq 500$。

对于 $100\%$ 数据：$n\leq 2\times 10^3,m\leq 10^4$。

感谢 @FlierKing 提供 spj


## 样例 #1

### 输入

```
5 5
4 5 2 5 4
1 2
3 2
5 1
3 4
3 1
```

### 输出

```
3 5 1 4 2
3 4 1 2 1
```

## 样例 #2

### 输入

```
5 0
3 3 3 5 5
```

### 输出

```
3 2 1 5 4
1 1 1 4 4
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：[NOI2010] 航空管制 深入学习指南 💡

今天我们来一起分析 **“航空管制”** 这道经典图论题。它把 **拓扑排序** 和 **贪心/优先队列** 巧妙融合，并衍生出多种解法：DFS、BFS、堆、线段树，甚至还有 bitset 黑科技！  
> 读完这份指南，你将学会如何像侦探一样从题面“读”出算法线索，如何比较不同策略的优劣，以及如何用像素动画把抽象的图论流程变成一场“航班调度”游戏。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
> 既要满足“航班最晚起飞时间”（deadline），又要满足“谁必须先飞”的依赖关系，还要快速求出 **每个航班的最早可能起飞序号**。

✨ **核心算法标签**  
- 图论（DAG）  
- 拓扑排序（Topological Sort）  
- 贪心 + 优先队列 / 堆  
- DFS / BFS  
- 可持久化/线段树优化  

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 原文关键词 | 对应算法信号 |
| --- | --- | --- |
| 1️⃣ **依赖关系** | “航班 a 必须早于航班 b” | DAG，拓扑排序 |
| 2️⃣ **截止时间** | “航班 i 的起飞序号 ≤ kᵢ” | 贪心：让 deadline 小的尽量靠前 |
| 3️⃣ **数据规模** | n ≤ 2×10³，m ≤ 10⁴ | O(n²) 或 O(nm) 均可，O(n² log n) 也能过 |

### 🧠 思维链构建：从线索到策略
> 1. 先看到“必须 a 早于 b”，**拓扑排序**直接浮现在脑海。  
> 2. 但还有“最晚起飞时间”——拓扑序里再套一个 **按 deadline 排序的贪心**。  
> 3. 第二问要求“每个航班的最早可能位置”，相当于 **枚举航班 x，问：不让 x 飞，最晚能把别的航班安排到什么位置？**  
> 4. 于是出现多种实现：  
>   • 纯 DFS（SBofGaySchool）  
>   • 反图 + 优先队列（Sol1 / asuldb）  
>   • bitset 黑科技（gyh20）  
>   • 线段树（ywy_c_asm）  

---

## 2. 精选优质题解参考

| 题解 | 作者 | 亮点提炼 | 推荐指数 |
| --- | --- | --- | --- |
| **DFS 反图** | SBofGaySchool | 用两次 DFS 把“依赖”和“deadline”一次性搞定；代码短小精悍，适合初学者理解 | ⭐⭐⭐⭐⭐ |
| **优先队列拓扑** | Sol1 | 反图 + 小根堆，思路清晰；第二问用“延迟入队”技巧，复杂度 O(nm) | ⭐⭐⭐⭐ |
| **bitset 优化** | gyh20 | 用 bitset 压缩可达性，复杂度 O(n² + nm/64)，目前洛谷榜一 | ⭐⭐⭐⭐ |
| **线段树贪心** | ywy_c_asm | 把“插入位置”问题转成区间最值查询，体现数据结构威力 | ⭐⭐⭐⭐ |
| **二分 + 拓扑 check** | pufanyi | 思路直观，但常数大；展示了“二分答案+验证”的经典套路 | ⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以 SBofGaySchool DFS 为例）

| 关键点 | 分析 | 💡 学习笔记 |
| --- | --- | --- |
| **1️⃣ 真实 deadline 计算** | 每个航班的 kᵢ 还要 ≤ 所有后继航班 k-1；一次 DFS 即可递推 | 把“后继最小值-1”当成动态规划 |
| **2️⃣ 构造合法序列** | 从后往前填：先放 k=n 的航班，再放 k=n-1 的… 保证不冲突 | 反证法证明正确性 |
| **3️⃣ 求最早位置** | 枚举航班 x，反图 DFS 标记 x 及其祖先；剩余航班仍按 k 从大到小填，**空出来的最后一个位置**就是 x 的最早位置 | “让别的航班尽量晚飞”即可让 x 尽量早飞 |

### ✨ 解题技巧总结
- **反图 + 贪心**：把“必须 a 早于 b”转成“b 必须在 a 之后”，方便从后往前安排。  
- **延迟入队**：优先队列里不立即放入度为 0 的点，而是等“再不选就错过 deadline”时再入队，直接求出最早位置。  
- **bitset 优化**：DAG 上可达性用 bitset 压缩，64 倍常数优化。  

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 优缺点 | 适用场景 |
| --- | --- | --- | --- | --- |
| **DFS 两次** | DFS 更新 k；再 DFS 求最早位置 | O(n(m+n)) | 代码短，常数小；递归层数深 | n ≤ 2000 |
| **优先队列拓扑** | 反图 + 小根堆，延迟入队 | O(nm) | 思路清晰；队列操作多 | n ≤ 2000 |
| **bitset 可达性** | bitset 维护可达点，跳过无效拓扑 | O(n² + nm/64) | 最快；实现稍复杂 | n ≤ 2000 |
| **线段树贪心** | 线段树维护 lim-pos 最小值 | O(n² log n) | 最通用；常数较大 | n ≤ 2000 |
| **二分 + 拓扑 check** | 二分答案 + 拓扑验证 | O(nm log n) | 思路直观；常数巨大 | n ≤ 500 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合 SBofGaySchool DFS 与 Sol1 优先队列，给出一份 **简洁完整** 的参考实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2005, M = 1e4 + 5;
int n, m, k[N], deg[N], ans[N];
vector<int> e[N], re[N];   // 原图 & 反图

// ---------- 第一问：优先队列拓扑 ----------
void solve1() {
    priority_queue<pair<int, int>> q;   // max-heap: 按 k 从大到小
    for (int i = 1; i <= n; ++i) if (!deg[i]) q.emplace(k[i], i);
    for (int pos = n; pos >= 1; --pos) {
        while (!q.empty() && q.top().first < pos) q.pop();
        if (q.empty()) { puts("-1"); exit(0); }   // 无解
        int u = q.top().second; q.pop();
        ans[pos] = u;
        for (int v : e[u])
            if (!--deg[v]) q.emplace(k[v], v);
    }
    for (int i = 1; i <= n; ++i) cout << ans[i] << " \n"[i == n];
}

// ---------- 第二问：延迟入队 ----------
int solve2(int ban) {
    static int d[N];
    priority_queue<pair<int, int>> q;
    for (int i = 1; i <= n; ++i) d[i] = deg[i];
    for (int i = 1; i <= n; ++i)
        if (!d[i] && i != ban) q.emplace(k[i], i);
    for (int pos = n; pos >= 1; --pos) {
        while (!q.empty() && q.top().first < pos) q.pop();
        if (q.empty()) return pos;   // ban 必须此时起飞
        int u = q.top().second; q.pop();
        for (int v : e[u])
            if (!--d[v] && v != ban) q.emplace(k[v], v);
    }
    return 1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> k[i];
    for (int i = 1, a, b; i <= m; ++i) {
        cin >> a >> b;
        e[b].push_back(a);   // 反图
        ++deg[a];
    }
    solve1();
    for (int i = 1; i <= n; ++i) cout << solve2(i) << " \n"[i == n];
    return 0;
}
```

### 精选代码片段赏析
| 题解 | 亮点 | 关键片段 |
| --- | --- | --- |
| SBofGaySchool | 两次 DFS 搞定全部 | `dfs` 更新 k 值，`rdfs` 标记祖先 |
| gyh20 | bitset 压缩可达性 | `B[x] |= B[to]` 一次位运算 |
| ywy_c_asm | 线段树区间减 | `add(l,r) --` 维护 `lim-pos` 最小值 |

---

## 5. 算法可视化：像素动画演示

> 主题：**《像素塔台》** —— 8 位风格的航班调度游戏

| 场景 | 像素表现 | 音效/交互 |
| --- | --- | --- |
| **塔台大屏** | 32×24 的像素网格，每格代表一个时间点；飞机用 8×8 小图标 | 8-bit 起飞音效 |
| **拓扑排序** | 依赖边 → 像素箭头；队列 → 像素传送带 | 每出队一架飞机播放“叮” |
| **贪心选 deadline** | 飞机图标上方显示 kᵢ 倒计时，颜色从绿→黄→红 | 错过 deadline 播放“警报” |
| **第二问延迟入队** | 飞机 x 被“禁止起飞”→图标变灰；剩余飞机继续排队 | 当 x 被迫起飞时播放“胜利” |
| **交互面板** | 开始/暂停、单步、调速滑块 | 支持 AI 自动演示 |

技术实现（核心伪代码）：
```js
// Canvas 关键帧示例：延迟入队
function delayEnqueueStep(pos, ban) {
  highlightPlane(ban, 'gray');
  for (let t = n; t >= 1; t--) {
    drawQueue(queue);        // 像素传送带
    if (queue.empty()) {
      animateNumber(pos, t); // x 被迫在 t 起飞
      break;
    }
    stepForward();
  }
}
```

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **反图 + 贪心** 同样适用于：  
  1. 课程表：先修课必须在后修课之前，但每门课有最晚修读学期。  
  2. 任务调度：任务有依赖，且必须在截止时间前完成。  
  3. 芯片布线：信号线必须按顺序走线，且不能超过最长延迟。

### 洛谷推荐
| 题号 | 推荐理由 |
| --- | --- |
| **P3243 [HNOI2015] 菜肴制作** | 反图 + 拓扑 + 贪心模板题 |
| **P1983 车站分级** | DAG 上带权拓扑排序 |
| **P4017 最大食物链计数** | 纯拓扑排序练手 |
| **P6145 [USACO20FEB] Timeline G** | 差分约束 + 拓扑 |

---

## 7. 学习心得与经验分享

> SBofGaySchool 提到：“写完 DFS 后，用 assert 检查 k 值是否非负，帮我定位了负下标 bug。”  
> **点评**：善用断言与对拍，是避免边界错误的有效手段。

> ywy_c_asm 卡常心得：“把 sort 换成手写的插入排序，常数从 3.2 s 降到 1.8 s。”  
> **点评**：当复杂度已卡满时，**常数优化**也能让你从 TLE 边缘起死回生。

---

<conclusion>
今天我们用 **反图 + 贪心** 的思路，把看似复杂的航空管制拆解成两次优雅的 DFS / 优先队列。  
记住：  
- 遇到“必须 a 在 b 前” → 先想 **拓扑**  
- 遇到“最晚时间” → 再套 **贪心**  
- 遇到“每个点的最早位置” → 尝试 **延迟入队** 或 **枚举 + 验证**  
下次再碰到类似题目，你就能像塔台调度员一样从容不迫！✈️
</conclusion>

---
处理用时：79.94秒
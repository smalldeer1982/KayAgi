# 题目信息

# [SDOI2009] 晨跑

## 题目描述

Elaxia 最近迷恋上了空手道，他为自己设定了一套健身计划，比如俯卧撑、仰卧起坐等等，不过到目前为止，他坚持下来的只有晨跑。 

现在给出一张学校附近的地图，这张地图中包含 $N$ 个十字路口和 $M$ 条街道，Elaxia 只能从 一个十字路口跑向另外一个十字路口，街道之间只在十字路口处相交。

Elaxia 每天从寝室出发跑到学校，保证寝室编号为 $1$，学校编号为 $N$。 

Elaxia 的晨跑计划是按周期（包含若干天）进行的，由于他不喜欢走重复的路线，所以在一个周期内，每天的晨跑路线都不会相交（在十字路口处），寝室和学校不算十字路口。

Elaxia 耐力不太好，他希望在一个周期内跑的路程尽量短，但是又希望训练周期包含的天数尽量长。

除了练空手道，Elaxia 其他时间都花在了学习和找 MM 上面，所有他想请你帮忙为他设计 一套满足他要求的晨跑计划。

可能存在 $1\rightarrow n$ 的边。这种情况下，这条边只能走一次。

## 说明/提示

- 对于 $30\%$ 的数据，$N\le 20$，$M \le 120$。
- 对于 $100\%$ 的数据，$N\le 200$，$M\le 2\times 10^4,1\le c\le 10^4$。

## 样例 #1

### 输入

```
7 10
1 2 1
1 3 1
2 4 1
3 4 1
4 5 1
4 6 1
2 5 5
3 6 6
5 7 1
6 7 1```

### 输出

```
2 11
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[SDOI2009] 晨跑 深入学习指南 💡

<introduction>
  今天我们来一起分析“[SDOI2009] 晨跑”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。
</introduction>

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在满足“十字路口不重复经过”的限制下，求从寝室（1号点）到学校（n号点）的**最大天数（最大流）**和**最短总路程（最小费用）**。  
✨ **核心算法标签**：网络流（Network Flow），最小费用最大流（Min-Cost Max-Flow），拆点（Node Splitting）。

🗣️ **初步分析**：
- 题目要求“每天路线不重复”，意味着每条路径上的**十字路口只能出现一次**（除起点1和终点n外）。  
- 这是一个典型的**最小费用最大流**问题，其中：  
  - **流量** = 训练天数（路径条数），目标是最大化。  
  - **费用** = 每天跑的路程，目标是最小化。  
- 难点在于如何**限制十字路口的访问次数**（点容量限制）。这需要我们使用**拆点**技巧：将每个十字路口拆分为“入点”和“出点”，并在中间连一条容量为1的边，从而确保每个十字路口只能被访问一次。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：题目要求“最长天数 + 最短路程”，这是**最小费用最大流**的经典标志。
2. **线索2 (问题约束)**：十字路口不能重复经过，说明存在**点容量限制**（每个点只能被访问一次）。
3. **线索3 (数据规模)**：n ≤ 200，m ≤ 2×10⁴，适合使用**SPFA + EK**或**Dinic**算法求解最小费用最大流。

### 🧠 思维链构建：从线索到策略
> 好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1. **线索1**告诉我们这是一个“双目标”问题（最大流 + 最小费用），最小费用最大流是最佳选择。
> 2. **线索2**的“点不能重复访问”提示我们需要**拆点**：将每个点拆成入点和出点，中间连一条容量为1的边。
> 3. **线索3**的数据规模告诉我们，SPFA + EK（O(nmf)）或Dinic（O(n²m)）均可通过。
> 4. **结论**：使用**拆点 + 最小费用最大流**模型，将问题转化为网络流问题，高效求解！

---

## 2. 精选优质题解参考

<eval_intro>
从思路清晰度、代码规范性、算法有效性等维度，我为大家筛选了以下优质题解。
</eval_intro>

**题解一：作者 Siyuan（赞：28）**
* **点评**：这份题解思路清晰，准确抓住了“拆点 + 最小费用最大流”的核心。代码实现规范，SPFA + DFS的EK算法高效可靠，是学习网络流的优秀范例。  
* **亮点**：  
  - 拆点逻辑严谨（1和n的容量设为∞，其余为1）。  
  - 反向边费用设为负值，确保算法正确性。

**题解二：作者 半仙胡小桃（赞：7）**
* **点评**：用通俗语言解释了拆点的必要性，并通过图示直观展示了“中间点重复访问”的问题。代码简洁，适合初学者理解。  
* **亮点**：  
  - 拆点后边的连接方式（出点→入点）清晰易懂。  
  - 对1→n的直接边特殊处理（容量设为1）。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）
1. **关键点1：如何限制十字路口的访问次数？**
   * **分析**：将每个点拆分为入点（i）和出点（i+n），中间连一条边：  
     - 容量：1（限制访问次数）。  
     - 费用：0（不增加路程）。  
   * 💡 **学习笔记**：拆点是处理“点容量限制”的通用技巧。

2. **关键点2：如何建图？**
   * **分析**：  
     - 对于原图中的边(u, v, c)，从u的出点（u+n）连向v的入点（v），容量为1，费用为c。  
     - 起点1和终点n的入点和出点之间连容量为∞的边（允许重复经过）。  
     - 源点为1的出点（1+n），汇点为n的入点（n）。  
   * 💡 **学习笔记**：建图时需明确每条边的起点、终点、容量和费用。

3. **关键点3：如何求解最小费用最大流？**
   * **分析**：使用**SPFA + EK算法**：  
     - SPFA找增广路径（费用最小）。  
     - EK算法沿增广路径更新流量和费用。  
   * 💡 **学习笔记**：SPFA的dis数组初始化为∞，反向边费用为负值。

### ✨ 解题技巧总结
- **技巧A（拆点）**：将点容量限制转化为边容量限制，适用于“点不能重复访问”问题。
- **技巧B（反向边）**：反向边的容量为0，费用为负值，确保算法正确性。
- **技巧C（特殊点处理）**：起点和终点的容量设为∞，允许重复经过。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力DFS** | 枚举所有路径，检查不重复 | 思路直观 | 时间复杂度O(2^m)，无法通过 | n ≤ 20，得分30% |
| **拆点 + 最小费用最大流** | 网络流模型，高效求解 | 时间复杂度O(nmf)，可通过 | 需掌握网络流知识 | n ≤ 200，得分100% |
| **动态规划** | 状态压缩DP | 无需拆点 | 时间复杂度O(n²·2^n)，无法通过 | n ≤ 20，得分30% |

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
* **说明**：综合Siyuan和半仙胡小桃的题解，提供标准拆点 + 最小费用最大流实现。
* **完整核心代码**：
```cpp
#include <cstdio>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;

const int N = 405, M = 1e5 + 5, INF = 0x3f3f3f3f;
int n, m, s, t, tot = 1, head[N], to[M], nxt[M], cap[M], cost[M], dis[N], pre[N], flow[N], maxflow, mincost;
bool vis[N];

void add(int u, int v, int w, int c) {
    to[++tot] = v, nxt[tot] = head[u], cap[tot] = w, cost[tot] = c, head[u] = tot;
    to[++tot] = u, nxt[tot] = head[v], cap[tot] = 0, cost[tot] = -c, head[v] = tot;
}

bool spfa() {
    queue<int> q;
    memset(dis, 0x3f, sizeof(dis));
    memset(flow, 0x3f, sizeof(flow));
    memset(vis, 0, sizeof(vis));
    q.push(s), dis[s] = 0, vis[s] = 1, pre[t] = -1;
    while (!q.empty()) {
        int u = q.front(); q.pop(), vis[u] = 0;
        for (int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if (cap[i] && dis[v] > dis[u] + cost[i]) {
                dis[v] = dis[u] + cost[i];
                pre[v] = u;
                if (!vis[v]) q.push(v), vis[v] = 1;
            }
        }
    }
    return pre[t] != -1;
}

void ek() {
    while (spfa()) {
        int f = flow[t];
        maxflow += f;
        mincost += f * dis[t];
        for (int u = t; u != s; u = pre[u]) {
            for (int i = head[pre[u]]; i; i = nxt[i])
                if (to[i] == u && cap[i]) {
                    cap[i] -= f, cap[i ^ 1] += f;
                    break;
                }
        }
    }
}

int main() {
    scanf("%d%d", &n, &m);
    s = 1 + n, t = n;
    add(1, 1 + n, INF, 0);
    add(n, n + n, INF, 0);
    for (int i = 2; i < n; ++i) add(i, i + n, 1, 0);
    while (m--) {
        int u, v, c;
        scanf("%d%d%d", &u, &v, &c);
        add(u + n, v, 1, c);
    }
    ek();
    printf("%d %d\n", maxflow, mincost);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**动画演示主题**：像素小人在迷宫中寻找最短路径（最小费用）并尽可能多走几条不重复的路（最大流）。

**设计思路**：
- **像素风格**：8位红白机风格，十字路口用像素方块表示，路径用箭头动画展示。
- **拆点可视化**：每个十字路口拆分成“入点”（蓝色方块）和“出点”（红色方块），中间连一条容量为1的边（黄色线段）。
- **网络流动画**：
  - SPFA寻找增广路径时，用绿色高亮当前节点，蓝色箭头表示路径。
  - 增广时，路径上的边闪烁并减少容量，伴随“叮”的音效。
- **游戏化元素**：
  - 每找到一条新路径，播放“胜利”音效，显示“+1天”。
  - 最终显示“总天数”和“总路程”。

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**：
- 拆点技巧适用于所有“点容量限制”问题，如：  
  1. **餐厅排队问题**：每个餐桌只能坐一次顾客（拆点）。  
  2. **任务调度问题**：每台机器同一时间只能处理一个任务（拆点）。  
  3. **网络路由问题**：每个路由器端口只能转发一次数据包（拆点）。

**洛谷练习推荐**：
1. **P1402 酒店之王**  
   🗣️ 推荐理由：拆点 + 最大流，巩固点容量限制建模。
2. **P1231 教辅的组成**  
   🗣️ 推荐理由：拆点 + 最小费用最大流，练习费用流应用。
3. **P2891 吃饭**  
   🗣️ 推荐理由：经典拆点题，学习如何将“点权”转化为“边权”。

---

## 7. 学习心得与经验分享

> **来自作者Yeji_的调试经验**：  
> “我在处理1→n的直接边时，一开始忘记将容量设为1，导致答案错误。后来通过打印中间变量发现是这条边被多次使用，才意识到需要特殊处理。”  
> **点评**：调试网络流时，检查每条边的容量和费用是否正确是发现问题的关键！

---

<conclusion>
本次关于“[SDOI2009] 晨跑”的分析就到这里。我们学习了如何通过**拆点 + 最小费用最大流**解决“点容量限制”问题。记住，网络流的难点往往在建模，一旦模型建立，代码实现就是模板化的。下次我们一起探索更多有趣的算法！💪
</conclusion>

---
处理用时：70.64秒
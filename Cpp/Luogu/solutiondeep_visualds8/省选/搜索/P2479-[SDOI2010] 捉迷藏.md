# 题目信息

# [SDOI2010] 捉迷藏

## 题目背景

iPig 在大肥猪学校刚上完了无聊的猪文课，天资聪慧的 iPig 被这门对他来说无比简单的课弄得非常寂寞，为了消除寂寞感，他决定和他的好朋友 giPi（鸡皮）玩一个更加寂寞的游戏——捉迷藏。但是，他们觉得，玩普通的捉迷藏没什么意思，还是不够寂寞，于是，他们决定玩寂寞无比的螃蟹版捉迷藏。


## 题目描述

螃蟹版捉迷藏，顾名思义，就是说他们在玩游戏的时候只能沿水平或垂直方向走。

一番寂寞的剪刀石头布后，他们决定 iPig 去捉 giPi。由于他们都很熟悉大肥猪学校的地形了，所以 giPi 只会躲在大肥猪学校内 $N$ 个隐秘地点之一，显然 iPig 也只会在那 $N$ 个地点内找 giPi。

游戏一开始，他们从这 $N$ 个隐秘地点之中选定一个地点，iPig 保持不动，然后 giPi 用 $30$ 秒的时间逃离现场（显然，giPi 不会呆在原地）。然后 iPig 会随机地去找 giPi，直到找到为止。

由于 iPig 很懒，所以他总是走最短的路径，而且，他选择起始点不是随便选的，他想找一个地点，使得该地点到（除了这个地点以外的）最远的地点和最近的地点的距离差最小。iPig现在想知道这个距离差最小是多少。

由于 iPig 现在手上没有电脑，所以不能编程解决这个如此简单的问题，所以他马上打了个电话，要求你帮他解决这个问题。iPig 告诉了你大肥猪学校的 $N$ 个隐秘地点的坐标，请你编程求出 iPig 的问题。

## 说明/提示

$30\%$ 的数据中，$2\le N\le 10^3$；

$100\%$ 的数据中，$2\le N\le 10^5$，$0\le X_i,Y_i\le 10^9$。

数据保证点不重合。

## 样例 #1

### 输入

```
4
0 0
1 0
0 1
1 1
```

### 输出

```
1```

# AI分析结果

# 💡 洛语云笺的C++算法解析：SDOI2010 捉迷藏 深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在 **N 个二维点** 中，找到一个点 \( p_i \)，使得其到其他所有点的 **曼哈顿距离** 的 **最大值与最小值之差最小**。  
> 曼哈顿距离公式：\( \text{dis}(p_i, p_j) = |x_i - x_j| + |y_i - y_j| \)。

✨ **核心算法标签**：  
- **K-D Tree**（高维空间搜索）  
- **线段树/树状数组**（曼哈顿距离拆分优化）  
- **CDQ 分治**（二维偏序）  

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1（问题目标）**：  
   题目要求 **最小化极差**（最大值 - 最小值），这类问题通常需要 **高效计算每个点的极值**（最近/最远点），而非暴力枚举。

2. **线索2（曼哈顿距离特性）**：  
   曼哈顿距离可拆分为 **四个线性表达式**：  
   \[
   |x_i - x_j| + |y_i - y_j| = \max \begin{cases}
   (x_i + y_i) - (x_j + y_j) \\
   (x_i - y_i) - (x_j - y_j) \\
   (-x_i + y_i) - (-x_j + y_j) \\
   (-x_i - y_i) - (-x_j - y_j)
   \end{cases}
   \]  
   这提示我们 **将二维问题转化为一维极值问题**！

3. **线索3（数据规模）**：  
   \( N \leq 10^5 \)，暴力 \( O(N^2) \) 不可行，需 **\( O(N \log N) \)** 算法。

---

### 🧠 思维链构建：从线索到策略

> 1. **暴力思路**：直接枚举每个点，计算其到其他所有点的距离（\( O(N^2) \)），但数据范围直接否决。  
> 2. **曼哈顿距离拆分**：将距离拆分为四个线性表达式，分别维护极值（如 \( x_j + y_j \) 的最大/最小值）。  
> 3. **数据结构选择**：  
>    - **K-D Tree**：高效处理高维空间最近/最远点查询（\( O(\log N) \) 平均）。  
>    - **线段树/树状数组**：将二维问题降维，利用排序和离散化维护极值（\( O(N \log N) \)）。  
> 4. **结论**：**K-D Tree** 或 **曼哈顿拆分 + 线段树** 是高效解法！

---

## 2. 精选优质题解参考

### 题解一：revenger（线段树拆分曼哈顿距离）
- **亮点**：  
  将曼哈顿距离拆分为四个线性表达式，分别用 **线段树** 维护极值。通过 **离散化** 和 **两次扫描**（正序/逆序）覆盖所有方向。  
  - **时间复杂度**：\( O(N \log N) \)。  
  - **代码技巧**：使用 **zkw线段树**（非递归实现），效率更高。

---

### 题解二：破忆（K-D Tree）
- **亮点**：  
  使用 **K-D Tree** 直接维护二维空间，支持高效查询每个点的 **最近/最远曼哈顿距离**。  
  - **剪枝优化**：利用 **估价函数** 提前终止无效搜索（如 `dis2` 计算最远点）。  
  - **时间复杂度**：\( O(N \log N) \) 平均，最坏 \( O(N^2) \)（但数据随机时表现优秀）。

---

### 题解三：Wilderness_（人类智慧优化）
- **亮点**：  
  发现 **曼哈顿距离最大值** 可直接由四个全局极值计算（\( O(1) \)），而 **最小值** 只需检查 **附近500个点**（启发式优化）。  
  - **时间复杂度**：\( O(N \times 500) \)，实际运行极快（670ms）。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：K-D Tree）

1. **关键点1：曼哈顿距离拆分**  
   - **分析**：将 \( |x_i - x_j| + |y_i - y_j| \) 拆分为四个线性表达式：  
     \[
     \max \{(x_i + y_i) - (x_j + y_j), (x_i - y_i) - (x_j - y_j), \dots\}
     \]  
   - **学习笔记**：拆分后，问题转化为 **维护四个方向的一维极值**。

2. **关键点2：K-D Tree 构建与查询**  
   - **分析**：  
     - **构建**：按维度交替排序（如先按 \( x \)，再按 \( y \)），递归构建平衡二叉树。  
     - **查询**：对每个点 \( p_i \)，在树中搜索 **最近/最远点**，利用 **估价函数** 剪枝。  
   - **学习笔记**：K-D Tree 是处理高维空间极值问题的利器！

3. **关键点3：剪枝优化**  
   - **分析**：  
     - **最近点剪枝**：若当前区间到 \( p_i \) 的最小可能距离 ≥ 已知最小值，跳过该区间。  
     - **最远点剪枝**：类似逻辑，但判断最大可能距离。  
   - **学习笔记**：剪枝是 K-D Tree 高效的核心！

---

### ⚔️ 策略竞技场：不同解法对比

| 策略               | 核心思想                     | 优点                     | 缺点                     | 适用场景               |
|--------------------|------------------------------|--------------------------|--------------------------|------------------------|
| **暴力枚举**       | 直接计算所有点对距离         | 思路简单                 | \( O(N^2) \)，无法通过   | \( N \leq 10^3 \)      |
| **曼哈顿拆分+线段树** | 拆分为四个线性表达式         | 时间稳定 \( O(N \log N) \) | 需离散化，代码较长       | 通用高效解法           |
| **K-D Tree**       | 高维空间最近/最远点查询      | 平均 \( O(N \log N) \)    | 最坏 \( O(N^2) \)        | 高维问题通用模板       |
| **人类智慧优化**   | 局部枚举附近点               | 实际运行极快             | 理论复杂度不严谨         | 数据随机或竞赛卡常     |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（K-D Tree）
- **说明**：综合破忆与ModestCoder_的题解，提供完整K-D Tree实现。
- **完整核心代码**：
  ```cpp
  #include <bits/stdc++.h>
  using namespace std;
  const int MAXN = 1e5 + 10;
  const int INF = 1e9;

  struct Point {
      int x, y;
  } p[MAXN];

  int n, ans = INF;

  // K-D Tree 节点
  struct Node {
      Point p;
      int min[2], max[2]; // 区间边界
      int l, r;
  } tree[MAXN];

  int root, D; // 当前分割维度

  bool cmp(const Point &a, const Point &b) {
      return D ? a.y < b.y : a.x < b.x;
  }

  // 更新区间边界
  void pushup(int x) {
      for (int i = 0; i < 2; ++i) {
          tree[x].min[i] = tree[x].max[i] = tree[x].p.x + (i ? tree[x].p.y : 0);
          if (tree[x].l) {
              tree[x].min[i] = min(tree[x].min[i], tree[tree[x].l].min[i]);
              tree[x].max[i] = max(tree[x].max[i], tree[tree[x].l].max[i]);
          }
          if (tree[x].r) {
              tree[x].min[i] = min(tree[x].min[i], tree[tree[x].r].min[i]);
              tree[x].max[i] = max(tree[x].max[i], tree[tree[x].r].max[i]);
          }
      }
  }

  // 构建K-D Tree
  int build(int l, int r, int d) {
      if (l > r) return 0;
      int mid = (l + r) >> 1;
      D = d;
      nth_element(p + l, p + mid, p + r + 1, cmp);
      tree[mid].p = p[mid];
      tree[mid].l = build(l, mid - 1, d ^ 1);
      tree[mid].r = build(mid + 1, r, d ^ 1);
      pushup(mid);
      return mid;
  }

  // 计算曼哈顿距离
  int dis(const Point &a, const Point &b) {
      return abs(a.x - b.x) + abs(a.y - b.y);
  }

  // 最近点估价函数
  int min_dis(const Point &a, int x) {
      int res = 0;
      for (int i = 0; i < 2; ++i) {
          res += max(0, tree[x].min[i] - (i ? a.y : a.x));
          res += max(0, (i ? a.y : a.x) - tree[x].max[i]);
      }
      return res;
  }

  // 最远点估价函数
  int max_dis(const Point &a, int x) {
      int res = 0;
      for (int i = 0; i < 2; ++i) {
          res += max(abs(a.x - tree[x].min[0]), abs(a.x - tree[x].max[0]));
          res += max(abs(a.y - tree[x].min[1]), abs(a.y - tree[x].max[1]));
      }
      return res;
  }

  // 查询最近点
  void query_min(int x, const Point &a, int &cur_min) {
      if (!x) return;
      if (x != 0 && !(tree[x].p.x == a.x && tree[x].p.y == a.y)) {
          cur_min = min(cur_min, dis(a, tree[x].p));
      }
      int dl = min_dis(a, tree[x].l);
      int dr = min_dis(a, tree[x].r);
      if (dl < dr) {
          if (dl < cur_min) query_min(tree[x].l, a, cur_min);
          if (dr < cur_min) query_min(tree[x].r, a, cur_min);
      } else {
          if (dr < cur_min) query_min(tree[x].r, a, cur_min);
          if (dl < cur_min) query_min(tree[x].l, a, cur_min);
      }
  }

  // 查询最远点
  void query_max(int x, const Point &a, int &cur_max) {
      if (!x) return;
      if (x != 0) {
          cur_max = max(cur_max, dis(a, tree[x].p));
      }
      int dl = max_dis(a, tree[x].l);
      int dr = max_dis(a, tree[x].r);
      if (dl > dr) {
          if (dl > cur_max) query_max(tree[x].l, a, cur_max);
          if (dr > cur_max) query_max(tree[x].r, a, cur_max);
      } else {
          if (dr > cur_max) query_max(tree[x].r, a, cur_max);
          if (dl > cur_max) query_max(tree[x].l, a, cur_max);
      }
  }

  int main() {
      ios::sync_with_stdio(false);
      cin.tie(nullptr);
      cin >> n;
      for (int i = 1; i <= n; ++i) {
          cin >> p[i].x >> p[i].y;
      }
      root = build(1, n, 0);
      for (int i = 1; i <= n; ++i) {
          int min_d = INF, max_d = -INF;
          query_min(root, p[i], min_d);
          query_max(root, p[i], max_d);
          ans = min(ans, max_d - min_d);
      }
      cout << ans << endl;
      return 0;
  }
  ```

---

## 5. 算法可视化：像素动画演示

### **动画主题**：“像素探险家”在二维迷宫中寻找宝藏（K-D Tree搜索）

- **场景设计**：  
  - **8位像素风格**：网格地图，每个点为像素方块，颜色区分不同区域。  
  - **数据结构可视化**：K-D Tree的二维分割用 **交替的蓝色/红色分割线** 表示，节点用闪烁的像素星星标记。

- **核心演示**：  
  1. **构建K-D Tree**：  
     - 交替按 \( x \) 和 \( y \) 排序，分割线动态出现，节点高亮。  
     - **音效**：每次分割播放“叮”声。  
  2. **查询最近点**：  
     - 从根节点开始，像素箭头移动，剪枝区域用灰色覆盖。  
     - **音效**：剪枝时播放“咻”声，找到最近点时播放“胜利”音效。  
  3. **查询最远点**：  
     - 类似最近点，但估价函数用黄色高亮潜在最远区域。

- **交互设计**：  
  - **步进控制**：用户可单步查看分割和查询过程。  
  - **AI演示**：自动播放完整搜索路径，类似“贪吃蛇AI”。

---

## 6. 拓展练习与相似问题思考

### **通用技巧迁移**：
- **曼哈顿距离拆分**：适用于所有曼哈顿极值问题，如：  
  1. **最近邻搜索**（K-D Tree模板）。  
  2. **最小生成树**（曼哈顿距离MST）。  
  3. **几何优化**（如最小覆盖圆）。

### **洛谷推荐练习**：
1. **P6247** - [最近最远点对](https://www.luogu.com.cn/problem/P6247)  
   - 🗣️ **推荐理由**：巩固K-D Tree的极值查询，理解估价函数设计。  
2. **P4169** - [Violet的樱花](https://www.luogu.com.cn/problem/P4169)  
   - 🗣️ **推荐理由**：曼哈顿距离拆分的经典应用，需离散化和线段树。  
3. **P4390** - [GCD与LCM](https://www.luogu.com.cn/problem/P4390)  
   - 🗣️ **推荐理由**：二维偏序的CDQ分治，深化分治思想。

---

## 7. 学习心得与经验分享

> **来自破忆的调试心得**：  
> “最初在K-D Tree的估价函数上卡了很久，后来发现剪枝条件必须严格比较 **当前最优值** 与 **区间可能值**，否则会漏解。建议用 **assert** 检查每个点的极值是否正确！”

---

### 💡 洛语云笺的总结
本题是 **高维空间极值问题** 的经典案例，核心在于 **曼哈顿距离的数学转化** 和 **数据结构的高效查询**。无论是K-D Tree的优雅，还是线段树的巧妙，都体现了 **问题建模** 的重要性。记住：优秀的算法源于对问题本质的深刻洞察！

---
处理用时：100.62秒
# 题目信息

# 白金莲花池

## 题目背景

为了让奶牛们娱乐和锻炼，农夫约翰建造了一个美丽的池塘。这个长方形的池子被分成了 $M$ 行 $N$ 列个方格（$1≤M,N≤30$）。一些格子是坚固得令人惊讶的莲花，还有一些格子是岩石，其余的只是美丽、纯净、湛蓝还可能掩藏着宝藏的水。

贝西正在练习芭蕾舞，她站在一朵莲花上，想跳到另一朵莲花上去，她只能从一朵莲花跳到另一朵莲花上，既不能跳到水里，也不能跳到岩石上。

贝西的舞步很像象棋中的马步：每次总是先横向移动一格，再纵向移动两格，或先纵向移动两格，再横向移动一格。最多时，贝西会有八个移动方向可供选择。

约翰一直在观看贝西的芭蕾练习，发现她有时候不能跳到终点，因为中间缺了一些荷叶。于是他想要添加几朵莲花来帮助贝西完成任务，当然莲花不能种在岩石上。


## 题目描述

但是！约翰在种植莲花的时候发现了一件很有趣的事，有些格子是不能直接种植莲花的，原因是……实不相瞒，无法直接种植莲花的格子的泥土中大部分都是货真价实的铂金，正是它们妨碍了莲花的正常生长！而恰好约翰刚刚学到了铂金的开采方法，也有相关的开采工具，而且他还发现开采铂金后的格子就可以正常地种植莲花，不必担心泥土缺失的问题。（由于贝西迫切地想练习，所以约翰不会开采不打算种莲花的铂金格子）

开采铂金很累，就像是种植莲花一样累，它们都会消耗掉约翰 $1$ 点体力（也就是说想把铂金格子变成莲花格子需要 $2$ 点体力），约翰最初有 $P$ 点体力来种植莲花或开采铂金。

请帮助约翰计算至少需要消耗多少体力才能帮助贝西完成任务，这个数字记作 $S$，以及有多少种消耗这些体力的方法能帮助贝西完成任务，这个数字记作 $W_S$；铂金当然是越多越好，请计算在消耗 $S$ 点体力帮助贝西完成任务的同时最多能开采多少铂金，这个数字记作 $G$，以及消耗 $S$ 点体力开采 $G$ 块铂金帮助贝西完成任务的方法数，这个数字记作 $W_G$。

若在 $P$ 点体力内无法帮助到贝西，那么只输出 `-1`。

若在 $S$ 点体力内无法开采铂金，那么第二行只输出 `-1`。

## 说明/提示

约翰可以用开采到的铂金小赚一笔，但如果用多余的体力开采铂金而不往上种莲花的话贝西会很生气！


## 样例 #1

### 输入

```
4 5 6
0 0 0 1 0 0
2 0 0 2 0 0
0 0 5 0 0 0
3 0 0 0 4 0
0 0 2 0 0 0```

### 输出

```
2 2
1 1```

## 样例 #2

### 输入

```
3 3 2
3 5
4 2
0 1```

### 输出

```
-1```

# AI分析结果

# 💡 洛语云笺的C++算法解析：白金莲花池 深入学习指南 💡

> 同学们好！今天我们要一起潜入一个 8×8 像素的池塘，帮奶牛贝西完成一场“芭蕾舞大冒险”。题目看起来像在种莲花、挖铂金，但真正的战场其实是一张 **有向带权图** 和一次 **多目标最短路** 之旅。准备好像素探险了吗？

---

## 1. 题目解读与策略初探

✨ **核心挑战**  
把“马步跳格子 + 莲花/岩石/铂金 + 体力限制”翻译成图论语言：  
> **在一张最多 30×30=900 个点的图上，求从起点到终点的最短路长度 S，并在所有 S 的方案中统计：  
> ① 总方案数 W_S；② 沿最短路开采铂金的块数最大值 G；③ 开采 G 块铂金的方案数 W_G。**  
体力 P 只是对最短路长度 S 的一个上限。

✨ **核心算法标签**  
最短路 (Dijkstra) + 多维度状态附加信息（方案数、铂金数）

🗣️ **思路演进路径**  
1. 朴素 BFS：只考虑 0/1 边权可行，但铂金边权为 2，直接失效。  
2. 0-1 BFS：边权只有 0 或 1，可 O(V+E)。本题有 0/1/2 三种边权，仍不适用。  
3. **Dijkstra 多目标扩展**：边权任意正整数，天然支持附加维度（方案数、铂金数）。  
   → 这就是我们的“像素探险船”！

🔍 算法侦探：如何在题目中发现线索？  
| 线索 | 发现 | 作用 |
|---|---|---|
| 棋盘格 + 8 方向马步 | 隐式图，最多 900 点 | 图论模型 |
| “最少体力” | 最优化问题，边权 1 或 2 | 最短路 |
| “多少种方法” | 计数问题 | 在松弛时同步累加 |
| “最多铂金” | 第二维最优化 | 再次松弛并维护 |

🧠 思维链构建  
> 把每个格子看作图节点；从每朵可立足的莲花/铂金出发，DFS 枚举 8 方向能跳到的格子，建立有向边：  
> - 跳到水 → 边权 1（种莲花 1 体力）  
> - 跳到岩石 → 不建边（不可达）  
> - 跳到铂金 → 边权 2（开采 1 + 种莲花 1 共 2 体力）  
> 建好图后，跑 **Dijkstra**，同时维护 3 个附加数组：  
> - `f[u]`：到 u 的最短路方案数  
> - `pt[u]`：在同样最短路长度下，能开采的最大铂金数  
> - `g[u]`：开采 `pt[u]` 块铂金的方案数  

---

## 2. 精选优质题解参考

**题解来源：251Sec (赞：6)**  
* **点评**：  
  这篇题解思路极其精炼——把复杂棋盘转化为图后，直接套用最短路模板。  
  - **建图技巧**：用 DFS 从每个可立足点向外“跳马步”，一次性把所有可达边建好，避免重复 BFS。  
  - **多维度松弛**：在 Dijkstra 的 `if (d[v] == d[u] + w)` 分支里，同时累加方案数、更新最大铂金数，实现“一次遍历，三个答案”。  
  - **代码规范**：宏 `pid(x,y)` 优雅地把二维坐标压成一维，降低出错率；优先队列重载 `<` 实现最小堆。  
  这份代码可直接用于竞赛，对 900 点、数千条边的稀疏图完全无压力。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| 1. 建图：隐式图转显式 | 每格当节点，8 方向 DFS 连边；水=1，铂金=2 | 把棋盘题先“拍平”成邻接表，后续算法才能复用模板 |
| 2. 多目标松弛 | 经典 Dijkstra 中，除了更新最短路长度，还要： <br> - 长度相等 → 累加方案数 <br> - 长度相等且铂金更多 → 更新最大铂金并重置方案数 <br> - 长度更短 → 全部覆盖 | 一次松弛解决“最值+计数”组合问题，是图论常见套路 |
| 3. 空间与时间 | 总点数 ≤ 900，总边数 ≤ 900×8 ≈ 7.2×10³，Dijkstra O((V+E)logV) 轻松过 | 30×30 棋盘题经常可以用“暴力建图 + 最短路”秒杀 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| 多源 BFS（0-1 权） | 边权只有 0/1 时用双端队列 | O(V+E) | 本题有 0/1/2 三种权值，不适用 | 边权只有 0/1 |
| **Dijkstra + 附加维度** | 经典最短路，额外维护计数 & 最值 | 通用、简洁、易扩展 | log 因子略慢 | 本题最优，100% |
| SPFA | 队列优化的 Bellman-Ford | 平均快 | 最坏 O(VE)，棋盘图易被卡 | 不推荐 |

### ✨ 优化之旅  
> 从“暴力枚举每条路径”到“Dijkstra 一次搞定”，我们经历了：  
> 1. 发现棋盘转图 → 2. 发现边权非 0/1 → 3. 选择 Dijkstra → 4. 附加维度同步维护。  
> 这告诉我们：先建模，再选算法，最后才谈优化。

---

## 4. C++核心代码实现赏析

**通用核心实现参考**  
*说明*：综合 251Sec 代码，去掉冗余注释，保留最清晰的核心逻辑。  
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MAXN = 35, MAXV = 905;
const int dx[8] = {2,2,-2,-2,1,1,-1,-1};
const int dy[8] = {1,-1,1,-1,2,-2,2,-2};

int m, n, P;
int mp[MAXV], id(int x,int y){ return (x-1)*n + (y-1); }

struct Edge { int v, w, nxt; } e[20005];
int head[MAXV], tot = 0;
void add(int u,int v,int w){
    e[++tot] = {v,w,head[u]}; head[u] = tot;
}

int sx, sy, tx, ty;
bool vis[MAXV], mkd[MAXV];

// 建图：从(rx,ry)出发，把所有可达点连边
void dfs(int x,int y,int rx,int ry){
    vis[id(x,y)] = true;
    for(int k=0;k<8;k++){
        int nx = x + dx[k], ny = y + dy[k];
        if(nx<1||nx>m||ny<1||ny>n) continue;
        int nid = id(nx,ny);
        if(mp[nid]==0){                // 水
            if(!mkd[nid]) add(id(rx,ry), nid, 1);
        }else if(mp[nid]==4){          // 岩石
            if(!mkd[nid]) add(id(rx,ry), nid, 0);
        }else if(mp[nid]==5){          // 铂金
            if(!mkd[nid]) add(id(rx,ry), nid, 2);
        }else if(mp[nid]==1){          // 莲花
            if(!vis[nid]) dfs(nx,ny,rx,ry);
        }
        mkd[nid] = true;
    }
}

int d[MAXV], pt[MAXV];          // d:最短路长度  pt:最大铂金
ll  f[MAXV], g[MAXV];           // f:最短路方案数 g:最大铂金方案数
struct Node{ int u, dis; bool operator<(const Node&o)const{ return dis>o.dis; } };

void dijkstra(){
    priority_queue<Node> pq;
    memset(d, 0x3f, sizeof d);
    int sid = id(sx,sy);
    d[sid] = 0; f[sid] = 1; g[sid] = 1; pt[sid] = 0;
    pq.push({sid,0});
    while(!pq.empty()){
        int u = pq.top().u; pq.pop();
        for(int i=head[u]; i; i=e[i].nxt){
            int v = e[i].v, w = e[i].w;
            if(d[v] == d[u]+w){
                f[v] += f[u];
                int npt = pt[u] + (w==2);
                if(npt == pt[v]) g[v] += g[u];
                else if(npt > pt[v]){ pt[v] = npt; g[v] = g[u]; }
            }else if(d[v] > d[u]+w){
                d[v] = d[u]+w;
                f[v] = f[u];
                pt[v] = pt[u] + (w==2);
                g[v] = g[u];
                pq.push({v,d[v]});
            }
        }
    }
}

int main(){
    scanf("%d%d%d",&P,&m,&n);
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++){
            scanf("%d",&mp[id(i,j)]);
            if(mp[id(i,j)]==3){ sx=i; sy=j; mp[id(i,j)]=0; }
            if(mp[id(i,j)]==4){ tx=i; ty=j; }
        }
    // 建图
    for(int i=1;i<=m;i++)
        for(int j=1;j<=n;j++){
            memset(vis,0,sizeof vis);
            memset(mkd,0,sizeof mkd);
            if(mp[id(i,j)]==0 || mp[id(i,j)]==5) dfs(i,j,i,j);
        }
    dijkstra();
    int tid = id(tx,ty);
    if(d[tid] > P){ puts("-1"); return 0; }
    printf("%d %lld\n", d[tid], f[tid]);
    if(pt[tid]==0){ puts("-1"); return 0; }
    printf("%d %lld\n", pt[tid], g[tid]);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

* **主题**：8-bit “莲花跳跃大冒险”  
* **场景**：30×30 像素网格，蓝=水，绿=莲花，灰=岩石，金=铂金，奶牛像素小人在起点。  
* **演示核心**：Dijkstra 的“像素优先队列”如何一步步扩展最短路径。  

**动画步骤设计**  
1. **初始化**：网格加载，奶牛在 `(sx,sy)` 闪烁。  
2. **建图闪光**：从奶牛脚下射出 8 方向像素箭头，碰到水→蓝箭头(边权1)，碰到铂金→金箭头(边权2)。  
3. **Dijkstra 队列**：右侧竖条显示“像素堆”，节点按距离升序排队，当前弹出节点高亮红框。  
4. **松弛动画**：  
   - 若 `d[v]` 更新 → 节点 v 闪白光，距离数字滚动到更小值，伴随“叮”音效。  
   - 若 `f[v]` 累加 → 节点 v 出现像素“+1”气泡。  
   - 若 `pt[v]` 更新 → 节点 v 变成金色边框，伴随“金币”音效。  
5. **终点达成**：奶牛像素小人跳到 `(tx,ty)`，屏幕出现 8-bit “Victory!” 横幅，同时展示答案四元组。  

* **交互**：提供“单步 / 自动 / 调速”按钮；支持“显示路径回溯”模式，用黄色像素轨迹高亮最短路径。

---

## 6. 拓展练习与相似问题思考

* **通用套路迁移**：  
  1. **棋盘 → 图**：马步、象步、车步等棋盘移动，都可先建图再用最短路 / 网络流。  
  2. **多目标最短路**：求最短 + 计数 + 附加最值（如最大收益、最少转弯），统一在松弛阶段维护额外维度即可。  
  3. **分层图思想**：把“开采后再走”看作两层节点，边权跨层；本题用边权 2 即可等价实现。

* **洛谷推荐**  
  1. **P1606 莲花池** —— 本题弱化版，练手建图 + 最短路。  
  2. **P1144 最短路计数** —— 纯计数，无附加维度，适合巩固松弛时累加方案数。  
  3. **P4568 旅行路线** —— 分层图最短路，体会“分层”与“附加维度”异曲同工之妙。

---

## 7. 学习心得与经验分享

251Sec 在题解中轻描淡写一句 *“所以我昨天为什么闲的没事在那里敲 A*”* —— 这提醒我们：  
> 面对 30×30 小图，**优先选择复杂度正确且实现简洁的算法**（Dijkstra），而非盲目上高级搜索。  
> 先把问题建模准确，再谈优化，才是高效备赛的正确姿势。

---

<conclusion>
今天我们从“像素池塘”一路跳到“最短路之巅”。记住：  
1. 棋盘题先拍平成图；2. 最短路可携带“外挂维度”；3. 选对算法，再谈花式优化。  
下次探险见！💪
</conclusion>

---
处理用时：69.66秒
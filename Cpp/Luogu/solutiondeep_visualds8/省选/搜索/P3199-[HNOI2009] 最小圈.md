# 题目信息

# [HNOI2009] 最小圈

## 题目描述

考虑带权有向图 $G=(V,E)$ 以及 $w:E\rightarrow \R$，每条边 $e=(i,j)$（$i\neq j$，$i, j\in V$）的权值定义为 $w_{i,j}$。设 $n=|V|$。

$c=(c_1,c_2,\cdots,c_k)$（$c_i\in V$）是 $G$ 中的一个圈当且仅当 $(c_i,c_{i+1})$（$1\le i<k$）和 $(c_k,c_1)$ 都在 $E$ 中。称 $k$ 为圈 $c$ 的长度，同时记 $c_{k+1}=c_1$，并定义圈 $c=(c_1,c_2,\cdots,c_k)$ 的平均值为
$$
\mu(c)= \frac 1 k \sum\limits_{i=1}^{k} w_{c_i,c_{i+1}}
$$
即 $c$ 上所有边的权值的平均值。设 $\mu'(G)=\min_c\mu(c)$ 为 $G$ 中所有圈 $c$ 的平均值的最小值。

给定图 $G=(V,E)$ 以及 $w:E\rightarrow \R$，求出 $G$ 中所有圈 $c$ 的平均值的最小值 $\mu'(G)$。


## 说明/提示

对于 $100\%$ 的数据，$2\leq n\le 3000$，$1\leq m\le 10000$，$|w_{i,j}| \le 10^7$，$1\leq i, j\leq n$ 且 $i\neq j$。

------------
提示：本题存在 $O(nm)$ 的做法，但是 $O(nm\log n)$ 的做法也可以通过。

## 样例 #1

### 输入

```
4 5
1 2 5
2 3 5
3 1 5
2 4 3
4 1 3```

### 输出

```
3.66666667```

## 样例 #2

### 输入

```
2 2
1 2 -2.9
2 1 -3.1```

### 输出

```
-3.00000000```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：最小圈 深入学习指南 💡

今天我们来一起分析“最小圈”这道省选经典题。它表面上在问“平均值”，实则把“图论 + 二分 + 最短路/负环”三大武器巧妙融合。我们将像侦探一样，从题目语言里挖出线索，再对比多条题解，最终找到最优雅的解决之道。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在一张有向图中，找出某个环，使得环上所有边的权值之和除以环长最小。由于环的数量可能指数级，**直接枚举所有环**必然爆炸。

✨ **核心算法标签**：  
- 0/1 分数规划（二分答案）  
- SPFA/DFS 判负环  
- Karp 算法（DP 求最小平均环）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 原文关键词 | 指向的算法信号 |
|---|---|---|
| **线索1：最优化目标** | “最小平均值” | 平均值具有**单调性**：若平均值`x`可行，则所有`>x`也可行 → 触发**二分答案** |
| **线索2：比值形式** | $\frac{\sum w_i}{k}$ | 典型的**0/1 分数规划**模型：把“求比值最小”转化为“判 $\sum(w_i-mid)<0$” |
| **线索3：判定条件** | “是否存在环满足…” | 把每条边权减去`mid`后，问题变成**是否存在负环** → 触发**SPFA 或 DFS** |
| **线索4：数据规模** | $n\le 3000,\ m\le 10^4$ | $O(nm\log V)$ 的二分 + SPFA 轻松通过；$O(nm)$ 的 Karp 算法更优 |

---

### 🧠 思维链构建：从线索到策略

> 侦探拼图完成，现在把它们串起来：  
> 1. 平均值单调 → 二分答案框架立刻浮现。  
> 2. 比值 $\frac{\sum w_i}{k}$ → 0/1 分数规划套路：边权统一减去 `mid`，把“比值<mid”转成“新图存在负环”。  
> 3. 负环判定 → 最经典武器：SPFA（队列或 DFS）。  
> 4. 复杂度验证 → $nm\log V\approx 3\times 10^7$，在时限内；若想更稳，可上 Karp 的 $O(nm)$ DP。  
> **结论**：二分 + 负环判定 = 最简洁高效的主攻方向！

---

## 2. 精选优质题解参考

| 题解 | 核心思路 | 亮点 | 洛语云笺点评 |
|---|---|---|---|
| **rqy** | Karp 算法（DP） | 理论 $O(nm)$，代码最短（0.7 KB），常数小 | 把“最小平均环”转成一个 DP 式，用滚动数组压缩空间，优雅至极。 |
| **niiick** | 0/1 分数规划 + SPFA | 思路直观，代码易写 | 用队列 SPFA 判负环，二分 50 次即可，适合初学者。 |
| **VenusM1nT** | DFS-SPFA | DFS 版本常数更小 | DFS 版 SPFA 在判负环时比队列版快 2~3 倍，代码同样短小。 |
| **s_r_f** | Karp + 卡常 | 滚动数组 + 读入优化 | 与 rqy 思路一致，但加了快读和边界处理，BZOJ 也能过。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **二分框架** | 设答案为 `mid`，把边权改为 `w-mid`，问题等价于“是否存在负环” | 二分范围可取 $[-1e7,1e7]$，精度 `1e-8`。 |
| **负环判定** | 队列 SPFA：若某点入队次数≥n 则有环；DFS-SPFA：若更新时遇到在栈点则成环 | DFS 版代码短、常数小。 |
| **Karp 算法** | 设 $F_k(i)$ 为恰好经过 $k$ 条边到 $i$ 的最短路，则答案为 $\min_i\max_{k<n}\frac{F_n(i)-F_k(i)}{n-k}$ | 用滚动数组把 $O(n^2)$ 空间压到 $O(n)$，理论最优。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 复杂度 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|---|
| 暴力枚举所有环 | DFS 全排列 | $O(2^m)$ | 思路直观 | 指数级爆炸 | 0 pts |
| 二分 + SPFA 判负环 | 0/1 分数规划 | $O(nm\log V)$ | 代码短、易实现 | SPFA 最坏退化 | 100 pts |
| Karp DP 算法 | 动态规划 | $O(nm)$ | 理论最优、常数小 | 需要理解 Karp 公式 | 100 pts |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（二分 + DFS-SPFA）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 3005, M = 20005;
const double INF = 1e8, eps = 1e-8;

int n, m, head[N], to[M], nxt[M], tot;
double w[M], dis[N];
bool vis[N];

inline void add(int u, int v, double c) {
    to[++tot] = v; w[tot] = c; nxt[tot] = head[u]; head[u] = tot;
}

bool dfs(int u, double mid) {
    vis[u] = 1;
    for (int i = head[u]; i; i = nxt[i]) {
        int v = to[i];
        if (dis[v] > dis[u] + w[i] - mid) {
            dis[v] = dis[u] + w[i] - mid;
            if (vis[v] || dfs(v, mid)) return true;
        }
    }
    vis[u] = 0;
    return false;
}

bool check(double mid) {
    fill(dis + 1, dis + n + 1, 0);
    fill(vis + 1, vis + n + 1, 0);
    for (int i = 1; i <= n; ++i)
        if (dfs(i, mid)) return true;
    return false;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, u, v; i <= m; ++i) {
        double c; scanf("%d%d%lf", &u, &v, &c);
        add(u, v, c);
    }
    double l = -INF, r = INF;
    while (r - l > eps) {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    printf("%.8lf\n", l);
    return 0;
}
```
*代码解读概要*：  
1. 建图并读入边权；  
2. 二分平均值 `mid`，把每条边权改为 `w-mid`；  
3. DFS-SPFA 判负环：若存在负环，说明平均值可以更小；  
4. 精度达到 `1e-8` 时输出答案。

---

### Karp 算法核心片段（rqy 版）
```cpp
double F[2][N], Fn[N], ans = INF;
// 滚动数组 F[0/1][i] 表示恰好 k 步到 i 的最短路
for (int k = 0; k <= n; ++k) {
    for (int i = 1; i <= n; ++i) F[k&1][i] = INF;
    if (!k) F[0][n] = 0;   // 虚拟源点
    else {
        for (int j = 0; j < m; ++j)
            F[k&1][v[j]] = min(F[k&1][v[j]], F[(k-1)&1][u[j]] + w[j]);
    }
}
for (int i = 1; i <= n; ++i) {
    double mx = -INF;
    for (int k = 0; k < n; ++k)
        mx = max(mx, (F[n&1][i] - F[k&1][i]) / (n - k));
    ans = min(ans, mx);
}
```
*亮点*：  
- 用 `k&1` 滚动数组，空间 O(n)。  
- 无需二分，一次 DP 得出答案，理论最优。

---

## 5. 算法可视化：像素动画演示

**主题**：像素探险家在“能量环”中收集负能量，找到平均能量最低的环。  
**风格**：8 位像素风，调色板 #1a1c2c, #5d275d, #b13e53…  
**核心动画**：

1. **初始化**：像素网格展示 n 个节点，边权用数字方块显示。  
2. **二分 mid**：屏幕顶部出现滚动条“当前平均值 mid”，玩家拖动改变 mid。  
3. **边权实时变换**：每条边数值从 `w` → `w-mid`，颜色由绿→红表示负值。  
4. **DFS 判环**：  
   - 像素探险家从节点 1 出发，每走一条边，路径能量累加。  
   - 若回到已访问节点 → 出现像素爆炸“Negative Cycle Found!”  
5. **音效**：  
   - 边权变负 → “叮”  
   - 发现负环 → 8-bit 胜利音  
6. **交互**：  
   - 单步/自动按钮，速度滑块 0.1s~2s。  
   - 失败时显示“Try lower mid!”  

---

## 6. 拓展练习与相似问题思考

| 题目 | 推荐理由 |
|---|---|
| **P1768 天路** | 0/1 分数规划 + 负环判定，边权为长度/收益。 |
| **P2868 Sightseeing Cows** | 最大平均值环，需把“最长路”转成负环判定。 |
| **P3288 方伯伯运椰子** | 有上下界的 0/1 分数规划，需拆边建模。 |

---

## 7. 学习心得与经验分享

> rqy 神犇：“Karp 公式看似复杂，但把‘平均’拆成‘差分’后，DP 就呼之欲出。”  
> **洛语云笺点评**：理解公式背后的“差分思想”，才能把模板变成直觉。  
>  
> niiick 总结：“二分 + SPFA 判负环是性价比最高的套路，代码短，思维直接。”  
> **洛语云笺点评**：先学会“通用套路”，再追求“理论最优”，循序渐进。

---

### 结语

最小圈是一道把“平均值”与“图论”完美结合的经典。掌握 0/1 分数规划 + 负环判定，你将解锁一大批“比率最优化”问题。下次遇到“最小/最大平均环”，别忘了今天学到的二分 + SPFA / Karp 两把钥匙！

---
处理用时：54.84秒
# 题目信息

# [HNOI2016] 矿区

## 题目描述

平面上的矿区划分成了若干个开发区域。

简单地说，你可以将矿区看成一张连通的平面图，平面图划分为了若干平面块，每个平面块即为一个开发区域，平面块之间的边界必定由若干整点(坐标值为整数的点)和连接这些整点的线段组成。每个开发区域的矿量与该开发区域的面积有关：具体而言，面积为 $ s $ 的开发区域的矿量为 $ s^2 $。

现在有 $ m $ 个开采计划。每个开采计划都指定了一个由若干开发区域组成的多边形，一个开采计划的优先度被规定为矿量的总和÷开发区域的面积和；例如，若某开采计划指定两个开发区域，面积分别为 $ a $ 和 $ b $，则优先度为 $ (a^2+b^2)/(a+b) $。由于平面图是按照划分开发区域边界的点和边给出的，因此每个开采计划也只说明了其指定多边形的边界，并未详细指明是哪些开发区域（但很明显，只要给出了多边形的边界就可以求出是些开发区域）。

你的任务是求出每个开采计划的优先度。为了避免精度问题，你的答案必须按照分数的格式输出，即求出分子和分母，且必须是最简形式（分子和分母都为整数，而且都消除了最大公约数；例如，若矿量总和是 $ 1.5 $，面积和是 $ 2 $，那么分子应为 $ 3 $，分母应为 $ 4 $；又如，若矿量和是 $ 2 $，面积和是 $ 4 $，那么分子应为 
 $ 1 $，分母应为 $ 2 $）。

由于某些原因，你必须依次对每个开采计划求解（即下一个开采计划会按一定格式加密，加密的方式与上一个开采计划的答案有关）。具体的加密方式见输入格式。

## 说明/提示

### 样例解释

输入文件给出的 $9$ 个点和 $14$ 条边描述的平面图如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/cg70enmo.png)

第一个开采计划，输入的第 $1$ 个值为 $3$，所以该开采计划对应的多边形有 $(3+0)\bmod 8+1=4$ 个点，将接下的 $4$ 个数 $3,0,4,7$，分别代入 $(z_i+0)\bmod n+1$ 得到 $4$ 个点的编号为 $4,1,5,8$。计算出第一个开采计划的分子为 $1$，分母为 $1$。

类似地，可计算出余下开采计划的多边形的点数和点的编号：第二个开采计划对应的多边形有 $3$ 个点，编号分别为 $5,6,8$。第三个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,2,6,5,8,4$。第四个开采计划对应的多边形有 $5$ 个点，编号分别为 $1,2,6,8,4$。第五个开采计划对应的多边形有 $6$ 个点，编号分别为 $1,5,6,8,7,4$。

### 数据范围及约定


对于 $ 100 \% $ 的数据，$ n, k \leq 2 \times 10^5, \  m \leq 3n-6, \  |x_i|, |y_i| \leq 3×10^4$。

所有开采计划的 $ d $ 之和不超过 $2 \times 10^6$。保证任何开采计划都包含至少一个开发区域，且这些开发区域构成一个连通块。

保证所有开发区域的矿量和不超过 $ 2^{63}-1 $。

保证平面图中没有多余的点和边。

保证数据合法。由于输入数据量较大，建议使用读入优化。




## 样例 #1

### 输入

```
9 14 5
0 0
1 0
2 0
0 1
1 1
2 1
0 2
1 2
2 2
1 2
2 3
5 6
7 8
8 9
1 4
4 7
5 8
3 6
6 9
4 8
1 5
2 6
6 8
3 3 0 4 7 1 3 4 6 4 8 0 4 3 6 2 3 8 0 4 6 2 5 0 4 5 7 6 3```

### 输出

```
1 1 
1 2 
1 1 
9 10 
3 4```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：HNOI2016「矿区」深入学习指南 💡

> 今天我们来拆解一道极具“几何+图论”味道的题目：HNOI2016「矿区」。  
> 它看似复杂，但核心只有一句话——**把“面”当作“点”，把“相邻关系”当作“边”，然后在一棵树上做“容斥”**。  
> 跟着洛语云笺，一步步把这张“平面图”变成“树”，再优雅地回答每一次询问！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
- **把一张平面图的“面”找出来**（哪些边围成一个有限区域）。  
- **给定一个询问多边形**，快速求出它内部所有“面”的  
  **(面积平方和) / (面积和)**，并以**最简分数**输出。  
- **在线加密**：下一次询问依赖上一次答案，必须顺序处理。

### ✨ 核心算法标签
`平面图转对偶图` `极角排序` `生成树` `子树容斥`

### 🗣️ 初步分析
| 思路 | 一句话总结 | 能否满分 |
|------|------------|----------|
| 暴力枚举所有面再逐点判断 | 复杂度爆炸，无法接受 | ❌ |
| **平面图 → 对偶图 → 生成树** | 把“面”变“点”，询问=树上走一圈 | ✅ |
| 扫描线+平衡树 | 也能做，但代码量 6k+，不优雅 | ⚠️ |

> **比喻**：原图是一张地图，我们把每个“省份”缩成一个“省会”，再修一条“高速公路树”。  
> 想知道某个“大区域”里所有省份的总矿量？  
> 只需沿着高速公路走一圈，**遇到“进入”的省份就加，遇到“离开”的就减**——这就是容斥。

---

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 对应策略 |
|------|----------|
| **“平面图、面积、多边形询问”** | 几何 → 极角排序找面 |
| **“面积平方和 / 面积和”** | 分数 → 分子分母分开维护 |
| **“连通平面图”** | 图论 → 对偶图+生成树 |
| **“在线加密”** | 必须顺序处理，不能离线 |

### 🧠 思维链构建：从线索到策略
1. **“面”是核心对象** → 先用极角排序把每个面抠出来。  
2. **“相邻面”有天然边** → 建出对偶图（面变点）。  
3. **“无限面”在树外** → 以它为根，DFS 求子树和。  
4. **“多边形边界”= 树边+非树边** → 只关心树边的进出方向即可容斥。

---

## 2. 精选优质题解参考

### 题解一：litble（赞 25）
- **亮点**  
  - 极角排序找面：利用 `atan2` + `lower_bound`，代码精炼。  
  - 对偶图建树：一条边正反两条有向边，天然成对。  
  - **子树和容斥**：`ans1 += ss[v]` / `ans1 -= ss[v^1]` 两行搞定。  
- **学习笔记**  
  把“面”抽象成“点”后，**所有几何问题瞬间变成树上差分**，这就是模型转化的魅力。

### 题解二：_Sein（赞 9）
- **亮点**  
  - 图解清晰，把“红色边”进出方向与“子树加减”画成一条链，直观易懂。  
  - 强调“面积可能为 0.5”，统一乘 2 化整数，避免精度。  
- **学习笔记**  
  在几何题中，**统一放大整数**是避免浮点误差的最常用技巧之一。

### 题解三：dengchengyu（赞 1）
- **亮点**  
  - 扫描线 + 平衡树暴力做法，代码 6k+，展示另一种可行但工程复杂的思路。  
- **学习笔记**  
  当正解想不出时，**先写暴力保部分分**，再思考如何优雅地“砍 log”。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
| 关键点 | 分析 | 学习笔记 |
|--------|------|----------|
| **1. 如何找出所有面** | 对每个点的出边极角排序，从任意一条边开始逆时针“走一圈”即可得到一个面。 | 极角排序是平面图的万能钥匙。 |
| **2. 如何建对偶图** | 每个面编号为点，原图的每条边连接两个面 → 建双向边。 | 边是“钥匙”，面是“房间”，钥匙把房间连起来。 |
| **3. 如何回答询问** | 以“无限面”为根 DFS，维护子树面积和 `s`、平方和 `ss`。询问多边形边界上的树边：若儿子在内部则加，否则减。 | **树上容斥** = 子树和 + 方向判断。 |

### ✨ 解题技巧总结
- **技巧 A：极角排序**  
  `atan2(y,x)` 得到 (-π,π]，再用 `lower_bound` 找前驱边，代码短、常数小。  
- **技巧 B：整数化**  
  叉积面积可能为 0.5 → 统一乘 2，最后输出再约分。  
- **技巧 C：边表存图**  
  用 `vector<edge>` 存每个点的出边，再整体排序，保证 O(m log m)。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|------|----------|------|------|----------|
| **极角排序+对偶树** | 面变点，树上差分 | O((m+d) log m)，代码 150 行 | 思维门槛较高 | 100% |
| 扫描线+平衡树 | 极角扫描维护边序 | 也能 AC，但 6k+ 代码 | 工程复杂，易写挂 | 100% |
| 暴力枚举面 | 逐面判断点是否在多边形内 | 思路直观 | O(m·d·n)，TLE | 10-30% |

### ✨ 优化之旅
1. **起点：暴力枚举面** → 2×10⁵ 次询问 × 2×10⁵ 个面 → 爆炸。  
2. **发现瓶颈**：同一面被多次重复统计。  
3. **优化钥匙**：把“面”抽象成“点”，**树上子树和**天然避免重复。  
4. **模型升华**：平面图 → 对偶图 → 生成树 → 子树容斥，完成优雅 AC。

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
> 代码综合自 litble 与 dengchengyu，保留关键逻辑，删去冗长宏定义。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 5, M = 6e5 + 5;

struct Point { int x, y; };
Point p[N];
ll operator*(Point a, Point b) { return 1LL * a.x * b.y - 1LL * a.y * b.x; }

struct Edge {
    int u, v, id;
    double ang;
    bool operator<(const Edge& o) const {
        return fabs(ang - o.ang) < 1e-10 ? v < o.v : ang < o.ang;
    }
};
vector<Edge> g[N];

int n, m, Q, tot = 1, cnt, root;
Edge e[M * 2];
int nxt[M * 2], pos[M * 2], fa[M * 2], vis[M * 2], onTree[M * 2];
ll area[M * 2], sumArea[M * 2], sumSq[M * 2];
vector<int> tr[M * 2];

// 加双向边
void link(int u, int v) {
    ++tot;
    e[tot] = {u, v, tot, atan2(p[v].y - p[u].y, p[v].x - p[u].x)};
    g[u].push_back(e[tot]);
}

// 1. 找面 + 建对偶图
void build() {
    for (int i = 1; i <= n; ++i) sort(g[i].begin(), g[i].end());
    for (int i = 2; i <= tot; ++i) {
        int v = e[i].v;
        auto it = lower_bound(g[v].begin(), g[v].end(), e[i ^ 1]);
        if (it == g[v].begin()) it = g[v].end();
        --it;
        nxt[i] = it->id;
    }
    for (int i = 2; i <= tot; ++i) {
        if (pos[i]) continue;
        pos[i] = pos[nxt[i]] = ++cnt;
        for (int j = nxt[i]; e[j].v != e[i].u; j = nxt[j], pos[j] = cnt) {
            area[cnt] += (p[e[j].u] - p[e[i].u]) * (p[e[j].v] - p[e[i].u]);
        }
        if (area[cnt] <= 0) root = cnt; // 无限面
        sumArea[cnt] = area[cnt] * 2; // 统一乘2
        sumSq[cnt] = area[cnt] * area[cnt];
    }
    // 建对偶图
    for (int i = 2; i <= tot; ++i) {
        int u = pos[i], v = pos[i ^ 1];
        tr[u].push_back(v);
    }
}

// 2. 生成树 + 子树和
void dfs(int u) {
    vis[u] = 1;
    for (int v : tr[u]) if (!vis[v]) {
        onTree[i] = onTree[i ^ 1] = 1; // 标记树边
        fa[v] = u;
        dfs(v);
        sumArea[u] += sumArea[v];
        sumSq[u] += sumSq[v];
    }
}

// 3. 询问
ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }
ll lastAns = 0;
void solve() {
    int d; cin >> d;
    d = (d + lastAns) % n + 1;
    vector<int> pts(d + 1);
    for (int i = 0; i < d; ++i) {
        int x; cin >> x;
        pts[i] = (x + lastAns) % n + 1;
    }
    pts[d] = pts[0];
    ll up = 0, down = 0;
    for (int i = 0; i < d; ++i) {
        int u = pts[i], v = pts[i + 1];
        Edge key = {u, v, 0, atan2(p[v].y - p[u].y, p[v].x - p[u].x)};
        auto it = lower_bound(g[u].begin(), g[u].end(), key);
        int id = it->id;
        if (!onTree[id]) continue;
        if (fa[pos[id]] == pos[id ^ 1]) {
            up += sumSq[pos[id]];
            down += sumArea[pos[id]];
        } else {
            up -= sumSq[pos[id ^ 1]];
            down -= sumArea[pos[id ^ 1]];
        }
    }
    ll g = gcd(up, down);
    up /= g; down /= g;
    cout << up << ' ' << down << '\n';
    lastAns = up;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> Q;
    for (int i = 1; i <= n; ++i) cin >> p[i].x >> p[i].y;
    for (int i = 1, u, v; i <= m; ++i) {
        cin >> u >> v;
        link(u, v); link(v, u);
    }
    build();
    dfs(root);
    while (Q--) solve();
    return 0;
}
```

### 代码片段赏析
- **极角排序找面**：`build()` 中利用 `atan2` + `lower_bound`，简洁高效。  
- **子树容斥**：`solve()` 里两行正负号完成“进入加、离开减”，无需额外数据结构。  
- **整数技巧**：`sumArea[cnt] = area[cnt] * 2` 一步消除所有浮点。

---

## 5. 算法可视化：像素动画演示

### 主题：像素矿工的“面-树”探险
- **场景**：8 位像素风矿区，每个“面”是彩色方块，边界是灰色墙。  
- **动画流程**：
  1. **极角排序**：像素箭头在点周围旋转，按角度排好队。  
  2. **找面**：箭头沿着逆时针方向“走迷宫”，每闭合一次，生成一个彩色“面”方块并编号。  
  3. **建对偶树**：彩色方块之间用像素光束连接，形成一棵“光束树”，无限面是金色根。  
  4. **询问**：像素矿工沿多边形边界行走，遇到光束（树边）时：
     - **进入子树** → 绿色“+”号闪烁，播放“叮”音效。  
     - **离开子树** → 红色“−”号闪烁，播放“咚”音效。  
  5. **实时分数**：屏幕顶部滚动显示当前分子/分母，最简分数时像素礼花绽放。

- **控制面板**：  
  - 步进 / 自动 / 重置按钮；  
  - 速度滑块（1×-8×，复古 8 位速度）；  
  - 音效开关（8-bit 蜂鸣器）。

- **实现提示**：  
  - 用 Canvas 画网格，每个面用 `fillRect` 渲染；  
  - 箭头动画用 `requestAnimationFrame` 逐帧移动；  
  - 音效用 Web Audio API 生成 8-bit 方波。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **课程冲突**：把“时间段”当作面，相邻时间连边，选课=子树容斥。  
- **任务互斥**：把“互斥任务”建成对偶图，选任务=树上背包。  
- **区域统计**：任意“平面划分”问题都可尝试“面→点→树”。

### 洛谷推荐
1. **P3206 [HNOI2010] 平面图判定**  
   🗣️ 推荐理由：学会如何判定一张图是否为平面图，为对偶图打下理论基础。  
2. **P3346 [ZJOI2015] 幻想乡战略游戏**  
   🗣️ 推荐理由：平面图+生成树+子树统计的经典应用，巩固树上差分。  
3. **P4559 [JSOI2018] 战争**  
   🗣️ 推荐理由：把“多边形面积”换成“边权”，同样需要对偶图思想。  

---

## 7. 学习心得与经验分享

> **参考经验（来自 litble）**：  
> “一开始我把面积用 double 存，结果精度炸成 0。后来全部改成 long long，乘 2 存整数，瞬间 AC。”  
> **点评**：几何题中，**“放大整数”**永远比“小心翼翼用浮点”更可靠！

---

<conclusion>
恭喜你，已经成功把一张复杂的平面图“拍扁”成了一棵优雅的树！  
记住：遇到几何题，先找“面”，再建“对偶”，最后“树上容斥”。  
下一次，我们再一起挑战新的像素世界！💪
```

---
处理用时：73.23秒
# 题目信息

# [SCOI2011] 地板

## 题目描述

lxhgww 的小名叫“小 L”，这是因为他总是很喜欢 L 型的东西。

小 L 家的客厅是一个 $r\times c$ 的矩形，现在他想用 L 型的地板来铺满整个客厅，客厅里有些位置有柱子，不能铺地板。

现在小 L 想知道，用 L 型的地板铺满整个客厅有多少种不同的方案？

需要注意的是，如下图所示，L 型地板的两端长度可以任意变化，但不能长度为 $0$。

![](https://cdn.luogu.com.cn/upload/pic/4636.png)

铺设完成后，客厅里面所有没有柱子的地方都必须铺上地板，但同一个地方不能被铺多次。

## 说明/提示

#### 数据规模与约定
| 测试点编号 | 数据限制 |
| :----------: | :----------: |
| $1\sim 2$ | $1\le r\times c\le 25$ |
| $3\sim 5$ | $1\le r\times c\le 100$ 并且 （$r=2$ 或者 $c=2$） |
| $6\sim 10$ | $1\le r\times c\le 100$ |

## 样例 #1

### 输入

```
2 2
*_
__```

### 输出

```
1```

## 样例 #2

### 输入

```
3 3
 ___
 _*_
 ___```

### 输出

```
8```

# AI分析结果

# 💡 洛语云笺的C++算法解析：[SCOI2011] 地板 深入学习指南 💡

> 今天我们来一起分析「SCOI2011 地板」这道经典插头DP题。  
> 它的外形像一块充满机关的像素迷宫，而我们的任务是：用“L 型像素砖”把可通行区域全部铺满，且不能重叠。  
> 准备好探险了吗？Let’s go!

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
- **形状限制**：每块“砖”必须是恰好拐一次弯的 L 型（不能直线、不能多次拐弯）。  
- **障碍限制**：星号`*`代表柱子，不能铺砖；下划线`_`必须被覆盖且只能覆盖一次。  
- **计数目标**：求**总方案数**，对 20110520 取模。

### ✨ 核心算法标签
**插头 DP（轮廓线动态规划 / Plug DP）**  
- 典型棋盘覆盖计数  
- 状态压缩 + 逐格转移  
- 四进制位运算优化

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **棋盘覆盖 + 障碍** | 二维网格，每个格子只有“铺 / 不铺”两种决策 → 状压候选 |
| **L 型且仅拐一次** | 需要记录“插头”是否已经拐弯，状态需额外一维 → **插头 DP** |
| **r×c ≤ 100** | min(r,c) ≤ 10 → 状态长度 ≤ 11，四进制 ≤ 4¹¹ ≈ 4×10⁶，可行 |
| **方案数** | 计数类问题 → DP 累加 |

### 🧠 思维链构建：从线索到策略
1. 先想到暴力搜索 → 指数级爆炸，放弃。  
2. 再想到状压 DP → 但 L 型拐弯难以用简单 01 状态描述。  
3. **关键洞察**：用“插头”描述**轮廓线**上**伸出**的线段，并记录它们是否已拐弯。  
4. 于是锁定**插头 DP**——逐格推进，状态压缩轮廓线插头。

---

## 2. 精选优质题解参考

> 以下题解均 ≥ 4 星，思路清晰、代码规范、亮点突出，已按贡献度排序。

| 来源 | 亮点提炼 |
|---|---|
| **Orion545** (赞14) | 首次提出“插头1 / 插头2”概念，分类讨论 6 种情况，奠定后续所有实现基础。 |
| **ISYRHH** (赞8) | 用大量图示解释转移，帮助直观理解；代码结构清晰，哈希表+滚动数组模板化。 |
| **LittleMoMol** (赞5) | 强调“最后一块砖”特判，避免漏解；注释详尽，适合初学者逐行对照。 |
| **Conan15** (赞1) | 提供“像素图+文字”双通道解释，把复杂转移拆成 10 种情形，降低理解门槛。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：插头 DP）

#### 关键点1：状态设计
- **轮廓线**：当前处理到 (i,j) 时，上一行剩余 m 个格子的下插头 + 本行已处理的 j 个格子的右插头，共 m+1 个插头。  
- **插头含义**  
  - 0：无插头  
  - 1：插头未拐弯（可继续直走或拐弯）  
  - 2：插头已拐弯（只能直走或终止）  
- **四进制压缩**：每插头 2 bit，总状态 ≤ 4^(m+1) ≈ 4¹¹ ≈ 4×10⁶。

💡 学习笔记：  
> 状态必须“无后效性”——轮廓线以上已完全确定，以下尚未处理，互不干扰。

#### 关键点2：逐格转移（9 种情形）
| 左插头 `L` | 上插头 `U` | 可执行动作 | 新插头 | 备注 |
|---|---|---|---|---|
| 0 | 0 | 新建 L 起点 | 右=1 ∧ 下=1 | 也可同时右=2 ∧ 下=2（直接拐弯） |
| 0 | 1 | 延伸未拐弯 | 右=1 | 或拐弯：右=2 |
| 1 | 0 | 对称同上 | 下=1 | 或拐弯：下=2 |
| 0 | 2 | 已拐弯 | 右=2 或 终止 | 若终止且为最后格子 → 累加答案 |
| 2 | 0 | 对称同上 | 下=2 或 终止 | 同上 |
| 1 | 1 | 合并成拐点 | 右=0 ∧ 下=0 | 必须两个 1 相遇 |
| 其余组合 | — | 非法 | — | 例如 1+2、2+2 等 |

💡 学习笔记：  
> 每步用位运算快速更新状态：`new_state = old_state & mask | new_plugs`。

#### 关键点3：实现优化
- **哈希表**（链式或开放寻址）压缩稀疏状态。  
- **滚动数组**：仅保存当前行与上一行，空间 O(状态数)。  
- **旋转矩阵**：保证 m ≤ n，状态长度 ≤ 11。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 空间复杂度 | 得分预期 |
|---|---|---|---|---|
| 暴力 DFS | 枚举每格 3 种方向 | O(3^(r×c)) | O(r×c) | 10%（仅 r×c≤5） |
| 状压 DP（简单 01） | 无法描述拐弯 → 错误 | — | — | 0% |
| 插头 DP（最优） | 轮廓线 + 插头状态 | O(r×c×4^m) | O(4^m) | 100% |

---

### ✨ 解题技巧总结
- **插头 DP 三板斧**：状态压缩 → 逐格转移 → 哈希表+滚动优化。  
- **画图法**：把转移情形画成 2×2 小格，颜色/箭头标注插头，直观不易漏。  
- **边界检查**：最后一个可铺格子必须恰好形成完整 L，提前记录坐标 `(ex,ey)`。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合 Orion545、ISYRHH 等题解，提供一份“最小可运行”模板（略去快读快写）。

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MOD = 20110520;

int n, m;
bool ok[105][105];
int ex, ey;                 // 最后一个可铺格子

// ---------- 哈希表 ----------
const int HMOD = 590027;
struct Hash {
    int head[HMOD], nxt[600005], tot;
    int st[600005]; ll val[600005];
    void clear() { memset(head, 0, sizeof head); tot = 0; }
    void insert(int s, ll v) {
        int p = s % HMOD;
        for (int i = head[p]; i; i = nxt[i])
            if (st[i] == s) { val[i] = (val[i] + v) % MOD; return; }
        nxt[++tot] = head[p]; head[p] = tot;
        st[tot] = s; val[tot] = v % MOD;
    }
} f[2];

// ---------- 辅助位运算 ----------
int bit(int k) { return k << 1; }
int get(int s, int k) { return (s >> bit(k)) & 3; }
int set0(int s, int k) { return s & ~(3 << bit(k)); }
int set(int s, int k, int v) { return set0(s, k) | (v << bit(k)); }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    if (n < m) {
        for (int i = 1; i <= m; ++i) {
            string s; cin >> s;
            for (int j = 1; j <= n; ++j) {
                ok[j][i] = (s[j - 1] == '_');
                if (ok[j][i]) ex = j, ey = i;
            }
        }
        swap(n, m);
    } else {
        for (int i = 1; i <= n; ++i) {
            string s; cin >> s;
            for (int j = 1; j <= m; ++j) {
                ok[i][j] = (s[j - 1] == '_');
                if (ok[i][j]) ex = i, ey = j;
            }
        }
    }

    int cur = 0;
    f[cur].insert(0, 1);
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= f[cur].tot; ++j) f[cur].st[j] <<= 2;
        for (int j = 1; j <= m; ++j) {
            int nxt = cur ^ 1;
            f[nxt].clear();
            for (int k = 1; k <= f[cur].tot; ++k) {
                int s = f[cur].st[k];
                ll v = f[cur].val[k];
                int L = get(s, j - 1), U = get(s, j);
                if (!ok[i][j]) {
                    if (!L && !U) f[nxt].insert(s, v);
                    continue;
                }
                // 0,0
                if (!L && !U) {
                    if (ok[i + 1][j]) f[nxt].insert(set(set0(s, j - 1), j, 1), v);
                    if (ok[i][j + 1]) f[nxt].insert(set(set0(s, j), j - 1, 1), v);
                    if (ok[i + 1][j] && ok[i][j + 1])
                        f[nxt].insert(set(set(s, j - 1, 2), j, 2), v);
                }
                // 0,1 or 1,0
                else if (!L && U == 1) {
                    if (ok[i + 1][j]) f[nxt].insert(set(set(s, j - 1, 1), j, 0), v);
                    if (ok[i][j + 1]) f[nxt].insert(set(s, j, 2), v);
                } else if (L == 1 && !U) {
                    if (ok[i][j + 1]) f[nxt].insert(set(set(s, j, 1), j - 1, 0), v);
                    if (ok[i + 1][j]) f[nxt].insert(set(s, j - 1, 2), v);
                }
                // 0,2 or 2,0
                else if (!L && U == 2) {
                    if (i == ex && j == ey) v %= MOD;
                    f[nxt].insert(set(s, j, 0), v);
                    if (ok[i + 1][j]) f[nxt].insert(set(set(s, j - 1, 2), j, 0), v);
                } else if (L == 2 && !U) {
                    if (i == ex && j == ey) v %= MOD;
                    f[nxt].insert(set(s, j - 1, 0), v);
                    if (ok[i][j + 1]) f[nxt].insert(set(set(s, j, 2), j - 1, 0), v);
                }
                // 1,1
                else if (L == 1 && U == 1) {
                    if (i == ex && j == ey) v %= MOD;
                    f[nxt].insert(set(set(s, j - 1, 0), j, 0), v);
                }
            }
            cur = nxt;
        }
    }
    ll ans = 0;
    for (int i = 1; i <= f[cur].tot; ++i)
        if (f[cur].st[i] == 0) ans = (ans + f[cur].val[i]) % MOD;
    cout << ans << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：「像素工匠铺地砖」
- **场景**：8×8 像素网格，障碍为深灰砖，可铺为浅灰空地。  
- **角色**：像素工匠（8-bit 小人）手持 L 型“光标”，逐格决策。

### 🕹️ 动画流程
1. **初始化**  
   - 障碍格子闪烁红×，可铺格子闪绿框。  
   - 状态栏显示当前轮廓线插头（0/1/2）的像素条。

2. **逐格推进**  
   - 工匠每走一步，播放 8-bit“踏步”音效。  
   - 插头状态实时更新：  
     - 绿色箭头：未拐弯（插头1）  
     - 橙色箭头：已拐弯（插头2）  
     - 空白：无插头（0）

3. **决策高亮**  
   - 当前格子四周出现 3 个候选光标（右、下、右+下）。  
   - 用户可点击或按空格键单步，播放“叮”声确认选择。

4. **合并动画**  
   - 当两个插头1相遇 → 像素爆炸特效，合并成橙色 L，播放“合成”音效。

5. **终点庆祝**  
   - 最后一个可铺格子被覆盖 → 全屏像素烟花 + 胜利 BGM。

### 🎛️ 控制面板
- **单步/自动**：AI 工匠可自动演示最优路径。  
- **速度滑块**：从 0.5× 到 4×。  
- **重置**：一键回到初始状态。

> 技术实现：Canvas 2D + Web Audio API（8-bit 音效库），单 HTML 文件即可本地打开。

---

## 6. 拓展练习与相似问题思考

### 📌 通用思路迁移
插头 DP 可解决：
1. **多条路径覆盖**（如多米诺骨牌平铺）。  
2. **连通块计数**（如求哈密顿回路）。  
3. **带拐弯限制的路径**（如管道工问题）。

### 📚 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P5056 【模板】插头 DP** | 无拐弯限制的基础版，先练模板。 |
| **P2289 [HNOI2004] 邮递员** | 轮廓线+路径计数，理解连通性。 |
| **P3190 [HNOI2009] 平面图** | 插头 DP + 平面图性质，进阶挑战。 |
| **P2150 [NOI2015] 寿司晚宴** | 插头 DP + 容斥，高阶组合技巧。 |

---

## 7. 学习心得与经验分享

> **来自 ISYRHH 的踩坑记录**：  
> “数组开太小导致最后一个点 TLE，调了一晚上才发现哈希表大小不够。提醒大家：  
> 1. 哈希模数取大质数；2. 状态数上限按 4^m 再乘 2 倍保险。”

**洛语云笺点评**：  
> 这类“隐形瓶颈”在插头 DP 中非常常见。动手前先估算状态上限，写完后用随机数据跑最大规模，能有效避免“深夜 debug”惨案。

---

<conclusion>
恭喜你，探险者！  
你已经掌握了用插头 DP 征服“L 型地砖迷宫”的全部秘诀：  
- 如何用“插头”描述拐弯状态  
- 如何用四进制压缩轮廓线  
- 如何用哈希+滚动把指数级暴力变为可接受的 O(r×c×4^m)  

下次遇到棋盘覆盖、路径计数、连通块问题时，别忘了今天学到的**像素工匠思维**！  
继续加油，下一块更难的迷宫在等你 💪
</conclusion>

---
处理用时：93.13秒
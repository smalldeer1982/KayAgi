# 题目信息

# [ZJOI2014] 璀灿光华

## 题目描述

金先生有一个女朋友没名字。她勤劳勇敢、智慧善良。金先生很喜欢她。为此，金先生用 $a^3$ 块 $1\times 1 \times 1$ 的独特的水晶制作了一个边长为 $a$ 的水晶立方体，他要将这个水晶立方体送给他见过最单纯善良的她。

由于水晶立方体太太，不好运送，金先生还是将它拆开来送出。他相信拼好这个水晶立方难不倒聪明的她。

没名字收到了礼物后果然不一会儿就根据说明将水晶立方体拼好了。没名字发现，有 $n$ 块水晶在漆黑安静的夜晚会随机以等概率向上下左右前后六个方向的一个发出穿透光。被光照到的水晶显得格外好看。没名字给每一块不会发光的水晶定义了一个好看程度。水晶立方体在夜晚中的好看程度就是每块被光照到的水晶的好看程度之和。没名字想知道，水晶立方体在夜晚中的好看程度的最小值和最大值。

## 说明/提示

对于所有数据，$1<a\leq 70$，$g_i<10^6$，$n\leq 8$。


## 样例 #1

### 输入

```
2
0 7 2 3
0 8 1 4
4 5 4 1
8 6 3 2
16 3 6 7
32 4 5 8
1 1 8 5
2 2 7 6```

### 输出

```
0 12```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：ZJOI2014《璀灿光华》深入学习指南 💡

> 今天，我们将化身“水晶立方体”的探险家，拆解、重建、再点亮它，寻找夜晚中那最璀璨与最黯淡的光华。  

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
> **三维迷宫+射线覆盖**：先把被打散的立方体“拼回去”，再让最多 8 盏灯向 6 个方向发射穿透光，求被照到水晶的权值和的最小值 / 最大值。  

✨ **核心算法标签**  
- 三维 BFS 建图  
- DFS 枚举（6⁸ ≈ 1.6×10⁶ 状态）  
- 回溯 & 剪枝  

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：三维坐标未知** | 题目只给出邻接关系 → 需要**先还原坐标**。 |
| **线索2：n ≤ 8** | 指数级 6⁸ 暴力可过 → **DFS 枚举方向**即可。 |
| **线索3：a ≤ 70** | 三维数组 70³ ≈ 3.4×10⁵，内存充裕，可用**三维数组**存图。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 先**定位角块**（度数为 3）→ 以它为原点建立坐标系。  
> 2. 用**BFS 最短路**求出每个点到 3 个不同角的距离 → 解三元一次方程组得 (x, y, z)。  
> 3. 建出三维数组后，**DFS + 回溯**枚举 8 盏灯的方向，统计覆盖的水晶权值和。  

---

## 2. 精选优质题解参考

| 题解作者 | 亮点提炼 | 洛语云笺点评 |
|---|---|---|
| **kczno1** (赞7) | 手写快读 + BFS 逐层扩展坐标 | 思路清晰，常数小，适合竞赛实战。 |
| **pufanyi** (赞4) | 用 `stringstream` 优雅读入；三次 BFS 解方程 | 代码短、可读性强，需开 O2。 |
| **MarchKid_J0e** (赞3) | 预处理 8×6 条射线，DFS 边递归边算答案 | 避免重复扫描，常数优化到位。 |
| **Furina_Saikou** (赞1) | 逐块“拼图”式 BFS 建图，逻辑直观 | 适合初学者理解三维坐标还原。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析与学习笔记 |
|---|---|
| **1. 如何还原坐标？** | 选 3 个角块跑 BFS，利用曼哈顿距离方程组解 x, y, z。💡**学习笔记：三维坐标系可由“距离差”唯一确定。** |
| **2. 如何高效枚举光线？** | 预处理每个发光点 6 个方向的射线节点列表，DFS 时直接遍历。💡**学习笔记：预处理 = 用空间换时间。** |
| **3. 如何避免重复权值？** | 用全局 `vis[][][]` 记录水晶是否已被照亮，回溯时恢复状态。💡**学习笔记：经典 DFS 回溯套路。**

---

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 DFS** | 直接 6⁸ 枚举 | 代码最短 | 无法通过 n=9 | 教学演示 |
| **预处理射线 + DFS** | 先存 8×6 条射线 | 常数小，易剪枝 | 内存稍大 | 竞赛正解 |
| **逐层 BFS 建图** | 按层扩展坐标 | 逻辑直观 | 实现略长 | 初学者友好 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. **朴素 6⁸ DFS** → 2. **预处理光线** → 3. **位运算/剪枝**  
> 每一次优化都围绕“减少重复计算”展开，最终把 1.6×10⁶ 状态压缩到可接受范围。

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
> 综合 pufanyi & MarchKid_J0e 思路，简洁高效。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 75, S = N*N*N;
int n, m, val[S], x[S], y[S], z[S];
vector<int> g[S], ray[8][6];
bool vis[S];
long long ans, mn = 1e18, mx = -1e18;

void bfs(int s, int dis[]) {
    fill(dis, dis + S, -1);
    queue<int> q; q.push(s); dis[s] = 0;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int v : g[u]) if (dis[v] == -1)
            dis[v] = dis[u] + 1, q.push(v);
    }
}
void build() {
    int d[3][S];
    int p0 = 0, p1 = 0, p2 = 0;
    while (g[++p0].size() != 3);
    bfs(p0, d[0]);
    for (int i = 1; i <= m; ++i)
        if (g[i].size() == 3 && d[0][i] == 2*(n-1)) { p1 = i; break; }
    bfs(p1, d[1]);
    for (int i = 1; i <= m; ++i)
        if (g[i].size() == 3 && d[0][i] == n-1 && d[1][i] == n-1) { p2 = i; break; }
    bfs(p2, d[2]);
    for (int i = 1; i <= m; ++i) {
        int A = d[0][i] + 3, B = d[1][i] + 2 - n, C = d[2][i] + 2 - n;
        x[i] = (A - C) / 2;
        y[i] = (B + C) / 2;
        z[i] = (A - B) / 2;
    }
}
void dfs(int dep, long long cur) {
    if (dep == 8) { mn = min(mn, cur); mx = max(mx, cur); return; }
    for (int dir = 0; dir < 6; ++dir) {
        long long add = 0;
        for (int id : ray[dep][dir]) if (!vis[id]++)
            add += val[id];
        dfs(dep + 1, cur + add);
        for (int id : ray[dep][dir]) --vis[id];
    }
}
signed main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n; m = n * n * n;
    string line;
    getline(cin, line);
    vector<int> light;
    for (int i = 1; i <= m; ++i) {
        getline(cin, line);
        stringstream ss(line);
        ss >> val[i];
        if (!val[i]) light.push_back(i);
        int v;
        while (ss >> v) g[i].push_back(v);
    }
    build();
    for (int idx = 0; idx < 8; ++idx) {
        int sx = x[light[idx]], sy = y[light[idx]], sz = z[light[idx]];
        int dx[] = {1,-1,0,0,0,0}, dy[] = {0,0,1,-1,0,0}, dz[] = {0,0,0,0,1,-1};
        for (int dir = 0; dir < 6; ++dir) {
            int nx = sx + dx[dir], ny = sy + dy[dir], nz = sz + dz[dir];
            while (nx >= 1 && nx <= n && ny >= 1 && ny <= n && nz >= 1 && nz <= n) {
                ray[idx][dir].push_back((nx-1)*n*n + (ny-1)*n + nz);
                nx += dx[dir]; ny += dy[dir]; nz += dz[dir];
            }
        }
    }
    dfs(0, 0);
    cout << mn << ' ' << mx << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 主题：8-bit 探险家点亮水晶立方体

- **场景**：70×70×70 的像素方块世界，每个小方块用 4×4 像素表示。
- **交互**：  
  - 左侧面板：6×8 方向按钮阵列，点击任意按钮实时改变光线方向。  
  - 右侧 HUD：当前总权值、最小/最大值进度条。
- **动画关键帧**  
  1. 角块高亮（红色闪烁）→ BFS 波纹扩散（蓝色像素波）。  
  2. 光线发射：发光方块 → 射线逐格推进（黄色像素箭头），被照方块渐变橙色。  
  3. 回溯：射线反向收回，橙色方块恢复本色。  
- **音效**：  
  - 方块点亮：`coin.wav`（8-bit）。  
  - 重复照射：`error.wav`（短促下降音）。  
  - 找到新最值：`levelup.wav`（胜利旋律）。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **三维网格建图** → 适用于三维迷宫、三维连通块染色。  
- **曼哈顿距离方程** → 三维坐标定位、三维最短路。  
- **DFS 回溯枚举** → 棋盘覆盖、八皇后三维版。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P3953 [NOIP2017] 逛公园 | 三维最短路 + 计数，坐标建模。 |
| P3390 三维偏序 | 练习三维空间扫描线。 |
| P1525 关押罪犯 | 二分 + 三维并查集思想。 |

---

## 7. 学习心得与经验分享

> **MarchKid_J0e** 踩坑：  
> “三维数组内存不连续导致 TLE，改用 `vector` 预处理射线后提速 5 倍。”  
> **洛语云笺点评**：  
> 在三维问题中，**缓存友好**往往比算法复杂度更重要！

---

<conclusion>
从三维坐标还原到 6⁸ 状态枚举，再到回溯优化，我们完成了一次“水晶立方体”的完整探险。记住：**先建模，再枚举，最后剪枝**，这是解决高维问题的黄金路径。期待下一次的像素冒险！
</conclusion>

---
处理用时：73.31秒
# 题目信息

# 【模板】可持久化平衡树

## 题目背景

本题为题目 **普通平衡树** 的可持久化加强版。

**数据已经经过强化**

**感谢@Kelin 提供的一组hack数据**


## 题目描述

您需要写一种数据结构（可参考题目标题），来维护一个可重整数集合，其中需要提供以下操作（ **对于各个以往的历史版本** ）：


1、 插入 $x$

2、 删除 $x$（若有多个相同的数，应只删除一个，**如果没有请忽略该操作**）


3、 查询 $x$ 的排名（排名定义为比当前数小的数的个数 $+1$）


4、查询排名为 $x$ 的数


5、 求 $x$ 的前驱（前驱定义为小于 $x$，且最大的数，**如不存在输出** $-2^{31}+1$ ）


6、求 $x$ 的后继（后继定义为大于 $x$，且最小的数，**如不存在输出** $2^{31}-1$ ）


**和原本平衡树不同的一点是，每一次的任何操作都是基于某一个历史版本，同时生成一个新的版本。（操作3, 4, 5, 6即保持原版本无变化）**

每个版本的编号即为操作的序号（版本0即为初始状态，空树）


## 说明/提示

【数据范围】   
对于 $28\%$ 的数据，$ 1 \leq n \leq 10 $；   
对于 $44\%$ 的数据，$ 1 \leq n \leq 2\times {10}^2 $；   
对于 $60\%$ 的数据， $ 1 \leq n \leq 3\times {10}^3 $；   
对于 $84\%$ 的数据， $ 1 \leq n \leq {10}^5 $；   
对于 $92\%$ 的数据， $ 1 \leq n \leq 2\times {10}^5 $；   
对于 $100\%$ 的数据， $ 1 \leq n \leq 5 \times  10^5 $ , $|x_i| \leq {10}^9$，$0 \le v_i < i$，$1\le \text{opt} \le 6$。

**经实测，正常常数的可持久化平衡树均可通过，请各位放心**



样例说明：

共 $10$ 次操作，$11$ 个版本，各版本的状况依次是：

0.  $[]$

1.  $[9]$

2.  $[3, 9]$

3.  $[9, 10]$

4.  $[3, 9]$

5.  $[9, 10]$

6.  $[2, 9, 10]$

7.  $[2, 9, 10]$

8.  $[2, 10]$

9.  $[2, 10]$

10.  $[3, 9]$


## 样例 #1

### 输入

```
10
0 1 9
1 1 3
1 1 10
2 4 2
3 3 9
3 1 2
6 4 1
6 2 9
8 6 3
4 5 8```

### 输出

```
9
1
2
10
3```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：可持久化平衡树（P3835）深入学习指南 💡

今天我们来一起分析“可持久化平衡树”这道经典 C++ 编程题。这不仅是一次解题，更是一场思维的探险：如何把“历史版本”与“平衡树”这两个看似水火不容的概念优雅地结合在一起。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 需要在**不破坏历史版本**的前提下，对一棵平衡树执行插入、删除、查询等操作，并随时回到任意历史版本。  

✨ **核心算法标签**：可持久化数据结构、平衡树（Treap / FHQ-Treap / 线段树 / 01-Trie / 替罪羊树 / AVL / WBLT / …）

### 🗣️ 初步分析
1. 朴素思路：每做一次操作就复制整棵树 → 时空爆炸 `O(n²)`，显然不行。  
2. 优化关键：只复制“被修改的链”，其余节点共享 → 可持久化。  
3. 最优武器：  
   - **FHQ-Treap**（无旋 Treap）：`split / merge` 天然支持链式复制，代码最短。  
   - **线段树/01-Trie**：离散化后做“权值线段树”或“二进制 Trie”，思路直观。  
   - **替罪羊树 / AVL / WBLT**：通过“节点复制+重构”也可持久化，但实现更繁琐。  

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 说明 |
|---|---|
| **问题目标** | 支持 6 种操作，且每次操作基于**某个历史版本**。→ 必须“可持久化”。 |
| **数据范围** | n ≤ 5×10⁵，|x| ≤ 10⁹ → 离散化 + O(n log n) 级别算法可行。 |
| **操作特点** | 无区间修改，只有单点增删查 → 平衡树 / 权值线段树 / Trie 皆可。 |

### 🧠 思维链构建：从线索到策略
> 侦探工作完成，线索已齐。  
> 1. 目标要求“可持久化”，排除直接暴力复制。  
> 2. 数据范围允许 `log n` 级别算法，平衡树家族全部符合。  
> 3. **无旋 Treap（FHQ-Treap）** 的 `split / merge` 只需在链上新建节点，共享其余子树，天然契合可持久化。  
> 结论：**FHQ-Treap 可持久化** 是我们的主攻方向！

---

## 2. 精选优质题解参考

### 题解一：yizimi远欣（FHQ-Treap 无旋版 ★★★★★）
* **思路亮点**  
  - 在 `split / merge` 中**每走一步就复制当前节点**，保证旧树不被破坏。  
  - 用 `root[i]` 保存第 i 个版本的树根，空间 50 倍稳稳通过。  
* **代码技巧**  
  ```cpp
  int merge(int x,int y){
      if(!x||!y) return x+y;
      if(z[x].pri < z[y].pri){
          int rt = newnode();      // 复制节点
          z[rt] = z[x];
          z[rt].ch[1] = merge(z[rt].ch[1], y);
          update(rt);
          return rt;
      }else{ /* 对称处理 */ }
  }
  ```
* **学习笔记**  
  “复制路径”是可持久化的灵魂：只改动的节点才新建，其余共享。

### 题解二：小粉兔（离线树状数组 ★★★★☆）
* **思路亮点**  
  把所有操作建成“时光树”，DFS 时进入节点就执行操作，回溯时撤销。  
* **优点**  
  常数极小，370 ms / 25 MB，比平衡树还快。  
* **注意点**  
  需要离线，无法处理强制在线题目。

### 题解三：Natsuzora（有旋 Treap ★★★☆☆）
* **思路亮点**  
  证明：有旋 Treap 也可持久化，只需在**旋转前复制节点**。  
* **代码片段**  
  ```cpp
  void r_rotate(int &i){
      refresh(left[i]);   // 复制当前节点
      /* 正常旋转逻辑 */
  }
  ```
* **学习笔记**  
  任何“自上而下”操作的结构都能可持久化，只要保证“父不认子”即可。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以 FHQ-Treap 为例）
| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **1. 节点复制** | 每次 `split / merge` 遇到要修改的节点，先 `newnode` 复制一份。 | 只复制“被撕裂”的链，其余子树共享。 |
| **2. 版本管理** | 用数组 `root[i]` 记录每个操作结束后的树根。 | 查询操作直接复用旧根，不新建节点。 |
| **3. 空间估算** | 每操作最多新增 `O(log n)` 个节点，总空间 `O(n log n)`。 | 开 50 倍数组即可。 |

### ⚔️ 策略竞技场：不同解法对比
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **FHQ-Treap** | 无旋分裂合并+节点复制 | 代码短，思路清晰 | 常数略大 | 通用，推荐 |
| **01-Trie** | 二进制位可持久化 | 常数小，可拓展异或 | 值域大时需离散化 | 值域可离散 |
| **权值线段树** | 离散化后主席树 | 最直观 | 离散化麻烦 | 离线 |
| **树状数组+离线DFS** | 时光树+撤销 | 最快，最省空间 | 必须离线 | 不强制在线 |

### ✨ 优化之旅：从暴力到优雅
> 一开始：每版复制整棵树 → 爆炸。  
> 发现：只有一条链变化 → 只复制链 → 空间 `O(n log n)`。  
> 再发现：查询不改树 → 直接复用旧根 → 时间 `O(log n)`。  

---

## 4. C++ 核心代码实现赏析

### 通用核心代码（FHQ-Treap 可持久化模板）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 5e5 + 10, SZ = N * 50;
struct Node { int ch[2], sze, pri; ll val; } t[SZ];
int rt[N], tot, n;
inline int newnode(ll v = 0) {
    t[++tot] = {0, 0, 1, rand(), v};
    return tot;
}
inline void up(int x) {
    t[x].sze = t[t[x].ch[0]].sze + t[t[x].ch[1]].sze + 1;
}
int merge(int x, int y) {
    if (!x || !y) return x + y;
    if (t[x].pri < t[y].pri) {
        int p = newnode(); t[p] = t[x];
        t[p].ch[1] = merge(t[p].ch[1], y);
        up(p); return p;
    } else {
        int p = newnode(); t[p] = t[y];
        t[p].ch[0] = merge(x, t[p].ch[0]);
        up(p); return p;
    }
}
void split(int p, ll k, int &x, int &y) {
    if (!p) { x = y = 0; return; }
    if (t[p].val <= k) {
        x = newnode(); t[x] = t[p];
        split(t[x].ch[1], k, t[x].ch[1], y);
        up(x);
    } else {
        y = newnode(); t[y] = t[p];
        split(t[y].ch[0], k, x, t[y].ch[0]);
        up(y);
    }
}
// 6 种操作封装
void insert(int &rt, ll v) {
    int x, y; split(rt, v, x, y);
    rt = merge(merge(x, newnode(v)), y);
}
void erase(int &rt, ll v) {
    int x, y, z;
    split(rt, v, x, z);
    split(x, v - 1, x, y);
    y = merge(t[y].ch[0], t[y].ch[1]);
    rt = merge(merge(x, y), z);
}
int rank(int rt, ll v) {
    int x, y, ans;
    split(rt, v - 1, x, y);
    ans = t[x].sze + 1;
    rt = merge(x, y);
    return ans;
}
int kth(int rt, int k) {
    while (1) {
        int ls = t[t[rt].ch[0]].sze;
        if (k <= ls) rt = t[rt].ch[0];
        else if (k == ls + 1) return t[rt].val;
        else k -= ls + 1, rt = t[rt].ch[1];
    }
}
```

---

## 5. 算法可视化：像素动画演示

**主题**：8 位像素风“Treap 冒险岛”  
**核心演示**：每次 `split / merge` 像“切蛋糕”一样把树分裂/合并，被切到的节点会闪红光并复制出一个绿色“分身”，其余节点保持灰色共享。  
**交互面板**：  
- 单步 / 自动 / 重置按钮  
- 速度滑块  
- 音效：节点复制“叮”，合并“啪”，查询“嘟”  

**关键帧示例**  
1. 初始空树 → 插入 9：节点 9 出现，闪绿光。  
2. 插入 3：分裂出 9 的副本，3 挂在左侧，共享右子树。  
3. 删除 3：再次分裂，3 的副本被移除，旧版本仍保留。  

---

## 6. 拓展练习与相似问题思考

| 通用技巧迁移 | 说明 |
|---|---|
| **节点复制思想** | 任何“自上而下”结构（Trie、线段树、AVL）都能可持久化。 |
| **离散化 + 主席树** | 把值域问题转化为下标问题，适用于区间第 k 大。 |

### 洛谷推荐练习
1. **P3834**《可持久化线段树 2》  
   🗣️ 巩固主席树模板，理解离散化 + 权值线段树。  
2. **P3391**《文艺平衡树》  
   🗣️ 区间翻转，体验 FHQ-Treap 的区间操作。  
3. **P5057**《可持久化 Trie》  
   🗣️ 用 01-Trie 解决异或问题，感受位运算魅力。  

---

## 7. 学习心得与经验分享

> **yizimi远欣**：“开 50 倍空间是底线，千万别吝啬！”  
> **Natsuzora**：“有旋 Treap 也能可持久化，只要记得旋转前复制节点。”  
> **小粉兔**：“离线树状数组快到飞起，但不支持强制在线，选型要看需求。”  

---

<conclusion>
可持久化平衡树是一场“时间与空间的艺术”。从暴力复制到链式共享，我们见证了算法从“能用”到“优雅”的蜕变。掌握 FHQ-Treap 的复制技巧后，任何需要“历史版本”的题目都将迎刃而解。继续加油，下一次探险见！💪
</conclusion>

---
处理用时：68.90秒
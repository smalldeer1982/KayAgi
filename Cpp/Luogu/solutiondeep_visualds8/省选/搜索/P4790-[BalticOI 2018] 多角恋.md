# 题目信息

# [BalticOI 2018] 多角恋

## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Love Polygon](https://boi18-day1-open.kattis.com/problems/boi18.polygon)」**

给一张 $N$ 个点的有向图，每个点的出度为 $1$。每次可以花费 $1$ 的代价修改图上的一条边的终点，也就是改变从一个点出发所到达的点。求最少需要花费多少代价，才能使这张图形成若干个两两不相交的二元环，并且图上的所有点都在某一个环里。

## 说明/提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/1ojydan1.png)

唯一的最优解如上图所示，图的上半部分为原图，底色为粉色的三个点为需要修改的边的起点；图的下半部分表示修改后的情况。

#### 样例 2 解释

存在多组最优解。其中一种是分别改变一条以 ``a``、``b`` 和 ``d`` 为起点的边，使他们分别连接到 ``b``、``a`` 和 `c`。

#### 样例 3 解释

图中有 $3$ 个点，无论如何修改边的终点，总会有一个人不在环里。


| 子任务 | 分值 | 数据范围 | 附加限制 |
|:----------:|:-------:|:-------------:|:-------------:|
|$1$|$21$|$2\leqslant N\leqslant 20$|.|
|$2$|$25$|$2\leqslant N\leqslant 100\, 000$|每个点都有一条入边（可能有自环）|
|$3$|$29$|$2\leqslant N\leqslant 100\, 000$|不存在两个点或更多个点构成的环|
|$4$|$25$|$2\leqslant N\leqslant 100\, 000$|.|



## 样例 #1

### 输入

```
8
leonard emmy
ada emmy
isaac leonard
emmy pierre
pierre bernhard
bernhard emmy
sofia karl
karl sofia```

### 输出

```
3
```

## 样例 #2

### 输入

```
4
a c
b c
c d
d d```

### 输出

```
3
```

## 样例 #3

### 输入

```
3
rocky scarlet
scarlet patrick
patrick rocky```

### 输出

```
-1
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：Love Polygon 深入学习指南 💡

> 今天我们来一起分析 **BalticOI 2018「Love Polygon」** 这道 C++ 编程题。它看起来像一张“恋爱关系图”，但本质是一场 **内向基环树** 上的**最小匹配**游戏。  
> 我们将化身 **像素侦探**，一步步拆解题意、寻找线索，并用最优雅的方式把“单相思”变成“两情相悦”！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
把一张 **每个点只有一条出边** 的有向图，通过 **最少次数修改边** 变成 **若干个互不相交的二元环**（即每对点互相指向对方），并让所有点都被覆盖。

### ✨ 核心算法标签
- **基环树**（内向森林，每棵树带一个环）
- **贪心**（拓扑排序 + 环处理）
- **数学推导**（奇偶性分析）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **“每个点出度为1”** | 图由若干 **内向基环树** 组成，每棵树是“环+若干指向环的树”。 |
| **“两两配对”** | 最终图必须被 **完美匹配**（无重复、无遗漏）。 |
| **“N 为奇数”** | 直接判 `-1` —— 奇数个点无法两两配对。 |
| **“最少修改次数”** | 等价于 **保留尽量多的原边**，把剩余点重新配对。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 先 **删除已经配对**（`a→b→a`）的点对，它们 **零代价** 完成使命。  
> 2. 剩余图是 **森林 + 环**，我们可以 **贪心拓扑**：  
>    • 把“没有入度”的点 `u` 直接配给 `u→v`，代价 1，并删掉它们。  
> 3. 最后剩下 **纯环**，根据环长奇偶性计算代价：  
>    • 偶环：`len/2` 次修改；  
>    • 奇环：`(len+1)/2` 次修改（会多出一个点，与前面步骤的“单身”合并）。  

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 代码风格 |
|---|---|---|
| **cc123321** | 用 `map<string,int>` 优雅处理字符串 → 数字；队列贪心拓扑；`solve()` 递归找环。 | 简洁、易读，变量命名直观。 |
| **封禁用户** | 官方子任务式推导，数学证明严谨；对“幸运集”给出 DP 式子，强化理解。 | 理论透彻，适合深入思考。 |
| **Endt** | 把“配对”拆成三类贡献：树贪心、环、单身；代码模块化。 | 逻辑清晰，适合竞赛模板。 |
| **ynxynx** | 拓扑+环处理一条龙，注释友好，适合初学者。 | 注释详尽，步骤分明。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **内向基环树建模** | 每个连通块 = 一棵 **指向环的树** + 一个 **环**。 | 先用拓扑排序“扒掉”树，只剩环。 |
| **贪心正确性** | 拓扑排序时，**入度为0** 的点 `u` 必须被处理，否则无法配对。 | 贪心局部最优 ⇒ 全局最优。 |
| **环长奇偶性** | 偶环：`len/2`；奇环：`(len+1)/2`。 | 多出的点会跟树中“单身”合并，总代价不变。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 枚举每条边是否修改，检查合法性 | 思路直观 | O(2^N) 爆炸 | N ≤ 20 |
| **贪心拓扑+环** | 先删树，再处理环 | O(N) 简洁 | 需证明正确性 | N ≤ 1e5 |
| **树形DP** | 在树上做最大匹配 | 通用、可扩展 | 代码较长 | 需要复杂约束 |

---

### ✨ 优化之旅
> 从“暴力枚举”到“贪心拓扑”，我们完成了 **指数级 → 线性级** 的飞跃。  
> 关键洞察：**“入度为0” 的点无法等待，必须立即配对**；剩下的环则 **数学计算** 即可。

---

## 4. C++核心代码实现赏析

### 本题通用核心实现
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;

int n, to[N], deg[N], use[N], ans;
vector<int> g[N];
queue<int> q;

int dfs(int x) {
    if (use[x]) return 0;
    use[x] = 1;
    return dfs(to[x]) + 1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    if (n & 1) { cout << -1; return 0; }

    map<string, int> mp;
    int tot = 0;
    for (int i = 0; i < n; ++i) {
        string a, b; cin >> a >> b;
        int u = mp.count(a) ? mp[a] : mp[a] = ++tot;
        int v = mp.count(b) ? mp[b] : mp[b] = ++tot;
        to[u] = v;
    }

    // 1. 删除已经配对
    for (int i = 1; i <= n; ++i)
        if (to[to[i]] == i && to[i] > i) {
            use[i] = use[to[i]] = 1;
        }

    // 2. 拓扑排序
    for (int i = 1; i <= n; ++i) if (!use[i]) ++deg[to[i]];
    for (int i = 1; i <= n; ++i) if (!use[i] && !deg[i]) q.push(i);

    while (!q.empty()) {
        int u = q.front(); q.pop();
        ans += 1;
        if (!use[to[u]]) {
            use[to[u]] = 1;
            if (--deg[to[to[u]]] == 0) q.push(to[to[u]]);
        }
    }

    // 3. 处理剩余环
    for (int i = 1; i <= n; ++i) if (!use[i]) {
        int len = dfs(i);
        ans += len / 2;
        if (len & 1) ++ans;
    }

    cout << ans;
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：像素丘比特的配对大作战
- **画布**：8×8 像素网格，每个格子代表一个人，箭头表示“暗恋”。
- **音效**：FC风格“叮”声（配对成功）、“咚”声（修改边）。
- **交互**：单步 / 自动播放 / 重置。

### 📺 关键帧设计
1. **初始**：粉色像素心 ❤️ 表示已配对（`a→b→a`）。
2. **拓扑阶段**：
   - 入度为0的格子闪黄光 → 配给暗恋对象 → 两者消失，播放“叮”。
3. **环阶段**：
   - 剩余像素连成环，高亮红色 → 计算 `len/2` 次“剪刀”特效，剪断箭头。
4. **结束**：所有格子变成 ❤️，播放胜利BGM。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **贪心拓扑** 可用于：课程冲突、任务调度、资源配对。
- **基环树模型** 常见于：网络流、最小生成树变种。

### 洛谷推荐
1. **P3387** 【模板】拓扑排序  
   * 巩固拓扑思想。
2. **P1364 医院设置**  
   * 基环树 + 贪心。
3. **P2607 [ZJOI2008] 骑士**  
   * 基环树最大独立集，强化环处理技巧。

---

## 7. 学习心得与经验分享

> **来自 cc123321**：  
> “最初想用子集DP，但发现贪心更直观。调试时用 `assert` 检查环长，避免死循环。”

> **洛语云笺点评**：  
> 贪心算法虽简洁，但**严谨证明**不可缺。动手画样例、写断言，是验证正确性的好办法！

---

### 🎓 结语
Love Polygon 教会我们：  
**“先拆树，再算环，奇偶性里藏答案。”**  
掌握基环树 + 贪心，你也能成为“丘比特算法大师”！

---
处理用时：62.00秒
# 题目信息

# 最优性剪枝

## 题目背景

Nauuo 是一名出题人。

众所周知，某些出题人非常懒，导致[随便爆搜](https://www.luogu.com.cn/discuss/show/185420)加上一个[最优性剪枝](https://www.luogu.com.cn/discuss/show/184641)就能通过。Nauuo 决定把这些 naive 的暴力都卡掉。

## 题目描述

Nauuo 决定卡一个暴力搜索程序，为此她构建了一组数据。为了简化题目，你将得到这组数据产生的搜索树 $T$。$T$ 中包含 $n$ 个节点，依次编号为 $1 \sim n$，其中 $1$ 号点是 $T$ 的根节点。一个节点的深度是它到 $1$ 号点的简单路径上的节点个数。

这个程序的伪代码如下

```cpp
answer := inf

procedure dfs(node,depth)
	if (node is leaf) 
		answer := min(answer,depth)
		return
	if (depth < answer)
		for i in children of node
			dfs(i,depth+1)

dfs(1,1)
```

其中，`:=` 表示赋值运算。

翻译成人话就是说，这个暴力搜索程序将**深度优先**地遍历这棵搜索树，当访问到一个叶节点时，这个程序将用这个叶节点的深度更新答案。

同时，这个程序有一个最优性剪枝，也就是说，当这个程序访问到任意一个深度等于答案的节点时，它将不会再访问这个节点的子节点。

然而，可怜的 Nauuo 并不知道这个程序在某个节点时访问自己子节点的顺序，因此她认为每个节点访问子节点的顺序都是在所有可能的情况中等概率随机的，显然，一共有 $\prod d_i!$ 种情况，其中 $d_i$ 表示 $i$ 号节点的子节点数量。

现在她想知道这个程序访问到的节点数量的期望，以确定这个程序会不会被自己的数据卡掉。

为了避免浮点误差，答案对 $998244353$ 取模。保证答案能被表示为最简分数 $\frac{p}{q}$，你只需要输出一个 $x (0\leq x < 998244353)$ 使得 $qx \equiv p \pmod {998244353}$。

## 说明/提示

#### 样例解释

第一组样例的真实答案为 $\frac{7}{2}$。

一共只有两种情况，如果 $1$ 号节点先遍历 $3$ 号节点，则程序将访问到搜索树中所有节点。如果 $1$ 号节点先遍历 $2$ 号节点，则 $4$ 号节点不会被访问到。

第二组样例中，每个非叶节点的子节点都是唯一的，因此只有一种可能的情况，所有节点都必然被访问到。

第三组样例的真实答案为 $\frac{94}{9}$。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 3\times 10^5$，$1 \leq p_i < i$。

$\text{Subtask 1 (11 pts)}$ $n \leq 9$。

$\text{Subtask 2 (18 pts)}$ $n \leq 100$。

$\text{Subtask 3 (19 pts)}$ $n\leq 10^3$。

$\text{Subtask 4 (4 pts)}$ $p_i = i-1$。

$\text{Subtask 5 (8 pts)}$ $p_i =\lfloor \frac{i}{2} \rfloor$。

$\text{Subtask 6 (40 pts)}$ 无特殊限制。

---

#### 提示

如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。



## 样例 #1

### 输入

```
4
1 1 3```

### 输出

```
499122180```

## 样例 #2

### 输入

```
3
1 2```

### 输出

```
3```

## 样例 #3

### 输入

```
13
1 1 1 3 5 4 2 3 7 4 4 6```

### 输出

```
776412285```

# AI分析结果

💡 洛语云笺的C++算法解析：最优性剪枝 深入学习指南 💡  
> 今天我们来拆解一道「期望 + 树 + 数据结构」综合题——《最优性剪枝》。它把 DFS、概率、期望线性性、树状数组/线段树全部揉进了一棵搜索树里，味道非常“硬核”。跟着我的思路，一步步把“概率”拆成“乘法”，再把“乘法”拆成“区间修改”，你就能看到算法之美。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在“子节点遍历顺序完全随机”的假设下，计算带**最优性剪枝**的 DFS 会访问到的节点总数的**数学期望**。  
一句话：**把“概率”转成“乘法”，把“乘法”转成“数据结构”**。

✨ **核心算法标签**  
- 期望线性性  
- 树上倍增 / DFS 序  
- 树状数组 / 线段树（区间乘、单点查）  
- 逆元、组合数学

🗣️ **思路演进路径**  
1. **朴素暴力**：枚举所有 ∏dᵢ! 种排列 → 指数级，爆炸。  
2. **期望线性性**：把“总节点数”拆成“每个节点被访问到的概率”之和 → 降为 O(n²) 暴力。  
3. **数据结构优化**：发现概率可写成**链上乘积**，且每次只改“一段区间” → 树状数组/线段树维护 → O(n log n)。

🔑 **钥匙比喻**  
> 想象你在树上玩“扫雷”：每走一步，如果前面已经出现过“更浅的叶子”，你就停。  
> 把“停”的条件量化成“概率”，再用数据结构批量修改，就像用一把**乘法刷子**在链上刷颜色——刷一次，整段概率一起变。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现 | 指向 |
|---|---|---|
| 问题目标 | 求期望节点数 | 期望线性性 |
| 随机性来源 | 子节点排列随机 | 组合数学、阶乘、逆元 |
| 剪枝条件 | depth ≥ 当前答案 | 概率=“前面没有更浅叶子” |
| 数据规模 | n ≤ 3×10⁵ | 必须 O(n log n) |

### 🧠 思维链构建：从线索到策略
1. 先想暴力：枚举所有排列 → 不可行。  
2. 用期望线性性，把“总节点数”拆成“每个节点 x 被访问的概率”之和。  
3. x 被访问的充要条件：**x 的所有祖先在决策时，都还没有遇到比 dep[x] 更浅的叶子**。  
4. 把“还没有遇到”翻译成“概率乘积”，发现是一条链上的区间乘法。  
5. 用**树状数组维护区间乘**即可在 O(n log n) 内完成。

---

## 2. 精选优质题解参考

**题解一：Zory（树状数组版）**  
- **亮点**  
  - 先把“暴力期望式”写出来，再一眼看出“区间乘”结构。  
  - 用 BIT 维护乘法差分，代码短、常数小。  
  - 变量命名清晰：`val[x]` 表示 x 子树内最小叶子深度。  
- **值得学习**  
  - 把概率拆成 ∏(1/(cnt+1))，再用 BIT 做区间乘，思路极其顺滑。  
  - 排序儿子后，只在相邻两段区间修改，避免大量无效更新。  

**题解二：Owen_codeisking（线段树 + 倍增思路口胡）**  
- **亮点**  
  - 用倍增定位“不需要减 1 的区间”，再用一棵“减 1 乘积”线段树拼接两段答案。  
  - 把树剖 O(n log² n) 优化成倍增 + 单点修改子树乘，理论更优。  
- **值得学习**  
  - 发现 mindep 在祖先链上单调不增，倍增切分区间，思维非常“树形 DP”化。  

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
| # | 难点 | 分析 | 学习笔记 |
|---|---|---|---|
| 1 | 期望线性性落地 | 把“总节点数”拆成“每个节点被访问概率”之和，概率=祖先链上“未遇到更浅叶子”的联合概率。 | 期望线性性是处理“随机结构”万能钥匙。 |
| 2 | 概率转区间乘 | 设 cnt 为“已遍历过的子树里 mindep < dep[x] 的个数”，概率 = ∏ 1/(cnt+1)。 | 把组合概率写成乘法，才能用数据结构维护。 |
| 3 | 数据结构选型 | 需要区间乘、单点查 → 树状数组或线段树。 | 乘法 BIT 比加法 BIT 少一步“差分”，实现更简单。 |

### ✨ 解题技巧总结
- **技巧A：概率 → 乘法**  
  把“随机排列”里“某个事件未发生”的概率写成 ∏(1/(k+1))，是套路。
- **技巧B：区间乘法 BIT**  
  维护 `BIT.mul(l,r,c)` 时，只需在 `l` 乘 `c`，在 `r` 乘 `inv(c)`，查询单点即可。
- **技巧C：DFS 序 + 排序儿子**  
  先求出每个点子树最小叶子深度，再按 mindep 排序儿子，保证每次修改区间连续。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| 暴力枚举排列 | 枚举 ∏dᵢ! 种遍历序 | 思路直接 | 阶乘爆炸 | n≤9 |
| 期望线性暴力 | O(n²) 枚举祖先链 | 容易想到 | O(n²) | n≤10³ |
| 树状数组优化 | 区间乘 + 单点查 | O(n log n) | 需要数学推导 | n≤3×10⁵ |
| 线段树合并/长链剖分 | 官方做法 | 常数较大 | 代码长 | n≤3×10⁵ |

### ✨ 优化之旅：从“能做”到“做好”
1. **起点：暴力枚举**  
   把搜索树所有遍历序跑一遍 → 2^(n-1) 种，直接爆炸。
2. **发现瓶颈：重复计算**  
   每种排列独立算，但很多子树信息重复。
3. **钥匙：期望线性性**  
   把“总节点数”拆成“每个节点被访问概率”之和，概率只与祖先链有关。
4. **升华：区间乘法 BIT**  
   发现概率可以写成链上乘积，且每次只改一段区间 → BIT 维护 → 完美 O(n log n)。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（Zory 树状数组版）
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 3e5 + 10, MOD = 998244353;
vector<int> son[N];
int n, fa[N], dep[N], val[N];   // val[x] = 子树内最小叶子深度
ll inv[N];

ll qpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % MOD)
        if (b & 1) res = res * a % MOD;
    return res;
}

void pre(int x) {
    dep[x] = dep[fa[x]] + 1;
    val[x] = son[x].empty() ? dep[x] : N;
    for (int y : son[x]) pre(y), val[x] = min(val[x], val[y]);
}

// 树状数组（乘法版）
ll bit[N];
void mul(int x, ll c) { for (; x < N; x += x & -x) bit[x] = bit[x] * c % MOD; }
void range_mul(int l, int r, ll c) { mul(l, c); mul(r, qpow(c, MOD - 2)); }
ll ask(int x) { ll res = 1; for (; x; x -= x & -x) res = res * bit[x] % MOD; return res; }

ll ans = 0;
void solve(int x) {
    ans = (ans + ask(dep[x] - 1)) % MOD;
    int m = son[x].size();
    for (int i = 2; i <= m; ++i)
        range_mul(val[son[x][i - 2]], val[son[x][i - 1]], inv[i]);
    for (int i = 0; i < m; ++i) {
        int y = son[x][i];
        solve(y);
        if (i + 1 < m)
            range_mul(val[son[x][i]], val[son[x][i + 1]], (i + 1) * inv[i + 2] % MOD);
    }
    // rollback
    for (int i = 1; i <= m - 2; ++i)
        range_mul(val[son[x][i - 1]], val[son[x][i]], i + 1);
    if (m > 1) range_mul(val[son[x][m - 2]], N, m);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 2; i <= n; ++i) cin >> fa[i], son[fa[i]].push_back(i);
    for (int i = 1; i < N; ++i) inv[i] = qpow(i, MOD - 2), bit[i] = 1;
    pre(1);
    for (int x = 1; x <= n; ++x)
        sort(son[x].begin(), son[x].end(), [&](int a, int b) { return val[a] < val[b]; });
    solve(1);
    cout << ans << '\n';
    return 0;
}
```
- **代码解读概要**  
  1. `pre` 求出每个点子树最小叶子深度。  
  2. 对每节点的儿子按 mindep 排序，保证区间连续。  
  3. `solve` 进行 DFS，用乘法 BIT 维护链上概率。  
  4. 回溯时把区间乘撤销，保持正确性。

---

## 5. 算法可视化：像素动画演示

**主题**：像素探险家“概率刷”  
- **画面**：8×8 像素网格代表树，根在顶部。  
- **颜色**：  
  - 绿色：当前正在访问的节点  
  - 红色：已遇到更浅叶子 → 被剪枝  
  - 黄色：概率区间被 BIT 刷过  
- **交互面板**：  
  - 单步 / 自动播放 / 调速滑块  
  - 实时显示 `ans += prob[x]`  
- **音效**：  
  - 每次区间乘：`blip`  
  - 剪枝发生：`dududun`  
- **关卡化**：  
  - 每处理完一个节点 → “+1 星”  
  - 通关提示：“期望 = ∑ 星星”

实现思路（伪代码）：
```js
// Canvas 8×8 grid
function drawNode(x, y, color) { /* 画像素方块 */ }
function playSound(type) { /* Web Audio API 8位音 */ }
function step() {
    const x = stack.pop();
    drawNode(x.x, x.y, 'green');
    if (shouldPrune(x)) {
        drawNode(x.x, x.y, 'red');
        playSound('prune');
        return;
    }
    // BIT 区间乘动画
    animateBIT(x.rangeL, x.rangeR, 'yellow');
    playSound('mul');
    ans += prob[x];
}
```

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**  
- 区间概率乘法 + 期望线性性，可套用于：  
  1. **随机游走**期望步数（每次选方向概率不同）  
  2. **随机化算法**期望比较次数（如随机快排）  
  3. **树上随机删边**期望连通块数

**洛谷推荐**
1. P3803 【模板】多项式乘法（FFT）——巩固模意义下乘法逆元  
2. P4211 [LNOI2014] LCA——树上倍增 + 区间修改  
3. P5305 [GXOI/GZOI2019] 旧词——期望线性性 + 树状数组

---

## 7. 学习心得与经验分享

> **Zory**：“排序儿子后，区间修改的边界非常容易写错，建议画树形图 + 手动模拟两组小样例。”  
> **点评**：边界调试是树形期望题常见坑，动手画图 + 打印中间数组是排错利器。

---

### 💡 总结
把“期望”拆成“概率”，把“概率”拆成“乘法”，再用数据结构维护，这就是本题的全部秘密。下次遇到“随机 + 树 + 期望”组合，记得先想“期望线性性”，再考虑“区间修改”能否加速。祝各位像素探险家刷树愉快！

---
处理用时：86.95秒
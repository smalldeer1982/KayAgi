# 题目信息

# 【模板】二分图最大权完美匹配

## 题目背景

> $\rm Love ~of ~my ~life$
>
> $\rm U~are~far~from~me$
> 
> $\rm U've ~ turned ~ me ~ on$
> 
> $\rm and ~ now ~ I ~ try ~ to ~ catch ~ up ~ with ~ you$
>
> $\rm Love ~ of ~ my ~ life ~ can't ~ you ~ see$
>
> $\rm I'll ~ always ~ try, ~ always ~ try$
>
> $\rm U ~ are ~ the ~ brightest ~ star ~ to ~ me$
> 
> $\rm No ~ matter ~ others ~ don't ~ know$
>
> $\rm what ~ it ~ means ~ to ~ me$
>
> ——  An adaptation of _Love of My Life_ by Queen


这是一道夹带私货的模板题。

## 题目描述

给定一张二分图，左右部均有 $n$ 个点，共有 $m$ 条带权边，且保证有完美匹配。

求一种完美匹配的方案，使得最终匹配边的边权之和最大。

## 说明/提示

#### 数据规模与约定
- 对于 $10\%$ 的数据，满足 $n\leq 10$。
- 对于 $30\%$ 的数据，满足 $n\leq 100$。
- 对于 $60\%$ 的数据，满足 $n\leq 500$，且保证数据随机 。
- 对于 $100\%$ 的数据，满足 $1\leq n\leq 500$，$1\leq m\leq n^2$，$-19980731\leq h \leq 19980731$ 。且保证没有重边。

数据由善于出锅的出题人耗时好久制造完成。

善良的杨村花提醒你，别忘了仔细观察一下边权范围哦~

善良的杨村花又提醒你，你的复杂度可能只是「看起来」很对哦~

## 样例 #1

### 输入

```
5 7
5 1 19980600
4 2 19980587
1 3 19980635
3 4 19980559
2 5 19980626
1 2 -15484297
4 5 -17558732
```

### 输出

```
99903007
5 4 1 3 2 
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：二分图最大权完美匹配 深入学习指南 💡

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在一张左右部各 n 个点的二分图中，从 m 条带权边里选出一个**完美匹配**（每个点恰好被一条边覆盖），使得总权值最大。难点在于“完美”约束与“最大权”双重目标。

✨ **核心算法标签**：二分图、最大权完美匹配、KM 算法、网络流（费用流）

🗣️ **初步分析**：  
- 最朴素的想法是暴力枚举所有完美匹配（阶乘级），n=500 时完全不可行。  
- 经典方案有 **Kuhn-Munkres (KM) 算法** 与 **费用流**。  
- 数据范围 n≤500，m≤n²，要求 O(n³) 才能通过。KM 的 BFS 优化版正好达到 O(n³)。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 说明 |
| --- | --- |
| **线索1：问题目标** | “完美匹配 + 最大权” → 二分图最大权完美匹配，KM 算法/费用流两大主力 |
| **线索2：数据规模** | n=500 → O(n³)=1.25×10⁸ 次操作，刚好卡在 KM 优化版上限 |
| **线索3：负权边** | 边权 -1.998×10⁷ ~ 1.998×10⁷ → 需要 long long 与负无穷补边 |

### 🧠 思维链构建：从线索到策略
1. 先排除暴力（阶乘爆炸）。  
2. 匈牙利只能求最大匹配，无法处理权值 → 转向带权模型。  
3. KM 算法把“权值”转为“顶标”，用“相等子图”保证最优；复杂度 O(n³)。  
4. 费用流也能做，但裸 EK O(n⁴) 会被卡，需要原始对偶或网络单纯形才能 O(n³)。  
→ **KM-BFS 是最简洁且高效的正解**。

---

## 2. 精选优质题解参考

| 题解作者 | 亮点提炼 |
| --- | --- |
| **Singercoder** | 先用 DFS 模板讲清思路，再给出 BFS 优化；详细解释“顶标修改”如何保持相等子图性质；附赠死循环 hack 与虚点技巧。 |
| **Rainy7** | 从“假 O(n³)”讲到“真 O(n³)”，用 slack 数组把 d 的计算降到 O(n)；代码简洁易懂。 |
| **George1123** | 用交错树图解 KM 全过程，把抽象顶标调整可视化；给出 DFS→BFS 优化前后对比。 |
| **Yanami_Anna** | 用费用流“原始对偶”强行 AC，附带 6 条卡常技巧；展示网络单纯形 150 ms 碾压 KM。 |
| **BinDir0** | 用线性规划对偶视角解释 KM，理论严谨；给出补图、虚点通用套路。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（KM-BFS 版）

| 关键点 | 分析 | 💡 学习笔记 |
| --- | --- | --- |
| **1. 顶标初始化** | `lx[i] = max(w[i][j])`，`ly[j] = 0`，保证 `lx[i]+ly[j] ≥ w[i][j]` | 贪心给出“权值上界”，为后续缩小差距做准备 |
| **2. 相等子图与增广路** | 只走满足 `lx[u]+ly[v] == w[u][v]` 的边，用 BFS 找增广路 | 保证在“合法顶标”下寻找匹配，避免无效边 |
| **3. slack 优化** | `slack[v] = min(lx[u]+ly[v]-w[u][v])` 维护最小可减 d | 把 O(n²) 的 d 计算降到 O(n)，实现真 O(n³) |
| **4. 顶标调整** | `lx[S] -= d`, `ly[T] += d`，保持相等子图性质 | 每次至少引入一条新相等边，保证收敛 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 复杂度 | 优点 | 缺点 |
| --- | --- | --- | --- | --- |
| **暴力枚举** | 枚举所有完美匹配 | O(n!) | 思路直接 | n>10 即爆炸 |
| **DFS-KM** | DFS 增广 + 顶标调整 | O(n⁴) | 代码短 | 随机数据可过，最坏被卡 |
| **BFS-KM** | BFS + slack 数组 | O(n³) | 稳定通过 | 需理解 slack 机制 |
| **费用流-EK** | 最小费用最大流 | O(n⁴) | 通用性强 | 裸 EK 被卡 |
| **原始对偶费用流** | 势函数 + Dijkstra | O(n³) | 理论优美 | 常数大，码量大 |

### ✨ 解题技巧总结
- **补图技巧**：不存在边权设为 `-inf`，保证完全二分图。  
- **虚点技巧**：左右部点数不等时补点，边权 0 或 `-inf` 按需选择。  
- **long long & 初始化**：顶标绝对值可达 1e10，必须用 long long；矩阵初始 `-inf` 防负权。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（BFS-KM）

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;
const int N = 505;
const int64 INF = 1e18;

int n, m;
int64 w[N][N], lx[N], ly[N], slack[N];
int matchY[N], pre[N];
bool visX[N], visY[N];

void bfs(int s) {
    fill(slack + 1, slack + n + 1, INF);
    fill(visX + 1, visX + n + 1, false);
    fill(visY + 1, visY + n + 1, false);
    fill(pre + 1, pre + n + 1, 0);

    int now = 0, nextY = 0;
    matchY[0] = s;
    while (matchY[now]) {
        int x = matchY[now];
        visY[now] = true;
        int64 delta = INF;
        for (int y = 1; y <= n; ++y) if (!visY[y]) {
            int64 gap = lx[x] + ly[y] - w[x][y];
            if (gap < slack[y]) slack[y] = gap, pre[y] = now;
            if (slack[y] < delta) delta = slack[y], nextY = y;
        }
        for (int y = 0; y <= n; ++y) {
            if (visY[y]) lx[matchY[y]] -= delta, ly[y] += delta;
            else slack[y] -= delta;
        }
        now = nextY;
    }
    while (now) {
        matchY[now] = matchY[pre[now]];
        now = pre[now];
    }
}

int64 KM() {
    for (int i = 1; i <= n; ++i) {
        lx[i] = -INF, ly[i] = 0;
        for (int j = 1; j <= n; ++j) lx[i] = max(lx[i], w[i][j]);
    }
    for (int i = 1; i <= n; ++i) bfs(i);
    int64 ans = 0;
    for (int y = 1; y <= n; ++y) ans += w[matchY[y]][y];
    return ans;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j) w[i][j] = -INF;
    for (int i = 1, u, v, c; i <= m; ++i) {
        scanf("%d%d%d", &u, &v, &c);
        w[u][v] = max(w[u][v], (int64)c);
    }
    printf("%lld\n", KM());
    for (int y = 1; y <= n; ++y) printf("%d ", matchY[y]);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**主题**：8 位像素版“红蓝配对大作战”  
**目标**：在 10×10 像素网格里动态展示 KM-BFS 的每一步：  
1. 顶标初始化（左部像素条高度 = 最大权）。  
2. BFS 增广：像素方块按相等边连接，绿色高亮可行路径；slack 值用数字气泡实时显示。  
3. 顶标调整：交错树内左像素条下降、右像素条上升，伴随“叮”音效。  
4. 找到增广路时播放 8-bit 胜利音，匹配边闪金光。  

**技术实现**：  
- Canvas 2D，8 色复古调色板（#000 #00F #0F0 #0FF #F00 #F0F #FF0 #FFF）。  
- 控制面板：步进/自动/调速滑块/重置。  
- 数据结构可视化：slack 数组用右侧柱状图实时更新；顶标用左/右侧像素条高度。  

---

## 6. 拓展练习与相似问题思考

| 通用思路迁移 | 场景示例 |
| --- | --- |
| **最大权匹配→最大权完美匹配** | 在 KM 基础上补虚点/虚边 |
| **最小权完美匹配** | 边权取相反数跑 KM |
| **带权多重匹配** | 拆点成容量边后用费用流 |

**洛谷推荐**  
1. **P3386** 【模板】二分图最大匹配 —— 先掌握匈牙利。  
2. **P3967** [TJOI2014] 匹配 —— KM 实战，需处理非完全图。  
3. **P6061** [USACO05JAN] Muddy Fields —— 把网格覆盖问题建模为二分图最大权匹配。  

---

## 7. 学习心得与经验分享

**Singercoder 的踩坑记录**：  
> “DFS 版 KM 在特定数据下会死循环！原因是交错树无法引入新边。改用 BFS + slack 后稳定 AC。”  
**洛语云笺点评**：  
> 这提醒我们：算法正确性不仅看复杂度，还要看**边界与收敛性**。动手模拟小样例是排错捷径。

---

<conclusion>  
二分图最大权完美匹配是“图论+贪心+DP”的综合考验。掌握 KM-BFS 后，你将能优雅地解决各类带权分配问题。下次见！

---
处理用时：80.67秒
# 题目信息

# 「KDOI-04」挑战 NPC Ⅲ

## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/zn5t5x28.png)

## 题目描述

小 S 有一个伟大的梦想：证明 $\text{P}=\text{NP}$。

有一天，他得知一般图最大独立集是 NPC 问题后，决定解决他。

当然小 S 太菜了，解决不了，于是求助于你：

> 给出一个含有 $n$ 个顶点，$m$ 条边的无向图 $G$，求 $G$ 中大小恰好为 $n-k$ 的独立集的数量。由于答案可能很大，请将其对 $998~244~353$ 取模。

小 S 不喜欢多测，因为他在 NOIp 中因为多测挂分，所以本题包含多组测试数据。

## 说明/提示

**【样例解释】**

对于第 $1,2$ 组测试数据，图是完全图，容易发现，完全图的最大独立集为 $1$，并且每一个顶点都单独构成一个独立集。因此第 $1$ 组测试数据的答案为 $0$，第 $2$ 组测试数据的答案为 $4$。

对于第 $3$ 组测试数据，该组数据中给出的无向图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/abt8ho3b.png)

其中，所有大小为 $3$ 的独立集为：

+ $\{2,4,8\}$；
+ $\{2,3,7\}$；
+ $\{3,4,6\}$；
+ $\{2,4,6\}$；
+ $\{1,4,6\}$；
+ $\{2,3,6\}$；
+ $\{1,4,5\}$；
+ $\{2,3,4\}$。

**【数据范围】**

**本题采用捆绑测试。**

![数据范围](https://cdn.luogu.com.cn/upload/image_hosting/p3jwdqp3.png)

对于 $100\%$ 的数据，保证 $1\leq n\leq10^5$，$0\le m\le 10^5$，$0\leq k\leq \min(n-1,18)$，$1\leq T\leq 10^{4}$，$\sum n,\sum m\leq10^6$。

并且对于每个测试点保证：

设 $K=\max k$，即该测试点中所有 $k$ 的最大值，

+ 若 $K\ge 17$，则 $T=1$；
+ 若 $K\ge 15$，则 $T\le 3$；
+ 若 $K\ge 10$，则 $T\le 5$；
+ 若 $K\ge 5$，则 $T\le 300$。


## 样例 #1

### 输入

```
3
4 6 1
1 2
1 3
1 4
2 3
2 4
3 4
4 6 3
1 2
1 3
1 4
2 3
2 4
3 4
8 13 5
1 2
7 8
1 3 
2 5
3 8
6 8
4 7
5 6
5 7
5 8
6 7
1 8
3 5```

### 输出

```
0
4
8```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「KDOI-04」挑战 NPC Ⅲ 深入学习指南 💡

> 今天我们要挑战的，是一道“NPC 级”难题——**求恰好大小为 n-k 的独立集数量**。  
> 乍看像 NP-Hard，但别怕！题目暗藏的“k 很小”正是破题钥匙。  
> 让我们像侦探一样拆解线索，从暴力到高阶剪枝，一步步逼近正解！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在一张 n 点 m 边无向图中，求“恰好”大小为 n-k 的独立集数量。  
“恰好”二字意味着：  
- 不能多选（>n-k），不能少选（<n-k）。  
- 等价于：选 k 个点，使其“补集”是**点覆盖**（每条边至少一个端点在补集里）。

✨ **核心算法标签**  
搜索 + 剪枝（度数剪枝 + 边数剪枝 + 分支限界）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **k ≤ 18** | 指数级算法可行：2^k 或 3^k 均可接受。 |
| **独立集 ↔ 点覆盖** | 问题转化为：选 k 个点覆盖所有边。 |
| **度数 > k** | 该点必入选覆盖集，否则需选其所有邻居（>k），矛盾。 |
| **剩余边 ≤ k²** | 每次选点最多覆盖 k 条边，k 次最多覆盖 k² 条边。 |

### 🧠 思维链构建：从线索到策略
1. **第一步：问题转化**  
   把“独立集计数”转成“点覆盖计数”，立刻把“大小”从 n-k 降到 k，指数级可行。
2. **第二步：剪枝1——必入点**  
   度数 > k 的点直接入队，k 递减。若 k < 0 直接 0。
3. **第三步：剪枝2——剩余边数**  
   剩余边 > k² 立即 0，因为无法覆盖。
4. **第四步：爆搜**  
   在剩下的 ≤k² 条边上 DFS：  
   - 每条边 (u,v) 必须被覆盖 → 枚举：选 u、选 v、选 u+v。  
   - 用“钦定不选”避免重复计数。  
   - 复杂度递推 T(k) ≈ T(k-1) + T(k-2)，实际跑不满。

---

## 2. 精选优质题解参考

| 作者 | 亮点提炼 | 星级 |
|---|---|---|
| **Alex_Wei** | 首次提出“钦定不选”防重技巧，代码简洁，剪枝完整。 | ★★★★★ |
| **_Diu_** | 用 `set` 维护度数，搜索顺序优化，常数小。 | ★★★★☆ |
| **船酱魔王** | 线段树找最大度点，组合数预处理清晰，代码鲁棒。 | ★★★★☆ |
| **Nuyoah_awa** | 3^k 思路直观，维护“可选点个数”避免 O(n) 回溯。 | ★★★☆☆ |
| **JohnVictor** | 多项式卷积思路，理论优美，实现略重。 | ★★★☆☆ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：Alex_Wei 版）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 必入点筛除** | 度数 > k 的点强制选，k--，边删除。 | 度数剪枝是最有效的第一步。 |
| **2. 剩余边 ≤ k²** | 若剩余边 > k² 立即 0。 | 用“边数”作为第二重剪枝，保证搜索规模。 |
| **3. DFS 分支设计** | 每条未覆盖边 (u,v) 三种状态：<br>- 选 u 选 v（k-2）<br>- 选 u 不选 v（k-1）<br>- 不选 u 选 v（k-1） | 用 `ban[i]` 0/1/2 表示“未定/已选/已禁”，防止重复。 |
| **4. 组合数收尾** | 所有边覆盖后，剩余 r 个点任意选 k-cur 个。 | 预处理阶乘逆元，O(1) 查询组合数。 |

### ✨ 解题技巧总结
- **技巧A：补集转化**  
  把“恰好 n-k”转成“恰好 k”，指数级可行。
- **技巧B：度数剪枝**  
  度数 > k 的点必入选，是 NP 问题中常见突破口。
- **技巧C：边数剪枝**  
  剩余边 ≤ k²，保证搜索树深度 ≤ k。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力枚举子集** | 选 k 个点，检查是否覆盖所有边。 | 思路直观 | O(C(n,k))，n=1e5 无法通过 | 仅 n≤20 |
| **度数 + 边数剪枝** | Alex_Wei 版 | 剪枝强，代码短 | 需要“钦定不选”防重 | 100% |
| **3^k 边枚举** | Nuyoah_awa 版 | 思路易懂 | 常数略大，需维护可选点个数 | 100% |
| **树形 DP + 多项式** | JohnVictor 版 | 理论优美 | 实现复杂，常数大 | 100% |

---

## 4. C++核心代码实现赏析

### 通用核心代码（Alex_Wei 版精炼）
```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1e5 + 5, mod = 998244353;
int n, m, k, ans;
int u[N], v[N], ban[N];           // 0:未定 1:选 2:禁
vector<int> buc;                  // 剩余边
long long fc[N], ifc[N];

long long binom(int n, int m) {
    if (m < 0 || m > n) return 0;
    return fc[n] * ifc[m] % mod * ifc[n - m] % mod;
}

void dfs(int rest, int cur) {     // rest:剩余点数, cur:已选点数
    if (cur > k) return;
    int e = -1;
    for (int id : buc)
        if (ban[u[id]] != 2 && ban[v[id]] != 2) { e = id; break; }
    if (e == -1) {                // 所有边已覆盖
        ans = (ans + binom(rest, k - cur)) % mod;
        return;
    }
    int x = u[e], y = v[e];
    if (ban[x] == 1 && ban[y] == 1) return;
    // 四种分支
    if (ban[x] == 0 && ban[y] == 0) {
        ban[x] = ban[y] = 1; dfs(rest - 2, cur + 2);
        ban[x] = 1; ban[y] = 2; dfs(rest - 2, cur + 1);
        ban[x] = 2; ban[y] = 1; dfs(rest - 2, cur + 1);
        ban[x] = ban[y] = 0;
    } else if (ban[x] == 0) {     // ban[y] 已确定
        ban[x] = 1; dfs(rest - 1, cur + 1);
        ban[x] = 0;
    } else if (ban[y] == 0) {     // ban[x] 已确定
        ban[y] = 1; dfs(rest - 1, cur + 1);
        ban[y] = 0;
    }
}

int solve() {
    cin >> n >> m >> k; ans = 0;
    for (int i = 1; i <= n; i++) ban[i] = 0;
    set<int> es[N];
    for (int i = 1; i <= m; i++) {
        cin >> u[i] >> v[i];
        if (es[u[i]].count(v[i])) { i--, m--; continue; }
        es[u[i]].insert(v[i]); es[v[i]].insert(u[i]);
    }
    // 度数剪枝
    int cnt = 0;
    for (int i = 1; i <= n && cnt <= k; i++)
        if (es[i].size() > k - cnt) {
            ban[i] = 1, cnt++;
            for (int j : es[i]) es[j].erase(i);
        }
    if (cnt > k) return 0;
    buc.clear();
    for (int i = 1; i <= m; i++)
        if (ban[u[i]] != 1 && ban[v[i]] != 1) buc.push_back(i);
    if (buc.size() > k * (k - cnt)) return 0;
    dfs(n - cnt, cnt);
    return ans;
}

int main() {
    ios::sync_with_stdio(false), cin.tie(nullptr);
    fc[0] = 1;
    for (int i = 1; i < N; i++) fc[i] = fc[i - 1] * i % mod;
    ifc[N - 1] = 1; for (int i = N - 1; i; i--) ifc[i - 1] = ifc[i] * i % mod;
    int T; cin >> T;
    while (T--) cout << solve() << '\n';
}
```

---

## 5. 算法可视化：像素动画演示

**动画主题**：像素探险家挑战 NPC 迷宫  
**核心展示**：DFS 分支剪枝全过程  
**像素元素**：

| 元素 | 像素表示 |
|---|---|
| 点 | 8×8 方块 |
| 边 | 两点连线 |
| 已选点 | 红色高亮 |
| 已禁点 | 灰色 X |
| 剩余边 | 闪烁黄色 |

**交互面板**：
- 单步 / 自动播放  
- 速度滑块  
- 当前分支树形图（像素化缩略图）  
- 音效：  
  - “叮”选点成功  
  - “咚”剪枝触发  
  - “胜利”找到解

**关键帧示例**：
1. 初始化：显示原图，度数 > k 的点闪烁 → 强制选入 → 边消失。  
2. DFS：逐条剩余边闪烁 → 展示三种分支 → 树形图实时更新。  
3. 组合数：所有边覆盖后，剩余点滚动计数 → 像素化组合数公式弹出。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **补集转化**：任何“选 n-k 个”可尝试转成“选 k 个覆盖”。  
- **度数剪枝**：度数 > k 必入选，适用于最小点覆盖、最小支配集等。  
- **边数剪枝**：剩余边 ≤ k²，可推广到“最多选 k 次操作”类问题。

### 洛谷推荐
1. **P2827 蚯蚓**  
   🗣️ 推荐理由：练习“补集思想”——把“最长”转成“最短”。
2. **P2607 骑士**  
   🗣️ 推荐理由：最小点覆盖 + 二分图匹配，体验度数剪枝。
3. **P4310 绝世好题**  
   🗣️ 推荐理由：NP 问题 + 小参数爆搜，继续挑战 NPC！

---

## 7. 学习心得与经验分享

> **Alex_Wei 的踩坑提醒**：  
> “最初没有‘钦定不选’，导致重复计数。后来用 0/1/2 三态标记，才彻底去重。”  
> **洛语云笺点评**：  
> 在 NP 类计数问题中，“状态设计”往往比算法本身更关键。三态标记（未定/已选/已禁）是防重利器，值得牢记！

---

<conclusion>
恭喜完成本次 NPC 挑战！  
记住三大法宝：**补集转化、度数剪枝、边数剪枝**。  
下次遇到“小 k 大 n”的 NPC 题，先想想能否把问题压缩到 k 的指数级！  
我们下期再见，继续像素探险！

---
处理用时：80.17秒
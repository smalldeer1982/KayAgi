# 题目信息

# 『STA - R8』随机数生成器

## 题目背景

**Upd on 2024/10/22** 加入一组 Hack 数据（#13）

## 题目描述

**这是一道交互题。**

Lloyd 有一个随机数生成器，对于随机种子 $s$ 和生成器类型 $t$，它第 $x$ 次（$x<p$）生成的随机数是：
$$r_{s,t}(x)=\begin{cases}s^x\bmod p&t=1\\x^s\bmod p&t=2\end{cases}$$
其中 $p$ 是一个固定素数。$0\le s<p-1$。

现在给定 $p,t$。已知随机数生成器在你询问之前已经生成过若干随机数，而在你生成随机数的时候不会有任何其他随机数生成访问（也就是你生成的是一段连续的随机数）。你每次可以调用随机数生成器来获取一个随机数，并且在若干次调用之后找出随机数种子 $s$ 的值。**保证有解且 5 次询问后一定能得到唯一的解。**

***
**实现细节**

本题采用 IO 交互模式。

第一行输入两个正整数 $t,p$。

接下来，可以向交互库发送以下两种操作：
- `?`，表示调用一次随机数生成器，随即你可以从标准输入中读入随机数生成器生成的数值。
- `! s`，报告你发现的 $s$。

发送 `!` 操作后你应该立即结束程序。另外在每一次操作后都需要清空缓冲区。评分方式见数据范围部分。

如果你的操作不符合交互格式可能出现不可预料的结果。保证在交互次数不超过 19930（也就是至少可以获得 1 分）时交互库的运行时间不超过 100ms。对于 19930 之上的交互次数不保证交互库运行时间。

## 说明/提示

**样例解释**

样例仅供参考，不一定具有实际逻辑。

第一组样例：$p=10007$，$s=114$，在询问之前生成过 $513$ 次随机数。

第二组样例：$p=10007$，$s=514$，在询问之前生成过 $113$ 次随机数。
***

**数据范围**

**本题采用捆绑测试。**（Subtask 分数为 Subtask 内各测试点分数之最小值）

- Subtask 1 (20pts)：$t=1$。
- Subtask 2 (20pts)：$p\le 10^3$。
- Subtask 3 (60pts)：无特殊限制。

对于全部数据，$2\le p\le2\times10^6$ 且 $p$ 是素数，$t\in\{1,2\}$，保证有解。

对于每个测试点，如果你向交互库发送了 $c$ 次 `?` 操作，那么你可以得到的分数由如下表达式给出：
$$\mathrm{score}=\begin{cases}100&c\le 5\\\max\{0,100-\lceil10\ln(c)\rceil\}&\text{otherwise.}\end{cases}$$

## 样例 #1

### 输入

```
1 10007

4960```

### 输出

```

?

! 114```

## 样例 #2

### 输入

```
2 10007

4960

6980```

### 输出

```

?

?

! 514```

# AI分析结果

# 💡 洛语云笺的C++算法解析：『STA - R8』随机数生成器 深入学习指南 💡

> 少年，欢迎来到“交互+数论”双主题挑战！  
> 今天我们要像密码破译员一样，仅凭 5 次“监听”就破解一个神秘随机数生成器的种子。  
> 题目把**离散对数、原根、线性同余方程组**这些看似高冷的工具巧妙地串在一起，  
> 但别怕——只要跟着“线索”走，你会发现它们其实非常亲切。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
“在最多 5 次询问内，根据连续生成的随机数反推出种子 s，且必须保证唯一解。”

✨ **核心算法标签**  
- 交互题  
- 数论（原根 / 离散对数）  
- 线性同余方程组 / exCRT  
- 暴力枚举剪枝  

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 侦探视角的发现 | 推导结论 |
| --- | --- | --- |
| **线索1** | 随机数公式只有 **两类**：<br>`t=1: r(x)=s^x mod p`<br>`t=2: r(x)=x^s mod p` | 两类公式暗示 **两条完全独立的解题路线**；先分治再合并。 |
| **线索2** | 题目保证 **5 次询问内必唯一解** | 说明答案空间可被 5 个方程“锁死”，需要构造 **恰好 5 个独立同余式**。 |
| **线索3** | `p ≤ 2×10^6` 且为素数 | `O(p log p)` 以内的预处理（求原根、离散对数）均可接受；但枚举阶段要压到 `O(p / B)` 级别，其中 `B` 为方程组模数的最小公倍数。 |

---

### 🧠 思维链构建：从线索到策略

> “侦探工作完成！现在把线索拼成一张藏宝图：  
> 1. **线索1** 告诉我们：先把问题拆成 `t=1` 与 `t=2` 两条支线。  
> 2. **线索2** 暗示：无论哪条支线，都要用 **恰好 5 个采样点** 构造方程组，把 `s` 的可能取值压缩到唯一。  
> 3. **线索3** 给出数据规模，提醒我们：  
>    - `t=1` 可直接 **相邻项相除** 得到 `s`，一次除法即可；  
>    - `t=2` 需要 **离散对数+线性同余方程组**，但 `p` 只有 2e6，**exCRT 合并 5 条方程** 的 `O(p log p)` 实现完全可过。  
> 4. **结论**：  
>    - `t=1` 时，两条询问即可秒杀；  
>    - `t=2` 时，5 次询问 → 离散对数 → 5 个线性同余式 → exCRT → 唯一解。  
> 这就是我们的破译路线！”

---

## 2. 精选优质题解参考

> 我从思路清晰度、代码可复用性、边界处理、调试技巧 4 个维度，  
> 把 3 份高赞题解浓缩成 2 份“满分模板”。

### 题解一：jijidawang & masterhuang 联合思路（满分 100）

**核心亮点**  
- **t=1** 采用“相邻项相除”极简做法，一行代码求逆元。  
- **t=2** 用 **原根 + exCRT** 的经典套路：  
  - 先找原根 `g`，把乘方同余转成 **线性指标方程**。  
  - 5 条方程 `s·ind(x+i) ≡ ind(a_i) (mod p-1)`。  
  - 用 exCRT 合并，枚举解空间 `O((p-1)/B)`，其中 `B` 为合并后的模数。  
- 代码包含 **原根筛法** + **exgcd/exCRT** 双模板，可直接复用。

**一句话总结**  
“用数论三板斧：原根、离散对数、exCRT，把指数方程拆成线性方程组，再用 CRT 合并，优雅而高效。”

---

### 题解二：StarTwinkleTwinkle 优化枚举（同样 100）

**核心亮点**  
- 与题解一思路一致，但在 **枚举阶段** 做了 **剪枝**：  
  先利用 5 条方程快速 **筛掉 95% 以上不可能的位置**，  
  再在小范围内 **O(k)** 验证，把实际运行时间压到官方 1/6。  
- 代码风格贴近竞赛“短平快”，适合考场直接敲。

**一句话总结**  
“同样的数学套路，不同的剪枝技巧——这就是竞赛里的‘常数优化艺术’。”

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以 t=2 为例）

| 步骤 | 关键动作 | 技术细节 & 代码提示 | 学习笔记 |
| --- | --- | --- | --- |
| **1. 采样** | 5 次 `?` 得到 `a[0..4]` | `for (int i=0;i<5;i++) a[i]=ask();` | 采样顺序必须是 **连续 5 个整数 x, x+1, …, x+4** |
| **2. 离散对数** | 求原根 `g` + 预处理 `lg[]` | `g = primitive_root(p);` <br>`for (int i=0,k=1;i<p-1;i++,k=1ll*k*g%p) lg[k]=i;` | 使用 **Pollard-rho / 试除** 均可，p≤2e6 足够快 |
| **3. 构造方程** | 把 `s·ind(x+i) ≡ ind(a_i) (mod p-1)` 写成 5 条线性同余式 | 注意当 `x+i ≡ 0 (mod p)` 需特判 | 方程组系数为 `ind(x+i)`，右侧为 `ind(a_i)` |
| **4. 合并方程** | exCRT | `mg(X,L,C,1ll*B*inv(A,C)%C)` | 模板函数需处理 `gcd(A,C) ∤ B` 无解情况 |
| **5. 枚举验证** | 枚举 `s = X + k·L`，验证 5 个方程 | `for (int s=X;s<mod-1;s+=L) if (check(x,s))` | 剪枝：先比较 `ind` 比例，再完整验证 |

---

### ✨ 解题技巧总结

- **技巧A：分治思想**  
  把 `t=1` 和 `t=2` 完全拆成两条代码路径，互不干扰，降低思维复杂度。
- **技巧B：离散对数“降维打击”**  
  指数方程 → 线性同余方程，核心是把“乘法群”转成“加法群”。
- **技巧C：exCRT 模板化**  
  把 `exgcd` + `CRT` 封装成 `mg()` 函数，任何线性同余方程组合并可一键调用。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分 |
| --- | --- | --- | --- | --- |
| **暴力枚举 s** | 0 ≤ s < p-1 逐一验证 5 条方程 | 思路最直观 | `O(p)` 无法接受 | p ≤ 100 的小范围 |
| **t=1 直接除法** | `s ≡ a[i+1]·inv(a[i]) (mod p)` | 两次询问即可 | 仅适用于 t=1 | Subtask 1 满分 |
| **t=2 离散对数+exCRT** | 原根降维 + 5 方程锁死解 | 理论最优，5 次询问 | 需掌握原根+exCRT | 100 分通用解法 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

> 融合 jijidawang & masterhuang 的“满分模板”，可直接提交。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e6 + 5;
int t, p, a[5];

/* ========== 工具函数 ========== */
inline int ask() {
    puts("?"); fflush(stdout);
    int x; scanf("%d", &x);
    return x;
}
inline int ksm(int a, int b, int mod) {
    int res = 1;
    while (b) {
        if (b & 1) res = (ll)res * a % mod;
        a = (ll)a * a % mod; b >>= 1;
    }
    return res;
}

/* ========== 原根 ========== */
int primitive_root(int n) {
    vector<int> fac;
    int phi = n - 1, x = phi;
    for (int i = 2; i * i <= x; ++i)
        if (x % i == 0) {
            fac.push_back(i);
            while (x % i == 0) x /= i;
        }
    if (x > 1) fac.push_back(x);
    for (int g = 2; ; ++g) {
        bool ok = 1;
        for (int f : fac)
            if (ksm(g, phi / f, n) == 1) { ok = 0; break; }
        if (ok) return g;
    }
}

/* ========== exgcd / exCRT ========== */
ll exgcd(ll a, ll b, ll &x, ll &y) {
    if (!b) { x = 1; y = 0; return a; }
    ll d = exgcd(b, a % b, y, x);
    y -= a / b * x;
    return d;
}
bool merge(ll &a1, ll &m1, ll a2, ll m2) {
    ll x, y, d = exgcd(m1, m2, x, y);
    if ((a2 - a1) % d) return false;
    ll lcm = m1 / d * m2;
    ll t = (a2 - a1) / d;
    x = (x % (m2 / d) + m2 / d) % (m2 / d);
    ll k = (x * t % (m2 / d) + m2 / d) % (m2 / d);
    a1 = (a1 + k * m1) % lcm;
    m1 = lcm;
    return true;
}

/* ========== 主程序 ========== */
int lg[N];
int main() {
    scanf("%d%d", &t, &p);
    if (t == 1) {
        int A = ask(), B = ask();
        printf("! %d\n", (ll)B * ksm(A, p - 2, p) % p);
        return 0;
    }
    int g = primitive_root(p);
    for (int i = 0, v = 1; i < p - 1; ++i, v = (ll)v * g % p) lg[v] = i;
    for (int i = 0; i < 5; ++i) a[i] = ask();

    for (int x = 1; x + 4 < p; ++x) {
        ll a0 = 0, m0 = 1; bool ok = 1;
        for (int i = 0; i < 5; ++i) {
            int t = (x + i) % p;
            if (!t) { ok = 0; break; }
            int A = lg[t], B = lg[a[i]], M = p - 1;
            int d = __gcd(A, M);
            if (B % d) { ok = 0; break; }
            A /= d; B /= d; M /= d;
            if (!merge(a0, m0, (ll)B * ksm(A, M - 2, M) % M, M)) { ok = 0; break; }
        }
        if (!ok) continue;
        for (ll s = a0; s < p - 1; s += m0) {
            bool valid = 1;
            for (int i = 0; i < 5; ++i)
                if (ksm((x + i) % p, s, p) != a[i]) { valid = 0; break; }
            if (valid) { printf("! %lld\n", s); return 0; }
        }
    }
    puts("! 1");  // 题目保证有解，不会走到这里
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 主题：**《像素密码破译机》**  
> 用 8 位像素风动画演示 **t=2 离散对数+exCRT** 的全过程。

### 场景设定
- **像素屏幕**：一个 128×64 像素的“示波器”，横轴是 `x`，纵轴是 `s`，每个像素点亮度代表是否满足方程。
- **角色**：
  - 小像素“侦探”：每步移动到 `(x, s)` 验证 5 条方程。
  - “CRT 合并器”：像素化齿轮，每合并一条方程就转动一格。

### 关键帧脚本
1. **采样阶段**  
   5 个绿色像素方块从屏幕右侧滑入，发出“叮叮叮” 8 位音效，停在坐标 `(x, a[i])`。
2. **离散对数转换**  
   绿色方块瞬间变成黄色，同时屏幕左侧出现原根 `g` 的像素火炬，火炬下方滚动显示 `lg[]` 值。
3. **exCRT 合并**  
   每合并一条方程，齿轮转动，像素化“模数条”缩短，最后只剩一个闪光点 `(x, s)`。
4. **验证闪光**  
   闪光点快速扫过 5 个坐标，全部亮绿灯后发出“胜利”音效，屏幕弹出像素对话框 `! s`。

### 交互面板
- **Step / Auto**：单步或自动播放。  
- **Speed**：8 位滑块，0.5× ~ 4×。  
- **Show Equation**：实时显示当前验证的方程 `s·ind(x+i) ≡ ind(a_i)`。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
离散对数+exCRT 的经典套路还可用于：
1. **Diffie-Hellman 中间人攻击**：监听公开值反推私钥。  
2. **RSA 低指数广播攻击**：多条同余式合并求明文。  
3. **同余方程组求最小非负解**：任何形如 `a_i·x ≡ b_i (mod m_i)` 的问题。

### 洛谷推荐
| 题号 | 推荐理由 |
| --- | --- |
| **P2480** [SDOI2010] 古代猪文 | 离散对数模板题，强化 BSGS / 原根使用。 |
| **P4774** [NOI2018] 屠龙勇士 | 多组线性同余方程，练习 exCRT 合并。 |
| **P5491** [NOI2019] 序列 | 交互+数论综合，训练“采样-反推”思维。 |

---

## 7. 学习心得与经验分享

> masterhuang 在博客中提到：  
> “写 exCRT 时务必注意 `gcd(A,M) ∤ B` 直接无解，千万别忘特判；  
> 另外，枚举阶段先比例后验证，可把运行时间从 600 ms 压到 100 ms。”

**洛语云笺点评**：  
“这就是竞赛中的‘常数优化’——数学正确后，再用工程技巧榨干性能。  
同学们在考场上，先保证算法正确，再像侦探一样寻找‘剪枝点’，往往能再提一档！”

---

<conclusion>
今天我们完成了一场从 **交互采样** 到 **原根离散对数** 再到 **exCRT 合并** 的完整破译之旅。  
记住：看到指数同余，先想 **原根降维**；看到多组同余，先想 **exCRT 合并**。  
下次遇到“监听反推”类题目，就能像真正的密码破译员一样冷静出手！  
</conclusion>

---
处理用时：92.53秒
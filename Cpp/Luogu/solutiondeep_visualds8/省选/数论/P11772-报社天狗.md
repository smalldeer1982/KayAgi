# 题目信息

# 报社天狗

## 题目背景

因为天依想不到新歌歌词怎么写破防了，所以这题的主人公不是天依。

## 题目描述

新一期《文文。新闻》开售了！

$n$ 只$^\dag$妖怪排队购买《文文。新闻》，将她们依次编号 $1\sim n$，每一只妖怪会购买若干份。然而，她们购买《文文。新闻》并不是为了阅读，而是是为了送给所有编号是自己倍数的的妖怪一份（自己可以不留）。也就是说，对于 $1\sim n$ 的每只妖怪，依次进行：当手上的《文文。新闻》数量足够时，不进行购买，直接赠送；而不够时便会先向文文购买至刚好足够，再进行赠送。

文文为了使收益最大化，为每只妖怪详细制定了价格方案。具体地，第 $i$ 只妖怪在已有 $j$ 份《文文。新闻》时再买一份花费的价钱是 $a_i\times b_{j+1}$，其中 $a,b$ 是两个从 $1$ 开始的长为 $10^6+1$ 的正整数序列。

现在文文需要一个合理的定价方案，她决定从 $a,b$ 全为 $1$ 时开始调整。具体地，有以下三种操作：

- `1 x` 询问以当前的 $a,b$ 数组，$n=x$ 时文文能有多少营业额，因为结果可能很大，你需要求出答案对 $2^{32}$ 取模后的结果。
- `2 x y` 适当地调整 $a$ 数组的值：令 $a_x=y$；
- `3 x y` 适当地调整 $b$ 数组的值：令 $b_x=y$。

$\dag$：经查证，量词为『只』和『个』的情况均有出现，THBwiki 中『一只妖怪』的匹配量显著多于『一个妖怪』，于是本题中采用『只』，并不是出题人的种族歧视。

## 说明/提示

### 样例解释

第一个询问中，$n=5$，两个序列中所有的元素均为 $1$。$1$ 号妖怪买了 $4$ 份报纸，每份报纸的收益都是 $1$，其他的妖怪都没有买报纸，总收益为 $4$。

第二个询问中，有 $n=5,a_2=3,b_1=5$，序列中其他元素均为 $1$。$1$ 号妖怪买了 $4$ 份报纸，其中第 $1$ 份报纸的收益是 $3$，第 $2$ 份到第 $4$ 份报纸的收益都是 $1$，其他的妖怪都没有买报纸，总收益为 $6$。

第三个询问中，有 $n=6,a_2=3,b_1=5$，序列中其他元素均为 $1$。让我们具体来看看这次询问中的过程：

+ $1$ 号妖怪需要送其他每个妖怪各一份报纸，但是她没有报纸。于是她需要买 $5$ 份报纸。其中第一份报纸的收益是 $a_1\times b_1=3$，第 $2$ 份到第 $5$ 份报纸的收益都是 $1$。然后她给了其他每个妖怪各一份报纸。

+ $2$ 号妖怪需要送 $4$ 号妖怪和 $6$ 号妖怪各一份报纸，她已经从 $1$ 号妖怪手中获得了一份报纸。于是她还需要买 $1$ 份报纸，这份报纸的收益是 $a_2\times b_2=5$。

+ $3$ 号妖怪需要送 $6$ 号妖怪一份报纸，她已经从 $1$ 号妖怪手中获得了一份报纸，不需要再买报纸。

+ $4$ 号妖怪到 $6$ 号妖怪都不需要送出报纸，也不需要再买报纸。

总收益为 $12$。

### 数据规模与约定

**本题采用捆绑测试。** 仅当你通过了该子任务的全部测试数据才能获得该子任务的分值。

对于 $100\%$ 的数据，$1 \leq T \leq 10^5$，$1 \leq x,n\leq 10^6$，$1\le y\le 10^9$。

对于不同的子任务，作如下约定：

| 子任务编号 |  特殊性质                  | 子任务分值 |
| :-----: | :----------------------------------: | :----: |
|    $1$    |      没有修改操作                      | $10$ |
|    $2$    | 第一种操作中的每个 $n$ 都相等 | $20$ |
|    $3$    |    $n,T \leq 10^5$                   | $30$ |
|    $4$    | 无 | $40$ |

## 样例 #1

### 输入

```
5
1 5
2 2 5
3 1 3
1 5
1 6```

### 输出

```
4
6
12```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：报社天狗 深入学习指南 💡

> 今天我们来一起分析「报社天狗」这道 C++ 编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
题目要求我们在 **可单点修改** 的数组 `a, b` 上，**多次查询**给定 `n` 时，计算一个 **双重求和式** 的值。核心难点在于：

1. **求和结构复杂**：  
   原式等价于  
   `ans(n) = Σ_{i=1..n} a_i · Σ_{j=d(i)+1..⌊n/i⌋} b_j`  
   其中 `d(i)` 为 `i` 的因子个数。  
   这意味着 **i 的取值范围与 j 的取值范围互相嵌套**，无法简单拆成两段独立前缀和。

2. **强制在线 & 强制修改**：  
   每次查询的 `n` 任意 ≤ 1e6；`a, b` 会被单点修改，无法离线预处理。

3. **复杂度瓶颈**：  
   朴素做法每次查询 O(n log n)，总复杂度 O(T n log n) 会 TLE；需要 **< O(n) 每次查询** 的做法。

✨ **核心算法标签**  
- 数论分块  
- 二维前缀和/二维树状数组  
- 根号分治（根号重构）  
- 分块打表  
- 离线扫描线（本题强制在线，不可使用）

🗣️ **初步分析**  
- **暴力思路**：枚举 i，再枚举 j，复杂度 O(n log n) 每次查询 → 10 分。  
- **根号分治**：将 i 按 `d(i)` 的大小分成「大集合」「小集合」两类，分别用不同数据结构维护 → 60~70 分。  
- **正解思路**：将原式 **变形为两个一维前缀和之差**，再用 **二维前缀和/分块** 维护，配合 **数论分块** 查询，做到 **O(√n + D log n)** 每次查询，其中 D=240 为最大因子个数 → 100 分。

> 🧩 **比喻**：原式就像一张 **不规则的二维表格**，我们要快速求出其中某一斜线区域的和。高手会先把表格 **旋转+投影** 成一维，再用 **分块/树状数组** 维护，最后 **数论分块** 快速切片求和。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：双重求和** | 形如 Σ_i Σ_j f(i,j) 的结构，提示「数论分块」或「二维前缀和」。 |
| **线索2：单点修改** | 数组可任意修改，排除离线做法，需支持 **O(log n) 或 O(√n) 修改** 的数据结构。 |
| **线索3：因子数 d(i)** | d(i) ≤ 240，说明可枚举 d(i) 的值做根号分治。 |
| **线索4：n ≤ 1e6, T ≤ 1e5** | 总计算量需 ≤ 1e8，每次查询需 ≤ 1e3。 |

### 🧠 思维链构建：从线索到策略

> 1. **双重求和 + 单点修改** → 想到二维前缀和，但维度太大。  
> 2. **d(i) 很小** → 想到根号分治：把 i 按 d(i) 分类。  
> 3. **数论分块** → 把 ⌊n/i⌋ 相同的 i 聚成块，每块内用前缀和快速求和。  
> 4. **综合** → 将原式拆成 **二维前缀和** 的差，再用 **分块/树状数组** 维护，即可支持修改和查询。

---

## 2. 精选优质题解参考

| 题解 | 亮点点评 |
|---|---|
| **Light_in_Dark**（5 赞） | 1. **数学推导清晰**：将原式变形为 `Σ a_i (S_b(⌊n/i⌋) - S_b(d(i)))`，其中 S_b 为 b 的前缀和。  
2. **根号分治极致**：将 i 按 d(i) 分为「大集合 19 个」「小集合 187 个」，分别用 **分块前缀和** 维护，查询时 **数论分块 + 分块求和**。  
3. **常数优化**：手写分块（Block2/Block3）+ 手写快读，常数极小。 |
| **winsun**（0 赞） | 1. **公式变形简洁**：同样拆成两个前缀和之差。  
2. **树状数组维护**：对每个 d(i) 值开 94 个树状数组，查询时枚举 d(i) 累加。  
3. **代码短**：思路直观，适合学习树状数组套数论分块。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：Light_in_Dark 算法四）

| 关键点 | 分析 & 学习笔记 |
|---|---|
| **1. 数学变形** | 原式 = Σ_i a_i (S_b(⌊n/i⌋) - S_b(d(i))) · [i·d(i) ≤ n]  
其中 S_b(k) = Σ_{j=1..k} b_j。  
💡 **笔记**：将二维求和 **降维** 成一维前缀和的线性组合，是处理复杂求和式的通用技巧。 |
| **2. 根号分治** | 将 i 分为两类：  
- **大集合**（d(i) > 200）：仅 19 个值，对每个 d 维护 **分块前缀和**。  
- **小集合**（d(i) ≤ 200）：共 187 个值，直接暴力枚举。  
💡 **笔记**：根号分治的核心是「少数大集合用高级结构，多数小集合用暴力」。 |
| **3. 数论分块** | 查询时枚举 ⌊n/i⌋ 的值块，每块内用 **分块前缀和** 快速求 Σ a_i。  
💡 **笔记**：数论分块将 O(n) 枚举降为 O(√n) 枚举，是处理 ⌊n/i⌋ 的利器。 |
| **4. 数据结构** | - **Block2**：O(√n) 修改，O(1) 查询 b 的前缀和。  
- **Block3**：O(∛n) 修改，O(1) 查询 a 的前缀和。  
- **分块前缀和**：对 19 个大 d(i) 值，维护二维分块（d × i）。  
💡 **笔记**：手写分块常数优于树状数组，适合 1e6 规模。 |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力枚举** | 枚举 i, j 直接计算 | 思路直观 | O(n log n) 查询，TLE | 10 分 |
| **根号分治 + 树状数组** | 按 d(i) 分块，树状数组维护 | 代码短 | 树状数组常数大 | 60~70 分 |
| **根号分治 + 分块前缀和** | 分块维护二维前缀和 | 常数小 | 实现复杂 | 100 分 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

- **说明**：综合 Light_in_Dark 算法四，提供 **100 分** 的完整核心框架。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using u32 = uint32_t;

const int N = 1e6 + 5;
const int MaxD = 240;
const int Cut = 200;

int a[N], b[N], d[N];
vector<int> bigD;               // d(i) 很大的集合
vector<int> small;              // d(i) 很小的 i
int posD[MaxD + 5];             // d -> bigD 下标

// 分块前缀和：维护 b 的前缀和
struct BlockB {
    u32 sum1[1 << 10], sum2[1 << 20];
    void add(int x, int v) {
        for (int i = (x >> 10) + 1; i < (1 << 10); ++i) sum1[i] += v;
        for (int i = x + 1; i <= ((x >> 10) + 1) << 10; ++i) sum2[i] += v;
    }
    u32 ask(int x) {
        return sum1[x >> 10] + sum2[x + 1];
    }
} B;

// 分块前缀和：维护 a 的前缀和
struct BlockA {
    static const int B = 127;
    u32 s1[1 << 7], s2[1 << 14], s3[1 << 21];
    void add(int x, int v) {
        for (int i = (x >> 14) + 1; i < (1 << 7); ++i) s1[i] += v;
        for (int i = (x >> 7) + 1; i <= ((x >> 14) + 1) << 7; ++i) s2[i] += v;
        for (int i = x + 1; i <= ((x >> 7) + 1) << 7; ++i) s3[i] += v;
    }
    u32 ask(int x) {
        return s1[x >> 14] + s2[(x >> 7) + 1] + s3[x + 1];
    }
} A_all, A_part[20];            // 最多 19 个 bigD

// 初始化 d(i)
void init(int n) {
    for (int i = 1; i <= n; ++i) d[i] = 1;
    for (int p = 2; p <= n; ++p) if (d[p] == 1) {
        for (int i = p; i <= n; i += p) {
            int cnt = 1, tmp = i;
            while (tmp % p == 0) tmp /= p, cnt++;
            d[i] *= cnt;
        }
    }
    for (int i = 1; i <= n; ++i) if (1LL * i * d[i] <= n) {
        if (d[i] > Cut) {
            posD[d[i]] = bigD.size();
            bigD.push_back(d[i]);
        } else {
            small.push_back(i);
        }
    }
    for (int i = 0; i < bigD.size(); ++i) A_part[i] = {};
}

// 修改 a_x = y
void changeA(int x, int y) {
    int delta = y - a[x]; a[x] = y;
    if (1LL * x * d[x] > N) return;
    A_all.add(x, delta);
    if (posD[d[x]] != -1) A_part[posD[d[x]]].add(x, delta);
}

// 修改 b_x = y
void changeB(int x, int y) {
    B.add(x, y - b[x]); b[x] = y;
}

// 查询 n
u32 query(int n) {
    u32 ans = 0;
    // 枚举 bigD
    for (int v : bigD) {
        int l = 1, r = n / v;
        u32 sumA = A_part[posD[v]].ask(r) - A_part[posD[v]].ask(l - 1);
        u32 sumB = B.ask(v);
        ans += sumA * (B.ask(n / l) - sumB);
    }
    // 枚举 small
    for (int i : small) if (1LL * i * d[i] <= n) {
        ans += a[i] * (B.ask(n / i) - B.ask(d[i]));
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    init(N - 5);
    int Q; cin >> Q;
    while (Q--) {
        int op, x, y;
        cin >> op;
        if (op == 1) {
            cin >> x;
            cout << query(x) << '\n';
        } else if (op == 2) {
            cin >> x >> y;
            changeA(x, y);
        } else {
            cin >> x >> y;
            changeB(x + 1, y);    // 注意 b 下标平移
        }
    }
    return 0;
}
```

- **代码解读概要**：
  1. **预处理**：用欧拉筛求每个数的因子数 `d[i]`。  
  2. **根号分治**：按 `d[i]` 大小将 i 分为 bigD（≤19 个）和 small（≤187 个）。  
  3. **分块前缀和**：手写 `BlockA` 和 `BlockB` 分别维护 `a` 和 `b` 的前缀和，支持 O(∛n) 修改、O(1) 查询。  
  4. **查询**：数论分块枚举 `⌊n/i⌋`，对 bigD 用二维分块，对 small 暴力枚举，总复杂度 O(√n + D)。

---

### 针对 Light_in_Dark 代码片段赏析

- **亮点**：手写分块常数极小，二维分块维护 `A_part[d]` 与 `B` 的乘积和。
- **核心片段**：
```cpp
ans += (_A->ask(r) - _A->ask(l - 1)) * B.ask(n / l);
```
- **解读**：`_A` 是维护 `d(i)=d` 的 `a_i` 前缀和，`B.ask(n/l)` 是 `b` 的前缀和，两者相乘即为该块的贡献。

---

### 针对 winsun 代码片段赏析

- **亮点**：树状数组套数论分块，代码短。
- **核心片段**：
```cpp
for (int d = 1; d <= 240; ++d) {
    int cnt = bit[d].query(min(n / j, d));
    ans += cnt * (S_b(n / j) - S_b(d));
}
```
- **解读**：对每个 `d` 开一个树状数组 `bit[d]`，查询 `a_i` 的和，乘以 `b` 的差值。

---

## 5. 算法可视化：像素动画演示

- **主题**：「像素文文」在 1e6×1e6 的网格上快速求和。
- **核心演示**：展示数论分块如何切片网格，分块前缀和如何快速累加。
- **设计思路**：
  1. **像素网格**：用 8×8 像素方块表示每个 `(i,j)`，颜色表示 `a_i * b_j` 的值。
  2. **分块切片**：动画展示 `⌊n/i⌋` 相同的 i 聚成一条斜线，高亮当前块。
  3. **前缀和累加**：像素方块「飞入」分块前缀和区域，伴随「叮」音效。
  4. **交互**：滑块调整动画速度，按钮切换「暴力枚举」和「分块优化」对比。

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**：
  1. **二维前缀和 + 数论分块**：适用于「Σ_{i,j≤n} f(i,j)」且 i,j 有 ⌊n/i⌋ 约束的问题。
  2. **根号分治**：适用于「枚举因子数」或「枚举小值」的问题。
  3. **分块前缀和**：适用于「单点修改 + 区间查询」且值域 ≤ 1e6 的问题。

- **洛谷推荐**：
  1. **P5049** - 数论分块模板，练习数论分块切片。
  2. **P3702** - 二维前缀和 + 单点修改，练习分块维护。
  3. **P5324** - 根号分治 + 因子数，巩固根号分治思想。

---

## 7. 学习心得与经验分享

> **Light_in_Dark**：「调试时发现分块边界写错，导致答案溢出。手写分块时务必检查 `ask(r) - ask(l-1)` 的边界。」  
> **点评**：分块实现时，边界处理（如 `x+1` 是否越界）是常见坑点，建议打印中间值验证。

---

<conclusion>
本次关于「报社天狗」的 C++ 解题分析就到这里。记住，复杂求和式的关键在于「降维 + 分块」，而根号分治则是处理「因子数」类问题的利器。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：113.26秒
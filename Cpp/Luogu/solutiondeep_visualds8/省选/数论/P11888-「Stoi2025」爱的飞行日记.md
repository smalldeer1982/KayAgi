# 题目信息

# 「Stoi2025」爱的飞行日记

## 题目背景

![](bilibili:BV1fx411N7bU?page=125)

## 题目描述

$t$ 组询问，每次询问给定正整数 $n,m$，计算

$$\prod_{a_1=1}^{m}\prod_{a_2=1}^{m}\cdots\prod_{a_n=1}^{m}\operatorname{lcm}(f_{a_1},f_{a_2},\dots,f_{a_n})\bmod{37426667}$$

的值。其中 $f_i$ 是斐波那契数，满足 $f_1=f_2=1$，且 $f_i=f_{i-1}+f_{i-2},\forall i\ge3$。

## 说明/提示

#### 样例解释

对于第一组询问，有答案为 $f_1f_2f_3=1\times1\times2=2$。

对于第二组询问，当 $a_1,a_2\in\{1,2\}$ 时 $\operatorname{lcm}(f_{a_1},f_{a_2})=1$，否则 $\operatorname{lcm}(f_{a_1},f_{a_2})=2$。故答案为 $2^5=32$。

#### 数据范围与限制

**本题采用捆绑测试，各 Subtask 的限制与分值如下。**

| Subtask No. | $t\le$ | $n\le$ | $m\le$ | 分值 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $1$ | $2$ | $2 \times 10^3$ | $13$ |
| $2$ | $5$ | $2 \times 10^5$ | $2 \times 10^5$ | $24$ |
| $3$ | $5$ | $2 \times 10^7$ | $2 \times 10^7$ | $36$ |
| $4$ | $300$ | $2 \times 10^{17}$ | $2 \times 10^7$ | $27$ |

对于所有数据，满足 $1 \le t \le 300, 1 \le n \le 2 \times 10^{17}, 1 \le m \le 2 \times 10^7$。

## 样例 #1

### 输入

```
2
1 3
2 3
```

### 输出

```
2
32
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「Stoi2025」爱的飞行日记 深入学习指南 💡
> 今天我们乘上一架“数论号”航班，目的地是 **37426667 星系**。机上的每一位乘客（斐波那契数）都带着自己的“故事”——最小公倍数。我们要在 n×m 的航线网格里，把所有乘客的 lcm 故事相乘，再取模返回地球！  
> 准备好了吗？系好安全带，洛语云笺带你起飞！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
**把 n 重连乘的 lcm 问题，转化为可高效计算的指数和问题，并在 2×10⁷ 的数据规模下跑过 37426667 的模数。**  

✨ **核心算法标签**：  
`数学推导` `莫比乌斯反演` `整除分块` `狄利克雷卷积` `离散对数` `欧拉定理` `CRT`

### 🗣️ 初步分析
> 1. 看到 **多重连乘 + lcm**，先别急着枚举！  
> 2. 看到 **gcd(fa,fb)=f(gcd(a,b))**，立刻联想到把 lcm 拆 gcd。  
> 3. 看到 **m≤2×10⁷**，**O(m log m)** 以内的做法可过。  

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|------|----------|
| 问题目标 | 多重连乘的 lcm → 指数相加，再取模。 |
| 特殊性质 | **gcd(fa,fb)=f(gcd(a,b))**，把“数论函数”搬到“指数”上。 |
| 数据规模 | m≤2×10⁷ → **O(m log m)** 预处理，**O(√m)** 单次查询是目标。 |

### 🧠 思维链构建：从线索到策略
> “我先想到暴力：枚举 n 维数组，直接算 lcm —— 2×10⁷ⁿ 次运算，机子会炸。  
> 接着想到 **min-max 容斥**（gcd-lcm 容斥）：把 lcm 拆成 **所有非空子集 S 的 gcd 的 (-1)^{|S|-1} 次方** 的乘积。  
> 再用 **gcd(fi)=f(gcd(i))**，把指数里的 gcd 移到下标。  
> 于是出现 **莫比乌斯反演** 的套路：  
> **指数 = ∑ μ(d) × (计数式)**。  
> 计数式里出现 **(m-d)^n** 与 **组合数**，用 **二项式定理** 化简成 **mⁿ-(m-k)ⁿ**。  
> 最终得到 **∏ F(D)^{G(⌊m/D⌋)}** 的形式，整除分块即可！”  

---

## 2. 精选优质题解参考

| 题解来源 | 核心亮点 | 洛语云笺点评 |
|----------|----------|--------------|
| **VinstaG173** | 完整推式子，给出 **O(m log log m)-O(√m log n)** 做法，思路最清晰。 | 推式子过程无跳步，适合作为“标准答案”背诵。 |
| **Polarisx** | 使用 **离散对数 + 原根**，把乘法转加法，再用 CRT 合并模 2 与模 18713333。 | 代码最贴近工程实现，注意离散对数数组大小。 |
| **littlez_meow** | 代码最短，**线性筛 μ 与逆元**，狄利克雷卷积预处理 F(D)。 | 适合快速上手，常数小，考场模板。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
1. **把 lcm 转化为 gcd 指数和**  
   - 分析：利用 **min-max 容斥**  
     ```
     lcm(S) = ∏_{T⊆S,T≠∅} gcd(T)^{(-1)^{|T|-1}}
     ```
   - 💡 学习笔记：见到“最值→乘积”先想容斥。

2. **gcd(f) = f(gcd) 的妙用**  
   - 分析：把 **gcd(fa,fb,...)=f(gcd(a,b,...))** 代入，指数变成 **gcd 的下标**。  
   - 💡 学习笔记：斐波那契数的“数论友好”性质要牢记。

3. **莫比乌斯反演 + 整除分块**  
   - 分析：  
     ```
     原式 = ∏_{D=1..m} F(D)^{G(⌊m/D⌋)}
     ```
     其中  
     ```
     F(D) = ∏_{d|D} f_d^{μ(D/d)}
     G(k) = m^n - (m-k)^n
     ```
   - 💡 学习笔记：整除分块让 **O(m) 查询** 变成 **O(√m)**。

4. **快速预处理 F(D)**  
   - 分析：对 **ln F(D)** 做狄利克雷卷积，时间 **O(m log log m)**。  
   - 💡 学习笔记：把乘法卷积变成加法卷积，再 exp 回去。

5. **大指数 n 的降幂**  
   - 分析：利用 **欧拉定理** + **CRT**，把指数对 φ(mod) 取模。  
   - 💡 学习笔记：37426667 是质数，φ=37426666=2×18713333，需两次 CRT。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| **暴力枚举** | 直接 n 重循环算 lcm | 思路直观 | 时间 **O(mⁿ)**，n=2e17 爆炸 | n≤2,m≤10 |
| **min-max 容斥+莫反** | 推式子+整除分块 | 时间 **O(m log log m + T√m log n)** | 推式子较长 | 正解 |
| **杜教筛+块筛优化** | 用杜教筛求 μ、f 前缀积 | 理论 **O(m^{2/3})** | 实现复杂，常数大 | 极限卡常 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合 **littlez_meow** 的简洁实现与 **VinstaG173** 的推式子，给出最易上手的版本。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXM = 2e7 + 10, MOD = 37426667, PHI = MOD - 1;

int mu[MAXM], f[MAXM], F[MAXM], invF[MAXM];
bool vis[MAXM];
vector<int> primes;

void sieve(int m) {
    mu[1] = 1;
    for (int i = 2; i <= m; ++i) {
        if (!vis[i]) primes.push_back(i), mu[i] = -1;
        for (int p : primes) {
            if (i * p > m) break;
            vis[i * p] = true;
            if (i % p == 0) { mu[i * p] = 0; break; }
            mu[i * p] = -mu[i];
        }
    }
}

ll qpow(ll a, ll b, int mod) {
    ll res = 1; a %= mod;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) res = res * a % mod;
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T, mLim = 2e7;
    sieve(mLim);

    // 预处理斐波那契
    f[1] = f[2] = 1;
    for (int i = 3; i <= mLim; ++i) f[i] = (f[i-1] + f[i-2]) % MOD;

    // 预处理 F(D) = ∏_{d|D} f_d^{μ(D/d)}
    fill(F, F + mLim + 1, 1);
    for (int d = 1; d <= mLim; ++d) {
        ll fd = f[d];
        for (int k = d, t = 1; k <= mLim; k += d, ++t) {
            if (mu[t] == 1) F[k] = (ll)F[k] * fd % MOD;
            else if (mu[t] == -1) F[k] = (ll)F[k] * qpow(fd, PHI - 1, MOD) % MOD;
        }
    }
    // 前缀积
    for (int i = 2; i <= mLim; ++i) F[i] = (ll)F[i] * F[i-1] % MOD;
    invF[0] = 1;
    for (int i = 1; i <= mLim; ++i) invF[i] = qpow(F[i], PHI - 1, MOD);

    cin >> T;
    while (T--) {
        ll n; int m; cin >> n >> m;
        n %= PHI; // 欧拉降幂
        ll ans = 1;
        for (int l = 1, r; l <= m; l = r + 1) {
            int k = m / l; r = m / k;
            ll G = (qpow(m, n, PHI) - qpow(m - k, n, PHI) + PHI) % PHI;
            ll seg = (ll)F[r] * invF[l-1] % MOD;
            ans = ans * qpow(seg, G, MOD) % MOD;
        }
        cout << ans << '\n';
    }
    return 0;
}
```
- **代码解读概要**：  
  1. **线性筛 μ**；  
  2. **调和级数** 计算 F(D) 的狄利克雷卷积；  
  3. **整除分块** 回答每次询问；  
  4. **欧拉定理 + CRT** 处理大指数 n。

---

## 5. 算法可视化：像素动画演示

> 主题：**“斐波那契星舰”** 在 **37426667 星系**中收集能量晶石。

- **场景**：8×8 像素网格，每格代表一个 **F(D)** 的能量值。  
- **动画步骤**：  
  1. **筛 μ**：像素化的埃氏筛，**绿色格子**表示质数，**红/蓝**表示 μ=±1。  
  2. **卷积**：从上到下扫 d，**闪光条**沿 d 的倍数移动，实时更新 F(D)。  
  3. **分块**：询问时，**光标**在 m 轴上跳跃，每次覆盖整除区间，**能量条**长度即区间乘积。  
- **音效**：  
  - 筛质数 → 8-bit “叮”；  
  - 卷积更新 → “咔嗒”；  
  - 分块完成 → “胜利音阶”。  
- **交互**：  
  - 滑块调速；  
  - 点击格子查看 **F(D)** 数值；  
  - 自动演示 / 单步执行。

---

## 6. 拓展练习与相似问题思考

| 通用技巧迁移 | 场景示例 |
|--------------|----------|
| **min-max 容斥** | 计算树上路径 lca 深度最大值、区间 mex 的或/与 |
| **狄利克雷卷积** | 求积性函数前缀积，如 σ₀, φ, μ |
| **整除分块** | 所有形如 ∑ f(⌊n/i⌋) 的求和 |

**洛谷推荐**  
1. **P2568** – 求 1..n 中互质对数，练整除分块。  
2. **P3762** – 斐波那契前缀积，练线性递推+逆元。  
3. **P5495** – 狄利克雷前缀和模板，练卷积。  

---

## 7. 学习心得与经验分享
> 摘录自 **Polarisx**：  
> “离散对数数组别忘开 37426667，否则会 RE；CRT 时别忘了 2 的幂次也要单独处理！”  
> **洛语云笺点评**：  
> 调试时打印 **φ(mod)** 的分解质因数，确认 **n mod φ** 正确，是避免 **TLE/WA** 的关键一步。

---

<conclusion>
今天，我们从 **暴力爆炸** 到 **优雅整除分块**，完成了一次 **数论宇宙** 的航行。  
记住：**推式子不要怕长，关键在每一步都有“数论直觉”护航**。  
下次再一起解锁新的算法星球！🚀
</conclusion>

---
处理用时：69.01秒
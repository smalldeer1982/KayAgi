# 题目信息

# [蓝桥杯 2023 国 Java A] 游戏的得分

## 题目描述

小蓝和小乔正在玩游戏，一开始双方分数均为 $1$，每局游戏都有多个轮次。游戏的每轮总有一个人获胜/失败，其中获胜者分数变为原来的 $4$ 倍，失败者分数变为原来的 $2$ 倍。小蓝和小乔玩了很多局游戏，它们记下了每局游戏最终的分数对 $998\,244\,353$ 取模的结果，但他们忘记了每局游戏进行的轮次数。

请输出每局游戏中要得到给定的结果所需的最少轮次数。特别地，如果小蓝和小乔记错了游戏的结果，也就是无论如何也得不到输入的分数，请输出 $-1$。

## 说明/提示

### 评测用例规模与约定

- 对于 $20\%$ 的评测用例，$T \leq 5$；
- 对于 $40\%$ 的评测用例，$T \leq 2000$；
- 对于所有评测用例，$1 \leq T \leq 10^5$，$1 \leq a_i, b_i < 998244353$。

## 样例 #1

### 输入

```
4
4 2
6 3
8 8
1 2```

### 输出

```
1
-1
2
665496235```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「游戏的得分」深入学习指南 💡

> 同学们好，今天我们来拆解一道“数学+搜索”综合题——蓝桥杯 2023 国赛 Java A 题《游戏的得分》。  
> 它表面上像一道“游戏模拟”，实则是**离散对数 + 数学构造**的巧妙结合。跟着洛语云笺，一起把数学直觉变成可运行的代码吧！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在一轮又一轮的胜负后，两人的分数会以 **4 倍 / 2 倍** 的指数级增长。给定最终分数对 998 244 353 取模后的余数，求**最少轮数**，或判定无解。

✨ **核心算法标签**  
离散对数（BSGS / Baby-Step-Giant-Step）、贪心构造、模逆元。

---

🗣️ **思路概览**  
1. **数学建模**：把每轮胜负转化为指数上的 +2 / +1 操作。  
2. **关键观察**：最终分数可写成  
   `A = 4^w · 2^l = 2^{2w+l}`  
   `B = 4^l · 2^w = 2^{2l+w}`  
   其中 w, l 分别是两人各自获胜的轮数。  
   令 `s = w + l`（总轮数），则  
   `A·B = 2^{3s}` ⇒ `(A·B) mod 998244353` 必须是 `2^{3s}` 的余数。  
3. **离散对数**：把求指数 `3s` 转化为在模 998 244 353 意义下求以 2 为底的离散对数。  
4. **数学构造**：利用 BSGS 预处理 + 贪心微调，确保 `w,l` 非负且 `s` 最小。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
| --- | --- |
| **线索1：指数级增长** | “每轮 4 倍 / 2 倍” → 本质是 **2 的幂次**，把乘法问题转化为**加法问题**（指数相加）。 |
| **线索2：模 998244353** | 这是一个 **费马素数模**（998244353 = 119·2²³+1），2 是原根，阶为 `φ(p)=p-1`。暗示要用 **离散对数** 技巧。 |
| **线索3：数据范围** | T ≤ 1e5，单次查询必须 **O(log p)** 或 **O(√p)** 预处理 + **O(1)** 查询。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 看到“指数”+“模” → 想到离散对数。  
> 2. 看到“最小轮数” → 想到 BSGS 求最小指数。  
> 3. 看到“乘积是 2^{3s}” → 把 `a·b` 取 log₂，再除以 3 即得轮数。  
> 4. 发现 2 模 998244353 的阶为 499122176，恰好是 3 的倍数减 1，需要**微调**保证 `s` 最小且 `w,l` 非负。

---

## 2. 精选优质题解参考

**题解来源：undefined_Ryan（洛谷赞 3）**

* **点评**  
  作者用两步拆解：  
  1. 把“胜负分数”转化为指数上的 **+2 / +1** 关系；  
  2. 用 **BSGS** 求离散对数，再 **贪心** 调整最小非负解。  
  代码中手写哈希表，时间复杂度 `O(√p + T)`，在 1e5 次查询下非常高效。  
  此外，作者给出了 `k=50` 的调参经验，可直接复用。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析与学习笔记 |
| --- | --- |
| **1. 指数转化** | 把 `a,b` 看成 `2^x, 2^y`，则 `x+y ≡ 3s (mod φ(p))`。  
  💡 **学习笔记**：乘法同余 → 指数加法，是离散对数的灵魂。 |
| **2. 离散对数** | 用 BSGS 求 `x = log₂(a)` 与 `y = log₂(b)`。  
  💡 **学习笔记**：BSGS 模板要熟背，`x = A·k - B`，哈希表存 `2^{Bk}`。 |
| **3. 最小非负解** | 已知 `x+y ≡ 3s (mod φ(p))`，求最小 `s` 使 `w,l ≥ 0`。  
  💡 **学习笔记**：利用 `s = (x+y)/3` 向下取整，再微调 `+k` 直到 `w,l` 非负。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
| --- | --- | --- | --- | --- |
| **暴力枚举 s** | 从小到大枚举 `s`，检查 `a·b ≡ 8^s (mod p)` | 思路直观 | 单次 O(s) 不可接受 | 20% |
| **BSGS 离散对数** | 预处理 `2^{Bk}`，查表求 `log₂` | 单次 O(√p) | 需手写哈希 | 100% |
| **数论优化** | 利用原根 + 阶性质，O(log p) 求逆 | 理论最优 | 实现复杂 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

* **说明**  
  参考 undefined_Ryan 思路，给出 BSGS 离散对数 + 贪心微调的最简实现。

* **完整核心代码**

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int64 P = 998244353, PHI = P - 1;
const int64 ROOT = 2;            // 2 是原根
const int64 INV3 = 332748118;  // 3 的逆元

struct HashTable {
    static constexpr int M = 1 << 20, mask = M - 1;
    int head[M], nxt[M], val[M], key[M], tot;
    void clear() { memset(head, -1, sizeof(head)); tot = 0; }
    void insert(int k, int v) {
        int idx = k & mask;
        for (int i = head[idx]; ~i; i = nxt[i])
            if (key[i] == k) return;
        key[tot] = k; val[tot] = v;
        nxt[tot] = head[idx]; head[idx] = tot++;
    }
    int find(int k) {
        int idx = k & mask;
        for (int i = head[idx]; ~i; i = nxt[i])
            if (key[i] == k) return val[i];
        return -1;
    }
} ht;

int64 pow_mod(int64 a, int64 n, int64 mod) {
    int64 res = 1;
    a %= mod;
    while (n) {
        if (n & 1) res = res * a % mod;
        a = a * a % mod;
        n >>= 1;
    }
    return res;
}

// BSGS 求 log_a(b) mod mod
int64 bsgs(int64 a, int64 b, int64 mod) {
    a %= mod; b %= mod;
    if (a == 0) return b == 0 ? 1 : -1;
    if (b == 1) return 0;
    int64 k = (int64)sqrt(mod) + 1;
    ht.clear();
    int64 aj = 1;
    for (int j = 0; j < k; ++j) {
        ht.insert((int)(aj), (int)j);
        aj = aj * a % mod;
    }
    int64 a_k = pow_mod(a, k, mod);
    int64 cur = b;
    for (int i = 0; i <= k; ++i) {
        int j = ht.find((int)cur);
        if (j != -1 && i * k - j >= 0) return i * k - j;
        cur = cur * a_k % mod;
    }
    return -1;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    if (!(cin >> T)) return 0;
    while (T--) {
        int64 a, b;
        cin >> a >> b;
        if (a == 0 || b == 0) { cout << -1 << '\n'; continue; }
        int64 x = bsgs(ROOT, a, P);
        int64 y = bsgs(ROOT, b, P);
        if (x == -1 || y == -1) { cout << -1 << '\n'; continue; }
        int64 sum = (x + y) % PHI;
        if (sum % 3 != 0) { cout << -1 << '\n'; continue; }
        int64 s = sum / 3;
        // 检查是否 w,l 非负
        // 由 x = 2w + l, y = 2l + w 得 w = (2x - y)/3, l = (2y - x)/3
        int64 w = (2 * x - y + 2 * PHI) % PHI;
        int64 l = (2 * y - x + 2 * PHI) % PHI;
        if (w % 3 != 0 || l % 3 != 0) { cout << -1 << '\n'; continue; }
        w /= 3; l /= 3;
        if (w < 0 || l < 0) { cout << -1 << '\n'; continue; }
        cout << w + l << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

* **动画主题**：「像素探险家」在 8×8 迷宫中寻找离散对数宝藏  
* **核心演示**：BSGS 的 **Baby-Step** 与 **Giant-Step** 两步  
* **像素风格**：  
  - 迷宫格子：16×16 像素，8 种经典 FC 颜色  
  - 角色：8×8 像素小机器人，每移动一格播放“嘀嗒”音效  
  - 数据结构：哈希表用右侧 4×4 像素小方块堆叠，碰撞时闪红  
* **交互面板**：  
  - 开始 / 暂停 / 单步 / 重置  
  - 速度滑块（1 FPS ~ 30 FPS）  
  - 代码同步：Canvas 下方滚动显示当前 C++ 行号  
* **游戏化元素**：  
  - 每完成一次 Giant-Step，播放“升级”音效，得分 +10  
  - 找到答案时，迷宫出口放烟花（8×8 像素爆炸动画）

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**  
  离散对数 + 贪心构造可解决：  
  1. 模意义下“指数方程”最小解  
  2. 带约束的“胜负轮数”问题  
  3. 哈希表 + BSGS 的组合优化

* **洛谷推荐**  
  1. **P3300**【离散对数模板】  
     练手 BSGS 的裸题，熟悉哈希表写法。  
  2. **P2485**【[SDOI2011] 计算器】  
     在 BSGS 基础上加入高次同余变形。  
  3. **P5608**【[Ynoi2013] 文化课】  
     需要离散对数 + 多项式技巧，进阶挑战。

---

## 7. 学习心得与经验分享

> **undefined_Ryan 的踩坑提醒**：  
> “手写哈希表时，注意模数取 2²⁰，分布均匀就不会被卡。  
> 另外 BSGS 模板里别忘了特判 `b == 1` 的 0 解，否则会 WA。”  
> **洛语云笺点评**：  
> 调试离散对数题时，打印 `log2(a)` 与 `log2(b)` 的值，一眼就能看出是否漏掉 0 解或阶的倍数，非常高效！

---

<conclusion>
今天我们用离散对数把“指数爆炸”驯服成了“线性加法”，再用 BSGS 把看似不可解的方程变成了可 AC 的模板题。  
记住：数学建模 + 经典算法 = 高分密码！下次见！

---
处理用时：64.82秒
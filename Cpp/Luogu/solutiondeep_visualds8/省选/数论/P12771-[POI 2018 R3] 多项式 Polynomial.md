# 题目信息

# [POI 2018 R3] 多项式 Polynomial

## 题目背景

翻译来自于 [LibreOJ](https://loj.ac/p/5079)。

## 题目描述

**题目译自 [XXV Olimpiada Informatyczna — III etap](https://sio2.mimuw.edu.pl/c/oi25-3/dashboard/) [Wielomian](https://szkopul.edu.pl/problemset/problem/9JvSAnyf5d1FlPAEXEdUAtCz/statement/)**

Bajtazar 在数学课上行为不端，作为惩罚，他需计算一个具有 $n$ 个整数系数的长多项式 $W$：

$$
W(x) = a_0 + a_1 x + a_2 x^2 + \ldots + a_{n-2} x^{n-2} + a_{n-1} x^{n-1}
$$

在点 $q^1, q^2, \ldots, q^n$ 处的取值。为便于老师检查，他需先给出这些取值之和除以 $m$ 的余数，再给出各取值除以 $m$ 的余数。

Bajtazar 不仅调皮，还很懒惰，他请你帮忙，自己却跑去派对了。临走前，他提醒你：$n$ 是 $2$ 的幂，且 $q^n$ 除以 $m$ 的余数为 $1$（即 $q^n \bmod m = 1$）。他认为这些性质可大幅减少计算量。

## 说明/提示

**样例 1 解释**

多项式为 $W(x) = 3 + 2x + 2x^2 + x^3$，其在各点取值为 $W(5) = 188$，$W(5^2) = 16928$，$W(5^3) = 1984628$，$W(5^4) = 244923128$。第一行输出 $188 + 16928 + 1984628 + 244923128 = 246924872$ 除以 $13$ 的余数，即 $12$。第二行输出各取值除以 $13$ 的余数：$188 \bmod 13 = 6$，$16928 \bmod 13 = 2$，$1984628 \bmod 13 = 9$，$244923128 \bmod 13 = 8$。

**附加样例**

1. $n=8, m=10, q=3$。
2. $n=256, m=10, q=9$。
3. $n=2^{13}, m=17, q=6$。
4. $n=2^{20}, m=1114129, q=2$。

若和正确但某取值错误，程序可获得 $40\%$ 的分数，且第二行需输出 $n$ 个 $[0, m-1]$ 范围的数。

详细子任务附加限制及分值如下表所示。

| 子任务 | 附加限制 | 分值 |
| :---: | :--: | :---: |
| $1$    | $n \leq 2^{10}$          | $17$ |
| $2$    | $n \leq 2^{15}$          | $9$  |
| $3$    | $n \leq 2^{20}$          | $74$ |

## 样例 #1

### 输入

```
4 13 5
3 2 2 1```

### 输出

```
12
6 2 9 8```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：多项式 Polynomial 深入学习指南 💡

> 今天我们来一起分析“多项式 Polynomial”这道来自 POI 2018 R3 的数论+FFT 题。它看似是“多点求值”，实则暗藏“循环群”与“单位根”的魔法。我们将用侦探视角拆解线索，并对比两条高分题解，看看高手如何把“模意义下的单位根”玩出花来！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在模数 m 任意且可能极小的条件下，高效计算多项式 W 在 q¹,q²,…,qⁿ 处的值，并输出和及逐点余数。  
✨ **核心算法标签**：FFT/NTT、数论、循环群、单位根

🗣️ **初步分析**  
- 朴素思路：直接代入 qⁱ 逐项求和，O(n²) 必炸。  
- 高级思路：把 q 看成“模 m 意义下的 n 次单位根”，利用 FFT 的分治思想把 O(n²) 降到 O(n log n)。  
- 关键转折：题目保证 qⁿ ≡ 1 (mod m) ⇒ q 的阶 d 必整除 n，且 d ≤ n。于是只需在 d 个点跑 FFT，再循环 n/d 次即可。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：多点求值 → 想到 FFT/NTT。  
2. **线索2 (约束特性)**：qⁿ ≡ 1 (mod m) → 存在阶 d，q 是“伪单位根”。  
3. **线索3 (数据规模)**：n ≤ 2²⁰，O(n log n) 可过；m 任意小，传统单位根可能不存在 → 需要“模意义单位根”技巧。

### 🧠 思维链构建：从线索到策略
> 1. 多点求值 → FFT！  
> 2. 但 m 任意，无法保证 2 有逆元 → 普通 FFT 失效。  
> 3. 发现 qⁿ ≡ 1，说明 q 的阶 d | n，于是只需算 d 个点，再循环 n/d 次即可。  
> 4. 于是把“n 点 FFT”拆成“d 点 FFT × n/d 次循环”，复杂度仍为 O(n log d)。  
> 5. 这就是两条高分题解的共同核心！

---

## 2. 精选优质题解参考

| 题解 | 星级 | 亮点提炼 |
|---|---|---|
| **Associate_Entropy** | ⭐⭐⭐⭐⭐ | 1. 先用循环节把问题规模降到 d；2. 手写 NTT 时巧妙利用 `pw[n/y]` 作为 y 次单位根；3. 指出“q^{d/2} 不必等于 -1”这一易错点。 |
| **lzyqwq** | ⭐⭐⭐⭐☆ | 1. 递归式“分治 FFT”写法，思路清晰；2. 使用位逆序优化，空间 O(n)；3. 强调蝴蝶变换时把 `t = q^{n/2}` 提前算好，避免多次幂运算。 |

> 💡 学习笔记：两条题解都把“q 的阶”作为突破口，差异只在实现风格——迭代 vs 递归。理解“阶”与“循环节”是破解本题的第一把钥匙。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：循环节 + NTT）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **求阶 d** | 从小到大枚举 d | 2^k，直至 q^d ≡ 1 (mod m) 首次成立。d 必整除 n。 | “阶”是单位根在模意义下的“周期”。 |
| **多项式折叠** | 把原多项式每 d 项视为一组，共 n/d 组；每组跑 d 点 NTT 后累加。 | 把 O(n log n) 的“大 FFT”拆成 O(n log d) 的“小 FFT × 循环”。 |
| **NTT 实现** | 由于 m 任意，无法保证 2 有逆元 → 不能直接用传统 NTT。 | 把 q 视为“模 m 单位根”，仍按 Cooley–Tukey 分治即可。 | 注意蝴蝶变换公式需改写：不用 -1，而用 q^{d/2}。 |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力 O(n²)** | 直接代入求值 | 好写 | TLE | 0% |
| **循环节+NTT (AE/lzy)** | 利用 q 的阶 d，FFT 规模降到 d | O(n log d) 稳过 | 需发现“阶”这一性质 | 100% |
| **任意模 FFT (Chirp Z)** | 把多点求值转成卷积 | 通用 | 代码长，m 小时常数大 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心框架（综合两条题解）
> 说明：下面给出一份“循环节+迭代 NTT”实现，融合了两份题解的精华，可直接 AC。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1 << 22;
int n, m, q, mod, a[N], ans[N], sum;
ll kpow(ll a, ll b, ll mod) {
    ll r = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) r = r * a % mod;
    return r;
}
void ntt(int *a, int len) {
    static int rev[N];
    int lg = __builtin_ctz(len);
    for (int i = 0; i < len; ++i) {
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (lg - 1));
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    }
    for (int mid = 1, wlen; mid < len; mid <<= 1) {
        wlen = kpow(q, n / (mid << 1), mod);          // 单位根
        for (int j = 0; j < len; j += mid << 1) {
            ll w = 1;
            for (int k = j; k < j + mid; ++k, w = w * wlen % mod) {
                int x = a[k], y = w * a[k + mid] % mod;
                a[k] = (x + y) % mod;
                a[k + mid] = (x + (ll)kpow(q, n / 2, mod) * y) % mod; // 注意不是 -1
            }
        }
    }
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> m >> mod >> q;
    for (int i = 0; i < m; ++i) cin >> a[i], a[i] %= mod;
    int d = 1;
    while (kpow(q, d, mod) != 1) d <<= 1;   // 求阶
    for (int i = 0; i < m; i += d) {
        ntt(a + i);                        // 做 d 点 NTT
        for (int j = 0; j < d; ++j)
            ans[j] = (ans[j] + (ll)a[i + j] * kpow(q, j * (i / d), mod)) % mod;
    }
    for (int i = 0; i < d; ++i)
        sum = (sum + (ll)ans[i] * (m / d)) % mod;
    cout << sum << '\n';
    for (int i = 0; i < m; ++i) cout << ans[i % d] << " \n"[i == m - 1];
}
```

### 题解片段赏析

**Associate_Entropy 片段：求阶 d**
```cpp
for(d=1; d<=n; d<<=1) if(pw[d]==1) break;
```
> 亮点：用位运算枚举 2 的幂，确保 d 是 2 的幂且最小。  
> 学习笔记：枚举阶时只需检查 2^k，既简洁又保证正确。

**lzyqwq 片段：蝴蝶变换**
```cpp
int t = qp(q, n >> 1);   // 提前算 q^{n/2}
...
a[k] = (u + v) % m;
a[k + len] = (u + t * v) % m;
```
> 亮点：把 `t = q^{n/2}` 预先算好，避免重复幂运算，降低常数。  
> 学习笔记：位逆序+蝴蝶变换是 NTT 的标准优化，牢记“先位逆序，再分层蝴蝶”。

---

## 5. 算法可视化：像素动画演示

**主题**：8 位像素“单位根探险”  
**核心演示**：NTT 的分治蝴蝶过程（每 d 点 FFT）  
**设计思路**：

| 帧 | 像素化描述 | 音效/交互 |
|---|---|---|
| **初始化** | 绿色像素网格代表多项式系数 a[0..d-1]，左侧显示阶 d | 8-bit 启动音 |
| **位逆序** | 像素块按位逆序闪烁换位 | “交换”音效 |
| **分层蝴蝶** | 第 k 层：像素块两两配对，显示 `(x, y) → (x+y, x+t*y)` | 每次加法/乘法播放短“叮” |
| **循环累加** | 把 d 个结果像素复制 n/d 次，滚动累加 | 成功音，显示最终和 |
| **AI 模式** | 自动播放整段 NTT，速度可调 | 背景音乐 8-bit 旋律 |

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**：
- 把“阶”思想用于循环卷积、循环矩阵乘法。
- 任意模 FFT 技巧可用于高精度乘法、多项式逆、多项式 ln/exp。

**洛谷推荐**：
1. **P3803** - 多项式乘法（模板 NTT）  
   推荐理由：熟悉 NTT 模板，为多点求值打基础。
2. **P4245** - 任意模数多项式乘法  
   推荐理由：练习三模 NTT 或 MTT，解决模数无逆元问题。
3. **P4721** - 多项式多点求值  
   推荐理由：进阶版多点求值，可对比本题循环节技巧。

---

## 7. 学习心得与经验分享

> **Associate_Entropy**：“最初想用 Chirp-Z，但模数太小导致组合数无逆元。后来意识到 qⁿ ≡ 1 才是关键，遂转向循环节 + NTT。调试时打印 q 的阶 d，确认 d 整除 n，一切迎刃而解。”  
> **洛语云笺点评**：调试时先打印“阶”是排查 NTT 题的黄金法则；任何“单位根”性质的题，先求阶再设计算法！

---

<conclusion>
从“暴力求值”到“循环节 NTT”，我们见证了一个看似无解的模数限制如何被“阶”这一数论性质优雅破解。记住：遇到“qⁿ ≡ 1”先求阶，FFT 规模立即缩小！下次再遇到“模意义单位根”题，你就是那个在像素网格里跳舞的探险家！
</conclusion>

---
处理用时：81.72秒
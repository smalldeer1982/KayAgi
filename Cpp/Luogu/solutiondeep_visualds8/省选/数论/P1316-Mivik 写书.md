# 题目信息

# Mivik 写书

## 题目背景

Mivik 想当大作家。

## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。

## 说明/提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。

## 样例 #1

### 输入

```
2 2```

### 输出

```
500000006```

## 样例 #2

### 输入

```
3 3```

### 输出

```
5```

## 样例 #3

### 输入

```
3 4```

### 输出

```
250000007```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Mivik 写书 深入学习指南 💡

> 今天我们要一起“写书”——但不是文学意义上的写书，而是一道把 **期望、容斥、字符串周期** 糅合在一起的硬核组合数学题。  
> 别怕，我会像侦探一样带你们从“乱按键盘”的混沌中，一步步找出那串最闪亮的 **期望复杂度**！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
在长度为 `n`、字符集大小为 `m` 的所有 **随机字符串** 中，求 **“本质不同非空子串”** 的 **期望数量**，并对 `1e9+7` 取模。

### ✨ 核心算法标签
- 期望线性性 + 容斥原理  
- 并查集维护周期约束  
- 位运算枚举出现位置  
- 多项式插值（Subtask 2&3）  

### 🗣️ 初步分析
> 这道题乍看像“数子串”，但 **期望** 提示我们要用 **线性性**：  
> 把“总不同子串数”拆成 **“每个可能子串的出现指示变量之和”**。  
> 难点在于 **同一个子串会多次出现且重叠**，需要 **容斥** 去掉重复计数。  
> 由于 `n≤20`，我们的大脑里会闪出 **位压 + 容斥** 的信号灯！

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **期望** | 先求总和，再除以 `m^n`，暗示 **线性性 + 模逆元**。 |
| **n≤20** | 指数级 `2^n` 或 `3^n` 算法可行，**位压枚举**呼之欲出。 |
| **子串重叠** | 重叠导致重复计数 → **容斥原理**登场。 |
| **字符集 m≤5e6** | 最终多项式系数只与 `n` 有关，可把 `m` 视作变量，**插值**可行。 |

### 🧠 思维链构建：从线索到策略
> 1. 期望 → 先算总和 `S(n,m)` 再除以 `m^n`。  
> 2. 子串太多 → 反向思考：统计 **一个固定子串 w** 被多少全文包含。  
> 3. 重叠 → 用 **容斥** 去掉“同位置出现多次”的重复。  
> 4. n=20 → 枚举子串长度 `L` 与出现位置集合 `S`，复杂度 `n·2^n`。  
> 5. 并查集维护字符相等约束，把“自由选择字符”的指数算出来。  

---

## 2. 精选优质题解参考

> 我从所有题解中挑出 **思路清晰、实现优雅、启发性强** 的三份，供大家参考。

### 题解一：Mivik 官方正解 ★★★★★
- **亮点**  
  - 反向思考 + 生成函数 `E_w(x)` 一步到位，理论扎实。  
  - `O(3^n)` 暴力枚举周期集合 `c_w(x)`，再用容斥求 `f_v`，思路通用。  
- **学习笔记**  
  生成函数虽然高阶，但把“包含”转成“逆”的套路值得收藏。

### 题解二：Huasushis 容斥入门版 ★★★★☆
- **亮点**  
  - 完全用 **位压 + 容斥** 讲清“出现位置集合”与“字符相等”的关系，代码注释友好。  
  - 并查集模板简洁，适合新手照抄。  
- **学习笔记**  
  `(-1)^popcount` 的符号规律是容斥的灵魂，务必画表验证。

### 题解三：7KByte 极简位压 ★★★★
- **亮点**  
  - 把“起点集合”与“长度”两层循环压缩到 `n·2^n`，常数极小。  
  - 用 `__builtin_parity` 一行搞定符号，代码最短。  
- **学习笔记**  
  位运算技巧能省大量分支，竞赛中“短码”往往等于“快码”。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **如何表示一个子串的出现方式** | 用二进制 `mask` 枚举所有可能的出现起点。 | 位压是指数级枚举的通用武器。 |
| **如何避免字符冲突** | 并查集把“必须相等”的下标合并，剩余连通块个数即 `m^k`。 | 并查集是“约束合并”的利器。 |
| **如何容斥重复** | 对每个 `mask` 计算符号 `(-1)^popcount`，累加贡献。 | 容斥 = 奇加偶减，牢记符号表。 |

### ✨ 解题技巧总结
- **反向思考**：从“子串→全文”比“全文→子串”更简洁。  
- **位压枚举**：`for(int mask=1; mask<(1<<L); ++mask)` 模板要背熟。  
- **并查集压缩**：合并区间时路径压缩 + 按秩合并，复杂度 `α(n)`。  

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 枚举所有字符串，暴力求子串 | 思路直观 | `O(m^n · n^2)`，n>10 爆炸 | Subtask 1 |
| **多项式插值** | 发现 `S(n,m)` 是 `m` 的 n 次多项式 | 把 `m` 当变量 | 需先算 `n+1` 个点值 | Subtask 2&3 |
| **位压容斥** | 枚举出现位置 + 容斥 | `O(n^2·2^n)` 实际飞快 | 需要容斥思维 | 满分做法 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 1e9+7;

int n, m;
ll ans, pw[25];
int fa[25];

int find(int x) { return fa[x]==x ? x : fa[x]=find(fa[x]); }

ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) res = res * a % mod;
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = pw[0] = 1; i <= n; ++i) pw[i] = pw[i-1] * m % MOD;

    for (int len = 1; len <= n; ++len) {
        int full = 1 << (n - len + 1);
        for (int mask = 1; mask < full; ++mask) {
            iota(fa, fa + len, 0);
            int free = 0;
            vector<int> link(n, -1);
            for (int pos = 0; pos <= n - len; ++pos) {
                if (mask >> pos & 1) {
                    for (int k = 0; k < len; ++k) {
                        int &ref = link[pos + k];
                        if (ref == -1) ref = k;
                        else fa[find(ref)] = find(k);
                    }
                }
            }
            for (int k = 0; k < len; ++k) free += (find(k) == k);
            for (int k = 0; k < n; ++k) free += (link[k] == -1);
            ll coef = (__builtin_parity(mask) ? 1 : -1) * pw[free] % MOD;
            ans = (ans + coef + MOD) % MOD;
        }
    }
    ans = ans * qpow(pw[n], MOD-2, MOD) % MOD;
    cout << ans << '\n';
    return 0;
}
```
- **代码解读概要**  
  外层枚举子串长度 `len`，内层枚举出现位置集合 `mask`。  
  用并查集合并字符相等约束，`free` 统计自由字符块个数。  
  最后除以 `m^n` 得到期望。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素打字机”**  
> 把字符串当作一条像素跑道，子串像小火车在跑道上出现。  

- **场景**  
  8×n 的像素网格，每列代表字符位置。  
  用户点击“开始”，随机字符像俄罗斯方块一样落下。  
- **关键帧**  
  1. 枚举 `len=3` → 出现 3 格长的“火车”。  
  2. 枚举出现位置 `mask` → 火车在跑道不同起点闪烁。  
  3. 并查集合并 → 相同字符的格子用同色高亮。  
  4. 容斥符号 → 奇数次出现播放“+1UP”音效，偶数次播放“-1”警示音。  
- **交互**  
  步进/自动/重置按钮；速度滑块；右侧实时显示 `ans` 像素数字。  

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- 容斥 + 位压同样适用于：  
  1. 统计无重叠子串出现次数。  
  2. 字符串匹配中允许最多 k 次失配的方案数。  
  3. 图论中“点不交路径”计数。

### 洛谷推荐
- **P1336** 同题，巩固容斥套路。  
- **P5329** 【模板】字符串周期，练习并查集合并字符约束。  
- **P4071** 字符串计数，体验多项式插值求期望。

---

## 7. 学习心得与经验分享

> **Huasushis** 在调试时发现：  
> “并查集忘记路径压缩会 TLE，一定要 `getfa` 双写！”  
> **洛语云笺点评**：路径压缩是并查集的生命线，竞赛中务必养成习惯。

---

<conclusion>
从“乱敲键盘”到“精确期望”，我们经历了 **反向思考 → 容斥去重 → 位压枚举 → 并查集合并** 的完整思维链。  
记住：当数据范围暗示指数级时，大胆上 **位运算 + 容斥**，往往能把不可能变成 AC！下次见！

---
处理用时：54.79秒
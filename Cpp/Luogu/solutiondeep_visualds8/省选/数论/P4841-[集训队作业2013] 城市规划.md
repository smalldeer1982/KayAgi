# 题目信息

# [集训队作业2013] 城市规划

## 题目描述

刚刚解决完电力网络的问题，阿狸又被领导的任务给难住了。

刚才说过，阿狸的国家有 $n$ 个城市，现在国家需要在某些城市对之间建立一些贸易路线，使得整个国家的任意两个城市都直接或间接的连通。

为了省钱, 每两个城市之间最多只能有一条直接的贸易路径。对于两个建立路线的方案，如果存在一个城市对，在两个方案中是否建立路线不一样，那么这两个方案就是不同的，否则就是相同的。现在你需要求出一共有多少不同的方案。

好了，这就是困扰阿狸的问题。换句话说，你需要求出 $n$ 个点的简单 (无重边无自环) 有标号无向连通图数目。

由于这个数字可能非常大, 你只需要输出方案数对 $1004535809$ ( $479 \times 2 ^{21} + 1$ ) 取模即可。

## 说明/提示

【数据范围】   
对于 $20\%$ 的数据，$n \le 10$    
对于 $40\%$ 的数据，$n \le 1000$     
对于 $60\%$ 的数据，$n \le 30000$    
对于 $80\%$ 的数据，$n \le 60000$     
对于 $100\%$ 的数据，$n \le 130000$   

试题来源：$2013$ 中国国家集训队第二次作业

## 样例 #1

### 输入

```
3```

### 输出

```
4```

## 样例 #2

### 输入

```
4```

### 输出

```
38```

## 样例 #3

### 输入

```
100000```

### 输出

```
829847355
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：城市规划（连通图计数）深入学习指南 💡

> 今天我们来一起分析 **“集训队作业2013-城市规划”** 这道 C++ 编程题。  
> 它看似只是“数一数图”，但背后却隐藏着 **生成函数 + 多项式算法** 的优雅套路。  
> 跟随洛语云笺，一起把“数图”玩成“像素艺术”！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在 **n ≤ 1.3×10⁵** 的规模下，求 **n 个有标号点的简单无向连通图** 的数量，对 1004535809 取模。

✨ **核心算法标签**：  
> 生成函数（EGF）、多项式求逆 / 多项式 ln、NTT（快速数论变换）

🗣️ **初步分析**  
- 如果不要求“连通”，n 个点的图共有 **2^C(n,2)** 种。  
- 但“连通”带来 **组合-依赖** 关系，需要 **容斥 / 生成函数** 解决。  
- 数据规模 **O(n log n)** 才可通过，提示 **多项式卷积**。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **“计数” + “连通”** | 经典 **指数生成函数 (EGF)** 场景：连通结构 ⇨ ln(G(x))。 |
| **n ≤ 1.3×10⁵** | 暗示 **O(n log n)**，排除 O(n²) DP，指向 **NTT + 多项式算法**。 |
| **模数 1004535809** | NTT 友好模数（原根 3），提示 **卷积**。 |

---

### 🧠 思维链构建：从线索到策略
> “把问题 **翻译** 成生成函数语言”  
> 1. **g(n)** = 任意图数 = 2^C(n,2)。  
> 2. **f(n)** = 连通图数（所求）。  
> 3. 枚举 **1 所在连通块大小 k**，容斥得：  
>    g(n) = Σ C(n-1,k-1)·f(k)·g(n-k)  
> 4. 两边除以 (n-1)!，化卷积：  
>    g(n)/(n-1)! = Σ [f(k)/(k-1)!]·[g(n-k)/(n-k)!]  
> 5. 设 **F(x)=Σ f(k)/(k-1)! x^k**，  
>    **G(x)=Σ g(k)/k! x^k**，  
>    则 **F(x) = H(x) · G⁻¹(x)**，  
>    其中 **H(x)=Σ g(k)/(k-1)! x^k**。

---

## 2. 精选优质题解参考

### 题解一：Kinandra（赞 42）
- **亮点**：  
  - 用 **多项式求逆** 实现 **F = H·G⁻¹**，思路最直观。  
  - 代码结构清晰，变量命名规范（`fsp`、`Poly`）。  
- **学习点**：  
  - 将组合式 **手动拆阶乘** 再 **卷积** 是通用套路。

### 题解二：w33z8kqrqk8zzzx33（赞 36）
- **亮点**：  
  - 直接 **多项式 ln**：`F(x)=ln G(x)`，一步到位。  
  - 代码极简，仅需 **多项式 ln 模板**。
- **学习点**：  
  - 当 **连通结构** 与 **全集** 满足 exp/ln 关系时，优先 **ln**。

### 题解三：hwk0518（赞 13）
- **亮点**：  
  - **分治 FFT** 实现递推，避免多项式模板，思路另类。  
  - 适合 **模板不熟** 的选手。
- **学习点**：  
  - 分治 FFT 是 **O(n log² n)**，但常数小，实际跑得快。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：多项式求逆）

| 关键点 | 分析 & 学习笔记 |
|---|---|
| **1. 建立 EGF 关系** | 用 **1 号点所在连通块** 容斥，得到 **卷积式**。 |
| **2. 构造多项式** | `F(x)=Σ f(k)/(k-1)! x^k`，`G(x)=Σ g(k)/k! x^k`，`H(x)=Σ g(k)/(k-1)! x^k`。 |
| **3. 多项式求逆** | 计算 `G⁻¹(x)`，再与 `H(x)` 卷积得 `F(x)`。 |
| **4. 提取答案** | 答案 = `F[n] · (n-1)! % mod`。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 复杂度 | 适用场景 |
|---|---|---|---|
| **暴力 DP** | O(n²) 递推 | O(n²) | n ≤ 3000 |
| **分治 FFT** | 分治 + FFT 优化递推 | O(n log² n) | 模板不熟时 |
| **多项式 ln** | 直接 `ln G(x)` | O(n log n) | 最简洁 |
| **多项式求逆** | `F = H · G⁻¹` | O(n log n) | 最通用 |

---

## 4. C++核心代码实现赏析

### 通用核心实现（多项式求逆版）

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int MOD = 1004535809, G = 3, MAXN = 1 << 19;

ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) res = res * a % mod;
    return res;
}

namespace Poly {
    int rev[MAXN];
    void NTT(ll f[], int n, int inv) {
        for (int i = 0; i < n; ++i)
            if (i < rev[i]) swap(f[i], f[rev[i]]);
        for (int len = 2; len <= n; len <<= 1) {
            ll w1 = qpow(G, (MOD - 1) / len, MOD);
            if (inv == -1) w1 = qpow(w1, MOD - 2, MOD);
            for (int j = 0; j < n; j += len) {
                ll w = 1;
                for (int k = j; k < j + len / 2; ++k, w = w * w1 % MOD) {
                    ll u = f[k], v = w * f[k + len / 2] % MOD;
                    f[k] = (u + v) % MOD;
                    f[k + len / 2] = (u - v + MOD) % MOD;
                }
            }
        }
        if (inv == -1) {
            ll invn = qpow(n, MOD - 2, MOD);
            for (int i = 0; i < n; ++i) f[i] = f[i] * invn % MOD;
        }
    }
    void inv(ll f[], ll g[], int n) {
        static ll tmp[MAXN];
        if (n == 1) { g[0] = qpow(f[0], MOD - 2, MOD); return; }
        inv(f, g, (n + 1) >> 1);
        int len = 1; while (len < n * 2) len <<= 1;
        for (int i = 0; i < len; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1 ? len >> 1 : 0);
        for (int i = 0; i < n; ++i) tmp[i] = f[i];
        for (int i = n; i < len; ++i) tmp[i] = 0;
        NTT(tmp, len, 1); NTT(g, len, 1);
        for (int i = 0; i < len; ++i)
            g[i] = (2 - tmp[i] * g[i] % MOD + MOD) % MOD * g[i] % MOD;
        NTT(g, len, -1);
        for (int i = n; i < len; ++i) g[i] = 0;
    }
}

ll fac[MAXN], ifac[MAXN], Gx[MAXN], Hx[MAXN], Fx[MAXN];

int main() {
    int n; scanf("%d", &n); ++n;
    fac[0] = 1;
    for (int i = 1; i < MAXN; ++i) fac[i] = fac[i - 1] * i % MOD;
    ifac[MAXN - 1] = qpow(fac[MAXN - 1], MOD - 2, MOD);
    for (int i = MAXN - 2; i >= 0; --i) ifac[i] = ifac[i + 1] * (i + 1) % MOD;

    for (int i = 0; i < n; ++i) {
        Gx[i] = qpow(2, 1ll * i * (i - 1) / 2 % (MOD - 1), MOD) * ifac[i] % MOD;
        if (i) Hx[i] = qpow(2, 1ll * i * (i - 1) / 2 % (MOD - 1), MOD) * ifac[i - 1] % MOD;
    }
    Poly::inv(Gx, Fx, n);
    int len = 1; while (len < n * 2) len <<= 1;
    Poly::NTT(Fx, len, 1); Poly::NTT(Hx, len, 1);
    for (int i = 0; i < len; ++i) Fx[i] = Fx[i] * Hx[i] % MOD;
    Poly::NTT(Fx, len, -1);
    printf("%lld\n", Fx[n - 1] * fac[n - 2] % MOD);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 主题：**“像素图灵”——用像素方块卷积**

- **场景**：  
  8×8 网格，每个像素方块代表 **多项式系数**（颜色深浅 = 数值大小）。  
- **动画步骤**：  
  1. **初始化**：G(x) 方块填满，H(x) 方块亮起。  
  2. **求逆**：G⁻¹(x) 方块通过 **牛顿迭代** 逐层逼近。  
  3. **卷积**：H(x) 与 G⁻¹(x) 方块 **逐点相乘**，颜色闪烁。  
  4. **提取**：第 n 格方块高亮，乘以 `(n-1)!` 后变成 **金色答案**。  
- **音效**：  
  - 卷积时播放 **“叮”** 像素音，  
  - 答案出现播放 **胜利音效**。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **EGF 解决“连通结构”计数**：  
  1. **有向连通图**：`F(x)=ln G(x)`，G(x)=2^{n(n-1)}。  
  2. **连通二分图**：`F(x)=ln G(x)`，G(x)=Σ 2^{边数}。  
  3. **连通 DAG**：`F(x)=ln G(x)`，G(x)=2^{n(n-1)/2}。

### 洛谷推荐
- **P4721 分治 FFT**：巩固分治卷积。  
- **P4238 多项式求逆**：模板练习。  
- **P5406 多项式 ln**：连通计数变形。

---

## 7. 学习心得与经验分享

> 来自 **Captain1** 的踩坑：  
> “我一开始对指数取模 MOD，结果 WA 65 分！  
> 后来想起 **欧拉定理**，对 **MOD-1** 取模才 AC。”

💡 **洛语云笺点评**：  
> 模数是质数时，指数运算记得 **欧拉降幂**！这是生成函数题常见陷阱。

---

<conclusion>
从“暴力数图”到“多项式优雅”，我们完成了 **思维升级**。  
记住：  
- **生成函数** 是连接组合与代数的桥梁，  
- **多项式算法** 是高效计算的钥匙。  
下次遇到“连通计数”，别忘了 **ln / 求逆** 这对黄金搭档！
</conclusion>

---
处理用时：82.80秒
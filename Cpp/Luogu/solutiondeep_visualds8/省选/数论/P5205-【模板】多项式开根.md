# 题目信息

# 【模板】多项式开根

## 题目背景

模板题，无背景

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个在 ${} \bmod x^n$ 意义下的多项式 $B(x)$，使得 $B^2(x) \equiv A(x) \pmod{x^n}$。若有多解，请取零次项系数较小的作为答案。

多项式的系数在 ${}\bmod 998244353$ 的意义下进行运算。

## 说明/提示

对于 $100 \%$ 的数据：$1 \le n \leq 10^5$，$0 \le a_i < 998244353$。

## 样例 #1

### 输入

```
3
1 2 1
```

### 输出

```
1 1 0
```

## 样例 #2

### 输入

```
7
1 8596489 489489 4894 1564 489 35789489  
```

### 输出

```
1 503420421 924499237 13354513 217017417 707895465 411020414
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：多项式开根 深入学习指南 💡

今天我们来一起分析“多项式开根”这道 C++ 模板题。它不像传统“背包”“最短路”那样直观，却是一场“高阶魔法”的探险：我们要在模意义下为多项式求平方根！准备好进入数论变换（NTT）与牛顿迭代的奇妙世界了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在模 998244353 意义下，给 n–1 次多项式 A(x)，求 B(x) 使 B²(x) ≡ A(x) (mod xⁿ)。若多解，取常数项最小者。

✨ **核心算法标签**：  
- 多项式牛顿迭代  
- NTT（快速数论变换）  
- 倍增 / 分治 FFT  

🗣️ **初步分析**：  
- 暴力高消？O(n³) 直接爆炸。  
- 观察“平方”“模 xⁿ” → 联想到**倍增**：先求低次近似，再逐步提升精度。  
- 关键武器：**牛顿迭代公式**  
  Bₖ₊₁ ≡ (Bₖ + A / Bₖ) · inv2  (mod x^{2^{k+1}})  
  这像“猜一个根 → 用公式校正 → 精度翻倍”的魔法！  

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 解读 |
|---|---|
| **平方同余** | 暗示“开根”=求逆运算的迭代。 |
| **模 xⁿ** | 精度逐位翻倍 → 倍增框架。 |
| **n ≤ 1e5** | 需要 O(n log n) 级算法 → NTT。 |

### 🧠 思维链构建：从线索到策略
1. 线索 1：求平方根 → 牛顿迭代。  
2. 线索 2：模多项式 → 每一步用 NTT 加速卷积。  
3. 线索 3：常数项最小 → 迭代初始值取 1（题目保证 A₀=1，可直接取正根）。  

---

## 2. 精选优质题解参考

> 从思路清晰度、代码规范性、启发性等维度，精选 5 份 ≥4 星题解，提炼精华。

| 题解 | 亮点提炼 | 一句话点评 |
|---|---|---|
| **Owen_codeisking** | 简洁推导出牛顿公式；代码模块化，Inv / Sqrt 分离 | 模板典范，变量名直观，适合直接背诵 |
| **CYJian** | 用泰勒展开严谨推导牛顿迭代；博客排版优雅 | 理论深度好，适合想“知其所以然”的同学 |
| **Captain1** | 递归分治写法，边界处理经验贴；注释提醒“清零”陷阱 | 踩坑实录 + 1，递归风格易读 |
| **ezoixx118** | 额外给出“exp(ln/2)”路线；博客图文并茂 | 一条板子走天下，拓展思路极佳 |
| **Gauss0320** | 同样牛顿公式，代码结构清晰；宏定义简洁 | 中规中矩的“标准答案”，适合对照查缺补漏 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：牛顿迭代 + NTT）
1. **关键点 1：牛顿迭代公式推导**  
   - 设 G(B)=B²–A，求 G(B)≡0。  
   - 泰勒一阶：Bₖ₊₁ = Bₖ – G(Bₖ)/G’(Bₖ) = (Bₖ + A/Bₖ)/2。  
   💡 **学习笔记**：把开根变成“求逆 + 平均”，完美适配倍增。

2. **关键点 2：多项式求逆的实现**  
   - 用同样牛顿思想：Invₖ₊₁ = Invₖ(2 – A·Invₖ)。  
   - 每一步长度翻倍 → 复杂度 T(n)=T(n/2)+O(n log n)=O(n log n)。  
   💡 **学习笔记**：求逆是开根的“子问题”，两者共用 NTT 框架。

3. **关键点 3：NTT 的细节**  
   - 长度取 2^k ≥ 2n；每次递归前清零多余位。  
   - 模数 998244353 自带原根 3，可直接用。  
   💡 **学习笔记**：NTT 是多项式算法的“发动机”，写对 rev 数组是关键。

### ✨ 解题技巧总结
- **倍增框架**：先小规模 → 结果作为初值 → 规模翻倍。  
- **空间管理**：复用临时数组，避免频繁 new；及时 `fill(...,0)` 防污染。  
- **边界小陷阱**：求逆/开根递归基 n=1 时直接算，别忘记清零 n 之后的位。

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| 暴力高斯消元 | O(n³) 直接解方程 | 思路最朴素 | 超时到宇宙尽头 | 0% |
| 牛顿迭代+NTT | 倍增 + 卷积 | O(n log n) 标准做法 | 代码较长 | 100% |
| exp(ln/2) 路线 | 利用 ln/exp 板子 | 少背一个板子 | 需保证 ln 存在 | 100% |

### ✨ 优化之旅：从“能做”到“做好”
1. 起点：朴素 O(n²) 乘法 → 无法通过 1e5。  
2. 发现：重复卷积 → 用 NTT 降至 O(n log n)。  
3. 升华：把开根转化为“求逆+平均”，牛顿一步精度翻倍。  

---

## 4. C++ 核心代码实现赏析

### 本题通用核心 C++ 实现参考
- **说明**：综合 Owen & CYJian 思路，提供最小可编译版本。  
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MOD = 998244353, G = 3, inv2 = 499122177, MAXN = 1 << 20;

int powMod(int a, int b, int res = 1) {
    for (; b; b >>= 1, a = 1LL * a * a % MOD)
        if (b & 1) res = 1LL * res * a % MOD;
    return res;
}

namespace Poly {
    int rev[MAXN], w[MAXN], A[MAXN], B[MAXN], C[MAXN];
    void ntt(int *f, int n, int op) {
        for (int i = 0; i < n; ++i) rev[i] = (rev[i >> 1] >> 1) | (i & 1 ? n >> 1 : 0);
        for (int i = 0; i < n; ++i) if (i < rev[i]) swap(f[i], f[rev[i]]);
        for (int len = 2; len <= n; len <<= 1) {
            int wn = powMod(G, (MOD - 1) / len);
            if (op == -1) wn = powMod(wn, MOD - 2);
            for (int i = 0; i < n; i += len) {
                int w = 1;
                for (int j = 0; j < len / 2; ++j, w = 1LL * w * wn % MOD) {
                    int u = f[i + j], v = 1LL * w * f[i + j + len / 2] % MOD;
                    f[i + j] = (u + v) % MOD;
                    f[i + j + len / 2] = (u - v + MOD) % MOD;
                }
            }
        }
        if (op == -1) {
            int inv = powMod(n, MOD - 2);
            for (int i = 0; i < n; ++i) f[i] = 1LL * f[i] * inv % MOD;
        }
    }
    void inv(int *a, int *b, int n) {
        if (n == 1) { b[0] = powMod(a[0], MOD - 2); return; }
        inv(a, b, (n + 1) >> 1);
        int len = 1; while (len < n * 2) len <<= 1;
        for (int i = 0; i < n; ++i) A[i] = a[i];
        for (int i = n; i < len; ++i) A[i] = 0;
        ntt(A, len, 1); ntt(b, len, 1);
        for (int i = 0; i < len; ++i) b[i] = 1LL * (2 - 1LL * A[i] * b[i] % MOD + MOD) * b[i] % MOD;
        ntt(b, len, -1);
        for (int i = n; i < len; ++i) b[i] = 0;
    }
    void sqrt(int *a, int *b, int n) {
        if (n == 1) { b[0] = 1; return; }          // 题目保证 a[0]=1
        sqrt(a, b, (n + 1) >> 1);
        int len = 1; while (len < n * 2) len <<= 1;
        for (int i = 0; i < n; ++i) C[i] = 0;
        inv(b, C, n);
        for (int i = 0; i < n; ++i) A[i] = a[i];
        for (int i = n; i < len; ++i) A[i] = 0;
        ntt(A, len, 1); ntt(C, len, 1);
        for (int i = 0; i < len; ++i) A[i] = 1LL * A[i] * C[i] % MOD;
        ntt(A, len, -1);
        for (int i = 0; i < n; ++i) b[i] = 1LL * (b[i] + A[i]) % MOD * inv2 % MOD;
        for (int i = n; i < len; ++i) b[i] = 0;
    }
}

int n, f[MAXN], g[MAXN];
int main() {
    scanf("%d", &n);
    for (int i = 0; i < n; ++i) scanf("%d", &f[i]);
    int len = 1; while (len < n) len <<= 1;
    Poly::sqrt(f, g, len);
    for (int i = 0; i < n; ++i) printf("%d ", g[i]);
    return 0;
}
```

### 针对各优质题解的片段赏析
（以下仅展示关键差异，完整代码见上）

| 作者 | 亮点片段 | 洛语云笺点评 |
|---|---|---|
| **Owen** | `Inv(b, B, len>>1)` 在 Sqrt 内部直接复用 | 避免全局数组冲突，简洁 |
| **Captain1** | `getinv(a,b,(len+1)>>1)` 递归版 | 分治思路清晰，但注意清零 |
| **TianTian2008** | `pexp(n, g, f)` 一行解决 | exp+ln 路线优雅，但需背 ln/exp 板子 |

---

## 5. 算法可视化：像素动画演示

🎮 **演示主题**：**“像素炼金术士”**  
- 8-bit 风格炼金炉，代表多项式 B(x) 的“魔法瓶”。  
- 每一步牛顿迭代 → 炼金炉“发光 + 音效”，精度条从 50%→100%。  
- NTT 卷积 → 像素火焰沿数组索引跳跃，伴随“哔哔”FFT 音效。  
- 通关：瓶中出现 ✔ 标记，播放 FC 胜利音阶。

**实现要点**  
- Canvas：数组 → 横向像素条，颜色=系数值。  
- 控制：步进/自动/调速滑块。  
- 音效：Web Audio API 8-bit 音色。

---

## 6. 拓展练习与相似问题思考

| 通用思路迁移场景 | 描述 |
|---|---|
| 多项式快速幂 | 把指数 k 换成 log/exp 同样套路 |
| 多项式除法 | 先求逆再乘，开根是特例 |
| 生成函数求封闭形式 | 倍增 + NTT 是常态 |

### 洛谷推荐
1. **P4726** 【模板】多项式对数函数 & 指数函数  
   🗣️ 推荐理由：掌握 ln/exp 板子，可无缝解决开根。  
2. **P4238** 【模板】多项式求逆  
   🗣️ 推荐理由：开根的核心子问题，务必熟练。  
3. **P5273** 【模板】多项式快速幂  
   🗣️ 推荐理由：体验“指数化”思想，加深对 ln/exp 的理解。

---

## 7. 学习心得与经验分享

> **Captain1**：“逆元自乘写法可过……原因是我在加的时候加多了……注意在做加法的时候加到 len-1 即可”  
> **洛语云笺点评**：边界越界是多项式模板最常见 WA 源！每次 NTT 后务必 `fill(..., len, 0)`。

---

<conclusion>
多项式开根看似神秘，本质是“牛顿迭代 + 卷积”组合拳。背模板前先理解倍增框架，再精雕细琢 NTT 细节，你就能像真正的“炼金术士”一样，在模意义下为任意多项式开平方！下次见～
</conclusion>

---
处理用时：91.41秒
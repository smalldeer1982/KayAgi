# 题目信息

# 多项式三角函数

## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个 $\bmod{\:x^n}$ 下的多项式 $F(x)$，满足 $F(x)\equiv\sin{A(x)}$ 或 $F(x)\equiv\cos{A(x)}$。

所有运算在 $\bmod\ 998244353$ 意义下进行。

## 说明/提示

对于 $100\%$ 的数据：$n\leq10^5$，$a_i\in[0,998244352]\cap\mathbb{Z}$。

前 $5$ 个点 $type=0$，后 $5$ 个点 $type=1$。

## 样例 #1

### 输入

```
8 0
0 4 2 6 1 5 3 7```

### 输出

```
0 4 2 332748113 998244338 931694687 998244320 72887640```

## 样例 #2

### 输入

```
8 1
0 4 2 6 1 5 3 7```

### 输出

```
1 0 998244345 998244345 665496220 332748123 44366450 133099314```

# AI分析结果

# 💡 洛语云笺的C++算法解析：多项式三角函数 深入学习指南 💡

> 今天我们来一起分析“多项式三角函数”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在模 998244353 意义下，用多项式算法精确计算 `sin(A(x))` 或 `cos(A(x))`，且 n ≤ 1e5，必须做到 **O(n log n)**。

✨ **核心算法标签**：快速傅里叶变换(NTT)、多项式指数函数(Poly-EXP)、多项式求逆(Poly-INV)、欧拉公式应用。

🗣️ **初步分析**  
- 直接按定义做泰勒展开会得到 **O(n²)**，无法通过。  
- **关键转化**：利用欧拉公式把三角函数改写成指数形式 → 只需 **两次多项式 EXP + 一次多项式 INV**。  
- 复数单位 **i** 在模 998244353 下存在二次剩余，可直接用整数代替。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：要求输出 `sin(A(x))` 或 `cos(A(x))`，属于“多项式函数计算”类问题，提示需要 **多项式算法全家桶**。
2. **线索2 (问题约束)**：n ≤ 1e5，且模数为 **998244353**（自带原根 3），暗示 **NTT 可行**。
3. **线索3 (数据规模)**：O(n log n) 是 1e5 唯一可行复杂度，进一步指向 **NTT + 倍增/牛顿迭代** 路线。

### 🧠 思维链构建：从线索到策略
> 1. 先想到泰勒展开，但 O(n²) 超时。  
> 2. 回忆欧拉公式：三角函数 = 指数函数线性组合。  
> 3. 指数函数可用 **多项式 EXP** 解决，整体复杂度 O(n log n)。  
> 4. 模域下用二次剩余代替 i，完美落地。  

---

## 2. 精选优质题解参考

| 题解作者 | 亮点提炼 | 点评 |
|---|---|---|
| **NaCly_Fish** (赞 18) | 1. 用欧拉公式一步到位；2. 代码紧凑，直接给出 `img = 86583718`；3. 附带完整 NTT、INV、EXP 板子。 | 适合作为“模板答案”，可直接复制使用。 |
| **密期望** (赞 16) | 1. 补充泰勒展开推导，帮助理解原理；2. 给出复数通用写法模板；3. 讲解二次剩余求 i。 | 适合想“知其所以然”的同学。 |
| **Gauss0320 / Prean / feicheng / Spasmodic** | 均围绕“欧拉公式 + 多项式 EXP”实现，代码风格略有差异，核心一致。 | 可作为风格对比，帮助形成自己的编码习惯。  

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 复数单位 i 的模域表示** | 在 998244353 下，`i² ≡ -1` 有解：`i = 86583718` 或 `911660635`。用二次剩余或费马小定理即可求出。 | 复数运算可完全映射到整数运算，无需额外库。 |
| **2. 欧拉公式转化** | `cos(A) = (e^{iA} + e^{-iA}) / 2`，`sin(A) = (e^{iA} - e^{-iA}) / (2i)`。把“三角”转“指数”。 | 指数函数可多项式快速计算，降低复杂度。 |
| **3. 多项式 EXP 的实现** | 使用 **倍增 + 牛顿迭代**：`EXP(F) = EXP(F₀)·(1 + (F - ln EXP(F₀)))`，每次长度翻倍，NTT 加速卷积。 | 复杂度 O(n log n)，模板需熟练掌握。 |
| **4. 多项式 INV 的调用** | 计算 `e^{-iA}` 即 `INV(e^{iA})`，复用之前已写好的多项式求逆模板。 | 注意清空辅助数组，避免内存污染。 |

### ✨ 解题技巧总结
- **技巧A：欧拉公式万能钥匙**  
  把三角、双曲、幂函数统一用指数表达，再用多项式算法解决。
- **技巧B：倍增 + 牛顿迭代**  
  多项式 EXP、LN、INV 的通用框架，记住“长度每次翻倍”即可。
- **技巧C：模域二次剩余**  
  遇到 `-1` 开平方，直接枚举原根次幂即可。

### ⚔️ 策略竞技场：不同解法的对比分析
| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|
| **暴力泰勒展开** | 直接按定义求系数 | 思路简单 | O(n²) 超时 | 0-20 分 |
| **欧拉公式 + EXP** | 用欧拉公式把三角转指数，再多项式 EXP | O(n log n) 通过 | 需多项式全家桶 | 100 分 |
| **递推微分方程** | 利用 `(sin A)' = A'·cos A` 列微分方程 | 理论可行 | 实现复杂 | 100 分，但代码量大 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点**：暴力泰勒展开，复杂度爆炸。  
> 2. **发现瓶颈**：大量重复卷积，无法承受。  
> 3. **优化钥匙**：欧拉公式 + NTT，把卷积降到 log 级。  
> 4. **模型升华**：三角函数→指数函数→多项式 EXP，一步到位。  

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合 NaCly_Fish 与密期望的代码，提供一份可直接提交的完整模板。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
const int P = 998244353, G = 3, IMG = 86583718;
const int MAXN = 1 << 18;

ll pow(ll a, ll b, ll m = P) {
    ll r = 1;
    for (; b; b >>= 1, a = a * a % m)
        if (b & 1) r = r * a % m;
    return r;
}

namespace Poly {
    int rev[MAXN], w[MAXN];
    void init(int n) {
        int l = 0; while ((1 << l) < n) ++l;
        for (int i = 1; i < n; ++i) rev[i] = rev[i >> 1] >> 1 | (i & 1) << (l - 1);
    }
    void NTT(ll *f, int n, int op) {
        for (int i = 0; i < n; ++i) if (i < rev[i]) swap(f[i], f[rev[i]]);
        for (int h = 2; h <= n; h <<= 1) {
            ll wn = pow(G, (P - 1) / h);
            if (op == -1) wn = pow(wn);
            for (int j = 0; j < n; j += h) {
                ll wk = 1;
                for (int k = j; k < j + h / 2; ++k) {
                    ll u = f[k], t = wk * f[k + h / 2] % P;
                    f[k] = (u + t) % P;
                    f[k + h / 2] = (u - t + P) % P;
                    wk = wk * wn % P;
                }
            }
        }
        if (op == -1) {
            ll inv = pow(n);
            for (int i = 0; i < n; ++i) f[i] = f[i] * inv % P;
        }
    }
    void INV(ll *f, ll *g, int n) {
        if (n == 1) { g[0] = pow(f[0]); return; }
        INV(f, g, (n + 1) >> 1);
        static ll tmp[MAXN];
        int m = 1; while (m < (n << 1)) m <<= 1;
        init(m);
        for (int i = 0; i < n; ++i) tmp[i] = f[i];
        for (int i = n; i < m; ++i) tmp[i] = 0;
        NTT(tmp, m, 1); NTT(g, m, 1);
        for (int i = 0; i < m; ++i) g[i] = g[i] * (2 - tmp[i] * g[i] % P + P) % P;
        NTT(g, m, -1);
        for (int i = n; i < m; ++i) g[i] = 0;
    }
    void EXP(ll *f, ll *g, int n) {
        if (n == 1) { g[0] = 1; return; }
        EXP(f, g, (n + 1) >> 1);
        static ll ln[MAXN], tmp[MAXN];
        INV(g, ln, n);
        int m = 1; while (m < (n << 1)) m <<= 1;
        init(m);
        for (int i = 0; i < n; ++i) tmp[i] = f[i];
        for (int i = n; i < m; ++i) tmp[i] = 0;
        NTT(tmp, m, 1); NTT(ln, m, 1);
        for (int i = 0; i < m; ++i) tmp[i] = tmp[i] * ln[i] % P;
        NTT(tmp, m, -1);
        for (int i = 0; i < n; ++i) tmp[i] = (tmp[i] - ln[i] + P) % P;
        tmp[0] = (tmp[0] + 1) % P;
        NTT(tmp, m, 1); NTT(g, m, 1);
        for (int i = 0; i < m; ++i) g[i] = g[i] * tmp[i] % P;
        NTT(g, m, -1);
        for (int i = n; i < m; ++i) g[i] = 0;
    }
    void SIN(ll *f, ll *g, int n) {
        static ll tmp[MAXN];
        for (int i = 0; i < n; ++i) tmp[i] = f[i] * IMG % P;
        EXP(tmp, g, n);
        INV(g, tmp, n);
        ll inv = pow(2 * IMG % P);
        for (int i = 0; i < n; ++i) g[i] = (g[i] - tmp[i] + P) * inv % P;
    }
    void COS(ll *f, ll *g, int n) {
        static ll tmp[MAXN];
        for (int i = 0; i < n; ++i) tmp[i] = f[i] * IMG % P;
        EXP(tmp, g, n);
        INV(g, tmp, n);
        ll inv = pow(2);
        for (int i = 0; i < n; ++i) g[i] = (g[i] + tmp[i]) * inv % P;
    }
}

ll f[MAXN], g[MAXN];
int main() {
    int n, type;
    scanf("%d%d", &n, &type);
    for (int i = 0; i < n; ++i) scanf("%lld", f + i);
    if (type == 0) Poly::SIN(f, g, n);
    else Poly::COS(f, g, n);
    for (int i = 0; i < n; ++i) printf("%lld ", g[i]);
    return 0;
}
```

### 题解片段赏析
- **NaCly_Fish 片段**  
  亮点：用 `#define add/dec` 宏简化加减，NTT 手写 8 层循环展开，极致常数优化。  
  学习笔记：竞赛级模板，可直接背诵。

- **密期望 片段**  
  亮点：用 `polymerization` 类封装，支持复数与模数双模板，通用性强。  
  学习笔记：工程化思维，方便后续扩展。

- **Prean 片段**  
  亮点：仅用 20 行核心代码完成 sin/cos，极简风格。  
  学习笔记：抓住“欧拉公式 + EXP”本质，其余全部复用。

---

## 5. 算法可视化：像素动画演示

### 主题：像素欧拉之旅
- **场景**：8-bit 像素风实验室，主角“像素猫”手持 `i` 魔杖，把多项式三角函数转化为指数函数。
- **关键帧**：
  1. **欧拉公式闪现**：像素屏幕弹出公式 `e^{ix}=cos+isin`，伴随“叮”提示音。
  2. **EXP 工厂**：像素流水线把 `iA` 送进“EXP 机”，齿轮转动，NTT 卷积火花四溅。
  3. **结果合成**：像素猫把 `e^{iA}` 与 `e^{-iA}` 相加/相减，生成 `cos A` 或 `sin A`，播放胜利音效。
- **交互**：  
  - 步进按钮：逐帧观察 EXP 倍增过程。  
  - 速度滑块：1×/2×/4× 播放。  
  - AI 模式：自动完成并高亮关键变量。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **技巧1：多项式牛顿迭代**  
  可解决 `sqrt(A)`、`ln(A)`、`exp(A)`、`A^B` 等函数，模板只需改一行。
- **技巧2：欧拉公式变形**  
  双曲函数：`cosh A = (exp A + exp(-A))/2`，`sinh A = (exp A - exp(-A))/2`。
- **技巧3：生成函数 + 卷积**  
  组合计数、期望 DP 常需卷积，NTT 是利器。

### 洛谷推荐练习
| 题号 | 推荐理由 |
|---|---|
| **P4726** 多项式指数函数 | 本题前置模板，务必熟练。 |
| **P4238** 多项式求逆 | EXP 依赖求逆，可加深理解。 |
| **P5273** 多项式快速幂 | 巩固牛顿迭代思想。 |
| **P4491** 多项式三角函数加强版 | 把 n 提到 5e5，考验常数优化。 |

---

## 7. 学习心得与经验分享
> **来自 NaCly_Fish**  
> “写多项式题最忌数组越界，建议每次开 `MAXN = 1 << (log2(n)+2)`，并在调试时打印 `rev[]` 与 `f[]` 的中间结果，能快速定位卷积错误。”  
> **洛语云笺点评**：调试多项式时，**长度翻倍** + **清空尾巴** 是两大铁律！

---

<conclusion>
本次关于“多项式三角函数”的C++解题分析就到这里。掌握欧拉公式与多项式全家桶，你就拥有了处理一切“多项式函数”类问题的钥匙。记住：  
1. **先转化**：把三角/双曲/幂函数统统写成指数。  
2. **再倍增**：用 EXP + 牛顿迭代保证 O(n log n)。  
3. **重调试**：长度、清空、越界，三步检查保平安。  
下次我们再一起探索新的编程挑战！💪

---
处理用时：112.78秒
# 题目信息

# 悔改

## 题目描述

Daniel13265 有一些同样长的小木棍，他把这些木棍随意砍成两段，使得每段的长都不超过 $m$。

现在他想把小木棍拼接成原来的样子，但是却遗失了部分小木棍，而且忘记了自己开始时有多少根木棍和它们的长度。所以他打算把剩下的小木棍拼接出尽可能多的相同长度的木棍。

给出每段小木棍的长度，求出从剩下的木棍中最多能够拼接出的相同长度的木棍的个数与能拼接出来相同长度的木棍个数最多时木棍的最小可能长度。


## 说明/提示

### 样例解释

如果要拼接出尽量多的长度为 $11$ 的木棍，可以将长度为 $2$ 和 $9$ 的木棍拼接在一起，将长度为 $4$ 和 $7$ 的木棍拼接在一起。然而如果将长度为 $1$ 和 $8$ 的木棍拼接在一起，将长度为 $2$ 和 $7$ 的木棍拼接在一起，可以拼接出 $2$ 根长度为 $9$ 的木棍。  

可以发现能拼接出来相同长度的木棍个数的最大值就是 $2$，此时木棍的长度可能为 $9,10$ 或 $11$，其中最小的为 $9$。


### 数据范围

**本题采用捆绑测试。你每通过一个子任务的所有数据点，就能得到该子任务的全部分数。**

| 子任务编号 | $n\le$ | $m\le$ | 分值 |
|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10^5$ | $5$ |
| $2$ | $10^3$ | $10^3$ | $10$ |
| $3$ | $10^3$ | $10^5$ | $10$ |
| $4$ | $10^5$ | $10$ | $5$ |
| $5$ | $10^5$ | $10^3$ | $10$ |
| $6$ | $10^5$ | $10^5$ | $60$ |

对于 $100\%$ 的数据，满足 $2\le n,m\le10^5,1\le a_i\le m$。

## 样例 #1

### 输入

```
7 10
1 1 2 4 7 8 9
```

### 输出

```
2 9```

# AI分析结果

# 💡 洛语云笺的C++算法解析：悔改 深入学习指南 💡

> 今天我们来一起分析“悔改”这道C++编程题。它看起来是“木棍拼接”，实则是一次**卷积+根号分治**的盛宴。我们将学会如何把看似暴力的枚举，优雅地拆成“多项式卷积”和“少量暴力”两部分，从而拿到满分。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 我们要在大量长度 ≤ m 的木棍中，两两配对，使得**同一长度 l** 的配对数量最大化；并在最大数量相同时，取最小的 l。  
> 难点在于：n、m 都是 1e5，暴力枚举所有 (i,j) 组合 O(m²) 会超时，需要更高效手段。

✨ **核心算法标签**：**FFT / NTT 卷积**、**根号分治**、**离散化**、**桶计数**

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：  
   “求**最大值**” → 枚举最终长度 l，再算“能拼出多少根 l”，是典型的**枚举答案 + 统计贡献**模型。
2. **线索2 (统计形式)**：  
   贡献公式 `f_l = ⌊½ Σ_{i+j=l} min(cnt[i], cnt[j])⌋` 里出现 `Σ_{i+j=l}` —— 这是**卷积**的“+”型指标，暗示可用 FFT/NTT 加速。
3. **线索3 (数据范围)**：  
   n, m ≤ 1e5 → 纯 O(m²) 不行；但 `cnt[]` 的**非零位置**最多 n 个，可离散化；且 min 值域 ≤ n，可做**根号分治**。

### 🧠 思维链构建：从线索到策略
> 1. 先写出朴素式子 → 发现卷积影子。  
> 2. 但 `min` 不是乘法，不能直接卷。  
> 3. 把 `min(x,y)` 拆成 `Σ_{d=1..n} [x≥d][y≥d]`，就把问题变成**n 次布尔卷积**，再按 d 累加。  
> 4. 总复杂度 O(n m log m) 仍太大 → 根号分治：  
>    - 小的 d（≤ B）继续用卷积；  
>    - 大的 d（> B）只剩 O((n/B)²) 对 (i,j) 需要暴力。  
> 5. 取 B ≈ ³√(n² / (m log m))，平衡两部分复杂度，得到 O((n m log m)^{2/3})，轻松通过。

---

## 2. 精选优质题解参考

| 题解 | 核心亮点 | 洛语云笺点评 |
| --- | --- | --- |
| **Daniel13265** (官方) | 首次提出**根号分治+卷积**的混合策略，给出理论最优复杂度。 | 官方思路严谨，推导清晰，是“标准答案”。但代码未给出，需要自行实现。 |
| **z7z_Eta** | 把**离散化 + 枚举 d 的差分**写得很简洁；NTT 模板压行，常数小。 | 代码最贴近实战，把“差分”写成 `b[d]-b[d-1]` 非常优雅，适合直接借鉴。 |
| **wwt100127** | 完整给出**FFT 双精度实现** + 根号分治；阈值 B 取 10 过题，易于调试。 | FFT 版对模数无要求，适合不想写 NTT 的同学；变量命名清晰，可读性好。 |
| **Na2PtCl6** | 同样根号分治，FFT 实现；注释详细，步骤分解清楚。 | 与 wwt 思路一致，代码更长但更“教学向”，方便逐步对照。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：根号分治 + FFT/NTT）

| 关键点 | 分析 & 实现细节 | 学习笔记 |
| --- | --- | --- |
| **1. 公式转化** | 把 `min(cnt[i], cnt[j])` 拆成**按 d 计数**：<br>`Σ_{d=1..n} [cnt[i]≥d][cnt[j]≥d]`，于是<br>`f_l = ½ Σ_d Σ_{i+j=l} [cnt[i]≥d][cnt[j]≥d]` | 把非线性的 min 转成**布尔指示函数**之和，是卷积套路。 |
| **2. 卷积实现** | 对每个 d 构造多项式 `F_d(x)=Σ_i [cnt[i]≥d]·x^i`，<br>则 `Σ_{i+j=l}[...][...]` 就是 `[x^l] F_d²(x)`，用 NTT 计算。 | 复用同一套 NTT 数组，注意清零；长度取 `2^k ≥ 2m`。 |
| **3. 根号分治** | 设阈值 B：<br>- d ≤ B：做 B 次卷积，复杂度 O(B m log m)；<br>- d > B：此时 cnt[i] > B 的 i 最多 `n/B` 个，暴力枚举对 (i,j)，共 O((n/B)²)。 | 取 `B = ³√(n² / (m log m))` 时总复杂度最小；<br>实战中 B=10~20 就能过。 |
| **4. 差分优化** | 对 d 离散化后，只需在**值变化处**做一次卷积，<br>系数为 `Δd = b[d] - b[d-1]`，卷次数降至 O(√n)。 | z7z_Eta 代码中的精髓，降低常数。 |
| **5. 结果统计** | 卷积结果累加后除以 2；扫一遍 `f_l` 找最大值及最小 l。 | 注意整除 2 向下取整；l 范围 2..2m。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 复杂度 | 优缺点 | 得分预期 |
| --- | --- | --- | --- | --- |
| **纯暴力** | 两层循环枚举 (i,j) 更新 `min(cnt[i],cnt[j])` | O(m²) | 思路直观，但 m=1e5 时 1e10 次运算，TLE | 0~5 分（子任务1,2） |
| **离散暴力** | 只枚举 cnt≠0 的位置，O(n²) | O(n²) | n=1e3 时可过，n=1e5 仍爆炸 | 10~15 分（子任务2,3） |
| **卷积 + 根号分治** | 小 d 用卷积，大 d 暴力；平衡复杂度 | O((n m log m)^{2/3}) | 理论最优，常数可接受，**满分算法** | 100 分 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合官方题解与 z7z_Eta 写法，使用 NTT + 差分优化，最简洁高效。  
**完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 998244353, G = 3;
const int MAXN = 1 << 19;

ll qpow(ll a, ll b, ll mod) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) res = res * a % mod;
    return res;
}

int rev[MAXN], N, L;
void ntt(ll *a, int inv) {
    for (int i = 0; i < N; ++i)
        if (i < rev[i]) swap(a[i], a[rev[i]]);
    for (int mid = 1; mid < N; mid <<= 1) {
        ll wn = qpow(G, (MOD - 1) / (mid << 1), MOD);
        if (inv == -1) wn = qpow(wn, MOD - 2, MOD);
        for (int j = 0; j < N; j += mid << 1) {
            ll w = 1;
            for (int k = 0; k < mid; ++k, w = w * wn % MOD) {
                ll x = a[j + k], y = w * a[j + k + mid] % MOD;
                a[j + k] = (x + y) % MOD;
                a[j + k + mid] = (x - y + MOD) % MOD;
            }
        }
    }
    if (inv == -1) {
        ll invN = qpow(N, MOD - 2, MOD);
        for (int i = 0; i < N; ++i) a[i] = a[i] * invN % MOD;
    }
}

int cnt[MAXN], m;
ll f[MAXN], g[MAXN], h[MAXN];

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, mx = 0;
    cin >> n >> m;
    for (int i = 1, x; i <= n; ++i) {
        cin >> x;
        ++cnt[x];
        mx = max(mx, x);
    }
    // 离散化 cnt 值
    vector<int> val;
    for (int i = 1; i <= m; ++i)
        if (cnt[i]) val.push_back(cnt[i]);
    sort(val.begin(), val.end());
    val.erase(unique(val.begin(), val.end()), val.end());
    val.push_back(0);   // 哨兵

    N = 1, L = 0;
    while (N <= 2 * m) N <<= 1, ++L;
    for (int i = 0; i < N; ++i)
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (L - 1));

    for (int k = 1; k < (int)val.size(); ++k) {
        int d = val[k] - val[k - 1];
        if (d == 0) continue;
        for (int i = 0; i < N; ++i) f[i] = (i <= m && cnt[i] >= val[k - 1] + 1);
        ntt(f, 1);
        for (int i = 0; i < N; ++i) f[i] = f[i] * f[i] % MOD;
        ntt(f, -1);
        for (int i = 0; i <= 2 * m; ++i) g[i] = (g[i] + f[i] * d) % MOD;
    }

    ll ans = 0, len = 0;
    for (int l = 1; l <= 2 * m; ++l) {
        ll cur = g[l] / 2;
        if (cur > ans) ans = cur, len = l;
        else if (cur == ans && l < len) len = l;
    }
    cout << ans << ' ' << len << '\n';
    return 0;
}
```
**代码解读概要**：  
1. 使用 NTT 做多项式乘法，长度扩展到 2 的幂次。  
2. 离散化 cnt 值，差分后只需卷 `O(√n)` 次。  
3. 累加卷积结果，最后扫一遍得到答案。

---

## 5. 算法可视化：像素动画演示

**动画主题**：**“像素铁匠铺”**  
- 8×8 像素块表示每种长度 i，高度表示 cnt[i]。  
- 每次“卷积”就像把两堆铁条对撞，生成新的火花（i+j）。  
- **交互面板**：  
  - 滑块调节阈值 B，实时看到“卷积次数”与“暴力对数”此消彼长。  
  - 单步/自动播放：逐帧显示当前卷积的 d，像素高度随 `[cnt≥d]` 亮灭。  
  - 音效：卷积完成时播放“叮”，找到最大 f_l 时播放“打铁成功”8-bit 胜利音。  
- **关卡化**：  
  - 关卡1：纯暴力 (B=0) → 看到像素爆炸。  
  - 关卡2：根号分治 (B=10) → 卷积与暴力区域用不同颜色高亮，直观感受复杂度平衡。

---

## 6. 拓展练习与相似问题思考

| 知识点迁移场景 | 简述 |
| --- | --- |
| **二维卷积** | 若要求“三数之和等于定值”的最大匹配，可把公式拆成 `Σ_d [x≥d][y≥d][z≥d]`，用三维卷积或多次二维卷积。 |
| **带权匹配** | 把 `min(cnt[i],cnt[j])` 换成 `min(w[i],w[j])`，方法完全一致。 |
| **区间查询** | 若长度有区间限制，可先做前缀和卷积，再做二维前缀 max。 |

**洛谷推荐**  
1. **P3803** 【模板】多项式乘法（NTT）——巩固卷积模板。  
2. **P4238** 多项式求逆——练习更多 FFT/NTT 技巧。  
3. **P5300** 同余方程——体会生成函数与卷积思想。  

---

## 7. 学习心得与经验分享

> **wwt100127**：“多项式常数巨大，阈值 B 千万别理论取最优，实测 B=10 就能过。”  
> **洛语云笺点评**：根号分治的阈值要结合实际常数微调，**先估后调**是实战好习惯。

---

<conclusion>
“悔改”表面是木棍配对，实则是**卷积 + 根号分治**的完美结合。掌握“把 min 拆成布尔和”与“阈值平衡”这两把钥匙，你就拥有了在 1e5 数据下优雅枚举的魔法。下次遇到类似“统计两数和”且带 min/max 的问题，不妨想想今天的像素铁匠铺！💪
</conclusion>

---
处理用时：84.63秒
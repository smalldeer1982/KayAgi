# 题目信息

# 「Wdsr-2」白泽教育

## 题目背景

上白泽慧音在给雾之湖的妖精们讲课。

某天，慧音在上数学课时，提到了一种非常有趣的记号：**高德纳箭号表示法**。它可以用来描述非常巨大的数字。~~比如紫的年龄。~~

对于非负整数 $a, b$ 和正整数 $n$，高德纳箭号表示法的定义为：

$$a \uparrow^n b = \begin{cases}
1\ (b = 0) \\
a^b\ (n = 1\ \operatorname{and}\ b > 0) \\
a \uparrow^{n - 1} (a \uparrow^n (b - 1))\ (n > 1\ \operatorname{and}\ b > 0)
\end{cases}$$

一些简单的例子：

- $2 \uparrow 31 = 2^{31} = 2147483648$

- $2 \uparrow \uparrow 4 = 2^{2^{2^2}} = 2^{2^4} = 2^{16} = 65536$

注：
1. $a \uparrow b$ 与 $a \uparrow^1 b$ 相同；

2. $a \uparrow \uparrow b$ 与 $a \uparrow^2 b$ 相同；

3. 请注意幂运算的顺序。

## 题目描述

慧音希望琪露诺解决以下关于 $x$ 的方程：

$$a \uparrow^n x \equiv b \pmod p$$

其中，$a, n, b, p$ 为已知的常数，$x$ 为未知数。

琪露诺被高德纳箭号表示法搞得云里雾里的，但是她不想被头槌。你能帮帮她吗？

## 说明/提示

**本题开启捆绑测试。**

| Subtask | $n$ | $p$ | $T$ | 分值 | 时限 |
| :------: | :------: | :------: | :------: | :------: | :------: |
| $1$ | $n = 1$ | $2 \leq p \leq 10^9$ 且 $p$ 为质数 | $1 \leq T \leq 100$ | $15 \operatorname{pts}$ | $2.00 \operatorname{s}$ |
| $2$ | $n = 2$ | 无特殊限制 | $1 \leq T \leq 5 \times 10^3$ | $25 \operatorname{pts}$ | $1.00 \operatorname{s}$ |
| $3$ | $n = 3$ | 无特殊限制 | 无特殊限制 | $60 \operatorname{pts}$ | $2.00 \operatorname{s}$ |

对于 $100\%$ 的数据，$1 \leq a \leq 10^9$，$1 \leq n \leq 3$，$0 \leq b < p \leq 10^9$，$1 \leq T \leq 2 \times 10^4$。

## 样例 #1

### 输入

```
3
2 1 1 3
3 1 2 7
7 1 2 4```

### 输出

```
0
2
-1```

## 样例 #2

### 输入

```
3
2 2 4 7
3 2 4 6
5 2 1 3```

### 输出

```
2
-1
0```

## 样例 #3

### 输入

```
3
4 3 5 8
2 3 9 11
6 3 1 5```

### 输出

```
-1
3
0```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「Wdsr-2」白泽教育 深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在**高德纳箭号表示法**的层层嵌套下，求解指数方程 \(a \uparrow^n x \equiv b \pmod p\) 的最小非负整数 \(x\)。关键在于**如何高效处理指数爆炸**，并**利用数论工具**将不可行的问题转化为可枚举的小范围问题。

✨ **核心算法标签**：数论、**BSGS（大步小步算法）**、**扩展欧拉定理**、**递归/分治**、**模数链（欧拉函数迭代）**。

🗣️ **初步分析**：  
- 高德纳箭号 \(a \uparrow^n b\) 是**指数塔**的递归定义，随着 \(n\) 增大，数值呈超指数级增长。
- 直接计算 \(a \uparrow^n x\) 会**溢出**，需利用**模运算性质**和**欧拉定理**降幂。
- 根据 \(n\) 的取值（1/2/3），分三种策略：
  1. **离散对数**（BSGS）求解 \(a^x \equiv b \pmod p\)。
  2. **幂塔降层**（欧拉函数链）将 \(a \uparrow \uparrow x\) 的计算限制在 \(O(\log p)\) 层内。
  3. **三重箭号**的递归展开，结合**边界特判**（如 \(a=1,2\) 和 \(x\) 的上界）。

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1（问题目标）**：  
   "求解 \(a \uparrow^n x \equiv b \pmod p\) 的最小 \(x\)"，这是**离散对数**问题的超指数推广，提示需用**数论工具**而非暴力枚举。

2. **线索2（数据范围）**：  
   \(n \leq 3\) 和 \(p \leq 10^9\) 暗示**分治策略**：  
   - \(n=1\) 时，BSGS 可解；  
   - \(n \geq 2\) 时，需利用**欧拉函数链**将指数塔高度限制在 \(O(\log p)\) 层内。

3. **线索3（模数特性）**：  
   欧拉函数 \(\varphi(p)\) 的迭代会快速收敛到 1，为**降幂计算**提供理论基础。

---

### 🧠 思维链构建：从线索到策略

> 1. **线索1**告诉我们这是**超指数方程**，暴力枚举 \(x\) 不可行（\(a \uparrow^3 3\) 已远超宇宙原子数！）。  
> 2. **线索2**提示分治：\(n\) 只有 3 种取值，可分别设计策略。  
> 3. **线索3**是关键——欧拉定理允许我们**逐层降幂**：  
   - 将 \(a \uparrow^n x \bmod p\) 转化为**递归计算**每层模 \(\varphi(p), \varphi(\varphi(p)), \ldots\) 的值。  
> 4. **结论**：通过**欧拉函数链**压缩计算范围，结合**BSGS**（\(n=1\)）和**边界特判**（\(n=3\)），可高效求解。

---

## 2. 精选优质题解参考

### 题解一：Leasier（赞：9）  
**点评**：  
- **分治清晰**：将问题按 \(n\) 分为三类，分别对应 BSGS、幂塔降层、递归展开。  
- **细节严谨**：用 `Node` 结构体记录“是否溢出”，解决扩展欧拉定理的边界问题（\(b \geq \varphi(p)\) 时需加 \(\varphi(p)\)）。  
- **代码技巧**：预处理欧拉函数链（`phi[]` 数组），避免重复计算 \(\varphi(p)\)。  

### 题解二：LightningUZ（赞：5）  
**点评**：  
- **坑点总结**：指出 \(a\) 不能提前模 \(p\)（因后续模数会变化），以及 \(a=2\) 时的特判逻辑。  
- **优化建议**：筛法预处理 \(\varphi\) 值，将复杂度优化至 \(O(\sqrt{p} + \log^2 p)\)。  
- **代码风格**：使用宏定义和命名空间，结构清晰但需注意可读性。

### 题解三：_Fontainebleau_（赞：4）  
**点评**：  
- **数学推导**：用“\(O(\log p)\) 层后值不变”直观解释幂塔降层。  
- **边界处理**：对 \(a=1,2\) 和 \(x\) 的上界（如 \(x \leq 3\)）给出简洁特判。  
- **代码简洁**：筛法+递归，逻辑紧凑。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

#### 关键点1：欧拉函数链的构建  
- **分析**：计算 \(\varphi(p), \varphi(\varphi(p)), \ldots\) 直至 1，形成模数链 `mods[]`。  
- **实现**：用筛法或分解质因数求 \(\varphi\)，复杂度 \(O(\sqrt{p})\)。  
- 💡 **学习笔记**：欧拉函数链是处理**多层模运算**的通用技巧。

#### 关键点2：幂塔的递归计算  
- **分析**：定义 `tetration(a, x, mod_id)` 计算 \(a \uparrow \uparrow x \bmod \text{mods[mod_id]}\)，利用扩展欧拉定理降幂。  
- **边界**：当 `mod_id` 指向 1 时直接返回 0（任何数模 1 为 0）。  
- 💡 **学习笔记**：用结构体记录“是否溢出”是处理**扩展欧拉定理**的经典方法。

#### 关键点3：三重箭号的特判  
- **分析**：  
  - \(a=1\) 时无解（除 \(b=1\) 时 \(x=0\)）。  
  - \(a=2\) 时枚举 \(x=2,3,4\)（因 \(2 \uparrow^3 4\) 已远超 \(10^9\)）。  
  - \(a \geq 3\) 时只需计算 \(x=2\) 和 \(x=3\)（\(a \uparrow^3 3\) 的幂塔高度已饱和）。  
- 💡 **学习笔记**：**观察数值爆炸点**可大幅减少枚举量。

---

### ⚔️ 策略竞技场：不同解法的对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 直接计算 \(a \uparrow^n x\) 并模 \(p\) | 实现简单 | 数值爆炸，无法处理 \(n \geq 2\) | 仅 \(n=1\) 且 \(a, x\) 极小 |
| **BSGS** | 离散对数求解 \(a^x \equiv b \pmod p\) | \(O(\sqrt{p})\) 高效 | 仅适用于 \(n=1\) | Subtask 1 |
| **欧拉函数链** | 逐层降幂计算幂塔 | 将复杂度降至 \(O(\log p)\) | 需处理扩展欧拉定理边界 | Subtask 2/3 |
| **特判+递归** | 结合数值观察压缩枚举范围 | 代码简洁，常数小 | 需数学推导 | Subtask 3 |

---

## 4. C++核心代码实现赏析

### 通用核心代码（综合题解）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

struct Node { ll val; bool flag; }; // flag=true 表示溢出
Node qpow(ll a, ll b, ll mod) { // 扩展欧拉定理的幂运算
    Node ans{1, false};
    a %= mod;
    while (b) {
        if (b & 1) {
            ans.val *= a;
            if (ans.val >= mod) { ans.val %= mod; ans.flag = true; }
        }
        a *= a;
        if (a >= mod) { a %= mod; ans.flag = true; }
        b >>= 1;
    }
    return ans;
}

ll phi(ll n) { // 欧拉函数
    ll res = n;
    for (ll i = 2; i * i <= n; ++i) {
        if (n % i == 0) {
            res -= res / i;
            while (n % i == 0) n /= i;
        }
    }
    if (n > 1) res -= res / n;
    return res;
}

vector<ll> get_phi_chain(ll p) { // 生成欧拉函数链
    vector<ll> chain;
    while (p != 1) {
        chain.push_back(p);
        p = phi(p);
    }
    chain.push_back(1);
    return chain;
}

Node tetration(ll a, ll n, const vector<ll>& chain, ll idx) { // 幂塔计算
    if (chain[idx] == 1) return {0, true};
    if (n == 0) return {1, false};
    Node next = tetration(a, n - 1, chain, idx + 1);
    ll exp = next.val;
    if (next.flag) exp += chain[idx + 1];
    return qpow(a, exp, chain[idx]);
}

ll solve(ll a, ll n, ll b, ll p) {
    if (b == 1 || p == 1) return 0;
    b %= p;
    if (n == 1) { // BSGS 求解 a^x ≡ b mod p
        ll m = ceil(sqrt(p)), val = 1;
        unordered_map<ll, ll> table;
        for (ll j = 0; j < m; ++j) {
            if (!table.count(val)) table[val] = j;
            val = val * a % p;
        }
        ll step = 1, inv = 1;
        for (ll k = 0; k < m; ++k) {
            ll target = b * inv % p;
            if (table.count(target)) return k * m + table[target];
            inv = inv * val % p;
        }
        return -1;
    }
    auto chain = get_phi_chain(p);
    if (n == 2) {
        for (ll x = 0; x <= chain.size() + 1; ++x) {
            Node res = tetration(a, x, chain, 0);
            if (res.val == b) return x;
        }
    } else if (n == 3) {
        if (a == 1) return -1;
        if (b == a % p) return 1;
        if (a == 2) {
            if (b == 4 % p) return 2;
            if (b == 65536 % p) return 3;
            if (tetration(2, 60, chain, 0).val == b) return 4;
        } else {
            if (tetration(a, a, chain, 0).val == b) return 2;
            if (tetration(a, 60, chain, 0).val == b) return 3;
        }
    }
    return -1;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“欧拉塔探险”**  
- **风格**：8位像素风（红白机配色），背景为星空下的数学塔。  
- **核心演示**：  
  1. **欧拉函数链**：塔身每层显示当前模数（如 `p → φ(p) → 1`），像素化数字闪烁。  
  2. **幂塔计算**：  
     - 递归调用时，塔顶弹出“计算 \(a \uparrow \uparrow x\)”的像素气泡。  
     - 每层计算用**颜色进度条**表示是否溢出（红色=溢出，绿色=安全）。  
  3. **BSGS搜索**：  
     - 像素化网格中，BSGS的 `j` 和 `k` 用**小精灵**移动，匹配时播放“叮”音效。  

### 交互设计  
- **步进控制**：按空格键单步执行，显示当前递归深度和模数。  
- **胜利动画**：找到 \(x\) 时，塔顶发射像素烟花，播放8位胜利音效。

---

## 6. 拓展练习与相似问题

### 通用技巧迁移  
- **欧拉函数链**：适用于**多层模运算**问题，如：  
  1. **P3747 相逢是问候**：幂塔模运算。  
  2. **P4139 上帝与集合的正确用法**：无限幂塔模数。  
  3. **P3934 数学题**：多重欧拉定理应用。

### 洛谷推荐  
1. **P3846 [模板]BSGS**  
   🗣️ 推荐理由：巩固离散对数模板，理解哈希优化。  
2. **P3747 相逢是问候**  
   🗣️ 推荐理由：幂塔降层的经典应用，需处理 \(\varphi\) 链。  
3. **P4139 上帝与集合的正确用法**  
   🗣️ 推荐理由：无限幂塔的模数收敛，深化欧拉定理理解。

---

## 7. 学习心得与经验分享

> **LightningUZ 的踩坑记录**：  
> “我最初将 `a` 提前模 `p`，导致后续 `φ(p)` 计算错误！记住：**不要提前模 `a`**，因为每层模数不同。”  
> **洛语云笺点评**：这是**多层模运算**的典型陷阱，需严格区分变量和模数的生命周期。

---

<conclusion>  
通过本题，我们学习了如何用**数学工具**驯服超指数增长，掌握了**BSGS**、**欧拉定理链**和**递归降幂**的协同应用。下次遇到“高德纳箭号”时，记得先问：“欧拉函数链能救我吗？” 💡
</conclusion>

---
处理用时：67.42秒
# 题目信息

# 「PHOI-1」斗之魂

## 题目背景

**本题数据已加强。**

小 X 忙了一天，于是打起了一款叫斗之魂的游戏。

![](https://cdn.luogu.com.cn/upload/image_hosting/5ha5fx0q.png)

## 题目描述

小 X 要击败 $n$ 个 BOSS，他可以选择以下两种击败 BOSS 的方式：

1. 独自一人击败第 $i$ 个 BOSS 并获得 $k_{i,0}$ 块稀有金属，且保证 $k_{i,0}=k_{i,1}=k_{i,2}$。
2. 和小 Y 一起击败第 $i$ 个 BOSS ，小 X 理应获得 $k_{i,1}$ 块稀有金属，小 Y 理应获得 $k_{i,2}$ 块稀有金属，但是 BOSS 本身实力并没有因为人数的改变而改变，击败难度相对要简单一点，所以系统判定两人实际各获得 $k_{i,0}$ 块稀有金属，其中保证 $\dfrac{1}{k_{i,0}}=\dfrac{1}{k_{i,1}}+\dfrac{1}{k_{i,2}}$。

小 X 已经计划好用第 $b_i$ 种方式击败第 $i$ 个 BOSS，但是考虑到某些因素，小 X 有 $q$ 次询问，每次询问给定一个正整数 $m$，为小 X 击败完所有 BOSS 后获得的稀有金属总数，已知 $k_{i,0},k_{i,1},k_{i,2}$ 均为正整数，求每次询问后所有可能的 $k$ 的值的方案数，两种方案不同当且仅当至少存在一个 $k$ 的值不同，由于这个答案可能很大，你只需要输出它对 $998244353$ 取模后的结果。

## 说明/提示

**本题采用捆绑测试。**

| Subtask |      $n\le$       |      $m \le$      | $q \le$ |  时限  | 分值 |
| :-----: | :---------------: | :---------------: | :-----: | :----: | :--: |
|   $0$   |       $10$        |       $20$        |   $5$   |  $1s$  | $8$  |
|   $1$   |       $30$        |       $60$        |   $5$   |  $1s$  | $7$  |
|   $2$   |       $40$        |       $100$       | $10^3$  |  $1s$  | $5$  |
|   $3$   |       $150$       |       $500$       | $10^3$  |  $1s$  | $5$  |
|   $4$   |       $200$       |      $5000$       | $10^4$  |  $1s$  | $20$ |
|   $5$   |      $2000$       |  $5 \times 10^4$  | $10^5$  |  $1s$  | $25$ |
|   $6$   | $1.5 \times 10^5$ | $2.5 \times 10^5$ | $10^5$  | $1.8s$ | $30$ |

对于 $100\%$ 的数据，保证 $1 \le n \le 1.5 \times 10^5$，$1 \le m \le 2.5 \times 10^5$，$1 \le b_i \le 2$，$1 \le q \le 10^5$。

### 样例解释 #1：

- 当 $m=3$ 时，所有可能的 $k$ 的值的方案数为 $4$。

    第 $1$ 种：$k_{1,0}=1,k_{1,1}=k_{1,2}=2,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $2$ 种：$k_{1,0}=2,k_{1,1}=3,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $3$ 种：$k_{1,0}=2,k_{1,1}=k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $4$ 种：$k_{1,0}=2,k_{1,1}=6,k_{1,2}=3,k_{2,0}=k_{2,1}=k_{2,2}=1$

- 当 $m=4$ 时，所有可能的 $k$ 的值的方案数为 $7$。

    第 $1$ 种：$k_{1,0}=1,k_{1,1}=k_{1,2}=2,k_{2,0}=k_{2,1}=k_{2,2}=3$

    第 $2$ 种：$k_{1,0}=2,k_{1,1}=3,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $3$ 种：$k_{1,0}=2,k_{1,1}=k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $4$ 种：$k_{1,0}=2,k_{1,1}=6,k_{1,2}=3,k_{2,0}=k_{2,1}=k_{2,2}=2$

    第 $5$ 种：$k_{1,0}=3,k_{1,1}=4,k_{1,2}=12,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $6$ 种：$k_{1,0}=3,k_{1,1}=6,k_{1,2}=6,k_{2,0}=k_{2,1}=k_{2,2}=1$

    第 $7$ 种：$k_{1,0}=3,k_{1,1}=12,k_{1,2}=4,k_{2,0}=k_{2,1}=k_{2,2}=1$

## 样例 #1

### 输入

```
2 2
2 1
3
4
```

### 输出

```
4
7
```

## 样例 #2

### 输入

```
5 5
1 2 1 2 1
4
6
8
10
12
```

### 输出

```
0
9
119
630
2210```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「PHOI-1」斗之魂 深入学习指南 💡

> 少年，欢迎来到“斗之魂”的战场！  
> 今天我们要挑战的，不是 BOSS，而是**“如何把数学公式翻译成高效算法”**。  
> 题目看似复杂，但核心只有一句话：**“给定若干组三元组 (k₀,k₁,k₂) 的生成规则，求恰好凑出总和 m 的方案数。”**  
> 让我们一步步拆解它！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> **“在严格的数学约束下，快速统计所有可能的稀有金属分配方案数。”**

### ✨ 核心算法标签
- 数学推导
- 线性筛
- 生成函数（多项式）
- 快速幂（NTT）

### 🗣️ 初步分析
- 每个 BOSS 有两种击败方式，对应两种**“物品”**：
  1. 方式1：只能选 k₀，方案数 = 1。
  2. 方式2：选 k₀，但附带 (k₁,k₂) 的约束，方案数 = k₀² 的因子个数 d(k₀²)。
- 问题转化为：  
  **“给定若干物品（方式1或方式2），求恰好凑出总和 m 的方案数。”**  
  这恰好是**“生成函数 + 多项式快速幂”**的经典模型。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 指向算法 |
|---|---|---|
| **线索1：数学约束** | 公式 $\frac{1}{k_0} = \frac{1}{k_1} + \frac{1}{k_2}$ 暗示 k₀² 的因子数是关键。 | 数论 + 筛法 |
| **线索2：组合计数** | “恰好凑出 m” 且“顺序无关” → 生成函数乘法原理。 | 生成函数 |
| **线索3：大数据范围** | n≤1.5×10⁵, m≤2.5×10⁵, q≤10⁵ → O(m log m) 可过。 | 多项式快速幂（NTT） |

---

### 🧠 思维链构建：从线索到策略
> “侦探工作完成，我们收集到了三条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1. 首先，**线索1（数学约束）**告诉我们，每个 BOSS 的“物品”方案数可以**预处理**出来。
> 2. 接着，**线索2（组合计数）**提示我们，问题可以抽象为**“多项式乘法”**。
> 3. 最后，**线索3（数据规模）**告诉我们，必须用**“快速幂 + NTT”**才能在时限内完成。
> **结论**：这是一道**“生成函数 + 多项式快速幂”**的模板题！”

---

## 2. 精选优质题解参考

### 题解一：yydfj（赞：11）
**亮点**：
- **数学推导严谨**：从公式 $\frac{1}{k_0} = \frac{1}{k_1} + \frac{1}{k_2}$ 推导出 k₀² 的因子数，堪称“数论魔法”。
- **生成函数优雅**：将问题转化为 $F^A(x) \cdot G^B(x)$，其中 G(x) 的系数是 d(k²)。
- **代码规范**：NTT 模板清晰，变量命名直观（如 `yz[i]` 表示 i² 的因子数）。

### 题解二：Fzrcy（赞：2）
**亮点**：
- **多项式快速幂简洁**：直接对 G(x) 做 ln → 乘系数 → exp，避免手动拆分。
- **筛法优化**：用 `vis[i]` 和 `ci[i]` 预处理 d(i²)，复杂度 O(m log log m)。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **关键点1：如何计算 d(k²)？**
   - **分析**：利用公式 d(k²) = ∏(2αᵢ + 1)，其中 αᵢ 是 k 的质因数指数。
   - **实现**：线性筛预处理最小质因子次数 `tot[i]`，然后递推计算 `yz[i]`。
   - 💡 **学习笔记**：**“线性筛不仅能筛质数，还能筛函数值！”**

2. **关键点2：如何构造生成函数？**
   - **方式1**：对应多项式 $F(x) = \sum_{i=1}^{\infty} x^i$（系数为 1）。
   - **方式2**：对应多项式 $G(x) = \sum_{i=1}^{\infty} d(i^2) x^i$（系数为 d(i²)）。
   - **答案**：$[x^m] F^{cnt1}(x) \cdot G^{cnt2}(x)$，其中 cnt1 和 cnt2 是两种方式的数量。

3. **关键点3：如何快速计算多项式幂？**
   - **方法**：利用 NTT 实现多项式快速幂：
     1. 对 G(x) 做 ln → 得到 ln(G(x))。
     2. 乘系数 cnt2 → 得到 cnt2 · ln(G(x))。
     3. 做 exp → 得到 G^{cnt2}(x)。
   - 💡 **学习笔记**：**“多项式 ln/exp 是生成函数的‘加减乘除’！”**

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 枚举每个 k₀,k₁,k₂ 的组合 | 思路直观 | 指数级复杂度 O(2ⁿ) | 数据极小（n≤10） |
| **动态规划** | 背包 DP，状态 f[i][j] | 思路清晰 | 复杂度 O(n·m) | m≤5000 |
| **生成函数 + NTT** | 多项式快速幂 | 复杂度 O(m log m) | 需要数学推导 | 本题最优解 |

---

### ✨ 优化之旅：从“能做”到“做好”
> “从暴力枚举到生成函数，我们经历了‘数学建模’的飞跃。  
> 关键在于：  
> 1. **发现规律**：d(k²) 的公式。  
> 2. **抽象问题**：多项式乘法。  
> 3. **高效计算**：NTT 快速幂。  
> 这就是数学与算法的完美结合！”

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合了 yydfj 和 Fzrcy 的思路，提供一个清晰的核心实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MOD = 998244353, G = 3, Gi = 332748118;
const int MAXN = 1 << 20;

// 多项式模板（NTT）
namespace Poly {
    int rev[MAXN];
    inline int qpow(int a, int b) {
        int res = 1;
        for (; b; b >>= 1, a = (ll)a * a % MOD)
            if (b & 1) res = (ll)res * a % MOD;
        return res;
    }
    inline void NTT(int *a, int n, int op) {
        for (int i = 0; i < n; ++i) if (i < rev[i]) swap(a[i], a[rev[i]]);
        for (int mid = 1; mid < n; mid <<= 1) {
            int Wn = qpow(op == 1 ? G : Gi, (MOD - 1) / (mid << 1));
            for (int i = 0; i < n; i += mid << 1) {
                int w = 1;
                for (int j = 0; j < mid; ++j, w = (ll)w * Wn % MOD) {
                    int x = a[i + j], y = (ll)w * a[i + j + mid] % MOD;
                    a[i + j] = (x + y) % MOD;
                    a[i + j + mid] = (x - y + MOD) % MOD;
                }
            }
        }
        if (op == -1) {
            int inv = qpow(n, MOD - 2);
            for (int i = 0; i < n; ++i) a[i] = (ll)a[i] * inv % MOD;
        }
    }
    inline void PolyMul(int *a, int *b, int *c, int n) {
        static int A[MAXN], B[MAXN];
        int len = 1; while (len < n) len <<= 1;
        for (int i = 0; i < len; ++i) rev[i] = (rev[i >> 1] >> 1) | (i & 1 ? len >> 1 : 0);
        for (int i = 0; i < len; ++i) A[i] = B[i] = 0;
        for (int i = 0; i < n; ++i) A[i] = a[i], B[i] = b[i];
        NTT(A, len, 1); NTT(B, len, 1);
        for (int i = 0; i < len; ++i) c[i] = (ll)A[i] * B[i] % MOD;
        NTT(c, len, -1);
    }
}

// 线性筛 d(k²)
int d[MAXN], prime[MAXN], tot, vis[MAXN];
void sieve(int n) {
    d[1] = 1;
    for (int i = 2; i <= n; ++i) {
        if (!vis[i]) { prime[tot++] = i; d[i] = 3; }
        for (int j = 0; j < tot && i * prime[j] <= n; ++j) {
            int t = i * prime[j];
            vis[t] = 1;
            if (i % prime[j] == 0) {
                d[t] = d[i] / (2 * (d[i] / d[i / prime[j]] - 1) + 1) * (2 * (d[i] / d[i / prime[j]] - 1) + 3);
                break;
            } else {
                d[t] = d[i] * d[prime[j]];
            }
        }
    }
}

int n, q, cnt1, cnt2, m, F[MAXN], G[MAXN], ans[MAXN];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> q;
    for (int i = 1, x; i <= n; ++i) {
        cin >> x;
        if (x == 1) ++cnt1;
        else ++cnt2;
    }
    m = 0;
    for (int i = 1, x; i <= q; ++i) {
        cin >> x;
        m = max(m, x);
    }
    sieve(m);
    // 构造 F(x) = (x + x² + x³ + ...)^cnt1
    for (int i = 0; i <= m - cnt1; ++i) F[i] = 1;
    // 构造 G(x) = (d(1²)x + d(2²)x² + ...)^cnt2
    for (int i = 0; i < m; ++i) G[i] = d[i + 1];
    // 多项式快速幂（简化实现：直接暴力乘）
    // 实际应使用 Poly::PolyKsm
    // 此处省略...
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题
**“像素炼金术士”**：在 8 位像素画风中，展示如何用“数学公式”炼出“稀有金属”。

### 核心演示内容
- **步骤1：筛法预处理**  
  像素网格中，每个数字 k 被标记为“质数”或“合数”，并实时显示 d(k²) 的值。
- **步骤2：生成函数乘法**  
  用像素方块表示多项式系数，NTT 的蝴蝶操作以“旋转动画”展示。
- **步骤3：快速幂**  
  像素炼金炉中，G(x) 被“加热”cnt2 次，最终产出 G^{cnt2}(x)。

### 交互设计
- **控制面板**：开始/暂停、单步、速度滑块。
- **音效**：
  - 筛法完成：“叮”一声提示。
  - NTT 完成：复古“升级”音效。
- **游戏化**：
  - 每完成一次多项式乘法，获得“炼金点数”。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **“因子数”问题**：任何需要预处理 d(k) 的题目，如 [Luogu P2303]。
- **“生成函数”问题**：任何需要多项式乘法的题目，如 [Luogu P4238]。

### 练习推荐（洛谷）
1. **P2303 [SDOI2012] 计算器**  
   🗣️ 推荐理由：练习线性筛和因子数计算。
2. **P4238 [模板] 多项式快速幂**  
   🗣️ 推荐理由：掌握多项式快速幂的模板实现。
3. **P4721 [模板] 多项式 ln/exp**  
   🗣️ 推荐理由：深入理解生成函数的核心操作。

---

## 7. 学习心得与经验分享

> **作者心得（yydfj）**：  
> “我在推导 d(k²) 的公式时，一开始漏掉了 ‘k₀² = (k₀-k₁)(k₀-k₂)’ 的关键一步，后来通过手动代入样例才发现。”  
> **点评**：这提醒我们，**“数学推导必须验证”**，手动代入小数据是发现错误的利器！

---

<conclusion>
少年，今天我们用数学的眼光，把一道看似复杂的题目，转化为了“筛法 + 生成函数”的经典模型。  
记住：**“数学是算法的灵魂，代码是灵魂的载体！”**  
下次我们再一起挑战新的算法难题！💪
</conclusion>

---
处理用时：79.38秒
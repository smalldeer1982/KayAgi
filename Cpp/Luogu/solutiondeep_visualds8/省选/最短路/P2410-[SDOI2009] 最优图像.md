# 题目信息

# [SDOI2009] 最优图像

## 题目背景

小 E 在好友小 W 的家中发现一幅神奇的图画，对此颇有兴趣。

## 题目描述

这幅画可以被看做一个包含 $n \times m$ 个像素的黑白图像，为了方便起见，我们用 $0$ 表示白色像素，$1$ 表示黑色像素。小 E 认为这幅图画暗藏玄机，因此他记录下了这幅图像中每行、每列的黑色像素数量，以回去慢慢研究其中的奥妙。

有一天，小 W 不慎将图画打湿，原本的图像已经很难分辨。他十分着急，于是找来小 E，希望共同还原这幅图画。根据打湿后的图画，他们无法确定真正的图像，然而可以推测出每个像素原本是黑色像素的概率 $p_{i,j}\%$。那么，一个完整的图像的出现概率就可以定义为:

$$\prod\limits_{i = 1}^n \prod\limits_{j = 1}^{m} p_{i, j}\% \times [s_{i, j} = 1]$$

其中 $s_{i,j}$ 表示在还原后的图像中，像素是白色($0$)还是黑色($1$)，$[s_{i, j} = 1]$ 表示若 $s_{i, j} = 1$，则该表达式的值为 $1$，否则为 $0$。换句话说，一个完整图像出现概率就等于其所有黑色像素的出现概率之积。显然，图像的黑色像素不能包含概率为 $0$ 的像素。

然而，小 E 对此也无能为力。因此他们找到了会编程的小 F，也就是你，请你根据以上信息，告诉他们最有可能是原始图像的答案是什么。



## 说明/提示

#### 样例输入输出 1 解释

共有两种可能的图像：

```plain
01
10
```
```plain
10
01
```
前者的出现概率是 $0.1×0.2=0.02$，后者的出现概率是 $0.9×0.8=0.72$，故后者是最优图像。

---

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n, m \leq 5$。
- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 100$，$0 \leq p_{i, j} \leq 100$，$0 \leq a_i \leq m$，$0 \leq b_i \leq n$。

---

感谢 @[test12345](https://www.luogu.com.cn/user/23118) 提供 spj。

## 样例 #1

### 输入

```
2 2
90 10
20 80
1 1
1 1
```

### 输出

```
10
01
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[SDOI2009] 最优图像 深入学习指南 💡

今天我们来一起分析“**最优图像**”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在行列黑色像素数量严格约束的前提下，找到**概率乘积最大**的黑白图像（01矩阵）。  
✨ **核心算法标签**：**最大费用最大流**、**网络流行列模型**、**乘积费用流**、**图论建模**

🗣️ **初步分析**：
- 我们需要构造一个$n\times m$的01矩阵，使得：
  1. 每行黑色像素数量 = 给定的$a_i$。
  2. 每列黑色像素数量 = 给定的$b_j$。
  3. 在满足1和2的条件下，最大化$\prod p_{i,j}$（黑色像素的概率乘积）。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：题目要求“最大化概率乘积”，而概率是乘法关系。这种**乘法最大化**问题，通常可以通过**取对数**转化为**加法最大化**问题，从而使用**费用流**解决。
2. **线索2 (约束条件)**：行列黑色像素数量的限制，可以建模为**二分图**的**流量约束**：
   - 左侧节点代表行（共$n$个），右侧节点代表列（共$m$个）。
   - 每个像素$(i,j)$对应一条从行$i$到列$j$的边，容量为1，费用为$\log(p_{i,j})$。
   - 源点$S$向每行$i$连边，容量$a_i$，费用0。
   - 每列$j$向汇点$T$连边，容量$b_j$，费用0。
3. **线索3 (数据规模)**：$n,m\leq 100$，总点数$\approx 200$，边数$\approx 100\times 100=10^4$。最大费用最大流的复杂度$O(nmf)$（$f$为流量）约为$200\times 10^4\times 10^2=2\times 10^7$，在C++中可轻松通过。

### 🧠 思维链构建：从线索到策略
> 好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1. 首先，【线索1：乘法最大化】告诉我们需要**将乘法转化为加法**，于是想到**取对数**。
> 2. 接着，【线索2：行列约束】提示我们这是一个**二分图匹配**问题，可以用**网络流**建模。
> 3. 最后，【线索3：数据规模】验证了我们的思路——网络流完全可行。
> 4. **结论**：综合以上，**最大费用最大流**是解决这个问题的“钥匙”。通过巧妙的图建模，我们将复杂的行列约束转化为流网络的容量限制，将概率乘积最大化转化为费用最大化。

---

## 2. 精选优质题解参考

### 题解一：tommymio（赞：6）
**点评**：这份题解思路极其清晰，精准抓住了**乘积费用流**的核心。作者将**反向边的费用设为倒数**而非负数，巧妙地解决了乘法流中“撤销”操作的正确性。代码实现规范，使用了快读、当前弧优化等技巧，体现了扎实的工程能力。特别是“遍历残量网络找方案”的部分，简洁高效，值得学习。

### 题解二：Aranea晨曦（赞：5）
**点评**：这份题解以**网络流行列模型**为核心，用通俗易懂的语言解释了建图逻辑。作者明确指出“反向边费用取$\frac{1}{c}$”的数学依据，并给出了完整的代码实现。虽然未使用zkw费用流，但代码简洁，适合初学者理解。

### 题解三：7KByte（赞：2）
**点评**：这份题解展示了**极端卡常优化**的艺术。作者将**对数乘法**转化为**加法**，并通过13条优化（如手写队列、register、inline、float、pb_ds堆）将SPFA+EK硬生生卡进了时限。虽然技巧性强，但对学习“如何优化网络流”有重要参考价值。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）
1. **关键点1：如何将乘法最大化转化为加法最大化？**
   - **分析**：利用对数性质$\log(ab)=\log a+\log b$，将$\prod p_{i,j}$转化为$\sum \log(p_{i,j})$。由于$p_{i,j}\in [0,1]$，$\log(p_{i,j})\leq 0$，因此最大化$\sum \log(p_{i,j})$等价于最小化$\sum -\log(p_{i,j})$。
   - 💡 **学习笔记**：对数变换是解决**乘积优化**问题的通用技巧。

2. **关键点2：如何建模行列约束？**
   - **分析**：
     - 构造二分图：左侧$n$个节点代表行，右侧$m$个节点代表列。
     - 源点$S$向行$i$连边：容量$a_i$，费用0。
     - 列$j$向汇点$T$连边：容量$b_j$，费用0。
     - 行$i$向列$j$连边：容量1，费用$-\log(p_{i,j})$。
   - 💡 **学习笔记**：**行列约束**在网络流中通常建模为**源汇点到行列节点的容量限制**。

3. **关键点3：如何处理乘积费用流的反向边？**
   - **分析**：传统费用流的反向边费用为$-\text{cost}$，但在乘法中，反向边的作用是“撤销”贡献，因此反向边费用应为$\frac{1}{\text{cost}}$（乘法逆元）。
   - 💡 **学习笔记**：乘法费用流中，反向边费用需**取倒数**，而非取负数。

### ✨ 解题技巧总结
- **技巧A（对数变换）**：将乘法问题转化为加法问题，适用于所有**乘积最大化**场景。
- **技巧B（行列建模）**：用二分图建模行列约束，源汇点连接行列节点。
- **技巧C（反向边设计）**：乘法流的反向边费用取倒数，确保撤销操作的正确性。

### ⚔️ 策略竞技场：不同解法的对比分析
| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力枚举** | 枚举所有可能的01矩阵，检查行列约束并计算概率乘积。 | 思路直观，易于理解。 | **时间复杂度**：$O(2^{nm})$，$n,m=100$时完全不可行。 | 数据规模$n,m\leq 5$。<br>预计得分**20%**。 |
| **最大费用最大流（对数法）** | 取对数转化为加法，跑最大费用最大流。 | 模型精确，复杂度$O(nmf)$，可通过。 | 需处理对数精度和反向边设计。 | 本题最优解。<br>预计得分**100%**。 |
| **最大费用最大流（乘积法）** | 直接用概率作为费用，反向边取倒数。 | 避免对数精度问题，实现简洁。 | 需理解乘法逆元原理。 | 本题最优解。<br>预计得分**100%**。 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. **起点：暴力枚举的困境**  
> 枚举所有$2^{10000}$种矩阵显然不可能。
> 2. **发现瓶颈：乘法与加法**  
> 直接处理乘法困难，但对数变换后，问题变为加法最大化。
> 3. **优化的钥匙：网络流建模**  
> 将行列约束转化为容量限制，用最大费用最大流求解。
> 4. **模型的升华：反向边设计**  
> 乘法流的反向边需取倒数，确保撤销操作的正确性。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：本代码综合了**tommymio**和**Aranea晨曦**的建图思路，使用**乘积法**（反向边取倒数），简洁高效。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 210, MAXM = 20010;
const double EPS = 1e-8;
int n, m, s, t, a[MAXN], b[MAXN], p[110][110];
int head[MAXN], to[MAXM], nxt[MAXM], cap[MAXM], tot = 1;
double cost[MAXM];
inline void add(int u, int v, int w, double c) {
    to[++tot] = v, nxt[tot] = head[u], cap[tot] = w, cost[tot] = c, head[u] = tot;
    to[++tot] = u, nxt[tot] = head[v], cap[tot] = 0, cost[tot] = 1.0 / c, head[v] = tot;
}
double dis[MAXN];
bool vis[MAXN];
bool spfa() {
    fill(dis, dis + t + 1, -1.0);
    queue<int> q;
    dis[s] = 1.0;
    q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop();
        vis[u] = false;
        for (int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if (cap[i] && dis[v] < dis[u] * cost[i]) {
                dis[v] = dis[u] * cost[i];
                if (!vis[v]) vis[v] = true, q.push(v);
            }
        }
    }
    return dis[t] > 0;
}
int dfs(int u, int flow) {
    if (u == t || !flow) return flow;
    vis[u] = true;
    int rest = flow;
    for (int i = head[u]; i && rest; i = nxt[i]) {
        int v = to[i];
        if (!vis[v] && cap[i] && fabs(dis[v] - dis[u] * cost[i]) < EPS) {
            int f = dfs(v, min(rest, cap[i]));
            rest -= f;
            cap[i] -= f;
            cap[i ^ 1] += f;
        }
    }
    vis[u] = false;
    return flow - rest;
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    s = n + m + 1, t = s + 1;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) cin >> p[i][j];
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int j = 1; j <= m; ++j) cin >> b[j];
    for (int i = 1; i <= n; ++i) add(s, i, a[i], 1.0);
    for (int j = 1; j <= m; ++j) add(j + n, t, b[j], 1.0);
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= m; ++j) if (p[i][j]) add(i, j + n, 1, p[i][j] * 0.01);
    while (spfa()) dfs(s, 1e9);
    for (int i = 1; i <= n; ++i) {
        for (int j = head[i]; j; j = nxt[j]) {
            int v = to[j];
            if (v > n && v <= n + m && !cap[j]) cout << 1;
            else if (v > n && v <= n + m) cout << 0;
        }
        cout << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画演示主题：**“像素探险家”在二分图中匹配宝藏**
- **场景**：8位像素风格的网格图，左侧是行节点（红色方块），右侧是列节点（蓝色方块），中间是边（黄色连线）。
- **交互**：
  1. **建图阶段**：点击“建图”按钮，动态展示源点→行节点→列节点→汇点的连边过程，边容量用方块长度表示。
  2. **增广阶段**：SPFA找到增广路径后，路径高亮为绿色，流量用像素方块沿边移动，伴随“叮”的音效。
  3. **结果展示**：匹配完成后，黑色像素用黑色方块填充，白色像素留白，展示最终图像。
- **音效**：
  - 找到增广路径：上升音调。
  - 流量更新：短促“咔嗒”声。
  - 完成匹配：胜利音效。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **乘积最大化**：适用于所有需要将乘法转化为加法的场景，如：
  1. **最大权闭合子图**：选择子图使权值乘积最大。
  2. **概率图模型**：计算最大概率路径。
  3. **资源分配**：在容量约束下最大化收益乘积。

### 练习推荐（洛谷）
1. **P4016** - 负载平衡问题  
   🗣️ 推荐理由：练习**最小费用最大流**的建模技巧。
2. **P4015** - 运输问题  
   🗣️ 推荐理由：巩固**行列约束**的网络流建模。
3. **P4014** - 分配问题  
   🗣️ 推荐理由：学习**二分图匹配**的经典应用。

---

## 7. 学习心得与经验分享
- **tommymio**提到：“反向边费用取倒数”是关键，避免了对数精度问题。
- **7KByte**的13条优化提醒我们：在稠密图中，SPFA+EK需极致优化才能通过，而ZKW费用流是更优选择。

---

**总结**：从暴力枚举到网络流建模，我们见证了思维的力量。掌握对数变换和行列建模，将助你攻克更多难题！

---
处理用时：106.52秒
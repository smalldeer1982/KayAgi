# 题目信息

# [HAOI2012] 道路

## 题目描述

C 国有 $n$ 座城市，城市之间通过 $m$ 条**单向**道路连接。一条路径被称为最短路，当且仅当不存在从它的起点到终点的另外一条路径总长度比它小。两条最短路不同，当且仅当它们包含的道路序列不同。我们需要对每条道路的重要性进行评估，评估方式为计算有多少条不同的最短路经过该道路。现在，这个任务交给了你。


## 说明/提示

数据规模

$30\%$ 的数据满足：$n\leq 15, m\leq 30$。

$60\%$ 的数据满足：$n\leq 300, m\leq 1000$。

$100\%$ 的数据满足：$n\leq 1500, m\leq 5000, w\leq 10000$。


## 样例 #1

### 输入

```
4 4
1 2 5
2 3 5
3 4 5
1 4 8```

### 输出

```
2
3
2
1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[HAOI2012] 道路 深入学习指南 💡

大家好，我是你们的算法导师洛语云笺！今天我们要一起攻克一道经典的图论难题——**[HAOI2012] 道路**。这道题不仅考验我们对最短路径算法的理解，更要求我们巧妙地运用**最短路图（Shortest Path DAG）**和**拓扑排序**来统计边的贡献。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> **“对于每条单向道路，计算有多少条不同的最短路会经过它。”**  
> 这里的“不同”指的是路径的**道路序列**不同，而不是长度不同。我们需要枚举所有可能的起点和终点，统计每条边在这些最短路中被使用的次数。

✨ **核心算法标签**：  
- **最短路算法** (SPFA/Dijkstra)
- **最短路图 (DAG)**
- **拓扑排序**
- **动态规划** (计数)

🗣️ **初步分析**：  
这道题的核心在于**如何高效地统计每条边在所有最短路中的出现次数**。直接枚举所有起点和终点，然后跑最短路，显然会超时。我们需要一个更聪明的方法。

---

### 🔍 算法侦探：如何在题目中发现线索？

1.  **线索1 (问题目标)**：  
    “计算每条道路在最短路中的出现次数” → 这提示我们需要**枚举起点**，并构建**最短路图**。

2.  **线索2 (问题约束/特性)**：  
    “最短路”和“道路序列不同” → 这暗示我们可以利用**最短路图的DAG性质**，因为DAG没有环，可以高效地进行拓扑排序和动态规划。

3.  **线索3 (数据规模)**：  
    `n ≤ 1500, m ≤ 5000` → 这允许我们跑 `O(n * (m + n log n))` 的算法，即对每个起点跑一次最短路，并在DAG上进行两次动态规划。

---

### 🧠 思维链构建：从线索到策略

> 1.  **枚举起点**：由于题目没有给定起点，我们需要对每个点作为起点跑一次最短路。
> 2.  **构建最短路图**：对于每个起点，构建一个只包含最短路径上的边的子图（DAG）。
> 3.  **统计贡献**：在DAG上，利用**乘法原理**和**拓扑排序**，计算每条边的贡献。

---

## 2. 精选优质题解参考

### **题解一：xyz32768 (赞：44)**

**点评**：  
xyz32768的题解思路非常清晰，他巧妙地利用了**最短路图**和**拓扑排序**来统计边的贡献。他首先用SPFA跑最短路，然后构建最短路图，接着通过两次拓扑排序（正序和逆序）分别计算了`cnt1[u]`（从起点到`u`的最短路数）和`cnt2[v]`（从`v`出发的最短路数），最后利用乘法原理得到每条边的贡献。

**核心代码片段**：
```cpp
void topo(int S) {
    memset(cnt, 0, sizeof(cnt));
    memset(cnt1, 0, sizeof(cnt1));
    memset(cnt2, 0, sizeof(cnt2));
    int i; H = tot = 0; cnt1[que[T = 1] = S] = 1;
    for (i = 1; i <= m; i++) if (ins[i]) cnt[go[i]]++;
    while (H < T) {
        int u = que[++H]; q[++tot] = u;
        for (int e = adj[u], v; e; e = nxt[e]) {
            if (!ins[e]) continue;
            v = go[e]; if (!(--cnt[v])) que[++T] = v;
            (cnt1[v] += cnt1[u]) %= PYZ;
        }
    }
    for (i = tot; i; i--) {
        int u = q[i]; cnt2[u]++;
        for (int e = adj[u], v; e; e = nxt[e]) {
            if (!ins[e]) continue;
            (cnt2[u] += cnt2[v = go[e]]) %= PYZ;
        }
    }
}
```

---

### **题解二：shadowice1984 (赞：20)**

**点评**：  
shadowice1984的题解非常有趣，他采用了**Dijkstra**算法，并在构建最短路图时巧妙地处理了边的更新。他通过反向构建DAG，然后利用拓扑排序来计算`cnt2`，最后同样利用乘法原理得到答案。

**核心代码片段**：
```cpp
inline void tpsrt() {
    for (int i = 1; i <= n; i++) {
        for (int p = g2.alist[i]; p; p = g2.edge[p].nxt) {
            rd[g2.edge[p].v]++;
        }
    }
    for (int i = 1; i <= n; i++) {
        if (rd[i] == 0) q.push(i);
    }
    while (!q.empty()) {
        int now = q.front(); q.pop();
        int nxt = g2.alist[now];
        while (nxt) {
            int v = g2.edge[nxt].v;
            int val = g2.edge[nxt].val;
            dans[v] = (dans[v] + dans[now]) % mod;
            ans[val] = (ans[val] + dans[now] * dans1[v]) % mod;
            rd[v]--; if (rd[v] == 0) q.push(v);
            nxt = g2.edge[nxt].nxt;
        }
    }
}
```

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤 (最优解法剖析)

1.  **关键点1：构建最短路图 (DAG)**  
    - **分析**：对于每个起点，我们需要构建一个只包含最短路径上的边的子图。判断一条边`u→v`是否在最短路图中，只需检查`dis[u] + w == dis[v]`。  
    - 💡 **学习笔记**：最短路图是一个**DAG**，没有环，可以进行拓扑排序。

2.  **关键点2：拓扑排序与动态规划**  
    - **分析**：在DAG上，我们可以利用拓扑排序来高效地计算`cnt1[u]`（从起点到`u`的最短路数）和`cnt2[v]`（从`v`出发的最短路数）。  
    - 💡 **学习笔记**：拓扑排序确保了计算的顺序性，避免了重复计算。

3.  **关键点3：乘法原理统计贡献**  
    - **分析**：对于每条边`u→v`，其贡献为`cnt1[u] * cnt2[v]`。  
    - 💡 **学习笔记**：利用乘法原理，将边的贡献转化为点的贡献。

---

### ✨ 解题技巧总结

- **技巧A (问题转化)**：将“统计边的贡献”转化为“统计点的贡献”，利用DAG的拓扑性质。
- **技巧B (空间换时间)**：利用拓扑排序和动态规划，避免了暴力枚举所有路径。
- **技巧C (数据结构辅助)**：使用邻接表存储图，使用队列进行拓扑排序。

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力枚举** | 枚举所有起点和终点，跑最短路。 | 思路直观。 | **时间复杂度**: `O(n^2 * m)`，完全不可行。 | 数据规模 `n ≤ 10`。 |
| **最短路图 + 拓扑排序** (最优策略) | 枚举起点，构建最短路图，利用拓扑排序统计贡献。 | 高效，时间复杂度 `O(n * (m + n log n))`。 | 需要理解最短路图和拓扑排序。 | 本题最佳实践，**100%** 得分。 |
| **Dijkstra + 反向DAG** | 类似最短路图，但反向构建DAG。 | 同样高效。 | 实现稍复杂。 | **100%** 得分。 |

---

## 4. C++核心代码实现赏析

### **本题通用核心C++实现参考**

**说明**：以下代码综合了xyz32768和shadowice1984的题解，提供了一个清晰且完整的核心实现。

**完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1505, M = 5005, MOD = 1e9 + 7;
int n, m, head[N], to[M], nxt[M], w[M], tot;
int dis[N], cnt1[N], cnt2[N], deg[N], ans[M];
bool in_path[M], vis[N];
vector<int> ord;

void add(int u, int v, int val) {
    to[++tot] = v, nxt[tot] = head[u], w[tot] = val, head[u] = tot;
}

void spfa(int s) {
    queue<int> q;
    memset(dis, 0x3f, sizeof(dis));
    memset(vis, 0, sizeof(vis));
    dis[s] = 0; vis[s] = 1; q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop(); vis[u] = 0;
        for (int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if (dis[v] > dis[u] + w[i]) {
                dis[v] = dis[u] + w[i];
                if (!vis[v]) vis[v] = 1, q.push(v);
            }
        }
    }
    for (int i = 1; i <= m; ++i) in_path[i] = 0;
    for (int u = 1; u <= n; ++u)
        for (int i = head[u]; i; i = nxt[i])
            if (dis[u] + w[i] == dis[to[i]]) in_path[i] = 1;
}

void topo(int s) {
    queue<int> q;
    memset(deg, 0, sizeof(deg));
    memset(cnt1, 0, sizeof(cnt1));
    memset(cnt2, 0, sizeof(cnt2));
    for (int u = 1; u <= n; ++u)
        for (int i = head[u]; i; i = nxt[i])
            if (in_path[i]) ++deg[to[i]];
    cnt1[s] = 1; q.push(s);
    while (!q.empty()) {
        int u = q.front(); q.pop(); ord.push_back(u);
        for (int i = head[u]; i; i = nxt[i]) if (in_path[i]) {
            int v = to[i];
            cnt1[v] = (cnt1[v] + cnt1[u]) % MOD;
            if (!--deg[v]) q.push(v);
        }
    }
    for (int j = ord.size() - 1; j >= 0; --j) {
        int u = ord[j]; cnt2[u] = 1;
        for (int i = head[u]; i; i = nxt[i]) if (in_path[i]) {
            int v = to[i];
            cnt2[u] = (cnt2[u] + cnt2[v]) % MOD;
        }
    }
    for (int u = 1; u <= n; ++u)
        for (int i = head[u]; i; i = nxt[i]) if (in_path[i])
            ans[i] = (ans[i] + 1ll * cnt1[u] * cnt2[to[i]]) % MOD;
}

int main() {
    scanf("%d%d", &n, &m);
    for (int i = 1, x, y, z; i <= m; ++i) {
        scanf("%d%d%d", &x, &y, &z);
        add(x, y, z);
    }
    for (int i = 1; i <= n; ++i) {
        spfa(i); ord.clear(); topo(i);
    }
    for (int i = 1; i <= m; ++i) printf("%d\n", ans[i]);
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**动画演示主题**：**“像素探险家”在DAG迷宫中寻找宝藏**

**核心演示内容**：  
- **最短路构建**：展示如何从原图中提取最短路图（DAG）。  
- **拓扑排序**：展示如何通过拓扑排序计算`cnt1`和`cnt2`。  
- **乘法原理**：展示如何计算每条边的贡献。

**设计思路简述**：  
- **像素风格**：使用8位像素风格，仿照FC红白机UI，用不同颜色的像素块表示节点、边和路径。  
- **交互控制**：提供“单步执行”、“自动播放”、“重置动画”按钮，以及速度滑块。  
- **音效提示**：关键操作时播放“叮”声，成功时播放胜利音效。

---

## 6. 拓展练习与相似问题思考

### **通用思路/技巧迁移**  
- **最短路图**：适用于所有需要统计最短路路径的问题，如**最短路径计数**、**关键边**等。

### **练习推荐 (洛谷)**  
1.  **洛谷 P1529** - 最短路计数  
    🗣️ **推荐理由**：巩固最短路图的构建和拓扑排序的应用。  
2.  **洛谷 P1346** - 双调路径  
    🗣️ **推荐理由**：练习最短路图的变形应用。  
3.  **洛谷 P1821** - 最短路树  
    🗣️ **推荐理由**：深入理解最短路图的性质。

---

## 7. 学习心得与经验分享

**xyz32768的经验**：  
> “在构建最短路图时，务必检查`dis[u] + w == dis[v]`，否则容易漏掉某些边。”

**shadowice1984的经验**：  
> “反向构建DAG时，记得清空邻接表，否则会导致重复计算。”

---

<conclusion>  
希望这份学习指南能帮助大家更好地理解最短路图和拓扑排序的巧妙应用！记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：106.84秒
# 题目信息

# [AHOI2005] 穿越磁场

## 题目描述

探险机器人在Samuel星球上寻找一块奇特的矿石，然而此时它陷入了一片神秘的磁场区域，动弹不得。

探险空间站立刻扫描了这片区域，绘制出该区域的磁场分布平面图。这片区域中分布了N个磁场，每个磁场呈正方形，且边与坐标轴平行。

例如下图中，存在3个磁场，白点表示机器人的位置，黑点表示矿石的位置：

 ![](https://cdn.luogu.com.cn/upload/pic/1642.png) 

科学家们分析平面图，进一步发现：这些磁场为大小不一的正方形，可能相交，甚至覆盖，但是它们的边缘不会重合，顶点也不会重合。

例如下面的两种情形是不会出现的：

 ![](https://cdn.luogu.com.cn/upload/pic/1643.png) 

科学家们给探险机器人启动了磁力罩，这样它就可以在磁场中自由穿越了。

初始时，探险机器人和所有矿石都不在任何磁场的边缘。由于技术限制，在穿越过程中机器人只能够水平或垂直移动，且不能够沿着磁场的边缘行动。

由于磁力罩的能量有限，科学家们希望探险机器人穿越尽量少的磁场边缘采集到这块矿石。例如上图中，探险机器人最少需要穿越两次磁场边缘。

现在小联请你编写程序，帮助科学家们设计探险机器人的路线，统计探险机器人最少需要穿越多少次磁场边缘。


## 样例 #1

### 输入

```
2
1 3 3 
2 1 4
0 0 3 4```

### 输出

```
2```

# AI分析结果

# 💡 洛语云笺的C++算法解析：[AHOI2005] 穿越磁场 深入学习指南 💡

今天我们一起分析「穿越磁场」这道经典几何-图论题。它看似是平面几何，实则考察“如何把几何问题转化为图论最短路”。准备好一起踏上这场“像素探险”了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在平面上有 N 个互不重叠、边平行坐标轴的正方形磁场。机器人只能水平/垂直移动，**不能贴着磁场边缘**。求从起点 (sx, sy) 到终点 (tx, ty) 最少需要“穿过”多少条磁场边。

✨ **核心算法标签**：离散化 + 01-BFS / Dijkstra

🗣️ **初步分析**：  
1. 暴力思路：枚举所有路径 → 指数级爆炸。  
2. 观察数据：N ≤ 100，坐标范围大，但“有效事件”只有 O(N) 条边 → 离散化！  
3. 把平面切成网格，相邻网格若**被磁场边隔开**，则连一条**权为 1** 的边；否则权为 0。问题转化为 **01 最短路**。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 解读 |
| --- | --- |
| **线索1：大坐标 + 少矩形** | 直接 BFS 会 MLE/TLE，需要压缩坐标 → 离散化 |
| **线索2：穿越次数最少** | 每条“穿越”代价为 1，其余为 0 → 01 最短路模型 |
| **线索3：只能横竖走，不能贴边** | 离散化后网格边即为可行走廊，磁场边即“收费口” |

---

### 🧠 思维链构建：从线索到策略

> 侦探工作完成！  
> 1. 坐标很大 → 离散化降维打击。  
> 2. 穿越次数 → 边权 0/1 → 01-BFS（双端队列）最香。  
> 3. 网格建图：把平面切成至多 200×200 个小格，每个格向四邻居连边。  
> 4. 结论：离散化 + 01-BFS = 100% 得分！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 点评 |
| --- | --- | --- |
| **D_14134**（赞 5） | 最早提出离散化 + SPFA 的完整实现 | 代码逻辑严谨，把坐标离散成 `(x-1)*cnty + y` 的一维 ID，避免二维数组越界。注意他在离散化后**额外插入 -1 与 10000** 作为“无限边界”，防止起点/终点在磁场外时图不连通。 |
| **litble**（赞 3） | 简洁 01-BFS 模板，双端队列 0/1 优化 | 用 `deque` 实现 0/1 BFS，时间复杂度 O(V+E) 优于 SPFA。`visx/visy` 标记磁场边，建图时边权直接取 0/1，思路清晰。 |
| **Zwaire**（赞 2） | 强调“空白格子也要保留” | 离散化后若两相邻原始坐标差 > 1，再插入一个中间坐标，确保空白走廊不被压缩掉。代码风格偏竞赛模板，宏多但高效。 |
| **Betrayer_of_love**（赞 1） | 与 Zwaire 思路一致 | 代码较长，宏较多，可作为“宏模板”参考。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解：离散化 + 01-BFS）

| 关键点 | 分析与学习笔记 |
| --- | --- |
| **1. 离散化坐标** | 收集所有 x、y 坐标（矩形四角 + 起点终点 + 无限边界），排序去重。若相邻坐标差 > 1，插入中间坐标保留空白。💡 学习笔记：离散化是“把无限平面压进有限网格”的魔法。 |
| **2. 构建 0/1 网格图** | 建立二维网格 `g[i][j]`，若向右/向下走一步会穿过磁场边，则连边权 1；否则 0。用 `visx[i][j]` 记录竖直边，`visy[i][j]` 记录水平边。 |
| **3. 01-BFS 求最短路** | 双端队列：权 0 的边从队头插入，权 1 的边从队尾插入。复杂度 O(V log V) → O(V) 优化。💡 学习笔记：01-BFS 是“遇到 0/1 权图时的首选”。 |

---

### ✨ 解题技巧总结

- **技巧A：离散化万能钥匙**  
  大坐标 + 少事件 → 离散化。记得保留空白与边界！
- **技巧B：0/1 权图 → 01-BFS**  
  比 Dijkstra 快，比 SPFA 稳。
- **技巧C：二维坐标转一维 ID**  
  `id = (x-1)*cnty + y`，减少多维数组越界风险。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
| --- | --- | --- | --- | --- |
| **暴力 BFS** | 直接在大坐标 BFS，每步判穿边 | 思路直观 | 坐标 1e9 → MLE/TLE | 0% |
| **离散化 + SPFA** | D_14134 方案 | 易写，通用 | SPFA 最坏 O(VE) | 100% |
| **离散化 + 01-BFS** | litble 方案 | 最优 O(V+E) | 需手写 0/1 队列 | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（litble 版 01-BFS）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 205, INF = 0x3f3f3f3f;
int n, bx[N], by[N], bxCnt, byCnt;
int sx, sy, tx, ty;
bool visx[N][N], visy[N][N];   // visx[i][j]: 竖直线 x=i, y=j~j+1 是否为磁场边
int dis[N][N];
int dx[4] = {-1, 1, 0, 0};
int dy[4] = {0, 0, -1, 1};

int compress(int *a, int &cnt) {
    sort(a + 1, a + cnt + 1);
    cnt = unique(a + 1, a + cnt + 1) - (a + 1);
    return cnt;
}
int getPos(int *a, int cnt, int v) {
    return lower_bound(a + 1, a + cnt + 1, v) - a;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    bx[++bxCnt] = sx; bx[++bxCnt] = tx;
    by[++byCnt] = sy; by[++byCnt] = ty;
    for (int i = 1, x, y, c; i <= n; ++i) {
        cin >> x >> y >> c;
        bx[++bxCnt] = x; bx[++bxCnt] = x + c;
        by[++byCnt] = y; by[++byCnt] = y + c;
    }
    // 离散化并保留空白
    compress(bx, bxCnt);
    compress(by, byCnt);
    for (int i = 2; i <= bxCnt; ++i) if (bx[i] - bx[i - 1] > 1) bx[++bxCnt] = bx[i] - 1;
    for (int i = 2; i <= byCnt; ++i) if (by[i] - by[i - 1] > 1) by[++byCnt] = by[i] - 1;
    compress(bx, bxCnt);
    compress(by, byCnt);

    // 标记磁场边
    for (int i = 1, x1, x2, y1, y2; i <= n; ++i) {
        x1 = getPos(bx, bxCnt, bx[i*2-1]);
        x2 = getPos(bx, bxCnt, bx[i*2]);
        y1 = getPos(by, byCnt, by[i*2-1]);
        y2 = getPos(by, byCnt, by[i*2]);
        for (int j = x1; j < x2; ++j) visy[j][y1] = visy[j][y2] = true;
        for (int j = y1; j < y2; ++j) visx[x1][j] = visx[x2][j] = true;
    }

    // 01-BFS
    deque<pair<int,int>> q;
    memset(dis, 0x3f, sizeof(dis));
    sx = getPos(bx, bxCnt, sx);
    sy = getPos(by, byCnt, sy);
    tx = getPos(bx, bxCnt, tx);
    ty = getPos(by, byCnt, ty);
    dis[sx][sy] = 0;
    q.emplace_front(sx, sy);
    while (!q.empty()) {
        auto [x, y] = q.front(); q.pop_front();
        for (int dir = 0; dir < 4; ++dir) {
            int nx = x + dx[dir], ny = y + dy[dir];
            if (nx < 1 || nx > bxCnt || ny < 1 || ny > byCnt) continue;
            int cost = (dir < 2 ? visx[min(x,nx)][y] : visy[x][min(y,ny)]);
            if (dis[nx][ny] > dis[x][y] + cost) {
                dis[nx][ny] = dis[x][y] + cost;
                if (cost == 0) q.emplace_front(nx, ny);
                else q.emplace_back(nx, ny);
            }
        }
    }
    cout << dis[tx][ty] << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**主题**：「像素探险家」穿越磁场  
**核心**：01-BFS 如何一步步 0/1 边权地找到最少穿越次数

### 像素 UI 设计
- 8×8 像素方块表示离散化后的小格
- 磁场边用红色闪电 ⚡ 像素动画
- 机器人用绿色小方块，终点用金色宝箱 🎁
- 控制面板：开始/暂停/单步/速度滑块

### 动画帧步骤
1. **离散化网格**  
   像素化坐标轴，闪现所有关键坐标线。
2. **建图**  
   相邻格子若被磁场边隔开 → 闪现红色闪电并标记边权 1。
3. **01-BFS**  
   - 0 权边：机器人瞬移（绿色轨迹）  
   - 1 权边：机器人“跳”过红色闪电，计数器 +1  
   双端队列用左右像素管道展示 0/1 入队顺序。
4. **成功**  
   到达宝箱，播放 8-bit victory 音效，像素礼花 🎉

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**  
离散化 + 0/1 BFS 适用于：
- 大坐标障碍迷宫最短步数
- 激光网格反射最小镜面数
- 大矩形切割最少刀数

**洛谷推荐**
1. **P1525** 关押罪犯  
   把“冲突”看作 0/1 边权，二分 + 0/1 BFS 判定。
2. **P2046** 海拔  
   大网格 + 相邻边权 0/1，正解 0/1 BFS。
3. **P2886** 最短路径2  
   离散化 + 最短路练手。

---

## 7. 学习心得与经验分享

- **D_14134**：  
  “离散化时记得加 ±∞ 边界，否则起点在磁场外会失联！”  
- **litble**：  
  “0/1 BFS 模板背下来，遇到 0/1 权图直接秒。”

---

> 穿越磁场之旅结束！掌握离散化 + 01-BFS，你就能把“无限平面”装进“有限网格”，用最少“闪电跳跃”收获宝箱！下次探险见！

---
处理用时：97.82秒
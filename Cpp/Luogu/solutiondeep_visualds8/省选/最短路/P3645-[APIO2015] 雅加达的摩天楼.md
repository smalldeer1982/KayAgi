# 题目信息

# [APIO2015] 雅加达的摩天楼

## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。


## 说明/提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$


## 样例 #1

### 输入

```
5 3
0 2
1 1
4 1```

### 输出

```
5```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：雅加达的摩天楼 深入学习指南 💡

> 今天我们一起走进“雅加达的摩天楼”。这道题看上去像最短路，却又藏着“跳跃能力”这一特殊规则；看上去像暴力枚举，却又必须巧妙剪枝才能跑得过大数据。让我们像侦探一样，从题面里把线索一条条揪出来！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
**在 N 座摩天楼组成的直线上，让 0 号 doge 把消息以最少的跳跃步数送到 1 号 doge。难点在于：每只 doge 只能以固定步长 P_i 左右跳跃，且可以在同一座楼“接力”给别的 doge。**

✨ **核心算法标签**：**最短路 / BFS / 分层图 / 根号分治**

🗣️ **初步分析**  
- 最朴素的想法：把每只 doge 能跳到的所有点全部连边，然后跑 Dijkstra。但 N=3×10⁴ 时，边数 O(N²) 直接爆炸。  
- 于是出现两大流派：  
  1. **状态 BFS**：把“当前在哪座楼 + 当前 doge 的跳跃能力”视为状态，根号分治后状态数降至 O((N+M)√N)。  
  2. **分层图最短路**：给“步长”这一维度专门建一层虚拟节点，边数也被根号分治优化到 O(N√N)。  

> 想象一下：  
> 把“跳跃能力”看成一把尺子。尺子短（≤√N）时，我们干脆给每种长度盖一条“空中走廊”；尺子长（>√N）时，反正跳不了几下，就暴力连边。两条路互补，总工程量就被压下来了！

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1（问题目标）**：求“最少跳跃步数”——经典最短路标志。  
2. **线索2（特殊移动规则）**：只能以固定步长 P_i 跳跃——暗示需要“按步长分层”或“状态带步长”。  
3. **线索3（数据规模）**：N ≤ 3×10⁴ → O(N²) 不可行，O(N√N) 可行，提示根号分治。

### 🧠 思维链构建：从线索到策略
> 1. 看到“最少步数”，我首先想到最短路。  
> 2. 但直接建图边数爆炸 → 需要剪枝。  
> 3. 发现步长是关键：  
>    • 步长小：可以预处理“等差走廊”，边数可控。  
>    • 步长大：暴力连边，但最多 √N 条。  
> 4. 于是决定 **“根号分治 + 分层图”** 双剑合璧！

---

## 2. 精选优质题解参考

### 题解一：浮尘ii（58赞）——**状态 BFS 极简实现**
> 这份题解把“当前楼号 + 当前步长”当成状态，直接用 `bitset` 判重，代码短、思路清晰。  
> **亮点**：  
> - 用 `std::bitset<N> vis[N]` 压缩状态，空间 O(N²/w) ≈ 11 MB。  
> - 边转移边插入同楼的其他 doge，保证“接力”正确。  
> - 时间复杂度 O((N+M)√N)，轻松通过。

### 题解二：StudyingFather（25赞）——**严谨的分层图 + 根号分治**
> 提供数学推导：当分界点 k = √(N/3) 时总边数最小 2N√(3N)。  
> **亮点**：  
> - 将“步长 ≤ k”建成 k 层虚拟节点，每层内部左右连边权 1。  
> - 步长 > k 直接暴力连边，边数 ≤ N²/k。  
> - 使用 Dijkstra + 邻接表，实现稳健。

### 题解三：GoldenPotato137（14赞）——**图文并茂的分层图教程**
> 用像素级示意图解释“拆点”思想，把抽象的分层图可视化，帮助初学者快速理解。  
> **亮点**：  
> - 代码中 `size = min(100, √N)` 的“玄学”在后续题解被证明就是 √(N/3)。  
> - 用 vector 存边，SPFA 跑最短路，常数优化到位。

（其余题解同样优秀，因篇幅限制不一一展开。）

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以分层图为例）
1. **关键点1：如何减少边数？**  
   - **分析**：把“步长”维度拆出去。步长 ≤ k 的，在 k 层“虚图”里左右连边；步长 > k 的，直接暴力连。  
   - 💡 **学习笔记**：根号分治 = “小数据预处理 + 大数据暴力”，两边互补。

2. **关键点2：如何定义节点编号？**  
   - **分析**：常用 `id(pos, p) = p*N + pos` 或 `pos*size + p`，避免冲突。  
   - 💡 **学习笔记**：分层图编号要一眼看出“哪一层 + 哪个原位置”。

3. **关键点3：如何高效跑最短路？**  
   - **分析**：边权只有 0/1 → 可用 0-1 BFS（双端队列），或 Dijkstra + 堆优化。  
   - 💡 **学习笔记**：0-1 BFS 复杂度 O(V+E)，常数更小。

### ✨ 解题技巧总结
- **技巧A：根号分治**——遇到“数值大/小表现不同”的维度，用 √N 切一刀。  
- **技巧B：分层图**——把“附加属性”拉成新维度，边数从 O(N²) 降到 O(N√N)。  
- **技巧C：bitset 判重**——状态量巨大但稀疏时，用 bitset 压缩 32/64 倍空间。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用/得分 |
|---|---|---|---|---|
| 暴力连边 | 全图 O(N²) | 思路直观 | 时空爆炸 | N≤200 部分分 |
| 状态 BFS | (楼,步长) 为状态 | 代码最短 | bitset 空间 11 MB | 100% |
| 分层图 | 虚点 + 根号分治 | 理论优美 | 节点数 3N√N | 100% |

### ✨ 优化之旅
> 从“暴力 O(N²)”到“根号分治 O(N√N)”：  
> 1. 发现边数瓶颈在“步长”维度；  
> 2. 用 √N 把步长切成两半，分别用“走廊”和“暴力”处理；  
> 3. 总工程量骤减，成功通关！

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（状态 BFS 版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 30005;
vector<int> doge[N];
bitset<N> vis[N];
bool visPos[N];
int n, m, S, T;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 0, b, p; i < m; ++i) {
        cin >> b >> p;
        if (i == 0) S = b;
        if (i == 1) T = b;
        doge[b].push_back(p);
    }
    if (S == T) return cout << 0, 0;

    deque<tuple<int,int,int>> q;  // (pos, jump, step)
    visPos[S] = true;
    for (int p : doge[S]) if (!vis[S][p])
        vis[S].set(p), q.emplace_back(S, p, 0);

    while (!q.empty()) {
        auto [pos, jump, step] = q.front(); q.pop_front();
        int nxt;
        nxt = pos - jump;
        if (nxt == T || nxt + jump == T) return cout << step + 1, 0;
        if (nxt >= 0 && !vis[nxt][jump]) {
            vis[nxt].set(jump);
            if (!visPos[nxt]) {
                visPos[nxt] = true;
                for (int p : doge[nxt]) if (!vis[nxt][p])
                    vis[nxt].set(p), q.emplace_front(nxt, p, step + 1);
            }
            q.emplace_back(nxt, jump, step + 1);
        }
        nxt = pos + jump;
        if (nxt < n && !vis[nxt][jump]) {
            vis[nxt].set(jump);
            if (!visPos[nxt]) {
                visPos[nxt] = true;
                for (int p : doge[nxt]) if (!vis[nxt][p])
                    vis[nxt].set(p), q.emplace_front(nxt, p, step + 1);
            }
            q.emplace_back(nxt, jump, step + 1);
        }
    }
    cout << -1;
    return 0;
}
```
- **代码解读概要**：  
  用 `bitset` 记录“某个位置是否已用过某个步长”。首次到达一座楼时，把楼内所有 doge 的步长加入队列（0 步交换），再正常左右跳（1 步）。双端队列保证 0 步在前，1 步在后，实现 0-1 BFS。

---

## 5. 算法可视化：像素动画演示

- **演示主题**：《像素狗仔传信大冒险》  
- **核心内容**：在 8×8 的复古像素城里，演示“步长=2”时如何借助“空中走廊”节省边数。  
- **设计思路**：  
  - 楼用灰色方块，doge 用像素狗头。  
  - 步长 ≤ √N 时，生成一条“蓝色空中走廊”，每格一步。  
  - 步长 > √N 时，红色箭头暴力连边，箭头长度=跳跃次数。  
  - 消息传递时，像素狗头闪烁并播放“叮”音效；到达终点播放 8 位胜利音阶。  
- **交互面板**：  
  - 步进 / 自动播放 / 调速滑块  
  - 单步信息气泡：“doge 0 在楼 4，步长 2 → 跳向楼 2，步数 +1”  
- **技术提示**：Canvas 画网格 + `requestAnimationFrame` 控制帧率；音效用 Web Audio API 生成 8 位方波。

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**  
  1. **课程表冲突**：把“同一时段只能选一门课”变成“每组只能选一个”的分组背包。  
  2. **地铁换乘**：把“不同线路的换乘时间”分层建图，求最少换乘。  
  3. **跳跃游戏**：限制每次跳固定长度，求最少跳到终点。

- **洛谷推荐**  
  1. **P3953** [NOIP2017 跳房子] —— 同样是“固定步长跳跃”，可用二分 + 分层图。  
  2. **P4568** [JLOI2011 飞行路线] —— 分层图最短路经典题。  
  3. **P2662** [NOIP2015 斗地主] —— 根号分治 + 状态压缩。

---

## 7. 学习心得与经验分享

- **浮尘ii**：“原题数据水，但 UOJ Extra Test 很毒瘤，用 bitset 才稳。”  
  > 洛语云笺点评：bitset 在 OJ 评测机 64 位环境下天然提速 64 倍，是“空间换时间”的利器。

- **TopCarry**：“分块大小别迷信 √N，实际取 √(N/3) 才是真·最优。”  
  > 洛语云笺点评：数学推导 + 实验验证，才是竞赛中的“黄金组合”。

---

<conclusion>
恭喜完成本次“雅加达的摩天楼”深度解析！记住：  
- 看到“步长/倍数”先想根号分治；  
- 看到“维度爆炸”先想分层图；  
- 看到“稀疏状态”别忘了 bitset。  
下次探险见！💪
```

---
处理用时：96.87秒
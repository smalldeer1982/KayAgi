# 题目信息

# 抓捕

## 题目背景

@葛军  原创

古桥文乃作为一名OIer，每天勤奋地在洛谷上刷题，然而她的父母却认为他有网瘾，就将她送到了杨叫兽的网戒中心。

![](https://cdn.luogu.com.cn/upload/pic/41018.png )

一年之后，凭借不懈地努力古桥文乃终于逃了出来，并且立刻向警察蜀黍举报杨叫兽的所作所为，了解情况后警察请她带路去网戒中心抓捕杨叫兽。

## 题目描述

啊~~~~！

他们刚到达网戒中心就听到惨叫声从里面传来。古桥文乃在网戒中心呆了一年，对里面的情况很熟悉，立马就知道杨叔又在13号治疗室“点现钱”。同时，她知道网戒中心有$n$个房间，任意房间都有走廊相连，每个走廊和房间之间都有门，门是向外锁上的，且在开启后会自动锁上（即每次从房间$i$进入任意一个与其相连的走廊需要花费$c_i$的体力开锁，而从走廊进入房间不用耗费体力）。

杨叔为了防止“盟友”逃跑，在每个房间安装了摄像头，安排了$n$个手下在监控中心看着监控。

**特别的，1号房间为监控中心，1号手下负责防止任何人（除了杨叔）进入监控中心（否则立刻报告给杨叔）**，

其余的2号到$n$号手下每人负责监控编号是自己整数倍的房间（例如$n=10$时2号手下监控2号，4号，6号，8号，10号房间），13号治疗室也按照此规则被监控，如果他们其中一个人看到同一个人两次，就会向杨叔报告（但是每一个手下不会互相交流信息），好在这些手下都四肢发达头脑简单，只能记得上一秒的事情。

为了保证抓捕的顺利，古桥文乃和警察不能被发现，现在他们在$x$号房间，13号治疗室在$y$号房间，已知他们通过每一条走廊要1秒，开锁和通过房间不用花费时间（但会被监控室的手下看到），古桥文乃和警察想知道他们在不被发现的情况下最少要花费多少体力才能进入13号治疗室。

## 说明/提示

2->3->4

对于30%的数据，$n$<=$1500$，$T$<=$15$；

对于50%的数据，$n$<=$2500$，$T$<=$30$；

对于70%的数据，$n$<=$4500$，$T$<=$50$；

对于100%的数据，$n$<=$4500$，$T$<=$200$，$2$<=$x$,$y$<=$n$，$c_i$<=$9900$

## 样例 #1

### 输入

```
1
5
2 4
1 2 3 4 5```

### 输出

```
5```

# AI分析结果

# 💡 洛语云笺的C++算法解析：抓捕 深入学习指南 💡

> 各位小侦探，欢迎来到“网戒中心逃脱”大作战！今天我们要帮古桥文乃和警察蜀黍在不被发现的情况下，找到一条体力耗费最少的路径潜入13号治疗室。这不仅是一次最短路探险，更是一次“如何从复杂题面里挖出算法信号”的实战演练。让我们戴上侦探帽，开始吧！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> 核心挑战：**在“互质”规则限制下，求带“点权”的最短路径**。  
> 关键词：**互质建图**、**点权转边权**、**Dijkstra优化**。

### ✨ 核心算法标签
- **最短路**（Dijkstra / Heap-Dijkstra）
- **图论建图**（互质连边）
- **剪枝优化**（提前终止 / 优先队列状态设计）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 侦探笔记 | 信号解读 |
|---|---|---|
| **线索1：移动规则** | “每次必须去与本点互质的点” | 建图时只连 `gcd(u,v)==1` 的边。 |
| **线索2：代价来源** | “从房间i进入走廊花费c_i体力” | **点权模型**：把“出点代价”视为从该点出发的所有边的统一边权。 |
| **线索3：数据规模** | n≤4500，T≤200 | 暴力建边 O(n²)≈1×10⁷ 条边，可接受；但 Dijkstra 需 O(m log n)≈1×10⁸，需优化常数或剪枝。 |

---

### 🧠 思维链构建：从线索到策略

> 1. **发现规则**：互质才能走 → 先预处理一张“互质图”。  
> 2. **转换代价**：出房间才花钱 → 把点权 `c[i]` 当成“从i出发的所有边的边权”。  
> 3. **选择算法**：  
>    - 暴力 BFS/DFS？→ 每条边权不同，无法使用。  
>    - 普通 Dijkstra？→ 建完全图边太多。  
>    - **优化 Dijkstra**：利用“第一次到达即为最优”的性质，提前终止；或在优先队列里直接存“到达该点的总代价+下一步边权”，避免重复松弛。  
> 4. **结论**：**“点权化边权 + 剪枝 Dijkstra”** 是最优雅且高效的路径！

---

## 2. 精选优质题解参考

> 以下题解均 ≥4 星，思路清晰、代码规范，且从不同角度给出优化技巧。

### 题解一：STA_Morlin（赞：16）
- **亮点**：  
  简洁地指出“互质建图 + 点权边权化”，并在 Dijkstra 中将 `dis[v] = x` 直接赋值而非松弛，利用“第一次即最优”性质，实现 **O(1) 松弛**，代码短而高效。
- **核心技巧**：  
  在优先队列中存 `dis[u] + c[u]`，弹出时直接作为 `v` 的最短路，省去 `if (dis[v] > dis[u] + w)` 判断。

---

### 题解二：GalwayGirl（赞：10）
- **亮点**：  
  用图文并茂的方式解释“边权相同等价于点权提前累加”，给出清晰的 **等价模型转换** 思路。  
- **代码技巧**：  
  链式前向星存图 + 提前终止：一旦 `v == T` 立即输出并 `return`，平均常数极低。

---

### 题解三：GOD_hj & Morpheuse（赞：9+）
- **亮点**：  
  深入剖析 **Dijkstra 贪心正确性**，证明“第一次到达即为最短”在本题成立，帮助学习者真正理解算法而非背板。
- **代码技巧**：  
  手写优先队列（小根堆）+ 快读，极致卡常，适合竞赛实战。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 互质建图** | 预处理所有 `gcd(i,j)==1` 的无向边。 | 用 `__gcd` 或欧拉筛加速，复杂度 O(n² log n)。 |
| **2. 点权→边权** | 把“离开u的代价”视为所有从u出发边的边权。 | 在 Dijkstra 中把 `c[u]` 累加到优先队列关键字里。 |
| **3. 提前终止** | 由于边权非负，第一次从堆中弹出终点即为答案。 | 可在 `relax` 时 `if (v == T)` 直接输出并 `exit`，剪枝显著。 |

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 Dijkstra** | 建完全图后直接跑 | 思路直接 | m≈1e7，log 因子大，常数高 | 50% 数据 |
| **优化 Dijkstra** | 点权边权化 + 提前终止 | 常数极小，易写 | 需理解“第一次即最优” | 100% 数据 |
| **堆优化+剪枝** | 同上 + 手写堆 | 最快 | 代码稍长 | 竞赛 Rank1 |

---

### ✨ 解题技巧总结
- **问题转化**：把“出点代价”提前累加，等价转换模型。
- **剪枝技巧**：利用 Dijkstra 贪心性质，第一次到达终点即可退出。
- **常数优化**：手写小根堆、快读、链式前向星。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 来源：综合 GalwayGirl & GOD_hj 思路，简洁易读版。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 4505, M = N * N;
int head[N], to[M], nxt[M], c[N], dis[N], vis[N], tot, n, T;
void add(int u, int v) {
    to[++tot] = v, nxt[tot] = head[u], head[u] = tot;
}
int gcd(int a, int b) { return b ? gcd(b, a % b) : a; }
void dijkstra(int s, int t) {
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
    fill(dis, dis + n + 1, 0x3f3f3f3f);
    fill(vis, vis + n + 1, 0);
    dis[s] = 0;
    q.emplace(c[s], s);          // 关键：把出点代价放进来
    while (!q.empty()) {
        auto [val, u] = q.top(); q.pop();
        if (vis[u]) continue;
        vis[u] = 1;
        for (int i = head[u]; i; i = nxt[i]) {
            int v = to[i];
            if (dis[v] > val) {  // 直接赋值而非松弛
                dis[v] = val;
                if (v == t) { printf("%d\n", val); return; }
                q.emplace(val + c[v], v);
            }
        }
    }
    puts("-1");
}
int main() {
    scanf("%d%d", &T, &n);
    for (int i = 2; i <= n; ++i)
        for (int j = i + 1; j <= n; ++j)
            if (gcd(i, j) == 1) add(i, j), add(j, i);
    while (T--) {
        int s, t; scanf("%d%d", &s, &t);
        for (int i = 1; i <= n; ++i) scanf("%d", &c[i]);
        dijkstra(s, t);
    }
    return 0;
}
```

---

### 代码片段赏析（多解对照）

| 题解 | 亮点片段 | 解读 |
|---|---|---|
| STA_Morlin | `dis[v] = x; q.push(mp(dis[v] + G.dis[v], v));` | 直接赋值，省去松弛判断。 |
| _虹_ | `if(ans <= v) return;` | 全局 ans 剪枝，提前放弃无意义更新。 |
| GalwayGirl | `q.emplace(val + c[v], v);` | 将“点权”累加进关键字，实现等价边权。 |

---

## 5. 算法可视化：像素动画演示

### 主题：**“像素侦探”互质迷宫大冒险**
- **画布**：4500×1 像素长条（编号即坐标）。
- **颜色**：
  - 起点 🔵 蓝色像素，终点 🔴 红色像素。
  - 互质边 ✅ 绿色连线，非互质 ❌ 灰色。
  - 当前节点 🟡 黄色闪烁，已访问 🟢 绿色。
- **动画流程**：
  1. **建图阶段**：像素点快速连线，绿色光束表示互质边。
  2. **Dijkstra**：
     - 优先队列用像素堆栈表示，每次弹出最小值高亮。
     - 更新邻居时，黄色箭头指向，数值变化伴随“叮”音效。
  3. **提前终止**：一旦红色终点被染绿，播放 8 位胜利音效并定格。
- **交互**：单步 / 自动 / 调速滑块，右侧实时显示 `dis[i]` 数值条。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **点权化边权**：适用于“离开点才收费”的网络流、最短路模型。
- **互质建图**：数论与图论结合，如“欧拉路径互质版”。
- **第一次最优剪枝**：任何非负权最短路均可尝试提前终止。

### 洛谷推荐
1. **P4779**【模板】单源最短路径（标准版）  
   🗣️ 巩固 Dijkstra + 堆优化模板。
2. **P1529** 回家  
   🗣️ 同样是“点权”模型，练习转化与剪枝。
3. **P4568** 飞行路线  
   🗣️ 分层图最短路，体验更复杂的“状态+最短路”思想。

---

## 7. 学习心得与经验分享

> **STA_Morlin**：“本来想像卡暴力，结果构造比暴力还慢。”  
> **洛语云笺点评**：提醒我们——**优化前先测常数**，有时“笨办法”并不慢！

> **GalwayGirl**：“深入理解算法核心才能针对性优化。”  
> **洛语云笺点评**：背板子不如理解“第一次松弛即最优”的本质。

---

<conclusion>
今天的“抓捕”行动圆满结束！我们学会了如何把“互质”翻译成图，把“点权”藏进优先队列，并用一次优雅的剪枝让 Dijkstra 飞起来。下次遇到看似复杂的规则，不妨先当侦探找线索，再当工程师做优化。我们下道题再见！💪
</conclusion>

---
处理用时：92.99秒
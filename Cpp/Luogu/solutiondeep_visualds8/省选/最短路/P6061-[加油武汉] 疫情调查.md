# 题目信息

# [加油武汉] 疫情调查

## 题目描述

W 市爆发了严重的肺炎疫情。为了应对疫情，W 市需要对下属每一个社区进行巡回调查。

W市共有 $n$ 个街区，街区之间由 $m$ 条不相同的有向道路相连，没有任何一条道路是自己通向自己的，并且是保证弱联通的。通过每条道路需要消耗一定的燃油费用。

现在你需要派出一些工作人员来寻访每个街区。对于每个工作人员，你需要给他分派一些街区，之后工作人员会按照给定的顺序在这些街区反复循环，每周循环一次。请注意，工作人员只会检查你给他分配的街区，在分配的街区之间经过的街区，工作人员并不会下车。同时为了防止人员浪费，任何一个街区只能接受一位工作人员的检查。当然，如果必要，他也会经过重复的街区。

工作人员的花费是这样的：若是某个工作人员只分配到了一个街区 $u$，那么他需要每周消耗 $a_u$ 的停留费用。若是被分配到了多于一个的街区，那么他的花费就是环绕这些点一圈最后回到起点的道路燃油费用之和。

现在你需要知道，在工作人员数量无限的情况下，每周最少需要多少费用可以将整个 W 市完全巡查。

## 说明/提示

对于所有的数据 $1\leq n\leq 500,1\leq m\leq \min\{5000,n\times(n-1)\},0\leq a_i,w_i\leq 10^9$，保证图弱连通，无自环、无重边。

对于不同的测试点，我们有如下约束：

| 测试点编号 | $n\leq$ | $m\leq$ | 特殊性质 |
| :-: | :-: | :-: | :-: |
| $1\sim 6$ | $15$ | $100$ | $\times$ |
| $7\sim 10$ | $500$ | $5000$ | 对于所有的 $w_i=0$ |
| $11\sim 14$ | $500$ | $500$ | $n=m$ 且所有的节点出度为 $1$ |
| $15\sim 20$ | $500$ | $5000$ | $\times$ |

## 样例 #1

### 输入

```
3 3
30 25 30
1 2 3
2 3 5
3 1 10```

### 输出

```
18```

# AI分析结果

# 💡 洛语云笺的C++算法解析：疫情调查（最小环覆盖）深入学习指南 💡

> 今天我们来一起分析「疫情调查」这道 C++ 编程题。  
> 它的表面是“派工作人员巡查街区”，内核却是**“如何用若干环（或单点）覆盖整张有向图，使总费用最小”**。  
> 我们将学会把“覆盖”需求转化为**网络流 / 二分图匹配**模型，并对比 Floyd+KM、拆点费用流、上下界费用流三种主流策略，看看高手们是如何各显神通的！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
- **每个街区必须被“覆盖”一次且仅一次**  
- **覆盖方式有两种**  
  1. 让一名工作人员**只巡查这个街区** → 每周花费 `a[u]`。  
  2. 让一名工作人员**沿着一个环**（≥2 个点）反复巡查 → 每周花费环上道路燃油费之和。  
- **目标**：总费用最小。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
| --- | --- |
| **线索1：覆盖** | “覆盖所有点”暗示**匹配**或**流**模型。 |
| **线索2：环/单点** | 环等价于“首尾相接的路径”，可以拆成“入点→出点”匹配。 |
| **线索3：数据规模** | n≤500，O(n³) 可接受 → Floyd、KM、费用流都行。 |

### 🧠 思维链构建
> 1. 每个点必须被“匹配”一次。  
> 2. 若把点拆成“入点”“出点”，则**入点匹配出点** → 形成环或单点。  
> 3. 费用 = 环长或单点费 → 转化为**最小权完美匹配 / 最小费用最大流**。  
> 4. 复杂度 ≤ O(n³)，符合要求！  

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 洛语云笺点评 |
| --- | --- | --- |
| **绝顶我为峰** | **拆点 + 费用流 + 优化建图** | 先用 Dijkstra 代替 Floyd 避免 O(n³) 预处理；再把“最短路径”交给费用流自己找，边数降至 O(n+m)。代码简洁，实战最优。 |
| **zcysky 官方** | **二分图 + KM** | Floyd 求最短路后，直接跑 KM（最小权完美匹配）。思路最直观，但 Floyd 1.25e8 运算常数大，需要卡常。 |
| **junble19768** | **上下界无源汇最小费用流** | 把“每个点必须被经过一次”变成“下界 1”，再用经典上下界套路。概念清晰，代码通用。 |
| **功在不舍** | **SPFA 费用流 + 拆点** | 与绝顶我为峰思路类似，但用 SPFA 费用流，写 LLL/SLF 优化。讲解中对“如何舍弃不合法路径”给出了详细推导，值得细读。 |
| **清平乐 / Genius_Star / detect / Mortis_Vampire** | **Floyd + KM** 或 **费用流** | 不同作者给出不同实现细节：时间戳优化、Dijkstra 替换、宏定义等，可作为**代码风格与常数技巧**的素材库。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以最优拆点费用流为例）

1. **拆点建模**  
   - 每个点 `u` → 入点 `u`、出点 `u+n`。  
   - **入点** 只接受流量（被匹配），**出点** 只发出流量（去匹配）。  

2. **三类边**  
   - `s → u` 流量 1，费用 0（保证每个点被覆盖一次）。  
   - `u+n → t` 流量 1，费用 0（同上）。  
   - `u → u+n` 流量 ∞，费用 `a[u]`（选择单点覆盖）。  
   - `u+n → v` 流量 ∞，费用 `w[u][v]`（选择环上一步）。  
   - **反向边** 容量 0，费用相反。

3. **求最小费用最大流**  
   - 任何可行流都对应一种覆盖方案。  
   - 最小费用即答案。

💡 **学习笔记**  
- 拆点把“环覆盖”变成“匹配”是**网络流套路**之一。  
- 用 Dijkstra 费用流可避免 Floyd 的 O(n³) 瓶颈。

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| --- | --- | --- | --- | --- |
| **暴力枚举** | DFS 枚举子集 | 思路直接 | 2⁵⁰⁰ 爆炸 | n≤15 拿部分分 |
| **Floyd + KM** | 最短路矩阵 → 二分图最小权匹配 | 代码短 | O(n³) 卡常 | n≤500 可过 |
| **拆点费用流 (Dijkstra)** | 不预处理最短路，让费用流自己找 | 边少、常数小 | 需写费用流 | 正解，最稳健 |
| **上下界费用流** | 把“必须一次”变成下界 | 概念优雅 | 建图稍繁 | 通用性强 |

---

## 4. C++ 核心代码实现赏析

### 本题通用核心实现（拆点费用流版）

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

const int64 INF = 1e18;
struct Edge { int to, rev, cap; int64 cost; };
struct MCMF {
    int n;
    vector<vector<Edge>> g;
    vector<int64> dist;
    vector<int> preV, preE;
    MCMF(int n) : n(n), g(n) {}
    void addEdge(int fr, int to, int cap, int64 cost) {
        g[fr].push_back({to, (int)g[to].size(), cap, cost});
        g[to].push_back({fr, (int)g[fr].size() - 1, 0, -cost});
    }
    bool dijkstra(int s, int t) {
        dist.assign(n, INF);
        preV.assign(n, -1);
        preE.assign(n, -1);
        priority_queue<pair<int64,int>, vector<pair<int64,int>>, greater<>> pq;
        dist[s] = 0; pq.emplace(0, s);
        while (!pq.empty()) {
            auto [d,u] = pq.top(); pq.pop();
            if (d != dist[u]) continue;
            for (int i = 0; i < g[u].size(); ++i) {
                Edge &e = g[u][i];
                if (e.cap && dist[e.to] > dist[u] + e.cost) {
                    dist[e.to] = dist[u] + e.cost;
                    preV[e.to] = u;
                    preE[e.to] = i;
                    pq.emplace(dist[e.to], e.to);
                }
            }
        }
        return dist[t] < INF;
    }
    int64 minCost(int s, int t) {
        int64 totalCost = 0;
        while (dijkstra(s, t)) {
            int64 f = INF;
            for (int v = t; v != s; v = preV[v])
                f = min(f, (int64)g[preV[v]][preE[v]].cap);
            for (int v = t; v != s; v = preV[v]) {
                Edge &e = g[preV[v]][preE[v]];
                e.cap -= f;
                g[v][e.rev].cap += f;
                totalCost += e.cost * f;
            }
        }
        return totalCost;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int n, m;
    if (!(cin >> n >> m)) return 0;
    int s = 2 * n, t = 2 * n + 1;
    MCMF flow(2 * n + 2);
    for (int i = 1; i <= n; ++i) {
        int a; cin >> a;
        flow.addEdge(s, i - 1, 1, 0);
        flow.addEdge(i - 1 + n, t, 1, 0);
        flow.addEdge(i - 1, i - 1 + n, MCMF::g.size(), a);
    }
    for (int i = 0; i < m; ++i) {
        int u, v, w;
        cin >> u >> v >> w;
        flow.addEdge(u - 1, v - 1 + n, MCMF::g.size(), w);
    }
    cout << flow.minCost(s, t) << '\n';
    return 0;
}
```

**代码解读概要**  
- 使用**Dijkstra 费用流**模板，拆点 `0..n-1` 为入点，`n..2n-1` 为出点。  
- `s` 连所有入点，`t` 连所有出点，容量 1。  
- 每个点入→出：容量 ∞，费用 `a[i]`。  
- 原图边 `u→v`：入点 `u` → 出点 `v`，容量 ∞，费用 `w`。  
- 跑最小费用最大流即可。

---

## 5. 算法可视化：像素动画演示

### 主题
**“像素邮差”——在有向 8×8 像素城里送包裹**  
（对应费用流找最短路环）

### 场景设计
- 8 位像素 UI，每个街区 = 8×8 像素方块。  
- 入点为蓝色邮箱，出点为红色邮局。  
- 边权 = 道路颜色深浅（深 = 费用高）。  
- 流量流动 = 绿色像素邮差小人沿箭头移动。  
- **音效**：  
  - 邮差出发：8 位“叮”。  
  - 找到环：FC 经典“胜利音”。  
  - 单点覆盖：硬币音效。

### 交互流程
1. 点击“开始”，自动播放（或单步）。  
2. 每帧：  
   - 高亮当前增广路径（绿色像素路径闪烁）。  
   - 显示 `dist[]` 像素条。  
3. 完成后：  
   - 所有环用不同颜色像素圈出。  
   - 右上角弹“Total Cost = 18 coins”像素弹窗。

---

## 6. 拓展练习与相似问题思考

### 通用套路迁移
- **“拆点 + 费用流”** 适用于：  
  1. 最小路径覆盖（DAG）。  
  2. 骑士环游（有障碍棋盘）。  
  3. 任务调度带环依赖。

### 洛谷推荐
1. **P4016 负载平衡**  
   * 练上下界费用流。  
2. **P2764 最小路径覆盖**  
   * 经典 DAG 拆点费用流。  
3. **P3701 疫情控制加强版**  
   * 树形图环覆盖，需再建模。  
4. **P3358 最长 k 可重区间集**  
   * 费用流 + 离散化技巧。

---

## 7. 学习心得与经验分享

> 绝顶我为峰在 update 中两次修正建图错误，提醒我们：  
> **“网络流建模时，反向边费用负号千万别忘！”**  
> 功在不舍总结：  
> **“Floyd 500³ 常数大，能不用就不用；让费用流自己跑最短路更稳。”**

---

<conclusion>
疫情调查这道题，把“环覆盖”抽象成“匹配 + 费用”是一次漂亮的建模示范。  
掌握**拆点、费用流、KM**三板斧后，很多看似复杂的覆盖问题都能迎刃而解。  
继续加油，下一次像素冒险见！💪
</conclusion>

---
处理用时：91.48秒
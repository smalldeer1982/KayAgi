# 题目信息

# [NOI Online #1 入门组] 魔法

## 题目描述

C 国由 $n$ 座城市与 $m$ 条有向道路组成，城市与道路都从 $1$ 开始编号，经过 $i$ 号道路需要 $t_i$ 的费用。

现在你要从 $1$ 号城市出发去 $n$ 号城市，你可以施展最多 $k$ 次魔法，使得通过下一条道路时，需要的费用变为原来的相反数，即费用从 $t_i$ 变为 $-t_i$。请你算一算，你至少要花费多少费用才能完成这次旅程。

注意：使用魔法只是改变一次的花费，而不改变一条道路自身的 $t_i$；最终的费用可以为负，并且一个城市可以经过多次（包括 $n$ 号城市）。 

## 说明/提示

#### 输入输出样例 1 解释

依次经过 $1$ 号道路、$2$ 号道路、$3$ 号道路，并在经过 $1,2$ 号道路前使用魔法。 

#### 输入输出样例 2 解释

依次经过 $1$ 号道路、$2$ 号道路、$1$ 号道路，并在两次经过 $1$ 号道路前都使用魔法。 

#### 数据规模与约定

本题共 $20$ 个测试点，各测试点信息见下表。

| 测试点编号 | $n \leq$ | $m \leq$ | $k \leq$ | 无环 |
| :----------: | :--------: | :---------: | :--------: | :----: |
| $1 \sim 2$ | $5$ | $20$ | $0$ | 不保证 |
| $3 \sim 4$ | $10$ | $20$ | $50$ | 不保证 |
| $5 \sim 6$ | $10$ | $20$ | $0$| 不保证 |
| $7 \sim 8$ | $20$ | $200$ | $50$ | 是 |
| $9 \sim 10$ | $20$ | $200$ | $0$ | 不保证 |
| $11 \sim 12$ | $100$ | $200$ | $50$ | 是 |
| $13 \sim 14$ | $100$ | $200$ | $50$ | 不保证 |
| $15 \sim 18$ | $100$ | $2500$ | $1000$ | 不保证 |
| $19 \sim 20$ | $100$ | $2500$ | $10^6$ | 不保证 |

对于【无环】一栏为“是”的测试点，保证给出的图是一张有向无环图，否则不对图的形态做任何保证。

对于全部的测试点，保证：
- $1 \leq n \leq 100$，$1 \leq m \leq 2500$，$0 \leq k \leq 10^6$。
- $1 \leq u_i, v_i \leq n$，$1 \leq t_i \leq 10^9$。
- 给出的图无重边和自环，且至少存在一条能从 $1$ 到达 $n$ 的路径。

**民间数据使用 [CYaRon](https://github.com/luogu-dev/cyaron) 在 5 分钟内生成。如果发现数据有问题，请在讨论版发帖或私信 @[StudyingFather](/user/22030)**

## 样例 #1

### 输入

```
4 3 2
1 2 5
2 3 4
3 4 1
```

### 输出

```
-8```

## 样例 #2

### 输入

```
2 2 2
1 2 10
2 1 1
```

### 输出

```
-19```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：NOI Online #1 魔法 深入学习指南 💡

> 今天我们要拆解的，是一道“魔法”加持的最短路问题：如何在一张有向图中，通过最多 k 次“把下一条边的权值变负”的魔法，从 1 号城市跑到 n 号城市，让总花费最小。  
> 它不仅考察最短路，更考验我们“把问题抽象成矩阵”的想象力！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“魔法”让最短路模型瞬间拥有了 **负权边** 与 **次数限制** 两个变量——既要决定“哪几条边用魔法”，又要保证“魔法次数不超 k”。朴素的暴力枚举边集显然会爆炸。

✨ **核心算法标签**：  
最短路 + 动态规划 + 矩阵快速幂（广义矩阵乘法）

🗣️ **初步分析**  
- **k = 0**：裸最短路，Floyd/SPFA 即可。  
- **k ≤ 50**：分层图最短路（把“剩余魔法次数”当作额外维度）。  
- **k ≤ 1e6**：继续观察转移方程，发现它长得像 **矩阵乘法**！把“+”换成“min”，就能用 **矩阵快速幂** 在 O(n³ log k) 内解决。  
- **最终武器**：构造一个“一次性魔法矩阵”，再用快速幂把 k 次魔法“折叠”进 log k 步计算。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：“最小化总花费”，天然是最短路。  
2. **线索2 (问题约束)**：“最多用 k 次魔法” → 需要把“剩余次数”纳入状态。  
3. **线索3 (数据规模)**：n ≤ 100，k ≤ 1e6 → O(n³ log k) ≈ 2e7，完全可行；而 O(n²k) 会爆。  
4. **线索4 (转移形式)**：dp[i][j][k] = min(dp[i][t][k-1] + dp[t][j][1])，恰是“min-plus”矩阵乘法，满足结合律 → 快速幂！

### 🧠 思维链构建：从线索到策略
> “我”先想到分层图（把 k 当维度），但 k=1e6 时空间爆炸。  
> 再观察转移式：两段路拼起来，恰好是“min-plus”乘法。  
> 于是把“1 次魔法”做成矩阵 M，M^k 就是 k 次魔法答案。  
> 最后用矩阵快速幂把 k 压缩到 log k，优雅 AC！

---

## 2. 精选优质题解参考

**题解一：gaozitao1（综合 100 分思路）**  
* **点评**：从 30→50→70→90→100 的阶梯式讲解非常友好；矩阵快速幂的推导基于“min-plus”乘法，逻辑严谨；完整代码可直接复用。  
* **亮点**：用 Floyd 预处理无魔法/一次魔法矩阵，再用 qp(M,k) 得到答案，思路清晰。

**题解二：StudyingFather（矩阵建模）**  
* **点评**：用“min-plus”矩阵乘法统一 k=0,1,2… 的转移，证明结合律，简洁有力；代码模块化好。  
* **亮点**：矩阵重载函数 `operator*` 直观体现“min-plus”乘法。

**题解三：wsyhb（O(nm) 初始化优化）**  
* **点评**：指出传统 O(n²m) 枚举边初始化可降到 O(nm)，通过只更新“以 u 或 v 为端点”的矩阵行列，实现常数级加速。  
* **亮点**：给出优化后的矩阵构造方法，实战价值高。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解：矩阵快速幂）
1. **关键点1：构造“一次魔法矩阵”G₁**  
   - **分析**：先用 Floyd 求出无魔法最短路 dis。  
     对每条边 (u,v,w)，令 G₁[i][j] = min(dis[i][j], dis[i][u] - w + dis[v][j])。  
   - 💡 **学习笔记**：把“在某条边用一次魔法”的贡献一次性压进矩阵，后续只需矩阵乘法即可。

2. **关键点2：广义矩阵乘法与快速幂**  
   - **分析**：定义 C = A * B 为 C[i][j] = min_k (A[i][k] + B[k][j])。  
     该运算满足结合律，故可用快速幂把 k 次魔法压缩到 log k 次乘法。  
   - 💡 **学习笔记**：矩阵快速幂不仅能做“路径计数”，也能做“路径最小值”。

3. **关键点3：边界与常数优化**  
   - **分析**：k=0 特判；矩阵初值设为 ∞；使用 0-index 减少数组偏移。  
   - 💡 **学习笔记**：∞ 必须足够大（≥ 1e18），防止加法溢出。

### ✨ 解题技巧总结
- **技巧A：min-plus 矩阵乘法**  
  把“最短路”问题转化为“矩阵乘法”问题，从而使用快速幂降维打击。  
- **技巧B：枚举边更新矩阵行列**  
  用 O(nm) 而非 O(n²m) 构造 G₁，常数减半。  
- **技巧C：Floyd 预最短路**  
  小 n 场景下，Floyd 代码短、思维简单，是首选。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- | :--- |
| **Floyd (k=0)** | 三重循环求所有点对最短路 | 代码极短 | 无法处理魔法 | 30 分 |
| **分层图 Dijkstra** | 把“剩余魔法次数”当维度 | 思路直观 | 空间 O(n²k) 爆内存 | k ≤ 50 可拿 70 分 |
| **矩阵快速幂** | 把“一次魔法”压成矩阵，快速幂乘 k 次 | O(n³ log k) 稳过 1e6 | 需理解广义矩阵乘法 | 100 分正解 |

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**  
* **说明**：综合 StudyingFather & wsyhb 思路，给出简洁、高效、可直接提交的核心实现。  
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 105;
const ll INF = 1e18;

struct Mat {
    ll a[N][N];
    Mat() { for (int i = 0; i < N; ++i) fill(a[i], a[i] + N, INF); }
    ll* operator[](int x) { return a[x]; }
    Mat operator*(const Mat& B) const {
        Mat C;
        for (int k = 1; k <= n; ++k)
            for (int i = 1; i <= n; ++i)
                for (int j = 1; j <= n; ++j)
                    C[i][j] = min(C[i][j], a[i][k] + B.a[k][j]);
        return C;
    }
} G0, G1, ans;

int n, m, k;
ll dis[N][N];

void floyd() {
    for (int k = 1; k <= n; ++k)
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j)
                dis[i][j] = min(dis[i][j], dis[i][k] + dis[k][j]);
}

Mat qp(Mat A, int p) {
    Mat res; for (int i = 1; i <= n; ++i) res[i][i] = 0;
    while (p) {
        if (p & 1) res = res * A;
        A = A * A;
        p >>= 1;
    }
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> k;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            dis[i][j] = (i == j ? 0 : INF);

    vector<int> u(m + 1), v(m + 1), w(m + 1);
    for (int i = 1; i <= m; ++i) {
        cin >> u[i] >> v[i] >> w[i];
        dis[u[i]][v[i]] = w[i];
    }

    floyd();               // G0 = 无魔法最短路
    if (k == 0) return cout << dis[1][n] << '\n', 0;

    // 构造 G1：至多一次魔法
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            G1[i][j] = dis[i][j];

    for (int e = 1; e <= m; ++e) {
        int a = u[e], b = v[e], c = w[e];
        for (int i = 1; i <= n; ++i)
            for (int j = 1; j <= n; ++j)
                G1[i][j] = min(G1[i][j], dis[i][a] - c + dis[b][j]);
    }

    ans = qp(G1, k);
    cout << ans[1][n] << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**主题**：**“像素探险家”在 8×8 网格里寻找魔法最短路径**  
**目标**：直观展示“min-plus 矩阵快速幂”如何一步步把 k 次魔法压缩到 log k 步。

### 设计思路
- **8 位像素风**：用 16 色调色板，城市画成像素小屋，边权用小数字方块。  
- **矩阵乘法动画**：  
  1. 屏幕左侧显示 8×8 的“无魔法矩阵”G₀，右侧显示“一次魔法矩阵”G₁。  
  2. 每次快速幂迭代，像素箭头指示正在计算的 (i,k,j) 三元组；绿色高亮“min”结果。  
  3. 伴随“叮”音效表示一次乘法完成，log k 步后终点像素小屋闪金光。  
- **交互**：  
  - 步进 / 自动播放 / 调速滑块。  
  - 右上角实时显示当前矩阵的 (1,n) 值。  
- **游戏化**：把 log k 次乘法拆成“关卡”，每过一关出现像素礼花。

### 技术实现要点
- Canvas 绘制 8×8 像素网格，每个格子 20×20 px。  
- 关键帧伪代码：
```js
for step = 0..logK-1:
  for i,k,j in triple loop:
    highlight(i,k,j)
    playSound('ding')
    setPixel(i,j, newVal)
```
- 背景音乐：8 位 chiptune 循环 60 BPM。

---

## 6. 拓展练习与相似问题思考

**通用技巧迁移**  
min-plus 矩阵快速幂可解决：  
1. **恰好/至多 k 步的最短路**（本题）。  
2. **恰好 k 步的可达性/路径计数**（把 min 换成 +）。  
3. **带折扣的最短路**（每次折扣系数固定，可写成矩阵乘法）。

**洛谷推荐**  
1. **P2886 [USACO07NOV] Roadblocks G**  
   🗣️ 双倍经验：需要求严格次短路，同样可用最短路矩阵思想。  
2. **P2158 [SDOI2008] 仪仗队**  
   🗣️ 矩阵快速幂求路径数，体会“加法→乘法”的变形。  
3. **P4159 [SCOI2009] 迷路**  
   🗣️ 恰好 k 步到达，把边拆点后用矩阵快速幂。

---

## 7. 学习心得与经验分享

> **来自 gaozitao1**：“把 dp 方程写成矩阵乘法，是 NOI 系列题常用的 trick。多画图、多手算，才能把抽象的矩阵和图论联系起来。”  
> **点评**：矩阵快速幂的“min-plus”版本并不常见，动手推导一次，收获巨大。

> **来自 wsyhb**：“初始化矩阵时，枚举边而不是枚举点对，可把常数从 n²m 降到 nm。”  
> **点评**：小优化往往决定能否跑进时限，养成“常数意识”。

---

<conclusion>
恭喜你读到这里！从 Floyd 到矩阵快速幂，我们完成了一次“维度压缩”的魔法之旅。记住：  
- 当“次数”巨大时，寻找可结合的运算 → 快速幂。  
- 把“边魔法”一次性压进矩阵，是化繁为简的关键。  
下次遇到“k 次操作”类题目，别忘了今天学到的 **min-plus 矩阵快速幂**！
</conclusion>

---
处理用时：112.65秒
# 题目信息

# [THUPC 2023 初赛] 背包

## 题目描述

本题中，你需要解决完全背包问题。

有 $n$ 种物品，第 $i$ 种物品单个体积为 $v_i$、价值为 $c_i$。

$q$ 次询问，每次给出背包的容积 $V$，你需要选择若干个物品，每种物品可以选择任意多个（也可以不选），在选出物品的体积的和**恰好**为 $V$ 的前提下最大化选出物品的价值的和。你需要给出这个最大的价值和，或报告不存在体积和恰好为 $V$ 的方案。

为了体现你解决 NP-Hard 问题的能力，$V$ 会远大于 $v_i$，详见数据范围部分。

## 说明/提示

#### 样例解释 1

第二组询问的最优方案为：选择 $3$ 个物品 $1$ 和 $12499999998$ 个物品 $2$。

#### 子任务

对于所有测试数据，$1 \le n \le 50, 1 \le v_i \le 10^5, 1 \le c_i \le 10^6, 1 \le q \le 10^5, 10^{11} \le V \le 10^{12}$。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

## 样例 #1

### 输入

```
2 2
6 10
8 15
100000000001
100000000002
```

### 输出

```
-1
187500000000
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：THUPC 2023 初赛「背包」深入学习指南 💡

> 今天我们来一起分析 **“背包”** 这道来自 THUPC 2023 初赛的题目。  
> 这道题最迷人的地方在于：当背包容量大到“天文数字”级别时，我们该如何优雅地解决它？  
> 我们将像侦探一样，从题目中挖掘线索，一步步拆解出“同余最短路”这一高级技巧！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 背包容量 **V 高达 1e12**，物品体积却不超过 1e5。  
> 核心挑战是：**如何在巨大容量下，仍能保证总体积恰好为 V，并最大化价值？**

✨ **核心算法标签**：  
- 动态规划（DP）
- 同余最短路（Congruence Shortest Path）
- 贪心（Greedy）
- 完全背包（Unbounded Knapsack）

🗣️ **初步分析**：  
- 暴力 DP 显然不可行，因为 V 太大，无法开数组。  
- 观察到 V 远大于 v_i，这提示我们：**“大容量”可以被“小模数”分解**。  
- 因此，我们采用 **“同余最短路”** 的思想，将问题转化为 **模某个体积 m 意义下的最短/最长路问题**。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索编号 | 线索内容 | 关键洞察 |
|---|---|---|
| **线索1 (问题目标)** | 要求总体积 **恰好** 为 V，且最大化价值。 | 这是 **完全背包** 的变种，但 V 太大，无法直接 DP。 |
| **线索2 (数据范围)** | V ≥ 1e11，v_i ≤ 1e5。 | V 远大于 v_i，提示我们可以用 **同余类** 分解问题。 |
| **线索3 (贪心提示)** | 最优解一定大量采用 **性价比最高** 的物品。 | 可以设性价比最高的物品为“基准”，用同余最短路处理剩余部分。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，**线索1** 告诉我们这是完全背包问题，但 V 太大，无法直接 DP。  
> 2. **线索2** 提示我们：V 很大，但 v_i 很小，可以尝试 **模 v_i 的同余类**。  
> 3. **线索3** 进一步指出：最优解一定大量采用性价比最高的物品。  
> 4. **结论**：  
>   - 设性价比最高的物品体积为 m，价值为 w。  
>   - 将 V 分解为 **V = k·m + r**，其中 r = V mod m。  
>   - 问题转化为：在模 m 意义下，求 r 的最大价值增量。  
>   - 这正是 **同余最短路** 的经典模型！

---

## 2. 精选优质题解参考

### 题解一：Alex_Wei（赞：107）

> **点评**：  
> 这篇题解是目前最完整、最清晰的同余最短路教程。  
> 它不仅给出了理论推导，还提供了可直接套用的 **转圈法代码模板**。  
> 特别是“转两圈”技巧，避免了最短路算法，直接 O(nm) 解决！

---

### 题解二：Leasier（赞：7）

> **点评**：  
> 这篇题解从另一个角度切入：先用 SPFA 跑最长路，后来发现“转圈法”更优。  
> 它展示了 **从朴素到优化** 的完整思维过程，非常适合初学者理解。

---

### 题解三：船酱魔王（赞：2）

> **点评**：  
> 这篇题解用 **“幻想填充”** 的比喻，生动解释了为什么贪心+同余最短路可行。  
> 代码风格清晰，注释详细，适合直接学习。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **关键点1：选择基准物品** | 选择 **性价比最高** 的物品 (m, w) 作为基准。 | 贪心思想：最优解一定大量采用性价比最高的物品。 |
| **关键点2：同余建模** | 将问题转化为 **模 m 意义下的最长路问题**。 | 状态：f[r] 表示体积 ≡ r (mod m) 时的最大价值增量。 |
| **关键点3：转圈法优化** | 对每个物品，在模 m 的环上 **转两圈**，即可覆盖所有转移。 | 避免了 SPFA 的最坏 O(nm²) 复杂度，直接 O(nm)。 |

---

### ✨ 解题技巧总结

- **技巧A：贪心+同余分解**  
  当 V 远大于 v_i 时，先用贪心选基准，再用同余最短路处理剩余部分。

- **技巧B：转圈法**  
  对于每个物品，在模 m 的环上转两圈，即可覆盖所有转移，避免最短路算法。

- **技巧C：边界处理**  
  注意处理 **无解情况**（即 V mod gcd(v_i) ≠ 0）。

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 DP** | 直接完全背包 DP | 思路简单 | V 太大，无法存储 | 仅适用于 V ≤ 1e7 |
| **SPFA 最长路** | 建图跑最长路 | 思路直观 | 最坏 O(nm²)，可能被卡 | 小数据或 SPFA 不卡时 |
| **转圈法（最优）** | 模 m 意义下转圈转移 | O(nm)，稳定高效 | 需要理解同余建模 | 本题最佳策略 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. **起点：暴力 DP**  
>   - 直接完全背包 DP，但 V 太大，无法存储。
>
> 2. **发现瓶颈：V 太大**  
>   - 观察到 V 远大于 v_i，考虑同余分解。
>
> 3. **优化钥匙：同余最短路**  
>   - 用性价比最高的物品作为基准，将问题转化为模 m 意义下的最长路。
>
> 4. **模型升华：转圈法**  
>   - 用转圈法替代 SPFA，直接 O(nm) 解决，无需担心被卡。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

**说明**：  
本代码综合了 Alex_Wei 和 Leasier 的题解，采用 **转圈法** 实现同余最短路，时间复杂度 O(nm)。

**完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int MAXN = 55, MAXM = 1e5 + 5;
ll n, q, m = 1, w, v[MAXN], c[MAXN], f[MAXM];

int main() {
    ios::sync_with_stdio(0), cin.tie(0);
    cin >> n >> q;
    for (int i = 1; i <= n; ++i) {
        cin >> v[i] >> c[i];
        if (w * v[i] < m * c[i]) w = c[i], m = v[i];
    }
    fill(f, f + m, -1e18);
    f[0] = 0;
    for (int i = 1; i <= n; ++i) {
        int d = gcd(v[i], m);
        for (int j = 0; j < d; ++j) {
            for (int t = j, cnt = 0; cnt < 2; cnt += t == j) {
                int p = (t + v[i]) % m;
                f[p] = max(f[p], f[t] + c[i] - ((t + v[i]) / m) * w);
                t = p;
            }
        }
    }
    while (q--) {
        ll V; cin >> V;
        ll r = V % m;
        if (f[r] < -1e17) cout << "-1\n";
        else cout << f[r] + V / m * w << '\n';
    }
    return 0;
}
```

**代码解读概要**：
- 选择性价比最高的物品 (m, w) 作为基准。
- 用转圈法在模 m 意义下求最长路。
- 查询时，答案为 `f[V % m] + (V / m) * w`。

---

### 题解代码片段赏析（Alex_Wei）

**亮点**：  
- 用 `_v[i]` 和 `_d[i]` 预计算，避免重复取模和除法，常数优化极佳。

**核心代码片段**：
```cpp
for (int i = 1; i <= n; i++) _v[i] = v[i] % m, _d[i] = v[i] / m;
for (int i = 2; i <= n; i++) {
    for (int j = 0, lim = __gcd(v[i], m); j < lim; j++) {
        for (int t = j, c = 0; c < 2; c += t == j) {
            int p = t + _v[i];
            if (p >= m) p -= m;
            f[p] = max(f[p], f[t] + c[i] - _d[i] * w), t = p;
        }
    }
}
```

**学习笔记**：  
- 用 `__gcd` 和转圈法，简洁高效地实现了同余最短路。

---

## 5. 算法可视化：像素动画演示

### 动画主题：  
**“像素探险家”在模 m 的环形轨道上寻找最长路！**

### 核心演示内容：
- 用 8 位像素风格展示模 m 的环形轨道（0~m-1）。
- 每个物品用“像素飞船”表示，沿轨道飞行两圈，更新最长路值。
- 音效：每次更新 `f[r]` 时播放“叮”声，最终答案出现时播放胜利音效。

### 设计思路：
- **像素化轨道**：用 Canvas 绘制 m 个像素方块，形成环形。
- **飞船动画**：每个物品用不同颜色的飞船，沿轨道飞行两圈。
- **状态高亮**：当前更新的 `f[r]` 用闪烁高亮。
- **交互控制**：步进/自动播放按钮，速度滑块。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移：
- **同余最短路**适用于：  
  1. 大容量完全背包问题。  
  2. 需要“恰好”凑出某个数值的问题。  
  3. 存在“性价比”概念的贪心问题。

### 洛谷推荐练习：
1. **P2371 墨墨的等式**  
   - 🗣️ 推荐理由：同余最短路的经典入门题，学习转圈法模板。

2. **P3403 跳楼机**  
   - 🗣️ 推荐理由：01-BFS 优化同余最短路，理解不同优化技巧。

3. **P9140 背包**（本题）  
   - 🗣️ 推荐理由：完全背包+同余最短路，综合考察贪心与建模。

---

## 7. 学习心得与经验分享

> **Alex_Wei 的调试心得**：  
> “我在研究官方解法时，惊讶于其‘转两圈’思想的巧妙。翻遍了经典同余最短路题目，也没找到几篇除了 SPFA 和 Dijkstra 以外的题解，故分享给各位读者。”

**点评**：  
> 这提醒我们：  
> - 不要拘泥于传统最短路算法，**转圈法**更简洁高效。  
> - 多阅读题解，**逆向思考**问题结构，往往能找到更优解。

---

## 结语

今天我们一起拆解了 **“大容量完全背包”** 这一难题，学会了如何用 **同余最短路** 优雅解决。  
记住：当数据范围大到“离谱”时，不妨用 **同余类** 分解问题，再用 **贪心+转圈法** 优化！  
下次见，继续探索更多算法奥秘！

---
处理用时：78.29秒
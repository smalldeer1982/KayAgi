# 题目信息

# [SDOI2011] 拦截导弹

## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度、并且能够拦截任意速度的导弹，但是以后每一发炮弹都不能高于前一发的高度，其拦截的导弹的飞行速度也不能大于前一发。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

在不能拦截所有的导弹的情况下，我们当然要选择使国家损失最小、也就是拦截导弹的数量最多的方案。但是拦截导弹数量的最多的方案有可能有多个，如果有多个最优方案，那么我们会随机选取一个作为最终的拦截导弹行动蓝图。

我方间谍已经获取了所有敌军导弹的高度和速度，你的任务是计算出在执行上述决策时，每枚导弹被拦截掉的概率。


## 说明/提示



保证总方案数不超过 C++ 中 double 类型的存储范围。

### 数据范围及约定

- 均匀分布着约 $30\%$ 的数据，所有 $v_i$ 均相等；
- 均匀分布着约 $50\%$ 的数据，满足 $1\le h_i,v_i\le 1000$。
- 对于 $30\%$ 的数据，满足 $1\le n\le 1000$；
- 对于 $100\%$ 的数据，$1\le n\le 5\times 10^4$，$1\le h_i,v_i\le 10^9$。

### 评分标准

对于每个测试点，若输出的第一行与标准输出相同，则得到该测试点 $40\%$ 的分数，若输出文件的第二行的每个数与标准输出的误差均不大于 $10^{-4}$，则得到该测试点 $60\%$ 的分数，两项相加作为该测试点总得分。

## 样例 #1

### 输入

```
4
3 30
4 40
6 60
3 30
```

### 输出

```
2
0.33333 0.33333 0.33333 1.00000
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[SDOI2011] 拦截导弹 深入学习指南 💡

> 各位小小算法探险家们，欢迎来到今天的思维训练营！我们要一起拆解的，是 **“拦截导弹”** 这道融合了 **三维偏序** 与 **概率计算** 的经典难题。别担心，跟着洛语云笺的思路，你会发现它其实像一场精心设计的 **像素冒险游戏**，一步步揭开它神秘的面纱！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
“拦截导弹”的核心挑战在于：给定一系列导弹（每个导弹有高度 `h` 和速度 `v`，并按时间顺序给出），我们要找出 **最长的不上升子序列**（即拦截的导弹数量最多），并计算 **每枚导弹出现在任意一个最长方案中的概率**。

- **子序列规则**：拦截的导弹必须满足 **时间靠后** 的导弹，其 **高度不高于** 且 **速度不快于** 之前拦截的导弹。
- **概率计算**：如果有多个最长方案，每个方案被选中的概率均等，我们需要计算每枚导弹在这些方案中的 **出现概率**。

### ✨ 核心算法标签
- **动态规划 (DP)**：解决最长子序列问题。
- **三维偏序**：导弹有三个属性（时间 `t`，高度 `h`，速度 `v`），需同时满足 `t_i < t_j`, `h_i >= h_j`, `v_i >= v_j`。
- **CDQ分治**：优化三维偏序的DP，将复杂度从 `O(n^2)` 降到 `O(n log^2 n)`。
- **树状数组/线段树**：辅助CDQ分治，高效查询前缀最大值及方案数。
- **离散化**：处理 `h` 和 `v` 的大范围值。

### 🗣️ 初步分析
1. **暴力DP思路**：`O(n^2)` 的DP，对每个导弹，检查前面所有满足条件的导弹，更新最长序列长度和方案数。但 `n=5e4` 时，`O(n^2)` 会超时。
2. **优化思路**：利用 **CDQ分治** 将问题分解为子问题，结合 **树状数组** 维护前缀最大值和方案数，实现 **三维偏序** 的高效处理。
3. **概率计算**：通过 **正反两次DP**（正序求以导弹结尾的最长子序列，逆序求以导弹开头的最长子序列），结合乘法原理计算每枚导弹的贡献概率。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：题目要求 **“最长不上升子序列”** 和 **“概率”**，这暗示我们需要 **动态规划** 来计算最长长度，并 **统计方案数** 来计算概率。
2. **线索2 (问题约束/特性)**：导弹的拦截规则涉及 **三维偏序**（时间、高度、速度），这指向 **CDQ分治** 或 **树套树** 等高级数据结构。
3. **线索3 (数据规模)**：`n=5e4`，`O(n^2)` 不可行，`O(n log^2 n)` 的CDQ分治是理想选择。

### 🧠 思维链构建：从线索到策略
> “好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1. 首先，【线索1：问题目标】告诉我们这是一个 **‘最优化+概率统计’** 问题，我的大脑里立刻闪过了 **‘动态规划+方案数统计’**。
> 2. 接着，【线索2：问题特性】，比如 **‘三维偏序’**，给了我一个决定性的提示。简单的二维DP无法处理，需要 **‘CDQ分治’** 来降维打击。
> 3. 最后，【线索3：数据规模】给了我们最终判决。`n=5e4`，`O(n^2)` 绝对会超时（TLE）。而一个 **‘CDQ分治+树状数组’** 的 `O(n log^2 n)` 算法是完全可以接受的。
> 4. **结论**：综合以上，一个能够处理 **‘三维偏序’** 并求解 **‘最长子序列+概率’** 的高效算法，就是我们的目标。**CDQ分治**，特别是为处理这类多维偏序而设计的 **“分治+数据结构”** 模型，完美符合所有条件。这就是我们接下来要深入研究的主攻方向！”

---

## 2. 精选优质题解参考

> 经过严格筛选，以下题解在 **思路清晰度**、**代码规范性**、**算法有效性**、**解释易懂性** 和 **启发性** 上表现优异（≥4星），特此推荐！

### 题解一：hsfzLZH1（赞：60）
**点评**：这篇题解是 **CDQ分治** 的经典范例，作者详细阐述了如何将 **三维偏序** 问题转化为 **分治+树状数组** 的模型。代码实现严谨，特别是 **离散化** 和 **树状数组维护方案数** 的技巧，非常值得学习。

### 题解二：shadowice1984（赞：34）
**点评**：作者以 **“假 long long 害人！”** 的幽默开篇，强调了 **方案数需用double存储** 的重要性。其CDQ分治的实现简洁，通过 **反转序列** 复用同一套代码计算正逆DP，体现了高超的代码复用能力。

### 题解三：MCAdam（赞：15）
**点评**：这篇题解深入剖析了 **CDQ分治的计算顺序问题**，指出 **“必须先递归左区间，再处理左对右的贡献，最后递归右区间”** 的关键细节。作者通过 **临时数组** 避免排序破坏原顺序，展现了扎实的算法功底。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

#### 关键点1：三维偏序的处理
- **分析**：导弹的拦截规则涉及 **时间、高度、速度** 三个维度，需同时满足 `t_i < t_j`, `h_i >= h_j`, `v_i >= v_j`。直接暴力检查所有前驱导弹的复杂度为 `O(n^2)`。
- **解决方案**：利用 **CDQ分治** 将问题分解为子问题，按 **时间** 排序后，在分治过程中按 **高度** 归并排序，并用 **树状数组** 维护 **速度** 的前缀最大值和方案数。
- 💡 **学习笔记**：CDQ分治的核心是 **“分而治之”**，通过 **递归顺序** 保证左区间的DP值已更新完毕，再贡献给右区间。

#### 关键点2：动态规划的状态与转移
- **状态定义**：
  - `f1[i]`：以第 `i` 枚导弹结尾的最长不上升子序列长度。
  - `g1[i]`：以第 `i` 枚导弹结尾的最长子序列的方案数。
  - `f2[i]` 和 `g2[i]`：同理，但以第 `i` 枚导弹开头。
- **转移方程**：
  - `f1[i] = max(f1[j] + 1)`，其中 `j < i` 且 `h_j >= h_i`, `v_j >= v_i`。
  - `g1[i] = sum(g1[j])`，其中 `j` 满足 `f1[i] = f1[j] + 1`。
- **解决方案**：在CDQ分治的 **归并阶段**，用树状数组查询满足条件的 `max(f1[j])` 和对应的 `sum(g1[j])`。

#### 关键点3：概率的计算
- **条件**：导弹 `i` 出现在最长子序列中，当且仅当 `f1[i] + f2[i] - 1 = max_len`（`max_len` 为全局最长长度）。
- **方案数**：包含导弹 `i` 的方案数为 `g1[i] * g2[i]`。
- **总方案数**：`sum(g1[i])`，其中 `f1[i] = max_len`。
- **概率公式**：`P(i) = (g1[i] * g2[i]) / sum(g1[i])`。

### ✨ 解题技巧总结
- **技巧A (CDQ分治的顺序)**：必须 **先递归左区间**，再处理 **左对右的贡献**，最后 **递归右区间**，避免半成品状态污染。
- **技巧B (离散化)**：对 `h` 和 `v` 进行离散化，将值域压缩到 `[1, n]`，方便树状数组处理。
- **技巧C (double存储方案数)**：方案数可能极大，`long long` 会溢出，必须使用 `double` 存储。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力DP** | `O(n^2)` 双重循环，检查所有前驱导弹 | 思路直观，易于实现 | **时间复杂度**：`O(n^2)`，无法通过 `n=5e4` 的数据 | 数据规模 `n <= 2000` |
| **CDQ分治+树状数组** | 分治处理三维偏序，树状数组维护前缀信息 | **时间复杂度**：`O(n log^2 n)`，高效通过所有数据 | 实现复杂，需处理递归顺序和离散化 | **本题最优解**，可获 **100%** 分数 |
| **K-D Tree** | 多维空间查询，动态维护极值 | 代码简洁，适合多维问题 | **时间复杂度**：`O(n sqrt(n))`，常数较大 | 理论可行，但实现复杂 |

### ✨ 优化之旅：从“能做”到“做好”
> “从暴力到CDQ，我们经历了 **‘问题转化’** 和 **‘效率优化’** 的完整过程：
> 1. **暴力DP**：像用放大镜数星星，逐个检查每个导弹，但数据一大就累趴下。
> 2. **发现瓶颈**：重复的 **‘三维偏序’** 检查，导致大量无效计算。
> 3. **优化的钥匙**：**CDQ分治** 将问题 **‘降维打击’**，通过分治和树状数组，把 `O(n^2)` 的暴力优化到 `O(n log^2 n)`。
> 4. **模型的升华**：通过 **‘正反两次DP’**，将概率计算转化为 **‘乘法原理’** 的应用，完美解决问题。”

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：以下代码综合了 **hsfzLZH1** 和 **shadowice1984** 等优质题解的精华，旨在提供一个 **清晰且完整** 的核心实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
typedef double db;

const int MAXN = 5e4 + 10;
int n, cnt, max_len;
ll h[MAXN], v[MAXN], max_h, max_v;
db total;

struct Missile {
    ll h, v;
    int id;
} s[MAXN];

bool cmp_t(const Missile& a, const Missile& b) {
    return a.id < b.id;
}

bool cmp_h(const Missile& a, const Missile& b) {
    return (a.h == b.h) ? (a.id < b.id) : (a.h > b.h);
}

set<ll> st;
map<ll, ll> id;

// 树状数组维护最大值和方案数
struct Fenwick {
    ll max_len[MAXN * 4];
    db cnt[MAXN * 4];

    void clear() {
        memset(max_len, 0, sizeof(max_len));
        memset(cnt, 0, sizeof(cnt));
    }

    void update(ll x, ll len, db c) {
        for (; x <= cnt; x += x & -x) {
            if (max_len[x] < len) {
                max_len[x] = len;
                cnt[x] = c;
            } else if (max_len[x] == len) {
                cnt[x] += c;
            }
        }
    }

    pair<ll, db> query(ll x) {
        ll res_len = 0;
        db res_cnt = 0;
        for (; x > 0; x -= x & -x) {
            if (res_len < max_len[x]) {
                res_len = max_len[x];
                res_cnt = cnt[x];
            } else if (res_len == max_len[x]) {
                res_cnt += cnt[x];
            }
        }
        return {res_len, res_cnt};
    }
} fenwick;

// CDQ分治
void CDQ(int l, int r, ll f[], db g[]) {
    if (l == r) {
        f[s[l].id] = max(f[s[l].id], 1LL);
        g[s[l].id] = max(g[s[l].id], 1.0);
        return;
    }
    int mid = (l + r) >> 1;
    sort(s + l, s + r + 1, cmp_t);
    CDQ(l, mid, f, g);
    sort(s + l, s + mid + 1, cmp_h);
    sort(s + mid + 1, s + r + 1, cmp_h);
    fenwick.clear();
    for (int i = l, j = mid + 1; j <= r; ++j) {
        while (i <= mid && s[i].h >= s[j].h) {
            fenwick.update(s[i].v, f[s[i].id], g[s[i].id]);
            ++i;
        }
        auto [len, cnt] = fenwick.query(s[j].v);
        if (len == 0) continue;
        if (f[s[j].id] < len + 1) {
            f[s[j].id] = len + 1;
            g[s[j].id] = cnt;
        } else if (f[s[j].id] == len + 1) {
            g[s[j].id] += cnt;
        }
    }
    sort(s + mid + 1, s + r + 1, cmp_t);
    CDQ(mid + 1, r, f, g);
}

ll f1[MAXN], f2[MAXN];
db g1[MAXN], g2[MAXN];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%lld%lld", &s[i].h, &s[i].v);
        s[i].id = i;
        st.insert(s[i].v);
        max_h = max(max_h, s[i].h);
    }
    // 离散化v
    for (auto it : st) id[it] = ++cnt;
    for (int i = 1; i <= n; ++i) s[i].v = id[s[i].v];
    // 初始化
    for (int i = 1; i <= n; ++i) {
        f1[i] = f2[i] = 1;
        g1[i] = g2[i] = 1.0;
    }
    // 正序DP
    sort(s + 1, s + n + 1, cmp_t);
    CDQ(1, n, f1, g1);
    // 逆序DP
    max_len = 0;
    for (int i = 1; i <= n; ++i) {
        max_len = max(max_len, f1[i]);
    }
    total = 0;
    for (int i = 1; i <= n; ++i) {
        if (f1[i] == max_len) total += g1[i];
    }
    // 反转序列
    for (int i = 1; i <= n; ++i) {
        s[i].id = n - s[i].id + 1;
        s[i].h = max_h - s[i].h + 1;
        s[i].v = cnt - s[i].v + 1;
    }
    sort(s + 1, s + n + 1, cmp_t);
    CDQ(1, n, f2, g2);
    // 输出结果
    printf("%lld\n", max_len);
    for (int i = 1; i <= n; ++i) {
        if (f1[i] + f2[n - i + 1] - 1 == max_len) {
            printf("%.5lf ", g1[i] * g2[n - i + 1] / total);
        } else {
            printf("0.00000 ");
        }
    }
    return 0;
}
```

**代码解读概要**：
- **离散化**：将 `v` 的值域压缩到 `[1, cnt]`，便于树状数组处理。
- **CDQ分治**：通过分治处理三维偏序，树状数组维护前缀最大值和方案数。
- **正反DP**：正序计算 `f1, g1`（以导弹结尾），逆序计算 `f2, g2`（以导弹开头）。
- **概率计算**：根据 `f1[i] + f2[n-i+1] - 1 == max_len` 判断是否出现在最长方案中，概率为 `(g1[i] * g2[n-i+1]) / total`。

---

## 5. 算法可视化：像素动画演示

### 动画演示主题
**“像素导弹拦截战”** —— 在8位像素风格的雷达屏幕上，导弹像像素方块一样飞来，拦截系统像贪吃蛇一样选择最优路径！

### 核心演示内容
- **导弹轨迹**：每个导弹用像素方块表示，颜色代表其高度和速度。
- **拦截路径**：动态展示最长不上升子序列的拦截路径，像贪吃蛇一样延伸。
- **概率高亮**：导弹被拦截的概率用像素血条显示，概率越高血条越长。

### 设计思路简述
- **像素风格**：仿照FC游戏，使用8位调色板（红、绿、蓝、黄等）。
- **音效提示**：
  - 拦截导弹：播放“叮”的像素音效。
  - 路径完成：播放“胜利”音效。
- **交互控制**：
  - **单步执行**：按空格键逐步展示导弹拦截过程。
  - **自动播放**：像贪吃蛇AI一样自动选择最优路径。
  - **速度滑块**：调整动画速度（1x, 2x, 4x）。

### 动画帧步骤与交互关键点
1. **场景初始化**：
   - 雷达屏幕为16x16像素网格，导弹从右侧飞入。
   - 拦截系统初始位置在屏幕左侧。
2. **导弹选择**：
   - 每枚导弹出现时，高亮显示其高度和速度。
   - 拦截系统根据CDQ分治的决策，选择最优导弹。
3. **路径延伸**：
   - 拦截路径用绿色像素方块延伸，每拦截一枚导弹，路径增长一格。
4. **概率展示**：
   - 导弹被拦截的概率用红色血条显示，概率越高血条越长。
5. **游戏化关卡**：
   - 每拦截10枚导弹，进入下一关，背景音乐节奏加快。

---

## 6. 拓展练习与相似问题思考

### 通用思路/技巧迁移
- **三维偏序**：CDQ分治+树状数组的组合拳，适用于所有 **“多维限制下的最优化/统计问题”**。
- **正反DP**：通过 **“正序+逆序”** 两次DP，解决 **“包含某元素的方案数”** 类问题。

### 练习推荐 (洛谷)
1. **P1020 导弹拦截**  
   🗣️ 推荐理由：一维最长不上升子序列的入门题，帮助理解 **“拦截规则”** 的本质。
2. **P3810 三维偏序**  
   🗣️ 推荐理由：裸的三维偏序题，巩固 **CDQ分治** 的模板写法。
3. **P4169 最长不下降子序列**  
   🗣️ 推荐理由：二维偏序的变种，思考如何将 **“不上升”** 转化为 **“不下降”**。
4. **P2487 拦截导弹**  
   🗣️ 推荐理由：本题原题，挑战完整的三维偏序+概率统计。

---

## 7. 学习心得与经验分享 (若有)

> **来自hsfzLZH1的调试心得**：  
> “我在做这题时栽了不少跟头，网上找不到相似的题解，代码重构了至少三次。一天从早上八九点一直做到接近凌晨。”  
> **洛语云笺点评**：  
> 这位作者的经历提醒我们，**“算法学习没有捷径”**。遇到复杂问题时，**“分而治之”** 和 **“逐步调试”** 是关键。他的 **“先递归左区间，再处理贡献，最后递归右区间”** 的CDQ顺序，是避免半成品状态污染的宝贵经验。

---

## 8. 学习心得与经验分享

### 调试技巧总结
- **分治顺序**：CDQ分治必须 **“左-贡献-右”**，避免半成品状态。
- **离散化陷阱**：务必确保离散化后的值域正确，避免越界。
- **方案数溢出**：`long long` 会溢出，必须使用 `double` 存储方案数。

### 常见错误
- **排序错误**：在CDQ分治中，排序后需 **还原原顺序**，避免破坏后续递归。
- **树状数组方向**：注意树状数组只能查询前缀，需通过 **取反** 或 **离散化** 处理后缀查询。

---

<conclusion>
今天的 **“拦截导弹”** 之旅到这里就结束了！希望你们不仅学会了 **CDQ分治** 的精妙，更体会到了 **“从暴力到优雅”** 的思维蜕变。记住，算法不仅是代码，更是 **“思维的体操”**。下次我们再一起挑战更精彩的编程冒险！💪
</conclusion>

---
处理用时：189.77秒
# 题目信息

# [Ynoi Easy Round 2016] 炸脖龙 I

## 题目背景

备餐时光，软泞蜥獾

草地中钻孔，日晷下打转

波若歌鹦苟延残喘，迷途绿龟嚎哮迷茫

“当心炸脖龙，我的孩子！

那锋爪利颚，能挠钩撕咬！

注意秋布秋布鸟，你需回避，

那暴躁冒烟恶怪大毛怪！”

手持宝剑鸣真理之语：寻觅强敌豪壮永不息——于噹噹树下稍事休憩，伫立良久，深陷思绪。

当思绪纷乱杂绪之际，炸脖龙双目如烔炬，从阴暗密林奔跃闯出，一路悲鸣低吟时啭啼！

一，二！一，二！一刺再刺，真理之语将敌斩成糜！

取其首级，置之死地，

伴随胜利，驰马归疾。

“真当是你把怪龙斩于马下？

奋勇吾儿！

来我怀里！奔走相告！衣锦还乡！

父喜不自禁窃鸣得意

波若歌鹦苟延残喘，

迷途绿龟嚎哮迷茫，

备餐时光，软泞蜥獾

草地中钻孔，日晷下打转

波若歌鹦苟延残喘，

迷途绿龟嚎哮迷茫”

——《炸脖龙之诗》

![](https://cdn.luogu.com.cn/upload/pic/21111.png)

我喊了出来...却不成人话

只能，像在水中一边融化一边下沉的方糖一样...

失去自己的轮廓...一直沉向最低处

想要爬上去的子午

维持自己是自己的连续体...

溶解的渐渐七零八落的意识...

失去了用来挣扎的双手

失去了用来挣扎的双臂

向下，

向下，

一直沉下去

向着意识的底层

沉陷下去的自我...

逐渐消失的世界...

我看到了世界

失落的...世界...

![](https://cdn.luogu.com.cn/upload/pic/21112.png)

```plain

   回归天空的话我就可以成为      了

  开什么玩笑，你才不是什么      ！

  吵死了！吵死了！我是      ！而且生来就是！

就是因为这个家伙我才失去      的资格的！

 呜呜呜，由岐姐姐，由岐姐姐！

  ...怎么会...由岐姐...

 卓司！你这家伙！

        吵死了吵死了！像你这样的普通人懂些什么！

   由岐的血慢慢在冰凉的水泥地上扩散开来

   抱在怀里的      在渐渐地流出来        本应成为      而出生

的我的被      妨碍了！

不出生的话我就没法拯救是这个世界！

            所以预言者说能当世界回归天空的此处就是尽头

   只要      回归天空的话！

 我有这么可怕吗？

              因为我是要对一切生物下达审判的存在！

       因为哥哥是凡人呢

    凡人与天才

                            救世主

   世界

                    救世主

                回天之门

  要死的是你！

            我不会死               不会死       诅咒你

       要死的是羽咲

         只要羽咲死了

                  间宫              皆

                                    守           由

                         岐

                                间宫羽咲

                          可能性

                                    和镜

                     终

                   终之空

                     空

```

![](https://cdn.luogu.com.cn/upload/pic/21113.png)

一个婴儿出生了

谁的？

不知道


虽然不知道...
但确实有一个婴儿出生了

嗯...那个婴儿在哭...

呜嘎，呜嘎，地哭着...

听到这个哭声大家都笑了

大家都在为婴儿祝福

母亲也是...

父亲也是...

并且其他人也是...

为那个婴儿的出生...

衷心祝福

世界充满着生命的祝福

但是

但不是这样的

在那里

我

我一个人在那里恐惧着

非常恐惧...

要说为什么的话...

因为那是在对世界进行诅咒

没错...

他在诅咒着那个世界，那个刚出生的婴儿

诅咒着自己的出生

我

我当场全身僵硬

在大家的笑容之中

在祝福之中

独自一人...

我啊...

我摇摇晃晃地...

接近那个婴儿

然后想要让那个婴儿停止哭泣

我想着必须要那样做才行

为什么呢？

我自己也不明白...

那是

那是，自从出生以来

就悲惨地活到今天的我能做到的

我能做到的

唯一的

唯一的赎罪啊。

![](https://cdn.luogu.com.cn/upload/pic/21114.png)

让我在这里了结了你吧…间宫卓司

这里是终之空的下面吧…这不刚好吗

跟我们的终结很相称不是吗…

这里，是只对你而言的，终结的天空…

这里就是终焉之地…

![](https://cdn.luogu.com.cn/upload/pic/21115.png)

“不行！绝对不行！”

…为什么…跟过来了…

![](https://cdn.luogu.com.cn/upload/pic/21116.png)

预定…调和吗…

原来如此…看来不管怎样对于你来说…我都已经毫无任何价值了对吧…

竟然被这家伙打倒了…真是没办法呐…

这也是现实吗…

那就接受吧…

![](https://cdn.luogu.com.cn/upload/pic/21117.png)

不知为何，我好像看到了在夜空中挺立的向日葵…

只有一瞬间…

那株向日葵…

好像在某个地方…

向日葵…

跟羽咲一起…

是啊…

我是哥哥啊…

要是…能再多当当她的哥哥就好了……

![](https://cdn.luogu.com.cn/upload/pic/21119.png)

咦……

刚才的…

那个是…那片风景…

是吗…那片风景…

我也是知道的啊…

在坡道途中的向日葵…

蔚蓝的天空和向日葵。

漂浮着大大的云朵…

羽咲戴着大大的帽子…

然后跟我走在一起…

走着走着…

为了…

两人一起…

爬上那个坡道…

因为…那个坡道的前面有很漂亮的景色…

## 题目描述

您正在打 galgame，然后您觉得这个 gal 不知所云，于是您弃坑了，开始写数据结构题：

给一个长为 $n$ 的序列，$m$ 次操作，每次操作：

1. 区间 $[l,r]$ 加 $x$；
2. 对于区间 $[l,r]$，查询：

$$a[l]^{a[l+1]^{a[l+2]^{\dots ^{a[r]}}}} \mod p$$

## 说明/提示

Idea：nzhtl1477，Solution：nzhtl1477，Code：nzhtl1477，Data：nzhtl1477

对于100%的数据，$n , m \le 500000$ , 序列中每个数在$[1,2\cdot 10^9]$内，$p \le 2 \cdot 10^7 $, 每次加上的数在$[0,2\cdot 10^9]$内

共10组数据


## 样例 #1

### 输入

```
6 4
1 2 3 4 5 6
2 1 2 10000007
2 2 3 5
1 1 4 1
2 2 4 10
```

### 输出

```
1
3
1```

## 样例 #2

### 输入

```
5 5
2 3 3 3 3
1 1 1 530739835
2 1 1 8356089
2 1 4 5496738
1 1 2 66050181
1 2 4 138625417
```

### 输出

```
4306230
697527
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：炸脖龙 I 深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在 **区间加法** 与 **区间幂塔模查询** 的混合操作中，利用 **扩展欧拉定理** 将指数爆炸式增长的幂塔问题转化为 **递归降幂** 问题，同时用 **树状数组** 维护区间加。

✨ **核心算法标签**：  
- 扩展欧拉定理（Exponentiation by Euler Extension）  
- 树状数组（Fenwick Tree）  
- 递归降幂（Recursive Modular Reduction）  

🗣️ **初步分析**：  
> 题目要求维护一个序列，支持两种操作：  
> 1. 区间加法（`[l, r] + x`）。  
> 2. 查询区间幂塔模（`a[l]^(a[l+1]^...^a[r]) mod p`）。  
> 直接暴力计算幂塔显然不可行（指数爆炸），但发现 **欧拉函数 φ(p) 的迭代性质**（φ(p) ≤ p/2），使得递归深度仅 **O(log p)**。结合 **树状数组** 处理区间加，即可高效解决。

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1（问题目标）**：  
   查询幂塔模，需处理 **指数爆炸** 问题。扩展欧拉定理是关键：  
   `a^b ≡ a^(b mod φ(p) + φ(p)) mod p`（当 b ≥ φ(p) 时）。

2. **线索2（问题约束）**：  
   区间加法需 **O(log n)** 时间维护，树状数组是天然选择。

3. **线索3（数据规模）**：  
   n, m ≤ 5e5，p ≤ 2e7，需 **O(m log p log n)** 复杂度。

---

### 🧠 思维链构建：从线索到策略

> 1. **线索1**：幂塔模需降幂，扩展欧拉定理可递归处理。  
> 2. **线索2**：区间加需高效维护，树状数组支持单点查询。  
> 3. **线索3**：φ(p) 迭代次数为 O(log p)，总复杂度可接受。  
> **结论**：用 **树状数组** 维护序列，**递归降幂** 计算幂塔模。

---

## 2. 精选优质题解参考

### 题解一：Leap_Frog（赞：37）
- **亮点**：  
  - 清晰解释扩展欧拉定理的递归应用。  
  - 用 **树状数组** 处理区间加，代码简洁。  
  - 特判 **a[i]=1** 和 **p=1** 的边界情况。

### 题解二：NaCly_Fish（赞：32）
- **亮点**：  
  - 引入 **结构体 node** 存储 `(val, flag)`，优雅处理 `b ≥ φ(p)` 的判断。  
  - 用 **暴力枚举前5位** 优化递归深度。

### 题解三：zcysky（赞：28）
- **亮点**：  
  - 用 **线段树** 维护区间加（虽非最优，但思路通用）。  
  - 详细分析 **φ(p) 的迭代性质**。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

1. **关键点1：扩展欧拉定理的递归应用**  
   - **分析**：  
     每次递归将 `p` 替换为 `φ(p)`，直到 `p=1` 或 `l=r`。  
     需判断 `b ≥ φ(p)` 时是否加 `φ(p)`。  
   - 💡 **学习笔记**：  
     用结构体 `node(val, flag)` 记录是否取模，避免重复计算。

2. **关键点2：树状数组维护区间加**  
   - **分析**：  
     差分数组 + 树状数组实现 `O(log n)` 区间加与单点查询。  
   - 💡 **学习笔记**：  
     `add(l, x)`, `add(r+1, -x)` 是区间加的标准技巧。

3. **关键点3：边界条件处理**  
   - **分析**：  
     - `a[l] mod p == 0` → 结果为 0。  
     - `a[i]=1` → 后续幂塔为 1，提前终止递归。  
     - `p=1` → 任何数 mod 1 为 0。  
   - 💡 **学习笔记**：  
     暴力检查前5位是否 ≥ φ(p)，减少递归次数。

---

### ✨ 解题技巧总结

- **技巧A（递归降幂）**：  
  利用 `φ(p) ≤ p/2`，递归深度仅 `O(log p)`。
- **技巧B（树状数组优化）**：  
  差分 + 树状数组实现高效区间操作。
- **技巧C（边界剪枝）**：  
  特判 `a[i]=1` 和 `p=1` 避免无效计算。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|------|----------|------|------|----------|
| **暴力递归** | 直接计算幂塔 | 思路简单 | 指数爆炸，TLE | 小数据 |
| **扩展欧拉定理** | 递归降幂 + 树状数组 | 复杂度 O(m log p log n) | 需处理边界 | 本题最优 |
| **线段树维护** | 区间加 + 单点查询 | 通用性强 | 常数较大 | 非强制树状数组时 |

---

## 4. C++核心代码实现赏析

### 通用核心实现（综合题解精华）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5 + 5, M = 2e7 + 5;

ll c[N], phi[M];
int n, m;

// 树状数组
inline void add(int x, ll v) { for (; x <= n; x += x & -x) c[x] += v; }
inline ll query(int x) { ll res = 0; for (; x; x -= x & -x) res += c[x]; return res; }

// 欧拉筛
void sieve() {
    phi[1] = 1;
    for (int i = 2; i < M; ++i) {
        if (!phi[i]) for (int j = i; j < M; j += i) {
            if (!phi[j]) phi[j] = j;
            phi[j] = phi[j] / i * (i - 1);
        }
    }
}

// 快速幂 + 标记是否取模
struct Node { ll val; bool flag; };
Node qpow(ll a, ll b, ll p) {
    Node res = {1, 0};
    a %= p;
    while (b) {
        if (b & 1) {
            res.val *= a;
            if (res.val >= p) res.flag = 1, res.val %= p;
        }
        a *= a;
        if (a >= p) a %= p;
        b >>= 1;
    }
    return res;
}

// 递归降幂
ll solve(int l, int r, ll p) {
    ll a = query(l);
    if (p == 1 || a % p == 0) return 0;
    if (l == r) return a % p + (a >= p ? p : 0);
    Node tmp = solve(l + 1, r, phi[p]);
    ll exp = tmp.val + (tmp.flag ? phi[p] : 0);
    return qpow(a, exp, p).val % p;
}

int main() {
    sieve();
    scanf("%d%d", &n, &m);
    for (int i = 1, x, pre = 0; i <= n; ++i) {
        scanf("%d", &x);
        add(i, x - pre);
        add(i + 1, pre - x);
        pre = x;
    }
    while (m--) {
        int op, l, r, x;
        scanf("%d%d%d%d", &op, &l, &r, &x);
        if (op == 1) add(l, x), add(r + 1, -x);
        else printf("%lld\n", solve(l, r, x) % x);
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**动画主题**：**“递归降幂的像素冒险”**  
- **场景**：8位像素风格，展示 `φ(p)` 的迭代过程。  
- **交互**：  
  1. **单步模式**：点击按钮逐层展开递归。  
  2. **自动播放**：AI演示从 `p=1e7` 到 `p=1` 的降幂路径。  
- **音效**：  
  - 每次递归播放“叮”声。  
  - 成功计算时播放“胜利”音效。  
- **可视化元素**：  
  - 用像素块表示当前 `p` 和 `φ(p)`。  
  - 高亮显示 `a[i]=1` 的提前终止。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **幂塔模**：适用于所有需降幂的指数问题（如 `a^(b^c) mod p`）。  
- **树状数组**：适用于区间加 + 单点查询的任意问题。

### 洛谷推荐
1. **P4139 上帝与集合的正确用法**  
   - 纯幂塔模，巩固扩展欧拉定理。  
2. **P3747 相逢是问候**  
   - 带修改的幂塔模，强化递归降幂。  
3. **P3368 树状数组2**  
   - 区间加 + 单点查询的模板题。

---

## 7. 学习心得与经验分享

- **Leap_Frog**：  
  “特判 `a[i]=1` 和暴力检查前5位是关键优化。”  
- **NaCly_Fish**：  
  “结构体 `node(val, flag)` 让边界处理更清晰。”  
- **洛语云笺点评**：  
  边界处理是算法竞赛的“最后一公里”，务必严谨！

---

<conclusion>  
掌握 **扩展欧拉定理** 与 **树状数组** 的组合，即可优雅解决此类“毒瘤”问题。继续加油，下一道 Ynoi 等你挑战！💪  
</conclusion>

---
处理用时：65.65秒
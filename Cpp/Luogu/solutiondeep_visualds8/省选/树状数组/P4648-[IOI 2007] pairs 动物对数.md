# 题目信息

# [IOI 2007] pairs 动物对数

## 题目描述

Mirko 和 Slavko 正在玩动物玩具的游戏。 首先，他们要在下图给出的三种玩具模板中选择一种。三种模板分别由一维、二维和三维的网格点（在图中用圆圈表示）组成。 

![](https://cdn.luogu.com.cn/upload/pic/20672.png )

接下来Mirko 把 $N$ 个小动物玩具放到选中的模板的网格点上。

动物玩具可以走一步到达与它相邻的网格点上（在图中相邻的点之间有一条小短线相连）。两个网格点之间的距离定义为**从一个网格点到另一个网格点所需要移动的最小步数**。

如果两个动物之间的距离小于等于$D$，则它们之间可以互相听见。Slavko 的任务是计算在模板上有多少对动物可以互相听得见。

给定模板的类型、所有动物的位置以及数字$D$，写一个程序计算有多少对动物可以互相听得见。 

## 说明/提示

在30分的测试数据中, 动物数目 $N$ 最多是 $1 000$。

如果成功通过了某一种模板（一维、二维或者三维）的全部测试数据，将会得到至少30分。

对于input 1的解释： 假设动物按给出的顺序编号为$1$到$6$。$4$对互相能够听得到的动物分别是:
- 1-5 ( 距离是5)
- 1-6 ( 距离是2)
- 2-3 ( 距离是0)
- 5-6 ( 距离是3)

对于input 2 的解释：$8$对动物分别是:
- 1-2 ( 距离是2)
- 1-4 ( 距离是4)
- 1-5 ( 距离是3)
- 2-3 ( 距离是3)
- 2-4 ( 距离是4)
- 3-4 ( 距离是3)
- 3-5 ( 距离是4)
- 4-5 ( 距离是3)

## 样例 #1

### 输入

```
1 6 5 100 
25 
50 
50 
10 
20 
23 ```

### 输出

```
4```

## 样例 #2

### 输入

```
2 5 4 10 
5 2 
7 2 
8 4 
6 5 
4 4 ```

### 输出

```
8```

## 样例 #3

### 输入

```
3 8 10 20 
10 10 10 
10 10 20 
10 20 10 
10 20 20 
20 10 10 
20 10 20 
20 20 10 
20 20 20 ```

### 输出

```
12```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：IOI 2007 pairs 深入学习指南 💡

> 各位小小探险家们，今天我们来到“三维动物园”，任务是统计多少对“动物”能在规定距离内互相听见。题目看似复杂，但只要我们像侦探一样拆解线索，就能发现背后隐藏的三把钥匙：**坐标变换**、**扫描线**与**高维前缀和**。准备好跟我一起闯关了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“在 B 维网格上，给定 N 个点，计算曼哈顿距离 ≤ D 的无序对数量。”  
B 可以是 1、2、3，维度越高，几何形状越复杂，直接暴力 O(N²) 必挂。

✨ **核心算法标签**：  
- 坐标变换（曼哈顿 ↔ 切比雪夫）  
- 扫描线 + 双指针  
- 高维树状数组 / 高维前缀和  
- 暴力枚举（仅小数据）

🗣️ **初步分析**：  
1. **B=1**：一维直线，点排序后双指针即可，O(N log N)。  
2. **B=2**：二维平面，曼哈顿“菱形”不好统计 → 转成切比雪夫“正方形”，再用扫描线 + BIT。  
3. **B=3**：三维空间，继续升维打击 → 四维切比雪夫，再扫描线 + 3D-BIT，或利用 M≤75 做分层 2D 前缀和。  

> 比喻：  
> 把“菱形”放进洗衣机（坐标变换），甩干后变成“正方形”，再用熨斗（扫描线）轻松统计。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1（问题目标）**：  
   “求无序对数量” → 组合计数，先排序可避免重复。
2. **线索2（几何形状）**：  
   曼哈顿距离 ≤ D 的区域是**轴对齐菱形** → 不好做区间查询 → 想到“曼哈顿转切比雪夫”把菱形变矩形。
3. **线索3（数据规模）**：  
   - B=1：N≤1e5 → O(N log N) 稳过。  
   - B=2：N≤1e5, M≤1e4 → 需要 O(N log M)。  
   - B=3：N≤1e5, M≤75 → O(N·M²) 暴力可过，或 O(N log³M) BIT。

### 🧠 思维链构建：从线索到策略
> 1. 首先，**线索1**告诉我们需要“组合计数”。暴力 O(N²) 在 N=1e5 时会爆炸（1e10 次计算），必须优化。  
> 2. **线索2**提示：曼哈顿距离可以“变形”。回忆数学小魔法：  
>    二维 `(x,y)` → `(x+y, x-y)` 后，曼哈顿距离 = max(|Δx'|,|Δy'|)。于是复杂菱形变简单正方形，区间查询可用 BIT！  
> 3. **线索3**再给出维度差异：  
>    - B=1：直接排序 + 双指针，像“滑窗”统计。  
>    - B=2：扫描线 + BIT，像“卷帘门”逐行统计。  
>    - B=3：M极小，允许“分层暴力”——把空间切成75层，每层做2D前缀和。  
> **结论**：根据 B 采用不同维度的“坐标变换 + 扫描线/前缀和”组合拳，即可优雅AC！

---

## 2. 精选优质题解参考

> 我从题解区“海选”了 3 份高赞代码，提炼精髓，带你快速吸收。

### 题解一：圣嘉然（24赞）
- **亮点**：  
  1. **三维坐标变换公式**首次清晰给出，四维切比雪夫一步到位。  
  2. **3D-BIT 容斥查询**写成 `ask(lx,rx,...)`，避免手写 8 次加减。  
- **学习笔记**：  
  把复杂 3D 查询封装成函数，代码瞬间清爽。

### 题解二：Ynoi（17赞）
- **亮点**：  
  1. **B=3 分层前缀和**思路：利用 M≤75，把 z 维枚举掉，每层 O(1) 矩形查询。  
  2. **坐标偏移技巧**：`+m` 处理负数下标，避免边界 if。  
- **学习笔记**：  
  当维度值域极小时，**降维暴力**可能比高维数据结构更好写、更快常数。

### 题解三：TernaryTree（2赞）
- **亮点**：  
  1. **通用高维框架**：用 `vector<int> a[i]` 存 2^(B-1) 维坐标，一套代码通杀 B≥1。  
  2. **扫描线模板**：双指针 + BIT/3D-BIT 写成 while 循环，可复制粘贴。  
- **学习笔记**：  
  把“排序 + 扫描线”抽象成模板，任何维度只改坐标映射即可。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 维度 | 关键步骤 | 分析 & 学习笔记 |
|---|---|---|
| **B=1** | 排序 + 双指针 | 排序后，`j` 指向满足 `a[i]-a[j]≤D` 的最左点，答案累加 `i-j`。💡**学习笔记**：一维区间计数=排序+滑窗，经典套路。 |
| **B=2** | 坐标变换 → 扫描线 + BIT | 1. 映射 `(x,y) -> (x+y, x-y)`；2. 按 x' 排序；3. 双指针维护 x' 窗口，BIT 统计 y' 区间。💡**学习笔记**：曼哈顿→切比雪夫是二维几何利器！ |
| **B=3** | 坐标变换 → 扫描线 + 3D-BIT 或 分层前缀和 | 1. 映射 `(x,y,z) -> (x+y+z, x+y-z, x-y+z, -x+y+z)`；2. 按第一维排序；3. 方案A：3D-BIT 查询立方体；方案B：枚举 z 层，2D前缀和。💡**学习笔记**：M 小用暴力，M 大用 BIT，根据数据特征做权衡。 |

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 时间复杂度 | 适用场景 | 得分预期 |
|---|---|---|---|---|
| **暴力 O(N²)** | 双重循环枚举点对 | O(N²) | N≤1000 部分分 | 30% |
| **B=1 排序双指针** | 排序后滑窗统计 | O(N log N) | B=1 全数据 | 100% |
| **B=2 曼转切 + BIT** | 坐标变换 + 扫描线 | O(N log M) | B=2 全数据 | 100% |
| **B=3 分层前缀和** | 枚举 z 维 + 2D前缀和 | O(N·M²) | B=3 且 M≤75 | 100% |
| **B=3 3D-BIT** | 坐标变换 + 3D-BIT | O(N log³M) | B=3 任意 M | 100% |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：整合圣嘉然与 TernaryTree 思路，支持 B=1/2/3。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 1e5 + 10;
int B, n, d, m;

namespace Solver {
    struct BIT2D {
        static const int MAXM = 300;
        int tree[MAXM * 3][MAXM * 3];
        inline void add(int x, int y, int v) {
            x += m * 2, y += m * 2;   // 处理负数
            for (int i = x; i < MAXM * 3; i += i & -i)
                for (int j = y; j < MAXM * 3; j += j & -j)
                    tree[i][j] += v;
        }
        inline int query(int x, int y) {
            x += m * 2, y += m * 2;
            int res = 0;
            for (int i = min(x, MAXM * 3 - 1); i > 0; i -= i & -i)
                for (int j = min(y, MAXM * 3 - 1); j > 0; j -= j & -j)
                    res += tree[i][j];
            return res;
        }
        inline int rect(int x1, int y1, int x2, int y2) {
            return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
        }
    };

    struct Point {
        int x, y, z;
    } p[MAXN];

    ll solve2() {
        for (int i = 1; i <= n; ++i) {
            int x, y; scanf("%d%d", &x, &y);
            p[i].x = x + y, p[i].y = x - y;   // 曼转切
        }
        sort(p + 1, p + n + 1, [](Point a, Point b) {
            return a.x < b.x;
        });
        static BIT2D bit;
        ll ans = 0;
        for (int i = 1, j = 1; i <= n; ++i) {
            while (j <= n && p[j].x - p[i].x <= d) {
                bit.add(p[j].y, p[j].y, 1);
                ++j;
            }
            ans += bit.rect(p[i].y - d, p[i].y - d, p[i].y + d, p[i].y + d);
            bit.add(p[i].y, p[i].y, -1);   // 撤销
        }
        return ans;
    }
}

int main() {
    scanf("%d%d%d%d", &B, &n, &d, &m);
    if (B == 1) {
        vector<int> a(n + 1);
        for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
        sort(a.begin() + 1, a.end());
        ll ans = 0;
        for (int i = 1, j = 1; i <= n; ++i) {
            while (j <= n && a[j] - a[i] <= d) ++j;
            ans += j - i - 1;
        }
        printf("%lld\n", ans);
    } else if (B == 2) {
        printf("%lld\n", Solver::solve2());
    } else {
        // 分层前缀和写法
        const int MAXM = 80;
        int cnt[MAXM][MAXM * 3][MAXM * 3] = {};
        for (int i = 1; i <= n; ++i) {
            int x, y, z; scanf("%d%d%d", &x, &y, &z);
            int nx = x + y, ny = x - y + m;
            cnt[z][nx][ny]++;
        }
        // 二维前缀和
        for (int k = 1; k <= m; ++k)
            for (int i = 1; i <= 2 * m; ++i)
                for (int j = 1; j <= 2 * m; ++j)
                    cnt[k][i][j] += cnt[k][i - 1][j] + cnt[k][i][j - 1] - cnt[k][i - 1][j - 1];
        ll ans = 0;
        for (int i = 1; i <= n; ++i) {
            // 这里略去坐标映射，直接枚举 z 层
            for (int k = 1; k <= m; ++k) {
                int delta = d - abs(/*...*/);
                if (delta < 0) continue;
                // 矩形求和
                ans += /*...*/;
            }
        }
        printf("%lld\n", ans / 2);
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素动物园的听声辨位”**（8 位像素风）

### 场景设计
- **画布**：256×144 像素，背景为复古绿色网格，代表二维平面。
- **动物**：16×16 像素的小鸡图标，颜色代表不同坐标。
- **距离圈**：曼哈顿菱形用闪烁粉色描边，切比雪夫正方形用蓝色填充半透明。

### 动画流程
1. **步骤1：坐标变换**  
   小鸡图标瞬间旋转45°，菱形→正方形，伴随“叮”音效。
2. **步骤2：扫描线滑窗**  
   一条红色扫描线从左到右移动，窗口内正方形高亮，BIT 数组在侧边用像素条展示区间和。
3. **步骤3：统计对数**  
   每找到一对可听见的小鸡，屏幕顶部“PAIR+1”像素字蹦出，累计到 8 位计分板。

### 交互面板
- **滑块**：控制扫描线速度。
- **按钮**：“单步 / 自动 / 重置”。
- **音效**：经典红白机“coin”音。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
1. **曼哈顿转切比雪夫**同样适用于：
   - 平面最近点对（旋转后转 KD-Tree）。
   - 最小生成树（曼哈顿边权→切比雪夫边权）。
   - 网格图最短路（菱形邻接→矩形邻接）。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P4636** [APIO2018] 选圆圈 | 二维曼哈顿距离 + 扫描线 + BIT 变形。 |
| **P4648** [IOI2007] pairs | 本题原题，巩固三维坐标变换。 |
| **P3810** 【模板】三维偏序 | 三维树状数组练手，体会 CDQ 分治 vs BIT。 |

---

## 7. 学习心得与经验分享

> **来自圣嘉然的调试心得**：  
> “3D-BIT 容斥写错两次，后来发现把坐标 +m 后值域上限要同步扩大，调试时打印中间 query 结果，一眼定位。”  
> **洛语云笺点评**：  
> 坐标变换后值域变化是易错点，统一加偏移量并用常量 `MAXM*3` 防越界，是实用小技巧。

---

## 结语
今天我们用“坐标变换”这把万能钥匙，打开了高维几何的大门；又用“扫描线”这把剪刀，剪开了复杂查询的包裹。记住：**维度不是障碍，而是变换的舞台**。下次遇到更高维的问题，不妨先想想能否升维打击！

---
处理用时：106.15秒
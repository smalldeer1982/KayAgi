# 题目信息

# [COCI 2015] Divljak

## 题目描述

Alice 有 $n$ 个字符串 ${S}_1, {S}_2, \ldots, {S}_n$，Bob 有一个字符串集合 ${T}$，一开始集合是空的。

接下来会发生 $q$ 个操作，操作有两种形式：

1. `1 P`：Bob 往自己的集合里添加了一个字符串 ${P}$。
2. `2 x`：Alice 询问 Bob，集合 ${T}$ 中有多少个字符串包含串 ${S}_x$（我们称串 ${A}$ 包含串 ${B}$，当且仅当 ${B}$ 是 ${A}$ 的子串）。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq n,q \leq 10^5$，字符串由小写字母构成，$S$ 和 $P$ 的总长分别 $\le 2 \times 10^6$。


## 样例 #1

### 输入

```
3
a
bc
abc
5
1 abca
2 1
1 bca
2 2
2 3
```

### 输出

```
1
2
1
```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[COCI 2015] Divljak 深入学习指南 💡

<intro>
今天我们来一起分析“Divljak”这道**字符串多模式匹配**题。它把 AC 自动机、树链剖分、树上差分、树状数组等经典算法巧妙地串成了一条“算法项链”。通过它，你将学会如何把“字符串包含查询”这一抽象问题，转化为一次次优雅的树上操作。
</intro>

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 要在 **动态** 插入的字符串集合 T 中，实时回答 **“有多少个字符串包含给定的 Sₓ”**。  
> 核心难点在于：  
> 1. 每个 Sₓ 可能作为子串在 T 中的某个字符串里出现 **多次**，但只应计数 **1 次**；  
> 2. 数据范围大（总串长 2×10⁶），暴力不可行。

✨ **核心算法标签**：  
AC 自动机 + fail 树 + 树链剖分 + 树上差分 + BIT/线段树（线性对数解法）

🗣️ **思路演进路径**  
- **暴力思路**：每次插入 T 后，对询问 Sₓ 逐一扫描 T 中所有串，复杂度爆炸。  
- **初步优化**：把 S 集合建成 AC 自动机，T 中每串跑自动机，打标记。但同一次插入需要避免重复计数。  
- **最优思路**：  
  1. 对 S 集合建 AC 自动机 → 得到 **fail 树**；  
  2. 把一次插入 P 在自动机上经过的所有节点 **去重** 后，做一次 **树链并集 +1** 操作；  
  3. 查询 Sₓ 的答案 → 在 fail 树上求 **子树和**。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：“统计包含” → 字符串匹配，AC 自动机天然适合。  
2. **线索2 (动态插入)**：数据结构必须支持 **在线** 修改 → 树状数组 / 线段树。  
3. **线索3 (去重计数)**：每个 P 对 S 的贡献是 **链并集** → 树上差分 + dfs 序排序 + LCA 去重。

### 🧠 思维链构建：从线索到策略
> “侦探”工作完成，把线索拼起来：  
> 1. 用 AC 自动机把“子串”问题转成 **fail 树上的链覆盖**；  
> 2. 为了“去重”，把 P 在自动机上经过的节点按 dfs 序排序，相邻 LCA 减 1；  
> 3. 用树链剖分 + BIT 把 **链修改** 变成 **子树和查询**，复杂度线性对数。

---

## 2. 精选优质题解参考

<eval_intro>
我从思路清晰度、代码规范性、启发性等维度，为大家筛选出 5 份高分题解（≥4星），并提炼精华。
</eval_intro>

| 作者 | 亮点提炼 |
|------|----------|
| **Calculatelove** | 完整实现了“fail 树 + 树链剖分 + BIT”的标准套路，代码简洁，变量命名清晰（`End[i]` 记录 Sᵢ 的终止节点）。 |
| **皎月半洒花** | 用生动的语言解释了“dfs 序排序 + LCA 差分”的动机，帮助理解“为什么必须排序”。 |
| **QwQ蒟蒻wjr** | 注释详尽，把“子树求和”写成 `query(dfn[u]+siz[u]-1) - query(dfn[u]-1)`，一目了然。 |
| **orz_z** | 用“虚树思想”一句话点破“dfs 序排序”的本质，代码风格统一，适合模仿。 |
| **Infiltrator** | 额外提供 **欧拉序 + ST 表 O(1) LCA** 的常数优化技巧，适合追求极限性能。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析 & 学习笔记 |
|--------|-----------------|
| **1. 构建 fail 树** | 把 AC 自动机的 `fail` 指针反向成边，得到一棵树。  
> 💡 学习笔记：fail 树上，祖先节点代表的串都是后代节点的**后缀**，这正是“子串包含”关系。 |
| **2. 树链并集 +1** | 对一次插入 P，在自动机上跑一遍得到节点序列，去重后按 dfs 序排序，相邻 LCA 减 1。  
> 💡 学习笔记：这一步把“链覆盖”转成“单点加”，避免重复计数。 |
| **3. 子树求和查询** | 用 dfs 序 + BIT/线段树，把“子树和”转成区间查询。  
> 💡 学习笔记：树链剖分让 LCA 和子树查询都变成 O(log n)。 |

### ✨ 解题技巧总结
- **技巧A：问题转化** → 把“字符串包含”转成“fail 树上的链覆盖”。  
- **技巧B：树上差分** → 把“链加”转成“单点加”，再用子树和还原。  
- **技巧C：dfs 序排序** → 保证链并集的正确性，避免重复/遗漏。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 复杂度 | 适用场景 |
|------|----------|--------|----------|
| **暴力 KMP** | 每插入一个 P，对所有 Sₓ 跑 KMP | O(∑|P|·∑|S|) | 数据 ≤ 10² |
| **SA + CDQ** | 后缀数组 + 三维数点 | O((|S|+|P|) log²) | 离线、思维难度高 |
| **AC 自动机 + fail 树** | 本文最优解 | O((|S|+|P|) log) | 在线、标准套路 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6 + 10;
int n, q, tot = 1, trie[N][26], fail[N], ed[N], dfn[N], siz[N], c[N];
vector<int> g[N];
void insert(char *s, int id) {
    int p = 1;
    for (int i = 1; s[i]; ++i) {
        int v = s[i] - 'a';
        if (!trie[p][v]) trie[p][v] = ++tot;
        p = trie[p][v];
    }
    ed[id] = p;
}
void build() {
    queue<int> q; q.push(1);
    for (int i = 0; i < 26; ++i) trie[0][i] = 1;
    while (!q.empty()) {
        int u = q.front(); q.pop();
        for (int i = 0; i < 26; ++i) {
            int v = trie[u][i];
            if (!v) trie[u][i] = trie[fail[u]][i];
            else fail[v] = trie[fail[u]][i], q.push(v);
        }
    }
    for (int i = 2; i <= tot; ++i) g[fail[i]].push_back(i);
}
void dfs(int u) {
    static int clk = 0;
    dfn[u] = ++clk; siz[u] = 1;
    for (int v : g[u]) dfs(v), siz[u] += siz[v];
}
// BIT
void add(int x, int v) { for (; x <= tot; x += x & -x) c[x] += v; }
int sum(int x) { int s = 0; for (; x; x -= x & -x) s += c[x]; return s; }
int lca(int x, int y) { /* 树剖求 LCA，略 */ return 0; }
int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) {
        scanf("%s", s + 1);
        insert(s, i);
    }
    build(); dfs(1);
    scanf("%d", &q);
    while (q--) {
        int op; scanf("%d", &op);
        if (op == 1) {
            scanf("%s", s + 1);
            vector<int> seq;
            for (int i = 1, p = 1; s[i]; ++i)
                p = trie[p][s[i] - 'a'], seq.push_back(p);
            sort(seq.begin(), seq.end(), [](int a, int b) { return dfn[a] < dfn[b]; });
            seq.erase(unique(seq.begin(), seq.end()), seq.end());
            for (int i = 0; i < seq.size(); ++i) {
                add(dfn[seq[i]], 1);
                if (i) add(dfn[lca(seq[i - 1], seq[i])], -1);
            }
        } else {
            int x; scanf("%d", &x);
            printf("%d\n", sum(dfn[ed[x]] + siz[ed[x]] - 1) - sum(dfn[ed[x]] - 1));
        }
    }
    return 0;
}
```

### 代码片段赏析（Calculatelove 版）
- **亮点**：用 `End[id] = p` 把字符串编号映射到节点，查询时直接 `sum(dfn[End[x]]...)`，简洁直观。  
- **学习笔记**：`dfn[u] + siz[u] - 1` 就是子树右端点，树链剖分模板用法。

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“像素探险家”在 fail 树上打标记**
- **场景**：8-bit 风格的 fail 树，节点为像素方块，边为绿色管道。  
- **交互**：  
  1. 插入字符串 P → 像素探险家沿 trie 移动，留下蓝色脚印；  
  2. 去重排序 → 脚印按 dfs 序排队；  
  3. 链覆盖 → 脚印到根节点的路径变红，LCA 处闪烁黄色“-1”；  
  4. 查询 Sₓ → 子树高亮，显示当前计数。  
- **音效**：  
  - 插入成功：`"叮！"`  
  - 查询答案：`"叮叮——"`（8-bit 胜利音）。  

---

## 6. 拓展练习与相似问题思考

### 通用套路迁移
1. **子串计数** → 可推广到“病毒特征码检测”（安全领域）。  
2. **链并集 +1** → 可用于“区间染色”类树问题。  
3. **dfs 序排序 + LCA 去重** → 虚树思想的入门案例。

### 洛谷推荐
- **P5357**【AC 自动机模板2】：巩固 fail 树子树求和。  
- **P4198**【楼房重建】：树上差分的另一种应用。  
- **P3834**【主席树】：区间数颜色问题的经典解法。

---

## 7. 学习心得与经验分享

> **来自皎月半洒花**：  
> “我一开始没排序 dfs 序，结果链并集算重。调试时把 fail 树打印出来，才发现排序的必要性。”  
> **洛语云笺点评**：  
> 当算法涉及“链并集”时，**dfs 序排序 + LCA 去重**是避免重复计数的黄金技巧，值得牢记！

---

<conclusion>
恭喜你！我们已经把一道看似复杂的字符串题，拆解成了“AC 自动机 + fail 树 + 树上差分”的优雅组合。记住：  
- **把字符串问题转成树问题**；  
- **把链操作转成子树和**；  
- **用 dfs 序和 BIT 实现高效维护**。  
下次遇到动态子串统计，你就知道该怎么“像素探险”啦！
</conclusion>

---
处理用时：70.64秒
# 题目信息

# 【模板】点分树 | 震波

## 题目背景

模板题，没有 $rap$ 。

## 题目描述

在一片土地上有 $n$ 个城市，通过 $n-1$ 条无向边互相连接，形成一棵树的结构，相邻两个城市的距离为 $1$，其中第 $i$ 个城市的价值为 $value_i$。

不幸的是，这片土地常常发生地震，并且随着时代的发展，城市的价值也往往会发生变动。

接下来你需要在线处理 $m$ 次操作：

`0 x k` 表示发生了一次地震，震中城市为 $x$，影响范围为 $k$，所有与 $x$ 距离不超过 $k$ 的城市都将受到影响，该次地震造成的经济损失为所有受影响城市的价值和。

`1 x y` 表示第 $x$ 个城市的价值变成了 $y$ 。

为了体现程序的在线性，操作中的 $x$、$y$、$k$ 都需要异或你程序上一次的输出来解密，如果之前没有输出，则默认上一次的输出为 $0$ 。



## 说明/提示

#### 数据规模与约定

对于 $100 \%$ 的数据，有 $1\leq n,m\leq 10^5, 1\leq u,v,x\leq n, 1\leq value_i,y\leq 10^4,0\leq k\leq n-1$ 。

upd：样例范围与题目真实数据范围不同，以提示中给出的数据范围为准。

#### 说明
题目来源：BZOJ3730。

## 样例 #1

### 输入

```
8 1
1 10 100 1000 10000 100000 1000000 10000000
1 2
1 3
2 4
2 5
3 6
3 7
3 8
0 3 1```

### 输出

```
11100101```

# AI分析结果

---
# 💡 洛语云笺的 C++ 算法解析：点分树 | 震波 深入学习指南 💡

> 今天我们来一起分析 **“点分树 | 震波”** 这道 C++ 编程题。  
> 这不仅仅是一次解题，更是一场思维的探险：  
> 如何在一棵会“地震”的树上，**在线**回答“震源周围 k 步内所有城市的价值和”？  
> 我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **在一棵 n 个节点的树上，支持两种在线操作：**  
> 1. `0 x k`：询问震源 x 周围 k 步以内所有点的价值和；  
> 2. `1 x y`：把城市 x 的价值改成 y。  
> **难点：** 强制在线（参数需异或上一次答案），n、m ≤ 1e5，暴力做法必然超时。

### ✨ 核心算法标签
- **点分树（动态点分治）**
- **树上倍增 LCA / 欧拉序 ST 表**
- **动态开点线段树 / 树状数组**

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：问题模型** | “带权树上距离 ≤ k 的点权和” → 典型的 **邻域查询** 问题。 |
| **线索2：在线操作** | 暴力 O(n) 查询、O(1) 修改显然不行 → 需要 **层次化** 或 **分治结构**。 |
| **线索3：数据规模** | n = 1e5 → O(n log²n) 可过；O(n²) 必死 → **点分树** 树高 log n，恰好满足！ |

---

### 🧠 思维链构建：从线索到策略
> 1. **线索1** 提示我们：**邻域求和** 可以用 **点分治** 离线解决。  
> 2. **线索2** 告诉我们：离线不可行，需要 **在线结构**。  
> 3. **线索3** 限制下，我们想到把 **点分治过程固化** 成 **点分树**：  
>    - 树高 O(log n)；  
>    - 每个节点维护 **到自身距离** 的前缀和（树状数组 / 线段树）；  
>    - 查询时沿点分树祖先一路容斥即可。  
> **结论**：**点分树 + 树状数组** 是完美的钥匙！

---

## 2. 精选优质题解参考

> 我综合了所有题解的清晰度、技巧性与启发性，为你精选以下 3 份 ≥4 星的高赞题解。

---

### ✅ 题解一：tzc_wk（赞：183）

- **亮点**  
  1. **思路最清晰**：用“枚举 LCA z”的方式，把原问题拆成 `z 子树内 ≤k-dis(x,z)` 的区间和。  
  2. **代码最规范**：变量命名直观，`w1`、`w2` 分别存“到当前点”和“到父亲”的贡献。  
  3. **技巧总结**：动态开点线段树 + 容斥公式，避免 O(n²) 空间。

- **核心代码片段**  
  ```cpp
  // 修改：沿点分树一路向上
  void modify(int x,int v){
      int cur=x;
      while(cur){
          w1.modify(w1.rt[cur],0,n-1,getdis(cur,x),v);
          if(dfa[cur]) w2.modify(w2.rt[cur],0,n-1,getdis(dfa[cur],x),v);
          cur=dfa[cur];
      }
  }

  // 查询：容斥公式
  int query(int x,int k){
      int cur=x,pre=0,ret=0;
      while(cur){
          if(getdis(cur,x)>k){ pre=cur; cur=dfa[cur]; continue; }
          ret += w1.query(w1.rt[cur],0,n-1,0,k-getdis(cur,x));
          if(pre) ret -= w2.query(w2.rt[pre],0,n-1,0,k-getdis(cur,x));
          pre=cur; cur=dfa[cur];
      } return ret;
  }
  ```

---

### ✅ 题解二：Ayiirep（赞：119）

- **亮点**  
  1. **教学级注释**：详细讲解“为什么需要两个 BIT”。  
  2. **调试经验**：提醒“continue 而非 break”的易错点。  
  3. **空间优化**：树状数组大小只开到子树最大深度 +2，防止 MLE。

- **学习笔记**  
  把 **子树深度** 作为树状数组上界，是点分树空间压缩的通用技巧。

---

### ✅ 题解三：NewJeanss（赞：9）

- **亮点**  
  1. **无需 LCA**：在 `finddep` 时直接记录 **到当前重心的距离**，省去 LCA 调用。  
  2. **vector 动态开点**：`vector<int> DS[2][N]` 写法简洁，易读易写。  
  3. **结构体封装**：`struct node {G,from,dis}` 把“覆盖结构”显式化。

- **核心代码片段**  
  ```cpp
  struct node{ int G,from,dis; };
  vector<node> a[N];          // 每个点被哪些重心“管辖”
  vector<int> DS[2][N];       // 0: 到重心  1: 到父亲
  ```

---

## 3. 解题策略深度剖析

---

### 🎯 核心难点与关键步骤（最优解法：点分树 + BIT）

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 点分树构建** | 递归找重心，把重心连成新树，树高 log n。 | 模板：findcent → divcent → dfs 建树父。 |
| **2. 数据结构选择** | 每个节点开 **两棵 BIT**：<br>- `BIT0[u]`：u 子树内到 u 距离的前缀和；<br>- `BIT1[u]`：u 子树内到 fa[u] 距离的前缀和。 | BIT 比线段树常数小，动态开 vector 防 MLE。 |
| **3. 查询容斥** | 沿点分树祖先链，累加 `BIT0`，减去 `BIT1` 去重。 | 公式：`ans += BIT0[anc] - BIT1[child]`。 |
| **4. 修改扩散** | 同样沿祖先链，两棵 BIT 同步单点更新。 | 每次修改 log² n，总复杂度 (n+m) log² n。 |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力 DFS** | 每次询问整棵子树 DFS | 代码最短 | O(n) 查询 → 1e10 次运算 | n≤5000 |
| **点分治离线** | 预处理所有询问 | O(n log n) 单次 | 无法在线 | 无强制在线 |
| **点分树 + BIT** | 把分治结构固化 | O(log² n) 操作 | 代码较长 | 100% |
| **全局平衡二叉树** | 链分治 + 簇合并 | 理论更优 | 实现复杂 | 100% |

---

### ✨ 优化之旅：从“能做”到“做好”

1. **起点：暴力 DFS**  
   直接 BFS/DFS 求 k 步以内点权和 → 10⁵×10⁵ 爆炸。

2. **发现瓶颈：重复遍历**  
   每次查询都重新遍历整棵树，大量重复劳动。

3. **钥匙：分治结构**  
   点分治把树切成 log n 层，每层只处理经过重心的路径。

4. **升华：固化结构**  
   把“分治树”存下来（点分树），每节点挂 BIT，  
   查询/修改沿祖先链 log 次，每次 BIT log 次 → log²。

---

## 4. C++ 核心代码实现赏析

---

### 🌟 本题通用核心实现参考

> 综合 tzc_wk、Ayiirep 的优点，给出一份 **最简洁、最易读** 的模板。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, LOG = 17;
int n, m, val[N], last_ans;
vector<int> g[N];

/* ---------- 1. 点分树 ---------- */
int sz[N], mx[N], vis[N], fa[N], root;
void find_root(int x, int f, int tot, int &rt) {
    sz[x] = 1, mx[x] = 0;
    for (int v : g[x]) if (!vis[v] && v != f) {
        find_root(v, x, tot, rt);
        sz[x] += sz[v];
        mx[x] = max(mx[x], sz[v]);
    }
    mx[x] = max(mx[x], tot - sz[x]);
    if (!rt || mx[x] < mx[rt]) rt = x;
}
void build(int x, int tot) {
    vis[x] = 1;
    for (int v : g[x]) if (!vis[v]) {
        int rt = 0;
        find_root(v, 0, sz[v] < sz[x] ? sz[v] : tot - sz[x], rt);
        fa[rt] = x;
        build(rt, sz[v] < sz[x] ? sz[v] : tot - sz[x]);
    }
}

/* ---------- 2. 距离 ---------- */
int dep[N], st[LOG + 1][N << 1], id[N], cnt;
void dfs_lca(int u, int f) {
    st[0][id[u] = ++cnt] = u;
    dep[u] = dep[f] + 1;
    for (int v : g[u]) if (v != f) {
        dfs_lca(v, u);
        st[0][++cnt] = u;
    }
}
inline int lca(int u, int v) {
    if (id[u] > id[v]) swap(u, v);
    int k = __lg(id[v] - id[u] + 1);
    int x = st[k][id[u]], y = st[k][id[v] - (1 << k) + 1];
    return dep[x] < dep[y] ? x : y;
}
inline int dis(int u, int v) {
    return dep[u] + dep[v] - 2 * dep[lca(u, v)];
}

/* ---------- 3. 树状数组 ---------- */
struct Fenwick {
    vector<int> c;
    Fenwick(int n) : c(n + 2) {}
    void add(int x, int v) {
        ++x;
        for (; x < (int)c.size(); x += x & -x) c[x] += v;
    }
    int ask(int x) {
        ++x;
        int res = 0;
        x = min(x, (int)c.size() - 1);
        for (; x; x -= x & -x) res += c[x];
        return res;
    }
};
vector<Fenwick> bit0, bit1;  // 0: 到 u   1: 到 fa[u]

/* ---------- 4. 初始化 ---------- */
void init() {
    dfs_lca(1, 0);
    for (int i = 1; i <= LOG; ++i)
        for (int j = 1; j + (1 << i) - 1 <= cnt; ++j) {
            int x = st[i - 1][j], y = st[i - 1][j + (1 << (i - 1))];
            st[i][j] = dep[x] < dep[y] ? x : y;
        }
    find_root(1, 0, n, root);
    build(root, n);
    bit0.resize(n + 1), bit1.resize(n + 1);
    for (int i = 1; i <= n; ++i) {
        int mx_dep = 0;
        for (int j = i, f = 0; j; f = j, j = fa[j]) {
            mx_dep = max(mx_dep, dis(i, j));
            bit0[j].c.resize(mx_dep + 2);
            if (fa[j]) bit1[j].c.resize(dis(i, fa[j]) + 2);
        }
    }
    for (int i = 1; i <= n; ++i) {
        for (int j = i; j; j = fa[j]) {
            bit0[j].add(dis(i, j), val[i]);
            if (fa[j]) bit1[j].add(dis(i, fa[j]), val[i]);
        }
    }
}

/* ---------- 5. 查询 & 修改 ---------- */
int query(int x, int k) {
    int res = bit0[x].ask(k);
    for (int u = x; fa[u]; u = fa[u]) {
        int d = dis(x, fa[u]);
        if (d <= k) {
            res += bit0[fa[u]].ask(k - d) - bit1[u].ask(k - d);
        }
    }
    return res;
}
void modify(int x, int v) {
    int delta = v - val[x];
    val[x] = v;
    for (int u = x; u; u = fa[u]) {
        bit0[u].add(dis(x, u), delta);
        if (fa[u]) bit1[u].add(dis(x, fa[u]), delta);
    }
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) cin >> val[i];
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    init();
    while (m--) {
        int op, x, y;
        cin >> op >> x >> y;
        x ^= last_ans, y ^= last_ans;
        if (op == 0) {
            cout << (last_ans = query(x, y)) << '\n';
        } else {
            modify(x, y);
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 本节设计一个 **8-bit 像素风格** 的动画，帮助你在“游戏画面”里看懂点分树查询。

### 🎮 场景设定：像素王国地震救援

- **像素画布**：320×240 像素，16 色调色板（复古 FC）。
- **角色**：  
  - 🟩 绿色像素块：普通城市  
  - 🔴 红色闪烁块：震源 x  
  - 🟦 蓝色圆环：当前 k 步范围（逐帧扩散）  
  - 🟨 黄色方块：点分树当前祖先节点  

### 🕹️ 交互控制面板

| 按钮 | 功能 |
|---|---|
| ▶️ 开始/暂停 | 播放/暂停动画 |
| ⏭️ 单步 | 逐帧查看每一步 |
| 🔄 重置 | 回到初始状态 |
| 🎚️ 速度滑块 | 1× / 2× / 4× |

---

### 📺 关键帧设计（10 帧示例）

| 帧 | 画面 | 音效 | 旁白文字 |
|---|---|---|---|
| 1 | 展示整棵像素树 | 8-bit BGM | “王国共有 8 座城市…” |
| 2 | 红色块在 3 号城 | 短“叮” | “震源位于城市 3” |
| 3 | 蓝色环扩散 1 步 | 轻微“哔” | “k=1，影响范围开始扩散” |
| 4 | 高亮 3 号城 BIT0 | “嗒” | “查询 3 号城 BIT0[1] = 10” |
| 5 | 跳父节点 1 | “嗒” | “跳到点分树父节点 1” |
| 6 | 高亮 1 号城 BIT0 | “嗒” | “累加 BIT0[1-2] = 100” |
| 7 | 高亮 1 号城 BIT1 | “嗒” | “减去 BIT1[1-2] = 1” |
| 8 | 跳父节点（根） | “嗒” | “继续向上到根 0” |
| 9 | 显示最终答案 | 胜利“噔” | “最终损失 11100101” |
| 10 | 回到城市界面 | BGM 循环 | “等待下一次地震…” |

---

### 🎵 音效脚本（Web Audio）

```js
const ctx = new AudioContext();
function beep(f, t) {
  const osc = ctx.createOscillator();
  osc.type = 'square';
  osc.frequency.value = f;
  osc.connect(ctx.destination);
  osc.start();
  osc.stop(ctx.currentTime + t);
}
// 关键帧触发
// beep(800, 0.1);   // 普通操作
// beep(1200, 0.15); // 胜利
```

---

## 6. 拓展练习与相似问题思考

### 🌱 通用思路迁移
- **邻域查询** 不止用于树上：  
  1. 二维平面曼哈顿距离 ≤ k 点权和（KD-Tree + BIT）。  
  2. 动态图连通块大小（Link-Cut Tree + 线段树）。  
  3. 带权并查集维护子树信息（DSU on Tree）。

### 📚 洛谷推荐

| 题号 | 推荐理由 |
|---|---|
| P2056 [ZJOI2007] 捉迷藏 | 点分树 + 堆，练习“最远点”维护。 |
| P3241 [HNOI2015] 开店 | 点分树 + 前缀和，无修改版。 |
| P3920 [WC2014] 紫荆花之恋 | 动态加点 + 点分树 + 平衡树，进阶挑战。 |

---

## 7. 学习心得与经验分享

> 摘录自高赞题解作者 **Ayiirep**：

> “初学点分树容易陷入误区：  
> - 以为 `dis(u,fa[u])` 单调，其实没有，**必须跳满祖先链**。  
> - 以为 BIT 只需一棵，实际需要 **两棵** 做容斥。  
> - 以为空间要 O(n²)，其实开到 **子树最大深度** 即可。”

---

## 💡 结语

> 从 **暴力 DFS** 到 **点分树 + BIT**，我们完成了 **思维的三级跳**：  
> 1. 发现问题 → 2. 寻找结构 → 3. 固化结构。  
> 记住：  
> **“优秀的算法，往往源于对问题结构的深刻洞察。”**  
> 下次地震来临时，你已准备好用点分树守护王国！

---
处理用时：131.38秒
# 题目信息

# [NOI1998] 免费的馅饼

## 题目描述

SERKOI 最新推出了一种叫做“免费馅饼”的游戏：游戏在一个舞台上进行。舞台的宽度为 $w$ 格（从左到右依次用 $1$ 到 $w$ 编号），游戏者占一格。开始时游戏者可以站在舞台的任意位置，手里拿着一个托盘。下图为天幕的高度为 $4$ 格时某一个时刻游戏者接馅饼的情景。

![](https://cdn.luogu.com.cn/upload/image_hosting/1gcg9awi.png)

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。

当馅饼在某一时刻恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。当馅饼落在一个游戏者不在的格子里时该馅饼就消失。

写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq w \leq 10^8$，$1 \leq n \leq 10^5$，$1\leq t_i \leq 10^8$，$1\leq p_i \leq w$，$1\leq v_i \leq 1000$。

## 样例 #1

### 输入

```
3 4
1 2 3
5 2 3
6 3 4
1 1 5
 ```

### 输出

```
12```

# AI分析结果

# 💡 洛语云笺的C++算法解析：NOI1998 免费馅饼 深入学习指南 💡

> 各位少年，欢迎来到“馅饼大冒险”！  
> 舞台很宽，馅饼从天而落，而我们的任务是在有限的时间里，用最快的脚步收集最大的价值。  
> 今天，我们将一起拆解这道经典题，从“贪心幻想”到“暴力现实”，再到“数据结构魔法”，体验一次完整的算法升级之旅！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
在宽度 ≤10⁸ 的舞台上，给定 ≤10⁵ 个馅饼的落点 (pᵢ) 和落地时间 (tᵢ)，以及价值 (vᵢ)。  
游戏者每秒可移动 0/1/2 格，求能获得的最大价值。

### ✨ 核心算法标签
- 动态规划 (DP)
- 二维偏序 + 数据结构优化
- 树状数组 / 线段树 / 离散化

### 🗣️ 初步思路演进
1. **贪心**：按时间排序，一路捡最大？→ 50 分，因为会错过更优组合。  
2. **暴力 DP**：O(n²) 枚举前驱 → 85 分，n=1e⁵ 时 1e¹⁰ 次运算爆炸。  
3. **正解**：把“能否从 j 走到 i”转化为二维偏序，用树状数组 O(n log n) 维护区间最大值。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **目标** | 最大化价值 → 动态规划/贪心 |
| **约束** | 移动距离 ≤2×时间差 → 绝对值不等式 |
| **数据范围** | n≤1e⁵ → 必须 ≤O(n log n) |
| **转化** | 把 `|pᵢ-pⱼ|≤2(tᵢ-tⱼ)` 拆成两条直线 → 二维偏序 |

### 🧠 思维链构建
> “我首先想到贪心，但很快发现会漏掉高价值馅饼；  
> 接着用 O(n²) 暴力 DP，能拿 85 分却过不了大数据；  
> 于是把条件拆成 `2t-p` 和 `2t+p` 两个维度，发现这正是二维偏序模板！  
> 最终，用树状数组维护前缀最大值，成功把时间降到 O(n log n)。”

---

## 2. 精选优质题解参考

> 以下 5 份题解在思路清晰度、代码规范、启发性上均≥4星，我们提炼精华供你快速吸收。

| 来源 | 亮点速读 | 关键技巧 |
|---|---|---|
| **xiezheyuan** | 先给贪心→暴力→正解三段式，树状数组推导清晰 | 用 `2t-p` 排序、`2t+p` 离散化 |
| **SSL_TJH_蒟蒻** | 详细解释“为什么两个不等式同时满足” | 二维偏序→树状数组求区间 max |
| **onglu** | 把坐标旋转成 LIS，思路飘逸 | 用斜率几何意义降维 |
| **鲨齿渊虹** | 分类讨论后树状数组+离散化模板 | 代码短、变量命名直观 |
| **Maverik** | 二维偏序+树状数组最简实现 | 一行 `lower_bound` 完成离散化 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（正解）
1. **把移动限制变成不等式**  
   `|pᵢ-pⱼ| ≤ 2(tᵢ-tⱼ)`  
   拆得：  
   `2tⱼ-pⱼ ≤ 2tᵢ-pᵢ` 且 `2tⱼ+pⱼ ≤ 2tᵢ+pᵢ`  
   💡 学习笔记：绝对值→两条直线，二维偏序雏形。

2. **离散化第二维**  
   值域 1e⁸ 太大，用 `lower_bound` 把 `2t+p` 压到 1…n。  
   💡 学习笔记：离散化是处理“大值域偏序”的万能钥匙。

3. **树状数组维护前缀最大值**  
   按 `2t-p` 升序处理，查询 `≤2tᵢ+pᵢ` 的最大 `dp` 值。  
   💡 学习笔记：先固定一维，再用数据结构维护另一维，经典二维偏序套路。

### ⚔️ 策略竞技场
| 策略 | 复杂度 | 实战得分 | 适用场景 |
|---|---|---|---|
| 贪心 | O(n log n) | 50 | 数据极弱或教学演示 |
| 暴力 DP | O(n²) | 85 | n≤3e3 的小数据 |
| 二维偏序+BIT | O(n log n) | 100 | 通用正解 |

### ✨ 优化之旅
> 从 O(n²) 到 O(n log n) 的跃迁：  
> 我们发现暴力重复枚举了大量“不可达”状态。  
> 把几何限制转成代数不等式后，问题立刻降维，  
> 再用树状数组“区间最大值”秒杀，  
> 这就是“问题转化+数据结构”带来的质变！

---

## 4. C++核心代码实现赏析

### 本题通用核心实现（参考 xiezheyuan & 鲨齿渊虹）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 10;

struct Pie { int t, p, v, x, y; } a[N];
int n, w, tmp[N], f[N], tr[N];

bool cmp(const Pie& a, const Pie& b) { return a.x > b.x; }
int lowbit(int x) { return x & -x; }
void upd(int x, int v) { for (; x <= n; x += lowbit(x)) tr[x] = max(tr[x], v); }
int qry(int x) { int r = 0; for (; x; x -= lowbit(x)) r = max(r, tr[x]); return r; }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> w >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i].t >> a[i].p >> a[i].v;
        a[i].x = a[i].p - 2 * a[i].t;
        tmp[i] = a[i].y = a[i].p + 2 * a[i].t;
    }
    sort(tmp + 1, tmp + n + 1);
    int m = unique(tmp + 1, tmp + n + 1) - tmp - 1;
    for (int i = 1; i <= n; ++i)
        a[i].y = lower_bound(tmp + 1, tmp + m + 1, a[i].y) - tmp;
    sort(a + 1, a + n + 1, cmp);
    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        f[i] = qry(a[i].y) + a[i].v;
        upd(a[i].y, f[i]);
        ans = max(ans, f[i]);
    }
    cout << ans << '\n';
    return 0;
}
```
- **代码解读概要**  
  1. 预处理 `x = p-2t`, `y = p+2t`  
  2. 离散化 `y`  
  3. 按 `x` 降序，树状数组查询 `≤y` 的最大 `f` 并更新  
  4. 输出全局最大值

---

## 5. 算法可视化：像素动画演示

> 主题：**《像素馅饼大作战》**  
> 风格：8 位红白机像素风，舞台 32×16 格，馅饼为 8×8 黄色方块，玩家为红色小人。

### 动画步骤
1. **初始化**  
   - 舞台网格 + 时间轴滚动  
   - 控制面板：开始 / 单步 / 重置 / 调速滑块
2. **数据映射**  
   - 每个馅饼映射为 (x, y) = (2t-p, 2t+p) 的像素坐标
3. **二维偏序演示**  
   - 像素箭头按 x 降序扫描  
   - 树状数组用绿色条形高度表示区间最大值  
   - 每成功转移，播放“叮”音，馅饼高亮闪金光
4. **AI 自动演示**  
   - 类似“贪吃蛇”自动寻找最优路径  
   - 背景音乐：8 位 chiptune《Pixel Victory》
5. **完成动画**  
   - 收集完所有可达馅饼后，屏幕中央出现“MAX VALUE GET!”像素横幅  
   - 胜利音效 + 礼花

> 实现提示：用 Canvas 2D API，颜色表 `#000 #5f5 #ff5 #fff`，音效用 Web Audio 生成方波。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- 二维偏序 + BIT 可解决：
  1. 最长上升子序列 (LIS)  
  2. 区间调度最大权独立集  
  3. 平面最近点对统计

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P1439 【模板】最长上升子序列 | 纯 LIS，体验离散化+BIT |
| P3378 【模板】树状数组 1 | 掌握单点修改、区间查询 |
| P4198 楼房重建 | 二维偏序进阶，斜率优化 |

---

## 7. 学习心得与经验分享
> 摘录自 **xiezheyuan**：  
> “贪心 50 分让我意识到‘局部最优≠全局最优’；  
> 暴力 85 分告诉我‘复杂度是硬门槛’；  
> 最终用二维偏序+BIT 拿到 100 分，深刻体会‘问题转化+数据结构’才是解题王道。”

---

<conclusion>
恭喜你完成本次“馅饼大冒险”！  
记住：遇到绝对值不等式，先拆维度；遇到大值域，先离散化；遇到二维偏序，树状数组是最佳拍档。  
下次见，继续一起打怪升级！💪
</conclusion>

---
处理用时：65.89秒
# 题目信息

# [北大集训 2021] 经典游戏

## 题目背景

CTT2021 D4T2

## 题目描述

某天，`C` 和 `K` 觉得很无聊，于是决定玩一个经典小游戏：

在一棵有 $n$ 个结点的有根树上，标号为 $i$ 的节点上有 $a_i$ 个棋子。游戏时玩家轮流操作，每次可以将任意一个节点 $u$ 上的一个棋子放置到任意一个点 $v \in U(u)$上，其中 $U(u)=subtree\{u\}\setminus\{u\}$ ，表示 $u$ 的子树内（不包含 $u$ 本身）的点组成的集合。不能进行操作者失败。

而 `C` 和 `K` 作为 `P**` 和 `T**` 的在读学生，这种一眼就能找出必胜策略的游戏实在是索然无味，于是两人觉得，每个人给自己一个特殊能力可能会比较有趣：

`C` 在开始游戏之前，**可以选择**将当前树的树根 $R$ 换到与 $R$ 相邻的任意一个点 $R^{\prime}$ 上。定义两个点相邻当且仅当这两个点有边直接相连。

`K` 在开始游戏之前，**必须选择**树上的一个节点，在上面加上一颗棋子。

`C` 和 `K` 决定玩 $m$ 局游戏。每局游戏的流程如下：

1. 游戏开始前，`C` 和 `K` 会商量好，先在标号为 $x$ 的节点上放上一个棋子，然后将树根设为 $y$。
2. 之后 `C` 可以选择是否发动特殊能力，`C` 决策完之后 `K` 可以选择是否发动特殊能力。
3. 特殊能力的决策结束后，会在这棵树上进行一局 `C` 先手、`K` 后手的游戏。游戏完成后会将树上棋子的状态**还原到流程 `1` 结束后的状态**。

`C` 觉得这个游戏可以出成一个简单题，于是他决定考考你：`C` 在每局游戏的第二步的时候，有多少种决策方式使得不管 `K` 如何进行特殊能力的操作，开始游戏时都存在**必胜策略**？两种决策方式不同，**当且仅当**两种决策**更换的树根** $R^{\prime}$ **不同**，或者**两者中仅有一个没有发动特殊能力**。


## 说明/提示

| 子任务分数 | $1\le n,m\le$ | $\max\{a_1,a_2,\dots,a_n\}\le$ |              特殊性质              |
| :--------: | :-----------: | :----------------------------: | :--------------------------------: |
|    $16$    |      $5$      |              $1$               |                 无                 |
|    $15$    |     $300$     |              $1$               |                 无                 |
|    $14$    |    $5000$     |             $10^9$             |                 无                 |
|    $13$    |   $100000$    |             $10^9$             |        保证给出的树是一条链        |
|    $12$    |   $100000$    |             $10^9$             | 保证给出的树存在一个点度数为 $n-1$ |
|    $11$    |   $100000$    |             $10^9$             |   保证 $m$ 次游戏初始给定根一致    |
|    $10$    |   $500000$    |             $10^9$             |                 无                 |
|    $9$     |   $1000000$   |             $10^9$             |                 无                 |




## 样例 #1

### 输入

```
0
5 2
1 2
1 3
2 4
2 5
1 0 1 0 1
2 2
4 4```

### 输出

```
2
1
```

## 样例 #2

### 输入

```
0
10 10
6 3
7 4
8 2
2 1
9 1
1 3
3 4
4 5
5 10
0 0 1 1 1 0 1 1 0 0 
8 3
2 3
7 10
7 3
6 7
8 5
9 8
2 10
5 4
3 9
```

### 输出

```
1
1
0
1
1
1
0
0
2
1
```

# AI分析结果

# 💡 洛语云笺的C++算法解析：经典游戏 深入学习指南 💡

> 今天我们来一起分析「经典游戏」这道北大集训题。它表面上是一场博弈，骨子里却是一道高阶数据结构题。我们将学习如何把博弈论、树形结构、换根技巧、长链剖分、Trie 树、树状数组等多个知识点像拼乐高一样拼在一起，形成一条完整的解题链。

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
在一棵有根树上，棋子可以沿子树向下移动。给定每局游戏的初始根 `y` 与初始加子位置 `x`，**C** 可以选择是否把根换到相邻节点，**K** 随后可以选择是否在任意节点再加一枚棋子。C 要统计**无论 K 怎么加子**，C 都必胜的「换根方案」数量（最多 3 种：不动、换到某个邻居）。

### ✨ 核心算法标签
- 博弈论（SG 定理）
- 树形 DP（换根、长链剖分）
- 数据结构（01-Trie + BIT/线段树）
- 区间异或 + 邻域查询

---

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 解读 |
|---|---|
| **1. 游戏胜负** | “不能操作者失败” ⇒ 标准 ICG ⇒ SG 定理 |
| **2. 棋子移动规则** | 只能往子树内移动 ⇒ 每个棋子的 SG = 该点到子树内最远距离 |
| **3. 附加操作** | C 可以换根，K 可以加子 ⇒ 需要动态维护**以任意点为根**时的总 SG |
| **4. 数据范围** | 1e6 ⇒ 必须做到 **O((n+m) log n)** |

### 🧠 思维链构建
1. 先抛开特殊能力，算出固定根时的 SG 值。  
2. 发现 K 的加子等价于在任意节点把总 SG 异或上该点的 SG；若异或后变成 0 则 K 胜。  
3. 因此 C 必胜的充要条件是：  
   **max{ SG_u } < 总 SG**（K 无法一步把总 SG 变成 0）。  
4. 问题转化为：  
   支持单点翻转颜色（0/1），查询「以 `y` 为中心，半径 1 的邻域内」满足 `max_SG < total_SG` 的点数。  
5. 需要同时维护  
   - 以任意点为根时的 **总 SG**（区间异或，单点查）。  
   - 以任意点为根时的 **max_SG**（换根 DP）。  
   - 邻域内 3 种 max_SG 值对应的 **01-Trie** 统计。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|---|---|
| **Licykoc (赞 5)** | 首创「换根+长剖+Trie」组合；用 dfs 序把树切成若干区间，再用 BIT 维护全局异或；对轻儿子统一处理，重儿子暴力判。代码结构清晰，常数优秀。 |
| **Alex_Wei (赞 2)** | 同样长剖思路，但把「邻域三种 max_SG」显式拆成 Trie[0/1/2]；实现更紧凑，注释详细，易读性强。 |
| **CarroT1212 (赞 1)** | 不用长剖，改用「直径端点」思想，把 max_SG 拆成三类；用两个 BIT + 三棵 Trie 完成；思路另类，适合拓展视野。 |
| **tribool4_in & Leasier** | 将换根 DP、区间异或、01-Trie 封装得模块化；可作为模板参考。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. SG 函数推导** | 每个棋子的 SG = 该点到子树内最远距离（不含自身）。证明：该点可移动到子树内任意更深层，等价于 Nim 堆大小。 | 树上博弈先找 SG，再套 SG 定理。 |
| **2. 换根 DP** | 两遍 DFS 求出以 1 为根时的 `mx[u]`（子树最远距离）与 `se[u]`（次远距离）。<br>换根时若从 `u→v`，只有 `u` 与 `v` 的链上受影响，其余子树可批量更新。 | 换根 DP 模板：先自底向上，再自顶向下。 |
| **3. 区间异或维护总 SG** | 翻转 `a[x]` 的奇偶性时：<br>- 子树内所有点的总 SG 异或 `mx_out[x]`（子树外最远距离）。<br>- 子树外异或 `mx_in[x]`（子树内最远距离）。<br>用 BIT 维护 dfs 序区间异或即可。 | 区间异或 + 单点查是树上换根的常用套路。 |
| **4. 邻域查询** | 以 `y` 为中心，邻域最多 3 种 max_SG：`mx[y]-1, mx[y], mx[y]+1`。<br>把对应儿子的「总 SG 异或值」塞到 Trie 里，查询时二分统计即可。 | 01-Trie 支持「异或后大于某数」的经典操作。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 复杂度 | 适用场景 |
|---|---|---|---|
| **暴力** | 枚举所有根，重新计算 SG | O(n²) | n ≤ 300 |
| **换根 DP + BIT** | 区间异或维护总 SG | O(n log n) | 无邻域查询 |
| **换根 DP + BIT + Trie** | 邻域三种 max_SG 统一处理 | O((n+m) log n) | 正解 |

---

## 4. C++核心代码实现赏析

### ✅ 通用核心实现（基于 Alex_Wei 思路，精简版）
```cpp
#include <bits/stdc++.h>
using namespace std;
constexpr int N = 1e6 + 5, K = N << 5;
int n, m, a[N];
vector<int> e[N];

// ================= 01-Trie =================
namespace Trie {
    int node, ch[K][2], val[K];
    void modify(int bit, int &x, int c, int v, int s) {
        if (!x) x = ++node;
        if (!bit) return;
        int bc = c >> (bit - 1) & 1, bv = v >> (bit - 1) & 1;
        if (!bv) {
            if (!ch[x][bc ^ 1]) ch[x][bc ^ 1] = ++node;
            val[ch[x][bc ^ 1]] += s;
            modify(bit - 1, ch[x][bc], c, v, s);
        } else {
            modify(bit - 1, ch[x][bc ^ 1], c, v, s);
        }
    }
    int query(int bit, int x, int v) {
        if (!x || !bit) return val[x];
        return val[x] + query(bit - 1, ch[x][v >> (bit - 1) & 1], v);
    }
}

// ================= BIT 维护异或 =================
struct BIT {
    int c[N];
    void add(int x, int v) { for (; x <= n; x += x & -x) c[x] ^= v; }
    void add(int l, int r, int v) { add(l, v); add(r + 1, v); }
    int qry(int x) { int s = 0; for (; x; x -= x & -x) s ^= c[x]; return s; }
} tr;

// ================= 换根 DP =================
int mx[N], sf[N], g[N], son[N], fa[N], dfn[N], sz[N], dt;
void dfs1(int u, int f) {
    dfn[u] = ++dt; fa[u] = f; sz[u] = 1;
    for (int v : e[u]) if (v != f) {
        dfs1(v, u); sz[u] += sz[v];
        if (mx[v] + 1 > mx[u]) sf[u] = mx[u], mx[u] = mx[v] + 1, son[u] = v;
        else sf[u] = max(sf[u], mx[v] + 1);
    }
}
void dfs2(int u) {
    g[u] = max(mx[u], g[fa[u]]);
    for (int v : e[u]) if (v != fa[u]) {
        int w = (v == son[u]) ? sf[u] : mx[u];
        g[v] = max(g[u], w) + 1;
        dfs2(v);
    }
}

// ================= 主程序 =================
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int _; cin >> _ >> n >> m;
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        e[u].push_back(v); e[v].push_back(u);
    }
    for (int i = 1; i <= n; ++i) cin >> a[i], a[i] &= 1;

    dfs1(1, 0); dfs2(1);

    // 初始 SG 值
    int sg = 0;
    for (int i = 1; i <= n; ++i) if (a[i]) sg ^= mx[i];

    // 预处理每个点的 Trie 根
    vector<int> root(n + 1);
    for (int u = 1; u <= n; ++u) {
        for (int v : e[u]) {
            if (v == fa[u] || v == son[u]) continue;
            Trie::modify(20, root[u], 0, 0, 1);
        }
    }

    auto flip = [&](int x) {
        int tmp = mx[x] ^ sf[x];
        if (son[x]) {
            tr.add(dfn[son[x]], dfn[son[x]] + sz[son[x]] - 1, tmp);
        }
        sg ^= mx[x];
    };

    auto query = [&](int y) {
        int now = sg ^ tr.qry(dfn[y]);
        int ans = 0;
        if (now > mx[y]) ++ans;
        if (fa[y] && (now ^ tr.qry(dfn[fa[y]])) > mx[fa[y]]) ++ans;
        if (son[y] && (now ^ tr.qry(dfn[son[y]])) > mx[son[y]]) ++ans;
        ans += Trie::query(20, root[y], now);
        return ans;
    };

    while (m--) {
        int x, y; cin >> x >> y;
        flip(x);
        cout << query(y) << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 场景设定
**像素探险家**站在一棵 8×8 的像素树上，每个节点是一颗发光方块，颜色代表当前 SG 值。玩家通过「换根按钮」把树根移动到相邻节点，观察「必胜区域」如何实时闪烁。

### 🎯 动画流程
| 帧 | 画面 | 音效 | 说明 |
|---|---|---|---|
| 1 | 初始化：根在节点 1，节点颜色按 SG 值渐变 | 8-bit 启动音 | 展示初始状态 |
| 2 | 翻转节点 3 的颜色（黑→白） | “叮” | 触发区间异或，部分节点闪烁 |
| 3 | 把根从 1 移到 2 | “嗖” | 换根 DP 更新，新的必胜区域高亮 |
| 4 | 弹出计数器：当前有 2 个合法根 | “胜利”音 | 展示查询结果 |

### 🕹️ 交互面板
- **单步/自动** 按钮：逐帧或连续播放
- **速度滑块**：1×~8×
- **节点悬停**：显示 SG 值、总 SG、max_SG

---

## 6. 拓展练习与相似问题思考

| 通用套路 | 场景举例 |
|---|---|
| 换根 DP | 求「以任意点为根」时的子树信息（如子树最大值、子树和） |
| 01-Trie 异或统计 | 区间查询「异或某数后大于 k 的个数」 |
| 树上博弈 SG | 石子只能向下移动的树上 Nim |

### 🏆 洛谷推荐
- **P3809** 【模板】后缀数组（练倍增 + 换根思想）
- **P4211** 【模板】01-Trie（练异或统计）
- **P4319** 树的重心（换根 DP 经典）
- **P6329** 【模板】长链剖分（练维护子树最值）

---

## 7. 学习心得与经验分享

> **Alex_Wei 调试心得**：  
> “最初在维护轻儿子 Trie 时忘记处理父亲标记，导致样例 2 输出全 0。用 `cerr` 打印每个点的 `S_v` 和 `mx_v`，才发现是异或值没有下传。提醒：**区间异或+单点查**时，别忘了全局标记！”

> **洛语云笺点评**：  
> 调试树上数据结构，**可视化 dfs 序区间**是最有效的手段。把树拍平成数组后，用 `gdb` 或打印区间值，能一眼看出哪段异或漏了。

---

<conclusion>
经典游戏把「博弈 + 换根 + 数据结构」巧妙融合。掌握它，你就拥有了：
- 快速识别树上博弈模型的能力
- 熟练使用换根 DP 和区间数据结构的技巧
- 在百万级数据下优雅解决问题的自信

继续刷题，下次见！

---
处理用时：97.78秒
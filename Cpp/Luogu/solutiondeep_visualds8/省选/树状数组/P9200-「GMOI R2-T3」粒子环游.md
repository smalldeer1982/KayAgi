# 题目信息

# 「GMOI R2-T3」粒子环游

## 题目背景

热爱珂学的小 Z 正在进行一项无聊的实验。

## 题目描述

实验室中有一个由 $n$ 个实验腔连接而成的环形轨道，其中第 $i$ 个实验腔顺时针连向第 $i+1$ 个实验腔（特别的，第 $n$ 个实验腔连向第 $1$ 个实验腔）。同时还有一个标号为 $n+1$ 的新建实验腔要接入这个环形轨道。它可以接在任意两个原本相连的实验腔之间。

第 $i$ 个实验腔可以将带电荷量为 $Q$ 的粒子运输到它的下一个实验腔，这个过程花费的能量为 $\vert Q \vert \times c_i$。除此之外，第 $i$ 个实验腔本身就存储了量为 $e_i$ 的电荷（电荷量有正负）。由于众所周知的电荷守恒定律，第 $n+1$ 个实验腔储存的电荷量与前 $n$ 个实验腔储存的总电荷量的代数和为 $0$。

小 Z 有一个原本不带电的粒子。等到第 $n+1$ 个实验腔接入轨道后，他要任选一个实验腔（包括第 $n+1$ 个）作为出发点，将粒子放入，并使之在实验腔的能量驱动下顺时针环游一周回到出发点。粒子每到达一个实验腔（包括出发点），它所带电荷量就会变成原来所带的电荷量和这个实验腔所储存的电荷量的代数和。

**注意：电荷量会先加上实验腔所含电荷量，再计算能量贡献。**

现在，小 Z 想知道，在所有接入新建实验腔并选定出发点的方案中，粒子环游一周所需的能量最少为多少？

## 说明/提示

样例 $1$ 解释：一种最优方案为将 $4$ 号实验腔接在 $3$ 号实验腔与 $1$ 号实验腔之间，以 $4$ 号实验腔为出发点，花费能量为 $ 1\times 2\ +\ 4\times 1\ + \vert -1 \vert \times 3 \ +\ 0 \times 2 =9$。

**本题采用 Subtask 捆绑测试。**

| Subtask | $n\le$ | $c_i\le$ | $\vert e_i\vert$ | 特殊性质 | 对应测试点 | 总分 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $300$ | $100$ | $100$ | $-$ | $1\sim 5$ | $10$ |
| $1$ | $10^3$ | $10^3$ | $10^3$ | $\bf A$ | $6\sim 7$ | $5$ |
| $2$ | $10^4$ | $10^4$ | $10^4$ | $-$ | $8\sim12$ | $15$ |
| $3$ | $10^5$ | $10^5$ | $10^5$ | $\bf B$ | $13\sim 16$ | $10$ |
| $4$ | $2.5\times 10^5$ | $10^5$ |$10^5$ | $-$ | $17\sim 25$ | $60$ |

特殊性质 $\bf A$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=0$。

特殊性质 $\bf B$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=1$。

对于 $100\%$ 的数据，$1\le n\le 2.5\times 10^5$，$0\le c_i\le 10^5$，$0\le |e_i|\le 10^5$。

保证答案在 long long 范围内。

## 样例 #1

### 输入

```
3
1 3 2 2
3 -5 1```

### 输出

```
9```

## 样例 #2

### 输入

```
12
4 7 7 8 8 4 5 5 9 10 1 1 10 
0 -5 7 8 1 -1 -6 8 2 4 10 8 ```

### 输出

```
509```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「GMOI R2-T3」粒子环游 深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“环形轨道 + 插入新节点 + 任一起点” 的三重自由度，使得我们必须同时决定  
1. 新实验腔插在哪两个腔之间，  
2. 粒子从哪一个腔出发，  
3. 如何快速计算一整圈能量和的最小值。  

✨ **核心算法标签**：前缀和、带权中位数、线段树 / 树状数组、离散化、滑动窗口思想  

🗣️ **初步分析**：  
如果把实验腔按顺时针拉成一条链，插入新腔相当于在某处“切开”并塞进一个元素；而任一起点又相当于把这条链旋转。  
于是问题转化为：  
> 给定一条 **长度 n+1 的链**（含新腔），每个位置 i 有坐标 sᵢ 与权值 cᵢ，求  
> minₚ Σ |sᵢ – sₚ| × cᵢ。  

这正是经典的 **带权中位数** 问题！  
我们可以枚举插入位置（O(n)），再用数据结构在 **O(log n)** 内求出当前链的最小 Σ|…|。  
整体复杂度 O(n log n)，可过 n ≤ 2.5×10⁵。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**  
   “在所有方案中求最小能量” → 最小化 Σ|sᵢ – sₚ|·cᵢ，一眼带权中位数。
2. **线索2 (环形与插入)**  
   环形 → 断环成链；插入 → 枚举断点；旋转 → 枚举起点 → 前缀和差即可。
3. **线索3 (数据规模)**  
   n ≤ 2.5×10⁵，O(n²) 必死，O(n log n) 可行 → 数据结构维护中位数。

### 🧠 思维链构建：从线索到策略
1. 看到“最小化绝对值加权和” → 带权中位数模型。  
2. 看到“插入位置未知” → 枚举插入位置，链条长度仅 n+1，可承受。  
3. 看到“起点未知” → 起点即中位数，可用线段树 / BIT 在 log n 内求。  
4. 看到“前缀和会随插入位置变化” → 每次只有相邻两项被修改，可用 **滑动修改 + 数据结构** 维护。  
5. 结论：**枚举插入 + 数据结构维护带权中位数** 是最优雅的路径！

---

## 2. 精选优质题解参考

| 题解 | 核心亮点 | 洛语云笺点评 |
|---|---|---|
| **yinhy09 (官方)** | 用 **四个树状数组** 维护前缀和与权值，实现 **O(n log² n)**；思路严谨，适合学习 BIT 的高级用法。 | 把绝对值拆成“左右两段”，用前缀和化乘为加，非常漂亮的数学推导。 |
| **_Fatalis_** | 完整讲述 **从暴力到正解** 的渐进思考；用 **动态开点线段树** 维护带权中位数，代码清晰。 | 把“插入位置”→“交换相邻两项”→“线段树单点修改”解释得通俗易懂，适合新手。 |
| **Aiopr_2378** | 将点权拆成 **cᵢ 个权为 1 的点**，直接套用经典中位数结论；用 **动态开点线段树** 实现 **O(n log V)**。 | 拆权技巧非常巧妙，把复杂问题瞬间化简为“找第 k 小”，值得收藏。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **1. 断环成链 + 前缀和** | 把环看成 1…n+1 的链，插入新腔即在某处插入 (eₙ₊₁, cₙ₊₁)。起点 p 的环游能量 = Σ|sᵢ – sₚ|·cᵢ。 | 环形问题常用技巧：固定一个断点，旋转用差值表示。 |
| **2. 带权中位数** | 在数轴上，若总权 Σcᵢ 为 tot，则最优 p 满足左侧权 ≥ ⌈tot/2⌉ 且右侧 ≥ ⌊tot/2⌋。可用线段树二分或 BIT 二分。 | 经典结论：最小化 Σ|x – aᵢ|·wᵢ 的 x 就是带权中位数。 |
| **3. 滑动修改** | 枚举插入位置 i 时，只需交换相邻两项的 (e, c)，前缀和数组 s 仅两项被修改，线段树两次单点更新即可。 | 每次只动 O(1) 个元素，保证整体 O(n log n)。 |

### ✨ 解题技巧总结
- **技巧A：问题转化**  
  把“环形 + 插入 + 任一起点”→“线性链 + 枚举断点 + 中位数”。
- **技巧B：数据结构辅助**  
  线段树 / BIT 维护“前缀和 × 权值”和“权值和”，支持 log n 查询区间和与二分中位数。
- **技巧C：离散化**  
  值域可能到 5×10¹⁰，需离散化或动态开点。

### ⚔️ 策略竞技场
| 策略 | 思想 | 优点 | 缺点 | 得分 |
|---|---|---|---|---|
| **暴力 O(n³)** | 枚举插入、枚举起点、O(n) 求和 | 思路直观 | 2.5e5 必 TLE | 0 |
| **暴力 O(n²)** | 枚举插入 O(n) + 枚举起点 O(n) | 实现简单 | 2.5e5 仍 TLE | 10 |
| **带权中位数 + BIT** | O(n log² n) | 常数小 | 需要 4 个 BIT | 100 |
| **带权中位数 + 线段树** | O(n log n) | 代码简洁 | 动态开点略大 | 100 |

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
- **说明**：综合 _Fatalis_ 与 Aiopr_2378 思路，采用 **动态开点线段树** 维护带权中位数，时间 O(n log n)。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2.5e5 + 5;
const ll V = 2.5e14;
int n, rt, tot;
ll c[N], e[N], s[N], ans = 1e18;

struct Node { int ls, rs; ll sz, sum; } t[N * 40];
#define mid (l + r >> 1)
void upd(int &p, ll l, ll r, ll pos, ll k) {
    if (!p) p = ++tot;
    t[p].sz += k;
    t[p].sum += pos * k;
    if (l == r) return;
    pos <= mid ? upd(t[p].ls, l, mid, pos, k)
               : upd(t[p].rs, mid + 1, r, pos, k);
}
ll kth(int p, ll l, ll r, ll k) {          // 找带权中位数
    if (l == r) return l;
    return k <= t[t[p].ls].sz ? kth(t[p].ls, l, mid, k)
                              : kth(t[p].rs, mid + 1, r, k - t[t[p].ls].sz);
}
ll qry(int p, ll l, ll r, ll ql, ll qr, ll &sz, ll &sum) {
    if (!p || qr < ql) return sz = sum = 0;
    if (ql <= l && r <= qr) { sz = t[p].sz; sum = t[p].sum; return 0; }
    ll sz1, sum1, sz2, sum2;
    qry(t[p].ls, l, mid, ql, qr, sz1, sum1);
    qry(t[p].rs, mid + 1, r, ql, qr, sz2, sum2);
    sz = sz1 + sz2, sum = sum1 + sum2;
    return 0;
}
ll calc() {
    ll all = 0; for (int i = 1; i <= n + 1; ++i) all += c[i];
    ll pos = kth(rt, -V, V, (all + 1) / 2);
    ll szL, sumL, szR, sumR;
    qry(rt, -V, V, -V, pos, szL, sumL);
    qry(rt, -V, V, pos + 1, V, szR, sumR);
    return (szL * pos - sumL) + (sumR - szR * pos);
}
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n + 1; ++i) cin >> c[i];
    for (int i = 1; i <= n; ++i) cin >> e[i];
    e[n + 1] = 0; for (int i = 1; i <= n; ++i) e[n + 1] -= e[i];
    for (int i = 1; i <= n + 1; ++i) s[i] = s[i - 1] + e[i];
    for (int i = 1; i <= n + 1; ++i) upd(rt, -V, V, s[i], c[i]);
    ans = calc();
    for (int i = n; i >= 1; --i) {                // 滑动插入位置
        upd(rt, -V, V, s[i], -c[i]);
        upd(rt, -V, V, s[i + 1], -c[i + 1]);
        s[i] -= e[i] - e[n + 1];
        swap(c[i], c[i + 1]);
        upd(rt, -V, V, s[i], c[i]);
        upd(rt, -V, V, s[i + 1], c[i + 1]);
        ans = min(ans, calc());
    }
    cout << ans << '\n';
    return 0;
}
```
- **代码解读概要**：  
  1. 用 `s[i]` 表示从节点 1 到节点 i 的电荷前缀和，新腔插入即修改相邻两项。  
  2. 动态开点线段树维护 `(sᵢ, cᵢ)`，支持插入/删除、查询带权中位数。  
  3. `calc()` 用经典公式 **(szL·pos – sumL) + (sumR – szR·pos)** 计算当前答案。  
  4. 从后往前滑动插入位置，仅修改 O(1) 个元素，保证总复杂度 O(n log n)。

---

## 5. 算法可视化：像素动画演示

- **主题**：《像素粒子环游记》  
- **场景**：8×8 像素网格模拟实验腔，粒子顺时针移动，能量条实时跳动。  
- **关键帧**：
  1. 初始化：n 个像素舱围成环，新舱以闪烁像素插入。  
  2. 枚举插入：插入位置高亮，环被拉直成链。  
  3. 带权中位数：所有 `sᵢ` 像素在数轴上排队，线段树节点闪动，中位数舱被金色框选中。  
  4. 能量计算：粒子从起点出发，每经过一个舱，能量条增长 `|Q|×cᵢ` 的像素高度。  
  5. 滑动更新：仅需交换相邻两项，像素舱位置互换，线段树节点重新着色。  
- **交互**：  
  - 单步 / 自动播放按钮（FC 手柄风格）。  
  - 速度滑块（1× / 2× / 4×）。  
  - 音效：8-bit “叮” 表示插入，“咚” 表示能量累加。  
- **游戏化**：  
  - 每完成一次插入 + 中位数选取视为“通关”。  
  - 通关后播放胜利 8-bit 音乐，显示“Best Energy = xxx”。

---

## 6. 拓展练习与相似问题思考

- **通用思路迁移**：  
  带权中位数可处理“选址问题”：超市、仓库、公交站选址，要求最小化顾客总距离。  
- **洛谷推荐**：
  1. **P2893** [USACO08FEB] Cow Neighborhoods  
     用带权中位数思想维护区间最值。  
  2. **P3396** 哈希冲突  
     离散化 + 线段树维护带权信息。  
  3. **P4559** [JSOI2018] 战争  
     环形问题断环成链 + 数据结构优化枚举。  

---

## 7. 学习心得与经验分享

> **_Fatalis_ 的踩坑记录**：  
> “我最开始把 `s[i]` 与 `c[i]` 的下标搞混，导致线段树查询结果异常。  
> 后来用 `assert` 打印 `szL, sumL` 才发现问题：离散化映射写错。  
> 提醒同学们：**先写暴力对拍**，再上线段树，能减少 90% 调试时间！”

**洛语云笺点评**：  
把复杂数据结构拆成“小对拍”是极好的习惯，尤其涉及离散化时，务必验证映射唯一性与正确性。

---

<conclusion>
今天我们用“断环成链 + 带权中位数”这把钥匙，打开了看似复杂的粒子环游问题。  
记住：看到“最小化绝对值加权和”先想中位数，看到“环形 + 枚举”先想滑动更新。  
下次遇到选址类、环形类难题，不妨也试试这套组合拳！  
祝各位在算法之路上像素闯关，能量满满！💪
</conclusion>

---
处理用时：83.46秒
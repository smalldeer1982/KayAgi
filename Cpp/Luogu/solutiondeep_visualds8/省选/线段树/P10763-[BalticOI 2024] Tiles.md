# 题目信息

# [BalticOI 2024] Tiles

## 题目背景

翻译自 [BalticOI 2024 Day2 T2](https://boi2024.lmio.lt/tasks/d2-tiles-statement.pdf)。

## 题目描述

有一个存在 $N$ 个顶点的大教堂，顶点坐标依次为 $(x_i,y_i)$，对于每个 $1 \leq i < N$，存在一条 $i$ 与 $i+1$ 之间的边，此外，还存在一条 $N$ 到 $1$ 的边。

大教堂每条边都与 $x$ 轴或 $y$ 轴平行。此外，大教堂是一个简单多边形，即：

- 每个顶点恰好由两条边相交
- 任何一对边只能在顶点处相交

你有无数块 $2 \times 2$ 的瓷砖，你希望用这些瓷砖覆盖大教堂的大部分区域，具体来说，你想选择一条垂直线，并覆盖该线左侧的大教堂部分。对于任何整数 $k$，设 $L_k$ 为包含 $x$ 坐标等于 $k$ 的点的垂直线。对 $L_k$ 左侧大教堂部分的覆盖，是指在平面上放置一定数量的瓷砖，使得：

- 多边形内部且 $x$ 坐标小于 $k$ 的每个点都被某块瓷砖覆盖
- 多边形外部或 $x$ 坐标大于 $k$ 的点都不被任何瓷砖覆盖
- 瓷砖的内部不重叠

大教堂中任何顶点的最小 $x$ 坐标为 $0$。我们设 $M$ 为大教堂中任何顶点的最大 $x$ 坐标。

请你求出最大的满足条件的 $k\ (0 \leq k \leq M)$，根据定义，一定存在答案为 $0$。

## 说明/提示

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $N=4$ | $4$ |
| $2$ | $N \leq 6$ | $9$ |
| $3$ | $x_N=0,y_N=0$，对于 $1 \leq i \leq N-2$，$x_i \leq x_{i+1},y_i \geq y_{i+1}$ | $11$ |
| $4$ | $M \leq 1000$ 且 $y_i \leq 1000$ | $19$ |
| $5$ | $y_i$ 都为偶数 | $22$ |
| $6$ | $x_i$ 都为偶数 | $25$ |
| $7$ | 无特殊性质 | $10$ |

对于所有数据，$4 \leq N \leq 2 \times 10^5$，$1 \leq M \leq 10^9$，$0 \leq y_i \leq 10^9$，$\min(\{x_i\}) = 0,\max(\{x_i\}) = M$。

对于样例一，下面是对于 $k=2$ 的覆盖。

![](https://cdn.luogu.com.cn/upload/image_hosting/q9qi2e3b.png)

可以发现这是最大的情况了。

对于样例二，没有正值 $k$，使得 $L_k$ 左侧的教堂部分可以用瓷砖覆盖。

对于样例三，图示如下。

![](https://cdn.luogu.com.cn/upload/image_hosting/6kpbkvbn.png)

## 样例 #1

### 输入

```
14 6
0 1
0 3
2 3
2 4
0 4
0 6
3 6
3 7
4 7
6 7
6 5
3 5
3 2
3 1
```

### 输出

```
2```

## 样例 #2

### 输入

```
4 3
0 0
0 3
3 3
3 0```

### 输出

```
0```

## 样例 #3

### 输入

```
18 9
0 2
2 2
2 1
4 1
4 0
9 0
9 2
4 2
4 4
7 4
7 3
9 3
9 6
4 6
4 5
2 5
2 4
0 4```

### 输出

```
6```

# AI分析结果

💡 洛语云笺的C++算法解析：BalticOI 2024 Tiles 深入学习指南 💡

> 今天我们一起拆解「Tiles」这道 BalticOI 2024 的压轴题。它看起来像几何+扫描线的组合，但真正的挑战在于：  
> **如何在不断变化的竖直线段集合里，实时判断「是否存在奇数长度的连通块」以及「奇偶性冲突」**。  
> 我们会从最朴素的想法出发，一步步走向优雅的平衡树/线段树解法，并用像素动画把「扫描线+区间合并」的全过程可视化！

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
> 在一条从左向右移动的扫描线 $L_k$ 后，必须保证  
> 1. 所有被截出的竖直线段长度均为偶数；  
> 2. 任何时刻不能同时存在奇偶性不同的竖直线段；  
> 3. 一旦出现不合法立即输出当前最大可行 $k$。

✨ **核心算法标签**：扫描线 + 区间合并 + 平衡树 / 线段树

### 🗣️ 初步分析（思路演进路径）
- 朴素思路：枚举 $k$ → 模拟贴砖 → 检查 → $O(MN)$，爆炸。  
- 扫描线：让 $k$ 从 $0$ 到 $M$ 递增，只关心**竖直线段**的变化。  
- 关键洞察：  
  - 一条竖直线段被「加入」或「删除」时，其**端点纵坐标奇偶性**必须一致，否则 $k$ 不合法。  
  - 实时维护所有竖直线段的并集，若存在**奇数长度区间**则不合法。  
- 最优策略：  
  - 用 **两个平衡树/线段树** 分别维护「横坐标奇/偶」两类竖直线段。  
  - 插入/删除时动态合并或分裂区间，同时检查奇偶冲突和奇数长度。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (扫描线)**：  
   “选择一条垂直线 $L_k$ 并覆盖左侧” → 天然扫描线模型。
2. **线索2 (奇偶性约束)**：  
   “$2\times 2$ 瓷砖” → 竖直线段长度必须是偶数，且奇偶性不同的线段不能共存。
3. **线索3 (数据规模)**：  
   $N\le 2\times 10^5,\ M\le 10^9$ → $O(N\log N)$ 是目标复杂度，平衡树或线段树。

### 🧠 思维链构建：从线索到策略
> 1. 看到“覆盖左侧”→扫描线。  
> 2. 看到“2×2瓷砖”→竖直线段长度偶数，端点奇偶一致。  
> 3. 看到 $N=2\times 10^5$ → 需要 $O(\log N)$ 插入/删除/查询。  
> 4. 结论：**平衡树维护区间并集**，实时检查「奇数长度」与「奇偶冲突」即可！

---

## 2. 精选优质题解参考

| 作者 | 亮点提炼 | 洛语云笺点评 |
| --- | --- | --- |
| **wangyizhi** | 用两个 `set<pii>` 做区间合并；$O(N\log N)$；代码极短。 | 思路清晰，区间合并模板值得收藏；奇偶分类+实时检查很优雅。 |
| **Linge_Zzzz** | 用 `map<int,int>` 模拟平衡树；加入/分裂区间时维护奇数长度计数；调试经验丰富。 | 平衡树写法避免离散化；调试细节（迭代器顺序）是踩坑精华。 |
| **hnczy** & **huhangqi** | 离散化 + 两颗线段树；区间覆盖+全局奇数检测；代码结构规范。 | 线段树做法通用且易扩展；离散化+懒标记套路值得新手学习。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）
| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **1. 竖直线段提取** | 遍历多边形，若 $x_i=x_{i-1}$ 则生成线段 $(\min(y_i,y_{i-1}),\max(y_i,y_{i-1}))$ 并记录横坐标 $x_i$。 | 预处理只需一次线性扫描。 |
| **2. 奇偶分类** | 将线段按 $x_i$ 的奇偶性分到两个数据结构（平衡树/线段树）。 | 奇偶性是冲突检测的核心维度。 |
| **3. 区间合并/分裂** | 插入时合并相邻区间；删除时分裂区间；同时维护「奇数长度」计数 `cnt_odd`。 | 合并/分裂操作均摊 $O(\log N)$。 |
| **4. 实时合法性检查** | 每移动一次扫描线：若 `cnt_odd>0` 或两棵树同时非空 → 不合法，立即输出答案。 | 保证扫描线单调性。 |

### ✨ 解题技巧总结
- **区间合并模板**：用 `std::set` 或 `std::map` 维护不重叠区间，支持插入、删除、合并、分裂。
- **奇偶性分类**：将二维问题降维，避免复杂几何判断。
- **离散化**：纵坐标范围 $10^9$ → 离散化后线段树大小 $O(N)$。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举 $k$** | 逐 $k$ 模拟贴砖 | 思路直观 | $O(MN)$ 无法接受 | $N\le 100$ 部分分 |
| **离散化+线段树** | 离散化纵坐标，两颗线段树维护奇偶线段 | 通用、易写 | 离散化略繁琐 | 标准考场写法 |
| **平衡树区间合并** | 不离散化，用 `map` 维护区间 | 代码短，常数小 | 需手写合并/分裂 | 追求极致性能 |

### ✨ 优化之旅：从“能做”到“做好”
> 1. 朴素 $O(MN)$ → 发现瓶颈在于重复检查。  
> 2. 扫描线降维 → 只处理竖直线段事件。  
> 3. 奇偶分类 → 把几何冲突转化为区间冲突。  
> 4. 平衡树/线段树 → 区间合并+奇数检测 $O(\log N)$。  
> 5. 结论：**问题转化 + 数据结构优化** 是提升效率的万能钥匙！

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考
- **说明**：综合 wangyizhi 与 Linge_Zzzz 的平衡树写法，避免离散化，简洁高效。
- **完整核心代码**：

```cpp
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int,int>;
const int INF = 1e9;

struct Event {
    int x, l, r, op;   // op=1 加入, op=-1 删除
    bool operator<(const Event& b) const { return x < b.x; }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int N, M;  cin >> N >> M;
    vector<int> X(N+1), Y(N+1);
    for (int i = 1; i <= N; ++i) cin >> X[i] >> Y[i];
    X[0] = X[N], Y[0] = Y[N];

    vector<Event> evt;
    for (int i = 1; i <= N; ++i) {
        if (X[i] == X[i-1]) {
            int l = min(Y[i], Y[i-1]);
            int r = max(Y[i], Y[i-1]);
            evt.push_back({X[i], l, r, 1});
        }
    }
    sort(evt.begin(), evt.end());

    set<pii> st[2];   // 0: x even, 1: x odd
    int cnt_odd = 0;  // 全局奇数长度计数
    int ans = 0;

    auto len = [](pii s) { return (s.second - s.first) & 1; };

    auto insert = [&](set<pii>& s, int l, int r) {
        auto it = s.lower_bound({l, l});
        if (it != s.end() && it->first == r) { r = it->second; cnt_odd -= len(*it); s.erase(it); }
        it = s.lower_bound({l, l});
        if (it != s.begin()) { --it; if (it->second == l) { l = it->first; cnt_odd -= len(*it); s.erase(it); } }
        cnt_odd += len({l, r});
        s.insert({l, r});
    };

    auto erase = [&](set<pii>& s, int l, int r) {
        auto it = s.lower_bound({l+1, 0});
        if (it == s.end() || it->first > l) --it;
        pii seg = *it;
        s.erase(it); cnt_odd -= len(seg);
        if (seg.first < l) { insert(s, seg.first, l); }
        if (r < seg.second) { insert(s, r, seg.second); }
    };

    int ptr = 0;
    for (int x = 0; x <= M; ++x) {
        while (ptr < (int)evt.size() && evt[ptr].x == x) {
            int parity = x & 1;
            int l = evt[ptr].l, r = evt[ptr].r;
            if (evt[ptr].op == 1) {
                if (st[!parity].size()) { cout << ans << '\n'; return 0; }
                insert(st[parity], l, r);
            } else {
                erase(st[parity], l, r);
            }
            ++ptr;
        }
        if (cnt_odd) { cout << ans << '\n'; return 0; }
        if (st[0].empty() && st[1].empty()) ans = x;
        else if (st[0].empty()) ans = x - (x % 2 == 0);
        else if (st[1].empty()) ans = x - (x % 2 == 1);
    }
    cout << ans << '\n';
    return 0;
}
```

- **代码解读概要**：  
  1. 预处理所有竖直线段事件。  
  2. 扫描线从左到右，用两个 `set` 维护奇/偶横坐标的竖直线段。  
  3. 插入/删除时合并/分裂区间，维护 `cnt_odd`。  
  4. 每步检查合法性，更新答案。

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“像素工匠铺砖记”**  
8位像素风格，玩家扮演工匠，用 2×2 像素砖块从左向右铺设教堂。

### 场景设计
- **画布**：横 800px，纵 400px，下方 60px 为控制面板。  
- **教堂轮廓**：绿色像素线，竖直线段高亮为黄色。  
- **瓷砖**：红色 2×2 方块，半透明覆盖。  
- **扫描线**：垂直蓝线从左到右移动，触发事件时停顿 0.5s。

### 交互面板
- **开始/暂停**：红白机 A/B 键样式。  
- **单步**：→ 键图标。  
- **速度滑块**：0.2x ~ 4x。  
- **音效**：  
  - 插入线段 → 8位“叮”；  
  - 发现奇数长度 → 8位“警报”；  
  - 成功铺设 → 胜利音效。

### 关键帧示例
| 帧 | 事件 | 画面变化 | 音效 |
|---|---|---|---|
| 0 | 初始化 | 教堂轮廓出现 | BGM 开始 |
| 1 | 扫描线到 x=2 | 两条黄色竖线高亮 | 叮 |
| 2 | 插入线段 | 红色砖块覆盖偶数区间 | 叮 |
| 3 | 发现奇数 | 竖线闪烁红色 | 警报 |
| 4 | 输出答案 | 屏幕中央显示“k=2” | 胜利 |

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **区间合并**：适用于「区间调度」「合并区间」等经典问题。  
- **扫描线**：可用于「矩形面积并」「天际线问题」。  
- **奇偶分类**：在「棋盘覆盖」「黑白染色」问题中常见。

### 洛谷推荐练习
1. **P1908 逆序对**  
   🗣️ 推荐理由：熟悉离散化+树状数组/线段树，为扫描线打基础。
2. **P5490 矩形面积并**  
   🗣️ 推荐理由：经典扫描线+线段树，巩固区间合并思想。
3. **P2161 拆地毯**  
   🗣️ 推荐理由：区间覆盖+合并，与 Tiles 竖直线段维护高度相似。
4. **P4141 消失之物**  
   🗣️ 推荐理由：平衡树维护区间，训练区间分裂/合并手感。

---

## 7. 学习心得与经验分享

> **来自 Linge_Zzzz**：  
> “我在 `while(it->se>=c[i].l)spl(...),it--` 上 RE 了 4pts，原因是迭代器在删除后失效。修正为先 `--it` 再传参，避免野指针。”  
> **洛语云笺点评**：  
> 这是 STL 迭代器使用的经典陷阱！记住：**删除后立刻失效**，务必提前保存或反向遍历。

---

<conclusion>
Tiles 教会我们：  
- **几何问题** → **扫描线** → **区间数据结构** 的通用降维思路。  
- **奇偶分类** 能把复杂约束转化为简单计数。  
- **平衡树/线段树** 的区间合并是 $O(\log N)$ 利器。  
下次见到“覆盖”“奇偶”“区间”关键词，别忘了今天的像素工匠之旅！💪
</conclusion>

---
处理用时：105.38秒
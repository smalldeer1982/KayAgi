# 题目信息

# [BalticOI 2024] Wall

## 题目背景

翻译自 [BalticOI 2024 Day2 T3](https://boi2024.lmio.lt/tasks/d2-wall-statement.pdf)。

## 题目描述

你想要修建一个围墙，它是由 $N$ 个墙组成的，每个墙 $i$ 可能的高度是 $a_i$ 或 $b_i$，对于每个可能的围墙序列 $h$，你想要求出它的积水量之和。

例如下图展示了一个 $N = 10$，围墙高度分别为 $4, 2, 1, 8, 6, 2, 7, 1, 2, 3$ 的例子，它的实际积水高度是 $4, 4, 4, 8, 7, 7, 7, 3, 3, 3$。

![](https://cdn.luogu.com.cn/upload/image_hosting/p18f84ua.png)

对于某个 $i$ 雨后应有的水位 $H$，需要满足存在两个数 $l,r\ (l \leq i,r\geq i)$，有 $h_l \geq H,h_r \geq H$，且 $H$ 最大，此时 $i$ 的积水量为 $H-h_i$。

输出所有可能情况的积水量之和对 $10^9 +7$ 取模的值。

## 说明/提示

对于样例一，$(2,1,1,2)$ 的情况存在 $2$ 的积水量，$(1,2,1,2)$，$(2,1,2,1)$，$(2,1,2,2)$，$(2,2,1,2)$ 分别存在 $1$ 的积水量。

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :----------- | :-----------: |
| $1$ | $N \leq 20$ | $8$ |
| $2$ | $N \leq 100$ 且 $a_i,b_i \leq 1000$ | $17$ |
| $3$ | $N \leq 10000$ 且 $a_i,b_i \leq 1000$ | $19$ |
| $4$ | $N \leq 10000$ | $14$ |
| $5$ | $a_i,b_i \leq 2$ | $12$ |
| $6$ | 无特殊性质 | $30$ |


对于所有数据 $1 \leq N \leq5 \times10^5$，$1 \leq a_i,b_i \leq 10^9$ 且对于 每个 $1 \leq i \leq n$，有 $a_i \neq b_i$。

## 样例 #1

### 输入

```
4
1 1 1 1
2 2 2 2```

### 输出

```
6```

## 样例 #2

### 输入

```
10
1 2 3 4 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
```

### 输出

```
21116```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：BalticOI 2024 Wall 深入学习指南 💡

大家好，我是你们的算法导师——洛语云笺。今天，我们将一起深入剖析一道极具挑战性的题目：**BalticOI 2024 Wall**。这道题不仅考验我们对复杂数学推导的理解，更要求我们将抽象的“积水”问题转化为可计算、可优化的算法模型。

我们将从“题目侦探”开始，寻找线索，构建思维链，再对比多种高阶策略，最后通过可视化的方式，彻底理解如何优雅地解决它。

---

## 1. 题目解读与策略初探

### ✨ **本题核心挑战**
这道题目的核心挑战在于：**如何高效地计算所有可能围墙构型下的“积水总量”**。这里的“积水”并非简单的模拟，而是需要根据一个复杂的数学定义，对所有 $2^n$ 种可能的围墙高度序列进行求和。

### ✨ **核心算法标签**
- **离散化 (Discretization)**
- **扫描线 (Sweep Line)**
- **线段树 (Segment Tree) / 树状数组 (Fenwick Tree)**
- **容斥原理 (Inclusion-Exclusion Principle)**
- **动态规划 (DP) 与矩阵乘法优化**

---

### 🗣️ **初步分析**
面对 $2^n$ 种情况，直接枚举显然不可行。我们需要一种数学上的“奇技淫巧”——**将求和问题转化为对“值域”的扫描**。

核心思路是：**将积水高度 $H$ 的贡献，转化为对每个离散高度 $h$ 的贡献求和**。即，我们不再问“某个序列有多少积水”，而是问“有多少序列，在高度 $h$ 处有积水”。

---

### 🔍 算法侦探：如何在题目中发现线索？

1.  **线索1 (问题目标)**：题目要求计算“所有可能情况”的积水量之和。这提示我们，最终答案可能是一个求和形式，而非某个单一序列的最优解。

2.  **线索2 (问题约束/特性)**：积水高度 $H$ 的定义依赖于左右两侧的最大值。这强烈暗示我们需要**前缀/后缀最大值**的概念，并可能利用**单调性**或**扫描线**。

3.  **线索3 (数据规模)**：$N \leq 5 \times 10^5$，这要求我们的算法时间复杂度必须是 **$O(N \log N)$** 或更低。这排除了任何 $O(N^2)$ 或指数级的暴力方法，指向了基于**离散化**和**高效数据结构**的解决方案。

---

### 🧠 思维链构建：从线索到策略

> “好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1.  **线索1：问题目标**告诉我们，这是一个“求和”问题，而非“最优化”问题。这意味着我们需要对每个离散值进行计数。
> 2.  **线索2：问题特性**，如“积水高度依赖于左右最大值”，提示我们可能需要**容斥原理**来避免重复计算。例如，计算“至少”某个高度的方案数，然后用总和减去不满足的。
> 3.  **线索3：数据规模**给了我们最终判决。一个朴素的 $O(N \times V)$ 算法（$V$ 为值域）完全不可行。我们必须将值域**离散化**，并利用**线段树**或**树状数组**来维护区间信息，实现单次 $O(\log N)$ 的修改和查询。
> 4.  **结论**：综合以上，我们需要一个能够**按值域从高到低（或从低到高）扫描**的算法。在扫描过程中，动态维护每个位置是否满足“左侧有大于等于 $h$ 的墙”和“右侧有大于等于 $h$ 的墙”的条件。这种“扫描线 + 数据结构”的组合，正是解决此类复杂计数问题的利器！”

---

## 2. 精选优质题解参考

<eval_intro>
为了帮助大家理解，我精选了以下几条思路清晰、实现优雅的题解。它们虽然实现细节不同，但都巧妙地运用了“离散化 + 扫描线 + 线段树”的核心思想。
</eval_intro>

---

### **题解一：Petit_Souris 的“扫描线+线段树”经典范式**

*   **核心思想**：将积水总量 $\sum H$ 拆分为 $\sum_{h} \text{count}(H \ge h)$，然后通过离散化高度 $h$，从高到低扫描。在扫描过程中，利用线段树动态维护每个位置的贡献。
*   **亮点**：
    *   **巧妙的容斥**：将“左侧有大于等于 $h$ 的墙”转化为“总方案数 - 左侧所有墙都小于 $h$ 的方案数”，从而将复杂的条件转化为线段树上的区间乘法。
    *   **优雅的数学推导**：通过将 $H$ 的贡献拆解为 $\sum [H \ge h]$，将二维问题（位置和高度）降维到一维（仅位置），使得线段树能够高效维护。
*   **代码风格**：代码结构清晰，变量命名规范，如 `L`, `R` 表示左右边界，`cnt` 数组跟踪状态变化，使得逻辑易于追踪。

---

### **题解二：cyffff 的“DP+线段树”模型**

*   **核心思想**：将问题抽象为计算所有序列的 $\sum \text{prefix\_max} + \sum \text{suffix\_max} - n \times \text{global\_max} - \sum h$。通过线段树维护动态规划的转移矩阵，高效计算这些和。
*   **亮点**：
    *   **问题转化**：将复杂的积水问题转化为对前缀最大值、后缀最大值和全局最大值的求和，大大简化了思考难度。
    *   **矩阵乘法优化**：利用线段树维护一个 $2 \times 2$ 的转移矩阵，将状态转移的复杂性封装在矩阵乘法中，使得线段树的更新操作非常简洁。
*   **代码风格**：代码模块化程度高，`solve` 函数封装了核心逻辑，`modint` 的使用保证了数值计算的准确性。

---

### **题解三：happy_dengziyue 的“单点修改+区间乘”简洁实现**

*   **核心思想**：同样采用“离散化 + 扫描线”的思路，但将贡献公式化简为四个部分：$2^{n-1} \sum c_i - \sum 2^{n-i} L_i c_i - \sum 2^{i-1} R_i c_i + \sum \text{all}$。通过三棵线段树分别维护这四个部分。
*   **亮点**：
    *   **简洁的公式推导**：将复杂的容斥公式化简为四个独立的求和项，每一项都可以通过线段树的单点修改和区间乘法高效维护。
    *   **清晰的实现**：三棵线段树分工明确，分别处理前缀、后缀和全局的贡献，使得代码易于理解和调试。
*   **代码风格**：代码注释详尽，变量命名直观，如 `T1`, `T2`, `T3` 分别对应不同的维护目标。

---

## 3. 解题策略深度剖析

<difficulty_intro>
通往正确答案的道路不止一条，高手们是如何思考的呢？让我们深入剖析几种核心策略，看看它们是如何优雅地解决这个问题的。
</difficulty_intro>

---

### 🎯 核心难点与关键步骤 (最优解法剖析)

1.  **关键点1：如何将“积水”这一几何概念转化为可计算的数学形式？**
    *   **分析**：根据题目定义，位置 $i$ 的积水高度 $H_i$ 是 $\min(\max_{j \le i} h_j, \max_{j \ge i} h_j) - h_i$。直接计算这个值对所有 $2^n$ 种序列求和是不可行的。
    *   **解决方案**：采用**离散化 + 扫描线**的策略。我们将问题转化为：**对于每一个离散高度 $h$，计算有多少种序列使得位置 $i$ 的积水高度 $\ge h$**。这样，总积水就可以表示为 $\sum_{h} \text{count}(H \ge h)$。
    *   💡 **学习笔记**：将几何问题转化为计数问题，是处理复杂求和问题的常用技巧。

2.  **关键点2：如何高效计算“满足特定条件的序列数”？**
    *   **分析**：对于某个高度 $h$，一个位置 $i$ 有积水 $\ge h$ 的条件是：$h_i < h$ 且存在 $l \le i$ 使得 $h_l \ge h$ 且存在 $r \ge i$ 使得 $h_r \ge h$。
    *   **解决方案**：使用**容斥原理**和**线段树**。
        1.  **容斥**：计算总方案数（$2^n$）减去不满足条件的方案数。
        2.  **线段树**：维护每个位置 $i$ 的“左侧所有墙都小于 $h$”的方案数（记为 $L_i$）和“右侧所有墙都小于 $h$”的方案数（记为 $R_i$）。
        3.  **动态更新**：当扫描线从高到低移动时，每当一个 $a_i$ 或 $b_i$ 从“小于 $h$”变为“大于等于 $h$”，就通过线段树的**区间乘法**或**单点修改**来更新 $L_i$ 和 $R_i$。
    *   💡 **学习笔记**：线段树是处理“区间更新 + 区间查询”的利器，能将复杂度从 $O(N^2)$ 降至 $O(N \log N)$。

3.  **关键点3：如何处理离散化后的“区间贡献”？**
    *   **分析**：离散化后，相邻两个离散高度 $h_k$ 和 $h_{k+1}$ 之间，所有实际高度 $h$ 的贡献是相同的。
    *   **解决方案**：将总贡献表示为 $\sum_{k} (h_{k+1} - h_k) \times \text{count}(H \ge h_k)$。这样，我们只需要对每个离散高度 $h_k$ 计算一次贡献，然后乘以区间长度 $(h_{k+1} - h_k)$。
    *   💡 **学习笔记**：离散化不仅压缩了值域，还使得我们可以将连续的贡献转化为离散的求和，从而利用数据结构高效处理。

---

### ✨ 解题技巧总结

-   **技巧A (离散化与扫描线)**：将连续的值域离散化，并通过扫描线（从高到低或从低到高）来处理，将二维问题降维，使得数据结构能够高效介入。
-   **技巧B (容斥原理与贡献拆分)**：将复杂的“满足条件”问题转化为“总方案数 - 不满足方案数”，并将总贡献拆分为多个可独立计算的子贡献，便于分别维护。
-   **技巧C (线段树维护动态信息)**：利用线段树维护随扫描线变化而动态更新的信息（如前缀/后缀方案数），实现高效的区间修改和查询。

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- |:--- |
| **暴力枚举 (Brute Force)** | 枚举所有 $2^n$ 种序列，计算每种序列的积水。 | 思路直观，易于验证正确性。 | **时间复杂度**: 指数级 $O(2^N \times N)$，完全不可行。 | 数据规模 $N \leq 20$。在竞赛中预计可得 **8%** 的分数。 |
| **离散化 + 扫描线 + 线段树 (主流最优)** | 离散化高度，从高到低扫描，用线段树维护每个位置的贡献。 | 时间复杂度 $O(N \log N)$，可处理大规模数据；思路清晰，实现优雅。 | 需要对容斥原理和线段树有深入理解。 | 本题的最佳实践。可得 **100%** 分数。 |
| **DP + 矩阵乘法优化** | 将问题转化为计算前缀/后缀/全局最大值的和，用线段树维护转移矩阵。 | 将复杂的DP状态转移封装在矩阵中，代码模块化程度高。 | 矩阵乘法的概念可能对初学者稍显抽象。 | 适用于需要维护复杂状态转移的计数问题。可得 **100%** 分数。 |

---

### ✨ 优化之旅：从“能做”到“做好”

> “从暴力枚举到优雅解法，我们经历了一个‘降维打击’的过程。
> 1.  **起点：暴力枚举的困境**——指数级复杂度，计算机无法承受。
> 2.  **发现瓶颈：重复计算与维度诅咒**——每个高度都要重新计算，无法复用信息。
> 3.  **优化的钥匙：离散化 + 扫描线 + 线段树**——将二维问题降维到一维，通过线段树高效维护动态信息，实现从 $O(N \times V)$ 到 $O(N \log N)$ 的飞跃。
> 4.  **模型的升华：从容斥到贡献拆分**——将复杂的条件转化为可独立计算的子贡献，使得数据结构能够精准地更新和查询所需信息。”

---

## 4. C++核心代码实现赏析

---

### **本题通用核心C++实现参考**

*   **说明**：本代码综合了 `Petit_Souris` 和 `happy_dengziyue` 的思路，旨在提供一个清晰且完整的离散化 + 扫描线 + 线段树实现。
*   **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;
    using ll = long long;
    const ll MOD = 1e9 + 7;
    const ll INV2 = (MOD + 1) / 2;
    const int MAXN = 5e5 + 10;

    ll n, a[MAXN], b[MAXN];
    ll lsh[MAXN * 2], lsh_cnt;
    vector<int> ops[MAXN * 2];

    struct Fenwick {
        ll tr[MAXN];
        void add(int x, ll v) { for (; x <= n; x += x & -x) tr[x] = (tr[x] + v) % MOD; }
        ll sum(int x) { ll res = 0; for (; x; x -= x & -x) res = (res + tr[x]) % MOD; return res; }
    } fw;

    struct SegTree {
        ll tr[MAXN * 4], tag[MAXN * 4];
        void build(int p, int l, int r) {
            tag[p] = 1;
            if (l == r) { tr[p] = 1; return; }
            int mid = (l + r) >> 1;
            build(p << 1, l, mid);
            build(p << 1 | 1, mid + 1, r);
            tr[p] = (tr[p << 1] + tr[p << 1 | 1]) % MOD;
        }
        void push_down(int p, int l, int r) {
            if (tag[p] == 1) return;
            tr[p << 1] = tr[p << 1] * tag[p] % MOD;
            tr[p << 1 | 1] = tr[p << 1 | 1] * tag[p] % MOD;
            tag[p << 1] = tag[p << 1] * tag[p] % MOD;
            tag[p << 1 | 1] = tag[p << 1 | 1] * tag[p] % MOD;
            tag[p] = 1;
        }
        void range_mul(int p, int l, int r, int ql, int qr, ll v) {
            if (ql > qr) return;
            if (ql <= l && r <= qr) {
                tr[p] = tr[p] * v % MOD;
                tag[p] = tag[p] * v % MOD;
                return;
            }
            push_down(p, l, r);
            int mid = (l + r) >> 1;
            if (ql <= mid) range_mul(p << 1, l, mid, ql, qr, v);
            if (qr > mid) range_mul(p << 1 | 1, mid + 1, r, ql, qr, v);
            tr[p] = (tr[p << 1] + tr[p << 1 | 1]) % MOD;
        }
        ll range_sum(int p, int l, int r, int ql, int qr) {
            if (ql > qr) return 0;
            if (ql <= l && r <= qr) return tr[p];
            push_down(p, l, r);
            int mid = (l + r) >> 1;
            ll res = 0;
            if (ql <= mid) res = (res + range_sum(p << 1, l, mid, ql, qr)) % MOD;
            if (qr > mid) res = (res + range_sum(p << 1 | 1, mid + 1, r, ql, qr)) % MOD;
            return res;
        }
    } st1, st2, st3;

    int main() {
        ios::sync_with_stdio(false);
        cin.tie(nullptr);
        cin >> n;
        ll sum_h = 0;
        for (int i = 1; i <= n; ++i) {
            cin >> a[i] >> b[i];
            if (a[i] > b[i]) swap(a[i], b[i]);
            lsh[++lsh_cnt] = a[i];
            lsh[++lsh_cnt] = b[i];
            sum_h = (sum_h + a[i] + b[i]) % MOD;
        }
        sum_h = sum_h * ((1ll << (n - 1)) % MOD) % MOD;

        sort(lsh + 1, lsh + lsh_cnt + 1);
        lsh_cnt = unique(lsh + 1, lsh + lsh_cnt + 1) - lsh - 1;
        for (int i = 1; i <= n; ++i) {
            a[i] = lower_bound(lsh + 1, lsh + lsh_cnt + 1, a[i]) - lsh;
            b[i] = lower_bound(lsh + 1, lsh + lsh_cnt + 1, b[i]) - lsh;
            ops[a[i]].push_back(i);
            ops[b[i]].push_back(i);
        }

        st1.build(1, 1, n);
        st2.build(1, 1, n);
        st3.build(1, 1, n);
        ll all = 1;
        for (int i = 1; i <= n; ++i) all = all * 2 % MOD;

        ll ans = 0;
        for (int h = lsh_cnt; h >= 1; --h) {
            for (int i : ops[h]) {
                if (a[i] == h) {
                    st1.range_mul(1, 1, n, 1, i - 1, INV2);
                    st2.range_mul(1, 1, n, i + 1, n, INV2);
                    st3.range_mul(1, 1, n, i, i, 1);
                } else if (b[i] == h) {
                    st1.range_mul(1, 1, n, 1, i - 1, 0);
                    st2.range_mul(1, 1, n, i + 1, n, 0);
                    st3.range_mul(1, 1, n, i, i, 0);
                    all = all * INV2 % MOD;
                }
            }
            ll s1 = st1.range_sum(1, 1, n, 1, n);
            ll s2 = st2.range_sum(1, 1, n, 1, n);
            ll s3 = st3.range_sum(1, 1, n, 1, n);
            ll res = (all * n % MOD - s1 - s2 + s3 + 2 * MOD) % MOD;
            ll delta = (h == 1) ? lsh[1] : (lsh[h] - lsh[h - 1]);
            ans = (ans + res * delta % MOD) % MOD;
        }
        ans = (ans - sum_h + MOD) % MOD;
        cout << ans << '\n';
        return 0;
    }
    ```
*   **代码解读概要**：
    > 该代码首先离散化所有高度，并计算 $\sum h$ 的贡献。然后，从高到低扫描离散高度 $h$。对于每个 $h$，它动态维护三个线段树：
    > 1.  `st1` 维护每个位置左侧“所有墙都小于 $h$”的方案数（即 $L_i$）。
    > 2.  `st2` 维护每个位置右侧“所有墙都小于 $h$”的方案数（即 $R_i$）。
    > 3.  `st3` 维护所有墙都小于 $h$ 的全局方案数（即 $\prod (2 - [a_i \ge h] - [b_i \ge h])$）。
    > 在扫描过程中，每当一个 $a_i$ 或 $b_i$ 从“小于 $h$”变为“大于等于 $h$”，就通过线段树的区间乘法更新这些值。最后，利用容斥原理计算出当前高度 $h$ 的贡献，并累加到总答案中。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了让大家更直观地理解“扫描线 + 线段树”是如何工作的，我设计了一个8位像素风格的动画演示。
</visualization_intro>

*   **动画演示主题**：**“像素围墙”与“扫描线洪水”**
*   **核心演示内容**：展示离散高度 $h$ 从高到低移动时，线段树如何动态更新每个位置的“积水贡献”。
*   **设计思路简述**：
    *   **像素风格**：使用8x8像素方块表示每堵墙，颜色代表其高度。
    *   **扫描线**：一条水平的“洪水线”从高到低移动。
    *   **线段树可视化**：屏幕底部显示一个简化的线段树，每个节点用像素块表示其维护的区间和值。
    *   **音效与交互**：每当洪水线经过一个墙高，播放“滴”的音效，线段树对应节点高亮更新。

*   **动画帧步骤与交互关键点**：
    1.  **初始化**：展示 $N$ 堵像素墙，高度随机。
    2.  **离散化**：将墙高映射到像素化的离散值。
    3.  **扫描线移动**：
        *   **帧1**：洪水线在最高高度，所有线段树节点为初始值（如全为2）。
        *   **帧2**：洪水线下降，经过第一堵墙。该墙对应的线段树节点从“2”变为“1”或“0”，并触发区间乘法更新其父节点。
        *   **帧3**：洪水线继续下降，重复更新过程。
    4.  **贡献计算**：屏幕侧边实时显示当前高度 $h$ 的贡献值（如 `res = 123`）。
    5.  **最终动画**：当洪水线降到0，显示最终总积水量，并播放“胜利”音效。

*   **旁白提示**：
    *   “看！当洪水线下降时，线段树节点就像多米诺骨牌一样更新！”
    *   “这里的‘2’代表这堵墙可以选高或低，‘1’代表只能选低，‘0’代表必须选高！”

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
掌握了本题的核心思想后，我们可以进一步思考其普适性。
</similar_problems_intro>

*   **通用思路/技巧迁移**：
    1.  **扫描线 + 线段树**：适用于所有需要将**二维问题降维**的场景，如**矩形面积并**、**天际线问题**。
    2.  **容斥原理**：在处理“至少”、“恰好”等计数问题时，将复杂条件转化为可独立计算的子问题。
    3.  **离散化**：当值域很大但有效值不多时，将值域压缩，使得数据结构能够高效处理。

*   **练习推荐 (洛谷)**：
    1.  **P1908 逆序对** - 经典扫描线 + 树状数组应用。
        *   🗣️ **推荐理由**：巩固离散化和树状数组的基本用法，理解如何将二维问题转化为一维。
    2.  **P3374 【模板】树状数组 1** - 线段树/树状数组模板题。
        *   🗣️ **推荐理由**：熟练掌握区间修改和区间查询的基本操作。
    3.  **P3372 【模板】线段树 1** - 线段树模板题。
        *   🗣️ **推荐理由**：深入理解线段树的延迟标记（lazy propagation）机制。
    4.  **P1966 火柴排队** - 扫描线 + 离散化的进阶应用。
        *   🗣️ **推荐理由**：学习如何巧妙地利用扫描线处理看似与“线”无关的问题。

---

<conclusion>
本次关于“BalticOI 2024 Wall”的C++解题分析就到这里。这道题的精髓在于将复杂的**几何求和问题**，通过**离散化**和**扫描线**技术，转化为**高效的数据结构维护问题**。希望这份学习指南能帮助大家理解这些高阶技巧，并在未来的挑战中举一反三！记住，算法的魅力在于将不可能变为可能！💪
</conclusion>

---
处理用时：191.44秒
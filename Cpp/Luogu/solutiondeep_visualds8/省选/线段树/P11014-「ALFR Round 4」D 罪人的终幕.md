# 题目信息

# 「ALFR Round 4」D 罪人的终幕

## 题目背景

> 而我承诺你，一切都将在一场盛大的，如同戏剧般的审判中结束……  
> 小小地旋转，轻轻地跳跃，然后便是「罪人」的谢幕。

## 题目描述

定义函数 $a(x)$ 表示自然数 $x$ 的不同的质因子的和。

若 $x=\prod\limits_{p_i\in\mathbb{P}}p_i^{d_i}$，则 $a(x)=\sum\limits_{p_i\in \mathbb{P}}p_i\times[d_i\ge1]$，其中 $\mathbb{P}$ 是质数集，$a(1)=0$。

从诞生的第一天开始，Furina 便有了一个期待值 $m_1$。

在最终的审判来临前，她每天都会选择整理自己的心情，具体的方法如下：

假设今天是第 $i$ 天，Furina 会把今天的期待值 $m_i$ 定为 $\max\{\dfrac{m_j}{a(\operatorname{lcm}(w_i,w_j))+a(\gcd(w_i,w_j))}+k\}$，其中 $2\le i\le n$，$1\le j<i$，$k$ 是观看审判所获得的期待值。

请你求出 $\sum\limits_{i=1}^nm_i$。

## 说明/提示

### 样例解释

这 $4$ 天的期待值分别是 $4,7.285714,7.809524,8.952381$。

### 数据范围

| 子任务 | 分值 | 限制 |
| :-----------: | :-----------: | :-----------: |
| $0$ | $30$ | $n,m_1,k\le10^3$，$w_i\le29$ |
| $1$ | $70$ | - |

对于 $100\%$ 的数据，$1\le n\le182376$，$1\le m_1\le10^7$，$0\le k\le10^6$，$2\le w_i\le182376$。

本题数据可能偏弱，欢迎大家提供对于错误做法的 hack。

## 样例 #1

### 输入

```
4 4 7
7 10 16 8```

### 输出

```
28.047619```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「ALFR Round 4」D 罪人的终幕 深入学习指南 💡

> 大家好，我是你们的算法伙伴洛语云笺。今天我们要挑战的是一道融合了数论与高级数据结构的压轴题——“罪人的终幕”。它看似复杂，但只要我们像侦探一样拆解线索，就能发现一条清晰的解题脉络。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在每一步递推中，我们需要高效地找到前驱最优解，使得形如  
`m_i = max{ m_j / (a(lcm(w_i,w_j)) + a(gcd(w_i,w_j))) } + k`  
的式子能在 **O(n log n)** 内完成，而 **不能** 用朴素 O(n²) 暴力。

✨ **核心算法标签**：  
数论函数性质 + **李超线段树**（或凸包斜率优化）+ 线性筛。

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**  
   题目要求“求和”，本质是把每一步的 `m_i` 都算出来。  
   → 需要 **递推**，每一步依赖前面所有 `m_j`。

2. **线索2 (递推公式结构)**  
   式子里有 `lcm` 和 `gcd`，且外面套着 `a(·)` 这个“质因子和”。  
   → 思考：能否把 `a(lcm) + a(gcd)` 化简成只与 `w_i` 或 `w_j` 相关的形式？

3. **线索3 (数据规模)**  
   n ≤ 1.8×10⁵，O(n²) 会爆炸；值域 V ≤ 1.8×10⁵，暗示 **log V** 级别的数据结构可行。

---

### 🧠 思维链构建：从线索到策略

> 1. 先把“质因子和”记为 `a(x)`，尝试化简 `a(lcm) + a(gcd)`。  
> 2. 发现 **关键恒等式**：  
>    `a(lcm(x,y)) + a(gcd(x,y)) = a(x) + a(y)`  
>    证明见题解区，核心就是“质因子贡献不重复”。  
> 3. 把递推式化简为：  
>    `m_i = max{ m_j / (a(w_i) + a(w_j)) } + k`  
> 4. 取倒数 → 变 **最小值**：  
>    `m_i = 1 / min{ (a(w_i) + a(w_j)) / m_j } + k`  
> 5. 令 `x = a(w_i)`，把 `(a(w_j)/m_j) + (1/m_j)·x` 看成一次函数，用 **李超线段树** 在值域上维护最小值即可。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 关键技巧 |
|---|---|---|
| **___Furina___ (赞:20)** | 完整给出恒等式证明；代码简洁，用宏定义“卖萌”。 | 线性筛 + 李超树 |
| **违规用户名1425622 (赞:6)** | 用“取倒数”思路自然引出一次函数；强调 `long double`。 | 斜率截距化简 |
| **bluewindde (赞:1)** | 用凸包 + cdq 分治双 log 实现；给出严谨证明。 | 凸包斜率优化 |
| **BPG_ning (赞:1)** | 不用李超树，用 cdq 分治 + 双指针维护凸包。 | 经典凸包优化 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 步骤 | 要点 | 学习笔记 |
|---|---|---|
| **1. 数论化简** | 证明 `a(lcm)+a(gcd)=a(x)+a(y)` | 数论函数性质往往是破题钥匙 |
| **2. 式子变形** | 把分式 `max` 转成一次函数 `min` | “取倒数”是处理分式极值的常用技巧 |
| **3. 数据结构** | 用 **李超线段树** 在值域上维护一次函数最小值 | 李超树模板：插入直线 + 单点查询 |
| **4. 精度处理** | 全程 `long double`，输出 6~12 位小数 | 注意比较时用 `eps` |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 思想 | 复杂度 | 优缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 O(n²)** | 双层循环递推 | O(n²) | 思路直观，TLE | n≤3×10³ |
| **李超树 O(n log V)** | 一次函数最值 | O(n log V) | 代码短，常数小 | 通用，推荐 |
| **凸包+cdq O(n log n)** | 凸包斜率优化 | O(n log n) | 无需离散化，双 log | 值域大时更稳 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. **起点**：暴力循环 1.8e5² ≈ 3e10 次 → 直接爆炸。  
> 2. **发现瓶颈**：`min` 里的 `(a(w_i)+a(w_j))/m_j` 可以看成一次函数。  
> 3. **优化钥匙**：李超树能在 **O(log V)** 内回答“在 x = a(w_i) 处哪条直线最小”。  
> 4. **模型升华**：把“递推”转成“动态插入直线 + 单点查询”，时间骤降至 **O(n log V)**。

---

## 4. C++核心代码实现赏析

### 本题通用核心实现参考

> 综合 ___Furina___ 与 bluewindde 的写法，给出一份可读性最高的李超树实现。

```cpp
#include <bits/stdc++.h>
using namespace std;
using db = long double;
const int N = 2e5 + 10, V = 182376;
const db INF = 1e18, EPS = 1e-15;

int n, w[N], a[N];
db m[N], k, ans;

// ---------- 线性筛 a(n) ----------
int prime[N], tot, sum[N];
bool vis[N];
void sieve() {
    for (int i = 2; i <= V; ++i) {
        if (!vis[i]) { prime[++tot] = i; sum[i] = i; }
        for (int j = 1; j <= tot && i * prime[j] <= V; ++j) {
            vis[i * prime[j]] = true;
            sum[i * prime[j]] = sum[i] + prime[j];
            if (i % prime[j] == 0) break;
        }
    }
}

// ---------- 李超线段树 ----------
struct Line { db k, b; };
Line li[N];
int idx[N << 2], cnt;           // 线段树节点存最优直线编号
db calc(int id, db x) { return li[id].k * x + li[id].b; }

int cmp(db x, db y) {
    return (fabs(x - y) < EPS) ? 0 : (x < y ? -1 : 1);
}

void update(int p, int l, int r, int id) {
    if (!idx[p]) { idx[p] = id; return; }
    int mid = (l + r) >> 1;
    int cur = idx[p];
    if (cmp(calc(id, mid), calc(cur, mid)) < 0) swap(id, cur);

    int cl = cmp(calc(id, l), calc(cur, l));
    int cr = cmp(calc(id, r), calc(cur, r));
    if (cl < 0) update(p << 1, l, mid, id);
    if (cr < 0) update(p << 1 | 1, mid + 1, r, id);
    idx[p] = cur;
}

db query(int p, int l, int r, int x) {
    if (!idx[p]) return INF;
    db res = calc(idx[p], x);
    if (l == r) return res;
    int mid = (l + r) >> 1;
    if (x <= mid) res = min(res, query(p << 1, l, mid, x));
    else res = min(res, query(p << 1 | 1, mid + 1, r, x));
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    sieve();

    cin >> n >> m[1] >> k;
    for (int i = 1; i <= n; ++i) {
        cin >> w[i];
        a[i] = sum[w[i]];           // a(w_i)
    }

    // 第 1 条直线
    li[++cnt] = { 1.0 / m[1], 1.0 * a[1] / m[1] };
    update(1, 0, V, cnt);

    for (int i = 2; i <= n; ++i) {
        db val = query(1, 0, V, a[i]);
        m[i] = 1.0 / val + k;
        li[++cnt] = { 1.0 / m[i], 1.0 * a[i] / m[i] };
        update(1, 0, V, cnt);
    }

    db ans = 0;
    for (int i = 1; i <= n; ++i) ans += m[i];
    cout << fixed << setprecision(6) << ans << '\n';
    return 0;
}
```

---

### 片段赏析

**___Furina___ 的“卖萌宏”**  
```cpp
#define I_love_Furina return
#define forever 0
```
> 把 `return 0;` 写成 `I_love_Furina forever;`，既有趣又易读。

**bluewindde 的凸包写法**  
```cpp
while (top>1 && slope(st[top-1],p) > slope(st[top-1],st[top])) --top;
```
> 经典凸包维护，斜率单调队列思想。

---

## 5. 算法可视化：像素动画演示

**主题**：「像素审判庭」——在 8×8 像素法庭上实时插入“直线律师”，为每个 `a(w_i)` 找到“最佳辩词”。

| 场景 | 像素元素 | 音效 |
|---|---|---|
| 直线插入 | 像素律师滑入 | “叮” |
| 查询最小 | 像素法官敲击法槌 | “咚” |
| 找到最优 | 像素烟花 | “胜利音” |

**实现要点**  
- Canvas 画一条 256px 的 x 轴，代表值域 0~V。  
- 每条直线用 2×1 像素块“堆叠”展示。  
- 单步按钮 → 逐帧演示插入/查询过程。  
- AI 自动模式 → 2s 内完成所有动画，配 8-bit BGM。

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**  
- 把“递推 + 分式极值”抽象为“一次函数最值”，适用于  
  1. 斜率优化 DP（如 “玩具装箱”）。  
  2. 凸包维护最大斜率（如 “征途”）。  
  3. 李超树维护直线最小值（如 “任务安排”）。

**洛谷推荐**  
- **P3195 [HNOI2008] 玩具装箱**  
  经典斜率优化入门。  
- **P4072 [SDOI2016] 征途**  
  凸包 + cdq 分治双 log。  
- **P4655 [CEOI2017] 游戏**  
  李超树维护直线最小值。

---

## 7. 学习心得与经验分享

> 违规用户名1425622 提到：“感觉这个题挺简单也挺典的，可能是因为大部分人不会李超树所以过的人少。”  
> **洛语云笺点评**：掌握李超树后，很多看似“玄学”的递推都能优雅解决。把复杂式子拆成一次函数，是竞赛中屡试不爽的“降维打击”。

---

<conclusion>
至此，“罪人的终幕”已谢幕。希望这份指南让你体会到：  
**“数论恒等式 + 数据结构优化”** 这对黄金组合的强大威力。  
继续刷题，我们下一场“演出”再见！
</conclusion>

---
处理用时：116.98秒
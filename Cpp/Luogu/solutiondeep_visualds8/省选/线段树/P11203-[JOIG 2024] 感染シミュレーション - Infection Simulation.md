# 题目信息

# [JOIG 2024] 感染シミュレーション / Infection Simulation

## 题目描述

昨天，$N$ 位顾客光顾了 EGOI 自助餐厅。顾客编号从 $1$ 到 $N$，顾客 $i(1\le i\le N)$ 到达时间为 $L_i$，离开时间为 $R_i$。今天，我们发现有一位顾客来店时感染了目前在 JOI 国流行的新型传染病 X。

传染病 X 的**传染性**用整数 $x$ 表示。具体来说，对于 $1\le i\le N$，当顾客 $i$ 与一个或多个感染者同时进入餐厅的累计总时间至少达到 $x$ 时，顾客 $i$ 就会成为新感染者。

现在，由于 JOI 国采取了严格的感染控制措施，因此必须确定感染者人数。然而，问题在于调查组并不知道哪些人感染了传染病，而代表传染性的整数 $x$ 的值也是未知数。

因此，EGOI 自助餐厅经理理惠决定对于 $Q$ 种情况，分别求出最终会有多少顾客被感染。在第 $j(1\le j\le Q)$ 种情况下，最初只有顾客 $P_j$ 受到感染，传染性为 $X_j$。

根据到店顾客的信息，求出每种情况下最终的感染人数。注意，即使受感染的人数是在他们离开餐厅时被感染的，也应包括在内。此外，还假定一旦顾客感染了传染病 X，他就不能再被感染。

## 说明/提示

#### 【样例解释 #1】

在第 $1$ 个询问中，初始的感染者是顾客 $1$，传染性为 $15$，因此感染的传播方式如下

- 在时间 $10$，顾客 $1$ 到达餐厅；
- 在时间 $20$，顾客 $2$ 到达餐厅；
- 在时间 $35$，顾客 $2$ 与顾客 $1$ 同时出现在餐厅累计时间为 $15$，顾客 $2$ 被感染；
- 在时间 $40$，顾客 $1$ 离开餐厅；
- 在时间 $45$，顾客 $3$ 到达餐厅；
- 在时间 $60$，顾客 $3$ 与顾客 $2$ 同时出现在餐厅累计时间为 $15$，顾客 $3$ 被感染；与此同时，顾客 $3$ 离开餐厅；
- 在时间 $70$，顾客 $4$ 到达餐厅；
- 在时间 $80$，顾客 $2$ 离开餐厅；
- 在时间 $95$，顾客 $4$ 与顾客 $2$ 同时出现在餐厅累计时间为 $10$，因此顾客 $4$ 未感染；与此同时，顾客 $4$ 离开餐厅。

最终顾客 $1,2,3$ 被感染，共 $3$ 人，故第 $1$ 个询问答案为 $3$。

该样例满足子任务 $4,5,6,8,9,10$ 的限制。

#### 【样例解释 #2】

- 在第 $1$ 个询问中，$7$ 个顾客 $1,2,3,4,6,7,8$ 最终被感染，答案为 $7$。
- 在第 $2$ 个询问中，$1$ 个顾客 $1$ 最终被感染，答案为 $1$。
- 在第 $3$ 个询问中，$5$ 个顾客 $2,3,4,7,8$ 最终被感染，答案为 $5$。

该样例满足子任务 $2,3,4,5,6,10$ 的限制。

#### 【样例解释 #3】

该样例满足子任务 $1,2,3,5,6,8,10$ 的限制。

#### 【样例解释 #4】

该样例满足子任务 $4,5,6,9,10$ 的限制。

#### 【样例解释 #5】

该样例满足子任务 $4,5,6,7,8,9,10$ 的限制。

#### 【样例解释 #6】

该样例满足子任务 $4,5,6,7,8,10$ 的限制。

#### 【样例解释 #7】

该样例满足子任务 $4,5,6,7,9,10$ 的限制。

#### 【数据范围】

- $1\le N\le 10^5$；
- $0\le L_i<R_i\le 10^9(1\le i\le N)$；
- $1\le Q\le 10^5$；
- $1\le P_j\le N(1\le j\le Q)$；
- $1\le X_j\le 10^9(1\le j\le Q)$。

#### 【子任务】

1. （$2$ 分）$L_i=0(1\le i\le N)$，$R_i=10(1\le i\le N)$，$Q\le 5$；
2. （$3$ 分）$L_i=0(1\le i\le N)$，$Q\le 5$；
3. （$6$ 分）$L_i=0(1\le i\le N)$；
4. （$10$ 分）$N\le 500$，$Q\le 5$，$R_i\le 500(1\le i\le N)$，$X_j\le 500(1\le j\le Q)$；
5. （$11$ 分）$N\le 500$，$Q\le 5$；
6. （$16$ 分）$Q\le 5$；
7. （$13$ 分）$P_j=1(1\le j\le Q)$，$L_1<L_2<\cdots<L_N$，$R_1<R_2<\cdots<R_N$；
8. （$14$ 分）$P_j=1(1\le j\le Q)$；
9. （$15$ 分）$R_i-L_i(1\le i\le N)$ 的最小值大于或等于 $X_j(1\le j\le Q)$ 的最大值；
10. （$10$ 分）无附加限制。

## 样例 #1

### 输入

```
4
10 40
20 80
45 60
70 95
1
1 15```

### 输出

```
3```

## 样例 #2

### 输入

```
8
0 30
0 90
0 80
0 60
0 20
0 40
0 70
0 50
3
1 30
1 40
4 50```

### 输出

```
7
1
5```

## 样例 #3

### 输入

```
5
0 10
0 10
0 10
0 10
0 10
4
1 9
1 10
1 11
1 1000000000```

### 输出

```
5
5
1
1```

## 样例 #4

### 输入

```
7
38 61
13 27
10 54
22 56
49 75
27 47
70 99
1
3 10```

### 输出

```
6```

## 样例 #5

### 输入

```
10
10 20
11 21
13 23
16 26
20 30
25 35
31 41
38 48
46 56
80 90
4
1 3
1 6
1 8
1 10```

### 输出

```
8
5
3
1```

## 样例 #6

### 输入

```
7
10 54
38 61
13 27
22 56
49 75
27 47
70 99
5
1 3
1 6
1 9
1 12
1 15```

### 输出

```
7
6
6
6
4```

## 样例 #7

### 输入

```
7
38 61
13 27
10 54
22 56
49 75
27 47
70 99
5
1 10
2 10
3 10
4 10
5 10```

### 输出

```
4
6
6
5
2```

# AI分析结果

# 💡 洛语云笺的C++算法解析：感染模拟（Infection Simulation）深入学习指南 💡

> 今天我们来一起分析 JOIG2024 的压轴题——“感染模拟”。这不仅是一道区间题，更是一场关于“时间线+倍增+二维偏序”的思维盛宴。我们将学会如何把复杂的“传染链”拆成清晰的数学条件，并用优雅的算法高效回答每一次询问。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
**“给定 N 位顾客的到店区间 [L_i,R_i]，当累计与他人共处时间 ≥ x 时会被感染。要在 Q 次询问中，快速求出从指定顾客 P_j 出发、传染性为 X_j 时的最终感染人数。”**

✨ **核心算法标签**：倍增（Binary Lifting）、扫描线（Sweep Line）、二维偏序（2D Counting）、可持久化线段树（Persistent Segment Tree）

---

### 🗣️ 初步分析（从朴素到精妙）

1. 最朴素的思路：  
   每次询问做一次 **BFS/DFS** 模拟——把当前感染者集合里所有人能传染的新顾客加入队列，直到没人再被感染。  
   **复杂度：O(Q·N²)**，在 N,Q ≤ 1e5 时直接爆炸。

2. 观察 1：感染传播具有 **单调性**  
   一旦顾客 i 被感染，他只会把感染“向右”传递（时间不会倒流）。因此整个传染链在 **时间轴上单向延伸**。

3. 观察 2：最后离开餐厅的感染者决定了“时间上限”  
   设最终感染时间区间为 [L,R]，则 **R = 最后离开餐厅的感染者的 R**。  
   只要我们能快速求出这个 R，就可以把问题转化为 **二维数点**：
   - 统计所有满足  
     `R_i - max(L_i, L) ≥ X_j` 且 `R_i ≤ R`  
     的顾客个数。

4. 观察 3：倍增求 R  
   把顾客按 R 升序排序后，为每个顾客 i 预先找到“能继续向右传播”的最近顾客 j（即 R_j > R_i 且 L_j 最小），并记录边权 w = R_i - L_j。  
   这样，从 P_j 出发，沿着这些边向右跳，直到边权 < X_j 为止，即可得到 R。  
   **复杂度：O(N log N) 预处理，O(log N) 每次询问**。

5. 观察 4：二维偏序 / 可持久化线段树  
   求出 R 后，只需统计满足  
   `R_i - max(L_i, L_Pj) ≥ X_j` 且 `R_i ≤ R`  
   的顾客个数。  
   可离线扫描线 + 树状数组，也可在线可持久化线段树，时间复杂度 O((N+Q) log N)。

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现与启示 |
|------|-----------|
| **1. 问题目标** | “最终感染人数”暗示需要 **批量统计** 而非逐点模拟。 |
| **2. 单调性** | 感染链在时间轴上单向延伸 → **倍增** 可快速求出最远感染点。 |
| **3. 区间交长度** | “共处时间 ≥ x”可写成 `R_i - max(L_i, L) ≥ x`，天然二维偏序。 |
| **4. 数据规模** | N,Q=1e5，必须 O(N log N) 或 O((N+Q) log N)。 |

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，【线索1】告诉我们暴力模拟不可行，需要 **数学化** 条件。  
> 2. 【线索2】的单调性让我们想到 **倍增**，把“传染链”抽象成有向森林。  
> 3. 【线索3】把“感染条件”转化为二维偏序，于是 **扫描线/可持久化线段树** 登场。  
> 4. 【线索4】确认总复杂度 O((N+Q) log N) 可行。  
> **结论**：倍增求 R + 二维偏序统计，是本题的最优钥匙！

---

## 2. 精选优质题解参考

### 题解一：VainSylphid（赞：2）
* **点评**：  
  思路清晰地把问题拆成“倍增求 R”与“扫描线统计”两步。  
  - 倍增部分：用单调栈 + 排序预处理“向右最近且 L 最小”的后继，再用倍增数组 `g[i][j]` 记录路径上的最小边权，简洁高效。  
  - 统计部分：离线离散化坐标后，用树状数组两次扫描线（一次插入区间，一次回答询问），代码紧凑。

### 题解二：Miss_SGT（赞：1）
* **点评**：  
  与 VainSylphid 思路一致，但代码更短：  
  - 用 **并查集** 在扫描线过程中维护“已合并的祖先”，避免显式倍增数组，常数更小。  
  - 适合喜欢并查集技巧的同学参考。

### 题解三：To_our_starry_sea（赞：0）
* **点评**：  
  提供 **在线做法**：  
  - 同样倍增求 R。  
  - 使用 **可持久化线段树** 在线回答二维数点，避免离线排序询问。  
  - 代码较长，但展示了动态开点技巧，适合想练习可持久化数据结构的同学。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）

| 关键点 | 分析与学习笔记 |
|--------|----------------|
| **1. 倍增求 R** | 把“传染链”建模为 **有向森林**：每个顾客 i 的后继 j 满足 R_j > R_i 且 L_j 最小，边权 w = R_i - L_j。倍增数组 `g[k][i]` 记录从 i 向上 2^k 步路径上的最小边权，O(N log N) 预处理。 |
| **2. 二维数点** | 感染条件等价于：R_i ∈ [L_Pj + X_j, R] 且 R_i - L_i ≥ X_j。离线后可用 **扫描线 + 树状数组** 解决；在线可用 **可持久化线段树** 维护 (R_i, R_i-L_i) 的二维信息。 |
| **3. 离散化与坐标压缩** | 由于 L_i, R_i, X_j 可达 1e9，需离散化坐标。使用 `std::lower_bound` 即可，注意把 `R_i-L_i` 也一起离散。 |

---

### ✨ 解题技巧总结

- **问题转化**：把“模拟感染”转化为“倍增求最远感染时间 + 二维偏序统计”。  
- **单调性利用**：单调栈/单调队列是寻找“最近且满足某条件”的经典技巧。  
- **扫描线模板**：二维偏序问题 → 按一维排序，另一维用树状数组/线段树维护。  
- **并查集优化**：在扫描线过程中用并查集合并已处理区间，避免显式倍增。

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分预期 |
|------|----------|------|------|------------------|
| **暴力模拟** | BFS/DFS 逐层传染 | 思路直观 | O(Q·N²) 爆炸 | 子任务 4,5 (N≤500, Q≤5) 可得部分分 |
| **倍增+扫描线** | 倍增求 R，离线二维偏序 | O((N+Q) log N) 最优 | 需离线 | 全场满分 |
| **倍增+可持久化线段树** | 倍增求 R，在线二维偏序 | 在线回答，无需离线排序 | 代码较长，常数较大 | 需要在线或练习可持久化数据结构 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 1. **起点：暴力模拟**  
>    直接 BFS 会超时，因为每次询问都要重新扫 N 个人。  
> 2. **发现瓶颈：重复计算**  
>    每次询问都独立处理，无法共享信息。  
> 3. **优化钥匙：倍增 + 二维偏序**  
>    - 倍增预处理传染链，O(log N) 求出 R。  
>    - 二维偏序把“统计满足条件的区间”变成经典问题，可共享数据结构。  
> 4. **模型升华：从“模拟”到“数学”**  
>    把感染条件写成不等式，再抽象为二维平面上的点计数，实现从 O(N²) 到 O(N log N) 的飞跃。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（倍增 + 扫描线版）

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

const int N = 1e5 + 5, LOG = 18;

struct Interval { ll L, R; } a[N];
int n, Q;

// ---------- 倍增预处理 ----------
int p[N];               // 按 R 排序后的下标
int nxt[LOG][N];        // 倍增后继
ll  minW[LOG][N];       // 路径上的最小边权

// ---------- 扫描线 ----------
struct Event {
    ll x, yl, yr;
    int type, id;   // type = 1: 询问差分; type = 0: 插入
};
vector<Event> ev;

ll ans[N];

// ---------- 树状数组 ----------
ll bit[N * 4];
void upd(int x, int v) { for (; x < N * 4; x += x & -x) bit[x] += v; }
ll qry(int x) { ll s = 0; for (; x; x -= x & -x) s += bit[x]; return s; }

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> a[i].L >> a[i].R;

    // ---------- 1. 预处理倍增 ----------
    iota(p + 1, p + n + 1, 1);
    sort(p + 1, p + n + 1, [&](int i, int j) { return a[i].R < a[j].R; });

    int ptr = n;
    int best = 0;
    for (int i = n; i >= 1; --i) {
        int u = p[i];
        while (ptr > i && a[p[ptr]].R > a[u].R) {
            if (!best || a[p[ptr]].L < a[best].L) best = p[ptr];
            --ptr;
        }
        if (best && a[best].L < a[u].R) {
            nxt[0][u] = best;
            minW[0][u] = a[u].R - a[best].L;
        } else {
            nxt[0][u] = 0;
            minW[0][u] = 1e18;
        }
    }

    for (int k = 1; k < LOG; ++k) {
        for (int i = 1; i <= n; ++i) {
            nxt[k][i] = nxt[k - 1][nxt[k - 1][i]];
            minW[k][i] = min(minW[k - 1][i], minW[k - 1][nxt[k - 1][i]]);
        }
    }

    // ---------- 2. 处理询问 ----------
    cin >> Q;
    for (int q = 1; q <= Q; ++q) {
        ll P, X; cin >> P >> X;
        if (a[P].R - a[P].L < X) { ans[q] = 1; continue; }

        ll L = a[P].L, R = a[P].R;
        int cur = P;
        for (int k = LOG - 1; k >= 0; --k)
            if (minW[k][cur] >= X) cur = nxt[k][cur];
        R = a[cur].R;

        // 条件: R_i >= L + X, R_i <= R, R_i - L_i >= X
        ev.push_back({ R, L + X, R, 1, q });
        ev.push_back({ L + X - 1, L + X, R, -1, q });
    }

    // ---------- 3. 离散化并扫描线 ----------
    vector<ll> ys;
    for (int i = 1; i <= n; ++i) {
        ys.push_back(a[i].R - a[i].L);
        ev.push_back({ a[i].R, a[i].R - a[i].L, 0, 0, 0 });
    }
    sort(ys.begin(), ys.end());
    ys.erase(unique(ys.begin(), ys.end()), ys.end());
    auto get = [&](ll v) { return lower_bound(ys.begin(), ys.end(), v) - ys.begin() + 1; };

    sort(ev.begin(), ev.end(), [&](const Event& a, const Event& b) {
        return a.x < b.x || (a.x == b.x && a.type < b.type);
    });

    for (auto [x, yl, yr, type, id] : ev) {
        int yl_idx = get(yl), yr_idx = get(yr);
        if (type == 0) {
            upd(get(a[yl].R - a[yl].L), 1);
        } else {
            ll cnt = qry(yr_idx) - qry(yl_idx - 1);
            ans[id] += type * cnt;
        }
    }

    for (int q = 1; q <= Q; ++q) cout << ans[q] << '\n';
    return 0;
}
```

* **代码解读概要**：  
  1. 预处理阶段用单调栈找“向右最近 L 最小”的后继，建立倍增数组。  
  2. 对每个询问用倍增求出最远感染时间 R。  
  3. 把“统计满足条件的区间”转化为二维偏序，用扫描线+树状数组解决。  

---

## 5. 算法可视化：像素动画演示

* **动画主题**：  
  “像素时间线”——在 8 位像素风格的水平时间轴上，顾客以彩色方块出现，感染以闪烁扩散。

* **核心演示内容**：  
  1. **倍增跳跃**：顾客方块向右跳，每次跳 2^k 步，路径最小边权用红色数字显示。  
  2. **扫描线**：一条垂直扫描线从左向右移动，遇到顾客方块就插入树状数组；遇到询问就弹出计数。  
  3. **音效**：  
     - “叮”：插入树状数组。  
     - “咚”：回答询问。  
     - “胜利”音：找到最终感染人数。

* **交互面板**：  
  - 单步/自动播放按钮。  
  - 速度滑块。  
  - 可切换“倍增模式”与“扫描线模式”。

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**  
  - 倍增求最远可达节点：适用于“区间覆盖”、“跳跃游戏”等问题。  
  - 扫描线二维偏序：适用于“区间交统计”、“矩形覆盖”等问题。

* **洛谷推荐**  
  1. P1972 [HH的项链]：二维偏序裸题，练习扫描线+树状数组。  
  2. P3379 最近公共祖先：倍增模板，巩固倍增思想。  
  3. P4551 最长异或路径：倍增 + Trie，拓展倍增应用场景。

---

## 7. 学习心得与经验分享

> **来自 VainSylphid**：“我在预处理倍增时，最初把 `minW` 的初始值设成了 0，导致跳过头。后来改成 1e18 就通过了。提醒大家在倍增中，边界值要足够大/小。”  
> **点评**：倍增数组的初始边界值是常见坑点，务必检查。

---

<conclusion>  
本次“感染模拟”之旅到此结束。我们学会了如何用倍增快速锁定传染链的终点，再用扫描线优雅地统计答案。记住：复杂模拟题往往隐藏着“数学结构”与“经典算法”的钥匙。下次见！
</conclusion>

---
处理用时：83.27秒
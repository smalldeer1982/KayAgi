# 题目信息

# 调的啥啊

## 题目背景

**为避免卡常，本题时限为比赛时的 2 倍。**

你试过用笔记本的触摸板操作扒谱吗？

阿绫正在玩天依——最新的 X Studio 声库，由于触控板和鼠标神秘失踪，她每调整一个音符都极其费力……


## 题目描述

在阿绫正在调的序列中一共有 $n$ 个音符，从左至右第 $i$ 个音符的音高为 $s_i$。阿绫发现其中三个音符 $s_i,s_j,s_k~(1\le i<j<k\le n)$ 产生的听感不佳，她决定将它们调整为 $s_i',s_j',s_k'$，使得 $s_i'\le s_k'$ 且 $s_j'\le s_k'$。扒拉触摸板真的很难受：

- 调节 $s_i$ 到 $s_i'$ 需要耗费阿绫 $a\times|s_i-s_i'|$ 的精力；
- 调节 $s_j$ 到 $s_j'$ 需要耗费阿绫 $b\times|s_j-s_j'|$ 的精力；
- 调节 $s_k$ 到 $s_k'$ 需要耗费阿绫 $c\times|s_k-s_k'|$ 的精力。

于是，调节完这三个音符，阿绫耗费的精力为：
$$
z=a\cdot|s_i-s_i'|+b\cdot|s_j-s_j'|+c\cdot|s_k-s_k'|.
$$

阿绫自然会找到使得 $z$ 值最小的 $(s_i',s_j',s_k')$，记此时的 $z$ 值为 $f(i,j,k)$。现在阿绫想知道，对于所有满足 $i<j<k$ 的 $(i,j,k)$，$f(i,j,k)$ 之和是多少呢？你只需要回答她这一答案对 $2^{32}$ 取模的结果。

## 说明/提示

### 样例解释

$f(1,2,3)=4$，其中一组最优的 $(s_i',s_j',s_k')$ 为 $(2,3,3)$。

$f(1,2,4)=13$，其中一组最优的 $(s_i',s_j',s_k')$ 为 $(2,2,2)$。

$f(1,3,4)=9$，其中一组最优的 $(s_i',s_j',s_k')$ 为 $(2,2,2)$。

$f(2,3,4)=13$，其中一组最优的 $(s_i',s_j',s_k')$ 为 $(3,3,3)$。

$f(i,j,k)$ 的总和为 $4+13+9+13=39$。

### 数据规模与约定

**本题采用捆绑测试。** 仅当你通过了该子任务的全部测试数据才能获得该子任务的分值。

对于 $100\%$ 的数据，$3\le n\le5\times10^5$，$1\le s_i,a,b,c\le 10^9$。

对于不同的子任务，作如下约定：

| 子任务编号	| $n$ | 特殊性质 | 子任务分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $=3$ | 无 | $5$ |
| $2$ | $\le300$ | 无 | $5$ |
| $3$ | $\le1000$ | 无 | $10$ |
| $4$ | $\le5\times10^3$ | 无 | $20$ |
| $5$ | $\le5\times10^4$ | 无 | $20$ |
| $6$ | $\le5\times10^5$ | 有 | $20$ |
| $7$ | $\le5\times10^5$ | 无 | $20$ |

特殊性质：出现的不同音高不超过 $10$ 种。

## 样例 #1

### 输入

```
4
3 4 5
2 4 3 1```

### 输出

```
39```

# AI分析结果

# 💡 洛语云笺的C++算法解析：调的啥啊 深入学习指南 💡

> 大家好，我是你们的算法导师洛语云笺！今天我们来拆解一道“听上去像音游，实际上是数学题”的有趣题目——《调的啥啊》。  
> 它看似在讲音符，实则考察如何把“绝对值最小化”转化为“分段函数”，再用数据结构高效统计。准备好跟我一起扒谱了吗？🎹

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
把“三个音符满足 $s_i'\le s_k', s_j'\le s_k'$ 时总调整代价最小”这个条件，拆解成**可计算的数学表达式**，并在 **O(n log n)** 时间内对所有有序三元组求和。

✨ **核心算法标签**：  
数学推导 + 离散化 + 权值线段树 / 树状数组（前缀/后缀统计）

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现过程 | 指向策略 |
|---|---|---|
| **线索1：目标是最小化绝对值之和** | $z = a|s_i-s_i'| + b|s_j-s_j'| + c|s_k-s_k'|$ | 经典“绝对值最小”套路 → **最优解一定取离散点** |
| **线索2：约束是 $s_i', s_j' \le s_k'$** | 变量有顺序关系 | 把 $s_k'$ 当成“阈值”，分段讨论 $s_i,s_j$ 与阈值的大小 |
| **线索3：数据范围 n ≤ 5×10⁵** | 纯暴力 O(n³) 爆炸 | 需要 **O(n log n)** 的统计结构 → 树状数组 / 线段树 |

---

### 🧠 思维链构建：从线索到策略

1. 先想暴力：枚举所有 (i,j,k) 并枚举 $s_i',s_j',s_k'$ → 不可接受。  
2. 关键观察：最优 $(s_i',s_j',s_k')$ 一定落在 $\{s_i,s_j,s_k\}$ 中，因此 $f(i,j,k)$ 可以写成**只与 $s_i,s_j,s_k$ 有关的代数式**。  
3. 代数化后，发现总答案可以拆成 3 个“前缀/后缀统计”问题 → 用 **权值线段树** 或 **树状数组** 维护“个数 × 值”与“值的和”。  
4. 离散化音高后，复杂度降到 **O(n log n)**，完美通过！

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 推荐指数 |
|---|---|---|
| **lmh (7赞)** | 用权值线段树维护区间“个数、和、加权和”，把五种情况统一成区间查询，思路最系统 | ⭐⭐⭐⭐⭐ |
| **xieziheng (4赞)** | 纯树状数组实现，常数更小；通过“容斥+前缀和”巧妙避开线段树，实战最快 | ⭐⭐⭐⭐ |
| **E_firework (4赞)** | 把答案拆成 3 个“前缀/后缀统计”模板，代码清晰，适合第一次学习权值结构 | ⭐⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

#### 难点1：把绝对值最小化写成**分段函数**
- **分析**  
  固定 $s_k'=t$，则 $s_i',s_j'$ 只能选 $\min(s_i,t)$ 和 $\min(s_j,t)$。  
  代入后可得：
  $$
  f(i,j,k)=\begin{cases}
  0 & s_i,s_j\le s_k\\[4pt]
  \min(b,c)\,(s_j-s_k) & s_i\le s_k<s_j\\[4pt]
  \min(a,c)\,(s_i-s_k) & s_j\le s_k<s_i\\[4pt]
  \dots & \text{其他组合}
  \end{cases}
  $$
- 💡 **学习笔记**  
  把绝对值问题变成“取 min / max 的代数式”是常见套路，后续只需统计“满足某条件的 (i,j,k) 个数与和”。

#### 难点2：把三元组统计拆成**二维前缀/后缀**
- **分析**  
  以“统计所有 $s_i>s_k$ 且 $s_j\le s_k$ 的 $(i,j,k)$”为例：  
  枚举 $k$，用权值线段树维护前缀中 **$>s_k$ 的个数与和**，即可 O(log n) 得到当前 $k$ 的贡献。
- 💡 **学习笔记**  
  把“三元组”拆成“枚举中间元素 + 前缀/后缀统计”是处理高维统计的常用技巧。

#### 难点3：离散化 + 权值结构实现
- **分析**  
  音高值域 $10^9$ → 离散化到 $[1,n]$。  
  线段树节点存：  
  - `cnt`：区间元素个数  
  - `sum`：区间元素值和  
  - `wsum`：区间元素 × 排名 的和  
  合并节点时用乘法分配律即可。
- 💡 **学习笔记**  
  离散化后，权值线段树/树状数组的常数远小于平衡树，且支持区间查询。

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 复杂度 | 优点 | 缺点 | 得分预期 |
|---|---|---|---|---|---|
| **暴力枚举** | 三层循环 + 枚举 3 个取值 | O(n³·3³) | 思路直观 | 无法通过 n≥1000 | 10-20 |
| **固定 sₖ 后枚举 sᵢ,sⱼ** | 离散化 + 二维前缀和 | O(n² log n) | 实现简单 | n=5×10³ 已超时 | 20-40 |
| **权值线段树统计** | 拆成 3 个“前缀/后缀统计” | O(n log n) | 最优复杂度 | 需要推导分段函数 | 100 |
| **树状数组容斥** | 把二维条件容斥成前缀 | O(n log n) | 常数更小 | 推导复杂 | 100 |

---

## 4. C++核心代码实现赏析

### 通用核心实现（基于 E_firework 思路，精简版）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef unsigned int uint;
const int N = 5e5 + 5;

uint n, a, b, c, s[N], rk[N], ans;

// 权值线段树节点
struct Node {
    uint cnt, sum, wsum;   // cnt: 个数, sum: 值和, wsum: 值×排名和
    Node() { cnt = sum = wsum = 0; }
    Node operator+(const Node& rhs) const {
        Node ret;
        ret.cnt = cnt + rhs.cnt;
        ret.sum = sum + rhs.sum;
        ret.wsum = wsum + rhs.wsum + cnt * rhs.sum;
        return ret;
    }
} tr[1 << 21];
int k;

// 离散化
void discrete() {
    static pair<uint, int> tmp[N];
    for (int i = 1; i <= n; ++i) tmp[i] = {s[i], i};
    sort(tmp + 1, tmp + n + 1);
    for (int i = 1; i <= n; ++i) rk[tmp[i].second] = i;
}

// 线段树单点更新
void upd(int x, uint v) {
    int i = (1 << k) + x - 1;
    tr[i].cnt = 1; tr[i].sum = v; tr[i].wsum = 0;
    while (i >>= 1) tr[i] = tr[i << 1] + tr[i << 1 | 1];
}

// 查询前缀信息
Node queryL(int x) {
    Node ret; int i = (1 << k) + x - 1;
    while (i >>= 1) if (i & 1) ret = tr[i ^ 1] + ret;
    return ret;
}

// 查询后缀信息
Node queryR(int x) {
    Node ret; int i = (1 << k) + x - 1;
    while (i >>= 1) if (!(i & 1)) ret = ret + tr[i ^ 1];
    return ret;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> a >> b >> c;
    for (int i = 1; i <= n; ++i) cin >> s[i];
    discrete();
    // 预处理 k
    k = 0; while ((1 << k) < n) ++k;

    // 计算 ans
    a = min(a, c);
    b = min(b, c);
    c = min(a + b, c);

    // 计算 b·max(s_j - max(s_i,s_k),0) 的贡献
    for (int i = 1; i <= n; ++i) {
        Node L = queryL(rk[i]);
        Node R = queryR(rk[i]);
        ans += b * ((L.cnt * (L.cnt - 1) / 2) * s[i] - L.wsum);
        ans += c * (R.wsum - (R.cnt * (R.cnt - 1) / 2) * s[i]);
        upd(rk[i], s[i]);
    }

    // 计算 a·max(s_i - max(s_j,s_k),0) 的贡献
    for (int i = 1; i <= (1 << (k + 1)); ++i) tr[i] = Node();
    for (int i = n; i >= 1; --i) {
        Node L = queryL(rk[i]);
        ans += a * ((L.cnt * (L.cnt - 1) / 2) * s[i] - L.wsum);
        upd(rk[i], s[i]);
    }

    cout << ans << '\n';
    return 0;
}
```

---

### 代码片段赏析（xieziheng 树状数组版）
```cpp
// 计算第四种情况：x>y>z 的贡献
uint ss = 0;
for (int i = n; i; --i) {
    ss += (c - b) * d[s[i]] * ((ss - A.get1(s[i])) - (FF(h[i]) - ff[i]));
    ss += g[i];
    A.add(s[i], g[i]);
}
```
- **亮点**：用树状数组维护“前缀和 + 组合数公式”，避免线段树常数。  
- **学习笔记**：当需要“前缀个数 × 前缀和”时，树状数组 + 容斥往往比线段树更快。

---

## 5. 算法可视化：像素动画演示

### 动画主题
**“像素调音师”**  
8 位像素风格的调音台，一排彩色方块代表音符。  
每步操作伴随“叮”的 8-bit 音效。

### 关键帧设计
1. **离散化阶段**  
   音符方块按高度排序，生成像素化“坐标轴”。
2. **权值线段树插入**  
   方块飞入对应高度的“槽位”，节点闪烁显示 `cnt / sum / wsum` 更新。
3. **查询阶段**  
   当前方块高亮，左右两侧出现像素箭头指向“前缀”和“后缀”，实时显示计算出的贡献值。
4. **音效提示**  
   - 插入成功：↑ 音  
   - 查询完成：→ 音  
   - 总答案累加：胜利音阶 🎉

### 交互面板
- 步进 / 自动播放 / 调速滑块  
- 显示当前代码行与变量值（像素字体）

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
1. **绝对值最小化 → 分段函数**  
   适用于“最小化曼哈顿距离”、“最小化 L1 损失”类问题。
2. **三维统计 → 枚举中间 + 前缀/后缀**  
   常见于“逆序对”、“三维偏序”问题。
3. **离散化 + 权值结构**  
   几乎所有值域大但数据量大的计数题。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P3374 【模板】树状数组 1 | 掌握基础单点/区间查询 |
| P3368 【模板】树状数组 2 | 区间修改 + 单点查询 |
| P1908 逆序对 | 经典“前缀统计”入门 |
| P5267 简单的数学题 | 三维偏序，需树套树 |

---

## 7. 学习心得与经验分享

> 来自 **xieziheng** 的调试心得：  
> “我最初把离散化后的下标写错了一位，导致贡献计算全乱。后来用 `assert` 打印了前 10 个元素的离散值，才发现问题。调试绝对值问题时，**手算小样例** + **打印中间数组** 是最快的排错手段。”

**洛语云笺点评**：  
绝对值类题目往往“差之毫厘，失之千里”。把分段函数写清楚后，**先跑 n=10 的小数据** 验证代数式，再上线段树，是避免返工的捷径！

---

<conclusion>
今天我们学会了如何把“调音”变成“数学”，把“绝对值”拆成“分段函数”，再用权值结构优雅统计。下次遇到类似的“看似模拟，实则计数”的题目，记得先代数化，再数据结构化！  
继续加油，算法之路，音浪不停！🎶
</conclusion>

---
处理用时：103.69秒
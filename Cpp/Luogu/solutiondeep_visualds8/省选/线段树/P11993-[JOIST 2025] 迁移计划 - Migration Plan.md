# 题目信息

# [JOIST 2025] 迁移计划 / Migration Plan

## 题目背景

本题测试点极大，评测时可能需要等待较长时间加载测试点。

## 题目描述




JOI 王国由编号从 $1$ 到 $N$ 的 $N$ 个城市组成。这些城市通过 $N − 1$ 条单向道路连接。具体来说，对于每个 $i = 2, 3, \ldots, N$，存在一条从城市 $i$ 通向城市 $P_i$ 的道路。此处保证 $1 \leq P_i < i$。

每个城市有一个定义好的危险等级。首都（城市 $1$）的危险等级为 $0$。对于城市 $i$（$2 \leq i \leq N$），其危险等级定义为从该城市到城市 $1$ 的路径中经过的道路数量。根据 JOI 王国的结构，从任意城市 $i$ 到城市 $1$ 的路径存在且唯一。

当前，城市 $i$（$1 \leq i \leq N$）居住着 $K_i$ 只海狸。JOI 王国的总统 Bitaro 计划实施海狸迁移计划。该计划将在 $Q$ 天内执行。在第 $j$ 天（$1 \leq j \leq Q$），以下三类事件之一会发生：

- 迁移：当时刻所有居住在危险等级为 $X_j$ 的城市的海狸会迁移到危险等级为 $Y_j$ 的城市，该城市需满足从当前城市出发沿道路行进可达。保证 $0 \leq Y_j < X_j$。根据 JOI 王国的结构，每只海狸的迁移目的地唯一确定。
- 迁入：由于王国外的迁入，城市 $A_j$ 的海狸数量增加 $L_j$。
- 调查： 调查当前时刻城市 $B_j$ 居住的海狸数量。

作为 Bitaro 的下属，你发现无需实地考察即可根据迁移计划信息计算出每次调查事件时的海狸数量。

给定 JOI 王国的结构、各城市当前的海狸数量及迁移计划详情，请编写程序计算每次调查事件的结果。


## 说明/提示


### 样例解释


#### 样例 $1$ 解释
初始时，城市 $1$, $2$, $3$, $4$ 分别有 $1$, $3$, $4$, $3$ 只海狸。这些城市的危险等级分别为 $0$, $1$, $1$, $2$。

- 第 $1$ 天发生调查事件。第一行输出 $1$，表示城市 $1$ 的海狸数量。
- 第 $2$ 天发生迁移事件。城市 $2$ 和 $3$ 的海狸全部迁移到城市 $1$。第 $2$ 天结束时，城市 $1$, $2$, $3$, $4$ 分别有 $8$, $0$, $0$, $3$ 只海狸。
- 第 $3$ 天发生调查事件。第二行输出 $8$。
- 第 $4$ 天发生调查事件。第三行输出 $0$。
- 第 $5$ 天发生迁移事件。城市 $4$ 的海狸全部迁移到城市 $2$。第 $5$ 天结束时，城市 $1$, $2$, $3$, $4$ 分别有 $8$, $3$, $0$, $0$ 只海狸。
- 第 $6$ 天发生调查事件。第四行输出 $3$。

该样例满足子任务 $2\sim 7$ 的限制。

#### 样例 $2$ 解释
初始时，城市 $1$, $2$, $3$ 分别有 $3$, $1$, $4$ 只海狸。这些城市的危险等级分别为 $0$, $1$, $1$。

- 第 $1$ 天发生迁入事件。城市 $2$ 的海狸数量增加 $5$。第 $1$ 天结束时，城市 $1$, $2$, $3$ 分别有 $3$, $6$, $4$ 只海狸。
- 第 $2$ 天发生迁移事件。无海狸迁移，因为不存在危险等级为 $2$ 的城市。
- 第 $3$ 天发生调查事件。第一行输出 $3$。
- 第 $4$ 天发生迁移事件。城市 $2$ 和 $3$ 的海狸全部迁移到城市 $1$。第 $4$ 天结束时，城市 $1$, $2$, $3$ 分别有 $13$, $0$, $0$ 只海狸。
- 第 $5$ 天发生调查事件。第二行输出 $13$。
- 第 $6$ 天发生调查事件。第三行输出 $0$。
后续事件类似发生，此处省略具体描述。

该样例满足子任务 $1\sim 3,7$ 的限制。


#### 样例 $3$ 解释

该样例满足子任务 $2,3,5,7$ 的限制。



### 数据范围
- $2 \leq N \leq 2\,000\,000$。
- $1 \leq P_i < i$（$2 \leq i \leq N$）。
- $0 \leq K_i \leq 100$（$1 \leq i \leq N$）。
- $1 \leq Q \leq 2\,000\,000$。
- $T_j$ 的取值为 $1$, $2$ 或 $3$（$1 \leq j \leq Q$）。
- 若 $T_j = 1$，则 $0 \leq Y_j < X_j \leq N − 1$（$1 \leq j \leq Q$）。
- 若 $T_j = 2$，则 $1 \leq A_j \leq N$，$1 \leq L_j \leq 100$（$1 \leq j \leq Q$）。
- 若 $T_j = 3$，则 $1 \leq B_j \leq N$（$1 \leq j \leq Q$）。
- 至少存在一个 $j$（$1 \leq j \leq Q$）满足 $T_j = 3$。
- 所有输入值为整数。

### 子任务
设城市最大危险等级为 $D$。

- $\text{Subtask 1 (4 pts)}$：$D = 1$。
- $\text{Subtask 2 (8 pts)}$：$N \leq 20$。
- $\text{Subtask 3 (13 pts)}$：$D \leq 20$。
- $\text{Subtask 4 (15 pts)}$：不存在 $T_j = 2$ 的查询，且最多有 $5$ 个 $T_j = 3$ 的查询。
- $\text{Subtask 5 (15 pts)}$：最多有 $5$ 个 $T_j = 3$ 的查询。
- $\text{Subtask 6 (27 pts)}$：不存在 $T_j = 2$ 的查询。
- $\text{Subtask 7 (18 pts)}$：无额外限制。


## 样例 #1

### 输入

```
4
1 1 2
1 3 4 3
6
3 1
1 1 0
3 1
3 2
1 2 1
3 2```

### 输出

```
1
8
0
3```

## 样例 #2

### 输入

```
3
1 1
3 1 4
11
2 2 5
1 2 0
3 1
1 1 0
3 1
3 2
2 3 4
3 3
1 1 0
3 3
3 1```

### 输出

```
3
13
0
4
0
17```

## 样例 #3

### 输入

```
7
1 2 1 3 3 2
5 2 8 9 4 0 5
10
1 3 1
2 4 10
3 2
1 6 3
1 2 0
3 1
3 4
2 5 6
3 5
3 3```

### 输出

```
6
18
19
6
0```

# AI分析结果

```markdown
# 💡 洛语云笺的C++算法解析：  
# [JOIST 2025] 迁移计划 / Migration Plan 深入学习指南 💡

> 今天我们化身“像素探险家”，一起用线段树合并这把“像素锤”，敲开这道 200 万规模的大树难题！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
在 **一棵 200 万个节点的树** 上，支持三种操作：  
1. 把 **整层** 节点的所有海狸 **整体迁移到它们的祖先层**；  
2. 单点增加海狸；  
3. 查询某节点 **当前真实海狸数**（需把所有迁移后的贡献累加）。  

### ✨ 核心算法标签
- **线段树合并**（Segment Tree Merge）  
- **DFS 序 + 动态开点线段树**  
- **离线思想 + 深度分层**

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现内容 | 指向策略 |
|---|---|---|
| **线索1：操作规模** | N, Q ≤ 2×10⁶，暴力 O(NQ) 必 TLE | 需要 **O((N+Q) log N)** 级算法 |
| **线索2：迁移规则** | “整层整体迁移到祖先层” → **整层数据整体移动** | 想到 **“合并两棵线段树”** 而非逐点修改 |
| **线索3：查询规则** | 查询某节点子树内 **当前深度** 的所有贡献 | DFS 序把子树 → 区间，天然适配 **区间求和** |

---

### 🧠 思维链构建：从线索到策略

1. 暴力思路：逐点找祖先再单点加 → **200 万次迁移 × 200 万个节点** → 爆炸！  
2. 观察迁移：一次操作把 **整层节点** 整体搬到另一层 → 可以 **整棵树合并**！  
3. 观察查询：需要知道 **“当前某节点子树内，深度恰好为 d 的所有节点”** 的贡献 → **DFS 序 + 深度分层线段树** 完美契合。  
4. **结论**：  
   - 给 **每个深度 d** 建一棵 **以 DFS 序为下标的线段树**；  
   - 迁移：线段树合并；  
   - 查询：子树区间求和。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 | 学习笔记 |
|---|---|---|
| **Aegleseeker_** (赞：6) | 首次提出 **“把整层合并而非逐点”** 的核心洞察 | **“整层合并”** 是降维打击的关键 |
| **Mirasycle** (赞：4) | 用简洁语言解释 **“dfs 序 + 深度线段树”** 模型 | 代码短、思路清晰，适合入门 |
| **Colinxu2020** (赞：1) | 给出 **完整 AC 代码**，结构模块化，变量命名规范 | 可直接作为 **模板** 使用 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解）

| 关键点 | 分析 | 学习笔记 |
|---|---|---|
| **1. 如何表示“整层”** | 以 **深度 d** 为索引，每深度一棵线段树 | 把“树”拆成“森林”，每棵树管一层 |
| **2. 如何表示“子树”** | **DFS 序** 把子树 → 连续区间 [dfn[u], dfn[u]+sz[u]-1] | DFS 序是子树问题的万能钥匙 |
| **3. 如何迁移** | 线段树合并：把 **深度 x 的树** 合并到 **深度 y** 上，然后清空 x | 复杂度 O(节点数 log N)，可证总节点数 O(N+Q) |

---

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 复杂度 | 适用场景 | 得分预期 |
|---|---|---|---|---|
| **暴力逐点** | 每迁移一次，逐点找祖先累加 | O(NQ) | 样例 2 规模 N≤20 | 8 pts |
| **DFS 序 + 差分数组** | 离线 + 差分 + 扫描线 | O((N+Q) log N) | 无单点加，仅 Sub6 | 27 pts |
| **线段树合并（正解）** | 深度分层 + 线段树合并 | **O((N+Q) log N)** | 无限制 | **100 pts** |

---

### ✨ 优化之旅：从“能做”到“做好”

1. **起点：逐点暴力** → 2e6×2e6 次操作 → 爆炸！  
2. **发现瓶颈：重复遍历整层** → 每次迁移都要扫一遍整层节点。  
3. **优化钥匙：整层合并** → 用 **线段树合并** 把整层节点打包带走。  
4. **模型升华：深度分层线段树** → 把“树结构”拆成“深度切片”，用 **DFS 序** 把子树变区间，一切迎刃而解！

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
**说明**：综合题解中思路最清晰、实现最简洁的 **Mirasycle** 版本，可作为 **标准模板**。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e6 + 10;
int n, q, fa[N], dep[N], dfn[N], sz[N], tot, rt[N], cnt;
vector<int> e[N];

struct Seg {
    int sum[N << 5], ls[N << 5], rs[N << 5];
    void add(int &p, int l, int r, int x, int v) {
        if (!p) p = ++cnt;
        if (l == r) { sum[p] += v; return; }
        int mid = (l + r) >> 1;
        if (x <= mid) add(ls[p], l, mid, x, v);
        else add(rs[p], mid + 1, r, x, v);
        sum[p] = sum[ls[p]] + sum[rs[p]];
    }
    int merge(int a, int b, int l, int r) {
        if (!a || !b) return a + b;
        if (l == r) { sum[a] += sum[b]; return a; }
        int mid = (l + r) >> 1;
        ls[a] = merge(ls[a], ls[b], l, mid);
        rs[a] = merge(rs[a], rs[b], mid + 1, r);
        sum[a] = sum[ls[a]] + sum[rs[a]];
        return a;
    }
    int ask(int p, int l, int r, int ql, int qr) {
        if (!p || ql > qr) return 0;
        if (ql <= l && r <= qr) return sum[p];
        int mid = (l + r) >> 1, res = 0;
        if (ql <= mid) res += ask(ls[p], l, mid, ql, qr);
        if (qr > mid) res += ask(rs[p], mid + 1, r, ql, qr);
        return res;
    }
} T;

void dfs(int u) {
    dfn[u] = ++tot;
    sz[u] = 1;
    for (int v : e[u]) {
        dep[v] = dep[u] + 1;
        dfs(v);
        sz[u] += sz[v];
    }
}

int main() {
    ios::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    for (int i = 2, p; i <= n; ++i) {
        cin >> p;
        e[p].push_back(i);
    }
    dep[1] = 0;
    dfs(1);
    for (int i = 1, k; i <= n; ++i) {
        cin >> k;
        T.add(rt[dep[i]], 1, n, dfn[i], k);
    }
    cin >> q;
    while (q--) {
        int op, x, y;
        cin >> op;
        if (op == 1) {
            cin >> x >> y;               // 深度 x -> y
            rt[y] = T.merge(rt[y], rt[x], 1, n);
            rt[x] = 0;
        } else if (op == 2) {
            cin >> x >> y;               // 城市 x 增加 y
            T.add(rt[dep[x]], 1, n, dfn[x], y);
        } else {
            cin >> x;
            cout << T.ask(rt[dep[x]], 1, n, dfn[x], dfn[x] + sz[x] - 1) << '\n';
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题  
**《像素海狸大迁徙》** —— 8 位 FC 风格像素世界，海狸们在树上“跳层”！

### 🎯 核心演示  
- **深度分层**：屏幕左侧竖排 8×8 像素条，代表 0~D 深度。  
- **线段树节点**：每个深度条内，用 **绿色像素块高度** 表示该 DFS 序区间内的海狸数。  
- **迁移事件**（操作1）：  
  1. 高亮源深度条（红色闪烁）。  
  2. 播放 **“叮-咚”** 8 位音效。  
  3. 绿色像素块 **整体滑入** 目标深度条，完成线段树合并动画。  
  4. 源深度条 **清空**（像素块瞬间消失）。  
- **迁入事件**（操作2）：对应像素块 **+1 像素高度** 动画。  
- **调查事件**（操作3）：  
  1. 高亮查询节点子树区间（黄色边框）。  
  2. 目标深度条中 **子树区间像素块** 闪白求和。  
  3. 弹出 8 位像素对话框： `“海狸数 = 42”` 伴随胜利音效。

### 🕹️ 交互面板  
- **步进 / 自动播放** 滑块（1~60 FPS）。  
- **重置** 按钮回到初始状态。  
- **AI 演示模式**：自动完成所有操作，像“贪吃蛇 AI”一样流畅。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **线段树合并** 还能解决：  
  1. **树上背包合并**（P3177 树上染色）  
  2. **树上路径统计**（P3899 树的统计）  
  3. **颜色段合并**（P3201 梦幻布丁）

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P3201** | 线段树合并的“颜色段”经典模板，迁移思路与本题完全一致。 |
| **P3177** | 树上背包 + 线段树合并，强化“合并子树信息”能力。 |
| **P3899** | 练习用 DFS 序 + 线段树处理树上路径查询。 |

---

## 7. 学习心得与经验分享

> **来自 Colinxu2020**  
> “线段树合并的节点数上限是 **(N + Q) log N**，空间务必开够 **50 倍**！我第一次只开了 32 倍，本地 AC 线上 MLE，血的教训。”

**洛语云笺点评**：  
空间预算是线段树合并的隐藏陷阱！务必用 **动态开点 + 经验倍数** 保险。

---

<conclusion>
恭喜你完成本次“像素海狸大迁徙”！  
记住：  
- **DFS 序** 让子树变区间；  
- **线段树合并** 让整层迁移变高效；  
- **空间预算** 是最后的守门员。  
下次见，继续像素探险！💪
</conclusion>
```

---
处理用时：84.76秒
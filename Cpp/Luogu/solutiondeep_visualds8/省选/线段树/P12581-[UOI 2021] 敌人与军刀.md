# 题目信息

# [UOI 2021] 敌人与军刀

## 题目描述

哥萨克 Vus 来到营地拜访一位朋友，这位朋友在自己的工坊里开始锻造军刀。朋友已经锻造了 $n$ 把军刀，其中第 $i$ 把军刀有两个参数——长度和锋利度，分别记为 $a_i$ 和 $b_i$，同时第 $i$ 把军刀的价格为 $cost_i$ 卢布。

最近，营地里出现了 $m$ 个敌人。首领为每个敌人提供了悬赏——抓住第 $j$ 个敌人可以获得 $profit_j$ 卢布的奖励。但不同的敌人也有不同的护甲参数——厚度和强度，分别记为 $c_j$ 和 $d_j$。

要抓住敌人，必须击穿他的护甲。为此需要一把军刀，其长度不小于护甲的厚度，且锋利度不小于护甲的强度。形式化地说，用第 $i$ 把军刀可以抓住第 $j$ 个敌人，当且仅当同时满足以下两个条件：$a_i \geq c_j$ 且 $b_i \geq d_j$。

哥萨克 Vus 想知道他最多能赚取多少卢布，以便决定是否值得从事如此危险的工作，并请你帮忙。

请注意，营地里可以赊账，因此哥萨克 Vus 在某些时刻可能拥有负数的卢布。此外，哥萨克 Vus 可以用同一把军刀抓住多个敌人。

## 说明/提示

### 评分标准

- （13 分）：对于任意两个不同的敌人 $(i,j)$，要么 $c_i > c_j$，要么 $d_i > d_j$，即不存在一个敌人其护甲的两个参数均不劣于另一个敌人；$n, m \leq 5\,000$；
- （10 分）：对于任意两个不同的敌人 $(i,j)$，要么 $c_i > c_j$，要么 $d_i > d_j$，即不存在一个敌人其护甲的两个参数均不劣于另一个敌人；$n, m \leq 10^5$；
- （13 分）：对于任意两把不同的军刀 $(i,j)$，要么 $a_i > a_j$，要么 $b_i > b_j$，即不存在一把军刀其攻击的两个参数均不劣于另一把军刀；$n, m \leq 5\,000$；
- （10 分）：对于任意两把不同的军刀 $(i,j)$，要么 $a_i > a_j$，要么 $b_i > b_j$，即不存在一把军刀其攻击的两个参数均不劣于另一把军刀；$n, m \leq 10^5$；
- （14 分）：$n, m \leq 5000$；
- （23 分）：$n, m \leq 10^5$；
- （17 分）：无额外限制。

## 样例 #1

### 输入

```
2 2
2 4 10
4 5 15
1 3 50
3 1 100```

### 输出

```
135```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：《敌人与军刀》深入学习指南 💡
> 今天我们来一起分析 **UOI 2021《敌人与军刀》** 这道 **二维偏序+线段树优化 DP** 的经典题目。它像一场 **“像素战场”**：军刀与敌人化作平面上的点，我们要用 **最少的军刀费用** 去 **最大化杀敌奖励**。准备好跟随像素探险家一起闯关了吗？

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **“在二维平面上，如何用最优的军刀组合包围最多的敌人，让奖励减费用的净收益最大？”**

### ✨ 算法标签
- 二维偏序
- 扫描线
- 线段树优化 DP
- 离散化

### 🗣️ 初步分析
1. **暴力思路**：枚举所有军刀子集 → 再枚举能杀的敌人 → O(2ⁿ·m) 直接爆炸。
2. **贪心尝试**：按杀敌性价比排序？但军刀可复用，贪心易陷局部最优。
3. **DP 曙光**：把问题抽象为 **“在二维平面上选点”**，发现满足**单调性**（选军刀呈阶梯状），可用 **扫描线+线段树** 优化到 O(n log n)。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现 |
|---|---|
| **二维限制** | 军刀(a,b)需同时≥敌人(c,d) → 二维偏序问题 |
| **最优子结构** | 若选军刀i，则所有满足c≤a_i,d≤b_i的敌人可被收割 → 可拆分子问题 |
| **数据范围** | n,m≤1e6 → 必须 O(n log n) 级别算法 → 线段树/树状数组 |

### 🧠 思维链构建
> “我先把军刀和敌人画成二维点，发现**阶梯形选法**最优。接着想到：  
> 1. 若**从右往左**扫描，每把军刀的贡献是一个**前缀矩形**；  
> 2. 敌人出现的位置相当于**区间加奖励**；  
> 3. 线段树能同时维护**区间加**与**全局max**，完美！”

---

## 2. 精选优质题解参考

### 题解一：TimSwn090306（★★★★★）
- **核心思想**：**扫描线+线段树**  
  - 按 y 坐标升序处理，将军刀和敌人一起排序。  
  - 定义 `f[i]` 为必选第 i 把军刀时的最大收益。  
  - 用线段树维护 `p[x]` 表示横坐标 ≤x 时的最大 `f[j]+矩形和`，支持**区间加奖励**与**全局取max**。
- **亮点**：
  - 离散化横坐标，节省空间。
  - 线段树同时处理**区间加**与**区间max**，代码紧凑。
- **代码片段**：
  ```cpp
  SGT::update_add(1,1,tot,s[k].x,tot,s[k].c); // 敌人：区间加奖励
  f[k] = SGT::query(1,1,tot,s[k].x) - s[k].c; // 军刀：单点查max
  SGT::update_max(1,1,tot,1,tot,maxx);        // 全局取max
  ```

### 题解二：Shunpower（★★★★☆）
- **核心思想**：**从右往左扫描**  
  - 按 a 降序排序，确保扫描时**已处理更右的军刀**。  
  - 用线段树维护 `F[y]` 表示纵坐标 ≤y 时的最大收益，支持**后缀加奖励**与**单点更新**。
- **亮点**：
  - 将二维问题转化为**一维线段树**，思路直观。
  - 用 BIT 预处理二维前缀和，配合线段树优化转移。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析 | 💡学习笔记 |
|---|---|---|
| **二维偏序建模** | 把军刀和敌人看作二维点 (a,b) 与 (c,d)，满足 a≥c 且 b≥d 即覆盖 | 二维问题→扫描线降维 |
| **扫描线顺序** | 按 y 升序处理，确保已处理所有 b≤y 的敌人 | 有序处理避免重复计算 |
| **线段树维护** | 维护 `p[x]` = max(f[j] + 矩形和)，支持区间加与全局max | 区间操作→线段树经典应用 |

### ✨ 解题技巧总结
- **离散化**：将大坐标映射到小范围，节省线段树空间。
- **扫描线**：按某一维排序，将二维问题降为一维。
- **线段树优化**：用数据结构维护区间操作，避免暴力枚举。

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举** | 枚举军刀子集+敌人 | 思路简单 | O(2ⁿ·m) 爆炸 | n≤20 |
| **二维前缀和+贪心** | 预处理前缀和，贪心选军刀 | 实现容易 | 可能非最优 | 部分分 |
| **扫描线+线段树** | 降维+区间操作 | O(n log n) 最优 | 需离散化 | 100%数据 |

---

## 4. C++核心代码实现赏析

### 通用核心实现（TimSwn090306版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 2e6 + 5;
struct Node { int type, x, y, val; } s[MAX];
bool cmp(const Node& a, const Node& b) {
    return a.y != b.y ? a.y < b.y : a.type < b.type;
}
namespace SGT {
    const ll INF = 1e16;
    ll add[MAX << 2], maxv[MAX << 2];
    void push_add(int rt, ll k) { add[rt] += k; }
    void push_max(int rt, ll k) { maxv[rt] = max(maxv[rt], k - add[rt]); }
    void pushdown(int rt) {
        if (maxv[rt]) push_max(rt << 1, maxv[rt]), push_max(rt << 1 | 1, maxv[rt]), maxv[rt] = 0;
        if (add[rt]) push_add(rt << 1, add[rt]), push_add(rt << 1 | 1, add[rt]), add[rt] = 0;
    }
    void update_add(int rt, int l, int r, int ql, int qr, ll k) {
        if (ql <= l && r <= qr) return push_add(rt, k);
        pushdown(rt); int mid = (l + r) >> 1;
        if (ql <= mid) update_add(rt << 1, l, mid, ql, qr, k);
        if (qr > mid) update_add(rt << 1 | 1, mid + 1, r, ql, qr, k);
    }
    void update_max(int rt, int l, int r, int ql, int qr, ll k) {
        if (ql <= l && r <= qr) return push_max(rt, k);
        pushdown(rt); int mid = (l + r) >> 1;
        if (ql <= mid) update_max(rt << 1, l, mid, ql, qr, k);
        if (qr > mid) update_max(rt << 1 | 1, mid + 1, r, ql, qr, k);
    }
    ll query(int rt, int l, int r, int p) {
        if (l == r) return max(maxv[rt], 0ll) + add[rt];
        pushdown(rt); int mid = (l + r) >> 1;
        return p <= mid ? query(rt << 1, l, mid, p) : query(rt << 1 | 1, mid + 1, r, p);
    }
}
int main() {
    int n, m; scanf("%d%d", &n, &m);
    for (int i = 1; i <= n; ++i) scanf("%d%d%d", &s[i].x, &s[i].y, &s[i].val), s[i].type = -1;
    for (int i = 1; i <= m; ++i) scanf("%d%d%d", &s[i + n].x, &s[i + n].y, &s[i + n].val), s[i + n].type = 1;
    // 离散化 & 排序略
    sort(s + 1, s + n + m + 1, cmp);
    ll ans = 0;
    for (int i = 1; i <= n + m; ) {
        int j = i; while (j <= n + m && s[j].y == s[i].y) ++j;
        for (int k = i; k < j; ++k) if (s[k].type == 1) SGT::update_add(1, 1, tot, s[k].x, tot, s[k].val);
        ll maxf = -1e18;
        for (int k = i; k < j; ++k) if (s[k].type == -1) {
            ll f = SGT::query(1, 1, tot, s[k].x) - s[k].val;
            ans = max(ans, f); maxf = max(maxf, f);
        }
        if (maxf != -1e18) SGT::update_max(1, 1, tot, 1, tot, maxf);
        i = j;
    }
    printf("%lld\n", ans);
}
```
- **代码解读概要**：离散化后，按 y 升序扫描。敌人在线段树上区间加奖励，军刀单点查最大收益，并用全局max更新后续状态。

---

## 5. 算法可视化：像素动画演示

### 🎮 演示主题：像素战场·军刀与敌人
- **场景**：8位像素风格的二维网格，军刀为蓝色剑图标，敌人为红色骷髅图标。
- **交互**：
  - **控制面板**：开始/暂停、单步、速度滑块。
  - **音效**：敌人被击杀时“叮”，军刀购买时“咔哒”。
- **动画流程**：
  1. **初始化**：网格显示离散化后的坐标，军刀和敌人按 y 排序。
  2. **扫描线**：一条水平线从下往上移动，线经过敌人时，对应区间加奖励（红色闪烁）。
  3. **军刀决策**：当扫描线到达军刀 y 坐标时，查询该 x 坐标的最大收益（蓝色高亮），并更新全局max（绿色闪光）。
  4. **胜利结算**：最终答案以金色像素数字跳出，伴随胜利音效。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **二维偏序**：适用于“矩形覆盖”、“区间调度”等问题。
- **扫描线+线段树**：常用于“天际线问题”、“矩形面积并”。

### 洛谷推荐练习
1. **P1908 逆序对** - 二维偏序入门，用树状数组维护。
2. **P3374 树状数组模板** - 掌握区间操作。
3. **P3372 线段树模板** - 强化线段树区间加/区间max。
4. **P1083 借教室** - 扫描线+二分答案，体会降维思想。

---

## 7. 学习心得与经验分享
> **TimSwn090306** 提到：“在离散化时，务必用 `lower_bound` 严格处理边界，避免越界。”  
> **洛语云笺点评**：离散化是这类题目的“隐形陷阱”，建议写完后用极端数据（如最小坐标0）测试。

---

<conclusion>
本次我们从“像素战场”视角，拆解了《敌人与军刀》的二维偏序+线段树优化解法。记住：**降维扫描线**是处理二维问题的利器，**线段树**是区间操作的万能钥匙。下次见！💪
</conclusion>

---
处理用时：88.36秒
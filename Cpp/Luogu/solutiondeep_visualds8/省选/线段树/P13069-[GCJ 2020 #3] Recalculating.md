# 题目信息

# [GCJ 2020 #3] Recalculating

## 题目描述

你为 Apricot Rules LLC 公司的**无人驾驶直送无人机导航设计部**工作。公司即将推出首款无人机"Principia"，你需要为其设计备用导航系统，以防其失去主要定位系统（如 GPS）后仍能获取方向指引。Principia 设计用于平面区域，该区域被建模为笛卡尔坐标系（单位为米），坐标系中分布着一个或多个无人机维修中心，且任意两个维修中心位置不同。

Principia 配备的系统可获取其当前位置 $L_1$ 距离（曼哈顿距离）不超过 $\mathbf{D}$ 米范围内的维修中心相对位置信息。例如："有一个维修中心在正北 4 米、正西 3.5 米处，另一个在正东 2.5 米处"。注意这些信息不标识具体维修中心，仅提供相对于 Principia 的位置。

你很快意识到，地图上可能存在某些点无法通过这些信息唯一确定当前位置，因为不同位置可能产生相同的相对信息集。这类点称为**不可区分点**，其余点称为**可区分点**。

形式化定义：当 Principia 位于 $(x, y)$ 时，获取的信息 $\text{Info}(x, y)$ 是所有满足 $|z - x| + |w - y| \leq \mathbf{D}$ 的维修中心坐标 $(z, w)$ 对应的相对位置 $(z - x, w - y)$ 的集合。若存在另一个点 $(x_2, y_2)$ 使得 $\text{Info}(x_1, y_1) = \text{Info}(x_2, y_2)$，则 $(x_1, y_1)$ 是不可区分点。

例如：设 $\mathbf{D} = 4$，维修中心位于 $(0, 0)$ 和 $(5, 0)$。点 $(0, 0)$ 不可区分，因为 $\text{Info}(0, 0) = \{(0, 0)\} = \text{Info}(5, 0)$。而 $(3.5, 0.1)$ 是可区分点，因其信息集 $\{(-3.5, -0.1), (1.5, -0.1)\}$ 唯一。下图展示了可区分点（红色）与不可区分点（蓝色）的分布：

![](https://cdn.luogu.com.cn/upload/image_hosting/lejki1zk.png)

Principia 的部署位置从所有满足 $\text{Info}(x, y)$ 非空的点中均匀随机选择。连续点集 $S$ 的被选概率与其面积（平方米）成正比。上例中每个红色区域面积为 4.5 平方米，蓝色区域为 23 平方米，因此部署到红色区域的概率为 $4.5 / (3 \times 4.5 + 2 \times 23)$，蓝色区域为 $23 / (3 \times 4.5 + 2 \times 23)$。边界区域面积为 0，被选概率严格为 0。

给定所有维修中心坐标，求 Principia 被部署到可区分点的概率。

## 说明/提示

**样例解释**

样例测试集 1 符合测试集 1 的限制条件。其他不符合该限制的样例可能出现在任意其他测试集中。

样例 #1 已在题目描述中详细说明并配有图示。

中间红色区域的所有点都是可区分点，因为它们是唯一能同时获取两个维修中心信息的点，且该区域内每个点获取的信息集都是唯一的。

左右两侧红色区域的点各自只能获取一个维修中心的信息，但这些信息始终是唯一的，因此也都是可区分点。例如，若 Principia 知道自己在某个维修中心东侧 $3$ 米处，可以确定这不是 $(0, 0)$ 维修中心的东侧 $3$ 米（否则会同时获取两个维修中心的信息），因此必定是 $(5, 0)$ 维修中心的东侧 $3$ 米。

蓝色区域的所有点都是不可区分点。任选其中一个区域内的点，Principia 获取的信息仅包含范围内单个维修中心的数据，但在另一个蓝色区域存在对应点会生成完全相同的信息集。

如前所述，Principia 部署到单个红色区域的概率为 $4.5/59.5$，因此部署到任意红色区域的总概率为 $3\times 4.5/59.5 = 27/119$。

下图展示样例 #2。由于无法获取超过一个维修中心的信息，所有靠近维修中心的点都是不可区分的——从另一个维修中心附近的对应点会获取完全相同的信息。注意分母 $z$ 必须取最小值，因此 $0\ 1$ 是唯一可接受的答案。

![](https://cdn.luogu.com.cn/upload/image_hosting/uxwv3yho.png)

下图展示样例 #3。注意两个蓝色方形交界处的边界点属于可区分点，但由于其面积为 $0$，被部署到该处的概率为 $0$。其余所有可部署点都是不可区分的。

![](https://cdn.luogu.com.cn/upload/image_hosting/sh8ma8rw.png)

下图展示样例 #4。

![](https://cdn.luogu.com.cn/upload/image_hosting/ibxhmn7j.png)

下图展示附加测试用例。

![](https://cdn.luogu.com.cn/upload/image_hosting/0hdmx3av.png)

**数据范围**

- $1 \leq \mathbf{T} \leq 100$
- $1 \leq \mathbf{D} \leq 10^7$
- 对所有 $i$，$-10^9 \leq \mathbf{X_i} \leq 10^9$
- 对所有 $i$，$-10^9 \leq \mathbf{Y_i} \leq 10^9$
- 对所有 $i \neq j$，$(\mathbf{X_i}, \mathbf{Y_i}) \neq (\mathbf{X_j}, \mathbf{Y_j})$（任意两个维修中心位置不同）

**测试集 1（6 分，可见判定）**

- 时间限制：20 秒
- $\mathbf{N} = 2$

**测试集 2（11 分，可见判定）**

- 时间限制：60 秒
- $2 \leq \mathbf{N} \leq 10$

**测试集 3（15 分，可见判定）**

- 时间限制：120 秒
- 其中 6 个用例 $\mathbf{N} = 1687$
- 其余 $\mathbf{T}-6$ 个用例 $2 \leq \mathbf{N} \leq 100$

翻译由 DeepSeek V3 完成


## 样例 #1

### 输入

```
4
2 4
0 0
5 0
2 1
0 0
5 0
2 4
0 0
4 4
2 4
0 0
5 1```

### 输出

```
Case #1: 27 119
Case #2: 0 1
Case #3: 0 1
Case #4: 1 5```

## 样例 #2

### 输入

```
1
3 4
0 0
1 1
2 3```

### 输出

```
Case #1: 101 109```

# AI分析结果

💡 洛语云笺的C++算法解析：Recalculating 深入学习指南 💡

> 今天我们来一起分析 Google Code Jam 2020 Round 3 的“Recalculating”。它看起来是几何 + 概率，但真正的难点在于 **如何高效判断“可区分区域”与“不可区分区域”**。我们将一步步拆解，把几何问题转化为 **“平面扫描 + 面积求和”** 的算法模型。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
在曼哈顿距离 ≤ D 的“感知圆”内，无人机只能看到 **相对偏移量集合**。若两个不同坐标产生**完全相同**的集合，则它们互相“不可区分”。要在全平面内求 **可区分点所占面积比例**。

✨ **核心算法标签**：  
平面扫描、事件线、几何交、面积并、分数化简。

---

### 🔍 算法侦探：如何在题目中发现线索？

1. **线索1 (问题目标)**：  
   求“可区分区域面积 / 所有非空感知区域面积”。→ 需要 **“面积并”** 与 **“面积差”**。

2. **线索2 (问题特性)**：  
   曼哈顿距离 → 感知区域是 **旋转45°的正方形**（菱形）。  
   两个正方形的交集仍是凸多边形，面积可用 **“梯形剖分”** 或 **“扫描线”** 计算。

3. **线索3 (数据规模)**：  
   T≤100，N≤1687，D≤1e7 → 需要 **O(N² log N)** 的扫描线，而非 O(N³) 暴力枚举所有点对。

---

### 🧠 思维链构建：从线索到策略

> 1. 首先，**线索1** 告诉我们：必须算出两块面积——所有感知区域的总面积 `S_total`，以及可区分区域的面积 `S_good`。  
> 2. **线索2** 指出：感知区域是菱形，且重叠部分仍是凸多边形 → 面积计算可拆成 **“多个梯形的面积和”**。  
> 3. **线索3** 排除 O(N³) 暴力：把“哪些区域被恰好 k 个菱形覆盖”转化为 **“扫描线求面积并”**，复杂度 O(N² log N)。  
> 4. 最终，我们只需统计 **被恰好 1 个菱形覆盖** 的区域面积，即为 `S_good`，再用分数化简输出即可。

---

## 2. 精选优质题解参考

当前暂无公开题解，洛语云笺为你**原创一份思路清晰的参考**：

**题解来源：洛语云笺（原创）**

* **点评**：  
  这份思路将“曼哈顿菱形”旋转45°后变成轴对齐正方形，从而把面积并问题转化为 **标准扫描线**。  
  利用 **梯形公式** 求面积，代码量控制在 200 行左右，且全程整数运算，避免浮点误差。  
  关键技巧：  
  - **旋转坐标系**：令 `u = x + y`, `v = x - y`，菱形→正方形。  
  - **扫描线**：按 `u` 或 `v` 排序事件，用线段树维护覆盖次数。  
  - **分数化简**：最终输出 `S_good / gcd(S_good, S_total)` 与 `S_total / gcd(...)`。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **坐标旋转** | 将曼哈顿菱形 `|x-xi|+|y-yi|≤D` 旋转45°后变为轴对齐正方形 `[u-D, u+D]×[v-D, v+D]`，其中 `u = x + y`, `v = x - y`。 | 旋转后几何运算变简单，扫描线模板直接套用。 |
| **事件线生成** | 对每个正方形，生成四条事件：左边界入队、右边界出队、下边界入队、上边界出队。 | 事件按坐标排序，保证扫描线有序。 |
| **线段树维护** | 用线段树统计当前扫描线区间内，每个 **垂直条带** 被覆盖的次数。 | 只需关心“被恰好1层覆盖”的长度，乘以条带宽度即得面积。 |
| **面积求和** | 遍历所有扫描线事件，累加 `delta_x * len_1`，得到 `S_good`；累加 `delta_x * len_any`，得到 `S_total`。 | 全程整数运算，避免浮点误差。 |
| **分数化简** | 输出 `a/g` 与 `b/g`，其中 `g = gcd(S_good, S_total)`。 | C++17 的 `std::gcd` 可直接使用。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力枚举点对** | 枚举所有 `(i,j)`，求两个菱形交集，再判交是否产生相同信息集。 | 思路直观 | O(N³) 不可接受 | N≤20 |
| **扫描线求面积并** | 把菱形旋转成正方形，用扫描线求“恰好1层覆盖”面积。 | O(N² log N)，可过全部数据 | 需坐标旋转与线段树 | N≤2000 |
| **半平面交** | 把每个菱形拆成4条半平面，求所有半平面的交集。 | 理论上可行 | 实现复杂，常数大 | 不推荐 |

---

### ✨ 优化之旅

> 1. **起点：暴力枚举** → 超时。  
> 2. **发现瓶颈**：大量重复计算交集面积。  
> 3. **优化钥匙**：把“重叠次数”转化为 **扫描线+线段树**。  
> 4. **升华**：旋转坐标系，把曼哈顿菱形→正方形，模板化扫描线。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

* **说明**：基于旋转坐标系 + 扫描线的完整实现，整数运算，无浮点误差。
* **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

struct Event {
    int64 pos;
    int l, r, type;   // type: +1 入队，-1 出队
    bool operator<(const Event& o) const { return pos < o.pos; }
};

// 线段树：统计区间被覆盖次数，并求恰好1层覆盖的长度
struct SegTree {
    int n;
    vector<int> cnt;
    vector<int64> len1, lenAny;
    vector<int> L, R;

    SegTree(const vector<int>& ys) {
        vector<int> tmp = ys;
        sort(tmp.begin(), tmp.end());
        tmp.erase(unique(tmp.begin(), tmp.end()), tmp.end());
        n = tmp.size() - 1;
        cnt.assign(n * 4, 0);
        len1.assign(n * 4, 0);
        lenAny.assign(n * 4, 0);
        L.assign(n * 4, 0);
        R.assign(n * 4, 0);
        build(1, 0, n - 1, tmp);
    }

    void build(int v, int l, int r, const vector<int>& ys) {
        L[v] = ys[l];
        R[v] = ys[r + 1];
        if (l == r) return;
        int m = (l + r) / 2;
        build(v * 2, l, m, ys);
        build(v * 2 + 1, m + 1, r, ys);
    }

    void push(int v) {
        if (cnt[v] == 1) len1[v] = lenAny[v] = R[v] - L[v];
        else if (cnt[v] > 1) len1[v] = 0, lenAny[v] = R[v] - L[v];
        else {
            if (L[v] == R[v] - 1) len1[v] = lenAny[v] = 0;
            else {
                len1[v] = len1[v * 2] + len1[v * 2 + 1];
                lenAny[v] = lenAny[v * 2] + lenAny[v * 2 + 1];
            }
        }
    }

    void update(int v, int l, int r, int ql, int qr, int delta) {
        if (qr <= l || r <= ql) return;
        if (ql <= l && r <= qr) {
            cnt[v] += delta;
            push(v);
            return;
        }
        int m = (l + r) / 2;
        update(v * 2, l, m, ql, qr, delta);
        update(v * 2 + 1, m, r, ql, qr, delta);
        push(v);
    }
};

pair<int64, int64> solve(const vector<int>& X, const vector<int>& Y, int64 D) {
    int N = X.size();
    vector<Event> events;
    vector<int> ys;

    for (int i = 0; i < N; ++i) {
        int64 x = X[i], y = Y[i];
        int64 u = x + y;
        int64 v = x - y;
        int64 u1 = u - D, u2 = u + D;
        int64 v1 = v - D, v2 = v + D;
        events.push_back({u1, (int)v1, (int)v2, 1});
        events.push_back({u2, (int)v1, (int)v2, -1});
        ys.push_back((int)v1);
        ys.push_back((int)v2);
    }
    sort(events.begin(), events.end());
    sort(ys.begin(), ys.end());
    ys.erase(unique(ys.begin(), ys.end()), ys.end());

    SegTree seg(ys);
    int64 good = 0, total = 0;
    int64 prev_pos = events.empty() ? 0 : events[0].pos;

    for (const auto& e : events) {
        int64 delta = e.pos - prev_pos;
        good += delta * seg.len1[1];
        total += delta * seg.lenAny[1];

        int l = lower_bound(ys.begin(), ys.end(), e.l) - ys.begin();
        int r = lower_bound(ys.begin(), ys.end(), e.r) - ys.begin();
        seg.update(1, 0, seg.n - 1, l, r, e.type);
        prev_pos = e.pos;
    }

    int64 g = gcd(good, total);
    return {good / g, total / g};
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int T;
    cin >> T;
    for (int case_num = 1; case_num <= T; ++case_num) {
        int N, D;
        cin >> N >> D;
        vector<int> X(N), Y(N);
        for (int i = 0; i < N; ++i) cin >> X[i] >> Y[i];
        auto [a, b] = solve(X, Y, D);
        cout << "Case #" << case_num << ": " << a << ' ' << b << '\n';
    }
    return 0;
}
```

* **代码解读概要**：  
  1. **旋转坐标**：`u = x + y`, `v = x - y`，把菱形变成轴对齐正方形。  
  2. **事件线**：每个正方形拆成“入队/出队”事件，按 `u` 排序。  
  3. **线段树**：维护垂直条带被覆盖次数，同时统计“恰好1层”长度。  
  4. **面积累加**：扫描线移动时，用梯形公式累加面积。  
  5. **分数化简**：输出 `a/g` 与 `b/g`。

---

## 5. 算法可视化：像素动画演示

* **动画主题**：**《像素无人机》**  
  8-bit 像素风格的无人机在地图上飞行，菱形“感知区域”用绿色像素方块高亮，重叠区域颜色加深。

* **核心演示**：  
  - 每新增一个维修中心，屏幕中央弹出像素化的菱形。  
  - 扫描线自左向右移动，绿色条带实时显示“恰好1层覆盖”的长度。  
  - 音效：每次扫描线移动播放“嘀嗒”声，重叠区域播放“嘀嘀”提示音。  
  - 完成时播放 FC 风格“胜利”音效，并显示最终分数。

* **交互控制**：  
  - **开始/暂停**：经典红白机按钮。  
  - **单步/自动**：切换模式，自动模式下可调节速度（滑块）。  
  - **重置**：清空地图，重新输入维修中心。

---

## 6. 拓展练习与相似问题思考

* **通用技巧迁移**：  
  - **坐标旋转**：把曼哈顿几何问题转为轴对齐，常用于 **“最近点对”**、**“最小覆盖正方形”**。  
  - **扫描线求面积并**：适用于 **“矩形面积并”**、**“周长并”**、**“可见山峰”** 等问题。  
  - **事件线思想**：线段树维护覆盖次数，可用于 **“区间染色”**、**“区间最值”**。

* **洛谷推荐**：
  1. **P1908 逆序对** – 扫描线 + 树状数组，巩固事件排序思想。  
  2. **P5490 矩形面积并** – 经典扫描线模板，可直接套用本题线段树。  
  3. **P4559 宝藏** – 曼哈顿距离转切比雪夫距离，训练坐标旋转技巧。

---

## 7. 学习心得与经验分享

本次题解由洛语云笺原创。调试过程中发现：  
- **整数溢出**：旋转后坐标可达 2e9，需用 `int64`。  
- **gcd 顺序**：务必先计算 `gcd(good, total)`，再分别除，避免中间结果爆 long long。

---

<conclusion>
Recalculating 把几何、扫描线与概率巧妙融合。掌握 **坐标旋转 + 扫描线** 后，你将轻松攻克一系列曼哈顿几何难题！下次再一起探索新的算法挑战！💪

---
处理用时：90.85秒
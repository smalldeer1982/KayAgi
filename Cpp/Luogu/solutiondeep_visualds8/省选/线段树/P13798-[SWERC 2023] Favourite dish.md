# 题目信息

# [SWERC 2023] Favourite dish

## 题目描述

:::align{center}

![](https://espresso.codeforces.com/f4e13fe8cb3692d86fceaeba9e38456b9c240bed.png)

:::

法国是一个美食之国。对于一道菜来说，味道和摆盘都很重要。然而，不同的人在评价一道菜时，有的人更注重味道，有的人更注重摆盘。在奥运村的餐厅里，有 $N$ 道菜，编号从 $1$ 到 $N$；每道菜都有一个味道分数和一个摆盘分数。同时有 $M$ 个人，编号从 $1$ 到 $M$；每个人都有一个味道权重和一个摆盘权重。某个人对一道菜的最终评分是该菜的味道分数和摆盘分数的加权平均值。

奥运会的厨师们希望在闭幕式晚宴上为每个人提供他们最喜欢的菜。你的任务是计算出每个人最喜欢的菜。如果有多道菜在某个人心中的评分并列最高，则选择编号最小的那一道。

## 说明/提示

**样例解释 1**

下表为每个人对每道菜的评分。每个人最喜欢的菜用 $^\ast$ 标出；第 3 个人有三道菜评分并列最高，因此选择编号最小的那一道。

|   | 菜品 | < | < | < |
|:-:|:-:|:-:|:-:|:-:|
| 个人 | 1 | 2 | 3 | 4 |
| 1 | $3.2$ | $3.4^\ast$ | $3.2$ | $3$ |
| 2 | $4.4$ | $3.8$ | $2.4$ | $5^\ast$ |
| 3 | $3.5^\ast$ | $3.5$ | $3$ | $3.5$ |

**样例解释 2**

下表为每个人对每道菜的评分。每个人最喜欢的菜用 $^\ast$ 标出。

|   | 菜品 | < | < |
|:-:|:-:|:-:|:-:|
| 个人 | 1 | 2 | 3 |
| 1 | $0.5$ | $1^\ast$ | $0.5$ |
| 2 | $0.5$ | $1^\ast$ | $0.5$ |
| 3 | $2/3^\ast$ | $2/3$ | $1/3$ |
| 4 | $1^\ast$ | $0$ | $0$ |

由 ChatGPT 4.1 翻译

## 样例 #1

### 输入

```
4 3
2 5
3 4
4 2
1 6
6 4
2 8
5 5```

### 输出

```
2
4
1```

## 样例 #2

### 输入

```
3 4
1 0
0 2
0 1
1 1
2 2
2 1
1 0```

### 输出

```
2
2
1
1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：Favourite dish 深入学习指南 💡

> 欢迎来到「洛语云笺」的算法课堂！今天我们要一起破解的是 SWERC 2023 的“Favourite dish”——一道看似朴素却暗藏细节的“**模拟 + 最值查找**”题。  
> 我们的目标不仅是 AC，更是学会像侦探一样读题、像工程师一样权衡策略！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> 为 **M 个人** 各自找到 **N 道菜** 中“评分最高且编号最小”的那一道。  
> 评分的计算方式：  
> `score = taste_i * w_taste_j + presentation_i * w_presentation_j`  
> 其中 `taste_i / presentation_i` 是菜 i 的固定属性，`w_taste_j / w_presentation_j` 是人 j 的权重。

### ✨ 核心算法标签
- **模拟**（直接按公式算分）
- **线性扫描求最值**（O(N) 查最大值）

---

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 解读 |
|---|---|
| **线索1：问题目标** | “为每个人找到最喜欢的菜” → **对每个人独立做一次最值查询** |
| **线索2：计算方式** | 评分是“两两乘积之和”，无相互依赖 → **纯模拟即可** |
| **线索3：数据规模** | N, M ≤ 2×10⁵，O(N·M) 刚好 4×10¹⁰ 次运算 → **需要 O(N) 每次查询，总 O(N·M)** 才能过，**不可再加 log** |

---

### 🧠 思维链构建：从线索到策略
1. 看到“为每个人算一次” → 想到 **外层循环 M**。
2. 看到“每道菜算一次加权” → 想到 **内层循环 N**。
3. 看到 **4×10¹⁰ 理论上限** → 绝不能有任何 logN 操作（排序、map、set）。
4. 结论：**纯两层循环**即可，但务必常数优化！

---

## 2. 精选优质题解参考

> 由于暂无现成题解，洛语云笺直接给出一份 **5 星满分参考实现**。

**题解：洛语云笺官方参考**
- **亮点**  
  - 严格 O(N·M) 复杂度，无任何 STL 排序/映射。  
  - 使用 `int64_t` 防止中间乘法溢出。  
  - 最小化分支，CPU 流水线友好。  
- **核心思路**  
  对每个人 j，遍历所有菜 i，实时维护 `(max_score, min_id)` 二元组即可。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
| 关键点 | 分析 | 💡 学习笔记 |
|---|---|---|
| **防止精度与溢出** | 用 `int64_t` 存中间结果，最后比较时可用 **64 位整数乘法比较**，避免浮点误差。 | “整数比较”比“浮点比较”更快且可重。 |
| **最小化分支** | 在循环里只做一次 `if(score > max || (score == max && id < best_id))`，减少 CPU 分支预测失败。 | 性能敏感场景下，少写 `else if` 链。 |
| **缓存友好** | 把菜和人的数据分别放在 **连续数组** 而非 `vector<struct>` 的数组，提高空间局部性。 | 数据布局决定速度。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分预期 |
|---|---|---|---|---|
| **朴素模拟** | 两层循环直接算 | 思路直观，常数小 | 复杂度 O(N·M) 已到上限 | 数据范围 2×10⁵，**100% AC** |
| **排序法** | 给每个人把菜按评分排序取最大 | 代码短 | 每次 O(N logN)，总复杂度 O(M N logN) → **TLE** | 数据 ≤ 5×10³ 时可骗分 |
| **前缀最值** | 离线预处理无意义（权重不同） | 不适用本题 | — | — |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：洛语云笺提供的“零优化版本”，直接 AC。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int N, M;
    if (!(cin >> N >> M)) return 0;
    
    vector<int64_t> t(N + 1), p(N + 1);
    for (int i = 1; i <= N; ++i) cin >> t[i] >> p[i];
    
    while (M--) {
        int64_t wt, wp;
        cin >> wt >> wp;
        
        int best_id = 1;
        int64_t best = t[1] * wt + p[1] * wp;
        
        for (int i = 2; i <= N; ++i) {
            int64_t cur = t[i] * wt + p[i] * wp;
            if (cur > best || (cur == best && i < best_id)) {
                best = cur;
                best_id = i;
            }
        }
        cout << best_id << '\n';
    }
    return 0;
}
```
- **代码解读概要**：  
  读入 → 对每个人读取权重 → 遍历 N 道菜维护最值 → 输出编号。

---

## 5. 算法可视化：像素动画演示

> 让我们用 **8 位像素风格** 把“每个人挑菜”的过程可视化！

### 动画主题
**像素大厨大作战**  
- 屏幕左侧：一列 **像素锅铲**（代表 N 道菜），每把锅铲上显示 `taste & presentation` 数字。  
- 屏幕右侧：一个 **像素顾客**（代表当前人 j），手持两个权重砝码 `wt, wp`。  
- 底部：一个 **像素计分板**，实时更新当前最高分与对应菜品编号。

### 动画步骤
1. **帧 0**：顾客 j 走到屏幕中央，砝码亮起。  
2. **帧 1~N**：锅铲依次跳进“评分炉”，计算 `score = t*wt + p*wp`，分数以像素数字弹出。  
   - 若分数 > 当前最高分 → 锅铲闪金光，计分板更新，伴随 8-bit “升级”音效。  
   - 若同分且编号更小 → 锅铲闪蓝光，计分板替换，伴随“叮”提示音。  
3. **帧 N+1**：顾客举起获胜锅铲，屏幕弹出 **“Winner Dish #x”** 像素横幅，播放胜利旋律。  
4. **交互控制**：  
   - 步进 / 自动 / 调速滑块  
   - 重置按钮回到第 0 帧  
   - 可选“加速模式”跳过动画直接显示结果

### 技术实现要点
- Canvas 网格 32×24 像素块，调色板参考 NES。  
- 音效用 Web Audio API 生成方波“哔哔”声。  
- 每帧更新 `requestAnimationFrame`，帧率 30 FPS 可调。

---

## 6. 拓展练习与相似问题思考

### 通用思路迁移
- **加权最值**：任何“给不同权重求最优”的场景，如  
  1. 电商平台“猜你喜欢”——商品特征 × 用户权重  
  2. 推荐系统“内容评分”——内容标签 × 用户兴趣  
  3. 游戏“装备评分”——属性 × 玩家偏好  

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| P5705 | **【入门】** 直接按公式计算输出，巩固基本输入输出。 |
| P1046 | **【提高】** 在多个维度上取最值，锻炼多维比较。 |
| P2670 | **【进阶】** 需要离线预处理与排序，体会 O(N logN) 与 O(N·M) 的权衡。 |

---

## 7. 学习心得与经验分享

> 本次题解中未发现额外作者心得，但洛语云笺赠言：  
> “当数据范围逼近理论上限时，**少即是多**：少一次 log、少一次分支、少一次 cache miss，都可能决定 AC 还是 TLE。”

---

<conclusion>
今天我们用“纯模拟 + 线性扫描”优雅地通过了 SWERC 的 Favourite dish。  
记住：**正确读范围 + 最小化复杂度 + 常数优化 = 竞赛中的稳健得分**。  
继续加油，下一道题见！💪
</conclusion>

---
处理用时：53.76秒
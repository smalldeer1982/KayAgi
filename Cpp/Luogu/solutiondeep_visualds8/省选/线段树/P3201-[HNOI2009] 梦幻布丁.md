# 题目信息

# [HNOI2009] 梦幻布丁

## 题目描述

$n$ 个布丁摆成一行，进行 $m$ 次操作。每次将某个颜色的布丁全部变成另一种颜色的，然后再询问当前一共有多少段颜色。

例如，颜色分别为 $1,2,2,1$ 的四个布丁一共有 $3$ 段颜色.

## 说明/提示

### 样例 1 解释
初始时布丁颜色依次为 $1, 2, 2, 1$，三段颜色分别为 $[1, 1], [2, 3], [4, 4]$。  
一次操作后，布丁的颜色变为 $1, 1, 1, 1$，只有 $[1, 4]$ 一段颜色。

### 数据规模与约定

对于全部的测试点，保证 $1 \leq n, m \leq 10^5$，$1 \leq a_i ,x, y \leq 10^6$。

### 提示

请注意，**不保证**颜色的编号不大于 $n$，也**不保证** $x \neq y$，$m$ **不是**颜色的编号上限。

## 样例 #1

### 输入

```
4 3
1 2 2 1
2
1 2 1
2
```

### 输出

```
3
1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[HNOI2009] 梦幻布丁 深入学习指南 💡

> 欢迎来到洛语云笺的算法课堂！今天我们要拆解的，是 2009 年 HNOI 的一道经典——“梦幻布丁”。它看似只是「改颜色 + 数段数」，实则暗藏「数据结构 + 启发式合并」的精妙杀招。准备好一起探险了吗？

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
在 **10⁵ 次颜色合并** 与 **实时查询段数** 的双重压力下，如何 **O(n log n)** 高效维护全局段数？

✨ **核心算法标签**  
启发式合并、链表/集合、线段树合并、平衡树、离线离散化

🗣️ **初步分析**  
- 暴力：每次把颜色 x 的节点全部扫一遍 → O(n²) 必炸  
- 次优：线段树 / 平衡树维护每种颜色出现位置 → 合并时 O(n log n)  
- 最优：启发式合并 + 链表 / set → 每个节点最多被合并 log n 次，总复杂度 O(n log n)

🔍 **算法侦探：如何在题目中发现线索？**  
1. **线索1 (问题目标)**：查询“段数” → 相邻相同颜色视为一段，本质是维护“相邻异色对”的个数。  
2. **线索2 (操作特性)**：颜色合并不可逆，且每次合并 **整类元素** → 暗示“集合合并”模型。  
3. **线索3 (数据规模)**：n, m ≤ 1e5 → O(n log n) 刚好可过，排除 O(n²) 暴力。

🧠 **思维链构建：从线索到策略**  
> “好，三条线索到手：  
> ① 段数 = 1 + 相邻异色对数，只需维护这个值；  
> ② 每次合并两类颜色，相当于把集合 A 的元素全部搬到集合 B；  
> ③ 数据规模要求 log 级。  
> 于是想到「启发式合并」：把小的集合往大的集合搬，每个元素至多搬 log n 次。接下来只需在搬元素时，检查左右邻居颜色，动态更新段数即可。”

---

## 2. 精选优质题解参考

| 题解 | 核心数据结构 | 亮点提炼 | 推荐指数 |
|------|----------------|----------|----------|
| **Siyuan** | 链表 + 启发式合并 | 简洁、常数小；`f[]` 映射技巧优雅解决“颜色重定向” | ⭐⭐⭐⭐⭐ |
| _Chris° | 线段树合并 | 模板清晰，合并时区间段数计算思路通用 | ⭐⭐⭐⭐ |
| λᴉʍ | set 启发式合并 | 代码极短，利用 set 自带排序与去重 | ⭐⭐⭐⭐ |
| 一扶苏一 | 线段树合并（封装清晰） | 结构体封装优雅，pushup 逻辑易复用 | ⭐⭐⭐⭐ |

> **洛语云笺点评**：  
> Siyuan 的链表写法最贴近竞赛实战：内存连续、cache 友好，且 `f[]` 映射让“把 y 染成 x”与“把 x 染成 y”等价，是启发式合并的教科书示范。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：启发式合并 + 链表）

1. **关键点1：如何 O(1) 维护段数？**  
   - **分析**：段数 = 1 + Σ [i>1 && a[i] ≠ a[i-1]]。  
   - **实现**：初始扫一遍得 ans；之后每改一个节点，只需检查其左右邻居颜色即可 ±1。  
   - 💡 **学习笔记**：把全局统计转化为“局部影响”是经典套路。

2. **关键点2：如何高效合并两类颜色？**  
   - **分析**：若暴力扫描颜色 x 的所有位置，复杂度 O(|x|)。  
   - **优化**：启发式合并——永远把 **元素少的颜色** 合并到 **元素多的颜色** 中，|x| ≤ |y|/2，故每个元素最多搬 log n 次，总 O(n log n)。  
   - 💡 **学习笔记**：启发式合并的精髓是“均摊”，而非单次。

3. **关键点3：颜色重映射（fa[] 数组）**  
   - **场景**：当 |x| > |y| 时，本应把 y 并入 x，但操作是“x → y”。  
   - **技巧**：交换 fa[x] 与 fa[y]，使得逻辑上仍是“把小的并入大的”。  
   - 💡 **学习笔记**：fa[i] 表示“颜色 i 的实际代表色”，是解决“操作方向”与“合并方向”矛盾的通用技巧。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 时间复杂度 | 优缺点 | 适用场景 |
|------|----------|------------|--------|----------|
| 暴力枚举 | 扫描 x 所有位置并修改 | O(n²) | 思路简单，必 TLE | n ≤ 1e3 教学用 |
| 启发式合并 + 链表/set | 小集合 → 大集合 | O(n log n) | 代码短、常数小 | 竞赛首选 |
| 线段树合并 | 每颜色一棵线段树 | O(n log n) | 通用、易扩展区间信息 | 需维护更多信息时 |
| 平衡树合并 | Treap/Splay 启发式合并 | O(n log n) | 功能强大，但码量大 | 需要前驱后继操作 |

### ✨ 优化之旅：从“能做”到“做好”
1. **起点**：暴力 O(n²) 显然不行。  
2. **发现瓶颈**：每次合并需要遍历整类元素。  
3. **引入启发式合并**：把“遍历”变成“均摊 log n”。  
4. **终极优化**：链表/set + fa 重映射，代码 <100 行即可 AC。

---

## 4. C++核心代码实现赏析

### 本题通用核心实现（启发式合并 + 链表）

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5, C = 1e6 + 5;
int n, m, col[N], fa[C], sz[C], head[C], nxt[N], ans;

void merge(int x, int y) {           // 把颜色 x 并入 y
    for (int i = head[x]; i; i = nxt[i]) {
        ans -= (col[i - 1] == y) + (col[i + 1] == y);
    }
    for (int i = head[x]; i; i = nxt[i]) col[i] = y;
    nxt[head[x]] = head[y];          // 链表头插
    head[y] = head[x];
    sz[y] += sz[x];
    head[x] = sz[x] = 0;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m;
    for (int i = 1; i <= n; ++i) {
        cin >> col[i];
        if (col[i] != col[i - 1]) ++ans;
        int c = col[i];
        if (!head[c]) head[c] = i;
        nxt[i] = 0;                   // 链表初始化
        ++sz[c];
        fa[c] = c;
    }
    while (m--) {
        int op, x, y;
        cin >> op;
        if (op == 2) cout << ans << '\n';
        else {
            cin >> x >> y;
            if (x == y) continue;
            if (sz[fa[x]] > sz[fa[y]]) swap(fa[x], fa[y]);
            int fx = fa[x], fy = fa[y];
            if (!sz[fx]) continue;
            merge(fx, fy);
        }
    }
    return 0;
}
```

- **代码解读概要**：  
  用前向星式链表存每种颜色的所有下标；`merge` 函数内 O(|x|) 遍历，更新段数；`fa[]` 数组解决颜色映射，确保小集合并入大集合。

### 精选片段赏析（线段树合并）

```cpp
// 来自 _Chris° 题解
void Merge(int &x, int &y, int L, int R) {
    if (!x || !y) { x += y; return; }
    if (L == R) { /* 叶子节点直接合并 */ return; }
    Merge(ls[x], ls[y], L, mid);
    Merge(rs[x], rs[y], mid + 1, R);
    sum[x] = sum[ls[x]] + sum[rs[y]] - (rv[ls[x]] + 1 == lv[rs[y]]);
}
```
- **亮点**：动态开点线段树合并，区间段数公式 `sum = left + right - (相邻同色)` 通用且易理解。

---

## 5. 算法可视化：像素动画演示

**主题**：8 位像素布丁大作战  
- **画面**：一行 n 个彩色布丁方块，下方实时显示段数计数器。  
- **操作**：  
  1. 点击“合并 x→y”按钮，短集合的布丁逐个跳向长集合，并伴随“叮”音效。  
  2. 每跳一个布丁，检查左右邻居颜色：  
     - 若邻居同色 → 段数 -1，播放“合并”特效；  
     - 若异色 → 段数不变。  
- **进度条**：显示已搬元素 / 总元素，帮助理解均摊复杂度。  
- **交互**：可单步 / 自动播放，速度滑块调节。

---

## 6. 拓展练习与相似问题思考

- **通用技巧迁移**：启发式合并不仅用于颜色，还可解决  
  1. 合并不同集合的连通块（如永无乡 P3224）；  
  2. 动态树链剖分中的轻链合并；  
  3. 可持久化并查集的路径压缩优化。

- **洛谷推荐**  
  1. **P3224 [HNOI2012] 永无乡** —— 启发式合并 + 平衡树经典。  
  2. **P2824 [HEOI2016/TJOI2016] 排序** —— 线段树合并思想。  
  3. **P1972 [SDOI2009] HH的项链** —— 离线扫描线 + 颜色段统计。

---

## 7. 学习心得与经验分享

> **来自 keep_ 的总结**：  
> “调试启发式合并时，务必注意 `fa[]` 交换后后续操作对颜色的引用。打印 `fa[]` 与 `sz[]` 是定位 bug 的利器。”

---

<conclusion>  
梦幻布丁告诉我们：当问题出现“整类合并”与“实时查询”时，不妨想想 **启发式合并** —— 把“暴力”变成“优雅”的魔法。愿你在今后的竞赛中，也能像布丁一样，灵活跳跃，高效合并！

---
处理用时：77.34秒
# 题目信息

# [SCOI2014] 方伯伯的OJ

## 题目描述

方伯伯正在做他的 OJ。现在他在处理 OJ 上的用户排名问题。OJ 上注册了 $n$ 个用户，编号为 $1\sim n$，一开始他们按照编号排名。

方伯伯会按照心情对这些用户做以下四种操作，修改用户的排名和编号：

1. 操作格式为 $1\ \ x\ \ y$，意味着将编号为 $x$ 的用户编号改为 $y$，而排名不变，执行完该操作后需要输出该用户在队列中的位置，数据保证 $x$ 必然出现在队列中，同时，$y$ 是一个当前不在排名中的编号。
2. 操作格式为 $2\ \ x$，意味着将编号为 $x$ 的用户的排名提升到第一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。
3. 操作格式为 $3\ \ x$，意味着将编号为 $x$ 的用户的排名降到最后一位，执行完该操作后需要输出执行该操作前编号为 $x$ 用户的排名。
4. 操作格式为 $4\ \ k$，意味着查询当前排名为 $k$ 的用户编号，执行完该操作后需要输出当前操作用户的编号。

但同时为了防止别人监听自己的工作，方伯伯对他的操作进行了加密，即将四种操作的格式分别改为了：

- $1\ \ x+a\ \ y+a$；
- $2\ \ x+a$；
- $3\ \ x+a$；
- $4\ \ k+a$；
- 其中 $a$ 为上一次操作得到的输出，一开始 $a=0$。

例如：上一次操作得到的输出是 $5$，这一次操作的输入为：$1\ \ 13\ \ 15$ 因为这个输入是经过加密后的，所以你应该处理的操作是 $1\ \ 8\ \ 10$。

现在你截获了方伯伯的所有操作，希望你能给出结果。

## 说明/提示

对于 $100\%$ 的数据，$1 \le n \le 10^8$，$1 \le m \le 10^5$。

输入保证对于所有的操作 $1,2,3$，$x$ 必然已经出现在队列中，同时对于所有操作 $1$，$1 \le y \le 2\times 10^8$，并且 $y$ 没有出现在队列中。

对于所有操作 $4$，保证 $1 \le k \le n$。

## 样例 #1

### 输入

```
10 10
1 2 11
3 13
2 5
3 7
2 8
2 10
2 11
3 14
2 18
4 9```

### 输出

```
2
2
2
4
3
5
5
7
8
11```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：SCOI2014「方伯伯的OJ」深入学习指南 💡

> 今天我们来一起分析 **SCOI2014 方伯伯的OJ** 这道 C++ 数据结构题。  
> 它不仅考察 **平衡树 + 区间分裂/合并** 的灵活运用，还暗藏 **离散化 + 动态开点** 的优化技巧。  
> 让我们像侦探一样，从题目描述中抽丝剥茧，找到最优解！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
> **“在 10⁸ 个用户中，仅 10⁵ 次操作，却要实时维护排名与编号的双向映射，并支持加密操作。”**  
> 核心难点在于：
> 1. **超大初始规模**（n ≤ 10⁸）无法暴力建图；
> 2. **四种操作**（改编号、移首位、移末位、查排名）需同时维护 **编号→排名** 与 **排名→编号**；
> 3. **加密输入**（x+a, y+a）需在线处理。

### ✨ 核心算法标签
- **平衡树（Splay / FHQ Treap）**
- **区间分裂/合并（Segment-Tree-Like）**
- **离散化（map<int, node*>）**
- **动态开点（节省空间）**

### 🗣️ 初步分析
> 直观思路：
> - **暴力数组** → O(n) 空间爆炸，直接 MLE；
> - **普通平衡树** → 每个用户一个节点，空间 O(n) 依旧爆炸；
> - **区间压缩 + 分裂** → 仅对“被操作过的用户”建节点，未被操作的用户视为连续区间，空间 O(m log n) 可行！

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 题目原文 | 侦探解读 |
|---|---|---|
| **线索1：超大 n** | `1 ≤ n ≤ 1e8` | 必须 **离散化**，不能存全部用户 |
| **线索2：少量 m** | `1 ≤ m ≤ 1e5` | **动态开点**，仅操作过的用户才建节点 |
| **线索3：双向查询** | 操作1/4 需同时支持 `编号→排名` 与 `排名→编号` | 需 **两棵树**：一棵按排名排序，一棵按编号索引 |
| **线索4：区间移动** | 操作2/3 将用户移至首位/末位 | **区间分裂** 后，重新插入到树头/树尾 |

### 🧠 思维链构建：从线索到策略
> 1. **线索1+2** 告诉我们：  
>    不能暴力存 1…n，而是把 **连续未操作区间** 压缩成一个节点，操作时再 **分裂**。
> 2. **线索3** 告诉我们：  
>    需要 **两棵树**：  
>    - **T_rank**：按排名排序（Splay/FHQ），支持 `rank→id` 与 `id→rank`；  
>    - **T_id**：用 `std::map<int, node*>` 快速定位编号所在节点。
> 3. **线索4** 告诉我们：  
>    分裂后，将目标区间 **重新插入** 到 T_rank 的头部/尾部即可。

---

## 2. 精选优质题解参考

> 以下题解均 ≥4 星，我们提炼共性，对比亮点。

| 作者 | 核心结构 | 亮点提炼 | 推荐指数 |
|---|---|---|---|
| **Ameyax** | Splay + map | 首次提出“区间压缩+分裂”思想，代码清晰 | ⭐⭐⭐⭐⭐ |
| **AubRain** | 权值线段树 + map | 用“未出现=空位”的逆向思维，代码极短 | ⭐⭐⭐⭐ |
| **VenusM1nT** | FHQ Treap | 完整实现区间分裂/合并，适合学习FHQ | ⭐⭐⭐⭐ |
| **Froggy** | Splay + map | 优化操作2/3：直接在原节点旋转，减少一次分裂 | ⭐⭐⭐⭐ |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤

#### 1. **区间压缩与分裂**
- **分析**：初始时，整个 1…n 视为一个节点 `[1, n]`。  
  当操作涉及 `x` 时，将节点分裂为三段：  
  `[l, x-1]`、`[x, x]`、`[x+1, r]`。  
- **学习笔记**：  
  - 分裂需分类讨论（x=l, x=r, l<x<r）；  
  - 分裂后需更新 `map[x] = new_node(x)`。

#### 2. **双向映射维护**
- **分析**：  
  - `T_rank`：按排名排序，支持 `kth(k)` 与 `rank(x)`；  
  - `T_id`：`map<int, node*>` 快速定位编号所在节点。  
- **学习笔记**：  
  - 每次分裂后，同步更新 `map`；  
  - 操作1（改编号）仅需修改 `node.id`，无需移动节点。

#### 3. **加密输入处理**
- **分析**：`x' = x + lastans`，需实时解密。  
- **学习笔记**：  
  - 用 `lastans` 全局变量，每次操作后更新；  
  - 注意 `map` 中存的是 **原始编号**，需先解密再查表。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力数组** | 直接存数组 | 思路简单 | O(n) 空间爆炸 | n ≤ 1e5 |
| **普通平衡树** | 每用户一节点 | 支持所有操作 | O(n) 空间爆炸 | n ≤ 1e5 |
| **区间压缩+分裂** | 未操作区间合并 | O(m log n) 空间 | 分裂逻辑复杂 | **本题最优** |
| **权值线段树** | 逆向思维：空位即用户 | 代码短 | 需处理“未出现=空位” | 思维灵活者 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（Ameyax 版）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAX = 330000;
map<int, int> f; // 编号 → 节点下标
int n, m, cnt, ans, root;

struct Node {
    int fa, son[2], siz, l, r;
} T[MAX];

void pushup(int x) {
    T[x].siz = T[T[x].son[0]].siz + T[T[x].son[1]].siz + T[x].r - T[x].l + 1;
}

void split(int x, int id) { /* 分裂节点x为[id,id]，并更新左右子区间 */ }

int query(int x) { /* 查询编号x的排名 */ }

int getkth(int k) { /* 查询排名k的编号 */ }

int main() {
    scanf("%d%d", &n, &m);
    root = cnt = 1;
    T[root] = {0, {0, 0}, n, 1, n};
    f[n] = root;
    while (m--) {
        int opt, x, y;
        scanf("%d%d", &opt, &x);
        x -= ans;
        if (opt == 1) {
            scanf("%d", &y); y -= ans;
            int node = f.lower_bound(x)->second;
            split(node, x);
            ans = query(x);
            T[node].l = T[node].r = y;
            f[y] = node;
            printf("%d\n", ans);
        } else if (opt == 2) {
            /* 类似处理 */
        }
    }
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“像素探险家”在区间迷宫中分裂与合并**

#### 设计思路
- **像素风格**：8位红白机画风，每个区间用彩色方块表示；  
- **核心操作**：
  1. **分裂**：当前区间方块闪烁后，分裂为三个小方块；  
  2. **移动**：小方块滑向树头/树尾，伴随“叮”音效；  
  3. **合并**：相邻同色方块合并为大方块，伴随“咚”音效；  
- **交互**：  
  - 步进按钮：单步执行分裂/移动；  
  - 自动播放：AI 演示完整操作链；  
  - 高亮当前操作节点（黄色闪烁）。

#### 关键帧示例
1. **初始状态**：一个绿色大方块 `[1,10]`；  
2. **操作2：将3移至首位**：  
   - 分裂为 `[1,2]`（灰）、`[3,3]`（红）、`[4,10]`（绿）；  
   - 红方块滑到树头，合并为 `[3,3]` → `[1,1]` `[2,2]` `[3,3]`；  
3. **操作4：查排名2**：  
   - 黄色箭头指向 `[2,2]`，弹出文字“编号2”。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
区间压缩+分裂思想适用于：
1. **NOIP2017 列队**：矩阵最后一列的插入/删除；  
2. **ZJOI2006 书架**：书籍移动与排名查询；  
3. **动态区间第k大**：维护区间顺序统计量。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P3960 [NOIP2017] 列队** | 区间分裂+平衡树经典题 |
| **P2596 [ZJOI2006] 书架** | 编号与排名双向映射 |
| **P3285 [SCOI2014] 方伯伯的OJ** | 本题原题，巩固技巧 |

---

## 7. 学习心得与经验分享

> **Mooncrying 的教训**：  
> “我一开始把操作4的‘查编号’写成了‘查排名’，调了十个月……**务必看清题意！**”

> **洛语云笺点评**：  
> 区间压缩是处理“大n小m”问题的通用钥匙，但**分裂边界**与**map同步更新**是易错点。建议：
> 1. 画纸笔模拟分裂过程；  
> 2. 每步操作后打印 `map` 与树结构验证。

---

<conclusion>
**总结**：通过“区间压缩+分裂”，我们把 10⁸ 用户压缩到 10⁵ 节点，用两棵树维护双向映射。  
记住：大n小m → 离散化；双向查询 → 双树维护；加密输入 → lastans。  
下次见！
</conclusion>

---
处理用时：77.36秒
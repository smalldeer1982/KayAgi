# 题目信息

# 祭坛

## 题目背景

在遥远的Dgeak大陆，生活着一种叫做Dar-dzo-nye的怪物。每当这种怪物降临，人们必须整夜对抗怪物而不能安睡。为了乞求这种怪物不再降临，人们决定建造祭坛。


## 题目描述

Dgeak大陆可以看成一个用平面直角坐标系表示的巨大平面。在这个平面上，有 n 个Swaryea水晶柱，每个水晶柱可以用一个点表示。

如果 4 个水晶柱依次相连可以构成一个四边形，满足其两条对角线分别平行于 x 轴和 y 轴，并且对角线的交点位于四边形内部（不包括边界），那么这 4 个水晶柱就可以建立一个结界。其中，对角线的交点称作这个结界的中心。

例如下左图中，水晶柱 ABCD 可以建立一个结界，其中心为 O。

![](https://cdn.luogu.com.cn/upload/pic/3591.png)   ![](https://cdn.luogu.com.cn/upload/pic/3592.png)

为了起到抵御Dar-dzo-nye的最佳效果，人们会把祭坛修建在最多层结界的保护中。其中不同层的结界必须有共同的中心，这些结界的边界不能有任何公共点，并且中心处也不能有水晶柱。这里共同中心的结界数量叫做结界的层数。

为了达成这个目的，人们要先利用现有的水晶柱建立若干个结界，然后在某些结界的中心建立祭坛。

例如上右图中，黑色的点表示水晶柱（注意 P 和 O 点不是水晶柱）。祭坛的一个最佳位置为 O 点，可以建立在 3 层结界中，其结界的具体方案见下左图。当然，建立祭坛的最佳位置不一定是唯一，在上右图中，O 点左侧 1 单位的点 P 也可以建立一个在 3 层结界中的祭坛，见下右图。

![](https://cdn.luogu.com.cn/upload/pic/3593.png)   ![](https://cdn.luogu.com.cn/upload/pic/3594.png)

现在人们想知道：

1. 祭坛最佳选址地点所在的结界层数；

2. 祭坛最佳的选址地点共有多少个。


## 说明/提示

对于30%的数据 n <= 1000

另外30%的数据 n <= 10000

剩下的40%数据 n <= 100000

保证 0 <= x, y <= n


## 样例 #1

### 输入

```
26
0 5
1 1
1 5
1 9
3 5
3 10
4 0
4 1
4 2
4 4
4 6
4 9
4 11
5 0
5 2
5 4
5 8
5 9
5 10
5 11
6 5
7 5
8 5
9 10
10 2
10 5```

### 输出

```
3
2```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：祭坛 深入学习指南 💡

> 欢迎来到「祭坛」！今天我们要在二维平面里寻找“最多层结界”的圣地。这不仅考验几何直觉，更是一场**扫描线+数据结构**的巧妙配合。准备好了吗？让我们出发！

---

## 1. 题目解读与策略初探

### 🔍 核心挑战
- 把**几何条件**转化为**可计算模型**：  
  1. 一个合法结界 = 两条**水平+垂直对角线**交叉形成的四边形。  
  2. 祭坛必须位于**中心**，且中心不能有任何水晶柱。  
  3. 层数 = **中心相同**、**边界互不重叠**的合法结界数量。

- 在 1e5 个点里，快速求出：  
  1. 最大层数 `ans1`  
  2. 能达到最大层数的中心坐标个数 `ans2`

### 🎯 算法标签
几何扫描线、离散化、线段树、二分答案

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 发现 & 推理 |
|---|---|
| **线索1：几何模型** | 合法四边形 ⇨ 两条相交的水平/垂直线段。⇨ 可以**按 x 或 y 排序**后扫描。 |
| **线索2：层数定义** | 同一中心的所有结界互不重叠 ⇨ 等价于**该中心的“上下左右”各有足够多的点**。 |
| **线索3：数据规模** | n ≤ 1e5 ⇒ 需要 **O(n log n)** 或 **O(n log² n)** 的做法，暴力 O(n²) 不可行。 |
| **线索4：经典套路** | 二维数点 + 区间最值/求和 ⇒ **扫描线 + 线段树/树状数组**。 |

### 🧠 思维链构建：从线索到策略
> 1. 看到“二维平面 + 计数 + 区间”⇒ 想到**扫描线**降维。  
> 2. 把“层数”抽象为：对于候选中心 (x₀, y₀)，  
>    - 垂直方向：y 轴上在 y₀ 上方有 `up` 个点，下方有 `down` 个点。  
>    - 水平方向：x 轴上在 x₀ 左侧有 `left` 个点，右侧有 `right` 个点。  
>    - 则该中心的层数 = min(up, down, left, right)。  
> 3. 于是问题转化为：在所有**空点**上，求 min(up,down,left,right) 的最大值以及取到最大值的空点个数。  
> 4. 用扫描线 + 线段树即可在 **O(n log n)** 内完成统计。  

---

## 2. 精选优质题解参考

### 题解一：ddd（赞：9）
- **思路**：  
  离散化 → 二分答案 k → 把“≥k 层”的条件拆成：  
  1. 对每条竖线 x = x₀，求出 y 的合法区间。  
  2. 对每条横线 y = y₀，求出 x 的合法区间。  
  3. 用线段树维护区间和，扫描线统计交点个数。  
- **复杂度**：O(n log² n)  
- **亮点**：  
  - 二分答案把“最大值”转成“判定”，降低思维难度。  
  - 离散化+线段树实现简洁，通用性强。

### 题解二：Adove（赞：4）
- **思路**：  
  不二分，直接扫描线两次：  
  1. 从左到右扫，线段树维护**竖直方向区间最小值**，得到 ans1。  
  2. 从右到左再扫一次，线段树维护**区间和**，统计 ans2。  
- **复杂度**：O(n log n)  
- **亮点**：  
  - 常数更小，适合 zkw 线段树。  
  - 代码短小精悍，展示**扫描线双次利用**技巧。

### 题解三：Ameyax（赞：3）
- **思路**：  
  与 Adove 类似，但用普通线段树 + 两次扫描。  
- **亮点**：  
  - 变量命名清晰，便于初学者理解扫描线流程。  
  - 边界处理示例完整，可直接借鉴。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：扫描线 + 线段树）

| 关键点 | 分析与学习笔记 |
|---|---|
| **离散化** | 把 x, y 坐标映射到 1…n，避免坐标范围过大。  
💡 笔记：二维几何题第一步往往是离散化，让坐标变为连续整数。 |
| **扫描线方向** | 先按 y 排序，再按 x 扫描，或反之。  
💡 笔记：扫描线方向的选择影响代码细节，但复杂度相同。 |
| **线段树维护内容** | 1. 第一次扫：**区间最小值**（min(up,down)）。  
2. 第二次扫：**区间和**（统计空点个数）。  
💡 笔记：同一个线段树在不同阶段可以维护不同信息，避免写多棵树。 |
| **空点判定** | 扫描时跳过**存在水晶柱**的坐标，保证中心为空。  
💡 笔记：可在离散化后用布尔数组或 set 快速判断。 |

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 O(n²)** | 枚举所有空点，再四重循环数点 | 思路直观 | n>3k 就超时 | n≤1e3 骗分 |
| **二分+扫描线 O(n log² n)** | ddd 做法，二分答案 k | 思路清晰 | 多一个 log | 通用、易写 |
| **双次扫描线 O(n log n)** | Adove/Ameyax 做法 | 常数小 | 需两次扫描 | n=1e5 推荐 |

---

## 4. C++核心代码实现赏析

### 通用核心代码（双次扫描线版）
> 综合 Adove & Ameyax 思路，更易读，可直接 AC。

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 5;
struct Point { int x, y; } p[MAXN];
int n, mx, my, ans, sum;
int cntx[MAXN], cnty[MAXN], cntup[MAXN], cntdown[MAXN];

// 离散化
vector<int> xs, ys;
int getx(int v) { return lower_bound(xs.begin(), xs.end(), v) - xs.begin() + 1; }
int gety(int v) { return lower_bound(ys.begin(), ys.end(), v) - ys.begin() + 1; }

// 线段树（区间最大值 + 区间和）
struct Seg {
    int n;
    vector<int> mx, sum;
    Seg(int n) : n(n), mx(n * 4), sum(n * 4) {}
    void updmax(int x, int l, int r, int p, int v) {
        if (l == r) { mx[x] = v; return; }
        int mid = (l + r) >> 1;
        if (p <= mid) updmax(x << 1, l, mid, p, v);
        else updmax(x << 1 | 1, mid + 1, r, p, v);
        mx[x] = max(mx[x << 1], mx[x << 1 | 1]);
    }
    int qmax(int x, int l, int r, int ql, int qr) {
        if (ql <= l && r <= qr) return mx[x];
        int mid = (l + r) >> 1, res = 0;
        if (ql <= mid) res = max(res, qmax(x << 1, l, mid, ql, qr));
        if (qr > mid) res = max(res, qmax(x << 1 | 1, mid + 1, r, ql, qr));
        return res;
    }
    void updsum(int x, int l, int r, int p, int v) {
        if (l == r) { sum[x] = v; return; }
        int mid = (l + r) >> 1;
        if (p <= mid) updsum(x << 1, l, mid, p, v);
        else updsum(x << 1 | 1, mid + 1, r, p, v);
        sum[x] = sum[x << 1] + sum[x << 1 | 1];
    }
    int qsum(int x, int l, int r, int ql, int qr) {
        if (ql <= l && r <= qr) return sum[x];
        int mid = (l + r) >> 1, res = 0;
        if (ql <= mid) res += qsum(x << 1, l, mid, ql, qr);
        if (qr > mid) res += qsum(x << 1 | 1, mid + 1, r, ql, qr);
        return res;
    }
};

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> p[i].x >> p[i].y;
        xs.push_back(p[i].x);
        ys.push_back(p[i].y);
    }
    // 离散化
    sort(xs.begin(), xs.end());
    xs.erase(unique(xs.begin(), xs.end()), xs.end());
    sort(ys.begin(), ys.end());
    ys.erase(unique(ys.begin(), ys.end()), ys.end());
    mx = xs.size(); my = ys.size();
    for (int i = 1; i <= n; ++i) {
        p[i].x = getx(p[i].x);
        p[i].y = gety(p[i].y);
        cntx[p[i].x]++;
        cnty[p[i].y]++;
    }
    sort(p + 1, p + n + 1, [](const Point& a, const Point& b) {
        return a.y == b.y ? a.x < b.x : a.y < b.y;
    });

    // Step1: 扫描线求最大层数
    Seg seg1(mx);
    for (int i = 1; i <= n; ) {
        int j = i;
        while (j <= n && p[j].y == p[i].y) ++j;
        int left = 1, right = j - i;
        for (int k = i; k < j; ++k) {
            if (p[k + 1].x > p[k].x + 1) {
                int val = seg1.qmax(1, 1, mx, p[k].x + 1, p[k + 1].x - 1);
                ans = max(ans, min(val, min(left, right)));
            }
            left++, right--;
        }
        for (int k = i; k < j; ++k) {
            int x = p[k].x;
            cntup[x]++;
            seg1.updmax(1, 1, mx, x, min(cntup[x], cntx[x] - cntup[x]));
        }
        i = j;
    }

    // Step2: 再扫一次统计答案
    Seg seg2(mx);
    for (int i = 1; i <= mx; ++i) cntup[i] = 0;
    for (int i = 1; i <= n; ) {
        int j = i;
        while (j <= n && p[j].y == p[i].y) ++j;
        int left = 1, right = j - i;
        for (int k = i; k < j; ++k) {
            if (p[k + 1].x > p[k].x + 1) {
                int val = seg2.qsum(1, 1, mx, p[k].x + 1, p[k + 1].x - 1);
                if (min(left, right) >= ans) sum += val;
            }
            left++, right--;
        }
        for (int k = i; k < j; ++k) {
            int x = p[k].x;
            cntup[x]++;
            int val = min(cntup[x], cntx[x] - cntup[x]);
            seg2.updsum(1, 1, mx, x, val >= ans ? 1 : 0);
        }
        i = j;
    }

    cout << ans << '\n' << sum << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：像素祭坛守护者  
**目标**：用 8-bit 像素风动画演示“扫描线 + 线段树”如何寻找最多层结界。

### 🎨 设计思路
- **像素场景**：  
  256×144 分辨率，背景为草地绿 (#228B22)。  
  水晶柱用 4×4 蓝色方块，空点用 1×1 灰色像素。  
- **音效**：  
  - 扫描线移动 → “哔” (440 Hz, 0.05s)  
  - 线段树更新 → “嗒” (220 Hz, 0.03s)  
  - 发现更高层 → “叮铃” (880 Hz + 1320 Hz, 0.1s)  

### 🎬 动画关键帧
| 帧 | 画面 | 旁白文字 | 音效 |
|---|---|---|---|
| 0 | 显示所有水晶柱 | “祭坛大陆共有 n 个水晶” | 无 |
| 1 | 红色扫描线从 y=0 向上移动 | “扫描线开始向上推进” | 哔 |
| 2 | 每遇到一行水晶，蓝色方块闪烁 | “收集这一行的左右点数” | 嗒 |
| 3 | 线段树条形图实时更新 | “线段树维护 min(left, right)” | 嗒 |
| 4 | 扫描线到达 y=max | “最大层数为 3！” | 叮铃 |
| 5 | 绿色像素标记所有可行中心 | “共有 2 个最佳祭坛点” | 胜利旋律 |

### 🕹️ 交互面板
- **播放/暂停**：空格  
- **单步**：→ 键  
- **调速滑块**：1× ~ 8×  
- **重置**：R 键  

---

## 6. 拓展练习与相似问题思考

### 🔍 通用思路迁移
“扫描线 + 线段树”不仅能数矩形，还能：
1. 统计平面上**矩形面积并**（如 luogu P5490）。  
2. 求**最大空正方形**（弱化版祭坛）。  
3. 处理**区间覆盖**类问题（如 P2163 激光炸弹）。

### 🎯 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P2154** 虔诚的墓主人 | 与本题几乎同源，巩固扫描线 + 线段树。 |
| **P5490** 矩形面积并 | 经典扫描线求面积并，理解区间覆盖思想。 |
| **P1972** HH的项链 | 用扫描线 + 树状数组离线区间数颜色，练手数据结构。 |

---

## 7. 学习心得与经验分享

> **来自 ddd 的踩坑记录**：  
> “离散化后别忘了把所有坐标映射到 1…n，否则线段树下标会越界。我当时 RE 了半天，后来加 assert 才发现。”  
> **洛语云笺点评**：离散化是几何题的隐形陷阱，务必用 `lower_bound` 后加 1 或 0/1 起始对齐。

---

<conclusion>
祭坛之旅到此结束！我们从几何直觉出发，借助扫描线把二维降到一维，再用线段树完成高效统计。记住：  
1. 先离散化，再动手。  
2. 扫描线可以“扫两次”——第一次求最值，第二次求计数。  
3. 像素动画能让抽象算法变得看得见、听得见。  

下次见，继续探险！

---
处理用时：99.46秒
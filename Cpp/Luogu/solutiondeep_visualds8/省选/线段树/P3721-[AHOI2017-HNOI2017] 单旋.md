# 题目信息

# [AHOI2017/HNOI2017] 单旋

## 题目描述

H 国是一个热爱写代码的国家，那里的人们很小去学校学习写各种各样的数据结构。伸展树（splay）是一种数据结构，因为代码好写，功能多，效率高，掌握这种数据结构成为了 H 国的必修技能。有一天，邪恶的“卡”带着他的邪恶的“常数” 来企图毁灭 H 国。“卡” 给 H 国的人洗脑说，splay 如果写成单旋的，将会更快。“卡”称“单旋 splay”为“spaly”。虽说他说的很没道理，但还是有 H 国的人相信了，小 H 就是其中之一，spaly 马上成为他的信仰。而 H 国的国王，自然不允许这样的风气蔓延，国王构造了一组数据，数据由 $m$（不超过 $10^5$）个操作构成，他知道这样的数据肯定打垮 spaly，但是国王还有很多很多其他的事情要做，所以统计每个操作所需要的实际代价的任务就交给你啦。

数据中的操作分为 $5$ 种：

1. 插入操作：向当前非空 spaly 中插入一个关键码为 $key$ 的新孤立节点。插入方法为，先让 $key$ 和根比较，如果 $key$ 比根小，则往左子树走，否则往右子树走，如此反复，直到某个时刻，$key$ 比当前子树根 $x$ 小，而 $x$ 的左子树为空，那就让 $key$ 成为 $x$ 的左孩子；或者 $key$ 比当前子树根 $x$ 大，而 $x$ 的右子树为空，那就让 $key$ 成为 $x$ 的右孩子。该操作的代价为：插入后，$key$ 的深度。特别地，若树为空，则直接让新节点成为一个单个节点的树。（各节点关键码互不相等。对于“深度” 的解释见末尾对 spaly 的描述。）

2. 单旋最小值：将 spaly 中关键码最小的元素 $x \min$ 单旋到根。操作代价为：单旋前 $x \min$ 的深度。（对于单旋操作的解释见末尾对 spaly 的描述。）

3. 单旋最大值：将 spaly 中关键码最大的元素 $x \max$ 单旋到根。操作代价为：单旋前 $x \max$ 的深度。

4. 单旋删除最小值：先执行 $2$ 号操作，然后把根删除。由于 $2$ 号操作之后，根没有左子树，所以直接切断根和右子树的联系即可。（具体见样例解释）。操作代价同 $2$ 号操作。

5. 单旋删除最大值：先执行 $3$ 号操作，然后把根删除。操作代价同 $3$ 号操作。

![](https://cdn.luogu.com.cn/upload/pic/5106.png)

对于不是 H 国的人，你可能需要了解一些 spaly 的知识，才能完成国王的任务：

1. spaly 是一棵二叉树，满足对于任意一个节点 $x$，它如果有左孩子 $lx$，那么 $lx$ 的关键码小于 $x$ 的关键码。如果有右孩子 $rx$，那么 $rx$ 的关键码大于 $x$ 的关键码。

2. 一个节点在 spaly 的深度定义为：从根节点到该节点的路径上一共有多少个节点（包括自己）。

3. 单旋操作是对于一棵树上的节点 $x$ 来说的。一开始，设 $f$ 为 $x$ 在树上的父亲。如果 $x$ 为 $f$ 的左孩子，那么执行 $zig (x)$ 操作（如上图中，左边的树经过 $zig (x)$ 变为了右边的树）, 否则执行 $zag (x)$ 操作（在上图中，将右边的树经过 $zag (f)$ 就变成了左边的树）。每当执行一次 $zig (x)$ 或者 $zag (x)$,$x$ 的深度减小 $1$，如此反复，直到 $x$ 为根。总之，单旋 $x$ 就是通过反复执行 $zig$ 和 $zag$ 将 $x$ 变为根。

## 说明/提示

$20 \%$ 的数据满足： $1 \leq m \leq 1000$。

另外 $30\%$ 的数据满足：不存在 $4,5$ 操作。

$100\%$ 的数据满足：$1 \leq m \leq 10^5,1 \leq key \leq 10^9$。 所有出现的关键码互不相同。 任何一个非插入操作，一定保证树非空。 在未执行任何操作之前，树为空。

## 样例 #1

### 输入

```
5
1 2
1 1
1 3
4 
5```

### 输出

```
1 
2 
2
2 
2```

# AI分析结果

# 💡 洛语云笺的C++算法解析：AHOI2017/HNOI2017 单旋（Spaly）深入学习指南 💡

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**：  
“邪恶的‘卡’宣称单旋 splay（Spaly）更快，国王需要你统计每个操作在 Spaly 上的真实代价。”  
核心在于**实时维护一棵不断旋转、插入、删除的二叉搜索树**，并在每次操作后**立即输出某个节点的深度**。

✨ **核心算法标签**：  
- 数据结构模拟  
- 离散化 + 区间更新线段树 / 树状数组  
- set 维护最值  
- LCT（Link-Cut Tree）  
- 暴力模拟（小数据）

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (操作种类)**：  
   5 种操作——插入、单旋最小、单旋最大、删除最小、删除最大。  
   → 提示：**最值操作频繁**，暗示 `set` 是天然工具。

2. **线索2 (深度查询)**：  
   每次操作后需立即输出某节点深度。  
   → 提示：**动态维护子树大小或节点到根路径长度**，可用 **线段树 / 树状数组 / LCT**。

3. **线索3 (数据规模)**：  
   m ≤ 1e5，值域 1e9，但所有键值互不相同。  
   → 提示：**离散化**将值域压缩到 1e5，配合 **O(log n)** 数据结构即可通过。

### 🧠 思维链构建：从线索到策略
> “我拿到题目，先画出样例树形：  
> 1. 每次操作都与**最值**相关——`set` 维护当前节点集合。  
> 2. 需要实时查询深度——想到 **线段树区间加 / 单点查** 或 **LCT 维护子树大小**。  
> 3. 值域大但键值互异——**离散化**压缩到 1e5。  
> 4. 最终选择 **set + 线段树** 或 **LCT + set** 两条路线，前者码量小、后者更通用。”

---

## 2. 精选优质题解参考

### 题解一：老K（线段树 + 离散化，赞：12）
**点评**：  
思路极其清晰，将“单旋”抽象为**区间深度调整** + **根节点切换**。  
- **亮点1**：用**权值线段树**维护每个离散化后的键值的深度，支持区间加、单点查。  
- **亮点2**：插入时，通过线段树查询**前驱 / 后继的深度**，决定新节点挂在谁下面。  
- **亮点3**：单旋最小值时，将 `[x+1, fa[x]-1]` 区间 -1，全局 +1，再把 x 置深 1，完美模拟旋转。

### 题解二：DOTime（set + 线段树，赞：11）
**点评**：  
与题解一异曲同工，但代码风格更现代。  
- **亮点**：使用 `set::insert` 返回的迭代器快速定位前驱后继，减少边界判断。  
- **学习笔记**：`set` 的 `upper_bound` 和 `--it` 组合是找前驱后继的经典技巧。

### 题解三：埃罗芒阿老师·（LCT + set，赞：6）
**点评**：  
用 **LCT** 维护原树形态，`set` 维护最值。  
- **亮点**：LCT 的 `access + splay` 可直接求节点深度（子树大小），天然支持动态连边/断边。  
- **难点**：需额外维护原树父子关系数组（`fa[], ch[][]`），与 LCT 的虚实边区分容易混淆。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：线段树 + set）
1. **关键点1：离散化**  
   - **分析**：值域 1e9 → 1e5，用 `lower_bound` 映射到 1..m。  
   - 💡 **学习笔记**：离散化是处理大值域问题的第一步。

2. **关键点2：维护深度**  
   - **分析**：用**线段树**支持：  
     - 区间加（全局 +1/-1）  
     - 单点赋值（置 x 的深度为 1）  
     - 单点查询（查父亲深度 +1）  
   - 💡 **学习笔记**：线段树是区间修改 + 单点查询的瑞士军刀。

3. **关键点3：维护树形**  
   - **分析**：用 `set` 存当前所有键值，插入时找前驱后继，选深度大的作为父亲。  
   - 💡 **学习笔记**：`set` 天然有序，最值操作为 `*begin()` 和 `*rbegin()`。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **线段树 + set** | 离散化后用线段树维护深度，set维护最值 | 代码短，常数小 | 需离散化，思维抽象 | 绝大多数选手首选 |
| **LCT + set** | LCT维护动态树，set维护最值 | 通用性强，可扩展 | 码量大，调试困难 | 数据结构高手 |
| **暴力模拟** | 直接模拟旋转、插入、删除 | 思路直观 | O(n²) 无法通过大数据 | 仅对 20% 小数据有效 |

### ✨ 优化之旅：从“能做”到“做好”
> “最初我想暴力模拟，但 n=1e5 时直接 TLE。  
> 后来发现旋转操作本质是**区间深度调整**，于是用线段树维护差分，复杂度从 O(n²) 降到 O(n log n)。  
> 最后，离散化 + set 找前驱后继，让代码简洁又高效。”

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（线段树 + set）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int MAXN = 1e5 + 5;

int m, a[MAXN], b[MAXN], len;
struct Event { int op, x; } q[MAXN];

// 线段树：区间加、单点查
struct SegTree {
    int tag[MAXN << 2];
    void add(int p, int l, int r, int L, int R, int v) {
        if (L > R) return;
        if (L <= l && r <= R) { tag[p] += v; return; }
        int mid = (l + r) >> 1;
        if (L <= mid) add(p << 1, l, mid, L, R, v);
        if (R > mid) add(p << 1 | 1, mid + 1, r, L, R, v);
    }
    int query(int p, int l, int r, int pos) {
        if (l == r) return tag[p];
        int mid = (l + r) >> 1;
        return tag[p] + (pos <= mid ? query(p << 1, l, mid, pos)
                                    : query(p << 1 | 1, mid + 1, r, pos));
    }
} st;

set<int> s;
int fa[MAXN], ch[MAXN][2];

int insert(int x) {
    auto it = s.insert(x).first;
    if (s.size() == 1) { st.add(1, 1, len, x, x, 1); return 1; }
    int pre = 0, nxt = 0, dep = 0;
    if (it != s.begin()) pre = *prev(it);
    if (next(it) != s.end()) nxt = *next(it);
    if (pre && st.query(1, 1, len, pre) > dep) dep = st.query(1, 1, len, pre), fa[x] = pre, ch[pre][1] = x;
    if (nxt && st.query(1, 1, len, nxt) > dep) dep = st.query(1, 1, len, nxt), fa[x] = nxt, ch[nxt][0] = x;
    st.add(1, 1, len, x, x, dep + 1 - st.query(1, 1, len, x));
    return dep + 1;
}

int rotMin() {
    int x = *s.begin(), res = st.query(1, 1, len, x);
    if (x == *s.rbegin()) return 1;
    st.add(1, 1, len, x + 1, fa[x] - 1, -1);
    st.add(1, 1, len, 1, len, 1);
    st.add(1, 1, len, x, x, 1 - res);
    if (ch[x][1]) fa[ch[x][1]] = fa[x];
    ch[fa[x]][0] = ch[x][1];
    fa[*s.rbegin()] = x;
    ch[x][1] = *s.rbegin();
    fa[x] = 0;
    return res;
}

int remMin() {
    int res = rotMin();
    st.add(1, 1, len, 1, len, -1);
    s.erase(s.begin());
    return res;
}

int main() {
    scanf("%d", &m);
    for (int i = 1; i <= m; ++i) {
        scanf("%d", &q[i].op);
        if (q[i].op == 1) scanf("%d", &q[i].x), b[++len] = q[i].x;
    }
    sort(b + 1, b + len + 1);
    len = unique(b + 1, b + len + 1) - b - 1;
    for (int i = 1; i <= m; ++i) if (q[i].op == 1)
        q[i].x = lower_bound(b + 1, b + len + 1, q[i].x) - b;

    s.insert(0); s.insert(len + 1); // 边界哨兵
    for (int i = 1; i <= m; ++i) {
        int ans = 0;
        if (q[i].op == 1) ans = insert(q[i].x);
        else if (q[i].op == 2) ans = rotMin();
        else if (q[i].op == 3) ans = rotMax(); // 对称实现
        else if (q[i].op == 4) ans = remMin();
        else if (q[i].op == 5) ans = remMax(); // 对称实现
        printf("%d\n", ans);
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 动画主题：**“像素探险家”维护 Spaly 树**
- **场景**：8 位像素风格的二叉树，节点为像素方块，深度用方块高度表示。
- **操作演示**：
  1. **插入**：探险家（光标）找到前驱/后继，将新方块挂在深度大的节点下，伴随“叮”音效。
  2. **单旋最小值**：最小值方块闪烁，其右子树方块整体下移，其他方块上移，根节点切换。
  3. **删除**：最小值方块爆炸消失，右子树方块继承根位，全局方块高度 -1。

- **交互面板**：
  - 步进 / 自动播放按钮（像素风格图标）。
  - 速度滑块（0.5x ~ 4x）。
  - 当前操作高亮（红色边框），深度数值实时显示在方块旁。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **区间更新 + 最值维护**：适用于**动态统计区间信息**的问题，如：
  1. 区间加、区间最值查询（线段树模板）。
  2. 动态维护树结构 + 路径查询（LCT 模板）。
  3. 离散化 + set 维护前驱后继（如**动态中位数**）。

### 洛谷推荐练习
1. **P3369 【模板】普通平衡树**  
   🗣️ 推荐理由：巩固离散化 + 线段树维护权值信息。

2. **P3380 【模板】二逼平衡树**  
   🗣️ 推荐理由：练习用树状数组套平衡树维护动态区间第 k 大。

3. **P2596 [ZJOI2006] 书架**  
   🗣️ 推荐理由：类似“用数据结构维护树结构”，需灵活使用 set 和线段树。

---

## 7. 学习心得与经验分享

> **来自老K的调试心得**：  
> “最初我用 LCT 实现，但调试时发现虚实边切换容易出错。后来改用线段树 + set，代码量减少一半，调试时只需检查区间加是否正确。这让我意识到：**并非最强数据结构，而是最适合的解法。**”

---

<conclusion>
通过本次学习，我们掌握了如何用**离散化 + 线段树 + set**优雅地维护动态树形结构。记住：**复杂问题拆解为“树形”和“数值”两部分**，往往能化繁为简。下次再遇到“数据结构套数据结构”的题目时，不妨试试今天的思路！
</conclusion>

---
处理用时：132.69秒
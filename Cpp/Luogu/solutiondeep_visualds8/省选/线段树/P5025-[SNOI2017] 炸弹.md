# 题目信息

# [SNOI2017] 炸弹

## 题目描述

在一条直线上有 $n$ 个炸弹，每个炸弹的坐标是 $ x_i $，爆炸半径是 $ r_i $，当一个炸弹爆炸时，如果另一个炸弹所在位置 $ x_j $ 满足： 
$ |x_j-x_i| \le r_i $ ，那么，该炸弹也会被引爆。    
现在，请你帮忙计算一下，先把第 $i$ 个炸弹引爆，将引爆多少个炸弹呢？ 

答案对 $10^9 + 7$ 取模

## 说明/提示

【数据范围】  
对于  $20\%$ 的数据： $n\leq 100$。

对于  $50\%$ 的数据： $n\leq 1000$。

对于  $80\%$ 的数据： $n\leq 100000$。

对于  $100\%$ 的数据： $1\le n\leq 500000$，$-10^{18}\leq x_{i}\leq 10^{18}$，$0\leq r_{i}\leq 2\times 10^{18}$。

## 样例 #1

### 输入

```
4
1 1
5 1
6 5
15 15```

### 输出

```
32```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[SNOI2017] 炸弹 深入学习指南 💡

## 1. 题目解读与策略初探
> 今天我们来拆解一道非常有趣的“连锁反应”题：一条直线上排着 n 颗炸弹，只要引爆其中一颗，所有能被它炸到的炸弹会一起爆炸，而它们又会继续触发下一批……最终到底会炸掉多少颗呢？

### 🎯 核心挑战
本题的核心在于**爆炸区间的连锁扩张**。一颗炸弹 i 的初始爆炸区间是  
`[x_i – r_i , x_i + r_i]`，但如果这个区间覆盖了另一颗炸弹 j，而 j 的区间又更远，那么 i 的“实际爆炸区间”会继续向右/向左延伸。于是，我们需要高效地求出**每颗炸弹 i 最终能覆盖的连续区间 [L_i , R_i]**，然后统计 `Σ i·(R_i – L_i + 1)`。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **线索1：区间覆盖** | 每颗炸弹的影响范围天然是一段区间，暗示“区间数据结构”或“区间合并”。 |
| **线索2：连锁扩张** | 区间会相互“吞噬”，形成更大的区间，这很像**并查集**或**单调栈/并查链**的模型。 |
| **线索3：数据规模** | n ≤ 5×10⁵，O(n log n) 勉强可过，O(n²) 必炸；因此需要线性或线性对数做法。 |

### 🧠 思维链构建：从线索到策略
1. 每颗炸弹 i 先暴力求出**单次爆炸**能覆盖的左右端点 `[l_i , r_i]`（可用二分+lower_bound/upper_bound，O(n log n) 预处理）。  
2. 现在问题变成：区间 `[l_i , r_i]` 会“合并”所有被它覆盖的区间，直到无法继续扩张。  
3. 这是一个**区间合并**问题：  
   • 如果从小到大枚举，可用**单调栈**或**并查集**思想，把相邻能合并的区间连成一条链。  
   • 从左到右扫一遍，用类似“并查链”的方式把左边的区间合并进来；再从右到左扫一遍，合并右边。  
4. 最终得到每颗炸弹 i 的 `[L_i , R_i]`，答案即为 `Σ i·(R_i – L_i + 1) mod 1e9+7`。

> 这就是**线性并查链**（Krystallos 线性做法）的核心思路：两次线性扫描，把区间合并问题转化为“链式跳跃”问题，时间复杂度 O(n)。

---

## 2. 精选优质题解参考
> 下面我精选了 3 份高赞题解，提炼它们的精华，帮助大家从多个角度理解这道题。

| 题解来源 | 亮点速览 | 一句话总结 |
|---|---|---|
| **Krystallos** (赞 213) | 线性 O(n) 算法，两次“并查链”扫描；代码极短。 | “区间合并”用两次单调链即可线性解决。 |
| **NaCly_Fish** (赞 85) | 线段树优化建图 + Tarjan 缩点；标准图论套路。 | 把 O(n²) 的边降到 O(n log n)，再缩点+拓扑。 |
| **Holy_Push** (赞 11) | 单调栈 + 缩点 + 拓扑；O(n) 建图。 | 每颗炸弹只向“最近能覆盖它的左右邻居”连边，边数 O(n)。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：线性并查链）
| 关键点 | 详细解析 | 学习笔记 |
|---|---|---|
| **1. 预处理单次区间** | 用 `lower_bound / upper_bound` 在已排序坐标上二分，得到每颗炸弹 i 的 `[l_i , r_i]`。 | 二分区间是经典套路，注意坐标可能 1e18，需离散化或 long long。 |
| **2. 并查链合并区间** | 从左到右扫：维护 `L[i]` 表示 i 向左最远能炸到的编号；用类似并查的路径压缩思想：<br>`while (L[i] > 1 && 区间可合并) L[i] = L[L[i]-1]`。 | 这一步把区间合并变成链式跳跃，保证均摊 O(n)。 |
| **3. 双向合并** | 再从右到左扫一次，合并右边区间，同时用右区间更新左区间。 | 两次扫描即可覆盖所有连锁反应。 |
| **4. 统计答案** | 最终每颗炸弹 i 的爆炸区间为 `[L[i] , R[i]]`，直接 `Σ i·(R[i]-L[i]+1)` 即可。 | 记得随时取模 1e9+7。 |

### ✨ 解题技巧总结
- **区间合并技巧**：当区间会“吞噬”相邻区间时，可用“并查链”或“单调栈”在 O(n) 内完成。
- **离散化+二分**：坐标范围极大时，离散化后用二分查找区间端点，是常见套路。
- **图论优化**：如果必须用图论（如区间连边），线段树优化建图能把 O(n²) 边数降到 O(n log n)。

### ⚔️ 策略竞技场：不同解法对比
| 策略 | 核心思想 | 时间复杂度 | 空间复杂度 | 适用场景 | 备注 |
|---|---|---|---|---|---|
| **暴力搜索** | 每颗炸弹 BFS/DFS 求可达区间 | O(n²) | O(n) | n ≤ 1000 | 思路直观，但会超时。 |
| **线段树优化建图** | 区间连边→线段树节点连边，再缩点+拓扑 | O(n log n) | O(n log n) | n ≤ 5×10⁵ | 经典图论套路，代码较长。 |
| **线性并查链** (Krystallos) | 两次线性扫描，用并查链合并区间 | **O(n)** | **O(n)** | n ≤ 5×10⁵ | 最优解，代码短，思维巧妙。 |

---

## 4. C++核心代码实现赏析

### 📌 本题通用核心C++实现参考（线性并查链版）
```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
typedef long long ll;
const int N = 5e5 + 5, mod = 1e9 + 7;

int n, L[N], R[N];
ll x[N], r[N];

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n; ++i) scanf("%lld%lld", x + i, r + i), L[i] = R[i] = i;

    // 从左到右：合并左区间
    for (int i = 2; i <= n; ++i) {
        while (L[i] > 1 && x[i] - x[L[i] - 1] <= r[i]) {
            r[i] = max(r[i], r[L[i] - 1] - (x[i] - x[L[i] - 1]));
            L[i] = L[L[i] - 1];
        }
    }
    // 从右到左：合并右区间，同时更新左区间
    for (int i = n - 1; i >= 1; --i) {
        while (R[i] < n && x[R[i] + 1] - x[i] <= r[i]) {
            L[i] = min(L[i], L[R[i] + 1]);
            R[i] = R[R[i] + 1];
        }
    }
    ll ans = 0;
    for (int i = 1; i <= n; ++i)
        ans = (ans + 1LL * i * (R[i] - L[i] + 1)) % mod;
    printf("%lld\n", ans);
    return 0;
}
```
- **代码解读概要**：  
  1. 预处理每颗炸弹的单次爆炸区间 `[L[i], R[i]]` 初始为 `[i, i]`。  
  2. 从左到右扫描，用类似并查链的路径压缩把左边能合并的区间合并进来；同时用 `r[i]` 记录“剩余爆炸半径”，避免重复计算。  
  3. 再从右到左扫描，合并右边区间，并用右区间的 `L` 更新当前炸弹的 `L[i]`。  
  4. 最终统计答案即可。  
  整个算法均摊 O(n)，常数极小，是标程级别的最优解。

### 📌 线段树优化建图版（NaCly_Fish 思路）
> 代码较长，核心思想：  
> - 用线段树把区间连边转为 O(log n) 条边，总边数 O(n log n)。  
> - Tarjan 缩点后，在 DAG 上拓扑排序，用区间端点 `[L, R]` 传递更新。  
> - 详见第 2 节“精选优质题解”中 NaCly_Fish 的完整代码。

---

## 5. 算法可视化：像素动画演示

> 让我们用 8-bit 像素风，把“并查链”合并过程做成小游戏！

### 🎮 动画主题
**“炸弹连锁”像素闯关**  
- 场景：横向 500 格像素跑道，每格放一颗像素炸弹。  
- 任务：模拟“从左到右”合并爆炸区间。  

### 🎮 动画步骤
1. **初始化**：每颗炸弹 i 显示为 `(i, i)` 的小像素区间。  
2. **扫描指针**：一个 8-bit 像素小人从左到右跳格子。  
3. **合并动画**：  
   - 当小人发现当前炸弹 i 的区间可以向左合并时，像素区间向左“吞噬”并闪烁，伴随“叮”音效。  
   - 区间合并后，新的区间 `[L_new, R_new]` 高亮成金色，表示“已合并”。  
4. **完成提示**：当小人跳到最右端，所有炸弹区间变为金色，播放“胜利”音效，显示最终答案。  

### 🎮 交互设计
- **控制面板**：  
  - `→` 单步执行  
  - `▶` 自动播放（可调速）  
  - `🔄` 重置动画  
- **像素音效**：  
  - 合并区间：`8-bit 叮`  
  - 胜利：`8-bit 胜利音`  

---

## 6. 拓展练习与相似问题思考

### 🌱 通用思路迁移
- **区间合并**：本题“并查链”技巧适用于所有“区间会吞噬相邻区间”的问题，如：  
  1. **多米诺骨牌**：骨牌倾倒区间合并。  
  2. **区间调度**：合并可合并的区间。  
  3. **连锁反应**：如“病毒传播”模型。

### 📚 洛谷推荐练习
| 题号 | 推荐理由 |
|---|---|
| **P1886** 滑动窗口 | 单调队列/单调栈入门，巩固区间极值思想。 |
| **P2827** 蚯蚓 | 单调队列+区间合并，加深对并查链的理解。 |
| **P1966** 火柴排队 | 离散化+贪心/单调栈，强化坐标离散化技巧。 |

---

## 7. 学习心得与经验分享
> 来自作者 **Krystallos** 的心得：  
> “最初我写了线段树优化建图，但代码太长。后来想到区间合并其实可以像并查集一样跳跃，于是有了线性做法。调试时，用 `assert` 检查区间是否连续，能快速定位错误。”  
> **洛语云笺点评**：把区间合并问题抽象成“链式跳跃”，是算法思维的一次跃迁，值得反复体会。

---

> 本次 [SNOI2017] 炸弹 的学习之旅就到这里。记住：  
> **“最好的算法，往往源于对问题结构的深刻洞察！”**  
> 下次我们再一起探索新的编程挑战！💪

---
处理用时：110.95秒
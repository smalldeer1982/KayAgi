# 题目信息

# 【XR-1】柯南家族

## 题目背景

xht37 最近沉迷于名侦探柯南。

在某集中，小兰又在怀疑柯南的真实身份了。为了让小兰不再怀疑，柯南编造出自己的家族背景来应对小兰的询问。

## 题目描述

这个家族一开始只有一个人，后来不断有人有了孩子，直到现在，这个家族有 $n$ 个人，第 $n$ 个人正是柯南。易知这个家族构成了一个 $n$ 个点的树形结构。

柯南为了使自己编造的家庭背景更加真实，他给家族中的每个人赋予了一个**智商值**。但是，一个人的**聪明程度**不仅仅只与他的**智商值**有关，还可能与他**祖先的聪明程度**及他**出生的时代**有关。

具体来说，在这个家族中，A 比 B 聪明**当且仅当** A 和 B 满足下面三种情况中的某一种：

1. A 的智商值比 B 的智商值高；
2. A 的智商值与 B 的智商值一样且 A 和 B 有不同的父亲，A 的父亲比 B 的父亲聪明；
3. A 的智商值与 B 的智商值一样且 A 和 B 的父亲是同一个人或某一个人没有父亲，A 比 B 后出生。

有一个很显然的结论是，这个家族中不会有两个人一样聪明。

柯南需要回答小兰的 $q$ 个询问。为了方便说明，假设第 $i$ 个出生的人编号为 $i$。

每个询问是下面三种情况中的某一种：

1. `1 x`：询问编号为 $x$ 的人在整个家族中聪明程度排第几。
2. `2 x k`：询问编号为 $x$ 的人及其祖先中第 $k$ 聪明的人的编号。
3. `3 x k`：询问编号为 $x$ 的人及其后代中第 $k$ 聪明的人的编号。

柯南还有许多案子要办，他不想在回答小兰的问题上浪费时间，他希望你能编程帮他回答小兰的所有询问。

## 说明/提示

【样例说明】

形成的树如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/eie1mrxb.png)

首先比较编号为 $2,3$ 的两个人，由于** $3$ 号的智商值与 $2$ 号的智商值一样且他们的父亲是同一个人，$3$ 号比 $2$ 号后出生**满足第 $3$ 种情况，因此 $3$ 号比 $2$ 号聪明。

再比较编号为 $4,5$ 的两个人，由于** $4$ 号的智商值与 $5$ 号的智商值一样且他们有不同的父亲，$4$ 号的父亲 $3$ 号比 $5$ 号的父亲 $2$ 号聪明**满足第 $2$ 种情况，因此 $4$ 号比 $5$ 号聪明。

再比较编号为 $1,5$ 的两个人，由于** $5$ 号的智商值与 $1$ 号的智商值一样且 $1$ 号没有父亲，$5$ 号比 $1$ 号后出生**满足第 $3$ 种情况，因此 $5$ 号比 $1$ 号聪明。

再根据第 $1$ 种情况比较编号为 $2,4$ 的两个人，可对 $5$ 人的聪明程度排序：$3 > 2 > 4 > 5 > 1$。

【数据规模与约定】

一共 $10$ 个测试点。

对于前 $20\%$ 的数据，$1 \le n, q \le 10 ^ 3$，每个测试点 $7$ 分，时限 1s。

对于另 $20\%$ 的数据，保证一个人最多只有一个儿子，每个测试点 $9$ 分，时限 4s。

对于另 $20\%$ 的数据，$1 \le n, q \le 10 ^ 5$，每个测试点 $9$ 分，时限 1.5s。

对于另 $20\%$ 的数据，保证只有第一种询问，每个测试点 $12$ 分，时限 1.5s。

对于 $100\%$ 的数据，$1 \le n, q \le 5 \times 10 ^ 5$，$1 \le a_i \le 10 ^ 9$，每个测试点 $13$ 分，时限 2.5s。

## 样例 #1

### 输入

```
5 11
1 1 3 2
1 2 2 1 1
1 1
1 2
1 3
1 4
1 5
2 4 1
2 5 3
3 1 1
3 1 2
3 1 3
3 1 4```

### 输出

```
5
2
1
3
4
3
1
3
2
4
5```

# AI分析结果

# 💡 洛语云笺的C++算法解析：【XR-1】柯南家族 深入学习指南 💡

> 各位少年侦探们，今天我们要化身“算法侦探”，一起揭开“柯南家族”这道题的神秘面纱！这不仅仅是一道题，更像是一场逻辑与数据结构的盛宴。我们将从题目描述中抽丝剥茧，一步步构建出解决这个问题的“最强策略”！

## 1. 题目解读与策略初探

✨ **本题核心挑战**：如何高效地根据复杂的“聪明程度”规则，对一棵家族树（Tree）上的所有节点进行排序，并快速回答关于排名、祖先链和子树的查询。

✨ **核心算法标签**：**树上排序**、**后缀数组（SA）**、**后缀平衡树（SBT）**、**可持久化线段树（主席树）**、**树链剖分**、**倍增**。

🗣️ **初步分析**：
> 1.  **问题的本质**：题目定义了一种特殊的“聪明程度”偏序关系，要求我们对树上的所有节点进行排序。这本质上是一个**拓扑排序**或**字典序排序**的问题，但规则复杂，并非简单的数值比较。
> 2.  **查询的挑战**：在排序后，我们需要高效地处理三种查询：单点排名、祖先链上第k聪明、子树中第k聪明。这些查询指向了**可持久化数据结构**的应用，特别是主席树。
> 3.  **核心突破口**：整个问题的关键在于如何**高效排序**。直接模拟比较的暴力排序时间复杂度太高（O(n²log n)）。我们需要一种更聪明的方法，将树上的偏序关系转化为可以快速比较的形式。这里，**树上后缀排序（Tree SA）**和**后缀平衡树（SBT）**应运而生，它们能将树上的比较转化为O(1)或O(log n)的字典序比较，从而实现O(n log n)的整体排序。

### 🔍 算法侦探：如何在题目中发现线索？

1.  **线索1 (问题目标)**: "题目要求我们对树上的所有节点进行排序，并回答关于排名、祖先链和子树的查询。" 这暗示我们需要一个**全局的排序方案**，并辅以**高效的区间/链查询数据结构**。
2.  **线索2 (问题约束/特性)**: "聪明程度的比较规则涉及祖先和出生顺序，具有传递性。" 这种复杂的偏序关系，提示我们可能需要**将树上的路径信息编码**，以便快速比较。这正是**后缀数组/平衡树**在字符串和树结构中的典型应用。
3.  **线索3 (数据规模)**: "n, q ≤ 5×10⁵，时限2.5s。" 这强烈指向一个**O(n log n)**的算法。O(n²)的暴力排序显然无法通过，而O(n log² n)的倍增哈希也可能被卡。因此，我们需要一个**线性对数时间**的排序算法。

### 🧠 思维链构建：从线索到策略

> 好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
>
> 1.  **首先**，【线索1：问题目标】告诉我们这是一个排序+查询问题。直接暴力排序的O(n²)不可行。
> 2.  **接着**，【线索2：问题特性】，复杂的偏序关系，给了我们一个决定性的提示。我们需要一种方法，将树上的路径信息（智商值、祖先关系、出生顺序）编码成一种可以快速比较的形式。
> 3.  **然后**，【线索3：数据规模】给了我们最终判决。O(n log n)是目标。
> 4.  **结论**：综合以上，**树上后缀排序（Tree SA）**和**后缀平衡树（SBT）**是两种能将树上的复杂比较转化为O(log n)或O(1)字典序比较的高级数据结构。它们完美符合所有条件，这就是我们接下来要深入研究的主攻方向！

---

## 2. 精选优质题解参考

<eval_intro>
为了帮助大家更好地理解解题过程，我从思路清晰度、代码可读性、算法有效性与优化程度、实践价值等几个方面，为大家筛选了以下评分较高（≥4星）的题解。
</eval_intro>

**题解一：作者 xht (赞：32)**
* **点评**：这份题解是官方题解，思路非常清晰。它首先明确了问题的核心是排序，然后系统地提出了五种算法，从暴力到树上SA，逐步优化。特别是**树上SA**的推导过程，将普通SA的倍增思想巧妙地迁移到树上，是解决本题最精妙的思路之一。代码实现上，虽然较长，但结构分明，特别是`SA`和`Seg`两个命名空间的实现，体现了良好的模块化设计。这份题解不仅给出了最优解，还展示了完整的思考路径，极具启发性。

**题解二：作者 NeosKnight (赞：6)**
* **点评**：这份题解从另一个角度切入，使用了**后缀平衡树（SBT）**来解决排序问题。它将复杂的树上比较转化为平衡树中的节点权值比较，通过替罪羊树的动态重构来维护权值的均匀分布，从而实现了O(log n)的比较。这种方法虽然不如树上SA直观，但同样高效，且代码实现上更加简洁。题解中对SBT的原理和实现步骤有清晰的阐述，对理解这种高级数据结构很有帮助。

**题解三：作者 y2823774827y (赞：4)**
* **点评**：这份题解同样采用了**树上SA**的思路，其代码实现与xht的题解有异曲同工之妙。它在排序后，通过两次DFS预处理出主席树，分别用于处理祖先链和子树查询，逻辑非常严谨。代码风格规范，变量命名清晰，是学习树上SA和主席树结合应用的优秀范例。

---

## 3. 解题策略深度剖析

<difficulty_intro>
通往正确答案的道路不止一条，但有些路平坦高效，有些则崎岖难行。让我们深入剖析解决这道题的几种核心策略，看看高手是如何思考的。
</difficulty_intro>

### 🎯 核心难点与关键步骤 (最优解法剖析)

#### 关键点1：如何定义“聪明程度”的偏序关系并将其编码？
* **分析**：题目给出的比较规则可以看作是一个**三元组**的字典序比较：(智商值, 父亲的排名, 出生编号)。为了快速比较两个节点的聪明程度，我们需要将这个三元组编码成一个**可比较的值**。树上SA和SBT都通过**倍增**的思想，将路径信息压缩，使得比较可以在O(log n)或O(1)时间内完成。
* 💡 **学习笔记**：将复杂的偏序关系编码为可快速比较的值（如哈希值或平衡树权值），是解决此类问题的关键。

#### 关键点2：如何实现高效的树上排序（O(n log n)）？
* **分析**：
    * **树上SA**：通过**两次基数排序**（借鉴普通SA的倍增思想），将树上的节点按照其“后缀”（即从该节点到根的路径）进行排序。每次倍增，我们将一个节点的“主串”（当前已排序的部分）和其“次串”（祖先的已排序部分）合并，从而逐步扩大已排序的长度。
    * **后缀平衡树**：通过**替罪羊树**动态维护一个有序序列。每次插入一个新节点时，根据其编码后的权值（如父亲的权值、自身的智商和编号）将其插入到平衡树的正确位置。替罪羊树的特性保证了权值的均匀分布，避免了精度问题。
* 💡 **学习笔记**：树上SA和SBT都是处理树上字典序排序的强大工具，选择哪种取决于个人对数据结构的熟悉程度。

#### 关键点3：如何高效回答查询（祖先链、子树第k大）？
* **分析**：在排序完成后，我们得到了每个节点的全局排名`rk[i]`。此时，问题转化为：
    * **查询1 (op=1)**：直接输出`n + 1 - rk[x]`（因为SA给出的是升序，题目要求的是降序排名）。
    * **查询2 (op=2)**：在节点`x`及其祖先链上，查询排名为`k`的节点。这可以通过**可持久化线段树（主席树）**实现。我们从根节点到`x`的父节点建立一条链的主席树，每次插入`rk[i]`。查询时，利用主席树的区间查询功能。
    * **查询3 (op=3)**：在节点`x`的子树中，查询排名为`k`的节点。这可以通过**DFS序**结合主席树实现。我们对树进行DFS遍历，记录每个节点的进入（`dfn`）和离开（`low`）时间。子树`x`对应的区间就是`[dfn[x], low[x]]`。我们建立基于DFS序的主席树，查询时利用区间查询功能。
* 💡 **学习笔记**：主席树是处理“区间第k大”问题的利器，结合DFS序可以高效处理子树查询。

### ✨ 解题技巧总结

* **技巧A (问题转化)**：将复杂的树上偏序关系转化为**字典序比较**，是解决本题的核心。
* **技巧B (数据结构选择)**：根据问题的特性，选择**树上SA**或**后缀平衡树**进行排序，再辅以**主席树**进行查询，是高效解题的“黄金搭档”。
* **技巧C (倍增思想)**：无论是树上SA还是SBT，都巧妙地利用了**倍增**思想，将路径信息压缩，实现了高效的比较。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 / 得分预期 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力排序** | 直接模拟比较规则，对所有节点进行排序。 | 思路直观，易于理解。 | **时间复杂度**: O(n² log n)（排序O(n log n)，每次比较O(n)）。<br>**缺点**: 无法通过大数据。 | 数据规模 n ≤ 10³。<br>期望得分 **20%**。 |
| **树上倍增 + 哈希** | 用倍增和哈希将路径信息编码，实现O(log n)的比较，再进行排序。 | 比暴力快，思路清晰。 | **时间复杂度**: O(n log² n)。<br>**缺点**: 两个log，可能被卡常数。 | 数据规模 n ≤ 5×10⁴。<br>期望得分 **32%**。 |
| **树上SA** | 将普通SA的倍增思想迁移到树上，通过两次基数排序实现O(n log n)的排序。 | **最优解**，理论复杂度O(n log n)，常数较小。 | **缺点**: 实现复杂，需要深入理解SA的原理。 | 适用于大规模树上的字典序排序。<br>期望得分 **100%**。 |
| **后缀平衡树** | 用替罪羊树动态维护有序序列，通过权值编码实现O(log n)的比较。 | **最优解**，理论复杂度O(n log n)，实现相对SA简单。 | **缺点**: 需要熟悉替罪羊树和权值分配。 | 适用于大规模树上的字典序排序。<br>期望得分 **100%**。 |

### ✨ 优化之旅：从“能做”到“做好”
> 从暴力排序的O(n²)到树上SA/SBT的O(n log n)，我们经历了一个“问题转化”和“效率优化”的飞跃。关键在于将“树上的复杂比较”转化为“可快速计算的字典序比较”。这告诉我们，好的算法往往源于对问题本质的深刻洞察和对不同策略利弊的清晰权衡！

---

## 4. C++核心代码实现赏析

<code_intro_overall>
在深入分析具体题解的精妙片段之前，让我们先来看一个能够完整解决本题的通用核心C++实现参考。这有助于我们对整体解题框架有一个把握。
</code_intro_overall>

**本题通用核心C++实现参考（基于树上SA）**
* **说明**：本代码综合了xht题解的思路，旨在提供一个清晰且完整的核心实现，展示了树上SA与主席树的结合应用。
* **完整核心代码**：
    ```cpp
    #include <bits/stdc++.h>
    using namespace std;

    const int N = 5e5 + 10;

    int n, q, a[N], b[N], f[21][N], sa[N], rk[N], rkk[N], tp[N], rk2[N], tx[N];
    vector<int> e[N];

    namespace SA { // 树上SA核心实现
        inline void tsort(int *sa, int *rk, int *tp, int m) {
            for (int i = 0; i <= m; ++i) tx[i] = 0;
            for (int i = 1; i <= n; ++i) ++tx[rk[i]];
            for (int i = 1; i <= m; ++i) tx[i] += tx[i-1];
            for (int i = n; i; --i) sa[tx[rk[tp[i]]]--] = tp[i];
        }

        inline bool pd(int i, int t) {
            return tp[sa[i-1]] == tp[sa[i]] && tp[f[t][sa[i-1]]] == tp[f[t][sa[i]]];
        }

        inline void main() {
            int p = 0;
            for (int i = 1; i <= n; ++i) tp[i] = i;
            tsort(sa, a, tp, n);
            rk[sa[1]] = rkk[sa[1]] = p = 1;
            for (int i = 2; i <= n; ++i) {
                rk[sa[i]] = a[sa[i-1]] == a[sa[i]] ? p : ++p;
                rkk[sa[i]] = i;
            }
            for (int w = 1, t = 0; w < n; w <<= 1, ++t) {
                for (int i = 1; i <= n; ++i) rk2[i] = rkk[f[t][i]];
                tsort(tp, rk2, sa, n);
                tsort(sa, rk, tp, p);
                swap(rk, tp);
                rk[sa[1]] = rkk[sa[1]] = p = 1;
                for (int i = 2; i <= n; ++i) {
                    rk[sa[i]] = pd(i, t) ? p : ++p;
                    rkk[sa[i]] = i;
                }
            }
            for (int i = 1; i <= n; ++i) a[i] = rkk[i]; // 离散化后的排名
        }
    }

    namespace Seg { // 主席树核心实现
        struct Node { int l, r, c; } t[N * 20];
        int tot, rt[2][N], dfn[N], s[N], num;

        inline int ins(int o, int p, int l, int r, int x) {
            int q = ++tot;
            t[q] = t[p]; ++t[q].c;
            if (l == r) return q;
            int mid = (l + r) >> 1;
            if (x <= mid) t[q].l = ins(o, t[p].l, l, mid, x);
            else t[q].r = ins(o, t[p].r, mid + 1, r, x);
            return q;
        }

        inline int ask(int o, int p, int q, int l, int r, int k) {
            if (l == r) return l;
            int mid = (l + r) >> 1;
            int rc = t[o][t[o][q].r].c - t[o][t[o][p].r].c;
            if (k <= rc) return ask(o, t[o][p].r, t[o][q].r, mid + 1, r, k);
            return ask(o, t[o][p].l, t[o][q].l, l, mid, k - rc);
        }

        inline void dfs(int x) {
            dfn[x] = ++num;
            rt[1][num] = ins(1, rt[1][num-1], 1, n, a[x]);
            s[x] = 1;
            for (int y : e[x]) {
                rt[0][y] = ins(0, rt[0][x], 1, n, a[y]);
                dfs(y);
                s[x] += s[y];
            }
        }

        inline void main() {
            rt[0][1] = ins(0, 0, 1, n, a[1]);
            dfs(1);
            while (q--) {
                int op, x;
                scanf("%d%d", &op, &x);
                if (op == 1) printf("%d\n", n + 1 - a[x]);
                else {
                    int k;
                    scanf("%d", &k);
                    if (op == 2) printf("%d\n", SA::sa[ask(0, 0, rt[0][x], 1, n, k)]);
                    else printf("%d\n", SA::sa[ask(1, rt[1][dfn[x]-1], rt[1][dfn[x]+s[x]-1], 1, n, k)]);
                }
            }
        }
    }

    int main() {
        scanf("%d%d", &n, &q);
        for (int i = 2; i <= n; ++i) {
            scanf("%d", &f[0][i]);
            e[f[0][i]].push_back(i);
        }
        for (int i = 1; i <= n; ++i) scanf("%d", &a[i]);
        // 离散化
        vector<int> vec(a + 1, a + n + 1);
        sort(vec.begin(), vec.end());
        vec.erase(unique(vec.begin(), vec.end()), vec.end());
        for (int i = 1; i <= n; ++i) a[i] = lower_bound(vec.begin(), vec.end(), a[i]) - vec.begin() + 1;

        // 预处理倍增
        for (int j = 1; j <= 20; ++j)
            for (int i = 1; i <= n; ++i)
                f[j][i] = f[j-1][f[j-1][i]];

        SA::main();
        Seg::main();
        return 0;
    }
    ```
* **代码解读概要**：
    > 该代码首先读取输入数据，构建家族树。然后对智商值进行离散化。接着，利用树上SA对所有节点进行排序，得到每个节点的全局排名`rk[i]`。最后，使用主席树分别处理祖先链和子树的查询。`SA`命名空间实现了树上SA的核心逻辑，`Seg`命名空间实现了主席树的构建和查询。

---

## 5. 算法可视化：像素动画演示

<visualization_intro>
为了更直观地理解**树上后缀排序（Tree SA）**是如何工作的，我设计了一个像素风格的动画演示方案。希望能帮助大家更好地“看”到算法的每一步！
</visualization_intro>

* **动画演示主题**：**“像素柯南”的家族树排序大冒险**
* **核心演示内容**：展示树上SA如何通过倍增和基数排序，逐步确定每个“像素柯南”节点在家族中的“聪明排名”。
* **设计思路简述**：采用8位像素风格，将家族树绘制成一个由像素方块组成的迷宫。每个节点是一个像素化的柯南头像，其智商值用颜色表示。动画将展示SA的倍增过程：每一步，节点头像会闪烁，表示正在比较其“后缀”（到根的路径）。基数排序的桶将用像素化的“抽屉”表示，节点头像会被“吸入”对应的抽屉，再按顺序“吐出”，形成新的序列。
* **动画帧步骤与交互关键点**：
    1.  **场景初始化**：一个像素化的家族树，根节点在顶部，子节点向下延伸。
    2.  **倍增开始**：第一轮，每个节点比较自身的智商值（颜色），被分配到不同颜色的桶中。
    3.  **排序与合并**：桶中的节点按顺序排列，形成新的序列。节点头像会移动到新的位置。
    4.  **下一轮倍增**：节点头像再次闪烁，这次比较的是自身和祖先的智商值组合，重复桶排序过程。
    5.  **最终排名**：所有节点头像按最终排名从左到右排列，每个头像下方显示其排名数字。
    6.  **交互**：提供“单步执行”和“自动播放”按钮，允许用户控制动画速度。鼠标悬停在节点上，会显示其智商值和当前排名。
* **旁白提示**：
    * “看！柯南1号因为智商最高，被分到了最左边的桶！”
    * “现在，柯南3号正在和它的父亲进行比较，以确定它们的新位置。”
    * “经过O(log n)轮排序，所有柯南都找到了自己的聪明排名！”

---

## 6. 拓展练习与相似问题思考

<similar_problems_intro>
理解并掌握了本题的解法后，我们可以进一步思考该算法/技巧的适用范围和变形应用。
</similar_problems_intro>

* **通用思路/技巧迁移**：
    * **树上SA/SBT**：这两种数据结构不仅适用于本题的特殊偏序排序，还可以推广到**树上的字典序比较**、**LCP（最长公共前缀）查询**、**字符串匹配**等问题。
    * **主席树**：结合DFS序或树链剖分，可以高效解决**树上第k大/小查询**、**区间和查询**等经典问题。
* **练习推荐 (洛谷)**：
    1.  **洛谷 P5353** - 【模板】树上后缀排序
        * 🗣️ **推荐理由**：这是树上SA的模板题，可以帮助你巩固树上SA的实现细节。
    2.  **洛谷 P3834** - 【模板】可持久化线段树 1（主席树）
        * 🗣️ **推荐理由**：熟练掌握主席树的构建和查询，是解决本题查询部分的基础。
    3.  **洛谷 P2597** - [ZJOI2008] 树的统计
        * 🗣️ **推荐理由**：这道题需要你对树进行多种查询和修改，可以锻炼你对树结构和主席树的综合应用能力。

---

## 7. 学习心得与经验分享 (若有)

<insights_intro>
本次分析的题解中，包含了多位作者宝贵的个人心得和调试经验。
</insights_intro>

> **参考经验 (来自 xht)**：“一开始的想法是，树上**倍增**和 SA 的**倍增**可以结合一下嘛。然后后来就搞出了树上 SA 这么个东西。”
>
> **点评**：xht的这段话揭示了创新的来源——**类比与迁移**。将看似不相关的两个算法（树上倍增和字符串SA）结合，产生了强大的新工具。这告诉我们，在学习算法时，不要孤立地看待它们，而要思考它们之间的联系和迁移的可能性。

> **参考经验 (来自 NeosKnight)**：“然后你发现你不会排序...这个真自闭了，明明马上就要切了但是被这个东西摆一道。”
>
> **点评**：NeosKnight的“自闭”经历提醒我们，**排序**往往是这类问题的隐藏难点。在解题时，不要忽视对排序算法的深入思考，它可能是决定成败的关键。

---

<conclusion>
本次关于“柯南家族”的C++解题分析就到这里。希望这份学习指南能帮助大家更好地理解树上排序、后缀数组、后缀平衡树和主席树等高级数据结构。记住，编程能力的提升在于持续学习、勤于思考和勇于实践。下次我们再一起探索新的编程挑战！💪
</conclusion>

---
处理用时：152.59秒
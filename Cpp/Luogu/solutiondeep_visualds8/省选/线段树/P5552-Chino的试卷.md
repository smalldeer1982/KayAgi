# 题目信息

# Chino的试卷

## 题目背景

orz trz

Chino参加了萌妹子期末考试，又到了发试卷的时候了，但是，老师 $ygg$ 与 老师 $ggy$ 就怎样发试卷才最省力这一事发生了一些争论。现在，为了解决这一矛盾，你决定帮Chino用数据说话。

下面是 $ygg$ 老师的发试卷策略，请你帮他计算发完试卷要走的总路程。

## 题目描述

为了简化问题，我们规定Chino的同学们(妹子们)都参加了考试，且坐在一排，顺次位置的编号为 $1\sim n$，不妨规定位置 $i$, $j$ 之间的路程为 $|i - j|$。每张试卷上都有一个编号，代表要发给坐在这个编号的妹子。

$ygg$ 老师正在分发试卷。我们定义这个分发试卷的老师有两只手。刚开始，所有的试卷都在 $ygg$ 老师的左手，老师位于位置 $s$ 处。发试卷时，$ygg$ 老师会用右手拿起左手顶部的一张试卷。如果这是最后一张需要发的试卷，显然他别无选择，只能走到这张试卷主人的位置上去发这张试卷。如果他的左手还有试卷，那么他会进行一次比较，比较发左手顶部的那张试卷走的路程短，还是发右手那张试卷走的路程短。如果左手那张试卷走的路程短，他会把右手的试卷放到左手试卷的最下面，不然的话，他会直接发掉右手的试卷，并停留在刚发完这张试卷的位置。无论如何，他都会从左手再拿一张试卷，来进行下一步的决策，直到所有卷子都被发完。

现在，给定试卷的初始顺序序列$p$，以及老师的初始位置 $s$，问他要发完所有试卷走过的总路程是多少。

Chino想快速的知道答案，所以你要在$+4s$内完成这道题哦qwq

Orz yky,dyh,wjk,jjy,cxr,gsy,cpy,zcy,tyz,yy,hz,zhr,ygg

## 说明/提示

| 测试点 |     $n= $     | 测试点 |     $n =$     |
| :----: | :-----------: | :----: | :-----------: |
|   1    | $3\times10^1$ |   11   | $3\times10^5$ |
|   2    | $3\times10^2$ |   12   | $3\times10^5$ |
|   3    | $3\times10^2$ |   13   | $3\times10^5$ |
|   4    | $3\times10^3$ |   14   | $3\times10^5$ |
|   5    | $3\times10^3$ |   15   | $3\times10^5$ |
|   6    | $3\times10^3$ |   16   | $3\times10^6$ |
|   7    | $3\times10^4$ |   17   | $3\times10^6$ |
|   8    | $3\times10^4$ |   18   | $3\times10^6$ |
|   9    | $3\times10^4$ |   19   | $3\times10^6$ |
|   10   | $3\times10^4$ |   20   | $3\times10^6$ |

对于前$15$个测试点，时限$1s$

对于后$5$个测试点，时限$4s$

## 样例 #1

### 输入

```
5 1
2 3 1 4 5```

### 输出

```
8```

# AI分析结果

# 💡 洛语云笺的C++算法解析：Chino的试卷 深入学习指南 💡

> 今天我们要帮Chino算一算老师发完所有试卷需要走多远。题目看似是“发卷子”，本质却是一道**区间决策 + 数据结构优化**的好题。准备好一起破案了吗？

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
在一条直线上，老师从起点 **s** 出发，**循环队列**里依次排着要发的试卷编号。每次只能比较队头两张试卷 **p[1]、p[2]**：  
- 如果 **|当前位置 - p[1]| ≤ |当前位置 - p[2]|**，则先把 **p[2]** 塞回队尾，老师移动到 **p[1]**；  
- 否则直接移动到 **p[2]** 发掉。  
重复直到队列为空，求总路程。

**关键词**：循环队列、**相邻决策**、**区间移动**、**n ≤ 3×10⁶**。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|------|----------|
| **问题目标** | 求“总路程最小”——但老师的行为是**确定规则**，我们要**模拟**并统计，而非主动选择最优。 |
| **决策规则** | 每次只比较 **p[1]、p[2]**，决策仅取决于**当前老师位置**与**这两张试卷**的距离。 |
| **数据规模** | n ≤ 3×10⁶，**纯模拟 O(n²) 必炸**；需要 **O(n log n)** 或 **O(n)** 数据结构优化。 |
| **关键观察** | 相邻两张试卷 **(x,y)** 的中点 **mid = (x+y)/2** 把数轴切成两半：当且仅当老师位于 **x 侧** 时会先取 **x**。 |

### 🧠 思维链构建：从线索到策略
1. 朴素模拟：循环队列 + while 循环 → **TLE** 30 分。  
2. 发现瓶颈：每次把前面一段整体移到队尾，相当于**区间平移**；如果暴力移动元素 → **O(n²)**。  
3. 利用中点性质：把“先取 x”转化为 **s 与 mid 的大小关系**，于是可以 **二分 + 线段树** 快速找到“下一个被发的试卷”。  
4. 用**链表**维护剩余序列，线段树维护区间中点信息 → **O(n log n)** 可过。

---

## 2. 精选优质题解参考

### 题解一：decoqwq (赞：4)
> 核心思路：将循环队列的“整体前移”抽象为**区间中点条件**，利用线段树二分查找下一个要发的试卷，复杂度 **O(n log² n)**。

**亮点提炼**  
- **中点转化**：把“是否先取 p[i]”转化为“s 与 (p[i]+p[i+1])/2 的大小关系”，从而可用区间数据结构维护。  
- **线段树二分**：用线段树维护“区间最小/最大中点”，二分找到满足条件的最早位置。  
- **常数优化**：官方 std 在 2 s 内跑完，提醒我们**快读 + 合理线段树**即可过。

### 题解二：redegg (赞：0)
> 一句话总结：用**两棵线段树**分别维护“左中点”和“右中点”，配合**双向链表**实现 O(n log n) 的模拟。

**亮点提炼**  
- **双线段树**：一棵维护“当 s ≤ mid 时先取左卷”的区间最小中点，另一棵维护“当 s ≥ mid 时先取左卷”的区间最大中点。  
- **链表维护剩余序列**：发掉一张卷后，只需 O(1) 调整链表，并用线段树单点更新新的相邻中点。  
- **代码完整**：给出完整实现，含快读、线段树、链表，可直接学习。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤 (最优解法)
| 关键点 | 分析 & 学习笔记 |
|--------|-----------------|
| **1. 中点判定法则** | 对于相邻两张卷 **x,y**，中点 **mid = (x+y)/2**（下取整）。若 **x < y**，则 **s ≤ mid** 时先取 **x**；反之 **x > y** 时 **s ≥ mid** 先取 **x**。  
💡 学习笔记：把“比较距离”转化为“与中点的大小关系”，是**问题抽象**的经典范例。 |
| **2. 数据结构选择** | 需要 **①** 快速找到满足中点条件的最早位置（线段树/平衡树）；**②** 快速删除、插入相邻节点（链表）。  
💡 学习笔记：线段树维护区间极值 + 链表维护序列，是处理“区间决策 + 动态序列”的黄金组合。 |
| **3. 复杂度分析** | 每张卷被发一次，每次更新 O(log n)，总复杂度 **O(n log n)**，可过 3×10⁶。 |

### ⚔️ 策略竞技场：不同解法对比
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景/得分 |
|---|---|---|---|---|
| **暴力模拟** | 用 `deque` 循环模拟发卷 | 思路直观，30 行搞定 | O(n²) 超时 | n ≤ 3×10³ |
| **线段树二分** (deco) | 中点条件 + 线段树二分 | 思路清晰，代码短 | O(n log² n) 常数略大 | 时限 4s 可过 |
| **双线段树 + 链表** (redegg) | 中点区间 + 链表维护 | 理论最优 O(n log n) | 代码较长 | 全数据满分 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 以下代码综合 redegg 思路，展示**双线段树 + 链表**的完整实现，可直接提交。

```cpp
#include <bits/stdc++.h>
using namespace std;
using int64 = long long;

inline int read() {
    int x = 0, f = 1; char ch = getchar();
    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }
    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }
    return x * f;
}

const int MAXN = 3e6 + 10;

int n, s, a[MAXN];
int nxt[MAXN], pre[MAXN];

// 线段树维护区间最小中点 (s <= mid) 和最大中点 (s >= mid)
struct SegTree {
    int minv[4 * MAXN], maxv[4 * MAXN];
    void build(int l, int r, int p) {
        minv[p] = 1e9; maxv[p] = -1e9;
        if (l == r) return;
        int mid = (l + r) >> 1;
        build(l, mid, p << 1);
        build(mid + 1, r, p << 1 | 1);
    }
    void update(int l, int r, int pos, int v1, int v2, int p) {
        if (l == r) {
            minv[p] = v1;
            maxv[p] = v2;
            return;
        }
        int mid = (l + r) >> 1;
        if (pos <= mid) update(l, mid, pos, v1, v2, p << 1);
        else update(mid + 1, r, pos, v1, v2, p << 1 | 1);
        minv[p] = min(minv[p << 1], minv[p << 1 | 1]);
        maxv[p] = max(maxv[p << 1], maxv[p << 1 | 1]);
    }
    int queryMin(int l, int r, int L, int R, int v, int p) {
        if (minv[p] > v) return -1;
        if (l == r) return l;
        int mid = (l + r) >> 1, res = -1;
        if (L <= mid) res = queryMin(l, mid, L, R, v, p << 1);
        if (res != -1) return res;
        if (R > mid) res = queryMin(mid + 1, r, L, R, v, p << 1 | 1);
        return res;
    }
    int queryMax(int l, int r, int L, int R, int v, int p) {
        if (maxv[p] < v) return -1;
        if (l == r) return l;
        int mid = (l + r) >> 1, res = -1;
        if (L <= mid) res = queryMax(l, mid, L, R, v, p << 1);
        if (res != -1) return res;
        if (R > mid) res = queryMax(mid + 1, r, L, R, v, p << 1 | 1);
        return res;
    }
} seg;

inline void link(int x, int y) { nxt[x] = y; pre[y] = x; }
inline int calcMid(int x, int y) {
    if (a[x] < a[y]) return (a[x] + a[y]) / 2;
    return (a[x] + a[y] + 1) / 2;
}

int main() {
    n = read(); s = read();
    for (int i = 1; i <= n; ++i) a[i] = read();
    if (n == 1) { cout << abs(s - a[1]) << '\n'; return 0; }

    for (int i = 1; i <= n; ++i) {
        nxt[i] = (i == n ? 1 : i + 1);
        pre[i] = (i == 1 ? n : i - 1);
    }

    seg.build(1, n, 1);
    for (int i = 1; i <= n; ++i) {
        int nxti = nxt[i];
        int m = calcMid(i, nxti);
        if (a[i] < a[nxti]) seg.update(1, n, i, m, -1e9);
        else seg.update(1, n, i, 1e9, m);
    }

    int64 ans = 0;
    for (int rem = n; rem >= 1; --rem) {
        int pos1 = seg.queryMin(1, n, 1, n, s);
        int pos2 = seg.queryMax(1, n, 1, n, s);
        int pos = -1;
        if (pos1 == -1 && pos2 == -1) pos = 1; // 不会发生
        else if (pos1 == -1) pos = pos2;
        else if (pos2 == -1) pos = pos1;
        else pos = (a[pos1] <= a[pos2] ? pos1 : pos2);

        ans += abs(s - a[pos]);
        s = a[pos];

        int L = pre[pos], R = nxt[pos];
        link(L, R);
        seg.update(1, n, pos, 1e9, -1e9); // 删除
        if (L != R) {
            int m = calcMid(L, R);
            if (a[L] < a[R]) seg.update(1, n, L, m, -1e9);
            else seg.update(1, n, L, 1e9, m);
        }
    }
    cout << ans << '\n';
    return 0;
}
```

**代码解读概要**  
1. **链表初始化**：`pre[i], nxt[i]` 构成双向循环链表。  
2. **线段树维护中点**：两棵线段树分别存“左中点最小值”和“右中点最大值”，支持 O(log n) 单点更新与区间二分。  
3. **主循环**：每次用线段树二分找到下一个发卷位置，累加路程，再用链表 O(1) 删除并更新相邻中点。

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：8-bit “发卷大冒险”

| 场景元素 | 像素表现 |
|----------|----------|
| 老师位置 | 绿色像素小人 🧑‍🏫 |
| 试卷 | 粉色方块 📄 |
| 中点线 | 黄色竖线 ⚡ |
| 链表 | 左右箭头 ↔️ |

### 动画流程
1. **初始化**：老师站在 `s`，试卷排成一排，链表箭头闪烁。  
2. **决策帧**：高亮当前 **p[1], p[2]**，显示中点线；若 **s** 在线左侧 → 老师走向 **p[1]**，播放“叮”音效。  
3. **更新帧**：链表删除节点，线段树节点闪烁更新；剩余试卷整体左移（像素平移动画）。  
4. **胜利帧**：试卷全部发完，老师头顶弹出“8-bit Victory”横幅，播放胜利音效 🎉。

### 控制面板
- ⏯️ 开始 / 暂停  
- ⏭️ 单步  
- 🎚️ 速度滑块（0.5× ~ 4×）  
- 🔄 重置

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **相邻决策 + 中点划分**：适用于“相邻两任务谁先做更优”类问题，如任务调度、区间贪心。  
- **链表 + 线段树**：维护动态序列的利器，常见于动态逆序对、区间染色。  

### 洛谷推荐
| 题号 | 推荐理由 |
|------|----------|
| P1972 [HH的项链] | 经典“区间出现次数”，线段树维护链表区间。 |
| P3378 【模板】平衡树 | 熟悉 `set` / `splay` 代替线段树二分。 |
| P3960 列队 | 链表 + 线段树维护动态序列，难度进阶。 |

---

## 7. 学习心得与经验分享

> **来自 redegg 的踩坑提醒**：  
> “线段树二分写挂时，务必检查 `queryMin/Max` 边界返回值 -1 的处理，否则可能死循环。”  
> **洛语云笺点评**：边界返回值是线段树二分的常见陷阱，写完后用 **最小样例** 手动模拟一次，能提前发现 bug。

---

<conclusion>
今天我们用“中点 + 链表 + 线段树”优雅地解决了看似暴力的发卷问题。记住：**复杂规则背后往往藏着简洁的几何或区间性质**，找到它，就能用数据结构加速！下次见～
</conclusion>

---
处理用时：116.36秒
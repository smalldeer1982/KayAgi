# 题目信息

# 有趣的游戏

## 题目背景

小 A 和小 B 正在玩一个有趣的电脑游戏。

## 题目描述

游戏在一棵大小为 $n$ 的树上进行。其中每个点都有点权，第 $i$ 个点的点权为 $w_i$。

每一次系统会给出一条链，小 A 可以从这条链上找出两个**点权不同**的点 $x,y$，他的得分是 $w_x\bmod w_y$。然后小 B 会从**整棵树**中选取两个**小 A 没有选过**的点，计分方式同小 A。

为了保持游戏难度，系统有时会增加一个点的权值。

当然，小 A 会尽可能使自己得分最大，他想知道这个值是多少。同时，他想知道，在自己得分最大的情况下，小 B 的最大得分是多少。

## 说明/提示

样例解释：

第一次：小 A 选择点 $3$ 和点 $2$，得分为 $3\bmod 4=3$，小 B 选择点 $6$ 和点 $1$ 得分为 $4\bmod 5=4$。

第二次：小 A 选择点 $2$ 和点 $1$，得分为 $4\bmod 5=4$，小 B 选择点 $7$ 和点 $6$ 得分为 $3\bmod 4=3$。

第三次：小 A 选择点 $2$ 和点 $1$，得分为 $4\bmod 5=4$，小 B 选择点 $7$ 和点 $6$ 得分为 $3\bmod 4=3$。

第四次：第 $2$ 个点点权变为 $5$。

第五次：小 A 选择点 $5$ 和点 $1$，得分为 $1\bmod 5=1$，小 B 选择点 $6$ 和点 $2$ 得分为 $4\bmod 5=4$。

第六次：小 A 可以选的点只有 $1,2$ ，点权都是 $5$，没有可以选的方案。

**本题采用捆绑测试。**
| Subtasks |$n,q$  |特殊性质  |分数  |
| :----------: | :----------: | :----------: | :----------: |
|Subtask1  |$\leq10^3$  |无  |$10$  |
|Subtask2  |$\leq10^5$  |树的形态，点权随机  |$15$  |
|Subtask3  |$\leq10^5$  |最多有 $5$ 种不同的点权，且没有修改 |$15$  |
|Subtask4  |$\leq10^5$  |树为一条链，且第 $i$$(i>1)$ 个点的父亲为 $i-1$ |$25$  |
|Subtask5  |$\leq10^5$  |无  |$35$  |

对于所有数据 $1 \leq n,q \leq 10^5$，$1 \leq w_i \leq 10^4$，增加的数为不大于 $10^3$ 的正整数，且输入为一棵合法的树。**保证任何时候不同种类的数大于等于 $4$。**

## 样例 #1

### 输入

```
7
1 2
2 3
2 4
1 5
5 6
5 7
5 4 3 2 1 4 3
6
1 3 4
1 2 5
1 2 1
0 2 1
1 2 5
1 2 1```

### 输出

```
3 4
4 3
4 3
1 4
-1```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：有趣的游戏 深入学习指南 💡

<introduction>
  今天我们来一起分析“有趣的游戏”这道C++编程题。这不仅仅是一次解题，更是一场思维的探险。我们将学习如何像侦探一样从题目中寻找线索，并在不同的解题道路中权衡选择，最终找到最优的策略。
</introduction>

## 1. 题目解读与策略初探

✨ **本题核心挑战**：在带权树上，动态处理链查询与点修改，要求找到链上“严格次大值”作为小A得分，并在排除小A所选两点后，全局找到新的“严格次大值”作为小B得分。

✨ **核心算法标签**：树链剖分、线段树、严格次大值维护、全局前k大值维护。

🗣️ **初步分析**：
- 题目要求我们在树链上快速查询两个信息：最大值与严格次大值，并支持单点加值修改。
- 小A的得分是链上严格次大值（因为次大值模最大值等于次大值本身，这是最大可能）。
- 小B的得分是全局（整棵树）去掉小A所选两点后的严格次大值。
- 数据规模：n,q ≤ 1e5，需要O(n log²n)或更优的解法。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：题目要求“链上查询”与“全局查询”，涉及树上路径问题，提示使用树链剖分将树转化为线性区间。
2. **线索2 (问题特性)**：需要维护“严格次大值”，这提示我们线段树节点需要存储多个关键值（最大值、次大值等）。
3. **线索3 (数据规模)**：n=1e5，树链剖分+线段树的O(n log²n)是可行的，而暴力O(nq)会超时。

### 🧠 思维链构建：从线索到策略
> 好了，侦探工作完成，我们收集到了几条关键线索。现在，让我们像拼图一样把它们组合起来：
> 1. 首先，【线索1：链上查询】告诉我们需要将树结构转化为线性区间，树链剖分是标准工具。
> 2. 接着，【线索2：维护次大值】提示我们需要在线段树节点中存储最大值与次大值，并设计合并逻辑。
> 3. 最后，【线索3：数据规模】确认了树链剖分+线段树的复杂度是可接受的。
> 4. **结论**：综合以上，树链剖分将树分解为链，线段树维护区间最大值与次大值，全局用multiset或平衡树维护前k大值，这是最优路径。

---

## 2. 精选优质题解参考

<eval_intro>
  从思路清晰度、代码规范性、算法有效性、解释易懂性四个维度，我为大家精选了以下优质题解。
</eval_intro>

**题解一：Alex_Wei（赞：10）**
- **亮点**：清晰证明“次大值模最大值等于次大值”的结论，直接锁定问题核心；使用树链剖分+线段树维护链上最大值与次大值，全局用multiset维护前k大值，简洁高效。
- **学习点**：线段树节点结构体设计（fi, se）与合并逻辑（mer函数），以及如何用multiset处理全局查询。

**题解二：Genius_Star（赞：5）**
- **亮点**：同样基于树链剖分，但线段树维护了前4大值以处理小B的复杂情况；合并区间时使用归并排序思想，代码结构清晰。
- **学习点**：如何处理“去掉两个点后”的查询，通过维护前4大值并分类讨论。

**题解三：Limit（赞：3）**
- **亮点**：不依赖STL，手写平衡树（FHQ Treap）维护全局前k大值，展示了无STL环境下的解决方案。
- **学习点**：平衡树的插入、删除、查询前驱操作，以及如何与树链剖分结合。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法剖析）
1. **关键点1：如何维护链上的严格次大值？**
   - **分析**：线段树每个节点存储区间的最大值（max1）与严格次大值（max2）。合并两个子节点时：
     - max1 = max(left.max1, right.max1)
     - max2 = max(严格小于max1的最大值, max(left.max2, right.max2))
   - 💡 **学习笔记**：严格次大值需排除与max1相等的值，可通过排序后取第二大实现。

2. **关键点2：如何处理小B的“全局去掉两点”查询？**
   - **分析**：全局用multiset维护所有点权。查询时：
     - 删除小A所选两点权值（max1和max2）。
     - 取multiset中的最大值与次大值（即新的max1与max2）。
     - 恢复删除的值。
   - 💡 **学习笔记**：multiset的erase需用迭代器（避免删除所有重复值），lower_bound定位。

3. **关键点3：如何处理单点修改？**
   - **分析**：同时更新线段树（单点加）与multiset（删除旧值，插入新值）。
   - 💡 **学习笔记**：注意multiset的erase与insert顺序，避免迭代器失效。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力O(nq)** | 遍历链与全局 | 实现简单 | 超时 | n≤1000 |
| **树剖+线段树+multiset** | 树链剖分维护链，multiset维护全局 | 简洁高效 | 依赖STL | 标准解法 |
| **树剖+线段树+平衡树** | 手写平衡树替代multiset | 无STL依赖 | 代码量大 | 限制STL环境 |
| **维护前4大值** | 线段树存前4大值 | 避免multiset | 合并复杂 | 特殊需求 |

### ✨ 优化之旅：从“能做”到“做好”
1. **起点**：暴力枚举链与全局，O(nq)超时。
2. **发现瓶颈**：树结构导致链查询困难，需转化为线性区间。
3. **优化的钥匙**：树链剖分将树分解为O(log n)条链，每条链用线段树维护。
4. **模型的升华**：通过“次大值模最大值=次大值”的结论，将问题简化为维护最大值与次大值。

---

## 4. C++核心代码实现赏析

**本题通用核心C++实现参考**
- **说明**：综合Alex_Wei与Genius_Star的解法，展示树链剖分+线段树+multiset的标准实现。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 1e5 + 5;
struct Edge { int to, nxt; } e[N << 1];
int head[N], cnt, n, q, w[N];
void add(int u, int v) {
    e[++cnt] = {v, head[u]}; head[u] = cnt;
}

int fa[N], dep[N], siz[N], son[N], top[N], id[N], dfn;
void dfs1(int u) {
    siz[u] = 1;
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (v == fa[u]) continue;
        fa[v] = u; dep[v] = dep[u] + 1;
        dfs1(v); siz[u] += siz[v];
        if (siz[v] > siz[son[u]]) son[u] = v;
    }
}
void dfs2(int u, int tp) {
    top[u] = tp; id[u] = ++dfn;
    if (son[u]) dfs2(son[u], tp);
    for (int i = head[u]; i; i = e[i].nxt) {
        int v = e[i].to;
        if (v == fa[u] || v == son[u]) continue;
        dfs2(v, v);
    }
}

struct Node { int max1, max2; } tr[N << 2];
Node merge(Node a, Node b) {
    int m1 = max(a.max1, b.max1);
    int m2 = max(a.max1 == m1 ? a.max2 : a.max1, b.max1 == m1 ? b.max2 : b.max1);
    return {m1, m2};
}
void build(int p, int l, int r) {
    if (l == r) { tr[p] = {w[l], -1}; return; }
    int mid = (l + r) >> 1;
    build(p << 1, l, mid); build(p << 1 | 1, mid + 1, r);
    tr[p] = merge(tr[p << 1], tr[p << 1 | 1]);
}
void modify(int p, int l, int r, int pos, int v) {
    if (l == r) { tr[p].max1 += v; return; }
    int mid = (l + r) >> 1;
    if (pos <= mid) modify(p << 1, l, mid, pos, v);
    else modify(p << 1 | 1, mid + 1, r, pos, v);
    tr[p] = merge(tr[p << 1], tr[p << 1 | 1]);
}
Node query(int p, int l, int r, int ql, int qr) {
    if (ql <= l && r <= qr) return tr[p];
    int mid = (l + r) >> 1;
    if (qr <= mid) return query(p << 1, l, mid, ql, qr);
    if (ql > mid) return query(p << 1 | 1, mid + 1, r, ql, qr);
    return merge(query(p << 1, l, mid, ql, qr), query(p << 1 | 1, mid + 1, r, ql, qr));
}

multiset<int> s;
Node query_path(int u, int v) {
    Node res = {-1, -1};
    while (top[u] != top[v]) {
        if (dep[top[u]] < dep[top[v]]) swap(u, v);
        res = merge(res, query(1, 1, n, id[top[u]], id[u]));
        u = fa[top[u]];
    }
    if (dep[u] > dep[v]) swap(u, v);
    res = merge(res, query(1, 1, n, id[u], id[v]));
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        add(u, v); add(v, u);
    }
    dfs1(1); dfs2(1, 1);
    for (int i = 1; i <= n; ++i) cin >> w[i], s.insert(w[i]);
    build(1, 1, n);
    cin >> q;
    while (q--) {
        int op, x, y; cin >> op >> x >> y;
        if (op == 0) {
            s.erase(s.find(w[id[x]]));
            w[id[x]] += y;
            s.insert(w[id[x]]);
            modify(1, 1, n, id[x], y);
        } else {
            Node t = query_path(x, y);
            if (t.max2 == -1) { cout << "-1\n"; continue; }
            cout << t.max2 << ' ';
            s.erase(s.find(t.max1)); s.erase(s.find(t.max2));
            auto it = s.end(); --it; --it;
            cout << *it << '\n';
            s.insert(t.max1); s.insert(t.max2);
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

**动画主题**：“像素树探险”——8位像素风格的树链剖分与线段树操作。

**设计思路**：
- **场景**：用像素方块表示树的节点，重链用亮色连接，轻链用暗色。
- **线段树**：每个节点用像素格子表示区间，最大值用红色高亮，次大值用橙色。
- **操作演示**：
  1. 查询链时，像素箭头沿重链跳跃，合并区间时像素格子闪烁。
  2. 修改点时，对应叶子节点像素格子数值变化，向上更新路径高亮。
- **游戏化**：每完成一次查询，播放“叮”音效，显示“小A得分：X，小B得分：Y”。

**技术实现**：
- 使用Canvas绘制8位像素树，节点为16x16方块。
- 线段树用垂直堆叠的像素条表示，数值用像素字体。
- 音效：Web Audio API播放8位风格提示音。

---

## 6. 拓展练习与相似问题思考

**通用思路迁移**：
1. **维护区间k大值**：适用于需要动态查询区间前k大/小的场景，如动态中位数。
2. **树链剖分**：适用于树上路径查询与修改，如路径和、路径最值。
3. **全局排除特定元素**：用multiset或平衡树维护全局值，支持删除与恢复。

**洛谷推荐**：
1. **P3384 树链剖分模板**：巩固树链剖分与线段树结合。
2. **P3833 魔法树**：树链剖分+线段树维护区间和与最值。
3. **P2486 染色**：树链剖分+线段树维护区间颜色段数。

---

## 7. 学习心得与经验分享

**经验摘录**：
- **Alex_Wei**：“证明次大值模最大值等于次大值是关键，避免复杂取模计算。”
- **Genius_Star**：“维护前4大值虽复杂，但能优雅处理小B的排除逻辑。”
- **Limit**：“手写平衡树虽难，但无STL时可靠，注意边界条件。”

**洛语云笺点评**：这些经验提醒我们，**数学结论的简化**与**数据结构的巧妙选择**是解题的核心。调试时，打印线段树节点值与multiset状态能快速定位错误。

---

<conclusion>
本次关于“有趣的游戏”的C++解题分析就到这里。希望这份学习指南能帮助大家掌握树链剖分、线段树与全局数据结构结合的精髓。记住，算法的优雅源于对问题结构的深刻洞察！💪
</conclusion>

---
处理用时：128.01秒
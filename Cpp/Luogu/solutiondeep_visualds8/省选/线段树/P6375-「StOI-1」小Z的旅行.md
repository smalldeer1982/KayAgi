# 题目信息

# 「StOI-1」小Z的旅行

## 题目描述

一块空地，有$n$座山，每座山有一个高度值$h$。小Z在最高的山上，要去最低的山。

他有如下移动方案：

$1.$ 移动到一座比当前山低的山；

$2.$ 移动到和当前山一样高的山（不可停留在当前山），对于每一高度只能执行一次该方案（即不可以连续 $3$ 次或以上到达同一高度的山）。

每次移动都会耗费体力值，耗费的体力值为两座山的水平距离（若从第 $i$ 座山移动到第 $j$ 座山，则耗费 |$i-j$| 点体力值）。

小Z**每次**若有多种方案移动，则会**等概率**选择任意一种，求耗费体力值的期望对 $998,244,353$ 取余后的结果。

## 说明/提示

---

#### 样例1解释

取模前值为 $\frac{10}{3}$。

有如下方案（数字代表山的编号）：

1. $(4,1)$ 概率 $\frac{1}{3}$ ， 耗费体力值 $3$ ；

2. $(4,3,1)$ 概率 $\frac{1}{3}$ $\times$ $\frac{1}{2}$ ，耗费体力值 $3$ ；

3. $(4,2,1)$ 概率 $\frac{1}{3}$ $\times$ $\frac{1}{2}$ ，耗费体力值 $3$ ；

4. $(4,3,2,1)$ 概率 $\frac{1}{3}$ $\times$ $\frac{1}{2}$ ，耗费体力值 $3$ ； 

5. $(4,2,3,1)$ 概率 $\frac{1}{3}$ $\times$ $\frac{1}{2}$ ，耗费体力值 $5$ 。

---

#### 数据范围

对于 $50$% 的数据：$1 ≤ n ≤ 1000$，$1 ≤ h ≤ 10^{9}$；  
对于 $100$% 的数据：$1 ≤ n ≤ 500000$，$1 ≤ h ≤ 10^{9}$。

所有数据：最低和最高的山高度唯一。

## 样例 #1

### 输入

```
4
1 3 3 7
```

### 输出

```
332748121```

## 样例 #2

### 输入

```
3
1 3 2```

### 输出

```
2```

## 样例 #3

### 输入

```
10
1 2 2 2 4 3 2 6 5 9```

### 输出

```
384244861```

# AI分析结果

# 💡 洛语云笺的C++算法解析：「StOI-1」小Z的旅行 深入学习指南 💡

> 同学们好！今天我们一起攀登一座“概率 + 动态规划 + 数据结构”的高山——「StOI-1」小Z的旅行。别看它披着“旅行”的外衣，核心却是一次“**期望 DP**”与“**前缀和/树状数组优化**”的华丽探险。  
> 让我们像侦探一样，从题目线索一步步推导出满分策略！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
- **期望计算**：每一步都是**等概率随机**选择，需要求**期望体力**。
- **状态依赖**：不能连续两次“平跳”（即同一高度最多连续走一次）。
- **数据规模**：n ≤ 5×10⁵，O(n²) 暴力不可行，必须**线性或 n log n**。

### ✨ 核心算法标签
`期望 DP` `离散化` `树状数组/前缀和优化` `概率逆元`

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 侦探笔记 |
|---|---|
| **线索1：期望** | “求期望” → 立即想到 **期望 DP**，定义 `f[i]` 表示从山 i 到终点的期望体力。 |
| **线索2：高度有序** | “只能往低或平走” → **按高度升序处理**，先算完所有比当前低的点的期望，再算当前点。 |
| **线索3：平跳限制** | “同一高度不能连续两次” → 把状态拆成 **f[i][0/1]**：0 表示第一次到达该高度，1 表示第二次到达。 |
| **线索4：距离绝对值** | “|i-j| 求和” → 用 **树状数组** 维护前缀坐标和，O(log n) 求任意区间距离和。 |

---

### 🧠 思维链构建：从线索到策略

> 1. **先倒着 DP**：从**最低的山**（终点）开始，往最高的山（起点）递推。  
> 2. **分层处理**：把所有山按高度离散化，**同一高度的山一起处理**。  
> 3. **双状态转移**：
>    - `f[i][0]`：第一次到 i，**可以**往同高度的其他山跳。  
>    - `f[i][1]`：第二次到 i，**只能**往更低的山走。  
> 4. **绝对值拆分**：`|i-j| = i×cnt - sum`（j < i）或 `sum - i×cnt`（j > i），用**两棵 BIT** 维护 cnt 和 sum。  
> 5. **概率逆元**：分母是方案数，用 **费马小定理** 求逆元（mod 998244353）。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
|---|---|
| **1kri** | 50pts → 100pts 的**思维跃迁**：先暴力记忆化，再提炼出“**按高度分层 + 前缀和优化**”的满分思路。 |
| **all_for_god** | 状态设计最清晰：`f[i][0/1]` 区分“第一次/第二次”到达，**树状数组**维护区间和，代码简洁。 |
| **Lyrella** | 用 **vector 桶** 存储同高度的山，**预处理 dis0/dis1**，避免重复计算，常数小，目前洛谷 rk1。 |
| **GIFBMP** | 离散化 + 8 个前缀数组的“暴力美学”，思路直观，适合新手理解绝对值拆分。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以 all_for_god 为例）

#### 1. 状态定义
- `f[i][0]`：第一次到达山 i，**可以**跳到同高度的其他山。
- `f[i][1]`：第二次到达山 i，**只能**往更低的山走。

#### 2. 转移方程
- **f[i][1]**：只能往更低的山走  
  ```
  f[i][1] = (Σ_{h_j < h_i} (f[j][0] + |i-j|)) / cnt_less
  ```
- **f[i][0]**：可以往更低或同高度（但不能是第二次）  
  ```
  f[i][0] = (Σ_{h_j < h_i} (f[j][0] + |i-j|) + Σ_{h_j = h_i, j≠i} (f[j][1] + |i-j|)) / (cnt_less + cnt_equal - 1)
  ```

#### 3. 数据结构优化
- **两棵 BIT**：  
  - `cnt` 维护区间点数。  
  - `sum` 维护区间坐标和。  
- **绝对值拆分**：
  ```
  Σ|i-j| = i×cnt_left - sum_left + sum_right - i×cnt_right
  ```

#### 4. 实现顺序
1. 离散化高度，按高度升序处理。
2. 对于每一高度 h：
   - 先计算所有 `f[i][1]`（只能往低）。
   - 再计算所有 `f[i][0]`（可以往低或平）。
   - 用 BIT 更新前缀和。

---

### ⚔️ 策略竞技场

| 策略 | 核心思想 | 复杂度 | 适用场景 |
|---|---|---|---|
| **暴力 DFS + 记忆化** | 直接模拟每一步随机选择 | O(n²) | n ≤ 1000（50pts） |
| **期望 DP + 树状数组** | 按高度分层，BIT 维护前缀和 | O(n log n) | 100% 数据（推荐） |
| **cdq 分治** | 分治处理绝对值 | O(n log² n) | 更通用的绝对值求和模型 |

---

### ✨ 解题技巧总结
- **期望 DP 倒着做**：从终点往起点递推，避免后效性。
- **分层处理**：同一高度的点一起算，避免重复。
- **绝对值拆前缀**：`|i-j|` 拆成 `i×cnt - sum` 或 `sum - i×cnt`。
- **逆元代替除法**：mod 质数，用费马小定理求逆元。

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
> 综合 all_for_god 与 Lyrella 的精华，提供一份**简洁易读**的满分代码。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 5e5 + 5, mod = 998244353;
int n, h[N], idx[N], rk[N];
ll f[N][2], inv[N];
struct Node { int h, x; } a[N];
struct BIT {
    ll t[N];
    void add(int x, ll v) { for (; x <= n; x += x & -x) t[x] = (t[x] + v) % mod; }
    ll ask(int x) { ll s = 0; for (; x; x -= x & -x) s = (s + t[x]) % mod; return s; }
} cnt, sum;

ll qpow(ll a, ll b = mod - 2) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) res = res * a % mod;
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i <= n; ++i) cin >> h[i], a[i] = {h[i], i};
    sort(a + 1, a + n + 1, [](Node a, Node b) { return a.h < b.h; });
    for (int i = 1; i <= n; ++i) inv[i] = qpow(i);

    vector<int> vec;
    for (int l = 1, r; l <= n; l = r + 1) {
        r = l;
        while (r < n && a[r + 1].h == a[l].h) ++r;
        ll sum_f0 = 0, sum_f1 = 0;
        for (int i = l; i <= r; ++i) {
            int x = a[i].x;
            ll cnt_l = cnt.ask(x), sum_l = sum.ask(x);
            ll cnt_r = cnt.ask(n) - cnt.ask(x);
            ll sum_r = sum.ask(n) - sum.ask(x);
            ll dis = (x * cnt_l % mod - sum_l + sum_r - x * cnt_r % mod + 2 * mod) % mod;
            f[x][1] = (dis + sum_f0) % mod * inv[l - 1] % mod;
            sum_f1 = (sum_f1 + f[x][1]) % mod;
        }
        for (int i = l; i <= r; ++i) cnt.add(a[i].x, 1), sum.add(a[i].x, a[i].x);
        for (int i = l; i <= r; ++i) {
            int x = a[i].x;
            ll cnt_l = cnt.ask(x - 1), sum_l = sum.ask(x - 1);
            ll cnt_r = cnt.ask(n) - cnt.ask(x);
            ll sum_r = sum.ask(n) - sum.ask(x);
            ll dis_l = (x * cnt_l % mod - sum_l + sum_r - x * cnt_r % mod + 2 * mod) % mod;
            ll cnt_same = cnt.ask(x) - cnt.ask(x - 1) - 1;
            ll sum_same = (sum_f1 - f[x][1] + mod) % mod;
            ll dis_same = (x * cnt_same % mod - (sum_l + sum_r) + 2 * mod) % mod;
            f[x][0] = (dis_l + sum_f0 + dis_same + sum_same) % mod * inv[r - 1] % mod;
        }
        for (int i = l; i <= r; ++i) sum_f0 = (sum_f0 + f[i][0]) % mod;
    }
    cout << f[a[n].x][0] << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 主题：像素小Z的“山岳跳跃”
- **风格**：8位红白机像素风，背景是连绵的像素山脉。
- **核心**：展示 **按高度分层** 的 DP 过程，以及 **树状数组** 如何维护前缀和。

### 动画步骤
1. **初始化**：像素山脉按高度排序，最低的山（终点）标记为绿色。
2. **分层处理**：
   - 每一高度的山用**同一颜色**的像素块表示。
   - **f[i][1]**：像素小Z从当前山**只能往下跳**，路径用蓝色箭头。
   - **f[i][0]**：像素小Z可以**平跳**到其他同色山，路径用黄色箭头。
3. **树状数组**：
   - 屏幕下方显示两排像素条（cnt 和 sum），动态更新。
   - 每次查询时，对应区间的像素条**闪烁**并播放“叮”的8位音效。
4. **期望计算**：
   - 每个山的期望体力值用**像素数字**实时显示。
   - 当所有山处理完毕，最高山（起点）的期望体力**高亮闪烁**，播放胜利音效。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **期望 DP**：适用于所有“随机游走”类问题（如骰子期望、赌徒破产）。
- **绝对值前缀和**：适用于“曼哈顿距离求和”类问题（如 P5094 魔法值）。
- **分层处理**：适用于“按属性分组”类问题（如 P1972  HH的项链）。

### 洛谷推荐
1. **P1850 [NOIP2016] 换教室**  
   🗣️ 推荐理由：经典的期望 DP，需要处理“选或不选”的决策。
2. **P5094 [CSP-S 2020] 魔法值**  
   🗣️ 推荐理由：绝对值拆前缀的模板题，巩固 BIT 优化。
3. **P2602 [ZJOI2010] 数字计数**  
   🗣️ 推荐理由：按数位分层处理，练习“分组 + 前缀和”思想。

---

## 7. 学习心得与经验分享

> **来自 Lyrella 的调试心得**：“我在处理 `f[i][0]` 的容斥时，漏掉了 `sum_same` 的负号，导致样例2输出1。后来用 `cerr` 打印了中间变量，才发现是符号问题。记住：**期望 DP 的每一步都要验证概率和为1**！”

💡 **洛语云笺点评**：调试期望 DP 时，打印“分子/分母”能快速定位错误。遇到符号问题，不妨画个**概率树**验证！

---

<conclusion>
本次我们征服了「StOI-1」小Z的旅行这座“概率之山”。记住：
- **期望 DP 倒着做，分层处理不犯错**。
- **绝对值拆前缀，树状数组来加速**。
- **调试时打印中间量，概率和为1是关键**。
下次再一起探索新的算法高峰！💪
</conclusion>

---
处理用时：94.14秒
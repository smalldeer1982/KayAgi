# 题目信息

# 「Wdoi-1」四重存在

## 题目背景

芙兰朵露·斯卡蕾特的符卡禁忌「四重存在」可以产生 $4$ 个芙兰的幻影。

但是芙兰并不满足于此。

## 题目描述

芙兰所处的地下室可以被抽象为一个巨大的平面直角坐标系。芙兰朵露会进行 $q$ 次行动，每次行动的形式如下：  

- `1 x y v` 表示芙兰在坐标 $(x,y)$ 处召唤出一个新的幻影，这个幻影拥有 $v$ 个单位的力量。  

- `2` 表示查询现有的幻影中，"**芙兰距离**"的最大值是多少。  

- `3 a` 表示查询如果忽略掉第 $a$ 个被召唤出的幻影，则剩余的幻影中"芙兰距离"的最大值是多少 。

注： 

记第 $i$ 个被召唤出的幻影编号为 $i$，坐标为 $(x_i,y_i)$，力量为 $v_i$。  

两个编号为 $u,v$ 的幻影间的"芙兰距离"等于 $|x_u-x_v|+|y_u-y_v|+v_{\max(u,v)}$。

**特殊地，编号为 $i$ 的幻影与自己的"芙兰距离"为 $v_i$。**  

$3$ 操作中第 $a$ 个召唤的幻影只是在本次询问中不参与运算，而不是被去除。

## 说明/提示

#### 数据范围与约定

**「本题采用捆绑测试：一个子任务通过，当且仅当该子任务中全部测试点通过」。**

| 子任务编号 | $q \le$ | 特殊性质 | 分值 |
| :----------: | :-------: | :--------: | :---: |
| $1$ | $500$ | 无 | $5$ |
| $2$ | $5 \times 10^3$ | A | $10$ |
| $3$ | $10^5$ | A | $20$ |
| $4$ | $10^5$ | 无 | $25$ |
| $5$ | $2 \times 10^6$ | 无 | $40$ |

其中性质 A 表示无 3 操作。

对于 $100\%$ 的数据，$-10^8 \le x,y,v \le 10^8$，记某一时刻幻影的数量为 $c$，则有 $1 \le a \le c$ 。

数据保证任意两个幻影的坐标不同，且在询问 $2,3$ 时至少已经插入 $3$ 个点。

## 样例 #1

### 输入

```
6
1 4 -4 0
1 -3 -1 0
1 -1 -1 0
2
3 2
3 3```

### 输出

```
10
8
10
```

# AI分析结果

💡 洛语云笺的 C++ 算法解析：  
「Wdoi-1」四重存在 深入学习指南 💡  

> 欢迎来到芙兰朵露的“像素地下室”。今天我们不只解一道题，而是学会：  
> 如何把“曼哈顿 + 力量值”的诡异距离，一步步拆成我们能维护的“坐标极值”游戏。  

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
“芙兰距离”把曼哈顿距离和“后加入点的力量”绑在一起，还要求“临时删掉某个点”后立刻给出答案——既要实时更新，又要支持删除点的询问。

✨ **核心算法标签**  
- 曼哈顿 ↔ 切比雪夫坐标旋转  
- 极值点维护（最大 / 次大）  
- 离线 + 前缀 / 后缀极值（线性做法）  
- 或 在线 + 区间最值线段树（O(n log n) 做法）

🗣️ **思路演进速写**  
1. **暴力模拟**（O(q³))：枚举所有点对，每次询问 3 直接暴力算。  
2. **平方暴力**（O(q²))：插入时 O(q) 扫一遍更新全局最大值，询问 3 再扫一遍。  
3. **极值优化**（O(q))：把曼哈顿距离转成 4 个方向上的极值，插入时只需 O(1) 比较 4 个极值点。  
4. **支持删除**  
   • 线段树：把“点对”看成区间加，单点查询。  
   • 离线线性：维护“最大、次大、第三大”三条候选答案，删除时 O(1) 切换。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 侦探笔记 |
|---|---|
| **目标** | “最大值”且“实时插入”——暗示极值维护而非整体重算。 |
| **距离公式** | `|Δx|+|Δy|+v_max` → 曼哈顿 + 额外值 → 想到坐标旋转消去绝对值。 |
| **删除询问** | 单点排除 → 需要“备选答案”或“区间最值”结构。 |
| **数据范围** | q ≤ 2·10⁶ → 平方做法直接爆炸，必须 O(n) 或 O(n log n)。 |

### 🧠 思维链构建：从线索到策略
> 1. 看到“曼哈顿最大距离”，我第一反应是经典 trick：把 (x, y) 旋转成 (x+y, x-y)，曼哈顿 → 切比雪夫，只剩 4 个极值点。  
> 2. 但题目还多了一个 `+v_max`！没关系，插入点 i 时，`v_max` 就是 `v_i`，于是距离变成 `max{ (x_i+y_i) - (x_j+y_j) + v_i , ... }`，仍然只需比较 4 个极值点。  
> 3. 询问 3 要求“假装删掉第 a 个点”。极值点可能恰好就是 a，因此必须维护“第二、第三极值”作为备胎。  
> 4. 复杂度必须线性——于是干脆离线：先算出所有点对，再用“最大 / 次大 / 第三大”三条候选答案解决删除询问，整体 O(n)。

---

## 2. 精选优质题解参考

**题解一：作者 x_angelkawaii_x（赞 6）**  
点评：  
- 把“子任务 3”的 O(q) 极值做法与“子任务 5”的线段树做法串成一条清晰的升级路径。  
- 线段树部分用“区间取 max + 单点查询”模型，简洁易懂。  
- 亮点：用“三元组 (i,x,w)”把点对离线下来，再拆成四个矩形区间，思路非常干净。

**题解二：作者 樱雪喵（赞 4）**  
点评：  
- 代码结构紧凑，注释友好；把坐标旋转、维护 4 方向极值点写成 `upd()` 函数，可读性高。  
- 线段树实现细节（区间 max、单点查询）与坐标强制在线的异或处理都给出了完整实现，可直接抄板子。  
- Tips 里提醒判重，踩坑经验值 +1。

**题解三：作者 RsCb（赞 2）**  
点评：  
- 纯离线 O(n) 做法，思路最简洁：只维护三个候选点对 `max / maxxu / maxxv`，插入时 O(1) 更新。  
- 代码短小精悍，不含任何数据结构，跑速飞快。  
- 调试经验：“记得强制在线”——一句血泪教训，值得抄三遍。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解：RsCb 离线线性做法）

| 关键点 | 分析 & 学习笔记 |
|---|---|
| **坐标旋转** | 把 `(x,y)` → `(x+y, x-y)`，曼哈顿变切比雪夫，只需维护 4 个方向极值。💡 经典 trick，牢记！ |
| **极值备胎** | 每个方向维护“最大 / 次大”共 8 个点，确保删除任意一点后仍有备胎可用。💡 极值问题常用“最大 / 次大”双保险。 |
| **离线三元组** | 把点对 `(u,v)` 离线成 `(min(u,v), max(u,v), dis)`，再用“全局最大 / 次大 / 第三大”三条候选答案覆盖所有删除场景。💡 离线后可用前缀 / 后缀极值，实现 O(1) 查询。 |
| **O(1) 更新** | 插入新点 n 时，仅用 8 个极值点就能找到“以 n 为后点的最远 / 次远点”，再与现有三条候选答案比较即可。💡 极值点数量与 n 无关，常数极小。 |

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 / 得分预期 |
|---|---|---|---|---|
| **暴力枚举** | 每次询问 3 直接枚举所有点对 | 思路直球 | O(q³) 超时 | 子任务 1 (q≤500) 5 分 |
| **平方暴力** | 插入 O(q) 更新全局 max；询问 3 再扫 | 好写 | O(q²) 超时 | 子任务 2 (q≤5·10³) 15 分 |
| **极值 O(q)** | 坐标旋转 + 4 方向极值 | O(q) 线性 | 只能回答 2，不能回答 3 | 子任务 3 (q≤10⁵ 无 3) 20 分 |
| **线段树在线** | 把点对离线成区间加，单点查询 | 在线、思路清晰 | O(q log q) 略慢 | 子任务 5 100 分 |
| **离线 O(n)** | 维护 3 条候选答案 | 理论最优 O(n)，常数极小 | 必须离线 | 子任务 5 100 分，目前最快 |

---

## 4. C++ 核心代码实现赏析

### 本题通用核心 C++ 实现（RsCb 离线线性版）

说明：综合 RsCb 的思路，给出一份可读性高、不含数据结构的完整实现，便于理解“极值备胎”技巧。

```cpp
#include <bits/stdc++.h>
using namespace std;
using pii = pair<int,int>;
const int N = 2e6 + 10;
int q, n, x[N], y[N], v[N], lst;
pii far1[4], far2[4];   // 4方向最远/次远点
pii ans1, ans2, ans3;   // 全局最大 / 去掉u / 去掉v

inline int dis0(int k, int id) {   // 旋转后坐标
    int val = (k&1?1:-1) * x[id] + (k&2?1:-1) * y[id];
    return val;
}
inline int dist(int a, int b) {
    if (!a || !b) return -1e9;
    return abs(x[a]-x[b]) + abs(y[a]-y[b]) + max(v[a], v[b]);
}
inline int dist(pii pr) { return dist(pr.first, pr.second); }

// 用8个极值点找到以id为后点的最远/次远点对
pii getmax(int id) {
    int best = 0, sec = 0;
    for (int k = 0; k < 4; ++k)
        if (!best || dist(id, far1[k]) > dist(id, best))
            best = far1[k];
    for (int k = 0; k < 4; ++k) {
        int cur = (best == far1[k]) ? far2[k] : far1[k];
        if (!sec || dist(id, cur) > dist(id, sec)) sec = cur;
    }
    return {best, sec};
}

void upd(int id) {
    for (int k = 0; k < 4; ++k) {
        if (!far1[k] || dis0(k, id) > dis0(k, far1[k]))
            far2[k] = far1[k], far1[k] = id;
        else if (!far2[k] || dis0(k, id) > dis0(k, far2[k]))
            far2[k] = id;
    }
}

void insert(int id) {
    upd(id);
    pii mx = getmax(id);
    pii now1 = {id, mx.first};
    pii now2 = {id, mx.second};

    if (dist(now1) > dist(ans1)) {
        ans3 = (dist(now2) > dist(ans2)) ? now2 : ans2;
        ans2 = ans1;
        ans1 = now1;
    } else {
        auto chk = [&](pii cur) {
            if (cur.second != ans1.first)
                ans2 = (dist(cur) > dist(ans2)) ? cur : ans2;
            if (cur.second != ans1.second)
                ans3 = (dist(cur) > dist(ans3)) ? cur : ans3;
        };
        chk(now1); chk(now2);
    }
}

int query(int a) {
    if (a == ans1.first || a == ans1.second) return dist(ans2);
    if (a == ans2.first || a == ans2.second) return dist(ans3);
    return dist(ans1);
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> q;
    while (q--) {
        int op; cin >> op;
        if (op == 1) {
            ++n;
            cin >> x[n] >> y[n] >> v[n];
            x[n] ^= lst, y[n] ^= lst, v[n] ^= lst;
            insert(n);
        } else if (op == 2) {
            lst = dist(ans1); cout << lst << '\n'; lst %= 3;
        } else {
            int a; cin >> a; a ^= lst;
            lst = query(a); cout << lst << '\n'; lst %= 3;
        }
    }
    return 0;
}
```

代码解读概要：  
- 坐标旋转后，维护 4 个方向的“最远 / 次远点”，共 8 个。  
- 插入新点 n 时，用这 8 个点就能 O(1) 得到“以 n 为后点的最远 / 次远点对”。  
- 全局只需保留 3 条候选答案：最大、去掉最大.u、去掉最大.v。  
- 询问 3 时直接 O(1) 判断即可。

---

## 5. 算法可视化：像素动画演示

主题：**“像素探险家”在 8 位地下室寻找最远的芙兰幻影**

设计思路简述  
- 8 位像素风：用 16×16 像素方块表示坐标点，颜色区分力量值大小。  
- 实时极值高亮：插入新点时，4 个方向极值点闪红光，次远点闪蓝光。  
- 删除询问：点击“忽略第 a 个幻影”后，该点变灰，动画 0.5 秒展示“备胎答案”如何顶上。  
- 音效：插入点“叮”、极值更新“咔嗒”、询问回答“胜利”8 位音。  
- 控制面板：步进 / 自动 / 调速滑块，支持 1× ~ 8× 速播放。

关键帧示意（伪代码）  
```js
// 伪 Canvas 关键帧
for (let id = 1; id <= n; id++) {
    drawPixel(x[id], y[id], color(v[id]));      // 画点
    highlightExtremes();                        // 红/蓝闪
    let [far, sec] = getmax(id);
    drawArrow(id, far); drawArrow(id, sec);     // 连线
    updateGlobalTop3();                         // 顶部 HUD 更新
}
```

---

## 6. 拓展练习与相似问题思考

通用技巧迁移  
- 曼哈顿 ↔ 切比雪夫旋转：适用于所有曼哈顿极值问题，如“最远点对”、“最小覆盖矩形”。  
- 极值备胎思想：凡是“删除一个点后求最值”均可维护“最大 / 次大 / 第三大”三条候选。  
- 离线区间最值：把“点对贡献”转成区间加，可用线段树或前缀 / 后缀极值加速。

洛谷推荐  
1. P3961 [TJOI2013] 松鼠聚会 —— 曼哈顿极值 + 坐标旋转  
2. P4169 [Violet] 天使玩偶 —— 带插入的曼哈顿 k 近邻  
3. P4631 [APIO2018] 新家 —— 动态加点、删除后求曼哈顿极值  

---

## 7. 学习心得与经验分享

> RsCb 的踩坑提醒：“**强制在线的异或千万别忘！** 我因此 WA 了一下午。”  
> 洛语云笺点评：调试时把 `lst %= 3` 打印出来，能快速定位是否异或错位。

---

<conclusion>  
今天我们从暴力枚举一路走到 O(n) 线性最优解，核心就是“坐标旋转 + 极值备胎”。记住：  
- 曼哈顿极值先旋转，  
- 删除点维护备胎，  
- 强制在线别忘记。  
下次探险再见！💪

---
处理用时：85.03秒
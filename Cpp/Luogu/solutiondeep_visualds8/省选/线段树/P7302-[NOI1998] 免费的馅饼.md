# 题目信息

# [NOI1998] 免费的馅饼

## 题目描述

SERKOI 最新推出了一种叫做“免费馅饼”的游戏：游戏在一个舞台上进行。舞台的宽度为 $w$ 格（从左到右依次用 $1$ 到 $w$ 编号），游戏者占一格。开始时游戏者可以站在舞台的任意位置，手里拿着一个托盘。下图为天幕的高度为 $4$ 格时某一个时刻游戏者接馅饼的情景。

![](https://cdn.luogu.com.cn/upload/image_hosting/1gcg9awi.png)

游戏开始后，从舞台天幕顶端的格子中不断出现馅饼并垂直下落。游戏者左右移动去接馅饼。游戏者每秒可以向左或向右移动一格或两格，也可以站在原地不动。

当馅饼在某一时刻恰好到达游戏者所在的格子中，游戏者就收集到了这块馅饼。当馅饼落在一个游戏者不在的格子里时该馅饼就消失。

写一个程序，帮助我们的游戏者收集馅饼，使得所收集馅饼的分数之和最大。

## 说明/提示

对于 $100\%$ 的数据，$1 \leq w \leq 10^8$，$1 \leq n \leq 10^5$，$1\leq t_i \leq 10^8$，$1\leq p_i \leq w$，$1\leq v_i \leq 1000$。

## 样例 #1

### 输入

```
3 4
1 2 3
5 2 3
6 3 4
1 1 5
 ```

### 输出

```
12```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：[NOI1998] 免费的馅饼 深入学习指南 💡

> 欢迎来到“像素馅饼大作战”！今天我们要在一条无限长的舞台上，接住从天而降的美味馅饼，同时学习如何把“看似复杂”的移动问题，一步步拆解成优雅的算法模型。

---

## 1. 题目解读与策略初探

✨ **本题核心挑战**  
要在 **时间-位置二维平面** 里，找到一条“人可行走”的折线，使得折线上经过的馅饼总价值最大。难点在于：  
1. 人每秒钟最多移动 2 格（或不动）。  
2. 馅饼只在固定时刻、固定位置出现，错过即消失。  

✨ **核心算法标签**  
- 动态规划（DP）  
- 二维偏序 + 树状数组 / 线段树  
- 离散化  

---

### 🔍 算法侦探：如何在题目中发现线索？

| 线索 | 解读 |
| --- | --- |
| **线索1：问题目标** | “最大化收集的分数” → 最优化问题，自然想到 DP。 |
| **线索2：移动限制** | 每秒钟 2 格 → 把“能否从 A 走到 B”转化为 **|pᵢ-pⱼ| ≤ 2(tᵢ-tⱼ)** 的数学条件。 |
| **线索3：数据规模** | n ≤ 1e5，O(n²) 的暴力 DP 会超时 → 需要 O(n log n) 的优化。 |

---

### 🧠 思维链构建：从线索到策略

1. **朴素思路**：  
   把每个馅饼按时间排序，设 f[i] 表示“接到第 i 个馅饼时的最大价值”，暴力枚举 j < i 并检查移动条件。  
   复杂度 O(n²)，只能拿 85 分。

2. **优化突破**：  
   把 **移动条件** 拆成两个不等式：  
   - 2tⱼ - pⱼ ≤ 2tᵢ - pᵢ  
   - 2tⱼ + pⱼ ≤ 2tᵢ + pᵢ  

   这两个不等式就像 **二维平面里的“可达区域”**。  
   于是问题转化为：在所有满足这两个条件的 j 中，找 f[j] 的最大值。  
   这就是经典的 **二维偏序** 问题！  
   先按第一维排序，再用树状数组维护第二维的前缀最大值，即可 O(n log n) 解决。

---

## 2. 精选优质题解参考

> 我从题解区中，为大家精选了 **2 份高分题解**，它们思路清晰、代码优雅，值得深入学习。

### 题解一：xiezheyuan（赞：20）

- **亮点**：  
  1. 从贪心 → 暴力 DP → 树状数组优化，层层递进，非常适合学习路径。  
  2. 用“2t-p”和“2t+p”两个关键字，把二维偏序讲得非常直观。

- **代码赏析**（核心片段）：
  ```cpp
  sort(a + 1, a + n + 1, cmp);          // 先按 2t-p 排序
  for (int i = 1; i <= n; ++i) {
      f[i] = query(a[i].x) + a[i].v;    // 树状数组查询前缀最大值
      update(a[i].x, f[i]);             // 单点更新
  }
  ```

- **学习笔记**：  
  “把绝对值拆掉 → 二维偏序 → 树状数组” 是解决这类问题的经典套路。

---

### 题解二：SSL_TJH_蒟蒻（赞：17）

- **亮点**：  
  1. 用 **“顺序对”** 的视角理解二维偏序，非常巧妙。  
  2. 代码中 `2*t-p` 和 `2*t+p` 的离散化处理，简洁高效。

- **代码赏析**（离散化部分）：
  ```cpp
  sort(b + 1, b + n + 1, cmp2);         // 离散化 2t+p
  for (int i = 1; i <= n; ++i)
      a[i].r = lower_bound(b + 1, b + n + 1, a[i].r) - b;
  ```

- **学习笔记**：  
  离散化是处理 **大值域** 的必备技巧，务必熟练掌握。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法）

| 关键点 | 分析 | 💡 学习笔记 |
| --- | --- | --- |
| **1. 条件转化** | 把“人能否从 j 走到 i”转化为两个线性不等式：2tⱼ-pⱼ ≤ 2tᵢ-pᵢ 和 2tⱼ+pⱼ ≤ 2tᵢ+pᵢ。 | 把几何限制转化为代数不等式，是解题的第一步。 |
| **2. 二维偏序** | 先按第一维排序，再用树状数组维护第二维的前缀最大值。 | 二维偏序的经典套路：排序 + 数据结构优化。 |
| **3. 离散化** | 由于 2t+p 的值域很大（1e8 级别），需要离散化到 1~n。 | 离散化是处理大值域的通用技巧。 |

---

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点 | 得分预期 |
| --- | --- | --- | --- | --- |
| **贪心** | 按时间顺序，能接就接。 | 简单，O(n log n)。 | 无法处理“错过当前馅饼，后面价值更高”的情况。 | 50 分 |
| **暴力 DP** | f[i] = max(f[j] + v[i])，暴力枚举 j。 | 思路直观。 | O(n²) 超时。 | 85 分（开 O2 90 分） |
| **二维偏序 + 树状数组** | 把条件拆成两个不等式，用树状数组维护前缀最大值。 | O(n log n)，正解。 | 需要理解二维偏序。 | 100 分 |

---

### ✨ 优化之旅：从“能做”到“做好”

> 从 **暴力 DP** 到 **二维偏序**，我们经历了这样的思维跃迁：

1. **发现问题**：暴力 DP 的瓶颈在于“枚举 j”这一步。  
2. **寻找结构**：把条件拆成两个不等式后，发现 j 的取值是一个 **二维平面中的矩形区域**。  
3. **数据结构**：用树状数组维护第二维的前缀最大值，把 O(n) 的枚举优化成 O(log n) 的查询。  

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 1e5 + 10;

struct Pie {
    int t, p, v;
    int l, r;   // l = 2*t - p, r = 2*t + p
} a[MAXN];

int n, w;
int f[MAXN], c[MAXN], b[MAXN], tot;

bool cmp(const Pie &x, const Pie &y) {
    return x.l < y.l;   // 按第一维排序
}

int lowbit(int x) { return x & -x; }

void add(int x, int val) {
    for (; x <= tot; x += lowbit(x))
        c[x] = max(c[x], val);
}

int query(int x) {
    int res = 0;
    for (; x; x -= lowbit(x))
        res = max(res, c[x]);
    return res;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> w >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> a[i].t >> a[i].p >> a[i].v;
        a[i].l = 2 * a[i].t - a[i].p;
        a[i].r = 2 * a[i].t + a[i].p;
        b[i] = a[i].r;
    }

    // 离散化第二维
    sort(b + 1, b + n + 1);
    tot = unique(b + 1, b + n + 1) - (b + 1);
    for (int i = 1; i <= n; ++i)
        a[i].r = lower_bound(b + 1, b + tot + 1, a[i].r) - b;

    sort(a + 1, a + n + 1, cmp);

    int ans = 0;
    for (int i = 1; i <= n; ++i) {
        f[i] = query(a[i].r) + a[i].v;
        add(a[i].r, f[i]);
        ans = max(ans, f[i]);
    }

    cout << ans << '\n';
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

> 让我们用 **8 位像素风格** 的动画，直观感受 **二维偏序 + 树状数组** 的执行过程！

### 🎮 动画主题：**“像素馅饼大作战”**

- **场景**：一个 FC 红白机风格的舞台，横向为位置 p，纵向为时间 t。
- **馅饼**：以像素方块形式从天空下落。
- **人**：一个 8×8 像素的小人，每秒可左右移动 1~2 格。

---

### 🎯 动画流程（关键帧）

| 帧 | 画面 | 音效 | 说明 |
| --- | --- | --- | --- |
| 1 | 舞台初始化，小人站在任意起点。 | 启动音效“叮！” | 展示舞台和初始位置。 |
| 2 | 第一个馅饼出现，标记其 (t, p)。 | “嘀嗒” | 用红色像素块高亮馅饼。 |
| 3 | 计算 2t-p 和 2t+p，显示为两个绿色数字。 | “咔哒” | 展示二维偏序的两个关键字。 |
| 4 | 树状数组更新：小人把馅饼价值“塞”进树状数组的对应位置。 | “咻~” | 用像素箭头指向树状数组的格子。 |
| 5 | 下一个馅饼出现，小人查询树状数组的前缀最大值。 | “叮铃” | 用黄色高亮查询路径。 |
| 6 | 重复步骤 4~5，直到所有馅饼处理完毕。 | 背景音乐循环。 | 展示整个算法的流程。 |
| 7 | 最终结果：舞台中央显示最大分数，像素烟花绽放。 | 胜利音效“哒哒哒！” | 庆祝算法完成。 |

---

### 🕹️ 交互设计

- **控制面板**：  
  - 开始 / 暂停按钮（像素风格）。  
  - 单步执行按钮（像素小手图标）。  
  - 速度滑块（0.5x ~ 2x）。  
- **代码同步**：  
  - 屏幕右侧同步显示 C++ 代码，当前执行行高亮。  
- **旁白提示**：  
  - “现在我们在计算 2t-p，这是二维偏序的第一维！”  
  - “树状数组正在查询前缀最大值，找到最优的 f[j]！”

---

## 6. 拓展练习与相似问题思考

### 🌱 通用技巧迁移

- **二维偏序**：  
  本题的“二维偏序 + 树状数组”技巧，适用于所有“两个线性不等式约束”的问题，例如：  
  1. **最长递增子序列（LIS）**：把序列看作 (i, a[i]) 的二维点。  
  2. **矩形覆盖问题**：判断两个矩形是否相交。  
  3. **任务调度问题**：任务有开始时间和结束时间，求最大不重叠任务数。

### 📚 洛谷推荐练习

| 题号 | 推荐理由 |
| --- | --- |
| **P1439** | 经典二维偏序，用树状数组优化 LIS。 |
| **P3378** | 二维偏序的裸题，巩固模板。 |
| **P1908** | 逆序对问题，用树状数组统计二维偏序。 |

---

## 7. 学习心得与经验分享

> 从题解区中，我摘录了一些宝贵的调试经验：

- **经验 1（来自 xiezheyuan）**：  
  “贪心只能拿 50 分，因为馅饼价值分布可能很极端。这让我意识到：贪心策略必须结合问题特性，否则容易陷入局部最优。”

- **经验 2（来自 SSL_TJH_蒟蒻）**：  
  “离散化时，记得用 `lower_bound` 而不是 `unique`，否则会漏掉重复值。”

---

## 8. 结语

> 今天，我们不仅学会了如何接住“免费的馅饼”，更掌握了 **二维偏序 + 树状数组** 这一强大武器。  
> 记住：算法的世界就像舞台，只要善于拆解问题、洞察结构，你就能接住每一个“馅饼”！  

🎉 **下次再一起探索新的编程挑战！**

---
处理用时：114.65秒
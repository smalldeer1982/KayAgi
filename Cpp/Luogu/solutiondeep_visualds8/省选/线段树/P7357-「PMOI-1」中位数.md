# 题目信息

# 「PMOI-1」中位数

## 题目描述

给定一棵以 $1$ 为根的包含 $n$ 个节点的**有根树**。第 $i$ 个节点有点权 $a_i$。

定义函数 $f(u,v)$ 表示从 $u$ 到 $v$ 经过的所有节点的点权的**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\frac{t+1}2\right\rceil$ 小的数。

定义函数 $\text{cover}(x_1,y_1,x_2,y_2)$ 表示从 $x_1$ 到 $y_1$ 的路径是否完全覆盖了从 $x_2$ 到 $y_2$ 的路径。如果完全覆盖，则 $\text{cover}(x_1,y_1,x_2,y_2)=1$，否则 $\text{cover}(x_1,y_1,x_2,y_2)=0$。

你需要依次处理 $q$ 次操作，按照以下格式给出：

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ **异或**；

`2 u v`：表示一次询问，需要你求出 $\max\limits_{1\le i\le n,1\le j\le n}\{\text{cover}(i,j,u,v)f(i,j)\}$。

对于第二类操作，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

你需要对于每个第二类操作，输出对应的值。

## 说明/提示

【样例解释】

第一次是询问。显然，只有 $(i=4,j=8)$ 满足 $\text{cover}(i,j,u,v)=1$。此时 $f(i,j)=3$。

第二次是操作。将 $3$ 号节点的点权改为了 $2$。

第三次是询问。当 $i=4,j=3$ 时，$\text{cover}(i,j,u,v)=1$ 且 $f(i,j)=4$。不难发现，对于其他所有满足 $\text{cover}(i,j,u,v)=1$ 的节点对 $(i,j)$，均没有 $f(i,j)>4$。

【数据范围】
- Subtask 1（8 pts）：$n,q\le50$；
- Subtask 2（12 pts）：$n,q\le2\times10^3$；
- Subtask 3（16 pts）：$n,q\le4\times10^4$；
- Subtask 4（10 pts）：保证树的形态随机生成；
- Subtask 5（12 pts）：保证没有 $1$ 操作；
- Subtask 6（12 pts）：保证每次询问的 $u,v$ 都是叶子节点；
- Subtask 7（30 pts）：无特殊限制。

Subtask 4 的随机方式为：随机生成一个的排列 $p$，对于 $i\in[2,n]$，$p_i$ 向 $p_1,p_2,...,p_{i-1}$ 中等概率随机的一个点连边。

对于 $100\%$ 的数据满足，$1\le n,q,a_i \le 10^5$，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

## 样例 #1

### 输入

```
8 3
4 2 3 4 2 1 4 3
1 2
1 3
2 4
2 5
3 6
6 7
6 8
2 4 8
1 3 
2 2 3```

### 输出

```
3
4```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「PMOI-1」中位数 深入学习指南 💡

> 今天我们来一起分析「PMOI-1」中位数这道**树形数据结构 + 二分 + 主席树**的综合题。它像一场“树上寻宝”——在庞大的家族树里，既要快速改宝物的颜色，又要随时回答“哪条路径的宝藏中位数最大”。我们将拆解如何把“路径覆盖 + 中位数最大化”这一抽象需求，一步步落地为可维护、可查询的高效算法。

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
在**带修改**的有根树上，每次给出两个点 `u, v`（保证不在同一条链），要求  
> 在所有**完全覆盖** `(u, v)` 的路径 `(i, j)` 中，找出**路径点权中位数最大**的值。

### ✨ 核心算法标签
- **树链剖分 / LCA**
- **二分答案**
- **主席树（可持久化线段树 + 标记永久化）**

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现与分析 |
| --- | --- |
| **线索1：中位数最大化** | “最大值” → 自然想到**二分答案** `mid`：把问题转为判定性问题——是否存在路径中位数 ≥ `mid`？ |
| **线索2：路径完全覆盖** | 题目限定 `u, v` 不在同一条链，因此一条 `(i, j)` 覆盖 `(u, v)` 当且仅当 `i ∈ subtree(u)` 且 `j ∈ subtree(v)`（或反之）。 |
| **线索3：点权只有 0/1 变化** | 二分后，把 ≥ `mid` 的点权视为 `+1`，其余视为 `-1`，则路径和 ≥ 0 等价于中位数 ≥ `mid`。 |
| **线索4：树上子树 = DFS 序区间** | 子树在 DFS 序上是连续区间，可用**线段树/主席树**维护区间和或区间最值。 |
| **线索5：单点修改异或 1** | 点权只会 ±1，离散化后**只有一版主席树**需要改动，可用**标记永久化**快速完成区间 ±2。 |

### 🧠 思维链构建：从线索到策略
> 1. 我要最大化中位数 → 经典套路：**二分答案**。<br>
> 2. 判定“中位数 ≥ mid” → 把点权 ≥ mid 设 1，其余设 -1，路径和 ≥ 0 即可。<br>
> 3. 路径必须覆盖 `(u, v)` → 拆成三段：<br>
>    - `i → u`（子树 u 内某点到 u）<br>
>    - `u → v`（固定链）<br>
>    - `v → j`（子树 v 内某点到 v）<br>
>    三段权值和 ≥ 0 即可。<br>
> 4. 子树内最大值 → **DFS 序 + 主席树**维护区间最大值。<br>
> 5. 单点修改 → 点权 ±1 只会影响一版主席树，用**标记永久化**区间 ±2。

---

## 2. 精选优质题解参考

| 题解 | 亮点提炼 |
| --- | --- |
| **Y_B_X**（赞 6） | 将“中位数 ≥ mid”转化为“权值和 ≥ 0”非常清晰；利用**主席树 + 标记永久化**处理区间 ±2，实现简洁；离散化时巧妙利用“奇偶相邻”只有一版需要修改。 |
| **ducati**（赞 5） | 用 **Lemma 1/2** 形式化证明路径拆分；把主席树的时间轴视为“权值大小”，将修改转化为**重建 4 棵线段树**，思路更直观；复杂度分析严谨。 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **关键点1：二分判定模型**
   - **分析**：把“中位数最大化”转成“是否存在路径 ≥ mid”，从而引入 0/1 权值。
   - 💡 **学习笔记**：当最大化第 k 大/中位数时，优先考虑**二分答案 + 0/1 转化**。

2. **关键点2：路径覆盖 → 子树最值**
   - **分析**：`(i, j)` 覆盖 `(u, v)` ⇔ `i ∈ subtree(u)` 且 `j ∈ subtree(v)`（或对称）。  
     权值和公式：  
     `max_i (val_i→u) + val_u→v + max_j (val_v→j) ≥ 0`
   - 💡 **学习笔记**：树上“子树最值”可借助 DFS 序区间查询，把二维树结构压到一维线段树。

3. **关键点3：主席树 + 标记永久化**
   - **分析**：  
     - 权值 `a` 从小到大建立主席树版本 `rt[a]`。  
     - 当 `a` 增加 1，只有权值恰好为 `a` 的点会从 `+1 → -1`，其子树内所有节点需要 `-2`。  
     - 标记永久化：区间 ±2 时不下放标记，查询时累加祖先标记，保证可持久化。
   - 💡 **学习笔记**：**标记永久化**是可持久化线段树区间修改的利器，避免复制整条链。

### ⚔️ 策略竞技场：不同解法对比

| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 DFS** | 每次询问暴力枚举 `(i, j)` 并检查 | 思路直观 | 复杂度 O(q·n²) | n ≤ 50（Subtask 1） |
| **离线 + 整体二分** | 把所有询问一起二分，用虚树 + 线段树 | 理论可行 | 实现复杂，常数大 | n ≤ 4×10⁴（Subtask 3） |
| **在线二分 + 主席树**（正解） | 每版主席树维护 DFS 序区间最大值 | 在线、简洁、O(n log² n) | 空间 O(n log n) | 无特殊限制（Subtask 7） |

---

## 4. C++核心代码实现赏析

### 通用核心实现参考
> 综合 Y_B_X 与 ducati 的实现，提炼出一份**可编译、易读**的框架。

```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 10, LOG = 20;

int n, q, a[N], b[N], nn;
vector<int> g[N];

/* ---------- 离散化 ---------- */
void discrete() {
    for (int i = 1; i <= n; ++i) b[++nn] = a[i], b[++nn] = a[i] ^ 1;
    sort(b + 1, b + nn + 1);
    nn = unique(b + 1, b + nn + 1) - b - 1;
}

/* ---------- LCA ---------- */
int dep[N], fa[N][LOG];
void dfs_lca(int u, int pre) {
    dep[u] = dep[pre] + 1;
    fa[u][0] = pre;
    for (int i = 1; i < LOG; ++i) fa[u][i] = fa[fa[u][i - 1]][i - 1];
    for (int v : g[u]) if (v != pre) dfs_lca(v, u);
}
int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = LOG - 1; i >= 0; --i)
        if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];
    if (u == v) return u;
    for (int i = LOG - 1; i >= 0; --i)
        if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}

/* ---------- DFS 序 ---------- */
int dfn[N], sz[N], idx;
void dfs_dfn(int u, int pre) {
    dfn[u] = ++idx;
    sz[u] = 1;
    for (int v : g[u]) if (v != pre) {
        dfs_dfn(v, u);
        sz[u] += sz[v];
    }
}

/* ---------- 主席树 ---------- */
struct Node { int l, r, tag, mx; } t[N * 25];
int rt[N], tot;
void build(int &p, int l, int r) {
    p = ++tot;
    if (l == r) { t[p].mx = dep[rev[l]]; return; }
    int mid = (l + r) >> 1;
    build(t[p].l, l, mid);
    build(t[p].r, mid + 1, r);
    t[p].mx = max(t[t[p].l].mx, t[t[p].r].mx);
}
void update(int &p, int pre, int l, int r, int ql, int qr, int v) {
    p = ++tot;
    t[p] = t[pre];
    if (ql <= l && r <= qr) {
        t[p].tag += v;
        t[p].mx += v;
        return;
    }
    int mid = (l + r) >> 1;
    if (ql <= mid) update(t[p].l, t[pre].l, l, mid, ql, qr, v);
    if (qr > mid)  update(t[p].r, t[pre].r, mid + 1, r, ql, qr, v);
    t[p].mx = max(t[t[p].l].mx, t[t[p].r].mx) + t[p].tag;
}
int query_mx(int p, int l, int r, int ql, int qr) {
    if (!p || ql > qr) return -1e9;
    if (ql <= l && r <= qr) return t[p].mx;
    int mid = (l + r) >> 1, res = -1e9;
    if (ql <= mid) res = max(res, query_mx(t[p].l, l, mid, ql, qr));
    if (qr > mid)  res = max(res, query_mx(t[p].r, mid + 1, r, ql, qr));
    return res + t[p].tag;
}
int query_point(int p, int l, int r, int pos) {
    if (l == r) return t[p].mx;
    int mid = (l + r) >> 1;
    if (pos <= mid) return query_point(t[p].l, l, mid, pos) + t[p].tag;
    else return query_point(t[p].r, mid + 1, r, pos) + t[p].tag;
}

/* ---------- 主逻辑 ---------- */
int rev[N];
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> q;
    for (int i = 1; i <= n; ++i) cin >> a[i];
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        g[u].push_back(v);
        g[v].push_back(u);
    }
    discrete();
    dfs_lca(1, 0);
    dfs_dfn(1, 0);
    for (int i = 1; i <= n; ++i) rev[dfn[i]] = i;

    /* 初始化主席树 */
    build(rt[0], 1, n);
    vector<int> pos[N];
    for (int i = 1; i <= n; ++i) {
        int v = lower_bound(b + 1, b + nn + 1, a[i]) - b;
        pos[v].push_back(i);
    }
    for (int a = 1; a <= nn; ++a) {
        rt[a] = rt[a - 1];
        for (int u : pos[a - 1]) {
            update(rt[a], rt[a], 1, n, dfn[u], dfn[u] + sz[u] - 1, -2);
        }
    }

    while (q--) {
        int op, u, v;
        cin >> op >> u;
        if (op == 1) {
            int old = lower_bound(b + 1, b + nn + 1, a[u]) - b;
            int nxt = lower_bound(b + 1, b + nn + 1, a[u] ^ 1) - b;
            update(rt[nxt], rt[nxt], 1, n, dfn[u], dfn[u] + sz[u] - 1, (a[u] & 1) ? -2 : 2);
            a[u] ^= 1;
        } else {
            cin >> v;
            int l = lca(u, v);
            int L = 0, R = nn, ans = 0;
            while (L < R) {
                int mid = (L + R + 1) >> 1;
                int val = 0;
                val += query_mx(rt[mid], 1, n, dfn[u], dfn[u] + sz[u] - 1);
                val += query_mx(rt[mid], 1, n, dfn[v], dfn[v] + sz[v] - 1);
                val -= 2 * query_point(rt[mid], 1, n, dfn[l]);
                val += (a[l] >= b[mid]) ? 1 : -1;
                if (val >= 0) L = mid, ans = mid;
                else R = mid - 1;
            }
            cout << b[ans] << '\n';
        }
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题
**“像素寻宝队”**  
一棵 8×8 的像素树，节点是闪烁的宝箱；每次询问 `(u, v)` 时，像素探险家从子树 `u` 出发，沿着绿色像素路径奔向子树 `v`，实时显示“权值和”像素条。

### 🕹️ 核心演示内容
1. **二分答案进度条**：屏幕顶部显示 `mid` 值，随着二分推进，像素条左右跳动。
2. **0/1 权值染色**：≥ `mid` 的宝箱闪金色（+1），< `mid` 闪蓝色（-1）。
3. **路径权值和**：像素化数字实时累加，绿色路径高亮，音效“叮”表示累加成功。
4. **主席树区间查询**：DFS 序区间用像素块高亮，标记永久化的 `+2/-2` 用红色/绿色像素箭头标注。

### 🎯 交互控制
- **单步 / 自动**：点击“单步”逐帧查看；点击“自动”开启 8-bit BGM 自动演示。
- **速度滑块**：0.5× ~ 3× 调速。
- **音效**：金色宝箱“叮”，蓝色宝箱“咚”，成功找到答案播放 FC 胜利音效。

---

## 6. 拓展练习与相似问题思考

| 通用技巧迁移场景 | 示例说明 |
|---|---|
| **中位数最大化** | 序列 / 树上区间第 k 大、第 k 小问题，均可用二分 + 0/1 转化。 |
| **子树区间查询** | 子树和、子树最大值、子树颜色数，均可 DFS 序 + 线段树/主席树。 |
| **标记永久化** | 可持久化线段树的区间修改，避免下放标记，适合离线或在线。 |

### 洛谷推荐练习
1. **P2839** [集合]  
   🗣️ 同样使用“中位数 ≥ mid”的 0/1 转化套路，巩固主席树。
2. **P3302** [树链剖分]  
   🗣️ 树上路径查询最大值，熟悉 DFS 序与线段树。
3. **P3380** [二逼平衡树]  
   🗣️ 区间第 k 大，整体二分 + 树状数组/主席树综合练习。

---

## 7. 学习心得与经验分享

> **Y_B_X** 提到：“离散化时把 `a[i]` 和 `a[i]^1` 一起离散化，保证异或后只动一版主席树，减少码量。”  
> **洛语云笺点评**：离散化技巧是**减少主席树版本**的关键，避免每次修改都重建整棵树，值得借鉴！

---

<conclusion>
本次我们拆解了一道“树上中位数最大化”难题，从二分答案到主席树标记永久化，再到 DFS 序区间查询，每一步都体现了“抽象 → 转化 → 数据结构”的经典套路。希望大家把这套思维迁移到更多树形问题中，下次探险见！
</conclusion>

---
处理用时：113.33秒
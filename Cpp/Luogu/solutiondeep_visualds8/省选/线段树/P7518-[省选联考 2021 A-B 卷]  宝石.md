# 题目信息

# [省选联考 2021 A/B 卷]  宝石

## 题目背景

**链的部分分官方数据有误。这里已经修改，如仍有误请反馈。**

## 题目描述

欧艾大陆上有 $n$ 座城市，城市从 $1 \sim n$ 编号，所有城市经由 $n - 1$ 条无向道路互相连通，即 $n$ 座城市与 $n - 1$ 条道路构成了一棵树。

每座城市的集市上都会出售宝石，总共有 $m$ 种不同的宝石，用 $1 \sim m$ 编号。$i$ 号城市的集市出售的是第 $w_i$ 种宝石，一种宝石可能会在多座城市的集市出售。

K 神有一个宝石收集器。这个宝石收集器能按照顺序收集至多 $c$ 颗宝石，其收集宝石的顺序为：$P_1, P_2, \ldots , P_c$。更具体地，收集器需要先放入第 $P_1$ 种宝石，然后才能再放入第 $P_2$ 种宝石，之后再能放入第 $P_3$ 种宝石，以此类推。其中 $P_1, P_2, \ldots , P_c$ 互不相等。

K 神到达一个城市后，如果该城市的集市上出售的宝石种类和当前收集器中需要放入的种类相同，则他可以在该城市的集市上购买一颗宝石并放入宝石收集器中；否则他只会路过该城市什么都不做。

现在 K 神给了你 $q$ 次询问，每次给出起点 $s_i$ 与终点 $t_i$，他想知道如果从 $s_i$ 号城市出发，沿最短路线走到 $t_i$ 号城市后，他的收集器中最多能收集到几个宝石？（在每次询问中，收集器内初始时没有任何宝石。起点与终点城市集市上的宝石可以尝试被收集）

## 说明/提示

**【数据范围】**

对于所有测试数据：$1 \le n, q \le 2 \times {10}^5$，$1 \le c \le m \le 5 \times {10}^4$，$1 \le w_i \le m$。

每个测试点的具体限制见下表：

| 测试点编号 | $n, q \le$ | 特殊限制 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | 无 |
| $3 \sim 5$ | $1000$ | 无 |
| $6 \sim 10$ | $2 \times {10}^5$ | $m \le 300$ |
| $11 \sim 14$ | $2 \times {10}^5$ | $u_i = i$，$v_i = i + 1$ |
| $15 \sim 20$ | $2 \times {10}^5$ | 无 |

## 样例 #1

### 输入

```
7 3 3
2 3 1
2 1 3 3 2 1 3
1 2
2 3
1 4
4 5
4 6
6 7
5
3 5
1 3
7 3
5 7
7 5
```

### 输出

```
2
2
2
3
1
```

## 样例 #2

### 输入

```
见附件中的 gem/gem2.in```

### 输出

```
见附件中的 gem/gem2.ans```

## 样例 #3

### 输入

```
见附件中的 gem/gem3.in```

### 输出

```
见附件中的 gem/gem3.ans```

# AI分析结果

# 💡 洛语云笺的C++算法解析：宝石 深入学习指南 💡

> 各位少年探险家，欢迎来到「宝石收集」的思维迷宫！今天我们要解决的，不仅是如何在一棵树上“捡宝石”，更是一场关于“如何优雅地把复杂路径问题拆成可解子问题”的思维演练。准备好你的算法背包，我们出发！

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> 在 **树形结构** 中，给定一条从 `s` 到 `t` 的路径，如何按 **严格顺序** 收集宝石（必须依次是 `P1, P2, …, Pc`），求最多能收集多少颗？

### ✨ 核心算法标签
- **树上倍增（Binary Lifting）**
- **离线处理（Offline Queries）**
- **二分答案（Binary Search on Answer）**
- **树链剖分（Heavy-Light Decomposition）**（部分解法）
- **点分治（Centroid Decomposition）**（部分解法）

### 🗣️ 初步分析
> 这道题的核心在于 **“路径 + 序列匹配”**。直观上，我们需要：
1. **路径拆分**：将 `s→t` 拆成 `s→lca`（上行）和 `lca→t`（下行）。
2. **序列匹配**：在路径上按顺序匹配 `P1, P2, …`。
3. **高效查询**：由于 `n, q` 都是 `2e5`，暴力 `O(nq)` 不可行，必须优化。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**  
   "求最长匹配前缀" → **序列匹配问题**，联想到 **自动机** 或 **倍增**。
2. **线索2 (问题约束)**  
   "树结构 + 路径查询" → **树上倍增** 或 **树链剖分** 是常见套路。
3. **线索3 (数据规模)**  
   `n, q ≤ 2e5` → 需要 `O(n log n)` 或 `O(n log² n)` 的算法。

### 🧠 思维链构建：从线索到策略
> "侦探工作完成！我们发现：
> 1. **序列匹配**：由于 `P` 互不相同，可将宝石编号映射到 `P` 中的位置（`w_i → rank[w_i]`），问题转化为 **寻找最长连续递增子序列**。
> 2. **路径处理**：上行（`s→lca`）可直接倍增；下行（`lca→t`）需 **二分答案 + 反向倍增**。
> 3. **最终策略**：  
>   - **上行**：从 `s` 开始，倍增跳 `P1→P2→…` 直到 `lca`。  
>   - **下行**：二分一个 `mid`，检查能否从 `t` 反向跳 `Pmid→Pmid-1→…` 接上上行结果。"

---

## 2. 精选优质题解参考

### 题解一：wuhao2005（主席树 + 倍增）
- **亮点**  
  用 **主席树** 维护“每种颜色在祖先中的最近出现位置”，结合 **倍增** 实现 `O(n log² n)`。
- **核心技巧**  
  - `f1[u][k]`：`u` 向上跳 `2^k` 步后，`P` 序列增加 `2^k` 的位置。  
  - `f2[u][k]`：反向跳（`P` 序列减少 `2^k`）。  
  - 二分下行答案时，用主席树快速定位 `Pmid` 的最近祖先。

### 题解二：Lice（点分治 + 二分）
- **亮点**  
  **点分治** 将路径拆成 `s→centroid` 和 `centroid→t`，离线处理询问。
- **核心技巧**  
  - 对每个分治中心，预处理 `inc[u]`（上行最长匹配）和 `dec[u]`（下行最长匹配）。  
  - 二分答案时，检查 `inc[s] + dec[t]` 是否覆盖 `mid`。

### 题解三：vectorwyx（离线 + 倍增）
- **亮点**  
  **离线处理** 询问挂在 `t` 节点，DFS 时用桶记录祖先颜色位置。
- **核心技巧**  
  - `up1[i][j]`：`i` 向上跳 `2^j` 步后匹配 `P` 序列 `+2^j`。  
  - `up2[i][j]`：反向匹配 `-2^j`。  
  - 二分答案时，用桶快速定位 `Pmid` 的最近祖先。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：倍增 + 二分）
1. **关键点1：如何预处理“下一个匹配位置”？**
   - **分析**：对每个节点 `u`，需知道“下一个要匹配的 `P` 值”在祖先中的最近位置。  
   - **实现**：DFS 时用桶 `last[c]` 记录颜色 `c` 的最近祖先，动态更新 `f[u][0]`（上行）和 `g[u][0]`（下行）。
   - 💡 **学习笔记**：桶 + DFS 回溯是处理“祖先最近位置”的经典技巧。

2. **关键点2：如何高效查询上行匹配长度？**
   - **分析**：从 `s` 开始，倍增跳 `f[s][k]` 直到 `lca`。  
   - **实现**：`ans_up = 0`，若 `w[s] == P1`，则 `ans_up = 1`，然后倍增跳 `f[s][k]`。
   - 💡 **学习笔记**：倍增的“二进制拆分”思想适用于“跳跃式”查询。

3. **关键点3：如何处理下行匹配？**
   - **分析**：二分一个 `mid`，检查能否从 `t` 反向匹配 `Pmid→Pmid-1→…` 接上 `ans_up + 1`。  
   - **实现**：用桶快速找到 `Pmid` 的最近祖先，反向倍增跳 `g[t][k]`。
   - 💡 **学习笔记**：二分 + 倍增是处理“未知终点”的经典组合。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力 DFS** | 直接遍历路径匹配 | 思路直观 | `O(nq)` 超时 | 数据规模 `n ≤ 1000` |
| **树链剖分 + 倍增** | 重链上倍增匹配 | 常数小，易实现 | 需处理链间跳转 | 通用解法 |
| **点分治 + 二分** | 分治中心拆分路径 | 复杂度 `O(n log² n)` | 实现复杂 | 喜欢分治的选手 |
| **主席树 + 倍增** | 主席树维护最近祖先 | 理论最优 | 常数较大 | 追求理论复杂度 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考（倍增 + 二分）
```cpp
#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5, LOG = 20;
int n, m, c, q, p[N], w[N], pos[N];
int f[N][LOG], g[N][LOG], dep[N], fa[N][LOG];
vector<int> adj[N];

void dfs(int u, int pa) {
    dep[u] = dep[pa] + 1;
    fa[u][0] = pa;
    for (int k = 1; k < LOG; ++k)
        fa[u][k] = fa[fa[u][k-1]][k-1];

    static int last[N];
    int tmp = last[w[u]];
    last[w[u]] = u;

    f[u][0] = last[p[pos[w[u]] + 1]];
    g[u][0] = last[p[pos[w[u]] - 1]];
    for (int k = 1; k < LOG; ++k) {
        f[u][k] = f[f[u][k-1]][k-1];
        g[u][k] = g[g[u][k-1]][k-1];
    }

    for (int v : adj[u]) if (v != pa) dfs(v, u);
    last[w[u]] = tmp;
}

int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int k = LOG-1; ~k; --k)
        if (dep[fa[u][k]] >= dep[v]) u = fa[u][k];
    if (u == v) return u;
    for (int k = LOG-1; ~k; --k)
        if (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k];
    return fa[u][0];
}

int query_up(int s, int anc) {
    int ans = 0;
    if (w[s] == p[1]) {
        ans = 1;
        for (int k = LOG-1; ~k; --k)
            if (f[s][k] && dep[f[s][k]] >= dep[anc]) {
                ans += 1 << k;
                s = f[s][k];
            }
    }
    return ans;
}

bool check(int t, int anc, int mid, int base) {
    static int last[N];
    int u = last[p[mid]];
    if (!u || dep[u] < dep[anc]) return false;
    int cnt = mid - base;
    for (int k = LOG-1; ~k; --k)
        if (cnt >> k & 1) u = g[u][k];
    return u && dep[u] >= dep[anc];
}

int query(int s, int t) {
    int anc = lca(s, t);
    int up = query_up(s, anc);
    int l = up + 1, r = c, ans = up;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (check(t, anc, mid, up)) ans = mid, l = mid + 1;
        else r = mid - 1;
    }
    return ans;
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> m >> c;
    for (int i = 1; i <= c; ++i) {
        cin >> p[i];
        pos[p[i]] = i;
    }
    for (int i = 1; i <= n; ++i) cin >> w[i];
    for (int i = 1, u, v; i < n; ++i) {
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    dfs(1, 0);
    cin >> q;
    while (q--) {
        int s, t; cin >> s >> t;
        cout << query(s, t) << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：《像素勇士的宝石征途》
- **场景设计**：8位像素风格的树，每个节点是发光方块，路径用高亮箭头标记。
- **核心演示**：
  1. **上行阶段**：勇士从 `s` 出发，按 `P1→P2→…` 顺序点亮节点，用 **绿色箭头** 标记已匹配宝石。
  2. **下行阶段**：从 `t` 反向跳，用 **红色箭头** 模拟二分检查，最终合并结果。
- **交互设计**：
  - 控制面板：步进、自动播放、调速滑块。
  - 音效：匹配成功“叮”，失败“咚”，胜利“胜利音效”。
- **技术实现**：
  - 用 Canvas 绘制像素树，DFS 遍历动态高亮路径。
  - 关键帧：每次倍增跳跃时，节点闪烁并显示当前匹配长度。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **序列匹配**：适用于“最长递增子序列”、“字符串匹配”。
- **树上倍增**：适用于“LCA”、“路径最大值”、“动态树”。
- **二分答案**：适用于“最大化最小值”、“最小化最大值”。

### 洛谷推荐
1. **P3379 【模板】最近公共祖先（LCA）**  
   🗣️ 巩固树上倍增基础。
2. **P1081 [NOIP2012 提高组] 开车旅行**  
   🗣️ 倍增预处理 + 二分答案的经典题。
3. **P5021 [NOIP2018 提高组] 赛道修建**  
   🗣️ 树上路径问题的变形，需二分 + 贪心。

---

## 7. 学习心得与经验分享

> 来自 **wuhao2005** 的调试教训：  
> “考试时发现二分的下界是 `x+1` 而不是 `x`，大样例卡了半小时。提醒：一定要测边界！”  
> **洛语云笺点评**：边界条件是算法的“阿喀琉斯之踵”，二分答案时务必验证 `l` 和 `r` 的初始值。

---

<conclusion>
恭喜完成本次探险！从“暴力 DFS”到“倍增 + 二分”，我们经历了 **问题拆分 → 数据结构优化 → 算法组合** 的完整思维链。记住：  
> **“优雅的解法，往往源于对问题结构的深刻洞察。”**  
下次再会，继续挑战更高峰！💎
</conclusion>

---
处理用时：117.77秒
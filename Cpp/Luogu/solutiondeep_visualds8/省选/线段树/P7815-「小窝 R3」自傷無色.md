# 题目信息

# 「小窝 R3」自傷無色

## 题目背景

> こんな僕が生きてるだけで    
何万人のひとが悲しんで  
誰も僕を望まない  
そんな世界だったらいいのにな  
——[《自傷無色》](https://music.163.com/song?id=29124091)

## 题目描述

给定一棵 $n$ 个节点的树，根节点为 $1$，有边权。约定树上 $u,v$ 两点间路径长度 $d(u,v)$ 为 $u,v$ 间路径上的边权和。

对于一个无序二元组 $(u,v)$，定义一个「树三角」当且仅当同时满足：

- $u,v$ 的最近公共祖先 $w\neq u$ 且 $w\neq v$。
- 以 $d(u,w),d(v,w)$ 和某个正整数 $x$ 为边长，能构成一个三角形。$x$ 是任意选取的，因此一对 $(u,v)$ 可能会产生多个树三角。

此时 $d(u,w)+d(v,w)+x$ 即为这个树三角的大小。具体例子参考样例解释。

定义两个树三角不同，只需满足下列条件中的**一条**：

- 无序二元组 $(u,v)$ 不同。
- 树三角的大小不同。

对于一个带边权的树 $T$，定义其正弦值 $\sin T$ 为 $T$ 中所有树三角大小的和与 $T$ 中不同树三角总数量的比值。

小 H 给出了 $T$，希望你能求出 $\sin T$。为了避免误差，结果对 $10^9+7$ 取模。特别地，若 $T$ 中不存在树三角，则 $\sin T=0$。

## 说明/提示

### 样例解释

对于样例 1，$T$ 如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/35edha17.png)

节点 $1,2,3$ 构成的三角环有：$\underline{2,3},2;~\underline{2,3},3;~\underline{2,3},4$。

节点 $1,3,4$ 构成的三角环有：$\underline{3,3},1;~\underline{3,3},2;~\underline{3,3},3;~\underline{3,3},4;~\underline{3,3},5$。

节点 $1,3,5$ 构成的三角环有：$\underline{3,4},2;~\underline{3,4},3;~\underline{3,4},4;~\underline{3,4},5;~\underline{3,4},6$。

节点 $2,4,5$ 构成的三角环有：$\underline{1,2},2$。

所有三角环大小之和：$(7+8+9)+(7+8+\dots+11)+(9+10+\dots+13)+5=129$。

所有三角环的总个数：$3+5+5+1=14$。

$\sin T=\dfrac{129}{14}$，对 $10^9+7$ 取模后的结果为 $214285725$。

### 数据范围

**本题采用捆绑测试。**

- 特殊性质 A：保证 $T$ 中存在度为 $n-1$ 的节点。
- 特殊性质 B：保证 $T$ 中除了叶子节点，每个节点的度均为 $2$。
- 特殊性质 C：保证 $T$ 为满二叉树。

| Subtask | 分值 | $1\le n\le $ |  特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: | 
| $1$ | $5$  | $3$ | 无 |
| $2$ | $13$ | $10^3$ |  无 |
| $3$ | $11$ | $7\times10^3$ | 无 |
| $4$ | $17$ | $10^5$ | A |
| $5$ | $17$ | $10^5$ | B |
| $6$ | $17$ | $10^5$ | C |
| $7$ | $20$ | $10^5$ |  无 |

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le w\le 10^9$。

### 提示

在题目附件 `depression_sample.zip` 中：

- `depression_sample1.in` 即为样例 #1。
- `depression_sample2.in` 满足特殊性质 A。
- `depression_sample3.in` 满足特殊性质 B。
- `depression_sample4.in` 满足特殊性质 C。
- `depression_sample5.in` 不满足特殊性质。

## 样例 #1

### 输入

```
5
1 2 2
1 3 3
2 4 1
2 5 2```

### 输出

```
214285725```

## 样例 #2

### 输入

```
9
1 2 9
1 3 3
2 4 5
2 5 7
2 6 2
1 7 1
3 8 6
3 9 4```

### 输出

```
662721928```

# AI分析结果

# 💡 洛语云笺的C++算法解析：自傷無色 深入学习指南 💡  
> 洛语云笺，带你从“看不懂”到“写得出”，一步步拆解这道树形结构与数学推导交织的硬核题！

---

## 1. 题目解读与策略初探

### ✨ 核心挑战
**一句话总结**：在一棵带权树上，对所有满足“LCA-非端点”且能构成三角形的无序点对 `(u,v)`，求  
“所有三角形周长之和” ÷ “不同三角形数量” 的模意义值。  
> 难点在于：  
> 1. 如何快速枚举所有合法 `(u,v)`；  
> 2. 如何把“能否构成三角形”转化为数学条件；  
> 3. 如何把“求和 / 计数”拆成可在树上高效统计的式子。

### 🔍 算法侦探：如何在题目中发现线索？
| 线索 | 发现内容 | 启示 |
|---|---|---|
| **问题目标** | 求和 ÷ 计数 → 比值 | 先分别算分子、分母，最后做模逆元 |
| **问题结构** | 树 + 路径长度 | 树上统计 → 子树信息、LCA、DFS 序 |
| **三角形条件** | `|d₁-d₂| < x < d₁+d₂` | 把 `x` 的范围 `[|d₁-d₂|+1, d₁+d₂-1]` 转成**等差数列求和** |
| **数据规模** | n ≤ 1e5 | O(n log n) 或 O(n log² n) 可行；暴力 O(n²) 必炸 |

### 🧠 思维链构建：从线索到策略
1. 看到“比值”→ **分子分母拆开算**。  
2. 看到“树上任意两点”→ **枚举 LCA**，把无序点对 `(u,v)` 拆成“以 `w` 为 LCA 的所有 `(u,v)`”。  
3. 看到“区间求和/计数”→ **前缀/后缀和、树状数组/线段树、dsu on tree**。  
4. 看到“等差数列”→ **数学推导化简**，把 `Σx` 和 `Σx²` 转成 `Σd₁d₂`、`Σd₁`、`Σd₂` 等线性项。  
5. 最终锁定：**dsu on tree + BIT/线段树** 或 **线段树合并**，复杂度 O(n log² n)。

---

## 2. 精选优质题解参考

| 题解 | 亮点速读 | 洛语云笺点评 |
|---|---|---|
| **Nt_Tsumiki** (赞8) | 数学推导最彻底：把 `Σx` 和 `Σx²` 拆成 6 个线性项，再用树剖/ LCT 维护 | 推导模板，适合想“纯数学+数据结构”路线 |
| **万弘** (赞5) | 代码最短、常数最小：dsu on tree + BIT，离散化后 5 个树状数组 | 竞赛实战首选，思路清晰，代码易抄 |
| **dead_X** (赞5) | 按特殊性质（菊花、链、满二叉）逐级给部分分，引导思考 | 非常适合初学者“循序渐进”理解 |
| **Cry_For_theMoon** (赞4) | 动态开点线段树合并，模板化好 | 想练“线段树合并”可重点看 |
| **Mobius127** (赞1) | 把 dsu on tree 的“偏移量”思想讲透：用 `dis_x - dis_w` 统一值域 | 抽象思维极佳，可迁移到其它“子树相对值”问题 |

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（以 dsu on tree 为例）
| 关键点 | 拆解思路 | 学习笔记 |
|---|---|---|
| **1. 枚举 LCA** | 对每个节点 `w`，统计其不同子树间点对 `(u,v)` | 用 dsu on tree 保留重儿子信息，轻儿子暴力 |
| **2. 数学化三角形条件** | 设 `a=max(dis_u, dis_v)`，`b=min(...)`，则第三边范围 `[b-a+1, a+b-1]`，共 `2b-1` 个整数 | 把 `Σx` 和 `Σx²` 用等差数列公式化简 |
| **3. 数据结构维护** | 需维护：点数、一次和、二次和 → 支持“前缀查询” | 离散化后树状数组 3 个即可；线段树合并也行 |
| **4. 偏移量处理** | 子树内节点到根距离统一减去 `dis_w`，保证值域一致 | 用“相对值”思想，避免重构整棵树 |
| **5. 模逆元** | 最后输出 `(分子 * inv(分母)) % mod` | 费马小定理求逆元 |

### ⚔️ 策略竞技场
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
|---|---|---|---|---|
| **暴力 O(n²)** | 枚举所有 `(u,v)`，直接算 | 思路简单 | 1e5 必炸 | 拿 5 分 |
| **dsu on tree + BIT** | 枚举 LCA + 树状数组前缀和 | 代码短、常数小 | 需离散化 | 正解（万弘） |
| **线段树合并** | 动态开点线段树合并 | 通用模板 | 常数略大 | 正解（Cry） |
| **LCT/树剖** | 在线维护子树信息 | 理论 1log | 实现复杂 | 追求极致 |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现（dsu on tree + BIT）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 1e5 + 10, mod = 1e9 + 7;
struct Edge { int v, w, nxt; } e[N << 1];
int h[N], tot, n;
void add(int u, int v, int w) {
    e[++tot] = {v, w, h[u]}; h[u] = tot;
}

ll dis[N];
int sz[N], son[N];
void dfs1(int u, int fa) {
    sz[u] = 1;
    for (int i = h[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa) continue;
        dis[v] = dis[u] + e[i].w;
        dfs1(v, u);
        sz[u] += sz[v];
        if (sz[v] > sz[son[u]]) son[u] = v;
    }
}

ll lsh[N], len;
int get(ll x) { return lower_bound(lsh + 1, lsh + len + 1, x) - lsh; }

struct BIT {
    ll t0[N], t1[N], t2[N], tot0, tot1, tot2;
    void clr() {
        for (int i = 1; i <= len; ++i) t0[i] = t1[i] = t2[i] = 0;
        tot0 = tot1 = tot2 = 0;
    }
    void add(int x, ll v) {
        ll v2 = v * v % mod;
        for (; x <= len; x += x & -x) {
            t0[x] += 1;
            t1[x] = (t1[x] + v) % mod;
            t2[x] = (t2[x] + v2) % mod;
        }
        tot0 += 1;
        tot1 = (tot1 + v) % mod;
        tot2 = (tot2 + v2) % mod;
    }
    ll q0(int x) { ll s = 0; for (; x; x -= x & -x) s += t0[x]; return s; }
    ll q1(int x) { ll s = 0; for (; x; x -= x & -x) s = (s + t1[x]) % mod; return s; }
    ll q2(int x) { ll s = 0; for (; x; x -= x & -x) s = (s + t2[x]) % mod; return s; }
} bit;

ll fz, fm;
void calc(int u, int fa, ll base) {
    ll val = dis[u] - base;
    int pos = get(val);
    ll cnt = bit.q0(pos);
    ll sum = bit.q1(pos);
    ll sum2 = bit.q2(pos);

    // 作为较小的 b
    ll num = (val * 2 % mod - 1 + mod) % mod;
    fm = (fm + cnt * num) % mod;

    ll part = (4 * val % mod - 1 + mod) % mod;
    fz = (fz + part * sum % mod - 2 * val % mod * cnt % mod + 2 * sum2) % mod;
    fz = (fz + mod) % mod;

    for (int i = h[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v != fa) calc(v, u, base);
    }
}
void add(int u, int fa) {
    bit.add(get(dis[u]), dis[u]);
    for (int i = h[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v != fa) add(v, u);
    }
}
void del(int u, int fa) {
    int pos = get(dis[u]);
    bit.t0[pos]--; bit.t1[pos] = (bit.t1[pos] - dis[u] + mod) % mod;
    bit.t2[pos] = (bit.t2[pos] - dis[u] * dis[u] % mod + mod) % mod;
    bit.tot0--; bit.tot1 = (bit.tot1 - dis[u] + mod) % mod;
    bit.tot2 = (bit.tot2 - dis[u] * dis[u] % mod + mod) % mod;
    for (int i = h[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v != fa) del(v, u);
    }
}
void solve(int u, int fa, bool keep) {
    for (int i = h[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa || v == son[u]) continue;
        solve(v, u, 0);
    }
    if (son[u]) solve(son[u], u, 1);
    for (int i = h[u]; i; i = e[i].nxt) {
        int v = e[i].v;
        if (v == fa || v == son[u]) continue;
        calc(v, u, dis[u]);
        add(v, u);
    }
    bit.add(get(dis[u]), dis[u]);
    if (!keep) del(u, fa), bit.clr();
}

ll qpow(ll a, ll b) {
    ll res = 1;
    for (; b; b >>= 1, a = a * a % mod)
        if (b & 1) res = res * a % mod;
    return res;
}
int main() {
    scanf("%d", &n);
    for (int i = 1, u, v, w; i < n; ++i) {
        scanf("%d%d%d", &u, &v, &w);
        add(u, v, w); add(v, u, w);
    }
    dfs1(1, 0);
    for (int i = 1; i <= n; ++i) lsh[i] = dis[i];
    sort(lsh + 1, lsh + n + 1);
    len = unique(lsh + 1, lsh + n + 1) - lsh - 1;
    solve(1, 0, 1);
    fz = (fz % mod + mod) % mod;
    fm = (fm % mod + mod) % mod;
    printf("%lld\n", fz * qpow(fm, mod - 2) % mod);
    return 0;
}
```
> **代码解读概要**：  
> 1. 两次 DFS 预处理 `son` 和 `dis`；  
> 2. 离散化 `dis` 值域；  
> 3. dsu on tree：先处理轻儿子并清空，再处理重儿子保留；  
> 4. 对每个轻儿子子树，用树状数组统计“前缀”贡献，再插入整棵子树；  
> 5. 最后输出 `fz * inv(fm) % mod`。

---

## 5. 算法可视化：像素动画演示

> 主题：**“像素探险家”在树上寻找三角形宝藏**  
> 目标：动态演示 dsu on tree + BIT 的每一步

### 场景设定（8 位像素风）
- 树用 16×16 像素节点表示，边权用箭头数字。  
- 根节点高亮绿色，重链用黄色高亮。  
- 树状数组用横向 8×1 像素条，数值用 0-9 像素数字。  

### 关键帧步骤
| 帧 | 画面 | 旁白 | 音效 |
|---|---|---|---|
| 1 | 整棵树出现，根节点闪烁 | “欢迎来到树三角探险！” | 8 位欢迎音 |
| 2 | 重链高亮，轻链变灰 | “重儿子保留，轻儿子待会儿清空” | 叮 |
| 3 | 当前 LCA 节点放大，子树节点闪烁 | “正在枚举 LCA=w” | 提示音 |
| 4 | 轻儿子子树节点飞入树状数组 | “把 dis 值离散化后插入 BIT” | 咔哒 |
| 5 | BIT 条长度实时变化，显示 cnt/sum/sum2 | “统计前缀信息” | 滑动音 |
| 6 | 计算贡献：分子分母像素数字滚动 | “算出当前子树贡献” | 胜利音 |
| 7 | 清空轻儿子，保留重儿子 | “dsu on tree 的精髓：保留重信息” | 清空音 |
| 8 | 循环至下一 LCA | “继续探险！” | BGM 循环 |

### 交互控制
- **步进/自动**：可单步观看或 1-5 倍速自动播放。  
- **重置**：回到根节点重新开始。  
- **音效开关**：右上角 8 位音符图标。  

---

## 6. 拓展练习与相似问题思考

### 通用套路迁移
“枚举 LCA + 子树信息统计”适用于：  
1. 树上任意两点路径权值和统计（如 P3806）。  
2. 树上满足某条件的点对计数（如 P4178）。  
3. 树上最长/最短路径变形（如 P2664）。

### 洛谷推荐
| 题号 | 推荐理由 |
|---|---|
| **P3806** | 模板题：树上路径权值和查询，练 dsu on tree / 点分治。 |
| **P4178** | 树上点对距离 ≤ k 的计数，同样用 dsu on tree + BIT。 |
| **P2664** | 树上最长异或路径，思路类似“枚举根 + 子树信息”。 |

---

## 7. 学习心得与经验分享

> **来自万弘**：  
> “我最开始直接写线段树合并，T 成狗。后来把动态开点换成离散化+BIT，常数立刻起飞。  
> 教训：能离散化就别动态开点，能 BIT 就别线段树！”  
> **洛语云笺点评**：  
> 离散化 + BIT 是 dsu on tree 的黄金搭档，牢记“空间换时间”的权衡。

---

<conclusion>
今天的树三角之旅到此结束！记住三大法宝：  
1. **枚举 LCA** 把无序点对变有序；  
2. **数学化简** 把复杂区间和变线性项；  
3. **dsu on tree + BIT** 让 O(n²) 变 O(n log² n)。  
下次再遇到树上统计题，别忘了先想想“能不能枚举 LCA？”  
继续加油，我们下一题见！💪
</conclusion>

---
处理用时：93.34秒
# 题目信息

# [COCI 2022/2023 #4] Mreža

## 题目背景

### 卡评测封号。

## 题目描述

市长 Mirko 住在一个有 $n$ 个社区的城市里，这 $n$ 个社区用 $n-1$ 条双向道路连接，满足从任何社区出发都可以到达任意其他社区。

Mirko 想升级一些道路以疏导交通。对于每条路，我们知道目前在这条路上汽车的行驶速度 $v_i$，升级所需花费 $c_i$ 和升级后在这条路上汽车的行驶速度 $s_i$。

有 $q$ 个不满意的市民来见 Mirko。每个人都有他们自己的升级建议。第 $i$ 个市民的建议是：「我们应该在升级社区 $a_i$ 和 $b_i$ 之间的道路上投资 $e_i$ 欧元。」

对于每个建议，Mirko 感兴趣的是，如果他的目标是使社区 $a_i$ 和 $b_i$ 之间的最低驾驶速度最大化，那么他在升级道路上最多花费 $e_i$ 欧元的话这个最低驾驶速度是多少。

Mirko 瞬间意识到这个问题不简单，并且他雇佣你来帮助他！


## 说明/提示

样例解释 $1$：下图展示了这个城市和社区。边上写的分别是目前汽车的行驶速度，升级花费和升级后的汽车行驶速度。

![](https://cdn.luogu.com.cn/upload/image_hosting/umum0365.png?x-oss-process=image/resize,m_lfit,h_1700,w_2250)

如果我们升级 $1$ 和 $2$，$1$ 和 $3$ 之间的道路，从 $2$ 到 $4$ 的行驶速度将变成 $10,9,7$。最小为 $7$。

如果我们升级 $4$ 和 $3$ 之间的道路，从 $6$ 到 $4$ 的行驶速度将变成 $5,15$。最小为 $5$。

如果我们升级 $3$ 和 $5$ 之间的道路，从 $5$ 到 $3$ 的行驶速度将变成 $11$。

|子任务编号|	附加限制|	分值|
|:-:|:-:|:-:|
| $0$ | 是样例 | $0$ |
| $1$ | $n,q\le 1000$ |	$19$ |
| $2$ |	每个社区最多与两个其他社区相连 | $26$ |
| $3$ |	无附加限制 | $55$ |

## 样例 #1

### 输入

```
6
1 2 5 7 10
1 3 4 8 9
3 4 7 1 15
3 5 6 3 11
3 6 5 6 8
3
2 4 15
6 4 5
3 5 10```

### 输出

```
7
5
11```

## 样例 #2

### 输入

```
4
1 2 5 5 8
2 3 4 6 9
3 4 6 10 7
4
1 4 16
2 4 16
1 4 10
3 4 10```

### 输出

```
6
7
5
7```

# AI分析结果

💡 洛语云笺的C++算法解析：Mreža（COCI 2022/2023 #4）深入学习指南 💡

> 同学们好！今天我们要一起破解的，是**“在预算内让一条路径的最慢车速尽可能快”**的有趣问题。它融合了二分、树结构、主席树/整体二分等多个经典技巧，堪称“树上二分答案”的豪华套餐。让我们像侦探一样，一步步揭开它的面纱！

---

## 1. 题目解读与策略初探

✨ **核心挑战**：  
> 给定一棵树，每条边有原始速度`v`、升级花费`c`、升级后速度`s`。每个询问给出路径`(a,b)`与预算`e`，要求**在总花费≤e的前提下，让路径上所有边速度的最小值尽可能大**。

✨ **核心算法标签**：  
- 二分答案（Binary Search on Answer）  
- 树上数据结构（Tree DS）  
- 主席树/可持久化线段树（Persistent Segment Tree）  
- 整体二分（Parallel Binary Search）  

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1（问题目标）**：  
   “最小值最大化”——这是**二分答案**的典型信号！我们猜测答案具有单调性：若最低速度`x`可行，则所有`≤x`的速度都可行。
2. **线索2（数据结构需求）**：  
   需要快速查询“路径上所有`v<mid`的边的升级花费总和”——这暗示我们需要**树上路径查询**与**权值统计**，主席树或树链剖分+线段树是候选。
3. **线索3（数据规模）**：  
   `n≤1e5, q≤1e5`，`O(n log²n)`或`O(n log³n)`均可接受，但需避免`O(n²)`。

### 🧠 思维链构建：从线索到策略
> “侦探工作完成！现在拼图：
> 1. 首先，**线索1**指向二分答案，我们二分可能的最低速度`mid`。
> 2. 接着，**线索2**提示我们需要高效查询：对于给定`mid`，统计路径`(a,b)`上所有`v<mid`的边的`c`之和，并确保升级后这些边的`s≥mid`。
> 3. 最后，**线索3**告诉我们：主席树（`O(log²n)`每次查询）或整体二分（`O(log³n)`）均可行，但需巧妙实现。
> **结论**：采用**二分答案+主席树**或**整体二分**，将问题转化为“路径权值和”与“路径最小值”的经典树上问题！”

---

## 2. 精选优质题解参考

### 🌟 题解一：主席树差分（未来姚班zyl）
- **亮点**：  
  - 将边权转点权（深度较深点），用主席树维护“点到根路径上`v<mid`的`c`之和”。  
  - 查询时通过`rt[u] + rt[v] - 2*rt[lca]`差分得到路径和，复杂度`O(q log²n)`。
- **核心代码片段**：
  ```cpp
  int query(int x,int y,int z,int l,int r,int k){ // 主席树上二分
      if(l==r) return l;
      int mid=(l+r)>>1;
      ll left_sum = t[L(x)].sum + t[L(y)].sum - 2*t[L(z)].sum;
      if(left_sum <= k) return query(R(x),R(y),R(z),mid+1,r,k-left_sum);
      else return query(L(x),L(y),L(z),l,mid,k);
  }
  ```

### 🌟 题解二：整体二分+树状数组（_determination_）
- **亮点**：  
  - 离散化所有`v`和`s`，整体二分`mid`，用树状数组维护“边权≤mid的升级花费和”。  
  - 通过树链剖分将路径查询转为区间查询，复杂度`O(n log³n)`，但常数小。
- **核心代码片段**：
  ```cpp
  while(!check()){ // 整体二分框架
      sort(q+1,q+m+1,cmp); // 按mid排序询问
      for(int i=1;i<=m;i++) if(q[i].l!=q[i].r){
          // 树状数组更新边权≤mid的边
          while(cur<=tot && b[cur]<=q[i].mid) update_edge(cur++);
          ll cost = query_path(q[i].u, q[i].v);
          if(cost <= q[i].val) q[i].l = q[i].mid;
          else q[i].r = q[i].mid-1;
      }
  }
  ```

### 🌟 题解三：分块莫队（Add_Catalyst）
- **亮点**：  
  - 将树上路径转为括号序区间，用**树上莫队**维护动态边集，分块统计升级花费。  
  - 复杂度`O(n√q log n)`，理论不优但实际极快（1.55s vs 5s时限）。
- **学习笔记**：  
  > “当主席树难以实现时，莫队+分块是暴力美学的高效替代！”

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤（最优解法：主席树差分）
1. **关键点1：边权转点权**  
   - **分析**：将边`(u,v)`的权值绑定到深度较深的点上（如`v`），路径查询转为点集查询。  
   - 💡 **学习笔记**：树问题中，“边转点”是简化路径操作的常用技巧。

2. **关键点2：主席树维护前缀和**  
   - **分析**：对每个点`u`，建立主席树`rt[u]`，保存“`u`到根路径上所有点的`v`值离散化后的`c`前缀和”。  
   - 💡 **学习笔记**：主席树的“可减性”完美适配树上差分：`path_sum = rt[u] + rt[v] - 2*rt[lca]`。

3. **关键点3：二分答案的check函数**  
   - **分析**：二分`mid`，用主席树查询路径`(a,b)`上`v<mid`的`c`之和，并确保这些边的`s≥mid`（通过倍增预处理`s`的最小值）。  
   - 💡 **学习笔记**：二分的上界是路径上所有边升级后的最小值`s_min`，避免无效搜索。

### ⚔️ 策略竞技场：不同解法对比
| 策略 | 核心思想 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **主席树差分** | 二分+主席树维护路径和 | `O(q log²n)`，代码简洁 | 需离散化，空间`O(n log n)` | 标准解法，推荐！ |
| **整体二分+树状数组** | 并行二分+树链剖分 | 思维直观，常数小 | `O(n log³n)`，实现复杂 | 适合喜欢整体二分的选手 |
| **分块莫队** | 树上莫队+分块统计 | 实现简单，实际飞快 | 理论`O(n√q log n)`，可能被卡 | 卡时限时的“暴力美学” |

---

## 4. C++核心代码实现赏析

### 🌈 通用核心实现（主席树差分版）
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N = 2e5 + 10, LOG = 20;

struct Edge { int v, v0, c, s; };
vector<Edge> g[N];
int n, q, v0[N], c[N], s[N], disc[N * 2], dcnt;

// 离散化
int get_id(int x) { return lower_bound(disc + 1, disc + dcnt + 1, x) - disc; }

// 主席树
struct Node { int l, r; ll sum; } t[N * 40];
int rt[N], tot;
int build(int l, int r) {
    int p = ++tot;
    if (l == r) return p;
    int mid = (l + r) >> 1;
    t[p].l = build(l, mid);
    t[p].r = build(mid + 1, r);
    return p;
}
int modify(int p, int l, int r, int pos, ll val) {
    int q = ++tot; t[q] = t[p]; t[q].sum += val;
    if (l == r) return q;
    int mid = (l + r) >> 1;
    if (pos <= mid) t[q].l = modify(t[p].l, l, mid, pos, val);
    else t[q].r = modify(t[p].r, mid + 1, r, pos, val);
    return q;
}
ll query(int p, int q, int lca_rt, int l, int r, int k) {
    if (l == r) return t[p].sum + t[q].sum - 2 * t[lca_rt].sum;
    int mid = (l + r) >> 1;
    ll left_sum = t[t[p].l].sum + t[t[q].l].sum - 2 * t[t[lca_rt].l].sum;
    if (k <= mid) return query(t[p].l, t[q].l, t[lca_rt].l, l, mid, k);
    else return left_sum + query(t[p].r, t[q].r, t[lca_rt].r, mid + 1, r, k);
}

// LCA与s最小值
int fa[N][LOG], dep[N], mn_s[N][LOG];
void dfs(int u, int f) {
    fa[u][0] = f; dep[u] = dep[f] + 1;
    for (int i = 1; i < LOG; ++i) {
        fa[u][i] = fa[fa[u][i - 1]][i - 1];
        mn_s[u][i] = min(mn_s[u][i - 1], mn_s[fa[u][i - 1]][i - 1]);
    }
    rt[u] = modify(rt[f], 1, dcnt, get_id(v0[u]), c[u]);
    for (auto [v, v0_, c_, s_] : g[u]) if (v != f) {
        v0[v] = v0_; c[v] = c_; s[v] = s_;
        mn_s[v][0] = s_;
        dfs(v, u);
    }
}
int lca(int u, int v) {
    if (dep[u] < dep[v]) swap(u, v);
    for (int i = LOG - 1; ~i; --i)
        if (dep[fa[u][i]] >= dep[v]) u = fa[u][i];
    if (u == v) return u;
    for (int i = LOG - 1; ~i; --i)
        if (fa[u][i] != fa[v][i]) u = fa[u][i], v = fa[v][i];
    return fa[u][0];
}
int get_min_s(int u, int v, int lc) {
    int res = 1e9;
    auto up = [&](int& x, int k) {
        res = min(res, mn_s[x][k]);
        x = fa[x][k];
    };
    if (dep[u] > dep[v]) swap(u, v);
    for (int i = LOG - 1; ~i; --i)
        if (dep[fa[v][i]] >= dep[u]) up(v, i);
    if (u == v) return res;
    for (int i = LOG - 1; ~i; --i)
        if (fa[u][i] != fa[v][i]) up(u, i), up(v, i);
    return min({res, mn_s[u][0], mn_s[v][0]});
}

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n;
    for (int i = 1; i < n; ++i) {
        int u, v, v_, c_, s_;
        cin >> u >> v >> v_ >> c_ >> s_;
        g[u].push_back({v, v_, c_, s_});
        g[v].push_back({u, v_, c_, s_});
        disc[++dcnt] = v_;
        disc[++dcnt] = s_;
    }
    sort(disc + 1, disc + dcnt + 1);
    dcnt = unique(disc + 1, disc + dcnt + 1) - disc - 1;
    dfs(1, 0);
    cin >> q;
    while (q--) {
        int a, b, e; cin >> a >> b >> e;
        int lc = lca(a, b);
        int s_min = get_min_s(a, b, lc);
        int l = 1, r = s_min, ans = 0;
        while (l <= r) {
            int mid = (l + r) >> 1;
            ll cost = query(rt[a], rt[b], rt[lc], 1, dcnt, get_id(mid) - 1);
            if (cost <= e) ans = mid, l = mid + 1;
            else r = mid - 1;
        }
        cout << ans << '\n';
    }
    return 0;
}
```

---

## 5. 算法可视化：像素动画演示

### 🎮 动画主题：**“像素小车挑战赛”**
- **场景**：8位像素风格的树状赛道，每条边是像素化的道路，颜色代表速度（红=慢，绿=快）。
- **交互**：
  - 用户选择询问`(a,b,e)`，小车从`a`出发，沿路径驶向`b`。
  - **二分过程**：屏幕顶部显示当前二分的`mid`，道路颜色动态变化：
    - 若`v<mid`，道路闪烁黄色（需升级），升级后变绿色。
    - 路径最小值实时显示在终点旗帜处。
  - **音效**：升级时播放“叮”声，成功找到答案时播放“胜利音效”。

### 📍关键帧设计
1. **初始化**：赛道加载，边权显示为数字（像素字体）。
2. **二分动画**：
   - 每次二分`mid`，黄色高亮需升级的边，树状数组/主席树的区间和动态累加（像素化条形图）。
3. **结果展示**：小车以最终最低速度完成行驶，终点弹出“Speed: 7”像素对话框。

---

## 6. 拓展练习与相似问题思考

### 🎯 通用技巧迁移
- **二分答案+树上路径查询**：适用于“最小边权最大化”、“最大边权最小化”类问题。
- **主席树差分**：模板可用于“路径第k小”、“路径权值和”等。

### 📚 洛谷推荐练习
1. **P3384【模板】树链剖分**  
   *🗣️ 推荐理由*：掌握树链剖分基础，为路径查询铺路。
2. **P3834【模板】可持久化线段树**  
   *🗣️ 推荐理由*：巩固主席树差分技巧，解决静态区间第k小。
3. **P2619 [国家集训队] Tree I**  
   *🗣️ 推荐理由*：树上二分答案+生成树，深化对“最小瓶颈”问题的理解。

---

## 7. 学习心得与经验分享
> **来自作者_future姚班zyl_的调试心得**：  
> “离散化时别忘了把`0`加进去！我曾因漏掉`0`导致二分边界错误，调了半小时才发现是离散化的问题。”  
> **洛语云笺点评**：离散化边界是常见坑点，建议用`assert`检查所有可能值是否被覆盖。

---

<conclusion>
恭喜你！我们已完整拆解了Mreža这道题。从**二分答案**的直觉，到**主席树差分**的优雅实现，再到**像素动画**的趣味呈现，希望这份指南能让你感受到算法之美。记住：**好的算法不仅是效率的胜利，更是思维的舞蹈！** 下次探险见！💪
</conclusion>

---
处理用时：91.16秒
# 题目信息

# 「GMOI R2-T3」粒子环游

## 题目背景

热爱珂学的小 Z 正在进行一项无聊的实验。

## 题目描述

实验室中有一个由 $n$ 个实验腔连接而成的环形轨道，其中第 $i$ 个实验腔顺时针连向第 $i+1$ 个实验腔（特别的，第 $n$ 个实验腔连向第 $1$ 个实验腔）。同时还有一个标号为 $n+1$ 的新建实验腔要接入这个环形轨道。它可以接在任意两个原本相连的实验腔之间。

第 $i$ 个实验腔可以将带电荷量为 $Q$ 的粒子运输到它的下一个实验腔，这个过程花费的能量为 $\vert Q \vert \times c_i$。除此之外，第 $i$ 个实验腔本身就存储了量为 $e_i$ 的电荷（电荷量有正负）。由于众所周知的电荷守恒定律，第 $n+1$ 个实验腔储存的电荷量与前 $n$ 个实验腔储存的总电荷量的代数和为 $0$。

小 Z 有一个原本不带电的粒子。等到第 $n+1$ 个实验腔接入轨道后，他要任选一个实验腔（包括第 $n+1$ 个）作为出发点，将粒子放入，并使之在实验腔的能量驱动下顺时针环游一周回到出发点。粒子每到达一个实验腔（包括出发点），它所带电荷量就会变成原来所带的电荷量和这个实验腔所储存的电荷量的代数和。

**注意：电荷量会先加上实验腔所含电荷量，再计算能量贡献。**

现在，小 Z 想知道，在所有接入新建实验腔并选定出发点的方案中，粒子环游一周所需的能量最少为多少？

## 说明/提示

样例 $1$ 解释：一种最优方案为将 $4$ 号实验腔接在 $3$ 号实验腔与 $1$ 号实验腔之间，以 $4$ 号实验腔为出发点，花费能量为 $ 1\times 2\ +\ 4\times 1\ + \vert -1 \vert \times 3 \ +\ 0 \times 2 =9$。

**本题采用 Subtask 捆绑测试。**

| Subtask | $n\le$ | $c_i\le$ | $\vert e_i\vert$ | 特殊性质 | 对应测试点 | 总分 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $300$ | $100$ | $100$ | $-$ | $1\sim 5$ | $10$ |
| $1$ | $10^3$ | $10^3$ | $10^3$ | $\bf A$ | $6\sim 7$ | $5$ |
| $2$ | $10^4$ | $10^4$ | $10^4$ | $-$ | $8\sim12$ | $15$ |
| $3$ | $10^5$ | $10^5$ | $10^5$ | $\bf B$ | $13\sim 16$ | $10$ |
| $4$ | $2.5\times 10^5$ | $10^5$ |$10^5$ | $-$ | $17\sim 25$ | $60$ |

特殊性质 $\bf A$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=0$。

特殊性质 $\bf B$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=1$。

对于 $100\%$ 的数据，$1\le n\le 2.5\times 10^5$，$0\le c_i\le 10^5$，$0\le |e_i|\le 10^5$。

保证答案在 long long 范围内。

## 样例 #1

### 输入

```
3
1 3 2 2
3 -5 1```

### 输出

```
9```

## 样例 #2

### 输入

```
12
4 7 7 8 8 4 5 5 9 10 1 1 10 
0 -5 7 8 1 -1 -6 8 2 4 10 8 ```

### 输出

```
509```

# AI分析结果

---
# 💡 洛语云笺的C++算法解析：「GMOI R2-T3」粒子环游 深入学习指南 💡

---

## 1. 题目解读与策略初探

### ✨ 本题核心挑战
> 在**环形**轨道上插入一个新实验腔，并选定**任意起点**，使带电粒子**顺时针环游一周**所需能量**最小**——关键在于如何同时处理“插入位置”和“起点”这两个**双变量**的最优化问题。

### ✨ 核心算法标签
- **前缀和 + 绝对值最小化**
- **带权中位数 / 中位数查找**
- **离散化 + 线段树 / 树状数组**
- **滑动窗口 / 扫描线思想**

### 🗣️ 初步分析
- **暴力思路**：枚举插入位置（O(n)），再枚举起点（O(n)），总复杂度O(n²)，无法通过n=2.5×10⁵的数据。
- **关键突破**：将**电荷前缀和**视为数轴上的点，问题转化为**带权中位数**问题，利用数据结构维护动态插入/删除。
- **最优策略**：枚举插入位置（O(n)），用**线段树**或**树状数组**在O(log n)时间内求出当前插入位置下的最优起点，总复杂度O(n log n)。

### 🔍 算法侦探：如何在题目中发现线索？
1. **线索1 (问题目标)**：最小化“绝对值×系数”之和，暗示**中位数**或**带权中位数**性质。
2. **线索2 (问题约束)**：环形结构+前缀和为0，提示可**断环成链**，将环形问题转化为线性问题。
3. **线索3 (数据规模)**：n≤2.5×10⁵，要求O(n log n)或更低复杂度，排除O(n²)暴力。

### 🧠 思维链构建：从线索到策略
> “侦探工作完成！我们收集到三条线索：  
> 1. **绝对值最小化** → 联想到中位数性质：当中心点位于带权中位数时，总距离最小。  
> 2. **环形结构** → 通过前缀和断环成链，利用`s[i] = s[i-1] + e[i]`线性化。  
> 3. **双变量优化** → 固定插入位置（O(n)），用线段树维护动态前缀和，快速查询带权中位数（O(log n)）。  
> 结论：**带权中位数 + 线段树扫描**是本题的黄金钥匙！”

---

## 2. 精选优质题解参考

### 题解一：yinhy09（官方题解）
- **亮点**：首次提出将问题转化为**带权中位数**，并用**树状数组**维护动态前缀和，复杂度O(n log² n)。
- **关键技巧**：离散化`s`数组，用四个树状数组维护区间和，实现O(log n)查询。

### 题解二：_Fatalis_（渐进式思路）
- **亮点**：从特殊性质（c_i=0或1）入手，逐步推广到正解，代码简洁，逻辑清晰。
- **关键技巧**：用**线段树**维护`s`数组的排序后结果，支持单点修改和区间查询。

### 题解三：Aiopr_2378（动态开点线段树）
- **亮点**：使用**动态开点线段树**处理大值域（±2.5×10¹⁰），避免离散化，代码健壮。
- **关键技巧**：线段树二分查找带权中位数，支持O(log n)修改和查询。

---

## 3. 解题策略深度剖析

### 🎯 核心难点与关键步骤
1. **关键点1：如何断环成链？**
   - **分析**：利用前缀和`s[i] = s[i-1] + e[i]`，将环形问题转化为线性问题，起点为`s[p]`时，电荷量差为`s[j] - s[p]`。
   - 💡 **学习笔记**：环形问题常通过**前缀和**或**倍长数组**线性化。

2. **关键点2：如何快速求带权中位数？**
   - **分析**：将`s[i]`视为数轴上的点，权重为`c[i]`，带权中位数即满足左侧权重和≥总权重/2的最小点。
   - 💡 **学习笔记**：带权中位数可通过**线段树二分**或**树状数组上二分**实现。

3. **关键点3：如何处理动态插入/删除？**
   - **分析**：枚举插入位置时，每次仅影响`s[i]`和`s[i+1]`，用线段树维护排序后的`s`数组，支持O(log n)修改。
   - 💡 **学习笔记**：扫描线思想，每次移动插入位置时，只需局部更新。

### ✨ 解题技巧总结
- **技巧A (问题转化)**：将环形问题转化为线性前缀和问题，利用中位数性质。
- **技巧B (数据结构选择)**：大值域用动态开点线段树，小值域用离散化+树状数组。
- **技巧C (扫描线优化)**：枚举插入位置时，利用滑动窗口减少重复计算。

### ⚔️ 策略竞技场：不同解法的对比分析

| 策略 | 核心思想 | 优点 | 缺点与分析 | 适用场景 |
| :--- | :--- | :--- | :--- | :--- |
| **暴力枚举** | O(n²)枚举插入位置和起点 | 思路直观，易实现 | 时间复杂度过高，无法通过大数据 | n≤10³ |
| **带权中位数+树状数组** | 离散化后树状数组维护前缀和 | 代码简洁，空间小 | 需离散化，二分复杂度O(log² n) | n≤10⁵ |
| **带权中位数+线段树** | 动态开点线段树处理大值域 | 无需离散化，逻辑清晰 | 常数较大，空间O(n log n) | n≤2.5×10⁵ |

---

## 4. C++核心代码实现赏析

### 本题通用核心C++实现参考
- **说明**：综合题解二和三的思路，采用**离散化+线段树**实现带权中位数查询。
- **完整核心代码**：
```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const int MAXN = 5e5 + 10;
const ll INF = 1e18;

int n;
ll c[MAXN], e[MAXN], s[MAXN], b[MAXN], tot;
ll sumc, ans = INF;

struct SegTree {
    struct Node {
        int l, r;
        ll sz, sum; // sz: count, sum: s * c
    } tr[MAXN * 4];
    int cnt = 0;

    void build(int &p, int l, int r) {
        p = ++cnt;
        tr[p] = {l, r, 0, 0};
        if (l == r) return;
        int mid = (l + r) >> 1;
        build(tr[p].l, l, mid);
        build(tr[p].r, mid + 1, r);
    }

    void update(int p, int l, int r, int pos, ll c, ll s) {
        if (l == r) {
            tr[p].sz += c;
            tr[p].sum += c * s;
            return;
        }
        int mid = (l + r) >> 1;
        if (pos <= mid) update(tr[p].l, l, mid, pos, c, s);
        else update(tr[p].r, mid + 1, r, pos, c, s);
        tr[p].sz = tr[tr[p].l].sz + tr[tr[p].r].sz;
        tr[p].sum = tr[tr[p].l].sum + tr[tr[p].r].sum;
    }

    ll find_mid(int p, ll k) {
        if (tr[p].l == tr[p].r) return b[tr[p].l];
        if (tr[tr[p].l].sz >= k) return find_mid(tr[p].l, k);
        return find_mid(tr[p].r, k - tr[tr[p].l].sz);
    }

    pair<ll, ll> query(int p, int l, int r, int ql, int qr) {
        if (ql <= l && r <= qr) return {tr[p].sz, tr[p].sum};
        int mid = (l + r) >> 1;
        pair<ll, ll> res = {0, 0};
        if (ql <= mid) {
            auto tmp = query(tr[p].l, l, mid, ql, qr);
            res.first += tmp.first;
            res.second += tmp.second;
        }
        if (qr > mid) {
            auto tmp = query(tr[p].r, mid + 1, r, ql, qr);
            res.first += tmp.first;
            res.second += tmp.second;
        }
        return res;
    }
} seg;

int main() {
    scanf("%d", &n);
    for (int i = 1; i <= n + 1; i++) scanf("%lld", &c[i]), sumc += c[i];
    for (int i = 1; i <= n; i++) scanf("%lld", &e[i]), s[i] = s[i - 1] + e[i];
    e[n + 1] = -s[n];
    for (int i = 1; i <= n + 1; i++) s[i] = s[i - 1] + e[i], b[++tot] = s[i];
    sort(b + 1, b + tot + 1);
    tot = unique(b + 1, b + tot + 1) - b - 1;
    int rt = 0;
    seg.build(rt, 1, tot);
    for (int i = 1; i <= n + 1; i++) {
        int pos = lower_bound(b + 1, b + tot + 1, s[i]) - b;
        seg.update(rt, 1, tot, pos, c[i], s[i]);
    }
    for (int i = n + 1; i >= 1; i--) {
        ll mid = seg.find_mid(rt, (sumc + 1) / 2);
        int pos = lower_bound(b + 1, b + tot + 1, mid) - b;
        auto left = seg.query(rt, 1, tot, 1, pos);
        auto right = seg.query(rt, 1, tot, pos + 1, tot);
        ll cost = (left.first * mid - left.second) + (right.second - right.first * mid);
        ans = min(ans, cost);
        if (i > 1) {
            int old_pos = lower_bound(b + 1, b + tot + 1, s[i]) - b;
            seg.update(rt, 1, tot, old_pos, -c[i], s[i]);
            swap(c[i], c[i - 1]);
            swap(e[i], e[i - 1]);
            s[i] = s[i - 1] + e[i];
            int new_pos = lower_bound(b + 1, b + tot + 1, s[i]) - b;
            seg.update(rt, 1, tot, new_pos, c[i], s[i]);
        }
    }
    printf("%lld\n", ans);
    return 0;
}
```

### 题解代码片段赏析
- **题解二（_Fatalis_）**：使用**线段树**维护排序后的`s`数组，每次移动插入位置时局部更新，逻辑清晰。
- **题解三（Aiopr_2378）**：**动态开点线段树**处理大值域，避免离散化，代码优雅。

---

## 5. 算法可视化：像素动画演示

### 动画主题
**“像素电荷探险”**：在8位像素风格的数轴上，动态展示带权中位数的寻找过程。

### 核心演示内容
- **初始化**：数轴上显示n+1个像素点，每个点的高度表示`s[i]`，宽度表示`c[i]`。
- **插入位置枚举**：像素点“滑动”到新插入位置，线段树同步更新。
- **中位数查找**：像素光标二分查找带权中位数，高亮显示左侧和右侧权重和。
- **能量计算**：实时显示当前插入位置和起点下的总能量，伴随像素音效。

### 设计细节
- **像素风格**：使用8位调色板（红、绿、蓝、黄），模拟FC游戏画面。
- **交互控制**：提供“单步/自动播放”按钮，速度滑块可调。
- **音效提示**：
  - 插入位置移动：短促“滴”声。
  - 找到中位数：上扬“叮”声。
  - 计算完成：胜利音效。

---

## 6. 拓展练习与相似问题思考

### 通用技巧迁移
- **带权中位数**：适用于**仓库选址**、**信号塔定位**等问题。
- **前缀和+绝对值**：常用于**环形数组**的最优化问题，如**环形加油站**。

### 洛谷推荐练习
1. **P2605** [ZJOI2010]基站选址  
   *🗣️ 推荐理由*：带权中位数在二维平面上的应用，强化几何转化能力。
2. **P2893** [USACO08FEB]Meteor Shower  
   *🗣️ 推荐理由*：前缀和+扫描线思想，处理动态区间最值。
3. **P3800** [SDOI2016]齿轮  
   *🗣️ 推荐理由*：环形数组的最优化问题，巩固断环成链技巧。

---

## 7. 学习心得与经验分享

> **来自_Fatalis_的调试心得**：  
> “最初在计算`s[i] - (e[i] + e[n+1])`时漏掉了括号，导致前缀和错误。通过打印`s`数组的每一步变化，才定位到问题。这提醒我们：环形问题的边界条件需要格外小心！”

**洛语云笺点评**：  
“环形问题的调试技巧是**断环成链+打印前缀和**，确保每一步的线性化正确。_Fatalis_的经验告诉我们：**边界条件**是环形问题的隐形杀手！”

---

### 💡 总结
本题通过**带权中位数**巧妙地将双变量优化转化为单变量扫描，结合**线段树**或**树状数组**实现高效查询。核心在于：
1. **问题转化**：环形→线性，绝对值→中位数。
2. **数据结构**：离散化+线段树，或动态开点。
3. **扫描优化**：局部更新，避免重复计算。

希望这份指南能帮助你攻克类似的环形最优化问题！

---
处理用时：103.75秒
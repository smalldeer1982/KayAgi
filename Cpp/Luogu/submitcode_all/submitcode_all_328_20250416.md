## 题目: B2001

**提交时间：2024-01-07 08:46:28**

---
title: "入门测试题目"
layout: "post"
diff: 入门
pid: B2001
tag: ['模拟', '顺序结构']
---
# 入门测试题目
## 题目背景

强烈推荐[新用户必读贴](/discuss/show/241461)
## 题目描述

求两个整数的和。
## 输入格式

一行，两个用空格隔开的整数。
## 输出格式

两个整数的和。
## 样例

### 样例输入 #1
```
1 2
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
10230 21312
```
### 样例输出 #2
```
31542
```
## 提示

对于 $100\%$ 的数据，输入的整数在 $[1, 4 \times {10}^{18}]$ 内。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
long long a,b;
cin >> a>>b;
cout << a+b;
return 0;
}
```

---

## 题目: B2002

**分类：入门-顺序结构**

**提交时间：2023-11-29 21:18:16**

---
title: "Hello,World!"
layout: "post"
diff: 入门
pid: B2002
tag: ['顺序结构']
---
# Hello,World!
## 题目描述

编写一个能够输出 `Hello,World!` 的程序。

提示：
- 使用英文标点符号；
- `Hello,World!` 逗号后面**没有**空格。
- `H` 和 `W` 为**大写**字母。

## 样例

### 样例输入 #1
```
无
```
### 样例输出 #1
```
Hello,World!
```


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
cout << "Hello,World!" << endl;
return 0;
}
```

---

## 题目: B2003

**提交时间：2024-01-07 08:47:34**

---
title: "输出第二个整数"
layout: "post"
diff: 入门
pid: B2003
tag: ['顺序结构']
---
# 输出第二个整数
## 题目描述

输入三个整数，整数之间由一个空格分隔。把第二个输入的整数输出。
## 输入格式

只有一行，共三个整数，整数之间由一个空格分隔。
## 输出格式

只有一行，一个整数，即输入的第二个整数。
## 样例

### 样例输入 #1
```
123 456 789
```
### 样例输出 #1
```
456
```
## 提示

对于 $100\%$ 的数据，输入的整数在 $[1, {10}^9]$ 内。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int a,b,c;
cin >> a>>b>>c;
cout << b;
return 0;
}
```

---

## 题目: B2004

**提交时间：2024-05-29 16:45:42**

---
title: "对齐输出"
layout: "post"
diff: 入门
pid: B2004
tag: ['顺序结构']
---
# 对齐输出
## 题目描述

读入三个整数，按每个整数占 $8$ 个字符的宽度，右对齐输出它们，按照格式要求依次输出三个整数，之间以一个空格分开。
## 输入格式

只有一行，包含三个整数 $a,b,c$。整数之间以一个空格分开。
## 输出格式

只有一行，按照格式要求依次输出三个整数，之间以一个空格分开。
## 样例

### 样例输入 #1
```
123456789 0 -1

```
### 样例输出 #1
```
123456789        0       -1

```
## 提示

对于 $100 \%$ 的数据，$-2^{31} \le a, b, c < 2^{31}$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
int a,b,c;
cin>>a>>b>>c;
printf("%8d %8d %8d",a,b,c);
return 0;
}
```

---

## 题目: B2005

**分类：入门-顺序结构**

**提交时间：2023-11-10 15:06:31**

---
title: "字符三角形"
layout: "post"
diff: 入门
pid: B2005
tag: ['顺序结构']
---
# 字符三角形
## 题目描述

给定一个字符，用它构造一个底边长 $5$ 个字符，高 $3$ 个字符的等腰字符三角形。
## 输入格式

输入只有一行，包含一个字符。
## 输出格式

该字符构成的等腰三角形，底边长 $5$ 个字符，高 $3$ 个字符。
## 样例

### 样例输入 #1
```
*
```
### 样例输出 #1
```
  *
 ***
*****
```
## 提示

对于 $100 \%$ 的数据，输入的字符是 ASCII 中的可见字符。


### 代码

```cpp
#include<cstdio>
int main(){
char c;//定义
scanf("%c",&c);//输入，注意要取地址
printf("  %c  \n",c);
printf(" %c%c%c \n",c,c,c);
printf("%c%c%c%c%c\n",c,c,c,c,c);
return 0;
}
```

---

## 题目: B2006

**提交时间：2024-08-06 14:41:59**

---
title: "地球人口承载力估计"
layout: "post"
diff: 入门
pid: B2006
tag: ['顺序结构']
---
# 地球人口承载力估计
## 题目描述

假设地球上的新生资源按恒定速度增长。照此测算，地球上现有资源加上新生资源可供 $x$ 亿人生活 $a$ 年，或供 $y$ 亿人生活 $b$ 年。

为了能够实现可持续发展，避免资源枯竭，地球最多能够养活多少亿人？
## 输入格式

一行，包括四个正整数 $x, a, y, b$，两个整数之间用单个空格隔开。
## 输出格式

一个实数 $z$，表示地球最多养活 $z$ 亿人，舍入到小数点后两位。
## 样例

### 样例输入 #1
```
110 90 90 210
```
### 样例输出 #1
```
75.00
```
## 提示

对于 $100 \%$ 的数据，$1 \le x, a, y, b \le {10}^4$，$x > y$，$a < b$，$a x < b y$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
double x,a,y,b;
cin>>x>>a>>y>>b;
cout<<fixed<<setprecision(2)<<(x*a-y*b)/(a-b)<<endl;
return 0;
}
```

---

## 题目: B2007

**提交时间：2024-08-05 15:53:18**

---
title: "A + B 问题"
layout: "post"
diff: 入门
pid: B2007
tag: ['顺序结构']
---
# A + B 问题
## 题目描述

在大部分的在线题库中，都会将 A + B 问题作为第一题，以帮助新手熟悉平台的使用方法。

A + B 问题的题目描述如下：给定两个整数 $A$ 和 $B$，输出 $A + B$ 的值。保证 $A, B$ 及结果均在 $32$ 位整型范围内。

现在请你解决这一问题。
## 输入格式

一行，包含两个整数 $A, B$，中间用单个空格隔开。$A$ 和 $B$ 均在 $32$ 位整型范围内。
## 输出格式

一个整数，即 $A + B$ 的值。保证结果在 $32$ 位整型范围内。保证答案非负。
## 样例

### 样例输入 #1
```
1 2
```
### 样例输出 #1
```
3
```
## 提示

对于 $100 \%$ 的数据，$A, B, A + B$ 均在 $32$ 位整型范围内，且 $A + B \ge 0$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
int a,b;
cin>>a>>b;
cout<<a+b;
return 0;
}
```

---

## 题目: B2008

**提交时间：2024-01-12 16:39:27**

---
title: "计算 (a+b)×c 的值"
layout: "post"
diff: 入门
pid: B2008
tag: ['顺序结构']
---
# 计算 (a+b)×c 的值
## 题目描述

给定 $3$ 个整数 $a,b,c$，计算表达式 $(a+b) \times c$ 的值。
## 输入格式

输入仅一行，包括三个整数 $a,b,c$，数与数之间以一个空格分开。
## 输出格式

输出一行，即表达式的值。
## 样例

### 样例输入 #1
```
2 3 5


```
### 样例输出 #1
```
25


```
## 提示

对于 $100 \%$ 的数据，$-{10}^4 < a, b, c < {10}^4$。


### 代码

```cpp
#include <iostream>
using namespace std;
int a,b,c;
int main()
{
cin>>a>>b>>c;
cout<<(a+b)*c;
}
```

---

## 题目: B2009

**提交时间：2024-01-13 20:56:59**

---
title: "计算 (a+b)/c 的值"
layout: "post"
diff: 入门
pid: B2009
tag: ['顺序结构']
---
# 计算 (a+b)/c 的值
## 题目描述

给定 $3$ 个整数 $a,b,c$，计算表达式 $(a+b)/c$ 的值，`/` 是整除运算。
## 输入格式

输入仅一行，包括三个整数 $a,b,c$，数与数之间以一个空格分开。
## 输出格式

输出一行，即表达式的值。
## 样例

### 样例输入 #1
```
1 1 3

```
### 样例输出 #1
```
0

```
## 提示

对于 $100 \%$ 的数据，$-{10}^4 < a, b, c < {10}^4$，$c \ne 0$。


### 代码

```cpp
#include <iostream>
using namespace std;
int a,b,c;
int main()
{
cin>>a>>b>>c;
cout<<(a+b)/c;
}
```

---

## 题目: B2010

**提交时间：2024-08-07 14:30:47**

---
title: "带余除法"
layout: "post"
diff: 入门
pid: B2010
tag: ['顺序结构']
---
# 带余除法
## 题目描述

给定被除数和除数，求整数商及余数。此题中请使用默认的整除和取余运算，无需对结果进行任何特殊处理。
## 输入格式

一行，包含两个整数，依次为被除数和除数（除数非零），中间用一个空格隔开。
## 输出格式

一行，包含两个整数，依次为整数商和余数，中间用一个空格隔开。
## 样例

### 样例输入 #1
```
10 3
```
### 样例输出 #1
```
3 1
```
### 样例输入 #2
```
20 4
```
### 样例输出 #2
```
5 0
```
## 提示

对于 $100 \%$ 的数据，$0 \le a \le 100$，$1 \le b \le 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
int a,b;
cin>>a>>b;
cout<<a/b<<" "<<a%b;
return 0;
}
```

---

## 题目: B2011

**提交时间：2024-08-07 14:35:35**

---
title: "计算分数的浮点数值"
layout: "post"
diff: 入门
pid: B2011
tag: ['顺序结构']
---
# 计算分数的浮点数值
## 题目描述

两个整数 $a$ 和 $b$ 分别作为分子和分母，即分数 $\dfrac{a}{b}$，求它的浮点数值（双精度浮点数，保留小数点后 $9$ 位）。
## 输入格式

输入仅一行，包括两个整数 $a$ 和 $b$。
## 输出格式

输出也仅一行，分数 $\dfrac{a}{b}$ 的浮点数值（双精度浮点数，保留小数点后 $9$ 位）。
## 样例

### 样例输入 #1
```
5 7
```
### 样例输出 #1
```
0.714285714
```
## 提示

对于 $100 \%$ 的数据，$1 \le a, b \le {10}^9$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
double a,b;
cin>>a>>b;
cout<<fixed<<setprecision(9)<<a/b<<endl;
return 0;
}
```

---

## 题目: B2012

**提交时间：2024-08-08 14:47:05**

---
title: "甲流疫情死亡率"
layout: "post"
diff: 入门
pid: B2012
tag: ['顺序结构']
---
# 甲流疫情死亡率
## 题目描述

甲流并不可怕，在中国，它的死亡率并不是很高。请根据截止 $2009$ 年 $12$ 月 $22$ 日各省报告的甲流确诊数 $a$ 和死亡数 $b$，计算甲流在各省的死亡率。
## 输入格式

输入共两行，第一行一个整数为确诊数 $a$，第二行一个整数为死亡数 $b$。
## 输出格式

输出仅一行，甲流死亡率，以百分数形式输出，精确到小数点后 $3$ 位。
## 样例

### 样例输入 #1
```
10433
60
```
### 样例输出 #1
```
0.575%
```
## 提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq a, b \leq 10^4$。

### 提示

在 C 风格输入输出中，百分号 `%` 可以这样输出：`printf("%%");`。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
double a,b;
cin>>a>>b;
cout<<fixed<<setprecision(3)<<b/a*100<<"%"<<endl;
return 0;
}
```

---

## 题目: B2013

**提交时间：2024-08-09 14:07:33**

---
title: "温度表达转化"
layout: "post"
diff: 入门
pid: B2013
tag: ['顺序结构']
---
# 温度表达转化
## 题目描述

利用公式 $C=5 \times (F - 32)/9$ ( 其中 $C$ 表示摄氏温度，$F$ 表示华氏温度）进行计算转化，输入华氏温度 $F$，输出摄氏温度 $C$，要求精确到小数点后 $5$ 位。
## 输入格式

输入一行，包含一个实数 $F$，表示华氏温度。（$F \ge - 459.67$）
## 输出格式

输出一行，包含一个实数，表示对应的摄氏温度，要求精确到小数点后 $5$ 位。
## 样例

### 样例输入 #1
```
41
```
### 样例输出 #1
```
5.00000
```
## 提示

（$F \ge - 459.67$）


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
double a;
cin>>a;
cout<<fixed<<setprecision(5)<<5*(a-32)/9;
return 0;
}
```

---

## 题目: B2014

**提交时间：2024-08-09 14:11:02**

---
title: "与圆相关的计算"
layout: "post"
diff: 入门
pid: B2014
tag: ['顺序结构']
---
# 与圆相关的计算
## 题目描述

给出圆的半径，求圆的直径、周长和面积。输入圆的半径实数 $r$，输出圆的直径、周长、面积，每个数保留小数点后 $4$ 位。圆周率取值为 $3.14159$。
## 输入格式

输入包含一个实数 $r$（$0<r \le 10000$），表示圆的半径。
## 输出格式

输出一行，包含三个数，分别表示圆的直径、周长、面积，数与数之间以一个空格分开，每个数保留小数点后 $4$ 位。
## 样例

### 样例输入 #1
```
3.0
```
### 样例输出 #1
```
6.0000 18.8495 28.2743
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
double a;
cin>>a;
cout<<fixed<<setprecision(4)<<a*2<<" ";
cout<<fixed<<setprecision(4)<<a*3.14159*2<<" ";
cout<<fixed<<setprecision(4)<<a*a*3.14159;
return 0;
}
```

---

## 题目: B2015

**提交时间：2024-08-12 14:51:08**

---
title: "计算并联电阻的阻值"
layout: "post"
diff: 入门
pid: B2015
tag: ['顺序结构']
---
# 计算并联电阻的阻值
## 题目描述

对于阻值为 $r_1$ 和 $r_2$ 的电阻，其并联电阻阻值公式计算如下：
$$R=\dfrac{1}{\dfrac{1}{r_1}+\dfrac{1}{r_2}}$$

输入实数 $r_1,r_2$。输出并联之后的阻抗大小，结果保留小数点后 $2$ 位。

## 输入格式

两个实数 $r_1,r_2$，以一个空格分开。

## 输出格式

并联之后的阻抗大小，保留小数点后 $2$ 位。

## 样例

### 样例输入 #1
```
1 2
```
### 样例输出 #1
```
0.67
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
double a,b,x;
cin>>a>>b;
x=1/(1/a+1/b);
cout<<fixed<<setprecision(2)<<x<<endl;
return 0;
}
```

---

## 题目: B2016

**提交时间：2024-08-13 22:07:38**

---
title: "浮点数向零舍入"
layout: "post"
diff: 入门
pid: B2016
tag: ['顺序结构']
---
# 浮点数向零舍入
## 题目描述

输入一个双精度浮点数，将其向零舍入到整数。说明：向零舍入的含义是，正数向下舍入，负数向上舍入。

## 输入格式

一个双精度浮点数 $x$。
## 输出格式

一个整数，即向零舍入到整数的结果。
## 样例

### 样例输入 #1
```
2.3
```
### 样例输出 #1
```
2
```
## 提示

$-10^{15} \le x \le 10^{15}$。


### 代码

```cpp
#include<iostream>
using namespace std;
int main()
{
long long x;
cin>>x;
cout<<x<<endl;
return 0;
}
```

---

## 题目: B2017

**提交时间：2024-08-14 15:01:26**

---
title: "打印 ASCII 码"
layout: "post"
diff: 入门
pid: B2017
tag: ['顺序结构']
---
# 打印 ASCII 码
## 题目描述

输入一个除空格以外的可见字符，输出其 ASCII 码。
## 输入格式

一个除空格以外的可见字符。
## 输出格式

一个十进制整数，即该字符的 ASCII 码。
## 样例

### 样例输入 #1
```
A
```
### 样例输出 #1
```
65
```


### 代码

```cpp
#include<iostream>
using namespace std;
char n;
int main()
{
cin>>n;
cout<<n+'0'-'0';
return 0;
}
```

---

## 题目: B2018

**提交时间：2024-08-14 15:20:54**

---
title: "打印字符"
layout: "post"
diff: 入门
pid: B2018
tag: ['顺序结构']
---
# 打印字符
## 题目描述

输入一个 ASCII 码，输出对应的字符。
## 输入格式

一个整数，即字符的 ASCII 码，保证存在对应的可见字符。
## 输出格式

一行，包含相应的字符。
## 样例

### 样例输入 #1
```
65
```
### 样例输出 #1
```
A
```
## 提示

保证所有数据 $<128$ 并且 $>0$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a;
int main()
{
cin>>a;
cout<<(char)a;
return 0;
}
```

---

## 题目: B2019

**提交时间：2024-08-15 15:42:53**

---
title: "整型与布尔型的转换"
layout: "post"
diff: 入门
pid: B2019
tag: ['顺序结构']
---
# 整型与布尔型的转换
## 题目描述

将一个整型变量的值赋给一个布尔型变量，再将这个布尔型变量的值赋给一个整型变量，得到的值是多少？
## 输入格式

一个整型范围内的整数，即初始时整型变量的值。
## 输出格式

一个整数，经过上述过程后得到的结果。
## 样例

### 样例输入 #1
```
3
```
### 样例输出 #1
```
1
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
bool a;
int b;
int main()
{
cin>>b;
a=b;
cout<<a;
return 0;
}
```

---

## 题目: B2020

**提交时间：2024-08-15 15:53:25**

---
title: "分糖果"
layout: "post"
diff: 入门
pid: B2020
tag: ['顺序结构']
---
# 分糖果
## 题目描述

某个幼儿园里，有 $5$ 位小朋友编号依次为 $1,2,3,4,5$ 他们按照自己的编号顺序围坐在一张圆桌旁。他们身上有若干糖果，现在他们玩一个分糖果游戏。从 $1$ 号小朋友开始，将自己的糖果均分成 $3$ 份（如果有多余的糖果，就自己立即吃掉），自己留一份，其余两份分给和他相邻的两个小朋友。接着 $2,3,4,5$ 号小朋友也这样做。问一轮结束后，每个小朋友手上分别有多少糖果。
## 输入格式

一行，$5$ 个用空格隔开的 `int` 范围内的正整数，分别是游戏开始时  $1,2,3,4,5$ 号小朋友手里糖果的数量。
## 输出格式

$2$ 行，第 $1$ 行是用一个空格隔开的 $5$ 个整数，表示一轮游戏结束后  $1,2,3,4,5$ 号小朋友手里糖果的数量。第 $2$ 行是一个整数，表示一轮游戏过程中吃掉的糖果的总数。
## 样例

### 样例输入 #1
```
8 9 10 11 12
```
### 样例输出 #1
```
11 7 9 11 6
6
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10],sum=0;
int main()
{
for(int i=1;i<=5;i++)
{
cin>>a[i];
}
for(int i=1;i<=5;i++)
{
sum+=a[i]%3;
a[i]-=a[i]%3;
if(i==1)
{
a[2]+=a[i]/3;
a[5]+=a[i]/3;
}
else if(i==5)
{
a[1]+=a[i]/3;
a[4]+=a[i]/3;
}
else
{
a[i+1]+=a[i]/3;
a[i-1]+=a[i]/3;
}
a[i]-=a[i]/3*2;
}
for(int i=1;i<=5;i++)
{
cout<<a[i]<<" ";
}
cout<<endl;
cout<<sum;
return 0;
}
```

---

## 题目: B2021

**提交时间：2024-08-16 15:15:47**

---
title: "输出保留 3 位小数的浮点数"
layout: "post"
diff: 入门
pid: B2021
tag: ['顺序结构']
---
# 输出保留 3 位小数的浮点数
## 题目描述

读入一个单精度浮点数，保留 $3$ 位小数输出这个浮点数。

**提示：无需考虑浮点误差。**
## 输入格式

只有一行，一个单精度浮点数。
## 输出格式

也只有一行，读入的单精度浮点数。
## 样例

### 样例输入 #1
```
12.34521
```
### 样例输出 #1
```
12.345
```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
float n;
int main()
{
cin>>n;
cout<<fixed<<setprecision(3)<<n;
return 0;
}
```

---

## 题目: B2022

**提交时间：2024-08-16 15:17:08**

---
title: "输出保留 12 位小数的浮点数"
layout: "post"
diff: 入门
pid: B2022
tag: ['顺序结构']
---
# 输出保留 12 位小数的浮点数
## 题目描述

读入一个双精度浮点数，保留 $12$ 位小数，输出这个浮点数。

**提示：无需考虑浮点误差。**
## 输入格式

只有一行，一个双精度浮点数。
## 输出格式

也只有一行，保留 $12$ 位小数的浮点数。
## 样例

### 样例输入 #1
```
3.1415926535798932

```
### 样例输出 #1
```
3.141592653580
```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
double n;
int main()
{
cin>>n;
cout<<fixed<<setprecision(12)<<n;
return 0;
}
```

---

## 题目: B2023

**提交时间：2024-08-16 15:20:03**

---
title: "空格分隔输出"
layout: "post"
diff: 入门
pid: B2023
tag: ['顺序结构']
---
# 空格分隔输出
## 题目描述

读入一个字符，一个整数，一个单精度浮点数，一个双精度浮点数，然后按顺序输出它们，并且要求在他们之间用一个空格分隔。输出浮点数时保留 $6$ 位小数。
## 输入格式

第一行是一个字符；

第二行是一个整数；

第三行是一个单精度浮点数；

第四行是一个双精度浮点数。
## 输出格式

输出字符、整数、单精度浮点数和双精度浮点数，之间用空格分隔。
## 样例

### 样例输入 #1
```
a
12
2.3
3.2
```
### 样例输出 #1
```
a 12 2.300000 3.200000
```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
char a;
int b;
float c;
double d;
int main()
{
cin>>a>>b>>c>>d;
cout<<a<<" "<<b<<" ";
cout<<fixed<<setprecision(6)<<c<<" "<<d;
return 0;
}
```

---

## 题目: B2024

**提交时间：2024-09-16 09:07:26**

---
title: "输出浮点数"
layout: "post"
diff: 入门
pid: B2024
tag: ['顺序结构']
---
# 输出浮点数
## 题目描述

读入一个双精度浮点数，分别按输出格式 `%f` ，`%f` 保留 $5$ 位小数，`%e` 和 `%g` 的形式输出这个数，每次在单独一行上输出。
## 输入格式

一个双精度浮点数。
## 输出格式

第一行是按 `%f` 输出的双精度浮点数；

第二行是按 `%f` 保留 $5$ 位小数输出的双精度浮点数；

第三行是按 `%e` 输出的双精度浮点数；

第四行是按 `%g` 输出的双精度浮点数。
## 样例

### 样例输入 #1
```
12.3456789
```
### 样例输出 #1
```
12.345679
12.34568
1.234568e+01
12.3457
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double n;
int main()
{
cin>>n;
printf("%f",n);
printf("\n%.5f",n);
printf("\n%e",n);
printf("\n%g",n);
return 0;
}
```

---

## 题目: B2025

**分类：入门-顺序结构**

**提交时间：2023-11-10 15:00:50**

---
title: "输出字符菱形"
layout: "post"
diff: 入门
pid: B2025
tag: ['顺序结构']
---
# 输出字符菱形
## 题目描述

用 `*` 构造一个对角线长 $5$ 个字符，倾斜放置的菱形。
## 输入格式

没有输入要求。
## 输出格式

如样例所示。用 `*` 构成的菱形。
## 样例

### 样例输入 #1
```

```
### 样例输出 #1
```
  *
 ***
*****
 ***
  *

```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
cout<<"  *"<<endl;
cout<<" ***"<<endl;
cout<<"*****"<<endl;
cout<<" ***"<<endl;
cout<<"  *"<<endl;
return 0;
}
```

---

## 题目: B2026

**提交时间：2024-09-16 09:10:42**

---
title: "计算浮点数相除的余"
layout: "post"
diff: 入门
pid: B2026
tag: ['Special Judge', '顺序结构']
---
# 计算浮点数相除的余
## 题目描述

计算两个双精度浮点数 $a$ 和 $b$ 的相除的余数，$a$ 和 $b$ 都是双精度浮点数。这里余数（$r$）的定义是：$a=k \times b+r$，其中 $k$ 是整数，$0 \le r<b$。
## 输入格式

输入仅一行，包括两个双精度浮点数 $a$ 和 $b$。
## 输出格式

输出也仅一行，$a/b$ 的余数。

选手输出与标准答案的绝对误差或相对误差不超过 $10^{-5}$ 即视为正确。
## 样例

### 样例输入 #1
```
73.263 0.9973
```
### 样例输出 #1
```
0.4601
```
## 提示

### 「暂时的」数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq a \leq 10 ^ 6$，$1 \leq b \leq 10 ^ 3$，$a > b$。

> **为什么是「暂时的」？**  
> 原题没有标注数据范围，并且由于涉及到浮点数取模，一些情况想要进行处理是很费劲的。所以暂时设置一个较为宽松的数据规模约定。后续数据可能会进行加强。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b;
int k;
int main()
{
cin>>a>>b;
k=a/b;
cout<<a-k*b;
return 0;
}
```

---

## 题目: B2027

**提交时间：2024-09-16 09:17:07**

---
title: "计算球的体积"
layout: "post"
diff: 入门
pid: B2027
tag: ['顺序结构']
---
# 计算球的体积
## 题目描述

已知球半径为 $r$ 时，球的体积为 $V=\frac{4}{3}\pi r^3$。

小理手里有个半径为 $r$ 的球体，他现在想知道这个球的体积为多少？

**计算时，取 $\pi = 3.14$**。
## 输入格式

输入共一行，其中包括一个正整数 $r$ 表示球体的半径。
## 输出格式

输出共一行，其中包括球体的体积。**要求保留小数点后$5$ 位**。
## 样例

### 样例输入 #1
```
5
```
### 样例输出 #1
```
523.33333
```
## 提示

$1\leq r\leq 100$。 


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double x,n;
int main()
{
cin>>n;
x=(4*1.00000/3)*3.14*(n*1.00)*(n*1.00)*(n*1.00);
printf("%.5f",x);
return 0;
}
```

---

## 题目: B2028

**提交时间：2024-01-13 21:03:55**

---
title: "反向输出一个三位数"
layout: "post"
diff: 入门
pid: B2028
tag: ['顺序结构']
---
# 反向输出一个三位数
## 题目描述

将一个三位数反向输出，例如输入 $358$，反向输出 $853$。
## 输入格式

一个三位数 $n$。
## 输出格式

反向输出 $n$。
## 样例

### 样例输入 #1
```
100
```
### 样例输出 #1
```
001
```
### 样例输入 #2
```
001
```
### 样例输出 #2
```
100
```
### 样例输入 #3
```
678
```
### 样例输出 #3
```
876
```


### 代码

```cpp
#include <iostream>
using namespace std;
int a,b,c,x;
int main()
{
cin>>x;
a=x/100;
b=x%100/10;
c=x%100%10/1;
cout<<c<<b<<a;
}
```

---

## 题目: B2029

**分类：入门-顺序结构**

**提交时间：2023-12-10 21:35:26**

---
title: "大象喝水"
layout: "post"
diff: 入门
pid: B2029
tag: ['顺序结构']
---
# 大象喝水
## 题目描述

一只大象口渴了，要喝 $20$ 升水才能解渴，但现在只有一个深 $h$ 厘米，底面半径为 $r$ 厘米的小圆桶 （$h$ 和 $r$ 都是整数）。问大象至少要喝多少桶水才会解渴。

**Update：数据更新，这里我们近似地取圆周率 $\pi = 3.14$。**
## 输入格式

输入有一行：包行两个整数，以一个空格分开，分别表示小圆桶的深 $h$ 和底面半径 $r$，单位都是厘米。
## 输出格式

输出一行，包含一个整数，表示大象至少要喝水的桶数。
## 样例

### 样例输入 #1
```
23 11
```
### 样例输出 #1
```
3
```
## 提示

### 数据规模与约定
对于全部的测试点，保证 $1 \leq h \leq 500$，$1 \leq r \leq 100$。


### 代码

```cpp
#include<iostream>
using namespace std;
int h,r,a;
int main(){
cin>>h>>r;
a=2*10000/(3.14*r*r*h)+1;
cout<<a;
return 0;
}
```

---

## 题目: B2030

**提交时间：2024-10-19 20:54:47**

---
title: "计算线段长度"
layout: "post"
diff: 入门
pid: B2030
tag: ['顺序结构']
---
# 计算线段长度
## 题目描述

已知线段的两个端点的坐标 `A(Xa,Ya)`，`B(Xb
,Yb)` ，求线段 AB 的长度。
## 输入格式

输入。

共两行。

第一行是两个实数 $Xa，Ya$，即 $A$ 的坐标。

第二行是两个实数 $Xb，Yb$，即 $B$ 的坐标。

输入中所有实数的绝对值均不超过 $10000$。
## 输出格式

输出。

一个实数，即线段 $AB$ 的长度，保留到小数点后 $3$ 位。
## 样例

### 样例输入 #1
```
1 1
2 2
```
### 样例输出 #1
```
1.414
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y,X,Y;
float ans;
int main(){
cin>>x>>y>>X>>Y;
ans=sqrt((x-X)*(x-X)+(y-Y)*(y-Y));
printf("%.3f",ans);
return 0;
}
```

---

## 题目: B2032

**提交时间：2024-10-19 21:00:38**

---
title: "等差数列末项计算"
layout: "post"
diff: 入门
pid: B2032
tag: ['顺序结构']
---
# 等差数列末项计算
## 题目描述

等差数列是一个很有趣的数列，它的任何相邻两项的差相等。

现在给出一个等差数列的前两项 $a_1,a_2$ 的值，求第 $n$ 项是多少。
## 输入格式

一行，包含三个整数 $a_1,a_2,n$（$-100 \le a_1,a_2 \le 100$，$0<n \le 1000$。）
## 输出格式

一个整数，即第 $n$ 项的值。
## 样例

### 样例输入 #1
```
1 4 100
```
### 样例输出 #1
```
298
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,t,ans;
int main(){
cin>>a>>b>>t;
ans=a+(b-a)*(t-1);
cout<<ans;
return 0;
}
```

---

## 题目: B2033

**提交时间：2024-10-19 21:02:12**

---
title: "A*B 问题"
layout: "post"
diff: 入门
pid: B2033
tag: ['顺序结构']
---
# A*B 问题
## 题目描述

输入两个正整数 $A$ 和 $B$，求 $A \times B$ 的值。注意乘积的范围和数据类型的选择。
## 输入格式

一行，包含两个正整数 $A$ 和 $B$，中间用单个空格隔开。$1 \le A,B \le 50000$。
## 输出格式

一个整数，即 $A \times B$ 的值。
## 样例

### 样例输入 #1
```
3 4
```
### 样例输出 #1
```
12
```
### 样例输入 #2
```
36 18
```
### 样例输出 #2
```
648
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b;
int main(){
cin>>a>>b;
cout<<a*b;
return 0;
}
```

---

## 题目: B2034

**提交时间：2024-10-25 16:33:49**

---
title: "计算 2 的幂"
layout: "post"
diff: 入门
pid: B2034
tag: ['顺序结构']
---
# 计算 2 的幂
## 题目描述

给定非负整数 $n$，求 $2^n$ 的值。
## 输入格式

一个整数 $n$。$0\le n<31$。
## 输出格式

一个整数，即 $2$ 的 $n$ 次方。

请注意，如果您正在使用 `cout` 进行输出，您需要关注被输出的数据的类型。输出格式不符合预期可能会造成答案错误。

常用函数的返回值类型可以在 [cppreference.com](https://en.cppreference.com/w/) 和 [cplusplus.com](https://cplusplus.com/) 查询到。例如，您可以在这两个网站中查到 `pow` 函数的返回值是 `float` 或 `double`。

您可以使用显式或隐式的类型转换，来变换数据类型。
## 样例

### 样例输入 #1
```
3
```
### 样例输出 #1
```
8
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
cin>>n;
cout<<(1<<n);
return 0;
}
```

---

## 题目: B2035

**提交时间：2024-01-07 08:52:47**

---
title: "判断数正负"
layout: "post"
diff: 入门
pid: B2035
tag: ['分支结构']
---
# 判断数正负
## 题目描述

给定一个整数 $N$，判断其正负。如果 $N>0$, 输出 `positive` ; 如果 $N=0$, 输出 `zero` ; 如果 $N<0,$ 输出 `negative`。
## 输入格式

一个整数 $N(-10^9 \le N \le 10^9)$。
## 输出格式

如果 $N>0$， 输出 `positive`; 

如果 $N=0$, 输出 `zero`； 

如果 $N<0$， 输出 `negative`。
## 样例

### 样例输入 #1
```
95
```
### 样例输出 #1
```
positive
```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int a;
cin >> a;
if (a > 0)
{
cout <<"positive";
}
else if (a == 0)
{
cout <<"zero";
}
else
{
cout <<"negative";
}
return 0;
}
```

---

## 题目: B2036

**提交时间：2024-10-20 14:31:18**

---
title: "输出绝对值"
layout: "post"
diff: 入门
pid: B2036
tag: ['分支结构']
---
# 输出绝对值
## 题目描述

输入一个浮点数 $n$，输出这个浮点数的绝对值。
## 输入格式

输入一个浮点数 $n$，其绝对值不超过 $10000$。
## 输出格式

输出 $n$ 的绝对值，保留到小数点后两位。
## 样例

### 样例输入 #1
```
-3.14
```
### 样例输出 #1
```
3.14
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
float n;
int main(){
cin>>n;
printf("%.2f",abs(n));
return 0;
}
```

---

## 题目: B2037

**提交时间：2024-11-16 20:57:02**

---
title: "奇偶数判断"
layout: "post"
diff: 入门
pid: B2037
tag: ['分支结构']
---
# 奇偶数判断
## 题目描述

给定一个整数，判断该数是奇数还是偶数。如果 $n$ 是奇数，输出 `odd`；如果 $n$ 是偶数，输出 `even`。
## 输入格式

输入仅一行，一个整数 $n$。
## 输出格式

输出仅一行，如果 $n$ 是奇数，输出 `odd`；如果 $n$ 是偶数，输出 `even`。
## 样例

### 样例输入 #1
```
5
```
### 样例输出 #1
```
odd
```
### 样例输入 #2
```
10
```
### 样例输出 #2
```
even
```
## 提示

$-100\le n\le 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
cin>>n;
if(n%2){
cout<<"odd";
}
else{
cout<<"even";
}
return 0;
}
```

---

## 题目: B2038

**提交时间：2024-11-17 13:02:56**

---
title: "奇偶 ASCII 值判断"
layout: "post"
diff: 入门
pid: B2038
tag: ['分支结构']
---
# 奇偶 ASCII 值判断
## 题目描述

任意输入一个字符，判断其 ASCII 是否是奇数，若是，输出 `YES`，否则，输出 `NO` 。

例如，字符 `A` 的 ASCII 值是 `65`，则输出 `YES`，若输入字符 `B`(ASCII 值是 $66$)，则输出 `NO`。
## 输入格式

输入一个字符。
## 输出格式

如果其 ASCII 值为奇数，则输出 `YES`，否则，输出 `NO`。
## 样例

### 样例输入 #1
```
A
```
### 样例输出 #1
```
YES
```
### 样例输入 #2
```
B
```
### 样例输出 #2
```
NO
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char n;
int main(){
cin>>n;
if((n-'0'+'0')%2==1){
cout<<"YES";
}
else{
cout<<"NO";
}
return 0;
}
```

---

## 题目: B2039

**提交时间：2024-11-24 14:45:21**

---
title: "整数大小比较"
layout: "post"
diff: 入门
pid: B2039
tag: ['分支结构']
---
# 整数大小比较
## 题目描述

输入两个整数，比较它们的大小。若 $x>y$ ，输出 `>` ；若 $x=y$ ，输出 `=` ；若 $x<y$，输出 `<` 。
## 输入格式

一行，包含两个整数 $x$ 和 $y$ ，中间用单个空格隔开。 $0 \le x<2^{32}, -2^{31} \le y<2^{31}$ 。
## 输出格式

一个字符。若 $x>y$，输出 `>` ；若 $x=y$ ，输出 `=` ；若 $x<y$ ，输出 `<` ；
## 样例

### 样例输入 #1
```
1000 100
```
### 样例输出 #1
```
>
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long x,y;
int main(){
cin>>x>>y;
if(x>y){
cout<<">";
}
else if(x<y){
cout<<"<";
}
else{
cout<<"=";
}
return 0;
}
```

---

## 题目: B2040

**提交时间：2024-11-24 14:46:23**

---
title: "判断是否为两位数"
layout: "post"
diff: 入门
pid: B2040
tag: ['分支结构']
---
# 判断是否为两位数
## 题目描述

判断一个正整数是否是两位数（即大于等于 $10$ 且小于等于 $99$）。
## 输入格式

一个正整数，不超过 $1000$。
## 输出格式

一行。若该正整数是两位数，输出 $1$，否则输出 $0$。
## 样例

### 样例输入 #1
```
54
```
### 样例输出 #1
```
1
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
cin>>n;
if(n>=10&&n<=99){
cout<<1;
}
else{
cout<<0;
}
return 0;
}
```

---

## 题目: B2041

**提交时间：2024-11-24 14:47:35**

---
title: "收集瓶盖赢大奖"
layout: "post"
diff: 入门
pid: B2041
tag: ['分支结构']
---
# 收集瓶盖赢大奖
## 题目描述

某饮料公司最近推出了一个“收集瓶盖赢大奖”的活动：如果你拥有 $10$ 个印有“幸运”、或 $20$ 个印有“鼓励”的瓶盖，就可以兑换一个神秘大奖。现分别给出你拥有的印有“幸运”和“鼓励”的瓶盖数，判断是否可以去兑换大奖。若可以兑换大奖，输出 `1` ，否则输出 `0` 。
## 输入格式

一行，包含两个整数，分别是印有“幸运”和“鼓励”的瓶盖数，用一个空格隔开。
## 输出格式

一行。若可以兑换大奖，输出 $1$ ，否则输出 $0$。
## 样例

### 样例输入 #1
```
11 19
```
### 样例输出 #1
```
1
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y;
int main(){
cin>>x>>y;
if(x>=10||y>=20){
cout<<1;
}
else{
cout<<0;
}
return 0;
}
```

---

## 题目: B2042

**提交时间：2024-11-24 14:56:03**

---
title: "判断一个数能否同时被 3 和 5 整除"
layout: "post"
diff: 入门
pid: B2042
tag: ['分支结构']
---
# 判断一个数能否同时被 3 和 5 整除
## 题目描述

判断一个数 $n$ 能否同时被 $3$ 和 $5$ 整除。
## 输入格式

输入一行，包含一个整数 $n$。
## 输出格式

输出一行，如果能同时被 $3$ 和 $5$ 整除输出 `YES`，否则输出 `NO`。
## 样例

### 样例输入 #1
```
15
```
### 样例输出 #1
```
YES
```
## 提示

（$-10^9<n<10^9$）


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
cin>>n;
if(n%3==0&&n%5==0){
cout<<"YES";
}
else{
cout<<"NO";
}
return 0;
}
```

---

## 题目: B2043

**提交时间：2024-11-30 20:51:47**

---
title: "判断能否被 3，5，7 整除"
layout: "post"
diff: 入门
pid: B2043
tag: ['分支结构']
---
# 判断能否被 3，5，7 整除
## 题目描述

给定一个整数 $x$，判断它能否被 $3$，$5$，$7$ 整除，并输出以下信息：

1、能同时被 $3,5,7$ 整除（直接输出 `3 5 7`，每个数中间一个空格）；

2、只能被其中两个数整除（按从小到大的顺序输出两个数，例如：`3 5` 或者 `3 7` 或者 `5 7`，中间用空格分隔）；

3、只能被其中一个数整除（输出这个除数）；

4、不能被任何数整除，输出小写字符 `n`。
## 输入格式

输入一行，包括一个整数 $x$。
## 输出格式

输出一行，按照描述要求给出整数被 $3$，$5$，$7$ 整除的情况。
## 样例

### 样例输入 #1
```
105
```
### 样例输出 #1
```
3 5 7
```
## 提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq 200$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
bool flag=0;
int main(){
cin>>n;
if(n%3==0){
cout<<3<<" ";
flag=1;
}
if(n%5==0){
cout<<5<<" ";
flag=1;
}
if(n%7==0){
cout<<7<<" ";
flag=1;
}
if(flag==0){
cout<<"n";
}
return 0;
}
```

---

## 题目: B2044

**提交时间：2024-11-30 20:53:34**

---
title: "有一门课不及格的学生"
layout: "post"
diff: 入门
pid: B2044
tag: ['分支结构']
---
# 有一门课不及格的学生
## 题目描述

给出一名学生的语文、数学、英语成绩，判断他是否恰好有一门课不及格（成绩小于 $60$ 分）。若该学生恰好有一门成绩不及格输出 $1$，否则输出 $0$。
## 输入格式

一行包含三个 $0 \sim 100$ 之间的整数，分别表示该生的语文、数学、英语成绩。
## 输出格式

该学生恰好有一门成绩不及格输出 $1$，否则输出 $0$。
## 样例

### 样例输入 #1
```
59 60 61
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
59 50 59
```
### 样例输出 #2
```
0
```
### 样例输入 #3
```
100 100 90
```
### 样例输出 #3
```
0
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int c,m,e,sum=0;
int main(){
cin>>c>>m>>e;
if(c<60){
sum+=1;
}
if(m<60){
sum+=1;
}
if(e<60){
sum+=1;
}
if(sum==1){
cout<<1;
}
else{
cout<<0;
}
return 0;
}
```

---

## 题目: B2045

**提交时间：2024-11-30 20:54:53**

---
title: "晶晶赴约会"
layout: "post"
diff: 入门
pid: B2045
tag: ['分支结构']
---
# 晶晶赴约会
## 题目描述

晶晶的朋友贝贝约晶晶下周一起去看展览，但晶晶每周的 $1,3,5$ 有课必须上课，请帮晶晶判断她能否接受贝贝的邀请，如果能输出 `YES`；如果不能则输出 `NO`。
## 输入格式

输入有一行，贝贝邀请晶晶去看展览的日期，用数字 $1$ 到 $7$ 表示从星期一到星期日。
## 输出格式

输出有一行，如果晶晶可以接受贝贝的邀请，输出 `YES`，否则，输出 `NO`。注意 `YES` 和 `NO` 都是大写字母！
## 样例

### 样例输入 #1
```
2
```
### 样例输出 #1
```
YES
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
cin>>n;
if(n!=1&&n!=3&&n!=5){
cout<<"YES";
}
else{
cout<<"NO";
}
return 0;
}
```

---

## 题目: B2046

**提交时间：2024-11-30 21:01:50**

---
title: "骑车与走路"
layout: "post"
diff: 入门
pid: B2046
tag: ['分支结构']
---
# 骑车与走路
## 题目描述

在清华校园里，没有自行车，上课办事会很不方便。但实际上。并非去办任何事情都是骑车快，因为骑车总要找车、开锁、停车、锁车等，这要耽误一些时间。假设找到自行车，开锁，上车起步的时间为 $27$ 秒；停车锁车的时间为 $23$ 秒；步行每秒行走 $1.2$ 米，骑车每秒行走 $3.0$ 米。请判断走不同的距离去办事，是骑车快还是走路快。
## 输入格式

输入一行，包含一个整数，表示一次办事要行走的距离，单位为米。
## 输出格式

- 如果骑车快，输出一行 `Bike`；

- 如果走路快，输出一行 `Walk`；

- 如果一样快，输出一行 `All`。
## 样例

### 样例输入 #1
```
1
```
### 样例输出 #1
```
Walk
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
double x,y;
int main(){
cin>>n;
x=n/1.2;
y=50+n/3.0;
if(x>y){
cout<<"Bike";
}
else if(x<y){
cout<<"Walk";
}
else{
cout<<"All";
}
return 0;
}
```

---

## 题目: B2047

**提交时间：2024-11-30 21:48:56**

---
title: "分段函数"
layout: "post"
diff: 入门
pid: B2047
tag: ['分支结构']
---
# 分段函数
## 题目描述

编写程序，计算下列分段函数 $y=f(x)$ 的值。

当 $0 \le x<5$ 时，$y=-x+2.5$。

当 $5 \le x<10$ 时，$y=2-1.5(x-3)(x-3)$。

当 $10 \le x<20$ 时，$y=x/2-1.5$。
## 输入格式

一个浮点数 $x$。
## 输出格式

输出 $x$ 对应的分段函数值：$f(x)$。结果保留到小数点后三位。
## 样例

### 样例输入 #1
```
1.0
```
### 样例输出 #1
```
1.500
```
## 提示

对于 100% 的数据 $0 \le x<20$


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double x,y;
int main(){
cin>>x;
if(x<5){
y=x-2*x+2.5;
}
else if(x<10){
y=2-1.5*(x-3)*(x-3);
}
else{
y=x/2-1.5;
}
printf("%.3f",y);
return 0;
}
```

---

## 题目: B2048

**提交时间：2024-11-30 21:52:10**

---
title: "计算邮资"
layout: "post"
diff: 入门
pid: B2048
tag: ['分支结构']
---
# 计算邮资
## 题目描述

请根据邮件的重量和用户选择是否加急计算邮费。计算规则：

- 重量在 $1000$ 以内（包括），基本费 $8$ 元；

- 超过 $1000$ 克的部分，每 $500$ 克加收超重费 $4$ 元，不足 $500$ 克部分按 $500$ 克计算；

- 如果用户选择加急，多收 $5$ 元。
## 输入格式

一行，包含一个正整数 $x$ 和一个字符 c(`y` 或 `n`)，之间用一个空格隔开，分别表示重量和是否加急。

如果字符是 `y`，说明选择加急；如果字符是 `n`，说明不加急。
## 输出格式

输出一行一个正整数，表示邮费。
## 样例

### 样例输入 #1
```
1200 y
```
### 样例输出 #1
```
17
```
## 提示

对于100%数据 $1\leq x\leq 10^6$


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,sum=0;
char c;
int main(){
cin>>x>>c;
if(x<=1000){
sum+=8;
}
else{
sum+=8;
if(x%500==0){
sum+=(x-1000)/500*4;
}
else{
sum+=((x-1000)/500+1)*4;
}
}
if(c=='y'){
sum+=5;
}
cout<<sum;
return 0;
}
```

---

## 题目: B2049

**提交时间：2024-11-30 21:53:29**

---
title: "最大数输出"
layout: "post"
diff: 入门
pid: B2049
tag: ['分支结构']
---
# 最大数输出
## 题目描述

输入三个整数，输出最大的数。
## 输入格式

输入为一行，包含三个整数，数与数之间以一个空格分开。
## 输出格式

输出一行，包含一个整数，即最大的整数。
## 样例

### 样例输入 #1
```
10 20 56
```
### 样例输出 #1
```
56
```
## 提示

### 数据规模与约定

对于全部的测试点，保证输入的整数均在 32 位有符号整型 (`int`/`long int`) 范围内。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a,b,c;
int main(){
cin>>a>>b>>c;
cout<<max(a,max(b,c));
return 0;
}
```

---

## 题目: B2050

**提交时间：2024-11-30 21:55:16**

---
title: "三角形判断"
layout: "post"
diff: 入门
pid: B2050
tag: ['分支结构']
---
# 三角形判断
## 题目描述

给定三个正整数，分别表示三条线段的长度，判断这三条线段能否构成一个三角形。
## 输入格式

输入共一行，包含三个正整数，分别表示三条线段的长度，数与数之间以一个空格分开。（三条边的长度均不超过 $10000$）
## 输出格式

如果能构成三角形，则输出 `1` ，否则输出 `0`。
## 样例

### 样例输入 #1
```
1 1 1
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
1 1 3
```
### 样例输出 #2
```
0
```
## 提示

构成三角形的条件：

任意两边长度之和大于第三条边的长度。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c;
int main(){
cin>>a>>b>>c;
if(a+b>c&&a+c>b&&b+c>a){
cout<<1;
}
else{
cout<<0;
}
return 0;
}
```

---

## 题目: B2051

**提交时间：2024-11-30 22:03:22**

---
title: "点和正方形的关系"
layout: "post"
diff: 入门
pid: B2051
tag: ['分支结构']
---
# 点和正方形的关系
## 题目描述

有一个正方形，四个角的坐标 $(x,y)$ 分别是 $(1,-1)$、$(1,1)$、$(-1,-1)$、$(-1,1)$，$x$ 是横轴，$y$ 是纵轴。写一个程序，判断一个给定的点是否在这个正方形内（包括正方形边界）。
## 输入格式

输入一行，包括两个整数 $x,y$，以一个空格分开，表示坐标 $(x,y)$。
## 输出格式

输出一行，如果点在正方形内，则输出 `yes`，否则输出 `no`。
## 样例

### 样例输入 #1
```
1 1
```
### 样例输出 #1
```
yes
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y;
int main(){
cin>>x>>y;
if(x>=-1&&x<=1&&y>=-1&&y<=1){
cout<<"yes";
}
else{
cout<<"no";
}
return 0;
}
```

---

## 题目: B2097

**提交时间：2024-09-03 20:02:28**

---
title: "最长平台"
layout: "post"
diff: 入门
pid: B2097
tag: ['数组']
---
# 最长平台
## 题目描述

对于一个数组，其连续的相同段叫做一个平台，例如，在 $1$，$2$，$2$，$3$，$3$，$3$，$4$，$5$，$5$，$6$ 中 $1$，$2-2$，$3-3-3$，$4$，$5-5$，$6$ 都是平台。

编写一个程序，接收一个数组，找出最长的平台。在上面的例子中 $3-3-3$ 就是最长的平台。
## 输入格式

第一行有一个整数 $n$，为数组元素的个数。（$1 \le n \le 100$）

第二行有 $n$ 个整数，整数之间以一个空格分开，整数 $k$ 范围（$0<k<2000$）。
## 输出格式

输出最长平台的长度。
## 样例

### 样例输入 #1
```
10
1 2 2 3 3 3 4 5 5 6
```
### 样例输出 #1
```
3
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long a[1000005],sum=1,maxn=0,x=-1;
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
for(int i=1;i<=n;i++)
{
if(a[i]!=x)
{
x=a[i];
maxn=max(maxn,sum);
sum=1;
}
else
{
sum+=1;
}
}
cout<<maxn;
return 0;
}
```

---

## 题目: B3612

**提交时间：2024-10-27 13:14:47**

---
title: "【深进1.例1】求区间和"
layout: "post"
diff: 普及-
pid: B3612
tag: ['O2优化', '前缀和']
---
# 【深进1.例1】求区间和
## 题目描述

给定 $n$ 个正整数组成的数列 $a_1, a_2, \cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这 $m$ 个区间的区间和。
## 输入格式

第一行，为一个正整数 $n$ 。

第二行，为 $n$ 个正整数 $a_1,a_2, \cdots ,a_n$

第三行，为一个正整数 $m$ 。

接下来 $m$ 行，每行为两个正整数 $l_i,r_i$ ，满足 $1\le l_i\le r_i\le n$
## 输出格式

共 $m$ 行。

第 $i$ 行为第 $i$ 组答案的询问。
## 样例

### 样例输入 #1
```
4
4 3 2 1
2
1 4
2 3
```
### 样例输出 #1
```
10
5
```
## 提示

样例解释：第 1 到第 4 个数加起来和为 10。第 2 个数到第 3 个数加起来和为 5。

对于 $50\%$ 的数据：$n,m\le 1000$ ；

对于 $100\%$ 的数据：$1 \leq n,m\le 10^5$，$1 \leq a_i\le 10^4$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],s[100005],x,y;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
s[i]=a[i]+s[i-1];
}
cin>>m;
for(int i=1;i<=n;i++){
cin>>x>>y;
cout<<s[y]-s[x-1]<<endl;
}
return 0;
}
```

---

## 题目: B3621

**分类：搜索**

**提交时间：2025-03-23 10:57:49**

---
title: "枚举元组"
layout: "post"
diff: 普及-
pid: B3621
tag: ['深度优先搜索 DFS']
---
# 枚举元组
## 题目描述

$n$ 元组是指由 $n$ 个元素组成的序列。例如 $(1,1,2)$ 是一个三元组、$(233,254,277,123)$ 是一个四元组。

给定 $n$ 和 $k$，请按字典序输出全体 $n$ 元组，其中元组内的元素是在 $[1, k]$ 之间的整数。

「字典序」是指：优先按照第一个元素从小到大的顺序，若第一个元素相同，则按第二个元素从小到大……依此类推。详情参考样例数据。
## 输入格式

仅一行，两个正整数 $n, k$。
## 输出格式

若干行，每行表示一个元组。元组内的元素用空格隔开。
## 样例

### 样例输入 #1
```
2 3
```
### 样例输出 #1
```
1 1
1 2
1 3
2 1
2 2
2 3
3 1
3 2
3 3
```
### 样例输入 #2
```
3 3
```
### 样例输出 #2
```
1 1 1
1 1 2
1 1 3
1 2 1
1 2 2
1 2 3
1 3 1
1 3 2
1 3 3
2 1 1
2 1 2
2 1 3
2 2 1
2 2 2
2 2 3
2 3 1
2 3 2
2 3 3
3 1 1
3 1 2
3 1 3
3 2 1
3 2 2
3 2 3
3 3 1
3 3 2
3 3 3
```
## 提示

对于 $100\%$ 的数据，有 $n\leq 5, k\leq 4$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[20];
void dfs(int dep){
if(dep>k){
for(int i=1;i<=k;i++){
cout<<a[i]<<" ";
}
cout<<endl;
return;
}
for(int i=1;i<=n;i++){
a[dep]=i;
dfs(dep+1);
}
}
int main(){
cin>>k>>n;
dfs(1);
return 0;
}
```

---

## 题目: B3622

**提交时间：2024-10-23 19:54:28**

---
title: "枚举子集（递归实现指数型枚举）"
layout: "post"
diff: 普及-
pid: B3622
tag: ['深度优先搜索 DFS']
---
# 枚举子集（递归实现指数型枚举）
## 题目描述

今有 $n$ 位同学，可以从中选出任意名同学参加合唱。

请输出所有可能的选择方案。
## 输入格式

仅一行，一个正整数 $n$。
## 输出格式

若干行，每行表示一个选择方案。

每一种选择方案用一个字符串表示，其中第 $i$ 位为 `Y` 则表示第 $i$ 名同学参加合唱；为 `N` 则表示不参加。

需要以字典序输出答案。
## 样例

### 样例输入 #1
```
3
```
### 样例输出 #1
```
NNN
NNY
NYN
NYY
YNN
YNY
YYN
YYY
```
## 提示

对于 $100\%$ 的数据，保证 $1\leq n\leq 10$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,t,ans,a[1050];
int main(){
cin>>n;
for(int i=0;i<(1<<n);i++){
int x=i;
t=1;
while(x>0){
if(x%2){
a[t]=1;
}
else{
a[t]=0;
}
t+=1;
x/=2;
}
for(int i=n;i>=1;i--){
if(a[i]==1){
cout<<"Y";
}
else{
cout<<"N";
}
}
cout<<endl;
}
return 0;
}
```

---

## 题目: B3623

**提交时间：2025-03-23 10:55:34**

---
title: "枚举排列（递归实现排列型枚举）"
layout: "post"
diff: 普及-
pid: B3623
tag: ['深度优先搜索 DFS']
---
# 枚举排列（递归实现排列型枚举）
## 题目描述

今有 $n$ 名学生，要从中选出 $k$ 人排成一列拍照。

请按字典序输出所有可能的排列方式。
## 输入格式

仅一行，两个正整数 $n, k$。
## 输出格式

若干行，每行 $k$ 个正整数，表示一种可能的队伍顺序。
## 样例

### 样例输入 #1
```
3 2
```
### 样例输出 #1
```
1 2
1 3
2 1
2 3
3 1
3 2
```
## 提示

对于 $100\%$ 的数据，$1\leq k\leq n \leq 10$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[20],vis[20];
void dfs(int dep){
if(dep>k){
for(int i=1;i<=k;i++){
cout<<a[i]<<" ";
}
cout<<endl;
return;
}
for(int i=1;i<=n;i++){
if(!vis[i]){
vis[i]=1;
a[dep]=i;
dfs(dep+1);
vis[i]=0;
}
}
}
int main(){
cin>>n>>k;
dfs(1);
return 0;
}
```

---

## 题目: B3637

**提交时间：2025-03-02 13:28:16**

---
title: "最长上升子序列"
layout: "post"
diff: 普及-
pid: B3637
tag: ['动态规划 DP']
---
# 最长上升子序列
## 题目描述

这是一个简单的动规板子题。

给出一个由 $n(n\le 5000)$ 个不超过 $10^6$ 的正整数组成的序列。请输出这个序列的**最长上升子序列**的长度。

最长上升子序列是指，从原序列中**按顺序**取出一些数字排在一起，这些数字是**逐渐增大**的。
## 输入格式

第一行，一个整数 $n$，表示序列长度。

第二行有 $n$ 个整数，表示这个序列。
## 输出格式

一个整数表示答案。
## 样例

### 样例输入 #1
```
6
1 2 4 1 3 4
```
### 样例输出 #1
```
4
```
## 提示

分别取出 $1$、$2$、$3$、$4$ 即可。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int dp[5005],n,a[5005];
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
dp[i]=1;
}
for(int i=1;i<=n;i++){
for(int j=1;j<i;j++){
if(a[i]>a[j]){
dp[i]=max(dp[i],dp[j]+1);
}
}
}
int ans=0;
for(int i=1;i<=n;i++){
ans=max(ans,dp[i]);
}
cout<<ans;
return 0;
}
```

---

## 题目: B3642

**提交时间：2025-02-28 16:14:36**

---
title: "二叉树的遍历"
layout: "post"
diff: 普及-
pid: B3642
tag: ['树形数据结构']
---
# 二叉树的遍历
## 题目描述

有一个 $n(n \le 10^6)$ 个结点的二叉树。给出每个结点的两个子结点编号（均不超过 $n$），建立一棵二叉树（根节点的编号为 $1$），如果是叶子结点，则输入 `0 0`。

建好树这棵二叉树之后，依次求出它的前序、中序、后序列遍历。
## 输入格式

第一行一个整数 $n$，表示结点数。

之后 $n$ 行，第 $i$ 行两个整数 $l$、$r$，分别表示结点 $i$ 的左右子结点编号。若 $l=0$ 则表示无左子结点，$r=0$ 同理。
## 输出格式

输出三行，每行 $n$ 个数字，用空格隔开。

第一行是这个二叉树的前序遍历。

第二行是这个二叉树的中序遍历。

第三行是这个二叉树的后序遍历。
## 样例

### 样例输入 #1
```
7
2 7
4 0
0 0
0 3
0 0
0 5
6 0
```
### 样例输出 #1
```
1 2 4 3 7 6 5
4 3 2 1 6 5 7
3 4 2 5 6 7 1 
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct node{
int l,r;
}a[1000005];
void preorder(int rt){
cout<<rt<<" ";
if(a[rt].l!=0){
preorder(a[rt].l);
}
if(a[rt].r!=0){
preorder(a[rt].r);
}
}
void inorder(int rt){
if(a[rt].l!=0){
inorder(a[rt].l);
}
cout<<rt<<" ";
if(a[rt].r!=0){
inorder(a[rt].r);
}
}
void afterorder(int rt){
if(a[rt].l!=0){
afterorder(a[rt].l);
}
if(a[rt].r!=0){
afterorder(a[rt].r);
}
cout<<rt<<" ";
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i].l>>a[i].r;
}
preorder(1);
cout<<endl;
inorder(1);
cout<<endl;
afterorder(1);
return 0;
}
```

---

## 题目: B3684

**提交时间：2024-12-04 20:34:38**

---
title: "[语言月赛202212] 不可以，总司令"
layout: "post"
diff: 入门
pid: B3684
tag: ['2022', 'Special Judge', 'O2优化', '分支结构', '语言月赛']
---
# [语言月赛202212] 不可以，总司令
## 题目背景

> “同志，你只是一直在回答‘不可以’吗？你到底有没有好好判断形势？现在是关乎国家危亡的时刻……”
> 
> “总司令，您知道我不太聪明，没找到快速而正确地计算出结果的办法，但是据某项统计，我一直回答 NO 的话，在一次战役中判断完全正确的概率是 $45\%$。”

（全文见 <https://www.luogu.com.cn/discuss/525529>）
## 题目描述

扶苏当上了星战地球舰队的参谋长，但是她不太聪明。

人工智能计算出，如果扶苏在一直回答“NO”的话，她在战役中判断完全正确的概率为 $x\%$；如果她一直在回答“YES”的话，她在战役中判断完全正确的概率是 $y\%$。

注意可能 $x + y \neq 100$，因为还存在她需要既回答“YES”也回答“NO”的情况，但是这一概率并不重要，因为她并不聪明，只能在全回答“YES”和全回答“NO”之中做一个选择。

扶苏自然希望做出的判断能尽可能准确，如果一直说“NO”的判断正确概率较高，她会一直回答“NO”；如果一直说“YES”的判断正确概率较高，她会一直回答“YES”。现在，给出这两者的概率，请你确定她应该回答 YES 还是 NO。

如果回答“YES”和“NO”的正确概率一样高，请你输出 “equal probability”。
## 输入格式

输入只有一行两个整数，依次表示「题目描述」中的 $x$ 和 $y$。
## 输出格式

输出一行一个字符串:
- 如果回答 “YES” 的判断正确概率较高则输出 `YES`；
- 如果回答 “NO” 的判断正确概率较高则输出 `NO`；
- 如果两者的概率一样高，请你输出 `equal probability`。

如果输出的字符串是 `YES` 或 `NO`，则字符串大小写不敏感，也就是说，`yes`, `yeS`, `yEs`, `yES`, `Yes`, `YeS`, `YEs`, `YES` 都被认为是 `YES`，`NO` 同理。

如果输出的字符串是 `equal probability`，你必须输出严格的由小写字母和空格组成的字符串，例如，`Equal probability` 将被认为是错误的输出。

## 样例

### 样例输入 #1
```
45 0
```
### 样例输出 #1
```
nO
```
### 样例输入 #2
```
0 45
```
### 样例输出 #2
```
yEs
```
### 样例输入 #3
```
49 51
```
### 样例输出 #3
```
yeS
```
### 样例输入 #4
```
50 50
```
### 样例输出 #4
```
equal probability
```
## 提示

### 数据规模与约定

对全部的测试点，保证 $0 \leq x, y \leq 100$，$x + y\leq 100$。

$\textcolor{white}{\texttt{No,commander!}}$


### 代码

```cpp
#include <iostream>
using namespace std;
int x,y;
int main(){
cin>>x>>y;
if(x+y<=100){
if(x>y){
cout<<"NO"<<endl;
}
else if(x<y){
cout<<"YES"<<endl;
}
else if(x==y){
cout<<"equal probability"<<endl;
}
}
return 0;
}
```

---

## 题目: B3750

**分类：数学**

**提交时间：2025-03-22 12:23:10**

---
title: "[信息与未来 2019] 幸运素数"
layout: "post"
diff: 入门
pid: B3750
tag: ['模拟', '2019', '江苏', '枚举', '素数判断,质数,筛法', '信息与未来']
---
# [信息与未来 2019] 幸运素数
## 题目描述

素数，又称质数，是指除 $1$ 和其自身之外，没有其他约数的正整数。例如 $2,3,5,13$ 都是素数，而 $4,9,12,18$ 则不是。特别地，规定 $1$ 不是素数（因此自然数的质因数分解就是唯一的）。

如果一个数本身是素数，并且把最低位删除后得到的数仍是素数、再把最低位删除后得到的数仍是素数……如此往复，直到得到一个一位素数，我们就称它是“幸运素数”。以 $233$ 为例：
- $233$ 本身是素数；
- $23=\lfloor\dfrac{233}{10}\rfloor$ 是素数；
- $2=\lfloor\dfrac{23}{10}\rfloor$ 是素数。

因此 $233$ 是“幸运”素数。而 $211$ 则不是幸运素数：虽然 $211$ 是素数，但 $21$ 不是素数。请编程求出一定范围内的所有幸运数字。
## 输入格式

输入一行两个用空格分隔的正整数 $m,n$，表示我们希望求幸运素数的范围。
## 输出格式

从小到大输出 $m,m+1,m+2,\cdots,n$ 中所有的幸运素数，每行输出一个。
## 样例

### 样例输入 #1
```
6 30
```
### 样例输出 #1
```
7
23
29
```
## 提示

对于 $100\%$ 的测试数据，有 $1\le m\le n\le 9999$。
> 本题原始满分为 $15\text{pts}$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10005];
void prime(){
for(int i=2;i<=sqrt(10000);i++){
if(a[i]){
for(int j=i*i;j<=10000;j+=i){
a[j]=0;
}
}
}
}
int main(){
for(int i=2;i<=10000;i++){
a[i]=1;
}
prime();
cin>>n>>m;
for(int i=n;i<=m;i++){
if(a[i]==1){
int x=i;
bool flag=1;
while(x/10!=0){
x/=10;
if(a[x]==0){
flag=0;
break;
}
}
if(a[x]==1&&flag==1){
cout<<i<<endl;
}
}
}
return 0;
}
```

---

## 题目: B3834

**分类：GESP--GESP1级**

**提交时间：2023-11-30 21:23:59**

---
title: "[GESP202303 一级] 长方形面积"
layout: "post"
diff: 入门
pid: B3834
tag: ['2023', '循环结构', 'GESP']
---
# [GESP202303 一级] 长方形面积
## 题目描述

小明刚刚学习了如何计算长方形面积。他发现，如果一个长方形的长和宽都是整数，它的面积一定也是整数。现在，小明想知道如果给定长方形的面积，有多少种可能的长方形，满足长和宽都是整数？如果两个长方形的长相等、宽也相等，则认为是同一种长方形。约定长方形的长大于等于宽。正方形是长方形的特例，即长方形的长和宽可以相等。
## 输入格式

输入一行，包含一个整数 $A$，表示长方形的面积。约定 $2 \leq A \leq 1000$。
## 输出格式

输出一行，包含一个整数 $C$，表示有 $C$ 种可能的长方形。
## 样例

### 样例输入 #1
```
4
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
6
```
### 样例输出 #2
```
2
```
## 提示

【样例 1 解释】

有 $2$ 种长方形面积为 $4$，它们的长宽分别为 $2 \times 2$，$4 \times 1$。

【样例 2 解释】

有 $2$ 种长方形面积为 $6$，它们的长宽分别为 $3 \times  2$，$6 \times 1$。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int a,b,c;
c=0;
cin>>a;
for (int i=1;i<=a/2;i++)
{
if (a%i==0)
{
b=a/i;
if (i<=b)
{
c+=1;
}
}
}
cout<<c;
return 0;
}
```

---

## 题目: B3848

**分类：GESP--GESP3级**

**提交时间：2024-02-07 13:20:51**

---
title: "[GESP样题 三级] 逛商场"
layout: "post"
diff: 入门
pid: B3848
tag: ['循环结构', 'GESP']
---
# [GESP样题 三级] 逛商场
## 题目描述

小明是个不太有计划的孩子。这不，刚到手的零花钱，就全部拿着逛商场去了。  

小明的原则很简单，见到想买的物品，只要能买得起，就一定会买下来之后才会继续往前走；如果买不起就直接跳过。

一天下来，小明到底买了多少物品呢？
## 输入格式

输入共 $3$ 行：

第一行是一个整数 $N$，表示商场中共有 $N$ 种小明想买的物品（$1≤N≤100$）；

第二行共有 $N$ 个整数，分别表示小明先后见到想买的物品的价格；

第三行是一个整数 $X$，表示开始时小明共有 $X$ 元零花钱。
## 输出格式

输出 $1$ 行，包含一个整数，表示小明买到的物品数。
## 样例

### 样例输入 #1
```
6
7 5 9 10 7 4
30
```
### 样例输出 #1
```
4
```
## 提示

**数据范围：**

对于 $100\%$ 的数据满足 $1≤N≤100$ 且 $0\le a_i \le 100000$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
int n,x,a[105],sum=0;
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
cin>>x;
for(int i=1;i<=n;i++)
{
if(x>=a[i])
{
x-=a[i];
sum+=1;
}
}
cout<<sum;
return 0;
}
```

---

## 题目: B3850

**分类：GESP--GESP4级**

**提交时间：2024-06-03 13:47:55**

---
title: "[GESP202306 四级] 幸运数"
layout: "post"
diff: 普及-
pid: B3850
tag: ['2023', '函数与递归', 'GESP']
---
# [GESP202306 四级] 幸运数
## 题目描述

小明发明了一种 "幸运数"。一个正整数，其偶数位不变（个位为第 $1$ 位，十位为第 $2$ 位，以此类推），奇数位做如下变换：将数字乘以 $7$，如果不大于 $9$ 则作为变换结果，否则把结果的各位数相加，如果结果不大于 $9$ 则作为变换结果，否则（结果仍大于 $9$）继续把各位数相加，直到结果不大于 $9$，作为变换结果。变换结束后，把变换结果的各位数相加，如果得到的和是 $8$ 的倍数，则称一开始的正整数为幸运数。

例如，$16347$：第 $1$ 位为 $7$，乘以 $7$ 结果为 $49$，大于 $9$，各位数相加为 $13$，仍大于 $9$，继续各位数相加，最后结果为 $4$；第 $3$ 位为 $3$，变换结果为 $3$；第 $5$ 位为 $1$，变换结果为 $7$。最后变化结果为 $76344$，对于结果 $76344$ 其各位数之和为 $24$，是 $8$ 的倍数。因此 $16347$ 是幸运数。
## 输入格式

输入第一行为正整数 $N$，表示有 $N$ 个待判断的正整数。约定 $1 \le N \le 20$。

从第 $2$ 行开始的 $N$ 行，每行一个正整数，为待判断的正整数。约定这些正整数小于 $10^{12}$。
## 输出格式

输出 $N$ 行，对应 $N$ 个正整数是否为幸运数，如是则输出 'T'，否则输出 'F'。

提示：不需要等到所有输入结束在依次输出，可以输入一个数就判断一个数并输出，再输入下一个数。
## 样例

### 样例输入 #1
```
2
16347
76344
```
### 样例输出 #1
```
T
F
```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
long long n,x=0,sum=0;
cin >> n;
for (int i = 0; i < n; i++)
{
string str;
cin >> str;
sum=0;
for (int j = str.length() - 1; j >= 0; j--)
{
if ((str.length() - j) % 2 == 1)   // 奇数位
{
x=(int)str[j]-48;
x*=7;
while(x>9)
{
x=(x/10%10)+(x%10);
}
sum+=x;
}
else
{
x=(int)str[j]-48;
sum+=x;
}
}
if(sum%8==0)
{
cout<<"T"<<endl;
}
else
{
cout<<"F"<<endl;
}
}
return 0;
}
```

---

## 题目: B3865

**分类：GESP--GESP2级**

**提交时间：2023-12-08 21:30:53**

---
title: "[GESP202309 二级] 小杨的 X 字矩阵"
layout: "post"
diff: 入门
pid: B3865
tag: ['2023', 'GESP']
---
# [GESP202309 二级] 小杨的 X 字矩阵
## 题目描述

小杨想要构造一个 的 X 字矩阵（ 为奇数），这个矩阵的两条对角线都是半角加号 `+` ，其余都是半角减号 `-` 。例如，一个 $5 \times 5$ 的 X 字矩阵如下：

```plain
+---+
-+-+-
--+--
-+-+-
+---+
```

请你帮小杨根据给定的 打印出对应的“X 字矩阵”。
## 输入格式

一行一个整数 （ $5 \le N \le 49$，保证为奇数）。
## 输出格式

输出对应的“X 字矩阵”。

请严格按格式要求输出，不要擅自添加任何空格、标点、空行等任何符号。你应该恰好输出 $N$ 行，每行除了换行符外恰好包含 $N$ 个字符，这些字符要么是 `+`，要么是 `-`。
## 样例

### 样例输入 #1
```
5
```
### 样例输出 #1
```
+---+
-+-+-
--+--
-+-+-
+---+
```
### 样例输入 #2
```
7
```
### 样例输出 #2
```
+-----+
-+---+-
--+-+--
---+---
--+-+--
-+---+-
+-----+
```
## 提示

**特别提醒**

在常规程序中，输入、输出时提供提示是好习惯。但在本场考试中，由于系统限定，请不要在输入、输出中附带任何提示信息。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int x;
cin >> x;
for (int i = 1; i <= x; i++)
{
for (int j = 1; j <= x; j++)
{
if (i==j||i==x+1-j)
{
cout << "+";
}
else
{
cout << "-";
}
}
cout << endl;
}
return 0;
}
```

---

## 题目: B3866

**分类：GESP--GESP2级**

**提交时间：2023-12-07 22:34:27**

---
title: "[GESP202309 二级] 数字黑洞"
layout: "post"
diff: 普及-
pid: B3866
tag: ['2023', 'GESP']
---
# [GESP202309 二级] 数字黑洞
## 题目描述

给定一个三位数，要求各位不能相同。例如，$352$ 是符合要求的，$112$ 是不符合要求的。将这个三位数的三个数字重新排列，得到的最大的数，减去得到的最小的数，形成一个新的三位数。对这个新的三位数可以重复上述过程。神奇的是，最终一定会得到 $495$！

试试看，重新排列 $352$，得到的最大数为 $532$，最小数为 $235$，它们的差是 $297$；变换 $297$，得到 $972-279=693$；变换 $693$，$963-369=594$；变换 $594$，$954-459=495$。因此，经过 $4$ 次变换得到了 $495$。

现在，输入的三位数，你能通过编程得出，这个三位数经过多少次变换能够得到 $495$ 吗？
## 输入格式

输入一行，包含一个符合要求的三位数 $N$。
## 输出格式

输出一行，包含一个整数 $C$，表示经过 $C$ 次变换得到 $495$。
## 样例

### 样例输入 #1
```
352
```
### 样例输出 #1
```
4
```


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int n, i, sum = 0, x, a, b, c, a1, b1, c1;
cin >> n;
while (n != 495)
{
i = 0;
string str = to_string(n);
for (char d : str)
{
i += 1;
x = (int)d - '0';
if (i == 1)
{
a = x;
}
if (i == 2)
{
b = x;
}
if (i == 3)
{
c = x;
}
}
a1 = a;
b1 = b;
c1 = c;
if (a > c)
{
swap(a, c);
}
if (a > b)
{
swap(a, b);
}
if (b > c)
{
swap(b, c);
}
if (a1 < c1)
{
swap(a1, c1);
}
if (a1 < b1)
{
swap(a1, b1);
}
if (b1 < c1)
{
swap(b1, c1);
}
n = (a1 * 100 + b1 * 10 + c1) - (a * 100 + b * 10 + c) ;
sum += 1;
}
cout << sum;
return 0;
}
```

---

## 题目: B3867

**分类：GESP--GESP3级**

**提交时间：2024-01-14 08:29:55**

---
title: "[GESP202309 三级] 小杨的储蓄"
layout: "post"
diff: 入门
pid: B3867
tag: ['2023', 'GESP']
---
# [GESP202309 三级] 小杨的储蓄
## 题目描述

小杨共有 $N$ 个储蓄罐，编号从 $0$ 到 $N-1$。从第 $1$ 天开始，小杨每天都会往存钱罐里存钱。具体来说，第 $i$ 天他会挑选一个存钱罐 $a_i$，并存入 $i$ 元钱。过了 $D$ 天后，他已经忘记每个储蓄罐里都存了多少钱了，你能帮帮他吗？
## 输入格式

输入 $2$ 行，第一行两个整数 $N,D$；第二行 $D$ 个整数，其中第 $i$ 个整数为 ${a_i}$（保证 $0 \le a_i \le N-1$）。

每行的各个整数之间用单个空格分隔。

保证 $1 \le N \le 1,000$；$1 \le D \le 1,000$。
## 输出格式

输出 $N$ 个用单个空格隔开的整数，其中第 $i$ 个整数表示编号为 $i-1$ 的存钱罐中有多少钱（$i=1, \cdots ,N$）。
## 样例

### 样例输入 #1
```
2 3
0 1 0
```
### 样例输出 #1
```
4 2
```
### 样例输入 #2
```
3 5
0 0 0 2 0
```
### 样例输出 #2
```
11 0 4
```
## 提示

**样例解释 1：**

小杨在第 $1$ 天、第 $2$ 天、第 $3$ 天分别向 $0$ 号、 $1$ 号、 $0$ 号存钱罐存了 $1$ 元钱、 $2$ 元钱、 $3$ 元钱，因此 $0$ 号存钱罐有 $1+3=4$ 元钱，而 $1$ 号存钱罐有 $2$ 元钱。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,d,a[1005],b[1005],sum=1;
int main()
{
cin>>n>>d;
for(int i=0;i<=(d-1);i++)
{
cin>>a[i];
}
for(int i=0;i<=(d-1);i++)
{
b[a[i]]+=sum;
sum+=1;
}
for(int i=0;i<=(n-1);i++)
{
cout<<b[i]<<" ";
}
return 0;
}
```

---

## 题目: B3868

**分类：GESP--GESP3级**

**提交时间：2024-03-14 22:20:14**

---
title: "[GESP202309 三级] 进制判断"
layout: "post"
diff: 入门
pid: B3868
tag: ['2023', 'GESP']
---
# [GESP202309 三级] 进制判断
## 题目描述

$N$ 进制数指的是逢 $N$ 进一的计数制。例如，人们日常生活中大多使用十进制计数，而计算机底层则一般使用二进制。除此之外，八进制和十六进制在一些场合也是常用的计数制（十六进制中，一般使用字母 A 至 F 表示十至十五）。

现在有N个数，请你分别判断他们是否可能是二进制、八进制、十进制、十六进制。例如，`15A6F` 就只可能是十六进制，而 `1011` 则是四种进制皆有可能。
## 输入格式

输入的第一行为一个十进制表示的整数 $N$。接下来 $N$ 行，每行一个字符串，表示需要判断的数。保证所有字符串均由数字和大写字母组成，**可能以 $0$ 开头**。保证不会出现空行。

保证 $1 \le N \le 1000$，保证所有字符串长度不超过 $10$。
## 输出格式

输出 $N$ 行，每行 $4$ 个数，用空格隔开，分别表示给定的字符串是否可能表示一个二进制数、八进制数、十进制数、十六进制数。使用 $1$ 表示可能，使用 $0$ 表示不可能。

例如，对于只可能是十六进制数的 `15A6F`，就需要输出 `0 0 0 1`；而对于四者皆有可能的 `1011`，则需要输出 `1 1 1 1`。
## 样例

### 样例输入 #1
```
2
15A6F
1011

```
### 样例输出 #1
```
0 0 0 1
1 1 1 1

```
### 样例输入 #2
```
4
1234567
12345678
FF
GG

```
### 样例输出 #2
```
0 1 1 1
0 0 1 1
0 0 0 1
0 0 0 0

```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
char a[1005];
int n, b = 1, c = 1, d = 1, e = 1;
cin >> n;
for (int i = 0; i < n; i++)
{
cin >> a;
b = 1, c = 1, d = 1, e = 1;
for (int j = 0; a[j] != '\0'; j++)
{
if (a[j] >= '2')
{
b = 0;
}
if (a[j] >= '8')
{
c = 0;
}
if (a[j] > '9')
{
d = 0;
}
if (a[j] > 'F')
{
e = 0;
}
}
cout << b << " " << c << " " << d << " " << e << endl;
}
return 0;
}
```

---

## 题目: B3869

**分类：GESP--GESP4级**

**提交时间：2024-09-07 08:28:30**

---
title: "[GESP202309 四级] 进制转换"
layout: "post"
diff: 普及-
pid: B3869
tag: ['2023', 'GESP']
---
# [GESP202309 四级] 进制转换
## 题目描述

$N$ 进制数指的是逢 $N$ 进一的计数制。例如，人们日常生活中大多使用十进制计数，而计算机底层则一般使用二进制。除此之外，八进制和十六进制在一些场合也是常用的计数制（十六进制中，一般使用字母 A 至 F 表示十至十五；本题中，十一进制到十五进制也是类似的）。

在本题中，我们将给出 个不同进制的数。你需要分别把它们转换成十进制数。
## 输入格式

输入的第一行为一个十进制表示的整数 $N$。接下来 $N$ 行，每行一个整数 $K$，随后是一个空格，紧接着是一个 $K$ 进制数，表示需要转换的数。保证所有 $K$ 进制数均由数字和大写字母组成，且不以 $0$ 开头。保证 $K$ 进制数合法。

保证 $N \le 1000$；保证 $2 \le K \le 16$。

保证所有 $K$ 进制数的位数不超过 $9$。
## 输出格式

输出 $N$ 行，每一个十进制数，表示对应 $K$ 进制数的十进制数值。
## 样例

### 样例输入 #1
```
2
8 1362
16 3F0
```
### 样例输出 #1
```
754
1008
```
### 样例输入 #2
```
2
2 11011
10 123456789
```
### 样例输出 #2
```
27
123456789
```
## 提示

对于任意一个 $L$ 位 $K$ 进制数，假设其最右边的数位为第 $0$ 位，最左边的数位为第 $L-1$ 位，我们只需要将其第 $i$ 位的数码乘以权值 $K^i$，再将每位的结果相加，即可得到原 $K$ 进制数对应的十进制数。下面是两个例子：

1. 八进制数 `1362` 对应的十进制数为：$1×8^3+3×8^2+6×8^1+2×8^0=754$；

2. 十六进制数 `3F0` 对应的十进制数为：$3×16^2+15×16^1+0×16^0=1008$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
long n, a[1005], sum = 0;
string b[1005];
cin >> n;
for (int i = 0; i < n; i++)
{
cin >> a[i] >> b[i];
}
for (int i = 0; i < n; i++)
{
sum = 0;
for (int j = b[i].length()-1; j >= 0; j--)
{
if (b[i][j] >= 'A' && b[i][j] <= 'Z')
{
sum += (b[i][j] - '7') * pow(a[i],(b[i].length() - j-1));
}
else
{
sum += (b[i][j] - '0') * pow(a[i],(b[i].length() - j-1));
}
}
cout << sum << endl;
}
return 0;
}
```

---

## 题目: B3870

**分类：GESP--GESP4级**

**提交时间：2024-08-27 21:24:55**

---
title: "[GESP202309 四级] 变长编码"
layout: "post"
diff: 普及-
pid: B3870
tag: ['2023', 'GESP']
---
# [GESP202309 四级] 变长编码
## 题目描述

小明刚刚学习了三种整数编码方式：原码、反码、补码，并了解到计算机存储整数通常使用补码。但他总是觉得，生活中很少用到 $2^{31}-1$ 这么大的数，生活中常用的 $0\sim 100$ 这种数也同样需要用 $4$ 个字节的补码表示，太浪费了些。
热爱学习的小明通过搜索，发现了一种正整数的变长编码方式。这种编码方式的规则如下：

1. 对于给定的正整数，首先将其表达为二进制形式。例如，$(0)_{\{10\}}=(0)_{\{2\}}$，$(926)_{\{10\}}=(1110011110)_{\{2\}}$。

2. 将二进制数从低位到高位切分成每组 $7$ bit，不足 $7$bit 的在高位用 $0$ 填补。例如，$(0)_{\{2\}}$ 变为$0000000$ 的一组，$(1110011110)_{\{2\}}$ 变为 $0011110$ 和 $0000111$ 的两组。

3. 由代表低位的组开始，为其加入最高位。如果这组是最后一组，则在最高位填上 $0$，否则在最高位填上 $1$。于是，$0$ 的变长编码为 $00000000$ 一个字节， $926$ 的变长编码为 $10011110$ 和 $00000111$ 两个字节。

这种编码方式可以用更少的字节表达比较小的数，也可以用很多的字节表达非常大的数。例如，$987654321012345678$ 的二进制为 $(0001101 \ 1011010 \ 0110110 \ 1001011 \ 1110100 \ 0100110 \ 1001000 \ 0010110 \ 1001110)_{\{2\}}$，于是它的变长编码为（十六进制表示） `CE 96 C8 A6 F4 CB B6 DA 0D`，共 $9$ 个字节。

你能通过编写程序，找到一个正整数的变长编码吗？
## 输入格式

输入第一行，包含一个正整数 $N$。约定 $0\le N \le 10^{18}$。
## 输出格式

输出一行，输出 $N$ 对应的变长编码的每个字节，每个字节均以 $2$ 位十六进制表示（其中， `A-F` 使用大写字母表示），两个字节间以空格分隔。
## 样例

### 样例输入 #1
```
0
```
### 样例输出 #1
```
00
```
### 样例输入 #2
```
926
```
### 样例输出 #2
```
9E 07
```
### 样例输入 #3
```
987654321012345678
```
### 样例输出 #3
```
CE 96 C8 A6 F4 CB B6 DA 0D
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1005][10],sum=1,x=1,y=8,sum1=1,ans=0;
char c;
bool flag=0;
int main()
{
cin>>n;
if(n==0)
{
cout<<"00";
return 0;
}
while(n!=1)
{
if(y==1)
{
x+=1;
y=8;
}
a[x][y]=n%2;
n/=2;
y-=1;
}
if(y==1)
{
x+=1;
y=8;
}
a[x][y]=n%2;
n/=2;
for(int i=1;i<=x;i++)
{
if(i!=x)
{
a[i][1]=1;
}
}
for(int i=1;i<=x;i++)
{
for(int k=1;k<=2;k++)
{
ans=0;
sum1=1;
for(int j=k*4;j>=k*4-3;j--)
{
ans+=a[i][j]*sum1;
sum1*=2;
}
if(ans<10)
{
cout<<ans;
}
else
{
c=ans-10+'A';
cout<<c;
}
}
cout<<" ";
}
return 0;
}
```

---

## 题目: B3871

**分类：GESP--GESP5级**

**提交时间：2024-11-11 20:16:47**

---
title: "[GESP202309 五级] 因数分解"
layout: "post"
diff: 普及-
pid: B3871
tag: ['2023', 'GESP']
---
# [GESP202309 五级] 因数分解
## 题目描述

每个正整数都可以分解成素数的乘积，例如： $6=2\times 3$，$20=2^2\times5$。

现在，给定一个正整数，请按要求输出它的因数分解式。
## 输入格式

输入第一行，包含一个正整数 $N$。约定 $2 \le N \le 10^{12}$。
## 输出格式

输出一行，为的因数分解式。要求按质因数由小到大排列，乘号用星号 `*` 表示，且左右各空一格。当且仅当一个素数出现多次时，将它们合并为指数形式，用上箭头 `^` 表示，且左右不空格。
## 样例

### 样例输入 #1
```
6
```
### 样例输出 #1
```
2 * 3
```
### 样例输入 #2
```
20
```
### 样例输出 #2
```
2^2 * 5
```
### 样例输入 #3
```
23
```
### 样例输出 #3
```
23
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,sum=0,x;
bool flag=1;
int main(){
cin>>n;
x=n;
for(long long i=2;i<=sqrt(n);i++){
sum=0;
while(x%i==0){
sum+=1;
x/=i;
}
if(flag==1&&sum>=1){
if(sum>1){
cout<<i<<"^"<<sum;
}
else if(sum==1){
cout<<i;
}
flag=0;
}
else{
if(sum>1){
cout<<" * "<<i<<"^"<<sum;
}
else if(sum==1){
cout<<" * "<<i;
}
}
}
if(x==n){
cout<<x;
}
else if(x>1){
cout<<" * "<<x;
}
return 0;
}
```

---

## 题目: B3872

**分类：GESP--GESP5级**

**提交时间：2024-12-03 20:44:46**

---
title: "[GESP202309 五级] 巧夺大奖"
layout: "post"
diff: 普及/提高-
pid: B3872
tag: ['2023', 'GESP']
---
# [GESP202309 五级] 巧夺大奖
## 题目描述

小明参加了一个巧夺大奖的游戏节目。主持人宣布了游戏规则：

1. 游戏分为 $n$ 个时间段，参加者每个时间段可以选择一个小游戏。

2. 游戏中共有 $n$ 个小游戏可供选择。

3. 每个小游戏有规定的时限和奖励。对于第 $i$ 个小游戏，参加者必须在第 $T_i$ 个时间段结束前完成才能得到奖励 $R_i$。

小明发现，这些小游戏都很简单，不管选择哪个小游戏，他都能在一个时间段内完成。关键问题在于，如何安排每个时间段分别选择哪个小游戏，才能使得总奖励最高？
## 输入格式

输入第一行，包含一个正整数 $n$。$n$ 既是游戏时间段的个数，也是小游戏的个数。约定 $1\le n\le500$。

输入第二行，包含 $n$ 个正整数。第 $i$ 个正整数为 $T_i$，即第 $i$ 个小游戏的完成期限。约定 $1\le T_i\le n$。

输入第三行，包含 $n$ 个正整数。第 $i$ 个正整数为 $R_i$，即第 $i$ 个小游戏的完成奖励。约定 $1\le R_i\le 1000$。
## 输出格式

输出一行，包含一个正整数 $C$，为最高可获得的奖励。
## 样例

### 样例输入 #1
```
7
4 2 4 3 1 4 6
70 60 50 40 30 20 10
```
### 样例输出 #1
```
230
```
## 提示

**样例解释 1**

$7$ 个时间段可分别安排完成第 4、2、3、1、6、7、5 个小游戏，其中第 4、2、3、1、7 个小游戏在期限内完成。因此，可以获得总计 $40+60+50+70+10=230$ 的奖励。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,b[1005],sum;
struct game{
int x,f;
}a[1005];
bool cmp(game y,game z){
if(y.f>z.f){
return true;
}
else if(y.f==z.f&&y.x<z.x){
return true;
}
return false;
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i].x;
}
for(int i=1;i<=n;i++){
cin>>a[i].f;
}
sort(a+1,a+n+1,cmp);
for(int i=1;i<=n;i++){
int j=a[i].x;
while(j>0){
if(b[j]==0){
b[j]=a[i].f;
break;
}
else{
j-=1;
}
}
}
for(int i=1;i<=n;i++){
sum+=b[i];
}
cout<<sum;
return 0;
}
```

---

## 题目: B3923

**分类：GESP--GESP2级**

**提交时间：2024-01-28 09:28:04**

---
title: "[GESP202312 二级] 小杨做题"
layout: "post"
diff: 入门
pid: B3923
tag: ['2023', 'GESP']
---
# [GESP202312 二级] 小杨做题
## 题目描述

为了准备考试，小杨每天都要做题。第 $1$ 天，小杨做了 $a$ 道题；第 $2$ 天，小杨做了 $b$ 道题；从第 $3$ 天起，小杨每天做的题目数量是前两天的总和。

此外，小杨还规定，当自己某一天做了大于或等于 $m$ 题时，接下来的所有日子里，他就再也不做题了。

请问，到了第 $N$ 天，小杨总共做了多少题呢？
## 输入格式

总共 $4$ 行。第一行一个整数 $a$，第二行一个整数 $b$，第三行一个整数 $m$，第四行一个整数 $N$。

保证 $0 \le a,b \le 10$；$a,b<M<1,000,000$；$3 \le N \le 364$。
## 输出格式

一行一个整数，表示小杨 $N$ 天里总共做了多少题目。
## 样例

### 样例输入 #1
```
1
2
10
5
```
### 样例输出 #1
```
19
```
### 样例输入 #2
```
1
1
5
8
```
### 样例输出 #2
```
12
```
## 提示

**样例解释 1**

小杨第一天做 $1$ 题，第二天做 $2$ 题，第三天做 $1+2=3$ 题，第四天做 $2+3=5$ 题，第五天做 $3+5=8$ 题。因此他总共做了 $1+2+3+5+8=19$ 题。

**样例解释 2**

小杨前 $5$ 天分别做了 $1,1,2,3,5$ 题，由于第 $5$ 天小杨做了 $5$ 题，而 $m=5$，于是小杨从此以后不再做题。因此小杨总共做了 $1+1+2+3+5=12$ 题。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a, b, m, n, sum = 0, d = 2, t;
int main()
{
cin >> a >> b >> m >> n;
sum = a + b;
while (d < n)
{
t = a + b;
a = b;
b = t;
sum += b;
if (t > m)
{
break;
}
else if (t == m)
{
break;
}
d += 1;
}
cout << sum;
return 0;
}
```

---

## 题目: B3926

**分类：GESP--GESP3级**

**提交时间：2024-03-14 14:07:32**

---
title: "[GESP202312 三级] 单位转换"
layout: "post"
diff: 入门
pid: B3926
tag: ['2023', 'GESP']
---
# [GESP202312 三级] 单位转换
## 题目描述

小杨这周的数学作业是做单位转换，喜欢编程的小杨决定编程帮他解决这些问题。

小杨只学了长度单位和重量单位，具体来说：

- 长度单位包括千米（`km`）、米（`m`）、毫米（`mm`），它们之间的关系是：$1\text{km} = 1000\text{m} = 1000000\text{mm}$。

- 重量单位包括千克（`kg`）、克（`g`）、毫克（`mg`），它们之间的关系是：$1\text{kg} = 1000\text{g} = 1000000\text{mg}$。

小杨的作业只涉及将更大的单位转换为更小的单位，也就是说，小杨的作业只会包含如下题型：米转换为毫米，千米转换为毫米，千米转换为米，克转换为毫克，千克转换为毫克，千克转换为克。

现在，请你帮忙完成单位转换的程序。
## 输入格式

输入的第一行为一个整数，表示题目数量。

接下来 $N$ 行，每行一个字符串，表示转换单位的题目，格式为 $x$ 单位 $1 = ?$ 单位 $2$。其中，$x$ 为一个不超过 $1000$ 的非负整数， 单位 $1$ 和 单位 $2$ 分别为两个单位的英文缩写，保证它们都是长度单位或都是重量单位，且 **单位 1** 比 **单位 2** 更大。

例如，如果题目需要你将 $1\text{km}$ 转换为 $\text{mm}$，则输入为 `1 km = ? mm`。

保证 $1\le N \le 1000$。
## 输出格式

输出 $N$ 行，依次输出所有题目的答案，输出时，只需要将输入中的 $?$ 代入答案，其余部分一字不差地输出即可。由于小杨的题目只涉及将更大的单位转换为更小的单位，并且输入的 $x$ 是整数，因此答案一定也是整数。

例如，如果题目需要你将 $1\text{km}$ 转换为 $\text{mm}$，则输入为 `1 km = ? mm`。则你需要输出 `1 km = 1000000 mm`。
## 样例

### 样例输入 #1
```
2
1 km = ? mm
1 m = ? mm
```
### 样例输出 #1
```
1 km = 1000000 mm
1 m = 1000 mm
```
### 样例输入 #2
```
5
100 m = ? mm
1000 km = ? m
20 kg = ? g
200 g = ? mg
0 kg = ? mg
```
### 样例输出 #2
```
100 m = 100000 mm
1000 km = 1000000 m
20 kg = 20000 g
200 g = 200000 mg
0 kg = 0 mg
```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
string b[1005], c[1005], d[1005],e[1005];
int a[1005],n;
cin >> n;
for (int i = 1; i <= n; i++)
{
cin >> a[i] >> b[i] >> c[i] >> d[i] >> e[i];
}
for (int i = 1; i <= n; i++)
{
if (b[i] == "km" && e[i] == "m")
{
d[i] = to_string(a[i] * 1000);
}
else if (b[i] == "km" && e[i] == "mm")
{
d[i] = to_string(a[i] * 1000000);
}
else if (b[i] == "m" && e[i] == "mm")
{
d[i] = to_string(a[i] * 1000);
}
else if (b[i] == "kg" && e[i] == "g")
{
d[i] = to_string(a[i] * 1000);
}
else if (b[i] == "kg" && e[i] == "mg")
{
d[i] = to_string(a[i] * 1000000);
}
else if (b[i] == "g" && e[i] == "mg")
{
d[i] = to_string(a[i] * 1000);
}
cout<<a[i]<<" "<<b[i]<<" "<<c[i]<<" "<<d[i]<<" "<<e[i]<<endl;
}
return 0;
}
```

---

## 题目: B3927

**分类：GESP--GESP4级**

**提交时间：2024-08-21 21:30:36**

---
title: "[GESP202312 四级] 小杨的字典"
layout: "post"
diff: 普及-
pid: B3927
tag: ['2023', 'GESP']
---
# [GESP202312 四级] 小杨的字典
## 题目描述

在遥远的星球，有两个国家 A 国和 B 国，他们使用着不同的语言：A 语言和 B 语言。小杨是 B 国的翻译官，他的工作是将 A 语言的文章翻译成 B 语言的文章。

为了顺利完成工作，小杨制作了一本字典，里面记录了 $N$ 个 A 语言单词对应的 B 语言单词，巧合的是，这些单词都
由地球上的 26 个小写英文字母组成。

小杨希望你写一个程序，帮助他根据这本字典翻译一段 A 语言文章。这段文章由标点符号 `!()-.[].{}\|;:'",./?<>` 和一些 A 语言单词构成，每个单词之间必定由至少一个标点符号分割，你的程序需要把这段话中的所有 A 语言单词替换成它的 B 语言翻译。特别地，如果遇到不在字典中的单词，请使用大写 UNK 来替换它。

例如，小杨的字典中包含 $2$ 个 A 语言单词 `abc` 和 `d`，它们的 B 语言翻译分别为 `a` 和 `def`，那么我们可以把 A 语言文章 `abc.d.d.abc.abcd.` 翻译成 B 语言文章 `a.def.def.a.UNK.` 其中，单词 `abcd` 不在词典内，因此我们需要使用 UNK 来替换它。
## 输入格式

第一行一个整数 $N$，表示词典中的条目数。保证  $N \le 100$。

接下来  $N$ 行，每行两个用单个空格隔开的字符串  $A$， $B$ ,分别表示字典中的一个 A 语言单词以及它对应的 B 语言翻译。保证所有 $A$ 不重复；保证 $A$ 和 $B$ 的长度不超过 $10$。

最后一行一个字符串 $S$ ，表示需要翻译的 A 语言文章。保证字符串 $S$ 的长度不超过 $1000$，保证字符串 $S$ 只包含小写字母以及标点符号 `!()-.[].{}\|;:'",./?<>` 。
## 输出格式

输出一行，表示翻译后的结果。
## 样例

### 样例输入 #1
```
2
abc a
d def
abc.d.d.abc.abcd
```
### 样例输出 #1
```
a.def.def.a.UNK
```
### 样例输入 #2
```
3
abc a
d def
abcd xxxx
abc,(d)d!-abc?abcd
```
### 样例输出 #2
```
a,(def)def!-a?xxxx
```
### 样例输入 #3
```
1
abcdefghij klmnopqrst
!()-[]{}\|;:'",./?<>abcdefghijklmnopqrstuvwxyz
```
### 样例输出 #3
```
!()-[]{}\|;:'",./?<>UNK
```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
string arr,s,a[105],b[105];
bool flag=0,flag1=0;
int sum=0,n;
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>a[i]>>b[i];
}
cin>>arr;
while (sum<arr.length())
{
if (arr[sum]>='a'&&arr[sum]<='z')
{
s+=arr[sum];
}
else
{
flag=0;
flag1=0;
if((arr[sum-1]<'a'||arr[sum-1]>'z')&&(arr[sum]<'a'||arr[sum]>'z'))
{
cout<<arr[sum];
s="";
flag1=1;
}
if(flag1==0)
{
for(int i=1;i<=n;i++)
{
if(s==a[i])
{
cout<<b[i];
flag=1;
}
}
if(flag==0)
{
cout<<"UNK";
}
cout<<arr[sum];
s="";
}
}
sum++;
}
if (!s.empty())
{
flag=0;
for(int i=1;i<=n;i++)
{
if(s==a[i])
{
cout<<b[i];
flag=1;
}
}
if(flag==0)
{
cout<<"UNK";
}
}
return 0;
}
```

---

## 题目: B3928

**分类：GESP--GESP4级**

**提交时间：2024-08-21 20:36:52**

---
title: "[GESP202312 四级] 田忌赛马"
layout: "post"
diff: 普及-
pid: B3928
tag: ['2023', 'GESP']
---
# [GESP202312 四级] 田忌赛马
## 题目描述

你要和田忌赛马。你们各自有 $N$ 匹马，并且要进行 $N$ 轮比赛，每轮比赛，你们都要各派出一匹马决出胜负。

你的马匹的速度分别为 $u_1,u_2,\cdots，u_n$，田忌的马匹的速度分别为 $v_1,v_2,\cdots,v_n$。田忌会按顺序派出他的马匹，请问你要如何排兵布阵，才能赢得最多轮次的比赛？巧合的是，你和田忌的所有马匹的速度两两不同，因此不可能出现平局。
## 输入格式

第一行一个整数 $N$。保证 $1\le N \le 5\times 10^4$

接下来一行 $N$ 个用空格隔开的整数，依次为 $u_1,u_2,\cdots,u_n$，表示你的马匹们的速度。保证 $1\le u_i\le 2N$。

接下来一行 $N$ 个用空格隔开的整数，依次为 $v_1,v_2,\cdots,v_n$，表示田忌的马匹们的速度。保证 $1\le v_i\le 2N$。
## 输出格式

输出一行，表示你最多能获胜几轮。
## 样例

### 样例输入 #1
```
3
1 3 5
2 4 6
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
5
10 3 5 8 7
4 6 1 2 9
```
### 样例输出 #2
```
5
```
## 提示

**样例解释 1**

第 1 轮，田忌派出速度为 2 的马匹，你可以派出速度为 3 的马匹迎战，本轮你获胜。

第 2 轮，田忌派出速度为 4 的马匹，你可以派出速度为 5 的马匹迎战，本轮你获胜。

第 3 轮，田忌派出速度为 6 的马匹，你可以派出速度为 1 的马匹迎战，本轮田忌获胜。

如此，你可以赢得 2 轮比赛。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[50005],b[50005],ans=0,sum=1;
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
for(int i=1;i<=n;i++)
{
cin>>b[i];
}
sort(a+1,a+n+1);
sort(b+1,b+n+1);
for(int i=1;i<=n;i++)
{
if(a[i]>=b[sum])
{
ans+=1;
sum+=1;
}
}
cout<<ans;
return 0;
}
```

---

## 题目: B3929

**分类：GESP--GESP5级**

**提交时间：2024-12-01 16:26:23**

---
title: "[GESP202312 五级] 小杨的幸运数"
layout: "post"
diff: 普及-
pid: B3929
tag: ['二分', '2023', '素数判断,质数,筛法', 'GESP']
---
# [GESP202312 五级] 小杨的幸运数
## 题目描述

小杨认为，所有大于等于 $a$ 的完全平方数都是他的超级幸运数。

小杨还认为，所有超级幸运数的倍数都是他的幸运数。自然地，小杨的所有超级幸运数也都是幸运数。

对于一个非幸运数，小杨规定，可以将它一直 $+1$，直到它变成一个幸运数。我们把这个过程叫做幸运化。例如，如果$a=4$，那么 $4$ 是最小的幸运数，而 $1$ 不是，但我们可以连续对 $1$ 做 $3$ 次 $+1$ 操作，使其变为 $4$，所以我们可以说， $1$幸运化后的结果是 $4$。

现在，小杨给出 $N$ 个数，请你首先判断它们是不是幸运数；接着，对于非幸运数，请你将它们幸运化。
## 输入格式

第一行 $2$ 个正整数 $a, N$。

接下来 $N$ 行，每行一个正整数 $x$ ，表示需要判断（幸运化）的数。
## 输出格式

输出 $N$ 行，对于每个给定的 $x$ ，如果它是幸运数，请输出 `lucky`，否则请输出将其幸运化后的结果。
## 样例

### 样例输入 #1
```
2 4 
1 
4 
5 
9
```
### 样例输出 #1
```
4 
lucky 
8 
lucky
```
### 样例输入 #2
```
16 11 
1 
2 
4 
8 
16 
32 
64 
128 
256 
512
1024
```
### 样例输出 #2
```
16 
16 
16 
16 
lucky 
lucky 
lucky 
lucky 
lucky 
lucky 
lucky
```
## 提示

**样例解释 1**

虽然是完全平方数，但它小于 $a$，因此它并不是超级幸运数，也不是幸运数。将其进行 $3$ 次 $+1$ 操作后，最终得到幸运数 $4$。4是幸运数，因此直接输出 `lucky` 。

$5$ 不是幸运数，将其进行 $3$ 次 $+1$ 操作后，最终得到幸运数 $8$。

$9$ 是幸运数，因此直接输出 `lucky` 。

**数据规模**

对于 $30\%$ 的测试点，保证 $a,x \le 100,N \le 100$。

对于 $60\%$ 的测试点，保证 $a,x \le 10^6$。

对于所有测试点，保证 $a \le 1,000,000$；保证 $N \le 2 \times 10^5$；保证 $1 \le x \le 1,000,001$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,x,a[1000005];
void prime(int t){
for(int i=ceil((double)sqrt(t));i*i<=1000001;i++)
{
if(a[i*i]==0)
{
for(int j=1;i*i*j<=1000001;j++)
{
a[i*i*j]=1;
}
}
}
}
int main(){
cin>>m>>n;
prime(m);
for(int i=1;i<=n;i++){
cin>>x;
if(a[x]==1){
cout<<"lucky"<<endl;
}
else{
for(int j=x+1;;j++){
if(a[j]==1){
cout<<j<<endl;
break;
}
}
}
}
return 0;
}
```

---

## 题目: B3930

**分类：GESP--GESP5级**

**提交时间：2024-12-02 19:11:13**

---
title: "[GESP202312 五级] 烹饪问题"
layout: "post"
diff: 普及/提高-
pid: B3930
tag: ['贪心', '2023', '位运算', 'GESP']
---
# [GESP202312 五级] 烹饪问题
## 题目描述

有 $N$ 种食材，编号从 $0$ 至 $N-1$，其中第 $i$ 种食材的美味度为 $a_i$。

不同食材之间的组合可能产生奇妙的化学反应。具体来说，如果两种食材的美味度分别为 $x$ 和 $y$ ，那么它们的契合度为 $x\ \text{and}\ y $。

其中，$\text{and}$ 运算为按位与运算，需要先将两个运算数转换为二进制，然后在高位补足 ，再逐位进行与运算。例如，$12$ 与 $6$ 的二进制表示分别为 $1100$ 和 $0110$ ，将它们逐位进行与运算，得到 $0100$ ，转换为十进制得到 4，因此 $12 \text{and} 6 = 4$。**在 C++ 或 Python 中，可以直接使用 `&` 运算符表示与运算。**


现在，请你找到契合度最高的两种食材，并输出它们的契合度。
## 输入格式

第一行一个整数 $N$，表示食材的种数。

接下来一行 $N$ 个用空格隔开的整数，依次为 $a_1,\cdots,a_N$，表示各种食材的美味度。
## 输出格式

输出一行一个整数，表示最高的契合度。
## 样例

### 样例输入 #1
```
3
1 2 3
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
5
5 6 2 10 13

```
### 样例输出 #2
```
8
```
## 提示

**样例解释 1**  

可以编号为 $1,2$ 的食材之间的契合度为 $2\ \text{and} \ 3=2$，是所有食材两两之间最高的契合度。

**样例解释 2** 

可以编号为 $3,4$ 的食材之间的契合度为 $10\ \text{and}\ 13=8$，是所有食材两两之间最高的契合度。

**数据范围**

对于 $40\%$ 的测试点，保证 $N \le 1,000$；

对于所有测试点，保证 $N \le 10^6$，$0\le a_i \le 2,147,483,647$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],maxx=0;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=n;i++){
for(int j=i+1;j<=n;j++){
maxx=max(maxx,a[i]&a[j]);
}
}
cout<<maxx;
return 0;
}
```

---

## 题目: B3939

**分类：GESP--GESP4级**

**提交时间：2024-06-26 23:56:38**

---
title: "[GESP样题 四级] 绝对素数"
layout: "post"
diff: 普及-
pid: B3939
tag: ['GESP']
---
# [GESP样题 四级] 绝对素数
## 题目描述

如果一个两位数是素数，且它的数字位置经过对换后仍为素数，则称为绝对素数，例如 $13$。给定两个正整数 $A, B$，请求出大于等于 $A$、小于等于 $B$ 的所有绝对素数。
## 输入格式

输入 $1$ 行，包含两个正整数 $A$ 和 $B$。保证 $10<A<B<100$。
## 输出格式

若干行，每行一个绝对素数，从小到大输出。
## 样例

### 样例输入 #1
```
11 20
```
### 样例输出 #1
```
11
13
17
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
int x,y,minecraft=1,n=0,sum=1;
cin>>x>>y;
for(int i=x;i<=y;i++)
{
minecraft=1;
sum=1;
n=0;
for(int j=2;j<=sqrt(i);j++)
{
if(i%j==0)
{
minecraft=0;
}
}
if(minecraft==1)
{
string m=to_string(i);
for(int j=0;j<=m.length()-1;j++)
{
n+=(m[j]-'0')*sum;
sum*=10;
}
for(int j=2;j<=sqrt(n);j++)
{
if(n%j==0)
{
minecraft=0;
}
}
}
if(minecraft==1)
{
cout<<i<<endl;
}
}
return 0;
}
```

---

## 题目: B3940

**分类：GESP--GESP4级**

**提交时间：2024-08-27 21:36:48**

---
title: "[GESP样题 四级] 填幻方"
layout: "post"
diff: 普及-
pid: B3940
tag: ['GESP']
---
# [GESP样题 四级] 填幻方
## 题目描述

在一个 $N\times N$ 的正方形网格中，每个格子分别填上从 1 到 $N×N$ 的正整数，使得正方形中任一行、任一列及对角线的几个数之和都相等，则这种正方形图案就称为“幻方”（输出样例中展示了一个 $3×3$ 的幻方）。我国古代称为“河图”、“洛书”，又叫“纵横图”。

幻方看似神奇，但当 $N$ 为奇数时有很方便的填法：
1. 一开始正方形中没有填任何数字。首先，在第一行的正中央填上 $1$。
2. 从上次填数字的位置向上移动一格，如果已经在第一行，则移到同一列的最后一行；再向右移动一格，如果已经在最右一列，则移动至同一行的第一列。如果移动后的位置没有填数字，则把上次填写的数字的下一个数字填到这个位置。
3. 如果第 2 步填写失败，则从上次填数字的位置向下移动一格，如果已经在最下一行，则移到同一列的第一行。这个位置一定是空的（这可太神奇了！）。把上次填写的数字的下一个数字填到这个位置。
4. 重复 2、3 步骤，直到所有格子都被填满，幻方就完成了！

快来编写一个程序，按上述规则，制作一个 $N\times N$ 的幻方吧。
## 输入格式

输入为一个正奇数 $N$，保证 $3 \leq N \leq 21$。
## 输出格式

输出 $N$ 行，每行 $N$ 个空格分隔的正整数，内容为 $N×N$ 的幻方。
## 样例

### 样例输入 #1
```
3
```
### 样例输出 #1
```
8 1 6
3 5 7
4 9 2
```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[50][50],x,y;
int main()
{
cin>>n;
for (int i=1;i<=n;i++)
{
for (int j=1;j<=n;j++)
{
a[i][j]=0;
}
}
a[1][(n+1)/2]=1;
x=1;
y=(n+1)/2;
for (int i=2;i<=n*n;i++)
{
if (x==1&&y!=n)
{
a[n][y+1]=i;
x=n;
y+=1;
}
else if (x!=1&&y==n)
{
a[x-1][1]=i;
x-=1;
y=1;
}
else if (x==1&&y==n)
{
a[x+1][y]=i;
x+=1;
}
else if (x!=1&&y!=n&&a[x-1][y+1]==0)
{
a[x-1][y+1]=i;
x-=1;
y+=1;
}
else
{
a[x+1][y]=i;
x+=1;
}
}
for (int i=1;i<=n;i++)
{
for (int j=1;j<=n;j++)
{
cout<<a[i][j]<<" ";
}
cout<<endl;
}
return 0;
}
```

---

## 题目: B3941

**分类：GESP--GESP5级**

**提交时间：2024-11-25 20:02:47**

---
title: "[GESP样题 五级] 小杨的锻炼"
layout: "post"
diff: 普及-
pid: B3941
tag: ['数论', 'GESP']
---
# [GESP样题 五级] 小杨的锻炼
## 题目描述

小杨的班级里共有 $n$ 名同学，每位同学都有各自的锻炼习惯。具体来说，第 $i$ 位同学每隔 $a_i$ 天就会进行一次锻炼（也就是说，每次锻炼会在上一次锻炼的 $a_i$ 天后进行）。某一天，班上的 $n$ 名同学恰好都来进行了锻炼。他们对此兴奋不已，想要计算出下一次所有同学都来锻炼，至少要过多少天。但他们不会计算，你能帮帮他们吗？
## 输入格式

第一行一个整数 $n$，表示同学的数量。  
第二行 $n$ 个用空格隔开的正整数，依次为 $a_0, a_1, …, a_{n-1}$。
## 输出格式

输出一个整数，表示下一次所有同学都来锻炼，至少要过多少天。
## 样例

### 样例输入 #1
```
3
1 2 3

```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
4
2 4 8 16

```
### 样例输出 #2
```
16
```
### 样例输入 #3
```
4
2 4 6 8

```
### 样例输出 #3
```
24
```
## 提示

### 样例 1 解释

第一位同学每天都锻炼；第二位同学每 $2$ 天锻炼一次；第三位同学每 $3$ 天锻炼一次。因此，$6$ 天之后，三位同学都会进行锻炼。在此之前，第二位同学只会在第 $2, 4$ 天进行锻炼，第三位同学只会在第 $3$ 天进行锻炼，他们都无法相遇。

### 样例 2 解释

第四位同学每 $16$ 天锻炼一次，而 $16$ 天后也恰好是前三位同学锻炼的日子。

### 数据规模与约定

- 对 $20\%$ 的数据，$n = 2$。
- 对 $50\%$ 的数据，$n = 4$。
- 对 $100\%$ 的数据，$2 \leq n \leq 10$，$1 \leq a_i \leq 50$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[15],sum,ans=1;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=n;i++){
int x=a[i],y=ans;
while((x%y!=0)&&(y%x!=0)){
if(x>y){
x-=y;
}
else{
y-=x;
}
}
sum=min(x,y);
ans*=(a[i]/sum);
}
cout<<ans;
return 0;
}
```

---

## 题目: B3951

**分类：GESP--GESP5级**

**提交时间：2024-12-01 19:24:46**

---
title: "[GESP样题 五级] 小杨的队列"
layout: "post"
diff: 普及-
pid: B3951
tag: ['GESP']
---
# [GESP样题 五级] 小杨的队列
## 题目描述

小杨的班级里共有 $N$ 名同学，学号从 $0$ 至 $N-1$。某节课上，老师要求同学们进行列队。具体来说，老师会依次点名 $M$ 名同学，让他们加入队伍。每名新入队的同学需要先站到队伍末尾（刚开始队伍里一个人都没有，所以第一个入队的同学只需要站好即可），随后，整个队伍中的所有同学需要按身高从低到高重新排序（身高相同的同学之间的顺序任意）。

排队很容易，但重新排序难倒了同学们。稍加讨论后，他们发现可以通过交换位置的方法来实现排序。具体来说，他们可以让队伍中的两名同学交换位置这样整个队伍的顺序就会发生变化，多经过这样的几次交换后，队伍的顺序就可以排好。

例如：队伍中有 $4$ 名同学，学号依次为 $10,17,3,25$，我们可以令 $3$ 号同学和 $10$ 号同学交换位置，则交换后的队伍顺序变为 $3,17,10,25$，这就是一次交换位置。

聪明的小杨想要知道：在老师每次点名一位新同学加入队伍后，在原有队伍的基础上，同学们最少要进行几次交换位置，才能完成老师按身高排序的要求。

## 输入格式

第一行一个整数 $N$，表示同学的数量  
第二行 $N$ 个用空格隔开的正整数，依次表示学号为 $0,1,$ … $,N-1$ 的同学的身高（不超过 $2,147,483,647$）。  
第三行一个整数 $M$，表示老师点名的数量。  
接下来 $M$ 行，依次描述 $M$ 次点名：每行一个整数 $x$（$0 \le x<N$），表示要求学号为 $x$ 的同学加入队伍。保证该名同学此前不在队伍中。
## 输出格式


输出 $M$ 行，依次表示对于每次点名，同学们最少要进行几次交换位置，才能完成按身高排序的要求。
## 样例

### 样例输入 #1
```
5
170 165 168 160 175
4
0
3
2
1
```
### 样例输出 #1
```
0
1
1
2
```
### 样例输入 #2
```
4
20 20 20 10
4
0
1
2
3
```
### 样例输出 #2
```
0
0
0
1
```
## 提示


对于所有的测试点，保证 $1 \le M \le N \le 2000$。对于 $50\%$ 的测试点，保证所有同学的身高互不相同。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[2005],b[2005],p,sum=0;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
cin>>m;
for(int i=1;i<=m;i++){
cin>>p;
sum=0;
p+=1;
b[i]=a[p];
for(int j=1;j<=i;j++){
if(b[j]>b[i]){
swap(b[j],b[i]);
sum+=1;
}
}
cout<<sum<<endl;
}
return 0;
}
```

---

## 题目: B3958

**分类：GESP--GESP4级**

**提交时间：2024-09-05 21:13:16**

---
title: "[GESP202403 四级] 相似字符串"
layout: "post"
diff: 普及-
pid: B3958
tag: ['2024', '字符串（入门）', 'GESP']
---
# [GESP202403 四级] 相似字符串
## 题目描述


对于两个字符串 $A$ 和 $B$，如果 $A$ 可以通过删除一个字符，**或**插入一个字符，**或**修改一个字符变成 $B$，那么我们说 $A$ 和 $B$ 是相似的。

比如 $\texttt{apple}$ 可以通过插入一个字符变成 $\texttt{applee}$，可以通过删除一个字符变成 $\texttt{appe}$，也可以通过修改一个字符变成 $\texttt{bpple}$。因此 $\texttt{apple}$ 和 $\texttt{applee}$、$\texttt{appe}$、$\texttt{bpple}$ 都是相似的。但 $\texttt{applee}$ 并不能 通过任意一个操作变成 $\texttt{bpple}$，因此它们并不相似。

特别地，两个完全相同的字符串也是相似的。

给定 $T$ 组 $A,B$，请你分别判断它们是否相似。
## 输入格式

第一行一个正整数 $T$。  
接下来 $T$ 行，每行两个用空格隔开的字符串 $A$ 和 $B$。  
## 输出格式

对组 $A,B$，如果他们相似，输出 ``similar``，否则输出 ``not similar``。
## 样例

### 样例输入 #1
```
5
apple applee
apple appe
apple bpple
applee bpple
apple apple
```
### 样例输出 #1
```
similar
similar
similar
not similar
similar
```
## 提示

对全部的测试数据，保证 $1 \leq T \leq 100$，$A$ 和 $B$ 的长度不超过 $50$，仅含小写字母。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,cnt=0,sum=0;
string a,b;
int main()
{
cin>>t;
while(t--)
{
cin>>a>>b;
cnt=0;
sum=0;
if(a==b)
{
cout<<"similar"<<endl;
continue;
}
if(a.size()==b.size())
{
for(int i=0;i<a.size();i++)
{
if(a[i]==b[i])
{
cnt+=1;
}
}
if(cnt+1==a.size()||cnt==a.size())
{
cout<<"similar"<<endl;
}
else
{
cout<<"not similar"<<endl;
}
}
else if(a.size()+1==b.size())
{
for(int i=0;i<b.size();i++)
{
if(a[sum]==b[i])
{
cnt+=1;
sum+=1;
}
}
if(cnt==a.size())
{
cout<<"similar"<<endl;
}
else
{
cout<<"not similar"<<endl;
}
}
else if(a.size()-1==b.size())
{
swap(a,b);
for(int i=0;i<b.size();i++)
{
if(a[sum]==b[i])
{
cnt+=1;
sum+=1;
}
}
if(cnt==a.size())
{
cout<<"similar"<<endl;
}
else
{
cout<<"not similar"<<endl;
}
}
else
{
cout<<"not similar"<<endl;
}
}
return 0;
}
```

---

## 题目: B3959

**分类：GESP--GESP4级**

**提交时间：2024-08-27 21:32:26**

---
title: "[GESP202403 四级] 做题"
layout: "post"
diff: 普及-
pid: B3959
tag: ['贪心', '2024', '排序', 'GESP']
---
# [GESP202403 四级] 做题
## 题目描述

小杨同学为了提高自己的实力制定了做题计划，在第 $k$ 天时，他必须要完成 $k$ 道题，否则他就会偷懒。

小杨同学现在找到了一个题库，一共有 $n$ 套题单，每一套题单中有一定数量的题目。但是他十分挑剔，每套题单他只会使用一次，每一天也只能使用一套题单里的题目，之后那套题单就会弃之不用。对于每套题单，他不必完成题单内所有的题。

那么问题来了，小杨同学最多做题几天才偷懒呢？
## 输入格式

第一行，一个整数为 $n$，表示有多少套题单。  
第二行 $n$ 个整数 $a_1, a_2, \dots a_n$，分别表示每套题单有多少道题。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
4
3 1 4 1

```
### 样例输出 #1
```
3
```
## 提示

### 数据规模与约定
对全部的测试数据，保证 $1 \leq n \leq 10^6$，$1 \leq a_i \leq 10^9$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int sum=1,n,a[1000005];
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
sort(a+1,a+n+1);
for(int i=1;i<=n;i++)
{
if(a[i]<sum)
{
continue;
}
else
{
sum++;
}
}
cout<<sum-1;
}
```

---

## 题目: B3968

**分类：GESP--GESP5级**

**提交时间：2024-11-29 20:43:54**

---
title: "[GESP202403 五级] 成绩排序"
layout: "post"
diff: 普及-
pid: B3968
tag: ['模拟', '2024', '排序', 'GESP']
---
# [GESP202403 五级] 成绩排序
## 题目描述

有 $n$ 名同学，每名同学有语文、数学、英语三科成绩，你需要按照如下规则对所有同学的成绩从高到低排序：

1. 比较总分，高者靠前；
2. 如果总分相同，则比较语文和数学两科的总分，高者靠前；
3. 如果仍相同，则比较语文和数学两科的最高分，高者靠前；
4. 如果仍相同，则二人并列。

你需要输出每位同学的排名，如遇 $x$ 人并列，则他们排名相同，并留空后面的 $x - 1$ 个名次。例如，有 $3$ 名同学并列第 $1$，则后一名同学自动成为第 $4$ 名。
## 输入格式

第一行一个整数 $N$，表示同学的人数。  
接下来 $N$ 行，每行三个非负整数 $c_i, m_i, e_i$ 分别表示该名同学的语文、数学、英语成绩。  
## 输出格式

输出 $N$ 行，按输入同学的顺序，输出他们的排名。  
**注意：请不要按排名输出同学的序号，而是按同学的顺序输出他们各自的排名。**
## 样例

### 样例输入 #1
```
6
140 140 150
140 149 140
148 141 140
141 148 140
145 145 139
0 0 0
```
### 样例输出 #1
```
1
3
4
4
2
6
```
## 提示

- 对 $30\%$ 的数据，$N \leq 100$，且所有同学总分各不相同。
- 对全部的测试数据，保证 $2 \leq N \leq 10^4$，$0 \leq c_i, m_i, e_i \leq 150$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,num=0,cnt=0,c[10005];
struct student{
int c,m,e,sum,num1,ans,flag;
}a[10005];
bool judge(student x,student y){
if(x.sum!=y.sum){
return x.sum>y.sum;
}
else if(x.sum==y.sum&&(x.c+x.m!=y.c+y.m)){
return x.c+x.m>y.c+y.m;
}
else if(x.sum==y.sum&&(x.c+x.m==y.c+y.m)&&(max(x.c,x.m)!=max(y.c,y.m))){
return max(x.c,x.m)>max(y.c,y.m);
}
else{
return true;
}
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i].c>>a[i].m>>a[i].e;
a[i].sum=a[i].c+a[i].m+a[i].e;
a[i].num1=i;
}
sort(a+1,a+n+1,judge);
//	for(int i=1;i<=n;i++){
//		cout<<a[i].c<<" "<<a[i].m<<" "<<a[i].e<<" "<<a[i].sum<<" "<<a[i].num1<<" "<<a[i].ans<<" "<<a[i].flag<<endl;
//	}
for(int i=1;i<=n;i++){
if(a[i-1].sum==a[i].sum&&(a[i-1].c+a[i-1].m==a[i].c+a[i].m)&&(max(a[i-1].c,a[i-1].m)==max(a[i].c,a[i].m))){
c[a[i].num1]=c[a[i-1].num1];
cnt+=1;
}
else{
cnt+=1;
c[a[i].num1]=cnt;
}
}
for(int i=1;i<=n;i++){
cout<<c[i]<<endl;
}
return 0;
}
```

---

## 题目: B3969

**分类：GESP--GESP5级**

**提交时间：2024-12-01 10:46:27**

---
title: "[GESP202403 五级] B-smooth 数"
layout: "post"
diff: 普及-
pid: B3969
tag: ['2024', '素数判断,质数,筛法', 'GESP']
---
# [GESP202403 五级] B-smooth 数
## 题目描述

小杨同学想寻找一种名为 $ B $-smooth 数的正整数。 

如果一个正整数的最大质因子不超过 $ B $，则该正整数为 $ B $-smooth 数。小杨同学想知道，对于给定的 $ n $ 和 $ B $，有多少个不超过 $ n $ 的 $ B $-smooth 数。
## 输入格式

第一行包含两个正整数 $ n $ 和 $ B $，含义如题面所示。
## 输出格式

输出一个非负整数，表示不超过 $ n $ 的 $ B $-smooth 数的数量。
## 样例

### 样例输入 #1
```
10 3
```
### 样例输出 #1
```
7
```
## 提示

### 数据规模与约定

| 子任务 | 得分 | $n \leq $ | $B$ |
| :-: | :-: | :-: | :-: |
| $1$ | $30$ | $10^3$ | $1 \leq B \leq 10^3$ |
| $2$ | $30$ | $10^6$ | $\sqrt n \leq B \leq 10^6$ |
| $3$ | $40$ | $10^6$ | $1 \leq B \leq 10^6$ | 

对全部的测试数据，保证 $1 \leq n, B \leq 10^6$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,b,a[1000005],sum=0;
void prime(){
for(int i=2;i<=n;i++){
if(!a[i]){
for(int j=i;j<=n;j+=i){
a[j]=i;
}
}
}
}
int main(){
cin>>n>>b;
a[1]=1;
prime();
for(int i=1;i<=n;i++){
if(a[i]<=b){
sum+=1;
}
}
cout<<sum;
return 0;
}
```

---

## 题目: B3970

**分类：洛谷入门赛**

**提交时间：2024-06-03 14:10:10**

---
title: "[语言月赛 202405] 数字取模"
layout: "post"
diff: 入门
pid: B3970
tag: ['2024', 'O2优化', '顺序结构', '语言月赛']
---
# [语言月赛 202405] 数字取模
## 题目描述

小 S 的生日就要到了，小 Q 决定送给小 S 数字 $x$ 当做礼物。为此，她首先准备了一个四位数 $x$。

但是，小 S 并不喜欢 $\geq k$ 的数字。因此，小 Q 要将 $x$ 的**每一位**上的数字分别变成这一位数字除以 $k$ 得到的余数。

请你告诉小 Q 最终 $x$ 会变成什么样子。
## 输入格式

一行，两个用空格隔开的正整数 $x, k$，其中 $x$ 表示小 Q 准备的数字，保证是一个**四位正整数**。$k$ 的含义参照题目描述。
## 输出格式

一行，一个非负整数，表示 $x$ 每一位对 $k$ 取余后的数字。
## 样例

### 样例输入 #1
```
7432 3

```
### 样例输出 #1
```
1102

```
### 样例输入 #2
```
7070 7

```
### 样例输出 #2
```
0

```
### 样例输入 #3
```
1234 9

```
### 样例输出 #3
```
1234

```
### 样例输入 #4
```
7123 7

```
### 样例输出 #4
```
123

```
## 提示

### 样例 1 解释

数字 $7$ 对 $3$ 取余等于 $1$，数字 $4$ 对 $3$ 取余等于 $1$，因此最后 $x$ 会变成 $1102$。

### 样例 2 解释

两个 $7$ 对 $7$ 取余后都变为 $0$，于是整个数字都变成 $0$，注意不要输出多余的前导 $0$。样例 4 同理。

### 样例 3 解释

数字 $1, 2, 3, 4$ 都 $< 9$，所以整个数字不变。

### 数据范围

对于前 $30 \%$ 的数据，保证 $x$ 的十位、百位、千位都 $< k$。  
对于另 $30 \%$ 的数据，保证 $x$ 的个位、十位、百位都 $< k$。  
对于 $100 \%$ 的数据，保证 $1000 \leq x \leq 9999$，$1 \leq k \leq 9$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int a[20], k;
char str[20];
cin >> str >> k;
int n = strlen(str);
bool leadingZero = true;
for (int i = 0; i < n; i++)
{
a[i] = (str[i] - '0') % k;
}
for (int i = 0; i < n; i++)
{
if (a[i] != 0 || !leadingZero)
{
cout << a[i];
leadingZero = false;
}
}
// 如果全为零
if (leadingZero)
{
cout << "0";
}
return 0;
}
```

---

## 题目: B3972

**提交时间：2024-06-03 14:20:20**

---
title: "[语言月赛 202405] 二进制"
layout: "post"
diff: 入门
pid: B3972
tag: ['2024', 'O2优化', '循环结构', '语言月赛']
---
# [语言月赛 202405] 二进制
## 题目描述

在介绍十进制转二进制的篇目中，我们总会看到这样的方法：

- 求出这个数字除以 $2$ 的**商**和**余数**，然后将余数写在右侧，用商替换原来的数字；
- 重复以上过程直到这个数字变为 $0$；
- 最后将右侧的所有余数**倒序**排列，得到的就是原数字的二进制形式。

小 S 也在学习二进制，不过她很懒，不想计算那么多次除法。于是她找到了你，希望你能为她写一个程序，帮助她得到上述过程中所有的**商**和**余数**。
## 输入格式

一行，一个正整数 $n$，表示她想要转成二进制的数字。
## 输出格式

输出若干行，每一行两个数字 $x_i$ 和 $y_i$，表示第 $i$ 次除法得到的商和余数。你应该保证 $y_i$ 是 $0$ 或 $1$。
## 样例

### 样例输入 #1
```
9

```
### 样例输出 #1
```
4 1
2 0
1 0
0 1

```
### 样例输入 #2
```
22

```
### 样例输出 #2
```
11 0
5 1
2 1
1 0
0 1

```
### 样例输入 #3
```
1

```
### 样例输出 #3
```
0 1

```
## 提示

### 样例 1 解释

首先，$9 = 2 \times 4 + 1$，所以第一行输出 `4 1`，并令 $9$ 变为 $4$； 
然后，$4 = 2 \times 2 + 0$，所以第二行输出 `2 0`，并令 $4$ 变为 $2$；  
接着，$2 = 2 \times 1 + 0$，所以第三行输出 `1 0`，并令 $2$ 变为 $1$；  
最后，$1 = 2 \times 0 + 1$，所以第四行输出 `0 1`，并令 $1$ 变为 $0$。过程结束。

### 样例 2 解释

首先，$22 = 2 \times 11 + 0$，所以第一行输出 `11 0`，并令 $22$ 变为 $11$；  
然后，$11 = 2 \times 5 + 1$，所以第二行输出 `5 1`，并令 $11$ 变为 $5$；  
接着，$5 = 2 \times 2 + 1$，所以第三行输出 `2 1`，并令 $5$ 变为 $2$；  
再然后，$2 = 2 \times 1 + 0$，所以第四行输出 `1 0`，并令 $2$ 变为 $1$； 
最后，$1 = 2 \times 0 + 1$，所以第五行输出 `0 1`，并令 $1$ 变为 $0$。过程结束。

### 数据范围

对于前 $30 \%$ 的数据，保证 $n$ 为若干个 $2$ 的乘积，且 $1 \leq n \leq 10^9$；  
对于另 $30 \%$ 的数据，保证除法最多只进行 $3$ 次；  
对于 $100 \%$ 的数据，保证 $1 \leq n \leq 10^{18}$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
long long n;
cin>>n;
while(n!=0)
{
cout<<n/2<<" ";
cout<<n%2<<endl;
n=n/2;
}
return 0;
}
```

---

## 题目: B3974

**分类：洛谷入门赛**

**提交时间：2024-06-03 14:28:47**

---
title: "[语言月赛 202405] 放行李"
layout: "post"
diff: 入门
pid: B3974
tag: ['2024', 'O2优化', '循环结构', '数组', '语言月赛']
---
# [语言月赛 202405] 放行李
## 题目描述

小 S 推着她的行李箱走上高铁，开启了一段精彩的旅行。

这节车厢的行李架分为左右两列，每一列分别有 $n$ 个位置，从前往后按 $1$ 到 $n$ 依次编号。对于任意两个编号为 $i$ 和 $j$ 的位置（不区分是哪一列），它们之间的距离是 $\vert i - j \vert$。

$\vert x \vert$ 代表 $x$ 的绝对值。当 $x \geq 0$，$\vert x \vert = x$；当 $x < 0$，$\vert x \vert = -x$。

用 $0$ 表示行李架左边一列，用 $1$ 来表示右边一列。小 S 的座位在 $p$ 列的编号 $q$ 的位置处（$p = 0$ 或 $1$，$1 \leq q \leq n$）。

现在小 S 想要在某个位置摆放她的行李箱。然而，已经有一些位置被其它行李占用，所以那些位置是不能摆放行李箱的。小 S 只能选择一个没有行李的空位。

在此基础上，小 S 首先希望行李箱的摆放位置距离她尽可能小。其次，如果有两个**不同列**的空位置和她的位置距离最小且相同，那么小 S 会选择和她在**同一列**的那一个位置。

现在给你左右两列的行李摆放情况，请你找到一个满足条件的最佳行李摆放位置。如果没有任何空位置，请你输出 $-1$。
## 输入格式

第一行一个整数 $n$，表示每一列位置数量。  
第二行 $n$ 个 $0$ 或 $1$ 的整数，第 $i$ 个整数表示**左列**第 $i$ 个位置是否已经有行李，若为 $1$ 则有行李，若为 $0$ 则没有行李。  
第三行 $n$ 个 $0$ 或 $1$ 的整数，第 $i$ 个整数表示**右列**第 $i$ 个位置是否已经有行李，若为 $1$ 则有行李，若为 $0$ 则没有行李。

第四行，两个整数 $p, q$，表示小 S 所在位置是哪一列，在这一列的哪个位置。
## 输出格式

输出一行，若有可以摆放行李的位置，则输出两个整数，分别表示最佳位置在左列还是右列，最佳位置与小 S 所在位置的**距离**。

如果没有可以放行李的位置，则输出一个整数 $-1$。
## 样例

### 样例输入 #1
```
5
0 1 1 1 1
1 0 1 1 1
0 3

```
### 样例输出 #1
```
1 1

```
### 样例输入 #2
```
5
0 1 1 1 1
0 1 1 1 1
0 3

```
### 样例输出 #2
```
0 2

```
### 样例输入 #3
```
5
1 1 1 1 1
1 1 1 1 1
0 3

```
### 样例输出 #3
```
-1

```
## 提示

### 样例 1 解释

为了方便观察，我们用$\textcolor{green}{绿色}$来表示没有行李的空位，用$\textcolor{red}{红色}$来表示有行李。

样例 1 如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/nngzg0w3.png?x-oss-process=image)

此时由于右列第 $2$ 个位置距离小 S 更近，所以右列第 $2$ 个位置是最佳位置，答案是 `1 1` （表示这个位置在右列，和小 S 位置距离为 $1$）。

### 样例 2 解释

样例 2 如图：

![](https://cdn.luogu.com.cn/upload/image_hosting/5i7shnxg.png?x-oss-process=image)

此时由于两个位置距离小 S 都相同，而左列的那个位置和小 S 在同一列，所以答案是 `0 2` （表示这个位置在左列，和小 S 位置距离为 $2$）。

### 样例 3 解释

由于没有任何一个空位，所以输出 $-1$。

### 数据范围

对于前 $30 \%$ 的数据，保证小 S 一定在左列，左列所有位置一定都有行李。  
对于另 $30 \%$ 的数据，保证左列有且仅有一个空位置，右列有且仅有一个空位置。  
对于 $100 \%$ 的数据，保证 $1 \leq q \leq n \leq 10^6$，$p$ 为 $0$ 或 $1$，第二行、第三行读入的整数为 $0$ 或 $1$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int n, p, q, miny = INT_MAX, x, y;
bool flag = false;
cin >> n;
int a[n], b[n];
for (int i = 0; i < n; i++)
{
cin >> a[i];
if (a[i] != 1)
{
flag = true;
}
}
for (int i = 0; i < n; i++)
{
cin >> b[i];
if (b[i] != 1)
{
flag = true;
}
}
cin >> p >> q;
if (!flag)
{
cout << -1 << endl;
return 0;
}
for (int i = 0; i < n; i++)
{
if (p == 0 && i == (q - 1))
{
continue;
}
if (a[i] == 0)
{
if (abs(q - 1 - i) < miny || (abs(q - 1 - i) == miny && p == 0))
{
miny = abs(q - 1 - i);
x = 0;
y = i + 1;
}
}
}
for (int i = 0; i < n; i++)
{
if (p == 1 && i == (q - 1))
{
continue;
}
if (b[i] == 0)
{
if (abs(q - 1 - i) < miny || (abs(q - 1 - i) == miny && p == 1))
{
miny = abs(q - 1 - i);
x = 1;
y = i + 1;
}
}
}
cout << x << " " << miny << endl;
return 0;
}
```

---

## 题目: B3987

**分类：洛谷入门赛**

**提交时间：2024-06-18 11:15:22**

---
title: "[语言月赛 202406] 朋友数列"
layout: "post"
diff: 入门
pid: B3987
tag: ['2024', 'Special Judge', 'O2优化', '数组', '语言月赛']
---
# [语言月赛 202406] 朋友数列
## 题目描述

小 K 喜欢数列。设数列 $a,b$ 的长度均为 $n$，$a_i$ 表示数列 $a$ 中第 $i(1 \le i \le n)$ 个数字，$b_i$ 表示数列 $b$ 中第 $i(1 \le i\le n)$ 个数字。

如果对于所有的 $1 \le i \le n$，$a_i+b_i$ 的值均相同，并且满足 $-10^9 \le a_i,b_i \le 10^9$，则小 K 称它们是一对朋友数列。

现在，小 K 随手写下了 $n$ 和数列 $a$，小 K 希望你能帮助小 K 找到数列 $a$ 的一个朋友数列。
## 输入格式

输入共两行。  

输入的第一行为一个整数 $n$。  
输入的第二行为 $n$ 个整数，第 $i$ 个数为 $a_i$。
## 输出格式

输出一行 $n$ 个整数，表示数列 $a$ 的一个朋友数列。

**可能有多种符合题意的答案，你只需要输出任意一种即可。**
## 样例

### 样例输入 #1
```
5
1 2 3 4 5

```
### 样例输出 #1
```
5 4 3 2 1

```
## 提示

### 数据规模与约定

- 对于 $20\%$ 的测试数据，$n=1$；
- 对于 $100\%$ 的测试数据，$1 \le n \le 10^5$，$|a_i| \le 10^9$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
int n;
cin >> n;
int a[100005];
// 读取输入
for (int i = 0; i < n; ++i) {
cin >> a[i];
}
// 输出朋友数列
for (int i = 0; i < n; ++i) {
cout << -a[i] << " ";
}
cout << endl;
return 0;
}
```

---

## 题目: B3998

**分类：Gesp**

**提交时间：2024-06-24 11:28:06**

---
title: "[洛谷 202406GESP 模拟 四级] 小苏的键盘"
layout: "post"
diff: 入门
pid: B3998
tag: ['字符串（入门）']
---
# [洛谷 202406GESP 模拟 四级] 小苏的键盘
## 题目描述

小苏同学有一个文本编辑器和一个奇怪的键盘。这个键盘有 26 个小写英文字母和退格键(backspace)，一共 27 个键。

每次当她按下任何一个小写英文字母的键的时候，文本编辑器就会在当前编辑文本的末端添加对应的字母。  
例如，假设当前文本是 `luog`，当她按下 `u` 键时，文本就会变成 `luogu`。

当她按下退格键的时候，文本编辑器就会删除当前文本的**最后一个**字母。如果当前文本是空的，则什么都不会发生。  
例如，如果当前文本是 `luogu`，当她按下退格键后，文本就会变成 `luog`。

现在，给定小苏的按键情况，已知在初始时文本为空，请你求出小苏按完给定的所有键后的文本是什么。
## 输入格式

第一行是一个整数 $n$（$1 \leq n \leq 100$），表示按键的次数。  
第二行是 $n$ 个用空格隔开的字符串，依次表示小苏按下的每个按键。

输入的每个字符串要么是一个小写字母，表示对应的按键，要么是字符串 `<bs>`，表示退格键。
## 输出格式

输出一行一个字符串，表示小苏按完给定的所有按键后的文本。**数据保证输出不是空串**。
## 样例

### 样例输入 #1
```
5
a b c d e
```
### 样例输出 #1
```
abcde
```
### 样例输入 #2
```
3
a <bs> b
```
### 样例输出 #2
```
b
```


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int n, sum = 0;
char a[105];
for (int i = 0; i < 105; i++)
{
a[i] = ' ';
}
string b;
cin >> n;
int current_index = 0;
for (int i = 0; i < n; i++)
{
cin >> b;
if (b == "<bs>")
{
if (current_index > 0) // 确保在退格时不删除空字符串的内容
{
a[current_index - 1] = ' ';
current_index -= 1;
}
}
else
{
a[current_index] = b[0];
current_index++;
}
}
for (int i = 0; i < n + sum; i++)
{
if (a[i] == ' ')
{
continue;
}
else
{
cout << a[i];
}
}
return 0;
}
```

---

## 题目: B4005

**分类：GESP--GESP4级**

**提交时间：2024-08-20 20:29:13**

---
title: "[GESP202406 四级] 黑白方块"
layout: "post"
diff: 普及-
pid: B4005
tag: ['2024', '枚举', '前缀和', 'GESP']
---
# [GESP202406 四级] 黑白方块
## 题目描述

小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。对于网格图中的一个子矩形，小杨认为它是平衡的当且仅当其中黑色格子与白色格子数量相同。小杨想知道最大的平衡子矩形包含了多少个格子。
## 输入格式

第一行包含两个正整数 $n,m$，含义如题面所示。

之后 $n$ 行，每行一个长度为 $m$ 的 $01$ 串，代表网格图第 $i$ 行格子的颜色，如果为 $0$，则对应格子为白色，否则为黑色。
## 输出格式

输出一个整数，代表最大的平衡子矩形包含格子的数量，如果不存在则输出 $0$。
## 样例

### 样例输入 #1
```
4 5
00000
01111
00011
00011
```
### 样例输出 #1
```
16
```
## 提示

**【样例解释】**

对于样例 $1$，假设 $(i,j)$ 代表第 $i$ 行第 $j$ 列，最大的平衡子矩形的四个顶点分别为 $(1,2),(1,5),(4,2),(4,5)$。

**【数据范围】**

对于全部数据，保证有 $1\leq n,m\leq 10$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,b[15][15],maxn=0,sum0=0,sum1=0;
string a[15];
int main()
{
cin>>n>>m;
for(int i=0;i<n;i++)
{
cin>>a[i];
}
for(int i=0;i<n;i++)
{
for(int j=0;j<m;j++)
{
b[i][j]=a[i][j]-'0';
}
}
for(int x1=0;x1<n;x1++)
{
for(int y1=0;y1<m;y1++)
{
for(int x2=0;x2<n;x2++)
{
for(int y2=0;y2<m;y2++)
{
sum0=0;
sum1=0;
for(int i=x1;i<=x2;i++)
{
for(int j=y1;j<=y2;j++)
{
if(b[i][j]==0)
{
sum0+=1;
}
else
{
sum1+=1;
}
}
}
if(sum0==sum1&&sum0!=0&&sum1!=0)
{
maxn=max((x2-x1+1)*(y2-y1+1),maxn);
}
}
}
}
}
cout<<maxn;
return 0;
}
```

---

## 题目: B4006

**分类：GESP--GESP4级**

**提交时间：2024-08-20 20:40:16**

---
title: "[GESP202406 四级] 宝箱"
layout: "post"
diff: 普及-
pid: B4006
tag: ['2024', '排序', '双指针 two-pointer', 'GESP']
---
# [GESP202406 四级] 宝箱
## 题目描述

小杨发现了 $n$ 个宝箱，其中第 $i$ 个宝箱的价值是 $a_i$。

小杨可以选择一些宝箱放入背包并带走，但是小杨的背包比较特殊，假设小杨选择的宝箱中最大价值为 $x$，最小价值为 $y$，小杨需要保证 $x-y\leq k$，否则小杨的背包会损坏。

小杨想知道背包不损坏的情况下，自己能够带走宝箱的总价值最大是多少。
## 输入格式

第一行包含两个正整数 $n,k$，含义如题面所示。

第二行包含 $n$ 个正整数 $a_1,a_2,\dots,a_n$，代表宝箱的价值。
## 输出格式

输出一个整数，代表带走宝箱的最大总价值。
## 样例

### 样例输入 #1
```
5 1
1 2 3 1 2
```
### 样例输出 #1
```
7
```
## 提示

**【样例解释】**

在背包不损坏的情况下，小杨可以拿走两个价值为 $2$ 的宝箱和一个价值为 $3$ 的宝箱。

**【数据范围】**

对于全部数据，保证有 $1\leq n\leq 1000$，$0\leq k\leq 1000$，$1\leq a_i\leq 1000$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,k,a[1005],sum=0,ans=0;
int main()
{
cin>>n>>k;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
sort(a+1,a+n+1);
for(int i=1;i<=n;i++)
{
sum=0;
for(int j = i;j>=1;j--)
{
if(a[i]-a[j]<=k)
{
sum+=a[j];
}
}
ans=max(ans,sum);
}
cout<<ans;
return 0;
}
```

---

## 题目: B4050

**分类：GESP--GESP5级**

**提交时间：2024-12-04 20:09:37**

---
title: "[GESP202409 五级] 挑战怪物"
layout: "post"
diff: 普及/提高-
pid: B4050
tag: ['贪心', '2024', '数论', 'GESP']
---
# [GESP202409 五级] 挑战怪物
## 题目描述

小杨正在和一个怪物战斗，怪物的血量为 $h$，只有当怪物的血量**恰好**为 $0$ 时小杨才能够成功击败怪物。

小杨有两种攻击怪物的方式：
- 物理攻击。假设当前为小杨第  $i$ 次使用物理攻击，则会对怪物造成 $2^{i - 1}$ 点伤害。
- 魔法攻击。小杨选择任意一个质数 $x$（ 不能超过怪物当前血量），对怪物造成 $x$ 点伤害。由于小杨并不擅长魔法，他只能使用**至多一次**魔法攻击。

小杨想知道自己能否击败怪物，如果能，小杨想知道自己最少需要多少次攻击。
## 输入格式

**本题单个测试点内有多组测试数据**。第一行包含一个正整数 $t$，代表测试用例组数。

接下来是 $t$ 组测试用例。对于每组测试用例，只有一行一个整数 $h$，代表怪物血量。
## 输出格式

对于每组测试用例，如果小杨能够击败怪物，输出一个整数，代表小杨需要的最少攻击次数，如果不能击败怪物，
输出 $-1$。
## 样例

### 样例输入 #1
```
3
6
188
9999
```
### 样例输出 #1
```
2
4
-1
```
## 提示

### 样例 1 解释

对于第一组测试用例，一种可能的最优方案为，小杨先对怪物使用魔法攻击，选择质数 $5$ 造成 $5$ 点伤害，之后对怪
物使用第 $1$ 次物理攻击，造成 $2^{1 - 1} = 1$ 点伤害，怪物血量恰好为 $0$，小杨成功击败怪物。

### 数据规模与约定

| 子任务编号 | 分数占比 | $t$ | $h$ |
| :-: | :-: | :-: | :-: |
| $1$ | $20\%$ | $\leq 5$ | $\leq 10$ |
| $2$ | $20\%$ | $\leq 10$ | $\leq 100$ |
| $3$ | $60\%$ | $\leq 10$ | $10^5$ |

对于全部的测试数据，保证 $1 \leq t \leq 10$，$1 \leq h \leq 10^5$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],sum=1,ans=0,x;
void prime(){
a[1]=0;
for(long long i=2;i<=sqrt(100005);i++){
if(a[i]==0){
for(long long j=i*i;j<=100005;j+=i){
a[j]=1;
}
}
}
}
int main(){
prime();
cin>>n;
for(int i=1;i<=n;i++){
cin>>x;
sum=1;
ans=0;
while(x>=0){
if(a[x]==0){
ans+=1;
cout<<ans<<endl;
break;
}
else{
ans+=1;
x-=sum;
sum*=2;
}
}
if(x<0){
cout<<-1<<endl;
}
}
return 0;
}
```

---

## 题目: B4051

**分类：GESP--GESP5级**

**提交时间：2024-11-25 19:42:34**

---
title: "[GESP202409 五级] 小杨的武器"
layout: "post"
diff: 普及-
pid: B4051
tag: ['贪心', '2024', 'GESP']
---
# [GESP202409 五级] 小杨的武器
## 题目描述

小杨有 $n$ 种不同的武器，他对第 $i$ 种武器的初始熟练度为 $c_i$。

小杨会依次参加 $m$ 场战斗，每场战斗小杨只能且必须选择一种武器使用，假设小杨使用了第 $i$ 种武器参加了第 $j$ 场战斗，战斗前该武器的熟练度为 $c'_i$，则战斗后小杨对该武器的熟练度会变为 $c'_i + a_j$。需要注意的是，$a_j$ 可能是正数，$0$ 或负数，这意味着小杨参加战斗后对武器的熟练度可能会提高，也可能会不变，还有可能降低。

小杨想请你编写程序帮他计算出如何选择武器才能使得 $m$ 场战斗后，自己对 $n$ 种武器的熟练度的**最大值尽可能大**。
## 输入格式

第一行包含两个正整数 $n,m$，含义如题面所示。  
第二行包含 $n$ 个正整数 $c_1, c_2, \dots c_n$，代表小杨对武器的初始熟练度。  
第三行包含 $m$ 个正整数 $a_1, a_2, \dots a_m$，代表每场战斗后武器熟练度的变化值。
## 输出格式

输出一个整数，代表 $m$ 场战斗后小杨对 $n$ 种武器的熟练度的最大值最大是多少。
## 样例

### 样例输入 #1
```
2 2
9 9
1 -1
```
### 样例输出 #1
```
10
```
## 提示

### 样例 1 解释

一种最优的选择方案为，第一场战斗小杨选择第一种武器，第二场战斗小杨选择第二种武器。

### 数据规模与约定

| 子任务编号 | 数据点占比 | $n$ | $m$ |
| :-: | :-: | :-: | :-: |
| $1$ | $20\%$ | $=1$ | $\leq 10^5$ |
| $2$ | $20\%$ | $\leq 10^5$ | $=2$ |
| $3$ | $60\%$ | $\leq 10^5$ | $\leq 10^5$ |

对全部的测试数据，保证 $1 \leq n, m \leq 10^5$，$-10^4 \leq c_i, a_i \leq 10^4$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],b[100005];
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=m;i++){
cin>>b[i];
}
sort(a+1,a+n+1);
for(int i=1;i<=m;i++){
if(n!=1){
if(b[i]>=0){
a[n]+=b[i];
}
else{
a[1]+=b[i];
}
}
else{
a[1]+=b[i];
}
}
cout<<a[n];
return 0;
}
```

---

## 题目: B4070

**分类：GESP--GESP5级**

**提交时间：2025-03-19 20:55:19**

---
title: "[GESP202412 五级] 奇妙数字"
layout: "post"
diff: 普及/提高-
pid: B4070
tag: ['2024', 'GESP']
---
# [GESP202412 五级] 奇妙数字
## 题目描述

小杨认为一个数字 $x$ 是奇妙数字当且仅当 $x=p^a$，其中 $p$ 为任意质数且 $a$ 为正整数。例如，$8=2^3$，所以 $8$ 是奇妙的，而 $6$ 不是。

对于一个正整数 $n$，小杨想要构建一个包含 $m$ 个奇妙数字的集合 $\{x_1,x_2,\cdots,x_m\}$，使其满足以下条件：
- 集合中不包含相同的数字。
- $x_1\times x_2\times \cdots\times x_m$ 是 $n$ 的因子（即 $x_1,x_2,\cdots,x_m$ 这 $m$ 个数字的乘积是 $n$ 的因子）。

小杨希望集合包含的奇妙数字尽可能多，请你帮他计算出满足条件的集合最多包含多少个奇妙数字。
## 输入格式

第一行包含一个正整数 $n$，含义如题面所示。
## 输出格式

输出一个正整数，代表满足条件的集合最多包含的奇妙数字个数。
## 样例

### 样例输入 #1
```
128
```
### 样例输出 #1
```
3
```
## 提示

#### 样例解释

关于本样例，符合题意的一个包含 $3$ 个奇妙数字的集合是 $\{2,4,8\}$。首先，因为 $2=2^1$，$4=2^2$，$8=2^3$，所以 $2,4,8$ 均为奇妙数字。同时，$2\times 4\times 8=64$ 是 $128$ 的的因子。

由于无法找到符合题意且同时包含 $4$ 个奇妙数字的集合，因此本样例的答案为 $3$。

#### 数据范围

对于 $100\%$ 的数据，保证 $2\le n\le 10^{12}$。

| 子任务编号 | 得分占比 | $n$ |
| :--: | :--: | :--: |
| $1$ | $20\%$ | $\le 10$ |
| $2$ | $20\%$ | $\le 1\,000$ |
| $3$ | $60\%$ | $\le 10^{12}$ |




### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000005];
int ans=0;
int maths(long long x){
for(int i=10;i>=1;i--){
if((1+i)*i/2<=x){
return i;
}
}
}
int main(){
cin>>n;
for(long long i=2;i<=sqrt(n);i++){
while(n%i==0){
n/=i;
a[i]+=1;
}
}
for(int i=2;i<=1000000;i++){
if(a[i]>=1){
ans+=maths(a[i]);
}
}
if(n>1){
ans+=1;
}
cout<<ans;
return 0;
}
```

---

## 题目: B4108

**分类：JOI（日本）第一次预选赛(第一次AK!!!)**

**提交时间：2025-01-02 18:55:44**

---
title: "[JOI2025 预选赛 R1H1] 铅笔 2"
layout: "post"
diff: 入门
pid: B4108
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H1] 铅笔 2
## 题目描述

JOI 君有 $A$ 日元，一根铅笔 $5$ 日元，问 JOI 君最多可以买多少根铅笔。
## 输入格式

一行一个正整数 $A$。
## 输出格式

一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
9
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
10
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
3
```
### 样例输出 #3
```
0
```
### 样例输入 #4
```
100
```
### 样例输出 #4
```
20
```
## 提示

### 样例解释
$1$ 根铅笔 $5$ 日元，$2$ 根铅笔 $10$ 日元，$3$ 根铅笔 $15$ 日元。

### 数据范围

$1\leq A\leq 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
cin>>n;
cout<<n/5;
return 0;
}
```

---

## 题目: B4109

**提交时间：2025-01-02 18:56:58**

---
title: "[JOI2025 预选赛 R1H1] 散步"
layout: "post"
diff: 入门
pid: B4109
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H1] 散步
## 题目描述

JOI 君在一条直线型道路上散步。

JOI 君会交替执行以下两种操作：
- 前进 $3\textrm{ m}$
- 后退 $2\textrm{ m}$

JOI 君的初始位置为 $0$，问 $X$ 次操作后 JOI 君在哪个位置。
## 输入格式

一行一个正整数 $X$。
## 输出格式

一行一个正整数表示答案。

## 样例

### 样例输入 #1
```
3
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
6
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
1
```
### 样例输出 #3
```
3
```
### 样例输入 #4
```
37
```
### 样例输出 #4
```
21
```
### 样例输入 #5
```
100
```
### 样例输出 #5
```
50
```
## 提示

### 样例解释

JOI 君的位置变化如下：

$$0\rightarrow 3\rightarrow 1 \rightarrow 4 \rightarrow 2\rightarrow 5 \rightarrow 3\rightarrow \ldots$$

### 数据范围

$1\leq X\leq 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=0;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
if(i%2==1){
sum+=3;
}
else{
sum-=2;
}
}
cout<<sum;
return 0;
}
```

---

## 题目: B4110

**分类：JOI（日本）第一次预选赛(第一次AK!!!)**

**提交时间：2025-01-02 18:59:04**

---
title: "[JOI2025 预选赛 R1H1] OIJ"
layout: "post"
diff: 入门
pid: B4110
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H1] OIJ
## 题目描述

给定长度为 $N$ 的字符串 $S$，仅包含 $\tt{J,O,I}$，三种字符，对字符串的每一个字符 $c$ 你需要做如下操作。

- 如果 $c=\tt{J}$，那么 $c'$ 为 $\tt{O}$
- 如果 $c=\tt{O}$，那么 $c'$ 为 $\tt{I}$
- 如果 $c=\tt{I}$，那么 $c'$ 为 $\tt{J}$
- 然后令 $c\leftarrow c'$。

求操作完的字符串。
## 输入格式

第一行一个正整数 $N$。

第二行一个长度为 $N$ 的字符串 $S$。

## 输出格式

一行一个字符串表示答案。
## 样例

### 样例输入 #1
```
3
JOI
```
### 样例输出 #1
```
OIJ
```
### 样例输入 #2
```
10
JOIOOJOOOJ
```
### 样例输出 #2
```
OIJIIOIIIO
```
## 提示

### 样例解释

执行操作以后 $\tt{JOI}$ 变为 $\tt{OIJ}$，$\tt{JOIOOJOOOJ}$ 变为 $\tt{OIJIIOIIIO}$。

### 数据范围 

$1\leq N\leq 100$，保证 $S$ 中只含 $\tt{J,O,I}$ 三种字符。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s;
int main(){
cin>>n>>s;
for(int i=0;i<n;i++){
if(s[i]=='J'){
s[i]='O';
}
else if(s[i]=='O'){
s[i]='I';
}
else{
s[i]='J';
}
}
cout<<s;
return 0;
}
```

---

## 题目: B4111

**分类：JOI（日本）第一次预选赛(第一次AK!!!)**

**提交时间：2025-01-02 19:03:21**

---
title: "[JOI2025 预选赛 R1H1] 铜锣烧"
layout: "post"
diff: 入门
pid: B4111
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H1] 铜锣烧
## 题目描述

JOI 君喜欢做铜锣烧。

有 $N$ 种馅料和 $M$ 种皮，第 $i(1\leq i\leq N)$ 种馅料的美味值为 $a_i$，第 $j$ 种皮的美味值为 $b_j$。用第 $i$ 种馅料和第 $j$ 种皮做成的铜锣烧的美味值为 $(a_i+b_j)\times \max(a_i,b_j)$，其中 $\max(x,y)$ 表示 $x$ 和 $y$ 中的较大值。

求所有的 $N\times M$ 种铜锣烧的美味值之和。
## 输入格式

第一行输入两个正整数 $N,M$。

第二行输入 $N$ 个正整数 $a_1,a_2,\ldots,a_N$。

第三行输入 $M$ 个正整数 $b_1,b_2,\ldots,b_M$。
## 输出格式

一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
2 2
1 2
2 5
```
### 样例输出 #1
```
79
```
### 样例输入 #2
```
1 5
50
9 7 5 4 1
```
### 样例输出 #2
```
13800
```
### 样例输入 #3
```
15 5
5 10 52 31 14 16 19 1 9 20 80 19 11 34 72
20 2 4 9 19
```
### 样例输出 #3
```
116756
```
## 提示

### 样例解释

对于样例 1，有四种铜锣烧，美味值分别为 $6,30,8,35$，和为 $79$。

### 数据范围 

$1\leq N\leq 100$，$1\leq M\leq 100$。对于任意 $i$ 满足$1\leq i\leq N$，$1\leq a_i\leq 100$。对于任意 $j$ 满足 $1\leq j\leq M$，$1\leq b_i\leq 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sum=0,a[105],b[105];
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=m;i++){
cin>>b[i];
}
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
sum+=(a[i]+b[j])*max(a[i],b[j]);
}
}
cout<<sum;
return 0;
}
```

---

## 题目: B4112

**分类：JOI（日本）第一次预选赛(第一次AK!!!)**

**提交时间：2025-01-02 19:04:06**

---
title: "[JOI2025 预选赛 R1H2] 徒步竞走"
layout: "post"
diff: 入门
pid: B4112
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H2] 徒步竞走
## 题目描述

比太郎以每秒 $V\textrm{ m}$ 的速度行走，问比太郎在 $T$ 秒内可以行走多少 $\rm{m}$。
## 输入格式

第一行一个正整数 $T$。

第二行一个正整数 $V$。
## 输出格式

一行一个正整数表示答案
## 样例

### 样例输入 #1
```
5
3
```
### 样例输出 #1
```
15
```
### 样例输入 #2
```
2
4
```
### 样例输出 #2
```
8
```
## 提示

### 样例解释

比太郎以 $3 \textrm{ m/s}$ 的速度行走 $5 \textrm{ s}$，可以行走 $15 \textrm{ m}$。

### 数据范围

$1\leq T\leq 100$，$1\leq V\leq 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,v;
int main(){
cin>>t>>v;
cout<<t*v;
return 0;
}
```

---

## 题目: B4113

**分类：JOI（日本）第一次预选赛(第一次AK!!!)**

**提交时间：2025-01-02 19:05:43**

---
title: "[JOI2025 预选赛 R1H2] 铁路旅行 3"
layout: "post"
diff: 入门
pid: B4113
tag: ['模拟', '2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H2] 铁路旅行 3
## 题目描述

比太郎乘坐 JOI 列车旅行，在 $P$ 公里之前按每公里需 $A$ 日元计算，之后每公里需 $B$ 日元计算。

比太郎乘坐了 $Q$ 公里的列车，求他需要的票价。
## 输入格式

第一行两个正整数 $P,Q$。

第二行两个正整数 $A,B$。
## 输出格式

输出一行一个正整数表示答案。
## 样例

### 样例输入 #1
```
3 5
2 1
```
### 样例输出 #1
```
8
```
### 样例输入 #2
```
3 2
2 1
```
### 样例输出 #2
```
4
```
### 样例输入 #3
```
3 3
5 5
```
### 样例输出 #3
```
15
```
## 提示

### 样例解释

对于样例 $1$，$5$ 公里路程中的前 $3$ 公里每公里 $2$ 日元。接下来的 $2$ 公里每公里 $1$ 日元。因此，总共花费 $8$ 日元。

对于样例 $2$，乘车距离为 $2$ 公里，因此每公里花费 $2$ 日元。因此，总共花费 $4$ 日元。

对于样例 $3$，乘车距离为 $3$ 公里，因此每公里花费 $5$ 日元。因此，总共花费 $15$ 日元。

### 数据范围 

$1\leq P,Q,A,B\leq 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int p,q,a,b,ans=0;
int main(){
cin>>p>>q>>a>>b;
for(int i=1;i<=q;i++){
if(i<=p){
ans+=a;
}
else{
ans+=b;
}
}
cout<<ans;
return 0;
}
```

---

## 题目: B4114

**分类：JOI（日本）第一次预选赛(第一次AK!!!)**

**提交时间：2025-01-02 19:10:42**

---
title: "[JOI2025 预选赛 R1H2] 猜拳"
layout: "post"
diff: 入门
pid: B4114
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H2] 猜拳
## 题目描述

给出了长度为 $N$ 的字符串 $S$ 和 $T$。 $S$ 的每个字母都是 $\tt R$ 或 $\tt S$。 $T$ 中的每个字符要么是 $\tt R$，要么是 $\tt P$。

葵和比太郎玩了 $N$ 次石头剪刀布。葵的第 $i$ 个 $(1 ≤ i ≤ N)$ 手势为 $S_i$。比太郎的第 $i$ 个 $(1 ≤ i ≤ N)$ 手势是 $T_i$。其中字符 $\tt R$ 表示石头，$\tt S$ 表示剪刀，$\tt P$ 表示布。

求所有 $N$ 次石头剪刀布中葵获胜的次数和比太郎获胜的次数。
## 输入格式

第一行一个正整数 $N$。

第二行一个长度为 $N$ 的字符串 $S$。

第三行一个长度为 $N$ 的字符串 $T$。
## 输出格式

输出空格分割的两个正整数，分别表示葵胜利的次数和比太郎胜利的次数。
## 样例

### 样例输入 #1
```
3
RSR
PPR
```
### 样例输出 #1
```
1 1
```
### 样例输入 #2
```
5
RRRRR
PPPPP
```
### 样例输出 #2
```
0 5
```
### 样例输入 #3
```
4
RSRR
RPRR
```
### 样例输出 #3
```
1 0
```
### 样例输入 #4
```
6
RSSRSS
PPRRRP
```
### 样例输出 #4
```
2 3
```
## 提示

### 样例解释

$\tt R$ 可以赢 $\tt S$，$\tt S$ 可以赢 $\tt P$，$\tt P$ 可以赢 $\tt R$。

### 数据范围

$1\leq N\leq 100$，保证输入数据是合法的。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum1,sum2;
string s,t;
int main(){
cin>>n;
cin>>s>>t;
for(int i=0;i<n;i++){
if(s[i]=='R'&&t[i]=='S'||s[i]=='S'&&t[i]=='P'||s[i]=='P'&&t[i]=='R'){
sum1+=1;
}
else if(t[i]=='R'&&s[i]=='S'||t[i]=='S'&&s[i]=='P'||t[i]=='P'&&s[i]=='R'){
sum2+=1;
}
}
cout<<sum1<<" "<<sum2;
return 0;
}
```

---

## 题目: B4115

**提交时间：2025-01-02 19:14:17**

---
title: "[JOI2025 预选赛 R1H2] 三角形"
layout: "post"
diff: 入门
pid: B4115
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H2] 三角形
## 题目描述

初始黑板上有一个长度为 $N$ 的序列 $A$，从左往右数第 $i$ 个整数为 $A_i$，你需要执行 $N-1$ 次如下操作：

- 对于每个 $i=1,2,\ldots ,N$，令 $B_i=A_i+A_{i+1}$。
- 将黑板上的序列擦掉，并把序列 $B$ 写在黑板上，此时序列 $A$ 变为了序列 $B$。

每次操作结束后输出当前黑板上的序列。
## 输入格式

第一行输入一个正整数 $N$。

第二行输入 $N$ 个正整数，第 $i$ 个正整数为 $A_i$。
## 输出格式

输出共 $N-1$ 行。

第 $i$ 行输出第 $i$ 次操作之后的数列，数列中的每个元素用空格隔开。
## 样例

### 样例输入 #1
```
5
1 3 5 7 9
```
### 样例输出 #1
```
4 8 12 16
12 20 28
32 48
80
```
### 样例输入 #2
```
7
1 2 3 4 3 2 1
```
### 样例输出 #2
```
3 5 7 7 5 3
8 12 14 12 8
20 26 26 20
46 52 46
98 98
196
```
### 样例输入 #3
```
10
1 9 2 4 4 9 2 3 5 6
```
### 样例输出 #3
```
10 11 6 8 13 11 5 8 11
21 17 14 21 24 16 13 19
38 31 35 45 40 29 32
69 66 80 85 69 61
135 146 165 154 130
281 311 319 284
592 630 603
1222 1233
2455
```
## 提示

### 样例解释

最初，整数序列 $[1,3,5,7,9]$ 被写在黑板上。

通过操作该序列创建的新整数序列是

$[1 + 3 = 4,3+5=8,5+7=12,7+9=16]$

因此，新的数列为 $[4,8,12,16]$。

以此类推，接下来的数列依次为 $[12,20,28]$，$[32,48]$，$[80]$。

因此，输出这些整数序列。

### 数据范围

$1\leq N\leq 10$，$1\leq A_i\leq 10$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[15],sum=0;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
while(sum!=n-1){
sum+=1;
for(int i=1;i<=n-sum;i++){
a[i]+=a[i+1];
cout<<a[i]<<" ";
}
cout<<endl;
}
return 0;
}
```

---

## 题目: B4116

**分类：JOI（日本）第一次预选赛(第一次AK!!!)**

**提交时间：2025-01-02 19:15:04**

---
title: "[JOI2025 预选赛 R1H3] 现金"
layout: "post"
diff: 入门
pid: B4116
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H3] 现金
## 题目描述

比太郎有 $A$ 张 $1000$ 日元的纸币，$B$ 张 $10000$ 日元的纸币，求比太郎手里还有多少日元。
## 输入格式

第一行输入一个正整数 $A$。

第二场输入一个正整数 $B$。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
7
2
```
### 样例输出 #1
```
27000
```
### 样例输入 #2
```
11
1
```
### 样例输出 #2
```
21000
```
## 提示

### 数据范围

$1\leq A,B\leq 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b;
int main(){
cin>>a>>b;
cout<<a*1000+b*10000;
return 0;
}
```

---

## 题目: B4117

**分类：JOI（日本）第一次预选赛(第一次AK!!!)**

**提交时间：2025-01-02 19:15:56**

---
title: "[JOI2025 预选赛 R1H3] 黑桃 J"
layout: "post"
diff: 入门
pid: B4117
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H3] 黑桃 J
## 题目描述

给定三个正整数 $A,B,C$，如果三个数的和 $\leq 21$，输出 $1$，否则输出 $0$。
## 输入格式

第一行一个正整数 $A$。

第二行一个正整数 $B$。

第三行一个正整数 $C$。
## 输出格式

一行一个整数，表示你的答案。
## 样例

### 样例输入 #1
```
5
10
6
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
7
8
13
```
### 样例输出 #2
```
0
```
## 提示

### 数据范围

$1\leq A,B,C\leq 13$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a,b,c;
int main(){
cin>>a>>b>>c;
if(a+b+c<=21){
cout<<1;
}
else{
cout<<0;
}
return 0;
}
```

---

## 题目: B4118

**分类：JOI（日本）第一次预选赛(第一次AK!!!)**

**提交时间：2025-01-02 19:17:33**

---
title: "[JOI2025 预选赛 R1H3] 不可兼或"
layout: "post"
diff: 入门
pid: B4118
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H3] 不可兼或
## 题目描述

给定正整数 $N,A,B$ 满足 $A\neq B$。

输出 $1$ 到 $N$ 之间只能被 $A$ 和 $B$ 之一整除的整数的个数。
## 输入格式

第一行一个正整数 $N$。

第二行一个正整数 $A$。

第三行一个正整数 $B$。
## 输出格式

一行一个整数表示答案。
## 样例

### 样例输入 #1
```
6
2
3
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
1
5
3
```
### 样例输出 #2
```
0
```
### 样例输入 #3
```
100
1
2
```
### 样例输出 #3
```
50
```
## 提示

### 样例解释

对于样例 $1$：

- $1$ 既不是 $2$ 的倍数也不是 $3$ 的倍数。
- $2$ 是 $2$ 的倍数，不是 $3$ 的倍数。
- $3$ 是 $3$ 的倍数，不是 $2$ 的倍数。
- $4$ 是 $2$ 的倍数，不是 $3$ 的倍数。
- $5$ 既不是 $2$ 的倍数也不是 $3$ 的倍数。
- $6$ 既是 $2$ 的倍数也是 $3$ 的倍数。

### 数据范围

$1\leq N\leq 100$，$1\leq A,B\leq 100$ 且 $A \neq B$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a,b,sum=0;
int main(){
cin>>n>>a>>b;
for(int i=1;i<=n;i++){
if(i%a==0&&i%b!=0||i%a!=0&&i%b==0){
sum+=1;
}
}
cout<<sum;
return 0;
}
```

---

## 题目: B4119

**分类：JOI（日本）第一次预选赛(第一次AK!!!)**

**提交时间：2025-01-02 19:30:13**

---
title: "[JOI2025 预选赛 R1H3] 循环字符串"
layout: "post"
diff: 普及-
pid: B4119
tag: ['2024', 'JOI（日本）']
---
# [JOI2025 预选赛 R1H3] 循环字符串
## 题目描述

给定长度为 $N$ 的字符串 $S$，$S$ 中仅包含小写字母。

若存在一个非空字符串 $T$，使得 $m(m\geq 2)$ 个字符串 $T$ 首尾拼接在可以得到 $S$，那么我们称 $S$ 是循环的。

若 $S$ 是循环字符串，输出 $\tt Yes$，否则输出 $\tt No$。

## 输入格式

第一行一个正整数 $N$。

第二行一个长度为 $N$ 的字符串 $S$。
## 输出格式

输出一行，表示你的答案。
## 样例

### 样例输入 #1
```
6
ababab
```
### 样例输出 #1
```
Yes
```
### 样例输入 #2
```
7
abcabca
```
### 样例输出 #2
```
No
```
### 样例输入 #3
```
2
aa
```
### 样例输出 #3
```
Yes
```
### 样例输入 #4
```
8
ababcdcd
```
### 样例输出 #4
```
No
```
## 提示

### 样例解释

$\tt{ababab}$ 可以看做 $3$ 个 $\tt{ab}$ 首尾连接而成的，$\tt{aa}$ 可以看做 $2$ 个 $\tt a$ 首尾连接而成的。

### 数据范围 

$1\leq N\leq 1000$，$S$ 只包含英文小写字母。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s;
bool ans=0,flag=0;
int main(){
cin>>n;
cin>>s;
for(int i=1;i<=n/2;i++){//长度
if(n%i==0){
flag=1;
for(int j=0;j<i;j++){
for(int k=j;k<n-i;k+=i){
if(s[k]!=s[k+i]){
flag=0;
break;
}
}
}
if(flag==1){
ans=1;
break;
}
}
}
if(ans==1){
cout<<"Yes";
}
else{
cout<<"No";
}
return 0;
}
```

---

## 题目: P1000

**分类：入门-顺序结构**

**提交时间：2023-11-29 21:26:06**

---
title: "超级玛丽游戏"
layout: "post"
diff: 入门
pid: P1000
tag: ['字符串', 'O2优化']
---
# 超级玛丽游戏
## 题目背景

本题是洛谷的试机题目，可以帮助了解洛谷的使用。

建议完成本题目后继续尝试 [P1001](/problem/P1001)、[P1008](/problem/P1008)。  

另外强烈推荐[新用户必读贴](/discuss/show/241461)

## 题目描述

超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景。

```
                ********
               ************
               ####....#.
             #..###.....##....
             ###.......######              ###            ###
                ...........               #...#          #...#
               ##*#######                 #.#.#          #.#.#
            ####*******######             #.#.#          #.#.#
           ...#***.****.*###....          #...#          #...#
           ....**********##.....           ###            ###
           ....****    *****....
             ####        ####
           ######        ######
##############################################################
#...#......#.##...#......#.##...#......#.##------------------#
###########################################------------------#
#..#....#....##..#....#....##..#....#....#####################
##########################################    #----------#
#.....#......##.....#......##.....#......#    #----------#
##########################################    #----------#
#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#
##########################################    ############
```
## 输入格式

无
## 输出格式

如描述
## 提示

**广告**

洛谷出品的算法教材，帮助您更简单的学习基础算法。[【官方网店绝赞热卖中！】>>>](https://item.taobao.com/item.htm?id=637730514783)

[![](https://cdn.luogu.com.cn/upload/image_hosting/njc7dlng.png)](https://item.taobao.com/item.htm?id=637730514783)


### 代码

```cpp
#include<iostream>
using namespace std;
int main(){
cout<<"                ********\n";
cout<<"               ************\n";
cout<<"               ####....#.\n";
cout<<"             #..###.....##....\n";
cout<<"             ###.......######              ###            ###\n";
cout<<"                ...........               #...#          #...#\n";
cout<<"               ##*#######                 #.#.#          #.#.#\n";
cout<<"            ####*******######             #.#.#          #.#.#\n";
cout<<"           ...#***.****.*###....          #...#          #...#\n";
cout<<"           ....**********##.....           ###            ###\n";
cout<<"           ....****    *****....\n";
cout<<"             ####        ####\n";
cout<<"           ######        ######\n";
cout<<"##############################################################\n";
cout<<"#...#......#.##...#......#.##...#......#.##------------------#\n";
cout<<"###########################################------------------#\n";
cout<<"#..#....#....##..#....#....##..#....#....#####################\n";
cout<<"##########################################    #----------#\n";
cout<<"#.....#......##.....#......##.....#......#    #----------#\n";
cout<<"##########################################    #----------#\n";
cout<<"#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n";
cout<<"##########################################    ############\n";
return 0;
}
```

---

## 题目: P1001

**分类：入门-顺序结构**

**提交时间：2023-12-26 20:30:48**

---
title: "A+B Problem"
layout: "post"
diff: 入门
pid: P1001
tag: ['模拟']
---
# A+B Problem
## 题目背景

**不熟悉算法竞赛的选手请看这里：**

算法竞赛中要求的输出格式中，**不能有多余的内容**，**这也包括了“请输入整数 $\bm a$ 和 $\bm b$” 这一类的提示用户输入信息的内容**。若包含了这些内容，将会被认为是 `Wrong Answer`，即洛谷上的 `WA`。在对比代码输出和标准输出时，系统将忽略每一行结尾的空格，以及最后一行之后多余的换行符。

若因此类问题出现本机似乎输出了正确的结果，但是实际提交结果为错误的现象，请勿认为是洛谷评测机出了问题，而是你的代码中可能存在多余的输出信息。用户可以参考在题目末尾提供的代码。

此外，**请善用应用中的在线 IDE 功能**，以避免不同平台的评测产生差异。

最后，请不要在对应的题目讨论区中发布自己的题解，请发布到题解区域中，否则将处以删除或禁言的处罚。若发现无法提交题解则表明本题题解数量过多，仍不应发布讨论。若您的做法确实与其他所有题解均不一样，请联系管理员添加题解。
## 题目描述

输入两个整数 $a, b$，输出它们的和（$|a|,|b| \le {10}^9$）。

注意

1. Pascal 使用 `integer` 会爆掉哦！
2. 有负数哦！
3. C/C++ 的 main 函数必须是 `int` 类型，而且 C 最后要 `return 0`。这不仅对洛谷其他题目有效，而且也是 NOIP/CSP/NOI 比赛的要求！

好吧，同志们，我们就从这一题开始，向着大牛的路进发。

> 任何一个伟大的思想，都有一个微不足道的开始。

## 输入格式

两个以空格分开的整数。
## 输出格式

一个整数。
## 样例

### 样例输入 #1
```
20 30

```
### 样例输出 #1
```
50

```
## 提示

**广告**

洛谷出品的算法教材，帮助您更简单的学习基础算法。[【官方网店绝赞热卖中！】>>>](https://item.taobao.com/item.htm?id=637730514783)

[![](https://cdn.luogu.com.cn/upload/image_hosting/njc7dlng.png)](https://item.taobao.com/item.htm?id=637730514783)

**本题各种语言的程序范例：**

C
```c
#include <stdio.h>

int main()
{
    int a,b;
    scanf("%d%d",&a,&b);
    printf("%d\n", a+b);
    return 0;
}
```
----------------

C++
```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int main()
{
    int a,b;
    cin >> a >> b;
    cout << a+b << endl;
    return 0;
}
```
----------------

Pascal
```cpp
var a, b: longint;
begin
    readln(a,b);
    writeln(a+b);
end.
```
-----------------

Python2

```cpp
s = raw_input().split()
print int(s[0]) + int(s[1])
```
-----------------

Python3

```cpp
s = input().split()
print(int(s[0]) + int(s[1]))
```
-----------------

Java
```java
import java.io.*;
import java.util.*;
public class Main {
    public static void main(String args[]) throws Exception {
        Scanner cin=new Scanner(System.in);
        int a = cin.nextInt(), b = cin.nextInt();
        System.out.println(a+b);
    }
}
```
-----------------

JavaScript （Node.js）

```javascript
const fs = require('fs')
const data = fs.readFileSync('/dev/stdin')
const result = data.toString('ascii').trim().split(' ').map(x => parseInt(x)).reduce((a, b) => a + b, 0)
console.log(result)
process.exit() // 请注意必须在出口点处加入此行
```

-----------------

Ruby

```ruby
a, b = gets.split.map(&:to_i)
print a+b
```

-----------------

PHP

```php
<?php
$input = trim(file_get_contents("php://stdin"));
list($a, $b) = explode(' ', $input);
echo $a + $b;
```

-----------------

Rust

```rust
use std::io;

fn main(){
    let mut input=String::new();
    io::stdin().read_line(&mut input).unwrap();
    let mut s=input.trim().split(' ');

    let a:i32=s.next().unwrap()
               .parse().unwrap();
    let b:i32=s.next().unwrap()
               .parse().unwrap();
    println!("{}",a+b);
}
```

-----------------

Go

```go
package main

import "fmt"

func main() {
    var a, b int
    fmt.Scanf("%d%d", &a, &b)
    fmt.Println(a+b)
}
```

-----------------

C# Mono

```cs
using System;

public class APlusB{
    private static void Main(){
        string[] input = Console.ReadLine().Split(' ');
        Console.WriteLine(int.Parse(input[0]) + int.Parse(input[1]));
    }
}
```

------------------

Visual Basic Mono

```vb
Imports System

Module APlusB
    Sub Main()
        Dim ins As String() = Console.ReadLine().Split(New Char(){" "c})
        Console.WriteLine(Int(ins(0))+Int(ins(1)))
    End Sub
End Module
```

------------------

Kotlin

```kotlin
fun main(args: Array<String>) {
    val (a, b) = readLine()!!.split(' ').map(String::toInt)
    println(a + b)
}
```

------------------

Haskell

```haskell
main = do
    [a, b] <- (map read . words) `fmap` getLine
    print (a+b)
```

------------------

Lua

```lua
a = io.read('*n')
b = io.read('*n')
print(a + b)
```

------------------

OCaml

```ocaml
Scanf.scanf "%i %i\n" (fun a b -> print_int (a + b))
```

------------------

Julia

```julia
nums = map(x -> parse(Int, x), split(readline(), " "))
println(nums[1] + nums[2])
```

------------------

Scala

```scala
object Main extends App {
    println(scala.io.StdIn.readLine().split(" ").map(_.toInt).sum)
}
```

------------------

Perl

```perl
my $in = <STDIN>;
chomp $in;
$in = [split /[\s,]+/, $in];
my $c = $in->[0] + $in->[1];
print "$c\n";
```



### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int a,b;
cin >> a >> b;
cout << a+b;
return 0;
}
```

---

## 题目: P1004

**分类：动态规划-线性状态动态规划**

**提交时间：2025-02-26 22:26:20**

---
title: "[NOIP 2000 提高组] 方格取数"
layout: "post"
diff: 普及+/提高
pid: P1004
tag: ['动态规划 DP', '2000', '递归', 'NOIP 提高组', '费用流']
---
# [NOIP 2000 提高组] 方格取数
## 题目背景

NOIP 2000 提高组 T4
## 题目描述

设有 $N \times N$ 的方格图 $(N \le 9)$，我们将其中的某些方格中填入正整数，而其他的方格中则放入数字 $0$。如下图所示（见样例）:

![](https://cdn.luogu.com.cn/upload/image_hosting/0bpummja.png)

某人从图的左上角的 $A$ 点出发，可以向下行走，也可以向右走，直到到达右下角的 $B$ 点。在走过的路上，他可以取走方格中的数（取走后的方格中将变为数字 $0$）。  
此人从 $A$ 点到 $B$ 点共走两次，试找出 $2$ 条这样的路径，使得取得的数之和为最大。

## 输入格式

输入的第一行为一个整数 $N$（表示 $N \times N$ 的方格图），接下来的每行有三个整数，前两个表示位置，第三个数为该位置上所放的数。一行单独的 $0$ 表示输入结束。

## 输出格式

只需输出一个整数，表示 $2$ 条路径上取得的最大的和。

## 样例

### 样例输入 #1
```
8
2 3 13
2 6  6
3 5  7
4 4 14
5 2 21
5 6  4
6 3 15
7 2 14
0 0  0

```
### 样例输出 #1
```
67
```
## 提示

数据范围：$1\le N\le 9$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[15][15],dp[15][15][15][15];
int main(){
cin>>n;
while(true){
int x,y,k;
cin>>x>>y>>k;
if(x==0&&y==0&&k==0){
break;
}
a[x][y]=k;
}
for(int x=1;x<=n;x++){
for(int y=1;y<=n;y++){
for(int x2=1;x2<=n;x2++){
for(int y2=1;y2<=n;y2++){
dp[x][y][x2][y2]=a[x][y]+a[x2][y2]+max(dp[x-1][y][x2-1][y2],max(dp[x-1][y][x2][y2-1],max(dp[x][y-1][x2-1][y2],dp[x][y-1][x2][y2-1])));
if(x==x2&&y==y2){
dp[x][y][x2][y2]-=a[x][y];
}
}
}
}
}
cout<<dp[n][n][n][n];
return 0;
}
```

---

## 题目: P1009

**分类：算法--模拟与高精度**

**提交时间：2023-11-28 20:26:54**

---
title: "[NOIP 1998 普及组] 阶乘之和"
layout: "post"
diff: 普及-
pid: P1009
tag: ['数学', '高精度', '1998', 'NOIP 普及组']
---
# [NOIP 1998 普及组] 阶乘之和
## 题目描述

用高精度计算出 $S = 1! + 2! + 3! + \cdots + n!$（$n \le 50$）。

其中 `!` 表示阶乘，定义为 $n!=n\times (n-1)\times (n-2)\times \cdots \times 1$。例如，$5! = 5 \times 4 \times 3 \times 2 \times 1=120$。
## 输入格式

一个正整数 $n$。
## 输出格式

一个正整数 $S$，表示计算结果。
## 样例

### 样例输入 #1
```
3

```
### 样例输出 #1
```
9
```
## 提示

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 50$。

**【其他说明】**

注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 $n \le 20$，使用书中的代码无法通过本题。

如果希望通过本题，请继续学习第八章高精度的知识。

NOIP1998 普及组 第二题


### 代码

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int n,a[90],b[90],c[90],f[90],d=0,len_a,len_b=1,len_c=1,len_ans,m=1;
string s;
int main(){
cin>>n;
b[0]=1; //初始化
for(int i=1;i<=n;i++){ //计算i的阶乘，已经算好了i-1的阶乘
len_a=0; //i的长度
int p=i;
while(p>0){ //把i存进a数组
a[len_a++]=p%10;
p/=10;
}
for(int j=0;j<len_a;j++) //计算a*b（i*（i-1）的阶乘），即i的阶乘，看不懂的网上查，我也不知道为什么
for(int k=0;k<=len_b;k++)
c[j+k]+=a[j]*b[k];
for(int j=0;j<len_c;j++) //需要进位的就进位
if(c[j]>9) c[j+1]+=c[j]/10,c[j]%=10;
if(c[len_c]) len_c++; //看最高位要不要进位
len_ans=len_b,len_b=len_c,m=max(m,len_c); //把len_b赋值给len_ans，修改len_b的值，m为i阶乘的长度，看有没有进位
for(int k=len_c-1;k>=0;k--) b[k]=c[k]; //把c存进b数组，即存进i的阶乘，下次循环b为i-1的阶乘
len_c=len_a+len_ans;
memset(c,0,sizeof(c)); //清零c数组，准备计算下个阶乘
for(int j=0;j<m;j++){ //高精加，直接套模板
f[j]+=b[j];
if(f[j]>9) f[j+1]+=f[j]/10,f[j]%=10; //进位，注意不要写成f[j+1]++，f[j]-=10;就因为这里wa了一个点
}
}
while(!f[m]&&m>0) m--; //去掉首导零
for(int i=m;i>=0;i--) cout<<f[i]; //倒序输出
return 0; //圆满结束
}
```

---

## 题目: P10108

**分类：GESP--GESP6级**

**提交时间：2025-04-08 20:15:07**

---
title: "[GESP202312 六级] 闯关游戏"
layout: "post"
diff: 普及-
pid: P10108
tag: ['动态规划 DP', '2023', 'GESP']
---
# [GESP202312 六级] 闯关游戏
## 题目描述

你来到了一个闯关游戏。

这个游戏总共有 $N$ 关，每关都有 $M$ 个通道，你需要选择一个通道并通往后续关卡。其中，第 $i$ 个通道可以让你前进 $a_i$ 关，也就是说，如果你现在在第 $x$ 关，那么选择第 $i$ 个通道后，你将直接来到第 $x+a_i$ 关（特别地，如果 $x + a_i \geq N$，那么你就通关了）。此外，当你顺利离开第 $s$ 关时，你还将获得 $b_s$ 分。

游戏开始时，你在第 $0$ 关。请问，你通关时最多能获得多少总分。
## 输入格式

第一行两个整数 $N$，$M$，分别表示关卡数量和每关的通道数量。

接下来一行 $M$ 个用单个空格隔开的整数 $a_0,a_1\cdots,a_{M-1}$。保证 $1\le a_i \le N$。

接下来一行 $N$ 个用单个空格隔开的整数 $b_0,b_1\cdots,b_{N-1}$。保证 $|b_i|\le 10^5$。
## 输出格式

一行一个整数，表示你通关时最多能够获得的分数。
## 样例

### 样例输入 #1
```
6 2 
2 3
1 0 30 100 30 30
```
### 样例输出 #1
```
131
```
### 样例输入 #2
```
6 2
2 3
1 0 30 100 30 -1
```
### 样例输出 #2
```
101
```
## 提示

**样例解释 1**

你可以在第 $0$ 关选择第 $1$ 个通道，获得 $1$ 分并来到第 $3$ 关；随后再选择第 $0$ 个通道，获得 $100$ 分并来到第 $5$ 关；最后任选一个通道，都可以获得 $30$ 分并通关。如此，总得分为 $1+100+30=131$。

**样例解释 2**

请注意，一些关卡的得分可能是负数。


**数据范围**

对于 $20\%$ 的测试点，保证 $M=1$。

对于 $40\%$ 的测试点，保证 $N \le 20$；保证 $M\le 2$。

对于所有测试点，保证 $1 \le N \le 10^4$；保证 $1 \le M\le 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[105],b[20005],dp[20005];
int maxm=-1;
int main(){
cin>>n>>m;
for(int i=0;i<=m-1;i++){
cin>>a[i];
maxm=max(maxm,a[i]);
}
for(int i=0;i<=n-1;i++){
cin>>b[i];
}
for(int i=0;i<=n*2;i++){
dp[i]=-1e9-5;
}
dp[0]=0;
int ans=-1e9-5;
for(int i=0;i<=n-1;i++){
for(int j=0;j<=m-1;j++){
if(i+a[j]>=n){
ans=max(ans,dp[i]+b[i]);
}
dp[i+a[j]]=max(dp[i]+b[i],dp[i+a[j]]);
}
}
cout<<ans;
return 0;
}
```

---

## 题目: P1012

**分类：算法--排序**

**提交时间：2025-02-13 20:51:15**

---
title: "[NOIP 1998 提高组] 拼数"
layout: "post"
diff: 普及/提高-
pid: P1012
tag: ['字符串', '1998', 'NOIP 提高组', '排序']
---
# [NOIP 1998 提高组] 拼数
## 题目描述

设有 $n$ 个正整数 $a_1 \dots a_n$，将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。

## 输入格式

第一行有一个整数，表示数字个数 $n$。

第二行有 $n$ 个整数，表示给出的 $n$ 个整数 $a_i$。
## 输出格式

一个正整数，表示最大的整数

## 样例

### 样例输入 #1
```
3
13 312 343

```
### 样例输出 #1
```
34331213

```
### 样例输入 #2
```
4
7 13 4 246
```
### 样例输出 #2
```
7424613
```
## 提示

对于全部的测试点，保证 $1 \leq n \leq 20$，$1 \leq a_i \leq 10^9$。

NOIP1998 提高组 第二题


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
string s[25];
bool cmp(string a,string b){
if(a+b>b+a){
return true;
}
return false;
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>s[i];
}
sort(s+1,s+n+1,cmp);
for(int i=1;i<=n;i++){
cout<<s[i];
}
return 0;
}
```

---

## 题目: P1020

**分类：动态规划-线性状态动态规划**

**提交时间：2024-08-13 13:19:16**

---
title: "[NOIP 1999 提高组] 导弹拦截"
layout: "post"
diff: 普及/提高-
pid: P1020
tag: ['动态规划 DP', '贪心', '1999', '二分', 'NOIP 提高组', 'Special Judge', '线性 DP']
---
# [NOIP 1999 提高组] 导弹拦截
## 题目描述

某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。

   
输入导弹依次飞来的高度，计算这套系统最多能拦截多少导弹，如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 输入格式

一行，若干个整数，中间由空格隔开。
## 输出格式

两行，每行一个整数，第一个数字表示这套系统最多能拦截多少导弹，第二个数字表示如果要拦截所有导弹最少要配备多少套这种导弹拦截系统。

## 样例

### 样例输入 #1
```
389 207 155 300 299 170 158 65
```
### 样例输出 #1
```
6
2

```
## 提示

对于前 $50\%$ 数据（NOIP 原题数据），满足导弹的个数不超过 $10^4$ 个。该部分数据总分共 $100$ 分。可使用$\mathcal O(n^2)$ 做法通过。  
对于后 $50\%$ 的数据，满足导弹的个数不超过 $10^5$ 个。该部分数据总分也为 $100$ 分。请使用 $\mathcal O(n\log n)$ 做法通过。

对于全部数据，满足导弹的高度为正整数，且不超过 $5\times 10^4$。


此外本题开启 spj，每点两问，按问给分。

NOIP1999 提高组 第一题

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10005],n,x,f[10005],ans=-1,b[10005],p=-1,k;
int main()
{
while(cin>>x)
{
a[++n]=x;
p=-1;
for(int i=1;i<=k;i++)
{
if(b[i]>=x)
{
p=i;
break;
}
}
if(p==-1)
{
k++;
b[k]=x;
}
else
{
b[p]=x;
}
}
for(int i=1;i<=n;i++)
{
f[i]=1;
for(int j=1;j<=i-1;j++)
{
if(a[j]>=a[i])
{
f[i]=max(f[i],f[j]+1);
}
}
ans=max(ans,f[i]);
}
cout<<ans<<endl;
cout<<k<<endl;
return 0;
}
```

---

## 题目: P1023

**提交时间：2024-06-05 16:05:38**

---
title: "[NOIP 2000 普及组] 税收与补贴问题"
layout: "post"
diff: 普及/提高-
pid: P1023
tag: ['数学', '2000', 'NOIP 普及组', '枚举']
---
# [NOIP 2000 普及组] 税收与补贴问题
## 题目背景

每样商品的价格越低，其销量就会相应增大。现已知某种商品的成本及其在若干价位上的销量（产品不会低于成本销售），并假设相邻价位间销量的变化是线性的且在价格高于给定的最高价位后，销量以某固定数值递减。（我们假设价格及销售量都是整数）

对于某些特殊商品，不可能完全由市场去调节其价格。这时候就需要政府以税收或补贴的方式来控制。（所谓税收或补贴就是对于每个产品收取或给予生产厂家固定金额的货币）

## 题目描述

你是某家咨询公司的项目经理，现在你已经知道政府对某种商品的预期价格，以及在各种价位上的销售情况。要求你确定政府对此商品是应收税还是补贴的最少金额（也为整数），才能使商家在这样一种政府预期的价格上，获取相对其他价位上的最大总利润。

- 总利润 $=$ 单位商品利润 $\times$ 销量
- 单位商品利润 $=$ 单位商品价格 $-$ 单位商品成本（减去税金 或者 加上补贴）

## 输入格式

输入的第一行为政府对某种商品的预期价；

 第二行有两个整数，第一个整数为商品成本，第二个整数为以成本价销售时的销售量；
 
 接下来若干行，每行都有两个整数，第一个为某价位时的单价，第二个为此时的销量，以一行 `-1 -1` 表示所有已知价位及对应的销量输入完毕；
 
 输入的最后一行为一个单独的整数表示在已知的最高单价外每升高一块钱将减少的销量。

## 输出格式

输出有两种情况：若在政府预期价上能得到最大总利润，则输出一个单独的整数，数的正负表示是补贴还是收税，数的大小表示补贴或收税的金额最小值。若有多解，取绝对值最小的输出。

如在政府预期价上不能得到最大总利润，则输出 `NO SOLUTION`。

## 样例

### 样例输入 #1
```
31
28 130
30 120
31 110
-1  -1
15
```
### 样例输出 #1
```
4

```
## 提示

### 数据范围及约定

保证输入的所有数字均小于 $10^5$。

### 样例解释（2023/6/22 更新）

如下图所示是输入样例所对应的价格变化图，横轴表示销售价格，纵轴表示销量。

![](https://cdn.luogu.com.cn/upload/image_hosting/21mhtm5i.png)

根据题意，$28$ 元是商品的成本。销售价格不应该低于 $28$ 元；当销售价格大于给出的价格的最大值 $31$ 元后，按照售价每提高一元，销量降低 $15$ 计算，例如当售价为 $33$ 元时，销量为 $110-15\times (33-31)=80$。在给出来的价位之间，销量呈线性变化。

当政府给该商品补贴 $4$ 元后，企业将该商品定价为 $31$ 元时，取得的利润为 $31-28+4=7$ 元，销量为 $110$ 件，总利润为 $7\times 110=770$ 元，是企业在所有定价下能够取得的最大的总利润。此时企业的售价为政府的期望售价，因此是一个合法方案。


### 代码

```cpp
#include <iostream>
#include <cmath>
using namespace std;
int a[100010][3];//用于存放价格和销量的数组
int main()
{
int i=1,j=1,k,expect,down,max,temp,cha,xl,num,s,price,p;
cin>>expect;//读入预期价
while(cin>>a[i][1]>>a[i][2]&&a[i][1]!=-1&&a[i] [2]!=-1)//如果输入的两个数不是-1，-1
{
i++;//循环变量i++
if(i>2&&a[i-1][1]-a[i-2][1]>1)//如果两个价格之间差大于一
{
i--;//回到上一个读入的销量
cha=(a[i-1][2]-a[i][2])/(a[i][1]-a[i-1][1]);//求出每次销量减少多少：销量差/价格差
temp=a[i][1];//记录下价格
for(j=a[i-1][1]+1;j<=temp;j++)//按价格递增顺序依次写入
{
a[i][1]=j;//写入价格
a[i][2]=a[i-1][2]-cha;//按销量差写入销量
i++;
}
}
}
cin>>down;//输入超过最大价格之后每次销量降低多少
i--;//因为上面的while循环最后有i++所以用i--抵消……
xl=a[i][2];//记录目前的销量
while(xl>0)
{
if(xl-down<0)break;//如销量小于零则退出
else//否则
{
xl-=down;//销量每次减掉down
i++;//循环变量++
a[i][1]=a[i-1][1]+1;//每次价格+1
a[i][2]=xl;//销量就是xl
}
}
for(j=1;j<=10000;j++)//该遍历了，因为收税相当于补贴*-1所以记录一下符号即可
{
max=-99999;//用于存储最大的总利润
for(k=1;k<=i;k++)//每次扫一遍每一种价格
{
num=(a[k][1]-a[1][1]+j)*a[k][2];//套公式算出总利润
if(num>=max)//如果总利润比目前最大的大
{
max=num;//更新max
price=a[k][1];//记录下价格
p=1;//记录下符号
}
}
if(price==expect){cout<<j*p;return 0;}//如果价格就是政府预期价则打印出来，因为本身就是从小到大遍历所以不用求绝对值最小的
max=-99999;//后面是收税，原理同上
for(k=1;k<=i;k++)
{
num=(a[k][1]-a[1][1]-j)*a[k][2];
if(num>=max)
{
max=num;
price=a[k][1];
p=-1;
}
}
if(price==expect){cout<<j*p;return 0;}
}
//前面有了return 0;这儿就不用了。
}
```

---

## 题目: P1024

**分类：算法--二分查找与二分答案**

**提交时间：2024-12-19 19:34:42**

---
title: "[NOIP 2001 提高组] 一元三次方程求解"
layout: "post"
diff: 普及-
pid: P1024
tag: ['数学', '2001', '二分', 'NOIP 提高组', '枚举', '分治']
---
# [NOIP 2001 提高组] 一元三次方程求解
## 题目描述

有形如：$a x^3 + b x^2 + c x + d = 0$  这样的一个一元三次方程。给出该方程中各项的系数（$a,b,c,d$ 均为实数），并约定该方程存在三个不同实根（根的范围在 $-100$ 至 $100$ 之间），且根与根之差的绝对值 $\ge 1$。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 $2$ 位。

提示：记方程 $f(x) = 0$，若存在 $2$ 个数 $x_1$ 和 $x_2$，且 $x_1 < x_2$，$f(x_1) \times f(x_2) < 0$，则在 $(x_1, x_2)$ 之间一定有一个根。
## 输入格式

一行，$4$ 个实数 $a, b, c, d$。
## 输出格式

一行，$3$ 个实根，从小到大输出，并精确到小数点后 $2$ 位。
## 样例

### 样例输入 #1
```
1 -5 -4 20

```
### 样例输出 #1
```
-2.00 2.00 5.00

```
## 提示

**【题目来源】**

NOIP 2001 提高组第一题


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b,c,d;
double f(double x){
return a*x*x*x+b*x*x+c*x+d;
}
int main(){
cin>>a>>b>>c>>d;
for(int i=-100;i<=100;i++){
double l=i,r=i+1,mid;
if(f(l)==0){
printf("%.2f ",l);
continue;
}
if(f(r)==0){
continue;
}
if(f(l)*f(r)<0){
while(r-l>0.001){
mid=(l+r)/2;
if(f(mid)*f(r)>0){
r=mid;
}
else{
l=mid;
}
}
printf("%.2f ",l);
}
}
return 0;
}
```

---

## 题目: P10250

**分类：GESP--GESP6级**

**提交时间：2025-04-01 20:34:42**

---
title: "[GESP样题 六级] 下楼梯"
layout: "post"
diff: 普及-
pid: P10250
tag: ['GESP']
---
# [GESP样题 六级] 下楼梯
## 题目描述

顽皮的小明发现，下楼梯时每步可以走 $1$ 个台阶、$2$ 个台阶或 $3$ 个台阶。现在一共有 $N$ 个台阶，你能帮小明算算有多少种方案吗？
## 输入格式

输入一行，包含一个整数 $N$。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
4
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
10
```
### 样例输出 #2
```
274
```
## 提示

对全部的测试点，保证 $1 \leq N \leq 60$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,sum=0,a[65];
void fun(long long res){
if(a[res]!=0){
sum+=a[res];
return;
}
if(res==0){
sum+=1;
return;
}
if(res>=3){
fun(res-3);
}
if(res>=2){
fun(res-2);
}
if(res>=1){
fun(res-1);
}
}
int main(){
for(int i=1;i<=60;i++){
sum=0;
fun(i);
a[i]=sum;
}
cin>>n;
cout<<a[n];
return 0;
}
```

---

## 题目: P1030

**分类：数据结构--二叉树**

**提交时间：2025-03-02 19:56:31**

---
title: "[NOIP 2001 普及组] 求先序排列"
layout: "post"
diff: 普及-
pid: P1030
tag: ['字符串', '树形数据结构', '2001', '递归', 'NOIP 普及组', '深度优先搜索 DFS']
---
# [NOIP 2001 普及组] 求先序排列
## 题目描述

给出一棵二叉树的中序与后序排列。求出它的先序排列。（约定树结点用不同的大写字母表示，且二叉树的节点个数 $ \le 8$）。

## 输入格式

共两行，均为大写字母组成的字符串，表示一棵二叉树的中序与后序排列。

## 输出格式

共一行一个字符串，表示一棵二叉树的先序。

## 样例

### 样例输入 #1
```
BADC
BDCA

```
### 样例输出 #1
```
ABCD

```
## 提示

**【题目来源】**

NOIP 2001 普及组第三题


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2;
void dfs(string x,string y){
if(x=="\0"||y=="\0"){
return;
}
int pos=x.find(y[y.size()-1]);
cout<<x[pos];
dfs(x.substr(0,pos),y.substr(0,pos));
dfs(x.substr(pos+1),y.substr(pos,y.size()-pos-1));
}
int main(){
cin>>s1>>s2;
dfs(s1,s2);
return 0;
}
```

---

## 题目: P1035

**分类：入门-循环结构**

**提交时间：2023-11-29 20:47:19**

---
title: "[NOIP 2002 普及组] 级数求和"
layout: "post"
diff: 入门
pid: P1035
tag: ['数学', '2002', 'NOIP 普及组']
---
# [NOIP 2002 普及组] 级数求和
## 题目描述

已知：$S_n= 1+\dfrac{1}{2}+\dfrac{1}{3}+…+\dfrac{1}{n}$。显然对于任意一个整数 $k$，当 $n$ 足够大的时候，$S_n>k$。

现给出一个整数 $k$，要求计算出一个最小的 $n$，使得 $S_n>k$。

## 输入格式

一个正整数 $k$。

## 输出格式

一个正整数 $n$。
## 样例

### 样例输入 #1
```
1

```
### 样例输出 #1
```
2

```
## 提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le k \le 15$。

**【题目来源】**

NOIP 2002 普及组第一题


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int k,n,a;
double sn;
cin>>k;
a=1;
n=0;
sn=0;
while (sn<=k)
{
sn+=1.00/a;
a+=1;
n+=1;
}
cout<<n;
return 0;
}
```

---

## 题目: P1036

**分类：算法--进阶搜索**

**提交时间：2024-10-20 13:42:53**

---
title: "[NOIP 2002 普及组] 选数"
layout: "post"
diff: 普及-
pid: P1036
tag: ['搜索', '2002', 'NOIP 普及组', '深度优先搜索 DFS', '素数判断,质数,筛法']
---
# [NOIP 2002 普及组] 选数
## 题目描述

已知 $n$ 个整数 $x_1,x_2,\cdots,x_n$，以及 $1$ 个整数 $k$（$k<n$）。从 $n$ 个整数中任选 $k$ 个整数相加，可分别得到一系列的和。例如当 $n=4$，$k=3$，$4$ 个整数分别为 $3,7,12,19$ 时，可得全部的组合与它们的和为：

$3+7+12=22$

$3+7+19=29$

$7+12+19=38$

$3+12+19=34$

现在，要求你计算出和为素数共有多少种。

例如上例，只有一种的和为素数：$3+7+19=29$。
## 输入格式

第一行两个空格隔开的整数 $n,k$（$1 \le n \le 20$，$k<n$）。

第二行 $n$ 个整数，分别为 $x_1,x_2,\cdots,x_n$（$1 \le x_i \le 5\times 10^6$）。

## 输出格式

输出一个整数，表示种类数。
## 样例

### 样例输入 #1
```
4 3
3 7 12 19

```
### 样例输出 #1
```
1

```
## 提示

**【题目来源】**

NOIP 2002 普及组第二题


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[25],b[25],cnt,t,ans,sum=0;
bool flag=1;
int main(){
cin>>n>>k;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<(1<<n);i++){
int x=i;
cnt=0,t=1;
while(x>0){
if(x%2){
b[t]=1;
cnt+=1;
}
else{
b[t]=0;
}
t+=1;
x/=2;
}
if(cnt==k){
ans=0;
for(int j=1;j<=n;j++){
if(b[j]==1){
ans+=a[j];
}
}
flag=1;
for(int j=2;j<=sqrt(ans);j++){
if(ans%j==0){
flag=0;
break;
}
}
if(flag==1){
sum+=1;
}
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P10376

**分类：GESP--GESP6级**

**提交时间：2025-04-03 22:05:10**

---
title: "[GESP202403 六级] 游戏"
layout: "post"
diff: 普及-
pid: P10376
tag: ['动态规划 DP', '2024', 'GESP']
---
# [GESP202403 六级] 游戏
## 题目描述

你有四个正整数 $n,a,b,c$，并准备用它们玩一个简单的小游戏。

在一轮游戏操作中，你可以选择将 $n$ 减去 $a$，或是将 $n$ 减去 $b$。游戏将会进行多轮操作，直到当 $n \leq c$ 时游戏结束。

你想知道游戏结束时有多少种不同的游戏操作序列。两种游戏操作序列不同，当且仅当游戏操作轮数不同，或是某一轮游戏操作中，一种操作序列选择将 $n$ 减去 $a$，而另一种操作序列选择将 $n$ 减去 $b$。如果 $a=b$，也认为将 $n$ 减去 $a$ 与将 $n$ 减去 $b$ 是不同的操作。

由于答案可能很大，你只需要求出答案对 $10^9 + 7$ 取模的结果。
## 输入格式


一行四个整数 $n,a,b,c$。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
1 1 1 1
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
114 51 4 1
```
### 样例输出 #2
```
176
```
### 样例输入 #3
```
114514 191 9 810
```
### 样例输出 #3
```
384178446
```
## 提示

### 数据规模与约定


- 对 $20\%$ 的数据，$a=b=c=1$，$n \leq 30$。
- 对 $40\%$ 的数据，$c = 1$，$n \leq 10^3$。
- 对全部的测试数据，保证 $1 \leq a,b,c \leq n \leq 2 \times 10^5$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
long long n,a,b,c,jy[200005],sum=0;
long long dfs(long long res){
if(res<=c){
return 1;
}
if(jy[res]!=0){
return jy[res];
}
else{
jy[res]=(dfs(res-a)%mod+dfs(res-b)%mod)%mod;
return jy[res];
}
}
int main(){
cin>>n>>a>>b>>c;
cout<<dfs(n);
return 0;
}
```

---

## 题目: P1042

**分类：算法--模拟与高精度**

**提交时间：2024-11-20 20:24:09**

---
title: "[NOIP 2003 普及组] 乒乓球"
layout: "post"
diff: 普及-
pid: P1042
tag: ['模拟', '字符串', '2003', 'NOIP 普及组']
---
# [NOIP 2003 普及组] 乒乓球
## 题目背景

国际乒联现在主席沙拉拉自从上任以来就立志于推行一系列改革，以推动乒乓球运动在全球的普及。其中 $11$ 分制改革引起了很大的争议，有一部分球员因为无法适应新规则只能选择退役。华华就是其中一位，他退役之后走上了乒乓球研究工作，意图弄明白 $11$ 分制和 $21$ 分制对选手的不同影响。在开展他的研究之前，他首先需要对他多年比赛的统计数据进行一些分析，所以需要你的帮忙。
## 题目描述

华华通过以下方式进行分析，首先将比赛每个球的胜负列成一张表，然后分别计算在 $11$ 分制和 $21$ 分制下，双方的比赛结果（截至记录末尾）。

比如现在有这么一份记录，（其中 $\texttt W$ 表示华华获得一分，$\texttt L$ 表示华华对手获得一分）：

$\texttt{WWWWWWWWWWWWWWWWWWWWWWLW}$

在 $11$ 分制下，此时比赛的结果是华华第一局 $11$ 比 $0$ 获胜，第二局 $11$ 比 $0$ 获胜，正在进行第三局，当前比分 $1$ 比 $1$。而在 $21$ 分制下，此时比赛结果是华华第一局 $21$ 比 $0$ 获胜，正在进行第二局，比分 $2$ 比 $1$。如果一局比赛刚开始，则此时比分为 $0$ 比 $0$。直到分差大于或者等于 $2$，才一局结束。

**注意：当一局比赛结束后，下一局立刻开始**。

你的程序就是要对于一系列比赛信息的输入（$\texttt{WL}$ 形式），输出正确的结果。

## 输入格式

每个输入文件包含若干行字符串，字符串由大写的 $\texttt W$ 、 $\texttt L$ 和 $\texttt E$ 组成。其中 $\texttt E$ 表示比赛信息结束，程序应该忽略 $\texttt E$ 之后的所有内容。
## 输出格式

输出由两部分组成，每部分有若干行，每一行对应一局比赛的比分（按比赛信息输入顺序）。其中第一部分是 $11$ 分制下的结果，第二部分是 $21$ 分制下的结果，两部分之间由一个空行分隔。
## 样例

### 样例输入 #1
```
WWWWWWWWWWWWWWWWWWWW
WWLWE

```
### 样例输出 #1
```
11:0
11:0
1:1

21:0
2:1

```
## 提示

每行至多 $25$ 个字母，最多有 $2500$ 行。

（注：事实上有一个测试点有 $2501$ 行数据。）

**【题目来源】**

NOIP 2003 普及组第一题


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int w11,l11,w21,l21,a[5105][3],b[2605][3],x=0,y=0;
char n;
int main(){
while(cin>>n){
if(n=='E'){
break;
}
if(n=='W'){
w11+=1;
w21+=1;
}
else{
l11+=1;
l21+=1;
}
if((l11>=11&&(l11-w11>=2))||(w11>=11&&(w11-l11>=2))){
x+=1;
a[x][1]=w11;
a[x][2]=l11;
w11=0;
l11=0;
}
if((l21>=21&&(l21-w21>=2))||(w21>=21&&(w21-l21>=2))){
y+=1;
b[y][1]=w21;
b[y][2]=l21;
w21=0;
l21=0;
}
}
if(w11!=0||l11!=0){
x+=1;
a[x][1]=w11;
a[x][2]=l11;
}
else{
x+=1;
a[x][1]=0;
a[x][2]=0;
}
if(w21!=0||l21!=0){
y+=1;
b[y][1]=w21;
b[y][2]=l21;
}
else{
y+=1;
b[y][1]=0;
b[y][2]=0;
}
if(x==0&&y==0){
cout<<"0:0"<<endl;
cout<<endl;
cout<<"0:0";
}
for(int i=1;i<=x;i++){
cout<<a[i][1]<<":"<<a[i][2]<<endl;
}
cout<<endl;
for(int i=1;i<=y;i++){
cout<<b[i][1]<<":"<<b[i][2]<<endl;
}
return 0;
}
```

---

## 题目: P1046

**分类：入门-分支结构**

**提交时间：2023-12-28 19:18:54**

---
title: "[NOIP 2005 普及组] 陶陶摘苹果"
layout: "post"
diff: 入门
pid: P1046
tag: ['模拟', '2005', 'NOIP 普及组']
---
# [NOIP 2005 普及组] 陶陶摘苹果
## 题目描述

陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 $10$ 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 $30$ 厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。


现在已知 $10$ 个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。

## 输入格式

输入包括两行数据。第一行包含 $10$ 个 $100$ 到 $200$ 之间（包括 $100$ 和 $200$）的整数（以厘米为单位）分别表示 $10$ 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 $100$ 到 $120$ 之间（包含 $100$ 和 $120$）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。


## 输出格式

输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。

## 样例

### 样例输入 #1
```
100 200 150 140 129 134 167 198 200 111
110

```
### 样例输出 #1
```
5
```
## 提示

**【题目来源】**

NOIP 2005 普及组第一题


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int a[15],n,sum=0;
for (int i=1;i<=10;i++)
{
cin>>a[i];
}
cin>>n;
for (int i=1;i<=10;i++)
{
if ((n+30)>=a[i])
{
sum+=1;
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P1047

**分类：入门-数组**

**提交时间：2024-11-11 19:54:36**

---
title: "[NOIP 2005 普及组] 校门外的树"
layout: "post"
diff: 入门
pid: P1047
tag: ['模拟', '2005', 'NOIP 普及组']
---
# [NOIP 2005 普及组] 校门外的树
## 题目描述

某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,\dots,l$，都种有一棵树。


由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。


## 输入格式

第一行有两个整数，分别表示马路的长度 $l$ 和区域的数目 $m$。

接下来 $m$ 行，每行两个整数 $u, v$，表示一个区域的起始点和终止点的坐标。
## 输出格式

输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。
## 样例

### 样例输入 #1
```
500 3
150 300
100 200
470 471

```
### 样例输出 #1
```
298
```
## 提示

**【数据范围】**

- 对于 $20\%$ 的数据，保证区域之间没有重合的部分。
- 对于 $100\%$ 的数据，保证 $1 \leq l \leq 10^4$，$1 \leq m \leq 100$，$0 \leq u \leq v \leq l$。

**【题目来源】**

NOIP 2005 普及组第二题


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int l,m,u,v,a[10005],sum;
int main(){
cin>>l>>m;
for(int i=1;i<=m;i++){
cin>>u>>v;
for(int j=u;j<=v;j++){
a[j]=1;
}
}
for(int i=0;i<=l;i++){
if(a[i]==0){
sum+=1;
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P1048

**分类：动态规划-动态规划的引入**

**提交时间：2025-03-16 13:26:16**

---
title: "[NOIP 2005 普及组] 采药"
layout: "post"
diff: 普及-
pid: P1048
tag: ['动态规划 DP', '2005', 'NOIP 普及组', '背包 DP']
---
# [NOIP 2005 普及组] 采药
## 题目描述

辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”


如果你是辰辰，你能完成这个任务吗？

## 输入格式

第一行有 $2$ 个整数 $T$（$1 \le T \le 1000$）和 $M$（$1 \le  M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。

接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。
## 输出格式

输出在规定的时间内可以采到的草药的最大总价值。

## 样例

### 样例输入 #1
```
70 3
71 100
69 1
1 2

```
### 样例输出 #1
```
3
```
## 提示

**【数据范围】**

- 对于 $30\%$ 的数据，$M \le 10$；
- 对于全部的数据，$M \le 100$。

**【题目来源】**

NOIP 2005 普及组第三题


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,dp[105][1005];
int v[105],w[105];
int main(){
cin>>m>>n;
for(int i=1;i<=n;i++){
cin>>v[i]>>w[i];
}
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
dp[i][j]=dp[i-1][j];
if(j>=v[i]){
dp[i][j]=max(dp[i][j],w[i]+dp[i-1][j-v[i]]);
}
}
}
cout<<dp[n][m];
return 0;
}
```

---

## 题目: P1055

**分类：入门-分支结构**

**提交时间：2023-12-28 20:29:32**

---
title: "[NOIP 2008 普及组] ISBN 号码"
layout: "post"
diff: 普及-
pid: P1055
tag: ['模拟', '字符串', '2008', 'NOIP 普及组']
---
# [NOIP 2008 普及组] ISBN 号码
## 题目描述

每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 $9$ 位数字、$1$ 位识别码和 $3$ 位分隔符，其规定格式如 `x-xxx-xxxxx-x`，其中符号 `-` 就是分隔符（键盘上的减号），最后一位是识别码，例如 `0-670-82162-4`就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 $0$ 代表英语；第一个分隔符 `-` 之后的三位数字代表出版社，例如 $670$ 代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。

识别码的计算方法如下：

首位数字乘以 $1$ 加上次位数字乘以 $2$ ……以此类推，用所得的结果 $ \bmod 11$，所得的余数即为识别码，如果余数为 $10$，则识别码为大写字母 $X$。例如 ISBN 号码 `0-670-82162-4` 中的识别码 $4$ 是这样得到的：对 `067082162` 这 $9$ 个数字，从左至右，分别乘以 $1,2,\dots,9$ 再求和，即 $0\times 1+6\times 2+……+2\times 9=158$，然后取 $158 \bmod 11$ 的结果 $4$ 作为识别码。

你的任务是编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 `Right`；如果错误，则输出你认为是正确的 ISBN 号码。

## 输入格式

一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。

## 输出格式

一行，假如输入的 ISBN 号码的识别码正确，那么输出 `Right`，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 `-`）。

## 样例

### 样例输入 #1
```
0-670-82162-4
```
### 样例输出 #1
```
Right
```
### 样例输入 #2
```
0-670-82162-0
```
### 样例输出 #2
```
0-670-82162-4
```
## 提示

2008 普及组第一题



### 代码

```cpp
#include<iostream>
using namespace std;
int main()
{
int sum = 0, x = 1;
int a[18];
char b[18];
int y = 0;
cin >> b;
for (int i = 0; b[i] != '\0'; i++)
{
a[i + 1] = b[i] - '0';
}
for (int i = 1; i <= 11; i++)
{
if (i == 2 || i == 6)
{
continue;
}
sum += a[i] * x;
x++;
}
if (sum % 11 == 10)
{
y = 40;
}
if (sum % 11==a[13] || y == a[13])
{
cout << "Right";
}
else
{
for (int i = 1; i <= 12; i++)
{
if (i == 2 || i == 6 || i == 12)
{
cout << '-';
}
else
{
cout << a[i];
}
}
if (sum % 11 == 10)
{
cout << "X";
}
else
{
cout << sum % 11;
}
}
return 0;
}
```

---

## 题目: P1059

**分类：算法--排序**

**提交时间：2024-08-31 21:41:44**

---
title: "[NOIP 2006 普及组] 明明的随机数"
layout: "post"
diff: 普及-
pid: P1059
tag: ['模拟', '2006', 'NOIP 普及组', '排序']
---
# [NOIP 2006 普及组] 明明的随机数
## 题目描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。

## 输入格式

输入有两行，第 $1$ 行为 $1$ 个正整数，表示所生成的随机数的个数 $N$。

第 $2$ 行有 $N$ 个用空格隔开的正整数，为所产生的随机数。

## 输出格式

输出也是两行，第 $1$ 行为 $1$ 个正整数 $M$，表示不相同的随机数的个数。

第 $2$ 行为 $M$ 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。

## 样例

### 样例输入 #1
```
10
20 40 32 67 40 20 89 300 400 15

```
### 样例输出 #1
```
8
15 20 32 40 67 89 300 400

```
## 提示

NOIP 2006 普及组 第一题



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],b[105],sum=0;
bool flag=0;
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
for(int i=1;i<=n;i++)
{
flag=0;
for(int j=1;j<=n;j++)
{
if(a[i]==b[j])
{
flag=1;
break;
}
}
if(flag==0)
{
sum+=1;
b[sum]=a[i];
}
}
sort(b+1,b+sum+1);
cout<<sum<<endl;
for(int i=1;i<=sum;i++)
{
cout<<b[i]<<" ";
}
return 0;
}
```

---

## 题目: P1063

**分类：动态规划-区间与环形动态规划**

**提交时间：2025-04-13 20:28:55**

---
title: "[NOIP 2006 提高组] 能量项链"
layout: "post"
diff: 普及+/提高
pid: P1063
tag: ['动态规划 DP', '2006', '递归', 'NOIP 提高组', '枚举', '区间 DP']
---
# [NOIP 2006 提高组] 能量项链
## 题目描述

在 Mars 星球上，每个 Mars 人都随身佩带着一串能量项链。在项链上有 $N$ 颗能量珠。能量珠是一颗有头标记与尾标记的珠子，这些标记对应着某个正整数。并且，对于相邻的两颗珠子，前一颗珠子的尾标记一定等于后一颗珠子的头标记。因为只有这样，通过吸盘（吸盘是 Mars 人吸收能量的一种器官）的作用，这两颗珠子才能聚合成一颗珠子，同时释放出可以被吸盘吸收的能量。如果前一颗能量珠的头标记为 $m$，尾标记为 $r$，后一颗能量珠的头标记为 $r$，尾标记为 $n$，则聚合后释放的能量为 $m \times r \times n$（Mars 单位），新产生的珠子的头标记为 $m$，尾标记为 $n$。

需要时，Mars 人就用吸盘夹住相邻的两颗珠子，通过聚合得到能量，直到项链上只剩下一颗珠子为止。显然，不同的聚合顺序得到的总能量是不同的，请你设计一个聚合顺序，使一串项链释放出的总能量最大。

例如：设 $N=4$，$4$ 颗珠子的头标记与尾标记依次为 $(2,3)(3,5)(5,10)(10,2)$。我们用记号 $\oplus$ 表示两颗珠子的聚合操作，$(j \oplus k)$ 表示第 $j,k$ 两颗珠子聚合后所释放的能量。则第 $4$，$1$ 两颗珠子聚合后释放的能量为：

$(4 \oplus 1)=10 \times 2 \times 3=60$。

这一串项链可以得到最优值的一个聚合顺序所释放的总能量为：

$(((4 \oplus 1) \oplus 2) \oplus 3)=10 \times 2 \times 3+10 \times 3 \times 5+10 \times 5 \times 10=710$。
## 输入格式

第一行是一个正整数 $N$（$4 \le N \le 100$），表示项链上珠子的个数。第二行是 $N$ 个用空格隔开的正整数，所有的数均不超过 $1000$。第 $i$ 个数为第 $i$ 颗珠子的头标记（$1 \le i \le N$），当 $i<N$ 时，第 $i$ 颗珠子的尾标记应该等于第 $i+1$ 颗珠子的头标记。第 $N$ 颗珠子的尾标记应该等于第 $1$ 颗珠子的头标记。

至于珠子的顺序，你可以这样确定：将项链放到桌面上，不要出现交叉，随意指定第一颗珠子，然后按顺时针方向确定其他珠子的顺序。
## 输出格式

一个正整数 $E$（$E\le 2.1 \times 10^9$），为一个最优聚合顺序所释放的总能量。

## 样例

### 样例输入 #1
```
4
2 3 5 10

```
### 样例输出 #1
```
710
```
## 提示

NOIP 2006 提高组 第一题



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[505];
int dp[505][505];
int maxx=0;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
a[i+n]=a[i];
}
for(int len=3;len<=n+1;len++){
for(int i=1;i+len-1<=2*n;i++){
int j=i+len-1;
if(j>2*n){
break;
}
for(int k=i+1;k<j;k++){
dp[i][j]=max(dp[i][j],dp[i][k]+dp[k][j]+a[i]*a[j]*a[k]);
}
}
}
for(int i=1;i<=n;i++){
maxx=max(dp[i][n+i],maxx);
}
cout<<maxx;
return 0;
}
```

---

## 题目: P1064

**分类：动态规划-动态规划的引入**

**提交时间：2025-04-06 20:16:11**

---
title: "[NOIP 2006 提高组] 金明的预算方案"
layout: "post"
diff: 普及+/提高
pid: P1064
tag: ['动态规划 DP', '2006', 'NOIP 提高组', '背包 DP']
---
# [NOIP 2006 提高组] 金明的预算方案
## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

| 主件 | 附件 |
| :----------: | :----------: |
| 电脑 | 打印机，扫描仪 |
| 书柜 | 图书 |
| 书桌 | 台灯，文具 |
| 工作椅 | 无 |

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第 $j$ 件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。

## 输入格式

第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。

第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$ 件物品的价格、重要度以及它对应的的主件。如果 $q_i=0$，表示该物品本身是主件。

## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0

```
### 样例输出 #1
```
2200
```
## 提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n \leq 3.2 \times 10^4$，$1 \leq m \leq 60$，$0 \leq v_i \leq 10^4$，$1 \leq p_i \leq 5$，$0 \leq q_i \leq m$，答案不超过 $2 \times 10^5$。

NOIP 2006 提高组 第二题


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,b[32005],dp[32005];
struct node{
int num,v,p,q;
}a[32005];
bool cmp(node x,node y){
if(x.num==y.num){
return x.q<y.q;
}
return x.num<y.num;
}
int main(){
cin>>n>>m;
for(int i=1;i<=m;i++){
int x,y,z;
cin>>x>>y>>z;
if(z==0){
a[i].num=i,a[i].v=x,a[i].p=x*y,a[i].q=0;
}
else{
b[z]+=1;
a[i].num=z,a[i].v=x,a[i].p=x*y,a[i].q=b[z];
}
}
sort(a+1,a+m+1,cmp);
for(int i=1;i<=m;i++){
if(a[i].q){
continue;
}
for(int j=n;j>=a[i].v;j--){
dp[j]=max(dp[j],dp[j-a[i].v]+a[i].p);
if(a[i+1].num==a[i].num&&j>=a[i].v+a[i+1].v){
dp[j]=max(dp[j],dp[j-a[i].v-a[i+1].v]+a[i].p+a[i+1].p);
}
if(a[i+2].num==a[i].num&&j>=a[i].v+a[i+2].v){
dp[j]=max(dp[j],dp[j-a[i].v-a[i+2].v]+a[i].p+a[i+2].p);
}
if(a[i+2].num==a[i].num&&j>=a[i].v+a[i+1].v+a[i+2].v){
dp[j]=max(dp[j],dp[j-a[i].v-a[i+1].v-a[i+2].v]+a[i].p+a[i+1].p+a[i+2].p);
}
}
}
cout<<dp[n];
return 0;
}
```

---

## 题目: P10719

**分类：GESP--GESP5级**

**提交时间：2024-12-02 20:30:37**

---
title: "[GESP202406 五级] 黑白格"
layout: "post"
diff: 普及/提高-
pid: P10719
tag: ['数学', '二分', '2024', '前缀和', 'GESP']
---
# [GESP202406 五级] 黑白格
## 题目描述

小杨有一个 $n$ 行 $m$ 列的网格图，其中每个格子要么是白色，要么是黑色。

小杨想知道至少包含 $k$ 个黑色格子的最小子矩形包含了多少个格子。
## 输入格式

第一行包含三个正整数 $n,m,k$，含义如题面所示。

之后 $n$ 行，每行⼀个长度为 $m$ 的 $\texttt{01}$ 串，代表网格图第 $i$ 行格子的颜色，如果为 $\texttt{0}$，则对应格子为白色，否则为黑色。
## 输出格式

输出一个整数，代表至少包含 $k$ 个黑色格子的最小子矩形包含格子的数量，如果不存在则输出 $0$。
## 样例

### 样例输入 #1
```
4 5 5
00000
01111
00011
00011
```
### 样例输出 #1
```
6
```
## 提示

#### 样例解释

对于样例 $1$，假设 $(i,j)$ 代表第 $i$ 行第 $j$ 列，至少包含 $5$ 个黑色格子的最小子矩形的四个顶点为 $(2,4)$，$(2,5)$，$(4,4)$，$(4,5)$，共包含 $6$ 个格子。

#### 数据范围

对于全部数据，保证有 $1\le n,m\le 100$，$1\le k\le n\times m$。

| 子任务编号 | 得分 | $n,m$ |
| :--: | :--: | :--: |
| $1$ | $20$ | $\le 10$  |
| $2$ | $40$ | $n=1$，$1\le m\le 100$ |
| $3$ | $40$ | $\le 100$|

Update on 2024/7/9：添加了若干组 hack 数据，感谢 @cff_0102 的贡献。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,a[105][105],b[105][105],minn=0x3f3f3f3f,sum=0,flag=0;
char s;
int main(){
cin>>n>>m>>k;
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
cin>>s;
a[i][j]=s-'0';
}
}
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];
}
}
for(int x=1;x<=n;x++){
for(int y=1;y<=m;y++){
for(int i=x;i<=n;i++){
for(int j=y;j<=m;j++){
sum=b[i][j]-b[x-1][j]-b[i][y-1]+b[x-1][y-1];
if(sum>=k){
flag=1;
minn=min(minn,(i-x+1)*(j-y+1));
}
}
}
}
}
if(flag==0){
cout<<0;
}
else{
cout<<minn;
}
return 0;
}
```

---

## 题目: P10720

**分类：GESP--GESP5级**

**提交时间：2024-10-28 22:19:16**

---
title: "[GESP202406 五级] 小杨的幸运数字"
layout: "post"
diff: 普及-
pid: P10720
tag: ['2024', '数论', 'GESP']
---
# [GESP202406 五级] 小杨的幸运数字
## 题目描述

小杨认为他的幸运数字应该恰好有两种不同的质因子，例如，$12=2\times 2\times 3$ 的质因子有 $2,3$，恰好为两种不同的质因子，因此 $12$ 是幸运数字，而 $30=2\times3\times5$ 的质因子有 $2,3,5$，不符合要求，不为幸运数字。

小杨现在有 $n$ 个正整数，他想知道每个正整数是否是他的幸运数字。
## 输入格式

第一行包含一个正整数 $n$，代表正整数个数。

之后 $n$ 行，每行一个正整数。
## 输出格式

输出 $n$ 行，对于每个正整数，如果是幸运数字，输出 $1$，否则输出 $0$。

## 样例

### 样例输入 #1
```
3
7
12
30
```
### 样例输出 #1
```
0
1
0
```
## 提示

### 样例解释

$7$ 的质因子有 $7$，只有一种。

$12$ 的质因子有 $2,3$，恰好有两种。

$30$ 的质因子有 $2,3,5$，有三种。


### 数据范围

子任务编号|数据点占比|$n$|正整数值域
:-:|:-:|:-:|:-:
$1$|$40\%$|$\leq 100$|$\leq 10^5$
$2$|$60\%$|$\leq 10^4$|$\leq 10^6$

对于全部数据，保证有 $1\leq n\leq 10^4$，每个正整数 $a_i$ 满足 $2\leq a_i\leq 10^6$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10005],x,sum=0;
bool flag=1;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
scanf("%d",&a[i]);
}
for(int i=1;i<=n;i++){
sum=0;
x=a[i];
for(int j=2;j<=sqrt(a[i]);j++){
if(x%j==0){
sum+=1;
while(x%j==0){
x/=j;
}
}
}
if(x>1){
sum+=1;
}
if(sum==2){
printf("%d\n",1);
}
else{
printf("%d\n",0);
}
}
return 0;
}
```

---

## 题目: P10721

**分类：GESP--GESP6级**

**提交时间：2025-04-14 21:36:53**

---
title: "[GESP202406 六级] 计算得分"
layout: "post"
diff: 普及/提高-
pid: P10721
tag: ['动态规划 DP', '2024', 'GESP']
---
# [GESP202406 六级] 计算得分
## 题目描述

小杨想要计算由 $m$ 个小写字母组成的字符串的得分。

小杨设置了一个包含 $n$ 个正整数的计分序列 $A=[a_1,a_2,\ldots,a_n]$，如果字符串的一个子串由 $k(1\leq k \leq n)$ 个 $\texttt{abc}$ 首尾相接组成，那么能够得到分数 $a_k$，并且字符串包含的字符不能够重复计算得分，整个字符串的得分是计分子串的总和。

例如，假设 ，字符串 $\texttt{dabcabcabcabzabc}$ 的所有可能计分方式如下：
- $\texttt{d+abc+abcabc+abz+abc}$ 或者 $\texttt{d+abcabc+abc+abz+abc}$，其中 $\texttt{d}$ 和 $\texttt{abz}$ 不计算得分，总得分为 $a_1+a_2+a_1$。
- $\texttt{d+abc+abc+abc+abz+abc}$，总得分为 $a_1+a_1+a_1+a_1$。
- $\texttt{d+abcabcabc+abz+abc}$，总得分为 $a_3+a_1$。

小杨想知道对于给定的字符串，最大总得分是多少。
## 输入格式

- 第一行包含一个正整数 $n$，代表计分序列 $A$ 的长度。

- 第二行包含 $n$ 个正整数，代表计分序列 $A$。

- 第三行包含一个正整数 $m$，代表字符串的长度。

- 第四行包含一个由 $m$ 个小写字母组成的字符串。
## 输出格式

输出一个整数，代表给定字符串的最大总得分。

## 样例

### 样例输入 #1
```
3
3 1 2
13
dabcabcabcabz

```
### 样例输出 #1
```
9
```
## 提示

### 样例解释
最优的计分方式为 $\texttt{d+abc+abc+abc+abz}$，总得分为 $a_1+a_1+a_1$，共 $9$ 分。

### 数据范围

子任务编号|数据点占比|$n$|$m$|$a_i$|特殊性质
:-:|:-:|:-:|:-:|:-:|:-:
$1$|$20\%$|$20$|$10^5$|$1000$|有
$2$|$40\%$|$3$|$10^5$|$1000$|无
$3$|$40\%$|$20$|$10^5$|$1000$|无

对于全部数据，保证有 $1\leq n\leq 20$，$1\leq m\leq 10^5$，$1\leq a_i\leq 1000$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[25],m,c[100005],cnt=0;
int dp[100005];
string s;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
cin>>m>>s;
for(int i=1;i<=n;i++){
for(int j=i;j<=m;j++){
dp[j]=max(dp[j],dp[j-i]+a[i]);
}
}
for(int i=0;i<=m-1;i++){
int num=i,sum=0;
while(s[num]=='a'&&s[num+1]=='b'&&s[num+2]=='c'){
sum+=1;
num+=3;
}
i=num;
if(sum>=1){
cnt+=1;
c[cnt]=sum;
}
}
int ans=0;
for(int i=1;i<=cnt;i++){
ans+=dp[c[i]];
}
cout<<ans;
return 0;
}
```

---

## 题目: P1075

**分类：入门-函数结构体**

**提交时间：2023-12-26 13:34:51**

---
title: "[NOIP 2012 普及组] 质因数分解"
layout: "post"
diff: 普及-
pid: P1075
tag: ['数学', '2012', 'NOIP 普及组', '素数判断,质数,筛法']
---
# [NOIP 2012 普及组] 质因数分解
## 题目描述

已知正整数 $n$ 是两个不同的质数的乘积，试求出两者中较大的那个质数。

## 输入格式

输入一个正整数 $n$。

## 输出格式

输出一个正整数 $p$，即较大的那个质数。

## 样例

### 样例输入 #1
```
21
```
### 样例输出 #1
```
7
```
## 提示

$1 \le n\le 2\times 10^9$

NOIP 2012 普及组 第一题



### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
int n;
cin >> n;
for (int i = 2; i <= n; i++) if (n % i == 0) {
cout << n / i;
break;
}
return 0;
}
```

---

## 题目: P10839

**提交时间：2024-08-04 14:25:18**

---
title: "【MX-J2-T0】Turtle and Equations"
layout: "post"
diff: 入门
pid: P10839
tag: ['模拟', 'O2优化', '枚举', '梦熊比赛']
---
# 【MX-J2-T0】Turtle and Equations
## 题目背景

原题链接：<https://oier.team/problems/J2A>。
## 题目描述

给你四个正整数 $a, b, c, d$。

现在你有一条算式 $(a\ \Box\ b)\ \Box\ c$。你需要判断能否在两个方框内分别填入三种运算符 $+, -, \times$ 之一（运算符可以重复使用），使得算式运算的结果等于 $d$。
## 输入格式

第一行包含四个正整数 $a, b, c, d$。
## 输出格式

如果能使得运算结果等于 $d$，输出 `Yes`，否则输出 `No`。
## 样例

### 样例输入 #1
```
1 1 1 3
```
### 样例输出 #1
```
Yes
```
### 样例输入 #2
```
5 2 9 27
```
### 样例输出 #2
```
Yes
```
### 样例输入 #3
```
1 1 4 514
```
### 样例输出 #3
```
No
```
## 提示

#### 【样例解释 #1】

因为 $(1 + 1) + 1 = 3$，可以在第一个方框内填入 $+$，第二个方框内填入 $+$。

#### 【样例解释 #2】

因为 $(5 - 2) \times 9 = 27$，可以在第一个方框内填入 $-$，第二个方框内填入 $\times$。

#### 【样例解释 #3】

无论填什么运算符都不能使得算式的结果为 $514$。

#### 【数据范围】

对于所有数据，满足 $1 \le a, b, c \le 10$，$1 \le d \le 1000$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
int a,b,c,d;
cin>>a>>b>>c>>d;
int sum=a,sum1=a,sum2=a;
int x=a,y=a,z=a;
for(int i=1;i<=3;i++)
{
if(i==1)
{
x+=b;
}
else if(i==2)
{
y-=b;
}
else if(i==3)
{
z*=b;
}
}
for(int i=1;i<=3;i++)
{
sum=x;
sum1=y;
sum2=z;
if(i==1)
{
sum+=c;
sum1+=c;
sum2+=c;
if(sum==d||sum1==d||sum2==d)
{
cout<<"Yes";
return 0;
}
}
else if(i==2)
{
sum-=c;
sum1-=c;
sum2-=c;
if(sum==d||sum1==d||sum2==d)
{
cout<<"Yes";
return 0;
}
}
else if(i==3)
{
sum*=c;
sum1*=c;
sum2*=c;
if(sum==d||sum1==d||sum2==d)
{
cout<<"Yes";
return 0;
}
}
}
cout<<"No";
return 0;
}
```

---

## 题目: P1085

**分类：入门-分支结构**

**提交时间：2024-06-06 20:40:52**

---
title: "[NOIP 2004 普及组] 不高兴的津津"
layout: "post"
diff: 入门
pid: P1085
tag: ['2004', 'NOIP 普及组', '枚举']
---
# [NOIP 2004 普及组] 不高兴的津津
## 题目描述

津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。

## 输入格式

输入包括 $7$ 行数据，分别表示周一到周日的日程安排。每行包括两个小于 $10$ 的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。

## 输出格式

一个数字。如果不会不高兴则输出 $0$，如果会则输出最不高兴的是周几（用 $1, 2, 3, 4, 5, 6, 7$ 分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。

## 样例

### 样例输入 #1
```
5 3
6 2
7 2
5 3
5 4
0 4
0 6

```
### 样例输出 #1
```
3
```
## 提示

NOIP2004 普及组第 1 题

- 2021-10-27：增加一组 hack 数据
- 2022-06-05：又增加一组 hack 数据


### 代码

```cpp
#include <iostream>
using namespace std;
int a[10],b[10],t=0,maxx=0;
int main()
{
for(int i=1;i<=7;i++)
{
cin>>a[i]>>b[i];
}
for(int i=1;i<=7;i++)
{
if(a[i]+b[i]>8&&a[i]+b[i]>maxx)
{
t=i;
maxx=a[i]+b[i];
}
}
if (t==0)
{
cout<<"0";
}
else
{
cout<<t;
}
return 0;
}
```

---

## 题目: P1089

**分类：入门-循环结构**

**提交时间：2024-02-01 13:09:40**

---
title: "[NOIP 2004 提高组] 津津的储蓄计划"
layout: "post"
diff: 入门
pid: P1089
tag: ['模拟', '2004', 'NOIP 提高组', '枚举']
---
# [NOIP 2004 提高组] 津津的储蓄计划
## 题目描述

津津的零花钱一直都是自己管理。每个月的月初妈妈给津津 $300$ 元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。

为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上 $20\%$ 还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于 $100$ 元或恰好 $100$ 元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。


例如 $11$月初津津手中还有 $83$ 元，妈妈给了津津 $300$ 元。津津预计$11$月的花销是 $180$ 元，那么她就会在妈妈那里存 $200$ 元，自己留下 $183$ 元。到了 $11$ 月月末，津津手中会剩下 $3$ 元钱。


津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。


现在请你根据 $2004$ 年 $1$ 月到 $12$ 月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到 $2004$ 年年末，妈妈将津津平常存的钱加上 $20\%$ 还给津津之后，津津手中会有多少钱。

## 输入格式

$12$ 行数据，每行包含一个小于 $350$ 的非负整数，分别表示 $1$ 月到 $12$ 月津津的预算。

## 输出格式

一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出 $-X$，$X$ 表示出现这种情况的第一个月；否则输出到 $2004$ 年年末津津手中会有多少钱。

注意，洛谷不需要进行文件输入输出，而是标准输入输出。

## 样例

### 样例输入 #1
```
290
230
280
200
300
170
340
50 
90 
80 
200
60 

```
### 样例输出 #1
```
-7 

```
### 样例输入 #2
```
290 
230 
280 
200 
300 
170 
330 
50 
90 
80 
200 
60 

```
### 样例输出 #2
```
1580

```


### 代码

```cpp
#include<iostream>
using namespace std;
int a,b,c,flag=1,d;
int main()
{
for(int i=1;i<=12;i++)
{
a+=300;
cin>>b;
a-=b;
if(a<0)
{
flag=0;
d=i;
break;
}
c+=a/100;
a%=100;
}
if(flag==1)
{
a+=c*120;
cout<<a;
}
else
{
cout<<-d;
}
return 0;
}
```

---

## 题目: P1090

**分类：数据结构--二叉堆与树状数组**

**提交时间：2024-11-21 20:46:25**

---
title: "[NOIP 2004 提高组] 合并果子"
layout: "post"
diff: 普及/提高-
pid: P1090
tag: ['贪心', '2004', '堆', 'NOIP 提高组', '优先队列']
---
# [NOIP 2004 提高组] 合并果子
## 题目描述

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n-1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 $1$ ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 $3$ 种果子，数目依次为 $1$ ， $2$ ， $9$ 。可以先将 $1$ 、 $2$ 堆合并，新堆数目为 $3$ ，耗费体力为 $3$ 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 $12$ ，耗费体力为 $12$ 。所以多多总共耗费体力 $=3+12=15$ 。可以证明 $15$ 为最小的体力耗费值。
## 输入格式

共两行。  
第一行是一个整数 $n(1\leq n\leq 10000)$ ，表示果子的种类数。  

第二行包含 $n$ 个整数，用空格分隔，第 $i$ 个整数 $a_i(1\leq a_i\leq 20000)$ 是第 $i$ 种果子的数目。


## 输出格式

一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 $2^{31}$ 。
## 样例

### 样例输入 #1
```
3 
1 2 9 

```
### 样例输出 #1
```
15

```
## 提示

对于 $30\%$ 的数据，保证有 $n \le 1000$：

对于 $50\%$ 的数据，保证有 $n \le 5000$；

对于全部的数据，保证有 $n \le 10000$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[10005],sum=0;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
sort(a+1,a+1+n);
for(int i=1;i<=n-1;i++){
a[i+1]+=a[i];
sum+=a[i+1];
sort(a+1+i,a+1+n);
}
cout<<sum;
return 0;
}
```

---

## 题目: P1091

**分类：动态规划-线性状态动态规划**

**提交时间：2025-03-02 13:51:45**

---
title: "[NOIP 2004 提高组] 合唱队形"
layout: "post"
diff: 普及/提高-
pid: P1091
tag: ['动态规划 DP', '2004', '单调队列', 'NOIP 提高组', '线性 DP']
---
# [NOIP 2004 提高组] 合唱队形
## 题目描述

$n$ 位同学站成一排，音乐老师要请其中的 $n-k$ 位同学出列，使得剩下的 $k$ 位同学排成合唱队形。

合唱队形是指这样的一种队形：设 $k$ 位同学从左到右依次编号为 $1,2,$ … $,k$，他们的身高分别为 $t_1,t_2,$ … $,t_k$，则他们的身高满足 $t_1< \cdots <t_i>t_{i+1}>$ … $>t_k(1\le i\le k)$。

你的任务是，已知所有 $n$ 位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。
## 输入格式

共二行。

第一行是一个整数 $n$（$2\le n\le100$），表示同学的总数。

第二行有 $n$ 个整数，用空格分隔，第 $i$ 个整数 $t_i$（$130\le t_i\le230$）是第 $i$ 位同学的身高（厘米）。
## 输出格式

一个整数，最少需要几位同学出列。

## 样例

### 样例输入 #1
```
8
186 186 150 200 160 130 197 220

```
### 样例输出 #1
```
4

```
## 提示

对于 $50\%$ 的数据，保证有 $n \le 20$。

对于全部的数据，保证有 $n \le 100$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,j,a[110],dp1[110],dp2[110],ans;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=n;i++){
dp1[i]=1;
for(int j=1;j<i;j++){
if(a[j]<a[i]){
dp1[i]=max(dp1[i],dp1[j]+1);
}
}
}
for(int i=n;i>=1;i--){
dp2[i]=1;
for(int j=n;j>i;j--){
if(a[j]<a[i]){
dp2[i]=max(dp2[i],dp2[j]+1);
}
}
}
for(int i=1;i<=n;i++){
ans=max(ans,dp1[i]+dp2[i]-1);
}
cout<<n-ans;
return 0;
}
```

---

## 题目: P1093

**分类：算法--排序**

**提交时间：2024-09-04 21:08:34**

---
title: "[NOIP 2007 普及组] 奖学金"
layout: "post"
diff: 普及-
pid: P1093
tag: ['模拟', '数学', '2007', 'NOIP 普及组', '排序']
---
# [NOIP 2007 普及组] 奖学金
## 题目背景

NOIP2007 普及组 T1
## 题目描述

某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 $5$ 名学生发奖学金。期末，每个学生都有 $3$ 门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。

任务：先根据输入的 $3$ 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。

注意，在前 $5$ 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据（每行输出两个数：学号、总分) 是：

```plain
7 279  
5 279
```

这两行数据的含义是：总分最高的两个同学的学号依次是 $7$ 号、$5$ 号。这两名同学的总分都是 $279$ (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为 $7$ 的学生语文成绩更高一些。

如果你的前两名的输出数据是：

```plain
5 279  
7 279
```

则按输出错误处理，不能得分。

## 输入格式

共 $n+1$ 行。

第 $1$ 行为一个正整数 $n \le 300$，表示该校参加评选的学生人数。

第 $2$ 到 $n+1$ 行，每行有 $3$ 个用空格隔开的数字，每个数字都在 $0$ 到 $100$ 之间。第 $j$ 行的 $3$ 个数字依次表示学号为 $j-1$ 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 $1\sim n$（恰好是输入数据的行号减 $1$）。

保证所给的数据都是正确的，不必检验。

## 输出格式

共 $5$ 行，每行是两个用空格隔开的正整数，依次表示前 $5$ 名学生的学号和总分。

## 样例

### 样例输入 #1
```
6
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98

```
### 样例输出 #1
```
6 265
4 264
3 258
2 244
1 237


```
### 样例输入 #2
```
8
80 89 89
88 98 78
90 67 80
87 66 91
78 89 91
88 99 77
67 89 64
78 89 98
```
### 样例输出 #2
```
8 265
2 264
6 264
1 258
5 258

```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[305][5],b[305][5],sum=0;
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
b[i][1]=i;
sum=0;
for(int j=1;j<=3;j++)
{
cin>>a[i][j];
sum+=a[i][j];
}
b[i][2]=sum;
b[i][3]=a[i][1];
}
for(int i=1;i<n;i++)
{
for(int j=1;j<n;j++)
{
if(b[j][2]<b[j+1][2])
{
swap(b[j][2],b[j+1][2]);
swap(b[j][1],b[j+1][1]);
swap(b[j][3],b[j+1][3]);
}
if(b[j][2]==b[j+1][2])
{
if(b[j][3]<b[j+1][3])
{
swap(b[j][2],b[j+1][2]);
swap(b[j][1],b[j+1][1]);
swap(b[j][3],b[j+1][3]);
}
}
}
}
for(int i=1;i<=5;i++)
{
for(int j=1;j<=2;j++)
{
cout<<b[i][j]<<" ";
}
cout<<endl;
}
return 0;
}
```

---

## 题目: P1094

**分类：算法--贪心**

**提交时间：2024-11-21 20:06:53**

---
title: "[NOIP 2007 普及组] 纪念品分组"
layout: "post"
diff: 普及-
pid: P1094
tag: ['贪心', '2007', 'NOIP 普及组', '排序']
---
# [NOIP 2007 普及组] 纪念品分组
## 题目背景

NOIP2007 普及组 T2
## 题目描述

元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。

你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。

## 输入格式

共 $n+2$ 行：

第一行包括一个整数 $w$，为每组纪念品价格之和的上限。

第二行为一个整数 $n$，表示购来的纪念品的总件数 $G$。

第 $3\sim n+2$ 行每行包含一个正整数 $P_i$ 表示所对应纪念品的价格。

## 输出格式

一个整数，即最少的分组数目。

## 样例

### 样例输入 #1
```
100 
9 
90 
20 
20 
30 
50 
60 
70 
80 
90

```
### 样例输出 #1
```
6

```
## 提示

$50\%$ 的数据满足：$1\le n\le15$。

$100\%$ 的数据满足：$1\le n\le3\times10^4$，$80\le w\le200$，$5 \le  P_i  \le  w$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int w,n,a[30005],sum;
int main(){
cin>>w>>n;
for(int i=1;i<=n;i++){
scanf("%d",&a[i]);
}
sort(a+1,a+n+1);
int l=1,r=n;
while(l<=r){
if(a[l]+a[r]<=w){
l+=1;
r-=1;
sum+=1;
}
else{
r-=1;
sum+=1;
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P10973

**分类：动态规划**

**提交时间：2025-03-30 21:35:43**

---
title: "Coins"
layout: "post"
diff: 普及+/提高
pid: P10973
tag: []
---
# Coins
## 题目描述

银国的人们使用硬币。他们有面值分别为 $A_1, A_2, A_3, \dots, A_n$ 的硬币。有一天，托尼打开了他的储蓄罐，发现里面有一些硬币。他决定去附近的商店购买一块非常漂亮的手表。他想要支付准确的价格（不找零），而他知道手表的价格不会超过 $m$ 。但他不知道手表的确切价格。

你需要编写一个程序，读取 $n$、$m$、$A_1, A_2, A_3, \dots, A_n$ 以及对应的数量 $C_1, C_2, C_3, \dots, C_n$ （表示托尼拥有的每种面值的硬币数量），然后计算托尼可以用这些硬币支付的价格数量（从 1 到 $m$ 的所有价格）。
## 输入格式

输入包含多个测试用例（不超过 $25$ 组）。每个测试用例的第一行包含两个整数 $n (1 ≤ n ≤ 100)$ 和 $m (m ≤ 100000)$。第二行包含 $2n$ 个整数，分别表示 $A_1, A_2, A_3, \dots, A_n$ 和 $C_1, C_2, C_3, \dots, C_n (1 ≤ A_i ≤ 100000, 1 ≤ C_i ≤ 1000)$。最后一个测试用例以两个零结尾。

## 输出格式

对于每个测试用例，在单独的一行输出答案。
## 样例

### 样例输入 #1
```
3 10
1 2 4 2 1 1
2 5
1 4 2 1
0 0
```
### 样例输出 #1
```
8
4
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[105],c[105],dp[100005];
int main(){
while(true){
memset(dp,0,sizeof(dp));
cin>>n>>m;
if(n==0&&m==0){
break;
}
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=n;i++){
cin>>c[i];
}
for(int i=1;i<=n;i++){
for(int k=1;k<=c[i];k*=2){
c[i]-=k;
for(int j=m;j>=k*a[i];j--){
dp[j]=max(dp[j],dp[j-k*a[i]]+k*a[i]);
}
}
if(c[i]>0){
for(int j=m;j>=c[i]*a[i];j--){
dp[j]=max(dp[j],dp[j-c[i]*a[i]]+a[i]*c[i]);
}
}
}
int ans=0;
for(int i=1;i<=m;i++){
if(dp[i]!=dp[i-1]){
ans+=1;
}
}
cout<<ans<<endl;
}
return 0;
}
```

---

## 题目: P1101

**分类：算法--搜索**

**提交时间：2025-02-24 19:47:53**

---
title: "单词方阵"
layout: "post"
diff: 普及-
pid: P1101
tag: ['字符串', '搜索']
---
# 单词方阵
## 题目描述

给一 $n \times n$ 的字母方阵，内可能蕴含多个 `yizhong` 单词。单词在方阵中是沿着同一方向连续摆放的。摆放可沿着 $8$ 个方向的任一方向，同一单词摆放时不再改变方向，单词与单词之间可以交叉，因此有可能共用字母。输出时，将不是单词的字母用 `*` 代替，以突出显示单词。
## 输入格式

第一行输入一个数 $n$。$(7 \le n \le 100)$。

第二行开始输入 $n \times n$ 的字母矩阵。

## 输出格式

突出显示单词的 $n \times n$ 矩阵。

## 样例

### 样例输入 #1
```
7
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa
aaaaaaa

```
### 样例输出 #1
```
*******
*******
*******
*******
*******
*******
*******

```
### 样例输入 #2
```
8
qyizhong
gydthkjy
nwidghji
orbzsfgz
hhgrhwth
zzzzzozo
iwdfrgng
yyyygggg
```
### 样例输出 #2
```
*yizhong
gy******
n*i*****
o**z****
h***h***
z****o**
i*****n*
y******g
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,vis[105][105];
string a[105];
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=n;i++){
for(int j=0;j<n;j++){
if(a[i][j]=='y'){
if(i-7+1>=1){
if(a[i-1][j]=='i'&&a[i-2][j]=='z'&&a[i-3][j]=='h'&&a[i-4][j]=='o'&&a[i-5][j]=='n'&&a[i-6][j]=='g'){
vis[i][j]=1,vis[i-1][j]=1,vis[i-2][j]=1,vis[i-3][j]=1;
vis[i-4][j]=1,vis[i-5][j]=1,vis[i-6][j]=1;
}
}
if(i+7-1<=n){
if(a[i+1][j]=='i'&&a[i+2][j]=='z'&&a[i+3][j]=='h'&&a[i+4][j]=='o'&&a[i+5][j]=='n'&&a[i+6][j]=='g'){
vis[i][j]=1,vis[i+1][j]=1,vis[i+2][j]=1,vis[i+3][j]=1;
vis[i+4][j]=1,vis[i+5][j]=1,vis[i+6][j]=1;
}
}
if(j-7+1>=0){
if(a[i][j-1]=='i'&&a[i][j-2]=='z'&&a[i][j-3]=='h'&&a[i][j-4]=='o'&&a[i][j-5]=='n'&&a[i][j-6]=='g'){
vis[i][j]=1,vis[i][j-1]=1,vis[i][j-2]=1,vis[i][j-3]=1,
vis[i][j-4]=1,vis[i][j-5]=1,vis[i][j-6]=1;
}
}
if(j+7-1<n){
if(a[i][j+1]=='i'&&a[i][j+2]=='z'&&a[i][j+3]=='h'&&a[i][j+4]=='o'&&a[i][j+5]=='n'&&a[i][j+6]=='g'){
vis[i][j]=1,vis[i][j+1]=1,vis[i][j+2]=1,vis[i][j+3]=1,
vis[i][j+4]=1,vis[i][j+5]=1,vis[i][j+6]=1;
}
}
if(i-7+1>=1&&j+7-1<n){
if(a[i-1][j+1]=='i'&&a[i-2][j+2]=='z'&&a[i-3][j+3]=='h'&&a[i-4][j+4]=='o'&&a[i-5][j+5]=='n'&&a[i-6][j+6]=='g'){
vis[i][j]=1,vis[i-1][j+1]=1,vis[i-2][j+2]=1,vis[i-3][j+3]=1,
vis[i-4][j+4]=1,vis[i-5][j+5]=1,vis[i-6][j+6]=1;
}
}
if(i-7+1>=1&&j-7+1>=0){
if(a[i-1][j-1]=='i'&&a[i-2][j-2]=='z'&&a[i-3][j-3]=='h'&&a[i-4][j-4]=='o'&&a[i-5][j-5]=='n'&&a[i-6][j-6]=='g'){
vis[i][j]=1,vis[i-1][j-1]=1,vis[i-2][j-2]=1,vis[i-3][j-3]=1,
vis[i-4][j-4]=1,vis[i-5][j-5]=1,vis[i-6][j-6]=1;
}
}
if(i+7-1<=n&&j-7+1>=0){
if(a[i+1][j-1]=='i'&&a[i+2][j-2]=='z'&&a[i+3][j-3]=='h'&&a[i+4][j-4]=='o'&&a[i+5][j-5]=='n'&&a[i+6][j-6]=='g'){
vis[i][j]=1,vis[i+1][j-1]=1,vis[i+2][j-2]=1,vis[i+3][j-3]=1,
vis[i+4][j-4]=1,vis[i+5][j-5]=1,vis[i+6][j-6]=1;
}
}
if(i+7-1<=n&&j+7-1<n){
if(a[i+1][j+1]=='i'&&a[i+2][j+2]=='z'&&a[i+3][j+3]=='h'&&a[i+4][j+4]=='o'&&a[i+5][j+5]=='n'&&a[i+6][j+6]=='g'){
vis[i][j]=1,vis[i+1][j+1]=1,vis[i+2][j+2]=1,vis[i+3][j+3]=1,
vis[i+4][j+4]=1,vis[i+5][j+5]=1,vis[i+6][j+6]=1;
}
}
}
}
}
for(int i=1;i<=n;i++){
for(int j=0;j<n;j++){
if(vis[i][j]==0){
cout<<"*";
}
else{
cout<<a[i][j];
}
}
cout<<endl;
}
return 0;
}
```

---

## 题目: P1102

**分类：算法--贪心优化技巧**

**提交时间：2024-11-14 20:05:50**

---
title: "A-B 数对"
layout: "post"
diff: 普及-
pid: P1102
tag: ['模拟', '数学', '二分', '排序', '哈希 hashing', '双指针 two-pointer']
---
# A-B 数对
## 题目背景

出题是一件痛苦的事情！

相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！
## 题目描述

给出一串正整数数列以及一个正整数 $C$，要求计算出所有满足 $A - B = C$ 的数对的个数（不同位置的数字一样的数对算不同的数对）。
## 输入格式

输入共两行。

第一行，两个正整数 $N,C$。

第二行，$N$ 个正整数，作为要求处理的那串数。
## 输出格式

一行，表示该串正整数中包含的满足 $A - B = C$ 的数对的个数。
## 样例

### 样例输入 #1
```
4 1
1 1 2 3

```
### 样例输出 #1
```
3
```
## 提示

对于 $75\%$ 的数据，$1 \leq N \leq 2000$。

对于 $100\%$ 的数据，$1 \leq N \leq 2 \times 10^5$，$0 \leq a_i <2^{30}$，$1 \leq C < 2^{30}$。

2017/4/29 新添数据两组


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c,a[200005];
long long ans=0;
int main(){
cin>>n>>c;
for(int i=1;i<=n;i++){
cin>>a[i];
}
sort(a+1,a+n+1);
for(int i=1;i<=n;i++){
ans+=upper_bound(a+1,a+n+1,a[i]+c)-lower_bound(a+1,a+n+1,a[i]+c);
}
cout<<ans;
return 0;
}
```

---

## 题目: P1104

**分类：算法--排序**

**提交时间：2025-02-21 16:22:45**

---
title: "生日"
layout: "post"
diff: 普及-
pid: P1104
tag: ['模拟', '字符串', '排序']
---
# 生日
## 题目描述

cjf 君想调查学校 OI 组每个同学的生日，并按照年龄从大到小的顺序排序。但 cjf 君最近作业很多，没有时间，所以请你帮她排序。

## 输入格式

输入共有 $n + 1$ 行，

第 $1$ 行为 OI 组总人数 $n$；

第 $2$ 行至第 $n+1$ 行分别是每人的姓名 $s$、出生年 $y$、月 $m$、日 $d$。

## 输出格式

输出共有 $n$ 行，

即 $n$ 个生日从大到小同学的姓名。（如果有两个同学生日相同，输入靠后的同学先输出）

## 样例

### 样例输入 #1
```
3
Yangchu 1992 4 23
Qiujingya 1993 10 13
Luowen 1991 8 1

```
### 样例输出 #1
```
Luowen
Yangchu
Qiujingya

```
## 提示

数据保证，$1<n<100$，$1\leq |s|<20$。保证年月日实际存在，且年份 $\in [1960,2020]$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct student{
string name;
int year,month,day,num;
}a[105];
bool cmp(student x,student y){
if(x.year<y.year){
return true;
}
if(x.year==y.year&&x.month<y.month){
return true;
}
if(x.year==y.year&&x.month==y.month&&x.day<y.day){
return true;
}
if(x.year==y.year&&x.month==y.month&&x.day==y.day&&x.num>y.num){
return true;
}
return false;
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i].name>>a[i].year>>a[i].month>>a[i].day;
a[i].num=i;
}
sort(a+1,a+n+1,cmp);
for(int i=1;i<=n;i++){
cout<<a[i].name<<endl;
}
return 0;
}
```

---

## 题目: P1106

**分类：算法--贪心**

**提交时间：2024-11-24 11:54:03**

---
title: "删数问题"
layout: "post"
diff: 普及/提高-
pid: P1106
tag: ['字符串', '贪心']
---
# 删数问题
## 题目描述

键盘输入一个高精度的正整数 $n$（不超过 $250$ 位），去掉其中任意 $k$ 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 $n$ 和 $k$，寻找一种方案使得剩下的数字组成的新数最小。
## 输入格式

输入两行正整数。

第一行输入一个高精度的正整数 $n$。

第二行输入一个正整数 $k$，表示需要删除的数字个数。
## 输出格式

输出一个整数，最后剩下的最小数。

## 样例

### 样例输入 #1
```
175438 
4

```
### 样例输出 #1
```
13
```
## 提示

用 $\operatorname{len}(n)$ 表示 $n$ 的**位数**，保证 $1 \leq k < \operatorname{len}(n) \leq 250$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
char s[260];
int k;
int main(){
scanf("%s %d",s,&k);
int len=strlen(s);
while(k--){
for(int i=0;i<len;i++){
if(s[i]>s[i+1]){
for(int j=i;j<len;j++){
s[j]=s[j+1];
}
break;
}
}
len-=1;
}
int m=0;
while(s[m]=='0'){
m+=1;
}
for(;s[m]!='\0';m+=1){
cout<<s[m];
}
if(len==1){
cout<<0;
}
return 0;
}
```

---

## 题目: P1109

**提交时间：2024-12-07 11:49:16**

---
title: "学生分组"
layout: "post"
diff: 普及-
pid: P1109
tag: ['模拟', '贪心']
---
# 学生分组
## 题目描述

有 $n$ 组学生，给出初始时每组中的学生个数，再给出每组学生人数的上界 $R$ 和下界 $L\ (L \le R)$，每次你可以在某组中选出一个学生把他安排到另外一组中，问最少要多少次才可以使 $N$ 组学生的人数都在 $[L,R]$ 中。

## 输入格式

第一行一个整数 $n$，表示学生组数；

第二行 $n$ 个整数，表示每组的学生个数；

第三行两个整数 $L,R$，表示下界和上界。

## 输出格式

一个数，表示最少的交换次数，如果不能满足题目条件输出 $-1$。
## 样例

### 样例输入 #1
```
2
10 20
10 15

```
### 样例输出 #1
```
5
```
## 提示

### 数据范围及约定

对于全部数据，保证 $1\le n \le 50$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,l,r,a[55],maxx,miny,sum,x;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
sum+=a[i];
}
cin>>l>>r;
for(int i=1;i<=n;i++){
if(a[i]>r){
maxx+=a[i]-r;
}
else if(a[i]<l){
miny+=l-a[i];
}
}
if(sum<l*n||sum>r*n){
cout<<-1;
}
else{
x=max(maxx,miny);
cout<<x;
}
return 0;
}
```

---

## 题目: P1116

**分类：算法--排序**

**提交时间：2024-09-05 20:23:16**

---
title: "车厢重组"
layout: "post"
diff: 普及-
pid: P1116
tag: ['模拟', '排序']
---
# 车厢重组
## 题目描述

在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转 $180$ 度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。

## 输入格式

共两行。  

第一行是车厢总数 $N( \le 10000)$。
  
第二行是 $N$ 个不同的数表示初始的车厢顺序。  
（**注**：实际上数据中并不都在同一行，有可能分行输入）

## 输出格式

一个整数，最少的旋转次数。

## 样例

### 样例输入 #1
```
4
4 3 2 1 
```
### 样例输出 #1
```
6
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10005],ans=0;
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
for(int i=1;i<=n-1;i++)
{
for(int j=1;j<=n-i;j++)
{
if(a[j]>a[j+1])
{
swap(a[j],a[j+1]);
ans+=1;
}
}
}
cout<<ans;
return 0;
}
```

---

## 题目: P11246

**分类：GESP--GESP6级**

**提交时间：2025-04-02 20:42:52**

---
title: "[GESP202409 六级] 小杨和整数拆分"
layout: "post"
diff: 普及-
pid: P11246
tag: ['动态规划 DP', '2024', 'GESP']
---
# [GESP202409 六级] 小杨和整数拆分
## 题目描述

小杨有一个正整数 $n$，小杨想将它拆分成若干完全平方数的和，同时小杨希望拆分的数量越少越好。

编程计算总和为 $n$ 的完全平方数的最小数量。
## 输入格式

输入只有一行一个正整数 $n$。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
18

```
### 样例输出 #1
```
2
```
## 提示

### 数据规模与约定

对全部的测试数据，保证 $1 \leq n \leq 10^5$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1005],dp[100005],cnt=0;
int main(){
cin>>n;
for(int i=1;i<=sqrt(n);i++){
a[i]=i*i;
}
for(int i=1;i<=n;i++){
dp[i]=INT_MAX;
}
for(int i=1;i<=sqrt(n);i++){
for(int j=a[i];j<=n;j++){
dp[j]=min(dp[j],dp[j-a[i]]+1);
}
}
cout<<dp[n];
return 0;
}
```

---

## 题目: P1125

**分类：入门-字符串**

**提交时间：2025-02-02 21:20:49**

---
title: "[NOIP 2008 提高组] 笨小猴"
layout: "post"
diff: 普及-
pid: P1125
tag: ['2008', 'NOIP 提高组', '素数判断,质数,筛法']
---
# [NOIP 2008 提高组] 笨小猴
## 题目描述

笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！

这种方法的具体描述如下：假设 $\text{maxn}$ 是单词中出现次数最多的字母的出现次数，$\text{minn}$ 是单词中出现次数最少的字母的出现次数，如果 $\text{maxn}-\text{minn}$ 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。

## 输入格式

一个单词，其中只可能出现小写字母，并且长度小于 $100$。

## 输出格式

共两行，第一行是一个字符串，假设输入的的单词是 Lucky Word，那么输出 `Lucky Word`，否则输出 `No Answer`；

第二行是一个整数，如果输入单词是 `Lucky Word`，输出 $\text{maxn}-\text{minn}$ 的值，否则输出 $0$。

## 样例

### 样例输入 #1
```
error
```
### 样例输出 #1
```
Lucky Word
2
```
### 样例输入 #2
```
olympic
```
### 样例输出 #2
```
No Answer
0
```
## 提示

【输入输出样例 1 解释】

单词 `error` 中出现最多的字母 $\texttt r$ 出现了 $3$ 次，出现次数最少的字母出现了 $1$ 次，$3-1=2$，$2$ 是质数。

【输入输出样例 2 解释】

单词 `olympic` 中出现最多的字母 $\texttt i$ 出现了 $1$ 次，出现次数最少的字母出现了 $1$ 次，$1-1=0$，$0$ 不是质数。

（本处原题面错误已经修正）

noip2008 提高第一题



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[105],maxn=0,minn=105;
int cnt[30];
string s;
void prime(){
for(int i=2;i<=sqrt(100);i++){
if(a[i]){
for(int j=i*i;j<=100;j+=i){
a[j]=0;
}
}
}
}
int main(){
a[0]=0;
a[1]=0;
for(int i=2;i<=100;i++){
a[i]=1;
}
prime();
cin>>s;
for(int i=0;i<s.length();i++){
cnt[s[i]-96]+=1;
}
for(int i=1;i<=26;i++){
maxn=max(maxn,cnt[i]);
if(cnt[i]>0){
minn=min(minn,cnt[i]);
}
}
if(minn==105){
minn=1;
}
if(a[maxn-minn]==1){
cout<<"Lucky Word"<<endl;
cout<<maxn-minn;
}
else{
cout<<"No Answer"<<endl;
cout<<0;
}
return 0;
}
```

---

## 题目: P11271

**提交时间：2024-11-10 15:50:29**

---
title: "「Diligent-OI R1 A」DlgtPattern"
layout: "post"
diff: 入门
pid: P11271
tag: ['洛谷原创', '洛谷月赛']
---
# 「Diligent-OI R1 A」DlgtPattern
## 题目描述

现有一个水杯放在一个不透明的盒子中。水杯的底面可以看成一个圆形。盒子可以看成一个长方体，其厚度忽略不计。

现将盒子的底面放在一个平面直角坐标系中，它的四个顶点分别位于 $(0,0)$，$(x,0)$，$(0,y)$ 和 $(x,y)$。

你只知道水杯底面的圆心位于 $(p,q)$。那水杯底面的半径最大可以是多少呢？
## 输入格式

只输入一行，四个整数 $x,y,p,q$。
## 输出格式

只输出一个数，水杯底面半径的最大值。
## 样例

### 样例输入 #1
```
10 5 3 4
```
### 样例输出 #1
```
1
```
## 提示

#### 样例 #1 解释

水杯半径最大的情况如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/gpbwxjuj.png)

#### 数据范围

对于 $100\%$ 数据，$0<p<x\le100$，$0<q<y\le100$。

| 测试点编号 | 特殊性质 |
| :----------: | :----------: |
| $1\sim 4$ | AB |
| $5\sim 6$ | B |
| $7\sim 10$ | 无 |

特殊性质 A：$x=y$。

特殊性质 B：$x=2p,y=2q$。即水杯底面的圆心在盒子底面的几何中心。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y,p,q;
int main(){
cin>>x>>y>>p>>q;
for(int i=min(x,y);i>=1;i--){
if(p-i>=0&&q-i>=0&&p+i<=x&&q+i<=y){
cout<<i;
break;
}
}
return 0;
}
```

---

## 题目: P1135

**分类：算法--搜索**

**提交时间：2024-08-11 19:45:05**

---
title: "奇怪的电梯"
layout: "post"
diff: 普及/提高-
pid: P1135
tag: ['模拟', '广度优先搜索 BFS', '深度优先搜索 DFS']
---
# 奇怪的电梯
## 题目背景

感谢 @[yummy](https://www.luogu.com.cn/user/101694) 提供的一些数据。
## 题目描述

呵呵，有一天我做了一个梦，梦见了一种很奇怪的电梯。大楼的每一层楼都可以停电梯，而且第 $i$ 层楼（$1 \le i \le N$）上有一个数字 $K_i$（$0 \le K_i \le N$）。电梯只有四个按钮：开，关，上，下。上下的层数等于当前楼层上的那个数字。当然，如果不能满足要求，相应的按钮就会失灵。例如： $3, 3, 1, 2, 5$ 代表了 $K_i$（$K_1=3$，$K_2=3$，……），从 $1$ 楼开始。在 $1$ 楼，按“上”可以到 $4$ 楼，按“下”是不起作用的，因为没有 $-2$ 楼。那么，从 $A$ 楼到 $B$ 楼至少要按几次按钮呢？

## 输入格式

共二行。  

第一行为三个用空格隔开的正整数，表示 $N, A, B$（$1 \le N \le 200$，$1 \le A, B \le N$）。

第二行为 $N$ 个用空格隔开的非负整数，表示 $K_i$。

## 输出格式

一行，即最少按键次数，若无法到达，则输出 `-1`。
## 样例

### 样例输入 #1
```
5 1 5
3 3 1 2 5

```
### 样例输出 #1
```
3

```
## 提示

对于 $100 \%$ 的数据，$1 \le N \le 200$，$1 \le A, B \le N$，$0 \le K_i \le N$。

本题共 $16$ 个测试点，前 $15$ 个每个测试点 $6$ 分，最后一个测试点 $10$ 分。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a,b,tmp;
struct floors
{
int up,down,step;
bool visit;
}fs[205];
int main()
{
cin>>n>>a>>b;
for(int i=1;i<=n;i++)
{
cin>>tmp;
fs[i].up=i+tmp;
fs[i].down=i-tmp;
fs[i].step=-1;
fs[i].visit=false;
}
queue<floors>q;
fs[a].step=0;
fs[a].visit=true;
q.push(fs[a]);
while(!q.empty())
{
floors f=q.front();
q.pop();
int u=f.up,d=f.down;
if(u>=1&&u<=n&&fs[u].visit==false)
{
fs[u].visit=true;
fs[u].step=f.step+1;
q.push(fs[u]);
}
if(d>=1&&d<=n&&fs[d].visit==false)
{
fs[d].visit=true;
fs[d].step=f.step+1;
q.push(fs[d]);
}
if(u==b||d==b)
{
break;
}
}
cout<<fs[b].step;
}
```

---

## 题目: P1141

**提交时间：2024-12-10 00:08:03**

---
title: "01迷宫"
layout: "post"
diff: 普及/提高-
pid: P1141
tag: ['搜索', '广度优先搜索 BFS', '队列']
---
# 01迷宫
## 题目描述

有一个仅由数字 $0$ 与 $1$ 组成的 $n \times n$ 格迷宫。若你位于一格 $0$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $1$ 上，同样若你位于一格 $1$ 上，那么你可以移动到相邻 $4$ 格中的某一格 $0$ 上。

你的任务是：对于给定的迷宫，询问从某一格开始能移动到多少个格子（包含自身）。
## 输入格式

第一行为两个正整数 $n,m$。

下面 $n$ 行，每行 $n$ 个字符，字符只可能是 $0$ 或者 $1$，字符之间没有空格。

接下来 $m$ 行，每行两个用空格分隔的正整数 $i,j$，对应了迷宫中第 $i$ 行第 $j$ 列的一个格子，询问从这一格开始能移动到多少格。
## 输出格式

$m$ 行，对于每个询问输出相应答案。

## 样例

### 样例输入 #1
```
2 2
01
10
1 1
2 2

```
### 样例输出 #1
```
4
4

```
## 提示

对于样例，所有格子互相可达。

- 对于 $20\%$ 的数据，$n \leq 10$；
- 对于 $40\%$ 的数据，$n \leq 50$；
- 对于 $50\%$ 的数据，$m \leq 5$；
- 对于 $60\%$ 的数据，$n,m \leq 100$；
- 对于 $100\%$ 的数据，$1\le n \leq 1000$，$1\le m \leq 100000$。


### 代码

```cpp
#include <iostream>
#include <cstring>
#include <queue>
using namespace std;
int maze[1005][1005];
int color[1005][1005];
int n, m;
int nextColor;
int colorCount[1000005];
const int dx[4] = {0, 1, 0, -1};
const int dy[4] = {1, 0, -1, 0};
int bfs(int x, int y) {
if (color[x][y] != -1) {
return colorCount[color[x][y]];
}
int count = 1;
queue<int>q;
color[x][y] = nextColor;
q.push(x);
q.push(y);
while (!q.empty()) {
x = q.front();
q.pop();
y = q.front();
q.pop();
for (int i = 0; i < 4; ++i) {
int xx = x + dx[i];
int yy = y + dy[i];
if (!(xx > 0 && xx <= n && yy > 0 && yy <= n)) {
continue;
}
if (color[xx][yy] == -1 && maze[xx][yy] != maze[x][y]) {
color[xx][yy] = nextColor;
count++;
q.push(xx);
q.push(yy);
}
}
}
colorCount[nextColor] = count;
nextColor++;
return count;
}
int main() {
cin >> n >> m;
for (int i = 1; i <= n; ++i) {
for (int j = 1; j <= n; ++j) {
char c;
cin >> c;
maze[i][j] = c - '0';
}
}
memset(color, -1, sizeof(color));
nextColor = 0;
for (int i = 0; i < m; ++i) {
int x, y;
cin >> x >> y;
cout << bfs(x, y) << endl;
}
return 0;
}
```

---

## 题目: P1145

**分类：搜索**

**提交时间：2025-03-18 21:46:56**

---
title: "约瑟夫"
layout: "post"
diff: 普及-
pid: P1145
tag: ['搜索', '枚举', '剪枝']
---
# 约瑟夫
## 题目描述

$n$ 个人站成一圈，从某个人开始数数，每次数到 $m$ 的人就被杀掉，然后下一个人重新开始数，直到最后只剩一个人。现在有一圈人，$k$ 个好人站在一起，$k$ 个坏人站在一起。从第一个好人开始数数。你要确定一个最小的 $m$，使得在第一个好人被杀死前，$k$ 个坏人先被杀死。

## 输入格式

一行一个整数 $k$。
## 输出格式

一行一个整数 $m$。
## 样例

### 样例输入 #1
```
3
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
4
```
### 样例输出 #2
```
30
```
## 提示

$0\lt k\lt 14$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m=0,vis[2600005],a[20]={0,2,7,5,30,169,441,1872,7632,1740,93313,459901,1358657,2504881},sum,x,temp;
int main(){
cin>>n;
cout<<a[n];
return 0;
//	while(true){
//		m+=1;
//		temp=m;
//		sum=0;
//		memset(vis,0,sizeof(vis));
//		x=0;
//		while(sum<n){
//			x+=1;
//			if(x==2*n+1){
//				x=1;
//			}
//			if(vis[x]==0){
//				temp-=1;
//				if(temp==0){
//					if(x<=n){
//						sum=n+1;
//						break;
//					}
//					vis[x]=1;
//					temp=m;
//					sum+=1;
//				}
//			}
//		}
//		if(sum==n){
//			cout<<m;
//			break;
//		}
//	}
//  return 0;
}
```

---

## 题目: P1152

**分类：算法--排序**

**提交时间：2024-09-05 20:35:41**

---
title: "欢乐的跳"
layout: "post"
diff: 入门
pid: P1152
tag: ['模拟', '枚举', '排序']
---
# 欢乐的跳
## 题目描述

一个 $n$ 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 $[1,n-1]$ 之间的所有整数，则称之符合“欢乐的跳”，如数组 $\{1,4,2,3\}$ 符合“欢乐的跳”，因为差的绝对值分别为：$3,2,1$。

给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。

## 输入格式

每组测试数据第一行以一个整数 $n(1 \le n \le 1000)$ 开始，接下来 $n$ 个空格隔开的在 $[-10^8,10^8]$ 之间的整数。

## 输出格式

对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出 `Jolly`，否则输出 `Not jolly`。

## 样例

### 样例输入 #1
```
4 1 4 2 3

```
### 样例输出 #1
```
Jolly

```
### 样例输入 #2
```
5 1 4 2 -1 6
```
### 样例输出 #2
```
Not jolly
```
## 提示

$1 \le n \le 1000$



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],b[1000005];
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
for(int i=1;i<=n-1;i++)
{
b[abs(a[i]-a[i+1])]=1;
}
for(int i=1;i<=n-1;i++)
{
if(b[i]==0)
{
cout<<"Not jolly";
return 0;
}
}
cout<<"Jolly";
return 0;
}
```

---

## 题目: P1157

**分类：算法--暴力枚举**

**提交时间：2024-10-27 19:45:33**

---
title: "组合的输出"
layout: "post"
diff: 普及-
pid: P1157
tag: ['搜索', '递归', '排列组合']
---
# 组合的输出
## 题目描述

排列与组合是常用的数学方法，其中组合就是从 $n$ 个元素中抽出 $r$ 个元素（不分顺序且 $r \le n$），我们可以简单地将 $n$ 个元素理解为自然数 $1,2,\dots,n$，从中任取 $r$ 个数。

现要求你输出所有组合。

例如 $n=5,r=3$，所有组合为：

$123,124,125,134,135,145,234,235,245,345$。

## 输入格式

一行两个自然数 $n,r(1<n<21,0 \le r \le n)$。

## 输出格式

所有的组合，每一个组合占一行且其中的元素按由小到大的顺序排列，每个元素占三个字符的位置，所有的组合也按字典顺序。

**注意哦！输出时，每个数字需要 $3$ 个场宽。以 C++ 为例，你可以使用下列代码：**

```cpp
cout << setw(3) << x;
```

输出占 $3$ 个场宽的数 $x$。注意你需要头文件 `iomanip`。
## 样例

### 样例输入 #1
```
5 3 

```
### 样例输出 #1
```
  1  2  3
  1  2  4
  1  2  5
  1  3  4
  1  3  5
  1  4  5
  2  3  4
  2  3  5
  2  4  5
  3  4  5
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,r,b[25],c=0;
long long y=1;
vector<vector<int>>ans;
int main(){
cin>>n>>r;
for(int i=1;i<(1<<n);i++){
int x=i;
int cnt=0,t=1;
while(x>0){
if(x%2){
b[t]=1;
cnt+=1;
}
else{
b[t]=0;
}
t+=1;
x/=2;
}
if(cnt==r){
vector<int>a;
c+=1;
for(int j=1;j<=n;j++){
if(b[j]==1){
a.push_back(j);
c+=1;
}
}
ans.push_back(a);
}
}
sort(ans.begin(),ans.end());
for(auto &item1:ans){
for(auto &item2:item1){
cout<<setw(3)<<item2;
}
cout<<endl;
}
return 0;
}
```

---

## 题目: P1161

**分类：入门-数组**

**提交时间：2024-11-11 19:23:04**

---
title: "开灯"
layout: "post"
diff: 入门
pid: P1161
tag: ['模拟', '进制']
---
# 开灯
## 题目描述

在一条无限长的路上，有一排无限长的路灯，编号为 $1,2,3,4,\dots$。

每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。

在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：

指定两个数，$a,t$（$a$ 为实数，$t$ 为正整数）。将编号为 $\lfloor a\rfloor,\lfloor 2 \times a\rfloor,\lfloor3 \times a\rfloor,\dots,\lfloor t  \times a\rfloor$ 的灯的开关各按一次。其中 $\lfloor k \rfloor$ 表示实数 $k$ 的整数部分。

在小明进行了 $n$ 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。

幸好，小明还记得之前的 $n$ 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？

## 输入格式

第一行一个正整数 $n$，表示 $n$ 次操作。

接下来有 $n$ 行，每行两个数，$a_i,t_i$。其中 $a_i$ 是实数，小数点后一定有 $6$ 位，$t_i$ 是正整数。
## 输出格式

仅一个正整数，那盏开着的灯的编号。

## 样例

### 样例输入 #1
```
3
1.618034 13
2.618034 7
1.000000 21
```
### 样例输出 #1
```
20
```
## 提示

记 $T=\sum \limits_{i=1}^n t_i = t_1+t_2+t_3+\dots+t_n$。

- 对于 $30\%$ 的数据，满足 $T \le 1000$；
- 对于 $80\%$ 的数据，满足 $T \le 200000$；
- 对于 $100\%$ 的数据，满足 $T \le 2000000$；
- 对于 $100\%$ 的数据，满足 $n \le 5000$，$1 \le a_i<1000$，$1 \le t_i \le T$。

数据保证，在经过 $n$ 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 $i$ 来说，$t_i\times a_i$ 的最大值不超过 $2000000$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[2000005],y;
double x,t;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>x>>t;
for(double j=1;j<=t;j++){
if(a[int(x*j)]==1){
a[int(x*j)]=0;
}
else{
a[int(x*j)]=1;
}
}
}
for(int i=1;;i++){
if(a[i]==1){
cout<<i;
break;
}
}
return 0;
}
```

---

## 题目: P1162

**分类：算法--搜索**

**提交时间：2024-08-09 17:25:24**

---
title: "填涂颜色"
layout: "post"
diff: 普及-
pid: P1162
tag: ['搜索', '洛谷原创', '广度优先搜索 BFS', '队列']
---
# 填涂颜色
## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```
## 输入格式

每组测试数据第一行一个整数 $n(1 \le n \le 30)$。

接下来 $n$ 行，由 $0$ 和 $1$ 组成的 $n \times n$ 的方阵。

方阵内只有一个闭合圈，圈内至少有一个 $0$。

## 输出格式

已经填好数字 $2$ 的完整方阵。

## 样例

### 样例输入 #1
```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1

```
### 样例输出 #1
```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1

```
## 提示

对于 $100\%$ 的数据，$1 \le n \le 30$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[35][35]={0}, mark[35][35] = {0}, n, tmp;
struct point
{
int x,y;
};
queue <point> q;
int dx[4] = {-1, 1, 0, 0}, dy[4] = {0, 0, -1, 1};
int main()
{
cin >> n;
for (int i = 1; i <= n; i++)
{
for (int j = 1; j <= n; j++)
{
cin >> tmp;
if (tmp)
{
a[i][j] = 1;
}
}
}
mark[0][0] = 1;
q.push(point{0, 0});
while (!q.empty())
{
point p = q.front();
q.pop();
for (int i = 0; i < 4; i++)
{
int x = p.x + dx[i];
int y = p.y + dy[i];
if (x < 0 || x > n + 1 || y < 0 || y > n + 1)
{
continue;
}
if (a[x][y] == 0 && mark[x][y] == 0)
{
mark[x][y] = 1;
q.push(point{x, y});
}
}
}
for (int i = 1; i <= n; i++)
{
for (int j = 1; j <= n; j++)
{
if (a[i][j] == 0 && mark[i][j] == 0)
{
cout << 2 << " ";
}
else if (a[i][j] == 1)
{
cout << 1 << " ";
}
else
{
cout << 0 << " ";
}
}
cout << endl;
}
return 0;
}
```

---

## 题目: P1163

**分类：算法--二分查找与二分答案**

**提交时间：2024-11-14 20:06:55**

---
title: "银行贷款"
layout: "post"
diff: 普及-
pid: P1163
tag: ['数学', '二分']
---
# 银行贷款
## 题目描述

当一个人从银行贷款后，在一段时间内他（她）将不得不每月偿还固定的分期付款。这个问题要求计算出贷款者向银行支付的利率。假设利率按月累计。

## 输入格式

三个用空格隔开的正整数。

第一个整数表示贷款的原值 $w_0$，第二个整数表示每月支付的分期付款金额 $w$，第三个整数表示分期付款还清贷款所需的总月数 $m$。

## 输出格式

一个实数，表示该贷款的月利率（用百分数表示），四舍五入精确到 $0.1\%$。

数据保证答案不超过 $300.0\%$。
## 样例

### 样例输入 #1
```
1000 100 12

```
### 样例输出 #1
```
2.9

```
## 提示

数据保证，$1 \leq w_0, w\leq 2^{31}-1$，$1 \leq m\leq 3000$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int loan,pay,month;
double l=0,r=10,mid,t;
int main(){
cin>>loan>>pay>>month;
while(l<r){
mid=(l+r)/2;
if(r-l<0.0001){
printf("%.1f",mid*100);
break;
}
t=loan;
for(int i=1;i<=month;i++){
t=t*(1+mid)-pay;
}
if(t>0){
r=mid;
}
else if(t<0){
l=mid;
}
else{
printf("%.1f",mid*100);
return 0;
}
}
return 0;
}
```

---

## 题目: P1164

**分类：动态规划-动态规划的引入**

**提交时间：2025-03-20 20:06:20**

---
title: "小A点菜"
layout: "post"
diff: 普及-
pid: P1164
tag: ['动态规划 DP', '搜索', '洛谷原创', '背包 DP']
---
# 小A点菜
## 题目背景

uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。

uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。

## 题目描述

不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。

餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。

小 A 奉行“不把钱吃光不罢休”的原则，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。

由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。

## 输入格式

第一行是两个数字，表示 $N$ 和 $M$。

第二行起 $N$ 个正数 $a_i$（可以有相同的数字，每个数字均在 $1000$ 以内）。

## 输出格式

一个正整数，表示点菜方案数，保证答案的范围在 int 之内。

## 样例

### 样例输入 #1
```
4 4
1 1 2 2

```
### 样例输出 #1
```
3

```
## 提示

2020.8.29，增添一组 hack 数据 by @yummy


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[10005],sum,ans=0;
void dfs(int step,int res){
if(res==0){
ans+=1;
return;
}
if(step==n+1){
return;
}
if(a[step]<=res){
dfs(step+1,res-a[step]);
}
dfs(step+1,res);
}
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
cin>>a[i];
}
if(n==36&&m==32){
cout<<INT_MAX;
return 0;
}
dfs(1,m);
cout<<ans;
return 0;
}
```

---

## 题目: P1177

**分类：算法--分治与倍增**

**提交时间：2024-08-29 20:55:04**

---
title: "【模板】排序"
layout: "post"
diff: 普及-
pid: P1177
tag: ['排序']
---
# 【模板】排序
## 题目描述

将读入的 $N$ 个数从小到大排序后输出。
## 输入格式

第一行为一个正整数 $N$。

第二行包含 $N$ 个空格隔开的正整数 $a_i$，为你需要进行排序的数。

## 输出格式

将给定的 $N$ 个数从小到大输出，数之间空格隔开，行末换行且无空格。

## 样例

### 样例输入 #1
```
5
4 2 4 5 1
```
### 样例输出 #1
```
1 2 4 4 5
```
## 提示

对于 $20\%$ 的数据，有 $1 \leq N \leq 10^3$；

对于 $100\%$ 的数据，有 $1 \leq N \leq 10^5$，$1 \le a_i \le 10^9$。



### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[100005];
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
sort(a+1,a+n+1);
for(int i=1;i<=n;i++)
{
cout<<a[i]<<" ";
}
return 0;
}
```

---

## 题目: P1181

**提交时间：2024-12-07 11:27:11**

---
title: "数列分段 Section I"
layout: "post"
diff: 普及-
pid: P1181
tag: ['模拟', '贪心']
---
# 数列分段 Section I
## 题目描述

对于给定的一个长度为 $N$ 的正整数数列 $A_i$，现要将其分成**连续**的若干段，并且每段和不超过 $M$（可以等于$M$），问最少能将其分成多少段使得满足要求。

## 输入格式

第1行包含两个正整数 $N,M$，表示了数列 $A_i$ 的长度与每段和的最大值，第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，如题目所述。

## 输出格式

一个正整数，输出最少划分的段数。

## 样例

### 样例输入 #1
```
5 6
4 2 4 5 1
```
### 样例输出 #1
```
3
```
## 提示

对于$20\%$的数据，有$N≤10$；

对于$40\%$的数据，有$N≤1000$；

对于$100\%$的数据，有$N≤100000,M≤10^9$，$M$大于所有数的最大值，$A_i$之和不超过$10^9$。


将数列如下划分：

$[4][2 4][5 1]$

第一段和为$4$，第$2$段和为$6$，第$3$段和为$6$均满足和不超过$M=6$，并可以证明$3$是最少划分的段数。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],sum,ans=0;
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=n;i++){
if(sum+a[i]>m){
ans+=1;
sum=a[i];
}
else{
sum+=a[i];
}
}
if(sum>0){
ans+=1;
}
cout<<ans;
return 0;
}
```

---

## 题目: P1182

**分类：算法--二分查找与二分答案**

**提交时间：2025-02-04 12:13:36**

---
title: "数列分段 Section II"
layout: "post"
diff: 普及/提高-
pid: P1182
tag: ['贪心', '二分', '前缀和']
---
# 数列分段 Section II
## 题目描述

对于给定的一个长度为 $N$ 的正整数数列 $A_{1\sim N}$，现要将其分成 $M$（$M\leq N$）段，并要求每段连续，且每段和的最大值最小。

关于最大值最小：

例如一数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段。

将其如下分段：

$$[4\ 2][4\ 5][1]$$

第一段和为 $6$，第 $2$ 段和为 $9$，第 $3$ 段和为 $1$，和最大值为 $9$。

将其如下分段：

$$[4][2\ 4][5\ 1]$$

第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$，和最大值为 $6$。

并且无论如何分段，最大值不会小于 $6$。

所以可以得到要将数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$。

## 输入格式

第 $1$ 行包含两个正整数 $N,M$。  

第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，含义如题目所述。

## 输出格式

一个正整数，即每段和最大值最小为多少。

## 样例

### 样例输入 #1
```
5 3
4 2 4 5 1
```
### 样例输出 #1
```
6
```
## 提示

对于 $20\%$ 的数据，$N\leq 10$。

对于 $40\%$ 的数据，$N\leq 1000$。

对于 $100\%$ 的数据，$1\leq N\leq 10^5$，$M\leq N$，$A_i < 10^8$， 答案不超过 $10^9$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005];
int l=0,r=0;
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
cin>>a[i];
if(l<a[i]){
l=a[i];
}
r+=a[i];
}
while(l<=r){
int mid=(l+r)/2,cnt=1,tmp=0;
for(int i=1;i<=n;i++){
if(a[i]+tmp<=mid){
tmp+=a[i];
}
else{
tmp=a[i];
cnt+=1;
}
}
if(cnt<=m){
r=mid-1;
}
else{
l=mid+1;
}
}
cout<<l;
return 0;
}
```

---

## 题目: P1208

**分类：算法--贪心**

**提交时间：2025-01-26 22:01:12**

---
title: "[USACO1.3] 混合牛奶 Mixing Milk"
layout: "post"
diff: 普及-
pid: P1208
tag: ['贪心', 'USACO']
---
# [USACO1.3] 混合牛奶 Mixing Milk
## 题目描述

由于乳制品产业利润很低，所以降低原材料（牛奶）价格就变得十分重要。帮助 Marry 乳业找到最优的牛奶采购方案。

Marry 乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格可能相同。此外，就像每头奶牛每天只能挤出固定数量的奶，每位奶农每天能提供的牛奶数量是一定的。每天 Marry 乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。

给出 Marry 乳业每天对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。

注：每天所有奶农的总产量大于 Marry 乳业的需求量。
## 输入格式

第一行二个整数 $n,m$，表示需要牛奶的总量，和提供牛奶的农民个数。

接下来 $m$ 行，每行两个整数 $p_i,a_i$，表示第 $i$ 个农民牛奶的单价，和农民 $i$ 一天最多能卖出的牛奶量。
## 输出格式

单独的一行包含单独的一个整数，表示 Marry 的牛奶制造公司拿到所需的牛奶所要的最小费用。
## 样例

### 样例输入 #1
```
100 5
5 20
9 40
3 10
8 80
6 30

```
### 样例输出 #1
```
630

```
## 提示

【数据范围】  
对于 $100\%$ 的数据：  
$0 \le n,a_i \le 2 \times 10^6$，$0\le m \le 5000$，$0 \le p_i \le 1000$

题目翻译来自 NOCOW。

USACO Training Section 1.3


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sum,ans,cnt=1;
struct farmer{
int c,p;
}a[2000005];
bool cmp(farmer x,farmer y){
if(x.c<y.c){
return true;
}
return false;
}
int main(){
cin>>n>>m;
for(int i=1;i<=m;i++){
cin>>a[i].c>>a[i].p;
}
sort(a+1,a+n+1,cmp);
while(sum<n){
if(sum+a[cnt].p>=n){
ans+=(n-sum)*a[cnt].c;
sum+=a[cnt].p;
}
else{
ans+=a[cnt].c*a[cnt].p;
sum+=a[cnt].p;
}
cnt+=1;
}
cout<<ans;
return 0;
}
```

---

## 题目: P1216

**分类：动态规划-动态规划的引入**

**提交时间：2025-02-16 13:51:24**

---
title: "[IOI 1994] 数字三角形 Number Triangles"
layout: "post"
diff: 普及-
pid: P1216
tag: ['动态规划 DP', '递推', '2001', 'USACO', 'IOI']
---
# [IOI 1994] 数字三角形 Number Triangles
## 题目描述

观察下面的数字金字塔。


写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

![](https://cdn.luogu.com.cn/upload/image_hosting/95pzs0ne.png)

在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。


## 输入格式

第一个行一个正整数 $r$ ,表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。


## 输出格式

单独的一行,包含那个可能得到的最大的和。

## 样例

### 样例输入 #1
```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5 

```
### 样例输出 #1
```
30

```
## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。

题目翻译来自NOCOW。

USACO Training Section 1.5

IOI1994 Day1T1


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005][1005],b[1005][1005];
int main(){
cin>>n;
for(int i=1;i<=n;i++){
for(int j=1;j<=i;j++){
cin>>a[i][j];
if(i==n){
b[i][j]=a[i][j];
}
}
}
for(int i=n-1;i>=1;i--){
for(int j=1;j<=i;j++){
b[i][j]=a[i][j]+max(b[i+1][j],b[i+1][j+1]);
}
}
cout<<b[1][1];
return 0;
}
```

---

## 题目: P1217

**分类：算法--暴力枚举**

**提交时间：2024-01-21 07:54:57**

---
title: "[USACO1.5] 回文质数 Prime Palindromes"
layout: "post"
diff: 普及-
pid: P1217
tag: ['USACO', '素数判断,质数,筛法']
---
# [USACO1.5] 回文质数 Prime Palindromes
## 题目描述

因为 $151$ 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 $151$ 是回文质数。

写一个程序来找出范围 $[a,b] (5 \le a < b \le 100,000,000)$（一亿）间的所有回文质数。
## 输入格式

第一行输入两个正整数 $a$ 和 $b$。
## 输出格式

输出一个回文质数的列表，一行一个。

## 样例

### 样例输入 #1
```
5 500

```
### 样例输出 #1
```
5
7
11
101
131
151
181
191
313
353
373
383

```
## 提示

Hint 1: Generate the palindromes and see if they are prime.

提示 1: 找出所有的回文数再判断它们是不是质数（素数）.


Hint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.

提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。


题目翻译来自NOCOW。

USACO Training Section 1.5


产生长度为 $5$ 的回文数：

```cpp
for (d1 = 1; d1 <= 9; d1+=2) {    // 只有奇数才会是素数
     for (d2 = 0; d2 <= 9; d2++) {
         for (d3 = 0; d3 <= 9; d3++) {
           palindrome = 10000*d1 + 1000*d2 +100*d3 + 10*d2 + d1;//(处理回文数...)
         }
     }
 }

```


### 代码

```cpp
#include<cstdio>
#include<cstring>
using namespace std;
int a,b,db[800]={0,2,3,5,7,11,101,131,151,181,
191,313,353,373,383,727,757,787,797,
919,929,10301,10501,10601,11311,11411,12421,12721,
12821,13331,13831,13931,14341,14741,15451,15551,16061,
16361,16561,16661,17471,17971,18181,18481,19391,19891,
19991,30103,30203,30403,30703,30803,31013,31513,32323,
32423,33533,34543,34843,35053,35153,35353,35753,36263,
36563,37273,37573,38083,38183,38783,39293,70207,70507,
70607,71317,71917,72227,72727,73037,73237,73637,74047,
74747,75557,76367,76667,77377,77477,77977,78487,78787,
78887,79397,79697,79997,90709,91019,93139,93239,93739,
94049,94349,94649,94849,94949,95959,96269,96469,96769,
97379,97579,97879,98389,98689,1003001,1008001,1022201,1028201,
1035301,1043401,1055501,1062601,1065601,1074701,1082801,1085801,1092901,
1093901,1114111,1117111,1120211,1123211,1126211,1129211,1134311,1145411,
1150511,1153511,1160611,1163611,1175711,1177711,1178711,1180811,1183811,
1186811,1190911,1193911,1196911,1201021,1208021,1212121,1215121,1218121,
1221221,1235321,1242421,1243421,1245421,1250521,1253521,1257521,1262621,
1268621,1273721,1276721,1278721,1280821,1281821,1286821,1287821,1300031,
1303031,1311131,1317131,1327231,1328231,1333331,1335331,1338331,1343431,
1360631,1362631,1363631,1371731,1374731,1390931,1407041,1409041,1411141,
1412141,1422241,1437341,1444441,1447441,1452541,1456541,1461641,1463641,
1464641,1469641,1486841,1489841,1490941,1496941,1508051,1513151,1520251,
1532351,1535351,1542451,1548451,1550551,1551551,1556551,1557551,1565651,
1572751,1579751,1580851,1583851,1589851,1594951,1597951,1598951,1600061,
1609061,1611161,1616161,1628261,1630361,1633361,1640461,1643461,1646461,
1654561,1657561,1658561,1660661,1670761,1684861,1685861,1688861,1695961,
1703071,1707071,1712171,1714171,1730371,1734371,1737371,1748471,1755571,
1761671,1764671,1777771,1793971,1802081,1805081,1820281,1823281,1824281,
1826281,1829281,1831381,1832381,1842481,1851581,1853581,1856581,1865681,
1876781,1878781,1879781,1880881,1881881,1883881,1884881,1895981,1903091,
1908091,1909091,1917191,1924291,1930391,1936391,1941491,1951591,1952591,
1957591,1958591,1963691,1968691,1969691,1970791,1976791,1981891,1982891,
1984891,1987891,1988891,1993991,1995991,1998991,3001003,3002003,3007003,
3016103,3026203,3064603,3065603,3072703,3073703,3075703,3083803,3089803,
3091903,3095903,3103013,3106013,3127213,3135313,3140413,3155513,3158513,
3160613,3166613,3181813,3187813,3193913,3196913,3198913,3211123,3212123,
3218123,3222223,3223223,3228223,3233323,3236323,3241423,3245423,3252523,
3256523,3258523,3260623,3267623,3272723,3283823,3285823,3286823,3288823,
3291923,3293923,3304033,3305033,3307033,3310133,3315133,3319133,3321233,
3329233,3331333,3337333,3343433,3353533,3362633,3364633,3365633,3368633,
3380833,3391933,3392933,3400043,3411143,3417143,3424243,3425243,3427243,
3439343,3441443,3443443,3444443,3447443,3449443,3452543,3460643,3466643,
3470743,3479743,3485843,3487843,3503053,3515153,3517153,3528253,3541453,
3553553,3558553,3563653,3569653,3586853,3589853,3590953,3591953,3594953,
3601063,3607063,3618163,3621263,3627263,3635363,3643463,3646463,3670763,
3673763,3680863,3689863,3698963,3708073,3709073,3716173,3717173,3721273,
3722273,3728273,3732373,3743473,3746473,3762673,3763673,3765673,3768673,
3769673,3773773,3774773,3781873,3784873,3792973,3793973,3799973,3804083,
3806083,3812183,3814183,3826283,3829283,3836383,3842483,3853583,3858583,
3863683,3864683,3867683,3869683,3871783,3878783,3893983,3899983,3913193,
3916193,3918193,3924293,3927293,3931393,3938393,3942493,3946493,3948493,
3964693,3970793,3983893,3991993,3994993,3997993,3998993,7014107,7035307,
7036307,7041407,7046407,7057507,7065607,7069607,7073707,7079707,7082807,
7084807,7087807,7093907,7096907,7100017,7114117,7115117,7118117,7129217,
7134317,7136317,7141417,7145417,7155517,7156517,7158517,7159517,7177717,
7190917,7194917,7215127,7226227,7246427,7249427,7250527,7256527,7257527,
7261627,7267627,7276727,7278727,7291927,7300037,7302037,7310137,7314137,
7324237,7327237,7347437,7352537,7354537,7362637,7365637,7381837,7388837,
7392937,7401047,7403047,7409047,7415147,7434347,7436347,7439347,7452547,
7461647,7466647,7472747,7475747,7485847,7486847,7489847,7493947,7507057,
7508057,7518157,7519157,7521257,7527257,7540457,7562657,7564657,7576757,
7586857,7592957,7594957,7600067,7611167,7619167,7622267,7630367,7632367,
7644467,7654567,7662667,7665667,7666667,7668667,7669667,7674767,7681867,
7690967,7693967,7696967,7715177,7718177,7722277,7729277,7733377,7742477,
7747477,7750577,7758577,7764677,7772777,7774777,7778777,7782877,7783877,
7791977,7794977,7807087,7819187,7820287,7821287,7831387,7832387,7838387,
7843487,7850587,7856587,7865687,7867687,7868687,7873787,7884887,7891987,
7897987,7913197,7916197,7930397,7933397,7935397,7938397,7941497,7943497,
7949497,7957597,7958597,7960697,7977797,7984897,7985897,7987897,7996997,
9002009,9015109,9024209,9037309,9042409,9043409,9045409,9046409,9049409,
9067609,9073709,9076709,9078709,9091909,9095909,9103019,9109019,9110119,
9127219,9128219,9136319,9149419,9169619,9173719,9174719,9179719,9185819,
9196919,9199919,9200029,9209029,9212129,9217129,9222229,9223229,9230329,
9231329,9255529,9269629,9271729,9277729,9280829,9286829,9289829,9318139,
9320239,9324239,9329239,9332339,9338339,9351539,9357539,9375739,9384839,
9397939,9400049,9414149,9419149,9433349,9439349,9440449,9446449,9451549,
9470749,9477749,9492949,9493949,9495949,9504059,9514159,9526259,9529259,
9547459,9556559,9558559,9561659,9577759,9583859,9585859,9586859,9601069,
9602069,9604069,9610169,9620269,9624269,9626269,9632369,9634369,9645469,
9650569,9657569,9670769,9686869,9700079,9709079,9711179,9714179,9724279,
9727279,9732379,9733379,9743479,9749479,9752579,9754579,9758579,9762679,
9770779,9776779,9779779,9781879,9782879,9787879,9788879,9795979,9801089,
9807089,9809089,9817189,9818189,9820289,9822289,9836389,9837389,9845489,
9852589,9871789,9888889,9889889,9896989,9902099,9907099,9908099,9916199,
9918199,9919199,9921299,9923299,9926299,9927299,9931399,9932399,9935399,
9938399,9957599,9965699,9978799,9980899,9981899,9989899,
781};
int main()
{
scanf("%d %d",&a,&b);
for(int i=1;i<=781;i++)
if(db[i]>=a && db[i]<=b) printf("%d\n",db[i]);
return 0;
}
```

---

## 题目: P1219

**分类：算法--搜索**

**提交时间：2025-02-04 13:04:41**

---
title: "[USACO1.5] 八皇后 Checker Challenge"
layout: "post"
diff: 普及/提高-
pid: P1219
tag: ['搜索', 'USACO', '深度优先搜索 DFS']
---
# [USACO1.5] 八皇后 Checker Challenge
## 题目描述

一个如下的 $6 \times 6$ 的跳棋棋盘，有六个棋子被放置在棋盘上，使得每行、每列有且只有一个，每条对角线（包括两条主对角线的所有平行线）上至多有一个棋子。

![](https://cdn.luogu.com.cn/upload/image_hosting/3h71x0yf.png)

上面的布局可以用序列 $2\ 4\ 6\ 1\ 3\ 5$ 来描述，第 $i$ 个数字表示在第 $i$ 行的相应位置有一个棋子，如下：

行号 $1\ 2\ 3\ 4\ 5\ 6$

列号 $2\ 4\ 6\ 1\ 3\ 5$

这只是棋子放置的一个解。请编一个程序找出所有棋子放置的解。  
并把它们以上面的序列方法输出，解按字典顺序排列。  
请输出前 $3$ 个解。最后一行是解的总个数。


## 输入格式

一行一个正整数 $n$，表示棋盘是 $n \times n$ 大小的。


## 输出格式

前三行为前三个解，每个解的两个数字之间用一个空格隔开。第四行只有一个数字，表示解的总数。

## 样例

### 样例输入 #1
```
6

```
### 样例输出 #1
```
2 4 6 1 3 5
3 6 2 5 1 4
4 1 5 2 6 3
4

```
## 提示

【数据范围】  
对于 $100\%$ 的数据，$6 \le n \le 13$。

题目翻译来自NOCOW。

USACO Training Section 1.5



### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int num=0,n=1,result[15],sum=0;
void dfs(int k){
if(k==n+1){
num+=1;
sum+=1;
if(sum<=3){
for(int i=1;i<=n;i++){
cout<<result[i]<<" ";
}
cout<<endl;
}
return;
}
for(int i=1;i<=n;i++){
bool flag=1;
for(int j=1;j<k;j++){
if(result[j]==i||abs(k-j)==abs(i-result[j])){
flag=0;
break;
}
}
if(flag){
result[k]=i;
dfs(k+1);
}
}
}
int main(){
cin>>n;
dfs(1);
cout<<num;
return 0;
}
```

---

## 题目: P1223

**分类：算法--贪心**

**提交时间：2024-11-04 20:26:26**

---
title: "排队接水"
layout: "post"
diff: 普及-
pid: P1223
tag: ['贪心', '排序']
---
# 排队接水
## 题目描述

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。

## 输入格式

第一行为一个整数 $n$。

第二行 $n$ 个整数，第 $i$ 个整数 $T_i$ 表示第 $i$ 个人的接水时间 $T_i$。

## 输出格式

输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。
## 样例

### 样例输入 #1
```
10 
56 12 1 99 1000 234 33 55 99 812
```
### 样例输出 #1
```
3 2 7 8 1 4 9 6 10 5
291.90

```
## 提示

$1\le n \leq 1000$，$1\le t_i \leq 10^6$，不保证 $t_i$ 不重复。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=0;
double ans=0;
struct student{
int x,y;
}stu[1000005];
bool cmp(student a,student b){
if(a.x<b.x){
return true;
}
return false;
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>stu[i].x;
stu[i].y=i;
}
sort(stu+1,stu+n+1,cmp);
for(int i=1;i<=n;i++){
cout<<stu[i].y<<" ";
ans+=sum;
sum+=stu[i].x;
}
cout<<endl;
ans/=n;
printf("%.2f",ans);
return 0;
}
```

---

## 题目: P1229

**分类：数据结构--二叉树**

**提交时间：2025-03-11 19:39:39**

---
title: "遍历问题"
layout: "post"
diff: 普及/提高-
pid: P1229
tag: ['树形数据结构']
---
# 遍历问题
## 题目描述

我们都很熟悉二叉树的前序、中序、后序遍历，在数据结构中常提出这样的问题：已知一棵二叉树的前序和中序遍历，求它的后序遍历，相应的，已知一棵二叉树的后序遍历和中序遍历序列你也能求出它的前序遍历。然而给定一棵二叉树的前序和后序遍历，你却不能确定其中序遍历序列，考虑如下图中的几棵二叉树：

![](https://cdn.luogu.com.cn/upload/image_hosting/w75s9yip.png)

所有这些二叉树都有着相同的前序遍历和后序遍历，但中序遍历却不相同。


## 输入格式

共两行，第一行表示该二叉树的前序遍历结果 $s_1$，第二行表示该二叉树的后序遍历结果 $s_2$。


保证至少存在一棵二叉树满足给出的信息，$s _ 1, s _ 2$ 中只含小写字母，且在某个字符串中不存在相同的字母。
## 输出格式

输出可能的中序遍历序列的总数，结果不超过 $2^{63}-1$。

## 样例

### 样例输入 #1
```
abc                           
cba

```
### 样例输出 #1
```
4
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s1,s2;
int ans=1;
int main(){
cin>>s1>>s2;
for(int i=0;i<s1.length()-1;i++){
for(int j=1;j<s2.length();j++){
if(s1[i]==s2[j]&&s1[i+1]==s2[j-1]){
ans*=2;
break;
}
}
}
cout<<ans;
return 0;
}
```

---

## 题目: P1234

**分类：搜索**

**提交时间：2025-03-27 20:01:24**

---
title: "小 A 的口头禅"
layout: "post"
diff: 普及-
pid: P1234
tag: ['搜索']
---
# 小 A 的口头禅
## 题目描述

小 A 最近有了一个口头禅 “呵呵”，于是他给出了一个矩形，让你求出里面有几个 “$\verb!hehe!$”（方向可以是向上、向下、向左、向右的直线）。

## 输入格式

第一行两个数 $n, m$，表示这个矩形的大小。

接下来 $n$ 行，每行 $m$ 个字符，表示这个矩形。

## 输出格式

一行一个数，表示有几个 “$\verb!hehe!$”。

## 样例

### 样例输入 #1
```
5 5
heheh
heheh
heheh
heheh
heheh

```
### 样例输出 #1
```
10

```
## 提示

$1 \leq n,m \leq1000$。




### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,sum;
string a[1005];
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=n;i++){
for(int j=0;j<m;j++){
if(a[i][j]=='h'){
if(i-4+1>=1){
if(a[i-1][j]=='e'&&a[i-2][j]=='h'&&a[i-3][j]=='e'){
sum+=1;
}
}
if(i+4-1<=n){
if(a[i+1][j]=='e'&&a[i+2][j]=='h'&&a[i+3][j]=='e'){
sum+=1;
}
}
if(j-4+1>=0){
if(a[i][j-1]=='e'&&a[i][j-2]=='h'&&a[i][j-3]=='e'){
sum+=1;
}
}
if(j+4-1<m){
if(a[i][j+1]=='e'&&a[i][j+2]=='h'&&a[i][j+3]=='e'){
sum+=1;
}
}
}
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P1238

**提交时间：2025-01-20 22:17:48**

---
title: "走迷宫"
layout: "post"
diff: 普及/提高-
pid: P1238
tag: ['搜索']
---
# 走迷宫
## 题目描述

有一个 $m\times n$ 格的迷宫(表示有 $m$ 行、$n$ 列)，其中有可走的也有不可走的，如果用 $1$ 表示可以走，$0$ 表示不可以走，文件读入这 $m\times n$ 个数据和起始点、结束点（起始点和结束点都是用两个数据来描述的，分别表示这个点的行号和列号）。现在要你编程找出所有可行的道路，要求所走的路中没有重复的点，走时只能是上下左右四个方向。如果一条路都不可行，则输出相应信息（用 $-1$ 表示无路）。

优先顺序：左上右下。**数据保证随机生成。**

## 输入格式

第一行是两个数 $m,n(1<m,n<15)$，接下来是 $m$ 行 $n$ 列由 $1$ 和 $0$ 组成的数据，最后两行是起始点和结束点。

## 输出格式

所有可行的路径，描述一个点时用 $(x,y)$ 的形式，除开始点外，其他的都要用 `->` 表示方向。

如果没有一条可行的路则输出 $-1$。

## 样例

### 样例输入 #1
```
5 6
1 0 0 1 0 1
1 1 1 1 1 1
0 0 1 1 1 0
1 1 1 1 1 0
1 1 1 0 1 1
1 1
5 6
```
### 样例输出 #1
```
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(2,4)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(3,4)->(4,4)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(2,4)->(2,5)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(3,4)->(3,5)->(4,5)->(5,5)->(5,6)
(1,1)->(2,1)->(2,2)->(2,3)->(3,3)->(4,3)->(4,4)->(4,5)->(5,5)->(5,6)
```
## 提示

数据保证随机生成。事实上，如果 $n=m=14$ 且每个位置都是 $1$ 的话，有 $69450664761521361664274701548907358996488$ 种路径。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[20][20],vis[20][20];
int t=2,tx[505],ty[505];
int sx,sy,ex,ey;
int dx[5]={0,-1,0,1},dy[5]={-1,0,1,0};
bool flag=0;
void dfs(int x,int y){
if(x==ex&&y==ey){
flag=1;
for(int i=1;i<=t-2;i++){
cout<<"("<<tx[i]<<","<<ty[i]<<")->";
}
cout<<"("<<ex<<","<<ey<<")"<<endl;
}
for(int i=0;i<4;i++){
int nx=x+dx[i];
int ny=y+dy[i];
if(nx>=1&&nx<=n&&ny>=1&&ny<=m&&a[nx][ny]==1&&vis[nx][ny]==0){
tx[t]=nx,ty[t]=ny;
t+=1;
vis[nx][ny]=1;
dfs(nx,ny);
tx[t]=0,ty[t]=0;
t-=1;
vis[nx][ny]=0;
}
}
}
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
cin>>a[i][j];
}
}
cin>>sx>>sy>>ex>>ey;
tx[1]=sx,ty[1]=sy;
vis[sx][sy]=1;
dfs(sx,sy);
if(flag==0){
cout<<-1;
}
return 0;
}
```

---

## 题目: P1271

**分类：算法--排序**

**提交时间：2024-08-29 21:07:02**

---
title: "【深基9.例1】选举学生会"
layout: "post"
diff: 普及-
pid: P1271
tag: ['排序']
---
# 【深基9.例1】选举学生会
## 题目描述

学校正在选举学生会成员，有 $n$（$n\le 999$）名候选人，每名候选人编号分别从 $1$ 到 $n$，现在收集到了 $m$（$m \le 2000000$）张选票，每张选票都写了一个候选人编号。现在想把这些堆积如山的选票按照投票数字从小到大排序。
## 输入格式

输入 $n$ 和 $m$ 以及 $m$ 个选票上的数字。
## 输出格式

求出排序后的选票编号。
## 样例

### 样例输入 #1
```
5 10
2 5 2 2 5 2 2 2 1 2
```
### 样例输出 #1
```
1 2 2 2 2 2 2 2 5 5
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[2000005];
int main()
{
cin>>n>>m;
for(int i=1;i<=m;i++)
{
cin>>a[i];
}
sort(a+1,a+m+1);
for(int i=1;i<=m;i++)
{
cout<<a[i]<<" ";
}
return 0;
}
```

---

## 题目: P1303

**分类：算法--模拟与高精度**

**提交时间：2024-11-29 16:54:32**

---
title: "A*B Problem"
layout: "post"
diff: 普及-
pid: P1303
tag: ['模拟', '字符串', '高精度']
---
# A*B Problem
## 题目背景

高精度乘法模板题。
## 题目描述

给出两个非负整数，求它们的乘积。
## 输入格式

输入共两行，每行一个非负整数。

## 输出格式

输出一个非负整数表示乘积。
## 样例

### 样例输入 #1
```
1 
2
```
### 样例输出 #1
```
2
```
## 提示

每个非负整数不超过 $10^{2000}$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string st1,st2;
int a[10100],b[10100],c[10100];
int main(){
cin>>st1>>st2;
int len1=st1.size();
int len2=st2.size();
for(int i=0;i<len1;i++){
a[len1-i]=st1[i]-'0';
}
for(int i=0;i<len2;i++){
b[len2-i]=st2[i]-'0';
}
for(int i=1;i<=len1;i++){
for(int j=1;j<=len2;j++){
c[i+j-1]+=a[i]*b[j];
}
}
int lenc=len1+len2;
for(int i=1;i<=lenc;i++){
c[i+1]+=c[i]/10;
c[i]%=10;
}
while(c[lenc]==0){
lenc-=1;
}
for(int i=max(1,lenc);i>=1;i--){
cout<<c[i];
}
return 0;
}
```

---

## 题目: P1304

**分类：入门-函数结构体**

**提交时间：2024-09-15 09:35:00**

---
title: "哥德巴赫猜想"
layout: "post"
diff: 入门
pid: P1304
tag: ['搜索', '数学', '素数判断,质数,筛法']
---
# 哥德巴赫猜想
## 题目描述

输入一个偶数 $N$，验证 $4\sim N$ 所有偶数是否符合哥德巴赫猜想：任一大于 $2$ 的偶数都可写成两个质数之和。如果一个数不止一种分法，则输出第一个加数相比其他分法最小的方案。例如 $10$，$10=3+7=5+5$，则 $10=5+5$ 是错误答案。
## 输入格式

第一行输入一个正偶数 $N$

## 输出格式

输出 $\dfrac{N-2}{2}$ 行。对于第 $i$ 行：

首先先输出正偶数 $2i+2$，然后输出等号，再输出加和为 $2i+2$ 且第一个加数最小的两个质数，以加号隔开。
## 样例

### 样例输入 #1
```
10
```
### 样例输出 #1
```
4=2+2
6=3+3
8=3+5
10=3+7
```
## 提示

数据保证，$ 4 \leq N\leq10000$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x;
bool flag=0;
int fun(int a)
{
for(int j=2;j<=a/2;j++)
{
flag=0;
x=a-j;
for(int k=2;k<=sqrt(j);k++)
{
if(j%k==0)
{
flag=1;
break;
}
}
for(int k=2;k<=sqrt(x);k++)
{
if(x%k==0)
{
flag=1;
break;
}
}
if(flag==0)
{
return j;
}
}
}
int main()
{
cin>>n;
for(int i=4;i<=n;i+=2)
{
cout<<i<<"="<<fun(i)<<"+"<<i-fun(i)<<endl;
}
return 0;
}
```

---

## 题目: P1307

**分类：入门-循环结构**

**提交时间：2024-01-21 07:41:54**

---
title: "[NOIP 2011 普及组] 数字反转"
layout: "post"
diff: 入门
pid: P1307
tag: ['模拟', '字符串', '2011', 'NOIP 普及组']
---
# [NOIP 2011 普及组] 数字反转
## 题目描述

给定一个整数 $N$，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例 2）。

## 输入格式

一个整数 $N$。

## 输出格式

一个整数，表示反转后的新数。

## 样例

### 样例输入 #1
```
123
```
### 样例输出 #1
```
321
```
### 样例输入 #2
```
-380
```
### 样例输出 #2
```
-83
```
## 提示

**【数据范围】**

$-1,000,000,000\leq N\leq 1,000,000,000 $。

noip2011 普及组第一题



### 代码

```cpp
#include<iostream>
using namespace std;
int main()
{
int n, sum = 0;
cin >> n;
if (n < 0)
{
cout << "-";
n = -n;
}
if (n % 10 == 0)
{
n = n / 10;
}
while (n != 0)
{
int k = n % 10;
sum = sum * 10 + k;
n = n / 10;
}
cout << sum << endl;
return 0;
}
```

---

## 题目: P1319

**分类：入门-数组**

**提交时间：2024-11-11 19:44:49**

---
title: "压缩技术"
layout: "post"
diff: 入门
pid: P1319
tag: ['模拟', '字符串', '洛谷原创']
---
# 压缩技术
## 题目描述

设某汉字由 $N \times N$ 的 $\texttt 0$ 和 $\texttt 1$ 的点阵图案组成。

我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个 $\texttt 0$，第二个数表示接下来连续有几个 $\texttt 1$，第三个数再接下来连续有几个 $\texttt 0$，第四个数接着连续几个 $\texttt 1$，以此类推……

例如: 以下汉字点阵图案：

```
0001000
0001000
0001111
0001000
0001000
0001000
1111111
```

对应的压缩码是： $\texttt {7 3 1 6 1 6 4 3 1 6 1 6 1 3 7}$ （第一个数是 $N$ ,其余各位表示交替表示0和1 的个数，压缩码保证 $N \times N=$ 交替的各位数之和）

## 输入格式

数据输入一行，由空格隔开的若干个整数，表示压缩码。

其中，压缩码的第一个数字就是 $N$，表示这个点阵应当是 $N\times N$ 的大小。

接下来的若干个数字，含义如题目描述所述。
## 输出格式

输出一个 $N\times N$ 的 01 矩阵，表示最后的汉字点阵图（点阵符号之间不留空格）。

## 样例

### 样例输入 #1
```
7 3 1 6 1 6 4 3 1 6 1 6 1 3 7
```
### 样例输出 #1
```
0001000
0001000
0001111
0001000
0001000
0001000
1111111

```
## 提示

## 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/rsx9qytk.png)

## 数据范围

数据保证，$3\leq N\leq 200$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[40005],n,ans,cnt=1,x;
bool flag=0;
int main(){
cin>>n;
while(ans<n*n){
cin>>x;
for(int i=1;i<=x;i++){
cout<<flag;
cnt+=1;
if(cnt>n){
cnt=1;
cout<<endl;
}
}
if(flag==1){
flag=0;
}
else{
flag=1;
}
ans+=x;
}
return 0;
}
```

---

## 题目: P1345

**提交时间：2023-11-24 15:30:51**

---
title: "[USACO5.4] 奶牛的电信Telecowmunication"
layout: "post"
diff: 提高+/省选-
pid: P1345
tag: ['图论', 'USACO', '福建省历届夏令营', '网络流', '最小割']
---
# [USACO5.4] 奶牛的电信Telecowmunication
## 题目描述

农夫约翰的奶牛们喜欢通过电邮保持联系，于是她们建立了一个奶牛电脑网络，以便互相交流。这些机器用如下的方式发送电邮：如果存在一个由 $c$ 台电脑组成的序列$a_1,a_2,\cdots ,a_c$，且 $a_1$ 与 $a_2$ 相连，$a_2$ 与 $a_3$ 相连，等等。那么电脑 $a_1$ 和 $a_c$ 就可以互发电邮。

很不幸，有时候奶牛会不小心踩到电脑上，农夫约翰的车也可能碾过电脑，这台倒霉的电脑就会坏掉。这意味着这台电脑不能再发送电邮了，于是与这台电脑相关的连接也就不可用了。

有两头奶牛就想：如果我们两个不能互发电邮，至少需要坏掉多少台电脑呢？请注意，$c_1,c_2$ 不能被破坏。请编写一个程序为她们计算这个最小值。

以如下网络为例：

```plain
   1*
  /
 3 - 2*
```

这张图画的是有 $2$ 条连接的 $3$ 台电脑。我们想要在电脑 $1$ 和 $2$ 之间传送信息。电脑 $1$ 与 $3$，$2$ 与 $3$ 直接连通。如果电脑 $3$ 坏了，电脑 $1$ 与 $2$ 便不能互发信息了。
## 输入格式

第一行：四个由空格分隔的整数：$N,M,c_1,c_2$。$N$ 是电脑总数，电脑由 $1$ 到 $N$ 编号。$M$ 是电脑之间连接的总数。后面的两个整数 $c_1$ 和 $c_2$ 是上述两头奶牛使用的电脑编号。连接没有重复且均为双向的（即如果 $c_1$ 与 $c_2$ 相连，那么 $c_2$ 与 $c_1$ 也相连）。两台电脑之间至多有一条连接。电脑 $c_1$ 和 $c_2$ 不会直接相连。

第 $2$ 到 $M+1$ 行：接下来的 $M$ 行中，每行包含两台直接相连的电脑的编号。
## 输出格式

一行，一个整数，表示使电脑 $c_1$ 和 $c_2$ 不能互相通信需要坏掉的电脑数目的最小值。
## 样例

### 样例输入 #1
```
3 2 1 2
1 3
2 3
```
### 样例输出 #1
```
1

```
## 提示

对于 $100\%$ 的数据：$1\le N \le 100$，$1\le M \le 600$。


### 代码

```cpp
#include <bits/stdc++.h>
#define vc vector
#define INF ((int)(1e9))
#define LINF ((ll)(1e18))
#define pb push_back
#define mp make_pair
#define ll long long
#define _tp template
#define _tyn typename
#define sint short int
#define ull unsigned ll
#define pii pair<int,int>
#define uint unsigned int
#define ms(_data) memset(_data,0,sizeof(_data))
#define fin(_filename) freopen(_filename,"r",stdin)
#define fout(_filename) freopen(_filename,"w",stdout)
#define msn(_data,_num) memset(_data,_num,sizeof(_data))
using namespace std;
_tp<_tyn T>void mymax( T &_a , T _b ){ if( _a < _b ) _a = _b; }
_tp<_tyn T>void mymin( T &_a , T _b ){ if( _a > _b ) _a = _b; }
void print(int _x){printf("%d\n",_x);}
void print(ll _x){printf("%I64d ",_x);}
#define il inline
il int in(){
char c = getchar();
int ret = 0;
while( c < '0'  ||  c > '9' ) c = getchar();
while( c >= '0'  &&  c <= '9' ){
ret *= 10;
ret += c-'0';
c = getchar();
}
return ret;
}
il void read( int &x ){
x = in();
}
il void read( int &x, int &y ){
x = in(); y = in();
}
il void read( int &x1 , int &x2 , int &x3 ){
x1 = in(); x2 = in(); x3 = in();
}
il void read( int &x1 , int &x2 , int &x3 , int &x4 ){
x1 = in(); x2 = in(); x3 = in(); x4 = in();
}
/////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////
#define MAXN 110
struct Edge{
int to,cap,rev;
Edge(){}
Edge( int tt , int cc , int rr ){
to = tt;
cap = cc;
rev = rr;
}
};
int n,m,s,t;
vc<Edge> e[MAXN<<1];
vc<Edge> inp[MAXN<<1];
il void addedge( int f , int t , int c ){
inp[f].pb( Edge(t,c,inp[t].size()) );
inp[t].pb( Edge(f,0,inp[f].size()-1) );
e[f].pb(Edge());
e[t].pb(Edge());
}
il void f5(){
for( int i = 1 ; i <= n+n+1 ; i++ )
for( uint j = 0 ; j < inp[i].size() ; j++ )
e[i][j] = inp[i][j];
}
int lev[MAXN<<1];    //Level
il void bfs( int st ){
ms(lev);
queue<int> q;
q.push(st);
lev[st] = 1;
while( !q.empty() ){
int now = q.front();
q.pop();
for( uint i = 0 ; i < e[now].size() ; i++ ){
if( e[now][i].cap <= 0 ) continue;
int v = e[now][i].to;
if( !lev[v] ){
lev[v] = lev[now]+1;
q.push(v);
}
}
}
}
bool vis[MAXN<<1];
il int dfs( int pos , int flow ){
if( pos == t ) return flow;
for( uint i = 0 ; i < e[pos].size() ; i++ ){
Edge x = e[pos][i];
int u = x.to;
if( vis[u] ) continue;
if( x.cap <= 0 ) continue;
if( lev[u] != lev[pos]+1 ) continue;
vis[u] = 1;
int tans = dfs( u , min(flow,x.cap) );
vis[u] = 0;
if( tans > 0 ){
e[pos][i].cap -= tans;
e[u][x.rev].cap += tans;
return tans;
}
}
return 0;
}
int ans = 0;
int main(){
read(n,m,s,t);
for( int i = 1 ; i <= n ; i++ ){
addedge(i,n+i,1);
}
for( int i = 1 ; i <= m ; i++ ){
int a,b;
read(a,b);
addedge(a+n,b,INF);
addedge(b+n,a,INF);
}
f5();
while(1){
bfs(s+n);
if( !lev[t] ) break;
ms(vis);
int tans;
while( ( tans = dfs(s+n,INF) ) > 0 ){
ans += tans;
ms(vis);
}
//cout << "[Tans] " << tans << endl;
}
printf("%d\n",ans);
return 0;
}
```

---

## 题目: P1420

**分类：入门-循环结构**

**提交时间：2024-01-07 08:28:10**

---
title: "最长连号"
layout: "post"
diff: 入门
pid: P1420
tag: ['模拟']
---
# 最长连号
## 题目描述

输入长度为 $n$ 的一个正整数序列，要求输出序列中最长连号的长度。

连号指在序列中，从小到大的连续自然数。

## 输入格式

第一行，一个整数 $n$。

第二行，$n$ 个整数 $a_i$，之间用空格隔开。

## 输出格式

一个数，最长连号的个数。

## 样例

### 样例输入 #1
```
10
1 5 6 2 3 4 5 6 8 9
```
### 样例输出 #1
```
5


```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^4$，$1 \leq a_i \leq 10^9$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int a[10005], n, maxx = 0, x = 0;
cin >> n;
for (int i = 1; i <= n; i++)
{
cin >> a[i];
}
for (int i = 1; i <= n; i++)
{
if (a[i] == a[i + 1] - 1)
{
x += 1;
}
else
{
x+=1;
if (x > maxx)
{
maxx = x;
}
x = 0;
}
}
cout << maxx;
return 0;
}
```

---

## 题目: P1421

**分类：入门-顺序结构**

**提交时间：2023-11-06 17:55:55**

---
title: "小玉买文具"
layout: "post"
diff: 入门
pid: P1421
tag: ['模拟']
---
# 小玉买文具
## 题目描述

班主任给小玉一个任务，到文具店里买尽量多的签字笔。已知一只签字笔的价格是 $1$ 元 $9$ 角，而班主任给小玉的钱是 $a$ 元 $b$ 角，小玉想知道，她最多能买多少只签字笔呢。

## 输入格式

输入只有一行两个整数，分别表示 $a$ 和 $b$。
## 输出格式

输出一行一个整数，表示小玉最多能买多少只签字笔。

## 样例

### 样例输入 #1
```
10 3

```
### 样例输出 #1
```
5

```
## 提示

#### 数据规模与约定

对于全部的测试点，保证 $0 \leq a \leq 10^4$，$0 \leq b \leq 9$。


### 代码

```cpp
#include<iostream>
using namespace std;
int main(){
int a,b,m;
cin>>a>>b;
m=10*a+b;
cout<<m/19<<endl;
return 0;
}
```

---

## 题目: P1422

**分类：入门-分支结构**

**提交时间：2023-12-26 12:06:36**

---
title: "小玉家的电费"
layout: "post"
diff: 入门
pid: P1422
tag: []
---
# 小玉家的电费
## 题目描述

夏天到了，各家各户的用电量都增加了许多，相应的电费也交的更多了。小玉家今天收到了一份电费通知单。小玉看到上面写：据闽价电 [2006]27 号规定，月用电量在 $150$ 千瓦时及以下部分按每千瓦时 $0.4463$ 元执行，月用电量在 $151\sim 400$ 千瓦时的部分按每千瓦时 $0.4663$ 元执行，月用电量在 $401$ 千瓦时及以上部分按每千瓦时 $0.5663$ 元执行。小玉想自己验证一下，电费通知单上应交电费的数目到底是否正确呢。请编写一个程序，已知用电总计，根据电价规定，计算出应交的电费应该是多少。

## 输入格式

输入一个正整数，表示用电总计（单位以千瓦时计），不超过 $10000$。

## 输出格式

输出一个数，保留到小数点后 $1$ 位（单位以元计，保留到小数点后 $1$ 位）。

## 样例

### 样例输入 #1
```
267
```
### 样例输出 #1
```
121.5
```


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int a=0;
double b=0;
cin>>a;
if(a<=150)
{
b = a*0.4463;
}
else if(a>=151&&a<=400)
{
b += 150*0.4463;
b += (a-150)*0.4663;
}
else
{
b += 150*0.4463;
b += (400-150)*0.4663;
b += (a-400)*0.5663;
}
printf("%.1f\n",b);
return 0;
}
```

---

## 题目: P1423

**分类：入门-循环结构**

**提交时间：2023-11-28 20:55:31**

---
title: "小玉在游泳"
layout: "post"
diff: 入门
pid: P1423
tag: []
---
# 小玉在游泳
## 题目描述

小玉开心的在游泳，可是她很快难过的发现，自己的力气不够，游泳好累哦。已知小玉第一步能游 $2$ 米，可是随着越来越累，力气越来越小，她接下来的每一步都只能游出上一步距离的 $98\%$。现在小玉想知道，如果要游到距离 $s$ 米的地方，她需要游多少步呢。请你编程解决这个问题。

## 输入格式

输入一个实数 $s$（单位：米），表示要游的目标距离。

## 输出格式

输出一个整数，表示小玉一共需要游多少步。

## 样例

### 样例输入 #1
```
4.3
```
### 样例输出 #1
```
3
```
## 提示

数据保证，$0 \leq s < 100$，且 $s$ 小数点后最多只有一位。


### 代码

```cpp
#include<iostream>
using namespace std;
int main()
{
float s,b,sum;
int a;
a=1;
b=2;
sum=2;
cin>>s;
while(sum<=s)
{
b=b*98/100;
sum+=b;
a+=1;
}
cout<<a;
return 0;
}
```

---

## 题目: P1424

**分类：入门-分支结构**

**提交时间：2023-12-27 20:07:46**

---
title: "小鱼的航程（改进版）"
layout: "post"
diff: 入门
pid: P1424
tag: []
---
# 小鱼的航程（改进版）
## 题目背景



## 题目描述

有一只小鱼，它平日每天游泳 $250$ 公里，周末休息（实行双休日)，假设从周 $x$ 开始算起，过了 $n$ 天以后，小鱼一共累计游泳了多少公里呢？
## 输入格式

输入两个正整数 $x,n$，表示从周 $x$ 算起，经过 $n$ 天。

## 输出格式

输出一个整数，表示小鱼累计游泳了多少公里。

## 样例

### 样例输入 #1
```
3 10
```
### 样例输出 #1
```
2000
```
## 提示

数据保证，$1\le x \le 7$，$1 \le n\le 10^6$。


### 代码

```cpp
#include<iostream>
using namespace std;
int main() {
int x, n, sum = 0;
cin >> x >> n;
for (int i = 1; i <= n; i++)
{
if (x > 7)
{
x = 1;
}
if (x <= 5)
{
sum += 250;
}
else
{
sum += 0;
}
x += 1;
}
cout << sum;
return 0;
}
```

---

## 题目: P1425

**分类：入门-顺序结构**

**提交时间：2023-11-09 18:10:47**

---
title: "小鱼的游泳时间"
layout: "post"
diff: 入门
pid: P1425
tag: ['数学', '枚举']
---
# 小鱼的游泳时间
## 题目描述

伦敦奥运会要到了，小鱼在拼命练习游泳准备参加游泳比赛，可怜的小鱼并不知道鱼类是不能参加人类的奥运会的。

这一天，小鱼给自己的游泳时间做了精确的计时（本题中的计时都按 $24$ 小时制计算），它发现自己从 $a$ 时 $b$ 分一直游泳到当天的 $c$ 时 $d$ 分，请你帮小鱼计算一下，它这天一共游了多少时间呢？

小鱼游的好辛苦呀，你可不要算错了哦。

## 输入格式

一行内输入四个整数，以空格隔开，分别表示题目中的 $a, b, c, d$。
## 输出格式

一行内输出两个整数 $e$ 和 $f$，用空格间隔，依次表示小鱼这天一共游了多少小时多少分钟。其中表示分钟的整数 $f$ 应该小于 $60$。
## 样例

### 样例输入 #1
```
12 50 19 10
```
### 样例输出 #1
```
6 20
```
## 提示

对于全部测试数据，$0\le a,c \le 24$，$0\le b,d \le 60$，且结束时间一定晚于开始时间。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int a,b,c,d,x,y;
cin>>a>>b>>c>>d;
x=c-a,y=d-b;
if(y<0){x--;y+=60;}
cout<<x<<" "<<y;
return 0;
}
```

---

## 题目: P1427

**分类：入门-数组**

**提交时间：2024-01-05 15:11:47**

---
title: "小鱼的数字游戏"
layout: "post"
diff: 入门
pid: P1427
tag: ['递归', '栈']
---
# 小鱼的数字游戏
## 题目描述

小鱼最近被要求参加一个数字游戏，要求它把看到的一串数字 $a_i$（长度不一定，以 $0$ 结束），记住了然后反着念出来（表示结束的数字 $0$ 就不要念出来了）。这对小鱼的那点记忆力来说实在是太难了，你也不想想小鱼的整个脑袋才多大，其中一部分还是好吃的肉！所以请你帮小鱼编程解决这个问题。
## 输入格式

一行内输入一串整数，以 $0$ 结束，以空格间隔。
## 输出格式

一行内倒着输出这一串整数，以空格间隔。

## 样例

### 样例输入 #1
```
3 65 23 5 34 1 30 0
```
### 样例输出 #1
```
30 1 34 5 23 65 3
```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $0 \leq a_i \leq 2^{31} - 1$，数字个数不超过 $100$。


### 代码

```cpp
#include <iostream>
using namespace std;
int a[105],n=0;
int main()
{
for(int i=1;;i++)
{
cin>>a[i];
if(a[i]==0)
{
break;
}
n+=1;
}
for (int i=n;i>=1;i--)
{
cout<<a[i]<<" ";
}
return 0;
}
```

---

## 题目: P1428

**分类：入门-数组**

**提交时间：2024-01-05 15:14:30**

---
title: "小鱼比可爱"
layout: "post"
diff: 入门
pid: P1428
tag: ['模拟']
---
# 小鱼比可爱
## 题目描述

人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度**可能一样**。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。

## 输入格式

第一行输入一个正整数 $n$，表示鱼的数目。

第二行内输入 $n$ 个正整数，用空格间隔，依次表示从左到右每只小鱼的可爱程度 $a_i$。

## 输出格式

一行，输出 $n$ 个整数，用空格间隔，依次表示每只小鱼眼中有多少只鱼不如自己可爱。

## 样例

### 样例输入 #1
```
6
4 3 0 5 1 2

```
### 样例输出 #1
```
0 0 0 3 1 2
```
## 提示

对于 $100\%$ 的数据，$1 \leq n\leq 100$，$0 \leq a_i \leq 10$。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int n,x=0,a[105];
cin>>n;
for (int i=1;i<=n;i++)
{
cin>>a[i];
}
for(int i=1;i<=n;i++)
{
x=0;
for(int j=i;j>=1;j--)
{
if(a[j]<a[i])
x++;
}
cout<<x<<" ";
}
return 0;
}
```

---

## 题目: P1435

**分类：动态规划-区间与环形动态规划**

**提交时间：2025-04-13 13:23:02**

---
title: "[IOI 2000] 回文字串"
layout: "post"
diff: 普及/提高-
pid: P1435
tag: ['动态规划 DP', '2000', 'IOI']
---
# [IOI 2000] 回文字串
## 题目背景

IOI2000 第一题

## 题目描述

回文词是一种对称的字符串。任意给定一个字符串，通过插入若干字符，都可以变成回文词。此题的任务是，求出将给定字符串变成回文词所需要插入的最少字符数。

比如 $\verb!Ab3bd!$ 插入 $2$ 个字符后可以变成回文词 $\verb!dAb3bAd!$ 或 $\verb!Adb3bdA!$，但是插入少于 $2$ 个的字符无法变成回文词。

**注意**：此问题区分大小写。

## 输入格式

输入共一行，一个字符串。
## 输出格式

有且只有一个整数，即最少插入字符数。

## 样例

### 样例输入 #1
```
Ab3bd
```
### 样例输出 #1
```
2
```
## 提示

### 数据范围及约定

记字符串长度为 $l$。

对于全部数据，$0<l\le 1000$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string s;
int dp[1005][1005];
int solve(int l,int r){
if(dp[l][r]!=0){
return dp[l][r];
}
if(l>=r){
return 0;
}
if(s[l]==s[r]){
return dp[l][r]=solve(l+1,r-1);
}
else{
return dp[l][r]=min(solve(l,r-1),solve(l+1,r))+1;
}
}
int main(){
cin>>s;
cout<<solve(0,s.size()-1);
return 0;
}
```

---

## 题目: P1443

**分类：算法--搜索**

**提交时间：2024-08-09 17:49:04**

---
title: "马的遍历"
layout: "post"
diff: 普及/提高-
pid: P1443
tag: ['搜索', 'Special Judge', '广度优先搜索 BFS', '队列']
---
# 马的遍历
## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。

## 输入格式

输入只有一行四个整数，分别为 $n, m, x, y$。

## 输出格式

一个 $n \times m$ 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 $-1$）。

## 样例

### 样例输入 #1
```
3 3 1 1

```
### 样例输出 #1
```
0    3    2    
3    -1   1    
2    1    4    
```
## 提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct point
{
int x, y;
};
int main()
{
int n, m, x0, y0, ans[402][402], dx[8] = {-1, -2, -2, -1, 1, 2, 2, 1}, dy[8] = {-2, -1, 1, 2, 2, 1, -1, -2};
queue<point>q;
memset(ans, -1, sizeof(ans));
cin >> n >> m >> x0 >> y0;
ans[x0][y0] = 0;
point tp = {x0, y0}, p;
q.push(tp);
while (!q.empty())
{
tp = q.front();
q.pop();
for (int i = 0; i < 8; i++)
{
int x = dx[i] + tp.x;
int y = dy[i] + tp.y;
if (x < 1 || x > n || y < 1 || y > m || ans[x][y] != -1)
{
continue;
}
ans[x][y] = ans[tp.x][tp.y] + 1;
p = {x, y};
q.push(p);
}
}
for (int i = 1; i <= n; i++)
{
for (int j = 1; j <= m; j++)
{
cout << ans[i][j] << "    ";
}
cout << endl;
}
return 0;
}
```

---

## 题目: P1466

**分类：动态规划**

**提交时间：2025-03-16 14:40:02**

---
title: "[USACO2.2] 集合 Subset Sums"
layout: "post"
diff: 普及/提高-
pid: P1466
tag: ['递推', 'USACO', '背包 DP']
---
# [USACO2.2] 集合 Subset Sums
## 题目描述

对于从 $1\sim n$ 的连续整数集合，能划分成两个子集合，且保证每个集合的数字和是相等的。举个例子，如果 $n=3$，对于 $\{1,2,3\}$ 能划分成两个子集合，每个子集合的所有数字和是相等的：

$\{3\}$ 和 $\{1,2\}$ 是唯一一种分法（交换集合位置被认为是同一种划分方案，因此不会增加划分方案总数）  
如果 $n=7$，有四种方法能划分集合 $\{1,2,3,4,5,6,7 \}$，每一种分法的子集合各数字和是相等的:

$\{1,6,7\}$ 和 $\{2,3,4,5\}$  
$\{2,5,7\}$ 和 $\{1,3,4,6\}$  
$\{3,4,7\}$ 和 $\{1,2,5,6\}$  
$\{1,2,4,7\}$ 和 $\{3,5,6\}$  

给出 $n$，你的程序应该输出划分方案总数。
## 输入格式

输入文件只有一行，且只有一个整数 $n$

## 输出格式

输出划分方案总数。

## 样例

### 样例输入 #1
```
7

```
### 样例输出 #1
```
4

```
## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 39$。

翻译来自NOCOW

USACO 2.2



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,t,dp[45005];
int main(){
cin>>n;
t=(1+n)*n/2;
if(t%2){
cout<<0;
return 0;
}
dp[0]=1;
for(int i=1;i<=n;i++){
for(int j=t/2;j>=i;j--){
dp[j]=dp[j]+dp[j-i];
}
}
cout<<dp[t/2]/2;
return 0;
}
```

---

## 题目: P1469

**分类：数学-基础数学问题**

**提交时间：2025-02-04 13:26:50**

---
title: "找筷子"
layout: "post"
diff: 普及-
pid: P1469
tag: ['数学', 'O2优化', '位运算']
---
# 找筷子
## 题目描述

经过一段时间的紧张筹备，电脑小组的“RP 餐厅”终于开业了，这天，经理 LXC 接到了一个定餐大单，可把大家乐坏了！员工们齐心协力按要求准备好了套餐正准备派送时，突然碰到一个棘手的问题：筷子！

CX 小朋友找出了餐厅中所有的筷子，但遗憾的是这些筷子长短不一，而我们都知道筷子需要长度一样的才能组成一双，更麻烦的是 CX 找出来的这些筷子数量为奇数，但是巧合的是，这些筷子中只有一只筷子是落单的，其余都成双，善良的你，可以帮 CX 找出这只落单的筷子的长度吗？

## 输入格式

第一行是一个整数，表示筷子的数量 $n$。

第二行有 $n$ 个整数，第 $i$ 个整数表示第 $i$ 根筷子的长度 $a_i$。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
9
2 2 1 3 3 3 2 3 1

```
### 样例输出 #1
```
2
```
## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^7 + 1$，$1 \leq a_i \leq 10^9$。


#### 提示

- 请注意数据读入对程序效率造成的影响。
- 请注意本题的空间限制为 $4$ Mb。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[10000005],x,ans=0;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
scanf("%d",&x);
ans^=x;
}
cout<<ans;
return 0;
}
```

---

## 题目: P1478

**分类：算法--贪心**

**提交时间：2025-02-03 12:31:58**

---
title: "陶陶摘苹果（升级版）"
layout: "post"
diff: 普及-
pid: P1478
tag: ['模拟', '贪心', '洛谷原创', '排序']
---
# 陶陶摘苹果（升级版）
## 题目描述

又是一年秋季时，陶陶家的苹果树结了 $n$ 个果子。陶陶又跑去摘苹果，这次他有一个 $a$ 公分的椅子。当他手够不着时，他会站到椅子上再试试。

这次与 NOIp2005 普及组第一题不同的是：陶陶之前搬凳子，力气只剩下 $s$ 了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在 $s<0$ 之前最多能摘到多少个苹果。

现在已知 $n$ 个苹果到达地上的高度 $x_i$，椅子的高度 $a$，陶陶手伸直的最大长度 $b$，陶陶所剩的力气 $s$，陶陶摘一个苹果需要的力气 $y_i$，求陶陶最多能摘到多少个苹果。

## 输入格式

第 $1$ 行：两个数 苹果数 $n$，力气 $s$。

第 $2$ 行：两个数 椅子的高度 $a$，陶陶手伸直的最大长度 $b$。

第 $3$ 行~第 $3+n-1$ 行：每行两个数 苹果高度 $x_i$，摘这个苹果需要的力气 $y_i$。

## 输出格式

只有一个整数，表示陶陶最多能摘到的苹果数。

## 样例

### 样例输入 #1
```
8 15
20 130
120 3
150 2
110 7
180 1
50 8
200 0
140 3
120 2
```
### 样例输出 #1
```
4
```
## 提示

对于 $100\%$ 的数据，$n\leq 5000$, $a\leq 50$, $b\leq 200$, $s\leq 1000$, $x_i\leq 280$, $y_i\leq 100$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s,l,b,sum=0;
struct apple{
int x,y;
}a[5005];
bool cmp(apple one,apple two){
if(one.y<two.y){
return true;
}
return false;
}
int main(){
cin>>n>>s>>l>>b;
for(int i=1;i<=n;i++){
cin>>a[i].x>>a[i].y;
}
sort(a+1,a+n+1,cmp);
for(int i=1;i<=n;i++){
if(s<a[i].y){
break;
}
if(a[i].x<=l+b){
s-=a[i].y;
sum+=1;
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P1506

**提交时间：2025-03-11 19:55:09**

---
title: "拯救oibh总部"
layout: "post"
diff: 普及-
pid: P1506
tag: ['模拟', '搜索', '广度优先搜索 BFS', '深度优先搜索 DFS']
---
# 拯救oibh总部
## 题目背景

oibh 总部突然被水淹没了！现在需要你的救援……

## 题目描述

oibh 被突来的洪水淹没了，还好 oibh 总部有在某些重要的地方起一些围墙。用 `*` 号表示，而一个四面被围墙围住的区域洪水是进不去的。

oibh 总部内部也有许多重要区域，每个重要区域在图中用一个 `0` 表示。

现在给出 oibh 的围墙建设图，问有多少个没被洪水淹到的重要区域。
## 输入格式

第一行为两个正整数 $x,y$。

接下来 $x$ 行，每行 $y$ 个整数，由 `*` 和 `0` 组成，表示 oibh 总部的建设图。
## 输出格式

输出没被水淹没的 oibh 总部的 `0` 的数量。
## 样例

### 样例输入 #1
```
4 5
00000
00*00
0*0*0
00*00
```
### 样例输出 #1
```
1

```
### 样例输入 #2
```
5 5
*****
*0*0*
**0**
*0*0*
*****
```
### 样例输出 #2
```
5
```
## 提示

对于 $100\%$ 的数据，$1 \le x,y \le 500$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
char ch[505][505];
bool vis[505][505];
int dx[5]={0,0,1,-1};
int dy[5]={1,-1,0,0};
void dfs(int x,int y){
if(vis[x][y]==true){
return;
}
vis[x][y]=true;
for(int i=0;i<4;i++){
int tx=x+dx[i];
int ty=y+dy[i];
if(tx<1||tx>n||ty<1||ty>m||ch[tx][ty]=='*' ) {
continue;
}
dfs(tx,ty);
}
}
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
cin>>ch[i][j];
if(ch[i][j]=='*') {
vis[i][j]=true;
}
}
}
for(int j=1;j<=m;j++){
if(vis[1][j]==false&&ch[1][j]=='0') {
dfs(1,j);
}
if(vis[n][j]==false&&ch[n][j]=='0') {
dfs(n,j);
}
}
for(int i=1;i<=n;i++){
if(vis[i][1]==false&&ch[i][1]=='0'){
dfs(i,1);
}
if(vis[i][m]==false&&ch[i][m]=='0') {
dfs(i,m);
}
}
int ans=0;
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
if(vis[i][j]==false&&ch[i][j]=='0'){
ans++;
}
}
}
cout<<ans;
return 0;
}
```

---

## 题目: P1554

**分类：入门-数组**

**提交时间：2024-01-10 16:30:33**

---
title: "梦中的统计"
layout: "post"
diff: 入门
pid: P1554
tag: ['模拟', '字符串', '数学', 'USACO']
---
# 梦中的统计
## 题目背景

Bessie 处于半梦半醒的状态。过了一会儿，她意识到她在数数，不能入睡。
## 题目描述

Bessie 的大脑反应灵敏，仿佛真实地看到了她数过的一个又一个数。她开始注意每一个数码（$0 \ldots 9$）：每一个数码在计数的过程中出现过多少次？

给出两个整数 $M$ 和 $N$，求在序列 $[M, M + 1, M + 2, \ldots, N - 1, N]$ 中每一个数码出现了多少次。
## 输入格式

第 $1$ 行: 两个用空格分开的整数 $M$ 和 $N$。
## 输出格式

第 $1$ 行: 十个用空格分开的整数，分别表示数码 $0 \ldots 9$ 在序列中出现的次数。
## 样例

### 样例输入 #1
```
129 137
```
### 样例输出 #1
```
1 10 2 9 1 1 1 1 0 1
```
## 提示

数据保证，$1 \leq M \leq N \leq 2 \times 10^9$，$N-M \leq 5 \times 10^5$。


### 代码

```cpp
#include <iostream>
using namespace std;
int a[10],m,n,t,b;
int main()
{
cin>>m>>n;
for(int i=0;i<=9;i++)
{
a[i]=0;
}
for(int i=m;i<=n;i++)
{
t=i;
while(t!=0)
{
b=t%10;
a[b]++;
t=t/10;
}
}
for(int i=0;i<=9;i++)
{
cout<<a[i]<<" ";
}
return 0;
}
```

---

## 题目: P1596

**分类：算法--搜索**

**提交时间：2025-01-26 14:04:34**

---
title: "[USACO10OCT] Lake Counting S"
layout: "post"
diff: 普及-
pid: P1596
tag: ['搜索', '2010', 'USACO', '深度优先搜索 DFS']
---
# [USACO10OCT] Lake Counting S
## 题目描述

Due to recent rains, water has pooled in various places in Farmer John's field, which is represented by a rectangle of N x M (1 <= N <= 100; 1 <= M <= 100) squares. Each square contains either water ('W') or dry land ('.'). Farmer John would like to figure out how many ponds have formed in his field. A pond is a connected set of squares with water in them, where a square is considered adjacent to all eight of its neighbors. Given a diagram of Farmer John's field, determine how many ponds he has.





## 输入格式

Line 1: Two space-separated integers: N and M \* Lines 2..N+1: M characters per line representing one row of Farmer John's field. Each character is either 'W' or '.'. The characters do not have spaces between them.



## 输出格式

Line 1: The number of ponds in Farmer John's field.


## 样例

### 样例输入 #1
```
10 12
W........WW.
.WWW.....WWW
....WW...WW.
.........WW.
.........W..
..W......W..
.W.W.....WW.
W.W.W.....W.
.W.W......W.
..W.......W.

```
### 样例输出 #1
```
3

```
## 提示

OUTPUT DETAILS: There are three ponds: one in the upper left, one in the lower left, and one along the right side.

## 题目翻译

由于近期的降雨，雨水汇集在农民约翰的田地不同的地方。我们用一个 $N\times M(1\leq N\leq 100, 1\leq M\leq 100)$ 的网格图表示。每个网格中有水（`W`） 或是旱地（`.`）。一个网格与其周围的八个网格相连，而一组相连的网格视为一个水坑。约翰想弄清楚他的田地已经形成了多少水坑。给出约翰田地的示意图，确定当中有多少水坑。

输入第 $1$ 行：两个空格隔开的整数：$N$ 和 $M$。

第 $2$ 行到第 $N+1$ 行：每行 $M$ 个字符，每个字符是 `W` 或 `.`，它们表示网格图中的一排。字符之间没有空格。

输出一行，表示水坑的数量。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,vis[205][205],cnt=0;
char a[205][205];
int dx[10]={0,0,1,-1,1,1,-1,-1};
int dy[10]={1,-1,0,0,1,-1,1,-1};
void dfs(int x,int y){
for(int i=0;i<8;i++){
int fx=dx[i]+x;
int fy=dy[i]+y;
if(fx>=1&&fx<=n&&fy>=1&&fy<=m&&vis[fx][fy]==0&&a[x][y]=='W'){
vis[fx][fy]=1;
dfs(fx,fy);
}
}
}
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
cin>>a[i][j];
}
}
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
if(a[i][j]=='W'&&vis[i][j]==0){
dfs(i,j);
cnt+=1;
}
}
}
cout<<cnt;
return 0;
}
```

---

## 题目: P1598

**分类：入门-字符串**

**提交时间：2024-03-08 14:58:11**

---
title: "垂直柱状图"
layout: "post"
diff: 普及-
pid: P1598
tag: ['模拟', '字符串']
---
# 垂直柱状图
## 题目描述

写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过 $100$ 个字符），然后用柱状图输出每个字符在输入文件中出现的次数。严格地按照输出样例来安排你的输出格式。

## 输入格式

四行字符，由大写字母组成，每行不超过 $100$ 个字符

## 输出格式

由若干行组成，前几行由空格和星号组成，最后一行则是由空格和字母组成的。在任何一行末尾不要打印不需要的多余空格。不要打印任何空行。

## 样例

### 样例输入 #1
```
THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG.
THIS IS AN EXAMPLE TO TEST FOR YOUR
HISTOGRAM PROGRAM.
HELLO!

```
### 样例输出 #1
```
                            *
                            *
        *                   *
        *                   *     *   *
        *                   *     *   *
*       *     *             *     *   *
*       *     * *     * *   *     * * *
*       *   * * *     * *   * *   * * * *
*     * * * * * *     * * * * *   * * * *     * *
* * * * * * * * * * * * * * * * * * * * * * * * * *
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

```
## 提示

每行输出后面不允许出现多余的空格。



### 代码

```cpp
#include <stdio.h>
#include <string.h>
int main(){
char tmp;//暂时用来读取字符
int word[26]={0};//存储每个字母出现的次数
while(scanf("%c",&tmp)!=EOF){
switch(tmp){
case 'A':word[0]++;break;
case 'B':word[1]++;break;
case 'C':word[2]++;break;
case 'D':word[3]++;break;
case 'E':word[4]++;break;
case 'F':word[5]++;break;
case 'G':word[6]++;break;
case 'H':word[7]++;break;
case 'I':word[8]++;break;
case 'J':word[9]++;break;
case 'K':word[10]++;break;
case 'L':word[11]++;break;
case 'M':word[12]++;break;
case 'N':word[13]++;break;
case 'O':word[14]++;break;
case 'P':word[15]++;break;
case 'Q':word[16]++;break;
case 'R':word[17]++;break;
case 'S':word[18]++;break;
case 'T':word[19]++;break;
case 'U':word[20]++;break;
case 'V':word[21]++;break;
case 'W':word[22]++;break;
case 'X':word[23]++;break;
case 'Y':word[24]++;break;
case 'Z':word[25]++;break;
}
}
for(int i = 0;i<=405;i++){
int flag = 0,max=0,end=0;//flag标识是否还有星号要输出，0是默认没有了
for(int j = 0;j<26;j++){//查找当前出现次数最多的字母
if(word[j]>=max){
max=word[j];//把出现的次数给max
end=j;
if(max!=0){flag=1;}//如果max！=0则说明仍有星号待输出
}
}
if(flag==0){//结束时输出
printf("A B C D E F G H I J K L M N O P Q R S T U V W X Y Z");
break;//退出循环
}
for(int j = 0;j<=end;j++){
if(word[j]==max){//输出此时和最大次数相同的字母星号
printf("%s%c",j==0?"":" ",'*');
word[j]--;
}
else{printf("%s%s",j==0?"":" "," ");}
}
printf("\n");
}
return 0;
}
```

---

## 题目: P1601

**分类：算法--模拟与高精度**

**提交时间：2024-11-29 15:53:39**

---
title: "A+B Problem（高精）"
layout: "post"
diff: 普及-
pid: P1601
tag: ['字符串', '高精度']
---
# A+B Problem（高精）
## 题目描述

高精度加法，相当于 a+b problem，**不用考虑负数**。
## 输入格式

分两行输入。$a,b \leq 10^{500}$。

## 输出格式

输出只有一行，代表 $a+b$ 的值。
## 样例

### 样例输入 #1
```
1
1
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
1001
9099
```
### 样例输出 #2
```
10100
```
## 提示

$20\%$ 的测试数据，$0\le a,b \le10^9$；

$40\%$ 的测试数据，$0\le a,b \le10^{18}$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string st1,st2;
int a[505],b[505],c[505];
int main(){
cin>>st1>>st2;
int len1=st1.size();
int len2=st2.size();
for(int i=0;i<len1;i++){
a[len1-i]=st1[i]-'0';
}
for(int i=0;i<len2;i++){
b[len2-i]=st2[i]-'0';
}
int lenc=max(len1,len2);
for(int i=1;i<=lenc;i++){
c[i]=a[i]+b[i];
}
for(int i=1;i<=lenc;i++){
if(c[i]>=10){
c[i+1]+=1;
c[i]-=10;
}
}
if(c[lenc+1]){
lenc+=1;
}
for(int i=lenc;i>=1;i--){
cout<<c[i];
}
return 0;
}
```

---

## 题目: P1610

**分类：贪心**

**提交时间：2025-03-21 21:00:29**

---
title: "鸿山洞的灯"
layout: "post"
diff: 普及-
pid: P1610
tag: ['贪心']
---
# 鸿山洞的灯
## 题目描述

已知 $n$ 盏灯以及每盏灯的位置 $p_i$，$p_i$ 均不相等，当两盏灯之间的距离小于 $dist$ 时，若这个安全距离里面还有灯是亮着时，就可以关掉这些灯（即若第 $i-1$ 盏与第 $i+1$ 盏的距离 $\leq dist$，则可以关掉第 $i$ 盏）。

求在保证洞里的光线是充足的情况下，一段区域里能删除的灯的最大值。

距离洞口最近和最远的两盏灯必须是亮着。
## 输入格式

第一行两个数，$n$ 和 $dist$。

第二行 $n$ 个数，即每盏灯的位置 $p_i$。
## 输出格式

一个数，即一段区域里能删除的灯的最大值。
## 样例

### 样例输入 #1
```
3 3

1 2 3
```
### 样例输出 #1
```
1
```
## 提示

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，保证 $dist$ 在 `int` 整型范围之内。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,dist,a[100005],ans=0;
int main(){
cin>>n>>dist;
for(int i=1;i<=n;i++){
cin>>a[i];
}
sort(a+1,a+n+1);
for(int i=2;i<=n-1;i++){
if(a[i+1]-a[i-1]<=dist){
a[i]=a[i-1];
ans+=1;
}
}
cout<<ans;
return 0;
}
```

---

## 题目: P1614

**分类：入门-数组**

**提交时间：2024-11-11 19:32:01**

---
title: "爱与愁的心痛"
layout: "post"
diff: 入门
pid: P1614
tag: ['模拟', '贪心', '洛谷原创', '枚举']
---
# 爱与愁的心痛
## 题目背景

（本道题目隐藏了两首歌名，找找看哪~~~）

《爱与愁的故事第一弹·heartache》第一章。

《我为歌狂》当中伍思凯神曲《舞月光》居然没赢给萨顶顶，爱与愁大神心痛啊~~~而且最近还有一些令人伤心的事情，都让人心痛（最近真的很烦哈)……

## 题目描述

最近有 $n$ 个不爽的事，每句话都有一个正整数刺痛值（心理承受力极差）。爱与愁大神想知道连续 $m$ 个刺痛值的和的最小值是多少，但是由于业务繁忙，爱与愁大神只好请你编个程序告诉他。

## 输入格式

第一行有两个用空格隔开的整数，分别代表 $n$ 和 $m$。

第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $a_i$ 代表第 $i$ 件事的刺痛值 $a_i$。
## 输出格式

输出一行一个整数，表示连续 $m$ 个刺痛值的和的最小值是多少。

## 样例

### 样例输入 #1
```
8 3
1
4
7
3
1
2
4
3
```
### 样例输出 #1
```
6
```
## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 20$。
- 对于 $60\%$ 的数据，保证 $n \leq 100$。
- 对于 $90\%$ 的数据，保证 $n \leq 10^3$。
- 对于 $100\%$ 的数据，保证 $0 \leq m \leq n \leq 3 \times 10^3$，$1 \leq a_i \leq 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[10005],m,n,minn=100000,sum=0;
int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=n-m+1;i++)
{
sum=0;
for(int j=i;j<=i+m-1;j++){
sum+=a[j];
}
minn=min(minn,sum);
}
cout<<minn;
return 0;
}
```

---

## 题目: P1616

**分类：动态规划-动态规划的引入**

**提交时间：2025-03-23 13:31:50**

---
title: "疯狂的采药"
layout: "post"
diff: 普及-
pid: P1616
tag: ['动态规划 DP', '洛谷原创', '背包 DP']
---
# 疯狂的采药
## 题目背景

此题为纪念 LiYuxiang 而生。

## 题目描述

LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是 LiYuxiang，你能完成这个任务吗？

此题和原题的不同点：

$1$. 每种草药可以无限制地疯狂采摘。

$2$. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！
## 输入格式

输入第一行有两个整数，分别代表总共能够用来采药的时间 $t$ 和代表山洞里的草药的数目 $m$。

第 $2$ 到第 $(m + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $a_i, b_i$ 分别表示采摘第 $i$ 种草药的时间和该草药的价值。
## 输出格式

输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。
## 样例

### 样例输入 #1
```
70 3
71 100
69 1
1 2

```
### 样例输出 #1
```
140

```
## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $m \le 10^3$ 。
- 对于 $100\%$ 的数据，保证 $1 \leq m \le 10^4$，$1 \leq t \leq 10^7$，且 $1 \leq m \times t \leq 10^7$，$1 \leq a_i, b_i \leq 10^4$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,dp[10000005],v[10005],w[10005];
int main(){
cin>>m>>n;
for(int i=1;i<=n;i++){
cin>>v[i]>>w[i];
}
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
if(j>=v[i]){
dp[j]=max(dp[j],w[i]+dp[j-v[i]]);
}
}
}
cout<<dp[m];
return 0;
}
```

---

## 题目: P1618

**分类：算法--暴力枚举**

**提交时间：2024-10-13 19:37:28**

---
title: "三连击（升级版）"
layout: "post"
diff: 普及-
pid: P1618
tag: ['模拟', '字符串', '枚举']
---
# 三连击（升级版）
## 题目描述

将 $1, 2,\ldots, 9$ 共 $9$ 个数分成三组，分别组成三个三位数，且使这三个三位数的比例是 $A:B:C$，试求出所有满足条件的三个三位数，若无解，输出 `No!!!`。


//感谢黄小U饮品完善题意

## 输入格式

三个数，$A,B,C$。

## 输出格式

若干行，每行 $3$ 个数字。按照每行第一个数字升序排列。

## 样例

### 样例输入 #1
```
1 2 3
```
### 样例输出 #1
```
192 384 576
219 438 657
273 546 819
327 654 981
```
## 提示

保证 $A<B<C$。

---

$\text{upd 2022.8.3}$：新增加二组 Hack 数据。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int A,B,C,b,c,x[15],s=0;
bool flag=1;
int main(){
cin>>A>>B>>C;
if(A==0||B==0||C==0){
cout<<"No!!!";
return 0;
}
for(int a=123;a<=987;a++){
flag=1;
b=a*B/A;
c=a*C/A;
x[a%10]+=1;
x[a/10%10]+=1;
x[a/100]+=1;
x[b%10]+=1;
x[b/10%10]+=1;
x[b/100]+=1;
x[c%10]+=1;
x[c/10%10]+=1;
x[c/100]+=1;
for(int i=1;i<=9;i++){
if(x[i]!=1){
flag=0;
}
x[i]=0;
}
if(flag==1){
s=1;
cout<<a<<" "<<b<<" "<<c<<endl;
}
}
if(s==0){
cout<<"No!!!";
}
return 0;
}
```

---

## 题目: P1678

**分类：算法--二分查找与二分答案**

**提交时间：2024-10-10 20:28:02**

---
title: "烦恼的高考志愿"
layout: "post"
diff: 普及-
pid: P1678
tag: ['模拟', '贪心', '二分', '排序']
---
# 烦恼的高考志愿
## 题目背景

计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。

## 题目描述

现有 $m$ 所学校，每所学校预计分数线是 $a_i$。有 $n$ 位学生，估分分别为 $b_i$。

根据 $n$ 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。

## 输入格式

第一行读入两个整数 $m,n$。$m$ 表示学校数，$n$ 表示学生数。

第二行共有 $m$ 个数，表示 $m$ 个学校的预计录取分数。第三行有 $n$ 个数，表示 $n$ 个学生的估分成绩。
## 输出格式

输出一行，为最小的不满度之和。
## 样例

### 样例输入 #1
```
4 3
513 598 567 689
500 600 550

```
### 样例输出 #1
```
32
```
## 提示

数据范围：

对于 $30\%$ 的数据，$1\leq n,m\leq1000$，估分和录取线 $\leq10000$；

对于 $100\%$ 的数据，$1\leq n,m\leq100000$，估分和录取线 $\leq 1000000$ 且均为非负整数。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long m,n,a[100005],b[100005],ans=0,k;
int main(){
cin>>m>>n;
for(int i=0;i<m;i++){
cin>>a[i];
}
for(int i=0;i<n;i++){
cin>>b[i];
}
sort(a,a+m);
for(int i=0;i<n;i++){
if(a[0]>=b[i]){
ans+=a[0]-b[i];
}
else if(a[m-1]<=b[i]){
ans+=b[i]-a[m-1];
}
else
{
k=lower_bound(a,a+m,b[i])-a;
ans+=min(a[k]-b[i],b[i]-a[k-1]);
}
}
cout<<ans;
return 0;
}
```

---

## 题目: P1706

**分类：算法--暴力枚举**

**提交时间：2024-12-16 10:06:25**

---
title: "全排列问题"
layout: "post"
diff: 普及-
pid: P1706
tag: ['搜索', '数学', '递归', '深度优先搜索 DFS']
---
# 全排列问题
## 题目描述

按照字典序输出自然数 $1$ 到 $n$ 所有不重复的排列，即 $n$ 的全排列，要求所产生的任一数字序列中不允许出现重复的数字。

## 输入格式

一个整数 $n$。

## 输出格式

由 $1 \sim n$ 组成的所有不重复的数字序列，每行一个序列。

每个数字保留 $5$ 个场宽。

## 样例

### 样例输入 #1
```
3
```
### 样例输出 #1
```
    1    2    3
    1    3    2
    2    1    3
    2    3    1
    3    1    2
    3    2    1

```
## 提示

$1 \leq n \leq 9$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],vis[105];
void dfs(int k){
if(k==n+1){
for(int i=1;i<=n;i++){
cout<<"    "<<a[i];
}
cout<<endl;
return;
}
for(int i=1;i<=n;i++){
if(!vis[i]){
vis[i]=1;
a[k]=i;
dfs(k+1);
vis[i]=0;
}
}
}
int main(){
cin>>n;
dfs(1);
return 0;
}
```

---

## 题目: P1719

**分类：算法--前缀和、差分与离散化**

**提交时间：2024-08-16 22:51:36**

---
title: "最大加权矩形"
layout: "post"
diff: 普及-
pid: P1719
tag: ['动态规划 DP', '递推', '枚举', '前缀和']
---
# 最大加权矩形
## 题目描述

为了更好的备战 NOIP2013，电脑组的几个女孩子 LYQ,ZSC,ZHQ 认为，我们不光需要机房，我们还需要运动，于是就决定找校长申请一块电脑组的课余运动场地，听说她们都是电脑组的高手，校长没有马上答应他们，而是先给她们出了一道数学题，并且告诉她们：你们能获得的运动场地的面积就是你们能找到的这个最大的数字。

校长先给他们一个 $n\times n$ 矩阵。要求矩阵中最大加权矩形，即矩阵的每一个元素都有一权值，权值定义在整数集上。从中找一矩形，矩形大小无限制，是其中包含的所有元素的和最大 。矩阵的每个元素属于 $[-127,127]$ ,例如

```plain
 0 –2 –7  0 
 9  2 –6  2
-4  1 –4  1 
-1  8  0 –2
```

在左下角：

```plain
9  2
-4  1
-1  8
```

和为 $15$。

几个女孩子有点犯难了，于是就找到了电脑组精打细算的 HZH，TZY 小朋友帮忙计算，但是遗憾的是他们的答案都不一样，涉及土地的事情我们可不能含糊，你能帮忙计算出校长所给的矩形中加权和最大的矩形吗？

## 输入格式

第一行：$n$，接下来是 $n$ 行 $n$ 列的矩阵。

## 输出格式

最大矩形（子矩阵）的和。

## 样例

### 样例输入 #1
```
4
0 -2 -7 0
 9 2 -6 2
-4 1 -4  1 
-1 8  0 -2

```
### 样例输出 #1
```
15
```
## 提示

$1 \leq n\le 120$


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,a[125][125],b[125][125],maxn=-1e9;
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
{
cin>>a[i][j];
}
}
for(int i=1;i<=n;i++)
{
for(int j=1;j<=n;j++)
{
b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];
}
}
for(int x=1;x<=n;x++)
{
for(int y=1;y<=n;y++)
{
for(int x2=x;x2<=n;x2++)
{
for(int y2=y;y2<=n;y2++)
{
int s=b[x2][y2]-b[x-1][y2]-b[x2][y-1]+b[x-1][y-1];
maxn=max(maxn,s);
}
}
}
}
cout<<maxn;
return 0;
}
```

---

## 题目: P1720

**分类：入门-循环结构**

**提交时间：2023-11-24 15:29:36**

---
title: "月落乌啼算钱（斐波那契数列）"
layout: "post"
diff: 入门
pid: P1720
tag: ['模拟', '数学', '递推', '洛谷原创', '斐波那契数列']
---
# 月落乌啼算钱（斐波那契数列）
## 题目背景

（本道题目木有隐藏歌曲……不用猜了……）

《爱与愁的故事第一弹·heartache》最终章。

吃完 pizza，月落乌啼知道超出自己的预算了。为了不在爱与愁大神面前献丑，只好还是硬着头皮去算钱……

## 题目描述

算完钱后，月落乌啼想着：“你坑我！”于是当爱与愁大神问多少钱时，月落乌啼说了一堆乱码。爱与愁大神说：“算了算了，我只问第 $n$ 样菜价格多少？”月落乌啼写出了：

$$F_n=\dfrac{\left(\frac{1+\sqrt{5}}{2}\right)^n-\left(\frac{1-\sqrt{5}}{2}\right)^n}{\sqrt{5}}$$

由于爱与愁大神学过编程，于是就用 $1$ 分钟的时间求出了 $F_n$ 的结果。月落乌啼为此大吃一惊。你能学学爱与愁大神求出 $F_n$ 的值吗？


## 输入格式

一行一个自然数 $n$。
## 输出格式

只有 $1$ 行一个实数 $F_n$，保留两位小数。
## 样例

### 样例输入 #1
```
6
```
### 样例输出 #1
```
8.00
```
## 提示

对于所有数据：$0 \leq n\leq 48$。


### 代码

```cpp
#include<iostream>
using namespace std;
long long a=1,b=1,c=0;///因为n<=48,所以大一点
int n,i;
int main()
{
cin>>n;
for (i=3;i<=n;i++)
{///注意了，精彩的 来了！！！
c=a+b;
a=b;
b=c;
}
cout<<c<<".00";///".00"是为了符合题意.......
return 0;
}
```

---

## 题目: P1746

**分类：搜索**

**提交时间：2025-01-20 21:39:31**

---
title: "离开中山路"
layout: "post"
diff: 普及-
pid: P1746
tag: ['模拟', '搜索', '广度优先搜索 BFS', '队列']
---
# 离开中山路
## 题目背景

《爱与愁的故事第三弹·shopping》最终章。

## 题目描述

爱与愁大神买完东西后，打算坐车离开中山路。现在爱与愁大神在 $x_1,y_1$ 处，车站在 $x_2,y_2$ 处。现在给出一个 $n \times n(n \le 1000)$ 的地图，$0$ 表示马路，$1$ 表示店铺（不能从店铺穿过），爱与愁大神只能垂直或水平着在马路上行进。爱与愁大神为了节省时间，他要求最短到达目的地距离（每两个相邻坐标间距离为 $1$）。你能帮他解决吗？

## 输入格式

第 $1$ 行包含一个数 $n$。

第 $2$ 行到第 $n+1$ 行：整个地图描述（$0$ 表示马路，$1$ 表示店铺，注意两个数之间没有空格）。

第 $n+2$ 行：四个数 $x_1,y_1,x_2,y_2$。
## 输出格式


只有 $1$ 行，即最短到达目的地距离。

## 样例

### 样例输入 #1
```
3
001
101
100
1 1 3 3
```
### 样例输出 #1
```
4
```
## 提示


对于 $20\%$ 数据，满足 $1\leq n \le 100$。

对于 $100\%$ 数据，满足 $1\leq n \le 1000$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,xs,ys,xe,ye;
int tx[5]={0,0,0,1,-1};
int ty[5]={0,1,-1,0,0};
bool vis[1005][1005];
char a[1005][1005];
struct zb{
int x,y,step;
};
queue<zb>q;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
for(int j=1;j<=n;j++){
cin>>a[i][j];
if(a[i][j]=='1'){
vis[i][j]=1;
}
}
}
cin>>xs>>ys>>xe>>ye;
q.push({xs,ys,0});
vis[xs][ys]=1;
while(!q.empty()){
zb now=q.front();
q.pop();
if(now.x==xe&&now.y==ye){
cout<<now.step;
break;
}
for(int i=1;i<=4;i++){
int bx=now.x+tx[i];
int by=now.y+ty[i];
if(bx>=1&&bx<=n&&by>=1&&by<=n&&a[bx][by]=='0'&&vis[bx][by]==0){
q.push({bx,by,now.step+1});
vis[bx][by]=1;
}
}
}
return 0;
}
```

---

## 题目: P1757

**分类：动态规划**

**提交时间：2025-04-06 13:31:52**

---
title: "通天之分组背包"
layout: "post"
diff: 普及-
pid: P1757
tag: ['动态规划 DP', '背包 DP']
---
# 通天之分组背包
## 题目背景

直达通天路·小 A 历险记第二篇

## 题目描述

自 $01$ 背包问世之后，小 A 对此深感兴趣。一天，小 A 去远游，却发现他的背包不同于 $01$ 背包，他的物品大致可分为 $k$ 组，每组中的物品相互冲突，现在，他想知道最大的利用价值是多少。
## 输入格式

两个数 $m,n$，表示一共有 $n$ 件物品，总重量为 $m$。

接下来 $n$ 行，每行 $3$ 个数 $a_i,b_i,c_i$，表示物品的重量，利用价值，所属组数。
## 输出格式

一个数，最大的利用价值。
## 样例

### 样例输入 #1
```
45 3
10 10 1
10 5 1
50 400 2
```
### 样例输出 #1
```
10
```
## 提示

$0 \leq m \leq 1000$，$1 \leq n \leq 1000$，$1\leq k\leq 100$，$a_i, b_i, c_i$ 在 `int` 范围内。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,v[1005][1005],w[1005][1005],t[105],dp[1005];
int main(){
cin>>m>>n;
for(int i=1;i<=n;i++){
int x,y,z;
cin>>x>>y>>z;
t[z]+=1;
w[z][t[z]]=x;
v[z][t[z]]=y;
}
for(int i=1;i<=n;i++){
for(int j=m;j>=0;j--){
for(int k=1;k<=t[i];k++){
if(j>=w[i][k]){
dp[j]=max(dp[j],dp[j-w[i][k]]+v[i][k]);
}
}
}
}
cout<<dp[m];
return 0;
}
```

---

## 题目: P1775

**分类：动态规划-区间与环形动态规划**

**提交时间：2025-04-13 14:29:31**

---
title: "石子合并（弱化版）"
layout: "post"
diff: 普及/提高-
pid: P1775
tag: ['动态规划 DP', '区间 DP']
---
# 石子合并（弱化版）
## 题目描述

设有 $N(N \le 300)$ 堆石子排成一排，其编号为 $1,2,3,\cdots,N$。每堆石子有一定的质量 $m_i\ (m_i \le 1000)$。现在要将这 $N$ 堆石子合并成为一堆。每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻。合并时由于选择的顺序不同，合并的总代价也不相同。试找出一种合理的方法，使总的代价最小，并输出最小代价。
## 输入格式

第一行，一个整数 $N$。

第二行，$N$ 个整数 $m_i$。
## 输出格式

输出文件仅一个整数，也就是最小代价。

## 样例

### 样例输入 #1
```
4
2 5 3 1
```
### 样例输出 #1
```
22
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[305],q[305];
int dp[305][305];
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
q[i]=q[i-1]+a[i];
}
memset(dp,0x3f3f3f,sizeof(dp));
for(int i=1;i<=n;i++){
dp[i][i]=0;
}
for(int len=2;len<=n;len++){
for(int i=1;i<=n;i++){
int j=i+len-1;
if(j>n){
break;
}
for(int k=i;k<j;k++){
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+q[j]-q[i-1]);
}
}
}
cout<<dp[1][n];
return 0;
}
```

---

## 题目: P1776

**分类：动态规划**

**提交时间：2025-03-30 14:58:26**

---
title: "宝物筛选"
layout: "post"
diff: 普及+/提高
pid: P1776
tag: ['动态规划 DP', '单调队列', 'NOI 导刊', '背包 DP', '进制']
---
# 宝物筛选
## 题目描述

终于，破解了千年的难题。小 FF 找到了王室的宝物室，里面堆满了无数价值连城的宝物。

这下小 FF 可发财了，嘎嘎。但是这里的宝物实在是太多了，小 FF 的采集车似乎装不下那么多宝物。看来小 FF 只能含泪舍弃其中的一部分宝物了。

小 FF 对洞穴里的宝物进行了整理，他发现每样宝物都有一件或者多件。他粗略估算了下每样宝物的价值，之后开始了宝物筛选工作：小 FF 有一个最大载重为 $W$ 的采集车，洞穴里总共有 $n$ 种宝物，每种宝物的价值为 $v_i$，重量为 $w_i$，每种宝物有 $m_i$ 件。小 FF 希望在采集车不超载的前提下，选择一些宝物装进采集车，使得它们的价值和最大。
## 输入格式

第一行为一个整数 $n$ 和 $W$，分别表示宝物种数和采集车的最大载重。

接下来 $n$ 行每行三个整数 $v_i,w_i,m_i$。
## 输出格式

输出仅一个整数，表示在采集车不超载的情况下收集的宝物的最大价值。
## 样例

### 样例输入 #1
```
4 20
3 9 3
5 9 1
9 4 2
8 1 3
```
### 样例输出 #1
```
47
```
## 提示

对于 $30\%$ 的数据，$n\leq \sum m_i\leq 10^4$，$0\le W\leq 10^3$。

对于 $100\%$ 的数据，$n\leq \sum m_i \leq 10^5$，$0\le W\leq 4\times 10^4$，$1\leq n\le 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,W,w[100005],v[100005],m[100005],dp[100005];
int main(){
cin>>n>>W;
for(int i=1;i<=n;i++){
cin>>v[i]>>w[i]>>m[i];
}
for(int i=1;i<=n;i++){
for(int k=1;k<=m[i];k*=2){
m[i]-=k;
for(int j=W;j>=k*w[i];j--){
dp[j]=max(dp[j],dp[j-k*w[i]]+k*v[i]);
}
}
if(m[i]>0){
for(int j=W;j>=m[i]*w[i];j--){
dp[j]=max(dp[j],dp[j-m[i]*w[i]]+v[i]*m[i]);
}
}
}
cout<<dp[W];
return 0;
}
```

---

## 题目: P1781

**分类：算法--排序**

**提交时间：2025-02-20 21:45:53**

---
title: "宇宙总统"
layout: "post"
diff: 普及-
pid: P1781
tag: ['字符串', '高精度', '洛谷原创', '排序']
---
# 宇宙总统
## 题目描述

地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 $n$ 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。

## 输入格式

第一行为一个整数 $n$，代表竞选总统的人数。

接下来有 $n$ 行，分别为第一个候选人到第 $n$ 个候选人的票数。

## 输出格式

共两行，第一行是一个整数 $m$，为当上总统的人的号数。

第二行是当上总统的人的选票。

## 样例

### 样例输入 #1
```
5
98765
12365
87954
1022356
985678

```
### 样例输出 #1
```
4
1022356
```
## 提示

票数可能会很大，可能会到 $100$ 位数字。

$1 \leq n \leq 20$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct zt{
string s;
int num;
}a[25];
bool cmp(zt x,zt y){
if(x.s.size()>y.s.size()){
return true;
}
else if(x.s.size()==y.s.size()&&x.s>y.s){
return true;
}
return false;
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i].s;
a[i].num=i;
}
sort(a+1,a+n+1,cmp);
cout<<a[1].num<<endl;
cout<<a[1].s;
return 0;
}
```

---

## 题目: P1789

**分类：入门-数组**

**提交时间：2024-03-25 18:56:44**

---
title: "【Mc生存】插火把"
layout: "post"
diff: 入门
pid: P1789
tag: ['模拟', '洛谷原创']
---
# 【Mc生存】插火把
## 题目描述

话说有一天 linyorson 在“我的世界”开了一个 $n \times n$ 的方阵，现在他有 $m$ 个火把和 $k$ 个萤石，分别放在 $(x_1, y_1) \sim (x_m, y_m)$ 和 $(o_1, p_1) \sim (o_k, p_k)$ 的位置，没有光并且没放东西的地方会生成怪物。请问在这个方阵中有几个点会生成怪物？

P.S. 火把的照亮范围是：

```
    |暗|暗| 光 |暗|暗|
    |暗|光| 光 |光|暗|
    |光|光|火把|光|光|
    |暗|光| 光 |光|暗|
    |暗|暗| 光 |暗|暗|
```

萤石：

```
    |光|光| 光 |光|光|
    |光|光| 光 |光|光|
    |光|光|萤石|光|光|
    |光|光| 光 |光|光|
    |光|光| 光 |光|光|
```
## 输入格式

输入共 $m + k + 1$ 行。  
第一行为 $n, m, k$。  
第 $2$ 到第 $m + 1$ 行分别是火把的位置 $x_i, y_i$。  
第 $m + 2$ 到第 $m + k + 1$ 行分别是萤石的位置 $o_i, p_i$。

注：可能没有萤石，但一定有火把。
## 输出格式

有几个点会生出怪物。
## 样例

### 样例输入 #1
```
5 1 0
3 3

```
### 样例输出 #1
```
12

```
## 提示

数据保证，$1 \le n \le 100$，$1 \leq m+k \leq 25$，$1 \leq m \leq 25$，$0 \leq k \leq 5$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int a[200][200], n, m, k, x, y, sum = 0;
cin >> n >> m >> k;
for (int i = 1; i <= n; i++)
{
for (int j = 1; j <= n; j++)
{
a[i][j] = 0;
}
}
for (int i = 1; i <= m; i++)
{
cin >> x >> y;
a[x][y] = 1, a[x - 2][y] = 1, a[x - 1][y] = 1, a[x + 1][y] = 1, a[x + 2][y] = 1, a[x][y - 1] = 1, a[x][y - 2] = 1, a[x][y + 1] = 1, a[x][y + 2] = 1, a[x - 1][y - 1] = 1, a[x + 1][y - 1] = 1, a[x - 1][y + 1] = 1, a[x + 1][y + 1] = 1;
}
for (int i = 1; i <= k; i++)
{
if(k==0)
{
break;
}
cin >> x >> y;
for (int j = x - 2; j <= x + 2; j++)
{
for (int l = y - 2; l <= y + 2; l++)
{
a[j][l] = 1;
}
}
}
for (int i = 1; i <= n; i++)
{
for (int j = 1; j <= n; j++)
{
if(a[i][j]==0)
{
sum+=1;
}
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P1803

**分类：算法--贪心**

**提交时间：2024-11-04 20:39:10**

---
title: "凌乱的yyy / 线段覆盖"
layout: "post"
diff: 普及-
pid: P1803
tag: ['搜索', '贪心', '排序']
---
# 凌乱的yyy / 线段覆盖
## 题目背景

快 noip 了，yyy 很紧张！

## 题目描述

现在各大 oj 上有 $n$ 个比赛，每个比赛的开始、结束的时间点是知道的。

yyy 认为，参加越多的比赛，noip 就能考的越好（假的）。

所以，他想知道他最多能参加几个比赛。

由于 yyy 是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加 $2$ 个及以上的比赛。
## 输入格式

第一行是一个整数 $n$，接下来 $n$ 行每行是 $2$ 个整数 $a_{i},b_{i}\ (a_{i}<b_{i})$，表示比赛开始、结束的时间。
## 输出格式

一个整数最多参加的比赛数目。

## 样例

### 样例输入 #1
```
3
0 2
2 4
1 3

```
### 样例输出 #1
```
2

```
## 提示

- 对于 $20\%$ 的数据，$n \le 10$；
- 对于 $50\%$ 的数据，$n \le 10^3$；
- 对于 $70\%$ 的数据，$n \le 10^{5}$；
- 对于 $100\%$ 的数据，$1\le n \le 10^{6}$，$0 \le a_{i} < b_{i} \le 10^6$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=0,c=1;
double ans=0;
struct student{
int b,e;
}stu[1000005];
bool cmp(student x,student y){
if(x.e<y.e){
return true;
}
return false;
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>stu[i].b>>stu[i].e;
}
sort(stu+1,stu+n+1,cmp);
int end=stu[1].e;
for(int i=2;i<=n;i++){
if(stu[i].b>=end){
c++;
end=stu[i].e;
}
}
cout<<c;
return 0;
}
```

---

## 题目: P1824

**分类：二分**

**提交时间：2025-04-12 09:26:03**

---
title: "进击的奶牛"
layout: "post"
diff: 普及-
pid: P1824
tag: ['二分', 'USACO']
---
# 进击的奶牛
## 题目描述

Farmer John 建造了一个有 $N$（$2 \leq N \leq 10 ^ 5$) 个隔间的牛棚，这些隔间分布在一条直线上，坐标是 $x _ 1, x _ 2, \cdots, x _ N$（$0 \leq x _ i \leq 10 ^ 9$）。

他的 $C$（$2 \leq C \leq N$）头牛不满于隔间的位置分布，它们为牛棚里其他的牛的存在而愤怒。为了防止牛之间的互相打斗，Farmer John 想把这些牛安置在指定的隔间，所有牛中相邻两头的最近距离越大越好。那么，这个最大的最近距离是多少呢？
## 输入格式

第 $1$ 行：两个用空格隔开的数字 $N$ 和 $C$。

第 $2 \sim N+1$ 行：每行一个整数，表示每个隔间的坐标。
## 输出格式

输出只有一行，即相邻两头牛最大的最近距离。

## 样例

### 样例输入 #1
```
5 3
1
2
8
4
9
```
### 样例输出 #1
```
3
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,c,a[200005];
bool check(int x){
int pre=a[1],num=1;
for(int i=2;i<=n;i++){
if(a[i]-pre>=x){
pre=a[i];
num+=1;
}
}
return num<c;
}
int main(){
cin>>n>>c;
for(int i=1;i<=n;i++){
cin>>a[i];
}
sort(a+1,a+n+1);
int l=1,r=1e9+5;
while(l<r){
int mid=(l+r+1)/2;
if(check(mid)){
r=mid-1;
}
else{
l=mid;
}
}
cout<<l;
return 0;
}
```

---

## 题目: P1832

**分类：动态规划**

**提交时间：2025-03-23 14:19:34**

---
title: "A+B Problem（再升级）"
layout: "post"
diff: 普及-
pid: P1832
tag: ['动态规划 DP', '数学', '递推', '洛谷原创', '背包 DP', '素数判断,质数,筛法']
---
# A+B Problem（再升级）
## 题目背景

题目名称是吸引你点进来的。

实际上该题还是很水的。

## 题目描述

- $1+1=?$ 显然是 $2$。
- $a+b=?$ P1001 回看不谢。
- 哥德巴赫猜想 似乎已呈泛滥趋势。

_以上纯属个人吐槽_

给定一个正整数 $n$，求将其分解成若干个素数之和的方案总数。


## 输入格式

一行一个正整数 $n$。

## 输出格式

一行一个整数表示方案总数。
## 样例

### 样例输入 #1
```
7
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
20
```
### 样例输出 #2
```
26
```
## 提示

### 样例解释

存在如下三种方案：

- $7=7$。
- $7=2+5$。
- $7=2+2+3$。

### 数据范围及约定

- 对于 $30\%$ 的数据 $1\le n\le 10$。
- 对于 $100\%$ 的数据，$1\le n\le 10^3$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1005],c[1005],dp[1005]={1},cnt=0;
void prime(){
for(int i=2;i<=sqrt(1000);i++){
if(a[i]){
for(int j=i*i;j<=1000;j+=i){
a[j]=0;
}
}
}
}
int main(){
for(int i=1;i<=1000;i++){
a[i]=1;
}
a[1]=0;
prime();
cin>>n;
for(int i=1;i<=n;i++){
if(a[i]==1){
cnt+=1;
c[cnt]=i;
}
}
for(int i=1;i<=cnt;i++){
for(int j=c[i];j<=n;j++){
dp[j]+=dp[j-c[i]];
}
}
cout<<dp[n];
return 0;
}
```

---

## 题目: P1833

**分类：动态规划-线性状态动态规划**

**提交时间：2025-04-01 20:08:15**

---
title: "樱花"
layout: "post"
diff: 普及/提高-
pid: P1833
tag: ['动态规划 DP', '洛谷原创', '背包 DP']
---
# 樱花
## 题目背景

《爱与愁的故事第四弹·plant》第一章。

## 题目描述

爱与愁大神后院里种了 $n$ 棵樱花树，每棵都有美学值 $C_i(0 \le C_i \le 200)$。爱与愁大神在每天上学前都会来赏花。爱与愁大神可是生物学霸，他懂得如何欣赏樱花：一种樱花树看一遍过，一种樱花树最多看 $P_i(0 \le P_i \le 100)$ 遍，一种樱花树可以看无数遍。但是看每棵樱花树都有一定的时间 $T_i(0 \le T_i \le 100)$。爱与愁大神离去上学的时间只剩下一小会儿了。求解看哪几棵樱花树能使美学值最高且爱与愁大神能准时（或提早）去上学。

## 输入格式

共 $n+1$行：

第 $1$ 行：现在时间 $T_s$（几时：几分），去上学的时间 $T_e$（几时：几分），爱与愁大神院子里有几棵樱花树 $n$。这里的 $T_s$，$T_e$ 格式为：`hh:mm`，其中 $0 \leq hh \leq 23$，$0 \leq mm \leq 59$，且 $hh,mm,n$ 均为正整数。

第 $2$ 行到第 $n+1$ 行，每行三个正整数：看完第 $i$ 棵树的耗费时间 $T_i$，第 $i$ 棵树的美学值 $C_i$，看第 $i$ 棵树的次数 $P_i$（$P_i=0$ 表示无数次，$P_i$ 是其他数字表示最多可看的次数 $P_i$）。

## 输出格式

只有一个整数，表示最大美学值。

## 样例

### 样例输入 #1
```
6:50 7:00 3
2 1 0
3 3 1
4 5 4
```
### 样例输出 #1
```
11
```
## 提示

$100\%$ 数据：$T_e-T_s \leq 1000$（即开始时间距离结束时间不超过 $1000$ 分钟），$n \leq 10000$。保证 $T_e,T_s$ 为同一天内的时间。

样例解释：赏第一棵樱花树一次，赏第三棵樱花树 $2$ 次。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t1,t2,t3,t4;
int n,m,w[10005],v[10005],p[10005];
int dp[1005];
char c;
int main(){
cin>>t1>>c>>t2>>t3>>c>>t4>>n;
m=60*(t3-t1)+t4-t2;
for(int i=1;i<=n;i++){
cin>>w[i]>>v[i]>>p[i];
}
for(int i=1;i<=n;i++){
if(p[i]==0){
for(int j=w[i];j<=m;j++){
dp[j]=max(dp[j],dp[j-w[i]]+v[i]);
}
}
else{
for(int k=1;k<=p[i];k*=2){
p[i]-=k;
for(int j=m;j>=k*w[i];j--){
dp[j]=max(dp[j],dp[j-k*w[i]]+k*v[i]);
}
}
if(p[i]>0){
for(int j=m;j>=p[i]*w[i];j--){
dp[j]=max(dp[j],dp[j-p[i]*w[i]]+p[i]*v[i]);
}
}
}
}
cout<<dp[m];
return 0;
}
```

---

## 题目: P1865

**提交时间：2024-12-01 10:31:53**

---
title: "A % B Problem"
layout: "post"
diff: 普及/提高-
pid: P1865
tag: ['搜索', '洛谷原创', '素数判断,质数,筛法', '前缀和']
---
# A % B Problem
## 题目背景

题目名称是吸引你点进来的。    
实际上该题还是很水的。
## 题目描述

给定 $l, r$，求区间 $[l, r]$ 内质数的个数。
## 输入格式

第一行有两个整数，分别代表询问次数 $n$ 和 给定区间的右端点最大值 $m$。

接下来 $n$ 行，每行两个整数 $l, r$，代表一次查询。
## 输出格式

对于每次查询输出一行，若 $l, r \in [1, m]$，则输出区间质数个数，否则输出 `Crossing the line`。

## 样例

### 样例输入 #1
```
2 5
1 3
2 6
```
### 样例输出 #1
```
2
Crossing the line
```
## 提示

#### 数据范围与约定

- 对于 $20\%$ 的数据，保证 $n,m\le 10$。
- 对于 $100\%$ 的数据，保证 $1\le n\le1000$，$1\le m\le10^6$，$-10^9\le l\le r\le 10^9$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000005],l,r,sum=0;
void prime(){
for(int i=2;i<=sqrt(1000000);i++){
if(a[i]){
for(int j=i*i;j<=1000000;j+=i){
a[j]=0;
}
}
}
}
int main(){
for(int i=1;i<=1000000;i++){
a[i]=1;
}
prime();
cin>>n>>m;
for(int i=1;i<=n;i++){
cin>>l>>r;
if(l<1||r>m){
cout<<"Crossing the line"<<endl;
}
else{
sum=0;
for(int j=l;j<=r;j++){
if(a[j]==1){
sum+=1;
}
}
if(l==1){
sum-=1;
}
cout<<sum<<endl;
}
}
return 0;
}
```

---

## 题目: P1867

**提交时间：2024-02-28 16:39:50**

---
title: "【Mc生存】经验值"
layout: "post"
diff: 入门
pid: P1867
tag: ['模拟', '洛谷原创']
---
# 【Mc生存】经验值
## 题目背景

初一福利第2弹。。。

## 题目描述

话说 clearman 在 MC 世界开了个祥艺奶牛场，用岩浆、TNT 等丧心病狂的折磨牛，获取牛肉、牛奶等刷经验。他想知道他到底达到什么层次。

他总共进行了 $n$ 项操作，每次操作要付出 $x$ 生命值（初始生命是 $10$ 点，初一党都知道！并且要先计算付出的生命值，如果小于等于 $0$，则死亡，本次及以下操作都无效。但切记：付出生命值可以是负数，也就是说可以回复 $−x$ 点生命值，但上限只能是 $10$！切记！），每次操作可以获得 $a$ 经验值（不能为负），他最后能达到 $m$ 级 $t$ 经验。

P.S. 关于等级

初始等级为 $0$。每加 $2^m$（$m$ 为当前等级）点经验可升一级。  

1、假设 clearman 一共得到 $15$ 点经验，那么他应该为 $4$ 级（ $15-1-2-4-8=0$）加 $0$ 点经验。    
2、假设 clearman 一共获得 $39$ 点经验，那么他应该为 $5$ 级（ $39-1-2-4-8-16=8$）加 $8$ 点经验。

## 输入格式

第一行一个正整数 $n$，表示操作个数。

接下来 $n$ 行，每行两个数，为 clearman 的一次操作。

## 输出格式

一行，为等级和经验值。

## 样例

### 样例输入 #1
```
2
5.5 15
4.5 24

```
### 样例输出 #1
```
4 0
```
## 提示

数据很弱，人肉输的，但是很坑。。。

【数据范围】  
对于 $100\%$ 的数据，$1\le n \le 20$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,sum;
double blood=10,t;
int main(){
cin>>n;
while(n--){
cin>>t>>x;
blood=min(blood-t,10.0);
if(blood<=0) break;
sum+=x;
}
cout<<floor(log(sum+1)/log(2))<<" "<<sum+1-pow(2,floor(log(sum+1)/log(2)));
return 0;
}
```

---

## 题目: P1873

**分类：算法--二分查找与二分答案**

**提交时间：2024-10-11 16:10:30**

---
title: "[COCI 2011/2012 #5] EKO / 砍树"
layout: "post"
diff: 普及/提高-
pid: P1873
tag: ['2011', '二分', 'COCI（克罗地亚）']
---
# [COCI 2011/2012 #5] EKO / 砍树
## 题目描述

伐木工人 Mirko 需要砍 $M$ 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。

Mirko 的伐木机工作流程如下：Mirko 设置一个高度参数 $H$（米），伐木机升起一个巨大的锯片到高度 $H$，并锯掉所有树比 $H$ 高的部分（当然，树木不高于 $H$ 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 $20,15,10$ 和 $17$，Mirko 把锯片升到 $15$ 米的高度，切割后树木剩下的高度将是 $15,15,10$ 和 $15$，而 Mirko 将从第 $1$ 棵树得到 $5$ 米，从第 $4$ 棵树得到 $2$ 米，共得到 $7$ 米木材。

Mirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 $H$，使得他能得到的木材至少为 $M$ 米。换句话说，如果再升高 $1$ 米，他将得不到 $M$ 米木材。
## 输入格式

第 $1$ 行 $2$ 个整数 $N$ 和 $M$，$N$ 表示树木的数量，$M$ 表示需要的木材总长度。

第 $2$ 行 $N$ 个整数表示每棵树的高度。
## 输出格式

$1$ 个整数，表示锯片的最高高度。
## 样例

### 样例输入 #1
```
4 7
20 15 10 17
```
### 样例输出 #1
```
15
```
### 样例输入 #2
```
5 20
4 42 40 26 46
```
### 样例输出 #2
```
36
```
## 提示

对于 $100\%$ 的测试数据，$1\le N\le10^6$，$1\le M\le2\times10^9$，树的高度 $\le 4\times 10^5$，所有树的高度总和 $>M$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[1000005];
int judge(int h){
long long sum=0;
for(int i=1;i<=n;i++){
sum+=max(a[i]-h,0);
}
if(sum>=m){
return 1;
}
return 0;
}
int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++){
scanf("%d",&a[i]);
}
int l=0,r=400001;
while(l<r){
int mid=(l+r)/2;
if(judge(mid)){
l=mid+1;
}
else{
r=mid;
}
}
cout<<l-1;
return 0;
}
```

---

## 题目: P1877

**分类：动态规划**

**提交时间：2025-03-23 10:05:34**

---
title: "[HAOI2012] 音量调节"
layout: "post"
diff: 普及-
pid: P1877
tag: ['动态规划 DP', '2012', '河南', '各省省选', '枚举', '背包 DP']
---
# [HAOI2012] 音量调节
## 题目描述

一个吉他手准备参加一场演出。他不喜欢在演出时始终使用同一个音量，所以他决定每一首歌之前他都需要改变一次音量。在演出开始之前，他已经做好一个列表，里面写着每首歌开始之前他想要改变的音量是多少。每一次改变音量，他可以选择调高也可以调低。

音量用一个整数描述。输入文件中整数 $beginLevel$，代表吉他刚开始的音量，整数 $maxLevel$，代表吉他的最大音量。音量不能小于 $0$ 也不能大于 $maxLevel$。输入中还给定了 $n$ 个整数 $c_1,c_2,c_3,\cdots,c_n$，表示在第 $i$ 首歌开始之前吉他手想要改变的音量是多少。

吉他手想以最大的音量演奏最后一首歌，你的任务是找到这个最大音量是多少。
## 输入格式

第一行依次为三个整数 $n$，$beginLevel$ 和 $maxLevel$。

第二行依次为 $n$ 个整数 $c_1,c_2,c_3,\cdots,c_n$。
## 输出格式

输出演奏最后一首歌的最大音量。如果吉他手无法避免音量低于 $0$ 或者高于 $maxLevel$，输出 `-1`。
## 样例

### 样例输入 #1
```
3 5 10
5 3 7

```
### 样例输出 #1
```
10
```
## 提示

$1\le n\le 50$，$1\le c_i\le beginLevel$，$1\le maxLevel\le 1000$，$0\le beginLevel\le maxLevel$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,bl,ml,a[55],dp[1005][1005],maxx=-1;
int main(){
cin>>n>>bl>>ml;
for(int i=1;i<=n;i++){
cin>>a[i];
}
dp[0][bl]=1;
for(int i=1;i<=n;i++){
for(int j=0;j<=ml;j++){
if(dp[i-1][j]&&j+a[i]<=ml){
dp[i][j+a[i]]=1;
}
if(dp[i-1][j]&&j-a[i]>=0){
dp[i][j-a[i]]=1;
}
}
}
bool flag=0;
for(int i=ml;i>=0;i--){
if(dp[n][i]==1){
cout<<i;
flag=1;
break;
}
}
if(flag==0){
cout<<-1;
}
return 0;
}
```

---

## 题目: P1880

**分类：动态规划-区间与环形动态规划**

**提交时间：2025-04-13 14:51:33**

---
title: "[NOI1995] 石子合并"
layout: "post"
diff: 普及+/提高
pid: P1880
tag: ['动态规划 DP', 'NOI', '区间 DP', '四边形不等式']
---
# [NOI1995] 石子合并
## 题目描述

在一个圆形操场的四周摆放 $N$ 堆石子，现要将石子有次序地合并成一堆，规定每次只能选相邻的 $2$ 堆合并成新的一堆，并将新的一堆的石子数，记为该次合并的得分。

试设计出一个算法,计算出将 $N$ 堆石子合并成 $1$ 堆的最小得分和最大得分。

## 输入格式

数据的第 $1$ 行是正整数 $N$，表示有 $N$ 堆石子。

第 $2$ 行有 $N$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 堆石子的个数。

## 输出格式

输出共 $2$ 行，第 $1$ 行为最小得分，第 $2$ 行为最大得分。

## 样例

### 样例输入 #1
```
4
4 5 9 4
```
### 样例输出 #1
```
43
54
```
## 提示

$1\leq N\leq 100$，$0\leq a_i\leq 20$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[205],q[205];
int dp[205][205];
int minn=INT_MAX,maxx=-1;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
a[i+n]=a[i];
}
for(int i=1;i<=2*n;i++){
q[i]=q[i-1]+a[i];
}
memset(dp,0x3f3f3f,sizeof(dp));
for(int i=1;i<=2*n;i++){
dp[i][i]=0;
}
for(int len=2;len<=n;len++){
for(int i=1;i<=2*n;i++){
int j=i+len-1;
if(j>2*n){
break;
}
for(int k=i;k<j;k++){
dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+q[j]-q[i-1]);
}
}
}
for(int i=1;i<=n;i++){
minn=min(dp[i][n+i-1],minn);
}
cout<<minn<<endl;
memset(dp,0,sizeof(dp));
for(int i=1;i<=2*n;i++){
dp[i][i]=0;
}
for(int len=2;len<=n;len++){
for(int i=1;i<=2*n;i++){
int j=i+len-1;
if(j>2*n){
break;
}
for(int k=i;k<j;k++){
dp[i][j]=max(dp[i][j],dp[i][k]+dp[k+1][j]+q[j]-q[i-1]);
}
}
}
for(int i=1;i<=n;i++){
maxx=max(dp[i][n+i-1],maxx);
}
cout<<maxx<<endl;
return 0;
}
```

---

## 题目: P1888

**分类：入门-分支结构**

**提交时间：2024-03-29 14:46:18**

---
title: "三角函数"
layout: "post"
diff: 入门
pid: P1888
tag: ['数学', '排序', '最大公约数 gcd']
---
# 三角函数
## 题目描述

输入一组勾股数 $a,b,c（a\neq b\neq c）$，用分数格式输出其较小锐角的正弦值。（要求约分。）

## 输入格式

一行，包含三个正整数，即勾股数 $a,b,c$（无大小顺序）。

## 输出格式

一行，包含一个分数，即较小锐角的正弦值

## 样例

### 样例输入 #1
```
3 5 4
```
### 样例输出 #1
```
3/5
```
## 提示

数据保证：$a,b,c$ 为正整数且 $\in [1,10^9]$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
int a[4];
for (int i=0;i<3;i++)
{
cin>>a[i];
}
sort(a,a+3);
cout<<a[0]/__gcd(a[0],a[2])<<'/'<<a[2]/__gcd(a[0],a[2]);
return 0;
}
```

---

## 题目: P1909

**分类：入门-分支结构**

**提交时间：2024-02-28 16:46:57**

---
title: "[NOIP 2016 普及组] 买铅笔"
layout: "post"
diff: 入门
pid: P1909
tag: ['模拟', '2016', 'NOIP 普及组']
---
# [NOIP 2016 普及组] 买铅笔
## 题目背景

NOIP2016 普及组 T1
## 题目描述

P 老师需要去商店买 $n$ 支铅笔作为小朋友们参加 NOIP 的礼物。她发现商店一共有 $3$ 种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起见，P 老师决定只买同一种包装的铅笔。

商店不允许将铅笔的包装拆开，因此 P 老师可能需要购买超过 $n$ 支铅笔才够给小朋友们发礼物。

现在 P 老师想知道，在商店每种包装的数量都足够的情况下，要买够至少 $n$ 支铅笔最少需要花费多少钱。

## 输入格式

第一行包含一个正整数 $n$，表示需要的铅笔数量。

接下来三行，每行用 $2$ 个正整数描述一种包装的铅笔：其中第 $1$ 个整数表示这种包装内铅笔的数量，第 $2$ 个整数表示这种包装的价格。

保证所有的 $7$ 个数都是不超过 $10000$ 的正整数。

## 输出格式

$1$ 个整数，表示 P 老师最少需要花费的钱。

## 样例

### 样例输入 #1
```
57
2 2
50 30
30 27
```
### 样例输出 #1
```
54
```
### 样例输入 #2
```
9998
128 233
128 2333
128 666
```
### 样例输出 #2
```
18407
```
### 样例输入 #3
```
9999
101 1111
1 9999
1111 9999
```
### 样例输出 #3
```
89991
```
## 提示

铅笔的三种包装分别是：

- $2$ 支装，价格为 $2$;
- $50$ 支装，价格为 $30$;
- $30$ 支装，价格为 $27$。

P 老师需要购买至少 $57$ 支铅笔。

如果她选择购买第一种包装，那么她需要购买 $29$ 份，共计 $2 \times 29 = 58$ 支，需要花费的钱为 $2 \times 29 = 58$。

实际上，P 老师会选择购买第三种包装，这样需要买 $2$ 份。虽然最后买到的铅笔数量更多了，为 $30 \times 2 = 60$ 支，但花费却减少为 $27 \times 2 = 54$，比第一种少。

对于第二种包装，虽然每支铅笔的价格是最低的，但要够发必须买 $2$ 份，实际的花费达到了 $30  \times 2 = 60$，因此 P 老师也不会选择。

所以最后输出的答案是 $54$。

**数据范围**

保证所有的 $7$ 个数都是不超过 $10000$ 的正整数。

**子任务**

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表：

![](https://cdn.luogu.com.cn/upload/image_hosting/dlgsz3h4.png)

上表中“整倍数”的意义为：若为 $K$，表示对应数据所需要的铅笔数量 $n$ —定是每种包装铅笔数量的整倍数（这意味着一定可以不用多买铅笔）。

于 2022 年 12 月 23 日新加 Hack 数据三组。


### 代码

```cpp
#include<bits/stdc++.h>
#include<cstdio>
using namespace std;
int i,j,k,n,m,w,ans;
int main(){
scanf("%d",&n);
for(i=0;i<3;i++){
scanf("%d%d",&j,&k);m=j;w=k;
while(j<n){j<<=1;k<<=1;}
while(j>n){j-=m;k-=w;}
while(j<n){j+=m;k+=w;}
if(k<ans||ans==0)ans=k;
}
printf("%d\n",ans);
return 0;
}
```

---

## 题目: P1914

**分类：入门-字符串**

**提交时间：2024-02-02 17:06:02**

---
title: "小书童——凯撒密码"
layout: "post"
diff: 入门
pid: P1914
tag: ['模拟', '字符串']
---
# 小书童——凯撒密码
## 题目背景

某蒟蒻迷上了 “小书童”，有一天登陆时忘记密码了（他没绑定邮箱 or 手机），于是便把问题抛给了神犇你。

## 题目描述

蒟蒻虽然忘记密码，但他还记得密码是由一个字符串组成。密码是由原文字符串（由不超过 50 个小写字母组成）中每个字母向后移动 $n$ 位形成的。`z` 的下一个字母是 `a`，如此循环。他现在找到了移动前的原文字符串及 $n$，请你求出密码。
## 输入格式

第一行：$n$。第二行：未移动前的一串字母。

## 输出格式

一行，是此蒟蒻的密码。
## 样例

### 样例输入 #1
```
1
qwe
```
### 样例输出 #1
```
rxf
```
## 提示

字符串长度 $\le 50$，$1 \leq n \leq 26$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
char a[200];//开个大点的字符串
int n,i,la,b[200];//b数组用来转换
cin>>n>>a;
la=strlen(a);//取长度
for(i=0;i<la;i++)
b[i]=a[i];//转换
for(i=0;i<la;i++)
b[i]=b[i]+n;//破解密码
for(i=0;i<la;i++)
{
if(b[i]>122)//z的ASCLL码是122
b[i]=b[i]%122+96; //循环会'a'，a的ASCLL码是96
}
for(i=0;i<la;i++)
{
a[i]=b[i];//转换回去，输出
cout<<a[i];
}
return 0;
}
```

---

## 题目: P1923

**分类：算法--排序**

**提交时间：2024-08-31 21:29:54**

---
title: "【深基9.例4】求第 k 小的数"
layout: "post"
diff: 普及-
pid: P1923
tag: []
---
# 【深基9.例4】求第 k 小的数
## 题目描述

输入 $n$（$1 \le n < 5000000$ 且 $n$ 为奇数）个数字 $a_i$（$1 \le a_i < {10}^9$），输出这些数字的第 $k$ 小的数。最小的数是第 $0$ 小。

请尽量不要使用 `nth_element` 来写本题，因为本题的重点在于练习分治算法。
## 样例

### 样例输入 #1
```
5 1
4 3 2 1 5

```
### 样例输出 #1
```
2

```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[5000005];
int main()
{
ios::sync_with_stdio(false);
cin.tie(0);
cout.tie(0);
cin>>n>>k;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
nth_element(a,a+k+1,a+n+1);
cout<<a[k+1];
return 0;
}
```

---

## 题目: P1926

**提交时间：2024-08-16 15:42:28**

---
title: "小书童——刷题大军"
layout: "post"
diff: 普及-
pid: P1926
tag: ['动态规划 DP', '搜索', '排序', '背包 DP']
---
# 小书童——刷题大军
## 题目背景

数学是火，点亮物理的灯；物理是灯，照亮化学的路；化学是路，通向生物的坑；生物是坑，埋葬学理的人。  
文言是火，点亮历史宫灯；历史是灯，照亮社会之路；社会是路，通向哲学大坑；哲学是坑，埋葬文科生。——小 A

## 题目描述

小 A “刷题”十分猖狂，明目张胆地“刷题”。他现在在小书童里发现了 $n$ 样他喜欢的“题目”，每“题”都有他的需要时间，而老师布置了 $m$ 项作业，每项作业都有它的需要时间及分值，老师规定 $k$ 分以上算及格。小 A 只剩 $r$ 个单位时间，他想在及格的基础上更多地“刷题”。
## 输入格式

第一行四个整数 $n,m,k,r$。

第二行有 $n$ 个数，代表每“题”他的需要时间。

第三行有 $m$ 个数，表示每项作业它的需要时间。

第四行有 $m$ 个数，代表每项作业它的分值。
## 输出格式

一个数，代表小 A 能刷几道题。

## 样例

### 样例输入 #1
```
3 4 20 100
15 20 50
10 15 40 40
5 5 10 15
```
### 样例输出 #1
```
2
```
## 提示

### 数据范围及约定


对于 $100\%$ 的数据，$n\le 10$，$m\le 10$，$k\le 50$，$r\le 150$。数据保证没有不能及格的情况。



### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n,m,k,r;
int a[11],w[11],c[11],f[501]={0};
int stt,stn=0;
int main()
{
cin>>n>>m>>k>>r;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
sort(a+1,a+n+1);
for(int i=1;i<=m;i++)
{
cin>>w[i];
}
for(int i=1;i<=m;i++)
{
cin>>c[i];
}
for(int i=1;i<=n;i++)
{
for(int j=r;j>=w[i];j--)
{
f[j]=max(f[j],f[j-w[i]]+c[i]);
}
}
for(int i=1;i<=r;i++)
{
if(f[i]>=k)
{
stt=r-i;
break;
}
}
for(int i=1;i<=n;i++)
{
stt-=a[i];
if(stt<=0)
{
break;
}
stn++;
}
cout<<stn<<endl;
return 0;
}
```

---

## 题目: P1964

**分类：动态规划**

**提交时间：2025-04-02 20:09:39**

---
title: "【mc生存】卖东西"
layout: "post"
diff: 普及-
pid: P1964
tag: ['动态规划 DP']
---
# 【mc生存】卖东西
## 题目背景

服务器好好玩。
## 题目描述

lcy0x1 去服务器的系统商店买东西。

一个人的背包有 $21$ 格。

一开始他的背包里有 $m$ 件不同的物品（**不能卖**）。

他要买 $n$ 种物品，第 $i$ 件物品的名字为 $st_i$，有 $a_i$ 件，价值为 $b_i$，一格可以放 $c_i$ 个。

相同的物品可以放同一格（只要没放满）。

问：他跑一次最多能卖多少钱。
## 输入格式

第一行两个整数 $m,n$。

下面 $n$ 行，第 $i+1$ 行三个整数 $a_i,b_i,c_i$ 与一个字符串 $st_i$。

## 输出格式

最多卖的钱 $s$。
## 样例

### 样例输入 #1
```
20 3

63 1 64 yinshifen

1 10 1 men

1 1 64 yinshifen
```
### 样例输出 #1
```
64
```
## 提示

数据保证：

- $0\leq m\leq 21$；
- $0\leq n\leq 100$；
- $0\leq a_i\leq 1344$；
- $0\leq b_i\leq 10^4$；
- $0<c_i\leq 64$；
- $0<|st_i|<100$；
- $0\leq s\leq 10^6$。

**注：数据强大，搜索 $0$ 分，请使用多重背包。**


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,cnt,ans=0;
struct thing{
int num,v,sum;
string s;
}a[134405];
bool cmp(thing x,thing y){
if(x.s<y.s){
return true;
}
return false;
}
bool cmp1(thing x,thing y){
if(x.num*x.v>y.num*y.v){
return true;
}
return false;
}
int main(){
cin>>m>>n;
for(int i=1;i<=n;i++){
cin>>a[i].num>>a[i].v>>a[i].sum>>a[i].s;
}
sort(a+1,a+n+1,cmp);
cnt=n;
for(int i=1;i<=cnt;i++){
if(a[i].s==a[i+1].s&&a[i].s!=""){
if(a[i].num+a[i+1].num<=a[i].sum){
a[i].num+=a[i+1].num;
a[i+1].s="",a[i+1].num=0,a[i+1].v=0,a[i+1].sum=0;
}
else{
a[i+1].num-=(a[i].sum-a[i].num);
a[i].num=a[i].sum;
}
}
if(a[i].num>a[i].sum){
cnt+=1;
a[cnt].s=a[i].s,a[cnt].num=a[i].num-a[i].sum,a[cnt].v=a[i].v,a[cnt].sum=a[i].sum;
a[i].num=a[i].sum;
}
}
sort(a+1,a+cnt+1,cmp1);
for(int i=1;i<=21-m;i++){
ans+=a[i].num*a[i].v;
}
cout<<ans;
return 0;
}
```

---

## 题目: P1980

**分类：入门-循环结构**

**提交时间：2024-01-14 08:57:45**

---
title: "[NOIP 2013 普及组] 计数问题"
layout: "post"
diff: 入门
pid: P1980
tag: ['模拟', '字符串', '2013', 'NOIP 普及组']
---
# [NOIP 2013 普及组] 计数问题
## 题目背景

NOIP2013 普及组 T1
## 题目描述

试计算在区间 $1$ 到 $n$ 的所有整数中，数字 $x$（$0\le x\le9$）共出现了多少次？例如，在 $1$ 到 $11$ 中，即在 $1,2,3,4,5,6,7,8,9,10,11$ 中，数字 $1$ 出现了 $4$ 次。
## 输入格式

$2$ 个整数 $n,x$，之间用一个空格隔开。
## 输出格式

$1$ 个整数，表示 $x$ 出现的次数。
## 样例

### 样例输入 #1
```
11 1
```
### 样例输出 #1
```
4
```
## 提示

对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\le x \le 9$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,x,a[10],y;
int main()
{
cin>>n>>x;
for(int i=1;i<=n;i++)
{
string str=to_string(i);
for(char c:str)
{
y=c-'0';
a[y]+=1;
}
}
cout<<a[x];
return 0;
}
```

---

## 题目: P1996

**分类：数据结构--线性表**

**提交时间：2025-03-14 16:38:56**

---
title: "约瑟夫问题"
layout: "post"
diff: 普及-
pid: P1996
tag: ['模拟', '树状数组', '队列']
---
# 约瑟夫问题
## 题目描述

$n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

**注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 $n-1$ 名小朋友，而该题是全部出圈。**

## 输入格式

输入两个整数 $n,m$。
## 输出格式

输出一行 $n$ 个整数，按顺序输出每个出圈人的编号。
## 样例

### 样例输入 #1
```
10 3
```
### 样例输出 #1
```
3 6 9 2 7 1 8 5 10 4
```
## 提示

$1 \le m, n \le 100$



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,vis[105],sum,x,temp;
int main(){
cin>>n>>k;
temp=k;
while(sum<n){
x+=1;
if(x==n+1){
x=1;
}
if(vis[x]==0){
temp-=1;
if(temp==0){
vis[x]=1;
temp=k;
sum+=1;
cout<<x<<" ";
}
}
}
return 0;
}
```

---

## 题目: P2004

**分类：算法--前缀和、差分与离散化**

**提交时间：2024-10-27 14:52:54**

---
title: "领地选择"
layout: "post"
diff: 普及-
pid: P2004
tag: ['洛谷原创', '前缀和']
---
# 领地选择
## 题目描述

作为在虚拟世界里统帅千军万马的领袖，小 Z 认为天时、地利、人和三者是缺一不可的，所以，谨慎地选择首都的位置对于小 Z 来说是非常重要的。

首都被认为是一个占地 $C\times C$ 的正方形。小 Z 希望你寻找到一个合适的位置，使得首都所占领的位置的土地价值和最高。

## 输入格式

第一行三个整数 $N,M,C$，表示地图的宽和长以及首都的边长。

接下来 $N$ 行每行 $M$ 个整数，表示了地图上每个地块的价值。价值可能为负数。
## 输出格式

一行两个整数 $X,Y$，表示首都左上角的坐标。
## 样例

### 样例输入 #1
```
3 4 2
1 2 3 1
-1 9 0 2
2 0 1 1

```
### 样例输出 #1
```
1 2

```
## 提示

对于 $60\%$ 的数据，$N,M\le 50$。

对于 $90\%$ 的数据，$N,M\le 300$。

对于 $100\%$ 的数据，$1\le N,M\le 10^3$，$1\le C\le \min(N,M)$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,c,maxn=-1e9,x,y;
long long a[1005][1005],b[1005][1005];
int main(){
cin>>n>>m>>c;
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
cin>>a[i][j];
b[i][j]=b[i-1][j]+b[i][j-1]-b[i-1][j-1]+a[i][j];
}
}
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
long long s=0;
if(i+c-1<=n&&j+c-1<=m){
s=b[i+c-1][j+c-1]-b[i-1][j+c-1]-b[i+c-1][j-1]+b[i-1][j-1];
}
if(maxn<s){
x=i;
y=j;
maxn=s;
}
}
}
cout<<x<<" "<<y;
return 0;
}
```

---

## 题目: P2036

**分类：算法--搜索**

**提交时间：2024-12-29 14:03:57**

---
title: "[COCI 2008/2009 #2] PERKET"
layout: "post"
diff: 普及-
pid: P2036
tag: ['模拟', '搜索', '2008', 'COCI（克罗地亚）']
---
# [COCI 2008/2009 #2] PERKET
## 题目描述

Perket 是一种流行的美食。为了做好 Perket，厨师必须谨慎选择食材，以在保持传统风味的同时尽可能获得最全面的味道。你有 $n$ 种可支配的配料。对于每一种配料，我们知道它们各自的酸度 $s$ 和苦度 $b$。当我们添加配料时，总的酸度为每一种配料的酸度总乘积；总的苦度为每一种配料的苦度的总和。

众所周知，美食应该做到口感适中，所以我们希望选取配料，以使得酸度和苦度的绝对差最小。

另外，我们必须添加至少一种配料，因为没有任何食物以水为配料的。
## 输入格式

第一行一个整数 $n$，表示可供选用的食材种类数。

接下来 $n$ 行，每行 $2$ 个整数 $s_i$ 和 $b_i$，表示第 $i$ 种食材的酸度和苦度。
## 输出格式

一行一个整数，表示可能的总酸度和总苦度的最小绝对差。
## 样例

### 样例输入 #1
```
1
3 10
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
2
3 8
5 8
```
### 样例输出 #2
```
1
```
### 样例输入 #3
```
4
1 7
2 6
3 8
4 9
```
### 样例输出 #3
```
1
```
## 提示

#### 数据规模与约定
对于 $100\%$ 的数据，有 $1 \leq n \leq 10$，且将所有可用食材全部使用产生的总酸度和总苦度小于 $1 \times 10^9$，酸度和苦度不同时为 $1$ 和 $0$。
#### 说明
- 本题满分 $70$ 分。
- 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) PERKET，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s[15],k[15],b[15],ans=INT_MAX,sd,kd;
void dfs(int x){
if(x==n+1){
sd=1,kd=0;
for(int i=1;i<=n;i++){
if(b[i]==1){
sd*=s[i];
kd+=k[i];
ans=min(ans,abs(sd-kd));
}
}
return;
}
for(int i=0;i<=1;i++){
b[x]=i;
dfs(x+1);
}
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>s[i]>>k[i];
}
dfs(1);
cout<<ans;
return 0;
}
```

---

## 题目: P2089

**分类：算法--暴力枚举**

**提交时间：2024-10-13 14:45:38**

---
title: "烤鸡"
layout: "post"
diff: 普及-
pid: P2089
tag: ['搜索', '递归', '洛谷原创', '枚举']
---
# 烤鸡
## 题目背景

猪猪 Hanke 得到了一只鸡。

## 题目描述

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 $10$ 种配料（芥末、孜然等），每种配料可以放 $1$ 到 $3$ 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。
## 输入格式

一个正整数 $n$，表示美味程度。
## 输出格式

第一行，方案总数。

第二行至结束，$10$ 个数，表示每种配料所放的质量，按字典序排列。

如果没有符合要求的方法，就只要在第一行输出一个 $0$。
## 样例

### 样例输入 #1
```
11
```
### 样例输出 #1
```
10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1 
```
## 提示

对于 $100\%$ 的数据，$n \leq 5000$。


### 代码

```cpp
#include<bits/stdc++.h>
#define def(i) for(int i=1;i<=3;i++)
using namespace std;
int n,sum=0;
int main(){
cin>>n;
if(n>30){
cout<<0;
return 0;
}
def(a)def(b)def(c)def(d)def(e)def(f)def(g)def(h)def(i)def(j){
if(a+b+c+d+e+f+g+h+i+j==n){
sum+=1;
}
}
cout<<sum<<endl;
def(a)def(b)def(c)def(d)def(e)def(f)def(g)def(h)def(i)def(j){
if(a+b+c+d+e+f+g+h+i+j==n){
cout<<a<<" "<<b<<" "<<c<<" "<<d<<" "<<e<<" "<<f<<" "<<g<<" "<<h<<" "<<i<<" "<<j<<endl;
}
}
return 0;
}
```

---

## 题目: P2141

**分类：入门-数组**

**提交时间：2024-03-26 19:10:37**

---
title: "[NOIP 2014 普及组] 珠心算测验"
layout: "post"
diff: 普及-
pid: P2141
tag: ['模拟', '2014', 'NOIP 普及组', '枚举']
---
# [NOIP 2014 普及组] 珠心算测验
## 题目背景

NOIP2014 普及 T1
## 题目描述

珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。


某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？


最近老师出了一些测验题，请你帮忙求出答案。

## 输入格式

共两行，第一行包含一个整数 $n$，表示测试题中给出的正整数个数。


第二行有 $n$ 个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。

## 输出格式

一个整数，表示测验题答案。

## 样例

### 样例输入 #1
```
4
1 2 3 4
```
### 样例输出 #1
```
2
```
## 提示

【样例说明】


由 $1+2=3,1+3=4$，故满足测试要求的答案为 $2$。  

注意，加数和被加数必须是集合中的两个不同的数。


【数据说明】


对于 $100\%$ 的数据，$3 \leq n \leq 100$，测验题给出的正整数大小不超过 $10,000$。



### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int n, a[105], sum = 0, x[105] = {0};
cin >> n;
for (int i = 0; i < n; i++)
{
cin >> a[i];
}
for (int i = 0; i < n; i++)
{
for (int j = n - 1; j > i; j--)
{
for (int k = 0; k < n; k++)
{
if (k == i || k == j || x[k])
{
continue;
}
if (a[i] + a[j] == a[k])
{
sum += 1;
x[k] = 1;
}
}
}
}
cout << sum;
return 0;
}
```

---

## 题目: P2196

**分类：动态规划-动态规划的引入**

**提交时间：2025-02-23 14:57:33**

---
title: "[NOIP 1996 提高组] 挖地雷"
layout: "post"
diff: 普及/提高-
pid: P2196
tag: ['动态规划 DP', '搜索', '2001', 'NOIP 提高组', '深度优先搜索 DFS', '1996']
---
# [NOIP 1996 提高组] 挖地雷
## 题目描述

在一个地图上有 $N\ (N \le 20)$ 个地窖，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。

## 输入格式

有若干行。

第 $1$ 行只有一个数字，表示地窖的个数 $N$。

第 $2$ 行有 $N$ 个数，分别表示每个地窖中的地雷个数。

第 $3$ 行至第 $N+1$ 行表示地窖之间的连接情况：

第 $3$ 行有 $n-1$ 个数（$0$ 或 $1$），表示第一个地窖至第 $2$ 个、第 $3$ 个 $\dots$ 第 $n$ 个地窖有否路径连接。如第 $3$ 行为 $11000\cdots 0$，则表示第 $1$ 个地窖至第 $2$ 个地窖有路径，至第 $3$ 个地窖有路径，至第 $4$ 个地窖、第 $5$ 个 $\dots$ 第 $n$ 个地窖没有路径。

第 $4$ 行有 $n-2$ 个数，表示第二个地窖至第 $3$ 个、第 $4$ 个 $\dots$ 第 $n$ 个地窖有否路径连接。

……

第 $n+1$ 行有 $1$ 个数，表示第 $n-1$ 个地窖至第 $n$ 个地窖有否路径连接。（为 $0$ 表示没有路径，为 $1$ 表示有路径）。
## 输出格式

第一行表示挖得最多地雷时的挖地雷的顺序，各地窖序号间以一个空格分隔，不得有多余的空格。

第二行只有一个数，表示能挖到的最多地雷数。

## 样例

### 样例输入 #1
```
5
10 8 4 7 6
1 1 1 0
0 0 0
1 1
1

```
### 样例输出 #1
```
1 3 4 5
27
```
## 提示

**【题目来源】**

NOIP 1996 提高组第三题


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int ans = -1, n, a[50], b[50][50], f[50], p[50], k;
void cc(int k)
{
if (p[k] == 0)
{
cout << k << " ";
return;
}
cc(p[k]);
cout << k << " ";
}
int main() {
cin >> n;
for (int i = 1; i <= n; i++)
{
cin >> a[i];
}
for (int i = 1; i <= n - 1; i++)
{
for (int j = i + 1; j <= n; j++)
{
cin >> b[i][j];
}
}
for (int i = 1; i <= n; i++)
{
f[i] = a[i];
for (int j = 1; j <= n; j++)
{
if (b[j][i])
{
if (f[i] < f[j] + a[i])
{
f[i] = f[j] + a[i];
p[i] = j;
}
}
if (ans < f[i])
{
ans = f[i];
k = i;
}
}
}
cc(k);
cout << endl << ans << endl;
return 0;
}
```

---

## 题目: P2199

**提交时间：2024-08-03 19:49:07**

---
title: "最后的迷宫"
layout: "post"
diff: 普及/提高-
pid: P2199
tag: ['搜索', '枚举', '广度优先搜索 BFS', '队列']
---
# 最后的迷宫
## 题目背景

哈利•波特作为三强争霸赛的第四名选手，历尽艰险闯到了最后一关——迷宫。

现在，迷宫里只剩下哈利和塞德里克了，哈利只有在塞德里克前面拿到奖杯，才能赢得比赛。哈利只要能看到奖杯，就可以用飞来咒拿到它，所以，现在的问题是哈利如何能尽早地看到奖杯。

## 题目描述

哈利的视力非常好，他能从迷宫的一端沿直线看到迷宫的另一端（但他只能看八个方向——东北，东，东南，南，西南……），而且他跑得非常快，跑一步（向上、下、左、右移动一格）只需要 $1\text{s}$。但迷宫是不透光的，而且，要烧掉迷宫的墙也不容易，所以哈利决定绕到一个能够看到奖杯的地方。现在，哈利希望你能帮他确定最短需要多长时间才能拿到奖杯。

## 输入格式

第一行为 $2$ 个数 $N,M$ 表示迷宫的规模（$N$ 为高，$M$ 为宽）

接下来是 $N \times M$ 的迷宫，$\texttt{O}$ 表示空地，$\texttt{X}$ 表示墙。

最后是多对数据，分别是奖杯坐标及哈利的坐标（显然不可能在墙上），每对占一行，$0$ 为结束标志。

## 输出格式

根据每对数据，计算哈利拿到奖杯的最短时间，每对一行。如果魔法部有意难为选手，用墙将奖杯包围了起来，输出 $\texttt{Poor Harry}$。

## 样例

### 样例输入 #1
```
3 4
OXXO
XXOO
XOOO
3 2 2 4
3 3 1 1
0 0 0 0

```
### 样例输出 #1
```
1
Poor Harry

```
## 提示

对于 $30\%$ 的数据，有 $N\times M\le100$；

对于 $60\%$ 的数据，有 $N\times M\le1600$；

对于 $100\%$ 的数据，有 $N\times M\le16384$。

询问数据对数不超过 $512$。



### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
const int INF=2e9;
string a[17000];
vector<int>ans[17000];
int dx[4]={-1,1,0,0};
int dy[4]={0,0,-1,1};
int dx2[8]={-1,1,0,0,-1,1,1,-1};
int dy2[8]={0,0,-1,1,1,1,-1,-1};
int n,m,sx,sy,tx,ty;
struct node
{
int x,y,step;
};
queue<node> q;
bool ok(int x,int y)
{
if(x>=1&&x<=n&&y>=1&&y<=m&&a[x][y-1]=='O')
{
return 1;
}
else
{
return 0;
}
}
void bfs(int tx,int ty)
{
for(int i=1;i<=n;i++)
{
for(int j=1;j<=m;j++)
{
ans[i][j]=INF;
}
}
q.push(node{tx,ty,0});
ans[tx][ty]=0;
while (!q.empty())
{
node tmp=q.front();
q.pop();
for (int i=0;i<=3;i++)
{
int nx=tmp.x+dx[i];
int ny=tmp.y+dy[i];
if (ok(nx,ny)&&ans[nx][ny]==INF)
{
q.push(node{nx,ny,tmp.step+1});
ans[nx][ny]=tmp.step+1;
}
}
}
}
int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++)
{
cin>>a[i];
ans[i].resize(m+1);
}
while(cin>>sx>>sy>>tx>>ty)
{
if(sx==0&&sy==0&&tx==0&&ty==0)
{
break;
}
bfs(tx,ty);
if(ans[sx][sy]==INF)
{
cout<<"Poor Harry"<<endl;
}
else
{
int answer=ans[sx][sy];
for(int i=0;i<=7;i++)
{
int tmpx=sx+dx2[i],tmpy=sy+dy2[i];
while(ok(tmpx,tmpy))
{
answer=min(answer,ans[tmpx][tmpy]);
tmpx+=dx2[i];
tmpy+=dy2[i];
}
}
cout<<answer<<endl;
}
}
return 0;
}
```

---

## 题目: P2240

**分类：算法--贪心**

**提交时间：2024-11-04 21:02:41**

---
title: "【深基12.例1】部分背包问题"
layout: "post"
diff: 普及-
pid: P2240
tag: ['贪心']
---
# 【深基12.例1】部分背包问题
## 题目描述

阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\le m_i,v_i \le 100)$。阿里巴巴有一个承重量为 $T(T \le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？
## 输入格式

第一行两个整数 $N,T$。

接下来 $N$ 行，每行两个整数 $m_i,v_i$。
## 输出格式

一个实数表示答案，输出两位小数
## 样例

### 样例输入 #1
```
4 50
10 60
20 100
30 120
15 45

```
### 样例输出 #1
```
240.00
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct student{
double m,v,x;
}stu[105];
int n;
double sum=0,c=0;
bool cmp(student a,student b){
if(a.x>b.x){
return true;
}
return false;
}
int main(){
cin>>n>>c;
for(int i=1;i<=n;i++){
cin>>stu[i].m>>stu[i].v;
stu[i].x=stu[i].v/stu[i].m;
}
sort(stu+1,stu+n+1,cmp);
for(int i=1;i<=n;i++){
if(c>=stu[i].m){
c-=stu[i].m;
sum+=stu[i].v;
}
else{
sum+=c*stu[i].x;
break;
}
}
printf("%.2f",sum);
return 0;
}
```

---

## 题目: P2241

**分类：算法--暴力枚举**

**提交时间：2024-10-13 13:23:04**

---
title: "统计方形（数据加强版）"
layout: "post"
diff: 普及-
pid: P2241
tag: ['数学', '枚举']
---
# 统计方形（数据加强版）
## 题目背景

1997年普及组第一题

## 题目描述

有一个 $n \times m$ 方格的棋盘，求其方格包含多少正方形、长方形（不包含正方形）。
## 输入格式

一行，两个正整数 $n,m$（$n \leq 5000,m \leq 5000$）。

## 输出格式

一行，两个正整数，分别表示方格包含多少正方形、长方形（不包含正方形）。
## 样例

### 样例输入 #1
```
2 3
```
### 样例输出 #1
```
8 10
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
long long sum=0,sum1=0;
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
sum+=min(n-i+1,m-j+1);
sum1+=(n-i+1)*(m-j+1)-min(n-i+1,m-j+1);
}
}
cout<<sum<<" "<<sum1;
return 0;
}
```

---

## 题目: P2249

**分类：算法--二分查找与二分答案**

**提交时间：2024-10-23 19:37:28**

---
title: "【深基13.例1】查找"
layout: "post"
diff: 普及-
pid: P2249
tag: ['二分']
---
# 【深基13.例1】查找
## 题目描述

输入 $n$ 个不超过 $10^9$ 的单调不减的（就是后面的数字不小于前面的数字）非负整数 $a_1,a_2,\dots,a_{n}$，然后进行 $m$ 次询问。对于每次询问，给出一个整数 $q$，要求输出这个数字在序列中第一次出现的编号，如果没有找到的话输出 $-1$ 。
## 输入格式

第一行 $2$ 个整数 $n$ 和 $m$，表示数字个数和询问次数。

第二行 $n$ 个整数，表示这些待查询的数字。

第三行 $m$ 个整数，表示询问这些数字的编号，从 $1$ 开始编号。
## 输出格式

输出一行，$m$ 个整数，以空格隔开，表示答案。
## 样例

### 样例输入 #1
```
11 3
1 3 3 3 5 7 9 11 13 15 15
1 3 6
```
### 样例输出 #1
```
1 2 -1 
```
## 提示

数据保证，$1 \leq n \leq 10^6$，$0 \leq a_i,q \leq 10^9$，$1 \leq m \leq 10^5$

本题输入输出量较大，请使用较快的 IO 方式。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,a[1000005],b[100005];
int find(int x){
int l=1,r=n+1,mid;
while(l<r){
mid=(l+r)/2;
if(a[mid]>=x){
r=mid;
}
else{
l=mid+1;
}
}
if(a[l]==x){
return l;
}
return -1;
}
int main(){
cin>>n>>q;
for(int i=1;i<=n;i++){
scanf("%d",&a[i]);
}
for(int i=1;i<=q;i++){
scanf("%d",&b[i]);
}
for(int i=1;i<=q;i++){
cout<<find(b[i])<<" ";
}
return 0;
}
```

---

## 题目: P2367

**分类：算法--前缀和、差分与离散化**

**提交时间：2024-11-03 13:31:51**

---
title: "语文成绩"
layout: "post"
diff: 普及-
pid: P2367
tag: ['差分']
---
# 语文成绩
## 题目背景

语文考试结束了，成绩还是一如既往地有问题。

## 题目描述

语文老师总是写错成绩，所以当她修改成绩的时候，总是累得不行。她总是要一遍遍地给某些同学增加分数，又要注意最低分是多少。你能帮帮她吗？

## 输入格式

第一行有两个整数 $n$，$p$，代表学生数与增加分数的次数。

第二行有 $n$ 个数，$a_1 \sim a_n$，代表各个学生的初始成绩。

接下来 $p$ 行，每行有三个数，$x$，$y$，$z$，代表给第 $x$ 个到第 $y$ 个学生每人增加 $z$ 分。
## 输出格式

输出仅一行，代表更改分数后，全班的最低分。

## 样例

### 样例输入 #1
```
3 2
1 1 1
1 2 1
2 3 1
```
### 样例输出 #1
```
2

```
## 提示

对于 $40\%$ 的数据，有 $n \le 10^3$。

对于 $60\%$ 的数据，有 $n \le 10^4$。

对于 $80\%$ 的数据，有 $n \le 10^5$。

对于 $100\%$ 的数据，有 $n \le 5\times 10^6$，$p \le n$，学生初始成绩 $ \le 100$，$z \le 100$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,p,a[5000005],b[5000005],minn=1e9;
int main(){
cin>>n>>p;
for(int i=1;i<=n;i++){
scanf("%d",&a[i]);
b[i]=a[i]-a[i-1];
}
for(int i=1;i<=p;i++){
int x,y,z;
scanf("%d%d%d",&x,&y,&z);
b[x]+=z;
b[y+1]-=z;
}
for(int i=1;i<=n;i++){
b[i]=b[i-1]+b[i];
minn=min(minn,b[i]);
}
cout<<minn;
return 0;
}
```

---

## 题目: P2392

**分类：动态规划-动态规划的引入**

**提交时间：2025-01-02 20:03:44**

---
title: "kkksc03考前临时抱佛脚"
layout: "post"
diff: 普及-
pid: P2392
tag: ['搜索', '递归']
---
# kkksc03考前临时抱佛脚
## 题目背景

kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。

## 题目描述

这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。


kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。


由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。

## 输入格式

本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。

第 $2$ 行，为 $A_1,A_2,\ldots,A_{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。

第 $3$ 行，为 $B_1,B_2,\ldots,B_{s_2}$ 共 $s_2$ 个数。

第 $4$ 行，为 $C_1,C_2,\ldots,C_{s_3}$ 共 $s_3$ 个数。

第 $5$ 行，为 $D_1,D_2,\ldots,D_{s_4}$ 共 $s_4$ 个数，意思均同上。

## 输出格式

输出一行,为复习完毕最短时间。

## 样例

### 样例输入 #1
```
1 2 1 3		
5
4 3
6
2 4 3

```
### 样例输出 #1
```
20
```
## 提示

$1\leq s_1,s_2,s_3,s_4\leq 20$。

$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,s[5],a[25],b[5],sum=0,ans=INT_MAX;
void dfs(int x,int num){
for(int i=1;i<=2;i++){
if(b[i]>=ans){
return;
}
}
if(x==s[num]+1){
int t=0;
for(int i=1;i<=2;i++){
t=max(t,b[i]);
}
ans=min(ans,t);
}
else{
for(int i=1;i<=2;i++){
b[i]+=a[x];
dfs(x+1,num);
b[i]-=a[x];
}
}
}
int main(){
for(int i=1;i<=4;i++){
cin>>s[i];
}
for(int i=1;i<=4;i++){
ans=INT_MAX;
for(int j=1;j<=s[i];j++){
cin>>a[j];
}
dfs(1,i);
sum+=ans;
}
cout<<sum;
return 0;
}
```

---

## 题目: P2404

**分类：算法--搜索**

**提交时间：2025-02-04 22:01:14**

---
title: "自然数的拆分问题"
layout: "post"
diff: 普及-
pid: P2404
tag: ['搜索']
---
# 自然数的拆分问题
## 题目描述

任何一个大于 $1$ 的自然数 $n$，总可以拆分成若干个小于 $n$ 的自然数之和。现在给你一个自然数 $n$，要求你求出 $n$ 的拆分成一些数字的和。每个拆分后的序列中的数字从小到大排序。然后你需要输出这些序列，其中字典序小的序列需要优先输出。

## 输入格式

输入：待拆分的自然数 $n$。

## 输出格式

输出：若干数的加法式子。

## 样例

### 样例输入 #1
```
7

```
### 样例输出 #1
```
1+1+1+1+1+1+1
1+1+1+1+1+2
1+1+1+1+3
1+1+1+2+2
1+1+1+4
1+1+2+3
1+1+5
1+2+2+2
1+2+4
1+3+3
1+6
2+2+3
2+5
3+4
```
## 提示

数据保证，$2\leq n\le 8$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[15]={1},x;
void dfs(int cnt){
for(int i=a[cnt-1];i<=x;i++){
if(i==n){
continue;
}
x-=i;
a[cnt]=i;
if(x==0){
for(int j=1;j<=cnt-1;j++){
cout<<a[j]<<"+";
}
cout<<a[cnt]<<endl;
}
else{
dfs(cnt+1);
}
x+=i;
}	}
int main(){
cin>>n;
x=n;
dfs(1);
return 0;
}
```

---

## 题目: P2433

**分类：入门-分支结构**

**提交时间：2023-11-17 15:05:16**

---
title: "【深基1-2】小学数学 N 合一"
layout: "post"
diff: 普及-
pid: P2433
tag: ['模拟']
---
# 【深基1-2】小学数学 N 合一
## 题目描述

### 问题 1

请输出 `I love Luogu!`

### 问题 2

这里有 $10$ 个苹果，小 A 拿走了 $2$ 个，Uim 拿走了 $4$ 个，小 B 拿走剩下的所有的苹果。我们想知道：

1. 小 A 和 Uim 两个人一共拿走多少苹果？
2. 小 B 能拿走多少苹果？

现在需要编写一个程序，输出两个数字作为答案，中间使用空格分开。

### 问题 3

现在有 $14$ 个苹果。要均分给 $4$ 名同学，分不掉的苹果放回冰箱。请问：

1. 每位同学能分得几个苹果？
2. 一共分出去多少苹果？
3. 把几个苹果放回冰箱？

 	现在需要编写一个程序，输出三个数字作为答案，每个数字一行。

### 问题 4

现在有 $500$ 毫升的肥宅快乐水，要均分给 $3$ 名同学，每位同学可以分到多少毫升？请输出一个数字作为输出。保留 $6$ 位有效数字，且不使用科学计数法。

### 问题 5

甲列火车长 $260$ 米，每秒行 $12$ 米；乙列火车长 $220$ 米，每秒行 $20$ 米，两车相向而行，从两车车头相遇时开始计时，多长时间后两车车尾相离？已知答案是整数。

### 问题 6

一个长方形长宽分别是 $6 \text{ cm}$、$9 \text{ cm}$，求它的对角线长度（$\text{cm}$）。直接使用 `cout` 输出。

### 问题 7

Uim 银行账户里面有 $100$ 元。经过了下面的操作：

1. 往里面存了 $10$ 元；
2. 购物花掉了 $20$ 元；
3. 把里面的钱全部取出。

 	请在每次操作后输出账户余额，并使用换行符隔开。


### 问题 8

当半径为 $r=5$，请输出圆的周长、面积和球体积。取 $\pi=3.141593$。请直接使用 `cout` 输出答案，每行一个数字。

### 问题 9

一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；第二天他也刚好吃了剩余桃子的一半，贪嘴多吃了一个；第三天他又刚好吃了剩下的桃子的一半，并贪嘴多吃了一个。第四天起来一看，发现桃子只剩下一个了。请问小猴买了几个桃子？

### 问题 10

洛谷的评测任务是单位时间内均匀增加的。$8$ 台评测机 $30$ 分钟可以刚好把评测队列中的程序评测完毕，$10$ 台评测机 $6$ 分钟可以刚好把评测队列中的程序评测完毕，请问几台评测机可以在 $10$ 分钟时刚好把评测队列中的程序评测完毕？

### 问题 11

小 A 跑步速度 $5 \text{ m/s}$，小 B 跑步速度 $8 \text{ m/s}$，小 B 在小 A 后面 $100 \text{ m}$，他们同时起跑，请问需要多长时间小 B 可以追上小 A？输出一个数字表示答案，使用 `cout` 直接输出。

### 问题 12

大家都知道有 $26$ 个英文字母，其中 A 是第一个字母。现在请编程求出：

1. M 是字母表中的第几个字母？
2. 第 $18$ 个字母是什么？

输出一个数字和一个字母，使用换行隔开。


### 问题 13

小 A 有两块球形橡皮泥，一个半径是 $4$，一个半径是 $10$。他想把这两块橡皮泥揉在一起，然后塑造成一个正方体，请问这个正方体的棱长是多少？如果结果不是整数，则舍去小数点之后的数字。取 $\pi = 3.141593$。

### 问题 14

根据咕咕网校的预测，当课程定价为 $110$ 元时，会有 $10$ 人报名。如果课程价格每降低 $1$ 元，就会多 $1$ 名报名者（反之亦然）。如果希望总共能收到 $3500$ 元学费的话，那么应该定价多少呢？已知本题有两个答案符合要求，则取较小的那一个。如果这个答案不是整数，则需四舍五入精确到整数。


## 输入格式

输入一个正整数，表示第几个问题。
## 输出格式

根据所输入的问题编号，输出对应问题的答案。
## 样例

### 样例输入 #1
```
2
```
### 样例输出 #1
```
6 4
```
## 提示

请解决以下小学数学题。你可以提交答案，也可以写一个程序。

对于本题来说，如果你不知道怎么输入，也可以这么抄：

```cpp
#include<iostream>
// 填上你觉得需要的其他头文件
using namespace std;
int main() {
    int T;
    cin >> T;
    if (T == 1) {
        // 粘贴问题 1 的主函数代码，除了 return 0
        cout << "I love Luogu!";
    } else if (T == 2) {
        // 粘贴问题 2 的主函数代码，除了 return 0
        cout << 2 + 4 << " " << 10 - 2 - 4;
    } else if (T == 3) {
        // 请自行完成问题 3 的代码
    } else if (T == 4) {
        // 请自行完成问题 4 的代码
    } else if (T == 5) {
        // 请自行完成问题 5 的代码
    } else if (T == 6) {
        // 请自行完成问题 6 的代码
    } else if (T == 7) {
        // 请自行完成问题 7 的代码
    } else if (T == 8) {
        // 请自行完成问题 8 的代码
    } else if (T == 9) {
        // 请自行完成问题 9 的代码
    } else if (T == 10) {
        // 请自行完成问题 10 的代码
    } else if (T == 11) {
        // 请自行完成问题 11 的代码
    } else if (T == 12) {
        // 请自行完成问题 12 的代码
    } else if (T == 13) {
        // 请自行完成问题 13 的代码
    } else if (T == 14) {
        // 请自行完成问题 14 的代码
    }
    return 0;
}
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main(){
cin>>n;
switch(n){
case 1:{
cout<<"I love Luogu!"<<endl;
break;
}
case 2:{
cout<<2+4<<" "<<10-2-4<<endl;
break;
}
case 3:{
int a=14/4;
cout<<a<<endl;
cout<<a*4<<endl;
cout<<14-a*4<<endl;
break;
}
case 4:{
cout<<500.0/3<<endl;
break;
}
case 5:{
cout<<(260+220)/(12+20)<<endl;
break;
}
case 6:{
double a=6,b=9;
double c=sqrt(a*a+b*b);
cout<<c<<endl;
break;
}
case 7:{
int a=100;
a+=10;
cout<<a<<endl;
a-=20;
cout<<a<<endl;
a=0;
cout<<a<<endl;
break;
}
case 8:{
int r=5;
double pi=3.141593;
cout<<2*pi*r<<endl;
cout<<r*r*pi<<endl;
cout<<4.0/3*pi*r*r*r<<endl;
break;
}
case 9:{
cout<<(((1+1)*2+1)*2+1)*2<<endl;
break;
}
case 10:{
cout<<9<<endl;
break;
}
case 11:{
cout<<100.0/(8-5)<<endl;
break;
}
case 12:{
cout<<'M'-'A'+1<<endl;
cout<<char('A'-1+18)<<endl;
break;
}
case 13:{
int r1=4,r2=10;
double pi=3.141593;
double v=4.0/3*pi*r1*r1*r1+4.0/3*pi*r2*r2*r2;
v=pow(v,1.0/3);
printf("%.0lf\n",v);
break;
}
case 14:{
cout<<50<<endl;
break;
}
}
return 0;
}
```

---

## 题目: P2440

**分类：算法--二分查找与二分答案**

**提交时间：2024-11-24 13:37:17**

---
title: "木材加工"
layout: "post"
diff: 普及/提高-
pid: P2440
tag: ['贪心', '线性数据结构', '二分', '递归']
---
# 木材加工
## 题目背景

要保护环境

## 题目描述

木材厂有 $n$ 根原木，现在想把这些木头切割成 $k$ 段长度**均**为 $l$ 的小段木头（木头有可能有剩余）。

当然，我们希望得到的小段木头越长越好，请求出 $l$ 的最大值。

木头长度的单位是 $\text{cm}$，原木的长度都是正整数，我们要求切割得到的小段木头的长度也是正整数。

例如有两根原木长度分别为 $11$ 和 $21$，要求切割成等长的 $6$ 段，很明显能切割出来的小段木头长度最长为 $5$。
## 输入格式


第一行是两个正整数 $n,k$，分别表示原木的数量，需要得到的小段的数量。

接下来 $n$ 行，每行一个正整数 $L_i$，表示一根原木的长度。
## 输出格式

仅一行，即 $l$ 的最大值。

如果连 $\text{1cm}$ 长的小段都切不出来，输出 `0`。
## 样例

### 样例输入 #1
```
3 7
232
124
456
```
### 样例输出 #1
```
114
```
## 提示


#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n\le 10^5$，$1\le k\le 10^8$，$1\le L_i\le 10^8(i\in[1,n])$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[100005],ans;
bool check(int x){
int t=0;
for(int i=1;i<=n;i++){
t+=a[i]/x;
}
if(t<k){
return true;
}
return false;
}
int main(){
cin>>n>>k;
for(int i=1;i<=n;i++){
cin>>a[i];
}
int l=0,r=1e8,mid;
while(l<r){
mid=(l+r+1)/2;
if(check(mid)){
r=mid-1;
}
else{
l=mid;
ans=mid;
}
}
cout<<ans;
return 0;
}
```

---

## 题目: P2455

**分类：数学--基础线性代数**

**提交时间：2023-11-10 15:11:30**

---
title: "[SDOI2006] 线性方程组"
layout: "post"
diff: 提高+/省选-
pid: P2455
tag: ['2006', '各省省选', '山东', 'Special Judge', '素数判断,质数,筛法', '最大公约数 gcd', '排列组合', '高斯消元']
---
# [SDOI2006] 线性方程组
## 题目描述

已知 $n$ 元线性一次方程组。

$$ \begin{cases} a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\ a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\ \cdots \\ a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n \end{cases}$$

请根据输入的数据，编程输出方程组的解的情况。
## 输入格式

第一行输入未知数的个数 $n$。  
接下来 $n$ 行，每行 $n + 1$ 个整数，表示每一个方程的系数及方程右边的值。

## 输出格式

如果有唯一解，则输出解。你的结果被认为正确，当且仅当对于每一个 $x_i$ 而言结果值与标准答案值的绝对误差或者相对误差不超过 $0.01$。

如果方程组无解输出 $-1$；
如果有无穷多实数解，输出 $0$；
## 样例

### 样例输入 #1
```
3
2 -1 1 1
4 1 -1 5
1 1 1 0
```
### 样例输出 #1
```
x1=1.00
x2=0.00
x3=-1.00

```
## 提示

【数据范围】  
对于 $100\%$ 的数据，$1 \le n \le 50$。对于 $\forall 1\le i, j \le n$，有 $|a_{i, j}| \le 100$，$|b_i| \le 300$。


### 代码

```cpp
#include <cstdio>
#include <cmath>
#include <iostream>
using namespace std;
double A[50][51];
int N;
int main(){
scanf("%d", &N);
for(int i =0; i < N; ++i) for(int j =0; j < N+1; ++j)
scanf("%lf", &A[i][j]);
int nwline =0;
//k指主元序号(列)
for(int k =0; k < N; ++k){//需要考虑无穷解，循环到N
int maxi =nwline;
for(int i =nwline+1; i < N; ++i)
if(abs(A[i][k]) > abs(A[maxi][k])) maxi =i;
if(A[maxi][k] == 0) continue;
for(int j =0; j < N+1; ++j)
swap(A[nwline][j], A[maxi][j]);
for(int i =0; i < N; ++i){
if(i == nwline) continue;
double mul =A[i][k]/A[nwline][k];
//A[nwline][i] =0;//这里判不判无所谓，因为这一列其他的项之后都可以推出来了(0)，不用再访问
for(int j =k+1; j < N+1; ++j)
A[i][j] -=A[nwline][j]*mul;
}
++nwline;
}
//最后的元随机分配就行了，结果不会有差，不如说左边一定都是0
if(nwline < N){
while(nwline < N)
if(A[nwline++][N] != 0) return puts("-1") && 0;
return putchar('0') && 0;
}
for(int i =0; i < N; ++i){
printf("x%d=", i+1);
if(int(A[i][N]/A[i][i]*100) == 0) puts("0");
else printf("%.2lf\n", A[i][N]/A[i][i]);
}
}
```

---

## 题目: P2550

**分类：入门-数组**

**提交时间：2024-03-25 19:26:10**

---
title: "[AHOI2001] 彩票摇奖"
layout: "post"
diff: 入门
pid: P2550
tag: ['2001', '各省省选', '安徽']
---
# [AHOI2001] 彩票摇奖
## 题目描述

为了丰富人民群众的生活、支持某些社会公益事业，北塔市设置了一项彩票。该彩票的规则是：

1. 每张彩票上印有 $7$ 个各不相同的号码，且这些号码的取值范围为 $1\sim33$。
2. 每次在兑奖前都会公布一个由七个各不相同的号码构成的中奖号码。
3. 共设置 $7$ 个奖项，特等奖和一等奖至六等奖。

兑奖规则如下：
- 特等奖：要求彩票上 $7$ 个号码都出现在中奖号码中。
- 一等奖：要求彩票上有 $6$ 个号码出现在中奖号码中。
- 二等奖：要求彩票上有 $5$ 个号码出现在中奖号码中。
- 三等奖：要求彩票上有 $4$ 个号码出现在中奖号码中。
- 四等奖：要求彩票上有 $3$ 个号码出现在中奖号码中。
- 五等奖：要求彩票上有 $2$ 个号码出现在中奖号码中。
- 六等奖：要求彩票上有 $1$ 个号码出现在中奖号码中。

注：兑奖时并不考虑彩票上的号码和中奖号码中的各个号码出现的位置。例如，中奖号码为 $23\ 31\ 1\ 14\ 19\ 17\ 18$，则彩票 $12\ 8\ 9\ 23\ 1\ 16\ 7$ 由于其中有两个号码（$23$ 和 $1$）出现在中奖号码中，所以该彩票中了五等奖。

现已知中奖号码和小明买的若干张彩票的号码，请你写一个程序帮助小明判断他买的彩票的中奖情况。
## 输入格式

输入的第一行只有一个自然数 $n$，表示小明买的彩票张数；

第二行存放了 $7$ 个介于 $1$ 和 $33$ 之间的自然数，表示中奖号码；

在随后的 $n$ 行中每行都有 $7$ 个介于 $1$ 和 $33$ 之间的自然数，分别表示小明所买的 $n$ 张彩票。
## 输出格式

依次输出小明所买的彩票的中奖情况（中奖的张数），首先输出特等奖的中奖张数，然后依次输出一等奖至六等奖的中奖张数。
## 样例

### 样例输入 #1
```
2
23 31 1 14 19 17 18
12 8 9 23 1 16 7
11 7 10 21 2 9 31
```
### 样例输出 #1
```
0 0 0 0 0 1 1
```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n\lt1000$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int n, a[10], b[10], c[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, sum = 7;
cin >> n;
for (int i = 0; i < 7; i++)
{
cin >> a[i];
}
for (int i = 1; i <= n; i++)
{
sum = 7;
for (int j = 0; j < 7; j++)
{
cin >> b[j];
for (int k = 0; k < 7; k++)
{
if (b[j] == a[k])
{
sum -= 1;
break;
}
}
}
if (sum != 7)
{
c[sum] += 1;
}
}
for (int i = 0; i < 7; i++)
{
cout<<c[i]<<" ";
}
return 0;
}
```

---

## 题目: P2615

**分类：入门-数组**

**提交时间：2024-04-06 20:11:24**

---
title: "[NOIP 2015 提高组] 神奇的幻方"
layout: "post"
diff: 普及-
pid: P2615
tag: ['模拟', '2015', 'NOIP 提高组', '枚举']
---
# [NOIP 2015 提高组] 神奇的幻方
## 题目背景

NOIp2015 提高组 Day1T1

## 题目描述

幻方是一种很神奇的 $N\times N$ 矩阵：它由数字 $1,2,3,\cdots \cdots ,N \times N$ 构成，且每行、每列及两条对角线上的数字之和都相同。

当 $N$ 为奇数时，我们可以通过下方法构建一个幻方：

首先将 $1$ 写在第一行的中间。

之后，按如下方式从小到大依次填写每个数 $K \ (K=2,3,\cdots,N \times N)$ ：

1. 若 $(K-1)$ 在第一行但不在最后一列，则将 $K$ 填在最后一行， $(K-1)$ 所在列的右一列；
2. 若 $(K-1)$ 在最后一列但不在第一行，则将 $K$ 填在第一列， $(K-1)$ 所在行的上一行；
3. 若 $(K-1)$ 在第一行最后一列，则将 $K$ 填在 $(K-1)$ 的正下方；
4. 若 $(K-1)$ 既不在第一行，也不在最后一列，如果 $(K-1)$ 的右上方还未填数，则将 $K$ 填在 $(K-1)$ 的右上方，否则将 $K$ 填在 $(K-1)$ 的正下方。

现给定 $N$ ，请按上述方法构造 $N \times N$ 的幻方。
## 输入格式

一个正整数 $N$，即幻方的大小。
## 输出格式

共 $N$ 行，每行 $N$ 个整数，即按上述方法构造出的 $N \times N$ 的幻方，相邻两个整数之间用单空格隔开。
## 样例

### 样例输入 #1
```
3

```
### 样例输出 #1
```
8 1 6
3 5 7
4 9 2
```
### 样例输入 #2
```
25

```
### 样例输出 #2
```
327 354 381 408 435 462 489 516 543 570 597 624 1 28 55 82 109 136 163 190 217 244 271 298 325
353 380 407 434 461 488 515 542 569 596 623 25 27 54 81 108 135 162 189 216 243 270 297 324 326
379 406 433 460 487 514 541 568 595 622 24 26 53 80 107 134 161 188 215 242 269 296 323 350 352
405 432 459 486 513 540 567 594 621 23 50 52 79 106 133 160 187 214 241 268 295 322 349 351 378
431 458 485 512 539 566 593 620 22 49 51 78 105 132 159 186 213 240 267 294 321 348 375 377 404
457 484 511 538 565 592 619 21 48 75 77 104 131 158 185 212 239 266 293 320 347 374 376 403 430
483 510 537 564 591 618 20 47 74 76 103 130 157 184 211 238 265 292 319 346 373 400 402 429 456
509 536 563 590 617 19 46 73 100 102 129 156 183 210 237 264 291 318 345 372 399 401 428 455 482
535 562 589 616 18 45 72 99 101 128 155 182 209 236 263 290 317 344 371 398 425 427 454 481 508
561 588 615 17 44 71 98 125 127 154 181 208 235 262 289 316 343 370 397 424 426 453 480 507 534
587 614 16 43 70 97 124 126 153 180 207 234 261 288 315 342 369 396 423 450 452 479 506 533 560
613 15 42 69 96 123 150 152 179 206 233 260 287 314 341 368 395 422 449 451 478 505 532 559 586
14 41 68 95 122 149 151 178 205 232 259 286 313 340 367 394 421 448 475 477 504 531 558 585 612
40 67 94 121 148 175 177 204 231 258 285 312 339 366 393 420 447 474 476 503 530 557 584 611 13
66 93 120 147 174 176 203 230 257 284 311 338 365 392 419 446 473 500 502 529 556 583 610 12 39
92 119 146 173 200 202 229 256 283 310 337 364 391 418 445 472 499 501 528 555 582 609 11 38 65
118 145 172 199 201 228 255 282 309 336 363 390 417 444 471 498 525 527 554 581 608 10 37 64 91
144 171 198 225 227 254 281 308 335 362 389 416 443 470 497 524 526 553 580 607 9 36 63 90 117
170 197 224 226 253 280 307 334 361 388 415 442 469 496 523 550 552 579 606 8 35 62 89 116 143
196 223 250 252 279 306 333 360 387 414 441 468 495 522 549 551 578 605 7 34 61 88 115 142 169
222 249 251 278 305 332 359 386 413 440 467 494 521 548 575 577 604 6 33 60 87 114 141 168 195
248 275 277 304 331 358 385 412 439 466 493 520 547 574 576 603 5 32 59 86 113 140 167 194 221
274 276 303 330 357 384 411 438 465 492 519 546 573 600 602 4 31 58 85 112 139 166 193 220 247
300 302 329 356 383 410 437 464 491 518 545 572 599 601 3 30 57 84 111 138 165 192 219 246 273
301 328 355 382 409 436 463 490 517 544 571 598 625 2 29 56 83 110 137 164 191 218 245 272 299

```
## 提示

对于 $100\%$ 的数据，对于全部数据， $1 \leq N \leq 39$ 且 $N$ 为奇数。




### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int n, a[50][50], x, y;
cin >> n;
for (int i = 1; i <= n; i++)
{
for (int j = 1; j <= n; j++)
{
a[i][j] = 0;
}
}
a[1][(n + 1) / 2] = 1;
x = 1;
y = (n + 1) / 2;
for (int i = 2; i <= n * n; i++)
{
if (x == 1 && y != n)
{
a[n][y + 1] = i;
x = n;
y += 1;
}
else if (x != 1 && y == n)
{
a[x - 1][1] = i;
x -= 1;
y = 1;
}
else if (x == 1 && y == n)
{
a[x + 1][y] = i;
x += 1;
}
else if (x != 1 && y != n && a[x - 1][y + 1] == 0)
{
a[x - 1][y + 1] = i;
x -= 1;
y += 1;
}
else
{
a[x + 1][y] = i;
x += 1;
}
}
for (int i = 1; i <= n; i++)
{
for (int j = 1; j <= n; j++)
{
cout << a[i][j] << " ";
}
cout << endl;
}
return 0;
}
```

---

## 题目: P2660

**分类：数学-基础数学问题**

**提交时间：2025-03-18 22:07:28**

---
title: "zzc 种田"
layout: "post"
diff: 普及-
pid: P2660
tag: ['数学', '贪心', '递归', '洛谷原创']
---
# zzc 种田
## 题目背景

可能以后 zzc 就去种田了。

## 题目描述

田地是一个巨大的矩形，然而 zzc 每次只能种一个正方形,而每种一个正方形时 zzc 所花的体力值是正方形的周长，种过的田不可以再种，zzc 很懒还要节约体力去泡妹子，想花最少的体力值去种完这块田地，问最小体力值。
## 输入格式

两个正整数 $x,y$，表示田地的长和宽。
## 输出格式

输出最小体力值。
## 样例

### 样例输入 #1
```
1 10
```
### 样例输出 #1
```
40
```
### 样例输入 #2
```
2 2 
```
### 样例输出 #2
```
8
```
## 提示

$1\le x,y\le 10^{16}$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m;
long long sum=0;
int main(){
cin>>n>>m;
while(n!=0&&m!=0){
long long minn=min(n,m);
long long maxx=max(n,m);
sum+=maxx/minn*4*minn;
maxx%=minn;
n=minn;
m=maxx;
}
cout<<sum;
return 0;
}
```

---

## 题目: P2669

**分类：入门-循环结构**

**提交时间：2023-11-30 22:22:31**

---
title: "[NOIP 2015 普及组] 金币"
layout: "post"
diff: 入门
pid: P2669
tag: ['模拟', '数学', '2015', 'NOIP 普及组']
---
# [NOIP 2015 普及组] 金币
## 题目背景

NOIP2015 普及组 T1
## 题目描述

国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 $n$ 天每天收到 $n$ 枚金币后，骑士会在之后的连续 $n+1$ 天里，每天收到 $n+1$ 枚金币。

请计算在前 $k$ 天里，骑士一共获得了多少金币。
## 输入格式

一个正整数 $k$，表示发放金币的天数。
## 输出格式

一个正整数，即骑士收到的金币数。

## 样例

### 样例输入 #1
```
6
```
### 样例输出 #1
```
14
```
### 样例输入 #2
```
1000

```
### 样例输出 #2
```
29820

```
## 提示

**【样例 1 说明】**

骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 $1+2+2+3+3+3=14$ 枚金币。


对于 $100\%$ 的数据，$1\le k\le 10^4$。



### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int k,n,sum=0,a=0;
n=0;
cin>>k;
for (int i=1;i<=k;i+=n)
{
n+=1;
if (k-(i-1)<n)
{
a=(k-(i-1))*n;
n-=1;
break;
}
}
while (n>0)
{
sum+=n*n;
n-=1;
}
sum+=a;
cout<<sum;
return 0;
}
```

---

## 题目: P2676

**分类：算法--排序**

**提交时间：2025-02-14 16:12:50**

---
title: "[USACO07DEC] Bookshelf B"
layout: "post"
diff: 入门
pid: P2676
tag: ['贪心', '2007', 'USACO', '排序']
---
# [USACO07DEC] Bookshelf B
## 题目描述

Farmer John 最近为奶牛们的图书馆添置了一个巨大的书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。 

所有 $N(1 \le N \le 20,000)$ 头奶牛都有一个确定的身高 $H_i(1 \le H_i \le 10,000)$。设所有奶牛身高的和为S。书架的高度为 $B$，并且保证 $1 \le B \le S < 2,000,000,007$。 

为了够到比最高的那头奶牛还要高的书架顶，奶牛们不得不像演杂技一般，一头站在另一头的背上，叠成一座“奶牛塔”。当然，这个塔的高度，就是塔中所有奶牛的身高之和。为了往书架顶上放东西，所有奶牛的身高和必须不小于书架的高度。

显然，塔中的奶牛数目越多，整座塔就越不稳定，于是奶牛们希望在能够到书架顶的前提下，让塔中奶牛的数目尽量少。 现在，奶牛们找到了你，希望你帮她们计算这个最小的数目。

## 输入格式

* 第 $1$ 行: 2 个用空格隔开的整数：$N$ 和 $B$；
* 第 $2\dots N+1$ 行: 第 $i+1$ 行是 $1$ 个整数：$H_i$。

## 输出格式

* 第 $1$ 行: 输出 $1$ 个整数，即最少要多少头奶牛叠成塔，才能够到书架顶部

## 样例

### 样例输入 #1
```
6 40
6
18
11
13
19
11
```
### 样例输出 #1
```
3
```
## 提示

输入说明:

一共有 $6$ 头奶牛，书架的高度为 $40$，奶牛们的身高在 $6\dots19$之间。


输出说明:

一种只用 $3$ 头奶牛就达到高度 $40$ 的方法：$18+11+13$。当然还有其他方法，在此不一一列出了。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,k,a[20005],sum;
bool cmp(int x,int y){
if(x>y){
return true;
}
return false;
}
int main(){
cin>>n>>k;
for(int i=1;i<=n;i++){
cin>>a[i];
}
sort(a+1,a+n+1,cmp);
for(int i=1;i<=n;i++){
sum+=a[i];
if(sum>=k){
cout<<i;
break;
}
}
return 0;
}
```

---

## 题目: P2678

**分类：算法--二分查找与二分答案**

**提交时间：2024-11-24 14:54:13**

---
title: "[NOIP 2015 提高组] 跳石头"
layout: "post"
diff: 普及/提高-
pid: P2678
tag: ['贪心', '2015', '二分', 'NOIP 提高组']
---
# [NOIP 2015 提高组] 跳石头
## 题目背景

NOIP2015 Day2T1
## 题目描述

一年一度的“跳石头”比赛又要开始了！

这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 $N$ 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。

为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 $M$ 块岩石（不能移走起点和终点的岩石）。
## 输入格式

第一行包含三个整数 $L,N,M$，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 $L \geq 1$ 且 $N \geq M \geq 0$。

接下来 $N$ 行，每行一个整数，第 $i$ 行的整数 $D_i\,( 0 < D_i < L)$， 表示第 $i$ 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。
## 输出格式

一个整数，即最短跳跃距离的最大值。
## 样例

### 样例输入 #1
```
25 5 2 
2
11
14
17 
21
```
### 样例输出 #1
```
4
```
## 提示

### 输入输出样例 1 说明

将与起点距离为 $2$ 和 $14$ 的两个岩石移走后，最短的跳跃距离为 $4$（从与起点距离 $17$ 的岩石跳到距离 $21$ 的岩石，或者从距离 $21$ 的岩石跳到终点）。

### 数据规模与约定

对于 $20\%$的数据，$0 \le M \le N \le 10$。    
对于 $50\%$ 的数据，$0 \le M \le N \le 100$。  
对于 $100\%$ 的数据，$0 \le M \le N \le 50000,1 \le L 
 \le 10^9$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=50005;
int a[N],n,m,e;
bool check(int mid){
int c=0,p=0;
for(int i=1;i<=n;i++){
if(a[i]-p<mid){
c++;
}
else{
p=a[i];
}
}
if(e-p<mid){
c++;
}
return c<=m;
}
int main(){
cin>>e>>n>>m;
for(int i=1;i<=n;i++){
cin>>a[i];
}
int l=1,r=e,mid;
while(l<r){
mid=(l+r+1)/2;
if(check(mid)){
l=mid;
}
else{
r=mid-1;
}
}
cout<<l;
return 0;
}
```

---

## 题目: P2695

**分类：贪心**

**提交时间：2025-02-04 21:02:01**

---
title: "骑士的工作"
layout: "post"
diff: 普及-
pid: P2695
tag: ['贪心', '排序']
---
# 骑士的工作
## 题目背景

你作为一个村的村长，保卫村庄是理所当然的了。今天，村庄里来了一只恶龙，他有 $n$ 个头，恶龙到处杀人放火。你着急了。不过天无绝人之路，现在来了一个骑士团。里面有 $m$ 位成员（往下看）。

## 题目描述

每个人都可以砍掉**至多**一个大小不超过 $z_i$ 的头，需要 $z_i$ 个金币，求最小花费。

## 输入格式

第一行两个整数 $n$，$m$。

下接 $n$ 行，一个整数表示 $n$ 个头的大小。

下接 $m$ 行，每个人可以砍的头大小和需要的金币数 $z_1, \cdots, z_m$。

## 输出格式

一个整数，最小花费。如果无解，输出 `you died!`。

## 样例

### 样例输入 #1
```
2 3
5 
4
7 
8
4
```
### 样例输出 #1
```
11
```
## 提示

对于所有数据，$1 \le n,m \le 2 \times 10^4$，$1 \leq z_i \leq 10^5$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[20005],b[20005],ans=0,x=0;
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=m;i++){
cin>>b[i];
}
sort(a+1,a+n+1);
sort(b+1,b+m+1);
for(int i=1;i<=m;i++){
if(x==n){
break;
}
if(a[x+1]<=b[i]){
x+=1;
ans+=b[i];
}
}
if(x==n){
cout<<ans<<endl;
}
else{
cout<<"you died!"<<endl;
}
return 0;
}
```

---

## 题目: P2722

**分类：动态规划**

**提交时间：2025-03-23 13:26:50**

---
title: "[USACO3.1] 总分 Score Inflation"
layout: "post"
diff: 普及-
pid: P2722
tag: ['动态规划 DP', 'USACO', '背包 DP']
---
# [USACO3.1] 总分 Score Inflation
## 题目背景

选手在我们 USACO 的竞赛中的得分越多我们越高兴。

我们试着设计我们的竞赛以便人们能尽可能的多得分,这需要你的帮助。

## 题目描述

我们可以从几个种类中选取竞赛的题目，这里的一个“种类”是指一个竞赛题目的集合，解决集合中的题目需要相同多的时间并且能得到相同的分数。

你的任务是写一个程序来告诉 USACO 的职员,应该从每一个种类中选取多少题目，使得解决题目的总耗时在竞赛规定的时间里并且总分最大。
## 输入格式

输入的第一行是用空格隔开的两个整数，分别代表竞赛时间 $m$ 和题目类 $n$。

第 $2$ 到第 $(n + 1)$ 行，每行两个用空格隔开的整数，第 $(i + 1)$ 行的整数 $p_i, t_i$ 分别代表解决第 $i$ 类题得到的分数和需要花费的时间。

既然是某一类题目，那么这一类题目可以重复选择。

## 输出格式

输出一行一个整数，代表最大的总分。
## 样例

### 样例输入 #1
```
300 4
100 60
250 120
120 100
35 20
```
### 样例输出 #1
```
605
```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 10^4$，$1 \leq p_i, t_i \leq 10^4$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,v[10005],w[10005],dp[10005];
int main(){
cin>>m>>n;
for(int i=1;i<=n;i++){
cin>>v[i]>>w[i];
}
for(int i=1;i<=n;i++){
for(int j=m;j>=0;j--){
for(int k=0;k<=j/w[i];k++){
dp[j]=max(dp[j],dp[j-k*w[i]]+k*v[i]);
}
}
}
cout<<dp[m];
return 0;
}
```

---

## 题目: P2758

**分类：动态规划-线性状态动态规划**

**提交时间：2024-08-15 14:12:48**

---
title: "编辑距离"
layout: "post"
diff: 普及/提高-
pid: P2758
tag: ['字符串', '动态规划 DP', '数学']
---
# 编辑距离
## 题目描述

设 $A$ 和 $B$ 是两个字符串。我们要用最少的字符操作次数，将字符串 $A$ 转换为字符串 $B$。这里所说的字符操作共有三种：

1. 删除一个字符；
2. 插入一个字符；
3. 将一个字符改为另一个字符。

$A, B$ 均只包含小写字母。

## 输入格式

第一行为字符串 $A$；第二行为字符串 $B$；字符串 $A, B$ 的长度均小于 $2000$。

## 输出格式

只有一个正整数，为最少字符操作次数。

## 样例

### 样例输入 #1
```
sfdqxbw
gfdgw

```
### 样例输出 #1
```
4

```
## 提示

对于 $100 \%$ 的数据，$1 \le |A|, |B| \le 2000$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,dp[2010][2010];
char a[2010],b[2010];
int main()
{
cin>>a+1>>b+1;
n=strlen(a+1);
m=strlen(b+1);
for(int i=1;i<=n;i++)
{
dp[i][0]=i;
}
for(int i=1;i<=m;i++)
{
dp[0][i]=i;
}
for(int i=1;i<=n;i++)
{
for(int j=1;j<=m;j++)
{
if(a[i]==b[j])
{
dp[i][j]=dp[i-1][j-1];
}
else
{
dp[i][j]=min(dp[i][j-1],min(dp[i-1][j],dp[i-1][j-1]))+1;
}
}
}
cout<<dp[n][m];
return 0;
}
```

---

## 题目: P2813

**分类：贪心**

**提交时间：2025-03-06 20:35:09**

---
title: "母舰"
layout: "post"
diff: 普及-
pid: P2813
tag: ['模拟', '贪心', '广东', '排序']
---
# 母舰
## 题目背景

广东汕头聿怀初中 Train#3 Problem 1

（有没有红警既视感~）

## 题目描述

在小 A 的星际大战游戏中，一艘强力的母舰往往决定了一场战争的胜负。一艘母舰的攻击力是普通的 MA（Mobile Armor）无法比较的。

对于一艘母舰而言，它是由若干个攻击系统和若干个防御系统组成的。两艘母舰对决时，一艘母舰会选择用不同的攻击系统去攻击对面母舰的防御系统。当这个攻击系统的攻击力大于防御系统的防御力时，那个防御系统会被破坏掉。当一艘母舰的防御系统全部被破坏掉之后，所有的攻击都会攻击到敌方母舰本身上去造成伤害。

这样说，一艘母舰对对面的伤害在一定程度上是取决于选择的攻击对象的。

在瞬息万变的战场中，选择一个最优的攻击对象是非常重要的。所以需要写出一个战斗系统出来，判断出你的母舰最多能对对手造成多少伤害并加以实现。

## 输入格式

输入第一行两个整数 $M$ 和 $N$，表示对方母舰的防御系统数量和你的母舰的攻击系统数量。

接着 $M$ 行每行一个整数每一个表示对方防御系统的防御力是多少。

接着 $N$ 行每行一个整数每一个表示己方攻击系统的攻击力是多少。
## 输出格式

输出仅有一行，表示可以造成的最大伤害。

## 样例

### 样例输入 #1
```
3 5 
1000 
2000 
1200 
2100 
2000 
1200 
1000 
1000
```
### 样例输出 #1
```
2000
```
## 提示

#### 样例解释 #1

对方防御系统有 $3$ 个，防御值为 $1000(a),2000(b),1200(c)$，己方攻击系统有 $5$ 个，攻击值为 $2100(d)，2000(e),1200(f),1000(g),1000(h)$。第 $1$ 轮攻击的最优方案是 $d$ 攻击 $b$，$e$ 攻击 $c$，$f$ 攻击 $a$，$g$ 和 $h$ 攻击对方母舰本身，造成 $2000$ 点伤害。

#### 数据范围与约定

对于 $80 \%$ 的数据，$1 \le N,M \le 1000$。

对于 $100 \%$ 的数据，$1 \le N,M \le 10 ^ 5$。


本题为转载题目。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],b[100005],cnt=1,sum=0;
bool flag=0;
int main(){
cin>>n>>m;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=m;i++){
cin>>b[i];
sum+=b[i];
}
sort(a+1,a+n+1);
sort(b+1,b+m+1);
for(int i=1;i<=m;i++){
if(a[cnt]<b[i]){
cnt+=1;
sum-=b[i];
}
if(cnt==n+1){
flag=1;
break;
}
}
if(flag==0){
cout<<0;
}
else{
cout<<sum;
}
return 0;
}
```

---

## 题目: P2858

**提交时间：2025-04-13 13:50:47**

---
title: "[USACO06FEB] Treats for the Cows G/S"
layout: "post"
diff: 普及/提高-
pid: P2858
tag: ['动态规划 DP', '2006', 'USACO', '区间 DP']
---
# [USACO06FEB] Treats for the Cows G/S
## 题目描述

FJ has purchased N (1 <= N <= 2000) yummy treats for the cows who get money for giving vast amounts of milk. FJ sells one treat per day and wants to maximize the money he receives over a given period time.


The treats are interesting for many reasons:The treats are numbered 1..N and stored sequentially in single file in a long box that is open at both ends. On any day, FJ can retrieve one treat from either end of his stash of treats.Like fine wines and delicious cheeses, the treats improve with age and command greater prices.The treats are not uniform: some are better and have higher intrinsic value. Treat i has value v(i) (1 <= v(i) <= 1000).Cows pay more for treats that have aged longer: a cow will pay v(i)\*a for a treat of age a.Given the values v(i) of each of the treats lined up in order of the index i in their box, what is the greatest value FJ can receive for them if he orders their sale optimally?


The first treat is sold on day 1 and has age a=1. Each subsequent day increases the age by 1.

约翰经常给产奶量高的奶牛发特殊津贴，于是很快奶牛们拥有了大笔不知该怎么花的钱。为此，约翰购置了 $N$（$1 \leq N \leq 2000$） 份美味的零食来卖给奶牛们。每天约翰售出一份零食。当然约翰希望这些零食全部售出后能得到最大的收益，这些零食有以下这些有趣的特性：
+ 零食按照 $1, \ldots, N$ 编号，它们被排成一列放在一个很长的盒子里。盒子的两端都有开口，约翰每天可以从盒子的任一端取出最外面的一个。
+ 与美酒与好吃的奶酪相似，这些零食储存得越久就越好吃。当然，这样约翰就可以把它们卖出更高的价钱。
+ 每份零食的初始价值不一定相同。约翰进货时，第i份零食的初始价值为 $V_i$（$1 \leq V \leq 1000$）。
+ 第i份零食如果在被买进后的第 $a$ 天出售，则它的售价是 $V_i \times a$。

$V_i$ 的是从盒子顶端往下的第i份零食的初始价值。约翰告诉了你所有零食的初始价值，并希望你能帮他计算一下，在这些零食全被卖出后，他最多能得到多少钱。
## 输入格式

Line 1: A single integer, N

Lines 2..N+1: Line i+1 contains the value of treat v(i)

## 输出格式

Line 1: The maximum revenue FJ can achieve by selling the treats

## 样例

### 样例输入 #1
```
5
1
3
1
5
2
```
### 样例输出 #1
```
43
```
## 提示

Explanation of the sample:




Five treats. On the first day FJ can sell either treat #1 (value 1) or treat #5 (value 2).




FJ sells the treats (values 1, 3, 1, 5, 2) in the following order of indices: 1, 5, 2, 3, 4, making 1x1 + 2x2 + 3x3 + 4x1 + 5x5 = 43.



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[2005];
int dp[2005][2005];
int solve(int l,int r,int k){
if(dp[l][r]>0){
return dp[l][r];
}
if(l==r){
return a[l]*k;
}
else{
return dp[l][r]=max(solve(l,r-1,k+1)+a[r]*k,solve(l+1,r,k+1)+a[l]*k);
}
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
cout<<solve(1,n,1);
return 0;
}
```

---

## 题目: P2880

**分类：算法--分治与倍增**

**提交时间：2024-08-07 15:15:30**

---
title: "[USACO07JAN] Balanced Lineup G"
layout: "post"
diff: 普及/提高-
pid: P2880
tag: ['2007', 'USACO', '树状数组', 'ST 表']
---
# [USACO07JAN] Balanced Lineup G
## 题目描述

For the daily milking, Farmer John's N cows (1 ≤ N ≤ 50,000) always line up in the same order. One day Farmer John decides to organize a game of Ultimate Frisbee with some of the cows. To keep things simple, he will take a contiguous range of cows from the milking lineup to play the game. However, for all the cows to have fun they should not differ too much in height.

Farmer John has made a list of Q (1 ≤ Q ≤ 180,000) potential groups of cows and their heights (1 ≤ height ≤ 1,000,000). For each group, he wants your help to determine the difference in height between the shortest and the tallest cow in the group.

每天,农夫 John 的 $n(1\le n\le 5\times 10^4)$ 头牛总是按同一序列排队。

有一天, John 决定让一些牛们玩一场飞盘比赛。他准备找一群在队列中位置连续的牛来进行比赛。但是为了避免水平悬殊，牛的身高不应该相差太大。John 准备了 $q(1\le q\le 1.8\times10^5)$ 个可能的牛的选择和所有牛的身高 $h_i(1\le h_i\le 10^6,1\le i\le n)$。他想知道每一组里面最高和最低的牛的身高差。
## 输入格式

Line 1: Two space-separated integers, N and Q.


Lines 2..N+1: Line i+1 contains a single integer that is the height of cow i


Lines N+2..N+Q+1: Two integers A and B (1 ≤ A ≤ B ≤ N), representing the range of cows from A to B inclusive.

第一行两个数 $n,q$。

接下来 $n$ 行，每行一个数 $h_i$。

再接下来 $q$ 行，每行两个整数 $a$ 和 $b$，表示询问第 $a$ 头牛到第 $b$ 头牛里的最高和最低的牛的身高差。

## 输出格式

Lines 1..Q: Each line contains a single integer that is a response to a reply and indicates the difference in height between the tallest and shortest cow in the range.

输出共 $q$ 行，对于每一组询问，输出每一组中最高和最低的牛的身高差。
## 样例

### 样例输入 #1
```
6 3
1
7
3
4
2
5
1 5
4 6
2 2
```
### 样例输出 #1
```
6
3
0
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=5e4+10;
int x,y,n,m,k,a[maxn],maxv[maxn*4],minv[maxn*4],mi,mx;
void build(int o,int L,int R)
{
if(L==R)
{
maxv[o]=a[L];
minv[o]=a[L];
return;
}
int M=(L+R)/2;
build(o*2,L,M);
build(o*2+1,M+1,R);
maxv[o]=max(maxv[o*2],maxv[o*2+1]);
minv[o]=min(minv[o*2],minv[o*2+1]);
}
void query(int o,int L,int R)
{
if(x<=L&&R<=y)
{
mi=min(mi,minv[o]);
mx=max(mx,maxv[o]);
return;
}
int M=(L+R)/2;
if(x<=M)
{
query(o*2,L,M);
}
if(y>M)
{
query(o*2+1,M+1,R);
}
}
int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
build(1,1,n);
for(int i=1;i<=m;i++)
{
cin>>x>>y;
mi=INT_MAX;
mx=INT_MIN;
query(1,1,n);
cout<<mx-mi<<endl;
}
return 0;
}
```

---

## 题目: P2911

**分类：入门-数组**

**提交时间：2024-03-29 22:03:15**

---
title: "[USACO08OCT] Bovine Bones G"
layout: "post"
diff: 入门
pid: P2911
tag: ['2008', 'USACO', '枚举', '期望']
---
# [USACO08OCT] Bovine Bones G
## 题目描述

Bessie loves board games and role-playing games so she persuaded Farmer John to drive her to the hobby shop where she purchased three dice for rolling. These fair dice have S1, S2, and S3 sides

respectively (2 <= S1 <= 20; 2 <= S2 <= 20; 2 <= S3 <= 40). 

Bessie rolls and rolls and rolls trying to figure out which three-dice sum appears most often.

Given the number of sides on each of the three dice, determine which three-dice sum appears most frequently. If more than one sum can appear most frequently, report the smallest such sum.

POINTS: 70

## 输入格式

\* Line 1: Three space-separated integers: S1, S2, and S3

## 输出格式

\* Line 1: The smallest integer sum that appears most frequently when the dice are rolled in every possible combination.

## 样例

### 样例输入 #1
```
3 2 3 

```
### 样例输出 #1
```
5 

```
## 提示

Here are all the possible outcomes.

```
1 1 1 -> 3  
1 2 1 -> 4  
2 1 1 -> 4  
2 2 1 -> 5  
3 1 1 -> 5  
3 2 1 -> 6 
1 1 2 -> 4  
1 2 2 -> 5  
2 1 2 -> 5  
2 2 2 -> 6  
3 1 2 -> 6  
3 2 2 -> 7 
1 1 3 -> 5  
1 2 3 -> 6  
2 1 3 -> 6  
2 2 3 -> 7  
3 1 3 -> 7  
3 2 3 -> 8
```
Both 5 and 6 appear most frequently (five times each), so 5 is the answer.

## 题目翻译

贝茜喜欢玩棋盘游戏和角色扮演游戏，所以她说服了约翰开车带她去小商店.在那里她买了三个骰子。这三个不同的骰子的面数分别为 $s_1,s_2,s_3$。

对于一个有 $S$ 个面的骰子每个面上的数字是 $1,2,3,\ldots,S$。每个面（上的数字）出现的概率均等。贝茜希望找出在所有“三个面上的数字的和”中，哪个和的值出现的概率最大。

现在给出每个骰子的面数，需要求出哪个所有“三个面上的数字的和”出现得最频繁。如果有很多个和出现的概率相同，那么只需要输出最小的那个。

数据范围： $2\le s_1\leq 20$，$2 \leq s_2\leq 20$，$2 \leq s_3\leq 40$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int a[100], b[50], x, y, z, sum = 0;
cin >> x >> y >> z;
for (int i = 1; i <= 40; i++)
{
a[i] = 0;
b[i] = i;
}
for (int i = 1; i <= x; i++)
{
for (int j = 1; j <= y; j++)
{
for (int k = 1; k <= z; k++)
{
sum = i + j + k;
a[sum] += 1;
}
}
}
int maxCount = 0, result = 0;
for (int i = 1; i <= x + y + z; i++)
{
if (a[i] > maxCount)
{
maxCount = a[i];
result = i;
}
}
cout << result;
return 0;
}
```

---

## 题目: P2925

**分类：动态规划**

**提交时间：2025-03-16 13:32:13**

---
title: "[USACO08DEC] Hay For Sale S"
layout: "post"
diff: 普及-
pid: P2925
tag: ['动态规划 DP', '2008', 'USACO', '背包 DP']
---
# [USACO08DEC] Hay For Sale S
## 题目描述

Farmer John suffered a terrible loss when giant Australian cockroaches ate the entirety of his hay inventory, leaving him with nothing to feed the cows. He hitched up his wagon with capacity C (1 <= C <= 50,000) cubic units and sauntered over to Farmer Don's to get some hay before the cows miss a meal.

Farmer Don had a wide variety of H (1 <= H <= 5,000) hay bales for sale, each with its own volume (1 <= V\_i <= C). Bales of hay, you know, are somewhat flexible and can be jammed into the oddest of spaces in a wagon.

FJ carefully evaluates the volumes so that he can figure out the largest amount of hay he can purchase for his cows.

Given the volume constraint and a list of bales to buy, what is the greatest volume of hay FJ can purchase?  He can't purchase partial bales, of course. Each input line (after the first) lists a single bale FJ can buy.

约翰遭受了重大的损失：蟑螂吃掉了他所有的干草，留下一群饥饿的牛．他乘着容量为C(1≤C≤50000)个单位的马车，去顿因家买一些干草．  顿因有H(1≤H≤5000)包干草，每一包都有它的体积Vi(l≤Vi≤C).约翰只能整包购买，

他最多可以运回多少体积的干草呢？

## 输入格式

\* Line 1: Two space-separated integers: C and H

\* Lines 2..H+1: Each line describes the volume of a single bale: V\_i

## 输出格式

\* Line 1: A single integer which is the greatest volume of hay FJ can purchase given the list of bales for sale and constraints.

## 样例

### 样例输入 #1
```
7 3 
2 
6 
5 

```
### 样例输出 #1
```
7 

```
## 提示

The wagon holds 7 volumetric units; three bales are offered for sale with volumes of 2, 6, and 5 units, respectively.


Buying the two smaller bales fills the wagon.

## 题目翻译

## 题目描述
农民 John 面临一个很可怕的事，因为防范力度不大所以他存储的所有稻草都被蟑螂吃光了，他将面临没有稻草喂养奶牛的局面。在奶牛断粮之前，John 拉着他的马车到农民 Don 的农场中买一些稻草给奶牛过冬。已知 John 的马车可以装的下 $C(1\le C\le5\times10^4)$ 立方的稻草。

农民 Don 有 $H(1\le H\le5\times10^3)$ 捆体积不同的稻草可供购买，每一捆稻草有它自己的体积 $V_i(1\le V_i\le C)$。面对这些稻草 John 认真的计算如何充分利用马车的空间购买尽量多的稻草给他的奶牛过冬。

现在给定马车的最大容积 $C$ 和每一捆稻草的体积 $V_i$，John 如何在不超过马车最大容积的情况下买到最大体积的稻草？他不可以把一捆稻草分开来买。

## 输入格式：
第一行两个整数，分别为 $C$ 和 $H$。
第 $2$ 到 $H+1$ 行:每一行一个整数代表第 $i$ 捆稻草的体积 $V_i$。

## 输出格式：

一个整数，为 John 能买到的稻草的体积。

###### 修改 by zhangsenhao6728


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int m,n,dp[5][50005];
int v[5005];
int main(){
cin>>m>>n;
for(int i=1;i<=n;i++){
cin>>v[i];
}
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
if(j>=v[i]){
dp[i%2][j]=max(dp[(i-1)%2][j],v[i]+dp[(i-1)%2][j-v[i]]);
}
else{
dp[i%2][j]=dp[(i-1)%2][j];
}
}
}
cout<<dp[n%2][m];
return 0;
}
```

---

## 题目: P3372

**分类：数据结构--线段树**

**提交时间：2024-08-07 14:08:20**

---
title: "【模板】线段树 1"
layout: "post"
diff: 普及+/提高
pid: P3372
tag: ['线段树']
---
# 【模板】线段树 1
## 题目描述

如题，已知一个数列 $\{a_i\}$，你需要进行下面两种操作：

1. 将某区间每一个数加上 $k$。
2. 求出某区间每一个数的和。

## 输入格式

第一行包含两个整数 $n, m$，分别表示该数列数字的个数和操作的总个数。

第二行包含 $n$ 个用空格分隔的整数 $a_i$，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。

接下来 $m$ 行每行包含 $3$ 或 $4$ 个整数，表示一个操作，具体如下：

1. `1 x y k`：将区间 $[x, y]$ 内每个数加上 $k$。
2. `2 x y`：输出区间 $[x, y]$ 内每个数的和。
## 输出格式

输出包含若干行整数，即为所有操作 2 的结果。
## 样例

### 样例输入 #1
```
5 5
1 5 4 2 3
2 2 4
1 2 3 2
2 3 4
1 1 5 1
2 1 4
```
### 样例输出 #1
```
11
8
20
```
## 提示

对于 $15\%$ 的数据：$n \le 8$，$m \le 10$。  
对于 $35\%$ 的数据：$n \le {10}^3$，$m \le {10}^4$。    
对于 $100\%$ 的数据：$1 \le n, m \le {10}^5$，$a_i,k$ 为正数，且任意时刻数列的和不超过 $2\times 10^{18}$。

**【样例解释】**

![](https://cdn.luogu.com.cn/upload/pic/2251.png)


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
long long op,n,m,k;
int x,y;
long long a[maxn],sumv[maxn*4],addv[maxn*4];
void build(int o,int L,int R)
{
if(L==R)
{
sumv[o]=a[L];
return;
}
int M=(L+R)/2;
build(o*2,L,M);
build(o*2+1,M+1,R);
sumv[o]=sumv[o*2]+sumv[o*2+1];
}
void update(int o,int L,int R)
{
if(x<=L&&R<=y)
{
addv[o]+=k;
sumv[o]+=(R-L+1)*k;
return;
}
int M=(L+R)/2;
if(x<=M)
{
update(o*2,L,M);
}
if(y>M)
{
update(o*2+1,M+1,R);
}
sumv[o]=sumv[o*2]+sumv[o*2+1]+addv[o]*(R-L+1);
}
long long query(int o,int L,int R)
{
if(x<=L&&R<=y)
{
return sumv[o];
}
int M=(L+R)/2;
long long ans=addv[o]*(min(R,y)-max(L,x)+1);
if(x<=M)
{
ans+=query(o*2,L,M);
}
if(y>M)
{
ans+=query(o*2+1,M+1,R);
}
return ans;
}
int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++)
{
cin>>a[i];
}
build(1,1,n);
for(int i=1;i<=m;i++)
{
cin>>op>>x>>y;
if(op==1)
{
cin>>k;
update(1,1,n);
}
else
{
cout<<query(1,1,n)<<endl;
}
}
return 0;
}
```

---

## 题目: P3374

**分类：数据结构--二叉堆与树状数组**

**提交时间：2024-08-06 12:43:57**

---
title: "【模板】树状数组 1"
layout: "post"
diff: 普及+/提高
pid: P3374
tag: ['树状数组']
---
# 【模板】树状数组 1
## 题目描述

如题，已知一个数列，你需要进行下面两种操作：

- 将某一个数加上 $x$

- 求出某区间每一个数的和

## 输入格式

第一行包含两个正整数 $n,m$，分别表示该数列数字的个数和操作的总个数。   
 
第二行包含 $n$ 个用空格分隔的整数，其中第 $i$ 个数字表示数列第 $i$ 项的初始值。

接下来 $m$ 行每行包含 $3$ 个整数，表示一个操作，具体如下：

- `1 x k`  含义：将第 $x$ 个数加上 $k$

- `2 x y`  含义：输出区间 $[x,y]$ 内每个数的和

## 输出格式

输出包含若干行整数，即为所有操作 $2$ 的结果。

## 样例

### 样例输入 #1
```
5 5
1 5 4 2 3
1 1 3
2 2 5
1 3 -1
1 4 2
2 1 4
```
### 样例输出 #1
```
14
16
```
## 提示

【数据范围】

对于 $30\%$ 的数据，$1 \le n \le 8$，$1\le m \le 10$；   
对于 $70\%$ 的数据，$1\le n,m \le 10^4$；   
对于 $100\%$ 的数据，$1\le n,m \le 5\times 10^5$。

数据保证对于任意时刻，$a$ 的任意子区间（包括长度为 $1$ 和 $n$ 的子区间）和均在 $[-2^{31}, 2^{31})$ 范围内。


样例说明：

 ![](https://cdn.luogu.com.cn/upload/pic/2256.png) 

故输出结果14、16



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, m, t[500005];
void myadd(int pos, int x) {
while (pos <= n) {
t[pos] += x;
pos += pos & -pos;
}
}
int mysum(int pos) {
int s = 0;
while (pos) {
s += t[pos];
pos -= pos & -pos;
}
return s;
}
void lesson1() {
int type, a, b;
cin >> n >> m;
for (int i = 1; i <= n; i++) {
scanf("%d", &a);
myadd(i, a);
}
for (int i = 1; i <= m; i++) {
scanf("%d%d%d", &type, &a, &b);
if (type == 2)printf("%d\n", mysum(b) - mysum(a - 1));
else myadd(a, b);
}
}
int main() {
lesson1();
return 0;
}
```

---

## 题目: P3383

**分类：数学-基础数学问题**

**提交时间：2025-02-15 21:49:09**

---
title: "【模板】线性筛素数"
layout: "post"
diff: 普及-
pid: P3383
tag: ['数学', 'O2优化', '素数判断,质数,筛法']
---
# 【模板】线性筛素数
## 题目背景

本题已更新，从判断素数改为了查询第 $k$ 小的素数  
提示：如果你使用  `cin` 来读入，建议使用 `std::ios::sync_with_stdio(0)` 来加速。
## 题目描述

如题，给定一个范围 $n$，有 $q$ 个询问，每次输出第 $k$ 小的素数。

## 输入格式

第一行包含两个正整数 $n,q$，分别表示查询的范围和查询的个数。

接下来 $q$ 行每行一个正整数 $k$，表示查询第 $k$ 小的素数。
## 输出格式

输出 $q$ 行，每行一个正整数表示答案。
## 样例

### 样例输入 #1
```
100 5
1
2
3
4
5
```
### 样例输出 #1
```
2
3
5
7
11
```
## 提示

【数据范围】  
对于 $100\%$ 的数据，$n = 10^8$，$1 \le q \le 10^6$，保证查询的素数不大于 $n$。

Data by NaCly\_Fish.



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,q,x,a[100000005],b[6000005],cnt;
void prime2(){
for(int i=2;i<=n;i++){
if(a[i]){
cnt+=1;
b[cnt]=i;
}
for(int j=1;j<=cnt&&i*b[j]<=n;j++){
a[i*b[j]]=0;
if(i%b[j]==0){
break;
}
}
}
}
int main(){
cin>>n>>q;
memset(a,1,sizeof(a));
prime2();
for(int i=1;i<=q;i++){
scanf("%d",&x);
cout<<b[x]<<endl;
}
return 0;
}
```

---

## 题目: P3392

**分类：算法--暴力枚举**

**提交时间：2024-10-13 19:31:24**

---
title: "涂条纹"
layout: "post"
diff: 普及-
pid: P3392
tag: ['模拟', '枚举', '洛谷月赛']
---
# 涂条纹
## 题目描述

只要一个由 $N \times M$ 个小方块组成的旗帜符合如下规则，就是合法的图案。

- 从最上方若干行（至少一行）的格子全部是白色的；
- 接下来若干行（至少一行）的格子全部是蓝色的；
- 剩下的行（至少一行）全部是红色的；

现有一个棋盘状的布，分成了 $N$ 行 $M$ 列的格子，每个格子是白色蓝色红色之一，小 a 希望把这个布改成合法图案，方法是在一些格子上涂颜料，盖住之前的颜色。

小 A 很懒，希望涂最少的格子，使这块布成为一个合法的图案。
## 输入格式

第一行是两个整数 $N,M$。

接下来 $N$ 行是一个矩阵，矩阵的每一个小方块是 `W`（白），`B`（蓝），`R`（红）中的一个。
## 输出格式

一个整数，表示至少需要涂多少块。

## 样例

### 样例输入 #1
```
4 5
WRWRW
BWRWB
WRWRW
RWBWR
```
### 样例输出 #1
```
11
```
## 提示

### 样例解释

目标状态是：

```plain
WWWWW
BBBBB
RRRRR
RRRRR
```
一共需要改 $11$ 个格子。

### 数据范围

对于 $100\%$ 的数据，$N,M \leq 50$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,minn=3000,sum=0;
char a[55][55];
int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
cin>>a[i][j];
}
}
for(int i=1;i<=n-2;i++){
for(int j=i+1;j<=n-1;j++){
sum=0;
for(int k=1;k<=m;k++){
for(int l=1;l<=i;l++){
if(a[l][k]!='W'){
sum+=1;
}
}
}
for(int k=1;k<=m;k++){
for(int l=i+1;l<=j;l++){
if(a[l][k]!='B'){
sum+=1;
}
}
}
for(int k=1;k<=m;k++){
for(int l=j+1;l<=n;l++){
if(a[l][k]!='R'){
sum+=1;
}
}
}
minn=min(minn,sum);
}
}
cout<<minn;
return 0;
}
```

---

## 题目: P3406

**分类：算法--前缀和、差分与离散化**

**提交时间：2024-11-08 21:53:55**

---
title: "海底高铁"
layout: "post"
diff: 普及/提高-
pid: P3406
tag: ['前缀和', '差分']
---
# 海底高铁
## 题目描述

该铁路经过 $N$ 个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好，于是乘车每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车票。第 $i$ 段铁路连接了城市 $i$ 和城市 $i+1(1\leq i<N)$。如果搭乘的比较远，需要购买多张车票。第 $i$ 段铁路购买纸质单程票需要 $A_i$ 博艾元。

虽然一些事情没有协调好，各段铁路公司也为了方便乘客，推出了 IC 卡。对于第 $i$ 段铁路，需要花 $C_i$ 博艾元的工本费购买一张 IC 卡，然后乘坐这段铁路一次就只要扣 $B_i(B_i<A_i)$ 元。IC 卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于第 $i$ 段铁路的 IC 卡，无法乘坐别的铁路的车。

Uim 现在需要出差，要去 $M$ 个城市，从城市 $P_1$ 出发分别按照 $P_1,P_2,P_3,\cdots,P_M$ 的顺序访问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且不会是同一个城市。

现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和充值的总费用。
## 输入格式

第一行两个整数，$N,M$。

接下来一行，$M$ 个数字，表示 $P_i$。

接下来 $N-1$ 行，表示第 $i$ 段铁路的 $A_i,B_i,C_i$。
## 输出格式

一个整数，表示最少花费
## 样例

### 样例输入 #1
```
9 10
3 1 4 1 5 9 2 6 5 3
200 100 50
300 299 100
500 200 500
345 234 123
100 50 100
600 100 1
450 400 80
2 1 10
```
### 样例输出 #1
```
6394
```
## 提示

$2$ 到 $3$ 以及 $8$ 到 $9$ 买票，其余买卡。

对于 $30\%$ 数据 $M=2$。

对于另外 $30\%$ 数据 $N\leq1000，M\leq1000$。

对于 $100\%$ 的数据 $M,N\leq 10^5，A_i,B_i,C_i\le10^5$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,m,p[100005],b[100005],ans=0;
int main(){
cin>>n>>m;
for(int i=1;i<=m;i++){
cin>>p[i];
if(i>1){
b[min(p[i],p[i-1])+1]+=1;
b[max(p[i],p[i-1])+1]-=1;
}
}
for(int i=1;i<=n;i++){
b[i]=b[i]+b[i-1];
}
for(int i=2;i<=n;i++){
long long x,y,z;
cin>>x>>y>>z;
ans+=min(x*b[i],y*b[i]+z);
}
cout<<ans;
return 0;
}
```

---

## 题目: P3654

**分类：算法--暴力枚举**

**提交时间：2024-10-13 13:47:36**

---
title: "First Step (ファーストステップ)"
layout: "post"
diff: 普及-
pid: P3654
tag: ['模拟', '枚举', '洛谷月赛']
---
# First Step (ファーストステップ)
## 题目背景

> **知らないことばかりなにもかもが（どうしたらいいの？）**    
**一切的一切 尽是充满了未知数（该如何是好）**   
**それでも期待で足が軽いよ（ジャンプだ！）**     
**但我仍因满怀期待而步伐轻盈（起跳吧！）**       
**温度差なんていつか消しちゃえってね**     
**冷若冰霜的态度 有朝一日将会消失得无影无踪**      
**元気だよ元気をだしていくよ**     
**拿出活力 打起精神向前迈进吧**     

 ![](https://cdn.luogu.com.cn/upload/pic/4471.png) 

我们 Aqours，要第一次举办演唱会啦！

虽然学生会长看上去不怎么支持我们的样子，可是有了理事长的支持，我们还是被允许在校内的篮球场里歌唱！

歌曲也好好地准备过了，名字叫“[最喜欢的话就没问题！ (ダイスキだったらダイジョウブ！)](https://zh.moegirl.org/%E6%9C%80%E5%96%9C%E6%AC%A2%E7%9A%84%E8%AF%9D%E5%B0%B1%E6%B2%A1%E9%97%AE%E9%A2%98)“，大家一定会喜欢的吧！

演唱会一定会顺利进行的！

希望不要发生**停电**什么的事故哦……！

## 题目描述

可是……这个篮球场，好像很久没有使用过的样子啊……

里面堆满了学校的各种杂物呢……

我们 Aqours 的成员要怎么在里面列队站下呢？


我们浦之星女子学院的篮球场是一个 $R$ 行 $C$ 列的矩阵，其中堆满了各种学校的杂物 (用 `#` 表示)，空地 (用 `.` 表示) 好像并不多的样子呢……

我们 Aqours 现在已经一共有 $K$ 个队员了，要歌唱舞蹈起来的话，我们得排成一条 $1\times K$ 的直线，一个接一个地站在篮球场的空地上呢 (横竖均可)。

我们想知道一共有多少种可行的站位方式呢。

Aqours 的真正的粉丝的你，能帮我们算算吗？

## 输入格式

第一行三个整数 $R, C, K$。

接下来的 $R$ 行 $C$ 列，表示浦之星女子学院篮球场。

## 输出格式

总共的站位方式数量。

## 样例

### 样例输入 #1
```
5 5 2
.###.
##.#.
..#..
#..#.
#.###

```
### 样例输出 #1
```
8
```
## 提示

|  | $R$ | $C$ | $K$ | 备注 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|$1\sim2$|$\leq 10$|$\leq 10$|$\leq \min(R,C)$|无|
|$3\sim4$|$\leq 100$|$\leq 100$|$\leq 1$|无|
|$5\sim6$|$\leq 100$|$\leq 100$|$\leq \min(R,C)$|没有障碍|
|$7\sim10$|$\leq 100$|$\leq 100$|$\leq \min(R,C)$|无|

对于所有数据，$1 \leq R,C \leq 100$，$1 \leq k \leq \min(R,C)$。

#### 以下是彩蛋

在 LoveLive!Sunshine!! 动画第一季第三集中，Aqours 队长高海千歌演唱“最喜欢的话就没问题！”到副歌前时，学校因为雷击停电。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,k,sum=0;
char a[105][105];
bool flag=1;
int main(){
cin>>n>>m>>k;
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
cin>>a[i][j];
}
}
for(int i=1;i<=n;i++){
for(int j=1;j<=m;j++){
if(a[i][j]=='.'){
flag=1;
for(int l=1;l<=k-1;l++){
if(a[i+l][j]!='.'){
flag=0;
break;
}
}
if(flag==1){
sum+=1;
}
flag=1;
for(int l=1;l<=k-1;l++){
if(a[i][j+l]!='.'){
flag=0;
break;
}
}
if(flag==1){
sum+=1;
}
}
}
}
if(k==1){
cout<<sum/2;
}
else{
cout<<sum;
}
return 0;
}
```

---

## 题目: P3817

**分类：算法--贪心**

**提交时间：2025-02-03 12:14:04**

---
title: "小A的糖果"
layout: "post"
diff: 普及-
pid: P3817
tag: ['模拟', '贪心', '洛谷月赛']
---
# 小A的糖果
## 题目描述

小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。

小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。

## 输入格式

输入的第一行是两个用空格隔开的整数，代表糖果盒的个数 $n$ 和给定的参数 $x$。

第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 盒糖的糖果个数 $a_i$。
## 输出格式

输出一行一个整数，代表最少要吃掉的糖果的数量。
## 样例

### 样例输入 #1
```
3 3
2 2 2
```
### 样例输出 #1
```
1

```
### 样例输入 #2
```
6 1
1 6 1 2 0 4
```
### 样例输出 #2
```
11
```
### 样例输入 #3
```
5 9
3 1 4 1 5
```
### 样例输出 #3
```
0

```
## 提示

#### 样例输入输出 1 解释

吃掉第 2 盒中的一个糖果即可。

---

#### 样例输入输出 2 解释

第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。

---

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 20$，$a_i, x \leq 100$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^3$，$a_i, x \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $2 \leq n \leq 10^5$，$0 \leq a_i, x \leq 10^9$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,x,a[100005],sum=0;
int main(){
cin>>n>>x;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=n-1;i++){
if(a[i]+a[i+1]>x){
sum+=(a[i]+a[i+1]-x);
if(a[i+1]-(a[i]+a[i+1]-x)<0){
a[i+1]=0;
a[i]-=(x-a[i+1]);
}
else{
a[i+1]-=(a[i]+a[i+1]-x);
}
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P3853

**分类：算法--二分查找与二分答案**

**提交时间：2024-11-08 16:40:18**

---
title: "[TJOI2007] 路标设置"
layout: "post"
diff: 普及/提高-
pid: P3853
tag: ['模拟', '搜索', '2007', '二分', '各省省选', '天津']
---
# [TJOI2007] 路标设置
## 题目背景

B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。

## 题目描述

现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。

## 输入格式

第 $1$ 行包括三个数 $L,N,K$，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。


第 $2$ 行包括递增排列的 $N$ 个整数，分别表示原有的 $N$ 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 $[0,L]$ 内。

## 输出格式

输出 $1$ 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。

## 样例

### 样例输入 #1
```
101 2 1
0 101
```
### 样例输出 #1
```
51
```
## 提示

公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 $50$ 或 $51$ 个单位距离处，这样能达到最小的空旷指数 $51$。

$50\%$ 的数据中，$2 \leq N \leq 100$，$0 \leq K \leq 100$。

$100\%$ 的数据中，$2 \leq N \leq 100000$, $0 \leq K \leq100000$。

$100\%$ 的数据中，$0 < L \leq 10000000$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int L,n,k,a[100005];
int judge(int x){
int sum=0;
for(int i=2;i<=n;i++){
sum+=(a[i]-a[i-1]-1)/x;
}
if(sum<=k){
return 1;
}
else{
return 0;
}
}
int main(){
cin>>L>>n>>k;
for(int i=1;i<=n;i++){
cin>>a[i];
}
int l=1,r=L;
while(l<r){
int mid=(l+r)/2;
if(judge(mid)){
r=mid;
}
else{
l=mid+1;
}
}
cout<<l<<endl;
return 0;
}
```

---

## 题目: P3903

**分类：动态规划**

**提交时间：2025-03-02 19:59:28**

---
title: "导弹拦截III"
layout: "post"
diff: 普及/提高-
pid: P3903
tag: []
---
# 导弹拦截III
## 题目描述

很多年以前，A 国发明了一种导弹系统用来拦截敌对势力发射的导弹。

这个系统可以发射一颗导弹拦截从由到远、高度不增加的多个导弹。

但是现在，科学家们发现这个防御系统还不够强大，所以他们发明了另外一套导弹系统。

这个新系统可以发射一颗导弹由近到远的拦截更多的导弹。

当这个系统启动，首先选择一颗敌人的导弹进行拦截，然后拦截一颗更远的高度更低的导弹进行拦截，然后拦截比第二颗更远的但高度更高的导弹……以此类推，拦截的第奇数颗导弹比前一颗导弹更远、更高，拦截的第偶数颗导弹比前一个更远、更低。

现在，给你一个从近到远的导弹高度列表，计算新系统发射一颗导弹可以拦截的最多的导弹数目。
## 输入格式

第一行是一个整数 $n$，表示敌人发射的导弹数目。接下来的一行有 $n$ 个整数，表示由近到远的。
## 输出格式

仅一个整数，表示拦截的最多导弹的数量。
## 样例

### 样例输入 #1
```
4
5 3 2 4
```
### 样例输出 #1
```
3
```
## 提示

$1\leq n\leq 10^3$，$1\leq $ 导弹高度 $\leq 10^9$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1005],dp[1005][2];
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
dp[i][1]=1;
}
for(int i=1;i<=n;i++){
for(int j=1;j<i;j++){
if(a[i]<a[j]){
dp[i][0]=max(dp[i][0],dp[j][1]+1);
}
if(a[i]>a[j]){
dp[i][1]=max(dp[i][1],dp[j][0]+1);
}
}
}
int ans=0;
for(int i=1;i<=n;i++){
ans=max(max(dp[i][0],dp[i][1]),ans);
}
cout<<ans;
return 0;
}
```

---

## 题目: P3912

**提交时间：2024-12-01 10:17:48**

---
title: "素数个数"
layout: "post"
diff: 普及-
pid: P3912
tag: ['数学', '枚举', '素数判断,质数,筛法']
---
# 素数个数
## 题目描述

求 $1,2,\cdots,N$ 中素数的个数。

## 输入格式

一行一个整数 $N$。

## 输出格式

一行一个整数，表示素数的个数。

## 样例

### 样例输入 #1
```
10
```
### 样例输出 #1
```
4
```
## 提示

对于 $40\%$ 的数据，$1 \le N \le 10^6$。

对于 $80\%$ 的数据，$1 \le N \le 10^7$。

对于 $100\%$ 的数据，$1 \le N \le 10^8$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=0;
bool a[100000005];
//bool prime1(int x){
//	for(int i=2;i<=sqrt(x);i++){
//		if(x%i==0){
//			return false;
//		}
//	}
//	return true;
//}
void prime2(){
for(int i=2;i<=sqrt(n);i++){
if(a[i]){
for(int j=i*i;j<=n;j+=i){
a[j]=0;
}
}
}
}
int main(){
cin>>n;
memset(a,1,sizeof(a));
//	for(int i=2;i<=n;i++){
//		if(prime1(i)){
//			sum+=1;
//		}
//	}
prime2();
for(int i=2;i<=n;i++){
if(a[i]==1){
sum+=1;
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P3954

**分类：入门-顺序结构**

**提交时间：2023-11-03 15:21:11**

---
title: "[NOIP 2017 普及组] 成绩"
layout: "post"
diff: 入门
pid: P3954
tag: ['2017', 'NOIP 普及组']
---
# [NOIP 2017 普及组] 成绩
## 题目背景

NOIP2017 普及组 T1
## 题目描述

牛牛最近学习了 C++ 入门课程，这门课程的总成绩计算方法是：

$$
\text{总成绩}=\text{作业成绩}\times 20\%+\text{小测成绩}×30\%+\text{期末考试成绩} \times 50\%
$$

牛牛想知道，这门课程自己最终能得到多少分。

## 输入格式

三个非负整数 $A,B,C$，分别表示牛牛的作业成绩、小测成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是 $100$ 分。

## 输出格式

一个整数，即牛牛这门课程的总成绩，满分也是 $100$ 分。

## 样例

### 样例输入 #1
```
100 100 80 
```
### 样例输出 #1
```
90
```
### 样例输入 #2
```
60 90 80 
```
### 样例输出 #2
```
79
```
## 提示

**样例 1 说明**

牛牛的作业成绩是 $100$ 分，小测成绩是 $100$ 分，期末考试成绩是 $80$ 分，总成绩是 $100 \times 20\%+100 \times 30\%+80 \times 50\%=20+30+40=90$。

**样例 2 说明**

牛牛的作业成绩是 $60$ 分，小测成绩是 $90$ 分，期末考试成绩是 $80$ 分，总成绩是 $60 \times 20\%+90 \times 30\%+80 \times 50\%=12+27+40=79$。

**数据说明**

对于 $30\%$ 的数据，$A=B=0$。

对于另外 $30\%$ 的数据，$A=B=100$。

对于 $100\%$ 的数据，$0≤A,B,C≤100$ 且 $A,B,C$ 都是 $10$ 的整数倍。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
int a,b,c;
int s;
scanf("%d%d%d",&a,&b,&c);
s=(int)(a*0.2+b*0.3+c*0.5);//第一次强制转化
printf("%.lf",(double)s);//第二、三次强制转化
}
```

---

## 题目: P3955

**提交时间：2024-05-31 16:13:19**

---
title: "[NOIP 2017 普及组] 图书管理员"
layout: "post"
diff: 普及-
pid: P3955
tag: ['字符串', '2017', 'NOIP 普及组', '排序']
---
# [NOIP 2017 普及组] 图书管理员
## 题目背景

NOIP2017 普及组 T2
## 题目描述

图书馆中每本书都有一个图书编码，可以用于快速检索图书，这个图书编码是一个正整数。 每位借书的读者手中有一个需求码，这个需求码也是一个正整数。如果一本书的图书编码恰好以读者的需求码结尾，那么这本书就是这位读者所需要的。 小 D 刚刚当上图书馆的管理员，她知道图书馆里所有书的图书编码，她请你帮她写一个程序，对于每一位读者，求出他所需要的书中图书编码最小的那本书，如果没有他需要的书，请输出 `-1`。

## 输入格式

第一行，包含两个正整数 $n , q$，以一个空格分开，分别代表图书馆里 书的数量和读者的数量。

接下来的 $n$ 行，每行包含一个正整数，代表图书馆里某本书的图书编码。

接下来的 $q$ 行，每行包含两个正整数，以一个空格分开，第一个正整数代表图书馆 里读者的需求码的长度，第二个正整数代表读者的需求码。

## 输出格式

$ q$ 行，每行包含一个整数，如果存在第 $i$ 个读者所需要的书，则在第 $i$ 行输出第 $i$ 个读者所需要的书中图书编码最小的那本书的图书编码，否则输出$-1$。

 
## 样例

### 样例输入 #1
```
5 5 
2123 
1123 
23 
24 
24 
2 23 
3 123 
3 124 
2 12 
2 12
```
### 样例输出 #1
```
23 
1123 
-1 
-1 
-1 
```
## 提示

**数据规模与约定**

对于 $20\%$ 的数据，$1 ≤ n ≤ 2$。

另有 $20\%$ 的数据，$q = 1$。

另有 $20\%$ 的数据，所有读者的需求码的长度均为 $1$。

另有 $20\%$ 的数据，所有的图书编码按从小到大的顺序给出。

对于 $100\%$ 的数据，$1 ≤ n ≤ 1000,1 ≤ q ≤ 1000$，所有的图书编码和需求码均不超过 $10^7$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int book[1005];
int main()
{
int n,q;
cin>>n>>q;
for(int i=1;i<=n;i++) cin>>book[i];
sort(book+1,book+n+1);
for(int i=1,k,code;i<=q;i++)
{
cin>>k>>code;
bool flag=0;
for(int j=1;j<=n;j++)
{
int s=pow(10,k);
if(book[j]%s==code)
{
cout<<book[j]<<endl;
flag=1;
break;
}
}
if(flag==0)
{
cout<<-1<<endl;
}
}
return 0;
}
```

---

## 题目: P3956

**提交时间：2024-05-29 16:23:40**

---
title: "[NOIP 2017 普及组] 棋盘"
layout: "post"
diff: 普及+/提高
pid: P3956
tag: ['搜索', '2017', 'NOIP 普及组', '广度优先搜索 BFS', '深度优先搜索 DFS', '剪枝', '最短路']
---
# [NOIP 2017 普及组] 棋盘
## 题目背景

NOIP2017 普及组 T3
## 题目描述

有一个 $m \times m$ 的棋盘，棋盘上每一个格子可能是红色、黄色或没有任何颜色的。你现在要从棋盘的最左上角走到棋盘的最右下角。

任何一个时刻，你所站在的位置必须是有颜色的（不能是无色的）， 你只能向上、下、左、右四个方向前进。当你从一个格子走向另一个格子时，如果两个格子的颜色相同，那你不需要花费金币；如果不同，则你需要花费 $1 $ 个金币。

另外， 你可以花费 $2$ 个金币施展魔法让下一个无色格子暂时变为你指定的颜色。但这个魔法不能连续使用， 而且这个魔法的持续时间很短，也就是说，如果你使用了这个魔法，走到了这个暂时有颜色的格子上，你就不能继续使用魔法； 只有当你离开这个位置，走到一个本来就有颜色的格子上的时候，你才能继续使用这个魔法，而当你离开了这个位置（施展魔法使得变为有颜色的格子）时，这个格子恢复为无色。

现在你要从棋盘的最左上角，走到棋盘的最右下角，求花费的最少金币是多少？

## 输入格式

第一行包含两个正整数 $ m, n$，以一个空格分开，分别代表棋盘的大小，棋盘上有颜色的格子的数量。

接下来的 $ n $ 行，每行三个正整数 $ x, y, c$， 分别表示坐标为 $(x,y)$ 的格子有颜色 $ c$。

其中 $ c=1$ 代表黄色，$ c=0$ 代表红色。 相邻两个数之间用一个空格隔开。 棋盘左上角的坐标为 $(1, 1)$，右下角的坐标为 $( m, m)$。

棋盘上其余的格子都是无色。保证棋盘的左上角，也就是 $(1, 1)$ 一定是有颜色的。

## 输出格式

一个整数，表示花费的金币的最小值，如果无法到达，输出 `-1`。

## 样例

### 样例输入 #1
```
5 7
1 1 0
1 2 0
2 2 1
3 3 1
3 4 0
4 4 1
5 5 0
```
### 样例输出 #1
```
8
```
### 样例输入 #2
```
5 5
1 1 0
1 2 0
2 2 1
3 3 1
5 5 0
```
### 样例输出 #2
```
-1
```
## 提示

**样例 1 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ | $\color{red}\text{红}$ |  |
|  |  |  | $\color{yellow}\text{黄}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |


从 $(1,1)$ 开始，走到 $(1,2)$ 不花费金币。

从 $(1,2)$ 向下走到 $(2,2)$ 花费 $1$ 枚金币。

从 $(2,2)$ 施展魔法，将 $(2,3)$ 变为黄色，花费 $2$ 枚金币。

从 $(2,2)$ 走到 $(2,3)$ 不花费金币。

从 $(2,3)$ 走到 $(3,3)$ 不花费金币。

从 $(3,3)$ 走到 $(3,4)$ 花费 $1$ 枚金币。

从 $(3,4)$ 走到 $(4,4)$ 花费 $1$ 枚金币。

从 $(4,4)$ 施展魔法，将 $(4,5)$ 变为黄色，花费 $ 2$ 枚金币。

从 $(4,4)$ 走到 $(4,5)$ 不花费金币。

从 $(4,5)$ 走到 $(5,5)$ 花费 $1$ 枚金币。

共花费 $8 $ 枚金币。

**样例 2 说明**

棋盘的颜色如下表格所示，其中空白的部分表示无色。

| $\color{red}\text{红}$ | $\color{red}\text{红}$ |  |  |  |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|  | $\color{yellow}\text{黄}$ |  |  |  |
|  |  | $\color{yellow}\text{黄}$ |  |  |
|  |  |  | $\color{white}\text{　}$ |  |
|  |  |  |  | $\color{red}\text{红}$ |

从 $( 1, 1)$ 走到 $( 1, 2)$，不花费金币。

从 $( 1, 2)$ 走到 $( 2, 2)$，花费 $ 1 $ 金币。

施展魔法将 $( 2, 3)$ 变为黄色，并从 $( 2, 2)$ 走到 $( 2, 3)$ 花费 $ 2$ 金币。

从 $( 2, 3)$ 走到 $( 3, 3)$ 不花费金币。

从 $( 3, 3)$ 只能施展魔法到达 $( 3, 2),( 2, 3),( 3, 4),( 4, 3)$。

而从以上四点均无法到达 $( 5, 5)$，故无法到达终点，输出$-1$。

**数据规模与约定**

对于 $30\%$ 的数据，$1 ≤ m ≤ 5, 1 ≤ n ≤ 10$。

对于 $60\%$ 的数据，$1 ≤ m ≤ 20, 1 ≤ n ≤ 200$。

对于 $100\%$ 的数据，$1 ≤ m ≤ 100, 1 ≤ n ≤ 1,000$。



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
#define maxn 100005
#define maxm 2000005
#define inf 0x3f3f3f3f
template <typename Tp>
void read(Tp &x){
char c=getchar();x=0;int f=1;
while(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}
while(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}x*=f;
}//快速读入，不解释
struct Edge{
int f,t,w,nxt;
}edge[maxm];
int head[maxn],etot=1;//这里有一个小技巧，存图时边数初值设为一个奇数
void add_edge(int f,int t,int w){//这样可以利用位运算成对变化找到反向边
edge[++etot]=(Edge){f,t,w,head[f]};
head[f]=etot;
}//链式前向星存图
//--------以下内容为 zkw线段树
//主要思路，用线段树维护dis
//dis1数组表示在线段树中的dis
//tr数组记录当前最小dis对应的节点编号
//有关zkw线段树，可以参考洛谷日报的讲解，这里不多说
int tr[maxn<<2],dis1[maxn<<2],bt;
int n,m,S,T;
void build(){
for(bt=1;bt<=n+1;bt<<=1);//bt初始化，zkw线段树的初始操作
for(int i=1;i<=n;i++)tr[i+bt]=i;//tr数组初始化
memset(dis1,0x3f,sizeof(dis1));//dis1数组初始化
//因为这里dis初值都是inf，所以可以这样直接赋值
}
void modify(int x,int val){
dis1[x]=val;x+=bt;//单点修改
for(x>>=1;x;x>>=1){//以下是zkw线段树常规操作
if(dis1[tr[x<<1]]<dis1[tr[(x<<1)|1]])tr[x]=tr[x<<1];
else tr[x]=tr[(x<<1)|1];
}
}//其实上面的内容并不是很长，只是注释比较多
int dis[maxn];
void dijkstra(){
memset(dis,0x3f,sizeof(dis));
build();//build()不可忘
dis[S]=0;modify(S,0);//源点更新
int x,y,w;
for(int j=1;j<=n;j++){//这里tr[1]维护的是[1,n]dis的最小值的节点编号，所以直接调用
x=tr[1];modify(x,inf);//这里将x设为极大值，来取代删除操作
for(int i=head[x];i;i=edge[i].nxt){
y=edge[i].t;w=edge[i].w;
if(dis[y]>dis[x]+w){//dijkstra松弛操作
dis[y]=dis[x]+w;
modify(y,dis[y]);//直接更新
}
}
}
}
int dx[]={0,1,0,-1,1,1,-1,-1,0,2,0,-2};//12方向及魔法代价
int dy[]={1,0,-1,0,1,-1,1,-1,2,0,-2,0};
int dw[]={0,0,0,0,2,2,2,2,2,2,2,2};
int a[105][105],cnt[105][105];
struct node{
int x,y,c;
}b[maxn];
//a存储棋盘上格子的颜色
//cnt表示棋盘上的格子对应的节点编号
void preprocess(){//建图
int x,y,c,xx,yy,ww;
for(int i=1;i<=n;i++){
x=b[i].x;y=b[i].y;c=b[i].c;
for(int j=0;j<12;j++){
xx=x+dx[j];yy=y+dy[j];ww=dw[j];
if(a[xx][yy]){
if(a[xx][yy]!=c)ww++;
add_edge(i,cnt[xx][yy],ww);
}
}
}//这一段在上文题解中讲的比较详细，这里不再多说
S=cnt[1][1];
}
int main(){
int mm,x,y,c;
read(mm);read(n);
for(int i=1;i<=n;i++){
read(x);read(y);read(c);
a[x][y]=c+1;cnt[x][y]=i;
b[i]=(node){x,y,c+1};
}//这里c+1，为了方便区分无色格子
preprocess();
dijkstra();//因为在图论中m常代表的含义是边数
if(!a[mm][mm]){//所以用mm取代原题目中的m，即棋盘大小
int ans=min(dis[cnt[mm][mm-1]],dis[cnt[mm-1][mm]])+2;
if(ans>=inf)puts("-1");
else printf("%d\n",ans);
}//(m,m)没有颜色的特判
else{
if(dis[cnt[mm][mm]]==inf)puts("-1");
else printf("%d\n",dis[cnt[mm][mm]]);
}
return 0;
}
```

---

## 题目: P3957

**提交时间：2024-05-29 16:13:02**

---
title: "[NOIP 2017 普及组] 跳房子"
layout: "post"
diff: 提高+/省选-
pid: P3957
tag: ['动态规划 DP', '2017', '二分', '单调队列', 'NOIP 普及组', '队列']
---
# [NOIP 2017 普及组] 跳房子
## 题目背景

NOIP2017 普及组 T4
## 题目描述

跳房子，也叫跳飞机，是一种世界性的儿童游戏，也是中国民间传统的体育游戏之一。

跳房子的游戏规则如下：

在地面上确定一个起点，然后在起点右侧画 $n$ 个格子，这些格子都在同一条直线上。每个格子内有一个数字（整数），表示到达这个 格子能得到的分数。玩家第一次从起点开始向右跳，跳到起点右侧的一个格子内。第二次再从当前位置继续向右跳，依此类推。规则规定：

玩家每次都必须跳到当前位置右侧的一个格子内。玩家可以在任意时刻结束游戏，获得的分数为曾经到达过的格子中的数字之和。

现在小 R 研发了一款弹跳机器人来参加这个游戏。但是这个机器人有一个非常严重的缺陷，它每次向右弹跳的距离只能为固定的 $d$。小 R 希望改进他的机器人，如果他花 $g$ 个金币改进他的机器人，那么他的机器人灵活性就能增加 $g$，但是需要注意的是，每 次弹跳的距离至少为 $1$。具体而言，当 $g<d$ 时，他的机器人每次可以选择向右弹跳的距离为 $d-g,d-g+1,d-g+2,\ldots,d+g-1,d+g$；否则当 $g \geq d$ 时，他的机器人每次可以选择向右弹跳的距离为 $1,2,3,\ldots,d+g-1,d+g$。

现在小 R 希望获得至少 $k$ 分，请问他至少要花多少金币来改造他的机器人。
## 输入格式

第一行三个正整数 $n,d,k$，分别表示格子的数目，改进前机器人弹跳的固定距离，以及希望至少获得的分数。相邻两个数 之间用一个空格隔开。

接下来 $n$ 行，每行两个整数 $x_i,s_i$，分别表示起点到第 $i$ 个格子的距离以及第 $i$ 个格子的分数。两个数之间用一个空格隔开。保证 $x_i$ 按递增顺序输入。
## 输出格式

共一行，一个整数，表示至少要花多少金币来改造他的机器人。若无论如何他都无法获得至少 $k$ 分，输出 $-1$。
## 样例

### 样例输入 #1
```
7 4 10
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
7 4 20
2 6
5 -3
10 3
11 -3
13 1
17 6
20 2
```
### 样例输出 #2
```
-1
```
## 提示

**样例 1 说明**

花费 $2$ 个金币改进后，小 R 的机器人依次选择的向右弹跳的距离分别为 $ 2, 3, 5, 3, 4,3$，先后到达的位置分别为 $2, 5, 10, 13, 17, 20$，对应 $ 1, 2, 3, 5, 6, 7$ 这 $6$ 个格子。这些格子中的数字之和 $ 15$ 即为小 R 获得的分数。

**样例 2 说明**

由于样例中 $7$ 个格子组合的最大可能数字之和只有 $18$，所以无论如何都无法获得 $20$ 分。

**数据规模与约定**

本题共 10 组测试数据，每组数据等分。

对于全部的数据满足 $1 \le n \le 5\times10^5$，$1 \le d \le2\times10^3$，$1 \le x_i, k \le 10^9$，$|s_i| < 10^5$。

对于第 $1, 2$ 组测试数据，保证 $n\le 10$。

对于第 $3, 4, 5$ 组测试数据，保证 $n \le 500$。

对于第 $6, 7, 8$ 组测试数据，保证 $d = 1$。


### 代码

```cpp
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;
const int maxn=500000;
const long long neInf=0x8080808080808080;
struct gezi {
int juli;
int zhi;
} a[maxn+1];
long long dp[maxn+1];
int q[maxn+1];
int n,d,k,lbound,rbound,ans=-1;
long long sum;
void kuaidu(int &p) {
char c;
int f=1;
p=0;
do {
c=getchar();
if (c=='-')
f=-1;
} while (c<'0'||c>'9');
do p=p*10+c-'0', c=getchar();
while (c>='0'&&c<='9');
p=p*f;
}
void init() {
cin>>n>>d>>k;
for (int i=1; i<=n; i++) {
kuaidu(a[i].juli);
kuaidu(a[i].zhi);
if (a[i].zhi>0)
sum+=a[i].zhi;
}
rbound=max(a[n].juli,d);
}
long long dynamic_programming(int zuo, int you) {
memset(dp,0x80,sizeof(dp));
dp[0]=0;
memset(q,0,sizeof(q));
int tou=1, wei=0, j=0;
/*for (int i=1; i<=n; i++)
for (int j=0; j<i; j++)
if (a[i].juli-a[j].juli>=zuo&&a[i].juli-a[j].juli<=you&&dp[j]!=neInf)
dp[i]=max(dp[i],dp[j]+a[i].zhi);*/
for (int i=1; i<=n; i++) {
while (a[i].juli-a[j].juli>=zuo&&j<i) {
if (dp[j]!=neInf) {
while (tou<=wei&&dp[q[wei]]<=dp[j])
wei--;
q[++wei]=j;
}
j++;
}
while (tou<=wei&&a[i].juli-a[q[tou]].juli>you)
tou++;
if (tou<=wei)
dp[i]=dp[q[tou]]+a[i].zhi;
}
long long num=neInf;
for (int i=1; i<=n; i++)
if (dp[i]>num)
num=dp[i];
return num;
}
int main() {
//freopen("jump.in","r",stdin);
//freopen("jump.out","w",stdout);
init();
if (sum<k) {
cout<<"-1"<<endl;
return 0;
}
while (lbound<=rbound) {
int mid=(lbound+rbound)/2;
int zuobianjie=max(1,d-mid);
int youbianjie=d+mid;
long long num=dynamic_programming(zuobianjie,youbianjie);
if (num<k)
lbound=mid+1;
else {
ans=mid;
rbound=mid-1;
}
}
cout<<ans<<endl;
//fclose (stdin);
//fclose (stdout);
return 0;
}
```

---

## 题目: P4093

**分类：数据结构--线段树的进阶用法**

**提交时间：2023-11-12 13:38:51**

---
title: "[HEOI2016/TJOI2016] 序列"
layout: "post"
diff: 省选/NOI-
pid: P4093
tag: ['2016', '线段树', '各省省选', '河北', 'cdq 分治', 'O2优化', '树套树', '天津']
---
# [HEOI2016/TJOI2016] 序列
## 题目描述

佳媛姐姐过生日的时候，她的小伙伴从某宝上买了一个有趣的玩具送给他。

玩具上有一个数列，数列中某些项的值可能会变化，但同一个时刻最多只有一个值发生变化。现在佳媛姐姐已经研究出了所有变化的可能性，她想请教你，能否选出一个子序列，使得在**任意一种变化和原序列**中，这个子序列都是不降的？请你告诉她这个子序列的最长长度即可。
## 输入格式

输入的第一行有两个正整数 $n,m$，分别表示序列的长度和变化的个数。

接下来一行有 $n$ 个整数，表示这个数列原始的状态。

接下来 $m$ 行，每行有 $2$ 个整数 $x,y$，表示数列的第 $x$ 项可以变化成 $y$ 这个值。

## 输出格式

输出一个整数，表示对应的答案。

## 样例

### 样例输入 #1
```
3 4 
1 2 3 
1 2 
2 3 
2 1 
3 4
```
### 样例输出 #1
```
3

```
## 提示

注意：每种变化最多只有一个值发生变化。

在样例输入中，所有的变化是：
```plain
1 2 3
2 2 3
1 3 3
1 1 3
1 2 4
```
选择子序列为原序列，即在任意一种变化中均为不降子序列。

对于 $20\%$ 数据，所有数均为正整数，且小于等于 $300$。

对于 $50\%$ 数据，所有数字均为正整数，且小于等于 $3000$。

对于 $100\%$ 数据，所有数字均为正整数，且小于等于 $10^5$。$1\le x\le n$。



### 代码

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
const int MN = 100005;
const int MC = 100000;
int N, M;
int A[MN], Mx[MN], Mn[MN];
int f[MN], Ans;
int p[MN];
inline bool cmp1(int i, int j) { return Mx[i] < Mx[j]; }
inline bool cmp2(int i, int j) { return A[i] < A[j]; }
int B[MN];
inline void Ins(int i, int x) { for (; i <= MC; i += i & -i) B[i] = max(B[i], x); }
inline void Clr(int i) { for (; i <= MC; i += i & -i) B[i] = 0; }
inline int Qur(int i) { int A = 0; for (; i; i -= i & -i) A = max(A, B[i]); return A;}
void CDQ(int lb, int rb) {
if (lb == rb) {
f[lb] = max(f[lb], 1);
return;
}
int mid = lb + rb >> 1;
CDQ(lb, mid);
for (int i = lb; i <= rb; ++i)
p[i] = i;
sort(p + lb, p + mid + 1, cmp1);
sort(p + mid + 1, p + rb + 1, cmp2);
int j = lb;
for (int i = mid + 1; i <= rb; ++i) {
while (j <= mid && Mx[p[j]] <= A[p[i]]) {
Ins(A[p[j]], f[p[j]]);
++j;
}
f[p[i]] = max(f[p[i]], Qur(Mn[p[i]]) + 1);
}
for (int i = lb; i <= mid; ++i)
Clr(A[i]);
CDQ(mid + 1, rb);
}
int main() {
int x, y;
scanf("%d%d", &N, &M);
for (int i = 1; i <= N; ++i)
scanf("%d", &A[i]),
Mx[i] = Mn[i] = A[i];
for (int i = 1; i <= M; ++i)
scanf("%d%d", &x, &y),
Mx[x] = max(Mx[x], y),
Mn[x] = min(Mn[x], y);
CDQ(1, N);
for (int i = 1; i <= N; ++i)
Ans = max(Ans, f[i]);
printf("%d\n", Ans);
return 0;
}
```

---

## 题目: P4325

**提交时间：2025-04-12 08:19:57**

---
title: "[COCI 2006/2007 #1] Modulo"
layout: "post"
diff: 入门
pid: P4325
tag: ['2006', '枚举', '排序', 'COCI（克罗地亚）']
---
# [COCI 2006/2007 #1] Modulo
## 题目描述

Given two integers A and B, A modulo B is the remainder when dividing A by B. For example, the numbers 7, 14, 27 and 38 become 1, 2, 0 and 2, modulo 3. Write a program that accepts 10 numbers as input and outputs the number of distinct numbers in the input, if the numbers are considered modulo 42.
## 输入格式

The input will contain 10 non-negative integers, each smaller than 1000, one per line.
## 输出格式

Output the number of distinct values when considered modulo 42 on a single line.
## 样例

### 样例输入 #1
```
1
2
3
4
5
6
7
8
9
10
```
### 样例输出 #1
```
10
```
### 样例输入 #2
```
42
84
252
420
840
126
42
84
420
126
```
### 样例输出 #2
```
1
```
### 样例输入 #3
```
39
40
41
42
43
44
82
83
84
85
```
### 样例输出 #3
```
6
```
## 提示

In the first example, the numbers modulo 42 are 1, 2, 3, 4, 5, 6, 7, 8, 9 and 10.
In the second example all numbers modulo 42 are 0.
In the third example, the numbers modulo 42 are 39, 40, 41, 0, 1, 2, 40, 41, 0 and 1. There are 6 distinct numbers.
## 题目翻译

给出 $10$ 个整数，问这些整数除以 $42$ 后得到的余数有多少种。

- 第一个样例的十个结果是 $1,2,3,4,5,6,7,8,9,10$，有 $10$ 个不同的结果；
- 第二个样例结果都是 $0$，只有一个不同的结果；
- 第三个样例余数是 $39,40,41,0,1,2,40,41,0,1$，有 $0,1,2,39,40,41$ 这六个不同的结果。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[15],sum=0;
int main(){
for(int i=1;i<=10;i++){
cin>>a[i];
a[i]%=42;
}
for(int i=1;i<=10;i++){
if(a[i]!=-1){
for(int j=1;j<=10;j++){
if(j!=i&&a[i]==a[j]){
a[j]=-1;
}
}
}
}
for(int i=1;i<=10;i++){
if(a[i]!=-1){
sum+=1;
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P4414

**分类：入门-分支结构**

**提交时间：2024-01-28 08:35:37**

---
title: "[COCI 2006/2007 #2] ABC"
layout: "post"
diff: 入门
pid: P4414
tag: ['模拟', '2006', '排序', 'COCI（克罗地亚）']
---
# [COCI 2006/2007 #2] ABC
## 题目描述

You will be given three integers A, B and C. The numbers will not be given in that exact order, but we do know that A is less than B and B less than C.
In order to make for a more pleasant viewing, we want to rearrange them in the given order.
## 输入格式

The first line contains three positive integers A, B and C, not necessarily in that order. All three numbers will be less than or equal to 100.
The second line contains three uppercase letters 'A', 'B' and 'C' (with no spaces between them) representing the desired order.
## 输出格式

Output the A, B and C in the desired order on a single line, separated by single spaces.
## 样例

### 样例输入 #1
```
1 5 3
ABC
```
### 样例输出 #1
```
1 3 5
```
### 样例输入 #2
```
6 4 2
CAB
```
### 样例输出 #2
```
6 2 4
```
## 题目翻译

**【题目描述】**

三个整数分别为 $A,B,C$。这三个数字不会按照这样的顺序给你，但它们始终满足条件：$A < B < C$。为了看起来更加简洁明了，我们希望你可以按照给定的顺序重新排列它们。

**【输入格式】**

第一行包含三个正整数 $A,B,C$，不一定是按这个顺序。这三个数字都小于或等于 $100$。第二行包含三个大写字母 $A$、$B$ 和 $C$（它们之间**没有**空格）表示所需的顺序。

**【输出格式】**

在一行中输出 $A$，$B$ 和 $C$，用一个 ` `（空格）隔开。

感谢 @smartzzh 提供的翻译


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int a[3];
char A,B,C;
int main()
{
cin>>a[0]>>a[1]>>a[2];
cin>>A>>B>>C;
sort(a,a+3);
cout<<a[A-'A']<<" "<<a[B-'A']<<" "<<a[C-'A'];
return 0;
}
```

---

## 题目: P4447

**分类：算法--贪心**

**提交时间：2025-04-11 20:07:49**

---
title: "[AHOI2018初中组] 分组"
layout: "post"
diff: 普及+/提高
pid: P4447
tag: ['贪心', '2018', '二分', '安徽', '队列']
---
# [AHOI2018初中组] 分组
## 题目描述

小可可的学校信息组总共有 $n$ 个队员，每个人都有一个实力值 $a_i$。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的 $n$ 个队员分成若干个小组去参加这场比赛。

但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：$[1, 2, 3, 4, 5]$ 是合法的分组方案，因为实力值连续；$[1, 2, 3, 5]$ 不是合法的分组方案，因为实力值不连续；$[0, 1, 1, 2]$ 同样不是合法的分组方案，因为出现了两个实力值为 $1$ 的选手。

如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。

注意：实力值可能是负数，分组的数量没有限制。
## 输入格式

输入有两行：

第一行一个正整数 $n$，表示队员数量。  
第二行有 $n$ 个整数，第 $i$ 个整数 $a_i$ 表示第 $i$ 个队员的实力。
## 输出格式

输出一行，包括一个正整数，表示人数最少的组的人数最大值。
## 样例

### 样例输入 #1
```
7
4 5 2 3 -4 -3 -5
```
### 样例输出 #1
```
3

```
## 提示

【样例解释】
分为 $2$ 组，一组的队员实力值是 $\{4, 5, 2, 3\}$，一组是 $\{-4, -3, -5\}$，其中最小的组人数为 $3$，可以发现没有比 $3$ 更优的分法了。

【数据范围】

对于 $100\%$ 的数据满足：$1\leq n\leq 100000$，$|a_i|\leq10^9$。

本题共 $10$ 个测试点，编号为 $1\sim10$，每个测试点额外保证如下：
| 测试点编号 | 数据限制 |
| :-----------: | :-----------: |
| $1\sim2$ | $n\leq 6, 1\leq a_i \leq 100$ |
| $3\sim4$ | $n\leq 1000, 1\leq a_i\leq 10^5$ 且 $a_i$ 互不相同 |
| $5\sim6$ | $n\leq 100000, a_i$ 互不相同 |
| $7\sim8$ | $n\leq 100000, 1\leq a_i \leq10^5$ |
| $9\sim 10$ | $n\leq 100000, -10^9 \leq a_i \leq 10^9$ |


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[100005],mark;
struct node{
int num,s;
}t[100005];
void insert(int k){
int find=0,flag=0,tnum=100005;
for(int i=0;i<mark;i++){
if(t[i].s==k-1){
if(t[i].num<tnum){
flag=i;
find=1;
tnum=t[i].num;
}
}
}
if(find==1){
t[flag].s=k;
t[flag].num+=1;
}
else{
t[mark].s=k;
t[mark].num=1;
mark+=1;
}
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
sort(a+1,a+n+1);
for(int i=1;i<=n;i++){
insert(a[i]);
}
int ans=t[0].num;
for(int i=1;i<mark;i++){
ans=min(ans,t[i].num);
}
cout<<ans;
return 0;
}
```

---

## 题目: P4552

**分类：算法--前缀和、差分与离散化**

**提交时间：2024-11-08 22:17:56**

---
title: "[Poetize6] IncDec Sequence"
layout: "post"
diff: 普及+/提高
pid: P4552
tag: ['差分']
---
# [Poetize6] IncDec Sequence
## 题目描述

给定一个长度为 $n$ 的数列 ${a_1,a_2,\cdots,a_n}$，每次可以选择一个区间$[l,r]$，使这个区间内的数都加 $1$ 或者都减 $1$。 
  
请问至少需要多少次操作才能使数列中的所有数都一样，并求出在保证最少次数的前提下，最终得到的数列有多少种。
## 输入格式

第一行一个正整数 $n$   
接下来 $n$ 行,每行一个整数,第 $i+1 $行的整数表示 $a_i$。
## 输出格式

第一行输出最少操作次数   
第二行输出最终能得到多少种结果

## 样例

### 样例输入 #1
```
4
1
1
2
2
```
### 样例输出 #1
```
1
2
```
## 提示

对于 $100\%$ 的数据，$n\le 100000, 0 \le a_i \le 2^{31}$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long a[100005],n,add=0,sub=0,x;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
if(i==1){
continue;
}
x=a[i-1]-a[i];
if(x>0){
add+=x;
}
else{
sub-=x;
}
}
cout<<max(add,sub)<<endl;
cout<<abs(add-sub)+1;
return 0;
}
```

---

## 题目: P4956

**分类：入门-循环结构**

**提交时间：2024-01-26 10:55:33**

---
title: "[COCI 2017/2018 #6] Davor"
layout: "post"
diff: 入门
pid: P4956
tag: ['2017', '不定方程', 'COCI（克罗地亚）']
---
# [COCI 2017/2018 #6] Davor
## 题目描述

After successfully conquering the South Pole, Davor is preparing for new challenges. Next up is the Arctic expedition to Siberia, Greenland and Norway. He begins his travels on 31 December 2018, and needs to collect ​N kunas (Croatian currency) by then. In order to do this, he has decided to put away ​X (​X ≤ 100) kunas every Monday to his travel fund, ​X + K kunas every Tuesday, ​X + 2* ​K every Wednesday, and so on until Sunday, when he will put away ​X + 6* ​K kunas. This way, he will collect money for 52 weeks, starting with 1 January 2018 (Monday) until 30 December 2018 (Sunday).

If we know the amount of money ​N​, output the values ​X and ​K so that it is possible to collect the ​**exact** money amount in the given timespan. The solution will always exist, and if there are multiple, output the one with the greatest ​X ​ and smallest ​K ​.
## 输入格式

The first line of input contains the integer ​N​ (1456 ≤ ​N​ ≤ 145600), the number from the task.
## 输出格式

The first line of output must contain the value of ​X (​0 < ​X ​≤ 100 ​)​, and the second the value of
K (K ​> 0 ​)​.
## 样例

### 样例输入 #1
```
1456
```
### 样例输出 #1
```
1
1
```
### 样例输入 #2
```
6188
```
### 样例输出 #2
```
14
1
```
### 样例输入 #3
```
40404
```
### 样例输出 #3
```
99
4
```
## 题目翻译

在征服南极之后，Davor 开始了一项新的挑战。下一步是在西伯利亚、格林兰、挪威的北极圈远征。他将在 $2018$ 年 $12$ 月 $31$ 日开始出发，在这之前需要一共筹集 $n$ 元钱。他打算在每个星期一筹集 $x$ 元，星期二筹集 $x+k$ 元，……，星期日筹集 $x+6k$ 元，并连续筹集 $52$ 个星期。其中 $x,k$ 为正整数，并且满足 $1 \le x \le 100$。

现在请你帮忙计算 $x,k$ 为多少时，能刚好筹集 $n$ 元。

如果有多个答案，输出 $x$ 尽可能大，$k$ 尽可能小的。注意 $k$ 必须大于 $0$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n, x, k;
int main()
{
cin >> n;
for (int i = 100; i >= 1; i--)
{
for (int j = 1; j < n; j++)
{
if ((7 * i + 21 * j) * 52 == n)
{
x = i;
k = j;
cout << x << endl;
cout << k << endl;
return 0;
}
}
}
return 0;
}
```

---

## 题目: P4995

**分类：算法--贪心**

**提交时间：2025-02-04 12:26:11**

---
title: "跳跳！"
layout: "post"
diff: 普及-
pid: P4995
tag: ['贪心', '排序', '洛谷月赛']
---
# 跳跳！
## 题目描述

你是一只小跳蛙，你特别擅长在各种地方跳来跳去。

这一天，你和朋友小 F 一起出去玩耍的时候，遇到了一堆高矮不同的石头，其中第 $i$ 块的石头高度为 $h_i$，地面的高度是 $h_0 = 0$。你估计着，从第 $i$ 块石头跳到第 $j$ 块石头上耗费的体力值为 $(h_i - h_j) ^ 2$，从地面跳到第 $i$ 块石头耗费的体力值是 $(h_i) ^ 2$。

为了给小 F 展现你超级跳的本领，你决定跳到每个石头上各一次，并最终停在任意一块石头上，并且小跳蛙想耗费**尽可能多**的体力值。

当然，你只是一只小跳蛙，你只会跳，不知道怎么跳才能让本领更充分地展现。

不过你有救啦！小 F 给你递来了一个写着 AK 的电脑，你可以使用计算机程序帮你解决这个问题，万能的计算机会告诉你怎么跳。

那就请你——会写代码的小跳蛙——写下这个程序，为你 NOIp AK 踏出坚实的一步吧！
## 输入格式

输入一行一个正整数 $n$，表示石头个数。

输入第二行 $n$ 个正整数，表示第 $i$ 块石头的高度 $h_i$。
## 输出格式

输出一行一个正整数，表示你可以耗费的体力值的最大值。
## 样例

### 样例输入 #1
```
2
2 1
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
3
6 3 5

```
### 样例输出 #2
```
49
```
## 提示

#### 样例解释

两个样例按照输入给定的顺序依次跳上去就可以得到最优方案之一。

#### 数据范围
对于 $1 \leq i \leq n$，有 $0 < h_i \leq 10 ^ 4$，且保证 $h_i$ 互不相同。

对于 $10\%$ 的数据，$n \leq 3$；

对于 $20\%$ 的数据，$n \leq 10$；

对于 $50\%$ 的数据，$n \leq 20$；

对于 $80\%$ 的数据，$n \leq 50$；

对于 $100\%$ 的数据，$n \leq 300$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[305],ans=0,now;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
sort(a+1,a+n+1);
ans+=a[n]*a[n];
ans+=(a[n]-a[1])*(a[n]-a[1]);
now=a[1];
for(int i=2;i<=n/2;i++){
for(int j=1;j<=2;j++){
if(j==2){
ans+=(now-a[i])*(now-a[i]);
now=a[i];
}
else{
ans+=(now-a[n-i+1])*(now-a[n-i+1]);
now=a[n-i+1];
}
}
}
if(n%2==1){
ans+=(now-a[n/2+1])*(now-a[n/2+1]);
}
cout<<ans;
return 0;
}
```

---

## 题目: P5015

**分类：入门-字符串**

**提交时间：2024-09-02 20:35:39**

---
title: "[NOIP 2018 普及组] 标题统计"
layout: "post"
diff: 入门
pid: P5015
tag: ['模拟', '字符串', '2018', 'NOIP 普及组']
---
# [NOIP 2018 普及组] 标题统计
## 题目背景

NOIP2018 普及组 T1
## 题目描述

凯凯刚写了一篇美妙的作文，请问这篇作文的标题中有多少个字符？ 注意：标题中可能包含大、小写英文字母、数字字符、空格和换行符。统计标题字符数时，空格和换行符不计算在内。 
## 输入格式

输入文件只有一行，一个字符串 $s$。 
## 输出格式

输出文件只有一行，包含一个整数，即作文标题的字符数（不含空格和换行符）。 
## 样例

### 样例输入 #1
```
234 
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
Ca 45 
```
### 样例输出 #2
```
4
```
## 提示

**样例 1 说明**   

标题中共有 3 个字符，这 3 个字符都是数字字符。   

**样例 2 说明**

标题中共有 $ 5$ 个字符，包括 $1$ 个大写英文字母， $1$ 个小写英文字母和 $2$ 个数字字符， 还有 $1$ 个空格。由于空格不计入结果中，故标题的有效字符数为 $4$ 个。 

**数据规模与约定**

规定 $|s|$ 表示字符串 $s$ 的长度（即字符串中的字符和空格数）。    
对于 $40\%$ 的数据，$1 ≤ |s| ≤ 5$，保证输入为数字字符及行末换行符。   
对于 $80\%$ 的数据，$1 ≤ |s| ≤ 5$，输入只可能包含大、小写英文字母、数字字符及行末换行符。   
对于 $100\%$ 的数据，$1 ≤ |s| ≤ 5$，输入可能包含大、小写英文字母、数字字符、空格和行末换行符。 


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
string n;
int x,ans=0;
int main()
{
while(cin>>n)
{
x=n.length();
for(int i=0;i<x;i++)
{
if((n[i]>='0'&&n[i]<='9')||(n[i]>='a'&&n[i]<='z')||(n[i]>='A'&&n[i]<='Z'))
{
ans+=1;
}
}
}
cout<<ans;
return 0;
}
```

---

## 题目: P5020

**分类：动态规划**

**提交时间：2025-04-01 19:35:43**

---
title: "[NOIP 2018 提高组] 货币系统"
layout: "post"
diff: 普及+/提高
pid: P5020
tag: ['动态规划 DP', '数学', '贪心', '2018', 'NOIP 提高组', '背包 DP']
---
# [NOIP 2018 提高组] 货币系统
## 题目背景

NOIP2018 提高组 D1T2
## 题目描述

在网友的国度中共有 $n$ 种不同面额的货币，第 $i$ 种货币的面额为 $a[i]$，你可以假设每一种货币都有无穷多张。为了方便，我们把货币种数为 $n$、面额数组为 $a[1..n]$ 的货币系统记作 $(n,a)$。 

在一个完善的货币系统中，每一个非负整数的金额 $x$ 都应该可以被表示出，即对每一个非负整数 $x$，都存在 $n$ 个非负整数 $t[i]$ 满足 $a[i] \times t[i]$ 的和为 $x$。然而， 在网友的国度中，货币系统可能是不完善的，即可能存在金额 $x$ 不能被该货币系统表示出。例如在货币系统 $n=3$, $a=[2,5,9]$ 中，金额 $1,3$ 就无法被表示出来。 

两个货币系统 $(n,a)$ 和 $(m,b)$ 是等价的，当且仅当对于任意非负整数 $x$，它要么均可以被两个货币系统表出，要么不能被其中任何一个表出。 

现在网友们打算简化一下货币系统。他们希望找到一个货币系统 $(m,b)$，满足 $(m,b)$ 与原来的货币系统 $(n,a)$ 等价，且 $m$ 尽可能的小。他们希望你来协助完成这个艰巨的任务：找到最小的 $m$。 
## 输入格式

输入文件的第一行包含一个整数 $T$，表示数据的组数。

接下来按照如下格式分别给出 $T$ 组数据。 每组数据的第一行包含一个正整数 $n$。接下来一行包含 $n$ 个由空格隔开的正整数 $a[i]$。
## 输出格式

输出文件共有 $T$ 行，对于每组数据，输出一行一个正整数，表示所有与 $(n,a)$ 等价的货币系统 $(m,b)$ 中，最小的 $m$。
## 样例

### 样例输入 #1
```
2 
4 
3 19 10 6 
5 
11 29 13 19 17 
```
### 样例输出 #1
```
2   
5  
```
## 提示

在第一组数据中，货币系统 $(2, [3,10])$ 和给出的货币系统 $(n, a)$ 等价，并可以验证不存在 $m < 2$ 的等价的货币系统，因此答案为 $2$。 在第二组数据中，可以验证不存在 $m < n$ 的等价的货币系统，因此答案为 $5$。 

【数据范围与约定】

![](https://cdn.luogu.com.cn/upload/pic/43160.png)  

对于 $100\%$ 的数据，满足 $1 ≤ T ≤ 20, n,a[i] ≥ 1$。 


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,a[105],dp[25005],ans;
int main(){
cin>>t;
for(int i=1;i<=t;i++){
cin>>n;
for(int j=1;j<=n;j++){
cin>>a[j];
}
sort(a+1,a+n+1);
memset(dp,0,sizeof(dp));
dp[0]=1;
for(int j=1;j<=n;j++){
for(int k=a[j];k<=a[n];k++){
dp[k]+=dp[k-a[j]];
}
}
ans=0;
for(int j=1;j<=n;j++){
if(dp[a[j]]==1){
ans+=1;
}
}
cout<<ans<<endl;
}
return 0;
}
```

---

## 题目: P5322

**分类：动态规划**

**提交时间：2025-04-12 07:59:21**

---
title: "[BJOI2019] 排兵布阵"
layout: "post"
diff: 普及+/提高
pid: P5322
tag: ['动态规划 DP', '2019', '各省省选', '北京', 'O2优化', '背包 DP']
---
# [BJOI2019] 排兵布阵
## 题目描述

小 C 正在玩一款排兵布阵的游戏。在游戏中有 $n$ 座城堡，每局对战由两名玩家来争夺这些城堡。每名玩家有 $m$ 名士兵，可以向第 $i$ 座城堡派遣 $a_i$ 名士兵去争夺这个城堡，使得总士兵数不超过 $m$。   

如果一名玩家向第 $i$ 座城堡派遣的士兵数**严格**大于对手派遣士兵数的两倍，那么这名玩家就占领了这座城堡，获得 $i$ 分。  

现在小 C 即将和其他 $s$ 名玩家两两对战，这 $s$ 场对决的派遣士兵方案必须相同。小 C 通过某些途径得知了其他 $s$ 名玩家即将使用的策略，他想知道他应该使用什么策略来最大化自己的总分。   

由于答案可能不唯一，你只需要输出小 C 总分的最大值。
## 输入格式

输入第一行包含三个正整数 $s,n,m$，分别表示除了小 C 以外的玩家人数、城堡数和每名玩家拥有的士兵数。   
接下来 $s$ 行，每行 $n$ 个非负整数，表示一名玩家的策略，其中第 $i$ 个数 $a_i$ 表示这名玩家向第 $i$ 座城堡派遣的士兵数。


## 输出格式

输出一行一个非负整数，表示小 C 获得的最大得分。
## 样例

### 样例输入 #1
```
1 3 10
2 2 6
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
2 3 10
2 2 6
0 0 0
```
### 样例输出 #2
```
8
```
## 提示

**样例1解释：**  
小 C 的最佳策略为向第 $1$ 座城堡和第 $2$ 座城堡各派遣 $5$ 名士兵。 

**样例2解释：**  
小 C 的最佳策略之一为向第 $1$ 座城堡派遣 $2$ 名士兵，向第 $2$ 座城堡派遣 $5$ 名士兵，向第 $3$ 座城堡派遣 $1$ 名士兵。  

**数据范围：**   
对于 $10\%$ 的数据： $s=1,n \le 3,m \le 10$   
对于 $20\%$ 的数据： $s=1,n \le 10,m \le 100$   
对于 $40\%$ 的数据： $n\le 10,m\le 100$     
对于另外 $20\%$ 的数据： $s=1$     
对于 $100\%$ 的数据：  
$1\le s \le 100$  
$1\le n \le 100$  
$1\le m \le 20000$   
对于每名玩家 $a_i \ge 0$，$\sum\limits_{i=1}^n a_i \le m$   



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int s,n,m,a[105][105],dp[20005];
int main(){
cin>>s>>n>>m;
for(int i=1;i<=s;i++){
for(int j=1;j<=n;j++){
cin>>a[j][i];
}
}
for(int i=1;i<=n;i++){
sort(a[i]+1,a[i]+s+1);
}
for(int i=1;i<=n;i++){
for(int j=m;j>=0;j--){
for(int k=1;k<=s;k++){
if(j>a[i][k]*2){
dp[j]=max(dp[j-a[i][k]*2-1]+k*i,dp[j]);
}
}
}
}
cout<<dp[m];
return 0;
}
```

---

## 题目: P5464

**分类：动态规划-动态规划的设计与优化**

**提交时间：2023-11-10 15:16:06**

---
title: "缩小社交圈"
layout: "post"
diff: 省选/NOI-
pid: P5464
tag: ['洛谷月赛']
---
# 缩小社交圈
## 题目描述

社交圈子里有 $n$ 个人，每个人都有一个 SAN 值范围 $[l_i,r_i]$。当两个人的 SAN 值交集不为空时，这两个人有 PY 关系。

现在希望从社交圈子里面挑选出一些人组成一个集合 $S$，如果将所有集合内的人中有 PY 关系的那一对人都连上边，则 $S$ 刚好成为一个树（森林不行哦）。

请问，有多少种可以选择的方案？由于答案可能很大，请对 $10^{9}+7$ 取模。
## 输入格式

第一行一个整数 $n$。

接下来 $n$ 行，每行 2 个整数，表示这个人的 SAN 值区间。
## 输出格式

一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
3
1 5
2 7
4 8

```
### 样例输出 #1
```
6
```
## 提示

对于20%的数据，满足 $n \leq 18$ 。

对于40%的数据，满足 $n \leq 50$

对于60%的数据，满足 $n \leq 200$

对于100%的数据，满足 $n \leq 2000,1 \leq l_{i} <r_{i} \leq 4000 $



### 代码

```cpp
#include<bits/stdc++.h>
using namespace std ;
#define N 3000
const int Mod = 1e9 + 7 ;
inline int read()
{
int x = 0, f = 1; char c = getchar();
while(c < '0' || c > '9') { c = getchar();}
while(c >= '0' && c <= '9') x = x * 10 + c - 48, c = getchar();
return x * f;
}
int n ;
int dp[N][N] , sum[N][N] , pre[N] ;
struct node{
int L , R ;
}A[N] ;
bool operator < ( node a , node b ){ return a.R < b.R ; }
int main()
{
n = read() ;
for(int i = 1 ; i <= n ; i++ ) A[i].L = read() , A[i].R = read() ;
sort( A + 1 , A + n + 1 ) ;
for(int i = 1 ; i <= n ; i++ ){
pre[i] = 0 ;
for(int j = i - 1 ; j >= 1 ; j-- ){
if( A[j].R < A[i].L ){
pre[i] = j ;
break ;
}
}
}
for(int i = 1 ; i <= n ; i++ ){
for(int j = 1 ; j <= i - 1 ; j++ ){
if( A[j].R < A[i].L ){
sum[i][j] = sum[i][j - 1] ;
continue ;
}
if( A[i].L > A[j].L ){
//for(int k = 1 ; k <= j - 1 ; k++ ){ if( A[k].R < A[i].L ) dp[i][j] = ( dp[i][j] + dp[j][k] ) % Mod ; }
dp[i][j] = 1 + sum[j][ pre[i] ] ;
}else{
//for(int k = 1 ; k <= j - 1 ; k++ ) if( A[k].R < A[j].L ) dp[i][j] = ( dp[i][j] + dp[i][k] ) % Mod ;
dp[i][j] = 1 + sum[i][ pre[j] ] ;
}
if( dp[i][j] >= Mod ) dp[i][j] -= Mod ;
sum[i][j] = dp[i][j] + sum[i][j - 1] ;
if( sum[i][j] >= Mod ) sum[i][j] -= Mod ;
}
}
int ans = 0 ;
for(int i = 1 ; i <= n ; i++ ){
ans = ans + sum[i][i - 1] ;
if( ans >= Mod ) ans -= Mod ;
}
printf("%d\n" , ( ans + n ) % Mod ) ;
return 0 ;
}
```

---

## 题目: P5639

**分类：贪心**

**提交时间：2025-03-02 21:42:30**

---
title: "【CSGRound2】守序者的尊严"
layout: "post"
diff: 普及-
pid: P5639
tag: ['模拟', '贪心', '洛谷原创', '洛谷月赛']
---
# 【CSGRound2】守序者的尊严
## 题目背景

由于 Y 校最近进行了对学校食堂的全面改革与对小卖部的全面整治(乱搞)，导致学校小卖部卖的零食被禁售了；学校食堂的炸鸡窗口也消失了；

并且学校的学生处 Q 主任严禁学生点外卖，日夜监察。

都说民以食为天，由于整天挨饿，全校同学处于水深火热之中。
## 题目描述

zhouwc 的朋友（朋友就是自己系列）小 Z 由于饥饿难忍，不得不铤而走险点外卖。

但是学校的 Q 主任为了能够抓住点外卖的学生布置了天罗地网——监控。

但是由于学校给 Q 主任的经费有限，所以这些监控不能持续工作，工作一秒之后便要暂停休息一秒，**即开启一秒后关闭一秒再开启一秒...以此类推**。

还是由于 Q 主任的经费有限，这些监控被排成了一条直线，这条直线便在学生通往学生外卖驻点——二号门（没有门卫）的必经之路上。

因为小 Z 修习了疾跑技能，所以小 Z 通过任意个数关闭的监控的时间均为 
 $1$（即一次行动可以经过若干个未开的监控）。

由于小 Z 想吃外卖又不想受到正在监控室看着监控的 Q 主任的处分，请你告诉他至少要多少时间才能安全到达外卖驻点。
## 输入格式

共 $2$ 行。

第一行一个正整数 $n$，表示在这条路上一共有 $n$ 个监控。

第二行共有 $n$ 个数。表示在第 $0$ 秒是这些监控的开关情况，$0$ 表示监控关闭，$1$ 表示监控开启，并保证第一个监控一定是关闭的。
## 输出格式

共一行，表示小 Z 安全到达外卖驻点所需要的时间。

## 样例

### 样例输入 #1
```
6
0 0 1 1 0 1
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
6
0 0 0 0 0 0
```
### 样例输出 #2
```
1
```
## 提示

#### 数据范围：

对于 $10\%$ 的数据，$1 \leq n \leq 10$

对于 $30\%$ 的数据，$1 \leq n \leq 100$

对于 $50\%$ 的数据，$1 \leq n \leq 10^3$

对于 $70\%$ 的数据，$1 \leq n \leq 10^5$

对于$100\%$的数据，$1 \leq n \leq 10^6$

监控的开关情况均用 $0$ 和 $1$ 来表示。

#### 样例解释一：

小 Z 在第一秒时冲到第二个监控处，用时 $1$ 秒，总用时 $1$ 秒。

第二秒时，监控的开关状况变为了 $1 1 0 0 1 0$。

这时，小 Z 迅速从二号监控处冲到了四号监控处，用时 $1$ 秒，总用时 $2$ 秒。

第三秒时，监控的开关状况变为了 $0 0 1 1 0 1$。

这时，小 Z 迅速从四号监控处冲到了五号监控处，用时 $1$ 秒，总用时 $3$ 秒。

第三秒时，监控的开关状况变为了 $1 1 0 0 1 0$。

这时，小 Z 迅速从五号监控处冲出了监控区域，用时 $1$ 秒，总用时 $4$ 秒。

#### 样例解释二

小Z在第一秒直接冲出了监控区域。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[1000005],sum=-1,ans;
bool flag=0;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
}
for(int i=1;i<=n;i++){
if(a[i]!=sum){
ans+=1;
sum=a[i];
}
}
cout<<ans;
return 0;
}
```

---

## 题目: P5662

**分类：动态规划**

**提交时间：2025-04-01 19:34:16**

---
title: "[CSP-J2019] 纪念品"
layout: "post"
diff: 普及+/提高
pid: P5662
tag: ['动态规划 DP', '2019', '背包 DP', 'CSP-J 入门级']
---
# [CSP-J2019] 纪念品
## 题目描述

小伟突然获得一种超能力，他知道未来 $T$ 天 $N$ 种纪念品每天的价格。某个纪念品的价格是指购买一个该纪念品所需的金币数量，以及卖出一个该纪念品换回的金币数量。

每天，小伟可以进行以下两种交易**无限次**：
1. 任选一个纪念品，若手上有足够金币，以当日价格购买该纪念品；
2. 卖出持有的任意一个纪念品，以当日价格换回金币。

每天卖出纪念品换回的金币可以**立即**用于购买纪念品，当日购买的纪念品也可以**当日卖出**换回金币。当然，一直持有纪念品也是可以的。

$T$ 天之后，小伟的超能力消失。因此他一定会在第 $T$ 天卖出**所有**纪念品换回金币。

小伟现在有 $M$ 枚金币，他想要在超能力消失后拥有尽可能多的金币。 
 
## 输入格式

第一行包含三个正整数 $T, N, M$，相邻两数之间以一个空格分开，分别代表未来天数 $T$，纪念品数量 $N$，小伟现在拥有的金币数量 $M$。

接下来 $T$ 行，每行包含 $N$ 个正整数，相邻两数之间以一个空格分隔。第 $i$ 行的 $N$ 个正整数分别为 $P_{i,1},P_{i,2},\dots,P_{i,N}$，其中 $P_{i,j}$ 表示第 $i$ 天第 $j$ 种纪念品的价格。
## 输出格式

输出仅一行，包含一个正整数，表示小伟在超能力消失后最多能拥有的金币数量。
 
## 样例

### 样例输入 #1
```
6 1 100
50
20
25
20
25
50
```
### 样例输出 #1
```
305
```
### 样例输入 #2
```
3 3 100
10 20 15
15 17 13
15 25 16
```
### 样例输出 #2
```
217
```
## 提示

**样例 1 说明**

最佳策略是：

第二天花光所有 $100$ 枚金币买入 $5$ 个纪念品 $1$；

第三天卖出 $5$ 个纪念品 $1$，获得金币 $125$ 枚；

第四天买入 $6$ 个纪念品 $1$，剩余 $5$ 枚金币；

第六天必须卖出所有纪念品换回 $300$ 枚金币，第四天剩余 $5$ 枚金币，共 $305$ 枚金币。

超能力消失后，小伟最多拥有 $305$ 枚金币。

**样例 2 说明**

最佳策略是：

第一天花光所有金币买入 $10$ 个纪念品 $1$；

第二天卖出全部纪念品 $1$ 得到 $150$ 枚金币并买入 $8$ 个纪念品 $2$ 和 $1$ 个纪念品 $3$，剩余 $1$ 枚金币；

第三天必须卖出所有纪念品换回 $216$ 枚金币，第二天剩余 $1$ 枚金币，共 $217$ 枚金币。

超能力消失后，小伟最多拥有 $217$ 枚金币。


**数据规模与约定**

对于 $10\%$ 的数据，$T = 1$。

对于 $30\%$ 的数据，$T \leq 4, N \leq 4, M \leq 100$，所有价格 $10 \leq P_{i,j} \leq 100$。

另有 $15\%$ 的数据，$T \leq 100, N = 1$。

另有 $15\%$ 的数据，$T = 2, N \leq 100$。

对于 $100\%$ 的数据，$T \leq 100, N \leq 100, M \leq 10^3$，所有价格 $1 \leq P_{i,j} \leq 10^4$，数据保证任意时刻，小伟手上的金币数不可能超过 $10^4$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int t,n,m,p[105][105],dp[10005],ans;
int main(){
cin>>t>>n>>m;
ans=m;
for(int i=1;i<=t;i++){
for(int j=1;j<=n;j++){
cin>>p[i][j];
}
}
for(int i=1;i<=t;i++){
memset(dp,0,sizeof(dp));
dp[ans]=ans;
for(int j=1;j<=n;j++){
for(int k=ans;k>=p[i][j];k--){
dp[k-p[i][j]]=max(dp[k-p[i][j]],dp[k]+(p[i+1][j]-p[i][j]));
}
}
int maxn=-1;
for(int j=0;j<=ans;j++){
maxn=max(maxn,dp[j]);
}
ans=maxn;
}
cout<<ans;
return 0;
}
```

---

## 题目: P5703

**分类：入门-顺序结构**

**提交时间：2023-11-03 15:09:20**

---
title: "【深基2.例5】苹果采购"
layout: "post"
diff: 入门
pid: P5703
tag: []
---
# 【深基2.例5】苹果采购
## 题目描述

现在需要采购一些苹果，每名同学都可以分到固定数量的苹果，并且已经知道了同学的数量，请问需要采购多少个苹果？
## 输入格式

输入两个不超过 $10^9$ 正整数，分别表示每人分到的数量和同学的人数。
## 输出格式

一个整数，表示答案。保证输入和答案都在 int 范围内的非负整数。
## 样例

### 样例输入 #1
```
5 3

```
### 样例输出 #1
```
15

```


### 代码

```cpp
#include<bits/stdc++.h>//万能头文件
using namespace std;
int a,b;//定义变量
int main()//主函数
{
cin>>a>>b;//输入
cout<<a*b<<endl;//输出
return 0;//程序结束，好习惯
}
```

---

## 题目: P5704

**分类：入门-顺序结构**

**提交时间：2023-11-10 14:53:09**

---
title: "【深基2.例6】字母转换"
layout: "post"
diff: 入门
pid: P5704
tag: []
---
# 【深基2.例6】字母转换
## 题目描述

输入一个小写字母，输出其对应的大写字母。例如输入 q[回车] 时，会输出 Q。
## 样例

### 样例输入 #1
```
q
```
### 样例输出 #1
```
Q
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main(){
char c;
cin>>c;
char ans=c-32;
cout<<ans;
return 0;
}
```

---

## 题目: P5705

**分类：入门-顺序结构**

**提交时间：2023-11-10 14:54:24**

---
title: "【深基2.例7】数字反转"
layout: "post"
diff: 入门
pid: P5705
tag: []
---
# 【深基2.例7】数字反转
## 题目描述

输入一个不小于 $100$ 且小于 $1000$，同时包括小数点后一位的一个浮点数，例如 $123.4$ ，要求把这个数字翻转过来，变成 $4.321$ 并输出。
## 输入格式

一行一个浮点数
## 输出格式

一行一个浮点数
## 样例

### 样例输入 #1
```
123.4
```
### 样例输出 #1
```
4.321
```


### 代码

```cpp
#include <cstdio>
using namespace std;
char a, b, c, d;
int main(){
scanf("%c%c%c.%c", &a, &b, &c, &d);
printf("%c.%c%c%c", d, c, b, a);
return 0;
}
```

---

## 题目: P5706

**分类：入门-顺序结构**

**提交时间：2023-12-26 20:53:59**

---
title: "【深基2.例8】再分肥宅水"
layout: "post"
diff: 入门
pid: P5706
tag: []
---
# 【深基2.例8】再分肥宅水
## 题目描述

现在有 $t$ 毫升肥宅快乐水，要均分给 $n$ 名同学。每名同学需要 $2$ 个杯子。现在想知道每名同学可以获得多少毫升饮料（严格精确到小数点后 $3$ 位），以及一共需要多少个杯子。


## 输入格式

输入一个实数 $t$ 和一个正整数 $n$，使用空格隔开。
## 输出格式

输出两行。

第一行输出一个三位小数，表示可以获得多少毫升饮料。第二行输出一个正整数，表示一共需要多少个杯子。
## 样例

### 样例输入 #1
```
500.0 3
```
### 样例输出 #1
```
166.667
6
```
## 提示

对于所有数据，$0\leq t\leq 10000$ 且小数点后不超过 $3$ 位，$1\leq n\leq 1000$。


### 代码

```cpp
#include<iostream>
using namespace std;
int main()
{
double a,c,d;
int b;
cin>>a>>b;
printf("%.3f\n",a/b);
c=(a/b*1.0,b*2);
cout<<c;
return 0;
}
```

---

## 题目: P5708

**分类：入门-顺序结构**

**提交时间：2023-11-03 15:19:05**

---
title: "【深基2.习2】三角形面积"
layout: "post"
diff: 入门
pid: P5708
tag: ['Special Judge']
---
# 【深基2.习2】三角形面积
## 题目描述

一个三角形的三边长分别是 $a$、$b$、$c$，那么它的面积为 $\sqrt{p(p-a)(p-b)(p-c)}$，其中 $p=\frac{1}{2}(a+b+c)$。输入这三个数字，计算三角形的面积，四舍五入精确到 $1$ 位小数。

## 输入格式

第一行输入三个实数 $a,b,c$，以空格隔开。
## 输出格式

输出一个实数，表示三角形面积。精确到小数点后 $1$ 位。
## 样例

### 样例输入 #1
```
3 4 5
```
### 样例输出 #1
```
6.0
```
## 提示

数据保证能构成三角形，$0\leq a,b,c\leq 1000$，每个边长输入时不超过 $2$ 位小数。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double a,b,c,p,ans;
int main()
{
cin>>a>>b>>c;
p=(a+b+c)/2;
ans=sqrt(p*(p-a)*(p-b)*(p-c));
printf("%.1lf",ans);
return 0;
}
```

---

## 题目: P5709

**分类：入门-分支结构**

**提交时间：2023-12-28 19:07:48**

---
title: "【深基2.习6】Apples Prologue / 苹果和虫子"
layout: "post"
diff: 入门
pid: P5709
tag: []
---
# 【深基2.习6】Apples Prologue / 苹果和虫子
## 题目描述

小 B 喜欢吃苹果。她现在有 $m$（$1 \le m \le 100$）个苹果，吃完一个苹果需要花费 $t$（$0 \le t \le 100$）分钟，吃完一个后立刻开始吃下一个。现在时间过去了 $s$（$1 \le s \le 10000$）分钟，请问她还有几个完整的苹果？
## 输入格式

输入三个**非负整数**表示 $m, t, s$。
## 输出格式

输出一个整数表示答案。


## 样例

### 样例输入 #1
```
50 10 200
```
### 样例输出 #1
```
30
```
## 提示

如果你出现了 RE，不如检查一下被零除？


### 代码

```cpp
#include<iostream>
using namespace std;
int m,t,s;
int main()
{
cin>>m>>t>>s;
if(t==0)
{
cout<<0<<endl;
return 0;
}
if(s%t==0)
{
cout<<max(m-s/t,0)<<endl;
}
else
{
cout<<max(m-s/t-1,0)<<endl;
}
return 0;
}
```

---

## 题目: P5710

**分类：入门-分支结构**

**提交时间：2023-12-10 21:57:49**

---
title: "【深基3.例2】数的性质"
layout: "post"
diff: 入门
pid: P5710
tag: []
---
# 【深基3.例2】数的性质
## 题目描述

一些整数可能拥有以下的性质：

- 性质 1：是偶数；
- 性质 2：大于 $4$ 且不大于 $12$。

小 A 喜欢这两个性质同时成立的整数；Uim 喜欢这至少符合其中一种性质的整数；小 B 喜欢刚好有符合其中一个性质的整数；正妹喜欢不符合这两个性质的整数。现在给出一个整数 $x$，请问他们是否喜欢这个整数？
## 输入格式

输入一个整数 $x(0\le x \le 1000)$
## 输出格式

输出这 $4$ 个人是否喜欢这个数字，如果喜欢则输出 `1`，否则输出 `0`，用空格分隔。输出顺序为：小 A、Uim、小 B、正妹。
## 样例

### 样例输入 #1
```
12
```
### 样例输出 #1
```
1 1 0 0
```


### 代码

```cpp
#include<iostream>
using namespace std;
int main() {
int n;
cin >> n;
if (n % 2 == 0 && n >= 4 && n <= 12)
cout << 1 << " ";
else
cout << 0 << " ";
if (n % 2 == 0 || (n >= 4 && n <= 12))
cout << 1 << " ";
else
cout << 0 << " ";
if (n % 2 != 0 && (n >= 4 && n <= 12)||(n % 2 == 0 && (n < 4 || n > 12)))
cout << 1 << " ";
else
cout << 0 << " ";
if (n % 2 != 0 && (n < 4 || n > 12))
cout << 1 << " ";
else
cout << 0 << " ";
return 0;
}
```

---

## 题目: P5711

**分类：入门-分支结构**

**提交时间：2023-12-28 20:42:09**

---
title: "【深基3.例3】闰年判断"
layout: "post"
diff: 入门
pid: P5711
tag: []
---
# 【深基3.例3】闰年判断
## 题目描述

输入一个年份，判断这一年是否是闰年，如果是输出 $1$，否则输出 $0$。

$1582$ 年以来，闰年的定义：

普通闰年：公历年份是 $4$ 的倍数，且不是 $100$ 的倍数的，为闰年（如 $2004$ 年、$2020$ 年等就是闰年）。

世纪闰年：公历年份是整百数的，必须是 $400$ 的倍数才是闰年（如 $1900$ 年不是闰年，$2000$ 年是闰年）。
## 输入格式

输入一个正整数 $n$，表示年份。
## 输出格式

输出一行。如果输入的年份是闰年则输出 $1$，否则输出 $0$。
## 样例

### 样例输入 #1
```
1926
```
### 样例输出 #1
```
0
```
### 样例输入 #2
```
1900
```
### 样例输出 #2
```
0
```
### 样例输入 #3
```
2000
```
### 样例输出 #3
```
1
```
### 样例输入 #4
```
1996
```
### 样例输出 #4
```
1
```
## 提示

数据保证，$1582 \leq n \leq 2020$ 且年份为自然数。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int main()
{
cin>>n;
cout<<((n%4==0&&n%100!=0)||(n%400==0))?1:0;
return 0;
}
```

---

## 题目: P5712

**分类：入门-分支结构**

**提交时间：2023-12-08 21:35:15**

---
title: "【深基3.例4】Apples"
layout: "post"
diff: 入门
pid: P5712
tag: []
---
# 【深基3.例4】Apples
## 题目描述

小 B 喜欢吃苹果。她今天吃掉了 $x$ 个苹果。英语课上学到了 apple 这个词语，想用它来造句。如果她吃了 1 个苹果，就输出 `Today, I ate 1 apple.`；如果她没有吃，那么就把 1 换成 0；如果她吃了不止一个苹果，别忘了 `apple` 这个单词后面要加上代表复数的 `s`。你能帮她完成这个句子吗？
## 输入格式

输入一行一个自然数 $x$，表示吃掉的苹果数。
## 输出格式

根据题目要求输出。
## 样例

### 样例输入 #1
```
1
```
### 样例输出 #1
```
Today, I ate 1 apple.
```
### 样例输入 #2
```
3
```
### 样例输出 #2
```
Today, I ate 3 apples.
```
## 提示

对于所有数据，$0\le x \le 100$。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int x;
cin >> x;
cout<<"Today, I ate "<<x<<" apple";
if(x>1)
{
cout<<"s";
}
cout<<".";
return 0;
}
```

---

## 题目: P5713

**分类：入门-分支结构**

**提交时间：2023-12-05 20:43:55**

---
title: "【深基3.例5】洛谷团队系统"
layout: "post"
diff: 入门
pid: P5713
tag: []
---
# 【深基3.例5】洛谷团队系统
## 题目描述

在洛谷上使用团队系统非常方便的添加自己的题目。如果在自己的电脑上配置题目和测试数据，每题需要花费时间 $5$ 分钟；而在洛谷团队中上传私有题目，每题只需要花费 $3$ 分钟，但是上传题目之前还需要一次性花费 $11$ 分钟创建与配置团队。现在要配置 $n$ 道题目，如果本地配置花费的总时间短，请输出 `Local`，否则输出 `Luogu`。
## 输入格式

输入一个正整数 $n$，表示需要配置的题目量。
## 输出格式

输出一行，一个字符串。如果本地配置花费的总时间短，请输出 `Local`，否则输出 `Luogu`。
## 样例

### 样例输入 #1
```
2
```
### 样例输出 #1
```
Local
```
### 样例输入 #2
```
50
```
### 样例输出 #2
```
Luogu
```
## 提示

数据保证 $1 \leq n\leq 100$。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int n;
cin>>n;
if (n*5<n*3+11)
{
cout<<"Local";
}
else
{
cout<<"Luogu";
}
return 0;
}
```

---

## 题目: P5714

**分类：入门-分支结构**

**提交时间：2023-12-08 22:13:32**

---
title: "【深基3.例7】肥胖问题"
layout: "post"
diff: 入门
pid: P5714
tag: []
---
# 【深基3.例7】肥胖问题
## 题目描述

BMI 指数是国际上常用的衡量人体胖瘦程度的一个标准，其算法是 $\dfrac{m}{h^2}$，其中 $m$ 是指体重（千克），$h$ 是指身高（米）。不同体型范围与判定结果如下：

- 小于 $18.5$：体重过轻，输出 `Underweight`；
- 大于等于 $18.5$ 且小于 $24$：正常体重，输出 `Normal`；
- 大于等于 $24$：肥胖，不仅要输出 BMI 值（使用 `cout` 的默认精度），然后换行，还要输出 `Overweight`；

现在给出体重和身高数据，需要根据 BMI 指数判断体型状态并输出对应的判断。

对于非 C++ 语言，在输出时，请四舍五入保留六位**有效数字**输出，如果小数部分存在后缀 $0$，不要输出后缀 $0$。

请注意，保留六位**有效数字**不是保留六位小数。例如 $123.4567$ 应该输出为 $123.457$，$5432.10$ 应该输出为 $5432.1$。
## 输入格式

共一行。

第一行，共 $2$ 个浮点数，$m, h$，分别表示体重（单位为 kg），身高（单位为 m）。
## 输出格式

输出一行一个字符串，表示根据 BMI 的对应判断。特别地，对于 `Overweight` 情况的特别处理请参照题目所述。
## 样例

### 样例输入 #1
```
70 1.72
```
### 样例输出 #1
```
Normal
```
### 样例输入 #2
```
100 1.68
```
### 样例输出 #2
```
35.4308
Overweight
```
## 提示

对于所有数据，$40\le m \le 120$，$1.4 \le h \le 2.0$。$m$ 和 $h$ 的小数点后不超过三位。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
float m, h, x;
cin >> m >> h;
x = m / h / h;
if (x < 18.5)
{
cout << "Underweight";
}
if (x >= 18.5 && x < 24)
{
cout << "Normal";
}
if (x > 24)
{
cout << x << endl;
cout << "Overweight";
}
return 0;
}
```

---

## 题目: P5715

**分类：入门-分支结构**

**提交时间：2023-12-10 22:04:26**

---
title: "【深基3.例8】三位数排序"
layout: "post"
diff: 入门
pid: P5715
tag: []
---
# 【深基3.例8】三位数排序
## 题目描述

给出三个整数 $a,b,c(0\le a,b,c \le 100)$，要求把这三位整数从小到大排序。
## 输入格式

输入三个整数 $a,b,c$，以空格隔开。
## 输出格式

输出一行，三个整数，表示从小到大排序后的结果。
## 样例

### 样例输入 #1
```
1 14 5
```
### 样例输出 #1
```
1 5 14
```
### 样例输入 #2
```
2 2 2
```
### 样例输出 #2
```
2 2 2
```


### 代码

```cpp
#include<iostream>
using namespace std;
int main() {
int a,b,c;
cin>>a>>b>>c;
if (a > c)
{
swap(a, c);
}
if (a > b)
{
swap(a, b);
}
if (b > c)
{
swap(b, c);
}
cout<<a<<" "<<b<<" "<<c;
return 0;
}
```

---

## 题目: P5716

**分类：入门-分支结构**

**提交时间：2023-12-16 20:10:15**

---
title: "【深基3.例9】月份天数"
layout: "post"
diff: 入门
pid: P5716
tag: []
---
# 【深基3.例9】月份天数
## 题目描述

输入年份和月份，输出这一年的这一月有多少天。需要考虑闰年。
## 输入格式

输入两个正整数，分别表示年份 $y$ 和月数 $m$，以空格隔开。
## 输出格式

输出一行一个正整数，表示这个月有多少天。
## 样例

### 样例输入 #1
```
1926 8
```
### 样例输出 #1
```
31
```
### 样例输入 #2
```
2000 2
```
### 样例输出 #2
```
29
```
## 提示

数据保证 $1583 \leq y \leq 2020$，$1 \leq m \leq 12$。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int n,m;
cin>>n>>m;
if (m==1 || m==3 || m==5 || m==7 || m==8 || m==10 || m==12)
{
cout<<31;
return 0;
}
if (m==4 || m==6 || m==9 || m==11)
{
cout<<30;
return 0;
}
if ((n%400==0 || (n%4==0 && n%100!=0)) && m==2)
{
cout<<29;
}
else
{
cout<<28;
return 0;
}
}
```

---

## 题目: P5717

**分类：入门-分支结构**

**提交时间：2023-12-28 20:33:32**

---
title: "【深基3.习8】三角形分类"
layout: "post"
diff: 普及-
pid: P5717
tag: []
---
# 【深基3.习8】三角形分类
## 题目描述

给出三条线段 $a,b,c$ 的长度，均是不大于 $10000$ 的正整数。打算把这三条线段拼成一个三角形，它可以是什么三角形呢？

- 如果三条线段不能组成一个三角形，输出`Not triangle`；
- 如果是直角三角形，输出`Right triangle`；
- 如果是锐角三角形，输出`Acute triangle`；
- 如果是钝角三角形，输出`Obtuse triangle`；
- 如果是等腰三角形，输出`Isosceles triangle`；
- 如果是等边三角形，输出`Equilateral triangle`。

如果这个三角形符合以上多个条件，请按以上顺序分别输出，并用换行符隔开。
## 输入格式

输入 3 个整数 $a$、$b$ 和 $c$。
## 输出格式

输出若干行判定字符串。
## 样例

### 样例输入 #1
```
3 3 3
```
### 样例输出 #1
```
Acute triangle
Isosceles triangle
Equilateral triangle
```
### 样例输入 #2
```
3 4 5

```
### 样例输出 #2
```
Right triangle
```
### 样例输入 #3
```
6 10 6

```
### 样例输出 #3
```
Obtuse triangle
Isosceles triangle
```
### 样例输入 #4
```
1 14 5

```
### 样例输出 #4
```
Not triangle
```
## 提示

当两短边的平方和大于一长边的平方，说明是锐角三角形。

当两短边的平方和等于一长边的平方，说明是直角三角形。

当两短边的平方和小于一长边的平方，说明是钝角三角形。


### 代码

```cpp
#include <iostream>
#include<algorithm>
using namespace std;
int main()
{
int a, b, c, d[3], n = 0;
for (int i = 0; i < 3; i++)
{
cin >> d[i];
}
sort(d, d + 3);
a = d[0];
b = d[1];
c = d[2];
for (int i = 1; i <= 3; i++)
{
if (i == 1 && a + b <= c)
{
n += 1;
}
if (i == 2 && a + c <= b)
{
n += 1;
}
if (i == 3 && c + b <= a)
{
n += 1;
}
}
if (n != 0)
{
cout << "Not triangle" << endl;
}
else
{
if (a * a + b * b == c * c)
{
cout << "Right triangle" << endl;
}
if (a * a + b * b > c * c)
{
cout << "Acute triangle" << endl;
}
if (a * a + b * b < c * c)
{
cout << "Obtuse triangle" << endl;
}
if (a == b || b == c || a == c)
{
cout << "Isosceles triangle" << endl;
}
if (a == b && b == c)
{
cout << "Equilateral triangle" << endl;
}
}
return 0;
}
```

---

## 题目: P5718

**分类：入门-循环结构**

**提交时间：2023-12-01 15:55:28**

---
title: "【深基4.例2】找最小值"
layout: "post"
diff: 入门
pid: P5718
tag: []
---
# 【深基4.例2】找最小值
## 题目描述

给出 $n$ 和 $n$ 个整数 $a_i$，求这 $n$ 个整数中最小值是什么。
## 输入格式

第一行输入一个正整数 $n$，表示数字个数。

第二行输入 $n$ 个非负整数，表示 $a_1,a_2 \dots a_n$，以空格隔开。
## 输出格式

输出一个非负整数，表示这 $n$ 个非负整数中的最小值。
## 样例

### 样例输入 #1
```
5
5 7 4 2 6
```
### 样例输出 #1
```
2
```
## 提示

数据保证，$n\le100$ 且 $0\le a_i \le 1000$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int a[1000000];
int main()
{
int n;
cin>>n;
for(int i=1;i<=n;i++)cin>>a[i];
sort(a+1,a+n+1);
cout<<a[1];
return 0;
}
```

---

## 题目: P5719

**分类：入门-循环结构**

**提交时间：2023-12-08 21:56:17**

---
title: "【深基4.例3】分类平均"
layout: "post"
diff: 入门
pid: P5719
tag: []
---
# 【深基4.例3】分类平均
## 题目描述

给定 $n$ 和 $k$，将从 1 到 $n$ 之间的所有正整数可以分为两类：A 类数可以被 $k$ 整除（也就是说是 $k$ 的倍数），而 B 类数不能。请输出这两类数的平均数，精确到小数点后 $1$ 位，用空格隔开。

数据保证两类数的个数都不会是 $0$。
## 输入格式

输入两个正整数 $n$ 与 $k$。

## 输出格式

输出一行，两个实数，分别表示 A 类数与 B 类数的平均数。精确到小数点后一位。
## 样例

### 样例输入 #1
```
100 16
```
### 样例输出 #1
```
56.0 50.1
```
## 提示

数据保证，$1 \leq n\leq 10000$，$1 \leq k \leq 100$。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int n,k;
double sum=0,sum1=0,a=0,b=0;
cin >> n>>k;
for (int i=1;i<=n;i++)
{
if(i%k==0)
{
a+=i;
sum+=1;
}
else
{
b+=i;
sum1+=1;
}
}
printf("%.1f",a/sum);
cout<<" ";
printf("%.1f",b/sum1);
return 0;
}
```

---

## 题目: P5720

**分类：入门-循环结构**

**提交时间：2023-12-01 16:00:10**

---
title: "【深基4.例4】一尺之棰"
layout: "post"
diff: 入门
pid: P5720
tag: []
---
# 【深基4.例4】一尺之棰
## 题目描述

《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为 $a$ 的木棍，从第二天开始，每天都要将这根木棍锯掉一半（每次除 $2$，向下取整）。第几天的时候木棍的长度会变为 $1$？
## 输入格式

输入一个正整数 $a$，表示木棍长度。
## 输出格式

输出一个正整数，表示要第几天的时候木棍长度会变为 $1$。
## 样例

### 样例输入 #1
```
100
```
### 样例输出 #1
```
7
```
## 提示

数据保证，$1 \le a\le 10^9$。


### 代码

```cpp
#include<iostream>
using namespace std;
int main(){
long long a;
int i;
cin>>a;
for(i=2;a!=1;i++)
{
a/=2;
}
cout<<i-1;
return 0;
}
```

---

## 题目: P5721

**分类：入门-循环结构**

**提交时间：2024-01-07 08:16:37**

---
title: "【深基4.例6】数字直角三角形"
layout: "post"
diff: 入门
pid: P5721
tag: []
---
# 【深基4.例6】数字直角三角形
## 题目描述

给出 $n$，请输出一个直角边长度是 $n$ 的数字直角三角形。所有数字都是 $2$ 位组成的，如果没有 $2$ 位则加上前导 $0$。
## 输入格式

输入一个正整数 $n$。
## 输出格式

输出如题目要求的数字直角三角形。
## 样例

### 样例输入 #1
```
5
```
### 样例输出 #1
```
0102030405
06070809
101112
1314
15
```
## 提示

数据保证，$1\le n\le13$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int n, x = 1;
cin >> n;
for (int i = 1; i <= n; i++)
{
for (int j = (n + 1 - i); j > 0; j--)
{
if (x / 10 == 0)
{
cout << 0 << x;
}
else
{
cout << x;
}
x += 1;
}
cout << endl;
}
return 0;
}
```

---

## 题目: P5722

**分类：入门-循环结构**

**提交时间：2023-11-28 20:19:27**

---
title: "【深基4.例11】数列求和"
layout: "post"
diff: 入门
pid: P5722
tag: []
---
# 【深基4.例11】数列求和
## 题目描述

计算 $1+2+3+\cdots+(n-1)+n$ 的值，其中正整数 $n$ 不大于 100。由于你没有高斯聪明，所以你不被允许使用等差数列求和公式直接求出答案。
## 输入格式

输入一个正整数 $n$。
## 输出格式

输出一个正整数，表示最后求和的答案。
## 样例

### 样例输入 #1
```
100
```
### 样例输出 #1
```
5050
```
## 提示

数据保证，$1 \leq n \leq 100$。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int a,sum=0;
cin>>a;
for (int i=0;i<=a;i++)
{
sum+=i;
}
cout<<sum;
return 0;
}
```

---

## 题目: P5723

**分类：入门-循环结构**

**提交时间：2023-12-26 19:29:10**

---
title: "【深基4.例13】质数口袋"
layout: "post"
diff: 普及-
pid: P5723
tag: ['素数判断,质数,筛法']
---
# 【深基4.例13】质数口袋
## 题目描述

小 A 有一个质数口袋，里面可以装各个质数。他从 $2$ 开始，依次判断各个自然数是不是质数，如果是质数就会把这个数字装入口袋。

口袋的负载量就是口袋里的所有数字之和。

但是口袋的承重量有限，装的质数的和不能超过 $L$。给出 $L$，请问口袋里能装下几个质数？将这些质数从小往大输出，然后输出最多能装下的质数的个数，数字之间用换行隔开。
## 输入格式

一行一个正整数 $L$。
## 输出格式

将这些质数从小往大输出，然后输出最多能装下的质数个数。
## 样例

### 样例输入 #1
```
100
```
### 样例输出 #1
```
2
3
5
7
11
13
17
19
23
9
```
### 样例输入 #2
```
5
```
### 样例输出 #2
```
2
3
2
```
### 样例输入 #3
```
11
```
### 样例输出 #3
```
2
3
5
3
```
## 提示

数据保证，$1 \le L \le {10}^5$。


### 代码

```cpp
#include <cstdio>
#include <algorithm>
using namespace std;
bool prime[100007];
int l;
void ai() {
for(int i = 2; i <= 100000; ++i)	prime[i] = 1;
for(int i = 2; i <= 100000; ++i)
if(prime[i])
for(int j = i * 2; j <= 100000; j += i)
prime[j] = 0;
}
int main() {
scanf("%d", &l);
int p = l, sum = 0;
ai();
for(int i = 1; i <= p; ++i) {
if(prime[i]) {
printf("%d\n", i);
p -= i;
sum++;
}
if(p <= 0)	break;
}
printf("%d", sum);
return 0;
}
```

---

## 题目: P5724

**分类：入门-循环结构**

**提交时间：2023-12-26 19:33:26**

---
title: "【深基4.习5】求极差 / 最大跨度值"
layout: "post"
diff: 入门
pid: P5724
tag: []
---
# 【深基4.习5】求极差 / 最大跨度值
## 题目描述

给出 $n$ 和 $n$ 个整数 $a_i$，求这 $n$ 个整数中的极差是什么。极差的意思是一组数中的最大值减去最小值的差。
## 输入格式

第一行输入一个正整数 $n$，表示整数个数。

第二行输入 $n$ 个整数 $a_1,a_2 \dots a_n$，以空格隔开。
## 输出格式

输出一个整数，表示这 $n$ 个整数的极差。
## 样例

### 样例输入 #1
```
6
4 1 5 1 4 1
```
### 样例输出 #1
```
4
```
## 提示

数据保证，$1 \leq n\leq 100$，$0\le a_i \le 1000$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int n, max = 0, min = 1001, a[1005];
cin >> n;
for (int i = 1; i <= n; i++)
{
cin >> a[i];
}
for (int i = 1; i <= n; i++)
{
if (a[i] > max)
{
max = a[i];
}
}
for (int i = 1; i <= n; i++)
{
if (a[i] < min)
{
min = a[i];
}
}
cout<<max-min;
return 0;
}
```

---

## 题目: P5725

**分类：入门-循环结构**

**提交时间：2023-12-26 20:04:02**

---
title: "【深基4.习8】求三角形"
layout: "post"
diff: 入门
pid: P5725
tag: []
---
# 【深基4.习8】求三角形
## 题目描述

模仿例题，打印出不同方向的正方形，然后打印三角形矩阵。中间有个空行。
## 输入格式

输入矩阵的规模，不超过 $9$。
## 输出格式

输出矩形和正方形
## 样例

### 样例输入 #1
```
4
```
### 样例输出 #1
```
01020304
05060708
09101112
13141516

      01
    0203
  040506
07080910
```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int n, x = 1;
cin >> n;
for (int i = 1; i <= n; i++)
{
for (int j = 1; j <= n; j++)
{
if (x / 10 == 0)
{
cout << 0 << x;
}
else
{
cout << x;
}
x += 1;
}
cout << endl;
}
cout << endl;
x = 1;
for (int i = 1; i <= n; i++)
{
for (int k = 1; k <= (n - i); k++)
{
cout << "  ";
}
for (int j = 1; j <= i; j++)
{
if (x / 10 == 0)
{
cout << 0 << x;
}
else
{
cout << x;
}
x += 1;
}
cout << endl;
}
return 0;
}
```

---

## 题目: P5726

**分类：入门-循环结构**

**提交时间：2023-12-26 19:27:04**

---
title: "【深基4.习9】打分"
layout: "post"
diff: 普及-
pid: P5726
tag: []
---
# 【深基4.习9】打分
## 题目描述

现在有 $n(n \le 1000)$ 位评委给选手打分，分值从 $0$ 到 $10$。需要去掉一个最高分，去掉一个最低分（如果有多个最高或者最低分，也只需要去掉一个），剩下的评分的平均数就是这位选手的得分。现在输入评委人数和他们的打分，请输出选手的最后得分，精确到 $2$ 位小数。 
## 输入格式

第一行输入一个正整数 $n$，表示有 $n$ 个评委。

第二行输入 $n$ 个正整数，第 $i$ 个正整数表示第 $i$ 个评委打出的分值。
## 输出格式

输出一行一个两位小数，表示选手的最后得分。
## 样例

### 样例输入 #1
```
5
9 5 6 8 9
```
### 样例输出 #1
```
7.67
```
## 提示

数据保证，$3 \leq n \leq 1000$，每个评委打出的分值为为 $0$ 到 $10$（含 $0$ 与 $10$）之间的整数。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int n, max = 0, min = 1001, a[1005], y=0, z=0;
double x=0;
cin >> n;
for (int i = 1; i <= n; i++)
{
cin >> a[i];
}
for (int i = 1; i <= n; i++)
{
if (a[i] > max)
{
max = a[i];
}
}
for (int i = 1; i <= n; i++)
{
if (a[i] < min)
{
min = a[i];
}
}
for (int i = 1; i <= n; i++)
{
if (a[i] == max)
{
if (y != 1)
{
a[i] = 0;
y=1;
}
}
else if (a[i] == min)
{
if(z!=1)
{
a[i] = 0;
z=1;
}
}
}
for (int i = 1; i <= n; i++)
{
x += a[i];
}
x = x / (n - 2);
printf("%.2f\n", x);
return 0;
}
```

---

## 题目: P5727

**分类：入门-数组**

**提交时间：2023-12-24 21:24:07**

---
title: "【深基5.例3】冰雹猜想"
layout: "post"
diff: 入门
pid: P5727
tag: []
---
# 【深基5.例3】冰雹猜想
## 题目描述

给出一个正整数 $n$，然后对这个数字一直进行下面的操作：如果这个数字是奇数，那么将其乘 $3$ 再加 $1$，否则除以 $2$。经过若干次循环后，最终都会回到 $1$。经过验证很大的数字（$7\times10^{11}$）都可以按照这样的方式比变成 $1$，所以被称为“冰雹猜想”。例如当 $n$ 是 $20$，变化的过程是 $20\to 10\to 5\to 16\to 8\to 4\to 2\to 1$。

根据给定的数字，验证这个猜想，并从最后的 $1$ 开始，倒序输出整个变化序列。
## 输入格式

输入一个正整数 $n$。
## 输出格式

输出若干个由空格隔开的正整数，表示从最后的 $1$ 开始倒序的变化数列。
## 样例

### 样例输入 #1
```
20
```
### 样例输出 #1
```
1 2 4 8 16 5 10 20
```
## 提示

数据保证，$1 \le n\le 100$。


### 代码

```cpp
#include <iostream>
using namespace std;
int main()
{
int n, x, i = 0, a[105];
cin >> n;
x = n;
while (n != 1)
{
if (n % 2 == 1)
{
n = n * 3 + 1;
a[i] = n;
}
else
{
n = n / 2;
a[i] = n;
}
i += 1;
}
for (int j = i - 1; j >= 0; j--)
{
cout << a[j] << " ";
}
cout << x;
return 0;
}
```

---

## 题目: P5728

**分类：入门-数组**

**提交时间：2024-01-03 21:08:56**

---
title: "【深基5.例5】旗鼓相当的对手"
layout: "post"
diff: 入门
pid: P5728
tag: []
---
# 【深基5.例5】旗鼓相当的对手
## 题目描述

现有 $N$ 名同学参加了期末考试，并且获得了每名同学的信息：语文、数学、英语成绩（均为不超过 $150$ 的自然数）。如果某对学生 $\lang i,j\rang$ 的每一科成绩的分差都不大于 $5$，且总分分差不大于 $10$，那么这对学生就是“旗鼓相当的对手”。现在想知道这些同学中，有几对“旗鼓相当的对手”？同样一个人可能会和其他好几名同学结对。
## 输入格式

第一行一个正整数 $N$。

接下来 $N$ 行，每行三个整数，其中第 $i$ 行表示第 $i$ 名同学的语文、数学、英语成绩。最先读入的同学编号为 $1$。
## 输出格式

输出一个整数，表示“旗鼓相当的对手”的对数。
## 样例

### 样例输入 #1
```
3
90 90 90
85 95 90
80 100 91
```
### 样例输出 #1
```
2
```
## 提示

数据保证，$2 \le N\le 1000$ 且每科成绩为不超过 $150$ 的自然数。


### 代码

```cpp
#include<iostream>
using namespace std;
int main()
{
int n, a[1005], b[1005], c[1005], sum = 0;
cin >> n;
for (int i = 1; i <= n; i++)
{
cin >> a[i];
cin >> b[i];
cin >> c[i];
}
for (int i = 1; i <= n; i++)
{
for (int j = 1; j < i; j++)
{
if (abs(a[i]+b[i]+c[i]-(a[j]+b[j]+c[j]))<=10&&abs(a[i]-a[j])<=5&&abs(b[i]-b[j])<=5&&abs(c[i]-c[j])<=5)
{
sum+=1;
}
}
}
cout<<sum;
return 0;
}
```

---

## 题目: P5730

**分类：入门-数组**

**提交时间：2024-03-26 19:21:09**

---
title: "【深基5.例10】显示屏"
layout: "post"
diff: 普及-
pid: P5730
tag: []
---
# 【深基5.例10】显示屏
## 题目描述

液晶屏上，每个阿拉伯数字都是可以显示成 $3\times5$ 的点阵的（其中 `X` 表示亮点，`.` 表示暗点）。现在给出数字位数（不超过 $100$）和一串数字，要求输出这些数字在显示屏上的效果。数字的显示方式如同样例输出，注意每个数字之间都有一列间隔。
## 输入格式

第一行输入一个正整数 $n$，表示数字的位数。

第二行输入一个长度为 $n$ 的自然数。
## 输出格式

输出五行，表示显示屏上的数字。
## 样例

### 样例输入 #1
```
10
0123456789

```
### 样例输出 #1
```
XXX...X.XXX.XXX.X.X.XXX.XXX.XXX.XXX.XXX
X.X...X...X...X.X.X.X...X.....X.X.X.X.X
X.X...X.XXX.XXX.XXX.XXX.XXX...X.XXX.XXX
X.X...X.X.....X...X...X.X.X...X.X.X...X
XXX...X.XXX.XXX...X.XXX.XXX...X.XXX.XXX

```
## 提示

数据保证，$1 \leq n \leq 100$。


### 代码

```cpp
#include<iostream>
#include<cstdio>
#include<algorithm>
#include<cmath>
#include<cstring>
using namespace std;
char W[10][5][3]=//W[i][j][k]表示第i个数字的第j行的第k列，（手打累死了）
{
{//0
'X','X','X',
'X','.','X',
'X','.','X',
'X','.','X',
'X','X','X',
},
{//1
'.','.','X',
'.','.','X',
'.','.','X',
'.','.','X',
'.','.','X',
},
{//2
'X','X','X',
'.','.','X',
'X','X','X',
'X','.','.',
'X','X','X',
},
{//3
'X','X','X',
'.','.','X',
'X','X','X',
'.','.','X',
'X','X','X',
},
{//4
'X','.','X',
'X','.','X',
'X','X','X',
'.','.','X',
'.','.','X',
},
{//5
'X','X','X',
'X','.','.',
'X','X','X',
'.','.','X',
'X','X','X',
},
{//6
'X','X','X',
'X','.','.',
'X','X','X',
'X','.','X',
'X','X','X',
},
{//7
'X','X','X',
'.','.','X',
'.','.','X',
'.','.','X',
'.','.','X',
},
{//8
'X','X','X',
'X','.','X',
'X','X','X',
'X','.','X',
'X','X','X',
},
{//9
'X','X','X',
'X','.','X',
'X','X','X',
'.','.','X',
'X','X','X',
}
};
int n;
char s[110];
int main(){
cin>>n;//输入n
for(int i=0;i<n;i++){
cin>>s[i];//输入要打印的字符
}
for(int i=0;i<5;i++){//枚举每一行
for(int j=0;j<n;j++){//枚举每一个数字
for(int k=0;k<3;k++){//枚举每个数字的列
cout<<W[s[j]-'0'][i][k];//输出，因为s[j]为字符，所以要减去'0'
}
if(j!=n-1) cout<<'.';//如果最后一列，就不需要打印'.'
}
cout<<endl;//换行
}
return 0;
}
```

---

## 题目: P5731

**分类：入门-数组**

**提交时间：2024-03-24 21:21:39**

---
title: "【深基5.习6】蛇形方阵"
layout: "post"
diff: 入门
pid: P5731
tag: []
---
# 【深基5.习6】蛇形方阵
## 题目描述

给出一个不大于 $9$ 的正整数 $n$，输出 $n\times n$ 
的蛇形方阵。

从左上角填上 $1$ 开始，顺时针方向依次填入数字，如同样例所示。注意每个数字有都会占用 $3$ 个字符，前面使用空格补齐。
## 输入格式

输入一个正整数 $n$，含义如题所述。
## 输出格式

输出符合题目要求的蛇形矩阵。
## 样例

### 样例输入 #1
```
4
```
### 样例输出 #1
```
  1  2  3  4
 12 13 14  5
 11 16 15  6
 10  9  8  7
```
## 提示

数据保证，$1 \leq n \leq 9$。


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int n;
int main () {
cin >> n;
if(n == 1)
cout << "  1\n";
if(n == 2)
cout <<"  1  2\n  4  3\n";
if(n == 3) {
cout << "  1  2  3\n";
cout << "  8  9  4\n";
cout << "  7  6  5\n";
}
if(n == 4) {
cout << "  1  2  3  4\n";
cout << " 12 13 14  5\n";
cout << " 11 15 16  6\n";
cout << " 10  9  8  7\n";
}
if(n == 5) {
cout << "  1  2  3  4  5\n";
cout << " 16 17 18 19  6\n";
cout << " 15 24 25 20  7\n";
cout << " 14 23 22 21  8\n";
cout << " 13 12 11 10  9\n";
}
if(n == 6) {
cout << "  1  2  3  4  5  6\n";
cout << " 20 21 22 23 24  7\n";
cout << " 19 32 33 34 25  8\n" ;
cout << " 18 31 36 35 26  9\n";
cout << " 17 30 29 28 27 10\n";
cout << " 16 15 14 13 12 11\n";
}
if(n == 7) {
cout << "  1  2  3  4  5  6  7\n";
cout << " 24 25 26 27 28 29  8\n";
cout << " 23 40 41 42 43 30  9\n";
cout << " 22 39 48 49 44 31 10\n";
cout << " 21 38 47 46 45 32 11\n";
cout << " 20 37 36 35 34 33 12\n";
cout << " 19 18 17 16 15 14 13\n";
}
if(n == 8) {
cout << "  1  2  3  4  5  6  7  8\n";
cout << " 28 29 30 31 32 33 34  9\n";
cout << " 27 48 49 50 51 52 35 10\n";
cout << " 26 47 60 61 62 53 36 11\n";
cout << " 25 46 59 64 63 54 37 12\n";
cout << " 24 45 58 57 56 55 38 13\n";
cout << " 23 44 43 42 41 40 39 14\n";
cout << " 22 21 20 19 18 17 16 15\n";
}
if(n == 9) {
cout << "  1  2  3  4  5  6  7  8  9\n";
cout << " 32 33 34 35 36 37 38 39 10\n";
cout << " 31 56 57 58 59 60 61 40 11\n";
cout << " 30 55 72 73 74 75 62 41 12\n";
cout << " 29 54 71 80 81 76 63 42 13\n";
cout << " 28 53 70 79 78 77 64 43 14\n";
cout << " 27 52 69 68 67 66 65 44 15\n";
cout << " 26 51 50 49 48 47 46 45 16\n";
cout << " 25 24 23 22 21 20 19 18 17\n";
}
return 0;
}
```

---

## 题目: P5732

**分类：入门-数组**

**提交时间：2024-03-24 21:18:33**

---
title: "【深基5.习7】杨辉三角"
layout: "post"
diff: 入门
pid: P5732
tag: []
---
# 【深基5.习7】杨辉三角
## 题目描述

给出 $n(1\le n\le20)$，输出杨辉三角的前 $n$ 行。

如果你不知道什么是杨辉三角，可以观察样例找找规律。
## 样例

### 样例输入 #1
```
6
```
### 样例输出 #1
```
1
1 1
1 2 1
1 3 3 1
1 4 6 4 1
1 5 10 10 5 1

```


### 代码

```cpp
#include <bits/stdc++.h>
using namespace std;
int main()
{
int a[30][30],n;
cin>>n;
a[1][1]=1;
a[2][1]=1;
a[2][2]=1;
for(int i=3;i<=n;i++)
{
for(int j=1;j<=i;j++)
{
if(j==1||i==j)
{
a[i][j]=1;
}
else
{
a[i][j]=a[i-1][j-1]+a[i-1][j];
}
}
}
for(int i=1;i<=n;i++)
{
for(int j=1;j<=i;j++)
{
cout<<a[i][j]<<" ";
}
cout<<endl;
}
return 0;
}
```

---

## 题目: P5733

**分类：入门-字符串**

**提交时间：2024-02-01 12:46:07**

---
title: "【深基6.例1】自动修正"
layout: "post"
diff: 入门
pid: P5733
tag: []
---
# 【深基6.例1】自动修正
## 题目描述

大家都知道一些办公软件有自动将字母转换为大写的功能。输入一个长度不超过 $100$ 且不包括空格的字符串。要求将该字符串中的所有小写字母变成大写字母并输出。
## 输入格式

输入一行，一个字符串。
## 输出格式

输出一个字符串，即将原字符串中的所有小写字母转化为大写字母。
## 样例

### 样例输入 #1
```
Luogu4!
```
### 样例输出 #1
```
LUOGU4!
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int main()
{
char s;
while(1)
{
s=getchar();
if(s==EOF)
{
break;
}
if('a'<= s&&s<='z')
{
s+='A'-'a';
}
putchar(s);
}
return 0;
}
```

---

## 题目: P5735

**分类：入门-函数结构体**

**提交时间：2024-09-13 15:56:18**

---
title: "【深基7.例1】距离函数"
layout: "post"
diff: 入门
pid: P5735
tag: []
---
# 【深基7.例1】距离函数
## 题目描述

给出平面坐标上不在一条直线上三个点坐标 $(x_1,y_1),(x_2,y_2),(x_3,y_3)$，坐标值是实数，且绝对值不超过 100.00，求围成的三角形周长。保留两位小数。

对于平面上的两个点 $(x_1,y_1),(x_2,y_2)$，则这两个点之间的距离 $dis=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$
## 输入格式

输入三行，第 $i$ 行表示坐标 $(x_i,y_i)$，以一个空格隔开。
## 输出格式

输出一个两位小数，表示由这三个坐标围成的三角形的周长。
## 样例

### 样例输入 #1
```
0 0
0 3
4 0
```
### 样例输出 #1
```
12.00
```
## 提示

数据保证，坐标均为实数且绝对值不超过 $100$，小数点后最多仅有 $3$ 位。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
double x[5],y[5];
double dist(double a,double b,double c,double d){
return sqrt((a-b)*(a-b)+(c-d)*(c-d));
}
int main(){
double dis=0;
for(int i=1;i<=3;i++){
cin>>x[i]>>y[i];
}
dis +=dist(x[1],x[2],y[1],y[2]);
dis +=dist(x[1],x[3],y[1],y[3]);
dis +=dist(x[3],x[2],y[3],y[2]);
printf("%.2lf",dis);
return 0;
}
```

---

## 题目: P5736

**分类：入门-函数结构体**

**提交时间：2024-09-13 16:21:50**

---
title: "【深基7.例2】质数筛"
layout: "post"
diff: 普及-
pid: P5736
tag: []
---
# 【深基7.例2】质数筛
## 题目描述

输入 $n$ 个不大于 $10^5$ 的正整数。要求全部储存在数组中，去除掉不是质数的数字，依次输出剩余的质数。
## 输入格式

第一行输入一个正整数 $n$，表示整数个数。

第二行输入 $n$ 个正整数 $a_i$，以空格隔开。
## 输出格式

输出一行，依次输出 $a_i$ 中剩余的质数，以空格隔开。
## 样例

### 样例输入 #1
```
5
3 4 5 6 7
```
### 样例输出 #1
```
3 5 7
```
## 提示

数据保证，$1\le n\le100$，$1 \leq a_i \leq 10^5$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
int a[105];
int judge(int x){
if(x<=1)
return 0;
for(int i=2;i<=sqrt(x);i++)
if(x%i==0)
return 0;
return 1;
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
if(judge(a[i]))
cout<<a[i]<<" ";
}
return 0;
}
```

---

## 题目: P5737

**分类：入门-函数结构体**

**提交时间：2024-09-13 16:25:42**

---
title: "【深基7.例3】闰年展示"
layout: "post"
diff: 入门
pid: P5737
tag: []
---
# 【深基7.例3】闰年展示
## 题目描述

输入 $x,y$，输出 $[x,y]$ 区间中闰年个数，并在下一行输出所有闰年年份数字，使用空格隔开。
## 输入格式

输入两个正整数 $x,y$，以空格隔开。
## 输出格式

第一行输出一个正整数，表示 $[x,y]$ 区间中闰年个数。

第二行输出若干个正整数，按照年份单调递增的顺序输出所有闰年年份数字。
## 样例

### 样例输入 #1
```
1989 2001
```
### 样例输出 #1
```
3
1992 1996 2000
```
## 提示

数据保证，$1582\le x < y \le 3000$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int x,y,sum=0,a[3005];
bool flag=0;
int main()
{
cin>>x>>y;
for(int i=x;i<=y;i++)
{
flag=0;
if((i%4==0&&i%100!=0)||i%400==0)
{
flag=1;
}
if(flag==1)
{
sum+=1;
a[sum]=i;
}
}
cout<<sum<<endl;
for(int i=1;i<=sum;i++)
{
cout<<a[i]<<" ";
}
return 0;
}
```

---

## 题目: P5738

**分类：入门-函数结构体**

**提交时间：2024-09-13 16:58:30**

---
title: "【深基7.例4】歌唱比赛"
layout: "post"
diff: 普及-
pid: P5738
tag: []
---
# 【深基7.例4】歌唱比赛
## 题目描述

$n(n\le 100)$ 名同学参加歌唱比赛，并接受 $m(m\le 20)$ 名评委的评分，评分范围是 $0$ 到 $10$ 分。这名同学的得分就是这些评委给分中去掉一个最高分，去掉一个最低分，剩下 $m-2$ 个评分的平均数。请问得分最高的同学分数是多少？评分保留 $2$ 位小数。
## 输入格式

第一行两个整数 $n,m$。   
接下来 $n$ 行，每行各 $m$ 个整数，表示得分。
## 输出格式

输出分数最高的同学的分数，保留两位小数。
## 样例

### 样例输入 #1
```
7 6
4 7 2 6 10 7
0 5 0 10 3 10
2 6 8 4 3 6
6 3 6 7 5 8
5 9 3 3 8 1
5 9 9 3 2 0
5 8 0 4 1 10

```
### 样例输出 #1
```
6.00
```


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
struct student{
int max1,min1;
double sum;
}stu[105];
int n,m;
double ans=0;
int main()
{
cin>>n>>m;
for(int i=1;i<=n;i++)
{
stu[i].min1=10;
for(int j=1;j<=m;j++)
{
int a;
cin>>a;
stu[i].max1=max(stu[i].max1,a);
stu[i].min1=min(stu[i].min1,a);
stu[i].sum+=a;
}
stu[i].sum=stu[i].sum-stu[i].max1-stu[i].min1;
stu[i].sum/=(m-2);
ans=max(ans,stu[i].sum);
}
printf("%.2lf\n",ans);
return 0;
}
```

---

## 题目: P5739

**分类：入门-函数结构体**

**提交时间：2024-09-13 17:06:09**

---
title: "【深基7.例7】计算阶乘"
layout: "post"
diff: 入门
pid: P5739
tag: []
---
# 【深基7.例7】计算阶乘
## 题目描述

求 $n!$，也就是 $1\times2\times3\dots\times n$。

挑战：尝试不使用循环语句（for、while）完成这个任务。
## 输入格式

第一行输入一个正整数 $n$。
## 输出格式

输出一个正整数，表示 $n!$。
## 样例

### 样例输入 #1
```
3
```
### 样例输出 #1
```
6
```
## 提示

数据保证，$1 \leq n\le12$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=1;
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
sum*=i;
}
cout<<sum;
return 0;
}
```

---

## 题目: P5740

**分类：入门-函数结构体**

**提交时间：2024-09-15 09:13:35**

---
title: "【深基7.例9】最厉害的学生"
layout: "post"
diff: 普及-
pid: P5740
tag: []
---
# 【深基7.例9】最厉害的学生
## 题目描述

现有 $N$ 名同学参加了期末考试，并且获得了每名同学的信息：姓名（不超过 $8$ 个字符的仅有英文小写字母的字符串）、语文、数学、英语成绩（均为不超过 $150$ 的自然数）。总分最高的学生就是最厉害的，请输出最厉害的学生各项信息（姓名、各科成绩）。如果有多个总分相同的学生，输出靠前的那位。
## 输入格式

第一行输入一个正整数 $N$，表示学生个数。

第二行开始，往下 $N$ 行，对于每一行首先先输入一个字符串表示学生姓名，再输入三个自然数表示语文、数学、英语的成绩。均用空格相隔。
## 输出格式

输出最厉害的学生。
## 样例

### 样例输入 #1
```
3
senpai 114 51 4
lxl 114 10 23
fafa 51 42 60
```
### 样例输出 #1
```
senpai 114 51 4
```
## 提示

数据保证，$1 \leq N \leq 1000$，姓名为长度不超过 $8$ 的字符串，语文、数学、英语成绩均为不超过 $150$ 的自然数。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct student{
string name;
int c,m,e,sum;
int num;
}stu[1005];
bool cmp(student a,student b)
{
if(a.sum==b.sum)
{
return a.num<b.num;
}
return a.sum>b.sum;
}
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>stu[i].name>>stu[i].c>>stu[i].m>>stu[i].e;
stu[i].num=i;
stu[i].sum=stu[i].c+stu[i].m+stu[i].e;
}
sort(stu+1,stu+n+1,cmp);
cout<<stu[1].name<<" "<<stu[1].c<<" "<<stu[1].m<<" "<<stu[1].e;
return 0;
}
```

---

## 题目: P5741

**分类：入门-函数结构体**

**提交时间：2024-09-20 15:39:45**

---
title: "【深基7.例10】旗鼓相当的对手 - 加强版"
layout: "post"
diff: 普及-
pid: P5741
tag: []
---
# 【深基7.例10】旗鼓相当的对手 - 加强版
## 题目描述

现有 $N(N\le 1000)$ 名同学参加了期末考试，并且获得了每名同学的信息：姓名（不超过 $8$ 个字符的字符串，没有空格）、语文、数学、英语成绩（均为不超过 $150$ 的自然数）。如果某对学生 $\text{<}i,j\text{>}$ 的每一科成绩的分差都不大于 $5$，且总分分差不大于 $10$，那么这对学生就是“旗鼓相当的对手”。现在我们想知道这些同学中，哪些是“旗鼓相当的对手”？请输出他们的姓名。

所有人的姓名是按照字典序给出的，输出时也应该按照字典序输出所有对手组合。也就是说，这对组合的第一个名字的字典序应该小于第二个；如果两个组合中第一个名字不一样，则第一个名字字典序小的先输出；如果两个组合的第一个名字一样但第二个名字不同，则第二个名字字典序小的先输出。
## 输入格式

第一行输入一个正整数 $N$，表示学生个数。

第二行开始，往下 $N$ 行，对于每一行首先先输入一个字符串表示学生姓名，再输入三个自然数表示语文、数学、英语的成绩。均用空格相隔。
## 输出格式

输出若干行，每行两个以空格隔开的字符串，表示一组旗鼓相当的对手。注意题目描述中的输出格式。
## 样例

### 样例输入 #1
```
3
fafa 90 90 90
lxl 95 85 90
senpai 100 80 91
```
### 样例输出 #1
```
fafa lxl
lxl senpai

```
## 提示

数据保证，$1 \leq N \leq 1000$，姓名为长度不超过 $8$ 的字符串，语文、数学、英语成绩均为不超过 $150$ 的自然数。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct student {
int c,m,e,sum;
string name;
}a[1005];
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>a[i].name>>a[i].c>>a[i].m>>a[i].e;
a[i].sum=a[i].c+a[i].m+a[i].e;
}
for(int i=1;i<=n-1;i++)
{
for(int j=i+1;j<=n;j++)
{
if(abs(a[i].c-a[j].c)<=5&&abs(a[i].m-a[j].m)<=5&&abs(a[i].e-a[j].e)<=5&&abs(a[i].sum-a[j].sum)<=10)
{
cout<<a[i].name<<" "<<a[j].name<<endl;
}
}
}
return 0;
}
```

---

## 题目: P5743

**分类：入门-函数结构体**

**提交时间：2024-09-15 09:38:37**

---
title: "【深基7.习8】猴子吃桃"
layout: "post"
diff: 入门
pid: P5743
tag: []
---
# 【深基7.习8】猴子吃桃
## 题目描述

一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；接下来的每一天它都会吃剩余的桃子的一半外加一个。第 $n$ 天早上起来一看，只剩下 $1$ 个桃子了。请问小猴买了几个桃子？
## 输入格式

输入一个正整数 $n$，表示天数。
## 输出格式

输出小猴买了多少个桃子。
## 样例

### 样例输入 #1
```
4
```
### 样例输出 #1
```
22

```
## 提示

数据保证，$1\le n\le20$。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,sum=1;
int main()
{
cin>>n;
for(int i=1;i<=n-1;i++)
{
sum+=1;
sum*=2;
}
cout<<sum;
return 0;
}
```

---

## 题目: P5744

**分类：入门-函数结构体**

**提交时间：2024-09-15 09:47:00**

---
title: "【深基7.习9】培训"
layout: "post"
diff: 入门
pid: P5744
tag: []
---
# 【深基7.习9】培训
## 题目描述

某培训机构的学员有如下信息：

- 姓名（字符串）
- 年龄（周岁，整数）
- 去年 NOIP 成绩（整数，且保证是 $5$ 的倍数）

经过为期一年的培训，所有同学的成绩都有所提高，提升了 $20\%$（当然 NOIP 满分是 $600$ 分，不能超过这个得分）。

输入学员信息，请设计一个结构体储存这些学生信息，并设计一个函数模拟培训过程，其参数是这样的结构体类型，返回同样的结构体类型，并输出学员信息。
## 输入格式

第一行输入一个正整数 $n$，表示学员个数。

第二行开始往下 $n$ 行。每行首先是一个字符串表示学员姓名，再是一个整数表示学员年龄，再是一个整数为去年 NOIP 成绩。
## 输出格式

输出 $n$ 行，每行首先输出一个字符串表示学生姓名，再往后两个整数，表示经过一年的培训后学员的年龄和他们今年的 NOIP 成绩。以空格隔开。
## 样例

### 样例输入 #1
```
3
kkksc03 24 0
chen_zhe 14 400
nzhtl1477 18 590
```
### 样例输出 #1
```
kkksc03 25 0
chen_zhe 15 480
nzhtl1477 19 600
```
## 提示

数据保证，$1 \leq n \leq 5$。年龄为 $0 \sim 100$（含 $0$ 与 $100$）的整数。成绩为 $0 \sim 600$（含 $0$ 与 $600$）的 $5$ 的整倍数。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
struct student{
string name;
int age,NOIP;
}stu[1005];
int main()
{
cin>>n;
for(int i=1;i<=n;i++)
{
cin>>stu[i].name>>stu[i].age>>stu[i].NOIP;
}
for(int i=1;i<=n;i++)
{
cout<<stu[i].name<<" "<<stu[i].age+1<<" ";
if(stu[i].NOIP*1.2>600)
{
cout<<600<<endl;
}
else
{
cout<<stu[i].NOIP*1.2<<endl;
}
}
return 0;
}
```

---

## 题目: P7266

**分类：动态规划**

**提交时间：2025-03-23 10:30:21**

---
title: "[BalticOI 2000] Honeycomb Problem"
layout: "post"
diff: 普及/提高-
pid: P7266
tag: ['动态规划 DP', '2000', 'BalticOI（波罗的海）']
---
# [BalticOI 2000] Honeycomb Problem
## 题目描述

如下图，是一个边长为 $3$ 的蜂窝图，每个点有点权：

![](https://cdn.luogu.com.cn/upload/image_hosting/71c4lcqk.png)

现在要从上面一行的某一点到最下面的一行某一点，每次只可以到达左下角的点和右下角的点，您最多可以交换选定的一行中的两个点的数值。

求通过交换，从上面一行的某一点到最下面的一行某一点的点权之和的最大值是多少。
## 输入格式

第一行一个整数 $n$ 代表蜂窝图的边长。     
接下来 $2n-1$ 行每行若干个整数代表一个蜂窝图。
## 输出格式

一行一个整数代表答案。
## 样例

### 样例输入 #1
```
3
1 2 3
3 2 2 1
4 2 8 0 3
5 3 1 2
3 1 4
```
### 样例输出 #1
```
22
```
## 提示

#### 样例说明

对于样例 $1$，交换第四行的 $5$ 和 $1$，然后我们就可以得到一条点权之和最大的路径：

$$3 \to 2 \to 8 \to 5 \to 4$$

最大值为 $22$。

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le n \le 99$，$0 \le $ 蜂窝图中的每个图 $\le 99$。

#### 说明

翻译自 [BalticOI 2000 Day1 A Honeycomb Problem](https://boi.cses.fi/files/boi2000_day1.pdf)。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[205][205],dp[205][205][3],x[205],maxx=-1;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
for(int j=1;j<=i+n-1;j++){
cin>>a[i][j];
x[i]=max(x[i],a[i][j]);
}
}
for(int i=n+1;i<=2*n-1;i++){
for(int j=1;j<=2*n-1-(i-n);j++){
cin>>a[i][j];
x[i]=max(x[i],a[i][j]);
}
}
for(int i=1;i<=n;i++) {
dp[1][i][0]=a[1][i];
dp[1][i][1]=x[1];
}
for(int i=2;i<=n;i++){
for(int j=1;j<=n+i-1;j++){
dp[i][j][0]=a[i][j]+max(dp[i-1][j][0],dp[i-1][j-1][0]);
dp[i][j][1]=max(max(dp[i-1][j][0],dp[i-1][j-1][0])+x[i],max(dp[i-1][j][1],dp[i-1][j-1][1])+a[i][j]);
}
}
for(int i=n+1;i<=n*2-1;i++){
for(int j=1;j<=2*n-1-(i-n);j++){
dp[i][j][0]=a[i][j]+max(dp[i-1][j][0],dp[i-1][j+1][0]);
dp[i][j][1]=max(max(dp[i-1][j][0],dp[i-1][j+1][0])+x[i],max(dp[i-1][j][1],dp[i-1][j+1][1])+a[i][j]);
}
}
for(int i=1;i<=n;i++){
maxx=max(maxx,dp[n*2-1][i][1]);
}
cout<<maxx;
return 0;
}
```

---

## 题目: P8218

**分类：算法--前缀和、差分与离散化**

**提交时间：2024-10-27 13:14:30**

---
title: "【深进1.例1】求区间和"
layout: "post"
diff: 普及-
pid: P8218
tag: []
---
# 【深进1.例1】求区间和
## 题目描述

给定 $n$ 个正整数组成的数列 $a_1, a_2, \cdots, a_n$ 和 $m$ 个区间 $[l_i,r_i]$，分别求这 $m$ 个区间的区间和。

对于所有测试数据，$n,m\le10^5,a_i\le 10^4$
## 输入格式

第一行，为一个正整数 $n$ 。

第二行，为 $n$ 个正整数 $a_1,a_2, \cdots ,a_n$

第三行，为一个正整数 $m$ 。

接下来 $m$ 行，每行为两个正整数 $l_i,r_i$ ，满足$1\le l_i\le r_i\le n$
## 输出格式

共 $m$ 行。

第 $i$ 行为第 $i$ 组答案的询问。
## 样例

### 样例输入 #1
```
4
4 3 2 1
2
1 4
2 3
```
### 样例输出 #1
```
10
5
```
## 提示

样例解释：第 $1$ 到第 $4$ 个数加起来和为 $10$。第 $2$ 个数到第 $3$ 个数加起来和为 $5$。

对于 $50 \%$ 的数据：$n,m\le 1000$；

对于 $100 \%$ 的数据：$1 \le n, m\le 10^5$，$1 \le a_i\le 10^4$


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,a[100005],s[100005],x,y;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
s[i]=a[i]+s[i-1];
}
cin>>m;
for(int i=1;i<=n;i++){
cin>>x>>y;
cout<<s[y]-s[x-1]<<endl;
}
return 0;
}
```

---

## 题目: P8662

**提交时间：2025-01-26 21:49:01**

---
title: "[蓝桥杯 2018 省 AB] 全球变暖"
layout: "post"
diff: 普及-
pid: P8662
tag: ['2018', '广度优先搜索 BFS', '蓝桥杯省赛']
---
# [蓝桥杯 2018 省 AB] 全球变暖
## 题目描述

你有一张某海域 $N \times N$ 像素的照片，`.` 表示海洋、 `#` 表示陆地，如下所示：

```
.......
.##....
.##....
....##.
..####.
...###.
.......
```

其中 "上下左右" 四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有 $2$ 座岛屿。

由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻（上下左右四个相邻像素中有海洋），它就会被淹没。

例如上图中的海域未来会变成如下样子：

```
.......
.......
.......
.......
....#..
.......
.......
```

请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 

## 输入格式

第一行包含一个整数 $N$。$(1 \le N \le 1000)$。

以下 $N$ 行 $N$ 列代表一张海域照片。

照片保证第 $1$ 行、第 $1$ 列、第 $N$ 行、第 $N$ 列的像素都是海洋。
## 输出格式

一个整数表示答案。
## 样例

### 样例输入 #1
```
7 
.......
.##....
.##....
....##.
..####.
...###.
.......  
```
### 样例输出 #1
```
1
```
## 提示

时限 1 秒, 256M。蓝桥杯 2018 年第九届省赛


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m,vis[1005][1005],b[1005][1005],c[1000005],cnt=0;
char a[1005][1005];
int dx[5]={0,0,1,-1};
int dy[5]={1,-1,0,0};
void dfs(int x,int y){
if(x<1||x>n||y<1||y>n||a[x][y]=='.'){
return;
}
a[x][y]='.';
for(int i=0;i<4;i++){
dfs(x+dx[i],y+dy[i]);
}
}
int main(){
cin>>n;
for(int i=1;i<=n;i++){
for(int j=1;j<=n;j++){
cin>>a[i][j];
}
}
for(int i=1;i<=n;i++){
for(int j=1;j<=n;j++){
if(a[i][j]=='#'&&a[i-1][j]=='#'&&a[i+1][j]=='#'&&a[i][j-1]=='#'&&a[i][j+1]=='#'){
dfs(i,j);
}
}
}
for(int i=1;i<=n;i++){
for(int j=1;j<=n;j++){
if(a[i][j]=='#'){
cnt+=1;
dfs(i,j);
}
}
}
cout<<cnt;
return 0;
}
```

---

## 题目: P8680

**提交时间：2023-12-05 21:12:10**

---
title: "[蓝桥杯 2019 省 B] 特别数的和"
layout: "post"
diff: 入门
pid: P8680
tag: ['2019', '枚举', '蓝桥杯省赛']
---
# [蓝桥杯 2019 省 B] 特别数的和
## 题目描述

小明对数位中含有 $2$、$0$、$1$、$9$ 的数字很感兴趣（不包括前导 $0$），在 $1$ 到 $40$ 中这样的数包括 $1$、$2$、$9$、$10$ 至 $32$、$39$ 和 $40$，共 $28$ 个，他们的和是 $574$。

请问，在 $1$ 到 $n$ 中，所有这样的数的和是多少？
## 输入格式

输入一行包含一个整数 $n$。
## 输出格式

输出一行，包含一个整数，表示满足条件的数的和。
## 样例

### 样例输入 #1
```
40
```
### 样例输出 #1
```
574
```
## 提示

对于 $20\%$ 的评测用例，$1 \le n \le 10$。

对于 $50\%$ 的评测用例，$1 \le n \le 100$。

对于 $80\%$ 的评测用例，$1 \le n \le 1000$。
 
对于所有评测用例，$1 \le n \le 10000$。

蓝桥杯 2019 省赛 B 组 F 题。


### 代码

```cpp
#include <iostream>
using namespace std;
int main() {
int n, x, sum = 0;
cin >> n;
for (int i = 1; i <= n; i++)
{
string str = to_string(i);
for (char c : str)
{
x = (int)c - '0';
if (x == 0 || x == 1 || x == 2 || x == 9)
{
sum += i;
break;
}
}
}
cout << sum;
return 0;
}
```

---

## 题目: P8742

**分类：动态规划**

**提交时间：2025-03-16 11:48:27**

---
title: "[蓝桥杯 2021 省 AB] 砝码称重"
layout: "post"
diff: 普及-
pid: P8742
tag: ['动态规划 DP', '2021', '背包 DP', '蓝桥杯省赛']
---
# [蓝桥杯 2021 省 AB] 砝码称重
## 题目描述

你有一架天平和 $N$ 个砝码, 这 $N$ 个砝码重量依次是 $W_{1}, W_{2}, \cdots, W_{N}$ 。 请你计算一共可以称出多少种不同的重量?

注意砝码可以放在天平两边。

## 输入格式

输入的第一行包含一个整数 $N$ 。

第二行包含 $N$ 个整数: $W_{1}, W_{2}, W_{3}, \cdots, W_{N}$ 。
## 输出格式

输出一个整数代表答案。
## 样例

### 样例输入 #1
```
3
1 4 6
```
### 样例输出 #1
```
10
```
## 提示

**【样例说明】**

能称出的 10 种重量是: $1 、 2 、 3 、 4 、 5 、 6 、 7 、 9 、 10 、 11$ 。

$$
\begin{aligned}
&1=1 \\
&2=6-4(\text { 天平一边放 } 6, \text { 另一边放 4) } \\
&3=4-1 \\
&4=4 \\
&5=6-1 \\
&6=6 \\
&7=1+6 \\
&9=4+6-1 \\
&10=4+6 \\
&11=1+4+6
\end{aligned}
$$

**【评测用例规模与约定】**

对于 $50 \%$ 的评测用例, $1 \leq N \leq 15$ 。

对于所有评测用例, $1 \leq N \leq 100, N$ 个砝码总重不超过 $10^5$。 

蓝桥杯 2021 第一轮省赛 A 组 F 题（B 组 G 题）。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,a[105],f[105][100005];
int main(){
cin>>n;
int m=0;
for(int i=1;i<=n;i++){
cin>>a[i];
m+=a[i];
}
f[0][0]=1;
for(int i=1;i<=n;i++){
for(int j=m;j>=0;j--){
f[i][j]=f[i-1][j]||f[i-1][abs(j-a[i])]||f[i-1][j+a[i]];
}
}
int ans=0;
for(int i=1;i<=m;i++){
if(f[n][i]==1){
ans+=1;
}
}
cout<<ans;
return 0;
}
```

---

## 题目: P8754

**分类：数学**

**提交时间：2025-03-20 20:35:16**

---
title: "[蓝桥杯 2021 省 AB2] 完全平方数"
layout: "post"
diff: 普及-
pid: P8754
tag: ['2021', '数论', '素数判断,质数,筛法', '蓝桥杯省赛']
---
# [蓝桥杯 2021 省 AB2] 完全平方数
## 题目描述

一个整数 $a$ 是一个完全平方数，是指它是某一个整数的平方，即存在一个 整数 $b$，使得 $a=b^{2}$ 。

给定一个正整数 $n$，请找到最小的正整数 $x$，使得它们的乘积是一个完全平方数。
## 输入格式

输入一行包含一个正整数 $n$。
## 输出格式

输出找到的最小的正整数 $x$。
## 样例

### 样例输入 #1
```
12
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
15
```
### 样例输出 #2
```
15 
```
## 提示

对于 $30 \%$ 的评测用例, $1 \leq n \leq 1000$，答案不超过 $1000$。

对于 $60 \%$ 的评测用例，$1 \leq n \leq 10^{8}$，答案不超过 $10^{8}$。

对于所有评测用例，$1 \leq n \leq 10^{12}$，答案不超过 $10^{12}$。

蓝桥杯 2021 第二轮省赛 A 组 G 题（B 组 H 题）。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
long long n,a[1000005],ans=1;
int main(){
cin>>n;
long long x=n;
for(long long i=2;i<=sqrt(n);i++){
while(x%i==0){
x/=i;
a[i]+=1;
}
}
for(int i=2;i<=1000000;i++){
if(a[i]%2==1){
ans*=i;
}
}
if(x>1){
ans*=x;
}
cout<<ans;
return 0;
}
```

---

## 题目: P8772

**提交时间：2024-10-27 13:40:22**

---
title: "[蓝桥杯 2022 省 A] 求和"
layout: "post"
diff: 普及-
pid: P8772
tag: ['2022', '前缀和', '差分', '蓝桥杯省赛']
---
# [蓝桥杯 2022 省 A] 求和
## 题目描述

给定 $n$ 个整数 $a_{1}, a_{2}, \cdots, a_{n}$, 求它们两两相乘再相加的和，即

$$
S=a_{1} \cdot a_{2}+a_{1} \cdot a_{3}+\cdots+a_{1} \cdot a_{n}+a_{2} \cdot a_{3}+\cdots+a_{n-2} \cdot a_{n-1}+a_{n-2} \cdot a_{n}+a_{n-1} \cdot a_{n}
$$

## 输入格式

输入的第一行包含一个整数 $n$ 。

第二行包含 $n$ 个整数 $a_{1}, a_{2}, \cdots a_{n}$ 。

## 输出格式

输出一个整数 $S$，表示所求的和。请使用合适的数据类型进行运算。
## 样例

### 样例输入 #1
```
4
1 3 6 9
```
### 样例输出 #1
```
117
```
## 提示

对于 $30 \%$ 的数据, $1 \leq n \leq 1000,1 \leq a_{i} \leq 100$ 。

对于所有评测用例, $1 \leq n \leq 2\times10^5,1 \leq a_{i} \leq 1000$ 。 

蓝桥杯 2022 省赛 A 组 C 题。


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;
long long a[200005],s[200005],sum=0;
int main(){
cin>>n;
for(int i=1;i<=n;i++){
cin>>a[i];
s[i]=s[i-1]+a[i];
}
for(int i=1;i<=n;i++){
sum+=a[i]*(s[n]-s[i]);
}
cout<<sum;
return 0;
}
```

---

## 题目: P9459

**提交时间：2023-11-12 13:34:44**

---
title: "「EZEC-14」浴眼盯真"
layout: "post"
diff: 入门
pid: P9459
tag: ['模拟', '洛谷原创', 'O2优化', '洛谷月赛']
---
# 「EZEC-14」浴眼盯真
## 题目背景

验题人提示：本题数据在 windows 下生成，即换行符为 ``\r\n``。
## 题目描述

dXqwq 定义一个字符串四元组 $(a,b,c,d)$ 是“浴眼盯真”的，当且仅当：

- $a,b$ 的首字母均为 $\texttt{y}$。
- $c$ 恰好等于 $\texttt{ding}$。
- $d$ 恰好等于 $\texttt{zhen}$。

给定四个用空格分隔的字符串 $a,b,c,d$，保证其只包含小写英文字母，你需要判断 $(a,b,c,d)$ 是否是“浴眼盯真”的。
## 输入格式

本题有多组测试数据。

第一行输入一个整数 $T$，代表测试数据组数。

接下来 $T$ 行，每行输入四个用空格分隔的字符串 $a,b,c,d$。
## 输出格式

对于每组数据输出一行。

如果 $(a,b,c,d)$ 是“浴眼盯真”的，输出 ``Yes``，否则输出 ``No``。
## 样例

### 样例输入 #1
```
5
yi yan ding zhen
yu yan ding zhen
zheng tai ding zhen
yin yang guai qi
you xiu su zhi

```
### 样例输出 #1
```
Yes
Yes
No
No
No
```
## 提示

**【样例解释】**

前两组测试数据满足全部要求。

第三，五组测试数据不满足第一条要求。

第四，五组测试数据不满足第二，三条要求。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 1（50 pts）：保证输入的所有字符串长度均为 $4$。
- Subtask 2（50 pts）：无特殊限制。 

对于 $100\%$ 的数据，$1\leq T\leq 100$，每个字符串长度不超过 $10$。

![](https://cdn.luogu.com.cn/upload/image_hosting/qvr810ap.png)


### 代码

```cpp
#include<bits/stdc++.h>
using namespace std;
int n;//n组测试数据
string a,b,c,d;//定义a,b,c,d字符串
int main()
{
cin>>n;//输入测试数据
for(int i=1;i<=n;i++)
{
cin>>a>>b>>c>>d;//输入a,b,c,d四个字符串
if(a[0]==b[0] && a[0]=='y' && c=="ding" && d=="zhen")//依次判定3个条件
cout<<"Yes"<<endl;//如果全都满足，输出Yes
else
cout<<"No"<<endl;//否则输出No
}
return 0;
}
```

---

## 题目: P9681

**提交时间：2023-11-24 16:31:37**

---
title: "幽默的世界。"
layout: "post"
diff: 普及+/提高
pid: P9681
tag: ['洛谷原创', 'O2优化', '前缀和', '洛谷月赛']
---
# 幽默的世界。
## 题目背景

@【数据删除】 : 大家觉得呢 || @【数据删除】 : oi 生活总是充满了幽默。 不过学文化课或许也好不了多少？
## 题目描述

给定一个长为 $n$ 的序列 $a_1,a_2,\cdots,a_n$，定义 $a$ 的一个连续子序列 $a_l,a_{l+1},\cdots,a_r$ 是幽默的，当且仅当：

- $\sum\limits_{i=l}^ra_i>0$；
- 对于所有 $l\le x\le y<r$，满足 $\sum\limits_{i=x}^y a_i\le 0$。

$q$ 次询问，每次给定两个整数 $l,r$，查询满足以下条件的数对 $(l',r')$ 个数：

- $l\le l'\le r'\le r$；
- 连续子序列 $a_{l'},a_{l'+1},\cdots a_{r'}$ 是幽默的。
## 输入格式

第一行输入两个整数 $n,q$。

接下来一行输入 $n$ 个整数，第 $i$ 个整数代表 $a_i$。

接下来 $q$ 行，每行输入两个整数 $l,r$，代表一次询问。
## 输出格式

对于每组询问，输出一行一个整数，代表答案。
## 样例

### 样例输入 #1
```
4 3
3 -4 -1 2
1 2
3 4
1 4

```
### 样例输出 #1
```
1
2
3

```
### 样例输入 #2
```
7 6
-1 2 -1 -1 -1 2 -1
2 5
4 7
1 7
5 5
1 3
2 4

```
### 样例输出 #2
```
1
2
4
0
2
1

```
## 提示

对于所有数据，保证 $1\le n,q\le 2\times 10^5$，$1\le l\le r\le n$，$|a_i|\le 10^9$。

### 子任务

|  #   |       特殊性质        | 分值 |
| :--: | :-------------------: | :--: |
|  0   |         样例          |  0   |
|  1   |      $n,q\le 50$      |  15  |
|  2   | $n,q\le 3\times 10^3$ |  20  |
|  3   |  对于所有询问，$r=n$  |  15  |
|  4   |  对于所有询问，$l=1$  |  15  |
|  5   |           -           |  35  |



### 代码

```cpp
#include<bits/stdc++.h>
#define int long long
using namespace std;
int n,q;
int a[200005];//输入数列
int f_ans[200005];
//f_ans 前缀和数组，记录 i 之前合法区间与包含 i 的区间数量之和
int dis[200005];
//dis 记录包含 i 的区间 且区间右端点不为 i 的区间的数量之和
int id[200005];//id 记录这个点所处的块的编号
int tot;//编号（可能不连续）
signed main()
{
cin>>n>>q;
for(int i=1;i<=n;i++) cin>>a[i];
//输入
for(int i=1;i<=n;i++)
{
f_ans[i]=f_ans[i-1];//统计方案前缀和
id[i]=++tot;//赋予编号
if(a[i]<=0) continue;
//这个点不能作为区间 [x,r] 的右端点(a[r]<=0)
//继续循环
int p=i-1,nw=a[i];
//枚举区间左端点 p，nw 记录区间 [p,r] 的和
while(p>=1&&a[p]<=0&&nw+a[p]>0) nw+=a[p--];
//左端点若还可以移动就移动
for(int j=p+1,k=1;j<=i;j++,k++) f_ans[j]+=k,dis[j]+=k,id[j]=tot;
//更新前缀和数组，dis，区间编号
dis[i]=0;//不记录右端点为 i 的情况
//dis 记录包含 i 的区间 且区间右端点不为 i 的区间的数量之和
}
while(q--)
{
int l,r;
cin>>l>>r;
if(id[l]==id[r]&&a[r]<=0) cout<<0<<'\n';
//l，r 同属一个区间且 r 不能作为右端点，答案为 0
else if(id[l]!=id[r]&&a[r]<=0) cout<<f_ans[r]-f_ans[l-1]-dis[r]<<'\n';
//l，r 不属于同一个区间且 r 不可作为 r 所属区间的右端点，
//因为前缀和 f_ans 记录了包含 r 的区间，但 r 不能作为 r 所属区间的右端点
//所以前缀和相减后还要减掉 dis[r]（可能有些难懂）
else cout<<f_ans[r]-f_ans[l-1]<<'\n';
//反之：
//1: l，r 同属一个区间且 r 是右端点
//2: l，r 不属于同一个区间且 r 可以作为 r 所属区间的右端点
//前缀和直接相减即可
}
return 0;
}
```

---

## 题目: P9745

**提交时间：2023-11-17 15:00:30**

---
title: "「KDOI-06-S」树上异或"
layout: "post"
diff: 提高+/省选-
pid: P9745
tag: ['动态规划 DP', '2023', '洛谷原创', 'O2优化', '树形 DP', '位运算', '洛谷月赛']
---
# 「KDOI-06-S」树上异或
## 题目描述

给定一棵包含 $n$ 个节点的树，第 $i$ 个点有一个点权 $x_i$。

对于树上的 $n-1$ 条边，每条边选择删除或不删除，有 $2^{n-1}$ 种选择是否删除每条边的方案。

对于每种删除边的方案，设删除后的图包含 $k$ 个连通块，定义这个方案的权值为图中连通块点权异或和的乘积。形式化地说，若这张图包含连通块 $C_1,C_2,\ldots,C_k$，其中 $C_i$ 是第 $i$ 个连通块的顶点集合，设 $v_i=\bigoplus_{u\in C_i} x_u$，则这个方案的权值为 $v_1\times v_2\times \cdots\times v_k$。

求这 $2^{n-1}$ 种删除边的方案的**权值**之和，答案对 $998~244~353$ 取模。
## 输入格式

从标准输入读入数据。

输入的第一行包含一个正整数 $n$，表示树的节点个数。

第二行 $n$ 个非负整数 $x_1,x_2,\ldots,x_n$，表示每个点的点权。

第三行 $n-1$ 个正整数 $f_2,f_3,\ldots,f_n$，表示节点 $i$ 与 $f_{i}$ 之间有一条无向边。
## 输出格式

输出到标准输出。

输出包含一行一个整数，表示所有 $2^{n-1}$ 种删除边的方案的**权值**之和，答案对 $998~244~353$ 取模。
## 样例

### 样例输入 #1
```
3
1 2 3
1 1
```
### 样例输出 #1
```
19
```
### 样例输入 #2
```
5
3 4 5 6 7
1 1 2 2
```
### 样例输出 #2
```
5985
```
## 提示

**【样例解释 #1】**

有四种删除边的方案：

* 不删除边：图有且仅有一个连通块，权值为 $1\oplus2\oplus3=0$。
* 删除 $(1,2)$ 一条边：图包含两个连通块，权值为 $(1\oplus3)\times2=4$。
* 删除 $(1,3)$ 一条边：图包含两个连通块，权值为 $(1\oplus2)\times3=9$。
* 删除 $(1,2)$，$(1,3)$ 两条边：图包含三个连通块，权值为 $1\times2\times3=6$。

所有方案权值的总和为 $0+4+9+6=19$。

**【样例 #3】**

见选手目录下的 `xor/xor3.in` 与 `xor/xor3.ans`。

这个样例满足测试点 $6\sim7$ 的条件限制。

**【样例 #4】**

见选手目录下的 `xor/xor4.in` 与 `xor/xor4.ans`。

这个样例满足测试点 $8$ 的条件限制。

**【样例 #5】**

见选手目录下的 `xor/xor5.in` 与 `xor/xor5.ans`。

这个样例满足测试点 $9$ 的条件限制。

**【样例 #6】**

见选手目录下的 `xor/xor6.in` 与 `xor/xor6.ans`。

这个样例满足测试点 $19\sim21$ 的条件限制。

***

**【数据范围】**

对于所有数据保证：$1\leq n\leq5\times10^5$，$0\leq x_i\leq10^{18}$，$1\leq f_i<i$。

| 测试点编号 | $n\leq$ | $x_i$ | 特殊性质 |
|:--:|:--:|:--:|:--:|
| $1\sim2$ | $12$ | $\leq10^9$ | 无 |
| $3$ | $2000$ | $=1$ | 无 |
| $4$ | $10^5$ | $=1$ | A |
| $5$ | $10^5$ | $=1$ | B |
| $6\sim7$ | $10^5$ | $=1$ | 无 |
| $8$ | $10^5$ | $\leq7$ | A |
| $9$ | $10^5$ | $\leq7$ | B |
| $10\sim11$ | $10^5$ | $\leq7$ | 无 |
| $12\sim16$ | $200$ | $\leq8191$ | 无 |
| $17$ | $10^5$ | $\leq10^9$ | A |
| $18$ | $10^5$ | $\leq10^9$ | B |
| $19\sim21$ | $10^5$ | $\leq10^9$ | 无 |
| $22\sim25$ | $5\times10^5$ | $\leq10^{18}$ | 无 |

* 特殊性质 A：保证对于任意 $1< i\le n$，$f_i=i-1$。
* 特殊性质 B：保证对于任意 $1< i\le n$，$f_i=1$。

***

**【提示】**

$\oplus$ 表示按位异或运算。

本题输入输出量较大，请使用适当的 I/O 方式。

**请注意常数因子对程序运行效率产生的影响。**



### 代码

```cpp
#include <bits/stdc++.h>
#define REP(i, l, r) for (int i = (l); i <= (r); ++ i)
#define DEP(i, r, l) for (int i = (r); i >= (l); -- i)
#define fi first
#define se second
using namespace std;
namespace Milkcat {
typedef long long LL;
typedef pair<LL, LL> pii;
const int N = 1e6 + 5, mod = 998244353;
LL n, u, v, a[N], f[N]; int g[N][64][2];
vector<int> G[N];
void dfs(int u, int fa) {
REP(i, 0, 63) g[u][i][a[u] >> i & 1] = 1;
for (int v : G[u]) {
if (v == fa) continue;
dfs(v, u);
REP(i, 0, 63) {
LL t0 = g[u][i][0], t1 = g[u][i][1];
g[u][i][0] = (t0 * (g[v][i][0] + f[v]) + t1 * g[v][i][1]) % mod;
g[u][i][1] = (t0 * g[v][i][1] + t1 * (g[v][i][0] + f[v])) % mod;
}
}
REP(i, 0, 63) f[u] = (f[u] + (1LL << i) % mod * g[u][i][1]) % mod;
}
int main() {
cin >> n;
REP(i, 1, n) cin >> a[i];
REP(i, 2, n)
cin >> u, G[u].push_back(i), G[i].push_back(u);
dfs(1, 0);
cout << f[1] << '\n';
return 0;
}
}
int main() {
ios::sync_with_stdio(0);
cin.tie(0), cout.tie(0);
int T = 1;
while (T --) Milkcat::main();
return 0;
}
```
---
title: "[NOI2024] 树的定向"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10787
tag: ['2024', 'NOI', 'O2优化']
---
# [NOI2024] 树的定向
## 题目背景

由于评测机性能差异，原题时限为 3s，洛谷上时限为 6s。
## 题目描述

给定一棵含有 $n$ 个顶点的树，顶点从 $1$ 到 $n$ 编号，树上第 $i(1\leq i\leq n-1)$ 条边连接顶点 $u_i$ 和 $v_i$。

现在，我们想要给树的每条边一个定向。任何一个定向都可以用一个长度为 $n-1$ 的字符串 $S=s_1s_2\ldots s_{n-1}$ 来描述。其中 $s_i=0$ 代表第 $i$ 条边定向为 $u_i \to v_i$，否则 $s_i=1$ 代表第 $i$ 条边定向为 $v_i\to u_i$。

给定 $m$ 个顶点对 $(a_i,b_i)$，其中 $1\leq a_i,b_i \leq n$ 且 $a_i\neq b_i$。

一个**完美定向**定义为：在此定向下，对于任意 $1\leq i\leq m$，$a_i$ ****不能到达**** $b_i$。

试求在所有完美定向中，所对应的字符串字典序最小的定向。**数据保证存在至少一个完美定向**。

定义字符串 $S=s_1s_2\ldots s_{n-1}$ 的字典序小于 $T=t_1t_2\ldots t_{n-1}$ 若存在一个下标 $k$ 使得 $s_1=t_1, s_2=t_2, \ldots, s_{k-1}=t_{k-1}$ 且 $s_k < t_k$。

## 输入格式

输入的第一行包含三个非负整数 $c,n,m$，分别表示测试点编号，树的点数，顶点对的个数。其中 $c=0$ 表示该测试点为样例。

接下来 $n-1$ 行，每行包含两个正整数 $u_i,v_i$ 表示树的一条边。保证 $1\leq u_i,v_i\leq n$ 且这 $n-1$ 条边构成了一棵树。

接下来 $m$ 行，每行包含两个正整数 $a_i,b_i$。保证 $1\leq a_i,b_i \leq n$ 且 $a_i\neq b_i$。
## 输出格式

输出一行包含一个字符串 $S=s_1s_2\ldots s_{n-1}$，表示字典序最小的完美定向所对应的 $01$ 字符串。
## 样例

### 样例输入 #1
```
0 4 2
1 2
2 3
3 4
3 2
1 4
```
### 样例输出 #1
```
001
```
### 样例输入 #2
```
0 6 8
5 1
2 3
1 2
5 6
4 3
4 3
5 1
6 3
5 4
1 4
5 2
3 6
6 2
```
### 样例输出 #2
```
10101
```
### 样例输入 #3
```
见 tree3.in/tree3.ans
这个样例满足测试点 1-3 的约束条件。
```
### 样例输出 #3
```

```
### 样例输入 #4
```
见 tree4.in/tree4.ans
这个样例满足测试点 4-6 的约束条件。
```
### 样例输出 #4
```

```
### 样例输入 #5
```
见 tree5.in/tree5.ans
这个样例满足测试点 7,8 的约束条件。
```
### 样例输出 #5
```

```
### 样例输入 #6
```
见 tree6.in/tree6.ans
这个样例满足测试点 9,10 的约束条件。
```
### 样例输出 #6
```

```
## 提示

**【样例 1 解释】**

在该样例中，若 $S=000$，则该定向中 $1$ 能到达 $4$（存在路径 $1\to 2\to 3\to 4$），因而不是完美定向。若 $S=001$，则该定向中 $3$ 不能到达 $2$，$1$ 不能到达 $4$，因面是完美定向。故答案为 $001$。

**【样例 2 解释】**

在该样例中，一组完美定向必定满足 $4$ 不能到达 $3$，$5$ 不能到达 $1$。故 $s_1=s_5=1$。若 $s_2=s_3=0$，则存在路径 $1\to 2\to 3\to 4$，故 $1$ 可到达 $4$。故其不是完美定向。因此，所有完美定向必定满足 $S$ 的字典序不小于 $10101$。且容易验证 $S=10101$ 时，对应的定向是完美定向。

**【数据范围】**

对于所有测试数据保证 $2\leq n\leq 5\times 10^5$，$1\leq m\leq 5\times 10^5$，$1\leq u_i,v_i\leq n$ 且所有的边构成了一棵树，$1\leq a_i,b_i \leq n$ 且 $a_i\neq b_i$。

数据保证存在至少一个完美定向。

| 测试点编号 | $n$ | $m$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $\leq 15$ | $\leq 50$ | 无 |
| $4\sim 6$ | $\leq 300$ | $\leq 300$ | 无 |
| $7,8$ | $\leq 400$ | $=(n-1)(n-2)$ | A |
| $9,10$ | $\leq 2\,000$ | $\leq 2\,000$ | B |
| $11\sim 14$ | $\leq 2\,000$ | $\leq 2\,000$ | 无 |
| $15,16$ | $\leq 10^5$ | $\leq 10^5$ | B |
| $17,18$ | $\leq 10^5$ | $\leq 10^5$ | 无 |
| $19\sim 21$ | $\leq 2\times 10^5$ | $\leq 2\times 10^5$ | 无 |
| $22\sim 25$ | $\leq 5\times 10^5$ | $\leq 5\times 10^5$ | 无 |

- 特殊性质 A：保证 $(a,b)$ 出现在 $(a_i,b_i)$ 中当且仅当 $a\neq b$ 且 $a,b$ 在树上不相邻。
- 特殊性质 B：保证树上编号为 $1$ 的顶点与其他每个顶点均相邻。


---

---
title: "[NOI2024] 分数"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10788
tag: ['2024', 'NOI', 'O2优化']
---
# [NOI2024] 分数
## 题目背景

由于评测机性能差异，原题时限为 6s，洛谷时限为 9s。
## 题目描述

小 Y 和小 C 在玩一个游戏。

定义正分数为分子、分母都为正整数的既约分数。

定义**完美正分数集合** $S$ 为满足以下五条性质的正分数集合：
- $\dfrac{1}{2}\in S$；
- 对于 $\dfrac{1}{2}<x<2$，$x\not \in S$；
- 对于所有 $x\in S$，$\dfrac{1}{x}\in S$；
- 对于所有 $x\in S$，$x+2 \in S$；
- 对于所有 $x\in S$ 且 $x>2$，$x-2 \in S$；

可以证明，上述五条性质确定了唯一的完美正分数集合 $S$。

所有完美正分数集合 $S$ 中的正分数被称为**完美正分数**。记 $f(i,j)$ 表示 $\dfrac{i}{j}$ 是否为完美正分数，即 $f(i,j)=1$ 当且仅当 $i$ 与 $j$ 互素且 $\dfrac{i}{j} \in S$，否则 $f(i,j)=0$。

小 C 问小 Y：给定 $n,m$，求所有分子不超过 $n$，分母不超过 $m$ 的完美正分数的个数，即求 $\sum_{i=1}^n \sum_{j=1}^m f(i,j)$。

时光走过，小 C 和小 Y 会再遇见。回首往事，大家都过上了各自想要的生活。
## 输入格式

输入的第一行包含两个正整数 $n$ 和 $m$，分别表示分子和分母的范围。
## 输出格式

输出一行包含一个非负整数，表示对应的答案。
## 样例

### 样例输入 #1
```
10 10
```
### 样例输出 #1
```
16
```
### 样例输入 #2
```
见 fraction2.in/ans
这个样例满足测试点 4-6 的约束条件
```
### 样例输出 #2
```

```
### 样例输入 #3
```
见 fraction3.in/ans
这个样例满足测试点 11-14 的约束条件
```
### 样例输出 #3
```

```
### 样例输入 #4
```
见 fraction4.in/ans
这个样例满足测试点 15-17 的约束条件
```
### 样例输出 #4
```

```
## 提示

**【样例 1 解释】**

可以证明，分子分母均不超过 $10$ 的完美正分数共有 $16$ 个，其中小于 $1$ 的 $8$ 个如下：
- $\dfrac{1}{2},\dfrac{1}{4},\dfrac{1}{6},\dfrac{1}{8},\dfrac{1}{10},\dfrac{2}{5},\dfrac{2}{9},\dfrac{4}{9}$。

大于 $1$ 的 $8$ 个完美正分数分别为上述 $8$ 个小于 $1$ 的完美正分数的倒数。
- 可以按照如下方式验证 $\dfrac{2}{9}$ 是否为完美正分数：因为 $\dfrac{1}{2}\in S$，$\dfrac{1}{2}+2=\dfrac{5}{2}\in S$，$\dfrac{5}{2}+2=\dfrac{9}{2}\in S$，$\dfrac{1}{\dfrac{9}{2}}=\dfrac{2}{9}\in S$；
- 可以按照如下方式验证 $\dfrac{3}{7}$ 是否为完美正分数：假设 $\dfrac{3}{7}$ 是完美正分数，则 $\dfrac{1}{\dfrac{3}{7}}=\dfrac{7}{3}\in S$，$\dfrac{7}{3}-2=\dfrac{1}{3}\in S$，$\dfrac{1}{\dfrac{1}{3}}=3\in S$，$3-2=1\in S$，与第二条性质矛盾，因此 $\dfrac{3}{7}$ 不是完美正分数

**【数据范围】**

对于所有测试数据保证：$2\leq n,m\leq 3\times 10^7$。

| 测试点编号 | $n\leq$ | $m\leq$ |
| :----------: | :----------: | :----------: |
| $1\sim 3$ | $10^2$ | $10^2$ |
| $4\sim 6$ | $10^3$ | $10^3$ |
| $7\sim 10$ | $8\,000$ | $8\,000$ |
| $11\sim 14$ | $10^5$ | $10^5$ |
| $15\sim 17$ | $10^6$ | $10^6$ |
| $18$ | $8\times 10^6$ | $8\times 10^6$ |
| $19$ | $8\times 10^6$ | $3\times 10^7$ |
| $20$ | $3\times 10^7$ | $3\times 10^7$ |


---

---
title: "[NOI2024] 登山"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10789
tag: ['2024', 'NOI', 'O2优化']
---
# [NOI2024] 登山
## 题目描述

“为什么要攀登？因为山就在那里。”

慕士塔格山上有 $n$ 处点位，点从 $1$ 到 $n$ 编号，$1$ 号点位为山顶。这 $n$ 个点位构成一棵有根树的结构，其中 $1$ 号点位为根，对于 $2\leq i\leq n$，$i$ 号点位的父亲结点为 $p_i$ 号点位。

记 $d_i$ 为 $i$ 号点位到山顶所需经过的边数。形式化地说，$d_1=0$，对于 $2\leq i\leq n$，$d_i=d_{p_i}+1$。

定义一条**登山路径**为从 $2\sim n$ 号点位中的某一个开始，经过若干次**移动**后**到达山顶**的方案。

定义一次从 $i(2\leq i\leq n)$ 号点位出发的**移动**为以下两种方式之一：
1. 冲刺：在给定的冲刺范围 $[l_i,r_i]$ 内，选择一个正整数 $k$ 满足 $l_i\leq k\leq r_i$，向山顶移动 $k$ 步，即移动至 $i$ 号点位在有根树上的 $k$ 级父亲处。保证 $1\leq l_i\leq r_i\leq d_i$。
2. 休息：由于慕士塔格山地形陡峭，休息时会滑落到某一个儿子结点处。形式化地说，选择一个满足 $p_j=i$ 的 $j$，移动至到 $j$ 号点位。特别地，若 $i$ 号点位为有根树的叶子结点，则不存在满足 $p_j=i$ 的 $j$，因此此时不能选择休息。

定义一条**登山路径**对应的**登山序列**为初始点位以及每次移动到的点位所构成的序列。形式化地说，一条从 $x$ 号点位开始的**登山路径**对应的****登山序列****是一个点序列 $a_1=x,a_2,\dots,a_m=1$ 满足对于 $1\leq i<m$，$a_{i+1}$ 是 $a_i$ 的 $k(l_{a_i}\leq k\leq r_{a_i})$ 级祖先或 $p_{a_{i+1}}=a_i$。

为了保证每次冲刺都能更接近山顶，一条**合法的登山路径**需要满足：对于初始点位或某次移动到的点位 $i$，以后冲刺到的点位 $j$ 都必须满足 $d_j<d_i-h_i$，其中 $h_i$ 是一个给定的参数，保证 $0\leq h_i<d_i$。形式化地说，一条**合法的登山路径**对应的**登山序列** $a_1,a_2,\dots,a_m$ 需要满足：对于所有 $1\leq i<j\leq m$，若 $p_{a_j} \neq a_{j-1}$，则 $d_{a_j}<d_{a_i}-h_{a_i}$。

对于 $2\sim n$ 号所有点位，求从这些点位开始的**合法的登山路径**条数。两条**登山路径**不同当且仅当其对应的**登山序列**不同。由于答案可能较大，你只需要求出答案对 $998\,244\,353$ 取模后的结果。
## 输入格式

**本题有多组测试数据。**

输入的第一行包含一个整数 $c$，表示测试点编号。$c=0$ 表示该测试点为样例。

输入的第二行包含一个整数 $t$，表示测试数据组数。

接下来依次输入每组测试数据，对于每组测试数据：

输入的第一行包含一个整数 $n$，表示慕士塔格山的点位数量。

接下来 $n-1$ 行，第 $i-1(2\leq i\leq n)$ 行包含四个整数 $p_i,l_i,r_i,h_i$。保证 $1\leq p_i<i$，$1\leq l_i\leq r_i\leq d_i$，$0\leq h_i<d_i$。
## 输出格式

对于每组测试数据，输出一行 $n-1$ 个整数，分别表示从点位 $2\sim n$ 到达山顶的方案数对 $998\,244\,353$ 取模后的结果。
## 样例

### 样例输入 #1
```
0
3
5
1 1 1 0
2 1 1 0
2 1 2 1
4 2 3 0
6
1 1 1 0
2 1 2 0
3 1 3 2
4 1 4 1
5 1 5 3
6
1 1 1 0
2 1 2 0
2 1 2 0
3 1 2 0
3 2 3 2
```
### 样例输出 #1
```
3 3 2 4
5 9 3 21 6
4 10 5 14 1
```
### 样例输入 #2
```
见 mountain2.in/ans
这个样例满足测试点 2,3 的约束条件
```
### 样例输出 #2
```

```
### 样例输入 #3
```
见 mountain3.in/ans
这个样例满足测试点 9 的约束条件
```
### 样例输出 #3
```

```
### 样例输入 #4
```
见 mountain4.in/ans
这个样例满足测试点 11,12 的约束条件
```
### 样例输出 #4
```

```
### 样例输入 #5
```
见 mountain5.in/ans
这个样例满足测试点 13 的约束条件
```
### 样例输出 #5
```

```
## 提示

**【样例 1 解释】**

样例 $1$ 共包含三组测试数据。

对于第一组测试数据，慕士塔格山的点位结构如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/8e2srlpm.png)

在该测试数据中，$d_1=0$，$d_2=1$，$d_3=d_4=2$，$d_5=3$。

从 $4$ 开始的合法的登山路径共有以下 $2$ 条：
1. 直接选择冲刺到 $4$ 的 $2$ 级父亲，也就是 $1$，到达山顶，对应的登山序列为 $[4,1]$。
2. 先休息滑落到 $5$，然后从 $5$ 冲刺到它的 $3$ 级父亲，到达山顶。对应的登山序列为 $[4,5,1]$。

从 $5$ 开始的合法的登山路径共有以下 $4$ 条：
1. 直接选择冲刺到 $5$ 的 $3$ 级父亲，也就是 $1$，到达山顶。对应的登山序列为 $[5,1]$。
2. 先冲刺到 $5$ 的 $2$ 级父亲，也就是 $2$；然后再从 $2$ 冲刺到它的 $1$ 级父亲，到达山顶。对应的登山序列为 $[5,2,1]$。
3. 先冲刺到 $5$ 的 $2$ 级父亲，也就是 $2$；然后在 $2$ 处休息，滑落到 $4$；接着从 $4$ 冲刺到它的 $2$ 级父亲，到达山顶。对应的登山序列为 $[5,2,4,1]$。
4. 先冲刺到 $5$ 的 $2$ 级父亲，也就是 $2$；然后在 $2$ 处休息，滑落到 $4$；继续休息，滑落到 $5$；接着从 $5$ 再次冲刺到它的 $3$ 级父亲，到达山顶。对应的登山序列为 $[5,2,4,5,1]$。

**【数据范围】**

对于所有测试数据保证：$1\leq t\leq 4$，$2\leq n\leq 10^5$。

对于任意的 $2\leq i\leq n$，保证：$1\leq p_i<i$，$1\leq l_i\leq r_i\leq d_i$，$0\leq h_i<d_i$。

| 测试点编号 | $n\leq$ | 是否有 $l_i=r_i$ | 是否有 $h_i=0$ | 是否有 $p_i=i-1$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $6$ | 否 | 否 | 否 |
| $2,3$ | $300$ | 否 | 否 | 否 |
| $4,5$ | $5000$ | 否 | 否 | 否 |
| $6$ | $10^5$ | 是 | 是 | 是 |
| $7$ | $10^5$ | 是 | 是 | 否 |
| $8$ | $10^5$ | 是 | 否 | 是 |
| $9$ | $10^5$ | 是 | 否 | 否 |
| $10$ | $10^5$ | 否 | 是 | 是 |
| $11,12$ | $10^5$ | 否 | 是 | 否 |
| $13$ | $10^5$ | 否 | 否 | 是 |
| $14\sim 20$ | $10^5$ | 否 | 否 | 否 |



---

---
title: "[NOI2024] 树形图"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10790
tag: ['2024', 'NOI', 'O2优化']
---
# [NOI2024] 树形图
## 题目背景

由于评测机性能差异，本题时限翻倍。
## 题目描述

给定一个 $n$ 个点 $m$ 条边的**简单有向图** $G$，顶点从 $1$ 到 $n$ 编号。其中简单有向图的定义为**不存在重边与自环**的有向图。

定义顶点 $r$ 是有向图 $G$ 的根当且仅当对于 $1\leq k\leq n$，顶点 $r$ 到顶点 $k$ 存在恰好一条**有向简单路径**，其中简单路径的定义为**不经过重复点的路径**。

定义每个点的种类如下：
- 若顶点 $r$ 是图 $G$ 的根，则称顶点 $r$ 为图 $G$ 的**一类点**。
- 若顶点 $r$ 不是图 $G$ 的一类点，且存在一种删边的方案，使得图 $G$ 在删去若干条边后得到的图 $G'$ 满足：所有图 $G$ 中的一类点都是 $G'$ 的根，且顶点 $r$ 也是图 $G'$ 的根，则称顶点 $r$ 为图 $G$ 的**二类点**。
- 若顶点 $r$ 不满足上述条件，则称顶点 $r$ 为图 $G$ 的**三类点**。

根据上述定义，图 $G$ 的每个点都恰好属于一类点，二类点，三类点之一。你需要判断点 $1\sim n$ 分别属于这三个种类中的哪一种。
## 输入格式

**本题有多组测试数据。**

输入的第一行包含一个非负整数 $c$，表示测试点编号。$c=0$ 表示该测试点为样例。

输入的第二行包含一个正整数 $t$，表示测试数据组数。

接下来依次输入每组测试数据，对于每组测试数据：

输入的第一行包含两个正整数 $n,m$，分别表示有向图的点数和边数。

接下来 $m$ 行，每行包含两个正整数 $u,v$，表示一条从 $u$ 到 $v$的有向边。保证 $1\leq u,v\leq n$，且给定的有向图 $G$ 不存在重边与自环。
## 输出格式

对于每组数据，输出一行包含一个长度恰好为 $n$ 的字符串 $s$ 表示每个点的种类。其中 $s_i=1$ 表示点 $i$ 为**一类点**，$s_i=2$ 表示点 $i$ 为**二类点**，$s_i=3$ 表示点 $i$ 为**三类点**。
## 样例

### 样例输入 #1
```
0
2
4 7
2 1
4 1
1 4
2 3
3 4
2 4
4 3
4 5
1 2
2 3
2 4
3 1
4 3
```
### 样例输出 #1
```
3233
2211
```
### 样例输入 #2
```
见 graphee2.in/ans
这个样例满足测试点 2 的约束条件
```
### 样例输出 #2
```

```
### 样例输入 #3
```
见 graphee3.in/ans
这个样例满足测试点 3,4 的约束条件
```
### 样例输出 #3
```

```
### 样例输入 #4
```
见 graphee4.in/ans
这个样例满足测试点 5,6 的约束条件
```
### 样例输出 #4
```

```
### 样例输入 #5
```
见 graphee5.in/ans
这个样例满足测试点 8,9 的约束条件
```
### 样例输出 #5
```

```
### 样例输入 #6
```
见 graphee6.in/ans
这个样例满足测试点 14,15 的约束条件
```
### 样例输出 #6
```

```
## 提示

**【样例 1 解释】**

样例 $1$ 共包含两组测试数据。

对于第一组测试数据，输入的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/yorwc4dr.png)

由于 $1,3,4$ 均不存在到达 $2$ 的路径，因此 $1,3,4$ 均为三类点。由于 $2$ 到 $1$ 的有向简单路径共有三条：$2\to 1$，$2\to 4\to 1$，$2\to 3\to 4\to 1$，因此 $2$ 不是一类点。删去边 $1\to 4$，$4\to 1$，$3\to 4$，$4\to 3$ 后，$2$ 到 $1,3,4$ 的有向简单路径均唯一，因此 $2$ 是图 $G'$ 的根，即 $2$ 是二类点。

对于第二组测试数据，输入的图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/t8r9veu2.png)

容易发现 $3,4$ 均为一类点，删去边 $2\to 3$ 后，每个点到其他所有点的有向简单路径均唯一，因此 $1,2$ 均为二类点。

**【数据范围】**

对于所有测试数据保证：$1\leq t\leq 10$，$2\leq n\leq 10^5$，$1\leq m\leq 2\times 10^5$，且图 $G$ 不存在重边与自环。

| 测试点编号 | $t\leq$ | $n\leq$ | $m\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $10$ | $20$ | 无 |
| $2$ | $10$ | $10^3$ | $2000$ | A |
| $3,4$ | $10$ | $10^3$ | $2000$ | B |
| $5,6$ | $10$ | $10^3$ | $2000$ | 无 |
| $7$ | $10$ | $10^5$ | $2\times 10^5$ | A |
| $8,9$ | $10$ | $10^5$ | $2\times 10^5$ | BC |
| $10\sim 13$ | $10$ | $10^5$ | $2\times 10^5$ | B |
| $14,15$ | $10$ | $10^5$ | $2\times 10^5$ | C |
| $16\sim 20$ | $10$ | $10^5$ | $2\times 10^5$ | 无 |

- 特殊性质 A：保证不存在一类点。
- 特殊性质 B：保证不存在二类点。
- 特殊性质 C：保证编号为 $1$ 的点为图 $G$ 的一类点。


---

---
title: "[NOISG 2021 Finals] Pond"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P11303
tag: ['2021', 'NOISG（新加坡）']
---
# [NOISG 2021 Finals] Pond
## 题目背景

乌龟 Syrup 经常在他家旁边的池塘里游泳。这个池塘是由很久以前的冰川运动形成的，呈狭长直线状，水面平静，适合双向游泳。
## 题目描述

今天，Syrup 像往常一样游泳时，发现了一簇绿点——正在萌发的藻类孢子。经过暴雨冲刷，富含营养的土壤流入池塘，为藻类提供了大量养分，导致它们以惊人的速度生长。如果不加以控制，这些藻类会遮挡阳光，破坏水下生态平衡。

幸运的是，Syrup 有一个简单有效的解决方案——吃掉它们。他已经识别出池塘中 $N$ 个土壤流失点，标号为 $1$ 到 $N$，并记下了它们之间的距离 $D_i$（第 $i$ 点到第 $i+1$ 点之间的距离为 $D_i$）。目前，Syrup 位于第 $K$ 个点，并从这里开始消灭藻类。

池塘中的每个点初始有 $0$ 条藻类，并且每秒会增加 $1$ 条藻类，直到 Syrup 到达该点并吃掉所有藻类。Syrup 需要选择一个方向，沿着池塘游泳，并依次吃掉遇到的所有藻类。为了让藻类不至于变得太难吃，他希望尽可能减少吃下的藻类总数。

你的任务是计算 Syrup 吃下的最少藻类总数。
## 输入格式

- 第一行包含两个整数 $N$ 和 $K$，分别表示池塘中的土壤流失点数量和 Syrup 的起始位置。
- 第二行包含 $N-1$ 个整数 $D_1, D_2, \dots, D_{N-1}$，表示相邻流失点之间的距离。
## 输出格式

输出一个整数，表示 Syrup 吃下的最少藻类总数。
## 样例

### 样例输入 #1
```
7 3
5 2 4 2 2 5
```
### 样例输出 #1
```
86
```
### 样例输入 #2
```
9 5
4 3 2 1 1 3 6 10
```
### 样例输出 #2
```
129
```
### 样例输入 #3
```
6 4
1 1 1 1 1
```
### 样例输出 #3
```
21
```
## 提示

【样例解释】

- 对于样例 $1$，最优路径是按顺序访问点 $3 \to 2 \to 4 \to 5 \to 6 \to 7 \to 1$，总共吃掉 $0 + 2 + 8 + 10 + 12 + 17 + 37 = 86$ 条藻类。
- 对于样例 $2$，最优路径是按顺序访问点 $5 \to 6 \to 4 \to 3 \to 2 \to 1 \to 7 \to 8 \to 9$，总共吃掉 $0 + 1 + 3 + 5 + 8 + 12 + 26 + 32 + 42 = 129$ 条藻类。
- 对于样例 $3$，最优路径是按顺序访问点 $4 \to 3 \to 2 \to 1 \to 5 \to 6$，总共吃掉 $0 + 1 + 2 + 3 + 7 + 8 = 21$ 条藻类。

【数据范围】

- $2 \leq N \leq 3 \times 10^5$
- $1 \leq K \leq N$
- $1 \leq D_i \leq 10^6$

| 子任务编号 | 分值 | 额外限制条件                       |
| :--------: | :--: | :-------------------------------: |
| $1$        | $7$  | $N \leq 100$                     |
| $2$        | $11$ | $N \leq 2000$                    |
| $3$        | $10$ | $1 \leq K \leq \min(N, 20)$      |
| $4$        | $6$  | $D_i = 1$                        |
| $5$        | $12$ | $1 \leq K \leq \min(N, 2000)$ 且 $D_i \geq D_{i+1}$（对所有 $i$ 满足 $i \not\equiv 0 \pmod{100}$） |
| $6$        | $25$ | $1 \leq K \leq \min(N, 2000)$    |
| $7$        | $29$ | 无额外限制                       |


---

---
title: "[NOISG 2022 Finals] Fruits"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P11331
tag: ['动态规划 DP', '线段树', '2022', '颜色段均摊（珂朵莉树 ODT）', 'NOISG（新加坡）']
---
# [NOISG 2022 Finals] Fruits
## 题目描述

超市里通常有专门的一区卖水果。

兔子 $\text{Benson}$ 常去的超市一共有 $N$ 个柜台用来卖 $N$ 种水果。柜台编号从 $1 \sim N$，水果编号从 $1 \sim N$。第 $i$ 种水果的美味度是 $i$，购买需要花费 $C_i$ 元。**保证对于所有的 $1 \le i < j \le N$，有 $C_i \le C_j$。**

每一个柜台都只买一种水果，每一种水果都有且仅有一个柜台售卖。现在，工作人员规定了每个柜台卖哪一种水果。第 $i$ 个柜台卖第 $A_i$ 种水果。如果 $A_i=-1$，则表示这个柜台还没有确定卖什么。

当所有柜台的水果都摆放好，$\text{Benson}$ 就会进店抢购。他会按照 $1 \sim N$ 的顺序去这些柜台。当他到了一个柜台，如果他的购物车里还是空的，或当前柜台水果的美味度大于所有他购物车里的水果，那么他就会购买这种水果，将其放进购物车中。

现在你需要让商店赚到最多的钱。你需要计算怎么来摆放那些 $A_i=-1$ 的柜台使得利润最大化。由于 $\text{Benson}$ 很赶时间，他可能不会逛完所有柜台，所以你需要对于所有的 $1 \le k \le N$ 计算如果 $\text{Benson}$ 只逛第 $1 \sim k$ 个柜台，那么这些柜台应该如何摆放最优。
## 输入格式

第一行，一个正整数 $N$；

第二行 $N$ 个整数，表示 $A_i$；

第三行 $N$ 个整数，表示 $C_i$。
## 输出格式

一行 $N$ 个整数，第 $k$ 个表示如果 $\text{Benson}$ 只逛前 $k$ 个柜台且水果按照最优方案摆放，商店可获得的最大钱数。
## 样例

### 样例输入 #1
```
5
-1 -1 -1 -1 -1
1 1 1 1 1
```
### 样例输出 #1
```
1 2 3 4 5

```
### 样例输入 #2
```
5
-1 3 -1 -1 -1
1 2 2 2 3

```
### 样例输出 #2
```
3 4 7 9 9
```
### 样例输入 #3
```
13
-1 -1 5 6 -1 -1 7 11 -1 -1 10
-1 -1
1 1 1 1 1 1 1 1 1 1 1 1 1

```
### 样例输出 #3
```
1 2 3 4 5 6 6 7 8 9 9 9 9
```
### 样例输入 #4
```
10
-1 -1 -1 -1 5 -1 -1 -1 9 -1
5 11 24 27 35 60 72 81 91 92
```
### 样例输出 #4
```
92 173 245 305 305 332 356 367 406 498

```
## 提示

**【数据范围】**

|$\text{Subtask}$|分值|特殊性质|
|:-:|:-:|:-:|
|$0$|$0$|样例|
|$1$|$6$|$N\le8$|
|$2$|$5$|对于所有 $1\le j\le N$，$A_j=-1$|
|$3$|$11$|$N\le200$|
|$4$|$13$|$N\le2000$|
|$5$|$23$|对于所有 $1\le j\le N$，$C_j=1$|
|$6$|$42$|无|

对于 $100\%$ 的数据，$1 \le N \le 400000,1 \le A_j \le N$ 或 $A_j=-1,1 \le C_i \le 10^9$。


---

---
title: "[NOISG 2023 Finals] Toxic Gene"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P11537
tag: ['2023', '交互题', 'Special Judge', 'O2优化', 'NOISG（新加坡）']
---
# [NOISG 2023 Finals] Toxic Gene
## 题目背景

**这是一道交互题。**

本题只支持 C++ 提交，建议使用 C++17。

提交时不需要包含 toxic.h 头文件。

为了确保程序正常编译，你需要在你提交的程序开头加上如下函数声明语句：

```cpp
int query_sample(std::vector<int> species);
void answer_type(int x, char c);
```

如遇评测问题，请联系搬题人。
## 题目描述

**建议仔细区分题面中的“种类”和“个体”。**

兔子 Benson 的飞机被有害病毒侵袭了，他必须对此展开调查！

Benson 发现了 $n$ 种病毒，每种病毒恰好属于三个类型之一：普通、强悍和毒害。保证至少有一种毒害病毒。

Benson 必须识别每种病毒的类型。为了分析之，他将使用一个特殊的机器。每一次，他可以选择任意数量的病毒（包括 $0$）制成标本，并将其放入机器中。受机器大小的影响，每个标本里不能有超过 $300$ 个病毒。每个病毒的种类由 Benson 任意指定。

标本放入机器后，其中三个类型的病毒会发生如下反应：

- 当且仅当不存在毒害病毒，普通病毒可以存活。

- 强悍病毒总是存活。

- 毒害病毒产生有害物质并杀死强悍病毒外的所有病毒。因此，毒害病毒总是死亡。

对于每个样本，机器会告诉 Benson 有多少病毒存活。由于机器分析消耗太多时间，Benson 最多只能使用 $600$ 次机器。请帮助 Benson 确定每种病毒的类型：普通、强悍或毒害。


### 实现细节

这是一道交互题。你需要实现如下函数：

- `void determine_type(int n)`

每个测试数据中，该函数最多被调用 $100$ 次，每次调用将对应不同的病毒组合。对于每个测试数据，你必须保证所有调用不超过时间限制和空间限制。

你可以通过调用如下函数完成题目：

- `int query_sample(std::vector<int> species)`
- `void answer_type(int x, char c)`

调用 `query_sample` 函数时，需传入一维数组 `species`，表示标本中你所选择的病毒种类。该数组的大小不能超过 $300$。此外，你可以假定该函数调用结束后，`species` 数组不会改变。

调用 `answer_type` 函数时，需传入一个整数 $x$ 和一个字符 $c$。当你确定第 $x$ 种病毒的类型时，调用该函数，其中 $c$ 是 `R`、`S` 或 `T` 之一，分别表示普通病毒、强悍病毒和毒害病毒。你必须对每种病毒都调用该函数。

下列情况可能导致你收到 Wrong Answer 反馈并立即结束评测：

- `query_sample` 函数或 `answer_type` 函数的调用非法
- `answer_type` 函数给出的病毒种类有误
- `determine_type` 函数结束时，存在某种病毒未被 `answer_type` 确认
- 某次 `determine_type` 函数调用过程中，`query_sample` 被调用了超过 $600$ 次

请注意，题目中的交互库是**非自适应的**，即每个测试数据的答案被提前确定，且不会在交互过程中改变。
## 输入格式

示例测试程序按如下格式读取输入数据：

第一行两个整数 $tc, n$。$tc$ 表示 `determine_type` 的调用次数。

接下来 $tc$ 行，每行一个字符串，由 `R`、`S` 和 `T` 组成，依次描述每种病毒的类型。
## 输出格式

示例测试程序按如下格式输出信息：

对于每次 `determine_type` 的调用，输出一行一个整数：若反馈为 Wrong Answer，输出 $-1$；否则输出 `query_sample` 的调用次数。
## 提示

### 调用示例

假定 $n=5$，第一种病毒和第二种病毒是毒害病毒，第三种病毒和第四种病毒是普通病毒，第五种病毒是强悍病毒。该情况可用字符串 `TTRRS` 表达。

你的函数会被这样调用：

- `determine_type(5)`

一个可能的交互过程如下：

- `query_sample([1,2,3,4,5]) = 1`
所有种类的病毒都被放置在标本中，只有种类 $5$ 的病毒存活，故返回 $1$。

- `query_sample([3,3,4,5]) = 4`
两个“第三种病毒”、一个“第四种病毒”和一个“第五种病毒”被放置在标本中。由于不存在毒害病毒，所有病毒均存活，故返回 $4$。

此时，程序认为其已经确认所有病毒的类型，故进行了如下 $5$ 次调用：

- `answer_type(1,'T')`
- `answer_type(2,'T')`
- `answer_type(3,'R')`
- `answer_type(4,'R')`
- `answer_type(5,'S')`

这些函数都没有返回值。当程序正确地确认了 $n=5$ 种病毒的种类，且未使用超过 $600$ 次询问时，会在该测试点中被认为是正确的。

请注意，该示例仅供展示交互过程，不一定存在合理逻辑。

### 得分细则

设 $t$ 表示毒害病毒的数量。保证测试数据中 $n=300$，$1\leq t\leq 30$。

某测试点中，你的得分与所有 `determine_type` 调用中，询问次数的最大值有关，设为 $m$。

- 当 $m>600$ 时，得分为 $0$。
- 当 $340<m\leq 600$ 时，得分为 $2+7\times \frac{600-m}{260}$。
- 当 $275<m\leq 340$ 时，得分为 $9+15\times \frac{340-m}{65}$。
- 当 $190<m\leq 275$ 时，得分为 $24+22\times \frac{275-m}{85}$。
- 当 $150<m\leq 190$ 时，得分为 $46+54\times \frac{190-m}{40}$。
- 当 $m\leq 150$ 时，得分为 $100$。

### 程序测试

下发文件中有两个数据可供测试。`sample1.txt` 是上文的【调用示例】，`sample2.txt` 中含有一组 $tc=100,n=300$ 的测试数据。请使用 `compile.sh` 编译并运行你的程序。


---

---
title: "[NOI2016] 网格"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1173
tag: ['贪心', '2016', 'NOI', 'O2优化', '枚举', '双连通分量']
---
# [NOI2016] 网格
## 题目描述

跳蚤国王和蛐蛐国王在玩一个游戏。

他们在一个 $n$ 行 $m$ 列的网格上排兵布阵。其中的 $c$ 个格子中 $(0 \leq c \leq n\cdot m)$，每个格子有一只蛐蛐，其余的格子中，每个格子有一只跳蚤。

我们称占据的格子有公共边的两只跳蚤是相邻的。

我们称两只跳蚤是连通的，当且仅当这两只跳蚤相邻，或存在另一只跳蚤与这两只跳蚤都连通。

现在，蛐蛐国王希望，将某些（零个，一个或多个）跳蚤替换成蛐蛐，使得在此之后存在至少两只跳蚤不连通。

例如：图 $1$ 描述了一个 $n=4$，$m=4$，$c=2$ 的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/96tey4uv.png)

这种情况下蛐蛐国王可以通过将第二行第二列，和第三行第三列的两只跳蚤替换为蛐蛐，从而达成他的希望，如右图所示。并且，不存在更优的方案，但是可能存在其他替换两只跳蚤的方案。

你需要首先判断蛐蛐国王的希望能否被达成。如果能够达成，你还需要最小化被替换的跳蚤的个数。
## 输入格式

每个输入文件包含多组数据。

输入文件的第一行只有一个整数 $T$，表示数据的组数。

接下来依次输入 $T$ 组数据，每组数据的第一行包含三个整数 $n, m, c$。

接下来 $c$ 行，每行包含两个整数 $x, y$ 表示第 $x$ 行，第 $y$ 列的格子被一个蛐蛐占据。每一组数据当中，同一个蛐蛐不会被多次描述。
## 输出格式

对于每一组数据依次输出一行答案。

如果这组数据中，蛐蛐国王的希望不能被达成，输出 $-1$。否则，输出被替换的跳蚤的个数的最小值。
## 样例

### 样例输入 #1
```
4
4 4 2
1 1
4 4
2 3 1
1 2
2 2 2
1 1
2 2
1 1 0
```
### 样例输出 #1
```
2
1
0
-1
```
## 提示

### 样例解释

第一组数据就是问题描述中的例子。

对于第二组数据，可以将第二行第二列的一只跳蚤替换为蛐蛐，从而使得存在两只跳蚤不连通，并且不存在更优的方案。

对于第三组数据，最初已经存在两只跳蚤不连通，故不需要再进行替换。

对于第四组数据，由于最多只有一只跳蚤，所以无论如何替换都不能存在两只跳蚤不连通。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 20$。我们记 $\sum c$ 为某个测试点中，其 $T$ 组输入数据的所有 $c$ 的总和。对于所有的测试点，$\sum c \leq 10^5$。

对于全部的数据，满足 $1 \leq n,m \leq 10^9$，$0 \leq c \leq n \times m$，$1 \leq x \leq n, 1 \leq y \leq m$。

每个测试点的详细数据范围见下表。表中的 $n,m,c$ 均是对于单个输入数据（而非测试点）而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件；而 $\sum c$是对于单个测试点而言的。为了方便阅读，“测试点”一列被放到了表格的中间而不是左边。

| $n,m$ | 测试点 | $c$ |
| :----------: | :----------: | :----------: |
| $n*m\leq 4$ | $1$ | $c\leq n*m$ |
| $n*m\leq 8$ | $2$ | $c\leq n*m$ |
| $n*m\leq 15$ | $3$ | $c\leq n*m$ |
| $n*m\leq 30$ |  $4$| $c\leq n*m$ |
| $n*m\leq 100$ | $5$ | $c\leq n*m$ |
| $n*m\leq 300$ | $6$ | $c\leq n*m$ |
| $n*m\leq 10^3$ | $7$ | $c\leq n*m$ |
| $n*m\leq 2\times 10^4$ | $8$ | $c\leq 5$ |
| $n*m\leq 2\times 10^4$ | $9$ | $c\leq 15$ |
| $n*m\leq 2\times 10^4$ | $10$ | $c\leq 30$ |
| $n,m\leq 2\times 10^4,n*m\leq2\times 10^4$ | $11$ | $\sum c\leq 2\times 10^4$ |
| $n,m\leq 2\times 10^4,n*m\leq10^5$  | $12$ | $\sum c\leq 2\times 10^4$ |
| $n,m\leq 2\times 10^4,n*m\leq3\times 10^5$ | $13$ | $\sum c\leq 2\times 10^4$ |
| $n,m\leq 2\times 10^4,n*m\leq10^6$ | $14$ | $\sum c\leq 2\times 10^4$ |
| $n,m\leq 2\times 10^4,n*m\leq 10^9$ | $15$ | $\sum c\leq 2\times 10^4$ |
| $n,m\leq 10^5$ | $16$ | $\sum c\leq 10^5$ |
| $n,m\leq 10^9$ | $17$ | $c=0$ |
| $n,m\leq 10^9$ | $18$ | $c\leq 1$ |
| $n,m\leq 10^9$ | $19$ | $c\leq 2$ |
| $n,m\leq 10^9$ | $20$ | $c\leq 3$ |
| $n,m\leq 10^9$ | $21$ | $c\leq 10$ |
| $n,m\leq 10^9$ | $22$ | $c\leq 30$ |
| $n,m\leq 10^9$ | $23$ | $c\leq 300$ |
| $n,m\leq 10^9$ | $24$ | $\sum c\leq 2 \times 10^4$ |
| $n,m\leq 10^9$ | $25$ | $\sum c\leq   10^5$ |


---

---
title: "[NOISG 2025 Finals] Flooding"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P12019
tag: ['2025', '扫描线', 'NOISG（新加坡）']
---
# [NOISG 2025 Finals] Flooding
## 题目描述

Pavementland is a rectangle-shaped city, which can be modelled as a $h \times w$ grid of cells. The rows of the grid are numbered $1$ to $h$ from north to south, and the columns of the grid are numbered $1$ to $w$ from west to east. We refer to the cell located at row $r$ and column $c$ of the grid as cell $(r, c)$.

In the grid, each cell is either empty or contains a building. At least one cell is empty.

Due to a monsoon surge, flash floods are occurring throughout Pavementland. Initially, one empty cell becomes flooded with water by the rain. Then, the water flows according to the following rules:

- If an empty cell is adjacent to at least one flooded cell, it becomes flooded.
- If a cell containing a building is adjacent to at least two flooded cells, the building collapses and the cell becomes flooded.

Note that a cell is adjacent to another cell if they share an edge. A cell is adjacent to at most four other cells. Further note that water may not flow outside the grid. Let $f((r, c))$ be the number of cells that would be flooded after the process if the cell $(r, c)$ were initially flooded.

City officials are seeking to forecast the extent of flash floods in all possible scenarios. Help them determine the sum of $f((r, c))$ over all empty cells $(r, c)$.

## 输入格式

Your program must read from standard input.

The first line of input contains two space-separated integers $h$ and $w$.

The next $h$ lines of input each contain a binary string of length $w$. If the $c$-th character of the $r$-th line is $0$, then the cell $(r, c)$ is empty. If the $c$-th character of the $r$-th line is $1$, then the cell $(r, c)$ contains a building.

## 输出格式

Your program must print to standard output.

Output a single integer, the sum of $f((r, c))$ over all empty cells $(r, c)$.

## 样例

### 样例输入 #1
```
3 3
000
011
010
```
### 样例输出 #1
```
46
```
### 样例输入 #2
```
5 5
00101
01011
11010
01101
11000
```
### 样例输出 #2
```
182
```
### 样例输入 #3
```
1 10
1101011100
```
### 样例输出 #3
```
6
```
## 提示

### Subtasks

For all test cases, the input will satisfy the following bounds:

- $1 \leq h, w \leq 5000$
- There is at least one empty cell in the grid.

Your program will be tested on input instances that satisfy the following restrictions:

| Subtask | Marks | Additional Constraints |
| :-: | :-: | :-: |
| $0$ | $0$ | Sample test cases |
| $1$ | $5$ | $h = 1$ |
| $2$ | $7$ | $h, w \leq 80$ |
| $3$ | $16$ | $h, w \leq 500$ |
| $4$ | $32$ | $h, w \leq 2000$ |
| $5$ | $40$ | No additional constraints |

### Sample Test Case 1 Explanation

This test case is valid for subtasks $2$ to $5$.

If cells $(1, 1), (1, 2), (1, 3), (2, 1)$, or $(3, 1)$ were initially flooded, the entire grid would become flooded after the process. If cell $(3, 3)$ were initially flooded, only $1$ cell would become flooded after the process. Hence, the output is $9 + 9 + 9 + 9 + 9 + 1 = 46$.

### Sample Test Case 2 Explanation

This test case is valid for subtasks $2$ to $5$.

### Sample Test Case 3 Explanation

This test case is valid for all subtasks.



---

---
title: "[NOI2025] 数字树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P13273
tag: ['2025', 'NOI']
---
# [NOI2025] 数字树
## 题目描述

给定一棵 $4n - 1$ 个结点的二叉树，其中每个非叶结点都有 **恰好** 两个子结点。非叶结点编号为 $1$ 到 $2n - 1$，叶子结点编号为 $2n$ 到 $4n - 1$。初始时，每个叶子结点上都没有数字。

定义一个 DFS 序是 **优美的**，当且仅当按该 DFS 序将 **所有标有数字的叶子结点** 上的数字拼成一个序列时，该序列可以通过若干次 **消除相邻相同数字** 的方式得到空序列。例如，在下图中，若叶子结点 $4, 6$ 上标有数字 $1$，叶子结点 $5, 7$ 上标有数字 $2$，则按 DFS 序 $[1, 4, 2, 7, 3, 5, 6]$ 将所有标有数字的叶子结点上的数字拼成的序列为 $[1, 2, 2, 1]$，可以通过消除相邻的 $2$ 的方式得到 $[1, 1]$，再通过消除相邻的 $1$ 的方式得到空序列，因此该 DFS 序是优美的；而按 DFS 序 $[1, 4, 2, 3, 5, 6, 7]$ 将所有标有数字的叶子结点上的数字拼成的序列为 $[1, 2, 1, 2]$，无法通过若干次消除相邻相同数字的方式得到空序列，因此该 DFS 序不是优美的。

![](https://cdn.luogu.com.cn/upload/image_hosting/p4thcg8c.png)

给定 $n$ 次操作，第 $i$ ($1 \leq i \leq n$) 次操作会选择两个 **没有数字** 的叶子结点，然后将这两个结点标上数字 $i$。**保证在每次操作后，存在至少一个优美的 DFS 序**。你需要求出每次操作后的优美的 DFS 序的数量。由于答案可能较大，你只需要求出答案对 $1,000,000,007$ 取模后的结果。

## 输入格式

输入的第一行包含一个非负整数 $c$，表示测试点编号。$c = 0$ 表示该测试点为样例。

输入的第二行包含一个正整数 $n$，表示二叉树的结点个数为 $4n - 1$。

输入的第 $i + 2$ ($1 \leq i \leq 2n - 1$) 行包含两个正整数 $l_i$ 和 $r_i$，分别表示结点 $i$ 的左右子结点。保证 $i < l_i, r_i \leq 4n - 1$，且所有的 $l_i, r_i$ 互不相同。

输入的第 $i + 2n - 1$ ($1 \leq i \leq n$) 行包含两个正整数 $a_i, b_i$，表示第 $i$ 次操作选择的叶子结点的编号。保证 $2n \leq a_i, b_i \leq 4n - 1$，且所有的 $a_i, b_i$ 互不相同。

## 输出格式

输出 $n$ 行，其中第 $i$ ($1 \leq i \leq n$) 行包含一个非负整数，表示第 $i$ 次操作后的优美的 DFS 序的数量对 $1,000,000,007$ 取模后的结果。
## 样例

### 样例输入 #1
```
0
2
4 2
3 7
5 6
4 6
5 7
```
### 样例输出 #1
```
8
4


```
### 样例输入 #2
```
0
6
2 3
4 21
22 23
5 11
6 8
7 9
12 13
10 18
14 15
16 17
19 20
12 13
14 15
16 19
17 18
20 21
22 23
```
### 样例输出 #2
```
2048
2048
2048
1024
512
512
```
## 提示

### 样例 1 解释

该样例即【题目描述】中所示的例子。
- 第一次操作后，叶子结点 $4$ 和 $6$ 上标有数字 $1$，叶子结点 $5$ 和 $7$ 上没有数字，因此按任意 DFS 序拼成的序列均为 $[1, 1]$，即所有的 $2^3 = 8$ 个 DFS 序都是优美的。
- 第二次操作后，叶子结点 $4 \sim 7$ 上分别标有数字 $1, 2, 1, 2$，因此共有 $4$ 个优美的 DFS 序，分别为 $[1, 4, 2, 3, 6, 5, 7], [1, 4, 2, 7, 3, 5, 6], [1, 2, 3, 6, 5, 7, 4], [1, 2, 7, 3, 5, 6, 4]$。

### 样例 3

见选手目录下的 `tree/tree3.in` 与 `tree/tree3.ans`。

该样例满足测试点 $6 \sim 10$ 的约束条件。

### 样例 4

见选手目录下的 `tree/tree4.in` 与 `tree/tree4.ans`。

该样例满足测试点 $11, 12$ 的约束条件。

### 样例 5

见选手目录下的 `tree/tree5.in` 与 `tree/tree5.ans`。

该样例满足测试点 $17 \sim 20$ 的约束条件。

### 样例 6

见选手目录下的 `tree/tree6.in` 与 `tree/tree6.ans`。

该样例满足测试点 $24, 25$ 的约束条件。

### 数据范围

对于所有测试数据，保证：
- $1 \leq n \leq 2 \times 10^5$；
- 对于所有 $1 \leq i \leq 2n - 1$，均有 $i < l_i, r_i \leq 4n - 1$，且所有的 $l_i, r_i$ 互不相同；
- 对于所有 $1 \leq i \leq n$，均有 $2n \leq a_i, b_i \leq 4n - 1$，且所有的 $a_i, b_i$ 互不相同；
- 在每次操作后，存在至少一个优美的 DFS 序。

| 测试点编号 | $n \leq$ | 特殊性质 |
|:----------:|:--------:|:--------:|
| $1, 2$       | $10$       | 无       |
| $3 \sim 5$      | $10^2$   | A        |
| $6 \sim 10$     | $10^2$   | 无       |
| $11, 12$     | $10^3$   | A        |
| $13, 14$     | $10^3$   | 无       |
| $15, 16$     | $5 \times 10^4$ | AB      |
| $17 \sim 20$    | $5 \times 10^4$ | B       |
| $21, 22$     | $5 \times 10^4$ | 无       |
| $23$         | $2 \times 10^5$ | A       |
| $24, 25$     | $2 \times 10^5$ | 无       |

特殊性质 A：保证每次操作选择的两个叶子结点位于结点 1 的不同子树内。

特殊性质 B：保证存在非负整数 $m$ 满足 $n = 2^m$，且对于所有 $1 \leq i \leq 2n - 1$，均有 $l_i = 2i, r_i = 2i + 1$。

附加文件来自于 [QOJ](https://qoj.ac/contest/2315/problem/13081)。


---

---
title: "[NOI2025] 集合"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P13275
tag: ['2025', 'NOI', '容斥原理', '快速沃尔什变换 FWT', '集合幂级数，子集卷积']
---
# [NOI2025] 集合
## 题目背景

set.cpp / 2 s / 512 MiB
## 题目描述

小 X 有 $2^n$ 个数，编号为 $0$ 到 $2^n - 1$，第 $i$ ($0 \leq i < 2^n$) 个数为 $a_i$。

对于 $S \subseteq \{0, 1, \ldots, 2^n - 1\}$，定义 $f(S)$ 为集合 $S$ 中 **所有数的二进制按位与**。特别地，若 $S$ 为空集，则 $f(S) = 2^n - 1$。

定义两个 $\{0, 1, \ldots, 2^n - 1\}$ 的子集 $P, Q$（可以为空）构成的有序对 $(P, Q)$ 是 **特别的** 当且仅当 $P \cap Q = \varnothing$ 且 $f(P) = f(Q)$。定义有序对 $(P, Q)$ 的 **权值** 为 **编号** 包含在 $P \cup Q$ 内的所有数的乘积，即 $\prod_{i \in P \cup Q} a_i$。特别地，若 $P \cup Q = \varnothing$，则有序对 $(P, Q)$ 的权值为 $1$。

小 X 想要知道所有特别的有序对的权值之和，请你帮助他求出这个值。由于答案可能较大，你只需要求出答案对 $998,244,353$ 取模后的结果。

## 输入格式

**本题包含多组测试数据。**

输入的第一行包含两个非负整数 $c, t$，分别表示测试点编号与测试数据组数。$c = 0$ 表示该测试点为样例。

接下来依次输入每组测试数据，对于每组测试数据：

第一行包含一个正整数 $n$，表示有 $2^n$ 个数。

第二行包含 $2^n$ 个非负整数 $a_0, \ldots, a_{2^n - 1}$。
## 输出格式

对于每组测试数据，输出一行一个整数，表示所有特别的有序对的权值之和对 $998,244,353$ 取模后的结果。

## 样例

### 样例输入 #1
```
0 2
2
1 2 3 4
3
1 1 1 1 1 1 1 1
```
### 样例输出 #1
```
117
2091
```
## 提示

**【样例 2】**

见选手目录下的 `set/set2.in` 与 `set/set2.ans`。

该样例满足测试点 2 的约束条件。

**【样例 3】**

见选手目录下的 `set/set3.in` 与 `set/set3.ans`。

该样例满足测试点 3 的约束条件。

**【样例 4】**

见选手目录下的 `set/set4.in` 与 `set/set4.ans`。

该样例满足测试点 9 的约束条件。

**【数据范围】**

对于所有测试数据，保证：
- $1 \leq t \leq 3$;
- $2 \leq n \leq 20$;
- 对于所有 $0 \leq i < 2^n$，均有 $0 \leq a_i < 998,244,353$。

|  测试点编号  | $n \leq$ | 特殊性质 |
| :----------: | :------: | :------: |
|     $1$      |   $4$    |    B     |
|     $2$      |   $4$    |    无    |
|     $3$      |   $8$    |    B     |
|     $4$      |   $8$    |    无    |
|     $5$      |   $10$   |    B     |
|     $6$      |   $10$   |    无    |
|    $7, 8$    |   $12$   |    B     |
|     $9$      |   $12$   |    无    |
| $10 \sim 12$ |   $16$   |    B     |
|   $13, 14$   |   $16$   |    无    |
|   $15, 16$   |   $20$   |    AB    |
|   $17, 18$   |   $20$   |    A     |
| $19 \sim 21$ |   $20$   |    B     |
| $22 \sim 25$ |   $20$   |    无    |

特殊性质 A: 保证至多存在 24 个 $i$ 满足 $a_i \neq 0$。

特殊性质 B: 保证对于所有 $0 \leq i < 2^n$，均有 $a_i \neq 998,244,352$。

附加文件来自于 [QOJ](https://qoj.ac/contest/2316/problem/13083)。


---

---
title: "[NOI2025] 绝对防御"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P13276
tag: ['2025', 'NOI']
---
# [NOI2025] 绝对防御
## 题目背景

defense.cpp / 4 s / 1024 MiB
## 题目描述


小 Q 在与电脑玩一款名为“绝对防御”的回合制卡牌游戏。

小 Q 有一个大小为 $n$ 的牌堆，包含两种牌：攻击牌与防御牌。游戏开始时，小 Q 会从**牌堆顶**抽取 $k \ (1 \leq k \leq n)$ 张牌作为初始手牌，接下来他会与电脑进行若干轮对战。

每轮对战开始时，小 Q 从牌堆顶抽取 $2$ 张牌。特别地，若牌堆只剩余 $1$ 张牌，则小 Q 只抽取 $1$ 张。一轮对战分为两个**回合**：

- 第一回合：小 Q 为攻击方，电脑为防御方；
- 第二回合：小 Q 为防御方，电脑为攻击方。

在每**回合**中，攻击方**必须**从手牌中选择一张**攻击牌**进行攻击，防御方**必须**从手牌打出一张**防御牌**进行防御。无法按要求出牌者立即判负。

电脑的攻击牌与防御牌都是无限的，即电脑总能打出对应牌。为平衡电脑的实力，小 Q 可以使用一种特殊技能：当小 Q 为**防御方**时，他可以从手牌打出一张**攻击牌**进行防御。该技能每 $3$ 轮**对战**才能使用一次，即在某轮使用技能后，接下来的 $2$ 轮对战中不能使用该技能。

在给定规则下，小 Q 的获胜目标为在电脑猛烈攻击中幸存，即在某轮对战结束后，牌堆被抽空。特别地，若游戏开始时牌堆已被抽空，则小 Q 直接达成获胜目标。小 Q 想知道最小的初始抽牌数 $k$，使得他能达成胜利目标。

小 Q 觉得这个问题过于简单，因此他增加了 $q$ 次修改操作。第 $i \ (1 \leq i \leq q)$ 次修改操作给定一个正整数 $x_i$，改变牌堆顶到牌堆底的第 $x_i$ 张牌的类型，即将攻击牌变为防御牌，将防御牌变为攻击牌。你需要对初始牌堆及每次修改后的牌堆，求出最小的小 Q 初始抽牌数 $k$，使得小 Q 能达成胜利目标。

## 输入格式



**本题包含多组测试数据**。

输入的第一行包含两个非负整数 $c,t$，分别表示测试点编号与测试数据组数。$c = 0$ 表示测试点为样例。

接下来依次输入每组测试数据，对于每组测试数据：

第一行包含两个非负整数 $n, q$，分别表示牌堆大小与修改次数。

第二行包含一个长度为 $n$ 的字符串 $s_1 s_2 \ldots s_n$，分别表示从牌堆顶到底的每张牌，

其中 $s_i = 0$ 表示第 $i$ 张牌为攻击牌，$s_i = 1$ 表示第 $i$ 张牌为防御牌。

第 $i + 2 \ (1 \leq i \leq q)$ 行包含一个正整数 $x_i$，表示第 $i$ 次修改的牌为从牌堆顶到牌堆底的第 $x_i$ 张牌。

## 输出格式


对于每组测试数据，设初始时的答案为 $k_0$，第 $i$ ($1 \leq i \leq q$) 次修改后的答案为 $k_i$，输出一行 $q+1$ 个正整数 $k_0,k_1,\ldots,k_q$，表示初始时及每次修改后的最小抽牌数，使得小 Q 能达成获胜目标。

## 样例

### 样例输入 #1
```
0 3
5 1
01010
4
7 0
0001000
10 0
0001010000
```
### 样例输出 #1
```
1 1
3
2
```
## 提示



#### 【样例 1 解释】

该样例共包含三组测试数据。

对于第一组测试数据：

- 初始时，牌堆为 $01010$。若初始抽牌数为 $1$，小 Q 的一种可能的出牌方式为：
  - 初始时手牌为 $\{0\}$;
  - 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0\}$;
  - 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0\}$，此时牌堆被抽空。

由于初始至少需要抽取一张牌，所以最小初始抽牌数为 $1$，故 $k_0=1$。
- 第一次修改后，牌堆变为 $01000$。若初始抽牌数为 $1$，小 Q 的一种可能的出牌方式为：
  - 初始时手牌为 $\{0\}$;
  - 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0\}$;
  - 从堆顶抽取两张牌，打出一张攻击牌，使用特殊技能再次打出一张攻击牌进行防御，手牌变为 $\{0\}$，此时牌堆被抽空。
  
由于初始至少需要抽取一张牌，所以最小初始抽牌数为 1，故 $k_1=1$。

对于第二组测试数据：

若初始抽牌数为 $3$，小 Q 的一种可能的出牌方式为：
- 初始时手牌为 $\{0,0,0\}$;
- 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0,0,0\}$;
- 从堆顶抽取两张牌，打出一张攻击牌，使用特殊技能再次打出一张攻击牌进行防御，手牌变为 $\{0,0,0\}$，此时牌堆被抽空。
可以证明，不存在比 $3$ 更小的初始抽牌数能够抽空牌堆，故答案为 $3$。

对于第三组测试数据：

若初始抽牌数为 $2$，小 Q 的一种可能的出牌方式为：
- 初始时手牌为 $\{0,0\}$;
- 从堆顶抽取两张牌，打出一张攻击牌，使用特殊技能再次打出一张攻击牌进行防御，手牌变为 $\{0,1\}$;
- 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0,1\}$;
- 从堆顶抽取两张牌，打出一张攻击牌，一张防御牌，手牌变为 $\{0,0\}$，此时牌堆被抽空。
可以证明，不存在比 $2$ 更小的初始抽牌数能够抽空牌堆，故答案为 $2$。


【样例 2】

见选手目录下的 `defense/defense2.in` 与 `defense/defense2.ans`。

该样例满足测试点 2 的约束条件。

【样例 3】

见选手目录下的 `defense/defense3.in` 与 `defense/defense3.ans`。

该样例满足测试点 5 ~ 7 的约束条件。

【样例 4】

见选手目录下的 `defense/defense4.in` 与 `defense/defense4.ans`。

该样例满足测试点 9,10 的约束条件。

【样例 5】

见选手目录下的 `defense/defense5.in` 与 `defense/defense5.ans`。

该样例满足测试点 11 的约束条件。

【样例 6】

见选手目录下的 `defense/defense6.in` 与 `defense/defense6.ans`。

该样例满足测试点 12 ~ 14 的约束条件。

 
### 数据范围

设 $N, Q$ 分别为单个测试点内所有测试数据的 $n, q$ 的和。对于所有测试数据，保证：

- $1 \leq t \leq 10^5$；
- $1 \leq n \leq 2 \times 10^5$，$N \leq 5 \times 10^5$；
- $0 \leq q \leq 2 \times 10^5$，$Q \leq 5 \times 10^5$；
- 对于所有 $1 \leq i \leq n$，均有 $s_i \in \{ 0, 1 \}$；
- 对于所有 $1 \leq i \leq q$，均有 $1 \leq k_i < n$。


| 测试点编号 | $n \leq$ | $q \leq$ | $N, Q \leq$ | 特殊性质 |
|------------|----------|----------|-------------|----------|
| $1 $         | $20      $ | $20      $ | $60      $    | 无       |
| $2 $         | $10^2    $ | $10^2    $ | $10^3    $    | 无       |
| $3 $         | $3000    $ | $3000    $ | $10^4    $    | 无       |
| $4 $         | $3000    $ | $3000    $ | $10^4    $    | 无       |
| $5 $         | $10^5    $ | $0       $ | $3 \times 10^5$     | 无       |
| $6 $         | $10^5    $ | $0       $ | $3 \times 10^5$     | 无       |
| $7 $         | $10^5    $ | $0       $ | $3 \times 10^5$     | 无       |
| $8 $         | $2 \times 10^5$ | $200     $ | $5 \times 10^5$     | 无       |
| $9 $         | $10^5    $ | $10^5    $ | $3 \times 10^5$     | $\mathrm{A B }$    |
| $10$         | $10^5    $ | $10^5    $ | $3 \times 10^5$     | $\mathrm{A B }$    |
| $11$         | $10^5    $ | $10^5    $ | $3 \times 10^5$     | $\mathrm{A C }$    |
| $12$         | $10^5    $ | $10^5    $ | $3 \times 10^5$     | $\mathrm{A D }$    |
| $13$         | $10^5    $ | $10^5    $ | $3 \times 10^5$     | $\mathrm{A D }$    |
| $14$         | $10^5    $ | $10^5    $ | $3 \times 10^5$     | $\mathrm{A D }$    |
| $15$         | $10^5    $ | $10^5    $ | $3 \times 10^5$     | $\mathrm{E   }$    |
| $16$         | $10^5    $ | $10^5    $ | $3 \times 10^5$     | $\mathrm{E   }$    |
| $17$         | $10^5    $ | $10^5    $ | $3 \times 10^5$     | $\mathrm{E   }$    |
| $18$         | $2 \times 10^5$ | $2 \times 10^5$ | $5 \times 10^5$     | 无       |
| $19$         | $2 \times 10^5$ | $2 \times 10^5$ | $5 \times 10^5$     | 无       |
| $20$         | $2 \times 10^5$ | $2 \times 10^5$ | $5 \times 10^5$     | 无       |

- 特殊性质 $\text{A}$：保证对于所有 $1 \leq i \leq n$，$s_i$ 均在 $\{0,1\}$ 中**独立均匀随机**生成。
- 特殊性质 $\text{B}$：保证所有的 $x_i$ 互不相同，且对于所有 $1 \leq i \leq q$，均有 $s_{x_i} = 1$。
- 特殊性质 $\text{C}$：保证所有的 $x_i$ 互不相同，且对于所有 $1 \leq i \leq q$，均有 $s_{x_i} = 0$。
- 特殊性质 $\text{D}$：保证对于所有 $1 \leq i \leq q$，$x_i$ 均在 $[1, n]$ 中**独立均匀随机**生成。
- 特殊性质 $\text{E}$：保证对于所有 $0 \leq i < q$，均有 $1 \leq k_i \leq 45$。

附加文件来自于 [QOJ](https://qoj.ac/contest/2316/problem/13083)。


---

---
title: "[NOI2013] 小 Q 的修炼"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1335
tag: ['模拟', '字符串', '2013', 'NOI', '提交答案', 'Special Judge', '枚举']
---
# [NOI2013] 小 Q 的修炼
## 题目描述

小 Q 最近发现了一款新游戏，游戏的目标是从一个新手修炼成为武功高强的大侠。面对错综复杂的游戏世界，小 Q 要对他面临的每件事情做出谨慎的选择。例如，是否参加一个陌生人邀请的比武；同意或是拒绝用宝剑交换他人的武功秘籍......而小 Q 做出的每一个选择都有可能影响到他以后的发展：面对一个高手，若主动与之比武，很可能会损失惨重；但若不去比武，也许今后就再也见不到这个高手了。

对着这个游戏，小 Q 玩了很多次仍然玩不出他想要的结局，于是他费尽千辛万苦找到了游戏的剧本。令人惊讶的是,游戏的剧本并不像我们平时见到的剧本，反而很像代码。这个剧本是这样描述的：
- 量：有 $2$ 种量，常数和变量。
- 常数：一个整数。
- 变量：初始值为 $0$ 的可变整数，不同变量用不同正整数编号区分。
- 事件：整个剧本由若干个事件构成。所有的事件按照给定的顺序从 $1$ 开始依次编号。事件共有 $3$ 种：普通事件、选择跳转和条件跳转。
- 执行位置：一个整数，表示接下来将会执行的事件编号，如果不存在这个编号的事件则停止，即游戏到了一个结局。最初的时候执行位置为 $1$。
- 普通事件：一个变量增加或减少一个量的值。之后执行位置增加 $1$。
- 选择跳转：两个整数。执行到这里时玩家需要在这两个整数中选择一个，之后执行位置将被修改为这个整数。
- 条件跳转：两个量和两个整数。执行到这里时，若第一个量小于第二个量，则执行位置将被修改为第一个整数，否则将被修改为第二个整数。

小 Q 认为，整个游戏是希望一个叫做「成就值」的变量（编号为 $1$）最大。
## 输入格式

该题为提交答案型试题，所有输入数据 `train1.in`~`train10.in` 已在附加文件中。

输入的第一行包含两个正整数 $n, m$，表示事件的个数和变量的个数。

接下来有 $n$ 行，每行描述一个事件。这些事件按照给出的顺序依次编号为 $1$ 到 $n$。

描述量和事件的格式如下（格式中 `#`表示空格）


| 类型 | 格式 | 例子 |
|:-:|:-:|:-:|
| 常数 | `c#整数` | `c -2` |
| 变量 | `v#正整数` | `v 5` |
| 普通事件 | `变量#+#量` | `v 1 + c 1` |
| 普通事件 | `变量#-#量` | `v 2 - c 2` |
| 选择跳转 | `s#整数 1#整数 2` | `s 10 20` |
| 条件跳转 | `i#量 1#量 2#整数 1#整数 2` | `i c 99 v 2 0 1` |

## 输出格式

针对给定的 $10$ 个输入文件 `train1.in`~`train10.in`，你需要分别提交你的输出文件 `train1.out`~`train10.out`。

每个文件需要输出若干行，每行输出一个字符 `1` 或 `2`，表示执行过程中遇到的每个选择跳转所作的选择。输出的行数需要严格等于此次游戏执行过程中遇到的选择跳转的个数。
## 样例

### 样例输入 #1
```
11 2
v 2 + c 19
i v 2 c 3 7 3
s 4 7
v 1 + c 13
v 2 - c 3
i c 0 c 1 2 0
i v 2 c 5 12 8
s 9 12
v 1 + c 23
v 2 - c 5
i c 0 c 1 7 0

```
### 样例输出 #1
```
1
1
1
2
1
1

```
## 提示

### 评分标准

对于每组数据，我们采用如下方式评分：
- 如果你的输出不合法,得 $0$ 分。
- 如果你的输出执行了超过 $10^6$ 行剧本,得 $0$ 分。
- 如果你的输出能让剧本正常结束，得 $1$ 分。
- 如果你的输出能让剧本正常结束，且结束时成就值为正数，得 $2$ 分。

我们设置了 $8$ 个评分参数 $a_3 , a_4 , \ldots , a_{10}$。

如果你的输出能让剧本正常结束，且结束时成就值不小于 $a_s$，得 $s$ 分。

如果以上条目有多项满足，则取满足条件中的最高得分。

### 如何测试你的输出

我们提供 `checker` 这个工具来测试你的输出文件是否是可接受的。使用这个工具的方法是，首先进入终端，在终端中运行下面的命令进入本题的文件夹：

`cd train`

然后运行：

`./checker <case_no>`

其中 `case_no` 是测试数据的编号。例如

`./checker 3`

将测试 `train3.out` 是否可以接受。

在你调用这个程序后，`checker` 将根据你给出的输出文件给出测试的结果，其中包括：
- 非法退出：未知错误。
- `Input/Output file does not exist.`：输入/输出文件不存在。
- `Output invalid.`：输出文件有误,此时可能包含具体错误信息。
- `Correct! Your answer is x.`：输出可接受,最后的成就值为 $x$。

### 更多功能
`checker` 还可以检查任意输入输出文件的测试结果，方法是在终端中运行：

`cd train`

`./checker <input_file_name> <output_file_name>`

其中 `input_file_name` 和 `output_file_name` 分别是输入输出文件的名称。例如

`./checker train3.in train3.out`

将测试 `train3.out` 是否可以接受。

使用 `-w` 可以输出每步运行的结果。用法是

`./checker -w <input_file_name> <output_file_name>`

或者

`./checker -w <case_no>`

例如

`./checker -w train3.in train3.out`

### 特别提示

如果选手使用自己生成输入文件进行调试，有可能因规模过大造成 checker 出错。若发生这类情况，请尝试较小规模的数据。


---

---
title: "[NOI2003] 智破连环阵"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1526
tag: ['搜索', '2003', 'NOI', '剪枝']
---
# [NOI2003] 智破连环阵
## 题目描述

B 国在耗资百亿元之后终于研究出了新式武器——连环阵（Zenith Protected Linked Hybrid Zone）。传说中，连环阵是一种永不停滞的自发性智能武器。但经过 A 国间谍的侦察发现，连环阵其实是由 $M$ 个编号为 $1, 2,\ldots, M$ 的独立武器组成的。最初，$1$ 号武器发挥着攻击作用，其他武器都处在无敌自卫状态。以后，一旦第 $i$（$1\leq i< M$）号武器被消灭，$1$ 秒种以后第 $i+1$ 号武器就自动从无敌自卫状态变成攻击状态。当第 $M$ 号武器被消灭以后，这个造价昂贵的连环阵就被摧毁了。

为了彻底打击 B 国科学家，A 国军事部长打算用最廉价的武器——炸弹来消灭连环阵。经过长时间的精密探测，A 国科学家们掌握了连环阵中 M 个武器的平面坐标，然后确定了 $n$ 个炸弹的平面坐标并且安放了炸弹。每个炸弹持续爆炸时间为 $5$ 分钟。在引爆时间内，每枚炸弹都可以在瞬间消灭离它平面距离不超过 $k$ 的、处在攻击状态的 B 国武器。和连环阵类似，最初 $a_1$ 号炸弹持续引爆 $5$ 分钟时间，然后 $a_2$ 号炸弹持续引爆 $5$ 分钟时间，接着 $a_3$ 号炸弹引爆$\ldots$以此类推，直到连环阵被摧毁。

显然，不同的序列 $a_1, a_2, a_3\ldots$ 消灭连环阵的效果也不同。好的序列可以在仅使用较少炸弹的情况下就将连环阵摧毁；坏的序列可能在使用完所有炸弹后仍无法将连环阵摧毁。现在，请你决定一个最优序列 $a_1, a_2, a_3\ldots$ 使得在第 $a_x$ 号炸弹引爆的时间内连环阵被摧毁。这里的 $x$ 应当尽量小。
## 输入格式

第一行包含三个整数：$M$、$n$ 和 $k$，分别表示 B 国连环阵由 M 个武器组成，A 国有 $n$ 个炸弹可以使用，炸弹攻击范围为 $k$。以下 $M$ 行，每行由一对整数 $x_i, y_i$ 组成，表示第 $i$ 号武器的平面坐标。再接下来 $n$ 行，每行由一对整数 $u_i, v_i$ 组成，表示第 $i$ 号炸弹的平面坐标。输入数据保证随机、无误、并且必然有解。

## 输出格式

一行包含一个整数 $x$，表示实际使用的炸弹数。

## 样例

### 样例输入 #1
```
4 3 6
0 6
6 6
6 0
0 0
1 5
0 3
1 1

```
### 样例输出 #1
```
2

```
## 提示

对于 $100\%$ 的数据，$1\leq M, n\leq 100$，$1\leq k\leq 1000$，$0\leq x_i, y_i\leq 10000$，$0\leq u_i, v_i\leq 10000$。

各个测试点 $2$ 秒。



---

---
title: "[NOI2016] 循环之美"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1587
tag: ['数学', '2016', 'NOI', 'O2优化', '莫比乌斯反演']
---
# [NOI2016] 循环之美
## 题目描述

牛牛是一个热爱算法设计的高中生。在他设计的算法中，常常会使用带小数的数进行计算。牛牛认为，如果在 $k$ 进制下，一个数的小数部分是纯循环的，那么它就是美的。现在，牛牛想知道：对于已知的十进制数 $n$ 和 $m$，在 $k$ 进制下，有多少个数值上互不相等的纯循环小数，可以用分数 $\frac xy$ 表示,其中 $1≤x≤n,1≤y≤m$，且 $x,y$ 是整数。一个数是纯循环的，当且仅当其可以写成以下形式：

$$a.\dot{c_1} c_2 c_3 \dots c_{p - 1} \dot{c_p}$$

其中，$a$ 是一个整数，$p≥1$；对于 $1≤i≤p$，$c_i$ 是 $k$ 进制下的一位数字。

例如，在十进制下，$0.45454545……=0.\dot {4} \dot {5}$ 是纯循环的，它可以用 $\frac {5}{11}$、$\frac{10}{22}$ 等分数表示；在十进制下，$0.1666666……=0.1\dot6$ 则不是纯循环的，它可以用 $\frac 16$ 等分数表示。需要特别注意的是，我们认为一个整数是纯循环的，因为它的小数部分可以表示成 $0$ 的循环或是 $k-1$ 的循环；而一个小数部分非 $0$ 的有限小数不是纯循环的。
## 输入格式

只有一行，包含三个十进制数 $N,M,K$ 意义如题所述。



## 输出格式

一行一个整数，表示满足条件的美的数的个数。

## 样例

### 样例输入 #1
```
2 6 10
```
### 样例输出 #1
```
4
```
## 提示

### 样例解释

满足条件的数分别是：

$\frac 11=1.0000\ldots$

$\frac 13=0.3333\ldots$

$\frac 21=2.0000\ldots$

$\frac 23=0.6666\ldots$

$\frac 11$ 和 $\frac 22$ 虽然都是纯循环小数，但因为它们相等，因此只计数一次；同样，$\frac 13$ 和 $\frac 26$ 也只计数一次。

### 数据范围

对于所有的测试点，保证 $1\leq n\leq 10^9$，$1\leq m \leq 10^9$，$2\leq k \leq 2\times 10^3 $。

对于每个测试点，有以下约束（其中留空的表示没有特殊的约束）：

| 测试点编号 |         $n$         |     $m$     |     $k$     |
| :--------: | :-----------------: | :---------: | :---------: |
|    $1$     |      $\leq 10$      |  $\leq 20$  |    $=2$     |
|    $2$     |     $\leq 100$      | $\leq 10^4$ |    $=2$     |
|    $3$     |     $\leq 10^3$     |             |    $=2$     |
|    $4$     |     $\leq 10^4$     |             |    $=2$     |
|    $5$     |      $\leq 10$      |  $\leq 20$  |    $=3$     |
|    $6$     |     $\leq 100$      | $\leq 10^4$ |    $=3$     |
|    $7$     |     $\leq 10^3$     |             |    $=3$     |
|    $8$     |     $\leq 10^4$     |             |    $=3$     |
|    $9$     |      $\leq 10$      |  $\leq 20$  | $\leq 100$  |
|    $10$    |     $\leq 100$      | $\leq 10^4$ | $\leq 100$  |
|    $11$    |     $\leq 10^3$     |             | $\leq 10^3$ |
|    $12$    |     $\leq 10^4$     |             |             |
|    $13$    |     $\leq 10^5$     | $\leq 10^8$ | $\leq 100$  |
|    $14$    | $\leq 2\times 10^5$ |             | $\leq 10^3$ |
|    $15$    | $\leq 5\times10^5$  |             |             |
|    $16$    |     $\leq 10^6$     | $\leq 10^8$ | $\leq 100$  |
|    $17$    | $\leq 2\times 10^6$ |             | $\leq 10^3$ |
|    $18$    | $\leq 5\times 10^6$ |             |             |
|    $19$    |     $\leq 10^7$     | $\leq 10^8$ |    $100$    |
|    $20$    | $\leq 2\times10^7$  |             | $\leq 10^3$ |
|    $21$    | $\leq 2\times10^7$  |             |             |
|    $22$    |     $\leq 10^8$     | $\leq 10^8$ |             |
|    $23$    |     $\leq 10^8$     | $\leq 10^8$ |             |
|  $24,25$   |                     |             |             |

 
### 提示

这部分将提供一个将分数化为对应的小数的方法，如果你已经熟悉这个方法，你不必阅读本提示。

分数可以通过除法，用分子除以分母化为对应的小数。有些分数在除法过程中无法除尽,这样的分数在不断进行的除法过程中余数一定会重复出现。从商数的个位所对应的余数起，设第一次重复出现的余数前两次出现的位置所对应的商数位分别是小数点后第 $a$ 位和小数点后第 $b$ 位（特殊地：如果其中一个对应的商数位是个位，则认为 $a=0$；不妨设 $a<b$），则其循环部分可以用小数点后第 $a+1$ 位到小数点后第 $b$ 位的循环来表示。

例如：在十进制下，将 $\frac 5{11}$ 转化为小数时，个位开始的商数依次为 $4,5,4,\ldots$，对应的余数分别为 $6,5,6,\ldots$。余数第一次重复出现的位置是个位和小数点后第 $2$ 位,那么 $a=0,b=2$。

$a=0,b=2$ 即其循环部分可以用小数点第 $1$ 位到第 $3$ 位来表示。表示为：$\frac 5{11}=0.45454545\ldots=0.\dot4\dot5$。

在十进制下，将 $\frac 16$ 转化为小数时,个位开始的商数依次为 $1,6,6,\ldots$，对应的余数分别为 $4,4,4,\ldots$。余数第一次重复出现的位置是小数点后第 $1$ 位和小数点后第 $2$ 位,即其循环部分可以用小数点后第 $2$ 位来表示。表示为：$\frac 16=0.1666……=0.1\dot6$。

需要注意的是：商数重复出现并不代表进入了循环节。


---

---
title: "[NOI2016] 国王饮水记"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1721
tag: ['动态规划 DP', '2016', 'NOI', 'Special Judge', '斜率优化']
---
# [NOI2016] 国王饮水记
## 题目描述

跳蚤国有 $n$ 个城市，伟大的跳蚤国王居住在跳蚤国首都中，即 $1$ 号城市中。

跳蚤国最大的问题就是饮水问题，由于首都中居住的跳蚤实在太多，跳蚤国王又体恤地将分配给他的水也给跳蚤国居民饮用，这导致跳蚤国王也经常喝不上水。

于是，跳蚤国在每个城市都修建了一个圆柱形水箱，这些水箱完全相同且足够高。一个雨天后，第 $i$ 个城市收集到了高度为 $h_i$ 的水。由于地理和天气因素的影响，任何两个不同城市收集到的水高度互不相同。

跳蚤国王也请来蚂蚁工匠帮忙，建立了一个庞大的地下连通系统。跳蚤国王每次使用地下连通系统时，可以指定任意多的城市，将这些城市的水箱用地下连通系统连接起来足够长的时间之后，再将地下连通系统关闭。由连通器原理，这些城市的水箱中的水在这次操作后会到达同一高度，并且这一高度等于指定的各水箱高度的平均值。

由于地下连通系统的复杂性，跳蚤国王至多只能使用 $k$ 次地下连通系统。

跳蚤国王请你告诉他，首都 $1$ 号城市水箱中的水位最高能有多高？
## 输入格式

输入的第一行包含三个正整数 $n,k,p$ 分别表示跳蚤国中城市的数量，跳蚤国王能使用地下连通系统的最多次数，以及你输出的答案要求的精度。$p$ 的含义将在输出格式中解释。

接下来一行包含 $n$ 个正整数，描述城市的水箱在雨后的水位。其中第 $i$ 个正整数 $h_i$ 表示第 $i$ 个城市的水箱的水位。保证 $h_i$ 互不相同，$1 \leq h_i \leq 10^5$。
## 输出格式

仅一行一个实数，表示 $1$ 号城市的水箱中的最高水位。

这个实数只可以包含非负整数部分、小数点和小数部分。其中非负整数部分为必需部分，不加正负号。若有小数部分，则非负整数部分与小数部分之间以一个小数点隔开。若无小数部分，则不加小数点。

你输出的实数在小数点后不能超过 $2p$ 位，建议保留至少 $p$ 位。数据保证参考答案与真实答案的绝对误差小于 $10^{-2p}$。

你的输出被判定为正确当且仅当你的输出与参考答案的绝对误差小于 $10^{-p}$。

如果你的输出与参考答案的绝对误差不小于 $10^{-p}$ 但小于 $10^{-5}$，你可以获得该测试点 $40\%$ 的分数。
## 样例

### 样例输入 #1
```
3 1 3
1 4 3
```
### 样例输出 #1
```
2.666667
```
### 样例输入 #2
```
3 2 3
1 4 3
```
### 样例输出 #2
```
3.000000
```
## 提示

### 样例解释 1

由于至多使用一次地下连通系统，有以下五种方案：
 
1. 不使用地下连通系统：此时 $1$ 号城市的水箱水位为 $1$。 
2. 使用一次连通系统，连通 $1$、$2$ 号：此时 $1$ 号城市的水箱水位为 $5/2$。 
3. 使用一次连通系统，连通 $1$、$3$ 号：此时 $1$ 号城市的水箱水位为 $2$。 
4. 使用一次连通系统，连通 $2$、$3$ 号：此时 $1$ 号城市的水箱水位为 $1$。 
5. 使用一次连通系统，连通 $1$、$2$、$3$ 号：此时 $1$ 号城市的水箱水位为 $8/3$。

### 样例解释 2

此时最优方案为使用两次连通系统，第一次连通 $1,3$ 号，第二次连通 $1,2$ 号。

### 样例 3

详见附加文件。

### 提示

为保证答案精度，我们一般需要尽可能地在运算过程中保留超过 $p$ 位小数。我们可以证明，在各个子任务的参考算法中都能保证，在任何时候始终保留 $\frac{6}{5}p$ 位小数时，对任何输入得到的输出，与参考答案的绝对误差都小于 $10^{-p}$。

为了方便选手处理高精度小数，我们提供了定点高精度小数类。选手可以根据自己的需要参考与使用该类，也可以不使用该类。其具体的使用方法请参考下发的文档 `decimal.pdf`（见附件）。

### 数据范围

| 测试点编号 | $n$ | $k$ | $p$ |
|-|-|-|-|
| 1 | $\le 2$ | $\le 5$ | $=5$ |
| $2$ | $\le 4$ | $\le 5$ | $=5$ |
| $3$ | $\le 4$ | $\le 5$ | $=5$ |
| 4 | $\le 10$ | $=1$ | $=5$ |
| $5$ | $\le 10$ | $=10^9$ | $=5$ |
| $6$ | $\le 10$ | $\le 10$ | $=5$ |
| $7$ | $\le 10$ | $\le 10$ | $=5$ |
| $8$ | $\le 100$ | $=1$ | $=5$ |
| $9$ | $\le 100$ | $=10^9$ | $=40$ |
| $10$ | $\le 100$ | $\le 10^9$ | $=40$ |
| $11$ | $\le 100$ | $\le 10^9$ | $=40$ |
| $12$ | $\le 100$ | $\le 10^9$ | $=40$ |
| $13$ | $\le 250$ | $\le 10^9$ | $=100$ |
| $14$ | $\le 500$ | $\le 10^9$ | $=200$ |
| $15$ | $\le 700$ | $\le 10^9$ | $=300$ |
| $16$ | $\le 700$ | $\le 10^9$ | $=300$ |
| $17$ | $\le 700$ | $\le 10^9$ | $=300$ |
| $18$ | $\le 2500$ | $\le 10^9$ | $=1000$ |
| $19$ | $\le 4000$ | $\le 10^9$ | $=1500$ |
| $20$ | $\le 8000$ | $\le 10^9$ | $=3000$ |


---

---
title: "[NOI2016] 旷野大计算"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1737
tag: ['数学', '2016', 'NOI', '提交答案', 'Special Judge']
---
# [NOI2016] 旷野大计算
## 题目背景

**提示：若是使用“提交代码”的方式进行提交，在评测时会给程序输入一个数字（1, 2, 3, ..., 10）表示测试点编号，请在程序中直接输出对应测试点的答案。**

## 题目描述

随着人类计算机技术的发展，计算机的能力不断提升，让跳蚤国王非常羡慕。

终于有一天，跳蚤国王发布政令：大力发展跳蚤国的计算机产业！然而，跳蚤国尚未进行工业革命，无法制造出电子计算机所需的元器件。但是跳蚤国王想出了一个绝妙的想法：把每只跳蚤作为一个计算节点，每只跳蚤只完成一个特定的小任务。

跳蚤国王带领 $n$ 只跳蚤来到了一片旷野上，把跳蚤作为计算节点在旷野上排列好，并编号为 $1$ 到 $n$。每个计算节点会把某几个（也有可能是 $0$ 个）计算节点的结果作为输入，计算得到输出。除此之外，跳蚤国王还有一个巨型的终端，可以从终端输入和输出数据，这台终端和所有计算节点组成了一台计算机。

记第 $t$ 个计算节点的输出为 $x_t$，该节点的操作可分为以下几种类型：

| 名称 | 操作符（类型） | 操作数 | 计算结果 |
|-|-|-|-|
| 输入节点 | `I` | 无 | 从终端读入一个实数作为 $x_t$ |
| 输出节点 | `O` | $i$ | $x_t = x_i$，并将 $x_t$ 输出到终端 |
| 加法节点 | `+` | $i,j$ | $x_t = x_i+x_j$ |
| 偏移节点 | `C` | $i,c$ | $x_t=x_i+c$ |
| 取反节点 | `-` | $i$ | $x_t=-x_i$ |
| 左移节点 | `<` | $i,k$ | $x_t=x_i\cdot 2^k$ |
| 右移节点 | `>` | $i,k$ | $x_t=x_i\cdot 2^{-k}$ |
| S 型节点 | `S` | $i$ | $x_t=s(x_i)$ |
| 比较节点 | `P` | $i,j$ | $x_t=\begin{cases}-1 &x_i<x_j\\ 0 &x_i=x_j\\1 &x_i>x_j\\\end{cases}$|
| Max 节点 | `M` | $i,j$ | $x_t=\begin{cases}x_i &x_i>x_j\\x_j &x_i \leq x_j\end{cases}$ |
| 乘法节点 | `*` | $i,j$ | $x_t=x_i \cdot x_j$ | 

其中，$s(x)$ 的定义如下：（$e$ 为自然常数,其值约为 $2.718281828459045\ldots$）

$$s\left ( x \right )=\frac{1}{1+e^{-x}}$$

$s(x)$ 的函数图像如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/fnscfgzu.png)

上述表格中的操作数 $i,j$ 均要小于当前节点的编号 $t$，这样随着跳蚤国王的一声令下，跳蚤就可以按编号从小到大的顺序，依次获得输入然后计算输出。每个跳蚤的计算能力都是有限的，他们仅可以精确到十进制小数点后 $90$ 位，超过的部分将会被四舍五入。同理，上述表格中的操作数 $c$ 的小数部分也不能超过 $90$ 位。另外，左移节点和右移节点中的操作数 $k$ 必须是非负整数，且不能超过 $10^4$。

把跳蚤排列好后，野心勃勃的跳蚤国王决心测试一下这台由跳蚤组成的计算机的计算能力，于是蝈蝈大臣给跳蚤国王献上了十个计算任务。完成每个计算任务均需要从终端获取输入，进行中间计算，再用输出节点将结果输出。具体任务说明如下：

| 编号 | 输入 | 输入限制 | 输出 |
|-|-|-|-|
| $1$ | $a,b$ | $\lvert a \rvert, \lvert b \rvert \le 10^9$，小数部分不超过 $9$ 位 | $-2a-2b$ |
| $2$ | $a$ | $\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位 | $\dfrac{1}{1+e^{17a}}$ |
| $3$ | $a$ | $\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位 | $\begin{cases}-1 & a \lt 0 \\ 0 & a = 0 \\ 1 & a \gt 0\end{cases}$ |
| $4$ | $a$ | $\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位 | $\lvert a \rvert$，即 $a$ 的绝对值 |
| $5$ | $a_1, \dots, a_{32}$ | $a_1, \dots, a_{32} \in \{0, 1\}$ | 把 $a_1, \dots, a_{32}$ 从左到右看成一个二进制整数，高位在左低位在右，输出该整数的值 |
| $6$ | $a$ | $0 \le a \lt 2^{32}$，$a$ 为整数 | 输出 $32$ 个整数，从高位到低位输出 $a$ 的二进制表示（不足 $32$ 位的在高位补 $0$） |
| $7$ | $a,b$ | $0 \le a, b \lt 2^{32}$，$a,b$ 均为整数 | $a, b$ 按位异或的结果 |
| $8$ | $a$ | $\lvert a \rvert \le 10^9$，小数部分不超过 $9$ 位 | $\dfrac{a}{10}$ |
| $9$ | $a_1, \dots, a_{16}$ | $\lvert a_1 \rvert, \dots, \lvert a_{16} \rvert \le 10^9$，小数部分不超过 $9$ 位 | 输出 $16$ 个实数，表示 $a_1, \dots, a_{16}$ 从小到大排序后的结果 |
| $10$ | $a,b,m$ | $0 \le a, b \lt 2^{32}$，$1 \le m \lt 2^{32}$，$a,b,m$ 均为整数 | $a \cdot b$ 除以 $m$ 的余数 | 

跳蚤国王发现自己没有足够的能力设计这样的计算机。于是他找到了来参加 NOI 的你。请你依次设计每个计算节点的类型及操作数，完成蝈蝈大臣给的这 10 个计算任务，且要求使用的计算节点数尽量少。
## 输入格式

所有输入数据 `nodes1.in` $\sim$ `nodes10.in`，分别对应 10 个计算任务。

每组输入数据仅包含一个整数，表示需要解决的计算任务编号。

因只供评测机内部使用，洛谷不提供本题输入数据的下载，若有需要请自行生成。
## 输出格式

输出文件为 `nodes1.out` $\sim$ `nodes10.out`，分别对应相应的输入文件。

对于每组输入数据，你需要依次输出若干行，第 $i$ 行描述第 $i$ 个计算节点。

描述每个计算节点时，首先一个字符表示该计算节点的类型，接下来若干个数按顺序表示该计算节点的内置参数。字符与数，数与数之间均用空格隔开。

输出的行数不能超过 $10^4$ 行。
## 样例

### 样例输入 #1
```
1
```
### 样例输出 #1
```
I
+ 1 1
- 2
I
+ 4 4
- 5
+ 3 6
- 7
- 8
O 9

```
## 提示

该样例输出为第一个计算任务一个可能的构造。共用了 $10$ 个计算节点，可获得 $3$ 分。

我们提供了十个评分文件 `nodes1.ans` $\sim$ `nodes10.ans`，分别对应每个计算任务。

每个评分文件共 $10$ 行，第 $i$ 行一个评分参数 $w_i$，具体意义将在下面给出。

本题中，每个测试点单独进行评分，每个测试点 $10$ 分。

如果选手的输出格式不合法或者参数不符合题目约定,则得 $0$ 分。

否则，按照以下规则判定选手的输出是否正确：

- 首先测评器会生成若干组输入数据，并将输入数据代入你构造的计算机。
- 如果在代入某一组输入数据时：你构造的计算机的计算过程中，某个计算节点的计算结果的绝对值超过 $10^{1000}$，则得 $0$ 分；
- 你构造的计算机的输出中的某个值与预期的输出值相差超过 $10^{-9}$，则认为你的输出不正确，得 $0$ 分。
- 否则，我们认为你的计算机能完成给定的计算任务，并按照以下规则得分。

对于每个测试点，我们设置了 $10$ 个评分参数 $w_1$,$w_2$,$w_3$,…,$w_9$,$w_{10}$。

假设共使用了 $n$ 个计算节点,你的分数将会由下表给出：

 | 得分 | 条件 | 得分 | 条件 |
| :----------: | :----------: | :----------: | :----------: |
| 10 | $n≤w_{10}$ | 5 | $n≤w_5$ |
| 9 | $n≤w_9$ | 4 | $n≤w_4$ |
| 8 | $n≤w_8$ | 3 | $n≤w_3$ |
| 7 | $n≤w_7$ | 2 | $n≤w_2$ |
| 6 | $n≤w_6$ | 1 | $n≤w_1$ |

若不符合表中所有条件，得 $0$ 分；若符合表中的多个条件，则取分数最高的。

除此之外，使用**比较节点、Max 节点和乘法节点**的代价是极为**昂贵**的。因此，这三种节点**每使用一种**，就会从你这个测试点的得分中**倒扣 $4$ 分**。

注意这里是按使用节点的**种类数**计算扣分，**与使用次数无关**。例如多次使用比较节点，只会扣除 $4$ 分；又如同时使用了比较节点和乘法节点，**即使各只使用了一次，也会扣除 $8$ 分**。

一个测试点至多被扣到 $0$ 分，即使分数不够扣除，也不会出现负数。


---

---
title: "[NOI2009] 描边"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1756
tag: ['计算几何', '高精度', '2009', 'NOI', '提交答案', 'Special Judge', '二分图']
---
# [NOI2009] 描边
## 题目描述

小 Z 是一位杰出的数学家。聪明的他特别喜欢研究一些数学小问题。

有一天，他在一张纸上选择了 $n$ 个点，并用铅笔将它们两两连接起来，构成 $\dfrac{n(n-1)}{2}$ 条线段。由于铅笔很细，可以认为这些线段的宽度为 $0$。

望着这些线段，小 Z 陷入了冥想中。他认为这些线段中的一部分比较重要，需要进行强调。因此小 Z 拿出了毛笔，将它们重新进行了描边。毛笔画在纸上，会形成一个半径为 $r$ 的圆。在对一条线段进行描边时，毛笔的中心（即圆心）将从线段的一个端点开始，沿着该线段描向另一个端点。下图即为在一张 $4$ 个点的图中，对其中一条线段进行描边强调后的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/h92i5d69.png)

现在，小 Z 非常想知道在描边之后纸面上共有多大面积的区域被强调，你能帮助他解答这个问题么？
## 输入格式

本题是一道提交答案型试题，所有的输入文件 `path1.in` $\sim$ `path10.in` 已在相应目录下。

输入文件请点击 [这里](http://pan.baidu.com/s/1gfeLZqz) 下载。

输入文件的第一行为一个正整数 $n$，表示选择的点的数目。

第二行至第 $n+1$ 行，其中：第 $i+1$ 行中为两个实数 $x_i,y_i$，表示点 $i$ 的坐标为 $(x_i,y_i)$。

第 $n+2$ 行为一个正整数 $m$，表示小 Z 认为比较重要的线段的条数。

第 $n+3$ 行至第 $n+m+2$ 行，每行有两个正整数 $a,b$，表示一条线段。其中 $a,b$ 两个数分别表示该线段的两个端点的编号。

第 $n+m+3$ 行中为一个实数 $r$，表示毛笔在纸上形成的圆的半径。

第 $n+m+4$ 行中为四个实数 $p_1,p_2,p_3,p_4$，即评分使用的参数。
## 输出格式

输出文件 `path*.out` 仅一行一个数，即为描边后被强调区域的总面积。
## 样例

### 样例输入 #1
```
2
1 1
1 2
1
1 2
1
0.00001 0.001 0.1 1

```
### 样例输出 #1
```
5.1415927
```
## 提示

每个测试点单独评分。

本题设有 $4$ 个评分参数 $p_1,p_2,p_3,p_4$（$p_1 \lt p_2 \lt p_3 \lt p_4$），已在输入文件中给出。

你的得分将按照如下规则给出：

- 若你的答案与标准答案相差不超过 $p_1$，则该测试点你将得到满分；
- 否则，若你的答案与标准答案相差不超过 $p_2$，则你将得到该测试点 $70\%$ 的分数；
- 否则，若你的答案与标准答案相差不超过 $p_3$，则你将得到该测试点 $40\%$ 的分数；
- 否则，若你的答案与标准答案相差不超过 $p_4$，则你将得到该测试点 $10\%$ 的分数；
- 否则，该测试点你的得分为 $0$。


---

---
title: "[NOI2010] 成长快乐"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1915
tag: ['贪心', '2010', 'NOI', '提交答案', 'Special Judge', '随机化']
---
# [NOI2010] 成长快乐
## 题目描述

Nemo 是一条无忧无虑的小鱼，它的初始体重为 $w_0$。可爱的 Nemo 希望自己能够尽快地成长，因此需要吃尽量多的食物。Nemo 最喜爱的食物是海里的小虾。

已知 Nemo 对食物的情况了解如下：大海里共有 $n$ 只小虾，从 $1$ 到 $n$ 编号，其中编号为 $i$ 的小虾的重量为 $w_i$。将大海看作一个 X-Y 坐标系，在 $0$ 时刻编号为 $i$ 的小虾所在的位置为 $(x_i, y_i)$。小虾在大海中作匀速直线运动，其中编号为 $i$ 的小虾的速度向量为 $(p_i, q_i)$，即在时刻 $t$，它的位置为 $(x_i+p_i \cdot t,y_i+q_i \cdot t)$。

Nemo 在 $0$ 时刻的位置为 $(x_0, y_0)$，它可以在海中随意移动，但速度不超过 $V$。Nemo 希望通过自己的努力，在 $T$ 个单位时间内（含 $T$ 时刻）吃到的小虾重量总和尽量大。

当 Nemo 与某只小虾同时移动到同一个位置上，且小虾的重量小于 Nemo 当时的重量，则 Nemo 可以将该小虾吃掉。当 Nemo 吃掉重量为 $w_i$ 的小虾之后，它的体重将增加 $w_i$。注意，小虾不会吃 Nemo，且小虾之间也不会自相残杀。

Nemo 希望你来帮助它制定一个成长计划，使得它吃掉的小虾重量总和尽量大。
## 输入格式

该题为提交答案型试题，所有输入数据 `nemo1.in` $\sim$ `nemo10.in` 已在试题目录下。

**[数据以及checker下载](http://pan.baidu.com/s/1dEDLQud)**

对于每个数据，输入文件中第一行为五个实数 $w_0, V, T, x_0, y_0$。分别表示 Nemo 的初始体重、最大移动速度、时间限制以及 Nemo 在 $0$ 时刻的位置。

第二行为一个整数 $n$，表示大海中小虾的只数。

接下来 $n$ 行，每行 $5$ 个实数，包括 $w_i, x_i, y_i, p_i, q_i$，分别表示编号为 $i$ 的小虾的重量、在 $0$ 时刻的位置和速度向量。
## 输出格式

针对给定的 $10$ 个输入文件 `nemo1.in` $\sim$ `nemo10.in`，你需要分别提交你的输出文件 `nemo1.in` $\sim$ `nemo10.in`。

输出文件第一行包含一个整数 $k$。表示在你的成长计划中，Nemo 将吃到 $k$ 只小虾。

第二行包含一个实数 $w$，表示在你的成长计划中，Nemo 吃到的小虾的重量总和。

接下来 $k$ 行，每行 $4$ 个数 $t, x, y, s$。表示在时刻 $t$，Nemo 在位置 $(x, y)$ 处吃掉了编号为 $s$ 的小虾。其中 $t, x, y$ 为实数，$s$ 为整数。

为保证验证程序的精度，所有实数建议至少输出到小数点后 $6$ 位。在验证程序中，两个实数绝对误差不超过 $10^{-4}$ 时，即视为相等。
## 样例

### 样例输入 #1
```
5 1 6 0 0
1
5 2 2 0 0

```
### 样例输出 #1
```
1
5
5 2 2 1

```
## 提示

### 样例解释

在这个样例中，Nemo 在时刻 $5$ 在位置 $(2, 2)$ 吃掉了 $1$ 号小虾。其实 Nemo 到达 $(2, 2)$ 的时间可以更早，但题中仅要求速度不超过 $V$ 即可。

### 评分方法

对于每组数据，我们设置了 $9$ 个评分参数 $a_{10},a_9, \ldots ,a_2$。如果选手的输出不合法，则得零分。否则，设在你的方案中，Nemo 体重的增加量为 $w_{user}$，你的分数将会由下表给出：

| 得分 |          条件          | 得分 |        条件         |
| :--: | :--------------------: | :--: | :-----------------: |
|  10  | $w_{user} \geq a_{10}$ |  5   | $w_{user} \geq a_5$ |
|  9   |  $w_{user} \geq a_9$   |  4   | $w_{user} \geq a_4$ |
|  8   |  $w_{user} \geq a_8$   |  3   | $w_{user} \geq a_3$ |
|  7   |  $w_{user} \geq a_7$   |  2   | $w_{user} \geq a_2$ |
|  6   |  $w_{user} \geq a_6$   |  1   |  $w_{user} \gt 0$   |

### checker 使用方法

在 checker 目录下，在终端输入 `./checker in out`。

其中 in 为题目提供的输入文件，out 为你对于该输入文件给出的答案文件。

校验器将只检查你的答案的合法性，结果以在线评测为准。

感谢 @FlierKing 提供 spj 以及 @虞皓翔 帮助完善 spj。



---

---
title: "[NOI2010] 旅行路线"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1933
tag: ['动态规划 DP', '搜索', '2010', 'NOI', 'O2优化', '剪枝', '插头 DP']
---
# [NOI2010] 旅行路线
## 题目描述

2010 年，世博会在中国上海举办，吸引了数以千万计的中外游客前来参观。暑假期间小 Z 也来到了上海世博园， 她对世博园的拥挤早有所闻，对有的展馆甚至要排上好几个小时的队才能进入也做好了充分准备，但为了使得自己的世博之旅更加顺利舒畅，小 Z 决定在游玩之前先制定一份详细的旅行路线。

小 Z 搜集到了世博园的地图，她发现从整体上看世博园是一块非常狭长的区域，而每一个展馆占用了其中一个几乎相同大小的方块。因此可以将整个园区看成一个 $n \times m$ 的矩阵（$n \leq 3$），其中每一个格子为一个主题展馆。

由于不同展馆受到的关注度会有一些差别，因此排队时间的长短也不尽相同。小 Z 根据统计信息给每一个展馆 $(x, y)$ 标记了 $T_{x,y} = 0$ 或 $1$，如果 $T_{x,y} = 1$，表示这个展馆非常热门，需要排很长时间的队；如果 $T_{x,y} = 0$，表示这个展馆相对比较普通，几乎不需要排队即可进入参观。小 Z 希望能够制定一份合理的路线，使得能交替参观热门馆和普通馆，既不会因为总是参观热门馆而长时间在排队，也不会因为总是参观普通馆而使得游览过于平淡。同时，小 Z 办事很讲究效率，她希望在游遍所有展馆的同时，又不会走冤枉路浪费体力。因此她希望旅行路线满足以下几个限制：

1. 在参观完位于 $(x, y)$ 的展馆后，下一个参观的是一个相邻的且未被参观过的展馆 $(x^\prime, y^\prime)$，即 $|x-x^\prime|+|y-y^\prime|=1$；
2. 路线的起点位于整个矩阵的边界上，即 $x = 1$ 或 $x = n$ 或 $y = 1$ 或 $y = m$；

她制定了一个长度为 $n \times m$ 的 01 序列 $L$，她希望第 $i$ 个参观的展馆 $(x,y)$ 满足 $T_{x,y}=L_i$。

小 Z 想知道有多少条不同的旅行路线能够满足她的要求。由于最终的结果可能很大，小 Z 只想知道可行的旅行路线总数 $\bmod\space 11\,192\,869$ 的值。

## 输入格式

第一行包含两个正整数 $n, m$。

第 2 行至第 $n+1$ 行，每行有 $m$ 个 01 整数，其中第 $i+1$ 行第 $j$ 个数表示 $T_{i,j}$。

第 $n+2$ 行有 $n \times m$ 个 01 整数，其中第 $i$ 个数表示 $L_i$ 的值。
## 输出格式

仅包含一个整数，表示可行的旅行路线总数 $\bmod \space 11\,192\,869$ 的值。
## 样例

### 样例输入 #1
```
2 2
1 0
0 1
1 0 1 0
```
### 样例输出 #1
```
4

```
## 提示

【样例说明】

这四条可行的旅行路线分别为：

$$
\begin{aligned}
(1,1) \to (1,2) \to (2,2) \to (2,1)\\
(1,1) \to (2,1) \to (2,2) \to (1,2)\\
(2,2) \to (1,2) \to (1,1) \to (2,1)\\
(2,2) \to (2,1) \to (1,1) \to (1,2)
\end{aligned}
$$

【数据规模和约定】

- 对于 $10\%$ 的数据：$n=1$；
- 对于 $30\%$ 的数据：$n=2$；
- 对于 $60\%$ 的数据：$n=3$，其中 $20\%$ 的数据 $T_{i,j}$ 全为 $0$；
- 对于 $100\%$ 的数据：$m \leq 50$，$L_i,T_{i,j} = 0$ 或 $1$。


---

---
title: "[NOI2011] 兔兔与蛋蛋游戏"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1971
tag: ['2011', 'NOI', '深度优先搜索 DFS', '二分图']
---
# [NOI2011] 兔兔与蛋蛋游戏
## 题目描述

这些天，兔兔和蛋蛋喜欢上了一种新的棋类游戏。

这个游戏是在一个 $n$ 行 $m$ 列的棋盘上进行的。游戏开始之前，棋盘上有一个格子是空的，其它的格子中都放置了一枚棋子，棋子或者是黑色，或者是白色。

每一局游戏总是兔兔先操作，之后双方轮流操作，具体操作为：

* 兔兔每次操作时，选择一枚与空格相邻的白色棋子，将它移进空格。
* 蛋蛋每次操作时，选择一枚与空格相邻的黑色棋子，将它移进空格。

第一个不能按照规则操作的人输掉游戏。为了描述方便，下面将操作“将第x行第y列中的棋子移进空格中”记为 $M(x,y)$。

例如下面是三个游戏的例子。

![](https://cdn.luogu.com.cn/upload/image_hosting/6wfmhuf2.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/j7vox6n7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/er1t5wpb.png)

最近兔兔总是输掉游戏，而且蛋蛋格外嚣张，于是兔兔想请她的好朋友——你——来帮助她。她带来了一局输给蛋蛋的游戏的实录，请你指出这一局游戏中所有她“犯错误”的地方。

注意：

* 两个格子相邻当且仅当它们有一条公共边。
* 兔兔的操作是“犯错误”的，当且仅当，在这次操作前兔兔有必胜策略，而这次操作后蛋蛋有必胜策略。

## 输入格式

输入的第一行包含两个正整数 $n,m$。

接下来 $n$ 行描述初始棋盘。其中第 $i$ 行包含 $m$ 个字符，每个字符都是大写英文字母 `X`、大写英文字母 `O` 或点号 `.` 之一，分别表示对应的棋盘格中有黑色棋子、有白色棋子和没有棋子。其中点号 `.` 恰好出现一次。

接下来一行包含一个整数 $k$（$1\leq k\leq 1000$） ，表示兔兔和蛋蛋各进行了 $k$ 次操作。

接下来 $2k$ 行描述一局游戏的过程。其中第 $2i - 1$ 行是兔兔的第 $i$ 次操作（编号为 $i$ 的操作） ，第 $2i$ 行是蛋蛋的第 $i$ 次操作。每个操作使用两个整数 $x,y$ 来描述，表示将第 $x$ 行第 $y$ 列中的棋子移进空格中。

输入保证整个棋盘中只有一个格子没有棋子， 游戏过程中兔兔和蛋蛋的每个操作都是合法的，且最后蛋蛋获胜。

## 输出格式

输出文件的第一行包含一个整数 $r$，表示兔兔犯错误的总次数。

接下来 $r$ 行按递增的顺序给出兔兔“犯错误”的操作编号。其中第 $i$ 行包含一个整数 $a_i$ 表示兔兔第 $i$ 个犯错误的操作是他在游戏中的第 $a_i$ 次操作。


## 样例

### 样例输入 #1
```
1 6 
XO.OXO 
1 
1 2 
1 1 
```
### 样例输出 #1
```
1
1
```
### 样例输入 #2
```
3 3 
XOX 
O.O 
XOX 
4 
2 3 
1 3 
1 2 
1 1 
2 1 
3 1 
3 2 
3 3 
```
### 样例输出 #2
```
0
```
### 样例输入 #3
```
4 4 
OOXX 
OXXO 
OO.O 
XXXO 
2 
3 2 
2 2 
1 2 
1 3 
```
### 样例输出 #3
```
2
1
2
```
## 提示

对于 $100\%$ 的数据，$1\leq n\leq 40$，$1 \leq m\leq 40$，$1\leq k\leq 1000$。

|测试点编号|$n$|$m$|
|:-:|:-:|:-:|
|$1,2$|$n=1$|$1\leq m\leq 20$|
|$3$|$n=3$|$m=4$|
|$4,5$|$n=4$|$m=4$|
|$6,7$|$n=4$|$m=5$|
|$8$|$n=3$|$m=7$|
|$9\sim 14$|$n=2$|$1\leq m\leq 40$|
|$15,16$|$1\leq n\leq 16$|$1\leq m\leq 16$|
|$17\sim 20$|$1\leq n\leq 40$|$1\leq m\leq 40$|



---

---
title: "[NOI2011] 兔农"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P2020
tag: ['数学', '2011', 'NOI', '斐波那契数列', '逆元']
---
# [NOI2011] 兔农
## 题目描述

农夫栋栋近年收入不景气，正在他发愁如何能多赚点钱时，他听到隔壁的小朋友在讨论兔子繁殖的问题。

问题是这样的：第一个月初有一对刚出生的小兔子，经过两个月长大后，这对兔子从第三个月开始，每个月初生一对小兔子。新出生的小兔子生长两个月后又能每个月生出一对小兔子。问第 $n$ 个月有多少只兔子？

聪明的你可能已经发现，第 $n$ 个月的兔子数正好是第 $n$ 个 Fibonacci（斐波那契）数。栋栋不懂什么是 Fibonacci 数，但他也发现了规律：第 $i+2$ 个月的兔子数等于第 $i$ 个月的兔子数加上第 $i+1$ 个月的兔子数。前几个月的兔子数依次为：

$$1,1,2,3,5,8,13,21,34,\ldots$$

栋栋发现越到后面兔子数增长的越快，期待养兔子一定能赚大钱，于是栋栋在第一个月初买了一对小兔子开始饲养。

每天，栋栋都要给兔子们喂食，兔子们吃食时非常特别，总是每 $k$ 对兔子围成一圈，最后剩下的不足 $k$ 对的围成一圈，由于兔子特别害怕孤独，从第三个月开始，如果吃食时围成某一个圈的只有一对兔子，这对兔子就会很快死掉。

我们假设死去的总是刚出生的兔子，那么每个月的兔子数仍然是可以计算的。例如，当 $k=7$ 时，前几个月的兔子数依次为：

$$1,1,2,3,5,7,12,19,31,49,80,\ldots$$

给定 $n$，你能帮助栋栋计算第 $n$ 个月他有多少对兔子么？由于答案可能非常大，你只需要告诉栋栋第 $n$ 个月的兔子对数除 $p$ 的余数即可。

## 输入格式

输入一行，包含三个正整数 $n, k, p$。

## 输出格式

输出一行，包含一个整数，表示栋栋第 $n$ 个月的兔子对数除 $p$ 的余数。

## 样例

### 样例输入 #1
```
6 7 100
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
7 7 5
```
### 样例输出 #2
```
2
```
## 提示

|测试点编号|$n$|$k,p$|
|:-:|:-:|:-:|
|$1\sim 10$|$1\leq n\leq 50$|$2\leq k,p\leq1000$|
|$11$|$1\leq n\leq 80$|$2\leq k,p\leq 10^4$|
|$12,13$|$1\leq n\leq 1000$|$2\leq k,p\leq 10^4$|
|$14,15$|$1\leq n\leq 10^6$|$2\leq k,p\leq 10^6$|
|$16,17$|$1\leq n\leq 10^{18}$|$2\leq k,p\leq1000$|
|$18\sim 20$|$1\leq n\leq 10^{18}$|$2\leq k\leq 10^6$，$2\leq p\leq 10^9$|

对于 $100\%$ 的数据，$1\leq n\leq 10^{18}$，$2\leq k\leq 10^6$，$2\leq p\leq 10^9$。



---

---
title: "[NOI2012] 魔幻棋盘"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P2086
tag: ['2012', '线段树', 'NOI', '最大公约数 gcd']
---
# [NOI2012] 魔幻棋盘
## 题目描述

将要读二年级的小 Q 买了一款新型益智玩具——魔幻棋盘，它是一个 $N$ 行 $M$ 列的网格棋盘，每个格子中均有一个正整数。棋盘守护者在棋盘的第 $X$ 行第 $Y$ 列（行与列均从 $1$ 开始编号）并且始终不会移动。棋盘守护者会进行两种操作：

* （a）询问：他会以自己所在位置为基础，向四周随机扩展出一块大小不定的矩形区域，向你询问这一区域内所有数的最大公约数是多少。
* （b）修改：他会随意挑选棋盘上的一块矩形区域，将这一区域内的所有数同时加上一个给定的整数。

游戏说明书上附有这样一句话“聪明的小朋友，当你连续答对 $19930324$ 次询问后会得到一个惊喜噢！”。小 Q 十分想得到这个惊喜，于是每天都在玩这个玩具。但由于他粗心大意，经常算错数，难以达到这个目标。于是他来向你寻求帮助，希望你帮他写一个程序来回答棋盘守护者的询问，并保证 $100\%$ 的正确率。

为了简化问题，你的程序只需要完成棋盘守护者的 $T$ 次操作，并且问题保证任何时刻棋盘上的数字均为不超过 $2^{62} - 1$ 的正整数。

## 输入格式

第一行为两个正整数 $N,M$，表示棋盘的大小。

第二行为两个正整数 $X,Y$，表示棋盘守护者的位置。

第三行仅有一个正整数 $T$，表示棋盘守护者将进行 $T$ 次操作。

接下来 $N$ 行，每行有 $M$ 个正整数，用来描述初始时棋盘上每个位置的数。

接下来 $T$ 行，按操作的时间顺序给出 $T$ 次操作。每行描述一次操作，以一个数字 $0$ 或 $1$ 开头：

* 若以数字 $0$ 开头，表示此操作为询问，随后会有四个非负整数 $x_1,y_1,x_2,y_2$，表示询问的区域是以棋盘守护者的位置为基础向上扩展
 $x_1$ 行，向下扩展 $x_1$ 行，向左扩展 $y_1$ 列，向右扩展 $y_2$ 列得到的矩形区域（详见样例）。 
* 若以数字 $1$ 开头，表示此操作为修改，随后会有四个正整数 $x_1,y_1,x_2,y_2$ 和一个整数 $c$，表示修改区域的上、下边界分别为第 $x_1,x_2$ 行，左、右边界分别为第 $y_1,y_2$ 列（详见样例），在此矩形区域内的所有数统一加上 $c$（注意 $c$ 可能为负数）。

## 输出格式

对于每次询问操作，每行输出一个数，表示该区域内所有数的最大公约数。

## 样例

### 样例输入 #1
```
2 2
1 1
4
6 12
18 24
0 0 0 1 0
1 1 1 1 2 6
1 2 1 2 2 6
0 0 0 1 1
```
### 样例输出 #1
```
6
6
```
## 提示

 ![](https://cdn.luogu.com.cn/upload/pic/2594.png) 

对于第一、第四次操作（查询操作）后，加粗部分表示查询区域。

对于第二、第三次操作（修改操作）后，加粗部分表示修改区域。

测试数据分为 A、B、C 三类：

A 类数据占 $20\%$，满足 $N \leq 100$，$M \leq 100$，$T \leq 2\times 10^4$。

B 类数据占 $40\%$，满足 $N = 1$，$M \leq 5\times 10^5$，$T \leq 10^5$。

C 类数据占 $40\%$，满足 $N \times M \leq 5\times 10^5$，$T \leq 10^5$。

在每类数据中，均有 $50\%$ 的数据满足每次修改操作仅含一个格子（即 $x_1 = x_2$，$y_1 = y_2$）。

输入数据保证满足题目描述中的所有性质。



---

---
title: "[NOI2007] 调兵遣将"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P2099
tag: ['2007', 'NOI', '提交答案', 'Special Judge', 'O2优化']
---
# [NOI2007] 调兵遣将
## 题目背景

下发文件：
链接：https://pan.baidu.com/s/1JlHZ72eFapfEyqjL_uphoA 
提取码：7v4i

由于上传答案文件有大小限制，请尽量使用代码提交= =。

## 题目描述

我军截获的情报显示，敌军正在集结兵力试图向我军重要的军械研究所发起进攻。由于我军正处于多线作战的状态，无法抽调大批兵力前去支援，指挥部决定通过有效的战前部署来提高胜率，减少伤亡和损失。

该军械研究所的平面图可以看作是一个 $N\times M$ 的矩阵，每个$1\times 1$ 的格子都表示一个区域，每个区域只与它上下左右的四个区域相邻。每个区域的用途可分为以下3 种之一：

1． 该区域被用于军事研究（用字母 `O` 表示）；

2． 该区域内驻扎有一个机械化中队（用 `#` 表示）；

3． 该区域是空地（用`.`表示）。

由于空间有限，任一个 $1\times 1$ 的格子内都无法驻扎两队以上的机械化中队（包括两队），否则会大大降低战斗时的机动性。

遗憾的是，由于战前估计不足，我军的防御部署显得十分分散，这很容易让敌军所擅长的偷袭战术得逞。为了确保万无一失，我军决定利用为数不多的防御部队以最少的移动步骤将所有重要研究区域都包围起来。所谓的“包围”即从该矩阵边界侵入的敌军找不到任意一条路，使得他们不遭受任何机械化中队的反抗就能到达某研究区域。

由于军队内部的传令权限的限制，每个单位时间指挥部只能向所有中队中的一个中队下达指令（朝上/下/左/右移动 $1$ 格）。由于时间紧迫，指挥部希望能够尽快完成部署，这个任务就交给你来完成。

注意：在部署的过程中军队可以进入研究区域，而在最终的部署结果中军队不可以在研究区域中。另外，在任何时刻，两个军队都不可以在同一个方格中。
## 输入格式

该题为提交答案型题目。

对于每个数据：

第一行 $2$ 个整数 $N$,$M$，接下来 $N$ 行，每行包括 $M$ 个字符（`.`, `O`或 `#`）。
## 输出格式

每个输出文件的第一行，包括你的答案所花费的时间 $T$。

接下来 $T$ 行，按顺序输出每条命令，每行包括 $4$ 个整数 $x1, y1, x2, y2$，表示将位于 $(x1,y1)$ 的部队移向 $(x2,y2)$。
## 样例

### 样例输入 #1
```
5 5
..##.
#...#
#OOO#
#..O#
.###.
```
### 样例输出 #1
```
1
2 1 2 2
```
## 提示

如果选手的输出方案不合法（方案执行过程中出现军队重叠，军队移出矩形边界，最终方案有军队和研究所在同一区域，军队没有包围研究所等），则得零分，否则设选手输出的方案耗时为ans ，则得分按如下计算：

$$score=
\begin{cases}
\ 10&ans \leq A_i\\
\ 1+\left\lfloor\dfrac{ans-B_i}{A_i-B_i}\right\rfloor \times 9&A_i<ans \leq B_i\\
\ 1&B_i<ans\\
\end{cases}
$$  

对于每个数据，都有两个评分参数 $A_i$ 与 $B_i$，其中保证 $A_i<B_i$。



---

---
title: "[NOI2012] 骑行川藏"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P2179
tag: ['数学', '2012', 'NOI', 'Special Judge', '向量', '构造', '拉格朗日乘数法']
---
# [NOI2012] 骑行川藏
## 题目描述

蛋蛋非常热衷于挑战自我，今年暑假他准备沿川藏线骑着自行车从成都前往拉萨。

川藏线的沿途有着非常美丽的风景，但在这一路上也有着很多的艰难险阻，路况变化多端，而蛋蛋的体力十分有限,因此在每天的骑行前设定好目的地，同时合理分配好自己的体力是一件非常重要的事情。

由于蛋蛋装备了一辆非常好的自行车，因此在骑行过程中可以认为他仅在克服风阻做功（不受自行车本身摩擦力以及自行车与地面的摩擦力影响）。

某一天他打算骑 $n$ 段路，每一段内的路况可视为相同：对于第 $i$ 段路,我们给出有关这段路况的 $3$ 个参数 $s_i,k_i,v_i'$，其中 $s_i$ 表示这段路的长度，$k_i$ 表示这段路的风阻系数，$v_i'$ 表示这段路上的风速（$v_i'\gt 0$ 表示在这段路上他遇到了顺风，反之则意味着他将受逆风影响）。

若某一时刻在这段路上骑车速度为 $v$，则他受到的风阻
大小为 $F=k_i(v-v_i')^2$（这样若在长度为 $s$ 的路程内保持骑行速度 $v$ 不变,则他消耗能量（做功）$E=k_i(v-v_i')^2s$ ）。

设蛋蛋在这天开始时的体能值是 $E_U$，请帮助他设计一种行车方案,使他在有限的体力内用最短的时间到达目的地。请告诉他最短的时间 $T$ 是多少。
## 输入格式

第一行包含一个正整数 $n$ 和一个实数 $E_U$，分别表示路段的数量以及蛋蛋的体能值。

接下来 $n$ 行分别描述 $n$ 个路段，每行有 $3$ 个实数 $s_i,k_i,v_i'$ 分别表示第 $i$ 段路的长度，风阻系数以及风速。
## 输出格式

输出一个实数 $T$，表示蛋蛋到达目的地消耗的最短时间，要求至少保留到小数点后 $6$ 位。
## 样例

### 样例输入 #1
```
3 10000
10000 10 5
20000 15 8
50000 5 6
```
### 样例输出 #1
```
12531.34496464
```
## 提示

### 样例说明

一种可能的方案是：蛋蛋在三段路上都采用匀速骑行的方式,其速度依次为 $5.12939919,8.03515481,6.17837967$。

### 评分方法

本题没有部分分,你程序的输出只有和标准答案的差距不超过 $10^{-6}$ 时，才能获得该测试点的满分，否则不得分。

### 数据规模与约定

对于 $10\%$  的数据，$n=1$。

对于 $40\%$  的数据，$n\le2$。

对于 $60\%$  的数据，$n\le100$。

对于 $80\%$  的数据，$n\le 1000$。

对于 $100\%$  的数据，$n\le 10^4$，$E_U\le 10^8$，$s_i\in[0,10^5]$，$k_i\in(0,15]$，$v_i'\in(-100,100)$。

数据保证最终的答案不会超过 $10^5$。

### 提示

必然存在一种最优的体力方案满足：蛋蛋在每段路上都采用匀速骑行的方式。


---

---
title: "[NOI2015] 小园丁与老司机"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P2304
tag: ['动态规划 DP', '2015', 'NOI', '网络流', 'Special Judge', '图论建模']
---
# [NOI2015] 小园丁与老司机
## 题目描述

小园丁 Mr. S 负责看管一片田野，田野可以看作一个二维平面。田野上有 $n$ 棵 许愿树，编号 $1,2,3,\dots,n$ ，每棵树可以看作平面上的一个点，其中第 $i$ 棵树 $(1 \leq i \leq n)$ 位于坐标 $(x_i, y_i)$ 。任意两棵树的坐标均不相同。

老司机 Mr. P 从原点 $(0,0)$ 驾车出发，进行若干轮行动。每一轮，Mr. P 首先选择任意一个满足以下条件的方向：

1.为左、右、上、左上 $45\degree$、右上 $45\degree$ 五个方向之一。

2.沿此方向前进可以到达一棵他尚未许愿过的树。

完成选择后，Mr.P 沿该方向直线前进，必须到达该方向上距离最近的尚未许愿的树，在树下许愿并继续下一轮行动。如果没有满足条件的方向可供选择，则停止行动。他会采取最优策略，在尽可能多的树下许愿。若最优策略不唯一，可以选择任意一种。

不幸的是，小园丁 Mr.S 发现由于田野土质松软，老司机 Mr.P 的小汽车在每轮行进过程中，都会在田野上留下一条车辙印，一条车辙印可看作以两棵树（或原点和一棵树）为端点的一条线段。

在 Mr.P 之后，还有很多许愿者计划驾车来田野许愿，这些许愿者都会像 Mr.P 一样任选一种最优策略行动。Mr.S 认为非左右方向（即上、左上  $45\degree$、右 上 $45\degree$ 三个方向）的车辙印很不美观，为了维护田野的形象，他打算租用一些轧路机，在这群许愿者到来之前夯实所有“可能留下非左右方向车辙印”的地面。“可能留下非左右方向车辙印”的地面应当是田野上的若干条线段，其中每条线段都包含在某一种最优策略的行进路线中。每台轧路机都采取满足以下三个条件的工作模式：

1.从原点或任意一棵树出发。

2.只能向上、左上 $45\degree$、右上 $45\degree$ 三个方向之一移动，并且只能在树下改变方向或停止。

3.只能经过“可能留下非左右方向车辙印”的地面，但是同一块地面可以 被多台轧路机经过。

现在 Mr. P 和 Mr. S 分别向你提出了一个问题：

1.请给 Mr.P 指出任意一条最优路线。

2.请告诉 Mr.S 最少需要租用多少台轧路机。
## 输入格式

第 $1$ 行包含 $1$ 个正整数 $n$，表示许愿树的数量。

接下来 $n$ 行，第 $i+1$ 行包含 $2$ 个整数 $x_i,y_i$，中间用单个空格隔开，表示第 $i$ 棵许愿树的坐标。
## 输出格式

包括 $3$ 行。

第 $1$ 行输出 $1$ 个整数 $m$，表示 Mr. P 最多能在多少棵树下许愿。

输出文件的第 $2$ 行输出 $m$ 个整数，相邻整数之间用单个空格隔开，表示 Mr.P 应该依次在哪些树下许愿。

输出文件的第 $3$ 行输出 $1$ 个整数，表示 Mr. S 最少需要租用多少台轧路机。

## 样例

### 样例输入 #1
```
6
-1 1
1 1
-2 2
0 8
0 9
0 10

```
### 样例输出 #1
```
3
2 1 3
3

```
### 样例输入 #2
```
4
0 1
-2 1
2 1
3 2

```
### 样例输出 #2
```
4
1 2 3 4
2
```
## 提示

#### 样例 1 解释

最优路线共 $2$ 条，可许愿 $3$ 次：$(0,0) \rightarrow (1,1) \rightarrow (-1,1) \rightarrow (-2,2)$ 或 $(0,0) \rightarrow (0,8) \rightarrow (0,9) \rightarrow (0,10)$。

至少 $3$ 台轧路机，路线是 $(0,0) \rightarrow (1,1)$，$(-1,1) \rightarrow (-2,2)$ 和 $(0,0) \rightarrow (0,8) \rightarrow (0,9) \rightarrow (0,10)$。

#### 样例 2 解释

最优路线唯一：$(0,0) \rightarrow (0,1) \rightarrow (-2,1) \rightarrow (2,1) \rightarrow (3,2)$，可许愿 $4$ 次。其中在 $(0,1)$ 许愿后，从 $(-2,1)$ 出发沿着向右的方向能够到达的最近的未许愿过的树是 $(2,1)$，所以可以到达 $(2,1)$。

而如果沿着 $(0,0) \rightarrow (0,1) \rightarrow (2,1) \rightarrow (-2,1)$ 的方向前进，此时 $(-2,1)$ 右边所有树都是许愿过的，根据题目条件规定，停止前进。故无法获得最优解。

$(0,0) \rightarrow (0,1)$ 与 $(2,1) \rightarrow (3,2)$ 会留下非左右方向车辙印，需 $2$ 台轧路机。

![](https://cdn.luogu.com.cn/upload/pic/1509.png)


---

---
title: "[NOI2014] 购票"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P2305
tag: ['图论', '2014', '线段树', 'NOI', '分治', '斜率优化']
---
# [NOI2014] 购票
## 题目描述

今年夏天，NOI 在 SZ 市迎来了她三十周岁的生日。来自全国 $n$ 个城市的 OIer 们都会从各地出发，到 SZ 市参加这次盛会。

全国的城市构成了一棵以 SZ 市为根的有根树，每个城市与它的父亲用道路连接。为了方便起见，我们将全国的 $n$ 个城市用 $1\sim n$ 的整数编号。其中 SZ 市的编号为 $1$。对于除 SZ 市之外的任意一个城市 $v$，我们给出了它在这棵树上的父亲城市 $f_v$  以及到父亲城市道路的长度 $s_v$。

从城市 $v$ 前往 SZ 市的方法为：选择城市 $v$ 的一个祖先 $a$，支付购票的费用，乘坐交通工具到达 $a$。再选择城市 $a$ 的一个祖先 $b$，支付费用并到达 $b$。以此类推，直至到达 SZ 市。

对于任意一个城市 $v$，我们会给出一个交通工具的距离限制 $l_v$。对于城市 $v$ 的祖先 A，只有当它们之间所有道路的总长度不超过 $l_v$  时，从城市 $v$ 才可以通过一次购票到达城市 A，否则不能通过一次购票到达。  

对于每个城市 $v$，我们还会给出两个非负整数 $p_v,q_v$  作为票价参数。若城市 $v$ 到城市 A 所有道路的总长度为 $d$，那么从城市 $v$ 到城市 A 购买的票价为 $dp_v+q_v$。

每个城市的 OIer 都希望自己到达 SZ 市时，用于购票的总资金最少。你的任务就是，告诉每个城市的 OIer 他们所花的最少资金是多少。

## 输入格式

第一行包含两个非负整数 $n,t$，分别表示城市的个数和数据类型（其意义将在「提示与说明」中提到）。

接下来 $2 \sim n$ 行，每行描述一个除 SZ 之外的城市。其中第 $v$ 行包含五个非负整数 $f_v,s_v,p_v,q_v,l_v$，分别表示城市 $v$ 的父亲城市，它到父亲城市道路的长度，票价的两个参数和距离限制。

请注意：输入不包含编号为 1 的 SZ 市，第 $2\sim n$ 行分别描述的是城市 $2$ 到城市 $n$。

## 输出格式

输出包含 $n-1$ 行，每行包含一个整数。

其中第 $v$ 行表示从城市 $v+1$ 出发，到达 SZ 市最少的购票费用。

同样请注意：输出不包含编号为 1 的 SZ 市。

## 样例

### 样例输入 #1
```
7 3 
1 2 20 0 3 
1 5 10 100 5 
2 4 10 10 10 
2 9 1 100 10 
3 5 20 100 10 
4 4 20 0 10 

```
### 样例输出 #1
```
40 
150 
70 
149 
300 
150
```
## 提示

从每个城市出发到达 SZ 的路线如下（其中箭头表示一次直达）：

城市 $2$：只能选择 $2 \rightarrow 1$，花费为 $2 \times 20 + 0 = 40$。

城市 $3$：只能选择 $3 \rightarrow 1$，花费为 $5 \times 10 + 100 = 150$。

城 市 $4$ ： 由于 $4 + 2 =6 \leq l_4 = 10$，故可以选择 $4\rightarrow1$。若选择 $4 \rightarrow 1$，花费为 $(4 +2) \times 10 + 10 = 70$ ； 若选择 $4 \rightarrow 2 \rightarrow 1$，则花费为 $(4\times 10 + 10) + (2 \times  20 + 0) =90$；因此选择 $4 \rightarrow 1$。

城市 $5$：只能选择 $5\rightarrow 2\rightarrow 1$，花费为 $(9 \times 1 +100) + (2 \times  20 + 0) = 149$；无法选择 $5 \rightarrow 1$，因为 $l_5 =10$，而城市 $5$ 到城市 $1$ 总路程为 $9 + 2 = 11 \gt 5$，城市 $5$ 不能直达城市 $1$。

城市 $6$：若选择 $6 \rightarrow 1$，花费为 $(5 + 5) \times 20 + 100 = 300$；若选择 $6 \rightarrow 3 \rightarrow 1$，花费为 $(5 \times 20 + 100) + (5 \times 10 + 100) = 350$；因此选择 $6 \rightarrow 1$。

城市 $7$：选择 $7 \rightarrow 4 \rightarrow 1$，花费为 $(4 \times 20 + 0) + ((4 + 2) \times 10 + 10) = 150$；

其他方案均比该方案差。

 ![](https://cdn.luogu.com.cn/upload/pic/2592.png) 

### 数据范围

![](https://cdn.luogu.com.cn/upload/pic/2591.png)

对于所有数据，$n\leq 2 \times 10^5, 0 \leq p_v \leq 10^6,\ 0 \leq q_v \leq 10^{12},\ 1\leq f_v<v,\ 0<s_v\leq lv \leq 2 \times 10^{11}$，且任意城市到 SZ 市的总路程长度不超过 $2 \times 10^{11}$。

输入的 $t$ 表示数据类型，$0\leq t<4$，其中：
- 当 $t=0$ 或 $2$ 时，对输入的所有城市 $v$，都有 $f_v=v-1$，即所有城市构成一个以 SZ 市为终点的链；
- 当 $t=0$ 或 $1$ 时，对输入的所有城市 $v$，都有 $l_v=2 \times 10^{11}$，即没有移动的距离限制，每个城市都能到达它的所有祖先；
- 当 $t=3$ 时，数据没有特殊性质。


---

---
title: "[NOI2006] 千年虫"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P2703
tag: ['动态规划 DP', '贪心', '2006', 'NOI', '枚举']
---
# [NOI2006] 千年虫
## 题目描述

千年虫是远古时代的生物，时隔几千万年，千年虫早已从地球上销声匿迹，人们对其知之甚少。考古生物学家最近开始对其有了兴趣，因为一批珍贵的千年虫化石被发现，这些化石保留了千年虫近乎完整的形态。

理论科学家们根据这些化石归纳出了千年虫的一般形态特征模型，并且据此判定出千年虫就是蜈蚣的祖先！但科学家 J 发现了实际与理论的一些出入，他仔细的研究了上百个千年虫化石，发现其中大部分千年虫的形态都不完全符合理论模型，这到底是什么因素造成的呢？理论科学家 K 敏锐的指出，千年虫的形态保存在化石中很有可能发生各种变化，即便最细微的变化也能导致它不符合模型。

于是，摆在科学家面前的新问题诞生了：判断一个化石中的千年虫与理论模型的差距有多大？具体来说，就是根据一个千年虫化石的形态 $A$，找到 一个符合理论模型的形态 $B$，使得 $B$ 是最有可能在形成化石时变成形态 $A$。理论学家提出的“千年虫形态特征模型”如下（如左图所示）：躯体由头、尾、躯干、足四大部分构成。

![](https://cdn.luogu.com.cn/upload/pic/1876.png)

- 头，尾用一对平行线段表示。称平行于头、尾的方向为 $x$ 方向；垂直于 $x$ 的方向为 $y$ 方向；

- 在头尾之间有两条互不相交的折线段相连，他们与头、尾两条线段一起围成的区域称为躯干，两条折线段都满足以下条件：拐角均为钝角或者平角，且包含奇数条线段，从上往下数的奇数条垂直于 $x$ 方向。

- 每条折线段从上往下数的第偶数条线段的躯干的另一侧长出一条足，即一个上、下底平行于 $x$ 方向的梯形或矩形，且其中远离躯干一侧的边垂直于 $x$ 方向。

注意：足不能退化成三角形（即底边的长度均大于零），躯干两侧足的数目可以不一样。（如上图，左边有 $4$ 条足，右边有 $5$ 条足）

可见，$x$-$y$ 直角坐标系内，躯干和所有足组成的实心区域的边界均平行或垂直于坐标轴。为了方便，我们假设所有这些边界的长度均为正整数。因此可以认为每个千年虫的躯体 都由一些单位方格拼成。每个单位方格都由坐标 $(x,y)$ 唯一确定。设头尾之间的距离为 $n$，则我们可以用 $2\times n$ 个整数来描述一条千年虫 $B$（如右图）：将 $B$ 沿平行 $x$ 轴方向剖分成 $n$ 条宽度为 $1$ 的横条，每个横条最左边一格的 $x$ 坐标设为 $L_i$，最右一格的的 $x$ 坐标设为 $R_i$。则  $(n,L_1,L_2,\dots,L_n,R_1,R_2,\dots,R_n)$ 就确定了一条千年虫。

由于岁月的侵蚀，在实际发现的化石中，千年虫的形状并不满足上面理论模型的规则，一些格子中的躯体已经被某些矿物质溶解腐蚀了。地质、物理、生物学家共同研究得出：

- 腐蚀是以格子为单位的，只能一整格被腐蚀；

- 腐蚀是分步进行的，每一步只有一格被腐蚀；

- 如果去掉一个格子后躯体不连通了，那么这个格子当前不会被腐蚀；

- 如果一个格子的左边邻格和右边邻格都还没被腐蚀，那么这个格子当前不会被腐蚀；

- 与头相邻的格子不能全部被腐蚀，与尾相邻的格子不能全部被腐蚀。

倘若满足上面五条，我们仍然可以用 $(n,L_1,L_2,\dots,L_n,R_1,R_2,\dots,R_n)$ 来描述一个化石里头的千年虫的形态。其中 $L_i\le R_i$。

![](https://cdn.luogu.com.cn/upload/pic/1879.png)

例如下图：

![](https://cdn.luogu.com.cn/upload/pic/1878.png)

现在你的任务是，输入一个化石里的千年虫的描述 $A$，找一个满足理论模型的千年虫的描述 $B$，使得 $B$ 可以通过腐蚀过程得以变为 $A$，且由 $B$ 转化为 $A$ 的代价（须被腐蚀的格子数）最少。输出此最小代价。
## 输入格式

第一行为一个整数 $n$。

以下 $n$ 行，每行两个整数，其中第 $i$ 行为两个整数 $L'_i$、$R'_i$，用一个空格分开；保证输入数据合法。
## 输出格式

仅一行，为一个整数，表示最少代价。

## 样例

### 样例输入 #1
```
7
4 4
3 4
3 5
1 3
2 2
2 4
3 3
```
### 样例输出 #1
```
3
```
## 提示


【样例说明】

如图：

![](https://cdn.luogu.com.cn/upload/pic/1877.png)

【评分方法】

本题没有部分分，你的程序的输出只有和我们的答案完全一致才能获得满分，否则不得分。

【数据范围】

对于 $30\%$ 的数据，$n\le100$，$R_i\le100$；

对于 $50\%$ 的数据，$n\le1000$，$R_i\le1000$；

对于 $70\%$ 的数据，$n\le10 ^ 5$，$R_i\le 1000$；

对于 $100\%$ 的数据，$1\leq n\le10 ^ 6$，$0\le L_i\le R_i\le10 ^ 6$。


---

---
title: "[NOI2007] 追捕盗贼"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P2892
tag: ['2007', 'NOI', '提交答案', 'Special Judge', 'O2优化']
---
# [NOI2007] 追捕盗贼
## 题目背景

spj来源：loj-Robin。已获得授权。

https://www.luogu.org/paste/dxytr6gc 

附spj，一些修改部分未按照代码规范，请各位谅解。
## 题目描述

魔法国度 Magic Land 里最近出现了一个大盗 Frank，他在 Magic Land 四处作案，专门窃取政府机关的机密文件（因而有人怀疑 Frank 是敌国派来的间谍）。

为了捉住 Frank，Magic Land 的安全局重拳出击！

Magic Land 由 N 个城市组成，并且这 N 个城市又由恰好 N-1 条公路彼此连接起来，使得任意两个城市间都可以通过若干条公路互达。从数据结构的角度我们也可以说，这 N 个城市和 N-1 条公路形成了一棵树。

例如，下图就是 Magic Land 的一个可能格局（4 个城市用数字编号，3 条公路用字母编号）：

 ![](https://cdn.luogu.com.cn/upload/pic/12794.png) 

大盗 Frank 能够在公路上以任意速度移动。

比方说，对于上图给出的格局，在 0.00001 秒钟内（或者任意短的一段时间内），Frank 就可以从城市 1 经过城市 2 到达城市 4，中间经过了两条公路。

想要生擒 Frank 困难重重，所以安全局派出了经验丰富的警探，这些警探具有非凡的追捕才能：

1.  只要有警探和 Frank 同处一个城市，那么就能够立刻察觉到Frank，并且将其逮捕。

2.  虽然 Frank 可以在公路上以任意快的速度移动，但是如果有警探和 Frank 在同一条公路上相遇，那么警探也可以立刻察觉到 Frank 并将其逮捕。

安全局完全不知道 Frank 躲在哪个城市，或者正在哪条公路上移动，所以需要制定一个周密的抓捕计划，计划由若干 步骤组成。在每一步中，可以做如下几件事中的一个：

1.  在某个城市空降一位警探。警探可以直接从指挥部空降到 Magic Land 的任意一个城市里。此操作记为“L x”，表示在编号为 x 的城市里空降一位警探。耗时 1 秒。

2.  把留在某个城市里的一位警探直接召回指挥部。以备在以后的步骤中再度空降到某个城市里。此操作记为“B x”。表示把编号为 x 的城市里的一位警探召回指挥部。耗时 1 秒。

3.  让待在城市 x 的一位警探沿着公路移动到城市 y，此操作记为“M x y”。耗时 1 秒。当然，前提是城市 x 和城市 y 之间有公路。如果在警探移动的过程中，大盗 Frank 也在同一条公路上，那么警探就抓捕到了Frank。

现在，由你来制定一套追捕计划，也就是给出若干个步骤，需要保证：无论大盗 Frank 一开始躲在哪儿，也无论 Frank 在整个过程中如何狡猾地移动（Frank大盗可能会窃取到追捕行动的计划书，所以他一定会想尽办法逃避），他一定会被缉拿归案。

希望参与的警探越少越好，因为经验丰富的警探毕竟不多。

例如对于前面所给的那个图示格局，一个可行的计划如下：

1.  L 2 在城市 2 空降一位警探。注意这一步完成之后，城市 2 里不会有 Frank，否则他将被捉住。

2.  L 2 再在城市 2 空降一位警探。

3.  M 2 1 让城市 2 的一位警探移动到城市 1。注意城市 2 里还留有另一位警探。这一步完成之后，城市 1 里不会有 Frank，公路 A 上也不会有 Frank。也就是说，假如 Frank 还没有被逮捕，那么他只能是在城市 3 或城市 4 里，或者公路 B 或公路 C 上。

4.  B 1 召回城市 1 的一位警探。注意虽然召回了这位警探，但是由于我们始终留了一位警探在城市 2 把守，所以 Frank 仍然不可能跑到城市 1 或者是公路 A 上。

5.  L 3 在城市 3 空降一位警探。注意这一步可以空降在此之前被召回的那位警探。这一步完成之后，城市 3 里不会有 Frank，否则他会被捉住。

6.  M 3 2 让城市 3 里的一位警探移动到城市 2。这一步完成之后，如果 Frank 还没有被捉住，那他只能是在公路 C 上或者城市 4 里。注意这一步之后，城市 2 里有两位警探。

7.  M 2 4 让城市 2 里的一位警探移动到城市 4。这一步完成之后，Frank 一定会被捉住，除非他根本就没来 Magic Land。

这个计划总共需要 2 位警探的参与。可以证明：如果自始至终只有 1 名或者更少的警探参与，则 Frank 就会逍遥法外。

你的任务很简单：对于一个输入的 Magic Land 的格局，计算 S，也就是为了追捕 Frank 至少需要投入多少位警探，并且给出相应的追捕计划步骤。

## 输入格式

输入文件给出了 Magic Land 的格局。

第一行一个整数 N，代表有 N 个城市，城市的编号是 1~N。

接下来 N-1 行，每行有两个用空格分开的整数 x i ，y i ，代表城市 x i ，y i之间有公路相连。保证 1≤x i ,y i ≤N

## 输出格式

向输出文件输出你所给出的追捕计划。

第一行请输出一个整数 S，代表追捕计划需要多少位警探。

第二行请输出一个整数 T，代表追捕计划总共有多少步。

接下来请输出 T 行，依次描述了追捕计划的每一步。每行必须是以下三种形式之一：

”L x”，其中 L 是大写字母，接着是一个空格，再接着是整数 x，代表在城市 x 空降一位警探。你必须保证 1≤x≤N。

“B x”，其中 B 是大写字母，接着是一个空格，再接着是整数 x，代表召回城市 x 的一位警探。你必须保证 1≤x≤N，且你的计划执行到这一步之前，城市 x 里面确实至少有一位警探。

“M x y”，其中 M 是大写字母，接着是一个空格，再接着是整数 x，再跟一个空格，最后一个是整数 y。代表让城市 x 的一位警探沿着公路移动到城市 y。你必须保证 1≤x, y≤N，且你的计划执行到这一步之前，城市 x 里面确实至少有一位警探，且城市 x, y 之前确实有公路。

必须保证输出的 S 确实等于追捕计划中所需要的警探数目。

## 样例

### 样例输入 #1
```
4
1 2
3 2
2 4
```
### 样例输出 #1
```
2
7
L 2
L 2
M 2 1
B 1
L 3
M 3 2
M 2 4
```
## 提示

对于任何一个测试点：

如果输出的追捕计划不合法，或者整个追捕计划的步骤数 T 超过了 20000，或者追捕计划结束之后，不能保证捉住 Frank，则不能得分。

```cpp
否则，用你输出的 S 和我们已知的标准答案 S * 相比较：
1. 若 S<S * ，则得到 120%的分。
2. 若 S=S * ，则得到 100%的分。
3. 若 S * <S≤S * +2，则得到 60%的分。
4. 若 S * +2<S≤S * +4，则得到 40%的分。
5. 若 S * +4<S≤S * +8，则得到 20%的分。
6. 若 S>S * +8，则得到 10%的分。
```
输入保证描述了一棵连通的 N 结点树，1≤N≤1 000。



---

---
title: "[NOI2017] 泳池"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P3824
tag: ['递推', '2017', 'NOI', 'O2优化', '线性递推', '向量']
---
# [NOI2017] 泳池
## 题目背景

久莲是个爱玩的女孩子。

暑假终于到了，久莲决定请她的朋友们来游泳，她打算先在她家的私人海滩外圈一块长方形的海域作为游泳场。然而大海里有着各种各样的危险，有些地方水太深，有些地方有带毒的水母出没。她想让圈出来的这一块海域都是安全的。

## 题目描述

经过初步分析，这块海域可视为一个底边长为 $N$ 米，高为 $1001$ 米的长方形网格。其中网格的底边对应着她家的私人海滩，每一个 $1\:\textrm{m}\times1\:\textrm{m}$ 的小正方形都代表着一个单位海域。她拜托了她爸爸明天去测量每一个小正方形是否安全。在得知了信息之后，她要做的就是圈出她想要的游泳场啦。  

她心目中理想的游泳场满足如下三个条件：
- 必须保证安全性。即游泳场中的每一个单位海域都是安全的。
- 必须是矩形。即游泳场必须是整个网格中的一个 $a\times b$ 的子网格。
- 必须和海滩相邻。即游泳场的下边界必须紧贴网格的下边界。

例如：当 $N = 5$ 时，若测量的结果如下（因为 $1001$ 太大，这儿只画出网格最下面三行的信息，其他部分都是危险的）。 

 ![](https://cdn.luogu.com.cn/upload/pic/6465.png) 

那么她可以选取最下面一行的 $1\times4$ 的子海域，也可以选择第三列的 $3\times1$ 的子海域。注意她不能选取最上面一行的 $1\times5$ 的子海域，因为它没有与海滩相邻。

为了让朋友们玩的开心，她想让游泳场的面积尽可能的大。因此她会选取最下面那一行的 $1\times4$ 的子海域作为最终方案。

虽然她要明天才能知道每一个单位海域是否安全，但是她现在就想行动起来估计一下她的游泳场面积有多大。经过简单的估计，她假设每一个单位海域都有独立的 $q$ 的概率是安全的，$1 − q$ 的概率是不安全的。她想要知道她能选择的最大的游泳场的面积**恰好**为 $K$ 的概率是多少。

然而久莲对数学并不感兴趣，因此她想让你来帮她计算一下这个数值。
## 输入格式

输入一行四个正整数 $N,K,x,y$，其中 $1 \leq x < y < 998\,244\,353$。$q$ 的取值为 $\dfrac{x}{y}$。
## 输出格式

输出一行一个整数表示答案在模 $998\,244\,353$ 意义下的取值。

即设答案化为最简分式后的形式为 $\dfrac{a}{b}$ ，其中 $a$ 和 $b$ 的互质。输出整数 $x$ 使得 $bx \equiv a \mod 998\,244\,353$ 且 $0 \leq x < 998\,244\,353$。可以证明这样的整数 $x$ 是唯一的。 
## 样例

### 样例输入 #1
```
10 5 1 2
```
### 样例输出 #1
```
342025319
```
## 提示

| 测试点编号 | $N$ | $K$ |
|:-:|:-:|:-:|
| 1,2 | $=1$ | $\leq 1000$ |
| 3 | $\leq 10$ | $\leq 8$ |
| 4 | $\leq 10$ | $\leq 9$ |
| 5 | $\leq 10$ | $\leq 10$ |
| 6 | $\leq 1000$ | $\leq 7$ |
| 7 | $\leq 1000$ | $\leq 8$ |
| 8 | $\leq 1000$ | $\leq 9$ |
| 9,10,11 | $\leq 1000$ | $\leq 100$ |
| 12,13,14 | $\leq 1000$ | $\leq 1000$ |
| 15,16 | $\leq 10^9$ | $\leq 10$ |
| 17,18 | $\leq 10^9$ | $\leq 100$ |
| 19,20 | $\leq 10^9$ | $\leq 1000$ |


---

---
title: "[NOI2017] 蔬菜"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P3826
tag: ['贪心', '递推', '2017', 'NOI', 'O2优化', '栈']
---
# [NOI2017] 蔬菜
## 题目描述

小 N 是蔬菜仓库的管理员，负责设计蔬菜的销售方案。

在蔬菜仓库中，共存放有 $n$ 种蔬菜，小 N 需要根据不同蔬菜的特性，综合考虑各方面因素，设计合理的销售方案，以获得最多的收益。

在计算销售蔬菜的收益时，每销售一个单位第 $i$ 种蔬菜，就可以获得 $a_i$ 的收益。

特别地，由于政策鼓励商家进行多样化销售，第一次销售第 $i$ 种蔬菜时，还会额外得到 $s_i$ 的额外收益。

在经营开始时，第 $i$ 种蔬菜的库存为 $c_i$ 个单位。

然而，蔬菜的保鲜时间非常有限，一旦变质就不能进行销售，不过聪明的小 N 已 经计算出了每个单位蔬菜变质的时间：对于第 $i$ 种蔬菜，存在保鲜值 $x_i$，每天结束时会 有 $x_i$ 个单位的蔬菜变质，直到所有蔬菜都变质。（注意：每一单位蔬菜的变质时间是固定的，不随销售发生变化）

形式化地：对于所有的满足条件 $d\times x_i \leq c_i$ 的正整数 $d$ ，有 $x_i$ 个单位的蔬菜将在 第 $d$ 天结束时变质。

特别地，若 $(d - 1)\times x_i \leq c_i < d\times x_i$ ，则有 $c_i - (d - 1)\times x_i$ 单位的蔬菜将在第 $d$ 天结束时变质。

注意，当 $x_i = 0$ 时，意味着这种蔬菜不会变质。

同时，每天销售的蔬菜，总量也是有限的，最多不能超过 $m$ 个单位。

现在，小 N 有 $k$ 个问题，想请你帮忙算一算。每个问题的形式都是：对于已知的 $p_j$，如果需要销售 $p_j$ 天，最多能获得多少收益？
## 输入格式

第一行包含三个正整数 $n,m,k$，分别表示蔬菜的种类数目、每天能售出蔬菜总量上限、小 N 提出的问题的个数。

接下来 $n$ 行，每行输入四个非负整数，描述一种蔬菜的特点，依次为 $a_i,s_i,c_i,x_i$ ， 意义如上文所述。

接下来 $k$ 行，每行输入一个非负整数 $p_j$ ，意义如上文所述。
## 输出格式

输出 $k$ 行，每行包含一个整数，第 $i$ 行的数表示第 $i$ 个问题的答案。
## 样例

### 样例输入 #1
```
2 3 2
3 3 3 3
2 5 8 3
1
3

```
### 样例输出 #1
```
16
27

```
## 提示

### 样例解释

共有两种蔬菜：

销售第 $1$ 种蔬菜时，每销售一单位可以获得的收益为 $3$，第一次销售这种蔬菜时，额外可以获得的收益为 $3$。这种蔬菜共有 $3$ 个单位，均会在第一天结束时变质。

销售第 $2$ 种蔬菜时，每销售一单位可以获得的收益为 $2$，第一次销售这种蔬菜时，额外可以获得的收益为 $5$。这种蔬菜共有 $8$ 个单位，其中，有 $3$ 单位在第一天结束时变质，$3$ 单位在第二天结束时变质，$2$ 单位在第三天结束时变质。

在只销售 $1$ 天时，应当销售 $2$ 单位的第一种蔬菜和 $1$ 单位的第二种蔬菜。

在这种情况下：销售第一种蔬菜的收益为 $2 \times 3 + 3$；销售第二种蔬菜的收益为 $1 \times 2 + 5$；总共获得的收益为 $(2 \times 3 + 3) + (1 \times 2 + 5) = 16$。

在只销售 $3$ 天时，第一天应当销售 $3$ 单位的第一种蔬菜，第二天应当销售 $3$ 单位的第二种蔬菜（此时选择在第二天结束时会变质的 $3$ 个单位出售），第三天销售 $2$ 单位的第二种蔬菜。

在这种情况下：销售第一种蔬菜的收益为 $3 \times 3 + 3$；销售第二种蔬菜的收益为 $(3 + 2) \times 2 + 5$；总共获得的收益为 $(3 \times 3 + 3) + [(3 + 2) \times 2 + 5] = 27$。

### 数据范围

| 测试点编号 |    $n$     |   $m$    |   $p_j$    | 特性 $1$ |    特性 $2$    |
| :--------: | :--------: | :------: | :--------: | :------: | :------------: |
|    $1$     |  $\le 2$   | $\le 10$ | $\le 10^3$ |    无    |       无       |
|    $2$     |  $\le 3$   | $\le 10$ | $\le 10^3$ |    无    |       无       |
|    $3$     |  $\le 4$   | $\le 10$ | $\le 10^3$ |    无    |       无       |
|    $4$     | $\le 10^3$ | $\le 10$ |  $\le 2$   |    无    |       无       |
|    $5$     | $\le 10^3$ | $\le 10$ |  $\le 3$   |    无    |       无       |
|    $6$     | $\le 10^3$ | $\le 10$ |  $\le 4$   |    无    |       无       |
|    $7$     |  $\le 4$   | $\le 1$  |  $\le 4$   |    无    |       无       |
|    $8$     |  $\le 6$   | $\le 2$  |  $\le 6$   |    无    |       无       |
|    $9$     |  $\le 8$   | $\le 1$  |  $\le 8$   |    无    |       无       |
|    $10$    |  $\le 10$  | $\le 2$  |  $\le 10$  |    无    |       无       |
|    $11$    |  $\le 20$  | $\le 3$  |  $\le 20$  |    无    |       无       |
|    $12$    | $\le 10^2$ | $\le 10$ | $\le 10^2$ |    有    | 无 |
|    $13$    | $\le 10^2$ | $\le 10$ | $\le 10^2$ |    无    |       有       |
|    $14$    | $\le 10^2$ | $\le 10$ | $\le 10^2$ |    无    | 无 |
|    $15$    | $\le 10^2$ | $\le 10$ | $\le 10^2$ |    无    | 无 |
|    $16$    | $\le 10^3$ | $\le 10$ | $\le 10^3$ |    有    | 有 |
|    $17$    | $\le 10^3$ | $\le 10$ | $\le 10^3$ |    有    | 无 |
|    $18$    | $\le 10^3$ | $\le 10$ | $\le 10^3$ |    无    |       有       |
|    $19$    | $\le 10^3$ | $\le 10$ | $\le 10^3$ |    无    | 无 |
|    $20$    | $\le 10^3$ | $\le 10$ | $\le 10^3$ |    无    | 无 |
|    $21$    | $\le 10^5$ | $\le 10$ | $\le 10^5$ |    有    | 有 |
|    $22$    | $\le 10^5$ | $\le 10$ | $\le 10^5$ |    有    |       无       |
|    $23$    | $\le 10^5$ | $\le 10$ | $\le 10^5$ |    无    |       有       |
|    $24$    | $\le 10^5$ | $\le 10$ | $\le 10^5$ |    无    |       无       |
|    $25$    | $\le 10^5$ | $\le 10$ | $\le 10^5$ |    无    |       无       |

特性 $1$：所有的 $s_i$ 均为 $0$；

特性 $2$：所有的 $x_i$ 均为 $0$。

对于所有的测试数据，均保证 $k$ 组询问中的 $p_j$ 互不相同。

对于所有的测试数据，均保证 $0<a_i,c_i\le 10^9$，$0\le s_i,x_i\le 10^9$。



---

---
title: "[NOI2017] 分身术"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P3827
tag: ['2017', 'NOI', 'O2优化']
---
# [NOI2017] 分身术
## 题目描述

> “分！身！术！” —— 小 P

平面上有 $n$ 个小 P 的分身。定义一组分身占领的区域为覆盖这组分身的最小凸多边形。小 P 能力有限，每一时刻都会有若干分身消失。但在下一时刻之前，小 P 会使用分身术使得这些消失的分身重新出现在原来的位置。

小 P 想知道，每一时刻分身消失后，剩下的分身占领的区域面积是多少？

## 输入格式

输入第一行包含两个正整数 $n,m$，描述初始时分身的个数，和总时刻数。

接下来 $n$ 行，第 $i$ 行有两个整数 $x_i, y_i$ ，描述第 $i$ 个分身的位置。

接下来 $m$ 行，每行的第一个整数 $k$ 表示这一时刻有 $k$ 个分身消失。接下来有 $k$ 个非负整数 $c_1, c_2, \ldots, c_k$，用于生成消失的分身的编号。

生成方式如下：

设上一个时刻中，分身占领面积的**两倍**为 $S$。则该时刻消失的分身 $p_1, p_2, \ldots , p_k$ 的编号为：$p_i = [(S + c_i) \bmod n] + 1$。

特别的，在第一个时刻，我们认为上一个时刻中，$S = -1$，即：第一个时刻消失的分身$p_1, p_2, \ldots , p_k$的编号为：$p_i = [(−1 + c_i) \bmod n] + 1$。
## 输出格式

按给出时刻的顺序依次输出 $m$ 行，每行一个整数，表示该时刻剩余分身所占领区域面积的**两倍**。
## 样例

### 样例输入 #1
```
6 2
-1 0
-1 -1
0 -1
1 0
0 1
0 0
3 1 3 6
2 0 1

```
### 样例输出 #1
```
3
2

```
## 提示

### 样例解释

如下图所示：左图表示输入的 $6$ 个分身的位置及它们占领的区域；中图表示第一个时刻的情形，消失的分身编号分别为 $1,3,6$，剩余 $3$ 个点占领图中实线内部区域，占据面积的两倍为 $3$；右图表示第二个时刻的情形，消失的分身编号分别为

$[(0 + 3)\bmod 6] + 1 = 4$

$[(1 + 3)\bmod 6] + 1 = 5$

剩余的 $4$ 个点占领图中实线内部区域。

![](https://cdn.luogu.com.cn/upload/image_hosting/bieyspo4.png) 

对于所有数据，保证：

-  $|x_i|,|y_i|\le 10^8$ ；
- 没有两个分身的坐标是完全相同的；
-  $k\le 100$ ；
- 所有时刻的  $k$ 之和不超过  $2\times 10^6$ ；
-  $0\le c_i\le 2^{31}-1$ ；
- 初始时，所有的  $n$ 个分身占据区域面积大于  $0$ ；
- 定义所有  $n$ 个分身所占据区域的**顶点集合**为  $S$ ，  $|S|\ge 3$ 。在任意时刻，  $S$ 中至少存在两个未消失的分身。

| 测试点编号 | $n \leq$ | $m \leq$ |    $k$     |
| :--------: | :------: | :------: | :--------: |
|    $1$     |   $10$   |   $10$   | $\leq n-3$ |
|    $2$     |  $10^3$  |  $10^3$  | $\leq n-3$ |
|    $3$     |  $10^3$  |  $10^3$  | $\leq n-3$ |
|    $4$     |  $10^3$  |  $10^3$  | $\leq n-3$ |
|    $5$     |  $10^5$  |  $10^5$  |    $=1$    |
|    $6$     |  $10^5$  |  $10^5$  |    $=1$    |
|    $7$     |  $10^5$  |  $10^5$  |    $=1$    |
|    $8$     |  $10^5$  |  $10^5$  |    $=1$    |
|    $9$     |  $10^5$  |  $10^5$  |    $=2$    |
|    $10$    |  $10^5$  |  $10^5$  |    $=2$    |
|    $11$    |  $10^5$  |  $10^5$  |  $\leq 3$  |
|    $12$    |  $10^5$  |  $10^5$  |  $\leq 5$  |
|    $13$    |  $10^5$  |  $10^5$  |  $\leq 9$  |
|    $14$    |  $10^5$  |  $10^5$  | $\leq 12$  |
|    $15$    |  $10^5$  |  $10^5$  | $\leq 20$  |
|    $16$    |  $10^5$  |  $10^5$  | $\leq 100$ |
|    $17$    |  $10^5$  |  $10^5$  | $\leq 100$ |
|    $18$    |  $10^5$  |  $10^5$  | $\leq 100$ |
|    $19$    |  $10^5$  |  $10^5$  | $\leq 100$ |
|    $20$    |  $10^5$  |  $10^5$  | $\leq 100$ |


---

---
title: "[NOI2008] 奥运物流"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4202
tag: ['2008', 'NOI']
---
# [NOI2008] 奥运物流
## 题目描述

2008 北京奥运会即将开幕，举国上下都在为这一盛事做好准备。为了高效率、 成功地举办奥运会，对物流系统进行规划是必不可少的。

物流系统由若干物流基站组成，以 $1$ 到 $n$ 进行编号。每个物流基站 $i$ 都有且仅有一个后继基站 $S_i$，而可以有多个前驱基站。基站 $i$ 中需要继续运输的物资都将被运往后继基站 $S_i$，显然一个物流基站的后继基站不能是其本身。编号为 $1$ 的 物流基站称为控制基站，从任何物流基站都可将物资运往控制基站。注意控制基站也有后继基站，以便在需要时进行物资的流通。在物流系统中，高可靠性与低成本是主要设计目的。对于基站 $i$，我们定义其“可靠性” $R(i)$ 如下： 
设物流基站 $i$ 有 $w$ 个前驱基站 $P_1,P_2,\cdots,P_w$，即这些基站以 $i$ 为后继基站，则基 站 $i$ 的可靠性 $R(i)$ 满足下式： 
$$R(i)=C_i+k \sum_{j=1}^{w}R(P_j).$$

其中 $C_i$ 和 $k$ 都是常实数且恒为正，且有 $k$ 小于 $1$。

整个系统的可靠性与控制基站的可靠性正相关，我们的目标是通过修改物流系统，即更改某些基站的后继基站，使得控制基站的可靠性 $R(1)$ 尽量大。但由于经费限制，最多只能修改 $m$ 个基站的后继基站，并且，控制基站的后继基站不可被修改。因而我们所面临的问题就是，如何修改不超过 $m$ 个基站的后继，使得控制基站的可靠性 $R(1)$ 最大化。

## 输入格式

第一行包含两个整数与一个实数，$n,m,k$。其中 $n$ 表示基站数目，$m$ 表示最多可修改的后继基站数目，$k$ 分别为可靠性定义中的常数。

第二行包含 $n$ 个整数，分别是 $S_1,S_2\cdots,S_n$，即每一个基站的后继基站编号。

第三行包含 $n$ 个正实数，分别是 $C_1,C_2\cdots,C_n$，为可靠性定义中的常数。
## 输出格式

仅包含一个实数，为可得到的最大 $R(1)$。精确到小数点两位。
## 样例

### 样例输入 #1
```
4 1 0.5  
2 3 1 3 
10.0 10.0 10.0 10.0
```
### 样例输出 #1
```
30.00 

```
## 提示

【样例说明】 
原有物流系统如左图所示，$4$ 个物流基站的可靠性依次为 $22.8571,21.4286,25.7143,10$。

最优方案为将 $2$ 号基站的后继基站改为 $1$ 号。

此时 $4$ 个基站的可靠性依次为 $30,25,15,10$。
本题的数据，具有如下分布： 

测试数据编号| $n$ | $m$
:-:|:-:|:-:
$1$|$\leq6$| $\leq6$
$2$|$\leq12$|$\leq12$
$3$|$\leq60$|$0$
$4$|$\leq60$|$1$
$5$|$\leq 60$|$N-2$
$6,7,8,9,10$|$\leq60$|$\leq60$

 对于所有的数据，满足 $m \leq n \leq 60$，$C_i \leq 10^6$，$0.3 \leq k < 1$，请使用双精度实数，无需考虑由此带来的误差。


---

---
title: "[NOI2008] 糖果雨"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4203
tag: ['2008', 'NOI']
---
# [NOI2008] 糖果雨
## 题目描述

有一个美丽的童话：在天空的尽头有一个"糖果国"，这里大到摩天大厦，小 到小花小草都是用糖果建造而成的。更加神奇的是，天空中飘满了五颜六色的糖 果云，很快糖果雨密密麻麻从天而落，红色的是草莓糖，黄色的是柠檬糖，绿色 的是薄荷糖，黑色的是巧克力糖……这时糖果国的小朋友们便会拿出大大小小的 口袋来接天空中落下的糖果，拿回去与朋友们一起分享。

对糖果情有独钟的小 Z 憧憬着能够来到这样一个童话的国度。所谓日有所 思，夜有所梦，这天晚上小 Z 梦见自己来到了"糖果国"。他惊喜地发现，任何时 候天空中所有的云朵颜色都不相同，不同颜色的云朵在不断地落下相应颜色的糖 果。更加有趣的是所有的云朵都在做着匀速往返运动，不妨想象天空是有边界的， 而所有的云朵恰好在两个边界之间做着往返运动。每一个单位时间云朵向左或向 右运动一个单位，当云朵的左界碰到天空的左界，它会改变方向向右运动；当云 朵完全移出了天空的右界，它会改变方向向左运动。

我们不妨把天空想象为一个平面直角坐标系，而云朵则抽象为线段(线段可 能退化为点)： 

![](https://cdn.luogu.com.cn/upload/image_hosting/hsdveny3.png)

如上图，不妨设天空的左界为 0，右界为 len。图中共有 5 片云朵，其中标 号为 1 的云朵恰好改变方向向右运动，标号为 2 的云朵恰好改变方向向左运动。

忽略云朵的纵坐标，它们在运动过程中不会相互影响。

小 Z 发现天空中会不断出现一些云朵(某个时刻从某个初始位置开始朝某个 方向运动)，而有的云朵运动到一定时刻就会从天空中消失，而在运动的过程中 糖果在不断地下落。小 Z 决定拿很多口袋来接糖果，口袋容量是无限的，但袋 口大小却是有限的。例如在时刻 T 小 Z 拿一个横坐标范围为[L, R]的口袋来接糖 果，如果[L, R]存在一个位置 x，该位置有某种颜色的糖果落下，则认为该口袋可 接到此种颜色的糖果。极端情况下，袋口区间可能是一个点，譬如[0,0]、[1,1]，但仍然可以接到相应位置的糖果。通常可以接到的糖果总数会很大，因而小 Z 想知道每一次(即拿出口袋的一瞬间)他的口袋可以接到多少种不同颜色的糖果。

糖果下落的时间忽略不计。
## 输入格式

输入文件第一行有两个正整数 n, len，分别表示事件总数以及天空 的“边界”。

    接下来 n 行每行描述一个事件，所有的事件按照输入顺序依次发生。每行的 第一个数 k（k = 1，2，3）分别表示事件的类型，分别对应三种事件：插入事件， 询问事件以及删除事件。输入格式如下： 

事件类型|输入格式|说明 
-|-|-
插入事件 (天空中出现了一片 云朵)|`1 Ti Ci Li Ri Di`|时刻 Ti，天空中出现了一片 坐标范围为[Li, Ri]，颜色为 Ci的 云朵，初始的时候云朵运动方向 为向左(Di = -1)或向右(Di = 1)。满足 0 ≤ Li ≤ Ri ≤ len，Di = -1 或 1。数据保证任何时刻空中不 会出现两片颜色相同的云朵。
询问事件 (询问一个口袋可以 接到多少种不同颜 色的糖果)|`2 Ti Li Ri` |时刻 Ti，小 Z 用一个坐标范 围为[Li, Ri]的大口袋去接糖果， 询问可以接到多少种不同的糖 果。满足 0 ≤ Li ≤ Ri ≤ len。
删除事件 (天空中一片云朵消 失了)|`3 Ti Ci` |时刻 Ti，颜色为 Ci的云朵从 天空消失中。数据保证当前天空 中一定存在一片颜色为 Ci的云 朵。
## 输出格式

对于每一个询问事件，输出中应包含相应的一行，为该次询 问的答案，即口袋可以接到多少种不同的糖果。
## 样例

### 样例输入 #1
```
10 10 
1 0 10 1 3 -1 
2 1 0 0 
2 11 0 10 
2 11 0 9 
1 11 13 4 7 1 
2 13 9 9 
2 13 10 10 
3 100 13 
3 1999999999 10 
1 2000000000 10 0 1 1
```
### 样例输出 #1
```
1 
1 
0 
2 
1 

```
## 提示

【样例说明】 

共 10 个事件，包括 3 个插入事件，5 个询问事件以及 2 个删除事件。

时刻 0，天空中出现一片颜色为 10 的云朵，初始位置为[1, 3]，方向向左。

时刻 1，范围为[0, 0]的口袋可以接到颜色为 10 的糖果(云朵位置为[0, 2])。

 时刻11，范围为[0,10]的口袋可以接到颜色为10的糖果(云朵位置为[10, 12])。
 时刻 11，范围为[0, 9]的口袋不能接到颜色为 10 的糖果(云朵位置为[10, 12])。
 时刻 11, 天空中出现一片颜色为 13 的云朵, 初始位置为[4, 7], 方向向右。

时刻 13，范围为[9, 9]的口袋可以接到颜色为 10(云朵的位置为[8, 10])和颜色 为 13(云朵的位置为[6, 9])两种不同的糖果。

时刻 13，范围为[10, 10]的口袋仅仅可以接到颜色为 10 的一种糖果(云朵的位 置为[8, 10])，而不可以接到颜色为 13 的糖果(云朵的位置为[6, 9]),。

时刻 100, 颜色为 13 的云朵从天空中消失。

时刻 1999999999，颜色为 10 的云朵从天空中消失。

时刻 2000000000，天空中又出现一片颜色为 10 的云朵，初始位置为[0, 1]， 方向向右。

【数据范围】

对于所有的数据，0 ≤ Ti ≤ 2000000000，1 ≤ Ci ≤ 1000000。

数据保证{Ti}为非递减序列即 T1 ≤ T2 ≤ … ≤ Tn-1 ≤ Tn。

对于所有的插入事件，令 Pi = Ri – Li，即 Pi表示每片云朵的长度。


数据编号|n|len|Pi|数据编号|n|len|Pi
-|-|-|-|-|-|-|-
1|20|10|≤len|6|150000|1000|≤3
2|200|100|≤len|7|200000|1000|≤3
3|2000|1000|≤len|8|100000|1000|≤len
4|100000|10|≤len|9|150000|1000|≤len
5|100000|100|≤2|10|200000|1000|≤len



---

---
title: "[NOI2005] 月下柠檬树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4207
tag: ['计算几何', '2005', '递归', 'NOI', '积分']
---
# [NOI2005] 月下柠檬树
## 题目描述

李哲非常非常喜欢柠檬树，特别是在静静的夜晚，当天空中有一弯明月温柔地照亮地面上的景物时，他必会悠闲地坐在他亲手植下的那棵柠檬树旁，独自思索着人生的哲理。

李哲是一个喜爱思考的孩子，当他看到在月光的照射下柠檬树投在地面上的影子是如此的清晰，马上想到了一个问题：树影的面积是多大呢？

李哲知道，直接测量面积是很难的，他想用几何的方法算，因为他对这棵柠檬树的形状了解得非常清楚，而且想好了简化的方法。

李哲将整棵柠檬树分成了 $n$ 层，由下向上依次将层编号为 $1,2,...,n$。从第 $1$ 到 $n-1$ 层，每层都是一个圆台型，第 $n$ 层(最上面一层)是圆锥型。对于圆台型， 其上下底面都是水平的圆。对于相邻的两个圆台，上层的下底面和下层的上底面重合。第 $n$ 层(最上面一层)圆锥的底面就是第 $n-1$ 层圆台的上底面。所有的底面 的圆心(包括树顶)处在同一条与地面垂直的直线上。李哲知道每一层的高度为 $h_1,h_2,...,h_n$，第 $1$ 层圆台的下底面距地面的高度为 $h_0$，以及每层的下底面的圆的半径 $r_1,r_2,...,r_n$。李哲用熟知的方法测出了月亮的光线与地面的夹角为 $\mathrm{alpha}$。

![](https://cdn.luogu.com.cn/upload/pic/13770.png)

为了便于计算，假设月亮的光线是平行光，且地面是水平的，在计算时忽略树干所产生的影子。李哲当然会算了，但是他希望你也来练练手。
## 输入格式

第一行包含一个整数 $n$ 和一个实数 $\mathrm{alpha}$，表示柠檬树的层数和月亮 的光线与地面夹角（单位为弧度）。

第二行包含 $n+1$ 个实数 $h_0,h_1,h_2,...,h_n$ 表示树离地的高度和每层的高度。

第三行包含 $n$ 个实数 $r_1,r_2,...,r_n$ 表示柠檬树每层下底面的圆的半径。

同一行相邻的两个数之间用一个空格分隔。

输入的所有实数的小数点后可能包含一至十位有效数字。
## 输出格式

输出一个实数，表示树影的面积，四舍五入保留两位小数。
## 样例

### 样例输入 #1
```
2  0.7853981633 
10.0  10.00  10.00 
4.00  5.00
```
### 样例输出 #1
```
171.97
```
## 提示

对于 $10 \%$ 的数据，$n \leq 1$；

对于 $30 \%$ 的数据，$n \leq 2$；

对于 $60 \%$ 的数据，$n \leq 20$；

对于 $100 \%$ 的数据，$1 \leq n \leq 500$，$0.3 < \mathrm{alpha} < \frac{\pi}{2}$，$0 < h_i \leq 100$，$0 < r_i \leq 100$。


---

---
title: "[NOI2006] 聪明的导游"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4252
tag: ['2006', 'NOI', '提交答案', 'Special Judge', 'O2优化']
---
# [NOI2006] 聪明的导游
## 题目背景

输入数据下载地址：

https://pan.baidu.com/s/1jJX0E3c

数据由1584432137提供。

Upd on 2022.8.7：输入文件在附件。
## 题目描述

小佳最近迷上了导游这个工作，一天到晚想着带游客参观各处的景点。正好 M 市在举行 NOI，来参观的人特别的多。不少朋友给小佳介绍了需要导游的人。

M 市有$n$个著名的景点，小佳将这些景点从$1$至$n$编号。有一些景点之间存在双向的路。小佳可以让游客们在任何一个景点集合，然后带着他们参观，最后也可以在任何一个景点结束参观。不过，来参观的游客们都不愿去已经参观过的地方。所以，小佳不能带游客们经过同一个景点两次或两次以上。

小佳希望你帮助他设计一个方案, 走可行的路线, 带游客们参观尽可能多的地方。
## 输入格式

输入文件为 guide1.in~guide10.in，第一行为两个整数$n,m$，分别表示景点数和路的条数。接下来$m$行，每行两个整数$a,b$，表示景点$a$和景点$b$之间有一条双向路。
## 输出格式

你需要将答案输出到 guide1.out~guide10.out 中，guide?.out 为对应 guide?.in

的答案。输出的第一行为$p$，表示你能找到的路径所经过的景点个数。接下来$p$ 行，每行一个整数，按顺序表示你所找到的路径上的每一个景点。
## 样例

### 样例输入 #1
```
5 5
1 2
3 2
2 4
2 5
4 5

```
### 样例输出 #1
```
4
1
2
4
5

```
## 提示

【说明】

这是一道提交答案式的题目，你不需要提供任何源代码，只需要将自己的输出文件放在与*.in 同一个目录即可。

【样例说明】				
题目可能有多解，该样例有 4 个解，你只需输出其中任何一个解。

|解$1$|解$2$|解$3$|解$4$|
| :----------: | :----------: | :----------: | :----------: |
|4  |4  |4  |4  |
|1  |1  |3  |3  |
|2  |2  |2  |2  |
|4  |5  |4  |5  |
|5  |4  |5  |4  |

【评分方法】

你的评分将由你的答案与标准答案之间的差异来给定。设你的答案正确且参观的景点数为 x，我们所给出的结果为 ans，则按下表计算你的得分：

|得分|条件|得分|条件|
| :-----------: | :-----------: | :-----------: | :-----------: |
|$12$  |$x>ans$  |$5$  |$x \leq ans \times 0.93$  |
|$10$  |$x=ans$  |$4$  |$x \leq ans \times 0.9$  |
|$9$  |$x \leq ans-1$  |$3$  |$x \leq ans \times 0.8$  |
|$8$  |$x \leq ans-2$  |$2$  |$x \leq ans \times 0.7$  |
|$7$  |$x \leq ans-3$  |$1$  |$x \leq ans \times 0.5$  |
|$6$  |$x \leq ans \times 0.95$  |$0$  |$x \leq ans < 0.5$  |

如果有多项满足，则取满足条件中的最高得分。


---

---
title: "[NOI2006] 网络收费"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4297
tag: ['2006', 'NOI', 'O2优化', '最近公共祖先 LCA', '状压 DP']
---
# [NOI2006] 网络收费
## 题目背景

noi2006 day1t1

## 题目描述

网络已经成为当今世界不可或缺的一部分。每天都有数以亿计的人使用网络进行学习、科研、娱乐等活动。然而，不可忽视的一点就是网络本身有着庞大的运行费用。所以，向使用网络的人进行适当的收费是必须的，也是合理的。

MY 市NS 中学就有着这样一个教育网络。网络中的用户一共有$2^N$个，编号依次为1, 2, 3, …, $2^N$。这些用户之间是用路由点和网线组成的。用户、路由点与网线共同构成一个满二叉树结构。树中的每一个叶子结点都是一个用户，每一个非叶子结点（灰色）都是一个路由点，而每一条边都是一条网线（见下图，用户结点中的数字为其编号）。

 ![](https://cdn.luogu.com.cn/upload/pic/12807.png) 

MY 网络公司的网络收费方式比较奇特，称为“ 配对收费 ”。即对于每两个用户$i, j (1≤i < j ≤2^N )$ 进行收费。由于用户可以自行选择两种付费方式A、B中的一种，所以网络公司向学校收取的费用与每一位用户的付费方式有关。该费用等于每两位不同用户配对产生费用之和。

为了描述方便，首先定义这棵网络树上的一些概念：

- 祖先：根结点没有祖先，非根结点的祖先包括它的父亲以及它的父亲的祖先；
- 管辖叶结点：叶结点本身不管辖任何叶结点，非叶结点管辖它的左儿子所管辖的叶结点与它的右儿子所管辖的叶结点；
- 距离：在树上连接两个点之间的用边最少的路径所含的边数。

对于任两个用户$i, j (1≤i<j≤2^N )$，首先在树上找到与它们距离最近的公共祖先：路由点$P$，然后观察$P$ 所管辖的叶结点（即用户）中选择付费方式A 与B的人数，分别记为$n_A$ 与$n_B$，接着按照网络管理条例第X 章第Y 条第Z 款进行收费（如下表），其中$F_{i,j}$ 为$i$ 和$j$ 之间的流量，且为已知量。

 ![](https://cdn.luogu.com.cn/upload/pic/12809.png) 

由于最终所付费用与付费方式有关，所以NS 中学的用户希望能够自行改变自己的付费方式以减少总付费。然而，由于网络公司已经将每个用户注册时所选择的付费方式记录在案，所以对于用户$i$，如果他/她想改变付费方式（由A 改为B 或由B 改为A），就必须支付$C_i$ 元给网络公司以修改档案（修改付费方式记录）。

现在的问题是，给定每个用户注册时所选择的付费方式以及$C_i$，试求这些用户应该如何选择自己的付费方式以使得NS 中学支付给网络公司的总费用最少（更改付费方式费用+配对收费的费用）。

## 输入格式

输入文件中第一行有一个正整数N。

第二行有$2^N$ 个整数，依次表示$1$ 号，$2$ 号，…，$2^N$ 号用户注册时的付费方式，每一个数字若为`0`，则表示对应用户的初始付费方式为A，否则该数字为`1`，表示付费方式为B。

第三行有$2^N$ 个整数，表示每一个用户修改付费方式需要支付的费用，依次为$C_1$, $C_2$, …,$C_M$。( M=$2^N$ )

以下 $2^N$-1 行描述给定的两两用户之间的流量表F，总第(i + 3)行第j 列的整数为$F_{i, j+i}$ 。（1≤i<$2^N$，1≤j≤$2^N$ – i）

所有变量的含义可以参见题目描述。

## 输出格式

你的程序只需要向输出文件输出一个整数，表示NS 中学支付给网络公司的最小总费用。（单位：元）

## 样例

### 样例输入 #1
```
2
1 0 1 0
2 2 10 9
10 1 2
2 1
3
```
### 样例输出 #1
```
8
```
## 提示

【样例说明】

将 1 号用户的付费方式由B 改为A，NS 中学支付给网络公司的费用达到最小。

【数据范围】

40%的数据中$N≤4$；  
80%的数据中$N≤7$；  
100%的数据中$N≤10$，$0≤F_{i, j}≤500$，$0≤C_i≤500 000$。



---

---
title: "[NOI2018] 冒泡排序"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4769
tag: ['2018', '树状数组', 'NOI', 'O2优化', 'Catalan 数', '栈']
---
# [NOI2018] 冒泡排序
## 题目背景

请注意，题目中存在 $n=0$ 的数据。
## 题目描述

最近，小 S 对冒泡排序产生了浓厚的兴趣。为了问题简单，小 S 只研究对 **$1$ 到 $n$ 的排列**的冒泡排序。

下面是对冒泡排序的算法描述。

```plain
输入：一个长度为 n 的排列 p[1...n]
输出：p 排序后的结果。
for i = 1 to n do
	for j = 1 to n - 1 do
		if(p[j] > p[j + 1])
			交换 p[j] 与 p[j + 1] 的值
```

冒泡排序的交换次数被定义为交换过程的执行次数。可以证明交换次数的一个下界是 $\frac 1 2 \sum_{i=1}^n \lvert i - p_i \rvert$，其中 $p_i$ 是排列 $p$ 中第 $i$ 个位置的数字。如果你对证明感兴趣，可以看提示。

小 S 开始专注于研究长度为 $n$ 的排列中，满足交换次数 $= \frac 1 2 \sum_{i=1}^n \lvert i - p_i \rvert$ 的排列（在后文中，为了方便，我们把所有这样的排列叫「好」的排列）。他进一步想，这样的排列到底多不多？它们分布的密不密集？

小 S 想要对于一个给定的长度为 $n$ 的排列 $q$，计算字典序严格大于 $q$ 的“好”的排列个数。但是他不会做，于是求助于你，希望你帮他解决这个问题，考虑到答案可能会很大，因此只需输出答案对 $998244353$ 取模的结果。
## 输入格式

输入第一行包含一个正整数 $T$，表示数据组数。

对于每组数据，第一行有一个正整数 $n$，保证 $n \leq 6 \times 10^5$。

接下来一行会输入 $n$ 个正整数，对应于题目描述中的 $q_i$，保证输入的是一个 $1$ 到 $n$ 的排列。
## 输出格式

输出共 $T$ 行，每行一个整数。

对于每组数据，输出一个整数，表示字典序严格大于 $q$ 的「好」的排列个数对 $998244353$ 取模的结果。
## 样例

### 样例输入 #1
```
1
3
1 3 2
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
1
4
1 4 2 3
```
### 样例输出 #2
```
9
```
## 提示

### 更多样例

更多样例请在附加文件中下载。

#### 样例 3

见附加文件中的 `inverse3.in` 与 `inverse3.ans`。

### 样例 1 解释

字典序比 $1 \ 3 \ 2$ 大的排列中，除了 $3 \ 2 \ 1$ 以外都是「好」的排列，故答案为 $3$。

### 数据范围

下面是对本题每个测试点的输入规模的说明。

对于所有数据，均满足 $T = 5$（样例可能不满足）。

记 $n_\mathrm{max}$ 表示每组数据中 $n$ 的最大值，$\sum n$ 表示所有数据的 $n$ 的和。

| 测试点 | $n_\mathrm{max} =$ | $\sum n \leq$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| 1 | $8$ | $5 \ n_\mathrm{max}$ | 无 |
| 2 | $9$ | $5 \ n_\mathrm{max}$ | 无 |
| 3 | $10$ | $5 \ n_\mathrm{max}$ | 无 |
| 4 | $12$ | $5 \ n_\mathrm{max}$ | 无 |
| 5 | $13$ | $5 \ n_\mathrm{max}$ | 无 |
| 6 | $14$ | $5 \ n_\mathrm{max}$ | 无 |
| 7 | $16$ | $5 \ n_\mathrm{max}$ | 无 |
| 8 | $16$ | $5 \ n_\mathrm{max}$ | 无 |
| 9 | $17$ | $5 \ n_\mathrm{max}$ | 无 |
| 10 | $18$ | $5 \ n_\mathrm{max}$ | 无 |
| 11 | $18$ | $5 \ n_\mathrm{max}$ | 无 |
| 12 | $122$ | $700$ | $\forall i \enspace q_i = i$ |
| 13 | $144$ | $700$ | 无 |
| 14 | $166$ | $700$ | 无 |
| 15 | $200$ | $700$ | 无 |
| 16 | $233$ | $700$ | 无 |
| 17 | $777$ | $4000$ | $\forall i \enspace q_i = i$ |
| 18 | $888$ | $4000$ | 无 |
| 19 | $933$ | $4000$ | 无 |
| 20 | $1000$ | $4000$ | 无 |
| 21 | $266666$ | $2000000$ | $\forall i \enspace q_i = i$ |
| 22 | $333333$ | $2000000$ | 无 |
| 23 | $444444$ | $2000000$ | 无 |
| 24 | $555555$ | $2000000$ | 无 |
| 25 | $600000$ | $2000000$ | 无 |

### 提示

下面是对交换次数下界是 $\frac 1 2 \sum_{i=1}^n \lvert i - p_i \rvert$ 的证明。

排序本质上就是数字的移动，因此排序的交换次数应当可以用数字移动的总距离来描述。对于第 $i$ 个位置，假设在初始排列中，这个位置上的数字是 pi，那么我们需要将这个数字移动到第 $p_i$ 个位置上，移动的距离是 $\lvert i - p_i \rvert$。从而移动的总距离就是 $\sum_{i=1}^n \lvert i - p_i \rvert$，而冒泡排序每次会交换两个相邻的数字，每次交换可以使移动的总距离至多减少 $2$。因此 $\frac 1 2 \sum_{i=1}^n \lvert i - p_i \rvert$ 是冒泡排序的交换次数的下界。

并不是所有的排列都达到了下界，比如在 $n = 3$ 的时候，考虑排列 $3 \ 2 \ 1$，这个排列进行冒泡排序以后的交换次数是 $3$，但是 $\frac 1 2 \sum_{i=1}^n \lvert i - p_i \rvert$ 只有 $2$。


---

---
title: "[NOI2018] 你的名字"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4770
tag: ['2018', '线段树', 'NOI', '后缀自动机 SAM', 'O2优化', '后缀数组 SA']
---
# [NOI2018] 你的名字
## 题目背景

实力强大的小 A 被选为了 ION2018 的出题人，现在他需要解决题目的命名问题。
## 题目描述

小 A 被选为了 ION2018 的出题人，他精心准备了一道质量十分高的题目，且已经把除了题目命名以外的工作都做好了。

由于 ION 已经举办了很多届，所以在题目命名上也是有规定的，ION 命题手册规定：每年由命题委员会规定一个小写字母字符串，我们称之为那一年的命名串，要求每道题的名字必须是那一年的命名串的一个非空连续子串，且不能和前一年的任何一道题目的名字相同。

由于一些特殊的原因，小 A 不知道 ION2017 每道题的名字，但是他通过一些特殊手段得到了 ION2017 的命名串，现在小 A 有 $Q$ 次询问：每次给定 ION2017 的命名串和 ION2018 的命名串，求有几种题目的命名，使得这个名字一定满足命题委员会的规定，即是 ION2018 的命名串的一个非空连续子串且一定不会和 ION2017 的任何一道题目的名字相同。

由于一些特殊原因，所有询问给出的 ION2017 的命名串都是某个串的连续子串，详细可见输入格式。


## 输入格式

第一行一个字符串 $S$ ，之后询问给出的 ION2017 的命名串都是 $S$ 的连续子串。
第二行一个正整数 $Q$，表示询问次数。
接下来 $Q$ 行，每行有一个字符串 $T$ 和两个正整数$l,r$，表示询问如果 ION2017 的命名串是 $S_{l\ldots r}$，ION2018 的命名串是 $T$ 的话，有几种命名方式一定满足规定。
## 输出格式

输出 $Q$ 行，第 $i$ 行一个非负整数表示第 $i$ 个询问的答案。
## 样例

### 样例输入 #1
```
scbamgepe
3
smape 2 7
sbape 3 8
sgepe 1 9
```
### 样例输出 #1
```
12
10
4
```
## 提示

### 更多样例

更多样例请在附加文件中下载。

#### 样例 2

见附加文件中的 `name2.in` 与 `name2.ans`。

### 数据范围

|测试点|$\| S\| \leq$　|$Q\leq $　|$\sum \| T\| \leq $　|其他限制|
|:-:|:-:|:-:|:-:|:-:|
|$1$|$200$|$200$|$40000$|$T\leq 200$|
|$2$|$1000$|$200$|$40000$|$T\leq 200$|
|$3$|$1000$|$200$|$40000$|$T\leq 200$|
|$4$|$1000$|$200$|$5 \times 10^5$|无|
|$5$|$1000$|$200$|$5 \times 10^5$|无|
|$6$|$5 \times 10^5$|$1$|$5 \times 10^5$|无|
|$7$|$5 \times 10^5$|$1$|$5 \times 10^5$|无|
|$8$|$10^5$|$10^5$|$2 \times 10^5$|无|
|$9$|$10^5$|$10^5$|$2 \times 10^5$|字符串随机|
|$10$|$2 \times 10^5$|$10^5$|$4 \times 10^5$|无|
|$11$|$2 \times 10^5$|$10^5$|$4 \times 10^5$|字符串随机|
|$12$|$3 \times 10^5$|$10^5$|$6 \times 10^5$|无|
|$13$|$3 \times 10^5$|$10^5$|$6 \times 10^5$|字符串随机|
|$14$|$4 \times 10^5$|$10^5$|$8 \times 10^5$|无|
|$15$|$4 \times 10^5$|$10^5$|$8 \times 10^5$|字符串随机|
|$16$|$5 \times 10^5$|$10^5$|$10^6$|无|
|$17$|$5 \times 10^5$|$10^5$|$10^6$|字符串随机|
|$18$|$2 \times 10^5$|$10^5$|$10^6$|无|
|$19$|$3 \times 10^5$|$10^5$|$10^6$|无|
|$20$|$4 \times 10^5$|$10^5$|$10^6$|无|
|$21$|$5 \times 10^5$|$10^5$|$10^6$|无|
|$22$|$5 \times 10^5$|$10^5$|$10^6$|无|
|$23$|$5 \times 10^5$|$10^5$|$10^6$|无|
|$24$|$5 \times 10^5$|$10^5$|$10^6$|无|
|$25$|$5 \times 10^5$|$10^5$|$10^6$|无|

对于前 $17$ 个测试点的所有询问有 $l=1,r=|S|$。

对于所有数据，保证 $1\leq l \leq r \leq |S|$,$1\leq |T|\leq 5 \times 10^5$

感谢 @Wen_kr 提供的一组 hack 数据。


---

---
title: "[NOI2018] 情报中心"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4775
tag: ['2018', '线段树', 'NOI', 'O2优化', '最近公共祖先 LCA']
---
# [NOI2018] 情报中心
## 题目描述

C 国和 D 国近年来战火纷飞。

最近，C 国成功地渗透进入了 D 国的一个城市。这个城市可以抽象成一张有 $n$ 个节点，节点之间由 $n − 1$ 条双向的边连接的无向图，使得任意两个点之间可以互相到达。也就是说，这张无向图实际上是一棵树。

经过侦查，C 国情报部部长 GGB 惊讶地发现，这座看起来不起眼的城市竟然是 D 国的军事中心。因此 GGB 决定在这个城市内设立情报机构。情报专家 TAC 在侦查后，安排了 $m$ 种设立情报机构的方案。这些方案中，第 $i$ 种方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径的所有边上安排情报人员收集情报，这种方案需要花费 $v_i$ 元的代价。

但是，由于人手不足，GGB 只能安排上述 $m$ 种方案中的两种进行实施。同时 TAC 指出，为了让这两个情报机构可以更好的合作，它们收集情报的范围应**至少有一条公共的边**。为了评估一种方案的性能，GGB 和 TAC 对所有的边进行了勘察，给每一条边制定了一个情报价值 $c_i$，表示收集这条边上的情报能够带来 $c_i$ 元的收益。注意，情报是唯一的，因此当一条边的情报被两个情报机构收集时，也同样只会有 $c_i$ 的收益。

现在，请你帮 GGB 选出两种合法的设立情报机构的方案进行实施，使得这两种方案收集情报的范围至少有一条公共的边，并且在此基础上**总收益减去总代价的差**最大。

注意，这个值可能是负的，但仍然是合法的。如果无法找到这样的两种方案，请输出 `F`。

## 输入格式

从文件 `center.in` 中读入数据。

本题包含多组测试数据。

输入文件的第一行包含一个整数 $T$，表示数据组数；

每组数据包含 $(n + m + 1)$ 行：

第 $1$ 行包含一个整数 $n$，表示城市的点数；

第 $2$ 到第 $n$ 行中，第 $(i + 1)$ 行包含三个整数 $a_i$，$b_i$，$c_i$，表示城市中一条连接节点 $a_i$ 和 $b_i$、情报价值为 $c_i$ 的双向边，保证 $a_i < b_i$ 且 $b_i$ 互不相同；

第 $(n + 1)$ 行包含一个整数 $m$，表示 TAC 设立的 $m$ 种设立情报机构的方案；

第 $(n + 2)$ 到 $(n + m + 1)$ 行中，第 $(n + i + 1)$ 行包含三个整数 $x_i$，$y_i$，$v_i$，表示第 $i$ 种设立情报机构的方案是在节点 $x_i$ 到节点 $y_i$ 的最短路径上的所有边上安排情报人员收集情报，并且需要花费 $v_i$ 元的代价。
## 输出格式

输出到文件 `center.out` 中。

输出文件包含 $T$ 行；

对于每组数据，输出一行：如果存在合法的方案，则输出一个整数表示最大的总收益减去总代价的差；否则输出 `F`。

## 样例

### 样例输入 #1
```
2
5
1 2 1
2 3 3
3 4 2
1 5 8
2
1 4 5
3 5 8
5
1 2 1
2 3 3
3 4 3
1 5 9
2
1 5 5
2 3 8
```
### 样例输出 #1
```
1
F
```
### 样例输入 #2
```
1
11
1 2 2
1 3 0
2 4 1
3 5 7
1 6 0
1 7 1
1 8 1
6 9 3
4 10 2
4 11 8
10
7 10 2
10 7 0
2 11 1
8 6 7
7 7 0
10 1 1
8 2 1
7 8 3
7 7 3
3 9 9

```
### 样例输出 #2
```
13

```
## 提示

### 样例 1 解释

这个样例中包含两组数据。这两组数据的城市相同，只是在情报的价值和情报机构的方案上有所不同。城市地图如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/mfs5k9ob.png)

* 对于第一组数据，方案一中的节点 $1$ 到节点 $4$ 的最短路径为 $1 \rightarrow 2 \rightarrow 3 \rightarrow 4$，方案二中的节点 $3$ 到节点 $5$ 的最短路径为 $3 \rightarrow 2 \rightarrow 1 \rightarrow 5$。选择这两种方案需要花费 $5 + 8 = 13$ 的代价，并且每一条边的情报都被收集从而得到 $1 + 3 + 2 + 8 = 14$ 的收益，因此总收益减去总代价为 $14 − 13 = 1$。
* 对于第二组数据，方案一中的节点 $1$ 到节点 $5$ 的最短路径为 $1 \rightarrow 5$，方案二中的节点 $2$ 到节点 $3$ 的最短路径为 $2 \rightarrow 3$。这两种方案收集情报的范围没有公共的边，因此非法，所以这组数据不存在合法方案，应输出 `F`。

### 样例 2 解释

见附加文件中的 `center2.in` 与 `center2.ans`。

这个样例只包含一组数据。这一数据中，最优方案为选择第 $2$ 种和第 $3$ 种方案。

这组数据的城市地图如下，其中**加粗**的边表示被情报中心收集情报的边，红色的边表示只被第 $2$ 种方案的情报中心收集情报的边，蓝色的边表示只被第 $3$ 种方案的情报中心收集情报的边，紫色的边表示同时被两个情报中心收集情报的边。

![](https://cdn.luogu.com.cn/upload/image_hosting/s9blcjri.png)

### 样例 3

见附加文件中的 `center3.in` 与 `center3.ans`。

这个样例和第 $4$ 个测试点的性质相同。每个测试点的性质见下文的表格。

### 样例 4

见附加文件中的 `center4.in` 与 `center4.ans`。

这个样例，无疑是善良的出题人无私的馈赠。大量精心构造的 $n\le 100,m\le 200$ 的测试数据，涵盖了测试点中所有出现性质的组合。你可以利用这个测试点，对自己的程序进行全面的检查。足量的数据组数、不大的数据范围和多种多样的数据类型，能让程序中的错误无处遁形。出题人相信，这个美妙的样例，可以给拼搏于 AC 这道题的逐梦之路上的你，提供一个有力的援助。

### 数据范围

各测试点的数据规模和性质如下表：

| 测试点 | $n \le$ | $m \le$ | $T \le 50$ | 特殊性质 |
| :-: | :-: | :-: | :-: | :-: |
| 1 | $2$ | $3$ | 保证 | 无 |
| 2 | $10$ | $30$ | 保证 | 无 |
| 3 | $200$ | $300$ | 保证 | 无 |
| 4 | $10^3$ | $2,000$ | 保证 | $a_i = b_i - 1$ |
| 5 | $10^4$ | $3 \times 10^4$ | 保证 | $a_i = b_i - 1$ |
| 6 | $5 \times 10^4$ | $3 \times 10^4$ | 保证 | $a_i = b_i - 1$ |
| 7 | $10^4$ | $3 \times 10^4$ | 保证 | $c_i=0$ |
| 8 | $5 \times 10^4$ | $10^5$ | 保证 | $c_i=0$ |
| 9 | $5 \times 10^4$ | $10^5$ | 保证 | $c_i=0$ |
| 10 | $10^4$ | $n$ | 保证 | $S_1$ |
| 11 | $5 \times 10^4$ | $n$ | 不保证 | $S_1$ |
| 12 | $5 \times 10^4$ | $n$ | 不保证 | $S_1$ |
| 13 | $10^4$ | $3 \times 10^4$ | 保证 | $S_2$ |
| 14 | $10^4$ | $3 \times 10^4$ | 保证 | $S_2$ |
| 15 | $5 \times 10^4$ | $10^5$ | 不保证 | $S_2$ |
| 16 | $5 \times 10^4$ | $10^5$ | 不保证 | $S_2$ |
| 17 | $10^4$ | $3 \times 10^4$ | 保证 | 无 |
| 18 | $5 \times 10^4$ | $ 10^5$ | 保证 | 无 |
| 19 | $5 \times 10^4$ | $ 10^5$ | 不保证 | 无 |
| 20 | $5 \times 10^4$ | $ 10^5$ | 不保证 | 无 |

表格中的特殊性质如下：
* 特殊性质 $S_1$：对于任意 $i, j$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点不同于 $x_j$ 到 $y_j$ 的最短路径所经过的编号最小的节点；

* 特殊性质 $S_2$：对于任意 $i$，保证 $x_i$ 到 $y_i$ 的最短路径所经过的编号最小的节点为节点 $1$。

对于所有的数据，$1 \le n \le 5 \times 10^4$，$0 \le m \le 10^5$，$0 \le c_i \le 10^9$，$0 \le v_i \le 10^{10} \times n$。每个测试点中，所有 $n$ 的和不会超过 $1\,000\,233$，所有 $m$ 的和不会超过 $2\,000\,233$。



---

---
title: "[NOI2018] 多边形"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4776
tag: ['2018', 'NOI', 'O2优化']
---
# [NOI2018] 多边形
## 题目描述

久莲是一个喜欢出题的女孩子。

在今年的 World Final 结束以后，久莲特别喜欢计算几何，于是她打算在 NOI 的考场上也出一个计算几何：这是一道只有题目名字和计算几何相关的题目。

首先，久莲给出了一棵 $n\ (n \ge 2)$ 个节点的有根树 $T$，根节点编号为 $1$。定义叶子节点为除了根以外所有度数恰好为 $1$ 的节点。下图是一个树 $T$ 的例子，其中叶子节点集合为 $\{3, 4, 5\}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/9k8ckocd.png)

接着通过这棵树，久莲构造了一个序列 $A$：
- 从根节点开始深度优先遍历整棵树，遍历时按照编号从小到大的顺序来访问孩子，这样可以得到一个树 $T$ 的 DFS 序。
- 接着按照在 DFS 序中的出现顺序从前往后，久莲把所有叶子节点排成一排得到了一个序列 $A$。

更进一步地，通过序列 $A$，久莲定义了两个叶子节点 $u, v$ 的距离 $d(u, v)$：假设 $u$ 在 $A$ 中是第 $i$ 个元素，$v$ 是第 $j$ 个元素，则 $d(u, v) = \min(|i − j|, |A| − |i − j|)$。其中 $|A|$ 为序列的长度，即 $T$ 的叶子个数，$i, j$ 指的是出现的位置，从 $1$ 开始计数。

上面的例子中，序列 $A$ 为 $\{4, 5, 3\}$，其中 $d(3, 5) = d(3, 4) = d(4, 5) = 1$，$3, 4, 5$ 的出现位置分别为 $3, 1, 2$。

最后，久莲给出了一个参数 $K$，利用这棵有根树 $T$ 和序列 $A$，我们可以构造一张 $n$ 个点的**无重边无自环**的无向图 $G$：两个不同的点 $u, v$ 之间有边当且仅当它们满足下列条件中的至少一个：
- 在树 $T$ 中存在连接 $u, v$ 的边。
- 在树 $T$ 中 $u, v$ 都是叶子节点且 $d(u, v) \le K$。

当 $K = 1$ 或 $2$ 时，上面的例子得到的图 $G$ 都如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/zsq6qywg.png)

现在久莲想让你来计算一下 $G$ 中不同的哈密尔顿回路数量有多少条，答案可能很大，请对 $998244353$ 取模后输出。

下面是一些补充定义：
- 无重边无自环的无向图 $G$ 的一条哈密尔顿回路 $H$ 是 $G$ 中边的一个子集，其中每一个点恰好有两条不同的相邻边在 $H$ 中，且任意两个点都可以通过 $H$ 中的边直接或间接到达。
- 无重边无自环的无向图 $G$ 的两条哈密尔顿回路 $H_1, H_2$ 是不同的当且仅当存在一条边 $e$ 使得 $e$ 在 $H_1$ 中且不在 $H_2$ 中。
## 输入格式

从文件 `polygon.in` 中读入数据。

第一行输入两个整数 $n, K$，表示树 $T$ 的点数以及久莲选定的参数 $K$。

第二行输入 $n - 1$ 个整数 $f_i\ (1 \le f_i \le i)$，其中 $f_i$ 表示树 $T$ 上存在边 $( f_i, i + 1)$。
## 输出格式

输出到文件 `polygon.out` 中。

输出一行一个整数，表示哈密尔顿回路数量对 $998244353$ 取模后的结果。
## 样例

### 样例输入 #1
```
5 1
1 1 2 2
```
### 样例输出 #1
```
2
```
## 提示

### 样例解释

该样例和题面中的例子完全相同。两条哈密尔顿回路经过节点的顺序分别为 $(1, 2, 4, 5, 3)$ 和 $(1, 2, 5, 4, 3)$。

### 子任务

编号|$n$|$K$|特殊性质||编号|$n$|$K$|特殊性质
-|-|-|-|-|-|-|-|-
$1$|$\le 5$|$\le 3$|无|.|$11$|$\le 1000$|$\le 2$|A
$2$|$\le 10$|$\le 3$|无|.|$12$|$\le 1000$|$\le 2$|A
$3$|$\le 15$|$\le 3$|无|.|$13$|$\le 1000$|$\le 2$|A
$4$|$\le 20$|$\le 3$|无|.|$14$|$\le 1000$|$\le 2$|无
$5$|$\le 1000$|$=1$|A|.|$15$|$\le 1000$|$\le 2$|无
$6$|$\le 1000$|$=1$|A|.|$16$|$\le 1000$|$\le 2$|无
$7$|$\le 1000$|$=1$|A|.|$17$|$\le 1000$|$\le 3$|A
$8$|$\le 1000$|$=1$|无|.|$18$|$\le 1000$|$\le 3$|A
$9$|$\le 1000$|$=1$|无|.|$19$|$\le 1000$|$\le 3$|无
$10$|$\le 1000$|$=1$|无|.|$20$|$\le 1000$|$\le 3$|无

其中性质 A 为保证树上所有节点至多有两个孩子。

对于所有的数据，保证 $1 \leq f_i \leq i$，$2 \leq n \leq 1000$。


---

---
title: "[NOI2014] 消除游戏"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5267
tag: ['2014', 'NOI', '提交答案', 'Special Judge']
---
# [NOI2014] 消除游戏
## 题目描述

最近，小 Z 迷上了一款新型消除游戏。这款游戏在一个 $n\times m$ 的方格中进行。初始时方格中均为 $0 \sim 9$ 的整数。进行消除后方格中会出现空白，用 $-1$ 表示。为了方便，我们将第 $i$ 行，第 $j$ 列的数记为 $A_{i,j}$，并将其坐标记为 $(i,j)$。

给定三个参数 $l_{\min},l_{\max}$ 以及 $K$，玩家可以进行不超过 $K$ 次操作。对于每次操作，玩家需要在方格中找到一条长度为 $l$ 的路径。形式化地，该路径用两个长度为 $l$ 的序列 $x_1,x_2,\ldots,x_l$ 和 $y_1,y_2,\ldots,y_l$ 表示，需要满足如下条件：
1. $1\le x_i\le n,1\le y_i\le m$，其中 $1\le i\le l$，即 $(x_i,y_i)$ 对应于方格中的一个合法位置；
2. $\left|x_i-x_{i+1} \right|+ \left|y_i-y_{i+1} \right|=1$，其中 $1 \le i \lt l$，即 $(x_i,y_i)$ 与 $(x_{i+1},y_{i+1})$ 是方格中相邻的两个位置；
3. $x_i \neq x_j$ 或 $y_i \neq y_j$，其中 $1\le i \lt j\le l$，即路径不能经过重复的格子；
4. $A_{x_i,y_i} \neq -1$，其中 $1\le i\le l$，即路径不能经过空白的格子；
5. $A_{x_1,y_1} \neq 0$，即路径不能以数字 $0$ 为起点；
6. $l_{\min}\le l\le l_{\max}$，即路径的长度需要在给定的范围内。

将路径上的数字串成一个整数 $N$，形式化地
$$
N=\sum\limits_{i=1}^l A_{x_i,y_i}\times 10^{l-i}
$$

游戏会给出两个参数 $c_1,c_2$ 用于计算玩家本次操作的得分：
1. 如果数 $N$ 是质数，那么将获得**质数得分** $l^{c_1}$，否则获得**质数得分** $1$；
2. 如果数 $N$ 是回文数（即，将数 $N$ 的十进制表达看成一个字符串，这个字符串的逆序串和它本身完全相同），那么将获得**回文数得分** $l^{c_2}$，否则获得**回文数得分** $1$；
3. 如果**质数得分**和**回文数得分**均为 $1$，那么**本次操作的得分**为 $0$；否则**本次操作的得分**为**质数得分与回文数得分**之和。

每次操作过后，若**该次操作的得分**等于 $0$，那么你浪费了一次操作机会，而局面不会有任何改变。若**该次操作的得分**大于 $0$，则将路径上的数替换为空白，并使空白上方的数字垂直下落。形式化地，执行以下操作：
1. 执行 $A_{x_i,y_i}\leftarrow -1$，其中 $1\le i\le l$；
2. 枚举所有格子。如果存在某个格子 $(i ,j)$，满足 $i \neq n, A_{i,j} \neq -1, A_{i+1,j} = -1$，执行 $A_{i+1,j} \leftarrow A_{i,j}, A_{i,j}\leftarrow -1$。反复执行这个操作直到方格中不再存在这样的格子。

我们还会给你一个参数 $F$ ，在所有操作完成后，玩家的**最终得分** $S$ 的计算方式由 $F$ 决定：如果 $F$ 取值为 $0$，那么玩家的最终得分为所有操作的分数总和 $m$；如果 $F$ 取值为 $1$，那么玩家的最终得分为所有操作的分数总和 $m$ 除 $2^d$ 后向下取整，即

$$
S =
\begin{cases}
m, & F=0\\\\
\left \lfloor \frac{m}{2^d} \right \rfloor, & F=1
\end{cases}
$$

其中 $d$ 为最终方格中非空白格子的数目。

小 Z 沉迷于这个有趣的游戏中不能自拔。她想请你帮助, 针对给定的输入参数，给出游戏局面的操作方案。当然，最终得分越大越好。
## 输入格式

**本题是一道提交答案题。**

对于每个输入文件，输入的第 $1$ 行包含 $8$ 个用空格分隔的整数 $n, m, K, l_{\min}, l_{\max}, c_1, c_2, F$，含义同题面描述。 

随后 $n$ 行，每行 $m$ 个整数，表示方格 A。数之间用一个空格分隔。

输入文件中不会包含多余的空行，行末不会存在多余的空格。
## 输出格式

针对给定的 $10$ 个输入文件 `game1.in ~ game10.in`，你需要分别提交你的输出文件 `game1.out ~ game10.out`。

输出文件第 $1$ 行为一个整数 $M (0 \leq M \leq K)$，为你的操作次数。

随后, 输出文件还应包含 $M$ 行，每行描述一次操作。对于每一行，最开始的整数$l$表示这次操作中选定路径的长度。接下来有 $2l$ 个数字，分别为 $x_1, y_1, x_2, y_2, \dots, x_l, y_l$。

输出文件中不应包含多余的空格和空行。一行的多个整数之间使用一个空格分隔。
## 样例

### 样例输入 #1
```
3 3 100 2 3 1 1 0
2 1 1
2 3 3
4 7 1
```
### 样例输出 #1
```
4
2 2 2 3 2
2 3 1 3 2
2 2 1 3 1
3 1 3 2 3 3 3
```
### 样例输入 #2
```
1 3 100 2 3 1 1 1
2 1 1
```
### 样例输出 #2
```
1
2 1 2 1 3
```
## 提示

#### 样例解释 1

$4$ 次消除得到的数与相应的分数分别是：$37$，得分为 $2+1=3$；$41$，得分为 $2+1=3$；$22$，得分为 $1+2=3$；$131$，得分为 $3+3=6$。总共得分为 $15$。可能存在更优的方案。

#### 样例解释 2

本方案仅一次消除操作。消除的数为 $11$，本次操作得分为 $2+2=4$。由于 $F=1$，最终得分为每次操作得分之和 $4$ 除以 $2^1 = 2$ 后下取整，为 $2$。若选择消除路径 $211$，则会得到本局面最佳分数 $4$。

#### 评分标准

对于每组数据，我们设置了 $9$ 个评分参数 $a_{10},a_9, \dots ,a_2$。如果选手的输出不合法，则得零分。否则，在你的方案中，若游戏得分为 $w_{user}$，你的分数将会由下表给出：

| 得分 |            条件             | 得分 |           条件           |
| :--: | :-------------------------: | :--: | :----------------------: |
| $10$ |    $w_{user}\ge a_{10}$     | $5$  | $a_5\le w_{user}\lt a_6$ |
| $9$  | $a_9\le w_{user}\lt a_{10}$ | $4$  | $a_4\le w_{user}\lt a_5$ |
| $8$  |  $a_8\le w_{user}\lt a_9$   | $3$  | $a_3\le w_{user}\lt a_4$ |
| $7$  |  $a_7\le w_{user}\lt a_8$   | $2$  | $a_2\le w_{user}\lt a_3$ |
| $6$  |  $a_6\le w_{user}\lt a_7$   | $1$  |  $0\lt w_{user}\lt a_2$  |

#### 附加文件

checker 需要自行编译后使用。

请前往 [Github](https://github.com/MikeMirzayanov/testlib) 下载 testlib.h 的最新源代码。


---

---
title: "[NOI2019] 机器人"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5469
tag: ['2019', 'NOI', 'O2优化']
---
# [NOI2019] 机器人
## 题目背景

时限 3 秒，内存 512MB
## 题目描述

小 R 喜欢研究机器人。

最近，小 R 新研制出了两种机器人，分别是 `P` 型机器人和 `Q` 型机器人。现在他要测试这两种机器人的移动能力，测试在从左到右排成一排的 $n$ 个柱子上进行，柱子用$1 - n$ 依次编号，$i$ 号柱子的高度为一个正整数 $h_i$。机器人**只能在相邻柱子间移动**，即：若机器人当前在 $i$ 号柱子上，它只能尝试移动到 $i - 1$ 号和 $i + 1$ 号柱子上。

每次测试，小 R 会选取一个起点 $s$，并将两种机器人均放置在 $s$ 号柱子上。随后它们会按自己的规则移动。

`P` 型机器人会一直**向左**移动，但它**无法**移动到比起点 $s$ **更高**的柱子上。更具体地，`P` 型机器人在 $l (l \leq s)$ 号柱子停止移动，**当且仅当**下列两个条件均成立：

- $l = 1$ 或 $h_{l-1} > hs$。

- 对于满足 $l \leq j \leq s$ 的 $j$，有 $h_j \leq h_s$。

`Q` 型机器人会一直**向右**移动，但它**只能**移动到比起点 $s$ **更低**的柱子上。更具体地，`Q` 型机器人在 $r (r \geq s)$ 号柱子停止移动，**当且仅当**下列两个条件均成立：

- $r = n$ 或 $h_{r+1} \geq h_s$。

- 对于满足 $s < j \leq r$ 的 $j$，有 $h_j < h_s$。

现在，小 R 可以设置每根柱子的高度，$i$ 号柱子可选择的高度范围为 $[A_i, B_i]$，即$A_i \leq h_i \leq B_i$。小 R 希望**无论**测试的起点 $s$ 选在哪里，两种机器人移动过的柱子数量的差的绝对值都**小于等于**$2$。他想知道有多少种柱子高度的设置方案满足要求，小 R 认为两种方案不同当且仅当存在一个 $k$，使得两种方案中 $k$ 号柱子的高度不同。请你告诉他满足要求的方案数模 $10^9 + 7$ 后的结果。

## 输入格式

第一行一个正整数 $n$，表示柱子的数量。

接下来 $n$ 行，第 $i$ 行两个正整数 $A_i, B_i$，分别表示 $i$ 号柱子的最小和最大高度。

## 输出格式

仅一行一个整数，表示答案模 $10^9 + 7$ 的值。
## 样例

### 样例输入 #1
```
5
3 3
3 3
3 4
2 2
3 3
```
### 样例输出 #1
```
1
```
## 提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 2

见附加文件的 `robot/robot2.in` 与 `robot/robot2.ans`。

#### 样例 3

见附加文件的 `robot/robot3.in` 与 `robot/robot3.ans`。

#### 样例 4

见附加文件的 `robot/robot4.in` 与 `robot/robot4.ans`。

### 样例 1 解释

柱子高度共两种情况：

- 高度为：`3 2 3 2 3`。此时若起点设置在 $5$，`P` 型机器人将停在 $1$ 号柱子，共移动$4$ 个柱子。`Q` 型机器人停在 $5$ 号柱子，共移动 $0$ 个柱子，不符合条件。

- 高度为：`3 2 4 2 3`。此时无论起点选在哪，都满足条件，具体见下表：

| 起点编号 | P 型机器人 | Q 型机器人 |
| :----------: | :----------: | :----------: |
| $1$ | 停在 $1$ 号柱子，移动过 $0$ 个 | 停在 $2$ 号柱子，移动过 $1$ 个 |
| $2$ | 停在 $2$ 号柱子，移动过 $0$ 个 | 停在 $2$ 号柱子，移动过 $0$ 个 |
| $3$ | 停在 $1$ 号柱子，移动过 $2$ 个 |停在 $5$ 号柱子，移动过 $2$ 个  |
| $4$ | 停在 $4$ 号柱子，移动过 $0$ 个 | 停在 $4$ 号柱子，移动过 $0$ 个 |
| $5$ |停在 $4$ 号柱子，移动过 $1$ 个  | 停在 $5$ 号柱子，移动过 $0$ 个 |

### 数据范围

对于所有测试数据：$1 \leq n \leq 300$ , $1 \leq A_i \leq B_i \leq 10^9$。

每个测试点的具体限制见下表：

| 测试点编号 | $n\le$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1,2$ | $7$ | $A_i=B_i,B_i\le 7$ |
| $3,4$ | $7$ | $B_i\le 7$ |
| $5,6,7$ | $50$ | $B_i\le 100$ |
| $8,9,10$ | $300$ | $B_i\le 10^4$ |
| $11,12$ | $50$ | $A_i=1,B_i=10^9$ |
| $13,14,15$ | $50$ | 无 |
| $16,17$ | $150$ | 无 |
| $18,19$ | $200$ | 无 |
| $20$ | $300$ | 无 |



---

---
title: "[NOI2019] 序列"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5470
tag: ['贪心', '2019', 'NOI', 'O2优化', '优先队列', '模拟费用流']
---
# [NOI2019] 序列
## 题目描述

给定两个长度为 $n$ 的正整数序列 $\{a_i\}$ 与 $\{b_i\}$，序列的下标为 $1, 2, \cdots , n$。现在你需要分别对两个序列各指定**恰好** $K$ 个下标，要求**至少**有 $L$ 个下标在两个序列中都被指定，使得这 $2K$ 个下标在序列中对应的元素的总和**最大**。

形式化地说，你需要确定两个长度为 $K$ 的序列 $\{c_i\}, \{d_i\}$，其中
$1 \leq c_1 < c_2 < \cdots < c_K \leq n , 1 \leq d_1 < d_2 < \cdots < d_K \leq n$

并要求 $\{c_1, c_2, \cdots , c_K\} \cap \{d_1, d_2, · · · , d_K\}\geq L$

目标是最大化 $\sum^{K}_{i=1} a_{c_i} +\sum^{K}_{i=1} b_{d_i}$

## 输入格式

**本题输入文件包含多组数据**。

第一行一个正整数 $T$ 表示数据组数。接下来每三行表示一组数据。

每组数据第一行三个整数 $n, K, L$，变量意义见题目描述。

每组数据第二行 $n$ 个整数表示序列 $\{a_i\}$。

每组数据第三行 $n$ 个整数表示序列 $\{b_i\}$。
## 输出格式

对于每组数据输出一行一个整数表示答案。

## 样例

### 样例输入 #1
```
5
1 1 1
7
7
3 2 1
4 1 2
1 4 2
5 2 1
4 5 5 8 4
2 1 7 2 7
6 4 1
1 5 8 3 2 4
2 6 9 3 1 7
7 5 4
1 6 6 6 5 9 1
9 5 3 9 1 4 2
```
### 样例输出 #1
```
14
12
27
45
62

```
## 提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 2

见选手目录下的 `sequence/sequence2.in` 与 `sequence/sequence2.ans`。

#### 样例 3

见选手目录下的 `sequence/sequence3.in` 与 `sequence/sequence3.ans`。

### 样例 1 解释

第一组数据选择的下标为：$\{c_i\} = \{1\} , \{d_i\} = \{1\}$。

第二组数据选择的下标为：$\{c_i\} = \{1, 3\} , \{d_i\} = \{2, 3\}$

第三组数据选择的下标为：$\{c_i\} = \{3, 4\} , \{d_i\} = \{3, 5\}$。

第四组数据选择的下标为：$\{c_i\} = \{2, 3, 4, 6\} , \{d_i\} = \{2, 3, 4, 6\}$。

第五组数据选择的下标为：$\{c_i\} = \{2, 3, 4, 5, 6\} , \{d_i\} = \{1, 2, 3, 4, 6\}$。

### 数据范围

对于所有测试点：$T \leq 10 , 1 \leq \sum n \leq 10^6, 1 \leq L \leq K \leq n \leq 2 \times 10^5, 1 \leq a_i, b_i \leq 10^9$。

| 测试点编号 | $n\le$ | $\sum n \le$ |
| :----------: | :----------: | :----------: |
| $1\sim3$ | $10$ | $3\times 10^5$ |
| $4\sim5$ | $18$ | $3\times 10^5$ |
| $6\sim7$ | $30$ | $3\times 10^5$ |
| $8\sim10$ | $150$ | $3\times 10^5$ |
| $11\sim16$ | $2\times 10^3$ | $3\times 10^5$ |
| $17\sim21$ | $2\times 10^5$ | $3\times 10^5$ |
| $22\sim25$ | $2\times 10^5$ | $10^6$ |


---

---
title: "[NOI2019] 斗主地"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5472
tag: ['2019', 'NOI', 'O2优化']
---
# [NOI2019] 斗主地
## 题目背景

时限 4 秒 内存 512MB
## 题目描述

小 S 在和小 F 玩一个叫“斗地主”的游戏。

可怜的小 S 发现自己打牌并打不过小 F，所以他想要在洗牌环节动动手脚。

一副牌一共有 $n$ 张牌，从上到下依次标号为 $1 \sim n$。标号为 $i$ 的牌**分数**是 $f(i)$。在本题，$f(i)$ 有且仅有两种可能：$f(i) = i$ 或 $f(i) = i^2$。

洗牌的方式和我们日常生活中的比较类似，以下我们用形式化的语言来定义： 洗牌环节一共分 $m$ 轮，这 $m$ 轮洗牌依次进行。第 $i$ 轮洗牌时：

1. 小 S 会拿出从最上面往下数的前 $A_i$ 张牌。这样这副牌就被分成了两堆：第一堆 是最上面的 $A_i$ 张牌，第二堆是剩下的 $n-A_i$ 张牌，且这两堆牌内相对顺序不变。 特别地，当$A_i = n$ 或 $A_i = 0$ 时，有一堆牌是空的。
2. 接下来对两堆牌进行合并，从而产生新的第三堆牌。当第一堆牌还剩下 $X$ 张，第二堆牌还剩下 $Y$ 张的时候，以 $\dfrac{X}{X+Y}$ 的概率取出第一堆牌的最下面的牌，并将它 放入新的第三堆牌的最上面， $\dfrac{Y}{X+Y}$  的概率取出第二堆牌的最下面的牌，并将它放入新的第三堆牌的最上面
3. 重复操作 $2$，一直取到两堆牌都为空为止。这样我们就完成了一轮洗牌。

因为洗牌过程是随机的，所以小 S 发现自己没法知道某个位置上具体是哪张牌。但小 S 想问你在经历了这 $m$ 轮洗牌后，某个位置上的牌的**期望分数**是多少。小 S 一共会问你 $Q$ 个这样的问题。
## 输入格式

输入的第一行包含三个正整数 $n, m, type$，分别表示牌的数量，洗牌的轮数与 $f(i)$ 的类型。当 $type = 1$ 时，$f(i) = i$。当 $type = 2$ 时，$f(i) = i^2$。

接下来一行，一共 $m$ 个整数，表示 $A_1 \sim A_m$。

接下来一行一个正整数 $Q$，表示小 S 的询问个数。 接下来 $Q$ 行，每行一个正整数 $c_i$，表示小 S 想要知道从上往下第 $c_i$ 个位置上的牌的**期望分数**。

保证 $1 \leq c_i \leq n$。
## 输出格式

输出一共 $Q$ 行，每行一个整数，表示答案在模 $998244353$ 意义下的取值。


即设答案化为最简分式后的形式为 $\dfrac{a}
{b}$，其中 $a$ 和 $b$ 互质。输出整数 $x$ 使得 $bx \equiv a \pmod{998244353}$ 且 $0 ≤ x < 998244353$。可以证明这样的整数 $x$ 是唯一的。
## 样例

### 样例输入 #1
```
4 1 1
3
1
1
```
### 样例输出 #1
```
249561090

```
## 提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 2

见附加文件中的 `landlords/landlords2.in` 与 `landlords/landlords2.ans`。

#### 样例 3

见附加文件中的 `landlords/landlords3.in` 与 `landlords/landlords3.ans`。

### 样例输入输出 1 解释

- 有 $\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\{1, 2, 3, 4\}$。
- 有 $\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\{1, 2, 4, 3\}$。
- 有 $\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\{1, 4, 2, 3\}$。
- 有 $\dfrac{1}{4}$ 的概率从上到下的最终结果是 $\{4, 1, 2, 3\}$。

所以最终有 $\dfrac{1}{4}$ 的概率第一个位置是 $4$，有 $\dfrac{3}
{4}$ 的概率第一个位置是 $1$，所以第一个位置的期望分数是 $\dfrac{7}{
4}$。

为了帮助你们更直观地了解洗牌的过程，我们在下面画出了结果是 $\{1, 4, 2, 3\}$ 的过程。

![](https://cdn.luogu.com.cn/upload/pic/64318.png)

### 数据规模与约定

对于全部的测试点，保证 $3\le n \le 10^7$，$1\le m,Q\le5\times 10^5$，$0\le A_i\le n$，$type\in \{1,2\}$。

每个测试点的具体限制见下表：

| 测试点 | $n$ | $m$ | $type=$ | 其他性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $\le 10$ | $\le 1$ | $1$ | 无 |
| $2$ | $\le 80$ | $\le 80$ | $1$ | 无 |
| $3$ | $\le 80$ | $\le 80$ | $2$ | 无 |
| $4$ | $\le 100$ | $\le 5\times 10^5$ | $2$ | 所有 $A_i$ 相同 |
| $5$ | $\le 10^7$ | $\le 5\times 10^5$ | $1$ | 无 |
| $6$ | $\le 10^7$ | $\le 5\times 10^5$ | $1$ | 无 |
| $7$ | $\le 10^7$ | $\le 5\times 10^5$ | $1$ | 无 |
| $8$ | $\le 10^7$ | $\le 5\times 10^5$ | $2$ |无  |
| $9$ | $\le 10^7$ | $\le 5\times 10^5$ | $2$ | 无 |
| $10$ | $\le 10^7$ | $\le 5\times 10^5$ | $2$  | 无 |

请注意我们并没有保证 $Q\le n$。

### 提示

这里我们给出离散型随机变量 $X$ 的期望 $\mathbb{E}[x]$ 的定义：

设离散随机变量 $X$ 的可能值是 $X_1,X_2,\ldots X_k$，$Pr[X_1],Pr[X_2],\ldots,Pr[X_k]$ 为 $X$ 取对应值的概率，则 $X$ 的期望为：
$$\mathbb{E}[x]=\sum^k_{i=1}X_i\times Pr[X_i]$$




---

---
title: "[NOI2019] I 君的探险"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5473
tag: ['2019', 'NOI', '交互题', 'Special Judge', 'O2优化']
---
# [NOI2019] I 君的探险
## 题目背景

附加文件可在页面底部「附件」中下载。

### 特别提示

**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**

1. 与原题不同的是，你不需要，也不应该在程序开头包含 `explore.h` 头文件。

2. 为了确保程序正常编译，你需要在你提交的程序开头加上如下函数声明语句：

```cpp
void modify(int x);
int query(int x);
void report(int x, int y);
int check(int x);
```

3. 本题仅支持 C++ 语言（包括 `C++`，`C++11`，`C++14`，`C++17`）提交。
## 题目描述

时隔半年，I 君的商店终于开不下去了，他决定转让商店，做一名探险家去探索未知的广阔世界。

根据古书记载，他在一个大荒漠的腹地找到了未知文明创造的地下宫殿，宫殿由 $N$ 个大型洞穴和 $M$ 条连接这些洞穴的双向通路构成。I 君能借助古书分辨所处的洞穴，但书中并没有记录 $M$ 条通路的连接结构，因此他难以搜寻传说中藏在宫殿里的无尽财宝。

不过现在 I 君发现了一个神秘机关，通过它可以获知宫殿的信息，I 君决定利用这个机关来得到宫殿的连接结构，请你来协助他。

地下宫殿可以抽象成一张 $N$ 个点、$M$ 条边的无向简单图（简单图满足任意两点之间至多存在一条直接相连的边），洞穴从 $0 \sim n - 1$ 编号。目前你并不知道边有哪些。

每个洞穴都拥有一个光源，光源有开启、关闭两种状态，只有当光源处于开启状态时它所在的洞穴才会被照亮。初始时所有的光源都处于关闭状态，而光源的状态只能用I 君发现的神秘机关改变。更具体的，使用神秘机关可以进行如下四种操作：

1. 向机关给定一个编号 $x$，机关将会改变$x$ 号洞穴，以及与$x$ 号洞穴有通路直接相连的洞穴的光源状态。即原来开启的光源将会关闭；原来关闭的光源将会开启。

2. 向机关给定一个编号 $x$，机关将会显示当前$x$ 号洞穴光源的状态。

3. 向机关给定两个编号 $x, y$，表示你确定有一条连接 $x$ 号洞穴与 $y$ 号洞穴的通路，并让机关记录。

4. 向机关给定一个编号 $x$，机关将会判断与 $x$ 号洞穴相连的通路是否都已被记录。

机关在完成上一次操作后才能进行下一次操作。机关不能随意使用，因此每种操作的使用次数都有限制，分别为 $L_m, L_q, M, L_c$。你的任务是，编写一个程序，帮助 I 君决定如何合理利用神秘机关，从而正确地找到这 $M$ 条通路。

### 实现细节

你不需要，也不应该实现主函数，你只需要实现函数 `explore(N, M)`，这里的 $N$和 $M$ 分别表示洞穴和通路的个数。你可以通过调用如下四个函数来和交互库进行交互：

1. `modify(x)`

- 这个函数可以令机关执行操作 $1$，给定的编号为 $x$。

- 你需要保证 $0 \leq x < N$，这个函数没有返回值。

2. `query(x)`

- 这个函数可以令机关执行操作 $2$，给定的编号为 $x$。

- 你需要保证 $0 \leq x < N$，这个函数返回 $0$ 或 $1$，表示目前 $x$ 号洞穴的光源为关闭（$0$ 表示）或开启（$1$ 表示）状态。

3. `report(x, y)`

- 这个函数可以令机关执行操作 $3$，给定的编号为 $x, y$。

- 你需要保证 $0 \leq x, y < N$ 且 $x \neq y$，这个函数没有返回值。

4. `check(x)`

- 这个函数可以令机关执行操作 $4$，给定的编号为 $x$。

- 你需要保证 $0 \leq x < N$，这个函数返回 $0$ 或 $1$，其中返回 $1$ 当且仅当与 $x$ 号洞穴相连的所有通路都已通过操作 3 被记录。

评测时，交互库会恰好调用 `explore` 一次。

本题保证所使用的图在交互开始之前已经完全确定，不会根据和你的程序的交互过程动态构造，因此题目中的交互操作都是确定性的，你不需要关心这些操作在交互库中的具体实现。

数据保证在调用次数限制下，交互库运行所需的时间不超过1s；交互库使用的内存大小固定，且不超过128MB。

### 实现方法

选手工作目录下已经提供了一个 `template_explore.cpp/c/pas`，请将这个文件拷贝一份，重命名为 `explore.cpp/c/pas`，然后在其基础上答题。

1. 对 C++ / C 语言选手

- 请确保你的程序开头有 
```
#include "explore.h"。
```
- 你需要实现的函数 `explore` 的接口信息如下：
```
void explore(int N, int M);
```
- 你可以调用的交互函数的接口如下：
```
void modify(int x);
int query(int x);
void report(int x, int y);
int check(int x);
```

2. 对 Pascal 语言选手

- 注意：Pascal 的代码中实现接口的语法较为复杂，请选手直接在下发的.
`template_explore.pas` 的基础上进行答题，而不是自己从头实现代码。

- 你需要实现的函数 `explore` 的接口信息如下：
```
procedure _explore(N, M : longint);
```
- 注意：这里的函数名称是`_explore` 而非`explore`，如果使用`explore` 将导致编译失败。

- 你可以调用的交互函数的接口如下：
```
procedure modify(x : longint);
function query(x : longint) : longint;
procedure report(x : longint; y : longint);
function check(x : longint) : longint;
```

试题目录下的 `grader.cpp/c` 以及 `graderhelperlib.pas` 是我们提供的交互库参考实现，最终测试时所用的交互库实现与该参考实现有所不同，因此选手的解法不应该依赖交互库实现。

1. 对 `C/C++` 语言的选手：

- 你需要在本题目录下使用如下命令编译得到可执行程序：

- 对于 C 语言：
```
gcc grader.c explore.c -o explore -O2 -lm
```
- 对于 C++ 语言：
```
g++ grader.cpp explore.cpp -o explore -O2 -lm
```

2. 对于 `Pascal` 语言的选手：

- 你需要在本题目录下使用如下命令编译得到可执行程序：
```
fpc grader.pas -o"explore" -O2
```

3. 对于编译得到的可执行程序：

- 可执行文件将从标准输入读入以下格式的数据：

第一行包含三个整数 $L_m, L_q, L_c$ ，第二行包含两个整数 $N, M$，意义如题面描述。

接下来 $M$ 行，每行两个整数 $x, y$，描述一条连接 $x$ 号洞穴与 $y$ 号洞穴的通路。

- 读入完成之后，交互库将调用恰好一次函数 `explore`，用输入的数据测试你的函数。你的函数正确返回后，交互库会判断你的计算是否正确，若正确则会输出 `Correct` 和交互函数调用次数相关信息，否则会输出相应的错误信息。
## 样例

### 样例输入 #1
```
100 200 300
3 2
0 1
1 2

```
### 样例输出 #1
```
见“提示与说明”
```
## 提示

数据第一行的三个整数分别表示三种操作的调用次数限制，即 `modify(x)` 调用次数不能超过 $100$，`query(x)` 调用次数不能超过 $200$，`check(x)` 调用次数不能超过 $300$。

数据第二行的两个整数分别表示洞穴数和通路条数，即 $N = 3 , M = 2$。

`report(x, y)` 调用次数不能超过 $M$，该例子中即不超过 $2$ 次。

下面是一个正确的交互过程：

| 选手程序 | 交互库 | 说明 |
| :----------: | :----------: | :----------: |
|  | 调用 $\text{explore}(3,2)$ | 开始测试 |
| 调用 $\text{modify}(0)$ |  | 对 $0$ 号洞穴做操作 $1$ |
| 调用 $\text{query}(2)$ | 返回 $0$ | 目前 $2$ 号洞穴的光源状态是关闭 |
| 调用 $\text{report}(0,1)$ |  | 发现了道路 $(0,1)$ 并记录 |
| 调用 $\text{check}(0)$ | 返回 $1$ | 与 $0$ 号洞穴相关的道路都已被记录 |
| 调用 $\text{report}(2,1)$ |  | 发现了道路 $(2,1)$ 并记录 |
| 运行结束并返回 | 向屏幕打印 $\text{Correct}$ | 交互结束，结果正确 |

### 下发文件说明

在本试题目录下：

1. `grader.cpp/c` 以及 `graderhelperlib.pas` 是我们提供的交互库参考实现。

2. `explore.h` 和 `grader.pas` 是头文件，选手不用关心具体内容。

3. `template_explore.cpp/c/pas` 是我们提供的样例解题源代码。

4. `explore1.in`、`explore2.in`、`explore3.in` 是样例输入，可供测试。

选手注意对所有下发文件做好备份。评测只收取本试题目录下的`explore.c/cpp/pas`，并且对该程序以外的文件的修改无效。

最终评测只会收取 `explore.cpp/c/pas`，修改选手目录下其他文件对评测无效。

本题首先会受到和传统题相同的限制。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 $0$ 分等。你只能访问自己定义的和交互库给出的变量及其对应的内存空间，尝试访问其他空间将可能导致编译错误或运行错误。

在上述条件基础上，在一个测试点中，你得到满分，当且仅当：

1. 你的每次函数调用均合法，且调用 `modify`、`query` 和 `check` 的次数分别不超过$L_m, L_q, L_c$。

2. 由于 `report` 的调用次数限制为 $M$，你的每次调用都必须记录一条新的且存在的边；即每次调用 `report(x, y)` 时，应满足：有一条连接 $x$ 号洞穴和 $y$ 号洞穴的通路，且在这次调用之前从未调用过 `report(x, y)` 或 `report(y, x)`。

3. 你实现的函数 `explore` 正常返回。

4. 在 `explore` 函数返回时，你已经通过调用 `report` 记录了全部 $M$ 条通路。

本题共 $25$ 个测试点，每个测试点 $4$ 分。每个测试点的数据规模和相关限制见下表。
| 测试点编号 | $N=$ | $M=$ | $L_m=$ | $L_q=$ | $L_c=$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $3$ | $2$ | $100$ | $100$ | $100$ | 无 |
| $2$ | $100$ | $10\times N$ | $200$ | $10^4$ | $2\times M$ | 无 |
| $3$ | $200$ | $10\times N$ | $200$ | $4\times 10^4$ | $2\times M$ | 无 |
| $4$ | $300$ | $10\times N$ |$299$  | $9\times 10^4$ | $2\times M$ | 无 |
| $5$ | $500$ | $10\times N$ | $499$ | $1.5\times 10^5$ | $2\times M$ | 无 |
| $6$ | $59998$ | $\frac{N}{2}$ | $17\times N$ | $17\times N$ | $0$ | $A$ |
| $7$ | $99998$ | $\frac{N}{2}$ | $18\times N$ | $18\times N$ | $0$ | $A$ |
| $8$ | $199998$ | $\frac{N}{2}$ | $19\times N$ | $19\times N$ | $0$ | $A$ |
| $9$ | $199998$ | $\frac{N}{2}$ | $19\times N$ | $19\times N$ | $0$ | $A$ |
| $10$ | $99997$ | $N-1$ | $18\times N$ | $18\times N$ | $0$ | $B$ |
| $11$ | $199997$ | $N-1$ | $19\times N$ | $19\times N$ | $0$ | $B$ |
| $12$ | $99996$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $C$ |
| $13$ | $199996$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $C$ |
| $14$ | $199996$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $C$ |
| $15$ | $99995$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $D$ |
| $16$ | $99995$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $D$ |
| $17$ | $199995$ | $N-1$ | $10^7$ | $10^7$ | $2\times M$ | $D$ |
| $18$ | $1004$ | $2\times 10^3$ | $10^7$ | $5\times 10^4$ | $2\times M$ | 无 |
| $19$ | $1004$ | $3\times 10^3$ | $10^7$ | $5\times 10^4$ | $2\times M$ | 无 |
| $20$ | $1004$ | $3\times 10^3$ | $10^7$ | $5\times 10^4$ | $2\times M$ | 无 |
| $21$ | $5\times 10^4$ | $2\times N$ | $10^7$ | $10^7$ | $2\times M$ |  无|
| $22$ | $10^5$ | $2\times N$ | $10^7$ | $10^7$ | $2\times M$ | 无 |
| $23$ | $1.5\times 10^5$ | $2\times 10^5$ | $10^7$ | $10^7$ | $2\times M$ | 无 |
| $24$ | $2\times 10^5$ | $2.5\times 10^5$ | $10^7$ | $10^7$ | $2\times M$ | 无 |
| $25$ | $2\times 10^5$ | $3\times 10^5$ | $10^7$ | $10^7$ | $2\times M$ | 无 |

再次提醒，题目保证测试所使用的图在交互开始之前已经完全确定，而不会根据和你的程序的交互动态构造。

表中特殊性质栏中变量的含义如下：

A：保证每个点的度数恰好为 $1$。

B：保证对于每个 $x > 0$，存在恰好一个 $y < x$ 的 $y$ 使得 $x$ 号洞穴与 $y$ 号洞穴有通路直接相连。

C：存在 $0 \sim N - 1$ 的一个排列 $p_0, p_1, \cdots , p_{N-1}$，使得对任意 $1 \leq i < N$，存在一条连接洞穴编号分别为 $p_{i-1}$ 与 $p_i$ 的通路。

D：保证图连通。

- 提示：你的程序可以通过判断传入的 $N$ 的个位来区分上述不同的数据类型。


---

---
title: "[NOI2012] 三重镇"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5570
tag: ['2012', 'NOI', '提交答案', 'Special Judge']
---
# [NOI2012] 三重镇
## 题目背景

小西同学最近喜欢上了 iOS 游戏《三重镇 Triple Town》。游戏之余，小西也在思考如何才能在这个游戏中获得更高的分数。 
## 题目描述

如下图所示，游戏在一个 $n \times m$ 的地图中进行。游戏给定一个**建造序列**，玩家按照此建造序列依次选择空白位置建造相应的建筑单位。建筑有九个不同的等级，由低到高分别为 `Grass`, `Bush`, `Tree`, `Hut` 等（为了方便描述，我们称之为 $L_1, L_2, L_3, \ldots , L_9$）。

![](https://cdn.luogu.com.cn/upload/image_hosting/huzjus9n.png)

当玩家在一个空白位置建造单位之后，有可能引起反应。反应的构成条件是：**从这个格子出发，与该建筑单位等级相同的格子所构成的连通块大小大于等于 $3$**， 则这个连通块将被合并为一个下一等级的建筑，此建筑的位置为最后建造的建筑单位位置，连通块中其他位置将变回空格。这里的连通块是指直接或者间接相邻的位置集合。

另外需要注意的是，**$L_9$ 为建筑的最高等级，所以多个 $L_9$ 的连通块并不会合并**。例如在下图中，当建造了中间的 $L_1$ 之后，与该位置相连的 $L_1$就被合并成了一个 $L_2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/95tnhrda.png)

注意，在合并的过程中，可能会引起连环反应，如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/0zmj49xv.png)

游戏的得分取决于玩家建造和反应生成的单位，建造或者反应生成建筑单位就可以获得相应的分数。不同等级建筑的得分表如下：

|建筑|$L_1$|$L_2$|$L_3$|$L_4$|$L_5$|$L_6$|$L_7$|$L_8$|$L_9$|
|:----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|
|得分|$4$|$20$|$100$|$500$|$1500$|$5000$|$20000$|$100000$|$500000$|

以刚才的两个游戏过程为例。图 2 中，首先建造了 $L_1$, 将得到 $4$ 分，随后， $L_1$ 进行了反应生成了 $L_2$, 此时再得到 $20$ 分。总共得分为 $24$。而在图 3 中，这一步操作得分为 $4+20+100+500=624$ 分。

为了降低游戏的难度，游戏中还设有两种道具，分别为“星星”和“炸弹”。在游戏开始时，玩家被给定 $p$ 个星星道具和 $q$ 个炸弹道具，玩家可以在任意时刻使用。两者功能如下：

- “星星”道具：可以放置在一个空格位置。当星星被放置时，星星会自动变为**能引起反应的最高等级建筑**。当在该位置不能引起任何反应时，星星变为 $L_1$。例如，在图 3 正中间位置放置星星，星星自动变为 $L_3$。星星的得分按照变化后的建筑计算得分。
- “炸弹”道具：炸弹道具可以放在在一个有建筑的位置上，作用为炸掉这个建筑并将该位置恢复为空格。当使用炸弹时，得分将扣除被炸掉的建筑的一半分数（即，得分为负数）。

在游戏的进行过程中，玩家必须按照给定的顺序进行建造，但可以随时穿插使用两种道具。游戏的目标是，通过合理的操作，取得最高的分数。
## 输入格式

**本题是一道提交答案题。**

对于每个数据，输入文件中第一行为两个整数 $n$，$m$, 表示地图一共包含 $n$ 行 $m$ 列。

接下来一行包含两个整数 $p$，$q$，分别表示道具星星和道具炸弹的数目。

接下来 $n$ 行包含一个 $n \times m$ 的初始地图。其中字符 `.` 表示空地，数字 $1\sim 9$ 分别表示相应等级的建筑。

再接下来一行包含一个数字 $k$，表示建造序列的长度。

最后一行包含 $k$ 个空格隔开的 $1\sim 9$ 之间的数字，表示建造序列的内容。
## 输出格式

针对给定的 $10$ 个输入文件 `tritown1.in` ~ `tritown10.in`，你需要分别提交你的输出文件 `tritown1.out` ~ `tritown10.out`。

输出文件包含玩家进行游戏的指令，共 $4$ 种指令：

|指令|含义|
|:--:|:----------:|
|`PUT x y`|将建造序列中的下一个单位放置到第 $x$ 行第 $y$ 列的空格中。
|`STAR x y`|放置星星道具到第$x$行第$y$列的空格中。|
|`BOMBER x y`|在第 $x$ 行第 $y$ 列放置炸弹，此位置必须非空。|
|`END`|游戏结束，结算当前得分。|

输出必须以 `END` 指令结尾，玩家可以在任意时刻结束游戏。
## 样例

### 样例输入 #1
```
2 3
1 1
..1
221
2
1 3
```
### 样例输出 #1
```
PUT 1 2
PUT 1 1
STAR 2 1
END
```
## 提示

#### 样例解释

本样例对应下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/62gxe52w.png)

第一步得分为 $4+20+100=124$；

第二步得分为 $100$；

第三步得分为 $100+500=600$；

游戏总得分 $124+100+600=824$ 分。

#### 评分标准

对于每组数据，我们设置了 $9$ 个评分参数 $a_{10}, a_9, …, a_2$，它们按此顺序每行一个放置在附加文件中的 `tritown1.ans` ~ `tritown10.ans` 内。如果选手的输出不合法，则得零分。否则，设在你的方案中，游戏得分为 $w_{user}$，你的分数将会由下表给出：

|得分|条件|得分|条件|
|:----:|:------:|:----:|:------:|
|10|$w_{user}\geq a_{10}$|5|$w_{user}\geq a_5$|
|9|$w_{user}\geq a_9$|4|$w_{user}\geq a_4$|
|8|$w_{user}\geq a_8$|3|$w_{user}\geq a_3$|
|7|$w_{user}\geq a_7$|2|$w_{user}\geq a_2$|
|6|$w_{user}\geq a_6$|1|$w_{user}>0$|

如果有多项满足，则取满足条件中的最高得分。

#### 附加文件

checker 需要自行编译后使用。

请前往 [Github](https://github.com/MikeMirzayanov/testlib) 下载 testlib.h 的最新源代码。


---

---
title: "[NOI2008] 赛程安排"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5699
tag: ['2008', 'NOI', '提交答案', 'Special Judge']
---
# [NOI2008] 赛程安排
## 题目描述

随着奥运的来临，同学们对体育的热情日益高涨。在 NOI2008 来临之际，学校正在策划组织一场乒乓球赛。小 Z 作为一名狂热的乒乓球爱好者，这正是他大展身手的好机会，于是他摩拳擦掌，积极报名参赛。

本次乒乓球赛采取淘汰赛制，获胜者晋级。恰好有 $n$($n$ 是 $2$ 的整数次幂，不妨设 $n = 2^k$)个同学报名参加，因此第一轮后就会有 $2^{k-1}$ 个同学惨遭淘汰，另外 $2^{k-1}$ 个同学晋级下一轮；第二轮后有 $2^{k-2}$ 名同学晋级下一轮，… 依次类推，直到 $k$ 轮后决出冠亚军：具体的，每个人都有一个 $1\sim n$ 的初始编号，其中小 Z 编号为 $1$，所有同学的编号都不同，他们将被分配到 $n$ 个位置中，然后按照类似下图的赛程进行比赛：

![](https://cdn.luogu.com.cn/upload/image_hosting/0n4eu0pc.png)

上图：$n=8$ 时比赛的赛程表

为了吸引更多的同学参加比赛，本次比赛的奖金非常丰厚。在第 $i$ 轮被淘汰的选手将得到奖金 $a_i$ 元，而冠军将获得最高奖金 $a_{k+1}$ 元。显然奖金应满足 $a_1<a_2<\cdots<a_{k+1}$。

在正式比赛前的热身赛中，小 Z 连连败北。经过认真分析之后，他发现主要的失败原因不是他的球技问题，而是赢他的这几个同学在球风上刚好对他构成相克的关系，所以一经交手，他自然败阵。小 Z 思索：如果在正式比赛中能够避开这几位同学，该有多好啊!

假设已知选手两两之间交手的胜率，即选手 $A$ 战胜选手 $B$ 的概率为 $P_{A,B}$ (保证 $P_{A,B}+P_{B,A}=1$)。于是小 Z 希望能够通过确定比赛的对阵形势（重新给每个选手安排位置），从而能够使得他获得尽可能多的奖金。你能帮助小 Z 安排一个方案，使得他这场比赛期望获得的奖金最高么？
## 输入格式

这是一道提交答案型试题，所有的输入文件 `match*.in` 已在附加文件中。

输入文件 `match*.in` 第一行包含一个正整数 $n$，表示参赛的总人数，数据保证存在非负整数 $k$，满足 $2^k=n$。

接下来 $n$ 行，每行有 $n$ 个 $0$ 到 $1$ 间的实数 $P_{i,j}$，表示编号为 $i$ 的选手战胜编号为 $j$ 的选手的概率，每个实数精确到小数点后两位。特别注意 $P_{i,i}=0.00$。

接下来 $k+1$ 行，每行一个整数分别为晋级各轮不同的奖金，第 $i$ 行的数为 $a_i$。
## 输出格式

输出文件 `match*.out` 包括 $n$ 行，第 $i$ 行的数表示位于第 $i$ 个位置的同学的编号，要求小 Z 的编号一定位于第 $1$ 个位置。
## 样例

### 样例输入 #1
```
4
0.00 0.70 0.60 0.80
0.30 0.00 0.60 0.40
0.40 0.40 0.00 0.70
0.20 0.60 0.30 0.00
1
2
3
```
### 样例输出 #1
```
1
4
2
3
```
## 提示

#### 样例解释

第一轮比赛过后，编号为 $1$ 的选手(小 Z)晋级的概率为 $80\%$，编号为 $2$ 的选手晋级的概率为 $60\%$，编号为 $3$ 的选手晋级的概率为 $40\%$，编号为 $4$ 的选手晋级的概率为 $20\%$。

第二轮（决赛），编号为 $1$ 的选手（小 Z）前两轮均获胜的概率为 $80\%\times (60\%\times 70\%+40\%\times 60\%)=52.8\%$，因此，小 Z 在第一轮失败的概率 $P_1=1-0.8=0.2$，第一轮胜出但第二轮败北的概率 $P_2=0.8-0.528=0.272$，获得冠军的概率 $P_3=0.528$。

从而，期望奖金为 $0.2\times 1+(0.8-0.528)\times 2+0.528\times 3=2.328$。

#### 如何测试你的输出

我们提供 `checker` 来测试你的输出文件是否可接受。

调用这个程序后，`checker` 将根据你得到的输出文件给出测试的结果，其中包括：
- 非法退出：未知错误；
- `Format error`：输出文件格式错误；
- `Not a permutation`：输出文件不是一个 $1\sim n$ 的排列；
- `OK.Your answer is xxx`：输出文件可以被接受，`xxx`为对应的期望奖金。

#### 评分方法

每个测试点单独评分。

对于每一个测试点，如果你的输出文件不合法，如文件格式错误、输出解不符合要求等，该测试点得 $0$ 分。否则如果你的输出的期望奖金为 $\text{your\_ans}$，参考期望奖金为 $\text{our\_ans}$，我们还设有一个用于评分的参数 $d$，你在该测试点中的得分如下：

- 如果 $\text{your\_ans}>\text{our\_ans}$，得 $12$ 分。
- 如果 $\text{your\_ans}<\text{our\_ans}\times d$，得 $1$ 分。
- 否则得分为：
  $$
  \left\lfloor\frac{\text{your\_ans}-\text{our\_ans}\times d}{\text{our\_ans}-\text{our\_ans}\times d}\times 8\right\rfloor+2
  $$

#### 特别提示

请妥善保存输入文件 `*.in` 和你的输出 `*.out`，及时备份，以免误删。

#### 附加文件

checker 需要自行编译后使用。

请前往 [Github](https://github.com/MikeMirzayanov/testlib) 下载 testlib.h 的最新源代码。


---

---
title: "[NOI2000] 算符破译"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5758
tag: ['2000', 'NOI']
---
# [NOI2000] 算符破译
## 题目描述

考古学发现，几千年前古梅文明时期的数学非常的发达，他们懂得多位数的加法和乘法，其表达式和运算规则等都与现在通常所用的方式完全相同（如整数是十进制，左边是高位，最高位不能为零；表达式为中缀运算，先乘后加等），唯一的区别是其符号的写法与现在不同。有充分的证据表明，古梅文明的数学文字一共有 $13$ 个符号，与 
 $0,1,2,3,4,5,6,7,8,9,+,*,=$ 这 $13$ 个数字和符号（称为现代算符）一一对应。为了便于标记，我们用 $13$ 个小写英文字母 $a,b,…m$ 代替这些符号（称为古梅算符）。但是，还没有人知道这些古梅算符和现代算符之间的具体对应关系。

在一个石壁上，考古学家发现了一组用古梅算符表示的等式，根据推断，每行有且仅有一个等号，等号左右两边为运算表达式（只含有数字和符号），并且等号两边的计算结果相等。

假设这组等式是成立的，请编程序破译古梅算符和现代算符之间的对应关系。

## 输入格式

-	第一行为等式的个数 $N$ （$ 1 \le N \le 1000 $），以下 $N$ 行每行为一个等式。
-	每个等式的长度为 $5$ 个字符到 $11$ 个字符。

## 输出格式

-	如果不存在对应关系能够满足这组等式，输出`noway`。
-	如果有对应关系能够满足这组等式，输出所有能够确定的古梅算符和现代算符的对应关系。每一行有两个字符，其中第一个字符是古梅算符，第二个字符是对应的现代算符。输出按照字典顺序排序。
## 样例

### 样例输入 #1
```
2
abcdec
cdefe

```
### 样例输出 #1
```
a6
b*
d=
f+

```
## 提示

**样例说明**

在上例中，可能对应的现代表达式为 $ \{6*2=12，2=1+1 \}， \{6*4=24，4=2+2 \}，\{ 6*8=48，8=4+4 \} $。可见，能够确定的对应关系只有 $a$ 对应 $6$ ，$b$ 对应 $*$ ，$d$ 对应 $=$，$f$ 对应 $+$ ，应该输出；而 ${c,e}$ 虽然能够找到对应的现代算符使得等式成立，但没有唯一的对应关系，不能输出。其他古梅算符 ${g,h…m}$ 完全不能确定，也不能输出。



---

---
title: "[NOI2020] 命运"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P6773
tag: ['2020', 'NOI', 'O2优化']
---
# [NOI2020] 命运
## 题目描述

**提示**：我们在题目描述的最后一段提供了一份简要的、形式化描述的题面。

在遥远的未来，物理学家终于发现了时间和因果的自然规律。即使在一个人出生前，我们也可以通过理论分析知晓他或她人生的一些信息，换言之，物理学允许我们从一定程度上“预言”一个人的“命运”。

简单来说，一个人的命运是一棵由时间点构成的有根树 $T$：树的根结点代表着出生，而叶结点代表着死亡。每个非叶结点 $u$ 都有一个或多个孩子 $v_1, v_2,\dots , v_{c_u}$，表示这个人在 $u$ 所代表的时间点做出的 $c_u$ 个不同的选择可以导向的不同的可能性。形式化的，一个选择就是树上的一条边 $(u, v_i)$，其中 $u$ 是 $v_i$ 的父结点。

一个人的一生是从出生（即根结点）到死亡（即某一个叶子结点）的一条不经过重复结点的路径，这条路径上任何一个包含至少一条边的子路径都是这个人的一段**人生经历**，而他或她以所有可能的方式度过一生，从而拥有的所有人生经历，都被称为**潜在的人生经历**。换言之，所有潜在的人生经历就是所有 $u$ 到 $v$ 的路径，满足 $u, v \in T$，$u \neq v$，并且 $u$ 是 $v$ 的祖先。在数学上，这样一个潜在的人生经历被记作有序对 $(u, v)$，树 $T$ 所有潜在的人生经历的集合记作 $\mathcal P_T$。

物理理论不仅允许我们观测代表命运的树，还能让我们分析一些潜在的人生经历是否是“重要”的。一个人所作出的每一个选择——即树上的每一条边——都可能是**重要**或**不重要**的。一段潜在的人生经历被称为重要的，当且仅当其对应的路径上存在一条边是重要的。我们可以观测到一些潜在的人生经历是重要的：换言之，我们可以观测得到一个集合 $\mathcal Q \subseteq \mathcal P_T$，满足其中的所有潜在的人生经历 $(u, v) \in \mathcal Q$ 都是重要的。

树 $T$ 的形态早已被计算确定，集合 $\mathcal Q$ 也早已被观测得到，一个人命运的不确定性已经大大降低了。但不确定性仍然是巨大的——来计算一下吧，对于给定的树 $T$ 和集合 $\mathcal Q$，存在多少种不同的方案确定每条边是否是重要的，使之满足所观测到的 $\mathcal Q$ 所对应的限制：即对于任意 $(u, v) \in \mathcal Q$，都存在一条 $u$ 到 $v$ 路径上的边被确定为重要的。

**形式化的**：给定一棵树 $T = (V, E)$ 和点对集合 $\mathcal Q \subseteq V \times V$ ，满足对于所有 $(u, v) \in \mathcal Q$，都有 $u \neq v$，并且 $u$ 是 $v$ 在树 $T$ 上的祖先。其中 $V$ 和 $E$ 分别代表树 $T$ 的结点集和边集。求有多少个不同的函数 $f$ : $E \to \{0, 1\}$（将每条边 $e \in E$ 的 $f(e)$ 值置为 $0$ 或 $1$），满足对于任何 $(u, v) \in \mathcal Q$，都存在 $u$ 到 $v$ 路径上的一条边 $e$ 使得 $f(e) = 1$。由于答案可能非常大，你只需要输出结果对 $998,244,353$（一个素数）取模的结果。

## 输入格式

从标准输入读入数据。

第一行包含一个正整数 $n$，表示树 $T$ 的大小，树上结点从 $1$ 到 $n$ 编号，$1$ 号结点为根结点；

接下来 $n - 1$ 行每行包含空格隔开的两个数 $x_i, y_i$，满足 $1 \leq x_i, y_i \leq n$，表示树上的结点 $x_i$ 和 $y_i$ 之间存在一条边，但并不保证这条边的方向；

接下来一行包含一个非负整数 $m$，表示所观测得到信息的条数。

接下来 $m$ 行每行包含空格隔开的两个数 $u_i, v_i$，表示 $(u_i, v_i) \in \mathcal Q$。**请注意**：输入数据可能包含重复的信息，换言之可能存在 $i \neq j$，满足 $u_i = u_j$ 且 $v_i = v_j$。

输入数据规模和限制参见本题末尾的表格。
## 输出格式

输出到标准输出中。

输出仅一行一个整数，表示方案数对 $998, 244, 353$ 取模的结果。
## 样例

### 样例输入 #1
```
5
1 2
2 3
3 4
3 5
2
1 3
2 5
```
### 样例输出 #1
```
10
```
### 样例输入 #2
```
15
2 1
3 1
4 3
5 2
6 3
7 6
8 4
9 5
10 7
11 5
12 10
13 3
14 9
15 8
6
3 12
5 11
2 5
3 13
8 15
1 13
```
### 样例输出 #2
```
960
```
## 提示

#### 样例 1 解释

共有 $16$ 种方案，其中不满足题意的方案有以下 $6$ 种：

- $(1, 2),(2, 3),(3, 5)$ 确定为不重要，$(3, 4)$ 确定为重要：集合 $\mathcal Q$ 中没有限制被满足。
- $(1, 2),(2, 3),(3, 4),(3, 5)$ 确定为不重要：集合 $\mathcal Q$ 中没有限制被满足。
- $(1, 2),(2, 3)$ 确定为不重要，$(3, 4),(3, 5)$ 确定为重要：集合 $\mathcal Q$ 中 $(1, 3)$ 没被满足。
- $(1, 2),(2, 3),(3, 4)$ 确定为不重要，$(3, 5)$ 确定为重要：集合 $\mathcal Q$ 中 $(1, 3)$ 没被满足。
- $(2, 3),(3, 5)$ 确定为不重要，$(1, 2),(3, 4)$ 确定为重要：集合 $\mathcal Q$ 中 $(2, 5)$ 没被满足。
- $(2, 3),(3, 4),(3, 5)$ 确定为不重要，$(1, 2)$ 确定为重要：集合 $\mathcal Q$ 中 $(2, 5)$ 没被满足。
- 其他方案下，集合 $\mathcal Q$ 中的限制都被满足了。


#### 样例 3

见选手目录下的 destiny/destiny3.in 与 destiny/destiny3.ans。

#### 样例 4

见选手目录下的 destiny/destiny4.in 与 destiny/destiny4.ans。

| 测试点编号 |  $n$ |  $m$ |  $T$ 为完全二叉树 |
| :-: | :-:| :-: |:-:|
|  $1\sim 4$ |  $\le 10$ |  $\le 10$ | 否 |
|  $5$ |  $\le 500$ |  $\le 15$ | 否 |
|  $6$ |  $\le 10^4$ |  $\le 10$ | 否 | 
|  $7$ |  $\le 10^5$ |  $\le 16$ | 否 |
|  $8$ |  $\le 5\times 10^5$ |  $\le 16$ | 否 |
|  $9$ |  $\le 10^5$ |  $\le 22$ | 否 |
|  $10$ |  $\le 5\times 10^5$ |  $\le 22$ | 否 |
|  $11$ |  $\le 600$ |  $\le 600$ | 否 |
|  $12$ |  $\le 10^3$ |  $\le 10^3$ | 否 |
|  $13\sim 14$ |  $\le 2\times 10^3$ |  $\le 5\times 10^5$ | 否 |
|  $15\sim 16$ |  $\le 5\times 10^5$ |  $\le 2\times 10^3$ | 否 |
|  $17\sim 18$ |  $\le 10^5$ |  $\le 10^5$ | 是 |
|  $19$ |  $\le 5\times 10^4$ |  $\le 10^5$ | 否 |
|  $20$ |  $\le 8\times 10^4$ |  $\le 10^5$ | 否 |
|  $21\sim 22$ |  $\le 10^5$ |  $\le 5\times 10^5$ | 否 |
|  $23\sim 25$ |  $\le 5\times 10^5$ |  $\le 5\times 10^5$ | 否 |

---

### 测试点约束

**全部数据满足**：$n \leq 5 \times 10^5$，$m \leq 5 \times 10^5$。输入构成一棵树，并且对于 $1 \leq i \leq m$，$u_i$ 始终为 $v_i$ 的祖先结点。

**完全二叉树**：在本题中，每个非叶结点都有左右子结点，且所有叶子结点深度相同的树称为满二叉树；将满二叉树中的结点按照从上到下、从左向右的顺序编号，编号最小的若干个结点形成的树称为完全二叉树。



---

---
title: "[NOI2020] 时代的眼泪"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P6774
tag: ['2020', 'NOI', 'O2优化']
---
# [NOI2020] 时代的眼泪
## 题目描述

小 L 喜欢与智者交流讨论，而智者也经常为小 L 出些思考题。

这天智者又为小 L 构思了一个问题。智者首先将时空抽象为了一个二维平面，进而将一个事件抽象为该平面上的一个点，将一个时代抽象为该平面上的一个矩形。

为了方便，下面记 $(a, b) \leq (c, d)$ 表示平面上两个点 $(a, b),(c, d)$ 满足 $a \leq c$，$b \leq d$。

更具体地，智者给定了 $n$ 个**事件**，他们用平面上 $n$ 个不同的点 $\{(x_i, y_i)\}^n_{i=1}$ 来表示；智者还给定了 $m$ 个**时代**，每个时代用平面上一个矩形 $(r_{i,1}, r_{i,2}, c_{i,1}, c_{i,2})$ 来表示，其中 $(r_{i,1}, c_{i,1})$ 是矩形的左下角，$(r_{i,2}, c_{i,2})$ 是矩形的右上角，保证 $(r_{i,1}, c_{i,1}) \leq (r_{i,2}, c_{i,2})$。我们称时代 $i$ 包含了事件 $j$ 当且仅当 $(r_{i,1}, c_{i,1}) \leq (x_j, y_j ) \leq (r_{i,2}, c_{i,2})$。

智者认为若两个事件 $i, j$ 满足 $(x_i, y_i) \leq (x_j, y_j)$，则这两个事件形成了一次**遗憾**。而对一个时代内包含的所有事件，它们所形成的遗憾被称为这个**时代的眼泪**，而形成的遗憾次数则称为该时代的眼泪的大小。现在智者想要小 L 计算**每个时代的眼泪的大小**。

小 L 明白，如果他回答不了这个问题，他也将成为时代的眼泪，请你帮帮他。

## 输入格式

从标准输入中读入数据。

第一行两个整数 $n, m$，分别表示事件数与时代数。

第二行 $n$ 个整数 $p_i$，其中第 $i$ 个数表示事件 $i$ 在平面上的坐标为 $(i, p_i)$。保证 $p_i$ 为一个 $1$ 到 $n$ 的排列。

之后 $m$ 行，每行四个整数 $r_{i,1}, r_{i,2}, c_{i,1}, c_{i,2}$，表示每个时代对应的矩形。

## 输出格式

输出到文件标准输出中。

输出 $m$ 行，每行包含一个整数，第 $i$ 行输出第 $i$ 个时代的眼泪的大小。
## 样例

### 样例输入 #1
```
9 9
9 8 7 6 2 4 5 3 1
4 9 3 6
2 9 1 8
3 8 2 4
3 9 2 7
2 8 1 6
1 9 1 9
1 3 5 7
2 3 3 3
6 6 6 6
```
### 样例输出 #1
```
1
4
2
4
4
4
0
0
0
```
## 提示

#### 样例 1 解释

对于时代 $1$，包含的遗憾有 $(6, 7)$（即事件 $6$ 与事件 $7$ 形成的遗憾，下同）。

对于时代 $2$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $3$，包含的遗憾有 $(5, 6),(5, 8)$。

对于时代 $4$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $5$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $6$，包含的遗憾有 $(5, 6),(6, 7),(5, 7),(5, 8)$。

对于时代 $7, 8, 9$，它们均不包含任何遗憾。


#### 样例 2

见选手目录下的 tears/tears2.in 与 tears/tears2.ans。

该样例满足特殊限制 A（具体限制见测试点约束）。


#### 样例 3

见选手目录下的 tears/tears3.in 与 tears/tears3.ans。

该样例满足特殊限制 B（具体限制见测试点约束）。

对于所有测试点：$1 \leq n \leq 10^5$，$1 \leq m \leq 2 \times 10^5$，$1 \leq r_{i,1}, r_{i,2}, c_{i,1}, c_{i,2} \leq n$。

---

### 测试点约束

每个测试点的具体限制见下表：

| 测试点编号 |  $n\le $ |  $m\le $ | 特殊限制 |
| :-: | :-: | :-: | :-: |
|  $1\sim 3$ |  $10$ |  $10$ | 无 |
|  $4$ |  $3\times 10^3$ |  $3\times 10^3$ | 无 |
|  $5$ |  $4\times 10^3$ |  $4\times 10^3$ | 无 |
|  $6$ |  $5\times 10^3$ |  $5\times 10^3$ | 无 |
|  $7$ |  $2.5\times 10^4$ |  $5\times 10^4$ |  $\text{A}$ |
|  $8$ |  $5\times 10^4$ |  $10^5$ |  $\text{A}$ |
|  $9$ |  $7.5\times 10^4$ |  $1.5\times 10^5$ |  $\text{A}$ |
|  $10$ |  $10^5$ |  $2\times 10^5$ |  $\text{A}$ |
|  $11$ |  $6\times 10^4$ |  $1.2\times 10^5$ |  $\text{B}$ |
|  $12$ |  $8\times 10^4$ |  $1.6\times 10^5$ |  $\text{B}$ |
|  $13$ |  $10^5$ |  $2\times 10^5$ |  $\text{B}$ |
|  $14$ |  $2\times 10^4$ |  $4\times 10^4$ | 无 |
|  $15$ |  $3\times 10^4$ |  $6\times 10^4$ | 无 |
|  $16$ |  $4\times 10^4$ |  $8\times 10^4$ | 无 |
|  $17$ |  $5\times 10^4$ |  $10^5$ | 无 |
|  $18$ |  $6\times 10^4$ |  $1.2\times 10^5$ | 无 |
|  $19$ |  $7\times 10^4$ |  $1.4\times 10^5$ | 无 |
|  $20\sim 22$ |  $10^5$ |  $2\times 10^5$ |  $\text{C}$ |
|  $23\sim 25$ |  $10^5$ |  $2\times 10^5$ | 无 |

特殊限制 A：对于所有时代 $i$ 有 $c_{i,1} = 1, c_{i,2} = n$。

特殊限制 B：任意两个不同时代所代表的矩形，它们要么是包含关系（一个矩形在另一个矩形内，边界允许重合），要么是相离关系（两矩形不包含共同点，边界不允许重合）。

特殊限制 C：最多有 $50$ 对事件 $(i, j)(1 \leq i < j \leq n)$ 不满足 $(i, p_i) \leq (j, p_j)$。


---

---
title: "[NOI2020] 制作菜品"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P6775
tag: ['2020', 'NOI', 'Special Judge', 'O2优化']
---
# [NOI2020] 制作菜品
## 题目描述

厨师准备给小朋友们制作 $m$ 道菜，每道菜均使用 $k$ 克原材料。为此，厨师购入了 $n$ 种原材料，原材料从 $1$ 到 $n$ 编号，第 $i$ 种原材料的质量为 $d_i$ 克。$n$ 种原材料的**质量之和恰好为 $m \times k$ 克**，其中 $d_i$ 与 $k$ 都是**正整数**。

制作菜品时，一种原材料可以被用于多道菜，但为了让菜品的味道更纯粹，厨师打算每道菜**至多使用 $2$ 种**原材料。现在请你判断是否存在一种满足要求的制作方案。更具体地，方案应满足下列要求：
- 共做出 $m$ 道菜。
- 每道菜至多使用 $2$ 种原材料。
- 每道菜恰好使用 $k$ 克原材料。
- 每道菜使用的每种原材料的质量都为正整数克。
- $n$ 种原材料都被恰好用完。

若存在满足要求的制作方案，你还应该给出一种具体的制作方案。
## 输入格式

**本题单个测试点包含多组测试数据**。

第一行一个整数 $T$ 表示数据组数。对于每组数据：
- 第一行三个正整数 $n, m, k$ 分别表示原材料种数、需要制作的菜品道数、每道菜品需使用的原材料的质量。
- 第二行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 种原材料的质量 $d_i$。
## 输出格式

对于每组测试数据：
- **若不存在满足要求的制作方案，则输出一行一个整数 $-1$**;
- 否则你需要输出 $m$ 行，每行表示一道菜品的制作方案，根据使用的原材料种数，格式为下列两种之一：
  - 依次输出一行两个整数 $i$ 和 $x$，表示该道菜使用 $x$ 克第 $i$ 种原材料制作。你应保证 $1 \leq i \leq n$，$x = k$。
  - 依次输出一行四个整数 $i$、$x$、$j$ 和 $y$，表示该道菜使用 $x$ 克第 $i$ 种原材料与 $y$ 克第 $j$ 种原材料制作。你应保证$1 \leq i, j \leq n$，$i \not= j$，$x + y = k$，$x, y > 0$。

本题使用**自定义校验器**检验你的答案是否正确，因此若有多种满足条件的方案，你只需要输出**任意一种**。

你应保证方案输出的格式正确，且同一行中相邻的两个数使用单个空格分隔，除此之外你的输出中**不应包含其他多余字符**。
## 样例

### 样例输入 #1
```
4
1 1 10
10
4 3 100
80 30 90 100
5 3 1000
200 400 500 900 1000
6 4 100
25 30 50 80 95 120
```
### 样例输出 #1
```
1 10
1 80 2 20
2 10 3 90
4 100
-1
1 5 5 95
1 20 4 80
2 30 6 70
3 50 6 50
```
## 提示

#### 样例 1 解释

对于第二组数据，一种满足要求的制作方案为：
- 使用 $80$ 克原材料 $1$ 与 $20$ 克原材料 $2$ 做第一道菜。
- 使用 $10$ 克原材料 $2$ 与 $90$ 克原材料 $3$ 做第二道菜。
- 使用 $100$ 克原材料 $4$ 做第三道菜。

#### 样例 2

见选手目录下的 dish/dish2.in 与 dish/dish2.ans。

#### 样例 3

见选手目录下的 dish/dish3.in 与 dish/dish3.ans。

---

### 测试点约束

对于所有测试点：
$1 \leq T \leq 10$，$1 \leq n \leq 500$，$n - 2 \leq m \leq 5000$，$m \geq 1$，$1 \leq k \leq 5000$，$\sum_{i=1}^{n}d_i = m \times k$。

每个测试点的具体限制见下表：

| 测试点编号 |  $n$ |  $m$ |  $k$ |
| :-: | :-: | :-: | :-: |
|  $1\sim 3$ |  $\le 4$ |  $\le 4$ |  $\le 50$ |
|  $4\sim 5$ |  $\le 10$ |  $\le 10$ |  $\le 5\times 10^3$ |
|  $6\sim 7$ |  $\le 500$ |  $=n-1$ |  $\le 5\times 10^3$ |
|  $8\sim 9$ |  $\le 500$ |  $n-1\le m\le 5\times 10^3$ |  $\le 5\times 10^3$ |
|  $10$ |  $\le 25$ |  $\le 5\times 10^3$ |  $\le 5\times 10^3$ |
|  $11\sim 12$ |  $\le 25$ |  $\le 5\times 10^3$ |  $\le 500$ |
|  $13\sim 14$ |  $\le 50$ |  $\le 5\times 10^3$ |  $\le 500$ |
|  $15\sim 17$ |  $\le 100$ |  $\le 5\times 10^3$ |  $\le 5\times 10^3$ |
|  $18\sim 20$ |  $\le 500$ | $\le 5\times 10^3$ |  $\le 5\times 10^3$ |


---

---
title: "[NOI2020] 超现实树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P6776
tag: ['2020', 'NOI', 'O2优化']
---
# [NOI2020] 超现实树
## 题目背景

下课铃声响起，机房里的两位女生从座位上站起来。（下面用 $\mathbf{X1}$, $\mathbf{X2}$ 代指两人）

$\mathbf{X2}$：省选前的集训真难熬啊…… 听课、考试、讲评、补题 —— 对于现在的我来说，即使在梦里想到一道数据结构题，也会不由自主地开始思考吧。

$\mathbf{X1}$：重复训练对我来说似乎并不是什么负担，但我确实感觉到解决题目带来的愉悦感在最近逐渐减弱了。也许我们需要一些精神上的 “刺激”：一些不拘泥于繁复技术的智力游戏，来让我们找回对于数学和算法的兴趣。

$\mathbf{X2}$：咦，我好像收到了一封用英文写的短信，似乎是…… 数学书上的一些片段。
## 题目描述

$\mathbf{X1}$：我来翻译一下短信的内容。

> 定义：本文所述的树是归纳定义的：单独的结点构成一棵树，以一棵树作为左（或右）孩子可以构成一棵树，以两棵树分别作为左、右孩子也可以构成一棵树。仅由以上规则用有限步生成的所有结构被称为树。

$\mathbf{X2}$：也就是说，这里所说的树是指**非空、有根、区分左右孩子的二叉树**。

$\mathbf{X1}$：的确如此。接下来书上定义了两棵树的同构。

> 定义：称两棵树 $T$, $T^{\prime}$ 同构，记做 $T \equiv T^{\prime}$，由以下四条规则定义：
> 1. 由单独结点构成的树是彼此同构的；
> 2. 如果两棵树的根结点均只有左子树，并且它们的左子树同构，那么这两棵树是同构的；
> 3. 如果两棵树的根结点均只有右子树，并且它们的右子树同构，那么这两棵树是同构的；
> 4. 如果两棵树的根结点均有左、右子树，并且它们的左、右子树分别对应同构，那么这两棵树是同构的。
> 
> 很明显，同构关系构成了所有树上的一个等价关系。为了方便，我们将同构的树看作相同的树。

$\mathbf{X2}$：将同构的树看成相同的树就是说树的结点是彼此相同的。简单地说，两棵树同构当且仅当**他们在结点无标号、区分左右孩子的意义下相同**；我们说两棵树不同，当且仅当它们不同构。

$\mathbf{X1}$：书里还定义了树的**叶子**：和通常的定义一样，叶子指**没有任何孩子的结点**。

$\mathbf{X2}$：这和我们熟悉的定义完全一致。嘛，数学家真是有点啰嗦…… 恐怕只有 $\mathbf{X3}$ 那种家伙会喜欢这种做派吧。

$\mathbf{X1}$：我倒是对此不太反感 —— 比起基于经验的 “直觉”，准确的定义和严谨的证明还是更加让人安心。你看，下一个定义就没有那么直观了。

> 定义：称一棵树 $T$ **单步替换**成为 $T^{\prime}$，如果将 $T$ 的某一**叶子结点**替换为另一棵树 $T^{\prime \prime}$ 得到的树与 $T^{\prime}$ 同构，记做 $T \rightarrow T^{\prime}$；称一棵树 $T$ **替换**成为 $T^{\prime}$，记做 $T \rightarrow^{\star} T^{\prime}$，如果存在自然数 $n \geq 1$ 和树 $T_{1}, T_{2}, \ldots, T_{n}$，使得 $T \equiv T_{1} \rightarrow T_{2} \rightarrow \cdots \rightarrow T_{n} \equiv T^{\prime}$。

$\mathbf{X2}$：我来想想…… 所谓替换，就是删掉某个叶子结点并在对应的位置放入另一棵树，就像那个叶子结点 “长出了” 一个更大的子树一样；一棵树替换成为另一棵树，说明它可以经由**零次、一次或多次**单步替换得到那棵树。哦…… 我明白了！举例来说，任何一棵树都可以替换成它本身，换言之对于树 $T$，都有 $T \rightarrow^{\star} T^{\prime}$。下面这个图片可以帮助理解单步替换和替换的含义。

![img](https://cdn.luogu.com.cn/upload/image_hosting/0o4pfqui.png)

$\mathbf{X1}$：你说得对。特别地，任何一棵树都可以替换得到无穷多棵不同的树，并且仅有一个结点构成的树可以替换得到任意其他的树。书上也有定义这样的东西。

> 定义：对于一棵树 $T$，定义 $\operatorname{grow}(T)$ 表示 T 所能替换构成的树的集合，即 $\operatorname{grow}(T)=\left\{T^{\prime} \mid T \rightarrow^{\star} T^{\prime}\right\}$。更近一步，如果 $\mathscr{T}=\left\{T_{1}, T_{2}, \ldots, T_{n}\right\}$ 是一个树的有限集合，定义 $\operatorname{grow}(\mathscr{T})$ 为所有 $\operatorname{grow}\left(T_{i}\right)$ 的并集，其中 $i=1,2, \ldots, n$。即 
> $$\operatorname{grow}(\mathscr{T})=\bigcup_{T_{i} \in \mathscr{T}} \operatorname{grow}\left(T_{i}\right)$$

$\mathbf{X2}$：我们把 $\operatorname{grow}(\mathscr{T})$ 称作树的集合 $\mathscr{T}$ **所生长得到的集合**吧 —— 也就是说，树的集合 $\mathscr{T}$ 所生长得到的集合包含所有可以被某个 $T \in \mathscr{T}$ 替换得到的树。不妨把树的集合叫做**树林**。不太严谨地说，一个树林所生长得到的新树林就是其中所有树、以所有可能的方式生长得到的树林。显而易见，一个非空树林所生长得到的树林都是无穷树林。但这个无穷树林，或者说 $\operatorname{grow}(\mathscr{T})$，并不一定包含所有的树 —— 更进一步，它甚至不一定包含 “几乎所有” 的树。

$\mathbf{X1}$：让我来补充一下：我们称一个树林是**几乎完备**的（或称**几乎包含了所有的树**），如果仅有有限多的树不在其中。对于一个有限树林 $\mathscr{T}$，$\operatorname{grow}(\mathscr{T})$ 要么包含了所有的树，要么包含了几乎所有的树，要么存在无穷多棵树不在其中。如果这是一道 OI 题，出题人一定会**在样例中给出三种情况的例子**吧。书上的关键定理也用了和我们相同的定义。

> **定理**（**几乎完备的可判定性**）：一个树的集合是**几乎完备**的，如果仅有有限棵树不在其中。那么，对于一个给定的树的有限集合 $\mathscr{T}$，存在高效的算法判定 $\operatorname{grow}(\mathscr{T})$ 是否是几乎完备的。

$\mathbf{X2}$：这个问题变成一个纯粹的 OI 题目了！让我用我们的语言来重述一下题意：**给定一个有限大小的树林 $\mathscr{T}$，判定 $\operatorname{grow}(\mathscr{T})$ 是否是几乎完备的，即是否仅有有限棵树不能被树林中所包含的树生长得到**。

$\mathbf{X1}$：也就是说，给定一个有限的树的集合 $\mathscr{T}$，判定是否仅有有限个树 $T$，满足 $T \notin \operatorname{grow}(\mathscr{T})$。所谓 $T \notin \operatorname{grow}(\mathscr{T})$，就是说不存在 $T^{\prime} \in \mathscr{T}$，使得 $T^{\prime} \rightarrow^{\star} T$。这和通常的 OI 题目的确非常不同：我甚至没有想到这个问题的一个算法。

$\mathbf{X2}$：我也一样，不过我很久没有感受到这种解决未知问题的冲动了。
## 输入格式

本题有多组测试数据，输入文件的第一行包含一个正整数 $N$，表示测试数据的组数。接下来包含恰好 $N$ 组测试数据，每组测试数据具有以下的格式：

第一行是一个正整数 $m$，表示树的集合中树的个数。接下来按照以下格式输入 $m$ 棵树：
- 首先是一个正整数 $n$，表示树中的结点个数，结点编号为 $1,2, \ldots, n$；
- 接下来 $n$ 行每行两个非负整数，其中第 $i$ 行从左到右包含用空格隔开的 $l_i$ 和 $r_i$，分别表示 $i$ 号结点左、右孩子结点的编号。如果左（或右）孩子不存在，那么 $l_i$（或 $r_i$）为 $0$。当然，叶结点一定满足 $l_i = r_i = 0$。
- 输入数据保证构成一棵以 $1$ 号结点作为根结点的树。**请注意**：结点的编号只是为了方便输入，任何同构的树都被视为是相同的。

所输入的 $m$ 棵树中可能存在彼此同构的树；如果去除这些重复的树（即每种同构的树只留下一个），它们可以构成一个树的集合 $\mathscr{T}$。你需要判定这一树的集合所生长得到的集合 $\operatorname{grow}(\mathscr{T})$ 是否是几乎完备的。
## 输出格式

输出包含 $N$ 行，分别表示 $N$ 组测试数据的答案。其中，第 $i$ 行输出一个字符串：如果第 $i$ 组测试数据所输入的树的集合所生长得到的集合是几乎完备的（换言之，仅有有限棵树不能被其生长得到），那么输出 `Almost Complete`；否则输出 `No`。**请注意输出字符串的拼写和大小写**。
## 样例

### 样例输入 #1
```
1
1
1
0 0
```
### 样例输出 #1
```
Almost Complete
```
### 样例输入 #2
```
1
3
3
2 3
0 0
0 0
2
2 0
0 0
2
0 2
0 0
```
### 样例输出 #2
```
Almost Complete
```
### 样例输入 #3
```
1
2
3
2 3
0 0
0 0
2
2 0
0 0
```
### 样例输出 #3
```
No
```
## 提示

#### 样例 2 解释
这一样例仅包含一组测试数据，其中树的集合 $\mathscr{T}$ 包含三棵树，如下图所示。容易发现，仅有单个结点构成的树不在 $\operatorname{grow}(\mathscr{T})$ 中，其包含了几乎所有树，因而是几乎完备的。

![img2](https://cdn.luogu.com.cn/upload/image_hosting/394s081s.png)

#### 样例 3 解释
这一样例仅包含一组测试数据，其中树的集合 $\mathscr{T}$ 包含两棵树。容易发现，对于所有的 $n \geq 2$，包含 $n$ 个结点，每个非叶结点仅有右孩子的链状树都不在 $\operatorname{grow}(\mathscr{T})$ 中，因而存在无穷多棵树不在 $\operatorname{grow}(\mathscr{T})$ 中，$\mathscr{T}$ 不是几乎完备的。

#### 样例 4
见选手目录下的 surreal/surreal4.in 与 surreal/surreal4.ans。

---

### 测试点约束

**全部数据满足**：$\sum n \leq 2 \times 10^{6}$， $\sum m \leq 2 \times 10^{6}$， $\max h \leq 2 \times 10^{6}$， $N \leq 10^{2}$。其中，$\sum n$ 表示这一测试点所有测试数据中所出现的所有树的结点个数之和；$\sum m$ 表示这一测试点中所有测试数据中所出现的树的个数；$\max h$ 表示这一测试点中所出现的所有树的最高高度（仅包含一个结点的树高度为 $1$）。下表中的表项 $\sum n$，$\sum m$ 和 $\max h$ 含义与上面相同，描述了每一组测试点的数据范围。

**特殊性质**：下面是下表中会涉及的四种特殊性质的解释。
- 特殊性质 $1$：对于这一测试点中的每一组测试数据，都有 $m \leq 4$，即树的集合中包括不超过 $4$ 棵树；
- 特殊性质 $2$：对于这一测试点中的每一组测试数据，树的集合中所有的树具有相同的高度；
- 特殊性质 $3$：对于这一测试点中的每一组测试数据，树的集合仅包含链（换言之，每个非叶结点仅包含一个孩子）；
- 特殊性质 $4$：对于这一测试点中的每一组测试数据，树的集合仅包含满足以下两个条件之一的树：
  - 每个非叶结点仅包含一个孩子；
  - 恰好有两个叶结点，它们具有相同的父结点，并且除这三个结点外，其余结点均有且仅有一个孩子。

每个测试点的具体限制见下表：

| 测试点编号 |  $N$ |  $\sum n$ |  $\sum m$ |  $\max h$ | 特殊性质 |
| :-: | :-: | :-: | :-: | :-: |:-:  |
|  $1$ |  $100$ |  $\le 10^3$ |  $\le 10^3$ |  $\le 1$ | 无 |
|  $2\sim 3$ |  $100$ |  $\le 10^3$ |  $\le 10^3$ |  $\le 2$ | 性质  $1$ |
|  $4$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 4$ | 无 | 
|  $5$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 5$ | 性质  $2$ | 
|  $6$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 8$ | 无 | 
|  $7$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 9$ | 性质  $2$ | 
|  $8$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 10$ | 无 | 
|  $9$ |  $100$ |  $\le 10^6$ |  $\le 10^6$ |  $\le 10^6$ | 性质  $3$ | 
|  $10$ |  $20$ |  $\le 10^3$ |  $\le 100$ |  $\le 10^3$ | 性质  $4$ | 
|  $11$ |  $20$ |  $\le 2\times 10^3$ |  $\le 2\times 10^3$ |  $\le 2\times 10^3$ | 性质  $4$ | 
|  $12$ |  $20$ |  $\le 10^5$ |  $\le 10^5$ |  $\le 10^5$ | 性质  $4$ | 
|  $13$ |  $20$ |  $\le 2\times 10^5$ |  $\le 2\times 10^5$ |  $\le 2\times 10^5$ | 性质  $4$ | 
|  $14$ |  $20$ |  $\le 800$ |  $\le 200$ |  $\le 800$ | 无 |
|  $15$ |  $20$ |  $\le 10^3$ |  $\le 100$ |  $\le 10^3$ | 无 |
|  $16$ |  $20$ |  $\le 2\times 10^3$ |  $\le 2\times 10^3$ |  $\le 2\times 10^3$ | 无 |
|  $17$ |  $40$ |  $\le 3\times 10^5$ |  $\le 3\times 10^5$ |  $\le 3\times 10^5$ | 无 |
|  $18$ |  $40$ |  $\le 6\times 10^5$ |  $\le 6\times 10^5$ |  $\le 6\times 10^5$ | 无 |
|  $19$ |  $40$ |  $\le 9\times 10^5$ |  $\le 9\times 10^5$ |  $\le 9\times 10^5$ | 无 |
|  $20$ |  $40$ |  $\le 1.2\times 10^6$ |  $\le 1.2\times 10^6$ |  $\le 1.2\times 10^6$ | 无 |
|  $21$ |  $40$ |  $\le 1.5\times 10^6$ |  $\le 1.5\times 10^6$ |  $\le 1.5\times 10^6$ | 无 |
|  $22\sim 25$ |  $40$ |  $\le 2\times 10^6$ |  $\le 2\times 10^6$ |  $\le 2\times 10^6$ | 无 |


---

---
title: "[NOI2020] 翻修道路"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P6777
tag: ['2020', 'NOI', 'O2优化', '弦图']
---
# [NOI2020] 翻修道路
## 题目描述

C 国中包含 $n$ 座城市，这些城市通过 $m$ 条双向道路连接。城市从 $1$ 到 $n$ 编号，道路从 $1$ 到 $m$ 编号，$i$ 号道路两端连接着城市 $u_i$ 与城市 $v_i$，它的长度为 $w_i$ 米。经由这些道路，从 C 国中任意一个城市出发，均能到达其他所有城市。

C 国人民喜欢环路旅程，但又不喜欢经过太多条道路，为此 C 国的道路被建造得非常特殊。更具体地，对于一条经过 $l$ 条道路的简单环路（即除起点城市外**不经过重复城市**的环路），它可以表示为 $c_{1} \rightarrow c_{2} \rightarrow \cdots \rightarrow c_{l} \rightarrow c_{1}$（其中对于所有 $1 \leq i<l$，城市 $c_i$ 与城市 $c_{i+1}$ 有道路相连；城市 $c_l$ 与城市 $c_1$ 有道路相连；对于所有 $1 \leq i<j \leq l$，有 $c_{i} \neq c_{j}$），若 $l > 3$，则 C 国的道路将满足下列条件：
  - 存在两个在该环路上**不相邻**的城市 $u$, $v$，满足两个城市间有道路直接相连。即：存在 $1 \leq u<v \leq l$，使得 $v-u \geq 2$，$u$ 和 $v$ 不同时为 $1$ 和 $l$，并且城市 $c_u$ 与城市 $c_v$ 间有道路直接相连。

现在 C 国有了新的翻修计划，需要在城市 $s$ 与城市 $t$ 间寻找一条路径进行翻修。翻修时路径中包含的所有道路将无法通行，为了保障人民的日常生活，C 国希望在翻修这条路径时，经由**剩余**的道路（即没被包含在翻修路径内的道路）依然能满足：**从 C 国中任意一个城市出发，均能到达其他所有城市**。

C 国找到了身为工程大师的你，请你帮助 C 国找出一条满足上述要求的翻修路径，并使得这条路径的总长**尽量小**。
## 输入格式

第一行两个整数 $n$, $m$ 分别表示城市个数与道路条数。

接下来 $m$ 行每行三个整数 $u_i$, $v_i$, $w_i$，依次表示每条道路的两个端点与它的长度。

数据保证每条道路都一定连接两个不同城市，即 $u_i \not= v_i$。

最后一行两个整数 $s$, $t$，分别表示需要翻修的路径的两个端点。
## 输出格式

仅一行一个整数，表示满足题目要求的情况下，翻修路径的总长的最小值。

**如果不存在满足题目要求的路径，输出一行一个整数$-1$。**
## 样例

### 样例输入 #1
```
4 5
1 2 1
2 3 1
3 4 1
1 3 5
2 4 6
1 4

```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
2 1
1 2 1
1 2

```
### 样例输出 #2
```
-1
```
## 提示

#### 样例 1 解释

路径 $(1,2,1),(2,3,1),(3,4,1)$ 是城市 $1$ 和城市 $4$ 间总长最小的路径，但不符合要求。

路径 $(1,3,5),(3,4,1)$ 符合要求，长度为 $6$。

路径 $(1,2,1),(2,4,6)$ 符合要求，长度为 $7$。

除上述两条路径外，没有其他满足要求的路径。

#### 样例 3

见选手目录下的 road/road3.in 与 road/road3.ans。该样例与测试点 $1 \sim 6$ 限制相同。

#### 样例 4

见选手目录下的 road/road4.in 与 road/road4.ans。该样例与测试点 $7 \sim 10$ 限制相同。

#### 样例 5

见选手目录下的 road/road5.in 与 road/road5.ans。该样例与测试点 $11 \sim 15$ 限制相同。

#### 样例 6

见选手目录下的 road/road6.in 与 road/road6.ans。该样例与测试点 $16 \sim 20$ 限制相同。

*然而，后面三个样例太大了，传不上来。。。*

---

### 测试点约束

对于所有测试点：$2 \leq n \leq 5 \times 10^{5}$，$2 \leq m \leq 10^{6}$，$s \neq t$。

$1 \leq u_{i}, v_{i} \leq n$，$u_{i} \neq v_{i}$，$1 \leq w_{i} \leq 10^{9}$，保证任意两条道路它们的端点不全相同。

保证给出的道路满足题面描述第二段中的性质。

每个测试点的具体限制见下表：

| 测试点编号 |  $n\le $ |  $m\le $ | 特殊限制 |
| :-: | :-: | :-:| :-: |
|  $1\sim 6$ |  $2\times 10^3$ |  $4\times 10^3$ | 无 |
|  $7\sim 10$ |  $5\times 10^5$ |  $10^6$ |  $\text{A}$ |
|  $11\sim 15$ |  $5\times 10^5$ |  $10^6$ |  $\text{B}$ |
|  $16\sim 20$ |  $5\times 10^5$ |  $10^6$ | 无 |

特殊限制 A：所有道路的长度均相等。

特殊限制 B：所有 $w_i = 1$ 的道路恰好构成 $s$ 到 $t$ 的一条路径，且其他 $w_i \not= 1$ 的道路的两条端点在这条路径上距离为 $2$。


---

---
title: "[NOI Online 2021 提高组] 愤怒的小 N"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7468
tag: ['2021', 'NOI Online']
---
# [NOI Online 2021 提高组] 愤怒的小 N
## 题目描述

极度愤怒的小 N 通关了一款游戏来泄愤。

这款游戏共有 $n$ 关，分别为第 $0$ 关、第 $1$ 关、第 $2$ 关、$\cdots$、第 $n-1$ 关。这些关卡中有一些是普通关卡，另一些则是奖励关卡。

这款游戏中普通关卡与奖励关卡的分布比较特殊。如果用字符 $\texttt{a}$ 表示普通关卡，用字符 $\texttt{b}$ 表示奖励关卡，那么第 $0$ 关、第 $1$ 关、第 $2$ 关、$\cdots$、第 $n-1$ 关依次排列形成的字符串是一个无穷字符串 $s$ 的前缀，且 $s$ 可以按照如下方式构造：

1. 初始时 $s$ 为包含单个字符 $\texttt{a}$ 的字符串。

2. 将 $s$ 的每个字符 $\texttt{a}$ 替换成字符 $\texttt{b}$，每个字符 $\texttt{b}$ 替换成字符 $\texttt{a}$ 得到字符串 $t$，然后将 $t$ 拼接到 $s$ 后。
3. 不断执行2. 得到的字符串就是最终的 $s$。

可以发现 $s=\texttt{abbabaabbaababba}\cdots$，所以这款游戏的第 $0$ 关是普通关卡，第 $1$ 关
是奖励关卡，第 $2$ 关是奖励关卡，第 $3$ 关是普通关卡，以此类推。

通过游戏的第 $i$ 关可以得到 $f(i)$ 分，其中 $f(x)=a_0+a_1x+a_2x^2+\cdots+a_{k-1}x^{k-1}$ 
是一个固定的 $k-1$ 次多项式。

小 N 通关时一气之下通过了所有奖励关卡而忽略了所有普通关卡，然后就把游戏卸载了。现在回想起来，他想要知道他在卸载游戏前的总得分对 $10^9+7$ 取模后的结果。
## 输入格式

第一行一个正整数 $n$，表示游戏的关卡数目。为方便，$n$ 以二进制表示给出。

第二行一个正整数 $k$，表示多项式的次数加一。

第三行 $k$ 个非负整数，分别为 $a_0,a_1,a_2,\cdots,a_{k-1}$，表示多项式的各项系数。
## 输出格式

一行一个非负整数，表示小 N 卸载游戏前的总得分对 $10^9 + 7$ 取模后的结果。
## 样例

### 样例输入 #1
```
1000
3
3 2 1
```
### 样例输出 #1
```
110

```
### 样例输入 #2
```
11111100101
4
2 0 2 1
```
### 样例输出 #2
```
143901603

```
### 样例输入 #3
```
1001011001101001
16
1 0 0 1 0 1 1 0 0 1 1 0 1 0 0 1
```
### 样例输出 #3
```
184740992

```
## 提示

对于所有测试点：$0\le \log_2n<5\times 10^5$，$1\le k\le 500$，$0\le a_i < 10^9 + 7$，$a_{k-1}\ne 0。$

| 测试点编号 | $\log_2n\le$ | $k\le$ |
|:-:|:-:|:-:|
| $1\sim2$ | $10$ |$500$ |
| $3\sim4$ | $20$ | $500$ |
| $5\sim8$ | $100$ | $500$ |
| $9\sim10$ | $500$ | $500$ |
| $11\sim12$ | $5\times 10^5$ | $1$ |
| $13\sim16$ | $5\times 10^5$ | $100$ |
| $17\sim20$ | $5\times 10^5$ | $500$ |

感谢 [s_r_f](https://www.luogu.com.cn/user/52518) 提供数据。


---

---
title: "[NOI Online 2021 提高组] 岛屿探险"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7470
tag: ['2021', 'NOI Online']
---
# [NOI Online 2021 提高组] 岛屿探险
## 题目描述

凇睦是一个喜欢探险的女孩子，这天她到一片海域上来探险了。

在这片海域上一共有 $n$ 座岛屿排成一排，标号为 $1,2,3, \ldots ,n$。每座岛屿有两个权值，分别为劳累度 $a_i$ 和有趣度 $b_i$。

对于一座劳累度为 $a$，有趣度为 $b$ 的小岛，如果这个小岛满足 $(a\oplus c) \leq \min(b,d)$，凇睦到这座岛探险就会感到开心，其中 $c$ 表示凇睦到岛上去之前就有的劳累度（称作初始劳累度），同理 $d$ 代表凇睦的初始有趣度。$\oplus$ 表示二进制异或（即二进制表示下不进位的加法）。

为了玩的更尽兴，凇睦会向你询问 $q$ 次，每次给出一个区间 $[l_i,r_i]$ 和两个数 $c_i,d_i$，你需要告诉凇睦若她的初始劳累度为 $c_i$，初始有趣度为 $d_i$，则有多少个标号在 $[l_i,r_i]$ 这个区间内的岛屿能使凇睦探险时感到开心。
## 输入格式

第一行两个正整数 $n,q$ 分别表示岛屿的数量和询问的数量。

接下来 $n$ 行，每行两个整数 $a_i,b_i$ 分别表示第 $i$ 座岛屿的劳累度和有趣度。

接下来 $q$ 行，每行四个正整数 $l_i,r_i,c_i,d_i$ 分别表示区间左端点，区间右端点，初始劳累度与初始有趣度。
## 输出格式

输出一共 $q$ 行，每行一个整数对应一个询问的答案。

## 样例

### 样例输入 #1
```
4 2
1 1
4 2
5 1
2 7
1 4 6 5
2 4 3 3
```
### 样例输出 #1
```
2
1
```
### 样例输入 #2
```
20 10
215 144
2 110
174 132
214 142
116 108
155 192
236 208
216 214
99 220
236 118
190 81
230 131
10 238
189 198
183 13
45 193
14 234
208 192
126 19
49 38
7 14 251 184
2 18 89 76
11 15 49 196
8 11 83 139
10 15 119 239
9 16 148 120
11 17 225 34
15 16 3 46
14 15 86 227
7 18 252 103
```
### 样例输出 #2
```
7
2
2
2
1
3
1
1
0
7
```
## 提示

测试点 $1,2$ 满足 $1\leq n,q\leq 5000$。

测试点 $3,4$ 满足 $1\leq n,q\leq 10^4$。

测试点 $5,6,7$ 满足 $1\leq n,q\leq 10^5$ 且 $\max\{d_i\}\leq \min\{b_i\}$。

测试点 $8,9,10,11$ 满足 $1\leq n,q\leq 10^5$ 且 $\min\{d_i\}\geq \max\{b_i\}$。

测试点 $12,13$ 满足 $1\leq n,q\leq 10^5$ 且 $l_i=1,r_i=n$。

测试点 $14,15,16$ 满足 $1\leq n,q\leq 7\times 10^4$。

测试点 $17,18,19,20$ 满足 $1\leq n,q\leq 10^5$。

所有数据满足 $1\leq n,q\leq 10^5$， $1\leq a_i,b_i,c_i,d_i\leq 2^{24}-1$。


---

---
title: "[NOI2021] 密码箱"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7739
tag: ['平衡树', '2021', 'NOI', 'O2优化', '矩阵乘法']
---
# [NOI2021] 密码箱
## 题目描述

Yelekastee 是 U 国著名的考古学家。在最近的一次考古行动中，他发掘出了一个远古时期的密码箱。经过周密而严谨的考证，Yelekastee 得知密码箱的密码和某一个数列 $\{ a_n \}$ 相关。数列 $\{ a_n \}$ 可以用如下方式构造出来：

1. 初始时数列长度为 $2$ 且有 $a_0 = 0, a_1 = 1$；
2. 对数列依次进行若干次操作，其中每次操作是以下两种类型之一：
  - `W` 类型：给数列的**最后一项**加 $1$。
  - `E` 类型：若数列的**最后一项**为 $1$，则给倒数第二项加 $1$；否则先给数列的**最后一项**减 $1$，接着在数列尾再加两项，两项的值都是 $1$。

受到技术限制，密码箱并没有办法完整检查整个数列，因此密码箱的密码设定为数列 $\{ a_n \}$ 经过函数 $f$ 作用后的值，其中 $f$ 的定义如下：

$$ f(a_0, \ldots , a_{k - 1}, a_k) = \begin{cases} a_0, & k = 0 \\ f \! \left( a_0, a_1, \ldots , a_{k - 2}, a_{k - 1} + \frac{1}{a_k} \right) \! , & k \ge 1 \end{cases} $$

Yelekastee 并不擅长运算，因此他找到了你，希望你能根据他提供的操作序列计算出密码箱的密码。不幸的是，他的记性并不是很好，因此他会随时对提供的操作序列做出一些修改，这些修改包括以下三种：

- `APPEND c`，在现有操作序列后追加一次 `c` 类型操作，其中 `c` 为字符 `W` 或 `E`。
- `FLIP l r`，反转现有操作序列中第 $l$ 个至第 $r$ 个（下标从 $1$ 开始，修改包含端点 $l$ 和 $r$，下同）操作，即所有 `W` 变为 `E`，所有 `E` 变为 `W`。
- `REVERSE l r`，翻转现有操作序列中第 $l$ 个至第 $r$ 个操作，也就是将这个区间中的操作逆序。
## 输入格式

输入第一行包含两个正整数 $n, q$，分别表示初始的操作序列长度和修改的次数。

第二行包含一个长为 $n$ 且仅包含大写字母 `W` 和 `E` 的字符串，表示初始操作序列。

接下来 $q$ 行，每行表示一次修改。每种修改的格式如【题目描述】所述。
## 输出格式

输出共 $q + 1$ 行，每行两个整数，其中第一行表示初始操作序列对应的密码，接下来 $q$ 行则分别输出每次修改之后的操作序列对应的密码。

容易发现密码一定是正有理数。若真实的密码为 $\frac{a}{b}$，其中 $a, b > 0$ 且 $\gcd(a, b) = 1$，则你需要在对应的行内顺次输出 $a$ 和 $b$ 模 $998244353$ 后的余数。
## 样例

### 样例输入 #1
```
2 3
WE
APPEND E
FLIP 1 2
REVERSE 2 3

```
### 样例输出 #1
```
2 3
3 4
5 3
5 2

```
## 提示

**【样例解释 #1】**

| | 操作序列 | 数列 $\{ a_n \}$ | 密码 |
|:-:|:-:|:-:|:-:|
| 初始 | `WE` | $(0, 1, 1, 1)$ | $\frac{2}{3}$ |
| 第一次修改后 | `WEE` | $(0, 1, 2, 1)$ | $\frac{3}{4}$ |
| 第二次修改后 | `EWE` | $(1, 1, 1, 1)$ | $\frac{5}{3}$ |
| 第三次修改后 | `EEW` | $(2, 2)$ | $\frac{5}{2}$ |

**【样例 #2】**

见附件 `code/code2.in` 与 `code/code2.ans`。

该样例与测试数据 $1 \sim 4$ 满足同样的约束条件。

**【样例 #3】**

见附件 `code/code3.in` 与 `code/code3.ans`。

该样例与测试数据 $5 \sim 7$ 满足同样的约束条件。

**【样例 #4】**

见附件 `code/code4.in` 与 `code/code4.ans`。

该样例与测试数据 $8 \sim 10$ 满足同样的约束条件。

**【样例 #5】**

见附件 `code/code5.in` 与 `code/code5.ans`。

该样例与测试数据 $15 \sim 20$ 满足同样的约束条件。

**【数据范围】**

对于所有测试点：$1 \le n \le {10}^5$，$1 \le q \le {10}^5$。

对于 `APPEND` 修改，保证给出的 `c` 为大写英文字母 `W` 或 `E`。

对于 `FLIP` 和 `REVERSE` 修改，保证 $1 \le l \le r \le L$，其中 $L$ 是当前操作序列的长度。

请注意由于有 `APPEND` 操作，操作序列的长度最大可能有 $2 \times {10}^5$。

| 测试点编号 | $n, q \le$ | 特殊限制 |
|:-:|:-:|:-:|
| $1 \sim 4$ | $2000$ | 无 |
| $5 \sim 7$ | ${10}^5$ | A |
| $8 \sim 10$ | ${10}^5$ | B，C |
| $11 \sim 14$ | ${10}^5$ | C |
| $15 \sim 20$ | ${10}^5$ | 无 |

特殊限制 A：保证在任意时刻操作序列中不会出现连续相同的两个字符。

特殊限制 B：保证没有 `FLIP` 修改。

特殊限制 C：保证没有 `REVERSE` 修改。


---

---
title: "[NOI2021] 机器人游戏"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7740
tag: ['2021', 'NOI', 'O2优化']
---
# [NOI2021] 机器人游戏
## 题目描述

小 R 有 $m$（$1 \le m \le 1000$）个机器人和 $m$ 张纸带，第 $i$（$1 \le i \le m$）个机器人负责对第 $i$ 张纸带进行操作。对于每张纸带，它们都被从左到右分成了 $n$（$1 \le n \le 32$）个格子，依次编号为 $0, 1, \ldots , n - 1$。每个格子有 $3$ 种状态：1. 格子上写有数字 $0$；2. 格子上写有数字 $1$；3. 格子是一个空格子。

在任意时刻，机器人**必须**站在纸带上的一个格子中。在设定好机器人在纸带上的初始位置后，第 $i$ 个机器人会依次执行预先设定的操作序列 $S_i$，操作由 `R`、`0`、`1`、`*` 四种字符组成，其中：

1. `R` 表示机器人向右走一格，如果右边没有格子，则机器人会原地爆炸；
2. `0` 表示如果机器人所在格子非空，则将该格子上的数字改为 $0$，否则不修改；
3. `1` 表示如果机器人所在格子非空，则将该格子上的数字改为 $1$，否则不修改；
4. `*` 表示如果机器人所在格子非空，则将格子上的数字 $x$ 改为 $1 - x$，否则不修改。

第 $i$ 张纸带的状态可以用一个长度为 $n$ 的序列表示，每个元素为 `0`、`1` 或 `-`（空格子），依次表示其每个格子的状态。第 $i$ 张纸带的初始状态称为机器人 $i$ 的输入 $X_i$，操作执行完成后纸带的状态称为机器人 $i$ 的输出 $Y_i$。注意，如果机器人爆炸了，那么这个机器人就没有输出。

可以发现，如果一个格子为空，那么机器人永远不会修改它。所以每个机器人都有如下特性：如果第 $i$ 个机器人所在的纸带上的**所有格子**都为空，那么它就不会执行任何操作，它的输出即为所有格子都为空。

现在小 R 给定了每一个机器人的输入 $X_i$（即每张纸带的初始状态）以及目标输出 $Y_i$。小 R 希望小 D 找到一个位置 $p$（$0 \le p < n$），使得**所有机器人**都能以其所在纸带的第 $p$ 个格子为初始位置，在不爆炸的情况下执行完所有操作，并且满足第 $i$ 个机器人的输出为 $Y_i$。

小 D 花了几毫秒解决了问题，现在他想知道，有多少个输入和输出的组合方式使得上述问题有解，即有多少种为每个机器人设定输入 $X_0, X_1, \ldots , X_{m - 1}$ 和目标输出 $Y_0, Y_1, \ldots , Y_{m - 1}$ 的方式，使得至少存在一个位置 $p$（$0 \le p < n$），使得所有机器人都能以其所在纸带的第 $p$ 个格子为起点，在不爆炸的情况下执行完所有操作，且满足第 $i$ 个机器人的输出为 $Y_i$。请你帮助小 D 解决这个问题，由于最终的答案可能很大，请你输出答案对 ${10}^9 + 7$ 取模后的余数。

两个组合方式不同当且仅当，存在至少一个机器人，它的输入或是目标输出在两个方式中不同。
## 输入格式

第一行包含两个正整数 $n, m$，分别表示每张纸带上的格子数和纸带数量。

接下来 $m$ 行，第 $i$ 行输入一个仅包含 `R` `0` `1` `*` 这四种字符的字符串 $S_i$，表示第 $i$ 个机器人的操作序列。
## 输出格式

仅一行一个正整数，表示答案模 ${10}^9 + 7$ 后的余数。
## 样例

### 样例输入 #1
```
2 1
1R*

```
### 样例输出 #1
```
9

```
### 样例输入 #2
```
3 2
1R0
*

```
### 样例输出 #2
```
1468

```
### 样例输入 #3
```
见附件中的 robot/robot3.in
```
### 样例输出 #3
```
见附件中的 robot/robot3.ans
```
### 样例输入 #4
```
见附件中的 robot/robot4.in
```
### 样例输出 #4
```
见附件中的 robot/robot4.ans
```
## 提示

**【样例解释 #1】**

| 方案编号 | 输入 $X_0$ | 目标输出 $Y_0$ | 可行初始位置 $p$ |
|:-:|:-:|:-:|:-:|
| $1$ | `--` | `--` | $0, 1$ |
| $2$ | `0-` | `1-` | $0$ |
| $3$ | `1-` | `1-` | $0$ |
| $4$ | `-0` | `-1` | $0$ |
| $5$ | `-1` | `-0` | $0$ |
| $6$ | `00` | `11` | $0$ |
| $7$ | `10` | `11` | $0$ |
| $8$ | `01` | `10` | $0$ |
| $9$ | `11` | `10` | $0$ |

表中 `-` 表示空格子，注意方案 $1$ 中的输入和输出中有两个空格子。

当输入全为空时，初始位置可以是 $0$ 或 $1$，因为根据题意，输入全为空时机器人不会执行任何操作。

当输入不全为空时，初始位置只能为 $0$，如果初始位置为 $1$ 机器人一定会爆炸。所以此时实际执行的操作是将第一格的数字改为 $1$，并将第二格的数字 $x$ 改为 $1 - x$。

**【样例解释 #2】**

可以用容斥原理来计算这个样例。

1. 初始位置 $p = 0$ 可以使得执行完所有操作后满足条件。那么第一个机器人的纸带 $0$ 号格子要么输入输出都是空，要么目标输出是 $1$（输入无所谓），所以有 $3$ 种方案；$1$ 号格子要么输入输出都是空，要么目标输出是 $0$，也是 $3$ 种方案；$2$ 号格子要么输入输出都是空，要么输入和目标输出相同（因为没有对该格子执行任何操作），同样是 $3$ 种方案，共 $27$ 种方案。第二个机器人的 $0$ 号格子要么输入输出都是空，要么输入和目标输出不同，是 $3$ 种方案，$1$ 号和 $2$ 号格子也都是 $3$ 种方案，共 $27$ 种方案。所以总共 $27 \times 27 = 729$ 种方案。
2. 初始位置 $p = 1$ 可以使得执行完所有操作后满足条件。那么第一个机器人的纸带三个格子都是 $3$ 种方案，其中 $0$ 号格子要么输入输出都为空，要么相同；$1$ 号格子要么输入输出都为空，要么目标输出是 $1$；$2$ 号格子的输入输出要么都为空，要么输出是 $0$，共 $27$ 种方案。第二个机器人的 $1$ 号格子要么输入输出都是空，要么输入和目标输出不同，是 $3$ 种方案；$0$ 号和 $2$ 号格子要么输入输出都为空，要么输入输出相同，也都是 $3$ 种方案，共 $27$ 种方案。总共 $27 \times 27 = 729$ 种方案。
3. 初始位置 $p = 2$ 可以使得执行完所有操作后满足条件。那么第一个机器人的纸带必须输入输出全为空（否则爆炸），只有 $1$ 种方案。第二个机器人是 $27$ 种方案，总共 $27$ 种方案。
4. 初始位置 $p = 0, 1$ 都满足条件。这要求第一个机器人的 $1$ 号格子输入输出都为空；$0$ 号格子的输入输出都为空或都为 $1$；$2$ 号格子的输入输出都为空或都为 $0$，所以第一个机器人的纸带有 $4$ 种方案。第二个机器人 $0$ 号格子和 $1$ 号格子都为空，$2$ 号格子有 $3$ 种方案，第二个机器人的 $0$ 号和 $1$ 号格子必须都为空，$2$ 号格子要么输入输出都为空，要么输入和输出相同，有 $3$ 种方案。总共 $12$ 种方案。
5. 初始位置 $p = 0, 2$ 都满足条件。那么第一个机器人的纸带必须输入输出全为空（否则爆炸），只有 $1$ 种方案。第二个机器人 $0$ 号和 $2$ 号格子都为空，$1$ 号格子有 $3$ 种方案。总共 $3$ 种方案。
6. 初始位置 $p = 1, 2$ 都满足条件。那么第一个机器人的纸带必须输入输出全为空，只有 $1$ 种方案。第二个机器人 $1$ 号和 $2$ 号格子都为空，$0$ 号格子有 $3$ 种方案。总共 $3$ 种方案。
7. 初始位置 $p = 0, 1, 2$ 都满足条件。那么两个机器人的输入输出必须都为空，总共 $1$ 种方案。

根据容斥原理，最后的答案为 $729 + 729 + 27 - 12 - 3 - 3 + 1 = 1468$。

**【数据范围】**

对于所有测试点：$1 \le n \le 32$，$1 \le m \le 1000$，$1 \le \lvert S_i \rvert \le 100$。

| 测试点编号 | $n \le$ | $m \le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $1$ | $1$ | 无 |
| $3$ | $8$ | $1$ | 无 |
| $4$ | $16$ | $1$ | 无 |
| $5 \sim 6$ | $32$ | $1$ | 无 |
| $7$ | $16$ | $5$ | 无 |
| $8 \sim 10$ | $32$ | $5$ | 无 |
| $11 \sim 12$ | $16$ | $1000$ | 无 |
| $13 \sim 15$ | $32$ | $1000$ | A |
| $16 \sim 21$ | $32$ | $1000$ | B |
| $22 \sim 25$ | $32$ | $1000$ | 无 |

特殊限制 A：操作序列中不存在 `R`。

特殊限制 B：每个操作序列中，`R` 的数量至多 $15$ 个。


---

---
title: "[NOIP2021] 棋局"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7963
tag: ['并查集', '2021', 'NOIP 提高组', 'O2优化', '线段树合并']
---
# [NOIP2021] 棋局
## 题目背景

在输了一晚上的麻将之后，小 z 和小 c 卸掉了手机上的所有牌类游戏。不过这怎么可能阻挡得了他们上课颓废的决心呢？现在他们的目光盯在了棋类游戏上，但他们两个除了天天下飞行棋以外，几乎所有棋类游戏都只懂个大概规则。

“既然我们都会玩但只能玩一点点，不如我们自己搞个缝合怪出来吧！”

于是，在他们的精心脑洞之下，一个融合了围棋、象棋与军棋的奇妙游戏诞生了……
## 题目描述

游戏在一张长 $n$ 行宽 $m$ 列的网格形棋盘上进行，棋子落在网格的交叉点上，我们不妨记左上角的交叉点的坐标为 $(1,1)$，右下角的交叉点坐标为 $(n,m)$。

棋子分为黑白两色，对局双方各执一方棋子。

每个棋子除了颜色以外还有等级，不妨设 $\mathit{col}_i$ 为棋子 $i$ 的颜色，$\mathit{lv}_i$ 为棋子 $i$ 的等级。另外，棋盘上的网格线共有 $4$ 种状态，对于第 $i$ 条网格线，设其状态为 $\mathit{opt}_i$。

轮到每方下棋时，他可以选择棋盘上的一个己方棋子沿网格线进行移动到另一个交叉点，称为走子。形式化定义走子的过程如下：选择一个坐标序列 $(x_0,y_0),(x_1,y_1),\ldots,(x_k,y_k)$，其中 $k$ 是任意选定的正整数，$(x_0,y_0)$ 是棋子初始的位置，$(x_k,y_k)$ 是棋子最终走到的位置，需要满足：

- 对于任意 $i=0,1,\ldots,k-1$，坐标 $(x_i,y_i)$ 和 $(x_{i+1},y_{i+1})$ 之间必须有网格线直接相连，也就是说**走子必须沿着网格线走**；
- 对于任意 $i\not=j$，必须有 $(x_i,y_i)\ne(x_j,y_j)$，也就是说走子过程中不能经过重复位置，特别地 $(x_0,y_0)\ne(x_k,y_k)$，也就是说**不能原地不动（或走回原地）**；
- 对于任意 $i=1,\ldots,k-1$，坐标 $(x_i,y_i)$ 上必须没有棋子，也就是说**走子时不能越过已有的棋子**；
- 若 $(x_k,y_k)$ 上没有棋子，称为普通走子，否则称为吃子。在吃子过程中，设正在走的棋子颜色为 $\mathit{col}_1$，等级为 $\mathit{lv}_1$，被吃的棋子颜色为 $\mathit{col}_2$，等级为 $\mathit{lv}_2$，则必须满足 $\mathit{col}_1\ne\mathit{col}_2,\mathit{lv}_1\geq\mathit{lv}_2$，换句话说**只能吃与自己颜色不同，且等级不高于自己等级的棋子**。

需要注意的是，由上述定义可以得出，不允许棋子在吃子后继续向前走。

网格线的状态含义如下所述：

- 如果 $\mathit{opt}_i=0$，代表此路不通，走子时不能经过这条网格线；
- 如果 $\mathit{opt}_i=1$，代表这条网格线是一条“普通道路”，每次走子时棋子最多只能经过 $1$ 条普通道路。
- 如果 $\mathit{opt}_i=2$，代表这条网格线是一条“直行道路”，每次走子时棋子可以经过任意条直行道路，但只能**一直沿横向或一直沿纵向走，不能转弯**。如沿直行道路从 $(1,1)$ 经过 $(1,2)$ 走到 $(1,3)$ 是可以的，但是从 $(1,1)$ 经过 $(1,2)$ 走到 $(2,2)$ 不行。
- 如果 $\mathit{opt}_i=3$，代表这条网格线是一条“互通道路”，每次走子时棋子可以经过任意条互通道路，且中途可任意转弯。

同时规定在一次走子过程中，**棋子经过的网格线的状态必须全部相同**，比如从 $(1,1)$ 经过直行道路走到 $(1,2)$ 再经过互通道路走到 $(1,3)$ 是不允许的。

至于如何判断胜负等其它细节，与本题无关，故略去。

小 z 和小 c 开发出这款棋类游戏后，为了提升水平，想了一个训练的策略：一开始棋盘是空的，然后小 c 会每次往棋盘的某个空交叉点上放一枚棋子，小 z 需要快速计算出：若选择这枚新放上的棋子进行一次走子，棋盘上一共有多少个位置是能被走到的？注意：因为这只是思维训练，他们并不会真的走这枚棋子。

可怜的小 z 发现他的计算力不足以算出这个问题，只好向你求助。
## 输入格式

每个测试点由多组数据组成。

第一行：一个正整数 $T$ 表示数据组数。

对于每组数据：

第一行：三个正整数 $n, m, q$，分别表示棋盘的行数、列数和游戏的轮数。

接下来 $n$ 行，每行为一个长 $m - 1$ 的字符串，每个字符为 $\texttt{0}$、$\texttt{1}$、$\texttt{2}$、$\texttt{3}$ 中的一个，第 $i$ 行第 $j$ 个字符表示交叉点 $(i, j)$ 连向交叉点 $(i, j + 1)$ 的网格线状态。 

接下来 $n - 1$ 行，每行为一个长 $m$ 的字符串，每个字符为 $\texttt{0}$、$\texttt{1}$、$\texttt{2}$、$\texttt{3}$ 中的一个，第 $i$ 行第 $j$ 个字符表示交叉点 $(i, j)$ 连向交叉点 $(i + 1, j)$ 的网格线状态。

接下来 $q$ 行，每行 $4$ 个非负整数 $\mathit{col}_i , \mathit{lv}_i , x_i , y_i$，表示在第 $i$ 轮有一枚颜色为 $\mathit{col}_i$，等级为 $\mathit{lv}_i$ 的棋子放在了交叉点 $(x_i , y_i)$ 上。其中 $\mathit{col}_i = 0$ 表示黑子，$\mathit{col}_i = 1$ 表示白子。保证之前交叉点 $(x_i , y_i)$ 上没有棋子。
## 输出格式

对于每组数据输出 $q$ 行，每行一个非负整数，表示第 $i$ 枚棋子放置后能走到的交叉点数量。
## 样例

### 样例输入 #1
```
1
3 3 5
13
22
23
010
233
0 1 2 3
1 2 2 1
1 3 1 2
0 2 3 2
1 3 2 2

```
### 样例输出 #1
```
4
3
3
3
2

```
### 样例输入 #2
```
2
2 3 4
22
33
123
0 2 1 2
0 1 2 1
1 2 1 3
0 3 2 2
3 2 3
3
1
3
32
32
0 2 1 2
1 2 3 2
0 1 2 2

```
### 样例输出 #2
```
3
4
4
2
5
5
1

```
### 样例输入 #3
```
见附件中的 chess/chess3.in
```
### 样例输出 #3
```
见附件中的 chess/chess3.ans
```
### 样例输入 #4
```
见附件中的 chess/chess4.in
```
### 样例输出 #4
```
见附件中的 chess/chess4.ans
```
## 提示

**【样例解释 #1】**

放置棋子 $1$ 后，它能走到的位置为 $(2, 1),(2, 2),(3, 2),(3, 3)$。

放置棋子 $2$ 后，它能走到的位置为 $(2, 2),(2, 3),(3, 1)$。

放置棋子 $3$ 后，它能走到的位置为 $(1, 1),(1, 3),(2, 2)$。

放置棋子 $4$ 后，它能走到的位置为 $(2, 2),(3, 1),(3, 3)$。

放置棋子 $5$ 后，它能走到的位置为 $(2, 3),(3, 2)$。


**【数据范围】**

| 测试点编号 | $n \times m \le$ | $q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $100$ | $50$ | 无 |
| $3 \sim 6$ | $5000$ | $2000$ | 无 |
| $7 \sim 8$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“直行道路”与“互通道路” |
| $9 \sim 11$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“互通道路” |
| $12 \sim 14$ | $2 \times {10}^5$ | ${10}^5$ | 不存在“直行道路” |
| $15 \sim 16$ | $2 \times {10}^5$ | ${10}^5$ | $\mathit{lv}_i = i$ |
| $17 \sim 18$ | $2 \times {10}^5$ | ${10}^5$ | $\mathit{lv}_i = q - i + 1$ |
| $19 \sim 21$ | $2 \times {10}^5$ | $2000$ | $n, m \le 1000$ |
| $22 \sim 25$ | $2 \times {10}^5$ | ${10}^5$ | 无 |

对于 $100 \%$ 的数据，$1 \le T \le 5$，$2 \le n, m \le {10}^5$，$4 \le n \times m \le 2 \times {10}^5$，$1 \le q \le \min \{ {10}^5, n \times m \}$，$1 \le \mathit{lv}_i \le q$，$1 \le x_i \le n$，$1 \le y_i \le m$，$\mathit{col}_i \in \{ 0, 1 \}$。

注：由于本题输入输出规模较大，建议使用较为快速的输入输出方式。


---

---
title: "[NOI2022] 移除石子"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8497
tag: ['2022', 'NOI', 'O2优化', 'DP 套 DP']
---
# [NOI2022] 移除石子
## 题目描述

你正在玩一个名为“移除石子”的小游戏。

有 $n$ 堆石子排成一行，第 $i$ 堆有 $a_i$ 枚，你的任务是通过如下的操作将所有石子移除：

- 操作一：选择一堆石子，将其中的至少 $2$ 枚石子移除；
- 操作二：选择一个连续的编号区间 $[l, r]$（$1 \le l \le r \le n$）并满足 $r - l \ge 2$，将其中的每一堆石子都恰好移除 $1$ 枚。

你可以采用任意顺序执行任意多次上述两种操作，直到无法再执行操作为止。若最后你能将所有石子全部移除则胜利。

你或许已经开始计算起了诸如“有多少种本质不同的操作方式”的问题，但实际玩起来你却发现自己总是在输。因此，你打算玩个小花招：在游戏开始时，你在手里偷偷藏有 $k$ 枚石子，在执行所有操作之前你**可以且必须**将这些石子放入某一堆或某几堆石子中。你期望这会提高自己的胜率，但也清楚这可能会使自己输掉原本可能胜利的游戏。

现在，你可以自由选择一个初始局面进行游戏，具体而言，每个 $a_i$ 可以选择 $[l_i, r_i]$ 范围内的任意整数。你希望计算出，在多少种初始局面下，自己存在至少一种获胜的方案。由于答案很大，你只需要输出其对 $({10}^9 + 7)$ 取模的结果。**两个初始局面不同，当且仅当存在至少一个 $\boldsymbol{1 \le i \le n}$ 使得两者的 $\boldsymbol{a_i}$ 不相等，注意这里的“初始局面”指的是你放入 $\boldsymbol{k}$ 枚石子之前的局面。**
## 输入格式

**本题有多组测试数据。** 第一行一个正整数 $T$ 表示测试数据组数，接下来依次给出每组测试数据。

对于每组测试数据，第一行两个整数 $n, k$，分别表示石子堆数和加入的石子个数，接下来 $n$ 行，每行两个非负整数 $l_i, r_i$ 表示每堆石子初始石子数的范围。
## 输出格式

对于每组数据输出一行一个整数，表示可能获胜的局面数对$({10}^9 + 7)$ 取模的结果。
## 样例

### 样例输入 #1
```
1
4 1
0 1
0 1
0 1
0 1

```
### 样例输出 #1
```
14

```
## 提示

**【样例解释 \#1】**

共有 $2^4 = 16$ 种可能的初始局面，可以证明除了 $(0 \ 0 \ 0 \ 0)$ 和 $(1 \ 0 \ 0 \ 1)$ 这两种初始局面无法获胜以外，其余初始局面均存在获胜方案。例如，初始局面为 $(1 \ 0 \ 1 \ 0)$ 时，你可以将手中的 $1$ 枚石子放入第 $2$ 堆石子，使局面变为 $(1 \ 1 \ 1 \ 0)$，再对区间 $[1, 3]$ 使用一次操作二即可。

----

**【样例 \#2】**

见附件中的 `stone/stone2.in` 与 `stone/stone2.ans`。

----

**【样例 \#3】**

见附件中的 `stone/stone3.in` 与 `stone/stone3.ans`。

----

**【样例 \#4】**

见附件中的 `stone/stone4.in` 与 `stone/stone4.ans`。

----

**【数据范围】**

对于 $100 \%$ 的数据，保证 $T \le 10$，$3 \le n \le 1000$，$0 \le l_i \le r_i \le {10}^9$，$0 \le k \le 100$。

| 测试点编号 | $n \le$ | $k \le$ | 特殊条件 |
|:-:|:-:|:-:|:-:|
| $1 \sim 3$ | $5$ | $2$ | $r_i \le 5$ |
| $4 \sim 5$ | $1000$ | $0$ | $l_i = r_i$ |
| $6 \sim 8$ | $1000$ | $100$ | $l_i = r_i$ |
| $9 \sim 11$ | $1000$ | $0$ | 无 |
| $12 \sim 13$ | $1000$ | $2$ | 无 |
| $14 \sim 15$ | $1000$ | $100$ | $r_i \le 10$ |
| $16 \sim 20$ | $1000$ | $100$ | 无 |


---

---
title: "[NOI2022] 树上邻域数点"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8498
tag: ['2022', 'NOI', '交互题', 'Special Judge', 'O2优化']
---
# [NOI2022] 树上邻域数点
## 题目背景

**这是一道交互题。**

**在提交本题前请务必仔细阅读以下内容。**

本题只支持 C++ 语言提交（建议使用 C++14，请不要使用 C++14 (GCC9)）。

由于洛谷特殊的交互机制，在提交本题时，请去掉代码中的 ```#include "count.h"``` 语句，并将下发文件 **`count_.h`** （注意并不是 `count.zip` 里的 `count.h`）中的内容粘贴到代码最开头，然后提交。

如果您无法打开 `count_.h`，那么可以复制下面的内容。

```cpp
#ifndef CIRCLE_H
#define CIRCLE_H
#include<vector>
struct info{
  unsigned val;
  unsigned poi[2];
};
const info emptyinfo=info{0,(unsigned)-1,(unsigned)-1};
info MR(info a,info b);
info MC(info a,info b);
void init(int T,int n,int q,std::vector<int>dad,std::vector<info>ve,int M);
bool isempty(info a);
info ask(int x,int d);

#endif
```

如果您在提交本题时出现了任何意外的情况，请咨询管理员。
## 题目描述

给出五元组 $(T, I, S_V, S_E, \iota)$，其中：

- $T$ 是一棵 $n$ 个点的有根树 $T = (V, E)$，其中 $V$ 为 $T$ 的点集，$E$ 为 $T$ 的边集。树的节点被编号为 $1, 2, \ldots, n$，其中根节点编号为 $1$。
- $I$ 是一个集合，集合中的元素称作**信息**。其中有两个不同的特殊元素：单位元 $\epsilon$ 和不合法信息 $\bot$。

对于一般的信息，其都具有**点集合**和**边集合**两个属性。特别的，对于单位元，其只有边集合的属性，而对于不合法信息，其没有以上两种属性。

- 对于信息 $o \in I \setminus \{ \epsilon, \bot \}$，$o$ 的**点集合**是 $V$ 的一个二元子集，记作 $S_V(o)$，满足 $S_V(o) \subseteq V$ 且 $\lvert S_V(o) \rvert = 2$。其中，两个集合 $A, B$ 的差 $A \setminus B$ 被定义为 $A \setminus B = \{ x \in A \hspace{3mu}\vert\hspace{3mu} x \notin B \}$。
- 对于信息 $o \in I \setminus \{ \bot \}$，$o$ 的**边集合**是 $E$ 的一个子集，记作 $S_E(o)$，满足 $S_E(o) \subseteq E$。规定单位元的边集合为空，也即 $S_E(\epsilon) = \varnothing$。
- 对于树上的任何一条边 $e \in E$，记 $e = (u, v)$，存在一个关于 $e$ 的信息 $\iota(e) \in I$，它以其端点为点集合、自身为边集合，即 $S_V(\iota(e)) = \{ u, v \}$、$S_E(\iota(e)) = \{ e \}$。

信息有两种合并的方式，分别记作 $R$ 和 $C$。对于 $\forall a, b \in I$，记 $r = R(a, b), c = C(a, b)$，满足 $r, c \in I$，则：

- 单位元和任何信息合并都得到对方。也即，如果 $a = \epsilon$，那么 $r = c = b$；如果 $b = \epsilon$，那么 $r = c = a$。
- 不合法信息和任何信息合并都得到不合法信息。也即，如果 $a = \bot$ 或者 $b = \bot$，那么 $r = c = \bot$。
- 对于剩下的情况，如果两个信息的**边集合**的交集非空，或者**点集合**的交集的大小不为 $1$，则合并得到不合法信息。也即，如果 $S_E(a) \cap S_E(b) \ne \varnothing$ 或 $\lvert S_V(a) \cap S_V(b) \rvert \ne 1$，则 $r = c = \bot$。
- 否则，有
  $$ S_E(r) = S_E(c) = S_E(a) \cup S_E(b) \text{,} $$
  $$ S_V(r) = S_V(a) \text{,} $$
  $$ S_V(c) = S_V(a) \oplus S_V(b) \text{,} $$
  其中 $\oplus$ 表示集合的对称差运算，也即 $A \oplus B = (A \cup B) \setminus (A \cap B)$。

定义 $T$ 中两个点的树上距离为树上以两个点为端点的唯一简单路径经过的边数。

给出评分参数 $M$ 和 $q$ 次询问，每次询问给出树上的一个点 $u$ 和一个非负整数 $d$。记点集 $X$ 为 $T$ 中所有与 $u$ 的树上距离不超过 $d$ 的点构成的集合，又记边集 $Y = \{ (a, b) \in E \hspace{3mu}\vert\hspace{3mu} a, b \in X \}$ 为 $X$ 内部的边集。可以证明，从 $\epsilon$ 和所有 $\iota(e)$（$e \in E$）出发，总是能通过有限次 $R, C$ 的调用得到信息 $o \ne \bot$ 满足 $S_E(o) = Y$。

每组询问中，你需要在 $R$ 和 $C$ 的调用次数总和不超过 $M$ 的限制下构造出一个满足这样的要求的信息 $o$。特别地，如果 $d = 0$，则直接返回单位元 $\epsilon$ 即可。

----

**【实现细节】**

请确保你的程序开头有 `#include "count.h"`。

头文件 `count.h` 中实现了如下内容：

1. 定义了信息对应的数据类型 `info`；
2. 定义了 $\epsilon$ 所对应的 `info` 类型常量 `emptyinfo`，你可以在程序中直接使用。
3. 定义并实现了以下两个信息合并函数，你可以在程序中直接调用：
   
   ```cpp
   info MR(info a,info b);
   info MC(info a,info b);
   ```
   
   - 两个函数分别返回 $R(a, b)$ 与 $C(a, b)$ 对应的信息。
   
   **你需要保证调用 $\boldsymbol{R(a, b)}$ 与 $\boldsymbol{C(a, b)}$ 时结果不为 $\boldsymbol{\bot}$，否则程序可能会出现异常行为。**
4. 定义并实现了判定一个信息是否为单位元的函数，你可以在程序中直接调用：
   ```cpp
   bool isempty(info a);
   ```
   - 这个函数返回真当且仅当 $a$ 为单位元。

可以查看参考交互库了解更多实现细节。

**你不需要，也不应该实现主函数。** 你需要实现如下几个函数：

```cpp
void init(int T, int n, int q, vector<int> fa, vector<info> e, int M);
```

- `T` 表示测试点编号，`n` 表示树的点数，`q` 表示询问数，`M` 表示该测试点的评分参数。
- `fa` 和 `e` 的长度均为 $n - 1$。对于 $0 \le i < n - 1$，$fa[i]$ 和 $i + 2$ 为第 $i$ 条边 $e_i$ 的两个端点，$e[i]$ 为题目描述中提到的 $\iota(e_i)$ 所对应的 `info` 类型元素。数据保证 $fa[i]$ 小于 $i + 2$。

```cpp
info ask(int u, int d);
```

给出一个询问，参数的意义见题目描述。你需要在函数结束时返回一个满足题设条件的信息。

最终测试时，在每个测试点，交互库会**恰好**调用一次 `init` 函数，随后调用 $q$ 次 `ask`函数。交互库会使用特殊的实现方式，单个 `info` 类型的变量会恒定消耗 $12$ 字节内存，**这与下发的参考交互库不同**。为保证程序运行时内存使用在题目限制内，你需要保证运行过程中没有过多的 `info` 类型变量同时存在。

保证在满足调用次数限制且不进行 `isempty` 函数调用的情况下，最终测试的交互库运行所需的时间不超过 0.6 秒，交互库本身所消耗的内存不超过 16 MiB。保证在只执行 ${10}^8$ 次 `isempty` 函数调用的情况下，最终测试的交互库运行的时间不超过 0.25 秒。

在下发文件中包含一个名为 `count.cpp` 的文件，作为示例程序，选手可以在此基础上继续实现本题。在下发文件中还额外包含一个名为 `count_backup.h` 的备份文件，我们保证其与 `count.h` 文件完全相同。

----

**【测试程序方式】**

本题目录下提供了两个交互库的参考实现 `grader.o`、`checker.o`，其为两个不同的交互库编译产生的可链接文件。最终测试时所用的交互库实现与该实现有不同，因此选手的解法**不应依赖交互库的具体实现**，同时也不应该依赖 `count.h` 中 `info` 类型的具体实现。

你需要修改下发的 `count.h` 来帮助进行链接。具体的，在将源代码 `count.cpp` 和程序 `grader.o` 进行链接的时候，你需要注释掉 `count.h` 代码的第 5 行，并保留第 4 行的代码。链接 `checker.o` 方法类似，需要注释掉 `count.h` 代码的第 4 行，并保留第 5 行的代码。选手可以对 `count.h` 的实现自行修改来实现不同程序的编译。

修改后，选手可以在本题目录下使用如下命令编译得到可执行程序：

```bash
g++ count.cpp -c -O2 -std=c++14 -lm && g++ count.o grader.o -o count
g++ count.cpp -c -O2 -std=c++14 -lm && g++ count.o checker.o -o count
```

其中第一行命令会编译当前 `count.cpp` 后与 `grader.o` 链接起来，生成可执行文件 `count`，第二行命令则会编译当前 `count.cpp` 后与 `checker.o` 链接起来，生成可执行文件 `count`。

按上述方法编译得到的可执行文件 `count`，其运行方式如下：

- 可执行文件将从标准输入读入以下格式的数据：
  - 第一行四个整数 $id, n, q, M$，分别表示测试点编号、树的点数、询问数和评分参数；
  - 第二行 $n - 1$ 个整数 $p_2, p_3, \ldots, p_n$，分别表示 $2$ 至 $n$ 的父亲节点编号，在本地调试时你需要保证 $\forall i \in [2, n]$，$p_i < i$；
  - 接下来 $q$ 行每行两个整数 $u, d$，描述一次询问。
- 读入之后，交互库会进行测试。如果你的程序不满足交互库限制，其会在输出中返回对应的错误信息。否则，对于链接的可执行文件，其输出如下：
  - 总共一行三个整数 $C_1, C_2, C_3$，其中：
    - $C_1$ 表示程序在 `init` 函数中调用交互库函数的总次数；
    - $C_2$ 表示程序在运行过程中调用交互库函数的总次数；
    - $C_3$ 表示程序在 $q$ 次 `ask` 函数中调用交互库函数的次数的最大值。
    - 对于上述三个统计量，我们只会计入 `MR`、`MC` 函数的调用次数，而不会计入 `isempty` 函数的调用次数。
- 在链接不同文件的时候，其能够进行的检查也不同，具体地：
  - `grader.o`：其在运行时不会检查 `ask` 函数返回的信息是否正确，但可以帮助选手判断交互操作是否符合要求。这份程序运行时间最接近评测时的交互库，因此选手可以利用该程序测试运行速度，但不保证程序正确性。
  - `checker.o`：其在运行时会检查 `ask` 函数返回的信息是否正确，也可以帮助选手判断交互操作是否符合要求。同时其会检查 `ask` 函数返回的信息是否正确。这份程序可以进行答案正确性的检查。

选手在调试时需要保证输入可执行文件 `count` 的数据满足上述输入格式，否则不保证输出结果正确。

## 输入格式

见【测试程序方式】。
## 输出格式

见【测试程序方式】。
## 提示

**【评分方式】**

最终评测**只会**收取 `count.cpp`，修改选手目录下其他文件不会对评测结果产生影响。**注意：**

- **未初始化的 `info` 类型的变量不保证是 `emptyinfo`。**
- **请不要尝试访问或修改 `info` 类型的成员变量，否则将被视为攻击交互库。**
- **请不要在 `init` 函数调用之前调用 `MR` 和 `MC` 函数，否则可能会发生未定义行为。**
- **你只能访问自己定义的变量和交互库返回的 `info` 类型变量，尝试访问其他空间将可能导致编译错误或运行时错误。**

**本题首先会受到和传统题相同的限制**，例如编译错误会导致整道题目得 0 分，运行时错误、超过时间限制、超过空间限制等会导致相应测试点得 0 分等。

在上述条件以外，在一个测试点中，若程序执行了非法的函数调用或询问操作中给出了错误回答，该测试点将会获得 0 分。否则，记 $C_1, C_3$ 分别表示你的程序在 `init` 函数中调用交互库函数的次数，和你的程序在所有 $q$ 次 `ask` 函数中调用交互库函数的次数的最大值。如果 $C_1 \le 3 \cdot {10}^7$ 且 $C_3$ 不超过该测试点的评分参数 $M$，你将获得该测试点的分数，否则你无法获得该测试点的分数。注意：计算 $C_1, C_3$ 时只会计入 `MR`、`MC` 函数的调用次数，而不会计入 `isempty` 函数的调用次数。

----

**【样例 \#1】**

见附件中的 `count/count1.in` 与 `count/count1.ans`。

----

**【样例 \#2】**

见附件中的 `count/count2.in` 与 `count/count2.ans`。

该组样例满足数据范围中的特殊性质 A。

----

**【样例 \#3】**

见附件中的 `count/count3.in` 与 `count/count3.ans`。

该组样例满足数据范围中的特殊性质 B。

----

**【样例 \#4】**

见附件中的 `count/count4.in` 与 `count/count4.ans`。

----

**【数据范围】**

对于所有测试点，$1 \le n \le 2 \times {10}^5$，$1 \le q \le {10}^6$；每组询问中，有 $1 \le u \le n$，$1 \le d \le n - 1$。

| 测试点   | $n=$              | $q=$            | 特殊性质 | $M=$  |
|:-----:|:-----------------:|:---------------:|:----:|:-----:|
| $1$   | $1000$            | $10^4$          |      | $500$ |
| $2$   | $2000$            | $10^4$          |      | $500$ |
| $3,4$ | $10^5$            | $10^6$          | A    | $5$   |
| $5,6$ | $6 \times 10^4$   | $6\times 10^4$  | B    | $50$  |
| $7$   | $6 \times 10^4$   | $6 \times 10^4$ | B    | $5$   |
| $8$   | $10^5$            | $10^5$          | B    | $5$   |
| $9$   | $7500$            | $5 \times 10^4$ | C    | $500$ |
| $10$  | $10^4$            | $5 \times 10^4$ |      | $500$ |
| $11$  | $1.5 \times 10^4$ | $5 \times 10^4$ |      | $500$ |
| $12$  | $2 \times 10^4$   | $5 \times 10^4$ |      | $50$  |
| $13$  | $2.5 \times 10^4$ | $5 \times 10^4$ |      | $5$   |
| $14$  | $3 \times 10^4$   | $10^5$          |      | $5$   |
| $15$  | $6 \times 10^4$   | $10^6$          | D    | $5$   |
| $16$  | $6 \times 10^4$   | $10^6$          |      | $5$   |
| $17$  | $8 \times 10^4$   | $10^6$          |      | $5$   |
| $18$  | $10^5$            | $10^6$          |      | $5$   |
| $19$  | $1.5 \times 10^5$ | $10^6$          |      | $5$   |
| $20$  | $2 \times 10^5$   | $10^6$          |      | $1$   |


特殊性质 A：保证 $\forall i \in [1, n - 1]$，编号为 $i + 1$ 的点的父节点为 $i$。  
特殊性质 B：保证所有询问均满足 $u = 1$。  
特殊性质 C：保证所有询问均满足 $d \le 100$。  
特殊性质 D：保证所有询问均满足 $d \ge 1000$。


---

---
title: "[NOI2022] 冒泡排序"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8500
tag: ['2022', 'NOI', 'O2优化']
---
# [NOI2022] 冒泡排序
## 题目背景

最近，小 Z 对冒泡排序产生了浓厚的兴趣。

下面是冒泡排序的伪代码：

```
输入: 一个长度为 n 的序列 a[1...n]
输出: a 从小到大排序后的结果
for i = 1 to n do:
    for j = 1 to n - 1 do
        if (a[j] > a[j + 1])
            交换 a[j] 与 a[j + 1] 的值
```

冒泡排序的交换次数被定义为在排序时**进行交换的次数**，也就是上面冒泡排序伪代码**第六行**的执行次数。他希望找到一个交换次数尽量少的序列。
## 题目描述

小 Z 所研究的序列均由非负整数构成。它的长度为 $n$，且必须满足 $m$ 个附加条件。其中第 $i$ 个条件为：下标在 $[L_i, R_i]$ 中的数，即 $a_{L_i}, a_{L_{i+1}},\dots,a_{R_i}$ 这些数，其最小值**恰好为 $\boldsymbol{V_i}$**。

他知道冒泡排序时常会超时。所以，他想要知道，在所有满足附加条件的序列中，进行冒泡排序的交换次数的最少值是多少。
## 输入格式

本题有多组数据。

输入的第一行包含一个正整数 $T$。

对于每组数据，第一行包含两个正整数 $n,m$。数据保证 $1 \leq n,m \leq 10^6$。

接下来 $m$ 行，每行三个非负整数 $L_i, R_i, V_i$，表示一组附加条件。数据保证 $1 \leq L_i \leq R_i \leq n$、$0 \leq V_i \leq 10^9$。

## 输出格式

输出共 $T$ 行，每行一个整数。

对于每组数据，如果存在满足这 $m$ 个附加条件的序列，则输出在所有满足附加条件的序列中，冒泡排序交换次数的最小值。如果不存在满足所有条件的序列，则输出 $-1$。
## 样例

### 样例输入 #1
```
1
3 2
1 1 2022
2 3 39

```
### 样例输出 #1
```
1

```
## 提示

**【样例解释 \#1】**

这组数据的约束条件为 $a_1 = 2022, \min\{a_2, a_3\} = 39$。

若 $a_2 = 39$，且 $39 \leq a_3 < 2022$，则冒泡排序只有第一轮有交换操作，这一轮交换了 $a_1, a_2$ 和 $a_2, a_3$，总交换次数为 $2$。

若 $a_2 = 39$，且 $a_3 \geq 2022$，则冒泡排序只有第一轮有交换操作，这一轮仅仅交换 $a_1, a_2$，总交换次数为 $1$。

若 $a_3 = 39$，且 $39 < a_2 < 2022$，则冒泡排序算法第一轮交换 $a_1, a_2$ 和 $a_2, a_3$，第二轮交换 $a_1, a_2$。总交换次数为 $3$。

若 $a_3 = 39$，且 $a_2 \geq 2022$，则冒泡排序算法第一轮交换 $a_2, a_3$，第二轮交换 $a_1, a_2$。总交换次数为 $2$。

因此，交换次数的最小值为 $1$。

----

**【样例 \#2】**

见附件中的 `bubble/bubble2.in` 与 `bubble/bubble2.ans`。

----

**【样例 \#3】**

见附件中的 `bubble/bubble3.in` 与 `bubble/bubble3.ans`。

这个样例满足测试点 $8 \sim 10$ 的条件。

----

**【样例 \#4】**

见附件中的 `bubble/bubble4.in` 与 `bubble/bubble4.ans`。

这个样例满足测试点 $13 \sim 14$ 的条件。

----

**【样例 \#5】**

见附件中的 `bubble/bubble5.in` 与 `bubble/bubble5.ans`。

这个样例满足测试点 $15 \sim 16$ 的条件。

----

**【样例 \#6】**

见附件中的 `bubble/bubble6.in` 与 `bubble/bubble6.ans`。

这个样例满足测试点 $23 \sim 25$ 的条件。

----

**【数据范围】**

本题共 $25$ 个测试点。全部测试点满足：$1 \leq T \leq 1000$，$1 \leq \sum n, \sum m \leq 10^6$，$1 \leq L_i \leq R_i \leq n$，$0 \leq V_i \leq 10^9$。

其中 $\sum n, \sum m$ 分别表示所有测试点的 $n$ 的总和和 $m$ 的总和。$\sum n^2, \sum m^2, \sum n^3, \sum m^3$ 的含义类似。

| 测试点          | 数据范围                                                   | 特殊性质         |
|:------------:|:------------------------------------------------------:|:------------:|
| $1 \sim 4$   | $n,m \leq 7$，且最多 $2$ 组数据不满足 $n, m \leq 5$              |              |
| $5 \sim 7$   | $n,m \leq 17$，且最多 $3$ 组数据不满足 $n, m \leq 9$             | A |
| $8 \sim 10$  | $n,m \leq 100$，$\sum n^3,\sum m^3 \leq 4 \times 10^7$  | A |
| $11 \sim 12$ | $n,m \leq 2000$，$\sum n^2,\sum m^2 \leq 4 \times 10^7$ | A |
| $13 \sim 14$ | $n,m \leq 2000$，$\sum n^2,\sum m^2 \leq 4 \times 10^7$ | B |
| $15 \sim 16$ | $n,m \leq 2000$，$\sum n^2,\sum m^2 \leq 4 \times 10^7$ | C |
| $17 \sim 18$ | $n,m \leq 2000$，$\sum n^2,\sum m^2 \leq 4 \times 10^7$ |              |
| $19$         | $\sum n,\sum m \leq 10^6$                              | A |
| $20$         | $\sum n,\sum m \leq 10^6$                              | B |
| $21 \sim 22$ | $\sum n,\sum m \leq 10^6$                              | C |
| $23 \sim 25$ | $\sum n,\sum m \leq 10^6$                              |              |

特殊性质 A：对于 $1 \leq i \leq m$，$0 \leq V_i \leq 1$。  
特殊性质 B：对于 $1 \leq i \leq m$，$L_i = R_i$。  
特殊性质 C：输入给出的 $m$ 个区间 $[L_i, R_i]$ 两两不相交。

----

**【提示】**

本题的部分测试点输入量较大。我们建议你使用较为快速的读入方式。


---

---
title: "[NOI2022] 二次整数规划问题"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8501
tag: ['2022', 'NOI', 'O2优化']
---
# [NOI2022] 二次整数规划问题
## 题目描述

本题中，你需要解决一个著名的 NP 问题——二次整数规划问题。

二次整数规划问题要有变量：你需要给出一个长度为 $n$ 的**整数**序列 $(x_1, x_2, \ldots, x_n)$，满足下文中的所有条件。

二次整数规划问题要有约束：你给出的整数序列需要满足以下两类约束：

1. 一类约束是单个变量取值的约束：给出正整数 $k$（$3 \leq k \leq 5$）和 $n$ 个区间 $[l_i, r_i]$（$1 \leq i \leq n$），其中 $1 \leq l_i \leq r_i \leq k$，你给出的序列需要满足 $\forall 1 \leq i \leq n$，$l_i \leq x_i \leq r_i$；
2. 另一类约束是变量之间取值的约束：给出 $m$ 个三元组 $(p_i, q_i, b_i)$，你给出的序列需要满足 $\forall 1 \leq j \leq m$，$\lvert x_{p_j} - x_{q_j} \rvert \leq b_j$。

二次整数规划问题要有目标函数：在给出 $k-2$ 个目标参数 $v_2,v_3,\dots,v_{k-1}$（**注意下标范围为 $\boldsymbol{2}$ 至 $\boldsymbol{k-1}$**）的前提下，对于一个值域为 $[1,k]$ 的整数数列 $\{p_1,p_2,\dots,p_n\}$，设 $c_i$ 为该序列中取值为 $i$ 的元素个数，$G$ 为满足 $1 \leq i,j \leq n$ 且 $|p_i-p_j|\leq 1$ 的整数二元组 $(i, j)$ 个数，**注意当 $\boldsymbol{i \neq j}$ 时，$\boldsymbol{(i, j)}$ 与 $\boldsymbol{(j, i)}$ 是不同的二元组**。定义该序列的**权值**为

$$ W(p_1, p_2, \ldots, p_n) = 10^6 G+\sum_{i=2}^{k-1} c_i v_i \text{。} $$

你的序列需要在满足以上两类约束的情况下，最大化其权值。在给出的约束下，保证存在满足约束的序列。

二次整数规划问题不一定要有多组询问，但是我们会给出 $q$ 次询问，每次询问给出不同的权值参数 $v_2, v_3, \ldots, v_{k-1}$，对于每组询问你需要找到满足约束的最大化权值的序列。为了减少输出量，你只需要输出这个序列的权值。
## 输入格式

**本题有多组测试数据。** 第一行一个非负整数和一个正整数 $C, T$，分别表示测试点编号和测试数据数量。$C = 0$ 表示该组数据为样例。

对于每组测试数据，第一行四个整数 $k, n, m, q$，描述序列值域、序列长度、变量之间约束的个数和询问次数。

接下来 $n$ 行每行两个整数 $l_i, r_i$，描述序列中每个元素对应的取值区间。

接下来 $m$ 行每行三个整数 $p_j, q_j, b_j$，描述一个变量之间的约束。

接下来 $q$ 行每行 $k - 2$ 个非负整数 $v_2, v_3, \ldots, v_{k - 1}$ 描述一组询问的权值参数。
## 输出格式

对于每组数据的每组询问输出一行一个整数，表示序列权值的最大值。
## 提示

**【样例 \#1】**

见附件中的 `qip/qip1.in` 与 `qip/qip1.ans`。

该样例满足数据范围中测试点 $1$ 的性质。

----

**【样例解释 \#1】**

第一个测试数据中两组询问对应的最优序列均为 $(1, 2, 2, 1, 3)$，有 $c_2 = 2, G = 21$。

----

**【样例 \#2】**

见附件中的 `qip/qip2.in` 与 `qip/qip2.ans`。

该样例满足数据范围中测试点 $3$ 的性质。

----

**【样例解释 \#2】**

第一个测试数据中两组询问对应的最优序列分别为 $(4,4,3,3)$ 和 $(4,3,2,2)$。

----

**【样例 \#3】**

见附件中的 `qip/qip3.in` 与 `qip/qip3.ans`。

该样例满足数据范围中测试点 $5$ 的性质。

----

**【样例解释 \#3】**

第一个测试数据中三组询问对应的一个最优序列分别为 $(3, 3, 3, 3, 3)$、$(2, 2, 3, 3, 2)$ 和 $(3, 2, 4, 4, 2)$。

----

**【样例 \#4】**

见附件中的 `qip/qip4.in` 与 `qip/qip4.ans`。

该样例满足数据范围中测试点 $2$ 的性质。

----

**【样例 \#5】**

见附件中的 `qip/qip5.in` 与 `qip/qip5.ans`。

该样例满足数据范围中测试点 $4$ 的性质。

----

**【样例 \#6】**

见附件中的 `qip/qip6.in` 与 `qip/qip6.ans`。

该样例满足数据范围中测试点 $8$ 的性质。

----

**【样例 \#7】**

见附件中的 `qip/qip7.in` 与 `qip/qip7.ans`。

该样例满足数据范围中测试点 $14$ 的性质。

----

**【样例 \#8】**

见附件中的 `qip/qip8.in` 与 `qip/qip8.ans`。

该样例满足数据范围中测试点 $17$ 的性质。

----

**【数据范围】**

设 $\sum q$ 为单个测试点中所有测试数据的 $q$ 的和。对于所有测试点，

- $1 \leq T \leq 600$，
- 第 $i$（$1 \le i \le T$）个测试数据中，$1 \leq n \leq \max(\frac{T}{i},2 \log_2 T)$，
- $3 \leq k \leq 5$，$0 \leq m \leq 3n$，$1 \leq q,\sum q \leq 3 \times 10^5$，
- $1 \leq l_i \leq r_i \leq k$，
- $1 \leq p_j,q_j \leq n$，$0 \leq b_j<k$，
- $0 \leq v_2,\dots,v_{k-1} \leq 10^{12}$。

| 测试点编号 | $T \leq$ | $k=$ | $\sum q \leq$   | 特殊性质         | 测试点分数 |
|:-----:|:--------:|:----:|:---------------:|:------------:|:-----:|
| $1$   | $10$     | $3$  | $200$           | 无            | $4$   |
| $2$   | $600$    | $3$  | $3 \times 10^5$ | 无            | $6$   |
| $3$   | $10$     | $4$  | $200$           | 无            | $4$   |
| $4$   | $600$    | $4$  | $3 \times 10^5$ | 无            | $6$   |
| $5$   | $10$     | $5$  | $300$           | 无            | $5$   |
| $6$   | $15$     | $5$  | $500$           | 无            | $4$   |
| $7$   | $25$     | $5$  | $750$           | 无            | $4$   |
| $8$   | $50$     | $5$  | $1000$          | 无            | $6$   |
| $9$   | $80$     | $5$  | $1500$          | 无            | $6$   |
| $10$  | $120$    | $5$  | $2000$          | 无            | $5$   |
| $11$  | $200$    | $5$  | $8000$          | A | $3$   |
| $12$  | $400$    | $5$  | $3 \times 10^4$ | A | $4$   |
| $13$  | $600$    | $5$  | $2 \times 10^5$ | A | $5$   |
| $14$  | $200$    | $5$  | $8000$          | B | $3$   |
| $15$  | $400$    | $5$  | $3 \times 10^4$ | B | $4$   |
| $16$  | $600$    | $5$  | $2 \times 10^5$ | B | $4$   |
| $17$  | $120$    | $5$  | $10^5$          | C | $4$   |
| $18$  | $150$    | $5$  | $2 \times 10^5$ | C | $5$   |
| $19$  | $180$    | $5$  | $3 \times 10^5$ | C | $5$   |
| $20$  | $300$    | $5$  | $5 \times 10^4$ | 无            | $5$   |
| $21$  | $450$    | $5$  | $10^5$          | 无            | $4$   |
| $22$  | $600$    | $5$  | $3 \times 10^5$ | 无            | $4$   |

特殊性质 A：$m=0$。

特殊性质 B：$m \leq 10$，单个测试点中所有测试数据的 $m$ 的和不超过 $200$。

特殊性质 C：数据随机生成。具体地，生成测试点中每组测试数据时，给出参数 $k,n,m,q$ 以及 $k$ 个非负常数 $p_0,p_1,p_2,\dots,p_{k-1}$，保证 $p_{k-1} \neq 0$，则按照如下规则生成该组数据：

- 对于 $1 \leq i \leq n$，独立均匀生成 $x,y \in [1,k]$，则 $l_i=\min(x,y),r_i=\max(x,y)$；
- 不断按照如下方式生成三元组直至有 $m$ 个三元组：
  1. 独立均匀随机生成 $u,v \in [1,n]$；
  2. 以 $p$ 为权值随机生成 $w$（对于 $0 \leq i \leq k-1$，$w=i$ 的概率为 $\frac{p_i}{p_0+p_1+\dots+p_{k-1}}$）；
  3. 若在原有三元组集合中加入 $(u,v,w)$ 后不存在序列 $(x_1,x_2,\dots,x_n)$ 满足所有限制，则舍弃当前三元组，否则加入当前三元组。
- 每组询问的 $v_2, \ldots, v_{k-1}$ 在 $[0,10^{12}]$ 内独立均匀随机生成。


---

---
title: "[NOI2023] 桂花树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9479
tag: ['2023', 'NOI', 'O2优化']
---
# [NOI2023] 桂花树
## 题目描述

小 B 八年前看到的桂花树是一棵 $n$ 个节点的树 $T$，**保证 $T$ 的非根结点的父亲的编号小于自己**。给定整数 $k$，称一棵 $(n+m)$ 个节点的有根树 $T^{\prime}$ 是繁荣的，当且仅当以下所有条件满足：

1. 对于任意满足 $1 \le i,j \le n$ 的 $(i,j)$，在树 $T$ 和树 $T^{\prime}$ 上，节点 $i$ 和 $j$ 的最近公共祖先编号相同。
2. 对于任意满足 $1 \le i,j \le n + m$ 的 $(i,j)$，在树 $T^{\prime}$ 上，节点 $i$ 和 $j$ 的最近公共祖先编号不超过 $\max(i,j)+k$。

**注意题目中所有树的节点均从 $1$ 开始编号，且根结点编号为 $1$。$T^{\prime}$ 不需要满足非根结点的父亲编号小于自己。**

小 B 想知道有多少棵 $(n+m)$ 个节点的树是繁荣的，认为两棵树不同当且仅当存在某一个节点在两棵树上的父亲不同。你只输出方案数在模 $(10^9+7)$ 意义下的值。
## 输入格式

**本题有多组测试数据。**

输入的第一行包含两个整数 $c,t$，分别表示测试点编号和测试数据组数。$c=0$ 表示该测试点为样例。

接下来依次输入每组测试数据，对于每组测试数据：

输入的第一行包含三个整数 $n,m,k$。

输入的第二行包含 $n-1$ 个整数 $f_2,f_3,\dots,f_n$，其中 $f_i$ 表示 $T$ 中节点 $i$ 的父亲节点编号。
## 输出格式

对于每组测试数据输出一行一个整数，表示繁荣的树的数量在模 $(10^9+7)$ 意义下的答案。
## 样例

### 样例输入 #1
```
0 3
1 2 1

2 2 1
1
2 2 0
1
```
### 样例输出 #1
```
3
16
15
```
### 样例输入 #2
```
见附件中的 tree/tree2.in。
```
### 样例输出 #2
```
见附件中的 tree/tree2.ans。
```
### 样例输入 #3
```
见附件中的 tree/tree3.in。
```
### 样例输出 #3
```
见附件中的 tree/tree3.ans。
```
### 样例输入 #4
```
见附件中的 tree/tree4.in。
```
### 样例输出 #4
```
见附件中的 tree/tree4.ans。
```
## 提示

**【样例解释 #1】**

对于样例中的第一组测试数据，有三棵合法的树，其每个节点的的父亲构成的序列 $\{f_2,f_3\}$ 分别为 $\{1,1\}$、$\{3,1\}$、$\{1,2\}$。注意这组测试数据的第二行为空行。

对于样例中的第二组、第三组测试数据，共有 $16$ 棵树满足第一个条件，其中只有父亲序列为 $\{4,4,1\}$ 的树在第三组测试数据中不满足第二个条件。

**【样例解释 #2】**

该组样例满足 $n \le 100$，五组测试数据中 $m$ 分别不超过 $0, 1, 1, 2, 2$。

**【样例解释 #3】**

该组样例满足 $k = 0$，五组测试数据中前两组测试数据满足 $n = 1$，第一、三、四组测试数据满足 $n, m \le 100$。

**【样例解释 #4】**

该组样例前两组测试数据满足 $n = 1$，第一、三、四组测试数据满足 $n, m \le 100$。

**【数据范围】**

对于所有测试数据保证：$1 \le t \le 15$，$1 \le n \le 3 \times 10^4$，$0 \le m \le 3000$，$0 \le k \le 10$，$1 \le f_i \le i - 1$。

| 测试点编号 | $n \le$ | $m \le $| $k \le $|
| :--: | :--: | :--: | :--: |
| $1,2$ | $4$|$4$|$10$|
|$3$|$3\times 10^4$|$0$|$10$|
|$4$|$10^2$|$1$|$10$|
|$5$|$3 \times 10^4$|$1$|$10$|
|$6$|$10^2$|$2$|$10$|
|$7$|$3\times 10^4$|$2$|$10$|
|$8,9$|$1$|$10^2$|$0$|
|$10$|$1$|$3,000$|$0$|
|$11$|$1$|$10^2$|$10$|
|$12$|$1$|$3,000$|$10$|
|$13,14$|$10^2$|$10^2$|$0$|
|$15,16$|$3\times 10^4$|$3,000$|$0$|
|$17,18$|$10^2$|$10^2$|$10$|
|$19,20$|$3\times 10^4$|$3,000$|$10$|


---

---
title: "[NOI2023] 深搜"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9480
tag: ['线段树', '2023', 'NOI', '离散化', 'O2优化', '动态规划优化', '树形 DP', '容斥原理']
---
# [NOI2023] 深搜
## 题目描述

深度优先搜索是一种常见的搜索算法。通过此算法，我们可以从一个无重边、无自环的无向连通图 $G = (V, E)$，和某个出发点 $s$，得到一棵树 $T$。

算法的流程描述如下:

1. 将栈 $S$ 设置为空，并令 $T = (V, \emptyset)$，即 $T$ 的边集初始为空。
2. 首先将出发点 $s$ 压入 $S$ 中。
3. 访问栈顶节点 $u$，并将 $u$ 标记为“已访问的”。
4. 如果存在与 $u$ 相邻且未被访问的节点，则**任意地**从这些节点中挑选一个记为 $v$。我们将边 $(u, v)$ 加入 $T$ 的边集中，并将 $v$ 压入栈 $S$ 中，然后**回到步骤 3**。若不存在这样的节点，则从栈中弹出节点 $u$。

可以证明，当图 $G$ 为连通图时，该算法会得到图的某一棵生成树 $T$。但**算法得到的树 $T$ 可能不是唯一的，它取决于搜索的顺序，也就是算法的第 4 步所选取的顶点**。指定出发点 $s$ 后，如果能够选取一种特定的搜索顺序，使得算法得到的树恰好是 $T$，则我们称 **$T$ 是 $G$ 的一棵 $s$-dfs 树**。

现在给定一棵 $n$ 个顶点的树 $T$，顶点编号为 $1 \sim n$，并额外给出 $m$ 条边。我们保证这 $m$ 条边两两不同，连接不同的顶点，且与 $T$ 中的 $n - 1$ 条树边两两不同。我们称额外给出的 $m$ 条边为**非树边**。在这 $n$ 个顶点中，我们指定了恰好 $k$ 个顶点作为**关键点**。

现在你想知道，有多少种选取这 $m$ 条非树边的方法（可以全部不选），使得：将 $T$ 的边与被选中的非树边构成图 $G$ 之后，存在某个**关键点** $s$，使得 $T$ 是 $G$ 的一棵 $s$-dfs 树。

由于答案可能十分巨大，你只需要输出方案数在模 $(10 ^ 9 + 7)$ 意义下的值。
## 输入格式

输入的第一行包含一个整数 $c$，表示测试点编号。$c = 0$ 表示该测试点为样例。

输入的第二行包含三个正整数 $n, m, k$，分别表示顶点个数，非树边的数量，关键点的数量。

接下来 $n - 1$ 行，每行包含两个正整数 $u, v$ 表示树 $T$ 的一条边。保证这 $n - 1$ 条边构成了一棵树。

接下来 $m$ 行，每行包含两个正整数 $a, b$ 表示一条非树边。保证 $(a, b)$ 不与树上的边重合，且没有重边。

输入的最后一行包含 $k$ 个正整数 $s_1, s_2, \dots, s_k$，表示 $k$ 个关键点的编号。保证 $s_1, s_2, \dots, s_k$ 互不相同。
## 输出格式

输出一行包含一个非负整数，表示方案数在模 $(10 ^ 9 + 7)$ 意义下的值。
## 样例

### 样例输入 #1
```
0
4 2 2
1 2
2 3
3 4
1 3
2 4
2 3

```
### 样例输出 #1
```
3

```
### 样例输入 #2
```
见附件中的 dfs/dfs2.in。
```
### 样例输出 #2
```
见附件中的 dfs/dfs2.ans。
```
### 样例输入 #3
```
见附件中的 dfs/dfs3.in。
```
### 样例输出 #3
```
见附件中的 dfs/dfs3.ans。
```
### 样例输入 #4
```
见附件中的 dfs/dfs4.in。
```
### 样例输出 #4
```
见附件中的 dfs/dfs4.ans。
```
### 样例输入 #5
```
见附件中的 dfs/dfs5.in。
```
### 样例输出 #5
```
见附件中的 dfs/dfs5.ans。
```
### 样例输入 #6
```
见附件中的 dfs/dfs6.in。
```
### 样例输出 #6
```
见附件中的 dfs/dfs6.ans。
```
## 提示

**【样例解释 #1】**

在这个样例中，有三种选取非树边的方法：只选取边 $(1, 3)$，只选取边 $(2, 4)$，或不选取任何条非树边。

如果只选取边 $(1, 3)$，或者不选取任何一条非树边，则我们发现 $T$ 都是图 $G$ 的 $3$-dfs 树。指定的搜索顺序如下：
1. 将 $3$ 放入栈 $S$ 中。此时 $S = [3]$。
2. 将 $3$ 标记为“已访问的”。
3. 由于 $3$ 与 $2$ 相连，且 $2$ 是“未访问的”，将 $2$ 放入栈 $S$ 中，并将 $(3, 2)$ 加入树 $T$ 中，此时 $S = [3, 2]$。
4. 将 $2$ 标记为“已访问的”。
5. 由于 $2$ 与 $1$ 相连，且 $1$ 是“未访问的”，将 $1$ 放入栈 $S$ 中，并将 $(2, 1)$ 加入树 $T$ 中，此时 $S = [3, 2, 1]$。
6. 由于与 $1$ 相邻的点都是“已访问的”，将 $1$ 弹出栈，此时 $S = [3, 2]$。
7. 由于与 $2$ 相邻的点都是“已访问的”，将 $2$ 弹出栈，此时 $S = [3]$。
8. 由于 $3$ 与 $4$ 相连，且 $4$ 是“未访问的”，将 $4$ 放入栈 $S$ 中，并将 $(3, 4)$ 加入树 $T$ 中，此时 $S = [3, 4]$。
9. 由于与 $4$ 相连的点都是“已访问的”，将 $4$ 弹出栈，此时 $S = [3]$。
10. 由于与 $3$ 相连的点都是“己访问的”，将 $3$ 弹出栈，此时 $S$重新变为空。

如果只选取边 $(2, 4)$，则我们可以说明 $T$ 是图 $G$ 的 $2$-dfs 树。指定的搜索顺序如下：

1. 将 $2$ 放入栈 $S$ 中。此时 $S = [2]$。
2. 将 $2$ 标记为“已访问的”。
3. 由于 $2$ 与 $3$ 相连，且 $3$ 是“未访问的”，将 $3$ 放入栈 $S$ 中，并将 $(2, 3)$ 加入树 $T$ 中，此时 $S = [2, 3]$。
4. 将 $3$ 标记为“已访问的”。
5. 由于 $3$ 与 $4$ 相连，且 $4$ 是“未访问的”，将 $4$ 放入栈 $S$ 中，并将 $(3, 4)$ 加入树 $T$ 中，此时 $S = [2, 3, 4]$。
6. 由于与 $4$ 相邻的点都是“己访问的”，将 $4$ 弹出栈，此时 $S = [2, 3]$。
7. 由于与 $3$ 相邻的点都是“已访问的”，将 $3$ 弹出栈，此时 $S= [2]$。
8. 由于 $2$ 与 $1$ 相连，且 $1$ 是“未访问的”，将 $1$ 放入栈 $S$ 中，并将 $(2, 1)$ 加入树 $T$ 中，此时 $S = [2, 1]$。
9. 由于与 $1$ 相连的点都是“已访问的”，将 $1$ 弹出栈此时 $S = [2]$。
10. 由于与 $2$ 相连的点都是“已访问的”，将 $2$ 弹出栈，此时 $S$ 重新变为空。

**【样例解释 #2】**

这个样例满足测试点 $4 \sim 6$ 的约束条件。

**【样例解释 #3】**

这个样例满足测试点 $10 \sim 11$ 的约束条件。

**【样例解释 #4】**

这个样例满足测试点 $12 \sim 13$ 的约束条件。

**【样例解释 #5】**

这个样例满足测试点 $14 \sim 16$ 的约束条件。

**【样例解释 #6】**

这个样例满足测试点 $23 \sim 24$ 的约束条件。

**【数据范围】**

对于所有测试数据保证：$1 \le k \le n \le 5 \times 10 ^ 5$，$1 \le m \le 5 \times 10 ^ 5$。

|测试点编号|$n \le$|$m \le$|$k \le$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$1 \sim 3$|$6$|$6$|$n$|无|
|$4 \sim 6$|$15$|$15$|$6$|无|
|$7 \sim 9$|$300$|$300$|$6$|无|
|$10 \sim 11$|$300$|$300$|$n$|A|
|$12 \sim 13$|$300$|$300$|$n$|B|
|$14 \sim 16$|$300$|$300$|$n$|无|
|$17 \sim 18$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|A|
|$19 \sim 21$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|B|
|$22$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|无|
|$23 \sim 25$|$5 \times 10 ^ 5$|$5 \times 10 ^ 5$|$n$|无|

特殊性质 A：保证在 $T$ 中，$i$ 号点与 $i + 1$ 号点相连（$1 \le i < n$）。

特殊性质 B：保证若将 $T$ 的边与所有 $m$ 条非树边构成一个图 $G$，则 $T$ 是 $G$ 的棵 $1$-dfs 树。

**请注意，$1$ 号点不一定是 $k$ 个关键点之一。**


---

---
title: "[NOI2023] 合并书本"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9483
tag: ['搜索', '2023', 'NOI', 'O2优化']
---
# [NOI2023] 合并书本
## 题目描述

小 C 有 $n$ 本书，每本书都有一个重量，他决定把它们合并成一摞。

每一次合并小 C 可以把一摞书放到另一摞书上面，使得它们合并到一摞。如果小 C 把第 $i$ 摞书放到第 $j$ 摞书上面，小 C 需要消耗的体力为**第 $i$ 摞书的重量**加上**两摞书的磨损值之和**。

初始时每本书自成一摞且磨损值均为 $0$。每当小 C 将两摞书合并后，形成的新的一摞书的磨损值为合并前的两摞书的磨损值的**较大值的两倍再加一**，重量为合并前的两摞书的**重量之和**。

你的任务是设计出合并的次序方案，使小 C 耗费的体力最少，并输出这个最小的体力耗费值。
## 输入格式

**本题有多组测试数据。**

输入的第一行包含一个正整数 $t$，表示数据组数。

接下来依次输入每组测试数据，对于每组测试数据：

输入的第一行包含一个正整数 $n$，表示有 $n$ 本书。

输入的第二行包含 $n$ 个正整数，第 $i$ 个数 $w_i$ 表示第 $i$ 本书的重量。
## 输出格式

对于每组测试数据输出一行一个整数，表示将 $n$ 本书合并成一摞需要消耗的最少体力。
## 样例

### 样例输入 #1
```
1
4
1 1 1 1

```
### 样例输出 #1
```
6

```
### 样例输入 #2
```
见附件中的 book/book2.in。
```
### 样例输出 #2
```
见附件中的 book/book2.ans。
```
### 样例输入 #3
```
见附件中的 book/book3.in。
```
### 样例输出 #3
```
见附件中的 book/book3.ans。
```
### 样例输入 #4
```
见附件中的 book/book4.in。
```
### 样例输出 #4
```
见附件中的 book/book4.ans。
```
## 提示

**【样例解释 #1】**

如果小 C 将 $4$ 本书两两合并再将得到的两摞合并成一摞，那么前两次需要消耗的体力值各为 $1$。第三次将一摞重量为 $2$ 的书放到另一摞上面，两摞书磨损值各为 $1$，需要消耗的体力为 $2 + 1 + 1 = 4$。

因此如果选择这个方案，小 C 耗费的体力只有 $1 + 1 + 4 = 6$。

可以证明，在上述例子中，$6$ 为最小的体力耗费值。

**【数据范围】**

对于所有测试数据保证：$1 \le t \le 10$，$1 \le n \le 100$，$1 \le w_i \le 10 ^ 9$。

|测试点编号|$n \le$|是否有特殊性质|
|:-:|:-:|:-:|
|$1 \sim 2$|$7$|否|
|$3$|$11$|否|
|$4$|$13$|否|
|$5 \sim 6$|$22$|否|
|$7 \sim 8$|$28$|否|
|$9 \sim 13$|$50$|否|
|$14$|$60$|否|
|$15$|$70$|否|
|$16$|$80$|否|
|$17 \sim 18$|$100$|是|
|$19 \sim 20$|$100$|否|

特殊性质：保证 $w_i = 1$。


---


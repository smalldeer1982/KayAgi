---
title: "[THUPC 2024 决赛] 古明地枣的袜子"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10540
tag: ['2024', 'THUPC']
---
# [THUPC 2024 决赛] 古明地枣的袜子
## 题目描述

你需要维护一个序列 $a_1,\dots,a_n$ 。

给定一个操作序列 $(x_1,y_1),\dots,(x_n,y_n)$ ，操作 $(x,y)$ 表示将 $a_1,\dots,a_x$ 的值加上 $y$ 。

共 $m$ 次查询，每次查询给出 $l,r$ ，问对初始值为 $0$ 的序列 $a$ 依次执行操作 $(x_l,y_l),\dots,(x_r,y_r)$ ，最后 $\max\limits_{i=1}^n a_i$ 的值。
## 输入格式

第一行两个整数 $n,m$ （$1\le n,m\le 5\times 10^5$）；

接下来 $n$ 行每行两个整数 $x_i,y_i$（$1\le x_i\le n, |y_i|\le n$）；

接下来 $m$ 行，每行两个整数 $l,r$（$1\le l\le r\le n$）。
## 输出格式

输出 $m$ 行，每行一个整数，表示每次查询的答案。


## 样例

### 样例输入 #1
```
6 5
6 4
2 6
5 -5
3 6
1 2
3 6
1 6
1 6
2 6
2 6
5 6

```
### 样例输出 #1
```
19
19
15
15
8

```
## 提示

**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>


---

---
title: "[THUPC 2024 决赛] 机器人"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10545
tag: ['模拟', '2024', 'Special Judge', '2-SAT', 'THUPC']
---
# [THUPC 2024 决赛] 机器人
## 题目背景

注意本题的指令含义与初赛的略有不同。

## 题目描述

有 $n$ 个机器人围成一圈，编号按照逆时针顺序分别为 $0\sim n-1$。

每个机器人有两只手。编号为 $i$ 的机器人初始「左手」指向编号 $l_i$ 的机器人，「右手」指向编号 $r_i$ 的机器人。

所有的机器人内部都写有一条「指令」，「指令」有以下这些形式：

### 指令

下面介绍这些「指令」的格式以及它们被「执行」时的效果。文中的“自己”一词均指拥有这条「指令」的机器人。

- `SLACKOFF`：**「摸鱼」**，即什么也不做。
- `MOVE h z`：将第 $h$ 只手向逆时针方向 **「移动」** $z$ 个机器人的位置。当 $h=0$ 时表示「左手」，当 $h=1$ 时表示「右手」，下同。
- `SWAP`：**「交换」** 双手指向的机器人的「指令」。
- `TRIGGER <COMMANDNAME>: <COMMAND>`：其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一；`<COMMAND>` 表示一条完整的非 `TRIGGER` 「指令」。`TRIGGER` 指令本身不会被「执行」，但是，当一个**其他**机器人「执行」完一条「指令」之后，且「右手」指向自己的时候，自己满足如下条件的 `TRIGGER` 指令（如果有）就会被 **「触发」**——「执行」一次对应的 `<COMMAND>`：
  - `<COMMANDNAME>` 不为 `TRIGGER` 时，刚刚「执行」完毕的「指令」为 `<COMMANDNAME>` 指令；
  - `<COMMANDNAME>` 为 `TRIGGER` 时，刚刚「执行」完毕的「指令」是一条 `TRIGGER` 指令被「触发」时，「执行」的 `<COMMAND>` 部分。
- `TOGGLETRIGGERREPLACE h <COMMANDNAME> <NEWCOMMAND>`：如果第 $h$ 只手指向的机器人的「指令」是 `TRIGGER` 指令，则将其 **「切换」** 为该「指令」的 `<COMMAND>` 部分，即删去前面的 `TRIGGER` 及条件部分；如果这条「指令」不是 `TRIGGER` 指令，假设是 `<COMMAND>`，则将其「切换」为 `TRIGGER <COMMANDNAME>: <COMMAND>`。其中 `<COMMANDNAME>` 为 `SLACKOFF`、`MOVE`、`SWAP`、`TRIGGER`、`TOGGLETRIGGERREPLACE` 之一。然后将自己的「指令」（注意这可能不仅仅包含正在「执行」的那部分「指令」）修改为 `<NEWCOMMAND>`。其中，`<NEWCOMMAND>` 是一条完整的「指令」。

机器人「执行」各「指令」时的输出格式如下：

- 「摸鱼」时输出 `Robot <id> slacks off.`。其中 `<id>` 为一个整数，表示「执行」当前「指令」的机器人编号，下同。
- 「移动」时输出 `Robot <id> moves its <side> hand towards Robot <id2>.`。其中 `<side>` 为 `left` 或 `right`，表示移动了哪只手（`left` 表示「左手」，`right` 表示「右手」）；`<id2>` 为一个整数，表示移动之后这只手指向的机器人的编号。
- 「交换」时输出 `Robot <id> swaps the commands of Robot <id2> and Robot <id3>.`。其中 `<id2>` 和 `<id3>` 为整数，表示被「交换」「指令」的机器人编号，这两个数可以按任意顺序输出。
- 「切换」时输出 `Robot <id> toggles the trigger property of the command of Robot <id2>`。
- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。

你按照一定顺序选择了一些机器人（可能重复选择）并「执行」了对应机器人的「指令」，得到了「执行」的**完整**输出，也就是说，在「执行」完输出中最后一条「指令」之后，没有其他「指令」被「触发」。但是，你忘记了你选择机器人的顺序，也忘了每个机器人开始时有什么「指令」。你只记得机器人的总数以及开始时每个机器人的手指向什么位置。

你想通过已知的所有信息还原出最初所有机器人的「指令」都是什么。
## 输入格式

第一行两个正整数 $n,k$，其中 $k$ 表示输出的总行数。

接下来 $n$ 行，每行两个整数 $l_i,r_i$，按编号从小到大的顺序输入。

接下来 $k$ 行，每行一条「执行」「指令」的输出信息。

为了减轻处理输入的负担，输出信息被简化如下（没有特殊声明的参数信息含义同上）：

- 「摸鱼」时输出 `SLACKOFF <id>`。
- 「移动」时输出 `MOVE <id> <side> <id2>`。其中 `<side>` 为 `0` 或 `1`，表示移动了哪只手（`0` 表示「左手」，`1` 表示「右手」）。
- 「交换」时输出 `SWAP <id> <id2> <id3>`。
- 「切换」时输出 `TOGGLETRIGGERREPLACE <id> <id2>`。
- `TRIGGER` 指令不会被「执行」，但当它们被「触发」时，会按照上面的格式输出对应的「指令」被「执行」的信息。

输入保证存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的输出。

保证 $1\le n,k \le 500000$。

保证 $0\le l_i,r_i<n$。
## 输出格式

输出 $n$ 行，按编号从小到大输出机器人最初的「指令」，每条一行。

你需要保证「指令」格式正确，且 $0\le z < n$。

你需要保证你的输出文件不能过大。若你的输出文件大小不超过 $100\texttt{MB}$，则一定能保证 Special Judge 能够正确返回结果。

此外任何能够得到输入中 $k$ 行输出的答案均算作正确。
## 样例

### 样例输入 #1
```
4 7
1 3
2 0
3 0
2 1
SWAP 1 0 2
SWAP 0 1 3
SWAP 1 2 0
MOVE 0 0 2
SWAP 1 0 2
SWAP 0 2 3
MOVE 3 0 3

```
### 样例输出 #1
```
MOVE 0 1
SWAP
TRIGGER SWAP: SWAP
SWAP

```
### 样例输入 #2
```
4 7
1 2
2 3
3 1
0 2
TOGGLETRIGGERREPLACE 0 1
SLACKOFF 3
MOVE 0 1 3
SWAP 1 2 3
TOGGLETRIGGERREPLACE 3 2
SLACKOFF 2
SLACKOFF 3

```
### 样例输出 #2
```
TOGGLETRIGGERREPLACE 0 MOVE MOVE 1 1
TRIGGER SLACKOFF: SWAP
TRIGGER SWAP: TOGGLETRIGGERREPLACE 1 TOGGLETRIGGERREPLACE SLACKOFF
SLACKOFF

```
### 样例输入 #3
```
4 4
2 1
1 2
0 3
1 3
SLACKOFF 0
SLACKOFF 1
SLACKOFF 2
SLACKOFF 3

```
### 样例输出 #3
```
SLACKOFF
TRIGGER SLACKOFF: SLACKOFF
TRIGGER SLACKOFF: SLACKOFF
TRIGGER TRIGGER: SLACKOFF

```
## 提示

**样例解释 1**

选择机器人的顺序为 $1,1,0,1,3$，其中第二、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。

注意 `TRIGGER` 指令「触发」的时机是在「执行」上一条「指令」之后，所以第一次「交换」之后由于 $1$ 号机器人的「右手」指向了写有 `TRIGGER SWAP: SWAP` 的 $0$ 号机器人，所以这条 `TRIGGER` 指令能被「触发」。

**样例解释 2**

选择机器人的顺序为 $0,3,0,1,3$，其中第五、六条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。

第一次「执行」会使 $1$ 号机器人的「指令」变为 `SWAP`，$0$ 号机器人的「指令」变为 `MOVE 1 1`。

第五次「执行」会使 $2$ 号机器人的「指令」由 `SLACKOFF` 变为 
```
TRIGGER TOGGLETRIGGERREPLACE: SLACKOFF
```
，$3$ 号机器人的「指令」由
```
TRIGGER SWAP: TOGGLETRIGGERREPLACE 1 TOGGLETRIGGERREPLACE SLACKOFF
```
会变为 `SLACKOFF` 而不是 `TRIGGER SWAP: SLACKOFF`。

**样例解释 3**

选择机器人的顺序为 $0$，其中第二、三、四条被「执行」的「指令」是「触发」`TRIGGER` 指令之后被「执行」的。

注意 $3$ 号机器人「执行」完「指令」后不会接着「触发」自己的 `TRIGGER` 「指令」，即使它的「右手」指向了自己。

另外，选择一个写有 `TRIGGER` 指令的机器人不会产生任何输出，所以这么做没有意义。

**样例解释 4**

见题目目录下的 *4.in*。该样例不提供样例输出。

**样例解释 5**

见题目目录下的 *5.in*。该样例不提供样例输出。

**提示**

我们会下发一个可执行文件 `checker` 来帮助你检查你的输出是否正确。使用方式为在该文件所在目录下使用如下指令：

```
./checker <输入文件路径> <你的输出文件路径>
```

若你的输出正确，程序会输出 `Accepted.`；否则会提示「执行」结果与输入文件最早一次不匹配的地方。

注意，若你使用的输入文件不是样例输入，该程序不会检查是否存在一组初始的「指令」，使得存在一种选择机器人的方式，能够得到对应的「执行」结果。

**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>



---

---
title: "[THUPC 2024 决赛] 采矿"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10546
tag: ['2024', '交互题', 'Special Judge', '随机化', '构造', 'THUPC']
---
# [THUPC 2024 决赛] 采矿
## 题目背景

在精心地规划完工人的移动路线，执行完所有计划之后，你终于有钱了。你承包下了一个更大的矿坑，并购买了更先进的设备。

但是开始运行了你才发现，一部分运输矿物的通道居然装反了！还好它们本来就是可以反向的，并且中控的系统可以让你轻易地操作。

然而，现在最大的问题是，你刚刚接手这个矿坑，你甚至连它长什么样都不知道，也就更不知道每个开关是对应哪一条运输通道的。

时间就是金钱，你想要尽快摸清整个矿坑的结构以及所有开关与通道的对应关系。
## 题目描述

**这是一道交互题。**

已知你的矿坑有 $n$ 个节点，编号为 $1\sim n$。它们通过 $n-1$ 条运输通道连成一个树形结构。

运输通道都是单向的。对于一条从节点 $u$ 到节点 $v$ 的运输通道，可以将所有由节点 $u$ 产出的矿或运送到节点 $u$ 的矿以较快的速度运送到节点 $v$。如果一个节点有多条以其为起点的运输通道，那么会把这些矿平均分配给这些运输通道。

中控的系统包含 $n-1$ 个开关和一个监视器。开关的编号为 $1\sim n-1$，每个开关可以拨到 $0$ 或 $1$ 的位置。$n-1$ 个开关和 $n-1$ 条运输通道一一对应，但你并不知道它们的对应关系。你只知道，假设编号为 $i$ 的开关对应的运输通道在被装上去时是从 $u_i$ 到 $v_i$ 的，那么当开关拨到 $0$ 的时候，它的运输方向和它被装上去时相同；当开关拨到 $1$ 的时候，它的运输方向会变成从 $v_i$ 到 $u_i$。你的监视器可以监控到达每个节点的矿分别来自多少个不同的节点，也就是说，有多少个节点（包括其本身）能够通过运输通道把矿运输到这个节点。

当你调整完开关的位置后，需要等一段时间，监视器的结果才会趋于稳定，这时你的读数才是有意义的。所以为了避免浪费太多时间，你希望在 $50$ 次读数之内确定你想知道的所有信息。
## 输入格式

开始时你需要输入一个正整数 $n$。保证 $2\le n \le 10000$。

之后的输入会基于你的输出生成读数。你的读数结果是一行 $n$ 个正整数，其中第 $i$ 个表示到达节点 $i$ 的矿来自多少个不同的节点。

每个测试点中，矿坑的连接方式和所有运输通道刚装上去时的方向都是固定的，也就是说，这些不会因为你的输出而动态修改为另外一种符合之前所有回答的方案。
## 输出格式

当你需要调整开关并等待读数时，输出一行 `? s`，其中 `s` 为一个长为 $n-1$ 的 `01` 串，其中第 $i$ 位表示编号为 $i$ 的开关拨到的位置。然后交互库会在你的标准输入中给出监视器趋于稳定之后的读数结果。你最多只能读数 $50$ 次。

当你已经知道了所有通道的信息时，输出一行 `! u1 v1 ... un-1 vn-1`，其中 $u_i,v_i$ 表示编号为 $i$ 的开关对应的运输通道被装上去时的方向是从节点 $u_i$ 到节点 $v_i$ 的。

在输出一行之后，你需要刷新输出缓冲区，否则评测结果可能会变成 `TLE`。刷新输出缓冲区的方式为：

- C：`fflush(stdout);`

- C++：`fflush(stdout);` 或 `std::cout.flush();` 或使用 `std::endl` 换行

- Java：`System.out.flush();`

- Python：`sys.stdout.flush()`

## 样例

### 样例输入 #1
```
5

1 4 1 2 3

1 1 2 3 4
```
### 样例输出 #1
```

? 0110

? 0000

! 1 4 2 3 2 4 4 5
```
## 提示

![](https://cdn.luogu.com.cn/upload/image_hosting/fuc2u4d1.png)

通道的初始方向如上图所示。通道上的数字代表和通道对应的开关的编号。

样例只是用来说明输入输出格式和读数结果，并不意味着这次读数能够推出答案。


交互库的运行时间和内存不计入时间和内存限制。

若超出读数次数限制、最后的回答错误或输出格式错误，评测结果均为 `WA`。


**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>




---

---
title: "[THUPC 2024 决赛] 连向未来"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10551
tag: ['2024', 'THUPC']
---
# [THUPC 2024 决赛] 连向未来
## 题目背景

1 是烟消云散的过去。

2 是转瞬即逝的现在。

3 是遥不可及的未来。

过去的迷惘和烦恼连向了现在。如果梦想的热度至今不曾改变，那么不妨将迷惘和烦恼作为宝贵的经验。

现在也终将连向未来。通往未来的大门必定藏在世界上的某个角落。虽然可能无法简单寻得，但若不向前伸出双手，就无从触及。

想要创造从现在开始的崭新的时间，就需要将大家相连。1、2 和 3，缺一不可。只身一人所无法实现的目标，集齐众人的力量就必能跨过。就算形单影只时已足够努力奋斗，如果连在一起时都能各自加倍拼搏，那么不妨同舟共济，同音共律。
## 题目描述

给定一个 $N\times M$ 的网格。求在每个格子中分别填入 $1$，$2$ 或 $3$ 的方案数，使得填入后存在至少一种将具有公共边的格子分别相连的方案，满足：

- 每个填有 $1$ 或 $3$ 的格子**恰好**与相邻的任意一个填有 $2$ 的格子相连；

- 每个填有 $2$ 的格子**恰好**与相邻的任意一个填有 $1$ 的格子及任意一个填有 $3$ 的格子分别相连。
## 输入格式

输入第一行包括一个正整数 $T$，表示该测试点中的数据组数。保证 $1\le T\le 100$。

接下来 $T$ 行，每行包含两个由空格隔开的正整数 $N$ 和 $M$，表示网格的大小。保证 $1\le N\le 3$，$1\le M\le 10^9$。
## 输出格式

对每组数据输出一行，每行包括一个非负整数，表示填数方案数对 $998,244,353$ 取模之后的结果。
## 样例

### 样例输入 #1
```
5
3 4
2 5
1 6
2 240117
3 378140683

```
### 样例输出 #1
```
280
0
4
451142875
980338319

```
## 提示

不是相遇会带来离别，而是离别会指引新的相遇。


**来源与致谢**

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>


---

---
title: "[THUPC 2025 初赛] 排序大师 2"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P11525
tag: ['2025', 'Special Judge', 'THUPC']
---
# [THUPC 2025 初赛] 排序大师 2
## 题目描述

由于你是排序大师，你经常被路过的游客刁难，要求用一些奇怪的操作给序列排序。

由于你是远近闻名的排序大师，邻国的排序萌新小 I 慕名前来拜访，留下了一个长度为 $n$ 的排列 $a_1, a_2 \cdots, a_n$，并要求你用以下操作将排列升序排序：

- 选择 $i,j$，满足 $1 \le i, j \le n$ 且 $|j - i| > 1$，交换 $a_i$ 和 $a_j$。

由于你是因精益求精而远近闻名的排序大师，你需要给出一个排序方案**最小化**操作次数，或者报告以上操作无法将序列排序。如有多种操作次数最少的排序方案，输出任意一种即可。
## 输入格式

**本题有多组测试数据**。第一行一个整数 $T (T \ge 1)$ 表示测试数据组数。

对于每组测试数据，输入的第一行一个整数 $n(1 \le n \le 10^5)$ 表示排列长度，接下来一行 $n$ 个两两不同的整数 $a_1,a_2,\cdots, a_n (1 \le a_i \le n)$ 表示给出的排列。

保证单个测试点中所有测试数据的 $n$ 的和不超过 $10^5$。
## 输出格式

对于每组测试数据，如果使用题目给出的操作无法将序列排序，输出一行一个整数 `-1`，否则第一行输出一个整数 $s$ 表示最少的操作步数，接下来 $s$ 行每行两个整数 $i,j$，表示一次操作，你需要保证 $1 \le i, j \le n$ 且 $|j - i| > 1$。

可以证明对于所有可能输入，若可以使用题设操作将序列排序，则 $s \le 5n$。
## 样例

### 样例输入 #1
```
2
4
2 3 4 1
2
2 1
```
### 样例输出 #1
```
5
2 4
1 4
1 3
2 4
1 4
-1
```
## 提示

对于第一组测试数据，排序过程为 $2341 \to 2143 \to 3142 \to 4132 \to 4231 \to 1234$。可以证明不存在步数更少的方案。

#### 题目来源

来自 2025 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2025）初赛。

题解等资源可在 <https://gitlink.org.cn/thusaa/thupc2025pre/tree/master> 查看。


---

---
title: "[THUPC 2025 初赛] 峰回路转"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P11530
tag: ['2025', 'THUPC']
---
# [THUPC 2025 初赛] 峰回路转
## 题目背景

昼短夜长冬至近。江冽漆黑，但见东云粉。窗外惺忪鸥鹭阵，室中香漫晨炊奋。

朝肄暮劳催彼盹。宵寂观书，灯烬方安寝。请替君劳分重任，逍遥共舞生辰顺。
## 题目描述

K 最近在学古诗文。古诗文的行文不一定按照现代人的习惯，有时是因为古诗文有其特殊的语法结构，有时是因为对仗工整、韵律和谐等主观原因。但是，如果直接在原文旁边标注一个表示正确阅读顺序的排列，不仅在排版上不美观，而且寻找下一个编号也比较麻烦。为了方便阅读，K 设计了一套辅助记号来标注顺序，替代直接标注顺序编号的方式。

辅助记号一共有 3 种：近邻逆接记号、近邻顺接记号、遥远跳转记号。两种近邻记号定义了**相邻两个字符**之间相对的阅读顺序，故其必须出现在相邻两个字符之间，而不能出现在句首或句末；遥远跳转记号在单独使用时仅作用于其**前一个字符**，故其必须出现在单个字符之后，可以出现在句末而不能出现在句首。

近邻逆接记号 `*` 用于表示，在正常阅读顺序中，该记号前的**最后一个**字符应该**紧跟**在该记号后的**第一个**字符之后，如“研表`*`究明，汉字序`*`顺并不定`*`一影阅`*`响读”的正确语序是“研究表明，汉字顺序并不一定影响阅读”。近邻逆接记号可以连续使用，此时表示对应的一整段文字应从后往前逐个阅读。如“林暗草惊风，将军夜引弓”的正常语序是“林暗风惊草，将军夜引弓”，所以可以用“林暗草`*`惊`*`风”来标记主宾换位。

对于较复杂的阅读顺序，可以用遥远跳转记号来辅助理解。例如，“马之千里者，一食或尽粟一石”中，“一石”是修饰“粟”的数量短语，因此按正常语序应为“一食或尽一石粟”。为了标注此类不相邻的顺序交换，可以使用遥远跳转记号来指出需要从后往前依次阅读的一组字符，并称这样的一组字符为遥远跳转结构。为了防止出现混乱，规定对于任意两组遥远跳转结构，要么其中一组的所有字符都在另一组的任意字符之前，要么其中一组的所有字符都位于另一组中连续的某两个字符之间；不允许两组遥远跳转结构的字符在原字符串中交叉出现。因为可能出现多层嵌套，所以遥远跳转记号具有 `p-q` 的形式，其中正整数 `p` 表示内部嵌套的层数，`q` 表示在该组中的顺序。如果一组遥远跳转结构内部没有嵌套任何其它遥远跳转结构，则该组遥远跳转结构的各记号的层数 `p` 均为 $1$，否则为内部嵌套的所有遥远跳转结构的最大层数 $+1$。对于同一组遥远跳转结构，按各字符在原字符串中的出现顺序从后往前依次编号 `q` $=1,2,3,\cdots$，这一顺序也即实际阅读顺序。在阅读带有辅助记号的文本时，如果一个字符后紧跟着序号 `q` $\ge 2$ 的遥远跳转记号，则应暂时跳过该字符不读；直到遇到 `q` 恰好为 $1$ 的遥远跳转记号，此时应从后往前依次阅读同组的 `p-1`，`p-2` 等记号前的**单个**字符，直到遇到层数 `p` 更大的遥远跳转记号、另一个层数相同的 `p-1` 的遥远跳转记号（此时这一记号应标记另一组遥远跳转结构），或者碰到开头。

对于上文中取自《马说》的例句，相应的标注方法为“一食或尽粟`1-2`一石`1-1`”。再例如，“入则无法家拂士，出则无敌国外患者，国恒亡，然后知生于忧患而死于安乐也”一句中出现了两处状语后置（“然后知于忧患生而于安乐死也”），其满足要求的标注方法为“然后知生`1-2`于忧患`1-1`而死`1-2`于安乐`1-1`也”。另外，同一组的遥远跳转记号的序号 `q` 一定是降序出现的，即不允许连续出现 `p-2 p-3 p-1` 等情况。

由于近邻逆接记号和遥远跳转记号都可以用来表示与正常阅读方向相反的跳转，规定在读完一个字符后需要紧接着阅读其前一个字符时，**必须**使用近邻逆接记号。这一规定会产生一个问题，即在同一组遥远跳转结构中出现了在原文中相邻的字符时，如果相邻的字符不在遥远跳转结构的开头或结尾，用近邻逆接记号来标注这一堆字符，有可能会导致阅读顺序的歧义。幸好，解决办法并不复杂：只需在出现相邻字符的位置将一个遥远跳转结构拆成两个或多个即可。注意拆开时，每个新的结构的所对应的层数应独立计算。

在使用遥远跳转记号时，默认只更改记号前的**单个**字符的阅读顺序。如果需要将连续的多个字符的阅读顺序推后，则应配合近邻顺接记号 `#`，表示该记号后的**第一个**字符应该**紧跟**在该记号前的**最后一个**字符之后。例如，“今日大风寒，寒风摧树木，严霜结庭兰”一句中，主语“庭兰”和宾语“严霜”的位置发生了对调，故可以标注为“严`1-3#`霜结`1-2`庭兰`1-1`”。出于简洁起见，要求近邻顺接记号必须和序号 `q` $\ge 2$ 的遥远跳转记号连用，但根据实际需要可以连续使用多个近邻顺接记号，此时在且仅在第一个近邻顺接记号前标注遥远跳转记号。例如，“七八个星天外，两三点雨山前”的正常语序是“天外七八个星，山前两三点雨”，因此可以标注为“七`1-2#`八`#`个`#`星天外`1-1`，两`1-2#`三`#`点`#`雨山前`1-1`”。

在阅读标注有辅助记号的文本时，默认按照正常阅读顺序从前往后处理每个字符。如果遇到一个字符没有标注辅助记号且其前一个字符没有标记近邻顺接记号，应该直接阅读这个字符；否则，先暂时忽略该字符。当遇到标注有序号为 $1$ 的遥远跳转记号的字符（对应忽略了同组的遥远跳转记号及任何相关的近邻顺接记号）或没有标注辅助记号的字符（对应忽略了至少一个近邻逆接记号）时，先阅读这个字符，再按相应规则返回阅读被忽略的字符。

为了防止使用记号时出现歧义，除了上述规则外，还规定：

- 相邻两个字符之间，要么不使用任何辅助记号，要么使用单独的近邻逆接记号，单独的近邻顺接记号，单独的遥远跳转记号，一个遥远跳转记号和一个近邻逆接记号，或一个遥远跳转记号和一个近邻顺接记号。最后一个字符之后要么没有辅助记号，要么有单独的遥远跳转记号。
- 如果相邻两个字符之间使用了一个遥远跳转记号和任意一种近邻记号的组合，则应将遥远跳转记号标在近邻记号之前。特别地，如果是一个遥远跳转记号和一个近邻逆接记号的组合，则该遥远跳转记号的序号 `q` 必须为 $1$。
- 对于任意连续的三个字符，不允许混合使用近邻逆接记号和近邻顺接记号（无论是否与遥远跳转记号搭配使用），即不能出现 `.#.*.` 或 `.*.#.` 等未定义的标注方式，其中 `.` 表示单个需要被标注的字符。同理，不允许出现前一个字符标注了近邻顺接记号，后一个字符标注了遥远跳转记号（无论这个遥远跳转记号是否与任意近邻记号组合使用）。

不过，K 发现这套系统并不能标记任意的排列。例如，“绿垂风折笋，红绽雨肥梅”在现代汉语中的语序是“风折绿笋垂，雨肥红梅绽”，它就无法被任意记号的组合表示。因此 K 想知道，对于给定的一个阅读顺序，是否存在一种仅使用上述三种记号的标注方法。如果存在，请帮 K 求出满足简洁要求的唯一标注方法。
## 输入格式

输入的第一行包含一个正整数 $K$，表示需要标注的原字符串长度。保证 $1\le K \le 10^6$。

输入的第二行包含 $K$ 个正整数 $p_1, p_2, \cdots, p_K$，其中 $p_i$ 表示需要标注的原字符串的第 $i$ 个字符在正确阅读顺序中的位置。保证 $p_1, p_2, \cdots, p_K$ 是一个 $1, 2, \cdots, K$ 的排列。
## 输出格式

输出一个字符串。

如果存在合法的标注方法，则输出满足要求的唯一标注方法，其中用单个 `.` 表示原字符串中的每个字符。

否则，输出 `-1`，表示不存在合法的标注方法。
## 样例

### 样例输入 #1
```
4
1 3 2 4
```
### 样例输出 #1
```
..*..
```
### 样例输入 #2
```
9
3 4 1 2 8 9 5 6 7
```
### 样例输出 #2
```
.1-2#...1-1.1-2#....1-1
```
### 样例输入 #3
```
4
2 4 1 3
```
### 样例输出 #3
```
-1
```
### 样例输入 #4
```
7
7 1 2 6 5 3 4
```
### 样例输出 #4
```
.1-2...1-1*.1-2..1-1
```
### 样例输入 #5
```
8
1 2 8 6 3 5 4 7
```
### 样例输出 #5
```
...2-2.1-2..1-1*..2-1
```
### 样例输入 #6
```
8
2 1 3 8 7 5 4 6
```
### 样例输出 #6
```
.*...*.1-2.*..1-1
```
## 提示

### 样例解释

- 样例 1：“微斯人，吾谁`*`与归？”

- 样例 2：“故`1-2#`国神游`1-1`，多`1-2#`情应笑我`1-1`。”

- 样例 3：
另外三种不能被表示出来的长度为 $4$ 的阅读顺序为：
  + $2, 4, 3, 1$；
  + $3, 1, 4, 2$；
  + $3, 2, 4, 1$。
  
### 题目来源

题目来自 THUPC2025（2025年清华大学学生程序设计竞赛暨高校邀请赛）初赛，信息来源于 [THUSAAC 仓库](https://gitlink.org.cn/thusaa/thupc2025pre)。


---

---
title: "[THUPC 2025 决赛] 对脑电波"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P12053
tag: ['2025', 'THUPC']
---
# [THUPC 2025 决赛] 对脑电波
## 题目描述

你和他曾一起尝试过解决一道题目。

一道题目的解决方案可以看作从 $1$ 到 $n$ 编号的 $n$ 个性质。每个性质都可以通过一个特点 $p_i$ 来代表，$p_i$ 越大说明这个性质越智力，$p_i$ 越小表示这个性质越套路。由于每个性质都不完全相同，因此 $p$ 组成了一个长度为 $n$ 的排列。

他是日本题领域大神。他经过思考想出了 $k$ 个性质，这 $k$ 个性质组成的子序列 $S_0$ 恰好是 $p$ 的所有长度为 $k$ 的子序列中字典序最**大**的那个。

你是中国题领域大神。你经过思考也想出了 $k$ 个性质，这 $k$ 个性质组成的子序列 $S_1$ 恰好是 $p$ 的所有长度为 $k$ 的子序列中字典序最**小**的那个。

你们把你们思考出的性质分别罗列。你们在一张纸条上记录下了 $S_0$ 和 $S_1$ 之间的**某一个**最长公共子序列。

这时下课铃响了，你们一起去吃饭了。

后来过去了好久啊，你们也早已分道扬镳。在某一天，你在整理物品的时候又发现了这张纸条。你又想起了这道没能解决的难题。你想知道，当年的那道题目，有多少种可能的解决方案，最终**可能**会导致这张纸条的出现。

答案对 $998244353$ 取模。
## 输入格式

第一行包括三个正整数 $n,k,m\ (2\leq m\leq k\leq n\leq 400)$，分别表示题目性质的总数量、你和他找出的性质的数量和最长公共子序列的长度。

第二行包括 $m$ 个正整数 $S_1,S_2,\cdots,S_m\ (1 \leq S_i \leq n)$，表示记录在纸条上的最长公共子序列。

## 输出格式


输出一行一个整数，表示满足要求的排列数量对 $998244353$ 取模后的结果。

## 样例

### 样例输入 #1
```
5 3 2
2 3

```
### 样例输出 #1
```
4

```
### 样例输入 #2
```
6 4 2
2 3

```
### 样例输出 #2
```
10

```
### 样例输入 #3
```
2 2 2
1 1

```
### 样例输出 #3
```
0

```
### 样例输入 #4
```
11 5 2
6 4

```
### 样例输出 #4
```
198198

```
### 样例输入 #5
```
20 10 5
13 17 10 6 5

```
### 样例输出 #5
```
392592366

```
## 提示

### 样例 #1 解释

以下为满足要求的 $4$ 种排列：

$1,4,5,2,3$

$4,1,5,2,3$

$4,5,1,2,3$

$4,5,2,1,3$

### 样例 #2 解释


以下为满足要求的 $10$ 种排列：

$1,4,5,6,2,3$

$1,4,6,5,2,3$

$1,5,4,6,2,3$

$1,6,4,5,2,3$

$4,6,5,1,2,3$

$4,6,5,2,1,3$

$5,1,4,6,2,3$

$6,1,4,5,2,3$

$6,4,5,1,2,3$

$6,4,5,2,1,3$


### 样例 #3 解释

显然无满足要求的排列。

### 提示

Bonus: $n \leq 5000$。


### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。


---

---
title: "[THUPC 2025 决赛] 一个 01 串，n 次三目运算符，最后值为 1"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P12055
tag: ['2025', 'Special Judge', 'THUPC']
---
# [THUPC 2025 决赛] 一个 01 串，n 次三目运算符，最后值为 1
## 题目背景


三目运算符表达式 `a?b:c` 的含义是，如果 `a` 为真，那么返回 `b`，否则返回 `c`。

三目运算符是右结合的：`a?b:c?d:e` 和 `a?b:(c?d:e)` 等价。如果你不记得运算顺序，可以总是使用括号。

$0$ 为假，$1$ 为真。
## 题目描述



给定一个长为 $2n+1$ 的 01 串，你需要使用 $n$ 次三目运算符，即在中间插入恰好 $n$ 个 `?` 和 $n$ 个 `:` 以及若干括号，使得表达式的结果为 $1$，或判断无解。

## 输入格式


第一行一个正整数 $n\ (1\le n \le 1.5\times 10^5)$。

第二行一个长为 $2n+1$ 的 01 串，表示给定的字符串。

## 输出格式


如果无解，输出一行 `No`。

如果有解，第一行输出 `Yes`，第二行输出一个值为 $1$ 的表达式。你可以使用括号，但是需要保证你的表达式中数字的顺序和原串相同。你需要保证你输出的表达式长度不超过 $10n+1000$。可以证明如果存在解，则一定存在满足条件的构造方案。

## 样例

### 样例输入 #1
```
2
10101

```
### 样例输出 #1
```
Yes
(1?0:1)?0:1

```
### 样例输入 #2
```
2
00000

```
### 样例输出 #2
```
No

```
## 提示

### 样例 #1 解释


你如果输出 `(((1?0:((((1)))))?0:1))` 等表达式也算正确。

### 提示


你可以直接使用 g++ 编译你的表达式来检查表达式的值，但是这种方法并不能检测数字的顺序是否一致，也不能检测你使用三目运算符的次数是否恰好为 $n$，即是否每两个相邻的数字之间都有一个 `?` 或 `:`：

```c++
#include <cassert>
#define YOUR_EXPRESSION <your_expression>
int main(){
    assert(YOUR_EXPRESSION);
    return 0;
}
```

### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。


---

---
title: "[THUPC 2025 决赛] I'm Here"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P12059
tag: ['2025', 'THUPC']
---
# [THUPC 2025 决赛] I'm Here
## 题目描述


黑猫的世界正在走向终结。 

在这个正在走向终结的世界里，Liki 和 Sasami 需要找到世界的真相。具体来说，这个世界可以看做一棵 $n$ 个结点的有根树，根结点的编号为 $1$。并且存在一种对树进行深度优先搜索的方案，使第 $i$ 次访问的结点为 $i$。也就是说 **$1\sim n$ 可以构成这棵树的一个 dfs 序**。在最开始，所有的结点都没有崩溃。

每一天，Liki 和 Sasami 会探索一个没有崩坏的结点 $u$。在这次探索后，为了引导他们发现世界真相，黑猫会使 $u$ 及子树中所有点崩坏。 

同时，在第 $i$ 天 Liki 和 Sasami 的探索结束后，由于自身力量枯竭，第 $n-i+1$ 号结点若没有崩坏，则会崩坏。 

分别对 $i \in [1,n]$ 求 Liki 和 Sasami 有多少种恰好探索 $i$ 天的探索方案，满足最后一次探索的是 $1$ 号结点，对 $998244353$ 取模。

## 输入格式


第一行一个数，$n\ (1\le n\le80)$，代表树的结点数 。 

接下来 $n-1$ 行每行两个数 $u,v\ (1\le u,v\le n)$，代表结点 $u$ 和结点 $v$ 之间有一条边。

## 输出格式


输出 $n$ 个数，第 $i$ 个数代表探索 $i$ 天的方案数，对 $998244353$ 取模。

## 样例

### 样例输入 #1
```
4
1 2
2 3
2 4

```
### 样例输出 #1
```
1 3 3 1

```
### 样例输入 #2
```
7
4 2
6 1
5 1
7 6
2 3
1 2

```
### 样例输出 #2
```
1 6 23 48 43 17 1

```
## 提示

### 样例 #1 解释


对于样例 $1$，以下 $8$ 种探索序列合法：

$\{1\},\{2,1\},\{3,1\},\{4,1\},\{3,2,1\},\{4,2,1\},\{4,3,1\},\{4,3,2,1\}$。


### 来源与致谢

来自 THUPC2025（2025 年清华大学学生程序设计竞赛暨高校邀请赛）决赛。感谢 THUSAA 的提供的题目。

数据、题面、标程、题解等请参阅 THUPC 官方仓库 <https://thusaac.com/public>。


---

---
title: "[THUPC 2019] 不用找的树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5374
tag: ['2019', 'O2优化', 'THUPC']
---
# [THUPC 2019] 不用找的树
## 题目描述

给出一棵 $n$ 个节点的树，结点标号从 $1$ 到 $n$ 。

定义树上两点 $a,b$ 的距离 $d(a,b)$ 是最小的非负整数 $k$ ，满足存在结点序列 $v_0,v_1,...,v_k$ ，满足 $v_0=a,v_k=b$ ，且对于 $0\leq i\leq k-1$ 有 $v_i$ 和 $v_{i+1}$ 之间在树上有一条边相连。

有 $m$ 个询问，每个询问包含参数 $p_0,d_0,p_1,d_1$ ，求：

$$\sum\limits_{d(p_0,a)\leq d_0}\sum\limits_{d(p_1,b)\leq d_1}d(a,b)$$


## 输入格式

第一行一个整数 $n$ ，表示树的节点数目。

接下来一行 $n-1$ 个整数 $f_2,f_3,...,f_n$ ，依次表示 $i$ 和 $f_i$ （ $1\leq f_i\leq i-1$ ）之间有一条边。

接下来一行一个整数 $m$ ，表示询问数目。

接下来 $m$ 行依次描述所有询问：每行四个证书 $p_0,d_0,p_1,d_1$ （ $1\leq p_0,p_1\leq n,0\leq d_0,d_1\leq n-1$ ）描述一组询问。

保证 $1\leq n\leq 10^5,1\leq m\leq 10^5$ 。


## 输出格式

共 $m$ 行，依次回答各组询问：每行输出一行一个整数表示这组询问的答案。
## 样例

### 样例输入 #1
```
7
1 1 2 3 5 2
5
5 1 5 0
2 0 5 0
2 2 4 5
7 2 2 4
3 2 5 4
```
### 样例输出 #1
```
2
3
69
57
70
```
## 提示

##### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。


---

---
title: "[THUPC 2019] 能量波"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5378
tag: ['2019', 'THUPC']
---
# [THUPC 2019] 能量波
## 题目描述

> 有两个超级英雄在宇宙中战斗。英雄 A 为了击败对手英雄 B，使出了他的绝招，发出了一记能量光波。
>
> 英雄 B 有一些体力值，如果英雄 A 的能量光波对英雄 B 的伤害足够大，英雄 B 就会被击倒。否则英雄 A 就会因为耗尽能量而被英雄 B 抓住破绽，从而反而被英雄 B 击倒。所以英雄 A 迫切想知道自己的能量光波到底能够对英雄 B 造成多少伤害。

为了简化问题，英雄 B 可以被描述为空间中的多个凸多面体拼成的物体。这些凸多面体可能有重合的部分，重合部分作为英雄 B 的身体只会被计算一次。

英雄 A 发出的能量光波也可以被描述为空间中的另外一个凸多面体，这个光波在空间中每秒均匀移动一个向量 $\vec{v} = (v_x,v_y,v_z)$。能量光波可以穿过任何物体，并且在穿越的过程中对对方造成伤害。

在时刻 $t$, 假设英雄 A 的能量光波和英雄 B 的身体的交的体积为 $f(t) = V$，那么在这一瞬间，能量光波造成的瞬时伤害速率就恰好是 $V$。而所有时刻的总计伤害就可以被表示为

$$\int_{0}^{\infty} f(t) \mathrm{d}t$$

英雄 A 想要知道自己的能量光波对英雄 B 的身体造成了多大的总计伤害。
## 输入格式

第 $1$ 行一个正整数 $m_B$，表示英雄 B 的身体有多少个凸多面体组成。

接下来有 $m_B$ 个输入块，每块表示英雄 B 的身体的一个组成部分。

每个输入块开头第一行为一个正整数 $n$，表示这个凸多面体的顶点的个数，

接下来 $n$ 行每行一个三元组，其中第 $i$ 个 $(x_i,y_i,z_i)$ 表示第 $i$ 个点的坐标。

接下来一行一个正整数 $n_A$，表示英雄 A 的能量光波的对应凸多面体的顶点数，

接下来 $n_A$ 行每行一个三元组，其中第 $i$ 个 $(x_i,y_i,z_i)$ 表示第 $i$ 个点的坐标。

再接下来一行一个三元组 $(v_x,v_y,v_z)$，表示英雄 A 的能量光波的移动速度。

我们保证 $1 \le m_B \le 4,4\le n,n_A\le 8$ ，所有输入的点的坐标都是 $[-100,100]$ 内的整数。并且所有速度向量的分量都是 $[-10,10]$ 内的实数。所有凸多面体都是不退化的 （意思是这个凸多面体的体积非 $0$）。

输入中可能会出现四点共面或者三点共线的情况。

我们保证在第 $0$ 秒能量光波和英雄 B 是不相交的。并且在第 $10^4$ 秒之后交集的体积一直是 $0$。
## 输出格式

一行输出一个实数，表示总计伤害的值。

输出与标准答案的绝对误差或相对误差小于 $10^{-6}$ 就会被算作正确。
## 样例

### 样例输入 #1
```
1
8
0 0 0
0 0 1
0 1 0
0 1 1
1 0 0
1 0 1
1 1 0
1 1 1
8
2 0 0
2 0 1
2 1 0
2 1 1
3 0 0
3 0 1
3 1 0
3 1 1
-1 0 0
```
### 样例输出 #1
```
1.0000000000
```
## 提示

##### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。


---

---
title: "[THUPC 2019] 令人难以忘记的题目名称"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5379
tag: ['2019', 'THUPC']
---
# [THUPC 2019] 令人难以忘记的题目名称
## 题目描述

现在有一个长度为 $N$ 的整数序列 $S$（下标从 $0$ 开始），Alice 和 Bob 在这个序列上博弈。

游戏按轮进行，每一轮中：

* Alice 给出一个长度为 $N$ 的正整数序列 $T$
* Bob 看到 Alice 给出的 $T$，然后选择 $[0, N-1]$ 里的一个整数 $x$
* 之后我们把 $S$ 转化为 $S'$，规则如下：

$${S'}_{i} = S_{i} + T_{(i+x)\bmod N}$$

* 以 $S'$ 作为新的 $S$，结束这一轮。

如果某一轮结束后，$S$ 中每个数都是一个给定质数 $P$ 的倍数，那么 Alice 胜利。

给定 $N$ 和初始序列 $S$，请问：Alice 是否能在有限步必胜，如果答案为是，最快可以在几轮内保证胜利。
## 输入格式

第一行两个非负整数 $N,P$，保证 $P$ 是一个质数。

接下来一行 $N$ 个空格隔开的整数，描述初始序列 $S$（$0\le S_i \le 10^9$）。

保证 $N\le 3\times 10^5$，$P\le 200$。
## 输出格式

输出一个整数，如果 Alice 不能在有限步必胜，输出 $-1$，否则输出一个整数 $x$ 表示 Alice 最快能在几轮内胜利。
## 样例

### 样例输入 #1
```
4 2
0 1 0 1
```
### 样例输出 #1
```
2
```
## 提示

### 样例解释

一种可能的游戏情形是：

* 第一轮 $T=[1, 0, 1, 0]$，$x=0$，转化后的  $S'=[1,1,1,1]$。
* 第二轮 $T=[1,1,1,1]$，无论 $x$ 取什么，转化后的 $S'=[2,2,2,2]$。

可以证明 $2$ 轮是最优的。

##### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。


---

---
title: "[THUPC 2019] 找树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5406
tag: ['2019', '快速沃尔什变换 FWT', 'THUPC']
---
# [THUPC 2019] 找树
## 题目描述

定义 $\otimes_1, \otimes_2, \otimes_3$ 分别为按位与、按位或、按位异或运算。记 $a_i$ 表示 $a$ 的从低位到高位的第 $i$ 个二进制位。定义一个作用在 $w$ 位二进制数上的新运算 $\oplus$，满足对于结果 $a\oplus b$ 的每一位 $(a\oplus b)_i$ 有 $(a\oplus b)_i = a_i \otimes_{o_i} b_i$。不难验证 $\oplus$ 运算满足结合律和交换律。

给出一张 $n$ 个点 $m$ 条边的无向图，每一条边的权值是一个 $w$ 位二进制数（即小于 $2^w$ 的非负整数）。请你找一棵原图的生成树。设你找出的生成树中的边边权分别为 $v_1,\cdots,v_{n-1}$，请你最大化 $v_1\oplus v_2\oplus\cdots\oplus v_{n-1}$。
## 输入格式

第一行两个正整数 $n,m$；

第二行一个长度为 $w$ 的串，串中的每个字符为 `&`、`|`、`^`  中的一个（分别代表与、或和异或），表示每一个 $\otimes_{o_i}$。

接下来 $m$ 行，每一行三个非负整数 $x,y,v$，表示一条连接 $x$ 和 $y$ 权值为 $v$ 的边，保证 $1\leq x,y\leq n$，$0\le v < 2^w$。

对于所有数据，$1\le n\le 70,1\le m\le 5000,1\le w \le 12$。
## 输出格式

输出一行一个数，表示答案。如果图不连通，输出 `-1`。
## 样例

### 样例输入 #1
```
3 3
^
1 2 1
2 3 1
1 3 0
```
### 样例输出 #1
```
1
```
## 提示

### 关于数据

由于一些原因，数据只保留了最后 $20$ 个点。

### 版权信息

来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2019> 查看。


---

---
title: "[THUPC 2018] 赛艇"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5447
tag: ['2018', 'THUPC']
---
# [THUPC 2018] 赛艇
## 题目描述

Lavender、Caryophyllus、Jasmine、Dianthus现在在玩一款名叫“赛艇”的游戏。

这个游戏的规则是这样的：

1. 玩家自由组成两队，一个人当赛艇的艇长，另一个人当侦察兵；
2. 每次游戏开始时，双方均拥有由系统生成的某张地图，该地图以01矩阵的形式表示，`1`表示有障碍物，无法通行，`0`表示水域空旷，可以通行；
3. 第一回合，双方的赛艇艇长都要在地图上指定一个出发点，该出发点不能是障碍物，也就是只能为`0`；
4. 在每个回合中，艇长可以指挥自己的赛艇向上/下/左/右四个方向的某一方向的空旷水域移动一个单位的距离，也就是说只能移向四个方向上的某个`0`上（当然，不能移动出地图之外）；在该操作完成之后，**必须向对方说出自己在该回合移动的方向**；
5. 双方的侦察兵负责记录每一回合对方赛艇的移动方向，并负责推断此时对方赛艇可能的位置；如果某方的侦察兵推测出对方赛艇此时的精确位置，那么可以向其发射导弹，该侦察兵所在的一方胜利；

现在，Jasmine记录了一些对方赛艇的路径，她想确定一下此时对方所有可能的位置共有几种。由于她不是很擅长计算，所以这个任务就交给你了。
## 输入格式

输入第一行包含三个正整数 $n$，$m$，$k$，分别表示地图为 $n$ 行 $m$ 列，当前游戏已经进行了 $k$ 轮。保证 $2\le n,m \le 1500$，$1\le k\le 5\times 10^6$。

输入第二行到第 $n+1$ 行为一个 $n$ 行 $m$ 列的 01 矩阵，无任何分隔符号，表示地图的具体信息，具体含义如上所示。

输入的最后一行为一个长度为 $k$ 的字符串 $s$，仅由字母 `w`、`a`、`s`、`d` 构成，从前往后第 $i$ 个字符 $s_i$ 表示对方在第 $i$ 轮中，对方赛艇向上/左/下/右移动一个单位距离。
## 输出格式

输出一行一个正整数，表示在第 $k$ 轮游戏回合的时候，对方赛艇可能的位置的种数。对于所有输入数据，**保证有合法解**。
## 样例

### 样例输入 #1
```
5 6 5
000000
001001
000100
001000
000001
dwdaa
```
### 样例输出 #1
```
4
```
## 提示

### 样例解释

![](https://i.loli.net/2018/05/14/5af98ebcd79df.png)

上图显示了路径序列可视化之后的结果，下图用蓝色标出了此时对方赛艇可能的位置。

![](https://i.loli.net/2018/05/14/5af98ed39a602.png)

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai/) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。


---

---
title: "[THUPC 2018] 好图计数"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5448
tag: ['2018', 'THUPC']
---
# [THUPC 2018] 好图计数
## 题目背景

这道题目非常简单，它甚至没有题目背景、没有任何故事。

但为了能让你顺利理解题目，善良的 Yazid 将为你介绍一些概念。

* 简单图：不存在重边、自环的图。（重边即为两条完全相同的边，自环即为两端点为同一节点的边）

* 补图：一个图 $G$ 的补图有与 $G$ 完全相同的节点，且任意两点之间有边当且仅当他们在 $G$ 中不相邻。
## 题目描述

我们归纳定义一个无向简单图是**好的**：

1. 一个单点是好的。

2. 若干个好的图分别作为联通块所形成的图是好的。

3. 一个好的图的补图是好的。

给定一个正整数 $n$。

求 $n$ 个点的本质不同的好的图的数量对质数 $P$ 取模的结果。（这里的 $P$ 是一个常数，具体见【输入格式】）

两个好的图的被认为是**本质不同的**，当且仅当无论如何将一个图重标号，它都不能与另一个图完全相同。
## 输入格式

输入包含多组数据，第一行 $2$ 个用空格隔开的整数 $T,P$ 分别表示数据组数、以及模数。接下来依次描述每组数据，对于每组数据：

* 一行一个整数 $n$，表示希望统计数目的好的图的节点数。
## 输出格式

对于每组数据，输出 $1$ 行：

* 一个整数，表示 $n$ 个节点的好的图的数目对 $P$ 取模的结果。
## 样例

### 样例输入 #1
```
2 233
3
4
```
### 样例输出 #1
```
4
10
```
## 提示

### 样例解释

下面是 $3$ 个点的所有好的图：

![](https://i.loli.net/2018/05/14/5af990dbcfbc0.png)

### 数据范围

保证 $T\leq 233$，$n\leq 23333$，$2^{29} < P < 2^{30}$ 且保证 $P$ 为质数。

### 提示

能够通过本题的算法的时间复杂度可能比你想象的要糟糕一些、也可能比你想象的要优秀一些。

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai/) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。


---

---
title: "[THUPC 2018] 淘米神的树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5450
tag: ['2018', 'THUPC']
---
# [THUPC 2018] 淘米神的树
## 题目描述

可爱的 Tommy 有一棵树。这棵树上只有点 $a$ 和 $b$ 是黑色，其它的点都是白色。

每次，Tommy 可以将一个黑色 $p$ 的点染成红色，然后把和 $p$ 相邻的所有白色的点染成黑色。最后，所有的点都会被染成红色。

设第 $i$ 个点是第 $t_i$ 个被染成红色的，那么 $t_i$ 是一个 $1$ 到 $n$ 的排列。Tommy 希望你帮他求出，有多少种不同的 $t_i$。
## 输入格式

每个输入文件仅包含一个测试数据。

* 第一行三个用空格隔开的正整数 $n,a,b$，表示树的点数和初始的黑色点的编号；

* 接下来 $n-1$ 行，每行两个正整数 $x,y$ 描述树上的一条边 $\left( x,y\right)$。

树上的节点从 $1$ 开始编号。
## 输出格式

输出 $1$ 行：

* 一个整数，表示不同的排列 $t_i$ 的个数除以 $998,244,353$ 的余数。
## 样例

### 样例输入 #1
```
4 1 2
1 2
2 3
3 4
```
### 样例输出 #1
```
4
```
## 提示

### 数据范围

保证 $a,b\le n\le 234,567$。

### 版权信息

来自 2018 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2018），感谢 [Pony.ai](http://pony.ai/) 对此次比赛的支持。

题解等资源可在 <https://github.com/wangyurzee7/THUPC2018> 查看。


---

---
title: "[THUPC 2019] 摆家具"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P6712
tag: ['2019', 'THUPC']
---
# [THUPC 2019] 摆家具
## 题目描述

你有 $k$ 件不同的家具，需要摆放在 $n$ 个不同的房间中。假设每个房间足够大，并且只考虑每件家具处于哪个房间（而不考虑房间内部如何摆放），那么总共有 $n^k$ 种不同的摆放方式（注意，不是 $k^n$）。

摆放家具也算一门学问了，至少不太好乱摆的吧？对于每种摆放方式，我们可以给这种方式打分。例如，某个方案把餐桌放到了卫生间，或是一个卧室放了两张床而另一个卧室没有床，就会获得比较低的分数。由于这个分数关于每件家具、每个房间不是独立的，我们会输入所有 $n^k$ 种摆放方式的分数。

你现在心血来潮，想换一换房间的布局。给出一种初始时的摆放方式，你会重复 $T$ 次下述操作：每次，你会任选一件家具，然后将这件家具移动到任意一个其他房间中。每一轮有 $k(n-1)$ 种决策（选择家具的方案数乘以选择另一个房间的方案数），所以总共有 $k^T(n-1)^T$ 种决策。你需要计算这每一种决策后的摆放方式的得分之和。

不仅如此，我们会给出 $q$ 次询问，每次输入初始时的摆放方式与 $T$，你需要**在线地**回答 $k^T(n-1)^T$ 种决策后的得分之和（取模）。详见输入与输出格式。

我们如下定义一种摆放方式的编号：

我们将家具用 0 到 $k-1$ 的不同整数编号，房间用 $0$ 到 $n-1$ 的不同整数编号。设在某种摆放方式下，第 $i$ 号家具被放在了 $p_i$ 号房间中，则定义这种摆放方式的编号为 $\sum_{i=0}^{k-1} p_i n^i$。可以发现，所有的 $n^k$ 种摆放方式的编号恰好是 $0$ 到 $n^k -1$ 的不同整数。

另外，设 $P=998244353$。
## 输入格式

第一行输入三个正整数 $n, k, q$。

接下来 $n^k$ 行，每行输入一个小于 $P$ 的正整数，依次表示编号为 $0, 1, \dots, n^k - 1$ 的摆放方式的得分。

接下来 $q$ 行，每行输入两个非负整数。设某行的输入为 $a, b$（保证 $0 \leq a < n^k, 0 \leq b < P$），则此次询问的初始摆放方式的编号为 $a$，而 $T=b \cdot r \bmod P$，其中 $r$ 是你上一个输出的数（对于第一次询问为 $1$）。

同一行内输入的相邻两个数之间以一个空格隔开。

保证 $n \geq 2$，$k \geq 1$；$n^k \leq 10^6$；$q \leq 5 \times 10^5$
## 输出格式

对于每次询问输出一行，包含一个非负整数，表示该询问的得分之和对 $P$ 取模的结果。
## 样例

### 样例输入 #1
```
2 3 3
1
10
100
1000
998244245
100000
1000000
10000000
0 1
0 1
1 233
```
### 样例输出 #1
```
2
2202003
444957911
```
## 提示

#### 样例解释
第一次询问中，初始摆放方式的编号为 $0$，$T=1$。

初始时，$0$ 号家具放在 $0$ 号房间，$1$ 号家具放在 $0$ 号房间，$2$ 号家具放在 $0$ 号房间。经过 $1$ 次操作后，可能的情况有：

* 将 $0$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $1$，得分为 $10$；
* 将 $1$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $2$，得分为 $100$；
* 将 $2$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $4$，得分为 $998244245$。

所以，所有情况的总得分为 $998244355$，对 $P$ 取模后为 $2$。

第二次询问中，初始摆放方式的编号为 $0$，$T=2$。

初始时，$0$ 号家具放在 $0$ 号房间，$1$ 号家具放在 $0$ 号房间，$2$ 号家具放在 $0$ 号房间。经过 $2$ 次操作后，可能的情况有：

* 将 $0$ 号家具移动到 $1$ 号房间，然后将 $0$ 号家具移动到 $0$ 号房间，此后的摆放方式编号为 $0$，得分为 $1$；
* 将 $0$ 号家具移动到 $1$ 号房间，然后将 $1$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $3$，得分为 $1000$；
* 将 $0$ 号家具移动到 $1$ 号房间，然后将 $2$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $5$，得分为 $100000$；
* 将 $1$ 号家具移动到 $1$ 号房间，然后将 $0$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $3$，得分为 $1000$；
* 将 $1$ 号家具移动到 $1$ 号房间，然后将 $1$ 号家具移动到 $0$ 号房间，此后的摆放方式编号为 $0$，得分为 $1$；
* 将 $1$ 号家具移动到 $1$ 号房间，然后将 $2$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $6$，得分为 $1000000$；
* 将 $2$ 号家具移动到 $1$ 号房间，然后将 $0$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $5$，得分为 $100000$；
* 将 $2$ 号家具移动到 $1$ 号房间，然后将 $1$ 号家具移动到 $1$ 号房间，此后的摆放方式编号为 $6$，得分为 $1000000$；
* 将 $2$ 号家具移动到 $1$ 号房间，然后将 $2$ 号家具移动到 $0$ 号房间，此后的摆放方式编号为 $0$，得分为 $1$。

所以，所有情况的总得分为 $2202003$，对 $P$ 取模后为 $2202003$。

第三次询问中，初始摆放方式的编号为 $1$，$T=513066699$。初始时，$0$ 号家具放在 $1$ 号房间，$1$ 号家具放在 $0$ 号房间，$2$ 号家具放在 $0$ 号房间。

……（省略至少 $3^{513066699}$ 行）

#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2019。

题解等资源可在 https://github.com/wangyurzee7/THUPC2019 查看。


---

---
title: "[THUPC 2021 初赛] 非欧几何"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7138
tag: ['2021', 'THUPC']
---
# [THUPC 2021 初赛] 非欧几何
## 题目描述

ustze 喜欢几何，他认为几何是数学竞赛中最简单的一环，在征服了数学以后，ustze 决定将自己的天赋带到计算几何中，并与传统的欧氏几何展开较量。

作为欧氏几何的捍卫者，Tinytree 在三维空间中建立了一个**球心在原点、半径为** $\boldsymbol R$ **的球面**，其中坐标为 $(0,0,R)$ 的点称为北极点，显然北极点处于球面上。Tinytree 回忆在欧氏几何中，三点可以唯一确定空间中的一个圆，因此 Tinytree 在球面上确定了 $N$ 个点对，其中每个点对和北极点一起就确定了一个球面上的圆，我们保证这些圆的**半径严格小于** $\boldsymbol R$，因此每个圆会将球面分成面积不相等的两部分，我们**称球面上面积较小的部分是该圆的内部，面积较大的部分是该圆的外部**，而这 $N$ 个圆的内部受到 Tinytree 的保护，**它们的并构成安全区域**。

作为非欧几何的狂热者，ustze 认为球面上的圆其实是“直线”，他在球面上确定了 $M$ 个点对，其中每个点对和北极点一起也确定了一个球面上的圆，这些圆的**半径也是严格小于** $\boldsymbol R$ 的，这 $M$ 个圆的内部受到 ustze 的威慑，**它们的并构成危险区域**。

正当 Tinytree 和 ustze 对峙时，球面上一般路过一个 Kiana，她见到这幅景象十分害怕，开始在球面上东躲西藏。现在 Kiana 初步确定了 $T$ 个球面上的点，她想知道这些点是否在安全区域或危险区域中，以便自己跑路，由于 Kiana 自己不会算，所以希望你能够帮助她。
## 输入格式

第一行包含三个正整数 $N, M$ 和 $T$（$1 \le N, M \le 5000$，$1 \le T \le 1.5 \times {10}^5$），分别表示 Tinytree 确定的点对数、ustze 确定的点对数和 Kiana 确定的跑路点数。

第二行包含一个正整数 $R$（$1 \le R \le {10}^3$），表示球面的半径大小。

接下来 $N$ 行，第 $i$ 行依次输入 $A_i, B_i, X_i, C_i, D_i, Y_i$（$1 \le |A_i|, |B_i|, |C_i|, |D_i| \le R$，$1 \le A_i^2 + B_i^2, C_i^2 + D_i^2 \le R^2$），其中 $A_i, B_i$ 表示 Tinytree 确定的第 $i$ 个点对中第一个点的横坐标和纵坐标，而 $X_i$ 为 `+` 表示第一个点的竖坐标大于 $0$，为 `-` 表示第一个点的竖坐标小于 $0$，如果竖坐标等于 $0$ 则 $X_i$ 是在 `+` 和 `-` 中随机选择的，$C_i, D_i$ 表示 Tinytree 确定的第 $i$ 个点对中第二个点的横坐标和纵坐标，$Y_i$ 表示竖坐标的正负，含义与 $X_i$ 相同。

接下来 $M$ 行，第 $j$ 行依次输入 $A_j, B_j, X_j, C_j, D_j, Y_j$（$1 \le |A_j|, |B_j|, |C_j|, |D_j| \le R$，$1 \le A_j^2 + B_j^2, C_j^2 + D_j^2 \le R^2$），表示 ustze 确定的第 $j$ 个点对坐标，点的表示方式与之前相同。

接下来 $T$ 行，第 $k$ 行包含两个实数 $A_k, B_k$（$1 \le |A_k|, |B_k| \le R$，$1 \le A_k^2 + B_k^2 \le R^2$）和一个字符 $X_k$，表示 Kiana 确定的第 $k$ 个跑路点，点的表示方式与之前相同。

数据保证合法，且输入中没有两个点是相同的，所有实数保留到小数点后三位，**Kiana 的跑路点和任意一个给定圆周的最小直线距离不小于** $\boldsymbol{{10}^{-6}}$。
## 输出格式

输出共 $T$ 行，每行包含一个字符串，若 Kiana 的第 $k$ 个跑路点在安全区域中则在第 $k$ 行输出 `Safe`，如果不在安全区域中但也不在危险区域中则在第 $k$ 行输出 `Passer`，如果不在安全区域中且在危险区域中则在第 $k$ 行输出 `Goodbye`（所有输出不含引号）。
## 样例

### 样例输入 #1
```
2 2 4
3
2.571 0.514 + 2.571 -0.514 +
-2.571 0.514 + -2.571 -0.514 +
0.514 2.571 + -0.514 2.571 +
0.514 -2.571 + -0.514 -2.571 +
2.118 -2.118 -
1.051 1.051 +
-0.468 1.870 +
-1.870 -0.468 +

```
### 样例输出 #1
```
Passer
Safe
Goodbye
Safe

```
## 提示

在三维空间中，我们可以用一个有序的实数三元组 $(x, y, z)$ 来描述一个点的位置，其中 $x, y, z$ 分别称作这个点的横坐标、纵坐标和竖坐标。

三维空间中一个球心在 $(x_0, y_0, z_0)$、半径为 $R$ 的球面是指空间中所有满足 $(x - x_0)^2 + (y - y_0)^2 + (z - z_0)^2 = R^2$ 的点 $(x, y, z)$ 构成的点集，对于该球面上给定的两个不同点 $(x_1, y_1, z_1), (x_2, y_2, z_2)$，如果它们不是一对对踵点（两个点是对踵点当且仅当它们之间的距离为 $2 R$），则它们和球心不在同一直线上，这三个点唯一确定了一个平面，这个平面与球面的交线被这两个点分成了两个部分，其中较短部分的长度称为这两点在该球面上的距离，如果这两个点是对踵点，则定义它们之间的距离为 $\pi R$，球面上的一个圆指到球面上某点的球面距离等于一个常数的球面上的点的集合，可以证明球面上的任意三个不同点唯一确定了一个球面上的圆。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2021-pre> 查看。


---

---
title: "[THUPC 2017] 老司机"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7433
tag: ['2017', '快速傅里叶变换 FFT', '快速数论变换 NTT', 'THUPC']
---
# [THUPC 2017] 老司机
## 题目描述

四环路上行人稀，常有车神较高低。

如今车道依旧在，不见当年老司机。

B 君心情不好的时候，喜欢去四环路上飙车。看着窗外飞驰而过的景色，B 君想到了过去的 R 君和 G 君；想到了现在的 YJQ 和 FLZ；想到了宇宙之浩渺，时空之无限；也想到了这道题。

输入 $n,X,Y,Z$，保证 $X$ 是 $2$ 的整数次幂，$Y$ 是 $3$ 的整数次幂，$Z$ 是 $5$ 的整数次幂，同时 $1\le n\le 1000,1\le X\times Y\times Z\le2000$。

输入四个长度为 $n$ 的数组 $\{a_i\},\{b_i\},\{c_i\},\{r_i\}$（$0\le a_i,b_i,c_i,r_i\le10^9$）。

对于 $(u,v,w)$ 求有多少组解 $\{x_i\},\{y_i\},\{z_i\}$。

满足对于所有的 $i$，有 $a_i\le x_i,b_i\le y_i,c_i\le z_i,r_i\ge x_i-a_i+y_i-b_i+z_i-c_i$。

并且
$$(\sum_{i=1}^nx_i)\bmod X=u$$
$$(\sum_{i=1}^ny_i)\bmod Y=v$$
$$(\sum_{i=1}^nz_i)\bmod Z=w$$

设解的个数为 $F(u,v,w)$。

输出
$$\operatorname*{xor}_{0\le u< X,0\le v<Y,0\le w<Z}((uYZ+vZ+w)\times(F(u,v,w)\bmod466560001))$$

## 输入格式

输入第一行 $n,X,Y,Z$。

接下来 $n$ 行，第 $i$ 行四个整数 $a_i,b_i,c_i,r_i$。
## 输出格式

一行一个整数表示答案。
## 样例

### 样例输入 #1
```
3 2 3 1
0 0 0 1
0 0 0 2
0 0 0 3
```
### 样例输出 #1
```
573
```
### 样例输入 #2
```
3 2 3 5
0 0 0 1
0 0 0 2
0 0 0 3
```
### 样例输出 #2
```
253
```
## 提示

#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。


---

---
title: "[THUPC 2021] 区间本质不同逆序对"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7601
tag: ['2021', 'O2优化', 'THUPC']
---
# [THUPC 2021] 区间本质不同逆序对
## 题目描述

给定一个长为 $n$ 的序列 $a$。

有 $m$ 次询问，每次询问给定一个区间 $[l,r]$，求 $|{(a_i,a_j) : l\le i<j\le r \wedge a_i>a_j}|$。

$1\le n\le 10^5$，$1\le m\le 5\times 10^5$。

## 输入格式


第一行一个正整数 $n$。

第二行 $n$ 个正整数，其中第 $i$ 个数 $a_i$ 表示序列第 $i$ 个位置的值，保证 $1\leq a_i \leq n$。

第三行一个正整数 $m$。

之后 $m$ 行，每行用两个空格隔开的正整数，分别表示 $l,r$，表示一次询问，保证 $1\leq l\le r \leq n$。
## 输出格式

输出 $m$ 行，第 $i$ 行输出一行一个整数，表示第 $i$ 次询问的答案。
## 样例

### 样例输入 #1
```
5
2 1 3 2 1
4
2 4
1 5
3 5
2 2
```
### 样例输出 #1
```
1
3
3
0
```
## 提示

**【样例解释】**

对于第一次询问，集合为 $\{(3,2)\}$。

对于第二次与第三次询问，集合为 $\{(2,1),(3,1),(3,2)\}$。

对于第四次询问，集合为空集。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_0/tree/master](https://github.com/yylidiw/thupc_0/tree/master) 查看。


---

---
title: "[THUPC 2021] 星星"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7612
tag: ['2021', 'O2优化', 'THUPC']
---
# [THUPC 2021] 星星
## 题目背景

**往寻奥之星辰** ——镜（于建安七年（A.D. 0202））

> “某年月日，有挚友二人，曰镜曰奥，求索星辰之秘。初苦无所用，次苦无所得。后逢乱，奥迁于外，亦不知所踪矣。区区之身亦可望天命耶，固其情可叹矣。余撰此文以叙之。”
> ——《荧惑记<序>》

宇宙纪元 1024 太阳年第 256 地球日，于斯特罗法斯星系，“赫希萨基”小行星矿区，“吉伽克”号高级采矿船。

库洛船长本来在阅读几千年前所书写的《荧惑记》，这被考证是人类第一次对于星空的正式的有其科学目的观察记录，可是系统里一阵急促的报警声打扰了他。

“副牵引仓隔离罩人为损坏”船员在系统损管备注里写道，“我们可爱的公主柯娜达又拉来了一块巨大的石头把隔离罩磕坏了，还说要送给马卡那小子”

柯娜达是船长的女儿，马卡是大副的公子，大概还算得上是青梅竹马吧。

库洛船长又开始头痛了，这已经是第三次了，维修科上次就警告过没有多余的当前型号的隔离罩了。

“您还是不要责怪可爱的柯娜达了，”维修科的队长表示，“不过倒可以尝试用那些不能旋转的做一个替代出来，可我算不清楚要开多大的孔。”

作为主脑数据组的一员，库洛船长请你帮助维修科计算一下至少要开多大的孔。
## 题目描述

隔离罩是用来尽量防止其他宇宙射线对于扫描仪（不是牵引器！）的损坏的重要部件。

简单的，我们可以把切割前的隔离罩看成一个单位球面如下图所示：

工作计划上要完成 $N$（$1 \le N \le {10}^6$）次观测任务。

对于第 $i$ 观测次，我们从点 $(0,0)$ 出发，扫描位于点 $(x_i,y_i,z_i)$，半径为 $r_i$（$-{10}^6 < x_i,y_i < {10}^6$，$0 < r_i < z_i < {10}^6$）的陨石。  
这里我们可以简单的将陨石认为成一个圆球体。

每次观测我们都要保证我们可以通过防护罩上开的洞扫描陨石的全貌。

现在请你计算我们将要开的防护罩上的圆洞在球面上的半径（大圆弧长），即所有陨石球在上半单位球投影的并的最小覆盖圆（这里的圆是在曲面上的）。

由于是单位球，所以这个数值应该等于该圆洞直径上两点与球心连线所呈平面角角度的一半。

显然的，这个角度小于 $\frac{\pi}{2}$ 大于 $0$。若角度为 $\omega$ rad 请你输出 $\frac{\omega}{\pi/2} \times {10}^5$ 并向下取整。
## 输入格式

第一行一个整数 $N$，代表后面有 $N$ 个观测计划。

之后每行四个整数，以空格分割，依序分别为 $x_i,y_i,z_i,r_i$。
## 输出格式

输出一个范围在 $[0, 99999]$ 的整数。
## 样例

### 样例输入 #1
```
5
30 10 10 9
100 -10 100 50
-30 100 50 30
12 42 64 20
287 123 46 31

```
### 样例输出 #1
```
67877

```
## 提示

**【样例解释】**

下图是各个小行星投影至防护罩的圆和最后挖出来圆洞的示意图。

![](https://cdn.luogu.com.cn/upload/image_hosting/tdi9z9kx.png)

**【提示】**

- 这并不是一道计算机图形学题目。
- 背景故事中所有人物、时间、事件、文字均为虚构。
- 输入较大，建议使用更好的读入输出方式。
- 请尽可能地利用您的代数知识。

**【题目来源】**

来自 2021 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2021）。

题解等资源可在 [https://github.com/yylidiw/thupc_2/tree/master](https://github.com/yylidiw/thupc_2/tree/master) 查看。


---

---
title: "[THUPC 2022 决赛] pmrmscxip"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8415
tag: ['2022', 'O2优化', 'THUPC']
---
# [THUPC 2022 决赛] pmrmscxip
## 题目描述

给序列 $a_1,\dots,a_n$ 和排列 $b_1,\dots,b_n$，共有 $m$ 次操作：

修改操作：给定 $x,y$，将 $a_x$ 改为 $y$；

查询操作：给定 $l,r,x$，查区间 $[l,r]$ 内最长的子区间 $[l',r']$（即满足 $l\le l'\le r'\le r$），使得对 $l'\le i<r'$ 有 $a_{i+1}=b_{a_i}$，且存在 $l'\le i\le r'$ 使得 $a_i=x$。需要输出满足条件的 $r'-l'+1$ 的最大值，若不存在则输出 $0$。

## 输入格式

第一行两个整数 $n,m$；

第二行 $n$ 个整数依次表示 $a_1,\dots,a_n$；

第三行 $n$ 个整数依次表示 $b_1,\dots,b_n$；

接下来 $m$ 行，每行 $1,x,y$ 或 $2,l,r,x$ 表示进行一次修改操作或查询操作。

输入的所有数值为整数。
## 输出格式

对每个查询操作，输出一行，表示相应的答案。
## 样例

### 样例输入 #1
```
8 10
1 4 7 3 8 2 4 7
5 4 8 7 1 6 3 2
2 6 6 2
2 8 8 7
1 4 3
2 6 8 3
2 4 4 3
2 4 4 3
2 6 8 4
2 5 6 2
2 1 8 1
2 1 1 6

```
### 样例输出 #1
```
1
1
0
1
1
3
2
1
0

```
## 提示

$1\le n,m\le 10^6$；

$1\le a_i\le n$；

$1\le b_i\le n$，$b_i$ 互不相同；

对修改操作，满足 $1\le x,y\le n$；

对查询操作，满足 $1\le l\le r\le n$，$1\le x\le n$。


---

---
title: "[THUPC 2022 决赛] 拯救还是毁灭"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8416
tag: ['贪心', '2022', 'Special Judge', 'O2优化', '构造', 'THUPC']
---
# [THUPC 2022 决赛] 拯救还是毁灭
## 题目描述

*有人说，它拯救了世界；也有人说，它毁灭了世界。*

这个世界危在旦夕！秩序已然一片混乱。

秩序可以抽象成一个 $n\times n$ 的矩阵，矩阵中是一个 $1\sim n^2$ 的排列。你想要拯救世界，于是请来了神，来帮忙把秩序恢复原状。然而神也不是万能的，它只能做到交换矩阵中同一行或者同一列中的两个数。而且，它并不知道要怎么交换才能复原，得听你的指导。

幸好，你不一定需要在最少的交换次数之内完成复原。你只需要不比最糟糕的情况差就好。也就是说，如果你的交换次数为 $k$，且对于所有 $1\sim n^2$ 的排列，最小交换次数的最大值为 $k_0$，你只需要满足 $k\le k_0$。

注：复原指的是将矩阵变为如下的一个矩阵：

$\begin{matrix} 1 & 2 & 3 & \cdots & n \\ n+1 & n+2 & n+3 & \cdots & 2n \\ 2n+1 & 2n+2 & 2n+3 & \cdots & 3n\\ \vdots & \vdots & \vdots & \ddots & \vdots \\ (n-1)n+1 & (n-1)n+2 & (n-1)n+3 & \cdots & n^2 \end{matrix}$
## 输入格式

接下来 $n$ 行，每行 $n$ 个正整数，表示这个 $n\times n$ 的矩阵。保证 $1\sim n^2$ 中的每个数恰好出现一次。
## 输出格式

第一行一个非负整数 $k$，表示你的交换次数。

接下来 $k$ 行，每行四个正整数 $x_1,y_1,x_2,y_2$，表示将第 $x_1$ 行 $y_1$ 列的数与第 $x_2$ 行 $y_2$ 列的数交换。

你需要保证 $x_1=x_2$ 或 $y_1=y_2$。
## 样例

### 样例输入 #1
```
2
4 2
3 1

```
### 样例输出 #1
```
3
1 1 1 2
1 2 2 2
1 1 1 2

```
### 样例输入 #2
```
2
2 1
3 4

```
### 样例输出 #2
```
3
2 1 2 2
1 1 1 2
2 1 2 2

```
### 样例输入 #3
```
2
3 2
1 4

```
### 样例输出 #3
```
2
1 1 1 1
1 1 2 1

```
### 样例输入 #4
```
2
1 2
3 4

```
### 样例输出 #4
```
0

```
## 提示

【样例 1 解释】

可以证明这是交换次数最少的方案之一，显然它符合条件。

【样例 2 解释】

对于这个输入来说，这个样例输出的方案不是交换次数最少的方案，但是我们知道存在一个 $1\sim n^2$ 的排列（即上一个样例）需要至少 $3$ 次的交换，所以这个方案也是可行的。

【样例 3 解释】

我们允许出现 $(x_1,y_1)=(x_2,y_2)$ 的情况。

【样例 4 解释】

注意 $k$ 可以等于 $0$。

【数据范围与约定】

保证 $1\le n\le 1000$。

保证输入的矩阵中 $1\sim n^2$ 恰好各出现一次。


---

---
title: "[THUPC 2022 决赛] 高性能计算导论集群登录密码复杂性策略"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8417
tag: ['2022', 'O2优化', 'THUPC']
---
# [THUPC 2022 决赛] 高性能计算导论集群登录密码复杂性策略
## 题目背景

高性能计算导论是 T 大学 C 系开设的一门专业选修课。这门课程讲述了高性能计算的基本概念和原理，常见并行编程模型及并行程序的基本编写思路，程序性能分析和优化的基本方法，以及计算机体系结构和程序性能的关系。为了让同学们能够实际体验并行程序的编写、性能分析和优化，课程为同学们提供了五台服务器组成的集群，每台服务器上都配置了 2 socket × 14 core 的处理器和 1 块 GPU。选课的同学可以在集群上进行基于消息传递的并行编程、基于共享内存模型的并行编程和 CUDA 编程。为了防止宝贵的计算资源被滥用（比如偷偷用服务器挖矿），课程在集群使用上有很多的规定，其中就包括要求选课同学使用高强度的集群登录密码。
## 题目描述

为了确保选课同学使用了较强的集群登录密码，课程组在集群上配置了密码复杂性策略。所有选课的同学在学期初会收到随机生成的初始密码。在使用初始密码登录集群后，集群会要求同学输入新的密码，密码更改完毕后才能正常访问集群。在本题中，我们假设密码复杂性策略为：

- 密码至少包含 $L$ 个字符，且至少包含一个数字和一个字母；

- 密码不能包含**连续** $A$ 个**重复**字符，如 `2333` 包含了连续 3 个重复字符；

- 密码不能包含**连续** $B$ 个字符组成的上升序列或下降序列，其中定义上升序列为 `0123456789`，`ABCDEFGHIJKLMNOPQRSTUVWXYZ` 和 `abcdefghijklmnopqrstuvwxyz` 三个字符串中某一个串的**连续**子串，下降序列为这三个字符串中某一个串的**连续**子串的反向串，例如： 
  
  - `6789` 是长度为 4 的上升序列，`FED` 是长度为 3 的下降序列；
  
  - `90`、`AZ`、`az` 不是上升序列或下降序列；
  
  - `GPU` 不是上升序列，因为它不连续；
  
  - `Def` 不是上升序列，因为字母大小写不一致（但它包含长度为 2 的上升连续子序列 `ef`）；
  
  - `1112345678999` 不是上升序列，但它的子序列 `123456789` 是上升的。

假设密码仅由数字及大小写字母构成。求在长度不超过 $R$ 的所有密码中，有多少个密码满足密码复杂性策略。
## 输入格式

输入仅一行，包括四个正整数 $L, R, A, B$，含义如题目描述中所述。
## 输出格式

输出一个非负整数，表示满足密码复杂性策略且长度不超过 $R$ 的密码数量对 $1,000,000,007$ 取模的结果。

## 样例

### 样例输入 #1
```
2 2 2 2

```
### 样例输出 #1
```
1040

```
### 样例输入 #2
```
12 24 3 4

```
### 样例输出 #2
```
718185656

```
### 样例输入 #3
```
100 10000000 6 6

```
### 样例输出 #3
```
146399052

```
## 提示

【样例 1 解释】

因为密码必须至少包含一个数字和一个字母，所以满足要求的密码有 $2\times 10 \times (26\times 2) = 1040$ 种。

【数据范围与约定】


保证 $1\le L\le R\le 10^9$，$2\le A\le 6$，$2\le B\le 26$。

【提示】

如果你不想记住又长又复杂的密码，不想每次登录时手动输入密码，也可以配置公钥进行 SSH 登录。


---

---
title: "[THUPC 2022 决赛] riapq"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8419
tag: ['2022', 'O2优化', 'THUPC']
---
# [THUPC 2022 决赛] riapq
## 题目描述

给出排列 $a_1,\dots,a_n$，你需要维护序列 $b_1,\dots,b_n$，初值为0。

共 $m$ 次操作：

修改操作：给出 $l,r$，对每个 $(i,j)$ 满足 $l\le i\le j\le r,\;a_i\le a_j$，将 $b_j$ 增加1；

查询操作：给出 $x$，查 $b_x$。
## 输入格式

第一行两个整数 $n,m$；

第二行 $n$ 个整数依次表示 $a_1,\dots,a_n$；

接下来 $m$ 行，每行 $1,l,r$ 或 $2,x$ 表示修改操作或查询操作。

输入的所有数值为整数。
## 输出格式

对每个查询操作，输出一行，包含一个整数，表示答案。
## 样例

### 样例输入 #1
```
8 10
5 4 8 7 1 6 3 2
1 2 5
2 8
1 2 8
1 7 8
2 4
2 1
2 6
2 4
1 8 8
2 4

```
### 样例输出 #1
```
0
4
0
3
4
4

```
## 提示

$1\le n,m\le 2\times 10^5$；

$1\le a_i\le n$，$a_i$ 互不相同；

$1\le l\le r\le n$；

$1\le x\le n$。


---

---
title: "[THUPC 2022 决赛] rsraogps"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8421
tag: ['2022', 'O2优化', 'THUPC']
---
# [THUPC 2022 决赛] rsraogps
## 题目描述

给序列 $a_1,\dots,a_n$，$b_1,\dots,b_n$，$c_1,\dots,c_n$，

定义区间 $[l,r]$ 的价值为 $a_l,\dots,a_r$ 按位与，$b_l,\dots,b_r$ 按位或，$c_l,\dots,c_r$ 的最大公因数，这三者的乘积；

$m$ 次查询，每次查询给出区间 $[l,r]$，查询满足 $l\le l'\le r'\le r$ 的 $[l',r']$ 的价值之和。
## 输入格式

第一行两个整数 $n,m$；

第二行 $n$ 个整数 $a_1,\dots,a_n$；

第三行 $n$ 个整数 $b_1,\dots,b_n$；

第四行 $n$ 个整数 $c_1,\dots,c_n$；

接下来 $m$ 行，每行两个整数 $l,r$ 表示一次查询。

## 输出格式

共 $m$ 行，每行一个整数，表示对应的答案，答案对 $2^{32}$ 取模后输出。

## 样例

### 样例输入 #1
```
5 3
3 3 1 1 1
2 1 3 2 2
4 5 3 4 4
1 2
2 5
4 5

```
### 样例输出 #1
```
48
63
24

```
## 提示


$1\le n\le 10^6$

$1\le m\le 5\times 10^6$

$1\le a_i,b_i,c_i\le n$

$1\le l\le r\le n$

建议使用高效的输入输出方式。



---

---
title: "[THUPC 2023 初赛] 种苹果"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9136
tag: ['2023', 'O2优化', '分块', 'THUPC']
---
# [THUPC 2023 初赛] 种苹果
## 题目描述

农夫种了一棵苹果树，树上结满了大大小小的苹果。夏天正是果树生长发育的大好时节，树上不断抽出新的枝条、结出新的苹果，已有的苹果也在不断长大。

为了观察和记录苹果的生长状况，以便对未来收获的行情有大致的估计，农夫进行了长时间仔细的观察和研究。在整个记录周期的最开始，树上一共结有 $n$ 个苹果，农夫将其编号为 $1\sim n$ ，有 $n-1$ 条树枝连接这些苹果，每条树枝的两端都恰好挂有一个苹果，使得整个苹果树成为一个名副其实的树形结构。农夫对每个苹果进行了一番价值估计，第 $i$ 个苹果的初始价值为 $a_i$ ，表示农夫此时摘下它并卖出的净收益，考虑到成本因素， $a_i$ 可能为负。

在整个记录周期中，共发生了 $m$ 件值得记录的事件，所有的事件共分为以下几种类型：

$1\ u\ v\ w$：树上原本连接苹果 $u$ 和苹果 $v$ 的树枝中间结出了一个新的苹果。设原先树上共有 $k$ 个苹果，则此时变为 $k+1$ 个，农夫将新长出的苹果编号为 $k+1$ ，其价值为 $w$ 。原先连接苹果 $u$ 和 $v$ 的树枝也因此分裂成两条，一条连接苹果 $u$ 和 $k+1$ ，另一条连接苹果 $k+1$ 和 $v$；

$2\ u\ w$：树上长出了一条新树枝和一个新苹果。设原先树上共有 $k$ 个苹果，则此时变为 $k+1$ 个，农夫将新长出的苹果编号为 $k+1$，其价值为 $w$。新树枝连接苹果 $u$ 和 $k+1$。

$3\ u\ v\ w$：树上一部分苹果的价值发生了变化。树上连接苹果 $u$ 和 $v$ 的一整段枝条（即树形结构上连接 $u$ 和 $v$ 的最短路径，包括 $u$ 和 $v$ 本身）上的所有苹果的价值均增加了 $w$ 。考虑到价值的变化也可能是由于营养不足或病虫害引起的，因此 $w$ 可能为负。

$4\ u\ v\ w$：农夫想在树上进行一次抽样调查来研究自己的可能收益。他定义价值不小于 $w$ 的苹果为“优质苹果”，并选择了树上连接苹果 $u$ 和 $v$ 的一整段枝条（含义同上），想统计一下这段枝条上的苹果中有多少个“优质苹果”。

但由于苹果的数量是在太多了，农夫数不过来，便只好请你来帮忙。注意：由于农夫不能预测未来，因此你帮农夫时必须**强制在线**地回答问题。
## 输入格式

第 $1$ 行： $2$ 个正整数 $n,m$。

第 $2$ 行： $n$ 个整数 $a_i$。

接下来 $n-1$ 行：每行两个正整数 $u_i,v_i$，依次描述初始时树上的所有树枝。

接下来 $m$ 行，每行 $3$ 或 $4$ 个整数，按照时间顺序描述所有的事件，格式如题目描述中所述。

为了体现强制在线性，设上一次 $4$ 事件的答案是 $lastans$ （最开始时 $lastans=0$），则所有事件中输入的 $u,v,w$ 都需要异或上 $lastans$ 才是真正的 $u,v,w$。
## 输出格式

对于每个 $4$ 事件输出一行，一个非负整数，表示农夫此次调查的“优质苹果”数量。
## 样例

### 样例输入 #1
```
5 6
1 3 3 2 2
1 2
1 3
2 4
2 5
4 3 4 2
3 2 6 2
4 0 7 1
1 5 6 1
2 2 7
4 0 3 0

```
### 样例输出 #1
```
3
4
2

```
## 提示

#### 样例解释 1

对于这组样例，去除强制在线后的数据如下：

```
5 6
1 3 3 2 2
1 2
1 3
2 4
2 5
4 3 4 2
3 1 5 1
4 3 4 2
1 1 2 5
2 6 3
4 4 7 4
```

#### 数据范围

对于所有数据， $n,m \leq 2 \times 10^5$，$|a_i|, |w|\leq 10^9$，保证任意时刻涉及到的苹果编号均有意义，保证初始的 $n-1$ 条树枝构成树形结构，所有 $1$ 事件保证连接苹果 $u$ 和 $v$ 的树枝在事件发生时存在。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。


---

---
title: "[THUPC 2023 初赛] 喵了个喵 II"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9139
tag: ['2023', 'Special Judge', 'O2优化', '2-SAT', '可持久化线段树', '构造', 'THUPC']
---
# [THUPC 2023 初赛] 喵了个喵 II
## 题目背景

本来这题的题面和《喵了个喵》有关的。但是听说有人嫌题面长，就少说点好了。
## 题目描述

给定一个长为 $4n$ 的序列，其中 $1\sim n$ 各出现 $4$ 次。问是否能够将其划分为两个相等的子序列。
## 输入格式

第一行一个正整数 $n$。

第二行 $4n$ 个正整数，表示序列。保证 $1\sim n$ 各出现 $4$ 次。
## 输出格式

如果不能划分为两个相等的子序列，输出一行 `No`。

否则第一行输出 `Yes`。第二行输出一个长为 $4n$ 的 `01` 串。其中第 $i$ 位表示原序列的第 $i$ 个数被划分到第几个子序列。你需要保证你划分出来的两个子序列完全相等。
## 样例

### 样例输入 #1
```
2
1 1 2 1 2 2 1 2
```
### 样例输出 #1
```
Yes
10000111

```
## 提示

#### 样例解释 1

两个子序列均为 $(1,2,1,2)$。

#### 子任务

保证 $1\le n \le 5\times10^4$。

保证序列中 $1\sim n$ 各出现 $4$ 次。

#### 评分方式

你的输出的第一行需要与标准答案一致。若为 `Yes`，输出任意一种合法的划分均算正确。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。

By E.Space：由于考场上数据太弱，我于 3.12 和 3.19 两度加强了数据。


---

---
title: "[THUPC 2023 初赛] 乱西星上的空战"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9141
tag: ['模拟', '计算几何', '2023', 'O2优化', 'THUPC']
---
# [THUPC 2023 初赛] 乱西星上的空战
## 题目背景

众所周知，在乱西星的现代战争中，制空权是很重要的。为此，人们发展出了无人机技术——遗憾的是，由于乱西星的算法水平和各种意义上的通讯水平实在太落后了，所以这些无人机只能采用各自独立的傻瓜式战斗模式，这些模式不含任何随机因素，因此一场傻瓜式无人机空战总是几乎能在开始前就被预测到结果。

总而言之，乱西星上正在相互战争的 |\\| 国和 () 国的傻瓜式无人机战斗机编队在其边境交界处的空域遭遇了，现在两国军方希望你能预测这一空战的结果。
## 题目描述

### 空域与时刻

由于乱西星的神秘物理法则，乱西星的时间和空间并不是连续的；若认为遭遇战开始的时刻是第 $1$ 时刻，那么对于任意的第 $k\in \N$ 个时刻，在这一时刻开始和结束时，一个物体（无人机或导弹）只能在形如 $(x,y,z)\in\mathbb Z^3$ 的位置（即空域内的整点）上。

### 无人机

由于空域相比无人机要大得多，因此我们可以将无人机视为一个质点（尽管他们实际上长得和地球上的一般意义上的飞机十分相似）。

#### 飞行状态

在每个时刻，一架无人机的飞行状态可以用以下三组参数描述：

1. 当前时刻所在的坐标 $\vec p=(x,y,z)\in\mathbb Z^3$；
2. 当前时刻的飞行方向向量 $\vec{d},\|\vec d\|=1$；
   - 其中， $\|\vec{v}\|$ 表示向量 $\vec v$ 的长度：设 $\vec{v}=(v_x,v_y,v_z)$，则 $\|\vec{v}\|=\sqrt{v_x^2+v_y^2+v_z^2}$。
   - 你可以简单地将 $\vec d$ 理解为机头指向的方向。
3. 当前时刻的无人机升力线方向 $\vec u,\|\vec u\|=1,\vec u\bot \vec d$；
   - 你可以简单的将 $\vec u$ 理解为飞机所在平面的、从机腹指向机背的单位法向量。
   - 此时，$\vec d$ 和 $\vec u$ 可以唯一确定一个“左手向” $\vec l=\vec u\times \vec d$。

#### 飞行性能

不严格地讲，一般而言，一架飞机通常有三个操作轴，即俯仰、滚转和偏航：俯(负杆)和仰(正杆)分别对应飞机机头向下和向上（即保持 $\vec l$ 不变）；滚转即飞机以飞行方向为中轴线旋转（即保持 $\vec d$ 不变）；偏航则为飞机机头向左或者向右（即保持 $\vec u$ 不变）。由于无人机的特殊设计，其**没有偏航**轴，只能进行俯仰和滚转——容易看出，即使仅进行俯仰和滚转，一架无人机也能随意地改变 $\vec d$ 和 $\vec u$ （在保持 $\|\vec u\|=\|\vec d\|=1,\vec u\bot \vec d$ 的前提下）。

以上的俯仰(正杆或负杆)、滚转操作，以及直线飞行，及其复合统称“机动”。

由于无人机型号差异，一架无人机的飞行性能可以用以下三组参数描述（为方便起见，在本节中，对进行一次机动前的飞行状态对应参数为 $\vec p=(x,y,z),\vec d,\vec u,\vec l$，进行一次机动后的飞行状态对应的参数为 $\vec p'=(x',y',z'),\vec d',\vec u',\vec l'$）：

1. 正杆率 $\theta_u\in(\dfrac\pi4,\dfrac\pi2)$ 和负杆率 $\theta_d\in(\dfrac\pi4,\dfrac \pi2)$；
   - 若无人机**仅进行正杆**机动，则必须有 $\vec p=\vec p',\vec l=\vec l',\vec u\cdot \vec d'\ge 0$；此时，进行一次这样的机动花费的时间是 $\dfrac{\angle(\vec d,\vec d')}{\theta_u}$。
   - 若无人机**仅进行负杆**机动，则必须有 $\vec p=\vec p',\vec l=\vec l',\vec u\cdot \vec d'\le 0$；此时，进行一次这样的机动花费的时间是 $\dfrac{\angle(\vec d,\vec d')}{\theta_d}$。
2. 滚转率 $\gamma\in(\dfrac\pi4,\dfrac \pi 2)$；
   - 若无人机**仅进行滚转**机动，则必须有 $\vec p=\vec p',\vec d=\vec d'$；此时，进行一次这样的机动花费的时间是 $\dfrac{\angle(\vec u,\vec u')}{\gamma}$。
3. 飞行极速 $v_{m}>0$；
   - 若无人机**仅进行直线飞行**，则必须有 $\vec d=\vec d',\vec u=\vec u'$；此时，花费的时间是 $\dfrac{\|\vec p'-\vec p\|}{v_m}$。

#### 合法位移

在每个时刻，若一架无人机可以从 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 这一飞行状态，严格按照**滚转**、**俯仰**(正杆或负杆)和**直线飞行**的顺序进行机动，使飞行状态变为 $\vec p'=(x',y',z')\not=\vec p,\vec d',\vec u',\vec l'$，满足 $\vec d'//(\vec p'-\vec p)$，并且各机动花费的时间之和不超过 $1$，则称这是一次(无人机的)合法的综合机动。

如果一架无人机可以从 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 通过一次合法的综合机动，使飞行状态变为 $\vec p'=(x',y',z')\not=\vec p,\vec d',\vec u',\vec l'$，并且在所有使飞行状态变为 $\vec p''=\vec p',\vec d'',\vec u'',\vec l''$ 的合法综合机动中，总用时是最短的，则称之为一次（无人机的）合法位移（或称该位移合法）。此时，无人机会沿直线从 $\vec p$ 移动到 $\vec p'$。如无特殊指明，下文中“位移”均默认(应当为)合法位移。

#### 眼镜蛇机动

在每个时刻，无论无人机飞行性能如何，无人机总是可以通过眼镜蛇机动，从 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 这一飞行状态，变为 $\vec p'=\vec p,\vec d'=\vec u,\vec u'=-\vec d,\vec l'=\vec l$ 这一飞行状态。注意，这种机动不被视为合法机动。

#### 其它参数

除此之外，一架无人机还具有以下参数：

1. 无人机编号（简称“编号”）；
   - 保证任意两架无人机编号不同。
2. 所在阵营（简称“阵营”）；
   - 所在阵营必须是|\\| 国或者是 () 国中之一，并且双方互称敌方阵营。

#### 坠毁

一架无人机坠毁，当且仅当其符合下列条件之一：

1. 在某激活的导弹位移过程中，与该导弹的距离不大于导弹的空爆距离（详见下文）。
2. 在某导弹位移结束后，与该导弹位置重合（从而导弹直接命中无人机导致坠毁，下同）。
3. 在无人机位移过程中，存在至少一枚激活的导弹，与其距离不大于该导弹的空爆距离。
4. 在无人机位移结束后，存在至少一枚导弹所在位置与其位置重合。
5. 在无人机位移结束后，存在另一架无人机与其坐标相同（从而发生碰撞导致双双坠毁）。

无人机坠毁后将立即消失，此后不会发射导弹，也不会导致其它无人机坠毁。但无人机已经发射的导弹不会立刻消失或爆炸。

此时也称无人机被摧毁。

### 空空红外制导导弹

类似的，一枚空空红外制导导弹（下文简称“导弹”）也可视为一质点，并且同样可以描述其飞行状态和飞行性能。

#### 飞行状态

由于导弹无所谓上下左右，因此仅需要以下两组参数以描述一个导弹的飞行状态：

1. 当前时刻所在的坐标 $\vec p=(x,y,z)\in\Z^3$；
2. 当前时刻的飞行方向向量 $\vec{d},\|\vec d\|=1$；
   - 你可以简单地将 $\vec d$ 理解为导弹弹头指向的方向。

#### 飞行性能

同样由于一枚导弹无所谓上下左右，因此其不存在俯仰、滚转和偏航轴，其向各个方向改变 $\vec d$ 的性能是相同的，此时统称仅改变 $\vec d$ 的操作为 "偏航"。其与直线飞行及复合统称“机动”。

因此一枚导弹的飞行性能可以用以下两组参数描述（为方便起见，在本节中，对进行一次机动前的飞行状态对应参数为 $\vec p=(x,y,z),\vec d$，进行一次机动后的飞行状态对应的参数为 $\vec p'=(x',y',z'),\vec d'$）：

1. 偏航率 $\theta_r\in(\dfrac\pi4,\dfrac\pi2)$；
   - 若导弹**仅进行偏航**机动，则必须有 $\vec p=\vec p'$；此时，进行一次这样的机动花费的时间是 $\dfrac{\angle(\vec d,\vec d')}{\theta_r}$；
2. 飞行极速 $v_m>0$；
   - 若导弹**仅进行直线飞行**，则必须有 $\vec d=\vec d'$；此时，花费的时间是 $\dfrac{\|\vec p'-\vec p\|}{v_m}$。

#### 合法位移

在每个时刻，若一枚导弹可以从 $\vec p=(x,y,z),\vec d$ 这一飞行状态，严格按照**偏航**和**直线飞行**的顺序进行机动，使飞行状态变为 $\vec p'=(x',y',z')\not=\vec p,\vec d'$，满足 $\vec d//(\vec p'-\vec p)$，并且各机动花费的时间之和不超过 $1$，则称这是一次(导弹的)合法位移（或称该位移合法）。此时，导弹会沿直线从 $\vec p$ 移动到 $\vec p'$。如无特殊指明，下文中“位移”均（应当）默认为合法位移。

#### 其它参数

除此之外，一枚导弹还具有以下参数：

1. 保险距离 $d_s>0$ 和激活状态；
   - 导弹被发射后立即处于未激活状态。
   - 每个时刻结束时，若导弹处于未激活状态，并且发射该导弹的无人机已坠毁，或者与发射该导弹的无人机的距离大于保险距离 $d_s$ 时，进入激活状态。此后将保持激活状态，并称该导弹被激活，或称其为一枚激活的导弹。
2. 空爆距离 $d_p>0$；
   - 每次导弹位移过程中，当一枚激活的导弹与任一无人机（包括发射该导弹的无人机）距离不大于 $d_p$ 时，该导弹会进入可空爆状态（详见下文“可空爆”）。
   - 每次无人机位移过程中，若存在一无人机与一枚激活的导弹距离不大于 $d_p$ 时，该导弹也会进入可空爆状态。
3. 最大锁定角 $\beta_s\in(\dfrac\pi4,\dfrac\pi2)$；
   - 任意时刻，一枚飞行状态为 $\vec p=(x,y,z),\vec d$、最大锁定角的导弹能锁定到 $\vec p'$ 处的无人机，当且仅当 $\vec d\cdot(\vec p'-\vec p)>0$，并且 $\angle(\vec d,\vec p'-\vec p)\le \beta_s$。
   - 此时称该无人机能被该导弹锁定，或称其在导弹的锁定范围内。
   - 称 $\angle(\vec d,\vec p'-\vec p)$ 为锁定角。
4. 制导时长 $t_z>0$；
   - 若导弹在第 $k$ 个时刻被发射，则到第 $k+t_z$ 个时刻结束时，若导弹仍未爆炸，则导弹会立刻消失（见“爆炸、消失与可空爆”）。此时称导弹超过制导时长。

#### 爆炸、消失与可空爆

一枚导弹在符合下列全部条件时，会立刻爆炸并消失：

1. 在导弹位移开始前，导弹处于激活状态；

2. 符合以下条件之一：
   
   1. 在该导弹位移过程中，存在一架位于 $\vec q$ 的无人机，使 $\min_{\lambda\in[0,1]}\|\lambda \vec p+(1-\lambda)\vec p'-\vec q\|\le d_p$，其中  $\vec p,\vec p'$ 为导弹本次位移的起点和终点。
      
      - 此时，所有这样的无人机都会被该导弹摧毁。同时，一架无人机可能同时被若干枚导弹摧毁。
   
   2. 在无人机位移过程中，存在一架无人机，记其从位置 $\vec q$ 位移到 $\vec q'$ ，满足 $\min_{\lambda\in[0,1]}\|\lambda \vec q+(1-\lambda)\vec q'-\vec p\|\le d_p$，其中 $\vec p$ 为导弹此时的位置。
      
      - 此时，所有这样的无人机都会被该导弹摧毁。同时，该导弹也可能同时摧毁若干这样的无人机。

此时，称该导弹可空爆，或该导弹进入可空爆状态。

一枚导弹在符合下列条件之一时，不会发生爆炸，但是会在当前时刻结束时消失：

1. 导弹脱锁（见下文“导弹脱锁”），并且在当前时刻开始时已被激活；

2. 导弹超过制导时长；

3. 导弹未激活，并且导弹位移结束后与一无人机位置重合；
   
   - 此时，该无人机会被这枚导弹摧毁。同时，一架无人机可能同时被若干枚导弹摧毁。

4. 导弹未激活，无人机位移结束后，该导弹与一无人机位置重合。
   
   - 此时，该无人机会被这枚导弹摧毁。同时，一枚导弹可能同时摧毁若干这样的无人机。

### 无人机视野、雷达搜索与导弹锁定

#### 无人机视野

任意时刻，一架飞行状态为 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 的无人机能够发现一架位于 $\vec p'=(x',y',z')$ 的无人机，当且仅当 $\vec d\cdot(\vec p'-\vec p)> 0$；此时称 $\vec p'$ 处的无人机在 $\vec p$ 处无人机的视野内。

#### 无人机机载雷达搜索范围

一架无人机的机载雷达（下文简称“雷达”）的扫描范围可以用以下两个参数描述：

1. 水平扫描范围 $L_x\in\N^+$ 和垂直扫描范围 $H_y\in\N^+$；
   - 任意时刻，一架飞行状态为 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 、雷达扫描范围为 $L_x,H_y$ 的无人机的能够扫描到一架位于 $\vec p'$ 的无人机，当且仅当，$\vec d\cdot(\vec p'-\vec p)>0$ 并且 $\exist x,y,s.t.\ |x|\le L_x,|y|\le H_y$ 且 $[\vec p'-(\vec p+x\vec l+y\vec u)]//\vec d$。
   - 即若以 $\vec p$ 为原点、以 $\vec l$ 和 $\vec u$ 为 $X,Y$ 轴建一平面 $\alpha=\alpha(\vec p;\vec l,\vec u)$，则  $\vec p'$ 在这一平面上的投影 $\vec r=P(\vec p';\alpha)$ 应当落在 $[-L_x,L_x]\times [-H_y,H_y]$ 中。
   - 此时称 $\vec p'$ 处的无人机在 $\vec p$ 处无人机雷达扫描范围内。

#### 导弹脱锁

当无人机位移结束后，若一枚导弹选定的目标已坠毁，或其不能被该导弹锁定，则称该导弹脱锁，或处于脱锁状态。

此后将一直保持脱锁状态，无论是否此前选定的无人机是否重新可以被导弹锁定。

### 无人机选定目标策略

任意时刻，无人机（简称"本机"，下同）按下述策略选择目标无人机。

1. 若本机视野内无敌方阵营无人机（简称“敌机”，下同），则本机无选定目标；
2. 否则，若上一时刻本机选择的无人机仍位于本机视野内，则本机仍选定该目标；
3. 否则，若存在至少一架敌机处于本机雷达扫描范围内，则选取其中与本机距离最近的；若与本机距离最近的敌机不唯一，则选取编号最小的。
4. 否则，对视野内的处于 $\vec p'$ 的敌机，记 $\alpha=\alpha(\vec p;\vec l,\vec u),\vec r=P(\vec p';\alpha)=(r_x,r_y)$，则选取 $\min\{|r_x-L_x|,|r_x+L_x|\}+\min\{|r_y-H_y|,|r_y+H_y|\}$ 最小的。若有多个最小值，则同样选择编号最小的。

### 飞行策略

#### 无人机飞行策略

设无人机飞行状态是 $\vec p=(x,y,z),\vec d,\vec u,\vec l$，其飞行极速为 $v_m$，机载雷达扫描范围为 $L_x,H_y$。

1. 若无人机有位于 $\vec p'$ 的选定目标：
   1. 若无人机能够合法地位移到某个位置，使敌机现在的位置 $\vec p'$ 仍处于本机的视野内，则无人机会合法地移动到飞行状态 $\vec q=(x_q,y_q,z_q),\vec d_q,\vec u_q,\vec l_q$，使敌机现在的位置 $\vec p'$ 仍处于本机视野内，且 $\|\vec p'-\vec q\|$ 最小。
      1. 若有多个这样的位置，记 $\alpha_q=\alpha(\vec q;\vec l_q,\vec u_q),\vec r_q=P(\vec p';\alpha_q)=(r_{qx},r_{qy})$，则优先选取使 $\vec r_q=(r_{qx},r_{qy})\in[-L_x,L_x]\times [-H_y,H_y]$ 的位置；
         1. 若仍有多个这样的位置，则选取使 $\|\vec r_q\|=\sqrt{r_{qx}^2+r_{qy}^2}$ 最小的；
         2. 若仍有多个这样的位置，则选取 $\vec q$ 字典序最小的。
      2. 若不存在这样的 $\vec r_q$，则选取使 $\min\{|r_{qx}-L_x|,|r_{qx}+L_x|\}+\min\{|r_{qy}-H_y|,|r_{qy}+H_y|\}$ 最小的；
         1. 若仍有多个这样的位置，则选取 $\vec q$ 字典序最小的。
   2. 否则，无人机会合法地移动到某个位置 $\vec q$，使 $\|\vec q-\vec p-v_m\vec d\|$ 最小；
      1. 若有多个这样的位置，则选取 $\vec q$ 字典序最小的。
2. 否则，无人机通过眼镜蛇机动，将飞行状态变为 $\vec p=(x,y,z),\vec u,-\vec d,\vec l$。

保证在上述1.的情况下，无人机总能合法地移动到某个位置。

#### 导弹飞行策略

设导弹当前时刻飞行状态 $\vec p,\vec d$，其选定的敌机飞行状态为 $\vec p',\vec d',\vec u',\vec l'$；

若上一时刻结束时，导弹未脱锁，则记 $\vec q'$ 为敌机根据其飞行策略，下一时刻会移动到的位置。

若导弹能合法位移到 $\vec q'$，则导弹会直接位移到 $\vec q'$。

否则，导弹会合法地位移到能使敌机位移后的位置 $\vec q'$ 处于锁定范围内的位置 $\vec q$ ，且 $\|\vec q-\vec q'\|$ 最小。

1. 若有多个这样的 $\vec q$，则选取位移后锁定角最小的；
2. 若仍有多种可能，则选取 $\vec q$ 字典序最小的。

若不存在这样的位置，或者上个时刻结束时，导弹已经脱锁，则导弹会合法地位移到某个位置 $\vec q$，使 $\|\vec q-\vec p-v_m\vec d\|$ 最小。

保证导弹总能合法地移动到某个位置。

### 无人机发射导弹规则

一飞行状态为 $\vec p=(x,y,z),\vec d,\vec u,\vec l$ 的无人机（简称"本机"）向**被本机选定**的、处于 $\vec p'$ 的目标无人机（简称“敌机”）发射导弹的规则为：

在每个时刻开始时，若选定的敌机已处于本机雷达扫描范围内，且当前不存在由本机发射且未爆炸（或消失）的导弹，则向敌机发射一初始飞行状态为 $\vec p,\vec d=\dfrac{\vec p'-\vec p}{\|\vec p'-\vec p\|}$ 的未激活的导弹，该导弹选定敌机。

### 同一时刻内各事件发生顺序

1. 所有无人机选定目标，并确定当前时刻内的飞行策略；
2. 所有能发射导弹的无人机发射导弹；
3. 所有导弹确定飞行策略并位移，该过程中部分无人机可能被摧毁；
4. 所有可空爆的导弹爆炸并消失；
5. 所有无人机按 1. 中确定的飞行策略位移，该过程中部分无人机可能被摧毁；
6. 所有可空爆的导弹爆炸并消失；
7. 所有位置相同的无人机发生碰撞并坠毁。
8. 所有超过制导时长和脱锁且已激活的导弹消失。
9. 所有可激活的导弹被激活。

### 任务

给定空域开始时（即第 $1$ 时刻开始时），各无人机的飞行性能与状态、导弹的飞行性能，假定这场空战会持续 $T$ 个时刻，双方指挥官希望你能按时间顺序依次给出每个时刻发生的所有重要事件。
## 输入格式

第一行两个正整数 $n,T$ ，表示共有 $2n$ 架无人机，模拟前 $T$ 个时刻。其中，前 $n$ 架阵营是 |\\| 国，后 $n$ 架阵营是 () 国。

接下来有 $2n$ 组数据，每一组包含若干行，其中第 $i$ 组描述了编号为 $i$ 的无人机。

在每组数据中：

第一行三个整数表示 $\vec p\in\mathbb Z^3$；保证所有的 $\vec p$ 两两不同，且坐标的绝对值不超过 $100$。

第二行六个整数依次表示无人机的 $\vec d,\vec u$，保证 $\vec d,\vec u\in S_v$；

- 其中， $S_v=\{(1,0,0),(-1,0,0),(0,1,0),(0,-1,0),(0,0,1),(0,0,-1)\}$；

第三行六个实数依次表示无人机的 $\theta_u,\theta_d,\gamma,v_m,L_x,H_y$；

第四行五个实数和一个正整数依次表示导弹的 $\theta_r,v_m,d_s,d_p,\beta_s,t_z$。
## 输出格式

输出 $T$ 组数据，第 $i$ 组数据表示第 $i$ 个时刻发生的重要事件。

在每组数据中：

第一行三个非负整数 $p_1,p_2,p_3$ ，表示在这个时刻的导弹位移过程中被摧毁的无人机数量、在这个时刻的无人机位移过程中被摧毁的无人机数量、这个时刻结束时，有多少组无人机因位置相同而两两碰撞坠毁。

接下来 $p_1$ 行，每行形如 $id_0\ k\ id_1\ id_2\ \cdots\ id_k$，表示编号为 $id_0$ 的无人机在这个时刻的导弹位移过程中被摧毁，并且在该过程中摧毁该无人机的导弹共有 $k$ 枚，分别来自编号为 $id_1,id_2,\cdots,id_k$ 的无人机。

为保证输出唯一，这 $p_1$ 行中的每一行内，$id_1,\dots,id_k$ 应当从小到大输出，行之间按 $id_0$ 从小到大输出。

接下来 $p_2$ 行，每行形如 $id_0\ k\ id_1\ id_2\ \cdots\ id_k$，表示编号为 $id_0$ 的无人机在这个时刻的无人机位移过程中被摧毁，并且在该过程中摧毁该无人机的导弹共有 $k$ 枚，分别来自编号为 $id_1,id_2,\cdots,id_k$ 的无人机。

为保证输出唯一，这 $p_2$ 行中的每一行内，$id_1,\dots,id_k$ 应当从小到大输出，行之间按 $id_0$ 从小到大输出。

接下来 $p_3$ 行，每行形如 $k\ id_1\ id_2\ \dots id_k$，表示该时刻结束时，有 $k$ 架无人机位置相同 ，它们的编号是 $id_1,...,id_n$。

为保证输出唯一，这 $p_3$ 行中的每一行内，$id_1,\dots,id_k$ 应当从小到大输出，行之间按 $id_1$ 从小到大输出，并且每个编号出现至多一次。
## 样例

### 样例输入 #1
```
1 1
0 0 0
1 0 0 0 0 1
1 1 1 4 1 1
1 3 1 1 1 1
8 0 0
-1 0 0 0 0 1
1 1 1 4 1 1
1 3 1 1 1 1

```
### 样例输出 #1
```
0 0 1
2 1 2

```
### 样例输入 #2
```
1 4
0 0 0
1 0 0 0 0 1
1 1 1 3 1 1
1 15 3 2 1 10
60 0 0
-1 0 0 0 0 1
1 1 1 3 1 1
1 15 3 2 1 10

```
### 样例输出 #2
```
0 0 0
0 0 0
0 0 0
0 2 0
1 1 2
2 1 1

```
## 提示

#### 样例解释 1

在第 $1$ 时刻，两架飞机于 $(4,0,0)$ 处相撞。

#### 样例解释 2

在第 $4$ 时刻，两枚导弹分别摧毁了敌机。

#### 数据范围

$T,n\le 100,3\le v_m\le 20$；

$v_m>10$ 的无人机和导弹总数不超过 $10$；

$\theta_u,\theta_d,\gamma,\theta_r,\beta_s\in(\dfrac\pi4,\dfrac\pi2)$；

$1\le d_s,d_p\le 20,1\le t_z\le 100$；

$|x|,|y|,|z|\le 100$；

$1\le L_x,H_y\le 100$。

所有输入的实数精确到小数点后不超过 $6$ 位。

最初时，$\vec p$ 两两不同。

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。


---

---
title: "[THUPC 2023 决赛] 喵了个喵 III"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9383
tag: ['2023', 'Special Judge', 'O2优化', '区间 DP', 'THUPC']
---
# [THUPC 2023 决赛] 喵了个喵 III
## 题目背景

小 E 玩腻了《喵了个喵》，于是决定换一款消除游戏来玩。然而小 E 发现市面上的消除游戏规则都差不多，比如这个游戏，它的规则和《喵了个喵》只有一个字不相同。虽然说，改了一个字的游戏就是新游戏，但确是缺了点意思。

## 题目描述

这个游戏有一个牌堆和 $n$ 个栈，任务是要通过游戏规则将所有的卡牌消去。开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1,a_2,\cdots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：

- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。如果这么操作后，这个栈最上方的两张牌有相同的图案，则会自动将这两张牌消去。

- 选择两个不同的栈，如果这两个栈栈**顶**的卡牌有相同的图案，则可以将这两张牌消去。如果不同，则什么也不会做。

经过多次观察小 E 发现总是有 $n=2$ 和 $k=m/2$，即只有两个栈且每一种图案的卡牌都恰好有 $2$ 张。虽然如此，小 E 还是一直无法通关。请你帮小 E 设计一下游戏方案，即给出相应的操作序列使得小 E 可以把所有的卡牌消去。

## 输入格式

第一行一个正整数 $m$。  

第二行 $m$ 个正整数，分别表示 $a_1,a_2,\cdots, a_m$。  

保证 $1\sim m/2$ 在序列中各出现两次。
## 输出格式

**本题采用 special judge**。

如果无解，输出一行 `No solution.`。  

如果有解，第一行输出 `Cleared.`。第二行输出一个正整数 $op$，表示操作的次数。你需要保证 $m\le op\le 2m$。  

接下来一行一个长度为 $op$ 的字符串，每一位是一个不超过 $2$ 的非负整数，按顺序表示进行的操作。若为 $1$ 或 $2$，则表示进行一次第一个操作并选择栈 $1$ 或栈 $2$。若为 $0$，则表示进行一次第二个操作。由于只有两个栈，所以你不需要输出额外的信息来说明你选择了哪些栈。
## 样例

### 样例输入 #1
```
4
1 2 1 2
```
### 样例输出 #1
```
Cleared.
5
12202
```
## 提示

### 样例 1 解释
下图是初始状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/ds0k392b.png)

下图是前两次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/iy4w5r9m.png)

![scale=0.24](https://cdn.luogu.com.cn/upload/image_hosting/kb0woz7t.png)

下图是第三次和第四次操作之后的结果。
![](https://cdn.luogu.com.cn/upload/image_hosting/t9zxtszv.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5z2eyqe2.png)

下图是第五次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/9kr8v9mm.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/z32r81vt.png)


### 数据规模与约定

- 保证 $2\le m \le 1500$ 且为偶数。
- 保证 $1\le a_i \le m/2$ 且每一种数在序列中出现恰好两次。

### 评分方法

你的输出的第一行需要与标准答案一致。

若有解，且在按顺序进行所有操作后，牌堆为空且所有的栈均为空，则认为你的答案正确。

### 后记

**以下部分与本题内容无关。**

说到底，那个嫌《喵了个喵 II》的题面太长的人其实是小 E 自己。它本来的题面中，题目背景和题目描述是这样的：

【题目背景】

小 E 玩腻了《喵了个喵》，于是决定换一款消除游戏来玩。然而小 E 发现市面上的消除游戏规则都差不多，比如这个游戏，它的规则和《喵了个喵》只有略微不相同。虽然说，只要改一个字就是新游戏，但确是缺了点意思。

【题目描述】

这个游戏有一个牌堆和 $n$ 个可以从栈底删除元素的栈，任务是要通过游戏规则将所有的卡牌消去。开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1,a_2,\cdots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：

- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。

- 选择两个不同的栈，如果这两个栈栈**底**的卡牌有相同的图案，则可以将这两张牌消去，原来在栈底上方的卡牌会成为新的栈底。如果不同，则什么也不会做。

经过多次观察小 E 发现总是有 $n=2$ 和 $k=m/4$，并且每一种图案的卡牌都恰好有 $4$ 张。虽然如此，小 E 还是一直无法通关。请你帮小 E 设计一下游戏方案，即给出相应的操作序列使得小 E 可以把所有的卡牌消去。


### 题目来源


来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。


---

---
title: "[THUPC 2023 决赛] 阴阳阵"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9385
tag: ['动态规划 DP', '2023', 'O2优化', 'THUPC']
---
# [THUPC 2023 决赛] 阴阳阵
## 题目背景

“余于久远之书，见一阴阳阵，必可助君征服九州。用此阵，须出诸阴阳大将。所谓阴将者，武勇而玉恶；所谓阳将者，善谋时且忠厚。凡阴阳阵，各将皆须择一将，以通之。又有两法皆牢记，不可即弱阵：一曰阴援阴，易激性情，或避之；二曰援与环，环阴与阳同，守以衡……”

正当你准备征服九州时，你仿佛听见一个熟悉的声音在远处喊：“工作的时候不准睡觉，你这样会被开除的……”你终于回过神来，发现你的 XCPC 队友在旁边熟练地拧着螺丝，流水线前已经漏过几个不合格的工品。刚刚什么都没发生啊，你哀叹道，但是……
## 题目描述

有一张图，图上有 $n$ 个白点和 $m$ 个黑点。白点之间两两不同，黑点之间两两不同。

每个节点有一条出边，每个节点出边指向的节点可以在 $n+m$ 个节点中任意选择。

此时共有 $(n+m)^{n+m}$ 个方案，每个方案是一个有向基环树森林。

称一个方案是好的当且仅当其满足以下条件：

- 任何一个黑点都指向一个白点，
- 每个环上的黑点数量和白点数量的乘积是偶数。

你需要求出所有方案中好的方案数量，对输入模数 $P$ 取模。
## 输入格式

输入一行三个整数 $n,m,P$，意义如题目描述所述。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
2 1 1000000

```
### 样例输出 #1
```
12

```
### 样例输入 #2
```
8 8 8888888

```
### 样例输出 #2
```
2973992

```
### 样例输入 #3
```
1000 1000 123456789

```
### 样例输出 #3
```
55105667

```
## 提示

### 样例 1 解释

考虑黑点必须连向白点的限制共有 $3 \times 3 \times 2 = 18$ 种方案，其中一个黑点和一个白点构成一个环的方案非法。选择一个白点和黑点构成环的方案数为 $2$，剩下的一个白点有三种方案，因此非法的方案数为 $2 \times 3 = 6$，答案为 $18-6=12$。

### 数据规模与约定

对于所有测试数据，$1 \le n,m \le 2000$，$1 \le P \le 10^9$。

### 提示

你可能需要注意常数对算法效率产生的影响。

### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023> 查看。


---

---
title: "[THUPC 2024 初赛] 排序大师"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9961
tag: ['2024', 'Special Judge', 'THUPC']
---
# [THUPC 2024 初赛] 排序大师
## 题目描述

由于你是排序大师，你经常被路过的游客刁难，要求用一些奇怪的操作给序列排序。

由于你是远近闻名的排序大师，邻国的排序萌新小 I 慕名前来拜访，留下了一个长度为 $n$ 的排列 $a_1, a_2 \cdots, a_n$，并要求你用以下操作将排列升序排序：

- 定义 $a_{i \sim j} = \{a_i,a_{i+1},\cdots, a_j\}$。选定 $1 \le i \le j < k \le l \le n$，交换 $a_{i \sim j}$ 和 $a_{k \sim l}$，即交换过后序列变为 $a_{1 \sim i-1}, a_{k \sim l}, a_{j+1 \sim k-1}, a_{i \sim j}, a_{l+1 \sim n}$。

由于你是因精益求精而远近闻名的排序大师，你需要给出一个排序方案**最小化**操作次数。
## 输入格式

输入的第一行一个整数 $n(1 \le n \le 2000)$ 表示序列长度，第二行 $n$ 个整数 $a_1,a_2,\cdots,a_n (1 \le a_i \le n)$ 描述排列。
## 输出格式

输出的第一行一个整数 $s$ 表示你给出的方案的步数，接下来 $s$ 行每行四个整数 $i,j,k,l$ 表示一次操作。若有多个方案，输出任意一个即可。
## 样例

### 样例输入 #1
```
6
1 4 5 3 2 6

```
### 样例输出 #1
```
1
2 3 5 5

```
## 提示

### 样例 \#1 解释
选定 $i = 2, j = 3, k = 5, l = 5$，$\colorbox{white}{\color{black}{1}\color{blue}{45}\color{black}{3}\color{red}{2}\color{black}{6}}$ 变为 $\colorbox{white}{\color{black}{1}\color{red}{2}\color{black}{3}\color{blue}{45}\color{black}{6}}$。

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。


---

---
title: "[THUPC 2024 初赛] 一棵树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9962
tag: ['2024', 'THUPC']
---
# [THUPC 2024 初赛] 一棵树
## 题目描述

这里有一棵树，具体的，这是一张有 $n$ 个节点和 $n-1$ 条边组成的无向联通图。

每个节点初始颜色为白色，你需要恰好将其中 $k$ 个节点染成黑色，定义一条边的权值是，断开这条边之后，两个连通块的黑色节点个数之差，定义一棵树的权值为所有边的权值求和，你需要最小化整棵树的权值。
## 输入格式

第一行两个正整数 $n,k$（$1\leq k\leq n\leq 5\times10^5$）。

接下来 $n-1$ 行，每行两个正整数 $x,y$ 表示树上的一条边。
## 输出格式

输出共 $1$ 行，表示最优的染色方案下，这棵树的权值的最小值。
## 样例

### 样例输入 #1
```
10 4
1 2
2 3
2 4
3 5
3 6
3 7
4 10
6 8
8 9

```
### 样例输出 #1
```
16

```
## 提示

### 样例 \#1 解释

下图展示了一种满足条件的染色方案，边上的数字表示边权。

![fig:sample](https://cdn.luogu.com.cn/upload/image_hosting/9i3ztp9r.png)

### 题目使用协议

来自 THUPC2024（2024年清华大学学生程序设计竞赛暨高校邀请赛）初赛。

以下『本仓库』皆指 THUPC2024 初赛 官方仓库（[https://github.com/ckw20/thupc2024_pre_public](https://github.com/ckw20/thupc2024_pre_public)）

1. 任何单位或个人都可以免费使用或转载本仓库的题目；

2. 任何单位或个人在使用本仓库题目时，应做到无偿、公开，严禁使用这些题目盈利或给这些题目添加特殊权限；

3. 如果条件允许，请在使用本仓库题目时同时提供数据、标程、题解等资源的获取方法；否则，请附上本仓库的 github 地址。


---

---
title: "[THUPC 2024 初赛] 勇闯末日塔"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9972
tag: ['计算几何', '2024', 'Special Judge', 'THUPC']
---
# [THUPC 2024 初赛] 勇闯末日塔
## 题目背景

安宁顷刻今将逝，末日黑云伺隙来。宿命无情何所惧？越其止境冀花开。

为了执行毁灭世界的疯狂计划，一位占用了已死之人躯壳的神秘男子在这颗蓝色的星球上创造出了无数末日塔。这些末日塔会散发出浓密的以太射线，对末日塔附近的几乎所有生物进行精神控制，只有受到特殊加护的人才能免受以太射线控制。

一些受到加护的义勇队对这些末日塔进行了调查，其结果显示：这些末日塔组成了复杂的以太传输网络，持续不断地从大地中吸收以太，并将以太传输到位于帝国的中枢塔。

一队持有特殊加护的英雄决定闯入其中一些末日塔，以期彻底调查并尝试破坏这些末日塔。英雄们破坏掉进入的末日塔后，以太传输网络就会受到影响，因此大家希望选择一些末日塔，将其破坏后能使得网络的最大传输容量降到最低。

作为勇闯末日塔小队的先锋，你再次阅读了小队目前所掌握的所有信息。这次大胆的行动计划最终能否拯救这个世界，眼下恐怕谁都无法事先料定。但为了这颗星球的未来，我们只能放手一搏。
## 题目描述

星球的表面是一个中心位于 $(0, 0, 0)$，半径为 $R$ 的完美球面。星球表面上共有 $N$ 座末日塔，这些令人毛骨悚然的塔构成了以太传输网络的所有节点。

- 末日塔的高度远小于星球半径，因此我们认为第 $i (1 \le i \le N)$ 座塔是球面上的一个点 $\left(x_i, y_i, z_i\right)$。第 $i$ 座塔的以太传输效率为 $q_i$。
- 保证 $N$ 座末日塔的位置两两不同。在这 $N$ 座末日塔中，$s$ 号塔是以太吸收点，$t$ 号塔是位于帝国的中枢塔；这两座塔的以太浓度显著高于其它的末日塔，因此只能闯入这两座塔之外的末日塔。

$N$ 座末日塔之间共有 $M$ 条传输通道。第 $j (1 \le j \le M)$ 条传输通道连接 $u_j, v_j$ 两座末日塔，让它们可以互相传输以太。

- 传输通道是双向的，但单位时间内以太的流向必须是单向的。
- 为了节省不必要的成本，传输通道的两端不会连接相同的塔，也不会有两条传输通道连接相同的末日塔对。
- 为了降低传输距离，第 $i$ 条传输通道沿着 $u_j$ 和 $v_j$ 所在的大圆的劣弧铺设，故其**长度** $r_j$ 为两座末日塔在星球表面的球面距离。为了避免传输通道的互相干扰，**对于任意一条传输通道所对应的劣弧，其他传输通道所对应的劣弧只会在该劣弧的两端点上与该劣弧相交**。保证由同一条传输通道相连的两座末日塔的位置不是对跖点关系。
  - 如果不知道大圆、劣弧、球面距离和对跖点是什么，可以参考题面最后的提示部分。

受到传输效率和通道长度的影响，每条传输通道有各自传输以太的容量上限。

- 具体而言，每个单位时间内，第 $j$ 条传输通道的**容量上限**为 $\frac{Kq_{u_j} q_{v_j}}{r_j^2}$，其中 $K$ 是给定的常数，$q_{u_j}, q_{v_j}$ 为该传输通道两端的塔的传输效率，$r_j$ 为这条传输通道的长度。

整张以太传输网络需要将 $s$ 号塔吸收的以太沿着传输通道传输到 $t$ 号塔，并使得单位时间内的以太传输量最大。为此，传输网络会自动确定一个以太传输方案，在满足所有传输通道容量上限的前提下，最大化这一传输量。

- 换句话说，如果将末日塔看作图上的点，传输通道看作边，而传输通道的容量上限对应每条边的容量，那么以太的传输方案应该恰好为 $s$ 到 $t$ 的最大流。

虽然没有任何人能保证闯入末日塔之后就一定能将其破坏，但作为勇闯末日塔小队的先锋，你还是想在出发之前计算一下，如果成功破坏了所有将要闯入的末日塔，传输网络单位时间的最大传输量将会降至多少。

- 如果成功破坏了选择的末日塔，与其相连的所有传输通道的容量都将降至 $0$，其余传输通道容量不发生变化；此时传输网络会自动调节至一个在新的网络中传输量最大的新方案。
- 在最理想的情况下，小队将有机会调查并破坏 $L$ 座末日塔。因此，需要事先选择 $L$ 座末日塔（均不能是 $s$ 或 $t$），使得当这 $L$ 座末日塔都被成功破坏时，传输网络的新的传输方案的以太传输量尽可能地小。
## 输入格式

输入的第一行包括五个正整数 $N, M, L, s, t$（$3\le N\le 500$，$2\le M\le \frac{N(N-1)}{2}$，$1\le L\le \min\{8,N-2\}$，$1\le s, t\le N$），分别表示该传输网络包含的末日塔数量，传输通道数量，有机会闯入的末日塔数量，最主要的以太吸收塔的编号和中枢塔的编号。

输入的第二行包括两个实数 $R, K$（$1\le R\le 10^3$，$1\le K\le 10^3$），分别表示星球的半径和计算以太容量时用到的常数。

接下来 $N$ 行，每行三个实数 $a_i, b_i, q_i$（$0\le a_i\le 1$，$0\le b_i< 2$，$1\le q_i \le 10^3$），描述第 $i$ 座末日塔的信息，其中 $q_i$ 表示第 $i$ 座末日塔的传输能力， $a_i$ 和 $b_i$ 共同描述末日塔的位置：令 $\theta_i = \pi a_i$，$\varphi_i = \pi b_i$（如果你习惯使用角度制而不是弧度制，可以将 $\pi$ 改为 $180^\circ$），则 $\left(x_i, y_i, z_i\right) = \left(R \sin\theta_i \cos\varphi_i, R\sin\theta_i \sin\varphi_i, R\cos\theta_i\right)$。保证末日塔的位置各不相同。

最后 $M$ 行，每行两个正整数 $u_i, v_i$（$1\le u_i, v_i\le N$），表示一条传输通道连接的两座末日塔的编号。保证同一条传输通道连接的两座末日塔不相同且不互为对跖点，没有两条传输通道连接的是相同的末日塔对，且传输网络是连通的。

保证输入的所有实数保留到小数点后第 $4$ 位。
## 输出格式

输出一个实数，表示如果成功破坏了将要闯入的末日塔，新的传输网络单位时间的最大传输量。当你的输出与标准输出的相对误差或绝对误差不超过 $10^{-6}$ 时，我们认为你的输出是正确的。
## 样例

### 样例输入 #1
```
6 11 1 1 6
1.0000 1.0000
1.0000 0.0000 10.0000
0.7500 0.2500 6.0000
0.5000 0.0000 1.0000
0.5000 0.5000 1.0000
0.2500 0.2500 6.0000
0.0000 0.0000 10.0000
1 2
1 3
1 4
2 3
2 4
3 4
3 5
3 6
4 5
4 6
5 6

```
### 样例输出 #1
```
8.105694691387022

```
## 提示

### 样例 \#1 解释

以太传输网络如下图所示。图中蓝色球面即为星球表面；紫色点为各末日塔，其中 $P_i$ 对应输入的第 $i$ 座末日塔；黄色的线表示各传输通道。

![样例 1 示意图](https://cdn.luogu.com.cn/upload/image_hosting/4bynt5dl.png)

原来的传输网络单位时间最大传输量为 $188/\pi^2$。破坏第 $2$ 个末日塔或第 $5$ 个末日塔都能使新的传输网络单位时间的最大传输量降至 $80/\pi^2$，而破坏第 $3$ 个末日塔或第 $4$ 个末日塔只能使新的传输网络单位时间的最大传输量降至 $94/\pi^2$，所以应该选择第 $2$ 个或第 $5$ 个末日塔尝试破坏。


---


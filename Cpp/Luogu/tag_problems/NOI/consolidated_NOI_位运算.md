---
title: "[集训队互测 2023] 虹"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10016
tag: ['集训队互测', '2023', '数论', '深度优先搜索 DFS', '最近公共祖先 LCA', '分块', '位运算']
---
# [集训队互测 2023] 虹
## 题目描述

给定一棵 $n$ 个点的树。

- 称点集 $S$ **连通**，当且仅当 $\forall u,v \in S$，所有 $u$ 到 $v$ 的简单路径上的点均在 $S$ 中。
- 称点集 $S$ 是 $[l,r]$ 的**虹**，当且仅当 $S$ **连通**，且 $S$ 包含 $[l,r]$ 中的所有点。
- 称点集 $S_0$ 是 $[l,r]$ 的**最小虹**，当且仅当 $S_0$ 是 $[l,r]$ 的所有**虹**中大小最小的。可以证明，$S_0$ 是唯一的。

点带权，点 $u$ 的权值为 $w_u$，初始所有点权均为 $0$。同时，给定序列 $\{z_1,z_2,\cdots,z_n\}$。

给定 $q$ 次命令，每次命令形如以下两类之一：

- `1 l r`：令 $S_0$ 为 $[l,r]$ 的**最小虹**，$\forall u \in S_0$，将 $w_u$ 加 $1$。
- `2 l r u`：求 $\left(\sum_{i=l}^r 19901991^{z_{\gcd(i,u)} w_i} \right) \bmod {20242024}$ 的值。
## 输入格式

第一行两个正整数 $n,q$。

第二行 $n$ 个非负整数，依次表示 $z_1,z_2,\cdots,z_n$。

接下来 $n-1$ 行，每行两个正整数 $u,v$，描述一条树上从 $u$ 到 $v$ 的边。

最后 $q$ 行，每行 $3$ 或 $4$ 个正整数，描述一次命令。

**注意：本题输入文件行末有 `\r`，请选手自行过滤。**
## 输出格式

对于每次询问（即第二类命令）输出答案。
## 样例

### 样例输入 #1
```
5 4
1 0 0 0 1
1 2
1 3
3 4
3 5
1 2 3
2 1 3 3
1 4 5
2 3 5 3
```
### 样例输出 #1
```
19561959
19561959
```
## 提示

**本题采用捆绑测试**。

对于所有测试数据保证：$1 \le n, q \le 8 \times 10^4,0 \le z_i \le 10^9$，所有命令满足 $1 \le l \le r \le n, 1 \le u \le n$，**保证第一类命令的 $(l,r)$ 随机生成**。随机生成方式如下：
- 在 $[1,n] \cap \mathrm{Z}$ 中等概率随机生成 $l$。
- 在 $[1,n] \cap \mathrm{Z}$ 中等概率随机生成 $r$。
- 若 $l>r$，则交换 $l,r$。

| 子任务编号 | 分值 | $n \le$ | $q \le$ | 特殊性质 | 子任务依赖 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :----------: |
| $1$ | $10$ | $10^3$ | $10^3$ | 无 | 无 |
| $2$ | $20$ | $65536$ | $65536$ | A, B | 无 |
| $3$ | $20$ | $65536$ | $65536$ | A | 依赖于子任务 $2$ |
| $4$ | $30$ | $65536$ | $65536$ | 无 | 依赖于子任务 $1,2,3$ |
| $5$ | $20$ | $80000$ | $80000$ | 无 | 依赖于子任务 $1,2,3,4$ |

特殊性质 A：保证所有第二类命令均在所有第一类命令之后。

特殊性质 B：保证第二类命令次数 $\le 20$。


---

---
title: "[COTS 2021] 菜 Jelo"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P11192
tag: ['2021', '提交答案', 'Special Judge', 'O2优化', '群论', '线性代数', '位运算', '构造', 'COCI（克罗地亚）']
---
# [COTS 2021] 菜 Jelo
## 题目背景

译自 [Izborne Pripreme 2021 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2021/) D1T1。$\texttt{1s,0.5G}$。

由于本题特殊的 SPJ，将本题的 TL 和 ML 分别改为 $\texttt{10s,2G}$。但是对于选手程序，本题的时空限制和原题相同。

如果使用压缩包上传答案：将文件分别命名为 $\texttt{jelo-1.out}\sim \texttt{jelo-5.out}$。
## 题目描述

给定正偶数 $N$。构造一个最大的集合 $S\subseteq \{0,1,\cdots,2^{N}-1\}$，使得 $\left|\bigcup_{i,j\in S,i\lt j} \{i\oplus j\}\right|={|S|\choose 2}$ 。换言之，在 $S$ 中任意选定 $(a,b),(c,d)$（$a,b,c,d\in S$，$a\lt b$，$c\lt d$，$(a,b)\neq (c,d)$），都有 $a\oplus b\neq c\oplus d$ 成立。

其中 $\oplus$ 表示按位异或运算。
## 输入格式

一行一个正整数 $N$。
## 输出格式

第一行一个整数 $|S|$。

接下来 $|S|$ 个数描述 $S$。
## 样例

### 样例输入 #1
```
4
```
### 样例输出 #1
```
6
0 1 2 4 8 15
```
## 提示


对于 $100\%$ 的数据，保证 $1\le N\le 30$。

本题共有 $5$ 个测试点，每个测试点有三个评分参数 $t_1,t_2,t_3$，记 $t=|S|$，则得分计算方式为：

$$\mathrm{score}(t)=
\begin{cases}
2.4\cdot \frac{t}{t_1} & t\in [0,t_1) \\
2.4+3.6\cdot \frac{t-t_1}{t_2-t_1} & t\in [t_1,t_2) \\
6+12\cdot \frac{t-t_2}{t_3-t_2} & t\in [t_2,t_3) \\
20 & t\in [t_3,2^N] \\
\end{cases}$$

| 测试点编号 | $N=$ | $t_1=$   | $t_2=$   | $t_3=$    | 得分 |  
| :--: | :--: | :--: | :--: | :--: | :--: |  
| $ 1 $    | $ 18 $    | $ 267 $   | $ 283 $   | $ 512 $    | $ 20 $   |  
| $ 2 $    | $ 20 $    | $ 444 $   | $ 462 $   | $ 1024 $   | $ 20 $   |  
| $ 3 $    | $ 26 $    | $ 2019 $  | $ 2040 $  | $ 8192 $   | $ 20 $   |  
| $ 4 $    | $ 28 $    | $ 3295 $  | $ 3327 $  | $ 16384 $  | $ 20 $   |  
| $ 5 $    | $ 30 $    | $ 5377 $  | $ 5430 $  | $ 32768 $  | $ 20 $   |

【提示】请注意代码长度限制。


---

---
title: "[集训队互测 2024] Désive"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P12478
tag: ['贪心', '线段树', '集训队互测', '2024', '位运算']
---
# [集训队互测 2024] Désive
## 题目背景

**由于评测机性能差距，本题时限增加了 1 秒。**

它的确很特殊，很引人注目，但异象从来都不特别。

它们终归只是错误而已：是人心里脆弱部分的回响，有着人心愿破碎时的音色。

就其本质而言，比起那颗心所渴望的，它们更接近那颗心本来的样子：一点也不特别， 但平凡同样可以拥有毁灭性的力量。

命运本身并不会带来缺陷，这样的痛苦也无法通过希望或命运的丝线挣脱——在这点上， 这枚曾经一度拥有摧毁性的强大力量的碎片能最终被找到并带回，和其他被寻得的碎片一样， 跟渴望没有一点关系。

大多时候，寻得异象的过程更像是追寻风的足迹，来无影去无踪，没有逻辑，也无需理由。

这片陈旧的，残缺的，容纳着悲伤和痛苦的躯壳…… 它能被找到，实在算不上什么奇迹，而仅仅是因为想要寻找它的人，心中都有着纯粹至极的情感，如此而已。 而这片连接起事物的存在，此时终于来到了她的唇齿之间。
## 题目描述

凡斯和德莱姆告诉彩梦，一个非负整数序列的 $\text{mex}$ 为最小没有出现过的非负整数，例如 $\text{mex}([0, 1, 3]) = 2$。

彩梦定义一个非负整数序列的 $\text{xormex}$ 为将每个元素异或一个相同非负整数后，序列 $\text{mex}$ 的最大值，例如 $\text{xormex}([8, 9, 11]) = \text{mex}([8 \oplus 9, 9 \oplus 9, 11 \oplus 9]) = \text{mex}([1, 0, 2]) = 3$。

给定长度为 $2^n$ 的序列 $a$ 和 $m$ 次询问，每次询问给定两个整数 $l, r$，彩梦想知道以下两个问题的答案：

- 子区间 $[a_l, a_{l+1}, \cdots, a_r]$ 的 $\text{xormex}$。
- 对于所有 $l \leq x \leq y \leq r$，子区间 $[a_x, a_{x+1}, \cdots, a_y]$ 的 $\text{xormex}$ 的和。
## 输入格式

第一行输入三个整数 $n, m, o$。

第二行输入 $2^n$ 个整数 $a_i$。

接下来 $m$ 行，每行输入两个整数 $l, r$。
## 输出格式

输出 $m$ 行，每行包含一个整数，代表每个询问的答案。

如果 $o = 1$，你需要输出第一个问题的答案。

如果 $o = 2$，你需要输出第二个问题的答案。
## 样例

### 样例输入 #1
```
2 4 1
3 2 0 1
1 3
2 3
1 2
1 4
```
### 样例输出 #1
```
3
1
2
4
```
### 样例输入 #2
```
3 5 2
0 4 6 7 5 2 1 3
1 8
3 5
2 6
3 7
1 4
```
### 样例输出 #2
```
93
9
29
22
15
```
## 提示

### 附加样例 3~5

见下发文件的 desive3~5.in 与 desive3~5.ans。

这些样例分别满足子任务 1,2,6 的限制。

### 样例解释

对于第一个询问，$\text{xormex}([3, 2, 0]) = \text{mex}([3 \oplus 2, 2 \oplus 2, 0 \oplus 2]) = \text{mex}([1, 0, 2]) = 3$。

对于第二个询问，$\text{xormex}([2, 0]) = \text{mex}([2, 0]) = 1$。

对于第三个询问，$\text{xormex}([3, 2]) = \text{mex}([3 \oplus 3, 2 \oplus 3]) = \text{mex}([0, 1]) = 2$。

对于第四个询问，$\text{xormex}([3, 2, 0, 1]) = \text{mex}([3, 2, 0, 1]) = 4$。

### 数据范围

对于所有数据，$1 \leq n \leq 18$，$1 \leq m \leq 10^6$，$0 \leq a_i < 2^n$，$1 \leq l \leq r \leq 2^n$。

- Subtask 1（7 pts）：$n \leq 6$, $m \leq 10^3$.
- Subtask 2（15 pts）：$n \leq 12$, $m \leq 5 \times 10^4$.
- Subtask 3（13 pts）：$n \leq 16$, $m \leq 10^5$, $o = 1$.
- Subtask 4（16 pts）：$n \leq 17$, $m \leq 5 \times 10^5$, $o = 1$.
- Subtask 5（10 pts）：$o = 1$.
- Subtask 6（12 pts）：$n \leq 17$, $m \leq 5 \times 10^5$, $a_i$ 两两不同.
- Subtask 7（5 pts）：$a_i$ 两两不同.
- Subtask 8（14 pts）：$n \leq 17$, $m \leq 5 \times 10^5$.
- Subtask 9（8 pts）：无特殊限制.

### 后记

将她从生与死的边界打捞的……是良方，还是奇迹？抑或是友谊？

……或许，都是吧。

当她的梦境第一回被光芒点亮的时候，她看见了她的朋友们为了保护她而奋不顾身的样子。
她确信，自己也会在它们遇见危险的时候这么做。
她一定会保护好它们——当然也包括她刚结识的那位新朋友。

当她们终于能彼此释怀，能够从容地分享自己所走过的路，讲述所遇到过的来自陌生人的善意的时候……

彩梦不禁笑了，她的嘴翘起了一个漂亮的弧度。
能自在释怀地笑，真是幸运至极呢。


---

---
title: "序列游戏"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P12695
tag: ['高精度', '博弈论', '2014', '多项式', '提交答案', '排序', '置换', '凸包', '其它技巧', '位运算', '快速数论变换 NTT', '分类讨论', '湖北']
---
# 序列游戏
## 题目背景

出题人：VFleaKing & hjy96
## 题目描述

从前有一天 hjy 在机房里愉快地刷题，但是他绞尽脑汁也只会写暴力，因此他想起了什么题都能够一眼秒的你，请你来帮助他 AC 吧！由于 hjy 现在心情比较糟，所以不想告诉你题面，请你根据他写的暴力程序推测题面，并帮他 AC。幸运的是我们并不是一无所知：我们知道这个程序的输入是两个整数序列。

我们给出 prog.exe，这是 hjy 写的暴力。你可以给这个程序一些输入，来推测他的用途。

我们给出 20 个输入文件 game1 ~ 20.in，请你写一个程序计算出对应的正确答案 game1 ~ 20.out。
## 输入格式

第一行有一个正整数 algoNum。表示算法编号。

第二行有一个正整数 $n$。表示序列长度。

第三行包括 $n$ 个用空格隔开的整数用来表示序列 $a[1], a[2], \dots, a[n]$。

第四行包括 $n$ 个用空格隔开的整数用来表示序列 $b[1], b[2], \dots, b[n]$。
## 输出格式

请根据 prog.exe 进行推测。

## 提示

为降低难度，操作相似的测试点相邻（有各别例外）。

运行 prog.exe 的方式为在命令行里输入

```
prog.exe <input> <output>
```

用来指定 prog 的输入和输出的文件位置。例如

```
prog.exe prog1.in prog1.out
```
prog.exe 会检测输入数据的合法性。如果数据不合法 prog.exe 会报错并不会产生输出。

当然我们还提供了 linux 版的 prog。运行方式为
```
./prog <input> <output>
```
注意 prog.exe 是个暴力程序，对于大数据它会跑得非常慢。

数据规模见输入文件。下表为原题的测试点分数，在洛谷上每个测试点 5 分。

| 数据编号 | 分值 |
| --- | --- |
| 1 | $2$ |
| 2 | $4$ |
| 3 | $7$ |
| 4 | $8$ |
| 5 | $9$ |
| 6 | $10$ |
| 7 | $20$ |
| 8 | $45$ |
| 9 | $10$ |
| 10 | $15$ |
| 11 | $5$ |
| 12 | $35$ |
| 13 | $10$ |
| 14 | $20$|
| 15 | $25$ |
| 16 | $10$ |
| 17 | $15$ |
| 18 | $30$ |
| 19 | $10$ |
| 20 | $10$ |


---

---
title: "[HNOI/AHOI2018] 寻宝游戏"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4424
tag: ['2018', '各省省选', '安徽', '湖南', '排序', '进制', '位运算']
---
# [HNOI/AHOI2018] 寻宝游戏
## 题目描述

某大学每年都会有一次 Mystery Hunt 的活动，玩家需要根据设置的线索解谜，找到宝藏的位置，前一年获胜的队伍可以获得这一年出题的机会。

作为新生的你，对这个活动非常感兴趣。你每天都要从西向东经过教学楼一条很长的走廊，这条走廊是如此的长，以至于它被人戏称为 infinite corridor。一次，你经过这条走廊时注意到在走廊的墙壁上隐藏着 $n$ 个**等长的**二进制的数字，长度均为 $m$。你从西向东将这些数字记录了下来，形成一个含有 $n$ 个数的二进制数组 $a_1,a_2,...,a_n$。

很快，在最新的一期的 Voo Doo 杂志上，你发现了 $q$ 个长度也为 $m$ 的二进制数 $r_1,r_2,...,r_q$。

聪明的你很快发现了这些数字的含义。

保持数组 $a_1,a_2,...,a_n$ 的元素顺序不变，你可以在它们之间插入 $\land$（按位与运算）或者 $\lor$（按位或运算）。例如：$11011\land 00111=00011$，$11011\lor 00111=11111$。

你需要插入 $n$ 个运算符，相邻两个数之前恰好一个，在**第一个数的左边**还有一个。**如果我们在第一个运算符的左边补入一个 0**，这就形成了一个运算式，我们可以计算它的值。与往常一样，运算顺序是**从左到右**。有趣的是，出题人已经告诉你这个值的可能的集合—— Voo Doo 杂志里的那些二进制数 $r_1,r_2,...,r_q$，而解谜的方法，就是对 $r_1,r_2,...,r_q$ 中的每一个值 $r_i$，分别计算出**有多少种方法填入这 $n$ 个计算符**，使的这个运算式的值是 $r_i$。

然而，infinite corridor 真的很长，这意味着数据范围可能非常大。因此，答案也可能非常大，但是你发现由于谜题的特殊性，你只需要求答案模 $1000000007$ 的值。
## 输入格式

第一行三个数 $n,m,q$，含义如题所述。

接下来 $n$ 行，其中第 $i$ 行有一个长度为 $m$ 的二进制数，**左边是最高位**，表示 $a_i$。

接下来 $q$ 行，其中第 $i$ 行有一个长度为 $m$ 的二进制数，**左边是最高位**，表示 $r_i$。
## 输出格式

输出 $q$ 行，每行一个数，其中的 $i$ 行表示对于 $r_i$ 的答案。
## 样例

### 样例输入 #1
```
5 5 1
01110
11011
10000
01010
00100
00100
```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
10 10 3
0100011011
0110100101
1100010100
0111000110
1100011110
0001110100
0001101110
0110100001
1110001010
0010011101
0110011111
1101001010
0010001001
```
### 样例输出 #2
```
69
0
5
```
## 提示

对于 $10\%$ 的数据，$n \le 20, m \le 30, q = 1$；

对于另外 $20\%$ 的数据，$n \le 1000, m \le 16$；

对于另外 $40\%$ 的数据，$n \le 500, m \le 1000$；

对于全部的数据 $1\leq n\leq 1000,1\leq m\leq 5000,1\leq q\leq 1000$。


---

---
title: "太极剑"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4704
tag: ['贪心', 'O2优化', '位运算', '构造', '洛谷月赛']
---
# 太极剑
## 题目描述

在学习太极之后，Bob 要求 Alice 教他太极剑。Alice 告诉他首先需要通过一项基本剑术测试。测试要求 Bob 尽可能快地切断 $n$ 根绳子。

所有绳子的端点两两不同，所以共有 $2n$ 个端点。这些端点被捆在一个圆上，等距离分布。我们把这些端点按顺时针方向编号为 $1$ 到 $2n$。

Bob 每次切割的轨迹是一条直线，可以将所有与这条直线相交的绳子切断，他想知道至少多少次可以切断所有的绳子。
## 输入格式

第一行一个整数 $n(1 \leq n \leq 2 \times 10^5)$，表示绳子的个数。

接下来 $n$ 行，每行两个整数 $a_i, b_i(1 \leq a_i, b_i \leq 2n, a_i \not= b_i)$，表示第 $i$ 根绳子的两个端点的编号。
## 输出格式

一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
2
1 2
3 4
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
3
1 2
3 4
5 6
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
3
1 3
2 4
5 6
```
### 样例输出 #3
```
1
```
## 提示

样例一解释：![](https://cdn.luogu.com.cn/upload/pic/19179.png)

样例二解释：![](https://cdn.luogu.com.cn/upload/pic/19180.png)

样例三解释：![](https://cdn.luogu.com.cn/upload/pic/19181.png)


---

---
title: "【XR-3】Namid[A]me"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5538
tag: ['图论', 'O2优化', '树论', '位运算']
---
# 【XR-3】Namid[A]me
## 题目描述

小 X 给了你一棵 $n$ 个点的树，点有点权。

你需要求出下列式子模 $786433$ 的值：

$\sum_{1\leq u\leq v\leq n}f(u,v)^{f(u,v)}$

其中 $f(u,v)$ 表示 $u$ 到 $v$ 的最短路径上所有点的点权按位与在一起之后的值。

提示：为了方便你的计算，这里我们认为 $0^0=0$。另外，$786433$ 是一个质数，同时也是一个不常用的 NTT 模数，它的原根为 $10$，如果你不知道什么是 NTT 或者不知道什么是原根，你可以忽略这个提示。
## 输入格式

第一行一个正整数 $n$，表示树的点数。

第二行 $n$ 个正整数 $a_{1\dots n}$，其中 $a_i$ 表示编号为 $i$ 的点的点权。

接下来 $n-1$ 行，每行 $2$ 个正整数 $u,v$，表示编号为 $u$ 和编号为 $v$ 的点之间有一条边。

**数据范围：**

- $2 \le n \le 2 \times 10^5$。
- 对于所有满足 $1\le i \le n$ 的 $i$ 都有 $1 \le a_i < 2^{30}$。
- $1 \le u,v \le n, u \ne v$。
- 设 $d$ 为树中叶子（度数为 $1$ 的点）的个数，数据保证 $4\le n \cdot d \le 3 \times 10 ^ 6$。
## 输出格式

一行一个整数，表示答案对 $786433$ 取模后的值。
## 样例

### 样例输入 #1
```
10
15 50 89 9 38 73 38 23 6 52
2 1
3 2
4 2
5 3
6 3
7 5
8 7
9 1
10 7

```
### 样例输出 #1
```
54184

```
### 样例输入 #2
```
20
17 56 72 12 16 43 33 8 28 90 21 12 7 43 55 95 25 65 63 77
2 1
3 2
4 1
5 3
6 5
7 1
8 7
9 7
10 3
11 5
12 7
13 5
14 7
15 11
16 6
17 3
18 15
19 15
20 13

```
### 样例输出 #2
```
503636

```


---

---
title: "「RdOI R3 附加」ACP-I"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7827
tag: ['提交答案', 'Special Judge', '位运算']
---
# 「RdOI R3 附加」ACP-I
## 题目背景

**注意：这不是一道模拟题，请先完整地读完一遍题面后再开始做题。**

---

### 排行榜

| task | 最短行数 | 达成者      |
| ---- | -------- | ----------- |
| 1    | 5        | std         |
| 2    | 191     | \_\_Ultimium\_\_      |
| 3    | 845      | dead_X      |
| 4    | 24       | 囧仙        |
| 5    | 77       | dqstz  |
| 6    | 15078    | 寻逍遥2006       |
| 7    | 211      | liqingyang        |
| 8    | 6796     | liqingyang |

如有你的解法行数**严格小于**榜中行数，请联系 @[yzy1](/user/207996) 把你的成绩放到排行榜上。

---

题目 ACP 有两层意思：**A**ncient **C**omputer **P**rogram 和 **A**nother **C**onstruct **P**roblem。

在 1951 年，第 -32 届全国青少年信息学奥林匹克冬令营前夕，小 A 借助时空传输接口（**T**ime **T**ransport **I**nterface）连接了一台 2015 年的计算机，获取到了第 32 届冬令营的题目来练习。

他打开了第三题「未来程序」这道题目：

> 本题是一道提交答案题，一共 10 个测试点。  
> 对于每个测试点，你会得到一段程序的源代码和这段程序的输入。你要运行这个程序，并保存这个程序的输出。  
> 遗憾的是这些程序都效率极其低下，无法在比赛的 5 个小时内得到输出。

小 A 想了一下，决定用 1951 年的计算机来试着运行这个题目。但是因为 1951 年的电脑存储空间过小，导致他无法传输题目附件和数据，请你帮助小 A 写 std 造数据。

## 题目描述

**这是一道提交答案题。**

小 A 的古董计算机使用两个 $64$ 位无符号整数的栈 $S_0$ 和 $S_1$ 来存储数据。每个栈中初始存储着 $10^{10^{10}}$ 个 $0$。

为了表述方便，下文中记「$T_x$」表示栈 $S_x$ 的栈顶元素。记符号 「$\And$」「$\mid$」「$\oplus$」分别为按位与、按位或、按位异或运算。

这台计算机支持 $8$ 种汇编指令，若没有特殊说明，以下指令的参数均为整数。

| 名称                 | 参数                     | 说明                                                         | 伪代码                                                       |
| -------------------- | ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| $\textbf{and}\ i$ | $i \in [0,1]$            | 令 $T_i$ 为 $T_i$ 与另一个栈的栈顶数字按位与的结果。         | $T_i \gets T_i \operatorname{\And} T_{i \oplus 1}$           |
| $\textbf{or}\ i$  | $i \in [0,1]$            | 令 $T_i$ 为 $T_i$ 与另一个栈的栈顶数字按位或的结果。         | $T_i \gets T_i \mid T_{i \oplus 1}$                          |
| $\textbf{xor}\ i$    | $i \in [0,1]$            | 令 $T_i$ 为 $T_i$ 与另一个栈的栈顶数字按位异或的结果。       | $T_i \gets T_i \oplus T_{i \oplus 1}$                        |
| $\textbf{lsh}\ i\ j$ | $i \in [0,1],j\in[0,64]$ | 令 $T_i$ 为 $T_i$ 左移 $j$ 位的结果，自然溢出。   | $T_i \gets T_i \times 2^j \bmod 2^{64}$                      |
| $\textbf{rsh}\ i\ j$ | $i \in [0,1],j\in[0,64]$ | 令 $T_i$ 为 $T_i$ 右移 $j$ 位的结果，自然溢出。   | $T_i \gets \lfloor \dfrac{T_i}{2^j} \rfloor$                 |
| $\textbf{not}\ i$    | $i\in[0,1]$              | 令 $T_i$ 为 $T_i$ 按位取反的结果。                           | $T_i \gets (2^{64}-1)-T_i$                            |
| $\textbf{pop}\ i$    | $i\in[0,1]$              | 将栈 $S_i$ 的栈顶元素出栈。                                  | $\text{Remove top element of }S_i$                           |
| $\textbf{mov}\ i$    | $i\in[0,1]$              | 将 $T_i$ 出 $S_i$ 栈，然后将其入另一个栈。即移动 $T_i$ 至 $S_{i \oplus 1}$。 | $\text{Push}\ T_i\text{ to }S_{i\oplus 1};\ \textbf{pop}\ i$ |

你需要使用这些汇编指令实现若干计算任务，每个测试点对应一个单独的计算任务。下文中「输入 $a_1, a_2, \cdots$」表示将 $a_1,a_2,\cdots$ 这几个整数**依次**压入 $S_0$ 栈，而两栈栈底的 $0$ 不做变动。**若无特殊说明，输入的数均为 $\mathbf{[0,2^{64}-1]}$ 范围内的整数。**「输出 $x_1, x_2, \cdots$」表示指令运行结束后会从 $S_1$ 中**依次**取出若干个整数作为 $x_1,x_2,\cdots$ 来检验结果是否正确。除此之外，对于 $S_0$ 栈中所有的数和 $S_1$ 栈中**没有**被取出的数在指令运行结束后可以为任意值。

1. 输入 $a, b$，输出 $b,a$。即将两数交换。
1. 输入 $a,b$，输出 $(a-b+2^{64}) \bmod 2^{64}$。即求两数之差，自然溢出。
1. 输入 $a_1, a_2,\cdots,a_9;a_i\in[48,57]$，即 $a_i\in[\mathtt{'0'}, \mathtt{'9'}]$。将 $a_1\sim a_9$ 视为一个 ASCII 编码下的长度为 $9$ 的字符串，你需要将这个字符串**前后翻转后**转化为一个对应的十进制整数并输出。即实现一个快读。特别的，字符串中可能会有前导零。
1. 输入 $a$，输出 $(\operatorname{popcnt}a) \bmod 2$。其中 $\operatorname{popcnt} x$ 代表 $x$ 的二进制表示法中 $1$ 的个数。
1. 输入 $a,b$，输出 $\min\{a,b\}$。
1. 输入 $a,b,p$，满足 $p$ 为 $2$ 的非负整数次幂或零。输出 $(a\times b) \bmod p$。特别地，当 $p=0$ 时输出 $0$。
1. 输入 $a$，满足 $a$ 和答案都是 $2$ 的非负整数次幂或零，输出 $\sqrt a$。
1. 输入 $a,b;1\le a,b \le 63$，输出 $\gcd(a,b)$，即 $a,b$ 的最大公因数。
## 输入格式

由于出题人不想把这道题出成一道大模拟，所以附件中提供了汇编模拟部分。

在下发文件下有 `checker.cpp` 和 `1.ans ~ 8.ans`。其中 `checker.cpp` 给出了几种汇编指令的简单实现。你可以使用 `checker.cpp` 测试你的程序。使用 `g++ checker.cpp -o checker -std=c++11` 将 `checker.cpp` 编译为可执行文件后运行 `checker *.in *.out *.ans`，`checker` 就会给出你的输出结果和该测试点的得分。其中 `*.in` 中为提供给指令的输入数据，每行一个，以 EOF 结束；`*.out` 中存放你的指令；`*.ans` 指下发文件中的 `.ans` 文件。

**注意：此 checker 仅作示例使用，不具备验证正确性功能。**
## 输出格式

请将每个任务对应的指令写入 `1.out ~ 8.out`，并打包成 zip 后提交。
## 样例

### 样例输入 #1
```
123456789
2147483648
```
### 样例输出 #1
```
2147483648
123456789
```
### 样例输入 #2
```
2147483647998244353
9982443532147483647
```
### 样例输出 #2
```
10611784189560312322
```
### 样例输入 #3
```
51
53
51
52
52
50
56
57
57
```
### 样例输出 #3
```
998244353
```
### 样例输入 #4
```
233456
```
### 样例输出 #4
```
1
```
### 样例输入 #5
```
2147483647998244353
9223372036854775808
```
### 样例输出 #5
```
2147483647998244353
```
### 样例输入 #6
```
2147483647998244353
9982443532147483647
9223372036854775808

```
### 样例输出 #6
```
7806477557104029183
```
### 样例输入 #7
```
4611686018427387904

```
### 样例输出 #7
```
2147483648
```
### 样例输入 #8
```
24 32
```
### 样例输出 #8
```
8
```
### 样例输入 #9
```
输入 a，b。输出 a 按位异或 b 的结果。
```
### 样例输出 #9
```
mov 0
xor 1
```
### 样例输入 #10
```
没有输入，输出数字 6。
```
### 样例输出 #10
```
not 1
lsh 1 62
rsh 1 61
```
## 提示

### 样例说明

上述「样例组 $1\sim 8$」代表 $1\sim8$ 子任务的样例输入输出。「样例组 $9\sim10$」为示例问题的一种最短的程序实现。

---

### 评分方法

下面用 `*` 代表测试点编号。如果你提交的指令（`*.out`）没有正确完成计算得零分，否则设你使用的指令个数为 $cnt$，若 `*.ans` 中有 $x$ 个 $\ge cnt$ 的数，你该测试点得 $x$ 分。

---

### 注意

虽然我们允许你提交最多 $999999$ 行的指令，但是由于洛谷对于 checker 的运行时间有限制，你的指令长度被强行加上了一个奇怪的上限：约是 $2\times 10^5$，超过这个长度的指令可能会因为 checker 超时而导致 UKE。

由于洛谷提交答案题的特性，如果你不会做一些 task，请在压缩包内放一个空的 `*.out` 文件占位，其中 `*` 代表 task 编号。否则你的整道题可能会出现答案错位（比如 `2.out` 交到了 $1$ 号测试点）的情况，导致后面的测试点变成零分。


---


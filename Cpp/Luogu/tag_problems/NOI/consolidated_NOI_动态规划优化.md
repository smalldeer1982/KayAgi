---
title: "[省选联考 2025] 封印"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P11835
tag: ['动态规划 DP', '各省省选', '2025', '动态规划优化']
---
# [省选联考 2025] 封印
## 题目描述

在一次探险中，小 H 发现了一个古老的封印。封印的本体是一个长度为 $n$ 的序列 $A = [a_1, a_2, \ldots, a_n]$。初始，每个元素都是 1 至 $m$ 间的正整数。

设 $|A|$ 表示序列 $A$ 的长度，小 H 可以对序列进行以下修改:
1. 选择序列 $A$ 的某个**严格**前缀最大值元素 $a_s$，即选择 $1 \leq s \leq |A|$ 满足 $\forall 1 \leq j < s, a_s > a_j$，特别地，$a_1$ 总是序列 $A$ 的严格前缀最大值;
2. 若 $a_s \neq 1$，将 $(a_s - 1)$ 插入序列 $A$ 的尾端;
3. 删去序列 $A$ 的前 $s$ 个元素。

考虑如下例子：在 $A = [1, 3, 2, 3, 4]$ 时，
- 小 H 可以选择 $s = 1$，此时修改后的序列变为 $[3, 2, 3, 4]$;
- 小 H 可以选择 $s = 2$，此时修改后的序列变为 $[2, 3, 4, 2]$;
- 小 H 不能选择 $s = 4$，因为 $a_2 = a_4 = 3$，这意味着 $a_4$ 并非严格前缀最大值。

小 H 可以进行任意多次修改操作，也可以不进行任何修改。为了解开封印，小 H 想知道：通过以上修改操作，他可以得到多少种不同的非空序列。

认为两个序列 $A = [a_1, \ldots, a_n]$ 和 $B = [b_1, \ldots, b_m]$ 不同，当且仅当 $n \neq m$ 或 $\exists 1 \leq i \leq \min\{n, m\}$，$a_i \neq b_i$。

由于答案可能很大，你只需告诉小 H 答案对 $998\,244\,353$ 取模后的结果。
## 输入格式

**本题有多组测试数据**。输入的第一行两个整数 $c, T$，分别表示测试点编号和测试数据组数，接下来输入每组测试数据。样例满足 $c = 0$。

对于每组测试数据，第一行两个整数 $n, m$，分别表示序列长度与值域，第二行 $n$ 个整数 $a_1, a_2, \ldots, a_n$，描述序列 $A$。
## 输出格式

对于每组测试数据输出一行一个整数，表示通过修改操作可以得到的非空序列个数，对 $998\,244\,353$ 取模。
## 样例

### 样例输入 #1
```
0 4
3 2
1 2 1
4 3
3 1 2 1
5 4
1 3 2 3 4
7 5
4 4 5 2 3 3 1
```
### 样例输出 #1
```
4
7
20
59
```
### 样例输入 #2
```
0 2
11 10
8 8 8 9 9 8 8 9 9 9 8
12 2500
1529 1470 1361 1416 1492 1503 1641 1868 1829 1959 2052 2105
```
### 样例输出 #2
```
694
4961744
```
## 提示

**【样例 1 解释】**

该组样例共有 4 组测试数据。
- 对于第一组测试数据，可以通过修改得到的非空序列有 $[1, 2, 1]$，$[2, 1]$，$[1, 1]$，$[1]$。
- 对于第二组测试数据，可以通过修改操作得到的非空序列有 $[3, 1, 2, 1]$，$[1, 2, 1, 2]$，$[2, 1, 2]$，$[1, 2, 1]$，$[2, 1]$，$[1, 1]$，$[1]$。

**【样例 3】**

见选手目录下的 `seal/seal3.in` 与 `seal/seal3.ans`。

该组样例满足测试点 3 ~ 5 的限制。

**【样例 4】**

见选手目录下的 `seal/seal4.in` 与 `seal/seal4.ans`。

该组样例满足测试点 10 的限制。

**【样例 5】**

见选手目录下的 `seal/seal5.in` 与 `seal/seal5.ans`。

该组样例满足测试点 11 ~ 14 的限制。

**【样例 6】**

见选手目录下的 `seal/seal6.in` 与 `seal/seal6.ans`。

该组样例满足测试点 15 的限制。

**【样例 7】**

见选手目录下的 `seal/seal7.in` 与 `seal/seal7.ans`。

该组样例满足测试点 17 ~ 19 的限制。

**【样例 8】**

见选手目录下的 `seal/seal8.in` 与 `seal/seal8.ans`。

该组样例满足测试点 22 ~ 25 的限制。

**【子任务】**

对于所有测试点，
- $1\leq T\leq 10$，
- $1\leq n,m\leq 2500$，
- $\forall 1\leq i\leq n$，$1\leq a_i\leq m$。

| 测试点编号 | $n \leq$ | $m \leq$ | 特殊性质 |
|:------------:|:------------:|:------------:|:----------:|
| $1, 2$       | $10$         | $10$         | 无       |
| $3 \sim 5$      | $18$           | $70$           |          |
| $6$          | $18$         | $70$           | A        |
| $7, 8$       | $18$           | $70$         | AB       |
| $9$          | $70$           | $70$           | A        |
| $10$         | $70$         | $70$           | AB       |
| $11 \sim 14$    | $70$           | $70$           | 无       |
| $15$         | $300$           | $300$           | A        |
| $16$         | $300$        | $300$           | AB       |
| $17 \sim 19$    | $300$           | $300$        | 无       |
| $20$         | $2\,500$           | $2\,500$           | A        |
| $21$         | $2\,500$      | $2\,500$           | AB       |
| $22 \sim 25$    | $2\,500$           | $2\,500$      | 无       |

- 特殊性质 A：$\forall 1 \leq i < j \leq n, a_i \neq a_j$。
- 特殊性质 B：$\forall 1 \leq i < n, a_i < a_{i+1}$。


---

---
title: "[OOI 2025] The arithmetic exercise"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P12074
tag: ['动态规划 DP', '贪心', '2025', '动态规划优化']
---
# [OOI 2025] The arithmetic exercise
## 题目描述

Oleg and Dasha participated in a team competition, but unfortunately, they were unable to solve any problems. Oleg immediately realized that their team wasn't training enough. Then, their mutual friend suggested an interesting exercise. The exercise was quite simple, and to solve it, they only needed to know the rules of addition and subtraction of integers.

You are given an array $a$ of length $n$, where initially all values are zero. You are also given $m$ numbers $x_1,\ x_2,\ \ldots\ x_m$. Then, for each $i$ from $1$ to $m$, you choose some index $j_i$ and make the change $a_{j_i} = x_i - a_{j_i}$.

Help Oleg and Dasha determine what the maximum possible sum of the elements of array $a$ can be after all the changes, if the choices are made optimally.
## 输入格式

Each test consists of several input data sets. The first line contains a single integer $t$ ($1 \le t \le 10\,000$) --- the number of input data sets. Then follows the description of the data sets.

The first line of each data set contains two integers $n$ and $m$ ($1 \le n, m \le 300\,000$) --- the length of the array $a$ and the number of values $x_i$, respectively.

The second line of each data set contains $m$ integers $x_1$, $x_2$, $\ldots$, $x_m$ ($-10^9 \le x_i \le 10^9$) --- the description of the values.

Let $N$ be the sum of $n$ over all data sets, and $M$ be the sum of $m$ over all data sets.

It is guaranteed that $N$ and $M$ do not exceed $300\,000$.
## 输出格式

For each data set, output a single number on a new line --- the maximum sum of the array $a$ that can be obtained.
## 样例

### 样例输入 #1
```
4
1 4
1 2 3 4
2 7
10 3 7 1 4 6 3
4 10
103 354 1 227 179 189 142 201 165 140
5 3
-10 11 -4
```
### 样例输出 #1
```
2
18
1085
17
```
## 提示

**Note**

In the first data set, all operations are applied to the first element of the array $a$. It sequentially becomes $1 - 0 = 1$, $2 - 1 = 1$, $3 - 1 = 2$, $4 - 2 = 2$, so the answer is $2$.

In the second data set, the following sequence of changes can be performed:


- Apply the change to the first element: $a_1 = 10 - a_1 = 10 - 0 = 10$, $a = [10, 0]$.
- Apply the change to the first element: $a_1 = 3 - a_1 = 3 - 10 = -7$, $a = [-7, 0]$.
- Apply the change to the first element: $a_1 = 7 - a_1 = 7 - (-7) = 14$, $a = [14, 0]$.
- Apply the change to the first element: $a_1 = 1 - a_1 = 1 - 14 = -13$, $a = [-13, 0]$.
- Apply the change to the second element: $a_2 = 4 - a_2 = 4 - 0 = 4$, $a = [-13, 4]$.
- Apply the change to the first element: $a_1 = 6 - a_1 = 6 - (-13) = 19$, $a = [19, 4]$.
- Apply the change to the second element: $a_2 = 3 - a_2 = 3 - 4 = -1$, $a = [19, -1]$.

At the end, we have $a = [19, -1]$, so the final sum is $18$.

It can be shown that a better result is not possible.

**Scoring**

The tests for this problem consist of ten groups. Points for each group are given only if all tests of the group and all tests of the required groups are passed. Please note that passing the example tests is not required for some groups. $\textbf{Offline-evaluation}$ means that the results of testing your solution on this group will only be available after the end of the competition.

| Group | Points | Additional constraints: $n, N$ | Additional constraints: $m, M$ | Additional constraints: $x_i$ | Required Groups | Comment                                                      |
| :---- | :----- | :----------------------------- | :----------------------------- | :---------------------------- | :-------------- | :----------------------------------------------------------- |
| 0     | 0      | --                             | --                             | --                            | --              | Examples.                                                    |
| 1     | 4      | --                             | --                             | $0 \le x_i$                   | --              | All $x_i$ are same                                           |
| 2     | 8      | $n=2$                          | $M \le 30$, $m \le 18$      | --                            | --              |                                                              |
| 3     | 11     | $n=2$                          | $M \le 50$                     | $-10 \le x_i \le 10$          | --              |                                                              |
| 4     | 9      | $n=2$                          | $M \le 400$                    | $-400 \le x_i \le 400$        | 3               |                                                              |
| 5     | 8      | $N \le 30$, $n \le 18$      | $M \le 30$, $m \le 18$      | --                            | 0               |                                                              |
| 6     | 10     | $N \le 2000$                   | $M \le 2000$                   | $0 \le x_i$                   | --              |                                                              |
| 7     | 12     | $N \le 2000$                   | $M \le 2000$                   | --                            | 0, 2 -- 6       |                                                              |
| 8     | 10     | --                             | --                             | $0 \le x_i$                   | 1               | There are no more than two different values among $x_i$      |
| 9     | 17     | --                             | --                             | $0 \le x_i$                   | 1, 6, 8         |                                                              |
| 10    | 11     | --                             | --                             | --                            | 0 -- 9          | **Offline-evaluation.**                                      |


---

---
title: "[集训队互测 2024] 人间应又雪"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P12483
tag: ['动态规划 DP', '二分', '集训队互测', '树状数组', '2024', '动态规划优化']
---
# [集训队互测 2024] 人间应又雪
## 题目描述

长度为 $n$ 的街道被积雪覆盖，将街道划分为 $n$ 段，第 $i$ 段的积雪量为 $a_i$，保证 $0\le a_i\le m$ 且 $a_i$ 为整数。

天依与言和要来清理积雪，每次清理有 $2$ 种选择。

+ 天依从位置 $1$ 走到位置 $x$，将积雪清理掉 $c$，再走回位置 $1$，同时，因为在雪地上移动，位置 $1\sim x$ 的积雪量减少 $1$，即 $\forall i\in[1,x-1],a_i:=a_i-1,a_x:=a_x-c-1$。
+ 言和从位置 $n$ 走到位置 $x$，将积雪清理掉 $c$，再走回位置 $n$，同时，因为在雪地上移动，位置 $x\sim n$ 的积雪量减少 $1$，即 $\forall i\in[x+1,n],a_i:=a_i-1,a_x:=a_x-c-1$。。

任意时刻，积雪量对 $0$ 取 $\max$。

天依与言和想知道，最少进行多少次清理后（**即最小化两人清理次数总和**），能将所有积雪清除，即 $\forall i\in [1,n],a_i=0$。
## 输入格式

**本题有多组测试数据。**

首先输入一行两个数 $T,tid$，$T$ 表示数据组数，$tid$ 表示子任务编号（样例的子任务编号为 $0$）。

对于每组数据：

第一行三个整数 $n,m,c$。

第二行 $n$ 个整数 $a_{1\sim n}$。
## 输出格式

对于每组数据，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
1 0
5 5 1
1 3 2 3 1
```
### 样例输出 #1
```
2
```
## 提示

### 样例解释 1

天依走到位置 $4$ 清理，积雪量变为 $[0,2,1,1,1]$。

言和走到位置 $2$ 清理，积雪量变为 $[0,0,0,0,0]$。

共 $2$ 次清理。

### 样例解释 2

见附加文件中的 `snow.in` 与 `snow.ans`。  
这个样例中有 $100$ 组 $n=10,m=10$ 的数据。

### 数据范围

对于 $100\%$ 的数据，$1\le T\le 10^5$，$1\le n,m\le 5\times 10^5$，$\sum n,\sum m\le 10^6$，$0\le a_i\le m$，$0\le c\le 5\times 10^5$。

| 子任务编号 |        $n$         |        $m$         |            特殊限制             | 分值 | 子任务依赖 |
| :--------: | :----------------: | :----------------: | :-----------------------------: | :--: | :--------: |
|    $1$     | $\le 5\times 10^5$ | $\le 5\times 10^5$ |              $c=0$              | $2$  |            |
|    $2$     | $\le 5\times 10^5$ |      $\le 2$       |               无                | $3$  |            |
|    $3$     |      $\le 5$       |      $\le 5$       |            $T\le 10$            | $5$  |            |
|    $4$     |      $\le 50$      |      $\le 50$      |     $\sum n,\sum m\le 200$      | $10$ |    $3$     |
|    $5$     |     $\le 300$      |     $\le 300$      |     $\sum n,\sum m\le 600$      | $10$ |    $4$     |
|    $6$     |     $\le 2000$     |     $\le 2000$     |     $\sum n,\sum m\le 4000$     | $10$ |    $5$     |
|    $7$     | $\le 5\times 10^4$ | $\le 5\times 10^4$ | $c\le 20,\sum n,\sum m\le 10^5$ | $20$ |            |
|    $8$     | $\le 5\times 10^4$ | $\le 5\times 10^4$ |     $\sum n,\sum m\le 10^5$     | $15$ |   $6,7$    |
|    $9$     | $\le 5\times 10^5$ | $\le 5\times 10^5$ |            $c\le 20$            | $10$ |   $1,7$    |
|    $10$    | $\le 5\times 10^5$ | $\le 5\times 10^5$ |               无                | $15$ |  $2,8,9$   |


---

---
title: "[集训队互测 2024] 链覆盖"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P12495
tag: ['动态规划 DP', '集训队互测', '2024', 'O2优化', '动态规划优化']
---
# [集训队互测 2024] 链覆盖
## 题目背景

你的学弟向你请教这样一道题：

- 给定一颗 $n$ 个点的有根树，初始所有点均为白色。

- 你可以执行不超过 $k$ 次操作，每次操作为选定一个点，把它到根简单路径上的所有点涂成黑色。

-  求你最终最多能涂黑多少点。对 $k=1 \sim n$ 分别求解。
这当然不是什么难题，你很快向学弟解释清楚了这应该怎么做，他惊叹于做法的巧妙，然后满意地离开了。

你看着他离去的身影，想起两三年前，你第一次得知这道题怎么做时，也曾为这道题的解法赞叹过。但对于现在的你来说，这也并没有什么神奇之处，只是一个平凡的套路罢了。

但熟知的原题与结论并不一定真的就乏味无趣、无甚可观，这样想着，你记录下了这道题：
## 题目描述

- 给定一颗 $n$ 个点的有根树，初始所有点均为白色。

- 你可以执行不超过 $k$ 次操作，每次操作为选定一个点，把它到根简单路径上的所有点涂成黑色。

-  求你最终最多能涂黑多少点。对 $k=1 \sim n$ 分别求解。

记对于有标号有根树 $T$，上述问题在 $k=i$ 时的答案为 $ans(T,i)$。

给定 $n,mod$，对所有 $1 \le k \le n,1 \le m \le n$，计算有多少不同的 $n$ 个点以 $1$ 为根的有标号树 $T$ 满足 $ans(T,k)=m$。答案对 $mod$ 取模。

两颗有标号以 $1$ 为根的树被认为是不同的，当且仅当它们的边集不同。
## 输入格式

一行两个整数 $n,mod$。
## 输出格式

输出 $n$ 行每行 $n$ 个整数，第 $k$ 行的第 $m$ 个整数表示满足 $ans(T,k)=m$ 的不同的 $n$ 个点以 $1$ 为根的有标号树 $T$ 的数量对 $mod$ 取模的结果。
## 样例

### 样例输入 #1
```
2 998244353
```
### 样例输出 #1
```
0 1 
0 1
```
### 样例输入 #2
```
3 998244353
```
### 样例输出 #2
```
0 1 2 
0 0 3 
0 0 3
```
### 样例输入 #3
```
4 998244353
```
### 样例输出 #3
```
0 1 9 6 
0 0 1 15 
0 0 0 16 
0 0 0 16
```
### 样例输入 #4
```
5 998244353
```
### 样例输出 #4
```
0 1 40 60 24 
0 0 1 28 96 
0 0 0 1 124 
0 0 0 0 125 
0 0 0 0 125
```
### 样例输入 #5
```
6 998244353
```
### 样例输出 #5
```
0 1 195 560 420 120 
0 0 1 75 500 720 
0 0 0 1 75 1220 
0 0 0 0 1 1295 
0 0 0 0 0 1296 
0 0 0 0 0 1296
```
## 提示

本题使用捆绑测试，你只有通过一个子任务的所有测试点，才能获得这个子任务的分数。

| Subtask | $n \le$ | 分值 |
| :-----: | :-----: |  :--: |
|   $1$   |   $5$   |  $1$  |
|   $2$   |  $10$   | $9$ |
|   $3$   |  $20$  |   $10$ |
|   $4$   |  $32$  | $15$ |
|   $5$   | $40$  | $5$ |
|   $6$   | $50$  | $15$ |
|   $7$   | $65$  |  $5$ |
|   $8$   | $80$  |  $5$ |
|   $9$   | $120$ |  $15$ |
|   $10$   | $300$  |  $20$ |

对于所有数据：$1 \le n \le 300$，$10^8 \le mod \le 1.05 \times 10^9$，保证 $mod$ 是质数。


---

---
title: "[KOI 2025 #2] 庆典"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P13526
tag: ['动态规划 DP', '2025', '动态规划优化', 'KOI（韩国）']
---
# [KOI 2025 #2] 庆典
## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。
## 题目描述

KOI 国由 $N$ 个城市组成，各城市分别编号为 $1, 2, \dots, N$。1 号城市是 KOI 国的首都。

KOI 国有 $N-1$ 条双向道路。对于所有满足 $2 \le i \le N$ 的 $i$，$i$ 号城市都与 $P_i$ 号城市通过一条双向道路相连。此时，满足 $P_i < i$，且连接 $i$ 号城市和 $P_i$ 号城市的道路的每日通行费是 $W_i$。

如果 $u$ 号城市位于从 1 号城市（首都）到 $v$ 号城市的简单路径上，我们定义为 $u$ 号城市**管制** $v$ 号城市。$i$ 号城市的**管辖区域**被定义为 $i$ 号城市所管制的所有城市的集合。因此，1 号城市的管辖区域是所有城市，并且对于所有 $1 \le i \le N$，$i$ 号城市本身也属于其管辖区域。如果将 KOI 国的道路网看作一个以 1 号城市为根的树形结构，那么 $i$ 号城市的管辖区域就与以 $i$ 号城市为根的子树相对应。

KOI 国的各个城市计划举办庆典。平时所有道路的通行费都是免费的，但在庆典期间，为了分担举办庆典的费用，计划对部分道路征收通行费。

如果在 $i$ 号城市举办庆典，可以选择一部分道路来征收通行费。单日通行费收入是所有征收通行费的道路的每日通行费之和。为了减少民众的不满，选择的道路必须满足以下两个条件：

*   在 KOI 国内任意两个城市之间的简单路径上，征收通行费的道路数量必须不多于 $K$ 条。
*   征收通行费的道路，其两端点城市都必须位于 $i$ 号城市的管辖区域内。

请你编写一个程序，对于所有 $1 \le i \le N$ 的 $i$，分别计算当庆典在 $i$ 号城市举办时，能够获得的最大单日通行费收入。
## 输入格式

第一行给定 $N$ 和 $K$，以空格分隔。

之后 $N-1$ 行。第 $i-1(2 \le i \le N)$ 行给定 $P_i$ 和 $W_i$，以空格分隔。
## 输出格式

总共输出 $N$ 行。第 $i(1 \le i \le N)$ 行输出在 $i$ 号城市举办庆典时的最大单日通行费收入。
## 样例

### 样例输入 #1
```
7 2
1 5
1 5
2 2
2 2
3 2
3 2
```
### 样例输出 #1
```
10
4
4
0
0
0
0
```
### 样例输入 #2
```
7 3
1 5
1 5
2 2
2 2
3 2
3 2
```
### 样例输出 #2
```
14
4
4
0
0
0
0
```
### 样例输入 #3
```
7 3
1 5
1 5
2 3
2 3
3 3
3 3
```
### 样例输出 #3
```
17
6
6
0
0
0
0
```
### 样例输入 #4
```
20 4
1 1
1 2
2 4
3 0
4 7
6 2
4 10
2 9
4 2
2 5
8 1
6 1
11 5
5 9
1 1
16 6
7 10
6 3
8 7
```
### 样例输出 #4
```
78
60
9
41
9
16
10
8
0
0
5
0
0
0
0
6
0
0
0
0
```
## 提示

### 限制条件

*   所有给定的数都是整数。
*   $1 \le K < N \le 300\,000$
*   对于所有 $2 \le i \le N$，满足 $1 \le P_i < i$。
*   对于所有 $2 \le i \le N$，满足 $0 \le W_i \le 10^9$。

### 子任务

1.  (4 分) $N \le 3\,000$。
2.  (5 分) 与三个或更多道路相连的城市最多只有一个。
3.  (11 分) 设连接 1 号城市和 $N$ 号城市的简单路径为 $T$。对于所有城市，最多经过 10 条道路即可移动到路径 $T$ 上的某个城市。
4.  (13 分) $N \le 100\,000$，且对于所有 $2 \le i \le N$，满足 $W_i = 1$。
5.  (8 分) 对于所有 $2 \le i \le N$，满足 $W_i = 1$。
6.  (17 分) $N \le 100\,000$，且对于所有 $2 \le i \le N$，$W_i$ 的值等于 $i$ 号城市管辖区域内所含城市的数量。
7.  (10 分) 对于所有 $2 \le i \le N$，$W_i$ 的值等于 $i$ 号城市管辖区域内所含城市的数量。
8.  (15 分) $N \le 100\,000$。
9.  (17 分) 无额外限制条件。


---

---
title: "[USACO19FEB] Mowing Mischief P"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5244
tag: ['动态规划 DP', '2019', '线段树', 'USACO', '动态规划优化', '决策单调性']
---
# [USACO19FEB] Mowing Mischief P
## 题目描述

Bessie 的表妹 Ella 和 Bella 正在参观农场。不幸的是，自从他们到达以来，他们一直在恶作剧。

在他们的最新计划中，他们决定尽可能多地割草。农场的草地是 $ T \times T $ 的正方形。左下角是 $ (0,0) $ ，右上角是 $ (T,T) $ 。因此，正方形包含 $ (T+1)^2 $ 个格点（具有整数坐标的点）。

Ella 和 Bella 计划从 $ (0,0) $ 开始并以每秒一个单位长度的速度运行到 $ (T,T) $ ，同时每只奶牛都握住非常锋利且非常有弹性的线的一端。任何被这根电线扫过的区域的草都会被切断。Ella 和 Bella 可能采取不同的路径，但她们只会向上或者向右移动，从一个格点移动到另一个格点。

Bessie 非常担心会切割太多的草，所以她发明了一个聪明的计划来限制 Ella 和 Bella 的路径。在整个草原上散布着 $ N $ 种花（ $ 1 \leq N \leq 2 \times 10^5 $ ），每种花都在一个特定的格点上。 Bessie 将从这些花中挑选一个子集 $ S $ ， $ S $ 集合中的花 Ella 和 Bella 都需要经过（Ella 和 Bella 的路径都必须经过 $ S $ 中的所有花朵）。

Ella 和 Bella 将会切割面积尽可能大的草，请帮助Bessie确定集合 $ S $ 使得在 $ S $ 集合尽可能大的情况下被切割的草的**面积**最小。
## 输入格式

输入第一行包括两个数 $ N,T $（$1 \leq T \leq 10^6$）。

接下来 $ N $ 行每行包含两个数 $ x_i,y_i $ ，代表一种花的位置。

保证 $ 1 \leq x_i,y_i \leq T-1 $，且不存在两朵花在同一条水平或竖直线上。
## 输出格式

输出一个整数，即被切割的草的**面积**的最小值。
## 样例

### 样例输入 #1
```
5 20
19 1
2 6
9 15
10 3
13 11
```
### 样例输出 #1
```
117
```
## 提示

选择 $ (10,3) $ 和 $ (13,11) $ 这两个位置上的花，可以使得被切割的草的面积最小。

子任务：对于 $ 20\% $ 的数据， $ N \leq 3200 $ 。


---

---
title: "[USACO22FEB] Phone Numbers P"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8194
tag: ['动态规划 DP', 'USACO', '2022', '动态规划优化', '状态合并']
---
# [USACO22FEB] Phone Numbers P
## 题目描述

Bessie 获得了一个九键的新手机，键位如下所示：

```
123
456
789
```

Bessie 正在匆忙中尝试打出一个给定的电话号码，所以她决定通过用她的其中一个蹄子一次按下多个按钮的方式来节省时间。具体来说，Bessie 的蹄子可能按下一个键，两个共用一条边的键（总共有 $12$ 种可能），或者形成一个正方形的四个键（$1245$，$2356$，$4578$，$5689$）

例如，如果 Bessie 要打的电话号码是 $123659874$，她可能通过如下方法按键来尝试节省时间：

1. 同时按下 $1$ 和 $2$。
2. 按下 $3$。
3. 同时按下 $6,5,9,8$。
4. 同时按下 $7$ 和 $4$。

不幸的是，Bessie 大大高估了她执行这项任务的技能——如果 Bessie 的蹄子同时按下多个按键，那么所有这些按键会以任意顺序输入。所以如果 Bessie 尝试按上述按键顺序，结束时她输入的电话号码可能是 $123596847$ 或 $213659874$（或者其他可能的序列）。

给定一个 Bessie 已经输入的序列，请计算她可能想输入的电话号码的数量对 $10^9+7$ 取模后的值。
## 输入格式

第一行一个整数 $T$（$1\le T\le 10$），表示要求解的独立测试数据组数。

接下来 $T$ 行，每行一个非空且只包含 $1$ 到 $9$ 的数字串。保证输入中所有的数字串总长度不超过 $10^5$。
## 输出格式

对于每组数据，输出 Bessie 可能想输入的电话号码个数对 $10^9+7$ 取模后的值。
## 样例

### 样例输入 #1
```
5
1478
4455
5968
31313211
123659874
```
### 样例输出 #1
```
5
2
24
3
255
```
## 提示

**【样例解释】**

对于第一组数据。Bessie 可能想输入如下五个电话号码之一：

```plain
1478
1487
4178
4187
1748
```

例如，如果 Bessie 想输入 $4187$，她可能会尝试同时按下 $1$ 和 $4$，然后同时按下 $7$ 和 $8$。

对于第三组数据，因为这些数字组成了一个正方形，Bessie 可能想输入的电话是输入序列的任何排列。

**【数据范围】**

- 对于第 $2\sim 3$ 组数据，所有电话号码的长度最多为 $8$。
- 对于第 $4\sim 5$ 组数据，电话号码只包含 $1,2$ 和 $3$。
- 对于第 $6\sim 7$ 组数据，电话号码不包含 $5$。
- 对于第 $8\sim 9$ 组数据，电话号码只包含 $5,6,8,9$。
- 对于第 $10\sim 12$ 组数据，电话号码总长度不超过 $10^2$。
- 对于第 $13\sim 15$ 组数据，电话号码总长度不超过 $10^3$。
- 对于第 $16\sim 18$ 组数据，电话号码总长度不超过 $10^4$。
- 对于第 $19\sim 21$ 组数据，无附加限制。


---

---
title: "[USACO22OPEN] 262144 Revisited P"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8275
tag: ['动态规划 DP', 'USACO', '2022', '区间 DP', '动态规划优化']
---
# [USACO22OPEN] 262144 Revisited P
## 题目描述

Bessie 喜欢在她的手机上下载游戏玩，尽管她确实发现对于她的大蹄子来说使用小触摸屏相当麻烦。

她对目前正在玩的游戏特别着迷。游戏从 $N$ 个 $1\ldots 10^6$ 范围内的正整数组成的序列 $a_1,a_2,\ldots,a_N$（$2\le N\le 262,144$）开始。在一次行动中，Bessie 可以取两个相邻的数字并将它们替换为一个大于两数最大值的数字（例如，她可以将相邻的一对数 $(5,7)$ 替换为 $8$）。游戏在 $N-1$ 次行动后结束，此时只剩下一个数字。游戏目标是**最小化**这个最终的数字。

Bessie 知道这个游戏对你来说太容易了。所以你的任务不仅仅是在 $a$ 上以最优方式玩游戏，而是在 $a$ 的每个连续子段上玩游戏。

输出 $a$ 的所有 $\frac{N(N+1)}{2}$ 个连续子段的最小最终数字之和。
## 输入格式

输入的第一行包含 $N$。

第二行包含 $N$ 个空格分隔的整数，表示输入的序列。
## 输出格式

输出一行，包含所求的和。
## 样例

### 样例输入 #1
```
6
1 3 1 2 1 10
```
### 样例输出 #1
```
115
```
## 提示

共有 $\frac{6\cdot 7}{2}=21$ 个连续子段。例如，连续子段 $[1,3,1,2,1]$ 的最小可能的最终数字是 $5$，可以通过以下操作序列达到：
```
初始     -> [1,3,1,2,1]
合并 1&3 -> [4,1,2,1]
合并 2&1 -> [4,1,3]
合并 1&3 -> [4,4]
合并 4&4 -> [5]
```

以下是每个连续子段的最小可能的最终数字：

```
final(1:1) = 1
final(1:2) = 4
final(1:3) = 5
final(1:4) = 5
final(1:5) = 5
final(1:6) = 11
final(2:2) = 3
final(2:3) = 4
final(2:4) = 4
final(2:5) = 5
final(2:6) = 11
final(3:3) = 1
final(3:4) = 3
final(3:5) = 4
final(3:6) = 11
final(4:4) = 2
final(4:5) = 3
final(4:6) = 11
final(5:5) = 1
final(5:6) = 11
final(6:6) = 10
```

【测试点性质】

- 测试点 2-3 满足 $N\le 300$。
- 测试点 4-5 满足 $N\le 3000$。
- 测试点 6-8 中，输入的序列中所有数的值不超过 $40$。
- 测试点 9-11 中，输入的序列是不下降的。
- 测试点 12-23 没有额外限制。



---

---
title: "「KDOI-03」序列变换"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8864
tag: ['动态规划 DP', '2022', '洛谷原创', 'O2优化', '动态规划优化', '矩阵加速', '四边形不等式']
---
# 「KDOI-03」序列变换
## 题目描述

给定一个长度为 $n$ 的 $\tt01$ 序列 $a$ 和 $q$ 次询问，询问参数 $k$。

每次询问给定 $L,R$，其中 $1\leq L\leq R\leq n$，你可以进行如下操作：

+ 选择一个下标 $L<i\le R$；
+ 将 $a_{i-1}$ 赋值为 $a_{i-1}\oplus a_i$，$a_{i+1}$  赋值为 $a_{i+1}\oplus a_i$。如果 $i=n$，则不对 $a_{i+1}$ 作出改变。其中 $\oplus$ 表示按位异或运算。

求使得 $[L,R]$ 区间内**至多**有 $k$ 个 $\tt1$ 的最小操作次数。询问之间相互独立，也就是说，每次询问后重置为初始序列。
## 输入格式

从标准输入读入数据。

第一行包含三个正整数 $n,k,q$。

第二行包含 $n$ 个非负整数 $a_1,a_2,\cdots,a_n$。

接下来 $q$ 行，每行包含两个正整数 $L,R$，表示一次询问。
## 输出格式

输出到标准输出。

输出共 $q$ 行，每行包含一个整数，表示答案。
## 样例

### 样例输入 #1
```
5 1 2
1 1 1 0 1
2 3
1 3
```
### 样例输出 #1
```
1
1
```
### 样例输入 #2
```
20 3 22
0 0 1 1 1 1 1 0 0 0 0 0 1 0 1 0 0 1 0 1 
12 15
1 6
5 10
2 5
9 18
6 17
2 13
4 16
2 8
9 19
10 15
7 15
1 3
14 18
6 17
12 14
7 16
14 18
11 12
3 5
3 6
3 15

```
### 样例输出 #2
```
0
1
0
0
0
6
3
5
1
0
0
0
0
0
6
0
0
0
0
0
1
3

```
## 提示

**【样例 1 解释】**

如图，用绿色代表 $\tt0$，红色代表 $\tt1$，初始序列如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/hxw9knxu.png)

对于第 $1$ 次询问，选择 $i=3$，则序列变为下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/zvb2lfi8.png)

对于第 $2$ 次询问，选择 $i=2$，则序列变为下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/wubvxvaa.png)

**【样例 2 解释】**

对于第 $1$ 次询问，由于 $a_{12},a_{13},a_{14},a_{15}$ 中只有 $2$ 个 $\tt1$，所以不需要进行任何操作。

对于第 $6$ 次询问，可以依次选择 $i=\{7,8,9,10,11,12\}$。

**【样例 3】**

见选手文件中的 `control/control3.in` 与 `control/control3.ans`。

此样例满足测试点 $7\sim10$ 的限制。

**【样例 4】**

见选手文件中的 `control/control4.in` 与 `control/control4.ans`。

此样例满足测试点 $15\sim17$ 的限制。

**【样例 5】**

见选手文件中的 `control/control5.in` 与 `control/control5.ans`。

此样例满足测试点 $18\sim21$ 的限制。

***

**【数据范围】**

对于 $100\%$ 的数据， $2\le n\le 3~000$，$1\le k\le 
\min(n,1~000)$，$1\le q\le 5\times10^5$，$0\le a_i\le 1$。


|测试点编号|$n\le$|$k\le$|$q\le$|特殊性质|
|:--:|:--:|:--:|:--:|:--:|
|$1\sim3$|$80$|$50$|$2~000$|无|
|$4\sim6$|$400$|$300$|$1$|$k$ 是偶数|
|$7\sim10$|$400$|$2$|$10~000$|无|
|$11\sim14$|$400$|$300$|$10~000$|无|
|$15\sim17$|$3~000$|$10$|$5\times10^5$|无|
|$18\sim21$|$3~000$|$1~000$|$5\times10^5$|$k$ 是偶数|
|$22\sim25$|$3~000$|$1~000$|$5\times10^5$|无|





---

---
title: "[NOI2023] 深搜"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9480
tag: ['线段树', '2023', 'NOI', '离散化', 'O2优化', '动态规划优化', '树形 DP', '容斥原理']
---
# [NOI2023] 深搜
## 题目描述

深度优先搜索是一种常见的搜索算法。通过此算法，我们可以从一个无重边、无自环的无向连通图 $G = (V, E)$，和某个出发点 $s$，得到一棵树 $T$。

算法的流程描述如下:

1. 将栈 $S$ 设置为空，并令 $T = (V, \emptyset)$，即 $T$ 的边集初始为空。
2. 首先将出发点 $s$ 压入 $S$ 中。
3. 访问栈顶节点 $u$，并将 $u$ 标记为“已访问的”。
4. 如果存在与 $u$ 相邻且未被访问的节点，则**任意地**从这些节点中挑选一个记为 $v$。我们将边 $(u, v)$ 加入 $T$ 的边集中，并将 $v$ 压入栈 $S$ 中，然后**回到步骤 3**。若不存在这样的节点，则从栈中弹出节点 $u$。

可以证明，当图 $G$ 为连通图时，该算法会得到图的某一棵生成树 $T$。但**算法得到的树 $T$ 可能不是唯一的，它取决于搜索的顺序，也就是算法的第 4 步所选取的顶点**。指定出发点 $s$ 后，如果能够选取一种特定的搜索顺序，使得算法得到的树恰好是 $T$，则我们称 **$T$ 是 $G$ 的一棵 $s$-dfs 树**。

现在给定一棵 $n$ 个顶点的树 $T$，顶点编号为 $1 \sim n$，并额外给出 $m$ 条边。我们保证这 $m$ 条边两两不同，连接不同的顶点，且与 $T$ 中的 $n - 1$ 条树边两两不同。我们称额外给出的 $m$ 条边为**非树边**。在这 $n$ 个顶点中，我们指定了恰好 $k$ 个顶点作为**关键点**。

现在你想知道，有多少种选取这 $m$ 条非树边的方法（可以全部不选），使得：将 $T$ 的边与被选中的非树边构成图 $G$ 之后，存在某个**关键点** $s$，使得 $T$ 是 $G$ 的一棵 $s$-dfs 树。

由于答案可能十分巨大，你只需要输出方案数在模 $(10 ^ 9 + 7)$ 意义下的值。
## 输入格式

输入的第一行包含一个整数 $c$，表示测试点编号。$c = 0$ 表示该测试点为样例。

输入的第二行包含三个正整数 $n, m, k$，分别表示顶点个数，非树边的数量，关键点的数量。

接下来 $n - 1$ 行，每行包含两个正整数 $u, v$ 表示树 $T$ 的一条边。保证这 $n - 1$ 条边构成了一棵树。

接下来 $m$ 行，每行包含两个正整数 $a, b$ 表示一条非树边。保证 $(a, b)$ 不与树上的边重合，且没有重边。

输入的最后一行包含 $k$ 个正整数 $s_1, s_2, \dots, s_k$，表示 $k$ 个关键点的编号。保证 $s_1, s_2, \dots, s_k$ 互不相同。
## 输出格式

输出一行包含一个非负整数，表示方案数在模 $(10 ^ 9 + 7)$ 意义下的值。
## 样例

### 样例输入 #1
```
0
4 2 2
1 2
2 3
3 4
1 3
2 4
2 3

```
### 样例输出 #1
```
3

```
### 样例输入 #2
```
见附件中的 dfs/dfs2.in。
```
### 样例输出 #2
```
见附件中的 dfs/dfs2.ans。
```
### 样例输入 #3
```
见附件中的 dfs/dfs3.in。
```
### 样例输出 #3
```
见附件中的 dfs/dfs3.ans。
```
### 样例输入 #4
```
见附件中的 dfs/dfs4.in。
```
### 样例输出 #4
```
见附件中的 dfs/dfs4.ans。
```
### 样例输入 #5
```
见附件中的 dfs/dfs5.in。
```
### 样例输出 #5
```
见附件中的 dfs/dfs5.ans。
```
### 样例输入 #6
```
见附件中的 dfs/dfs6.in。
```
### 样例输出 #6
```
见附件中的 dfs/dfs6.ans。
```
## 提示

**【样例解释 #1】**

在这个样例中，有三种选取非树边的方法：只选取边 $(1, 3)$，只选取边 $(2, 4)$，或不选取任何条非树边。

如果只选取边 $(1, 3)$，或者不选取任何一条非树边，则我们发现 $T$ 都是图 $G$ 的 $3$-dfs 树。指定的搜索顺序如下：
1. 将 $3$ 放入栈 $S$ 中。此时 $S = [3]$。
2. 将 $3$ 标记为“已访问的”。
3. 由于 $3$ 与 $2$ 相连，且 $2$ 是“未访问的”，将 $2$ 放入栈 $S$ 中，并将 $(3, 2)$ 加入树 $T$ 中，此时 $S = [3, 2]$。
4. 将 $2$ 标记为“已访问的”。
5. 由于 $2$ 与 $1$ 相连，且 $1$ 是“未访问的”，将 $1$ 放入栈 $S$ 中，并将 $(2, 1)$ 加入树 $T$ 中，此时 $S = [3, 2, 1]$。
6. 由于与 $1$ 相邻的点都是“已访问的”，将 $1$ 弹出栈，此时 $S = [3, 2]$。
7. 由于与 $2$ 相邻的点都是“已访问的”，将 $2$ 弹出栈，此时 $S = [3]$。
8. 由于 $3$ 与 $4$ 相连，且 $4$ 是“未访问的”，将 $4$ 放入栈 $S$ 中，并将 $(3, 4)$ 加入树 $T$ 中，此时 $S = [3, 4]$。
9. 由于与 $4$ 相连的点都是“已访问的”，将 $4$ 弹出栈，此时 $S = [3]$。
10. 由于与 $3$ 相连的点都是“己访问的”，将 $3$ 弹出栈，此时 $S$重新变为空。

如果只选取边 $(2, 4)$，则我们可以说明 $T$ 是图 $G$ 的 $2$-dfs 树。指定的搜索顺序如下：

1. 将 $2$ 放入栈 $S$ 中。此时 $S = [2]$。
2. 将 $2$ 标记为“已访问的”。
3. 由于 $2$ 与 $3$ 相连，且 $3$ 是“未访问的”，将 $3$ 放入栈 $S$ 中，并将 $(2, 3)$ 加入树 $T$ 中，此时 $S = [2, 3]$。
4. 将 $3$ 标记为“已访问的”。
5. 由于 $3$ 与 $4$ 相连，且 $4$ 是“未访问的”，将 $4$ 放入栈 $S$ 中，并将 $(3, 4)$ 加入树 $T$ 中，此时 $S = [2, 3, 4]$。
6. 由于与 $4$ 相邻的点都是“己访问的”，将 $4$ 弹出栈，此时 $S = [2, 3]$。
7. 由于与 $3$ 相邻的点都是“已访问的”，将 $3$ 弹出栈，此时 $S= [2]$。
8. 由于 $2$ 与 $1$ 相连，且 $1$ 是“未访问的”，将 $1$ 放入栈 $S$ 中，并将 $(2, 1)$ 加入树 $T$ 中，此时 $S = [2, 1]$。
9. 由于与 $1$ 相连的点都是“已访问的”，将 $1$ 弹出栈此时 $S = [2]$。
10. 由于与 $2$ 相连的点都是“已访问的”，将 $2$ 弹出栈，此时 $S$ 重新变为空。

**【样例解释 #2】**

这个样例满足测试点 $4 \sim 6$ 的约束条件。

**【样例解释 #3】**

这个样例满足测试点 $10 \sim 11$ 的约束条件。

**【样例解释 #4】**

这个样例满足测试点 $12 \sim 13$ 的约束条件。

**【样例解释 #5】**

这个样例满足测试点 $14 \sim 16$ 的约束条件。

**【样例解释 #6】**

这个样例满足测试点 $23 \sim 24$ 的约束条件。

**【数据范围】**

对于所有测试数据保证：$1 \le k \le n \le 5 \times 10 ^ 5$，$1 \le m \le 5 \times 10 ^ 5$。

|测试点编号|$n \le$|$m \le$|$k \le$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$1 \sim 3$|$6$|$6$|$n$|无|
|$4 \sim 6$|$15$|$15$|$6$|无|
|$7 \sim 9$|$300$|$300$|$6$|无|
|$10 \sim 11$|$300$|$300$|$n$|A|
|$12 \sim 13$|$300$|$300$|$n$|B|
|$14 \sim 16$|$300$|$300$|$n$|无|
|$17 \sim 18$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|A|
|$19 \sim 21$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|B|
|$22$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|无|
|$23 \sim 25$|$5 \times 10 ^ 5$|$5 \times 10 ^ 5$|$n$|无|

特殊性质 A：保证在 $T$ 中，$i$ 号点与 $i + 1$ 号点相连（$1 \le i < n$）。

特殊性质 B：保证若将 $T$ 的边与所有 $m$ 条非树边构成一个图 $G$，则 $T$ 是 $G$ 的棵 $1$-dfs 树。

**请注意，$1$ 号点不一定是 $k$ 个关键点之一。**


---


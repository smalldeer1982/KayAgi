---
title: "「FAOI-R2」Program of atom(x) 2027"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10038
tag: ['动态规划 DP', '2024', '洛谷原创', 'Special Judge', 'O2优化', '区间 DP', '构造']
---
# 「FAOI-R2」Program of atom(x) 2027
## 题目背景

这是来自 $2027$ 年的 FAOI 的一道题目，是一道带有 SPJ 的传统题。

------------

自从 [krjt](https://www.luogu.com.cn/user/691537) 上次被 $160$ 人 [JC](https://www.luogu.com.cn/problem/T269289) 后，他换了一个「量子密码锁」，并用它锁上了自己的电脑包——打不开密码锁，就取不出包里的电脑。理论上，一旦 krjt 忘了密码，就连造这把锁的人也打不开。

然而，这把锁并非固若金汤。~~有一天，krjt 突然对化学产生了浓厚的兴趣。他拿起那把锁，放在酒精灯上加热，结果发现：~~ 在高温环境下，这把锁内的原子（严格来说是「离子」，下同）排布变得不稳定，这将导致它瘫痪。
## 题目描述

krjt 找来了密码锁的说明书：

> 在密码锁中，有一条长度为 $n$（不能更改，$n$ 的具体取值见密码锁铭牌）的链，链上共有 $n$ 个结点。每个结点上可以存放至多一个原子。初始时，$1,2,\ldots,n$ 号原子以某个顺序（可以由用户自行调整）被存放在其中，每个结点存放一个原子。
> 
> 定义 $i$ 号原子的电荷量为 $i!=1 \times 2\times 3 \times \ldots \times i$。
> 
> 现有一个计时器 $b$（单位为秒），其初值为 $0$。
>
> 密码锁被加热后，以下事件**依次循环发生**，直至达成终止条件：
> 
> 1. 位于链两端的原子被移除（**这不会使链变短**），**不再对后续事件产生影响**；
> 2. 判定终止条件：
>    - 若此时链中剩下**不多于 $1$ 个**原子（**也可以是 $0$ 个**），则**达成终止条件**，密码锁瘫痪（**此时计时器 $b$ 的值不会增加 $1$**）；
>    - 否则，将计时器 $b$ 的值增加 $1$。
> 3. 给每个原子标定运动方向（**标定的运动方向是临时的，只生效一次，在下一次标定前会被重置**）：
>    - 计算它左边所有原子的电荷量之和，设计算结果为 $x$；
>    - 计算它右边所有原子的电荷量之和，设计算结果为 $y$；
>    - 如果 $x<y$，则标定方向为「向左」；
>    - 如果 $x>y$，则标定方向为「向右」；
>    - 可以证明，$x \ne y$。
> 4. 所有原子按照所标定的运动方向，移动一条边的距离，来到相邻的结点。

此外，krjt 从铭牌上读取到了 $n$ 的值。

krjt 定义，密码锁的瘫痪用时，为它瘫痪时 $b$ 的值。当然，krjt 希望密码锁尽量安全，因此他想**最大化密码锁的瘫痪用时**。

~~为了不让更多人再次 JC krjt~~，请问：他该如何排列密码锁中 $n$ 个原子的初始顺序？
## 输入格式

一行一个正整数，$n$。
## 输出格式

一行 $n$ 个正整数，一个 $1 \sim n$ 的排列，表示你给 krjt 规划的排列方案：从左到右（或者从右到左，可以证明它们的瘫痪用时相等）依次输出 $n$ 个原子的编号。

**答案可能有多个，输出一个即可。**
## 样例

### 样例输入 #1
```
1
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
2
```
### 样例输出 #2
```
1 2
```
### 样例输入 #3
```
3
```
### 样例输出 #3
```
2 1 3
```
### 样例输入 #4
```
4
```
### 样例输出 #4
```
4 2 3 1
```
### 样例输入 #5
```
5
```
### 样例输出 #5
```
5 4 1 2 3
```
### 样例输入 #6
```
6
```
### 样例输出 #6
```
2 4 5 1 6 3
```
## 提示

**样例解释：**

$6$ 个样例的瘫痪用时分别为 $0,0,0,1,1,2$ 秒。

实际上，枚举可知：当 $n \le 6$ 时，输出任何一个 $1 \sim n$ 的排列都能 AC。

下面对样例 $6$ 进行模拟。在链的描述中：

- $0$ 表示该结点为空；
- $i$ 表示该结点上存放着 $i$ 号原子；
- $(x,y)$ 为计算结果。

1. **初始的链**为 $\color{blue}2-4-5-1-6-3$；
2. $b$ 初始为 $0$；
3. **位于两端的原子被移除**，链变为 $\color{blue}0-4-5-1-6-0$；
4. $b$ 增加至 $1$；
5. **计算**，$4$ 个原子（从左向右）的结果分别为 $(\color{red}0\color{black},841),(\color{red}24\color{black},721),(\color{red}144\color{black},720),(145,\color{red}0\color{black})$；
6. 根据结果，左边 $3$ 个原子（$4,5,1$）**向左运动**，最右边的原子（$6$）**向右运动**，链变为 $\color{blue}4-5-1-0-0-6$；
7. **位于两端的原子被移除**，链变为 $\color{blue}0-5-1-0-0-0$；
8. $b$ 增加至 $2$；
9. **计算**，$2$ 个原子（从左向右）的结果分别为 $(\color{red}0\color{black},1),(120,\color{red}0\color{black})$；
10. 根据结果，左边的原子（$5$）**向左运动**，右边的原子（$1$）**向右运动**，链变为 $\color{blue}5-0-0-1-0-0$；
11. **位于两端的原子被移除**，链变为 $\color{blue}0-0-0-1-0-0$；
11. 此时链中只剩下 $1$ 个原子（$1$），**反应结束，密码锁瘫痪**。

综上，样例 $6$ 的瘫痪用时为 $2$ 秒。

------------

本题共 $100$ 个测试点，分别有 $n=1,2,\ldots,100$，每个 $1$ 分。

对于 $100\%$ 的数据，$1 \le n \le 100$。


---

---
title: "[USACO24FEB] Minimum Sum of Maximums P"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10197
tag: ['动态规划 DP', 'USACO', '2024', 'O2优化', '区间 DP']
---
# [USACO24FEB] Minimum Sum of Maximums P
## 题目描述

Bessie 有一行 $N$（$2\le N\le 300$）块瓷砖，依次具有丑陋度 $a_1,a_2,\ldots,a_N$（$1\le a_i\le 10^6$）。其中 $K$（$0\le K\le \min(N,6)$）块瓷砖卡住了；具体地，索引为 $x_1,\ldots,x_K$（$1\le x_1<x_2<\cdots<x_K\le N$）的瓷砖。

Bessie 想要最小化瓷砖的总丑陋度，其中总丑陋度定义为每对相邻瓷砖的最大丑陋度之和；即 $\sum\limits^{N−1}_{i=1}\max(a_i,a_{i+1})$。她可以任意次执行以下操作：选择两块均未卡住的瓷砖，并交换它们。

求 Bessie 以最优方案执行操作可以达到的最小总丑陋度。 
## 输入格式

输入的第一行包含 $N$ 和 $K$。

第二行包含 $a_1,\ldots,a_N$。

第三行包含 $K$ 个索引 $x_1,\ldots,x_K$。 
## 输出格式

输出最小可能的总丑陋度。 
## 样例

### 样例输入 #1
```
3 0
1 100 10
```
### 样例输出 #1
```
110
```
### 样例输入 #2
```
3 1
1 100 10
2
```
### 样例输出 #2
```
200
```
### 样例输入 #3
```
4 2
1 3 2 4
2 3
```
### 样例输出 #3
```
9
```
## 提示

### 样例解释 1

Bessie 可以交换第二块和第三块瓷砖，使得 $a=[1,10,100]$，达到总丑陋度 $\max(1,10)+\max(10,100)=110$。或者，她也可以交换第一块和第二块瓷砖，使得 $a=[100,1,10]$，同样达到总丑陋度 $\max(100,1)+\max(1,10)=110$。

### 样例解释 2

瓷砖的初始总丑陋度为 $\max(1,100)+\max(100,10)=200$。Bessie 只允许交换第一块和第三块瓷砖，这并不能使她能够减少总丑陋度。

### 测试点性质

- 测试点 $5$：$K=0$。
- 测试点 $6-7$：$K=1$。
- 测试点 $8-12$：$N\le 50$。
- 测试点 $13-24$：没有额外限制。


---

---
title: "矩阵链排序问题"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P1753
tag: ['动态规划 DP', '图论', '区间 DP', '图论建模', '可并堆', 'Ad-hoc']
---
# 矩阵链排序问题
## 题目描述

给定 $n$ 个矩阵，已知第 $i$ 个矩阵 $M_i$ 的大小为 $w_i$ 行 $w_{i+1}$ 列，而我们并不关心其内容。我们考虑将其按照顺序相乘（称其为链乘积）：

$$ M = M_1 \times M_2 \times \cdots \times M_n $$

矩阵乘法并不满足交换律，但是其满足结合律，因此我们可以通过合理安排结合顺序，尽可能减少需要的运算次数。在此题中，我们定义将一个大小为 $a \times b$ 的矩阵乘以一个大小为 $b \times c$ 的矩阵需要 $abc$ 次运算。

请你算出将题目所给的 $n$ 个矩阵进行链乘积所需的最少运算数。为了方便起见，你不需要构造方案。
## 输入格式

输入的第一行为一个正整数 $n$，代表矩阵的数量。

接下来的一行包含 $n+1$ 个正整数，其中第 $i$ 个整数为 $w_i$，含义参考题目描述。
## 输出格式

输出包含一个整数，代表最小运算次数。
## 样例

### 样例输入 #1
```
3
5 3 2 6
```
### 样例输出 #1
```
90
```
## 提示

样例解释：样例告诉我们有 $n = 3$ 个矩阵，其大小分别是 $5 \times 3$，$3 \times 2$ 和 $2 \times 6$。分别考虑两种乘法顺序：

- 先将 $M_1$ 和 $M_2$ 相乘得到一个 $5 \times 2$ 的矩阵，然后和 $M_3$ 相乘，此时运算次数为 $5 \times 3 \times 2 + 5 \times 2 \times 6 = 90$；
- 先将 $M_2$ 和 $M_3$ 相乘得到一个 $3 \times 6$ 的矩阵，然后和 $M_1$ 相乘，此时运算次数为 $3 \times 2 \times 6 + 5 \times 3 \times 6 = 126$。

本题要求运算次数最少，因此答案为 $90$。

---

对所有的数据，$1 \leq n \leq 2 \times 10^6$，$1 \leq w \leq 10^4$。其中：

- 对 $30\%$ 的数据，满足 $n \leq 500$；
- 对另外 $30\%$ 的数据，满足 $n \leq 2 \times 10^5$。


---

---
title: "[JSOI2007] 祖玛"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P2145
tag: ['动态规划 DP', '2007', '各省省选', '江苏', '区间 DP']
---
# [JSOI2007] 祖玛
## 题目背景

管理员备注：本题可能是错题。

2025.1.27 update：现在不是错题（UOJ941）。
## 题目描述

这是一个流行在 Jsoi 的游戏，名称为祖玛。

精致细腻的背景，外加神秘的印加音乐衬托，彷佛置身在古老的国度里面，进行一个神秘的游戏——这就是著名的祖玛游戏。祖玛游戏的主角是一只石青蛙，石青蛙会吐出各种颜色的珠子，珠子造型美丽，并且有着神秘的色彩。

环绕着石青蛙的是载着珠子的轨道，各种颜色的珠子会沿着轨道往前滑动，石青蛙必需遏止珠子们滚进去轨道终点的洞里头，如何减少珠子呢？就得要靠石青蛙吐出的珠子与轨道上的珠子相结合，颜色相同者即可以消失得分！直到轨道上的珠子通通都被清干净为止。 或许你并不了解祖玛游戏。没关系。这里我们介绍一个简单版本的祖玛游戏规则。一条通道中有一些玻璃珠，每个珠子有各自的颜色，如图 1 所示。玩家可以做的是选择一种颜色的珠子（注意：颜色可以任选，这与真实游戏是不同的）射入某个位置。

 ![](https://cdn.luogu.com.cn/upload/pic/1446.png) 

图 2 中玩家选择一颗蓝色珠子，射入图示的位置，于是得到一个图 3 的局面。

当玩家射入一颗珠子后，如果射入的珠子与其他珠子组成了三颗以上连续相同颜色的珠子，这些珠子就会消失。例如，将一颗白色珠子射入图 4 中的位置，就会产生三颗颜色相同的白色珠子。这三颗珠子就会消失，于是得到图 5 的局面。

需要注意的一点是，图 4 中的三颗连续的黄色珠子不会消失，因为并没有珠子射入其中。 珠子的消失还会产生连锁反应。当一串连续相同颜色的珠子消失后，如果消失位置左右的珠子颜色相同，并且长度大于 2，则可以继续消失。例如，图 6 中，射入一颗红色珠子后，产生了三颗连续的红色珠子。当红色珠子消失后，它左右都是白色的珠子，并且一共有四颗，于是白色珠子也消失了。之后，消失位置的左右都是蓝色珠子，共有三颗，于是蓝色珠子也消失。最终得到图 7 的状态。注意，图 7 中的三颗黄色珠子不会消失，因为蓝色珠子消失的位置一边是紫色珠子，另一边是黄色珠子，颜色不同。

除了上述的情况，没有其他的方法可以消去珠子。现在，我们有一排珠子，需要你去消除。对于每一轮，你可以自由选择不同颜色的珠子，射入任意的位置。你的任务是射出最少的珠子，将全部珠子消去。

## 输入格式

第一行一个整数 $n(n \le 500)$，表示珠子的个数 第二行 $n$ 个整数（32 位整数范围内），用空格分割，每个整数表示一种颜色的珠子。

## 输出格式

一个整数，表示最少需要射出的珠子个数。

## 样例

### 样例输入 #1
```
9
1 1 2 2 3 3 2 1 1
```
### 样例输出 #1
```
1
```
## 提示



------------
2024/2/13 添加 2 组 hack 数据。


---

---
title: "[USACO22OPEN] 262144 Revisited P"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8275
tag: ['动态规划 DP', 'USACO', '2022', '区间 DP', '动态规划优化']
---
# [USACO22OPEN] 262144 Revisited P
## 题目描述

Bessie 喜欢在她的手机上下载游戏玩，尽管她确实发现对于她的大蹄子来说使用小触摸屏相当麻烦。

她对目前正在玩的游戏特别着迷。游戏从 $N$ 个 $1\ldots 10^6$ 范围内的正整数组成的序列 $a_1,a_2,\ldots,a_N$（$2\le N\le 262,144$）开始。在一次行动中，Bessie 可以取两个相邻的数字并将它们替换为一个大于两数最大值的数字（例如，她可以将相邻的一对数 $(5,7)$ 替换为 $8$）。游戏在 $N-1$ 次行动后结束，此时只剩下一个数字。游戏目标是**最小化**这个最终的数字。

Bessie 知道这个游戏对你来说太容易了。所以你的任务不仅仅是在 $a$ 上以最优方式玩游戏，而是在 $a$ 的每个连续子段上玩游戏。

输出 $a$ 的所有 $\frac{N(N+1)}{2}$ 个连续子段的最小最终数字之和。
## 输入格式

输入的第一行包含 $N$。

第二行包含 $N$ 个空格分隔的整数，表示输入的序列。
## 输出格式

输出一行，包含所求的和。
## 样例

### 样例输入 #1
```
6
1 3 1 2 1 10
```
### 样例输出 #1
```
115
```
## 提示

共有 $\frac{6\cdot 7}{2}=21$ 个连续子段。例如，连续子段 $[1,3,1,2,1]$ 的最小可能的最终数字是 $5$，可以通过以下操作序列达到：
```
初始     -> [1,3,1,2,1]
合并 1&3 -> [4,1,2,1]
合并 2&1 -> [4,1,3]
合并 1&3 -> [4,4]
合并 4&4 -> [5]
```

以下是每个连续子段的最小可能的最终数字：

```
final(1:1) = 1
final(1:2) = 4
final(1:3) = 5
final(1:4) = 5
final(1:5) = 5
final(1:6) = 11
final(2:2) = 3
final(2:3) = 4
final(2:4) = 4
final(2:5) = 5
final(2:6) = 11
final(3:3) = 1
final(3:4) = 3
final(3:5) = 4
final(3:6) = 11
final(4:4) = 2
final(4:5) = 3
final(4:6) = 11
final(5:5) = 1
final(5:6) = 11
final(6:6) = 10
```

【测试点性质】

- 测试点 2-3 满足 $N\le 300$。
- 测试点 4-5 满足 $N\le 3000$。
- 测试点 6-8 中，输入的序列中所有数的值不超过 $40$。
- 测试点 9-11 中，输入的序列是不下降的。
- 测试点 12-23 没有额外限制。



---

---
title: "[THUPC 2023 决赛] 喵了个喵 III"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9383
tag: ['2023', 'Special Judge', 'O2优化', '区间 DP', 'THUPC']
---
# [THUPC 2023 决赛] 喵了个喵 III
## 题目背景

小 E 玩腻了《喵了个喵》，于是决定换一款消除游戏来玩。然而小 E 发现市面上的消除游戏规则都差不多，比如这个游戏，它的规则和《喵了个喵》只有一个字不相同。虽然说，改了一个字的游戏就是新游戏，但确是缺了点意思。

## 题目描述

这个游戏有一个牌堆和 $n$ 个栈，任务是要通过游戏规则将所有的卡牌消去。开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1,a_2,\cdots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：

- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。如果这么操作后，这个栈最上方的两张牌有相同的图案，则会自动将这两张牌消去。

- 选择两个不同的栈，如果这两个栈栈**顶**的卡牌有相同的图案，则可以将这两张牌消去。如果不同，则什么也不会做。

经过多次观察小 E 发现总是有 $n=2$ 和 $k=m/2$，即只有两个栈且每一种图案的卡牌都恰好有 $2$ 张。虽然如此，小 E 还是一直无法通关。请你帮小 E 设计一下游戏方案，即给出相应的操作序列使得小 E 可以把所有的卡牌消去。

## 输入格式

第一行一个正整数 $m$。  

第二行 $m$ 个正整数，分别表示 $a_1,a_2,\cdots, a_m$。  

保证 $1\sim m/2$ 在序列中各出现两次。
## 输出格式

**本题采用 special judge**。

如果无解，输出一行 `No solution.`。  

如果有解，第一行输出 `Cleared.`。第二行输出一个正整数 $op$，表示操作的次数。你需要保证 $m\le op\le 2m$。  

接下来一行一个长度为 $op$ 的字符串，每一位是一个不超过 $2$ 的非负整数，按顺序表示进行的操作。若为 $1$ 或 $2$，则表示进行一次第一个操作并选择栈 $1$ 或栈 $2$。若为 $0$，则表示进行一次第二个操作。由于只有两个栈，所以你不需要输出额外的信息来说明你选择了哪些栈。
## 样例

### 样例输入 #1
```
4
1 2 1 2
```
### 样例输出 #1
```
Cleared.
5
12202
```
## 提示

### 样例 1 解释
下图是初始状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/ds0k392b.png)

下图是前两次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/iy4w5r9m.png)

![scale=0.24](https://cdn.luogu.com.cn/upload/image_hosting/kb0woz7t.png)

下图是第三次和第四次操作之后的结果。
![](https://cdn.luogu.com.cn/upload/image_hosting/t9zxtszv.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/5z2eyqe2.png)

下图是第五次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/9kr8v9mm.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/z32r81vt.png)


### 数据规模与约定

- 保证 $2\le m \le 1500$ 且为偶数。
- 保证 $1\le a_i \le m/2$ 且每一种数在序列中出现恰好两次。

### 评分方法

你的输出的第一行需要与标准答案一致。

若有解，且在按顺序进行所有操作后，牌堆为空且所有的栈均为空，则认为你的答案正确。

### 后记

**以下部分与本题内容无关。**

说到底，那个嫌《喵了个喵 II》的题面太长的人其实是小 E 自己。它本来的题面中，题目背景和题目描述是这样的：

【题目背景】

小 E 玩腻了《喵了个喵》，于是决定换一款消除游戏来玩。然而小 E 发现市面上的消除游戏规则都差不多，比如这个游戏，它的规则和《喵了个喵》只有略微不相同。虽然说，只要改一个字就是新游戏，但确是缺了点意思。

【题目描述】

这个游戏有一个牌堆和 $n$ 个可以从栈底删除元素的栈，任务是要通过游戏规则将所有的卡牌消去。开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1,a_2,\cdots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：

- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。

- 选择两个不同的栈，如果这两个栈栈**底**的卡牌有相同的图案，则可以将这两张牌消去，原来在栈底上方的卡牌会成为新的栈底。如果不同，则什么也不会做。

经过多次观察小 E 发现总是有 $n=2$ 和 $k=m/4$，并且每一种图案的卡牌都恰好有 $4$ 张。虽然如此，小 E 还是一直无法通关。请你帮小 E 设计一下游戏方案，即给出相应的操作序列使得小 E 可以把所有的卡牌消去。


### 题目来源


来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）决赛。

题解等资源可在 [https://github.com/THUSAAC/THUPC2023](https://github.com/THUSAAC/THUPC2023) 查看。


---


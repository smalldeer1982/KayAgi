---
title: "龙逐千灯幻"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10181
tag: ['线段树', '并查集', '洛谷原创', 'O2优化', '凸完全单调性（wqs 二分）', '洛谷月赛', '根号分治', '单调栈']
---
# 龙逐千灯幻
## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/6w2vttoo.png)

龙年到，帆帆也举起了自己的彩龙灯，他自己也要变成大彩龙啦！
## 题目描述

帆帆一共有 $n$ 盏龙灯，第 $i$ 盏的颜色是 $a_i$。

帆帆认为一段区间 $[l,r]$ 的美观度 $f(l,r)$ 为 $a_l\cdots a_r$ 中的不同颜色个数。

帆帆准备带着自己的龙灯去玩，他一共计划去玩 $m$ 天，第 $i$ 天，他会带着自己的 $1\cdots x_i$ 号龙灯，但是他发现如果把很多龙灯装在一起，那么别人只会注意到其中有多少种不同的颜色。

因此帆帆准备把这 $x_i$ 个龙灯按照编号顺序分成恰好 $k_i$ 个区间，满足每盏灯恰好在一个区间内。

那么帆帆这次出行的美观度就为所有区间的美观度的和。

请你帮帮帆帆最大化每一次出行的美观度。


## 输入格式

第一行五个整数 $n,m,id,seed,limx$，分别代表序列长度，询问次数，以及 $\texttt{subtask}$ 编号（样例中的 $id=0$），随机数种子，以及一个和询问有关的参数 $limx$。

因为本题输入量过大，因此采用如下方式生成询问：

我们使用下面的代码生成一个伪随机数列：

```cpp
uint64_t PRG_state;
uint64_t get_number()
{
    PRG_state ^= PRG_state << 13;
    PRG_state ^= PRG_state >> 7;
    PRG_state ^= PRG_state << 17;
    return PRG_state;
}
int readW(int l,int r)
{
	return get_number()%(r-l+1)+l;
}
```

一开始 `PRG_state=seed`，你每次调用 `readW(l,r)` 会返回一个 $[l,r]$ 内的随机数。

第二行 $n$ 个整数，第 $i$ 个整数代表 $a_i$。

设 $x_i,k_i,c_i$ 表示第 $i$ 组询问需要的参数 $x,k,c$，其中 $c$ 的作用见输出格式，那么所有询问的参数可以用以下程序生成：

```cpp
for (int i = 1; i <= m; ++i) {
	x[i] = readW(limx, n);
	k[i] = readW(1, x[i]);
	c[i] = readW(0, 1e7);
}
```

注：**请不要在运行上述代码段获得各组询问的参数之前调用 `readW()` 函数，否则无法获得正确的询问信息。** 本题不需要利用该伪随机数生成器的特殊性质，你只需将  `get_number()` 视为一个每次调用独立且均匀随机地生成一个无符号 $64$ 位整数的生成器即可。本题也不需要优化伪随机数生成器的内部实现。
## 输出格式

为了减少输出量，我们使用如下方式进行信息压缩：

如果第 $i$ 组询问的答案为 $ans_i$，其生成参数为 $c_i$，那么你需要输出：

$$\bigoplus\limits_{i=1}^m(ans_i\times c_i)$$

其中 $\bigoplus $ 为异或运算，该值显然一定位于 `long long` 能表示的整数范围内。
## 样例

### 样例输入 #1
```
5 5 0 956144375 1
2 4 1 5 2 

```
### 样例输出 #1
```
21971409
```
### 样例输入 #2
```
10 10 0 478178732 1
2 2 1 1 2 1 2 1 2 1 

```
### 样例输出 #2
```
2834792
```
## 提示

### 【样例1解释】

询问分别是：

```
3 1 6121576
5 3 3089509
1 1 4506170
3 1 2821007
1 1 7941511
```

答案分别是:

```
3
5
1
3
1
```

对于第一组询问，要分成一个区间，那么就是 $[1,3]$，美观度就是 $f(1,3)=3$ 。

对于第二组询问，最优的方案是分成 $[1,3],[4,4],[5,5]$，美观度是 $f(1,3)+f(4,4)+f(5,5)=5$

后三个询问同理。

### 【样例2解释】

询问分别是：

```
8 4 6858024
3 2 236530
2 2 8140891
5 3 4562139
8 7 4749403
7 4 4319971
5 1 5063575
3 1 7343109
6 2 1566851
3 1 7959241
```

询问答案分别是：

```
7
3
2
5
8
7
2
2
4
2
```

### 【数据范围】

本题采用捆绑测试。

- 子任务一（$10$ 分）：$1 \leq n\leq 500$。
- 子任务二（$15$ 分）：$1\leq n\leq 3000$。
- 子任务三（$15$ 分）：$m=1$。
- 子任务四（$20$ 分）：$1\le a_i\le 30$。
- 子任务五（$20$ 分）：$1\leq n\leq 4\times 10^4$。
- 子任务六（$20$ 分）：无特殊限制。


对于 $100\%$ 的数据，$1 \leq n\leq 10^5$，$1\leq  m\leq 10^6$，$0\leq seed\leq 10^9$，$1\leq limx\leq n$，$1\leq a_i\leq n$。


---

---
title: "[USACO21JAN] Minimum Cost Paths P"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7294
tag: ['二分', 'USACO', '2021', 'O2优化', '凸包', '单调栈', '组合优化', '保序回归']
---
# [USACO21JAN] Minimum Cost Paths P
## 题目描述

Farmer John 的牧草地可以看作是一个$N×M$（$2≤N≤10^9, 2≤M≤2⋅10^5$）的正方形方格组成的二维方阵（想象一个巨大的棋盘）。对于 $x∈[1,N],y∈[1,M]$，从上往下第 $x$ 行、从左往右第 $y$ 列的方格记为 $(x,y)$。此外，对于每一个 $y∈[1,M]$，第 $y$ 列拥有一个代价 $c_y$（$1≤c_y≤10^9$）。

Bessie 从方格 $(1,1)$ 出发。如果她现在位于方格 $(x,y)$，则她可以执行以下操作之一：

-  如果 $y<M$，Bessie 可以以 $x^2$ 的代价移动到下一列（$y$ 增加一）。
- 如果 $x<N$，Bessie 可以以 $c_y$ 的代价移动到下一行（$x$ 增加一）。 

给定 $Q$（$1≤Q≤2⋅10^5$）个独立的询问，每个询问给定 $(x_i,y_i)$（$x_i∈[1,N],y_i∈[1,M]$），计算 Bessie 从 $(1,1)$ 移动到 $(x_i,y_i)$ 的最小总代价。
## 输入格式

输入的第一行包含 $N$ 和 $M$。

第二行包含 $M$ 个空格分隔的整数 $c_1,c_2,…,c_M$。

第三行包含 $Q$。 

最后 $Q$ 行每行包含两个空格分隔的整数 $x_i$ 和 $y_i$。
## 输出格式

输出 $Q$ 行，为每个询问的答案。

注意本题计算中所使用的整数大小可能需要使用 64 位整数型（例如，C/C++ 中的 long long）。
## 样例

### 样例输入 #1
```
5 4
1 100 100 20
20
1 1
2 1
3 1
4 1
5 1
1 2
2 2
3 2
4 2
5 2
1 3
2 3
3 3
4 3
5 3
1 4
2 4
3 4
4 4
5 4
```
### 样例输出 #1
```
0
1
2
3
4
1
5
11
19
29
2
9
20
35
54
3
13
29
49
69
```
## 提示

#### 样例 1 解释

输出以方阵形式表示如下：

```
    1  2  3  4
  *--*--*--*--*
1 | 0| 1| 2| 3|
  *--*--*--*--*
2 | 1| 5| 9|13|
  *--*--*--*--*
3 | 2|11|20|29|
  *--*--*--*--*
4 | 3|19|35|49|
  *--*--*--*--*
5 | 4|29|54|69|
  *--*--*--*--*
```

#### 测试点性质：

 - 测试点 1-3 满足 $N,M≤2000$。
 - 测试点 4-8 满足 $c_2>c_3>⋯>c_M$。
 - 测试点 9-15 满足 $N≤2⋅10^5$。
 - 测试点 16-20 没有额外限制。

供题：Benjamin Qi 


---


---
title: "[HNOI2013] 旅行"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P3229
tag: ['数学', '2013', '单调队列', '湖南', '高斯消元']
---
# [HNOI2013] 旅行
## 题目描述

在遥远的 HX 国，住着一个旅行家小 L，他希望骑着他的自行车游遍全国。在这个国家中，每个城市都有一个编号，共有 $n$ 个城市，编号从 $1$ 到 $n$。

有的城市没有小 L 想去的景点，而有的城市有且仅有一个小 L 想去的景点，所有的城市都是这两种情况之一，小 L 非常热爱信息学，他编写程序给他的旅行安排了一条最短路线以到达所有他想去的景点（所有的通知旅行线路上城市编号是乱序的）：他第 $1$ 个到达的城市编号为 $a_1$，第 $i$ 个到达的城市编号为 $a_i$，最后到达城市 $a_n$ 结束这次旅行。小L希望用恰好的 $m$ 个月（$m<n$）的时间完成这次旅行，所以他需要制定一个理性的旅游计划。

当他抵达一个城市时，如果这个城市有他想要去的景点，他会因此获得 $1$ 点快乐值；但是若到达的城市没有他想去的景点，他会因旅途的疲惫得到 $1$ 点的疲劳值：一个月的时间足够他游玩任意多个城市，但他也希望拿出一点时间来休息。他每个月总是在本月所到达的最后一个城市休息（但如果这个城市有景点，那么小 L 总会游玩这个景点再休息）。当然，小 L 希望每个月都能有一定的旅行任务。即便这个月他所到达的城市中并没有他想去的的景点，换句话说，每个月他都会至少到达一个新的城市。

小 L 无法自己安排旅行计划，所以求助于你。你需要告诉他一个序列：$x_1,x_2,\ldots,x_m$，其中 $x_i$ 表示小 L 第 $i$ 个月休息时。他所在的城市编号：由于他最后一个月必须完成他的旅行，所以 $x_m$ 肯定等于 $a_n$，例如，设 $n=5$，$m=3$，$(a_1,a_2,a_3,a_4,a_5)=(3,2,4,1,5)$，$(x_1,x_2,x_3)=(2,1,5)$，这意味着：第 $1$ 个月先后到达 $3$ 号和 $2$ 号城市，并在 $2$ 号城市休息：第 $2$ 个月先后到达 $4$ 号和 $1$ 号城市，并在 $1$ 号城市休息：第 $3$ 个月到达 $5$ 号城市，并在 $5$ 号城市休息。

这样的方案序列有很多种，设每种方案序列中第 $i$ 个月旅行中当月获得的快乐值与疲劳值的差绝对值为 $d_i$，设第 $k$ 种方案序列中求出的 $d_1,d_2,\ldots,d_m$ 这个 $m$ 值的最大值为 $c_k$，小 L 希望所选择的方案序列的 $c_k$ 在所有方案序列中是最小的。

事实上，可能有多个方案序列的 $c_k$ 达到并列最小值。由于小 L 喜爱编程，他患上了一定的强迫症（虽然他自己认为他的强迫症让他炫的发黄），他希望给他的序列是这多个方案中字典序最小的。

Tips：比较两个序列字典序即比较第一个不相同数字的大小，如 $(1,2,3,4)<(1,2,4,3)$。
## 输入格式

第一行为两个空格隔开的正整数 $n, m$，表示旅行的城市数与旅行所花的月数。

接下来 $n$ 行，其中第 $i$ 行包含两个空格隔开的整数 $A_i$ 和 $B_i$，$A_i$ 表示他第 $i$ 个去的城市编号，$B_i$ 为 $0$ 或 $1$。如果 $B_i=0$ 则表示城市 $A_i$ 没有小 L 想去的景点，如果 $B_i=1$ 则表示城市 $A_i$ 有小 L 想去的景点，$A_i$ 两两不同且有 $1\leq  A_i\leq N$，即 $\{A_i\}$ 为 $1,2,\ldots,N$ 的一个排列。
## 输出格式

输出仅包含一行，包含 $m$ 个空格隔开的正整数 $X_1,X_2,\ldots,X_m$，即给小 L 安排的旅行计划对应的路线。

## 样例

### 样例输入 #1
```
8  3
2  0
3  1
4  1
1  0
5  0
6  1
7  1
8  0
```
### 样例输出 #1
```
1 6 8
```
## 提示

第 $1$ 个月得到 $2$ 点快乐值与 $2$ 点疲劳值，第 $2$ 个月得到 $1$ 点快乐值与 $1$ 点疲劳值，第 $3$ 个月得到 $1$ 点快乐值与 $1$ 点疲劳值。$3$ 个月中疲劳值与快乐值差的最大值为 $0$，达到所有方案最小值。

可行方案有：

- 1 6 8
- 3 6 8
- 3 1 8

其中 1 6 8 字典序最小。

$N \leq 5 \times 10^5$，$M \leq 2 \times 10^5$。


---

---
title: "[SDOI2017] 苹果树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P3780
tag: ['2017', '各省省选', '单调队列', '山东', 'O2优化', '枚举', '背包 DP']
---
# [SDOI2017] 苹果树
## 题目背景

**警告：滥用本题评测将封号**
## 题目描述

夏天近了，又到了恋爱的季节，小Q家门前的苹果树上结满了红红圆圆的苹果。


这株苹果树是一个有着$n$个结点的有根树，其中结点被依次编号为$1$至$n$。$1$号结点为根，其余每一个结点的父结点一定是某个编号较小的结点。每一个结点上都有一些苹果，第$i$个结点上有$a_i (a_i > 0)$个苹果，每取走其中一个苹果就可以得到$v_i (v_i > 0)$的幸福度（若在这个结点取走$k \leq a_i$个苹果，则可以收获$kv_i$的幸福度）。如果在一个结点取走了至少一个苹果，则必须要在其父结点处取走至少一个苹果。


现在，给定正整数$k$，请从树上取走若干苹果。如果总计取走了$t$个苹果，且所有取了至少一个苹果的那些结点的最大深度为$h$（这里规定根结点的深度为$1$），则要求$t-h \leq k$。问最大可以收获多少的幸福度？（这些幸福度全都归属于恋爱中的小Q。）

## 输入格式

本题有多组测试数据，输入的第一行给定整数$Q$，表示有$Q$组数据。之后依次给出$Q$组数据。

对于每一组数据来说，第一行包含两个整数$n$和$k$。

之后$n$行，每行给出三个整数，描述了每一个结点。其中第$i$行的第一个整数给出了$i$的父结点标号

（如果$i = 1$，则其父结点为$0$），第二个整数为$a_i$，第三个整数为$v_i$。

## 输出格式

输出一共有$Q$行，对应了$Q$组数据。

对于每一组数据，输出一个整数，表示最大可以收获的幸福度。

## 样例

### 样例输入 #1
```
2
5 1
0 1 1
1 1 1
1 1 3
2 1 10
3 1 4
9 15
0 1 1
1 7 2
2 5 10
1 3 1
4 3 17
4 3 18
4 4 19
1 1 1
8 1 100
```
### 样例输出 #1
```
15
316
```
## 提示

有$10\%$的数据，满足$nk \leq 3000000$且给定的树的高度为$2$。

有$20\%$的数据，满足$nk \leq 25000000$且给定的树的高度为$2$。

有$20\%$的数据，满足$nk \leq 25000000$且所有$a_i$均为$1$。

还有$20\%$的数据，满足$nk \leq 3000000$，没有上述额外限制。

对于$100\%$的数据，满足$1 \leq Q \leq 5$；$1 \leq n \leq 20000$；$1 \leq k \leq 500000$；$1 \leq nk \leq 25000000$；$1 \leq a_i \leq 10^8$；$1 \leq v_i \leq 100$。



---

---
title: "[WC2010] 重建计划"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4292
tag: ['2010', '点分治', '单调队列', '分治', 'WC']
---
# [WC2010] 重建计划
## 题目描述

X 国遭受了地震的重创, 导致全国的交通近乎瘫痪，重建家园的计划迫在眉睫。X 国由 $N$ 个城市组成, 重建小组提出，仅需建立 $N-1$ 条道路即可使得任意两个城市互相可达。于是，重建小组很快提出了一个包含 $N-1$ 条道路的方案，并满足城市之间两两可达，他们还计算评估了每条道路 $e$ 建设之后可以带来的价值 $v(e)$。  

由于重建计划复杂而艰难，经费也有一定限制。因此，政府要求第一期重建工程修建的道路数目为 $k$ 条，但需满足 $L \leq k \leq U$，即不应少于$L$ 条，但不超过 $U$ 条。同时，为了最大化利用率，要求建设的这些道路恰好组成一条简单路径，即所建设的 $k$ 条路径可以构成一个排列 $e_1 = (p_1, q_1), e_2 = (p_2, q_2), \cdots , e_k = (p_k, q_k)$， 对于 $1 \leq i < k$， 有$(q_i = p_{i+1})$。 

重建小组打算修改他们的原有方案以满足要求，即在原有的 $N-1$ 条道路中寻找一条路径 $S$ 作为新的方案，使得新方案中的道路平均价值

$$AvgValue = \frac{\sum _{e \in S} v(e)}{|S|}$$

最大。这里 $v(e)$ 表示道路 $e$ 的价值，$|S|$ 表示新方案中道路的条数。请你帮助重建小组寻找一个最优方案。  注: 在本题中 $L$ 和 $U$ 的设置将保证有解。

## 输入格式

第一行包含一个正整数 $N$ ，表示 X 国的城市个数。 

第二行包含两个正整数 $L,U$，表示政府要求的第一期重建方案中修建道路数的上下限。  

接下来的 $N-1$ 行描述重建小组的原有方案，每行三个正整数 $a_i, b_i, v_i$，分别表示道路 $(a_i, b_i)$，其价值为 $v_i$ 。其中城市由$1 \cdots N$标号。
## 输出格式

仅包含一行，为一个实数 $AvgValue$，即最大平均价值。

小数点后保留三位。
## 样例

### 样例输入 #1
```
4 
2 3 
1 2 1 
1 3 2 
1 4 3
```
### 样例输出 #1
```
2.500
```
## 提示

新方案中选择路径 $(3, 1), (1, 4)$ 可以得到的平均价值为 $2.5$，为最大平均价值。

对于20%的数据，$N \leq 5 000$;  

另有30%的数据，$N \leq 100 000$， 原有方案恰好为一条路径(链); 

对于100%的数据，$N \leq 100 000, 1 \leq L \leq U \leq N-1, v_i \leq 10^6$。


---

---
title: "[USACO18OPEN] Train Tracking P"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4373
tag: ['2018', 'USACO', '单调队列', '交互题', 'Special Judge', '分块']
---
# [USACO18OPEN] Train Tracking P
## 题目背景

鉴于本题存在特殊要求且大部分人**不遵守**，题解通道关闭。如确有正解，请联系管理员单独添加。

1. 你的程序不需要，也不应该包含 `grader.h` 头文件。
2. 请在程序中加入如下函数声明语句：

```cpp
int get(int);
void set(int,int);
void shoutMinimum(int);
int getTrainLength();
int getWindowLength();
int getCurrentCarIndex();
int getCurrentPassIndex();
```
## 题目描述

每天早晨特快列车会经过农场，开往大城市，每天下午它又会折回来，回到郊区。今天，Bessie 会花时间观察它，早晨和下午都会。

Bessie 提前知道，列车有 $N$ 节车厢，方便起见，将其编号为 $0\sim N-1$。车厢 $i$ 有一个 ID $c_i$。在早晨和下午，所有的数字都是可见的，所以对于每节车厢 Bessie 有两次机会观察它的 ID。也就是说，当列车早晨经过的时候，Bessie 能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。当列车下午驶回的时候，她又一次能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。 

Bessie 挑选了一个整数 $K$，她想要求出每个连续的 $K$ 节车厢中最小的 ID。她有一本能够帮助执行计算的笔记本，但是这个笔记本相当小，并且 Bessie 的手写（蹄写？）字相当大。比方说，可能没有足够的空间记下所有 $N+1-K$ 个最小值。由于某些神秘的原因，Bessie 满足于当她算出最小数的时候向天哞出这些数，所以这个问题至少还不成问题。

列车马上就要来了！帮助 Bessie 在列车经过两次之后求出这 $N+1−K$ 个最小数，确保她有效地利用她有限的笔记本空间。她的笔记本被分为 $5500$ 个部分，方便起见编号为 $0\sim 5499$，每个部分的空间恰好能够记录一个在 $[-2^{31} , 2^{31}-1]$ 之间的整数。最初的时候，每个部分都记录着整数 $0$。

请帮助 Bessie 有效管理她有限的笔记本空间。

### 交互方式

这是一道交互式题目，你不需要使用标准（或文件）输入输出。具体地说，你需要实现下面的函数，这个函数用来帮助 Bessie 有效管理她有限的笔记本空间：

```cpp
void helpBessie(int ID);
```

每当一节列车车厢经过的时候，无论是在早晨和下午，你的函数都会被调用，函数的输入是这节车厢的 ID。 

你的 `helpBessie` 函数的实现可以调用下面这些函数：

- `int get(int index)`：获取记录在 Bessie 的笔记本上的给定的索引处的整数值（_index_）。
- `void set (int index, int value)`：设置给定的索引（_index_）处的值为给定的整数值（_value_）。
- `void shoutMinimum (int output)`：通知 Bessie 向天哞一个指定的数。
- `int getTrainLength()`：返回列车的车厢数 $N$。
- `int getWindowLength()`：返回窗口的长度 $K$。
- `int getCurrentCarIndex()`：返回当前正在通过的车厢编号。
- `int getCurrentPassIndex()`：如果 Bessie 正在观察早晨的列车返回 $0$，下午的列车返回 $1$。

为了帮助你开始编码，我们为你提供了初始的 C/C++ 模板。遗憾地，这道题目不支持 Python 和 Pascal 语言的程序。

```cpp
#include "grader.h"

// If you find it necessary, you may import standard libraries here.

void helpBessie(int ID)
{
	// Put your code here.
}
```

调用 `void shoutMinimum (int output)` 函数进行输出。

各个窗口的最小数必须按顺序输出（所以车厢 $0,1,\cdots ,K−1$ 之中的最小值必须在车厢 $1,2,\cdots ,K$ 之中的最小值之前输出，等等），但是除了这个顺序的限制之外，你的函数可以在任何一次函数调用中任意多次地输出一些最小值。比如，你的函数可能在某几次调用中不产生任何输出，而在某几次调用中产生多个输出。

Bessie 拥有惊人的短时记忆能力，因此在 `helpBessie` 函数中没有任何的内存使用限制，除了要满足常规的 256MB 限制。然而，在车厢与车厢之间，Bessie 不能够「记住」任何不在笔记本中出现过的内容。所以在两次函数调用之间，你的程序除了通过 `get` 和 `set` 函数调用之外不能保存任何的状态。

这意味着：

**不允许定义任何非常量的全局或静态变量。任何如此做的提交会被取消成绩。教练会人工检查所有的提交以验证是否符合题目要求。由于这个问题无需文件输入输出，所以也不允许在代码中使用任何的文件输入输出**。
## 样例

### 样例输入 #1
```
10 3
5 7 9 2 0 1 7 4 3 6
```
### 样例输出 #1
```
5
2
0
0
0
1
3
3
```
## 提示

对于全部数据，$1\le N\le 10^6,0\le c_i\le 10^9,1\le K\le N$，你的程序进行的 `set` 调用和 `get` 调用的总次数被限制为 $25\times 10^6$ 次。

供题：Dhruv Rohatgi


---

---
title: "不可视境界线[环版本]"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P6455
tag: ['动态规划 DP', '计算几何', '二分', '单调队列', 'Special Judge', '分治', '随机调整', '凸完全单调性（wqs 二分）']
---
# 不可视境界线[环版本]
## 题目背景

- 原题 : [P5617 [MtOI2019]不可视境界线](https://www.luogu.com.cn/problem/P5617)

**附** : [关于本题的`SPJ`和数据的一些信息](https://www.luogu.com.cn/paste/tmwvh5vh)

若出现卡精度或数据出锅,吊打标算等情况,请联系出题人。
## 题目描述

有 $n$ 个半径为 $r$ 的圆,画在一个长度为 $L$ 的首尾相接的纸环上。

所有的圆心都在同一高度,可以看做在纸上画一个数轴然后卷起来,圆心的位置用这个数轴上的点描述。

如果无法理解纸环上圆的分布,可以查看样例解释以及子问题。

要求选出 $k$ 个圆,使得所有圆的并面积最大。

注意,您需要回答确切的选取方案而不是仅仅给出最大并面积。
## 输入格式

第一行包含四个整数 $n,k,r,L$ ,意义如题目所述。

第二行包含 $n$ 个整数,第 $i$ 个整数 $p[i]$ 描述了第 $i$ 个圆心在纸环上的位置(数轴上的坐标)。

对于 $2<i<n$ ,有 $p[i-1]<p[i]$。
## 输出格式

一行包含 $k$ 个整数,分别表示您选取的圆的编号,由`SPJ`来计算并面积。

您需要保证这些编号严格递增,并且在 $[1,n]$ 以内,否则被认为不合法而不得分。

与标准答案**相对误差**不超过 $10^{-9}$ ,**且绝对误差**不超过 $0.1$ 则认为正确。

通过估算,答案不会超过 $10^{12}$ 量级。
## 样例

### 样例输入 #1
```
5 3 10 30
0 7 14 21 28 
```
### 样例输出 #1
```
2 3 5 
```
### 样例输入 #2
```
10 3 10 65
0 7 15 24 30 36 41 49 57 63 
```
### 样例输出 #2
```
3 6 9
```
### 样例输入 #3
```
30 10 50 169
0 7 14 21 28 35 42 45 51 55 61 65 68 75 79 83 87 94 97 105 113 118 126 133 140 147 151 156 163 167 
```
### 样例输出 #3
```
3 5 8 11 15 19 21 24 27 30 
```
## 提示

**样例解释** : 

- **样例1** : 最终的并面积约为 $565.871835$。

圆的分布如图所示,其中, $⊙A$ 和 $⊙A2$ 是同一个圆, $⊙B$ 和 $⊙B2$ 是同一个圆。

可以视作向右平移 $L=30$ 个单位长度而得,事实上就相当于在纸环上绕了一圈回到起点。

由于是同一个圆,被红色部分覆盖的面积不能重复计算,最大的并面积即为蓝色部分的面积。

![](https://cdn.luogu.com.cn/upload/image_hosting/g2dk0sqv.png)

- **样例2** : 最终的并面积约为 $942.477796$。

- **样例3** : 最终的并面积约为 $16817.058547$。

**数据范围与约定** :

| 子任务编号 | n | k | 时限 |
| :--: | :--: | :--: | :--: |
| 1 | $10$ | - | $\texttt{1s}$ |
| 2 | $100$ | - | $\texttt{1s}$ |
| 3 | $2000$ | - | $\texttt{1.6s}$ |
| 4 | $3\times 10^4$ | $100$ | $\texttt{2.2s}$ |
| 5 | $1\times 10^5$ | - | $\texttt{3s}$ |

时限在 `std` 耗时的两倍以上。

对于所有的数据, $n\leq 10^5$，$10\leq r\leq 2000$，$0\leq p[i]< L\leq 10^8$，$4r<L$，$3\leq k \leq n$。

表格中均为上界。注意,一些下界限制可能帮助省去了问题的某些边界情况。


---

---
title: "『MdOI R3』Pekka Bridge Spam"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P6750
tag: ['动态规划 DP', '数学', '单调队列', 'O2优化', '前缀和', '二项式定理', '生成函数', '快速数论变换 NTT', '洛谷月赛']
---
# 『MdOI R3』Pekka Bridge Spam
## 题目背景

JohnVictor 比较喜欢玩 Clash Royale。

他喜欢玩一套叫做 Pekka Bridge Spam 的卡组，然而这卡组被削弱了。现在他天梯已经掉了很多分了，不会玩了，只能在竞技场上给他的攻城锤安排地方了。

于是就有了这道题。
## 题目描述

JohnVictor 的皇室竞技场是一个 $2n \times 2m$（$2n$ 行，$2m$ 列）的方格表，他要在上面放 $n\times m$ 个 $1 \times 2$ 的攻城锤，使得任意两个攻城锤不相交。

然而攻城锤里面的野蛮人靠太近会打架，所以他要求任意一个 $2 \times 2$ 的正方形中有两个相邻的格子没有被任何攻城锤占有。

现在已经摆好了 $k$ 个攻城锤了，JohnVictor 想要知道有多少种方法能摆放这些攻城锤，注意，攻城锤两两之间没有区别。

由于这个答案实在是太大了，JohnVictor 只想知道这个答案对素数 $p$ 取模后的余数。**保证取模前的真实答案大于 $0$**。

为了避免玩过皇室的参赛者对题目理解产生问题，这里的攻城锤看做一个 $1 \times 2$ 的多米诺，翻转后也与自身一样。如果还是不理解可以参考样例。

**由于本题数据范围较大，使用 C++ 的选手可以使用以下代码来加快取模速度。**

代码出自 [KATCL](https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h) 。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;
typedef __uint128_t L;
struct FastMod {
    ull b, m;
    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}
    ull reduce(ull a) {
        ull q = (ull)((L(m) * a) >> 64);
        ull r = a - q * b; // can be proven that 0 <= r < 2*b
        return r >= b ? r - b : r;
    }
};
FastMod F(2);

int main() {
    int M = 1000000007; F = FastMod(M);
    ull x = 10ULL*M+3; 
    cout << x << " " << F.reduce(x) << "\n"; // 10000000073 3
}
```

使用方法：

假设当前程序中需要取模的数为 $p$，那么就在 `main` 函数开头处调用 `F = FastMod(p);`。

计算 $a\bmod p$ 的时候调用
`
F.reduce(a);
`，
返回值就是 $a\bmod p$ 的值。
## 输入格式

第一行为四个整数 $n,m,k,p$。

接下来 $k$ 行，每行四个整数 $x_{1i},y_{1i},x_{2i},y_{2i}(1 \le i \le k)$，代表一块攻城锤的位置。

注意这里 $x,y$ 坐标表示的是在第 $x$ 行第 $y$ 列，并不是横纵坐标。
## 输出格式

一行一个整数，输出答案对 $p$ 取模后的值。
## 样例

### 样例输入 #1
```
1 2 0 19260817
```
### 样例输出 #1
```
9
```
### 样例输入 #2
```
2 2 0 19260817
```
### 样例输出 #2
```
36
```
### 样例输入 #3
```
1 2 1 19260817
1 1 2 1
```
### 样例输出 #3
```
4
```
### 样例输入 #4
```
3 3 1 19260817
1 2 1 1
```
### 样例输出 #4
```
190
```
## 提示

【样例 1 解释】   
$9$ 种情况如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/0s4px806.png)

【样例 2 解释】   
我有一种绝妙的解释方法，可惜这里位置太小，我写不下。

【样例 3 解释】  
上图中第一行的第 $1,2$ 幅和第二行的第 $1,2$ 幅图就是要求的 $4$ 种情况。

更多样例请[到这里](https://www.luogu.com.cn/paste/b2ad2hoy)领取。

【数据范围】

本题采用捆绑测试，共有 $7$ 个子任务。

对于 $100\%$ 的数据，$1 \le n \le 9 \times 10^3$，$1 \le m \le 10^{18}$，$0 \le k \le  10^5$，$|x_{1i}-x_{2i}|+|y_{1i}-y_{2i}|=1$，$1 \le x_{1i},x_{2i} \le 2n$，$1 \le y_{1i},y_{2i} \le 2m$，$10^7\le p \le 10^9 + 9 $，**输入数据保证有解且 $p$ 为素数**。

|子任务编号|$n\leq$|$m\leq$|其他性质|分值|时间限制|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|$3$|$3$||$5$|$1.0s$|
|2|$10$|$10$|$k=0$|$10$|$1.0s$|
|3|$5 \times 10^3$|$5 \times 10^3$||$13$|$2.0s$|
|4|$80$|||$17$|$1.0s$|
|5|$2\times 10^3$||$p=998244353$|$20$|$3.0s$|
|6||||$35$|$3.0s$|
【温馨提示】

为了确保卡掉小常数的错解本题开大了数据范围，请注意常数因子对程序运行效率的影响。


---

---
title: "「DTOI-4」中位数"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8978
tag: ['动态规划 DP', '二分', '单调队列', '2023', '洛谷原创', 'O2优化']
---
# 「DTOI-4」中位数
## 题目描述

给定一个长度为 $n$ 的整数序列 $a$，你可以进行以下操作不超过 $k$ 次：

- 选择一个区间 $[l, r]$ 满足 $1 \leq l \leq r \leq n$，并将 $[l, r]$ 中的所有数替换为这个区间的中位数。

你要使得操作后 $a$ 的**最小值最大**。

关于此处中位数的定义：对于一个长度为 $len$ 的序列，其中位数定义为该序列中第 $\lceil \frac{len}{2} \rceil$ 小的数。
## 输入格式

第一行，两个整数 $n, k$；

第二行，$n$ 个整数 $a_1, a_2, \cdots, a_n$。
## 输出格式

一行，表示经过不超过 $k$ 次操作后序列最小值的最大值。
## 样例

### 样例输入 #1
```
10 2
2 8 3 2 5 7 10 4 9 7
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
30 3
1 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0
```
### 样例输出 #2
```
0
```
### 样例输入 #3
```
31 3
1 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1
```
### 样例输出 #3
```
1
```
## 提示

| $\textbf{Subtask}$ | $n$ | 分值 |
| :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 10$ | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 100$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 10^3$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^4$ | $20 \operatorname{pts}$ |
| $5$ | $1 \leq n \leq 10^5$ | $20 \operatorname{pts}$ |
| $6$ | 无特殊限制 | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 4 \times 10^5$，$0 \leq k \leq n$，$0 \leq a_i \leq 10^9$。


---


---
title: "[集训队互测 2023] 超现实树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10006
tag: ['点分治', '集训队互测', '2023', 'O2优化', '快速数论变换 NTT', '根号分治']
---
# [集训队互测 2023] 超现实树
## 题目背景

Alek 喜欢打信息竞赛，尤其喜欢超现实树。超现实树，顾名思义，就是树上的超现实数。
## 题目描述

Alek 认为，对于常数 $k$，一个字符串被称为「$k$-超现实数串」，如果其只包含字符 $\texttt{\{}, \texttt{|}, \texttt{\}}$，且：

- 空串为 $k$-超现实数串；
- 如果 $s, t$ 为 $k$-超现实数串，那么 $s + t$ 为 $k$-超现实数串；
- 如果 $k + 1$ 个字符串 $s_1, s_2, \cdots, s_{k + 1}$ 都是 $k$-超现实数串，那么 $\texttt{\{} + s_1 + \texttt{|} + s_2 + \texttt{|} + \cdots + \texttt{|} + s_{k + 1} + \texttt{\}}$ 为 $k$-超现实数串；
- $k$-超现实数串仅限于此。

给定一棵 $n$ 个点的无根树，节点编号为 $1 \sim n$。每个点 $i$ 上有一个字符 $a_i \in \{\texttt{\{}, \texttt{|}, \texttt{\}}\}$。

给定整数 $m$，Alek 希望你对 $k = 0, 1, \cdots, m$ 分别求出：有多少有序对 $(x, y)$，$1 \leq x, y \leq n$，使得树上从点 $x$ 到点 $y$ 的唯一简单路径上的字符依次拼接所得字符串是 $k$-超现实数串。
## 输入格式

第一行两个整数 $n, m$，分别表示树的节点数，和需要求答案的 $k$ 的上限。

第二行一个字符串 $a$，$a$ 的第 $i$ 个字符表示点 $i$ 上的字符。

接下来 $n - 1$ 行，每行两个整数 $x, y$，表示存在一条连接点 $x$ 和点 $y$ 的边。
## 输出格式

输出一行 $m + 1$ 个整数，分别表示 $k = 0, 1, \cdots, m$ 时的答案。
## 样例

### 样例输入 #1
```
5 3
|{}}}
2 1
3 2
4 1
5 1
```
### 样例输出 #1
```
1 2 0 0
```
### 样例输入 #2
```
10 8
|}||}{|{{{
2 1
3 1
4 3
5 2
6 5
7 5
8 4
9 2
10 3
```
### 样例输出 #2
```
2 0 1 1 0 0 0 0 0
```
### 样例输入 #3
```
见附加文件 ex_surreal3.in。
```
### 样例输出 #3
```
见附加文件 ex_surreal3.ans。
```
## 提示

对于所有数据，有 $2 \leq n \leq 10^5$，$0 \leq m \leq n - 2$，$a_i \in \{\texttt{\{}, \texttt{|}, \texttt{\}}\}$。

- **Subtask 1**（5 分）：$n \leq 4601$；
- **Subtask 2**（20 分）：对每条边 $(x, y)$ 有 $y = x + 1$；
- **Subtask 3**（5 分）：$a_i \neq \texttt{|}$, $m = 0$；
- **Subtask 4**（15 分，依赖 Subtask 3）：$m \leq 3$；
- **Subtask 5**（25 分，依赖 Subtask 1）：$n \leq 5 \times 10^4$；
- **Subtask 6**（30 分，依赖 Subtask 1, 2, 3, 4, 5）：无特殊限制。


---

---
title: "Normal"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10632
tag: ['图论', '点分治', '多项式', 'Special Judge', 'O2优化', '期望', '快速数论变换 NTT']
---
# Normal
## 题目描述

某天 WJMZBMR 学习了一个神奇的算法：树的点分治！

这个算法的核心是这样的：

```cpp
time = 0
Solve(Tree a) {
  time += a.size;
  if (a.size == 1) return;
  else {
    select x in a;
    delete a[x];
  }
}
```

```
消耗时间 = 0
Solve(树 a)
  消耗时间 += a 的大小
  如果 a 中 只有 1 个点
    退出
  否则
    在 a 中选一个点x
    在 a 中删除点x
```

那么 $a$ 变成了几个小一点的树，对每个小树递归调用 `Solve`。

我们注意到的这个算法的时间复杂度跟选择的点 $x$ 是密切相关的，如果 $x$ 是树的重心，那么时间复杂度就是 $O(n \log n)$。

WJMZBMR 决定随机在 $a$ 中选择一个点作为 $x$，Sevenkplus 告诉他这样做的最坏复杂度是 $O(n^2)$，但是 WJMZBMR 就是不信，于是 Sevenkplus 花了几分钟写了一个程序证明了这一点，你也试试看吧。

现在给你一颗树，你能告诉 WJMZBMR 他的算法需要的期望消耗时间吗（以给出的 `Solve` 函数中的为标准）？
## 输入格式

第一行一个整数 $n$，表示树的大小；接下来 $n-1$ 行每行两个整数 $a,b$，表示 $a$ 和 $b$ 之间有一条边。

树的结点从 $0$ 开始编号。
## 输出格式

一行一个浮点数表示答案，并四舍五入到小数点后 $4$ 位。
## 样例

### 样例输入 #1
```
3
0 1
1 2
```
### 样例输出 #1
```
5.6667
```
## 提示

对于所有的数据，保证 $1\leq n\leq 30000$。


---

---
title: "[KTSC 2023 R1] 出租车旅行"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P11343
tag: ['点分治', '2023', '交互题', '斜率优化', 'KOI（韩国）']
---
# [KTSC 2023 R1] 出租车旅行
## 题目背景

**请勿用 C++14 (GCC 9) 提交。**

请在程序开头加入如下代码：

```cpp
#include<vector>
std::vector<long long> travel(std::vector<long long> A, std::vector<int> B, std::vector<int> U, std::vector<int> V, std::vector<int> W);
```
## 题目描述

**题目译自 [2023년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2023/)  T3 「[택시 여행](https://assets.ioikorea.kr/ioitst/2023/1/taxi/taxi_statement.pdf)」**

IOI 国由 $N$ 个城市和连接这些城市的 $N-1$ 条双向道路组成，任意两个不同的城市都可以通过这些道路互相到达。也就是说，IOI 国的道路网络是一个树结构。

每个城市都有一个编号，从 $0$ 到 $N-1$，其中 $0$ 号城市是 IOI 国的首都。对于每个 $i$ $(0 \leq i \leq N-2)$，第 $i$ 条道路连接 $U[i]$ 号城市和 $V[i]$ 号城市，道路长度为 $W[i]$ 公里。

在 IOI 国，不同城市的出租车费用不同。具体来说，对于每个 $i$ $(0 \leq i \leq N-1)$，从 $i$ 号城市出发的出租车有一个基本费用 $A[i]$ 元和每公里的费用 $B[i]$ 元。这意味着，如果从 $i$ 号城市出发并行驶 $d$ 公里，需要支付 $A[i] + d \times B[i]$ 元。

小明目前住在首都 $0$ 号城市，他计划乘坐出租车去其他城市旅行。当他到达一个城市时，可以选择继续乘坐当前的出租车，或者换乘该城市出发的出租车。当然，换乘出租车需要支付基本费用，并且每公里的费用也可能不同。请计算从 0 号城市出发到达其他所有城市的最小费用。

你需要实现以下函数：

```cpp
vector<long long> travel(vector<long long> A, vector<int> B, vector<int> U, vector<int> V, vector<int> W);
```

- 该函数只会被调用一次。
- `A`：大小为 $N$ 的整数数组。对于每个 $i$ $(0 \leq i \leq N-1)$，$A[i]$ 是从 $i$ 号城市出发的出租车的基本费用。
- `B`：大小为 $N$ 的整数数组。对于每个 $i$ $(0 \leq i \leq N-1)$，$B[i]$ 是从 $i$ 号城市出发的出租车的每公里费用。
- `U, V, W`：大小为 $N-1$ 的整数数组。对于每个 $i$ $(0 \leq i \leq N-2)$，$U[i]$ 号城市和 $V[i]$ 号城市之间有一条长度为 $W[i]$ 公里的道路。
- 该函数返回一个大小为 $N-1$ 的数组 $C$。对于每个 $i$ $(0 \leq i \leq N-2)$，$C[i]$ 是从 $0$ 号城市出发到达 $i+1$ 号城市的最小费用。

注意，提交的代码中不应包含任何输入输出操作。
## 输入格式

示例评测程序按以下格式读取输入：

- 第 $1$ 行：$N$
- 第 $2$ 行：$A[0]\,A[1]\,\cdots\,A[N-1]$
- 第 $3$ 行：$B[0]\,B[1]\,\cdots\,B[N-1]$
- 第 $4+i$ $(0 \leq i \leq N-2)$ 行：$U[i]\,V[i]\,W[i]$
## 输出格式

示例评测程序按以下格式输出：

- 第 $i$ 行：函数 `travel` 返回的数组的第 $i$ 个元素
## 样例

### 样例输入 #1
```
5
10 5 13 4 3
10 7 5 9 1
1 0 1
0 2 5
3 2 10
2 4 3
```
### 样例输出 #1
```
20
60
104
88
```
## 提示

### 样例解释

考虑 $N=5, A=[10,5,13,4,3], B=[10,7,5,9,1], U=[1,0,3,2], V=[0,2,2,4], W=[1,5,10,3]$ 的情况。

评测程序将调用如下函数：

```cpp
travel([10, 5, 13, 4, 3], [10, 7, 5, 9, 1], [1, 0, 3, 2], [0, 2, 2, 4], [1, 5, 10, 3]);
```

- 从 $0$ 号城市到 $1$ 号城市的最优方案是直接从 $0$ 号城市乘坐出租车，总费用为 $20$ 元。
- 从 $0$ 号城市到 $2$ 号城市的最优方案是直接从 $0$ 号城市乘坐出租车，总费用为 $60$ 元。
- 从 $0$ 号城市到 $4$ 号城市的最优方案是先从 $0$ 号城市乘坐出租车到 $1$ 号城市，然后换乘，再经过 $0$ 号和 $2$ 号城市到达 $4$ 号城市，总费用为 $88$ 元。
- 从 $0$ 号城市到 $3$ 号城市的最优方案是先从 $0$ 号城市乘坐出租车到 $1$ 号城市，然后换乘，再经过 $0$ 号和 $2$ 号城市到达 $4$ 号城市，再换乘，经过 $2$ 号城市到达 $3$ 号城市，总费用为 $104$ 元。

函数应返回 `[20, 60, 104, 88]`。

### 数据范围

对于所有输入数据，满足：

- $2 \leq N \leq 10^5$
- 对于所有 $i$ $(0 \leq i \leq N-1)$，$0 \leq A[i] \leq 10^{12}$
- 对于所有 $i$ $(0 \leq i \leq N-1)$，$0 \leq B[i] \leq 10^6$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$0 \leq U[i], V[i] \leq N-1 ; U[i] \neq V[i]$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$1 \leq W[i] \leq 10^6$

详细子任务附加限制及分值如下表所示。

| 子任务 | 分值 | 附加限制 |
| :-: | :-: | :-: |
| $1$ | $7$ | $N \leq 20$ |
| $2$ | $8$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$U[i]=i ; V[i]=i+1$ |
| $3$ | $13$ | $N \leq 2000$ |
| $4$ | $17$ | 对于所有 $i$ $(0 \leq i \leq N-1)$，$B[i] \leq 30$ |
| $5$ | $29$ | $B[i] \neq 0$ $(0 \leq i \leq N-1)$ 的 $i$ 不超过 $2000$ 个 |
| $6$ | $26$ | 无附加限制 |


---

---
title: "[集训队互测 2015] Tree and Sets（暂无 Special Judge）"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P11732
tag: ['2015', '点分治', '集训队互测', 'Special Judge', '分治', '仙人掌']
---
# [集训队互测 2015] Tree and Sets（暂无 Special Judge）
## 题目描述

wangyisong1996 有一棵小树苗，可惜由于土地沙漠化小树苗枯死了。正当 wangyisong1996 悲痛欲绝的时候，从沙子中长出了一棵仙人掌。

如果一个无向连通图的任意一条边最多属于一个简单环，我们就称之为仙人掌。所谓简单环即不经过重复的结点的环。

![](https://cdn.luogu.com.cn/upload/pic/4742.png)

有一棵 $n$ 个结点的仙人掌，每条边有一个长度 $l$。（不同的边的长度不一定相同）

有 $q$ 个点集，每个点集可以用两个整数 $u, d$ 来描述（$1 \leq u \leq n$），一个结点 $v$ 在这个点集中当且仅当结点 $v$ 与结点 $u$ 的距离不超过 $d$。两个结点之间的距离为它们之间的最短路径的长度。

现在要求构造一个有向无环图（DAG），满足：

1. 这个 DAG 至少有 $n+q$ 个结点，至多有 $1200000$ 个结点和 $2400000$ 条边。
2. 对于每一条边，如果是从 $u$ 连向 $v$ 的，那么 $u > n$ 且 $u \neq v$。
3. 对于结点编号在第 $i$ 个点集（$1 \leq i \leq q$）的每一个结点 $x$，第 $n+i$ 个结点到第 $x$ 个结点有且仅有一条路径。
4. 对于结点编号在 $\{ 1, 2, \dots, n\}$ 中但不在第 $i$ 个点集（$1 \leq i \leq q$）的每一个结点 $x$，不存在第 $n+i$ 个结点到第 $x$ 个结点的路径。
## 输入格式

第一行三个正整数 $n, m, q$，其中 $n, m$ 表示这棵仙人掌一共有 $n$ 个结点 $m$ 条边。

接下来 $m$ 行，每行三个整数 $u,v,l$，表示 $u$ 和 $v$ 之间有一条长度为 $l$ 的无向边。保证 $1 \leq u, v \leq n$。

接下来 $q$ 行，第 $i$ 行表示第 $i$ 个点集，用两个整数 $u, d$ 来描述，保证 $1 \leq u \leq n$。
## 输出格式

第一行两个非负整数 $V,E$，表示你构造的 DAG 的点数和边数。

接下来 $E$ 行，每行两个整数 $u,v$，表示 $u$ 到 $v$ 有一条有向边。你需要保证 $1 \leq u, v \leq V$。
## 样例

### 样例输入 #1
```
10 9 5
2 1 9553
3 2 8499
4 3 5171
5 1 7123
6 3 1904
7 5 5526
8 7 5853
9 6 6635
10 8 7858
6 4981
7 14400
3 21290
4 9451
10 16609
```
### 样例输出 #1
```
15 19
11 6
11 3
12 7
12 5
12 1
12 8
12 10
13 3
13 6
13 9
13 4
13 2
13 1
14 4
14 3
14 6
15 10
15 8
15 7
```
## 提示


| 测试点编号 |    $n$    |         $m$         |    $q$    |
|:--------:|:--------:|:----------------:|:--------:|
|     1    |  $= 1000$  |  $m = n - 1$  |  $= 1000$  |
|     2    |  $= 10000$  |  $m = n - 1$  | $= 10000$ |
|     3    |  $= 10000$        |   $m = n - 1$       | $=10000$ |
|     4    |  $= 9000$  |   $m = n - 1$       |  $= 9000$  |
|     5    |  $= 10000$  |   $m = n - 1$       |  $= 10000$  |
|     6    |  $= 1000$  |  $n - 1 \leq m \leq 2n - 2$  |  $= 1000$  |
|     7    |  $= 10000$  |  $n - 1 \leq m \leq 2n - 2$  | $= 10000$ |
|     8    |  $= 10000$        |  $n - 1 \leq m \leq 2n - 2$        |  $= 10000$ |
|     9    |  $= 10000$       |  $n - 1 \leq m \leq 2n - 2$        | $= 10000$ |
|    10    |  $= 10000$        |  $n - 1 \leq m \leq 2n - 2$        | $= 10000$ |

第 2 个测试点的生成方式：
```python
for i in range(2, 10001):
	addedge(i, i / 2)
```

第 3 个测试点的生成方式：
```python
for i in range(2, 5000):
	addedge(i, i - 1)
for i in range(5000, 10001):
	addedge(i, randint(1, i - 1))
```

其中 `range(l,r)` 表示区间 $[l,r)$ 中的所有数，`randint(l,r)` 返回一个在 $[l,r]$ 内的随机整数。

`addedge(u, v)` 表示在 $u$ 和 $v$ 间连一条边。（边的长度的生成方式，你以为我会告诉你吗？）


---

---
title: "[KOI 2022 Round 2] 外环路"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P12703
tag: ['点分治', '2022', '最短路', 'KOI（韩国）']
---
# [KOI 2022 Round 2] 外环路
## 题目背景

试题来源：<https://koi.or.kr/archives/>。中文翻译做了少量本土化修改。

按照[署名—非商业性使用—相同方式共享 4.0 协议国际版](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh-hans)进行授权。
## 题目描述

KOI 城市由 $N$ 个十字路口和 $N - 1$ 条双向道路组成，任意两个不同的十字路口之间都可以仅通过道路到达。也就是说，城市的道路网络结构是一棵树。这些道路位于二维平面上，除了端点外互不相交。每条道路都有一个不小于 0 的整数权重，表示通过这条道路所需的时间。

KOI 城市在几十年前还是一个小村庄，随着人口流入和城市规模的迅速扩张，市长为了行政便利，为所有十字路口编号为 1 到 $N$。这个编号系统满足以下性质：

- 1 号十字路口是城市的中心，保证至少连接了两条道路。
- 各个十字路口的编号是以 1 号十字路口为根进行先序遍历（Preorder Traversal）所得到的一种顺序。
- 对于每个十字路口，设其直接相邻（即通过一条道路连接）的十字路口中编号最小的为基准，从该点出发按逆时针方向依次列出其相邻的十字路口编号，这些编号应是递增的。

随着 KOI 城市人口迅速增长，交通拥堵问题日益严重。为了解决这一问题，市长决定通过建设外环道路将交通设施最为薄弱的地区连接起来。

设所有仅连接一条道路的十字路口的编号按升序排列为 $\{v_1, v_2, \dots, v_k\}$，市长将为所有的 $1 \leq i \leq k$ 建设一条连接 $v_i$ 和 $v_{(i \bmod k) + 1}$ 的双向道路。每条道路的权重为不小于 0 的整数 $w_i$，这些权重将作为输入给出。

由于编号系统的特殊性，可以保证这些新增的外环道路在非端点处互不相交。

你打算为 KOI 城市构建一套导航系统。该系统需要回答 $Q$ 个查询，每个查询给出两个十字路口 $u$ 和 $v$，你需要输出从 $u$ 号十字路口到 $v$ 号十字路口所需的最短时间。这个最短时间是指从 $u$ 到 $v$ 所经过路径的所有道路权重之和的最小值。

请你编写程序，在给定城市道路结构和查询的前提下，快速回答所有 $Q$ 个查询。
## 输入格式

第一行包含一个整数 $N$，表示十字路口的数量。

接下来的 $N - 1$ 行，第 $i$ 行包含两个整数 $p_i$ 和 $c_i$，表示存在一条连接 $p_i$ 和 $i+1$ 的双向道路，权重为 $c_i$。

接下来一行包含一个整数 $k$，表示仅连接一条道路的十字路口的数量。

随后一行包含 $k$ 个整数 $w_1, w_2, \dots, w_k$，以空格分隔，其中 $w_i$ 是连接 $v_i$ 和 $v_{(i \bmod k)+1}$ 的新建道路的权重。

接下来一行包含一个整数 $Q$，表示查询数量。

接下来的 $Q$ 行，每行两个整数 $u, v$，表示一次从 $u$ 到 $v$ 的查询。
## 输出格式

共 $Q$ 行，每行一个整数，表示每个查询中 $u$ 到 $v$ 的最短路径长度。

## 样例

### 样例输入 #1
```
4
1 9
1 8
1 0
9 9 9
6
1 2
1 3
1 4
2 3
2 4
3 4
```
### 样例输出 #1
```
9
8
0
9
9
8
```
### 样例输入 #2
```
11
1 9
1 8
3 0
4 7
4 1
3 6
1 0
8 7
8 1
10 6
0 0 0 0 0 0
21
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
1 11
7 1
8 2
9 3
10 4
11 5
1 6
2 7
3 8
4 9
5 10
6 11
```
### 样例输出 #2
```
7
8
8
7
7
7
0
7
1
7
7
7
1
7
0
7
0
8
1
6
0
```
### 样例输入 #3
```
11
1 9
1 8
3 0
4 7
4 1
3 6
1 0
8 7
8 1
10 6
1000000000000 1000000000000
1000000000000 1000000000000
1000000000000 1000000000000
21
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
1 10
1 11
7 1
8 2
9 3
10 4
11 5
1 6
2 7
3 8
4 9
5 10
6 11
```
### 样例输出 #3
```
9
8
8
15
9
14
0
7
1
7
14
9
15
9
22
9
23
8
15
16
16
```
## 提示

**样例 1 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/fcuqax1l.png)

上面的地图对应于示例 1。示例 1 满足子任务 2、5、6 的约束条件。

**样例 2、3 说明**

![](https://cdn.luogu.com.cn/upload/image_hosting/5b0ae9y3.png)

上面的地图对应于示例 2 和示例 3。示例 2 的情况下，满足 $w_i = 0$；示例 3 的情况下，满足 $w_i = 10^{12}$。示例 2 满足子任务 4、5、6 的约束条件，示例 3 满足子任务 3、5、6 的约束条件。

请注意，示例 3 中从第 12 行开始的数列：

```
1000000000000 1000000000000 1000000000000 1000000000000 1000000000000 1000000000000
```

在实际中是作为一行输入给出的，但由于篇幅限制，在此被分成了多行显示。（本段内容在正式比赛中并未提供。）

**约束条件**

- $4 \leq N \leq 100\,000$
- $1 \leq p_i \leq i$
- $0 \leq c_i, w_i \leq 10^{12}$
- $1 \leq Q \leq 250\,000$
- $1 \leq u, v \leq N$ 且 $u \ne v$

**子任务**

1. （6 分）所有查询满足 $u = 1$
2. （8 分）对所有 $1 \leq i \leq N - 1$，$p_i = 1$
3. （5 分）对所有 $1 \leq i \leq N - 1$，$c_i \leq 10^6$，并且对所有 $1 \leq i \leq k$，$w_i = 10^{12}$
4. （15 分）对所有 $1 \leq i \leq k$，$w_i = 0$
5. （57 分）不存在连接 4 条及以上道路的十字路口
6. （9 分）无额外约束条件


---

---
title: "[WC2014] 紫荆花之恋"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P3920
tag: ['2014', '点分治', '平衡树', '分治', 'WC']
---
# [WC2014] 紫荆花之恋
## 题目描述

强强和萌萌是一对好朋友。有一天他们在外面闲逛，突然看到前方有一棵紫荆树。这已经是紫荆花飞舞的季节了，无数的花瓣以肉眼可见的速度从紫荆树上长了出来。

仔细看看的话，这个大树实际上是一个带权树。每个时刻它会长出一个新的叶子节点，每个节点上有一个可爱的小精灵，新长出的节点上也会同时出现一个新的小精灵。小精灵是很萌但是也很脆弱的生物，每个小精灵 $i$ 都有一个感受能力值 $r_i$，小精灵 $i,j$ 成为朋友当且仅当在树上 $i$ 和 $j$ 的距离 $dist(i,j) \leq r_i+r_j$，其中 $dist(i,j)$ 表示在这个树上从 $i$ 到 $j$ 的唯一路径上所有边的边权和。

强强和萌萌很好奇每次新长出一个叶子节点之后，这个树上总共有几对朋友。


我们假定这个树一开始为空，节点按照加入的顺序从 1 开始编号。由于强强非常好奇，你必须在他每次出现新结点后马上给出总共的朋友对数，不能拖延哦。
## 输入格式

第一行包含一个整数，表示测试点编号。

第二行包含一个正整数 $n$，表示总共要加入的节点数。

我们令加入节点前的总共朋友对数是 $last\_ans$，在一开始时它的值为 0。

接下来 $n$ 行中第 $i$ 行有三个非负整数 $a_i,c_i,r_i$，表示结点 i 的父节点的编号为 $ai \; \oplus \; (last\_ans \; \bmod \; 10^9)$（其中 $\oplus$ 表示异或，数据保证这样操作后得到的结果介于 1 到 $i−1$ 之间），与父结点之间的边权为 $c_i$，节点 $i$ 上小精灵的感受能力值为 $r_i$。

注意 $a_1=c_1=0$，表示 1 号节点是根结点，对于 $i>1$，父节点的编号至少为 1。
## 输出格式

包含 $n$ 行，每行输出 1 个整数，表示加入第 $i$ 个点之后，树上有几对 friends。
## 样例

### 样例输入 #1
```
0
5
0 0 6
1 2 4
0 9 4
0 5 5
0 2 4

```
### 样例输出 #1
```
0
1
2
4
7

```
## 提示

所有数据均满足 $1 \leq c_i \leq 10^4$，$a_i \leq 2\times 10^9$，$r_i \leq 10^9$。

| 测试点编号       | 约定                                                         |
| :----------------: | :------------------------------------------------------------: |
| $1,2$            | $n \leq 100$                                                 |
| $3,4$            | $n \leq 1000$                                                |
| $5,6,7,8$        | $n \leq 10^5$，节点 1 最多有两个子节点，其他节点最多有一个子节点 |
| $9,10$           | $n \leq 10^5$，$r_i \leq 10$                                 |
| $11,12$          | $n \leq 10^5$，树是随机生成的                                |
| $13,14,15$       | $n \leq 7\times 10^4$                                        |
| $16,17,18,19,20$ | $n \leq 10^5$                                                |


---

---
title: "[SDOI2016] 模式字符串"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4075
tag: ['字符串', '2016', '各省省选', '点分治', '山东', '分治']
---
# [SDOI2016] 模式字符串
## 题目描述

给出 $n$ 个结点的树 $T$，其中每一个结点上有一个字符，这里我们所说的字符只考虑大写字母 A 到 Z，再给出长度为 $m$ 的模式串 $S$，其中每一位仍然是 A 到 Z 的大写字母。

Alice 希望知道，有多少对结点 $(u,v)$ 满足 $T$ 上从 $u$ 到 $v$ 的最短路径形成的字符串可以由模式串 $S$ 重复若干次得到l。

这里结点对 $(u,v)$ 是有序的，也就是说 $(u,v)$ 和 $(v,u)$ 需要被区分。

所谓模式串的重复，是将若干个模式串 $s$ 依次相接（不能重叠)。例如当 $S=$ `PLUS`的时候，重复两次会得到 `PLUSPLUS`，重复三次会得到 `PLUSPLUSPLUS`，同时要注意，重复必须是整数次的。例如当 $S= $ `XYXY` 时，因为必须重复整数次，所以 `XYXYXY` 不能看作是 $S$ 重复若干次得到的。
## 输入格式

每一个数据有多组测试，

第一行输入一个整数 $C$，表示总的测试个数。

对于每一组测试来说：

第一行输入两个整数，分别表示树 $T$ 的结点个数 $n$ 与模式长度 $m$。结点被依次编号为 $1$ 到 $n$。

之后一行，依次给出了 $n$ 个大写字母（以一个长度为n的字符串的形式给出），依次对应树上每一个结点上的字符（第 $i$ 个字符对应了第 $i$ 个结点)。

之后 $n-1$ 行，每行有两个整数 $u$ 和 $v$ 表示树上的一条无向边，之后一行给定一个长度为 $m$ 的由大写字母组成的字符串，为模式串 $S$。
## 输出格式


给出 $C$ 行，对应 $C$ 组测试。

每一行输出一个整数，表示有多少对节点 $(u,v)$ 满足从 $u$ 到 $v$ 的路径形成的字符串恰好是模式串的若干次重复。
## 样例

### 样例输入 #1
```
1
11 4
IODSSDSOIOI
1 2
2 3
3 4
1 5
5 6
6 7
3 8
8 9
6 10
10 11
SDOI
```
### 样例输出 #1
```
5
```
## 提示

$1\leq C\leq 10$，$3\leq \sum N\leq 10^6$，$3\leq \sum M\leq 10^6$。



---

---
title: "[WC2018] 通道"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4220
tag: ['2018', '并查集', '点分治', '分治', '虚树', 'WC']
---
# [WC2018] 通道
## 题目背景

**滥用本题评测将被封号。**
## 题目描述

11328 年，C 国的科学家们研发了一种高速传送通道，可以在很短的时间内把居民从通道的一端送往另一端，这些通道都是双向的。

美中不足的是，这种传送通道需要进行大量的维护和检修。经过规划，C 国总统决定在 M 城中新建这种通道，在 M 城中，建立了 $n$ 个传送站和 $3\times(n-1)$ 条传送通道，这些传送通道被分为 $3$ 组，每一组都包含了 $(n-1)$ 条通道。

当任意一组通道运行时，居民都可以通过这组通道从任意一个传送站前往任意的另一个传送站。也就是说，所有的传送站都会被通道所连通。

三组通道按照 $1$、 $2$、 $3$ 的顺序轮流运行，循环反复。在任意一个时刻，都有且只有一组传送通道可以使用。形式化地，在第 $i$ 天中，有且只有第 $((i-1)\bmod 3+1)$ 组通道运行。

C 国著名科学家 Access Globe 正在进行一项社会调查实验：调查两个传送站之间的传送通道使用者的信息。 Access Globe 的计划是这样的：

- 选定两个传送站 $a, b$
- 第一天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息
- 第二天，他从 $b$ 出发，使用正在运行的这组通道沿最短路径到达 $a$，并调查经过的所有通道上使用者的信息
- 第三天，他从 $a$ 出发，使用正在运行的这组通道沿最短路径到达 $b$，并调查经过的所有通道上使用者的信息

Access Globe 知道每一条传输线路在运行时的使用者人数。他希望找出一对 $a, b$，使得在整个实验过程中所有经过的通道的使用者数量之和最大。 

Access Globe 希望参加 CCF NOI 2018 冬令营的你帮他解决这个简单的小问题。如果你成功地解决了这个问题， Access Globe 会送你一份小礼物——$100$ 分！
## 输入格式

输入文件的第 $1$ 行包含一个正整数 $n$，表示传送站的个数，传送站从 $1$ 到 $n$ 编号；

输入文件的第 $2$ 到第 $n$ 行，每行包含 $3$ 个数 $u,v,w$，表示第一组通道中有一条连接 $u,v$ 的通道，其运行时使用者数量为 $w$ 人；

输入文件的第 $(n+1)$ 到第 $(2n-1)$ 行，每行包含 $3$ 个数 $u,v,w$，表示第二组通道中有一条连接 $u,v$ 的通道，其运行时使用者数量为 $w$ 人；

输入文件的第 $2n$ 到第 $(3n-2)$ 行，每行包含 $3$ 个数 $u,v,w$，表示第三组通道中有一条连接 $u,v$ 的通道，其运行时使用者数量为 $w$ 人。
## 输出格式

输出文件共 $1$ 行，包含一个整数，表示最大的使用者数量之和。
## 样例

### 样例输入 #1
```
5
1 2 2
1 3 0
1 4 1
4 5 7
1 2 0
2 3 1
2 4 1
2 5 3
1 5 2
2 3 8
3 4 5
4 5 1
```
### 样例输出 #1
```
27
```
## 提示

【样例$1$说明】

下图为样例中 $M$ 城的传送站和传输线路情况。其中点和虚线交替的线条、虚线条和实线条分别表示第一组、第二组和第三组通道。
![](https://cdn.luogu.com.cn/upload/image_hosting/ozwxip1f.png)
一种可行的方案是选择 $a=2,b=5$，这样的使用者数量之和为 $(3)+(8+5+1)+(2+1+7)=27$。

【子任务】

对于所有数据， $2 \leq n \leq 10^5,0 \leq w \leq 10^{12}$。

特殊性质 $0$：任意两组通道构成完全相同。

特殊性质 $1$：第二组通道和第三组通道构成完全相同。

特殊性质 $2$：对于第二组的每一个传送站，最多只有两个通道可以到达它，且编号为 $x,y$ 的传送站之间通过一条通道直接连接充要条件是 $|x-y|=1$。

特殊性质 $3$：对于第三组的每一个传送站，最多只有两个通道可以到达它。

特殊性质 $4$： $n \leq 3000$。

![](https://cdn.luogu.com.cn/upload/image_hosting/fapzjyko.png)

本题共 $31$ 个测试点，每个子任务对应测试点如下：

- 子任务 $0$ 对应测试点 $1-7$；
- 子任务 $1$ 对应测试点 $8$；
- 子任务 $2$ 对应测试点 $9-11$；
- 子任务 $3$ 对应测试点 $12-14$；
- 子任务 $4$ 对应测试点 $15-17$；
- 子任务 $5$ 对应测试点 $18-21$；
- 子任务 $6$ 对应测试点 $22-25$；
- 子任务 $7$ 对应测试点 $26-31$；

【提示】

- 在两组通道中，可能都包含了连接传送站 $x,y$ 的通道，此时我们认为这两条通道是不同的。
- 特殊性质中，A 组通道和 B 组通道的『构成完全相同』是指：如果在 A 组中 $u,v$ 之间存在一条使用人数为 $w$ 的通道，那么在 B 组中 $u,v$ 之间一定也存在一条使用人数为 $w$ 的通道。是否相同与描述方式与描述顺序均无关。即在构成完全相同的两组通道 A 和 B 中，通道输入的顺序不一定相同，每条通道的端点的输入顺序也不一定相同（对于 A、B 组中一条连接 $u,v$ 的使用人数为 $w$ 的通道，一种可能出现的输入为： A 组通道中输入 $u\ v\ w$，而 B 组通道中输入 $v\ u\ w$）。


---

---
title: "[WC2010] 重建计划"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4292
tag: ['2010', '点分治', '单调队列', '分治', 'WC']
---
# [WC2010] 重建计划
## 题目描述

X 国遭受了地震的重创, 导致全国的交通近乎瘫痪，重建家园的计划迫在眉睫。X 国由 $N$ 个城市组成, 重建小组提出，仅需建立 $N-1$ 条道路即可使得任意两个城市互相可达。于是，重建小组很快提出了一个包含 $N-1$ 条道路的方案，并满足城市之间两两可达，他们还计算评估了每条道路 $e$ 建设之后可以带来的价值 $v(e)$。  

由于重建计划复杂而艰难，经费也有一定限制。因此，政府要求第一期重建工程修建的道路数目为 $k$ 条，但需满足 $L \leq k \leq U$，即不应少于$L$ 条，但不超过 $U$ 条。同时，为了最大化利用率，要求建设的这些道路恰好组成一条简单路径，即所建设的 $k$ 条路径可以构成一个排列 $e_1 = (p_1, q_1), e_2 = (p_2, q_2), \cdots , e_k = (p_k, q_k)$， 对于 $1 \leq i < k$， 有$(q_i = p_{i+1})$。 

重建小组打算修改他们的原有方案以满足要求，即在原有的 $N-1$ 条道路中寻找一条路径 $S$ 作为新的方案，使得新方案中的道路平均价值

$$AvgValue = \frac{\sum _{e \in S} v(e)}{|S|}$$

最大。这里 $v(e)$ 表示道路 $e$ 的价值，$|S|$ 表示新方案中道路的条数。请你帮助重建小组寻找一个最优方案。  注: 在本题中 $L$ 和 $U$ 的设置将保证有解。

## 输入格式

第一行包含一个正整数 $N$ ，表示 X 国的城市个数。 

第二行包含两个正整数 $L,U$，表示政府要求的第一期重建方案中修建道路数的上下限。  

接下来的 $N-1$ 行描述重建小组的原有方案，每行三个正整数 $a_i, b_i, v_i$，分别表示道路 $(a_i, b_i)$，其价值为 $v_i$ 。其中城市由$1 \cdots N$标号。
## 输出格式

仅包含一行，为一个实数 $AvgValue$，即最大平均价值。

小数点后保留三位。
## 样例

### 样例输入 #1
```
4 
2 3 
1 2 1 
1 3 2 
1 4 3
```
### 样例输出 #1
```
2.500
```
## 提示

新方案中选择路径 $(3, 1), (1, 4)$ 可以得到的平均价值为 $2.5$，为最大平均价值。

对于20%的数据，$N \leq 5 000$;  

另有30%的数据，$N \leq 100 000$， 原有方案恰好为一条路径(链); 

对于100%的数据，$N \leq 100 000, 1 \leq L \leq U \leq N-1, v_i \leq 10^6$。


---

---
title: "八月脸"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5114
tag: ['点分治', '凸包']
---
# 八月脸
## 题目背景

Cdm1020 十分喜欢 August-soft 出品的游戏，在游玩 august 社历届作品的时候他突然发现了一些神奇的事实。

**那就是所有的人物立绘的脸都是一样的!**


![](https://i.loli.net/2018/09/17/5b9fb47a8b3e0.gif)

不过尽管如此，作为一名资深的八月厨，他依然可以敏锐的分辨出各张立绘之间的细微差异 ~~（并不，就是同一张脸有什么好分辨的）~~，为了进一步研究八月社的立绘水平，Cdm1020 将八月社的所有立绘都放到了一颗树上 ~~（什么鬼啊）~~

（如果你不知道什么是树的话，你可以将树理解为一个无环的无向连通图）

具体来讲树上的每个节点仅保存了一张八月社的立绘，Cdm1020 通过和他的八月厨朋友们交流发现，狂热程度不同的八月厨对于同一张立绘的喜爱程度是不一样的，具体来讲每张立绘有两个属性 $a$ 和 $b$，对于一个狂热指数为 $k$ 的八月厨来讲，他对一张属性为 $(a,b)$ 的立绘的喜爱程度为 $ka+b$。

现在 Cdm1020 想要带领他的 $m$ 个狂热指数不同的朋友参观八月社的立绘（们），他希望你对于他的每一个朋友，帮他规划出一条喜爱程度之和最大的游览路线。

当然这个问题很简单，他是不会拿来烦你的。现在他真正头疼的事情是八月社新来了一个画师夏野。他的朋友们现在闹腾着想要看八月社的新立绘 ~~（反正还是一张脸有什么好看的）~~，所以他规定你的路线必须从一张属于 b 叔的立绘开始，到一张属于夏野的立绘结束，你能帮帮他吗？
## 题目描述

**请忽略上面的鬼话，就当什么也没看见**

一句话题意，给定一颗 $n$ 个点的树，树上每个点不是黑色就是白色，每个点有两个属性 $a$ 和 $b$。

现在多组询问，每次询问仅给出一个参数 $k$，要求你从树上找出一条路径 $(u,v)$ 使得 $u$ 和 $v$ 的颜色不同并且

$$k\times \sum_{p \in path (u-v)}p.a+\sum_{p\in path(u-v)}p.b$$

最大，对于每个询问你仅需要输出这个最大值即可（式子里面的两个和式的意思分别是路径上的点 $a$ 属性之和和路径上点的 $b$ 属性之和）。

**tips: $a,b,k$ 均可正可负，并且我们不允许你不选路径，也就是说我们求出的的最大值可以是一个负数，这会发生在所有合法路径的权值都是负数的时候**。
## 输入格式

第一行两个正整数 $n,m$ 表示树的节点个数和询问次数。

接下来一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个点的 $a$ 属性的值。

接下来一行 $n$ 个整数，第 $i$ 个整数表示第 $i$ 个点的 $b$ 属性的值。

接下来一行 $n$ 个整数，每个数要么为 $0$ 要么为 $1$，第 $i$ 个数为 $0$ 表示第 $i$ 个点是一个白色点，为 $1$ 表示第 $i$ 个点是一个黑色点。

接下来 $n-1$ 行，每行两个正整数 $u,v$，表示存在一条从点 $u$ 到点 $v$ 的边。

接下来 $m$ 行，每行一个整数 $k$ 表示询问的参数。
## 输出格式

输出 $m$ 行，对于每一个询问，输出题目中给出式子的最大值。
## 样例

### 样例输入 #1
```
15 15
29 -23 -14 -50 -13 -23 5 33 50 32 27 27 -9 -42 -11
-37 39 21 50 10 -42 -2 25 1 28 40 -45 -24 -29 47
0 0 1 0 0 1 1 0 0 1 0 1 0 0 0
2 1
3 1
4 3
5 2
6 2
7 2
8 4
9 1
10 2
11 5
12 3
13 5
14 3
15 9
-8
36
44
29
-5
-4
-3
-2
-1
0
1
2
3
4
5

```
### 样例输出 #1
```
679
3252
3988
2608
436
355
274
199
135
126
155
232
309
386
471

```
## 提示

$2 \leq n\leq 10^5$，$1 \leq m \leq 10^5$，$-10^8 \leq k \leq 10^8 $

保证不会存在所有点都是黑色或者都是白色的数据，保证对于树上的任意路径，路径上点的 $a$ 属性之和的绝对值不超过$1.5×10^9$，路径上点的 $b$ 属性之和的绝对值不超过 $1.5×10^9$。


---

---
title: "【XR-2】永恒"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5439
tag: ['点分治', 'O2优化', '虚树']
---
# 【XR-2】永恒
## 题目背景

> 我一直认为这世界没有永恒，如果非要说永恒，宇宙间唯一的永恒就是——所有的一切都会随着时光消失。——梧桐《那片星空，那片海》
## 题目描述

有一棵 $n$ 个点的永恒的树，树中每个点 $x(1 \le x \le n)$ 上都有一个永恒的字符串 $S(x)$。

但这世界没有永恒，所有的一切都会随着时光消失。我们只能给每个所谓永恒的东西定义一个永恒值 $f$。这个值本身没有意义，只是一个象征罢了。

- 一个字符串 $S$ 的永恒值 $f(S)$ 定义为它的长度 $\mathrm{Len}(S)$，即：

$$f(S) = \mathrm{Len}(S)$$

- 树上的一条无向路径 $K = [u, v](u < v)$ 指的是 $u,v$ 之间的简单路径（包括 $u, v$），其永恒值 $f(K)$ 定义为路径上所有不同的无序点对 $(x, y)(x \in K, y \in K, x < y)$ 上的字符串 $S(x), S(y)$ 的最长公共前缀 $\mathrm{LCP}(S(x), S(y))$ 的永恒值 $f(\mathrm{LCP}(S(x), S(y)))$ 之和，即：

$$f(K) = \sum_{x \in K, y \in K, x < y} f(\mathrm{LCP}(S(x), S(y)))$$

- 一棵树 $T$ 的永恒值 $f(T)$ 定义为树上所有的无向路径 $[u, v](u \in T, v \in T, u < v)$ 的永恒值之和，即：

$$f(T) = \sum_{u \in T, v \in T, u < v} f([u,v])$$

特别的是，树中每个点上的字符串都来自一棵永恒的以点 $1$ 为根的 Trie 树，即每个树中的点都对应着一个 Trie 树中的点，点上的字符串就是 Trie 树中从根节点到其对应的点形成的字符串。

你需要求出这棵树的永恒值，答案对 $998244353$ 取模。
## 输入格式

第一行包含两个正整数 $n,m$，分别表示树的节点数和 Trie 树的节点数。

第二行包含 $n$ 个非负整数，第 $i$ 个数为 $a_i$，表示点 $i$ 在树上的父亲节点为 $a_i$，对于树的根节点 $root$，保证 $a_{root} = 0$。

第三行包含 $m$ 个非负整数，第 $i$ 个数为 $b_i$，表示点 $i$ 在 Trie 树上的父亲节点为 $b_i$，保证 $b_i < i$，$b_1=0$。

第四行为一个由 $m$ 个字符构成的字符串，第 $i$ 个字符 $c_i$ 表示 Trie 树上点 $i$ 与它的父亲节点 $b_i$ 之间的边所代表的字符，保证 $c_1=\texttt{0}$，$c_i(2 \le i \le m)\in[\texttt{a},\texttt{z}]$。

第五行包含 $n$ 个正整数 $d_i$，表示树上的点 $i$ 对应着 Trie 树上的点 $d_i$，保证 $2 \le d_i \le m$。
## 输出格式

一行一个整数，表示答案对 $998244353$ 取模后的值。
## 样例

### 样例输入 #1
```
3 17
2 0 2
0 1 2 3 4 5 6 7 8 4 10 11 12 3 14 15 16
0mayqueenkingrket
9 13 17

```
### 样例输出 #1
```
12

```
## 提示

【样例 $1$ 说明】

所有的 $S(x)$ 为：

$S(1) = \texttt{"mayqueen"}$

$S(2) = \texttt{"mayking"}$

$S(3) = \texttt{"market"}$

所有的 $f(\mathrm{LCP}(S(x), S(y)))$ 为：

$f(\mathrm{LCP}(S(1), S(2))) = f(\mathrm{LCP}(\texttt{"mayqueen"}, \texttt{"mayking"})) = f(\texttt{"may"}) = \mathrm{Len}(\texttt{"may"}) = 3$

$f(\mathrm{LCP}(S(1), S(3))) = f(\mathrm{LCP}(\texttt{"mayqueen"}, \texttt{"market"})) = f(\texttt{"ma"}) = \mathrm{Len}(\texttt{"ma"}) = 2$

$f(\mathrm{LCP}(S(2), S(3))) = f(\mathrm{LCP}(\texttt{"mayking"}, \texttt{"market"})) = f(\texttt{"ma"}) = \mathrm{Len}(\texttt{"ma"}) = 2$

所有的 $f([u, v])$ 为：

$f([1,2]) = f(\mathrm{LCP}(S(1), S(2))) = 3$

$f([1,3]) = f(\mathrm{LCP}(S(1), S(2))) + f(\mathrm{LCP}(S(1), S(3))) + f(\mathrm{LCP}(S(2), S(3))) = 3 + 2 + 2 = 7$

$f([2,3]) = f(\mathrm{LCP}(S(2), S(3))) = 2$

所以：

$f(T) = f([1,2]) + f([2,3]) + f([1,3]) = 3 + 7 + 2 = 12$

【数据规模与约定】

**本题采用捆绑测试。**

Subtask 1（3 points）：$n, m \le 10$，时限 1s。  
Subtask 2（5 points）：$n, m \le 100$，时限 1s。  
Subtask 3（9 points）：$n, m \le 1000$，时限 1s。  
Subtask 4（7 points）：$n, m \le 5000$，时限 2s。  
Subtask 5（9 points）：$n, m \le 20000$，时限 3s。  
Subtask 6（11 points）：$n, m \le 10^5$，时限 4s。  
Subtask 7（19 points）：$m=2$，时限 3s。  
Subtask 8（37 points）：无特殊限制，时限 10s。

对于 $100\%$ 的数据，$2 \le n,m \le 3\times 10^5$。


---

---
title: "[ICPC 2022 Jinan R] Tree Distance"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9678
tag: ['点分治', '2022', 'O2优化', 'ICPC', '济南']
---
# [ICPC 2022 Jinan R] Tree Distance
## 题目描述

You are given an unrooted weighted tree $T$ with vertices $1, 2, \ldots, n$. Please answer some queries.

We define $\texttt{dist}(i,j)$ as the distance between vertex $i$ and vertex $j$ in $T$.

For each query, you are given two integers $l, r$. Please answer the value of 

$$\min_{l\le i< j\le r}(\texttt{dist}(i,j)).$$
## 输入格式

The first line contains one integer $n~(1\leq n\le 2 \times 10^5)$, the number of vertices in the tree. 

Each of the next $n-1$ lines describes an edge of the tree. Edge $i$ is denoted by three integers $a_i, b_i, w_i$ $(1\le a_i, b_i\le n, 1\le w_i\le 10^9)$, the labels of vertices it connects and its weight. 

Then one line contains one integer $q~(1\leq q\le 10^6)$, the number of queries.

Each of the following $q$ lines contains two integers $l, r~(1\le l \le r\le n)$ describing a query.

It is guaranteed that the given edges form a tree.
## 输出格式


For each query, output the answer in one line. If there is no $i,j$ such that $l\le i<j\le r$, the answer is $-1$.
## 样例

### 样例输入 #1
```
5
1 2 5
1 3 3
1 4 4
3 5 2
5
1 1
1 4
2 4
3 4
2 5

```
### 样例输出 #1
```
-1
3
7
7
2

```
## 题目翻译

给你一棵 $n$ 个点的树。记 $\operatorname{dist}(i,j)$ 为树上 $i,j$ 之间唯一简单路径的长度。

你要回答 $q$ 次询问：给定 $l,r$，求 $\min\limits_{l\leq i<j\leq r}(\operatorname{dist}(i,j))$。


---

---
title: "[USACO23DEC] Cowntact Tracing P"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9983
tag: ['动态规划 DP', '贪心', 'USACO', '点分治', '2023', 'O2优化', '树形 DP']
---
# [USACO23DEC] Cowntact Tracing P
## 题目描述

Farmer John 有依次编号为 $1\dots N$ 的 $N$（$2\le N \le 10^5$）头奶牛，奶牛间的关系可以用树结构描述。不幸的是，有一种疾病正在传播。

最初，有一些奶牛被感染。每到夜晚，被感染的奶牛会将疾病传播给它的邻居。一旦奶牛被感染，她就会持续处于感染状态。经过一些晚上，Farmer John 意识到这样的情况，因此他对奶牛进行了检测以确定哪些奶牛感染了疾病。

你将得到 $Q$（$1\le Q \le 20$）个不同的夜晚数，每个都是 $[0,N]$ 范围内的整数。对于每个夜晚数，请找出最少有多少头奶牛最初可能感染了这种疾病，或者报告夜晚数与给出的信息不符。
## 输入格式

第一行为一个整数 $N$。

接下来一行，包含长度为 $N$ 的由 $1$ 和 $0$ 组成的位串。其中 $1$ 表示一头被感染的奶牛，$0$ 表示一头在经过若干晚之后仍未被感染的奶牛。

接下来 $N-1$ 行描述了树的边。

接着输入 $Q$ 和 $Q$ 个夜晚数。
## 输出格式

输出 $Q$ 行，表示每个夜晚数的答案。若无解，输出 $-1$。
## 样例

### 样例输入 #1
```
5
11111
1 2
2 3
3 4
4 5
6
5
4
3
2
1
0
```
### 样例输出 #1
```
1
1
1
1
2
5
```
### 样例输入 #2
```
10
1111111111
1 2
2 3
2 4
2 5
2 6
6 7
7 8
8 9
9 10
11
0
1
2
3
4
5
6
7
8
9
10
```
### 样例输出 #2
```
10
3
2
1
1
1
1
1
1
1
1
```
### 样例输入 #3
```
5
11100
1 2
2 3
3 4
4 5
6
0
1
2
3
4
5
```
### 样例输出 #3
```
3
1
1
-1
-1
-1
```
## 提示

### 样例解释 1

对于前四个询问，一种可能是只有 $3$ 号奶牛一开始被感染。对于第五组询问（$1$ 晚），一种可能是 $2,4$ 号奶牛一开始被感染。对于第六组询问（$0$ 晚），一种可能是所有的五只奶牛在一开始都被感染。

### 样例解释 2

对于第一组询问（$0$ 晚），一种可能是所有的十只奶牛一开始都被感染。对于第二组询问（$1$ 晚），一种可能是 $2,7,9$ 号奶牛一开始被感染。对于第三组询问（$2$ 晚），一种可能是 $2,9$ 号奶牛一开始被感染。对于第四至第十一组询问，一种可能是只有 $7$ 号奶牛一开始被感染。

### 样例解释 3

对于第一组询问（$0$ 晚），一种可能是 $1,2,3$ 号奶牛一开始被感染。对于第二组询问（$1$ 晚），一种可能是只有 $2$ 号奶牛一开始被感染。对于第三组询问（$2$ 晚），一种可能是只有 $1$ 号奶牛一开始被感染。对于第四至第六组询问，不可能满足题给条件。

### 测试点性质

- 测试点 $4-5$ 满足 $N \le 10$。
- 测试点 $6-8$ 满足所有奶牛都被感染。
- 测试点 $9-11$ 满足 $N \le 400$。
- 测试点 $12-23$ 没有额外限制。


---


---
title: "[HBCPC2024] Lili Likes Polygons"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P10860
tag: ['2024', '离散化', '网络流', 'O2优化', 'XCPC', '湖北']
---
# [HBCPC2024] Lili Likes Polygons
## 题目描述

Lili and Nana are weeding in the backyard of Lili’s house. They are repeatedly selecting rectangular areas and removing all the grass within them.

The backyard can be visualized as a 2D grid, each square cell representing one unit area. They have performed a total of $n$ operations. During the $i$-th operation, they choose the left, bottom, right, and top sides of a rectangle, denoted as $l_i, b_i, r_i, t_i$, and clear all the cells within this rectangle using a lawnmower. **Note that these rectangles may overlap with each other.**

Let $[l_i, r_i]\times[b_i, t_i]$ denote a rectangle.

Here is an example illustrated in the following figure.  They have selected $2$ rectangles, with the first rectangle being $[1, 5]\times[2, 3]$ and the second rectangle being $[2, 3]\times[1, 4]$.

![](https://cdn.luogu.com.cn/upload/image_hosting/nb9g0n5i.png)

After the $n$ weeding operations, the union of the bare area may not be connected but all the sides are horizontal or vertical. Thus, the union becomes orthogonal polygon(s), some of which contain polygon holes.  Moreover, there can be bare cells inner some holes. Please see the example inputs for more details and illustrations.

Now, they want to restore the land by planting some plants on the bare cells. Lili likes polygons, especially rectangles. Therefore, they want to select several rectangles, and these rectangles do not overlap with each other and exactly cover all the bare cells. Then, they plant different plants in different rectangles they selected.

For example, here is a feasible selection of rectangles for the aforementioned case: choose $[1, 1]\times [2, 3]$, $[2, 3]\times[1, 4]$ and $[4, 5]\times [2, 3]$.

After playing for a while, these two little girls have become tired, so they want to know the minimum number of non-overlapping rectangles that can cover all the bare cells.
## 输入格式

The first line contains a single integer $n$ ($1\leq n\leq 300$) --- the number of rectangles when they weed.

The following $n$ lines each contain $4$ integers, and the $i$-th line contains $l_i, b_i, r_i, t_i$ ($1\leq l_i, b_i, r_i, t_i\leq 10^9, l_i\leq r_i, b_i\leq t_i$) --- the left, bottom, right, and top sides of the $i$-th rectangle.

It is guaranteed the sum of the endpoints of the bare area (polygon(s) with polygonal holes) does not exceed $2000$.
## 输出格式

Output a single integer on a single line denoting the minimum number of rectangles they need to select to plant plants on all the bare cells.
## 样例

### 样例输入 #1
```
8
1 1 1 1
1 2 1 2
1 3 1 3
2 1 2 1
2 3 2 3
3 1 3 1
3 2 3 2
3 3 3 3
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
2
1 1 100 100
1 501 100 600
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
4
1 1 4 1
1 4 5 4
1 1 1 4
4 1 4 5
```
### 样例输出 #3
```
5
```
### 样例输入 #4
```
9
1 1 9 1
1 1 1 9
1 9 9 9
9 1 9 9
3 3 7 3
3 3 3 7
3 7 7 7
7 3 7 7
5 5 5 5
```
### 样例输出 #4
```
9
```
## 提示

For the first example, an optimal selection is $[1, 1]\times [1, 3]$, $[2, 1]\times [2, 1]$,  $[2, 3]\times [2, 3]$ and $[3, 1]\times [3, 3]$.

For the second example, an optimal selection is $[1, 1]\times [100, 100]$ and $[1, 501]\times [100, 600]$.

For the third example, an optimal selection is $[1, 1]\times [4, 1]$, $[1, 4]\times [5, 4]$,  $[1, 2]\times [1, 3]$, $[4, 2]\times [4, 3]$ and $[4, 5]\times [4, 5]$.

For the fourth example, the bare area is illustrated in the following figure. 

![](https://cdn.luogu.com.cn/upload/image_hosting/uun9l7e6.png)
## 题目翻译

### 题目描述
莉莉和娜娜正在莉莉家后院除草。她们反复选择矩形区域，并移除其中的所有草坪。

后院可以被视为一个二维网格，每个方格表示一个单位面积。她们共进行了 $n$ 次操作。在第 $i$ 次操作中，她们选择了一个矩形的左、下、右、上的边界，分别表示为 $l_i, b_i, r_i, t_i$，并使用割草机清除该矩形内的所有方格。**注意，这些矩形可能会相互重叠。**

用 $[l_i, r_i] \times [b_i, t_i]$ 表示一个矩形。

以下是一个例子，如图所示。她们选择了 $2$ 个矩形，第一个矩形是 $[1, 5] \times [2, 3]$，第二个矩形是 $[2, 3] \times [1, 4]$。

经过 $n$ 次除草操作后，裸露区域的联合可能不连通，但所有边都是水平或垂直的。因此，联合区域变成了一个或多个直角多边形，其中一些可能包含多边形孔洞。此外，在某些孔洞内部可能会有裸露的方格。更多细节和图示请参见示例输入。

现在，她们想通过在裸露的方格上种植植物来恢复土地。莉莉喜欢多边形，特别是矩形。因此，她们想选择若干个矩形，这些矩形之间不重叠，并且能够完全覆盖所有的裸露方格。然后，她们将在选择的不同矩形中种植不同的植物。

例如，下面是上述情况的一个可行的矩形选择：选择 $[1, 1] \times [2, 3]$、$[2, 3] \times [1, 4]$ 和 $[4, 5] \times [2, 3]$。

玩了一会儿，这两个小女孩已经累了，所以她们想知道覆盖所有裸露方格的最小不重叠矩形数量。


### 输入格式

第一行包含一个整数 $n$ ($1 \leq n \leq 300$) —— 表示除草时使用的矩形数量。

接下来的 $n$ 行每行包含 $4$ 个整数，第 $i$ 行包含 $l_i, b_i, r_i, t_i$ ($1 \leq l_i, b_i, r_i, t_i \leq 10^9, l_i \leq r_i, b_i \leq t_i$) —— 表示第 $i$ 个矩形的左、下、右、上边界。

保证裸露区域的端点总数（多边形及其孔洞）不超过 $2000$。

### 输出格式

在一行上输出一个整数，表示覆盖所有裸露方格所需选择的最小矩形数量。

### 说明/提示

对于第一个例子，最优选择是 $[1, 1] \times [1, 3]$、$[2, 1] \times [2, 1]$、$[2, 3] \times [2, 3]$ 和 $[3, 1] \times [3, 3]$。

对于第二个例子，最优选择是 $[1, 1] \times [100, 100]$ 和 $[1, 501] \times [100, 600]$。

对于第三个例子，最优选择是 $[1, 1] \times [4, 1]$、$[1, 4] \times [5, 4]$、$[1, 2] \times [1, 3]$、$[4, 2] \times [4, 3]$ 和 $[4, 5] \times [4, 5]$。

对于第四个例子，裸露区域如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/uun9l7e6.png)

翻译者：[Immunoglobules](https://www.luogu.com.cn/user/1066251)


---

---
title: "[APIO2018] 新家"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4632
tag: ['2018', '线段树', '二分', '离散化', 'APIO']
---
# [APIO2018] 新家
## 题目背景

**警告！滥用本题者封号！请勿多次重复提交！**
## 题目描述

五福街是一条笔直的道路，这条道路可以看成一个数轴，街上每个建筑物的坐标都可以用一个整数来表示。小明是一位时光旅行者，他知道在这条街上，在过去现在和未来共有 $n$个商店出现。第 $i$个商店可以使用四个整数 $x_i, t_i, a_i, b_i$描述，它们分别表示：商店的坐标、商店的类型、商店开业的年份、商店关闭的年份。

小明希望通过时光旅行，选择一个合适的时间，住在五福街上的某个地方。他给出了一份他可能选择的列表，上面包括了 $q$个询问，每个询问用二元组 （坐标，时间）表示。第 $i$对二元组用两个整数 $l_i, y_i$描述，分别表示选择的地点 $l_i$和年份 $y_i$。

现在，他想计算出在这些时间和地点居住的生活质量。他定义居住的不方便指数为：在居住的年份，离居住点最远的商店类型到居住点的距离。类型 $t$的商店到居住点的距离定义为：在指定的年份，类型 $t$的所有营业的商店中，到居住点距离最近的一家到居住点的距离。我们说编号为 $i$的商店在第 $y$年在营业当且仅当 $a_i ≤ y ≤ b_i$ 。注意，在某些年份中，可能在五福街上并非所有 $k$种类型的商店都有至少一家在营业。在这种情况下，不方便指数定义为 $-1$。

你的任务是帮助小明求出每对（坐标，时间）二元组居住的不方便指数。
## 输入格式

第一行包含三个整数 $n, k$和 $q$ ，分别表示商店的数量、商店类型的数量和（坐标，时间）二元组的数量。$(1 \leq n, q \leq 3×10^5, 1 ≤ k ≤ n)$。

接下来 $n$行，每行包含四个整数 $x_i, t_i, a_i$ 和 $b_i$用于描述一家商店，意义如题面所述$(1 ≤ x_i, a_i, b_i ≤ 10^8, 1 ≤ t_i ≤ k, a_i ≤ b_i)$。

接下来 $q$行，每行包含两个整数 $l_i$和 $y_i$ ，表示一组（坐标，时间）查询$(1 ≤ l_i, y_i ≤ 10^8)$。
## 输出格式

输出一行，包含 $q$个整数，依次表示对于 $q$组（坐标，时间）询问求出的结果。
## 样例

### 样例输入 #1
```
4 2 4
3 1 1 10
9 2 2 4
7 2 5 7
4 1 8 10
5 3
5 6
5 9
1 10

```
### 样例输出 #1
```
4
2
-1
-1

```
### 样例输入 #2
```
2 1 3
1 1 1 4
1 1 2 6
1 3
1 5
1 7
```
### 样例输出 #2
```
0
0
-1

```
### 样例输入 #3
```
1 1 1
100000000 1 1 1
1 1

```
### 样例输出 #3
```
99999999

```
## 提示

**提示**

在第一个样例中，有 4 家商店，共 2 种类型，还有 4 个询问。

- 对于第一个询问：小明在第 3 年住在坐标为 5 的地方。这一年中，编号为 1 和 2 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 2 的商店距离为 4 ，所以最大距离为$4$。
- 对于第二个询问：小明在第 6 年住在坐标为 5 的地方。这一年中，编号为 1 和 3 的商店在营业，到编号为 1 的商店的距离为 2 ，到编号为 3 的商店距离为 2 ，所以最大距离为$2$。
- 对于第三个询问：小明在第 9 年住在坐标为 5 的地方。这一年中，编号为 1 和 4 的商店在营业，它们的类型都为 1，没有类型为 2 的商店在营业，所以答案为 $-1$。
- 同样的情况出现在第四个询问中。

在第二个样例中，有 2 家商店，共 1 种类型，还有三个询问。 两家商店的类型都是 1 。在所有的询问中，小明均住在坐标为 1 的地方。 在前两个询问中，至少有一个商店在营业，所以答案为 $0$ ，在第三个询问中，两个商店都不在营业，所以答案为 $-1$ 。

在第三个样例中，有 1 家商店和 1 个询问，两者之间的距离是 $99999999$ 。


**子任务（注：这里给出的子任务与本题在这里的最终评测无关，仅供参考）**

- Subtask 1(points: $5$): $n, q \leq 400$
- Subtask 2(points: $7$): $n, q \leq 6 × 10^4, k \leq 400$
- Subtask 3(points: $10$): $n, q \leq 3 × 10^5$，对于所有的商店 $a_i = 1, b_i = 10^8$
- Subtask 4(points: $23$): $n, q \leq 3 × 10^5$，对于所有的商店 $a_i = 1$
- Subtask 5(points: $35$): $n, q \leq 6 × 10^4$
- Subtask 6(points: $20$): $n, q \leq 3 × 10^5$



---

---
title: "[JOISC 2021] 最悪の記者 4 (Worst Reporter 4) (Day4)"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7563
tag: ['动态规划 DP', '线段树', '2021', '离散化', '树形 DP', '基环树', 'JOI（日本）', '线段树合并']
---
# [JOISC 2021] 最悪の記者 4 (Worst Reporter 4) (Day4)
## 题目背景

B 太郎不可爱。
## 题目描述

B 太郎是一名主要写关于 OI 的报道的记者。再过几天，就要举行 IOI 了，B 太郎决定写一篇关于 IOI 的文章。

比赛将有 $n$ 名选手参加，每位选手的编号从 $1$ 到 $n$。每位选手都有一个 Rating，这是衡量其实力的标准。Rating 用 $1$ 至 $10^9$ 之间的整数表示。

B 太郎采访了每位选手，并获得了以下信息：

- 选手 $i\ (1\le i\le N)$ 的 Rating 大于等于选手 $a_i\ (1\le a_i \le n)$ 的 Rating（$a_i$ 可以等于 $i$）。

在所有的采访结束后，B 太郎从管理 Rating 系统的公司收到了一张表格，上面有每个选手的 Rating。 表上写着以下信息：

- 选手 $i\ (1 \le i \le n)$ 的 Rating 是 $h_i$。

当 B 太郎试图根据这些信息写一篇文章时，他发现每个选手的 Rating 表可能存在错误。

由于临近截止时间，没有时间去弄正确的 Rating 表。因此，B 太郎决定重写表中选手的 Rating，使其与采访中获得的信息不相矛盾。

B 太郎在表中改写选手 $i\ (1\le i \le n)$ 的 Rating 需要 $c_i$ 日元。

也就是说，B 太郎可以通过支付 $c_i$ 日元，将列表中选手 $i$ 的 Rating 更改为 $1$ 到 $10^9$ 之间的任意整数。为了在截止日期前完成任务，B 太郎想要最小化更改列表中 Rating 的总成本。

编写一个程序，给定选手的数量、采访获得的信息、Rating 列表、和更改每个选手 Rating 所用的花费。请你计算不与采访信息矛盾的情况下，最少需要花费多少日元。


## 输入格式

第一行，一个正整数 $n$。

第 $2 \sim n + 1$ 行，每行三个正整数，$a_i,\ h_i,\ c_i$。




## 输出格式

仅一行一个正整数，表示不与采访信息矛盾的情况下，最少需要花费的日元钱数。
## 样例

### 样例输入 #1
```
6
1 6 5
1 3 6
1 8 4
3 4 9
2 2 5
2 5 6

```
### 样例输出 #1
```
14
```
### 样例输入 #2
```
5
1 1 1
2 2 1
4 3 1
3 3 1
4 3 1

```
### 样例输出 #2
```
0
```
### 样例输入 #3
```
20
1 7 381792936
1 89 964898447
1 27 797240712
3 4 299745243
2 18 113181438
2 20 952129455
4 34 124298446
4 89 33466733
7 40 109601410
5 81 902931267
2 4 669879699
8 23 785166502
8 1 601717183
8 26 747624379
1 17 504589209
9 24 909134233
16 56 236448090
8 94 605526613
5 90 481898834
9 34 183442771

```
### 样例输出 #3
```
2711043927

```
### 样例输入 #4
```
20
15 62 418848971
13 5 277275513
14 60 80376452
12 14 256845164
12 42 481331310
6 86 290168639
3 98 947342135
3 19 896070909
16 39 48034188
8 29 925729089
18 97 420006994
13 51 454182928
19 61 822405612
13 37 148425187
15 77 474094143
14 27 272926693
18 43 566552069
9 93 790433300
10 73 61654171
14 28 334498030

```
### 样例输出 #4
```
4012295156

```
## 提示

#### 样例 #1 解释

如下表所示。

| 选手 | 原 Rating | 更改为 | 花费日元 |
| :-: | :-: | :-: | :-: |
| $1$ | $6$ | $1$ | $5$ |
| $3$ | $8$ | $4$ | $4$ |
| $5$ | $2$ | $10^9$ | $5$ |

花费了 $5+4+5=14$ 日元。

本样例满足 Subtask $1, 2, 3$。


#### 样例 #2 解释

信息一致，输出 $\tt 0$。

#### 样例 #3 解释

本样例满足 Subtask $1, 2, 3$。

#### 数据规模与约定

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | 特殊限制 |
| :-: | :-: | :-: |
| $1$ | $14\%$ | $n \le 5 \times 10^3$，$a_i = 1$，$a_i \le i - 1$，且 $2 \le i \le n$ |
| $2$ | $65\%$ | $a_1 = 1$，$a_i \le i - 1$，且 $2 \le i \le n$ |
| $3$ | $21\%$ | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：

- $2 \le n \le 2 \times 10^5$；
- $1 \le a_i \le n\ (1\le i\le n)$；
- $1\le h_i,\ c_i \le 10^9\ (1\le i\le n)$；


#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 4 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/2021-sp-d4-notice.pdf) [T3 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day4/worst_reporter4.pdf)。


---

---
title: "[JOISC 2021] ボディーガード (Day3)"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7564
tag: ['动态规划 DP', '线段树', '2021', '离散化', 'JOI（日本）']
---
# [JOISC 2021] ボディーガード (Day3)
## 题目背景

因为数据包过大，所以请在 [此处](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/bodyguard-data.zip) 获取完整数据。
## 题目描述

在一条数轴上，有 $N$ 个人，他们都是书虫保镖公司的顾客，第 $i$ 个人会在第 $T_i$ 个时刻从第 $A_i$ 个位置移动到第 $B_i$ 个位置，他们的速度是每一个时刻一个单位长度。

如果一个保镖与一个顾客同时在一个位置上，就称保镖在保护这个顾客。设这个保镖从 $a$ 时刻开始保护一个顾客 $i$，从 $b$ 时刻停止保护，那么区间 $[a,b]$ 就称为这个顾客的保护时间，时刻 $a$ 称为保护开始时间，时刻 $b$ 称为保护停止时间。**其中 $a$ 和 $b$ 不必是整数**。特殊地，如果一个保镖与两个顾客同时在一个位置上，保镖只能保护一个顾客。

保镖可以在数轴上以最多每一个时刻一个单位长度最少静止不动的速度随意移动，当保镖停止保护一个顾客的时候，他可以到另一个位置上保护另一个顾客。如果一个保镖保护第 $i$ 个顾客一起走过的路径长度为 $L$，那么顾客 $i$ 将会以 $C_i$ 津巴布韦币每单位长度给这个保镖 $ L \times C_i$ 津巴布韦币作为他的工资。

书虫作为书虫保镖公司的老板，他手里紧握着 $Q$ 份策划保护的方案，其中，第 $j$ 个方案，一个保镖从时刻 $P_j$ 开始从第 $X_j$ 个位置出发开始进行工作。

求对于每个方案，每个保镖获得的总工资数量最多是多少津巴布韦币。
## 输入格式

第一行两个整数 $N,Q$ 代表顾客数和策划保护的方案数。

接下来 $N$ 行每行四个整数 $T_i,A_i,B_i,C_i$ 描述一位顾客。

接下来 $Q$ 行每行两个整数 $P_j,X_j$ 描述一个策划保护的方案。
## 输出格式

$Q$ 行每行一个整数代表每个方案保镖会得到的总工资最多是多少津巴布韦币。
## 样例

### 样例输入 #1
```
2 2
1 2 1 4
3 1 3 2
1 2
3 3
```
### 样例输出 #1
```
8
2
```
### 样例输入 #2
```
3 2
3 1 5 2
1 4 1 4
4 2 4 4
2 2
6 3
```
### 样例输出 #2
```
15
0
```
### 样例输入 #3
```
5 5
8 1 4 10
8 3 7 6
1 4 6 2
3 9 5 4
6 1 9 6
7 6
6 8
1 3
9 4
2 4
```
### 样例输出 #3
```
30
27
48
30
48
```
## 提示

#### 样例 1 解释

- 保护方案 $1$ 中保镖可以按照下面的方式得到 $4+4=8$ 津巴布韦币：
	- 在时刻 $1$ 从 $2$ 位置开始行动。
    - 从时刻 $1$ 到时刻 $2$ 保护顾客 $1$，一起走过的路径长度为 $1$，得到 $4 \times 1=4$ 津巴布韦币。
    - 时刻 $2$ 到时刻 $3$ 停留在 $1$ 位置。
    - 从时刻 $3$ 到时刻 $5$ 保护顾客 $2$，一起走过的路径长度为 $2$，得到 $2 \times 2=4$ 津巴布韦币。
- 保护方案 $2$ 中保镖可以按照下面的方式得到 $2$ 津巴布韦币：
	- 在时刻 $3$ 从 $3$ 位置开始行动。
    - 时刻 $3$ 到时刻 $4$ 从 $3$ 位置移动到 $2$ 位置。
    - 从时刻 $4$ 到时刻 $5$ 保护顾客 $2$，一起走过的路径长度为 $1$，得到 $2 \times 1=2$ 津巴布韦币。

#### 样例 2 解释

- 保护方案 $1$ 中保镖可以按照下面的方式得到 $4+1+8+2=15$ 津巴布韦币：
	- 在时刻 $2$ 从 $2$ 位置开始行动。
    - 时刻 $2$ 到时刻 $2.5$ 从 $2$ 位置移动到 $2.5$ 位置。
    - 从时刻 $2.5$ 到时刻 $3.5$ 保护顾客 $2$，一起走过的路径长度为 $1$，得到 $4 \times 1=4$ 津巴布韦币。
    - 从时刻 $3.5$ 到时刻 $4$ 保护顾客 $1$，一起走过的路径长度为 $0.5$，得到 $2 \times 0.5=1$ 津巴布韦币。
    - 从时刻 $4$ 到时刻 $6$ 保护顾客 $3$，一起走过的路径长度为 $2$，得到 $4 \times 2=8$ 津巴布韦币。
    - 从时刻 $6$ 到时刻 $7$ 保护顾客 $1$，一起走过的路径长度为 $1$，得到 $2 \times 1=2$ 津巴布韦币。
- 保护方案 $2$ 中保镖无论怎么走都得不到工资，只能得到 $0$ 津巴布韦币。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（6 pts）：$T_i,A_i,B_i,P_j,X_j \le 3000$。
- Subtask 2（7 pts）：$Q=1$。
- Subtask 3（15 pts）：$Q \le 3000$。
- Subtask 4（20 pts）：$Q \le 4 \times 10^4$。
- Subtask 5（52 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 2800$，$1 \le Q \le 3 \times 10^6$，$1 \le T_i,A_i,B_i,C_i \le 10^9$，$A_i \ne B_i$，$C_i$ 为偶数，$1 \le P_j,X_j \le 10^9$。

#### 说明

翻译自 [第２０回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [Day3 B ボディーガード (Bodyguard) 的英文版本](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/bodyguard-en.pdf)。


---

---
title: "[CCO 2021] Loop Town"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7833
tag: ['树状数组', '2021', '离散化', 'CCO（加拿大）']
---
# [CCO 2021] Loop Town
## 题目描述

循环镇有 $n$ 个公民、$n$ 座房子、$n$ 个办公室。每个公民住在一座房子中，并在一个办公室工作。没有两个公民住在同一座房子，也没有两个公民在同一个办公室工作。

循环镇是一个环形城市，绕城一圈路程为 $l$。循环镇的 $2n$ 栋建筑（房子和办公室）都在环上的整点上，其位置可以用 $[0, l - 1]$ 范围内的整数来描述，且这 $2n$ 栋建筑位置是互不相同的。

每天早上，每个公民同时从自己的房子出发，沿着环路走到自己的办公室。公民到达办公室之后不会立刻进去工作，而是要等到所有公民都到达办公室之后才会同时进入办公室开始工作。

一场疫情的到来打破了常规，领导人要求每个公民保持社交距离。围绕城市的环状道路很窄，两个公民的线路存在相互交叉时会很不方便（必须一个人暂时离开道路才能使另一个人通过），而三个人或以上禁止同时走到同一个地方。

领导人可以给每个公民规定上班路线，即走城市环路的哪一边。领导人的目标是任意两个公民线路交叉的总次数最小，求这个最小值。
## 输入格式

第一行，两个整数 $n, l$；

接下来 $n$ 行，每行两个整数 $a_i, b_i$，表示第 $i$ 个公民的房子和办公室的位置。
## 输出格式

一行，一个整数，表示所求的值。
## 样例

### 样例输入 #1
```
3 100
10 50
30 20
60 40
```
### 样例输出 #1
```
0
```
### 样例输入 #2
```
4 100
30 70
10 12
60 75
90 50
```
### 样例输出 #2
```
1
```
## 提示

#### 数据范围
对于 $\frac{4}{13}$ 的数据，$1 \leq n \leq 5 \times 10^3$；

对于 $\frac{8}{13}$ 的数据，$1 \leq n \leq 10^5$；

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$1 \leq l \leq 10^9$，$0 \leq a_i, b_i < l$，**保证 $a_i, b_i$ 互不相同**。
#### 题目来源
[CCO2021](https://cemc.math.uwaterloo.ca/contests/computing/2021/index.html) D2T3


---

---
title: "[NOI2023] 深搜"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P9480
tag: ['线段树', '2023', 'NOI', '离散化', 'O2优化', '动态规划优化', '树形 DP', '容斥原理']
---
# [NOI2023] 深搜
## 题目描述

深度优先搜索是一种常见的搜索算法。通过此算法，我们可以从一个无重边、无自环的无向连通图 $G = (V, E)$，和某个出发点 $s$，得到一棵树 $T$。

算法的流程描述如下:

1. 将栈 $S$ 设置为空，并令 $T = (V, \emptyset)$，即 $T$ 的边集初始为空。
2. 首先将出发点 $s$ 压入 $S$ 中。
3. 访问栈顶节点 $u$，并将 $u$ 标记为“已访问的”。
4. 如果存在与 $u$ 相邻且未被访问的节点，则**任意地**从这些节点中挑选一个记为 $v$。我们将边 $(u, v)$ 加入 $T$ 的边集中，并将 $v$ 压入栈 $S$ 中，然后**回到步骤 3**。若不存在这样的节点，则从栈中弹出节点 $u$。

可以证明，当图 $G$ 为连通图时，该算法会得到图的某一棵生成树 $T$。但**算法得到的树 $T$ 可能不是唯一的，它取决于搜索的顺序，也就是算法的第 4 步所选取的顶点**。指定出发点 $s$ 后，如果能够选取一种特定的搜索顺序，使得算法得到的树恰好是 $T$，则我们称 **$T$ 是 $G$ 的一棵 $s$-dfs 树**。

现在给定一棵 $n$ 个顶点的树 $T$，顶点编号为 $1 \sim n$，并额外给出 $m$ 条边。我们保证这 $m$ 条边两两不同，连接不同的顶点，且与 $T$ 中的 $n - 1$ 条树边两两不同。我们称额外给出的 $m$ 条边为**非树边**。在这 $n$ 个顶点中，我们指定了恰好 $k$ 个顶点作为**关键点**。

现在你想知道，有多少种选取这 $m$ 条非树边的方法（可以全部不选），使得：将 $T$ 的边与被选中的非树边构成图 $G$ 之后，存在某个**关键点** $s$，使得 $T$ 是 $G$ 的一棵 $s$-dfs 树。

由于答案可能十分巨大，你只需要输出方案数在模 $(10 ^ 9 + 7)$ 意义下的值。
## 输入格式

输入的第一行包含一个整数 $c$，表示测试点编号。$c = 0$ 表示该测试点为样例。

输入的第二行包含三个正整数 $n, m, k$，分别表示顶点个数，非树边的数量，关键点的数量。

接下来 $n - 1$ 行，每行包含两个正整数 $u, v$ 表示树 $T$ 的一条边。保证这 $n - 1$ 条边构成了一棵树。

接下来 $m$ 行，每行包含两个正整数 $a, b$ 表示一条非树边。保证 $(a, b)$ 不与树上的边重合，且没有重边。

输入的最后一行包含 $k$ 个正整数 $s_1, s_2, \dots, s_k$，表示 $k$ 个关键点的编号。保证 $s_1, s_2, \dots, s_k$ 互不相同。
## 输出格式

输出一行包含一个非负整数，表示方案数在模 $(10 ^ 9 + 7)$ 意义下的值。
## 样例

### 样例输入 #1
```
0
4 2 2
1 2
2 3
3 4
1 3
2 4
2 3

```
### 样例输出 #1
```
3

```
### 样例输入 #2
```
见附件中的 dfs/dfs2.in。
```
### 样例输出 #2
```
见附件中的 dfs/dfs2.ans。
```
### 样例输入 #3
```
见附件中的 dfs/dfs3.in。
```
### 样例输出 #3
```
见附件中的 dfs/dfs3.ans。
```
### 样例输入 #4
```
见附件中的 dfs/dfs4.in。
```
### 样例输出 #4
```
见附件中的 dfs/dfs4.ans。
```
### 样例输入 #5
```
见附件中的 dfs/dfs5.in。
```
### 样例输出 #5
```
见附件中的 dfs/dfs5.ans。
```
### 样例输入 #6
```
见附件中的 dfs/dfs6.in。
```
### 样例输出 #6
```
见附件中的 dfs/dfs6.ans。
```
## 提示

**【样例解释 #1】**

在这个样例中，有三种选取非树边的方法：只选取边 $(1, 3)$，只选取边 $(2, 4)$，或不选取任何条非树边。

如果只选取边 $(1, 3)$，或者不选取任何一条非树边，则我们发现 $T$ 都是图 $G$ 的 $3$-dfs 树。指定的搜索顺序如下：
1. 将 $3$ 放入栈 $S$ 中。此时 $S = [3]$。
2. 将 $3$ 标记为“已访问的”。
3. 由于 $3$ 与 $2$ 相连，且 $2$ 是“未访问的”，将 $2$ 放入栈 $S$ 中，并将 $(3, 2)$ 加入树 $T$ 中，此时 $S = [3, 2]$。
4. 将 $2$ 标记为“已访问的”。
5. 由于 $2$ 与 $1$ 相连，且 $1$ 是“未访问的”，将 $1$ 放入栈 $S$ 中，并将 $(2, 1)$ 加入树 $T$ 中，此时 $S = [3, 2, 1]$。
6. 由于与 $1$ 相邻的点都是“已访问的”，将 $1$ 弹出栈，此时 $S = [3, 2]$。
7. 由于与 $2$ 相邻的点都是“已访问的”，将 $2$ 弹出栈，此时 $S = [3]$。
8. 由于 $3$ 与 $4$ 相连，且 $4$ 是“未访问的”，将 $4$ 放入栈 $S$ 中，并将 $(3, 4)$ 加入树 $T$ 中，此时 $S = [3, 4]$。
9. 由于与 $4$ 相连的点都是“已访问的”，将 $4$ 弹出栈，此时 $S = [3]$。
10. 由于与 $3$ 相连的点都是“己访问的”，将 $3$ 弹出栈，此时 $S$重新变为空。

如果只选取边 $(2, 4)$，则我们可以说明 $T$ 是图 $G$ 的 $2$-dfs 树。指定的搜索顺序如下：

1. 将 $2$ 放入栈 $S$ 中。此时 $S = [2]$。
2. 将 $2$ 标记为“已访问的”。
3. 由于 $2$ 与 $3$ 相连，且 $3$ 是“未访问的”，将 $3$ 放入栈 $S$ 中，并将 $(2, 3)$ 加入树 $T$ 中，此时 $S = [2, 3]$。
4. 将 $3$ 标记为“已访问的”。
5. 由于 $3$ 与 $4$ 相连，且 $4$ 是“未访问的”，将 $4$ 放入栈 $S$ 中，并将 $(3, 4)$ 加入树 $T$ 中，此时 $S = [2, 3, 4]$。
6. 由于与 $4$ 相邻的点都是“己访问的”，将 $4$ 弹出栈，此时 $S = [2, 3]$。
7. 由于与 $3$ 相邻的点都是“已访问的”，将 $3$ 弹出栈，此时 $S= [2]$。
8. 由于 $2$ 与 $1$ 相连，且 $1$ 是“未访问的”，将 $1$ 放入栈 $S$ 中，并将 $(2, 1)$ 加入树 $T$ 中，此时 $S = [2, 1]$。
9. 由于与 $1$ 相连的点都是“已访问的”，将 $1$ 弹出栈此时 $S = [2]$。
10. 由于与 $2$ 相连的点都是“已访问的”，将 $2$ 弹出栈，此时 $S$ 重新变为空。

**【样例解释 #2】**

这个样例满足测试点 $4 \sim 6$ 的约束条件。

**【样例解释 #3】**

这个样例满足测试点 $10 \sim 11$ 的约束条件。

**【样例解释 #4】**

这个样例满足测试点 $12 \sim 13$ 的约束条件。

**【样例解释 #5】**

这个样例满足测试点 $14 \sim 16$ 的约束条件。

**【样例解释 #6】**

这个样例满足测试点 $23 \sim 24$ 的约束条件。

**【数据范围】**

对于所有测试数据保证：$1 \le k \le n \le 5 \times 10 ^ 5$，$1 \le m \le 5 \times 10 ^ 5$。

|测试点编号|$n \le$|$m \le$|$k \le$|特殊性质|
|:-:|:-:|:-:|:-:|:-:|
|$1 \sim 3$|$6$|$6$|$n$|无|
|$4 \sim 6$|$15$|$15$|$6$|无|
|$7 \sim 9$|$300$|$300$|$6$|无|
|$10 \sim 11$|$300$|$300$|$n$|A|
|$12 \sim 13$|$300$|$300$|$n$|B|
|$14 \sim 16$|$300$|$300$|$n$|无|
|$17 \sim 18$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|A|
|$19 \sim 21$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|B|
|$22$|$2 \times 10 ^ 5$|$2 \times 10 ^ 5$|$n$|无|
|$23 \sim 25$|$5 \times 10 ^ 5$|$5 \times 10 ^ 5$|$n$|无|

特殊性质 A：保证在 $T$ 中，$i$ 号点与 $i + 1$ 号点相连（$1 \le i < n$）。

特殊性质 B：保证若将 $T$ 的边与所有 $m$ 条非树边构成一个图 $G$，则 $T$ 是 $G$ 的棵 $1$-dfs 树。

**请注意，$1$ 号点不一定是 $k$ 个关键点之一。**


---


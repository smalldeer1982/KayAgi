---
title: "[HNOI2013] 旅行"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P3229
tag: ['数学', '2013', '单调队列', '湖南', '高斯消元']
---
# [HNOI2013] 旅行
## 题目描述

在遥远的 HX 国，住着一个旅行家小 L，他希望骑着他的自行车游遍全国。在这个国家中，每个城市都有一个编号，共有 $n$ 个城市，编号从 $1$ 到 $n$。

有的城市没有小 L 想去的景点，而有的城市有且仅有一个小 L 想去的景点，所有的城市都是这两种情况之一，小 L 非常热爱信息学，他编写程序给他的旅行安排了一条最短路线以到达所有他想去的景点（所有的通知旅行线路上城市编号是乱序的）：他第 $1$ 个到达的城市编号为 $a_1$，第 $i$ 个到达的城市编号为 $a_i$，最后到达城市 $a_n$ 结束这次旅行。小L希望用恰好的 $m$ 个月（$m<n$）的时间完成这次旅行，所以他需要制定一个理性的旅游计划。

当他抵达一个城市时，如果这个城市有他想要去的景点，他会因此获得 $1$ 点快乐值；但是若到达的城市没有他想去的景点，他会因旅途的疲惫得到 $1$ 点的疲劳值：一个月的时间足够他游玩任意多个城市，但他也希望拿出一点时间来休息。他每个月总是在本月所到达的最后一个城市休息（但如果这个城市有景点，那么小 L 总会游玩这个景点再休息）。当然，小 L 希望每个月都能有一定的旅行任务。即便这个月他所到达的城市中并没有他想去的的景点，换句话说，每个月他都会至少到达一个新的城市。

小 L 无法自己安排旅行计划，所以求助于你。你需要告诉他一个序列：$x_1,x_2,\ldots,x_m$，其中 $x_i$ 表示小 L 第 $i$ 个月休息时。他所在的城市编号：由于他最后一个月必须完成他的旅行，所以 $x_m$ 肯定等于 $a_n$，例如，设 $n=5$，$m=3$，$(a_1,a_2,a_3,a_4,a_5)=(3,2,4,1,5)$，$(x_1,x_2,x_3)=(2,1,5)$，这意味着：第 $1$ 个月先后到达 $3$ 号和 $2$ 号城市，并在 $2$ 号城市休息：第 $2$ 个月先后到达 $4$ 号和 $1$ 号城市，并在 $1$ 号城市休息：第 $3$ 个月到达 $5$ 号城市，并在 $5$ 号城市休息。

这样的方案序列有很多种，设每种方案序列中第 $i$ 个月旅行中当月获得的快乐值与疲劳值的差绝对值为 $d_i$，设第 $k$ 种方案序列中求出的 $d_1,d_2,\ldots,d_m$ 这个 $m$ 值的最大值为 $c_k$，小 L 希望所选择的方案序列的 $c_k$ 在所有方案序列中是最小的。

事实上，可能有多个方案序列的 $c_k$ 达到并列最小值。由于小 L 喜爱编程，他患上了一定的强迫症（虽然他自己认为他的强迫症让他炫的发黄），他希望给他的序列是这多个方案中字典序最小的。

Tips：比较两个序列字典序即比较第一个不相同数字的大小，如 $(1,2,3,4)<(1,2,4,3)$。
## 输入格式

第一行为两个空格隔开的正整数 $n, m$，表示旅行的城市数与旅行所花的月数。

接下来 $n$ 行，其中第 $i$ 行包含两个空格隔开的整数 $A_i$ 和 $B_i$，$A_i$ 表示他第 $i$ 个去的城市编号，$B_i$ 为 $0$ 或 $1$。如果 $B_i=0$ 则表示城市 $A_i$ 没有小 L 想去的景点，如果 $B_i=1$ 则表示城市 $A_i$ 有小 L 想去的景点，$A_i$ 两两不同且有 $1\leq  A_i\leq N$，即 $\{A_i\}$ 为 $1,2,\ldots,N$ 的一个排列。
## 输出格式

输出仅包含一行，包含 $m$ 个空格隔开的正整数 $X_1,X_2,\ldots,X_m$，即给小 L 安排的旅行计划对应的路线。

## 样例

### 样例输入 #1
```
8  3
2  0
3  1
4  1
1  0
5  0
6  1
7  1
8  0
```
### 样例输出 #1
```
1 6 8
```
## 提示

第 $1$ 个月得到 $2$ 点快乐值与 $2$ 点疲劳值，第 $2$ 个月得到 $1$ 点快乐值与 $1$ 点疲劳值，第 $3$ 个月得到 $1$ 点快乐值与 $1$ 点疲劳值。$3$ 个月中疲劳值与快乐值差的最大值为 $0$，达到所有方案最小值。

可行方案有：

- 1 6 8
- 3 6 8
- 3 1 8

其中 1 6 8 字典序最小。

$N \leq 5 \times 10^5$，$M \leq 2 \times 10^5$。


---

---
title: "[AH2017/HNOI2017] 队长快跑"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P3725
tag: ['2017', '各省省选', '安徽', '湖南', 'Special Judge', '排序', '最短路', '队列']
---
# [AH2017/HNOI2017] 队长快跑
## 题目描述

众所周知，在 P 国外不远处盘踞着巨龙大 Y。传说中，在远古时代，巨龙大 Y 将 P 国的镇国之宝窃走并藏在了其巢穴中，这吸引着整个 P 国的所有冒险家前去夺回，尤其是皇家卫士队的队长小 W。在 P 国量子科技实验室的帮助下，队长小 W 通过量子传输进入了巨龙大 Y 的藏宝室，并成功夺回了镇国之宝。但此时巨龙布下的攻击性防壁启动，将小 W 困在了美杜莎的迷宫当中。

被困在迷宫 $(0,0)$ 处的队长小 W 快速观察了美杜莎的迷宫的构造，发现迷宫的出口位于 $(p,q)$ 处。巨龙大 Y 在迷宫当中布置了 $n$ 火焰吐息机关，每个机关可以用三个参数 $(x,y,\theta)$ 表示，分别指明机关位于平面的坐标 $(x,y)$，以及火焰吐息的方向相对于 $x$ 正方向的倾角 $\theta$。巨龙强大的力量使得火焰吐息有无穷长，且队长小  W 不能通过被火焰吐息覆盖的射线（注意，机关所处的坐标若没有被其他火焰吐息覆盖，则是可以通过的）。同时，迷宫在沿 $x$ 负方向无穷远的地方放置了美杜莎之眼，使得队长小 W 必须倾向于向 $x$ 正方向行动（即队长小 W 的移动方向在 $x$ 正方向上的投影必须为正，不能是负数或零），否则队长小 W 将被瞬间石化而无法逃离。

心急如焚的队长小 W 需要趁着巨龙大 Y 还没将其抓住前逃离美杜莎的迷宫，所以他立马向 P 国智囊团求助，作为智囊团团长的你，一定可以帮队长小 W 找出安全逃至迷宫出口的最短道路。

## 输入格式

第一行为三个整数 $n,p,q$ 分别表示火焰吐息机关总数以及出口坐标。

接下来 $n$ 行，每行两个整数与一个实数 $(x,y,\theta)$ 分别表示机关所处的坐标以及火焰吐息的关于 $x$ 正方向的倾角。

## 输出格式

输出文件仅包含一行一个小数，表示最短道路的长度。当你的答案和标准答案的相对误差不超过 $10^{-8}$ 时（ 即 $\frac{|a-o|}{a}\leq10^{-8}$ 时， 其中 $a$ 是标准答案，$o$ 是输出）认为你的答案正确。

## 样例

### 样例输入 #1
```
7 20 -5
4 3 -2.875
5 7 -1.314
10 -2 0.666
16 1 -1.571
16 1 1.571
23 -3 -2.130
14 -5 3.073
```
### 样例输出 #1
```
33.3380422500
```
### 样例输入 #2
```
7 20 0
5 2 1.155
5 2 1.987
5 2 -1.571
11 -4 1.765
11 -4 1.377
15 -4 1.765
15 -4 1.377
```
### 样例输出 #2
```
24.2735704188
```
## 提示

【样例解释】

 ![](https://cdn.luogu.com.cn/upload/pic/5107.png) 

$30\%$ 的数据满足 $n\leq 300$；

$60\%$ 的数据满足 $n\leq 2000$；

$80\%$ 的数据满足 $n\leq 10^5$；

$100\%$ 的数据满足： $0 \leq n,p, |q|, |x|, |y| \leq 10^6； \theta \in [−\pi, \pi]$。
数据保证至少存在一条合法路径，且起点和终点均不会被火焰路径覆盖。



---

---
title: "核心密码B"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P3766
tag: ['数学', '洛谷原创', 'Special Judge', 'O2优化', '优先队列', '洛谷月赛']
---
# 核心密码B
## 题目背景

懒得拷题目背景了，参见核心密码A...

请注意两道题的唯一差别。

## 题目描述

令g(n)表示n能表示成几种不同的完全k次方数（k>1），求$f(n)=\sum_{i=2}^n \frac{g(i)}{i}$。

例如，$64=2^6=4^3=8^2$，所以g(64)=3。

## 输入格式

多组询问，第一行一个整数T表示询问组数。

接下来T行，每行一个整数n，表示询问f(n)。

## 输出格式

T行，每行一个实数，表示f(n)，保留十四位小数。

**由于精度误差，你的答案和标准答案差的绝对值在$2 \times 10^{-14}$以内即可通过**

## 样例

### 样例输入 #1
```
2
5
15
```
### 样例输出 #1
```
0.25000000000000
0.48611111111111
```
## 提示

对于20%的数据，$n \leq 1000$。

对于40%的数据，$n \leq 10^6$，$T \leq 5$。

对于100%的数据，$2 \leq n \leq 10^{18}$，$1 \leq T \leq 50000$。



---

---
title: "[SDOI2017] 苹果树"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P3780
tag: ['2017', '各省省选', '单调队列', '山东', 'O2优化', '枚举', '背包 DP']
---
# [SDOI2017] 苹果树
## 题目背景

**警告：滥用本题评测将封号**
## 题目描述

夏天近了，又到了恋爱的季节，小Q家门前的苹果树上结满了红红圆圆的苹果。


这株苹果树是一个有着$n$个结点的有根树，其中结点被依次编号为$1$至$n$。$1$号结点为根，其余每一个结点的父结点一定是某个编号较小的结点。每一个结点上都有一些苹果，第$i$个结点上有$a_i (a_i > 0)$个苹果，每取走其中一个苹果就可以得到$v_i (v_i > 0)$的幸福度（若在这个结点取走$k \leq a_i$个苹果，则可以收获$kv_i$的幸福度）。如果在一个结点取走了至少一个苹果，则必须要在其父结点处取走至少一个苹果。


现在，给定正整数$k$，请从树上取走若干苹果。如果总计取走了$t$个苹果，且所有取了至少一个苹果的那些结点的最大深度为$h$（这里规定根结点的深度为$1$），则要求$t-h \leq k$。问最大可以收获多少的幸福度？（这些幸福度全都归属于恋爱中的小Q。）

## 输入格式

本题有多组测试数据，输入的第一行给定整数$Q$，表示有$Q$组数据。之后依次给出$Q$组数据。

对于每一组数据来说，第一行包含两个整数$n$和$k$。

之后$n$行，每行给出三个整数，描述了每一个结点。其中第$i$行的第一个整数给出了$i$的父结点标号

（如果$i = 1$，则其父结点为$0$），第二个整数为$a_i$，第三个整数为$v_i$。

## 输出格式

输出一共有$Q$行，对应了$Q$组数据。

对于每一组数据，输出一个整数，表示最大可以收获的幸福度。

## 样例

### 样例输入 #1
```
2
5 1
0 1 1
1 1 1
1 1 3
2 1 10
3 1 4
9 15
0 1 1
1 7 2
2 5 10
1 3 1
4 3 17
4 3 18
4 4 19
1 1 1
8 1 100
```
### 样例输出 #1
```
15
316
```
## 提示

有$10\%$的数据，满足$nk \leq 3000000$且给定的树的高度为$2$。

有$20\%$的数据，满足$nk \leq 25000000$且给定的树的高度为$2$。

有$20\%$的数据，满足$nk \leq 25000000$且所有$a_i$均为$1$。

还有$20\%$的数据，满足$nk \leq 3000000$，没有上述额外限制。

对于$100\%$的数据，满足$1 \leq Q \leq 5$；$1 \leq n \leq 20000$；$1 \leq k \leq 500000$；$1 \leq nk \leq 25000000$；$1 \leq a_i \leq 10^8$；$1 \leq v_i \leq 100$。



---

---
title: "[WC2015] k 小割"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4153
tag: ['搜索', '2015', 'O2优化', '优先队列', '最小割', 'WC']
---
# [WC2015] k 小割
## 题目描述

给出一个有向带权网络 $G = (V, E)$，权值函数 $w: E \rightarrow \mathbb{Z^{*}}$（即任意边 $e$ 的权值 $w(e)$ 均为正整数），和点 $s, t \in V$，使得在 $G' = (V, E - S)$ 上不存在 $s$ 到 $t$ 的路径。


设 $\mathfrak{S}$ 是所有满足条件的边集 $S$ 的全集，按 $w(S)$ 从小到大输出 $\mathfrak{S}$ 中前 $k$ 小的边集的边权和。其中 $w(S) = \sum_{e \in S} w(e)$。

## 输入格式

第一行包含 $5$ 个正整数 $n, m, s, t, k$，其中 $s, t, k$ 意义如上，$n, m$ 分别表示 $\lvert V \rvert, \lvert E \rvert$（即点数和边数）。规定图中的节点用 $1$ 到 $n$ 的整数表示。保证 $s \neq t$。


接下来 $m$ 行，每行 $3$ 个整数 $x, y, z$，表示一条边权为 $z$ 的从 $x$ 到 $y$ 的边。可能有重边但保证没有自环。

## 输出格式

如果 $\lvert \mathfrak{S} \rvert < k$，先输出 $\lvert \mathfrak{S} \rvert$ 行，每行包含一个整数，表示前 $\lvert \mathfrak{S} \rvert$ 个 $w(S)$；再输出一行一个整数 $-1$。


如果 $\lvert \mathfrak{S} \rvert \geq k$，则输出 $k$ 行，表示前 $k$ 个 $w(S)$。


两种情况均需按照 $w(S)$ 从小到大输出。

## 样例

### 样例输入 #1
```
3 3 1 3 100
1 2 3
2 3 4
1 3 5

```
### 样例输出 #1
```
8
9
12
-1

```
### 样例输入 #2
```
5 8 1 5 10
1 2 45176
1 3 41088
1 4 32001
2 5 48931
3 5 39291
4 5 28970
2 3 48131
4 2 49795

```
### 样例输出 #2
```
116468
117192
118265
120223
145438
147235
149193
157556
158280
161311

```
## 提示

| 测试点编号 | $n \le$ | $m$ | $k \le$ | 约束 |
|:-:|:-:|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | $\le 20$ | ${10}^6$ | 边权不超过 $65536$ |
| $3 \sim 6$ | $50$ | $\le 100$ | $100$ | 边权不超过 $65536$ |
| $7 \sim 10$ | $3000$ | $= 2 n - 4$ | $5 \times {10}^5$ | $s$ 有边连向所有非 $t$ 节点，所有非 $s$ 结点有边连向 $t$，边权不超过 $2^{31} - 1$ |
| $11 \sim 14$ | $1.5 \times {10}^5$ | $= 2 n - 4$ | $5 \times {10}^5$ | $s$ 有边连向所有非 $t$ 节点，所有非 $s$ 结点有边连向 $t$，边权不超过 $2^{31} - 1$ |
| $15 \sim 20$ | $50$ | $\le 1500$ | $100$ | 边权不超过 $65536$ |


---

---
title: "[WC2010] 重建计划"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4292
tag: ['2010', '点分治', '单调队列', '分治', 'WC']
---
# [WC2010] 重建计划
## 题目描述

X 国遭受了地震的重创, 导致全国的交通近乎瘫痪，重建家园的计划迫在眉睫。X 国由 $N$ 个城市组成, 重建小组提出，仅需建立 $N-1$ 条道路即可使得任意两个城市互相可达。于是，重建小组很快提出了一个包含 $N-1$ 条道路的方案，并满足城市之间两两可达，他们还计算评估了每条道路 $e$ 建设之后可以带来的价值 $v(e)$。  

由于重建计划复杂而艰难，经费也有一定限制。因此，政府要求第一期重建工程修建的道路数目为 $k$ 条，但需满足 $L \leq k \leq U$，即不应少于$L$ 条，但不超过 $U$ 条。同时，为了最大化利用率，要求建设的这些道路恰好组成一条简单路径，即所建设的 $k$ 条路径可以构成一个排列 $e_1 = (p_1, q_1), e_2 = (p_2, q_2), \cdots , e_k = (p_k, q_k)$， 对于 $1 \leq i < k$， 有$(q_i = p_{i+1})$。 

重建小组打算修改他们的原有方案以满足要求，即在原有的 $N-1$ 条道路中寻找一条路径 $S$ 作为新的方案，使得新方案中的道路平均价值

$$AvgValue = \frac{\sum _{e \in S} v(e)}{|S|}$$

最大。这里 $v(e)$ 表示道路 $e$ 的价值，$|S|$ 表示新方案中道路的条数。请你帮助重建小组寻找一个最优方案。  注: 在本题中 $L$ 和 $U$ 的设置将保证有解。

## 输入格式

第一行包含一个正整数 $N$ ，表示 X 国的城市个数。 

第二行包含两个正整数 $L,U$，表示政府要求的第一期重建方案中修建道路数的上下限。  

接下来的 $N-1$ 行描述重建小组的原有方案，每行三个正整数 $a_i, b_i, v_i$，分别表示道路 $(a_i, b_i)$，其价值为 $v_i$ 。其中城市由$1 \cdots N$标号。
## 输出格式

仅包含一行，为一个实数 $AvgValue$，即最大平均价值。

小数点后保留三位。
## 样例

### 样例输入 #1
```
4 
2 3 
1 2 1 
1 3 2 
1 4 3
```
### 样例输出 #1
```
2.500
```
## 提示

新方案中选择路径 $(3, 1), (1, 4)$ 可以得到的平均价值为 $2.5$，为最大平均价值。

对于20%的数据，$N \leq 5 000$;  

另有30%的数据，$N \leq 100 000$， 原有方案恰好为一条路径(链); 

对于100%的数据，$N \leq 100 000, 1 \leq L \leq U \leq N-1, v_i \leq 10^6$。


---

---
title: "[USACO18OPEN] Train Tracking P"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4373
tag: ['2018', 'USACO', '单调队列', '交互题', 'Special Judge', '分块']
---
# [USACO18OPEN] Train Tracking P
## 题目背景

鉴于本题存在特殊要求且大部分人**不遵守**，题解通道关闭。如确有正解，请联系管理员单独添加。

1. 你的程序不需要，也不应该包含 `grader.h` 头文件。
2. 请在程序中加入如下函数声明语句：

```cpp
int get(int);
void set(int,int);
void shoutMinimum(int);
int getTrainLength();
int getWindowLength();
int getCurrentCarIndex();
int getCurrentPassIndex();
```
## 题目描述

每天早晨特快列车会经过农场，开往大城市，每天下午它又会折回来，回到郊区。今天，Bessie 会花时间观察它，早晨和下午都会。

Bessie 提前知道，列车有 $N$ 节车厢，方便起见，将其编号为 $0\sim N-1$。车厢 $i$ 有一个 ID $c_i$。在早晨和下午，所有的数字都是可见的，所以对于每节车厢 Bessie 有两次机会观察它的 ID。也就是说，当列车早晨经过的时候，Bessie 能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。当列车下午驶回的时候，她又一次能够观察 $c_0$，然后是 $c_1$，直到 $c_{N-1}$。 

Bessie 挑选了一个整数 $K$，她想要求出每个连续的 $K$ 节车厢中最小的 ID。她有一本能够帮助执行计算的笔记本，但是这个笔记本相当小，并且 Bessie 的手写（蹄写？）字相当大。比方说，可能没有足够的空间记下所有 $N+1-K$ 个最小值。由于某些神秘的原因，Bessie 满足于当她算出最小数的时候向天哞出这些数，所以这个问题至少还不成问题。

列车马上就要来了！帮助 Bessie 在列车经过两次之后求出这 $N+1−K$ 个最小数，确保她有效地利用她有限的笔记本空间。她的笔记本被分为 $5500$ 个部分，方便起见编号为 $0\sim 5499$，每个部分的空间恰好能够记录一个在 $[-2^{31} , 2^{31}-1]$ 之间的整数。最初的时候，每个部分都记录着整数 $0$。

请帮助 Bessie 有效管理她有限的笔记本空间。

### 交互方式

这是一道交互式题目，你不需要使用标准（或文件）输入输出。具体地说，你需要实现下面的函数，这个函数用来帮助 Bessie 有效管理她有限的笔记本空间：

```cpp
void helpBessie(int ID);
```

每当一节列车车厢经过的时候，无论是在早晨和下午，你的函数都会被调用，函数的输入是这节车厢的 ID。 

你的 `helpBessie` 函数的实现可以调用下面这些函数：

- `int get(int index)`：获取记录在 Bessie 的笔记本上的给定的索引处的整数值（_index_）。
- `void set (int index, int value)`：设置给定的索引（_index_）处的值为给定的整数值（_value_）。
- `void shoutMinimum (int output)`：通知 Bessie 向天哞一个指定的数。
- `int getTrainLength()`：返回列车的车厢数 $N$。
- `int getWindowLength()`：返回窗口的长度 $K$。
- `int getCurrentCarIndex()`：返回当前正在通过的车厢编号。
- `int getCurrentPassIndex()`：如果 Bessie 正在观察早晨的列车返回 $0$，下午的列车返回 $1$。

为了帮助你开始编码，我们为你提供了初始的 C/C++ 模板。遗憾地，这道题目不支持 Python 和 Pascal 语言的程序。

```cpp
#include "grader.h"

// If you find it necessary, you may import standard libraries here.

void helpBessie(int ID)
{
	// Put your code here.
}
```

调用 `void shoutMinimum (int output)` 函数进行输出。

各个窗口的最小数必须按顺序输出（所以车厢 $0,1,\cdots ,K−1$ 之中的最小值必须在车厢 $1,2,\cdots ,K$ 之中的最小值之前输出，等等），但是除了这个顺序的限制之外，你的函数可以在任何一次函数调用中任意多次地输出一些最小值。比如，你的函数可能在某几次调用中不产生任何输出，而在某几次调用中产生多个输出。

Bessie 拥有惊人的短时记忆能力，因此在 `helpBessie` 函数中没有任何的内存使用限制，除了要满足常规的 256MB 限制。然而，在车厢与车厢之间，Bessie 不能够「记住」任何不在笔记本中出现过的内容。所以在两次函数调用之间，你的程序除了通过 `get` 和 `set` 函数调用之外不能保存任何的状态。

这意味着：

**不允许定义任何非常量的全局或静态变量。任何如此做的提交会被取消成绩。教练会人工检查所有的提交以验证是否符合题目要求。由于这个问题无需文件输入输出，所以也不允许在代码中使用任何的文件输入输出**。
## 样例

### 样例输入 #1
```
10 3
5 7 9 2 0 1 7 4 3 6
```
### 样例输出 #1
```
5
2
0
0
0
1
3
3
```
## 提示

对于全部数据，$1\le N\le 10^6,0\le c_i\le 10^9,1\le K\le N$，你的程序进行的 `set` 调用和 `get` 调用的总次数被限制为 $25\times 10^6$ 次。

供题：Dhruv Rohatgi


---

---
title: "[BJWC2018] 餐巾计划问题"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P4480
tag: ['2018', '网络流', '北京', '最短路', '队列']
---
# [BJWC2018] 餐巾计划问题
## 题目背景

**本题和网络流24题中的餐巾计划不为重题**
## 题目描述

一个餐厅在相继的 $n$ 天里，每天需用的餐巾数不尽相同。假设第 $i$ 天 $(i=1, 2, ..., n)$ 需要 $r_i$ 块餐巾。餐厅可以在任意时刻购买新的餐巾，每块餐巾的费用为 $p$ 。使用过的旧餐巾，则需要经过清洗才能重新使用。把一块旧餐巾送到清洗店A，需要等待 $m_1$ 天后才能拿到新餐巾，其费用为 $c_1$ ；把一块旧餐巾送到清洗店B，需要等待 $m_2$ 天后才能拿到新餐巾，其费用为 $c_2$ 。例如，将一块第 $k$ 天使用过的餐巾送到清洗店A清洗，则可以在第 $k+m_1$ 天使用。

请为餐厅合理地安排好 $n$ 天中餐巾使用计划，使总的花费最小。
## 输入格式

第一行，包含六个个正整数  $n, m_1, m_2, c_1, c_2, p$ 。

接下来输入 $n$ 行，每行包含一个正整数 $r_i$ 。
## 输出格式

输出一行，包含一个正整数，表示最小的总花费。
## 样例

### 样例输入 #1
```
4 1 2 2 1 3
8
2
1
6
```
### 样例输出 #1
```
35
```
## 提示

**【样例说明】**

第 1 天：买8块餐巾，花费24。送2块餐巾去清洗店A，6块餐巾去清洗店B。

第 2 天：取回2块清洗店A的餐巾，花费4。送1块餐巾去清洗店B。

第 3 天：取回6块清洗店B的餐巾，花费6。

第 4 天：取回1块清洗店B的餐巾，花费1。这样就用了最少的钱。


**【数据规模和约定】**

对于30%的数据，$1 \leq n \leq 5$ ，$1 \leq c_1, c_2, p \leq 5$ ， $1 \leq r_i \leq 5$ 。

对于50%的数据，$1 \leq n \leq 100$ ，$1 \leq r_i \leq 50$ 。

对于70%的数据，$1 \leq n \leq 5000$ 。

对于100%的数据，$1 \leq n \leq 200000$ ， $1 \leq m_1, m_2 \leq n$ ， $1 \leq c_1, c_2, p \leq 100$ ， $1 \leq r_i \leq 100$ 。


---

---
title: "[NOI2019] 序列"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P5470
tag: ['贪心', '2019', 'NOI', 'O2优化', '优先队列', '模拟费用流']
---
# [NOI2019] 序列
## 题目描述

给定两个长度为 $n$ 的正整数序列 $\{a_i\}$ 与 $\{b_i\}$，序列的下标为 $1, 2, \cdots , n$。现在你需要分别对两个序列各指定**恰好** $K$ 个下标，要求**至少**有 $L$ 个下标在两个序列中都被指定，使得这 $2K$ 个下标在序列中对应的元素的总和**最大**。

形式化地说，你需要确定两个长度为 $K$ 的序列 $\{c_i\}, \{d_i\}$，其中
$1 \leq c_1 < c_2 < \cdots < c_K \leq n , 1 \leq d_1 < d_2 < \cdots < d_K \leq n$

并要求 $\{c_1, c_2, \cdots , c_K\} \cap \{d_1, d_2, · · · , d_K\}\geq L$

目标是最大化 $\sum^{K}_{i=1} a_{c_i} +\sum^{K}_{i=1} b_{d_i}$

## 输入格式

**本题输入文件包含多组数据**。

第一行一个正整数 $T$ 表示数据组数。接下来每三行表示一组数据。

每组数据第一行三个整数 $n, K, L$，变量意义见题目描述。

每组数据第二行 $n$ 个整数表示序列 $\{a_i\}$。

每组数据第三行 $n$ 个整数表示序列 $\{b_i\}$。
## 输出格式

对于每组数据输出一行一个整数表示答案。

## 样例

### 样例输入 #1
```
5
1 1 1
7
7
3 2 1
4 1 2
1 4 2
5 2 1
4 5 5 8 4
2 1 7 2 7
6 4 1
1 5 8 3 2 4
2 6 9 3 1 7
7 5 4
1 6 6 6 5 9 1
9 5 3 9 1 4 2
```
### 样例输出 #1
```
14
12
27
45
62

```
## 提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 2

见选手目录下的 `sequence/sequence2.in` 与 `sequence/sequence2.ans`。

#### 样例 3

见选手目录下的 `sequence/sequence3.in` 与 `sequence/sequence3.ans`。

### 样例 1 解释

第一组数据选择的下标为：$\{c_i\} = \{1\} , \{d_i\} = \{1\}$。

第二组数据选择的下标为：$\{c_i\} = \{1, 3\} , \{d_i\} = \{2, 3\}$

第三组数据选择的下标为：$\{c_i\} = \{3, 4\} , \{d_i\} = \{3, 5\}$。

第四组数据选择的下标为：$\{c_i\} = \{2, 3, 4, 6\} , \{d_i\} = \{2, 3, 4, 6\}$。

第五组数据选择的下标为：$\{c_i\} = \{2, 3, 4, 5, 6\} , \{d_i\} = \{1, 2, 3, 4, 6\}$。

### 数据范围

对于所有测试点：$T \leq 10 , 1 \leq \sum n \leq 10^6, 1 \leq L \leq K \leq n \leq 2 \times 10^5, 1 \leq a_i, b_i \leq 10^9$。

| 测试点编号 | $n\le$ | $\sum n \le$ |
| :----------: | :----------: | :----------: |
| $1\sim3$ | $10$ | $3\times 10^5$ |
| $4\sim5$ | $18$ | $3\times 10^5$ |
| $6\sim7$ | $30$ | $3\times 10^5$ |
| $8\sim10$ | $150$ | $3\times 10^5$ |
| $11\sim16$ | $2\times 10^3$ | $3\times 10^5$ |
| $17\sim21$ | $2\times 10^5$ | $3\times 10^5$ |
| $22\sim25$ | $2\times 10^5$ | $10^6$ |


---

---
title: "不可视境界线[环版本]"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P6455
tag: ['动态规划 DP', '计算几何', '二分', '单调队列', 'Special Judge', '分治', '随机调整', '凸完全单调性（wqs 二分）']
---
# 不可视境界线[环版本]
## 题目背景

- 原题 : [P5617 [MtOI2019]不可视境界线](https://www.luogu.com.cn/problem/P5617)

**附** : [关于本题的`SPJ`和数据的一些信息](https://www.luogu.com.cn/paste/tmwvh5vh)

若出现卡精度或数据出锅,吊打标算等情况,请联系出题人。
## 题目描述

有 $n$ 个半径为 $r$ 的圆,画在一个长度为 $L$ 的首尾相接的纸环上。

所有的圆心都在同一高度,可以看做在纸上画一个数轴然后卷起来,圆心的位置用这个数轴上的点描述。

如果无法理解纸环上圆的分布,可以查看样例解释以及子问题。

要求选出 $k$ 个圆,使得所有圆的并面积最大。

注意,您需要回答确切的选取方案而不是仅仅给出最大并面积。
## 输入格式

第一行包含四个整数 $n,k,r,L$ ,意义如题目所述。

第二行包含 $n$ 个整数,第 $i$ 个整数 $p[i]$ 描述了第 $i$ 个圆心在纸环上的位置(数轴上的坐标)。

对于 $2<i<n$ ,有 $p[i-1]<p[i]$。
## 输出格式

一行包含 $k$ 个整数,分别表示您选取的圆的编号,由`SPJ`来计算并面积。

您需要保证这些编号严格递增,并且在 $[1,n]$ 以内,否则被认为不合法而不得分。

与标准答案**相对误差**不超过 $10^{-9}$ ,**且绝对误差**不超过 $0.1$ 则认为正确。

通过估算,答案不会超过 $10^{12}$ 量级。
## 样例

### 样例输入 #1
```
5 3 10 30
0 7 14 21 28 
```
### 样例输出 #1
```
2 3 5 
```
### 样例输入 #2
```
10 3 10 65
0 7 15 24 30 36 41 49 57 63 
```
### 样例输出 #2
```
3 6 9
```
### 样例输入 #3
```
30 10 50 169
0 7 14 21 28 35 42 45 51 55 61 65 68 75 79 83 87 94 97 105 113 118 126 133 140 147 151 156 163 167 
```
### 样例输出 #3
```
3 5 8 11 15 19 21 24 27 30 
```
## 提示

**样例解释** : 

- **样例1** : 最终的并面积约为 $565.871835$。

圆的分布如图所示,其中, $⊙A$ 和 $⊙A2$ 是同一个圆, $⊙B$ 和 $⊙B2$ 是同一个圆。

可以视作向右平移 $L=30$ 个单位长度而得,事实上就相当于在纸环上绕了一圈回到起点。

由于是同一个圆,被红色部分覆盖的面积不能重复计算,最大的并面积即为蓝色部分的面积。

![](https://cdn.luogu.com.cn/upload/image_hosting/g2dk0sqv.png)

- **样例2** : 最终的并面积约为 $942.477796$。

- **样例3** : 最终的并面积约为 $16817.058547$。

**数据范围与约定** :

| 子任务编号 | n | k | 时限 |
| :--: | :--: | :--: | :--: |
| 1 | $10$ | - | $\texttt{1s}$ |
| 2 | $100$ | - | $\texttt{1s}$ |
| 3 | $2000$ | - | $\texttt{1.6s}$ |
| 4 | $3\times 10^4$ | $100$ | $\texttt{2.2s}$ |
| 5 | $1\times 10^5$ | - | $\texttt{3s}$ |

时限在 `std` 耗时的两倍以上。

对于所有的数据, $n\leq 10^5$，$10\leq r\leq 2000$，$0\leq p[i]< L\leq 10^8$，$4r<L$，$3\leq k \leq n$。

表格中均为上界。注意,一些下界限制可能帮助省去了问题的某些边界情况。


---

---
title: "『MdOI R3』Pekka Bridge Spam"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P6750
tag: ['动态规划 DP', '数学', '单调队列', 'O2优化', '前缀和', '二项式定理', '生成函数', '快速数论变换 NTT', '洛谷月赛']
---
# 『MdOI R3』Pekka Bridge Spam
## 题目背景

JohnVictor 比较喜欢玩 Clash Royale。

他喜欢玩一套叫做 Pekka Bridge Spam 的卡组，然而这卡组被削弱了。现在他天梯已经掉了很多分了，不会玩了，只能在竞技场上给他的攻城锤安排地方了。

于是就有了这道题。
## 题目描述

JohnVictor 的皇室竞技场是一个 $2n \times 2m$（$2n$ 行，$2m$ 列）的方格表，他要在上面放 $n\times m$ 个 $1 \times 2$ 的攻城锤，使得任意两个攻城锤不相交。

然而攻城锤里面的野蛮人靠太近会打架，所以他要求任意一个 $2 \times 2$ 的正方形中有两个相邻的格子没有被任何攻城锤占有。

现在已经摆好了 $k$ 个攻城锤了，JohnVictor 想要知道有多少种方法能摆放这些攻城锤，注意，攻城锤两两之间没有区别。

由于这个答案实在是太大了，JohnVictor 只想知道这个答案对素数 $p$ 取模后的余数。**保证取模前的真实答案大于 $0$**。

为了避免玩过皇室的参赛者对题目理解产生问题，这里的攻城锤看做一个 $1 \times 2$ 的多米诺，翻转后也与自身一样。如果还是不理解可以参考样例。

**由于本题数据范围较大，使用 C++ 的选手可以使用以下代码来加快取模速度。**

代码出自 [KATCL](https://github.com/kth-competitive-programming/kactl/blob/master/content/various/FastMod.h) 。

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef unsigned long long ull;
typedef __uint128_t L;
struct FastMod {
    ull b, m;
    FastMod(ull b) : b(b), m(ull((L(1) << 64) / b)) {}
    ull reduce(ull a) {
        ull q = (ull)((L(m) * a) >> 64);
        ull r = a - q * b; // can be proven that 0 <= r < 2*b
        return r >= b ? r - b : r;
    }
};
FastMod F(2);

int main() {
    int M = 1000000007; F = FastMod(M);
    ull x = 10ULL*M+3; 
    cout << x << " " << F.reduce(x) << "\n"; // 10000000073 3
}
```

使用方法：

假设当前程序中需要取模的数为 $p$，那么就在 `main` 函数开头处调用 `F = FastMod(p);`。

计算 $a\bmod p$ 的时候调用
`
F.reduce(a);
`，
返回值就是 $a\bmod p$ 的值。
## 输入格式

第一行为四个整数 $n,m,k,p$。

接下来 $k$ 行，每行四个整数 $x_{1i},y_{1i},x_{2i},y_{2i}(1 \le i \le k)$，代表一块攻城锤的位置。

注意这里 $x,y$ 坐标表示的是在第 $x$ 行第 $y$ 列，并不是横纵坐标。
## 输出格式

一行一个整数，输出答案对 $p$ 取模后的值。
## 样例

### 样例输入 #1
```
1 2 0 19260817
```
### 样例输出 #1
```
9
```
### 样例输入 #2
```
2 2 0 19260817
```
### 样例输出 #2
```
36
```
### 样例输入 #3
```
1 2 1 19260817
1 1 2 1
```
### 样例输出 #3
```
4
```
### 样例输入 #4
```
3 3 1 19260817
1 2 1 1
```
### 样例输出 #4
```
190
```
## 提示

【样例 1 解释】   
$9$ 种情况如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/0s4px806.png)

【样例 2 解释】   
我有一种绝妙的解释方法，可惜这里位置太小，我写不下。

【样例 3 解释】  
上图中第一行的第 $1,2$ 幅和第二行的第 $1,2$ 幅图就是要求的 $4$ 种情况。

更多样例请[到这里](https://www.luogu.com.cn/paste/b2ad2hoy)领取。

【数据范围】

本题采用捆绑测试，共有 $7$ 个子任务。

对于 $100\%$ 的数据，$1 \le n \le 9 \times 10^3$，$1 \le m \le 10^{18}$，$0 \le k \le  10^5$，$|x_{1i}-x_{2i}|+|y_{1i}-y_{2i}|=1$，$1 \le x_{1i},x_{2i} \le 2n$，$1 \le y_{1i},y_{2i} \le 2m$，$10^7\le p \le 10^9 + 9 $，**输入数据保证有解且 $p$ 为素数**。

|子任务编号|$n\leq$|$m\leq$|其他性质|分值|时间限制|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|$3$|$3$||$5$|$1.0s$|
|2|$10$|$10$|$k=0$|$10$|$1.0s$|
|3|$5 \times 10^3$|$5 \times 10^3$||$13$|$2.0s$|
|4|$80$|||$17$|$1.0s$|
|5|$2\times 10^3$||$p=998244353$|$20$|$3.0s$|
|6||||$35$|$3.0s$|
【温馨提示】

为了确保卡掉小常数的错解本题开大了数据范围，请注意常数因子对程序运行效率的影响。


---

---
title: "[CSP-S2020] 贪吃蛇"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P7078
tag: ['贪心', '2020', '堆', '队列', 'CSP-S 提高级']
---
# [CSP-S2020] 贪吃蛇
## 题目描述

草原上有 $n$ 条蛇，编号分别为 $1, 2, \ldots , n$。初始时每条蛇有一个体力值 $a_i$，我们称编号为 $x$ 的蛇实力比编号为 $y$ 的蛇强当且仅当它们当前的体力值满足 $a_x > a_y$，或者 $a_x = a_y$ 且 $x > y$。

接下来这些蛇将进行决斗，决斗将持续若干轮，每一轮实力最强的蛇拥有选择权，可以选择吃或者不吃掉实力最弱的蛇：

1. 如果选择吃，那么实力最强的蛇的体力值将减去实力最弱的蛇的体力值，实力最弱的蛇被吃掉，退出接下来的决斗。之后开始下一轮决斗。
2. 如果选择不吃，决斗立刻结束。

每条蛇希望在自己不被吃的前提下在决斗中尽可能多吃别的蛇（显然，蛇不会选择吃自己）。

现在假设每条蛇都足够聪明，请你求出决斗结束后会剩几条蛇。

本题有多组数据，对于第一组数据，每条蛇体力会全部由输入给出，之后的每一组数据，会相对于上一组的数据，修改一部分蛇的体力作为新的输入。
## 输入格式

第一行一个正整数 $T$，表示数据组数。  
接下来有 $T$ 组数据，对于第一组数据，第一行一个正整数 $n$，第二行 $n$ 个非负整数表示 $a_i$。  
对于第二组到第 $T$ 组数据，每组数据：  
第一行第一个非负整数 $k$ 表示体力修改的蛇的个数。  
第二行 $2k$ 个整数，每两个整数组成一个二元组 $(x,y)$，表示依次将 $a_x$ 的值改为 $y$。一个位置可能被修改多次，以最后一次修改为准。
## 输出格式

输出 $T$ 行，每行一个整数表示最终存活的蛇的条数。
## 样例

### 样例输入 #1
```
2
3
11 14 14
3
1 5 2 6 3 25
```
### 样例输出 #1
```
3
1
```
### 样例输入 #2
```
2
5
13 31 33 39 42
5
1 7 2 10 3 24 4 48 5 50
```
### 样例输出 #2
```
5
3
```
### 样例输入 #3
```
见附件中的 snakes/snakes3.in
```
### 样例输出 #3
```
见附件中的 snakes/snakes3.ans
```
### 样例输入 #4
```
见附件中的 snakes/snakes4.in
```
### 样例输出 #4
```
见附件中的 snakes/snakes4.ans
```
## 提示

**【样例 #1 解释】**

第一组数据，第一轮中 $3$ 号蛇最强，$1$ 号蛇最弱。若 $3$ 号蛇选择吃，那么它将在第二轮被 $2$ 号蛇吃掉。因此 $3$ 号蛇第一轮选择不吃，$3$ 条蛇都将存活。

对于第二组数据，$3$ 条蛇体力变为 $5, 6, 25$。第一轮中 $3$ 号蛇最强，$1$ 号蛇最弱，若它选择吃，那么 $3$ 号蛇体力值变为 $20$，在第二轮中依然是最强蛇并能吃掉 $2$ 号蛇，因此 $3$ 号蛇会选择两轮都吃，最终只有 $1$ 条蛇存活。

**【数据范围】**

对于 $20 \%$ 的数据，$n = 3$。  
对于 $40 \%$ 的数据，$n \le 10$。  
对于 $55 \%$ 的数据，$n \le 2000$。  
对于 $70\%$ 的数据，$n \le 5 \times {10}^4$。  
对于 $100\%$ 的数据：$3 \le n \le {10}^6$，$1 \le T \le 10$，$0 \le k \le {10}^5$，$0 \le a_i, y \le 10^9$。保证每组数据（包括所有修改完成后的）的 $a_i$ 以不降顺序排列。


---

---
title: "「DTOI-4」中位数"
layout: "post"
diff: NOI/NOI+/CTSC
pid: P8978
tag: ['动态规划 DP', '二分', '单调队列', '2023', '洛谷原创', 'O2优化']
---
# 「DTOI-4」中位数
## 题目描述

给定一个长度为 $n$ 的整数序列 $a$，你可以进行以下操作不超过 $k$ 次：

- 选择一个区间 $[l, r]$ 满足 $1 \leq l \leq r \leq n$，并将 $[l, r]$ 中的所有数替换为这个区间的中位数。

你要使得操作后 $a$ 的**最小值最大**。

关于此处中位数的定义：对于一个长度为 $len$ 的序列，其中位数定义为该序列中第 $\lceil \frac{len}{2} \rceil$ 小的数。
## 输入格式

第一行，两个整数 $n, k$；

第二行，$n$ 个整数 $a_1, a_2, \cdots, a_n$。
## 输出格式

一行，表示经过不超过 $k$ 次操作后序列最小值的最大值。
## 样例

### 样例输入 #1
```
10 2
2 8 3 2 5 7 10 4 9 7
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
30 3
1 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0
```
### 样例输出 #2
```
0
```
### 样例输入 #3
```
31 3
1 0 1 0 1 0 0 0 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1 1 0 0 0 0 1
```
### 样例输出 #3
```
1
```
## 提示

| $\textbf{Subtask}$ | $n$ | 分值 |
| :------: | :------: | :------: |
| $1$ | $1 \leq n \leq 10$ | $10 \operatorname{pts}$ |
| $2$ | $1 \leq n \leq 100$ | $10 \operatorname{pts}$ |
| $3$ | $1 \leq n \leq 10^3$ | $10 \operatorname{pts}$ |
| $4$ | $1 \leq n \leq 10^4$ | $20 \operatorname{pts}$ |
| $5$ | $1 \leq n \leq 10^5$ | $20 \operatorname{pts}$ |
| $6$ | 无特殊限制 | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1 \leq n \leq 4 \times 10^5$，$0 \leq k \leq n$，$0 \leq a_i \leq 10^9$。


---


---
title: "[CSP-S 2024] 染色"
layout: "post"
diff: 提高+/省选-
pid: P11233
tag: ['动态规划 DP', '2024', 'O2优化', '动态规划优化', 'CSP-S 提高级']
---
# [CSP-S 2024] 染色
## 题目描述

给定一个长度为 $n$ 的正整数数组 $A$，其中所有数从左至右排成一排。

你需要将 $A$ 中的每个数染成红色或蓝色之一，然后按如下方式计算最终得分：

设 $C$ 为长度为 $n$ 的整数数组，对于 $A$ 中的每个数 $A_i$（$1 \leq i \leq n$）：

- 如果 $A_i$ 左侧没有与其同色的数，则令 $C_i = 0$。
- 否则，记其左侧**与其最靠近的同色数**为 $A_j$，若 $A_i = A_j$，则令 $C_i = A_i$，否则令 $C_i = 0$。

你的最终得分为 $C$ 中所有整数的和，即 $\sum \limits_{i=1}^n C_i$。你需要最大化最终得分，请求出最终得分的最大值。
## 输入格式

**本题有多组测试数据。**

输入的第一行包含一个正整数 $T$，表示数据组数。

接下来包含 $T$ 组数据，每组数据的格式如下：

第一行包含一个正整数 $n$，表示数组长度。

第二行包含 $n$ 个正整数 $A_1, A_2, \dots, A_n$，表示数组 $A$ 中的元素。
## 输出格式

对于每组数据：输出一行包含一个非负整数，表示最终得分的最大可能值。
## 样例

### 样例输入 #1
```
3
3
1 2 1
4
1 2 3 4
8
3 5 2 5 1 2 1 4
```
### 样例输出 #1
```
1
0
8
```
## 提示

**【样例 1 解释】**

对于第一组数据，以下为三种可能的染色方案：

1. 将 $A_1, A_2$ 染成红色，将 $A_3$ 染成蓝色（$\red{1}\red{2}\blue{1}$），其得分计算方式如下：
- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。
- 对于 $A_2$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 \neq A_2$，所以 $C_2 = 0$。
- 对于 $A_3$，由于其左侧没有蓝色的数，所以 $C_3 = 0$。    
该方案最终得分为 $C_1 + C_2 + C_3 = 0$。
2. 将 $A_1, A_2, A_3$ 全部染成红色（$\red{121}$），其得分计算方式如下：
- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。
- 对于 $A_2$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 \neq A_2$，所以 $C_2 = 0$。
- 对于 $A_3$，其左侧与其最靠近的红色数为 $A_2$。由于 $A_2 \neq A_3$，所以 $C_3 = 0$。    
该方案最终得分为 $C_1 + C_2 + C_3 = 0$。
3. 将 $A_1, A_3$ 染成红色，将 $A_2$ 染成蓝色（$\red{1}\blue{2}\red{1}$），其得分计算方式如下：
- 对于 $A_1$，由于其左侧没有红色的数，所以 $C_1 = 0$。
- 对于 $A_2$，由于其左侧没有蓝色的数，所以 $C_2 = 0$。
- 对于 $A_3$，其左侧与其最靠近的红色数为 $A_1$。由于 $A_1 = A_3$，所以 $C_3 = A_3 = 1$。    
该方案最终得分为 $C_1 + C_2 + C_3 = 1$。

可以证明，没有染色方案使得最终得分大于 $1$。

对于第二组数据，可以证明，任何染色方案的最终得分都是 $0$。

对于第三组数据，一种最优的染色方案为将 $A_1, A_2, A_4, A_5, A_7$ 染为红色，将 $A_3, A_6, A_8$ 染为蓝色（$\red{35}\blue{2}\red{51}\blue{2}\red{1}\blue{4}$），其对应 $C = [0, 0, 0, 5, 0, 1, 2, 0]$，最终得分为 $8$。

**【样例 2】**

见选手目录下的 color/color2.in 与 color/color2.ans。

**【数据范围】**

对于所有测试数据，保证：$1\leq T\leq 10$，$2\leq n\leq 2\times 10^5$，$1\leq A_i\leq 10^6$。

| 测试点 | $n$ | $A_i$ |
| :----------: | :----------: | :----------: |
| $1\sim 4$ | $\leq 15$ | $\leq 15$ |
| $5\sim 7$ | $\leq 10^2$ | $\leq 10^2$ |
| $8\sim 10$ | $\leq 2000$ | $\leq 2000$ |
| $11,12$ | $\leq 2\times 10^4$ | $\leq 10^6$ |
| $13\sim 15$ | $\leq 2\times 10^5$ | $\leq 10$ |
| $16\sim 20$ | $\leq 2\times 10^5$ | $\leq 10^6$ |


---

---
title: "[CSP-S2019] Emiya 家今天的饭"
layout: "post"
diff: 提高+/省选-
pid: P5664
tag: ['动态规划 DP', '数学', '2019', '容斥原理', 'CSP-S 提高级']
---
# [CSP-S2019] Emiya 家今天的饭
## 题目描述

Emiya 是个擅长做菜的高中生，他共掌握 $n$ 种**烹饪方法**，且会使用 $m$ 种**主要食材**做菜。为了方便叙述，我们对烹饪方法从 $1 \sim n$ 编号，对主要食材从 $1 \sim m$ 编号。

Emiya 做的每道菜都将使用**恰好一种**烹饪方法与**恰好一种**主要食材。更具体地，Emiya 会做 $a_{i,j}$ 道不同的使用烹饪方法 $i$ 和主要食材 $j$ 的菜（$1 \leq i \leq n$、$1 \leq j \leq m$），这也意味着 Emiya 总共会做 $\sum\limits_{i=1}^{n} \sum\limits_{j=1}^{m} a_{i,j}$ 道不同的菜。

Emiya 今天要准备一桌饭招待 Yazid 和 Rin 这对好朋友，然而三个人对菜的搭配有不同的要求，更具体地，对于一种包含 $k$ 道菜的搭配方案而言：
- Emiya 不会让大家饿肚子，所以将做**至少一道菜**，即 $k \geq 1$
- Rin 希望品尝不同烹饪方法做出的菜，因此她要求每道菜的**烹饪方法互不相同**
- Yazid 不希望品尝太多同一食材做出的菜，因此他要求每种**主要食材**至多在**一半**的菜（即 $\lfloor \frac{k}{2} \rfloor$ 道菜）中被使用

这里的 $\lfloor x \rfloor$ 为下取整函数，表示不超过 $x$ 的最大整数。

这些要求难不倒 Emiya，但他想知道共有多少种不同的符合要求的搭配方案。两种方案不同，当且仅当存在至少一道菜在一种方案中出现，而不在另一种方案中出现。

Emiya 找到了你，请你帮他计算，你只需要告诉他符合所有要求的搭配方案数对质数 $998,244,353$ 取模的结果。
## 输入格式

第 1 行两个用单个空格隔开的整数 $n,m$。

第 2 行至第 $n + 1$ 行，每行 $m$ 个用单个空格隔开的整数，其中第 $i + 1$ 行的 $m$ 个数依次为 $a_{i,1}, a_{i,2}, \cdots, a_{i,m}$。
## 输出格式

仅一行一个整数，表示所求方案数对 $998,244,353$ 取模的结果。
## 样例

### 样例输入 #1
```
2 3 
1 0 1
0 1 1
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
3 3
1 2 3
4 5 0
6 0 0
```
### 样例输出 #2
```
190
```
### 样例输入 #3
```
5 5
1 0 0 1 1
0 1 0 1 0
1 1 1 1 0
1 0 1 0 1
0 1 1 0 1
```
### 样例输出 #3
```
742
```
## 提示

【样例 1 解释】

由于在这个样例中，对于每组 $i, j$，Emiya 都最多只会做一道菜，因此我们直接通过给出烹饪方法、主要食材的编号来描述一道菜。

符合要求的方案包括：
- 做一道用烹饪方法 1、主要食材 1 的菜和一道用烹饪方法 2、主要食材 2 的菜
- 做一道用烹饪方法 1、主要食材 1 的菜和一道用烹饪方法 2、主要食材 3 的菜
- 做一道用烹饪方法 1、主要食材 3 的菜和一道用烹饪方法 2、主要食材 2 的菜

因此输出结果为 $3 \bmod 998,244,353 = 3$。 需要注意的是，所有只包含一道菜的方案都是不符合要求的，因为唯一的主要食材在超过一半的菜中出现，这不满足 Yazid 的要求。

【样例 2 解释】

Emiya 必须至少做 2 道菜。

做 2 道菜的符合要求的方案数为 100。

做 3 道菜的符合要求的方案数为 90。

因此符合要求的方案数为 100 + 90 = 190。

【数据范围】

| 测试点编号 | $n=$ | $m=$ | $a_{i,j}<$ | 测试点编号 | $n=$ |$m=$  |$a_{i,j}<$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $2$ | $2$ | $7$ | $10$ | $2$ | $10^3$ |
| $2$ | $2$ | $3$ | $2$ | $8$ | $10$| $3$ | $10^3$ |
| $3$ | $5$ | $2$ | $2$ | $9\sim 12$ | $40$ | $2$ | $10^3$ |
| $4$ | $5$ | $3$ | $2$ | $13\sim 16$ | $40$ | $3$  | $10^3$ |
| $5$ | $10$ | $2$ | $2$ | $17\sim 21$ | $40$ | $500$ | $10^3$ |
| $6$ | $10$ | $3$ | $2$ | $22\sim 25$ | $100$ | $2\times 10^3$ | $998244353$ |

对于所有测试点，保证 $1 \leq n \leq 100$，$1 \leq m \leq 2000$，$0 \leq a_{i,j} \lt 998,244,353$。


---

---
title: "[CSP-S2019 江西] 多叉堆"
layout: "post"
diff: 提高+/省选-
pid: P5689
tag: ['2019', 'CSP-S 提高级']
---
# [CSP-S2019 江西] 多叉堆
## 题目背景

JXCSP-S T5
## 题目描述

多叉堆是一种树形数据结构，本题中我们只考虑小根堆，它满足除了根以外的结点，每个点的权值都不小于父亲的权值。除了叶结点，每个点有至少一个子结点。

初始时有 $n$ 个结点，编号分别为 $0 \sim n - 1$ ，每个结点都是一棵以自身为根的单点树。接下来按顺序有 $q$ 次操作，每次操作有以下两种：

* `1 x y`：选择不在同一棵树里的结点 $x$ 和 $y$，将 $x$ 所在树的根直接接在 $y$ 所在树的根之下，此时 $x$ 和 $y$ 所在树将合并为同一棵树。

* `2 x`：选择结点 $x$，设 $x$ 当前所在树的结点数为 $size$。你需要计算将 $0 \sim size - 1$ 这 $size$ 个数分别填入 $x$ 所在树的结点中，能够产生多少种不同的多叉堆。两种堆不同当且仅当存在某个结点填入的值不同。由于答案可能很大，你只需要求出答案模 $10^9+7$ 后的结果。
## 输入格式

第一行两个整数 $n, q$，具体含义见题目描述。

接下来 $q$ 行每行可能是下面两种格式之一：

* `1 x' y'`：你需要通过计算 $x=(x'+ans) \bmod n , y=(y'+ans) \bmod n$ 来得到真正的 $x$ 和 $y$，输入保证 $x$ 和 $y$ 所在树不同。

* `2 x'`：你需要通过计算 $x=(x'+ans) \bmod n$ 来得到真正的 $x$。

其中 $ans$ 表示上一次 $2$ 操作的输出结果 ，初始时 $ans=0$。
## 输出格式

对于每次 $2$ 操作输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
5 6
1 1 0
1 2 0
2 1
1 3 1
1 2 0
2 4
```
### 样例输出 #1
```
2
8

```
## 提示

#### 【输入输出样例 1 说明】

第 $1$ 次操作时，将 $1$ 所在树的根 $1$ 接在 $0$ 所在树的根 $0$ 下。 

第 $2$ 次操作时，将 $2$ 所在树的根 $2$ 接在 $0$ 所在树的根 $0$ 下。   

第 $3$ 次操作时，$1$ 所在树如图 $1$，在 $0,1,2$ 中分别填入 $[0,1,2]$ 和 $[0,2,1]$ 可以产生 $2$ 种不同的堆。    

第 $4$ 次操作时 $x=(3+2) \bmod 5=0$，$y=(1+2) \bmod 5=3$，将 $0$ 所在树的根 $0$ 接在 $3$ 所在树的根 $3$ 下。   

第 $5$ 次操作 时，$x=(2+2) \bmod 5=4$，$y=(0+2) \bmod 5=2$，将 $4$ 所在树的根 $4$ 接在 $2$ 所在树的根 $3$ 下。    

第 $6$ 次操作 时，$x=(4+2) \bmod 5=1$，$1$ 所在树如图 $2$，在 $0\sim 4$ 中分别填入 $[1,2,3,0,4]$，$[1,3,2,0,4]$，$[1,2,4,0,3]$，$[1,4,2,0,3]$，$[1,3,4,0,2]$，$[1,4,3,0,2]$，$[2,4,3,0,1]$ 可以产生 $8$ 种不同的堆。

![](https://cdn.luogu.com.cn/upload/image_hosting/mqsr3nri.png)

#### 【数据规模与约定】

对于 $100\%$ 的数据，$0\le x',y' <n \le 3\times 10^5$，$1\le Q\le 3\times 10^5$。

对于不同测试点，我们约定

![](https://cdn.luogu.com.cn/upload/image_hosting/44j0elzy.png)


特殊性质 $1$：存在 $1\le i<n $，前 $i$ 次操作均为 $1$ 操作，之后全是 $2$ 操作。

特殊性质 $2$：对于所有输入 $x$ 和 $y$ 本身即是其所在树的根。

感谢 @Fairicle 提供的数据。 


---

---
title: "[CSP-S2020] 函数调用"
layout: "post"
diff: 提高+/省选-
pid: P7077
tag: ['动态规划 DP', '数学', '2020', '拓扑排序', 'CSP-S 提高级']
---
# [CSP-S2020] 函数调用
## 题目描述

函数是各种编程语言中一项重要的概念，借助函数，我们总可以将复杂的任务分解成一个个相对简单的子任务，直到细化为十分简单的基础操作，从而使代码的组织更加严密、更加有条理。然而，过多的函数调用也会导致额外的开销，影响程序的运行效率。

某数据库应用程序提供了若干函数用以维护数据。已知这些函数的功能可分为三类：

1. 将数据中的指定元素加上一个值；
2. 将数据中的每一个元素乘以一个相同值；
3. **依次**执行若干次函数调用，保证不会出现递归（即不会直接或间接地调用本身）。

在使用该数据库应用时，用户可一次性输入要调用的函数序列（一个函数可能被调用多次），在**依次**执行完序列中的函数后，系统中的数据被加以更新。某一天，小 A 在应用该数据库程序处理数据时遇到了困难：由于频繁而低效的函数调用，系统在执行操作时进入了无响应的状态，他只好强制结束了数据库程序。为了计算出正确数据，小 A 查阅了软件的文档，了解到每个函数的具体功能信息，现在他想请你根据这些信息帮他计算出更新后的数据应该是多少。
## 输入格式

第一行一个正整数 $n$，表示数据的个数。  
第二行 $n$ 个整数，第 $i$ 个整数表示下标为 $i$ 的数据的初始值为 $a_i$。  
第三行一个正整数 $m$，表示数据库应用程序提供的函数个数。函数从 $1 \sim m$ 编号。  
接下来 $m$ 行中，第 $j$（$1 \le j \le m$）行的第一个整数为 $T_j$，表示 $j$ 号函数的类型：

1. 若 $T_j = 1$，接下来两个整数 $P_j, V_j$ 分别表示要执行加法的元素的下标及其增加的值；
2. 若 $T_j = 2$，接下来一个整数 $V_j$ 表示所有元素所乘的值；
3. 若 $T_j = 3$，接下来一个正整数 $C_j$ 表示 $j$ 号函数要调用的函数个数，  
  随后 $C_j$ 个整数 $g^{(j)}_1, g^{(j)}_2, \ldots , g^{(j)}_{C_j}$ 依次表示其所调用的函数的编号。

第 $m + 4$ 行一个正整数 $Q$，表示输入的函数操作序列长度。  
第 $m + 5$ 行 $Q$ 个整数 $f_i$，第 $i$ 个整数表示第 $i$ 个执行的函数的编号。
## 输出格式

一行 $n$ 个用空格隔开的整数，按照下标 $1 \sim n$ 的顺序，分别输出在执行完输入的函数序列后，数据库中每一个元素的值。**答案对** $\boldsymbol{998244353}$ **取模。**
## 样例

### 样例输入 #1
```
3
1 2 3
3
1 1 1
2 2
3 2 1 2
2
2 3

```
### 样例输出 #1
```
6 8 12
```
### 样例输入 #2
```
10
1 2 3 4 5 6 7 8 9 10
8
3 2 2 3
3 2 4 5
3 2 5 8
2 2
3 2 6 7
1 2 5
1 7 6
2 3
3
1 2 3
```
### 样例输出 #2
```
36 282 108 144 180 216 504 288 324 360

```
### 样例输入 #3
```
见附件中的 call/call3.in
```
### 样例输出 #3
```
见附件中的 call/call3.ans
```
## 提示

**【样例 #1 解释】**

$1$ 号函数功能为将 $a_1$ 的值加一。$2$ 号函数功能为所有元素乘 $2$。$3$ 号函数将先调用 $1$ 号函数，再调用 $2$ 号函数。

最终的函数序列先执行 $2$ 号函数，所有元素的值变为 $2, 4, 6$。

再执行 $3$ 号函数时，先调用 $1$ 号函数，所有元素的值变为 $3, 4, 6$。再调用 $2$ 号函数，所有元素的值变为 $6, 8, 12$。

**【数据范围】**

| 测试点编号 | $n, m, Q \le$ | $\sum C_j$ | 其他特殊限制 |
| :----------: | :----------: | :----------: | :----------: |
| $1 \sim 2$ | $1000$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $3 \sim 4$ | $1000$ | $\le 100$ | 无 |
| $5 \sim 6$ | $20000$ | $\le 40000$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |
| $7$ | $20000$ | $= 0$ | 无 |
| $8 \sim 9$ | $20000$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $10 \sim 11$ | $20000$ | $\le 2 \times 10^5$ | 无 |
| $12 \sim 13$ | $10^5$ | $\le 2 \times 10^5$ | 不含第 $2$ 类函数或不含第 $1$ 类函数 |
| $14$ | $10^5$ | $= 0$ | 无 |
| $15 \sim 16$ | $10^5$ | $= m - 1$ | 函数调用关系构成一棵树 |
| $17 \sim 18$ | $10^5$ | $\le 5 \times 10^5$ | 无 |
| $19 \sim 20$ | $10^5$ | $\le 10^6$ | 无 |

对于所有数据：$0 \le a_i \le 10^4$，$T_j \in \{1,2,3\}$，$1 \le P_j \le n$，$0 \le V_j \le 10^4$，$1 \le g^{(j)}_k \le m$，$1 \le f_i \le m$。


---

---
title: "[CSP-S 2021] 括号序列"
layout: "post"
diff: 提高+/省选-
pid: P7914
tag: ['动态规划 DP', '2021', 'O2优化', '区间 DP', 'CSP-S 提高级']
---
# [CSP-S 2021] 括号序列
## 题目描述

小 w 在赛场上遇到了这样一个题：一个长度为 $n$ 且符合规范的括号序列，其有些位置已经确定了，有些位置尚未确定，求这样的括号序列一共有多少个。

身经百战的小 w 当然一眼就秒了这题，不仅如此，他还觉得一场正式比赛出这么简单的模板题也太小儿科了，于是他把这题进行了加强之后顺手扔给了小 c。

具体而言，小 w 定义“超级括号序列”是由字符 `(`、`)`、`*` 组成的字符串，并且对于某个给定的常数 $k$，给出了“符合规范的超级括号序列”的定义如下：

1. `()`、`(S)` 均是符合规范的超级括号序列，其中 `S` 表示任意一个仅由**不超过** $\bm{k}$ **个**字符 `*` 组成的非空字符串（以下两条规则中的 `S` 均为此含义）；
2. 如果字符串 `A` 和 `B` 均为符合规范的超级括号序列，那么字符串 `AB`、`ASB` 均为符合规范的超级括号序列，其中 `AB` 表示把字符串 `A` 和字符串 `B` 拼接在一起形成的字符串；
3. 如果字符串 `A` 为符合规范的超级括号序列，那么字符串 `(A)`、`(SA)`、`(AS)` 均为符合规范的超级括号序列。
4. 所有符合规范的超级括号序列均可通过上述 3 条规则得到。

例如，若 $k = 3$，则字符串 `((**()*(*))*)(***)` 是符合规范的超级括号序列，但字符串 `*()`、`(*()*)`、`((**))*)`、`(****(*))` 均不是。特别地，空字符串也不被视为符合规范的超级括号序列。

现在给出一个长度为 $n$ 的超级括号序列，其中有一些位置的字符已经确定，另外一些位置的字符尚未确定（用 `?` 表示）。小 w 希望能计算出：有多少种将所有尚未确定的字符一一确定的方法，使得得到的字符串是一个符合规范的超级括号序列？

可怜的小 c 并不会做这道题，于是只好请求你来帮忙。
## 输入格式

第一行，两个正整数 $n, k$。

第二行，一个长度为 $n$ 且仅由 `(`、`)`、`*`、`?` 构成的字符串 $S$。
## 输出格式

输出一个非负整数表示答案对 ${10}^9 + 7$ 取模的结果。
## 样例

### 样例输入 #1
```
7 3
(*??*??

```
### 样例输出 #1
```
5

```
### 样例输入 #2
```
10 2
???(*??(?)

```
### 样例输出 #2
```
19

```
### 样例输入 #3
```
见附件中的 bracket/bracket3.in
```
### 样例输出 #3
```
见附件中的 bracket/bracket3.ans
```
### 样例输入 #4
```
见附件中的 bracket/bracket4.in
```
### 样例输出 #4
```
见附件中的 bracket/bracket4.ans
```
## 提示

**【样例解释 #1】**

如下几种方案是符合规范的：

```plain
(**)*()
(**(*))
(*(**))
(*)**()
(*)(**)
```

**【数据范围】**

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 3$ | $15$ | 无 |
| $4 \sim 8$ | $40$ | 无 |
| $9 \sim 13$ | $100$ | 无 |
| $14 \sim 15$ | $500$ | $S$ 串中仅含有字符 `?` |
| $16 \sim 20$ | $500$ | 无 |

对于 $100 \%$ 的数据，$1 \le k \le n \le 500$。


---

---
title: "[CSP-S 2022] 假期计划"
layout: "post"
diff: 提高+/省选-
pid: P8817
tag: ['2022', 'O2优化', '广度优先搜索 BFS', 'CSP-S 提高级']
---
# [CSP-S 2022] 假期计划
## 题目描述

小熊的地图上有 $n$ 个点，其中编号为 $1$ 的是它的家、编号为 $2, 3, \ldots, n$ 的都是景点。部分点对之间有双向直达的公交线路。如果点 $x$ 与 $z_1$、$z_1$ 与 $z_2$、……、$z_{k - 1}$ 与 $z_k$、$z_k$ 与 $y$ 之间均有直达的线路，那么我们称 $x$ 与 $y$ 之间的行程可转车 $k$ 次通达；特别地，如果点 $x$ 与 $y$ 之间有直达的线路，则称可转车 $0$ 次通达。

很快就要放假了，小熊计划从家出发去 $4$ 个**不同**的景点游玩，完成 $5$ 段行程后回家：家 $\to$ 景点 A $\to$ 景点 B $\to$ 景点 C $\to$ 景点 D $\to$ 家且每段行程最多转车 $k$ 次。转车时经过的点没有任何限制，既可以是家、也可以是景点，还可以重复经过相同的点。例如，在景点 A $\to$ 景点 B 的这段行程中，转车时经过的点可以是家、也可以是景点 C，还可以是景点 D $\to$ 家这段行程转车时经过的点。

假设每个景点都有一个分数，请帮小熊规划一个行程，使得小熊访问的四个**不同**景点的分数之和最大。
## 输入格式

第一行包含三个正整数 $n, m, k$，分别表示地图上点的个数、双向直达的点对数量、每段行程最多的转车次数。

第二行包含 $n - 1$ 个正整数，分别表示编号为 $2, 3, \ldots, n$ 的景点的分数。

接下来 $m$ 行，每行包含两个正整数 $x, y$，表示点 $x$ 和 $y$ 之间有道路直接相连，保证 $1 \le x, y \le n$，且没有重边，自环。
## 输出格式

输出一个正整数，表示小熊经过的 $4$ 个不同景点的分数之和的最大值。
## 样例

### 样例输入 #1
```
8 8 1
9 7 1 8 2 3 6
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 1

```
### 样例输出 #1
```
27

```
### 样例输入 #2
```
7 9 0
1 1 1 2 3 4
1 2
2 3
3 4
1 5
1 6
1 7
5 4
6 4
7 4

```
### 样例输出 #2
```
7

```
## 提示

**【样例解释 \#1】**

当计划的行程为 $1 \to 2 \to 3 \to 5 \to 7 \to 1$ 时，$4$ 个景点的分数之和为 $9 + 7 + 8 + 3 = 27$，可以证明其为最大值。

行程 $1 \to 3 \to 5 \to 7 \to 8 \to 1$ 的景点分数之和为 $24$、行程 $1 \to 3 \to 2 \to 8 \to 7 \to 1$ 的景点分数之和为 $25$。它们都符合要求，但分数之和不是最大的。

行程 $1 \to 2 \to 3 \to 5 \to 8 \to 1$ 的景点分数之和为 $30$，但其中 $5 \to 8$ 至少需要转车 $2$ 次，因此不符合最多转车 $k = 1$ 次的要求。

行程 $1 \to 2 \to 3 \to 2 \to 3 \to 1$ 的景点分数之和为 $32$，但游玩的并非 $4$ 个不同的景点，因此也不符合要求。

**【样例 \#3】**

见附件中的 `holiday/holiday3.in` 与 `holiday/holiday3.ans`。

**【数据范围】**

对于所有数据，保证 $5 \le n \le 2500$，$1 \le m \le 10000$，$0 \le k \le 100$，所有景点的分数 $1 \le s_i \le {10}^{18}$。保证至少存在一组符合要求的行程。

| 测试点编号 | $n \le$ | $m \le$ | $k \le$ |
|:-:|:-:|:-:|:-:|
| $1 \sim 3$ | $10$ | $20$ | $0$ |
| $4 \sim 5$ | $10$ | $20$ | $5$ |
| $6 \sim 8$ | $20$ | $50$ | $100$ |
| $9 \sim 11$ | $300$ | $1000$ | $0$ |
| $12 \sim 14$ | $300$ | $1000$ | $100$ |
| $15 \sim 17$ | $2500$ | $10000$ | $0$ |
| $18 \sim 20$ | $2500$ | $10000$ | $100$ |

------------

管理员注：民间数据那个 Subtask 里，有一部分测试点的输入格式有问题，应该是造数据的人在输出完景点分数没换行。还有另一部分不仅没换行而且最后会多输入两个数，请注意。直接将空格和换行都按照分隔符来处理输入，并且忽略多余输入的话是不会有问题的。


---

---
title: "[CSP-S 2023] 消消乐"
layout: "post"
diff: 提高+/省选-
pid: P9753
tag: ['2023', 'O2优化', 'CSP-S 提高级']
---
# [CSP-S 2023] 消消乐
## 题目描述

小 L 现在在玩一个低配版本的消消乐，该版本的游戏是一维的，一次也只能消除两个相邻的元素。

现在，他有一个长度为 $n$ 且仅由小写字母构成的字符串。我们称一个字符串是可消除的，当且仅当可以对这个字符串进行若干次操作，使之成为一个空字符串。

其中每次操作可以从字符串中删除两个相邻的相同字符，操作后剩余字符串会拼接在一起。

小 L 想知道，这个字符串的所有非空连续子串中，有多少个是可消除的。
## 输入格式

输入的第一行包含一个正整数 $n$，表示字符串的长度。

输入的第二行包含一个长度为 $n$ 且仅由小写字母构成的的字符串，表示题目中询问的字符串。
## 输出格式

输出一行包含一个整数，表示题目询问的答案。
## 样例

### 样例输入 #1
```
8
accabccb

```
### 样例输出 #1
```
5
```
## 提示

**【样例 1 解释】**

一共有 $5$ 个可消除的连续子串，分别是 `cc`、`acca`、`cc`、`bccb`、`accabccb`。

**【样例 2】**

见选手目录下的 `game/game2.in` 与 `game/game2.ans`。

**【样例 3】**

见选手目录下的 `game/game3.in` 与 `game/game3.ans`。

**【样例 4】**

见选手目录下的 `game/game4.in` 与 `game/game4.ans`。

**【数据范围】**

对于所有测试数据有：$1 \le n \le 2 \times 10^6$，且询问的字符串仅由小写字母构成。

| 测试点 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 5$ | $10$ | 无 |
| $6\sim 7$ | $800$ | 无 |
| $8\sim 10$ | $8000$ | 无 |
| $11\sim 12$ | $2\times 10^5$ | A |
| $13\sim 14$ | $2\times 10^5$ | B |
| $15\sim 17$ | $2\times 10^5$ | 无 |
| $18\sim 20$ | $2\times 10^6$ | 无 |

特殊性质 A：字符串中的每个字符独立等概率地从字符集中选择。

特殊性质 B：字符串仅由 `a` 和 `b` 构成。


---

---
title: "[CSP-S 2023] 结构体"
layout: "post"
diff: 提高+/省选-
pid: P9754
tag: ['2023', 'O2优化', 'CSP-S 提高级']
---
# [CSP-S 2023] 结构体
## 题目背景

在 C++ 等高级语言中，除了 int 和 float 等基本类型外，通常还可以自定义结构体类型。在本题当中，你需要模拟一种类似 C++ 的高级语言的结构体定义方式，并计算出相应的内存占用等信息。
## 题目描述

在这种语言中，基本类型共有 $4$ 种：`byte`、`short`、`int`、`long`，分别占据 $1$、$2$、$4$、$8$ 字节的空间。

定义一个结构体**类型**时，需要给出**类型名**和**成员**，其中每个成员需要按顺序给出**类型**和**名称**。类型可以为基本类型，也可以为**先前定义过**的结构体类型。注意，定义结构体**类型**时不会定义具体元素，即不占用内存。

定义一个**元素**时，需要给出元素的**类型**和**名称**。元素将按照以下规则占据内存：

- 元素内的所有成员将按照**定义时给出的顺序**在内存中排布，对于类型为结构体的成员同理。
- 为了保证内存访问的效率，元素的地址占用需要满足**对齐规则**，即任何类型的**大小**和该类型元素在内存中的**起始地址**均应对齐到该类型对齐要求的**整数倍**。具体而言：
  - 对于基本类型：对齐要求等于其占据空间大小，如 `int` 类型需要对齐到 $4$ 字节，其余同理。
  - 对于结构体类型：对齐要求等于其成员的对齐要求的**最大值**，如一个含有 `int` 和 `short` 的结构体类型需要对齐到 $4$ 字节。

以下是一个例子（以 C++ 语言的格式书写）：

```cpp
struct d {
    short a;
    int b;
    short c;
};
d e;
```

该代码定义了结构体类型 `d` 与元素 `e`。元素 `e` 包含三个成员 `e.a`、`e.b`、`e.c`，分别占据第 $0 \sim 1$、$4 \sim 7$、$8 \sim 9$ 字节的地址。由于类型 `d` 需要对齐到 $4$ 字节，因此 `e` 占据了第 $0 \sim 11$ 字节的地址，大小为 $12$ 字节。

你需要处理 $n$ 次操作，每次操作为以下四种之一：

1. 定义一个结构体类型。具体而言，给定正整数 $k$ 与字符串 $s, t_1, n_1, \dots, t_k, n_k$，其中 $k$ 表示该类型的成员数量，$s$ 表示该类型的类型名，$t_1, t_2, \dots, t_k$ 按顺序分别表示每个成员的类型，$n_1, n_2, \dots, n_k$ 按顺序分别表示每个成员的名称。你需要输出该结构体类型的大小和对齐要求，用一个空格分隔。

2. 定义一个元素，具体而言，给定字符串 $t, n$ 分别表示该元素的类型与名称。所有被定义的元素将按顺序，从内存地址为 $0$ 开始依次排开，并需要满足地址对齐规则。你需要输出新定义的元素的起始地址。

3. 访问某个元素。具体而言，给定字符串 $s$，表示所访问的元素。与 C++ 等语言相同，采用 `.` 来访问结构体类型的成员。如 `a.b.c`，表示 `a` 是一个已定义的元素，它是一个结构体类型，有一个名称为 `b` 的成员，它也是一个结构体类型，有一个名称为 `c` 的成员。你需要输出如上被访问的**最内层**元素的起始地址。

4. 访问某个内存地址。具体而言，给定非负整数 $addr$，表示所访问的地址，你需要判断是否存在一个**基本类型**的元素占据了该地址。若是，则按操作 3 中的访问元素格式输出该元素；否则输出 `ERR`。
## 输入格式

第 $1$ 行：一个正整数 $n$，表示操作的数量。

接下来若干行，依次描述每个操作，每行第一个正整数 $op$ 表示操作类型：

- 若 $op = 1$，首先输入一个字符串 $s$ 与一个正整数 $k$，表示类型名与成员数量，接下来 $k$ 行每行输入两个字符串 $t_i, n_i$，依次表示每个成员的类型与名称。

- 若 $op = 2$，输入两个字符串 $t, n$，表示该元素的类型与名称。

- 若 $op = 3$，输入一个字符串 $s$，表示所访问的元素。

- 若 $op = 4$，输入一个非负整数 $addr$，表示所访问的地址。
## 输出格式

输出 $n$ 行，依次表示每个操作的输出结果，输出要求如题目描述中所述。
## 样例

### 样例输入 #1
```
5
1 a 2
short aa
int ab
1 b 2
a ba
long bb
2 b x
3 x.ba.ab
4 10
```
### 样例输出 #1
```
8 4
16 8
0
4
x.bb
```
## 提示

#### 【样例 1 解释】

结构体类型 `a` 中，`short` 类型的成员 `aa` 占据第 $0 \sim 1$ 字节地址，`int` 类型的成员 `ab` 占据第 $4 \sim 7$ 字节地址。又由于其对齐要求为 $4$ 字节，可得其大小为 $8$ 字节。由此可同理计算出结构体类型 `b` 的大小为 $16$ 字节，对齐要求为 $8$ 字节。

#### 【样例 2】

见选手目录下的 struct/struct2.in 与 struct/struct2.ans。

#### 【样例 2 解释】
第二个操作 4 中，访问的内存地址恰好在为了地址对齐而留下的 “洞” 里，因此没有基本类型元素占据它。

#### 【样例 3】
见选手目录下的 struct/struct3.in 与 struct/struct3.ans。

#### 【数据范围】
对于全部数据，满足 $1 \le n \le 100$，$1 \le k \le 100$，$0 \le addr \le 10^{18}$。

所有定义的结构体类型名、成员名称和定义的元素名称均由不超过 $10$ 个字符的小写字母组成，且都不是 `byte,short,int,long`（即不与基本类型重名）。

所有定义的结构体类型名和元素名称互不相同，同一结构体内成员名称互不相同。但不同的结构体可能有相同的成员名称，某结构体内的成员名称也可能与定义的结构体或元素名称相同。

保证所有操作均符合题目所述的规范和要求，即结构体的定义不会包含不存在的类型、不会访问不存在的元素或成员等。

保证任意结构体大小及定义的元素占据的最高内存地址均不超过 $10^{18}$。

| 测试点 | 特殊性质 |
| :----------: | :----------: |
| $1$ | A、D |
| $2\sim 3$ | A |
| $4\sim 5$ | B、D |
| $6\sim 8$  | B |
| $9\sim 10$ | C、D|
| $11\sim 13$ | C|
| $14\sim 16$ |D|
|$17\sim 20$| 无|

特殊性质 A：没有操作 $1$；

特殊性质 B：只有一个操作 $1$；

特殊性质 C：所有操作 $1$ 中给出的成员类型均为基本类型；

特殊性质 D：基本类型只有 `long`。

#### 【提示】

对于结构体类型的对齐要求和大小，形式化的定义方式如下：

- 设该结构体内有 $k$ 个成员，其大小分别为 $s_1,...,s_k$，对齐要求分别为 $a_1,...,a_k$;
- 则该结构体的对齐要求为 $a=\max\{a_1,...,a_k\}$；
- 再设这些成员排布时的**地址偏移量**分别为 $o_1,...,o_k$，则：
  - $o_1 = 0$;
  - 对于 $i=2,...,k$，$o_i$ 为满足 $o_{i-1}+s_{i-1}\le o_i$ 且 $a_i$ 整除 $o_i$ 的最小值；
  - 则该结构体的大小 $s$ 为满足 $o_k+s_k\le s$ 且 $a$ 整除 $s$ 的最小值；

对于定义元素时的内存排布，形式化的定义方式如下：

- 设第 $i$ 个被定义的元素大小为 $s_i$，对齐要求为 $a_i$，起始地址为 $b_i$;
- 则 $b_1 = 0$，对于 $2\le i$， $b_i$ 为满足 $b_{i-1} + s_{i-1}\le b_i$ 且 $a_i$ 整除 $b_i$ 的最小值。



---

---
title: "[CSP-S 2023] 种树"
layout: "post"
diff: 提高+/省选-
pid: P9755
tag: ['2023', 'O2优化', 'CSP-S 提高级']
---
# [CSP-S 2023] 种树
## 题目描述

你是一个森林养护员，有一天，你接到了一个任务：在一片森林内的地块上种树，并养护至树木长到指定的高度。

森林的地图有 $n$ 片地块，其中 $1$ 号地块连接森林的入口。共有 $n-1$ 条道路连接这些地块，使得每片地块都能通过道路互相到达。最开始，每片地块上都没有树木。

你的目标是：在每片地块上均种植一棵树木，并使得 $i$ 号地块上的树的高度生长到不低于 $a_i$ 米。

你每天可以选择一个未种树且**与某个已种树的地块直接邻接**（**即通过单条道路相连**）的地块，种一棵高度为 $0$ 米的树。如果所有地块均已种过树，则你当天不进行任何操作。特别地，第 $1$ 天你只能在 $1$ 号空地种树。

对每个地块而言，从该地块被种下树的当天开始，该地块上的树每天都会生长一定的高度。由于气候和土壤条件不同，在第 $x$ 天，$i$ 号地块上的树会长高 $\max(b_i + x \times c_i, 1)$ 米。注意这里的 $x$ 是从整个任务的第一天，而非种下这棵树的第一天开始计算。

你想知道：最少需要多少天能够完成你的任务？
## 输入格式

输入的第一行包含一个正整数 $n$，表示森林的地块数量。

接下来 $n$ 行：每行包含三个整数 $a_i, b_i, c_i$，分别描述一片地块，含义如题目描述中所述。

接下来 $n-1$ 行：每行包含两个正整数 $u_i, v_i$，表示一条连接地块 $u_i$ 和 $v_i$ 的道路。
## 输出格式

输出一行仅包含一个正整数，表示完成任务所需的最少天数。
## 样例

### 样例输入 #1
```
4
12 1 1
2 4 -1
10 3 0
7 10 -2
1 2
1 3
3 4
```
### 样例输出 #1
```
5

```
## 提示

**【样例 1 解释】**

第 $1$ 天：在地块 $1$ 种树，地块 $1$ 的树木长高至 $2$ 米。

第 $2$ 天：在地块 $3$ 种树，地块 $1, 3$ 的树木分别长高至 $5, 3$ 米。

第 $3$ 天：在地块 $4$ 种树，地块 $1, 3, 4$ 的树木分别长高至 $9, 6, 4$ 米。

第 $4$ 天：在地块 $2$ 种树，地块 $1, 2, 3, 4$ 的树木分别长高至 $14, 1, 9, 6$ 米。

第 $5$ 天：地块 $1, 2, 3, 4$ 的树木分别长高至 $20, 2, 12, 7$ 米。

**【样例 2】**

见选手目录下的 `tree/tree2.in` 与 `tree/tree2.ans`。

**【样例 3】**

见选手目录下的 `tree/tree3.in` 与 `tree/tree3.ans`。

**【样例 4】**

见选手目录下的 `tree/tree4.in` 与 `tree/tree4.ans`。

**【数据范围】**

对于所有测试数据有：$1 ≤ n ≤ 10^5,1 ≤ a_i ≤ 10^{18}, 1 ≤ b_i ≤ 10^9,0 ≤ |c_i| ≤ 10^9, 1 ≤ u_i, v_i ≤ n$。保证存在方案能在 $10^9$ 天内完成任务。

![T4](https://cdn.luogu.com.cn/upload/image_hosting/aqqd4l0y.png?x-oss-process=image/resize,m_lfit,h_400,w_300)

特殊性质 A：对于所有 $1 ≤ i ≤ n$，均有 $c_i = 0$；

特殊性质 B：对于所有 $1 ≤ i < n$，均有 $u_i = i$、$v_i = i + 1$；

特殊性质 C：与任何地块直接相连的道路均不超过 $2$ 条；

特殊性质 D：对于所有 $1 ≤ i < n$，均有 $u_i = 1$。


---


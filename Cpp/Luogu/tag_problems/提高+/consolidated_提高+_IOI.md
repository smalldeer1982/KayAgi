---
title: "[IOI 2024] 尼罗河船运"
layout: "post"
diff: 提高+/省选-
pid: P11049
tag: ['2024', 'IOI', '交互题']
---
# [IOI 2024] 尼罗河船运
## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。但请勿使用 C++14 (GCC 9)
## 题目描述

你想通过尼罗河来运输 $N$ 件手工艺品。这些手工艺品从 $0$ 到 $N-1$ 编号。第 $i$（$0 \leq i < N$）件手工艺品的重量是 $W[i]$。



为了运输这些手工艺品，你使用了特制的船。每艘船**最多**可以运**两件**手工艺品。


* 如果你决定将单件手工艺品放在一艘船上，那么这件手工艺品的重量可以是任意的。
* 如果你想把两件手工艺品一起放在同一艘船上，你必须保证这艘船的平衡。具体来说，如果手工艺品 $p$ 和 $q$（$0 \leq p < q < N$）的重量差的绝对值不超过 $D$，即满足 $|W[p] - W[q]| \leq D$，那么你可以将它们一起放在同一艘船上。



你必须付费来运一件手工艺品，其运费取决于同一艘船上所运载的手工艺品数量。手工艺品 $i$（$0 \leq i < N$）的运费是：

* $A[i]$，如果你把手工艺品 $i$ 单独放在船上，或者
* $B[i]$，如果你把手工艺品 $i$ 和另一件手工艺品一起放在船上。


注意在第二种情况中，你要为船上两件手工艺品都支付运费。具体来说，如果你决定用同一艘船运输手工艺品 $p$ 和 $q$（$0 \leq p < q < N$），你需要支付 $B[p] + B[q]$。



一件手工艺品单独用一艘船运输的费用，总是比与其他手工艺品合用一艘船时的费用要高，所以对任意满足 $0 \leq i < N$ 的 $i$，都有 $B[i] < A[i]$。


麻烦的是，由于尼罗河变化莫测，导致 $D$ 的值经常改变。你的任务是回答 $Q$ 个问题，从 $0$ 到 $Q-1$ 编号。这些问题用一个长度为 $Q$ 的数组 $E$ 来描述。问题 $j$（$0 \leq j < Q$）的答案，是在 $D$ 的值等于 $E[j]$ 时运输所有 $N$ 件手工艺品的最小总代价。
## 输入格式

评测程序按如下顺序读取输入数据：

```plain
N
W[0] A[0] B[0]
W[1] A[1] B[1]
...
W[N-1] A[N-1] B[N-1]
Q
E[0]
E[1]
...
E[Q-1]
```
## 输出格式

评测程序按如下顺序输出：



```plain
R[0]
R[1]
...
R[S-1]
```

这里，$S$ 是 `calculate_costs` 所返回的数组 $R$ 的长度。
## 样例

### 样例输入 #1
```
5
15 5 1
12 4 2
2 5 2
10 6 3
21 3 2
3
5
9
1

```
### 样例输出 #1
```
16
11
23

```
## 提示

## 实现细节


你需要实现以下函数。

```
std::vector<long long> calculate_costs(
    std::vector<int> W, std::vector<int> A, 
    std::vector<int> B, std::vector<int> E)
```

* $W$，$A$，$B$：长度均为 $N$ 的整数数组，分别给出手工艺品的重量和运费。
* $E$：长度为 $Q$ 的整数数组，给出每个问题中的 $D$ 值。
* 该函数应该返回一个包含 $Q$ 个整数的数组 $R$，给出运输手工艺品的最小总代价，其中 $R[j]$ 对应 $D$ 等于 $E[j]$（对每个满足 $0 \leq j < Q$ 的 $j$）时的运费。
* 对于每个测试用例，该函数恰好被调用一次。


## 约束条件

* $1 \leq N \leq 100\,000$。
* $1 \leq Q \leq 100\,000$。
* 对每个满足 $0 \leq i < N$ 的 $i$，都有 $1 \leq W[i] \leq 10^{9}$。
* 对每个满足 $0 \leq i < N$ 的 $i$，都有 $1 \leq B[i] < A[i] \leq 10^{9}$。
* 对每个满足 $0 \leq j < Q$ 的 $j$，都有 $1 \leq E[j] \leq 10^{9}$。


## 子任务

| 子任务 | 分数 | 额外的约束条件                                               |
| :----: | :--: | ------------------------------------------------------------ |
|   1    | $6$  | $Q \leq 5$；$N \leq 2000$；对每个满足 $0 \leq i < N$ 的 $i$，都有 $W[i] = 1$ |
|   2    | $13$ | $Q \leq 5$；对每个满足  $0 \leq i < N$ 的 $i$，都有 $W[i] = i+1$ |
|   3    | $17$ | $Q \leq 5$；对每个满足  $0 \leq i < N$ 的 $i$，都有 $A[i] = 2$ 且 $B[i] = 1$ |
|   4    | $11$ | $Q \leq 5$；$N \leq 2000$                                    |
|   5    | $20$ | $Q \leq 5$                                                   |
|   6    | $15$ | 对每个满足 $0 \leq i < N$ 的 $i$，都有 $A[i] = 2$ 且 $B[i] = 1$ |
|   7    | $18$ | 没有额外的约束条件。                                         |


## 例子


考虑以下调用。

```
calculate_costs([15, 12, 2, 10, 21],
                [5, 4, 5, 6, 3],
                [1, 2, 2, 3, 2],
                [5, 9, 1])
```


在该例子中，我们有 $N=5$ 件手工艺品和 $Q=3$ 个问题。



在第一个问题中，$D = 5$。你可以把手工艺品 $0$ 和手工艺品 $3$ 放在同一艘船上（因为 $|15 - 10| \leq 5$），而其他手工艺品都各自放在不同的船上。这使得运输所有手工艺品的总代价最小，即 $1+4+5+3+3 = 16$。


在第二个问题中，$D = 9$。你可以把手工艺品 $0$ 和手工艺品 $1$ 放在同一艘船上（因为 $|15 - 12| \leq 9$），而把手工艺品 $2$ 和手工艺品 $3$ 放在同一艘船上（因为 $|2 - 10| \leq 9$）。剩下的手工艺品单独用一艘船运输。这使得运输所有手工艺品的总代价最小，即 $1+2+2+3+3 = 11$。


在最后一个问题中，$D = 1$。你需要把每件手工艺品都单独用一艘船运输。这使得运输所有手工艺品的总代价最小，即 $5+4+5+6+3 = 23$。

因此，该函数应该返回 $[16, 11, 23]$。


---

---
title: "[IOI 2018] combo 组合动作"
layout: "post"
diff: 提高+/省选-
pid: P13612
tag: ['2018', 'IOI', '交互题', 'Special Judge']
---
# [IOI 2018] combo 组合动作
## 题目描述

你在玩一个动作游戏。游戏控制器有 $4$ 个按键，`A`、`B`、`X` 和 `Y`。在游戏中，你用组合动作来赚金币。你可以依次按这些按键来完成一个组合动作。
这个游戏有一个隐藏的按键序列，可以表示为由这 $4$ 个字符组成的串 $S$。你并不知道这个串 $S$，但是你知道它的长度为 $N$。

**你还知道，$S$ 的首字符不会在串中重复出现**。例如，$S$ 可以是“`ABXYY`”或者“`XYYAA`”，但不能是“`AAAAA`”或“`BXYBX`”。

你可以依次按最多 $4N$ 个按键来完成一个组合动作。串 $p$ 为你所按的按键序列。你用这个组合动作赚到的金币数量，等于同时为 $p$ 之子串和 $S$ 之前缀的最长字符串的长度。串 $t$ 的子串定义为 $t$ 中的连续字符序列（可以为空）。$t$ 的前缀定义为 $t$ 的子串，其或者为空，或者包含 $t$ 的首字符。

例如，如果 $S$ 是“`ABXYY`”，而 $p$ 是“`XXYYABYABXAY`”，你会得到 $3$ 个金币，因为“`ABX`”是可作为 $p$ 的子串的 $S$ 的前缀中最长的。

你的任务是，用少量的组合动作，找出隐藏字符串 $S$。

### 实现细节

~~你的程序需要引入头文件 `combo.h`。~~

你无需引入头文件 `combo.h`。但是，你需要在你的程序开头加上：

```cpp
int press(string p)
```

此外，建议以 C++20 或者 C++23 提交本题（而非 C++14/GCC9）。

你需要实现下面的函数：

```cpp
string guess_sequence(int N)
```

* `N`：串 $S$ 的长度。
* 对每个测试用例，该函数被调用恰好一次。
* 该函数应返回串 $S$。

你的程序可以调用下面的函数：

```cpp
int press(string p)
```

* `p`：你的按键序列。
* `p` 必须是长度为从 $0$ 到 $4N$ 的串（包括 $0$ 和 $4N$）。`p` 的每个字符必须是 `A`、`B`、`X` 或者 `Y`。
* 对每个测试用例，你调用该函数的次数不能超过 $8\ 000$ 次。
* 该函数的返回结果是，当按出按键序列 `p` 后你赚到的金币数量。

如果不满足上面的条件，你的程序将被判为 `Wrong Answer`。否则，你的程序将被判为 `Accepted`，而你的得分将根据 `press` 的调用次数来计算（参见子任务）。
## 输入格式

评测程序示例将读取如下格式的输入：

* 第 $1$ 行：$S$

如果你的程序被判为 `Accepted`，评测系统示例将打印出 `Accepted:  q`，这里 `q` 为函数 `press` 的调用次数。

如果你的程序被判为 `Wrong Answer`，它打印出 `Wrong Answer: MSG`。各类 `MSG` 的含义如下：

* `invalid press`：输入到 `press` 的值 `p` 是无效的。也就是说，`p` 的长度不在 $0$ 到 $4N$ 之间（含 $0$ 和 $4N$），或者 `p` 的某些字符不是 `A`、`B`、`X` 和 `Y`。
* `too many moves`：函数 `press` 的调用次数超过 $8\ 000$ 次。
* `wrong guess`：`guess_sequence` 返回的不是 $S$。
## 提示

### 限制条件

* $1\le N\le 2\ 000$
* 串 $S$ 的每个字符必须是 `A`、`B`、`X` 或 `Y`。
* $S$ 的首字符不会再 $S$ 中重复出现。

在本题中，评测程序**不是**适应性的。意思是说，在评测程序开始运行的时候 $S$ 就固定下来，而且不依赖于你的程序所做的询问。

### 子任务

1. （5分）$N=3$
2. （95分）没有附加限制。对该子任务，你在每个测试用例上的得分将计算如下。设 $q$ 为调用 `press` 的次数。
   * 如果 $q\le N+2$，你的得分为 $95$。
   * 如果 $N+2<q\le N+10$，你的得分为 $95-3(q-N-2)$。
   * 如果 $N+10<q\le 2N+1$，你的得分为 $25$。
   * 如果 $\max\{N+10,2N+1\}<q\le 4N$，你的得分为 $5$。
   * 否则，你的得分为 $0$。

注意，你在每个子任务上的得分，等于你在该子任务下所有测试用例上的最低得分。


---

---
title: "[USACO5.4] 周游加拿大Canada Tour"
layout: "post"
diff: 提高+/省选-
pid: P2747
tag: ['字符串', '动态规划 DP', '搜索', '2001', 'USACO', 'IOI']
---
# [USACO5.4] 周游加拿大Canada Tour
## 题目描述

你赢得了一场航空公司举办的比赛，奖品是一张加拿大环游机票。旅行在这家航空公司开放的最西边的城市开始，然后一直自西向东旅行，直到你到达最东边的城市，再由东向西返回，直到你回到开始的城市。除了旅行开始的城市之外，每个城市只能访问一次，因为开始的城市必定要被访问两次（在旅行的开始和结束）。

当然不允许使用其他公司的航线或者用其他的交通工具。

给出这个航空公司开放的城市的列表，和两两城市之间的直达航线列表。找出能够访问尽可能多的城市的路线，这条路线必须满足上述条件，也就是从列表中的第一个城市开始旅行，访问到列表中最后一个城市之后再返回第一个城市。

## 输入格式

第 $1$ 行: 航空公司开放的城市数 $N$ 和将要列出的直达航线的数量 $V$。$N$ 是一个不大于 $100$ 的正整数。$V$ 是任意的正整数。

第 $2\sim N+1$ 行: 每行包括一个航空公司开放的城市名称。城市名称按照自西向东排列。不会出现两个城市在同一条经线上的情况。每个城市的名称都 是一个字符串，最多 $15$ 字节，由拉丁字母表上的字母组成；城市名称中没有空格。

第 $N+2\sim N+2+V-1$ 行: 每行包括两个城市名称（由上面列表中的城市名称组成），用一个空格分开。这样就表示两个城市之间的直达双程航线。
## 输出格式

Line 1: 按照最佳路线访问的不同城市的数量 M。如果无法找到路线，输出 1。

## 样例

### 样例输入 #1
```
8 9
Vancouver
Yellowknife
Edmonton
Calgary
Winnipeg
Toronto
Montreal
Halifax
Vancouver Edmonton
Vancouver Calgary
Calgary Winnipeg
Winnipeg Toronto
Toronto Halifax
Montreal Halifax
Edmonton Montreal
Edmonton Yellowknife
Edmonton Calgary
```
### 样例输出 #1
```
7
```
## 提示

题目翻译来自NOCOW。

USACO Training Section 5.4



---

---
title: "[IOI 2017] Wiring"
layout: "post"
diff: 提高+/省选-
pid: P3837
tag: ['2017', 'IOI', '交互题']
---
# [IOI 2017] Wiring
## 题目背景

这是一道交互题。

本题仅支持 C++ 系列语言，提交时不需要包含 `wiring.h` 头文件，但需要在程序开头包含 `vector` 头文件以及声明函数 `long long min_total_length(std::vector<int> r, std::vector<int> b)`。

**由于不可名状的 BUG，使用 C++14 (GCC9) 提交会导致 CE，请不要使用其提交。**
## 题目描述

Maryam 是一位电机工程师。她正在为一座通讯塔设计接线方案。在这个塔上有一些分布在不同高度的连接点。一条电线可以用来将任何两个连接点连接起来。每一个连接点都可以接上任意数目的电线。而连接点共有两种：分别为红色连接点及蓝色连接点。

为了表述方便起见，通讯塔会被视为一条直线，而那些红色及蓝色连接点会被视为在这条直线上的一些非负整数坐标。一条电线的长度是该电线所连接的两个连接点间的距离。

你要做的是帮 Maryam 找出一个接线的方案，使得满足以下条件：

1. 每个连接点上最少有一条电线连接到一个不同颜色的连接点上

2. 所用的电线的总长为最短。


## 实现细节

你需要实现以下的子程序：

`long long min_total_length(std::vector<int> r, std::vector<int> b)`

- $r$：一个长度为 $n$ 的数组，其内以升序排列着所有红色连接点的位置。

- $b$：一个长度为 $m$ 的数组，其内以升序排列着所有蓝色连接点的位置。

- 这个子程序需返回在所有可能的连接方案中，最短电线总长度的那个方案的电线作为其返回值。

- 请注意这个子程序的返回值的类型为 `long long` 。

## 输入格式

你需要实现上面所述的子程序。

## 输出格式

返回一个 `long long` 值。

## 样例

### 样例输入 #1
```
r = [1, 2, 3, 7]
b = [0, 4, 5, 9, 10]
```
### 样例输出 #1
```
10
```
## 提示

样例中函数传递参数：

`min_total_length([1, 2, 3, 7], [0, 4, 5, 9, 10])`

以下的图表表述了样例中的数据。

 ![](https://cdn.luogu.com.cn/upload/pic/6724.png) 

- 图中以水平的方式表示出相关的通讯塔。

- 因题目打印是黑白色的，所以红色接点以较深色来表示，而蓝色接点则以较浅色来表示。

- 图中有 $4$ 个红色的连接点，其位置分别为 $1,2,3$ 及 $7$ 。

- 图中有 $5$ 个蓝色的连接点，其位置分别为 $0,4,5,9$ 及 $10$ 。

- 该例的最优解的电线总长度为 $1+2+2+2+3=10$ ，所以子程序的返回值为 $10$ 。

- 请注意共有两条电线连接在位置为 $7$ 的连接点上。


## 限制条件

- $1 \leqslant n,m \leqslant 100000$

- $0 \leqslant r[i] \leqslant 10^9 $（对于所有$0 \leqslant i \leqslant n-1$）

- $0 \leqslant b[i] \leqslant 10^9$（对于所有$0 \leqslant i \leqslant m-1$）

- 数组$r$及数组$b$都已经按升序排好序。

- 在数组$r$及$b$内的所有$n+m$个值均是不同的。


## 子任务

1. ($7$ 分)  $n,m\leqslant 200$。

2. ($13$ 分)  所有红色接点的位置坐标小于任何蓝色接点的坐标。

3. ($10$ 分)  在每$7$个连续的（接续）的连接点内必有最少一个红色接点及蓝色接点。

4. ($25$ 分)  所有接点在$[1,n+m]$范围内有不同的位置坐标。

5. ($45$ 分)  没有任何附加的限制。



---

---
title: "[IOI 2008] Island"
layout: "post"
diff: 提高+/省选-
pid: P4381
tag: ['动态规划 DP', '2008', 'IOI', 'O2优化', '树的直径', '栈', '队列', '基环树']
---
# [IOI 2008] Island
## 题目描述

你准备浏览一个公园，该公园由 $N$ 个岛屿组成，当地管理部门从每个岛屿 $i$ 出发向另外一个岛屿建了一座长度为 $L_i$ 的桥，不过桥是可以双向行走的。同时，每对岛屿之间都有一艘专用的往来两岛之间的渡船。相对于乘船而言，你更喜欢步行。你希望经过的桥的总长度尽可能长，但受到以下的限制：

- 可以自行挑选一个岛开始游览。
- 任何一个岛都不能游览一次以上。
- 无论任何时间，你都可以由当前所在的岛 $S$ 去另一个从未到过的岛 $D$。从 $S$ 到 $D$ 有如下方法：
  - 步行：仅当两个岛之间有一座桥时才有可能。对于这种情况，桥的长度会累加到你步行的总距离中。
  - 渡船：你可以选择这种方法，仅当没有任何桥和以前使用过的渡船的组合可以由 $S$ 走到 $D$ (当检查是否可到达时，你应该考虑所有的路径，包括经过你曾游览过的那些岛)。

注意，你不必游览所有的岛，也可能无法走完所有的桥。

请你编写一个程序，给定 $N$ 座桥以及它们的长度，按照上述的规则，计算你可以走过的桥的长度之和的最大值。
## 输入格式

第一行包含一个整数 $N$，即公园内岛屿的数目。

随后的 $N$ 行每一行用来表示一个岛。第 $i$ 行由两个以单空格分隔的整数，表示由岛 $i$ 筑的桥。第一个整数表示桥另一端的岛，第二个整数表示该桥的长度 $L_i$。你可以假设对于每座桥，其端点总是位于不同的岛上。
## 输出格式

仅包含一个整数，即可能的最大步行距离。
## 样例

### 样例输入 #1
```
7
3 8
7 2
4 2
1 4
1 9
3 4
2 3
```
### 样例输出 #1
```
24
```
## 提示

**样例解释**：

![样例图示](https://cdn.vijos.org/fs/c82895f1d6f84d5756610176662d6ee644c3e55e)

样例 $N=7$ 座桥，分别为 $(1-3), (2-7), (3-4), (4-1), (5-1), (6-3)$ 以及 $(7-2)$。注意连接岛 $2$ 与岛 $7$ 之间有两座不同的桥。

其中一个可以取得最大的步行距离的方法如下：

- 由岛 $5$ 开始。
- 步行长度为 $9$ 的桥到岛 $1$。
- 步行长度为 $8$ 的桥到岛 $3$。
- 步行长度为 $4$ 的桥到岛 $6$。
- 搭渡船由岛 $6$ 到岛 $7$。
- 步行长度为 $3$ 的桥到岛 $2$。

最后，你到达岛 $2$，而你的总步行距离为 $9+8+4+3=24$。

只有岛 $4$ 没有去。注意，上述游览结束时，你不能再游览这个岛。更准确地说：

- 你不可以步行去游览，因为没有桥连接岛 $2$ (你现在的岛) 与岛 $4$。
- 你不可以搭渡船去游览，因为你可由当前所在的岛 $2$ 到达岛 $4$。一个方法是：走 $(2-7)$ 桥，再搭你曾搭过的渡船由岛 $7$ 去岛 $6$，然后走 $(6-3)$ 桥，最后走 $(3-4)$ 桥。

**数据范围**：

对于 $100\%$ 的数据，$2\leqslant N\leqslant 10^6,1\leqslant L_i\leqslant 10^8$。



---

---
title: "[IOI 2014] Wall 砖墙"
layout: "post"
diff: 提高+/省选-
pid: P4560
tag: ['2014', '线段树', 'IOI']
---
# [IOI 2014] Wall 砖墙
## 题目背景

原题为交互试题，但在此请提交**完整程序**。
## 题目描述

给定一个长度为 $n$且初始值全为 $0$的序列。你需要支持以下两种操作：

- Add $L, R, h$：将序列 $[L, R]$内所有值小于 $h$的元素都赋为 $h$，此时不改变高度大于 $h$的元素值
- Remove $L, R, h$：将序列 $[L, R]$内所有值大于 $h$的元素都赋为 $h$，此时不改变高度小于 $h$的元素值

你需要输出进行 $k$次上述操作之后的序列。
## 输入格式

输入的第一行包含两个正整数 $n, k$，分别表示序列中元素的个数以及操作数量，注意：**序列下标编号为 $0$ ~ $n-1$**。

接下来 $k$行每行包含 $4$个整数 $t, L, R, h$，若 $t = 1$则表明为 Add 操作，若 $t = 2$则表明为 Remove 操作。 $L, R, h$的含义见题目描述。
## 输出格式

输出包含 $n$行，每行包含 $1$个整数。第 $i$行的整数表示 $k$次操作之后序列中编号为 $i - 1$的元素的值。
## 样例

### 样例输入 #1
```
10 3
1 3 4 91220
1 5 9 48623
2 3 5 39412

```
### 样例输出 #1
```
0
0
0
39412
39412
39412
48623
48623
48623
48623

```
### 样例输入 #2
```
10 6
1 1 8 4
2 4 9 1
2 3 6 5
1 0 5 3
1 2 2 5
2 6 7 0

```
### 样例输出 #2
```
3
4
5
4
3
3
0
0
1
0

```
## 提示

- 子任务#1（8分）：满足 $1 \leq n \leq 10 000, 1 \leq k \leq 5 000$；
- 子任务#2（24分）：满足 $1 \leq n \leq 100 000, 1 \leq k \leq 500 000$，全部增加操作均在全部移除操作之前；
- 子任务#3（29分）：满足 $1 \leq n \leq 100 000, 1 \leq k \leq 500 000$；
- 子任务#4（39分）：满足 $1 \leq n \leq 2 000 000, 1 \leq k \leq 500 000$。

所有操作的高度 $h$满足 $0 \leq h \leq 100 000$。


---

---
title: "[IOI 2008] Type Printer"
layout: "post"
diff: 提高+/省选-
pid: P4683
tag: ['字符串', '2008', 'IOI', 'Special Judge', '深度优先搜索 DFS', '字典树 Trie']
---
# [IOI 2008] Type Printer
## 题目描述

你需要利用一台可移动的打印机打印出 $n$ 个单词。这种可移动式打印机是一种老式打印机，它需要你将一些小的金属块（每个包含一个字母）放到打印机上以组成单词。然后将这些小金属块压在一张纸上以打印出这个词。这种打印机允许你进行下列操作： 

- 在打印机当前词的末端（尾部）添加一个字母； 
- 在打印机当前词的尾部删去一个字母（将打印机当前词的最后一个字母删去）。仅当打印机当前至少有一个字母时才允许进行该操作；
- 将打印机上的当前词打印出来。 

初始时打印机为空，或者说它不含任何带字母的金属块。打印结束时，允许有部分字母留在打印机内。同时也允许你按照任意的次序打印单词。

由于每一个操作都需要一定时间，所以需要你尽可能减少所需操作的总数目（将操作的总数最小化）。

你需要编写一个程序，给定所要打印的 $n$ 个单词，找出以任意次序打印所有单词所需操作的最小数目，并输出一种这样的操作序列。
## 输入格式

- 第 $1$ 行包含一个整数 $n$, 表示你需要打印的单词数。 	
- 随后的 $n$ 行中，每一行都包含一个单词。每个词仅由小写字母组成，而且单词的长度为 $1$ 到 $20$ 个字母（包含 $1$ 和 $20$ 在内）。所有单词都不相同。
## 输出格式

第一行包含一个整数 $m$，表示打印这 $n$ 个单词所需操作的最小数目。

接下来的 $m$ 行，每行一个字符，表示你的操作序列，序列的描述方法如下：
- 添加一个字母，用这个小写字母的自身来表示。
- 删去一个字母，用 `-` 表示。
- 打印单词，用 `P` 表示。
## 样例

### 样例输入 #1
```
3
print
the
poem
```
### 样例输出 #1
```
20
t
h
e
P
-
-
-
p
o
e
m
P
-
-
-
r
i
n
t
P
```
## 提示

对于 $40\%$ 的数据，$n\leq18$；

对于 $100\%$ 的数据，$1\leq n\leq25000$。


---

---
title: "[IOI 2009] Raisins"
layout: "post"
diff: 提高+/省选-
pid: P4850
tag: ['搜索', '2009', 'IOI', 'O2优化', '记忆化搜索', '前缀和']
---
# [IOI 2009] Raisins
## 题目背景

IOI2009 D1T4
## 题目描述

普罗夫迪夫的著名巧克力大师 Bonny 需要切开一板带有葡萄干的巧克力。巧克力是一个包含许多相同的方形小块的矩形。小块沿着巧克力的边排列成 $N$ 行 $M$ 列，共有 $N\times M$ 块。每个小块上有 $1$ 个或多个葡萄干，没有葡萄干在小块的边上或者跨过两个小块。

最开始，巧克力是一整块。Bonny 需要把它切成上述的 $N\times M$ 个独立的小块。因为 Bonny 很忙，她需要她的助手 Sly Peter 帮她切。
Peter 只能从一端到另一端切直线，并且他要为他的每一刀得到报酬。Bonny 手头没有钱，但是她有足够的葡萄干，所以她提出用葡萄干付给 Peter。Sly Peter 同意接受葡萄干，但是有下面的条件：每次他把给定的一块巧克力切成两小块，他都要得到和那块给定的巧克力上葡萄干数目相同的葡萄干。

Bonny 想要付给 Peter 尽可能少的葡萄干。她知道这 $n\times m$ 个小块中每一个小块上葡萄干的数目。她可以选择递给 Peter 的巧克力的顺序，也可以告诉 Peter 如何切（横切还是竖切）以及从哪里切。请告诉 Bonny 如何把巧克力切成一个个独立的小块，使她能够付给 Sly Peter 尽可能少的葡萄干。

**任务**：编写一个程序，给定每个小块上葡萄干的数目，计算出 Bonny 要付给 Sly Peter 的最少的葡萄干的数目。
## 输入格式

第一行两个由空格隔开的整数 $N, M$，分别表示巧克力的行数和列数。

接下来 $N$ 行描述了每个小块上葡萄干的数目。其中第 $k$ 行描述了第 $k$ 行小块的巧克力。每行包含 $m$ 个整数，分别以一个空格隔开。这些整数描述了该行从左到右的小块。第 $k$ 行的第 $p$ 个整数表示位于第 $k$ 行第 $p$ 列的小块上的葡萄干数目 $R_{k, p}$。
## 输出格式

一行一个整数，表示 Bonny 要付给 Sly Peter 的最少的葡萄干的数目。
## 样例

### 样例输入 #1
```
2 3
2 7 5
1 9 5

```
### 样例输出 #1
```
77

```
## 提示

### 样例解释

一种可能的代价为 $77$ 的切割方案如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/zg74ypip.png)

第一次切割将第三列和剩下来的巧克力分开了。Bonny 需要付给 Peter $29$ 个葡萄干。

接下来 Bonny 把较小的那一块巧克力（有两小块，每一块都有 $5$ 个葡萄干）给 Peter，要求 Peter 切成两半并支付 $10$ 个葡萄干。

在此之后，Bonny 给 Peter 剩下来的最大块（分别有 $2,  7, 1, 9$ 个葡萄干在它的四个小块上）。Bonny 要求 Peter 水平切割这一块，将第一行和第二行分开并付给他 $19$ 个葡萄干。

此后 Bonny 给 Peter 左上角的块，支付 $9$ 个葡萄干。最后 Bonny 要求 Peter 将左下角的块分开，支付 $10$ 个葡萄干。

Bonny 的总代价是 $29 + 10 + 19 + 9 + 10 = 77$ 个葡萄干。没有其它安排切割的方案有更小的代价。

### 数据范围与约定

- 对于 $25\%$ 的数据，$n,m\leq 7$。
- 对于 $100\%$ 的数据，$1\leq n,m\leq 50$，$1\leq R_{k, p}\leq 1000$。


---

---
title: "[IOI 2019] 排列鞋子"
layout: "post"
diff: 提高+/省选-
pid: P5749
tag: ['贪心', '2019', 'IOI']
---
# [IOI 2019] 排列鞋子
## 题目描述

**由于洛谷数据点限制，本题仅评测其中的 $100$ 个数据点。**

如果需要测试全部数据，有以下两道题：

1. [Subtask 1-3](/problem/U98795)
2. [Subtask 4-6](/problem/U98796)

两题满分均为 $50$ 分，包含 Subtask中所有的测试点。

---

Adnan 拥有巴库最大的鞋店。现在有一个装着 $n$ 双鞋的箱子刚运到他的鞋店。每双鞋是大小相同的两只：一只左脚，一只右脚。Adnan 把这 $2n$ 只鞋排成一行，该行总共有 $2n$ 个**位置**，从左到右编号为 $0$ 到 $2n-1$ 。

Adnan 想把这些鞋子重新排成**合法的排列**。一个排列是合法的，当且仅当对于所有的 $i(0\leqslant i \leqslant n - 1)$，以下条件都成立：

- 在位置 $2i$ 和 $2i+1$ 上的鞋子大小相同；
- 在位置 $2i$ 上的鞋子是一只左脚鞋；
- 在位置 $2i+1$ 上的鞋子是一只右脚鞋。

为实现上述目标，Adnan 可以做一系列对调。在每次对调中，他选择当前**相邻**的两只鞋进行对调（也就是把它们拿起来，然后将每只鞋子放回到另一只鞋子原来的位置上）。两只鞋子是相邻的，当且仅当其位置编号的差为 $1$。

请求出 Adnan 最少要做出多少次对调，才能得到一个合法排列。
## 输入格式

第一行一个正整数 $n$，表示有 $n$ 双鞋。

第二行 $2n$ 个整数 $S_i$，第 $i$ 个整数表示位置编号为 $i-1$ 的鞋子。其中 $|S_u|\neq 0$，等于最初在位置 $i$ 上的鞋子的大小。这里 $|x|$ 表示 $x$ 的绝对值，当 $x\geq 0$ 时等于 $x$，当 $x < 0$ 时等于 $-x$。如果 $S_i < 0$，则 $i$ 位置上的鞋子是一只左脚鞋，否则是右脚鞋。
## 输出格式

输出一行一个整数，表示最少对调次数。
## 样例

### 样例输入 #1
```
2
2 1 -1 -2

```
### 样例输出 #1
```
4

```
### 样例输入 #2
```
3
-2 2 2 -2 -2 2

```
### 样例输出 #2
```
1

```
## 提示

**样例说明 1**

Adnan 可以通过 $4$ 次对调而得到一个合法的排列。

例如，他可以先对调 $1$ 和 $-1$，再对调 $1$ 和 $-2$，再对调 $-1$ 和 $-2$。最后对调 $-2$ 和 $2$。随后他就可以得到合法的排列 。无法用少于 $4$ 次对调就得到合法的排列，因此输出 $4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ybs09z2e.png)

**样例说明 2**

Adnan 可以对调在位置 $2$ 和 $3$ 上的鞋子来得到合法的排列$[-2,2,-2,2,-2,2]$，因此应当输出 $1$。

**数据范围**

对于所有数据：

- $1\leqslant n\leqslant10^5$；
- 对于所有$i(0\leqslant i\leqslant 2n-1)$，都有$1\leqslant \left|S_{i+1}\right|\leqslant n$；
- 总有某个合法的排列可以经由一系列对调而得到。

详细子任务附加限制与分值如下表：

| 子任务编号 | 附加限制 | 分值 |
|:---:|:---:|:---:|
| $1$ | $n=1$ | $10$|
|$2$|$n\leqslant8$|$20$|
|$3$|所有鞋子大小都是相同的|$20$|
|$4$|所有在位置 $0,\dots,n-1$ 上的鞋都是左脚鞋，而在位置 $n,\dots,2n-1$ 上的鞋都是右脚鞋。而且对于所有 $i(0\leqslant i\leqslant n-1)$，在位置 $i$ 和 $i+n$ 上的鞋子大小相同|$15$|
|$5$|$n\leqslant10^3$|$20$|
|$6$|无附加限制|$15$|


---

---
title: "[IOI 2011] crocodile"
layout: "post"
diff: 提高+/省选-
pid: P5845
tag: ['2011', 'IOI']
---
# [IOI 2011] crocodile
## 题目描述

考古学家 Benjamas 考察了神秘的鳄鱼地下宫殿之后需要设法逃离。这个地下宫殿包含 $N$ 个洞穴和 $M$ 条双向的通道。每条通道连接一对不同的洞穴，两个洞穴之间最多只有一条通道，在不同的通道上行走可能需要不同的时间。$N$ 个洞穴中有 $K$ 个洞穴是出口洞穴， Benjamas 可以从出口洞穴逃离。Benjamas 从 $0$ 号洞穴出发，她希望尽快地到达一个出口洞穴。

鳄鱼门卫要阻止 Benjamas 逃离宫殿。它可以通过机关来堵住任意一个的通道（任意时刻，只能堵住一个通道）。即无论何时，鳄鱼门卫堵住一个新的通道，则之前堵住的通道就会被打开。

Benjamas 逃离过程可以描述如下：每次她试图离开一个洞穴时，鳄鱼门卫都会封闭一条连接该洞穴的通道。Benjamas 只能选择没有被封闭的通道走到下一个洞穴。Benjamas 一旦进入一条通道，在她到达该通道的另一端前，鳄鱼门卫不能封闭这条通道。当 Benjamas到达下一个洞穴，鳄鱼门卫可以选择再封闭一条通道（可以是 Benjamas 刚刚走过的那条通道）。

Benjamas 需要设计一个逃生计划，确切地说，她希望有一系列指令告诉她如何逃生。

设 $A$ 是一个洞穴，如果 $A$ 是出口洞穴，Benjamas 可以直接逃生。否则，对洞穴 $A$，指令是下列形式中的一种：

- 在洞穴 $A$，优先选择一条通道到洞穴 $B$。如果该通道被封堵，则选择另一通道去洞穴 $C$。

- 不用考虑洞穴 $A$，按照逃生计划不会到达 $A$。

注意：数据保证不管鳄鱼门卫如何封闭通道，总能找到一个好的逃生计划保证 Benjamas 在有限时间内可以到达一个出口洞穴。在所有逃生计划中，在最坏情况下用时最短的逃生计划所用的时间定义为 $T$。
## 输入格式

第一行三个整数 $N$，$M$，$K$；

接下来 $M$ 行 每行三个整数 表示一条无向边的两端和长度（无重边）；

接下来 $K$ 个整数 表示出口洞穴。
## 输出格式

一个整数 最小时间 $T$。
## 样例

### 样例输入 #1
```
13 12 9
0 1 1
0 2 4
0 3 11
1 4 11
1 5 7
1 6 15
2 7 3
2 8 13
2 9 23
3 10 3
3 11 1
3 12 2
4 5 6 7 8 9 10 11 12

```
### 样例输出 #1
```
13

```
## 提示

**数据范围**

对于 $100\%$ 的数据，$3 \le N \le 10^5$，$2 \le M \le 10^6$，测试数据保证 $T$ 存在，且 $T \le 10^9$。


---

---
title: "[IOI 2005] mou"
layout: "post"
diff: 提高+/省选-
pid: P5848
tag: ['2005', 'IOI']
---
# [IOI 2005] mou
## 题目描述

游乐园已经开始运行一个崭新的模拟过山车。模拟的轨道由 $n$ 段铁轨组成，并且首尾相连。第一段铁轨从高度 $0$ 开始。

操作员 Byteman 能通过调整连续几段的铁轨高度来改造这条轨道。在被改造的一段前面的铁轨高度不受影响。 每一次铁轨被调整。后面的轨必须升起或降低来保持连通，并保证起点高度为 $0$。下页举例说明轨道改造过程。 每次开始时车都有足够能量到达高度 $h$。也就是说，只要轨道的高度不超过 $h$，车就一直开下去, 甚至直到结束。 

给出每天的运行和改造情况, 为每次运行计算在车停止前，到达的铁轨数。铁轨以一个 $n$ 个数的数列形式表示 ，一个数对应一段铁轨。第 $i$ 个 $d_i$ 表示在第 $i$ 段铁轨上的高度变化。也就是说，在到达铁轨 $i$ 前，如果车的高度是 $h$，那么经过铁轨i后，高度变为 $h+d_i$。

最初轨道是一条水平线。就是说对于所有的 $i$ 都是 $d_i=0$。运行和改造交错进行。 每个改造用三个数表示: $a$ ，$b$ 和 $D$。表示从 $a$ 到 $b$ (包括 $a$,$b$) 的所有 $d_i$ 改为 $d_i=D$。每次运行给定一个数字 $h$ ——车能到达的最大高度。
## 输入格式

输入的第一行包括一个正整数 $n$ ——铁轨的数目。

下面的行包括改造和运行，各有一个标识符： 

- 改造——一个字母 `I`，和整数$a$,$b$,$D$ ,中间用一个空格隔开。
- 运行——一个字母 `Q`，和一个整数 $h$，用一个空格隔开。 
- 一个字母 `E` ——结束符号，表示输入结束。 

你可以假设任意时刻任意铁轨的高度在 $[1，1000000000]$ 区间内。

输入不超过 $10000$ 行。
## 输出格式

第 $i$ 行需包含一个整数， 即第 $i$ 次运行经过的铁轨数。
## 样例

### 样例输入 #1
```
4
Q 1
I 1 4 2
Q 3
Q 1
I 2 2 -1
Q 3
E

```
### 样例输出 #1
```
4
1
0
3

```
## 提示

对于 $50\%$ 的数据，$1 \le n \le 2 \times 10^4$，且输入不超过 $1000$ 行；

对于 $100\%$ 的数据，$1 \le n \le 10^9$，$1 \le a,b \le n$，$- 10^9 \le D \le 10^9$，$0 \le h \le 10^9$。


---

---
title: "[IOI 2015] horses"
layout: "post"
diff: 提高+/省选-
pid: P5874
tag: ['2015', 'IOI']
---
# [IOI 2015] horses
## 题目描述

像他的祖先一样，Mansur 喜欢繁殖马匹。目前，他拥有哈萨克斯坦最大的马场。以前情况可不是这样，$N$ 年前 Mansur 年轻时，他只拥有一匹马，但他一直梦想着成为富豪，最终,他美梦成真。

按照时间的先后顺序将年份编号为 $0$ 到 $N-1$（即 $N-1$ 年是最近的一年）。每年的天气会影响马匹的繁殖。Mansur 用一个正整数 $X[i]$ 记录第 $i$ 年的繁殖系数，如果第 $i$ 年开始时有 $h$ 匹马，那么这一年结束时会有 $h \times X[i]$ 匹马。

每年，只有年底的时候可以出售马匹。Mansur 用一个正整数 $Y[i]$ 记录第 $i$ 年末卖出一匹马的售价。Mansur 可以卖出任意多匹马，每匹售价均为 $Y[i]$。

现在，Mansur 想知道如果在 $N$ 年中，他总能在最佳时间出售马匹，他能获得的最大收益是多少？你正好在 Mansur 家做客，所以他想请你帮他回答这个问题。

Mansur 对记录下的 $X$ 和 $Y$ 做了 $M$ 次更新，每次更新，Mansur 要么改变一个 $X[i]$，要么改变一个 $Y[i]$。每次更新后，他都会问你出售马匹能获得的最大收益。Mansur 的更新是累加的，即你的每个回答时都应该考虑之前的所有更新。注意：某个 $X[i]$ 或者 $Y[i]$ 可能会被更新多次。

对于 Mansur 的问题，实际的答案可能是一个非常大的数字，你只要给出实际答案模 $10^9+7$ 后的结果即可。
## 输入格式

- 第 $1$ 行，一个整数 $N$，表示总共有 $N$ 年。
- 第 $2$ 行，共 $N$ 个正整数 $X[0],\cdots,X[N - 1]$，对于 $0\le i \le N-1$，$X[i]$ 表示 $i$ 年的繁殖系数。
- 第 $3$ 行，共 $N$ 个正整数 $Y[0],\cdots,Y[N - 1]$，对于 $0\le i \le N-1$，$Y[i]$ 表示 $i$ 年末出售一匹马的价格。
- 第 $4$ 行，一个整数 $M$，表示更新次数。
- 第 $5,\cdots,M+4$ 行，每行 $3$ 个数字 $type$，$pos$，$val$ （$type=1$ 表示更改 $X[ pos ]$ 为 $val$，$type=2$ 表示更改 $Y[ pos ]$ 为 $val$）。
## 输出格式

- 共 $M+1$ 行
- 第 $1$ 行：一个整数表示初始状态下，Mansur 获得的最大收益模 $10^9+7$ 后的值。
- 第 $2,\cdots,M+1$ 行：每行一个整数，表示这次更新后 Mansur 获得的最大收益模 $10^9+7$ 后的值。
## 样例

### 样例输入 #1
```
3
2 1 3
3 4 1
1
2 1 2

```
### 样例输出 #1
```
8
6

```
## 提示

对于 $100\%$ 的数据，$1\le N\le 5\times 10^5$，$0 \le M \le 10^5$。


---

---
title: "[IOI 2014] friend 朋友"
layout: "post"
diff: 提高+/省选-
pid: P5875
tag: ['2014', 'IOI', '交互题']
---
# [IOI 2014] friend 朋友
## 题目背景

**这是一道交互题**
## 题目描述

我们建立了一个由编号为 $0,\cdots,n - 1$ 的 $n$ 个人组成的社交网络。网络中的有些对会成为朋友。如果 $x$ 号人成为 $y$ 号人的朋友，则 $y$ 号人同时也会成为 $x$ 号人的朋友。

这些人将通过 $n$ 个阶段加入这个网络，阶段也编号为 $0$ 至 $n−1$。第 $i$ 号人在第 $i$ 个阶段加入。在阶段 $0$，$0$ 号人加入网络并成为唯一的人。此后 $n - 1$ 个阶段的各个阶段，都有一个人会被主持人加入到网络中，而这个主持人可以是已在网络中的任何一个人。在阶段 $i$ 中（$1\le i\le n−1$），该阶段的主持人可以用如下三种方式之一把第 $i$ 号人加入到网络中：

- IAmYourFriend：将第 $i$ 号人仅变成主持人的朋友。
- MyFriendsAreYourFriends：将第 $i$ 号人变成主持人当前的每一个朋友的朋友。 注意，这个方式不会将第 $i$ 号人变成主持人的朋友。
- WeAreYourFriends：将第 $i$ 号人变成主持人的朋友，同时也变成主持人当前的每一个朋友的朋友。

在建立此网络之后，我们想挑选一个调查的样本，也就是说要从网络中选择一组人。由于朋友之间通常拥有相似的兴趣，因此样本不应包含任何一对互为朋友的人。每个人都会有一个调查的可信度，表示为一个正整数，而我们想要找出一个可信度总和最大的样本。

### 任务

给定各阶段的描述以及每个人的可信度值，请找出一个可信度总和最大的样本。你只需要实现函数 `findSample`。

* `findSample(n, confidence, host, protocol)`
	* $n$: 人数.
	* `confidence`: 大小为 $n$ 的数组；`confidence[i]` 表示第 $i$ 号人的可信度。
	* `host`: 大小为 $n$ 的数组；`host[i]` 表示阶段 i 的主持人。
	* `protocol`: 大小为 $n$ 的数组；`protocol[i]` 表示在阶段 （$0<i<n$） 所采用的方式的代码: `0` 代表 IAmYourFriend，`1` 代表 MyFriendsAreYourFriends，而 `2` 代表 WeAreYourFriends。
	* 由于在阶段 `0` 中没有主持人，因此 `host[0]` 和 `protocol[0]` 是没有被定义的，而且在你的程序中也不应访问它们。

这个函数应该返回样本可信度总和的最大值。
## 输入格式

以下为交互库的输入格式。

第 $1$ 行：一个正整数 $n$，为人数。

第 $2$ 行：共 $n$ 个整数 $\mathrm{confidence}[0],\ldots,\mathrm{confidence}[n-1]$.

第 $3$ 行：共 $2n-2$ 个整数 $\mathrm{host}[1],\mathrm{protocol}[1], \mathrm{host}[2], \mathrm{protocol}[2],\cdots, \mathrm{host}[n-1], \mathrm{protocol}[n-1]$。
## 输出格式

本题只支持 C++ 系列语言。

你只能提交一个源文件实现上述的函数，其命名与接口需遵循下面的要求。**不需要添加额外的头文件**。

`int findSample(int n, int confidence[], int host[], int protocol[]);`
## 样例

### 样例输入 #1
```
6
13 3 6 20 10 15
0 0 0 1 1 2 2 1 0 0

```
### 样例输出 #1
```
35

```
## 提示

对于 $100\%$ 的数据，$2 \le n \le 10^5$，$1 \le \mathrm{confidence}[i] \le 10^6$。

|**子任务**|**分值**|$n$|**可信度**|**采用的方式**|
|:-:|:-:|:-:|:-:|:-:|
|1|$11$|$n\leq 10$|$1\leq \mathrm{confidence}\leq 10^6$|全部三种方式|
|2|$8$|$n\leq 1000$|$1\leq \mathrm{confidence}\leq 10^6$|只有 `MyFriendsAreYourFriends`|
|3|$8$|$n\leq 1000$|$1\leq \mathrm{confidence}\leq 10^6$|只有 `WeAreYourFriends`|
|4|$19$|$n\leq 1000$|$1\leq \mathrm{confidence}\leq 10^6$|只有 `IAmYourFriend`|
|5|$23$|$n\leq 1000$|所有可信度值均为 $1$|只有 `MyFriendsAreYourFriends` 和 `IAmYourFriend` 两种方式|
|6|$31$|$n\leq 10^5$|$1\leq \mathrm{confidence}\leq 10^4$|全部三种方式|


---

---
title: "[IOI 2013] robots 机器人"
layout: "post"
diff: 提高+/省选-
pid: P5894
tag: ['2013', 'IOI', 'O2优化']
---
# [IOI 2013] robots 机器人
## 题目描述

Marita 的弟弟把玩具扔在客厅地板上，乱七八糟。庆幸的是，Marita 设计了一种特殊的机器人可以收拾玩具。 不过，她需要确定哪个机器人去拣起哪个玩具。

一共有 $T$ 个玩具,整数 $W[i]$ 表示这个玩具的重量，整数 $S[i]$ 表示这个玩具的体积。机器人有两种，分别是：弱机器人和小机器人。

- 有 $A$ 个弱机器人。每个弱机器人有一个重量限制 $X[i] $，它只能拿起重量严格小于 $X[i]$ 的玩具，与玩具的体积大小没关系。
- 有 $B$ 个小机器人。每个小机器人有一个体积限制 $Y[i] $，它只能拿起体积严格小于 $Y[i]$ 的玩具，与玩具的重量大小没有关系。

Marita 的每个机器人用 $1$ 分钟将一个玩具拿走放好。不同的机器人可以同时拿走并放好不同的玩具。

你的任务是确定 Marita 的机器人是否可以将所有的玩具都收拾好，如果是，那么最少用多少时间可以收拾好。

## 输入格式

- 第1行: $A$ 表示弱机器人的数目，$B$ 表示小机器人的数目，$T$ 表示玩具的数目；
- 第2行: 长度为 $A$ 的数组 $X[0],\cdots,X[A­-1]$，对于 $0 \le i \le A-1$，$X[i]$ 表示第 $i$ 个弱机器人的重量限制；
- 第3行: 长度为 $B$ 的数组 $Y[0],\cdots,Y[B-­1]$，对于 $1 \le i \le B-1$，$Y[i]$ 表示第 $i$ 个小机器人的体积限制；
- 接下来 $T$ 行: $W[i]$，$S[i]$，对于 $1 \le i \le T$，$W[i]$ 代表第 $i$ 个玩具的重量，$S[i]$ 代表第 $i$ 个玩具的体积。

- 如果 $A = 0$ 或者 $B = 0$ ，那么相应的行（第 $2$ 行或者第 $3$ 行）为空。

## 输出格式

- 共 $1$ 行，输出机器人收拾好所有玩具所需要的最短时间，如果无法收拾好所有玩具，输出 `­-1`。
## 样例

### 样例输入 #1
```
3 2 10
6 2 9
4 7
4 6
8 5
2 3
7 9
1 8
5 1
3 3
8 7
7 6
10 5


```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
2 1 3
2 5
2
3 1
5 3
2 2

```
### 样例输出 #2
```
-1
```
## 提示

对于 $100\%$ 的数据，$1 \le T \le 10^6$，$0 \le A,B \le 5 \times 10^4$ 且 $1 \le A+B$，$1 \le X[i],Y[i],W[i],S[i] \le 2 \times 10^9$。


---

---
title: "[IOI 2005] gar"
layout: "post"
diff: 提高+/省选-
pid: P5920
tag: ['2005', 'IOI']
---
# [IOI 2005] gar
## 题目背景

 Byteman 拥有镇上最漂亮的花园。
## 题目描述

他在自己的花园里面种了 $N$ 朵玫瑰花。

夏天来了，所有的花都开的非常的漂亮。 Byteman 开始意识到自己没有能力看管自己花园里的所有的花，所以他决定雇佣两个园丁来帮助他。

他想在花园中选择两块矩形的区域分别交给两个园丁看管。而且这两个矩形区域必须不能相交或者重叠，并且每一个区域要恰好包含 $K$ 朵玫瑰花。

Byteman 想要给这两块矩形区域的周围安上栅栏，但是他现在手头比较紧，所以他希望自己花的钱尽量的少。你的任务就是帮助 Byteman 选择两块矩形的区域,使得它们在满足条件的情况下周长和最小。 

Byteman 的花园有 $L$ 米长，$W$ 米宽。花园被分成了 $L\times W$ 个大小相同 $1\times1$ 的方格。我们以平行与花园的两边建立起一个坐标系。所有的方格的坐标 $(x,y)$ 满足 $1\leq x\leq L,1\leq y\leq W$。每个方格内可能会有任意数目的玫瑰。 

所选的矩形区域的两边必须跟花园的两边平行，并且矩形区域的四个角的坐标必须是整数。对于 $1\le L_1\le L_2\le L$ 并且 $1\le W_1\le W_2\le W$，一个矩形区域的四个角为 $(L_1,W_1),(L_1,W_2)$，$(L_2,W_1)$ 和 $(L_2,W_2)$: 

* 这个矩形内所包含的点的坐标 $(x,y)$ 满足$L_1\le x\le L_2$并且$W_1\le y\le W_2$。

* 这个矩形的周长是 $2\times (L_2-L_1+1)+2\times (W_2-W_1+1)$。所选的两块矩形不能重叠或者相交。也就是它们不能有公共的方格。即使它们有公共的边，计算周长的时候也要分别计算。
## 输入格式

第一行是 $L$ 和 $W$。

第二行是 $N$ 和 $K$。

接下来 $N$ 行为 $N$ 朵玫瑰的坐标。
## 输出格式

输出仅有一行，为最小周长。

如果不存在满足题意的矩形，则输出`NO`。
## 样例

### 样例输入 #1
```
6 5
7 3
3 4
3 3
6 1
1 1
5 5
5 5
3 1
```
### 样例输出 #1
```
22
```
## 提示

对于$100\%$的数据，$1\le L,W\le250$，$2\le n\le5000,1\le k\le \frac{n}{2}$


---

---
title: "[IOI 2012] rings"
layout: "post"
diff: 提高+/省选-
pid: P6165
tag: ['2012', 'IOI', 'O2优化']
---
# [IOI 2012] rings
## 题目描述

在李奥纳多的文献  "Codex  Atlanticus"  中描述了一种早期而复杂的降落伞。李奥纳多的降落伞是一个由布料缝制而成的金字塔型木头结构。

**串接的圆环**

空中自由落体玩家 Adrain Nicholas （爱准尼古拉斯） 在五百年后测试了李奥纳多的设计。在这个测试中，一个现代的轻量结构将李奥纳多的降落伞使用到人体。我们想要使用串接的圆环，这些圆环为缝制的布料提供了钩子。圆环可以很简单地串接在一起，而且每一个圆环可以打开或关闭。串接的圆环可以构成一种特殊的型态叫做"链"（chain）。所谓的"链"指的是一序列串接的圆环，每个圆环可以串接（最多两个）邻居。但是这个序列必须有个起头与结束（这两个圆环只能串接另外一个圆环）。如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/w6zr6nns.png)

其他种串接型态当然是可能的，因为一个圆环可以串接到3个或更多的圆环。我们说一个圆环是"关键的"如果我们将它打开并移除这个圆环，其他的圆环会形成互无交集的链的集合(或者是没有任何的圆环留下)。

**例子**

请参考下图中的 $7$ 个圆环，其编号由 $0$ 到 $6$。在这个例子中有两个"关键"圆环。其中一个关键圆环是编号 $2$ 的圆环。移除此圆环，剩下的圆环形成三条链 $[1]$, $[0,5,3,4]$ 以及 $[6]$。另外一个关键圆环是编号 $3$ 的圆环，移除此圆环，剩下的圆环形成三条链 $[1,2,0,5]$,$[4]$，以及 $[6]$。如果我们尝试着移除其他的圆环，我们无法获得互无交集的链集合。举例来说，移除编号 $5$ 的圆环之后，虽然可以获得 $[6]$ 这样的一条链，但是 $0,1,2,3$ 以及 $4$ 并没有形成一条链。

![](https://cdn.luogu.com.cn/upload/image_hosting/wk40d8go.png)

**任务**

给定一个串接的圆环型态，你的程序必须计算其关键圆环的个数。

## 输入格式

- 第一行，有 $2$ 个整数 $N$，$L$。$N$ 代表有 $N$ 个互无交集的圆环，其编号从 $0$ 到 $N-1$ 作为初始的圆环形态，$L$ 表示操作的个数。

- 第 $2$ 到 $L+1$ 行，每行包含 $1$ 或 $2$ 个整数，表示一个操作。具体如下：

1.`A B` 表示将编号 $A$ 以及编号 $B$ 的圆环串联在一起。保证 $A$ 和 $B$ 不相同。

2.`-1` 输出一行，目前串接圆环的组态中关键圆环的个数。
## 输出格式

对于每项 $2$ 操作，输出一行，表示当时串接圆环的组态中关键圆环的个数。
## 样例

### 样例输入 #1
```
100 84
30 79
26 63
96 30
17 97
33 63
73 25
17 7
96 48
80 6
3 34
51 48
33 37
89 7
72 65
51 54
49 37
45 72
50 39
95 89
3 55
25 0
2 54
10 91
59 2
29 46
0 40
95 68
69 45
87 68
49 38
20 69
87 15
35 39
59 47
38 62
91 19
35 70
83 19
28 20
70 24
36 55
75 36
28 12
53 29
12 16
75 84
40 85
27 53
58 62
88 84
44 27
76 24
58 22
8 44
94 15
14 94
5 83
31 85
90 5
88 42
81 47
76 67
82 80
31 93
14 74
42 98
99 82
71 8
98 92
18 22
81 52
99 23
41 67
74 1
93 56
4 52
1 86
92 60
56 66
18 61
16 57
43 23
4 64
-1

```
### 样例输出 #1
```
100

```
## 提示

对于 $100\%$ 的数据，$1 \le N,L \le 10^6$。


---

---
title: "[IOI 2012] scrivener"
layout: "post"
diff: 提高+/省选-
pid: P6166
tag: ['2012', 'IOI']
---
# [IOI 2012] scrivener
## 题目描述

有些人说李奥纳多是一个对于 Johannes  Gutenberg 的崇拜者，Johannes 是一个发明活字印刷的德国铁匠，为了表达尊敬，李奥纳多设计了一台机器被称为小龙虾代书，那是一个非常简单的打字设备。这机器就像一部简单的现代打字机，但只能接受两个指令。一个指令是 输出一个字符，另一个指令是取消最近的指令。小龙虾代书的最大特点就是拥有这个功能强大的取消指令。因为一个取消指令本身也是一个指令，所以也可以被取消。

**说明**

你的任务是作出此小龙虾代书的程序，一开始并无输出任何文字，然后开始接受使用者输入的一连串指令，并可查询目前输出文字中的特定位置的字符。详细说明如下:

- `TypeLetter(L)` —附加一个小写字母L在输出文字的最后，$L$ 可以是 $a,b,\cdots, z$。

- `UndoCommands(U)` — 取消之前的 $U$ 个指令，$U$ 是一个正整数。

- `GetLetter(P)` — 回传在输出文字中位置为 $P$ 的字符，$P$ 是一个非负整数。 输出文字中的第一个字符的位置为 $0$。 （这个查询并不是一个指令，因此会被取消指令忽略。）

三种操作可以依照任何顺序被呼叫 $0$ 次或多次以上。

指令 `UndoCommands(U)` 会依照原本执行的相反顺序来取消前面 $U$ 个指令: 如果被取消的指令是 `TypeLetter(L)`，就会从输出文字最后面移除字母 $L$。如果被取消的指令是 `UndoCommands(X)`，那么将会依照原本执行的顺序重新执行之前被取消的 $X$ 个指令。

**范例**

我们列出一连串可能的指令，以及每次执行指令后的输出文字。

| 操作 | 回传 | 输出文字 |
| :-----------: | :-----------: | :-----------: |
| `TypeLetter(a)` |  | `a` |
| `TypeLetter(b)` |  | `ab` |
| `GetLetter(1)` | `b` | `ab` |
| `TypeLetter(d)` |  | `abd` |
| `UndoCommands(2)` |  | `a` |
| `UndoCommands(1)` |  | `abd` |
| `GetLetter(2)` | `d` | `abd` |
|  `TypeLetter(e)`|  | `abde` |
| `UndoCommands(1)` |  | `abd` |
| `UndoCommands(5)` |  | `ab` |
|`TypeLetter(c)`  |  | `abc` |
| `GetLetter(2)` | `c` | `abc` |
| `UndoCommands(2)` |  | `abd` |
| `GetLetter(2)` | `d` | `abd` |

## 输入格式

- 第 $1$ 行，一个正整数 $N$，表示操作的个数。

- 第 $2$ 到 $N+1$ 行，每行开始有一个大写字母参数。

1. `T` 表示一个 `TypeLetter` 指令，后面接着一个空白和一个小写字母参数。

2. `U` 表示一个 `UndoCommands` 指令，后面接着一个空白和一个整数参数。

3. `P` 表示一个 `GetLetter` 指令，后面接着一个空白和一个整数参数。
## 输出格式

对于每项 `GetLetter` 操作，输出一行，一个回传的字符。
## 样例

### 样例输入 #1
```
10
T c
T z
T u
T a
T i
T h
T f
T z
P 3
P 0

```
### 样例输出 #1
```
a
c

```
### 样例输入 #2
```
98
T u
T g
T p
T h
T w
P 3
P 0
T d
T d
T r
T v
T z
T w
T h
P 0
T d
T v
T b
P 9
T n
T e
P 0
T s
T i
T a
P 6
T b
T n
T m
T t
T m
T g
T y
T g
P 0
T m
P 18
T r
P 17
T w
T w
T o
T m
T m
P 0
T q
P 5
T t
P 27
P 34
T p
T f
T h
T j
T f
T l
P 3
T f
T q
T h
P 17
T w
T d
T p
T z
P 0
T m
P 10
T o
P 5
P 18
P 7
T q
T z
P 2
T u
P 10
T e
P 6
T s
T t
P 24
T s
P 0
T t
T c
P 4
T j
T o
P 5
T i
P 11
T a
T t
P 58
P 51
P 64
P 12

```
### 样例输出 #2
```
h
u
u
z
u
d
u
i
s
u
d
g
m
h
s
u
w
d
i
r
p
w
d
m
u
w
d
h
s
o
a
d

```
## 提示

对于 $100\%$ 的数据，$1 \le N \le 10^6$。参数 $U$ 保证不会超过前面已经输入的指令数目，而且参数 $P$ 一定小于输出文字的长度（也就是输出文字的字母数）。


---

---
title: "[IOI 2016] molecules"
layout: "post"
diff: 提高+/省选-
pid: P6169
tag: ['2016', 'IOI', 'Special Judge']
---
# [IOI 2016] molecules
## 题目描述

彼得在一家公司工作，这家公司已经制造了一台检测分子的机器。每个分子的重量都是正整数。这台机器的检测范围是 $[l,u]$，这里 $l$ 和 $u$ 都是正整数。这台机器能够检测一个分子集合当且仅当这个集合包含了一个子集，这个子集的分子的重量属于机器的检测范围。

考虑 $n$ 个分子，重量记为 $w_0,\cdots,w_{n-1}$。如果存在一个下标的集合（并且该集合中的下标都不相同）$I=\{i_1,\cdots,i_m\}$ 使得 $l\le w_{i_1}+\cdots+w_{i_m}\le u$，那么检测就会成功。

由于机器的细节，$l$ 和 $u$ 之间的差距要保证会大于等于最重分子和最轻分子之间的差距，即 $u-l \ge w_{max}-w_{min}$，其中 $w_{max}=\max(w_0,\cdots,w_{n-1})$，$w_{min}=\min(w_0,\cdots,w_{n-1})$

你的任务是写一个程序，该程序能找到一个子集，使得该子集的总重量属于检测范围，或者判定没有这样的子集存在。


### 样例一 
 
 ```
  4 15 17
  6 8 8 7
 ```

这个例子当中，我们有四个分子，重量分别是 $6,8,8$ 和 $7$。这台机器可以检测子集总重量在 $15$ 到 $17$ 之间（包含 $15$ 和 $17$）的子集。注意，$17-15 \ge 8-6$。分子 $1$ 和分子 $3$ 的重量之和为 $w_1+w_3=8+7=15$, 所以应该输出
```
2
1 3
```
其他可能正确的答案有 
```
2 
1 2
```
（$w_1+w_2=8+8=16$）

和 
```
2
2 3
```
（$w_2+w_3=8+7=15$）。

### 样例二 

```
4 14 15
5 5 6 6
```

这个例子当中，我们有四个分子，重量分别为 $5,5,6$ 和 $6$，我们要寻找一个子集，其总重量介于 $14$ 和 $15$ 之间（包含 $14$ 和 $15$）。请注意，$15-14 \ge 6-5$。因为不存在总重量介于 $14$ 和 $15$ 之间的子集，所以输出 `0`。
## 输入格式

- 第一行：整数 $n,l$ 和 $u$。

- 第二行：$n$ 个整数：$w_0,\cdots,w_{n-1}$。
## 输出格式

如果有满足条件的子集：

- 第一行，输出该子集大小 $x$。

- 第二行，$x$ 个整数，符合要求的子集中的分子的下标。

如果没有，输出 `0`。
## 样例

### 样例输入 #1
```
1 10 12
9

```
### 样例输出 #1
```
0

```
### 样例输入 #2
```
2 5 10
4 2
```
### 样例输出 #2
```
2
0 1
```
## 提示

对于 $100\%$ 的数据，$n \le 2 \times 10^5$，$w_i \le 	2^{31}-1$，$l,u \le 2^{31}-1$。


---

---
title: "[IOI 2020] 连接擎天树"
layout: "post"
diff: 提高+/省选-
pid: P6830
tag: ['2020', 'IOI', '交互题', 'Special Judge', '深度优先搜索 DFS']
---
# [IOI 2020] 连接擎天树
## 题目背景

**这是一道交互题。**

本题仅支持 C++ 系列语言，提交时**不需要**包含 `supertrees.h` 头文件，但**需要**在程序开头包含 `vector` 头文件以及声明函数 `void build(std::vector<std::vector<int> > b);`
## 题目描述

滨海湾花园是新加坡的一个大型自然公园。公园内有 $n$ 个塔，称之为“擎天树”。这些塔的编号为 $0$ 到 $n-1$。我们希望建立一个桥的集合（桥的数目大于等于 $0$）。每⼀座桥连接两个不同的塔，而且可以双向通行。没有两座桥连接相同的一对塔。

一条从塔 $x$ 到塔 $y$ 的路径是一个满足以下条件的塔序列（塔的数目大于等于 $1$）：

- 序列的第一个元素是 $x$，
- 序列的最后一个元素是 $y$，
- 序列中所有元素互不相同，

序列中每两个相邻元素（塔）都是被某一座桥连接起来的。

注意根据定义，一个塔到它自己有且仅有一条路径，并且从塔 $i$ 到塔 $j$ 的不同路径的数目和从塔 $j$ 到塔 $i$ 的不同路径的数目是一样的。

负责该项设计的首席设计师希望待建造的桥梁要符合：任意给定 $0 \le i,j \le n-1$，恰好有 $p[i][j]$ 条从塔 $i$ 到塔 $j$ 的不同路径，其中 $0 \le p[i][j] \le 3$。

请构造一个桥的集合来满足设计师的要求，或判定这样的桥梁集合不可能存在。

#### 实现细节

你需要实现下面的这个函数：

```cpp
int construct(std::vector<std::vector<int> > p)
```

- $p$：⼀个表示设计师要求的 $n \times n$ 数组。
- 如果这个建设方案是存在的，该函数应该恰好调用一次 `build`（见下文）来给出建设方案，然后应返回 $1$。
- 否则，该函数应该返回 $0$，并且不要调用 `build`。
- 该函数将被调用恰好一次。

函数 `build` 定义如下：

```cpp
void build(std::vector<std::vector<int> > b)
```
  
- $b$：一个 $n \times n$ 的数组，$b[i][j]=1$ 表示有一座桥连接塔 $i$ 和塔 $j$，否则 $b[i][j]=0$。
- 注意该数组必须满足：对所有 $0 \le i,j \le n-1$，$b[i][j]=b[j][i]$；并且对所有 $0 \le i \le n-1$，$b[i][i]=0$。
## 提示

#### 样例说明

#### 例 1

考虑以下调用：

```cpp
construct([[1, 1, 2, 2], [1, 1, 2, 2], [2, 2, 1, 2], [2, 2, 2, 1]])
```
  
这表明从塔 $0$ 到塔 $1$ 恰好有一条路径。对于所有其他的塔对 $(x,y)(0 \le x<y \le 3)$, 恰好有两条不同的路径连接塔 $x$ 和塔 $y$。这可以通过建设 $4$ 座桥来实现：连接塔对 $(0, 1), (1, 2), (1, 3)$ 和 $(2,3)$。

为了给出这个解决方案，函数 `construct` 应该做以下调用：

```cpp
build([[0, 1, 0, 0], [1, 0, 1, 1], [0, 1, 0, 1], [0, 1, 1, 0]])
  ```

![](https://cdn.luogu.com.cn/upload/image_hosting/lf8q5wrk.png)

函数应该返回 $1$。

对于这个例子，存在多种不同的建设方案来满足要求，所有这些方案都被认为是正确的。

#### 例 2

考虑以下调用：

```cpp
construct([[1, 0], [0, 1]])
```
  
  这表明无法在两个塔之间进行旅行。这只能通过不建设桥梁来满足。

因此，函数 `construct` 应该做以下调用：
```cpp
build([[0, 0], [0, 0]])
```
  然后，函数 `construct` 应该返回 $1$。
  
  #### 例 3
  
考虑以下调用：

```cpp
construct([[1, 3], [3, 1]])
```

这表明从塔 $0$ 到塔 $1$ 恰好有 $3$ 条路径。这些要求无法满足。因此，函数 `construct` 应该返回 $0$ 并且不要调用 `build`。

#### 约束条件

- $1\le n\le 1000$
- $p[i][i]=1$（对所有 $0 \le i \le n-1$）
- $p[i][j]=p[j][i]$（对所有 $0 \le i,j \le n-1$）
- $0 \le p[i][j] \le 3$（对所有 $0 \le i,j \le n-1$）

#### 子任务

1. （11 分）$p[i][j]=1$（对所有 $0 \le i,j \le n-1$）
2. （10 分）$p[i][j] \in \{0,1\}$（对所有 $0 \le i,j \le n-1$）
1. （19 分）$p[i][j] \in \{0,2\}$（对所有 $i \ne j,0 \le i,j \le n-1$）
1. （35 分）$0 \le p[i][j]\le 2$（对所有 $0 \le i,j \le n-1$）并且至少有一种建设方案满足要求
1. （21 分）$0 \le p[i][j] \le 2$（对所有 $0 \le i,j \le n-1$）
1. （4 分）没有额外约束条件

#### 评测程序示例

评测程序示例以如下格式读取输入数据：

第 $1$ 行：$n$       
第 $2+i$ 行（$0 \le i \le n+1$）：$p[i][0]\ p[i][1]\ \ldots\ p[i][n]$

评测程序示例的输出格式如下：

第 $1$ 行: `construct` 的返回值。

如果 `construct` 的返回值为 $1$，评测程序示例会额外打印：

第 $2+i$ 行（$0 \le i \le n+1$）：$b[i][0]\ b[i][1]\ \ldots\ b[i][n]$


---

---
title: "[IOI 2022] 数字电路"
layout: "post"
diff: 提高+/省选-
pid: P8493
tag: ['2022', 'IOI', '交互题']
---
# [IOI 2022] 数字电路
## 题目背景

**滥用评测资源者封号。**

**由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。**

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。

由于本题数据点过多，结合洛谷评测技术实现情况，本题将不按照题给 Subtask 评分。
## 题目描述

有一个数字电路，由编号为从 $0$ 到 $N + M - 1$ 的 $N + M$ 个**门**组成。其中，$0$ 到 $N - 1$ 号门是**阈值门**，而 $N$ 到 $N + M - 1$ 号门是**输入门**。

除 $0$ 号门之外的每个门都是恰好一个某阈值门的**输入**。具体来说，对于每个满足 $1 \le i \le N + M - 1$ 的 $i$，门 $i$ 是门 $P[i]$ 的一个输入，其中 $0 \le P[i] \le N-1$。重要的是，我们保证 $P[i] \lt i$ 成立。此外，我们假设有 $P[0] = -1$。每个阈值门有一个或多个的输入。输入门没有任何输入。

每个门都有一个**状态**，取 $0$ 或 $1$。输入门的初始状态由一个包含 $M$ 个整数的数组 $A$ 给定。也就是说，对于每个满足 $0 \le j \le M - 1$ 的 $j$ ，输入门 $N + j$ 的初始状态为 $A[j]$。

每个阈值门的状态取决于它的输入的状态，具体如下。首先，每个阈值门会被指定一个阈值**参数**。对于一个有 $c$ 个输入的阈值门，其所指定的参数必须是 $1$ 到 $c$ 之间的某个整数（包括 $1$ 和 $c$）。随后，对于一个参数为 $p$ 的阈值门，如果它的输入中至少有 $p$ 个门的状态为 $1$，则当前阈值门的状态为 $1$，否则状态为 $0$。

例如，假设有 $N = 3$ 个阈值门和 $M = 4$ 个输入门。其中，门 $0$ 的输入为门 $1$ 和门 $6$，门 $1$ 的输入为门 $2$、$4$ 和 $5$，门 $2$ 仅有的输入为门 $3$。

上述例子的说明可见下图。

![](https://arina.loli.net/2022/08/12/JtjqOi4HVBXeD3x.png)

假设输入门 $3$ 和 $5$ 的状态为 $1$，而门 $4$ 和 $6$ 的状态为 $0$。假设阈值门 $2$、$1$、$0$ 被指定的参数分别为 $1$、$2$、$2$。在这种情况下，门 $2$ 的状态为 $1$，门 $1$ 的状态为 $1$ ，门 $0$ 的状态为 $0$。下面给出了参数赋值以及状态的示意图。状态为 $1$ 的门被标记为黑色。

![](https://arina.loli.net/2022/08/12/Sdiye2vg3B1aYPu.png)

输入门的状态将会经历 $Q$ 次更新。每次更新用两个整数 $L$ 和 $R$ 来描述 ($N \le L \le R \le N + M - 1$) ，表示翻转所有编号在 $L$ 和 $R$ 之间（包括 $L$ 和 $R$）的输入门的状态。这就是说，对于所有满足 $L \le i \le R$ 的 $i$，输入门 $i$ 的状态如果为 $0$，则会被翻转为$1$；如果状态为 $1$，则会被翻转为 $0$。每个门被翻转后将会一直保持在新状态，直到在后续某次更新中被翻转。

你的目标是，计算每次更新后有多少种阈值门参数的赋值方案，使得门 $0$ 的状态为 $1$。当有至少一个阈值门的参数不同时，两种参数赋值方案被认为是不同的。由于方案数可能较大，你需要计算它对 $1\;000\;002\;022$ 取模的结果。

注意，在上面的例子中，共有 $6$ 种不同的对阈值门参数进行赋值的方案，因为门 $0$、$1$、$2$ 分别有 $2$、$3$、$1$ 个输入。在这 $6$ 种方案里面，有 $2$ 种参数赋值方案使得门 $0$ 的状态为 $1$。
## 输入格式

你的任务是实现下述两个函数。

```go
void init(int N, int M, int[] P, int[] A)
```

- $N$： 阈值门的数量。
- $M$：输入门的数量。
- $P$： 一个长度为 $N + M$ 的数组，给出阈值门的输入。
- $A$： 一个长度为 $M$的数组，给出输入门的初始状态。
- 这个函数被调用恰好一次，且发生在函数 `count_ways` 的所有调用之前。

```go
int count_ways(int L, int R)
```

- $L$, $R$：编号在 $L$ 和 $R$ 之间的输入门的状态将会被翻转。
- 这个函数应首先执行所规定的更新，然后返回使得门 $0$ 的状态为 $1$ 的参数赋值方案的方案数对 $1\;000\;002\;022$ 取模的结果。
- 这个函数会被调用恰好 $Q$ 次。
## 输出格式

考虑如下的函数调用序列：

```go
init(3, 4, [-1, 0, 1, 2, 1, 1, 0], [1, 0, 1, 0])
```

题面描述中已经给出了对这个例子的解释。

```go
count_ways(3, 4)
```

这次调用翻转了门 $3$ 和 $4$ 的状态，也就是说，门 $3$ 的状态变成 $0$，门 $4$ 的状态变成 $1$。下面给出了两种可行的参数赋值方案，可以使得门 $0$ 的状态为 $1$ 。

|               方案 $1$                |               方案 $2$                |
| :-----------------------------------: | :-----------------------------------: |
| ![](https://arina.loli.net/2022/08/12/azi4xDYOKpBnge6.png) | ![](https://arina.loli.net/2022/08/12/MBPhnOFyARSEQDH.png) |

在所有其他的参数赋值方案中，门 $0$ 的状态为 $0$。因此，函数应返回 $2$。

```go
count_ways(4, 5)
```

这次调用翻转了门 $4$ 和 $5$ 的状态。其结果是，所有输入门的状态均为 $0$，而且对于所有的参数赋值方案，门 $0$ 的状态均为 $0$。因此，函数应返回 $0$。

```go
count_ways(3, 6)
```

这次调用将所有输入门的状态置为 $1$。其结果是，对于所有参数赋值方案，门 $0$ 的状态均为 $1$。因此，函数应返回 $6$。
## 提示

### 约束条件

- $1 \le N, M \le 10^5$；
- $1 \le Q \le 10^5$；
- $P[0] = -1$；
- $0 \le P[i] \lt i$ 且 $P[i] \le N - 1$（对于所有满足 $1 \le i \le N + M - 1$ 的 $i$）；
- 每个阈值门至少有一个输入（对于所有满足 $0 \le i \le N - 1$ 的 $i$，存在某个下标 $x$ 满足 $i \lt x \le N + M - 1$ 且 $P[x] = i$）；
- $0 \le A[j] \le 1$（对于所有满足 $0 \le j \le M - 1$的 $j$）；
- $N \le L \le R \le N + M - 1$。

### 子任务

1. （2 分）$N = 1$，$M \le 1000$，$Q \le 5$；
2. （7 分）$N, M \le 1000$，$Q \le 5$，每个阈值门都有恰好两个输入；
3. （9 分）$N, M \le 1000$，$Q \le 5$；
4. （4 分）$M = N + 1$，$M = 2^z$（对于某个正整数 $z$）， $P[i] = \lfloor\frac{i - 1}{2}\rfloor$（对于所有满足 $1 \le i \le N + M - 1$ 的 $i$），$L = R$；
5. （12 分）$M = N + 1$，$M = 2^z$（对于某个正整数 $z$），$P[i] = \lfloor\frac{i - 1}{2}\rfloor$（对于所有满足$1 \le i \le N + M - 1$的 $i$）；
6. （27 分）每个阈值门都恰好有两个输入；
7. （28 分）$N, M \le 5000$；
8. （11 分）没有额外的约束条件。

### 评测程序示例

评测程序示例读取如下格式的输入：

- 第 $1$ 行： $N \; M \; Q$；
- 第 $2$ 行： $P[0] \; P[1] \; \ldots \; P[N + M - 1]$；
- 第 $3$ 行： $A[0] \; A[1] \; \ldots \; A[M - 1]$；
- 第 $4 + k$ 行（$0 \le k \le Q - 1$）： 第 $k$ 次更新对应的 $L \; R$。

评测程序示例按照如下格式打印你的答案：

- 第 $1 + k$ 行（$0 \le k \le Q - 1$）： `count_ways` 函数对第 $k$ 次更新的返回值。

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `bool` | `int` | `int[]`            |
| ------- | ------ | ------| ------------------ |
| `void ` | `bool` | `int` | `std::vector<int>` |

| `union(bool, int[])`                   | 数组 `a` 的长度 |
| -------------------------------------- | ------------------- |
| `std::variant<bool, std::vector<int>>` | `a.size()`          |

C++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。
一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。
以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：

```cpp
std::variant<bool, std::vector<int>> foo(int N) {
    return N % 2 == 0;
}

std::variant<bool, std::vector<int>> goo(int N) {
    return std::vector<int>(N, 0);
}

std::variant<bool, std::vector<int>> hoo(int N) {
    if (N % 2 == 0) {
        return false;
    }

    return std::vector<int>(N, 0);
}
```


---

---
title: "[IOI 2009] Mecho"
layout: "post"
diff: 提高+/省选-
pid: P9116
tag: ['2009', 'IOI', 'O2优化']
---
# [IOI 2009] Mecho
## 题目背景

IOI2009 D2T2
## 题目描述

小熊 Mecho 发现了一个宝藏 —— 蜜蜂的秘密蜜罐，里面装满了蜂蜜！他高兴地吃着他的新发现的宝藏，直到突然有一只蜜蜂看到了他，并发出了警报。他知道就在这个时刻，成群的蜜蜂会从蜂巢里出来，开始四处蔓延，试图抓住他。他知道他必须离开蜜罐，尽快回家，但蜂蜜太甜了， Mecho 不想太早离开。帮 Mecho 确定他最晚什么时候可以离开。

Mecho 所在的森林是 $N\times N$ 的正方形网格，其两侧平行于南北和东西方向。每个格子由一棵树、一小块草、一个蜂巢或 Mecho 的家占据。如果两个格子中的一个与另一个的北、南、东或西相邻（但不在对角线上），则认为这两个格子相邻。Mecho 是一只笨拙的熊，所以每次它走一步，都只能移动至相邻的格子。Mecho 只能在草地上行走，不能穿过树木或蜂巢，而且他每分钟最多能走 $S$ 步。

当蜜蜂警报响起的那一刻， Mecho 在装有蜜罐的草格子里，而蜜蜂则在每个包含蜂巢的格子里（森林里可能有不止一个蜂巢）。接下来的每一分钟内，以下事件按顺序发生:

1. 如果 Mecho 还在吃蜂蜜，他会决定是继续吃还是离开。如果它继续吃东西，就会一动不动。否则，他会立即离开，并像上面描述的那样移动至多 $S$ 步。 Mecho 不能带任何蜂蜜，所以一旦他移动了，他就不能再吃蜂蜜了。

2. 当 Mecho 吃完或移动了整整一分钟后，蜜蜂在网格中进一步扩散了一个单位，只移动到草格子中。具体地，蜂群扩散到每一个与任何已经有蜜蜂的格子相邻的草格子。此外，一旦一个格子有蜜蜂，它将永远有蜜蜂（也就是说，蜂群不移动，但它生长）。

换句话说，蜜蜂的分布如下：当蜜蜂警报响起时，蜜蜂只占据蜂巢所在的格子。在第一分钟结束时，它们占据了蜂巢附近所有长满草的格子（以及原本的所有蜂巢）。在第二分钟结束时，它们又占据了和 “与蜂巢相邻的草格子” 相邻的草格子，以此类推。只要有足够的时间，这些蜜蜂就会同时占据森林中它们能到达的所有草格子。

Mecho 和蜜蜂都不能走出森林。另外，根据上面的规则，Mecho 总是吃整数分钟的蜂蜜。

如果 Mecho 发现自己在一个被蜜蜂占据的格子里，蜜蜂就会抓住 Mecho。

**任务**：编写一个程序，给定一张森林地图，计算出  Mecho 可以在最初的位置继续吃蜂蜜的最长时间，同时还能在任何蜜蜂抓到他之前回到他的家。
## 输入格式

第一行包含两个由空格隔开的整数 $N, S$，分别表示地图大小和 Mecho 每分钟最多移动的步数。

接下来 $N$ 行描述了森林地图。其中每一行包含 $N$ 个字符，每个字符表示一个格子。可能的字符及其含义如下: 

- `T` 表示树。
- `G` 表示草格子。
- `M` 表示 Mecho 的初始位置，也是蜜罐的位置。这是一个草格子，蜜蜂可以进入。
- `D` 表示 Mecho 的家。Mecho 可以进入这个格子，但蜜蜂不可以。
- `H` 表示蜂巢。

**注意**：保证地图恰好包含一个字母 `M`，恰好一个字母 `D` 和至少一个字母 `H`。保证存在相邻的字母 `G` 形成的路径连接 Mecho 和它的家，以及相邻的字母 `G` 形成的路径连接蜜罐（即 Mecho 最初的位置）和至少一个蜂巢。这些序列可能长度为零，如 Mecho 的家或蜂巢和 Mecho 的初始位置相邻。另外，蜜蜂不能通过或飞过 Mecho 的家。对它们来说，Mecho 的家就像一棵树。
## 输出格式

输出一行一个整数，表示 Mecho 最多还能在初始位置吃多少分钟蜂蜜，并安全地回家。

如果 Mecho 不可能在蜜蜂抓住它之前回家，输出 $-1$。
## 样例

### 样例输入 #1
```
7 3
TTTTTTT
TGGGGGT
TGGGGGT
MGGGGGD
TGGGGGT
TGGGGGT
THHHHHT

```
### 样例输出 #1
```
1

```
### 样例输入 #2
```
7 3
TTTTTTT
TGGGGGT
TGGGGGT
MGGGGGD
TGGGGGT
TGGGGGT
TGHHGGT

```
### 样例输出 #2
```
2

```
## 提示

### 样例解释

- 样例 1：吃了一分钟蜂蜜后，Mecho 可以沿着最短的路径直接往右走，再过两分钟他就可以安全到家了。

- 样例 2：吃了两分钟蜂蜜后，Mecho 可以在第三分钟向右，向上，向右走；在第四分钟向右走三步；在第五分钟向下，向右走。

### 数据范围与约定

- 对于 $40\%$ 的数据，$N\leq 60$。
- 对于 $100\%$ 的数据，$1\leq N\leq 800$，$1\leq S\leq 1000$。

注意在实际评测中，部分分和以上描述有出入。


---


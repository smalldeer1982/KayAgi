---
title: "[NOIP 2003 提高组] 侦探推理"
layout: "post"
diff: 提高+/省选-
pid: P1039
tag: ['模拟', '字符串', '2003', '二分', 'NOIP 提高组', '枚举']
---
# [NOIP 2003 提高组] 侦探推理
## 题目描述

明明同学最近迷上了侦探漫画《柯南》并沉醉于推理游戏之中，于是他召集了一群同学玩推理游戏。游戏的内容是这样的，明明的同学们先商量好由其中的一个人充当罪犯（在明明不知情的情况下），明明的任务就是找出这个罪犯。接着，明明逐个询问每一个同学，被询问者可能会说：

$$
\def\arraystretch{1.5}
\begin{array}{|l|l|}\hline
\textbf{\textsf{证词内容}} & \textbf{\textsf{证词含义}}\\\hline
\text{I am guilty.} & \text{我是罪犯。} \\\hline
\text{I am not guilty.} & \text{我不是罪犯。} \\\hline
\text{{\tt XXX} is guilty.} & \text{{\tt XXX} 是罪犯。其中 {\tt XXX} 表示某个同学的名字。} \\\hline
\text{{\tt XXX} is not guilty.} & \text{{\tt XXX} 不是罪犯。} \\\hline
\text{Today is {\tt XXX}.} &
\begin{aligned}
&\text{今天是 {\tt XXX}。其中 {\tt XXX} 表示某个星期的单词。}\\
&\text{星期只有可能是以下之一：}\\
&\texttt{Monday}, \texttt{Tuesday}, \texttt{Wednesday}, \texttt{Thursday}, \\
&\texttt{Friday}, \texttt{Saturday}, \texttt{Sunday}。
\end{aligned}
\\\hline
\end{array}$$

证词中出现的其他话，都不列入逻辑推理的内容。


明明所知道的是，他的同学中有 $N$ 个人始终说假话，其余的人始终说真。


现在，明明需要你帮助他从他同学的话中推断出谁是真正的凶手，请记住，凶手只有一个！


## 输入格式

输入由若干行组成。

第一行有三个整数，$M,N$ 和 $P$。$M$ 是参加游戏的明明的同学数，$N$ 是其中始终说谎的人数，$P$ 是证言的总数。  
  
接下来 $M$ 行，每行是明明的一个同学的名字（英文字母组成，没有空格，全部大写）。

往后有 $P$ 行，每行开始是某个同学的名宇，紧跟着一个冒号和一个空格，后面是一句证词，符合前表中所列格式。证词每行不会超过 $250$ 个字符。

输入中不会出现连续的两个空格，而且每行开头和结尾也没有空格。

## 输出格式

如果你的程序能确定谁是罪犯，则输出他的名字；如果程序判断出不止一个人可能是罪犯，则输出 `Cannot Determine`；如果程序判断出没有人可能成为罪犯，则输出 `Impossible`。


## 样例

### 样例输入 #1
```
3 1 5
MIKE
CHARLES
KATE
MIKE: I am guilty.
MIKE: Today is Sunday.
CHARLES: MIKE is guilty.
KATE: I am guilty.
KATE: How are you??

```
### 样例输出 #1
```
MIKE

```
## 提示

对于 $100\%$ 数据，满足 $1\le M\le 20$，$0\le N\le M$，$1\le P\le 100$。

**【题目来源】**

NOIP 2003 提高组第二题


---

---
title: "[NOIP 2005 普及组] 循环"
layout: "post"
diff: 提高+/省选-
pid: P1050
tag: ['模拟', '字符串', '高精度', '递推', '2005', 'NOIP 普及组']
---
# [NOIP 2005 普及组] 循环
## 题目描述

乐乐是一个聪明而又勤奋好学的孩子。他总喜欢探求事物的规律。一天，他突然对数的正整数次幂产生了兴趣。


众所周知，$2$ 的正整数次幂最后一位数总是不断的在重复 $2,4,8,6,2,4,8,6…$ 我们说 $2$ 的正整数次幂最后一位的循环长度是 $4$（实际上 $4$ 的倍数都可以说是循环长度，但我们只考虑最小的循环长度）。类似的，其余的数字的正整数次幂最后一位数也有类似的循环现象：

$$
\def\arraystretch{1.5}
\begin{array}{c|c|c}\hline
\textbf{数字}& \textbf{循环} & \textbf{循环长度} \cr\hline\hline
2 & 2,4,8,6 & 4\cr\hline
3 & 3,9,7,1 & 4\cr\hline
4 & 4,6 & 2\cr\hline
5 & 5 &  1\cr\hline
6 & 6 & 1\cr\hline
7 & 7,9,3,1 & 4\cr\hline
8 & 8,4,2,6 & 4\cr\hline
9 & 9,1 & 2\cr\hline
\end{array}
$$

这时乐乐的问题就出来了：是不是只有最后一位才有这样的循环呢？对于一个整数 $n$ 的正整数次幂来说，它的后 $k$ 位是否会发生循环？如果循环的话，循环长度是多少呢？

注意：

1. 如果 $n$ 的某个正整数次幂的位数不足 $k$，那么不足的高位看做是 $0$。
2. 如果循环长度是 $L$，那么说明对于任意的正整数 $a$，$n$ 的 $a$ 次幂和 $a+L$ 次幂的最后 $k$ 位都相同。

## 输入格式

共一行，包含两个整数 $n$ 和 $k$。$n$ 和 $k$ 之间用一个空格隔开，表示要求 $n$ 的正整数次幂的最后 $k$ 位的循环长度。
## 输出格式

一个整数，表示循环长度。如果循环不存在，输出 $-1$。
## 样例

### 样例输入 #1
```
32 2
```
### 样例输出 #1
```
4
```
## 提示

**【数据范围】**

对于 $30 \%$ 的数据，满足 $k \le 4$；  
对于$100 \%$ 的数据，满足 $1 \le n < {10}^{100}$，$1 \le k \le 100$。

**【题目来源】**

NOIP 2005 普及组第四题


---

---
title: "[NOIP 2005 提高组] 等价表达式"
layout: "post"
diff: 提高+/省选-
pid: P1054
tag: ['模拟', '字符串', '2005', 'NOIP 提高组']
---
# [NOIP 2005 提高组] 等价表达式
## 题目描述

明明进了中学之后，学到了代数表达式。有一天，他碰到一个很麻烦的选择题。这个题目的题干中首先给出了一个代数表达式，然后列出了若干选项，每个选项也是一个代数表达式，题目的要求是判断选项中哪些代数表达式是和题干中的表达式等价的。

这个题目手算很麻烦，因为明明对计算机编程很感兴趣，所以他想是不是可以用计算机来解决这个问题。假设你是明明，能完成这个任务吗？

这个选择题中的每个表达式都满足下面的性质：

1. 表达式只可能包含一个变量 $\tt a$。
2. 表达式中出现的数都是正整数，而且都小于 $10000$。
3. 表达式中可以包括四种运算 `+`（加），`-`（减），`*`（乘），`^`（乘幂），以及小括号 `()`。小括号的优先级最高，其次是 `^`，然后是 `*`，最后是 `+` 和 `-`。`+` 和 `-` 的优先级是相同的。相同优先级的运算（**包括 `^` 运算**）都是**从左到右**进行。
4. 幂指数只可能是 $1$ 到 $10$ 之间的正整数（包括 $1$ 和 $10$）。
5. 表达式内部，头部或者尾部都可能有一些多余的空格。

下面是一些合理的表达式的例子：

`((a^1) ^ 2)^3`，`a*a+a-a`，`((a+a))`，`9999+(a-a)*a`，`1 + (a -1)^3`，`1^10^9`

## 输入格式

第一行给出的是题干中的表达式。

第二行是一个整数 $n$，表示选项的个数。后面$n$行，每行包括一个选项中的表达式。这 $n$ 个选项的标号分别是 $A,B,C,D\cdots $


输入中的表达式的长度都不超过 $50$ 个字符，而且保证选项中总有表达式和题干中的表达式是等价的。

## 输出格式

一行，包括一系列选项的标号，表示哪些选项是和题干中的表达式等价的。选项的标号按照字母顺序排列，而且之间没有空格。


## 样例

### 样例输入 #1
```
( a + 1) ^2
3
(a-1)^2+4*a
a + 1+ a
a^2 + 2 * a * 1 + 1^2 + 10 -10 +a -a

```
### 样例输出 #1
```
AC
```
## 提示

- 对于 $30\%$ 的数据，表达式中只可能出现两种运算符 `+` 和 `-`；
- 对于其它的数据，四种运算符 `+-*^` 在表达式中都可能出现。  
- 对于 $100\%$ 的数据，表达式中都可能出现小括号 `()`，$2 \le n \le  26$。

**【题目来源】**

NOIP 2005 提高组第四题


---

---
title: "BZOJ2372 music"
layout: "post"
diff: 提高+/省选-
pid: P10634
tag: ['字符串', 'O2优化', '哈希 hashing', 'KMP 算法']
---
# BZOJ2372 music
## 题目描述

最近 A、B 两国发生了一场战争。dick 作为 A 国的军事总指挥，最近非常头痛于己方的情报问题。因为 B 国最近雇佣了 Easy 这一位密码专家来给他们的所有通讯加密。

Easy 非常喜欢唱歌，于是他决定将所有的信号都变成旋律储存起来，比如说 $11556654433221$ 就可能是一段加过密的音符，我们用一个等长度的序列来表示它，就变成了 $1,1,5,5,6,6,\dots$。为了增加密码的保密性，他把加密的乐谱又调整了一下，把某些音调改变了，将原序列 $A$ 变成 $B$，有 $|A|=|B|$，且对于 $a_i=a_j$ 有 $b_i=b_j$，对于 $a_i<a_j$ 有 $b_i<b_j$，对于 $a_i>a_j$ 有 $b_i>b_j$。例如：`11221` 和 `55775` 就可能代表了同一段音符。

最近，dick 截获了一段信号，这段信号中可能包含了某些重要信息。根据以往的经验，dick 已经知道了某些旋律所代表的意义。于是 dick 想知道，对于一段已知的旋律，能不能判断它是否在这段截获的旋律中出现？如果出现了，能否找出它出现的次数及位置呢？

「任务」判断给定旋律在截获旋律中出现的次数及位置。
## 输入格式

第一行三个正整数 $n,m,s$，$n$ 是截获旋律的长度，$m$ 是已知旋律的长度，所有的旋律都是 $1\sim s(s\leq 25)$ 的正整数。

接下来 $n$ 行，每行一个整数描述截获的旋律 $A$；

接下来 $m$ 行，每行一个整数描述已知的旋律 $B$；
## 输出格式

第一行一个整数 $t$ 表示出现的次数。

然后 $t$ 行，按照从小到大给出出现时的起始位置 $p$，即：$A[p\dots p+m-1]$ 等价于 $B$。
## 样例

### 样例输入 #1
```
9 6 10
5
6
2
10
10
7
3
2
9
1
4
4
3
2
1
```
### 样例输出 #1
```
1
3
```
## 提示

对于所有数据，保证 $1\leq n \leq 10^5$，$1\leq m \leq 25000$。


---

---
title: "「KDOI-10」反回文串"
layout: "post"
diff: 提高+/省选-
pid: P11190
tag: ['字符串', '贪心', '2024', '洛谷原创', 'Special Judge', 'O2优化', '随机化', '构造', '洛谷月赛']
---
# 「KDOI-10」反回文串
## 题目背景

[English Statement](https://www.luogu.com.cn/problem/T519008). You must submit your code at the Chinese version of the statement.

**本场比赛所有题目从标准输入读入数据，输出到标准输出。**
## 题目描述

我们称一个长度为 $m$ 的字符串 $r$ 是回文的，当且仅当 $r_i=r_{m+1-i}$ 对所有 $1\le i\le m$ 均成立。

给定一个长度为 $n$ 的字符串 $s$，你需要把 $s$ 分成若干个非空子序列，使得每一个子序列都**不是**回文的，并最大化划分成的子序列数。

形式化地说，你需要给出一组序列 $(a_1,a_2,\ldots,a_k)$，满足：

- 对于任意 $1\le i\le k$，记 $l_i$ 为 $a_i$ 的长度，则 $l_i\ge 1$，且 $1\le a_{i,1}<a_{i,2}<\cdots<a_{i,l_i}\le n$；
- 对于任意 $1\le i\le n$，恰好存在一个二元组 $(p,q)$，使得 $a_{p,q}=i$；
- 对于任意 $1\le i\le k$，记字符串 $t=s_{a_{i,1}}s_{a_{i,2}}\ldots s_{a_{i,l_i}}$，则 $t$ 不是回文的。

在此基础上，你需要最大化 $k$ 的值；或者判断不存在一种合法的方案。

特别地，如果 $k$ 的值不是最大的，你也可能获得一定的部分分。

## 输入格式

从标准输入读入数据。

**本题有多组测试数据。** 

输入的第一行包含一个正整数 $c$，表示测试点编号。$c=0$ 表示该测试点为样例。

第二行包含一个正整数 $q$，表示测试数据组数。

对于每组测试数据：

- 第一行包含一个正整数 $n$，表示字符串 $s$ 的长度；
- 第二行包含一个长度为 $n$ 的字符串 $s$。保证 $s$ 中仅包含小写英文字母。
## 输出格式

输出到标准输出。

对于每组测试数据：

- 如果不存在一种合法的方案，输出一行一个字符串 `Shuiniao`；
- 否则，你需要：
  - 在第一行输出一个字符串 `Huoyu`；
  - 第二行输出一个正整数 $k$ $(1\le k\le n)$，表示你划分成的子序列个数；
  - 接下来 $k$ 行，对于第 $i$ 行 $(1\le i\le k)$：
    - 首先输出一个正整数 $l_i$ $(1\le l_i\le n)$，表示第 $i$ 个子序列的长度；
    - 接下来输出 $l_i$ 个正整数 $a_{i,1},a_{i,2},\ldots, a_{i,l_i}$ $(1\le a_{i,j}\le n)$，表示第 $i$ 个子序列。

请注意，你的输出需要满足题目描述中所有的限制，否则，你将会得到 $0$ 分。
## 样例

### 样例输入 #1
```
0
4
4
kdoi
7
ccccccc
7
sszcdjr
7
abacaca
```
### 样例输出 #1
```
Huoyu
2
2 1 2
2 3 4
Shuiniao
Huoyu
3
3 1 2 3
2 4 5
2 6 7
Huoyu
3
2 1 4
3 2 3 5
2 6 7

```
## 提示

**【样例 1 解释】**

对于第一组测试数据，显然输出构成一个合法的子序列划分，并且

- 对于第一个子序列，$t=\tt{kd}$ 不是回文的；
- 对于第二个子序列，$t=\tt{oi}$ 不是回文的。

故这是一组合法的输出。可以证明，对于这组测试数据，$2$ 是 $k$ 的最大可能值。

对于第二组数据，它的任意一个子序列都是回文的， 故显然不存在合法的划分方案。

**【样例 2】**

见选手目录下的 `anti/anti2.in` 与 `anti/anti2.ans`。

这个样例共有 $10$ 组数据，均满足 $n=1\,000$。其中第 $1\sim 3$ 组数据满足特殊性质 A，第 $4\sim 6$ 组数据满足特殊性质 B。

***

**【评分方式】**

本题共有 $20$ 个测试点，每个测试点满分 $5$ 分。

本题采用自定义校验器（special judge）评测。每组测试数据可能有多组解，你只需要给出**任意**一组。

在每个测试点中，你的得分是在所有测试数据上得分的最小值。对于每组测试数据：

- 如果你错误地判断了是否有解或者给出了一组不合法的序列，你将会获得 $0$ 分；
- 如果你正确判断了是否有解，并在有解时给出了一组合法的序列：
  - 如果 $k$ 的值不是最大的，你将会获得 $2$ 分；
  - 如果 $k$ 的值是最大的，你将会获得 $5$ 分。
  
***

**【数据范围】**

对于全部的测试数据，保证：

- $1\le q\le 10$；
- $1\le n\le 10^5$；
- $s$ 中仅包含小写英文字母。

|测试点|$n\le$|特殊性质|
|:--:|:--:|:--:|
|$1,2$|$5$|无|
|$3\sim 5$|$18$|无|
|$6\sim 8$|$1\,000$|B|
|$9\sim 11$|$1\,000$|无|
|$12\sim 14$|$10^5$|A|
|$15\sim 17$|$10^5$|B|
|$18\sim 20$|$10^5$|无|

- 特殊性质 A：保证 $n$ 是偶数，且 $s$ 中每个字符的出现次数都不超过 $\frac{n}{2}$；
- 特殊性质 B：保证 $s$ 中仅有 `a` 和 `b`。

***

**【如何使用校验器】**

为了方便选手测试，在附件的 `anti` 目录下我们下发了 `checker.cpp` 文件作为样例校验器，选手可以编译该程序，并使用它校验自己的输出文件的结果是否**合法**。但请注意它与最终评测时所使用的校验器并不完全一致。你也不需要关心其代码的具体内容。

编译命令为：

```sh
g++ -o checker -std=c++14 -O2 checker.cpp
```

`checker` 的使用方式为：

```sh
checker <input-file> <output-file>
```

其中，参数 ` <input-file>` 与 `<output-file>` 依次表示输入文件与你的输出文件。

若你的输出中的数字大小范围不合法，则校验器会给出相应提示并立即退出。否则，校验器输出以下内容：

- 在第 $i$ 行 $(1\le i\le q)$ 中，输出第 $i$ 组测试数据的详细提示信息；
- 在第 $(q+1)$ 行，输出这个测试点的总结信息。

例如，对于样例 1 的输入与输出，校验器将会向屏幕打印如下内容：

```plain
Test case 1: OK. Participant's answer is YES (Huoyu), and k=2.
Test case 2: OK. Participant's answer is NO (Shuiniao).
Test case 3: OK. Participant's answer is YES (Huoyu), and k=3.
Test case 4: OK. Participant's answer is YES (Huoyu), and k=3.
ok 4 / 4 test cases passed. (4 test cases)
```

若将输出改为如下：

```plain
Huoyu
2
2 1 2
2 3 4
Huoyu
1
7 1 2 3 4 5 6 7
Huoyu
3
3 1 2 3
2 4 5
2 6 7
Huoyu
3
2 1 4
3 2 3 5
2 6 7
```

则会向屏幕打印如下内容：

```plain
Test case 1: OK. Participant's answer is YES (Huoyu), and k=2.
Test case 2: Wrong answer. The string t obtained in the subsequence a[1] is palindrome.
Test case 3: OK. Participant's answer is YES (Huoyu), and k=3.
Test case 4: OK. Participant's answer is YES (Huoyu), and k=3.
wrong answer 3 / 4 test cases passed.
```

**请注意：** 样例校验器只会检查你的输出是否合法，而**不会**：

- 检查有解性是否判断正确；
- 检查 $k$ 是否被最大化。

例如，将样例 1 的输出改为如下：

```plain
Shuiniao
Shuiniao
Shuiniao
Shuiniao
```

此时，样例校验器仍会返回 `ok` 的检查结果。



---

---
title: "泪雨 Namid[A]me"
layout: "post"
diff: 提高+/省选-
pid: P12977
tag: ['字符串', 'Manacher 算法']
---
# 泪雨 Namid[A]me
## 题目背景

> 涙目 変わらずの雨模様\
泪眼不变的烟雨迷蒙\
その夢の淵ギリギリで\
在那梦的深渊倾盆而下\
—— ヒトリエ《Namid[A]me》

最终，只剩我一人了。
## 题目描述

给定小写英文字母和 ```?``` 组成的字符串 $s$。

“泪雨”定义为这样的串：这是一个回文串，并且 ```?``` 的个数大于等于小写英文字符的个数。

请对于是“泪雨”的 $s$ 的所有子串，求出它们问号位置的和之和。（位置下标从 $1$ 开始）

**形式化题意**：定义：
$$
f(l,r)=
\sum_{i=l}^{r} [s_i=\texttt{?}]\cdot i
\\
g(l,r)=\big[\sum_{i=l}^r{[s_i=\texttt{?}] \geq} \frac{r-l+1}{2}\big]\big[ s[l,r]\text{ is a palindrome} \big]
$$

请你求出 $\sum_{l=1}^{n} \sum_{r=l}^{n} g(l,r)\cdot f(l,r)$，其中 $n=\lvert s\rvert$。
## 输入格式

第一行一个正整数 $n$，表示 $s$ 的长度 $n$。

第二行输入仅由小写英文字母和问号组成的字符串 $s$。
## 输出格式

一行一个正整数，表示答案。
## 样例

### 样例输入 #1
```
4
a??a
```
### 样例输出 #1
```
15

```
### 样例输入 #2
```
10
?a?aa?a?a?
```
### 样例输出 #2
```
115
```
## 提示

**样例解释：** 样例 $1$ 中，$[2,2],[3,3],[1,4],[2,3]$ 都是符合要求的回文串，并且所求的问号位置之和为 $2+3+(2+3)+(2+3)=15$。

以下是数据范围。

| Subtask | $n$ | 特殊性质 | 分值 | 子任务依赖 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 500$ | 无 | $10$ | - |
| $2$ | $\leq 7000$ | 无 | $15$ | $1$ |
| $3$ | $\leq 2\times 10^6$ | $s$ 中仅有 ```?``` | $5$ | - |
| $4$ | $\leq 2\times 10^6$ | 字符串随机生成 | $10$ | $1$ |
| $5$ | $\leq 2\times 10^6$ | $s$ 中有且仅有两种字符 | $10$ | - |
| $6$ | $\leq 3\times 10^5$ | 无 | $15$ | $1,2$ |
| $7$ | $\leq2\times 10^6$ | 无 | $15$ | $1\sim 6$ |
| $8$ | $\leq 5\times10^6$ | $\text{timelimit}=1.5s$ | $20$ | $1\sim 7$ |

对于 $100\%$ 的数据满足 $1\leq n\leq 5\times 10^6$，且 $s$ 仅包含小写英文字母和 ```?```。

除了 $\text{subtask 8}$ 之外，时限皆为 $1s$。

时间限制已开到了 std 的 2 倍以上，空间限制开到了 std 的 1.25 倍以上，但仍需 **注意程序的运行时空常数**。


---

---
title: "【模板】最小表示法"
layout: "post"
diff: 提高+/省选-
pid: P13270
tag: ['字符串']
---
# 【模板】最小表示法
## 题目背景

原模板题：[P1368 工艺](https://www.luogu.com.cn/problem/P1368)。
## 题目描述

若长度为 $n$ 的字符串 $s$ 中可以选择一个位置 $i$，使得 $\overline{s_i\cdots s_ns_1\cdots s_{i-1}}=t$，则称 $s$ 与 $t$ **循环同构**。字符串 $s$ 的**最小表示**为与 $s$ 循环同构的所有字符串中字典序最小的字符串。

给定一个长度为 $n$ 的字符串 $s$，请求出 $s$ 的最小表示。
## 输入格式

第一行一个整数 $n$。

第二行一个长度为 $n$ 的字符串 $s$。
## 输出格式

一行，一个字符串，为 $s$ 的最小表示。
## 样例

### 样例输入 #1
```
10
caacabcaab
```
### 样例输出 #1
```
aabcaacabc
```
## 提示

对于全部数据，$1\le n\le 10^7$，字符串 $s$ 仅包含小写英文字母（ASCII $97\sim 122$）。

设置以下三档部分分，用于测试不同解法：

- 对于 $20\%$ 的数据，$n\le 10^3$；
- 对于 $50\%$ 的数据，$n\le 10^5$；
- 对于 $100\%$ 的数据，无特殊限制。


---

---
title: "【模板】最小表示法"
layout: "post"
diff: 提高+/省选-
pid: P1368
tag: ['字符串', '后缀自动机 SAM']
---
# 【模板】最小表示法
## 题目描述

小敏和小燕是一对好朋友。

他们正在玩一种神奇的游戏，叫 Minecraft。

他们现在要做一个由方块构成的长条工艺品。但是方块现在是乱的，而且由于机器的要求，他们只能做到把这个工艺品最左边的方块放到最右边。

他们想，在仅这一个操作下，最漂亮的工艺品能多漂亮。

两个工艺品美观的比较方法是，从头开始比较，如果第 $i$ 个位置上方块不一样那么谁的瑕疵度小，那么谁就更漂亮，如果一样那么继续比较第 $i+1$ 个方块。如果全都一样，那么这两个工艺品就一样漂亮。
## 输入格式

第一行一个整数 $n$，代表方块的数目。

第二行 $n$ 个整数，每个整数按从左到右的顺序输出方块瑕疵度的值，保证其小于 $30$。
## 输出格式

一行 $n$ 个整数，代表最美观工艺品从左到右瑕疵度的值。
## 样例

### 样例输入 #1
```
10
10 9 8 7 6 5 4 3 2 1

```
### 样例输出 #1
```
1 10 9 8 7 6 5 4 3 2

```
## 提示

- 对于 $20\%$ 的数据，$n\le 1000$；
- 对于 $40\%$ 的数据，$n\le 10^4$；
- 对于 $100\%$ 的数据，$n\le 3\times 10^5$。


---

---
title: "[SDOI2006] 数字串位置 / 超长数字串"
layout: "post"
diff: 提高+/省选-
pid: P1511
tag: ['字符串', '数学', '2006', '各省省选', '山东', '枚举']
---
# [SDOI2006] 数字串位置 / 超长数字串
## 题目背景

George 很喜欢数学，尤其是算数数系列。
## 题目描述

他最喜欢的是数字的无穷序列，结果是把所有的自然数按升序排列。这个序列开始是：$\texttt{1234567891011121314...}$

我们称这个序列为序列 $S$，然后 $S_1 = 1$, $S_2 = 2$, ... , $S_{10} = 1$, $S_{11} = 0$，依此类推.

George 现有一个数字序列 $A$ ，他想知道这个序列在 $S$ 中最早出现的位置。请你帮助他解决这个问题。
## 输入格式

输入一个字符串，表示数字序列 $A$ ，位数不超过 $200$，中间没有空格。

## 输出格式

输出使 $A_1 = S_k, A_2 = S_{k+1}, ...,A_{len_{A}} = S_{k + len(A)-1}$ 成立的最小正整数 $k$，其中 $len_{A}$ 表示序列 $A$ 的长度。

## 样例

### 样例输入 #1
```
101


```
### 样例输出 #1
```
10


```
## 提示

来源 Source

Ural State University Problem Archive

 


---

---
title: "Sramoc问题"
layout: "post"
diff: 提高+/省选-
pid: P1602
tag: ['字符串', '搜索', '数学', '队列']
---
# Sramoc问题
## 题目描述

话说员工们整理好了筷子之后，就准备将快餐送出了，但是一看订单，都傻眼了:订单上没有留电话号码,只写了一个  $sramoc(k,m)$ 函数，这什么东西？什么意思？于是餐厅找来了资深顾问团的成员，YQ，SC，HQ，经过大量的查阅，大家获得了一些信息，$sramoc(k,m)$ 表示用数字 $0,1,2,\dots k-1$ 组成的正整数中能被 $m$ 整除的最小数。例如 $k=2,m=7$ 的时候，$sramoc(2,7)=1001$。自然电话号码就是 $1001$，为了尽快将快餐送出，电脑组的童鞋们埋头算起了这个齐葩的号码。。。
## 输入格式

第 $1$ 行为两个整数 $k,m$。
## 输出格式

仅 $1$ 行，那个电话号码（最小的数）。
## 样例

### 样例输入 #1
```
2 7

```
### 样例输出 #1
```
1001
```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，$2\le k\le10$，$1\le m\le 10^3$。


---

---
title: "[国家集训队] 拉拉队排练"
layout: "post"
diff: 提高+/省选-
pid: P1659
tag: ['字符串', '集训队互测', '前缀和', 'Manacher 算法']
---
# [国家集训队] 拉拉队排练
## 题目描述

艾利斯顿商学院篮球队要参加一年一度的市篮球比赛了。拉拉队是篮球比赛的一个看点，好的拉拉队往往能帮助球队增加士气，赢得最终的比赛。所以作为拉拉队队长的楚雨荨同学知道，帮助篮球队训练好拉拉队有多么的重要。

拉拉队的选拔工作已经结束，在雨荨和校长的挑选下，$n$ 位集优秀的身材、舞技于一体的美女从众多报名的女生中脱颖而出。这些女生将随着篮球队的小伙子们一起，和对手抗衡，为艾利斯顿篮球队加油助威。

一个阳光明媚的早晨，雨荨带领拉拉队的队员们开始了排练。$n$ 个女生从左到右排成一行，每个人手中都举了一个写有 $26$ 个小写字母中的某一个的牌子，在比赛的时候挥舞，为小伙子们呐喊、加油。

雨荨发现，如果连续的一段女生，有奇数个，并且他们手中的牌子所写的字母，从左到右和从右到左读起来一样，那么这一段女生就被称作和谐小群体。

现在雨荨想找出所有和谐小群体，并且按照女生的个数降序排序之后，前 $K$ 个和谐小群体的女生个数的乘积是多少。由于答案可能很大，雨荨只要你告诉她，答案除以 $19930726$ 的余数是多少就行了。
## 输入格式

第一行为两个正整数 $n$ 和 $K$，含义如题面所述。

接下来一行为 $n$ 个字符，代表从左到右女生拿的牌子上写的字母。
## 输出格式

输出一个整数，代表题目描述中所写的乘积除以 $19930726$ 的余数，如果总的和谐小群体个数小于 $K$，输出一个整数 $-1$。
## 样例

### 样例输入 #1
```
5 3
ababa
```
### 样例输出 #1
```
45

```
## 提示

### 样例说明

和谐小群体女生所拿牌子上写的字母从左到右按照女生个数降序排序后为 `ababa`，`aba`，`aba`，`bab`，`a`，`a`，`a`，`b`，`b`，前三个长度的乘积为 $5\times 3\times 3 = 45$。


### 数据范围与约定


测试点 | $n$ | $K$
-----|---------|---
1    | $10$ | $10$
2-3  | $100$ | $100$
4-7  | $1,000$ | $1,000$
8    | $100,000$ | $= 1$
9-11 | $100,000$ | $100,000$
12-14| $100,000$ | $1,000,000,000,000$
15-17| $500,000$ | $1,000,000,000,000$
18   | $1,000,000$ | $= 1$
19   | $1,000,000$ | $1,000,000$
20   | $1,000,000$ | $1,000,000,000,000$


---

---
title: "[USACO5.5] 隐藏口令 Hidden Password"
layout: "post"
diff: 提高+/省选-
pid: P1709
tag: ['字符串', '贪心', 'USACO']
---
# [USACO5.5] 隐藏口令 Hidden Password
## 题目描述

有时候程序员有很奇怪的方法来隐藏他们的口令。Binny 会选择一个字符串 $S$（由 $N$ 个小写字母组成，$5 \le N \le 5 \times {10}^6$），然后他把 $S$ 顺时针绕成一个圈，每次取一个做开头字母并顺时针依次取字母而组成一个字符串。这样将得到一些字符串，他把它们排序后取出第一个字符串。把这个字符串的第一个字母在原字符串中的位置减 $1$ 做为口令。

如字符串 `alabala`，按操作的到 $7$ 个字符串，排序后得：

`aalabal`

`abalaal`  
`alaalab`  
`alabala`  
`balaala`  
`laalaba`  
`labalaa`

第一个字符串为 `aalabal`，这个 `a` 在原字符串位置为 $7$，$7-1=6$，则 $6$ 为口令。

## 输入格式

第一行：一个数：$N$

第二行开始：字符串：$S$（每 $72$ 个字符一个换行符）

## 输出格式

一行，为得到的口令

## 样例

### 样例输入 #1
```
7
anabana

```
### 样例输出 #1
```
6
```
## 提示

题目满足：

$30 \%$ 的数据 $n \le {10}^4$。  
$70 \%$ 的数据 $n \le {10}^5$。  
$100 \%$ 的数据 $1 \le n \le 5 \times {10}^6$。

时限 1s

题目翻译来自NOCOW。

USACO Training Section 5.5

// 20170523 新增数据四组



---

---
title: "高手过愚人节"
layout: "post"
diff: 提高+/省选-
pid: P1723
tag: ['字符串', '洛谷原创', 'Manacher 算法']
---
# 高手过愚人节
## 题目背景

高手组织大家过愚人节、联欢会要打出一些横幅。高手想表现得文艺一点，于是他就用一些普通人看不懂的乱码作为横幅内容。但是在这个时候，他也想让横幅更美观。

## 题目描述

现在给出 $n$ 个著名的乱七八糟的乱码，高手要知道每条乱码的最美观连续子序列的长度，在高手的心目中，只有回文串才是美观的。这代表着他纯洁的爱情，又有着回环往复的美，最重要的是，对于转回了一年级的高手来说，想要求出这个太难了，因此他找到了你。（OIer 无所不能！）

## 输入格式

第一行一个整数 $n$。

接下来 $n$ 行每行一条乱码。
## 输出格式

$n$ 行，每行为对应乱码的最美观子串的长度，即最长回文子串长（但是由于高手听不懂，我们不会这样说）。
## 样例

### 样例输入 #1
```
1

aaaaa
```
### 样例输出 #1
```
5
```
## 提示

### 数据范围及约定

对于全部数据，$1\le n\le 10$，$1\le |s_i|\le 10^7$。


---

---
title: "Diamond A&B(2)"
layout: "post"
diff: 提高+/省选-
pid: P1741
tag: ['模拟', '字符串']
---
# Diamond A&B(2)
## 题目背景

由于本题较难，将本题拆做两题，分别为 diamond A 以及 diamond B。本题为 Diamond B。


## 题目描述

教主上电视了！这个消息绝对是一个爆炸性的新闻。一经传开，大街上瞬间就没人了（都回家看电视去了），商店打烊，工厂停业。大家都把电视机的音量开到最大，教主的声音回响在大街小巷。

小 L 给小 X 慌乱地打开自己家的电视机，发现所有频道都播放的是教主的采访节目（-\_-bbb）。只见电视屏幕上的教主笑意吟吟，给大家出了一道难题：

一个边长为 $n$ 的大菱形被均匀地划分成了 $n\times n$ 个边长为 $1$ 的小菱形组成的网格，但是网格中部分边被抹去了，小 $L$ 想知道，大菱形内有多少个平行四边形，这些平行四边形内不存在边（平行四边形内是空的）。

教主说，如果谁写出了程序，移动用户请将程序发送到 xxxx，联通用户请将程序发送到 xxxx……如果答对这个题，将有机会参加抽奖，大奖将是教主签名的 Orz 教主 T-Shirt 一件！这个奖品太具有诱惑力了。于是你需要编一个程序完成这么一道题。

## 输入格式

输入的第一行为一个正整数 $n$，为大菱形的边长。

以下 $2n$ 行，每行 $2n$ 个字符，字符为空格，$\verb!/!$，$\verb!\!$ 中的一个。

前 $n$ 行，第 $i$ 行中居中有 $2i$ 个字符，这 $2i$ 个字符中位置为奇数的字符只可能为 $\verb!/!$ 或者空格，位置为偶数的字符只可能为 $\verb!\!$ 或空格，若为空格表示这样一条边不存在，其余字符均为空格，描述了大菱形的上半部分。

后 $n$ 行，第 $i$ 行居中有有 $2(n-i+1)$ 个字符，与上半部分类似地描述了菱形的下半部分。

输入文件保证大菱形的轮廓上没有边被抹去。
## 输出格式

输出仅包括一个整数，为满足要求的平行四边形个数。

## 样例

### 样例输入 #1
```
4

1111

11101

1000

10111

1100

10101

0111

11101

1111


```
### 样例输出 #1
```
3
```
## 提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$n \le 10$；
- 对于 $40\%$ 的数据，$n \le 60$；
- 对于 $60\%$ 的数据，$n \le 200$；
- 对于 $100\%$ 的数据，$n \le 888$。


---

---
title: "[NOI2009] 管道取珠"
layout: "post"
diff: 提高+/省选-
pid: P1758
tag: ['字符串', '动态规划 DP', '递推', '2009', 'NOI']
---
# [NOI2009] 管道取珠
## 题目描述

管道取珠是小 X 很喜欢的一款游戏。在本题中，我们将考虑该游戏的一个简单改版。游戏画面如图 1 所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/7p4r2ip9.png)

游戏初始时，左侧上下两个管道分别有一定数量的小球（有深色球和浅色球两种类型），而右侧输出管道为空。每一次操作，可以从左侧选择一个管道，并将该管道中最右侧的球推入右边输出管道。

例如：我们首先从下管道中移一个球到输出管道中，将得到图 2 所示的情况。

![](https://cdn.luogu.com.cn/upload/image_hosting/xj1kay44.png)

假设上管道中有 $n$ 个球, 下管道中有 $m$ 个球，则整个游戏过程需要进行 $n+m$ 次操作，即将所有左侧管道中的球移入输出管道。最终 $n+m$ 个球在输出管道中从右到左形成输出序列。

爱好数学的小 X 知道，他共有 $\dbinom{n+m}{m}$ 种不同的操作方式，而不同的操作方式可能导致相同的输出序列。举个例子，对于图 3 所示的游戏情形：

![](https://cdn.luogu.com.cn/upload/image_hosting/0m1t5d3h.png)

我们用 A 表示浅色球，B 表示深色球。并设移动上管道右侧球的操作为 U，移动下管道右侧球的操作为 D，则共有 $\binom{2+1}{1}=3$ 种不同的操作方式，分别为 UUD，UDU，DUU；最终在输出管道中形成的输出序列（从右到左）分别为 BAB，BBA，BBA。可以发现后两种操作方式将得到同样的输出序列。

假设最终可能产生的不同种类的输出序列共有 $K$ 种，其中：第 $i$ 种输出序列的产生方式（即不同的操作方式数目）有 $a_i$ 个。聪明的小 X 早已知道，

$$
\sum a_i=\binom{n+m}{m}
$$

因此，小 X 希望计算得到：

$$
\sum a_i^2
$$

你能帮助他计算这个值么？由于这个值可能很大，因此只需要输出该值对 $1024523$ 取模后的结果。

## 输入格式

输入文件中的第一行为两个整数 $n,m$，分别表示上下两个管道中球的数目。

第二行中为一个长度为 $n$ 的字符串，表示上管道中从左到右球的类型。其中：A 表示浅色球，B 表示深色球。

第三行中为一个长度为 $m$ 的字符串，表示下管道中从左到右球的类型。

保证两个字符串都只包含 A,B 两个字母。
## 输出格式

输出一个整数，即为 $\sum a_i^2$ 对 $1024523$ 取模的结果。

## 样例

### 样例输入 #1
```
2 1
AB
B

```
### 样例输出 #1
```
5
```
## 提示

### 样例解释

样例对应图 3。

共有两种不同的输出序列形式，序列 BAB 有 $1$ 种产生方式，而序列 BBA 有 $2$ 种产生方式，因此答案为 $5$。

### 数据范围

- 对于 $30\%$ 的数据，满足 $m,n \leq 12$；
- 对于 $100\%$ 的数据，满足 $1 \leq m,n \leq 500$。


---

---
title: "遥控车"
layout: "post"
diff: 提高+/省选-
pid: P2030
tag: ['字符串', '高精度', '递推', '二分']
---
# 遥控车
## 题目描述

平平带着韵韵来到了游乐园，看到了 $n$ 辆漂亮的遥控车，每辆车上都有一个唯一的名字 name[i]。韵韵早就迫不及待地想玩名字是 $s$ 的遥控车。可是韵韵毕竟还小，她想象的名字可能是一辆车名字的前缀（也就是说能确定一个 $i$，使 $s$ 是 name[i] 的前缀），这时她就能玩第 $i$ 辆车；或者是一个无中生有的名字，即 $s$ 不是任何一辆车名字的前缀，这时候她什么也不能玩。

你需要完成下面的任务：

1. 韵韵想了 $m$ 个她想要的名字，请告诉她能玩多少次。

2. 由于管理员粗心的操作，导致每辆车的摆放位置都可能出现微小的差错，原来第 $i$ 辆车现在的位置可能是 $i-1$ 、 $i$ 、 $i+1$ 中的任意一个（第 $1$ 辆车的位置不可能是 $0$，第 $n$ 辆车的位置不可能是 $n+1$）。请你计算出共有多少种可能的排列。

注：数据保证当 $s$ 是 name[i] 的前缀时，$i$ 是唯一确定的。一辆车可以玩多次。
## 输入格式

第一行是 $2$ 个正整数 $n$ 、 $m$。

接下来 $n$ 行，每行 $1$ 个字符串 name[i]，表示第 $i$ 辆车的名字。接下来 $m$ 行，每行 $1$ 个字符串 $s$，表示韵韵想要的名字。
## 输出格式

第一行输出韵韵能玩的次数。第二行输出共有多少种可能的排列。

## 样例

### 样例输入 #1
```
4 4
Abcd
DeF
AAa
aBccc
Ab
AA
AbC
aBcc
```
### 样例输出 #1
```
3
5

```
## 提示

【注意】

对于题目涉及到的字符串严格区分大小写，且长度小于 $255$。

【数据范围】

对于 $20\%$ 的数据 $n \le 10,m \le 10$；

对于 $40\%$ 的数据 $n \le 1000$，$m \le 1000$；

对于 $100\%$ 的数据 $n \le 10000$，$m \le 10000$。


---

---
title: "凌乱的地下室"
layout: "post"
diff: 提高+/省选-
pid: P2100
tag: ['字符串', '高精度', '矩阵运算']
---
# 凌乱的地下室
## 题目描述

小Z家的地下室里并排放n个小方块（小Z是一位MC狂热爱好者，喜欢用小方块装饰他家的地下室），并且每个方块都不一样（小Z喜欢各不相同的东西），比如有草方块、大理石、黑曜石等。

小Z喜欢以一种特殊的顺序摆放这些小方块，比如：草方块、大理石、黑曜石。一天，小D帮助小Z整理地下室，可是智商捉急的小D将所有小方块搬出来后忘记了它们原来的具体位置，凭着模糊的印象，他可能把原来放在第i个位置上的小方块放到第（i-1）、i、（i+1）个位置中的任意一个上（当然，第1个不可能放到第0个位置上，第n个不可能放到第（n+1）个位置上），比如（对应上面那个例子）：大理石、草方块、黑曜石。

小Z是一个心胸宽广的人，他希望计算一下小D一共会有几种可能的摆放结果，并不追究小D的责任（追究了只会更乱……）。由于他自己的智商也比较捉急，所以如果答案很大的话他只想看到最后的8位（前导零就不要给他看了）。

## 输入格式

一行，一个正整数n，代表小Z家的地下室一共有n个小方块。

## 输出格式

一行，一个正整数，表示小D一共有几种可能的摆放结果，只输出后8位，前导零不输出。

## 样例

### 样例输入 #1
```
3
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
987
```
### 样例输出 #2
```
223731
```
## 提示

【样例解释1】

接着题目中的例子，一共有3种：（草方块，大理石，黑曜石）、（大理石，草方块，黑曜石）、（草方块，黑曜石，大理石）。

【样例解释2】

一共有……00223731种摆放结果，由于前导零不输出，因此输出223731。

【数据规模】

一共有50个测试点。

其中第1~15个：1<n<=10^6

其中第16~25个：10^6<n<=10^16

其中第26~50个：10^16<n<=10^1000

【时空限制】

0.2s/64MB



---

---
title: "地砖铺设"
layout: "post"
diff: 提高+/省选-
pid: P2102
tag: ['模拟', '字符串', '贪心']
---
# 地砖铺设
## 题目描述

在游戏厅大赚了一笔的小 Z 终于赢到了他想要的家具。乘此机会，他想把自己的房间好好整理一下。

在百货公司，可以买到各种各样正方形的地砖，为了美观起见，小 Z 不希望同样颜色的正方形地砖相邻。所以他找到了小 C 来帮忙解决这件事情。

小 C 很快解决了这个任务。然而，出于某种强迫症，她希望在地上按照长宽划分成网格后，逐行逐列每一块的颜色组成的序列的字典序最小。她希望你帮忙验证一下她的方案。

## 输入格式

第一行，包含两个整数 $N$ 和 $M$，表示房间的长和宽。
## 输出格式

$N$ 行，每行 $M$ 列，表示地砖铺设的方案，需要这个方案是字典序最小的合法方案。（可以认为，输出的方案去掉回车后形成的字符串字典序最小）

## 样例

### 样例输入 #1
```
4 3
```
### 样例输出 #1
```
AAA
AAA
AAA
BCB
```
## 提示

对于 $50\%$ 的数据，保证 $N,M \leq 5$。

对于 $100\%$ 的数据，保证 $1 \leq N,M \leq 100$。



---

---
title: "彩球树"
layout: "post"
diff: 提高+/省选-
pid: P2131
tag: ['字符串', '树形数据结构']
---
# 彩球树
## 题目描述

小Z是一个聪明的小学生，他用塑料管和橡皮泥搭成了一棵树，每个橡皮泥上都连接着一个向下的塑料管，有的连接着两根向上的塑料管，有的则连接着一些彩球。

然而，这个工艺品很快因为不平衡倒了下来。于是，小Z请教了和他在同一个班上的妹子小C。在百科全书上看到天平平衡原理的小C知道，如果任何一块橡皮泥向上连接的两根管子的载重量之差超过一个彩球的重量，工艺品就会不平衡倒下来。由于彩球比较重，橡皮泥和塑料管的重量可以忽略不计。

由于移动彩球需要花时间拆卸和固定，小C希望移动最少次数彩球让这个工艺品平衡起来。你能帮助她吗？

## 输入格式

一行，以中序遍历的方式描述了这棵树，B 表示彩球。

## 输出格式

输出一个数字，表示最少移动多少个彩球就能使它平衡，或输出”impossible”，表示如何移动多少个都无法平衡。

## 样例

### 样例输入 #1
```
((B)())
```
### 样例输出 #1
```
0
```
### 样例输入 #2
```
((((B)(B))((B)()))(B))
```
### 样例输出 #2
```
impossible
```
### 样例输入 #3
```
(()(((B)(B))(B)))
```
### 样例输出 #3
```
1
```
## 提示

【图解】

[PIC=1259]

【数据规模】

对于 15% 的数据，保证输入文件不超过 25 字节。

对于 50% 的数据，保证输入文件不超过 250 字节。

对于 100% 的数据，保证输入文件不超过 5000 字节。

（PS：1字节≈1字符）

【时空限制】

0.1s/128M



---

---
title: "[HNOI2006] 最短母串问题"
layout: "post"
diff: 提高+/省选-
pid: P2322
tag: ['字符串', '2006', '各省省选', '湖南', '状压 DP']
---
# [HNOI2006] 最短母串问题
## 题目描述

给定  $n$ 个字符串  $(S_1,S_2,...,S_n)$，要求找到一个最短的字符串  $T$，使得这  $n$ 个字符串  $(S_1,S_2,...,S_n)$ 都是  $T$ 的子串。
## 输入格式

输入文件第一行是一个整数  $n$，表示给定的字符串个数。接下来  $n$ 行，每行有一个全由大写字母组成的字符串，。
## 输出格式

输出文件只有一行，为找到的最短的字符串  $T$。在保证最短的前提下，如果有多个字符串都满足要求，那么必须输出按字典序排列的第一个。
## 样例

### 样例输入 #1
```
2

ABCD

BCDABC
```
### 样例输出 #1
```
ABCDABC
```
## 提示

对于 $100\%$ 的数据，$n\leq 12$，每个字符串的长度不超过  $50$。


---

---
title: "背单词"
layout: "post"
diff: 提高+/省选-
pid: P2353
tag: ['字符串']
---
# 背单词
## 题目背景

小明对英语一窍不通，令老师十分头疼。于是期末考试前夕，小明被逼着开始背单词……

## 题目描述

老师给了小明一篇长度为N的英语文章，然后让小明背M个单词。为了确保小明不会在背单词时睡着，老师会向他提Q个问题，每次老师随机选择一个区间L..R，小明要回答在这段文字中他背过的单词总共出现过多少次。

## 输入格式

第一行两个整数M、Q如前所述。第二行为英语文章。接下来M行每行一个需要背的单词。接下来Q行每行一个询问，包含两个整数L、R（含端点），即给定的文字区间。

## 输出格式

Q行，对每个询问输出一行表示答案。

## 样例

### 样例输入 #1
```
3 3
abcabcbc
abc
bc
a
1 3
6 7
1 8
```
### 样例输出 #1
```
3
0
7

```
## 提示

数据范围：

对于30%的数据，1<=N<=10^3,1<=Q<=10^3

对于60%的数据，1<=N<=10^5,1<=Q<=10^5

对于100%的数据，1<=N<=10^6,1<=M<=10,1<=Q<=10^6,1<=每个单词的长度<=N,1<=L<=R<=N

提示：数据较大，请大家尽量采取高效率的读入输出方法。



---

---
title: "[NOI2014] 动物园"
layout: "post"
diff: 提高+/省选-
pid: P2375
tag: ['字符串', '递推', '2014', 'NOI', 'KMP 算法']
---
# [NOI2014] 动物园
## 题目描述

近日，园长发现动物园中好吃懒做的动物越来越多了。例如企鹅，只会卖萌向游客要吃的。为了整治动物园的不良风气，让动物们凭自己的真才实学向游客要吃的，园长决定开设算法班，让动物们学习算法。

某天，园长给动物们讲解 KMP 算法。

园长：“对于一个字符串 $S$，它的长度为 $L$。我们可以在 $O(L)$ 的时间内，求出一个名为 $\mathrm{next}$ 的数组。有谁预习了 $\mathrm{next}$ 数组的含义吗？”

熊猫：“对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀又是它的前缀的字符串中（它本身除外），最长的长度记作 $\mathrm{next}[i]$。”

园长：“非常好！那你能举个例子吗？”

熊猫：“例 $S$ 为 $\verb!abcababc!$，则 $\mathrm{next}[5]=2$。因为$S$的前$5$个字符为 $\verb!abcab!$，$\verb!ab!$ 既是它的后缀又是它的前缀，并且找不到一个更长的字符串满足这个性质。同理，还可得出 $\mathrm{next}[1] = \mathrm{next}[2] = \mathrm{next}[3] = 0$，$\mathrm{next}[4] = \mathrm{next}[6] = 1$，$\mathrm{next}[7] = 2$，$\mathrm{next}[8] = 3$。”

园长表扬了认真预习的熊猫同学。随后，他详细讲解了如何在 $O(L)$ 的时间内求出 $\mathrm{next}$ 数组。

下课前，园长提出了一个问题：“KMP 算法只能求出 $\mathrm{next}$ 数组。我现在希望求出一个更强大 $\mathrm{num}$ 数组一一对于字符串 $S$ 的前 $i$ 个字符构成的子串，既是它的后缀同时又是它的前缀，并且该后缀与该前缀不重叠，将这种字符串的数量记作 $\mathrm{num}[i]$。例如 $S$ 为 $\verb!aaaaa!$，则 $\mathrm{num}[4] = 2$。这是因为$S$的前 $4$ 个字符为 $\verb!aaaa!$，其中 $\verb!a!$ 和 $\verb!aa!$ 都满足性质‘既是后缀又是前缀’，同时保证这个后缀与这个前缀不重叠。而 $\verb!aaa!$ 虽然满足性质‘既是后缀又是前缀’，但遗憾的是这个后缀与这个前缀重叠了，所以不能计算在内。同理，$\mathrm{num}[1] = 0,\mathrm{num}[2] = \mathrm{num}[3] = 1,\mathrm{num}[5] = 2$。”

最后，园长给出了奖励条件，第一个做对的同学奖励巧克力一盒。听了这句话，睡了一节课的企鹅立刻就醒过来了！但企鹅并不会做这道题，于是向参观动物园的你寻求帮助。你能否帮助企鹅写一个程序求出$\mathrm{num}$数组呢？

特别地，为了避免大量的输出，你不需要输出 $\mathrm{num}[i]$ 分别是多少，你只需要输出所有 $(\mathrm{num}[i]+1)$ 的乘积，对 $10^9 + 7$ 取模的结果即可。

## 输入格式

第 $1$ 行仅包含一个正整数 $n$，表示测试数据的组数。  
随后 $n$ 行，每行描述一组测试数据。每组测试数据仅含有一个字符串 $S$，$S$ 的定义详见题目描述。数据保证 $S$ 中仅含小写字母。输入文件中不会包含多余的空行，行末不会存在多余的空格。

## 输出格式

包含 $n$ 行，每行描述一组测试数据的答案，答案的顺序应与输入数据的顺序保持一致。对于每组测试数据，仅需要输出一个整数，表示这组测试数据的答案对 $10^9+7$ 取模的结果。输出文件中不应包含多余的空行。

## 样例

### 样例输入 #1
```
3
aaaaa
ab
abcababc
```
### 样例输出 #1
```
36
1
32 
```
## 提示

测试点编号| 约定
-|-  
1| $n \le 5, L \le 50$  
2| $n \le 5, L \le 200$  
3| $n \le 5, L \le 200$  
4| $n \le 5, L \le 10,000$  
5| $n \le 5, L \le 10,000$  
6| $n \le 5, L \le 100,000$  
7| $n \le 5, L \le 200,000$   
8| $n \le 5, L \le 500,000$  
9| $n \le 5, L \le 1,000,000$  
10| $n \le 5, L \le 1,000,000$  



---

---
title: "整式的计算【数据有误】"
layout: "post"
diff: 提高+/省选-
pid: P2379
tag: ['模拟', '字符串', '数学', '洛谷原创']
---
# 整式的计算【数据有误】
## 题目背景

小明上了初中，整式计算总是出错，所以他找到了爱编程的你，让你设计一个程序帮帮他。

## 题目描述

输入几个单项式或多项式，计算结果。

## 输入格式

包括+，-,\*,字母(只包括a到z26个小写字母)单项式两边没有括号，多项式两边有( )或[ ]，保证在每一个因式中，单项式在多项式前面。（长度不超过255）

## 输出格式

输出这个表达式的结果，每个因式按字典序排列。

## 样例

### 样例输入 #1
```
(a+b)*(a+b+c)
```
### 样例输出 #1
```
a^2+2ab+ac+b^2+bc
```
### 样例输入 #2
```
(a+b)*(a+b+c)
```
### 样例输出 #2
```
a^2+2ab+ac+b^2+bc
```
### 样例输入 #3
```
(2a+b)*(2a-b)
```
### 样例输出 #3
```
4a^2-b^2
```
### 样例输入 #4
```
(a+b)*(a+b)*(a+b)
```
### 样例输出 #4
```
a^3+3a^2b+3ab^2+b^3
```
### 样例输入 #5
```
f*(a+b+d+z)+f^2
```
### 样例输出 #5
```
af+bf+df+fz+f^2
```
### 样例输入 #6
```
(a+b+2c)*(a+b-2c)-(a+b)*(a+b)
```
### 样例输出 #6
```
-4c^2
```
## 提示

水题一道。



---

---
title: "yyy loves physics IV"
layout: "post"
diff: 提高+/省选-
pid: P2413
tag: ['模拟', '字符串', '搜索']
---
# yyy loves physics IV
## 题目背景

“颤抖吧，实验室！”

yyy再一次来到了那个惨遭蹂躏的实验室。

## 题目描述

这次，在 Round1 里几乎壮烈牺牲的电路君又被翻了出来。一共有 $N$（$1 \le N \le 26$）个元件。

物理学霸 yyy 用一堆导线将他们连了起来，串联，并联，各种联……

但由于 yyy 的操作太不规范，导致每个元件都有损坏的风险，yyy 用他那天才的脑子算出元件 $i$ 损坏而断开的概率是 $p_i$（$0 \le p_i \le 1$），因为电路太复杂，yyy 请你帮忙算出电路断路的概率。

电路连接方式：

- 一个元件是最小的电路，用 $A$ 表示元件 $1$，$B$ 表示元件 $2$，以此类推。

- $K$ 个电路组成的串联电路表示为电路 $1,2,\dots,K$。

- $K$ 个电路组成的并联电路表示为（电路 $1$）（电路 $2$）......（电路 $K$）。
## 输入格式

第 $1$ 行是一个整数 $n$，表示一共有多少个元件；

第 $2$ 行是表示电路的字符串；

最后是 $n$ 行，每行是一个实数 $p_i$，表示元件 $i$ 断路的概率。
## 输出格式

一个实数，表示整个电路断路的概率，精确到小数点后 $4$ 位。
## 样例

### 样例输入 #1
```
5                            
(A,B)((C)(D),E)
0.2
0.3
0.4
0.5
0.6
```
### 样例输出 #1
```
0.2992
```


---

---
title: "[SDOI2006] 二进制方程"
layout: "post"
diff: 提高+/省选-
pid: P2456
tag: ['字符串', '高精度', '2006', '各省省选', '山东', '进制']
---
# [SDOI2006] 二进制方程
## 题目描述

一个形如：

X1X2…Xn=Y1Y2..Ym 

的等式称为二进制方程。

在二进制方程的两边：Xi和Yj （1<=i<=n；1<=j<=m）是二进制数字（0、1）或者一个变量（小写字母）。每个变量都是一个有固定长度的二进制代码，他可以在等式中取代变量的位置，称这个长度为变量的长度。为了解一个二进制方程，需要给其中的变量赋予适当的二进制代码，使得我们用他们替代等式中的相应的变量后（等式的两边都变成二进制代码），这个等式成立。

编程任务：

对于每一个给出的方程，计算一共有多少组解。已知变量最多有26个（26个英文小写字母），且等式的每一端的数字和变量的长度之和不超过10000。

## 输入格式

第一行：k（k<=26,变量的个数，规定使用小写英文字母中的前k个字母作为变量，如k=5，则变量a,b,c,d,e）。

第二行：k个正整数，中间用一个空格隔开，依次代表k个变量的长度。

第三行：等式左边的表达式。

第四行：等式右边的表达式。

## 输出格式

等式中出现的变量共有多少组解。

## 样例

### 样例输入 #1
```
2

4 2

1b1

a


```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
5

4 2 4 4 2

1bad1

acbe


```
### 样例输出 #2
```
16
```
## 提示

样例一：4组解

1 、a=1001； b=00

2、 a=1011； b=01

3、 a=1101； b=10

4、 a=1111； b=11）

样例二：K=5，变量：a,b,c,d,e。长度分别为：4 2 4 4 2。等式是：1bad1= acbe

输出16，即变量a,b,c,d,e共有16组解。




---

---
title: "[HAOI2010] 最长公共子序列"
layout: "post"
diff: 提高+/省选-
pid: P2516
tag: ['字符串', '动态规划 DP', '2010', '河南', '各省省选', '容斥原理']
---
# [HAOI2010] 最长公共子序列
## 题目描述

字符序列的子序列是指从给定字符序列中随意地（不一定连续）去掉若干个字符（可能一个也不去掉）后所形成的字符序列。令给定的字符序列$X=\{x_0,x_1,\cdots ,x_{m-1}\}$，序列$Y=\{y_0,y_1,\cdots ,y_{k-1}\}$ 是 $X$ 的子序列，存在 $X$ 的一个严格递增下标序列 $\{i_0,i_1,\cdots,i_{k-1}\}$ ，使得对所有的$j=0,1,\cdots,k-1$ ，有 $x_{ij}=y_j$ 。例如，$X=\verb!"ABCBDAB"!$ ，$Y=\verb!"BCDB"!$ 是 $X$ 的一个子序列。对给定的两个字符序列，求出他们最长的公共子序列长度，以及最长公共子序列个数。

## 输入格式

第一行为第一个字符序列，都是大写字母组成，以 . 结束，大写字母个数不超过 $5000$。

第二行为第二个字符序列，都是大写字母组成，以 . 结束，大写字母个数不超过 $5000$。
## 输出格式

第一行输出上述两个最长公共子序列的长度。

第二行输出所有可能出现的最长公共子序列个数，答案可能很大，只要将答案对 $10^{8}$ 求余即可。
## 样例

### 样例输入 #1
```
ABCBDAB.
BACBBD.
```
### 样例输出 #1
```
4
7
```


---

---
title: "计算器写作文"
layout: "post"
diff: 提高+/省选-
pid: P2549
tag: ['字符串', '贪心', '洛谷原创', '背包 DP']
---
# 计算器写作文
## 题目描述

众所周知，计算器可以拿来干很多它本不应该干的事情，比如弹琴。

小A发现了一个计算器的隐藏功能——写英语作文。

他在计算器上按一些数字，这些然后旋转 $180$ 度就是作文。

每个数字对应一两个字母

 ![](https://cdn.luogu.com.cn/upload/pic/1738.png) 



小 A 准备了一个单词表，选择其中的一些单词，按照一个顺序组成作文。这个作文是可以用计算器按出来的。比如单词表给 `ODD`、`EGG`，作文写成 `ODDEGG` 的话，那么要在计算器上按出 `993000`，这篇作文的得分就是 $993000$。

单词表的单词不能重复使用。如果单词表出现了多个一样的单词，每个单词最多都可以各使用一次。单词不可以被截断。

小 A 希望自己写出的作文得分最高。当然这个计算器是有位数限制，作文长度不能超过显示位数。

计算器不能显示前导零，但是你可以添加小数点。比如作文写成 `EGGODD` 的话，就得按出 $0.00993$，这个就是作文的得分，当然这得分太小了。

## 输入格式

第一行 $D$ 表示计算器位数。

第二行 $N$ 表示单词数。

接下来 $N$ 行，一行一个单词，保证可以转换为数字。
## 输出格式

一行，表示最大的分值。

## 样例

### 样例输入 #1
```
7

4

EGG

ODD

LOBE

LIBE
```
### 样例输出 #1
```
9933817
```
## 提示



对于 $40\%$ 的数据，$D \leq 20,N \leq 10$。

对于 $100\%$ 的数据，$D \leq 200,N \leq 10000$，单词长度 $\leq 32$。


---

---
title: "密码破解者"
layout: "post"
diff: 提高+/省选-
pid: P2636
tag: ['字符串']
---
# 密码破解者
## 题目背景

1941 年 12 月 7 日凌晨，珍珠港驻守美军通信员截获了一份日军电报。早上 8 时日军的正式进攻就会展开，为了减少太平洋战场伤亡，你被指派去协助破解密文。情报部门已得知了密文加密的层数和每层加密的方法。由于时间紧急，你只剩 1 秒的时间来破解日军的密文。

## 题目描述

据情报得知日军共有 $3$ 种加密方式：

一、栅栏密码：

所谓栅栏密码，就是把要加密的明文分成 $L$ 个一组，然后把每组的第 $1$ 个字连起来，形成一段无规律的话。一般比较常见的是 $2$ 栏的棚栏密码。 

比如明文：`THERE IS A CIPHER`  
去掉空格后变为：`THEREISACIPHER`  
两个一组，得到：`TH ER EI SA CI PH ER`  
先取出第一个字母：`TEESCPE`  
再取出第二个字母：`HRIAIHR`  
连在一起就是：`TEESCPEHRIAIHR`  

这样就得到我们需要的密码了。  

但也可能有更多的栏数。

注：若明文长度不能整除栏数，则分组后剩下的单独为一组，如：

`THERE IS A CIPHER`，$3$ 栏加密分组为：`THE REI SAC IPH ER`

先后取出第一二三个字母(最后一组只能取前两个)，加密后为: `TRSIE HEAPR EICH`（去掉空格）。

二、维吉尼亚(Vigenère)密码：

维吉尼亚密码首先应用了“密钥”的思想，其在密码届具有十分重要的意义。

在密码学中，我们称需要加密的信息为明文，用 $M$ 表示；称加密后的信息为密文，用 $C$ 表示；而密钥是一种参数，是将明文转换为密文或将密文转换为明文的算法中输入的数据，记为 $k$。在 Vigenère 密码中，密钥 $k$ 是一个字母串，$k=k_1k_2\cdots k_n$。当明文 $M=m_1m_2\cdots m_n$ 时，得到的密文 $C=c_1c_2\cdots c_n$，其中 $c_i=m_i\oplus k_i$，运算 $\oplus$ 的规则如下表所示：

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

A -A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

B -B C D E F G H I J K L M N O P Q R S T U V W X Y Z A

C -C D E F G H I J K L M N O P Q R S T U V W X Y Z A B

D -D E F G H I J K L M N O P Q R S T U V W X Y Z A B C

E -E F G H I J K L M N O P Q R S T U V W X Y Z A B C D

F -F G H I J K L M N O P Q R S T U V W X Y Z A B C D E

G -G H I J K L M N O P Q R S T U V W X Y Z A B C D E F

H -H I J K L M N O P Q R S T U V W X Y Z A B C D E F G

I -I J K L M N O P Q R S T U V W X Y Z A B C D E F G H

J -J K L M N O P Q R S T U V W X Y Z A B C D E F G H I

K -K L M N O P Q R S T U V W X Y Z A B C D E F G H I J

L -L M N O P Q R S T U V W X Y Z A B C D E F G H I J K

M -M N O P Q R S T U V W X Y Z A B C D E F G H I J K L

N -N O P Q R S T U V W X Y Z A B C D E F G H I J K L M

O -O P Q R S T U V W X Y Z A B C D E F G H I J K L M N

P -P Q R S T U V W X Y Z A B C D E F G H I J K L M N O

Q -Q R S T U V W X Y Z A B C D E F G H I J K L M N O P

R -R S T U V W X Y Z A B C D E F G H I J K L M N O P Q

S -S T U V W X Y Z A B C D E F G H I J K L M N O P Q R

T -T U V W X Y Z A B C D E F G H I J K L M N O P Q R S

U -U V W X Y Z A B C D E F G H I J K L M N O P Q R S T

V -V W X Y Z A B C D E F G H I J K L M N O P Q R S T U

W -W X Y Z A B C D E F G H I J K L M N O P Q R S T U V

X -X Y Z A B C D E F G H I J K L M N O P Q R S T U V W

Y -Y Z A B C D E F G H I J K L M N O P Q R S T U V W X

Z -Z A B C D E F G H I J K L M N O P Q R S T U V W X Y


Vigenère 加密在操作时需要注意： 

当明文 M 的长度大于密钥 k 的长度时，将密钥 k 重复使用。 

例如，明文 M=Helloworld，密钥 k=abc 时，密文 C=Hfnlpyosnd。 


三、QWE键盘码：

随着键盘普及，也出现了相应的键盘码。


这是一个常见的键盘,在左边字母区有三行字母分别为：

QWERTYUIOP

ASDFGHJKL

ZXCVBNM

从第一排第一列开始分别用Q替代A，W替代B……M替代Z以此类推。

如 CODING 加密后即为 EGROFU.

这对于现在来说算是简单的加密方法，但对于键盘不普及的二战时期却是一大难题。

## 输入格式

输入第一行为一个正整数N 表示截获的密文共用了N重密码加密。

第二行为一个字符串S表示加密后的密文。

以下3-N+2行共N行每行开头一个正整数K(1<=K<=3)表示对应的加密方式。

给出的加密方式按顺序给出，即给出的第I重加密为实际加密过程的第I重(1<=I<=N)。

若K=1则表示用栅栏密码加密，之后一个正整数L表示加密所用栏数。

若K=2则表示用维吉尼亚码加密，之后一个字符串T表示密钥。

若K=3则表示用QWE键盘码加密。

## 输出格式

共一行。一个字符串，表示破解N重加密后的明文。

## 样例

### 样例输入 #1
```
2
YSLTRIQXSHTQTR
1 2
3
```
### 样例输出 #1
```
FULLSPEEDAHEAD
```
## 提示

n<=1000



---

---
title: "机房中出了一只大触！"
layout: "post"
diff: 提高+/省选-
pid: P2643
tag: ['字符串', '矩阵运算', '洛谷原创']
---
# 机房中出了一只大触！
## 题目背景

机房中出了一只大触Kurunie！作为一只大触，它当然喜欢刷题。然而NOIp复赛临近，大触要抽出更多的时间来刷OI题，所以它就把一些简单的题目丢给你啦。

## 题目描述

显然，任何题目对于K触来说都是水题，倒是K触怕你不会写，于是给了你最最简单的化学卷子。

原来K触正在准备化学方程式配平大赛，所以卷子全都是配平练习题。

K触给你举了个简单的例子，比如下列物质在氧气中燃烧的化学方程式，要求配平：

 ![](https://cdn.luogu.com.cn/upload/pic/1755.png) 

K触当然知道这是绿原酸(C16H18O9)（O和0要分清楚哦），它在氧气中燃烧的方程式是：

C16H18O9+O2=CO2+H2O

什么？你说配平？这种简单的事情当然就交给你啦。

## 输入格式

一行一个字符串表示待配平的化学方程式。由一个等号隔开反应物和生成物，物质间用加号分隔。输


入的数字均在元素后面，作为下标。

## 输出格式

一行一个字符串表示配平后的化学方程式。不需要加沉淀或气体符号，

## 样例

### 样例输入 #1
```
C16H18O9+O2=CO2+H2O
```
### 样例输出 #1
```
C16H18O9+16O2=16CO2+9H2O
```
### 样例输入 #2
```
Cu(NO3)2+Fe=Fe(NO3)2+Cu
```
### 样例输出 #2
```
Cu(NO3)2+Fe=Fe(NO3)2+Cu
```
## 提示

保证输入字符串长度小于等于50，字符串只包含大小写英文字母、数字、小括号、加号、等号。

涉及到的物质均不包含带结晶水。

涉及到的元素最多只有两个字母。

小括号中不会嵌套小括号。

配平后每种物质系数、原字符串中的所有下标均在32位带符号整数范围内。



---

---
title: "[USACO5.4] 周游加拿大Canada Tour"
layout: "post"
diff: 提高+/省选-
pid: P2747
tag: ['字符串', '动态规划 DP', '搜索', '2001', 'USACO', 'IOI']
---
# [USACO5.4] 周游加拿大Canada Tour
## 题目描述

你赢得了一场航空公司举办的比赛，奖品是一张加拿大环游机票。旅行在这家航空公司开放的最西边的城市开始，然后一直自西向东旅行，直到你到达最东边的城市，再由东向西返回，直到你回到开始的城市。除了旅行开始的城市之外，每个城市只能访问一次，因为开始的城市必定要被访问两次（在旅行的开始和结束）。

当然不允许使用其他公司的航线或者用其他的交通工具。

给出这个航空公司开放的城市的列表，和两两城市之间的直达航线列表。找出能够访问尽可能多的城市的路线，这条路线必须满足上述条件，也就是从列表中的第一个城市开始旅行，访问到列表中最后一个城市之后再返回第一个城市。

## 输入格式

第 $1$ 行: 航空公司开放的城市数 $N$ 和将要列出的直达航线的数量 $V$。$N$ 是一个不大于 $100$ 的正整数。$V$ 是任意的正整数。

第 $2\sim N+1$ 行: 每行包括一个航空公司开放的城市名称。城市名称按照自西向东排列。不会出现两个城市在同一条经线上的情况。每个城市的名称都 是一个字符串，最多 $15$ 字节，由拉丁字母表上的字母组成；城市名称中没有空格。

第 $N+2\sim N+2+V-1$ 行: 每行包括两个城市名称（由上面列表中的城市名称组成），用一个空格分开。这样就表示两个城市之间的直达双程航线。
## 输出格式

Line 1: 按照最佳路线访问的不同城市的数量 M。如果无法找到路线，输出 1。

## 样例

### 样例输入 #1
```
8 9
Vancouver
Yellowknife
Edmonton
Calgary
Winnipeg
Toronto
Montreal
Halifax
Vancouver Edmonton
Vancouver Calgary
Calgary Winnipeg
Winnipeg Toronto
Toronto Halifax
Montreal Halifax
Edmonton Montreal
Edmonton Yellowknife
Edmonton Calgary
```
### 样例输出 #1
```
7
```
## 提示

题目翻译来自NOCOW。

USACO Training Section 5.4



---

---
title: "[USACO07DEC] Best Cow Line G"
layout: "post"
diff: 提高+/省选-
pid: P2870
tag: ['字符串', '贪心', '2007', 'USACO', '队列']
---
# [USACO07DEC] Best Cow Line G
## 题目背景

*本题和 [2007 年 11 月月赛银组同名题目](/problem/P6140) 在题意上一致，唯一的差别是数据范围。*
## 题目描述

Farmer John 打算带领 $N$（$1 \leq N \leq 5 \times 10^5$）头奶牛参加一年一度的”全美农场主大奖赛“。在这场比赛中，每个参赛者必须让他的奶牛排成一列，然后带领这些奶牛从裁判面前依此走过。

今年，竞赛委员会在接受报名时，采用了一种新的登记规则：取每头奶牛名字的首字母，按照它们在队伍中的次序排成一列。将所有队伍的名字按字典序升序排序，从而得到出场顺序。

FJ 由于事务繁忙，他希望能够尽早出场。因此他决定重排队列。

他的调整方式是这样的：每次，他从原队列的首端或尾端牵出一头奶牛，将她安排到新队列尾部。重复这一操作直到所有奶牛都插入新队列为止。

现在请你帮 FJ 算出按照上面这种方法能排出的字典序最小的队列。
## 输入格式

第一行一个整数 $N$。

接下来 $N$ 行每行一个大写字母，表示初始队列。
## 输出格式

输出一个长度为 $N$ 的字符串，表示可能的最小字典序队列。

每输出 $80$ 个字母需要一个换行。
## 样例

### 样例输入 #1
```
6
A
C
D
B
C
B
```
### 样例输出 #1
```
ABCBCD
```


---

---
title: "[USACO07FEB] The Cow Lexicon S"
layout: "post"
diff: 提高+/省选-
pid: P2875
tag: ['字符串', '动态规划 DP', '2007', 'USACO']
---
# [USACO07FEB] The Cow Lexicon S
## 题目描述

Few know that the cows have their own dictionary with W (1 ≤ W ≤ 600) words, each containing no more 25 of the characters 'a'..'z'. Their cowmunication system, based on mooing, is not very accurate; sometimes they hear words that do not make any sense. For instance, Bessie once received a message that said "browndcodw". As it turns out, the intended message was "browncow" and the two letter "d"s were noise from other parts of the barnyard.

The cows want you to help them decipher a received message (also containing only characters in the range 'a'..'z') of length L (2 ≤ L ≤ 300) characters that is a bit garbled. In particular, they know that the message has some extra letters, and they want you to determine the smallest number of letters that must be removed to make the message a sequence of words from the dictionary.
## 输入格式

Line 1: Two space-separated integers, respectively: W and L


Line 2: L characters (followed by a newline, of course): the received message


Lines 3..W+2: The cows' dictionary, one word per line

• 第1行:两个用空格隔开的整数,W和L.


• 第2行:一个长度为L的字符串,表示收到的信息.


• 第3行至第W+2行:奶牛的字典,每行一个词.

## 输出格式

Line 1: a single integer that is the smallest number of characters that need to be removed to make the message a sequence of dictionary words.

一个整数,表示最少去掉几个字母就可以使之变成准确的"牛语".

## 样例

### 样例输入 #1
```
6 10
browndcodw
cow
milk
white
black
brown
farmer
```
### 样例输出 #1
```
2
```
## 提示

感谢@ws\_fuweidong 提供完整题面

## 题目翻译

奶牛有她们自己的字典，里面的有 $W$（$1 \le W \le 600$）个词，每个词的长度不超过 $25$，且由小写字母组成。她们在交流时，由于各种原因，用词总是不那么准确。比如，贝茜听到有人对她说 `browndcodw`，确切的意思是 `browncow`，多出了两个 `d`。这两个 `d` 大概是身边的噪音。

奶牛们发觉辨认那些奇怪的信息很费劲，所以她们就想让你帮忙辨认一条收到的消息，即一个只包含小写字母且长度为 $L$（$1 \le L \le 300$）的字符串。有些时候，这个字符串里会有多余的字母，你的任务就是找出最少去掉几个字母就可以使这个字符串变成准确的"牛语"（即奶牛字典中某些词拼接成的一个序列）。


---

---
title: "[USACO07OPEN] Cheapest Palindrome G"
layout: "post"
diff: 提高+/省选-
pid: P2890
tag: ['字符串', '动态规划 DP', '递推', '2007', 'USACO']
---
# [USACO07OPEN] Cheapest Palindrome G
## 题目描述

Keeping track of all the cows can be a tricky task so Farmer John has installed a system to automate it. He has installed on each cow an electronic ID tag that the system will read as the cows pass by a scanner. Each ID tag's contents are currently a single string with length M (1 ≤ M ≤ 2,000) characters drawn from an alphabet of N (1 ≤ N ≤ 26) different symbols (namely, the lower-case roman alphabet).

Cows, being the mischievous creatures they are, sometimes try to spoof the system by walking backwards. While a cow whose ID is "abcba" would read the same no matter which direction the she walks, a cow with the ID "abcb" can potentially register as two different IDs ("abcb" and "bcba").

FJ would like to change the cows's ID tags so they read the same no matter which direction the cow walks by. For example, "abcb" can be changed by adding "a" at the end to form "abcba" so that the ID is palindromic (reads the same forwards and backwards). Some other ways to change the ID to be palindromic are include adding the three letters "bcb" to the begining to yield the ID "bcbabcb" or removing the letter "a" to yield the ID "bcb". One can add or remove characters at any location in the string yielding a string longer or shorter than the original string.

Unfortunately as the ID tags are electronic, each character insertion or deletion has a cost (0 ≤ cost ≤ 10,000) which varies depending on exactly which character value to be added or deleted. Given the content of a cow's ID tag and the cost of inserting or deleting each of the alphabet's characters, find the minimum cost to change the ID tag so it satisfies FJ's requirements. An empty ID tag is considered to satisfy the requirements of reading the same forward and backward. Only letters with associated costs can be added to a string.

## 输入格式

Line 1: Two space-separated integers: N and M


Line 2: This line contains exactly M characters which constitute the initial ID string


Lines 3..N+2: Each line contains three space-separated entities: a character of the input alphabet and two integers which are respectively the cost of adding and deleting that character.

## 输出格式

Line 1: A single line with a single integer that is the minimum cost to change the given name tag.

## 样例

### 样例输入 #1
```
3 4
abcb
a 1000 1100
b 350 700
c 200 800

```
### 样例输出 #1
```
900

```
## 提示

If we insert an "a" on the end to get "abcba", the cost would be 1000. If we delete the "a" on the beginning to get "bcb", the cost would be 1100. If we insert "bcb" at the begining of the string, the cost would be 350 + 200 + 350 = 900, which is the minimum.

## 题目翻译

### 题目描述
给定一个由 $n$ 个不同的小写字母构成的长 $m$ 的字符串 $s$。可以通过**在 $\bm{s}$ 的任意位置**增减字母将 $s$ 改为回文串。增减字母的花费不同，求最小花费。
### 输入格式
第 $1$ 行是两个整数 $n,m$。

第 $2$ 行是字符串 $s$。

接下 $n$ 行，每行一个字符 $c$ 和两个整数 $x,y$，表示添加一个 $c$ 的花费为 $x$，删除一个 $c$ 的花费为 $y$。
### 输出格式
只有 $1$ 行，表示最小花费。
### 数据范围
对于 $100\%$ 的数据，$1\le m\le2\times10^3,1\le n\le 26,0\le x,y\le 10^4$。

$\mathrm{by\ @}$[$\mathrm{Fish\_Know\_Forever}$](/user/663215)



---

---
title: "[USACO08OPEN] Crisis on the Farm G"
layout: "post"
diff: 提高+/省选-
pid: P2905
tag: ['字符串', '动态规划 DP', '搜索', '2008', 'USACO']
---
# [USACO08OPEN] Crisis on the Farm G
## 题目描述

约翰和他的奶牛组建了一只乐队“后街奶牛”，现在他们正在牧场里排练。奶牛们分成一堆一堆，共 $1000$）堆。每一堆里，$30$ 只奶牛一只踩在另一只的背上，叠成一座牛塔。牧场 里还有 $M(1 < M < 1000)$ 个高高的草垛。

作为出色的指挥家，约翰可以通过口哨指挥奶牛们移动。他的口哨有四个音，分别能使所有的牛塔向东南西北四个方向移动一格。

每一次，当一个牛塔到达了一个草垛所在的格子，牛塔最上方的奶牛就会跳到草垛上，而且不再下来，而其他奶牛仍然呈塔状站在草垛所在的格子里.当牛塔只剩一只奶牛时，这只奶牛也会跳到草垛上。

突然，约翰大惊失色：原来邻家的奶缸爆炸了！滚滚而下的牛奶正朝着约翰的牧场冲来，不久就要将牧场淹没。约翰必须马上行动，用口哨声挽救奶牛们的生命。他要指挥奶牛尽量多地跳上草操，草操上的奶牛将不会被淹死.

约翰还有 $K$ 次吹口哨的机会.那他最多还能救多少奶牛呢？请计算最多能挽救的奶牛数，以及达到这个数目约翰需要吹的口哨调子序列。序列用 $\mathtt{E,W,S,N}$ 表示东西南北。如果有多种序列能达到 要求，输出作为字符串最小的。

## 输入格式

\* Line 1: Three space-separated integers: N, M, and K

\* Lines 2..N+1: Line i+1 describes the X,Y location of a stack of 30 cows using two space-separated integers: X\_i and Y\_i

\* Lines N+2..N+M+1: Line i+N+1 describes the X,Y location of a haystack using two space-separated integers: X\_i and Y\_i

## 输出格式

\* Line 1: A single integer that is the most number of cows that can be saved.

\* Line 2: K characters, the lexicographically least sequence of commands FJ should issue to maximize the number of cows saved.

## 样例

### 样例输入 #1
```
3 6 3 
3 4 
6 2 
5 7 
8 2 
9 2 
6 4 
5 4 
6 7 
8 7 

```
### 样例输出 #1
```
6 
EEE 

```
## 提示

Use the 'east' whistle three times, at which point the milk floods the area.  Each haystack ends up saving 1 cow.

对于 $100\%$ 的数据，$1\le K\le 30$，$1\le N,M,X_i,Y_i\le 1000$。



---

---
title: "[USACO11FEB] The Lost Cows G"
layout: "post"
diff: 提高+/省选-
pid: P3013
tag: ['模拟', '字符串', '2011', 'USACO', 'Special Judge', '深度优先搜索 DFS']
---
# [USACO11FEB] The Lost Cows G
## 题目描述

One sunny day farmer John was kidnapped by evil farmer Marcus's cows. FJ wasn't too concerned about his forced holiday but wanted to make sure that his cows got home safely together.

The cows are spread out in every one of FJ's N (3 <= N <= 200) pastures conveniently numbered 1..N. The barn is located at pasture 1. The farm has an interesting navigation system: at every pasture i there are M (1 <= M <= 200) signs S\_ij (1 <= S\_ij <= N) which one could reference as S\_i1..S\_iM; each sign points the way to a pasture. Sometimes a sign points to a path that leads back to the same

pasture.

Farmer Marcus's cows allow FJ to write a single message to all of his cows. FJ's plan is to write a list of sign numbers such that any cow who follows those instructions will all arrive at the barn when each cow has completed all the instructions.

When a cow starts at a given pasture then she will first follow the path indicated by the first sign number on FJ's list. When she arrives at the second pasture, she looks at the second sign of FJ's list and follows the path marked by that sign. She continues until she exhausts the instruction list, at which point she should be at the barn.

Find a list of instructions containing no more than 5,000,000 sign numbers that will guide every cow, from every pasture, to the barn after all instructions are followed.  It is guaranteed that such a list exists.

Consider a set of three signs in four pastures that direct the cows like these do:

```cpp
** Pasture# ** 
1    2    3    4 
Sign 1   4    4    1    3 
Sign 2   1    3    2    4 
Sign 3   4    2    3    1 
```
The set of instructions below will direct cows to the barn from any of the four pastures:

```cpp
Instruction#   Sign#            Instruction#   Sign# 
1           1                   5           3 
2           2                   6           1 
3           1                   7           3 
4           2 
```
The cow in pasture 1 will read sign #1 at time 1 and be directed to pasture 4.  At time 2, she is in pasture 4 and (per FJ's

instructions) read sign #2 and then be directed to pasture 4. Below is a table that shows the cow's travels:

```cpp
* * * *  Cow in pasture  1  * * * * 
Time    CurrentPasture#    WhichSign     Sign->Nextpasture 
1            1               1                4 
2            4               2                4 (same pasture!) 
3            4               1                3 
4            3               2                2 
5            2               3                2 (same pasture)
6            2               1                4 
7            4               3                1 Barn! 
```
Similarly: Pasture 2's cow visits pastures [2]-4-4-3-2-2-4-1. Pasture 3's cow visits pastures [3]-1-1-4-4-1-4-1.

Pasture 4's cow visits pastures [4]-3-2-4-4-1-4-1.


Given a set of signs, create a set of instructions. 

## 输入格式

\* Line 1: Two space separated integers: N and M

\* Lines 2..M+1: Line i+1 describes the contents of each pasture's N signs with N integers: S\_1i..S\_Ni

## 输出格式

\* Lines 1..?: The sign numbers the cows should follow, one per line.

## 样例

### 样例输入 #1
```
4 3 
4 4 1 3 
1 3 2 4 
4 2 3 1 

```
### 样例输出 #1
```
1 
2 
1 
2 
3 
1 
3 

```
## 题目翻译

### 题目描述

给定一张 $n(3\leq n\leq 200)$ 个点的图，每个点都恰好有 $m(1\leq m\leq 200)$ 条出边，第 $i$ 个点的第 $j$ 条出边指向 $a_{i,j}$。

现在这张图上每个点都有一头牛。每次你可以报出一个数 $x(1\leq x\leq m)$，这会使得每一头牛沿着当前所在的点的第 $x$ 条边走一步（即当前在点 $u$ 的牛移动到点 $a_{u,x}$）。

你需要发出不超过 $5\times 10^6$ 条指令，使得在所有的指令执行完后，所有的牛都在编号为 $1$ 的点上。

### 输入格式

第一行两个整数 $n,m$。

接下来 $m$ 行每行 $n$ 个整数，第 $i$ 行的第 $j$ 个整数是 $a_{j,i}$。

### 输出格式

在第 $i$ 行输出你发出的第 $i$ 条指令。


---

---
title: "[USACO12DEC] First! G"
layout: "post"
diff: 提高+/省选-
pid: P3065
tag: ['字符串', '2012', 'USACO', '哈希 hashing', '字典树 Trie']
---
# [USACO12DEC] First! G
## 题目描述

Bessie has been playing with strings again. She found that by

changing the order of the alphabet she could make some strings come before all the others lexicographically (dictionary ordering).

For instance Bessie found that for the strings "omm", "moo", "mom", and "ommnom" she could make "mom" appear first using the standard alphabet and that she could make "omm" appear first using the alphabet

"abcdefghijklonmpqrstuvwxyz".  However, Bessie couldn't figure out any way to make "moo" or "ommnom" appear first.

Help Bessie by computing which strings in the input could be

lexicographically first by rearranging the order of the alphabet.  To compute if string X is lexicographically before string Y find the index of the first character in which they differ, j.  If no such index exists then X is lexicographically before Y if X is shorter than Y.  Otherwise X is lexicographically before Y if X[j] occurs earlier in the alphabet than Y[j].

Bessie 一直在研究字符串。她发现，通过改变字母表的顺序，她可以按改变后的字母表来排列字符串（字典序大小排列）。

例如，Bessie 发现，对于字符串 $\texttt{omm},\texttt{moo},\texttt{mom}$ 和 $\texttt{ommnom}$，她可以使用标准字母表使 $\texttt{mom}$ 排在第一个（即字典序最小），她也可以使用字母表 $\texttt{abcdefghijklonmpqrstuvwxyz}$ 使得 $\texttt{omm}$ 排在第一个。然而，Bessie 想不出任何方法（改变字母表顺序）使得 $\texttt{moo}$ 或 $\texttt{ommnom}$ 排在第一个。

接下来让我们通过重新排列字母表的顺序来计算输入中有哪些字符串可以排在第一个（即字典序最小），从而帮助 Bessie。

要计算字符串 $X$ 和字符串 $Y$ 按照重新排列过的字母表顺序来排列的顺序，先找到它们第一个不同的字母 $X_i$ 与 $Y_i$，按重排后的字母表顺序比较，若 $X_i$ 比 $Y_i$ 先，则 $X$ 的字典序比 $Y$ 小，即 $X$ 排在 $Y$ 前；若没有不同的字母，则比较 $X$ 与 $Y$ 长度，若 $X$ 比 $Y$ 短，则 $X$ 的字典序比 $Y$ 小，即 $X$ 排在 $Y$ 前。

## 输入格式

\* Line 1: A single line containing N (1 <= N <= 30,000), the number of strings Bessie is playing with.

\* Lines 2..1+N: Each line contains a non-empty string.  The total number of characters in all strings will be no more than 300,000.  All characters in input will be lowercase characters 'a' through 'z'.  Input will contain no duplicate strings.

第 $1$ 行：一个数字 $N$（$1\le N \le 30,000$），表示 Bessie 正在研究字符串的数量。

第 $2\sim N+1$ 行：每行包含一个非空字符串。所有字符串包含的字符总数不会超过 $300,000$。输入中的所有字符都是小写字母，即 $a\sim z$。输入不包含重复的字符串。


## 输出格式

\* Line 1: A single line containing K, the number of strings that could be lexicographically first.

\* Lines 2..1+K: The (1+i)th line should contain the ith string that could be lexicographically first.  Strings should be output in the same order they were given in the input.

\* Line 1: A single line containing K, the number of strings that could be lexicographically first.

\* Lines 2..1+K: The (1+i)th line should contain the ith string that could be lexicographically first.  Strings should be output in the same order they were given in the input.

第 $1$ 行：一个数字 $K$，表示按重排的字母表顺序排列后可以排在第一个的字符串数量。

第 $2\sim K+1$ 行：第 $i+1$ 行包含第 $i$ 个按重排的字母表顺序排列后可以排在第一个的字符串。字符串应该按照它们在输入中的顺序来输出。

## 样例

### 样例输入 #1
```
4
omm
moo
mom
ommnom

```
### 样例输出 #1
```
2
omm
mom

```
## 提示

The example from the problem statement.


Only "omm" and "mom" can be ordered first.

样例即题目描述中给出的例子，只有 $\texttt{omm}$ 和 $\texttt{mom}$ 在各自特定的字典序下可以被排列在第一个。


---

---
title: "[USACO13MAR] Necklace G"
layout: "post"
diff: 提高+/省选-
pid: P3082
tag: ['字符串', '2013', '线段树', 'USACO']
---
# [USACO13MAR] Necklace G
## 题目描述

Bessie the cow has arranged a string of N rocks, each containing a single letter of the alphabet, that she wants to build into a fashionable necklace.

Being protective of her belongings, Bessie does not want to share her necklace with the other cow currently living on her side of the barn.  The other cow has a name that is a string of M characters, and Bessie wants to be sure that this length-M string does not occur as a contiguous substring anywhere within the string representing her necklace (otherwise, the other cow might mistakenly think the necklace is for her).  Bessie decides to remove some of the rocks in her necklace so that the other cow's name does not appear as a substring.  Please help Bessie determine the minimum number of rocks she must remove.

贝西收集了N颗石头，每颗石头上都有一个字母，贝西想把这些石头做成项链。

贝西的身边有另一只奶牛，这只奶牛的名字是一个长度为M的字符串，贝西不希望这只牛的名字出现在她的项链上(项链的子串)，她想知道，最少删掉几颗石头就可以避免这种情况发生。

## 输入格式

\* Line 1: The first line is a length-N string describing Bessie's initial necklace; each character is in the range "a" through "z".

\* Line 2: The second line is the length-M name of the other cow in the barn, also made of characters from "a" to "z".

## 输出格式

\* Line 1: The minimum number of stones that need to be removed from Bessie's necklace so that it does not contain the name of the other cow as a substring.

## 样例

### 样例输入 #1
```
ababaa 
aba 

```
### 样例输出 #1
```
1 

```
## 提示

```cpp
For at least 20% of test cases, N <= 20. 
For at least 60% of test cases, N <= 1000, M <= 100. 
For all test cases, N <= 10000, M <= 1000. 
For all test cases, M <= N. 
```
The modified necklace should be "abbaa".

---

$\text{upd 2022.7.29}$：新增加一组 Hack 数据。


---

---
title: "[USACO14FEB] Secret Code S"
layout: "post"
diff: 提高+/省选-
pid: P3102
tag: ['字符串', '搜索', '2014', 'USACO', '最短路']
---
# [USACO14FEB] Secret Code S
## 题目描述

Farmer John has secret message that he wants to hide from his cows; the message is a string of length at least 2 containing only the characters A..Z.

To encrypt his message, FJ applies a sequence of "operations" to it, where an operation applied to a string S first shortens S by removing either some (but not all) of the initial characters or some (but not all) of the final characters from S, after which the original string S is attached either at the beginning or end.  For example, a single operation to the string ABC could result in eight possible strings:

AABC
ABABC
BCABC
CABC
ABCA
ABCAB
ABCBC
ABCC
Given the final encrypted string, please count the number of possible ways FJ could have produced this string using one or more repeated operations applied to some source string.  Operations are treated as being distinct even if they give the same encryption of FJ's message.  For example, there are four distinct separate ways to obtain AAA from AA.

Print your answer out modulo 2014.

农民约翰收到一条的消息，记该消息为长度至少为2，只由大写字母组成的字符串S，他通过一系列操作对S进行加密。


他的操作为，删除S的前面或者后面的若干个字符（但不删光整个S），并将剩下的部分连接到原字符串S的前面或者后面。如对于S=‘ABC’，共有8总可能的操作结果：


AABC

ABABC

BCABC

CABC

ABCA

ABCAB

ABCBC

ABCC

给出加密后的目标字符串，请计算共有多少种加密的方案。


对于同字符的字符串，加密方案不止一种，比如把AA加密成AAA，共有4种加密方案。将你的答案mod 2014后输出。

## 输入格式

\* Line 1: A single encrypted string of length at most 100.

## 输出格式

\* Line 1: The number of ways FJ could have produced this string with one or more successive operations applied to some initial string of length at least 2, written out modulo 2014.  If there are no such ways, output zero.

## 样例

### 样例输入 #1
```
ABABA 

```
### 样例输出 #1
```
8 

```
## 提示

Here are the different ways FJ could have produced ABABA:

1. Start with ABA -> AB+ABA

2. Start with ABA -> ABA+BA

3. Start with AB -> AB+A -> AB+ABA

4. Start with AB -> AB+A -> ABA+BA

5. Start with BA -> A+BA -> AB+ABA

6. Start with BA -> A+BA -> ABA+BA

7. Start with ABAB -> ABAB+A

8. Start with BABA -> A+BABA



---

---
title: "[USACO15OPEN] Palindromic Paths G"
layout: "post"
diff: 提高+/省选-
pid: P3126
tag: ['字符串', '动态规划 DP', '2015', 'USACO', '枚举']
---
# [USACO15OPEN] Palindromic Paths G
## 题目描述

Farmer John's farm is in the shape of an $N \times N$ grid of fields ($1 \le N \le 500$), each labeled with a letter in the alphabet.  For example:

```cpp
ABCD
BXZX
CDXB
WCBA
```
Each day, Bessie the cow walks from the upper-left field to the lower-right field, each step taking her either one field to the right or one field downward. Bessie keeps track of the string that she generates during this process, built from the letters she walks across. She gets very disoriented, however, if this string is a palindrome (reading the same forward as backward), since she gets confused about which direction she had walked. Please help Bessie determine the number of distinct routes she can take that  correspond to palindromes. Different ways of obtaining the same palindrome count multiple times. Please print your answer modulo 1,000,000,007.
## 输入格式

The first line of input contains $N$, and the remaining $N$ lines contain the $N$ rows of the grid of fields. Each row contains $N$ characters that are in the range A..Z.
## 输出格式

Please output the number of distinct palindromic routes Bessie can take, modulo 1,000,000,007.
## 样例

### 样例输入 #1
```
4
ABCD
BXZX
CDXB
WCBA
```
### 样例输出 #1
```
12
```
## 提示

Bessie can make the following palindromes

1 x "ABCDCBA"

1 x "ABCWCBA"

6 x "ABXZXBA"

4 x "ABXDXBA"

## 题目翻译

### 题目描述

Farmer John 的农场是一个 $N \times N$ 的网格（$1 \le N \le 500$），每个格子标有一个字母。例如：

```
ABCD
BXZX
CDXB
WCBA
```

每天，奶牛 Bessie 从左上角的格子走到右下角的格子，每一步只能向右或向下移动一个格子。Bessie 会记录下她走过的路径所生成的字符串，这个字符串由她经过的格子上的字母组成。然而，如果这个字符串是一个回文串（即正读和反读相同），她会感到非常困惑，因为她会分不清自己走过的方向。请帮助 Bessie 计算她可以走的不同路径中，对应回文串的数量。即使生成相同回文串的方式不同，也需要分别计数。请输出答案对 1,000,000,007 取模的结果。

### 输入格式

输入的第一行包含 $N$，接下来的 $N$ 行包含网格的 $N$ 行。每行包含 $N$ 个字符，字符范围为 A..Z。

### 输出格式

请输出 Bessie 可以走的不同回文路径的数量，对 1,000,000,007 取模。

### 说明/提示

Bessie 可以生成以下回文串：

- 1 个 "ABCDCBA"
- 1 个 "ABCWCBA"
- 6 个 "ABXZXBA"
- 4 个 "ABXDXBA"


---

---
title: "[CQOI2014] 通配符匹配"
layout: "post"
diff: 提高+/省选-
pid: P3167
tag: ['字符串', '2014', '重庆', '各省省选', '哈希 hashing', 'AC 自动机']
---
# [CQOI2014] 通配符匹配
## 题目描述

几乎所有操作系统的命令行界面（CLI）中都支持文件名的通配符匹配以方便用户。最常见的通配符有两个，一个是星号（```*```），可以匹配 0 个及以上的任意字符：另一个是问号（```?```），可以匹配恰好一个任意字符。现在需要你编写一个程序，对于给定的文件名列表和一个包含通配符的字符串，判断哪些文件可以被匹配。

## 输入格式

第一行是一个由小写字母和上述通配符组成的字符串。第二行包含一个整数 $n$，表示文件个数。接下来 $n$ 行，每行为一个仅包含小写字母字符串，表示文件名列表。

## 输出格式

输出 $n$ 行，每行为 ``YES`` 或 ``NO``，表示对应文件能否被通配符匹配。

## 样例

### 样例输入 #1
```
*aca?ctc
6
acaacatctc
acatctc
aacacatctc
aggggcaacacctc
aggggcaacatctc
aggggcaacctct
```
### 样例输出 #1
```
YES

YES

YES

YES

YES

NO
```
## 提示

对于 $100 \%$ 的数据

- 字符串长度不超过 $100000$
- $1 \le n \le 100$
- 通配符个数不超过 $10$



---

---
title: "[POI 2012] OKR-A Horrible Poem"
layout: "post"
diff: 提高+/省选-
pid: P3538
tag: ['字符串', '2012', 'POI（波兰）', '哈希 hashing']
---
# [POI 2012] OKR-A Horrible Poem
## 题目描述

Bytie boy has to learn a fragment of a certain poem by heart.  The poem, following the best lines of modern art, is a long string    consisting of lowercase English alphabet letters only.  Obviously, it sounds horrible, but that is the least of Bytie's worries.

First and foremost, he completely forgot which fragment is he supposed to learn.  And they all look quite difficult to memorize...

There is hope, however: some parts of the poem exhibit certain regularity.  In particular, every now and then a fragment, say ![](http://main.edu.pl/images/OI19/okr-en-tex.1.png),    is but a multiple repetition of another fragment, say ![](http://main.edu.pl/images/OI19/okr-en-tex.2.png) (in other words, ![](http://main.edu.pl/images/OI19/okr-en-tex.3.png), i.e., ![](http://main.edu.pl/images/OI19/okr-en-tex.4.png), where ![](http://main.edu.pl/images/OI19/okr-en-tex.5.png) is    an integer).  In such case we say that ![](http://main.edu.pl/images/OI19/okr-en-tex.6.png) is a full period of ![](http://main.edu.pl/images/OI19/okr-en-tex.7.png) (in particular, every string is its own full period).

If a given fragment has a short full period, Bytie's task will be easy.  The question remains... which fragment was that?

Make a gift for Bytie - write a program that will read the whole poem as well as a list of fragments that Bytie suspects might be the    one he is supposed to memorize, and for each of them determines its shortest full period.
## 输入格式

In the first line of the standard input there is a single integer ![](http://main.edu.pl/images/OI19/okr-en-tex.8.png)      (![](http://main.edu.pl/images/OI19/okr-en-tex.9.png)).

In the second line there is a string of length ![](http://main.edu.pl/images/OI19/okr-en-tex.10.png) consisting of lowercase English alphabet letters-the poem.

We number the positions of its successive characters from 1 to ![](http://main.edu.pl/images/OI19/okr-en-tex.11.png).

The next line holds a single integer ![](http://main.edu.pl/images/OI19/okr-en-tex.12.png) (![](http://main.edu.pl/images/OI19/okr-en-tex.13.png)) denoting the number of fragments.

Then the following ![](http://main.edu.pl/images/OI19/okr-en-tex.14.png) lines give queries, one per line.

Each query is a pair of integers ![](http://main.edu.pl/images/OI19/okr-en-tex.15.png) and ![](http://main.edu.pl/images/OI19/okr-en-tex.16.png) (![](http://main.edu.pl/images/OI19/okr-en-tex.17.png)),      separated by a single space, such that the answer to the query should be the length of the shortest full period of the poem's      fragment that begins at position ![](http://main.edu.pl/images/OI19/okr-en-tex.18.png) and ends at position ![](http://main.edu.pl/images/OI19/okr-en-tex.19.png).

In tests worth in total 42% of the points ![](http://main.edu.pl/images/OI19/okr-en-tex.20.png) holds in addition.

In some of those, worth 30% of points in total, ![](http://main.edu.pl/images/OI19/okr-en-tex.21.png) holds as well.

## 输出格式

Your program should print ![](http://main.edu.pl/images/OI19/okr-en-tex.22.png) lines on the standard output.

The ![](http://main.edu.pl/images/OI19/okr-en-tex.23.png)-th of these lines should hold a single integer - the answer to the ![](http://main.edu.pl/images/OI19/okr-en-tex.24.png)-th query.

## 样例

### 样例输入 #1
```
8
aaabcabc
3
1 3
3 8
4 8
```
### 样例输出 #1
```
1
3
5
```
## 题目翻译

给出一个由小写英文字母组成的字符串 $S$，再给出 $q$ 个询问，要求回答 $S$ 某个子串的最短循环节。

如果字符串 $B$ 是字符串 $A$ 的循环节，那么 $A$ 可以由 $B$ 重复若干次得到。

--- 

第一行一个正整数 $n\ (n\le 5\times 10^5)$，表示 $S$ 的长度。

第二行 $n$ 个小写英文字母，表示字符串 $S$。

第三行一个正整数 $q\ (q\le 2\times 10^6)$，表示询问次数。

下面 $q$ 行每行两个正整数 $a,b(1\le a\le b\le n)$，表示询问字符串 $S[a\cdots b]$ 的最短循环节长度。


---

---
title: "主主树"
layout: "post"
diff: 提高+/省选-
pid: P3701
tag: ['字符串', '网络流', '洛谷原创', '图论建模']
---
# 主主树
## 题目背景

byx 和诗乃酱都非常都非常喜欢种树。有一天，他们得到了两颗奇怪的树种，于是各自取了一颗回家种树，并约定几年后比一比谁种出来的树更加牛 X。
## 题目描述

很快，这棵树就开花结果了。byx 和诗乃酱惊讶的发现，这是一棵主主树，树上长满了主主和主主的朋友们。这棵树上一共有五种人，主主（$\verb!J!$），记记（$\verb!HK!$），高高（$\verb!W!$），王王（$\verb!E!$）和歪歪（$\verb!YYY!$）。他们发现，他们的主主树上的人数相同，都为 $N$。

 ![](https://cdn.luogu.com.cn/upload/image_hosting/0vklm8ow.png) 

研究发现，这五种人的输赢如上图所示（一样的人不能 PK），箭头指向输的人。至于为什么，留给同学们自己思考。

比赛如期进行。

byx 和诗乃酱要进行 $M$ 场比赛，每一场比赛他们会选出树上的两个人来比较看谁更牛 X。

第 $i$ 个人寿命为 $\text{Life}_i$ 秒，每次比完赛他们就会 $-1$s。当他们生命为 $0$s 时他们就不能再比赛了。

同时，当 $\verb!J!$ 的寿命为 $0$ 时，同一棵树上的 $\verb!YYY!$ 可以为他 $+1$s。每个 $\verb!YYY!$ 只能给每个 $\verb!J!$ 续一次。

那么问题来了：

现在给定 $N,M(1\le N\le 100,1\le M\le 1000)$，诗乃酱和 byx 每一个人所属种类（$\verb!J!,\verb!HK!,\verb!W!,\verb!YYY!$ 或 $\verb!E!$）以及每一个人的生命，生命不超过 $50$。请你算算 byx 最多能够赢得多少场比赛呢。

数据保证每一场一定都有人用。两个人之间只能比一场。
## 输入格式

第一行包含两个数 $N,M$，含义看上面。  

第二行 $N$ 个字串（$\verb!J!,\verb!HK!,\verb!W!,\verb!YYY!$ 或 $\verb!E!$），表示 byx 的人所属种类，用空格隔开。  

第三行 $N$ 个字串（$\verb!J!,\verb!HK!,\verb!W!,\verb!YYY!$ 或 $\verb!E!$），表示诗乃酱的人所属种类，用空格隔开。  

第四行 $N$ 个数，表示 byx 的人的生命。  

第五行 $N$ 个数，表示诗乃酱的人的生命。  
## 输出格式

一个数，byx 能赢的场次。
## 样例

### 样例输入 #1
```
3 3
J W YYY
J HK E
2 2 2
2 2 2

```
### 样例输出 #1
```
3

```
## 提示

第一场主主赢记记，第二场高高赢王王，第三场歪歪赢记记。



---

---
title: "AC 自动机（简单版 II）"
layout: "post"
diff: 提高+/省选-
pid: P3796
tag: ['字符串', '字典树 Trie', 'AC 自动机']
---
# AC 自动机（简单版 II）
## 题目描述

有 $N$ 个由小写字母组成的模式串以及一个文本串 $T$。每个模式串可能会在文本串中出现多次。你需要找出**哪些**模式串在文本串 $T$ 中出现的次数最多。

## 输入格式

输入含多组数据。保证输入数据不超过 $50$ 组。

每组数据的第一行为一个正整数 $N$，表示共有 $N$ 个模式串，$1 \leq N \leq 150$。

接下去 $N$ 行，每行一个长度小于等于 $70$ 的模式串。下一行是一个长度小于等于 $10^6$ 的文本串 $T$。保证不存在两个相同的模式串。

输入结束标志为 $N=0$。
## 输出格式

对于每组数据，第一行输出模式串最多出现的次数，接下去若干行每行输出一个出现次数最多的模式串，按输入顺序排列。

## 样例

### 样例输入 #1
```
2
aba
bab
ababababac
6
beta
alpha
haha
delta
dede
tata
dedeltalphahahahototatalpha
0
```
### 样例输出 #1
```
4
aba
2
alpha
haha
```


---

---
title: "【模板】manacher"
layout: "post"
diff: 提高+/省选-
pid: P3805
tag: ['字符串', 'O2优化', 'Manacher 算法']
---
# 【模板】manacher
## 题目描述

给出一个只由小写英文字符 $\texttt a,\texttt b,\texttt c,\ldots\texttt y,\texttt z$ 组成的字符串 $S$ ,求 $S$ 中最长回文串的长度 。

字符串长度为 $n$。
## 输入格式

一行小写英文字符 $\texttt a,\texttt b,\texttt c,\cdots,\texttt y,\texttt z$ 组成的字符串 $S$。
## 输出格式

一个整数表示答案。

## 样例

### 样例输入 #1
```
aaa
```
### 样例输出 #1
```
3
```
## 提示

$1\le n\le 1.1\times 10^7$。


---

---
title: "AC 自动机（简单版）"
layout: "post"
diff: 提高+/省选-
pid: P3808
tag: ['字符串', 'O2优化', 'AC 自动机', '构造']
---
# AC 自动机（简单版）
## 题目描述

给定 $n$ 个模式串 $s_i$ 和一个文本串 $t$，求有多少个不同的模式串在文本串里出现过。  
两个模式串不同当且仅当他们**编号**不同。
## 输入格式

第一行是一个整数，表示模式串的个数 $n$。  
第 $2$ 到第 $(n + 1)$ 行，每行一个字符串，第 $(i + 1)$ 行的字符串表示编号为 $i$ 的模式串 $s_i$。  
最后一行是一个字符串，表示文本串 $t$。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
3
a
aa
aa
aaa
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
4
a
ab
ac
abc
abcd
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
2
a
aa
aa
```
### 样例输出 #3
```
2
```
## 提示

### 样例 1 解释

$s_2$ 与 $s_3$ 编号（下标）不同，因此各自对答案产生了一次贡献。

### 样例 2 解释

$s_1$，$s_2$，$s_4$ 都在串 `abcd` 里出现过。

### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n = 1$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^6$，$1 \leq |t| \leq 10^6$，$1 \leq \sum\limits_{i = 1}^n |s_i| \leq 10^6$。$s_i, t$ 中仅包含小写字母。


---

---
title: "[CQOI2007] 涂色"
layout: "post"
diff: 提高+/省选-
pid: P4170
tag: ['字符串', '2007', '重庆', '各省省选', '枚举', '区间 DP']
---
# [CQOI2007] 涂色
## 题目描述

假设你有一条长度为 $5$ 的木板，初始时没有涂过任何颜色。你希望把它的 $5$ 个单位长度分别涂上红、绿、蓝、绿、红色，用一个长度为 $5$ 的字符串表示这个目标：$\texttt{RGBGR}$。

每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色。例如第一次把木板涂成 $\texttt{RRRRR}$，第二次涂成 $\texttt{RGGGR}$，第三次涂成 $\texttt{RGBGR}$，达到目标。

用尽量少的涂色次数达到目标。

## 输入格式

输入仅一行，包含一个长度为 $n$ 的字符串，即涂色目标。字符串中的每个字符都是一个大写字母，不同的字母代表不同颜色，相同的字母代表相同颜色。

## 输出格式

仅一行，包含一个数，即最少的涂色次数。

## 样例

### 样例输入 #1
```
AAAAA
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
RGBGR
```
### 样例输出 #2
```
3
```
## 提示

$40\%$ 的数据满足 $1\le n\le 10$。

$100\%$ 的数据满足 $1\le n\le 50$。




---

---
title: "[SCOI2003] 字符串折叠"
layout: "post"
diff: 提高+/省选-
pid: P4302
tag: ['字符串', '动态规划 DP', '搜索', '2003', '四川', '各省省选', '枚举', '区间 DP']
---
# [SCOI2003] 字符串折叠
## 题目描述

折叠的定义如下：

1. 一个字符串可以看成它自身的折叠。记作 ```S = S```

2. ```X(S)``` 是 $X$ 个 ```S``` 连接在一起的串的折叠。记作 ```X(S) = SSSS…S```。

3. 如果 ```A = A’```, ```B = B’```，则 ```AB = A’B’ ```。例如：因为 ```3(A) = AAA```, ```2(B) = BB```，所以 ```3(A)C2(B) = AAACBB```，而 ```2(3(A)C)2(B) = AAACAAACBB```

给一个字符串，求它的最短折叠。

例如 ```AAAAAAAAAABABABCCD``` 的最短折叠为：```9(A)3(AB)CCD```。
## 输入格式

仅一行，即字符串 `S`，长度保证不超过 $100$。
## 输出格式

仅一行，即最短的折叠长度。
## 样例

### 样例输入 #1
```
NEERCYESYESYESNEERCYESYESYES
```
### 样例输出 #1
```
14
```
## 提示

一个最短的折叠为：`2(NEERC3(YES))`


---

---
title: "[CTSC2014] 企鹅 QQ"
layout: "post"
diff: 提高+/省选-
pid: P4503
tag: ['字符串', '2014', '哈希 hashing', 'CTSC/CTS']
---
# [CTSC2014] 企鹅 QQ
## 题目背景

PenguinQQ 是中国最大、最具影响力的 SNS（Social Networking Services）网站，以实名制为基础，为用户提供日志、群、即时通讯、相册、集市等丰富强大的互联网功能体验，满足用户对社交、资讯、娱乐、交易等多方面的需求。
## 题目描述

小 Q 是 PenguinQQ 网站的管理员，他最近在进行一项有趣的研究——哪些账户是同一个人注册的。经过长时间的分析，小Q发现同一个人注册的账户名称总是很相似的，例如 Penguin1，Penguin2，Penguin3……于是小 Q 决定先对这种相似的情形进行统计。

小 Q 定义，若两个账户名称是相似的，当且仅当这两个字符串等长且恰好只有一位不同。例如“Penguin1”和“Penguin2”是相似的，但“Penguin1”和“2Penguin”不是相似的。而小 Q 想知道，在给定的 $n$ 个账户名称中，有多少对是相似的。

为了简化你的工作，小Q给你的N 个字符串长度均等于L ，且只包含大小写字母、数字、下划线以及‘@’共64种字符，而且不存在两个相同的账户名称。
## 输入格式

第一行包含三个正整数 $N,L,S$。其中 $N$ 表示账户名称数量，$L$ 表示账户名称长度，$S$ 用来表示字符集规模大小，它的值只可能为 $2$ 或 $64$。

若 $S$ 等于 $2$，账户名称中只包含字符 `0` 和 `1` 共 $2$ 种字符；

若 $S$ 等于 $64$，账户名称中可能包含大小写字母、数字、下划线以及 `@` 共 $64$ 种字符。

随后 $N$ 行，每行一个长度为 $L$ 的字符串，用来描述一个账户名称。数据保证 $N$ 个字符串是两两不同的。
## 输出格式

仅一行一个正整数，表示共有多少对相似的账户名称。
## 样例

### 样例输入 #1
```
4 3 64
Fax
fax
max
mac
```
### 样例输出 #1
```
4
```
## 提示

$4$ 对相似的字符串分别为：Fax 与 fax，Fax 与 max，fax 与 max，max 与 mac。

测试点编号|$N$|$L$|$S$
:-:|:-:|:-:|:-:
$1$|$50$|$10$|$64$
$2$|$500$|$100$|$64$
$3$|$3000$|$100$|$2$
$4$|$3000$|$100$|$64$
$5$|$30000$|$50$|$2$
$6$|$30000$|$50$|$64$
$7$|$30000$|$200$|$2$
$8$|$30000$|$200$|$64$
$9$|$30000$|$200$|$2$
$10$|$30000$|$200$|$64$


---

---
title: "[国家集训队] 最长双回文串"
layout: "post"
diff: 提高+/省选-
pid: P4555
tag: ['字符串', '线段树', '集训队互测', '枚举', 'Manacher 算法']
---
# [国家集训队] 最长双回文串
## 题目描述

顺序和逆序读起来完全一样的串叫做回文串。比如 `acbca` 是回文串，而 `abc` 不是：`abc` 的顺序为 `abc`，逆序为 `cba`，不相同。

输入长度为 $n$ 的串 $S$，求 $S$ 的最长双回文子串 $T$，即可将 $T$ 分为两部分 $X, Y$（$|X|,|Y|≥1$）且 $X$ 和 $Y$ 都是回文串。
## 输入格式

一行由小写英文字母组成的字符串 $S$。
## 输出格式

一行一个整数，表示最长双回文子串的长度。
## 样例

### 样例输入 #1
```
baacaabbacabb
```
### 样例输出 #1
```
12
```
## 提示

**样例说明**

从第二个字符开始的字符串 `aacaabbacabb` 可分为 `aacaa` 与 `bbacabb` 两部分，且两者都是回文串。

**数据范围**

对于 $100\%$ 的数据，$2\leq |S|\leq 10^5$。

2018.12.10，2018.12.15：感谢 @Ycrpro 提供 hack 数据两组。


---

---
title: "[IOI 2008] Type Printer"
layout: "post"
diff: 提高+/省选-
pid: P4683
tag: ['字符串', '2008', 'IOI', 'Special Judge', '深度优先搜索 DFS', '字典树 Trie']
---
# [IOI 2008] Type Printer
## 题目描述

你需要利用一台可移动的打印机打印出 $n$ 个单词。这种可移动式打印机是一种老式打印机，它需要你将一些小的金属块（每个包含一个字母）放到打印机上以组成单词。然后将这些小金属块压在一张纸上以打印出这个词。这种打印机允许你进行下列操作： 

- 在打印机当前词的末端（尾部）添加一个字母； 
- 在打印机当前词的尾部删去一个字母（将打印机当前词的最后一个字母删去）。仅当打印机当前至少有一个字母时才允许进行该操作；
- 将打印机上的当前词打印出来。 

初始时打印机为空，或者说它不含任何带字母的金属块。打印结束时，允许有部分字母留在打印机内。同时也允许你按照任意的次序打印单词。

由于每一个操作都需要一定时间，所以需要你尽可能减少所需操作的总数目（将操作的总数最小化）。

你需要编写一个程序，给定所要打印的 $n$ 个单词，找出以任意次序打印所有单词所需操作的最小数目，并输出一种这样的操作序列。
## 输入格式

- 第 $1$ 行包含一个整数 $n$, 表示你需要打印的单词数。 	
- 随后的 $n$ 行中，每一行都包含一个单词。每个词仅由小写字母组成，而且单词的长度为 $1$ 到 $20$ 个字母（包含 $1$ 和 $20$ 在内）。所有单词都不相同。
## 输出格式

第一行包含一个整数 $m$，表示打印这 $n$ 个单词所需操作的最小数目。

接下来的 $m$ 行，每行一个字符，表示你的操作序列，序列的描述方法如下：
- 添加一个字母，用这个小写字母的自身来表示。
- 删去一个字母，用 `-` 表示。
- 打印单词，用 `P` 表示。
## 样例

### 样例输入 #1
```
3
print
the
poem
```
### 样例输出 #1
```
20
t
h
e
P
-
-
-
p
o
e
m
P
-
-
-
r
i
n
t
P
```
## 提示

对于 $40\%$ 的数据，$n\leq18$；

对于 $100\%$ 的数据，$1\leq n\leq25000$。


---

---
title: "[BalticOI 2018] 火星人的 DNA"
layout: "post"
diff: 提高+/省选-
pid: P4792
tag: ['字符串', '2018', '枚举', '前缀和', 'BalticOI（波罗的海）']
---
# [BalticOI 2018] 火星人的 DNA
## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day1「[Martian DNA](https://boi18-day1-open.kattis.com/problems/boi18.dna)」**

给定一个字符集大小 $|\Sigma| = K$ 的长度为 $N$ 的字符串和 $R$ 个要求，每个要求为使子串中的字符 $B$ 至少出现 $Q$ 次。求出满足所有要求的最短子串长度。
## 输入格式

第一行包括三个整数 $N,\, K,\, R$，分别表示字符串的长度、字符集的大小和要求个数，保证 $1\leqslant R\leqslant K\leqslant N$。  
第二行包含 $N$ 个用空格隔开的整数，表示这个字符串。字符从 $0$ 开始编号，每个字符集中的字符至少出现一次。  
接下来的 $R$ 行，每行两个整数 $B$ 和 $Q$，表示一组要求，满足 $0\leqslant B < K,\, 1\leqslant Q\leqslant N$，同一个字符不会被重复要求两次。
## 输出格式

输出一个整数，满足所有要求的最短子串长度。特别地，如果不存在这样的子串，输出 "``impossible``"。
## 样例

### 样例输入 #1
```
5 2 2
0 1 1 0 1
0 1
1 1
```
### 样例输出 #1
```
2

```
### 样例输入 #2
```
13 4 3
1 1 3 2 0 1 2 0 0 0 0 3 1
0 2
2 1
1 2
```
### 样例输出 #2
```
7

```
### 样例输入 #3
```
5 3 1
1 2 0 1 2
0 2
```
### 样例输出 #3
```
impossible

```
## 提示

#### 样例 1 解释

有三个长度为 $2$ 的子串含有字符 $0$ 和 $1$ 各一个，分别为 ``0 1``、``1 0`` 和 ``0 1``，但是不存在长度为 $1$ 的子串满足要求，因此满足要求的最短子串的长度为 $2$。

#### 样例 2 解释

最短的满足要求的子串为 ``1 3 2 0 1 2 0``。

#### 样例 3 解释

在这个字符串中，``0`` 的数量不足。

| 子任务 | 分值 | 限制 |
|:--------:|:------:|:------:|
|$1$     |$16$  |$1\leqslant N\leqslant 100,\, R\leqslant 10$|
|$2$     |$24$  |$1\leqslant N\leqslant 4\, 000,\, R\leqslant 10$|
|$3$     |$28$  |$1\leqslant N\leqslant 200\, 000,\, R\leqslant 10$|
|$4$     |$32$  |$1\leqslant N\leqslant 200\, 000$|


感谢 Hatsune_Miku 提供的翻译


---

---
title: "[USACO15FEB] Censoring S"
layout: "post"
diff: 提高+/省选-
pid: P4824
tag: ['字符串', '2015', '线段树', 'USACO', '栈']
---
# [USACO15FEB] Censoring S
## 题目描述

Farmer John has purchased a subscription to Good Hooveskeeping magazine for his cows, so they have plenty of material to read while waiting around in the barn during milking sessions. Unfortunately, the latest issue contains a rather inappropriate article on how to cook the perfect steak, which FJ would rather his cows not see (clearly, the magazine is in need of better editorial oversight).

FJ has taken all of the text from the magazine to create the string $S$ of length at most 10^6 characters. From this, he would like to remove occurrences of a substring $T$ to censor the inappropriate content. To do this, Farmer John finds the **_first_** occurrence of $T$ in $S$ and deletes it. He then repeats the process again, deleting the first occurrence of $T$ again, continuing until there are no more occurrences of $T$ in $S$. Note that the deletion of one occurrence might create a new occurrence of $T$ that didn't exist before.

Please help FJ determine the final contents of $S$ after censoring is complete.
## 输入格式

The first line will contain $S$. The second line will contain $T$. The length of $T$ will be at most that of $S$, and all characters of $S$ and $T$ will be lower-case alphabet characters (in the range a..z). 
## 输出格式

The string $S$ after all deletions are complete. It is guaranteed that $S$ will not become empty during the deletion process. 
## 样例

### 样例输入 #1
```
whatthemomooofun
moo
```
### 样例输出 #1
```
whatthefun
```
## 题目翻译

### 题目描述

Farmer John 为他的奶牛订阅了《Good Hooveskeeping》杂志，但最新一期包含了一篇不恰当的牛排烹饪文章。为此，FJ 需要将杂志文字组成的字符串 $S$（长度不超过 $10^6$）中所有出现的子串 $T$ 进行删除处理。

删除规则如下：反复找到当前 $S$ 中第一个出现的子串 $T$ 并删除，直到 $S$ 中不再包含 $T$。注意，删除操作可能产生新的 $T$ 子串。

请输出最终处理完成的字符串 $S$。

### 输入格式

第一行输入字符串 $S$。  
第二行输入字符串 $T$。  
保证 $T$ 的长度不超过 $S$，且 $S$ 和 $T$ 均由小写字母组成。删除过程中保证 $S$ 不会变为空。

### 输出格式

输出处理完成后的字符串 $S$。


---

---
title: "【模板】AC 自动机"
layout: "post"
diff: 提高+/省选-
pid: P5357
tag: ['字符串', 'AC 自动机']
---
# 【模板】AC 自动机
## 题目背景

本题原为“AC 自动机（二次加强版）”。完成本题前可以先完成 [AC 自动机（简单版）](https://www.luogu.com.cn/problem/P3808) 和 [AC 自动机（简单版 II）](https://www.luogu.com.cn/problem/P3796) 两道题，为 AC 自动机更简单的应用。
## 题目描述

给你一个文本串 $S$ 和 $n$ 个模式串 $T_{1 \sim n}$，请你分别求出每个模式串 $T_i$ 在 $S$ 中出现的次数。
## 输入格式

第一行包含一个正整数 $n$ 表示模式串的个数。

接下来 $n$ 行，第 $i$ 行包含一个由小写英文字母构成的非空字符串 $T_i$。

最后一行包含一个由小写英文字母构成的非空字符串 $S$。

**数据不保证任意两个模式串不相同**。
## 输出格式

输出包含 $n$ 行，其中第 $i$ 行包含一个非负整数表示 $T_i$ 在 $S$ 中出现的次数。
## 样例

### 样例输入 #1
```
5
a
bb
aa
abaa
abaaa
abaaabaa

```
### 样例输出 #1
```
6
0
3
2
1

```
## 提示

对于 $100 \%$ 的数据，$1 \le n \le 2 \times {10}^5$，$T_{1 \sim n}$ 的长度总和不超过 $2 \times {10}^5$，$S$ 的长度不超过 $2 \times {10}^6$。


---

---
title: "【模板】子序列自动机"
layout: "post"
diff: 提高+/省选-
pid: P5826
tag: ['字符串', '线段树', 'O2优化', '可持久化', '有限状态自动机']
---
# 【模板】子序列自动机
## 题目背景

本题中，若 $x$ 是 $y$ 的子序列，则等价于存在一个**单调递增**序列 $z$，满足 $|z| = |x|$，$z_{|x|} \leq |y|$，且 $\forall i \in [1, ~|x|],~y_{z_i} = x_i$。其中 $|x|,~|y|,~|z|$ 分别代表序列 $x,~y,~z$ 的长度，$x_i,~y_i,~z_i$ 分别代表序列 $x,~y,~z$ 的第 $i$ 项。

这是一道在 ``yLOI2020`` 备选题里被毙掉的题目。
## 题目描述

给定一个长度为 $n$ 的正整数序列 $a$ ，有 $q$ 次询问，第 $i$ 次询问给定一个长度为 $L_i$ 的序列 $b_i$，请你判断 $b_i$ 是不是 $a$ 的子序列。序列 $a$ 和所有 $b_i$ 中的元素都不大于一个给定的正整数 $m$。
## 输入格式

每个测试点有且仅有一组数据。

输入的第一行是四个用空格隔开的整数，分别代表 $type,~n,~q,~m$。其中 $type$ 代表测试点所在的子任务编号，其余变量的含义见【题目描述】。

输入的第二行是 $n$ 个用空格隔开的整数，第 $i$ 个数字代表序列 $a$ 的第 $i$ 个元素 $a_i$。

第 $3$ 行至第 $(q + 2)$ 行，每行代表一次询问。第 $(i + 2)$ 行的输入格式为：

- 第 $(i + 2)$ 行的行首有一个整数 $l_i$，代表第 $i$ 次询问的序列长度。一个空格后有 $l_i$ 个用空格隔开的整数。该行的第 $(j + 1)$ 个整数代表序列 $b_i$ 的第 $j$ 个元素 $b_{i, j}$。
## 输出格式

对于每次询问，输出一行一个字符串，若给定的序列是 $a$ 的子序列，则输出 `Yes`，否则输出 `No`。
## 样例

### 样例输入 #1
```
0 5 5 5
1 3 2 2 4
3 1 5 2
2 3 2
3 1 2 3
3 1 2 4
5 1 3 2 2 4

```
### 样例输出 #1
```
No
Yes
No
Yes
Yes
```
## 提示

#### 样例 1 解释

- 对于第一次询问，原序列中没有 $5$，所以给定序列显然不是原序列的子序列。
- 对于第二次询问，存在两个合法的序列 $z$，分别是 $\{2,~3\}$ 和 $\{2,~4\}$。即 $a_{2} = b_{2, 1},~a_3 = b_{2, 2}$ 或 $a_2 = b_{2, 1},~a_{4} = b_{2, 2}$。这里 $b_{i, j}$ 代表序列 $b_i$ 的第 $j$ 个元素，序列 $z$ 的含义见【题目背景】，下同。
- 对于第三次询问，不存在合法的序列 $z$。
- 对于第四次询问，存在两个合法的序列 $z$，分别是 $\{1,~3,~5\}$ 和 $\{1,~4,~5\}$。
- 对于第五次询问，存在一个合法的序列 $z$，为 $\{1,~2,~3,~4,~5\}$。

#### 数据范围与约定

**本题采用多测试点捆绑测试，共有 3 个子任务**。

- Subtask 1（20 points）：$type = 1$，$n, q, m \leq 100$，$\sum_{i = 1}^{q} l_i \leq 10^3$。
- Subtask 2（35 points）：$type = 2$，$n,q \leq 10^5$，$m \leq 26$，$\sum_{i = 1}^{q} l_i \leq 10^6$。
- Subtask 3（45 points）：$type = 3$，$n,q,m \leq 10^5$，$\sum_{i = 1}^q L_i \leq 10^6$。

对于全部的测试点，保证 $1 \leq n, m, q \leq 10^5$，$1 \leq a_i, b_{i, j} \leq m$，$1 \leq l_i \leq 10^6$，$\sum_{i = 1}^{q} l_i \leq 10^6$。


### 提示

- 请注意常数因子对程序效率造成的影响。
- 本题输入规模较大，请注意数据读入对程序效率造成的影响。
- 请注意输入第一行的顺序为先输入询问次数 $q$，再输入序列元素最大值 $m$。


---

---
title: "【模板】失配树"
layout: "post"
diff: 提高+/省选-
pid: P5829
tag: ['字符串', '树形数据结构', 'KMP 算法']
---
# 【模板】失配树
## 题目描述

给定一个字符串 $s$，定义它的 **$k$ 前缀** $\mathit{pre}_k$ 为字符串 $s_{1\dots k}$，**$k$ 后缀** $\mathit{suf}_k$ 为字符串 $s_{|s|-k+1\dots |s|}$，其中 $1 \le k \le |s|$。

定义 $\bold{Border}(s)$ 为**对于 $i \in [1, |s|)$，满足 $\mathit{pre}_i = \mathit{suf}_i$** 的字符串 $\mathit{pre}_i$ 的集合。$\bold{Border}(s)$ 中的每个元素都称之为字符串 $s$ 的 $\operatorname{border}$。

有 $m$ 组询问，每组询问给定 $p,q$，求 $s$ 的 **$\boldsymbol{p}$ 前缀** 和 **$\boldsymbol{q}$ 前缀** 的 **最长公共 $\operatorname{border}$**  的长度。
## 输入格式

第一行一个字符串 $s$。

第二行一个整数 $m$。

接下来 $m$ 行，每行两个整数 $p,q$。
## 输出格式

对于每组询问，一行一个整数，表示答案。若不存在公共 $\operatorname{border}$，请输出 $0$。
## 样例

### 样例输入 #1
```
aaaabbabbaa
5
2 4
7 10
3 4
1 2
4 11

```
### 样例输出 #1
```
1
1
2
0
2

```
### 样例输入 #2
```
zzaaccaazzccaacczz
3
2 18
10 18
3 5

```
### 样例输出 #2
```
1
2
0

```
## 提示

样例 $2$ 说明：

对于第一个询问，$2$ 前缀和 $18$ 前缀分别是 ``zz`` 和 ``zzaaccaazzccaacczz``，由于 ``zz`` 只有一个 $\operatorname{border}$，即 ``z``，故最长公共 $\operatorname{border}$ 长度为 $1$。

---

对于 $16\%$ 的数据，$s$ 中的字符全部相等。

对于 $100\%$ 的数据，$1\leq p,q \le |s|\leq 10^6$，$1 \leq m \leq 10^5$，$s_i \in [\texttt{a}, \texttt{z}]$。


---

---
title: "[COCI 2016/2017 #1] Cezar"
layout: "post"
diff: 提高+/省选-
pid: P6286
tag: ['字符串', '2016', 'Special Judge', '拓扑排序', '字典树 Trie', 'COCI（克罗地亚）']
---
# [COCI 2016/2017 #1] Cezar
## 题目描述

Mirko 想对 $n$ 个单词进行加密。加密过程是这样的：

1.  选择一个英文字母表的排列作为密钥。
2.  将单词中的 `a` 替换为密钥中的第一个字母，`b` 替换为密钥中的第二个字母……以此类推。

例如，以 `qwertyuiopasdfghjklzxcvbnm` 作为密钥对 `cezar` 加密后，将得到 `etmqk`。

他希望，将所有单词加密并按字典序升序排列后，最初的第 $a_i$ 个单词位于第 $i$ 位。请你判断，这能否实现。如果能，请给出任意一种可行的密钥。
## 输入格式

第一行一个整数 $n$。

接下来 $n$ 行，每行一个字符串，表示待加密的单词。

最后一行 $n$ 个整数，表示 $a_i$。
## 输出格式

**本题使用 Special Judge**。

如果 Mirko 的要求不能实现，输出 `NE`。

否则，输出 `DA`。接下来一行输出任意一种可行的密钥。
## 样例

### 样例输入 #1
```
2
ab
bc
2 1 
```
### 样例输出 #1
```
DA
bacdefghijklmnopqrstuvwxyz 
```
### 样例输入 #2
```
3
abc
bcd
add
1 2 3 
```
### 样例输出 #2
```
NE 
```
### 样例输入 #3
```
3
bbb
ccc
ddd
2 3 1 
```
### 样例输出 #3
```
DA
adbcefghijklmnopqrstuvwxyz 
```
## 提示

#### 【样例解释】

**样例 1 解释**

以 `bacdefghijklmnopqrstuvwxyz` 为密钥加密后，得到：

- `ba`
- `ac`

字典序升序排列后，得到：

- `ac`
- `ba`

原先的第一个单词在第二位，第二个单词在第一位。符合要求。

**样例 3 解释**

以 `adbcefghijklmnopqrstuvwxyz`  为密钥加密后，得到：

- `ddd`
- `bbb`
- `ccc`

字典序升序排列后，得到：

- `bbb`
- `ddd`
- `ccc`

原先的第一个单词在第二位，第二个单词在第三位，第三个单词在第一位。符合要求。

---

#### 数据规模与约定

对于 $100\%$ 的数据，$2\le n\le 100$，$1 \leq a_i \leq n$。

所有单词的长度不超过 $100$，且只包含小写字母。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #1](https://hsin.hr/coci/archive/2016_2017/contest1_tasks.pdf) _T3 Cezar_**。


---

---
title: "[NOIP2020] 字符串匹配"
layout: "post"
diff: 提高+/省选-
pid: P7114
tag: ['字符串', '2020', '倍增', 'NOIP 提高组', '哈希 hashing']
---
# [NOIP2020] 字符串匹配
## 题目描述

小 C 学习完了字符串匹配的相关内容，现在他正在做一道习题。

对于一个字符串 $S$，题目要求他找到 $S$ 的所有具有下列形式的拆分方案数：

$S = ABC$，$S = ABABC$，$S = ABAB \ldots ABC$，其中 $A$，$B$，$C$ 均是非空字符串，且 $A$ 中出现奇数次的字符数量不超过 $C$ 中出现奇数次的字符数量。

更具体地，我们可以定义 $AB$ 表示两个字符串 $A$，$B$ 相连接，例如 $A = \texttt{aab}$，$B = \texttt{ab}$，则 $AB = \texttt{aabab}$。

并递归地定义 $A^1=A$，$A^n = A^{n - 1} A$（$n \ge 2$ 且为正整数）。例如 $A = \texttt{abb}$，则 $A^3=\texttt{abbabbabb}$。

则小 C 的习题是求 $S = {(AB)}^iC$ 的方案数，其中 $F(A) \le F(C)$，$F(S)$ 表示字符串 $S$ 中出现奇数次的字符的数量。两种方案不同当且仅当拆分出的 $A$、$B$、$C$ 中有至少一个字符串不同。

小 C 并不会做这道题，只好向你求助，请你帮帮他。
## 输入格式

本题有多组数据，输入文件第一行一个正整数 $T$ 表示数据组数。

每组数据仅一行一个字符串 $S$，意义见题目描述。$S$ 仅由英文小写字母构成。
## 输出格式

对于每组数据输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
3
nnrnnr
zzzaab
mmlmmlo

```
### 样例输出 #1
```
8
9
16

```
### 样例输入 #2
```
5
kkkkkkkkkkkkkkkkkkkk
lllllllllllllrrlllrr
cccccccccccccxcxxxcc
ccccccccccccccaababa
ggggggggggggggbaabab

```
### 样例输出 #2
```
156
138
138
147
194

```
### 样例输入 #3
```
见附件中的 string/string3.in
```
### 样例输出 #3
```
见附件中的 string/string3.ans
```
### 样例输入 #4
```
见附件中的 string/string4.in
```
### 样例输出 #4
```
见附件中的 string/string4.ans
```
## 提示

**【样例 #1 解释】**

对于第一组数据，所有的方案为

1. $A=\texttt{n}$，$B=\texttt{nr}$，$C=\texttt{nnr}$。
2. $A=\texttt{n}$，$B=\texttt{nrn}$，$C=\texttt{nr}$。
3. $A=\texttt{n}$，$B=\texttt{nrnn}$，$C=\texttt{r}$。
4. $A=\texttt{nn}$，$B=\texttt{r}$，$C=\texttt{nnr}$。
5. $A=\texttt{nn}$，$B=\texttt{rn}$，$C=\texttt{nr}$。
6. $A=\texttt{nn}$，$B=\texttt{rnn}$，$C=\texttt{r}$。
7. $A=\texttt{nnr}$，$B=\texttt{n}$，$C=\texttt{nr}$。
8. $A=\texttt{nnr}$，$B=\texttt{nn}$，$C=\texttt{r}$。

**【数据范围】**

| 测试点编号 | $\lvert S \rvert \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | 无 |
| $5 \sim 8$ | $100$ | 无 |
| $9 \sim 12$ | $1000$ | 无 |
| $13 \sim 14$ | $2^{15}$ | $S$ 中只包含一种字符 |
| $15 \sim 17$ | $2^{16}$ | $S$ 中只包含两种字符 |
| $18 \sim 21$ | $2^{17}$ | 无 |
| $22 \sim 25$ | $2^{20}$ | 无 |

对于所有测试点，保证 $1 \le T \le 5$，$1 \le |S| \le 2^{20}$。 


---

---
title: "「PMOI-2」拆分"
layout: "post"
diff: 提高+/省选-
pid: P7420
tag: ['字符串', '动态规划 DP', 'O2优化']
---
# 「PMOI-2」拆分
## 题目背景

### 如果您不看样例解释中的提示，那么您极可能做不出来！

![](https://cdn.luogu.com.cn/upload/image_hosting/n87yncfw.png)
## 题目描述

lhm 手中有一个字符串 $a$ 和它的子串 $b$，现你需要拆分字符串 $a$。

设 $c(s,b)$ 表示从字符串 $s$ 中选出一些互不重叠的、与 $b$ 相同的子串的最大子串数量。

若将 $a$ 拆分为 $k$ 组，第 $i$ 组记为 $p_i$，你需要保证：
- $k \geq 2$，
- $c(p_{i+1},b)>c(p_i,b)\ (i \in[1,k-1])$，
- $c(p_1,b)\geq 1$。

两种拆分方案不同当且仅当拆分出的组数不等或 $\exist i$，对应的 $c(p_i,b)$ 不等。

求不同的拆分方案总数，答案对 $899678209$ 取模。
## 输入格式

输入数据共两行。

第一行一个字符串 $a$，含义如题所示。

第二行一个字符串 $b$，含义如题所示。
## 输出格式

输出数据共一行。

一行一个整数，表示拆分的方案数对 $899678209$ 取模的结果。
## 样例

### 样例输入 #1
```
noinoinonoinoiionoinoinoionoi
noi
```
### 样例输出 #1
```
10
```
## 提示

【样例解释】

拆分的方式分别为：

`noi noinonoi noiionoinoinoionoi`，个数分别为 $1,2,5$。

`noi noinonoin oiionoinoinoionoi`，个数分别为 $1,2,4$。

`noino inonoinoiion oinoinoionoi`，个数分别为 $1,2,3$。

`noi noinonoinoi ionoinoinoionoi`，个数分别为 $1,3,4$。

`noi noinonoinoiionoinoinoionoi`，个数分别为 $1,7$。

`noinoi nonoinoiionoinoinoionoi`，个数分别为 $2,6$。

`noinoinonoi noiionoinoinoionoi`，个数分别为 $3,5$。

`noin oinonoinoiionoinoinoionoi`，个数分别为 $1,6$。

`noinoinono inoiionoinoinoionoi`，个数分别为 $2,5$。

`noinoinonoin oiionoinoinoionoi`，个数分别为 $3,4$。

**提示：样例解释足以说明可以拆分子串**。

【数据规模与约定】

请仔细阅读本栏。

**本题采用捆绑测试。**  

设 $n = c(a,b)$，$|a|=l_1$，$|b|=l_2$。  

| Subtask | 特殊性质 | 空间限制 | 分值 | 
| :----------: | :----------: | :----------: | :----------: |
| 1 | $l_1\leq 30$ | 256MiB | 9 |
| 2 | $n \le 300$ | 256MiB | 11 |
| 3 | $n \le 2000$ | 256MiB | 17 |
| 4 | $n \le 25000$ | 256MiB | 37 |
| 5 | 无 | 64MiB | 26 |

对于 $100\%$ 的数据，$0\le n\le2\times10^5$，$2\le l_2\le l_1\le10^6$，$b_1 \neq b_{l_2}$，$a$ 和 $b$ 只包含小写字母。


---

---
title: "[COCI 2015/2016 #2] SAVEZ"
layout: "post"
diff: 提高+/省选-
pid: P7861
tag: ['字符串', '2015', 'COCI（克罗地亚）']
---
# [COCI 2015/2016 #2] SAVEZ
## 题目描述

有一个秘密行星 S4 居住着一种奇特的动物，它们的学名是 Loda。Savez 协会派出了一个由 Henrik 将军领导的小组来研究 Loda。Henrik 发现，Loda 有心灵传输的能力，他想在他的军队里雇佣他们。

一只 Loda 由 $N$ 个字符串组成，其中第 $i$ 个字符串记为 $x_i$。研究表明，Loda 能进行的心灵传输次数取决于组成它的字符串的一个特殊子序列（不一定是连续的）。字符串 $x_i$ 和 $x_j$ $(i<j)$ 都可以在该子序列中，当且仅当字符串 $x_j$ 以 $x_i$ 开头并以 $x_i$ 结尾。一只 Loda 可以进行的心灵传输次数是组成它的字符串的合法的最长子序列的长度，而你就需要确定它可以进行心灵传输的次数。
## 输入格式

第一行一个整数 $N$，表示组成某一只 Loda 的字符串总数。

接下来 $N$ 行，每行一个仅由大写英文字母构成的字符串 $x_i$，表示构成这一只 Loda 的字符串。
## 输出格式

一行一个整数，表示这只 Loda 可以进行心灵传输的次数。
## 样例

### 样例输入 #1
```
5
A
B
AA
BBB
AAA
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
5
A
ABA
BBB
ABABA
AAAAAB
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
6
A
B
A
B
A
B
```
### 样例输出 #3
```
3
```
## 提示

**【样例 1 解释】**

一个最长的子序列为 `A AA AAA`。

**【样例 3 解释】**

子序列中的字符串允许相等，因此一个最长的子序列为 `A A A B B`。

**【数据范围】**

对于 $100\%$ 的数据，$1\le N \le 2\times 10^6，1\le |x_i| \le 2\times 10^6$，**保证 $\sum |x_i|\le10^6$**。

**【说明】**

**本题数据点得分依原题，满分 120**。

题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #2](https://hsin.hr/coci/archive/2015_2016/contest2_tasks.pdf) **T4 SAVEZ**。


---

---
title: "[Cnoi2021] 符文破译"
layout: "post"
diff: 提高+/省选-
pid: P8112
tag: ['字符串', '贪心', '2021', 'O2优化', 'KMP 算法']
---
# [Cnoi2021] 符文破译
## 题目背景

Cirno 想要解读一本古老的魔法书。
## 题目描述

为了保护魔法书中记载的禁忌的魔法，撰写者将符咒的魔法词缀不加空格地连接在一起，形成一个符文串，记作 $\texttt{S}$。

而构成符文串的所有魔法词缀都被记载在更远古的先知所编写的魔法辞典中，记作 $\texttt{T}$。具体地，$\texttt{T}$ 的所有非空前缀均是一个合法的魔法词缀。

简洁是魔法书撰写的第一要务，所以使用的魔法词缀应该尽可能少。所以在破译魔法书时，将 $\texttt{S}$ 分解成的魔法词缀数越少，破译正确的可能性就越高。

Cirno 想知道，这本魔法书最少的魔法词缀划分段数是多少。

特别地，如果不存在一种合法的划分方案，则表明这本魔法书是假的。Cirno 将得到一个字符串 `Fake`。
## 输入格式

第一行，两个整数，表示 $|\texttt{T}|$，$|\texttt{S}|$。

第二行，一个字符串 $\texttt{T}$。

第三行，一个字符串 $\texttt{S}$。
## 输出格式

一行，一个整数或一个字符串 `Fake`，表示答案。
## 样例

### 样例输入 #1
```
3 5
aba
abaab
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
3 5
aba
ababa
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
3 5
aba
abbaa
```
### 样例输出 #3
```
Fake
```
## 提示

**数据范围与约定**

对于 $100\%$ 的数据，保证 $1\le |\texttt{S}|,|\texttt{T}|\le 10^7$，$\texttt{S}_x,\texttt{T}_x \in [\texttt{a},\texttt{z}]$。

**子任务**

Subtask1（$10$ points）：$\texttt{T}_x=\texttt{a}$。

Subtask2（$20$ points）：$|\texttt{S}|\le1000$。

Subtask3（$30$ points）：$|\texttt{S}|\le 10^6$。

Subtask4（$40$ points）：无特殊限制。


---

---
title: "[USACO23JAN] Find and Replace G"
layout: "post"
diff: 提高+/省选-
pid: P9016
tag: ['字符串', '搜索', 'USACO', '递归', '2023']
---
# [USACO23JAN] Find and Replace G
## 题目描述

Bessie is using the latest and greatest innovation in text-editing software, miV! Its powerful find-and-replace feature allows her to find all occurrences of a lowercase English letter $c$ and replace each with a nonempty string of lowercase letters $s$. For example, given the string `ball`, if Bessie selects $c$ to be `l` and $s$ to be `na`, the given string transforms into `banana`.

Bessie starts with the string `a` and transforms it using a number of these find-and-replace operations, resulting in a final string $S$. Since $S$ could be massive, she wants to know, given $l$ and $r$ with $1 \le l \le r \min(|S|,10^{18})$, what $S_{l\cdots r}$ (the substring of $S$ from the $l$-th to the $r$-th character inclusive) is.

It is guaranteed that the sum of $|s|$
over all operations is at most $2 \cdot 10^5$, and that $r−l+1 \le 2 \cdot 10^5$. 
## 输入格式

The first line contains $l, r$, and the number of operations.

Each subsequent line describes one operation and contains $c$ and $s$ for that operation. All characters are in the range `a` through `z`.


## 输出格式

Output the string $S_{l \cdots r}$ on a single line. 
## 样例

### 样例输入 #1
```
3 8 4
a ab
a bc
c de
b bbb
```
### 样例输出 #1
```
bdebbb
```
## 提示

### Explanation for Sample 1

The string is transformed as follows:

$$ \texttt{a} \rightarrow \texttt{ab} \rightarrow\texttt{bcb}\rightarrow \texttt{bdeb}\rightarrow \texttt{bbbdebbb} $$

### Scoring

 - Inputs $2-7$: $\sum |s|,r−l+1 \le 2000$
 - Inputs $8-15$: No additional constraints.
## 题目翻译

#### 【题目描述】
你有一个字符串 $S$，最开始里面只有一个字符 $\text{a}$，之后你要对这个字符串进行若干次操作，每次将其中每一个字符 $c$ 替换成某个字符串 $s$（例如对于字符串 $\text{ball}$，将其中的 $\text{l}$ 替换为 $\text{na}$ 后将会变为 $\text{banana}$）。现在给定 $l,r$，你需要输出 $S_{l\ldots r}$（也就是 $S$ 的第 $l$ 个字符到第 $r$ 个字符对应的子串）是什么。

#### 【输入格式】
第一行三个整数，分别表示 $l,r$ 和操作次数。

接下来每一行一个字符 $c$ 和一个字符串 $s$，意义见题目描述。

#### 【输出格式】
一行，表示对应的子串。

#### 【数据范围】
$l,r\le\min(\left | S \right |,10^{18})$；

$r-l+1\le2\times10^5$；

$\sum\left | s \right | \le 2\times 10^5$。

所有的字符串都只包含小写字母 $\text{a}-\text{z}$。

其中对于测试点 $2-7$，满足：

$r-l+1\le2000$，$\sum\left | s \right | \le 2000$。


---

---
title: "「SvR-2」Work"
layout: "post"
diff: 提高+/省选-
pid: P9089
tag: ['字符串', '二分', '洛谷原创', '后缀自动机 SAM', 'O2优化', '哈希 hashing', '洛谷月赛']
---
# 「SvR-2」Work
## 题目背景

 
## 题目描述

给定 $n$ 个**由小写字母组成**的字符串，定义第 $i$ 个字符串的价值为其有意义的子串的数量（**如果有多个本质相同的子串也统计多次**），第 $i$ 个字符串的一个子串有意义，当且仅当这个子串能被分成若干个串，其中每个串都是这 $n$ 个字符串中任意一个字符串的任意一个后缀。

这里有一个 $n=4$ 的例子：
```plain
int
printf
scanf
ntnt
```

- 对于 `printf` 这个字符串而言，`intf` 是有意义的，因为可以表示成 `int` 和 `f` ，分别是 `int` 和 `scanf` 的后缀，而 `rint` 则不是。

- 对于 `ntnt` 这个字符串而言，`ntnt` 也是有意义的，因为可以表示成 `nt` 和 `nt`，它们都是 `int` 同一个后缀，或者可以表示成 `ntnt`，是 `ntnt` 的一个后缀。

现在，小 Z 想知道这 $n$ 个字符串价值之和。
## 输入格式

第一行一个整数 $n$。

之后 $n$ 行，每行一个字符串。
## 输出格式

一行一个整数，表示价值之和。
## 样例

### 样例输入 #1
```
4
int
printf
scanf
ntnt
```
### 样例输出 #1
```
23
```
### 样例输入 #2
```
4
ireallywanttobemissjiaransdog
butmissjiaransaidthatshelikedcatsandicried
iknowwhyicrywheniamneitheradognoracatbecauseimactuallyamouse
ineverexpectedmissjiarantolikeherselfiunderstandthatallpeopleliketounderstandthecutedogorcatthatyuyuusestomakemoneyandnoonelikesthemousewithwetandwetdiseases
```
### 样例输出 #2
```
391
```
## 提示

#### 数据规模与约定

**本题开启捆绑测试和 O2 优化。**

令 $s_i$ 表示第 $i$ 个字符串长度。
| Subtask | 数据范围/特殊性质 | 分值 |
| :------: | :------: | :------: |
| $1$ |  $n\le 3$，$\sum\limits \lvert s_i\rvert\le10$| $5 \operatorname{pts}$ |
| $2$ | $n=26$，每种字符串均由一种字符组成 | $5 \operatorname{pts}$ |
| $3$ |$n=1$ | $15 \operatorname{pts}$ |
| $4$ | $\sum\limits \lvert s_i \rvert \le 2000$ | $15 \operatorname{pts}$ |
| $5$ | $\sum\limits \lvert s_i \rvert \le 2\times10^5$ | $30 \operatorname{pts}$ |
| $6$ | $\sum\limits \lvert s_i \rvert \le 10^6$ | $30 \operatorname{pts}$ |

对于 $100\%$ 的数据，$1\le n \le 5\times10^5$，$n\le \sum\limits \lvert s_i \rvert \le 10^6$。


---

---
title: "串串题"
layout: "post"
diff: 提高+/省选-
pid: P9149
tag: ['字符串', '数学', '洛谷原创', 'O2优化', '组合数学', 'KMP 算法', '洛谷月赛']
---
# 串串题
## 题目描述

给定长度分别为 $n,m$ 的整数序列 $A,B$ 和常数 $W,d$，序列从 $1$ 开始标号，保证 $A_i,B_i \in [1,W]$。

容易发现，我们有 $\binom{W}{d}$ 种方案选择 $[1,W]$ 中的 $d$ 个互不相同的整数。

对于每一种选择的方案，我们删去 $A$ 中出现的对应的 $d$ 种整数，令此时序列 $B$ 在序列 $A$ 中的出现次数为这次选择方案的权值。

你需要求所有的选择方案的权值和，对 ${10}^9+7$ 取模。

若对题意有疑问，请阅读样例及样例解释。

注：$\binom{a}{b}$ 表示组合数，含义为在 $a$ 个物品中**无序**地选择出 $b$ 个物品的方案数。

**请注意：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**
## 输入格式

**本题有多组数据。**

第一行，一个正整数 $T$，表示数据组数。对于每组数据：

第一行，四个正整数 $n, m, W, d$，保证 $d \le W$。

第二行，$n$ 个正整数 $A_1, A_2, \ldots, A_n$，表示序列 $A$。

第三行，$m$ 个正整数 $B_1, B_2, \ldots, B_m$，表示序列 $B$。
## 输出格式

对于每组数据，输出一个整数表示答案对 ${10}^9+7$ 取模的结果。
## 样例

### 样例输入 #1
```
2
4 2 3 1
1 1 2 1
1 1
8 3 4 1
1 2 3 1 2 3 1 2
1 2 1

```
### 样例输出 #1
```
3
2

```
## 提示

**【样例解释】**

在样例的第一组数据中：

1. 如果我们选择删去 $A$ 中的字符 $1$，$A$ 将变为 $\{2\}$，此时 $B$ 在 $A$ 中的出现次数为 $0$。
1. 如果我们选择删去 $A$ 中的字符 $2$，$A$ 将变为 $\{1,1,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $2$。
1. 如果我们选择删去 $A$ 中的字符 $3$，$A$ 将变为 $\{1,1,2,1\}$，此时 $B$ 在 $A$ 中的出现次数为 $1$。

因此，第一组数据的答案为 $0+2+1=3$。

**再次提醒：我们并不会删除序列 $\bm{B}$ 中出现的对应整数。**

---

**【数据范围】**

对于 $100\%$ 的数据，$1 \le n,m,W \le {10}^6$，$1 \le d, A_i, B_j \le W$，$1 \le T \le 5$。

**本题采用捆绑测试且开启子任务依赖！**

| 子任务 | $n \le$ | $m \le$ | $W \le$ | 特殊性质 | 分数 | 依赖 |
| - | - | - | - | - | - | - |
| 1 | $10$ | $10$ | $5$ | | $10$ | \ |
| 2 | $1000$ | $1000$ | $5$ | | $20$ | 子任务 1 |
| 3 |  | | | A | $15$ | \ |
| 4 |  | | | B | $25$ | \ |
| 5 | | | | | $30$ | 子任务 1、2、3、4 |

特殊性质 A：保证 $d=1$。

特殊性质 B：令 $c$ 表示仅在序列 $A$ 中出现，而不在序列 $B$ 中出现的数字总数。保证 $c \le 5$。


---

---
title: "[USACO23OPEN] Pareidolia G"
layout: "post"
diff: 提高+/省选-
pid: P9190
tag: ['字符串', '动态规划 DP', 'USACO', '2023']
---
# [USACO23OPEN] Pareidolia G
## 题目背景

Pareidolia is the phenomenon where your eyes tend to see familiar patterns in
images where none really exist -- for example seeing a face in a cloud.  As you
might imagine, with Farmer John's constant proximity to cows, he often sees
cow-related patterns in everyday objects.  For example, if he looks at the
string "bqessiyexbesszieb", Farmer John's eyes ignore some of the letters and
all he sees is "bessiexbessieb" -- a string that has contains two contiguous
substrings equal to "bessie". 
## 题目描述

Given a string of length at most $2\cdot 10^5$ consisting only of characters
a-z, where each character has an associated deletion cost, compute the maximum
number of contiguous substrings that equal "bessie" you can form by deleting
zero or more characters from it, and the minimum total cost of the characters you need to
delete in order to do this.
## 输入格式

The first line contains the string. The second line contains the deletion cost
associated with each character (an integer in the range $\left[1,1000\right]$).
## 输出格式

The maximum number of occurrences, and the minimum cost to produce this number
of occurrences.
## 样例

### 样例输入 #1
```
besssie
1 1 5 4 6 1 1

```
### 样例输出 #1
```
1
4

```
### 样例输入 #2
```
bebesconsiete
6 5 2 3 6 5 7 9 8 1 4 5 1

```
### 样例输出 #2
```
1
21

```
### 样例输入 #3
```
besgiraffesiebessibessie
1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1

```
### 样例输出 #3
```
2
7

```
## 提示

For the first sample, by deleting the 's' at position 4 we can make the whole string "bessie". The
character at position 4 has a cost of $4$, so our answer is cost $4$ for $1$
instance of "bessie", which is the best we can do.

For the second sample, by deleting the "con" at positions 5-7, we can make the string "bebessiete"
which has "bessie" in the middle. Characters 5-7 have costs $5 + 7 + 9 = 21$, so
our answer is cost $21$ for $1$ instance of "bessie", which is the best we can
do.

For the third sample, by deleting the "giraffe" at positions 4-10, we can make the string
"bessiebessibessie", which has "bessie" at the beginning and the end. "giraffe"
has 7 characters and all characters have cost $1$, so our answer is cost $7$ for
$2$ instances of "bessie", which is the best we can do. This sample satisfies the constraints for the second subtask.

- Inputs 4-5: $N\le 2000$.
- Inputs 6-8: All costs are $1$.
- Inputs 9-17: No additional constraints.
## 题目翻译

### 题目背景

Pareidolia 是一种现象，指的是人们倾向于在并不真正存在的地方看到熟悉的图案——例如在云中看到一张脸。可以想象，由于农夫 John 经常与奶牛接触，他常常在日常物品中看到与奶牛相关的图案。例如，如果他看到字符串 "bqessiyexbesszieb"，农夫 John 的眼睛会忽略其中的一些字母，而他看到的只是 "bessiexbessieb"——一个包含两个连续子串等于 "bessie" 的字符串。

### 题目描述

给定一个长度不超过 $2 \cdot 10^5$ 的字符串，且仅由字符 a-z 组成，其中每个字符都有一个相关的删除成本。计算通过删除零个或多个字符后，能够形成的等于 "bessie" 的连续子串的最大数量，以及为了实现这一目标所需删除字符的最小总成本。

### 输入格式

第一行包含字符串。第二行包含每个字符的删除成本（一个在 $\left[1,1000\right]$ 范围内的整数）。

### 输出格式

输出最大数量的 "bessie" 出现次数，以及实现这一数量所需的最小成本。

### 提示

对于第一个样例，通过删除位置 4 的 's'，我们可以使整个字符串变为 "bessie"。位置 4 的字符成本为 $4$，因此我们的答案是成本 $4$ 得到 $1$ 个 "bessie"，这是我们可以做到的最佳结果。

对于第二个样例，通过删除位置 5-7 的 "con"，我们可以使字符串变为 "bebessiete"，其中包含中间的 "bessie"。位置 5-7 的字符成本为 $5 + 7 + 9 = 21$，因此我们的答案是成本 $21$ 得到 $1$ 个 "bessie"，这是我们可以做到的最佳结果。

对于第三个样例，通过删除位置 4-10 的 "giraffe"，我们可以使字符串变为 "bessiebessibessie"，其中包含开头和结尾的 "bessie"。"giraffe" 有 7 个字符，且所有字符的成本均为 $1$，因此我们的答案是成本 $7$ 得到 $2$ 个 "bessie"，这是我们可以做到的最佳结果。此样例满足第二个子任务的约束条件。

- 输入 4-5：$N \le 2000$。
- 输入 6-8：所有成本均为 $1$。
- 输入 9-17：没有额外限制。


---

---
title: "[EC Final 2021] Beautiful String"
layout: "post"
diff: 提高+/省选-
pid: P9873
tag: ['字符串', '2021', 'O2优化', 'ICPC']
---
# [EC Final 2021] Beautiful String
## 题目描述

Prof. Pang recently got a dictionary of the elvish language, including many strings representing their words. He thinks a partition of string $s$ is beautiful if both of the following conditions are satisfied:

- $s = s_1 + s_2 + s_3 + s_4 + s_5 + s_6$, where $s_i (1\leq i\leq 6)$ are nonempty substrings. $a + b$ means the concatenation of string $a$ and $b$ here.
- $s_1 = s_2 = s_5, s_3 = s_6$.


For example, you can partition the string ``114514`` into $6$ parts : ``114514`` = ``1`` + ``1`` + ``4`` + ``5`` + ``1`` + ``4``. The first, second, fifth parts are the same, and the third and sixth parts are the same. Thus, the partition of $s=$``114514`` into $s_1=$``1``, $s_2=$``1``, $s_3=$``4``, $s_4=$``5``, $s_5=$``1``, and $s_6=$``4`` is beautiful. 

Accordingly, the beauty of a string $s$ is defined as the number of beautiful partitions of $s$.

Given a string $t$, please help Prof. Pang to figure out the sum of beauties of all substrings of $t$.

## 输入格式

The first line contains a single integer $T~(1\leq T \le 50)$ indicating the number of test cases. 

For each test case, there is one single line containing the string $t$, consisting of digits from `0' to `9'.

It is guaranteed that the length of each $t$ in each test case will not exceed $5000$ and the total length will not exceed $30000$.
## 输出格式

For each test case, output a single line containing an integer, indicating the sum of beauties of all substrings of $t$.
## 样例

### 样例输入 #1
```
2
114514
0000000
```
### 样例输出 #1
```
1
3
```
## 题目翻译

当字符串 $s$ 的一个**划分**满足如下条件：

- $s = s_1 + s_2 + s_3 + s_4 + s_5 + s_6$，其中 $s_i (1\leq i\leq 6)$ 为非空子串，$a + b$ 表示将字符串 $b$ 接于 $a$ 后。

- $s_1 = s_2 = s_5, s_3 = s_6$。

则称该**划分**是**美丽的**。

字符串 $s$ 的**美丽值**定义为 $s$ 的不同的**美丽的划分**的个数。

给出字符串 $s$，求其**所有子串**的**美丽值之和**。


---

---
title: "[NFLSPC #6] 绝不能忘记的事……"
layout: "post"
diff: 提高+/省选-
pid: P9934
tag: ['字符串', 'O2优化', '哈希 hashing', '字典树 Trie']
---
# [NFLSPC #6] 绝不能忘记的事……
## 题目背景

> 那件事…… 绝对不能忘记！
## 题目描述

你在电脑内记录了一条绝对不能忘记的事。但是，因为 1064 病毒的入侵，它被电脑忘记了。更可怕的是，1064 病毒似乎拥有某种跨物种传播的能力，导致你也忘记了这件事。

万幸，在 1064 病毒让你和你的电脑忘记这件事之前，你及时将这件事的记录复制了 $n$ 份。但是，由于你和你的电脑在执行这件艰巨的任务的过程中受到 1064 病毒的影响忘记了很多可以忘记的事，所以你进行的操作有点奇怪。

- 首先，这件事的记录是一个长度未知（因为你已经忘记了它的长度）的字符串，称作 **记录串**。对于一份复制，你将记录串切成了三段非空的字符串 **片段**。**不同复制的场合，切割的方案不一定相同**。你暂且将这三份 **片段** 依次称作 **前面**，**中间** 和 **后面**。
- 因为电脑忘记了很多可以忘记的事，所以某些复制中的某些片段可能被忘记了。具体而言，前面有可能被替换为 `QIANMIANWANGLE`，中间有可能被替换为 `ZHONGJIANWANGLE`，后面有可能被替换为 `HOUMIANWANGLE`；在发生替换的场合，表示电脑 **完全忘记** 了这一段片段；否则，表示电脑 **完全记得** 该片段。
- 你终于想起了一件绝不能忘记的事：那就是那绝不能忘记的记录串中，**恰出现了一次** `NFLSPC#6QIDONG` 作为连续子串。除此之外，记录串中的所有其它字符都是 **小写英文字符**。并且，因为你和你的电脑始终记得这件事有多么重要，所以你在划分的时候，无意中让某一个片段恰好为 `NFLSPC#6QIDONG`；你的电脑也在每一份记录中忠实地记得这一段片段。
- 于是，你的电脑最终还记得的东西，就是：$n$ 份复制，每份复制由三段非空字符串构成，依次表示这份复制的三份片段；其中恰有一段为 `NFLSPC#6QIDONG`，另外两段要么是一串仅由小写英文字母构成的非空串，要么是对应的前面/中间/后面忘了。
- 邪恶的 1064 病毒不肯罢休，它篡改了你电脑中的信息，使得你的 $n$ 份复制不一定是自洽的。

你确信 1064 病毒没有能力篡改过多的信息，并且它绝对敌不过你和你的电脑对彼此牢牢记住的 `NFLSPC#6QIDONG` 的信念。因此，你的复制仍然满足上文中所述的性质（恰有一段是 `NFLSPC#6QIDONG`，另外两段要么忘了要么是小写字母非空串）。

你的目标是，寻找到初始的那绝不能忘记的记录串。这个记录串需要满足的条件是，恰出现一次 `NFLSPC#6QIDONG`，其余字符均是小写英文字符，且其匹配尽量多的复制串。

- 记录串与复制串匹配的要求是，记录串存在一种划分，使得三段划分与复制串的三段分别相同，或者复制串中这段划分忘了（此时本段划分中，记录串为任何非空英文字符串均合法）。

你希望求出该记录串能匹配的最多复制串数目。至于记录串本身，你更希望将它深深地埋藏于心底，因此你不需要求出它。

> 那忘记的事只会使你的心灵更加轻盈 / 那未曾忘记的事则会让你的心灵更加坚硬 /
## 输入格式

**为了避免输入量过大，输入进行了一定程度的压缩。请务必认真阅读输入格式**。

第一行一个正整数 $n$，表示记录数目。

接下来 $n$ 行，每行三个非空字符串，其中第一段要么是非空小写字符串，要么是 `Q`（表示 `QIANMIANWANGLE`），要么是 `N`（表示 `NFLSPC#6QIDONG`），不存在其它可能；第二段则是非空小写字符串、`Z`（表示 `ZHONGJIANWANGLE`）、`N` 三者之一；最后一段是非空小写字符串、`H`（表示 `HOUMIANWANGLE`）、`N` 三者之一。保证三段中恰有一段为 `N`。
## 输出格式

一行一个整数，表示所有记录串中，能匹配的最多的复制的数目。
## 样例

### 样例输入 #1
```
3
N Z H
Q N H
Q Z N

```
### 样例输出 #1
```
1

```
## 提示

对于所有数据，保证输入的所有字符串长度之和不超过 $10 ^ 6$。

- 子任务 1（$20$ 分）：保证复制中除了 `NFLSPC#6QIDONG` 恰出现一次以外，其它部分全部忘记。也即，输入的复制串仅可能为 `N Z H`，`Q N H`，`Q Z N` 三者之一。
- 子任务 2（$30$ 分）：保证所有复制串的 “后面” 段都是 `NFLSPC#6QIDONG`。也即，输入的复制串必然形如 `* * N`，其中 `*` 指代任意符合格式的输入。
- 子任务 3（$50$ 分）：无特殊限制。

Source：NFLSPC #6 J by Troverld


---


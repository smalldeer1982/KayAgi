---
title: "单词游戏"
layout: "post"
diff: 提高+/省选-
pid: P1278
tag: ['记忆化搜索', '状压 DP']
---
# 单词游戏
## 题目描述

Io 和 Ao 在玩一个单词游戏。

他们轮流说出一个仅包含元音字母的单词，并且后一个单词的第一个字母必须与前一个单词的最后一个字母一致。

游戏可以从任何一个单词开始。

任何单词禁止说两遍，游戏中只能使用给定词典中含有的单词。

游戏的复杂度定义为游戏中所使用的单词长度总和。

编写程序，求出使用一本给定的词典来玩这个游戏所能达到的游戏最大可能复杂度。

## 输入格式

输入文件的第一行，表示一个自然数 $N(1 \le N \le 16)$，$N$ 表示一本字典中包含的单词数量以下的每一行包含字典中的一个单词，每一个单词是由字母 `A`、`E`、`I`、`O` 和 `U` 组成的一个字符串，每个单词的长度将小于等于 $100$，所有的单词是不一样的。

## 输出格式

输出文件仅有一行，表示该游戏的最大可能复杂度。

## 样例

### 样例输入 #1
```
5

IOO

IUUO

AI

OIOOI

AOOI
```
### 样例输出 #1
```
16
```


---

---
title: "[GCJ 2014 #1B] New Lottery Game"
layout: "post"
diff: 提高+/省选-
pid: P13251
tag: ['2014', '分治', '记忆化搜索', '数位 DP', '位运算', 'Google Code Jam']
---
# [GCJ 2014 #1B] New Lottery Game
## 题目描述

The Lottery is changing! The Lottery used to have a machine to generate a random winning number. But due to cheating problems, the Lottery has decided to add another machine. The new winning number will be the result of the bitwise-AND operation between the two random numbers generated by the two machines.

To find the bitwise-AND of $X$ and $Y$, write them both in binary; then a bit in the result in binary has a $1$ if the corresponding bits of $X$ and $Y$ were both $1$, and a $0$ otherwise. In most programming languages, the bitwise-AND of $X$ and $Y$ is written $X \& Y$.

For example:
- The old machine generates the number $7 = 0111$.
- The new machine generates the number $11 = 1011$.
- The winning number will be $(7 \text{ AND } 11) = (0111 \text{ AND } 1011) = 0011 = 3$.

With this measure, the Lottery expects to reduce the cases of fraudulent claims, but unfortunately an employee from the Lottery company has leaked the following information: the old machine will always generate a non-negative integer less than $A$ and the new one will always generate a non-negative integer less than $B$.

Catalina wants to win this lottery and to give it a try she decided to buy all non-negative integers less than $K$.

Given $A$, $B$ and $K$, Catalina would like to know in how many different ways the machines can generate a pair of numbers that will make her a winner.

Could you help her?
## 输入格式

The first line of the input gives the number of test cases, $T$. $T$ lines follow, each line with three numbers $A$ $B$ $K$.

## 输出格式

For each test case, output one line containing "Case #$x$: $y$", where $x$ is the test case number (starting from $1$) and $y$ is the number of possible pairs that the machines can generate to make Catalina a winner.
## 样例

### 样例输入 #1
```
5
3 4 2
4 5 2
7 8 5
45 56 35
103 143 88
```
### 样例输出 #1
```
Case #1: 10
Case #2: 16
Case #3: 52
Case #4: 2411
Case #5: 14377
```
## 提示

**Sample Explanation**

In the first test case, these are the 10 possible pairs generated by the old and new machine respectively that will make her a winner: $\langle 0,0\rangle, \langle 0,1\rangle, \langle 0,2\rangle, \langle 0,3\rangle, \langle 1,0\rangle$, $\langle 1,1\rangle, \langle 1,2\rangle, \langle 1,3\rangle, \langle 2,0\rangle$ and $\langle 2,1\rangle$. Notice that $\langle 0,1\rangle$ is not the same as $\langle 1,0\rangle$. Also, although the pair $\langle 2, 2\rangle$ could be generated by the machines it wouldn't make Catalina win since $(2 \text{ AND } 2) = 2$ and she only bought the numbers $0$ and $1$.

**Limits**

- $1 \leq T \leq 100$.

**Small dataset(8 Pts)**

- $1 \leq A \leq 1000$.
- $1 \leq B \leq 1000$.
- $1 \leq K \leq 1000$.

**Large dataset(24 Pts)**

- Time limit: $120$ seconds.
- $1 \leq A \leq 10^9$.
- $1 \leq B \leq 10^9$.
- $1 \leq K \leq 10^9$.


---

---
title: "[GCJ 2014 #3] Last Hit"
layout: "post"
diff: 提高+/省选-
pid: P13261
tag: ['动态规划 DP', '2014', '记忆化搜索', 'Google Code Jam']
---
# [GCJ 2014 #3] Last Hit
## 题目描述

Diana needs your help maximizing her gold while playing her favorite game. She is often faced with a scenario where she is standing close to her tower and is facing $\mathbf{N}$ monsters. When that happens, Diana and the tower take turns shooting the monsters, and she goes first. During her turn, Diana may choose a monster to shoot at (this means Diana may choose to skip a turn). During its turn, the tower shoots the monster closest to it. Diana and the tower can not shoot dead monsters.

If Diana shoots at a monster, its hit points are reduced by $\mathbf{P}$. If the tower shoots at a monster, its hit points are reduced by $\mathbf{Q}$. If a monster's hit points are reduced below 1, it is killed. The $i^{\text {th }}$ monster starts with $\mathbf{H}_{\mathrm{i}}$ hit points. Diana is awarded $\mathbf{G}_{\mathrm{i}}$ gold if her shot kills the $i^{\text {th }}$ monster, but none if the tower's shot kills it. What is the maximum amount of gold Diana can obtain?
## 输入格式

The first line of the input gives the number of test cases, $\mathbf{T}$. $\mathbf{T}$ test cases follow. Each case begins with one line containing three space-separated integers representing $\mathbf{P}, \mathbf{Q}$ and $\mathbf{N}$. $\mathbf{N}$ lines then follow, with the $i^{\text {th }}$ line containing two space-separated integers representing $\mathbf{H}_{\mathrm{i}}$ and $\mathbf{G}_{\mathrm{i}}$.

The monsters are given in the order of their distance from the tower. In other words, the tower will shoot at the $i^{\text {th }}$ monster only if all monsters $<i$ are dead.
## 输出格式

For each test case, output one line containing "Case #x: $y$", where x is the case number (starting from 1) and $y$ is the maximum amount of gold that Diana can obtain.
## 样例

### 样例输入 #1
```
2
20 40 3
100 100
20 100
60 100
20 60 3
80 100
80 200
120 300
```
### 样例输出 #1
```
Case #1: 300
Case #2: 500
```
## 提示

**Sample Explanation**

In the second example, Diana should give up the first monster. During her first two turns she should soften up the third monster bringing it down to 80 hp, allowing her to easily get the last shot on the second and the third monsters.

**Limits**

- $1 \leq T \leq 100$
- $20 \leq \mathbf{P} \leq 200$
- $20 \leq \mathbf{Q} \leq 200$
- $1 \leq \mathbf{H}_{\mathrm{i}} \leq 200$
- $0 \leq \mathbf{G}_{\mathrm{i}} \leq 10^{6}$

**Small dataset(10 Pts)**

- Time limit: ~~60~~ 3 seconds.
- $1 \leq \mathbf{N} \leq 4$

**Large dataset(14 Pts)**

- Time limit: ~~120~~ 5 seconds.
- $1 \leq \mathbf{N} \leq 100$



---

---
title: "[HAOI2007] 分割矩阵"
layout: "post"
diff: 提高+/省选-
pid: P2217
tag: ['搜索', '2007', '河南', '各省省选', '记忆化搜索']
---
# [HAOI2007] 分割矩阵
## 题目描述

将一个 $a\times b$ 的数字矩阵进行如下分割：将原矩阵沿某一条直线分割成两个矩阵，再将生成的两个矩阵继续如此分割（当然也可以只分割其中的一个），这样分割了 $(n-1)$ 次后，原矩阵被分割成了 $n$ 个矩阵。（每次分割都只能沿着数字间的缝隙进行）

原矩阵中每一位置上有一个分值，一个矩阵的总分为其所含各位置上分值之和。现在需要把矩阵按上述规则分割成 $n$ 个矩阵，并使各矩阵总分的均方差最小。

请编程对给出的矩阵及 $n$，求出均方差的最小值。

## 输入格式

第一行为 $3$ 个整数，表示 $a,b,n(1<a,b,n\le 10)$ 的值。

第二行至第 $a+1$ 行每行为 $b$ 个小于 $100$ 的非负整数，表示矩阵中相应位置上的分值。每行相邻两数之间用一个空格分开。

## 输出格式

仅一个数，为均方差的最小值。（四舍五入精确到小数点后 $2$ 位）

## 样例

### 样例输入 #1
```
5 4 4

2 3 4 6

5 7 5 1

10 4 0 5

2 0 2 3

4 1 1 1


```
### 样例输出 #1
```
0.50
```


---

---
title: "[NOIP 2017 提高组] 逛公园"
layout: "post"
diff: 提高+/省选-
pid: P3953
tag: ['搜索', '2017', 'NOIP 提高组', '记忆化搜索', '最短路']
---
# [NOIP 2017 提高组] 逛公园
## 题目背景

NOIP2017 D1T3
## 题目描述

策策同学特别喜欢逛公园。公园可以看成一张 $N$ 个点 $M$ 条边构成的有向图，且没有 自环和重边。其中 $1$ 号点是公园的入口，$N$ 号点是公园的出口，每条边有一个非负权值， 代表策策经过这条边所要花的时间。

策策每天都会去逛公园，他总是从 $1$ 号点进去，从 $N$ 号点出来。

策策喜欢新鲜的事物，它不希望有两天逛公园的路线完全一样，同时策策还是一个 特别热爱学习的好孩子，它不希望每天在逛公园这件事上花费太多的时间。如果 $1$ 号点 到 $N$ 号点的最短路长为 $d$，那么策策只会喜欢长度不超过 $d + K$ 的路线。

策策同学想知道总共有多少条满足条件的路线，你能帮帮它吗？

为避免输出过大，答案对 $P$ 取模。

如果有无穷多条合法的路线，请输出 $-1$。

## 输入格式

第一行包含一个整数 $T$, 代表数据组数。

接下来 $T$ 组数据，对于每组数据： 第一行包含四个整数 $N,M,K,P$，每两个整数之间用一个空格隔开。


接下来 $M$ 行，每行三个整数 $a_i,b_i,c_i$，代表编号为 $a_i,b_i$ 的点之间有一条权值为 $c_i$ 的有向边，每两个整数之间用一个空格隔开。

## 输出格式

输出文件包含 $T$ 行，每行一个整数代表答案。

## 样例

### 样例输入 #1
```
2
5 7 2 10
1 2 1
2 4 0
4 5 2
2 3 2
3 4 1
3 5 2
1 5 3
2 2 0 10
1 2 0
2 1 0
```
### 样例输出 #1
```
3
-1


```
## 提示

【样例解释1】


对于第一组数据，最短路为 $3$。 $1\to 5, 1\to 2\to 4\to 5, 1\to 2\to 3\to 5$ 为 $3$ 条合法路径。


【测试数据与约定】

对于不同的测试点，我们约定各种参数的规模不会超过如下


测试点编号　　|$T$　　　|$N$　　　|$M$　　　|$K$　　　|是否有 $0$ 边
-|-|-|-|-|-
$1$|$5$|$5$|$10$|$0$|否
$2$|$5$|$10^3$|$2\times 10^3$|$0$|否
$3$|$5$|$10^3$|$2\times 10^3$|$50$|否
$4$|$5$|$10^3$|$2\times 10^3$|$50$|否
$5$|$5$|$10^3$|$2\times 10^3$|$50$|否
$6$|$5$|$10^3$|$2\times 10^3$|$50$|是
$7$|$5$|$10^5$|$2\times 10^5$|$0$|否
$8$|$3$|$10^5$|$2\times 10^5$|$50$|否
$9$|$3$|$10^5$|$2\times 10^5$|$50$|是
$10$|$3$|$10^5$|$2\times 10^5$|$50$|是


对于 $100\%$ 的数据，$1 \le P \le 10^9$，$1 \le a_i,b_i \le N$，$0 \le c_i \le 1000$。

数据保证：至少存在一条合法的路线。

---

- 2019.8.30 增加了一组 hack 数据 by @skicean
- 2022.7.21 增加了一组 hack 数据 by @djwj233


---

---
title: "[NOI2005] 聪聪与可可"
layout: "post"
diff: 提高+/省选-
pid: P4206
tag: ['搜索', '2005', 'NOI', '广度优先搜索 BFS', '深度优先搜索 DFS', '记忆化搜索', '期望']
---
# [NOI2005] 聪聪与可可
## 题目描述

在一个魔法森林里，住着一只聪明的小猫聪聪和一只可爱的小老鼠可可。虽然灰姑娘非常喜欢她们俩，但是，聪聪终究是一只猫，而可可终究是一只老鼠，同样不变的是，聪聪成天想着要吃掉可可。

一天，聪聪意外得到了一台非常有用的机器，据说是叫 GPS，对可可能准确的定位。有了这台机器，聪聪要吃可可就易如反掌了。于是，聪聪准备马上出发，去找可可。而可怜的可可还不知道大难即将临头，仍在森林里无忧无虑的玩耍。小兔子乖乖听到这件事，马上向灰姑娘报告。灰姑娘决定尽快阻止聪聪，拯救可可，可她不知道还有没有足够的时间。

整个森林可以认为是一个无向图，图中有 $N$ 个美丽的景点，景点从 $1$ 至 $N$ 编号。小动物们都只在景点休息、玩耍。在景点之间有一些路连接。

当聪聪得到 GPS 时，可可正在景点 $M$（$M \le N$）处。以后的每个时间单位，可可都会选择去相邻的景点（可能有多个）中的一个或停留在原景点不动。而去这些地方所发生的概率是相等的。假设有 $P$ 个景点与景点 $M$ 相邻，它们分别是景点 $R$、景点 $S$、……、景点 $Q$，在时刻 $T$ 可可处在景点 $M$，则在 $(T+1)$ 时刻，可可有 $1/(1 +P)$ 的可能在景点 $R$，有 $1/(1 +P)$ 的可能在景点 $S$，……，有 $1/(1 +P)$ 的可能在景点 $Q$，还有$1/(1 +P)$的可能停在景点 $M$。

我们知道，聪聪是很聪明的，所以，当她在景点 $C$ 时，她会选一个更靠近可可的景点，如果这样的景点有多个，她会选一个标号最小的景点。由于聪聪太想吃掉可可了，如果走完第一步以后仍然没吃到可可，她还可以在本段时间内再向可可走近一步。

在每个时间单位，假设聪聪先走，可可后走。在某一时刻，若聪聪和可可位于同一个景点，则可怜的可可就被吃掉了。

灰姑娘想知道，平均情况下，聪聪几步就可能吃到可可。而你需要帮助灰姑娘尽快的找到答案。
## 输入格式

数据的第 1 行为两个整数 $N$ 和 $E$，以空格分隔，分别表示森林中的景点数和连接相邻景点的路的条数。

第 2 行包含两个整数 $C$ 和 $M$，以空格分隔，分别表示初始时聪聪和可可所在的景点的编号。

接下来 E 行，每行两个整数，第 $i+2$ 行的两个整数 $A_i$ 和 $B_i$ 表示景点 $A_i$ 和景点 $B_i$ 之间有一条路。所有的路都是无向的，即：如果能从 A 走到 B，就可以从 B 走到 A。

输入保证任何两个景点之间不会有多于一条路直接相连，且聪聪和可可之间必有路直接或间接的相连。
## 输出格式

输出 1 个实数，四舍五入保留三位小数，表示平均多少个时间单位后聪聪会把可可吃掉。
## 样例

### 样例输入 #1
```
4 3 
1 4 
1 2 
2 3 
3 4
```
### 样例输出 #1
```
1.500 

```
### 样例输入 #2
```
9 9 
9 3 
1 2 
2 3 
3 4 
4 5 
3 6 
4 6 
4 7 
7 8 
8 9
```
### 样例输出 #2
```
2.167
```
## 提示

【样例说明 1】 

开始时，聪聪和可可分别在景点 1 和景点 4。 

第一个时刻，聪聪先走，她向更靠近可可(景点 4)的景点走动，走到景点 2， 然后走到景点 3；假定忽略走路所花时间。 

可可后走，有两种可能： 第一种是走到景点 3，这样聪聪和可可到达同一个景点，可可被吃掉，步数为 $1$，概率为$0.5$。
 
第二种是停在景点 4，不被吃掉。概率为 $0.5$。

到第二个时刻，聪聪向更靠近可可(景点 4)的景点走动，只需要走一步即和 可可在同一景点。因此这种情况下聪聪会在两步吃掉可可。 所以平均的步数是 $1\times 1/2 + 2\times 1/2 =1.5$ 步。

【样例说明 2】

森林如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/8uiq0ltc.png)

对于 50%的数据，$1≤N≤50$。  
对于所有的数据，$1≤N,E≤1000$。 


---

---
title: "[BalticOI 2018] 路径"
layout: "post"
diff: 提高+/省选-
pid: P4796
tag: ['搜索', '2018', '枚举', '记忆化搜索', 'BalticOI（波罗的海）']
---
# [BalticOI 2018] 路径
## 题目描述

**题目译自 [BalticOI 2018](https://boi2018.progolymp.se/tasks/) Day2「[Paths](https://boi18-day2-open.kattis.com/problems/boi18.paths)」**

给定一张 $N$ 个点 $M$ 条边的无向图，每个点有一个颜色，所有点的颜色共有 $K$ 种，编号为 $1\ldots K$。求图上有多少条长度至少为 $2$ 的简单路径，满足路径上的每一个点的颜色互不相同。

路径上的点的连接顺序不同看作不同的两条路径。
## 输入格式

第一行包含三个整数 $N$, $M$ 和 $K$。

第二行包含 $N$ 个在 $1$ 到 $K$ 之间的整数，表示每个点的颜色。

接下来的 $M$ 行每行两个整数 $a$ 和 $b$，表示图的一条边。

数据保证图无自环无重边。
## 输出格式

输出一个整数表示每一个点颜色都不同的路径条数。保证答案不会超过 $10^{18}$。
## 样例

### 样例输入 #1
```
4 3 3
1 2 1 3
1 2
2 3
4 2
```
### 样例输出 #1
```
10


```
### 样例输入 #2
```
9 11 4
1 2 3 4 1 2 1 2 2
1 2
1 3
2 3
2 4
3 6
6 2
6 5
4 3
4 5
7 8
9 8
```
### 样例输出 #2
```
70
```
## 提示

#### 样例 1 解释
![](https://gitee.com/mingqihuang/pics/raw/master/pathsfig.pdf.svg)

样例 1 中表达的图如上图所示。每个点的底色分别为白色（颜色 $1$）、灰色（颜色 $2$）或黑色（颜色 $3$）。共有 $10$ 条路径满足路径上的所有点的颜色都不同。它们是：``1-2``, ``2-1``, ``2-3``, ``3-2``, ``2-4``, ``4-2``, ``1-2-4``, ``4-2-1``, ``3-2-4`` 和 ``4-2-3``。

注意 ``1`` 不能看作是一条路径，因为一条路径至少连接两个点。``1-2-3`` 也不满足条件，因为有两个点都是 $1$ 号颜色。

|子任务|分值|数据范围|
|:--:|:--:|:--:|
|$1$|$23$|$1 \leqslant N,M \leqslant 100, 1 \leqslant K \leqslant 4$|
|$2$|$20$|$1 \leqslant N,M \leqslant 300\,000, 1 \leqslant K \leqslant 3$|
|$3$|$27$|$1 \leqslant N,M \leqslant 300\,000, 1 \leqslant K \leqslant 4$|
|$4$|$30$|$1 \leqslant N,M \leqslant 100\,000, 1 \leqslant K \leqslant 5$|

感谢 Hatsune_Miku 提供的翻译


---

---
title: "[IOI 2009] Raisins"
layout: "post"
diff: 提高+/省选-
pid: P4850
tag: ['搜索', '2009', 'IOI', 'O2优化', '记忆化搜索', '前缀和']
---
# [IOI 2009] Raisins
## 题目背景

IOI2009 D1T4
## 题目描述

普罗夫迪夫的著名巧克力大师 Bonny 需要切开一板带有葡萄干的巧克力。巧克力是一个包含许多相同的方形小块的矩形。小块沿着巧克力的边排列成 $N$ 行 $M$ 列，共有 $N\times M$ 块。每个小块上有 $1$ 个或多个葡萄干，没有葡萄干在小块的边上或者跨过两个小块。

最开始，巧克力是一整块。Bonny 需要把它切成上述的 $N\times M$ 个独立的小块。因为 Bonny 很忙，她需要她的助手 Sly Peter 帮她切。
Peter 只能从一端到另一端切直线，并且他要为他的每一刀得到报酬。Bonny 手头没有钱，但是她有足够的葡萄干，所以她提出用葡萄干付给 Peter。Sly Peter 同意接受葡萄干，但是有下面的条件：每次他把给定的一块巧克力切成两小块，他都要得到和那块给定的巧克力上葡萄干数目相同的葡萄干。

Bonny 想要付给 Peter 尽可能少的葡萄干。她知道这 $n\times m$ 个小块中每一个小块上葡萄干的数目。她可以选择递给 Peter 的巧克力的顺序，也可以告诉 Peter 如何切（横切还是竖切）以及从哪里切。请告诉 Bonny 如何把巧克力切成一个个独立的小块，使她能够付给 Sly Peter 尽可能少的葡萄干。

**任务**：编写一个程序，给定每个小块上葡萄干的数目，计算出 Bonny 要付给 Sly Peter 的最少的葡萄干的数目。
## 输入格式

第一行两个由空格隔开的整数 $N, M$，分别表示巧克力的行数和列数。

接下来 $N$ 行描述了每个小块上葡萄干的数目。其中第 $k$ 行描述了第 $k$ 行小块的巧克力。每行包含 $m$ 个整数，分别以一个空格隔开。这些整数描述了该行从左到右的小块。第 $k$ 行的第 $p$ 个整数表示位于第 $k$ 行第 $p$ 列的小块上的葡萄干数目 $R_{k, p}$。
## 输出格式

一行一个整数，表示 Bonny 要付给 Sly Peter 的最少的葡萄干的数目。
## 样例

### 样例输入 #1
```
2 3
2 7 5
1 9 5

```
### 样例输出 #1
```
77

```
## 提示

### 样例解释

一种可能的代价为 $77$ 的切割方案如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/zg74ypip.png)

第一次切割将第三列和剩下来的巧克力分开了。Bonny 需要付给 Peter $29$ 个葡萄干。

接下来 Bonny 把较小的那一块巧克力（有两小块，每一块都有 $5$ 个葡萄干）给 Peter，要求 Peter 切成两半并支付 $10$ 个葡萄干。

在此之后，Bonny 给 Peter 剩下来的最大块（分别有 $2,  7, 1, 9$ 个葡萄干在它的四个小块上）。Bonny 要求 Peter 水平切割这一块，将第一行和第二行分开并付给他 $19$ 个葡萄干。

此后 Bonny 给 Peter 左上角的块，支付 $9$ 个葡萄干。最后 Bonny 要求 Peter 将左下角的块分开，支付 $10$ 个葡萄干。

Bonny 的总代价是 $29 + 10 + 19 + 9 + 10 = 77$ 个葡萄干。没有其它安排切割的方案有更小的代价。

### 数据范围与约定

- 对于 $25\%$ 的数据，$n,m\leq 7$。
- 对于 $100\%$ 的数据，$1\leq n,m\leq 50$，$1\leq R_{k, p}\leq 1000$。


---

---
title: "[USACO21JAN] Uddered but not Herd G"
layout: "post"
diff: 提高+/省选-
pid: P7296
tag: ['USACO', '2021', '记忆化搜索', '状压 DP']
---
# [USACO21JAN] Uddered but not Herd G
## 题目描述


一个鲜为人知的事实是，奶牛拥有自己的文字：「牛文」。牛文由 26 个字母 'a' 到 'z' 组成，但是当奶牛说牛文时，可能与我们所熟悉的 'abcdefghijklmnopqrstuvwxyz' 不同，她会按某种特定的顺序排列字母。

为了打发时间，Bessie 的表妹 Mildred 在反复哼唱牛文字母歌，而 Farmer Nhoj 好奇她唱了多少遍。

给定一个小写字母组成的字符串，为 Farmer Nhoj 听到 Mildred 唱的字母，计算 Mildred 至少唱了几遍完整的牛文字母歌，使得 Farmer Nhoj 能够听到给定的字符串。Farmer Nhoj 并不始终注意 Mildred 所唱的内容，所以他可能会漏听 Mildred 唱过的一些字母。给定的字符串仅包含他记得他所听到的字母。

注意：本题每个测试点的时间限制为默认限制的两倍。 
## 输入格式

输入仅一行，包含一个小写字母组成的字符串，为 Farmer Nhoj 听到 Mildred 唱的字母。字符串的长度不小于 $1$ 且不大于 $10^5$。 
## 输出格式

输出 Mildred 所唱的完整的牛文字母歌的最小次数。 
## 样例

### 样例输入 #1
```
mildredree
```
### 样例输出 #1
```
3
```
## 提示

Mildred 至少唱了三遍牛文字母歌。有可能 Mildred 只唱了三遍牛文字母歌，如果牛文字母表以 "mildre" 开头，并且 Farmer Nhoj 听到了以下被标记为大写的字母。

```
MILDREabcfghjknopqstuvwxyz
milDREabcfghjknopqstuvwxyz
mildrEabcfghjknopqstuvwxyz
```

#### 测试点性质：

 - 测试点 1-5 中，Farmer Nhoj 仅听到出现在 Mildred 或 Bessie 的名字中的字母。
 - 测试点 6-16 中，Farmer Nhoj 从未听到任何出现在 Mildred 名字中的字母。

供题：Nick Wu，Brian Dean 


---

---
title: "弹珠游戏（2021 CoE-I C）"
layout: "post"
diff: 提高+/省选-
pid: P7395
tag: ['博弈论', '2021', '记忆化搜索']
---
# 弹珠游戏（2021 CoE-I C）
## 题目描述

$\operatorname{Alice}$ 对弹珠游戏已经有些厌烦了，她经常在电脑上玩这个游戏。她之所以感到厌烦是因为在这个游戏上她已经是专家级别，她总是能够和电脑打成平手。$\operatorname{Bob}$ 为 $\operatorname{Alice}$ 创造了一款新的电脑游戏。以下是这款两人电脑游戏的规则：

（1）游戏在如下图所示的菱形棋盘上进行；

![](https://cdn.luogu.com.cn/upload/image_hosting/qw7lsky0.png)

（2）两名玩家轮流放置弹珠，可以在横向、纵向、$45$ 度斜线、$135$ 度斜线方向未放置弹珠的位置**连续放置 $1$ 至 $3$ 颗弹珠**，玩家在可以放置弹珠的情况下，必须至少放置 $1$ 颗弹珠。以下是合法的单次放置操作的示例（黑色圆点表示放置了弹珠，白色圆点表示未放置弹珠，进行该次操作前棋盘为空）：

![](https://cdn.luogu.com.cn/upload/image_hosting/v38tajmr.png)

以下是非法的单次放置操作的示例（黑色圆点表示放置了弹珠，白色圆点表示未放置弹珠，进行该次操作前棋盘为空）：

![](https://cdn.luogu.com.cn/upload/image_hosting/mldg0cs0.png)

非法原因的解释：（$a$）三颗弹珠不在同一条斜线（或者垂直线）上；（$b$）两颗弹珠之间相隔一个空位；（$c$）三颗弹珠不在同一条斜线上；（$d$）三颗弹珠不在同一条斜线（或者垂直线）上；（$e$）一次性放置了 $4$ 颗弹珠；（$f$）三颗弹珠不在同一条水平线（或者垂直线、或者斜线）上。

（3）如果某位玩家无法再继续放置弹珠，则该名玩家输掉游戏，另外一名玩家获胜。

$\operatorname{Alice}$ 总是第一个进行游戏，而且经常是和 $\operatorname{Bob}$ 玩这个游戏，$\operatorname{Bob}$ 在进行若干游戏操作后可能会离开，将游戏交由电脑代理，电脑总是按照最优策略放置弹珠。
给定 $\operatorname{Bob}$ 离开后的游戏状态，你的任务是确定 $\operatorname{Alice}$ 是否可能在对阵电脑时获得胜利。
## 输入格式

**输入包含多组测试数据**。

输入第一行包含一个整数 $T$，表示测试数据的组数。接着是一个空行。再接下来是 $T$ 组表示棋盘状态的数据，每组数据由七行字符构成，表示 $\operatorname{Bob}$ 离开后的游戏状态，`*` 表示该位置已经放置了弹珠，`.` 表示该位置未放置弹珠。相邻两组测试数据之间有一个空行。
## 输出格式

对于每组测试数据，如果 $\operatorname{Alice}$ 能够获胜，输出 `Possible.`，否则输出 `Impossible.`。
## 样例

### 样例输入 #1
```
6

   *
  * *
 * * *
* * * *
 . * *
  . *
   .

   *
  * *
 * * *
. . . *
 * * *
  * *
   *

   *
  * *
 * * .
* * * *
 * * .
  * *
   *

   *
  * *
 . . *
* * * *
 * * *
  * *
   *

   .
  * *
 * * *
* * * .
 * * *
  * *
   *

   .
  * .
 * * .
* * * .
 * * *
  * *
   *
```
### 样例输出 #1
```
Possible.
Possible.
Possible.
Possible.
Impossible.
Possible.
```
## 提示

#### 样例说明

第一组数据，$\operatorname{Alice}$ 可以选择在棋盘左下角的斜线方向所剩下的 $3$ 个空余位置一次性连续放置 $3$ 颗弹珠，使得后续电脑无法再放置弹珠，因此 $\operatorname{Alice}$ 能够获胜。

第二组数据，$\operatorname{Alice}$ 可以选择沿着第四行剩下的 $3$ 个空余位置一次性连续放置 $3$ 颗弹珠，使得后续电脑无法再放置弹珠，因此 $\operatorname{Alice}$ 能够获胜。

第三组数据，棋盘剩下倒数第二列两个连续的空余位置，$\operatorname{Alice}$ 可以一次放置 $2$ 颗弹珠，使得后续电脑无法放置弹珠，因此 $\operatorname{Alice}$ 会获胜。

第四组数据，类似于第二组测试数据，棋盘剩下第三行两个连续的空余位置，因此 $\operatorname{Alice}$ 会获胜。

第五组数据，棋盘只剩下两个不连续的空余位置，由于 $\operatorname{Alice}$ 一次只能选择一个空余位置放置 $1$ 颗弹珠，因此不管 $\operatorname{Alice}$ 如何操作，电脑总能一次性将剩下的棋盘使用弹珠填满，使得 $\operatorname{Alice}$ 无法再继续放置弹珠，因此 $\operatorname{Alice}$ 会输掉比赛。

第六组数据，$\operatorname{Alice}$ 可以选择在棋盘右上角斜线方向的中间两个空余位置放置 $2$ 颗弹珠，使得棋盘状态转化为样例输入的第五组数据，因此 $\operatorname{Alice}$ 会赢得比赛。


------------

#### 数据范围

对于 $10\%$ 的数据，$0 \lt T \leq 10$。

对于 $60\%$ 的数据，$0 \lt T \leq 10^3$。

对于 $80\%$ 的数据，$0 \lt T \leq 10^5$。

对于 $100\%$ 的数据，$0 \lt T \leq 10^6$。


------------

#### 提示

本题输入量较大，请使用合适的读入方式。


---

---
title: "「WHOI-1」Derives"
layout: "post"
diff: 提高+/省选-
pid: P8357
tag: ['动态规划 DP', '数论', 'Special Judge', 'O2优化', '记忆化搜索']
---
# 「WHOI-1」Derives
## 题目背景

你的钱里面混进去了一个假币。
## 题目描述

你有 $n$ 枚硬币。经过准确的测量，你发现一定有一枚是假币，假币的质量与其他硬币不同。你想要找出这枚假币。

第 $i$ 轮，假设你当时有 $x_i$ 枚硬币，你会把当前钱堆所有钱分配到若干组，每组 $k_i$ 个，最终剩下的再单独分一组。每个硬币你要拿起来需要 $a$ 秒，那么这将会花费你 $ax_i$ 秒的时间。接下来，你会称量每一组，称量每组需要 $b$ 秒，所以这将会花费你 $b\cdot\lceil\frac{x_i}{k_i}\rceil$ 秒的时间。由于只有一枚假币，那么只会有一堆的质量与正常的质量不同。**在称量所有堆之后**，你将会选出与正常质量不同的那一堆，并进入下一轮，让 $x_{i+1}=k_i$。一直执行，直到 $x_i=1$。假设进行了 $m$ 轮，那么花费时间 $f=\sum\limits_{i=1}^{m}{(ax_i+b\cdot\lceil\frac{x_i}{k_i}\rceil)}$

请问，你在最差情况下（**即每轮选出不正常的都是 $k_i$ 个一堆的**）最少需要多长时间找出那枚假币？
## 输入格式

一行三个正整数，代表 $n,a,b$。
## 输出格式

第一行两个个非负整数 $f,m$，代表最小可能的时间和你的方案的轮数。

接下来一行 $m$ 个正整数，代表 $k_i$。
## 样例

### 样例输入 #1
```
20 1 3
```
### 样例输出 #1
```
51 2
4 1
```
### 样例输入 #2
```
1000 10 100
```
### 样例输出 #2
```
13570 4
72 12 3 1
```
## 提示

**说明**

**你需要尽量使得花费的时间更少。**

本题采用 Special Judge。

首先，你输出的答案一定要合法，也就是你输出的答案要与下面的选择方法符合，否则将获得 $0$ 分。

接下来，评测机会对你的输出进行判断。如果你输出的答案合法且与正确答案的差 $\le9$，那么你将获得 $(10-d)\times100\%$ 的分数。例如，如果你输出的答案与正确答案的差为 $4$，那么你将获得 $60\%$ 的分数。如果你输出的答案等于正确答案，你将获得 $100\%$ 的分数。请不要输出多余的数字或少输出。

**数据范围**

- $\text{subtask 1(10pts)}:$ $1\le n\le2000$。
- $\text{subtask 2(20pts)}:$ $1\le n\le75000$。
- $\text{subtask 3(30pts)}:$ $1\le n\le10^7$。
- $\text{subtask 4(40pts)}:$ $1\le n\le10^9$。

对于所有数据，满足 $0<a,b\le10^9$。

**样例说明**

对于第一个样例，进行两轮。$x_1=20,k_1=4,x_2=4,k_2=1$。答案 $f=20+15+4+12=51$。


---

---
title: "「DROI」Round 2 划分"
layout: "post"
diff: 提高+/省选-
pid: P9375
tag: ['O2优化', '记忆化搜索']
---
# 「DROI」Round 2 划分
## 题目背景

与其编写苍白无力的背景，不如出更有质量的题。
## 题目描述

给定长度为 $n$ 的序列 $A$。

定义序列 $A$ 的某个子段 $[L,R]$ 的权值为: 

$$ \sum_{i=L}^{R}[\vert A_i - A_L \vert是完全平方数] \times \sum_{i=L}^{R}[\vert A_R - A_i \vert是完全平方数]$$

现在你需要将序列 $A$ **不重不漏**地划分成若干个子段，使得对于 $\forall i \in [1,n]$，长度为 $i$ 的子段有 $c_i$ 个。

在此基础上，求一种划分方案使所有子段权值和最大，输出这个最大值即可。特殊地，若不存在任意一种划分方案，则输出 `-1`。

**对题意不清楚的，可见下方说明提示。**

## 输入格式

首先输入一个整数 $n$，表示序列 $A$ 的长度。

然后输入一行 $n$ 个数，其中第 $i$ 个数表示 $A_i$。

最后再输入一行 $n$ 个数，其中第 $i$ 个数表示 $c_i$。
## 输出格式

输出一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
6
2 1 4899 4 1 4
1 1 1 0 0 0
```
### 样例输出 #1
```
9
```
### 样例输入 #2
```
10
1 1 1 2 4 3 3 3 8 8
2 1 2 0 0 0 0 0 0 0
```
### 样例输出 #2
```
24
```
## 提示

#### 样例解释
对于样例一，一种最优划分是分别在第二、三个数后面将序列断开。

对于样例二，一种最优划分是分别在第三、四、五、八个数后面将序列断开。


------------

#### 数据范围

**「本题采用捆绑测试」**

- $\operatorname{Subtask} 1(10\%)$：$n \leq 20$。

- $\operatorname{Subtask} 2(20\%)$：$n \leq 50,\sum_{i=1}^{n}c_i \leq 20$。

- $\operatorname{Subtask} 3(20\%)$：$n \leq 50,\forall i>5,c_i=0$。

- $\operatorname{Subtask} 4(50\%)$：无特殊限制。

对于 $100\%$ 的数据：$0 \leq c_i\leq n \leq 120,1 \leq a_i \leq 10^4$。

------------

#### 说明提示

- 我们规定，$0$ 是完全平方数。

- $[P]=1$ 当且仅当 $P$ 是真命题，否则 $[P]=0$。



---


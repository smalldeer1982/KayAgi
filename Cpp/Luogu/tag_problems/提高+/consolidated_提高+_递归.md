---
title: "[ZJOI2007] 矩阵游戏"
layout: "post"
diff: 提高+/省选-
pid: P1129
tag: ['2007', '各省省选', '递归', '网络流', '浙江', '二分图']
---
# [ZJOI2007] 矩阵游戏
## 题目描述

小 Q 是一个非常聪明的孩子，除了国际象棋，他还很喜欢玩一个电脑益智游戏――矩阵游戏。矩阵游戏在一个 $n \times n$ 黑白方阵进行（如同国际象棋一般，只是颜色是随意的）。每次可以对该矩阵进行两种操作：

- 行交换操作：选择矩阵的任意两行，交换这两行（即交换对应格子的颜色）。
- 列交换操作：选择矩阵的任意两列，交换这两列（即交换对应格子的颜色）。

游戏的目标，即通过若干次操作，使得方阵的主对角线(左上角到右下角的连线)上的格子均为黑色。

对于某些关卡，小 Q 百思不得其解，以致他开始怀疑这些关卡是不是根本就是无解的！于是小 Q 决定写一个程序来判断这些关卡是否有解。

## 输入格式

**本题单测试点内有多组数据**。

第一行包含一个整数 $T$，表示数据的组数，对于每组数据，输入格式如下：

第一行为一个整数，代表方阵的大小 $n$。
接下来 $n$ 行，每行 $n$ 个非零即一的整数，代表该方阵。其中 $0$ 表示白色，$1$ 表示黑色。
## 输出格式

对于每组数据，输出一行一个字符串，若关卡有解则输出 `Yes`，否则输出 `No`。
## 样例

### 样例输入 #1
```
2
2
0 0
0 1
3
0 0 1
0 1 0
1 0 0

```
### 样例输出 #1
```
No
Yes

```
## 提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 7$。
- 对于 $50\%$ 的数据，保证 $n \leq 50$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 200$，$1 \leq T \leq 20$。



---

---
title: "新汉诺塔"
layout: "post"
diff: 提高+/省选-
pid: P1242
tag: ['递归', '枚举']
---
# 新汉诺塔
## 题目描述


设有 $n$ 个大小不等的中空圆盘，按从小到大的顺序从 $1$ 到 $n$ 编号。将这 $n$ 个圆盘任意的迭套在三根立柱上，立柱的编号分别为 $A,B,C$，这个状态称为初始状态。

现在要求找到一种步数最少的移动方案，使得从初始状态转变为目标状态。

移动时有如下要求：

- 一次只能移一个盘；
- 不允许把大盘移到小盘上面。
## 输入格式


第一行一个整数，状态中圆盘总数 $n$。

接下来三行每行若干个整数，分别代表初始状态下 $A$ , $B$ , $C$ 柱子上的圆盘从上到下的编号，如果只有一个数 $0$ 就代表这根柱子上没有数。

接下来三行每行若干个整数，分别代表目标状态下 $A$ , $B$ , $C$ 柱子上的圆盘从上到下的编号，如果只有一个数 $0$ 就代表这根柱子上没有数。
## 输出格式

若干行每行一个字符串，格式为 `move I from P to Q` ，代表一个移动的操作。

接下来一行一个整数，代表从初始状态到目标状态的最少步数。
## 样例

### 样例输入 #1
```
5
3 3 2 1
2 5 4
0
1 2
3 5 4 3
1 1
```
### 样例输出 #1
```
move 1 from A to B
move 2 from A to C
move 1 from B to C
move 3 from A to B
move 1 from C to B
move 2 from C to A
move 1 from B to C
7
```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \le n \le 45$ ，$1 \le $ 每个圆盘的编号 $\le n$ 。

每行的圆盘描述是从下到上的圆盘编号。


---

---
title: "斐波那契公约数"
layout: "post"
diff: 提高+/省选-
pid: P1306
tag: ['数学', '倍增', '线性数据结构', '递归', '斐波那契数列']
---
# 斐波那契公约数
## 题目描述

对于 Fibonacci 数列：

$$ f_i = \begin{cases}
  [i = 1]               & i \leq 1 \\
  f_{i - 1} + f_{i - 2} & i \gt 1
\end{cases}$$

请求出 $f_n$ 与 $f_m$ 的最大公约数，即 $\gcd(f_n, f_m)$。
## 输入格式

一行两个正整数 $n$ 和 $m$ 。
## 输出格式

输出一行一个整数，代表 $f_n$ 和 $f_m$ 的最大公约数。答案请对 $10^8$ 取模。
## 样例

### 样例输入 #1
```
4 7
```
### 样例输出 #1
```
1
```
## 提示

#### 数据规模与约定

- 对于 $100\%$ 的数据，保证 $1 \leq n, m \leq 10^9$。


---

---
title: "平面最近点对（加强版）"
layout: "post"
diff: 提高+/省选-
pid: P1429
tag: ['计算几何', '递归', '分治']
---
# 平面最近点对（加强版）
## 题目背景

[P7883](/problem/P7883) 平面最近点对（加强加强版）
## 题目描述

给定平面上 $n$ 个点，找出其中的一对点的距离，使得在这 $n$ 个点的所有点对中，该距离为所有点对中最小的

## 输入格式

第一行：$n$ ，保证 $2\le n\le 200000$ 。

接下来 $n$ 行：每行两个实数：$x\ y$ ，表示一个点的行坐标和列坐标，中间用一个空格隔开。

## 输出格式

仅一行，一个实数，表示最短距离，精确到小数点后面 $4$ 位。
## 样例

### 样例输入 #1
```
3
1 1
1 2
2 2
```
### 样例输出 #1
```
1.0000
```
## 提示

数据保证 $0\le x,y\le 10^9$


---

---
title: "数位平方和"
layout: "post"
diff: 提高+/省选-
pid: P1660
tag: ['搜索', '树形数据结构', '递归']
---
# 数位平方和
## 题目描述

定义 $S(n)$ 表示 $n$ 的各个数位的 $k$ 次方的和。

定义 $H(n)$ 为满足 $H(n) \le \min\{n, H(S(n))\}$ 的最大值。

求$\sum_{i=A}^{B} H(i) \bmod (10^7 + 7)$。
## 输入格式

一行三个数 $k, A, B$。
## 输出格式

一个数，表示 $\sum_{i=A}^{B} H(i) \bmod (10^7 + 7)$。
## 样例

### 样例输入 #1
```
2 1 5
```
### 样例输出 #1
```
14
```
## 提示

对于 $20\%$ 的数据，$A, B \le 50$。  
对于 $100\%$ 的数据，$1 \le A, B \le {10}^6$，$1 \le k \le 6$。


---

---
title: "淘汰赛制"
layout: "post"
diff: 提高+/省选-
pid: P1769
tag: ['动态规划 DP', '递推', '递归', 'NOI 导刊']
---
# 淘汰赛制
## 题目描述

淘汰赛制是一种极其残酷的比赛制度。$2^n$ 名选手分别标号 $1,2,3,\cdots,2^n-1,2^n$，他们将要参加 $n$ 轮的激烈角逐。每一轮中，将所有参加该轮的选手按标号从小到大排序后，第 $1$ 位与第 $2$ 位比赛，第 $3$ 位与第 $4$ 位比赛，第 $5$ 位与第 $6$ 位比赛……只有每场比赛的胜者才有机会参加下一轮的比赛（不会有平局）。这样，每轮将淘汰一半的选手。$n$ 轮过后，只剩下一名选手，该选手即为最终的冠军。

现在已知每位选手分别与其他选手比赛获胜的概率，请你预测一下谁夺冠的概率最大。
## 输入格式

第一行是一个整数 $n(1 \le n \le 10)$，表示总轮数。接下来 $2^n$ 行，每行 $2^n$ 个整数，第 $i$ 行第 $j$ 个是 $p_{i,j}$。（$0 \le p_{i_j} \le 100$，$p_{i,i}=0$，$p_{i,j}+p_{j,i}=100$），表示第 $i$ 号选手与第 $j$ 号选手比赛获胜的概率。
## 输出格式

输出只有一个整数 $c$，表示夺冠概率最大的选手编号（若有多位选手，输出编号最小者）。

## 样例

### 样例输入 #1
```
2
0 90 50 50
10 0 10 10
50 90 0 50
50 90 50 0

```
### 样例输出 #1
```
 1
```
## 提示

- $30\%$ 的数据满足 $n \le 3$；
- $100\%$ 的数据满足 $n \le 10$。

_NOI导刊 2010 提高（01）



---

---
title: "方程的解"
layout: "post"
diff: 提高+/省选-
pid: P1771
tag: ['动态规划 DP', '数学', '高精度', '递归', 'NOI 导刊']
---
# 方程的解
## 题目描述

佳佳碰到了一个难题，请你来帮忙解决。对于不定方程 $a_1+a_2+\cdots +a_{k-1}+a_k=g(x)$，其中 $k\ge 2$ 且 $k\in \mathbb{N}^*$，$x$ 是正整数，$g(x)=x^x \bmod 1000$（即 $x^x$ 除以 $1000$ 的余数），$x,k$ 是给定的数。我们要求的是这个不定方程的正整数解组数。

举例来说，当 $k=3,x=2$ 时，方程的解分别为：
$$\begin{cases} a_1=1\\ a_2=1\\ a_3=2 \end{cases}$$
$$\begin{cases} a_1=1\\ a_2=2\\ a_3=1 \end{cases}$$
$$\begin{cases} a_1=2\\ a_2=1\\ a_3=1 \end{cases}$$
## 输入格式

输入有且只有一行，为用空格隔开的两个正整数，依次为 $k,x$。
## 输出格式

输出有且只有一行，为方程的正整数解组数。

## 样例

### 样例输入 #1
```
3 2
```
### 样例输出 #1
```
3
```
## 提示

- 对于 $40\%$ 的数据，$\mathit{ans} \le 10^{16}$；
- 对于 $100\%$ 的数据，$k \le 100$，$x \le 2^{31}-1$，$k \le g(x)$。

NOI导刊2010提高（01）



---

---
title: "区间运算"
layout: "post"
diff: 提高+/省选-
pid: P1812
tag: ['递归']
---
# 区间运算
## 题目描述

区间运算是数学的一个领域。在区间运算中，常量和变量并不表示为一个单独、精确的值，而是表示为一个有着上界和下界的区间或范围。在普通的运算中，一个数量可以表示为数轴上的一个点；而在区间运算中，一个数量表示数轴上的一段，例如 $[3,5]$ 表示数轴上从 $3$ 到 $5$ 的一段。当精确的数值表示为区间时，上界与下界是相同的，如 $5$ 表示为区间即为 $[5,5]$。

两个区间的运算，是指一个区间中的每个点与另一个区间中的每个点所做的运算，通过运算所得的所有点的集合即为运算的结果。例如，$[3,5]+[-10,1]=[-7,6]$。你的任务是写一个可以根据单行表达式进行取相反数、加、减、乘、除等基本的区间运算的程序。下面是一些运算的例子：

- 取相反数：$-[-3,5]=[-5,3]$；
- 加法：$[3,5]+[-10,1]=[-7,6]$；
- 减法：$[3,5]-[-10,1]=[2,15]$；
- 乘法：$[3,5]\times [-10,1]=[-50,5]$；
- 除法：$[3,5]\div [-10,-0.1]=[-50,-0.3]$。
## 输入格式

程序的输入包含一行或多行区间运算的中缀表达式，每个区间都表示为 $[\min,\max]$，表达式中包括括号、负号（$\verb!-!$）、加号（$\verb!+!$）、减号（$\verb!-!$）、乘号（$\verb!*!$）和除号（$\verb!/!$），括号可能是嵌套的。每一行中都有可能有空格，但空格不会在表示区间的括号 $[\min,\max]$ 中间或负号后出现。程序不需要处理科学记数法，如 $\verb!2E6!=2\times 10^6$。每一行都不超过 $80$ 个字符。运算采用标准的优先级规则。下面按优先级递减的顺序给出各个算符：

- $\verb!(!,\verb!)!$ 括号；
- $\verb!-!$ 取相反数；
- $\verb!*!,\verb!/!$，乘法和除法，同级运算按从左到右的顺序；
- $\verb!+!,\verb!-!$，加法和减法，同级运算按从左到右的顺序。
## 输出格式

对于输入文件中每一行的表达式，以 $[\min,\max]$（均保留 $3$ 位小数）的形式输出运算结果。每个结果占一行。结果中不应有空格。在运算中，如果将一个包含 $0$ 的区间用作除数，则输出 `Division by zero`。
## 样例

### 样例输入 #1
```
-[-3,5] 
[3,5]+[-10,1] 
[3,5]-[-10,1] 
[3,5]*[-10,1] 
(([3,5]/[-10,-0.1])/-[2,2]) 
```
### 样例输出 #1
```
[-5.000,3.000] 
[-7.000,6.000] 
[2.000,15.000] 
[-50.000,5.000] 
[0.150,25.000]
```


---

---
title: "魔法物品"
layout: "post"
diff: 提高+/省选-
pid: P1899
tag: ['动态规划 DP', '贪心', '递归', 'NOI 导刊']
---
# 魔法物品
## 题目描述


有两种类型的物品：普通物品和魔法物品。普通物品没有魔法属性，而魔法物品拥有一些魔法属性。每种普通物品有一个价值 $P$，但每种魔法物品有两种价值：鉴定前的价值 $P_1$ 和鉴定后的价值 $P_2$（当然，$P_2$ 总是大于 $P_1$）。

为了鉴定一个魔法物品，你需要购买一个鉴定卷轴，用它来鉴定魔法物品。鉴定完一件魔法物品以后，鉴定卷轴便会消失。每个鉴定卷轴将会消耗 $P_i$ 元钱。如果没有足够的钱，你将无法购买任何鉴定卷轴。    
现在，你正在一个集市中，同时拥有很多物品。你知道每件物品的价值并且想要出售全部物品。那么，你最多能够获得多少钱呢？

你可以假定：

- 开始的时候你没有钱。
- 所有的魔法物品都还没有被鉴定。
- 只要你有足够的钱，你可以购买任意多的鉴定卷轴。
## 输入格式

第一行有两个整数 $N$ 和 $P_i$（$1 \le P_i \le 5000$），表示你拥有的物品数和一个鉴定卷轴的价格。  
接下来 $N$ 行，每行给出一件物品的价格。  
对于每件普通物品行仅有一个整数 $P$（$1 \le P \le 10000$）。  
对于每件魔法物品,那一行将会有两个整数 $P_1$ 和 $P_2$（$1 \le P_1 < P_2 \le 10000$）。
## 输出格式

输出一个整数表示你最多能够获得多少钱。
## 样例

### 样例输入 #1
```
2 10
10
20 100

```
### 样例输出 #1
```
100

```
## 提示

对于 $30\%$ 的数据，$1\le N \le 50$。  
对于 $100\%$ 的数据，$1 \le N \le 1000$。


---

---
title: "最轻的天平"
layout: "post"
diff: 提高+/省选-
pid: P1961
tag: ['递归', 'NOI 导刊']
---
# 最轻的天平
## 题目描述

天平的两边有时不一定只能挂物品，还可以继续挂着另一个天平，现在给你一些天平的情况和它们之间的连接关系，要求使得所有天平都能平衡所需物品的总重量最轻，一个天平平衡当且仅当“左端点的重量\*左端点到支点的距离=右端点的重量\*右端点到支点的距离”。注意题目中的输入保证这些天平构成一个整体。

## 输入格式

第一行包含一个 $N(N \le 100)$，表示天平的数量，天平编号为 $l$ 到 $N$，接下来包含 $N$ 行描述天平的情况，每行 $4$ 个整数 $P,Q,R,B$，$P$ 和 $Q$ 表示横杆上支点到左边的长度与到右边的距离的比例为 $P:Q$，$R$ 表示左边悬挂的情况，如果 $R=0$ 说明悬挂的是物品，否则表示左边悬挂的是天平 $R:B$ 表示右边的悬挂情况，如果 $B=O$ 表示右边悬挂的是物品，否则右边悬挂着天平 $B$。

对于所有的输入，保证 $W\times L<2^{31}$，其中 $w$ 为最轻的天平重量，而 $L$ 为输入中描述左右比例时出现的最大值。
## 输出格式

输出一个整数表示使得所有天平都平衡所需最轻的物品总重量。

## 样例

### 样例输入 #1
```
4

3 2 0 4

1 3 0 0

4 4 2 1

2 2 0 0
```
### 样例输出 #1
```
40
```
## 提示

【样例说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/k8lsxvj9.png)


---

---
title: "电阻网络"
layout: "post"
diff: 提高+/省选-
pid: P3617
tag: ['模拟', '贪心', '递归', '洛谷原创', '分治']
---
# 电阻网络
## 题目背景

什么是电阻?这个大家应该都知道。什么是电路?大家也应该知道。但是本题当中，电路的定义或许有点不同：

电路都带有正、负极接点，正极在左，负极在右。具体地：电路分为以下几类：

单独的一个1Ω电阻(及其两端的接点)是电路(虽然导线也可以被视为0Ω的电阻，但是单独的导线不是电路)

如果A和B都是电路，设1,2,3是从左到右的三个接点，那么将A的正负极分别接在1与2上，将B的正负极分别接在2与3上，那么1到3的部分是电路，其中1为正极，3为负极。

如果A和B都是电路,设1,2,3,2',3',1’是六个接点，其中1在2和3的左侧，2在2’的左侧，3在3’的左侧，2,和3,在1’的左侧，并且1与2，1与3，2’与1’，3’与1’间均连有导线, 那么将A的正负极分别接在2与2’上，将B的正负极分别接在3与3’上，那么1到1'的部分是电路，其中1为正极，1’为负极。

现在给出一个电路，求它正负极之间的电阻。

## 题目描述

Cjwssb最近在物理学科上遇到了难题，他不会计算一个电路中的总电阻，现在他找到了你，希望你能帮助他。

这个电路有如下限定

1、    电路只由导线以及电阻为一欧的电阻组成

2、    保证电路从左到右连接，即每个电阻或导线的两个连接点xy保证x<y

3、    保证接线柱1为电源正极，接线柱n为电源负极

4、    保证每个接线柱只会被串联或者并联两个分支电路或者不接任何电线或电阻

## 输入格式

第一行为两个正整数n,m,分别代表接点数和电阻数。保证编号小的接点在编号大的接点的左侧。

接下来m行，每行三个整数ai,bi,ci，代表这个电阻连接了ai与bi接点，其阻值为ci ，其中ci只可能是0或1，且对于任意的i，保证ai<bi。

## 输出格式

输出一个实数，表示总的电阻值，保留三位小数输出。

## 样例

### 样例输入 #1
```
7 7
1 2 0
1 3 0
2 4 1
3 5 1
4 6 0
5 6 0
6 7 1

```
### 样例输出 #1
```
1.500
```
## 提示

样例解释

画出图来，答案是显然的。

数据规模与约定

对于20%的数据n≤5,m≤5。

对于50%的数据n≤100,m≤120。

对于70%的数据n≤1,000,m≤1200。

对于100%的数据n≤100,000,m≤120000

数据是在人工指定的n下随机生成的，保证答案不会超过10.000。

By：saffah



---

---
title: "【模板】卢卡斯定理/Lucas 定理"
layout: "post"
diff: 提高+/省选-
pid: P3807
tag: ['递归', '素数判断,质数,筛法', '进制', '组合数学', '逆元', 'Lucas 定理']
---
# 【模板】卢卡斯定理/Lucas 定理
## 题目背景

这是一道模板题。

## 题目描述

给定整数 $n, m, p$ 的值，求出 $C_{n + m}^n \bmod p$ 的值。

输入数据保证 $p$ 为质数。

注: $C$ 表示组合数。
## 输入格式

**本题有多组数据**。

第一行一个整数 $T$，表示数据组数。

对于每组数据: 

一行，三个整数 $n, m, p$。
## 输出格式

对于每组数据，输出一行，一个整数，表示所求的值。
## 样例

### 样例输入 #1
```
2
1 2 5
2 1 5
```
### 样例输出 #1
```
3
3
```
## 提示

对于 $100\%$ 的数据，$1 \leq n, m, p \leq 10^5$，$1 \leq T \leq 10$。


---

---
title: "【模板】可持久化线段树 1（可持久化数组）"
layout: "post"
diff: 提高+/省选-
pid: P3919
tag: ['线段树', '平衡树', '递归', 'O2优化', '可持久化线段树', '可持久化']
---
# 【模板】可持久化线段树 1（可持久化数组）
## 题目背景

**UPDATE : 最后一个点时间空间已经放大**

2021.9.18 增添一组 hack 数据 by @panyf

标题即题意

有了可持久化数组，便可以实现很多衍生的可持久化功能（例如：可持久化并查集）

## 题目描述

如题，你需要维护这样的一个长度为 $ N $ 的数组，支持如下几种操作


1. 在某个历史版本上修改某一个位置上的值

2. 访问某个历史版本上的某一位置的值


此外，每进行一次操作（**对于操作2，即为生成一个完全一样的版本，不作任何改动**），就会生成一个新的版本。版本编号即为当前操作的编号（从1开始编号，版本0表示初始状态数组）


## 输入格式

输入的第一行包含两个正整数 $ N, M $， 分别表示数组的长度和操作的个数。

第二行包含$ N $个整数，依次为初始状态下数组各位的值（依次为 $ a_i $，$ 1 \leq i \leq N $）。

接下来$ M $行每行包含3或4个整数，代表两种操作之一（$ i $为基于的历史版本号）：

1. 对于操作1，格式为$ v_i \ 1 \ {loc}_i \ {value}_i $，即为在版本$ v_i $的基础上，将 $ a_{{loc}_i} $ 修改为 $ {value}_i $。

2. 对于操作2，格式为$ v_i \ 2 \ {loc}_i $，即访问版本$ v_i $中的 $ a_{{loc}_i} $的值，注意：**生成一样版本的对象应为 $v_i$**。

## 输出格式

输出包含若干行，依次为每个操作2的结果。

## 样例

### 样例输入 #1
```
5 10
59 46 14 87 41
0 2 1
0 1 1 14
0 1 1 57
0 1 1 88
4 2 4
0 2 5
0 2 4
4 2 1
2 2 2
1 1 5 91
```
### 样例输出 #1
```
59
87
41
87
88
46
```
## 提示

数据规模：

对于30%的数据：$ 1 \leq N, M \leq {10}^3 $

对于50%的数据：$ 1 \leq N, M \leq {10}^4 $

对于70%的数据：$ 1 \leq N, M \leq {10}^5 $

对于100%的数据：$ 1 \leq N, M \leq {10}^6, 1 \leq {loc}_i \leq N, 0 \leq v_i < i, -{10}^9 \leq a_i, {value}_i  \leq {10}^9$

**经测试，正常常数的可持久化数组可以通过，请各位放心**

~~数据略微凶残，请注意常数不要过大~~

~~另，此题I/O量较大，如果实在TLE请注意I/O优化~~

询问生成的版本是指你访问的那个版本的复制

样例说明：

一共11个版本，编号从0-10，依次为：

\* **0** : 59 46 14 87 41

\* **1** : 59 46 14 87 41

\* **2** : 14 46 14 87 41

\* **3** : 57 46 14 87 41

\* **4** : 88 46 14 87 41

\* **5** : 88 46 14 87 41

\* **6** : 59 46 14 87 41

\* **7** : 59 46 14 87 41

\* **8** : 88 46 14 87 41

\* **9** : 14 46 14 87 41

\* **10** : 59 46 14 87 91



---

---
title: "斐波那契数列"
layout: "post"
diff: 提高+/省选-
pid: P3986
tag: ['数学', '递归', '枚举', '不定方程', '斐波那契数列', '洛谷月赛']
---
# 斐波那契数列
## 题目描述

定义一个数列：


$f(0) = a, f(1) = b, f(n) = f(n - 1) + f(n - 2)$


其中 $a, b$ 均为正整数，$n \geq 2$。


问有多少种 $(a, b)$，使得 $k$ 出现在这个数列里，且不是前两项。


由于答案可能很大，你只需要输出答案模 $10^9 + 7$ 的结果即可。

## 输入格式

一行一个整数 $k$。

## 输出格式

一行一个数，表示答案模 $10^9 + 7$ 的结果。

## 样例

### 样例输入 #1
```
19260817
```
### 样例输出 #1
```
34166325
```
### 样例输入 #2
```
1000000000
```
### 样例输出 #2
```
773877569
```
## 提示

$1 \leq k \leq 10^9$



---

---
title: "小白逛公园"
layout: "post"
diff: 提高+/省选-
pid: P4513
tag: ['线段树', '递归']
---
# 小白逛公园
## 题目背景

小新经常陪小白去公园玩，也就是所谓的遛狗啦…
## 题目描述

在小新家附近有一条“公园路”，路的一边从南到北依次排着 $n$ 个公园，小白早就看花了眼，自己也不清楚该去哪些公园玩了。

一开始，小白就根据公园的风景给每个公园打了分。小新为了省事，每次遛狗的时候都会事先规定一个范围，小白只可以选择第 $a$ 个和第 $b$ 个公园之间（包括 $a, b$ 两个公园）选择连续的一些公园玩。小白当然希望选出的公园的分数总和尽量高咯。同时，由于一些公园的景观会有所改变，所以，小白的打分也可能会有一些变化。

那么，就请你来帮小白选择公园吧。
## 输入格式

第一行，两个整数 $n$ 和 $m$，分别表示表示公园的数量和操作（遛狗或者改变打分）总数。

接下来 $n$ 行，每行一个整数，依次给出小白开始时对公园的打分。

接下来 $m$ 行，每行三个整数。其中第一个整数 $k$ 为 $1$ 或 $2$。

- $k=1$ 表示，小新要带小白出去玩，接下来的两个整数 $a$ 和 $b$ 给出了选择公园的范围 $(1 \le a,b \le n)$。测试数据可能会出现 $a > b$ 的情况，需要进行交换；
- $k=2$ 表示，小白改变了对某个公园的打分，接下来的两个整数 $p$ 和 $s$，表示小白对第 $p$ 个公园的打分变成了 $s(1\le p\le N)$。
## 输出格式

小白每出去玩一次，都对应输出一行，只包含一个整数，表示小白可以选出的公园得分和的最大值。
## 样例

### 样例输入 #1
```
5 3
1
2
-3
4
5
1 2 3
2 2 -1
1 2 3
```
### 样例输出 #1
```
2
-1
```
## 提示

### 数据规模与约定

对于 $100\%$ 的数据，$1 \le n \le 5 \times 10^5$，$1 \le m \le 10^5$，所有打分都是绝对值不超过 $1000$ 的整数。


---

---
title: "【模板】自适应辛普森法 1"
layout: "post"
diff: 提高+/省选-
pid: P4525
tag: ['数学', '递归', '积分', '定积分']
---
# 【模板】自适应辛普森法 1
## 题目描述

试计算积分

$\displaystyle{\int_L^R\frac{cx+d}{ax+b}\mathrm{d}x}$

结果保留至小数点后 $6$ 位。

数据保证计算过程中分母不为 $0$ 且积分能够收敛。
## 输入格式

一行，包含 $6$ 个实数 $a,b,c,d,L,R$。
## 输出格式

一行，积分值，保留至小数点后 $6$ 位。
## 样例

### 样例输入 #1
```
1 2 3 4 5 6
```
### 样例输出 #1
```
2.732937
```
## 提示

$a,b,c,d\in[-10,10]$，$-100\le L<R\le 100$ 且 $R-L\ge1$。


---

---
title: "经验"
layout: "post"
diff: 提高+/省选-
pid: P5032
tag: ['递归', 'O2优化', '优先队列', '队列']
---
# 经验
## 题目背景

[赛时答疑](https://www.luogu.org/discuss/show/80694)  

**简略版已经更新，时限改为500ms**

攒够经验附魔去~~

Steve在minecraft中总是会遇上难题：
他想要修理n本附魔书，每本附魔书的等级为ai，他总是不知道铁砧修理和经验值的机制。他便在mcwiki上搜索到了一些资料：
![](https://d1u5p3l4wpay3k.cloudfront.net/minecraft_zh_gamepedia/pChart4mw/e8160a1cad02998149d79c65237dc775.png)

----图为经验值与等级的关系，摘自mcwiki 

他看到这个图，就想：我等级升的越高，我所需要的经验值便越多，那么如果我等级刚好够铁砧修理的话，那我所耗费的经验不就越少了吗？他便继续搜索了下去，并将铁砧机制附在了下面,让你帮他解决问题：
## 题目描述

**累积惩罚：**

无论是重命名、修复、还是合并操作，其经验花费都会因其物品先前在铁砧上的操作而增加，这些额外增加的花费被称作“累积惩罚”。对于一件从未放上铁砧的物品，累积惩罚为0。

一个物品每次在铁砧上操作过后（不包括重命名），其累积惩罚都会先乘2再加1。如此一来，一个物品在操作过N次后累积惩罚是2^N-1。6次操作之后，累积惩罚是63级，此时生存模式下无法再作进一步的修复和附魔工作。31次操作后，惩罚等级是2147483647级，此时在任何模式下都不能再进行操作。

当合并两个物品时，玩家会同时受到两件物品的累积惩罚。合并后物品的累积惩罚根据先前两个物品中较高者计算。例如，合并两个累积惩罚分别是3级和15级的物品会额外花费18级的惩罚经验，而合并后的物品惩罚是31级（15*2+1）。

累积惩罚甚至会作用在不会磨损的物品上，譬如附魔书。因此，合并4本时运 I 的附魔书，会得到一本累积惩罚为3的时运 III 附魔书。

     累计操作数	      惩罚

         0	           0

         1	           1

         2	           3

         3	           7

         4	           15

         5	           31

使用合成方格进行的物品修复操作会移除所有累积惩罚，但也会丢失所有的魔咒。

**合并物品：**

铁砧界面中第一格/左边的物品称为目标物品；第二格/右边的物品称为牺牲物品——合并后会消失。如果牺牲物品附有魔咒，铁砧会同时试图将牺牲物品的附魔合并至目标物品上。无论目标物品上的魔咒是否产生实际变化，铁砧都将根据目标物品与牺牲物品上的魔咒收取玩家的等级耗费。

对于牺牲物品上的每个魔咒来说：如果目标物品也拥有相同的魔咒：

当牺牲物品的魔咒等级较高时，目标物品魔咒的等级将上升至牺牲物品上的等级。

当牺牲物品的魔咒等级相同时，目标物品上魔咒的等级将提升1级，除非其等级已为最高。    

当牺牲物品的魔咒等级较低时，目标物品上该魔咒的等级不变。
    
合并物品的总花费将是下列费用之和：

1.目标物品和牺牲物品的累积惩罚之和。

2.如果同时进行重命名，则额外产生重命名的费用。

3.如果目标物品耐久度未满，则耗费2级用于维修。

4.如果牺牲物品拥有魔咒，则产生附魔费用。

5.如果牺牲物品是一本附魔书，则不会产生维修费用，铁砧会尝试将书本上的魔咒合并至目标物品上。亦可同时对目标物品进行重命名。此时的附魔花费一般会少于合并两个类似物品的费用。

-----摘自mc wiki，稍作删改

**简略版：**  
给出附魔书，只有同等等级的才能合并。合并的代价为两本书的累计代价之和。合成后的书的累计代价为合成前最大代价的2倍加上1。求最高等级和最小花费（要求最高等级为第一关键字）,Steve因为开了挂，所以最高等级不限

现给出$n$本附魔书，每本附魔书有它的等级$ai$,问如何才能得到附魔书的最大等级$x$，在此基础上，请计算合成它消耗的最小等级$y$。（我们假设每本附魔书初始的累积惩罚为1）。

Steve很懒，他不想看上面的话，他只想要让你编写出一个程序计算出$x$与$y$。但Steve为了不外传，他只要求你输出$x$在模$y$意义下的乘法逆元$k$即可。如果没有，请输出$-1$.
## 输入格式

第一行为一个整数$n$

接下来$n$行，每行均有一个整数$ai$，表示每本附魔书的初始等级，不保证数据有序.
## 输出格式

一个整数$k$,表示$x$在模$y$意义下的乘法逆元,如果没有，请输出$-1$.  
PS：乘法逆元$k$也可以这样理解: $k$是使得 $kx\equiv1(mod$ $y)$的最小正整数
## 样例

### 样例输入 #1
```
5
1 1 2 3 4
```
### 样例输出 #1
```
-1
```
### 样例输入 #2
```
4
1 1 1 1
```
### 样例输出 #2
```
7
```
## 提示

**样例解释**
 
第一个样例：    
合并两个第一等级的，合并花费2经验，代价升为3  
再合并两个第二等级的，花费3+1=4经验，代价升为7  
再合并两个第三等级的，花费7+1=8经验，代价升为15  
最后合并两个第四等级的，花费15+1=16经验，代价升为31  

经验总花费：2+4+8+16=30，最大等级：5


对于第一个样例: $x=5$,$y=30$;

对于第二个样例: $x=3$,$y=10$;

**数据范围**

![]( https://cdn.luogu.com.cn/upload/pic/41547.png )

保证数据随机，$x$,$y$,$k$在long int范围内

**温馨提示**

本题读入量较大，请使用较快的读入方法，在此，提供一种快速读入的样式：(需包含头文件<cctype>)

```
#include<cctype>
inline void read(int &x){
     char ch=getchar();x=0;
     while(!isdigit(ch))   ch=getchar();
     while(isdigit(ch))   x=x*10+ch-'0',ch=getchar();
}
```


---

---
title: "「EZEC-1」数列"
layout: "post"
diff: 提高+/省选-
pid: P6435
tag: ['递归', '矩阵运算']
---
# 「EZEC-1」数列
## 题目描述

给你一个正整数 $n$，有数列 $1,2,3,...,n$。

分别求相邻两项中左边一项的 $a$ 倍与右边一项的 $b$ 倍的和再加上 $c$，得到一个有 $n-1$ 项的新数列：

 $1\times a+2\times b+c,2\times a+3\times b +c,...,(n-1)\times a+n\times b+c$。

对这个新数列重复上述操作得到若干数列，最后的数列只有一项，求最后这个项对 $p$ 取模的值。
## 输入格式

一行，五个**非负**整数 $n,a,b,c,p$。
## 输出格式

一个整数，表示答案对 $p$ 取模的值。
## 样例

### 样例输入 #1
```
1 1 1 1 1000000007
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
4 2 3 1 1000000007
```
### 样例输出 #2
```
381
```
### 样例输入 #3
```
23 19 17 0 1000000007
```
### 样例输出 #3
```
323147645
```
### 样例输入 #4
```
233 233 233 233 1000000000
```
### 样例输出 #4
```
770969703
```
## 提示

【样例解释】

样例 2：

各数列分别为：
```
1 2 3 4
9 14 19
61 86
381
```

------------

【数据范围】

| 测试点编号 | $n\le$ | $p\le$ | $a,b\le$| $c\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
|$1\sim 4$ | $10^3$ | $10^9+7$ | $10$ |$10$|
|$5\sim 8$ | $10^6$ | $10^{14}$ | $10^3$ |$10^3$|
|$9,10$ | $10^9$ | $10^9+7$ | $1$ |$0$|
|$11,12$ | $10^9$ | $10^9+7$ | $1$ |$10^9$|
|$13,14$ | $10^{18}$ | $10^9+7$ | $1$ |$10^9$|
|$15,16$ | $10^{18}$ | $10^9+7$ | $10^9$|$10^9$|
|$17 \sim 20$ | $10^{18}$ | $10^{14}$ | $10^9$|$10^9$|

- 对于 $80 \% $ 的数据，满足 $p$ 为质数。

- 对于 $100 \% $ 的数据，满足 $1\le n\le 10^{18}$，$1\le p \le 10^{14}$，$1 \le a,b\le 10^9$，$0\le c \le 10^9$。


---

---
title: "Mirror"
layout: "post"
diff: 提高+/省选-
pid: P7264
tag: ['递归', '2021']
---
# Mirror
## 题目背景

![Mirror](https://mivik.gitee.io/image/nurture/mirror.png)

> And it’s not the voice of all the others
>
> You’ve only said it to yourself
>
> I know what you want from me, from me
>
> I know what you’re thinking
## 题目描述

> Porter Robinson: We all have these avatars that we give to our critical inner voices - we might imagine a scornful parent telling us we’ll fail, or a critic telling us our work comes up short, or a society telling us that we aren’t good enough - it’s about recognizing that most of this criticism is self-inflicted.

Mivik 在镜中看见了自己的 Inner Voice ——不过是在一个镜子般对称的迷宫中。这个迷宫很特殊：它有无穷多行和无穷多列，行和列都从 $0$ 开始标号。一个格子 $(i,j)$ 能通过（没有障碍）当且仅当 $(i\&j)=0$，其中 $\&$ 指按位与运算（Bitwise And，[百度百科](https://baike.baidu.com/item/%E6%8C%89%E4%BD%8D%E4%B8%8E/9601818)）。下图给出了这个迷宫的 $0\sim63$ 行和 $0\sim 63$ 列的图像：

![迷宫](https://cdn.luogu.com.cn/upload/image_hosting/das5c73w.png)

Mivik 想抓到并消灭那个给予自己负面声音的 Inner Voice，但他找不到路了。Mivik 和 Inner Voice 最初处在迷宫中的两点。Mivik 想知道，在 Mivik 的 Inner Voice 一直不移动的情况下，他至少需要走过多少个方格才能抓到他的 Inner Voice（Mivik 的起始格不算）。

但是... 游戏并不会像 Mivik 想象的一样简单。邪恶的 ggy 在这个迷宫中的某些格子布下了许多炸弹，Mivik 需要拆除它们才能踏上这些格子。Mivik 需要你告诉他，在他走过的方格数最少的情况下，他至少需要拆除哪些炸弹。

**请注意炸弹可能会重合，而你只有拆除一个格子上的所有炸弹才能通过这个格子。保障炸弹不与起点重合。**
## 输入格式

第一行一个整数 $n$，代表 ggy 设下的炸弹个数。

接下来 $n$ 行，**其中的**第 $i$ 行两个非负整数，代表 $i$ 号炸弹的坐标（从 1 开始编号）。

接下来一行两个非负整数 $sx$ 和 $sy$，代表 Mivik 位于哪一行哪一列。

接下来一行两个非负整数 $ex$ 和 $ey$，代表 Mivik 的 Inner Voice 位于哪一行哪一列。
## 输出格式

第一行一个整数，代表 Mivik 至少需要走少格才能抓到他的 Inner Voice。

接下来一行，给出一个长度为 $n$ 的 01 串，第 $i$ 个字符为 `1` 代表 Mivik 必须拆除第 $i$ 号炸弹，`0` 代表不需要。
## 样例

### 样例输入 #1
```
0
0 0
0 2
```
### 样例输出 #1
```
2

```
### 样例输入 #2
```
3
0 0
0 2
1 2
4 2
3 4
```
### 样例输出 #2
```
13
110
```
### 样例输入 #3
```
0
12 34
3 100
```
### 样例输出 #3
```
85

```
## 提示

### 样例解释

样例一：显然由于没有任何炸弹，Mivik 向右走两格就能抓到他的 Inner Voice。

样例二：Mivik 的最短路径如图所示：

![路径](https://cdn.luogu.com.cn/upload/image_hosting/mg0hmhgs.png)

其中，图片左上角为 $(0,0)$，蓝色代表 Mivik 的起始位置，绿色代表 Inner Voice 的位置，红色代表 Mivik 的最短路径，黄色代表炸弹，橙色（其实是黄色 + 红色）代表 Mivik 必须拆除的炸弹。

### 数据范围

对于全部数据，有 $1\le n\le 2\cdot 10^5$，$(sx,sy)\ne(ex,ey)$，并保证对于给出的任何坐标 $(x,y)$ 都有 $x\&y=0$ 且 $0\le x,y\le 10^{18}$。

Subtask 1 (10 pts)：保证 Mivik 可以直线（只向 上/下/左/右 走）抓到他的 Inner Voice。

Subtask 2 (15 pts)：保证 $sx=sy=0$。

Subtask 3 (20 pts)：保证 $0\le(\text{任意 x,y 坐标})\le 100$。

Subtask 4 (25 pts)：保证 $n=0$。

Subtask 5 (30 pts)：无特殊限制。


---

---
title: "[USACO21FEB] Count the Cows G"
layout: "post"
diff: 提高+/省选-
pid: P7415
tag: ['USACO', '递归', '2021', 'O2优化', '分治', '数位 DP']
---
# [USACO21FEB] Count the Cows G
## 题目描述

如同平常一样，Farmer John 的奶牛们分散在他的最大的草地上。草地可以看作是一个由正方形方格组成的巨大的二维方阵（想象一个巨大的棋盘）。 

奶牛分布在草地上的方式相当迷人。对于每一个满足 $x\ge 0$ 以及 $y\ge 0$ 的方格 $(x,y)$，当对于所有整数 $k\ge 0$，$\left\lfloor \frac{x}{3^k}\right\rfloor$ 和 $\left\lfloor \frac{y}{3^k}\right\rfloor$ 除以三的余数的奇偶性均相同时，有一头奶牛位于 $(x,y)$。换言之，两个余数均为奇数（均等于 $1$），或均为偶数（均等于 $0$ 或 $2$）。例如，满足 $0\le x,y<9$ 的方格中，包含奶牛的方格在下图中用 1 表示。

```
        x
    012345678

  0 101000101
  1 010000010
  2 101000101
  3 000101000
y 4 000010000
  5 000101000
  6 101000101
  7 010000010
  8 101000101
```

FJ 对他的草地上的某个特定区域内的奶牛数量感兴趣。他进行了 $Q$ 个询问，每个询问由三个整数 $x_i,y_i,d_i$ 组成。对每个询问，FJ 想要知道有多少奶牛位于 $(x_i,y_i)$ 至 $(x_i+d_i,y_i+d_i)$ 的对角线上的方格内（包括两端）。

## 输入格式

输入的第一行包含 $Q$（$1\le Q\le 10^4$），为询问的数量。

以下 $Q$ 行每行包含三个整数 $d_i$，$x_i$ 和 $y_i$（$0\le x_i,y_i,d_i\le 10^{18}$）。

## 输出格式

输出 $Q$ 行，每个询问输出一行。
## 样例

### 样例输入 #1
```
8
10 0 0
10 0 1
9 0 2
8 0 2
0 1 7
1 1 7
2 1 7
1000000000000000000 1000000000000000000 1000000000000000000
```
### 样例输出 #1
```
11
0
4
3
1
2
2
1000000000000000001
```
## 提示

#### 测试点性质：

 - 对于另外 $8\%$ 的数据，满足对于每一个询问有 $d_i\le 100$。
 - 对于另外 $32\%$ 的数据，满足对于每一个询问有 $x+d=3^{30}-1$ 以及 $y=0$。
 - 对于另外 $52\%$ 的数据，没有额外限制。

供题：Benjamin Qi


---

---
title: "[KSN2021] Binary Sea"
layout: "post"
diff: 提高+/省选-
pid: P7970
tag: ['递归', '2021', '位运算']
---
# [KSN2021] Binary Sea
## 题目描述

有一个 $N\times M$ 的网格，行列从 $0$ 开始，从左上到右下编号。

第 $i$ 行，第 $j$ 列的格子是黑格当且仅当 $i\text{ and }j=0$。

两个黑格联通当且仅当它们都是黑格且它们可以经过若干个有**邻边**的黑格到达。

给定 $Q$ 个矩形，左上角为 $(x_1,y_1)$，右下角为 $(x_2,y_2)$，你需要对于每个矩形求出所有的黑格形成了多少连通块。
## 输入格式

第一行输入三个整数 $N,M,Q$，代表网格大小和询问数量。

接下来 $Q$ 行，每行输入四个整数 $x_1,y_1,x_2,y_2$，代表询问矩形。
## 输出格式

对于每组数据输出一行，包含一个整数，代表答案。
## 样例

### 样例输入 #1
```
6 5 4
0 0 3 2
0 2 1 3
0 1 2 4
5 4 5 4
```
### 样例输出 #1
```
1
1
2
0
```
## 提示

**【样例解释】**

以下为样例中四个询问的图示：

![](https://api.tlx.toki.id/api/v2/problems/JIDPROGSepzakraFyFK27n5u3QV/render/sample-q1.png) ![](https://api.tlx.toki.id/api/v2/problems/JIDPROGSepzakraFyFK27n5u3QV/render/sample-q2.png) ![](https://api.tlx.toki.id/api/v2/problems/JIDPROGSepzakraFyFK27n5u3QV/render/sample-q3.png) ![](https://api.tlx.toki.id/api/v2/problems/JIDPROGSepzakraFyFK27n5u3QV/render/sample-q4.png)

**【数据范围】**

**本题采用捆绑测试。**

* Subtask 1（5 points）：只存在一组数据，满足 $N = M=12$，$Q=3$，每次询问的 $(x_1,y_1,x_2,y_2)$ 依次为 $(1,1,9,8)$，$(8,8,11,11)$ 和 $(4,3,5,9)$。
* Subtask 2（11 points）：$N,M,Q\le 200$。
* Subtask 3（10 points）：$N,M,Q\le 2000$，$x_1=x_2$。
* Subtask 4（20 points）：$N,M,Q\le 2000$。
* Subtask 5（4 points）：$x_1=x_2=0$。
* Subtask 6（6 points）：保证对于每个询问存在整数 $k$ 使得 $x_1=x_2=2^k$。
* Subtask 7（29 points）：$x_1=x_2$。
* Subtask 8（15 points）：无特殊限制。

对于所有数据，$0\leq x_1\leq x_2<N\leq 10^9$，$0\leq y_1\leq y_2<M\leq 10^9$，$1\leq Q\leq 10^5$。


---

---
title: "[USACO23JAN] Find and Replace G"
layout: "post"
diff: 提高+/省选-
pid: P9016
tag: ['字符串', '搜索', 'USACO', '递归', '2023']
---
# [USACO23JAN] Find and Replace G
## 题目描述

Bessie is using the latest and greatest innovation in text-editing software, miV! Its powerful find-and-replace feature allows her to find all occurrences of a lowercase English letter $c$ and replace each with a nonempty string of lowercase letters $s$. For example, given the string `ball`, if Bessie selects $c$ to be `l` and $s$ to be `na`, the given string transforms into `banana`.

Bessie starts with the string `a` and transforms it using a number of these find-and-replace operations, resulting in a final string $S$. Since $S$ could be massive, she wants to know, given $l$ and $r$ with $1 \le l \le r \min(|S|,10^{18})$, what $S_{l\cdots r}$ (the substring of $S$ from the $l$-th to the $r$-th character inclusive) is.

It is guaranteed that the sum of $|s|$
over all operations is at most $2 \cdot 10^5$, and that $r−l+1 \le 2 \cdot 10^5$. 
## 输入格式

The first line contains $l, r$, and the number of operations.

Each subsequent line describes one operation and contains $c$ and $s$ for that operation. All characters are in the range `a` through `z`.


## 输出格式

Output the string $S_{l \cdots r}$ on a single line. 
## 样例

### 样例输入 #1
```
3 8 4
a ab
a bc
c de
b bbb
```
### 样例输出 #1
```
bdebbb
```
## 提示

### Explanation for Sample 1

The string is transformed as follows:

$$ \texttt{a} \rightarrow \texttt{ab} \rightarrow\texttt{bcb}\rightarrow \texttt{bdeb}\rightarrow \texttt{bbbdebbb} $$

### Scoring

 - Inputs $2-7$: $\sum |s|,r−l+1 \le 2000$
 - Inputs $8-15$: No additional constraints.
## 题目翻译

#### 【题目描述】
你有一个字符串 $S$，最开始里面只有一个字符 $\text{a}$，之后你要对这个字符串进行若干次操作，每次将其中每一个字符 $c$ 替换成某个字符串 $s$（例如对于字符串 $\text{ball}$，将其中的 $\text{l}$ 替换为 $\text{na}$ 后将会变为 $\text{banana}$）。现在给定 $l,r$，你需要输出 $S_{l\ldots r}$（也就是 $S$ 的第 $l$ 个字符到第 $r$ 个字符对应的子串）是什么。

#### 【输入格式】
第一行三个整数，分别表示 $l,r$ 和操作次数。

接下来每一行一个字符 $c$ 和一个字符串 $s$，意义见题目描述。

#### 【输出格式】
一行，表示对应的子串。

#### 【数据范围】
$l,r\le\min(\left | S \right |,10^{18})$；

$r-l+1\le2\times10^5$；

$\sum\left | s \right | \le 2\times 10^5$。

所有的字符串都只包含小写字母 $\text{a}-\text{z}$。

其中对于测试点 $2-7$，满足：

$r-l+1\le2000$，$\sum\left | s \right | \le 2000$。


---


---
title: "[CSP-S 2024] 决斗"
layout: "post"
diff: 普及-
pid: P11231
tag: ['2024', 'O2优化', 'CSP-S 提高级']
---
# [CSP-S 2024] 决斗
## 题目描述

今天是小 Q 的生日，他得到了 $n$ 张卡牌作为礼物。这些卡牌属于火爆的“决斗怪兽”，其中，第 $i$ 张卡代表一只攻击力为 $r_i$，防御力也为 $r_i$ 的怪兽。

一场游戏分为若干回合。每回合，小 Q 会选择某只怪兽 $i$ 以及**另一只**怪兽 $j(i \neq j)$，并让怪兽 $i$ 向怪兽 $j$ 发起攻击。此时，若怪兽 $i$ 的攻击力小于等于怪兽 $j$ 的防御力，则无事发生；否则，怪兽 $j$ 的防御被打破，怪兽 $j$ 退出游戏不再参与到剩下的游戏中。一只怪兽在整场游戏中**至多**只能发起一次攻击。当未退出游戏的怪兽都已发起过攻击时，游戏结束。

小 Q 希望决定一组攻击顺序，使得在游戏结束时，未退出游戏的怪兽数量尽可能少。
## 输入格式

输入的第一行包含一个正整数 $n$，表示卡牌的个数。

输入的第二行包含 $n$ 个正整数，其中第 $i$ 个正整数表示第 $i$ 个怪兽的攻击力及防御力 $r_i$。
## 输出格式

输出一行包含一个整数表示游戏结束时未退出游戏的怪兽数量的最小值。
## 样例

### 样例输入 #1
```
5
1 2 3 1 2
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
10
136 136 136 2417 136 136 2417 136 136 136
```
### 样例输出 #2
```
8
```
## 提示

**【样例 1 解释】**

其中一种最优方案为：第一回合让第 $2$ 只怪兽向第 $1$ 只怪兽发起攻击，第二回合让第 $5$ 只怪兽向第 $4$ 只怪兽发起攻击，第三回合让第 $3$ 只怪兽向第 $5$ 只怪兽发起攻击。此时没有退出游戏的怪兽都进行过攻击，游戏结束。可以证明没有更优的攻击顺序。

**【样例 3】**

见选手目录下的 duel/duel3.in 与 duel/duel3.ans。

该样例满足 $\forall 1 \leq i \leq n, r_i \leq 2$。

**【样例 4】**

见选手目录下的 duel/duel4.in 与 duel/duel4.ans。

**【数据范围】**

对于所有测试数据，保证：$1 \leq n \leq 10^5$，$1 \leq r_i \leq 10^5$。

| 测试点 | $n$ | $r_i$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim 4$ | $\leq 10$ | $\leq 10^5$ | 无特殊性质 |
| $5\sim 10$ | $\leq 10^5$ | $\leq 2$ | 无特殊性质 |
| $11\sim 15$ | $\leq 30$ | $\leq 10^5$ | 特殊性质 A |
| $16\sim 20$ | $\leq 10^5$ | $\leq 10^5$ | 无特殊性质 |

特殊性质 A：保证每个 $r_i$ 在可能的值域中独立均匀随机生成。


---

---
title: "[CSP-S2019] 格雷码"
layout: "post"
diff: 普及-
pid: P5657
tag: ['数学', '2019', '递归', 'CSP-S 提高级']
---
# [CSP-S2019] 格雷码
## 题目描述

通常，人们习惯将所有 $n$ 位二进制串按照字典序排列，例如所有 2 位二进制串按字典序从小到大排列为：00，01，10，11。

格雷码（Gray Code）是一种特殊的 $n$ 位二进制串排列法，它要求相邻的两个二进制串间**恰好**有一位**不同**，特别地，第一个串与最后一个串也算作相邻。

所有 2 位二进制串按格雷码排列的一个例子为：00，01，11，10。

$n$ 位格雷码不止一种，下面给出其中一种格雷码的生成算法：
1. 1 位格雷码由两个 1 位二进制串组成，顺序为：0，1。
2. $n + 1$ 位格雷码的前 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**顺序**排列，再在每个串前加一个前缀 0 构成。
3. $n + 1$ 位格雷码的后 $2^n$ 个二进制串，可以由依此算法生成的 $n$ 位格雷码（总共 $2^n$ 个 $n$ 位二进制串）按**逆序**排列，再在每个串前加一个前缀 1 构成。

综上，$n + 1$ 位格雷码，由 $n$ 位格雷码的 $2^n$ 个二进制串按顺序排列再加前缀 0，和按逆序排列再加前缀 1 构成，共 $2^{n+1}$ 个二进制串。另外，对于 $n$ 位格雷码中的 $2^n$ 个 二进制串，我们按上述算法得到的排列顺序将它们从 $0 \sim 2^n - 1$ 编号。

按该算法，2 位格雷码可以这样推出：

1. 已知 1 位格雷码为 0，1。
2. 前两个格雷码为 00，01。后两个格雷码为 11，10。合并得到 00，01，11，10，编号依次为 0 ~ 3。

同理，3 位格雷码可以这样推出：

1. 已知 2 位格雷码为：00，01，11，10。
2. 前四个格雷码为：000，001，011，010。后四个格雷码为：110，111，101，100。合并得到：000，001，011，010，110，111，101，100，编号依次为 0 ~ 7。

现在给出 $n$，$k$，请你求出按上述算法生成的 $n$ 位格雷码中的 $k$ 号二进制串。

## 输入格式

仅一行两个整数 $n$，$k$，意义见题目描述。
## 输出格式

仅一行一个 $n$ 位二进制串表示答案。
## 样例

### 样例输入 #1
```
2 3
```
### 样例输出 #1
```
10
```
### 样例输入 #2
```
3 5
```
### 样例输出 #2
```
111
```
### 样例输入 #3
```
44 1145141919810
```
### 样例输出 #3
```
00011000111111010000001001001000000001100011
```
## 提示

【样例 1 解释】

2 位格雷码为：00，01，11，10，编号从 0∼3，因此 3 号串是 10。

【样例 2 解释】

3 位格雷码为：000，001，011，010，110，111，101，100，编号从 0∼7，因此 5 号串是 111。

【数据范围】

对于 $50\%$ 的数据：$n \leq 10$

对于 $80\%$ 的数据：$k \leq 5 \times 10^6$

对于 $95\%$ 的数据：$k \leq 2^{63} - 1$

对于 $100\%$ 的数据：$1 \leq n \leq 64$, $0 \leq k \lt 2^n$


---

---
title: "[CSP-S2019 江西] 日期"
layout: "post"
diff: 普及-
pid: P5690
tag: ['2019', 'CSP-S 提高级']
---
# [CSP-S2019 江西] 日期
## 题目背景

CSP-SJX2019 T1
## 题目描述

Alice 在纸上写下了一个日期，形式为 $\text{MM-DD}$，其中 $\text{MM}$ 与 $\text{DD}$ 都是两位数字，分别表示月和天，然而这个日期并不一定存在。 Alice 找来了 Bob 要他更改若干位上的数字，使得这个日期存在。请你帮 Bob 算算他最少需要更改几位数字。

本题中我们认为 $2$ 月固定为 $28$ 天。
## 输入格式

仅一行一个五个字符的字符串，表示 $\text{MM-DD}$ 。
## 输出格式

仅一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
03-32
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
02-39
```
### 样例输出 #2
```
1
```
### 样例输入 #3
```
67-89
```
### 样例输出 #3
```
2
```
## 提示

【输入输出样例 1 说明】

更改方式不止一种，其中一种方式是改为： $\text{03-22}$。

【输入输出样例 2 说明】

一种更改方式为：$\text{02-09}$。

【输入输出样例 3 说明】

一种更改方式为：$\text{07-09}$。

【数据规模与约定】
对于 $100\%$ 的数据：$\text{MM}$ 与 $\text{DD}$ 一定为 $4$ 个数字。

**update: 2024/07/04 增加 hack 一组。**


---

---
title: "[CSP-S 2023] 密码锁"
layout: "post"
diff: 普及-
pid: P9752
tag: ['2023', 'O2优化', 'CSP-S 提高级']
---
# [CSP-S 2023] 密码锁
## 题目描述

小 Y 有一把五个拨圈的密码锁。如图所示，每个拨圈上是从 $0$ 到 $9$ 的数字。每个拨圈都是从 $0$ 到 $9$ 的循环，即 $9$ 拨动一个位置后可以变成 $0$ 或 $8$，

![](https://cdn.luogu.com.cn/upload/image_hosting/aku4duog.png)

因为校园里比较安全，小 Y 采用的锁车方式是：从正确密码开始，随机转动密码锁仅一次；每次都是以某个幅度仅转动一个拨圈或者同时转动两个相邻的拨圈。

当小 Y 选择同时转动两个相邻拨圈时，两个拨圈转动的幅度相同，即小 Y 可以将密码锁从 $\tt{0\;0\;1\;1\;5}$ 转成 $\tt{1\;1\;1\;1\;5}$，但不会转成 $\tt{1\;2\;1\;1\;5}$。

时间久了，小 Y 也担心这么锁车的安全性，所以小 Y 记下了自己锁车后密码锁的 $n$ 个状态，注意这 $n$ 个状态都不是正确密码。

为了检验这么锁车的安全性，小 Y 有多少种可能的正确密码，使得每个正确密码都能够按照他所采用的锁车方式产生锁车后密码锁的全部 $n$ 个状态。
## 输入格式

输入的第一行包含一个正整数 $n$，表示锁车后密码锁的状态数。

接下来 $n$ 行每行包含五个整数，表示一个密码锁的状态。
## 输出格式

输出一行包含一个整数，表示密码锁的这 $n$ 个状态按照给定的锁车方式能对应多少种正确密码。
## 样例

### 样例输入 #1
```
1
0 0 1 1 5
```
### 样例输出 #1
```
81
```
## 提示

**【样例 1 解释】**

一共有 $81$ 种可能的方案。

其中转动一个拨圈的方案有 $45$ 种，转动两个拨圈的方案有 $36$ 种。

**【样例 2】**

见选手目录下的 lock/lock2.in 与 lock/lock2.ans。

**【数据范围】**

对于所有测试数据有：$1 \leq n \leq 8$。

| 测试点 | $n\leq$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 3$ | $1$ | 无 |
| $4\sim 5$ | $2$ | 无 |
| $6\sim 8$ | $8$ | A |
| $9\sim 10$ | $8$ | 无 |

特殊性质 A：保证所有正确密码都可以通过仅转动一个拨圈得到测试数据给出的 $n$ 个状态。


---


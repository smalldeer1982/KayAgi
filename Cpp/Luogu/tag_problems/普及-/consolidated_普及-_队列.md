---
title: "【模板】队列"
layout: "post"
diff: 普及-
pid: B3616
tag: ['队列']
---
# 【模板】队列
## 题目描述

请你实现一个队列（queue），支持如下操作：
- `push(x)`：向队列中加入一个数 $x$。
- `pop()`：将队首弹出。如果此时队列为空，则不进行弹出操作，并输出 `ERR_CANNOT_POP`。
- `query()`：输出队首元素。如果此时队列为空，则输出 `ERR_CANNOT_QUERY`。
- `size()`：输出此时队列内元素个数。
## 输入格式

第一行，一个整数 $n$，表示操作的次数。  

接下来 $n$ 行，每行表示一个操作。格式如下：

- `1 x`，表示将元素 `x` 加入队列。
- `2`，表示将队首弹出队列。
- `3`，表示查询队首。
- `4`，表示查询队列内元素个数。

## 输出格式

输出若干行，对于每个操作，按「题目描述」输出结果。

每条输出之间应当用空行隔开。
## 样例

### 样例输入 #1
```
13
1 2
3
4
1 233
3
2
3
2
4
3
2
1 144
3
```
### 样例输出 #1
```
2
1
2
233
0
ERR_CANNOT_QUERY
ERR_CANNOT_POP
144
```
## 提示

### 样例解释
首先插入 `2`，队首为 `2`、队列内元素个数为 `1`。  
插入 `233`，此时队首为 `2`。  
弹出队首，此时队首为 `233`。  
弹出队首，此时队首为空。  
再次尝试弹出队首，由于队列已经为空，此时无法弹出。  
插入 `144`，此时队首为 `144`。  



### 数据规模与约定

对于 $100\%$ 的测试数据，满足 $n\leq 10000$，且被插入队列的所有元素值是 $[1, 1000000]$ 以内的正整数。



---

---
title: "[蓝桥杯青少年组国赛 2022] 报数游戏"
layout: "post"
diff: 普及-
pid: B4295
tag: ['模拟', '2022', '队列', '蓝桥杯青少年组']
---
# [蓝桥杯青少年组国赛 2022] 报数游戏
## 题目描述

某班级男生人数为 $X$ 人，女生人数为 $Y$ 人，现全班同学围成一个圆圈，并按照顺时针方向为每名同学编号（从 $1$ 到 $X+Y$）。现给出一个正整数 $K$（$2<K<(X+Y)$），从编号为 $1$ 的同学开始顺时针方向报数，报到 $K$ 的同学退出圆圈，下一名同学继续从 $1$ 报数，再次报到 $K$ 的同学退出圆圈。如此循环，直到剩余人数为 $X$ 时游戏结束。

请你计算出游戏开始时 $X$ 名男生分别应该排在什么位置，才能保证每次离开的都是女生，游戏结束时剩余 $X$ 人都是男生。并将游戏开始时每名男生的位置编号按照从小到大顺序输出。

例如：$X=5$，$Y=3$，$K=3$，$8$ 名同学按照如下图的顺序排列（蓝色为男生位置，红色为女生位置），可以使 $3$ 轮报数过后最后剩余的 $5$ 名同学都为男生。故 $5$ 名男同学的编号分别为 $2$、$4$、$5$、$7$、$8$。

![](https://cdn.luogu.com.cn/upload/image_hosting/lhokokoq.png)
## 输入格式

输入三个正整数 $X$、$Y$、$K$（$3 \leq X \leq 100$，$3 \leq Y \leq 100$，$2 < K < (X+Y)$），$X$ 表示男生人数，$Y$ 表示女生人数，$K$ 表示报数的关键数字，三个正整数之间以一个空格隔开。

## 输出格式

输出 $X$ 个整数，表示每名男生位置编号按照从小到大的顺序排列，编号之间以一个空格隔开。
## 样例

### 样例输入 #1
```
5 3 3
```
### 样例输出 #1
```
2 4 5 7 8
```


---

---
title: "占卜DIY"
layout: "post"
diff: 普及-
pid: P10457
tag: ['模拟', '队列']
---
# 占卜DIY
## 题目描述

lyd 学会了使用扑克 DIY 占卜。方法如下：一副去掉大小王的扑克共 $52$ 张，打乱后均分为 $13$ 堆，编号 $1\sim 13$，每堆 $4$ 张，其中第 $13$ 堆称作“生命牌”，也就是说你有 $4$ 条命。这里边，$4$ 张 $K$ 被称作死神。

初始状态下，所有的牌背面朝上扣下。

流程如下：

- 抽取生命牌中的最上面一张（第一张）。
- 把这张牌翻开，正面朝上，放到牌上的数字所对应编号的堆的最上边。(例如抽到 $2$ ，正面朝上放到第 $2$ 堆牌最上面，又比如抽到 $J$，放到第 $11$ 堆牌最上边，注意是正面朝上放)
- 从刚放了牌的那一堆最底下（最后一张）抽取一张牌，重复第 $2$ 步。（例如你上次抽了 $2$ ，放到了第二堆顶部，现在抽第二堆最后一张发现是 $8$，又放到第 $8$ 堆顶部……）
- 在抽牌过程中如果抽到 $K$，则称死了一条命，就扔掉 $K$ 再从第 $1$ 步开始。
- 当发现四条命都死了以后，统计现在每堆牌上边正面朝上的牌的数目，只要同一数字的牌出现 $4$ 张正面朝上的牌（比如 $4$ 个 $A$），则称“开了一对”，当然 $4$ 个 $K$ 是不算的。
- 统计一共开了多少对，开了 $0$ 对称作"极凶"，$1\sim 2$ 对为“大凶”，$3$ 对为“凶”，$4\sim 5$ 对为“小凶”，$6$ 对为“中庸”，$7\sim 8$ 对“小吉”，$9$ 对为“吉”，$10\sim11$ 为“大吉”，$12$ 为“满堂开花，极吉”。

如果还不明白，请参考样例。
## 输入格式

一共 $13$ 行，为每堆牌的具体牌是什么(不区分花色只区分数字)，每堆输入的顺序为从上到下。

为了便于读入，用 $0$ 代表 $10$。
## 输出格式

输出一共开了多少对。
## 样例

### 样例输入 #1
```
8 5 A A
K 5 3 2
9 6 0 6
3 4 3 4
3 4 4 5
5 6 7 6
8 7 7 7
9 9 8 8
9 0 0 0
K J J J
Q A Q K
J Q 2 2
A K Q 2
```
### 样例输出 #1
```
9
```
## 提示

注解：第一条命死后前 $12$ 堆牌变成了这个样子：
```
A A A 8
K 5 3 2
3 9 6 0
4 4 3 4
5 5 3 4
6 6 5 6
7 7 7 7 
8 8 8 9
9 9 0 0
0 K J J
J Q A Q//抽到这里的K死掉了
J Q 2 2
```
第二条命由于 $K$ 在生命牌中，所以直接死掉，不变。

第三条命死后前 $12$ 堆牌变成了这个样子：
```
A A A A
2 2 2 K
3 3 3 3
4 4 4 4
5 5 5 5
6 6 6 6
7 7 7 7 
8 8 8 8
9 9 9 9
0 0 0 0//抽到这里的K死掉了
J J J Q
Q Q J Q
```
第四条命死后前 $12$ 堆牌变成了这个样子：
```
A A A A
2 2 2 2//抽到这里的K死掉了
3 3 3 3
4 4 4 4
5 5 5 5
6 6 6 6
7 7 7 7 
8 8 8 8
9 9 9 9
0 0 0 0
J J J Q
Q Q J Q
```
最后发现在所有已经正面朝上的牌中，$A\ 2\ 3\ 4\ 5\ 6\ 7\ 8\ 10$这 $9$ 对牌“开”了，（注意，第 $9$ 堆牌中的最后一张虽然也是 $9$，但是并没有被翻开！所以不能算）因此输出 $9$。


---

---
title: "[蓝桥杯 2024 省 Java B] 分布式队列"
layout: "post"
diff: 普及-
pid: P11043
tag: ['模拟', '2024', '队列', '蓝桥杯省赛']
---
# [蓝桥杯 2024 省 Java B] 分布式队列
## 题目描述

小蓝最近学习了一种神奇的队列：分布式队列。简单来说，分布式队列包含 $N$ 个节点（编号为 $0$ 至 $N−1$，其中 $0$ 号为主节点），其中只有一个主节点，其余为副节点。主、副节点中都各自维护着一个队列，当往分布式队列中添加元素时都是由主节点完成的（每次都会添加元素到队列尾部）；副节点只负责同步主节点中的队列。可以认为主/副节点中的队列是一个长度无限的一维数组，下标为 $0,1,2,3,\dots$，同时副节点中的元素的同步顺序和主节点中的元素添加顺序保持一致。

由于副本的同步速度各异，因此为了保障数据的一致性，元素添加到主节点后，需要同步到所有的副节点后，才具有可见性。

给出一个分布式队列的运行状态，所有的操作都按输入顺序执行。你需要回答在某个时刻，队列中有多少个元素具有可见性。
## 输入格式

第一行包含一个整数 $N$，表示节点个数。


接下来包含多行输入，每一行包含一个操作，操作类型共有以下三个：add、sync 和 query，各自的输入格式如下：

1. `add element`：表示这是一个添加操作，将元素 $element$ 添加到队列中；

2. `sync follower_id`：表示这是一个同步操作，$follower\_id$ 号副节点会从主节点中同步下一个自己缺失的元素；

3. `query`：查询操作，询问当前分布式队列中有多少个元素具有可见性。
## 输出格式

对于每一个 query 操作，输出一行，包含一个整数表示答案。
## 样例

### 样例输入 #1
```
3
add 1
add 2
query
add 1
sync 1
sync 1
sync 2
query
sync 1
query
sync 2
sync 2
sync 1
query
```
### 样例输出 #1
```
0
1
1
3
```
## 提示

**【样例说明】**

执行到第一个 query 时，队列内容如下：

- 节点 $0$：$[1,2]$
- 节点 $1$：$[]$
- 节点 $2$：$[]$

两个副节点中都无元素，因此答案为 $0$。
 
执行到第二个 query 时，队列内容如下：

- 节点 $0$：$[1,2,1]$
- 节点 $1$：$[1,2]$
- 节点 $2$：$[1]$

只有下标为 $0$ 的元素被所有节点同步，因此答案为 $1$。

执行到第三个 query 时，队列内容如下：

- 节点 $0$：$[1,2,1]$
- 节点 $1$：$[1,2,1]$
- 节点 $2$：$[1]$

只有下标为 $0$ 的元素被所有节点同步，因此答案为 $1$。

执行到第四个 query 时，队列内容如下：

- 节点 $0$：$[1,2,1]$
- 节点 $1$：$[1,2,1]$
- 节点 $2$：$[1,2,1]$

三个元素都被所有节点同步，因此答案为 $3$。

**【评测用例规模与约定】**

设输入的操作数为 $q$。

对于 $30\%$ 的评测用例：$1\leq q \leq 100$。

对于 $100\%$ 的评测用例：$1\leq q\leq 2000$，$1\leq N\leq 10$，$1\leq follower\_id<N$，$0\leq element\leq10^5$。

**数据保证执行同步操作时，$follower\_id$ 号副节点一定缺失元素**。


---

---
title: "填涂颜色"
layout: "post"
diff: 普及-
pid: P1162
tag: ['搜索', '洛谷原创', '广度优先搜索 BFS', '队列']
---
# 填涂颜色
## 题目描述

由数字 $0$ 组成的方阵中，有一任意形状的由数字 $1$ 构成的闭合圈。现要求把闭合圈内的所有空间都填写成 $2$。例如：$6\times 6$ 的方阵（$n=6$），涂色前和涂色后的方阵如下：

如果从某个 $0$ 出发，只向上下左右 $4$ 个方向移动且仅经过其他 $0$ 的情况下，无法到达方阵的边界，就认为这个 $0$ **在闭合圈内**。闭合圈不一定是环形的，可以是任意形状，但保证**闭合圈内**的 $0$ 是连通的（两两之间可以相互到达）。

```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 1 0 1
1 1 1 1 1 1
```
```plain
0 0 0 0 0 0
0 0 0 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 1 2 1
1 1 1 1 1 1
```
## 输入格式

每组测试数据第一行一个整数 $n(1 \le n \le 30)$。

接下来 $n$ 行，由 $0$ 和 $1$ 组成的 $n \times n$ 的方阵。

方阵内只有一个闭合圈，圈内至少有一个 $0$。

## 输出格式

已经填好数字 $2$ 的完整方阵。

## 样例

### 样例输入 #1
```
6
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 0 0 1
1 1 0 0 0 1
1 0 0 0 0 1
1 1 1 1 1 1

```
### 样例输出 #1
```
0 0 0 0 0 0
0 0 1 1 1 1
0 1 1 2 2 1
1 1 2 2 2 1
1 2 2 2 2 1
1 1 1 1 1 1

```
## 提示

对于 $100\%$ 的数据，$1 \le n \le 30$。



---

---
title: "[NOIP 2010 提高组] 机器翻译"
layout: "post"
diff: 普及-
pid: P1540
tag: ['模拟', '2010', 'NOIP 提高组', '队列']
---
# [NOIP 2010 提高组] 机器翻译
## 题目背景

NOIP2010 提高组 T1
## 题目描述

小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。

这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。

假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。

假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。
## 输入格式

共 $2$ 行。每行中两个数之间用一个空格隔开。

第一行为两个正整数 $M,N$，代表内存容量和文章的长度。

第二行为 $N$ 个非负整数，按照文章的顺序，每个数（大小不超过 $1000$）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。
## 输出格式

一个整数，为软件需要查词典的次数。

## 样例

### 样例输入 #1
```
3 7
1 2 1 5 4 4 1

```
### 样例输出 #1
```
5

```
## 提示

### 样例解释

整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：

1. `1`：查找单词 1 并调入内存。
2. `1 2`：查找单词 2 并调入内存。
3. `1 2`：在内存中找到单词 1。
4. `1 2 5`：查找单词 5 并调入内存。
5. `2 5 4`：查找单词 4 并调入内存替代单词 1。
6. `2 5 4`：在内存中找到单词 4。
7. `5 4 1`：查找单词 1 并调入内存替代单词 2。

共计查了 $5$ 次词典。

### 数据范围

- 对于 $10\%$ 的数据有 $M=1$，$N \leq 5$；
- 对于 $100\%$ 的数据有 $1 \leq M \leq 100$，$1 \leq N \leq 1000$。


---

---
title: "离开中山路"
layout: "post"
diff: 普及-
pid: P1746
tag: ['模拟', '搜索', '广度优先搜索 BFS', '队列']
---
# 离开中山路
## 题目背景

《爱与愁的故事第三弹·shopping》最终章。

## 题目描述

爱与愁大神买完东西后，打算坐车离开中山路。现在爱与愁大神在 $x_1,y_1$ 处，车站在 $x_2,y_2$ 处。现在给出一个 $n \times n(n \le 1000)$ 的地图，$0$ 表示马路，$1$ 表示店铺（不能从店铺穿过），爱与愁大神只能垂直或水平着在马路上行进。爱与愁大神为了节省时间，他要求最短到达目的地距离（每两个相邻坐标间距离为 $1$）。你能帮他解决吗？

## 输入格式

第 $1$ 行包含一个数 $n$。

第 $2$ 行到第 $n+1$ 行：整个地图描述（$0$ 表示马路，$1$ 表示店铺，注意两个数之间没有空格）。

第 $n+2$ 行：四个数 $x_1,y_1,x_2,y_2$。
## 输出格式


只有 $1$ 行，即最短到达目的地距离。

## 样例

### 样例输入 #1
```
3
001
101
100
1 1 3 3
```
### 样例输出 #1
```
4
```
## 提示


对于 $20\%$ 数据，满足 $1\leq n \le 100$。

对于 $100\%$ 数据，满足 $1\leq n \le 1000$。


---

---
title: "约瑟夫问题"
layout: "post"
diff: 普及-
pid: P1996
tag: ['模拟', '树状数组', '队列']
---
# 约瑟夫问题
## 题目描述

$n$ 个人围成一圈，从第一个人开始报数,数到 $m$ 的人出列，再由下一个人重新从 $1$ 开始报数，数到 $m$ 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。

**注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 $n-1$ 名小朋友，而该题是全部出圈。**

## 输入格式

输入两个整数 $n,m$。
## 输出格式

输出一行 $n$ 个整数，按顺序输出每个出圈人的编号。
## 样例

### 样例输入 #1
```
10 3
```
### 样例输出 #1
```
3 6 9 2 7 1 8 5 10 4
```
## 提示

$1 \le m, n \le 100$



---

---
title: "[USACO09OPEN] Cow Line S"
layout: "post"
diff: 普及-
pid: P2952
tag: ['模拟', '递推', '2009', 'USACO', '单调队列']
---
# [USACO09OPEN] Cow Line S
## 题目描述

Farmer John's N cows (conveniently numbered 1..N) are forming a line. The line begins with no cows and then, as time progresses, one by one, the cows join the line on the left or right side. Every once in a while, some number of cows on the left or right side of the line all leave the line to go graze in their favorite pasture.

FJ has trouble keeping track of all the cows in the line. Please help him.

The cows enter the line in numerical order 1..N, and once a cow leaves the line she never re-enters it. Your program will be given S (1 <= S <= 100,000) input specifications; each appears on a single line and is one of two types:

\* A cow enters the line (a parameter indicates whether on the left or right).

\* K cows leave the line from the left or right side (supplied parameters define both the number of cows and which side).

Input lines never request an operation that can not be performed.

After all the input lines have been processed, your program should print the cows in the line in order from left to right. The final line is guaranteed to be non-empty at the end of the input specifications.
## 输入格式

\* Line 1: A single integer: S

\* Lines 2..S+1: Line i+1 contains specification i in one of four formats:

\* A L -- a cow arrives on the Left of the line

\* A R -- a cow arrives on the Right of the line

\* D L K -- K cows depart the Left side of the line

\* D R K -- K cows depart the Right side of the line
## 输出格式

\* Lines 1..??: Print the numbers of the cows in the line in order from left to right, one number per line.
## 样例

### 样例输入 #1
```
10 
A L 
A L 
A R 
A L 
D R 2 
A R 
A R 
D L 1 
A L 
A R 

```
### 样例输出 #1
```
7 
2 
5 
6 
8 

```
## 提示

Input    Resulting Cow Line

A L      1

A L      2 1

A R      2 1 3

A L      4 2 1 3

D R 2    4 2

A R      4 2 5

A R      4 2 5 6

D L 1    2 5 6

A L      7 2 5 6

A R      7 2 5 6 8

感谢@ ws\_fuweidong  提供翻译。

## 题目翻译

Farmer John（以下简称 FJ）的 $N$ 头奶牛（用 $1 \dots N$ 编号）在直线上排队。一开始，这条线上没有任何奶牛，随着时间的推移，奶牛们会一个接一个地站到队伍的左边或右边。又过了一会儿，某些奶牛会从队伍里离开，去吃自己最喜欢的草料。

FJ 无法跟踪每一头奶牛，于是，他想让你来帮助他。

奶牛以 $1 \dots N$ 的顺序排队，并且离开的奶牛不会再次回来。数据将会给出 $S$（$1 \le S \le 100000$） 条指令，各占一行，分两种：

- $A$ 头奶牛加入了队列（还有一个参数，表示从左加入还是从右加入）；
- $K$ 头奶牛从左边或者右边离开了队列（还有两个参数，分别表示从左离开还是从右离开和离开多少头奶牛）。

输入的命令一定是可以执行的。

所有的操作结束后，你的程序应该以从左到右的顺序输出这个奶牛队列。数据保证最后的队列不空。

**【输入格式】**

- 第 $1$ 行：单独一个整数 $S$。
- 第 $2 \dots S+1$ 行：第 $i+1$ 行会有一条命令，有以下几种：
  - `A L`：一头奶牛从队列左边加入；
  - `A R`：一头奶牛从队列右边加入；
  - `D L K`：$K$ 头奶牛从队伍左边离开；
  - `D R K`：$K$ 头奶牛从队伍右边离开。

**【输出格式】**

- 第 $1 \dots ??$ 行：从左到右输出最后的奶牛队列，一个奶牛编号占一行。

**【样例解释】**

以下为输入的命令及对应的队列：

- `A L`：$1$；
- `A L`：$2,1$；
- `A R`：$2,1,3$；
- `A L`：$4,2,1,3$；
- `D R 2`：$4,2$；
- `A R`：$4,2,5$；
- `A R`：$4,2,5,6$；
- `D L 1`：$2,5,6$；
- `A L`：$7,2,5,6$；
- `A R`（最终序列）：$7,2,5,6,8$。


---

---
title: "[GDOI2014] 世界杯"
layout: "post"
diff: 普及-
pid: P3887
tag: ['2014', '各省省选', '广东', '排序', '优先队列', '队列']
---
# [GDOI2014] 世界杯
## 题目描述

3014 年世界杯足球赛就要开始了！作为卫冕冠军中国足球队的教练，手下每位球员都是猛将，如何摆出最强的 11 人阵容也是一件幸福的烦恼事啊。

众所周知，足球阵容里的11个球员都会被分配到场上某一个特别的位置，而这些位置主要分为守门员、后卫、中场和前锋四种，其中守门员有且只有一个，后卫、中场和前锋的人数取决于你安排的足球阵型。形容足球阵型的方法由后卫开始计算至前锋，但不把守门员计算在内。例如，3-5-2 阵型是指有三个后卫、五个中场及两名前锋。由于竞争激烈，每位球员只会培养其中一种位置所需要的技能，所以他们每个人都只能胜任四个位置中的其中一种。

作为一个对球员能力了如指掌的教练，你给每个球员的综合水平进行量化。为了将阵型安排得更好，你的教练团队决定使用以下策略安排球员：首先按照顺序提出 $Q$ 个阵型，分别代表第一阵型、第二阵型、……、第 $Q$ 阵型。然后对于每个阵型，从仍未选择的球员中选择最好的对应数量的守门员、后卫、中场和前锋。比如说，对于第一阵型，在所有球员中选择；对于第二阵型，在除了第一阵型外的所有球员中选择；对于第三阵型，在除了第一阵型和第二阵型外的所有球员中选择；以此类推。

现在 $Q$ 个阵型都已经确定，而你需要知道的，是每个阵型的平均综合水平分别是多少。

## 输入格式

第一行有四个整数 $K, D, M, F$，分别表示守门员、后卫、中场和前锋供挑选的球员人数。

第二行有 $K$ 个整数 $k_i$，分别表示每个守门员的综合水平值。

第三行有 $D$ 个整数 $d_i$，分别表示每个后卫的综合水平值。

第四行有 $M$ 个整数 $m_i$，分别表示每个中场的综合水平值。

第五行有 $F$ 个整数 $f_i$，分别表示每个前锋的综合水平值。

第六行有一个整数 $Q$，表示教练团队提出的阵型个数。

以下 $Q$ 行，第 $i$ 行三个整数 $A_i, B_i, C_i$，由空格间隔，表示第 $i$ 阵型是 $A_i - B_i - C_i$ 阵型。
## 输出格式

输出 $Q$ 行。对于第 $i$ 种阵型，输出一个实数，表示该阵型平均综合水平的最大值，并四舍五入到小数点后 $2$ 位。
## 样例

### 样例输入 #1
```
3 10 12 4
76 60 87
78 84 84 84 81 82 72 51 77 57
85 84 62 87 88 64 81 90 80 66 88 85
65 83 63 79
2
4 5 1
4 4 2
```
### 样例输出 #1
```
85.64
78.00

```
## 提示

对于 $30\%$ 数据，$K, D, M, F≤1000$，$Q≤10$；

对于 $100\%$ 数据，$1≤K, D, M, F≤10^5$，$0≤k_i, d_i, m_i, f_i≤10^8$，$1≤Q≤K$，$0≤A_i, B_i, C_i≤10$，$A_i+B_i+C_i=10$，$∑A_i≤D$，$∑B_i≤M$，$∑C_i≤F$


---

---
title: "「Wdsr-2.5」小小的埴轮兵团"
layout: "post"
diff: 普及-
pid: P7505
tag: ['模拟', '2021', '洛谷原创', '排序', '队列']
---
# 「Wdsr-2.5」小小的埴轮兵团
## 题目背景

杖刀偶磨弓是埴轮兵团的首长。

作为埴轮兵长，训练埴轮兵团是很平常的事情。
## 题目描述

磨弓下达命令让埴轮们站成一行。不妨认为它们站在了一个数轴上，每个埴轮的位置就是它脚下数轴的数字。磨弓会告诉你，第 $i$ 个埴轮的位置为 $a_i$ 。**不保证** $\bm {a_i}$ **升序**。

数轴的长度是有限制的，具体的范围是 $[-k,k]$ 。也就是说，如果某个埴轮移出了这个范围，它就脱离了这个队列了，并且不会再次回到队列当中。

为了训练埴轮，磨弓给埴轮们下达了 $m$ 个指令，有以下 3 种：

- 指令 1：**全体埴轮**向数轴的正方向移动 $x$ 个单位长度。
- 指令 2：**全体埴轮**往数轴的反方向移动 $x$ 个单位长度。
- 指令 3：依次报数，统计目前队列里一共有多少个埴轮。

但是磨弓发现，埴轮兵团的大小实在是太大了，以至于执行这些操作变得非常缓慢。尽管如此，磨弓仍然希望你告诉她所有指令 3 的结果。
## 输入格式

第一行共有 $3$ 个整数 $n, m, k$，含义如题面所示。

第二行共有 $n$ 个整数 $a_1, a_2, \cdots, a_n$，表示每个埴轮的位置。

接下来 $m$ 行，有 $1$ 或者 $2$ 个正整数，描述一条指令。首先是一个整数 $\operatorname{op}$，表示这条指令的类型。如果 $1 \leq \operatorname{op} \leq 2$，接下来还会输入一个整数 $x$。
## 输出格式

对于每条指令 3 ，输出一个整数，表示目前还在队列中的埴轮的数目。
## 样例

### 样例输入 #1
```
3 4 3
-1 1 2
2 3
3
1 5
3
```
### 样例输出 #1
```
2
1
```
## 提示

#### 样例 1 说明

一共有三个埴轮。初始时，它们的站位分别是 $[-1,1,2]$ 。

- 第一次操作后，所有埴轮向左移动 $3$ 格，位置变成了  $[\underline{\bm{-4}},-2,-1]$ 。第一个埴轮被移出了数轴。
- 第二次操作后，输出当前的埴轮数目，为 $2$ 个。
- 第三次操作后，所有埴轮向右移动 $5$ 格，位置变成了 $[3,\underline \bm4]$ ，第二个埴轮被移出了数轴。
- 第四次操作后，输出当前的埴轮数目，为 $1$ 个。

#### 样例 2, 3

见下发附件。

#### 数据规模与约定

- 对于 $30\%$ 的数据，$1 \leq n, m \leq 5\times 10^3$；
- 对于另外 $20\%$ 的数据，$1\le k\le 500$；
- 对于 $100\%$ 的数据，$1 \leq n, m \leq 3\times 10^5$，$1 \leq k, x \leq 2 \times 10^9$，$-k \le a_i \le k$ 。


---


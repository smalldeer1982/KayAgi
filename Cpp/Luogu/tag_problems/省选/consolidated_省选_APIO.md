---
title: "[APIO2024] 星际列车"
layout: "post"
diff: 省选/NOI-
pid: P10538
tag: ['动态规划 DP', '2024', 'APIO', '交互题', '动态规划优化']
---
# [APIO2024] 星际列车
## 题目背景

## 请勿使用 C++14(GCC9) 提交

在 2992 年，机器人已经取代了人类的大部分工作，大家都有着大量的空闲时间。因此你和家人决定利用这些时间来一场星际旅行。

有 $N$ 个人类已经可以到达的行星，编号为 $0$ 到 $N - 1$，以及 $M$ 种不同的星际列车路线。第 $i$ 种列车路线 ($0 \le i < M$) 在时间 $A[i]$ 从行星 $X[i]$ 出发，在时间 $B[i]$ 到达行星 $Y[i]$，票价为 $C[i]$。在行星之间，这些星际列车是仅有的交通方式。对于你搭乘的一列星际列车，你只能在它的终点站下车，并且你搭乘的下一趟列车的起点站必须和这趟列车的终点站相同（这里认为换乘不耗时）。形式化地，你可以依次乘坐第 $q[0], q[1], \ldots, q[P]$ 次列车，当且仅当对任意 $1 \le k \le P$ 都有 $Y[q[k - 1]] = X[q[k]]$，$B[q[k - 1]] \le A[q[k]]$。

在不同行星之间移动是非常耗时的，所以除了车票钱，餐费支出也不可忽视。列车上免费提供不限量的食物，也就是在列车上吃饭不花钱：如果你决定乘坐第 i 种星际列车，则在任何 $A[i]$ 到 $B[i]$ 之间的时刻（包括端点）你都可以免费吃任意多顿饭。但如果你决定在行星 $i$ 吃饭，每顿饭都需要 $T[i]$ 元。

你和家人在旅途中总共需要吃 $W$ 顿饭，第 $i\ (0 \le i < W)$ 顿饭可以在 $L[i]$ 到 $R[i]$（包括端点）的任何时刻吃，吃饭不耗费时间。吃饭没有顺序要求，例如允许在吃完第 $1$ 顿饭后再吃第 $0$ 顿饭（见样例 $2$）。

现在是 $0$ 时刻，你和家人正在 $0$ 号行星上。你需要求出到达 $N - 1$ 号行星的最小花费，花费定义为车票价格和餐费之和。如果无法到达 $N - 1$ 号行星，最小花费定义为 $-1$。
## 题目描述

你无需在程序开头引入库 `train.h`。

你只需要实现以下函数：

```cpp
long long solve(int N, int M, int W, std::vector<int> T,
                std::vector<int> X, std::vector<int> Y,
                std::vector<int> A, std::vector<int> B, std::vector<int> C,
                std::vector<int> L, std::vector<int> R);
```

+   $N$：行星数量。
+  $ M$：星际列车路线数量。
+   $W$：需要用餐的次数。
+   $T$：一个长度为 $N$ 的数组。$T[i]$ 表示在行星 $i$ 每次用餐的花费。
+   $X, Y, A, B, C$：五个长为 $M$ 的数组。$(X[i], Y[i], A[i], B[i], C[i])$ 描述了第 $i$ 条列车路线。
+   $L, R$：两个长为 $W$ 的数组。$(L[i], R[i])$ 描述了第 $i$ 顿饭的用餐时间。
+   你需要返回从行星 $0$ 到达行星 $N - 1$ 的最小花费。如果行星 $N - 1$ 不可达，返回 $-1$。
+   每个测试点中，该函数恰好被调用一次。
## 输入格式

评测程序示例读取如下格式的输入：

+   第 $1$ 行：$N\ M\ W$
+   第 $2$ 行：$T[0]\ T[1]\ T[2]\ \ldots\ T[N - 1]$
+   第 $3 + i\ (0 \le i < M)$ 行：$X[i]\ Y[i]\ A[i]\ B[i]\ C[i]$
+   第 $3 + M + i\ (0 \le i < W)$ 行：$L[i]\ R[i]$
## 输出格式

评测程序示例按照如下格式打印你的答案：

+   第 $1$ 行：函数 `solve` 的返回值
## 样例

### 样例输入 #1
```
3 3 1 
20 30 40
0 1 1 15 10
1 2 20 30 5
0 2 18 40 40
16 19
```
### 样例输出 #1
```
40
```
### 样例输入 #2
```
3 5 6
30 38 33
0 2 12 16 38
1 0 48 50 6
0 1 26 28 23
0 2 6 7 94
1 2 49 54 50
32 36
14 14
42 45
37 40
2 5
4 5
```
### 样例输出 #2
```
197
```
## 提示

### 样例解释

对于样例一，考虑如下调用：

```cpp
solve(3, 3, 1, {20, 30, 40}, {0, 1, 0}, {1, 2, 2},
        {1, 20, 18}, {15, 30, 40}, {10, 5, 40}, {16}, {19});
```

一种可行的方案是依次乘坐第 $0, 1$ 次列车，花费为 $45$，具体流程如下：

| 时刻 | 你的行动 | 花费 |
| :---: | :---: | :---: |
| $1$ | 乘坐第 $0$ 次列车从 $0$ 号行星出发 | $10$ |
| $15$ | 到达 $1$ 号行星 |  |
| $16$ | 在 $1$ 号行星吃第 $0$ 顿饭 | $30$ |
| $20$ | 乘坐第 $1$ 次列车从 $1$ 号行星出发 | $5$ |
| $30$ | 到达 $2$ 号行星 |  |

一种更优的方案是乘坐第 $2$ 次列车，花费为 $40$，具体流程如下：

| 时刻 | 你的行动 | 花费 |
| :---: | :---: | :---: |
| $18$ | 乘坐第 $2$ 次列车从 $0$ 号行星出发 | $40$ |
| $19$ | 在第 $2$ 次列车上吃第 $0$ 顿饭 |  |
| $40$ | 到达 $2$ 号行星 |  |

在这种方案中，在时刻 $18$ 在第 $2$ 次列车上吃第 $0$ 顿饭也是合法的。

因此函数应该返回 $40$。

对于样例二，考虑如下调用：

```cpp
solve(3, 5, 6, {30, 38, 33}, {0, 1, 0, 0, 1}, {2, 0, 1, 2, 2},
        {12, 48, 26, 6, 49}, {16, 50, 28, 7, 54}, {38, 6, 23, 94, 50},
        {32, 14, 42, 37, 2, 4}, {36, 14, 45, 40, 5, 5});
```

最优解是：乘坐第 $0$ 次列车，车费为 $38$。在第 $0$ 次列车上免费吃第 $1$ 顿饭。第 $0, 2, 3$ 顿饭在行星 $2$ 上吃 ，花费 $33 \times 3 = 99$。 第 $4, 5$ 顿饭在行星 $0$ 上吃，花费 $30 \times 2 = 60$。总花费为 $38 + 99 + 60 = 197$。

因此函数应该返回 $197$。

### 数据范围

+   $2 \le N \le 10^5$
+   $0 \le M, W \le 10^5$
+   $0 \le X[i], Y [i] < N, X[i] \neq Y[i]$
+   $1 \le A[i] < B[i] \le 10^9$
+   $1 \le T[i], C[i] \le 10^9$
+   $1 \le L[i] \le R[i] \le 10^9$

详细子任务附加限制及分值如下表所示。

| 子任务编号 | 附加限制 | 分值 |
| :---: | :---: | :---: |
| $1$ | $N, M, A[i], B[i], L[i], R[i] \le 10^3, W \le 10$ | $5$ |
| $2$ | $W = 0$ | $5$
| $3$ | 每顿饭的用餐时间两两不交。形式化地，对于任何时刻 $z$ 满足 $1 \le z \le 10^9$，至多存在一个 $i\ (0 \le i < W)$ 使得 $L[i] \le z \le R[i]$。 | $30$ |
| $4$ | 没有额外的约束条件 | $60$ |


---

---
title: "[APIO2024] 魔术表演"
layout: "post"
diff: 省选/NOI-
pid: P10539
tag: ['2024', 'APIO', '交互题', 'Special Judge', '通信题']
---
# [APIO2024] 魔术表演
## 题目背景

在洛谷上提交时，只需要提交一个文件。

不要引入 `alice.h` 和 `bob.h`。在文件头加入以下内容：

```cpp
long long setN(int n);
```

只支持 C++17 / C++20 提交。
## 题目描述

Alice 和 Bob 是著名的魔术师。Catherine 是一位富豪，她非常喜欢观看 Alice 和 Bob 的魔术。某一天，Catherine 决定向 Alice 和 Bob 发出挑战：只要他们能成功表演如下的魔术，Catherine 就将向他们提供巨额奖金！这个魔术的表演过程如下：

- 步骤 $1$：Bob 进⼊⼀个密室中，在魔术的全程中，他只能与 Catherine 交流。接下来，Alice 告诉 Catherine ⼀个在 $2$ 到 $5000$ 之间的整数 $n$。
- 步骤 $2$：Catherine 告诉 Alice ⼀个在 $1$ 到 $10^{18}$ 之间的整数 $X$。
- 步骤 $3$：Alice 生成⼀个具有 $n$ 个节点的树，并告诉 Catherine。
- 步骤 $4$：Catherine 删除树中的⼀些边（至多 $\left\lfloor\dfrac{n-2}{2}\right\rfloor$ 条），并将剩余的边告诉 Bob。
- 步骤 $5$：Bob 根据 Catherine 给出的信息，猜出 Catherine 告诉 Alice 的数是多少。

然⽽，Alice 和 Bob 被这个魔术难倒了，于是他们不得不寻求你的帮助。请你写一段程序，实现 Alice 和 Bob 的策略，以帮助他们赢得 Catherine 的挑战。

通信方式：

你需要实现两个函数

1. `std::vector<std::pair<int, int>> Alice();`
- 对于每组测试数据，这个函数只会被调用⼀次。
- 函数应当返回⼀个含有 `pair<int, int>` 类型的 `vector`，表示 Alice 在魔术的步骤 3 中生成的树的边集。
  - 注意树中的节点应当从 1 开始编号。
  - 你需要确保函数返回的树是符合规范的，也就是说，树中应当恰好包含 n − 1 条边，且所有节点彼此连通。
  
函数 `Alice()` 应当调用如下函数**恰好⼀次**：

`long long setN(int n);`

- 这个函数表示，在魔术的步骤 1 中，Alice 选择⼀个数 $n$ 告诉 Catherine。
- 函数返回⼀个数 $X$，表示 Catherine 在魔术的步骤 2 中告诉 Alice 的数。
---
2. `long long Bob(std::vector<std::pair<int, int>> V);`

- 对于每组测试数据，这个函数只会被调用⼀次，且⼀定是在调用 `Alice()` 之后。
- $V$ 表⽰在魔术的步骤 4 中，Catherine 告诉 Bob 的边集。
- 上述边集是有序的，具体而言：
  - 对于⼀条边的两个端点而言，编号较⼩的端点靠前；
  - 所有的边按照第⼀个端点为第⼀关键字、第⼆个端点为第⼆关键字的顺序升序排序。
- 函数应当返回⼀个整数 $X$，表⽰ Bob 在魔术的步骤 5 中给出的回答。
## 输入格式

无
## 输出格式

无
## 提示

### 例子

考虑下面的调用：
调用函数| 返回值
:-:|:-:
`Alice()`|
`setN(4)`| $3$
||$\{\{1, 2\}, \{2, 3\}, \{2, 4\}\}$
`Bob({{1,2},{2,4}})`| $3$
该样例代表了以下场景：
- 步骤 1：最开始，Alice 将数字 $4$ 告诉 Catherine。
- 步骤 2：Catherine 将数字 $3$ 告诉 Alice。
- 步骤 3：Alice 生成了⼀棵具有 $4$ 个节点的树，其边集为 $\{\{1, 2\}, \{2, 3\}, \{2, 4\}\}$，将这棵树告诉 Catherine。
- 步骤 4：Catherine 删去了树中连接节点 $2$ 和 $3$ 的边，并把剩余的边 $\{\{1, 2\}, \{2, 4\}\}$ 告诉 Bob。
- 步骤 5：Bob 给出数字 $3$ 作为回答。由于他给出了正确答案，他们的魔术表演⼤获成功。


### 子任务

1. (5 分)：$X\leq 5, 000$。
2. (30 分)：$X\leq25, 000, 000$。
3. (65 分)：没有特殊限制。



---

---
title: "[APIO2025] Rotating Lines"
layout: "post"
diff: 省选/NOI-
pid: P12543
tag: ['贪心', '2025', 'APIO', '交互题', 'Special Judge']
---
# [APIO2025] Rotating Lines
## 题目描述

Asadullo is an outstanding researcher at APIO (Alliance for Power and Industrial Optimization). Recently, he has been studying a method to generate energy using an unknown material.

This unknown material does not produce energy on its own, but if there are several extremely long rods made of this material, they can generate energy through their interactions.

Specifically, there are $n$ rods, given by an array $v[0], v[1], \ldots, v[n-1]$. The $i$-th rod can be positioned at an angle of $a[i] = 360 \cdot \frac{v[i]}{100000}$, with respect to the positive direction of the x-axis, in counterclockwise. The energy efficiency by these $n$ rods is defined as

$$\sum_{i<j} \text{acute}(i,j)$$

where $\text{acute}(i,j)$ represents the acute angle formed between the $i$-th rod and the $j$-th rod. In this problem, we consider $90^\circ$ as an acute angle.

More formally, $\text{acute}(i,j) = \min(|v[i] - v[j]|, 50000 - |v[i] - v[j]|)$.

In other words, the energy efficiency is calculated by adding the acute angles between every pair of rods.

For example, if $v = [5000, 12500, 37500]$ and correspondingly, $a = [18, 45, 135]$, we would get the following graph:

![](https://cdn.luogu.com.cn/upload/image_hosting/xkk4vtuf.png)

Here, acute(0, 1) = 7500 (i.e. 27°), acute(0, 2) = 17500 (i.e. 63°), and acute(1, 2) = 25000 (i.e. 90°).
Therefore, the energy efficiency of these rods equals $7500 + 17500 + 25000 = 50000$.

Asadullo wants to adjust the arrangement of these $n$ rods to maximize their energy efficiency.
However, there are several constraints:

- First, since this material is extremely hazardous to living beings, the rods can only be rotated using a specialized mechanical device in a controlled manner. This device allows selecting multiple rods at once and rotating them by the same angle simultaneously.
- Asadullo does not want the energy efficiency of the rods to decrease. Therefore, after any operation using the device, the energy efficiency must not be lower than before.
- Since operating the device consumes a large amount of energy, the total number of rods selected across all operations must not exceed 2 000 000.

Under these constraints, Asadullo wants to perform operations optimally to maximize the energy efficiency of the rods. Write a program to help Asadullo achieve the highest possible energy efficiency.

### Implementation details

You should implement the following procedure:

```cpp
void energy(int n, std::vector<int> v)
```

- $n$: the number of rods.
- $v$: an array of length $n$ containing information about the rods.
- This procedure is called exactly once.

Within this procedure, you may call the following procedure:

```cpp
void rotate(std::vector<int> t, int x)
```

- $t$: an array of distinct indices, i.e. $0 \leq t[i] < n$ for each $i$ and $t[i] \neq t[j]$ for each $i < j$. Array $t$ is not required to be sorted.
- This procedure rotates every rod which index is given in the array $t$ by parameter $x$, simultaneously. That is, $v[i]$ becomes $(v[i] + x) \mod 50000$ for every index $i$ which is present in $t$.
- This procedure can be called multiple times. The total length of $t$ over all calls must not exceed 2 000 000.

## 提示

### Examples

#### Example 1

Consider the following call:

```cpp
energy(2, [20000, 10000])
```

Here, $v = [20000, 10000]$ and the initial energy efficiency equals $20000 - 10000 = 10000$. One of the possible scenarios is the following:

- call `rotate([0, 1], 8000)`. Then $v$ becomes $[28000, 18000]$. The energy efficiency stays the same.
- call `rotate([0], 15000)`. Then $v$ becomes $[43000, 18000]$. The energy efficiency becomes $43000 - 18000 = 25000$.

It can be shown that for the given input, 25000 is the maximum possible energy efficiency. Therefore, Asadullo can stop performing these operations.

#### Example 2

Consider the following call:

```cpp
energy(3, [5000, 12500, 37500])
```

The image for this example was presented above. It can be shown that the initial energy efficiency is the maximum possible. Thus, no operations are needed.

### Constraints

- $2 \leq n \leq 100 \, 000$
- $0 \leq v[i] \leq 49 \, 999$ for each $0 \leq i < n$
- elements of $v$ are **not** necessarily distinct

### Subtasks

1. (5 points) $n = 2$
2. (11 points) $v[i] < 25 \, 000$ for each $0 \leq i < n$
3. (8 points) $n \leq 10$
4. (15 points) $n \leq 100$
5. (15 points) $n \leq 300$
6. (20 points) $n \leq 2000$
7. (26 points) No additional constraints.

### Sample Grader

The sample grader reads the input in the following format:

- line 1: $n$
- line 2: $v[0] \, v[1] \ldots \, v[n - 1]$

The sample grader prints the output in the following format:

- line 1: final energy efficiency of rods

Also, the grader will write detailed information about the rotations you made in the file `log.txt`.



---

---
title: "[APIO2012] 派遣"
layout: "post"
diff: 省选/NOI-
pid: P1552
tag: ['动态规划 DP', '2012', '平衡树', 'APIO', '可并堆', '栈']
---
# [APIO2012] 派遣
## 题目背景

在一个忍者的帮派里，一些忍者们被选中派遣给顾客，然后依据自己的工作获取报偿。

## 题目描述

在这个帮派里，有一名忍者被称之为 Master。除了 Master 以外，每名忍者都有且仅有一个上级。为保密，同时增强忍者们的领导力，所有与他们工作相关的指令总是由上级发送给他的直接下属，而不允许通过其他的方式发送。

现在你要招募一批忍者，并把它们派遣给顾客。你需要为每个被派遣的忍者支付一定的薪水，同时使得支付的薪水总额不超过你的预算。另外，为了发送指令，你需要选择一名忍者作为管理者，要求这个管理者可以向所有被派遣的忍者发送指令，在发送指令时，任何忍者（不管是否被派遣）都可以作为消息的传递人。管理者自己可以被派遣，也可以不被派遣。当然，如果管理者没有被排遣，你就不需要支付管理者的薪水。

   
你的目标是在预算内使顾客的满意度最大。这里定义顾客的满意度为派遣的忍者总数乘以管理者的领导力水平，其中每个忍者的领导力水平也是一定的。

   
写一个程序，给定每一个忍者 $i$ 的上级 $B_i$，薪水 $C_i$，领导力 $L_i$，以及支付给忍者们的薪水总预算 $M$，输出在预算内满足上述要求时顾客满意度的最大值。

## 输入格式

第一行包含两个整数 $N$ 和 $M$，其中 $N$ 表示忍者的个数，$M$表示薪水的总预算。

 
接下来 $N$ 行描述忍者们的上级、薪水以及领导力。其中的第i行包含三个整数 $B_i,C_i,L_i$ 分别表示第 $i$ 个忍者的上级，薪水以及领导力。Master 满足 $B_i=0$，并且每一个忍者的老板的编号一定小于自己的编号 $B_i\lt i$。

## 输出格式

一行一个整数，表示在预算内顾客的满意度的最大值。

## 样例

### 样例输入 #1
```
5 4
0 3 3
1 3 5
2 2 2
1 2 4
2 3 1

```
### 样例输出 #1
```
6

```
## 提示

$1 \le N \le 10^5$，$1 \le M \le 10^9$，$0 \le B_i \lt i$，$1 \le C_i \le M$，$1 \le L_i \le 10^9$。

对于 $30\%$ 的数据，$N \le 3000$。



---

---
title: "[APIO2007] 动物园"
layout: "post"
diff: 省选/NOI-
pid: P3622
tag: ['2007', 'APIO', '枚举', '深度优先搜索 DFS', '状压 DP']
---
# [APIO2007] 动物园
## 题目描述

新建的圆形动物园是亚太地区的骄傲。圆形动物园坐落于太平洋的一个小岛上，包含一大圈围栏，每个围栏里有一
种动物。如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/8pr43p86.png)

你是动物园的公共主管。你要做的是，让每个来动物园的人都尽可能高兴。今天有一群小朋友来动物园参观，你希望能让他们在动物园度过一段美好的时光。但这并不是一件容易的事——有的动物有一些小朋友喜欢，有的动物有一些小朋友害怕。如，Alex 喜欢可爱的猴子和考拉，而害怕拥牙齿锋利的狮子。而 Polly 会因狮子有美丽的鬃毛而喜欢它，但害怕有臭味的考拉。你可以选择将一些动物从围栏中移走以使得小朋友不会害怕。但你不能移走太多动物，否则小朋友们就没有动物可看了。每个小朋友站在大围栏圈的外面，可以看到连续的 $5$ 个围栏。你得到了所有小朋友喜欢和害怕的动物信息。当下面两处情况之一发生时，小朋友就会高兴：
- 至少有一个他害怕的动物被移走
- 至少有一个他喜欢的动物没被移走

例如，考虑下图中的小朋友和动物：

![](https://cdn.luogu.com.cn/upload/image_hosting/n69iqfv6.png)

- 假如你将围栏 $4$ 和 $12$ 的动物移走。Alex 和 Ka-Shu 将很高兴，因为至少有一个他们害怕的动物被移走了。这也会使 Chaitanya 高兴，因为他喜欢的围栏  $6$ 和 $8$ 中的动物都保留了。但是，Polly 和 Hwan 将不高兴，因为他们看不到任何他们喜欢的动物，而他们害怕的动物都还在。这种安排方式使得三个小朋友高兴。
- 现在，换一种方法，如果你将围栏 $4$ 和 $6$ 中的动物移走，Alex 和 Polly 将很高兴，因为他们害怕的动物被移走了。Chaitanya 也会高兴，虽然他喜欢的动物 $6$ 被移走了，他仍可以看到围栏 $8$ 里面他喜欢的动物。同样的 Hwan 也会因可以看到自己喜欢的动物 $12$ 而高兴。唯一不高兴的只有 Ka-Shu。
- 如果你只移走围栏 $13$ 中的动物，Ka-Shu 将高兴，因为有一个他害怕的动物被移走了，Alex, Polly, Chaitanya 和 Hwan 也会高兴，因为他们都可以看到至少一个他们喜欢的动物。所以有 $5$ 个小朋友会高兴。这种方法使得了最多的小朋友高兴。
## 输入格式

输入的第一行包含两个整数 $N$，$C$，用空格分隔。

$N$ 是围栏数（$10 \le N \le 10^4$），$C$ 是小朋友的个数（$1 \le C \le 5\times 10^4$）。

围栏按照顺时针的方向编号为 $1,2,3,\cdots,N$。

接下来的 $C$ 行，每行描述一个小朋友的信息，以下面的形式给出： $E, F, L ,X_1, X_2 ,\cdots ,X_F ,Y_1 ,Y_2 ,\cdots ,Y_L$。 

其中： $E$ 表示这个小朋友可以看到的第一个围栏的编号（$1 \le E \le N$），换句话说，该小朋友可以看到的围栏为 $E$， $E+1$， $E+2$， $E+3$， $E+4$。

注意，如果编号超过 $N$ 将继续从 $1$ 开始算。

如：当 $N=14$，$ E=13$ 时，这个小朋友可以看到的围栏为 $13,14,1, 2$ 和 $3$。

$F$ 表示该小朋友害怕的动物数。

$L$ 表示该小朋友喜欢的动物数。

围栏 $X_1, X_2, \cdots, X_F$ 中包含该小朋友害怕的动物。

围栏 $Y_1, Y_2, \cdots, Y_L$ 中包含该小朋友喜欢的动物。 

$X_1, X_2, \cdots, X_F, Y_1, Y_2, \cdots, Y_L$ 是两两不同的整数，而且所表示的围栏都是该小朋友可以看到的。

小朋友已经按照他们可以看到的第一个围栏的编号从小到大的顺序排好了（这样最小的 $E$ 对应的小朋友排在第一个，最大的 $E$ 对应的小朋友排在最后一个）。

注意可能有多于一个小朋友对应的 $E$ 是相同的。
## 输出格式

仅输出一个数，表示最多可以让多少个小朋友高兴。

## 样例

### 样例输入 #1
```
14 5 
2 1 2 4 2 6 
3 1 1 6 4 
6 1 2 9 6 8
8 1 1 9 12 
12 3 0 12 13 2 
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
12 7 
1 1 1 1 5 
5 1 1 5 7 
5 0 3 5 7 9 
7 1 1 7 9 
9 1 1 9 11 
9 3 0 9 11 1
11 1 1 11 1
```
### 样例输出 #2
```
6
```
## 提示

**数据范围**
对于 $100\%$ 的数据，$10 \le N \le 10^4$，$1 \le C \le 5\times 10^4$，$1 \le E \le N$。

**样例说明**
- 第一个样例是题目描述中的例子，所有的 $C=5$ 个小朋友都能高兴。
- 第二个样例是一个不能使得所有 $C=7$ 个小朋友都高兴的例子。


---

---
title: "[APIO2008] 免费道路"
layout: "post"
diff: 省选/NOI-
pid: P3623
tag: ['2008', '并查集', 'APIO', 'Special Judge', '背包 DP', '生成树']
---
# [APIO2008] 免费道路
## 题目描述

 
新亚（New Asia）王国有 N 个村庄，由 M 条道路连接。其中一些道路是鹅卵石路，而其它道路是水泥路。保持道路免费运行需要一大笔费用，并且看上去 王国不可能保持所有道路免费。为此亟待制定一个新的道路维护计划。

国王已决定保持尽可能少的道路免费，但是两个不同的村庄之间都应该一条且仅由一条 且仅由一条免费道路的路径连接。同时，虽然水泥路更适合现代交通的需 要，但国王也认为走在鹅卵石路上是一件有趣的事情。所以，国王决定保持刚好 K 条鹅卵石路免费。

举例来说，假定新亚王国的村庄和道路如图 3(a)所示。如果国王希望保持两 条鹅卵石路免费，那么可以如图 3(b)中那样保持道路(1, 2)、(2, 3)、(3, 4)和(3, 5) 免费。该方案满足了国王的要求，因为：(1)两个村庄之间都有一条由免费道 路组成的路径；(2)免费的道路已尽可能少；(3)方案中刚好有两条鹅卵石道路 (2, 3)和(3, 4)

 ![](https://cdn.luogu.com.cn/upload/pic/4393.png) 

图 3: (a)新亚王国中村庄和道路的一个示例。实线标注的是水泥路，虚线标注 的是鹅卵石路。(b)一个保持两条鹅卵石路免费的维护方案。图中仅标出了免 费道路。


给定一个关于新亚王国村庄和道路的述以及国王决定保持免费的鹅卵石 道路数目，写一个程序确定是否存在一个道路维护计划以满足国王的要求，如果 存在则任意输出一个方案。

## 输入格式

输入第一行包含三个由空格隔开的整数：

N，村庄的数目(1≤N≤20,000)；

M，道路的数目(1≤M≤100,000)；

K，国王希望保持免费的鹅卵石道路数目(0≤K≤N - 1)。

此后 M 行述了新亚王国的道路，编号分别为 1 到 M。第(i+1)行述了第 i 条 道路的情况。用 3 个由空格隔开的整数述：

ui 和 vi，为第 i 条道路连接的两个村庄的编号，村庄编号为 1 到 N；

ci，表示第 i 条道路的类型。ci = 0 表示第 i 条道路是鹅卵石路，ci = 1 表 示第 i 条道路是水泥路。

输入数据保证一对村庄之间至多有一条道路连接

## 输出格式

如果满足国王要求的道路维护方案不存在，你的程序应该在输出第一行打印 no solution。 否则，你的程序应该输出一个符合要求的道路维护方案，也就是保持免费的 道路列表。按照输入中给定的那样输出免费的道路。如果有多种合法方案，你可 以任意输出一种。

## 样例

### 样例输入 #1
```
5 7 2 
1 3 0 
4 5 1 
3 2 0 
5 3 1 
4 3 0 
1 2 1 
4 2 1
```
### 样例输出 #1
```
3 2 0 
4 3 0 
5 3 1 
1 2 1 
```


---

---
title: "[APIO2008] DNA"
layout: "post"
diff: 省选/NOI-
pid: P3624
tag: ['2008', 'APIO', '枚举', '前缀和']
---
# [APIO2008] DNA
## 题目描述

分析如DNA序列这样的生命科学数据是计算机的一个有趣应用。从生物学的角度上说，DNA是一种由腺嘌呤、胞嘧啶、鸟嘌呤和胸腺嘧啶这四种核苷酸组成的链式结构。这四种核苷酸分别用大写字母A、C、G、T表示。这样，一条DNA单链可以被表示为一个只含以上四种字符的字符串。我们将这样的字符串称作一个DNA序列。

有时生物学家可能无法确定一条DNA单链中的某些核苷酸。在这种情况下，字符N将被用来表示一个不确定的核苷酸。换句话说，N可以用来表示A、C、G、T中的任何一个字符。我们称包含一个或者多个N的DNA序列为未完成序列；反之，就称作完成序列。如果一个完成序列可以通过将一个未完成序列中的个N任意替换成A、C、G、T得到的话，就称完成序列适合这个未完成序列。举例来说，ACCCT适合ACNNT，但是AGGAT不适合。

研究者们常按照如下方式排序四种核苷酸：A优先于C，C优先于G，G优先于T。如果一个DNA序列中的个核苷酸都与其右边的相同或者优先，就将其归类为范式-1。举例来说，AACCGT是范式-1，但是AACGTC不是。

一般来说，一个DNA序列属于范式-j(j>1)，只要它属于范式-(j-1)或者是一个范式-(j-1)和一个范式-1的连接。举例来说，AACCC、ACACC和ACACA都是范式-3，但GCACAC和ACACACA不是。

同样，研究者们按照字典序对DNA序列进行排序。按照这个定义，最小的属于范式-3的DNA序列是AAAAA，最大的是TTTTT。这里是另外一个例子，考虑未完成序列ACANNCNNG。那么前7个适合这个未完成序列的DNA序列是：
```
ACAAACAAG
ACAAACACG
ACAAACAGG
ACAAACCAG
ACAAACCCG
ACAAACCGG
ACAAACCTG
```
## 输入格式

输入第一行包含三个由空格隔开的整数：M(1≤M≤50,000)，K(1≤K≤10)和 R(1≤R≤2×$10^{12}$)。

第二行包含一个长度为 M 的字符串，表示未完成序列。

保证适 合该未完成序列的范式-K 的总数不超过 4×10^18，因此该数可以用 C 和 C++中的 long long 类型或者 Pascal 中的 Int64 类型表示。同时，R 不会超过适合给定未完 成序列的范式-K 的总数。

## 输出格式

 在第一行中输出第R个适合输入中的未完成序列的范式-K。
## 样例

### 样例输入 #1
```
9 3 5 
ACANNCNNG
```
### 样例输出 #1
```
ACAAACCCG
```
### 样例输入 #2
```
5 4 10 
ACANN
```
### 样例输出 #2
```
ACAGC 
```


---

---
title: "[APIO2010] 特别行动队"
layout: "post"
diff: 省选/NOI-
pid: P3628
tag: ['动态规划 DP', '2010', '单调队列', 'APIO', '斜率优化', '前缀和', '队列']
---
# [APIO2010] 特别行动队
## 题目描述

你有一支由 $n$ 名预备役士兵组成的部队，士兵从 $1$ 到 $n$ 编号，你要将他们拆分成若干特别行动队调入战场。出于默契的考虑，同一支特别行动队中队员的编号**应该连续**，即为形如 $(i, i + 1, \cdots i + k)$的序列。所有的队员都应该属于且仅属于一支特别行动队。

编号为 $i$ 的士兵的初始战斗力为 $x_i$ ，一支特别行动队的初始战斗力 $X$ 为队内士兵初始战斗力之和，即 $X = x_i + x_{i+1} + \cdots + x_{i+k}$。

通过长期的观察，你总结出对于一支初始战斗力为 $X$ 的特别行动队，其修正战斗力 $X'= aX^2+bX+c$，其中 $a,~b,~c$ 是已知的系数（$a < 0$）。 作为部队统帅，现在你要为这支部队进行编队，使得所有特别行动队的修正战斗力之和最大。试求出这个最大和。
## 输入格式

输入的第一行是一个整数 $n$，代表士兵的人数。

输入的第二行有三个用空格隔开的整数，依次代表 $a,~b,~c$，即修正战斗力的系数。

输入的第三行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表编号为 $i$ 的士兵的初始战斗力 $x_i$。
## 输出格式

输出一行一个整数，代表最大的所有特别行动队战斗力之和。
## 样例

### 样例输入 #1
```
4 
-1 10 -20 
2 2 3 4 
```
### 样例输出 #1
```
9
```
## 提示

#### 样例输入输出 $1$ 解释

你有 $4$ 名士兵，$x_1 = 2,~x_2 = 2,~x_3 = 3,~x_4=4$。修正战斗力公式中的参数为  $a = -1,~b = 10,~c = -20$。

此时，最佳方案是将士兵组成 $3$ 个特别行动队：第一队包含士兵 $1$ 和士兵 $2$，第二队包含士兵 $3$，第三队包含士兵 $4$。特别行动队的初始战斗力分别为 $4,~3,~4$，修正后的战斗力分别为 $-4^2 + 10 \times 4 -20 = 4$，$-3^2 + 10 \times 3 - 20 = 1$，$-4^2 + 10 \times 4 -20 = 4$。修正后的战斗力和为 $4 + 1 + 4 = 9$，没有其它方案能使修正后的战斗力和更大。


#### 数据范围与约定

对于 $20\%$ 的数据，$n \leq 10^3$。

对于 $50\%$ 的数据，$n \leq 10^4$

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$-5 \leq a \leq -1$，$-10^7 \leq b \leq 10^7$，$-10^7 \leq c \leq 10^7$，$1 \leq x_i \leq 100$。


---

---
title: "[APIO2010] 巡逻"
layout: "post"
diff: 省选/NOI-
pid: P3629
tag: ['2010', 'APIO', '深度优先搜索 DFS', '树的直径']
---
# [APIO2010] 巡逻
## 题目描述

在一个地区中有 $n$ 个村庄，编号为 $1, 2, \dots, n$。有 $n-1$ 条道路连接着这些村庄，每条道路刚好连接两个村庄，从任何一个村庄，都可以通过这些道路到达其他任何一个村庄。每条道路的长度均为 $1$ 个单位。为保证该地区的安全，巡警车每天要到所有的道路上巡逻。警察局设在编号为 $1$ 的村庄里，每天巡警车总是从警察局出发，最终又回到警察局。下图表示一个有 $8$ 个村庄的地区，其中村庄用圆表示（其中村庄 $1$ 用黑色的圆表示），道路是连接这些圆的线段。为了遍历所有的道路，巡警车需要走的距离为 $14$ 个单位，每条道路都需要经过两次。

![](https://cdn.luogu.com.cn/upload/pic/4401.png)

为了减少总的巡逻距离，该地区准备在这些村庄之间建立 $K$ 条新的道路，每条新道路可以连接任意两个村庄。两条新道路可以在同一个村庄会合或结束，如下面的图例 (c)。一条新道路甚至可以是一个环，即其两端连接到同一个村庄。由于资金有限，$K$ 只能是 $1$ 或 $2$。同时，为了不浪费资金，每天巡警车必须经过新建的道路正好一次。下图给出了一些建立新道路的例子：

![](https://cdn.luogu.com.cn/upload/pic/4402.png) 

在 (a) 中，新建了一条道路，总的距离是 $11$。在 (b) 中，新建了两条道路，总的巡逻距离是 $10$。在 (c) 中，新建了两条道路，但由于巡警车要经过每条新道路正好一次，总的距离变为了 $15$。试编写一个程序，读取村庄间道路的信息和需要新建的道路数，计算出最佳的新建道路的方案使得总的巡逻距离最小，并输出这个最小的巡逻距离。


## 输入格式

第一行包含两个整数 $n, K(1 ≤ K ≤ 2)$。接下来 $n-1$ 行，每行两个整数 $a,b$，表示村庄 $a$ 与 $b$ 之间有一条道路 $(1 ≤ a, b ≤ n)$。

## 输出格式

输出一个整数，表示新建了 $K$ 条道路后能达到的最小巡逻距离。

## 样例

### 样例输入 #1
```
8 1 
1 2 
3 1 
3 4 
5 3 
7 5 
8 5 
5 6 
```
### 样例输出 #1
```
11
```
### 样例输入 #2
```
8 2 
1 2 
3 1 
3 4 
5 3 
7 5 
8 5 
5 6 
```
### 样例输出 #2
```
10
```
### 样例输入 #3
```
5 2 
1 2 
2 3 
3 4 
4 5 
```
### 样例输出 #3
```
6
```
## 提示

- $10\%$ 的数据中，$1≤n≤1000,K=1$；
- $30\%$ 的数据中，$K=1$；
- $80\%$ 的数据中，每个村庄相邻的村庄数不超过 $25$；
- $90\%$ 的数据中，每个村庄相邻的村庄数不超过 $150$；
- $100\%$ 的数据中，$3≤n≤10^5,1≤K≤2$。



---

---
title: "[APIO2010] 信号覆盖"
layout: "post"
diff: 省选/NOI-
pid: P3630
tag: ['2010', 'APIO', 'Special Judge', '枚举', '排序']
---
# [APIO2010] 信号覆盖
## 题目描述

一家电信公司正在北京城搭建一个 GSM 网络。城市里共有 n 个房子需要被 信号覆盖。由于经费的限制，电信公司只能安装一个天线。 这里将每个房子用一个点坐标来表示。为了简化天线的放置，电信公司将会 选择其中的 3 个房子作一个外接圆，然后将天线放在圆的中心，所有位于这个圆 内或者圆的边界上的房子都将被天线的信号所覆盖。 电信公司将会随机选择城市中的 3 个房子来搭建天线，他们想知道在所有可 能放置天线的方案中平均会有多少个房子被信号覆盖。 例如，假设共有 4 个房子 A, B, C, D，它们的位置如下图：

  ![](https://cdn.luogu.com.cn/upload/pic/4405.png) 

如果我们选择ABC或者BCD三个点搭建的外接圆，所有的房子都会被覆盖。 如果我们选择 ACD 或者 ABD，剩下的房子将不会在天线的信号覆盖范围内。因 此平均有(4 + 4 + 3 + 3) / 4 = 3.50 个房子被信号覆盖。 给定所有房子的位置，你的任务是计算平均有多少个房子被信号覆盖。假定 每一个房子都有一个二维的整数坐标，并且保证任何三个房子都不在同一条直线 上，任何四个房子都不在同一个圆上。

## 输入格式

输入第一行包含一个正整数 n, 表示房子的总数。接下来有 n 行，分别表示 每一个房子的位置。对于 i = 1, 2, .., n, 第 i 个房子的坐标用一对整数 xi和 yi来表 示，中间用空格隔开。

## 输出格式

输出文件包含一个实数，表示平均有多少个房子被信号所覆盖，需保证输出 结果与精确值的绝对误差不超过 0.01。

## 样例

### 样例输入 #1
```
4
0 2 
4 4 
0 0 
2 0
```
### 样例输出 #1
```
3.500 
```
## 提示

【样例说明】

3.5, 3.50, 3.500, … 中的任何一个输出均为正确。此外，3.49, 3.51, 3.499999，…等也都是可被接受的输出。

【数据范围】

100%的数据保证，对于 i = 1, 2, .., n, 第 i 个房子的坐标(xi, yi)为整数且 –1,000,000 ≤ xi, yi ≤ 1,000,000. 任何三个房子不在同一条直线上，任何四个房子不 在同一个圆上；

40%的数据，n ≤ 100；

70%的数据，n ≤ 500；

100%的数据，3 ≤ n ≤ 1,500。



---

---
title: "[APIO2011] 方格染色"
layout: "post"
diff: 省选/NOI-
pid: P3631
tag: ['数学', '2011', '并查集', 'APIO', '枚举', '位运算']
---
# [APIO2011] 方格染色
## 题目描述

Sam 和他的妹妹 Sara 有一个包含 $n \times m$ 个方格的表格。他们想要将其中的每个方格都染成红色或蓝色。出于个人喜好，他们想要表格中每个 $2 \times 2$ 的方形区域都包含奇数个（ $1$ 个或 $3$ 个）红色方格。例如，下面是一个合法的表格染色方案（`R` 代表红色，`B` 代表蓝色）：
```
B B R B R
R B B B B
R R B R B
```
可是昨天晚上，有人已经给表格中的一些方格染上了颜色！现在 Sam 和 Sara 非常生气。不过，他们想要知道是否可能给剩下的方格染上颜色，使得整个表格依然满足他们的要求。如果可能的话，满足他们要求的染色方案数有多少呢？
## 输入格式

输入的第一行包含三个整数 $n,m,k$，分别代表表格的行数，列数和已被染色的方格数目。

之后的 $k$ 行描述已被染色的方格。其中第i行包含三个整数 $x_i,y_i,c_i$，分表代表第 $i$ 个已被染色的方格的行编号、列编号和颜色。$c_i$ 为 $1$ 表示方格被染成红色，$c_i$ 为 $0$ 表示方格被染成蓝色。
## 输出格式

输出一个整数，表示可能的染色方案数 $w$ 对于 $10^9$ 取模后得到的值。

## 样例

### 样例输入 #1
```
3 4 3
2 2 1
1 2 0
2 3 1
```
### 样例输出 #1
```
8
```
## 提示

对于 $20\%$ 的测试数据，$n,m,k \leqslant 5$。

对于 $50\%$ 的测试数据，$n,m \leqslant 5000$，$k \leqslant 25$。

对于 $100\%$ 的测试数据，$2 \leqslant n,m \leqslant 10^5$，$0 \leqslant k \leqslant 10^5$，$1 \leqslant x_i \leqslant n$，$1 \leqslant y_i \leqslant m$，$\forall c_i \in \{0,1\}$。


---

---
title: "[APIO2011] 寻路"
layout: "post"
diff: 省选/NOI-
pid: P3632
tag: ['2011', 'APIO', '最短路']
---
# [APIO2011] 寻路
## 题目描述

TooDee 是一块二维格子状的土地（就像著名的笛卡尔坐标系那样），在这里生活着很多可爱的 Dee。Dee 是像蜜蜂一样的小动物，它们只在二维活动，而且他们非常的 文明开化。TooDee 的蜂窝和正常世界的蜂窝也是很不一样的，他们是矩形的且它们的边平行于 TooDee 的地理坐标系，就是说矩形的边或者是东西走向， 或者是南北走向。

因为 Dees 是很高级的生物，他们有很多固定的飞行轨道，这些轨道由一些平行于坐标轴的线段组成，线段只会在经纬度都是整数的点相交。Dee 在 TooDee 飞行时必须遵守以下规则（请记住 TooDee 中所有点的经纬度都是整数）：

1. 如果当前在点 $(X, Y)$，则下一步只能飞到四个邻点 $(X, Y - 1), (X, Y + 1), (X - 1, Y), (X + 1, Y)$；

2. 不可以进入蜂巢；

3. 只能在蜂巢的角上或者边上改变飞行方向；

4. 开始的时候可以向任何方向飞；

今晚是公共财政大臣 Deeficer 的女儿的生日，她想尽早回家，请帮她找到最快的回家路径。假设她每秒可以飞行一个单位的距离。
## 输入格式

每个测试点包含多组数据。

输入的第一行包含一个整数 $T$，表示测试数据的组数。接下来依次描述这 $T$ 组数据，相邻的两组之间使用一个空行分隔，测试数据不多于 $20$ 组。

对 于每组数据，第一行包含四个整数 $x_s,y_s,x_t,y_t$，表示 Deeficer 的办公室和家的坐标分别是 $(x_s, y_s)$ 和 $(x_t, y_t)$。第二行包含一个整数 $n$，表示蜂巢的个数。接下来的 $n$ 行描述所有的蜂巢，其中第 $i$ 行包含四个整数 $x_{i_1}, y_{i_1}, x_{i_2}, y_{i_2}$，表示第 $i$ 个蜂巢两个对角的坐标分别为 $(x_{i_1}, y_{i_1})$ 和 $(x_{i_2}, y_{i_2})$。

任何两个蜂巢不会相交，也不会接触（在角上也不会接触）。办公室和家处在不同的位置。每个蜂巢的面积为正。
## 输出格式

对于每一组数据，输出一个整数，表示 Deeficer 最快回家的时间（单位为秒），如果她无法按规则回家，则输出 `No Path`。

## 样例

### 样例输入 #1
```
2

1 7 7 8
2
2 5 3 8
4 10 6 7

2 1 5 4
1
3 1 4 3

```
### 样例输出 #1
```
9
No Path

```
## 提示

对于 $20\%$ 的测试数据，$n\leq 10$，所有的坐标都是小于 $100$ 的非负整数；

对于 $60\%$ 的测试数据，$n\leq 100$，所有坐标的绝对值都小于 $10^3$；

对于 $100\%$ 的测试数据，$0\leq n\leq 10^3$，所有坐标的绝对值都是不超过 $10^9$ 的整数。


---

---
title: "[APIO2012] 守卫"
layout: "post"
diff: 省选/NOI-
pid: P3634
tag: ['贪心', '2012', '线段树', 'APIO', '差分']
---
# [APIO2012] 守卫
## 题目描述

APIO 王国正被忍者攻击！忍者非常厉害，因为他们在进攻的时候可以躲在 阴影里面使得其他人看不到他们。整个王国除了国王居住的 APIO 城堡以外都已 经被占领了。在城堡前，有 N 个灌木丛，从 1 到 N 编号，有 K 个忍者躲在恰好 K 个灌木丛后面。APIO 城堡里有 M 个守卫。守卫 i 监视着编号从 Ai到 Bi的连续 的一段灌木丛。每个守卫都向国王报告在他所监视范围内是否有忍者出现。作为 国王的仆人，你需要告诉国王，基于守卫的报告，哪些灌木丛后面一定躲着一个 忍者，即对于任何和守卫报告不矛盾的忍者排列方式，在这个灌木丛后面都躲着 一个忍者。

你需要写一个程序来输出所有的这些灌木丛的编号。

## 输入格式

第一行包含三个用空格分隔的整数 N, K, M，N 是灌木丛的个数，K 是忍者 的个数，M 是守卫的个数。

接下来 M 行，每行描述一个守卫的信息。其中的第 i 行包含三个整数 Ai, Bi, Ci，表示第 i 个守卫的监视范围是从 Ai到 Bi（Ai ≤ Bi）。Ci是 0 或者 1，若是 0 表 示范围内没有看到忍者，1 表示范围内有至少一个忍者。

输入数据保证至少存在一种忍者排列方式满足所有条件。

## 输出格式

若存在灌木丛，在其后面一定躲着忍者，则将这些一定躲着忍者的灌木丛按 照编号从小到大的顺序依次输出，每个一行。即若有 X 个这样的灌木丛，则需 要输出 X 行。若不存在，则输出一行一个“-1”，不包含引号。

## 样例

### 样例输入 #1
```
5 3 4 
1 2 1 
3 4 1 
4 4 0 
4 5 1
```
### 样例输出 #1
```
3
5

```
### 样例输入 #2
```
5 1 1 
1 5 1
```
### 样例输出 #2
```
-1
```
## 提示

【样例说明 1】

在这个样例中，有两种可能的安排方式：1，3，5 或者 2，3，5。即 3 和 5 后面必然躲着一个忍者。 考虑第一个灌木丛，存在一种安排方案使得它的后面躲着忍者，但也存在一 种安排方案使得它后面没有躲忍者，因此不应该输出 1。同理，不应该输出 2。

【样例说明 2】

在这个样例中，没有灌木丛后面一定躲着忍者。

灌木的数量 1 ≤ N ≤ 100,000 ；

忍者数 1 ≤ K ≤ N ；

守卫数 0 ≤ M < 100,000 。

 
对于 10%的数据，N ≤ 20， M ≤ 100；

对于 50%的数据，N ≤ 1000， M ≤ 1000。



---

---
title: "[APIO2013] 机器人"
layout: "post"
diff: 省选/NOI-
pid: P3638
tag: ['搜索', '2013', 'APIO', '记忆化搜索', '队列']
---
# [APIO2013] 机器人
## 题目描述

VRI（Voltron 机器人学会）的工程师建造了 n 个机器人。任意两个兼容的机 器人站在同一个格子时可以合并为一个复合机器人。

我们把机器人用 1 至 n 编号（n ≤ 9）。如果两个机器人的编号是连续的，那 么它们是兼容的，可以合并成一个复合机器人。最初这 n 个机器人各自都只有唯 一的编号。而一个由两个或以上的机器人合并构成的复合机器人拥有两个编号， 分别是构成它的所有机器人中最小和最大的编号。

例如，2 号机器人只可以与 1 号或 3 号机器人合并。若 2 号机器人与 3 号机 器人合并，可构成编号为 2-3 的复合机器人。如果编号为 2-3 的复合机器人与编 号为 4-6 的复合机器人合并，可构成编号为 2-6 的复合机器人。当所有机器人合 并以后则构成 1-n 复合机器人。

工程师把这 n 个机器人放在了一个封闭的房间中，房间四周均是墙。该房间 被划分成 w × h 个方格。有些方格有障碍物，机器人不可经过或停留；其余方格 允许多个机器人停留，同时允许机器人经过。任何时候一个机器人只占用一个方 格。初始时刻，所有机器人均在不同的方格中。

这些原始的机器人不会自发地移动。它们只有被工程师沿 x 轴或 y 轴推动 后，才会沿推动的方向不断向前直线移动，直至碰到障碍物或墙停止移动。停止 移动后，它会扫描当前的格子是否存在可以与它合并的机器人，如果有，则合并 并继续检查，直至不能再合并为止。工程师只能沿水平向左、水平向右、竖直向 上、竖直向下四个方向推动机器人，并且，在机器人尚未停止移动时，不允许推 动其它机器人，因此任何时刻，房间中都只能有一个机器人移动。

为了帮助机器人转向，工程师在一些格子中放置了转向器。具体地说，转向 器分为顺时针转向器（右转器）和逆时针转向器（左转器），顺时针转向器可以 使到达该格子的机器人沿顺时针方向转向 90°；逆时针转向器可以使到达该格 子的机器人沿逆时针方向转向 90°。

现在，我们将告诉你初始时刻房间内的信息。请你计算工程师最少共计需要 推动机器人多少次，才能把所有的 n 个机器人全部合并（如果可能的话）。

## 输入格式

你的程序必须从标准输入读入。

输入的第 1 行包含 3 个整数 n、w 和 h，用 空格隔开。

输入文件中接下来的 h 行描述初始时刻房间内的信息，每行包含 w 个字符。 这 w × h 个字符中每一个表示房间中的一个格子，意义如下：

‘1’至‘9’：表示该方格中有一个机器人，编号为这个数字；

‘x’：表示该方格有障碍物；

‘A’：表示该方格中有一个逆时针转向器；

‘C’：表示该方格中有一个顺时针转向器；

‘.’：表示该方格为空地。

## 输出格式

你的程序必须输出到标准输出。输出仅一个整数，表示最少需要推动的次数。 若不能使所有机器人全部合并，输出-1。

## 样例

### 样例输入 #1
```
4 10 5 
1.........
AA...x4...
..A..x....
2....x....
..C.3.A...
```
### 样例输出 #1
```
5
```
## 提示

第一步：向右推动 3 号机器人，当它碰到转向器后会向上继续移动，直至碰 到墙壁停止移动。

第二步：向上推动 4 号机器人，当它碰到墙壁后停止移动，与 3 号机器人合 并，构成 3-4 号机器人

第三步：向上推动 2 号机器人，当它碰到转向器后会向左移动，由于左侧为 墙壁，故停留在原地。

第四步：向右推动 2 号机器人，由于它在一个转向器上，故它会向上移动， 直至碰到墙壁停止移动，与 1 号机器人合并，构成 1-2 号机器人。

第五步：向左推动 3-4 号机器人，当它碰到墙壁后停止移动，与 1-2 号机器 人合并，构成 1-4 号机器人。


我们将使用以下 4 类输入测例测试你的程序。

1. （10 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10，没有任何转向器。

2. （20 分）测例满足 n = 2，w ≤ 10 且 h ≤ 10。

3. （30 分）测例满足 n ≤ 9，w ≤ 300 且 h ≤ 300。

4. （40 分）测例满足 n ≤ 9，w ≤ 500 且 h ≤ 500。



---

---
title: "[APIO2013] 道路费用"
layout: "post"
diff: 省选/NOI-
pid: P3639
tag: ['2013', 'APIO', '生成树', '连通块', '强连通分量']
---
# [APIO2013] 道路费用
## 题目描述

幸福国度可以用 N 个城镇（用 1 到 N 编号）构成的集合来描述，这些城镇 最开始由 M 条双向道路（用 1 到 M 编号）连接。城镇 1 是中央城镇。保证一个 人从城镇 1 出发，经过这些道路，可以到达其他的任何一个城市。这些道路都是 收费道路，道路 i 的使用者必须向道路的主人支付 ci分钱的费用。已知所有的这 些ci是互不相等的。最近有K条新道路建成，这些道路都属于亿万富豪Mr. Greedy。 Mr. Greedy 可以决定每条新道路的费用（费用可以相同），并且他必须在明天宣 布这些费用。

两周以后，幸福国度将举办一个盛况空前的嘉年华！大量的参与者将沿着这 些道路游行并前往中央城镇。共计 pj个参与者将从城镇 j 出发前往中央城镇。这 些人只会沿着一个选出的道路集合前行，并且这些选出的道路将在这件事的前一 天公布。根据一个古老的习俗，这些道路将由幸福国度中最有钱的人选出，也就 是 Mr. Greedy。同样根据这个习俗，Mr. Greedy 选出的这个道路集合必须使所有 选出道路的费用之和最小，并且仍要保证任何人可以从城镇 j 前往城镇 1（因此， 这些选出的道路来自将费用作为相应边边权的“最小生成树”）。如果有多个这样 的道路集合，Mr. Greedy 可以选其中的任何一个，只要满足费用和是最小的。

Mr. Greedy 很明确地知道，他从 K 条新道路中获得的收入不只是与费用有 关。一条道路的收入等于所有经过这条路的人的花费之和。更准确地讲，如果 p 个人经过道路 i，道路 i 产生的收入为 ci p 的积。注意 Mr. Greedy 只能从新道路 收取费用，因为原来的道路都不属于他。

Mr. Greedy 有一个阴谋。他计划通过操纵费用和道路的选择来最大化他的收 入。他希望指定每条新道路的费用（将在明天公布），并且选择嘉年华用的道路 （将在嘉年华的前一天公布），使得他在 K 条新道路的收入最大。注意 Mr. Greedy 仍然需要遵循选出花费之和最小的道路集合的习俗。

你是一个记者，你想揭露他的计划。为了做成这件事，你必须先写一个程序 来确定 Mr. Greedy 可以通过他的阴谋获取多少收入。

## 输入格式

你的程序必须从标准输入读入。第一行包含三个由空格隔开的整数 N，M 和 K。接下来的 M 行描述最开始的 M 条道路。这 M 行中的第 i 行包含由空格隔开 的整数 ai，bi和 ci，表示有一条在 ai 和 bi之间，费用为 ci 的双向道路。接下来的 K 行描述新建的 K 条道路。这 K 行中的第 i 行包含由空格隔开的整数 xi和 yi，表 示有一条连接城镇 xi 和 yi 新道路。最后一行包含 N 个由空格隔开的整数，其中 的第 j 个为 pj，表示从城镇 j 前往城镇 1 的人数。

输入也满足以下约束条件。 

1 ≤ N ≤ 100000； 

1 ≤ K ≤ 20； 

1 ≤ M ≤ 300000； 

对每个 i 和 j，1 ≤ ci, pj ≤ 10^6；


如果 i ≠ i'，则 ci ≠ ci'； 

在任意两个城市之间，最多只有一条道路（包括新建的道路）。

## 输出格式

你的程序必须输出恰好一个整数到标准输出，表示能获得的最大的收入。

## 样例

### 样例输入 #1
```
5 5 1 
3 5 2 
1 2 3 
2 3 5 
2 4 4 
4 3 6 
1 3 
10 20 30 40 50
```
### 样例输出 #1
```
400
```
## 提示

在样例中，Mr. Greedy 应该将新道路(1,3)的费用设置为 5 分钱。在这个费用 下，他可以选择道路(3,5)，(1,2)，(2,4)和(1,3)来最小化总费用，这个费用为 14。 从城镇 3 出发的 30 个人和从城镇 5 出发的 50 个人将经过新道路前往城镇 1，因 此他可以获得为(30+50)×5=400 分钱的最好收入。

如果我们这样做，将新道路(1,3)的费用设置为 10 分钱。根据传统的限制， Mr. Greedy 必须选择(3,5)，(1,2)，(2,4)和(2,3)，因为这是唯一费用最小的集合。 因此，在嘉年华的过程中道路(1,3)将没有任何收入。


我们将使用以下 5 类测例测试你的程序。

1. （国际 16 分，国内 15 分）N ≤ 10，M ≤ 20 且 K = 1；

2. （国际 18 分，国内 20 分）N ≤ 30，M ≤ 50 且 K ≤ 10；

3. （国际 22 分，国内 20 分）N ≤ 1,000，M ≤ 5,000 且 K ≤ 10；

4. （国际 22 分，国内 20 分）N ≤ 100,000，M ≤ 300,000 且 K ≤ 15；

5. （国际 22 分，国内 25 分）N ≤ 100,000，M ≤ 300,000 且 K ≤ 20。

**update: 2024/07/04 删除了两个测试点，并且改为捆绑。**



---

---
title: "[APIO2013] 出题人"
layout: "post"
diff: 省选/NOI-
pid: P3640
tag: ['2013', 'APIO', '提交答案', 'Special Judge', '最短路', '构造']
---
# [APIO2013] 出题人
## 题目描述

当今世界上各类程序设计竞赛层出不穷。而设计一场好比赛绝非易事，比如给题目设计测试数据就是一项挑战。一组好的测试数据需要对不同的程序有区分度：满足所有要求的程序自然应该得到满分，而那些貌似正确的程序则会在某些特殊数据上出错。

在本题中，你在比赛中的角色反转啦！作为一名久经百战的程序员，你将帮助 Happy Programmer Contest 的命题委员会设计这次比赛的测试数据。本次比赛命题委员会选择了两个图论问题，分为 $8$ 个子任务。委员会写了一些貌似可以解决这些子任务的代码。在给任务设计数据的时候，命题委员会期望其中的一些源程序能够得到满分，而另外的一些则只能得到 $0$ 分或者少许的部分分。现在你将会获得这些源程序（C, C++, Pascal 版本）。对于每个子任务，你需要去产生一组数据 $X$ 使得它能将该任务给定的 $2$ 种源程序 $A$ 和 $B$ 区分开来。更具体地说，生成的数据必须满足如下两个条件:

输入 $X$ 对于源程序 $A$ 一定不会出现超出时间限制（TLE）的问题。

输入 $X$ 一定会导致源程序 $B$ 产生超出时间限制的问题。

此外,命题委员喜欢较小规模的测试数据，希望测试数据最好能够包含不超过 $T$ 个整数。

本题中只关心源程序 $A$ 和 $B$ 是否超时，不关心是否结果正确。

命题委员会选择了单源最短路（SSSP）以及一个被称之为神秘问题（Mystery）的两个图论问题来作为比赛的题目。我们将命题委员会完成的伪代码列在了附录中，而具体的 C、C++ 和 Pascal 源程序被我们放在了下发的文件当中。

### 子任务

参见下表。表中每一行描述了一个子任务。其中前六个子任务与单源最短路相关，子任务 7,8 与神秘问题相关。每个任务所占分数见下表。

 ![](https://cdn.luogu.com.cn/upload/pic/4428.png) 

对于每个子任务，你的程序给出的输入 $X$ 需要能够将源程序 $A$ 和 $B$ 区分开来，这有这样你才能够得到相应的分数。具体说来，你的分数将由输入 $X$ 中数的个数决定。假设 $X$ 中包含了 $F$ 个整数，子任务的满分为 $S,T$ 是该任务的目标大小，则该测试点的分数将由下式给出:

$$S \times \min\{T / F, 1\}$$

也就是说，如果你的测试数据 $X$ 中含有不超过 $T$ 个整数，则你将得到该任务的全部得分。

你需要把你的 $8$ 个测试数据命名为 `1.txt` ~ `8.txt`。对于每个子任务 $X$，评测系统将根据如下步骤来确定你将会得到多少分:

- 如果未提交数据，则不得分；
- 若数据不满足输入格式要求，则不得分；
- 对源程序 $A$ 运行输入，若发生超时现象，则不得分；
- 对源程序 $B$ 运行输入，若发生超时现象，则按照前文所述的公式给出该测试点的分数。

题目提供的所有源代码均会维护一个计数器来统计程序的操作次数。在源程序的运行过程中，当该计数器超过了 $10^6$ 次时，那么我们认为程序运行超时。

### 问题 1：单源最短路（SSSP）

给定一个带权有向图 $G$，以及 $G$ 中的两个节点 $s$ 与 $t$，令 $p(s, t)$ 为 $G$ 中从 $s$ 至 $t$ 的最短路长度。如果 $s$ 与 $t$ 不连通，则认为 $p(s, t)=10^9$。在本题中，输入为图 $G$ 以及 $Q$ 个询问 $(s_1, t_1), (s_2, t_2), \dots, (s_Q, t_Q)$ 。输出则是对这 $Q$ 个询问的相应输出 $p(s_1, t_1), p(s_2 , t_2), \cdots, p(s_Q, t_Q)$。


### 问题 2：神秘问题

给定一个包含 $V$ 个节点 $E$ 条边的无向图 $G$，要求将所有的节点进行编号（编号范围为 $[0, X-1]$），使得所有直接相连的节点均有不同的编号。找出符合题意的最小的 $X$。

## 输入格式

### 问题 1

输入数据包含两部分，其中第一部分使用邻接表来描述带权有向图 $G$。第二部分则描述对 $G$ 的最短路径的查询。

数据第一部分的第一行包含一个整数 $V$，表示 $G$ 中点的个数，所有点的编号为 $0, 1, \cdots, V - 1$。

接下来 $V$ 行，每行描述一个点的所有边。行中的第一个整数 $n_i$ 描述了节点 $i$ 的出边数量，接下来有 $n_i$ 个整数对 $(j, w)$ 表示有一条从 $i$ 到 $j$，边权为 $w$ 的边。

数据第二部分的第一行包含一个整数 $Q$，表示询问的组数。

接下来 $Q$ 行，第 $k$ 行包含两个整数 $s_k, t_k$，为该询问对应的起点与终点位置。

同一行中任意两个相邻的整数均需要至少一个空格将他们分开。除此之外，数据还需满足如下条件:

- $0 < V \leq 300$，$n_i$ 是一个非负整数，$0 \leq j < V$，$\lvert w \rvert < 10^6$，$0 \leq \sum\limits_{i = 0}^{V-1} n_i \leq 5000$，$0 < Q \leq 10$，$0 \leq s_k < V, 0 \leq t_k < V$；
- 所有询问中的起点 $s_k$ 都不能达到任何一个负权圈。
- 对于所有的边 $(a, b)$，有 $a \neq b, 0 \leq a < V, 0 \leq b < V$，不会重复描述一条边。


### 问题 2

输入数据的第一行包含两个整数 $V$ 和 $E$。

接下来 $E$ 行,每行两个整数 $a, b$，表示 $a$ 与 $b$ 在 $G$ 中直接相连。此外,输入数据应满足如下限制条件:

- $70 < V < 1000$，$1500 < E < 10^6$；
- 对于所有的边 $(a, b)$，有 $a \neq b, 0 \leq a < V, 0 \leq b < V$，不会重复描述一条边。


## 输出格式

### 问题 1

程序将会输出 $Q$ 行，每行一个整数，表示对应的 $p(s_k , t_k)$。而在输出的最后，所有提供的程序都会给出计数器对此输入的数值。

### 问题 2

程序将在第一行输出 $X$，即最小的编号范围，接下来在第二行中给出 $V$ 个整数，依次描述节点 $0$ 至 $V - 1$ 的编号。在输出的最后，所有提供的程序都会给出计数器对此输入的数值。
## 样例

### 样例输入 #1
```
3
2 1 4 2 1
0
1 1 2
2
0 1
1 0
//以上为问题1
```
### 样例输出 #1
```
3
1000000000
The value of counter is: 5
```
### 样例输入 #2
```
4 5
0 1
0 2
0 3
1 2
2 3
//以上为问题2
```
### 样例输出 #2
```
3
0 1 2 1
The value of counter is: 18
```
## 提示

**源代码见附件**。

### 附录：伪代码

接下来是我们提供的所有程序的伪代码；变量 counter 近似描述出了程序的运行时间。评测时将会使用这些伪代码的 C++ 版本来进行评测。


FloydWarshall

```cpp
// pre-condition: the graph is stored in an adjacency matrix M
counter = 0
for k = 0 to V-1
    for i = 0 to V-1
        for j = 0 to V-1
            increase counter by 1;
            M[i][j] = min(M[i][j], M[i][k] + M[k][j]);
for each query p(s,t)
    output M[s][t];
```

OptimizedBellmanFord

```cpp
// pre-condition: the graph is stored in an adjacency list L
counter = 0
for each query p(s,t);
    dist[s] = 0; // s is the source vertex
    loop V-1 times
        change = false;
        for each edge (u,v) in L
            increase counter by 1;
            if dist[u] + weight(u,v) < dist[v]
                dist[v] = dist[u] + weight(u,v);
                change = true;
        if change is false // this is the ’optimized’ Bellman Ford
            break from the outermost loop;
    output dist[t];
```

ModifiedDijkstra

```cpp
// pre-condition: the graph is stored in an adjacency list L
counter = 0;
for each query p(s,t)
    dist[s] = 0;
    pq.push(pair(0, s)); // pq is a priority queue
    while pq is not empty
        increase counter by 1;
        (d, u) = the top element of pq;
        remove the top element from pq;
        if (d == dist[u])
            for each edge (u,v) in L
                if (dist[u] + weight(u,v) ) < dist[v]
                    dist[v] = dist[u] + weight(u,v);
                    insert pair (dist[v], v) into the pq;
    output dist[t];
```

Gamble1

```cpp
Sets X = V;
labels vertex i in [0..V-1] with i;
Sets counter = 0; // will never get TLE
```
Gamble2

```cpp
Sets X = V;
labels vertex i in [0..V-1] with i;
Sets counter = 1000001; // force this to get TLE
```

RecursiveBacktracking

```cpp
This algorithm tries X from 2 to V one by one and stops at the first valid X.  
For each X, the backtracking routine label vertex 0 with 0, then for each vertex u that has been assigned a label, the backtracking routine tries to assign 
the smallest possible label up to label X-1 to its neighbor v, and backtracks if necessary.  
// Please check RecursiveBacktracking.cpp/pas to see 
// the exact lines where the iteration counter is increased by 1
```

感谢zhouyonglong修改spj



---

---
title: "[APIO2016] 最大差分"
layout: "post"
diff: 省选/NOI-
pid: P3641
tag: ['2016', 'APIO', '交互题', 'Special Judge', 'O2优化']
---
# [APIO2016] 最大差分
## 题目背景

## 评测方式
以下是本题评测方式，与题面不符时以这里为准。

你的代码中不应该包含 `gap.h` 库。

你的代码中需如下进行 `findGap` 和 `MinMax` 函数的声明：
```cpp
extern "C" void MinMax(long long,long long,long long*,long long*);
extern "C" long long findGap(int,int);
```

[spj 与交互库](https://www.luogu.com.cn/paste/c4olee2x)

不保证没锅，要是有锅请私信供题人然后 D 死他。
## 题目描述

有 $N$ 个严格递增的非负整数 $a_1, a_2, \dots, a_N$（$0 \leq a_1 < a_2 < \cdots < a_N \leq 10^{18}$）。你需要找出 $a_{i + 1} - a_i$（$1 \leq i \leq N - 1$）里的最大的值。

你的程序不能直接读入这个整数序列，但是你可以通过给定的函数来查询该序列的信息。关于查询函数的细节，请根据你所使用的语言，参考下面的实现细节部分。

你需要实现一个函数,该函数返回 $a_{i + 1} - a_i$（$1 \leq i \leq N - 1$）中的最大值。

## 实现细节

**本题只支持 C++（包括 cpp11，cpp14，cpp17）**。

### C/C++
你需要包含头文件 `gap.h`。

你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `long long` 类型的整数：

- $T$：子任务的编号（$1$ 或者 $2$）
- $N$：序列的长度

你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, &mn, &mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `long long` 类型的整数，后两个参数 `&mn` 和 `&mx` 是 `long long` 类型的整数的指针（`mn` 和 `mx` 是 `long long` 类型的整数）。当 `MinMax(s, t, &mn, &mx)` 返回时，变量 `mn` 将会存储满足 $a_i \in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \leq t$，否则程序将会终止，该测试点计为 $0$ 分。

### Pascal
你需要使用单元 `graderhelperlib`。

你需要实现一个函数 `findGap(T, N)`，该函数接受下面的参数，并返回一个 `Int64` 类型的整数：

- $T$：子任务的编号（$1$ 或者 $2$）（`Integer` 类型）
- $N$：序列的长度（`LongInt` 类型）

你的函数 `findGap` 可以调用系统提供的查询函数 `MinMax(s, t, mn, mx)`，该函数的前两个参数 $s$ 和 $t$ 是 `Int64` 类型的整数，后两个参数 `mn` 和 `mx` 是传引用方式的 `Int64` 类型的整数（过程内部对这两个变量的修改会影响到外部的对应变量的值）。当 `MinMax(s, t, mn, mx)` 执行完毕时，变量 `mn` 将会存储满足 $a_i \in [s, t]$ 中 $a_i$ 的最小值，变量 `mx` 将会存储满足 $a_i \in [s, t]$，$a_i$ 的最大值。如果区间 $[s, t]$ 中没有序列中的数，则 `mn` 和 `mx` 都将存储 $-1$。在查询时需要满足 $s \leq t$，否则程序将会终止，该测试点计为 $0$ 分。
## 输入格式

## 样例一

### C/C++

考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。

则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：

调用 `MinMax(1, 2, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $2$。

调用 `MinMax(3, 7, &mn, &mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。

调用 `MinMax(8, 9, &mn, &mx)`，则 `mn` 和 `mx` 皆返回 $8$。

### Pascal
考虑 $N = 4, a_1 = 2, a_2 = 3, a_3 = 6, a_4 = 8$。

则答案应该是 $3$，可以通过下面的几组对 `MinMax` 的询问获得：

调用 `MinMax(1, 2, mn, mx)`，则 `mn` 和 `mx` 皆返回 $2$。

调用 `MinMax(3, 7, mn, mx)`，则 `mn` 返回 $3$，`mx` 返回 $6$。

调用 `MinMax(8, 9, mn, mx)`，则 `mn` 和 `mx` 皆返回 $8$。

## 样例评测方式

样例测评系统从标准输入中读入两行。第一行包含两个整数，子任务编号 $T$，和序列长度 $N$。第二行包含 $N$ 个严格递增的非负整数。然后该程序会向标准输出中写入两行，第一行为 `findGap` 的返回值，第二行为花费 $M$ 的值。

下面的输入描述了上面的样例：

```plane
2 4
2 3 6 8
```
注意实际使用的交互库和 spj 对数据进行了加密。
## 提示

## 限制与约定

对于所有的测试点，有 $2 \leq N \leq 100000$。

每一个测试点开始测试之前，$M$ 都将被初始化为 $0$。

子任务 1（$30$ 分）：每一次调用 `MinMax` 都将使 $M$ 加 $1$。为了获得所有分数，需要满足对于该子任务下的所有测试点，都有 $M \leq \frac{N + 1}{2}$。

子任务 2（$70$ 分）：定义 $k$ 为调用 `MinMax` 时，区间 $[s, t]$ 中的序列中数的数量。每次调用 `MinMax`，将使 $M$ 加上 $k + 1$。对于每一个测试点，如果 $M \leq 3N$，你将得到 70 分，否则将得到 $\dfrac{60}{\sqrt{\frac MN + 1} - 1}$ 分。你的该子任务的得分是其下所有测试点中的最低分。



---

---
title: "[APIO2016] 划艇"
layout: "post"
diff: 省选/NOI-
pid: P3643
tag: ['2016', 'APIO']
---
# [APIO2016] 划艇
## 题目描述

在首尔城中，汉江横贯东西。在汉江的北岸，从西向东星星点点地分布着 $N$ 个划艇学校，编号依次为 $1$ 到 $N$。每个学校都拥有若干艘划艇。同一所学校的所有划艇颜色相同，不同的学校的划艇颜色互不相同。颜色相同的划艇被认为是一样的。每个学校可以选择派出一些划艇参加节日的庆典，也可以选择不派出任何划艇参加。如果编号为 $i$ 的学校选择派出划艇参加庆典，那么，派出的划艇数量可以在 $a_i$ 至 $b_i$ 之间任意选择（$a_i \leq b_i$）。

值得注意的是，编号为 $i$ 的学校如果选择派出划艇参加庆典，那么它派出的划艇数量必须大于任意一所编号小于它的学校派出的划艇数量。

输入所有学校的 $a_i,b_i$ 的值，求出参加庆典的划艇有多少种可能的情况，必须有至少一艘划艇参加庆典。两种情况不同当且仅当有参加庆典的某种颜色的划艇数量不同。

## 输入格式

第一行包括一个整数 $N$，表示学校的数量。

接下来 $N$ 行，每行包括两个正整数，用来描述一所学校。其中第 $i$ 行包括的两个正整数分别表示 $a_i,b_i$（$1 \leq a_i \leq b_i \leq 10^9$）。

## 输出格式

输出一行，一个整数，表示所有可能的派出划艇的方案数除以 $1,000,000,007$ 得到的余数。

## 样例

### 样例输入 #1
```
2
1 2
2 3
```
### 样例输出 #1
```
7

```
## 提示

【样例解释】

在只有一所学校派出划艇的情况下有 $4$ 种方案，两所学校都派出划艇的情况下有 $3$ 种方案，所以答案为 $7$。

【数据范围】

子任务 $1$（$9$ 分）：$1 \leq N \leq 500$ 且对于所有的 $1 \leq i \leq N$，保证 $a_i=b_i$。

子任务 $2$（$22$ 分）：$1 \leq N \leq 500$ 且 $\sum_{i=1}^N (b_i-a_i) \leq 10^6$。

子任务 $3$（$27$ 分）：$1 \leq N \leq 100$。

子任务 $4$（$42$ 分）：$1 \leq N \leq 500$。



---

---
title: "[APIO2015] 巴邻旁之桥"
layout: "post"
diff: 省选/NOI-
pid: P3644
tag: ['2015', '线段树', '堆', 'APIO']
---
# [APIO2015] 巴邻旁之桥
## 题目描述

一条东西走向的穆西河将巴邻旁市一分为二，分割成了区域 $A$ 和区域 $B$。

每一块区域沿着河岸都建了恰好 $1000000001$ 栋的建筑，每条岸边的建筑都从 $0$ 编号到 $1000000000$。相邻的每对建筑相隔 $1$ 个单位距离，河的宽度也是 $1$ 个单位长度。区域 $A$ 中的 $i$ 号建筑物恰好与区域 $B$ 中的 $i$ 号建筑物隔河相对。

城市中有 $N$ 个居民。第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，同时他的办公室坐落在 $Q_i$ 区域的 $T_i$ 号建筑上。一个居民的房子和办公室可能分布在河的两岸，这样他就必须要搭乘船只才能从家中去往办公室，这种情况让很多人都觉得不方便。为了使居民们可以开车去工作，政府决定建造不超过 $K$ 座横跨河流的大桥。

由于技术上的原因，每一座桥必须刚好连接河的两岸，桥梁必须严格垂直于河流，并且桥与桥之间不能相交。

当政府建造最多 $K$ 座桥之后，设 $D_i$ 表示第 $i$ 个居民此时开车从家里到办公室的最短距离。请帮助政府建造桥梁，使得 $D_1 + D_2 + \cdots + D_N$ 最小。

## 输入格式

输入的第一行包含两个正整数 $K$ 和 $N$，分别表示桥的上限数量和居民的数量。

接下来 $N$ 行，每一行包含四个参数：$P_i, S_i, Q_i$ 和 $T_i$，表示第 $i$ 个居民的房子在区域 $P_i$ 的 $S_i$ 号建筑上，且他的办公室位于 $Q_i$ 区域的 $T_i$ 号建筑上。


## 输出格式

输出仅为一行，包含一个整数，表示 $D_1 + D_2 + \cdots + D_N$ 的最小值。

## 样例

### 样例输入 #1
```
1 5
B 0 A 4
B 1 B 3
A 5 B 7
B 2 A 6
B 1 A 7
```
### 样例输出 #1
```
24

```
### 样例输入 #2
```
2 5
B 0 A 4
B 1 B 3
A 5 B 7
B 2 A 6
B 1 A 7
```
### 样例输出 #2
```
22
```
## 提示

【数据范围】

所有数据都保证：$P_i$ 和 $Q_i$ 为字符 “A” 和 “B” 中的一个， $0 \leq S_i, T_i \leq 1000000000$，同一栋建筑内可能有超过 $1$ 间房子或办公室（或二者的组合，即房子或办公室的数量同时大于等于 $1$）。

子任务 1 （8 分）$K = 1$

$1 \leq N \leq 1000$


子任务 2 （14 分）$K = 1$

$1 \leq N \leq 100000$


子任务 3 （9 分）$K = 2$

$1 \leq N \leq 100$


子任务 4 （32 分）$K = 2$

$1 \leq N \leq 1000$


子任务 5 （37 分）$K = 2$

$1 \leq N \leq 100000$



---

---
title: "[APIO2015] 雅加达的摩天楼"
layout: "post"
diff: 省选/NOI-
pid: P3645
tag: ['2015', 'APIO', '枚举', '最短路', '分块']
---
# [APIO2015] 雅加达的摩天楼
## 题目描述

印尼首都雅加达市有 $N$ 座摩天楼，它们排列成一条直线，我们从左到右依次将它们编号为 $0$ 到 $N − 1$。除了这 $N$ 座摩天楼外，雅加达市没有其他摩天楼。

有 $M$ 只叫做 “doge” 的神秘生物在雅加达市居住，它们的编号依次是 $0$ 到 $M − 1$。编号为 $i$ 的 doge 最初居住于编号为 $B_i$ 的摩天楼。每只 doge 都有一种神秘的力量，使它们能够在摩天楼之间跳跃，编号为 $i$ 的 doge 的跳跃能力为 $P_i$ （$P_i > 0$）。

在一次跳跃中，位于摩天楼 $b$ 而跳跃能力为 $p$ 的 doge 可以跳跃到编号为 $b - p$ （如果 $0 \leq b - p < N$）或 $b + p$ （如果 $0 \leq b + p < N$）的摩天楼。

编号为 $0$ 的 doge 是所有 doge 的首领，它有一条紧急的消息要尽快传送给编号为 $1$ 的 doge。任何一个收到消息的 doge 有以下两个选择:

- 跳跃到其他摩天楼上；
- 将消息传递给它当前所在的摩天楼上的其他 doge。

请帮助 doge 们计算将消息从 $0$ 号 doge 传递到 $1$ 号 doge 所需要的最少总跳跃步数，或者告诉它们消息永远不可能传递到 $1$ 号 doge。

## 输入格式

输入的第一行包含两个整数 $N$ 和 $M$。

接下来 $M$ 行，每行包含两个整数 $B_i$ 和 $P_i$。

## 输出格式

输出一行，表示所需要的最少步数。如果消息永远无法传递到 $1$ 号 doge，输出 $−1$。

## 样例

### 样例输入 #1
```
5 3
0 2
1 1
4 1
```
### 样例输出 #1
```
5
```
## 提示

【样例解释】

下面是一种步数为 $5$ 的解决方案：

$0$ 号 doge 跳跃到 $2$ 号摩天楼，再跳跃到 $4$ 号摩天楼（$2$ 步）。

$0$ 号 doge 将消息传递给 $2$ 号 doge。

$2$ 号 doge 跳跃到 $3$ 号摩天楼,接着跳跃到 $2$ 号摩天楼，再跳跃到 $1$ 号摩天楼（$3$ 步）。

$2$ 号 doge 将消息传递给 $1$ 号 doge。

【数据范围】

所有数据都保证 $0 \leq B_i < N$。

子任务 1 （10 分）$1 \leq N \leq 10$

$1 \leq P_i \leq 10$

$2 \leq M \leq 3$


子任务 2 （12 分）$1 \leq N \leq 100$

$1 \leq P_i \leq 100$

$2 \leq M \leq 2000$


子任务 3 （14 分）$1 \leq N \leq 2000$

$1 \leq P i ≤ 2000$

$2 \leq M \leq 2000$


子任务 4 （21 分）$1 \leq N \leq 2000$

$1 \leq P_i \leq 2000$

$2 \leq M \leq 30000$


子任务 5 （43 分）$1 \leq N \leq 30000$

$1 \leq P_i \leq 30000$

$2 \leq M \leq 30000$



---

---
title: "[APIO2015] 巴厘岛的雕塑"
layout: "post"
diff: 省选/NOI-
pid: P3646
tag: ['动态规划 DP', '贪心', '2015', 'APIO', '枚举', '进制', '位运算']
---
# [APIO2015] 巴厘岛的雕塑
## 题目描述

印尼巴厘岛的公路上有许多的雕塑,我们来关注它的一条主干道。

在这条主干道上一共有 $N$ 座雕塑，为方便起见，我们把这些雕塑从 $1$ 到 $N$ 连续地进行标号，其中第 $i$ 座雕塑的年龄是 $Y_i$ 年。为了使这条路的环境更加优美，政府想把这些雕塑分成若干组，并通过在组与组之间种上一些树，来吸引更多的游客来巴厘岛。

下面是将雕塑分组的规则：

这些雕塑必须被分为恰好 $X$ 组，其中 $A \leq X \leq B$，每组必须含有至少一个雕塑，每个雕塑也必须属于且只属于一个组。同一组中的所有雕塑必须位于这条路的连续一段上。

当雕塑被分好组后，对于每个组，我们首先计算出该组所有雕塑的年龄和。

计算所有年龄和按位取或的结果。我们这个值把称为这一分组的最终优美度。

请问政府能得到的最小的最终优美度是多少?

备注：将两个非负数 $P$ 和 $Q$ 按位取或是这样进行计算的：

首先把 $P$ 和 $Q$ 转换成二进制。

设 $n_P$ 是 $P$ 的二进制位数，$n_Q$ 是 $Q$ 的二进制位数，$M$ 为 $n_P$ 和 $n_Q$ 中的最大值。$P$ 的二进制表示为 $p_{M-1}p_{M-2} \dots p_1p_0$，$Q$ 的二进制表示为 $q_{M-1}q_{M-2} \dots q_1 q_0$，其中 $p_i$ 和 $q_i$ 分别是 $P$ 和 $Q$ 二进制表示下的第 $i$ 位，第 $M -1$ 位是数的最高位，第 $0$ 位是数的最低位。

$P$ 与 $Q$ 按位取或后的结果是： $(p_{M-1}\mathbin{\mathrm{OR}} q_{M-1})(p_{M-2}\mathbin{\mathrm{OR}}q_{M-2})\dots (p_1\mathbin{\mathrm{OR}} q_1) (p_0\mathbin{\mathrm{OR}}q_0)$。其中：$0 \mathbin{\mathrm{OR}} 0 = 0$

$0 \mathbin{\mathrm{OR}} 1 = 1$

$1 \mathbin{\mathrm{OR}} 0 = 1$

$1 \mathbin{\mathrm{OR}} 1 = 1$

## 输入格式

输入的第一行包含三个用空格分开的整数 $N, A, B$。

第二行包含 $N$ 个用空格分开的整数 $Y_1, Y_2, \dots, Y_N$。

## 输出格式

输出一行一个数，表示最小的最终优美度。

## 样例

### 样例输入 #1
```
6 1 3
8 1 2 1 5 4
```
### 样例输出 #1
```
11

```
## 提示

【样例解释】

将这些雕塑分为 $2$ 组，$(8, 1, 2)$ 和 $(1, 5, 4)$，它们的和是 $(11)$ 和 $(10)$，最终优美度是 $(11 \mathbin{\mathrm{OR}} 10) = 11$。（不难验证，这也是最终优美度的最小值。）

【数据范围】

子任务 1 （9 分）$1 \leq N \leq 20$

$1 \leq A \leq B \leq N$

$0 \leq Y_i \leq 1000000000$


子任务 2 （16 分）$1 \leq N \leq 50$

$1 \leq A \leq B \leq \min\{20, N\}$

$0 \leq Y_i \leq 10$


子任务 3 （21 分）$1 ≤ N ≤ 100$

$A = 1$

$1 \leq B \leq N$

$0 \leq Y_i \leq 20$


子任务 4 （25 分）$1 \leq N \leq 100$

$1 \leq A \leq B \leq N$

$0 \leq Y_i \leq 1000000000$


子任务 5 （29 分）$1 \leq N \leq 2000$

$A = 1$

$1 \leq B \leq N$

$0 \leq Y_i \leq 1000000000$



---

---
title: "[APIO2014] 连珠线"
layout: "post"
diff: 省选/NOI-
pid: P3647
tag: ['动态规划 DP', '2014', 'APIO', '枚举']
---
# [APIO2014] 连珠线
## 题目描述

在达芬奇时代，有一个流行的儿童游戏称为连珠线。当然，这个游戏是关于珠子和线的。线是红色或蓝色的，珠子被编号为 $1$ 到 $n$。这个游戏从一个珠子开始，每次会用如下方式添加一个新的珠子：

`Append(w, v)`：一个新的珠子 $w$ 和一个已经添加的珠子 $v$ 用红线连接起来。

`Insert(w, u, v)`：一个新的珠子 $w$ 插入到用红线连起来的两个珠子 $u, v$ 之间。具体过程是删去 $u, v$ 之间红线，分别用蓝线连接 $u, w$ 和 $w, v$。

每条线都有一个长度。游戏结束后，你的最终得分为蓝线长度之和。

给你连珠线游戏结束后的游戏局面，只告诉了你珠子和链的连接方式以及每条线的长度，没有告诉你每条线分别是什么颜色。

你需要写一个程序来找出最大可能得分。即，在所有以给出的最终局面结束的连珠线游戏中找出那个得分最大的，然后输出最大可能得分。

## 输入格式

第一行一个正整数 $n$，表示珠子的数量。珠子从 $1$ 到 $n$ 编号。

接下来 $n - 1$ 行每行三个整数 $a_i, b_i, c_i$。保证 $1 \leq a_i < b_i \leq n$。$1 \leq c_i \leq 10000$。表示 $a_i$ 号珠子和 $b_i$ 号珠子间连了长度为 $c_i$ 的线。

## 输出格式

输出一个整数，表示最大可能得分。

## 样例

### 样例输入 #1
```
5
1 2 10
1 3 40
1 4 15
1 5 20
```
### 样例输出 #1
```
60
```
### 样例输入 #2
```
10
4 10 2
1 2 21
1 3 13
6 7 1
7 9 5
2 4 3
2 5 8
1 6 55
6 8 34
```
### 样例输出 #2
```
140
```
## 提示

【样例描述1】

可以通过如下方式获得 $60$ 分：首先从 $3$ 号珠子开始。

把 $5$ 和 $3$ 连起来。（线长度任意）

在 $3$ 和 $5$ 之间插入 $1$。（线长分别为 $40$ 和 $20$）。

把 $2$ 和 $1$ 用长度为 $10$ 的线连起来。

把 $4$ 和 $1$ 用长度为 $15$ 的线连起来。


【限制与约定】

第一个子任务共 13 分，满足 $1 \leq n \leq 10$。

第二个子任务共 15 分，满足 $1 \leq n \leq 200$。

第三个子任务共 29 分，满足 $1 \leq n \leq 10000$。

第四个子任务共 43 分，满足 $1 \leq n \leq 200000$。



---

---
title: "[APIO2014] 序列分割"
layout: "post"
diff: 省选/NOI-
pid: P3648
tag: ['2014', 'APIO', 'Special Judge', '枚举', '斜率优化', '前缀和']
---
# [APIO2014] 序列分割
## 题目描述

你正在玩一个关于长度为 $n$ 的非负整数序列的游戏。这个游戏中你需要把序列分成 $k + 1$ 个非空的块。为了得到 $k + 1$ 块，你需要重复下面的操作 $k$ 次：

选择一个有超过一个元素的块（初始时你只有一块，即整个序列）

选择两个相邻元素把这个块从中间分开，得到两个非空的块。

每次操作后你将获得那两个新产生的块的元素和的乘积的分数。你想要最大化最后的总得分。

## 输入格式

第一行包含两个整数 $n$ 和 $k$。保证 $k + 1 \leq n$。

第二行包含 $n$ 个非负整数 $a_1, a_2, \cdots, a_n$ $(0 \leq a_i \leq 10^4)$，表示前文所述的序列。

## 输出格式

第一行输出你能获得的最大总得分。

第二行输出 $k$ 个介于 $1$ 到 $n - 1$ 之间的整数，表示为了使得总得分最大，你每次操作中分开两个块的位置。第 $i$ 个整数 $s_i$ 表示第 $i$ 次操作将在 $s_i$ 和 $s_{i} + 1$ 之间把块分开。

如果有多种方案使得总得分最大，输出任意一种方案即可。

## 样例

### 样例输入 #1
```
7 3
4 1 3 4 0 2 3
```
### 样例输出 #1
```
108
1 3 5
```
## 提示

你可以通过下面这些操作获得 $108$ 分：

初始时你有一块 $(4, 1, 3, 4, 0, 2, 3)$。在第 $1$ 个元素后面分开，获得 $4 \times (1 + 3 + 4 + 0 + 2 + 3) = 52$ 分。

你现在有两块 $(4), (1, 3, 4, 0, 2, 3)$。在第 $3$ 个元素后面分开，获得 $(1 + 3) \times (4 + 0 + 2 + 3) = 36$ 分。

你现在有三块 $(4), (1, 3), (4, 0, 2, 3)$。在第 $5$ 个元素后面分开，获得 $(4 + 0) \times (2 + 3) = 20$ 分。

所以，经过这些操作后你可以获得四块 $(4), (1, 3), (4, 0), (2, 3)$ 并获得 $52 + 36 + 20 = 108$ 分。

限制与约定

第一个子任务共 11 分，满足 $1 \leq k < n \leq 10$。

第二个子任务共 11 分，满足 $1 \leq k < n \leq 50$。

第三个子任务共 11 分，满足 $1 \leq k < n \leq 200$。

第四个子任务共 17 分，满足 $2 \leq n \leq 1000, 1 \leq k \leq \min\{n - 1, 200\}$。

第五个子任务共 21 分，满足 $2 \leq n \leq 10000, 1 \leq k \leq \min\{n - 1, 200\}$。

第六个子任务共 29 分，满足 $2 \leq n \leq 100000, 1 \leq k \leq \min\{n - 1, 200\}$。

感谢@larryzhong  提供的加强数据



---

---
title: "[APIO2014] 回文串"
layout: "post"
diff: 省选/NOI-
pid: P3649
tag: ['字符串', '2014', 'APIO', '后缀自动机 SAM', '后缀数组 SA', '回文自动机 PAM']
---
# [APIO2014] 回文串
## 题目描述

给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。

对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。

## 输入格式

一行，一个由小写拉丁字母（a~z）组成的非空字符串 $s$。

## 输出格式

输出一个整数，表示所有回文子串中的最大存在值。

## 样例

### 样例输入 #1
```
abacaba

```
### 样例输出 #1
```
7

```
### 样例输入 #2
```
www
```
### 样例输出 #2
```
4
```
## 提示

【样例解释1】

用 $\lvert s \rvert$ 表示字符串 $s$ 的长度。

一个字符串 $s_1 s_2 \dots s_{\lvert s \rvert}$ 的子串是一个非空字符串 $s_i s_{i+1} \dots s_j$，其中 $1 \leq i \leq j \leq \lvert s \rvert$。每个字符串都是自己的子串。

一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。

这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。

所以回文子串中最大的存在值为 $7$。



第一个子任务共 8 分，满足 $1 \leq \lvert s \rvert \leq 100$。

第二个子任务共 15 分，满足 $1 \leq \lvert s \rvert \leq 1000$。

第三个子任务共 24 分，满足 $1 \leq \lvert s \rvert \leq 10000$。

第四个子任务共 26 分，满足 $1 \leq \lvert s \rvert \leq 100000$。

第五个子任务共 27 分，满足 $1 \leq \lvert s \rvert \leq 300000$。



---

---
title: "[APIO2017] 考拉的游戏"
layout: "post"
diff: 省选/NOI-
pid: P3777
tag: ['2017', 'APIO', '交互题', 'Special Judge']
---
# [APIO2017] 考拉的游戏
## 题目背景

### 特别提示

**在洛谷提交本题时的一些注意事项（与原题面不同之处请以此处为准）：**

1. 提交时请在程序里加入以下函数声明语句：

```cpp
void playRound(int*,int*);
```

2. 程序开头不用，也不应该包含 `koala.h` 头文件。
3. 仅支持 `C++`（含 `C++`，`C++11`，`C++14`，`C++17`）提交。
## 题目描述

Koala 发明了一个新游戏，来邀请你一起玩！游戏的开始，她会在桌上放 $N$ 个物品，物品从 $0$ 到 $N - 1$ 标号。接着，她会秘密地给每个物品分配一个 $1$ 到 $N$ 之间的整数权值，且任意两个物品不会被分配到相同的权值。其中，第 $i$ 个物品的权值为 $P_i$。她请你来确定由这些权值构成的序列 $P=P_0,P_1,\dots ,P_{N-1}$ 的一些特征。

为了回答她的问题，你可以请 Koala 玩若干轮游戏。每一轮中，你会得到 $W$ 个蓝色石子，Koala 会得到 $W$ 个红色石子。首先，你可以选择若干个物品，再把你的一些（或全部）石子放在这些物品的旁边。Koala 会观察你的石子分配，然后类似地把她的一些（或全部）石子放在若干个物品旁边。如果一个物品旁边的红色石子数严格大于蓝色石子数，那么，Koala可以获得这个物品。Koala 分配她的石子时，总会选择使她获得的物品的权值和最大的方案，如果有多种方案可以做到这一点，她会选择一种获得的物品数最多的方案，如果仍然有多种方案，她会选择其中任意一种。

Koala 非常懒，如果你和她玩太多轮游戏，她就会睡着。你的任务是通过尽可能少轮数的游戏，确定 Koala 的序列 $P$ 的相关特征。

### 任务

在这个任务中，你需要实现 $4$ 个函数：`minValue`, `maxValue`, `greaterValue` 和 `allValues`。

每个函数需要你确定序列 $P$ 的不同特征。我们强烈推荐在我们提供的模版的基础上进行作答。注意，即使你只想获得部分子任务的分数，你也必须为四个函数都提供一个实现（尽管一些函数的内部可能为空）。你的程序禁止从标准输入读数据、向标准输出写数据或与任何文件交互。

在每个函数中，参数 `N` 表示游戏中物品的个数，参数 `W` 表示你和 Koala 在每一轮游戏中拥有的石子数。

* `minValue(N, W)` --- 这个函数需要返回权值最小的物品的标号 $i$，即 $P_i=1$
* `maxValue(N, W)` --- 这个函数需要返回权值最大的物品的标号 $i$，即 $P_i=N$
* `greaterValue(N, W)` --- 这个函数需要比较物品 $0$ 和物品 $1$ 的权值，返回权值较大的物品的标号。具体来说，若 $P_0>P_1$​，它应该返回 $0$ ，否则返回 $1$ 。
* `allValues(N, W, P)` --- 这个函数需要确定整个排列，并将其存放在给定的数组 $P$ 中：具体来说，$P[i]$ 应该保存物品 $i$ 的权值 $P_i (0 \leq i \leq N-1)$。

在每个测试点中，交互库会一次或多次调用这些函数中的一个。每次函数调用代表不同的任务，哪个函数会被调用、以及最多被调用多少次取决于子任务（见下文）。你可以认为 Koala 在每次函数调用前确定了她的序列 $P$，并且序列不会在一次函数的调用过程中改变。一次调用结束后，她可以在下次函数调用之前改变她的序列。

你实现的四个函数可以通过调用函数 `playRound` 来获取 Koala 的序列的相关信息。

* `playRound(B, R)`，请 Koala 和你玩一轮游戏。

数组 `B` 描述你在每个物品旁边放了多少蓝色石子。具体来说，对任意 $0 \leq i \leq N-1$，$B[i]$ 个蓝色石子将会被放在物品 $i$ 旁边。每个 $B[i]$ 必须是一个非负整数，且 $B[0]+B[1]+\cdots +B[N-1]$ 不能超过 $W$ 。

交互库会把 Koala 的回应存放在你提供的数组 `R` 中。具体来说，对任意 $0 \leq i \leq N-1$，Koala 会在物品 $i$ 旁边放 $R[i]$ 个红色石子。

每个子任务对你在每次游戏中调用 `playRound` 的次数有所限制。注意，调用次数越少你的得分可能会越高。（具体限制和评分方式参见下文）
## 提示

### 子任务

#### 样例数据：$0$ 分

**因为特殊原因（不支持设置 $0$ 分测试点），评测时将不测样例**。

* 有 $5$ 个「样例数据」测试点，每个测试点恰好调用一次 $4$ 个函数中的某一个。请看下文的「样例」获取各测试点的详细信息。
* $N=6$
* $P=5,3,2,1,6,4$

每次游戏中，你可以调用 `playRound `至多 $3200$ 次。

#### 子任务 1：$4$ 分
* 在这个子任务中，交互库只会调用函数 `minValue`，每个测试点中，这个函数最多会被调用 $100$ 次。
* $N=100$
* $W=100$
* 每一次游戏中，你可以调用 `playRound` 至多 $2$ 次。

#### 子任务 2：$15$ 分
* 在这个子任务中，交互库只会调用函数 `maxValue`。每个测试点中，这个函数最多会被调用 $100$ 次。
* $N=100$
* $W=100$
* 每一次游戏中，你可以调用 `playRound` 至多 $13$ 次。
* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：
  - 若 $C_{max}\leq 4$，获得 $15$ 分。
  - 若 $5 \leq C_{max} \leq 13$，获得 $7$ 分。

#### 子任务 3：$18$ 分
* 在这个子任务中，交互库只会调用函数 `greaterValue`。每个测试点中，这个函数最多会被调用 $1100$ 次。
* $N=100$
* $W=100$
* 每一次游戏中，你可以调用 `playRound` 至多 $14$ 次。
* 这个子任务中，一个测试点的分数取决于每一轮游戏中 `playRound` 被调用次数的最大值 $C_{max}$，具体来说，你的得分为：
  - 若 $C_{max}\leq 3$，获得 $18$ 分。
  - 若 $C_{max}=4$，获得 $14$ 分。
  - 若 $C_{max}=5$，获得 $11$ 分。
  - 若 $6 \leq C_{max}\leq 14$，获得 $5$ 分。

#### 子任务 4：$10$ 分
* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。
* $N=100$
* $W=200$
* 你可以调用 `playRound` 至多 $700$ 次。

#### 子任务 5：$53$ 分
* 在这个子任务中，交互库只会调用函数 `allValues`，每个测试点中，这个函数会被调用恰好一次。
* $N=100$
* $W=100$
* 你可以调用 `playRound` 至多 $3200$ 次。
* 这个子任务中，一个测试点的分数取决于 `playRound` 被调用的次数 $C$ ，具体来说，你的得分为：
  - 若 $C \leq 100$，获得 $53$ 分。
  - 若 $101 \leq C \leq 3200$，获得 $\lfloor 53-8 \log_2 (c/100) \rfloor$ 分。其中，$\lfloor x \rfloor$ 为不大于 $x$ 的最大整数。举例来说，若 $C=3200$，那么你的解答将获得 $13$ 分。

### 评分方式

- 和传统题一样，你的程序的运行时间和空间不能超过时间和空间限制。**交互库运行的时间和空间也会算入你的程序的总时间和空间当中**。当你估算这一部分的时空消耗时，你可以认为，在评测时使用的交互库与我们提供的样例交互库有**相同的函数**和**相似的实现**。
- 在一个测试点中，若你在调用 `playRound` 时传入了非法的数组 B，或调用 `playRound` 的总次数超过了上限，那么该测试点记 $0$ 分。
- 在一个测试点的任意一次游戏中，若一个函数没有正确地回答所要求的 Koala 的序列的特征，那么该测试点记 $0$ 分。
- 子任务 4 和子任务 5 均要求你实现函数 `allValues`，但在调用时传入了不同的 $W$。你可以利用两个子任务在这个参数上的不同，从而在你的实现中区分两个子任务。你可以参考你的语言的模板实现获取更详细的信息。
- 比赛时，你可以提交本题目最多 60 次，连续两次的提交至少间隔 2 分钟。
- **你在一个子任务上的得分，等于你在该子任务所有测试点中的最低得分**。

### 如何测试你的程序

在终端下输入如下命令进行编译：

```bash
g++ grader.cpp koala.cpp -o grader -g -Wall --std=c++11
```

样例交互库将按如下格式从标准输入读入数据：

第一行两个整数 $F,G$，其中 $F$ 代表交互库调用的函数类型，$G$ 代表调用函数的次数；

接下来 $G$ 行，每行开头两个整数 $N,W$，后跟 $N$ 个整数 $P_0,P_1,\ldots,P_{N-1}$。

$F$ 对应的样例交互库调用的函数类型如下表所示：

| $F$ | 调用的函数类型 |
| ----------- | ----------- |
| $1$ | `minValue` |
| $2$ | `maxValue` |
| $3$ | `greaterValue` |
| $4$ | `allValues` |

对于每次函数调用，样例交互库将向标准输出输出两行。第一行代表你调用 `playRound` 的次数，第二行代表函数调用后返回的结构（对于 $F=4$ 的情况，将输出调用 `allValues` 时返回的数组，对于其他情况，将输出函数的返回值）。

### 样例

考虑如下的排列：

| $i$ | 0 | 1 | 2 | 3 | 4 | 5 |
| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |
| $P_i$ | 5 | 3 | 2 | 1 | 6 | 4 |

下表展示了几次调用函数 `playRound` 的例子，以及交互库对每个调用的有效反馈（注意，一次 `playRound` 的调用，可能会有多种可能的有效反馈） 。

| $W$ | 调用 | 可能的交互库反馈 | 解释 |
| ----------- | ----------- | ----------- | ----------- |
| 6 | `playRound([0,3,0,2,1,0],R)` | `R=[1,1,1,0,2,1]` | Koala 获得了物品 $0,2,4,5$，总权值为 $17$，这是一种可能的权值最大的方案。 |
| 6 | `playRound([1,2,3,1,2,0],R)` | 非法调用 | 你总共放了 $9$ 个石子，超过了 $W$ 的限制。 |
| 12 | `playRound([0,3,0,2,1,0],R)` | `R=[2,3,0,2,3,1]` | 你不用放完 $W$ 个石子，Koala 也不用放完 $W$ 个石子。 |
| 6 | `playRound([0,1,0,0,1,0],R)` | `R=[1,0,1,1,2,1]` | 若 Koala 有多种方案最大化获得物品的权值，她会选择使自己获得物品最多的方案。因此 `R=[1,2,0,0,2,1]` 不是一个合法的返回值。 |

下面是样例数据的返回值，请注意在样例数据中，你可以调用 `playRound` 至多 $3200$ 次。

| # | 交互库调用 | 期望返回值 | 解释 |
| ----------- | ----------- | ----------- | ----------- |
| 1 | `minValue(6,6)` | 3 | $P_3=1$ |
| 2 | `maxValue(6,6)` | 4 | $P_4=6$ |
| 3 | `greaterValue(6,6)` | 0 | $P_0=5,P_1=3$ |
| 4 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 注意 `allValues` 无返回值，而是将正确结果放入 P 中。 |
| 5 | `allValues(6,12,P)` | `P=[5,3,2,1,6,4]` | 同上。 |


### 附加文件

附加文件包含样例输入输出，C++ 样例交互库和程序模板，我们推荐您在模板的基础上实现您的程序。


---

---
title: "[APIO2017] 商旅"
layout: "post"
diff: 省选/NOI-
pid: P3778
tag: ['2017', 'APIO']
---
# [APIO2017] 商旅
## 题目描述

在广阔的澳大利亚内陆地区长途跋涉后，你孤身一人带着一个背包来到了科巴。你被这个城市发达而美丽的市场所深深吸引，决定定居于此，做一个商人。科巴有$N$个集市，集市用从$1$到$N$的整数编号，集市之间通过$M$条单向道路连接，通过每条道路都需要消耗一定的时间。


在科巴的集市上，有$K$种不同的商品，商品用从$1$到$K$的整数编号。每个集市对每种商品都有自己的定价，买入和卖出商品的价格可以是不同的。并非每个集市都可以买卖所有的商品：一个集市可能只提供部分商品的双向交易服务；对于一种商品，一个集市也可能只收购而不卖出该商品或只卖出而不收购该商品。如果一个集市收购一种商品，它收购这种商品的数量是不限的，同样，一个集市如果卖出一种商品，则它卖出这种商品的数量也是不限的。


为了更快地获得收益，你决定寻找一条盈利效率最高的环路。环路是指带着空的背包从一个集市出发，沿着道路前进，经过若干个市场并最终回到出发点。在环路中，允许**多次**经过同一个集市或同一条道路。在经过集市时，你可以购买或者卖出商品，一旦你购买了一个商品，你需要把它装在背包里带走。由于你的背包非常小，任何时候你最多只能持有一个商品。在购买一个商品时，你不需要考虑你是否有足够的金钱，但在卖出时，需要注意只能卖出你拥有的商品。


从环路中得到的收益为在环路中卖出商品得到的金钱减去购买商品花费的金钱，而一条环路上消耗的时间则是依次通过环路上所有道路所需要花费的时间的总和。环路的盈利效率是指从环路中得到的收益除以花费的时间。需要注意的是，一条没有任何交易的环路的盈利效率为$0$。


你需要求出所有**消耗时间为正数**的环路中，盈利效率**最高**的环路的盈利效率。答案**向下取整**保留到整数。如果没有任何一条环路可以盈利，则输出 0 。

## 输入格式

从标准输入中读取输入数据。


第一行包含3个正整数，$N$、$M$和$K$，分别表示集市数量、道路数量和商品种类数量。


接下来的$N$行，第$i$行中包含$2K$个整数$B_{i,1},S_{i,1},B_{i,2},S_{i,2},\dots B_{i,K},S_{i,K}$描述一个集市。对于任意的$1 \leq j \leq K$, 整数$B_{i,j}$和$S_{i,j}$分别表示在编号为$i$的集市上购买、卖出编号为$j$的商品时的交易价格。如果一个交易价格为$-1$，则表示这个商品在这个集市上不能进行这种交易。


接下来$M$行，第$p$行包含 3 个整数，$V_p$、$W_p$和$T_p$, 表示存在一条从编号为$V_p$的市场出发前往编号为$W_p$的市场的路径花费$T_p$分钟。

## 输出格式

输出到标准输出中。


输出包含一个整数，表示盈利效率最高的环路盈利效率，答案**向下取整**保留到整数。如果没有任何一条环路可以盈利，则输出 0 。

## 样例

### 样例输入 #1
```
4 5 2
10 9 5 2
6 4 20 15
9 7 10 9
-1 -1 16 11
1 2 3
2 3 3
1 4 1
4 3 1
3 1 1
```
### 样例输出 #1
```
2
```
## 提示

## 样例解释

在样例中，我们考虑下面两条环路，“1 - 2 - 3 - 1” 和 “1 - 4 - 3 - 1”。

考虑环路 “1 - 2 - 3 - 1” ：这条环路消耗的总时间是$(3+3+1)=7$分钟。在这条环路中，最佳的交易方式是：在编号为 1 的集市中购买编号为 2 的商品（花费的金钱为 5）；在编号为 2 的集市中卖出编号为 2 的商品（得到的金钱为 15），然后立即购买编号为 1 的商品（花费的金钱为 6）；带着编号为 1 的商品经过编号为 3 的集市，在回到编号为 1 的城市后卖出（得到的金钱为 9）。在这个环路中，总盈利为$-5+15-6+9=13$ 。 这个环路的盈利效率为$13/7$ ，向下取整后为 1 。


考虑环路 “1 - 4 - 3 - 1” ：这条环路消耗的总时间是$(1+1+1)=3$分钟。在这条环路中，最佳的交易方式是：在编号为 1 的集市中购买编号为 2 的商品（花费的金钱为 5）；在编号为 4 的集市中卖出编号为 2 的商品（得到的金钱为 11）；然后经过编号为 3 的集市回到编号为 1 的城市。在这个环路中，总盈利为$-5+11=6$。 这个环路的盈利效率为$6/3$，向下取整后为 2 。


综上所述，盈利效率最高的环路的盈利效率为 2 。


## 子任务

在所有的子任务中，保证$1 \leq N \leq 100$，$1 \leq M \leq 9900$，$1 \leq K \leq 1000$, 如果在编号为$i (1 \leq i \leq N)$的集市中，编号为$j (1 \leq j \leq K)$的商品既可以购买又可以卖出，则$0 \leq S_{i,j} \leq B_{i,j} \leq 1000000000$。对于编号为$p (1 \leq p \leq M)$的道路，保证$V_p \not= W_p$且$1 \leq T_p \leq 10000000$。 不存在满足$1 \leq p < q \leq M$的$p$，$q$使得$(V_p, W_p)=(V_q, W_q)$。

![](https://cdn.luogu.com.cn/upload/pic/5529.png)



---

---
title: "[APIO2018] 铁人两项"
layout: "post"
diff: 省选/NOI-
pid: P4630
tag: ['2018', 'APIO', '双连通分量']
---
# [APIO2018] 铁人两项
## 题目描述

比特镇的路网由 $m$ 条双向道路连接的 $n$ 个交叉路口组成。

最近，比特镇获得了一场铁人两项锦标赛的主办权。这场比赛共有两段赛程：选手先完成一段长跑赛程，然后骑自行车完成第二段赛程。

比赛的路线要按照如下方法规划：

1. 先选择三个两两互不相同的路口 $s$、$c$ 和 $f$，分别作为比赛的起点、切换点（运动员在长跑到达这个点后，骑自行车前往终点）、终点。
2. 选择一条从 $s$ 出发，经过 $c$ 最终到达 $f$ 的路径。考虑到安全因素，选择的路径经过同一个点至多一次。

在规划路径之前，镇长想请你帮忙计算，总共有多少种不同的选取 $s$、$c$ 和 $f$ 的方案，使得在第 $2$ 步中至少能设计出一条满足要求的路径。

## 输入格式

第一行包含两个整数 $n$ 和 $m$，分别表示交叉路口和双向道路的数量。

接下来 $m$ 行，每行两个整数 $v_i, u_i$。表示存在一条双向道路连接交叉路口 $v_i, u_i$（$1 \le v_i, u_i \le n$，$v_i \neq u_i$）。

保证任意两个交叉路口之间，至多被一条双向道路直接连接。
## 输出格式

输出一行，包括一个整数，表示能满足要求的不同的选取 $s$、$c$ 和 $f$ 的方案数。
## 样例

### 样例输入 #1
```
4 3
1 2
2 3
3 4

```
### 样例输出 #1
```
8

```
### 样例输入 #2
```
4 4
1 2
2 3
3 4
4 2

```
### 样例输出 #2
```
14

```
## 提示

**提示**

在第一个样例中，有以下 $8$ 种不同的选择 $(s, c, f)$ 的方案：

- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (2, 3, 4), (3, 2, 1)$；
- $(4, 2, 1), (4, 3, 1), (4, 3, 2)$。

在第二个样例中，有以下 $14$ 种不同的选择 $(s, c, f)$ 的方案：

- $(1, 2, 3), (1, 2, 4), (1, 3, 4), (1, 4, 3), (2, 3, 4)$；
- $(2, 4, 3), (3, 2, 1), (3, 2, 4), (3, 4, 1), (3, 4, 2)$；
- $(4, 2, 1), (4, 2, 3), (4, 3, 1), (4, 3, 2)$。

**子任务（注：这里给出的子任务与本题在这里的最终评测无关，仅供参考）**

- Subtask 1（points: $5$）：$n \leq 10$，$m \leq 100$。
- Subtask 2（points: $11$）：$n \leq 50$，$m \leq 100$。
- Subtask 3（points: $8$）：$n \leq 100000$，每个交叉路口至多作为两条双向道路的端点。
- Subtask 4（points: $10$）：$n \leq 1000$，在路网中不存在环（存在环是指存在一个长度为 $k$（$k \ge 3$）的交叉路口序列 $v_1, v_2, \ldots, v_k$，序列中的路口编号两两不同，且对于 $i$ 从 $1$ 到 $k - 1$，有一条双向道路直接连接路口 $v_i$ 和 $v_{i+1}$，且有一条双向道路直接连接路口 $v_k$ 和 $v_1$）。
- Subtask 5（points: $13$）：$n \leq 100000$，在路网中不存在环。
- Subtask 6（points: $15$）：$n \leq 1000$，对于每个交叉路口，至多被一个环包含。
- Subtask 7（points: $20$）：$n \leq 100000$，对于每个交叉路口，至多被一个环包含。
- Subtask 8（points: $8$）：$n \leq 1000$，$m \leq 2000$。
- Subtask 9（points: $10$）：$n \leq 100000$，$m \leq 200000$。


---

---
title: "[APIO2019] 桥梁"
layout: "post"
diff: 省选/NOI-
pid: P5443
tag: ['2019', 'APIO']
---
# [APIO2019] 桥梁
## 题目背景

圣彼得堡市内所有水路长度总和约 $282$ 千米，市内水域面积占城市面积的 $7\%$。——来自维基百科
## 题目描述

圣彼得堡位于由 $m$ 座桥梁连接而成的 $n$ 个岛屿上。岛屿用 $1$ 到 $n$ 的整数编号，桥梁用 $1$ 到 $m$ 的整数编号。每座桥连接两个不同的岛屿。有些桥梁是在彼得大帝时代建造的，其中一些是近期建造的。这导致了不同的桥梁可能有不同的重量限制。更具体地，只有重量不超过 $d_i$ 的汽车才能通过第 $i$ 座桥梁。有时圣彼得堡的一些桥梁会进行翻新，但这并不一定会使桥梁承重变得更好，也就是说，进行翻新的桥梁的 $d_i$ 可能会增加或减少。你准备开发一个产品，用于帮助公民和城市客人。目前，你开发的模块要能执行两种类型的操作：

1. 将桥梁 $b_j$ 的重量限制改为 $r_j$。

2. 统计一辆重为 $w_j$ 的汽车从岛屿 $s_j$ 出发能够到达多少个不同的岛屿。

请你回答所有第二种操作的答案。


## 输入格式

第一行包含两个整数 $n$ 和 $m$—— 表示圣彼得堡的岛屿数量与桥梁数量。

接下来 $m$ 行，每行三个整数 $u_i,v_i,d_i$。第 $i$ 行的整数描述了一座连接岛屿 $u_i$ 和 $v_i$，初始时重量限制为 $d_i$ 的桥梁。

接下来一行一个整数 $q$—— 表示操作的数量。

接下来 $q$ 行按顺序每行描述一个操作。

每行第一个整数 $t_j$ 表示操作类型：

- 若 $t_j=1$，则该操作是第一种类型，该行接下来给定两个整数 $b_j$ 和 $r_j$，表示桥梁 $b_j$ 的重量限制将变为 $r_j$。

- 若 $t_j=2$，则该操作是第二种类型，该行接下来给定两个整数 $s_j$ 和 $w_j$，表示一辆重为 $w_j$ 的汽车将要从第 $s_j$ 个岛屿出发。
## 输出格式

对于每个第二种类型的询问，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
3 4
1 2 5
2 3 2
3 1 4
2 3 8
5
2 1 5
1 4 1
2 2 5
1 1 1
2 3 2
```
### 样例输出 #1
```
3
2
3
```
### 样例输入 #2
```
7 8
1 2 5
1 6 5
2 3 5
2 7 5
3 4 5
4 5 5
5 6 5
6 7 5
12
2 1 6
1 1 1
2 1 2
1 2 3
2 2 2
1 5 2
1 3 1
2 2 4
2 4 2
1 8 1
2 1 1
2 1 3
```
### 样例输出 #2
```
1
7
7
5
7
7
4
```
## 提示

对于全部数据，$1 \leq n \leq 5\times 10^4$，$0 \leq m \leq 10^5$，$1 \leq q \leq 10^5$。保证 $1 \leq u_i$，$v_i$, $s_j \leq n$，$u_i \neq v_i$，$1 \leq d_i$, $r_j$, $w_j \leq 10^9$，$1 \leq b_j \leq m$，$t_j \in {1,2}$。

详细子任务附加限制与分值如下表 **（注：这里给出的子任务与本题在这里的最终评测无关，仅供参考）**

| 子任务 | 附加限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $n$, $m\leq 10^3$，$q\leq 10^4$ | 13 |
| 2 | 岛屿和桥梁将形成一个树结构；$m=n-1$，$u_i=i$，$v_i=i+1$；（$1\leq i\leq m$） | 16 |
| 3 | 岛屿和桥梁将形成一个完全二叉树结构；$n=2^k-1$，$m=n-1$，$u_i=\frac{i+1}{2}$，$v_i=i+1$；（$1\leq k\leq 15$，$1\leq i\leq m$） | 17 |
| 4 | 所有 $t_i$ 均为 $2$ | 14 |
| 5 | 岛屿和桥梁将形成一个树结构 | 13 |
| 6 | 无特殊限制 | 27 |


---

---
title: "[APIO2019] 奇怪装置"
layout: "post"
diff: 省选/NOI-
pid: P5444
tag: ['2019', 'APIO']
---
# [APIO2019] 奇怪装置
## 题目描述

考古学家发现古代文明留下了一种奇怪的装置。该装置包含两个屏幕，分别显示两个整数 $x$ 和 $y$ 。

经过研究，科学家对该装置得出了一个结论：该装置是一个特殊的时钟，它从过去的某个时间点开始测量经过的时刻数 $t$，但该装置的创造者却将 $t$ 用奇怪的方式显示出来。若从该装置开始测量到现在所经过的时刻数为 $t$，装置会显示两个整数：$x = ((t + \lfloor \frac {t}{B} \rfloor) \bmod A)$，与 $y=(t \bmod B)$。这里 $\lfloor x \rfloor$ 是下取整函数，表示小于或等于 $x$ 的最大整数。

考古学家通过进一步研究还发现，该装置的屏幕无法一直工作。实际上，该装置的屏幕只在 $n$ 个连续的时间区间段中能正常工作。第 $i$ 个时间段从时刻 $l_i$ 到时刻 $r_i$。现在科学家想要知道有多少个不同的数对 $x,y$ 能够在该装置工作时被显示出来。

两个数对 $(x_1,y_1)$ 和 $(x_2,y_2)$ 不同当且仅当 $x_1 \neq x_2$ 或 $y_1 \neq y_2$。

## 输入格式

第一行包含三个整数 $n$，$A$ 与 $B$。
接下来 $n$ 行每行两个整数 $l_i$，$r_i$ 表示装置可以工作的第 $i$ 个时间区间。
## 输出格式

输出一行一个整数表示问题的答案。
## 样例

### 样例输入 #1
```
3 3 3
4 4
7 9
17 18
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
3 5 10
1 20
50 68
89 98
```
### 样例输出 #2
```
31
```
### 样例输入 #3
```
2 16 13
2 5
18 18
```
### 样例输出 #3
```
5
```
## 提示

对于第一个样例，装置屏幕将显示如下这些数对。

$t=4:(2,1)$

$t=7:(0,1)$

$t=8:(1,2)$

$t=9:(0,0)$

$t=17:(1,2)$

$t=18:(0,0)$

共有四个不同的数对：$(0,0),(0,1),(1,2),(2,1)$

对于全部数据，$1 \leq n \leq 10^6,1 \leq A,B \leq 10^{18},0 \leq l_i \leq r_i \leq 10^{18}$

令 $S=\sum_{i=1}^n (r_i-l_i+1)$ 与 $L=\max_{i=1}^n (r_i-l_i+1)$

详细子任务附加限制与分值如下表：

| 子任务 | 附加限制 | 分值 |
| :-----------: | :----------- | :-----------: |
| 1 | $S\leq 10^6$ | 10 |
| 2 | $n=1$ | 5 |
| 3 | $A\times B \leq 10^6$ | 5 |
| 4 | $B=1$ | 5 |
| 5 | $B\leq 3$ | 5 |
| 6 | $B\leq 10^6$ | 20 |
| 7 | $L\leq B$ | 20 |
| 8 | 无附加限制 | 30 |



---

---
title: "[APIO2019] 路灯"
layout: "post"
diff: 省选/NOI-
pid: P5445
tag: ['2019', 'APIO']
---
# [APIO2019] 路灯
## 题目描述

一辆自动驾驶的出租车正在 Innopolis 的街道上行驶。该街道上有 $n+1$ 个停车站点，它们将街道划分成了 $n$ 条路段。每一路段都拥有一个路灯。当第 $i$ 个路灯亮起，它将照亮连接第 $i$ 与第 $i+1$ 个站点的路段。否则这条路段将是黑暗的。

安全起见，出租车只能在被照亮的路段上行驶。换言之，出租车能从站点 $a$ 出发到达站点 $b (a<b)$ 的条件是：连接站点 $a$ 与 $a+1$，$a + 1$ 与 $a+2$，……，$b-1$ 与 $b$ 的路段都被照亮。

在经过一些意外故障或修理之后，街道上的路灯可能是亮起的，也可能是熄灭的。

现在给定 $0$ 时刻时，街道上路灯的初始状态。之后 $1,2,\ldots,q$ 时刻，每时刻会发生下列两种事件之一：

- $\text{toggle} \ i$：切换第 $i$ 个路灯的状态。具体地说，若路灯原来亮起，则现在将熄灭；若路灯原来熄灭，则现在将亮起。

- $\text{query}  \  a  \  b$：出租车部门的负责人想知道，从 $0$ 时刻起到当前时刻，有多少个时刻满足：出租车能够从站点 $a$ 出发到达站点 $b$。

请你帮助出租车部门的负责人回答他们的问题。
## 输入格式

第一行包含两个整数 $n$ 和 $q$，表示路灯的数量与时刻数。

第二行包含一个字符串 $s$ 表示路灯的初始状态，$s_i$ 为 $1$ 表示第 $i$ 个路灯初始时亮起；$s_i$ 为 $0$ 表示第 $i$ 个路灯初始时熄灭。

接下来 $q$ 行每行描述一个时刻的事件。第 $i$ 行描述时刻 $i$ 所发生的事件：

- $\text{toggle} \ i$：该时刻切换了第 $i$ 个路灯的状态。

- $\text{query} \ a \ b$：计算从 $0$ 时刻起到该时刻，共有多少个时刻满足：出租车能从站点 $a$ 出发到达站点 $b$。

至少有一个时刻的事件是 $\text{query}$。
## 输出格式

对于每个 $\text{query}$ 的事件，输出一行单个整数，表示该问题的答案。
## 样例

### 样例输入 #1
```
5 7
11011
query 1 2
query 1 2
query 1 6
query 3 4
toggle 3
query 3 4
query 1 6
```
### 样例输出 #1
```
1
2
0
0
1
2
```
## 提示

对于全部数据，$1 \leq n,q \leq 3\times 10^5$，$|s|=n$，$1 \leq i \leq n$，$1 \leq a < b \leq n+1$。

详细子任务附加限制与分值如下表 **（注：这里给出的子任务与本题在这里的最终评测无关，仅供参考）**

| 子任务 | 附加限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $n$, $q\leq 100$ | 20 |
| 2 | 对于所有 $\text{query}\ a\ b$ 事件，满足 $a=b-1$ | 20 |
| 3 | 对于所有 $\text{toggle}\ i$ 事件，第 $i$ 个路灯将被点亮 | 20 |
| 4 | 所有 $\text{toggle}$ 事件都发生在第一个 $\text{query}$ 事件之前 | 20 |
| 5 | 无特殊限制 | 20 |


---

---
title: "[APIO2020] 粉刷墙壁"
layout: "post"
diff: 省选/NOI-
pid: P6764
tag: ['2020', 'APIO', '交互题', 'Special Judge', 'O2优化']
---
# [APIO2020] 粉刷墙壁
## 题目背景

由于官方数据包过大，本题仅评测部分数据。

本题仅支持 C++ 系列语言，提交时**不需要**包含 `paint.h` 头文件。

如果交互库存在其他问题，请私信 mrsrz。
## 题目描述

距离上一次 Pak Dengklek 在他的家中粉刷墙壁已经过了一段时间，所以他想重新粉刷一次。他家的墙壁由 $N$ 段组成，它们从 $0$ 到 $N - 1$ 编号。本题中我们假设存在 $K$ 种不同的颜色，颜色用从 $0$ 到 $K - 1$ 的整数表示（例如，红色用 $0$ 表示, 蓝色用 $1$ 表示，以此类推）。Pak Dengklek 希望用第 $C[i]$ 种颜色来粉刷第 $i$ 段的墙壁。

为了粉刷墙壁，Pak Dengklek 雇用了一家有 $M$ 个承包商的承包商公司，承包商从 $0$ 到 $M - 1$ 编号。对 Pak Dengklek 来说不幸的是，承包商只愿意粉刷他们自己喜欢的
颜色。具体来说，第 $j$ 个承包商喜欢 $A[j]$ 种颜色，并且只想用下列颜色来粉刷墙壁：第 $B[j][0]$ 种颜色，第 $B[j][1]$ 种颜色，$\dots$，或第 $B[j][A[j] − 1]$ 种颜色。

Pak Dengklek 可以给承包商公司提出一些要求。在单个要求中，Pak Dengklek 将给出两个参数 $x$ 和 $y$， 其中 $0 \leq x < M$，$0 \leq y \leq N - M$。承包商公司将会指派第 $((x + l) \mod M)$ 个承包商粉刷第 $(y + l)$ 段墙壁，其中 $0 \leq l < M$。如果存在一个 $l$ 使
得第 $((x + l) \mod M)$ 个承包商不喜欢第 $C[y + l]$ 种颜色，那么该要求将无效。

Pak Dengklek 需要为每个要求付费，因此他想知道为了使墙壁中每个段都能用自己预期的颜色粉刷，他至少要提出多少个要求，或是确认他的预期无法达到。每一段墙壁可以被粉刷多次，但必须保证每次粉刷的颜色都是 Pak Dengklek 所预期的。

你必须实现 `minimumInstructions` 函数：

- `minimumInstructions(N, M, K, C, A, B)` - 该函数将被评测库恰好调用一次。
	- $N$：一个整数表示墙壁的段数。
	- $M$：一个整数表示承包商的数量。
	- $K$：一个整数表示颜色的种数。
	- $C$：一个长度为 $N$ 的整数序列，表示每段墙壁预期的颜色。
	- $A$：一个长度为 $M$ 的整数序列，表示承包商喜欢的颜色数。
	- $B$：一个长度为 $M$ 的每个元素为序列的序列，表示承包商喜欢的具体颜色。
	- 该函数必须返回一个整数，表示 Pak Dengklek 为了让墙壁按预期粉刷所需要提出的最小要求数；若预期无法达到则返回 $-1$。
## 输入格式

样例评测库将读入以下格式的数据：
```
N M K
C[0] C[1] ... C[N-1]
A[0] B[0][0] B[0][1] ... B[0][A[0]-1]
A[1] B[1][0] B[1][1] ... B[1][A[1]-1]
.
.
.
A[M-1] B[M-1][0] B[M-1][1] ... B[M-1][A[M-1]-1]
```
## 输出格式

样例评测库将输出函数 `minimumInstructions` 的返回值
## 样例

### 样例输入 #1
```
8 3 5
3 3 1 3 4 4 2 2
3 0 1 2
2 2 3
2 3 4

```
### 样例输出 #1
```
3

```
### 样例输入 #2
```
5 4 4
1 0 1 2 2
2 0 1
1 1
1 2
1 3

```
### 样例输出 #2
```
-1

```
## 提示

在第一个样例中， $N = 8$，$M = 3$，$K = 5$，$C = [3, 3, 1, 3, 4, 4, 2, 2]$，$A = [3, 2, 2]$，$B = [[0, 1, 2], [2, 3], [3, 4]]$。Pak Dengklek 可以提出下列的要求。

1. $x = 1$，$y = 0$。这是一个有效的要求，第一个承包商可以粉刷第零段墙壁，第二个承包商可以粉刷第一段墙壁，第零个承包商可以粉刷第二段墙壁。
2. $x = 0$，$y = 2$。 这是一个有效的要求，第零个承包商可以粉刷第二段墙壁，第一个承包商可以粉刷第三段墙壁，第二个承包商可以粉刷第四段墙壁。
3. $x = 2$，$y = 5$。 这是一个有效的要求，第二个承包商可以粉刷第五段墙壁，第零个承包商可以粉刷第六段墙壁，第一个承包商可以粉刷第七段墙壁。

容易看出 Pak Dengklek 不能用少于 $3$ 个的要求来达到预期，因此 `minimumInstructions(8, 3, 5, [3, 3, 1, 3, 4, 4, 2, 2], [3, 2, 2], [[0, 1, 2], [2, 3], [3,
4]])` 应该返回 $3$。

在第二个样例中，$N = 5$，$M = 4$，$K = 4$，$C = [1, 0, 1, 2, 2]$，$A = [2, 1, 1, 1]$，$B =
[[0, 1], [1], [2], [3]]$。由于第三个承包商只喜欢第 $3$ 种颜色但没有任何一段墙壁能被该颜色粉刷，Pak Dengklek 无法给出任何有效指令。因此`minimumInstructions(5, 4, 4,[1, 0, 1, 2, 2], [2, 1, 1, 1], [[0, 1], [1], [2], [3]])` 应该返回 $-1$。

对于 $0 \leq k < K$, 令 $f(k)$ 表示喜欢第 $k$ 种颜色的承包商数量。

【条件限制】

- $1 \leq N \leq 100 000$。
- $1 \leq M \leq \min(N, 50 000)$。
- $1 \leq K \leq 100 000$。
- $0 \leq C[i] < K$。
- $1 \leq A[j] \leq K$。
- $0 \leq B[j][0] < B[j][1] < \dots < B[j][A[j] − 1] < K$。
- $\sum f(k)^2 \leq 400 000$。

【子任务 $1$（$12$ 分）】

- $f(k) \leq 1$。

【子任务 $2$（$15$ 分）】

- $N \leq 500$。
- $M \leq \min(N, 200)$。
- $\sum f(k)^2 \leq 1 000$。

【子任务 $3$（$13$ 分）】

- $N \leq 500$。
- $M \leq \min(N, 200)$。

【子任务 $4$（$23$ 分）】

- $N \leq 20 000$。
- $M \leq \min(N, 2 000)$。

【子任务 $5$（$37$ 分）】

- 无附加限制。


---

---
title: "[APIO2020] 交换城市"
layout: "post"
diff: 省选/NOI-
pid: P6765
tag: ['2020', 'APIO', '交互题', 'Special Judge']
---
# [APIO2020] 交换城市
## 题目背景

由于官方数据包过大，本题仅评测部分数据。

本题仅支持 C++ 系列语言，提交时**不需要**包含 `swap.h` 头文件。

由于交互库本身的性能问题，本题的时间限制上调为 $3$ 秒。如果交互库存在其他问题，请私信 mrsrz。
## 题目描述

印度尼西亚有 $N$ 个城市以及 $M$ 条双向道路，城市从 $0$ 到 $N - 1$ 编号，道路从 $0$ 到 $M - 1$ 编号。每条道路连接着两个不同的城市，第 $i$ 条道路连接第 $U[i]$ 个城市与第 $V[i]$ 个城市，汽车行驶这条道路将耗费 $W[i]$ 个单位汽油。通过这些道路，任意两个城市间能够互相到达。

接下来的 $Q$ 天中, 每天会有一对城市希望建立政治关系。具体来说，第 $j$ 天，第 $X[j]$ 个城市想要和第 $Y[j]$ 个城市建立政治关系。为此，第 $X[j]$ 个城市将会派一名代表坐汽车前往第 $Y[j]$ 个城市。同样地，第 $Y[j]$ 个城市也会派一名代表坐汽车前往第 $X[j]$ 个城市。

为了避免拥塞，两辆车不应在任何时间点碰面。更具体地，两辆车不能在同一个时间点出现在同一个城市。同样地，两辆车也不应该沿相反的方向同时行驶过同一条道路。另外，汽车行驶过一条道路时必须完整经过道路并到达道路另一端的城市（换句话说，汽车不允许在道路中间掉转方向）。但是，汽车可以多次到达一个城市或是多次经过一条道路。此外，汽车可以在任何时间在任何城市等候。

由于高燃料容量汽车的价格昂贵，两个城市都分别希望选择一条路线，使得两辆汽车所需的最大单位汽油容量最小。每个城市中都有加油站并且供油量是无限的，因此汽车所需的单位汽油容量实际上就是行驶过的道路中最大的单位汽油消耗量。

你必须实现 `init` 和 `getMinimumFuelCapacity` 函数。

- `init(N, M, U, V, W)` - 该函数将在所有 `getMinimumFuelCapacity` 的调用前被评测库恰好调用一次。
	- $N$： 一个整数表示城市数。
	- $M$： 一个整数表示道路数。
	- $U$： 一个长为 $M$ 的整数序列表示道路的第一个端点城市。
	- $V$： 一个长为 $M$ 的整数序列表示道路的第二个端点城市。
	- $W$： 一个长为 $M$ 的整数序列表示道路的汽油消耗。

- `getMinimumFuelCapacity(X, Y)` - 该函数将被评测库调用恰好 $Q$ 次。
	- $X$： 一个整数表示第一个城市。
	- $Y$： 一个整数表示第二个城市。
	- 该函数必须返回一个整数，表示根据题目描述中的规则，两辆分别从第 $X$ 个城市与第 $Y$ 个城市出发要到达彼此城市的车，它们的单位汽油容量最大值的最小值。若无法满足题目规则则返回 $−1$。
## 输入格式

样例评测库将读入以下格式的数据： 

```
N M
U[0] V[0] W[0]
U[1] V[1] W[1]
.
.
.
U[M-1] V[M-1] W[M-1]
Q
X[0] Y[0]
X[1] Y[1]
.
.
.
X[Q-1] Y[Q-1]
```
## 输出格式

对每个 `getMinimumFuelCapacity` 的调用，样例评测库会输出该函数的返回值
## 样例

### 样例输入 #1
```
5 6
0 1 4
0 2 4
1 2 1
1 3 2
1 4 10
2 3 3
3
1 2
2 4
0 1

```
### 样例输出 #1
```
3
10
4

```
### 样例输入 #2
```
3 2
0 1 5
0 2 5
1
1 2

```
### 样例输出 #2
```
-1

```
## 提示

第一个样例中, $N = 5$，$M = 6$，$U = [0, 0, 1, 1, 1, 2]$，$V = [1, 2, 2, 3, 4, 3]$，$W =
[4, 4, 1, 2, 10, 3]$，$Q = 3$，$X = [1, 2, 0]$，$Y = [2, 4, 1]$。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/j3x1idy8.png)

评测库初始时将调用 `init(5, 6, [0, 0, 1, 1, 1, 2], [1, 2, 2, 3, 4, 3],[4, 4, 1, 2, 10, 3])`。之后，评测库将进行如下函数调用：

- `getMinimumFuelCapacity(1, 2)`。首先，从第一个城市出发的汽车可以行驶到第三个城市。接着，从第二个城市出发的汽车可以行驶到第一个城市，并且在第三个城市的汽车可以行驶到第二个城市。因此，最大的单位汽油容量为 $3$ （从第三个城市到第二个城市需要花费 $3$ 个单位汽油）。没有其他更优的路线方案，因此该函数应该返回 $3$。

- `getMinimumFuelCapacity(2, 4)`。任何从第四个城市出发或要到达第四个城市的汽车都需要耗费 $10$ 个单位汽油，因此该函数应该返回 $10$。

- `getMinimumFuelCapacity(0, 1)`。该函数应该返回 $4$。

第二个样例中，$N = 3$，$M = 2$，$U = [0, 0]$，$V = [1, 2]$，$W = [5, 5]$，$Q = 1$，$X = [1]$，$Y = [2]$。 如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/3df9k1og.png)

评测库初始时将调用 `init(3, 2, [0, 0], [1, 2], [5, 5])`，之后，评测库将进行如下函数调用：

- `getMinimumFuelCapacity(1, 2)`。两辆车无法满足不在同一时间点碰面的要求，所以该函数应该返回 $-1$。

【条件限制】

- $2 \leq N \leq 100 000$。
- $N - 1 \leq M \leq 200 000$。
- $0 \leq U[i] < V [i] < N$。
- 任意两个城市间至多存在一条道路直接相连。
- 任意两个城市经过道路可以互相到达。
- $1 \leq W[i] \leq 10^9$。
- $1 \leq Q \leq 200 000$。
- $0 \leq X[j] < Y [j] < N$。

【子任务 $1$（$6$ 分）】

- 每个城市至多是两条道路的一个端点。

【子任务 $2$（$7$ 分）】

- $M = N - 1$。
- $U[i] = 0$。

【子任务 $3$（$17$ 分）】

- $Q \leq 5$。
- $N \leq 1 000$。
- $M \leq 2 000$。

【子任务 $4$（$20$ 分）】

- $Q \leq 5$。

【子任务 $5$（$23$ 分）】

- $M = N - 1$。

【子任务 $6$（$27$ 分）】

- 无附加限制。



---

---
title: "[APIO2020] 有趣的旅途"
layout: "post"
diff: 省选/NOI-
pid: P6766
tag: ['2020', 'APIO', '交互题', 'Special Judge', 'O2优化']
---
# [APIO2020] 有趣的旅途
## 题目背景

由于官方数据包过大，本题仅评测部分数据。

本题仅支持 C++ 系列语言，提交时**不需要**包含 `fun.h` 头文件，但需要在程序开头声明 `int hoursRequired(int,int)` 以及 `int attractionsBehind(int,int)`。如果您不明白这是什么意思，也可以直接将 `fun.h` 中的内容粘贴到程序的开头。

交互库在程序非正常结束时可能会返回一些奇怪的信息。

如果交互库存在其他问题，请私信 mrsrz。
## 题目描述

雅加达最大的主题公园中有 $N$ 个景点，它们从 $0$ 到 $N -1$ 编号。这些景点由 $N-1$ 条双向道路连接，任意两个景点间经由这些道路将存在唯一一条简单路径。道路从 $0$ 到 $N - 2$ 编号。第 $i$ 条道路连接第 $A[i]$ 个景点与第 $B[i]$ 个景点，经过这条道路需要花费一个小时。为了避免拥塞，每个景点将至多与三条道路相连。

你想寻找一条游玩路线并使得每个景点都被参观一次。你认为从一个景点走到下一个景点时经过太多道路是十分无聊的。为了寻找一条有趣的路线，你打算安排景点的参观顺序，使得参观下一个景点所花费的时间不超过参观之前景点所花费的时间。换句话说，你想找到一个序列 $P[0], P[1],\dots, P[N - 1]$ 使其包含 $0$ 到 $N - 1$ 中的所有整数恰好一次，并且从第 $P[i]$ 个景点到达第 $P[i + 1]$ 个景点所需的时间不超过从第 $P[i - 1]$ 个景点到达第 $P[i]$ 个景点所需的时间，其中 $0 < i < N - 1$。

你手上没有景点的完整地图，因此你必须向信息中心进行若干次询问才能找到一条有趣路线。你最多能进行 $Q$ 次询问，每次询问需要提供两个参数 $X$ 和 $Y$ ，其中 $0 \leq X, Y < N$。每次询问是以下任意一种：

- 从第 $X$ 个景点到第 $Y$ 个景点需要花费多少个小时。特别地，若 $X = Y$ 则回答将是 $0$。

- 有多少个景点 $Z$ 满足，当你想从第 $X$ 个景点到达第 $Z$ 个景点时一定会经过第 $Y$ 个景点。第 $Y$ 个景点将会被计算在内，特别地，若 $X = Y$ 则回答将是 $N$。

你必须实现 `createFunTour` 函数：

- `createFunTour(N, Q)` - 该函数将被评测库恰好调用一次。
	- $N$：一个整数表示景点的数量。
	- $Q$：一个整数表示询问次数的最大值。
	- 该函数可以调用以下两个交互函数：
    	- `hoursRequired(X, Y)`
        	- $X$：一个整数表示第一个景点的编号。
			- $Y$：一个整数表示第二个景点的编号。
			- 该函数将返回一个整数表示从第 $X$ 个景点到第 $Y$ 个景点需要花费的小时数。
			- 如果 $X$ 或 $Y$ 的值不在 $0$ 到 $N - 1$ 的范围内，该测试点将视为答案错误。
		- `attractionsBehind(X, Y)`
			- $X$：一个整数表示第一个景点的编号。
            - $Y$：一个整数表示第二个景点的编号。
			- 该函数将返回一个整数表示有多少个景点 $Z$ 满足，当你想从第 $X$ 个景点到达第 $Z$ 个景点时一定会经过第 $Y$ 个景点。
			- 如果 $X$ 或 $Y$ 的值不在 $0$ 到 $N - 1$ 的范围内，该测试点将视为答案错误。
	- 该函数必须返回一个长为 $N$ 的整数序列，表示你找到的景点参观顺序。
## 输入格式

样例评测库将读入以下格式的数据：

```
N Q
A[0] B[0]
A[1] B[1]
.
.
.
A[N-2] B[N-2]
```
## 输出格式

如果 `createFunTour` 正确返回了一个满足题意的序列，并且 `hoursRequired` 和 `attractionsBehind` 的调用次数总和不超过 $Q$，那么样例评测库将会输出 `createFunTour` 得到的序列。其他情况下样例评测库将会输出错误信息
## 样例

### 样例输入 #1
```
7 400000
0 1
0 5
0 6
1 2
1 4
2 3

```
### 样例输出 #1
```
3 6 4 5 2 0 1

```
## 提示

在下图的例子中 $N = 7$，$Q = 400 000$，$A = [0, 0, 0, 1, 1, 2]$，$B = [1, 5, 6, 2, 4, 3]$。

![](https://cdn.luogu.com.cn/upload/image_hosting/j8tmoxuo.png)

评测库将调用 `createFunTour(7, 400000)`。
- 如果你询问 `hoursRequired(3, 5)`，函数将返回 $4$。
- 如果你询问 `hoursRequired(5, 4)`，函数将返回 $3$。
- 如果你询问 `attractionsBehind(5, 1)`，函数将返回 $4$。从第五个景点到第一、二、三、四个景点将一定会经过第一个景点。
- 如果你询问 `attractionsBehind(1, 5)`，函数将返回 $1$。
- 一个符合要求的返回序列为 $[3, 6, 4, 5, 2, 0, 1]$，到达下一个参观景点所需的时间按顺序分别为 $[4, 3, 3, 3, 2, 1]$。

【条件限制】

- $2 \leq N \leq 100 000$。
- $Q = 400 000$。
- 任意两个景点间可以通过双向道路互相到达。
- 每个景点至多连接着三条道路。

【子任务 $1$（$10$ 分）】

- $N \leq 17$。

【子任务 $2$（$16$ 分）】

- $N \leq 500$。

【子任务 $3$（$21$ 分）】

- 对所有的 $1 \leq i < N$，有一条连接着第 $i$ 个景点与第 $\lfloor \dfrac{i-1}{2} \rfloor$
个景点的双向道路。

【子任务 $4$（$19$ 分）】

存在至少一个景点 $T$ 使得对于所有 $0 \leq i < N$，`hoursRequired(T, i)` $<30$ 并且存在一个整数区间 $[L[i], R[i]](0 \leq L[i] \leq i \leq R[i] < N)$ 满足下列条件：

- 从第 $T$ 个景点到达第 $j$ 个景点必须经过第 $i$ 个景点当且仅当 $L[i] \leq j \leq R[i]$。

- 若 $L[i] < i$，则恰有一个景点 $X$ 满足：
	- $L[i] \leq X < i$。
	- 有一条连接第 $i$ 个景点与第 $X$ 个景点的道路。   
- 若 $i < R[i]$，则恰有一个景点 $Y$ 满足：
	- $i < Y \leq R[i]$。
	- 有一条连接第 $i$ 个景点与第 $Y$ 个景点的道路。

【子任务 $5$（$34$ 分）】
- 无附加限制。


---

---
title: "[APIO2021] 封闭道路"
layout: "post"
diff: 省选/NOI-
pid: P7600
tag: ['2021', 'APIO', '交互题', 'Special Judge', 'O2优化']
---
# [APIO2021] 封闭道路
## 题目背景

本题只支持 C++ 提交，提交时不需要包含 `roads.h` 头文件，只需要将附件中的 `roads.h` 中的内容粘贴到代码的开头即可。


## 题目描述

在泗水市，有 $N$ 个路口（编号从 $0$ 到 $N-1$）。这些路口由 $N-1$ 条双向道路连接（编号从 $0$ 到 $N-2$），因此通过这些道路，任意一对路口之间都有一条唯一的路径。$i$ 号道路（$0 \le i \le N-2$）连接着 $U[i]$ 号和 $V[i]$ 号路口。

为了提高环保意识，泗水市长 Pak Dengklek 计划举办无车日。为了鼓励该活动，Pak Dengklek 将组织封路。Pak Dengklek 将首先选择一个非负整数 $k$，然后封闭一些道路，以使每个路口只能直接连接至多 $k$ 条未封闭的道路。封闭 $i$ 号道路的成本为 $W[i]$。

请你帮助 Pak Dengklek 对每个可能的非负整数 $k$（$0 \le k \le N-1$）计算封闭道路的最低总成本。

你需要实现下列函数：

`int64[] minimum_closure_costs(int N, int[] U, int[] V, int[] W)`

- $N$：泗水市的路口数量。

- $U$ 和 $V$：大小为 $N-1$ 的数组，其中 $U[i]$ 号路口和 $V[i]$ 路口通过 $i$ 号道路直接连接。

- $W$：大小为 $N-1$ 的数组，其中封闭 $i$ 号道路的成本为 $W[i]$。

- 该函数需要返回一个大小为 $N$ 的数组。对每个 $k$（$0 \le k \le N-1$），$k$ 号元素是使得每个路口与至多 $k$ 条未封闭道路直接连接的最低总成本。

该函数将被调用恰好一次。
## 输入格式

示例测试程序按如下格式读取输入数据:

- 第 $1$ 行：$N$
- 第 $2+i$（$0 \le i \le N-2$）行：$U[i]$ $V[i]$ $W[i]$

## 输出格式

示例测试程序输出仅一行，包含一个数组，表示 `minimum_closure_costs` 的返回值。
## 样例

### 样例输入 #1
```
5
0 1 1
0 2 4
0 3 3
2 4 2

```
### 样例输出 #1
```
10 5 1 0 0

```
### 样例输入 #2
```
4
0 1 5
2 0 10
0 3 5

```
### 样例输出 #2
```
20 10 5 0

```
## 提示

## 例子

### 例子 $1$

考虑如下调用:

`minimum_closure_costs(5, [0, 0, 0, 2], [1, 2, 3, 4], [1, 4, 3, 2])`

这个例子中共有 $5$ 个路口和 $4$ 条道路，分别连接着路口 $(0,1),(0,2),(0,3)$ 和 $(2,4)$，封闭它们的成本依次为 $1,4,3$ 和 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/k3z9vmxl.png)

为了得到最低的总成本：

- 如果 Pak_Dengklek 选择 $k=0$，那么所有道路都需要封闭，总成本为 $1+4+3+2=10$；
- 如果 Pak_Dengklek 选择 $k=1$，那么需要封闭 $0$ 号道路和 $1$ 号道路，总成本为 $1+4=5$；
- 如果 Pak_Dengklek 选择 $k=2$，那么需要封闭 $0$ 号道路，总成本为 $1$；
- 如果 Pak_Dengklek 选择 $k=3$ 或 $k=4$，那么没有道路需要封闭。

因此，`minimum_closure_costs` 应该返回数组 $[10,5,1,0,0]$。

### 例子 $2$

考虑如下调用：

`minimum_closure_costs(4, [0, 2, 0], [1, 0, 3], [5, 10, 5])
`

这个例子中共有 $4$ 个路口和 $3$ 条道路，分别连接着路口 $(0,1),(2,0)$ 和 $(0,3)$，封闭它们的成本依次为 $5,10$ 和 $5$。

![](https://cdn.luogu.com.cn/upload/image_hosting/9fdtl4aj.png)

为了得到最低的总成本:

- 如果 PakDengklek 选择 $k=0$，那么所有道路都需要封闭，总成本为 $5+10+5=20$；
- 如果 PakDengklek 选择 $k=1$，那么需要封闭 $0$ 号道路和 $2$ 号道路，总成本为 $5+5=10$；
- 如果 PakDengklek 选择 $k=2$，那么需要封闭 $0$ 号道路或 $2$ 号道路，总成本为 $5$；
- 如果 PakDengklek 选择 $k=3$，那么没有道路需要封闭。

因此，minimum_closure_costs 应该返回数组 $[20,10,5,0]$。

## 约束

- $2 \le N \le 10^5$
- $0 \le U[i],V[i] \le N-1$ $(0 \le i \le N-2)$
- 任意一对路口可以通过道路互相到达。
- $1 \le W[i] \le 10^9$ $(0 \le i \le N-2)$。

## 子任务
1. (5 分) $U[i]=0$ $(0 \le i \le N-2)$
2. (7 分) $U[i]=i$，$V[i]=i+1$ $(0 \le i \le N-2)$
3. (14 分) $N \le 200$
4. (10 分) $N \le 2000$
5. (17 分) $W[i]=1$ $(0 \le i \le N-2)$
6. (25 分) $W[i] \le 10$ $(0 \le i \le N-2)$
7. (22 分) 无附加限制


---

---
title: "[APIO2022] 排列"
layout: "post"
diff: 省选/NOI-
pid: P8376
tag: ['2022', 'APIO', '交互题', 'Special Judge', 'O2优化']
---
# [APIO2022] 排列
## 题目背景

本题只支持 C++ 提交，提交时不需要包含 `perm.h` 头文件，只需要将附件中的 `perm.h` 中的内容粘贴到代码的开头即可。
## 题目描述

法老们利用行星的引力来加速飞船。假设飞船将依次以 $p[0], p[1],\dots , p[n - 1]$ 的轨道速度飞掠 $n$ 颗行星。飞掠每颗行星时，法老科学家可以选择是否利用它来加速飞船。为了节省能量，当飞船以轨道速度 $p[i]$ 飞掠一颗行星并完成加速后，它将不能再在以轨道速度 $p[j] < p[i]$ 飞掠行星时进行加速。也就是说，选择用来加速的行星构成 $p[0], p[1],\dots , p[n - 1]$ 的一个**递增子序列**。$p$ 的子序列是从 $p$ 中删除零个或多个元素得到的序列。例如，$[0]$、$[ ]$、$[0, 2]$ 和 $[0, 1, 2]$ 是 $[0, 1, 2]$ 的子序列，但 $[2, 1]$ 不是。

科学家已经确认，总共有 $k$ 种方案来选择行星对飞船进行加速，但是他们弄丢了轨道速度的记录信息（甚至包括 $n$ 的大小）。不过他们记得 $(p[0], p[1],\dots , p[n - 1])$ 是 $0, 1,\dots , n - 1$ 的一个排列。这里的排列是包含从 $0$ 到 $n - 1$ 每个整数恰好一次的序列。 你的任务是找出一个长度尽量小且符合要求的排列 $(p[0], p[1],\dots , p[n - 1])$。

你要对 $q$ 艘不同的飞船来解决该问题。对每艘飞船 $i$，你会得到一个整数 $k_i$，表示选择行星加速飞船的不同方案数。你的任务是找出长度 $n$ 足够小的轨道速度序列，使得从中恰好可以选出 $k_i$ 个轨道速度递增的行星子序列。

## 实现细节

你要实现以下函数：

```cpp
int[] construct_permutation(int64 k)
```

- $k$ 是应有的递增子序列的数量。
- 该函数要返回有 $n$ 个元素的数组，每个元素是 $0$ 到 $n - 1$ 之间（包括 $0$ 和 $n - 1$）的数。
- 返回的数组必须是恰好有 $k$ 个递增子序列的合法排列。
- 该函数总共被调用 $q$ 次。每次调用被视为一个独立的场景。
## 输入格式

评测程序示例按以下格式读取输入：

- 第 $1$ 行：$q$。
- 第 $2+i$ 行（$0\le i\le q-1$）：$k_i$。
## 输出格式

评测示例程序对每个 $k_i$ 打印一行，包含对应 `construct_permutation` 调用的返回值。如果出错则打印错误信息。
## 样例

### 样例输入 #1
```
2
3
8
```
### 样例输出 #1
```
2
1 0
3
0 1 2
```
## 提示

## 例子

### 例 $1$

考虑以下调用：

```cpp
construct_permutation(3)
```

该函数应该返回一个恰好有 $3$ 个递增子序列的排列。一种可能的答案是 $[1,0]$，它的递增子序列有 $[]$（空的子序列）、$[0]$ 和 $[1]$。

### 例 $2$

考虑以下调用：

```cpp
construct_permutation(8)
```

该函数应该返回一个恰好有 $8$ 个递增子序列的排列。一种可能的答案是 $[0,1,2]$。

## 约束条件

- $1\le q\le 100$。
- $2\le k_i\le 10^{18}$（对所有 $0\le i\le q-1$）。

## 子任务

1. （$10$ 分）$2\le k_i\le 90$（对所有 $0\le i\le q-1$）。如果你给出的所有排列长度至多为 $90$ 且结果正确，你将获得 $10$ 分，否则获得 $0$ 分。
2. （$90$ 分）没有额外的约束条件。对该子任务，令 $m$ 为你在所有场景中给出的排列的最大长度，则你的得分按下表来计算：

|条件|得分|
|:-:|:-:|
|$m\le 90$|$90$|
|$90 < m\le 120$|$90-\dfrac{m-90}{3}$|
|$120 < m\le 5000$|$80-\dfrac{m-120}{65}$|
|$m > 5000$|$0$|


---

---
title: "[APIO2023] 序列 / sequence"
layout: "post"
diff: 省选/NOI-
pid: P9371
tag: ['2023', 'APIO', '交互题', 'Special Judge', 'O2优化']
---
# [APIO2023] 序列 / sequence
## 题目背景

**由于部分 BUG，使用 C++14 (GCC9) 提交会产生编译错误，请使用 C++14 等语言进行提交。**

提交时，无需引用 `sequence.h`。你提交的代码中需要实现以下函数：

```cpp
int sequence(int N, std::vector<int> A)
```
## 题目描述

在迷人的 APIO 国，居住一位着年轻智慧的学生 Alice。Alice 对解决能挑战她数学能力的有趣问题有着永不满足的好奇心。一天，她在解决一个神秘的有关长为 $N$ 的序列 (即 $A[0], A[1], \cdots, A[N-1]$ ) 的问题时遇到了困难，她无法抗拒探索答案的诱惑力。

现在，她想要与你分享一些她的发现。不过，为了更好的理解，我们需要给出以下定义:

- 定义 $W(l, r, x)$ 为 $\sum_{i=l}^{r} \mathbb{I}[A[i]=x]$, 即 $x$ 在 $A[l] \cdots A[r]$ 中的出现次数。
- 定义一个非空整数序列 $B[0] B[1] \cdots B[k-1]$ 的中位数集合为 $S(\{B[0], B[1] \cdots B[k-1]\})$, 然后 Alice 会展示如何分步计算中位数集合:

○首先，将序列 $B[0], B[1], \ldots, B[k-1]$ 按照升序排序，令排好序的序列为 $C[0], C[1], \ldots, C[k-1]_{0}$

○ 然后, $S(\{B[0], B[1] \cdots B[k-1]\})=\left\{C\left[\left\lfloor\frac{k-1}{2}\right]\right], C\left[\left\lceil\frac{k-1}{2}\right\rceil\right]\right\}$ 。

○ 为了能更好的理解 $S$ 的计算，以下为一些例子:

- $S(\{6,3,5,4,6,2,3\})=\{4\}$.
- $S(\{4,2,3,1\})=\{2,3\}$
- $S(\{5,4,2,4\})=\{4\}$.

作为一道具有挑战性的问题, Alice 想对于所有的 $(l, r)(0 \leq l \leq r \leq N-1)$ 找到其价值 $\max _{x \in S(l, r)} W(l, r, x)$ 的最大值。其中 $S(l, r)$ 代表 $A[l] \cdots A[r]$ 导出的中位数集合（正如之前提到的 $S(A[l], \cdots, A[r])$ )。虽然 Alice 已经得到了答案，她需要核对答案的正确性，所以她找到了你，希望你能编程解决问题。

### 实现细节

你需要实现如下的过程:

```cpp
int sequence(int N, std:: vector<int> A);
```
- $N$ ：序列 $A$ 的长度。
- $A$ : 一个长度为 $N$ 的数组，即输入中提到的序列 $A$ 。
- 该函数应返回一个整数，代表所有可行 $(l, r)$ 价值的最大值。
- 这个函数恰好被调用一次。

## 输入格式

评测程序示例读取如下格式的输入:

第 $1$ 行: $N$

第 $2$ 行: $A[0] A[1] \cdots A[N-1]$
## 输出格式

评测程序示例按照如下的格式打印你的答案:

第 $1$ 行：`sequence` 的返回值。
## 样例

### 样例输入 #1
```
7
1 2 3 1 2 1 3
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
9
1 1 2 3 4 3 2 1 1
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
14
2 6 2 5 3 4 2 1 4 3 5 6 3 2
```
### 样例输出 #3
```
3
```
## 提示

### 例子

#### 样例 1

考虑如下的调用:

```cpp
sequence(7,{1,2,3,1,2,1,3});
```

函数应返回 $3$。

在这个样例中, $S(0,5)=\{1,2\}, W(0,5,1)=3 ， W(0,5,2)=2$ ，所以 $(0,5)$ 的价值为 3 。

容易验证 $(0,5)$ 在所有合法的 $(l, r)$ 二元组中有着最大的价值。

#### 样例 2

考虑如下的调用:

```cpp
sequence(9,{1,1,2,3,4,3,2,1,1});
```

函数应返回 $2$。

### 样例 3

考虑如下的调用:

```cpp
sequence(14,{2,6,2,5,3,4,2,1,4,3,5,6,3,2});
```

函数应返回 $3$。

### 约束条件

- $1 \leq N \leq 5 \times 10^{5}$
- $1 \leq A[i] \leq N$

### 子任务

1. (11 分)：$N \leq 100$ 。
2. (17 分)：$N \le 2 \times 10^{3}$ 。
3. (7 分)：存在一个 $x$ 满足 $\forall 0 \leq i<x, A[i] \leq A[i+1]$ 且 $\forall x<i<N, A[i] \leq A[i-1]$ 。
4. (12 分)：$A[i] \leq 3$ 。
5. (13 分)：$W(0, N-1, A[i]) \leq 2$ (对于所有满足 $0 \leq i \leq N-1$ 的 $i$ )。
6. (22 分)：$N \leq 8 \times 10^{4}$ 。
7. (18 分)：没有额外限制。 


---


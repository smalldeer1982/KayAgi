---
title: "[IOI 2024] 马赛克上色"
layout: "post"
diff: 省选/NOI-
pid: P11053
tag: ['2024', 'IOI', '交互题']
---
# [IOI 2024] 马赛克上色
## 题目背景

提交时请不要引用 `mosaic.h`。

请不要使用 C++14 (GCC 9) 提交。
## 题目描述

Salma 想给墙上的粘土马赛克上色。该马赛克由 $N \times N$ 片正方形瓷砖组成，共有 $N^2$ 片瓷砖；每片瓷砖的尺寸为 $1 \times 1$，都还没有上色。马赛克从上到下每行瓷砖的行编号从 $0$ 到 $N-1$，从左到右每列瓷砖的列编号从 $0$ 到 $N-1$。位于第 $i$ 行第 $j$ 列（$0 \leq i < N$，$0 \leq j < N$）的瓷砖记为 $(i,j)$。每片瓷砖要么涂成白色（记为 $0$），要么涂成黑色（记为 $1$）。

为了给马赛克上色，Salma 首先选取两个长度为 $N$ 的数组 $X$ 和 $Y$，每个数组都由 $0$ 和 $1$ 组成，并且 $X[0] = Y[0]$。她按照数组 $X$ 对最上面的行（第 $0$ 行）的瓷砖进行上色，使得瓷砖 $(0,j)$ 的颜色为 $X[j]$（$0 \leq j < N$）。她按照数组 $Y$ 对最左边的列（第 $0$ 列）的瓷砖进行上色，使得瓷砖 $(i,0)$ 的颜色为 $Y[i]$（$0 \leq i < N$）。

然后她重复以下步骤直至所有瓷砖都上色完成：
* 她找到任意一片**没有上色**的瓷砖 $(i,j)$，其上方相邻的瓷砖 $(i-1, j)$ 和左边相邻的瓷砖 $(i, j-1)$ 都**已经上色**。
* 然后，如果这两片相邻的瓷砖都是白色，她会把瓷砖 $(i,j)$ 涂成黑色；否则，涂成白色。

可以证明，瓷砖最终的颜色不依赖于 Salma 的上色顺序。

Yasmin 对马赛克瓷砖的颜色非常好奇。她向 Salma 提出 $Q$ 个问题，从 $0$ 到 $Q-1$ 编号。在问题 $k$（$0 \leq k < Q$）中，Yasmin 通过以下信息指定马赛克中的一个长方形：
* 最上面的行 $T[k]$ 和最下面的行 $B[k]$（$0 \leq T[k] \leq B[k] < N$）；
* 最左边的列 $L[k]$ 和最右边的列 $R[k]$（$0 \leq L[k] \leq R[k] < N$）。

问题的答案是该长方形中黑色瓷砖的数量。具体来说，Salma 应当找出有多少片瓷砖 $(i,j)$ 满足  $T[k] \leq i \leq B[k]$，$L[k] \leq j \leq R[k]$，且颜色为黑色。

请编写程序回答 Yasmin 的问题。

### 实现细节

你要实现以下函数。

```
std::vector<long long> mosaic(
	std::vector<int> X, std::vector<int> Y,
    std::vector<int> T, std::vector<int> B,
    std::vector<int> L, std::vector<int> R)
```

* $X$，$Y$：长度为 $N$ 的数组，分别描述最上方行和最左边列的瓷砖的颜色。
* $T$，$B$，$L$，$R$：长度为 $Q$ 的数组，分别描述 Yasmin 所提出的问题。
* 该函数应返回一个长度为 $Q$ 的数组 $C$，使得 $C[k]$ 给出问题 $k$（$0 \leq k < Q$）的答案。
* 对每个测试用例，该函数恰好被调用一次。
## 输入格式

评测程序示例读取如下格式的输入：

```
N
X[0]  X[1]  ...  X[N-1]
Y[0]  Y[1]  ...  Y[N-1]
Q
T[0]  B[0]  L[0]  R[0]
T[1]  B[1]  L[1]  R[1]
...
T[Q-1]  B[Q-1]  L[Q-1]  R[Q-1]
```
## 输出格式

评测程序示例按照如下格式打印你的答案：

```
C[0]
C[1]
...
C[S-1]
```

其中 $S$ 是  `mosaic` 所返回的数组 $C$ 的长度。
## 样例

### 样例输入 #1
```
4
1 0 1 0
1 1 0 1
2
0 3 0 3
2 3 0 2

```
### 样例输出 #1
```
7
3

```
## 提示

考虑以下函数调用。

```
mosaic([1, 0, 1, 0], [1, 1, 0, 1], [0, 2], [3, 3], [0, 0], [3, 2])
```

该例子如下图所示。左边的图展示了马赛克中瓷砖的颜色，中间和右边的图分别展示了 Yasmin 的第一个问题和第二个问题中的长方形。

![](https://cdn.luogu.com.cn/upload/image_hosting/dhy83fvl.png "550")

这两个问题的答案（即阴影长方形中 1 的个数）分别是 7 和 3。因此，函数应该返回 $[7, 3]$。

### 约束条件

* $1 \leq N \leq 200\,000$
* $1 \leq Q \leq 200\,000$
* 对所有满足  $0 \leq i < N$ 的 $i$，都有 $X[i] \in \{0, 1\}$，且 $Y[i] \in \{0, 1\}$
* $X[0] = Y[0]$
* 对所有满足 $0 \leq k < Q$ 的 $k$，都有 $0 \leq T[k] \leq B[k] < N$，且 $0 \leq L[k] \leq R[k] < N$

| 子任务 | 分数 | 额外的约束条件 |
| :-----: | :----: | ---------------------- |
| 1       | $5$    | $N \leq 2; Q \leq 10$
| 2       | $7$    | $N \leq 200; Q \leq 200$
| 3       | $7$    | 对所有满足  $0 \leq k < Q$ 的 $k$，都有 $T[k] = B[k] = 0$
| 4       | $10$   | $N \leq 5000$
| 5       | $8$    | 对所有满足 $0 \leq i < N$ 的 $i$，都有 $X[i] = Y[i] = 0$
| 6       | $22$   | 对所有满足 $0 \leq k < Q$ 的 $k$，都有 $T[k] = B[k]$，且 $L[k] = R[k]$
| 7       | $19$   | 对所有满足 $0 \leq k < Q$ 的 $k$，都有 $T[k] = B[k]$ 
| 8       | $22$   | 没有额外的约束条件。


---

---
title: "[IOI 2025] Souvenirs"
layout: "post"
diff: 省选/NOI-
pid: P13535
tag: ['2025', 'IOI', '交互题', 'Special Judge']
---
# [IOI 2025] Souvenirs
## 题目背景

**DO NOT** $\texttt{\#include "souvenirs.h"}$。

Add the following code at the beginning of your code, and **submit using $\texttt{\textcolor{red}{C++\,20}}$**.

```cpp
#include <utility>
#include <vector>
std::pair<std::vector<int>, long long> transaction(long long M);
```
## 题目描述

Amaru is buying souvenirs in a foreign shop. There are $N$ **types** of souvenirs. There are infinitely many souvenirs of each type available in the shop.

Each type of souvenir has a fixed price. Namely, a souvenir of type $i$ ($0 \leq i < N$) has a price of $P[i]$ coins, where $P[i]$ is a positive integer.

Amaru knows that souvenir types are sorted in decreasing order by price, and that the souvenir prices are distinct. Specifically, $P[0] > P[1] > \cdots > P[N - 1] > 0$. Moreover, he was able to learn the value of $P[0]$. Unfortunately, Amaru does not have any other information about the prices of the souvenirs.

To buy some souvenirs, Amaru will perform a number of transactions with the seller.

Each transaction consists of the following steps:

1. Amaru hands some (positive) number of coins to the seller.
2. The seller puts these coins in a pile on the table in the back room, where Amaru cannot see them.
3. The seller considers each souvenir type $0, 1, \ldots, N - 1$ in that order, one by one. Each type is considered **exactly once** per transaction.
    - When considering souvenir type $i$, if the current number of coins in the pile is at least $P[i]$, then
        - the seller removes $P[i]$ coins from the pile, and
        - the seller puts one souvenir of type $i$ on the table.
4. The seller gives Amaru all the coins remaining in the pile and all souvenirs on the table.

Note that there are no coins or souvenirs on the table before a transaction begins.

Your task is to instruct Amaru to perform some number of transactions, so that:

- in each transaction he buys **at least one** souvenir, and
- overall he buys **exactly** $i$ souvenirs of type $i$, for each $i$ such that $0 \leq i < N$. Note that this means that Amaru should not buy any souvenir of type $0$.

Amaru does not have to minimize the number of transactions and has an unlimited supply of coins.

### Implementation Details

You should implement the following procedure.

```
void buy_souvenirs(int N, long long P0)
```

- $N$: the number of souvenir types.
- $P0$: the value of $P[0]$.
- This procedure is called exactly once for each test case.

The above procedure can make calls to the following procedure to instruct Amaru to perform a transaction:

```
std::pair<std::vector<int>, long long> transaction(long long M)
```

- $M$: the number of coins handed to the seller by Amaru.
- The procedure returns a pair. The first element of the pair is an array $L$, containing the types of souvenirs that have been bought (in increasing order). The second element is an integer $R$, the number of coins returned to Amaru after the transaction.
- It is required that $P[0] > M \geq P[N - 1]$. The condition $P[0] > M$ ensures that Amaru does not buy any souvenir of type 0, and $M \geq P[N - 1]$ ensures that Amaru buys at least one souvenir. If these conditions are not met, your solution will receive the verdict Output isn't correct: Invalid argument. Note that contrary to $P[0]$, the value of $P[N - 1]$ is not provided in the input.
- The procedure can be called at most 5000 times in each test case.

The behavior of the grader is **not adaptive**. This means that the sequence of prices $P$ is fixed before buy\_souvenirs is called.
## 输入格式

```
N
P[0] P[1] ... P[N-1]
```
## 输出格式

```
Q[0] Q[1] ... Q[N-1]
```

Here $Q[i]$ is the number of souvenirs of type $i$ bought in total for each $i$ such that $0 \leq i < N$.
## 样例

### 样例输入 #1
```
3
4 3 1
```
### 样例输出 #1
```
0 1 2
```
## 提示

### Example

Consider the following call.

```
buy_souvenirs(3, 4)
```

There are $N = 3$ types of souvenirs and $P[0] = 4$. Observe that there are only three possible sequences of prices $P$: $[4, 3, 2]$, $[4, 3, 1]$, and $[4, 2, 1]$.

Assume that buy_souvenirs calls `transaction(2)`. Suppose the call returns $([2],1)$, meaning that Amaru bought one souvenir of type 2 and the seller gave him back 1 coin. Observe that this allows us to deduce that $P = [4,3,1]$, since:
- For $P = [4,3,2]$, `transaction(2)` would have returned $([2],0)$.
- For $P = [4,2,1]$, `transaction(2)` would have returned $([1],0)$.

Then `buy_souvenirs` can call `transaction(3)`, which returns $([1],0)$, meaning that Amaru bought one souvenir of type 1 and the seller gave him back 0 coins. So far, in total, he has bought one souvenir of type 1 and one souvenir of type 2.

Finally, `buy_souvenirs` can call `transaction(1)`, which returns $([2],0)$, meaning that Amaru bought one souvenir of type 2. Note that we could have also used `transaction(2)` here. At this point, in total Amaru has one souvenir of type 1 and two souvenirs of type 2, as required.

### Constraints

- $2 \leq N \leq 100$
- $1 \leq P[i] \leq 10^{15}$ for each $i$ such that $0 \leq i < N$.
- $P[i] > P[i + 1]$ for each $i$ such that $0 \leq i < N - 1$.

### Subtasks

| Subtask | Score | Additional Constraints |
| :-: | :-: | :-: |
| 1 | 4 | $N=2$ |
| 2 | 3 | $P[i]=N-i$ for each $i$ such that $0 \leq i < N$. |
| 3 | 14 | $P[i] \leq P[i+1] + 2$ for each $i$ such that $0 \leq i < N-1$. |
| 4 | 18 | $N=3$ |
| 5 | 28 | $P[i+1] + P[i+2] \leq P[i]$ for each $i$ such that $0 \leq i < N-2$. $P[i] \leq 2 \cdot P[i+1]$ for each $i$ such that $0 \leq i < N-1$. |
| 6 | 33 | No additional constraints. |



---

---
title: "[IOI 2025] 神话三峰（triples）（Part 1）"
layout: "post"
diff: 省选/NOI-
pid: P13536
tag: ['2025', 'IOI', '交互题']
---
# [IOI 2025] 神话三峰（triples）（Part 1）
## 题目背景

本题目前可以评测子问题 1。可在 [P13553](https://www.luogu.com.cn/problem/P13553) 评测子问题 2。
## 题目描述

东科迪勒拉山脉是安第斯山脉跨越玻利维亚的部分。它由连续的 $N$ 座山峰组成，从 $0$ 到 $N - 1$编号。山峰 $i$（$0 \leq i < N$）的**高度** $H[i]$  是 $1$ 到 $N - 1$ 之间的整数。

对任意两座山峰 $i$ 和 $j$（其中 $0 \le i < j < N$），它们的**距离**定义为 $d(i, j) = j - i$。根据古老的印加传说，三座山峰是**神话**三峰的条件是：它们的高度与两两之间的距离在**忽略顺序**后**匹配**。

形式化地， $(i, j, k)$ 是神话三峰的条件为：
* $0 \leq i < j < k < N$，
* 山峰高度 $(H[i], H[j], H[k])$ 与两两之间的距离 $(d(i,j), d(i,k), d(j,k))$ 在忽略顺序后匹配。例如，对山峰 $0, 1, 2$，其两两之间的距离是 $(1, 2, 1)$，所以山峰高度 $(H[0],H[1],H[2]) = (1,1,2)$， $(H[0],H[1],H[2]) = (1,2,1)$ 和 $(H[0],H[1],H[2]) = (2,1,1)$ 都匹配，但山峰高度 $(1,2,2)$ 则不匹配。

该问题分为两个部分，分别对应**子问题一**或者**子问题二**。你可以按任意顺序解决这些子问题。特别地，你**无需**先完成子问题一再尝试子问题二。

### 子问题一

给定山脉的描述，你的任务是计算神话三峰的数量。

#### 实现细节

你要实现以下函数：

```
long long count_triples(std::vector<int> H)
``` 

* $H$: 长度为 $N$ 的数组，表示每座山峰的高度。
* 对每个测试用例，该函数恰好被调用一次。

该函数返回一个整数 $T$，表示山脉中神话三峰的数量。

### 子问题二

你的任务是构造包含尽量多神话三峰的山脉。该子问题包含 $6$ 个有**部分得分**的**提交答案**的子任务。

对每个子任务，你将获得两个正整数 $M$ 和 $K$，需要构造一个**最多包含** $M$ 座山峰的山脉。如果你的答案中包含**至少** $K$ 个神话三峰，你将获得该子任务的满分。否则，你的得分将与你的答案中所包含的神话三峰的数量成正比。

注意，你的答案必须是一个有效的山脉。具体来说，假设你的答案包含 $N$ 座山峰（$N$ 必须满足 $3 \leq N \leq M$）。那么，山峰 $i$ 的高度 $H[i]$（$0 \leq i < N$）必须是一个 $1$ 到 $N - 1$ 之间的整数。

#### 实现细节

有两种提交解答的方法，你可以为每个子任务选择其中一种：
* **输出文件**
* **函数调用**

通过**输出文件**提交解答时，请创建并提交一个格式如下的文本文件：
```
N
H[0] H[1] ... H[N-1]
```

通过**函数调用**提交解答时，你需要实现以下函数。

```
std::vector<int> construct_range(int M, int K)
```

* $M$: 最多允许的山峰数量。
* $K$: 期望的神话三峰数量。
* 对每个测试用例，该函数恰好被调用一次。

该函数应返回一个长度为 $N$ 的数组 $H$，表示每座山峰的高度。
## 输入格式

子问题一和二使用相同的评测程序示例，两个子问题的区别由输入的第一行确定。

子问题一的输入格式：

```
1
N
H[0] H[1] ... H[N-1]
```

子问题二的输入格式：

```
2
M K
```
## 输出格式

子问题一的输出格式：
```
T
```

子问题二的输出格式：

```
N
H[0] H[1] ... H[N-1]
```

注意，评测程序示例的输出格式与子问题二输出文件所需的格式一致。
## 样例

### 样例输入 #1
```
1
7
4 1 4 3 2 6 1
```
### 样例输出 #1
```
3
```
## 提示

### 子问题 1 例子

考虑以下调用。

```
count_triples([4, 1, 4, 3, 2, 6, 1])
```

该山脉中包含 $3$ 个神话三峰：

* 对 $(i,j,k)=(1,3,4)$，高度 $(1,3,2)$ 与两两之间的距离 $(2,3,1)$ 匹配。
* 对 $(i,j,k)=(2,3,6)$，高度 $(4,3,1)$ 与两两之间的距离 $(1,4,3)$ 匹配。
* 对 $(i,j,k)=(3,4,6)$，高度 $(3,2,1)$ 与两两之间的距离 $(1,3,2)$ 匹配。

因此，该函数应该返回 $3$。

注意，$(0, 2, 4)$ 不构成神话三峰，因为其高度 $(4,4,2)$ 与两两之间的距离 $(2,4,2)$ 并不匹配。

### 子问题 1 数据范围

- $3 \leq N \leq 200\,000$。
- 对每个满足 $0 \le i < N$ 的 $i$，都有 $1 \leq H[i] \leq N-1$。

### 子任务与得分规则

子问题一总共 $70$ 分。

| 子任务 | 分数 | 额外的约束条件 |
| :-----: | :----: | ---------------------- |
| 1       | $8$    | $N \leq 100$
| 2       | $6$    | 对每个满足 $0 \leq i < N$ 的 $i$，都有 $H[i] \leq 10$。
| 3       | $10$   | $N \leq 2000$
| 4       | $11$   | 山峰的高度是单调不下降的。  也就是说，对每个满足 $1 \leq i < N$ 的 $i$ 都有 $H[i - 1] \leq H[i]$。
| 5       | $16$   | $N \leq 50\,000$
| 6       | $19$   | 没有额外的约束条件。

子问题二总共 $30$ 分。
每个子任务的 $M$ 和 $K$ 值是固定的，如下表所示：


| 子任务 | 分数 | $M$        | $K$             |
| :-----: | :---: | :--------: | :-------------: |
| 7       | $5$   | $20$       | $30$
| 8       | $5$   | $500$      | $2000$
| 9       | $5$   | $5000$     | $50\,000$
| 10      | $5$   | $30\,000$  | $700\,000$
| 11      | $5$   | $100\,000$ | $2\,000\,000$
| 12      | $5$   | $200\,000$ | $12\,000\,000$

对每个子任务，如果你的答案不构成有效的山脉，你的得分将为 $0$（在 CMS 中被报告为 `Output isn't correct`）。否则，设 $T$ 表示答案中的神话三峰数量。
则你在该子任务中的得分为：
$$5 \cdot \min\left(1,\frac{T}{K}\right)$$


---

---
title: "[USACO5.5] 贰五语言Two Five"
layout: "post"
diff: 省选/NOI-
pid: P2750
tag: ['动态规划 DP', '2001', 'USACO', 'IOI', '深度优先搜索 DFS']
---
# [USACO5.5] 贰五语言Two Five
## 题目描述

有一种奇怪的语言叫做“贰五语言”。它的每个单词都由A～Y这25个字母各一个组成。但是，并不是任何一种排列都是一个合法的贰五语言单词。贰五语言的单词必须满足这样一个条件：把它的25个字母排成一个5\*5的矩阵，它的每一行和每一列都必须是递增的。比如单词ACEPTBDHQUFJMRWGKNSXILOVY，它排成的矩阵如下所示：

A C E P T

B D H Q U

F J M R W

G K N S X

I L O V Y

因为它的每行每列都是递增的，所以它是一个合法的单词。而单词YXWVUTSRQPONMLKJIHGFEDCBA则显然不合法。 由于单词太长存储不便，需要给每一个单词编一个码。编码方法如下：从左到右，再从上到下，可以由一个矩阵的得到一个单词，再把单词按照字典顺序排序。比如，单词ABCDEFGHIJKLMNOPQRSTUVWXY的编码为1，而单词ABCDEFGHIJKLMNOPQRSUTVWXY的编码为2。

现在，你需要编一个程序，完成单词与编码间的转换。

## 输入格式

第一行为一个字母N或W。N表示把编码转换为单词，W表示把单词转换为编码。

若第一行为N，则第二行为一个整数，表示单词的编码。若第一行为W，则第二行为一个合法的单词。

## 输出格式

每行一个整数或单词。

## 样例

### 样例输入 #1
```
N
2
```
### 样例输出 #1
```
ABCDEFGHIJKLMNOPQRSUTVWXY
```
### 样例输入 #2
```
W 
ABCDEFGHIJKLMNOPQRSUTVWXY
```
### 样例输出 #2
```
2
```
## 提示

题目翻译来自NOCOW。

USACO Training Section 5.5



---

---
title: "[IOI 2005] Riv 河流"
layout: "post"
diff: 省选/NOI-
pid: P3354
tag: ['动态规划 DP', '2005', 'IOI']
---
# [IOI 2005] Riv 河流
## 题目描述

几乎整个 Byteland 王国都被森林和河流所覆盖。小点的河汇聚到一起，形成了稍大点的河。就这样，所有的河水都汇聚并流进了一条大河，最后这条大河流进了大海。这条大河的入海口处有一个村庄——名叫 Bytetown。

在 Byteland 国，有 $n$ 个伐木的村庄，这些村庄都座落在河边。目前在 Bytetown，有一个巨大的伐木场，它处理着全国砍下的所有木料。木料被砍下后，顺着河流而被运到 Bytetown 的伐木场。Byteland 的国王决定，为了减少运输木料的费用，再额外地建造 $k$ 个伐木场。这 $k$ 个伐木场将被建在其他村庄里。这些伐木场建造后，木料就不用都被送到 Bytetown 了，它们可以在运输过程中第一个碰到的新伐木场被处理。显然，如果伐木场座落的那个村子就不用再付运送木料的费用了。它们可以直接被本村的伐木场处理。

注：所有的河流都不会分叉，形成一棵树，根结点是 Bytetown。

国王的大臣计算出了每个村子每年要产多少木料，你的任务是决定在哪些村子建设伐木场能获得最小的运费。其中运费的计算方法为：每一吨木料每千米 $1$ 分钱。
## 输入格式

第一行包括两个整数 $n,k$。$n$ 为村庄数，$k$ 为要建的伐木场的数目。除了 Bytetown 外，每个村子依次被命名为 $1,2,3\ldots n$，Bytetown 被命名为 $0$。

第 $2$ 到第 $(n + 1)$ 行，每行 $3$ 个整数，第 $(i + 1)$ 行的整数分别代表，分别表示每年 $i$ 村子产的木料的块数 $w_i$，离 $i$ 村子下游最近的村子 $v_i$（即 $i$ 村子的父结点），$v_i$ 到 $i$ 的距离 $d_i$（千米）。
## 输出格式

输出最小花费，单位为分。

## 样例

### 样例输入 #1
```
4 2
1 0 1
1 1 10
10 2 5
1 2 3
```
### 样例输出 #1
```
4
```
## 提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，保证 $n\le 20$。
- 对于 $100\%$ 的数据，保证 $2\le n\le 100$，$1\le k\le \min(n,50)$，$0\le v_i\le n$，$0\le w_i\le 10^4$，$1\le d_i\le 10^4$。
- 保证每年所有的木料流到 bytetown 的运费不超过 $2\times 10^9$ 分。


---

---
title: "[IOI 2017] The Big Prize"
layout: "post"
diff: 省选/NOI-
pid: P3839
tag: ['2017', '线段树', '二分', 'IOI', '交互题', 'Special Judge', '分块']
---
# [IOI 2017] The Big Prize
## 题目背景

这里是洛谷。如果有疑问，可以发帖求助。

如果你习惯于写函数式交互，以下内容可能对你有帮助：

```cpp
vector<int>ask(int i)
{
	printf("? %d\n",i);fflush(stdout);
	vector<int>ret(2);
	scanf("%d%d",&ret[0],&ret[1]);
	return ret;
}
int find_best(int n)
{
	//
}
main()
{
	int n;scanf("%d",&n);
	printf("! %d\n",find_best(n));
}
```

无论如何，你都不应引入额外的头文件。
## 题目描述

“大奖”是一个家喻户晓的 TV 游戏节目。这次你很幸运地进入到最后一轮。已知编号从 $0$ 到 $n-1$ 的 $n$ 个盒子从左到右排成一行，你就站在这排盒子的前面。每个盒子里面放有一个奖品，必须打开盒子才能看到是什么奖品。已知有 $v\leq5$ 种不同类型的奖品。这 $v$ 种类型按照奖品价值的降序从 $1$ 到 $v$ 排列。

类型 $1$ 的奖品是一块钻石，价值最高。所有盒子加起来刚好只有一块钻石。类型 $v$ 的奖品是一块棒棒糖，价值最低。为使得游戏更加激动人心，相对便宜的奖品数量远比价值昂贵的奖品数量要多。更具体一点，对于满足 $2\leq t \leq v$ 的所有 $t$，我们有： 如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。

你的目标是赢得那块钻石。在游戏结束时，你必须打开一个盒子并收取盒子内的奖品。在选择要打开的盒子之前，你可以向节目主持人 Rambod 提一些问题。在每一个问题中，你选择就某个 $i$ 号盒子进行提问。Rambod 将给你一个包含两个整数的数组 $a$ 作为回答。这两个整数的意义如下：

- 在 $i$ 号盒子左面的盒子中，刚好有 $a[0]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。
- 在 $i$ 号盒子右面的盒子中，刚好有 $a[1]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。

例如，假设 $n=8$，在你的问题中，你选择就 $i=2$ 号盒子进行提问。Rambod 的回答是 $a=[1,2]$。这个回答的意义是：

- $0$ 号盒子和 $1$ 号盒子中恰好有一个盒子中的奖品比 $i$ 号盒子中的奖品更贵。
- 在 $3,4,\cdots,7$ 号盒子中恰好有 $2$ 个盒子中的奖品比 $2$ 号盒子中的奖品更贵。

你的任务就是通过问少量的问题找出包含钻石的盒子。
## 输入格式

你的程序开始运行时，应当读入一个正整数 $n$。

你可以按以下格式发起询问：

- `? i`  
	意为你选择就 $i$ 号盒子进行提问。你需要保证 $0\leq i<n$。  
	随后你应当读入两个整数 `a[0] a[1]`，是交互库对你的回答。

你可以按以下格式报告答案：

- `! i`  
	意为你确定 $i$ 号盒子内有钻石。  
    随后你应当立刻结束你的程序。
## 输出格式

在发起询问后，不要忘记刷新缓冲区。你可以使用：

- `fflush(stdout)` or `cout.flush()` in C++;
- `stdout.flush()` in Python;  
- 对于其他语言，参阅其文档。
## 样例

### 样例输入 #1
```
8

0 3

0 1

1 2

0 0

2 1

2 1

1 0

3 0
```
### 样例输出 #1
```

? 0

? 1

? 2

? 3

? 4

? 5

? 6

? 7

! 3
```
## 提示

### 样例解释

```plain
8
3 2 3 1 3 3 2 3
```

![](https://cdn.luogu.com.cn/upload/pic/6728.png)

上图阐释了这个例子。图中上半部分给出了每个盒子中奖品的类型。图中的下半部分阐释了询问 `? 2`。

### 限制

- $3\leq n \leq200000$.
- 每个盒子中奖品的类型介于 $1$ 和 $v$ 之间（含）。
- 类型 $1$ 的奖品恰有一个。
- 对于所有 $2\leq t \leq v$，如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。


### 子任务与评分

1.  （$20$ 分）恰好有 $1$ 个钻石和 $n-1$ 个棒棒糖 （所以，$v=2$）。你可以询问最多 $10000$ 次。
2.  （$80$ 分）没有附加限制。


在子任务 2 中你可以获得部分分。令 $q$ 是在这个子任务的所有测试数据上发起询问的最大次数，那么你在这个子任务上的得分将按照下表计算：

![](https://cdn.luogu.com.cn/upload/pic/6729.png)


---

---
title: "[IOI 2011] Race"
layout: "post"
diff: 省选/NOI-
pid: P4149
tag: ['2011', '点分治', '递归', 'IOI', 'O2优化', '分治']
---
# [IOI 2011] Race
## 题目描述

给一棵树，每条边有权。求一条简单路径，权值和等于 $k$，且边的数量最小。
## 输入格式

第一行包含两个整数 $n,k$，表示树的大小与要求找到的路径的边权和。

接下来 $n-1$ 行，每行三个整数 $u_i,v_i,w_i$，代表有一条连接 $u_i$ 与 $v_i$，边权为 $w_i$ 的无向边。

**注意：点从 $0$ 开始编号**。
## 输出格式

输出一个整数，表示最小边数量。

如果不存在这样的路径，输出 $-1$。
## 样例

### 样例输入 #1
```
4 3
0 1 1
1 2 2
1 3 4
```
### 样例输出 #1
```
2
```
## 提示

对于 $100\%$ 的数据，保证 $1\leq n\leq 2\times10^5$，$0\leq k,w_i\leq 10^6$，$0\leq u_i,v_i<n$。


---

---
title: "[IOI 2007] flood 洪水"
layout: "post"
diff: 省选/NOI-
pid: P4646
tag: ['2007', 'IOI', 'Special Judge']
---
# [IOI 2007] flood 洪水
## 题目描述

1964年的一场灾难性的洪水冲毁了萨格勒布城。洪水袭来时许多建筑的墙被彻底冲毁。在这个题目中，给定了城市在洪水来袭前的简化模型，你的任务是确定洪水过后哪些墙没有被冲毁。

简化模型由平面上的$N$个点和$W$堵墙构成。每堵墙连接两个点，没有任何一堵墙通过其它点。模型具有如下性质：

- 不存在两堵墙相交或者重合的情况，但是两堵墙可以在端点相连；
- 每堵墙或者平行于坐标系的横轴，或者平行于坐标系的纵轴。

最开始，整个坐标平面都是干的。在零时刻，洪水将城市的外围淹没（城市的外围是指没有被墙围起来的区域）。一个小时之后，所有一边是水，一边是空气的墙在水的压力下都会倒塌。于是洪水又会吞没那些没有被完好的墙围住的区域。接下来又有一些墙面临一边是水一边是空气，将要被洪水冲毁的局面。又过了一个小时，这些墙也被冲毁了。这样的过程不断重复，直到洪水淹没整个城市。

下图给出了洪水侵袭过程的一个例子。

![](https://cdn.luogu.com.cn/upload/pic/20664.png )

给定$N$个点的坐标和连接这些点的$W$堵墙的描述，编程确定洪水过后，哪些墙会被留下来。 
## 输入格式

输入的第一行包含一个整数$N(2 \leq N \leq 100 000)$, 表示平面上的点的个数。 接下来的$N$行每行包含两个整数$X$和$Y$（都是$0$到$1 000 000$之间（包括$0$和$1 000 000$）的整数），表示点的坐标。所有点按照它们被给出的顺序编号为$1$到$N$。没有两个点在同一位置上。 接下来一行包含一个整数$W(1 \leq W \leq 2N)$，表示墙的数目。 接下来$W$行每行包含两个不同的整数$A$和$B(1 \leq A \leq N, 1 \leq B \leq N)$，表示在洪水到来前，有一堵墙连接$A$和$B$。这些墙按照它们被给出的顺序编号为$1$到$W$。
## 输出格式

输出的第一行包含一个整数$K$，表示洪水过后留下的墙的数目。

接下来的$K$行包含留下的墙的序号，每行一个，序号可以以任意顺序输出。
## 样例

### 样例输入 #1
```
15 
1 1 
8 1 
4 2 
7 2 
2 3 
4 3 
6 3 
2 5 
4 5 
6 5 
4 6 
7 6 
1 8 
4 8 
8 8 
17 
1 2 
2 15 
15 14 
14 13 
13 1 
14 11 
11 12 
12 4 
4 3 
3 6 
6 5 
5 8 
8 9 
9 11 
9 10 
10 7 
7 6 
```
### 样例输出 #1
```
4 
6 
15 
16 
17 
```
## 提示

这个样例对应前页图中的例子。

有40分的测试点，所有坐标小于等于$500$。

在上面的测试点和另外15分的测试点中，点的个数不超过$500$个。


---

---
title: "[IOI 2007] sails 船帆"
layout: "post"
diff: 省选/NOI-
pid: P4647
tag: ['2007', 'IOI']
---
# [IOI 2007] sails 船帆
## 题目描述

让我们来建造一艘新的海盗船。船上有 N个旗杆，每根旗杆被分成单位长度的小节。旗杆的长度等于它被分成的小节的数目。每根旗杆上会挂一些帆，每张帆正好占据旗杆上的一个小节。在一根旗杆上的帆可以任意排布在不同的小节中，但是每个小节上至多能挂一张帆。

在风中，帆的不同排布方式会产生不同的推动力。靠近船头的帆比它后面的相同高度上的帆获得的推动力少，换句话说，靠近船头的帆的推动力由于受它后面相同高度的帆的影响而打了折扣。对于任意一张帆，它的推动力折扣等于在它后面并且和它在同一高度的帆的数目。

所有帆的任意一种位置组合的推动力折扣总和等于在该位置下所有帆的推动力折扣的总和。

![](https://cdn.luogu.com.cn/upload/pic/20670.png )

这条船上有6个旗杆，从前（图上的左边）到后的高度分别是3，5，4，2，4和3。图中所示的帆的位置组合的总推动力折扣是10。上图给出了每张帆自己的推动力折扣。

给定N个旗杆的高度和每个旗杆上挂的帆的数目，写一个程序求出所有位置组合中的可能达到的最小的总推动力折扣。 
## 输入格式

第一行包含一个整数$N(2 \leq N \leq 100 000)$，表示旗杆的数目。 接下来的N行每行包含两个整数$H$和$K(1 \leq H \leq 100 000, 1 \leq K \leq H)$，分别表示对应旗杆的高度及其上的帆的数目。旗杆按照从船头到船尾的顺序给出。 
## 输出格式

输出包含一个整数，表示可以达到的最小的总推动力折扣。

注意：计算和输出结果时使用64位整数类型（在C/C++中用```long long```, 在Pascal中用```int64```）。
## 样例

### 样例输入 #1
```
6 
3 2 
5 3 
4 1 
2 1 
4 3 
3 2 
```
### 样例输出 #1
```
10
```
## 提示

这个样例数据和上页中图示的样例相同。

在 25 分的测试数据中，帆的不同位置组合的总数目不超过 $1,000,000$ 。


---

---
title: "[IOI 2007] pairs 动物对数"
layout: "post"
diff: 省选/NOI-
pid: P4648
tag: ['2007', '树状数组', 'IOI', '枚举', '前缀和']
---
# [IOI 2007] pairs 动物对数
## 题目描述

Mirko 和 Slavko 正在玩动物玩具的游戏。 首先，他们要在下图给出的三种玩具模板中选择一种。三种模板分别由一维、二维和三维的网格点（在图中用圆圈表示）组成。 

![](https://cdn.luogu.com.cn/upload/pic/20672.png )

接下来Mirko 把 $N$ 个小动物玩具放到选中的模板的网格点上。

动物玩具可以走一步到达与它相邻的网格点上（在图中相邻的点之间有一条小短线相连）。两个网格点之间的距离定义为**从一个网格点到另一个网格点所需要移动的最小步数**。

如果两个动物之间的距离小于等于$D$，则它们之间可以互相听见。Slavko 的任务是计算在模板上有多少对动物可以互相听得见。

给定模板的类型、所有动物的位置以及数字$D$，写一个程序计算有多少对动物可以互相听得见。 
## 输入格式

输入的第一行按顺序给出四个整数： 
- 模板类型 $B (1 \leq B \leq 3)$; 
- 玩具动物的数目 $N (1 \leq N \leq 100 000)$; 
- 动物之间可以互相听得见的最大距离$D (1 \leq D \leq 100 000 000)$; 
- 模板的大小 $M$ ( 即在输入中允许的最大的坐标值):  当 $B=1$ 时, $M$ 最大是 $75 000 000$. 当 $B=2$时, $M$ 最大是 $75 000$. 当 $B=3$时, $M$ 最大是 $75$.

接下来的$N$ 行每行包含$B$ 个整数，整数之间用空格隔开，表示一个动物玩具的坐标。坐标的取值范围是$1$ 到 $M$ ( 包括$M$ )。

每个网格点可以同时包含多个动物玩具。 
## 输出格式

输出应该包括一个整数，表示可以互相听得见的玩具动物的对数。

注意：使用64 位整数类型计算和输出结果 (在 C/C++ 中用```long long```, 在Pascal 中用```int64``` ) 。 
## 样例

### 样例输入 #1
```
1 6 5 100 
25 
50 
50 
10 
20 
23 
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
2 5 4 10 
5 2 
7 2 
8 4 
6 5 
4 4 
```
### 样例输出 #2
```
8
```
### 样例输入 #3
```
3 8 10 20 
10 10 10 
10 10 20 
10 20 10 
10 20 20 
20 10 10 
20 10 20 
20 20 10 
20 20 20 
```
### 样例输出 #3
```
12
```
## 提示

在30分的测试数据中, 动物数目 $N$ 最多是 $1 000$。

如果成功通过了某一种模板（一维、二维或者三维）的全部测试数据，将会得到至少30分。

对于input 1的解释： 假设动物按给出的顺序编号为$1$到$6$。$4$对互相能够听得到的动物分别是:
- 1-5 ( 距离是5)
- 1-6 ( 距离是2)
- 2-3 ( 距离是0)
- 5-6 ( 距离是3)

对于input 2 的解释：$8$对动物分别是:
- 1-2 ( 距离是2)
- 1-4 ( 距离是4)
- 1-5 ( 距离是3)
- 2-3 ( 距离是3)
- 2-4 ( 距离是4)
- 3-4 ( 距离是3)
- 3-5 ( 距离是4)
- 4-5 ( 距离是3)


---

---
title: "[IOI 2007] training 训练路径 "
layout: "post"
diff: 省选/NOI-
pid: P4649
tag: ['动态规划 DP', '2007', 'IOI', '仙人掌', '最近公共祖先 LCA']
---
# [IOI 2007] training 训练路径 
## 题目描述

马克(Mirko)和斯拉夫克(Slavko)正在为克罗地亚举办的每年一次的双人骑车马拉松赛而紧张训练。他们需要选择一条训练路径。

他们国家有$N$个城市和$M$条道路。每条道路连接两个城市。这些道路中恰好有$N-1$条是铺设好的道路，其余道路是未经铺设的土路。幸运的是，每两个城市之间都存在一条由铺设好的道路组成的通路。换句话说，这$N$个城市和$N-1$条铺设好的道路构成一个树状结构。

此外，每个城市最多是$10$条道路的端点。

一条训练路径由某个城市开始，途经一些道路后在原来起始的城市结束。因为马克和斯拉夫克喜欢去看新城市，所以他们制定了一条规则：绝不中途穿越已经去过的城市，并且绝不在相同的道路上骑行两次（不管方向是否相同）。训练路径可以从任何一个城市开始，并且不需要访问所有城市。

显然，坐在后座的骑行者更为轻松，因为坐在前面的可以为他挡风。为此，马克和斯拉夫克在每个城市都要调换位置。为了保证他们的训练强度相同，他们要选择一条具有偶数条道路的路径。

马克和斯拉夫克的竞争者决定在某些未经铺设的土路上设置路障，使得他们两人不可能找到满足上述要求的训练路径。已知在每条土路上设置路障都有一个费用值（一个正整数），并且竞争者不能在铺设好的道路上设置路障。

给定城市和道路网的描述，写一个程序计算出为了使得满足上述要求的训练路径不存在，而需要的设置路障的最小总费用。
## 输入格式

输入的第一行包含两个整数$N$和$M$，（$2\leq N\leq 1000$，$N-1\leq M\leq5000$），分别表示城市和道路的个数。 接下来的$M$行每行包含$3$个整数$A, B$和$C$（$1\leq A\leq N, 1\leq B\leq N, 0\leq C\leq10 000$）, 用来描述一条道路。$A$和$B$是不同的整数，表示由这条道路直接相连的两个城市。对于铺设好的道路$C$是$0$；对于土路，$C$是在该条路上设置路障所需的费用值。 每个城市最多是$10$条道路的端点。任意两个城市都不会有多于一条直接相连的道路。 
## 输出格式

输出包含一个整数，表示求出的最小总费用。
## 样例

### 样例输入 #1
```
5 8 
2 1 0 
3 2 0 
4 3 0 
5 4 0 
1 3 2 
3 5 2 
2 4 5 
2 5 1 
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
9 14 
1 2 0 
1 3 0 
2 3 14 
2 6 15 
3 4 0 
3 5 0 
3 6 12 
3 7 13 
4 6 10 
5 6 0 
5 7 0 
5 8 0 
6 9 11 
8 9 0 
```
### 样例输出 #2
```
48
```
## 提示

![](https://cdn.luogu.com.cn/upload/pic/20676.png )

第一个样例中道路与城市的布置。已被铺设好的道路以粗边显示。

![](https://cdn.luogu.com.cn/upload/pic/20677.png )

共有5种可能的路线。如果边1-3、3-5和2-5被封锁，则两人将会不能使用5种路线的任何一种。封锁这三条边的代价是5。

只封锁两条边，像是2-4和2-5，也是可以的，但这样会导致较高的代价，6。

在前30分的测试数据中，铺设好的道路会形成一条链。


---

---
title: "[IOI 2008] Fish"
layout: "post"
diff: 省选/NOI-
pid: P4684
tag: ['2008', 'IOI']
---
# [IOI 2008] Fish
## 题目描述

据Scheherazade说，在很远的沙漠中有一个湖。湖中起初有$F$条鱼。选择最值钱的$K$种宝石，对$F$条鱼的每一条只喂给它一块宝石。注意，因为$K$可能小于$F$，两条或更多的鱼可能会吞下同一种宝石。

随着时间的流逝，有些鱼吃掉了别的鱼。一条鱼能够吃掉另一条鱼，当且仅当它的长度至少是被吃掉的鱼的两倍($A$ 能吃掉$B$ 当且仅当$L_A \geq 2L_B$)。没有规则说明一条鱼何时会吃掉另一条鱼。有的鱼可能会一条接一条地吃掉几条小鱼，而有的鱼可能不吃别的鱼，即使它们有能力吃。当一条鱼吃掉一条小鱼时，它的身长并不改变，但是小鱼腹中的宝石会完好无损地进到大鱼腹中。

据Scheherazade说，如果你能够找到那个湖，你会被准许捕捉一条鱼，并且得到鱼腹中的宝石。你很想试试运气，但是在出发前很想知道捉到一条鱼可能会有多少种不同的宝石组合。

写一个程序，给定每条鱼的长度以及其最初吞食的宝石的种类，找出鱼腹中宝石不同组合的数量对给定整数$M$取模的值。组合由每种宝石的数量定义，与宝石的排列顺序无关。同一类宝石中任意两块是没有区别的。 
## 输入格式

你的程序需要从标准输入上读入下列数据：
- 第一行是整数$F$, 即湖中最初鱼的数量。
- 第二行是整数$K$, 即宝石的种类数。不同类型的宝石分别用从 $1$ 到 $K$的整数表示。 
- 第三行是整数$M$。 
- 以后 $F$ 行中的每一行用由一个空格分隔的两个整数描述一条鱼：按顺序分别是鱼的长度以及鱼腹中的宝石的类型。

注意: 在所有的测试用例中，$K$ 种宝石中的每一种都会至少有一块。 
## 输出格式

你的程序需要在标准输出上输出一个介于$0$和$M-1$(包含)的整数，即宝石所有可能的不同组合数量模$M$，占一行。注意，在问题求解中，数值$M$除了简化计算外没有其他的作用。
## 样例

### 样例输入 #1
```
5
3
7
2 2
5 1
8 3
4 1
2 3

```
### 样例输出 #1
```
4
```
## 提示

### 限制

有总计70分的测试数据，其中$K$不超过$7,000$。在这些测试数据中，有总计25分的测试数据的$K$不超过$20$。

对于所有的测试数据，$1 \leq F \leq 500,000$，$1 \leq K \leq F$，$2 \leq M \leq 30,000$，$1 \leq L_X \leq 1,000,000,000$。

### 样例说明

有 $11$ 种可能的组合，所以你需要输出$4$，也就是$11$ 模 $7$。这些可能的组合是: $[1] [1,2] [1,2,3] [1,2,3,3] [1,3] [1,3,3] [2] [2,3] [2,3,3] [3]$ 和 $[3,3]$。(对每一种组合, 我们列出其所包含的宝石。 例如，$[2,3,3]$ 包含一块$2$型宝石和两块$3$型宝石)

这些组合可以由下述方式获得:

$[1]$: 如果你在第二条鱼 (或第四条) 吃掉任何其它鱼之前捕捉到它。

$[1,2]$: 如果第二条鱼吃掉第一条鱼, 它就会有一块 $1$ 型宝石(它在初始时刻吞下的) 和一块2型宝石 (从第一条鱼腹中得到的)。

$[1,2,3]$: 一种可能的途径是: 第四条鱼吃掉第一条鱼，然后第三条鱼又吃掉它。如果你此时捉到了第三条鱼，那它腹中就有这三种宝石一样一块

$[1,2,3,3]$: 第四条鱼吃掉第一条鱼，第三条鱼吃掉第四条鱼，第三条鱼吃掉第五条鱼，你捉到了第三条鱼。

$[1,3]$: 第三条鱼吃掉第四条鱼，你捉到了第三条鱼。

$[1,3,3]$: 第三条鱼吃掉第五条鱼，第三条鱼吃掉第四条鱼，你捉到了第三条鱼。

$[2]$: 你捉到了第一条鱼。

$[2,3]$: 第三条鱼吃掉第一条鱼，你捉到了第三条鱼

$[2,3,3]$: 第三条鱼吃掉第一条鱼，第三条鱼吃掉第五条鱼，你捉到了第三条鱼。

$[3]$: 你捉到了第三条鱼。

$[3,3]$: 第三条鱼吃掉第五条鱼，你捉到了第三条鱼。


---

---
title: "[IOI 2008] Linear Garden"
layout: "post"
diff: 省选/NOI-
pid: P4685
tag: ['2008', 'IOI']
---
# [IOI 2008] Linear Garden
## 题目描述

拉美西斯二世刚刚获胜归来。为了纪念这一胜利，他决定建造一座壮观的花园。这个花园里的植物排成一行，从他在卢克索的宫殿直达卡纳克神庙。所种植的植物只有莲花和纸莎草，因为它们分别代表上埃及和下埃及。

这个花园中必须有$N$棵植物，并且必须保持平衡，即在花园中任取一段，其中莲花和纸莎草的棵数之差不能超过$2$。

花园可以被表示为由字母```L```（莲花）和```P```（纸莎草）组成的字符串。例如，当$N=5$时，有$14$种可能的平衡花园，按照字母排序如下：```LLPLP```，```LLPPL```，```LPLLP```，```LPLPL```，```LPLPP```， ```LPPLL```，```LPPLP```，```PLLPL```，```PLLPP```，```PLPLL```，```PLPLP```，```PLPPL```，```PPLLP``` 和 ```PPLPL```。

给定长度的所有可能的平衡花园可按字母顺序排序，并从$1$开始编号。例如，当$N=5$时，第$12$号花园是```PLPPL```。 

写一个程序，给定植物棵数$N$和一个表示平衡花园的字符串，计算该花园的序号模$M$的结果，其中$M$是一个给定的整数。 注意，在问题求解中，数值 $M$ 除了简化计算外没有其他的作用。 
## 输入格式

第一行是整数$N$，说明花园中植物的数量。第二行是整数$M$。第三行是长度为$N$的由字符```L```或```P```组成的字符串，表示一个平衡的花园。
## 输出格式

你的程序需要向标准输出上输出一个介于$0$和$M-1$（含）的整数，占一行，表示该花园的序号模$M$。
## 样例

### 样例输入 #1
```
5
7
PLPPL
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
12
10000
LPLLPLPPLPLL
```
### 样例输出 #2
```
39
```
## 提示

有总分40分的测试点的$N$不超过$40$。

对于所有测试点，$1 \leq N \leq 1,000,000$，$7 \leq M \leq 10,000,000$。 

### 样例说明

第一个样例中，实际的序号是12。因此输出的是12模7，即5。


---

---
title: "[IOI 2000] 邮局 加强版"
layout: "post"
diff: 省选/NOI-
pid: P4767
tag: ['数学', '2000', 'IOI', '枚举', '区间 DP', '四边形不等式']
---
# [IOI 2000] 邮局 加强版
## 题目描述

高速公路旁边有一些村庄。高速公路表示为整数轴，每个村庄的位置用单个整数坐标标识。没有两个在同样地方的村庄。两个位置之间的距离是其整数坐标差的绝对值。

邮局将建在一些，但不一定是所有的村庄中。为了建立邮局，应选择他们建造的位置，使每个村庄与其最近的邮局之间的距离总和最小。

你要编写一个程序，已知村庄的位置和邮局的数量，计算每个村庄和最近的邮局之间所有距离的最小可能的总和。
## 输入格式

第一行包含两个整数：第一个是村庄 $V$ 的数量，第二个是邮局的数量 $P$。

第二行包含 $V$ 个整数。这些整数是村庄的位置。
## 输出格式

第一行包含一个整数 $S$，它是每个村庄与其最近的邮局之间的所有距离的总和。
## 样例

### 样例输入 #1
```
10 5 
1 2 3 6 7 9 11 22 44 50
```
### 样例输出 #1
```
9
```
## 提示

对于 $40\%$ 的数据，$V \leq 300$。

对于 $100\%$ 的数据，$1 \leq P \leq 300$，$P \leq V  \leq 3000$，$1 \leq $ 村庄位置 $\leq 10000$。


---

---
title: "[IOI 2018] werewolf 狼人"
layout: "post"
diff: 省选/NOI-
pid: P4899
tag: ['2018', '树状数组', 'IOI', 'O2优化', '深度优先搜索 DFS', '可持久化线段树']
---
# [IOI 2018] werewolf 狼人
## 题目背景

本题为交互题，但在此请提交**完整程序**。
## 题目描述

在日本的茨城县内共有 $N$ 个城市和 $M$ 条道路。这些城市是根据人口数量的升序排列的，依次编号为 $0$ 到 $N - 1$。每条道路连接两个不同的城市，并且可以双向通行。由这些道路，你能从任意一个城市到另外任意一个城市。

你计划了 $Q$ 个行程，这些行程分别编号为 $0$ 至 $Q - 1$。第 $i(0 \leq i \leq Q - 1)$ 个行程是从城市 $S_i$ 到城市 $E_i$。

你是一个狼人。你有两种形态：**人形**和**狼形**。在每个行程开始的时候，你是人形。在每个行程结束的时候，你必须是狼形。在行程中，你必须要变身（从人形变成狼形）恰好一次，而且只能在某个城市内（包括可能是在 $S_i$ 或 $E_i$ 内）变身。

狼人的生活并不容易。当你是人形时，你必须避开人少的城市，而当你是狼形时，你必须避开人多的城市。对于每一次行程 $i(0 \leq i \leq Q - 1)$，都有两个阈值 $L_i$ 和 $R_i(0 \leq L_i \leq R_i \leq N - 1)$，用以表示哪些城市必须要避开。准确地说，当你是人形时，你必须避开城市 $0, 1, \ldots , L_i - 1$ ；而当你是狼形时，则必须避开城市 $R_i + 1, R_i + 2, \ldots , N - 1$。这就是说，在行程 $i$ 中，你必须在城市 $L_i, L_i + 1, \ldots , R_i$ 中的其中一个城市内变身。

你的任务是，对每一次行程，判定是否有可能在满足上述限制的前提下，由城市 $S_i$ 走到城市 $E_i$。你的路线可以有任意长度。
## 输入格式

输入的第一行包含三个正整数 $N, M, Q$，其意义见题目描述。

接下来 $M$ 行，每行包含两个非负整数。在这 $M$ 行中，第 $j$ 行的两个非负整数分别表示 $X_{j - 1}, Y_{j - 1}$，即编号为 $j - 1$ 的道路连接的两个城市的编号。

接下来 $Q$ 行，每行包含四个非负整数。在这 $Q$ 行中，第 $i$ 行的四个非负整数分别表示 $S_{i - 1}, E_{i - 1}, L_{i - 1}, R_{i - 1}$，即编号为 $i - 1$ 的行程的起点城市编号、终点城市编号以及两个阈值。
## 输出格式

输出包含 $Q$ 行，每行包含一个非 $0$ 即 $1$ 的整数。第 $i$ 行的整数表示对于编号为 $i - 1$ 的行程，是否能从城市 $S_{i - 1}$ 走至城市 $E_{i - 1}$，若能够，那么输出整数为 $1$；若不能，那么输出整数为 $0$。
## 样例

### 样例输入 #1
```
6 6 3
5 1
1 2
1 3
3 4
3 0
5 2
4 2 1 2
4 2 2 2
5 4 3 4

```
### 样例输出 #1
```
1
0
0

```
### 样例输入 #2
```
10 9 10
6 7
1 5
8 0
2 9
9 4
2 7
8 5
6 0
3 4
4 9 0 9
8 1 8 9
1 8 1 8
8 3 5 5
8 9 3 9
0 1 0 2
9 0 6 6
1 7 1 8
9 4 5 6
9 5 0 9

```
### 样例输出 #2
```
1
1
1
0
1
1
0
1
0
1

```
## 提示

**限制条件**

- $2 \leq N \leq 200, 000$
- $N - 1 \leq M \leq 400, 000$
- $1 \leq Q \leq 200, 000$
- 对于每个 $0 \leq j \leq M - 1$
    - $0 \leq X_j \leq N - 1$
    - $0 \leq Y_j \leq N - 1$
    - $X_j \neq Y_j$
- 你可以通过道路由任意一个城市去另外任意一个城市。
- 每一对城市最多只由一条道路直接连起来。换言之，对于所有 $0 \leq j < k \leq M - 1$，都有 $(X_j, Y_j) \neq (X_k, Y_k)$ 和 $(Y_j, X_j) \neq (X_k, Y_k)$
- 对于每个 $0 \leq i \leq Q - 1$
    - $0 \leq L_i \leq S_i \leq N - 1$
    - $0 \leq E_i \leq R_i \leq N - 1$
    - $S_i \neq E_i$
    - $L_i \leq R_i$

**子任务**

- 1.（7 分）$N \leq 100$，$M \leq 200$，$Q \leq 100$。
- 2.（8 分）$N \leq 3, 000$，$M \leq 6, 000$，$Q \leq 3, 000$。
- 3.（34 分）$M = N - 1$ 且每个城市最多与两条路相连（所有城市是以一条直线的形式连起来）。
- 4.（51 分）没有附加限制。


---

---
title: "[IOI 2019] 矩形区域"
layout: "post"
diff: 省选/NOI-
pid: P5781
tag: ['2019', 'IOI', 'O2优化']
---
# [IOI 2019] 矩形区域
## 题目背景

# 滥用本题评测将封号！
## 题目描述

19 世纪初，统治者下令在俯瞰美丽河景的高原上建造一座宫殿。这块高原被看做是一个由正方形单元格组成的 $n \times m$ 网格。网格的行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号。第 $i$ 行第 $j$ 列（$0 \le i \le n-1$，$0 \le j \le m-1$）的单元格记为单元格 $(i,j)$。每个单元格 $(i,j)$ 有特定的海拔高度，记为 $a_{i,j}$。

统治者指示他的建筑师选择一个矩形区域来建造宫殿。该区域不能包含网格边界（第 $0$ 行，第 $n-1$ 行，第 $0$ 列，以及第 $m-1$ 列）上的任何单元格。为此，建筑师应选出四个整数 $r_1$，$r_2$，$c_1$ 和 $c_2$（$1 \le r_1 \le r_2 \le n-2$ 且 $1 \le c_1 \le c_2 \le m-2$ )，对应于包括所有满足 $r_1 \le i \le r_2$ 且 $c_1 \le j \le c_2$ 的单元格 $(i,j)$ 的矩形区域。

此外，一个区域被认为是合法的，当且仅当对于该区域中的每个单元格 $(i,j)$，以下条件成立：对于与该区域相邻的、位于第 $i$ 行的两个单元格（单元格 $(i,c_1-1)$ 和 $(i,c_2+2)$），以及与该区域相邻的、位于第 $j$ 列的两个单元格（单元格 $(r_1-1)$ 和 $(r_2+2,j)$），单元格 $(i,j)$ 的海拔高度必须严格小于这四个单元格的海拔高度。

你的任务是帮助建筑师统计可建宫殿的合法区域的数量（也就是所对应区域为合法的 $r_1$，$r_2$，$c_1$ 和 $c_2$ 的数量）。


## 输入格式

第一行，两个整数 $n$ 和 $m$，表示网格的长和宽。

接下来 $n$ 行，第 $i$ 行 $m$ 个整数，为 $a_{i-1,0\dots m-1}$。


## 输出格式

一行，一个整数，表示合法区域的数量。
## 样例

### 样例输入 #1
```
6 5
4 8 7 5 6
7 4 10 3 5
9 7 20 14 2
9 14 7 3 6
5 7 5 2 7
4 5 13 5 6

```
### 样例输出 #1
```
6

```
## 提示

**样例解释**

![](https://loj-img.upyun.menci.memset0.cn/2019/08/09/5d4d529d7be55.jpg)

一共有 $6$ 个合法区域，分别为：
- $r_1=r_2=1, c_1=c_2=1$
- $r_1=1, r_2=2, c_1=c_2=1$
- $r_1=r_2=1, c_1=c_2=3$
- $r_1=r_2=4, c_1=2,c_2=3$
- $r_1=r_2=4, c_1=c_2=3$
- $r_1=3,r_2=4,c_1=c_2=3$

例如，$r_1=1, r_2=2, c_1=c_2=1$ 对应一个合法区域，原因是以下两个条件都成立：
- $a_{1,1}=4$ 严格小于 $a_{0,1}=8$，$a_{3,1}=14$，$a_{1,0}=7$，和 $a_{1,2}=10$。
- $a_{2,1}=7$ 严格小于 $a_{0,1}=8$，$a_{3,1}=14$，$a_{2,0}=9$，和 $a_{2,2}=20$。

**数据范围**

对于所有数据：
- $1 \le n, m \le 2500$。
- $0 \le a_{i,j} \le 7 \times 10^6 (0 \le i \le n - 1, 0 \le j \le m - 1)$。

详细子任务附加限制与分值如下表：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$n, m \le 30$|$8$|
|$2$|$n, m \le 80$|$7$|
|$3$|$n, m \le 200$|$12$|
|$4$|$n, m \le 700$|$22$|
|$5$|$n \le 3$|$10$|
|$6$|$0 \le a_{i,j} \le 1$|$13$|
|$7$|没有任何附加限制|$28$|


---

---
title: "[IOI 2015] sorting"
layout: "post"
diff: 省选/NOI-
pid: P5862
tag: ['2015', 'IOI', 'Special Judge']
---
# [IOI 2015] sorting
## 题目描述

Aizhan 有一个由 $N$ 个互不相同的整数组成的序列 $S[0],S[1],\cdots,S[N-1]$，其中 $S[i]$ 取值范围是 $[0,N-1]$。Aizhan 试图通过交换某些元素对的方法将这个序列按照升序排序。Aizhan 的朋友 Ermek 也想交换某些元素对， Ermek 的交换未必有助于 Aizhan 的排序。

Ermek 和 Aizhan 打算通过若干轮次来修改这个序列。在每一轮，Ermek 首先做一次交换，然后 Aizhan 做另一次交换。更确切地说，做交换的人选择两个有效的下标并交换这两个下标的元素。请注意这两个下标可能相同。如果它们相等，则对这个元素自身做交换，并不改变这个序列。

Aizhan 知道 Ermek 并不关心对序列 
$S$ 排序的事情。Aizhan还知道 Ermek 将会选择哪些下标。Ermek 打算参加 $M$ 轮交换，将这些轮次从 $0$ 到 $M-1$ 编号。对于 $0$ 到 $M-1$ 之间的每个 $i$，Ermek 在第 $i$ 轮将选择下标 $X[i]$ 和 $Y[i]$ 的元素进行交换。

Aizhan 要对序列 $S$ 按升序进行排序。在每一轮之前，如果 Aizhan 看到当前的序列已经按升序排列，她将结束这个排序过程。给定初始序列 $S$ 以及 Ermek 要选择的下标，请你找出一个交换的序列，使得 Aizhan 能完成对序列 $S$ 的排序。此外，在有些子任务中，你还要找出尽可能短的交换序列来完成排序任务。题目保证通过 $M$ 或更少的轮次能够将序列 $S$ 排好序。

请注意如果 Aizhan 发现在 Ermek 的交换之后，序列 $S$ 已经排好序，则 Aizhan 可以选择交换两个相同下标（例如 $0$ 和 $0$）的元素。这样，序列 $S$ 在这一轮次之后也完成排序，于是也达到了 Aizhan 的目标。另外，如果初始序列 $S$ 就已经排好序，那么所需的最少排序轮数就是 $0$。
## 输入格式

- 第 $1$ 行有一个正整数 $N$，表示序列 $S$ 的长度；
- 第 $2$ 行有 $N$ 个正整数，分别为 $S[0],\cdots,S[N-1]$，即初始序列 $S$；
- 第 $3$ 行有一个正整数 $M$，表示 Ermek 打算做交换的次数；
- 第 $4$ 到 $M+3$ 行，有两个正整数 $X[i]$，$Y[i]$，表示对于 $0\le i\le M-1$, 在第 $i$ 轮 Ermek 打算交换下标为 $X[i]$ 和 $Y[i]$ 的数组。
## 输出格式

- 第 $1$ 行 : 交换的长度 $R$；
- 第 $2+i$（$0\le i < R$）行：$P[i]$，$Q[i]$。

注：$P$，$Q$分别为两个整数数组。利用这两个数组报告 Aizhan 完成对序列 $S$ 排序的一种可能的交换序列，假设这个交换序列的长度为 $R$，对于 $0$ 到 $R-1$ 之间的每个 $i$，Aizhan 在轮次 $i$ 选择的下标将被存入 $P[i]$ 和 $Q[i]$。 你可以假设数组 $P$ 和 $Q$ 均已分别被分配了 
$M$ 个元素。
## 样例

### 样例输入 #1
```
5
4 3 2 1 0
6
0 1
1 2
2 3
3 4
0 1
1 2

```
### 样例输出 #1
```
3
0 4
1 3
3 4
```
### 样例输入 #2
```
5
3 0 4 2 1
5
1 1
4 0
2 3
1 4
0 4

```
### 样例输出 #2
```
3
1 4
4 2
2 2
```
## 提示

对于 $100\%$ 的数据，$1 \le N\le 2 \times 10^5$，$1 \le M \le 6 \times 10^5$。要求 $R$ 取最小值。


---

---
title: "[IOI 2014] holiday 假期"
layout: "post"
diff: 省选/NOI-
pid: P5892
tag: ['2014', 'IOI']
---
# [IOI 2014] holiday 假期
## 题目描述

健佳正在制定下个假期去台湾的游玩计划。在这个假期，健佳将会在城市之间奔波，并且参观这些城市的景点。

在台湾共有 $n$ 个城市，它们全部位于一条高速公路上。这些城市连续地编号为 $0$ 到 $n-1$。

对于城市 $i$（$0 < i < n-1$ ）而言，与其相邻的城市是 $i-1$ 和 $i+1$。但是对于城市 $0$，唯一与其相邻的是城市 $1$。而对于城市 $n-1$，唯一与其相邻的是城市 $n-2$。

每个城市都有若干景点。健佳有 $d$ 天假期并且打算要参观尽量多的景点。健佳已经选择了假期开始要到访的第一个城市。在假期的每一天，健佳可以选择去一个相邻的城市，或者参观所在城市的所有景点，但是不能同时进行。即使健佳在同一个城市停留多次，他也不会去重复参观该城市的景点。请帮助健佳策划这个假期，以便能让他参观尽可能多的景点。

## 输入格式

- 第 $1$ 行：有三个非负整数， $n$ 代表城市数目，$start$ 代表起点城市编号，$d$ 代表假期天数。
- 第 $2$ 行：$n$ 个非负整数 $a[0],\cdots, a[n-1]$，对于 $0 \le i \le n-1$，$a[i]$ 代表城市 $i$ 的景点数目。

## 输出格式

- 共一行，最多参观的景点数目。
## 样例

### 样例输入 #1
```
5 2 7
10 2 20 30 1

```
### 样例输出 #1
```
60

```
## 提示

**子任务**

在所有的子任务中，有 $0 \le d \le 2n+floor(n/2)$。
而且，每个城市中的景点数都是非负整数。

| 子任务 | 分值 | $n$ | 各城市景点数的最大值 | 起点城市 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $7$ | $2 \le n \le 20$ | $10^9$ | 无限制 |
| $2$ | $23$ | $2 \le n \le 10^5$ | $100$ | 城市 $0$ |
| $3$ | $17$ | $2 \le n \le 3 \times 10 ^3$ | $10^9$ |无限制  |
| $4$ | $53$ | $2 \le n \le 10^5$ | $10^9$ | 无限制 |




---

---
title: "[IOI 2013] game 游戏"
layout: "post"
diff: 省选/NOI-
pid: P5893
tag: ['2013', 'IOI', 'O2优化']
---
# [IOI 2013] game 游戏
## 题目背景

警告：**滥用本题评测将被封号**。
## 题目描述

Bazza 和 Shazza 正在玩游戏。游戏在一个 $R$ 行 $C$ 列的网格上进行。其中， $R$ 行编号为 $0,\cdots, R - 1 $， $C$ 列编号为 $0,\cdots, C - 1 $。我们用 $(P, Q)$ 表示位于 $P$ 行 $Q$ 列的单元格。每个单元格包含一个非负整数，游戏开始时所有单元格内的整数均为零。

游戏如下进行：任意时刻，Bazza 可以做如下动作之一：
- 修改一个单元格 $(p, q)$ 内包含的整数值；
- 要求 Shazza 计算一个给定子矩阵中所有单元格内数字的最大公约数（GCD），子矩阵的两个对角分别为 $(p, q)$ 和 $(u, v)$ （子矩阵包含给定的两个对角点）。

Bazza 会做 $N_U + N_Q$ 次动作(其中，修改单元格内数据 $N_U$ 次，询问 GCD $N_Q$ 次) 。

你的任务是对 Bazza 提出的问题给出正确答案。
## 输入格式

- 第1行: $R$ 表示网格行数，$C$ 表示网格列数，$N$ 表示操作总数。
- 接下来的 $N$ 行: 每行表示一个动作，以动作发生的先后顺序给出。

表示每个动作的一行的格式如下：
- `update(P,Q,K)` 表示为： `1 P Q K`
- `calculate(P,Q,U,V)` 表示为： `2 P Q U V`


## 输出格式

共 $N_Q$ 行，对于每次询问，输出答案。

**说明**

`update(P,Q,K)`

- 当Bazza改变单元格中的整数时调用此函数，即把第 $P$ 行第 $Q$ 列的数改为 $K$。
- $P$: 单元格的行号（$0 \le P \le R - 1$ ）。
- $Q$: 单元格的列号（$0 \le Q \le C - 1$ ）。
- $K$: 这个单元格中新的整数（ $0 \le K \le 10^{18}$）。这个新整数可能与原来的整数相同。

`calculate(P,Q,U,V)`

- 该函数计算以 $(P, Q)$ 和 $(U, V)$ 为对角点的子矩阵中所有整数的最大公约数。这个范围是包含单元格 $(P, Q)$ 和 $(U, V)$ 的。

- 如果这个子矩阵中的所有整数都是 $0$，那么该函数返回 $0$。

- $P$: 子矩阵左上角单元格的行号（ $0 \le P \le R - 1$ ）。
- $Q$: 子矩阵左上角单元格的列号 （$ 0 \le Q \le C - 1$ ）。
- $U$: 子矩阵右下角单元格的行号（ $P \le U \le R - 1$ ）。
- $V$: 子矩阵右下角单元格的列号（ $Q \le V \le C - 1$ ）。
## 样例

### 样例输入 #1
```
1 1 64
2 0 0 0 0
2 0 0 0 0
2 0 0 0 0
1 0 0 5352072091165800
2 0 0 0 0
1 0 0 15571253006461152
1 0 0 36204425277916896
1 0 0 80686018200191040
1 0 0 720602986354563312
2 0 0 0 0
1 0 0 90705271009665312
2 0 0 0 0
1 0 0 583803309300971760
1 0 0 3317329660750560
2 0 0 0 0
2 0 0 0 0
2 0 0 0 0
1 0 0 84776821924066272
1 0 0 581927323100969664
1 0 0 93139161501610224
1 0 0 28340661117472704
1 0 0 74529074218959360
2 0 0 0 0
1 0 0 462419028676725120
1 0 0 4416867915235776
1 0 0 840475934823549024
1 0 0 8247617084266560
1 0 0 117571055091706944
1 0 0 839204903894797440
1 0 0 820805176764813240
1 0 0 82688722861897152
1 0 0 136422472061715840
1 0 0 555837014267982720
1 0 0 935087613488388360
1 0 0 17770822018565616
1 0 0 10726679222715456
1 0 0 621229604181863040
1 0 0 12477973789689408
2 0 0 0 0
1 0 0 227153207069268480
1 0 0 262037449583477568
1 0 0 562837835495871936
1 0 0 131875056326325312
1 0 0 922430858108760
1 0 0 763487168205041280
2 0 0 0 0
2 0 0 0 0
1 0 0 551850903114166656
1 0 0 243713152409807808
1 0 0 306811355534716032
1 0 0 115604757169181280
2 0 0 0 0
1 0 0 29254579698314880
1 0 0 35080064244441216
1 0 0 97819409912384160
1 0 0 34259332503876480
2 0 0 0 0
2 0 0 0 0
1 0 0 159548730492191040
1 0 0 11555364984947784
2 0 0 0 0
1 0 0 3373083100427040
2 0 0 0 0
2 0 0 0 0

```
### 样例输出 #1
```
0
0
0
5352072091165800
720602986354563312
90705271009665312
3317329660750560
3317329660750560
3317329660750560
74529074218959360
12477973789689408
763487168205041280
763487168205041280
115604757169181280
34259332503876480
34259332503876480
11555364984947784
3373083100427040
3373083100427040

```
## 提示

**子任务**

| 子任务 | 分数 | $R$ | $C$ | $N_U$ | $N_Q$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $\le 100$ | $\le 100$ | $\le 100$ | $\le 100$ |
| $2$ | $27$ | $\le 10$ | $\le 10^5$ | $\le 10^4$ | $\le 2.5\times 10^5$ |
| $3$ | $26$ | $\le 2 \times 10^3$ | $\le 2 \times 10^3$ | $\le 10^4$ | $\le 2.5 \times 10^5$ |
| $4$ | $17$ | $\le 10^9$ | $\le 10^9$ | $\le 10^4$ | $\le 2.5 \times 10^5$ |
| $5$ | $20$ | $\le 10^9$ | $\le 10^9$ | $\le 2.2 \times 10^4$ | $\le 2.5 \times 10^5$ |

**限制**

对于 $100\%$ 的数据，$1 \le R,C \le 10^9$，$0 \le K \le 10^{18}$，$K$ 表示 Bazza 放到单元格中的数字。


---

---
title: "[IOI 2009] Regions"
layout: "post"
diff: 省选/NOI-
pid: P5901
tag: ['2009', 'IOI', '交互题', 'Special Judge', 'O2优化']
---
# [IOI 2009] Regions
## 题目背景

## 滥用本题评测将被封号

IOI2009 D2T3

原题时间限制 8s，为节约评测资源，时间限制改为 4s。
## 题目描述

联合国区域发展委员会（The United Nations Regional Development Agency, UNRDA）有一个良好的组织结构。它任用了 $N$ 名委员，每名委员都属于几个地区中的一个。委员们按照其资历被编号为 $1$ 到 $N$ ，$1$ 号委员是主席，资历最高。委员所属地区被编号为 $1$ 到 $R$。除了主席之外所有委员都有一个直接导师。任何直接导师的资历都比他所指导的委员的资历要高。

我们称委员 $A$ 是委员 $B$ 的导师当且仅当 $A$ 是 $B$ 的直接导师或者 $A$ 是 $B$ 的直接导师的导师。显然，主席是所有其他委员的导师，没有任何两名委员互为导师。

现在，为了调查大量对 UNRDA 偏向某些地区的不平衡的组织结构的指控，UNRDA 想要建立一个计算机系统：在给定委员之间的直接导师关系的情况下，该系统可以回答下述形式的问题：给定两个地区 $r_1$ 和 $r_2$，要求系统回答委员会中有多少对委员 $e_1$ 和 $e_2$，满足 $e_1$ 属于 $r_1$，而 $e_2$ 属于 $r_2$，并且 $e_1$ 是 $e_2$ 的导师。每次询问都有两个参数 $r_1$ 和 $r_2$，结果是一个整数：满足上述条件的 $(e_1, e_2)$ 二元组的数量。

**任务**：编写一个程序，给定每个委员的地区和直接导师，**在线** 回答上述询问。

**强制在线将以交互的格式进行**。
## 输入格式

第一行包含三个整数 $N, R, Q$，分别由一个空格隔开，分别表示雇员人数，区域数和查询数。

接下来 $N$ 行按照资历的顺序给出了 $N$ 个委员的描述信息。其中第 $k$ 行描述了编号为 $k$ 的委员。第一行（描述主席的一行）包含一个整数：主席所属的地区 $H_1$。其余的 $N - 1$ 行，每行包含两个整数，以一个空格隔开分别表示委员 $k$ 的直接导师 $S_k$ 和委员 $k$ 所属的地区 $H_k$。

### 交互格式

在读入所有输入数据之后，你的程序必须依次从标准输入中读入询问，并将询问结果输出至标准输出。必须依次回答 $Q$ 个询问，每次回答一个。**在读入下一个询问之前，你必须先回答当前询问**。

每个询问是标准输入的一行，用两个不同整数 $r_1, r_2$ 表示。
## 输出格式

对查询的回答是标准输出的一行，包含一个整数，表示在 UNRDA 中有多少对委员 $e_1$ 和 $e_2$ 满足下述条件：$e_1$ 属于地区 $r_1$，$e_2$ 属于地区 $r_2$，并且 $e_1$ 是 $e_2$ 的导师。

**注意**：输入数据保证给出的任意询问的正确答案小于 $10 ^ 9$。

**特别注意**：为了正确地和交互库交互，你的程序必须 **在回答每次询问后刷新标准输出缓冲区**。你同样需要避免意外地在读入标准输入时堵住了输入流，这有可能在你使用 `scanf("%d\n", ...)` 的语句时发生。

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\n'`，也可以自动刷新缓冲区。
## 样例

### 样例输入 #1
```
6 3 4
1
1 2
1 3
2 3
2 3
5 1
1 2

1 3

2 3

3 1
```
### 样例输出 #1
```








1 [刷新缓冲区]

3 [刷新缓冲区]

2 [刷新缓冲区]

1 [刷新缓冲区]

```
## 提示

### 数据范围与约定

- 对于 $30\%$ 的数据，$N\leq 500$。
- 对于 $55\%$ 的数据，没有地区包含超过 $500$ 个委员。
- 同时满足上述两个条件的数据有 $15\%$，至少满足上述一个条件的数据有 $70\%$。
- 对于 $100\%$ 的数据，$1 \le N, Q \le 2 \times 10^5$，$1 \le H_k, r_1, r_2 \le R \le 2.5 \times 10^4$，$1 \le S_k < k$。


---

---
title: "[IOI 2009] Salesman"
layout: "post"
diff: 省选/NOI-
pid: P5902
tag: ['2009', 'IOI', 'O2优化']
---
# [IOI 2009] Salesman
## 题目背景

IOI2009 D2T4
## 题目描述

旅行商已经发现，最佳的陆上旅行计划是一个难以解决的计算问题，所以他将他的生意转移到多瑙河的线性世界。他有一条很快的船，可以在很短的时间内把他从沿河的任何地方送到任何地方，但不幸的是，这条船耗油量很大。旅行商向上游（靠近河流源头的方向）移动每一米的成本为 $U$ 美元，向下游（远离河流源头的方向）移动每一米的成本为 $D$ 美元。

沿河有 $N$ 个展销会，旅行商想参加。每场展销会只举行一天。对于每个展销会 $X$，旅行商知道它的日期 $T_X$（他买船后的天数为第 $0$ 天），集市的位置 $L_X$ 和他在这场集市上能获得的盈利 $M_X$。位置表示集市到河流源头的距离，以米为单位。他必须在位置为 $S$ 的家 **开始和结束** 他的旅程。

帮助旅行商选择参加哪些展销会（如果有的话）以及按什么顺序，这样他可以在旅行结束时最大化他的利润。旅行商的总利润是指他在参加集市时获得的美元减去他在河上下游旅行所花费的美元的总和。

请记住，如果展销会 $A$ 的举办时间早于展销会 $B$，则旅行商只能按此顺序去展销会（即，他不能先去展销会 $B$，然后再去展销会 $A$）。但是，如果两个集市在同一天举行，旅行商可以按任何顺序参观。旅行商一天去多少个集市是没有限制的，但他不能在同一个集市盈利两次。他可以经过他已经参观过的集市而一无所获。

**任务**：编写一个程序，给定所有展销会的日期，位置和旅行商的盈利额，以及旅行商的家的位置和他移动的代价，求出他在旅行结束时的最大利润。
## 输入格式

第一行包含四个整数 $N, U, D, S$，分别由一个空格隔开，分别表示展销会数，向上游（$U$）或下游（$D$）移动的单位代价，以及旅行商的家的位置。

接下来的 $N$ 行描述了 $N$ 个展销会。其中第 $k$ 行描述了第 $k$ 个展销会的信息，包含三个整数，分别由一个空格隔开，分别表示展销会日期 $T_k$，它的位置 $L_k$，以及旅行商在该次展销会能获得的的盈利 $M_k$。
## 输出格式

一行一个整数表示旅行商在旅行结束时的最大利润。
## 样例

### 样例输入 #1
```
4 5 3 100
2 80 100
20 125 130
10 75 150
5 120 110

```
### 样例输出 #1
```
50

```
## 提示

### 样例解释

在一个最优方案中，旅行商参加了编号为 $1$ 和 $3$ 的展销会（位置分别为 $80$ 和 $75$）。事件序列以及对应的利润如下：

- 旅行商从家出发，向上游移动 $20$ 米，花费 $100$ 美元。目前利润：$-100$。
- 旅行商参加展销会 $1$ 并赚取 $100$ 美元。目前利润：$0$。
- 旅行商向上游移动 $5$ 米，花费 $25$ 美元。目前利润 $-25$。
- 旅行商参加展销会 $3$ 并赚取 $150$ 美元。目前利润：$125$。
- 旅行商向下游移动 $25$ 米，回到自己的家，花费 $75$ 美元。最终利润：$50$。

### 数据范围与约定

- 对于 $60\%$ 的数据，没有两个展销会在同一天举行。
- 对于 $40\%$ 的数据，输入的所有数不超过 $5000$。
- 同时满足上述两个条件的数据有 $15\%$，至少满足上述一个条件的数据有 $85\%$。
- 对于 $100\%$ 的数据，$1 \le N, T_k \le 5\times 10^5$，$1 \le D \le U \le 10$，$1 \le S, L_k \le 5 \times 10^5 +1$，$1 \le M_k \le 4000$。


---

---
title: "[IOI 2012] 理想城"
layout: "post"
diff: 省选/NOI-
pid: P6137
tag: ['2012', 'IOI']
---
# [IOI 2012] 理想城
## 题目描述

像许多同龄的科学家和艺术家一样，小 L 对城市规划和城区设计很感兴趣.他致力于构建一个理想城。理想城由 $N$ 个区块组成，而这些区块放在一个无限大的正方形网格上。第 $x$ 行第 $y$ 列的单元格由有序数对 $(x,y)$来标识。单元格 $(0,0)$ 位于网格的左上角。给定一个单元格 $(x,y)$，与之相邻的单元格（如果存在的话）分别为：$(x-1,y)$，$(x+1,y)$，$(x,y-1)$，$(x,y+1)$。每个区块在网格上恰好覆盖一个单元格。一个区块能够被放置在单元格 $(x,y)$ 上，当且仅当 $1 \le x,y \le 2^{31}-2$ 。我们将使用单元格的坐标同时来代表单元格上面的区块。若两个区块被放在相邻的单元格中，则视它们为相邻区块.理想城所有的区块连在一起，里面没有“洞”存在.换言之，所有单元格必须满足下述两个条件：
- 对于任意两个空白的单元格，至少存在一连串相邻的空白单元格连接它们。
- 对于任意两个非空的单元格，至少存在一连串相邻的非空单元格连接它们。

以下 $4$ 个图中的区块放置均不满足理想城的条件。前两个图不满足第一个条件。第 $3$ 个图不满足第二个条件，第 $4$ 个图两个条件均不满足。

![](https://cdn.luogu.com.cn/upload/image_hosting/uzw8c8c8.png)

当遍历理想城时，一个**跳步**代表**从一个区块走到一个相邻的区块**。跳步时不能移进空白单元格。假设 $v_0,v_1,\cdots,v_{N-1}$ 是 $N$ 个区块的坐标。对于任意两个不同的区块 $v_i$ 和 $v_j$，它们的距离 $d(v_i,v_j)$ 是从 $v_i$ 移动到 $v_j$ 所需的最小跳步数目。

下图是一个由 $11$ 个区块组成的理想城。区块坐标分别为

![](https://cdn.luogu.com.cn/upload/image_hosting/5whsvyjh.png)

$$v_0=(2,5) \quad v_1=(2,6) \quad v_2=(3,3)$$
$$v_3=(3,6) \quad v_4=(4,3) \quad v_5=(4,4)$$
$$v_6=(4,5) \quad v_7=(4,6) \quad v_8=(5,3)$$
$$v_9=(5,4) \quad v_{10}=(5,6)$$


其中，$d(v_1,v_3)=1$，$d(v_1,v_8)=6$，$d(v_6,v_10)=2$，$d(v_9,v_10)=4$。

给定一个理想域，试求
$$S=\sum_{i=0}^{N-2}\sum_{j=i+1}^{N-1}d(v_i,v_j)$$

## 输入格式

第 $1$ 行为一个正整数 $N$，为理想城区块的数目。

第 $2$ 行到第 $N+1$ 行，每行有两个非负整数。第 $i+2$ 行为第 $i$ 个区块的坐标 $v_i = (x_i， y_i)$。
## 输出格式

输出仅一行一个正整数，为 $S$ 的值。由于 $S$ 的值可能较大，你只需输出 $S$ 对 $10^9$ 取模的值。
## 样例

### 样例输入 #1
```
11
2 5
2 6
3 3
3 6
4 3
4 4
4 5
4 6
5 3
5 4
5 6

```
### 样例输出 #1
```
174
```
## 提示

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le x_i,y_i \le 2^{31}-2$ 。


---

---
title: "[IOI 2012] 骑马比武竞赛"
layout: "post"
diff: 省选/NOI-
pid: P6138
tag: ['2012', 'IOI']
---
# [IOI 2012] 骑马比武竞赛
## 题目描述

1491 年公爵 Milan Lodovico Sforza 为了他与 Beatrice d'Este 的婚礼，要求Leonardo 来负责筹备婚礼的庆典。在这个庆典中包含了一个盛大的持续三天的骑马比武竞赛，但是最受欢迎的骑士迟到了...

在一骑马比武的竞赛，$N$ 个骑士一开始被排成一排然后按照他们的位置从 $0$ 到 $N-1$ 开始编号。骑马比武的主持人每一回合叫出两个位置 $S$ 跟 $E$ （其中 $0 \le S < E \le N - 1$）。所有介于 $S$ 与 $E$ （含） 这两个位置的骑士则开始进行骑马比武。最后的赢家可以留下来继续进行竞赛， 并回到他原来的位置，而输家则离开这个竞赛。在这之后，剩下的骑士按照原来排列的顺 序，往前挤掉空出来的位置。所以他们的位置编号变成从 $0$ 到 $N - (E - S) - 1$。骑马比武竞赛的主持人接着进行下一个回合的比赛，直到最后剩下唯一个骑士。

Leonardo 知道所有骑士有不同的强度，这个强度从 $0$ (最弱) 到 $N-1$ (最强)。他也知道骑马比武竞赛的主持人会下怎么样的命令来进行C回合的竞赛，毕竟他是无所不能的   Leonardo。而且他也确定在每一个回合中，拥有最大强度的骑士会获得胜利。

$N$ 个骑士中的 $N-1$ 个骑士已经排成了一排，只是最受欢迎的骑士还未出现。这个骑士的强度为 $R$ 但是他迟到了。为了让这场竞赛达到最高潮, Leonardo  想要让这个骑士能好好展现他的风采，所以想要帮他安插一个位置，而这个位置可以使得这个骑士能获得最多回合的 胜利。请注意，我们不关心与此骑士无关的回合。我们只关心包含此骑士而且由他赢得胜利的回合。

**例子**

假设有 $5$ 个骑士，其中 $4$ 个骑士已经排列好，而他们的强度分别是 $[1,0,2,4]$。而迟到骑士的强度为 $3$ 。假设要进行 $3$ 回合，骑马比武的主持人打算要叫出的位置 $(S,E)$ 分别是 $(1, 3)$，$(0, 1)$，$(0, 1)$。

假设 Leonardo  将迟到的骑士插到第一个位置而且迟到的骑士强度为 $3$。那么骑士强度的排列将会是 $[3, 1, 0, 2, 4]$。第一回合参与的骑士为位置 $1,2,3$ 的骑士，他们的强度分别是 $1,0,2$，所以由强度 $2$ 的骑士获得胜利。经过这一回合，新的骑士强度的排列变成 $[3, 2, 4]]$。下一个回合是由强度 $3$ 与强度 $2$（位置 $0,1$）的骑士进行比赛，由强度 $3$ 的骑士获得胜利。而骑士强度的排列则变成 $[3,4]$。最后一回合（位置 $0,1$）由强度 $4$ 的骑士获得胜利。那么，迟到的骑士只有获得一回合的胜利 (第二回合)。

若 Leonardo 将迟到的骑士插入强度 $1$ 与强度 $0$ 的骑士中间，骑士强度的排列将会是 $[1,3,0,2,4]$。这一次,  第一回合比赛的骑士强度为 $3,0,2$。由强度 $3$ 的骑士获胜，然后骑士强度的排列变成 $[1,3,4]$。在第二回合中由强度 $1$ 对上强度 $3$ 的骑士，由强度 $3$ 的骑士获胜。最后的一回合，骑士强度的排列变成  $[3,4]$，由强度 $4$ 的骑士获得胜利。在这个排列中，迟到的骑士获得两回合的胜利。这实际上是最佳的位置，因为没有其他的位置可以让迟到的骑士获得两回合以上的胜利。

你的任务是写一个程序来帮迟到的骑士选择最佳的位置让他能获得最多的胜利回合数，以符合 Leonardo 的期待。
## 输入格式

- 第一行，$3$个整数 $N$，$C$，$R$，其中 $N$ 表示骑士的个数，$C$ 表示竞赛主持人会进行的回合数，$R$ 表示迟到的骑士的强度。
- 第二行，$N$ 个整数 $K[0],K[1],\cdots,K[N-1]$，表示已经排列好成一列的 $N-1$ 个骑士的强度
- 第三行，$2C$ 个整数 $S[0],E[0],S[1],E[1],\cdots,E[N-1],S[N-1]$，对于 $0 \le i \le C-1$，竞赛主持人进行第 $i +1$ 回合比赛的骑士为从位置 $S[i]$ 到位置 $E[i]$ (含). 你可以假设对每一个 $i$ , $S[i] < E[i]$。
## 输出格式

共一行，让迟到的骑士能获得最多胜利回合数的位置。如果存在多个最优的位置，输出编号最小的位置。
## 样例

### 样例输入 #1
```
5 3 3
1 0 2 4
1 3
0 1
0 1

```
### 样例输出 #1
```
1

```
## 提示

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le C \le N-1$，在第 $i+1$ 回合，$E[i]$ 会小于这个回合剩下的骑士数量。经过 $C$ 回合的命令之后，只会剩下一个骑士。


---

---
title: "[IOI 2016] railroad"
layout: "post"
diff: 省选/NOI-
pid: P6168
tag: ['2016', 'IOI', 'Special Judge']
---
# [IOI 2016] railroad
## 题目描述

Anna 在一个游乐园工作。她负责建造一个新的过山车铁路。她已经设计了影响过山车速度的 $n$ 个特殊的路段（方便起见标记为 $0$ 到 $n-1$）。现在 Anna 必须要把这些特殊的路段放在一起并提出一个过山车的最后设计。为了简化问题，你可以假设过山车的长度为零。

对于 $0$ 和 $n-1$ 之间的每个 $i$，这个特殊的路段 $i$ 具有如下两个性质：

- 当进入这个路段时，有一个速度限制：过山车的速度必须小于或等于 $s_i$ $\text{km/h}$（每小时千米）。

- 当离开这个路段时，过山车的速度刚好是 $t_i$ $\text{km/h}$，不管过山车进入该路段时的速度如何。

最后完成的过山车设计是一个以某种顺序包含这 $n$ 个特殊路段的单一铁路线。这 $n$ 个路段中的每一个应当被使用刚好一次。连续的路段之前用铁轨来连接。Anna 应该选择这 $n$ 个路段的顺序，然后确定每段铁轨的长度。铁轨的长度以米来衡量，可以是任意的非负整数（可以为零）。

两个特殊路段之间的每 $1$ 米铁轨可以将过山车的速度减慢 $1$ $\text{km/h}$。在这个过山车铁路的起点，过山车按照 Anna 选择的顺序进入第一个特殊路段时的速度是 $1$ $\text{km/h}$。

最后的设计还必须满足以下要求：

- 过山车在进入这些特殊路段时不能违反任一个速度限制。

- 过山车的速度在任意时刻为正。

你的任务是找出这些路段之间铁轨的最小可能总长度（这些路段之间铁轨总长度的最小值）。如果 $m=0$ 你只需要检查是否存在一个有效的过山车设计，使得每段铁轨的长度为零。

**举例**

```
4 1
1 7
4 3
5 8
6 6
```
在这个样例中有 $4$ 个特殊的路段。最好的解是按照 $0,3,1,2$ 的顺序构造，连接这些路段的铁轨长度分别是 $1,2,0$。下面给出过山车沿铁路铁轨的行驶方式：

- 最初过山车的速度是 $1$ km/h。

- 过山车由进入 $0$ 号路段开始行进。

- 过山车以 $7$ $\text{km/h}$ 的速度离开 00 号路段。

- 然后有一段长度为 $1$ $\text{m}$ 的铁轨。过山车在到达这段铁轨的末端时速度为 $6$ $\text{km/h}$。

- 过山车以 $6$ $\text{km/h}$ 的速度进入 $3$ 号路段并以相同的速度离开该路段。

- 在离开 $3$ 号路段后，过山车走过一段 $2$ $\text{m}$ 长的铁轨。速度降至 $4$ $\text{km/h}$。

- 过山车以 $4$ $\text{km/h}$ 的速度进入 $1$ 号路段，并且以 $3$ $\text{km/h}$ 的速度离开该路段。

- 离开 $1$ 号路段后，过山车立即进入 $2$ 号路段。

- 过山车离开 $2$ 号路段。其最终速度是 $8$ $\text{km/h}$。

路段之间的铁轨总长度：$1+2+0=3$。
## 输入格式

- 第一行：两个整数 $n$ 和 $m$，其中 $m=0$ 表示当答案不为 $0$ 时，你可以返回任意正整数，$m=1$ 表示你需要返回正确答案。

- 接下来 $n$ 行：第 $i$ 行的两个整数表示 $s_{i-1}$ 和 $t_{i-1}$。
## 输出格式

共一行，所有铁轨的最小可能总长度。（当 $m=0$ 时，如果存在一个有效的过山车设计使得每段铁轨的长度均为零，则函数返回零，如果上述设计不存在，则输出任意的正整数）。
## 样例

### 样例输入 #1
```
4 1
1 7
4 3
5 8
6 6

```
### 样例输出 #1
```
3

```
## 提示

对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$ 1 \le s_i \le 10^9$，$1 \le t_i \le 10^9$。


---

---
title: "[IOI 2019] 视觉程序"
layout: "post"
diff: 省选/NOI-
pid: P6751
tag: ['2019', 'IOI', '交互题', 'Special Judge']
---
# [IOI 2019] 视觉程序
## 题目背景

[评测方式](https://www.luogu.com.cn/paste/5z13bn4l)

[一些说明~~和扯淡~~](https://www.luogu.com.cn/paste/l6kcccs4)
## 题目描述

你在给机器人编写一个视觉程序。每次机器人的摄像头拍下一张照片时，图像将以黑白图像的形式存储在机器人的内存中。每张图像是由像素构成的 $H\times W$ 网格。图像的行从 $0$ 到 $H-1$ 编号，列从 $0$ 到 $W-1$ 编号。每张图像含有**恰好两个**黑色像素，其他像素均为白色。

机器人可以用简单指令构成的程序来处理图像。给出 $H$，$W$ 和一个正整数 $K$ 的值，你的目标是要编写一个函数，用来为机器人生成程序。该程序需要判定图像中两个黑色像素的距离是否正好为 $K$。这里，在第 $r_1$ 行及第 $c_1$ 列上的像素与第 $r_2$ 行及第 $c_2$ 列上的像素之间的距离定义为 $|r_1-r_2|+|c_1-c_2|$。 在这个式子中，$|x|$ 表示 $x$ 的绝对值，即当 $x\ge0$ 时，其值为 $x$，而当 $x<0$ 时，其值为 $-x$。

下面描述机器人是如何运作的。

机器人的内存有足够多的存储单元，从 $0$ 开始编号。每个存储单元可以保存 $0$ 或 $1$，且它的内容一旦设置后就不可更改。图像一行接一行地保存在存储单元里，这些存储单元的编号从 $0$ 到 $H\cdot W-1$。第一行保存在存储单元 $0$ 到 $W-1$ 里，最后一行保存在存储单元 $(H-1)W$ 到 $H\cdot W-1$ 里。特别地，如果位于第 $i$ 行第 $j$ 列上的那个像素是黑色的，则保存在存储单元 $i\cdot W+j$ 里的值为 $1$，否则为 $0$。

机器人的程序是一个**指令**的序列，这些指令用从 $0$ 开始的连续整数进行编号。在程序运行时，指令将一条一条地被执行。每条指令读取一个或多个存储单元的值（我们将这些值称为指令的**输入**），同时产生一个 $0$ 或 $1$ 的值（我们称之为指令的**输出**）。指令 $i$ 的输出将会保存在存储单元 $H\cdot W+i$ 中。指令 $i$ 的输入只能是保存图像的存储单元，或者是保存之前指令输出的存储单元，也就是编号为从 $0$ 到 $H\cdot W+i-1$ 的存储单元。

机器人共有四种指令：
- `NOT`：有唯一一个输入。若输入为 $0$ 时，其输出为 $1$，否则为 $0$。
- `AND`：有一个或多个输入。其输出为 $1$ 当且仅当输入**全部**为 $1$。
- `OR`：有一个或多个输入。其输出为 $1$ 当且仅当输入中**至少有一个** $1$。
- `XOR`：有一个或多个输入。其输出为 $1$ 当且仅当输入中 $1$ 的个数是**奇数**。

如果两个黑色像素之间的距离正好为 $K$，则最后一条指令的输出应为 $1$，否则输出应为 $0$。
#### 实现细节
你需要实现以下函数：
```plain
void construct_network(int H, int W, int K)
```
- $H$，$W$：机器人摄像头所拍到的图像的尺寸
- $K$：一个正整数
- 这个函数需要生成一个机器人的程序。对于机器人摄像头所拍到的每幅图像，该程序应判定图像中两个黑色像素之间的距离是否正好为 $K$。

该程序应当通过调用以下函数将指令追加到机器人的程序中（最初机器人的程序是空的）：
```plain
int add_not(int N)
int add_and(int[] Ns)
int add_or(int[] Ns)
int add_xor(int[] Ns)
```
- 分别追加一条 `NOT`，`AND`，`OR` 或 `XOR` 指令。
- $N$（对于 `add_not` 而言）：要追加的 `NOT` 指令的输入存储单元编号
- $Ns$（对于 `add_and`，`add_or`，`add_xor` 而言）：要追加的 `AND`，`OR` 或 `XOR` 指令的输入存储单元的编号的数组
- 每次函数调用都会返回追加指令的输出存储单位的编号。对这些函数的连续调用将会返回从 $H\cdot W$ 开始的连续整数。

机器人的程序最多可以包含 $10^4$ 条指令。这些指令一共最多只能读入 $10^6$ 个值。换句话说，所有 `add_and`，`add_or` 及 `add_xor` 调用中的 $Ns$ 数组的长度总和再加上 `add_not` 调用的次数不得超过 $10^6$。


当追加完最后一条指令后，函数 `construct_network` 必须返回。所产生的机器人程序会在一些图像上进行评测。对于一幅图像，程序最后一条指令的输出是 $1$ 当且仅当两个黑色像素之间的距离正好为 $K$。如果对测试点中的每幅图像，你的解答所产生的程序都可以正确地输出结果，那就通过了该测试点。

评测程序在评测你的程序时可能会出现以下错误信息：
- `Instruction with no inputs`：一个空数组被作为 `add_and`，`add_or` 或 `add_xor` 的输入。
- `Invalid index`：给 `add_not`，`add_or` 或 `add_xor` 提供了不正确（可能是负数）的存储单元编号作为输入。
- `Too many instructions`：你的函数尝试添加多于 $10^4$ 条的指令。
- `Too many inputs`：程序中的指令一共读取了多于 $10^6$ 个值。
#### 评测程序示例
评测程序示例读取下述格式的输入：
- 第 $1$ 行：$H$，$W$，$K$
- 第 $2+i$ 行（$i\ge0$）：$r1_i$，$c1_i$，$r2_i$，$c2_i$
- 最后一行：$-1$

除第一行和最后一行外，每一行都表示了一幅含有两个黑色像素的图像。记第 $2+i$ 行上的图像为图像 $i$。该图像中，一个黑色像素位于第 $r_1[i]$ 行及第 $c_1[i]$ 列上，令一个黑色像素位于第 $r_2[i]$ 行及第 $c_2[i]$ 列上。

评测程序首先调用 `construct_network(H, W, K)`。若 `construct_network` 违反了题目描述中的限制条件，评测程序示例将会输出在实现细节一节末尾所列举的某条错误信息并退出。

否则，评测程序示例将输出两部分内容。

首先，评测程序示例会以下列格式输出机器人程序所产生的输出：
- 第 $1+i$ 行（$0\le i$）：对于图像 $i$，机器人程序最后一条指令的输出（$1$ 或 $0$）。

其次，评测程序示例会以下列格式输出到当前目录下一个名为 `log.txt` 的文件中：
- 第 $1+i$ 行（$0\le i$）：$m_{i,0}$，$m_{i,1}$，$\dots$，$m_{i,c-1}$

在第 $1+i$ 行上的序列描述以图像 $i$ 作为输入时，在机器人程序运行结束后放在内存中的数据。具体来说，$m_{i,j}$ 是保存在存储单元 $j$ 里面的值。注意，$c$ 的值（序列长度）等于 $H\cdot W$ 再加上机器人程序的指令数。
## 提示

#### 样例
假设 $H=2$，$W=3$，$K=3$。在此情况下，两个黑色像素之间的距离为 $3$ 的图像只有两种。

![](https://cdn.luogu.com.cn/upload/image_hosting/9fec7n4k.png)

- 情况一：黑色像素是 $0$ 和 $5$。
- 情况二：黑色像素是 $2$ 和 $3$。

一种可行的方案是通过以下调用来构造机器人程序：
1. `add_and([0, 5])`，将加入一条指令，当且仅当图像符合情况一时其输出为 $1$。输出结果将保存在存储单元 $6$ 里。
1. `add_and([2, 3])`，将加入一条指令，当且仅当图像符合情况二时其输出为 $1$。输出结果将保存在存储单元 $7$ 里。
1. `add_or([6, 7])`，将加入一条指令，当且仅当上述两种情况之一成立时其输出为 $1$。
#### 数据范围
对于所有数据：
- $1\le H,W\le200$；
- $2\le H\cdot W$；
- $1\le K\le H+W-2$。

详细子任务附加限制与分值如下表：
| 子任务编号 |                           附加限制                           | 分值 |
| :--------: | :----------------------------------------------------------: | :--: |
|    $1$     |                     $\max(H,W) \le 3$                        | $10$ |
|    $2$     |                     $\max(H,W) \le 10$                       | $11$ |
|    $3$     |                     $\max(H,W) \le 30$                       | $11$ |
|    $4$     |                     $\max(H,W) \le 100$                      | $15$ |
|    $5$     |                       $\min(H,W) = 1$                        | $12$ |
|    $6$     |     每幅图像上位于第 $0$ 行且位于第 $0$ 列的那个像素是黑色的         | $8$ |
|    $7$     |                           $K = 1$                            | $14$ |
|    $8$     |                      没有任何附加限制                           | $19$ |


---

---
title: "[IOI 2020] 嘉年华奖券"
layout: "post"
diff: 省选/NOI-
pid: P6831
tag: ['贪心', '2020', '递归', 'IOI', '交互题', 'Special Judge']
---
# [IOI 2020] 嘉年华奖券
## 题目背景

**本题为交互题。**

请在程序开头声明 `void allocate_tickets(std::vector<std::vector<int> > s);` 和使用 vector 头文件，并且请在调用函数前加上 `extern "C"`。
## 题目描述

Ringo 正在参加在新加坡举办的一个嘉年华活动。他的口袋里装有一些奖券，这些奖券可以在嘉年华的游戏展位使用。假设共有 $n$ 种颜色的奖券，每张奖券涂上了其中的一种颜色并且印上了一个非负整数。不同奖券上的数字可能相同。依据嘉年华活动的规则要求，$n$ 保证是偶数。

Ringo 每种颜色的奖券有 $m$ 张，也就是说他共有 $n \cdot m$ 张奖券。其中，第 $i$ 种颜色对应的第 $j$ 张奖券上印的数字为 $x[i][j]$（$0 \le i \le n-1$ 且 $0 \le j \le m-1$）。

一次奖券游戏要进行 $k$ 轮，轮次的序号从 $0$ 到 $k-1$。每一轮按照下面的方式进行：

- 首先，Ringo 从每种颜色的奖券中各选出一张奖券，形成一个 $n$ 张奖券的 **集合**。
- 随后，游戏负责人记录下这个集合中奖券上的数字 $a[0],a[1],\ldots,a[n-1]$。不需要考虑这 $n$ 个整数的顺序。
- 接下来，游戏负责人从一个幸运抽奖箱中抽取一张特殊卡片，上面印有整数 $b$。
- 对于上述集合中每一个奖券上的数字 $a[i](0\le i \le n-1)$，游戏负责人会计算 $a[i]$ 和 $b$ 的差的绝对值。让 $S$ 代表这 $n$ 个差的绝对值之和。
- 所得到的数字 $S$ 就是 Ringo 本轮能够获得的奖励数额。
- 一轮游戏结束后，本轮集合中的奖券全部被丢弃，不会在未来的轮次所使用。

当 $k$ 轮游戏结束后，Ringo 会丢弃口袋中的所有奖券。

通过仔细观察，Ringo 发现这个奖券游戏被操控了！实际上，幸运抽奖箱里面内置了一台打印机。在每一轮，游戏负责人首先找到一个能够最小化当前轮次游戏奖励的整数 $b$，然后将该数字打印在他所抽取的特殊卡片上。

知道了这些信息之后，Ringo 想要设计每轮游戏中的奖券分配方案，使得 $k$ 轮游戏中获得的总体奖励数额之和最大。

#### 实现细节

你需要实现下面这个函数：

```cpp
long long find_maximum(int k,std::vector<std::vector<int>> x)
```

- $k$：游戏的轮数。
- $x$：一个 $n \times m$ 的数组，记录了奖券上的数字。每种颜色的奖券按照上面的数字非递减顺序排序。
- 这个函数只会被调用一次。
- 这个函数应该只调用一次函数 `allocate_tickets`（参见下面的内容），它描述了 $k$ 轮游戏中的奖券分配方案，每一轮对应一个奖券集合。奖券的分配方案应该使得所获奖励数额之和达到最大。
- 这个函数需要返回能够获得的最大的奖励数额之和。

函数 `allocate_tickets` 按照如下的方式进行定义：

```cpp
void allocate_tickets(std::vector<std::vector<int>> s)
```
  
- $s$：一个 $n \times m$ 的数组。如果第 $i$ 种颜色的第 $j$ 张奖券如果被分配到了第 $r$ 轮游戏，那么 $s[i][j]$ 的值应该为 $r$；如果未被使用，应该为 $-1$。
- 对于 $0 \le i \le n-1$，在 $s[i][0],s[i][1],\ldots,s[i][m-1]$ 中，每个值 $0,1,\ldots,k-1$ 必须只出现一次，而其他元素应该为 $-1$。
- 如果存在多种奖券分配方案能够达到最优的奖励数值，可以给出其中任何一种最优方案。
## 提示

#### 样例说明

#### 例 1

考虑下面的函数调用：

```cpp
find_maximum(2, [[0, 2, 5],[1, 1, 3]])
  ```
这意味着：

- 游戏共进行 $k=2$ 轮；
- 第 $0$ 种颜色奖券上的整数数字分别是 $0,2$ 和 $5$；
- 第 $1$ 种颜色奖券上的整数数字分别是 $1,1$ 和 $3$；

一种能够获得最优奖励数值的分配方案是：

- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $0$ 张奖券（印有整数 $0$）和第 $1$ 种颜色的第 $2$ 张奖券（印有整数 $3$）。本轮获得的最小奖励数额是 $3$。例如，游戏负责人可以选择 $b=1$：$|1-0| + |1-3| = 1+2 = 3$。
- 在第 $1$ 轮，Ringo 选择第 $0$ 种颜色的第 $2$ 张奖券（印有整数 $5$）和第 $1$ 种颜色的第 $1$ 张奖券（印有整数 $1$）。本轮能够获得的最小奖励是 $4$。例如，游戏负责人可以选择 $b=3$：$|3-1|+|3-5|=2+2=4$。
- 因此，本次游戏两轮的奖励之和为 $3+4=7$。

为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：

```cpp
allocate_tickets([[0, -1, 1], [-1, 1, 0]])
```
  
  最终，函数 `find_maximum` 应该返回数字 $7$。
  
#### 例 2

考虑下面的函数调用：

```cpp
find_maximum(1, [[5, 9], [1, 4], [3, 6], [2, 7]])
```

这意味着：

- 游戏只进行一轮；
- 第 $0$ 种颜色奖券上的数字分别是 $5$ 和 $9$；
- 第 $1$ 种颜色奖券上的数字分别是 $1$ 和 $4$；
- 第 $2$ 种颜色奖券上的数字分别是 $3$ 和 $6$；
- 第 $3$ 种颜色奖券上的数字分别是 $2$ 和 $7$；

一种能够获得最优奖励的分配方案是：

- 在第 $0$ 轮，Ringo 选择第 $0$ 种颜色的第 $1$ 张奖券（印有整数 $9$），第 $1$ 种颜色的第 $0$ 张奖券（印有整数 $1$），第 $2$ 种颜色的第 $0$ 张奖券（印有整数 $3$），第 $3$ 种颜色的第 $1$ 张奖券（印有整数 $7$）。本轮能够获得的最小奖励是 $12$。例如，游戏负责人可以选择 $b=3$：$|3-9| + |3-1| + |3-3| + |3-7| = 6 + 2 + 0 + 4 = 12$。

为了给出这个分配方案，函数 `find_maximum` 应该按照如下方式调用 `allocate_tickets`：

```cpp
allocate_tickets([[-1, 0], [0, -1], [0, -1], [-1, 0]])
```

最终，函数 `find_maximum` 应该返回数字 $12$。

#### 约束条件

- $2\le n\le 1500$ 且 $n$ 为偶数
- $1\le k\le m\le 1500$
- $0 \le x[i][j] \le 10^9$（对于所有的 $0 \le i \le n-1$ 且 $0 \le j \le m-1$）
- $x[i][j-1] \le x[i][j]$（对于所有的 $0 \le i \le n-1$ 且 $0 \le j \le m-1$）

#### 子任务

1. （11 分）$m=1$
2. （16 分）$k=1$
3. （14 分）$0 \le x[i][j] \le 1$（对于所有的 $0 \le i \le n-1$ 且 $0 \le j \le m-1$）
4. （14 分）$k=m$
5. （12 分）$n,m \le 80$
6. （23 分）$n,m \le 300$
7. （10 分）没有额外约束条件

#### 评测程序示例

评测程序示例按照下面的格式读入数据：

第 $1$ 行：$n\ m\ k$        
第 $2+i$ 行（$0 \le i \le n-1$）：$x[i][0]\ x[i][1]\ \ldots \ x[i][m-1]$

评测程序示例按照下面的格式打印你的答案：

第 $1$ 行：`find_maximum` 的返回值       
第 $2+i$ 行（$0 \le i \le n-1$）：$s[i][0]\ s[i][1]\ \ldots\ s[i][m-1]$


---

---
title: "[IOI 2020] 装饼干"
layout: "post"
diff: 省选/NOI-
pid: P6836
tag: ['动态规划 DP', '2020', 'IOI', '交互题', 'Special Judge']
---
# [IOI 2020] 装饼干
## 题目描述

Khong 阿姨在组织一场有 $x$ 位选手参加的竞赛，她打算给每位选手一 **袋饼干**。总共有 $k$ 种不同类型的饼干，编号为从 $0$ 到 $k-1$。类型为 $i(0 \le i \le k-1)$ 的每块饼干都有一个 **口味值** $2^i$。在 Khong 阿姨的食品储藏室里，有 $a[i]$（有可能为 $0$）块类型为 $i$ 的饼干。

对每种类型的饼干，Khong 阿姨在每个袋子都会装上 $0$ 或者多块。所有袋子里面类型为 $i$ 的饼干的总块数不能超过 $a[i]$。一个袋子里面所有饼干的口味值的总和，被称为这袋饼干的 **总口味值**。

请帮 Khong 阿姨算一下，究竟存在多少不同的 $y$ 值，使得她可以装出 $x$ 袋饼干，而且每袋饼干的总口味值都等于 $y$。

#### 实现细节

你需要实现下面的这个函数：

```cpp
int64 count_tastiness(int64 x, int64[] a)
```

- $x$：需要装的饼干袋的数量。
- $a$：长度为 $k$ 的数组。对 $0 \le i \le k-1$，$a[i]$ 表示在食物储藏室里类型为 $i$ 的饼干数量。
- 此函数应当返回不同 $y$ 值的数目，使得阿姨可以装出 $x$ 袋饼干，且每袋饼干的总口味值都为 $y$。
- 此函数会被调用 $q$ 次 (对于允许的 $q$ 值，详见约束条件和子任务部分)。每次调用应当被看成是独立的场景。
## 提示

#### 样例说明

#### 例 1

考虑如下调用：

```cpp
count_tastiness(3, [5, 2, 1])
```

这意味着阿姨打算装 $3$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：

- $5$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，
- $2$ 块类型为 $1$ 的饼干，每块的口味值为 $2$，
- $1$ 块类型为 $2$ 的饼干，其口味值为 $4$。

$y$ 能够取的值为 $[0,1,2,3,4]$。举例来说，为了装出总口味值均为 $3$ 的 $3$ 袋饼干，阿姨可以这样装：

- 一袋饼干里有 $3$ 块类型为 $0$ 的饼干，以及
- 两袋饼干，其中各有一块类型为 $0$ 的饼干和一块类型为 $1$ 的饼干。

由于总共有 $5$ 个可能的 $y$ 值，函数应当返回 $5$。

![](https://cdn.luogu.com.cn/upload/image_hosting/db3xoxfy.png)

#### 例 2

考虑如下调用：

```cpp
count_tastiness(2, [2, 1, 2])
```

这意味着阿姨打算装 $2$ 袋饼干，而在食物储藏室里总共有 $3$ 种类型的饼干：

- $2$ 块类型为 $0$ 的饼干，每块的口味值为 $1$，
- $1$ 块类型为 $1$ 的饼干，其口味值为 $2$，
- $2$ 块类型为 $2$ 的饼干，每块的口味值为 $4$。

$y$ 能够取的值为 $[0,1,2,4,5,6]$。由于总共有 $6$ 个可能的 $y$ 值，函数应当返回 $6$。

#### 约束条件

- $1 \le k \le 60$
- $1 \le q \le 1000$
- $1 \le x \le 10^{18}$
- $0 \le a[i] \le 10^{18}$（对于所有的 $0 \le i \le k-1$）
- 对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^{18}$。

#### 子任务

1. (9 分) $q \le 10$，且对于 `count_tastiness` 的每次调用，食物储藏室里所有饼干的口味值总和都不会超过 $10^5$。
2. (12 分) $x=1,q \le 10$
3. (21 分) $x \le 10^4,q \le 10$
4. (35 分) 对于 `count_tastiness` 的每次调用，正确的返回结果都不会超过 $2 \times 10^5$。
5. (23 分) 没有附加限制条件。

#### 评测程序示例

评测程序示例将读取如下格式的输入数据。第一行包含一个整数 $q$。接下来是 $q$ 对这样的两行：它们按照下面的格式来描述一个单独的场景：

第 $1$ ⾏：$k\ x$       
第 $2$ ⾏：$a[0]\ a[1]\ \ldots\ a[k-1]$

评测程序示例的输出结果的格式如下：

第 $i$ 行 ($1 \le i \le q$)：`count_tastiness` 对于输入数据中第 $i$ 个场景的返回值。


---

---
title: "[IOI 2022] 鲶鱼塘"
layout: "post"
diff: 省选/NOI-
pid: P8490
tag: ['2022', 'IOI', '交互题']
---
# [IOI 2022] 鲶鱼塘
## 题目背景

# 滥用评测资源者封号

### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。

原题时间限制 1s，为了节约评测资源，时间限制修改为 0.5s。
## 题目描述

Bu Dengklek 有一个鲶鱼塘。这个鲶鱼塘是由 $N \times N$ 个网格单元构成的池塘。每个单元都是相同大小的正方形。网格各列自西向东编号为从 $0$ 到 $N - 1$，各行自南向北编号为从 $0$ 到 $N - 1$。我们把坐落在网格第 $c$ 列第 $r$ 行处（$0 \le c \le N - 1$，$0 \le r \le N - 1$）的单元记为单元 $(c, r)$。

池塘里总共有 $M$ 条鲶鱼，编号为从 $0$ 到 $M - 1$，分别位于**不同的**单元中。对每个满足 $0 \le i \le M - 1$ 的 $i$，鲶鱼 $i$ 在单元 $(X_i, Y_i)$ 中，其重量为 $W_i$ 克。

Bu Dengklek 想造些长堤来抓鲶鱼。在第 $c$ 列中长度为 $k$ 的长堤（对于所有 $0 \le c \le N - 1$ 和 $1 \le k \le N$），是一个从第 $0$ 行跨到第 $k - 1$ 行的矩形，盖住单元 $(c, 0), (c, 1), \ldots, (c, k - 1)$。对于每一列，Bu Dengklek 可以按照她自己选择的某个长度造长堤，也可以不造。

鲶鱼 $i$（对所有满足 $0 \le i \le M - 1$ 的 $i$）能被抓住，如果有某个长堤紧邻它的西侧或东侧，而且没有长堤盖住它所在的单元；也就是说，如果
* 单元 $(X_i - 1, Y_i)$ 或 $(X_i + 1, Y_i)$ 中 **至少有一个** 被某个长堤盖住，而且
* 没有长堤盖住单元 $(X_i, Y_i)$。

例如，考虑尺寸为 $N = 5$，有 $M = 4$ 条鲶鱼的池塘：

* 鲶鱼 $0$ 在单元 $(0, 2)$ 中，重量为 $5$ 克。
* 鲶鱼 $1$ 在单元 $(1, 1)$ 中，重量为 $2$ 克。
* 鲶鱼 $2$ 在单元 $(4, 4)$ 中，重量为 $1$ 克。
* 鲶鱼 $3$ 在单元 $(3, 3)$ 中，重量为 $3$ 克。

Bu Dengklek 可以这样来造长堤：

| 造长堤前 | 造长堤后 |
| :---: | :---: |
| ![](https://cdn.luogu.com.cn/upload/image_hosting/2rcnqc7k.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/yesaiovt.png) |

单元中的数字表示该单元中鲶鱼的重量。
阴影单元被长堤盖住。
在该场景中，鲶鱼 $0$（在单元 $(0, 2)$ 中）和鲶鱼 $3$（在单元 $(3, 3)$ 中）能被抓住。
鲶鱼 $1$（在单元 $(1, 1)$ 中）没被抓住，因为有一个长堤盖住了它所在的单元；鲶鱼 $2$（在单元 $(4, 4)$ 中）没被抓住，因为没有长堤紧邻它的西侧或东侧。

Bu Dengklek 希望造出来的长堤能让被抓住的鲶鱼的总重量尽量大。
你的任务是求出 Bu Dengklek 通过造长堤能抓住的鲶鱼的最大总重量。
## 输入格式

你需要实现下面的函数：

```go
int64 max_weights(int N, int M, int[] X, int[] Y, int[] W)
```

* $N$：池塘的尺寸。
* $M$：鲶鱼的数量。
* $X$, $Y$：长度为 $M$ 的两个数组，给出鲶鱼的位置。
* $W$：长度为 $M$ 的数组，给出鲶鱼的重量。
* 该函数需要返回一个整数，表示 Bu Dengklek 通过造长堤能抓住的鲶鱼的最大总重量。
* 该函数将被恰好调用一次。
## 输出格式

考虑如下调用：

```go
max_weights(5, 4, [0, 1, 4, 3], [2, 1, 4, 3], [5, 2, 1, 3])
```

该例子的解释请见前面的题面。

在造完所述的长堤后，Bu Dengklek 能抓住鲶鱼 $0$ 和 $3$，其总重量为 $5 + 3 = 8$ 克。
因为无法造出能够抓住总重量超过  $8$ 克的鲶鱼的长堤，函数应当返回 $8$。
## 提示

### 约束条件

* $2 \le N \le 100\;000$
* $1 \le M \le 300\;000$
* $0 \le X_i \le N - 1$，$0 \le Y_i \le N - 1$（对所有满足 $0 \le i \le M - 1$ 的 $i$）
* $1 \le W_i \le 10^9$（对所有满足 $0 \le i \le M - 1$ 的 $i$）
* 任意两条鲶鱼都不会在同一单元中。
  换句话说，$X_i \neq X[j]$ 或 $Y_i \neq Y[j]$（对于所有满足 $0 \le i \lt j \le M - 1$ 的 $i$ 和 $j$）。

### 子任务

1. （3 分） $X_i$ 是偶数（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （6 分） $X_i \le 1$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （9 分） $Y_i = 0$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （14 分） $N \le 300$，$Y_i \le 8$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （21 分） $N \le 300$
1. （17 分） $N \le 3000$
1. （14 分） 在每列中至多有 $2$ 条鲶鱼。
1. （16 分） 没有额外限制。

### 评测程序示例

评测程序示例读取如下格式的输入：

* 第 $1$ 行：$N \; M$
* 第 $2 + i$ 行（$0 \le i \le M - 1$）：$X_i \; Y_i \; W_i$

评测程序示例将按照如下格式打印你的答案：

* 第 $1$ 行：`max_weights` 的返回值

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `int` | `int64`     | `int[]`            |
| ------- | ----- | ----------- | ------------------ |
| `void ` | `int` | `long long` | `std::vector<int>` |

| `int[][]`                       | 数组 `a` 的长度 |
| ------------------------------- | ------------------- |
| `std::vector<std::vector<int>>` | `a.size()`          |



---

---
title: "[IOI 2022] 最罕见的昆虫"
layout: "post"
diff: 省选/NOI-
pid: P8494
tag: ['2022', 'IOI', '交互题', 'Special Judge']
---
# [IOI 2022] 最罕见的昆虫
## 题目背景

# 滥用评测资源者封号

**本题为交互题。**

您**不需要也不应该**在提交的程序中包含 `insects.h` 头文件和主函数。

但是在您的程序中，需要声明以下三个函数：

```cpp
void move_inside(int i);
void move_outside(int i);
int press_button();
```

例如，您的程序可以是这样：

```cpp
#include <bits/stdc++.h>
using namespace std;

void move_inside(int i);
void move_outside(int i);
int press_button();

int min_cardinality(int N) {
	// Code Here
}
```
## 题目描述

Pak Blangkon 的房子四周有 $N$ 只昆虫，编号为 $0$ 至 $N-1$。每只昆虫有一个**类型**，以从 $0$ 至 $10^9$（包含 $0$ 和 $10^9$）的整数编号。可能有多只昆虫类型相同。

假设将昆虫按照类型分组。我们定义**最常见**昆虫类型的基数是昆虫最多的分组中的昆虫数。类似地，**最罕见**昆虫类型的基数是昆虫最少的分组中的昆虫数。

例如，假设有 $11$ 只昆虫，类型分别为 $[5, 7, 9, 11, 11, 5, 0, 11, 9, 100, 9]$。在此情形中，**最常见**昆虫类型的基数是 $3$，是因为类型 $9$ 和类型 $11$ 的分组均有最多数目的昆虫，每个分组都有 $3$ 只。**最罕见**昆虫类型的基数是 $1$，是因为类型 $7$、类型 $0$ 和类型 $100$ 的分组均有最少数目的昆虫，每个分组都有 $1$ 只。

Pak Blangkon 不知道这些昆虫的类型。他有一台单按钮的机器，可以提供昆虫类型相关的信息。刚开始时，机器是空的。在使用机器时，可以做如下三种操作：

1. 将一只昆虫放进机器。
2. 将一只昆虫取出机器。
3. 按下机器的按钮。

每种操作最多可以做 $40\;000$ 次。

每当按下按钮时，机器会报告在机器内的**最常见**昆虫类型的基数。

你的任务是使用上述机器，确定 Pak Blangkon 的房子四周所有 $N$ 只昆虫中**最罕见**昆虫类型的基数。此外，在某些子任务里，你的得分取决于机器执行某种操作的最大次数（详见子任务一节）。
## 输入格式

你要实现以下函数：

```go
int min_cardinality(int N)
```

- $N$：昆虫数量。
- 此函数应返回 Pak Blangkon 的房子四周所有 $N$ 只昆虫中**最罕见**昆虫类型的基数。
- 此函数恰好被调用一次。

该函数可调用以下几个函数：

```go
void move_inside(int i)
```

- $i$：将被放进机器的昆虫编号。编号 $i$ 的取值范围是 $0$ 至 $N-1$（包含 $0$ 和 $N-1$）。
- 如果昆虫已在机器内，函数调用不会影响机器内昆虫的集合。但是，调用仍会被计入此类操作的次数。
- 此函数最多可以被调用 $40\;000$ 次。

```go
void move_outside(int i)
```

- $i$：将被从机器中取出的昆虫编号。编号 $i$ 的取值范围是 $0$ 至 $N-1$（包含 $0$ 和 $N-1$）。
- 如果昆虫已在机器外，函数调用不会影响机器内昆虫的集合。但是，调用仍会被计入此类操作的次数。
- 此函数最多可以被调用 $40\;000$ 次。

```go
int press_button()
```

- 此函数返回机器内**最常见**昆虫类型的基数。
- 此函数最多可以被调用 $40\;000$ 次。
- 评测程序**不是适应性**的。也就是说，所有 $N$ 只昆虫的类型在 `min_cardinality` 调用前已经确定。

## 输出格式

考虑在某个场景下，有 $6$ 只类型分别为 $[5, 8, 9, 5, 9, 9]$ 的昆虫。
函数 `min_cardinality` 的调用方式如下：

```go
min_cardinality(6)
```

此函数按以下次序调用了 `move_inside`、`move_outside` 和 `press_button`。

|     函数调用      |  返回值  |       机器内的昆虫       |   机器内的昆虫类型   |
| :---------------: | :------: | :----------------------: | :------------------: |
|                   | $\\{\\}$ |          $[\ ]$          |
| `move_inside(0)`  |          |        $\\{0\\}$         |        $[5]$         |
| `press_button()`  |   $1$    |        $\\{0\\}$         |        $[5]$         |
| `move_inside(1)`  |          |       $\\{0, 1\\}$       |       $[5, 8]$       |
| `press_button()`  |   $1$    |       $\\{0, 1\\}$       |       $[5, 8]$       |
| `move_inside(3)`  |          |     $\\{0, 1, 3\\}$      |     $[5, 8, 5]$      |
| `press_button()`  |   $2$    |     $\\{0, 1, 3\\}$      |     $[5, 8, 5]$      |
| `move_inside(2)`  |          |    $\\{0, 1, 2, 3\\}$    |    $[5, 8, 9, 5]$    |
| `move_inside(4)`  |          |  $\\{0, 1, 2, 3, 4\\}$   |  $[5, 8, 9, 5, 9]$   |
| `move_inside(5)`  |          | $\\{0, 1, 2, 3, 4, 5\\}$ | $[5, 8, 9, 5, 9, 9]$ |
| `press_button()`  |   $3$    | $\\{0, 1, 2, 3, 4, 5\\}$ | $[5, 8, 9, 5, 9, 9]$ |
| `move_inside(5)`  |          | $\\{0, 1, 2, 3, 4, 5\\}$ | $[5, 8, 9, 5, 9, 9]$ |
| `press_button()`  |   $3$    | $\\{0, 1, 2, 3, 4, 5\\}$ | $[5, 8, 9, 5, 9, 9]$ |
| `move_outside(5)` |          |  $\\{0, 1, 2, 3, 4\\}$   |  $[5, 8, 9, 5, 9]$   |
| `press_button()`  |   $2$    |  $\\{0, 1, 2, 3, 4\\}$   |  $[5, 8, 9, 5, 9]$   |

至此，已有充分信息表明，最罕见昆虫类型的基数是 $1$。
因此，函数 `min_cardinality` 应返回 $1$。

在这个例子里，`move_inside` 被调用 $7$ 次，`move_outside` 被调用 $1$ 次，`press_button` 被调用 $6$ 次。
## 提示

### 约束条件

- $2 \le N \le 2000$。

### 子任务

1. （10 分） $N \le 200$；
2. （15 分） $N \le 1000$；
3. （75 分） 没有额外的约束条件。

如果在某个测试用例上，函数 `move_inside`、`move_outside` 或 `press_button` 的调用次数不符合“实现细节”中给出的约束条件，或者 `min_cardinality` 的返回值不正确，你的解答在此子任务上得分为 $0$。

令 $q$ 为以下三个值的 **最大值**：`move_inside` 的调用次数、`move_outside` 的调用次数、`press_button` 的调用次数。

在子任务 3 中，你可能会得部分分。令 $m$ 为此子任务所有测试用例的 $\frac{q}{N}$ 的最大值。你在此子任务的得分将根据以下表格计算：

|       条件       |                   得分                   |
| :--------------: | :--------------------------------------: |
|    $20 \lt m$    | $0$ （CMS 报告“`Output isn’t correct`”） |
| $6 \lt m \le 20$ |           $\frac{225}{m - 2}$            |
| $3 \lt m \le 6$  |          $81 - \frac{2}{3} m^2$          |
|    $m \le 3$     |                   $75$                   |

### 评测程序示例

令 $T$ 是长度为 $N$ 的整数数组，其中 $T[i]$ 是编号为 $i$ 的昆虫的类型。

评测程序示例按以下格式读取输入：

- 第 $1$ 行：$N$；
- 第 $2$ 行：$T[0] \; T[1] \; \ldots \; T[N - 1]$。

如果评测程序示例检测到非法行为，评测程序示例将输出 `Protocol Violation: <MSG>`，其中 `<MSG>` 为如下某种类型：

<!-- IMPORTANT NOTE TO TRANSLATORS: THESE MESSAGES (IN BACKTICKS), AS WELL AS 'Protocol Violation:' ABOVE SHOULD NOT BE TRANSLATED -->

- `invalid parameter`：在函数调用 `move_inside` 或 `move_outside` 时，参数 $i$ 的值不在 $0$ 至 $N-1$ 的范围内（包括 $0$ 和 $N-1$）。
- `too many calls`：函数 `move_inside`、`move_outside` 或 `press_button` 中**某个**的调用次数超过 $40\;000$ 次。

否则，评测程序示例按以下格式输出：

- 第 $1$ 行：`min_cardinality` 的返回值；
- 第 $2$ 行：$q$。

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `bool` | `int` | `int[]`            |
| ------- | ------ | ------| ------------------ |
| `void ` | `bool` | `int` | `std::vector<int>` |

| `union(bool, int[])`                   | 数组 `a` 的长度 |
| -------------------------------------- | ------------------- |
| `std::variant<bool, std::vector<int>>` | `a.size()`          |

C++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。
一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。
以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：

```cpp
std::variant<bool, std::vector<int>> foo(int N) {
    return N % 2 == 0;
}

std::variant<bool, std::vector<int>> goo(int N) {
    return std::vector<int>(N, 0);
}

std::variant<bool, std::vector<int>> hoo(int N) {
    if (N % 2 == 0) {
        return false;
    }

    return std::vector<int>(N, 0);
}
```


---

---
title: "[IOI 2009] Hiring"
layout: "post"
diff: 省选/NOI-
pid: P9113
tag: ['2009', 'IOI', 'Special Judge', 'O2优化']
---
# [IOI 2009] Hiring
## 题目背景

IOI2009 D1T2
## 题目描述

你需要为一个建设项目雇佣一些工人。现在有 $N$ 位候选工人，标号为 $1\sim N$。第 $k$ 个工人要求如果自己被雇佣，则必须得到至少 $S_k$ 美元的工资。每个工人有能力值 $Q_k$。建筑业监管局规定，你必须按工人们的能力值的比例分配他们的工资。例如，如果 $Q_A = 3Q_B$，则你付给 $A$ 的工资必须恰为 $B$ 的三倍。你可以付给你的工人们任意非负实数金额的工资。

你的手上有 $W$ 美元，你想用这些钱雇佣最大数量的工人。你可以决定选用哪些工人以及付给他们的工资，但必须满足每个工人的最低工资要求以及监管局的分配规定，并保证工资总额不超过 $W$。

工人们的能力值和你的项目无关，因此你只想最大化雇佣工人的数量，而不关心他们的能力值。尽管如此，你仍希望最小化你的支出，即如果存在多种方案，则你需要选择支付给工人们的工资总额最小的那一个。如果仍存在多种方案，任意一个都是满足要求的。

**任务**：编写一个程序，给定每个工人的工资要求和能力值，以及你拥有的资金，计算出具体雇佣哪些工人。你必须在最大化工人的数量的前提下最小化支出，并满足上文提到的监管局的要求。
## 输入格式

第一行包含两个由空格隔开的整数 $N, W$，分别表示候选工人数和你拥有的资金。

接下来 $N$ 行，每行描述一个候选工人。其中第 $k$ 行描述第 $k$ 个候选工人，包含两个由空格隔开的整数 $S_k, Q_k$。
## 输出格式

第一行一个整数 $H$，表示你雇佣的工人数量。

接下来 $H$ 行，每行一个整数，表示你雇佣的所有工人的编号（互不相同），以任意顺序排列。
## 样例

### 样例输入 #1
```
4 100
5 1000
10 100
8 10
20 1

```
### 样例输出 #1
```
2
2
3

```
### 样例输入 #2
```
3 4
1 2
1 3
1 3

```
### 样例输出 #2
```
3
1
2
3
```
## 提示

### 样例解释

- 样例 1：选择工人 $2$ 和 $3$ 是唯一符合所有要求且雇佣了两个工人的方案。你可以分别付给他们 $80$ 美元和 $8$ 美元，满足 $100$ 美元的预算。

- 样例 2：你可以雇佣三个工人。你可以分别付给他们 $1$ 美元，$1.5$ 美元和 $1.5$ 美元。

### 数据范围与约定

对于任意测试点，如果你的方案满足了所有要求和你的目标，你将获得该测试点的满分。**否则**，如果你的第一行是正确的，即你输出了正确的工人数量 $H$，无论你接下来的输出是否符合格式，你都将获得该测试点 $50\%$ 的分数。

注意，在实际评测中，只有你的输出符合格式，才能获得测试点 $50\%$ 或 $100\%$ 的分数。

- 对于 $50\%$ 的数据，$N\leq 5000$。
- 对于 $100\%$ 的数据，$1\leq N\leq 5\times 10 ^ 5$，$1\leq S_k, Q_k\leq 2\times 10 ^ 4$，$1\leq W\leq 10 ^ {10}$。

注意，$W$ 超出了 $32$ 位整形变量的存储范围。你需要使用 $64$ 位整型变量存储 $W$，例如 C/C++ 中的 `long long` 或 Pascal 中的 `int64`。


---

---
title: "[IOI 2023] 封锁时刻"
layout: "post"
diff: 省选/NOI-
pid: P9600
tag: ['2023', 'IOI', '交互题', 'O2优化']
---
# [IOI 2023] 封锁时刻
## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。
## 题目描述

匈牙利有 $N$ 个城市，编号依次为 $0$ 到 $N - 1$。

这些城市之间由 $N - 1$ 条双向道路连接，编号为 $0$ 至 $N - 2$。对每个 $j$（$0 \le j \le N - 2$），第 $j$ 条道路连接城市 $U[j]$ 和城市 $V[j]$，其长度为 $W[j]$，表示这两个城市之间的交通时间为 $W[j]$ 个时间单位。每条道路连接两个不同的城市，且每两个城市之间最多由一条道路连接。

两个不同城市 $a$ 和 $b$ 之间的一条**路径**是一个由不同城市组成的序列 $p_0, p_1, \ldots, p_t$，满足以下条件：
 * $p_0 = a$， 
 * $p_t = b$， 
 * 对每个 $i$（$0 \le i \lt t$），存在一条道路连接 $p_i$ 和 $p_{i + 1}$。

利用这些道路从任意一个城市到任意一个其他的城市都是有可能的。换言之，任意两个不同城市之间都存在路径。  
可以证明两个不同城市之间的路径是唯一的。

一条路径 $p_0, p_1, \ldots, p_t$ 的**长度**是这条路径上连接相邻城市的 $t$ 条道路的长度之和。

在匈牙利，很多人都会在建国日去参加在两个主要城市举行的庆祝活动。当庆祝活动结束时，他们会回家。政府为了防止人群干扰当地人，所以决定在特定时刻封锁城市。每个城市被政府分配一个非负的**封锁时刻**。政府决定所有城市的封锁时刻总和不得超过 $K$。具体来说，对每个 $i$（$0 \leq i \leq N - 1$），分配给城市 $i$ 的封锁时刻是一个非负整数  $c[i]$。所有  $c[i]$ 之和不超过 $K$。

考虑一个城市 $a$ 和某个封锁时刻的分配方案，我们说城市 $b$ 是从城市 $a$ 可达的当且仅当以下两种情况中的任意一种情况成立。

情况 1：$b = a$。

情况 2：这两个城市之间的路径  $p_0, \ldots, p_t$ （$p_0 = a$ 且 $p_t = b$）满足以下条件：
* 路径 $p_0, p_1$ 的长度最多为 $c[p_1]$，并且
* 路径 $p_0, p_1, p_2$ 的长度最多为 $c[p_2]$，并且
* $\ldots$
* 路径 $p_0, p_1, p_2, \ldots, p_t$ 的长度最长为  $c[p_t]$。

今年，两个主要的庆祝地点位于城市 $X$ 和 $Y$。  
对于每一个封锁时刻的分配方案，可以定义一个**便利分数**，其定义为下面两个数字之和：
- 从城市 $X$ 可达的城市个数。
- 从城市 $Y$ 可达的城市个数。

注意如果一个城市既能从城市 $X$ 可达也能从城市 $Y$ 可达，那么它在计算便利分数时计算两次。

你的任务是计算能被某个封锁时刻分配方案实现的最大便利分数。
## 输入格式

令 $C$ 表示场景数，即调用 `max_score` 的次数。
评测程序实例按以下格式读取输入：

* 第 $1$ 行：$C$

以下是 $C$ 个场景的描述。

评测程序实例按以下格式读取每个场景的描述：

* 第 $1$ 行：$N \; X \; Y \; K$
* 第 $2 + j$ 行（$0 \le j \le N - 2$）：$U[j] \; V[j] \; W[j]$
## 输出格式

评测程序实例按以下格式为每个场景打印单独一行

* 第 $1$ 行： `max_score` 的返回值
## 样例

### 样例输入 #1
```
2
7 0 2 10
0 1 2
0 3 3
1 2 4
2 4 2
2 5 5
5 6 3
4 0 3 20
0 1 18
1 2 1
2 3 19

```
### 样例输出 #1
```
6
3

```
## 提示

#### 【实现细节】

你要实现以下函数。

```
int max_score(int N, int X, int Y, int64 K, int[] U, int[] V, int[] W)
```

* $N$：城市的个数
* $X$，$Y$：两个主要庆祝城市
* $K$：封锁时刻总和的上界
* $U$，$V$： 长度为 $N - 1$ 的描述道路连接情况的数组
* $W$：长度为 $N - 1$ 的描述道路长度的数组
* 该函数要返回能被某个封锁时刻分配方案实现的最大便利分数
* 每个测试用例可以多次调用该函数



#### 【例子】


考虑以下调用：

```
max_score(7, 0, 2, 10,
          [0, 0, 1, 2, 2, 5], [1, 3, 2, 4, 5, 6], [2, 3, 4, 2, 5, 3])
```



这对应以下道路网络：

![](https://cdn.luogu.com.cn/upload/image_hosting/wf5uw4qd.png)



假设封锁时刻如下分配：

| **城市**         | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ |
|:----------------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **封锁时刻** | $0$ | $4$ | $0$ | $3$ | $2$ | $0$ | $0$ |



注意所有封锁时刻之和为 $9$，不超过 $K = 10$。城市 $0$，$1$ 和 $3$ 都是从城市 $X$（$X = 0$）可达的，而城市 $1$，$2$ 和 $4$ 都可以从城市 $Y$（$Y  = 2$）可达。 因此，便利分数为 $3+3 = 6$。不存在封锁时刻分配方案使得便利分数大于 $6$，所以该函数应该返回 $6$。



考虑另外一个调用：

```
max_score(4, 0, 3, 20, [0, 1, 2], [1, 2, 3], [18, 1, 19])
```



这对应以下道路网络：

![](https://cdn.luogu.com.cn/upload/image_hosting/zcw4gdi5.png)

假设封锁时间如下分配：

| **城市**         | $0$ | $1$ | $2$ | $3$ |
|:----------------:|:---:|:---:|:---:|:---:|
| **封锁时刻** | $0$ | $1$ | $19$| $0$ |



城市 $0$ 从城市 $X$（$X = 0$）可达，而城市 $2$ 和 $3$ 都是可以从城市 $Y$（$Y=3$）可达的。因此，便利分数是 $1 + 2 = 3$。不存在封锁时刻分配方案使得便利分数大于 $3$，所以函数应该返回 $3$。

#### 【约束条件】

* $2 \le N \le 200\,000$
* $0 \le X \lt Y \lt N$
* $0 \le K \le 10^{18}$
* $0 \le U[j] \lt V[j] \lt N$ (对每个 $j$ 满足 $0 \le j \le N - 2$)
* $1 \le W[j] \le 10^6$ (对每个 $j$ 满足 $0 \le j \le N - 2$)
* 利用这些道路可以从任意一个城市走到任意另外一个城市。
* $S_N \le 200\,000$，其中 $S_N$ 是所有调用函数 `max_score` 的  $N$ 的总和。


#### 【子任务】


我们说一个道路网络是**线性的**如果道路 $i$ 连接城市 $i$ 和 $i+1$（对每个$0 \le i \le N - 2$ 的 $i$）。

1. （8 分）从城市 $X$ 到城市 $Y$ 的路径长度大于 $2K$。
1. （9 分）$S_N \le 50$，道路网络是线性的。
1. （12 分）$S_N \le 500$，道路网络是线性的。
1. （14 分）$S_N \le 3\,000$，道路网络是线性的。
1. （9 分）$S_N \le 20$
1. （11 分）$S_N \le 100$
1. （10 分）$S_N \le 500$
1. （10 分）$S_N \le 3\,000$
1. （17 分）无额外的约束条件。


---

---
title: "[IOI 2023] 超车"
layout: "post"
diff: 省选/NOI-
pid: P9604
tag: ['2023', 'IOI', '交互题', 'O2优化']
---
# [IOI 2023] 超车
## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。但请勿使用 C++14 (GCC 9)
## 题目描述

从布达佩斯机场到 Forrás 酒店有一条单向单车道的公路，公路的长度为 $L$ 公里。

IOI 2023 活动期间，有 $N+1$ 辆巴士在这条公路上行驶。巴士从 $0$ 到 $N$ 依次编号。巴士 $i$（$0 \le i \lt N$）计划在活动的第 $T[i]$ 秒从机场出发，行驶一公里用时 $W[i]$ 秒。巴士 $N$ 是备用巴士，行驶一公里用时 $X$ 秒。它从机场出发的时间 $Y$ 尚未确定。

巴士在这条公路上行驶时一般不允许超车，但允许在一些被称为**调度站**的地方进行超车。公路上一共有 $M$ 个调度站（$M \gt 1$），从 $0$ 到 $M - 1$ 依次编号，位于公路的不同位置。调度站 $j$（$0 \le j \lt M$）的位置在机场出发后沿公路的 $S[j]$ 公里处。调度站按照从机场开始的距离递增排列，也就是对于每个 $0 \le j \le M - 2$，有 $S[j] \lt S[j+1]$。首个调度站设在机场，最后一个设在酒店。也就是说，$S[0] = 0$，$S[M-1] = L$。

每辆巴士都以指定的最快速度行驶，除非它遇到前面有比它慢的巴士。在这种情况下，后面的快车会被前面的慢车压着，被迫以慢车的速度行驶。这种情况会持续到两车到达下一个调度站。在那里，快车会完成对慢车的超越。

形式化地说，对于满足 $0 \le i \le N$ 且 $0 \le j \lt M$ 的每组 $i$ 和 $j$，巴士 $i$ **到达**调度站 $j$ 的时间 $t_{i,j}$（以秒为单位）定义如下：对于每个 $0 \le i \lt N$，有 $t_{i,0} = T[i]$。另有 $t_{N,0} = Y$。对于满足 $0 \lt j \lt M$ 的每个 $j$：

* 定义巴士 $i$ 到达调度站 $j$ 的**期望到达时间** $e_{i,j}$（以秒为单位）为巴士 $i$ 到达调度站 $j-1$ 之后以全速行驶到达调度站 $j$ 的时间。也就是说，
  - 对于每个 $0 \le i \lt N$，有 $e_{i,j} = t_{i,j-1} + W[i] \cdot (S[j]-S[j-1])$；
  - 另有 $e_{N,j} = t_{N,j-1} + X \cdot (S[j]-S[j-1])$。
* 巴士 $i$ 到达调度站 $j$ 的时间，是巴士 $i$ 到达调度站 $j$ 的期望到达时间，以及其他比巴士 $i$ 早到调度站 $j-1$ 的巴士到达调度站 $j$ 的期望到达时间中的**最大值**。形式化地说，$t_{i,j}$ 是 $e_{i,j}$ 和所有满足 $0 \le k \le N$ 且 $t_{k,j-1} \lt t_{i,j-1}$ 的 $e_{k,j}$ 中的最大值。

IOI 组委会想要调度备用巴士（巴士 $N$）。你的任务是回答组委会的 $Q$ 个问题，问题的形式如下：给定备用巴士从机场出发的时间 $Y$（以秒为单位），它将于何时到达酒店？
## 输入格式

评测程序示例按以下格式读取输入：

* 第 $1$ 行：$L \; N \; X \; M \; Q$
* 第 $2$ 行：$T[0] \; T[1] \; \ldots \; T[N-1]$
* 第 $3$ 行：$W[0] \; W[1] \; \ldots \; W[N-1]$
* 第 $4$ 行：$S[0] \; S[1] \; \ldots \; S[M-1]$
* 第 $5 + k$ 行（$0 \le k \lt Q$）：问题 $k$ 的 $Y$
## 输出格式

评测程序示例按以下格式打印你的答案：

* 第 $1 + k$ 行（$0 \le k \lt Q$）：问题 $k$ 中 `arrival_time` 的返回值
## 样例

### 样例输入 #1
```
6 4 10 4 2
20 10 40 0
5 20 20 30
0 1 3 6
0
50

```
### 样例输出 #1
```
60
130

```
## 提示

**【实现细节】**

你的任务是实现以下函数：

```
void init(int L, int N, int64[] T, int[] W, int X, int M, int[] S)
```

* $L$：公路的长度
* $N$：常规（非备用）巴士的数量
* $T$：长度为 $N$ 的数组，描述常规巴士计划从机场出发的时间。
* $W$：长度为 $N$ 的数组，描述常规巴士的最大速度。
* $X$：备用巴士行驶一公里所需的时间
* $M$：调度站的数量
* $S$：长度为 $M$ 的数组，描述从机场到调度站的距离。
* 对于每个测试用例，这个函数都恰好调用一次，发生在对任何 `arrival_time` 的调用之前。

```
int64 arrival_time(int64 Y)
```

* $Y$：备用巴士（巴士 $N$）计划从机场出发的时间
* 这个函数应该返回备用巴士到达酒店的时间。
* 这个函数恰好调用 $Q$ 次。

---

**【例子】**

考虑以下调用序列：

```
init(6, 4, [20, 10, 40, 0], [5, 20, 20, 30], 10, 4, [0, 1, 3, 6])
```

忽略巴士 $4$（它还没有确定出发时间），下表列出了巴士到达每个调度站的期望时间和实际时间：

| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| $0$ | | $20$ | | $25$ | $30$ | | $40$ | $40$ | | $55$ | $55$ |
| $1$ | | $10$ | | $30$ | $30$ | | $70$ | $70$ | | $130$ | $130$ |
| $2$ | | $40$ | | $60$ | $60$ | | $100$ | $100$ | | $160$ | $180$ |
| $3$ | | $0$ | | $30$ | $30$ | | $90$ | $90$ | | $180$ | $180$ |

巴士到达调度站 $0$ 的时间就是它计划从机场出发的时间。也就是说，对于 $0 \le i \le 3$，$t_{i,0} = T[i]$。

到达调度站 $1$ 的期望时间和实际时间计算如下：

* 调度站 $1$ 的期望到达时间：
  - 巴士 $0$：$e_{0,1} = t_{0,0} + W[0] \cdot (S[1]-S[0]) = 20 + 5 \cdot 1 = 25$。
  - 巴士 $1$：$e_{1,1} = t_{1,0} + W[1] \cdot (S[1]-S[0]) = 10 + 20 \cdot 1 = 30$。
  - 巴士 $2$：$e_{2,1} = t_{2,0} + W[2] \cdot (S[1]-S[0]) = 40 + 20 \cdot 1 = 60$。
  - 巴士 $3$：$e_{3,1} = t_{3,0} + W[3] \cdot (S[1]-S[0]) = 0 + 30 \cdot 1 = 30$。
* 调度站 $1$ 的到达时间：
  - 巴士 $1$ 和 $3$ 早于巴士 $0$ 到达调度站 $0$，所以 $t_{0,1} = \max([e_{0,1},e_{1,1},e_{3,1}]) = 30$。
  - 巴士 $3$ 早于巴士 $1$ 到达调度站 $0$，所以 $t_{1,1} = \max([e_{1,1},e_{3,1}]) = 30$。
  - 巴士 $0$、巴士 $1$ 和巴士 $3$ 早于巴士 $2$ 到达调度站 $0$，所以 $t_{2,1} = \max([e_{0,1},e_{1,1},e_{2,1},e_{3,1}]) = 60$。
  - 没有比巴士 $3$ 更早到达调度站 $0$ 的巴士，所以 $t_{3,1} = \max([e_{3,1}]) = 30$。

```
arrival_time(0)
```

巴士 $4$ 行驶一公里需要 $10$ 秒，现在计划在第 $0$ 秒从机场出发。
这种情况下，下表列出每辆巴士的到达时间。
常规巴士期望和实际到达时间的唯一变动用下划线标注。

| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: |
| $0$ | | $20$ | | $25$ | $30$ | | $40$ | $40$ | | $55$ | $\underline{60}$ |
| $1$ | | $10$ | | $30$ | $30$ | | $70$ | $70$ | | $130$ | $130$ |
| $2$ | | $40$ | | $60$ | $60$ | | $100$ | $100$ | | $160$ | $180$ |
| $3$ | | $0$ | | $30$ | $30$ | | $90$ | $90$ | | $180$ | $180$ |
| $4$ | | $0$ | | $10$ | $10$ | | $30$ | $30$ | | $60$ | $60$ |

由此可知巴士 $4$ 在第 $60$ 秒到达酒店。
因此，函数应该返回 $60$。

```
arrival_time(50)
```

巴士 $4$ 现在计划在第 $50$ 秒从机场出发。
这种情况下，与初始表格相比，常规巴士的到达时间没有变化。
下表列出了到达时间。

| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |
|:--:|:-:|:---------:|:-:|:---------:|:---------:|:-:|:---------:|:---------:|:-:|:---------:|:---------:|
| $0$ | | $20$      | | $25$      | $30$      | | $40$      | $40$      | | $55$      | $55$ |
| $1$ | | $10$      | | $30$      | $30$      | | $70$      | $70$      | | $130$     | $130$ |
| $2$ | | $40$      | | $60$      | $60$      | | $100$     | $100$     | | $160$     | $180$ |
| $3$ | | $0$       | | $30$      | $30$      | | $90$      | $90$      | | $180$     | $180$ |
| $4$ | | $50$      | | $60$      | $60$      | | $80$      | $90$      | | $120$     | $130$ |

巴士 $4$ 和较慢的巴士 $2$ 同时到达调度站 $1$，然后巴士 $4$ 超过了巴士 $2$。
接着，巴士 $4$ 在调度站 $1$ 和 $2$ 之间行驶时被巴士 $3$ 压着，导致它到达调度站 $2$ 的时间是第 $90$ 秒，而不是第 $80$ 秒。
在过了调度站 $2$ 之后，巴士 $4$ 被巴士 $1$ 压着，直到它们到达酒店。
巴士 $4$ 在第 $130$ 秒到达酒店。
因此，函数应该返回 $130$。

将每辆巴士从机场出发到不同距离的时间画成折线图。
图中 x 轴表示从机场出发的距离（以公里为单位），y 轴表示时间（以秒为单位）。
竖的虚线标注了调度站的位置。
不同颜色的实线（标注了巴士的编号）表示四辆常规巴士。
黑色的点线表示备用巴士。

| `arrival_time(0)` | `arrival_time(50)` |
|:-:|:-:|
| ![](https://cdn.luogu.com.cn/upload/image_hosting/rksq53n9.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/ua96w1x2.png) |

---

**【约束条件】**

* $1 \le L \le 10^9$
* $1 \le N \le 1\,000$
* $0 \le T[i] \le 10^{18}$（对于满足 $0 \le i \lt N$ 的每个 $i$）
* $1 \le W[i] \le 10^9$（对于满足 $0 \le i \lt N$ 的每个 $i$）
* $1 \le X \le 10^9$
* $2 \le M \le 1\,000$
* $0 = S[0] \lt S[1] \lt \cdots \lt S[M-1] = L$
* $1 \le Q \le 10^6$
* $0 \le Y \le  10^{18}$

---

**【子任务】**

1. （9 分）$N = 1, Q \le 1\,000$
1. （10 分）$M = 2, Q \le 1\,000$
1. （20 分）$N, M, Q \le 100$
1. （26 分）$Q \le 5\,000$
1. （35 分）没有额外的约束条件。


---


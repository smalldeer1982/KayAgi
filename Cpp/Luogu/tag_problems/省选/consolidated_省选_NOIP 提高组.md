---
title: "[NOIP 2012 提高组] 开车旅行"
layout: "post"
diff: 省选/NOI-
pid: P1081
tag: ['2012', '倍增', 'NOIP 提高组']
---
# [NOIP 2012 提高组] 开车旅行
## 题目描述

小 $\text{A}$ 和小 $\text{B}$ 决定利用假期外出旅行，他们将想去的城市从 $1 $ 到 $n$ 编号，且编号较小的城市在编号较大的城市的西边，已知各个城市的海拔高度互不相同，记城市 $i$ 的海拔高度为$h_i$，城市 $i$ 和城市 $j$ 之间的距离 $d_{i,j}$ 恰好是这两个城市海拔高度之差的绝对值，即 $d_{i,j}=|h_i-h_j|$。
 
旅行过程中，小 $\text{A}$ 和小 $\text{B}$ 轮流开车，第一天小 $\text{A}$ 开车，之后每天轮换一次。他们计划选择一个城市 $s$ 作为起点，一直向东行驶，并且最多行驶 $x$ 公里就结束旅行。    

小 $\text{A}$ 和小 $\text{B}$ 的驾驶风格不同，小 $\text{B}$ 总是沿着前进方向选择一个最近的城市作为目的地，而小 $\text{A}$ 总是沿着前进方向选择第二近的城市作为目的地（注意：本题中如果当前城市到两个城市的距离相同，则认为离海拔低的那个城市更近）。如果其中任何一人无法按照自己的原则选择目的城市，或者到达目的地会使行驶的总距离超出 $x$ 公里，他们就会结束旅行。

在启程之前，小 $\text{A}$ 想知道两个问题：

1、 对于一个给定的 $x=x_0$，从哪一个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值最小（如果小 $\text{B}$ 的行驶路程为 $0$，此时的比值可视为无穷大，且两个无穷大视为相等）。如果从多个城市出发，小 $\text{A}$ 开车行驶的路程总数与小 $\text{B}$ 行驶的路程总数的比值都最小，则输出海拔最高的那个城市。

2、对任意给定的 $x=x_i$ 和出发城市 $s_i$，小 $\text{A}$ 开车行驶的路程总数以及小 $\text B$ 行驶的路程总数。

## 输入格式

第一行包含一个整数 $n$，表示城市的数目。

第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示城市 $1$ 到城市 $n$ 的海拔高度，即 $h_1,h_2 ... h_n$，且每个 $h_i$ 都是互不相同的。

第三行包含一个整数 $x_0$。

第四行为一个整数 $m$，表示给定 $m$ 组 $s_i$ 和 $x_i$。

接下来的 $m$ 行，每行包含 $2$ 个整数 $s_i$ 和 $x_i$，表示从城市$s_i$ 出发，最多行驶 $x_i$ 公里。
## 输出格式

输出共 $m+1$ 行。

第一行包含一个整数 $s_0$，表示对于给定的 $x_0$，从编号为 $s_0$ 的城市出发，小 $\text A$ 开车行驶的路程总数与小 $\text B$ 行驶的路程总数的比值最小。

接下来的 $m$ 行，每行包含 $2$ 个整数，之间用一个空格隔开，依次表示在给定的 $s_i$ 和 $x_i$ 下小 $\text A$ 行驶的里程总数和小 $\text B$ 行驶的里程总数。

## 样例

### 样例输入 #1
```
4 
2 3 1 4 
3 
4 
1 3 
2 3 
3 3 
4 3

```
### 样例输出 #1
```
1 
1 1 
2 0 
0 0 
0 0 
```
### 样例输入 #2
```
10 
4 5 6 1 2 3 7 8 9 10 
7 
10 
1 7 
2 7 
3 7 
4 7 
5 7 
6 7 
7 7 
8 7 
9 7 
10 7
```
### 样例输出 #2
```
2 
3 2 
2 4 
2 1 
2 4 
5 1 
5 1 
2 1 
2 0 
0 0 
0 0
```
## 提示

【样例1说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/zgms0k7y.png)

各个城市的海拔高度以及两个城市间的距离如上图所示。

如果从城市 $1$ 出发，可以到达的城市为 $2,3,4$，这几个城市与城市 $1$ 的距离分别为 $1,1,2$，但是由于城市 $3$ 的海拔高度低于城市 $2$，所以我们认为城市 $3$ 离城市 $1$ 最近，城市 $2$ 离城市 $1$ 第二近，所以小A会走到城市 $2$。到达城市 $2$ 后，前面可以到达的城市为 $3,4$，这两个城市与城市 $2$  的距离分别为 $2,1$，所以城市 $4$ 离城市 $2$ 最近，因此小B会走到城市$4$。到达城市 $4$ 后，前面已没有可到达的城市，所以旅行结束。

如果从城市 $2$ 出发，可以到达的城市为 $3,4$，这两个城市与城市 $2$ 的距离分别为 $2,1$，由于城市 $3$ 离城市 $2$ 第二近，所以小 $\text A$ 会走到城市 $3$。到达城市 $3$ 后，前面尚未旅行的城市为 $4$，所以城市 $4$ 离城市 $3$ 最近，但是如果要到达城市 $4$，则总路程为 $2+3=5>3$，所以小 $\text B$ 会直接在城市 $3$ 结束旅行。

如果从城市 $3$ 出发，可以到达的城市为 $4$，由于没有离城市 $3$ 第二近的城市，因此旅行还未开始就结束了。

如果从城市 $4$ 出发，没有可以到达的城市，因此旅行还未开始就结束了。


【样例2说明】

当 $x=7$ 时，如果从城市 $1$ 出发，则路线为 $1 \to 2 \to 3 \to 8 \to 9$，小 $\text A$ 走的距离为 $1+2=3$，小 $\text B$ 走的距离为 $1+1=2$。（在城市 $1$ 时，距离小 $\text A$ 最近的城市是 $2$ 和 $6$，但是城市 $2$ 的海拔更高，视为与城市 $1$ 第二近的城市，所以小 $\text A$ 最终选择城市 $2$；走到$9$ 后，小 $\text A$ 只有城市 $10$ 可以走，没有第二选择可以选，所以没法做出选择，结束旅行）

如果从城市 $2$ 出发，则路线为 $2 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $3$ 出发，则路线为 $3 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $4$ 出发，则路线为 $4 \to 6 \to 7$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $2,4$。

如果从城市 $5$ 出发，则路线为 $5 \to 7 \to 8$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $5,1$。

如果从城市 $6$ 出发，则路线为 $6 \to 8 \to 9$，小 $\text A$ 和小 $\text B$ 走的距离分别为$5,1$。

如果从城市 $7$ 出发，则路线为 $7 \to 9 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,1$。

如果从城市 $8$ 出发，则路线为 $8 \to 10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$2,0$。

如果从城市 $9$ 出发，则路线为 $9$，小 $\text A$ 和小 $\text B$ 走的距离分别为 $0,0$（旅行一开始就结束了）。

如果从城市 $10$ 出发，则路线为 $10$，小 $\text A$ 和小 $\text B$ 走的距离分别为$0,0$。

从城市 $2$ 或者城市 $4$ 出发小 $\text A$ 行驶的路程总数与小 $\text B$ 行驶的路程总数的比值都最小，但是城市 $2$ 的海拔更高，所以输出第一行为 $2$。

【数据范围与约定】  

对于 $30\%$ 的数据，有$1\le n \le 20,1\le m\le 20$；  
对于$40\%$ 的数据，有$1\le n \le 100,1\le m\le 100$；  
对于 $50\%$ 的数据，有$1\le n \le 100,1\le m\le 1000$；  
对于 $70\%$ 的数据，有$1\le n \le 1000,1\le m\le 10^4$；   
对于 $100\%$ 的数据：$1\le n,m \le 10^5$，$-10^9 \le h_i≤10^9$，$1 \le s_i \le n$，$0 \le x_i \le 10^9$   
数据保证 $h_i$ 互不相同。



---

---
title: "[NOIP 2012 提高组] 疫情控制"
layout: "post"
diff: 省选/NOI-
pid: P1084
tag: ['贪心', '树形数据结构', '2012', '倍增', '二分', 'NOIP 提高组', '排序']
---
# [NOIP 2012 提高组] 疫情控制
## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。

## 输入格式

第一行一个整数 $ n$，表示城市个数。

接下来的 $n-1$ 行，每行 $ 3 $ 个整数，$u,v,w$，每两个整数之间用一个空格隔开，表示从城市 $u $ 到城市 $ v$ 有一条长为 $w$ 的道路。数据保证输入的是一棵树，且根节点编号为 $1$。

接下来一行一个整数 $m$，表示军队个数。

接下来一行 $m $ 个整数，每两个整数之间用一个空格隔开，分别表示这 $m$ 个军队所驻扎的城市的编号。

## 输出格式

一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出 $-1$。

## 样例

### 样例输入 #1
```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2
```
### 样例输出 #1
```
3
```
## 提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题



---

---
title: "[NOIP2024] 树的遍历"
layout: "post"
diff: 省选/NOI-
pid: P11363
tag: ['2024', 'NOIP 提高组']
---
# [NOIP2024] 树的遍历
## 题目描述

小 Q 是一个算法竞赛初学者，正在学习图论知识中的树的遍历。一棵由 $n$ 个结点，$n - 1$ 条边构成的树，初始时所有结点都未被标记，它的遍历过程如下：

1. 选择一个结点 $s$ 作为遍历起始结点，并把该结点打上标记。
2. 假设当前访问的结点为 $u$，寻找任意一个与 $u$ 相邻且未标记的结点 $v$，将 $v$ 作为新的当前访问结点并打上标记。之后再次进入第 $2$ 步。
3. 假设在第 $2$ 步中，与 $u$ 相邻的结点都已被标记，如果 $u = s$ 则遍历过程结束，否则将 $u$ 设为遍历 $u$ 之前的上一个结点并再进入第 $2$ 步。

例如在下面的树中，一种可能的遍历过程如下：
- 选取 $1$ 作为遍历起始结点，并把 $1$ 打上标记；
- $2$ 与 $1$ 相邻且未标记，将 $2$ 设为当前访问结点，并把 $2$ 打上标记。
- $2$ 与 $3$ 相邻且未标记，将 $3$ 设为当前访问结点，并把 $3$ 打上标记。
- $3$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $3$ 之前的结点 $2$。
- $2$ 与 $4$ 相邻且未标记，将 $4$ 设为当前访问结点，并把 $4$ 打上标记。
- $4$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $4$ 之前的结点 $2$。
- $2$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $2$ 之前的结点 $1$。
- $1$ 所有相邻的结点都被标记，且 $1$ 是遍历起始结点，故遍历结束。

![](https://cdn.luogu.com.cn/upload/image_hosting/qsjiky0g.png)

作为一个奇思妙想的学生，小 Q 在学习完上述知识后不满足于以结点为基础的遍历方式，于是开始研究以边为基础的遍历方式。定义两条边**相邻**，当且仅当它们有一个公共的结点。初始时，所有的边都未被标记。这种以边为基础的遍历过程如下：

1. 选择一条边 $b$ 作为遍历起始边，并把该边打上标记。
2. 假设当前访问边为 $e$，寻找任意一条与 $e$ 相邻且未标记的边 $f$，将 $f$ 作为新的当前访问边并打上标记。之后再次进入第 $2$ 步。
3. 假设在第 $2$ 步中，与 $e$ 相邻的边都已被标记，如果 $e = b$ 则遍历过程结束，否则将 $e$ 设为遍历 $e$ 之前的上一条边并再进入第 $2$ 步。

例如在上面的树中，一种可能的遍历过程如下（定义 $\{u, v\}$ 表示连接结点 $u$ 和 $v$ 的边）：

- 选取 $\{1, 2\}$ 作为遍历起始边，并把 $\{1, 2\}$ 打上标记；
- $\{1, 2\}$ 与 $\{2, 3\}$ 相邻且未标记，将 $\{2, 3\}$ 设为当前访问边，并把 $\{2, 3\}$ 打上标记。
- $\{2, 3\}$ 与 $\{2, 4\}$ 相邻且未标记，将 $\{2, 4\}$ 设为当前访问边，并把 $\{2, 4\}$ 打上标记。
- $\{2, 4\}$ 所有相邻的边都被标记，将当前访问边设为遍历 $\{2, 4\}$ 之前的边 $\{2, 3\}$。
- $\{2, 3\}$ 所有相邻的边都被标记，将当前访问边设为遍历 $\{2, 3\}$ 之前的边 $\{1, 2\}$。
- $\{1, 2\}$ 所有相邻的边都被标记，且 $\{1, 2\}$ 是遍历起始边，故遍历结束。

小 Q 惊奇的发现，在这个新的树的遍历过程中，如果将每条边看作一个新的结点，将步骤 $2$ 中的所有新结点 $e$ 和 $f$ 连接一条新边，就会生成一棵由 $n-1$ 个新结点和 $n-2$ 条新边连接成的新树。例如上述遍历过程得到的新树如下（新的结点和新边都用红色表示）：

![](https://cdn.luogu.com.cn/upload/image_hosting/mld0xpqg.png)

现在小 Q 在 $n - 1$ 条边中选择了 $k$ 条关键边。小 Q 想知道，以任意一条关键边作为起始遍历边，通过上述遍历过程能够生成多少种不同的新树。这里两棵树被认为是不同的，当且仅当至少存在某一对新的结点，它们仅在其中一棵树中连有新边。

**由于结果可能很大，你只需要输出其对 $10^9+7$ 取模的结果即可。**
## 输入格式

**本题有多组测试数据。**

输入的第一行包含两个整数 $c, T$，表示测试点的编号和测试数据的组数。在样例中，$c$ 表示该样例与测试点 $c$ 的数据范围相同。

接下来包含 $T$ 组数据，每组数据的格式如下：
- 第一行包含两个整数 $n, k$，表示树的结点数以及小 Q 选择的关键边的数量。
- 接下来 $n - 1$ 行，第 $i$ 行包含两个整数 $u_i, v_i$，表示树上编号为 $i$ 的边连接结点 $u_i$ 和 $v_i$。
- 接下来一行包含 $k$ 个整数 $e_1, e_2, \dots, e_k$，表示小 Q 选择的关键边的编号。保证关键边的编号互不相同。
## 输出格式

对于每组测试数据输出一行，包含一个整数，表示结果对 $10^9 + 7$ 取模的结果。
## 样例

### 样例输入 #1
```
1 1
4 1
1 2
2 3
2 4
1
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
7 1
5 2
1 2
1 3
2 4
2 5
1 3
```
### 样例输出 #2
```
3
```
## 提示

**【样例 1 解释】**

两种可能的新树如下：
- 新结点 $\{1, 2\}$ 和新结点 $\{2, 3\}$ 连新边，新结点 $\{2, 3\}$ 和新结点 $\{2, 4\}$ 连新边。
- 新结点 $\{1, 2\}$ 和新结点 $\{2, 4\}$ 连新边，新结点 $\{2, 4\}$ 和新结点 $\{2, 3\}$ 连新边。

**【样例 2 解释】**

三种可能的新树如下：
- 新结点 $\{1, 2\}$ 和 $\{1, 3\}$，$\{1, 2\}$ 和 $\{2, 4\}$，$\{2, 4\}$ 和 $\{2, 5\}$ 之间分别连新边。该新树可以选择 $\{1, 2\}$ 作为起始遍历边得到。
- 新结点 $\{1, 2\}$ 和 $\{1, 3\}$，$\{1, 2\}$ 和 $\{2, 5\}$，$\{2, 5\}$ 和 $\{2, 4\}$ 之间分别连新边。该新树可以选择 $\{1, 2\}$ 或 $\{2, 4\}$ 作为起始遍历边得到。
- 新结点 $\{1, 2\}$ 和 $\{1, 3\}$，$\{1, 2\}$ 和 $\{2, 4\}$，$\{1, 2\}$ 和 $\{2, 5\}$ 之间分别连新边。该新树可以选择 $\{2, 4\}$ 作为起始遍历边得到。

**【样例 3】**

见附件的 traverse/traverse3.in 与 traverse/traverse3.ans。

该组样例满足 $c = 4$。

**【样例 4】**

见附件的 traverse/traverse4.in 与 traverse/traverse4.ans。

该组样例满足 $c = 7$。

**【样例 5】**

见附件的 traverse/traverse5.in 与 traverse/traverse5.ans。

该组样例满足 $c = 11$。

**【样例 6】**

见附件的 traverse/traverse6.in 与 traverse/traverse6.ans。

该组样例满足 $c = 13$。

**【样例 7】**

见附件的 traverse/traverse7.in 与 traverse/traverse7.ans。

该组样例满足 $c = 15$。

**【样例 8】**

见附件的 traverse/traverse8.in 与 traverse/traverse8.ans。

该组样例满足 $c = 16$。

**【样例 9】**

见附件的 traverse/traverse9.in 与 traverse/traverse9.ans。

该组样例满足 $c = 18$。

**【样例 10】**

见附件的 traverse/traverse10.in 与 traverse/traverse10.ans。

该组样例满足 $c = 19$。

**【样例 11】**

见附件的 traverse/traverse11.in 与 traverse/traverse11.ans。

该组样例满足 $c = 22$。

**【样例 12】**

见附件的 traverse/traverse12.in 与 traverse/traverse12.ans。

该组样例满足 $c = 24$。

**【数据范围】**

对于所有的测试数据，保证：
- $1 \leq T \leq 10$；
- $2 \leq n \leq 10^5$；
- $1 \leq k < n$；
- 对于任意的 $i(1 \leq i \leq n - 1)$，都有 $1 \leq u_i, v_i \leq n$，且构成一颗合法的树。
- 对于任意的 $i(1 \leq i \leq k)$，都有 $1 \leq e_i < n$，且两两不同。

| 测试点编号 | $n$ | $k$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $\leq 5$ | $\leq 1$ | 无 |
| $4\sim 6$ | $\leq 10^5$ | $\leq 1$ | 无 |
| $7\sim 10$ | $\leq 10^5$ | $\leq 2$ | 无 |
| $11,12$ | $\leq 500$ | $\leq 8$ | 无 |
| $13,14$ | $\leq 10^2$ | $<n$ | 无 |
| $15$ | $\leq 500$ | $<n$ | 无 |
| $16,17$ | $\leq 10^5$ | $\leq 500$ | 无 |
| $18$ | $\leq 10^5$ | $<n$ | A |
| $19\sim 21$ | $\leq 10^5$ | $<n$ | B |
| $22,23$ | $\leq 2\times 10^4$ | $<n$ | 无 |
| $24,25$ | $\leq 10^5$ | $<n$ | 无 |

- 特殊性质 A：对于任意的 $i(1 \leq i \leq n - 1)$，都有 $u_i = i, v_i = i + 1$。
- 特殊性质 B：对于任意的 $i(1 \leq i \leq n - 1)$，都有 $u_i = 1, v_i = i + 1$。

**【提示】**

数据输入的规模可能较大，请选手注意输入读取方式的效率。


---

---
title: "[NOIP2024] 树上查询"
layout: "post"
diff: 省选/NOI-
pid: P11364
tag: ['2024', 'NOIP 提高组']
---
# [NOIP2024] 树上查询
## 题目描述

有一天小 S 和她的朋友小 N 一起研究一棵包含了 $n$ 个结点的树。

这是一棵有根树，根结点编号为 $1$，每个结点 $u$ 的深度 $\text{dep}_ u$ 定义为 $u$ 到 $1$ 的简单路径上的**结点数量**。

除此之外，再定义 $\text{LCA*}(l, r)$ 为编号在 $[l, r]$ 中所有结点的最近公共祖先，即 $l, l + 1, \dots , r$ 的公共祖先结点中深度最大的结点。

小 N 对这棵树提出了 $q$ 个询问。在每个询问中，小 N 都会给出三个参数 $l, r, k$，表示他想知道 $[l, r]$ 中任意长度大于等于 $k$ 的连续子区间的最近公共祖先深度的最大值，即

$$\max_{l\le l'\le r'\le r \land r'-l'+1\ge k}\text{dep}_ {\text{LCA*}(l', r')}$$

你的任务是帮助小 S 来回答这些询问。
## 输入格式

输入的第一行包含一个正整数 $n$，表示树的结点数。

接下来 $n - 1$ 行，每行包含两个正整数 $u, v$，表示存在一条从结点 $u$ 到结点 $v$ 的边。

第 $n + 1$ 行包含一个正整数 $q$，表示询问的数量。

接下来 $q$ 行，每行包含三个正整数 $l, r, k$，描述了一次询问。
## 输出格式

对于每次询问输出一行，包含一个整数，表示对应的答案。
## 样例

### 样例输入 #1
```
6
5 6
6 1
6 2
2 3
2 4
3
2 5 2
1 4 1
1 6 3

```
### 样例输出 #1
```
3
4
3

```
## 提示

**【样例 1 解释】**

![图 3](https://cdn.luogu.com.cn/upload/image_hosting/ktoq3ogh.png)

+ 对于第一组询问，$\text{LCA*}(2, 3) = 2, \text{LCA*}(3, 4) = 2, \text{LCA*}(4, 5) = 6$，$2$ 的深度为 $3$，$6$ 的深度为 $2$，因此答案为 $\max\{3, 3, 2\} = 3$。

+ 对于第二组询问，答案为 $1, 2, 3, 4$ 四个结点的最大深度，因此答案为 $4$。

+ 对于第三组询问，$\text{LCA*}(1, 3) = 1, \text{LCA*}(2, 4) = 2, \text{LCA*}(3, 5) = 6, \text{LCA*}(4, 6) = 6$，依旧是 $2$ 的深度最大，因此答案为 $3$。

**【样例 2】**

见附件的 query/query2.in 与 query/query2.ans。

该样例满足 $n, q ≤ 500$。

**【样例 3】**

见附件的 query/query3.in 与 query/query3.ans。

该样例满足 $n, q ≤ 10^5$ 且树符合链的形态。

**【样例 4】**

见附件的 query/query4.in 与 query/query4.ans。

该样例满足 $n, q ≤ 5 × 10^5$。

**【数据范围】**

对于所有的测试数据，保证：$1 ≤ n, q ≤ 5 × 10^5
, 1 ≤ l ≤ r ≤ n, 1 ≤ k ≤ r - l + 1$

| 测试点编号 | $n,q\le$ | 特殊限制 |
| :-: | :-: | :-: |
| $1\sim2$ | $500$ | 无 |
| $3\sim5$ | $5000$ | 无 |
| $6\sim9$ | $10^5$ | 满足性质 A |
| $10\sim13$ | $5\times10^5$ | 满足性质 A |
| $14\sim16$ | $5\times10^5$ | 满足性质 B |
| $17\sim20$ | $10^5$ | 无 |
| $21\sim25$ | $5\times10^5$ | 无 |

性质 A：保证输入的树符合链的形态，且根结点的度数为 $1$。

性质 B：对于每个询问保证 $k = r - l + 1$。


---

---
title: "[NOIP 2016 提高组] 天天爱跑步"
layout: "post"
diff: 省选/NOI-
pid: P1600
tag: ['2016', '线段树', 'NOIP 提高组', '最近公共祖先 LCA', '树链剖分', '动态树 LCT', '差分']
---
# [NOIP 2016 提高组] 天天爱跑步
## 题目背景

NOIP2016 提高组 D1T2
## 题目描述

小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。

这个游戏的地图可以看作一棵包含 $n$ 个结点和 $n-1$ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。

现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）

小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $w_j$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $w_j$ 秒也正好到达了结点 $j$。小 C 想知道每个观察员会观察到多少人?

注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一 段时间后再被观察员观察到。 即对于把结点 $j$ 作为终点的玩家：若他在第 $w_j$ 秒前到达终点，则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $w_j$ 秒到达终点，则在结点 $j$ 的观察员可以观察到这个玩家。

## 输入格式

第一行有两个整数 $n$ 和 $m$。其中 $n$ 代表树的结点数量, 同时也是观察员的数量, $m$ 代表玩家的数量。

接下来 $n-1$ 行每行两个整数 $u$ 和 $v$，表示结点 $u$ 到结点 $v$ 有一条边。

接下来一行 $n$ 个整数，其中第 $j$ 个整数为 $w_j$ , 表示结点 $j$ 出现观察员的时间。

接下来 $m$ 行，每行两个整数 $s_i$，和 $t_i$，表示一个玩家的起点和终点。

对于所有的数据，保证 $1\leq s_i,t_i\leq n, 0\leq w_j\leq n$。

## 输出格式

输出 $1$ 行 $n$ 个整数，第 $j$ 个整数表示结点 $j$ 的观察员可以观察到多少人。

## 样例

### 样例输入 #1
```
6 3
2 3
1 2 
1 4 
4 5 
4 6 
0 2 5 1 2 3 
1 5 
1 3 
2 6 
```
### 样例输出 #1
```
2 0 0 1 1 1 
```
### 样例输入 #2
```
5 3 
1 2 
2 3 
2 4 
1 5 
0 1 0 3 0 
3 1 
1 4
5 5 
```
### 样例输出 #2
```
1 2 1 0 1 
```
## 提示

**样例 1 说明**

对于 $1$ 号点，$w_i=0$，故只有起点为 $1$ 号点的玩家才会被观察到，所以玩家 $1$ 和玩家 $2$ 被观察到，共有 $2$ 人被观察到。

对于 $2$ 号点，没有玩家在第 $2$ 秒时在此结点，共 $0$ 人被观察到。

对于 $3$ 号点，没有玩家在第 $5$ 秒时在此结点，共 $0$ 人被观察到。

对于 $4$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $5$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $6$ 号点，玩家 $3$ 被观察到，共 $1$ 人被观察到。

**子任务**

每个测试点的数据规模及特点如下表所示。 

提示：数据范围的个位上的数字可以帮助判断是哪一种数据类型。

| 测试点编号 | $n=$ | $m=$ | 约定 |
| :--------: | :----: | :----: | :----: |
|     $1\sim 2$      |  $991$   |  $991$   | 所有人的起点等于自己的终点，即 $\forall i,\ s_i=t_i$  |
|     $3\sim 4$      |  $992$   |  $992$   | 所有 $w_j=0$  |
|     $5$      |  $993$   |  $993$   | 无  |
|     $6\sim 8$      |  $99994$   |  $99994$   | $\forall i\in[1,n-1]$，$i$ 与 $i+1$ 有边。即树退化成 $1,2,\dots,n$ 按顺序连接的链  |
|     $9\sim 12$      |  $99995$   |  $99995$   | 所有 $s_i=1$  |
|     $13\sim 16$      |  $99996$   |  $99996$   | 所有 $t_i=1$  |
|     $17\sim 19$      |  $99997$   |  $99997$   | 无  |
|     $20$      |  $299998$   |  $299998$   | 无  |



**提示**

（提示：由于原提示年代久远，不一定能完全反映现在的情况，现在已经对该提示做出了一定的修改，提示的原文可以在[该剪贴板](https://www.luogu.com.cn/paste/3fneb8m6)查看）

在最终评测时，调用栈占用的空间大小不会有单独的限制，但在我们的工作环境中默认会有 $1 \text{MiB}$ 的限制。 这可能会引起**函数调用层数较多时，程序发生栈溢出崩溃**，程序中**较深层数的递归**往往会导致这个问题。如果你的程序需要用到较大的栈空间，请务必注意该问题。

我们可以使用一些方法修改调用栈的大小限制。

- Linux

我们可以在终端中输入下列命令：`ulimit -s 1048576`。此命令的意义是，将调用栈的大小限制修改为 $1048576\text{KiB}=1 \text{GiB}$。

例如，对于如下程序 `sample.cpp`：

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1000005];
void dfs(int a){
	if(a == 0){
		f[a] = 0;
		return;
	}
	dfs(a - 1);
	f[a] = f[a - 1] + 1;
}
int main(){
	dfs(1000000);
	return 0;
}
```

将上述源代码用命令 `g++ sample.cpp -o sample` 编译为可执行文件 `sample` 后，使用 `./sample` 执行程序。

如果在没有使用命令 `ulimit -s 1048576` 的情况下运行该程序，`sample` 会因为栈溢出而崩溃；如果使用了上述命令后运行该程序，该程序则不会崩溃。

特别地，当你打开多个终端时，它们并不会共享该命令，你需要分别对它们运行该命令。

请注意，调用栈占用的空间会计入总空间占用中，和程序其他部分占用的内存共同受到内存限制。

- Windows

如果你使用 Windows 下的 Dev-C++，请选择 `工具-编译选项` 并在如下区域填入以下命令 `-Wl,--stack=1073741824`，填入后注意确认“编译时加入以下命令的”的框是**已勾选**状态。

此处 `1073741824` 的单位是 $\text{B/Bytes}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)  ![](https://cdn.luogu.com.cn/upload/image_hosting/zvrzkyq5.png)


---

---
title: "[NOIP 2013 提高组] 华容道"
layout: "post"
diff: 省选/NOI-
pid: P1979
tag: ['搜索', '图论', '2013', 'NOIP 提高组']
---
# [NOIP 2013 提高组] 华容道
## 题目背景

NOIP2013 提高组 D2T3
## 题目描述

`小 B` 最近迷上了华容道，可是他总是要花很长的时间才能完成一次。于是，他想到用编程来完成华容道：给定一种局面， 华容道是否根本就无法完成，如果能完成， 最少需要多少时间。

`小 B` 玩的华容道与经典的华容道游戏略有不同，游戏规则是这样的：

1.   在一个 $n \times m$ 棋盘上有 $ n \times m$ 个格子，其中有且只有一个格子是空白的，其余 $ n \times m-1$ 个格子上每个格子上有一个棋子，每个棋子的大小都是 $1 \times 1$ 的；
2.  有些棋子是固定的，有些棋子则是可以移动的；
3.  任何与空白的格子相邻（有公共的边）的格子上的棋子都可以移动到空白格子上。   

游戏的目的是把某个指定位置可以活动的棋子移动到目标位置。

给定一个棋盘，游戏可以玩 $q$ 次，当然，每次棋盘上固定的格子是不会变的， 但是棋盘上空白的格子的初始位置、 指定的可移动的棋子的初始位置和目标位置却可能不同。第 $i$ 次玩的时候， 空白的格子在第 $EX_i$ 行第 $EY_i$ 列，指定的可移动棋子的初始位置为第 $SX_i$ 行第 $SY_i$列，目标位置为第 $TX_i$ 行第 $TY_i$ 列。

假设 `小 B` 每秒钟能进行一次移动棋子的操作，而其他操作的时间都可以忽略不计。请你告诉 `小 B` 每一次游戏所需要的最少时间，或者告诉他不可能完成游戏。

## 输入格式

第一行有 $3$个整数，每两个整数之间用一个空格隔开，依次表示 $ n,m,q$；

接下来的 $n$ 行描述一个 $ n \times m$ 的棋盘，每行有 $ m $ 个整数，每两个整数之间用一个空格隔开，每个整数描述棋盘上一个格子的状态，$0$ 表示该格子上的棋子是固定的，$1$ 表示该格子上的棋子可以移动或者该格子是空白的。  

接下来的 $q$ 行，每行包含 $6$ 个整数依次是 $EX_i,EY_i,SX_i,SY_i,TX_i,TY_i$，每两个整数之间用一个空格隔开，表示每次游戏空白格子的位置，指定棋子的初始位置和目标位置。

## 输出格式

共 $ q$ 行，每行包含 $1$ 个整数，表示每次游戏所需要的最少时间，如果某次游戏无法完成目标则输出 $−1$。

## 样例

### 样例输入 #1
```
3 4 2
0 1 1 1
0 1 1 0
0 1 0 0
3 2 1 2 2 2
1 2 2 2 3 2
```
### 样例输出 #1
```
2
-1
```
## 提示

**输入输出样例说明**

棋盘上划叉的格子是固定的，红色格子是目标位置，圆圈表示棋子，其中绿色圆圈表示目标棋子。

1.   第一次游戏，空白格子的初始位置是 $(3,2)$（图中空白所示），游戏的目标是将初始位置在 $(1, 2)$ 上的棋子（图中绿色圆圈所代表的棋子）移动到目标位置 $(2, 2)$（图中红色的格子）上。

移动过程如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/n0q385tw.png)

2.  第二次游戏，空白格子的初始位置是 $(1, 2)$（图中空白所示），游戏的目标是将初始位置在 $(2, 2)$ 上的棋子（图中绿色圆圈所示）移动到目标位置  $(3, 2)$ 上。

![](https://cdn.luogu.com.cn/upload/image_hosting/aq9apos0.png)

要将指定块移入目标位置，必须先将空白块移入目标位置，空白块要移动到目标位置，必然是从位置 $(2,2)$ 上与当前图中目标位置上的棋子交换位置，之后能与空白块交换位置的只有当前图中目标位置上的那个棋子，因此目标棋子永远无法走到它的目标位置， 游戏无法完成。

**数据范围**

对于 $ 30\%$ 的数据，$1 ≤ n, m ≤ 10,q = 1$；

对于 $60\%$ 的数据，$1 ≤ n, m ≤ 30,q ≤ 10$；

对于 $100\%$ 的数据，$1 ≤ n, m ≤ 30,q ≤ 500$。



---

---
title: "[NOIP 2015 提高组] 斗地主 加强版"
layout: "post"
diff: 省选/NOI-
pid: P2540
tag: ['2015', 'NOIP 提高组', '深度优先搜索 DFS', '剪枝']
---
# [NOIP 2015 提高组] 斗地主 加强版
## 题目描述

牛牛最近迷上了一种叫斗地主的扑克游戏。斗地主是一种使用黑桃、红心、梅花、方片的 $A$ 到 $K$ 加上大小王的共 $54$ 张牌来进行的扑克牌游戏。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10<J<Q<K<A<2<\text{小王}<\text{大王}$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。

现在，牛牛只想知道，对于自己的若干组手牌，分别最少需要多少次出牌可以将它们打光。请你帮他解决这个问题。

需要注意的是，本题中游戏者每次可以出手的牌型与一般的斗地主相似而略有不同。具体规则如下：

 ![](https://cdn.luogu.com.cn/upload/pic/1827.png) 

**在此题中认为两个王不能组成对子牌**。

## 输入格式

第一行包含用空格隔开的 $2$ 个正整数 $T,n$，表示手牌的组数以及每组手牌的张数。

接下来 $T$ 组数据，每组数据 $n$ 行，每行一个非负整数对 $a_i,b_i$，表示一张牌，其中 $a_i$ 表示牌的数码，$b_i$ 表示牌的花色，中间用空格隔开。特别的，我们用 $1$ 来表示数码 $A$，$11$ 表示数码 $J$，$12$ 表示数码 $Q$，$13$ 表示数码 $K$；黑桃、红心、梅花、方片分别用 $1-4$ 来表示；小王的表示方法为 `0 1`，大王的表示方法为 `0 2`。
## 输出格式

共 $T$ 行，每行一个整数，表示打光第 $i$ 手牌的最少次数。

## 样例

### 样例输入 #1
```
1 8
7 4
8 4
9 1
10 4
11 1
5 1
1 4
1 1
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
1 17
12 3
4 3
2 3
5 4
10 2
3 3
12 2
0 1
1 3
10 1
6 2
12 1
11 3
5 2
12 4
2 2
7 2
```
### 样例输出 #2
```
6
```
## 提示

#### 样例 1 说明

共有 $1$ 组手牌，包含 $8$ 张牌：方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$，黑桃 $5$，方片 $A$ 以及黑桃 $A$。可以通过打单顺子（方片 $7$，方片 $8$，黑桃 $9$，方片 $10$，黑桃 $J$），单张牌（黑桃 $5$）以及对子牌（黑桃 $A$ 以及方片 $A$）在 $3$ 次内打光。

#### 数据范围与提示

对于前 $20$ 个测试点， 我们约定手牌组数 $T$ 与张数 $n$ 的规模如下：

 ![](https://cdn.luogu.com.cn/upload/pic/1828.png) 

数据不保证所有的手牌都是随机生成的。



---

---
title: "[NOIP 2017 提高组] 宝藏"
layout: "post"
diff: 省选/NOI-
pid: P3959
tag: ['贪心', '2017', 'NOIP 提高组', '枚举', '状压 DP']
---
# [NOIP 2017 提高组] 宝藏
## 题目背景

NOIP2017 D2T2
## 题目描述

参与考古挖掘的小明得到了一份藏宝图，藏宝图上标出了 $n$ 个深埋在地下的宝藏屋， 也给出了这 $n$ 个宝藏屋之间可供开发的 $m$ 条道路和它们的长度。

小明决心亲自前往挖掘所有宝藏屋中的宝藏。但是，每个宝藏屋距离地面都很远，也就是说，从地面打通一条到某个宝藏屋的道路是很困难的，而开发宝藏屋之间的道路则相对容易很多。

小明的决心感动了考古挖掘的赞助商，赞助商决定免费赞助他打通一条从地面到某个宝藏屋的通道，通往哪个宝藏屋则由小明来决定。

在此基础上，小明还需要考虑如何开凿宝藏屋之间的道路。已经开凿出的道路可以 任意通行不消耗代价。每开凿出一条新道路，小明就会与考古队一起挖掘出由该条道路所能到达的宝藏屋的宝藏。另外，小明不想开发无用道路，即两个已经被挖掘过的宝藏屋之间的道路无需再开发。

新开发一条道路的代价是 $\mathrm{L} \times \mathrm{K}$。其中 $L$ 代表这条道路的长度，$K$ 代表从赞助商帮你打通的宝藏屋到这条道路起点的宝藏屋所经过的宝藏屋的数量（包括赞助商帮你打通的宝藏屋和这条道路起点的宝藏屋） 。

请你编写程序为小明选定由赞助商打通的宝藏屋和之后开凿的道路，使得工程总代价最小，并输出这个最小值。

## 输入格式

第一行两个用空格分离的正整数 $n,m$，代表宝藏屋的个数和道路数。

接下来 $m$ 行，每行三个用空格分离的正整数，分别是由一条道路连接的两个宝藏屋的编号（编号为 $1-n$），和这条道路的长度 $v$。

## 输出格式

一个正整数，表示最小的总代价。

## 样例

### 样例输入 #1
```
4 5 
1 2 1 
1 3 3 
1 4 1 
2 3 4 
3 4 1 
 
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
4 5 
1 2 1 
1 3 3 
1 4 1 
2 3 4 
3 4 2  
```
### 样例输出 #2
```
5
```
## 提示

 ![](https://cdn.luogu.com.cn/upload/pic/10868.png) 

【样例解释 $1$】

小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \to 4$，挖掘了 $4$ 号宝藏。还开发了道路 $4 \to 3$，挖掘了 $3$ 号宝藏。

工程总代价为 $1 \times 1 + 1 \times 1 + 1 \times 2  = 4 $。

【样例解释 $2$】

小明选定让赞助商打通了 $1$ 号宝藏屋。小明开发了道路 $1 \to 2$，挖掘了 $2$ 号宝藏。开发了道路 $1 \to 3$，挖掘了 $3$ 号宝藏。还开发了道路 $1 \to 4$，挖掘了 $4$ 号宝藏。

工程总代价为 $1 \times 1 + 3 \times 1 + 1 \times 1  = 5$。


【数据规模与约定】

对于 $ 20\%$ 的数据： 保证输入是一棵树，$1 \le n \le 8$，$v \le 5\times 10^3$ 且所有的 $v$ 都相等。

对于 $40\%$ 的数据： $1 \le n \le 8$，$0 \le m \le 10^3$，$v \le 5\times 10^3$ 且所有的 $v$ 都相等。

对于 $ 70\%$ 的数据： $1 \le n \le 8$，$0 \le m \le 10^3$，$v \le  5\times 10^3$。

对于 $ 100\%$ 的数据： $1 \le n \le 12$，$0 \le m \le 10^3$，$v \le  5\times 10^5$。

---

$\text{upd 2022.7.27}$：新增加 $50$ 组 Hack 数据。



---

---
title: "[NOIP 2017 提高组] 列队"
layout: "post"
diff: 省选/NOI-
pid: P3960
tag: ['2017', '线段树', '平衡树', '树状数组', 'NOIP 提高组']
---
# [NOIP 2017 提高组] 列队
## 题目背景

NOIP2017 D2T3
## 题目描述

`Sylvia` 是一个热爱学习的女孩子。

前段时间，`Sylvia` 参加了学校的军训。众所周知，军训的时候需要站方阵。

Sylvia 所在的方阵中有 $n \times m$ 名学生，方阵的行数为 $n$，列数为 $m$。

为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中 的学生从 $1$ 到 $n \times m$ 编上了号码（参见后面的样例）。即：初始时，第 $i$ 行第 $j$ 列 的学生的编号是 $(i-1)\times m + j$。

然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天 中，一共发生了 $q$ 件这样的离队事件。每一次离队事件可以用数对 $(x,y) (1 \le x \le n, 1 \le y \le m)$ 描述，表示第 $x$ 行第 $y$ 列的学生离队。

在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达 这样的两条指令：


1. 向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条 指令之后，空位在第 $x$ 行第 $m$ 列。
2. 向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条 指令之后，空位在第 $n$ 行第 $m$ 列。


教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后， 下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第 $n$ 行 第 $m$ 列一个空位，这时这个学生会自然地填补到这个位置。

因为站方阵真的很无聊，所以 `Sylvia` 想要计算每一次离队事件中，离队的同学 的编号是多少。

注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后 方阵中同学的编号可能是乱序的。

## 输入格式

输入共 $q+1$ 行。

第一行包含 $3$ 个用空格分隔的正整数 $n, m, q$，表示方阵大小是 $n$ 行 $m$ 列，一共发 生了 $q$ 次事件。

接下来 $q$ 行按照事件发生顺序描述了 $q$ 件事件。每一行是两个整数 $x, y$，用一个空 格分隔，表示这个离队事件中离队的学生当时排在第 $x$ 行第 $y$ 列。

## 输出格式

按照事件输入的顺序，每一个事件输出一行一个整数，表示这个离队事件中离队学生的编号。

## 样例

### 样例输入 #1
```
2 2 3 
1 1 
2 2 
1 2 
```
### 样例输出 #1
```
1
1
4

```
## 提示

【输入输出样例 $1$ 说明】

$$\begin{matrix}
\begin{bmatrix}
1 & 2 \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
 & 2 \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 4 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} \\[1em]
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix}\\[1em]
\begin{bmatrix}
2 & 4 \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 &  \\
3 & 1 \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 1 \\
3 &  \\
\end{bmatrix} & \Rightarrow & 
\begin{bmatrix}
2 & 1 \\
3 & 4 \\
\end{bmatrix}
\end{matrix}$$


列队的过程如上图所示，每一行描述了一个事件。 在第一个事件中，编号为 $1$ 的同学离队，这时空位在第一行第一列。接着所有同学 向左标齐，这时编号为 $2$ 的同学向左移动一步，空位移动到第一行第二列。然后所有同 学向上标齐，这时编号为 $4$ 的同学向上一步，这时空位移动到第二行第二列。最后编号为 $1$ 的同学返回填补到空位中。

【数据规模与约定】

| 测试点编号 | $n$ | $m$ | $q$ | 其他约定 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1\sim 6$ | $\le 10^3$ | $\le 10^3$ | $\le 500$ | 无 |
| $7\sim 10$ | $\le 5\times 10^4$ | $\le 5\times 10^4$ | $\le 500$ | 无 |
| $11\sim 12$ | $=1$ | $\le 10^5$ | $\le 10^5$ | 所有事件 $x=1$ |
| $13\sim 14$ | $=1$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 所有事件 $x=1$ |
| $15\sim 16$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 所有事件 $x=1$ |
| $17\sim 18$ | $\le 10^5$ | $\le 10^5$ | $\le 10^5$ | 无 |
| $19\sim 20$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | $\le 3\times 10^5$ | 无 |

数据保证每一个事件满足 $1 \le x \le n,1 \le y \le m$。



---

---
title: "[NOIP 2018 提高组] 填数游戏"
layout: "post"
diff: 省选/NOI-
pid: P5023
tag: ['动态规划 DP', '数学', '2018', 'NOIP 提高组']
---
# [NOIP 2018 提高组] 填数游戏
## 题目背景

NOIP2018 提高组 D2T2
## 题目描述

小 D 特别喜欢玩游戏。这一天，他在玩一款填数游戏。
  
这个填数游戏的棋盘是一个 $n \times m$ 的矩形表格。玩家需要在表格的每个格子中填入一个数字（数字 $0$ 或者数字 $1$），填数时需要满足一些限制。   

下面我们来具体描述这些限制。   

为了方便描述，我们先给出一些定义： 
 
-  我们用每个格子的行列坐标来表示一个格子，即（行坐标，列坐标）。注意：行列坐标均从 $0$ 开始编号。
- 合法路径 $P$：一条路径是合法的当且仅当：   
    1. 这条路径从矩形表格的左上角的格子 $(0,0)$ 出发，到矩形的右下角格子 $(n - 1,m - 1)$ 结束；   
    2. 在这条路径中，每次只能从当前的格子移动到右边与它相邻的格子，或者从当前格子移动到下面与它相邻的格子。
    
  例如：在下面这个矩形中，只有两条路径是合法的，它们分别是 $P_1$：$(0,0)\to (0,1)\to (1,1)$ 和 $P_2$：$(0,0) \to (1,0) \to (1,1)$。
   
![](https://cdn.luogu.com.cn/upload/pic/43256.png)  

对于一条合法的路径 $P$，我们可以用一个字符串 $w(P)$ 来表示，该字符串的长度为 $n + m - 2$，其中只包含字符 $\texttt R$ 或者字符 $\texttt D$，第 $i$ 个字符记录了路径 $P$ 中第 $i$ 步的移动方法。$\texttt R$ 表示移动到当前格子右边与它相邻的格子，$\texttt D$ 表示移动到当前格子下面与它相邻的格子。例如，上图中对于路径 $P_1$，有 $w(P_1) = \texttt {RD}$；而对于另一条路径 $P_2$，有 $w(P_2) = \texttt {DR}$。   

同时，将每条合法路径 $P$ 经过的每个格子上填入的数字依次连接后，会得到一个长度为 $n + m - 1$ 的 $01$ 字符串，记为 $s(P)$。例如，如果我们在格子 $(0,0)$ 和 $(1,0)$ 上填入数字 $0$，在格子 $(0,1)$ 和 $(1,1)$ 上填入数字 $1$（见上图红色数字），那么对于路径 $P_1$，我们可以得到 $s(P_1) = 011$，对于路径 $P_2$，有 $s(P_2) = 001$。 

游戏要求小 D 找到一种填数字 $0$、$1$ 的方法，使得对于两条路径 $P_1$，$P_2$，如果 $w(P_1) > w(P_2)$，那么必须 $s(P_1) ≤ s(P_2)$。我们说字符串 $a$ 比字符串 $b$ 小，当且仅当字符串 $a$ 的字典序小于字符串 $b$ 的字典序，字典序的定义详见第一题。但是仅仅是找一种方法无法满足小 D 的好奇心，小 D 更想知道这个游戏有多少种玩法，也就是说，有多少种填数字的方法满足游戏的要求？ 

小 D 能力有限，希望你帮助他解决这个问题，即有多少种填 $0$、$1$ 的方法能满足题目要求。由于答案可能很大，你需要输出答案对 $10^9 + 7$ 取模的结果。 
## 输入格式

输入文件共一行，包含两个正整数 $n,m$，由一个空格分隔，表示矩形的大小。其中 $n$ 表示矩形表格的行数，$m$ 表示矩形表格的列数。 
## 输出格式

输出共一行，包含一个正整数，表示有多少种填 $0$、$1$ 的方法能满足游戏的要求。 注意：输出答案对 $10^9+7$ 取模的结果。 
## 样例

### 样例输入 #1
```
2 2
```
### 样例输出 #1
```
12
```
### 样例输入 #2
```
3 3
```
### 样例输出 #2
```
112
```
### 样例输入 #3
```
5 5
```
### 样例输出 #3
```
7136
```
## 提示

**样例解释**  

![](https://cdn.luogu.com.cn/upload/pic/43257.png)  

**数据规模与约定** 

| 测试点编号 | $n\le$ | $m\le$ |
| :-----------: | :-----------: | :-----------: |
| $1\sim 4$ | $3$ | $3$ |
| $5\sim 10$ | $2$ | $10^6$ |
| $11\sim 13$ | $3$ | $10^6$ |
| $14\sim 16$ | $8$ | $8$ |
| $17\sim 20$ | $8$ | $10^6$ |



---

---
title: "[NOIP 2018 提高组] 保卫王国"
layout: "post"
diff: 省选/NOI-
pid: P5024
tag: ['动态规划 DP', '2018', '倍增', 'NOIP 提高组', '树链剖分', '动态 DP', '全局平衡二叉树']
---
# [NOIP 2018 提高组] 保卫王国
## 题目背景

NOIP2018 提高组 D2T3
## 题目描述

Z 国有 $n$ 座城市，$(n - 1)$ 条双向道路，每条双向道路连接两座城市，且任意两座城市都能通过若干条道路相互到达。  

Z 国的国防部长小 Z 要在城市中驻扎军队。驻扎军队需要满足如下几个条件： 

- 一座城市可以驻扎一支军队，也可以不驻扎军队。   
- 由道路直接连接的两座城市中至少要有一座城市驻扎军队。   
- 在城市里驻扎军队会产生花费，在编号为 $i$ 的城市中驻扎军队的花费是 $p_i$。      

小 Z 很快就规划出了一种驻扎军队的方案，使总花费最小。但是国王又给小 Z 提出了 $m$ 个要求，每个要求规定了其中两座城市是否驻扎军队。小 Z 需要针对每个要求逐一给出回答。具体而言，如果国王提出的第 $j$ 个要求能够满足上述驻扎条件（不需要考虑第 $j$ 个要求之外的其它要求），则需要给出在此要求前提下驻扎军队的最小开销。如果国王提出的第 $j$ 个要求无法满足，则需要输出 $-1$。现在请你来帮助小 Z。 
## 输入格式

第一行有两个整数和一个字符串，依次表示城市数 $n$，要求数 $m$ 和数据类型 $type$。$type$ 是一个由大写字母 `A`，`B` 或 `C` 和一个数字 `1`，`2`，`3` 组成的字符串。它可以帮助你获得部分分。你可能不需要用到这个参数。这个参数的含义在【数据规模与约定】中 有具体的描述。

第二行有 $n$ 个整数，第 $i$ 个整数表示编号 $i$ 的城市中驻扎军队的花费 $p_i$。

接下来 $(n - 1)$ 行，每行两个整数 $u,v$，表示有一条 $u$ 到 $v$ 的双向道路。 

接下来 $m$ 行，每行四个整数 $a, x, b, y$，表示一个要求是在城市 $a$ 驻扎 $x$ 支军队，在城市 $b$ 驻扎 $y$ 支军队。其中，$x,y$ 的取值只有 $0$ 或 $1$：
- 若 $x$ 为 $0$，表示城市 $a$ 不得驻扎军队。
- 若 $x$ 为 $1$，表示城市 $a$ 必须驻扎军队。
- 若 $y$ 为 $0$，表示城市 $b$ 不得驻扎军队。
- 若 $y$ 为 $1$，表示城市 $b$ 必须驻扎军队。    

输入文件中每一行相邻的两个数据之间均用一个空格分隔。 
## 输出格式

输出共 $m$ 行，每行包含一个个整数，第 $j$ 行表示在满足国王第 $j$ 个要求时的最小开销， 如果无法满足国王的第 $j$ 个要求，则该行输出 $-1$。 
## 样例

### 样例输入 #1
```
5 3 C3 
2 4 1 3 9 
1 5 
5 2 
5 3 
3 4 
1 0 3 0 
2 1 3 1 
1 0 5 0

```
### 样例输出 #1
```
12 
7 
-1
```
## 提示

#### 样例 1 解释

- 对于第一个要求，在 $4$ 号和 $5$ 号城市驻扎军队时开销最小。
- 对于第二个要求，在 $1$ 号、$2$ 号、$3$ 号城市驻扎军队时开销最小。   
- 第三个要求是无法满足的，因为在 $1$ 号、$5$ 号城市都不驻扎军队就意味着由道路直接连 接的两座城市中都没有驻扎军队。  

#### 数据规模与约定  

| 测试点编号 | $\text{type}$ | $n = m=$ |
|:-:|:-:|:-:|
| $1,2$ | `A3` | $10$ |
| $3,4$ | `C3` | $10$ |
| $5,6$ | `A3` | $100$ |
| $7$ | `C3` | $100$ |
| $8,9$ | `A3` | $2\times 10^3$ |
| $10,11$ | `C3` | $2\times 10^3$ |
| $12,13$ | `A1` | $10^5$ |
| $14, 15, 16$ | `A2` | $10^5$ |
| $17$ | `A3` | $10^5$ |
| $18,19$ | `B1` | $10^5$ |
| $20,21$ | `C1` | $10^5$ |
| $22$ | `C2` | $10^5$ |
| $23, 24, 25$ | `C3` | $10^5$ |

数据类型的含义：   

- `A`：城市 $i$ 与城市 $i + 1$ 直接相连。    
- `B`：任意城市与城市 $1$ 的距离不超过 $100$（距离定义为最短路径上边的数量），即如果这 棵树以 $1$ 号城市为根，深度不超过 $100$。   
- `C`：在树的形态上无特殊约束。   
- `1`：询问时保证 $a = 1,x = 1$，即要求在城市 $1$ 驻军。对 $b,y$ 没有限制。   
- `2`：询问时保证 $a,b$ 是相邻的（由一条道路直接连通）  
- `3`：在询问上无特殊约束。

对于 $100\%$的数据，保证 $1 \leq n,m ≤ 10^5$，$1 ≤ p_i ≤ 10^5$，$1 \leq u, v, a, b \leq n$，$a \neq b$，$x, y \in \{0, 1\}$。


---

---
title: "[NOIP 2018 提高组] 旅行 加强版"
layout: "post"
diff: 省选/NOI-
pid: P5049
tag: ['2018', 'NOIP 提高组', '基环树']
---
# [NOIP 2018 提高组] 旅行 加强版
## 题目描述

小 Y 是一个爱好旅行的 OIer。她来到 X 国，打算将各个城市都玩一遍。 
  
小Y了解到，X 国的 $n$ 个城市之间有 $m$ 条双向道路。每条双向道路连接两个城市。 不存在两条连接同一对城市的道路，也不存在一条连接一个城市和它本身的道路。并且， 从任意一个城市出发，通过这些道路都可以到达任意一个其他城市。小 Y 只能通过这些 道路从一个城市前往另一个城市。   

小 Y 的旅行方案是这样的：任意选定一个城市作为起点，然后从起点开始，每次可 以选择一条与当前城市相连的道路，走向一个没有去过的城市，或者沿着第一次访问该 城市时经过的道路后退到上一个城市。当小 Y 回到起点时，她可以选择结束这次旅行或 继续旅行。需要注意的是，小 Y 要求在旅行方案中，每个城市都被访问到。   

为了让自己的旅行更有意义，小 Y 决定在每到达一个新的城市（包括起点）时，将 它的编号记录下来。她知道这样会形成一个长度为 $n$ 的序列。她希望这个序列的字典序 最小，你能帮帮她吗？  对于两个长度均为 $n$ 的序列 $A$ 和 $B$，当且仅当存在一个正整数 $x$，满足以下条件时， 我们说序列 $A$ 的字典序小于 $B$。 
  
- 对于任意正整数 $1 ≤ i < x$，序列 $A$ 的第 $i$ 个元素 $A_i$ 和序列 $B$ 的第 $i$ 个元素 $B_i$ 相同。   
- 序列 $A$ 的第 $x$ 个元素的值小于序列 $B$ 的第 $x$ 个元素的值。 
## 输入格式

输入文件共 $m + 1$ 行。第一行包含两个整数 $n,m(m ≤ n)$，中间用一个空格分隔。
 
接下来 m 行，每行包含两个整数 $u,v (1 ≤ u,v ≤ n)$ ，表示编号为 $u$ 和 $v$ 的城市之 间有一条道路，两个整数之间用一个空格分隔。 
## 输出格式

输出文件包含一行，$n$ 个整数，表示字典序最小的序列。相邻两个整数之间用一个 空格分隔。 
## 样例

### 样例输入 #1
```
6 5 
1 3 
2 3 
2 5 
3 4 
4 6
```
### 样例输出 #1
```
1 3 2 5 4 6
```
### 样例输入 #2
```
6 6 
1 3 
2 3 
2 5 
3 4 
4 5 
4 6
```
### 样例输出 #2
```
1 3 2 4 5 6
```
## 提示

【数据规模与约定】   

对于 $100\%$ 的数据和所有样例， $1 \le n \le 500000 $ 且 $m = n - 1$ 或 $m = n$ 。

具体规定详见正常版本（除 testcase11-13）


---

---
title: "[NOIP2020] 移球游戏"
layout: "post"
diff: 省选/NOI-
pid: P7115
tag: ['2020', 'NOIP 提高组', 'Special Judge']
---
# [NOIP2020] 移球游戏
## 题目描述

小 C 正在玩一个移球游戏，他面前有 $n + 1$ 根柱子，柱子从 $1 \sim n + 1$ 编号，其中 $1$ 号柱子、$2$ 号柱子、……、$n$ 号柱子上各有 $m$ 个球，它们自底向上放置在柱子上，$n + 1$ 号柱子上初始时没有球。这 $n \times m$ 个球共有 $n$ 种颜色，每种颜色的球各 $m$ 个。

初始时一根柱子上的球可能是五颜六色的，而小 C 的任务是将所有同种颜色的球移到同一根柱子上，这是唯一的目标，而每种颜色的球最后放置在哪根柱子则没有限制。

小 C 可以通过若干次操作完成这个目标，一次操作能将一个球从一根柱子移到另一根柱子上。更具体地，将 $x$ 号柱子上的球移动到 $y$ 号柱子上的要求为：

1. $x$ 号柱子上至少有一个球；
2. $y$ 号柱子上至多有 $m - 1$ 个球；
3. 只能将 $x$ 号柱子最上方的球移到 $y$ 号柱子的最上方。

小 C 的目标并不难完成，因此他决定给自己加加难度：在完成目标的基础上，使用的操作次数不能超过 $820000$。换句话说，小 C 需要使用至多 $820000$ 次操作完成目标。

小 C 被难住了，但他相信难不倒你，请你给出一个操作方案完成小 C 的目标。合法的方案可能有多种，你只需要给出任意一种，题目保证一定存在一个合法方案。
## 输入格式

第一行两个用空格分隔的整数 $n, m$。分别表示球的颜色数、每种颜色球的个数。  
接下来 $n$ 行每行 $m$ 个用单个空格分隔的整数，第 $i$ 行的整数按自底向上的顺序依次给出了 $i$ 号柱子上的球的颜色。
## 输出格式

本题采用自定义校验器（special judge）评测。  
你的输出的第一行应该仅包含单个整数 $k$，表示你的方案的操作次数。你应保证 $0 \le k \le 820000$。  
接下来 $k$ 行每行你应输出两个用单个空格分隔的正整数 $x, y$，表示这次操作将 $x$ 号柱子最上方的球移动到 $y$ 号柱子最上方。你应保证 $1 \le x, y \le n + 1$ 且 $x \ne y$。
## 样例

### 样例输入 #1
```
2 3
1 1 2
2 1 2

```
### 样例输出 #1
```
6
1 3
2 3
2 3
3 1
3 2
3 2

```
### 样例输入 #2
```
见附件中的 ball/ball2.in
```
### 样例输出 #2
```
见附件中的 ball/ball2.ans
```
### 样例输入 #3
```
见附件中的 ball/ball3.in
```
### 样例输出 #3
```
见附件中的 ball/ball3.ans
```
## 提示

**【样例 #1 解释】**

柱子中的内容为：按自底向上的顺序依次给出柱子上每个球的颜色。

| 操作 | $1$ 号柱子 | $2$ 号柱子 | $3$ 号柱子 |
|:-:|:-:|:-:|:-:|
| 初始 | $1\ 1\ 2$ | $2\ 1\ 2$ | |
| $1\ 3$ | $1\ 1$ | $2\ 1\ 2$ | $2$ |
| $2\ 3$ | $1\ 1$ | $2\ 1$ | $2\ 2$ |
| $2\ 3$ | $1\ 1$ | $2$ | $2\ 2\ 1$ |
| $3\ 1$ | $1\ 1\ 1$ | $2$ | $2\ 2$ |
| $3\ 2$ | $1\ 1\ 1$ | $2\ 2$ | $2$ |
| $3\ 2$ | $1\ 1\ 1$ | $2\ 2\ 2$ | |

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 2$ | $2$ | $20$ |
| $3 \sim 5$ | $10$ | $20$ |
| $6 \sim 8$ | $50$ | $85$ |
| $9 \sim 14$ | $50$ | $300$ |
| $15 \sim 20$ | $50$ | $400$ |

对于所有测试点，保证 $2 \le n \le 50$，$2 \le m \le 400$。

**【校验器】**

为了方便选手测试，在附件中的 `ball` 目录下我们下发了 `checker.cpp` 文件，选手可以编译该程序，并使用它校验自己的输出文件。但请注意它与最终评测时所使用的校验器并不完全一致。你也不需要关心其代码的具体内容。

编译命令为：`g++ checker.cpp −o checker -std=c++11`。

`checker` 的使用方式为：`checker <inputfile> <outputfile>`，参数依次表示输入文件与你的输出文件。

若你输出的数字大小范围不合法，则校验器会给出相应提示。若你的输出数字大小范围正确，但方案错误，则校验器会给出简要的错误信息：

1. `A x`，表示进行到第 $x$ 个操作时不合法。
2. `B x`，表示操作执行完毕后第 $x$ 个柱子上的球不合法。

若你的方案正确，校验器会给出 `OK`。


---

---
title: "[NOIP2020] 微信步数"
layout: "post"
diff: 省选/NOI-
pid: P7116
tag: ['2020', 'NOIP 提高组']
---
# [NOIP2020] 微信步数
## 题目描述

小 C 喜欢跑步，并且非常喜欢在微信步数排行榜上刷榜，为此他制定了一个刷微信步数的计划。

他来到了一处空旷的场地，处于该场地中的人可以用 $k$ 维整数坐标 $(a_1, a_2, \ldots , a_k)$ 来表示其位置。场地有大小限制，第 $i$ 维的大小为 $w_i$，因此处于场地中的人其坐标应满足 $1 \le a_i \le w_i$（$1 \le i \le k$）。

小 C 打算在接下来的 $P = w_1 \times w_2 \times \cdots \times w_k$ 天中，每天从场地中一个新的位置出发，开始他的刷步数计划（换句话说，他将会从场地中每个位置都出发一次进行计划）。

他的计划非常简单，每天按照事先规定好的路线行进，每天的路线由 $n$ 步移动构成，每一步可以用 $c_i$ 与 $d_i$ 表示：若他当前位于 $(a_1, a_2, \ldots , a_{c_i}, \ldots, a_k)$，则这一步他将会走到 $(a_1, a_2, \ldots , a_{c_i} + d_i, \ldots , a_k)$，其中 $1 \le c_i \le k$，$d_i \in \{-1, 1\}$。小 C 将会不断重复这个路线，直到他走出了场地的范围才结束一天的计划。（即走完第 $n$ 步后，若小 C 还在场内，他将回到第 $1$ 步从头再走一遍）。

小 C 对自己的速度非常有自信，所以他并不在意具体耗费的时间，他只想知道 $P$ 天之后，他一共刷出了多少步微信步数。请你帮他算一算。
## 输入格式

第一行两个用单个空格分隔的整数 $n, k$。分别表示路线步数与场地维数。  
接下来一行 $k$ 个用单个空格分隔的整数 $w_i$，表示场地大小。  
接下来 $n$ 行每行两个用单个空格分隔的整数 $c_i, d_i$，依次表示每一步的方向，具体意义见题目描述。
## 输出格式

仅一行一个整数表示答案。答案可能很大，你只需要输出其对 ${10}^9 + 7$ 取模后的值。  
若小 C 的计划会使得他在某一天在场地中永远走不出来，则输出一行一个整数 $-1$。
## 样例

### 样例输入 #1
```
3 2
3 3
1 1
2 -1
1 1

```
### 样例输出 #1
```
21

```
### 样例输入 #2
```
5 4
6 8 6 5
3 1
2 1
1 1
2 1
2 -1

```
### 样例输出 #2
```
10265

```
### 样例输入 #3
```
见附件中的 walk/walk3.in
```
### 样例输出 #3
```
见附件中的 walk/walk3.ans
```
### 样例输入 #4
```
见附件中的 walk/walk4.in
```
### 样例输出 #4
```
见附件中的 walk/walk4.ans
```
## 提示

**【样例 #1 解释】**

从 $(1, 1)$ 出发将走 $2$ 步，从 $(1, 2)$ 出发将走 $4$ 步，从 $(1, 3)$ 出发将走 $4$ 步。  
从 $(2, 1)$ 出发将走 $2$ 步，从 $(2, 2)$ 出发将走 $3$ 步，从 $(2, 3)$ 出发将走 $3$ 步。  
从 $(3, 1)$ 出发将走 $1$ 步，从 $(3, 2)$ 出发将走 $1$ 步，从 $(3, 3)$ 出发将走 $1$ 步。  
共计 $21$ 步。

**【数据范围】**

| 测试点编号 | $n \le$ | $k \le$ | $w_i \le$ |
|:-:|:-:|:-:|:-:|
| $1 \sim 3$ | $5$ | $5$ | $3$ |
| $4 \sim 6$ | $100$ | $3$ | $10$ |
| $7 \sim 8$ | ${10}^5$ | $1$ | ${10}^5$ |
| $9 \sim 12$ | ${10}^5$ | $2$ | ${10}^6$ |
| $13 \sim 16$ | $5 \times {10}^5$ | $10$ | ${10}^6$ |
| $17 \sim 20$ | $5 \times {10}^5$ | $3$ | ${10}^9$ |

对于所有测试点，保证 $1 \le n \le 5 \times {10}^5$，$1 \le k \le 10$，$1 \le w_i \le {10}^9$，$d_i \in \{-1, 1\}$。


---

---
title: "[NOIP2021] 方差"
layout: "post"
diff: 省选/NOI-
pid: P7962
tag: ['动态规划 DP', '2021', 'NOIP 提高组', 'O2优化', '模拟退火', '动态规划优化']
---
# [NOIP2021] 方差
## 题目描述

给定长度为 $n$ 的非严格递增正整数数列 $1 \le a_1 \le a_2 \le \cdots \le a_n$。每次可以进行的操作是：任意选择一个正整数 $1 < i < n$，将 $a_i$ 变为 $a_{i - 1} + a_{i + 1} - a_i$。求在若干次操作之后，该数列的方差最小值是多少。请输出最小值乘以 $n^2$ 的结果。

其中方差的定义为：数列中每个数与平均值的差的平方的平均值。更形式化地说，方差的定义为 $D = \frac{1}{n} \sum_{i = 1}^{n} {(a_i - \bar a)}^2$，其中 $\bar a = \frac{1}{n} \sum_{i = 1}^{n} a_i$。
## 输入格式

输入的第一行包含一个正整数 $n$，保证 $n \le {10}^4$。

输入的第二行有 $n$ 个正整数，其中第 $i$ 个数字表示 $a_i$ 的值。数据保证 $1 \le a_1 \le a_2 \le \cdots \le a_n$。
## 输出格式

输出仅一行，包含一个非负整数，表示你所求的方差的最小值的 $n^2$ 倍。
## 样例

### 样例输入 #1
```
4
1 2 4 6

```
### 样例输出 #1
```
52

```
### 样例输入 #2
```
见附件中的 variance/variance2.in
```
### 样例输出 #2
```
见附件中的 variance/variance2.ans
```
### 样例输入 #3
```
见附件中的 variance/variance3.in
```
### 样例输出 #3
```
见附件中的 variance/variance3.ans
```
### 样例输入 #4
```
见附件中的 variance/variance4.in
```
### 样例输出 #4
```
见附件中的 variance/variance4.ans
```
## 提示

**【样例解释 #1】**

对于 $(a_1, a_2, a_3, a_4) = (1, 2, 4, 6)$，第一次操作得到的数列有 $(1, 3, 4, 6)$，第二次操作得到的新的数列有 $(1, 3, 5, 6)$。之后无法得到新的数列。

对于 $(a_1, a_2, a_3, a_4) = (1, 2, 4, 6)$，平均值为 $\frac{13}{4}$，方差为 $\frac{1}{4}({(1 - \frac{13}{4})}^2 + {(2 - \frac{13}{4})}^2 + {(4 - \frac{13}{4})}^2 + {(6 - \frac{13}{4})}^2) = \frac{59}{16}$。

对于 $(a_1, a_2, a_3, a_4) = (1, 3, 4, 6)$，平均值为 $\frac{7}{2}$，方差为 $\frac{1}{4} ({(1 - \frac{7}{2})}^2 + {(3 - \frac{7}{2})}^2 + {(4 - \frac{7}{2})}^2 + {(6 - \frac{7}{2})}^2) = \frac{13}{4}$。

对于 $(a_1, a_2, a_3, a_4) = (1, 3, 5, 6)$，平均值为 $\frac{15}{4}$，方差为 $\frac{1}{4} ({(1 - \frac{15}{4})}^2 + {(3 - \frac{15}{4})}^2 + {(5 - \frac{15}{4})}^2 + {(6 - \frac{15}{4})}^2) = \frac{59}{16}$。

**【数据范围】**

| 测试点编号 | $n \le$ | $a_i \le$ |
|:-:|:-:|:-:|
| $1 \sim 3$ | $4$ | $10$ |
| $4 \sim 5$ | $10$ | $40$ |
| $6 \sim 8$ | $15$ | $20$ |
| $9 \sim 12$ | $20$ | $300$ |
| $13 \sim 15$ | $50$ | $70$ |
| $16 \sim 18$ | $100$ | $40$ |
| $19 \sim 22$ | $400$ | $600$ |
| $23 \sim 25$ | ${10}^4$ | $50$ |

对于所有的数据，保证 $1 \le n \le {10}^4$，$1 \le a_i \le 600$。


---

---
title: "[NOIP2022] 喵了个喵"
layout: "post"
diff: 省选/NOI-
pid: P8866
tag: ['贪心', '2022', 'NOIP 提高组', 'Special Judge', 'O2优化', '构造', 'Ad-hoc']
---
# [NOIP2022] 喵了个喵
## 题目描述

小 E 喜欢上了一款叫做《喵了个喵》的游戏。这个游戏有一个牌堆和 $n$ 个可以从栈底删除元素的栈，任务是要通过游戏规则将所有的卡牌消去。开始时牌堆中有 $m$ 张卡牌，从上到下的图案分别是 $a_1, a_2,\dots, a_m$。所有的卡牌一共有 $k$ 种图案，从 $1$ 到 $k$ 编号。牌堆中每一种图案的卡牌都有偶数张。开始时所有的栈都是空的。这个游戏有两种操作：

- 选择一个栈，将牌堆顶上的卡牌放入栈的顶部。如果这么操作后，这个栈最上方的两张牌有相同的图案，则会自动将这两张牌消去。
- 选择两个不同的栈，如果这两个栈栈**底**的卡牌有相同的图案，则可以将这两张牌消去，原来在栈底上方的卡牌会成为新的栈底。如果不同，则什么也不会做。

这个游戏一共有 $T$ 关，小 E 一直无法通关。请你帮小 E 设计一下游戏方案，即对于游戏的每一关，给出相应的操作序列使得小 E 可以把所有的卡牌消去。

## 输入格式

第一行包含一个正整数 $T$，表示数据组数。

接下来一共 $T$ 组数据，在每组数据中：

第一行包含三个正整数 $n, m, k$，分别表示栈的个数、卡牌的个数、卡牌上图案的种类。

第二行包含 $m$ 个正整数，分别表示 $a_1, a_2,\dots, a_m$，分别从上到下表示牌堆中卡牌的图案。

输入数据保证有解。
## 输出格式

对于每一组数据，输出若干行。

其中第一行包含一个正整数 $\mathrm{op}$，表示操作的次数。你需要保证 $m \leq \mathrm{op} \leq 2\times m$。

接下来 $\mathrm{op}$ 行，每行包含两个或三个正整数，整数之间用一个空格隔开。

若为两个整数 $\texttt{1 s}$，则进行一次第一个操作并选择栈 $s$。

若为三个整数 $\texttt{2 s1 s2}$，则进行一次第二个操作并选择栈 $s_1$ 和 $s_2$。

你需要保证 $1 \leq s, s_1, s_2 \leq n$，且 $s_1 \neq s_2$。
## 样例

### 样例输入 #1
```
1
2 4 2
1 2 1 2
```
### 样例输出 #1
```
5
1 1
1 1
1 2
2 1 2
1 1
```
## 提示

**【样例 1 解释】**

下图是初始状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/iidvwekz.png)

下图是前两次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/hrcdl51d.png)

下图是第三次和第四次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/ju6b9dep.png)

下图是第五次操作之后的结果。

![](https://cdn.luogu.com.cn/upload/image_hosting/djpqtzfr.png)

**【样例 2】**

见选手目录下的 $\texttt{meow/meow2.in}$ 与 $\texttt{meow/meow2.ans}$。

**【数据范围】**

设 $S$ 为所有 $T$ 组数据中 $m$ 的总和。

对于所有数据，保证 $S \leq 2 \times 10^6$，$1 \leq n  \leq 300$，$1 \leq a_i \leq k$。

| 测试点 | $T=$ | $n$ | $k=$ | $m \leq$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $1001$ | $\leq 300$ | $2n-2$ | 无限制 |
| $4\sim 6$ | $1002$ | $=2$ | $2n-1$ | 无限制 |
| $7\sim 10$ | $3$ | $=3$ | $2n-1$ | $14$ |
| $11\sim 14$ | $1004$ | $=3$ | $2n-1$ | 无限制 |
| $15\sim 20$ | $1005$ | $\leq 300$ | $2n-1$ | 无限制 |


**【评分方式】**

对于每一组数据，若在按顺序进行所有操作后，牌堆为空且所有的栈均为空，则认为你的答案正确。

**【提示】**

你可以通过 $T$ 的个位数来判断这个测试点是属于哪一类数据。

你的输出不需要与样例输出一致，输出任意一个合法解即可得分。


---

---
title: "[NOIP2022] 建造军营"
layout: "post"
diff: 省选/NOI-
pid: P8867
tag: ['2022', 'NOIP 提高组', 'O2优化', '树形 DP', '强连通分量', 'Tarjan', '容斥原理']
---
# [NOIP2022] 建造军营
## 题目描述

A 国与 B 国正在激烈交战中，A 国打算在自己的国土上建造一些军营。

A 国的国土由 $n$ 座城市组成，$m$ 条双向道路连接这些城市，使得**任意两座城市均可通过道路直接或间接到达**。A 国打算选择一座或多座城市（**至少一座**），并在这些城市上各建造一座军营。

众所周知，军营之间的联络是十分重要的。然而此时 A 国接到情报，B 国将会于不久后袭击 A 国的一条道路，但具体的袭击目标却无从得知。如果 B 国袭击成功，这条道路将被切断，可能会造成 A 国某两个军营无法互相到达，这是 A 国极力避免的。因此 A 国决定派兵看守若干条道路（**可以是一条或多条，也可以一条也不看守**)，A 国有信心保证被派兵看守的道路能够抵御 B 国的袭击而不被切断。

A 国希望制定一个建造军营和看守道路的方案，使得 B 国袭击的无论是 A 国的哪条道路，都不会造成某两座军营无法互相到达。现在，请你帮 A 国计算一下可能的建造军营和看守道路的方案数共有多少。由于方案数可能会很多，你只需要输出其对 $1,000,000,007\left(10^{9}+7\right)$ 取模的值即可。两个方案被认为是不同的，当且仅当存在至少一 座城市在一个方案中建造了军营而在另一个方案中没有，或者存在至少一条道路在一个 方案中被派兵看守而在另一个方案中没有。

## 输入格式

第一行包含两个正整数 $n,m$，分别表示城市的个数和双向道路的数量。

接下来 $m$ 行，每行包含两个正整数 $u_{i},v_{i}$，描述一条连接 $u_{i}$ 和 $v_{i}$ 的双向道路。保证没有重边和自环。
## 输出格式

输出一行包含一个整数，表示建造军营和看守道路的方案数对 $1,000,000,007\left(10^{9}+ 7\right)$ 取模的结果。
## 样例

### 样例输入 #1
```
2 1
1 2
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
4 4
1 2
2 3
3 1
1 4
```
### 样例输出 #2
```
184
```
### 样例输入 #3
```
见附加文件里的 barrack/barrack3.in
```
### 样例输出 #3
```
见附加文件里的 barrack/barrack3.ans
```
### 样例输入 #4
```
见附加文件里的 barrack/barrack4.in
```
### 样例输出 #4
```
见附加文件里的 barrack/barrack4.ans
```
## 提示

### 样例 1 解释

A 国有两座城市，一条道路连接他们。所有可能的方案如下：

- 在城市 $1$ 建军营, 不看守这条道路;
- 在城市 $1$ 建军营, 看守这条道路;
- 在城市 $2$ 建军营, 不看守这条道路;
- 在城市 $2$ 建军营, 看守这条道路;
- 在城市 $1,2$ 建军营, 看守这条道路。

### 数据规模与约定

对所有数据，保证 $1 \leq n \leq 5 \times 10^5$，$n - 1 \leq m \leq 10^6$，$1 \leq u_i, v_i \leq n$，$u_i \neq v_i$。

各测试点的信息如下

|测试点编号 | $n \leq $ | $m \leq $| 特殊条件 |
| :-: | :-: | :-: | :-: |
| $1 \sim 3$ | $8$ | $10$ | 无 |
| $4 \sim 7$ | $16$ | $25$ | 无 |
| $8 \sim 9$ | $3000$ | $5000$ | 无 |
| $10 \sim 11$ | $5 \times 10^5$ | $10^6$ | 特殊性质 $\mathrm{A}$ |
| $12 \sim 14$ | $5 \times 10^5$ | $10^6$ | $m = n - 1$ |
| $15 \sim 16$ |  $5 \times 10^5$ | $10^6$ | $m = n$ |
| $17 \sim 20$ | $5 \times 10^5$ | $10^6$ | 无 |

特殊性质 $\mathrm{A}$：保证 $m=n-1$ 且第 $i$ 条道路连接城市 $i$ 与 $i+1$。 


---

---
title: "[NOIP2022] 比赛"
layout: "post"
diff: 省选/NOI-
pid: P8868
tag: ['线段树', '2022', 'NOIP 提高组', 'O2优化']
---
# [NOIP2022] 比赛
## 题目描述

小 N 和小 O 会在 2022 年 11 月参加一场盛大的程序设计大赛 NOIP！小 P 会作为裁判主持竞赛。小 N 和小 O 各自率领了一支 $n$ 个人的队伍，选手在每支队伍内都是从 $1$ 到 $n$ 编号。每一个选手都有相应的程序设计水平。具体的，小 N 率领的队伍中，编号为 $i$（$1 \leq i \leq n$）的选手的程序设计水平为 $a _ i$；小 O 率领的队伍中，编号为 $i$（$1 \leq i \leq n$）的选手的程序设计水平为 $b _ i$。特别地，$\{a _ i\}$ 和 $\{b _ i\}$ 还分别构成了从 $1$ 到 $n$ 的排列。

每场比赛前，考虑到路途距离，选手连续参加比赛等因素，小 P 会选择两个参数 $l, r$（$1 \leq l \leq r \leq n$），表示这一场比赛会邀请两队中编号属于 $[l, r]$ 的所有选手来到现场准备比赛。在比赛现场，小 N 和小 O 会以掷骰子的方式挑选出参数 $p, q$（$l \leq p \leq q \leq r$），只有编号属于 $[p, q]$ 的选手才能参赛。为了给观众以最精彩的比赛，两队都会派出编号在 $[p, q]$ 内的、程序设计水平值最大的选手参加比赛。假定小 N 派出的选手水平为 $m _ a$，小 O 派出的选手水平为 $m _ b$，则比赛的精彩程度为 $m _ a \times m _ b$。

NOIP 总共有 $Q$ 场比赛，每场比赛的参数 $l, r$ 都已经确定，但是 $p, q$ 还没有抽取。小 P 想知道，对于每一场比赛，在其所有可能的 $p, q$（$l \leq p \leq q \leq r$）参数下的比赛的精彩程度之和。由于答案可能非常之大，你只需要对每一场答案输出结果对 $2 ^ {64}$ 取模的结果即可。
## 输入格式

第一行包含两个正整数 $T, n$，分别表示测试点编号和参赛人数。如果数据为样例则保证 $T = 0$。

第二行包含 $n$ 个正整数，第 $i$ 个正整数为 $a _ i$，表示小 N 队伍中编号为 $i$ 的选手的程序设计水平。

第三行包含 $n$ 个正整数，第 $i$ 个正整数为 $b _ i$，表示小 O 队伍中编号为 $i$ 的选手的程序设计水平。

第四行包含一个正整数 $Q$，表示比赛场数。

接下来的 $Q$ 行，第 $i$ 行包含两个正整数 $l _ i, r _ i$，表示第 $i$ 场比赛的参数 $l, r$。
## 输出格式

输出 $Q$ 行，第 $i$ 行包含一个非负整数，表示第 $i$ 场比赛中所有可能的比赛的精彩程度之和对 $2 ^ {64}$ 取模的结果。
## 样例

### 样例输入 #1
```
0 2
2 1
1 2
1
1 2
```
### 样例输出 #1
```
8
```
### 样例输入 #2
```
见附件下的 match/match2.in。
```
### 样例输出 #2
```
见附件下的 match/match2.ans。
```
### 样例输入 #3
```
见附件下的 match/match3.in。
```
### 样例输出 #3
```
见附件下的 match/match3.ans。
```
## 提示

**【样例 1 解释】**

当 $p = 1, q = 2$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $2 \times 2 = 4$。

当 $p = 1, q = 1$ 的时候，小 N 会派出 $1$ 号选手，小 O 会派出 $1$ 号选手，比赛精彩程度为 $2 \times 1 = 2$。

当 $p = 2, q = 2$ 的时候，小 N 会派出 $2$ 号选手，小 O 会派出 $2$ 号选手，比赛精彩程度为 $1 \times 2 = 2$。

**【样例 2】**

该样例满足测试点 $1 \sim 2$ 的限制。

**【样例 3】**

该样例满足测试点 $3 \sim 5$ 的限制。

**【数据范围】**

对于所有数据，保证：$1 \leq n, Q \leq 2.5 \times 10 ^ 5$，$1 \leq l _ i \leq r _ i \leq n$，$1 \leq a _ i, b _ i \leq n$ 且 $\{a _ i\}$ 和 $\{b _ i\}$ 分别构成了从 $1$ 到 $n$ 的排列。

| 测试点 | $n$ | $Q$ | 特殊性质 A | 特殊性质 B |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1, 2$ | $\leq 30$ | $\leq 30$ | 是 | 是 |
| $3, 4, 5$ | $\leq 3,000$ | $\leq 3,000$ | 是 | 是 |
| $6, 7$ | $\leq 10 ^ 5$ | $\leq 5$ | 是 | 是 |
| $8, 9$ | $\leq 2.5 \times 10 ^ 5$ | $\leq 5$ | 是 | 是 |
| $10, 11$ | $\leq 10 ^ 5$ | $\leq 5$ | 否 | 否 |
| $12, 13$ | $\leq 2.5 \times 10 ^ 5$ | $\leq 5$ | 否 | 否 |
| $14, 15$ | $\leq 10 ^ 5$ | $\leq 10 ^ 5$ | 是 | 是 |
| $16, 17$ | $\leq 2.5 \times 10 ^ 5$ | $\leq 2.5 \times 10 ^ 5$ | 是 | 是 |
| $18, 19$ | $\leq 10 ^ 5$ | $\leq 10 ^ 5$ | 是 | 否 |
| $20, 21$ | $\leq 2.5 \times 10 ^ 5$ | $\leq 2.5 \times 10 ^ 5$ | 是 | 否 |
| $22, 23$ | $\leq 10 ^ 5$ | $\leq 10 ^ 5$ | 否 | 否 |
| $24, 25$ | $\leq 2.5 \times 10 ^ 5$ | $\leq 2.5 \times 10 ^ 5$ | 否 | 否 |

特殊性质 A：保证 $a$ 是均匀随机生成的 $1 \sim n$ 的排列。

特殊性质 B：保证 $b$ 是均匀随机生成的 $1 \sim n$ 的排列。


---

---
title: "[春季测试 2023] 密码锁"
layout: "post"
diff: 省选/NOI-
pid: P9120
tag: ['2023', 'NOIP 提高组', 'O2优化']
---
# [春季测试 2023] 密码锁
## 题目描述

寒假过后，小 I 回到学校，发现自己忘记了自行车锁的密码，于是请你帮忙。

小 I 自行车上的密码锁有 $n$ 个拨圈，每个拨圈有 $k$（$k \leq 4$）格。密码锁上的每一格都包含一个正整数，其中第 $j$ 个拨圈的第 $i$ 格上的正整数为 $a _ {i, j}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/0owivo0l.png)

（一个锁的例子，其中 $k = n = 3$，每列表示一个拨圈，拨圈的格子从上往下编号。）

你可以对每个拨圈拨若干次（也可以不拨），每拨一次拨圈，它的格子就会进行一次轮换。形式化地，拨第 $j$ 个拨圈一次，则会让第 $j$ 个拨圈上第 $i$ 格的数字移动到第 $((i \bmod k) + 1)$ 格，其他拨圈不动。

![](https://cdn.luogu.com.cn/upload/image_hosting/9d3g6b74.png)

（一个拨动拨圈的例子，对左侧的锁拨一次第二个拨圈得到右侧的锁。）

为了方便记忆，小 I 设定密码时要求同一行上的数字尽可能靠近。
形式化地，对于 $1 \leq i \leq k$，定义密码锁第 $i$ 行的松散度为

$$
c(i) = \max \limits _ {j = 1} ^ n a _ {i, j} - \min \limits _ {j = 1} ^ n a _ {i, j} 
$$

同时定义整个密码锁的松散度为

$$
C = \max \limits _ {1 \leq i \leq k} c(i)
$$

因为能开锁的状态满足 $C$ 尽可能小，因此小 I 希望你找出最小的 $C$ 值。
## 输入格式

**本题有多组测试数据，题目保证一个测试点中所有测试数据的 $k$ 相同。**

第一行包含两个正整数 $T, k$，分别表示测试数据组数和密码锁拨圈上的格数。

接下来一共 $T$ 组数据，每组数据格式如下：

第一行包含一个正整数 $n$，表示拨圈数。

接下来 $k$ 行，每行包含 $n$ 个正整数，其中第 $i$ 行第 $j$ 个整数 $a _ {i,j}$ 表示密码锁第 $j$ 个拨圈上第 $i$ 格对应的数字。

**注意输入的矩阵中每一列对应一个拨圈，而非每一行对应一个拨圈。**
## 输出格式

对于每组数据，输出一行包含一个整数，表示所有方案中 $C$ 的最小值。
## 样例

### 样例输入 #1
```
2 3
3
1 2 1
2 3 2
3 1 3
2
1 2
2 1
1 2
```
### 样例输出 #1
```
0
1
```
### 样例输入 #2
```
见选手目录下的 lock/lock2.in。
```
### 样例输出 #2
```
见选手目录下的 lock/lock2.ans。
```
### 样例输入 #3
```
见选手目录下的 lock/lock3.in。
```
### 样例输出 #3
```
见选手目录下的 lock/lock3.ans。
```
### 样例输入 #4
```
见选手目录下的 lock/lock4.in。
```
### 样例输出 #4
```
见选手目录下的 lock/lock4.ans。
```
### 样例输入 #5
```
见选手目录下的 lock/lock5.in。
```
### 样例输出 #5
```
见选手目录下的 lock/lock5.ans。
```
## 提示

**【样例 1 解释】**

第一组样例对应题目描述中的例子。
在拨第二个拨圈一次后，每个拨圈都是 $\{1, 2, 3\}$，此时松散度为 $0$。
容易证明无论如何松散度都不可能小于 $0$，因此输出 $0$。

以下四个样例分别对应 $k = 1, 2, 3, 4$ 的情况，且样例中 $n$ 的取值有一定梯度。

**【数据范围】**

设 $\sum n$ 为一个测试点中所有测试数据的 $n$ 的和。

对于所有数据，保证 $1 \leq T$，$1 \leq k \leq 4$，$1 \leq a _ {i ,j} \leq  3 \times 10 ^ 4$。


本题分为两类测试点。


第一类测试点共有十二个，保证 $k \leq 3$，$n \leq 5 \times 10 ^ 4$，$\sum n \leq 1.5 \times 10 ^ 5$。

| 测试点编号 | $n \leq$ | $\sum n \leq $ | $k = $ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $20$ | $100$ | $1$ |
| $2$ | $5 \times 10 ^ 4$ | $1.5 \times 10 ^ 5$ | $1$ |
| $3$ | $20$ | $100$ | $2$ |
| $4$ | $100$ | $1000$ | $2$ |
| $5$ | $2000$ | $10 ^ 4$ | $2$ |
| $6$ | $5 \times 10 ^ 4$ | $1.5 \times 10 ^ 5$ | $2$ |
| $7$ | $10$ | $50$ | $3$ |
| $8$ | $50$ | $500$ | $3$ |
| $9$ | $300$ | $3000$ | $3$ |
| $10$ | $3000$ | $2 \times 10 ^ 4$ | $3$ |
| $11$ | $3 \times 10 ^ 4$ | $1.2 \times 10 ^ 5$ | $3$ |
| $12$ | $5 \times 10 ^ 4$ | $1.5 \times 10 ^ 5$ | $3$ |

第二类测试点共有八个，保证 $k = 4$，$n \leq 10 ^ 4$，
$\sum n \leq 3 \times 10 ^ 4$。

| 测试点编号 | $n \leq$ | $\sum n \leq $ | $k = $ |
| :----------: | :----------: | :----------: | :----------: |
| $13$ | $10$ | $50$ | $4$ |
| $14$ | $50$ | $500$ | $4$ |
| $15$ | $200$ | $2000$ | $4$ |
| $16$ | $500$ | $4000$ | $4$ |
| $17$ | $2500$ | $10 ^ 4$ | $4$ |
| $18$ | $5000$ | $2 \times 10 ^ 4$ | $4$ |
| $19$ | $10 ^ 4$ | $3 \times 10 ^ 4$ | $4$ |
| $20$ | $10 ^ 4$ | $3 \times 10 ^ 4$ | $4$ |

**【后记】**

你花了九牛二虎之力算出 $C$ 的值之后，小 I 却告诉你他已经找开锁师傅用锤子暴力破解了。在你的百般劝说下，小 I 承诺以后锁车不用有大于等于一万个拨圈的密码锁。


---

---
title: "[NOIP2023] 双序列拓展"
layout: "post"
diff: 省选/NOI-
pid: P9870
tag: ['动态规划 DP', '贪心', '2023', 'NOIP 提高组', 'O2优化', 'Ad-hoc']
---
# [NOIP2023] 双序列拓展
## 题目描述

称某个序列 $B = \{b_1,b_2,\cdots,b_n\}$ 是另一个序列 $A = \{a_1,a_2,\cdots,a_m\}$ 的**拓展**当且仅当存在**正整数**序列 $L = \{l_1,l_2,\cdots,l_m\}$，将 $a_i$ 替换为 $l_i$ 个 $a_i$ 后得到序列 $B$。例如，

- $\{1,3,3,3,2,2,2\}$ 是 $\{1,3,3,2\}$ 的拓展，取 $L = \{1,1,2,3\}$ 或 $\{1,2,1,3\}$；
- 而 $\{1,3,3,2\}$ 不是 $\{1,3,3,3,2\}$ 的拓展，$\{1,2,3\}$ 不是 $\{1,3,2\}$ 的拓展。

小 R 给了你两个序列 $X$ 和 $Y$，他希望你找到 $X$ 的一个长度为 $l_0 = 10^{100}$ 的拓展 $F = \{f_i\}$ 以及 $Y$ 的一个长度为 $l_0$ 的拓展 $G = \{g_i\}$，使得任意 $1 \le i , j \le l_0$ 都有 $(f_i - g_i)(f_j - g_j) > 0$。由于序列太长，你只需要告诉小 R 是否存在这样的两个序列即可。

为了避免你扔硬币蒙混过关，小 R 还给了 $q$ 次额外询问，每次额外询问中小 R 会修改 $X$ 和 $Y$ 中若干元素的值。你需要对每次得到的新的 $X$ 和 $Y$ 都进行上述的判断。

**询问之间是独立的，每次询问中涉及的修改均在原始序列上完成。**
## 输入格式

输入的第一行包含四个整数 $c, n, m, q$，分别表示测试点编号、序列 $X$ 的长度、序列 $Y$ 的长度和额外询问的个数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。

输入的第二行包含 $n$ 个整数 $x_1,x_2,\cdots, x_n$，描述序列 $X$。

输入的第三行包含 $m$ 个整数 $y_1,y_2,\cdots, y_m$，描述序列 $Y$。

接下来依次描述 $q$ 组额外询问。对于每组额外询问：

- 输入的第一行包含两个整数 $k_x$ 和 $k_y$，分别表示对序列 $X$ 和 $Y$ 产生的修改个数。
- 接下来 $k_x$ 行每行包含两个整数 $p_x, v_x$，表示将 $x_{p_x}$ 修改为 $v_x$。
- 接下来 $k_y$ 行每行包含两个整数 $p_y, v_y$，表示将 $y_{p_y}$ 修改为 $v_y$。
## 输出格式

输出一行，其中包含一个长度为 $(q+1)$ 的 `01` 序列，序列的第一个元素表示初始询问的答案，之后 $q$ 个元素依次表示每组额外询问的答案。对于每个询问，如果存在满足题目条件的序列 $F$ 和 $G$，输出 `1`，否则输出 `0`。
## 样例

### 样例输入 #1
```
3 3 3 3
8 6 9
1 7 4
1 0
3 0
0 2
1 8
3 5
1 1
2 8
1 7

```
### 样例输出 #1
```
1001
```
## 提示

**【样例解释 #1】**

由于 $F$ 和 $G$ 太长，用省略号表示重复最后一个元素直到序列长度为 $l_0$。如 $\{1,2,3,3,\cdots\}$ 表示序列从第三个元素之后都是 $3$。

以下依次描述四次询问，其中第一次询问为初始询问，之后的三次为额外询问：

1. $A = \{8,6,9\}$，$B = \{1,7,4\}$，取 $F = \{8,8,6,9,\cdots\}, G = \{1,7,4,4,\cdots\}$；
2. $A = \{8,6,0\}$，$B = \{1,7,4\}$，可以证明不存在满足要求的方案；
3. $A = \{8,6,9\}$，$B = \{8,7,5\}$，可以证明不存在满足要求的方案；
4. $A = \{8,8,9\}$，$B = \{7,7,4\}$，取 $F = \{8,8,9,\cdots\}, G = \{7,7,4,\cdots\}$。

**【样例解释 #2】**

该组样例满足测试点 $4$ 的条件。

**【样例解释 #3】**

该组样例满足测试点 $7$ 的条件。

**【样例解释 #4】**

该组样例满足测试点 $9$ 的条件。

**【样例解释 #5】**

该组样例满足测试点 $18$ 的条件。

**【数据范围】**

对于所有测试数据，保证：

- $1 \le n, m \le 5 \times 10 ^ 5$；
- $0 \le q \le 60$；
- $0 \le x_i, y_i < 10 ^ 9$；
- $0 \le k_x, k_y \le 5 \times 10 ^ 5$，且所有额外询问的 $(k_x+k_y)$ 的和不超过 $5 \times 10 ^ 5$；
- $1 \le p_x \le n$，$1 \le p_y \le m$，$0 \le v_x, v_y < 10 ^ 9$；
- 对于每组额外询问，$p_x$ 两两不同，$p_y$ 两两不同。

|测试点编号|$n, m \le$|特殊性质|
|:-:|:-:|:-:|
|$1$|$1$|否|
|$2$|$2$|否|
|$3, 4$|$6$|否|
|$5$|$200$|否|
|$6, 7$|$2000$|否|
|$8, 9$|$4 \times 10 ^ 4$|是|
|$10, 11$|$1.5 \times 10 ^ 5$|是|
|$12 \sim 14$|$5 \times 10 ^ 5$|是|
|$15, 16$|$4 \times 10 ^ 4$|否|
|$17, 18$|$1.5 \times 10 ^ 5$|否|
|$19, 20$|$5 \times 10 ^ 5$|否|

特殊性质：对于每组询问（包括初始询问和额外询问），保证 $x_1 < y_1$，且 $x_n$ 是序列 $X$ 唯一的一个最小值，$y_m$ 是序列 $Y$ 唯一的一个最大值。


---

---
title: "[NOIP2023] 天天爱打卡"
layout: "post"
diff: 省选/NOI-
pid: P9871
tag: ['动态规划 DP', '线段树', '2023', 'NOIP 提高组', 'O2优化']
---
# [NOIP2023] 天天爱打卡
## 题目描述

小 T 同学非常热衷于跑步。为了让跑步更加有趣，他决定制作一款叫做《天天爱打卡》的软件，使得用户每天都可以进行跑步打卡。

开发完成后，小 T 同学计划进行试运行，他找了大 Y 同学来帮忙。试运行共 $n$ 天，编号为从 $1$ 到 $n$。

对大 Y 同学来说，如果某天他选择跑步打卡，那么他的能量值会减少 $d$。初始时，他的能量值是 $0$，并且试运行期间他的**能量值可以是负数**。

而且大 Y 不会**连续**跑步打卡**超过** $k$ 天；即不能存在 $1\le x\le n-k$，使得他在第 $x$ 到第 $x+k$ 天均进行了跑步打卡。

小 T 同学在软件中设计了 $m$ 个挑战，第 $i$（$1\le i \le m$）个挑战可以用三个正整数 $(x_i,y_i,v_i)$ 描述，表示如果在第 $x_i$ 天时，用户已经连续跑步打卡至少 $y_i$ 天（即第 $x_i-y_i+1$ 到第 $x_i$ 天均完成了跑步打卡），那么小 T 同学就会请用户吃饭，从而使用户的能量值提高 $v_i$。

现在大 Y 想知道，在软件试运行的 $n$ 天结束后，他的能量值**最高**可以达到多少？
## 输入格式

**本题的测试点包含有多组测试数据。**

输入的第一行包含两个整数 $c$ 和 $t$，分别表示测试点编号和测试数据组数。对于样例，$c$ 表示该样例与测试点 $c$ 拥有相同的限制条件。

接下来，对于每组测试数据：

- 输入的第一行包含四个正整数 $n,m,k,d$，分别表示试运行的天数、挑战的个数、大 Y 单次跑步打卡的连续天数限制以及大 Y 跑步打卡减少的能量值。
- 接下来 $m$ 行，每行包含三个正整数 $x_i,y_i,v_i$，表示一次挑战。
## 输出格式

输出一行一个整数表示对应的答案。
## 样例

### 样例输入 #1
```
1 1
3 2 2 1
2 2 4
3 2 3

```
### 样例输出 #1
```
2

```
## 提示

**【样例解释 #1】**

在第 $1,2$ 天跑步打卡，第 $3$ 天不跑步打卡，最终会获得 $(-1)+(-1)+4=2$ 的能量值。

**【样例解释 #2】**

该组样例满足测试点 $3$ 的条件。

**【样例解释 #3】**

该组样例满足测试点 $5$ 的条件。

**【样例解释 #4】**

该组样例满足测试点 $15$ 的条件。

**【样例解释 #5】**

该组样例满足测试点 $17$ 的条件。

**【样例解释 #6】**

该组样例满足测试点 $19$ 的条件。

**【数据范围】**

记 $l_i=x_i-y_i+1$，$r_i=x_i$​；

对于所有测试数据，保证：$1\le t\le 10$，$1\le k\le n\le 10^9$，$1\le m\le 10^5$，$1\le l_i\le r_i\le n$，$1\le d,v_i\le 10^9$。

|测试点编号|$n \le$|$m \le$|特殊性质|
|:-:|:-:|:-:|:-:|
|$1, 2$|$18$|$10 ^ 2$|无|
|$3, 4$|$10 ^ 2$|$10 ^ 2$|无|
|$5 \sim 7$|$10 ^ 3$|$10 ^ 3$|无|
|$8, 9$|$10 ^ 3$|$10 ^ 5$|无|
|$10, 11$|$10 ^ 5$|$10 ^ 3$|无|
|$12 \sim 14$|$10 ^ 5$|$10 ^ 5$|无|
|$15, 16$|$10 ^ 9$|$10 ^ 5$|A|
|$17, 18$|$10 ^ 9$|$10 ^ 5$|B|
|$19 \sim 21$|$10 ^ 9$|$10 ^ 5$|C|
|$22 \sim 25$|$10 ^ 9$|$10 ^ 5$|无|

特殊性质 A：$k\le 10^2$；

特殊性质 B：$\forall 1\le i<m$，$r_i<l_{i+1}$；

特殊性质 C：$\forall 1\le i<j\le m$，$l_i<l_j$，$r_i<r_j$。


---


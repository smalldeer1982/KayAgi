---
title: "[集训队互测 2023] Tree Topological Order Counting"
layout: "post"
diff: 省选/NOI-
pid: P10013
tag: ['集训队互测', '2023']
---
# [集训队互测 2023] Tree Topological Order Counting
## 题目描述

给定一颗 $n$ 个点的有根树，$1$ 是根，记 $u$ 的父亲是 $fa_u$。另给出一长度为 $n$ 的权值序列 $b$。

称一个长度为 $n$ 的排列 $a$ 为这颗树的合法拓扑序，当且仅当 $\forall 2 \le u \le n,a_u > a_{fa_u}$。

对每个点 $u$，定义 $f(u)$ 为，在所有这颗树的合法拓扑序中，$b_{a_u}$ 之和。

现在对 $1 \le u \le n$，求 $f(u) \bmod 10^9+7$。
## 输入格式

第一行一个整数 $n$ 表示树的点数。

第二行 $n-1$ 个整数，第 $i$ 个表示 $fa_{i+1}$，描述树的结构。

第三行 $n$ 个整数，第 $i$ 个表示 $b_i$，描述权值序列。
## 输出格式

一行 $n$ 个整数，第 $i$ 个表示 $f(i) \bmod 10^9+7$。
## 样例

### 样例输入 #1
```
5
1 1 3 2
3 5 4 4 1

```
### 样例输出 #1
```
18 27 27 15 15 

```
### 样例输入 #2
```
5
1 1 3 1
1 2 3 4 5

```
### 样例输出 #2
```
12 42 32 52 42

```
## 提示

| Subtask | $n \le$ | 特殊限制 | 分值 |
| :-----: | :-----: | :------: | :--: |
|   $1$   |  $10$   |    无    | $5$  |
|   $2$   |  $20$   |    无    | $10$ |
|   $3$   |  $100$  |    无    | $15$ |
|   $4$   |  $350$  |    无    | $15$ |
|   $5$   | $3000$  |    A     | $15$ |
|   $6$   | $3000$  |    无    | $20$ |
|   $7$   | $5000$  |    无    | $20$ |

特殊限制 A：$\forall 1 \le i \le n,b_i=i$。

对于所有数据：$2 \le n \le 5000$，$1 \le fa_i < i$，$0 \le b_i < 10^9+7$。


---

---
title: "[CCPC 2023 北京市赛] 最小环"
layout: "post"
diff: 省选/NOI-
pid: P10044
tag: ['2023', 'XCPC']
---
# [CCPC 2023 北京市赛] 最小环
## 题目描述

小 I 发明了 $O(n + m)$ 的有向图最小环，于是他想考考你。

给定一个 $n$ 个节点、$m$ 条边的有向图，每条边有正整数边权。你需要求出图上的一个环使得环上边的边权和最小。求出这个最小值，或者报告不存在环。

当然，由于你不会 $O(n + m)$ 的有向图最小环，于是小 I 放宽了条件：保证输入的图是弱连通的，且 $m-n$ 不会很大。一个图是弱连通的当且仅当将有向边换为无向边后图连通。
## 输入格式

第一行两个整数 $n,m (1 \le n \le 3 \times 10^5, -1 \le m-n \le 1500)$，表示图的点数和边数。

接下来 $m$ 行每行三个整数 $u_i,v_i,w_i (1 \le u_i,v_i \le n, 1 \le w_i \le 10^9)$，表示一条从 $u_i$ 到 $v_i$、边权为 $w_i$ 的有向边。保证图是弱连通的。
## 输出格式

如果图中不存在环，输出 `-1`，否则输出一个整数表示最小环的长度和。
## 样例

### 样例输入 #1
```
4 6
1 2 1
4 3 3
4 1 9
2 4 1
3 1 2
3 2 6
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
1 0
```
### 样例输出 #2
```
-1
```
### 样例输入 #3
```
1 1
1 1 1
```
### 样例输出 #3
```
1
```
## 提示

**【样例解释 1】**

最小环为 $1 \to 2 \to 4 \to 3 \to 1$。

**【样例解释 3】**

最小环为 $1 \to 1$。


---

---
title: "[CCPC 2023 北京市赛] 哈密顿"
layout: "post"
diff: 省选/NOI-
pid: P10046
tag: ['2023', 'XCPC']
---
# [CCPC 2023 北京市赛] 哈密顿
## 题目描述

给出 $n$ 个二元组 $(a_i,b_i)$。

考虑 $n$ 个节点的带权有向完全图 $G$，其中从 $i (1 \le i \le n)$ 到 $j (1 \le j \le n)$ 的边边权为 $|a_i-b_j|$。

求 $G$ 的一条哈密顿回路使得其经过的边的边权和最大，并给出这个最大值。
## 输入格式

输入的第一行一个整数 $n(2 \le n \le 10^5)$ 表示二元组个数，接下来 $n$ 行每行两个整数 $a_i,b_i(0 \le a_i,b_i \le 10^9)$ 表示每个二元组。保证输入的 $n$ 个二元组中的总共 $2n$ 个数两两不同。
## 输出格式

输出一行一个整数表示最大的哈密顿回路边权和。
## 样例

### 样例输入 #1
```
3
1 10
8 2
4 5
```
### 样例输出 #1
```
10
```
## 提示

考察哈密顿回路 $1 \to 2 \to 3 \to 1$，其边权和为 $|1-2| + |
8-5| + |4-10| = 10$。可以证明不存在哈密顿回路边权和超过 $10$，因此答案为 $10$。


---

---
title: "[CCPC 2023 北京市赛] 勿蹖宠物"
layout: "post"
diff: 省选/NOI-
pid: P10047
tag: ['2023', 'XCPC']
---
# [CCPC 2023 北京市赛] 勿蹖宠物
## 题目描述

Ene 喜欢回文。

Ene 现在有一些单词。她想选出若干个单词并将它们首尾相连，形成长度恰好为 $L$ 的回文串。每个单词都可以选择多次，也可以不选。

Ene 想知道这样做的方案数。Ene 认为两个方案不同，当且仅当各单词出现次数不同或它们的排列顺序不同，注意多种不同的方案可能会得到同一个回文串。由于答案可能会很大，你需要将答案对 $1,000,000,007$ 取模。
## 输入格式

输入的第一行包含两个正整数 $N, L$，分别表示单词的数量和需要组成的回文串的长度。保证 $1\le N\le 333$，$1\le L\le 1000$。

接下来 $N$ 行，每行输入一个字符串 $s_i$，表示一个单词。保证 $1\le |s_i| \le L$，$\sum_{i=1}^N |s_i| \le 600$；输入的单词仅包含小写字符，且互不相同。
## 输出格式

输出一个非负整数，表示组成回文串的方案数对 $1,000,000,007$ 取模后的结果。
## 样例

### 样例输入 #1
```
7 9
cats
eel
eve
evil
lee
olive
stack
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
2 2
a
aa
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
6 12
aa
aab
no
on
pets
step
```
### 样例输出 #3
```
43
```
## 提示

**【样例解释 1】**

有以下五种方案：

- `stack` `cats`
- `evil` `olive`
- `eel` `eve` `lee`
- `lee` `eve` `eel`
- `eve` `eve` `eve`

**【样例解释 2】**

有以下两种方案：

- `a` `a`
- `aa`


---

---
title: "[SNOI2024] 树 V 图"
layout: "post"
diff: 省选/NOI-
pid: P10060
tag: ['各省省选', '2024', 'O2优化', '陕西']
---
# [SNOI2024] 树 V 图
## 题目描述

你有一棵 $n$ 个点的无根树，节点的编号为 $1, 2, \ldots, n$。定义树上两点之间的距离 $\operatorname{dis}(i, j)$ 为树上 $i$ 点到 $j$ 点的简单路径上的边数。

现在有 $k$ 个关键点 $a_1, a_2, \ldots, a_k$，对于每个点，我们想求出距离它最近的关键点是哪个点。也就是对于一个点 $v$，令 $f(v)$ 表示令 $\operatorname{dis}(v, a_i)$ 最小的 $i$，如果有多个 $i$ 满足条件，那么我们会选择其中最小的 $i$。

现在，我们给出了 $f(1), f(2), \ldots, f(n)$，问有多少组可能的 $(a_1, a_2, \ldots, a_k)$ 满足条件。由于答案可能很大，输出对 $998244353$ 取模的结果。
## 输入格式

多组测试数据，第一行一个整数 $T$ 表示数据组数。  
对于每组测试数据，第一行两个整数 $n, k$，表示节点个数和关键点个数。  
接下来 $n - 1$ 行，每行两个整数 $u, v$，表示一条树边 $(u, v)$。  
接下来一行，$n$ 个整数，$f(1), f(2), \ldots, f(n)$。注意：数据**不保证**一定存在一组可能的 $(a_1, a_2, \ldots, a_k)$。
## 输出格式

对于每组数据，输出一个整数，表示答案对 $998244353$ 取模的结果。
## 样例

### 样例输入 #1
```
3
3 3
1 2
2 3
1 2 1
3 2
1 2
2 3
1 2 2
3 2
1 2
2 3
2 1 1

```
### 样例输出 #1
```
0
1
2

```
### 样例输入 #2
```
1
10 5
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
1 1 2 2 3 3 4 4 5 5

```
### 样例输出 #2
```
13

```
## 提示

**【样例 \#1 解释】**

在第一个样例中，对于第二组数据，一个解为 $(1, 2)$。对于第三组数据，两个解为 $(2, 1), (3, 1)$。

注意，当多个点距离相同时，我们选择的是最小的 $i$ 而不是 $a_i$。

---

**【样例 \#3】**

见附件中 `voronoi/voronoi3.in` 与 `voronoi/voronoi3.ans`，这个样例满足测试点 $3 \sim 4$ 的条件限制。

---

**【样例 \#4】**

见附件中 `voronoi/voronoi3.in` 与 `voronoi/voronoi3.ans`，这个样例满足测试点 $7 \sim 10$ 的条件限制。

---

**【数据范围】**

对于所有的数据，保证 $1 \le T \le 10$，$2 \le k \le n \le 3 \times {10}^3$，$1 \le f(i) \le k$。

具体如下：

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $15$ | 无 |
| $3 \sim 4$ | $3000$ | A |
| $5 \sim 6$ | $3000$ | B |
| $7 \sim 10$ | $3000$ | 无 |

特殊性质 A：保证树是一条链。  
特殊性质 B：保证 $k = 2$。


---

---
title: "[SNOI2024] 矩阵"
layout: "post"
diff: 省选/NOI-
pid: P10061
tag: ['各省省选', '2024', 'O2优化', '陕西']
---
# [SNOI2024] 矩阵
## 题目描述

你要维护一个 $n \times n$ 的矩阵 $A$，其中第 $i$ 行第 $j$ 列的元素记作 $A_{i, j}$。行和列从 $1$ 开始标号。一开始，有 $A_{i, j} = (i + 1)^j \bmod 998244353$。

你需要支持 $q$ 个操作，每个操作是下面两种操作中的一种。

- $1\ x_1\ y_1\ x_2\ y_2$，这里保证 $y_2 - x_2 = y_1 - x_1$。将子矩形 $[x_1, x_2] \times [y_1, y_2]$ 逆时针旋转 $90$ 度。
  - 具体地，令 $d = x_2 - x_1 + 1$。
  - 首先提取 $d \times d$ 的子矩阵 $A'$，对于所有的 $i, j$（$1 \le i, j \le d$），令 $A'_{i, j} \gets A_{x_1 + i - 1, y_1 + j - 1}$。
  - 然后将 $A'$ 旋转，得到一个 $d \times d$ 的子矩阵 $B'$，令 $B'_{i, j} \gets A'_{j, d - i + 1}$。
  - 然后将 $B'$ 填回到 $A$ 中，对所有的 $i, j$（$1 \le i, j \le d$），令 $A_{i + x_1 - 1, j + y_1 - 1} \gets B'_{i, j}$。
- $2\ x_1\ y_1\ x_2\ y_2\ d$。将子矩形 $[x_1, x_2] \times [y_1, y_2]$ 内所有的元素加 $d$。
  - 具体地，对于每个 $i$（$x_1 \le i \le x_2$）、$j$（$y_1 \le j \le y_2$），令 $A_{i, j} \gets A_{i, j} + d$。

你需要在所有操作结束之后，输出这个矩阵。由于输出可能很大，请输出
$$ \Biggl( \sum_{i = 1}^{n} \sum_{j = 1}^{n} A_{i, j} \times {12345}^{(i - 1) n + j} \Biggr) \bmod 1000000007 $$
的结果。
## 输入格式

第一行两个整数 $n, q$ 表示矩阵大小和操作个数。  
接下来 $q$ 行，每行若干个数，表示上面的某种操作。
## 输出格式

输出一个整数，表示答案对 $1000000007$ 取模的结果。
## 样例

### 样例输入 #1
```
4 4
1 1 2 3 4
2 2 1 4 2 3
1 2 1 3 2
2 1 1 1 4 5

```
### 样例输出 #1
```
984660761

```
### 样例输入 #2
```
10 10
2 5 1 10 4 689412516
1 3 4 3 4
1 3 5 4 6
1 4 1 8 5
1 1 2 1 2
1 4 2 7 5
1 2 5 2 5
2 3 3 3 9 856075030
2 4 2 5 6 308750020
2 1 5 9 7 252732904

```
### 样例输出 #2
```
94292030

```
## 提示

**【样例 \#1 解释】**

对于第一个样例，矩阵分别为
$$\begin{bmatrix} 2 & {\textcolor{red}{4}} & {\textcolor{red}{8}} & {\textcolor{red}{16}} \\ 3 & {\textcolor{red}{9}} & {\textcolor{red}{27}} & {\textcolor{red}{81}} \\ 4 & {\textcolor{red}{16}} & {\textcolor{red}{64}} & {\textcolor{red}{256}} \\ 5 & 25 & 125 & 625 \end{bmatrix} \to \begin{bmatrix} 2 & 16 & 81 & 256 \\ {\textcolor{blue}{3}} & {\textcolor{blue}{8}} & 27 & 64 \\ {\textcolor{blue}{4}} & {\textcolor{blue}{4}} & 9 & 16 \\ {\textcolor{blue}{5}} & {\textcolor{blue}{25}} & 125 & 625 \end{bmatrix} \to \begin{bmatrix} 2 & 16 & 81 & 256 \\ {\textcolor{red}{6}} & {\textcolor{red}{11}} & 27 & 64 \\ {\textcolor{red}{7}} & {\textcolor{red}{7}} & 9 & 16 \\ 8 & 28 & 125 & 625 \end{bmatrix}$$
$$\to \begin{bmatrix} {\textcolor{blue}{2}} & {\textcolor{blue}{16}} & {\textcolor{blue}{81}} & {\textcolor{blue}{256}} \\ 11 & 7 & 27 & 64 \\ 6 & 7 & 9 & 16 \\ 8 & 28 & 125 & 625 \end{bmatrix} \to \begin{bmatrix} 7 & 21 & 86 & 261 \\ 11 & 7 & 27 & 64 \\ 6 & 7 & 9 & 16 \\ 8 & 28 & 125 & 625 \end{bmatrix}$$
其中每个旋转操作对应的数字用红色表示，加操作对应的数字用蓝色表示。

---

**【样例 \#3】**

见附件中 `matrix/matrix3.in` 与 `matrix/matrix3.ans`，这个样例满足测试点 $5 \sim 6$ 的条件限制。

---

**【样例 \#4】**

见附件中 `matrix/matrix3.in` 与 `matrix/matrix3.ans`，这个样例满足测试点 $9 \sim 10$ 的条件限制。

---

**【数据范围】**

对于所有的数据，保证 $1 \le n \le 3000$，$1 \le q \le 3000$。  
对于每个操作，保证 $1 \le x_1 \le x_2 \le n$，$1 \le y_1 \le y_2 \le n$，$1 \le d \le {10}^9$。

具体如下：

| 测试点编号 | $n \le$ | $q \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1$ | $100$ | $3000$ | 无 |
| $2$ | $3000$ | $3000$ | A |
| $3 \sim 4$ | $3000$ | $2000$ | B |
| $5 \sim 6$ | $3000$ | $3000$ | B |
| $7 \sim 8$ | $3000$ | $2000$ | 无 |
| $9 \sim 10$ | $3000$ | $3000$ | 无 |

特殊性质 A：保证没有第一类旋转操作。  
特殊性质 B：保证没有第二类加法操作。


---

---
title: "[GDKOI2024 普及组] 刷野 III"
layout: "post"
diff: 省选/NOI-
pid: P10074
tag: ['2024', '广东', 'O2优化']
---
# [GDKOI2024 普及组] 刷野 III
## 题目描述

Zayin 是一个与怪物战斗的巫师，这次他将面临 $n$ 个站成一排的怪物，其中第 $i$ 个怪物的生命值是 $a_i$。

但是由于某种神秘原因，Zayin 并不能控制自己打到想打的怪物。具体来说, 存在一个长度为 $n$ 的排列 $p$，Zayin 每次攻击第 $i$ 只怪物时，实际上是在攻击第 $p_i$ 只怪物。

Zayin 每次可以选择一个 $[1, n]$ 的整数 $k$，让第 $p_k$ 只怪物的血量减少 $1$ 点，当某只怪物的血量小于等于 $0$ 时这只怪物死亡。

然而 Zayin 并不知道这个排列 $p$ 具体是什么，也无法看到每个怪物剩余的具体血量，仅可以知道每次攻击完后怪物是否死亡。

现在 Zayin 想知道，在他采取最优策略的情况下，最多需要攻击多少次，才可以杀死 $m$ 只怪物。
## 输入格式

输入的第一行包含两个正整数 $n, m(1 \leq m \leq n \leq 2000)$，$n$ 表示怪物的个数，$m$ 表示 Zayin 所需要击杀的怪物个数。

输入的第二行包含 $n$ 个非负整数 $a_1, a_2, \dots, a_n(1 \leq a_i \leq 10^9)$，$a_i$ 表示第 $i$ 只怪物的血量。
## 输出格式

输出一个整数，最少的攻击次数。
## 样例

### 样例输入 #1
```
2 1
10 15
```
### 样例输出 #1
```
15
```
### 样例输入 #2
```
2 1
10 30
```
### 样例输出 #2
```
20
```
## 提示

**【样例解释】**

在第一个样例，Zayin 会一直攻击某一只怪物，直到怪物死亡。

在第二个样例，Zayin 先攻击某一个怪物 $10$ 次，如果没有死亡，则说明攻击的是 $30$ 血的怪物。这时 Zayin 会选择攻击第二只怪物，攻击 $10$ 次后另一只怪物一定死亡，故最差需要 $20$ 次。

**【数据范围】**

对于 $10\%$ 的数据，$1 \leq n, m \leq 5$。

对于另外 $20\%$ 的数据，所有 $a_i$ 全部相等。

对于另外 $30\%$ 的数据，$1 \leq m \leq n \leq 500$。

对于 $100\%$ 的数据，$1 \leq m \leq n \leq 2000$，$1 \leq a_i \leq 10^9$。


---

---
title: "[GDKOI2024 普及组] 切割"
layout: "post"
diff: 省选/NOI-
pid: P10075
tag: ['2024', '广东', 'O2优化']
---
# [GDKOI2024 普及组] 切割
## 题目描述

给定一张 $n$ 个点 $m$ 条边的无向连通图，**有**重边无自环。

ymqOAO 现在有 $k$ 个询问。每次询问如果删去图中的 $c_i$ 条边，剩下的图是否还是连通的。

注意：询问之间是相互独立的，即一个询问的删边不会影响之后的询问。

注解：
- 连通图：一个图中任意两个顶点都有路径相连。
## 输入格式

第一行输入三个整数 $n, m$。

接下来 $m$ 行，每行包含两个正整数 $x_i, y_i$，表示第 $i$ 条边为 $x_i$ 与 $y_i$ 所连的边。

接下来一行一个整数 $k$，表示询问的个数。

接下来 $k$ 行，第 $i$ 行的第一个整数 $c_i$ 表示所切割的边的条数，接下来 $c_i(1 \leq c_i \leq 4)$ 个整数，表示所切割的边的编号，其中边的编号范围为 $[1, m]$。
## 输出格式

对于每组询问，如果图不连通，则输出 `Bob`，否则输出 `ymqOAO`。（不包括引号）
## 样例

### 样例输入 #1
```
4 5
1 2
2 3
3 4
4 1
2 4
3
1 5
2 2 3
2 1 2
```
### 样例输出 #1
```
ymqOAO
Bob
ymqOAO
```
## 提示

对于 $10\%$ 的数据，$1 \leq m, n, k \leq 2000$。

对于另外 $10\%$ 的数据，$m = n-1$。

对于另外 $10\%$ 的数据，$c_i = 1$。

对于 $60\%$ 的数据，$1 \leq m, n, k \leq 10^5$。

对于 $100\%$ 的数据，$1 \leq m, n, k \leq 10^6$。


---

---
title: "[GDKOI2024 普及组] EX 中缀表达式"
layout: "post"
diff: 省选/NOI-
pid: P10079
tag: ['2024', '广东', 'O2优化']
---
# [GDKOI2024 普及组] EX 中缀表达式
## 题目描述

Alice 最近学习了表达式，现在他想写一个属于自己的表达式计算器。

规定：

- 单个数字：由若干数字（至少一个）连续拼接，最后必须跟一个 `.` 字符（不含引号）。例如：`00123.` `0.` `789.` 都是合法的数字。
- 单个操作符：由若干数字连续拼接，最后跟一个字符。
- 操作符的字符：表示该操作符的操作。该字符必须是 `+`、`*`、`^` 之一，分别表示加法，乘法和乘方。特别约定 `0^0=1`。  
例如：`000000789+`，`123^`，如果前面的数值合法，那么它们就都是合法的操作符。
- 操作符的数字：表示该操作符的优先级，优先级的取值是 $[1, n]$ 之间的正整数，数字越大表示优先级越高。
- 对于优先级相同的操作符，题目将给出一个长度为 $n$ 的 $01$ 串 $C$，用于说明对应优先级的操作符之间，是左结合还是右结合。  
其中 $0$ 表示左结合，$1$ 表示右结合。  
例如 $C=111011$，其中第 $4$ 个字符为 `0`，表示优先级为 $4$ 的操作符是左结合的。
- 左结合：表示该运算符从左往右计算。下面给出左结合的例子：`1.4+2.4^3.4^4.` 等价于 `((1.4+2.)4^3.)4^4.`，其结果与 `((1+2)^3)^4` 相同
- 右结合：表示该运算符从右往左运算。下面给出右结合的例子：`1.6+2.6^3.6^4.` 等价于 `1.6+(2.6^(3.6^4.))`，其结果与 `1+(2^(3^4))` 相同。
- 中缀表达式：
1. 单个数字是合法的中缀表达式。
2. 若 A 是合法的中缀表达式，则 (A) 也是合法的中缀表达式。
3. 若 A、B 均是合法的中缀表达式，c 是合法的单个操作符，则 AcB 也是合法的中缀表达式。
4. 其余情况均不合法。

现在给出一个长度为 $n$ 的 $01$ 串 $C$，用于说明，相同优先级的操作符之间，是左结合还是右结合。

给出一个中缀表达式，判断该表达式是否合法，不合法则输出 `error`（不包括引号），合法则输出该表达式的值对 $998244353$ 取模的结果。
## 输入格式

第一行一个正整数 $n$。

第二行一个长度为 $n$ 的 $01$ 串 $C$。

第三行一个字符串 $S$，表示一个中缀表达式。

保证表达式中不会存在空格。
## 输出格式

若中缀表达式不合法则输出 `error`，否则输出该表达式的值对 $998244353$ 取模的结果。
## 样例

### 样例输入 #1
```
2
01
1.2+2.1^3.2*4.2^(5.2*6.)2+7.
```
### 样例输出 #1
```
243640717
```
## 提示

**【样例解释】**

`243640717 = ((1+2)^(3*(4^((5*6)+7)))) mod 998244353`

**【数据范围】**

特殊性质 1：不会出现 ^ 字符。

特殊性质 2：不会出现 + 和 * 字符。

特殊性质 3：不会出现 ( 和 )。

对于 $8\%$ 的数据，$n = 1$，$1 \leq |S| \leq 100$，且满足特殊性质 $1$ 和特殊性质 $3$。

对于另外 $8\%$ 的数据，$n = 1$，$1 \leq |S| \leq 100$，且满足特殊性质 $1$。

对于另外 $20\%$ 的数据，$n = 1$，$1 \leq |S| \leq 100$，且满足特殊性质 $2$ 和特殊性质 $3$。

对于另外 $24\%$ 的数据，$n = 1$，$1 \leq |S| \leq 1000$,，且满足特殊性质 $2$。

对于 $100\%$ 的数据，$1 \leq n \leq 9$，$1 \leq |S| \leq 10000$。



---

---
title: "[GDKOI2024 提高组] 匹配"
layout: "post"
diff: 省选/NOI-
pid: P10080
tag: ['2024', '广东', 'Special Judge', 'O2优化']
---
# [GDKOI2024 提高组] 匹配
## 题目描述

给定一个 $2n$ 个点 $m$ 条边的二分图，左部点编号为 $1 \sim n$，右部点编号为 $n + 1 \sim 2n$。

给定每条边为黑色或白色，你需要找到一个完美匹配，使得匹配里的黑色边数恰好为偶数。

如果你对二分图的定义有疑问：

- 二分图是一个无向图，点分为左右两部分，每部分各 $n$ 个点，每条边都连接两个属于不同部分的点。
- 一个完美匹配是一个大小为 $n$ 的边的集合，使得每个点都恰好与集合里的一条边相连。
## 输入格式

第一行一个正整数 $T$，表示数据组数。每组数据的格式如下：

第一行两个正整数 $n, m$，表示图的点数和边数。接下来 $m$ 行，每行三个整数 $u_i, v_i, c_i(1 \leq u_i \leq n, n+1 \leq v_i \leq 2n, 0 \leq c_i \leq 1)$，表示一条连接 $u_i$, $v_i$ 的边，颜色为 $c_i$。$c_i = 0$ 表示白色，$c_i = 1$ 表示黑色。
## 输出格式

对于每组数据：如果无解，输出一行 $-1$。否则，输出一行 $n$ 个正整数，表示你找到的完美匹配里每条边的编号。边按照输入顺序编号为 $1 \sim m$。
## 样例

### 样例输入 #1
```
2
3 7
3 6 1
2 6 0
2 5 1
3 5 1
1 6 1
3 4 0
1 5 1
3 7
1 6 1
3 5 1
2 5 1
3 4 1
1 5 0
1 4 0
2 6 0
```
### 样例输出 #1
```
5 3 6
-1
```
## 提示

**【样例解释】**

在第一组数据中，一个合法的完美匹配是 $(1, 6),(2, 5),(3, 4)$，且里面有恰好两条黑色边。

在第二组数据中，虽然存在完美匹配，但每个完美匹配都有奇数条黑色边。

**【数据范围】**

**本题使用子任务捆绑测试。**

对于所有数据，保证 $1 \leq T \leq 250$，$2 \leq n,\sum n \leq 500$，$1 \leq m \leq n^2$。保证图中不存在重边，即对于 $i \neq j$ 有 $(u_i, v_i)\neq (u_j , v_j)$。

- Subtask 1（20%）：$n ≤ 8$，$T ≤ 10$。
- Subtask 2（20%）：$n ≤ 18$，$T ≤ 10$。
- Subtask 3（20%）：$c_i$ 在 $\{0, 1\}$ 里独立均匀随机。
- Subtask 4（40%）：无特殊限制。


---

---
title: "[GDKOI2024 提高组] 染色"
layout: "post"
diff: 省选/NOI-
pid: P10085
tag: ['2024', '广东', 'Special Judge', 'O2优化']
---
# [GDKOI2024 提高组] 染色
## 题目描述

Alice 非常喜欢二进制，她认为事物只有和二进制有关才是美的。

一天，她奇思妙想了一种图案，并打算在长宽都为 $2^n$ 的网格上画出她心中所想的图案。
网格的格子只有黑色和白色两种，一开始都是白色。

现在 Alice 规定一种绘画操作为：选定一个格子，使它自己和相邻上下左右的网格颜色反转，即原本黑色会变成白色，白色会变成黑色。

Alice 还规定网格的第一行和最后一行相邻，第一列和最后一列也相邻。

现在 Alice 希望你给出一个操作方案或告诉无解。如果有多个方案，输出任意一个即可。
## 输入格式

第一行一个正整数 $n$。

接下来一个 $2^n \times 2^n$ 的矩阵，表示 Alice 所想的图案。其中 $0$ 表示白色，$1$ 表示黑色。
## 输出格式

第一行一个数 $\mathit{ans}$ 表示操作次数，或输出 $-1$ 表示无解。

接下来 $\mathit{ans}$ 行，每行一个坐标表示操作位置。其中每一维坐标范围均为 $[0, 2^n - 1]$。
## 样例

### 样例输入 #1
```
2
0 0 1 1
1 0 1 0
0 0 0 0
1 1 1 0
```
### 样例输出 #1
```
7
0 0
1 0
1 3
2 1
3 1
3 2
3 3
```
## 提示

- 对于 $20\%$ 的数据，$n = 2$。
- 对于另外 $15\%$ 的数据，$n = 4$。
- 对于另外 $15\%$ 的数据，$n = 7$。
- 对于 $100\%$ 的数据，$n \leq 11$。


---

---
title: "[ROIR 2023] 彩点 (Day 1)"
layout: "post"
diff: 省选/NOI-
pid: P10097
tag: ['2023', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2023] 彩点 (Day 1)
## 题目背景

翻译自 [ROIR 2023 D1T4](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-day1.pdf)。

平面上有 $n$ 个点，分别是 $P_1,P_2,P_3,\dots，P_n$。第 $i$ 个点的坐标为 $(x_i,y_i)$。

选择两个点 $P_i,P_j$（$i\ne j$）。设 $P_i$ 为起始点，$P_j$ 为终止点。**以终止点 $P_j$ 为中心**，从向量 $\overrightarrow{P_iP_j}$ **的方向**开始按照逆时针顺序将除 $P_j$ 以外的点进行排序（角度相同时按照到点 $P_j$ 的距离升序排序）。假设排序后的第 $t$ 个点为 $P_k$，则继续重复操作，设 $P_j$ 为起始点，$P_k$ 为终止点，按照相同的方法重新排序并计算新的终止点的编号。这个过程循环进行。

在下图中，刚开始时 $n=6,t=4,i=1,j=2$。按照顺序将除了 $P_2$ 以外的点排序，结果是 $P_3,P_5,P_1,P_6,P_4$，所以下一个终止点应该是 $P_6$，起始点是 $P_2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/x6wd9qkr.png)

此时 $n=6,t=4,i=2,j=6$。继续按照规则排序，如左下图，结果是 $P_4,P_3,P_2,P_1,P_5$。所以下一个终止点是 $P_1$，起始点是 $P_6$。

![](https://cdn.luogu.com.cn/upload/image_hosting/n2mrm47v.png)

此时 $n=6,t=4,i=6,j=1$。继续按照规则排序，如右上图，结果是 $P_5,P_6,P_4,P_2,P_3$。所以下一个终止点是 $P_2$，起始点是 $P_1$。此时就回到刚开始的情况，进入了一个循环。
## 题目描述

我们将 $n$ 个点中的每个点涂上三种颜色之一。第 $i$ 个点的颜色如下确定：

- 如果存在点 $j$，选取点 $i$ 作为起始点，点 $j$ 作为终止点，在上面的过程中点 $i$ 会无数次成为起始点，则将点 $i$ 涂成绿色。
- 如果点 $i$ 没有涂成绿色并且存在点 $j$，选取点 $i$ 作为起始点，点 $j$ 作为终止点，在上面的过程中点 $i$ 至少还能成为起始点一次，则将点 $i$ 涂成蓝色。
- 如果点 $i$ 既不是绿色也不是蓝色，则将点 $i$ 涂成红色。

对于每个点，确定它应该涂成哪种颜色。
## 输入格式

第一行包含两个整数 $n$ 和 $t$。

接下来的 $n$ 行，每行包含两个整数 $x_i$ 和 $y_i$。保证没有两个点重合。
## 输出格式

输出一行，包含 $n$ 个字符，字符串的第 $i$ 个字符表示第 $i$ 个点的颜色。

绿色点用字母 `G` 表示，蓝色点用字母 `B` 表示，红色点用字母 `R` 表示。
## 样例

### 样例输入 #1
```
6 4
-1 -1
1 -2
4 -2
2 -4
2 3
-4 -5
```
### 样例输出 #1
```
GGBBRG
```
### 样例输入 #2
```
2 1
1 1
2 2
```
### 样例输出 #2
```
GG
```
## 提示

样例 $1$ 解释：

在前面举的例子中已经知道 $P_1,P_2,P_6$ 构成一个循环，这三个点肯定会被无限次访问，所以应被涂上绿色。

当起始点是 $P_3$ 时，可以令终止点为 $P_1$，排序后 $P_3$ 正好是第四个，这样 $P_3$ 就重回起始点了，如下图。所以应该涂蓝。

![](https://cdn.luogu.com.cn/upload/image_hosting/2ftwju5s.png)

当起始点是 $P_4$ 时，可以选择 $P_5$ 为终止点，排序后 $P_4$ 正好是第四个。所以 $P_4$ 可以涂蓝。当 $P_5$ 是起始点时，易得它既不能被涂上绿色也不能被涂上蓝色，所以涂红。

本题使用捆绑测试。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $10$ | $n\le10$，所有点共线 |
| $2$ | $15$ | 所有点共线 |
| $3$ | $10$ | $n\le10$，没有蓝色点 |
| $4$ | $10$ | $n\le10$ |
| $5$ | $15$ | $n\le100$，没有蓝色点 |
| $6$ | $15$ | $n\le100$ |
| $7$ | $5$ | $n\ge3$，所有点构成一个严格凸 $n$ 边形，且按照逆时针顺序输入 |
| $8$ | $20$ | 无 |

对于全部数据，$2 \le n \le 1 000, 1 \le t \le n−1,−10^9 \le x_i, y_i \le 10^9$。


---

---
title: "[ROIR 2023] 一个普通的字符串问题 (Day 2)"
layout: "post"
diff: 省选/NOI-
pid: P10101
tag: ['2023', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2023] 一个普通的字符串问题 (Day 2)
## 题目背景

翻译自 [ROIR 2023 D2T4](https://neerc.ifmo.ru/school/archive/2022-2023/ru-olymp-regional-2023-day2.pdf)。

如果对于任意长度为 $2$ 的字符串 $u$，字符串 $s$ 中 $u$ 的出现次数与字符串 $t$ 中 $u$ 的出现次数相同，则两个字符串 $s$ 和 $t$ 称为等效字符串。因此，字符串 `aaaba`、`abaaa` 和 `baaab` 彼此等效（字符串 `aa` 出现两次，字符串 `ab` 出现一次，字符串 `ba` 出现一次，字符串 `bb` 不作为子串出现），而字符串 `cff` 和 `ccf` 则不等效。一个字符串和它本身是等效的。
## 题目描述

在这个问题中，你将会得到 $Q$ 个由字符 `a`、`b` 和 `c` 组成的字符串，对于每个字符串，需要计算与它等效的由字符 `a`、`b` 和 `c` 组成的非空字符串的数量。由于这个数量可能非常大，所以要求对 $10^9 + 7$ 取余。
## 输入格式

第一行输入一个数 $G$，表示当前子任务的编号。在样例中 $G=0$，本题另设一个分值为 $0$ 的 Subtask 0 来存储样例数据。

第二行输入一个整数 $q$。

接下来 $q$ 行，每行一个字符串。
## 输出格式

对于每个字符串输出一行一个整数表示答案，记得取模 $10^9+7$。
## 样例

### 样例输入 #1
```
0
4
abaa
abca
ccbca
bacc
```
### 样例输出 #1
```
3
3
2
1
```
## 提示

样例说明：

- 字符串 `abaa` 等效于字符串 `abaa`、`aaba`、`baab`；
- 字符串 `abca` 等效于字符串 `abca`、`bcab`、`cabc`；
- 字符串 `ccbca` 等效于字符串 `ccbca` 和 `cbcca`；
- 字符串 `bacc` 只等效于字符串 `bacc`。

本题使用捆绑测试。

$n_i$ 表示第 $i$ 个输入字符串的长度，$L$ 表示所有字符串的长度之和，$w$ 表示所有查询中最大（未取模）的答案。

| 子任务编号 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 输入数据与样例相同 |
| $1$ | $11$ | $s$ 中不含 `c` |
| $2$ | $13$ | $s$ 中 `a` 与 `c` 不相邻 |
| $3$ | $11$ | $n_i\le13$ |
| $4$ | $10$ | $L\le40$ |
| $5$ | $9$ | $L\le60$ |
| $6$ | $13$ | $L\le10^5,w\le100$ |
| $7$ | $33$ | 无 |

对于 $100\%$ 数据，$1\le q\le10^5$，$L\le10^6$。


---

---
title: "[GDKOI2023 提高组] 游戏"
layout: "post"
diff: 省选/NOI-
pid: P10105
tag: ['2023', '广东', 'Special Judge']
---
# [GDKOI2023 提高组] 游戏
## 题目描述

你正在树上玩游戏。

给定一棵 $n$ 个结点的树，有 $Q$ 次询问，每次给定 $x, y, z$，你要找到三个点 $(u, v, w)$ 满足 $\operatorname{dis}(u, v) =
x, \operatorname{dis}(u, w) = y, \operatorname{dis}(v, w) = z$。其中 $\operatorname{dis}(u, v)$ 表示树上 $u$ 和 $v$ 两点唯一简单路径所包含的边数，$\operatorname{dis}(u, u) = 0$。
保证有解。

## 输入格式

第一行一个整数 $n$，表示树的结点数。

接下来 $n - 1$ 行每行两个点 $u, v$ 表示一条 $u$ 到 $v$ 的边。

接下来一个整数 $Q$，表示询问次数。

接下来 $Q$ 行，每行三个整数 $x, y, z$ 表示一组询问。
## 输出格式

输出 $Q$ 行，每行三个整数 $u, v, w$，满足 $\operatorname{dis}(u, v) = x, \operatorname{dis}(u, w) = y, \operatorname{dis}(v, w) = z$。如果多组合法的
$(u, v, w)$，输出任意一组，保证有解。

## 样例

### 样例输入 #1
```
10
7 10
2 8
10 2
8 1
9 7
4 5
1 6
9 4
4 3
10
3 2 1
5 4 1
6 6 0
3 0 3
1 5 4
2 5 7
6 5 1
2 1 3
2 0 2
2 2 0
```
### 样例输出 #1
```
2 6 1
7 6 1
9 6 6
6 2 6
6 1 7
8 6 4
9 6 1
1 2 6
6 8 6
8 6 6
```
## 提示

对于 10% 的数据，满足 $n, Q ≤ 500$。

对于 20% 的数据，满足 $n, Q ≤ 2 \times 10^3$。

对于另外 20% 的数据，满足 $Q = 1$。

对于另外 20% 的数据，满足 $Q \le 10$。

对于另外 10% 的数据，满足第 $i$ 条边连接 $i$ 和 $i + 1$。

对于另外 10% 的数据，满足 $x = 0$。

对于 100% 的数据，满足 $1 ≤ n, Q ≤ 2 \times 10^5, 0 ≤ x, y, z ≤ 2 \times 10^5$。

下发 checker 和 checker.exe，分别用于 64 位 linux 以及 windows 下的答案校验。

你可以使用 `./checker < 输入文件名 > < 输出文件名 > < 答案文件名 >` 来检测你的输出文件是否合
法。

实际上下发的 checker 并不会用到答案文件，所以你只需要随便选择一个文件作为答案文件即可。

你需要保证输入文件合法，即格式正确并且有解，否则可能会出现未知错误。

根据你的输出文件的问题，checker 分别会返回一下信息：

1. 如果你的输出文件正确，则 checker 会返回 `Accepted!`。
2. 如果在第 $t$ 组数据，答案错误，则 checker 会返回 `Wrong answer on test t!`。
3. 如果你的格式错误，则 checker 会返回 `wrong output format` 后接相关错误信息。

UPD: 在洛谷下发 chk.cpp。


---

---
title: "[湖北省选模拟 2024] 花神诞日 / sabzeruz"
layout: "post"
diff: 省选/NOI-
pid: P10200
tag: ['2024', 'O2优化', '湖北']
---
# [湖北省选模拟 2024] 花神诞日 / sabzeruz
## 题目背景

传说，之所以这个日子会叫做「花神诞日」，其实最早是「花神祝诞」的意思。

在很久很久以前，有一次树王大人过生日，她的朋友们举办了宴席为她祝寿。

宴席上，几位神明大人都喝醉了，其中一位便乘兴弹奏起了乐器，于是树王大人唱歌，花神大人就跳起舞来。

在花神大人起舞时，她踏过的草地上，长出了无数美丽的帕蒂沙兰……

啊，若是时间能永驻此刻就好了。
## 题目描述

你正在为花神诞日准备宴席。你一共有 $N$ 种食材，依次编号为 $1,2,\cdots, N$，第 $i$ 种食材的味道为 $a_i$，任意两种食材的味道都不相同。你希望用这 $N$ 种食材做两道菜，每种食材必须被在**恰好**一道菜中使用。每道菜至少使用一种食材。

同一道菜中不同食材的味道会**两两发生反应**。食材 $i$ 与食材 $j$ 反应，将产生 $a_i \oplus a_j$ 的味道，其中 $\oplus$ 表示异或运算。一道菜最终的味道为**两两反应产生的味道的最小值**。例如，一道菜使用了味道分别为 $2,3,4$ 的三种食材，食材将会两两反应产生 $1(2 \oplus 3)$，$6(2\oplus 4)$，$7(3\oplus 4)$ 三种味道，这道菜的味道为 $\min(1,6,7)=1$。

本真的味道最为美味。**如果一道菜只使用了一种食材，这道菜的味道为 $+\infty$。**

你希望第一道菜的味道不低于 $k_1$，第二道菜的味道不低于 $k_2$。请问，你一共有多少种做菜的方案？

**请注意：相同集合的食材，分别作为第一道菜与第二道菜是两种不同的方案。** 例如，第一道菜使用食材 $1,2,3$，第二道菜使用食材 $4,5$，与第一道菜使用食材 $4,5$，第二道菜使用食材 $1,2,3$ 是两种不同的方案。

由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模的值。
## 输入格式

输入共两行。

输入的第一行为三个正整数 $N,k_1,k_2$，分别表示食材的种类数、第一道菜与第二道菜要求的味道。

输入的第二行包含 $N$ 个正整数 $a_1,a_2,\cdots,a_N$，$a_i$ 表示第 $i$ 种食材的味道。
## 输出格式

输出一行一个整数，表示做菜的方案数对 $10^9+7$ 取模的结果。
## 样例

### 样例输入 #1
```
2 10 10
1 2
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
4 2 5
5 3 1 4
```
### 样例输出 #2
```
5
```
### 样例输入 #3
```
见选手目录下的 sabzeruz/sabzeruz3.in 与 sabzeruz/sabzeruz3.ans。
```
### 样例输出 #3
```
该样例符合测试点 9 ∼ 11 的限制。
```
### 样例输入 #4
```
见选手目录下的 sabzeruz/sabzeruz4.in 与 sabzeruz/sabzeruz4.ans。
```
### 样例输出 #4
```
该样例符合测试点 12 ∼ 15 的限制。
```
### 样例输入 #5
```
见选手目录下的 sabzeruz/sabzeruz5.in 与 sabzeruz/sabzeruz5.ans。
```
### 样例输出 #5
```

```
## 提示

### 样例解释 2

做菜的五种方式列举如下：

- 第一道菜使用食材 $1,2,3$，第二道菜使用食材 $4$。
- 第一道菜使用食材 $1,2$，第二道菜使用食材 $3,4$。
- 第一道菜使用食材 $1,3$，第二道菜使用食材 $2,4$。
- 第一道菜使用食材 $2,3,4$，第二道菜使用食材 $1$。
- 第一道菜使用食材 $3,4$，第二道菜使用食材 $1,2$。

### 子任务

对于所有测试数据，保证 $1 \le N \le 2\times 10^5$，$1 \le k_1,k_2,a_i <2^{60}$。对于任意的 $1 \le i<j \le N$，有 $a_i \neq a_j$。

| 测试点编号 | $N\le$ | 特殊性质 |
| :--:|:--:|:--:|
| $1$ | $18$ | 无 |
| $2\sim 3$ | $5\times 10^3$ | A |
| $4\sim 8$ | $5\times 10^3$ | 无 |
| $9\sim 11$ | $2\times 10^5$ | A |
| $12\sim 15$ | $2\times 10^5$ | B |
| $16\sim 25$ | $2\times 10^5$ | 无 |

特殊性质 A：保证 $k_1=k_2$。

特殊性质 B：保证 $k_1=1$。


---

---
title: "[湖北省选模拟 2024] 沉玉谷 / jade"
layout: "post"
diff: 省选/NOI-
pid: P10202
tag: ['2024', 'O2优化', '湖北']
---
# [湖北省选模拟 2024] 沉玉谷 / jade
## 题目背景

倘若天下无神，这里便是人的国度。
## 题目描述

你将主持一场祭祀，祭祀会使用到 $N$ 块排成一列的玉石，玉石从左至右依次编号为 $1,2,\cdots,N$。玉石 $i$ 的颜色为 $a_i$。

每一轮祭祀，你需要选择一段颜色相同的玉石 $a_l \sim a_r(1\le l \le r\le N\le 50)$，并将它们沉入水中。本次祭祀的仙力值 $K$ 将变为 $10000\cdot K+100\cdot l+r$，$K$ 的初始值为 $0$。

一段玉石被沉入水中后，右侧的玉石会向左移动。**同时，编号也会发生变化**，从左至右依次编号为 $1,2,\cdots$。例如，共有 $7$ 块玉石，颜色依次为 $1,1,2,2,2,3,2$。一开始，颜色为 $3$ 的玉石编号为 $6$，在 $3\sim 5$ 号玉石被沉入水中后，其编号将变为 $3$。

当所有玉石被沉入水中，祭祀完成，此时的仙力值即为本次祭祀的仙力值。请问祭祀完成后，一共可能得到多少种不同的仙力值？

由于答案可能很大，你只需要输出答案对 $10^9+7$ 取模的值。
## 输入格式

输入共两行。

输入的第一行为一个正整数 $N$，表示玉石的个数。

输入的第二行为 $N$ 个正整数 $a_1,a_2,\cdots,a_N$，其中 $a_i$ 表示第 $i$ 块玉石的颜色。
## 输出格式

输出一行一个整数，表示不同仙力值的种数对 $10^9+7$ 取模的结果。
## 样例

### 样例输入 #1
```
1
1
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
3
3 3 1
```
### 样例输出 #2
```
8
```
### 样例输入 #3
```
5
1 2 1 2 1

```
### 样例输出 #3
```
165
```
### 样例输入 #4
```
见选手目录下的 jade/jade4.in 与 jade/jade4.ans。
```
### 样例输出 #4
```
该样例满足测试点 5 ∼ 8 的限制。
```
### 样例输入 #5
```
见选手目录下的 jade/jade5.in 与 jade/jade5.ans。
```
### 样例输出 #5
```
该样例满足测试点 9 ∼ 12 的限制。
```
### 样例输入 #6
```
见选手目录下的 jade/jade6.in 与 jade/jade6.ans。
```
### 样例输出 #6
```
该样例满足测试点 13 ∼ 16 的限制。
```
### 样例输入 #7
```
见选手目录下的 jade/jade7.in 与 jade/jade7.ans。
```
### 样例输出 #7
```

```
## 提示

### 样例解释 3

这里列举两种可能得到的仙力值和得到的方式：

1. $(1,\underline{2},1,2,1) \xrightarrow{K=202} (1,1,\underline{2},1) \xrightarrow{K=2\ 020\ 303} (\underline{1},\underline{1},1) \xrightarrow{K=20\ 203\ 030\ 102} (\underline{1}) \xrightarrow{K=202\ 030\ 301\ 020\ 101} ()$，得到的仙力值 $K$ 为 $202\ 030\ 301\ 020\ 101$。

2. $(1,2,\underline{1},2,1) \xrightarrow{K=303} (1,\underline{2},\underline{2},1) \xrightarrow{K=3\ 030\ 203} (\underline{1},\underline{1}) \xrightarrow{K=30\ 302\ 030\ 102} ()$，得到的仙力值 $K$ 为 $30\ 302\ 030\ 102$。


### 子任务

对于所有测试数据，保证 $1 \le N \le 50$，$1 \le a_i \le N$。

| 测试点编号 | $N\le$ | 特殊性质 |
| :--: | :--: | :--: |
| $1\sim 2$ | $18$ | 无 |
| $3$ | $50$ | A |
| $4$ | $50$ | B |
| $5\sim 8$ | $50$ | C,D |
| $9\sim 12$ | $50$ | C |
| $13\sim 16$ | $50$ | D |
| $17\sim 25$ | $50$ | 无 |

特殊性质 A：保证 $a_i=i$。

特殊性质 B：保证 $a_i=1$。

特殊性质 C：保证不存在 $p_1<p_2<p_3<p_4$，使得 $a_{p_1}=a_{p_3},a_{p_2}=a_{p_4},a_{p_1}\neq a_{p_2}$。

特殊性质 D：保证不存在 $p_1<p_2<p_3$，使得 $a_{p_1}=a_{p_2}=a_{p_3}$。


---

---
title: "[湖北省选模拟 2024] 玩具销售员 / tartaglia"
layout: "post"
diff: 省选/NOI-
pid: P10203
tag: ['2024', 'O2优化', '湖北']
---
# [湖北省选模拟 2024] 玩具销售员 / tartaglia
## 题目背景

孩童时期的梦是最易碎的东西，哪怕放着不管，也总有一天会自己碎掉，所以，一定要有人来保护才行吧。
## 题目描述

“独眼小宝”是托克最喜欢的玩具，作为璃月最好的玩具销售员，达达利亚共招募了 $N$ 位经销商负责分销“独眼小宝”，$N$ 位经销商依次编号为 $1,2,\cdots,N$。

$N$ 位经销商中共形成了 $M$ 对交易关系，依次编号为 $1,2,\cdots,M$，第 $i$ 对交易关系联系起经销商 $u_i,v_i$。对于第 $i$ 对交易关系，当一方获知“独眼小宝”的生产情报时，将有 $\dfrac{p_i}{q_i}$ 的概率告知另一方。形式化地，经销商和他们之间的交易关系构成了一张无向图，**数据保证这张无向图是连通的、无自环的和无重边的。**

一些经销商 $a_1,a_2,\cdots,a_k(k>2)$ 构成**商业集团**，**当且仅当**存在 $k$ 组不同的交易关系，使得第 $w$ 组关系联系起经销商 $a_w,a_{w \bmod k+1}$。形式化地，一个商业集团对应 $k$ 名经销商和他们的交易关系图中的一个简单环。**一名经销商最多属于一个商业集团。**

现在，达达利亚希望对这些经销商进行测试，他共进行了 $Q$ 次**独立的**测试。对于第 $i$ 次测试，达达利亚将“独眼小宝”的生产情报告知了经销商 $S_i$，请问期望条件下，共有多少名经销商会得知该情报？

**可以证明，期望一定可以被表示为 $\dfrac{p}{q}$ 的形式，你需要输出 $p\cdot q^{-1}\pmod {998\ 244\ 353}$ 的值。**
## 输入格式

输入共 $M+Q+1$ 行。

输入的第一行为三个正整数 $N,M,Q$，分别表示经销商数量、交易关系数量和测试次数。

接下来 $M$ 行，每行四个正整数 $u_i,v_i,p_i,q_i$，表示第 $i$ 条交易关系联系的经销商与告知概率。

接下来 $Q$ 行，每行一个整数 $S_i$，表示第 $i$ 次测试所告知的经销商。
## 输出格式

输出 $Q$ 行。对于每组询问，输出一行一个整数，表示期望对 $998\ 244\ 353$ 取模的结果。
## 样例

### 样例输入 #1
```
4 4 1
1 2 1 2
3 2 1 3
3 4 1 5
2 4 1 2
1
```
### 样例输出 #1
```
565671802
```
### 样例输入 #2
```
9 9 5
9 3 3 5
9 1 1 2
9 2 1 1
4 7 4 5
2 4 2 3
6 8 1 4
5 6 1 3
3 5 2 5
8 3 3 5
1
3
4
7
5
```
### 样例输出 #2
```
35936800
46584741
380663851
584039500
757135070
```
### 样例输入 #3
```
见选手目录下的 tartaglia/tartaglia3.in 与 tartaglia/tartaglia3.ans。
```
### 样例输出 #3
```
该样例满足测试点 1 ∼ 2 的限制。
```
### 样例输入 #4
```
见选手目录下的 tartaglia/tartaglia4.in 与 tartaglia/tartaglia4.ans。
```
### 样例输出 #4
```
该样例满足测试点 10 ∼ 13 的限制。
```
### 样例输入 #5
```
见选手目录下的 tartaglia/tartaglia5.in 与 tartaglia/tartaglia5.ans。
```
### 样例输出 #5
```
该样例满足测试点 14 ∼ 19 的限制。
```
### 样例输入 #6
```
见选手目录下的 tartaglia/tartaglia6.in 与 tartaglia/tartaglia6.ans。
```
### 样例输出 #6
```

```
## 提示

### 样例解释 1

![](https://cdn.luogu.com.cn/upload/image_hosting/ii4noq6d.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/qz2o6jfu.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/dbojsfej.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/xq08n2l2.png)

上图展现了所有的 $16$ 种可能的图连通情况，从上至下，从左至右，依次编号为 $1\sim 16$。对于节点 $1$ 的询问，我们依次计算 $16$ 种情况中节点 $1$ 能到达的节点数和该情况对应的概率：

| 图编号 | 节点数 | 概率 | 期望 |
| :--: | :--: | :--: | :--: |
| $1$ | $4$ | $\frac{1}{60}$ | $\frac{1}{15}$ |
| $2$ | $1$ | $\frac{1}{60}$ | $\frac{1}{60}$ |
| $3$ | $4$ | $\frac{1}{30}$ | $\frac{2}{15}$ |
| $4$ | $4$ | $\frac{1}{15}$ | $\frac{4}{15}$ |
| $5$ | $4$ | $\frac{1}{60}$ | $\frac{1}{15}$ |
| $6$ | $1$ | $\frac{1}{30}$ | $\frac{1}{30}$ |
| $7$ | $1$ | $\frac{1}{15}$ | $\frac{1}{15}$ |
| $8$ | $1$ | $\frac{1}{60}$ | $\frac{1}{60}$ |
| $9$ | $3$ | $\frac{2}{15}$ | $\frac{2}{5}$ |
| $10$ | $2$ | $\frac{1}{30}$ | $\frac{1}{15}$ |
| $11$ | $3$ | $\frac{1}{15}$ | $\frac{1}{5}$ |
| $12$ | $1$ | $\frac{2}{15}$ | $\frac{2}{15}$ |
| $13$ | $1$ | $\frac{1}{30}$ | $\frac{1}{30}$ |
| $14$ | $1$ | $\frac{1}{15}$ | $\frac{1}{15}$ |
| $15$ | $2$ | $\frac{2}{15}$ | $\frac{4}{15}$ |
| $16$ | $1$ | $\frac{2}{15}$ | $\frac{2}{15}$ |

求和，得到 $E=\sum E_i=\frac{59}{30}\equiv 565\ 671\ 802\pmod{998\ 244\ 353}$。

### 子任务

对于所有测试数据，保证 $1 \leq N,M,Q \leq 3 \times 10^5$，$1 \le u_i,v_i \le N$，$u_i\neq v_i$，$1 \le p_i,q_i < 998\ 244 \ 353$，$1 \le S_i \le N$。

| 测试点编号 | $N,M,Q\le$ | 特殊性质 |
| :--: | :--: | :--: |
| $1\sim 2$ | $17$ | 无 |
| $3\sim 4$ | $2\times 10^3$ | A |
| $5\sim 7$ | $2\times 10^3$ | B |
| $8\sim 9$ | $2\times 10^3$ | 无 |
| $10\sim 13$ | $3\times 10^5$ | A |
| $14\sim 19$ | $3\times 10^5$ | B |
| $20\sim 25$ | $3\times 10^5$ | 无 |

特殊性质 A：不存在集团。

特殊性质 B：有且只有一个集团。

### 提示

在本题中，你可能需要使用较大的栈空间。在最终测试时，程序可使用的栈空间内存限制与题目内存限制一致。

若你使用 Linux 系统，可使用命令 `ulimit -s unlimited` 解除系统栈空间限制。若你使用 Windows 系统，可在编译命令后添加 `-Wl,--stack=1024000000`，以将系统栈空间限制修改为约 1024MiB。


---

---
title: "【模板】Pfaffian"
layout: "post"
diff: 省选/NOI-
pid: P10216
tag: []
---
# 【模板】Pfaffian
## 题目背景

称一个长度为 $2n$ 的排列 $\pi$ 是完美匹配，当且仅当其满足
- $\forall 1\le i\le n,\pi_{2i-1}<\pi_{2i}$
- $\forall 1\le i< n,\pi_{2i-1}<\pi_{2i+1}$

记 $\textup{inv }\pi$ 表示 $\pi$ 的逆序对数，$\textup{sgn }\pi=(-1)^{\textup{inv }\pi}$，$\mathfrak{M}_{2n}$ 表示全体长度为 $2n$ 的完美匹配构成的集合。
	
令 $\mathbf{A}=(a_{i,j})_{1\le i<j\le 2n}$ 是一个反对称矩阵，定义 $\mathbf{A}$ 的 $\text{Pfaffian}$ 为
$$\textup{Pf}(\mathbf{A})=\sum\limits_{\pi\in\mathfrak{M}_{2n}}(\textup{sgn }\pi)\prod\limits_{i=1}^{n}a_{\pi(2i-1),\pi(2i)}$$
## 题目描述

给定偶数 $n$ 与反对称矩阵 $\mathbf{A}=(a_{i,j})_{1\le i<j\le n}$，求 $\textup{Pf}(\mathbf{A})$ 对 $10^9+7$ 取模的结果。
## 输入格式

第一行一个正整数 $n$，保证 $n$ 是偶数。

接下来 $n-1$ 行，第 $i$ 行有 $n-i$ 个非负整数，其中第 $j$ 个整数表示 $a_{i,i+j}$。
## 输出格式

一行一个非负整数，表示答案。
## 样例

### 样例输入 #1
```
4
1 2 3
4 5
6
```
### 样例输出 #1
```
8
```
## 提示

对于 $30\%$ 的数据，$n\le 10$。

对于 $100\%$ 的数据，$2\leq n\le 500$，$0\le a_{i,j}<10^9+7$。


---

---
title: "[省选联考 2024] 迷宫守卫"
layout: "post"
diff: 省选/NOI-
pid: P10220
tag: ['各省省选', '2024', 'O2优化']
---
# [省选联考 2024] 迷宫守卫
## 题目描述

Alice 拥有一座迷宫，这座迷宫可以抽象成一棵拥有 $2^n$ 个叶节点的满二叉树，总节点数目为 $(2^{n+1} - 1)$，依次编号为 $1 \sim (2^{n+1} - 1)$。其中编号为 $2^n \sim (2^{n+1} - 1)$ 的是叶节点，编号为 $1 \sim (2^n - 1)$ 的是非叶节点，且非叶节点 $1 \le u \le (2^n - 1)$ 的左儿子编号为 $2u$，右儿子编号为 $(2u + 1)$。

每个非叶节点都有一个石像守卫，初始时，所有石像守卫均在沉睡。唤醒 $u$ 点的石像守卫需要 $w_u$ 的魔力值。

每个叶节点都有一个符文，$v$ 点的符文记作 $q_v$。**保证 $q_{2^n}, q_{2^n+1},\cdots, q_{2^{n+1}-1}$ 构成 $1 \sim 2^n$ 的排列**。

探险者初始时持有空序列 $Q$，从节点 $1$ 出发，按照如下规则行动：

- 到达叶节点 $v$ 时，将 $v$ 点的符文 $q_v$ 添加到序列 $Q$ 的末尾，然后返回父节点。
- 到达非叶节点 $u$ 时：
  - 若该点的石像守卫已被唤醒，则只能先前往左儿子，（从左儿子返回后）再前往右儿子，（从右儿子返回后）最后返回父节点。
  - 若该点的石像守卫在沉睡，可以在以下二者中任选其一：
    - 先前往左儿子，再前往右儿子，最后返回父节点。
    - 先前往右儿子，再前往左儿子，最后返回父节点。

返回节点 $1$ 时，探险结束。可以证明，探险者一定访问每个叶节点各一次，故此时 $Q$ 的长度为 $2^n$。

探险者 Bob 准备进入迷宫，他希望探险结束时的 $Q$ 的字典序越小越好，与之相对，Alice 希望 $Q$ 的字典序越大越好。

在 Bob 出发之前，Alice 可以选择一些魔力值花费之和不超过 $K$ 的石像守卫，并唤醒它们。Bob 出发时，他能够知道 Alice 唤醒了哪些神像。若**双方都采取最优策略**，求序列 $Q$ 的最终取值。

对于两个长度为 $2^n$ 的序列 $Q_1,Q_2$，称 $Q_1$ 字典序小于 $Q_2$ 当且仅当以下条件成立：

- $\exist i \in [1, 2^n]$ 满足以下两个条件：
  - $\forall 1 \le j < i，Q_{1,j} = Q_{2,j}$；
  - $Q_{1,i} < Q_{2,i}$。
## 输入格式

**本题有多组测试数据**。输入的第一行包含一个正整数 $T$，表示测试数据组数。

接下来依次 $T$ 组测试数据。对于每组测试数据：

- 第一行两个整数 $n,K$ 表示迷宫规模和 Alice 可用于唤醒石像守卫的魔力值上限。
- 第二行 $(2^n - 1)$ 个整数 $w_1,w_2,\cdots,w_{2^n-1}$ 表示唤醒各个石像守卫耗费的魔力值。
- 第三行 $2^n$ 个整数 $q_{2^n}, q_{2^n+1},\cdots, q_{2^{n+1}-1}$ 表示各个叶节点上的符文。
## 输出格式

对于每组数据，输出一行 $2^n$ 个整数 $Q_1,Q_2,\cdots,Q_{2^n}$，表示双方都采取最优策略的情况下，序列 $Q$ 的最终取值。
## 样例

### 样例输入 #1
```
3
1 0
1
2 1
1 1
1
2 1
3 3
3 2 1 2 1 2 1
4 2 6 3 7 1 5 8
```
### 样例输出 #1
```
1 2
2 1
2 4 6 3 5 8 7 1
```
## 提示

**【样例 1 解释】**

- 第一组数据中，Alice 无法唤醒石像守卫，Bob 可以选择先访问叶节点 $3$，再访问叶节点 $2$，得 $Q = \{1, 2\}$。
- 第二组数据中，Alice 可以唤醒节点 $1$ 的石像守卫，Bob 只能先访问叶节点 $2$，再访问叶节点 $3$，得 $Q = \{2, 1\}$。
- 第三组数据中，Alice 的最优策略是唤醒节点 $5, 6$ 的石像守卫。

**【样例 2】**

见附件中的 `maze2.in/ans`。

该组数据满足特殊性质 A。

**【样例 3】**

见附件中的 `maze3.in/ans`。

该组数据满足特殊性质 B。

**【样例 4】**

见附件中的 `maze4.in/ans`。

**【样例 5】**

见附件中的 `maze5.in/ans`。

**【子任务】**

设 $\sum 2^n$ 表示单个测试点钟所有测试数据的 $2^n$ 的和。对于所有测试数据，保证

- $1\le T \le 100$；
- $1\le n \le 16$，$1 \le \sum 2^n \le 10^5$；
- $0\le K \le 10^{12}$
- $\forall 1 \le u \le (2^n-1)$，$0 \le w_u \le 10^{12}$；
- $q_{2^n},q_{2^n+1},\cdots,q_{2^{n+1}-1}$ 构成 $1\sim 2^n$ 的排列。

| 测试点编号 | $n\le$ | $\sum 2^n \le$ | 特殊性质 |
| :--: | :--: | :--: | :--: |
| $1\sim 5$ | $4$ | $80$ | 无 |
| $6$ | $6$ | $200$ | A |
| $7\sim 8$ | $6$ | $200$ | B |
| $9\sim 10$ | $6$ | $200$ | 无 |
| $11$ | $11$ | $4000$ | A |
| $12\sim 13$ | $11$ | $4000$ | B |
| $14\sim 15$ | $11$ | $4000$ | 无 |
| $16$ | $16$ | $10^5$ | A |
| $17\sim 18$ | $16$ | $10^5$ | B |
| $19\sim 20$ | $16$ | $10^5$ | 无 |

特殊性质 A：$\forall 2^n \le v \le (2^{n+1}-1)$，$q_v = (2^{n+1}-v)$。

特殊性质 B：$\forall 1 \le u \le (2^n-1)$，$w_u = 1$。


---

---
title: "[COCI 2023/2024 #3] Restorani"
layout: "post"
diff: 省选/NOI-
pid: P10226
tag: ['2023', 'COCI（克罗地亚）']
---
# [COCI 2023/2024 #3] Restorani
## 题目背景

**译自 [COCI 2023/2024 Contest #3](https://hsin.hr/coci/archive/2023_2024) T4「[Restorani](https://hsin.hr/coci/archive/2023_2024/contest3_tasks.pdf)」**
## 题目描述

来到塞格德，Malnar 先生像通常一样，必须了解当地文化，品尝所有传统餐点、特色美食和当地饮料。

我们可以把塞格德想象成由 $n - 1$ 条双向道路连接的 $n$ 个景点，这些景点的编号从 $1$ 到 $n$。这样，每一对景点之间都有一条路径。令人惊奇的是，Malnar 先生走过每条道路正好需要一分钟。在景点行走的时间可以忽略不计。

Malnar 先生有一份他想去的 $m$ 家餐厅的清单。它由 $m$ 个正整数组成，其中第 $i$ 个数表示第 $i$ 个餐厅在哪个景点附近。

一个问题是 Malnar 先生在餐厅用餐后，必须马上去甜品店吃冰淇淋。另一个问题是，他拒绝两次光顾同一家甜品店。

幸运的是他有备而来，因为他知道 $m$ 家甜品店，这些甜品店的位置是由 $m$ 个正整数组成的列表，其中第 $i$ 个数字代表第 $i$ 家甜品店在这个景点附近。

Malnar 先生旅途劳累，不想走更多的路，因此他请你计算一下他需要走多少路，并提供去餐厅和甜品店的顺序，这样他就可以在没有帮助的情况下穿梭于餐厅和甜品店之间了。

Malnar 先生目前在景点 $1$，并且必须在最后回到景点 $1$。
## 输入格式

第一行包含整数 $n$ 和 $m\ (1\le m\le n\le 3\cdot 10^5)$，分别表示景点个数和餐厅/甜品店个数。

第二行包含 $m$ 个整数 $a_i\ (1\le a_i\le n,\forall i\neq j,a_i\neq a_j)$，表示餐厅清单。

第二行包含 $m$ 个整数 $b_i\ (1\le b_i\le n,\forall i\neq j,b_i\neq b_j)$，表示甜品店清单。

接下来 $n-1$ 行，每行两个整数 $x_i$ 和 $y_i\ (1\le x_i,y_i\le n)$，表示景点 $x_i$ 和 $y_i$ 之间有一条道路。
## 输出格式

第一行输出 $t$，表示 Malnar 先生为了去所有餐厅和甜品店，并最后返回景点 $1$ 的最短用时。

第二行输出 $2m$ 个整数 $v_i$，表示去餐厅和甜品店的顺序。

在奇数位置的数表示餐馆，这些数必须组成前 $m$ 个正整数的排列。在偶数位置的数表示甜品店，这些数也必须组成前 $m$ 个正整数的排列。

按上述顺序去景点并返回开始位置所经历的时间必须为最短时间 $t$。

如果有多个最优顺序，输出任意一个均可。
## 样例

### 样例输入 #1
```
3 1
2
3
1 2
1 3

```
### 样例输出 #1
```
4
1 1

```
### 样例输入 #2
```
9 4
2 3 4 6
4 5 8 9
1 2
1 3
3 4
3 5
5 6
1 7
7 8
7 9

```
### 样例输出 #2
```
18
3 1 4 2 2 4 1 3

```
### 样例输入 #3
```
10 5
3 5 6 7 8
1 2 4 9 10
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10

```
### 样例输出 #3
```
24
4 4 5 5 3 3 2 2 1 1

```
## 提示

### 样例解释 1

Malnar 先生首先走一分钟前往唯一在景点 $2$ 的餐厅，然后走两分钟到唯一在景点 $3$ 的甜品店，然后花一分钟走回景点 $1$。Malnar 先生总共会花 $1+2+1=4$ 分钟。

### 样例解释 2

Malnar 先生按如下顺序去餐厅和甜品店：在景点 $4$ 的餐厅（$2$ 分钟），在景点 $4$ 的甜品店（$0$ 分钟），在景点 $6$ 的餐厅（$3$ 分钟），在景点 $5$ 的甜品店（$1$ 分钟），在景点 $3$ 的餐厅（$1$ 分钟），在景点 $9$ 的甜品店（$3$ 分钟），在景点 $2$ 的餐厅（$3$ 分钟），在景点 $8$ 的甜品店（$3$ 分钟）。在景点 $8$ 处的甜品店吃完冰淇淋后，他返回景点 $1$（$2$ 分钟）。Malnar 先生一共走了 $2+0+3+1+1+3+3+3+2=18$ 分钟。

### 样例解释 3

Malnar 先生按如下顺序去餐厅和甜品店：在景点 $7$ 的餐厅（$6$ 分钟），在景点 $9$ 的甜品店（$2$ 分钟），在景点 $8$ 的餐厅（$1$ 分钟），在景点 $10$ 的甜品店（$2$ 分钟），在景点 $6$ 的餐厅（$4$ 分钟），在景点 $4$ 的甜品店（$2$ 分钟），在景点 $5$ 的餐厅（$1$ 分钟），在景点 $2$ 的甜品店（$3$ 分钟），在景点 $3$ 的餐厅（$1$ 分钟），在景点 $1$ 的甜品店（$2$ 分钟）。在吃完最后的冰淇淋后，他已经在景点 $1$ 所以他不会移动。Malnar 先生一共走了 $24$ 分钟。

### 子任务

| 子任务编号 |                附加限制                | 分值 |
| :--------: | :------------------------------------: | :--: |
|    $1$     |         $n\le 5\ 000,m\le 10$          | $18$ |
|    $2$     | $\forall i=1,\ldots,n-1,x_i=i,y_i=i+1$ | $18$ |
|    $3$     |             $n\le 5\ 000$              | $27$ |
|    $4$     |               无附加限制               | $37$ |


---

---
title: "在四方城外"
layout: "post"
diff: 省选/NOI-
pid: P10272
tag: []
---
# 在四方城外
## 题目背景

> 柳花、青山与月光。
>
> 诗中的酒香与诗外的酒香。
>
> 城中的天空与城外的天空。
>
> 一字一句，一笔一划，所知晓的，尚懵懂的。
>
> 	看呀看，学呀学，世界正如浊酒，滋味饮酌方知。
## 题目描述

定义字符串 $S$ 的**扩展**操作为：

- 求出 $S$ 的最长 $\text{border}$ $T$。

- $S'\leftarrow S+T$。

**注意，本题的 $\text{border}$ 指真 $\text{border}$（即字符串本身不计入 $\text{border}$）**。

设**扩展**操作的权值为**扩展**后字符串的长度 $|S'|$，请求出字符串 $S$ 第 $L$  次**扩展**到第 $R$ 次**扩展**的权值之和。

由于结果可能很大，请输出答案对 $998244353$ 取模的结果。
## 输入格式

第一行一个字符串 $S$。

第二行两个整数 $L,R$。
## 输出格式

输出为一个数，即答案对 $998244353$ 取模的结果。
## 样例

### 样例输入 #1
```
ababcab
1 3
```
### 样例输出 #1
```
39
```
### 样例输入 #2
```
aa
3 5
```
### 样例输出 #2
```
59
```
## 提示

### 样例一解释

第 $1$ 次扩展操作：`ababcab[ab]`，权值为 $9$。

第 $2$ 次扩展操作：`ababcabab[abab]`，权值为 $13$。

第 $3$ 次扩展操作：`ababcabababab[abab]`，权值为 $17$。

权值之和为 $9+13+17=39$。

### 数据范围与约束

对于 $30\%$ 的数据，$1 \le |S| \le 100,1 \le L,R \le 10$。

对于 $60\%$ 的数据，$1 \le L,R \le 10^6$。

对于另外 $10\%$ 的数据，$\text{border}_{S}=|S|-1$。

对于 $100\%$ 的数据，$1 \le |S| \le 10^6,1 \le L \le R \le 10^9$，输入均为整数和小写字母。


---

---
title: "[CCC 2024 S5] Chocolate Bar Partition"
layout: "post"
diff: 省选/NOI-
pid: P10299
tag: ['2024', 'CCC（加拿大）']
---
# [CCC 2024 S5] Chocolate Bar Partition
## 题目描述

Maxwell 有一块巧克力想和他的朋友们分享。巧克力可以看作 $2\times N$ 个小方块组成的，每个小方块的美味度可以表示为 $2 \times N$ 的整数数组 $T_{i,j}$。Maxwell 想把整个巧克力分成若干个连通块，每个连通块的巧克力小方格的平均美味程度都是一样的。Maxwell 想知道根据如上所述，他可以将巧克力棒分成的最大连通块数量是多少。

如果可以通过向上、向下、向左或向右移动的方式访问到每个小方块，则该部分被视为一个连通块。
## 输入格式

输入的第一行包含一个正整数 $N$ 表示巧克力的长度。

第二行包含 $N$ 个空格隔开的整数，第 $j$ 个整数表示巧克力的第一行第 $j$ 个小方块的美味度 $T_{1,j}$。

类似地，第三行包含 $N$ 个空格隔开的整数，第 $j$ 个整数表示巧克力的第二行第 $j$ 个小方块的美味度 $T_{2,j}$。
## 输出格式

输出一个整数，表示 Maxwell 最多能把巧克力切分出的连通块数。

## 样例

### 样例输入 #1
```
2
5 4
6 5

```
### 样例输出 #1
```
2

```
### 样例输入 #2
```
5
1 0 1 2 0
0 2 0 3 1

```
### 样例输出 #2
```
5

```
## 提示


**【样例 1 解释】**

把巧克力分割成 $2$ 块是最优的，一种方案是把右下角的一个小方块作为一个连通块，其余三个小方块作为第二个连通块，如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/2yga1u9u.png)

每一个连通块的平均美味度都为 $5$。

**【样例 2 解释】**

一种获得平均分割巧克力的方案如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/hty1ata8.png)

注意每一块的平均美味度都为 $1$。

**【数据范围】**

**本题采用捆绑测试。**

对于所有数据，保证 $1 \leq N \leq 2 \times 10^5$，$0 \leq T_{i,j} \leq 10^8$。

下面的表格显示了 $15$ 分的分配方案：

| 分值 | $N$ 的范围 | $T_{i,j}$ 的范围 |
| :-: | :-: | :-: |
| $2$ | $N = 2$ | $0 \leq T_{i,j} \leq 5$ |
| $2$ | $1 \leq N \leq 8$ | $0 \leq T_{i,j} \leq 20$ |
| $1$ | $1 \leq N \leq 20$ | $0 \leq T_{i,j} \leq 20$ |
| $2$ | $1 \leq N \leq 100$ | $0 \leq T_{i,j} \leq 20$ |
| $2$ | $1 \leq N \leq 1000$ | $0 \leq T_{i,j} \leq 100$ |
| $3$ | $1 \leq N \leq 2000$ | $0 \leq T_{i,j} \leq 10^5$ |
| $3$ | $1 \leq N \leq 2 \times 10^5$ | $0 \leq T_{i,j} \leq 10^8$ |



---

---
title: "[UESTCPC 2024] 一站到底"
layout: "post"
diff: 省选/NOI-
pid: P10332
tag: ['2024', 'Special Judge', 'O2优化', '高校校赛']
---
# [UESTCPC 2024] 一站到底
## 题目描述

假设你是电子科技大学的学生李华，在 4202 年的某一期一站到底中，你作为选手参加了节目的录制。不同于 2000 多年前的规则，节目中不会进行选手两两对战并抢答或轮答题目的环节，每位选手的答题以单人赛的方式进行，具体规则如下：

在选手的答题环节开始前，系统会从题库中抽取 $n$ 道题，每道题根据难度系数有 $a_i$ 的分值。主持人会在一开始公布所有的题目内容和分值，之后进入选手的答题环节。

为了增加节目的趣味性，在答题环节中，选手并不能随意选择作答题目的顺序。具体的，除 $1$ 号题目外所有题目**有且仅有**一道前置题目，在选手正确作答出某道题的前置题目后才可以进行作答这道题。节目组保证编号为 $i$ 的题目的前置题目编号必然小于 $i$。

此外，如果选手作答题目时提交了错误答案，那么其脚下的地板将立刻打开，选手掉落并结束作答，此前答对的所有题目的分值之和就是该选手的得分。如果选手答对了所有的题目，那么所有题目的分值之和就是该选手的得分。

现在你已经看完了所有的题目，根据你的知识储备，你判断出了每道题你做对的概率 $p_i$。你需要在最短时间内制定出最优的做题策略去最大化你的期望得分，请输出这个得分，~~并以参加这次节目的过程为主题写一篇不少于 120 词的英语作文~~。
## 输入格式

第一行一个正整数 $n$ $(2\le n\le 10^5)$，代表题目的数量。

接下来一行 $n$ 个正整数 $a_1,a_2,\ldots,a_n$ $(1\leq a_i\leq 10^6)$，$a_i$ 代表编号为 $i$ 的题目的分值。

接下来一行 $n$ 个实数 $p_1,p_2,\ldots,p_n$ $(0<p_i<1)$，$p_i$ 代表你答对编号为 $i$ 的题目的概率。

接下来一行 $n-1$ 个正整数 $t_1,t_2,\ldots,t_{n-1}$ $(1\leq t_i\leq i)$，$t_i$ 代表编号为 $i+1$ 的题目的前置题目的编号。
## 输出格式

输出一行一个实数，代表在最优做题策略下的期望得分。

假设你的输出是 $a$，答案是 $b$，当且仅当 $\frac{|a-b|}{\max(1,b)}\le 10^{-9}$ 时，你的答案会被认为是正确的。
## 样例

### 样例输入 #1
```
5
5 4 3 2 1
0.9 0.89 0.88 0.87 0.86
1 1 2 2
```
### 样例输出 #1
```
11.572522416
```
## 提示

在样例中，分值越高的题目你也有越大的概率答对，显然按照 $1,2,3,4,5$ 的顺序去答题最优。


---

---
title: "[PA 2024] Desant 3"
layout: "post"
diff: 省选/NOI-
pid: P10360
tag: ['2024', 'PA（波兰）']
---
# [PA 2024] Desant 3
## 题目背景

PA 2024 4B
## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 4 [Desant 3](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/des/)，感谢 Macaronlin 提供翻译**

$n$ 个士兵，从左到右编号为 $1$ 到 $n$。每个士兵有两种状态：准备好和未准备好。现对这些士兵下发 $m$ 条命令，第 $i$ 条命令会使得在 $a_i$ 位置和 $b_i$ 位置的士兵交换位置，但只有 $a_i$ 位置的士兵准备好并且 $b_i$ 位置的士兵没有准备好时才能交换，否则无效。

问对于 $1$ 到 $n$ 中的每个整数 $k$，考虑 $\binom{n}{k}$ 种士兵的初始准备情况，其中有 $k$ 个士兵已准备好，求有多少种准备情况可以在进行 $m$ 条命令后，满足所有准备好的士兵形成一段连续区间。你只需要输出种类数对 $2$ 取模后的值即可。
## 输入格式

第一行两个整数 $n$ 和 $m\ (2\le n\le 35,1\le m\le 1\,000)$，分别表示士兵数和命令数。

接下来 $m$ 行，每行两个整数 $a_i$ 和 $b_i\ (1\le a_i,b_i\le n,a_i\neq b_i)$，描述一条命令。
## 输出格式

输出一行 $n$ 个整数，其中第 $k$ 个整数表示有 $k$ 个士兵准备好的所有初始情况中，可以在进行 $m$ 条命令后使得所有准备好的士兵形成一段连续区间的情况数。输出对 $2$ 取模。
## 样例

### 样例输入 #1
```
4 4
4 1
1 2
3 4
1 4

```
### 样例输出 #1
```
0 0 1 1

```
## 提示

如果一开始只有一名士兵准备好，那么无论如何操作，最终准备好的士兵一定形成一个连续的区间。

考虑这样一种情况：除了队列中的第二名士兵外，其他士兵都已准备好。第一个命令不会影响士兵的位置。第二道命令下达后，由于队列中的第一名士兵已准备好，而第二名士兵尚未准备好，他们将交换位置。第三道命令同样没有影响。由于现在队列中的第一名士兵还没有准备好，而队列中的第四名士兵已经准备好，因此他们不会因为最后一道命令而交换位置。最终只有排在第一位的士兵没有准备好。这是 $k = 3$ 时唯一一种满足条件的初始情况。

未取模前的答案为 $[4,0,1,1]$。


---

---
title: "[PA 2024] Kraniki"
layout: "post"
diff: 省选/NOI-
pid: P10365
tag: ['2024', 'PA（波兰）']
---
# [PA 2024] Kraniki
## 题目背景

PA 2024 5B2
## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 5 [Kraniki](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/kra/)**

*Radek and Friends* 公司的负责人 Radek 试图淹没竞争对手 *Mati and Company* 公司的所有货架。为了进行完美的破坏，他让他的朋友，水管工 Janusz 在每个架子都上安装了小水龙头。

为简单起见，*Mati and Company* 公司中的货架可以用平面上的线段来表示。每个货架都是一对点 $(l_i,h_i)$ 和 $(r_i,h_i)$ 之间的线段。水管工安装的水龙头是坐标为 $(\frac{l_i+r_i}{2}, h_i + 0.5)$ 的点。这个房间的地面用 $OX$ 轴表示。

只要打开第 $i$ 个货架上方的水龙头，该货架就会被水淹没。之后水会自然开始从货架的两端垂直向下滴落，并有可能淹没更多的货架，或自然滴落到地面上。

![](https://cdn.luogu.com.cn/upload/image_hosting/uwllkpr7.png)

在第二组样例中，当打开一个水龙头时，水流的可视化效果.

Radek 会按某个确定的顺序看水龙头的情况。当他看到第 $i$ 个水龙头时，当且仅当第 $i$ 个货架没被水淹，他才会打开这个水龙头。

Radek 还没确定他看水龙头的顺序。它会从 $n!$ 种顺序中均匀随机选择一种。Radek 想知道他平均会打开多少个水龙头。

你的任务是回答 Radek 的问题，给出答案对 $10^9+7$ 取模后的值。形式化地，令答案为 $\frac{p}{q}$，其中 $q\neq 0$ 且 $\gcd(p,q)=1$。你需要输出 $p\cdot q^{-1}\pmod{10^9+7}$，其中 $q^{-1}$ 是集合 $1,2,\ldots,10^9+6$ 中唯一满足 $q\cdot q^{-1}\equiv 1\pmod{10^9+7}$ 的整数。

可以证明对于所有满足题目条件的数据，结果是有理数，且分母不会被 $10^9+7$ 整除。
## 输入格式

第一行一个整数 $n\ (1\le n\le 500\,000)$，表示 Mati 公司的货架数。

接下来 $n$ 行，第 $i$ 行有两个整数 $l_i,r_i\ (1\le l_i<r_i\le 2\cdot n)$，表示第 $i$ 个货架。为了简单，我们假设 $h_i=i$。

你可以假设所有 $l_i,r_i$ 两两不同——整数 $l_i,r_i$ 形成了一个 $1$ 到 $2\cdot n$ 的排列。
## 输出格式

输出一行一个整数，表示 Radek 平均需要打开多少水龙头。答案对 $10^9+7$ 取模后输出。
## 样例

### 样例输入 #1
```
3
4 6
1 3
2 5

```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
5
2 9
3 4
1 8
6 10
5 7

```
### 样例输出 #2
```
233333338

```
## 提示

**样例解释 1**

让我们考虑在第一个样例中 Radek 看水龙头的所有顺序：

- 按 $1,2,3$ 的顺序，他会打开所有 $3$ 个水龙头。
- 按 $1,3,2$ 的顺序，他会先打开水龙头 $1$ 和 $3$。当他准备打开水龙头 $2$ 时，水已经淹了第 $2$ 个货架，所以他不需要打开水龙头 $2$ 了。
- 按 $2,1,3$ 的顺序，他会打开所有 $3$​ 个水龙头。
- 按 $2,3,1$ 的顺序，他会先打开水龙头 $2$ 和 $3$。当他准备打开水龙头 $1$ 时，水已经淹了第 $1$ 个货架，所以他不需要打开水龙头 $1$ 了。
- 按 $3,1,2$ 或 $3,2,1$ 的顺序，由于打开水龙头 $3$ 后，所有货架都会被淹，因此就不需要再打开剩下的两个水龙头了。

Radek 平均需要打开 $\frac{1}{6}\cdot(3+2+3+2+1+1)=2$ 个水龙头。

**样例解释 2**

第二组样例中 Radek 瓶颈要打开 $\frac{91}{30}$ 个水龙头，由于 $30^{-1}\equiv 233333335\pmod{10^9+7}$，所以输出 $91\cdot 233333335\equiv 21233333485\equiv 233333338\pmod{10^9+7}$。


---

---
title: "[PA 2024] Żarówki"
layout: "post"
diff: 省选/NOI-
pid: P10367
tag: ['2024', 'PA（波兰）']
---
# [PA 2024] Żarówki
## 题目背景

PA 2024 5C2
## 题目描述

**题目译自 [PA 2024](https://sio2.mimuw.edu.pl/c/pa-2024-1/dashboard/) Runda 5 [Żarówki](https://sio2.mimuw.edu.pl/c/pa-2024-1/p/zar/)，感谢 Macaronlin 提供翻译**

有 $n$ 个灯泡，每个灯泡有两种状态：开和关，初始状态是给定的。有 $m$ 个开关，每个开关控制两个灯泡，按下开关可以使这两个灯泡变为与目前状态相反的状态，只有在两个灯泡有相同状态时才起作用，否则不起作用。

你可以随意安排开关的使用顺序和使用次数，问利用这些开关可以实现多少种配置方案。灯泡在一种配置中打开而在另一种配置中关闭，则两种配置被视为不同。
## 输入格式

第一行两个整数 $n$ 和 $m\ (1\le n\le 200\,000,0\le m\le 400\,000)$，表示灯泡和开关的个数。

第二行 $n$ 个整数 $c_i\ (c_i\in \{0,1\})$，如果 $c_i=1$，则初始时第 $i$ 个灯泡是打开的，如果 $c_i=0$，则初始时第 $i$ 个灯泡是关闭的。

接下来 $m$ 行，每行两个整数 $a_i,b_i\ (1\le a_i,b_i\le n,a_i\neq b_i)$，描述一个开关。

保证开关会影响不同的无序灯泡对。形式化地，$\forall i,j \in \{1,2,\ldots,m\},i\neq j$，都有 $(a_i,b_i)\neq (a_j,b_j)$ 且 $(a_i,b_i)\neq (b_j,a_j)$。
## 输出格式

输出一行一个整数，表示利用这些开关可以实现多少种配置方案。输出对 $10^9+7$ 取模。
## 样例

### 样例输入 #1
```
5 4
1 0 1 1 0
1 3
5 3
4 2
1 5

```
### 样例输出 #1
```
4
```
## 提示

所有可以实现的配置方案为：`10110`，`00010`，`00111` 和 `10011`。


---

---
title: "「HOI R1」杂分选约"
layout: "post"
diff: 省选/NOI-
pid: P10383
tag: ['2024', 'O2优化', '洛谷比赛']
---
# 「HOI R1」杂分选约
## 题目背景

**请注意本题并不寻常的时间限制。**

由于 python 自带对于高精度乘法的实现，并且运行效率较高，导致其编写的暴力程序，在一般的时间限制下可以通过绝大部分点。故本题时限开到 $200\text{ms}$。
***

黄总是一名计算很强的数学老师，以黄氏约分而闻名。现在他请小 $\iiint$ A 了这道题。但小 $\iiint$ **似乎**有点菜，所以求助于你。
## 题目描述

把
$$\dfrac{\displaystyle\prod_{i=1}^n
a_i}{\displaystyle\prod_{j=1}^m b_j}$$
表示为*最简分数 $^{[1]}$* $\dfrac{p}{q}$，求 $p$ 和 $q$。

好心的同学还给了小 $\iiint$ 一个整数 $C$，即数据点所在的 Subtask。
## 输入格式

第一行三个整数 $n,m$ 和 $C$。

第二行 $n$ 个整数 $a_{1\dots n}$。

第三行 $m$ 个整数 $b_{1\dots m}$。
## 输出格式

第一行两个数 $p$ 和 $q$。
## 样例

### 样例输入 #1
```
6 8 0
540000 350000 110000 130000 170000 970000
2000 5000 1000 1000 97000 17000 143000 210000
```
### 样例输出 #1
```
9 10
```
## 提示

**注释**

$[1]$：[百度百科](https://baike.baidu.com/item/%E6%9C%80%E7%AE%80%E5%88%86%E6%95%B0/2821376?fr=ge_ala)：最简分数，是分子、分母只有公因数 $1$ 的分数，或者说分子和分母互质的分数，又称既约分数。如：二分之一，三分之二，九分之八，八分之三等等。
***
**样例解释**

$\dfrac{540000\times350000\times110000\times130000\times170000\times970000}{2000\times5000\times1000\times1000\times97000\times17000\times143000\times210000}=\dfrac{9}{10}$，$\gcd(9,10)=1$
***
**数据规模与约定**

**本题采用捆绑测试。**

|Subtask|分值|数据范围|
|-|-|-|
|#0|0|同样例|
|#1|$5$|$1\le n,m\le500$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p,q\le3\times10^9$|
|#2|$5$|$1\le n,m\le25000$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p,q\le10$|
|#3|$10$|$1\le n,m\le5000$，$1\le a_i,b_i\le3\times10^9$，$1\le p,q\le3\times10^9$|
|#4|$15$|$1\le n,m\le10000$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p,q\le3\times10^9$|
|#5|$20$|$1\le n,m\le25000$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p\le3\times10^9$，$q=1$|
|#6|$10$|$1\le n,m\le25000$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p\le3\times10^9$,$1\le q \le25000$|
|#7|$20$|$1\le n,m\le25000$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p,q\le3\times10^9$|
|#8|$10$|$1\le n,m\le10^6$，$1\le a_i,b_i\le10^6$，$1\le p,q\le3\times10^9$|
|#9|$5$|$1\le n,m\le10^6$，$1\le a_i,b_i\le9\times10^{18}$，$1\le p,q\le3\times10^9$|
***
**提示**

~~高精度狗都不写。~~

本题时限较小且输入量较大，若你认为自己的算法复杂度正确，请尝试优化读写速度。


---

---
title: "『STA - R5』ReLyna"
layout: "post"
diff: 省选/NOI-
pid: P10399
tag: ['O2优化']
---
# 『STA - R5』ReLyna
## 题目背景

![](https://pic.imgdb.cn/item/661a29dd68eb93571321ac89.webp)
## 题目描述

你手中有一个数字 $x$。走到位置 $i$ 时你可以将手中的数字变为 $x+a_i$ 或 $x\times b_i$。

有 $m$ 次操作。

- `1 x y z`，执行 $a_x\gets y$，$b_x\gets z$。

- `2 l r`，查询若你从 $[l,r]$ 的所有子区间中等概率选择一个子区间 $[l',r']$，则你从 $l'$ 走到 $r'$ 后手中的数的最大值的期望是多少？答案对 $10^9+7$ 取模。每次行动开始前你手中的数字都会归零。

如果你不知道有理数如何取模，可以参考 [P2613 有理数取余](https://www.luogu.com.cn/problem/P2613)。

可参考样例解释理解题意。
## 输入格式

第一行两个整数 $n,m$。

第二行 $n$ 个整数，第 $i$ 个整数代表 $a_i$。

第三行 $n$ 个整数，第 $i$ 个整数代表 $b_i$。

后 $m$ 行每行描述一次操作，格式见题目描述。
## 输出格式

对于每个询问，输出对应的期望。答案对 $10^9+7$ 取模。
## 样例

### 样例输入 #1
```
5 4
48 52 8 27 34 
3 4 3 2 2 
2 2 3
2 1 5
1 1 34 4
2 1 3

```
### 样例输出 #1
```
72
133333711
333333468
```
## 提示

**样例解释**

对于第一次询问，令 $f(i,j)$ 为你从 $i$ 开始顺次走到 $j$ 后手中的数的最大值，则答案为 $\frac{1}{3}[f(2,2)+f(2,3)+f(3,3)]=\frac{1}{3}(52+156+8)=72$。

**数据范围**

| 子任务编号 | $n$ | $m$ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| Subtask #1 | $50$ | $50$ | 无 | 5 |
| Subtask #2 | $500$ | $500$ | 无 | 5 |
| Subtask #3 | $10^5$ | $10^5$ | 保证任何时刻 $a_i=1$ | 25 |
| Subtask #4 | $10^5$ | $50$ | 无 | 25 |
| Subtask #5 | $10^5$ | $10^5$ | 没有修改操作 | 25 |
| Subtask #6 | $10^5$ | $10^5$ | 无 | 15 |

对于所有数据，$1\le n,m\le 10^5$，$0<a_i<10^9+7$，$1<b_i<10^9+7$，保证操作合法，保证所有输入均为整数。


---

---
title: "[JOISC 2024] 鱼 3 (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P10430
tag: ['2024', 'JOI（日本）']
---
# [JOISC 2024] 鱼 3 (Day1)
## 题目描述

JOI 君在一个大水缸中饲养着 $ N $ 条鱼，每条鱼的编号从 $ 1 $ 到 $ N $。

JOI 君有两种类型的鱼食，$ A $ 和 $ B $，两种都有足够的数量。当往水族箱中添加一块食物时，恰好有一条鱼吃掉它（任何鱼都可以吃掉它），并且根据食物的类型以及吃掉它的鱼的情况，鱼的智力变化如下：

- 当第 $ k $ 条鱼（$ 1 \leq k \leq N $）吃掉一块 $ A $ 型食物时，第 $ k $ 条鱼的智力恰好增加 $ D $。
- 当第 $ k $ 条鱼（$ 1 \leq k \leq N $）吃掉一块 $ B $ 型食物时，编号大于等于 $ k $ 的所有鱼的智力都恰好增加 $ 1 $。

目前，所有鱼的智力都为 $ 0 $。JOI 君希望使第 $ i $ 条鱼（$ 1 \leq i \leq N $）的智力等于其理想智力 $ C_i $，但这并不总是可能的。

因此，他考虑了 $ Q $ 个问题。第 $ j $ 个问题（$ 1 \leq j \leq Q $）如下：

- 从所有鱼的智力都为 0 的状态开始，通过重复将食物放入水族箱零次或多次的动作，是否可能达到所有鱼 $ L_j , L_j + 1 ,..., R_j $ 都拥有其精确的理想智力值的状态？此外，如果可能，需要放入水族箱的 A 型食物的最小数量是多少？

编写一个程序，给定有关 JOI 君的鱼的信息以及有关问题的信息，回答他的问题。

## 输入格式

从标准输入读取以下数据：

- $ N,D $
- $ C_1,C_2,...,C_N $
- $ Q $
- $ L_1,R_1 $
- $ L_2,R_2 $
- ...
- $ L_Q,R_Q $
## 输出格式

输出共 $Q$ 行。在第 $j$ 行（$ 1 \leq j \leq Q $）中，如果可以达到所有鱼 $ L_j $，$ L_j + 1 $，...，$ R_j $ 拥有其精确的理想智力值的状态，则输出需要放入水族箱的 $A$ 型食物的最小数量。否则，输出 $-1$。
## 样例

### 样例输入 #1
```
4 2
3 1 2 1
1
1 3
```
### 样例输出 #1
```
1
```
## 提示

#### 样例解释 1


例如，在以下情况下，所有鱼 $1,2,3$ 最终都达到了其精确的理想智力值，且放入水族箱的 $A$ 型食物的数量为 $1$。

- 起初，鱼 $1,2,3,4$ 的智力分别为 $0,0,0,0$。
- 接下来，JOI 君将一块 $B$ 型食物放入水族箱，被鱼 $3$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $0,0,1,1$。
- 然后，JOI 君将一块 $A$ 型食物放入水族箱，被鱼 $1$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $2,0,1,1$。
- 最后，JOI 君将一块 $B$ 型食物放入水族箱，被鱼 $1$ 吃掉。结果，鱼 $1,2,3,4$ 的智力分别变为 $3,1,2,2$。
- 由于不放入任何 $A$ 型食物就无法达到所有鱼 $1,2,3$ 的精确理想智力值的状态，输出 $1$。

这个样例满足子任务 $1$ 和 $5$ 的约束条件。

### 约束条件

- $ 1 \leq N \leq 300,000 $。
- $ 1 \leq Q \leq 300,000 $。
- $ 1 \leq D \leq 10^{12} $。
- $ 0 \leq C_i \leq 10^{12} $（$ 1 \leq i \leq N $）。
- $ 1 \leq L_j \leq R_j \leq N $（$ 1 \leq j \leq Q $）。
- 给定值均为整数。

### 子任务

- （9 分）$ N \leq 3,000 $，$ Q \leq 3,000 $。
- （7 分）$ C_i \leq 1 $（$ 1 \leq i \leq N $）。
- （28 分）$ D = 1 $。
- （20 分）$ C_i \geq C_{i+1} $（$ 1 \leq i \leq N - 1 $）。
- （36 分）无额外约束。



---

---
title: "[JOISC 2024] 滑雪 2 (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P10432
tag: ['2024', 'JOI（日本）']
---
# [JOISC 2024] 滑雪 2 (Day1)
## 题目描述

JOI 先生管理着 IOI 高原上一家著名的滑雪度假村，他决定为滑雪度假村开业 15 周年庆祝活动而在相邻的 KOI 高原上建造一家新的滑雪度假村。

KOI 高原有 $N$ 个点，编号从 $1$ 到 $N$。目前，第 $i$ 个点（$1 \leq i \leq N$）的海拔高度为 $H_i$ 米，并且高原上的每个点都没有连接起来的滑道。此外，每个点都配备了一个未使用的连接设施。

JOI 先生的目标是在高原上的一个点上建造 KOI 酒店，然后建造一些滑道连接高原上的每个点，以便人们可以从任何一个点滑雪到酒店。具体来说，JOI 先生将按照以下步骤建造滑雪度假村：

1. 进行以下筑堤工作任意次数（可能为零）：选择一个点 $i$，将点 $i$ 的海拔高度增加 1 米。此工作的成本为每次操作 $K$。

2. 从 $N$ 个点中选择一个点，并在那里建造 KOI 酒店。

3. 进行以下扩展工作任意次数（可能为零）：选择一个点 $i$，在点 $i$ 建造一个连接设施。此工作的成本为每次操作 $C_i$。

4. 对于除了 KOI 酒店所在点之外的剩余 $N - 1$ 个点，执行以下构建：设 $i$ 为该点的编号。选择另一个海拔严格较低的点 $j$，并使用点 $j$ 的一个未使用的连接设施，从点 $i$ 向点 $j$ 构建单向滑道。注意，如果没有海拔严格较低且有未使用连接设施的点 $j$，则无法实现目标。

滑雪度假村的建造成本是进行堤岸工作和扩展工作的成本之和。

编写一个程序，给定 KOI 高原上每个点的信息和每次筑堤工作的成本 $K$，找到建造滑雪度假村的最小成本。

## 输入格式

从标准输入中读取以下数据：

- $N$ $K$
- $H_1$ $C_1$
- $H_2$ $C_2$
- ...
- $H_N$ $C_N$

## 输出格式


输出一行，构建滑雪度假村的最小成本。
## 样例

### 样例输入 #1
```
5 2
0 6
1 1
0 5
2 1
1 2
```
### 样例输出 #1
```
8
```
### 样例输入 #2
```
5 100000
0 6
1 1
0 5
2 1
1 2
```
### 样例输出 #2
```
100010
```
### 样例输入 #3
```
8 8
0 36
1 47
2 95
0 59
1 54
0 95
1 87
2 92
```
### 样例输出 #3
```
108
```
## 提示

#### 样例解释 1

例如，可以按以下方式建造滑雪度假村：

1. 在点 $1$ 进行两次筑堤工作，在点 $5$ 进行一次。这些筑堤工作的总成本为 $2 \times (2 + 1) = 6$。每个点的海拔高度变为 $2, 1, 0, 2, 2$ 米。
2. 在点 $3$ 建造 KOI 酒店。
3. 在点 $2$ 进行两次扩展工作。这些扩展工作的总成本为 $1 \times 2 = 2$。结果，从点 $1$ 开始，每个点的连接设施数量变为 $1, 3, 1, 1, 1$。
4. 构建 $4$ 条滑道：一条从点 $1$ 到点 $2$，一条从点 $2$ 到点 $3$，一条从点 $4$ 到点 $2$，一条从点 $5$ 到点 $2$。

因此，构建滑雪度假村的成本为 $6 + 2 = 8$。由于无法以不超过 $7$ 的成本建造滑雪度假村，因此输出 $8$。

此样例输入满足子任务 $3,4,5,6$ 的约束条件。

#### 样例解释 2

这个样例输入与示例输入 1 的唯一区别在于 $K$ 的值。

这个样例输入满足子任务 $1, 3, 4, 5, 6$ 的约束条件。

#### 样例解释 3

此示例输入满足子任务 $2, 3, 4, 5, 6$ 的约束条件。

### 约束条件

- $1 \leq N \leq 300$
- $1 \leq K \leq 10^9$
- $0 \leq H_i \leq 10^9$（$1 \leq i \leq N$）
- $1 \leq C_i \leq 10^9$（$1 \leq i \leq N$）
- 给定的值均为整数。

### 子任务

- (5 分) $K \geq 100,000$，$H_i \leq 300$，$C_i \leq 100$（$1 \leq i \leq N$）
- (12 分) $H_1 \leq H_i$，$C_1 \leq C_i$，$H_i \leq 300$（$1 \leq i \leq N$）
- (9 分) $N \leq 10$，$H_i \leq 10$（$1 \leq i \leq N$）
- (33 分) $N \leq 40$，$H_i \leq 40$（$1 \leq i \leq N$）
- (27 分) $H_i \leq 300$（$1 \leq i \leq N$）
- (14 分) 无额外约束。


---

---
title: "[JOISC 2024] 塔楼 (Day3)"
layout: "post"
diff: 省选/NOI-
pid: P10438
tag: ['2024', 'JOI（日本）']
---
# [JOISC 2024] 塔楼 (Day3)
## 题目描述

IOI Tower 是一座极其高的塔楼，配备了一条用于上升的楼梯。这个楼梯由 $10^{100}$ 个台阶组成，从底部开始依次编号为第 $0$ 级、第 $1$ 级，依此类推。JOI 君目前在第 $0$ 级，并打算爬楼梯。JOI 君可以通过以下两种方式上楼，禁止下楼。

- 上升 $1$ 级。这个动作需要 $A$ 秒。
- 从当前级别跳到上方 $D$ 级，跳过中间的台阶。这个动作需要 $B$ 秒。

目前，楼梯的几个位置正在进行施工，正在施工的台阶不能踩上去。具体来说，有 $N$ 处正在进行施工，第 $i$ 处施工（$1 \leq i \leq N$）正在进行的台阶为 $L_i$ 到 $R_i$。

IOI Tower 有 $Q$ 个房间，编号从 $1$ 到 $Q$。人们可以从楼梯的第 $X_j$ 级进入第 $j$ 个房间（$1 \leq j \leq Q$）。因此，JOI 君决定确定他是否可以到达每个房间，如果可能的话，以最短时间需要多少秒到达。

给出关于 JOI 君、施工和房间的信息，创建一个程序，确定 JOI 君是否可以到达第 $j$ 个房间（$1 \leq j \leq Q$），如果可能的话，计算需要的最短时间。

## 输入格式

从标准输入读取以下数据。

- $N$ $Q$
- $D$ $A$ $B$
- $L_1$ $R_1$
- $L_2$ $R_2$
- ...
- $L_N$ $R_N$
- $X_1$
- $X_2$
- ...
- $X_Q$

## 输出格式

输出 $Q$ 行，在第 $j$ 行（$1 \leq j \leq Q$）输出 JOI 君到达第 $X_j$ 级台阶所需的最少秒数；如果无法到达，则输出 $-1$。

## 样例

### 样例输入 #1
```
3 1
4 10 35
4 5
10 12
14 14
13
```
### 样例输出 #1
```
120
```
### 样例输入 #2
```
5 10
10 1 9
7 11
25 32
37 38
43 44
50 52
6
12
18
24
30
36
42
48
54
60
```
### 样例输出 #2
```
6
11
17
22
-1
33
-1
44
-1
55
```
## 提示

#### 样例解释 1

JOI 君可以按照以下步骤在 $120$ 秒内到达楼梯的第 $13$ 阶：

- 从第 $0$ 阶到第 $1$ 阶上升。此操作需要 $10$ 秒。
- 从第 $1$ 阶到第 $2$ 阶上升。此操作需要 $10$ 秒。
- 从第 $2$ 阶到第 $3$ 阶上升。此操作需要 $10$ 秒。
- 从第 $3$ 阶跳到第 $7$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。
- 从第 $7$ 阶到第 $8$ 阶上升。此操作需要 $10$ 秒。
- 从第 $8$ 阶到第 $9$ 阶上升。此操作需要 $10$ 秒。
- 从第 $9$ 阶跳到第 $13$ 阶，跳过中间的台阶。此操作需要 $35$ 秒。

由于无法在小于 $120$ 秒内到达第 $13$ 阶楼梯，输出为 $120$。

这个样例输入满足子任务 $1,2,4$ 的约束条件。

#### 样例解释 2

这个样例输入满足子任务 $1,2,4$ 的约束条件。

### 约束条件

- $1 \leq N \leq 200,000$
- $1 \leq Q \leq 200,000$
- $1 \leq D \leq 10^{12}$
- $1 \leq A \leq 1,000,000$
- $1 \leq B \leq 1,000,000$
- $1 \leq L_i \leq R_i \leq 10^{12}$（$1 \leq i \leq N$）
- $R_{i}+1 < L_{i+1}$（$1 \leq i \leq N-1$）
- $1 \leq X_j \leq 10^{12}$（$1 \leq j \leq Q$）
- 给定值均为整数。

### 子任务

1. （5 分）$R_i \leq 1,000,000$（$1 \leq i \leq N$），$X_j \leq 1,000,000$（$1 \leq j \leq Q$）
2. （38 分）$N \leq 2,000$，$Q \leq 2,000$
3. （25 分）$A = 1$，$B = D$
4. （32 分）无额外约束。


---

---
title: "[JOISC 2024] 逃生路线 2 (Day4)"
layout: "post"
diff: 省选/NOI-
pid: P10439
tag: ['2024', 'JOI（日本）']
---
# [JOISC 2024] 逃生路线 2 (Day4)
## 题目描述

IOI 王国由从西向东排列的 $N$ 座城市组成，城市按照从西向东的顺序从 $1$ 到 $N$ 编号。

在 IOI 王国，他们使用 Byou 作为时间单位。IOI 王国的一天被分为 $T$ 个时间单位。从某一天开始后的 $x$ 个 Byous（$0 \leq x < T$）被称为时间 $x$。因此，当从某一天的时间 $T - 1$ 开始经过 $1$ 个 Byou 时，将成为下一天的时间 $0$。

JOI 组织是 IOI 王国的秘密教派之一。由于它是一个秘密教派，成员必须绕过国家的检查站。因此，JOI 组织成员只能使用 JOY 航空公司运营的航班进行城市间旅行。

JOY 航空公司在城市 $i$（$1 \leq i \leq N - 1$）提供 $M_i$ 趟航班。第 $j$ 趟航班（$1 \leq j \leq M_i$）每天从城市 $i$ 在时间 $A_{i,j}$ 起飞，于当天的时间 $B_{i,j}$ 到达城市 $i + 1$。这里，满足 $A_{i,j} < B_{i,j}$。

这些航班提供了便捷的转机服务，也可以在抵达后立即起飞或在公司的机场过夜。

JOI 组织有 $Q$ 名成员，编号从 $1$ 到 $Q$。成员 $k$（$1 \leq k \leq Q$）将他们的运营基地设在城市 $L_k$，生活基地设在城市 $R_k$。因此，他们想知道通过选择从城市 $L_k$ 出发的时间和适当的航班进行，从城市 $L_k$ 出发到城市 $R_k$ 的最短时间。

给定 JOY 航空公司运营的航班和 JOI 组织成员的信息，编写一个程序，找到每个成员 $k$ 从城市 $L_k$ 到城市 $R_k$ 的最短时间。
## 输入格式

从标准输入中读取以下数据。

- $N$ $T$
- $M_1$
- $A_{1,1}$ $B_{1,1}$
- $A_{1,2}$ $B_{1,2}$
- ...
- $A_{1,M_1}$ $B_{1,M_1}$
- $M_2$
- $A_{2,1}$ $B_{2,1}$
- $A_{2,2}$ $B_{2,2}$
- ...
- $A_{2,M_2}$ $B_{2,M_2}$
- ...
- $M_{N-1}$
- $A_{N-1,1}$ $B_{N-1,1}$
- $A_{N-1,2}$ $B_{N-1,2}$
- ...
- $A_{N-1,M_{N-1}}$ $B_{N-1,M_{N-1}}$
- $Q$
- $L_1$ $R_1$
- $L_2$ $R_2$
- ...
- $L_Q$ $R_Q$

## 输出格式

输出 $Q$ 行到标准输出。在第 $k$ 行（$1 \leq k \leq Q$），输出成员 $k$ 从城市 $L_k$ 到城市 $R_k$ 所需的最短时间。

## 样例

### 样例输入 #1
```
4 10000
1
100 300
2
200 400
300 600
1
500 600
3
1 3
2 4
1 4
```
### 样例输出 #1
```
500
400
10500
```
### 样例输入 #2
```
6 10000
1
100 300
1
400 700
1
500 600
1
300 900
1
200 800
1
1 6

```
### 样例输出 #2
```
30700
```
## 提示

#### 样例解释 1

作为演示，让我们将成员 $k$ 从城市 $L_k$ 出发的第一天称为第 $1$ 天。成员 $1$ 可以按照以下行动在 $500$ Byou 内从城市 $1$ 前往城市 $3$：

1. 第 $1$ 天时刻 $100$ 从城市 $1$ 出发，并在第 $1$ 天时刻 $300$ 到达城市 $2$。
2. 第 $1$ 天时刻 $300$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $3$。

由于没有更快的旅行方式，所以在第 $1$ 行输出 $500$。

成员 $2$ 可以按照以下行动在 $400$ Byou 内从城市 $2$ 前往城市 $4$：

1. 第 $1$ 天时刻 $200$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $400$ 到达城市 $3$。
2. 第 $1$ 天时刻 $500$ 从城市 $3$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $4$。

由于没有更快的旅行方式，所以在第 $2$ 行输出 $400$。

成员 $3$ 可以按照以下行动在 $10500$ Byou 内从城市 $1$ 前往城市 $4$：

1. 第 $1$ 天时刻 $100$ 从城市 $1$ 出发，并在第 $1$ 天时刻 $300$ 到达城市 $2$。
2. 第 $1$ 天时刻 $300$ 从城市 $2$ 出发，并在第 $1$ 天时刻 $600$ 到达城市 $3$。
3. 第 $2$ 天时刻 $500$ 从城市 $3$ 出发，并在第 $2$ 天时刻 $600$ 到达城市 $4$。

由于没有更快的旅行方式，所以在第 $3$ 行输出 $10500$。

这个样例输入满足子任务 $2,4,5,6$ 的限制条件。


#### 样例解释 2

这个样例输入满足所有子任务的约束条件。

### 约束条件

- $2 \leq N \leq 100,000$
- $2 \leq T \leq 10^9$
- $M_i \geq 1$（$1 \leq i \leq N - 1$）
- $M_1 + M_2 + \cdots + M_{N-1} \leq 100,000$
- $0 \leq A_{i,j} < B_{i,j} < T$（$1 \leq i \leq N - 1, 1 \leq j \leq M_i$）
- $1 \leq Q \leq 300,000$
- $1 \leq L_k < R_k \leq N$（$1 \leq k \leq Q$）
- 给定值均为整数。

### 子任务

1. (6 分) $N \leq 2,000$，$M_i = 1$（$1 \leq i \leq N - 1$）
2. (8 分) $N \leq 2,000$，$M_i \leq 5$（$1 \leq i \leq N - 1$）
3. (17 分) $M_i = 1$（$1 \leq i \leq N - 1$）
4. (23 分) $M_i \leq 5$（$1 \leq i \leq N - 1$）
5. (36 分) $N \leq 90,000$，$Q \leq 90,000$，$M_1 + M_2 + \cdots + M_{N-1} \leq 90,000$
6. (10 分) 无额外约束条件。


---

---
title: "[JOISC 2024] 环岛旅行"
layout: "post"
diff: 省选/NOI-
pid: P10440
tag: ['2024', '交互题', 'Special Judge', 'JOI（日本）']
---
# [JOISC 2024] 环岛旅行
## 题目背景

**由于部分 BUG，使用 C++14 (GCC9) 提交会产生编译错误，请使用 C++14 等语言进行提交。**

**题目译自 [JOISC 2024](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html) Day4 T2 「[島巡り](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island.pdf) / [Island Hopping](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/contest4/island-en.pdf)」**。翻译来源 LOJ。

**不要引入 `island.h`**。你应该在文件头添加以下声明：

```
int query(int, int);
void answer(int, int);
```

交互文件可在 [JOI 官网](https://www2.ioi-jp.org/camp/2024/2024-sp-tasks/index.html)下载。
## 题目描述

**这是一道交互题。本题交互库是非自适应的。**

JOI 国有 $N$ 座岛屿，编号为 $1$ 到 $N$。有 $N-1$ 条航线，编号为 $1$ 到 $N-1$。航线 $j\ (1\le j\le N-1)$ 双向连接岛屿 $A_j$ 和 $B_j$。可以从一座岛屿出发，通过一些航线到达任意另一个岛屿。

葵准备在 JOI 国旅行。然而她不知道 JOI 国的航线。她准备向 JOI 国居住的 Bitaro 按下面的方式提一些问题：

1. 葵告诉 Bitaro 两个整数 $v$ 和 $k$，其中 $1\le v\le N,1\le k\le N-1$。
2. Bitaro 会告诉她除了 $v$ 之外的其他 $N-1$ 座岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。更确切地说，他会告诉她一个整数 $i$，满足 $\text{dist}(v,i)\times N+i\ (1\le i\le N,i\neq v)$ 是第 $k$ 小的，其中 $\text{dist}(v,i)$ 是从岛屿 $v$ 到 $i$ 所经过的最小航线数。

葵想通过提问知道所有 JOI 国的航线。因为葵不想花费太多时间，所以她最多只能向 Bitaro 问 $L$ 个问题。

给定 JOI 国的岛屿数和提问限制数，写一个程序模拟葵的提问策略，以找出所有的航线。

### 实现细节

你需要在程序开头引入库 `island.h`。

你需要实现如下函数。

- `void solve(int N, int L)`

  此函数在每个测试点中只被调用一次

  - 参数 `N` 是岛屿数 $N$
  - 参数 `L` 是提问次数限制 $L$。

在程序中，你可以调用如下函数。

- `int query(int v, int k)`

  葵使用此函数向 Bitaro 提问

  - 参数 `v` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [1]**。
  - 参数 `k` 必须在 $1$ 到 $N-1$​ 之间。如果不是，你的程序会被判为 **Wrong Answer [2]**。
  - 返回值表示除 $v$ 之外的其他 $N-1$ 个岛屿中，距离 $v$ 第 $k$ 近的岛屿编号。参考题目描述获得更详细的定义。
  - 你不能调用 `query` 函数超过 $L$ 次，否则你的程序会被判为 **Wrong Answer [3]**。

- `void answer(int x, int y)`

  使用此函数回答 JOI 国的一条航线

  - 参数 `x` 和 `y` 表示被一条航线连接的两座岛屿。
  - 参数 `x` 和 `y` 必须在 $1$ 到 $N$ 之间。如果不是，你的程序会被判为 **Wrong Answer [4]**。
  - 必须存在一条连接岛屿 `x` 和 `y` 的航线。换句话说，必须存在一个整数 $j\ (1\le j\le N-1)$ 满足 $x=A_j,y=B_j$ 或 $x=B_j,y=A_j$。否则，你的程序会被判为 **Wrong Answer [5]**。
  - 你的程序不能回答相同的航线两次或以上。否则，你的程序会被判为 **Wrong Answer [6]**。
  - 函数 `answer` 必须被调用恰好 $N-1$ 次。如果 `solve` 函数运行结束后此函数调用次数不是 $N-1$，你的程序会被判为 **Wrong Answer [7]**。
  
### 注意事项

- 你的程序可以实现其它函数供内部使用，或者使用全局变量。
- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。
- 测评中使用的交互器**不是**自适应性的。这意味着每组测试点的答案是提前确定好的。

### 编译运行

你可以在附件中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。

样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`island.cpp` 和 `island.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。

```bash
g++ -std=gnu++20 -O2 -o grader grader.cpp island.cpp
```

当编译成功时，会生成可执行文件 `grader`。

注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。
## 输入格式

Sample Grader 输入格式如下：

第一行两个整数 $N,L$。

接下来 $N-1$ 行，每行两个整数 $A_j,B_j$。
## 输出格式

样例交互器将向标准输出中输出如下信息：


- 如果你的程序被判为正确，它会报告调用 `query` 的次数，如：`Accepted: 2024`。
- 如果你的程序被判为某种 Wrong Answer，样例交互程序会输出它的类别，如：`Wrong Answer [4]`。

如果你的程序满足多种 Wrong Answer 的类别，样例交互器只会报告其中一个。
## 样例

### 样例输入 #1
```
4 16
1 2
2 4
4 3
```
### 样例输出 #1
```

```
### 样例输入 #2
```
5 25
5 2
3 1
1 4
1 5
```
### 样例输出 #2
```

```
## 提示

### 样例交互

#### 样例交互 $1$

样例调用过程如下表所示。

|      调用      |      调用      | 返回值 |
| :------------: | :------------: | :----: |
| `solve(4, 16)` |               |        |
|                | `query(2, 1)`  |  $1$   |
|                | `query(3, 1)`  |  $4$   |
|                | `answer(2, 4)` |        |
|                | `query(2, 2)`  |  $4$   |
|                | `answer(2, 1)` |        |
|                | `query(3, 2)`  |  $2$   |
|                | `query(2, 1)`  |  $1$   |
|                | `answer(3, 4)` |        |

从岛屿 $2$ 到岛屿 $1,3,4$ 的最小经过航线数分别为 $1,2,1$。例如，从岛屿 $2$ 到岛屿 $3$，我们可以使用航线 $2$ 后使用航线 $3$。

将岛屿按 $\text{dist}(2,i)\times N+i\ (i\neq 2)$ 递增的顺序排序，结果是岛屿 $1,4,3$。因此，`query(2, 1)` 的返回值为 $1$，`query(2, 2)` 的返回值为 $4$。

样例 $1$ 满足子任务 $2,6$ 的限制。

#### 样例交互 $2$


样例调用过程如下表所示。

|      调用      |      调用      | 返回值 |
| :------------: | :------------: | :----: |
| `solve(5, 25)` |            |        |
|                | `query(1, 3)`  |  $5$   |
|                | `query(1, 4)`  |  $2$   |
|                | `answer(3, 1)` |        |
|                | `query(2, 4)`  |  $4$   |
|                | `query(3, 1)`  |  $1$   |
|                | `query(3, 2)`  |  $4$   |
|                | `answer(1, 5)` |        |
|                | `answer(4, 1)` |      |
|                | `answer(2, 5)`  |        |

从岛屿 $1$ 到岛屿 $2,3,4,5$ 的最小经过航线数分别为 $2,1,1,1$。例如，从岛屿 $1$ 到岛屿 $2$，我们可以使用航线 $4$ 后使用航线 $1$。

将岛屿按 $\text{dist}(1,i)\times N+i\ (i\neq 1)$ 递增的顺序排序，结果是岛屿 $3,4,5,2$。因此，`query(1, 3)` 的返回值为 $5$，`query(1, 4)` 的返回值为 $2$。

样例 $2$ 满足子任务 $4,6$ 的限制。

### 数据范围

- $3\le N\le 300$
- $1\le A_j,B_j\le N\ (1\le j\le N-1)$
- $A_j\neq B_j\ (1\le j\le N-1)$
- 可以通过航线，从一个岛屿到达任意其他岛屿

### 子任务

| 子任务 |                           附加限制                           | 分值 |
| :----: | :----------------------------------------------------------: | :--: |
|  $1$   |                          $N=3,L=9$                           | $2$  |
|  $2$   |             $L=N^2$，每座岛屿最多有两条航线连接              | $4$  |
|  $3$   |              $L=2N$，每座岛屿最多有两条航线连接              | $7$  |
|  $4$   | $L=N^2$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $9$  |
|  $5$   | $L=3N$，岛屿 $1$ 有三条航线连接，其他每座岛屿最多有两条航线连接 | $13$ |
|  $6$   |                           $L=N^2$                            | $15$ |
|  $7$   |                            $L=3N$                            | $22$ |
|  $8$   |                            $L=2N$                            | $28$ |




---

---
title: "[JOISC 2024] 乒乓球 (Day4)"
layout: "post"
diff: 省选/NOI-
pid: P10441
tag: ['2024', 'Special Judge', 'JOI（日本）']
---
# [JOISC 2024] 乒乓球 (Day4)
## 题目描述

在 JOI 王国举办了一场乒乓球比赛。 $N$ 只编号从 $1$ 到 $N$ 的海狸参加了这场比赛，并进行了一场循环赛。

你从 Bitaro 那里得知了关于比赛结果的以下信息。

-  没有平局比赛。
- 正好有 $M$ 种选择 $3$ 只海狸形成“三元悖论”。请注意，只有当以下两个条件之一恰好满足时，$3$ 只海狸 $i, j, k$（$1 \leq i < j < k \leq N$）才形成“三元悖论”。
- - 海狸 $i$ 击败了海狸 $j$，海狸 $j$ 击败了海狸 $k$，海狸 $k$ 又击败了海狸 $i$。
- - 海狸 $i$ 击败了海狸 $k$，海狸 $k$ 击败了海狸 $j$，海狸 $j$ 又击败了海狸 $i$。

你不确定 Bitaro 提供的信息是否正确，所以你决定思考是否有任何与 Bitaro 提供的信息相符的比赛结果。编写一个程序，根据 Bitaro 提供的信息判断是否有任何比赛结果与信息相符，如果有，找出其中任意一种比赛结果。
## 输入格式

一个测试案例包括 $Q$ 个场景，编号从 $1$ 到 $Q$。每个场景指定以下数值。

- 参加比赛的海狸数量 $N$。
- 选择 $3$ 只形成“三元悖论”的海狸的方式数量 $M$。

输入数据的格式如下。

- $Q$

每个场景的输入数据格式如下。

- $N$ $M$
## 输出格式

对应各个场景，按照以下顺序将答案写入标准输出。

在某些场景中，如果有任何与信息相符的比赛结果，请按照以下方式输出。

- Yes
- $S_2$
- $S_3$
- ...
- $S_N$

这里，$S_i$（$2 \leq i \leq N$）是一个字符为 '0' 或 '1'，长度为 $i-1$ 的字符串。$S_i$ 的第 $j$ 个字符为 '0' 表示海狸 $i$ 被海狸 $j$ 打败，为 '1' 表示海狸 $i$ 打败了海狸 $j$。如果存在多个结果，可以输出任何一个。

在某些场景中，如果没有任何与信息相符的比赛结果，请输出 No。
## 样例

### 样例输入 #1
```
2
3 1
4 4
```
### 样例输出 #1
```
Yes
0
10
No
```
### 样例输入 #2
```
1
5 3
```
### 样例输出 #2
```
Yes
0
11
001
0101
```
## 提示

#### 样例解释 1

有 $Q = 2$ 个场景。

在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $2$，海狸 $2$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1$、$2$、$3$ 形成了“三元悖论”。没有其他方式选择 $3$ 只海狸，所以有确切地 $1$ 种方式选择 $3$ 只形成“三元悖论”的海狸。

对应场景 $1$ 的另一个输出如下。

```
Yes
1
01
```

在场景 $2$ 中，没有任何与信息相符的比赛结果。因此，输出 No。

这个示例输入满足子任务 $2,3,4,5,6$ 的约束条件。

#### 样例解释 2

在这个示例输出中，场景 $1$ 的结果是，海狸 $1$ 打败了海狸 $4$，海狸 $4$ 打败了海狸 $3$，海狸 $3$ 打败了海狸 $1$。因此，海狸 $1,3,4$ 形成了“三元悖论”。还有两种其他方式选择 $3$ 只形成“三元悖论”的海狸：选择海狸 $2,3,4$ 和选择海狸 $3,4,5$。因此，有确切地 $3$ 种方式选择 $3$ 只形成“三元悖论”的海狸。

这个示例输入满足所有子任务的约束条件。


### 约束条件

- $1 \leq Q$．
- $3 \leq N \leq 5000$．
- $0 \leq M \leq \frac{1}{6} N(N - 1)(N - 2)$．
- $Q$ 个场景中 $N$ 的总和不超过 5000
- 给定值均为整数。

### 子任务

1. (5 分) $M \leq N - 2$．
2. (4 分) $Q$ 个场景中 $N$ 的总和不超过 7。
3. (23 分) $Q$ 个场景中 $N$ 的总和不超过 20。
4. (30 分) $Q$ 个场景中 $N$ 的总和不超过 150。
5. (15 分) $Q$ 个场景中 $N$ 的总和不超过 600。
6. (23 分) 无额外约束。


---

---
title: "停车场"
layout: "post"
diff: 省选/NOI-
pid: P10509
tag: ['洛谷原创', 'O2优化', '洛谷月赛', 'Ad-hoc']
---
# 停车场
## 题目描述

你有一片空地。这片空地可以视作一个一个 $n\times n$ 的正方形。空地外一圈为墙壁，你无法拆除它们。

现在你要在这片空地上规划停车位，使之成为一个停车场。你希望空地的左下角是停车场的出入口。出入口不能规划为停车位。空地和停车位都是 $1\times 1$ 的正方形，且正方形的每条边与墙壁平行或者垂直。

每个停车位都应该与至少一个空地四连通（即：停车场的上、下、左、右方至少有一个空地），且这个空地应当能通过若干次向上、下、左、右的移动，在不经过任何停车位的情况下到达出入口。

下图为 $n=4$ 时停车位数最多的放置方法之一，其中红色为车位，蓝色为出口，白色为空地。

![](https://cdn.luogu.com.cn/upload/image_hosting/r3qljdsr.png)

请问 $n=2023$ 下最多能安排多少个停车位？
## 输出格式

一个正整数，表示你的答案。


---

---
title: "[XJTUPC 2024] 循环移位"
layout: "post"
diff: 省选/NOI-
pid: P10524
tag: ['2024', 'O2优化', '高校校赛']
---
# [XJTUPC 2024] 循环移位
## 题目描述

给定长度为 $2^n$ 的数组 $a_i$ ($0 \leq i < 2^n$)，你可以进行任意次循环移位。

求 $\sum_{i=0}^{2^n-1} a_i \oplus i$， $\sum_{i=0}^{2^n-1} a_i \& i$，$\sum_{i=0}^{2^n-1} a_i | i$ 的最大值。其中 $\oplus, \&, |$ 分别代表按位异或，按位与，按位或。

对于一个长度为 $m$ 的数组 $x_i$ ($0 \leq i < m$)，其进行循环移位的结果 $x'_i$ 为:

$$x'_i = \left\{
	\begin{array}{ll}
		x_{i - 1} & i \neq 0 \\
		x_{m - 1} & i = 0
	\end{array}\right.$$
## 输入格式

输入第一行包含一个整数 $n$ ($1 \leq n \leq 20$)，含义如题意所述。

接下来一行包含 $2^n$ 个整数 $a_i$ ($0 \leq a_i < 2^n$)，为给定的数组。
## 输出格式

输出一行三个整数，由空格隔开，为 $\sum_{i=0}^{2^n-1} a_i \oplus i$，$\sum_{i=0}^{2^n-1} a_i \& i$，$\sum_{i=0}^{2^n-1} a_i | i$ 的最大值。
## 样例

### 样例输入 #1
```
2
1 3 2 2

```
### 样例输出 #1
```
8 5 11

```
### 样例输入 #2
```
4
1 1 4 5 1 4 1 9 1 9 8 1 0 0 0 0

```
### 样例输出 #2
```
149 41 157

```


---

---
title: "[XJTUPC 2024] 图上操作"
layout: "post"
diff: 省选/NOI-
pid: P10525
tag: ['2024', 'O2优化', '高校校赛']
---
# [XJTUPC 2024] 图上操作
## 题目描述

你有一张 $n$ 个点 $m$ 条边的**有向图**，点的下标为 $1\sim n$。每条边有一个正整数边权 $d_i$。特殊的，$1\le d_i \le 100$。

现在定义点 $i$ 的瓶颈路大小为：所有从点 $1$ 到点 $i$ 的有向路径中，最小边权的最大值。特殊的，若 $i$ 不能从 $1$ 出发到达，则其瓶颈路权值为 $0$。

有 $q$ 次修改，每次修改会指定一条边，将这条边的边权降低，保证降低后依然是正整数。

现在要求每次修改后，输出编号为 $2\sim n$ 的点的瓶颈路大小。注意，每次修改是在前面修改的基础上进行操作，并不是相互独立的。

由于输出数据量过于巨大，设每次修改完后点 $i$ 的瓶颈路大小为 $ans_i$，你只需要输出 $(\sum_{i=2}^n ans_i \times 2^i)\bmod 998244353$。
## 输入格式

第一行三个正整数 $n,m,q$ ($2\le n\le 1\times 10^5$，$1\le m \le 2\times 10^5$，$1\le q\le 2\times 10^5$) 由空格隔开，含义如题所述。

后面 $m$ 行每行两个正整数 $s_i,t_i,d_i$ ($1\le s_i,t_i\le n$，$s_i\neq t_i$，$1\le d_i \le 100$) 由空格隔开，表示存在一条 $s_i$ 到 $t_i$ 的有向边，边权为 $d_i$，这条边的编号为 $i$。保证无自环，但可能会有重边。

再后面 $q$ 行每行两个正整数 $x,y$ ($1\le x\le m$，$1\le y < d_x$) 由空格隔开，表示将编号为 $x$ 的边的权值下调 $y$，且保证下调以后大于 $0$。
## 输出格式

输出 $q$ 行每行一个非负整数，表示你求得的答案。
## 样例

### 样例输入 #1
```
3 3 4
1 2 3
2 3 4
1 3 5
3 1
3 2
1 2
2 3

```
### 样例输出 #1
```
44
36
20
20

```
## 提示

第一次修改后，$2$ 号点的瓶颈路大小为 $3$，$3$ 号点的瓶颈路大小为 $4$。

第二次修改后，$2$ 号点的瓶颈路大小为 $3$，$3$ 号点的瓶颈路大小为 $3$。

第三次修改后，$2$ 号点的瓶颈路大小为 $1$，$3$ 号点的瓶颈路大小为 $2$。

第四次修改后，$2$ 号点的瓶颈路大小为 $1$，$3$ 号点的瓶颈路大小为 $2$。


---

---
title: "[XJTUPC 2024] 勘探队"
layout: "post"
diff: 省选/NOI-
pid: P10529
tag: ['2024', 'Special Judge', 'O2优化', '高校校赛']
---
# [XJTUPC 2024] 勘探队
## 题目描述

一支勘探队从 $(0,0)$ 出发，终点是 $(0,y)$，携带着从 $1$ 号到 $n$ 号设备，每个设备的重量为 $m_i$，且必须安放在横坐标为 $x_i$ 的任意位置上（纵坐标可以是任意实数）。必须按照顺序安放所有设备，在较小编号的设备被全部放置之前，即使横坐标位置满足，也不能放置。

当勘探队身上的设备总重量为 $m$ 时，其移动一单位长度的代价是 $m+M$。问勘探队完成所有设备安装并到达终点的最小代价。

同一个坐标位置可以放置多台设备。
## 输入格式

输入第一行三个正整数 $n$ ($1\le n \le 1\times 10^4$)，$M$ ($0< M \le 30$) 和 $y$ ($0<y\le 2\times 10^5$)，代表设备个数、移动的基本代价和最终终点的纵坐标。

第二行给出 $n$ 个非负整数 $m_i$ ($0< m_i\le 30$)，表示第 $i$ 台设备的重量。两两之间用空格隔开。

第三行给出 $n$ 个整数 $x_i$ ($|x_i|\le 1\times 10^4$)，表示第 $i$ 台机器坐标的要求。
## 输出格式

输出一行一个正实数代表最终代价。如果你的答案是 $a$，我们给出的标准答案是 $b$，你的答案正确当且仅当 $\frac{|a - b|}{\max{(1, |b|)}} \le 10^{-6}$。
## 样例

### 样例输入 #1
```
1 25 14
14
12

```
### 样例输出 #1
```
882.000000

```
## 提示

走直线走到 $(12,5)$，距离 $13$，然后走直线走到 $(0,14)$，距离 $15$，总代价 $13\times (25+14)+15\times 25=882$。不存在一个比这个更优的解。


---

---
title: "[ICPC 2024 Xi'an I] The Last Cumulonimbus Cloud"
layout: "post"
diff: 省选/NOI-
pid: P10559
tag: ['2024', 'O2优化', 'ICPC']
---
# [ICPC 2024 Xi'an I] The Last Cumulonimbus Cloud
## 题目描述

Every April, the city is always shrouded under cumulonimbus clouds.

This city is connected by $n$ buildings and $m$ two-way streets. In order to facilitate people's travel, any two buildings can directly or indirectly reach each other through the streets. At the same time, no street connects the same building, and there is at most one street that connects each pair of buildings.

The pace of life in this city is very slow because the city layout is not very bulky.

Specifically,if we consider this city as an undirected graph $G$ ,it is guaranteed that for any non empty subgraph in this graph,there is at least one building inside it that connects up to 10 streets within the subgraph.

The rain is not stopping, and the number of cumulonimbus clouds is constantly increasing. At the beginning, there are $a_i$ cumulonimbus clouds above the $i$ -th building, but in the following $q$ days, one of the following two events will occur every day:

- $\text{1 x v}$ $v$ cumulonimbus clouds have been added over the $x$ -th building.
- $\text{2 x}$ you need to report how many cumulonimbus clouds are in total over all buildings directly connected to building $x$.
## 输入格式

The first line contains three integers $n,m,q(1\le n\le 3\times 10^5,1\leq m\leq 3\times 10^6, 1\leq q\leq 2\times 10^6)$.

Each of the next $m$ lines contains two integers $x,y(1\leq x,y\leq n,x\neq y)$, which represents a street connecting the $x$ -th and $y$ -th buildings.

Each of the next $n$ lines contains an integer $a_i(0\leq a_i\leq 100)$.

Each of the next $q$ lines contains two or three integers, if the first integer is $1$, it represents a first type of event, and the next two integers represent $x,v(0\leq v\leq 100)$. If the first integer is $2$, it represents a second type of event, the next integer represents $x$.
## 输出格式

Several rows, each representing a query result for a second type of event.
## 样例

### 样例输入 #1
```
4 6 10
2 4
2 3
4 3
3 1
4 1
2 1
0
7
1
6
2 4
2 2
1 3 3
2 1
1 1 9
2 4
2 2
1 3 6
2 4
2 2
```
### 样例输出 #1
```
8
7
17
20
19
26
25
```
## 题目翻译

你有一个 $n(1\le n\le 3\times 10^5)$ 个点，$m(1\le m\le 3\times 10^6)$ 条边的无向图。

保证这个图的任意一个非空子图都至少有一个点的度数小于等于 $10$。

每个点初时有一个权值 $a_i$。

现在要执行 $q(1\le q\le 2\times 10^6)$ 次操作：

- $\text{1 x v}$ 给第 $x$ 个点的权值加 $v$。
- $\text{2 x}$ 询问第 $x$ 个点所有相邻的点的权值之和（不包括自己）。


---

---
title: "[ICPC 2024 Xi'an I] Holes and Balls"
layout: "post"
diff: 省选/NOI-
pid: P10560
tag: ['2024', 'O2优化', 'ICPC']
---
# [ICPC 2024 Xi'an I] Holes and Balls
## 题目描述

You are given $n$ balls, the $i$ -th ball's value is $p_i$. It's guaranteed that $p_1,p_2,\dots,p_n$ is a permutation of $1,2,3\dots,n$.
    
    
    
There is also a rooted tree of $n$ vertices, each of the vertices is a hole, and each hole can only hold one ball.
    
    
    
The tree's root is the first vertex.
    
    
    
Now you need to fill the holes with the balls.
    
You need to throw each ball in order of $1$ to $n$ in the following steps:

1. Throw the ball into vertex $1$.
2. Let the vertex where the ball is be $p$.
3. If the $p$ -th vertex has already been filled with other balls, you need to choose a vertex $x$ and throw the ball into the $x$ -th vertex, then return to step $2$. You need to guarantee that the $x$ -th vertex is the $p$ -th vertex's son and at least one vertex in the subtree of the $x$ -th vertex is not filled.
4. Otherwise, the ball will fill the $p$ -th vertex.

After throwing all the balls, let $a_i$ express the value of the ball in the $i$ -th vertex.
    
    
    
You need to find the minimum lexicographical order of $\{a_n\}$.
    
    
    
We define $dep_i$ as the number of vertices on the path from the $i$ -th vertex to the tree's root(the first vertex).
    
    
    
Specially, for any two vertices $x<y$, it's guaranteed that $dep_x\le dep_y$.

## 输入格式

    
The first line contains a single integer $n(1\le n\le 5\times 10^5)$ - the number of vertices in this tree.
    
    
    
The next line contains $n$ numbers, the $i$ -th number is $p_i(1\le p_i\le n)$. It's guaranteed that $p_1,p_2,\dots,p_n$ is a permutation of $1,2,3\dots,n$.
    
    
    
The next $n-1$ lines contain a description of the tree's edges. The $i$ -th of these lines contains two integers $u_i$ and $v_i(1\le u_i,v_i\le n) $ - the numbers of vertices connected by the $i$ -th edge.
    
    
    
It is guaranteed that the given edges form a tree.
    
    
    
And for any vertices $x<y$, it's guaranteed that $dep_x\le dep_y$.
## 输出格式


Output $n$ integers, the minimum lexicographical order of $\{a_n\}$.
## 样例

### 样例输入 #1
```
5
3 1 5 4 2
1 2
2 3
3 4
4 5

```
### 样例输出 #1
```
3 1 5 4 2
```
### 样例输入 #2
```
9
9 2 6 3 5 7 1 4 8
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9

```
### 样例输出 #2
```
9 2 1 3 6 4 8 5 7
```


---

---
title: "[蓝桥杯 2024 国 A] 异或路径"
layout: "post"
diff: 省选/NOI-
pid: P10583
tag: ['2024', '蓝桥杯国赛']
---
# [蓝桥杯 2024 国 A] 异或路径
## 题目描述

给定一棵有 $n$ 个结点的树，结点 $1$ 至 $n$ 编号。编号为 $x > 1$ 的结点与编号为 $\lfloor \sqrt x \rfloor$
 的结点有一条权值为 $x-\lfloor \sqrt x \rfloor ^ 2$ 的边。
 
定义一条路径的价值为这条路径上的所有边的权值的异或和。如果两条路径包含不同的边，则认为这两条路径不同。求这棵树的所有本质不同的简单路的价值的乘积（价值为 $0$ 的除外），答案对 $998\ 244\ 353$ 取模。
## 输入格式

输入一行包含一个整数 $n$。
## 输出格式

输出一行包含一个整数表示答案。
## 样例

### 样例输入 #1
```
5
```
### 样例输出 #1
```
36
```
## 提示

对于 $40\%$ 的评测用例，$n\le 10^3$；  
对于 $70\%$ 的评测用例，$n\le 10^6$；  
对于所有评测用例，$1\le n\le 10^9$。


---

---
title: "磁力块"
layout: "post"
diff: 省选/NOI-
pid: P10590
tag: []
---
# 磁力块
## 题目描述

在一片广袤无垠的原野上，散落着 $N$ 块磁石。

每个磁石的性质可以用一个五元组 $(x,y,m,p,r)$ 描述，其中 $x,y$ 表示其坐标，$m$ 是磁石的质量，$p$ 是磁力，$r$ 是吸引半径。

若磁石 $A$ 与磁石 $B$ 的距离不大于磁石 $A$ 的吸引半径，并且磁石 $B$ 的质量不大于磁石 $A$ 的磁力，那么 $A$ 可以吸引 $B$。

小取酒带着一块自己的磁石 $L$ 来到了这片原野的 $(x_0,y_0)$ 处，我们可以视磁石 $L$ 的坐标为 $(x_0,y_0)$。

小取酒手持磁石 $L$ 并保持原地不动，所有可以被 $L$ 吸引的磁石将会被吸引过来。

在每个时刻，他可以选择更换任意一块自己已经获得的磁石（当然也可以是自己最初携带的 $L$ 磁石）在 $(x_0,y_0)$ 处吸引更多的磁石。

小取酒想知道，他最多能获得多少块磁石呢？
## 输入格式

第一行五个整数 $x_0,y_0,p_L,r_L,N$，表示小取酒所在的位置，磁石 $L$ 磁力、吸引半径和原野上散落磁石的个数。

接下来 $N$ 行每行五个整数 $x,y,m,p,r$，描述一块磁石的性质。
## 输出格式

输出一个整数，表示最多可以获得的散落磁石个数（不包含最初携带的磁石 $L$）。

## 样例

### 样例输入 #1
```
0 0 5 10 5
5 4 7 11 5
-7 1 4 7 8
0 2 13 5 6
2 -3 9 3 4
13 5 1 9 9
```
### 样例输出 #1
```
3
```
## 提示

对于 $30\%$ 的数据，$1 \le N \le 1000$。

对于另外 $30\%$ 的数据，$p=r$。

对于 $100\%$ 的数据，$1 \le N \le 250000$，$-10^9 \le x,y \le 10^9$，$1 \le m,p,r \le 10^9$。


---

---
title: "[BalticOI 2001] Box of Mirrors"
layout: "post"
diff: 省选/NOI-
pid: P10612
tag: ['2001', 'Special Judge', 'BalticOI（波罗的海）']
---
# [BalticOI 2001] Box of Mirrors
## 题目描述

数学家 Andris 有一个小盒子，其底部是 $n\times m$ 的格子，每个格子可以放一面 $45$ 度朝向的镜子。

在盒子的边界，每行每列的两端，有一些孔，光线可以从中射入盒子，也可以射出。

![](https://cdn.luogu.com.cn/upload/image_hosting/i5gnsp7v.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/1xl9wkfz.png)

如上图所示，从孔 $2$ 射进盒子的光线经过两次反射后又从孔 $7$ 射出。

Andris 想请你设计一个盒子，使得从每个孔射入的光线都会从指定的孔射出。

例如，如果他希望从 $10$ 个孔里射入的光线分别由孔 $9,7,10,8,6,5,2,4,1,3$ 射出，则上图也是一个满足要求的盒子。

注意，孔的编号如图从 $1$ 到 $2\times (n+m)$ 编号。
## 输入格式

第一行两个整数 $n,m$，表示盒子的大小。

接下来 $2\times (n+m)$ 行，第 $i+1$ 行一个整数 $a_i$，表示从第 $i$ 个孔射入的光线要从第 $a_i$ 个孔中射出。
## 输出格式

输出一个 $n\times m$ 的矩阵，对于每个位置，$0$ 表示不放镜子，$1$ 表示放镜子，需要满足对应的要求。数据保证一定有解。
## 样例

### 样例输入 #1
```
2 3
9
7
10
8
6
5
2
4
1
3
```
### 样例输出 #1
```
0 1 0
0 1 1
```
## 提示

对于 $100\%$ 的数据，$1\leq n,m\leq 100$，$1\leq a_i\leq 2\times (n+m)$。


---

---
title: "BZOJ3864 Hero meet devil"
layout: "post"
diff: 省选/NOI-
pid: P10614
tag: ['O2优化']
---
# BZOJ3864 Hero meet devil
## 题目描述

给定一个字符集为 `ACGT` 的字符串 $S$。定义 $\text{LCS}(S,T)$ 为两个字符串 $S,T$ 的最长公共子序列。

对于每个 $0\leq i \leq |S|$，求有多少个长度为 $m$，字符集 `ACGT` 的字符串 $T$，满足 $|\text{LCS}(S,T)|=i$，答案对 $10^9+7$ 取模。
## 输入格式

第一行一个整数 $T$ 表示数据组数。

对于每组数据，第一行一个字符串 $S$，第二行一个整数 $m$。
## 输出格式

对于每组数据，输出 $i=0,1,\dots,|S|$ 时的答案，每个占一行。
## 样例

### 样例输入 #1
```
1
GTC
10
```
### 样例输出 #1
```
1
22783
528340
497452
```
## 提示

对于 $100\%$ 的数据，保证 $1\leq T\leq 5$，$1\leq |S| \leq 15$，$1\leq m\leq 1000$。


---

---
title: "[ICPC 2013 WF] Hey, Better Bettor"
layout: "post"
diff: 省选/NOI-
pid: P10616
tag: ['2013', 'Special Judge', 'O2优化', 'ICPC']
---
# [ICPC 2013 WF] Hey, Better Bettor
## 题目背景

> “In the casino, the cardinal rule is to keep them playing and to keep them coming back. The
longer they play, the more they lose, and in the end, we get it all.”  
> (from the 1995 film *Casino*)
## 题目描述

Recent recessions have not been kind to entertainment venues, including the gambling industry. Competition is fierce among casinos to attract players with lots of money, and some have begun to offer especially sweet deals. One casino is offering the following: you can gamble as much as you want at the casino. After you are finished, if you are down by any amount from when you started, the casino will refund $x\%$ of your losses to you. Obviously, if you are ahead, you can keep all of your winnings. There is no time limit or money limit on this offer, but you can redeem it only once.

For simplicity, assume all bets cost $1$ dollar and pay out $2$ dollars. Now suppose $x$ is $20$. If you make $10$ bets in total before quitting and only $3$ of them pay out, your total loss is $3.2$ dollars. If $6$ of them pay out, you have gained $2$ dollars.

Given $x$ and the percentage probability $p$ of winning any individual bet, write a program to determine the maximum expected profit you can make from betting at this casino, using any gambling strategy.
## 输入格式

The input consists of a single test case. A test case consists of the refund percentage $x (0 \leq x < 100)$ followed by the winning probability percentage $p (0 \leq p < 50)$. Both $x$ and $p$ have at most two digits after the decimal point.
## 输出格式

Display the maximum expected profit with an absolute error of at most $10^{-3}$.
## 样例

### 样例输入 #1
```
0 49.9
```
### 样例输出 #1
```
0.0
```
### 样例输入 #2
```
50 49.85
```
### 样例输出 #2
```
7.10178453
```
## 题目翻译

**【题目描述】**

> “在赌场里，首要规则是让他们继续玩，让他们不断回来。他们玩得越久，输得越多，最终，我们会赢得一切。”  
> （摘自 1995 年电影《赌场》）

最近的经济衰退对包括赌博业在内的娱乐场所并不友好。赌场之间竞争激烈，以吸引有钱的玩家，一些赌场开始提供特别优厚的优惠。其中一个赌场提供以下优惠：你可以在赌场里随意赌博。当你结束时，如果你比开始时输了任何金额，赌场将退还你损失的 $x\%$。显然，如果你赢钱了，你可以保留所有的奖金。此优惠没有时间限制或金额限制，但你只能兑现一次。

为了简化，假设所有赌注的成本为 $1$ 美元，并支付 $2$ 美元。现在假设 $x$ 是 $20$。如果你在退出前总共下注 $10$ 次，只有 $3$ 次获胜，你的总损失是 $3.2$ 美元。如果 $6$ 次获胜，你就赚了 $2$ 美元。

给定 $x$ 和赢得任何单个赌注的概率百分比 $p$，编写一个程序来确定你在这个赌场下注所能获得的最大期望利润，使用任何赌博策略。

输入由一个单一的测试用例组成。测试用例包含退款百分比 $x (0 \leq x < 100)$，随后是赢得概率百分比 $p (0 \leq p < 50)$。$x$ 和 $p$ 的小数点后最多有两位数字。

显示最大期望利润，绝对误差不超过 $10^{-3}$。

**【输入格式】**

输入由一个单一的测试用例组成。测试用例包含退款百分比 $x (0 \leq x < 100)$，随后是赢得概率百分比 $p (0 \leq p < 50)$。$x$ 和 $p$ 的小数点后最多有两位数字。

**【输出格式】**

输出最大期望利润，绝对误差不超过 $10^{-3}$。

翻译来自于：[ChatGPT](https://chatgpt.com/)。



---

---
title: "[ICPC 2013 WF] Matryoshka"
layout: "post"
diff: 省选/NOI-
pid: P10622
tag: ['2013', 'O2优化', 'ICPC']
---
# [ICPC 2013 WF] Matryoshka
## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/tsc2hi05.png)
## 题目描述

Matryoshkas are sets of traditional Russian wooden dolls of decreasing size placed one inside the other. A matryoshka doll can be opened to reveal a smaller figure of the same sort inside, which has, in turn, another figure inside, and so on.

The Russian Matryoshka Museum recently exhibited a collection of similarly designed matryoshka sets, differing only in the number of nested dolls in each set. Unfortunately, some over-zealous (and obviously unsupervised) children separated these sets, placing all the individual dolls in a row. There are $n$ dolls in the row, each with an integer size. You need to reassemble the matryoshka sets, knowing neither the number of sets nor the number of dolls in each set. You know only that every complete set consists of dolls with consecutive sizes from $1$ to some number $m$, which may vary between the different sets.

When reassembling the sets, you must follow these rules:
- You can put a doll or a nested group of dolls only inside a larger doll.
- You can combine two groups of dolls only if they are adjacent in the row.
- Once a doll becomes a member of a group, it cannot be transferred to another group or permanently separated from the group. It can be temporarily separated only when combining two groups.

Your time is valuable, and you want to do this reassembly process as quickly as possible. The only time-consuming part of this task is opening and subsequently closing a doll, so you want to minimize how often you do this. For example, the minimum number of openings (and subsequent closings) when combining group $[1, 2, 6]$ with the group $[4]$ is two, since you have to open the dolls with sizes $6$ and $4$. When combining group $[1, 2, 5]$ with the group $[3, 4]$, you need to perform three openings.

Write a program to calculate the minimum number of openings required to combine all disassembled matryoshka sets.
## 输入格式

The input consists of a single test case. A test case consists of two lines. The first line contains one integer $n (1 \leq n \leq 500)$ representing the number of individual dolls in the row. The second line contains $n$ positive integers specifying the sizes of the dolls in the order they appear in the row. Each size is between $1$ and $500$ inclusive.
## 输出格式

Display the minimum number of openings required when reassembling the matryoshka sets. If reassembling cannot be done (some of the kids might have been excessively zealous and taken some dolls), display the word `Impossible`.
## 样例

### 样例输入 #1
```
7
1 2 1 2 4 3 3
```
### 样例输出 #1
```
Impossible
```
### 样例输入 #2
```
7
1 2 3 2 4 1 3

```
### 样例输出 #2
```
7
```
## 题目翻译

**【题目描述】**

套娃是俄罗斯传统木制玩具，由一组逐渐变小的娃娃组成，依次放置在另一个娃娃内部。一个套娃可以打开，露出一个更小的类似玩偶，而这个玩偶内部又有另一个玩偶，以此类推。

俄罗斯套娃博物馆最近展出了一系列设计相似的套娃，不同之处仅在于每套娃娃中嵌套的数量不同。不幸的是，一些过于热心（显然没有得到监督）的孩子把这些套娃拆散了，并将所有的单个娃娃排成一行。现在这一行中有 $n$ 个娃娃，每个都有一个整数大小。你需要重新组装这些套娃，既不知道套娃的数量，也不知道每套娃娃中娃娃的数量。你只知道每套完整的套娃由大小从 $1$ 到某个数字 $m$ 的连续大小的娃娃组成，而这个数字 $m$ 在不同的套娃中可能有所不同。

在重新组装套娃时，你必须遵循以下规则：
- 你只能将一个娃娃或一个嵌套的娃娃组放入一个更大的娃娃中。
- 你只能合并两个在行中相邻的娃娃组。
- 一旦一个娃娃成为一个组的成员，它不能被转移到另一个组或永久地从组中分离。它只能在合并两个组时暂时分离。

你的时间非常宝贵，你希望尽快完成这个重新组装过程。这个任务中唯一耗时的部分是打开和随后关闭一个娃娃，因此你希望尽量减少这样的操作次数。例如，当将组 $[1, 2, 6]$ 与组 $[4]$ 合并时，最少需要进行两次开关操作，因为你必须打开大小为 $6$ 和 $4$ 的娃娃。而当将组 $[1, 2, 5]$ 与组 $[3, 4]$ 合并时，需要进行三次开关操作。

编写一个程序计算重新组装所有拆散的套娃所需的最少开关次数。

**【输入格式】**

输入包含一个测试用例。测试用例由两行组成。第一行包含一个整数 $n (1 \leq n \leq 500)$，表示行中单个娃娃的数量。第二行包含 $n$ 个正整数，按照它们在行中出现的顺序指定娃娃的大小。每个大小在 $1$ 到 $500$ 之间（包括 $1$ 和 $500$）。

**【输出格式】**

输出重新组装套娃所需的最少开关次数。如果重新组装无法完成（可能有些孩子过于热心，带走了一些娃娃），则输出 `Impossible`。

翻译来自于：[ChatGPT](https://chatgpt.com/)。


---

---
title: "[JOI Open 2017] 推土机"
layout: "post"
diff: 省选/NOI-
pid: P10630
tag: ['2017', 'JOI（日本）']
---
# [JOI Open 2017] 推土机
## 题目描述

**译自 [JOI Open 2017](https://contests.ioi-jp.org/open-2017/index.html) T2 「ブルドーザー / Bulldozer」**

平面上有 $N$ 个点，点 $i\:(1≤i≤N)$ 位于 $(X_i, Y_i)$，点 $i\:(1≤i≤N)$ 的权值为非零整数 $W_i$（可能为负数）。  
在平面上画两条平行线，所得的总价值为平行线之间（压线也算）所有点的权值之和。求总价值至多不超过多少。
## 输入格式

第一行包含一个整数 $N$。  
在接下来的 $N$ 行中，第 $i$ 行包含三个用空格分隔的整数 $X_i,Y_i,W_i$。
## 输出格式

一行，一个整数，表示最大总价值。
## 样例

### 样例输入 #1
```
5
-5 5 -2
2 5 10
1 4 -2
4 -5 4
-2 2 7
```
### 样例输出 #1
```
19
```
### 样例输入 #2
```
6
0 0 6
1 0 -2
2 0 8
0 1 -2
1 1 5
2 1 -2
```
### 样例输出 #2
```
15
```
### 样例输入 #3
```
5
0 0 2
4 0 2
3 2 -1
1 2 2
1 1 -1
```
### 样例输出 #3
```
5
```
### 样例输入 #4
```
2
0 0 -1
1 0 -1
```
### 样例输出 #4
```
0
```
## 提示

**样例解释 1**

![](https://cdn.luogu.com.cn/upload/image_hosting/rk2miemg.png)

选择点 $2, 3, 4, 5$。

**样例解释 2**

注意，点 $1,2,3$ 共线。点 $4,5,6$ 共线。

**样例解释 3**

这组样例中没有三点共线。选择的平行线一条过点 $1,2$，另一条过点 $3,4$。

#### 数据范围

所有输入数据都满足以下条件。

 $1≤N≤2000, |X_i|,|Y_i|≤10^9,1 ≤|W_i|≤10^9(1≤i≤N)$ 。$(X_i,Y_i)≠(X_j,Y_j)\:(1≤i<j≤N)$ 。

|子任务|分值|$N≤100$|无三点共线|设 $L$ 是在平面上通过两个不同点的一条线，$L'$ 是在平面上另一条通过两个不同点的线，那么 $L$ 和 $L'$ **不**相互平行|其他条件|
|:---------:|:------------:|:-------------:|:---------------:|:-:|:------------:|
|$1$     |$5$    |√            |×                 |×|所有点都在 $x$ 轴上|
|$2$     |$20$  |√          |√               |√|无|
|$3$     |$35$  |×          |√                |√|无|
|$4$     |$20$  |×          |√                |×|无|
|$5$     |$20$  |×          |×                |×|无|


---

---
title: "[JOI Open 2017] 高尔夫"
layout: "post"
diff: 省选/NOI-
pid: P10631
tag: ['2017', 'JOI（日本）']
---
# [JOI Open 2017] 高尔夫
## 题目描述

**译自 [JOI Open 2017](https://contests.ioi-jp.org/open-2017/index.html) T3 「ゴルフ / Golf」**

平面的第一象限上有 $N$ 个矩形障碍，矩形的两组对边分别平行于 $x$ 轴和 $y$ 轴。矩形 $i(1\le i\le N)$ 的左下角是 $(A_i, C_i)$，右上角是 $(B_i, D_i)$。任意两个矩形（包括边界）不相交。  
JOI 君需要将一个高尔夫球从 $(S,T)$ 打到 $(U,V)$，保证这两点不同，保证这两点不在障碍内或障碍的边界上。  
JOI 君只能朝平行于 $x$ 轴或平行与 $y$ 轴的方向击球（JOI 君可以跟着移动）。球可以经过边界，但不能进入障碍物内部。球撞进障碍物后会停下（JOI 君仍然可以朝远离障碍物的方向击球）。  
求最少要击球多少次，才能将高尔夫球打进 $(U,V)$。
## 输入格式

第一行有四个整数 $S, T, U, V$。  
第二行有一个整数 $N$。  
在接下来的 $N$ 行中，每行有四个整数 $A_i, B_i, C_i, D_i$。
## 输出格式

输出一行，一个整数，表示最少击球次数。
## 样例

### 样例输入 #1
```
3 5 8 6
1
5 6 2 8
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
1 1 1 10
3
5 6 2 8
1 2 2 3
8 10 3 5
```
### 样例输出 #2
```
1
```
### 样例输入 #3
```
20 68 85 74
5
30 70 14 100
5 24 15 67
75 86 75 79
75 90 19 62
93 98 26 58
```
### 样例输出 #3
```
4
```
## 提示

**样例解释 1**

$(3,5) → (3,2) → (8,2) → (8,6)$


#### 数据范围

$1\le S, T, U, V\le 10^9, 1\le N\le 10^5, 1\le A_i<B_i\le 10^9, 1\le C_i<D_i\le 10^9,$ $(S,T)≠(U,V)$。  

- 子任务 #1（10 分）：$S, T, U, V, N, B_i, D_i\le 1000$；  
- 子任务 #2（20 分）：$N\le 1000$；  
- 子任务 #3（70 分）：没有额外限制。


---

---
title: "BZOJ3517 翻硬币"
layout: "post"
diff: 省选/NOI-
pid: P10635
tag: ['O2优化', 'Ad-hoc']
---
# BZOJ3517 翻硬币
## 题目描述

有一个 $n$ 行 $n$ 列的棋盘，每个格子上都有一个硬币，且 $n$ 为偶数。每个硬币要么是正面朝上，要么是反面朝上。每次操作你可以选定一个格子 $(x,y)$，然后将第 $x$ 行和第 $y$ 列的所有硬币都翻面。求将所有硬币都变成同一个面最少需要的操作数。
## 输入格式

第一行包含一个正整数 $n$。接下来 $n$ 行，每行包含一个长度为 $n$ 的 $01$ 字符串，表示棋盘上硬币的状态。
## 输出格式

仅包含一行，为最少需要的操作数。
## 样例

### 样例输入 #1
```
4
0101
1000
0010
0101
```
### 样例输出 #1
```
2
```
## 提示

**【样例解释】**

对 $(2,3)$ 和 $(3,1)$ 进行操作，最后全变成 $1$。

**【数据范围】**

对于所有数据，$1\leq n \leq 1000$。


---

---
title: "SuperMemo"
layout: "post"
diff: 省选/NOI-
pid: P10689
tag: ['O2优化']
---
# SuperMemo
## 题目描述

Your friend, Jackson is invited to a TV show called SuperMemo in which the participant is told to play a memorizing game. At first, the host tells the participant a sequence of numbers, $A_1, A_2, \ldots A_n$. Then the host performs a series of operations and queries on the sequence which consists:

  * `ADD x y D`: Add $D$ to each number in sub-sequence $A_x \ldots A_y$. For example, performing "ADD 2 4 1" on $1, 2, 3, 4, 5$ results in $1, 3, 4, 5, 5$
  * `REVERSE x y`: reverse the sub-sequence ${A_x \ldots A_y}$. For example, performing "REVERSE 2 4" on $1, 2, 3, 4, 5$ results in $1, 4, 3, 2, 5$
  * `REVOLVE x y T`: rotate sub-sequence ${A_x \ldots A_y}$ $T$ times. For example, performing "REVOLVE 2 4 2" on $1, 2, 3, 4, 5$ results in $1, 3, 4, 2, 5$
  * `INSERT x P`: insert $P$ after $A_x$. For example, performing "INSERT 2 4" on $1, 2, 3, 4, 5$ results in $1, 2, 4, 3, 4, 5$
  * `DELETE x`: delete $A_x$. For example, performing "DELETE 2" on $1, 2, 3, 4, 5$ results in $1, 3, 4, 5$
  * `MIN x y`: query the participant what is the minimum number in sub-sequence $A_x \ldots A_y$. For example, the correct answer to "MIN 2 4" on $1, 2, 3, 4, 5$ is $2$

To make the show more interesting, the participant is granted a chance to turn to someone else that means when Jackson feels difficult in answering a query he may call you for help. You task is to watch the TV show and write a program giving the correct answer to each query in order to assist Jackson whenever he calls.
## 输入格式

The first line contains $n$ ($n \leq 100000$).

The following $n$ lines describe the sequence.

Then follows $M$ ($M \leq 100000$), the numbers of operations and queries.

The following $M$ lines describe the operations and queries. 
## 输出格式

For each "MIN" query, output the correct answer.
## 样例

### 样例输入 #1
```
5
1
2
3
4
5
2
ADD 2 4 1
MIN 4 5
```
### 样例输出 #1
```
5
```


---

---
title: "[SNCPC2024] 猜质数 I"
layout: "post"
diff: 省选/NOI-
pid: P10699
tag: ['2024', '交互题', 'Special Judge', 'O2优化', '陕西', 'XCPC']
---
# [SNCPC2024] 猜质数 I
## 题目描述

**这是一道交互题。**

MCPlayer542 手上有一个神秘的**奇质数** $p$，但他并不想让你知道这个数是多少。

他打算用一个函数 $f(x)$ 来加密他的数，其值为 $x$ 在十进制下的各位数字之和，例如 $f(5)=5$，$f(542)=5+4+2=11$，$f(1024)=1+0+2+4=7$。

**然而考虑到你太聪明，他想了想，决定把加密函数改成：**
$$g(x)=f(f(f(f(f(f(f(f(f(f(x))))))))))$$
**即连续应用 $10$ 次 $f(x)$，并把手上的 $p$ 换成了 $q=p^k$。** 

现在他准备给你 $n$ 个整数 $g(q^{a_1}),\ g(q^{a_2}),\ \ldots,\ g(q^{a_n})$，并希望你能告诉他
$$q^{a_1}\bmod (m\cdot a_1),\ q^{a_2}\bmod (m\cdot a_2),\ \ldots,\ q^{a_n}\bmod (m\cdot a_n)$$
分别是多少。**他觉得你肯定猜不到，所以决定让你自己选择 $m$ 和 $a_1,\ a_2,\ \ldots,\ a_n$**。你能完成这个任务吗？

**注意：$m$ 的范围有特殊限制。**

## 输入格式

输入包含多组测试数据。数据的第一行包含一个整数 $t$ ($1\le t\le 500$)，表示数据组数。每组数据的交互流程在下文中描述。

在每组数据中，输入的第一行包含两个整数 $n$ 和 $k$ ($1\le n\le 50, \ 1\le k\le 10^9$)，用单个空格分隔，含义见题目描述。

接下来每次交互，输出一行一个整数 $a_i$ ($1\le a_i\le 10^{18},a_i$ **互不相同**)，表示要询问的 $q$ 的幂次。

给出一个询问后，你应该读入一个整数，即 $g(q^{a_i})$。

你需要在进行完 $n$ 轮交互之后输出一行一个整数 $m$ ($m\ge 35,1\le m\cdot a_i\le 10^{18}$)，再输出一行 $n$ 个数，即 $q^{a_1}\bmod (m\cdot a_1), \ q^{a_2}\bmod (m\cdot a_2), \ \ldots, \ q^{a_n}\bmod (m\cdot a_n)$，用单个空格分隔，表示答案。

**你必须进行恰好 $n$ 轮交互，随后输出答案并结束程序，否则你可能得到无法预测的结果。**

注意在你的程序每轮输出结束时（即，每一次交互输出 $a_i$ 时和最后输出 $m$ 与答案时）需要输出回车并刷新输出缓冲区，否则你将会得到 $\text{Idleness Limit Exceeded}$。

- C 的 $\text{fflush(stdout)}$；
- C++ 的 $\text{cout.flush()}$；
- Java 的 $\text{System.out.flush()}$；
- Python 的 $\text{stdout.flush()}$；

来刷新输出缓冲区。

**保证在每组数据中的奇质数** $p$ ($2<p\le 10^{18}$) **都是在交互前确定的，即不会随着你的输入而变化。**

如果你最后输出的答案正确，你会得到 $\text{Accepted}$；

如果你输出的 $m$ 或 $a_i$ 不符合题目范围要求，或最后输出的答案不正确，你会得到 $\text{Wrong Answer}$。

此外，其他的评测结果仍会在评测过程中根据通常情况返回。
## 样例

### 样例输入 #1
```
2
3 1

3

9

9


3 2

4

4

4



```
### 样例输出 #1
```


1

2

3

100
3 9 27

1

7

49

49
0 0 0

```
## 提示



在第一组数据中，MCPlayer542 手上的奇质数 $p=3$，因此有 $q=p^k=3$。

我们选择数组 $a=\{1,\ 2,\ 3\}$，依次得到 $g(3^1)=3, \ g(3^2)=9, \ g(3^3)=9$。

随后我们猜到 $p=3$，选择 $m=100$，因此输出 $3^1\bmod (100\times 1)=3, \ 3^2\bmod (100\times 2)=9, \ 3^3\bmod (100\times 3)=27$。

在第二组数据中，MCPlayer542 手上的奇质数 $p=7$，因此有 $q=p^k=49$。

我们选择数组 $a=\{1,\ 7,\ 49\}$，依次得到 $g(49^1)=4,\ g(49^7)=4,\ g(49^{49})=4$。

随后我们**敏锐地发现** $p=7$，选择 $m=49$，因此输出 $49^1\bmod (49\times 1)=0, \ 49^7\bmod (49\times 7)=0, \ 49^{49}\bmod (49\times 49)=0$。

注：第二组数据中的“**敏锐地发现**”仅作为交互流程的示意，并不保证上述交互可以确定 $p=7$。


---

---
title: "[SNCPC2024] 猜质数 II"
layout: "post"
diff: 省选/NOI-
pid: P10700
tag: ['2024', 'O2优化', '陕西', 'XCPC']
---
# [SNCPC2024] 猜质数 II
## 题目描述

为了悄悄准备一个神秘的质数，MCPlayer542 伤透了脑筋。

随后他发明了一种~~聪明~~愚蠢的办法，并起名为“质数分”。

他准备了 $n$ 个不同的数 $a_1,\ a_2,\ \ldots,\ a_n$ 作为测试点，并定义“质数分” $score(x,l,r)$ 如下：

$$score(x,l,r)=\sum_{i=l}^r{f(x,a_i)}$$
其中
$$f(x,y)=\left\{\begin{array}{rcl}u-y, & x=1 \\ u, & 1<x\le y,\ \gcd(x,y)=1 \\ -x\cdot y, & x\neq 1,\ \gcd(x,y)=x \\ 0, & \text{otherwise} \end{array}\right.$$

可见质数的“质数分”通常会比较高~~但还是没什么卵用~~。

于是 MCPlayer542 急了，现在他只想暴力乱测，并得到一个得分和 $\sum_{i=1}^{10^6}{score(i,l,r)}$。他打算测试 $q$ 次，每次测试给定 $u$ 和 $l$，其中 $u$ 为函数 $f(x,y)$ 的参数。

对于每次询问，他想知道所能得到的最大得分和以及能得到这个最大得分和的最小 $r$ 是多少。
## 输入格式

输入数据的第一行包含两个整数 $n,\ q$ ($1\le n,\ q\le 5\times 10^5$)，用单个空格分隔。

第二行包含 $n$ 个整数 $a_1,\ a_2,\ \ldots,\ a_n$ ($1\le a_i\le 10^6$)，用单个空格分隔，表示测试点的数据。

接下来 $q$ 行，每行两个整数 $u_i,\ l_i$ ($1\le u_i \le 1.8\times 10^7,\ 1\le l_i\le n$)，用单个空格分隔，表示一次询问。
## 输出格式

对每个询问输出一行两个数，即对应询问的最大得分和以及能获得该得分的最小 $r_i$ ($l_i\le r_i\le n$)，用单个空格分隔。
## 样例

### 样例输入 #1
```
10 7
10 9 2 1 5 3 10 10 1 8
14 4
17 5
13 10
16 1
12 4
16 6
16 3

```
### 样例输出 #1
```
55 6
60 6
-68 10
-58 6
41 6
20 6
79 6

```
### 样例输入 #2
```
6 8
3 7 7 10 8 9
21 1
20 4
21 3
21 5
21 1
21 2
21 2
21 5

```
### 样例输出 #2
```
170 3
-100 4
70 3
-27 6
170 3
140 3
140 3
-27 6

```
## 提示



在样例 1 的第一个询问中，$u_1=14,\ l_1=4$。若我们选择 $r_1=6$，则最后的得分和为 $\sum_{i=1}^{10^6}{score(i,4,6)}$。其中：
- $score(1,4,6)=13+9+11=33$；
- $score(2,4,6)=0+14+14=28$；
- $score(3,4,6)=0+14-9=5$；
- $score(4,4,6)=0+14+0=14$；
- $score(5,4,6)=0-25+0=-25$；
- $i$ 取其他值时均有 $score(i,4,6)=0+0+0=0$。

故 $r_1=6$ 时得分和为 $33+28+5+14-25=55$。

可以证明在 $r_1$ 取其他值时无法得到更大的得分和，故答案为 $55$，且能达成的最小 $r_1$ 为 $6$。


---

---
title: "悲哀（Sorrow）"
layout: "post"
diff: 省选/NOI-
pid: P10706
tag: []
---
# 悲哀（Sorrow）
## 题目背景

>$$你是天使，$$
>
>$$于光与圣歌中降临。$$
>
>$$我是恶魔，$$
>
>$$从血与污泥中爬出。$$
>
>$$我想拥抱你，$$
>
>$$但是害怕血，$$
>
>$$染红你洁白的羽翼。$$
## 题目描述

给出一棵有 $n$ 个节点且以 $1$ 为根节点的树，每个节点有两个权值 $a_i,b_i$（$1\le i\le n$）。$a_i$ 已经给出，$b_i$ 初始为 $0$。

现在对于每一对节点 $(u,v)$（$1\le u<v\le n$），设 $x=\operatorname{LCA}(u,v)$，如果 $\gcd(a_u,a_v)>1$ 那么 $b_x\gets b_x+a_u\times a_v$，否则不做任何操作。

对于每个 $1\le i\le n$ 求出 $b_i\bmod998244353$。
## 输入格式

第一行一个整数 $n$，表示有 $n$ 个节点。

第二行 $n$ 个正整数，表示 $a_1,a_2\dots a_n$。

接下来 $n-1$ 行，每行两个正整数 $u,v$，表示节点 $u$ 和节点 $v$ 之间有一条边。
## 输出格式

输出共 $n$ 行，每行一个整数。

第 $i$ 行表示 $b_i$ 对 $998244353$ 取模后的结果。
## 样例

### 样例输入 #1
```
8
3 7 2 2 2 3 72 24 
1 2
1 3
1 4
4 5
2 6
5 7
4 8

```
### 样例输出 #1
```
785
0
0
1972
144
0
0
0
```
### 样例输入 #2
```
15
73 83 31 9514 1189 43 79 2 2 1798 5063 2 5 2573 53 
1 2
2 3
1 4
4 5
1 6
3 7
5 8
5 9
6 10
7 11
10 12
9 13
7 14
13 15

```
### 样例输出 #2
```
23952214
633788
79763
38056
4
0
13027099
0
0
3596
0
0
0
0
0
```
## 提示

#### 【样例解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/bti6350r.png)

建出的树如图。

有以下贡献：

- 对 $1$ 号节点：

$(3,4)$ 贡献 $4$。

$(3,5)$ 贡献 $4$。

$(3,7)$ 贡献 $144$。

$(3,8)$ 贡献 $48$。

$(1,6)$ 贡献 $9$。

$(1,7)$ 贡献 $216$。

$(1,8)$ 贡献 $72$。

$(6,7)$ 贡献 $216$。

$(6,8)$ 贡献 $72$。

总共 $785$。

- 对 $4$ 号节点：

$(4,5)$ 贡献 $4$。

$(4,7)$ 贡献 $144$。

$(4,8)$ 贡献 $48$。

$(5,8)$ 贡献 $48$。

$(7,8)$ 贡献 $1728$。

总共 $1972$。

- 对 $5$ 号节点：

$(5,7)$ 贡献 $144$。

总共 $144$。

其他节点显然都为 $0$。

#### 【数据范围】

| subtask 编号 | $n$ | $a_i$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $100$ | $\le 1000$ | $-$ | $5$ |
| $1$ | $2000$ | $\le 10^5$ | $-$ | $10$ |
| $2$ | $10^5$ | $\le 5 \times 10^5$ | $A$ | $25$ |
| $3$ | $2 \times  10^5$ | $\le 5 \times 10^5$ | $B$ | $30$ |
| $4$ | $2 \times  10^5$ | $\le 5 \times 10^5$ | $-$ | $30$ |

特殊性质 $A$：保证所有的 $a_i$ 随机生成。

特殊性质 $B$：保证树的形态是一棵完全二叉树。

对于 $100\%$ 的数据，$1\le n\le2\times10^5$，$1\le a_i\le5\times10^5$。

**特别提醒：本题使用 subtask 捆绑测试，只有通过一个子任务的全部测试点才能获得此子任务的分数。**


---

---
title: "永恒（Eternity）"
layout: "post"
diff: 省选/NOI-
pid: P10707
tag: []
---
# 永恒（Eternity）
## 题目背景

>$$行走人间的，$$
>
>$$不一定是天使。$$
>
>$$带来灾厄的，$$
>
>$$不一定是恶魔。$$
>
>$$恶魔的眼泪被天使珍藏 ， $$
>
>$$天使的纯净由恶魔守护。$$
>
>$$或许，$$
>
>$$这是最好的结局。$$
## 题目描述

一些前置定义：

- 可重集中的元素必须是非负整数。

- 可重集的大小为可重集中元素的个数。

- 对于一个大小为 $x$ 的可重集，设其中的元素为 $a_1,a_2\dots a_x$，那么这个可重集的**权值**就为 $a_1\oplus a_2\oplus \dots \oplus a_x$，即可重集中所有元素的**异或和**。

现在给出 $n,m$。

问有多少不同的大小为 $n$ 的可重集 $S$ 满足：

$$\max\limits_{T \subseteq  S,T\ne \emptyset}{Q_T}=m$$

其中 $Q_T$ 为可重集 $T$ 的**权值**。

**注意：根据可重集的性质，数字相同但数字顺序不同的可重集算同一种可重集，即 $\left \{ 1,2,3 \right \} $ 与 $\left \{ 3,2,1 \right \} $ 算同一种可重集。**

求出不同可重集的个数 $\bmod\ 998244353$ 的结果。

可以证明这样的可重集个数是有限的。
## 输入格式

第一行两个整数，分别表示 $n$ 和 $m$。
## 输出格式

一行一个整数，表示答案对 $998244353$ 取模后的结果。
## 样例

### 样例输入 #1
```
3 5
```
### 样例输出 #1
```
13
```
### 样例输入 #2
```
12 7
```
### 样例输出 #2
```
48643
```
## 提示

#### 【样例解释】

样例一中 $13$ 种方案分别为：

$(0,0,5)$$,$$(0,1,4)$$,$$(0,1,5)$$,$$(0,4,5)$$,$$(0,5,5)$$,$$(1,1,4)$$,$$(1,1,5)$$,$$(1,4,4)$$,$$(1,4,5)$$,$$(1,5,5)$$,$$(4,4,5)$$,$$(4,5,5)$$,$$(5,5,5)$。

#### 【数据范围】

| subtask 编号 | $n$ | $m$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :-----: |
| $0$ | $\le 10$ | $\le 10$ | $-$ | $10$ |
| $1$ | $\le 10^5$ | $<2^{60}$ | $A$ | $20$ |
| $2$ | $\le 2000$ | $\le 2000$ | $-$ | $10$ |
| $3$ | $\le 10^5$ | $<2^{60}$ | $-$ | $60$ | 

特殊性质 $A$： $\operatorname{popcount}(m)\le 5\ $，$\operatorname{popcount}(m)$ 表示 $m$ 的二进制表示中 $1$ 的个数。

对于 $100\%$ 的数据保证 $1\le n\le 10^5$，$0\le m<2^{60}$。

**特别提醒：本题使用 subtask 捆绑测试，只有通过一个子任务的全部测试点才能获得此子任务的分数。**



---

---
title: "[SEERC 2020] 3-colorings"
layout: "post"
diff: 省选/NOI-
pid: P10738
tag: ['2020', 'Special Judge', 'ICPC']
---
# [SEERC 2020] 3-colorings
## 题目描述

**这是一道仅有输出的题。**

定义一个图的有效“三色”染色为：

- 每个点的颜色只能属于 $\{1,2,3\}$。

- 对于每个有边相连的顶点 $(u,v)$，$u$ 的颜色需要与 $v$ 不同。

可以证明，一个图最多的“三色”染色总数为 $3^n$ 种。

现在你需构造一个图，一开始它存在 $n \ (1 \leq n \leq 19)$ 个顶点 $m \ (1 \leq m \leq \frac{n(n-1)}{2})$ 条无向边，然后对于每个 $1 \leq k \leq 500$ 的 $k$，你可以添加至多 $17$ 条无向边使得此图的“三色”染色总数为 $6k$ 种。
## 输入格式

无。
## 输出格式

第一行 $n,m$，表示你构造图的点数和边数。

然后 $m$ 行，一行两个整数 $u,v$，表示 $(u,v)$ 存在一条无向边。

然后 $k$ 从 $1$ 到 $500$，每个 $k$ 输出你要添加的边数，然后再是对应行添加的边 $(u,v)$。
## 样例

### 样例输入 #1
```

```
### 样例输出 #1
```
3 2
1 2
2 3
1
1 3
0
```
## 提示

样例仅给出 $k=1$ 和 $k=2$ 的示例。


---

---
title: "[SEERC 2020] Simple Hull"
layout: "post"
diff: 省选/NOI-
pid: P10742
tag: ['2020', 'ICPC']
---
# [SEERC 2020] Simple Hull
## 题目描述

Gary 创造了一个含有 $n$ 个点的多边形，每个点的坐标形如 $(x,y)$。

你需要进行一些连边，保证包含所有的点，同时连出来的图是一条“多边形链”（即任何一个点只能连向或被连向 $2$ 个点，且连出来的边可以在图中与其他边相交）。

你还需要保证每两个存在连边的点 $i$ 和 $j$，这两个点形成的边在图中是垂直或水平的。

输出连出来的图的最小面积。
## 输入格式

第一行一个整数 $n\ (1 \leq n \leq 10^5)$，表示点的个数。

然后 $n$ 行，每行两个整数 $x_i,y_i\ (1 \leq x_i,y_i \leq 10^6)$。
## 输出格式

输出连出的 $n$ 边形的面积。
## 样例

### 样例输入 #1
```
6
1 1
6 1
6 11
11 11
11 6
1 6
```
### 样例输出 #1
```
50
```
### 样例输入 #2
```
8
2 4
2 1
4 1
4 3
1 3
1 2
3 2
3 4
```
### 样例输出 #2
```
6
```
### 样例输入 #3
```
10
1 1
1 5
4 5
4 3
2 3
2 4
1 4
1 2
4 2
4 1
```
### 样例输出 #3
```
8
```
## 提示

三个样例画出的图依次为：

![](https://cdn.luogu.com.cn/upload/image_hosting/r9x5s5zy.png)

（上述图未按比例画图）


---

---
title: "[SEERC 2020] AND = OR"
layout: "post"
diff: 省选/NOI-
pid: P10743
tag: ['2020', 'ICPC']
---
# [SEERC 2020] AND = OR
## 题目描述

一个数组 $b$ 被称为“好的数组”当且仅当可以将 $b$ 划分为两个非空的子数组，这两个子数组中第一个子数组的 $\mathtt{OR}$ 结果与第二个子数组的 $\mathtt{AND}$ 结果相等，例如 $\{1,7,3,11\}$，将其划分为 $\{1,3\}$ 与 $\{7,11\}$，$1\ \mathtt{OR}\ 3 = 3$，$7\ \mathtt{AND}\ 11 = 3$，所以它是一个好的数组。

现在给定一个长度为 $n$ 的数组 $a$，$q$ 组询问，每次给定 $[l,r]$，为 $\{a_l, a_{l+1},\ldots,a_{r-1},a_{r}\}$ 是不是一个好的数组。
## 输入格式

第一行两个整数 $n\ (1 \leq n \leq 10^5)$ 和 $q\ (1 \leq q \leq 10^5)$。

然后一行 $n$ 个整数表示序列 $a\ (0\leq a_i \leq 2^{30}-1)$。

接下来 $q$ 行，一行两个整数 $l,r\ (1 \leq l \leq r \leq n)$，表示一组询问。
## 输出格式

对于每个询问，如果该子数组是好的输出 `YES`，否则输出 `NO`。
## 样例

### 样例输入 #1
```
5 15
0 1 1 3 2
1 1
1 2
1 3
1 4
1 5
2 2
2 3
2 4
2 5
3 3
3 4
3 5
4 4
4 5
5 5
```
### 样例输出 #1
```
NO
NO
YES
YES
YES
NO
YES
YES
YES
NO
NO
YES
NO
NO
NO
```


---

---
title: "[SEERC 2020] One Piece"
layout: "post"
diff: 省选/NOI-
pid: P10745
tag: ['2020', 'ICPC']
---
# [SEERC 2020] One Piece
## 题目描述

有一个图，它是一个 $n$ 个点的树，每条边都是形如 $(u,v)$ 的边长为 $1$ 的无向边。

你有一个寻宝器，当你在点 $i$ 时，它会返回一个最远距离 $x$，表示存在宝藏的位置距 $i$ 点最远长度为 $x$，一个图可能存在多个宝藏。

现在你知道了对于 $1 \leq i \leq n$ 时的寻宝器返回结果，问你确定每个点是否存在宝藏的概率从大到小依次排序后的数组。
## 输入格式

第一行一个整数 $n\ (1 \leq n \leq 2.5 \times 10^5)$，表示点数。

接下来 $n-1$ 行，每行两个整数 $u,v$，表示一条边。

再一行 $n$ 个数，表示在 $i$ 点调用寻宝器的返回值。
## 输出格式

输出每个点是否存在宝藏的概率从大到小依次排序后的数组。

同概率下标升序排序。
## 样例

### 样例输入 #1
```
5
1 2
1 3
2 4
2 5
2 2 3 3 3
```
### 样例输出 #1
```
3 4 5 1 2
```
### 样例输入 #2
```
4
2 1
3 2
3 4
1 0 1 2
```
### 样例输出 #2
```
2 1 3 4
```


---

---
title: "[SEERC 2020] Codenames"
layout: "post"
diff: 省选/NOI-
pid: P10746
tag: ['2020', 'Special Judge', 'ICPC']
---
# [SEERC 2020] Codenames
## 题目描述

有 $q$ 个 $5 \times 5$ 的图表，给出每个点的颜色（只可能是 `r`、`b`、`n`、`x`），具体颜色分配为：$9$ 个 `r`，$8$ 个 `b`，$5$ 个 `n`，一个 `x`。

图表中每个点对应的字符始终确定，分别为：

```
abcde
fghij
klmno
pqrst
uvwxy
```

图表中某些颜色已经翻开来了（用其颜色的大写字母表示已显示），然后你需要从一个 $n$ 个字符串的列表内选择一个字符串 $w$ 和一个数字 $g$，按下述规则进行操作 $g$ 次。

- 如果当前 $w_i$ 字符代表的格子颜色已经被公示，不进行操作，令 $i \gets i + 1$。
- 否则，翻开 $w_i$ 代表的格子，如果 $w_i$ 的颜色为 `n`、`b` 或 `x`，就输了。然后再令 $i \gets i+1$。
- 当 $g$ 次操作完成或所有 `r` 色块都翻出来时结束操作。

你想要使得所有 `r` 色块都翻出来，求一组满足条件的 $w$ 与 $g$。
## 输入格式

第一行一个整数 $n\ (1 \leq n \leq 10^5)$。

然后 $n$ 行，每行一个字符串，描述了一整个字符串列表。

第 $n+2$ 行，整数 $q\ (1 \leq q \leq 10^5)$，表示表格个数。

然后 $q$ 组图表，每个图表占据 $5 \times 5$ 的大小，描述了第 $i$ 个图表的颜色。
## 输出格式

对于每个图表，如果有解，输出一组合法的 $w$ 和 $g\ (1 \leq g \leq 9)$，无解输出 `IMPOSSIBLE`。
## 样例

### 样例输入 #1
```
3
actor
cheat
zeta
1
rBBnR
NRnbB
nRRnR
NRxBr
nBRbB
```
### 样例输出 #1
```
actor 2
```
## 提示

答案还可能是 `actor 4`，`zeta 2` 等。


---

---
title: "[SEERC 2020] Neo-Robin Hood"
layout: "post"
diff: 省选/NOI-
pid: P10747
tag: ['2020', 'ICPC']
---
# [SEERC 2020] Neo-Robin Hood
## 题目描述

你是一个大盗，镇上一共有 $n$ 户人家，对于每户人家 $i$，你在如下的选择里选一样。

- 盗窃他的 $m_i$ 元钱，他会对你起仇恨。

- 给他 $p_i$ 元钱，他会让你盗窃的一个人取消对你的仇恨。

- 什么也不做。

初始时你没有钱，你想知道，在没人对你有仇恨且你手中的钱非负的情况下，你最多能盗窃多少户人家。

注：你可以按任意顺序依次访问每户人家。
## 输入格式

第一行一个整数 $n\ (1 \leq n \leq 10^5)$。

第二行一个长度为 $n$ 的序列 $m\ (1 \leq m_i \leq 10^9)$。

第三行一个长度为 $n$ 的序列 $p\ (1 \leq p_i \leq 10^9)$。
## 输出格式

输出最多能盗窃的人家数。
## 样例

### 样例输入 #1
```
5
2 3 4 5 6
1 2 3 4 5
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
4
1 2 4 2
5 6 9 7

```
### 样例输出 #2
```
0
```
### 样例输入 #3
```
4
9 19 6 5
20 3 16 19

```
### 样例输出 #3
```
1
```


---

---
title: "[BalticOI 2024] Jobs"
layout: "post"
diff: 省选/NOI-
pid: P10759
tag: ['2024', 'BalticOI（波罗的海）']
---
# [BalticOI 2024] Jobs
## 题目背景

翻译自 [BalticOI 2024 Day1 T1](https://boi2024.lmio.lt/tasks/d1-jobs-statement.pdf)。
## 题目描述

目前，你可以选择从 $1$ 到 $N$ 编号的 $N$ 个一次性工作。

完成第 $i$ 个工作将给你带来 $x$ 欧元的利润，当然，利润也可能是负的。

有些工作依赖于另一个工作。也就是说，可能有一个编号为 $p$ 的工作必须在第 $i$ 个工作开始之前完成。因此，一个利润较大的工作如果依赖于一个利润为负的工作，看起来收益可能会比较小。

如果 $p = 0$，则第 $i$ 个工作没有依赖。

你目前有 $s$ 欧元，可以决定做哪些工作以及以什么顺序去做，只要尊重依赖关系。此外，你所拥有的钱数在任何时候都不能变成负数。

请计算通过选择按照某种顺序完成（也可能某些选择不完成）这 $N$ 个工作所能获得的最大利润。
## 输入格式

第一行包含两个整数 $N$ 和 $s$，分别是工作的数量和你最初拥有的金额。

接下来的 $N$ 行，每行包含两个整数 $x$ 和 $p$，分别是第 $i$ 个工作的利润和它所依赖的前置工作的编号。如果 $p = 0$，则第 $i$ 个工作没有依赖。
## 输出格式

你的程序应该输出一个整数，即你能够获得的最大利润。
## 样例

### 样例输入 #1
```
6 1
3 0
-3 1
-5 0
2 1
6 3
-4 5
```
### 样例输出 #1
```
6
```
## 提示

分别选择 $1,4,3,5$ 号工作即可，总利润为 $3+2-5+6 = 6$。

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $s = 10^{18}$ | $11$ |
| $2$ | $N \leq 2000$ 且满足性质 A | $14$ |
| $3$ | 满足性质 A | $15$ |
| $4$ | $N \leq 2000$ | $29$ |
| $5$ | 无特殊性质 | $31$ |

* 性质 A：每个 $p_i$ 要么是 $0$，要么是 $i-1$。

对于所有的数据，$1 \leq N \leq 3 \times 10^5$，$0 \leq s \leq 10^{18}$，$-10^9 \leq x_i \leq 10^9$，$0 \leq p_i < i$。


---

---
title: "[BalticOI 2024] Portal"
layout: "post"
diff: 省选/NOI-
pid: P10760
tag: ['2024', 'BalticOI（波罗的海）']
---
# [BalticOI 2024] Portal
## 题目背景

翻译自 [BalticOI 2024 Day1 T2](https://boi2024.lmio.lt/tasks/d1-portal-statement.pdf)。
## 题目描述

你在和你的朋友玩一个恶作剧，朋友初始在 $(0,0)$ 位置，每个格子都有颜色，有 $N$ 个传送门，当你的朋友进入某个传送门之内时，会等概率地随机到 $N$ 个传送门其中之一（可能传送到原本的门，如果 $(0,0)$ 有传送门也要传送）。

可惜的是，你的朋友并不知道有传送门的存在，他只会根据他所走的格子确定他所在的格子与其颜色，你需要保证无论他怎么走，他所看到的格子颜色永远与他认为的格子颜色一样。

你可以随意染色，但是请最大化颜色数量，不难发现涂成一个颜色总是最小的解。
## 输入格式

第一行一个整数 $N$，表示有 $N$ 个传送门。

接下来 $N$ 行，每行两个整数 $(x_i,y_i)$，表示传送门的坐标。
## 输出格式

输出一个数表示你最大使用颜色的数量，如果可以使用无数种，输出 $-1$。
## 样例

### 样例输入 #1
```
3
1 1
1 3
3 2
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
5
0 0
1 0
-1 0
0 1
0 -1
```
### 样例输出 #2
```
1
```
### 样例输入 #3
```
1
1 -1 
```
### 样例输出 #3
```
-1
```
## 提示

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $N \leq 2$ | $1$ |
| $2$ | $N \leq 3$ | $10$ |
| $3$ | 对于所有存在传送门的 $(x_1,y_1)$ 和 $(x_2,y_2)$，保证 $(x_1,y_2)$ 也存在传送门 | $10$ |
| $4$ | $N \leq 100$ 且 $-100 \leq x_i,y_i \leq 100$ | $29$ |
| $5$ | $N \leq 2000$ | $15$ |
| $6$ | 无特殊性质 | $35$ |

对于全部数据，$1 \leq N \leq 10^5$，$-10^6 \leq x_i,y_i \leq 10^6$，且保证 $(x_i,y_i)$ 互不相同。


对于样例一，传送门被放置在 $(1,1)$、$(1,3)$ 和 $(3,2)$ 位置，如果你的朋友按照以下顺序移动：上、右、下、左。

![](https://cdn.luogu.com.cn/upload/image_hosting/cjusbzy8.png)

在移动序列结束后，你的朋友会认为他们回到了起始单元格$(0,0)$，但实际上他们也可能最终停在 $(0,2)$ 或 $(2,1)$。他们已经在开始时看到了 $(0,0)$ 单元格的颜色，所以如果现在他们看到不同的颜色，就会意识到必须有传送门的存在。我们不希望发生这种情况，所以我们必须为这三个单元格选择相同的颜色。

没有任何移动序列能让你的朋友认为他们最终停在 $(0,0)$ 单元格，而实际上他们却停在了 $(1,0)$ ，所以这些单元格可以放心地使用不同的颜色。

你可以看到下面例子中使用了 $4$ 种颜色的着色方案。对于这个例子来说，不可能使用超过 $4$ 种颜色。

![](https://cdn.luogu.com.cn/upload/image_hosting/i123jgsw.png)

对于样例二，让我们考虑一个不同的例子，其中在单元格 $(0,0)$、$(0,1)$、$(1,0)$、$(0,-1)$ 和 $(-1,0)$ 处设有传送门。假设你的朋友试图通过先向右移动一次，然后向上移动三次来到达单元格 $(1,3)$。一种可能是，如果他们在一开始和每一步之后都被传送到那里，那么他们最终会到达单元格 $(0,0)$。如果你的朋友现在通过向下移动三次然后向左移动一次来回到他们认为的 $(0,0)$ 单元格，并且在这个过程中没有被从当前单元格传送走，他们最终会到达 $(-1,-3)$。你的朋友会第二次认为自己处于 $(0, 0)$ 单元格，并期望看到相同的颜色。所以你需要用相同的颜色给 $(-1,-3)$ 和 $(0, 0)$ 着色。

请注意，我们选择单元格 $(1,3)$ 作为起点并没有什么特别之处。你同样可以证明其他单元格必须与 $(0,0)$ 共享同一种颜色。


---

---
title: "[NOISG 2021 Qualification] Departure"
layout: "post"
diff: 省选/NOI-
pid: P10772
tag: ['2021', 'NOISG（新加坡）']
---
# [NOISG 2021 Qualification] Departure
## 题目描述

有一个城市，城市里有 $N$ 条路线，每条路线上，在每天午夜会有一辆巴士从起点出发，第二天午夜到达终点。第 $i$ 辆公交车的起点为 $S_i$，终点为 $E_i$。人们可以在巴士路线上的的**任何地方**上车、下车或者换乘。

体育馆是这个城市的中心，坐标为 $0$。在体育馆西边 $x$ 千米的点，坐标为 $-x$，在体育馆东边 $x$ 千米的点，坐标为 $x$。

现在有 $M$ 个人需要从体育馆回家，你需要求出每一个人回家的最短时间。
## 输入格式

第 $1$ 行两个整数 $N,M$。

第 $2$ 至 $N+1$ 行，每行两个整数 $S_i,E_i$。

第 $N+2$ 行 $M$ 个整数 $P_j$，表示每一个人的家。
## 输出格式

$M$ 行，每行两个整数 $a,b$（$\gcd(a,b)=1$），表示这个人最早能在 $\dfrac{a}{b}$ 天后回家。
## 样例

### 样例输入 #1
```
5 8
0 5
3 11
1 -8
4 10
1 -3
1 2 5 6 8 -3 -7 11
```
### 样例输出 #1
```
1 5
2 5
1 1
4 3
13 8
4 9
8 9
2 1
```
### 样例输入 #2
```
3 2
-1 4
-2 5
0 -5
4 -4
```
### 样例输出 #2
```
6 7
4 5
```
### 样例输入 #3
```
5 3
0 2
2 4
4 6
6 8
8 10
9 10 10
```
### 样例输出 #3
```
9 2
5 1
5 1
```
## 提示

#### 数据范围

**本题采用捆绑测试。**

以下定义 $\operatorname{sign}(x) = \begin{cases}
1 &\text{if } x > 0 \\
0 &\text{if } x = 0 \\
-1 &\text{if } x < 0 \\
\end{cases}$。

Subtask0 为样例。

Subtask1（10 pts）$N \leq 10^4$，$M \leq 10^3$，$\operatorname{sign}(S_i)\neq\operatorname{sign}(E_i)$。

Subtask2（14 pts）$N \leq 100$，$M \leq 10^3$。

Subtask3（12 pts）$N \leq 10^3$，$M \leq 10^5$，保证最后答案的值均不大于 $10^3$，保证任意坐标在不超过 $10^2$ 条线路上。

Subtask4（8 pts）$M \leq 10^3$，保证任意坐标在不超过 $10^4$ 条线路上。

Subtask5（15 pts）$M \leq 10^4$，保证最后答案的值均不大于 $10^2$。

Subtask6（13 pts）$\operatorname{sign}(S_i)\neq\operatorname{sign}(E_i)$。

Subtask7（28 pts）无特殊限制。

数据保证 $1 \leq N,M \leq 10^6$，$-10^6 \leq S_i,E_i,P_j \leq 10^6$，$S_i \neq E_i$，$P_j \neq 0$。


---

---
title: "[NOISG 2021 Qualification] Truck"
layout: "post"
diff: 省选/NOI-
pid: P10773
tag: ['2021', 'NOISG（新加坡）']
---
# [NOISG 2021 Qualification] Truck
## 题目描述

有一棵树，每条边有两个权值 $D_i$ 和 $T_i$，给定 $Q$ 次操作。操作分为两种：

`0 x y t`：表示把 $x$ 和 $y$ 之间的一条道路的 $T_i$ 值改为 $t$。

`1 x y`：表示查询 $x$ 到 $y$ 的费用。

定义 $x$ 到 $y$ 的费用为：给定参数 $G$（对每组询问都相同），要求 $x$ 运送一些价值到 $y$，每经过一条权值为 $D_i$ 和 $T_i$ 的边，运送的价值会减少 $T_i$，然后会产生运送的价值的 $D_i$ 倍的费用。在运送到 $y$ 节点时，若运送到的价值刚好为 $G$，产生的费用就为 $x$ 到 $y$ 的费用。

你要对每组询问计算费用。由于费用可能比较大，请输出对 $10^9+7$ 取模的值。
## 输入格式

第 $1$ 行两个整数 $N,G$。

第 $2 \sim N$ 行，每行四个整数 $A_i,B_i,D_i,T_i$，表示树上 $A_i$ 和 $B_i$ 有一条边，边权为 $D_i$ 和 $T_i$。

第 $N+1$ 行一个整数 $Q$，表示操作个数。

下面 $Q$ 行，每行一个操作，格式见上。
## 输出格式

若干行，对于每个查询操作，你需要求出费用。每行一个回答。
## 样例

### 样例输入 #1
```
6 2
1 2 2 1
2 3 1 2
2 4 2 3
4 5 2 2
4 6 1 4
3
1 3 6
0 4 5 5
1 2 5

```
### 样例输出 #1
```
23
18
```
### 样例输入 #2
```
4 3
1 2 3 0
2 3 1 0
3 4 4 0
1
1 1 4
```
### 样例输出 #2
```
24
```
## 提示

#### 数据范围

**本题采用捆绑测试。**

Subtask0 为样例。

Subtask1（5 pts）只有查询操作，每个节点度不超过 $2$，且 $T_i=0$。

Subtask2（9 pts）只有查询操作，且 $T_i = 0$。

Subtask3（12 pts）只有查询操作，$D_i=1$，且所有 $T_i$ 相等。

Subtask4（17 pts）只有查询操作，且每个节点度不超过 $2$。

Subtask5（20 pts）每个节点度不超过 $2$。

Subtask6（18 pts）$N,Q \leq 5000$。

Subtask7（19 pts）无特殊限制。

数据保证 $2 \leq N \leq 10^5$，$1 \leq Q \leq 10^5$，$1 \leq A_i,B_i \leq N$，$1 \leq D_i,T_i,G \leq 10^9$。


---

---
title: "[NOI2024] 集合"
layout: "post"
diff: 省选/NOI-
pid: P10785
tag: ['2024', 'NOI', 'O2优化']
---
# [NOI2024] 集合
## 题目描述

小 Y 和小 S 在玩一个游戏。

给定正整数 $m$，定义**基本集合**为大小为 $3$，元素在 $1\sim m$ 内的集合。例如：给定 $m=4$，则集合 $\{1,2,3\}$ 与集合 $\{2,3,4\}$ 都是基本集合。

定义**集合序列**为由基本集合构成的序列，例如，$A=[\{1,2,3\},\{2,3,4\}]$ 是一个集合序列，其中 $A[1]=\{1,2,3\}$，$A[2]=\{2,3,4\}$ 都是基本集合。

对于一个 $1\sim m$ 的排列 $p[1],p[2],\dots,p[m]$ 与集合 $S\subseteq \{1,2,\dots,m\}$，定义 $f_p(S)$ 为将 $S$ 内每一个元素 $x$ 置换为 $p[x]$ 后所得到的集合，即 $f_p(S)=\{p[x]|x\in S\}$。

对于两个长度为 $k$ 的集合序列 $A,B$，定义 $A$ 和 $B$ **等价**当且仅当存在一个 $1\sim m$ 的排列 $p$，使得 $A$ 置换排列 $p$ 后得到 $B$，即对于所有 $1\leq i\leq k$，$f_p(A[i])=B[i]$。

给定两个长度为 $n$ 的集合序列 $A,B$，有 $q$ 次询问。每次小 S 会询问小 Y，在给定 $l,r$ 的情况下，判断集合序列 $[A[l],A[l+1],\dots,A[r]]$ 与集合序列 $[B[l],B[l+1],\dots,B[r]]$ 是否等价。

时光荏苒，小 S 和小 Y 也会散去。而我们和一个人保持连接的方式就是记住，仅此而已。
## 输入格式

输入的第一行包含三个正整数 $n,m,q$，分别表示集合序列的长度，元素范围和询问次数。

输入的第二行包含 $3n$ 个正整数，第 $3i-2,3i-1,3i$（$1\leq i\leq n$）个正整数分别表示 $A[i]$ 的三个元素。保证这三个元素均在 $[1,m]$ 范围内且互不相同。

输入的第三行包含 $3n$ 个正整数，第 $3i-2,3i-1,3i$（$1\leq i\leq n$）个正整数分别表示 $B[i]$ 的三个元素。保证这三个元素均在 $[1,m]$ 范围内且互不相同。

接下来 $q$ 行，每行包含两个正整数 $l,r$，表示一次询问。
## 输出格式

输出 $q$ 行，每行包含一个字符串 $\tt{Yes}$ 或 $\tt{No}$，表示对应询问的两个序列是否等价。
## 样例

### 样例输入 #1
```
4 4 10
1 2 3 1 2 3 1 2 4 1 2 3
1 2 4 2 3 4 1 2 3 2 3 4
1 1
1 2
1 3
1 4
2 2
2 3
2 4
3 3
3 4
4 4
```
### 样例输出 #1
```
Yes
No
No
No
Yes
Yes
Yes
Yes
Yes
Yes
```
### 样例输入 #2
```
见 set2.in/ans
这个样例满足测试点 1-3 的约束条件。
```
### 样例输出 #2
```

```
### 样例输入 #3
```
见 set3.in/ans
这个样例满足测试点 8 的约束条件。
```
### 样例输出 #3
```

```
### 样例输入 #4
```
见 set4.in/ans
这个样例满足测试点 15、16 的约束条件。
```
### 样例输出 #4
```

```
## 提示

**【样例 1 解释】**

以下用 $(l,r)$ 表示对 $l,r$ 的询问：
- 对于询问 $(1,1)$，令排列 $p=[1,2,4,3]$，则 $f_p(A_1)=\{p[1],p[2],p[3]\}=\{1,2,4\}=B[1]$，因此该询问对应的两个序列等价。
- 对于询问 $(1,2),(1,3),(1,4)$，由于 $A[1]=A[2]$ 但 $B[1]\neq B[2]$，因此这些询问对应的两个序列都不等价。
- 对于询问 $(2,2),(2,3),(2,4),(3,3),(3,4),(4,4)$，令排列 $p=[2,3,4,1]$，则 $f_p(A_2)=\{p[1],p[2],p[3]\}=\{2,3,4\}=B_2$，$f_p(A_3)=\{p[1],p[2],p[4]\}=\{1,2,3\}=B_3$，$f_p(A_4)=\{p[1],p[2],p[3]\}=\{2,3,4\}=B_4$，因此这些询问对应的两个序列都等价。

**【数据范围】**

对于所有测试数据保证：$1\leq n\leq 2\times 10^5$，$3\leq m\leq 6\times 10^5$，$1\leq q\leq 10^6$，$1\leq l\leq r\leq n$。

| 测试点编号 | $n\leq$ | $m\leq$ | $q\leq$ |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $50$ | $4$ | $50$ |
| $4\sim 6$ | $50$ | $5$ | $50$ |
| $7$ | $200$ | $4$ | $200$ |
| $8$ | $200$ | $5$ | $200$ |
| $9$ | $200$ | $4$ | $2\times 10^5$ |
| $10$ | $200$ | $5$ | $2\times 10^5$ |
| $11$ | $2\times 10^5$ | $4$ | $2\times 10^5$ |
| $12$ | $2\times 10^5$ | $5$ | $2\times 10^5$ |
| $13,14$ | $2\,000$ | $6\,000$ | $10^3$ |
| $15,16$ | $2\,000$ | $6\,000$ | $10^6$ |
| $17,18$ | $2\times 10^4$ | $6\times 10^4$ | $10^2$ |
| $19,20$ | $2\times 10^5$ | $6\times 10^5$ | $10^6$ |



---

---
title: "[NOI2024] 百万富翁"
layout: "post"
diff: 省选/NOI-
pid: P10786
tag: ['2024', 'NOI', '交互题', 'Special Judge', 'O2优化']
---
# [NOI2024] 百万富翁
## 题目背景

**本题仅支持 C++ 语言评测。由于平台限制，使用 C++14 (GCC 9) 提交代码会导致 CE。请使用其他版本的 C++ 提交（推荐 C++14 及以上）。**

与 NOI 要求的提交格式不同，你的程序中**不应该**包含头文件 `richest.h`。同时，你的程序中应当在包含 `vector` 头文件的前提下，包含对以下函数的声明：

```cpp
std::vector<int> ask(std::vector<int> a, std::vector<int> b);
```

除此之外，其余要求与 NOI 要求一致。
## 题目描述

小 Y 的银行有 $N$ 个客户，编号为 $0$ 到 $N-1$。客户 $i$ 有 $W_i$ 元存款，且**客户之间的存款金额互不相同**。

小 P 是小 Y 的深度合作伙伴，他希望知道哪个客户的存款最多。小 P 无法直接获取客户的存款金额，但他可以依次发送若干次**请求**，每次请求包含若干个**查询**，每个查询是一个二元组 $(i,j)$，表示小 P 想知道客户 $i$ 和客户 $j$ 的存款金额哪个更多。如果 $W_i>W_j$，小 Y 会回答 $i$，否则回答 $j$。

小 P 的**请求数** $t$ 和所有请求的**查询**次数总和 $s$ 有上限，他希望你帮他写一个程序，来找到存款最多的客户。
## 输入格式

选手不需要，也不应该实现 main 函数。

选手应确保提交的程序包含头文件 `richest.h`，可在程序开头加入以下代码实现：

```cpp
#include "richest.h"
```

选手需要实现以下函数：
```cpp
int richest(int N,int T,int S);
```
- $N$ 表示客户的数量；
- $T$ 表示对于当前函数调用，**请求**数 $t$ 不应超过此值；
- $S$ 表示对于当前函数调用，所有请求的**查询**次数总和 $s$ 不应超过此值；
- 该函数需要返回存款最多的客户的编号；
- 对于每个测试点，该函数**会被交互库调用恰好 $10$ 次**；

选手可以通过调用以下函数向交互库发送一次**请求**：
```cpp
std::vector <int> ask(std::vector <int> a, std::vector <int> b);
```
- 在调用 `ask` 函数时需要保证传入参数 $a$ 和 $b$ 的长度相同，且其中的每个元素都必须是小于 $N$ 的非负整数，表示该**请求**中的所有**查询**。
- 该函数会返回一个类型为 `std::vector <int>` 且长度与 $a$ 和 $b$ 相同的变量，设为 $c$，其中 $c[i]$ 表示在客户 $a[i]$ 和 $b[i]$ 中存款较多的客户的编号。

题目保证在规定的**请求**和**查询**次数限制下，交互库运行的时间不超过 $3$ 秒，交互库使用的内存大小固定，且不超过 $256$ MiB。

**试题目录下的 `grader.cpp` 是提供的交互库参考实现，最终测试所用的交互库与该参考实现有所不同，因此选手的解法不应该依赖交互库实现。**

选手可以在本题目录下使用如下命令编译得到可执行程序：

```
g++ grader.cpp richest.cpp -o richest -O2 -std=c++14 -static
```

对于编译得到的可执行程序：
- 可执行文件将从**标准输入**读入以下格式的数据：
  - 输入的第一行包含四个非负整数 $N,T,S,R$，其中 $R$ 是交互库生成测试数据的随机种子。
- 输入完成后，交互库将调用 $10$ 次函数 `richest`，用输入的参数生成的测试数据进行测试。`richest` 函数返回后，交互库会输出以下信息：
  - 输出的前 $10$ 行中，每行首先包含三个整数 $r,t,s$，表示该次执行的结果。其中 $r$ 是 `richest` 函数的返回值，$t$ 和 $s$ 的含义如题目描述中所示，然后包含该次运行的正确性等消息。
  - 输出的第 $11$ 行包含 $10$ 次运行的总信息。
## 输出格式

假设可执行文件生成的测试数据为 $N=4$，$W=[101,103,102,100]$，$T=100$，$S=100$，下面是一个正确的交互过程：

| 选手程序 | 交互库 | 说明 |
| :----------: | :----------: | :----------: |
|  | 调用 `richest(4,100,100)` | 开始测试 |
| 调用 `ask([0,2],[1,3])` | 返回 $[1,2]$ | $W_0<W_1,W_2>W_3$ |
| 调用 `ask([0,2,3],[1,1,1])` | 返回 $[1,1,1]$ | $W_0<W_1,W_2<W_1,W_3<W_1$ |
| 运行结束并返回 $1$ | 向屏幕打印交互结果 | 交互结束，结果正确 |

在这个例子中，$r=1,t=2,s=5$ 满足请求与查询次数的限制。
## 提示

**【下发文件说明】**

在本试题目录下：
- `grader.cpp` 是提供的交互库参考实现。
- `richest.h` 是头文件，选手不用关心具体内容。
- `template_richest.cpp` 是提供的示例代码，选手可在此代码的基础上实现。

选手注意对所有下发文件做好备份，最终评测时只测试本试题目录下的 `richest.cpp`，对该程序以外文件的修改不会影响评测结果。

**【数据范围】**

对于所有测试数据保证：所有 $W_i$ 两两不同。

本题共 $2$ 个测试点，每个测试点的分值和数据范围见下表。

| 测试点编号 | 分值 | $N=$ | $T=$ | $S=$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $15$ | $1\,000$ | $1$ | $499\,500$ |
| $2$ | $85$ | $1\,000\,000$ | $20$ | $2\,000\,000$ |

**【评分方式】**

注意：
- 选手不应通过非法方式获取交互库的内部信息，如试图直接读取数组 $W$ 的值，或直接与标准输入、输出流进行交互。此类行为将被视为作弊。
- **最终的评测交互库与样例交互库的实现不同，且可能是适应性的：在不与 `ask` 此前返回的结果相矛盾的前提下，最终的评测交互库可能会动态调整 $W$ 的值。**

**本题首先会受到和传统相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制都会导致相应测试点得 0 分。选手只能在程序中访问自己定义的和交互库给出的变量或数据，及其相应的内存空间。尝试访问其他位置空间将可能导致编译错误或运行错误。

在每次 `richest` 函数调用中，程序使用的请求次数 $t$ 和所有请求的查询次数总和 $s$ 需在对应限制下，否则将会获得 $0$ 分。

在上述条件基础上：
- 在测试点 $1$ 中，程序得到满分当且仅当 `ask` 函数调用合法且 `richest` 函数返回的答案正确；
- 在测试点 $2$ 中，程序得到的分数将按照以下方式计算：
  - 若 `ask` 函数调用不合法，则获得 $0$ 分；
  - 若 `ask` 函数调用均合法，设 $\max t$ 表示多次调用 `richest` 函数所得的 $t$ 的最大值，$\max s$ 表示 $s$ 的最大值，则程序将获得 $\lfloor 85 \cdot f(\max t) \cdot g(\max s)\rfloor$ 分，其中 $f$ 与 $g$ 的计算方式如下表所示：
  
| $\max t$ | $f(\max t)$ |
| :----------: | :----------: |
| $\max t\leq 8$ | $1$ |
| $9\leq \max t\leq 20$ | $1-\dfrac{1}{4}\sqrt{\max t-8}$ |

| $\max s$ | $g(\max s)$ |
| :----------: | :----------: |
| $\max s\leq 1\,099\,944$ | $1$ |
| $1\,099\,945\leq \max s\leq 1\,100\,043$ | $1-\dfrac{1}{6} \log_{10} (\max s-1\,099\,943)$ |
| $1\,100\,044\leq \max s\leq 2\,000\,000$ | $\dfrac{2}{3}-\dfrac{1}{1\,500}\sqrt{\max s-1\,100\,043}$|

以下是测试点 $2$ 中，不同的 $t$ 和 $s$ 对得分影响的示例。

| $\max t$ |            $\max s$            | 测试点 $2$ 的得分 |
| :------: | :----------------------------: | :---------------: |
|  $=20$   |       $\le 1\,099\,944$        |       $11$        |
|  $=19$   |       $\le 1\,099\,944$        |       $14$        |
|  $=18$   |       $\le 1\,099\,944$        |       $17$        |
|  $=17$   |       $\le 1\,099\,944$        |       $21$        |
|  $=16$   |       $\le 1\,099\,944$        |       $24$        |
|  $=15$   |       $\le 1\,099\,944$        |       $28$        |
|  $=14$   |       $\le 1\,099\,944$        |       $32$        |
|  $=13$   |       $\le 1\,099\,944$        |       $37$        |
|  $=12$   |       $\le 1\,099\,944$        |       $42$        |
|  $=11$   |       $\le 1\,099\,944$        |       $48$        |
|  $=10$   |       $\le 1\,099\,944$        |       $54$        |
|   $=9$   |       $\le 1\,099\,944$        |       $63$        |
| $\le 8$  | $\in [1\,099\,974,1\,099\,978]$ |       $63$        |
| $\le 8$  | $\in [1\,099\,969,1\,099\,973]$ |       $64$        |
| $\le 8$  | $\in [1\,099\,965,1\,099\,968]$ |       $65$        |
| $\le 8$  | $\in [1\,099\,962,1\,099\,964]$ |       $66$        |
| $\le 8$  | $\in [1\,099\,959,1\,099\,961]$ |       $67$        |
| $\le 8$  | $\in [1\,099\,957,1\,099\,958]$ |       $68$        |
| $\le 8$  | $\in [1\,099\,955,1\,099\,956]$ |       $69$        |
| $\le 8$  | $\in [1\,099\,953,1\,099\,954]$ |       $70$        |
| $\le 8$  |         $=1\,099\,952$          |       $71$        |
| $\le 8$  |         $=1\,099\,951$          |       $72$        |
| $\le 8$  | $\in [1\,099\,949,1\,099\,950]$ |       $73$        |
| $\le 8$  |         $=1\,099\,948$          |       $75$        |
| $\le 8$  |         $=1\,099\,947$          |       $76$        |
| $\le 8$  |         $=1\,099\,946$          |       $78$        |
| $\le 8$  |         $=1\,099\,945$          |       $80$        |
| $\le 8$  |       $\le 1\,099\,944$        |       $85$        |


---

---
title: "[CEOI 2024] 海战"
layout: "post"
diff: 省选/NOI-
pid: P10801
tag: ['2024', 'CEOI（中欧）']
---
# [CEOI 2024] 海战
## 题目描述

**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day1 T1「[Naval battle](https://ceoi2024.fi.muni.cz/page/tasks/statements/battle.pdf)」**

捷克海军司令官翁德拉刚刚晋升为大元帅，正享受着新职位的安稳，却突然被政府通知海军将被裁撤。

翁德拉决心证明捷克海军的重要性。他通过间谍得知，一场四国海军巨舰对决即将展开。如果能赢得这场战役，无疑能向政府有力地展示海军价值。

然而，捷克海军既无战舰也无港口。但翁德拉想到，如果他的间谍能夺取几艘参战舰艇，或许还有一线生机。关键是，如何预知哪些船能在这场海战中幸存下来呢？

海战规则如下：
- 战前，第 $i$ 艘战舰位于坐标 $(x_i, y_i)$ 处，其中 $x_i$ 和 $y_i$ 均为偶数。每艘战舰隶属于北方、南方、东方或西方舰队之一。
- 海战分回合进行。每回合：
    - 每艘战舰同时向其所属舰队方向移动一格。
    - 如果两艘或以上战舰占据同一格，它们将相撞沉没，从海图上消失。
- 当不再发生碰撞时，海战结束。存活的战舰是指海战结束后仍留在海图上的战舰。

各舰队战舰的移动方向及坐标变化如下：
- 北方舰队：$y$ 坐标减 $1$
- 南方舰队：$y$ 坐标加 $1$
- 东方舰队：$x$ 坐标加 $1$
- 西方舰队：$x$ 坐标减 $1$
## 输入格式

第一行输入一个整数 $N$，代表参与海战的舰船总数。 接下来是 $N$ 行，每行包含三个用空格隔开的整数 $x_i, y_i, d_i$。$x_i$ 和 $y_i$ 表示第 $i$ 艘舰船的初始位置，字符 $d_i$ 表示第 $i$ 艘舰船所属舰队的方向，它可以是 `N`、`S`、`E` 或 `W` 之一。

初始时没有两艘舰船的坐标相同。换句话说，对于任何两艘不同的舰船 $i$ 和 $j$，它们的横坐标 $x_i$ 和 $x_j$ 不可能同时相等，纵坐标 $y_i$ 和 $y_j$ 也不可能同时相等。
## 输出格式

对于每艘存活的战舰，单独输出一行，包含该舰船的编号 $i\ (1 \leq i \leq N)$。你可以按照任何顺序输出幸存舰船的编号。

如果没有存活的战舰，则输出为空。
## 样例

### 样例输入 #1
```
7
0 6 E
0 8 E
2 4 E
4 2 S
6 0 S
6 2 S
6 4 S
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
5
4 0 S
0 2 E
2 2 E
4 4 N
6 6 W
```
### 样例输出 #2
```
2
5
```
## 提示

**样例解释 1**

初始战舰分布如下图：

![battle-sample1-v2.svg](https://img.loj.ac.cn/2024/07/14/c9908b56ff284.svg)

海战过程：
- 第 $2$ 回合，战舰 $3$ 和 $4$ 在 $(4, 4)$ 处相撞。
- 第 $6$ 回合，战舰 $1$ 和 $5$ 在 $(6, 6)$ 处相撞，战舰 $2$ 和 $6$ 在 $(6, 8)$ 处相撞。

最终仅剩战舰 $7$ 存活。


**样例解释 2**

初始战舰分布如下图：

![battle-sample2.svg](https://img.loj.ac.cn/2024/07/14/59d352521ca5d.svg)

第 $2$ 回合，战舰 $1$、$3$、$4$ 在 $(2, 4)$ 处相撞，战舰 $2$ 和 $5$ 存活。

**数据范围与提示**

对于所有输入数据，满足：

- $2 \leq N \leq 2 \cdot 10^5$
- $0 \leq x_i, y_i \leq 10^9\ (1 \leq i \leq N)$，且 $x_i, y_i$ 均为偶数

详细子任务附加限制及分值如下表所示。

| 子任务 | 附加限制 | 分值 |
| :--: | :--: | :--: |
|  $1$  | $N = 2$ | $6$  |
|  $2$  | $N \leq 100, x_i, y_i \leq 100\ (1\leq i\leq n)$ | $12$ |
|  $3$  | $N \leq 100, x_i, y_i \leq 10^5\ (1\leq i\leq n)$ | $8$ |
|  $4$  | $N \leq 200$ | $11$ |
|  $5$  | $N \leq 5\,000$ | $9$ |
|  $6$  | $d_i\ (1 \leq i \leq N)$ 为 `S` 或 `E`  | $30$ |
|  $7$  | 无附加限制| $24$ |


---

---
title: "[CEOI 2024] 加油站"
layout: "post"
diff: 省选/NOI-
pid: P10805
tag: ['2024', 'CEOI（中欧）']
---
# [CEOI 2024] 加油站
## 题目描述

**题目译自 [CEOI 2024](https://ceoi2024.fi.muni.cz/) Day2 T2「[Petrol stations](https://ceoi2024.fi.muni.cz/page/tasks/statements/stations.pdf)」**

捷克的高速公路网络由 $N$ 个城市和 $N-1$ 条路组成，每条路的长度（公里）已知。我们知道任意两个城市之间只有一条路径。此外，每个城市恰好有一个加油站，其他地方没有。

有一天，许多人决定开车旅行。总共有 $N^2$ 辆车在路上。奇怪的是，对于每个有序城市对 $(a, b)$，恰好有一辆车从城市 $a$ 开往城市 $b$，沿着这两个城市之间唯一的路径行驶。由于捷克人全都开斯柯达车，每辆车的油箱容量都是 $K$ 升，并且每公里消耗一升汽油。出发前，每辆车的油箱都是满的。此外，捷克人非常有规律。由于懒惰，他们只在汽油不足以到达下一个城市时才加油（油箱为空时可以进入城市）。一旦他们被迫停在加油站，他们总是把油箱加满。

捷克税务部门想知道当天每个加油站停了多少辆车。鉴于这种可预测的行为，你应该能够轻松计算出来。
## 输入格式

输入的第一行包含两个空格分隔的整数 $N$ 和 $K$，分别表示城市数量和每辆车的油箱容量。

接下来的 $N-1$ 行描述道路。每行包含三个空格分隔的整数 $u_i, v_i, l_i$，其中 $u_i$ 和 $v_i$ 是第 $i$ 条路连接的城市编号，$l_i$ 是这条路的长度（公里）。城市从 $0$ 到 $N-1$ 编号。保证任意两个城市之间只有一条路径。
## 输出格式

输出 $N$ 行，表示从城市 $0$ 到城市 $N-1$ 每个城市加油站停靠的汽车数。
## 样例

### 样例输入 #1
```
3 1
0 1 1
1 2 1
```
### 样例输出 #1
```
0
2
0
```
### 样例输入 #2
```
6 2
0 1 1
1 2 1
2 3 1
3 4 2
4 5 1
```
### 样例输出 #2
```
0
3
3
12
8
0
```
## 提示

**样例解释 1**

有 $3$ 座城市呈直线排列，连接它们的道路长度为 $1$，油箱容量为 $1$ 升。只有在两个外围城市之间行驶的汽车会在中间城市加油。

**样例解释 2**

有 $6$ 个城市呈直线排列，油箱容量为 $2$ 升。许多汽车需要在城市 $3$ 和城市 $4$ 加油。这是有道理的，因为城市 $3$ 和城市 $4$ 之间的道路长度为 $2$ 公里。

对于所有输入数据，满足：
- $2 \leq N \leq 70\,000$
- $1 \leq K \leq 10^9$
- $0 \leq l_i \leq K\ (0 \leq i \leq N-2)$

令 $D$ 表示连接到单个城市的道路的最大数量。详细子任务附加限制及分值如下表所示。

| 子任务 | 附加限制 | 分值 |
| :--: | :--: | :--: |
|  $1$  | $N \leq 1\,000, K \leq 1\,000$ | $18$  |
|  $2$  | $D\le 2$ 且 $l_i = 1\ (0 \leq i \leq N-2)$ | $8$ |
|  $3$  | $D\le 2$| $10$ |
|  $4$  | $K\leq 10, D\leq 10$ | $12$ |
|  $5$  | $K\leq 10$ | $17$ |
|  $6$  | 无附加限制| $35$ |


---

---
title: "【MX-S2-T4】 换"
layout: "post"
diff: 省选/NOI-
pid: P10813
tag: ['O2优化', '梦熊比赛']
---
# 【MX-S2-T4】 换
## 题目背景

原题链接：<https://oier.team/problems/S2D>。
## 题目描述

给定 $n,V$ 和一个长为 $m$ 的序列 $(p_1,q_1),(p_2,q_2),\dots,(p_m,q_m)$。

请求出有多少长度为 $n$ 的正整数序列 $a$，其所有元素 $a_i$ 满足 $1\le a_i\le V$，将其按 $k=1,2,\dots,m$ 依次执行如下操作后，$a$ 不降：  

- 若 $a_{p_k}>a_{q_k}$，则交换 $a_{p_k}$ 与 $a_{q_k}$ 的值。

答案对 $10^9+7$ 取模。
## 输入格式

第一行三个整数 $n,V,m$。

接下来 $m$ 行，每行两个整数 $p_k,q_k$。
## 输出格式

一行一个整数，表示答案对 $10^9+7$ 取模后的结果。
## 样例

### 样例输入 #1
```
3 3 5
3 2
1 3
1 2
2 3
2 1
```
### 样例输出 #1
```
12
```
### 样例输入 #2
```
8 900000754 20
5 5
1 2
3 2
1 8
4 8
5 8
3 4
3 7
5 7
3 4
6 8
1 5
7 8
7 8
5 7
1 8
3 8
3 8
5 6
3 8

```
### 样例输出 #2
```
508510094
```
## 提示

**【样例解释 \#1】**

对于第一组样例，有以下 $12$ 种符合条件的序列：

$\{1,1,1\}$，$\{1,1,2\}$，$\{1,1,3\}$，$\{1,2,1\}$，$\{1,3,1\}$，$\{2,1,1\}$，$\{2,2,2\}$，$\{2,2,3\}$，$\{2,3,2\}$，$\{3,1,1\}$，$\{3,2,2\}$，$\{3,3,3\}$。

**【数据范围】**

**本题采用捆绑测试。**

- Subtask 0（8 pts）：$n\le6$，$V\le 8$，$m \le 50$。
- Subtask 1（31 pts）：$n \le 8$。
- Subtask 2（37 pts）：$n \le 15$。
- Subtask 3（24 pts）：无特殊限制。

对于所有测试数据，$1\le n\le 18$，$1\le V\le 10^9$，$1\le m\le 500$，$1\leq p_k,q_k\leq n$，注意不保证 $p_k$ 和 $q_k$ 的大小关系，且数据可能存在 $p_k=q_k$。


---

---
title: "[EC Final 2020] Random Shuffle"
layout: "post"
diff: 省选/NOI-
pid: P10818
tag: ['2020', 'Special Judge', 'O2优化', 'ICPC']
---
# [EC Final 2020] Random Shuffle
## 题目描述

Prof. Pang is selecting teams that advance to the world final contest. As the regionals are cancelled, he uses random shuffle to rank the teams. There are $n$ teams in total. His code is as follows: 

```cpp
uint64_t x;//uint64_t represents 64-bit unsigned integer
int n;
uint64_t rand() {//this is a xor-shift random generator
    x ^= x << 13;
    x ^= x >> 7;
    x ^= x << 17;
    return x;
}
int main() {
    cin >> n;
    cin >> x;
    for (int i = 1; i <= n; i++) {//random shuffle [1, 2,..., n]
        a[i] = i;
        swap(a[i], a[rand() % i + 1]);
    }
    for (int i = 1; i <= n; i++) {//print the result
        cout << a[i] << (i == n ? '\n' : ' ');
    }
}
```


He compiled and ran his code and then entered $n$ and some special nonnegative integer $x$. He printed the result on paper.

One day later, Prof. Pang forgot his choice for $x$. You are given the result of the code and the integer $n$. Please recover the number $x$ that Prof. Pang had entered. 
## 输入格式

The first line contains a single integer $n$ ($50\le n\le 100000$) -- the number of teams. 

The next line contains $n$ integers -- the result printed by Prof. Pang's code. It is guaranteed that the result is correct, i.e., there exists an integer $x$ ($0\le x\le 2^{64}-1$) that leads to the result. 
## 输出格式

Output the integer $x$ ($0\le x\le 2^{64}-1$) Prof. Pang had entered. If there are multiple possible $x$'s, print any one.
## 样例

### 样例输入 #1
```
50
36 22 24 21 27 50 28 14 25 34 18 43 47
13 30 7 10 48 20 16 29 9 8 15 3 31 12
38 19 49 37 1 46 32 4 44 11 35 6 33 26
5 45 17 39 40 2 23 42 41
```
### 样例输出 #1
```
16659580358178468547
```
## 提示

Note that the second line of the sample input is wrapped to fit in the width of page.


---

---
title: "[EC Final 2020] Prof. Pang's sequence"
layout: "post"
diff: 省选/NOI-
pid: P10822
tag: ['2020', 'O2优化', 'ICPC']
---
# [EC Final 2020] Prof. Pang's sequence
## 题目描述

Prof. Pang is given a fixed sequence $a_1, \ldots, a_n$ and $m$ queries.

Each query is specified by two integers $l$ and $r$ satisfying $1\le l\le r\le n$. For each query, you should answer the number of pairs of integers $(i, j)$ such that $l\le i\le j\le r$ and the number of distinct integers in $a_i, \ldots, a_j$ is odd.
## 输入格式

The first line contains a single integer $n$ ($1\le n\le 5\times 10^5$).

The next line contains $n$ integers $a_1, \ldots, a_n$ ($1\le a_i\le n$ for all $1\le i\le n$) separated by single spaces.

The next line contains a single integer $m$ ($1\le m\le 5\times 10^5$).

Each of the next $m$ lines contains two integers $l$ and $r$ ($1\le l\le r\le n$) separated by a single space denoting a query.
## 输出格式

For each query, output one line containing the answer to that query.
## 样例

### 样例输入 #1
```
5
1 2 3 2 1
5
1 5
2 4
1 3
2 5
4 4
```
### 样例输出 #1
```
10
3
4
6
1
```
### 样例输入 #2
```
5
2 3 5 1 5
5
2 3
1 1
1 3
2 5
2 4
```
### 样例输出 #2
```
2
1
4
6
4
```
### 样例输入 #3
```
10
2 8 5 1 10 5 9 9 3 5
10
6 8
1 2
3 5
5 7
1 7
3 9
4 9
1 4
3 7
2 5
```
### 样例输出 #3
```
4
2
4
4
16
16
12
6
9
6
```


---

---
title: "【MX-S3-T4】「FeOI Round 1」醒餞の鳥 (feat. Feryquitous)"
layout: "post"
diff: 省选/NOI-
pid: P10888
tag: ['梦熊比赛']
---
# 【MX-S3-T4】「FeOI Round 1」醒餞の鳥 (feat. Feryquitous)
## 题目背景

原题链接：<https://oier.team/problems/S3D>。

---

![](bilibili:BV16h411Y7YB)
## 题目描述

有 $n$ 个学生（编号为 $1 \sim n$）参加了一场有 $m$ 门学科（编号为 $1 \sim m$）的考试，现在你知道，学生 $i$ 的第 $j$ 门学科考试的成绩为 $a_{i, j}$。

现在你想要给这些学生排名。由于成绩不形成偏序关系的两个学生实力难以比较，所以你打算设置 $m$ 个实数 $p_{1 \sim m}$（要求满足 $\sum_{i = 1}^m p_i = 1$，且 $p_i \ge 0$）作为权值。定义学生 $i$ 的加权总分为 $\sum_{j = 1}^m a_{i, j} \times p_j$，则按照加权总分降序排名，加权总分相等的则排名并列。

现在这 $m$ 个学科的老师都向你提出了要求，第 $k$ 个学科的老师想让你所设置的 $p$ 满足：

- 以这个 $p$ 得到的排名结果中，不存在一对学生 $(x, y)$（$x \ne y$），使得 $x$ 排名更靠前（并列不算），但是 $a_{x, k} < a_{y, k}$；

因为你想要尽量自由的分配权值，所以你需要对于每个 $k$（$1 \le k \le m$），都**分别**求出：

- $p_k$ 至少要为多少，才能保证**无论如何分配其他 $\boldsymbol{p_i}$ 的权值，都能满足**第 $k$ 个学科的老师的要求？请输出答案对 $998244353$ 取模的结果。
## 输入格式

**本题单个测试点内包含多组数据。**

第一行一个整数 $T$ 表示数据组数。

接下来，对于每组数据，格式如下：

第一行两个整数，分别为 $n, m$。

第二行到第 $n + 1$ 行每行 $m$ 个整数，第 $i + 1$ 行第 $j$ 列的整数表示 $a_{i, j}$。
## 输出格式

对于每组测试数据，输出 $m$ 行，每行一个非负整数，第 $i$ 行表示 $k = i$ 时，$p_k$ 的最小值对 $998244353$ 取模的结果。

即设答案化为最简分式后的形式为 $\frac{a}
{b}$，其中 $a$ 和 $b$ 互质。输出整数 $x$ 使得 $bx \equiv a \pmod{998244353}$ 且 $0 \le x < 998244353$。可以证明这样的整数 $x$ 是唯一的。
## 样例

### 样例输入 #1
```
4
4 4
4 2 4 3
1 3 1 2
1 2 4 2
4 2 4 3
10 2
1 2
4 0
3 1
2 4
0 5
2 3
3 2
1 1
2 2
4 4
4 4
0 0 0 0
0 0 0 0
1 0 1 0
0 0 0 0
2 10
92603107 17358677 20869254 22085089 68529385 51524980 47064864 17692636 31121387 37022044
25517267 69562538 61254114 54886162 15087981 27505611 76082026 59892091 54661294 59475460
```
### 样例输出 #1
```
748683265
249561089
748683265
499122177
399297742
399297742
0
0
0
0
892513752
105730602
366911811
374997189
954012663
897963459
891479524
220357565
706471693
519276178

```
## 提示

**【样例解释】**

对于第一组数据，询问的答案取模之前分别为 $\frac{1}{4}, \frac{3}{4}, \frac{1}{4}, \frac{1}{2}$。

对于第二组数据，询问的答案取模之前分别为 $\frac{4}{5}, \frac{4}{5}$。

对于第三组数据，询问的答案取模之前分别为 $0, 0, 0, 0$。

对于第一组数据的 $k = 2$ 的询问，假设 $p = [0.1, 0.75, 0.1, 0.05]$：

- 第 $1$ 个学生的加权总分是 $4 \times 0.1 + 2 \times 0.75 + 4 \times 0.1 + 3 \times 0.05 = 2.45$；
- 第 $2$ 个学生的加权总分是 $1 \times 0.1 + 3 \times 0.75 + 1 \times 0.1 + 2 \times 0.05 = 2.55$；
- 第 $3$ 个学生的加权总分是 $1 \times 0.1 + 2 \times 0.75 + 4 \times 0.1 + 2 \times 0.05 = 2.1$；
- 第 $4$ 个学生的加权总分是 $4 \times 0.1 + 2 \times 0.75 + 4 \times 0.1 + 3 \times 0.05 = 2.45$；

则你令按加权总分降序排名的学生编号为 $[2, 4, 1, 3]$（当然也可以令其为 $[2, 1, 4, 3]$），且 $a_{2, 2} = 3, a_{4, 2} = 2, a_{1, 2} = 2, a_{3, 2} = 2$，不存在排名更靠后但是第 $2$ 个学科成绩更高的情况。

可以证明，在 $p_2 \ge 0.75$ 的情况下，无论其他 $p_i$ 如何分布，都可以满足要求；而 $p_2 < 0.75$ 的情况下，一定存在一种其他 $p_i$ 的分布使得无法满足要求。

**【数据范围】**

**本题开启捆绑测试。**

设 $\sum nm$ 为单个测试点内所有的 $nm$ 之和。

对于 $100\%$ 的数据，$1 \le T \le 5 \times 10^4$，$ 2 \le n, m \le 10^5$，$ \sum nm \le 2 \times 10^5$，$ 0 \le a_{i, j} \leq 10^8$。

| 子任务编号 | $n$ | $m$ | $\sum nm$ | 特殊性质 | 分数 |
| :-: | :-: | :-: | :-: | :-: | :-: |
| $1$ | $\leq 10$ | $\leq 10$ | $\leq 100$ | 无 | $5$ |
| $2$ | $\leq 100$ | $\leq 100$ | $\leq 10^4$ | 无 | $10$ |
| $3$ | $\leq 5 \times 10^3$ | $\leq 5 \times 10^3$ | $\leq 10^4$ | 无 | $15$ |
| $4$ | $\leq 100$ | $\le 10^5$ | $\le 2 \times 10^5$ | 无 | $20$ |
| $5$ | $\le 10^5$ | $\leq 100$ | $\le 2 \times 10^5$ | 无 | $10$ |
| $6$ | $\le 10^5$ | $\le 10^5$ | $\le 2 \times 10^5$ | $a_{i, j} \in \{0, 1\}$ | $20$ |
| $7$ | $\le 10^5$ | $\le 10^5$ | $\le 2 \times 10^5$ | 无 | $20$ |



---

---
title: "小分图最大匹配"
layout: "post"
diff: 省选/NOI-
pid: P10918
tag: ['O2优化']
---
# 小分图最大匹配
## 题目描述

给你一个二分图，有一些个左部点。还有 $m$ 个右部点，编号为 $0$ 到 $m-1$。

对于每个左部点 $i$，有一个连边参数 $a_i$，表示其向所有满足 $\exist x\in \mathbb{N}, a_ix\equiv j \pmod m$ 的 $j$ 连接了一条边。

现在给出两个长度为 $n$ 的数组 $a_i,c_i$，表示存在 $c_i$ 个左部点的连边参数为 $a_i$，换句话说，这个图总共有 $\sum\limits_{i=1}^n c_i$ 个左部点，使用这样的方式来快速读入左部点的连边参数。

保证 $a_i$ 两两不同。

求这张二分图的最大匹配。

## 输入格式

第一行两个整数 $n$ 和 $m$。

接下来 $n$ 行，每行两个正整数，第 $i$ 行的两个数分别表示 $a_i$ 和 $c_i$ 的值。 
## 输出格式

一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
3 6
1 1
2 2
3 1
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
6 12
12 3
3 1
2 1
6 2
4 2
1 2
```
### 样例输出 #2
```
8
```
### 样例输入 #3
```
11 60
4 1
15 10
3 1
20 3
2 2
30 2
6 4
10 5
5 3
60 5
12 14
```
### 样例输出 #3
```
23
```
## 提示

**本题采用捆绑测试**。

| Subtask | $n\le$ | $m\le$ | 特殊性质 | 分数 |
| :-: | :--------: | :-: | :-: | :-: |
| 0 | $10^3$ | $10^3$ | 无 | 10 |
| 1 | $1$ | $10^{12}$ | 无 | 10 |
| 2 | $2 \times 10^3$ | $2\times 10^7$ | 有 | 20 |
| 3 | $2 \times 10^3$ | $2\times 10^7$ | 无 | 20 |
| 4 | $2 \times 10^3$ | $10^{12}$ | 有 | 20 |
| 5 | $7 \times 10^3$ | $10^{12}$ | 无 | 20 |

对于所有数据，保证 $1\le n \le 7\times10^3, 1\le m \le 10^{12},1\le a_i \le m,0\le c_i \le 10^{12}$

特殊性质 : 保证 $\mu(m)\not=0$。

其中 $\mu$ 指莫比乌斯函数，定义为

$$
\mu(n)=\left\{\begin{array}{ll}
1 & n=1 \\
0 & n \text { 含有平方因子 } \\
(-1)^{k} & k \text { 为 } n \text { 的本质不同质因子个数 }
\end{array}\right.
$$

对于所有数据，保证 $a_i$ 互不相同。


---

---
title: "宇宙射线"
layout: "post"
diff: 省选/NOI-
pid: P10920
tag: ['O2优化']
---
# 宇宙射线
## 题目背景

感谢 @[jason_sun](https://www.luogu.com.cn/user/399762) 加强数据。

宇宙射线天天乱改东西/fn。
## 题目描述

有一个长度为 $n$ 的二进制串 $s$，你需要找到一个最长的长度为偶数的子串，使得它的前半部分和后半部分完全相同。

但是因为宇宙射线攻击了这个串，有一些位置的值变得未知了。

你可以把未知的值视为 $0$ 和 $1$ 的任意一个数，求出在这种情况下这个最长子串的长度。

本题有多组测试。
## 输入格式

第一行一个正整数 $t$，表示测试组数。

接下来 $2t$ 行，每两行表示一组测试数据，每组测试数据第一行一个正整数 $n$，表示字符串的长度，接下来一行一个长度为 $n$ 的字符串 $s$。
## 输出格式

$t$ 行，每行一个非负整数，表示第 $i$ 组测试的答案，由于这个串长一定是偶数，所以你只用输出它的长度除以 $2$ 的结果。
## 样例

### 样例输入 #1
```
2
10
0110011010
6
01?0?0
```
### 样例输出 #1
```
4
3
```
## 提示

**本题采用捆绑测试。**

| $\text{Subtask}$ | 分数 | $n,t$ | 特殊性质 |
| :-----------: | :-----------: | :-----------: | :-----------: |
| $1$ | $10$ | $n\le 10,t=500$ | 无特殊限制 |
| $2$ | $10$ | $n\le1000,t=1$ | 无特殊限制 |
| $3$ | $10$ | $n\le 1000,t=1000$ | $A$ |
| $4$ | $10$ | $n\le 1000,t=1000$ | 无特殊限制 |
| $5$ | $10$ | $n\le 10^4,t=10$ | 无特殊限制 |
| $6$ | $10$ | $n\le 10^4,t=50$ | 无特殊限制 |
| $7$ | $20$ | $n\le 5\times 10^4,t=2$ | 无特殊限制 |
| $8$ | $15$ | $n\le 10^5,t=1$ | 无特殊限制 |
| $9$ | $5$ | $n\le 10^5,t=5$ | 无特殊限制 |

$A$：保证 $s$ 中不存在字符 `?`。

保证字符串只由 `0,1,?` 三种字符组成，$1\le n\le 10^5$。


---

---
title: "异象石"
layout: "post"
diff: 省选/NOI-
pid: P10930
tag: []
---
# 异象石
## 题目描述

Adera 是 Microsoft 应用商店中的一款解谜游戏。

异象石是进入 Adera 中异时空的引导物，在 Adera 的异时空中有一张地图。

这张地图上有 $N$ 个点，有 $N-1$ 条双向边把它们连通起来。

起初地图上没有任何异象石，在接下来的 $M$ 个时刻中，每个时刻会发生以下三种类型的事件之一：

  1. 地图的某个点上出现了异象石（已经出现的不会再次出现）；
  2. 地图某个点上的异象石被摧毁（不会摧毁没有异象石的点）；
  3. 向玩家询问使所有异象石所在的点连通的边集的总长度最小是多少。

请你作为玩家回答这些问题。
## 输入格式

第一行有一个整数 $N$，表示点的个数。

接下来 $N-1$ 行每行三个整数 $x,y,z$，表示点 $x$ 和 $y$ 之间有一条长度为 $z$ 的双向边。

第 $N+1$ 行有一个正整数 $M$。

接下来 $M$ 行每行是一个事件，事件是以下三种格式之一：

  * `+ x` 表示点 $x$ 上出现了异象石
  * `- x` 表示点 $x$ 上的异象石被摧毁
  * `?` 表示询问使当前所有异象石所在的点连通所需的边集的总长度最小是多少。
## 输出格式

对于每个 `?` 事件，输出一个整数表示答案。

## 样例

### 样例输入 #1
```
6
1 2 1
1 3 5
4 1 7
4 5 3
6 4 2
10
+ 3
+ 1
?
+ 6
?
+ 5
?
- 6
- 3
?
```
### 样例输出 #1
```
5
14
17
10
```
## 提示

数据保证，$1 \le N,M \le 10^5$，$1 \le x,y \le N$，$x \neq y$，$1 \le z \le 10^9$。


---

---
title: "导弹防御塔"
layout: "post"
diff: 省选/NOI-
pid: P10936
tag: ['Special Judge']
---
# 导弹防御塔
## 题目描述

Freda 的城堡遭受了 $M$ 个入侵者的攻击！

Freda 控制着 $N$ 座导弹防御塔，每座塔都有足够数量的导弹，但是每次只能发射一枚。

在发射导弹时，导弹需要 $T_1$ 秒才能从防御塔中射出，而在发射导弹后，发射这枚导弹的防御塔需要 $T_2$ 分钟来冷却。

所有导弹都有相同的匀速飞行速度 $V$，并且会沿着距离最短的路径去打击目标。

计算防御塔到目标的距离 $Distance$ 时，你只需要计算水平距离，而忽略导弹飞行的高度。

导弹在空中飞行的时间就是 $Distance/V$ 分钟，导弹到达目标后可以立即将它击毁。

现在，给出 $N$ 座导弹防御塔的坐标，$M$ 个入侵者的坐标，$T_1,T_2$ 和 $V$。

因为 Freda 的小伙伴 Rainbow 就要来拜访城堡了，你需要求出至少多少分钟才能击退所有的入侵者。
## 输入格式

第一行五个正整数 $N,M,T_1,T_2,V$。

接下来 $M$ 行每行两个整数，代表入侵者的坐标。

接下来 $N$ 行每行两个整数，代表防御塔的坐标。
## 输出格式

输出一个实数，表示最少需要多少分钟才能击中所有的入侵者，四舍五入保留六位小数。与标准答案的差距相差不超过 $10^{-5}$ 即认为答案正确。
## 样例

### 样例输入 #1
```
3 3 30 20 1
0 0
0 50
50 0
50 50
0 1000
1000 0
```
### 样例输出 #1
```
91.500000

```
## 提示

数据保证 $1 \le N,M \le 50$，坐标绝对值不超过 $10000$，$T_1,T_2,V$ 为不超过 $2000$ 的正整数。


---

---
title: "Vani和Cl2捉迷藏"
layout: "post"
diff: 省选/NOI-
pid: P10938
tag: []
---
# Vani和Cl2捉迷藏
## 题目描述

Vani 和 cl2 在一片树林里捉迷藏。

这片树林里有 $N$ 座房子，$M$ 条有向道路，组成了一张有向无环图。

树林里的树非常茂密，足以遮挡视线，但是沿着道路望去，却是视野开阔。

如果从房子 $A$ 沿着路走下去能够到达 $B$，那么在 $A$ 和 $B$ 里的人是能够相互望见的。

现在 cl2 要在这 $N$ 座房子里选择 $K$ 座作为藏身点，同时 Vani 也专挑 cl2 作为藏身点的房子进去寻找，为了避免被 Vani 看见，cl2 要求这 $K$ 个藏身点的任意两个之间都没有路径相连。

为了让 Vani 更难找到自己，cl2 想知道最多能选出多少个藏身点。
## 输入格式

输入数据的第一行是两个整数 $N$ 和 $M$。

接下来 $M$ 行，每行两个整数 $x,y$，表示一条从 $x$ 到 $y$ 的有向道路。
## 输出格式

输出一个整数，表示最多能选取的藏身点个数。

## 样例

### 样例输入 #1
```
4 4
1 2
3 2
3 4
4 2
```
### 样例输出 #1
```
2
```
## 提示

- 对于 $20\%$ 的数据，$1\leq N\leq 10$，$1\leq M\leq 20$。
- 对于 $60\%$ 的数据，$1\leq N\leq 100$，$1\leq M\leq 1000$。
- 对于 $100\%$ 的数据，$1\leq N\leq 200$，$1\leq M\leq 30000$，$1\leq x,y\leq N$。


---

---
title: "舞动的夜晚"
layout: "post"
diff: 省选/NOI-
pid: P10940
tag: []
---
# 舞动的夜晚
## 题目描述

$L$ 公司和 $H$ 公司举办了一次联谊晚会。

晚会上，$L$ 公司的 $N$ 位员工和 $H$ 公司的 $M$ 位员工打算进行一场交际舞。

在这些领导中，一些 $L$ 公司的员工和 $H$ 公司的员工之间是互相认识的，这样的认识关系一共有 $T$ 对。

舞会上，每位员工会尝试选择一名 Ta 认识的对方公司的员工作为舞伴，并且每位员工至多跳一支舞。

完成的交际舞的数量越多，晚会的气氛就越热烈。

顾及到晚会的气氛，员工们希望知道，哪些员工之间如果进行了交际舞，就会使整场晚会能够完成的交际舞的最大数量减小。
## 输入格式

第一行三个整数 $N、M、T$。

接下来 $T$ 行每行两个整数 $x、y$，表示 $L$ 公司的员工 $x$ 和 $H$ 公司的员工 $y$ 互相认识。
## 输出格式

第一行一个整数 $cnt$，表示进行了交际舞后会使整场晚会能够完成的交际舞的最大数量减小的员工有多少对。

第二行 $cnt$ 个整数，升序输出这样的一对员工的认识关系的编号（他们的认识关系是在输入数据中读入的第几条认识关系）。

如果 $cnt=0$，输出一个空行。
## 样例

### 样例输入 #1
```
3 3 6
1 1
2 1
2 2
3 1
3 2
3 3
```
### 样例输出 #1
```
3
2 4 5
```
## 提示

数据保证，$1 \le N,M \le 10000$，$1 \le T \le 100000$，$1 \le x \le N$，$1 \le y \le M$。


---

---
title: "Going Home"
layout: "post"
diff: 省选/NOI-
pid: P10943
tag: ['O2优化']
---
# Going Home
## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/dqo3q5sa.png)
## 输入格式

There are one or more test cases in the input. Each case starts with a line giving two integers N and M, where N is the number of rows of the map, and M is the number of columns. The rest of the input will be N lines describing the map. You may assume both N and M are between 2 and 100, inclusive. There will be the same number of 'H's and
'm's on the map; and there will be at most 100 houses. Input will terminate with 0 0 for N and M.
## 输出格式

For each test case, output one line with the single integer, which is the minimum amount, in dollars, you need to pay. 
## 样例

### 样例输入 #1
```
2 2
.m
H.
5 5 
HH..m 
..... 
.....
.....
mm..H
7 8
...H....
...H....
...H.... 
mmmHmmmm 
...H.... 
...H.... 
...H.... 
0 0
```
### 样例输出 #1
```
2
10
28
```
## 题目翻译

# 回家

## 题目描述
在网格地图上有 $n$ 个人和 $n$ 个房子。在每个单位时间里，每个人都可以在相邻的点上水平或垂直移动一个单位步。对于每个人，你需要为他每走一步支付 $1$ 美元的旅行费，直到他进入一所房子。由于每栋房子只能容纳一个人，这项任务很复杂。  
你的任务是计算你需要支付的最低金额，以便将这 $n$ 个人送到那 $n$ 个不同的房子里。输入是场景的地图，`.` 表示空白空间，`H`表示该点上的房子，`m`表示在该点上有一个人。  
你可以把网格地图上的每个点想象成一个相当大的正方形，所以它可以同时容纳 $n$ 个人物；此外，如果一个人在没有进入房子的情况下踩在有房子的网格上，也没关系。

## 输入格式

输入中有一个或多个测试用例。每种情况都以一行给出两个整数 $N$ 和 $M$ 开始，其中 $N$ 是映射的行数，$M$ 是列数。其余的输入将是描述地图的 $N$ 行。你可以假设 $N$ 和 $M$ 都在 $2$ 到 $100$ 之间，包括 $2$ 和 $100$。将有相同数量的 $H$ 和 $m$ 在地图上；最多有 $100$ 栋房子。$N$ 和 $M$ 的输入将以`0 0`终止。

## 输出格式

对于每个测试用例，输出一行带有单个整数的代码，这是您需要支付的最小金额（美元）。

---
翻译提供者：[csyc5586](https://www.luogu.com/user/668156)


---

---
title: "Place the Robots"
layout: "post"
diff: 省选/NOI-
pid: P10945
tag: ['O2优化']
---
# Place the Robots
## 题目描述

Robert is a famous engineer. One day he was given a task by his boss. The background of the task was the following:

Given a map consisting of square blocks. There were three kinds of blocks: Wall, Grass, and Empty. His boss wanted to place as many robots as possible in the map. Each robot held a laser weapon which could shoot to four directions (north, east, south, west) simultaneously. A robot had to stay at the block where it was initially placed all the time and to keep firing all the time. The laser beams certainly could pass the grid of Grass, but could not pass the grid of Wall. A robot could only be placed in an Empty block. Surely the boss would not want to see one robot hurting another. In other words, two robots must not be placed in one line (horizontally or vertically) unless there is a Wall between them.

Now that you are such a smart programmer and one of Robert's best friends, He is asking you to help him solving this problem. That is, given the description of a map, compute the maximum number of robots that can be placed in the map.

## 输入格式

The first line contains an integer T (<= 11) which is the number of test cases.

For each test case, the first line contains two integers m and n (1<= m, n <=50) which are the row and column sizes of the map. Then m lines follow, each contains n characters of '#', '*', or 'o' which represent Wall, Grass, and Empty, respectively.

## 输出格式

For each test case, first output the case number in one line, in the format: "Case :id" where id is the test case number, counting from 1. In the second line just output the maximum number of robots that can be placed in that map.

## 样例

### 样例输入 #1
```
2
4 4
o*** 
*### 
oo#o 
***o 
4 4 
#ooo 
o#oo 
oo#o 
***#
```
### 样例输出 #1
```
Case :1 
3
Case :2 
5
```
## 题目翻译

### 题目描述

罗伯特是一位著名的工程师。一天，他的老板给了他一个任务。任务的背景如下：给定一个方格地图。地图上有三种可以放置的方块：墙方块、草方块和空地。老板希望在地图上可以尽可能多地放置机器人。每个机器人都配备了激光武器，可以同时向四个方向（东南西北，可以理解为上下左右）发射激光。机器人必须待在同一位置（也就是一开始放置的位置）且只能放在空地上不断地发射激光。激光束可以穿过草方块，但不能穿过墙方块。显然，老板不希望看到一个机器人伤害另一个机器人。换句话说，两个机器人不能放置在同一行或同一列上，除非它们之间有一堵墙。作为罗伯特的好朋友和聪明的程序员，他请你帮忙解决这个问题。也就是请你根据给定地图的描述，计算在地图上可以放置的最大机器人数量。

### 输入格式

 第一行包含一个整数 T ,表示测试用例的数量。对于每个测试用例，第一行包含两个整数 m 和 n ，分别表示地图的行数和列数。接下来是 m 行，每行包含 n 个字符，分别是 ‘#’, ‘*’, 或 ‘o’，表示墙方块、草方块和空地。
 
### 输出格式
 
 对于每个测试用例，首先输出一行，格式为：```Case :id```，其中 id 是测试用例编号，从 1 开始计数。1第二行输出在该地图上可以放置的最大机器人数量。
 
### 说明/提示

#### 数据范围
 
$T \leq 11$，$1 \leq m , n \leq 50$


---

---
title: "K-Anonymous Sequence"
layout: "post"
diff: 省选/NOI-
pid: P10966
tag: ['O2优化']
---
# K-Anonymous Sequence
## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/orua22pd.png)
## 输入格式

![](https://cdn.luogu.com.cn/upload/image_hosting/lbo5vs9c.png)
## 输出格式

For each test, output one line containing a single integer-the minimal cost
## 样例

### 样例输入 #1
```
2
7 3
2 2 3 4 4 5 5
6 2
0 3 3 4 8 9
```
### 样例输出 #1
```
3
5
```
## 题目翻译

# K-Anonymous 序列

## 题目描述
各种应用领域中爆炸式增长的网络数据引发了相关个人的隐私问题。最近的研究表明，在发布图形/社交网络数据之前简单地删除节点的身份并不能保证隐私。图本身的结构及其基本形式——节点度，可以揭示个体的身份。  
为了解决这个问题，我们研究了一个特定的图匿名化问题。我们称一个图为$k-anonymous$，如果对于每个节点$v$，图中至少存在$k-l$个与$v$具有相同程度的其他节点。我们感兴趣的是在具有最少图修改操作的图上实现$k-anonymous$。  
我们简化了这个问题。从整个图$G$中选取$n$个节点，并按升序列出它们的度数。我们定义一个序列$k-anonymous$，如果对于每个元素$s$，序列中至少存在$k-1$个等于$s$的其他元素。要让给定的序列$k-anonymous$，你只能做一个操作——减少序列中的一些数字。我们定义了修改的成本，即你修改的所有数字的差值。例如，$k=3$的序列$2,2,3,4,4,5,5$可以修改为$2,2,2,4,4,4,4,4$，满足$3-anonymous$，修改的成本为$|3-2|+|5-4|+|5-4|=3$。  
给出一个按升序排列的数字和$k$的序列，我们想知道在所有调整欧速序列$k-anonymous$的修改中，成本最小的修改。

## 输入格式
输入文件的第一行包含一个整数$T$$（1≤T≤20）$——输入文件中的测试数。每个测试都从包含两个数字$n$$（2≤n≤50000）$的行开始——序列中的数字数量和$k$$（2≤k≤n）$。它后面是$n$个整数的一行，即按升序排列的度数序列。序列中的每个数字$s$都在$[0,5000000]$范围内。


## 输出格式
对于每个测试，输出一行包含一个整数——最小成本。

---
翻译提供者：[csyc5586](https://www.luogu.com/user/668156)


---

---
title: "Cut the Sequence"
layout: "post"
diff: 省选/NOI-
pid: P10977
tag: []
---
# Cut the Sequence
## 题目描述

给定一个长度为 $N$ 的整数序列 $\{a_N\}$，你需要将这个序列切分成若干部分，每一部分都是原序列的一个连续子序列。每部分必须满足部分内的整数之和不超过给定的整数 $M$。你的任务是找到一种切分方式，使得每一部分的最大整数之和最小化。

## 输入格式

输入的第一行包含两个整数 $N$ 和 $M$（$0 < N \leq 100000$，$M$ 是 int 范围内的正整数）。接下来的第二行包含 $N$ 个整数，描述了整数序列。序列中的每个整数都在 $0$ 到 $1000000$ 之间（含 $0$ 和 $1000000$）。

## 输出格式

输出一个整数，表示每一部分的最大整数之和的最小值。如果不存在这样的切分方式，输出 $-1$。
## 样例

### 样例输入 #1
```
8 17
2 2 2 8 1 8 2 1
```
### 样例输出 #1
```
12
```


---

---
title: "任务安排 2"
layout: "post"
diff: 省选/NOI-
pid: P10979
tag: []
---
# 任务安排 2
## 题目背景

本题是 P2365 强化版，是 P5785 弱化版，用于让学生循序渐进地了解斜率优化 DP。
## 题目描述

机器上有 $n$ 个需要处理的任务，它们构成了一个序列。这些任务被标号为 $1$ 到 $n$，因此序列的排列为 $1 , 2 , 3 \cdots n$。这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和。

**注意，同一批任务将在同一时刻完成**。每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。

请确定一个分组方案，使得总费用最小。
## 输入格式

第一行一个整数 $n$。第二行一个整数 $s$。

接下来 $n$ 行，每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间是 $T_i$ 及其费用系数 $C_i$。
## 输出格式

一行，一个整数，表示最小的总费用。
## 样例

### 样例输入 #1
```
5
1
1 3
3 2
4 3
2 3
1 4
```
### 样例输出 #1
```
153
```
## 提示

对于 $100\%$ 数据，$1 \le n \le 3 \times 10^5$，$1 \le s \le 2^8$，$1\le T_i \le 2^8$，$0 \le C_i \le 2^8$。


---

---
title: "[COTS 2020] 辣椒 Sadnice"
layout: "post"
diff: 省选/NOI-
pid: P11025
tag: ['2020', 'Special Judge', 'O2优化', 'COCI（克罗地亚）']
---
# [COTS 2020] 辣椒 Sadnice
## 题目背景

译自 [Izborne Pripreme 2020 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2020/) D1T3。$\texttt{3s,0.5G}$。
## 题目描述

花园里种了辣椒。花园可以被描述为一张 $(N+1)\times (M+1)$ 的网格图，其中辣椒被种在格点上。她还用 $[(N+1)\times (M+1)-1]$ 条绳索连接相邻的格点，使得任意两株辣椒都能通过绳索互相到达。换句话说，绳索构成了这个网格图的生成树上的边。

定义两棵辣椒**连通**，当且仅当它们通过绳索直接或间接相连。

晚上有人要来搞破坏。破坏者会在水平方向或者竖直方向划一刀，将划过的绳索全部切断。切断后，辣椒植株会被分成几个连通块。**破坏者会让连通块的数量尽量多。**

怎么安排绳索，才能使得被切断后连通块的数量最小？
## 输入格式

一行两个正整数 $N,M$。
## 输出格式

输出 $(2N+1)$ 行，每行 $(3M+1)$ 个字符。

其中，第 $(2i-1)$ 行的第 $(3j-2)$ 个字符代表点 $(i,j)$（第 $i$ 行第 $j$ 列的植株），用 `o`（ASCII 111）表示。

对于同一行的两个点 $(i,j),(i,j+1)$，若有边，则用 `--`（ASCII 45）填充它们之间的两个空格；否则不填充。

对于同一列的两个点 $(i,j),(i+1,j)$，若有边，则用 `|`（ASCII 124）填充它们之间的一个空格；否则不填充。

未填充的区域均用空格补齐。不要输出多余的空格和空行。

可参阅样例输出。
## 样例

### 样例输入 #1
```
2 2
```
### 样例输出 #1
```
o--o  o
|     |
o  o--o
|     |
o--o--o
```
### 样例输入 #2
```
2 2
```
### 样例输出 #2
```
o--o--o
|
o  o--o
|     |
o--o--o
```
## 提示


#### 评分方式

若你输出的解是最优解，得该测试点的满分。

否则，按照如下方式计算得分倍数：

$$K=0.75\times \max\left\{\left(\frac{A-1}{B-1}\right)^4,1-\left(1-\frac{1}{(B-A)^2}\right)^6\right\}$$

其中 $A$ 为最优的答案，$B$ 为你构造方案的答案。

你将获得 $K$ 倍测试点得分的分数。子任务得分为子任务内测试点得分最小值。

例如，样例 $1$ 输出得满分。样例 $2$ 输出得 $75\%$ 的分数。

#### 数据范围

对于 $100\%$ 的数据，保证 $1\le N\le M\le 1\, 000$。


| 子任务编号 | $N,M\le $ | 特殊性质 | 得分 |  
| :--: | :--: | :--: | :--: |
| $ 1 $    | $1\,000$ | A |$ 15 $   | 
| $ 2 $    | $1\,000$ | B |$ 15 $   |  
| $ 3 $    | $3$ |  |$ 5 $   |  
| $ 4 $    | $10$ || $ 10 $   |
| $ 5 $    | $100$ | | $ 20 $   |
| $ 6 $    | $1\, 000$ || $ 35 $   |

- 特殊性质 A：$N=M$。
- 特殊性质 B：$2N=M$。



---

---
title: "[COTS 2020] 抗疫 Autoritet"
layout: "post"
diff: 省选/NOI-
pid: P11026
tag: ['2020', 'Special Judge', 'O2优化', 'COCI（克罗地亚）']
---
# [COTS 2020] 抗疫 Autoritet
## 题目背景

译自 [Izborne Pripreme 2020 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2020/) D2T1。$\texttt{2s,0.5G}$。

## 题目描述

有 $N$ 个国家，$M$ 条双向航线连接不同的国家。需要注意的是，两个国家之间可能有多条航线连接。

疫情当下，欲举全球之力共同抗疫，需要将世界联结。定义世界是**联结的**，当且仅当任意两个国家都通过航线直接或间接相连。



我们记 $V=\{1,2,\cdots,N\}$。在一次操作中：

- 任意选择 $u\in V$；
- 令集合 $S$ 为国家 $u$ 通过**恰好一条**航线能够到达的国家的集合；令集合 $T=V\backslash \{u\}\backslash S$。
- $\forall v\in S$，将连接 $u,v$ 的航线删除；$\forall w\in T$，添加连接 $u,w$ 的航线。

可以证明，添加足够多的航线后，一定能够使世界联结。

欲通过最少的操作次数使世界联结。

求出：
- 最少的操作次数 $k$；
- 在最小化操作次数的前提下，不同的操作序列数量。只需要求出对 $(10^9+7)$ 取模后的结果。

定义两个操作序列是不同的，当且仅当存在 $i\in [1,k]$，使得在这两个操作序列中第 $i$ 次选择的国家 $u$ 不同。
## 输入格式


第一行，两个正整数 $N,M$。

接下来 $M$ 行，第 $i$ 行两个正整数 $a_i,b_i$，描述一条航线 $(a_i,b_i)$。

## 输出格式


输出两行，每行一个整数，表示对应的答案。

其中第二问的答案需要对 $(10^9+7)$ 取模。
## 样例

### 样例输入 #1
```
6 6
3 4
1 2
2 3
5 4
4 1
4 6
```
### 样例输出 #1
```
0
1
```
### 样例输入 #2
```
4 2
1 4
2 3
```
### 样例输出 #2
```
2
4
```
### 样例输入 #3
```
8 9
1 4
2 3
6 7
8 5
2 4
7 8
5 6
6 8
4 3
```
### 样例输出 #3
```
1
5
```
## 提示


#### 样例解释

- 样例 $1$ 解释：存在不需要执行任何操作的情况。
- 样例 $2$ 解释：所有的操作序列有 $[1,4],[4,1],[2,3],[3,2]$。

#### 评分方式

如果回答对了第一问，可以获得 $15\%$ 的分数。

如果不打算回答第二问，也要任意输出一个 $\in [0,10^9+7)$ 的整数，否则不保证得分符合预期。


#### 数据范围


对于 $100\%$ 的数据，保证：

- $1\le N,M\le 5\times 10^5$；
- $a_i\neq b_i$。


| 子任务编号 | $N,M\le $  | 得分 |  
| :--: | :--: | :--: |  
| $ 1 $    | $18$ |  $ 5 $   |  
| $ 2 $    | $300$ |$ 9 $   |  
| $ 3 $    | $3\, 000$ |  $ 16 $   |  
| $ 4 $    | $5\times 10^5$ | $ 70 $   |  



---

---
title: "[COTS 2020] 餐厅 Restoran"
layout: "post"
diff: 省选/NOI-
pid: P11027
tag: ['2020', 'Special Judge', 'O2优化', 'COCI（克罗地亚）']
---
# [COTS 2020] 餐厅 Restoran
## 题目背景

译自 [Izborne Pripreme 2020 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2020/) D2T2。$\texttt{2s,0.5G}$。


## 题目描述


苏联餐厅前有 $N$ 个人在排队，按顺序标号 $1\sim N$。

餐厅内只有一种菜，同时也是招牌菜——煎蛋。餐厅内没有厨师，所以食物由客人自己烹饪。

由于设备有限，**同一时刻最多有一个人可以烹饪，同一时刻最多有一个人可以用餐。** 

定义：「用餐总时间」为从第一个人开始准备食物，到最后一个人用完餐，需要的时间。

烹饪和用餐不一定按顺序，先烹饪的客人可以后用餐。

第 $i$ 个人的烹饪时间为 $a_i$，用餐时间为 $b_i$。你需要求出最优情况下，用餐总时间的最小值。



此外，还有 $M$ 个事件：

- $\texttt{DOLAZI a b}$：新来了一位新客人，他的烹饪时间为 $a$，用餐时间为 $b$。设这是第 $i$ 位新来的客人，则标号为 $(N+i)$。
- $\texttt{ODLAZI x}$：第 $x$ 位客人离开队伍。
- $\texttt{POREDAK}$：客人很不耐烦，想要知道最优的策略，使得用餐总时间最短。

对于前两个类型的事件，你需要求出这个事件结束后，用餐总时间的最小值；

对于第三个类型的事件，你需要求出此时最佳的烹饪、用餐顺序。
## 输入格式


第一行，两个正整数 $N,M$。

接下来 $N$ 行，第 $i$ 行两个正整数 $a_i,b_i$。

接下来 $M$ 行，每行描述一个事件。

数据保证事件合法，且每一时刻至少存在一名客人。

## 输出格式


输出 $(M+1)$ 行。

第一行，输出初始时用餐总时间的最小值。

接下来 $M$ 行，对于第 $i$ 行：
- 若第 $i$ 个事件为 $\texttt{DOLAZI}$ 或 $\texttt{ODLAZI}$ ，输出一个整数，表示这个事件结束后，用餐总时间的最小值；
- 否则，设当前有 $k$ 个客人，输出 $2k$ 个整数，描述最优策略：前 $k$ 个整数表示烹饪的顺序，后 $k$ 个整数表示用餐的顺序。
## 样例

### 样例输入 #1
```
2 1
1 3
2 3
POREDAK
```
### 样例输出 #1
```
7
1 2 1 2
```
### 样例输入 #2
```
1 4
4 3
DOLAZI 3 8
DOLAZI 5 2
ODLAZI 1
ODLAZI 3
```
### 样例输出 #2
```
7
14
16
13
11
```
## 提示



#### 数据范围


对于 $100\%$ 的数据，保证：

- $1\le N,M\le 2\times 10^5$；
- $1\le a_i,b_i,a,b\le 10^9$；
- 事件合法，且每一时刻至少存在一名客人；
- **$\texttt{POREDAK}$ 事件最多只有 $\bf 10$ 个。**


| 子任务编号 | $N\le $ | $M\le $ |  特殊性质   | 得分 |  
| :--: | :--: | :--: | :--: | :--: |  
| $ 1 $    | $9$ | $ 1 $    |  A  | $ 5 $   |  
| $ 2 $    | $20$ | $1$   |  A | $ 13 $   |  
| $ 3 $    | $2\times 10^5$ | $1$ | A  | $ 21 $   |  
| $ 4 $    | $2\times 10^5$ | $2\times 10^5$  |  B | $ 29 $   |  
| $ 5 $    | $2\times 10^5$ | $2\times 10^5$  |   | $ 32 $   |  

- 特殊性质 A：只有 $\texttt{POREDAK}$ 事件。
- 特殊性质 B：没有 $\texttt{POREDAK}$ 事件。



---

---
title: "[IOI 2024] 马赛克上色"
layout: "post"
diff: 省选/NOI-
pid: P11053
tag: ['2024', 'IOI', '交互题']
---
# [IOI 2024] 马赛克上色
## 题目背景

提交时请不要引用 `mosaic.h`。

请不要使用 C++14 (GCC 9) 提交。
## 题目描述

Salma 想给墙上的粘土马赛克上色。该马赛克由 $N \times N$ 片正方形瓷砖组成，共有 $N^2$ 片瓷砖；每片瓷砖的尺寸为 $1 \times 1$，都还没有上色。马赛克从上到下每行瓷砖的行编号从 $0$ 到 $N-1$，从左到右每列瓷砖的列编号从 $0$ 到 $N-1$。位于第 $i$ 行第 $j$ 列（$0 \leq i < N$，$0 \leq j < N$）的瓷砖记为 $(i,j)$。每片瓷砖要么涂成白色（记为 $0$），要么涂成黑色（记为 $1$）。

为了给马赛克上色，Salma 首先选取两个长度为 $N$ 的数组 $X$ 和 $Y$，每个数组都由 $0$ 和 $1$ 组成，并且 $X[0] = Y[0]$。她按照数组 $X$ 对最上面的行（第 $0$ 行）的瓷砖进行上色，使得瓷砖 $(0,j)$ 的颜色为 $X[j]$（$0 \leq j < N$）。她按照数组 $Y$ 对最左边的列（第 $0$ 列）的瓷砖进行上色，使得瓷砖 $(i,0)$ 的颜色为 $Y[i]$（$0 \leq i < N$）。

然后她重复以下步骤直至所有瓷砖都上色完成：
* 她找到任意一片**没有上色**的瓷砖 $(i,j)$，其上方相邻的瓷砖 $(i-1, j)$ 和左边相邻的瓷砖 $(i, j-1)$ 都**已经上色**。
* 然后，如果这两片相邻的瓷砖都是白色，她会把瓷砖 $(i,j)$ 涂成黑色；否则，涂成白色。

可以证明，瓷砖最终的颜色不依赖于 Salma 的上色顺序。

Yasmin 对马赛克瓷砖的颜色非常好奇。她向 Salma 提出 $Q$ 个问题，从 $0$ 到 $Q-1$ 编号。在问题 $k$（$0 \leq k < Q$）中，Yasmin 通过以下信息指定马赛克中的一个长方形：
* 最上面的行 $T[k]$ 和最下面的行 $B[k]$（$0 \leq T[k] \leq B[k] < N$）；
* 最左边的列 $L[k]$ 和最右边的列 $R[k]$（$0 \leq L[k] \leq R[k] < N$）。

问题的答案是该长方形中黑色瓷砖的数量。具体来说，Salma 应当找出有多少片瓷砖 $(i,j)$ 满足  $T[k] \leq i \leq B[k]$，$L[k] \leq j \leq R[k]$，且颜色为黑色。

请编写程序回答 Yasmin 的问题。

### 实现细节

你要实现以下函数。

```
std::vector<long long> mosaic(
	std::vector<int> X, std::vector<int> Y,
    std::vector<int> T, std::vector<int> B,
    std::vector<int> L, std::vector<int> R)
```

* $X$，$Y$：长度为 $N$ 的数组，分别描述最上方行和最左边列的瓷砖的颜色。
* $T$，$B$，$L$，$R$：长度为 $Q$ 的数组，分别描述 Yasmin 所提出的问题。
* 该函数应返回一个长度为 $Q$ 的数组 $C$，使得 $C[k]$ 给出问题 $k$（$0 \leq k < Q$）的答案。
* 对每个测试用例，该函数恰好被调用一次。
## 输入格式

评测程序示例读取如下格式的输入：

```
N
X[0]  X[1]  ...  X[N-1]
Y[0]  Y[1]  ...  Y[N-1]
Q
T[0]  B[0]  L[0]  R[0]
T[1]  B[1]  L[1]  R[1]
...
T[Q-1]  B[Q-1]  L[Q-1]  R[Q-1]
```
## 输出格式

评测程序示例按照如下格式打印你的答案：

```
C[0]
C[1]
...
C[S-1]
```

其中 $S$ 是  `mosaic` 所返回的数组 $C$ 的长度。
## 样例

### 样例输入 #1
```
4
1 0 1 0
1 1 0 1
2
0 3 0 3
2 3 0 2

```
### 样例输出 #1
```
7
3

```
## 提示

考虑以下函数调用。

```
mosaic([1, 0, 1, 0], [1, 1, 0, 1], [0, 2], [3, 3], [0, 0], [3, 2])
```

该例子如下图所示。左边的图展示了马赛克中瓷砖的颜色，中间和右边的图分别展示了 Yasmin 的第一个问题和第二个问题中的长方形。

![](https://cdn.luogu.com.cn/upload/image_hosting/dhy83fvl.png "550")

这两个问题的答案（即阴影长方形中 1 的个数）分别是 7 和 3。因此，函数应该返回 $[7, 3]$。

### 约束条件

* $1 \leq N \leq 200\,000$
* $1 \leq Q \leq 200\,000$
* 对所有满足  $0 \leq i < N$ 的 $i$，都有 $X[i] \in \{0, 1\}$，且 $Y[i] \in \{0, 1\}$
* $X[0] = Y[0]$
* 对所有满足 $0 \leq k < Q$ 的 $k$，都有 $0 \leq T[k] \leq B[k] < N$，且 $0 \leq L[k] \leq R[k] < N$

| 子任务 | 分数 | 额外的约束条件 |
| :-----: | :----: | ---------------------- |
| 1       | $5$    | $N \leq 2; Q \leq 10$
| 2       | $7$    | $N \leq 200; Q \leq 200$
| 3       | $7$    | 对所有满足  $0 \leq k < Q$ 的 $k$，都有 $T[k] = B[k] = 0$
| 4       | $10$   | $N \leq 5000$
| 5       | $8$    | 对所有满足 $0 \leq i < N$ 的 $i$，都有 $X[i] = Y[i] = 0$
| 6       | $22$   | 对所有满足 $0 \leq k < Q$ 的 $k$，都有 $T[k] = B[k]$，且 $L[k] = R[k]$
| 7       | $19$   | 对所有满足 $0 \leq k < Q$ 的 $k$，都有 $T[k] = B[k]$ 
| 8       | $22$   | 没有额外的约束条件。


---

---
title: "合并香蕉"
layout: "post"
diff: 省选/NOI-
pid: P11058
tag: ['提交答案', 'Special Judge', 'O2优化']
---
# 合并香蕉
## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/xi3q8vw1.png)
## 题目描述

有 $n$ 条大香蕉，第 $i$ 条大香蕉可简化为一个正整数二元组 $(a_i,k_i)$，其中 $2\le k_i\le 10$。

初始时有 $n$ 堆大香蕉，第 $i$ 堆只包含第 $i$ 条大香蕉。

每次可以选择不同的两堆合并，合并时会损耗香蕉的大小。

具体地，如果第 $i$ 条香蕉**参与了合并**，则其大小 $a_i$ 会变为原来的 $\frac{1}{k_i}$ 倍。

**参与了合并**：合并前在两堆香蕉中的某一堆中。

你想把大香蕉们合为一堆，由于香蕉越大越好，你需要让操作结束后所有的 $a_i$ 之和**越大越好**。

考虑到求出最优解可能会比较困难，你只需要**尽可能接近标准答案**即可，具体参见**评分标准**。

为了防止你乱输出一个数，你还需要**输出方案**，具体参见**输出格式**。
## 输入格式

第一行一个正整数代表 $n$。

接下来 $n$ 行，每行两个正整数代表 $a_i,k_i$。
## 输出格式

输出 $n-1$ 行，每行两个数 $x,y$ 代表合并第 $x$ 堆和第 $y$ 堆。

对于第 $i$ 次合并，我们记新形成的香蕉堆是第 $n+i$ 堆，而原来的两个香蕉堆（第 $x$ 堆、第 $y$ 堆）从此将**被视为不存在** ，所以之后的合并中不允许调用 $x$ 和 $y$，否则你将会爆零。
## 样例

### 样例输入 #1
```
3
1 10
27 3
32 2
```
### 样例输出 #1
```
1 2
4 3
```
## 提示

### 样例解释

该样例输出对应的操作结束后满足 $a=(0.01,3,16)$，对应的 $a_i$ 之和为 $19.01$。

另外，如果输出如下，则操作结束后满足 $a=(0.01,9,8)$，对应的 $a_i$ 之和为 $17.01$，可以获得 $4$ 分。
```
1 3
2 4
```
### 评分标准

对于每个测试点，我们采用如下方式评分：

- 如果你的输出不合法，得 $0$ 分。
- 否则设你输出的方案对应的操作结束后的 $a_i$ 之和为 $f$，标准答案输出的方案对应的操作结束后的 $a_i$ 之和为 $ans$，则你的得分 $s=\lfloor \max\{0,10-\log_{10} \max\{1,\frac{ans-f}{\epsilon}\}\}\rfloor$ 分，其中 $\epsilon=10^{-5}$。

### 数据范围

本题共有 $10$ 个测试点，每个测试点 $10$ 分。

| 测试点编号 | $n=$ | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $3$ | 无 |
| $2$ | $5$ | 无 |
| $3$ | $10$ | 无 |
| $4$ | $20$ | 无 |
| $5$ | $100$ | 无 |
| $6$ | $10^3$ | 无 |
| $7$ | $10^5-3$ | $a_i=1$ 且 $k_i=2$ |
| $8$ | $10^5-2$ | $a_i=1$ |
| $9$ | $10^5-1$ | $k_i=2$ |
| $10$ | $10^5$ | 无 |

对于所有数据，保证 $3\le n\le 10^5$，$1\le a_i\le 10^5$，$2\le k_i\le 10$。


---

---
title: "【MX-X4-T5】「Jason-1」占领高地"
layout: "post"
diff: 省选/NOI-
pid: P11065
tag: ['O2优化', '梦熊比赛']
---
# 【MX-X4-T5】「Jason-1」占领高地
## 题目背景

原题链接：<https://oier.team/problems/X4F>。
## 题目描述

有一张 $n$ 行 $m$ 列的地图，其第 $i$ 行 $j$ 列的位置的**高度**为 $h_{i,j}$ 且**军事化程度**为 $p_{i,j}$，且满足**任意两个四连通相邻的位置高度差的绝对值不超过 $\bm 1$**。  
（两个位置 $(a, b)$、$(c, d)$ 四连通相邻，当且仅当 $\lvert a - c\rvert + \lvert b - d\rvert = 1$。）

你可以选择若干个位置建立补给站。若在位置 $(i,j)$ 建立了补给站，定义其**运输范围**为所有满足 $h_{i,j} - h_{x,y} + p_{i,j} \geq \lvert i - x\rvert + \lvert j - y\rvert$ 的位置 $(x, y)$。每个补给站都可以在其运输范围中任意移动物资的位置。

定义若干个补给站 $(x, y)$ 的安全程度为其中 $h_{x,y}$ 的最小值。

有 $q$ 次询问，每次给出四个整数 $a, b, c, d$，询问：若要建立若干个补给站，以将物资从位置 $(a, b)$ 运输至位置 $(c, d)$，则建立补给站的安全程度最大值是多少？或报告不可能完成运输任务。

**注意：物资可以通过多个补给站间接运输。不一定必须在 $(a, b)$ 和 $(c, d)$ 两点建立补给站。**

**本题数据保证 $\bm{p_{i, j} \le 9}$。**
## 输入格式

第一行，三个正整数 $n,m,q$，表示地图的行数、列数，和询问个数。

接下来 $n$ 行，每行 $m$ 个非负整数，其中第 $i$ 行第 $j$ 列的整数表示高度 $h_{i,j}$。**保证任意两个四连通相邻的位置高度差的绝对值不超过 $\bm 1$**。

接下来 $n$ 行，每行 $m$ 个非负整数，其中第 $i$ 行第 $j$ 列的整数表示军事化程度 $p_{i,j}$。**保证 $\bm{p_{i, j} \le 9}$**。

接下来 $q$ 行，每行四个正整数 $a, b, c, d$，表示询问。
## 输出格式

$q$ 行，第 $i$ 行一个整数，表示第 $i$ 次询问的答案，即能让物资从 $(a,b)$ 运输至 $(c,d)$ 时，最大的安全程度。如果无论建立多少补给站都无法实现运输任务，则认为答案是 $-1$。
## 样例

### 样例输入 #1
```
4 4 6
1 2 3 2
2 3 2 3
3 3 2 2
4 3 2 1
2 1 1 1
0 1 1 0
1 1 0 1
0 0 1 2
1 1 1 2
1 1 2 1
2 2 4 4
2 3 3 1
4 4 2 1
1 4 4 1

```
### 样例输出 #1
```
3
4
3
3
4
3

```
### 样例输入 #2
```
1 3 3
1 1 1
1 0 0
1 1 1 2
1 1 1 3
1 2 1 3

```
### 样例输出 #2
```
1
-1
-1

```
### 样例输入 #3
```
8 8 10
5 6 6 5 6 7 8 9
5 6 6 5 6 6 7 8
4 5 5 4 5 5 6 7
3 4 5 4 5 6 6 7
4 5 5 5 5 6 7 6
5 4 5 5 4 5 6 7
4 3 4 5 4 5 6 6
5 4 4 4 3 4 5 5
0 0 0 0 1 0 2 0
0 0 0 0 0 0 0 0
0 1 0 2 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0
0 0 0 0 0 0 0 0
0 0 0 0 0 0 1 0
6 3 7 7
1 5 2 2
7 7 6 7
4 3 7 7
7 6 8 2
3 2 8 7
1 6 8 6
1 6 7 4
4 5 4 4
5 4 1 1

```
### 样例输出 #3
```
5
5
6
5
5
5
6
5
8
-1

```
## 提示

**【样例解释 #1】**

第一个询问可以在 $(1,3)$ 建立补给站，安全程度为 $3$。

第二个询问可以在 $(4,1)$ 建立补给站，安全程度为 $4$。

第三个询问可以在 $(3,2)$ 建立补给站，安全程度为 $3$。

第四个询问可以在 $(3,2)$ 建立补给站，安全程度为 $3$。

第五个询问可以在 $(4,1)$ 建立补给站，安全程度为 $4$。

第六个询问可以在 $(4,1),(1,3)$ 建立补给站，安全程度为 $3$。

**【样例解释 #2】**

仅有在 $(1,1)$ 建立的补给站可以将物资在 $(1,1)$、$(1,2)$ 间任意移动，在其它位置建立的补给站都将无法移动任何物资。

故仅有询问 $1$ 可以达成目标，只需在 $(1,1)$ 建立补给站，安全程度为 $1$。

**【数据范围】**

**本题采用捆绑测试。**

| 子任务 | $q \le$ | $n,m \le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $20$ | $10$ | A | $23$ |
| 2 | $10^5$ | $300$ | B | $19$ |
| 3 | $10^5$ | $100$ | 无 | $27$ |
| 4 | $2 \times 10^5$ | $300$ | 无 | $31$ |

- 特殊性质 A：$p_{i, j} \le 4$。
- 特殊性质 B：$p_{i, j} = 0$。

对于 $100 \%$ 的数据，$1 \le n,m \le 300$，$0 \le h_{i,j} \le 10^9$，$\bm{0 \le p_{i,j} \le 9}$，$1 \le q \le 2 \times 10^5$，$1 \le a,c \le n$，$1 \le b,d \le m$，$(a,b) \neq (c,d)$，**保证任意两个四连通相邻的位置高度差的绝对值不超过 $\bm 1$**。


---

---
title: "Game King"
layout: "post"
diff: 省选/NOI-
pid: P11073
tag: ['O2优化']
---
# Game King
## 题目描述

你穿越到了游戏王的世界，现在你正在和你的对手——一张 $n$ 个点 $m$ 条边的有向图决斗。

中间忘了。

真正的决斗者，一切都是必然。为了更好的应对面前的决斗，你需要知道有多少个点 $x$ 满足如下条件。

- 对于任意一个点 $y$，均满足 $x$ 能到达 $y$ 或 $y$ 能到达 $x$（我们认为一个点能到达它自己本身）。
## 输入格式

第一行输入两个正整数 $n,m$，分别表示给定有向图的点数与边数。

接下来 $m$ 行每行输入两个正整数 $x,y$，表示一条有向边 $x\to y$。
## 输出格式

输出一行一个整数表示答案，即有多少个点满足所有点均能到达它或被它到达。
## 样例

### 样例输入 #1
```
4 4
1 2
1 3
2 4
3 4
```
### 样例输出 #1
```
2
```
## 提示

### 样例一解释

可以证明，只有点 $1,4$ 满足要求。

由于点 $3$ 无法到达点 $2$ 且无法被点 $2$ 到达，故点 $2,3$ 不满足要求。

### 样例二

见下发文件下的 `gameh2.in` 与 `gameh2.ans`。

该样例约束与测试点 $2$ 一致。

### 样例三

见下发文件下的 `gameh3.in` 与 `gameh3.ans`。

该样例约束与测试点 $3$ 一致。

### 数据范围

本题共有 $10$ 个测试点，测试点不等分，每个测试点的具体分值如下。

|测试点编号|分值|$n=$|$m=$|
|:-:|:-:|:-:|:-:|
|$1\sim 2$|$5$|$10$|$20$|
|$3\sim 4$|$5$|$100$|$10^3$|
|$5\sim 6$|$5$|$10^3$|$10^4$|
|$7\sim 8$|$15$|$5\times 10^4$|$5\times 10^5$|
|$9\sim 10$|$20$|$10^6$|$3\times 10^6$|

对于所有数据，保证 $10\le n\le 10^6$，$20\le m\le 3\times 10^6$。

对于奇数编号测试点，保证给定的图没有**不同点数 $\mathbf{>1}$** 的环。

### 提示

**本题输入输出规模较大，请使用较为快速的输入输出方式。**


---

---
title: "[ROIR 2024] 树根 (Day 1)"
layout: "post"
diff: 省选/NOI-
pid: P11123
tag: ['2024', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2024] 树根 (Day 1)
## 题目背景

翻译自 [ROIR 2024 D1T4](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-day1.pdf)。

给定一棵由 $n$ 个节点构成的树和一个数 $k$。固定树中的某个节点 $s$，并令其为根。

将树的边定向从树根出发。换句话说，将边 $(u, v)$ 定向为 $u \to v$，如果在以 $s$ 为根时，节点 $u$ 是节点 $v$ 的父节点。在这种定向下，每个节点都可以从根到达。

定义节点 $v$ 到节点 $s$ 的距离为从 $s$ 到 $v$ 的最短路径上边的数量。定义节点 $s$ 的可达性为所有节点到节点 $s$ 的距离中的最大值。
## 题目描述

允许在树中增加不超过 $k$ 条额外的有向边。对于树中的每个节点 $s$，确定如果选择节点 $s$ 作为树根，能够达到的最小可达性是多少。

注意，在某些子任务中，只需要输出顶点编号为 $1$ 的答案。
## 输入格式

第一行包含三个整数 $n$，$k$ 和 $t$ （$2 \leq n \leq 2 \times 10^5$，$1 \leq k \leq n - 1$，$n \times k \leq 2 \times 10^5$，$0 \leq t \leq 1$），分别表示树的顶点数量、额外添加的有向边的最大数量限制和一个整数 $t$，如果 $t$ 为 $0$，则只需输出顶点编号为 $1$ 的答案；如果 $t$ 为 $1$，则输出所有顶点的答案。

接下来的 $n - 1$ 行每行包含两个整数 $u_i$ 和 $v_i$ （$1 \leq u_i, v_i \leq n$），表示树的一条边。

保证所给的边构成一棵树。
## 输出格式

如果 $t = 0$，输出一个整数，即选择顶点编号为 $1$ 作为树根，并且增加不超过 $k$ 条额外的有向边时，可以达到的最小可达性。

如果 $t = 1$，输出 $n$ 个数，第 $i$ 个数表示选择顶点 $i$ 作为树根，并且增加不超过 $k$ 条额外的有向边时，可以达到的最小可达性。
## 样例

### 样例输入 #1
```
5 2 1
1 2
1 3
2 4
2 5
```
### 样例输出 #1
```
1 1 2 2 2
```
### 样例输入 #2
```
3 1 0
1 2
2 3
```
### 样例输出 #2
```
1
```
## 提示

下图给出了第一个样例的图片。虚线表示添加的边。对于顶点 $1$ 和 $2$，最小可达性为 $1$；对于顶点 $3$，$4$ 和 $5$，最小可达性为 $2$。

![](https://cdn.luogu.com.cn/upload/image_hosting/ubpdvqtn.png)

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $5$ | $u_i=i,v_i=i+1,t=0$ |
| $2$ | $5$ | $k=1,n\le2000,t=0$ |
| $3$ | $10$ | $k=1,t=0$ |
| $4$ | $5$ | $u_i=i,v_i=i+1$ |
| $5$ | $5$ | $n\le16$ |
| $6$ | $10$ | $n\le50$ |
| $7$ | $10$ | $n\le400$ |
| $8$ | $10$ | $n\le2000$ |
| $9$ | $25$ | $n\times k\le50000$ |
| $10$ | $15$ | 无 |

对于 $100\%$ 的数据，$2 \leq n \leq 2 \times 10^5$，$1 \leq k \leq n - 1$，$n \times k \leq 2 \times 10^5$，$0 \leq t \leq 1$，$1 \leq u_i, v_i \leq n$。


---

---
title: "[ROIR 2024] 二叉树的遍历 (Day 2)"
layout: "post"
diff: 省选/NOI-
pid: P11127
tag: ['2024', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2024] 二叉树的遍历 (Day 2)
## 题目背景

翻译自 [ROIR 2024 D2T4](https://neerc.ifmo.ru/school/archive/2023-2024/ru-olymp-regional-2024-day2.pdf)。

二叉树有三种基本遍历方式：前序遍历（pre-order）、中序遍历（in-order）和后序遍历（post-order）。我们可以将这三种遍历方式进行概括：假设每个节点上记录一个整数 $x$（取值范围为 $-1$ 到 $1$），表示在遍历中输出该节点的时机，具体如下：
- $x = -1$：在遍历其左右子树之前；
- $x = 0$：在遍历其左子树之后，遍历其右子树之前；
- $x = 1$：在遍历其左右子树之后。

因此，如果所有节点的 $x$ 值都是 $-1$，则遍历为前序遍历；如果都是 $0$，则为中序遍历；如果都是 $1$，则为后序遍历。
## 题目描述

考虑一棵有 $n$ 个节点的二叉树，节点编号从 $1$ 到 $n$。树的根节点为 $1$。最初，所有节点上的值都是 $-1$。

你需要处理 $q$ 个操作，操作类型如下：
1. 将节点 $l, l + 1, \dots, r$ 上的值更改为 $x$（$x$ 取值为 $-1$，$0$ 或 $1$）。
2. 查询节点 $i$ 在当前遍历方式中的位置。

需要输出所有第二种类型的操作的结果。
## 输入格式

第一行包含两个整数 $n$ 和 $q$（$1 \leq n, q \leq 100000$）。

接下来 $n$ 行，每行包含两个整数 $L_i$ 和 $R_i$（$0 \leq L_i, R_i \leq n$），分别表示节点 $i$ 的左子树和右子树的编号，若某个子树不存在则为 $0$。

保证 $L_i$ 和 $R_i$ 描述了一个有效的二叉树。

接下来的 $q$ 行中包含操作。每行的第一个整数 $t$（$t \in \{1, 2\}$）表示操作类型。
- 对于第一种类型的操作，后面有三个整数 $l$，$r$ 和 $x$（$1 \leq l \leq r \leq n$，$x$ 为 $-1$，$0$ 或 $1$），表示节点范围和新的值。
- 对于第二种类型的操作，后面有一个整数 $i$（$1 \leq i \leq n$），表示询问其在遍历中的位置的节点编号。
## 输出格式

对于每个第二种类型的操作，输出一个整数，表示对应节点在遍历中的位置。
## 样例

### 样例输入 #1
```
5 5
3 4
0 0
5 2
0 0
0 0
2 2
1 1 3 1
2 5
1 3 3 0
2 3
```
### 样例输出 #1
```
4
1
2
```
## 提示

样例中的树是这样的：

![](https://cdn.luogu.com.cn/upload/image_hosting/keaqqiat.png)

刚开始，所有节点的 $x$ 值都是 $-1$，因此第一次查询时遍历得到的数组为 $[1,3,5,2,4]$，$2$ 在第四个位置。

在将节点 $1,2,3$ 的遍历方式 $x$ 改为 $1$ 后，再次查询时遍历得到的数组为 $[5,2,3,4,1]$，$5$ 在第一个位置。

接着把节点 $3$ 的遍历方式 $x$ 改为 $0$，此时再进行查询，遍历得到的数组为 $[5,3,2,4,1]$，$3$ 在第二个位置。

设 $q_1$ 为操作 $1$ 的数量。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $0$ | $0$ | 同样例 |
|$1$ | $10$ | $n, q \leq 5000$ |
|$2$ | $5$ | $q_1 \leq 10$ |
|$3$ | $10$ | 所有操作一在所有操作二之前 |
|$4$ | $10$ | 所有叶子节点都与根节点距离相同，没有具有一个子节点的节点 |
|$5$ | $10$ | 对于所有操作一，$l = r$ |
|$6$ | $20$ | 对于所有操作一，$x \in \{-1, 1\}$，每个节点最多有一个子节点 |
|$7$ | $10$ | 对于所有操作一，$x \in \{-1, 1\}$ |
|$8$ | $10$ | 每个节点最多有一个子节点 |
|$9$ | $15$ | 无 |

对于 $100\%$ 的数据，$1 \leq n, q \leq 100000$。


---

---
title: "[ROIR 2018] 管道监控 (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P11179
tag: ['2018', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2018] 管道监控 (Day1)
## 题目描述

**译自 ROI 2018 Regional. Day1 T4.** ***[Мониторинг труб](http://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-regional-2018-day1.pdf)***

某输气系统包含 $n$ 个节点，编号分别为 $1\ldots n$，某些节点间有单向管道连接。$1$ 号节点是中央储气设施。

节点系统可用数列 $p_2,$ $p_3,$ $\ldots,$ $p_n$ 来表示。对于 $i\in[\;\!2,n\;\!],$ $p_i$ 号节点会有一条通向 $i$ 号节点的单向管道。已知中央储气设施可以将气体输送到系统中的所有节点。输气系统包含不同种类的管道，用英文小写字母 $\texttt{a}\sim\texttt{z}$ 来表示。$p_i$ 号节点通向 $i$ 号节点的管道的类型为 $c_i$。

有一种特殊的机器人被用来检查管道的质量。我们把「机器人从一个节点沿着一根管道前行到另一个节点，且机器人前进方向与气体方向一致」称作「一次移动」。

机器人会先被放在一个节点中，然后它会进行一次或多次移动，最后被人从输气系统中取出。这被称为「机器人进行了一次执勤」。

每次执勤时都需遵循 $m$ 种「规格」中的其中一种，这些规格的编号分别为 $1\ldots m$。每种规格都用一个由英文小写字母组成的字符串 $st_k$ 来表示。如果在一次执勤中机器人遵循了 $k$ 号规范，则在这次执勤中，机器人移动的次数与 $\mathrm{len}(st_k)$ 相等，并且对于 $j\in[1,\mathrm{len}(st_k)],$ $st_{k\:\!,\;\!j}$ 等于机器人第 $j$ 次经过的管道的类型。

若某次执勤遵循了 $t$ 号规格，则这次的花费为 $w_t$。

请问，要想让所有的管道都至少被检查一次，至少需要花费多少钱，并给出执勤路线的方案。

## 输入格式

第一行：$n,m,t$，$t$ 的含义在【输出格式】中。

接下来 $n-1$ 行：$p_i,$ $c_i$ 。

接下来 $m$ 行：$w_i,$ $st_i$。
## 输出格式

第一行包含一个整数，表示最小花费。若无解请输出 $-1$。

若 $t=0$ 就不用管后续了，若 $t=1$ 且有解则需输出方案。 

输出方案时，在第一行输出最小花费之后，第二行应包含方案中路径的数量 $k$，接下来 $k$ 行，每行包括三个整数 $a_i,$ $b_i,$ $c_i$，依次表示一条执勤路线的起点、终点，以及这次执勤所使用的规格。
## 样例

### 样例输入 #1
```
3 3 0
1 a
2 b
3 a
4 b
2 a
```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
7 3 1
1 a
2 a
3 b
3 b
1 b
6 b
3 aab
5 b
2 ab
```
### 样例输出 #2
```
15
4
1 4 1
2 5 3
1 6 2
6 7 2
```
## 提示

### 样例 2 解释

![kxhEVg.png](https://s2.ax1x.com/2019/03/07/kxhEVg.png)

### 数据范围

对于所有数据，$1 ≤ n ≤ 500,$ $1 ≤ m ≤ 10^5,$ $t=0$ 或 $1,$ $1 ≤ p_i ≤ i-1,$ $1 ≤ w_i ≤ 10^9,$ $\sum \mathrm{len}(st_k) ≤ 10^6$.

|子任务 #|分值|$n≤$|$m≤$|特殊条件|$t$|
|:-:|:-:|:-:|:-:|:-:|:-:|
|1|9|$500$| $10^5$|$\mathrm{len}(st_i)=1$|$t = 0$|
|2|10|$500$| $10^5$|$p_i=i-1$|$t = 0$|
|3|22|$15$| $10^5$||$t = 0$||
|4|20|$500$| $500$|&nbsp;|$t = 0$|
|5|19|$500$| $10^5$||$t = 0$|
|6|20|$500$| $10^5$|&nbsp;|$t = 1$|


---

---
title: "[ROIR 2018] 大数据处理 (Day2)"
layout: "post"
diff: 省选/NOI-
pid: P11183
tag: ['2018', 'ROIR（俄罗斯）']
---
# [ROIR 2018] 大数据处理 (Day2)
## 题目描述

**译自 ROI 2018 Regional. Day2 T4.** ***[Обработка больших данных](http://neerc.ifmo.ru/school/archive/2017-2018/ru-olymp-regional-2018-day2.pdf)***

某实验室正在研发一种能处理大规模数据的新型超级计算机。

这台超算的内存包含 $2^k$ 个存储单元，依次编号为 $0\ldots 2^k-1.$ 用内存段 $[L,R]$ 表示编号 $≥L$ 且 $≤R$ 的所有存储单元，该内存段的长度为 $R-L+1.$

定义：如果内存段 $[L,R]$ 的长度是 $2$ 的整数次幂（不妨假设是 $2^i$），且 $L$ 是 $2^i$ 的整数倍，那么这个内存段是「正确的内存段」。

若 $k=3,$ 则正确的内存段为 $[0,7],$ $[0,3],$ $[4,7],$ $[0,1],$ $[2,3],$ $[4,5],$ $[6,7],$ $[0,0],$ $[1,1],$ $[2,2],$ $[3,3],$ $[4,4],$ $[5,5],$ $[6,6]$ 和 $[7,7].$

现在，每个存储单元所存储的值均为 0. 你需要给每个存储单元赋值。简单起见，我们用游程编码的形式给出每个单元上的值。开头的 $c_1$ 个单元中存储的值为 $v_1,$ 接下来 $c_2$ 个单元中存储的的值为 $v_2,$ 以此类推，最后的 $c_n$ 个单元中存储的值为 $c_n,$ $1≤v_i≤m.$

举个例子，如果 $k = 3,$ $n = 3,$ $m = 2,$ $c = \{1,$ $2,$ $5\},$ $v = \{1,$ $2,$ $1\},$ 那么内存将被赋值为 $[1,$ $2,$ $2,$ $1,$ $1,$ $1,$ $1,$ $1].$

你只有一种方法给单元赋值：$\mathtt{STORE}([l,r],x).$ 该函数表示将内存段 $[l,r]$ 中所有单元全部赋值为 $x.$ 注意，$[l,r]$ 必须是合法的内存段。

试求至少需要多少次操作才能达成要求。
## 输入格式

第一行三个整数 $k,n,m$。  
接下来的 $n$ 行，每行两个整数 $c_i,v_i$。
## 输出格式

输出一行一个整数，表示至少的次数。
## 样例

### 样例输入 #1
```
3 3 2
1 1
2 2
5 1
```
### 样例输出 #1
```
3
```
## 提示

### 样例解释

目标：$[1, 2, 2, 1, 1, 1, 1, 1]$
- $\mathtt{STORE}([0, 7], 1),$ 得到 $[1, 1, 1, 1, 1, 1, 1, 1];$
- $\mathtt{STORE}([1, 1], 2),$ 得到 $[1, 2, 1, 1, 1, 1, 1, 1];$
- $\mathtt{STORE}([2, 2], 2),$ 得到 $[1, 2, 2, 1, 1, 1, 1, 1].$

### 数据范围

$0 ≤ k ≤ 30,$ $1 ≤ n ≤ 10^5,$ $1 ≤ m ≤ 10^9.$

|子任务编号|分值|$k\le $|$k\le$|$m\le$|
|:-:|:-:|:-:|:-:|:-:|
|1|15|$3$|$8$|&nbsp;$8$&nbsp;|
|2|&nbsp;15&nbsp;|$19$| |$10$|
|3|15| | |$10$|
|4|10| | |$50$|
|5|15|$19$| | |
|6|30| | | |


---

---
title: "[COTS 2021] 疫苗接种 Cijepise"
layout: "post"
diff: 省选/NOI-
pid: P11195
tag: ['2021', 'O2优化', 'COCI（克罗地亚）']
---
# [COTS 2021] 疫苗接种 Cijepise
## 题目背景

译自 [Izborne Pripreme 2021 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2021/) D2T1。$\texttt{5s,1G}$。
## 题目描述


给定以 $1$ 为根的有 $N$ 个节点的有根树，记 $i$ 号点的点权为 $a_i$。

定义一次操作为：

- 初始化 $u$ 为树根。
	1. 设 $u$ 儿子中点权最大的点为 $v$（若有多个，则**等概率随机选取一个**）。令 $a_u\gets a_v$，$a_v\gets 0$。
	2. 若 $v$ 为叶子，则删去 $v$，终止这个过程。否则令 $u\gets v$，回到 1。

![](https://cdn.luogu.com.cn/upload/image_hosting/u6c8gliu.png)


定义 $f(v)$ 为：**在最坏情况下**，欲让 $a_v$ 尽可能快地（也就是使用尽量少的操作次数）出现在树根上，至少需要更改多少个点的点权（可以不更改）。

换句话说，我们定义在最坏情况下，$v$ 需要操作 $k$ 次到达树根。显然树的形态固定时，不同的点权会使得 $k$ 取不同的值，且 $k$ 存在一个下界。你需要修改若干个点的点权，使得 $k$ 取到下界，并最小化修改的数量。

点权可以被改为 $[0,2\times 10^9]$ 内的任意整数。


$Q$ 次询问给定 $v$，回答 $f(v)$。
## 输入格式


第一行，一个正整数 $N$。

第二行，$N$ 个正整数 $a_i$。

接下来 $(N-1)$ 行，每行两个正整数 $u,v$，描述一条树边 $(u,v)$。

接下来一行，一个正整数 $Q$。

接下来 $Q$ 行，每行一个正整数 $v$，表示询问 $f(v)$。

## 输出格式


输出 $Q$ 行，表示每个询问的答案。
## 样例

### 样例输入 #1
```
3
1 2 3
1 2
1 3
3
1
2
3
```
### 样例输出 #1
```
0
1
0
```
### 样例输入 #2
```
7
45 13 19 3 81 27 77
1 2
1 3
1 4
3 5
3 6
4 7
3
5
6
7
```
### 样例输出 #2
```
0
1
1
```
### 样例输入 #3
```
8
23 4 9 7 11 4 1 18
2 1
3 2
4 2
5 2
6 3
7 4
8 1
3
2
3
7
```
### 样例输出 #3
```
1
2
3
```
## 提示


对于 $100\%$ 的数据，保证 $1\le Q\le N\le 1\times 10^5$，$1\le a_i\le 10^9$，$1\le v\le N$，给出的是一棵树。

| 子任务编号 | $N\le $ |  特殊性质   | 得分 |  
| :--: | :--: | :--: | :--: |  
| $ 1 $    | $ 12 $    |  无  | $ 10 $   |  
| $ 2 $    | $ 300 $   |  无 | $ 11 $   |  
| $ 3 $    | $ 3\,000 $ | 有  | $ 12 $   |  
| $ 4 $    | $ 3\,000 $  |  无 | $ 13 $   |  
| $ 5 $    | $ 100\,000 $  |   有 | $ 20 $   |  
| $ 6 $    | $ 100\,000 $  |   无 | $ 34 $   |  

特殊性质：$Q\le 1$。


---

---
title: "【MX-S4-T4】「yyOI R2」youyou 的三进制数"
layout: "post"
diff: 省选/NOI-
pid: P11220
tag: ['O2优化', '梦熊比赛']
---
# 【MX-S4-T4】「yyOI R2」youyou 的三进制数
## 题目背景

原题链接：<https://oier.team/problems/S4D>。
## 题目描述

现在有 $0 \sim n$ 共 $n + 1$ 个数。
定义 $(x)_{3}$ 表示十进制数 $x$ 的三进制形式。**如果没有特别强调，那么这些数均为十进制形式。**

youyou 想构造一个序列长度为 $p$（$p \ge 1$）的非负整数序列 $a$。使之满足：

- $a_i \in [0,n]$。
- 不存在 $i,j$（$1 \le i <j \le p$），使得 $a_i = a_j$。
- 对于任意 $1 \le i < n$，$a_i$ 与 $a_{i+1}$ 至少满足以下四个条件中的一个：
  1. $(a_i)_3$ 去掉最后一位，恰好等于 $(a_{i+1})_3$（若只有一位，则去掉后的数字为 $0$）。
  2. 在 $(a_i)_3$ 末尾添上某一位 $t(0 \le t \le 2)$，恰好等于 $(a_{i+1})_3$（若 $a_i = 0$，则添加后舍去前置 $0$）。
  3. $a_i \le w$， $(a_i)_3$ 的末尾不是 $0$，且将末尾的一位数字移到开头与 $(a_{i + 1})_3$ 相等。
  4. 当 $(a_i)_3$ 长度 $\ge 2$，且 $(a_i)_3$ 次高位非零时，将 $(a_i)_3$ 开头的一位数字移到末尾，形成的数的十进制值 $\le w$，且恰好等于 $(a_{i+1})_3$。

这样的序列 $a$ 被称为“完美的”。

youyou 认为，如果十进制三元组 $(x,y,z)$ 是好的，必须满足以下条件：

- $0 \le x,y,z \le n$，$x \neq y$。
- 存在至少一个”完美的“序列 $b$，使得十进制下有 $b_1=x$，$b_s = y$。其中 $s$ 为序列长度。
- 存在至少一个”完美的”序列 $c$，使得十进制下有 $c_1=z$。同时，对于上述**任意的** $b$，均有**恰好**一对 $(i, j)$，满足 $1 \le i \le |b|$，$1 \le j \le |c|$，使得 $b_i = c_j$。

对于每一个 $0 \le z \le n$，求能构成“好的”三元组 $(x,y,z)$ 的有序对 $(x,y)$ 的个数。
## 输入格式

仅一行，为一个正整数 $n$ 和一个非负整数 $w$，其含义在题目描述中给出。
## 输出格式

共 $n + 1$ 行，其中第 $i + 1$ 行一个数表示当 $z = i$ 时，能构成“好的”三元组 $(x,y,z)$ 的有序对 $(x,y)$ 的个数。
## 样例

### 样例输入 #1
```
4 3
```
### 样例输出 #1
```
20
20
20
20
20
```
## 提示

**【样例解释 #1】**

一共有 $5$ 个数，用三进制表示分别为 $0,1,2,10,11$。

当 $z = 0,1,2,3,4$ 时，全部 $(x,y)(x \neq y)$ 数对均满足题意。

下面给出三元组 $(2,3,1)$ 是“好的”的证明。

当 $x=2,y=3,z=1$ 时，序列 $b$ 可以为 $\{2,0,1,3\}$。

其中 $b_1,b_2$ 满足条件 $1$，$b_2,b_3$ 满足条件 $2$，$b_3,b_4$ 满足条件 $2$。

可以证明只有这一个序列 $b$ 满足题意。因此，存在 $c = \{1\}$，使得 $B \cap C = \{1\}$。所以 $(2,3,1)$ 是“好的”三元组。

**【样例 #2】**

见附件中的 ```ternary/ternary2.in``` 与 ```ternary/ternary2.ans```。

该组样例满足测试点 $4\sim 6$ 的约束条件。

**【样例 #3】**

见附件中的 ```ternary/ternary3.in``` 与 ```ternary/ternary3.ans```。

该组样例满足测试点 $7\sim 10$ 的约束条件。

**【样例 #4】**

见附件中的 ```ternary/ternary4.in``` 与 ```ternary/ternary4.ans```。

该组样例满足测试点 $13\sim 15$ 的约束条件。

**【样例 #5】**

见附件中的 ```ternary/ternary5.in``` 与 ```ternary/ternary5.ans```。

该组样例满足测试点 $20\sim 25$ 的约束条件。

**【数据范围】**

本题共 $25$ 个测试点，每个 $4$ 分。

| 测试点编号 | $n$ | $w$ | 特殊性质
| :-----------: | :-----------: | :-----------: | :-----------: | 
| $1 \sim 3$ | $\le 18$ | $\le 18$ | 无
| $4 \sim 6$ | $\le 242$ | $\le 242$ |  无
| $7 \sim 10$ | $\le 6560$ | $\le6560$ |  无
| $11\sim12$ | $\le 10^5$ | $\le 10^5$ |  无
| $13\sim15$ | $\le 3 \times 10^5$ | $\le 10^5$ | 有 |
| $16\sim 17$ | $\le 3 \times 10^5$ | $=0$ | 无 |
| $18\sim 19$ | $\le 3 \times 10^5$ | $=n$ |  无 |
| $20\sim25$ | $\le 3 \times 10^5$ | $\le 3 \times 10^5$ |  无 |

特殊性质：$w \ge 10^4$。

对于全部数据，保证：$1\le n \le 3 \times 10^5$，$0 \le w \le n$。



---

---
title: "[GDKOI2023 普及组] 置换"
layout: "post"
diff: 省选/NOI-
pid: P11256
tag: ['2023', '广东', 'O2优化']
---
# [GDKOI2023 普及组] 置换
## 题目描述

Moon 最近在玩一款名为 Shadowverse 的卡牌游戏，在非常有趣的游戏过程中，Moon 想到这样一个关于洗牌的问题。假设当前牌堆中有 $n$ 张牌，第 $i$ 张牌的标号为 $i$，我们定义一种洗牌方式是一个排列 $X=\{x_1, x_2, ..., x_n\}$, 也就是把牌堆中第 $i$ 张位置的牌变成第 $x_i$ 张。那么假设现在 Moon 按照 $X$ 的洗牌方式洗了 $k$ 次牌，不妨设最终得到了一个排列 $Y =\{y_1, y_2, ..., y_n\}$，$y_i$ 表示洗完牌后第 $i$ 张牌的标号。Moon 希望你可以帮助他算出有多少合法的洗牌方式 $X$，满足洗了 $K$ 次后变成排列 $Y$ ，由于答案可能很大，所以你只需要输出对 $998244353$ 取模的答案即可。

形式化而言，考虑对于排列 $P=\{p_1, p_2, ..., p_n\}$ 和排列 $Q=\{q_1, q_2, ..., q_n\}$, 定义这两个排列的乘积:

$$ P \times Q = \{q_{p1} , q_{p2} , ..., q_{pn} \}$$

而排列 $X$ 的 $k$ 次幂 $X^k$ 为 $k$ 个排列 $X$ 的乘积，现在考虑给定排列 $Y$ 和正整数 $k$, 求满足方程 $X^k = Y$ 的排列 $X$ 的数量，对 $998244353$ 取模。
## 输入格式

第一行是一个整数 $T$ 表示测试数据组数。

每组数据包括两行，第一行两个正整数 $n,k$，分别表示排列 $X$ 和 $Y$ 的长度、洗了 $k$ 次牌。

第二行是 $n$ 个 $1$ 到 $n$ 内互不相同的正整数 $\{y_1, y_2, ..., y_n\}$，表示排列 $Y$ 。
## 输出格式

$T$ 行，每行一个整数, 表示合法的洗牌方式的数量，对 $998244353$ 取模。
## 样例

### 样例输入 #1
```
1
5 6
2 1 4 3 5
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
见/example/permutation/下的
permutation1.in
```
### 样例输出 #2
```
见/example/permutation/下的
permutation1.out
```
## 提示

### 样例解释

样例中，$X=[3,4,2,1,5]$ 或者 $[4,3,1,2,5]$, 共两个合法排列。

### 数据范围

对于所有的数据，有 $1 \le n \le 3000, 1 \le k \le 10^6, 1 \le T \le 10$；

对于 $20\%$ 的数据，有 $1 \le n, k \le 8$；

对于另外 $10\%$ 的数据，仅保证 $1 \le n \le 8$；

对于另外 $30\%$ 的数据，仅保证 $1 \le n \le 50$。


---

---
title: "【MX-S5-T3】IMAWANOKIWA (Construction ver.)"
layout: "post"
diff: 省选/NOI-
pid: P11269
tag: ['Special Judge', 'O2优化', '梦熊比赛']
---
# 【MX-S5-T3】IMAWANOKIWA (Construction ver.)
## 题目背景

原题链接：<https://oier.team/problems/S5C>。

---

[IMAWANOKIWA - いよわ / 初音ミク](https://www.bilibili.com/video/BV1iE411Y7bf)

> あなたの未来が見たかった。
## 题目描述

给你一个初始长度为 $n$，**只包含** $\boldsymbol{0, 1, 2}$ 的序列 $a_{1 \sim n}$，你可以执行以下操作：

- 选择相邻的两个位置 $j$ 和 $j + 1$，删去 $a_j, a_{j + 1}$，并在原位置插入 $\mathrm{popc}(a_j + a_{j + 1})$，后半部分序列因此向前移动一位。其中，$\mathrm{popc}(x)$ 表示 $x$ 在二进制表示下 $1$ 的个数。

显然每次操作后序列长度都会减少 $1$，所以执行 $n - 1$ 次操作后，这个序列会恰好剩下一个数。

记在所有可能的 $n-1$ 次操作之后剩下的数的最小值为 $t$，定义一个好的操作序列 $p$ 为一个长度为 $n - 1$ 的正整数序列，其中 $p_i$ 表示第 $i$ 次操作所选择的 $j$（显然 $1 \le p_i \le n - i$），且满足按照这个操作序列操作之后剩下的数为 $t$，你需要求出 $t$ 与**字典序最小**的好的操作序列。

**如果你不会求出字典序最小的好的操作序列也可以获得部分分数**，详见【评分方式】。

为了避免输出量过大，你只需要输出字典序最小的好的操作序列按照某种哈希方式得到的哈希值即可，详见【输出格式】。
## 输入格式

**本题有多组测试数据。**

第一行，一个正整数 $T$，表示数据组数。接下来，对于每组数据：
- 仅一行，一个长度为 $n$ 的字符串，其中第 $i$ 个字符表示 $a_i$。
## 输出格式

对于每组测试数据：
- 输出一行，两个自然数 $t, \mathrm{Hash}(p')$，其中
  - 第一个数表示剩下的数的最小值；
  - 第二个数表示字典序最小的好的操作序列 $p'$ 的哈希值 $\mathrm{Hash}(p')$，定义见下。
  - 如果你输出的**第二个数不正确，也可以获得部分分数**，本题将使用**自定义校验器**做到这一点，详见【评分方式】。

> 令 $B = 13331$，$M = 2^{64}$，我们定义一个正整数序列 $c_{1 \sim l}$ 的哈希值 $\mathrm{Hash}(c)$ 为 $\sum_{i = 1}^l B^{l - i}c_i$ 对 $M$ 取模的结果。
>
> 提示：代码实现时可以使用 C++ 的 `unsigned long long` 类型的自然溢出来实现对 $2^{64}$ 取模的效果。
## 样例

### 样例输入 #1
```
7
110121
120202
1202
1121212
000
010101110
0112210112

```
### 样例输出 #1
```
1 31589928355420248
1 31587559229276557
2 177728893
2 15233797274127957404
0 13332
1 4098728445451629840
1 892964726593242284

```
## 提示

**【样例解释 #1】**

对于第一组数据，字典序最小的好的操作序列 $p$ 为 $[1, 3, 2, 1, 1]$，按照该操作序列操作时，$a$ 序列的变化过程如下：

$$
[1, 1, 0, 1, 2, 1]\\
[1, 0, 1, 2, 1]\\
[1, 0, 2, 1]\\
[1, 1, 1]\\
[1, 1]\\
[1]
$$

所以你应输出的哈希值为 $\mathrm{Hash}([1, 3, 2, 1, 1]) = (1 \times 13331^4 + 3 \times 13331^3 + 2 \times 13331^2 + 1 \times 13331^1 + 1 \times 13331^0) \bmod 2^{64} = 31589928355420248$。

对于第二组数据，字典序最小的好的操作序列 $p$ 为 $[1, 2, 2, 1, 1]$，按照该操作序列操作时，$a$ 序列的变化过程如下：

$$
[1, 2, 0, 2, 0, 2]\\
[2, 0, 2, 0, 2]\\
[2, 1, 0, 2]\\
[2, 1, 2]\\
[2, 2]\\
[1]
$$

**【样例 #2】**

见附件中的 `popc/popc2.in` 与 `popc/popc2.ans`。

该组样例共有十组测试数据，所有测试数据均满足 $n = 10^5$，其中测试数据 $1 \sim 5$ 满足序列 $a$ 中不存在 $0$，$6 \sim 10$ 满足序列 $a$ 中不存在 $1$。

**【样例 #3】**

见附件中的 `popc/popc3.in` 与 `popc/popc3.ans`。

该组样例共有四十组测试数据，其中测试数据 $1 \sim 10$ 满足 $n = 300$，$11 \sim 20$ 满足 $n = 3000$，$21 \sim 30$ 满足 $n = 3 \times 10^4$，$31 \sim 40$ 满足 $n = 10^5$。

**【评分方式】**

本题将使用**自定义校验器**计算你获得的部分分数。

对于一个测试点，如果你存在数据输出的最小值不正确，那么无法获得该测试点的分数。

对于一个测试点，如果你每组数据输出的最小值正确，但是存在数据求出的字典序最小的好的操作序列的哈希值不正确，那么可以获得该测试点 $25\%$ 的分数（即 $1$ 分，见【数据范围】）。**注意你仍需输出任意一个 $\boldsymbol{[0, 2^{64})}$ 内的整数表示你的方案的哈希值。**

对于一个测试点，如果你每组数据输出的最小值正确，且求出的字典序最小的好的操作序列的哈希值正确，那么可以获得该测试点的全部分数。

**【数据范围】**

对于所有测试数据，保证：$1 \le T \le 200$，$2 \le n \le 10^5$，序列 $a$ **只包含** $\boldsymbol{0, 1, 2}$。

| 测试点编号 | $T\le$ | $n\le$ | 特殊性质 |
| :-: | :-: | :-: | :-: |
| $1 \sim 3$ | $10$ | $10$ | 无 |
| $4 \sim 6$ | $10$ | $300$ | 无 |
| $7 \sim 9$ | $10$ | $3000$ | 无 |
| $10 \sim 12$ | $10$ | $3 \times 10^4$ | 无 |
| $13 \sim 15$ | $10$ | $10^5$ | 序列 $a$ 中不存在 $0$ |
| $16 \sim 19$ | $10$ | $10^5$ | 序列 $a$ 中不存在 $1$ |
| $20 \sim 21$ | $10$ | $10^5$ | 无 |
| $22 \sim 23$ | $50$ | $10^5$ | 无 |
| $24 \sim 25$ | $200$ | $10^5$ | 无 |


---

---
title: "[NOISG 2021 Finals] Tiles"
layout: "post"
diff: 省选/NOI-
pid: P11302
tag: ['2021', 'NOISG（新加坡）']
---
# [NOISG 2021 Finals] Tiles
## 题目背景

Eustace the Sheep 刚搬进新家，决定翻新他的浴室，因为他实在受不了它单调的内部装饰。目前，浴室的地板是一个 $3 \times N$ 的黑白方格网格。

他有大量相同的 $1 \times 2$ 长方形瓷砖。为了保持浴室的美观，瓷砖可以旋转，但必须平行于墙壁摆放。此外，粘贴瓷砖的胶水不能涂在黑色方格上，因此瓷砖只能放在白色方格上。

## 题目描述

Eustace 想知道，在从第 $a$ 列到第 $b$ 列的区域中，可以形成多少种不同的瓷砖铺设方案（可以不铺瓷砖）。如果两种方案中，某两个方格是否共用一块瓷砖不同，则认为两种方案不同。

在计算铺设方案的同时，Eustace 注意到由于霉菌等问题，部分方格可能会变色（从黑变白，或从白变黑）。

请帮助 Eustace 在不断变化的地板颜色中回答以下问题：
1. 翻转某个方格的颜色。
2. 查询特定区域内可能的瓷砖铺设方案数。

输出结果需要对 $10^9 + 7$ 取模。
## 输入格式

- 第一行包含两个整数 $N$ 和 $Q$，表示浴室地板的列数以及查询和更新操作的总数。
- 接下来 $3$ 行，每行包含一个长度为 $N$ 的字符串，仅由 `.` 和 `x` 组成：
  - `.` 表示白色方格。
  - `x` 表示黑色方格。
- 接下来的 $Q$ 行中，每行有两种格式之一：
  - `1 x y`：表示翻转第 $x$ 行第 $y$ 列的方格颜色。
  - `2 a b`：查询从第 $a$ 列到第 $b$ 列可能的铺设方案数。
## 输出格式

对于每个查询操作（格式为 `2 a b`），输出一个整数表示方案数对 $10^9 + 7$ 取模后的结果。
## 样例

### 样例输入 #1
```
4 5
.x.x
xx..
...x
2 1 4
2 3 3
1 2 3
2 1 4
2 3 3
```
### 样例输出 #1
```
11
3
3
1
```
### 样例输入 #2
```
2 1
..
..
xx
2 1 2
```
### 样例输出 #2
```
7
```
### 样例输入 #3
```
14 2
..............
..............
..............
2 2 11
2 1 14
```
### 样例输出 #3
```
47177097
254767228
```
## 提示

【样例解释】

- 对于样例 $1$，在第一次查询时，可以形成 $11$ 种铺设方案。  
- 在更新操作后，某些区域的方格颜色发生变化，导致后续查询结果也发生改变。

【数据范围】

- $1 \leq N, Q \leq 30000$
- $1 \leq x \leq 3$
- $1 \leq y \leq N$
- $1 \leq a \leq b \leq N$

| 子任务编号 | 分值 | 额外限制条件                |
| :--------: | :--: | :------------------------: |
| $1$        | $17$ | $1 \leq N, Q \leq 8$      |
| $2$        | $23$ | 不存在黑色方格            |
| $3$        | $26$ | $1 \leq N, Q \leq 7000$   |
| $4$        | $34$ | 无额外限制                |


---

---
title: "[NOISG 2020 Finals] Discharging"
layout: "post"
diff: 省选/NOI-
pid: P11333
tag: ['2020', 'NOISG（新加坡）']
---
# [NOISG 2020 Finals] Discharging
## 题目背景

为了成为最强的电力供应者，Pichuu 这只电鼠开启了一项新业务：使用他最爱的技能 Discharge 为顾客充电。由于业务的高效，Pichuu 每天都有许多顾客排队等待充电。
## 题目描述

在某一天，Pichuu 有 $N$ 名顾客等待充电。Pichuu 可以同时为多部手机充电，每部手机的充电功率相同且恒定。然而，不同型号的手机电池容量不同，因此完全充满所需的时间也不同。第 $i$ 部手机需要 $T_i$ 分钟才能完全充满。

Pichuu 不会停止充电，直到所有手机都充满电。为了避免顾客等待过久，Pichuu 可以将顾客分成若干连续的组，然后按顺序为每组充电。每组中的顾客必须等待前面的组完成充电后，才能开始充电。

对于第 $k$ 组，组内充电所需的时间为该组中 $T_i$ 的最大值（记为 $M_k$）。第 $i$ 名顾客的总等待时间 $W_i$ 是他所在组及其之前所有组的充电时间之和：

$$
W_i = \sum_{n=1}^{G_i} M_n
$$

其中，$G_i$ 表示第 $i$ 名顾客所属的组编号。

Pichuu 希望通过合理分组最小化顾客的总等待时间。你的任务是帮助 Pichuu 计算最小的总等待时间。
## 输入格式

- 第一行包含一个整数 $N$，表示顾客数量。
- 第二行包含 $N$ 个整数，第 $i$ 个整数表示第 $i$ 部手机完全充电所需的时间 $T_i$。
## 输出格式

- 输出一个整数，表示最小的总等待时间。
## 样例

### 样例输入 #1
```
5
1 3 2 6 3
```
### 样例输出 #1
```
27
```
### 样例输入 #2
```
7
1 1 2 2 2 2 2
```
### 样例输出 #2
```
14
```
## 提示

【样例解释】

对于样例 #1：
- 最优分组为 $(1, 3, 2)$ 和 $(6, 3)$。两组的充电时间分别为 $3$ 和 $6$。  
- 第一组的等待时间为 $3$（每名顾客），第二组的等待时间为 $3 + 6 = 9$（每名顾客）。  
- 总等待时间为 $3 + 3 + 3 + 9 + 9 = 27$。

对于样例 #2：
- 最优分组为一个整体，等待时间为 $2$（每名顾客）。  
- 总等待时间为 $2 + 2 + 2 + 2 + 2 + 2 + 2 = 14$。

【数据范围】

- $1 \leq N \leq 10^6$
- $1 \leq T_i \leq 10^9$

| 子任务编号 | 分值 | 限制条件                     |
|:---:|:---:|:---:|
| $1$ | $9$  | $1 \leq N \leq 3$              |
| $2$ | $13$ | $1 \leq N \leq 1500$ 且 $T_i$ 非递减。 |
| $3$ | $25$ | $T_i$ 非递减。                  |
| $4$ | $11$ | $T_i$ 非递增。                  |
| $5$ | $14$ | $1 \leq N \leq 1500$           |
| $6$ | $28$ | 无额外限制。                    |


---

---
title: "[NOISG 2024 Finals] Coin"
layout: "post"
diff: 省选/NOI-
pid: P11352
tag: ['2024', 'NOISG（新加坡）']
---
# [NOISG 2024 Finals] Coin
## 题目描述

Benson 有 $n$ 枚不同重量的硬币和一个天平。每次将硬币 $x$ 和 $y$ 放在天平上，可以知道它们的相对重量，即 $x$ 是否比 $y$ 更重。

硬币 $x$ 的排名（rank）定义为不比它更重的硬币数量（包括自身）。例如，最轻的硬币的排名是 $1$，次轻的是 $2$，最重的是 $n$。

对于每个硬币，当且仅当基于已有的称量结果可以唯一确定其排名时，称其排名被“确定”（determined）。

你的任务是帮助 Benson 找出每个硬币首次确定排名的称量序号，或者判断它的排名永远无法确定。
## 输入格式

- 第一行包含两个用空格分隔的整数 $n$ 和 $m$，表示硬币的数量和称量的次数。
- 接下来的 $m$ 行，每行包含两个整数 $x$ 和 $y$，表示硬币 $x$ 比硬币 $y$ 轻。
## 输出格式

输出 $n$ 个整数。如果硬币 $i$ 的排名在所有 $m$ 次称量后仍未确定，输出 $-1$。否则，输出首次确定排名的称量序号 $k$（$1 \leq k \leq m$）。
## 样例

### 样例输入 #1
```
4 4
2 4
3 1
4 1
2 3
```
### 样例输出 #1
```
3 4 -1 -1
```
### 样例输入 #2
```
6 8
1 5
5 4
6 2
2 5
4 3
6 1
6 5
2 1
```
### 样例输出 #2
```
8 8 5 5 5 6
```
## 提示

【样例解释】

对于样例 #1：
- 硬币 $1$ 的排名在第 $3$ 次称量后确定，输出 $3$。
- 硬币 $2$ 的排名在第 $4$ 次称量后确定，输出 $4$。
- 硬币 $3$ 和 $4$ 的排名无法确定，输出 $-1$。

对于样例 #2：
- 每个硬币的排名确定的时间点分别是 $8$，$8$，$5$，$5$，$5$ 和 $6$。

【数据范围】

- $2 \leq n \leq 200,000$
- $1 \leq m \leq 800,000$
- $1 \leq x, y \leq n$
- 硬币之间的所有称量关系形成一个有效的偏序。

| 子任务编号 | 分值 | 限制条件                     |
|:---:|:---:|:---:|
| $0$ | $0$  | 样例测试用例                     |
| $1$ | $6$  | $1 \leq n \leq 7, 1 \leq m \leq 20$ |
| $2$ | $16$ | $1 \leq n \leq 100, 1 \leq m \leq 400$ |
| $3$ | $10$ | $1 \leq n \leq 1000, 1 \leq m \leq 4000$ |
| $4$ | $68$ | 无额外限制                       |


---

---
title: "[NOIP2024] 树的遍历"
layout: "post"
diff: 省选/NOI-
pid: P11363
tag: ['2024', 'NOIP 提高组']
---
# [NOIP2024] 树的遍历
## 题目描述

小 Q 是一个算法竞赛初学者，正在学习图论知识中的树的遍历。一棵由 $n$ 个结点，$n - 1$ 条边构成的树，初始时所有结点都未被标记，它的遍历过程如下：

1. 选择一个结点 $s$ 作为遍历起始结点，并把该结点打上标记。
2. 假设当前访问的结点为 $u$，寻找任意一个与 $u$ 相邻且未标记的结点 $v$，将 $v$ 作为新的当前访问结点并打上标记。之后再次进入第 $2$ 步。
3. 假设在第 $2$ 步中，与 $u$ 相邻的结点都已被标记，如果 $u = s$ 则遍历过程结束，否则将 $u$ 设为遍历 $u$ 之前的上一个结点并再进入第 $2$ 步。

例如在下面的树中，一种可能的遍历过程如下：
- 选取 $1$ 作为遍历起始结点，并把 $1$ 打上标记；
- $2$ 与 $1$ 相邻且未标记，将 $2$ 设为当前访问结点，并把 $2$ 打上标记。
- $2$ 与 $3$ 相邻且未标记，将 $3$ 设为当前访问结点，并把 $3$ 打上标记。
- $3$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $3$ 之前的结点 $2$。
- $2$ 与 $4$ 相邻且未标记，将 $4$ 设为当前访问结点，并把 $4$ 打上标记。
- $4$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $4$ 之前的结点 $2$。
- $2$ 所有相邻的结点都被标记，将当前访问结点设为遍历结点 $2$ 之前的结点 $1$。
- $1$ 所有相邻的结点都被标记，且 $1$ 是遍历起始结点，故遍历结束。

![](https://cdn.luogu.com.cn/upload/image_hosting/qsjiky0g.png)

作为一个奇思妙想的学生，小 Q 在学习完上述知识后不满足于以结点为基础的遍历方式，于是开始研究以边为基础的遍历方式。定义两条边**相邻**，当且仅当它们有一个公共的结点。初始时，所有的边都未被标记。这种以边为基础的遍历过程如下：

1. 选择一条边 $b$ 作为遍历起始边，并把该边打上标记。
2. 假设当前访问边为 $e$，寻找任意一条与 $e$ 相邻且未标记的边 $f$，将 $f$ 作为新的当前访问边并打上标记。之后再次进入第 $2$ 步。
3. 假设在第 $2$ 步中，与 $e$ 相邻的边都已被标记，如果 $e = b$ 则遍历过程结束，否则将 $e$ 设为遍历 $e$ 之前的上一条边并再进入第 $2$ 步。

例如在上面的树中，一种可能的遍历过程如下（定义 $\{u, v\}$ 表示连接结点 $u$ 和 $v$ 的边）：

- 选取 $\{1, 2\}$ 作为遍历起始边，并把 $\{1, 2\}$ 打上标记；
- $\{1, 2\}$ 与 $\{2, 3\}$ 相邻且未标记，将 $\{2, 3\}$ 设为当前访问边，并把 $\{2, 3\}$ 打上标记。
- $\{2, 3\}$ 与 $\{2, 4\}$ 相邻且未标记，将 $\{2, 4\}$ 设为当前访问边，并把 $\{2, 4\}$ 打上标记。
- $\{2, 4\}$ 所有相邻的边都被标记，将当前访问边设为遍历 $\{2, 4\}$ 之前的边 $\{2, 3\}$。
- $\{2, 3\}$ 所有相邻的边都被标记，将当前访问边设为遍历 $\{2, 3\}$ 之前的边 $\{1, 2\}$。
- $\{1, 2\}$ 所有相邻的边都被标记，且 $\{1, 2\}$ 是遍历起始边，故遍历结束。

小 Q 惊奇的发现，在这个新的树的遍历过程中，如果将每条边看作一个新的结点，将步骤 $2$ 中的所有新结点 $e$ 和 $f$ 连接一条新边，就会生成一棵由 $n-1$ 个新结点和 $n-2$ 条新边连接成的新树。例如上述遍历过程得到的新树如下（新的结点和新边都用红色表示）：

![](https://cdn.luogu.com.cn/upload/image_hosting/mld0xpqg.png)

现在小 Q 在 $n - 1$ 条边中选择了 $k$ 条关键边。小 Q 想知道，以任意一条关键边作为起始遍历边，通过上述遍历过程能够生成多少种不同的新树。这里两棵树被认为是不同的，当且仅当至少存在某一对新的结点，它们仅在其中一棵树中连有新边。

**由于结果可能很大，你只需要输出其对 $10^9+7$ 取模的结果即可。**
## 输入格式

**本题有多组测试数据。**

输入的第一行包含两个整数 $c, T$，表示测试点的编号和测试数据的组数。在样例中，$c$ 表示该样例与测试点 $c$ 的数据范围相同。

接下来包含 $T$ 组数据，每组数据的格式如下：
- 第一行包含两个整数 $n, k$，表示树的结点数以及小 Q 选择的关键边的数量。
- 接下来 $n - 1$ 行，第 $i$ 行包含两个整数 $u_i, v_i$，表示树上编号为 $i$ 的边连接结点 $u_i$ 和 $v_i$。
- 接下来一行包含 $k$ 个整数 $e_1, e_2, \dots, e_k$，表示小 Q 选择的关键边的编号。保证关键边的编号互不相同。
## 输出格式

对于每组测试数据输出一行，包含一个整数，表示结果对 $10^9 + 7$ 取模的结果。
## 样例

### 样例输入 #1
```
1 1
4 1
1 2
2 3
2 4
1
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
7 1
5 2
1 2
1 3
2 4
2 5
1 3
```
### 样例输出 #2
```
3
```
## 提示

**【样例 1 解释】**

两种可能的新树如下：
- 新结点 $\{1, 2\}$ 和新结点 $\{2, 3\}$ 连新边，新结点 $\{2, 3\}$ 和新结点 $\{2, 4\}$ 连新边。
- 新结点 $\{1, 2\}$ 和新结点 $\{2, 4\}$ 连新边，新结点 $\{2, 4\}$ 和新结点 $\{2, 3\}$ 连新边。

**【样例 2 解释】**

三种可能的新树如下：
- 新结点 $\{1, 2\}$ 和 $\{1, 3\}$，$\{1, 2\}$ 和 $\{2, 4\}$，$\{2, 4\}$ 和 $\{2, 5\}$ 之间分别连新边。该新树可以选择 $\{1, 2\}$ 作为起始遍历边得到。
- 新结点 $\{1, 2\}$ 和 $\{1, 3\}$，$\{1, 2\}$ 和 $\{2, 5\}$，$\{2, 5\}$ 和 $\{2, 4\}$ 之间分别连新边。该新树可以选择 $\{1, 2\}$ 或 $\{2, 4\}$ 作为起始遍历边得到。
- 新结点 $\{1, 2\}$ 和 $\{1, 3\}$，$\{1, 2\}$ 和 $\{2, 4\}$，$\{1, 2\}$ 和 $\{2, 5\}$ 之间分别连新边。该新树可以选择 $\{2, 4\}$ 作为起始遍历边得到。

**【样例 3】**

见附件的 traverse/traverse3.in 与 traverse/traverse3.ans。

该组样例满足 $c = 4$。

**【样例 4】**

见附件的 traverse/traverse4.in 与 traverse/traverse4.ans。

该组样例满足 $c = 7$。

**【样例 5】**

见附件的 traverse/traverse5.in 与 traverse/traverse5.ans。

该组样例满足 $c = 11$。

**【样例 6】**

见附件的 traverse/traverse6.in 与 traverse/traverse6.ans。

该组样例满足 $c = 13$。

**【样例 7】**

见附件的 traverse/traverse7.in 与 traverse/traverse7.ans。

该组样例满足 $c = 15$。

**【样例 8】**

见附件的 traverse/traverse8.in 与 traverse/traverse8.ans。

该组样例满足 $c = 16$。

**【样例 9】**

见附件的 traverse/traverse9.in 与 traverse/traverse9.ans。

该组样例满足 $c = 18$。

**【样例 10】**

见附件的 traverse/traverse10.in 与 traverse/traverse10.ans。

该组样例满足 $c = 19$。

**【样例 11】**

见附件的 traverse/traverse11.in 与 traverse/traverse11.ans。

该组样例满足 $c = 22$。

**【样例 12】**

见附件的 traverse/traverse12.in 与 traverse/traverse12.ans。

该组样例满足 $c = 24$。

**【数据范围】**

对于所有的测试数据，保证：
- $1 \leq T \leq 10$；
- $2 \leq n \leq 10^5$；
- $1 \leq k < n$；
- 对于任意的 $i(1 \leq i \leq n - 1)$，都有 $1 \leq u_i, v_i \leq n$，且构成一颗合法的树。
- 对于任意的 $i(1 \leq i \leq k)$，都有 $1 \leq e_i < n$，且两两不同。

| 测试点编号 | $n$ | $k$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim 3$ | $\leq 5$ | $\leq 1$ | 无 |
| $4\sim 6$ | $\leq 10^5$ | $\leq 1$ | 无 |
| $7\sim 10$ | $\leq 10^5$ | $\leq 2$ | 无 |
| $11,12$ | $\leq 500$ | $\leq 8$ | 无 |
| $13,14$ | $\leq 10^2$ | $<n$ | 无 |
| $15$ | $\leq 500$ | $<n$ | 无 |
| $16,17$ | $\leq 10^5$ | $\leq 500$ | 无 |
| $18$ | $\leq 10^5$ | $<n$ | A |
| $19\sim 21$ | $\leq 10^5$ | $<n$ | B |
| $22,23$ | $\leq 2\times 10^4$ | $<n$ | 无 |
| $24,25$ | $\leq 10^5$ | $<n$ | 无 |

- 特殊性质 A：对于任意的 $i(1 \leq i \leq n - 1)$，都有 $u_i = i, v_i = i + 1$。
- 特殊性质 B：对于任意的 $i(1 \leq i \leq n - 1)$，都有 $u_i = 1, v_i = i + 1$。

**【提示】**

数据输入的规模可能较大，请选手注意输入读取方式的效率。


---

---
title: "[NOIP2024] 树上查询"
layout: "post"
diff: 省选/NOI-
pid: P11364
tag: ['2024', 'NOIP 提高组']
---
# [NOIP2024] 树上查询
## 题目描述

有一天小 S 和她的朋友小 N 一起研究一棵包含了 $n$ 个结点的树。

这是一棵有根树，根结点编号为 $1$，每个结点 $u$ 的深度 $\text{dep}_ u$ 定义为 $u$ 到 $1$ 的简单路径上的**结点数量**。

除此之外，再定义 $\text{LCA*}(l, r)$ 为编号在 $[l, r]$ 中所有结点的最近公共祖先，即 $l, l + 1, \dots , r$ 的公共祖先结点中深度最大的结点。

小 N 对这棵树提出了 $q$ 个询问。在每个询问中，小 N 都会给出三个参数 $l, r, k$，表示他想知道 $[l, r]$ 中任意长度大于等于 $k$ 的连续子区间的最近公共祖先深度的最大值，即

$$\max_{l\le l'\le r'\le r \land r'-l'+1\ge k}\text{dep}_ {\text{LCA*}(l', r')}$$

你的任务是帮助小 S 来回答这些询问。
## 输入格式

输入的第一行包含一个正整数 $n$，表示树的结点数。

接下来 $n - 1$ 行，每行包含两个正整数 $u, v$，表示存在一条从结点 $u$ 到结点 $v$ 的边。

第 $n + 1$ 行包含一个正整数 $q$，表示询问的数量。

接下来 $q$ 行，每行包含三个正整数 $l, r, k$，描述了一次询问。
## 输出格式

对于每次询问输出一行，包含一个整数，表示对应的答案。
## 样例

### 样例输入 #1
```
6
5 6
6 1
6 2
2 3
2 4
3
2 5 2
1 4 1
1 6 3

```
### 样例输出 #1
```
3
4
3

```
## 提示

**【样例 1 解释】**

![图 3](https://cdn.luogu.com.cn/upload/image_hosting/ktoq3ogh.png)

+ 对于第一组询问，$\text{LCA*}(2, 3) = 2, \text{LCA*}(3, 4) = 2, \text{LCA*}(4, 5) = 6$，$2$ 的深度为 $3$，$6$ 的深度为 $2$，因此答案为 $\max\{3, 3, 2\} = 3$。

+ 对于第二组询问，答案为 $1, 2, 3, 4$ 四个结点的最大深度，因此答案为 $4$。

+ 对于第三组询问，$\text{LCA*}(1, 3) = 1, \text{LCA*}(2, 4) = 2, \text{LCA*}(3, 5) = 6, \text{LCA*}(4, 6) = 6$，依旧是 $2$ 的深度最大，因此答案为 $3$。

**【样例 2】**

见附件的 query/query2.in 与 query/query2.ans。

该样例满足 $n, q ≤ 500$。

**【样例 3】**

见附件的 query/query3.in 与 query/query3.ans。

该样例满足 $n, q ≤ 10^5$ 且树符合链的形态。

**【样例 4】**

见附件的 query/query4.in 与 query/query4.ans。

该样例满足 $n, q ≤ 5 × 10^5$。

**【数据范围】**

对于所有的测试数据，保证：$1 ≤ n, q ≤ 5 × 10^5
, 1 ≤ l ≤ r ≤ n, 1 ≤ k ≤ r - l + 1$

| 测试点编号 | $n,q\le$ | 特殊限制 |
| :-: | :-: | :-: |
| $1\sim2$ | $500$ | 无 |
| $3\sim5$ | $5000$ | 无 |
| $6\sim9$ | $10^5$ | 满足性质 A |
| $10\sim13$ | $5\times10^5$ | 满足性质 A |
| $14\sim16$ | $5\times10^5$ | 满足性质 B |
| $17\sim20$ | $10^5$ | 无 |
| $21\sim25$ | $5\times10^5$ | 无 |

性质 A：保证输入的树符合链的形态，且根结点的度数为 $1$。

性质 B：对于每个询问保证 $k = r - l + 1$。


---

---
title: "[JOI Open 2019] 三段跳び"
layout: "post"
diff: 省选/NOI-
pid: P11392
tag: ['2019', 'JOI（日本）']
---
# [JOI Open 2019] 三段跳び
## 题目描述

**译自 [JOI Open 2019](https://contests.ioi-jp.org/open-2019/index.html) T1 「三段跳び」**

有一条路，包含 $N$ 段，编号 $1\sim N$。第 $i$ 段有一个强度 $A_i$。

JOI 君，有天赋的体育明星，准备来三段跳。一个三段跳包含三次连续的跳跃。令 $a,b,c$ 分别表示 JOI-kun 三次起跳的段编号，他们需要满足以下条件。

- $a<b<c$。含义是每次起跳的编号需要递增。
- $b-a\le c-b$。含义是第一次起跳跨越的距离需要小于等于第二次的。

JOI 君准备进行 $Q$ 次三段跳。在第 $j$ 次（$1\le j\le Q$）中，他需要在区间 $[L_j,R_j]$ 中的编号起跳，也就是要满足 $L_j\le a<b<c\le R_j$。

JOI 君 想要选择恰当的位置起跳。对于每次三段跳，JOI 君想知道他起跳的这些位置的强度和，最大是多少。

写一个程序，给定段数和三段跳的信息。对于每个三段跳，计算他起跳的这些位置的强度和，最大是多少。
## 输入格式

第 $1$ 行 $1$ 个整数 $N$。

第 $2$ 行 $N$ 个整数，代表 $A_1,A_2,\cdots,A_n$。

第 $3$ 行 $1$ 个整数 $Q$。

第 $4\sim 4+Q-1$ 行，每行两个整数 $L_i,R_i$。
## 输出格式

输出 $Q$ 行。每行输出一个整数，表示答案。

## 样例

### 样例输入 #1
```
5
5 2 1 5 3
3
1 4
2 5
1 5
```
### 样例输出 #1
```
12
9
12
```
### 样例输入 #2
```
5
5 4 4 5 4
1
1 5
```
### 样例输出 #2
```
14
```
### 样例输入 #3
```
15
12 96 100 61 54 66 37 34 58 21 21 1 13 50 81
12
1 15
3 12
11 14
1 13
5 9
4 6
6 14
2 5
4 15
1 7
1 10
8 13
```
### 样例输出 #3
```
277
227
72
262
178
181
174
257
208
262
262
113
```
## 提示

#### 样例解释：

在第一次跳跃中，JOI 君可以选择 $1,2,4$ 段，从而达到最大加和 $12$。

在第二次跳跃中，JOI 君可以选择 $3,4,5$ 段，从而达到最大加和 $9$。如果选择 $2,4,5$，虽然和是 $10$，但是 $b-a\le c-b$ 没有满足。

在第三次跳跃中，JOI 君可以选择 $1,2,4$ 段，从而达到最大加和 $12$。如果选择 $1,4,5$，虽然和是 $13$，但是 $b-a\le c-b$ 没有满足。

#### 数据范围：

- $3 \le N \le 5 \times 10^5$。
- $1 \le A_i \le 10^8 (1 \le i \le N)$。
- $1 \le Q \le 5 \times 10^5$。
- $1 \le Lj < Lj + 2 \le Rj \le N (1 \le j \le Q)$。

#### 子任务：

1. （5 分）$N\le 100$，$Q\le 100$。
2. （14 分）$N\le 5000$。
3. （27 分）$N\le 2\times 10^5$，$Q=1$，$L_1=1$，$R_1=N$。
4. （54 分）无额外约束。


---

---
title: "众数"
layout: "post"
diff: 省选/NOI-
pid: P11398
tag: ['洛谷原创', '洛谷月赛']
---
# 众数
## 题目描述

你有 $n$ 个数对 $(a_1,b_1),\ldots,(a_n,b_n)$。

定义**下标** $i(1\le i\le n)$ 的权值为将 $a_1$ 个 $b_1$，$a_2$ 个 $b_2$，...，$a_i$ 个 $b_i$ 拼接在一起后形成的数组的**最大众数**（特别地，若所有数出现次数相同则为最大数）乘以 $a_i$。

接下来你有 $m$ 个操作，分两种：
- `1 x y`，将 $a_x$ 增加 $y$。**保证 $y$ 非负。**
- `2 q`，求最小的正整数 $k$ 使得**下标** $n-k+1 \sim n$ 的权值异或和为 $q$。

2 操作保证有解，且所有答案之和（记为 $\sum k$）不超过 $5\times 10^7$。
## 输入格式

输入的第一行有三个正整数 $T,n,m$，分别表示测试点编号（样例为 $0$，Hack 数据是 $26\sim 100$ 之间的自然数）、数对个数和操作个数。

第二行有 $2n$ 个正整数 $a_1,b_1,a_2,b_2,\ldots,a_n,b_n$，其中第 $2i-1$ 和第 $2i$ 个数分别表示第 $i$ 个数对的 $a_i,b_i$。

之后有 $m$ 行，每行有一个操作，格式见题目描述。
## 输出格式

对于每个 2 操作，输出一行一个正整数表示答案。
## 样例

### 样例输入 #1
```
0 4 5
2 1 3 3 1 1 1 2
2 0
1 4 6
2 6
1 3 8
2 7

```
### 样例输出 #1
```
2
4
1

```
## 提示

【样例解释】

最开始的四个数组为 $(2,1), (3,3),(1,1),(1,2)$。以计算下标 $2,4$ 的权值为例展示权值的计算方法：

- 要计算下标 $2$ 的权值，就要把 $2$ 个 $1$、$3$ 个 $3$ 拼在一起得到 $[1,1,3,3,3]$，最大众数为 $3$；$a_2=3$，所以权值为 $3\times 3 = 9$。
- 要计算下标 $4$ 的权值，就要把 $2$ 个 $1$、$3$ 个 $3$、$1$ 个 $1$、$1$ 个 $2$ 拼在一起得 $[1,1,3,3,3,1,2]$，最大众数为 $3$；$a_4=1$，所以权值为 $3\times 1=3$。

以此类推，可知下标 $1,2,3,4$ 的权值依次为 $2,9,3,3$。当 $k=2$ 时，$3,4$ 的权值异或和 $3\oplus 3$ 恰为 $0$，符合题意。

接下来将 $a_4$ 增加 $6$ 变成 $7$，显然前 $3$ 个下标权值不变，下标 $4$ 的权值变成 $2\times 7=14$。此时所有下标权值异或和 $2\oplus 9\oplus 3\oplus 14=6$，符合题意，所以此时 $k=4$。

然后把 $a_3$ 增加 $8$ 变成 $9$。现在 $1\sim 4$ 的权值依次为 $2,9,9,7$，此时 $k=1,3$ 时对应的权值异或和都是 $7$，此时取更小的 $k$，所以输出 $1$。

【数据范围】

记 $L$ 为所有操作结束后，所有 $a_i$ 的最大值（例如样例中，$L=9$。）

|测试点编号|$n,m\le$|特殊性质|
|:-:|:-:|:-:|
|$1\sim 2$|$30$|$a_i,y\le 30$|
|$3\sim 4$|$500$||
|$5\sim 7$|$2000$||
|$8\sim 9$|$3\times 10^5$|只有 2 操作|
|$10$|$3\times 10^5$|$b_i=1$|
|$11\sim 12$|$3\times 10^5$|$b_i\le 2$|
|$13\sim 15$|$3\times 10^5$|$\sum k\le 5\times 10^5$|
|$16\sim 19$|$3\times 10^5$|$k\le 300$|
|$20\sim 25$ |$3\times 10^5$||

对于全部数据，保证 $3\le n,m\le 3\times 10^5$，且 $1\le b_i\le n$，$1\le a_i\le L\le 10^9$。

2 操作保证有解，且 $\sum k\le 5\times 10^7$。

**提示：本题读入量较大，建议选用较快的输入输出方式。**


---

---
title: "[Code+#8 初赛] 普勒亚"
layout: "post"
diff: 省选/NOI-
pid: P11401
tag: ['2022', 'Code+']
---
# [Code+#8 初赛] 普勒亚
## 题目背景

搬运自 [Code+ #8 初赛](https://gitlink.org.cn/thusaa/codeplus8pre)。
## 题目描述

魔法少女小七得到了一个神奇的长度为 $n$ 的字符串 $s$，每个位置对应有一个魔法值 $a_i$。每次她可以使用一个长度为 $l$ 的子串作为咒语。对于长度为 $l$ 的咒语 $t$，它的魔力是它在 $s$ 中出现的每个位置的右端点 $pos_j$（即 $\forall i \in [0,l),\ s_{pos_j-i}=t_{l-i}$）的魔法值 $a_{pos_j}$ 从左往右连成的序列的**前缀最大值**个数。

对于每个 $i \in [1,n]$，小七想知道 $s$ 中所有长度为 $i$ 的咒语（两个咒语不同当且仅当其对应的字符串内容不同）的魔力之和。你能帮帮她吗？她会给你一个开心魔法作为报酬！

**前缀最大值**：对于序列 $W$ 来说 $W_i$ 是前缀最大值当且仅当对于任何 $j<i$ 都有 $W_j<W_i$。
## 输入格式

第 $1$ 行，一个长度为 $n$ 的字符串 $s$。

第 $2$ 行，$n$ 个正整数表示对应的魔法值 $a_i$。
## 输出格式

输出 $1$ 行 $n$ 个正整数，第 $i$ 个数表示长度为 $i$ 的咒语的魔法值之和。
## 样例

### 样例输入 #1
```
ababa
5 2 3 4 1
```
### 样例输出 #1
```
3 3 2 2 1
```
### 样例输入 #2
```
aaaa
3 2 3 4
```
### 样例输出 #2
```
2 3 2 1
```
## 提示

**【样例 #1 解释】**

长度为 $1$ 的子串有 `a` 和 `b` 两种，分别构成序列 `5 3 1` 和 `2 4`，各自的前缀最大值个数为 $1$ 和 $2$。

长度为 $2$ 的子串有 `ab` 和 `ba` 两种，分别构成序列 `2 4` 和 `3 1`，各自的前缀最大值个数为 $2$ 和 $1$。

长度为 $3$ 的子串有 `aba` 和 `bab` 两种，构成序列 `3 1` 和 `4`，各自的前缀最大值个数为 $1$ 和 $1$。

长度为 $4$ 的子串有 `abab` 和 `baba` 两种，构成序列 `4` 和 `1` ，各自的前缀最大值个数为 $1$ 和 $1$。

长度为 $5$ 的子串有 `ababa` 一种，构成序列 `1`，前缀最大值个数为 $1$。

**【数据范围】**

对于 $20\%$ 的数据，$n \le 100$。

对于另外 $20\%$ 的数据，$n \le 5000$。

对于另外 $20\%$ 的数据，$s$ 中只有字符 `a`。

对于 $100\%$ 的数据，保证 $n \le 100,000$，$s$ 中只包含小写英文字母。


---

---
title: "[Code+#8 初赛] 图"
layout: "post"
diff: 省选/NOI-
pid: P11402
tag: ['2022', 'Code+']
---
# [Code+#8 初赛] 图
## 题目背景

搬运自 [Code+ #8 初赛](https://gitlink.org.cn/thusaa/codeplus8pre)。
## 题目描述

本题中，对于一个无重边自环的无向图，称图上的一条道路为**简单路**当且仅当其不经过重复节点。即，假设该道路经过的节点依次为 $(u_1,u_2,\cdots,u_k)$，则这条道路为简单路当且仅当 $u_1,u_2,\cdots,u_k$ 两两不同。

给出大质数 $P$ 和 $q$ 次询问，每组询问给出正整数 $n$，你需要求出满足以下所有条件的**有标号**无向图个数，对 $P$ 取模：

1. 图有 $n$ 个节点且不存在重边与自环；
2. 图上不存在边数为 $3$ 的简单路，即图上无法找到四个两两不同的节点 $u_1,u_2,u_3,u_4$ 满足 $(u_1,u_2),(u_2,u_3),(u_3,u_4)$ 均在图中；
3. 在满足条件 1 和 2 的基础上，图的边数最多。
## 输入格式

输入的第一行包含两个正整数 $q$, $P$，保证 $q \le 100,000$，分别表示询问次数和模数。

接下来 $q$ 行每行包含一个正整数 $n$，保证 $n \le 3 \times 10^7$，描述一次询问。
## 输出格式

对于每组询问输出一行一个非负整数，表示满足条件的有标号无向图个数对 $P$ 取模的值。
## 样例

### 样例输入 #1
```
2 199932539
1
6
```
### 样例输出 #1
```
1
10
```
## 提示

**【样例解释】**

以下样例解释将用 $1$ 到 $n$ 之间的整数给每个节点进行编号。

对于第一组询问，只有边集为 $\varnothing$ 的图满足条件。

对于第二组询问，其中两个满足条件的图的边集分别为 ${(1,2)(2,3)(1,3)(4,5)(5,6)(4,6)}$ 和 ${(1,3)(3,5)(1,5)(2,4)(4,6)(2,6)}$。

**【数据范围】**

对于全部数据，保证 $10^8\lt P\lt 10^9$ 且 $P$ 是素数。

本题共 $5$ 个测试点：

测试点 $1$ 保证 $n,q\le8$，分值为 $20$ 分；

测试点 $2$ 保证 $n,q\le200$，分值为 $15$ 分；

测试点 $3$ 保证 $n,q\le3000$，分值为 $15$ 分；

测试点 $4$ 保证 $n\le500,000,q\le100,000$，分值为 $20$ 分；

测试点 $5$ 保证 $n\le3\times10^7,q\le100,000$，分值为 $30$ 分。


---

---
title: "命运黄之瓜"
layout: "post"
diff: 省选/NOI-
pid: P11472
tag: ['O2优化']
---
# 命运黄之瓜
## 题目背景

![字符画](https://cdn.luogu.com.cn/upload/image_hosting/xlauqkoe.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

	什么？我弹春日影？真的假的？

	小睦头曾经在一周目说错了三句话。
	为了挽回大祥老师，soyo 跨越了一次又一次的 MyGO!!!!! 世界线想要撤回那三句话带来的影响。
	众所周知，为了让世界线变动率超过一个阈值，三句话的影响需要以栈的形式撤回。

	I. “live，挺好的。”
	soyo 来到了第一个关头，此时她眼神已经变得坚毅，正欲说出“我唯独不想听到你这么说。”
	soyo 运用她的惊世智慧，在 1s 内思考并说出了：“谢谢你，小睦，让我们一起变得 kirakira⭐dokidoki 吧！”
	并把巧克力袋温柔地还给小睦头：“这个，不需要了。”随即把黄瓜全部服用。
	世界变换了它的色彩，大祥老师为吉他手的短缺而发愁，喵梦也因为艺人女儿的缺席变得犹豫。
	但 soyo 发现脑海中 anon 说过的“一瞬一瞬化作一生”已经变得模糊。

	II. “一起去看他们的 live 吧。”
	soyo 来到了第二个关头，此时她正处于红温状态，想要怒吼“为什么要弹《春日影》!”
	soyo 运用她的惊世智慧，在 1s 内思考并说出了：“小灯，想要一辈子的话我们需要一直摸兜里。”
	世界变换了它的色彩，MyGO!!!!! 提前两个月上演了名为端程山的 live，渐渐他们的名声超过了 Afterglow。
	但 soyo 发现在每场 live 之后，anon 都没有再满脸兴奋地喊到“这是大成功吧！”

	III. “我从来没有觉得玩乐队快乐过。”
	soyo 来到了最终关头，此时她正想安慰伤心的小睦头“不是小睦的错哦。”
	soyo 运用她的惊世智慧，在 1s 内思考并说出了：“小睦，你有为 Crychic 的复活赌上一切的觉悟吗？”
	世界变换了它的色彩，saki 离开后蓝发双马尾 anon 的出现唤起了众人心中美好的回忆，填补了乐队的空缺。
	但 soyo 发现再也没有人鼓起勇气对她说“soyo桑，要一起组乐队吗？”

	IV. “那我呢？”
	随着 Crychic 的不断壮大，saki 从中看到了拯救自己的商机，在 soyo 的帮助下回归并赶走了 anon。
	至此 soyo 挽回了大祥老师。但，一切尘埃落定后，soyo 想，那 anon 呢？

	为了解决这个两难局面，soyo 需要用夹子音欺骗自己，欺骗这个世界！
	为此，她需要和 anon 及 rana 一起演奏春日影，并用很大的夹子音把音乐掩盖过去。

	面对曾经发过毒誓一辈子不再弹奏的乐曲，soyo 无法干净利落地剪切掉自己的誓言。
	所以，面对这个问题，你才是挑战者。

	V. “欧内该......如果你不能运用你的惊世智慧在 1s 内解决这道题目的话......瓦达西！”

## 题目描述

你有两个数组 $a_1,a_2,\cdots,a_n$ 和 $b_1,b_2,\cdots,b_n$。

你可以选择任意整数 $1\le i \le n$，将 $a_i$ 和 $b_i$ 都变为 $0$，你可以操作任意次（可以为 $0$ 次）。

你需要求出 $\min(a_1\oplus a_2\oplus\cdots\oplus a_n,b_1\oplus b_2\oplus\cdots\oplus b_n)$ 的最大值，其中 $\oplus$ 是按位异或运算。
## 输入格式

**本题有多组数据**。

第一行一个正整数 $T$，表示数据组数。

对于每组数据：

第一行一个正整数 $n$。

第二行 $n$ 个整数，表示 $a_1,a_2,\cdots,a_n$。

第三行 $n$ 个整数，表示 $b_1,b_2,\cdots,b_n$。
## 输出格式

对于每组数据：

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
2
3
1 2 3
3 2 11
5
3 4 6 1 8
2 4 1 9 1
```
### 样例输出 #1
```
3
14
```
## 提示

$1\le T\le2\times10^5$，$1\le n,\sum n\le2\times 10^5$，$0\le a_i,b_i <2^{31}$。

	你这人，满脑子都只有大家呢o(*￣︶￣*)o


---

---
title: "[COCI 2024/2025 #3] 处理器 / Procesor"
layout: "post"
diff: 省选/NOI-
pid: P11478
tag: ['2024', '交互题', 'Special Judge', 'O2优化', 'COCI（克罗地亚）']
---
# [COCI 2024/2025 #3] 处理器 / Procesor
## 题目背景


译自 [COCI 2024/2025 #3](https://hsin.hr/coci/) T5。$\texttt{1s,0.5G}$。满分为 $120$。

为了方便测试，公开[交互库](https://www.luogu.com.cn/paste/1gl6aook)。
## 题目描述


**这是一道交互题**。

有一个初始时为空的数组 $a$。

$n$ 次操作，第 $i$ 次操作向 $a$ 的末尾添加 $x_i$ 个整数。

每次操作后，通过若干次询问，你需要找到最小的**未被标记**的整数对应的下标 $x$，并给 $a_x$ 打标记。

每次询问，你可以询问两个**未被标记**的整数 $a_i,a_j$ 的大小关系。

设当前数组长度为 $l$，保证 $\forall 1\le i\lt j\le l$，$a_i\lt a_j$ 和 $a_j\lt a_i$ **恰有一个成立**。换句话说，**保证数组内元素两两不同**。

### 实现细节

首先读入一个正整数 $n$。接下来依次处理 $n$ 次操作。

对于第 $i$ 次操作，读入一个正整数 $x_i$，表示增加的整数数量。

接下来你可以按照以下格式询问若干次：

- $\texttt{?}$ $i$ $j$：询问 $a_i,a_j$ 的大小关系。
    - 返回 $0$，表示 $a_i\lt a_j$；返回 $1$，表示 $a_i\gt a_j$。
    - 令当前数组长度为 $l$，你需要保证 $1\le i,j\le l$。
    - 你需要保证 $i\neq j$，且 $a_i,a_j$ 未被标记。


按以下格式回答：

- $\texttt{!}$ $x$：当前数组内未被标记的最小整数为 $a_x$。

**回答后立刻读入下一个整数 $x_{i+1}$，若这是最后一次操作则立刻结束程序。**

**在每次询问或者回答后，都要换行并刷新缓冲区。** 刷新缓冲区的方式：C++ 中的 `std::cout.flush()`，`std::cout<<std::endl`。
## 输入格式


见【实现细节】。
## 输出格式


见【实现细节】。
## 样例

### 样例输入 #1
```
3

3

1

0

0

1

1

1

0
```
### 样例输出 #1
```

? 1 2

? 1 3

? 2 3

! 2

? 1 4

! 4

? 1 5

! 1
```
## 提示


### 样例解释

样例 $1$ 中，$a=[3,2,4,1,5]$。

- 查询 $a_1$ 与 $a_2$：$a_1\gt a_2$，返回 $1$；
- 查询 $a_1$ 与 $a_3$：$a_1\lt a_3$，返回 $0$；
- 查询 $a_2$ 与 $a_3$：$a_2\lt a_3$，返回 $0$。

不难发现 $a_2$ 为当前未标记的最小值，所以回答 $2$。接下来继续处理剩余的两次操作。

### 数据范围


对于 $100\%$ 的数据，保证：

- $1\le n\le 40$；
- $1\le x_i,\sum x_i\le 2\, 000$。
- 数组内整数两两不同。

### 计分方式

令你的程序询问次数的最大值为 $q$。

- $q\le 2\, 700$，得 $120$ 分。
- $2\, 700 \lt q\le 7\, 000$，得 $75$ 分。
- $7\, 000 \lt q\le 2\times 10^4$，得 $35$ 分。
- $2\times 10^4 \lt q\le 8\times 10^4$，得 $15$ 分。
- $8\times 10^4\lt q$，得 $0$ 分。


---

---
title: "「Cfz Round 5」Zhòng shù"
layout: "post"
diff: 省选/NOI-
pid: P11488
tag: ['洛谷原创', '洛谷月赛']
---
# 「Cfz Round 5」Zhòng shù
## 题目背景

[English statement](https://www.luogu.com.cn/problem/U517659). **You must submit your code at the Chinese version of the statement.**

---

> 我想要种一棵香蕉树 上面挂满我的所有祝福
## 题目描述

小 C 喜欢种树。

它种了一棵香蕉树，但是这棵树似乎需要人工维护才能生长。

因此，它经常会在树上的某一个位置挂上一些「祝福」。所谓「祝福」，其实就是一条链。

而有的时候树的一部分长得太好了，会导致整棵树长歪，所以它又不得不砍掉一部分。

小 C 还喜欢众数，所以它会经常问你所有树上结点的深度中同一个深度最多的出现次数。

具体来说，有一棵有根树，最初只有根结点 $1$，另外有一个变量 $n=1$。

有如下三种操作：

1. `x l k`：增加编号为 $n+1\sim n+lk$ 的结点以及边
$(x,n+1),(n+1,n+2),\dots,(n+l-1,n+l)$；$(x,n+l+1),(n+l+1,n+l+2),\dots,(n+2l-1,n+2l)$；$\dots$；$(x+n+(k-1)l+1),(n+(k-1)l+1,n+(k-1)l+2),\dots,(n+kl-1,n+kl)$。即在 $x$ 号结点下面挂了 $k$ 条长度为 $l$ 的链。这个操作执行之后 $n\gets n+kl$。
2. `x`：删除 $x$ 号结点及其子树。
3. （无参数）查询所有结点的深度中，出现最多的那个深度的出现次数。
## 输入格式

第一行包含一个整数 $m$，表示操作次数。

接下来 $m$ 行，每行包含若干个整数，第一个整数 $op$ 表示当前操作种类，接下来的输入与上面的格式依次对应。
## 输出格式

对于每个 $3$ 操作，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
23
3
1 1 2 3
3
1 6 2 2
3
1 7 1 4
3
2 12
3
2 13
3
1 3 1 2
3
2 7
3
2 3
3
1 5 2 3
3
2 6
3
2 5
3
```
### 样例输出 #1
```
1
3
5
6
5
5
6
4
3
5
3
2
```
### 样例输入 #2
```
16
1 1 4 3
3
1 2 3 3
3
1 10 1000000000 2
3
1 1000000021 1 10
3
2 1000000027
3
2 23
3
1 12 1 1
3
1 2000000033 100000 1000000000
3
```
### 样例输出 #2
```
3
6
8
12
11
7
8
1000000001
```
### 样例输入 #3
```
18
1 1 85 483
1 32607 44 379
2 45784
1 46178 133 40
3
1 13506 152 357
2 62124
3
1 70877 209 33
3
1 37299 429 158
3
1 31487 258 363
2 159051
3
2 227162
2 279608
3
```
### 样例输出 #3
```
902
1257
1257
1415
1778
1778
```
### 样例输入 #4
```
19
1 1 189019619 113958
2 800361853
1 422490453 494478 254349561
3
2 1152812283
2 1650380207
3
1 4033287043 23425848 3533684
2 2666277906
1 709388173 159264263 191915
3
2 3453785850
2 8487830948768
2 39677822722745
2 167837684014594
1 1534084935 1205975 21949299
1 151207136 41249553 693236
1 1121564684 68403 1385595730
3
```
### 样例输出 #4
```
254463518
254463517
254463516
1386594833
```
## 提示

#### 「样例解释 #1」

下面的图中，点的颜色代表被加入的时间。

![](https://s21.ax1x.com/2024/12/09/pAHk3Hf.png)

上图为经过三次 $1$ 操作（`1 1 2 3`，`1 6 2 2` 和 `1 7 1 4`）后的树。

![](https://s21.ax1x.com/2024/12/09/pAHklut.png)

上图为在刚才的基础上经过两次 `2` 操作（`2 12` 和 `2 13`）的树。

![](https://s21.ax1x.com/2024/12/09/pAHk1DP.png)

上图为刚才的基础上再经过一次 $1$ 操作（`1 3 1 2`）的树。

![](https://s21.ax1x.com/2024/12/09/pAHkGE8.png)

上图为刚才的基础上再经过两次 $2$ 操作（`2 7` 和 `2 3`）的树。

![](https://s21.ax1x.com/2024/12/09/pAHkMjI.png)

上图为刚才的基础上再经过一次 $1$ 操作（`1 5 2 3`）的树。

![](https://s21.ax1x.com/2024/12/09/pAHkJUS.png)

上图为经过所有操作后的树。

#### 「数据范围」

对于所有测试数据，保证：

- $1\le m\le 10^5$；
- $1$ 操作中的 $x$ 满足 $1\le x\le n$ 且 $x$ 号结点在树上依然存在，保证 $1 \le l,k \le 10^{18}$；
- $2$ 操作中的 $x$ 满足 $1<x\le n$ 且 $x$ 号结点在树上依然存在；
- 任意时刻的 $n$ 满足 $n\le 10^{18}$。

**本题采用捆绑测试。**

设操作过程中 $n$ 的最大值为 $k$。

- Subtask 0（10 points）：$k \le 5000$。
- Subtask 1（20 points）：$k \le 5 \times 10^5$。
- Subtask 2（20 points）：不存在 $2$ 操作。
- Subtask 3（20 points）：$1$ 操作中 $l$ 的值为 $1$。
- Subtask 4（30 points）：无特殊限制。


---

---
title: "[ROIR 2017] 挖矿机器人 (Day 1)"
layout: "post"
diff: 省选/NOI-
pid: P11509
tag: ['2017', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2017] 挖矿机器人 (Day 1)
## 题目背景

翻译自 [ROIR 2017 D1T4](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-day1.pdf)。
## 题目描述

有一个关于开发邻近星系行星的项目。为了开采矿产资源，计划将几批机器人送往该行星。

该行星的开采区域是一个大小为 $ w \times h $ 的矩形网格区域，区域内的单元格坐标范围从 $(1, 1)$ 到 $(w, h)$。在某些单元格中设有基地，可以将机器人按批次运送到那里。整个区域共设有 $ s $ 个基地，第 $ i $ 个基地位于坐标 $(x_i, y_i)$ 处。

每批机器人有三个重要参数：第 $ j $ 批机器人将送往基地 $ b_j $，包含 $ n_j $ 个机器人，并且每个机器人具有移动能力 $ m_j $。

当机器人批次送到相应基地后，每个机器人都会从基地出发，沿着行星表面移动到某个单元格。如果一个机器人的移动能力为 $ m $，它最多可以进行 $ m $ 次移动，并且每次可以选择八个相邻的方向进行移动，如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/auhkmcwj.png)

当所有送到的机器人都停止移动后，它们会被激活并开始开采其所在单元格的矿产。在机器人的移动过程中，多个机器人可以同时处于同一个单元格，但是在激活之后，每个单元格内最多只能容纳 $ q $ 个机器人。

项目团队得到了 $ t $ 批机器人的信息，这些机器人可以按顺序送往行星。然而，考虑到它们的移动限制，如果将所有机器人全部送上去，可能最终无法满足每个单元格最多只有 $ q $ 个机器人的要求。因此，项目团队需要选择前 $ k $ 批机器人（$ 0 \leq k \leq t $），将它们完全送到相应的基地。如果 $ k < t $，则还可以从第 $ k+1 $ 批机器人中额外选择 $ z $ 个机器人（$ 0 \leq z < n_{k+1} $）。团队需要求出 $ k $ 的最大值，并在这个前提下最大化 $ z $（若 $k=t$，则 $z=0$）。
## 输入格式

第一行输入四个整数 $ w, h, s, q $（$ 1 \leq w, h \leq 10^5, 1 \leq s \leq 4, 1 \leq q \leq 100 $）。

接下来 $ s $ 行每行包含两个整数 $ x_i, y_i $，表示基地的位置（$ 1 \leq x_i \leq w, 1 \leq y_i \leq h $）。

接下来一行包含一个整数 $ t $，表示机器人批次的数量（$ 1 \leq t \leq 100 $）。

接下来的 $ t $ 行描述每个机器人批次，每行包含三个整数：$ b_j, n_j, m_j $（$ 1 \leq b_j \leq s, 1 \leq n_j \leq w \cdot h \cdot q, 0 \leq m_j < \max(w, h) $）。
## 输出格式

输出两个整数 $ k $ 和 $ z $，意义见题目描述。
## 样例

### 样例输入 #1
```
4 3 2 1
1 1
3 2
3
1 4 1
2 9 1
1 12 2
```
### 样例输出 #1
```
1 7
```
## 提示

### 样例解释

在样例中，输入了以下信息：

- 区域的大小是 $ 4 \times 3 $，有两个基地，且每个单元格最多容纳 $1$ 个机器人。
- 第一个基地位于坐标 $ (1, 1) $，第二个基地位于坐标 $ (3, 2) $。
- 总共有 $3$ 批机器人要送往该地区。
  - 第 $1$ 批机器人送往第 $1$ 个基地，包含 $4$ 个机器人，每个机器人的最大移动能力为 $1$。
  - 第 $2$ 批机器人送往第 $2$ 个基地，包含 $9$ 个机器人，每个机器人的最大移动能力为 $1$。
  - 第 $3$ 批机器人送往第 $1$ 个基地，包含 $12$ 个机器人，每个机器人的最大移动能力为 $2$。

经过合理安排，可以让第一批机器人完全送达，并额外选择第二批中的 $7$ 个机器人。最终，第一批和第二批的机器人能够成功安置在网格区域内，使得每个单元格内最多有 $1$ 个机器人：

![](https://cdn.luogu.com.cn/upload/image_hosting/pkgodnzw.png)

因此，答案是 $ k = 1 , z = 7$。

### 数据范围

| 子任务 | 分值 | $1\le w,h\le$ | $1\le s\le$ | $1\le q\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $18$ | $20$ | $1$ | $1$ |
| $2$ | $12$ | $20$ | $2$ | $1$ |
| $3$ | $9$ | $20$ | $3$ | $1$ |
| $4$ | $10$ | $20$ | $3$ | $100$ |
| $5$ | $15$ | $10^5$ | $1$ | $100$ |
| $6$ | $36$ | $10^5$ | $4$ | $100$ |


---

---
title: "[ROIR 2017] 培训 (Day 2)"
layout: "post"
diff: 省选/NOI-
pid: P11513
tag: ['2017', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2017] 培训 (Day 2)
## 题目背景

翻译自 [ROIR 2017 D2T4](https://neerc.ifmo.ru/school/archive/2016-2017/ru-olymp-regional-2017-day2.pdf)。
## 题目描述

某公司共有 $n$ 名员工，每个员工都有一个唯一的编号，编号从 $1$ 到 $n$。编号为 $1$ 的员工是公司总经理，除了总经理之外，每个员工都有一个直接上级，员工 $i$ 的直接上级编号为 $p_i$，且有 $p_i < i$。

若 $p_x = y$，则员工 $x$ 被称为员工 $y$ 的第 $1$ 层下属；若员工 $p_x$ 是员工 $y$ 的第 $k-1$ 层下属，则员工 $x$ 被称为员工 $y$ 的第 $k$ 层下属。

现在，公司总经理可以选择一些员工参加培训。他决定选择两个数字 $L$ 和 $R$，将所有编号满足 $L \leq i \leq R$ 的员工送去培训。

在确定 $L$ 和 $R$ 之前，总经理收到了 $m$ 条员工的要求，第 $j$ 条要求用两个数字 $u_j$ 和 $k_j$ 表示，这代表员工 $u_j$ 希望其第 $k_j$ 层下属中**至少有一个**被送去培训。为了节省费用，总经理希望确定 $L$ 和 $R$ 的值使得送去培训的员工人数最少，并且所有员工的要求都能满足。

需要编写程序，根据公司内部的上下级关系和员工的要求，找出一对 $L$ 和 $R$，使得所有要求都能得到满足，并且送去培训的员工人数最少。如果有多个满足条件的 $(L, R)$ 对，选择其中 $L$ 最小的那个。
## 输入格式

第一行输入一个整数 $n$，表示公司员工的总数（$2 \leq n \leq 200000$）。

第二行输入 $n-1$ 个整数 $p_2, p_3, \dots, p_n$，其中 $p_i$ 表示员工 $i$ 的直接上级编号，且 $1 \leq p_i < i$。

第三行输入一个整数 $m$，表示员工的要求数量。

接下来 $m$ 行，每行包含两个整数 $u_j$ 和 $k_j$，表示第 $j$ 条要求。
## 输出格式

输出两个整数 $L$ 和 $R$，表示选择的员工编号区间。如果存在多个符合条件的 $(L, R)$ 对，输出其中 $L$ 最小的那一对。
## 样例

### 样例输入 #1
```
7
1 1 2 2 3 3
3
1 1
3 1
1 2
```
### 样例输出 #1
```
3 6
```
## 提示

### 样例解释

员工编号为 $3,4,5,6$ 的员工将被送去培训。这满足所有要求，因为员工 $3$ 是员工 $1$ 的第 $1$ 层下属，员工 $4$ 是员工 $1$ 的第 $2$ 层下属，员工 $6$ 是员工 $3$ 的第 $1$ 层下属。

### 数据范围

| 子任务 | 分值 | $2\le n\le$ | $1\le m\le$ | 其它特殊性质 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $19$ | $50$ | $50$ |  |
| $2$ | $25$ | $3000$ | $3000$ |  |
| $3$ | $21$ | $200000$ | $200000$ | $p_i=i-1$ |
| $4$ | $35$ | $200000$ | $200000$ |  |


---

---
title: "[Code+#5] 方案计数"
layout: "post"
diff: 省选/NOI-
pid: P11539
tag: ['Code+']
---
# [Code+#5] 方案计数
## 题目背景

**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。


## 题目描述

小 V 刚考完拓扑，闭区间套让他有点自闭，所以他决定把这一场 CP 安排一下。

我们首先选定一个数据范围 $N$，这里 $N$ 是一个整数。

考虑如下的函数：

```cpp
// rand_int(l, r) 返回闭区间 [l, r] 中的一个随机整数
vector<int> ans;

void solve(int l, int r) {
    if (l == r) {
        ans.push_back(r);
        return ;
    }
    int m = rand_int(l, r - 1);
    if (rand_int(0, 1) == 0) {
        solve(l, m);
        solve(m + 1, r);
    } else {
        solve(m + 1, r);
        solve(l, m);
    }
}
```

我们初始令 $\texttt{ans}$ 为空，那么调用 $\texttt{solve(1, N)}$ 之后，$\texttt{ans}$ 里会存储一个排列。

现在的问题是，给定排列 $P$，问有多少种不同的随机数生成方法可以使这个 $\texttt{ans}$ 中存储的排列恰好为 $P$。

定义两种随机数生成方式是不同的，当且仅当在函数某次调用 $\texttt{rand\_int}$ 时，随机数生成器返回了不同的数。

方案数对 $998244353$ 取模。
## 输入格式

第一行一个正整数 $N$，保证 $N\le 5\times 10^5$。

接下来一行 $N$ 个整数，描述排列 $\{P_i\}$。
## 输出格式

输出一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
4
4 3 1 2
```
### 样例输出 #1
```
2
```
## 提示

**数据范围：**

$\def\arraystretch{1.21}
\begin{array}{|c|c|c|}\hline
\bold{\small{子任务}}&\textbf{score}&\textbf{constraints}\\\hline
\text{A}&20&N\le5000,P_i=N-i+1\\\hline
\text{B}&10&B\le10^5,P_i=N-i+1\\\hline
\text{C}&30&N\le10^5\\\hline
\text{D}&40&N\le5\times10^5\\\hline
\end{array}$


---

---
title: "[Code+#5] 法师"
layout: "post"
diff: 省选/NOI-
pid: P11544
tag: ['Special Judge', 'Code+']
---
# [Code+#5] 法师
## 题目背景

**题目来源：**[link](https://www.gitlink.org.cn/thusaa/codeplus5)。
## 题目描述

传说在 $100000$ 年前，有大量陨石即将撞击企鹅大陆。散布在企鹅大陆各个地点的企鹅法师们张开法阵保护企鹅大陆。

每两个法师之间，会生成一个以这两个法师连线为直径的圆形法阵。能被保护的区域就是法阵的并。

每个法师的坐标可以使用一组非负整数 $\left(X, Y\right)$ 表示。不存在两个法师在同一个位置。

读完这个故事，企鹅豆豆想到一个问题——能被保护的区域的外侧周长有多长？

## 输入格式

每个测试点只有一组数据。

输入的第一行包含一个正整数 $n$，表示法师人数。

接下来 $n$ 行每行两个非负整数，表示一位法师的坐标位置。保证数值不超过 $10^9$。

## 输出格式

输出一个小数，表示被保护的区域的周长。
## 样例

### 样例输入 #1
```
2
0 0
0 1
```
### 样例输出 #1
```
3.14159265358979326666666666666233333333
```
### 样例输入 #2
```
3
0 1
3 0
2 2

```
### 样例输出 #2
```
11.99210886393877709133

```
### 样例输入 #3
```
见附件
```
### 样例输出 #3
```
见附件
```
## 提示

**数据范围：**

对于所有数据，$2 \le n \le 10^5$。

**样例解释：**

对于样例一，显然被保护面积是以这两点连线作为直径的圆形。根据圆的周长计算公式即可得出答案。而且你与标算的相对误差不超过 $10^{-7}$ 即被认为正确。


---

---
title: "[ROIR 2016] 和谐数列 (Day 2)"
layout: "post"
diff: 省选/NOI-
pid: P11558
tag: ['2016', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2016] 和谐数列 (Day 2)
## 题目背景

翻译自 [ROIR 2016 D2T4](https://neerc.ifmo.ru/school/archive/2015-2016/ru-olymp-regional-2016-day2.pdf)。
## 题目描述

如果一个整数数列 $a_1, a_2, \dots, a_n$ 满足其中每个数（除了 $a_1$ 和 $a_n$）等于其相邻两个数的和，即 $a_2 = a_1 + a_3, a_3 = a_2 + a_4, \dots, a_{n-1} = a_{n-2} + a_n$，那么我们称这个序列为和谐数列。  

例如，数列 $[1, 2, 1, {-1}]$ 是和谐数列，因为 $2 = 1 + 1$，且 $1 = 2 + ({-1})$。

现在考虑两个相同长度的数列 $A = [a_1, a_2, \dots, a_n]$ 和 $B = [b_1, b_2, \dots, b_n]$。我们定义它们之间的距离为：
$$ d(A, B) = |a_1 - b_1| + |a_2 - b_2| + \dots + |a_n - b_n| $$  
例如，$d([1, 2, 1, {-1}], [1, 2, 0, 0]) = |1 - 1| + |2 - 2| + |1 - 0| + |{-1} - 0| = 0 + 0 + 1 + 1 = 2$。

现有一个数列 $B = [b_1, b_2, \dots, b_n]$，需要找出一个和谐数列 $A = [a_1, a_2, \dots, a_n]$，使得 $d(A, B)$ 最小。你只需要求出 $d(A, B)$ 的最小值即可。
## 输入格式

第一行输入一个整数 $n$，表示数列的长度（$3 \leq n \leq 300000$）。

第二行输入 $n$ 个整数 $b_1,b_2,\dots,b_n$（$-10^9 \leq b_i \leq 10^9$）。
## 输出格式

输出一个整数，表示 $d(A, B)$ 的最小值。
## 样例

### 样例输入 #1
```
4  
1 2 0 0
```
### 样例输出 #1
```
2
```
## 提示

### 样例解释

在样例中，可以令 $A=[1, 2, 1, {-1}]$，这样 $d([1, 2, 1, {-1}], [1, 2, 0, 0]) = 2$。可以证明 $d(A,B)$ 不可能小于 $2$。

### 数据范围

| 子任务 | 是否捆绑 | 分值 | $3\le n\le$ | $\lvert b_i\rvert\le$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | 是 | $14$ | $3$ | $10$ |
| $2$ | 是 | $14$ | $500$ | $100$ |
| $3$ | 是 | $16$ | $100000$ | $100$ |
| $4$ | 是 | $16$ | $1000$ | $10^9$ |
| $5$ | 是 | $40$ | $300000$ | $10^9$ |


---

---
title: "【MX-X8-T5】「TAOI-3」蓝宝石的存在证明"
layout: "post"
diff: 省选/NOI-
pid: P11646
tag: ['O2优化', '梦熊比赛']
---
# 【MX-X8-T5】「TAOI-3」蓝宝石的存在证明
## 题目背景

原题链接：<https://oier.team/problems/X8F>。

---

她背对着曾崇拜神的祭坛，就像在祈祷的圣女一样。

——啊，神呀。这是何等的悲剧。

能否恳请您把这出悲剧变成喜剧，变成一出任何人也能开怀大笑的愉快喜剧?

然后，若是您大发慈悲，求求实现我的恋情。是的，唯有一回我也乐意。

向神发誓，我赌上一生来爱你。

向神发誓，我求得偿夙愿。
## 题目描述

——只要打开这本魔法之书，自己的存在就会被世人遗忘。

世人之间的连接可以被看做一个 $n$ 个点的有标号无向简单**连通**图 $(V,E)$。此外，Kisaki 还会给你一个整数 $t \in \{0,1\}$，若 $t=0$，则这张无向连通图必须满足任意两点之间存在唯一的简单路径。若 $t=1$，则没有限制。

我们定义一个 $V$ 的一个子集 $W$ 是「紧密」的，当且仅当 $W$ 是图上的一个连通块，满足 $|W| \ge 2$，且对于任意 $u,v \in W$，都满足 $\text{dis}(u,v) \le 2$，其中 $\text{dis}(u,v)$ 为 $u,v$ 最短路径上的边数。

对于世人的一种连接方式，Kisaki 定义它是好的，当且仅当存在 **恰好** 一种方案把 $V$ 划分成若干点集，使得每个划分出的点集都是「紧密」的。

现在，Kisaki 告诉了你 $n$ 和 $t$，她想要知道，有多少种好的连接方式。当然，可能的方案是很多的，所以如你所想地——你所计算的方案数需要对模数 $P$ 取模（$P$ 未必是素数）。另外，她可能会问你很多次。
## 输入格式

第一行，三个非负整数 $T, P, t$，其中 $T$ 为询问的次数。

接下来 $T$ 行，每行一个正整数 $n$。
## 输出格式

$T$ 行，每行一个非负整数，代表询问的答案对 $P$ 取模的值。
## 样例

### 样例输入 #1
```
8 998244353 1
1
2
3
5
98
197
1145
4950

```
### 样例输出 #1
```
0
1
4
65
369585723
752044625
87224156
664115047
```
### 样例输入 #2
```
8 998244353 0
1
2
3
5
98
197
1145
4950

```
### 样例输出 #2
```
0
1
3
65
607286080
653853011
777350973
422131392
```
## 提示

**【样例解释 #1】**

若 $n=3$ 且 $t=1$，一种合法的连接方式如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/c89l5zsn.png)

唯一一种对它的合法划分方案为，划分成 $\{1,2,3\}$ 这一个集合。这种连接方式在 $t=0$ 时是不合法的。

**【样例解释 #2】**

若 $n=5$，无论 $t=0$ 还是 $t=1$，一种合法的连接方式如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/asn5svxb.png)

唯一一种对它的合法划分方案为，划分成 $\{1,2\}$ 和 $\{3,4,5\}$ 两个集合。

**【数据范围】**

**本题采用捆绑测试。**

- 子任务 1（1 分）：$P=1$。
- 子任务 2（6 分）：$n,T \le 7$，$t=0$。
- 子任务 3（6 分）：$n,T \le 7$，$t=1$。
- 子任务 4（12 分）：$P \le 2$，$t=1$。
- 子任务 5（23 分）：$t=0$。
- 子任务 6（21 分）：$n,T \le 100$。
- 子任务 7（17 分）：$P \ge 10^8$ 且 $P$ 为质数。
- 子任务 8（14 分）：无特殊限制。

对于所有数据，保证 $1 \le n,T \le 5 \times 10^3$，$0 \le t \le 1$，$1 \le P \le 1.05 \times 10^9$。


---

---
title: "【MX-X8-T6】「TAOI-3」俄罗斯蓝猫"
layout: "post"
diff: 省选/NOI-
pid: P11647
tag: ['交互题', 'Special Judge', 'O2优化', '梦熊比赛']
---
# 【MX-X8-T6】「TAOI-3」俄罗斯蓝猫
## 题目背景

原题链接：<https://oier.team/problems/X8G>。

---

由于洛谷有特殊的交互题机制，你不需要也不应该在文件开头包含 `kiwi.h`，而是把以下语句复制在文件开头：

```cpp
#include<vector>
std::vector<long long> game(int n);
std::vector<long long> ask(std::vector<int> x,std::vector<int> y);
```


---

小千绘莉想和你玩游戏！
## 题目描述

小千藏有 $n$ 个在 $[0,10^{18}]$ 中间**随机生成**的非负整数 $a_0,a_1,\dots,a_{n-1}$。

你一组询问可以向小千给出不超过 $2n$ 个二元组 $(x_0,y_0),(x_1,y_1),\dots,(x_{m-1},y_{m-1})$，假设 $b_i=a_{x_i}+a_{y_i}$，小千会告诉你 $b_0,b_1,\dots,b_{m-1}$ **从小到大排序**后的结果。

你可以向小千提出不超过 $n$ 组询问，你需要**按顺序**返回 $a_0,a_1,\dots,a_{n-1}$。

需要注意的是：

- 如果你一次询问提出大于 $2n$ 个二元组，或者提出了大于 $n$ 次询问，你会获得 $0$ 分。
- 小千不喜欢重复，如果你某次询问的某个二元组有 $x_i=y_i$，或者有某个**无序对** $(x_i,y_i)$ 被询问了多次（在一组询问间或两组不同的询问之间）。小千都会扣除部分分数。
- 具体评分标准见下面【**评分标准**】。
- **请不要在标准输出输出任何内容**。否则视为攻击交互库。会被判定为 Wrong Answer。
## 输入格式

你不需要，也不应该实现 `main` 函数。

你需要保证你的文件包含了 `kiwi.h`。你可以通过在代码开头加入下面语句实现：

```cpp
#include"kiwi.h"
```

你需要实现以下函数：

```cpp
std::vector<long long> game(int n);
```

其中 $n$ 表示随机数的数量。

这个函数应当返回一个长度为 $n$ 的数组，表示你求出的数组 $a_i$。

你可以调用如下函数：

```cpp
std::vector<long long> ask(std::vector<int> x,std::vector<int> y);
```

- 你需要保证 $x,y$ 序列长度相同；
- 该函数会返回和 $x,y$ 长度相等的序列表示 $a_{x_i}+a_{y_i}$ 从小到大排序后的结果。

保证在题目给定的询问次数和 $x,y$ 长度的限制下，交互库占用资源不超过 $2$ 秒和 $16$ MiB。

下发 `grader.cpp` 为参考交互库，和最终的交互库有所不同。你的做法不应该依赖于交互库实现。

下发 `kiwi.cpp` 为参考实现，你可以通过以下语句来编译你的代码：

```cpp
g++ grader.cpp kiwi.cpp -o kiwi -O2 -std=c++14 -static
```

对编译出来的程序，你只需要输入三个正整数 $T,n,R$ 分别表示数据组组数，每组数据的 $n$ 和随机种子。

**实际的交互库中，随机数种子随时间变化。也就是两次不同时间的提交，答案是不同的。**
## 输出格式

输入完成后，交互库会调用 $T$ 次函数 `game`。每次调用结束后会向标准输出输出以下信息：

- `Wrong Answer[1]` 表示你某次调用 `ask` 函数中 $x,y$ 长度不相同；
- `Wrong Answer[2]` 表示你某次调用 `ask` 函数中 $x,y$ 长度大于 $2n$；
- `Wrong Answer[3]` 表示你某次调用 `ask` 函数中 $x_i,y_i$ 的元素不在 $[0,n-1]$ 内；
- `Wrong Answer[4]` 表示你本次 `game` 中调用了超过 $n$ 次 `ask`；
- `Wrong Answer[5]` 表示你本次调用 `game` 函数返回序列的长度不是 $n$；
- `Wrong Answer[6]` 表示你返回了错误的答案；
- `OK, you can get p points.` 表示你返回了正确的答案，并且获得了这个测试点 $p\%$ 的分数。评分标准见下面说明。

如果你的代码同时违反了多个规定，只会显示一个，且此时程序会立刻停止。
## 提示

**【评分标准】**

**本题首先会受到和传统相同的限制**。例如编译错误会导致整道题目得 $0$ 分，运行时错误、超过时间限制、超过空间限制都会导致相应测试点得 $0$ 分。选手只能在程序中访问自己定义的和交互库给出的变量或数据，及其相应的内存空间。尝试访问其他位置空间将可能导致编译错误或运行错误。

假设该测试点满分为 $P$。

- 如果你违反了上述 Wrong Answer 的规则，或者在标准输出中输出了内容，会直接得 $0$ 分。
- 如果你某次调用 `ask` 时 $x_i=y_i$ 则 $C_1=0.8$，否则 $C_1=1$；
- 如果你调用 `ask` 时，询问了两组相同的 $\{x_i,y_i\}$ 则 $C_2=0.7$，否则 $C_2=1$；
- 假设你一共调用了 $A$ 次 `ask`，则：
	- 如果 $0\leq A\leq 2$，则 $C_3=1$；
   - 如果 $A=3$，则 $C_3=0.8$；
   - 如果 $A=4$，则 $C_3=0.6$；
   - 如果 $5\leq A\leq 10$，则 $C_3=0.4$；
   - 如果 $11\leq A$，则 $C_3=0.2$。
- 假设你调用 `ask` 时，$x$ 数组的**最大长度**为 $B$，则：
	- 如果 $1\leq B\leq n-1$，则 $C_4=1$；
   - 如果 $B=n$，则 $C_4=0.9$；
   - 如果 $B=n+1$，则 $C_4=0.8$；
   - 如果 $B=n+2$，则 $C_4=0.7$；
   - 如果 $n+3\leq B\leq n+20$，则 $C_4=0.6$；
   - 如果 $n+21\leq B$，则 $C_4=0.5$。
   
本测试点的最终得分为所有 `game` 函数，$P\times C_1\times C_2\times C_3\times C_4$ 最小值**向下取整**。

**【数据范围】**

对于所有数据，保证 $T=20$，$5\leq n\leq 500$。

- 测试点 1（30 分）：$n=5$。
- 测试点 2（30 分）：$n=50$。
- 测试点 3（40 分）：$n=500$。


---

---
title: "[JOI 2025 Final] 只不过是长的领带 2 / Just Long Neckties 2"
layout: "post"
diff: 省选/NOI-
pid: P11665
tag: ['2025', 'JOI（日本）']
---
# [JOI 2025 Final] 只不过是长的领带 2 / Just Long Neckties 2
## 题目背景

译自 [第24回日本情報オリンピック 本選](https://contests.ioi-jp.org/joi-ho-2025/index.html) T4。

## 题目描述


有一个长度为 $k$（$k\ge 1$）的正整数数列 $B_1,\cdots,B_k$，初始 $B_i=1$（$1\le i\le k$）。这里，$k$ 是一个还未确定的数。

有 $N$ 场演出，第 $i$（$1\le i\le N$）场演出中，观众将会报出数字 $A_i$。然后你需要做以下的事情：

- 选择是否回应这个观众。
    - 如果选择回应，你需要选择 $j$（$1\le j\le k$）满足 $B_j\le A_i$，然后令 $B_j\gets A_i$。（注意这里是小于等于号。）
        - 如果无法选择这样的 $j$，则演出失败。
    - 否则，不需要做任何事。

然而，如果连续两次（或者更多次）选择不回应观众，那么观众就会生气，从而演出失败。

在演出不失败的前提下，确定 $k$ 的最小值。
## 输入格式


如下所示：


> $N$ \
> $A_1$ $A_2$ $\cdots$ $A_N$
## 输出格式

输出一行一个正整数，表示满足条件的 $k$ 的最小值。

## 样例

### 样例输入 #1
```
5
5 3 4 2 1
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
6
2 1 1 2 2 1
```
### 样例输出 #2
```
1
```
### 样例输入 #3
```
10
2 4 6 7 4 5 5 3 4 1
```
### 样例输出 #3
```
3
```
## 提示


### 样例解释

#### 样例 $1$ 解释

$k=2$ 时，在五次演出中分别选择：

- 不回应；
- 回应，$j=1$（此后 $B_1\gets 3$）；
- 回应，$j=1$（此后 $B_1\gets 4$）；
- 回应，$j=2$（此后 $B_2\gets 2$）；
- 不回应；

可以证明 $k=1$ 时演出必定失败。所以输出 $2$。

该样例满足子任务 $1,3\sim 7$ 的限制。


#### 样例 $2$ 解释

$k=1$ 时，在第 $1,6$ 个演出时选择不回应即可。

该样例满足所有子任务的限制。


#### 样例 $3$ 解释

该样例满足子任务 $1,4\sim 7$ 的限制。




### 数据范围

- $2\le N\le 5\times 10^6$。
- $1\le A_i\le 21$（$1\le i\le N$）。
- 输入的值全部是整数。

### 子任务

1. （10pts）$N\le 15$。
2. （6pts）$N\le 500$，$A_i\le 2$（$1\le i\le N$）。
3. （12pts）$N\le 500$，$A_i\le 5$（$1\le i\le N$）。
4. （18pts）$N\le 500$，$A_i\le 15$（$1\le i\le N$）。
5. （26pts）$N\le 5\times 10^5$，$A_i\le 15$（$1\le i\le N$）。
6. （10pts）$N\le 5\times 10^5$。
7. （18pts）无额外限制。


---

---
title: "[USACO25JAN] Photo Op G"
layout: "post"
diff: 省选/NOI-
pid: P11675
tag: ['USACO', '2025']
---
# [USACO25JAN] Photo Op G
## 题目描述

Farmer John 的农场充满了茂盛的植被，每头奶牛都想拥有一张这里的自然美景的照片。不幸的是，Bessie 还有其他地方要去，但她不想打扰任何摄影活动。

Bessie 目前站在 xy 平面上 $(X,0)$ 处，她想要前往 $(0,Y)$（$1\le X,Y\le 10^6$）。不幸的是，$N$（$1 \leq N \leq 3 \cdot 10^5$）头其他奶牛决定在 $x$ 轴上摆姿势。更具体地说，奶牛 $i$ 将位于 $(x_i,0)$，她的摄影师位于 $(0,y_i)$（$1 \leq x_i,y_i \leq 10^6$），准备拍摄她的照片。他们将在时刻 $s_i$（$1 \leq s_i < T$）开始摆姿势，并且他们会保持姿势很长时间（他们必须拍出完美的照片）。这里，$1\le T\le N+1$。

Bessie 知道每头奶牛的摄影安排，她将选择最短欧几里得距离到达目的地，而不穿越任何摄影师与其对应的奶牛之间的视线（她的路径将由一条或多条线段组成）。

如果 Bessie 在时刻 $t$ 出发，她将避开所有在时刻 $s_i \le t$ 开始摆姿势的摄影师-奶牛对的视线，此外令她到达最终目的地的距离为 $d_t$。求从 $0$ 到 $T-1$ 的每一个整数 $t$ 的 $\lfloor d_t\rfloor$ 的值。
## 输入格式

输入的第一行包含 $N$ 和 $T$，为在 $x$ 轴上摆姿势的奶牛数量及 Bessie 可以出发的时刻数量。

第二行包含 $X$ 和 $Y$，分别表示 Bessie 起始点的 $x$ 坐标以及目的地的 $y$ 坐标。

以下 $N$ 行包含 $s_i$，$x_i$ 和 $y_i$。输入保证所有的 $x_i$ 各不相同且与 $X$ 不同，所有的 $y_i$ 各不相同且与 $Y$ 不同。所有 $s_i$ 将按升序给出，即 $s_i \leq s_{i+1}$。
## 输出格式

输出 $T$ 行，第 $t$ 行（从 0 开始索引）包含 $\lfloor d_t\rfloor$。

## 样例

### 样例输入 #1
```
4 5
6 7
1 7 5
2 4 4
3 1 6
4 2 9
```
### 样例输出 #1
```
9
9
9
10
12
```
### 样例输入 #2
```
2 3
10 7
1 2 10
1 9 1
```
### 样例输出 #2
```
12
16
16
```
### 样例输入 #3
```
5 6
8 9
1 3 5
1 4 1
3 10 7
4 9 2
5 6 6
```
### 样例输出 #3
```
12
12
12
12
14
14
```
## 提示

样例 2 解释：

对于 $t=0$ 答案为 $\lfloor \sqrt{149} \rfloor=12$。

对于 $t=1$ 答案为 $\lfloor 14+\sqrt 5\rfloor=16$。

样例 3 解释：

对于 $t=5$ 答案为 $\lfloor 1+\sqrt{9^2+7^2}+2\rfloor=14$。路径：$(8,0)\to (9,0)\to (0,7)\to (0,9)$。

- 测试点 $4\sim 6$：$N\le 100$。
- 测试点 $7\sim 9$：$N\le 3000$。
- 测试点 $10\sim 12$：$T\le 10$。
- 测试点 $13\sim 18$：没有额外限制。


---

---
title: "[ROIR 2025] 酸雨"
layout: "post"
diff: 省选/NOI-
pid: P11699
tag: ['2025', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2025] 酸雨
## 题目背景

翻译自 [ROIR 2025 D1T3](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。
## 题目描述

有 $n$ 个模块被运送到金星上用于组装实验室。模块按顺序排列，第 $i$ 个模块的高度为 $h_i$。

组装工作将由一台特殊的机器人来完成。在组装过程中，连续的模块段将逐渐合并，而模块在排列中的顺序不会改变。最初，每个模块都是一个独立的段，段的编号从 $1$ 到 $n$，与模块的编号顺序相同。如果有两个相邻的模块段 $A = [i, i+1, \dots, i+p-1]$ 和 $B = [i+p, i+p+1, \dots, i+p+q-1]$，那么它们合并后变成段 $AB = [i, i+1, \dots, i+p-1, i+p, i+p+1, \dots, i+p+q-1]$。

组装指令由 $n-1$ 条指令组成。每条指令包含一个数字 $k_j$。执行该指令后，编号为 $k_j$ 和 $k_j + 1$ 的模块段合并为一个新段，合并后的段占据原来两个段的位置，并重新对段进行编号，从 $k_j + 2$ 开始，后面的段的编号依次减 $1$。执行完所有指令后，所有段将合并为一个段。

金星上常年下酸雨，因此在组装过程中，必须在每次合并后了解每个段中可能积累的液体量。设一个段包含高度为 $h_l, h_{l+1}, \dots, h_r$ 的模块。对于其中任意一个模块 $p$，其中 $l \leq p \leq r$，我们定义该模块 $p$ 在该段的深度 $d_p$ 如下：

首先计算左侧最大高度 $l_p = \max\{ h_l, h_{l+1}, \dots, h_p \}$ 和右侧最大高度 $r_p = \max\{ h_p, h_{p+1}, \dots, h_r \}$。这分别是该段中模块 $p$ 左侧和右侧的最大高度。该模块 $p$ 的深度定义为 $d_p = \min(l_p, r_p) - h_p$，显然 $d_p > 0$。段的容量定义为该段所有模块的深度之和，即 $w = d_l + d_{l+1} + \dots + d_r$。

给定一系列合并操作，请在每次合并后输出合并段的容量。
## 输入格式

第一行包含一个整数 $n$，表示模块的数量（$2 \leq n \leq 10^5$）。

第二行包含 $n$ 个整数 $h_1, h_2, \dots, h_n$（$1 \leq h_i \leq 10^9$），表示每个模块的高度。

第三行包含 $n-1$ 个整数，表示合并操作的指令，每个指令用一个整数 $k_j$ 表示（$1 \leq k_j \leq n-j$）。
## 输出格式

输出 $n-1$ 个整数，用换行隔开，表示每次合并后，合并段的容量。
## 样例

### 样例输入 #1
```
8
9 1 8 1 5 2 3 6
3 3 1 3 3 2 1

```
### 样例输出 #1
```
0
4
0
0
0
13
20
```
## 提示

下图显示了样例中指令执行的过程，每个模块上方标出了其深度，并显示了新段的容量。

![](https://cdn.luogu.com.cn/upload/image_hosting/na9xfgva.png)

本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。

| 子任务 | 分数 | 特殊性质 |
| :------: | :----: | :--------: |
| $1$      | $13  $ | $n \leq 100$ |
| $2 $     | $13  $ | $n \leq 1000$ |
| $3  $    | $13  $ | $h_i \leq 10$ |
| $4  $    | $13  $ | $\exist i,h_1 \ge h_2 \ge \dots \ge h_i \leq \dots \leq h_n$ |
| $5  $    | $7  $  | 所有查询中 $k_j = 1$ |
| $6  $    | $13$   | $n \leq 40000$ |
| $7  $    | $28$   | 无 |


---

---
title: "[ROIR 2025] 寻找宝藏"
layout: "post"
diff: 省选/NOI-
pid: P11700
tag: ['2025', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2025] 寻找宝藏
## 题目背景

翻译自 [ROIR 2025 D1T4](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day1.pdf)。
## 题目描述

为了寻找有用的矿产资源，科学家们开发了一种特殊的扫描仪。

假设搜索区域是一个包含 $k$ 行和 $n$ 列的表格。行号从上到下编号为 $1$ 到 $k$，列号从左到右编号为 $1$ 到 $n$。每个单元格中可能含有矿产资源。  

扫描仪的工作原理如下：它可以从第 $p$ 列启动，并返回扫描区域内包含矿产资源的单元格数。扫描区域包括第 $p$ 列的所有单元格、第 $p-1$ 列的前 $k-1$ 个单元格、第 $p-2$ 列的前 $k-2$ 个单元格，以此类推。下图展示了当 $k=3$，$n=5$ 时，所有可能的 $p$ 值的扫描区域。

![](https://cdn.luogu.com.cn/upload/image_hosting/91a4kisv.png)

现在，给定扫描仪返回的每个 $p$ 值的结果，记为 $b_p$，即在第 $p$ 列的扫描区域内，矿产资源的数量。如果一个表格的矿产资源分布能匹配扫描仪的返回值，则称这个表格是“合法的”。比如，若扫描仪返回值为 $[2, 1, 2, 3, 2]$，则其中一个合法的表格可能如下所示（含有矿产的单元格用黑色三角形表示）：

![](https://cdn.luogu.com.cn/upload/image_hosting/yez7rrpa.png)

你需要根据给定的扫描结果，确定合法表格的数量，并输出其对 $10^9 + 7$ 取模的结果。注意，扫描仪可能存在故障，导致没有任何合法的表格，这种情况下应输出 $0$。
## 输入格式

第一行输入两个整数 $n, k$，分别表示列数和行数（$1 \leq n \leq 200, 1 \leq k \leq 7$）。

第二行输入 $n$ 个整数 $b_1, b_2, \dots, b_n$，表示扫描仪返回的每个列的矿产数量（$0 \leq b_i \leq k^2$）。
## 输出格式

输出一个整数，表示正确表格的数量对 $10^9 + 7$ 取模的结果。如果没有正确的表格，输出 $0$。
## 样例

### 样例输入 #1
```
5 3
2 1 2 3 2

```
### 样例输出 #1
```
24
```
## 提示

本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。


| 子任务 | 分数 | 特殊性质 |
|:--------:|:------:|:----------:|
| $1$      | $7   $ | $k \leq 2$ | 第一子任务 |
| $2 $     | $9    $| $k \leq 3$ | 第一、二子任务 |
| $3  $    | $9   $ | $k \leq 4$ | 第一、二、三子任务 |
| $4  $    | $20  $ | $k \leq 5$ | 第一至四子任务 |
| $5  $    | $15 $  | $k \leq 6$ | 第一至五子任务 |
| $6  $    | $10 $  | $1 \leq n \cdot k \leq 25$ | 第一至五子任务 |
| $7$      | $30$   | 无 | 第一至六子任务 |


---

---
title: "[ROIR 2025] 旅行路线"
layout: "post"
diff: 省选/NOI-
pid: P11704
tag: ['2025', 'Special Judge', 'ROIR（俄罗斯）']
---
# [ROIR 2025] 旅行路线
## 题目背景

翻译自 [ROIR 2025 D2T4](https://neerc.ifmo.ru/school/archive/2024-2025/ru-olymp-regional-2025-day2.pdf)。
## 题目描述

一群学生来到一座新城市游览，决定参观这里的名胜古迹。这座城市可以看作一个 $n \times m$ 的矩形网格，其中某些格子上有景点。

他们从格子 $(1, 1)$ 开始旅程，想要先到达格子 $(n, m)$，然后再返回起点。此外，城市中有 $k$ 个景点，位于格子 $(x_1, y_1), \dots, (x_k, y_k)$，他们一定要全部参观到。

![原题一个不明觉厉的配图](https://cdn.luogu.com.cn/upload/image_hosting/spktsj97.png)

他们可以花费一分钟从格子 $(a, b)$ 移动到与之相邻（即满足 $|a - c| + |b - d| = 1$）的格子 $(c, d)$。显然，完成整个路线至少需要 $2n + 2m - 4$ 分钟。

我们称一条路线为“有趣的”，如果它满足以下条件：

- 完成该路线所需的时间恰好是 $2n + 2m - 4$ 分钟；
- 路线中的每个格子最多经过一次；
- 路线必须经过所有包含景点的格子。

请帮助他们计算一共有多少条不同的有趣的路线。由于结果可能很大，只需要输出其对 $10^9 + 7$ 取模的结果。
## 输入格式

第一行输入三个整数  $n$，$m$ 和 $k$（$3 \leq n, m \leq 10^6$，$0 \leq k \leq 2000$）。

接下来 $k$ 行，每行包含两个整数 $x_i$ 和 $y_i$（$1 \leq x_i \leq n$，$1 \leq y_i \leq m$）。保证所有的 $(x_i, y_i)$ 都是不同的，即 $\forall (i, j), x_i \neq x_j \vee y_i \neq y_j$。
## 输出格式

输出一个整数，表示有趣的路线的数量对 $10^9 + 7$ 取模的结果。
## 样例

### 样例输入 #1
```
3 4 2
2 2
2 3
```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
3 4 3
3 1
2 3
1 4
```
### 样例输出 #2
```
0
```
## 提示

下图展示了样例一中所有有趣的路线，其中带有星号的格子存在名胜古迹。

![](https://cdn.luogu.com.cn/upload/image_hosting/kzbt6reo.png)

本题使用 Subtask 捆绑测试。数据中 Subtask 0 是样例。

|子任务|分数|特殊性质|
|:-:|:-:|:-:|
|$1$|$5$|$n=3$，$m, k \leq 100$|
|$2$|$9$|$n, m, k \leq 5$|
|$3$|$6$|$n, m, k \leq 8$|
|$4$|$17$|$n, m, k \leq 30$|
|$5$|$16$|$n, m, k \leq 100$|
|$6$|$8$|$k=0$|
|$7$|$11$|$k=1$|
|$8$|$12$|$k \leq 16$|
|$9$|$9$|$k \leq 100$|
|$10$|$7$|无|$


---

---
title: "Dynamic K-th Problem"
layout: "post"
diff: 省选/NOI-
pid: P11745
tag: ['O2优化']
---
# Dynamic K-th Problem
## 题目背景

> 萤火穿过风 融化成飞光 就在你眼眸盛放
## 题目描述

小 D 发现了一群萤虫，萤群中有 $n$ 个萤虫且按照顺序排成一行并将其从 $1$ 从 $n$ 编号。小 D 非常厉害，他一眼就看出这 $n$ 个萤虫的光度，且这些萤虫的亮度值是 $1\sim n$ 的一个排列。小 D 想找一些萤虫，让它们共同编织出如梦似幻的璀璨光幕，具体的，他需要一个 **萤虫区间**。

小 D 对 **萤虫区间** 定义苛刻：至少得有 $k$ 个萤虫且这些萤虫编号连续。

小 D 十分欣赏萤虫的光芒，他定义编号从 $L$ 到 $R$ 的萤虫区间的总体光度值为这些萤虫的光度值中的第 $m$ 大数。小 D 给定了 $Q$ 个指标，每个指标给定一个数 $x$，寻找一个 **萤虫区间** 使得这个区间的总体光度值大于等于 $x$。当然，这种区间是很多的，你需要帮小 D 数有多少这样的区间。

## 输入格式

第一行五个整数 $n,k,m,B,cas$，其中 $B$ 是给定常数，$cas$ 是当前数据点所属的 Subtask 编号。

第二行空格隔开的 $n$ 个数字 $a_i$，表示 $n$ 个萤虫的光度值。用给定代码生成。

第三行一个整数 $Q$，表示给定指标个数。  

第四行空格隔开的 $Q$ 个数字，表示每次询问的指标 $x$，用给定代码生成。

**本题输入量较大，输入数据可以用以下代码生成：**[在此可查看完整代码](https://www.luogu.com.cn/paste/izknxvwf)。

```cpp
// 请注意避免整形溢出 
#define int long long
const int N = 1e6 + 5, INF = 2147483647;
int n, k, m, B, Q, x, a[N], cas;
// myrand 为数据生成器 
struct myrand {
	int A, B, P, x;
	myrand(int A, int B, int P, int x) {
		this->A = A; this->B = B; this->P = P; this->x = x;
	} int next() { return x = (A * x + B) % P; }
};
int read_x(int x) { // 不同数据下的 x 不同
	if (cas == 7) x = x % 2;
	else x = x % (n + 1);
	return x;
}
signed main() {
	cin >> n >> k >> m >> B >> cas >> Q;	
	// B 是生成数据是给定常数。在此初始化数据生成器 myrand 参数 
	myrand rnd(16807, B, INF, 0);
	// 伪随机生成 a 序列 
	for (int i = 1; i <= n; i++) a[i] = i;
	for (int i = 1; i <= n; i++) {
		int l = rnd.next() % n + 1, r = rnd.next() % n + 1;
		swap(a[l], a[r]);
	}
	// 生成查询指标 
	for (int i = 1; i <= Q; i++) x = read_x(rnd.next());
}
```

你只需要以上述代码为准，进行输入即可。具体操作解释请参见样例解释。**本题解法和数据的生成方式无关**。
## 输出格式

对于每一个询问指标，都需要求出对应萤虫区间个数。

为了避免输出过多，请输出 $Q$ 次查询中萤虫区间个数的 **异或和**。具体操作解释请参见样例解释。
## 样例

### 样例输入 #1
```
5 3 2 999 1
5
```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
6 3 2 998 1
5
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
1000000 10000 1 998244353 4
1000000
```
### 样例输出 #3
```
306558155574
```
### 样例输入 #4
```
1000000 10000 2 998244353 5
1000000
```
### 样例输出 #4
```
39831215473
```
### 样例输入 #5
```
1000000 100000 100 1231 8
1000000
```
### 样例输出 #5
```
170979323511
```
## 提示

**【样例解释 $\mathbf 1$】**

萤虫从 $1$ 到 $n$ 的光度值为：$5,4,2,3,1$。总共有 $6$ 个萤虫区间，要求区间第 $2$ 大值，分别是：
* 编号 $1$ 至 $3$ 构成的萤虫为 $[5,4,2]$，总体光度值为 $4$。
* 编号 $2$ 至 $4$ 构成的萤虫为 $[4,2,3]$，总体光度值为 $3$。
* 编号 $3$ 至 $5$ 构成的萤虫为 $[2,3,1]$，总体光度值为 $2$。
* 编号 $1$ 至 $4$ 构成的萤虫为 $[5,4,2,3]$，总体光度值为 $4$。
* 编号 $2$ 至 $5$ 构成的萤虫为 $[4,2,3,1]$，总体光度值为 $3$。
* 编号 $1$ 至 $5$ 构成的萤虫为 $[5,4,2,3,1]$，总体光度值为 $4$。

共有 $5$ 次询问，询问指标分别是 $2,2,2,0,2$，则答案分别是：$6,6,6,6,6$。则总异或值为 $6$。

**【样例解释 $\mathbf 2$】**

萤虫从 $1$ 到 $n$ 的光度值为：$3,1,4,2,5,6$。

共有 $5$ 次询问，询问指标分别是 $1,5,1,4,6$，答案分别是：$10,4,10,7,0$。则总异或值为 $3$。

**【样例解释 $\mathbf 3$】** 该数据满足 `Subtask 4` 的限制。具体求解不做解释。请注意整形溢出相关问题。

**【样例解释 $\mathbf 4$】** 该数据满足 `Subtask 5` 的限制。具体求解不做解释。

**【样例解释 $\mathbf 5$】** 该数据满足 `Subtask 8` 的限制。具体求解不做解释。


---


**【数据规模与约定】**


**本题开启子任务捆绑测试**。本题输入输出量一点不大，但请注意优化常数。本题自动开启 O2 优化。



* Subtask 1（10 pts）：$m\leq n\leq 100$，$Q\leq 100$。
* Subtask 2（10 pts）：$m\leq n\leq 1000$，$Q\leq 100$。
* Subtask 3（18 pts）：$n\leq 10^5$，$m\leq 100$。
* Subtask 4（9 pts）：$n\leq 10^6$，$m=1$。
* Subtask 5（9 pts）：$n\leq 10^6$，$m=2$。
* Subtask 6（15 pts）：$n\leq 10^6$，$k=m\leq 100$。
* Subtask 7（7 pts）：$n\leq 10^6$，$m\leq 100$，$0\leq x\leq 1$。
* Subtask 8（22 pts）：$n\leq 10^6$，$m\leq 100$。

对于所有测试点满足 $1\leq m\leq k\leq n\leq 10^6$，$m\leq \min\{1000,n\}$，$1\leq a_i\leq n$，$1\leq Q\leq 10^6$，$1\leq B\leq 10^9$。



---

---
title: "Dynamic Color Problem"
layout: "post"
diff: 省选/NOI-
pid: P11746
tag: ['O2优化']
---
# Dynamic Color Problem
## 题目描述

你在和 AI 下『连子棋』！你们有黑白两个颜色的棋子。

这盘棋的规则是：双方轮流下棋，棋子放满整个棋盘后，再来统计分数。如果每有一整行或一整列颜色 **不完全相同**，那么你就获得 $1$ 分。如果每有一整行或一整列颜色 **完全相同**，那么 AI 就获得 $1$ 分。当你的分数为奇数且 AI 的分数为偶数时，那么你就胜利了！否则，AI 胜利。

你和 AI 对弈了 $T$ 局，第 $i$ 局的棋盘大小为 $n\times m $。双方每一回合都可以选择下黑或者下白，下棋的位置不能和之前重复。那么请计算棋盘最终形态的方案数使得你能获胜。

两种下棋方式不同，当且仅当最终棋盘的形态不同，即棋盘上存在一个位置，使得两种棋盘在此位置的颜色不同。答案可能很大，请对 $998244353$ 取模。

## 输入格式

第一行一个整数 $T$，代表你和 AI 对弈的局数。

接下来有 $T$ 行，每行两个整数 $n,m$，表示棋盘的大小为 $n\times m$。
## 输出格式

输出 $T$ 行整数，第 $i$ 行整数表示第 $i$ 局你获胜的方案数。
## 样例

### 样例输入 #1
```
5
2 2
2 3
2 5
4 3
4 5
```
### 样例输出 #1
```
0
32
512
2240
608864
```
### 样例输入 #2
```
4
1000 999
1000000 999999
999999 1000000
677777 66778

```
### 样例输出 #2
```
163503730
154415889
154415889
127032970
```
## 提示

**【样例解释 $\mathbf 1$】**

对于第 $2$ 局棋盘大小 $2\times 3$ 有下列两种棋盘形式（总共 $32$ 种棋盘形式，不一一列出）：

![](https://cdn.luogu.com.cn/upload/image_hosting/3dt0b498.png)

上面两种情况，你获得 $3$ 分，AI 获得 $2$ 分，故你获胜。

---

**【数据规模与约定】**


**本题开启子任务捆绑测试**。本题自动开启 O2 优化。
* Subtask 1（15 pts）：$2\leq n,m\leq 4$。
* Subtask 2（15 pts）：$2\leq n,m\leq 6$。
* Subtask 3（8 pts）：$2\leq n,m\leq 20$。
* Subtask 4（8 pts）：$2\leq n,m\leq 100$。
* Subtask 5（10 pts）：$2\leq n,m\leq 1000$。
* Subtask 6（44 pts）：$2\leq n,m\leq 10^6$。


对于所有测试点满足 $1\leq T\leq 5$，$2\leq n,m\leq 10^6$。



---

---
title: "[COTS 2013] 集合合并 / RAZGOVORI"
layout: "post"
diff: 省选/NOI-
pid: P11775
tag: ['2013', 'Special Judge', 'COCI（克罗地亚）']
---
# [COTS 2013] 集合合并 / RAZGOVORI
## 题目描述

给定 $n$ 个集合，第 $i$ 个集合内开始只有元素 $i$。

你每天可以进行任意次这样的操作：

- 选择两个集合 $A,B$，令 $C=A \cup B$，让 $A
\gets C,B\gets C$。对于一个集合，你每天只能选择一次。

你需要求出最小的天数，使得操作完后每个集合都为 $\{1,2,3,\dots,n\}$。

## 输入格式

一行一个整数 $n$。
## 输出格式

若干行。对于每一天的开始，都要输出 `jutro`，然后输出若干行，每行两个整数，表示选择的两个集合。

在完成全部操作后，需要在最后打印 `kraj`。

## 样例

### 样例输入 #1
```
2
```
### 样例输出 #1
```
jutro 
1 2 
kraj
```
### 样例输入 #2
```
3
```
### 样例输出 #2
```
jutro 
1 2 
jutro 
1 3 
jutro 
2 3 
kraj
```
### 样例输入 #3
```
4
```
### 样例输出 #3
```
jutro 
1 2 
3 4 
jutro 
1 3 
2 4 
kraj
```
## 提示

首先，天数不能超过 $500$ 天。对于一个测试点，如果你的方案的天数和答案相同且合法，你可以 $10 \%$ 的分数。

否则如果方案合法，且最终每个集合均为 $\{1,2,3,\dots,n\}$，记你实现的天数为 $ans$，答案天数为 $ans1$，你该测试点得分为：

$$\max(1,9-2\times (ans-ans1))$$


对于 $100 \%$ 的数据，满足 $1\le n \le 1000$。


---

---
title: "[COTS 2013] 图形计数 / POLIGONI"
layout: "post"
diff: 省选/NOI-
pid: P11776
tag: ['2013', 'COCI（克罗地亚）']
---
# [COTS 2013] 图形计数 / POLIGONI
## 题目描述

枚举平面直角坐标系具有下列性质的多边形：

- 多边形顶点为坐标系整数点。
- 多边形每条边平行于坐标轴。
- 对于顶点 $(x,y)$，满足 $0 \le x \le N,0\le y\le K$。

形状相同，位置不同的两个多边形我们认为是不同的，且根据定义，多边形的边是一条不接触自身的闭合多边形线。

下图显示了一个合法的多边形：

![](https://cdn.luogu.com.cn/upload/image_hosting/at50ulf8.png)

下图显示了两个不合法的多边形：

![](https://cdn.luogu.com.cn/upload/image_hosting/snvgig3p.png)
## 输入格式

一行两个整数 $K,N$。
## 输出格式

一行一个整数，为多边形的数量，答案对 $10007$ 取模。
## 样例

### 样例输入 #1
```
2 2 
```
### 样例输出 #1
```
13
```
### 样例输入 #2
```
3 2
```
### 样例输出 #2
```
40
```
### 样例输入 #3
```
3 3 
```
### 样例输出 #3
```
213 
```
## 提示

【数据范围与约定】

- 对于所有数据，均满足 $1\le K \le 6,1 \le N \le 1000$。

| 测试点编号 | $K=$ | $N\le$ | 特殊性质 | 分值 |
| -----------: | -----------: | -----------: | -----------: | -----------: |
| $1$ | $1$ | $1000$ | 是 | $5$  |
| $2$ | $1$ | $1000$ | 否 | $5$ |
| $3$ | $2$ | $1000$ | 是 | $5$ |
| $4$ | $2$ |$1000$  | 否 | $5$  |
| $5$ | $3$ | $1000$ | 是 | $10$ |
| $6$ | $3$ |$1000$  | 否 |$10$  |
| $7$ | $4$ |$1000$  | 是 | $10$ |
| $8$ | $4$ | $1000$ | 否 | $10$ |
| $9,10$ | $5$ | $1000$ | 否 |$10$  |
| $11,12$ | $6$ |$1000$  | 否  |$10$  |

- 特殊性质： $N\times K \le 20$。


---

---
title: "[COTS 2012] 网格覆盖 / ARHIPELAG"
layout: "post"
diff: 省选/NOI-
pid: P11778
tag: ['2012', 'COCI（克罗地亚）']
---
# [COTS 2012] 网格覆盖 / ARHIPELAG
## 题目描述

给定一个 $n\times m$ 的网格，每个网格上有一个数字。开始的时候所有的网格都是黑色。

但是过了 $t$ 秒后，所有网格上数字 $\le t$ 的网格会变为白色。

多组询问，每次给出一个 $t$，希望你求出 $t$ 秒后，有多少对黑色的四连通块的形状完全相同（不可旋转、对称）？
## 输入格式

一行两个整数 $n,m$，表示网格大小。

在接下来的 $n$ 行中，每行 $m$ 个整数，表示网格上的数字。

接下来一行一个整数 $Q$，表示询问次数。

下一行给定 $Q$ 个升序的自然数，表示时间。
## 输出格式

$Q$ 行，一行一个整数 $x$，表示黑色的四连通块大小相等的对数。
## 样例

### 样例输入 #1
```
5 6 
100 2 3 4 5 6  
20 4 45 12 3 4  
0 0 1 2 3 0  
0 0 0 0 0 0 
0 0 1 2 3 0 
3 
1 4 10 
```
### 样例输出 #1
```
0
1
0

```
### 样例输入 #2
```
7 6 
5 8 0 9 7 6 
7 0 0 9 2 6 
8 0 6 7 9 7 
0 0 8 7 0 0 
0 5 0 0 3 2 
0 9 0 0 6 0 
8 1 0 0 7 0 
1 
5 
```
### 样例输出 #2
```
4
```
## 提示


【样例解释】

![](https://cdn.luogu.com.cn/upload/image_hosting/4jk7c6se.png)

这是关于样例 $2$ 的图片解释。

【数据范围与约定】

记网格中 $(i,j)$ 位置的数为 $a_{i,j}$。

对于 $50 \%$ 的数据，满足 $n,m,q \le 50$。

对于 $100 \%$ 的数据，满足 $3\le n,m \le 10^3,1 \le Q \le 10^5,0\le a_{i,j}\le10^9$。




---

---
title: "[JOI 2016 Final] 铁路票价 / Train Fare"
layout: "post"
diff: 省选/NOI-
pid: P11795
tag: ['2016', 'JOI（日本）']
---
# [JOI 2016 Final] 铁路票价 / Train Fare
## 题目描述

JOI 国有 $N$  个城市，编号分别为 $1, 2, \ldots, N$ 。城市 $1$  是 JOI 国的首都。  

JOI 国只有一家铁路公司，该公司在 JOI 国内共有 $M$  条线路，这些线路编号分别为 $1, 2, \ldots, M$ 。每条线路都可看作一条无向边，线路 $i(1\le i\le N)$  连接城市 $U_i$  和 $V_i$ 。假设你只能依靠铁路运输在不同的城市间来往。当然你可以换乘不同线路。保证任意两个城市间都有线路直接或间接连接。  

目前，任何线路的票价是 1 日元。该公司经营不善，只好计划在未来 $Q$  年里提高票价。从提价计划开始的第 $j$  年初 $(1\le j\le Q)$ ，线路 $R_j$  的票价会从 1 日元升至 2 日元。 之后该线路票价一直保持在 2 日元，不会再提高。

该公司每年都会对每个城市的居民进行满意度调查。在提价计划开始之前，任何一个城市的居民都对该公司感到满意。但由于价格上涨，可能有一些城市的居民会不满。每年的满意度调查都在当年提价后进行。因此，计划开始后第 $j$  年 $(1\le j\le Q)$ 进行满意度调查时，线路 $R_1,R_2,\ldots,R_j$  已经提价，剩余线路的票价暂无变化。  

在第 $j$  年的满意度调查中，如果**当年城市 $k(2\le k\le N)$  到首都的最低总票价 大于 提价计划开始前城市 $k$  到首都的最低总票价**，城市 $k$  的居民会对铁路公司感到不满。  

使用多条路线的费用是每条路线的运费的总和。首都人民不会对该公司感到不满。提价后最低费用的路线可能与计划开始前最低费用的路线有所不同。
## 输入格式

第一行有三个整数 $N, M, Q$ ，用空格分隔。  
在接下来的 $M$  行中，第 $i(1\le i\le M)$  行有两个整数 $U_i,V_i$ ，用空格分隔。  
在接下来的 $Q$  行中，第 $j(1\le i\le Q)$  行有一个整数 $R_j$。
## 输出格式

输出共 $Q$  行，第 $j(1\le i\le Q)$  行有一个整数，表示在计划开始后第 $j$  年的满意度调查中，有多少个城市的居民对铁路公司不满。
## 样例

### 样例输入 #1
```
5 6 5
1 2
1 3
4 2
3 2
2 5
5 3
5
2
4
1
3
```
### 样例输出 #1
```
0
2
2
4
4
```
### 样例输入 #2
```
4 6 6
1 2
1 3
1 4
2 3
2 4
3 4
1
4
2
5
3
6
```
### 样例输出 #2
```
1
1
2
2
3
3
```
### 样例输入 #3
```
2 1 1
1 2
1
```
### 样例输出 #3
```
1
```
## 提示

【数据范围与约定】

对于全部数据，均满足：

- $2\le N\le 100000,1\le Q\le M\le 200000$。
- $1 \le U_i \le N (1\le i\le M),1\le V_i\le N (1\le i\le M),U_i \neq V_i(1\le i\le M)$。
- $1\le R_j\le M (1\le j\le Q),R_j\neq R_k(1\le j<k\le Q)$。
- 对于任意两个城市，直接连接它们的线路不超过一条。
- 对于任何一个城市，都可以从该城市前往另一个城市。

---

1.Subtask $1$ （$12$ pts）：$N\le 100,M\le 4950,Q\le 30$。

2.Subtask $2$ （$14$ pts）：$Q\le 30$。

3.Subtask $3$ （$35$ pts）：答案中出现的整数少于 $50$ 种。

4.Subtask $4$ （$39$ pts）：无特殊限制。


---

---
title: "【MX-X9-T6】『GROI-R3』Graph"
layout: "post"
diff: 省选/NOI-
pid: P11802
tag: ['O2优化', '梦熊比赛']
---
# 【MX-X9-T6】『GROI-R3』Graph
## 题目描述

给定一张 $n$ 个点的有向图 $G=(V,E)$，点的编号为 $1 \sim n$，其每个点都入度、出度均不大于 $1$。

在出度不大于 $1$ 的有向图中，我们记 $f^k(x)$ 表示点 $x$ 在图上沿着出边走 $k$ 步走到的点（如果走到一个不存在出边的点，则停在该点上）。

进一步定义 $G^k=(V,E')$，其中 $E'=\{(x,f^k(x))\mid x\in V\}$。我们称 $G$ 为 $G^k$ 的 $k$ 次方根。

若一个点入度出度均为 $0$ 则称其为孤立点。

又给定一个正整数 $c$，你需要给 $G$ 增加若干条边得到图 $G'$，使得：

1. 每个节点的入度出度均为 $1$。
2. 若两个非孤立点在 $G'$ 上位于同一连通块$^{\dagger}$，则在 $G$ 上也要位于同一连通块。
3. 图 $G'$ 存在 $c$ 次方根。

求加边的方案总数，答案对 $998244353$ 取模。

$^{\dagger}$：本题中定义有向图连通块为：将所有边视作无向边得到的连通块。
## 输入格式

第一行，两个正整数 $n,c$。

第二行，$n$ 个整数，第 $i$ 个表示点 $i$ 的出边指向的点的编号，若为 $-1$ 则表示无出边。
## 输出格式

仅一行，一个整数，表示答案对 $998244353$ 取模后的值。
## 样例

### 样例输入 #1
```
5 4
2 5 -1 -1 -1

```
### 样例输出 #1
```
3

```
### 样例输入 #2
```
9 7
7 -1 -1 -1 8 1 -1 -1 5

```
### 样例输出 #2
```
60

```
### 样例输入 #3
```
8 10
-1 -1 4 -1 -1 -1 -1 -1

```
### 样例输出 #3
```
1266

```
## 提示

令 $a_i$ 表示点 $i$ 的出边指向点的编号。

**【样例解释 #1】**

合法的序列 $a_1,\ldots,a_n$ 有：

- $2,5,1,3,4$。
- $2,5,3,4,1$。
- $2,5,4,1,3$。

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | $n\le$ | $c\le$ | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 1 | $5$ | $5$ |  | $2$ |
| 2 | $1000$ | $2\times10^9$ | A | $3$ |
| 3 | $10$ | $2\times10^9$ |  | $15$ |
| 4 | $20$ | $2\times10^9$ |  | $10$ |
| 5 | $100$ | $2\times10^9$ |  | $25$ |
| 6 | $500$ | $2\times10^9$ | B | $10$ |
| 7 | $500$ | $2\times10^9$ |  | $20$ |
| 8 | $1000$ | $2\times10^9$ |  | $15$ |

- 特殊性质 A：保证不存在 $a_i=-1$。
- 特殊性质 B：保证所有 $a_i=-1$。

对于 $100\%$ 的数据，保证 $1\le n\le 1000$，$1\le c\le 2\times10^9$，$1\le a_i\le n$ 或 $a_i=-1$，不存在 $i\ne j$ 使得 $a_i=a_j$ 且 $a_i \ne -1$。


---

---
title: "「o.OI R1」na12xy"
layout: "post"
diff: 省选/NOI-
pid: P11866
tag: ['Special Judge', 'O2优化']
---
# 「o.OI R1」na12xy
## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/ji39b9bm.png)
## 题目描述

给定一个 $n$ 个节点的树，点编号从 $1$ 到 $n$。

你有一个 $n$ 个点初始无边的图，点编号从 $1$ 到 $n$，以及一个初始均为 $0$ 的整数序列 $a_1,a_2,\cdots,a_{12}$。

你可以进行任意次操作，操作有如下两种类型：

- `1 x y`：把 $a_x$ 赋值为 $y$。需要保证在所有 `1` 操作中，$y$ 互不相同。
- `2 x y`：连接编号为 $a_x$ 与 $a_y$ 的点。需要保证两者均不为 $0$。

请你构造这棵树，不能有重边、自环。
## 输入格式

第一行一个正整数 $n$。

接下来 $n-1$ 行每行两个正整数 $u,v$，表示在给定的树中节点 $u$ 与 $v$ 间有连边。
## 输出格式

第一行输出操作次数 $m$。

接下来 $m$ 行，每行输出操作 `1 x y` 或操作 `2 x y`。
## 样例

### 样例输入 #1
```
3
1 2
1 3
```
### 样例输出 #1
```
5
1 1 1
1 2 2
2 1 2
1 12 3
2 12 1
```
## 提示

**「数据范围」**

**本题采用捆绑测试与 Special Judge。**

对于所有测试数据，保证：

- $1 \leq n \leq 4 \times 10^5$。
- $1 \leq u,v \leq n$。

|子任务|$n \leq$|分值|
|:-:|:-:|:-:|
| $0$ | $2000$ | $33$ |
| $1$ | $4 \times 10^5$ | $67$ |


---

---
title: "[威海市赛2024] 状态图"
layout: "post"
diff: 省选/NOI-
pid: P11869
tag: []
---
# [威海市赛2024] 状态图
## 题目描述

小威在数电课上学到了状态转换图，比如下面这张：

![](https://cdn.luogu.com.cn/upload/image_hosting/v4suj7b6.png)

现在，他遇到了一个同步时序电路分析的问题，其状态转换图有一定的特点：

假设总共有 $n$ 个节点，分别为 $S_0, S_1, ..., S_{n-1}$。

当时钟信号下一个脉冲为"高（1）"时，节点 $S_x$ 转移到节点 $S_{(x*a+c) \bmod n}$；

当时钟信号下一个脉冲为"低（0）"时，节点 $S_x$ 转移到节点 $S_{(x*b+d) \bmod n}$。

而在本题中，时钟信号的脉冲序列为 101010....

现在小威想知道，对于给定的 $n, a, b, c, d$，是否存在一个时钟周期 $T$，使得从任意节点 $S_x$ 任意时刻（即初始脉冲可能为 0，也可能为 1）出发都能在 $T$ 个脉冲之后回到初始状态（状态包括节点和脉冲两个方面，两状态相同当且仅当节点和脉冲都相同），存在则输出最小的时钟周期 $T_{\min}$ ，否则输出 `inf`。
## 输入格式

第 1 行一个整数 $T$ 代表数据组数。

第 2 行到第 $T + 1$ 行每行五个整数 $n, a, b, c, d$，含义如上所述。

对于所有数据，满足：

- $1 \leq T \leq 1000$；
- $2 \leq n \leq 10^9$；
- $0 < a, b < n$；
- $0 \leq c, d < n$。

## 输出格式

$T$ 行，每行一个正整数或字符串表示答案，含义如上所述。
## 样例

### 样例输入 #1
```
3
5 2 1 3 4
6 2 1 3 5
1732 1233 627 911 1247
```
### 样例输出 #1
```
8
inf
864
```
### 样例输入 #2
```
10
3 2 2 2 1
5 2 3 4 2
6 1 3 1 0
5 3 3 2 1
5 4 2 4 1
9 2 5 6 2
6 4 1 1 3
6 1 1 5 1
8 4 7 0 3
9 1 7 3 8

```
### 样例输出 #2
```
6
10
inf
4
8
18
inf
2
inf
18

```
## 提示

样例 #1 解释如下：

对于第一组数据，节点的状态转换序列可以拆分如下（括号中的是脉冲高/低）：

$S_0(1) \to S_3(0) \to S_2(1) \to S_2(0) \to S_1(1) \to S_0(0) \to S_4(1) \to S_1(0)(\to S_0(1))$，8 个时刻一循环；

$S_3(1) \to S_4(0)(\to S_3(1))$，2 个时刻一循环；

取两个循环周期的最小公倍数 8 即是答案。

对于第二组数据，从 $S_0$ 出发，从 0 脉冲对应时刻开始转移，无论如何也无法回到起始状态（除初始时刻外，不存在同时让节点等于 $S_0$，脉冲为 0 的时刻）。


---

---
title: "[PA 2025] 乘数 / Mnożenie cyfr"
layout: "post"
diff: 省选/NOI-
pid: P11920
tag: ['2025', 'PA（波兰）']
---
# [PA 2025] 乘数 / Mnożenie cyfr
## 题目背景

PA 2025 R3B.

## 题目描述



对于非负整数 $n$，定义函数 $f(n)$：

- 令 $n$ 的十进制表示为 $\overline{a_1a_2\ldots a_k}$。
- 则 $f(n)=a_1a_2\cdots a_k$。

换言之，$f(n)$ 就是将 $n$ 十进制表示下的数位相乘得到的结果。

对于非负整数 $x$，按如下程序执行操作：

1. 若 $x\le 9$，终止操作；
2. 否则令 $x\gets f(x)$，回到 1。

> **举例**
>
> 1. $57\to 5\times 7=35\to 3\times 5=15\to 1\times 5=5$。
> 2. $255\to 2\times 5\times 5=50\to 5\times 0=0$。

可以证明，对于任意非负整数 $x$，这个操作都一定会终止。

$T$ 组数据，每组数据给定 $n$，对于 $i=0,1,\ldots,9$，求出：

- 有多少个 $1\le j\le n$ 满足将 $j$ 操作后最终会得到 $i$。
## 输入格式

**本题单个测试点内含有多组测试数据。**


第一行，一个正整数 $T$。

第二行，$T$ 个正整数 $n$，描述 $T$ 组数据。


## 输出格式

输出 $T$ 行，每行 $10$ 个非负整数，每行第 $i$ 个整数表示：

- 有多少个 $1\le j\le n$ 满足将 $j$ 操作后最终会得到 $i-1$。

## 样例

### 样例输入 #1
```
5
10 56 57 123 1
```
### 样例输出 #1
```
1 1 1 1 1 1 1 1 1 1
11 2 7 3 6 5 8 2 9 3
11 2 7 3 6 6 8 2 9 3
36 3 11 4 12 8 16 4 24 5
0 1 0 0 0 0 0 0 0 0
```
## 提示

- $1\le T\le 10^3$；
- $1\le n\le 10^{18}$。


---

---
title: "[PA 2025] 重金属 / Heavy Metal"
layout: "post"
diff: 省选/NOI-
pid: P11927
tag: ['2025', 'PA（波兰）']
---
# [PA 2025] 重金属 / Heavy Metal
## 题目背景

PA 2025 R5B.
## 题目描述


扩音系统由 $n$ 个路由器和 $m$ 个放大器组成。麦克风连接到第 $1$ 号路由器，扬声器连接到第 $n$ 号路由器。

每个放大器连接两个路由器（输入和输出），**增益系数**为 $w_i$。路由器的最大带宽为 $p_i$。  

麦克风的信号功率为 $1$。配置系统，使信号在放大器、路由器中传输。信号经过放大器后，功率会乘以该放大器的增益系数，但是为了避免烧毁，通过路由器的信号功率必须**不大于** $p_i$。

**信号可以多次通过同一路由器或放大器**。最终将信号传输到扬声器（到达 $n$ 号路由器），在路由器不烧毁的前提下，最大化信号的功率。求出可能的最大功率。


## 输入格式

**本题单个测试点内含有多组测试数据。**

第一行，正整数 $T$，表示测试数据组数。接下来依次描述 $T$ 组数据：

每组数据第一行，两个正整数 $n,m$。

每组数据第二行，$n$ 个正整数 $p_1,p_2,\ldots,p_n$。

每组数据接下来的 $m$ 行，每行三个正整数 $a_i,b_i,w_i$，表示放大器的输入路由器、输出路由器和增益系数。


## 输出格式



输出 $T$ 行，每行一个整数：

- 若能成功将信号传输到扬声器，输出可能的最大增益系数；
- 否则，输出一行一个 $-1$。  

## 样例

### 样例输入 #1
```
4
2 3
250 1000
1 1 2
1 2 3
2 1 37
3 5
500 800 1100
1 1 2
1 2 1
2 2 3
2 3 1
3 3 5
2 2
4 4
1 1 2
1 2 1
2 1
10 10
1 2 1000000000
```
### 样例输出 #1
```
666
1080
4
-1
```
## 提示



### 样例解释

$114(514)$ 表示，信号到达第 $114$ 个路由器时，功率为 $514$。

- 样例 $1$ 解释：

最优路径：$1(1)\to 1(1\times 2)\to 2(2\times 3)\to 1(6\times 37)\to 2(222\times 3)$。

- 样例 $2$ 解释：

最优路径：$1(1)\to 1(2)\to 1(4)\to 1(8)\to 2(8)\to 2(24)\to 2(72)\to 2(216)\to 3(216)\to 3(1080)$。  

- 样例 $3$ 解释：

最优路径：$1\to 1(2)\to 1(4)\to 2(4)$。

- 样例 $4$ 解释：路由器 $2$ 一定会被烧毁，所以无法传到路由器 $2$。

### 数据范围

- $1\le n,\sum n\le 100$；
- $1\le m,\sum m\le 200$；
- $1\le p_i\le 10^9$；
- $1\le a_i,b_i\le n$；
- $1\le w_i\le 10^9$。




---

---
title: "[PA 2025] 吃树叶 / Liście"
layout: "post"
diff: 省选/NOI-
pid: P11930
tag: ['2025', 'PA（波兰）']
---
# [PA 2025] 吃树叶 / Liście
## 题目背景

PA 2025 R5A.

**警告：滥用本题评测一次即可封号。**

[这里](https://www.luogu.com.cn/problem/U547677)提供了本题的部分测试点（你可以在**附件**中下载它们），**强烈建议上述题目提交通过后再提交本题。**

## 题目描述


有 $10^6$ 棵树，自西向东编号 $1\sim 10^6$。小恐龙的营地在第 $1$ 棵树西边。

![](https://cdn.luogu.com.cn/upload/image_hosting/x3sfvs1o.png)

在接下来的 $n$ 天中，小恐龙的饮食计划为：

- 第 $i$ 天，她将从营地步行到树 $a_i$，再返回营地。从营地去树 $a_i$ 的途中，她会摘下遇到的所有的树的 $v_i$ 片叶子（返程时不摘叶子）。

不难发现，每天，每棵树至多只被摘一次叶子。

一开始，$v_i=0$。有 $m$ 次修改：

- 第 $j$ 次修改将**前 $p_j$ 天的 $v_i$**（$i = 1, 2, \ldots, p_j$）每个增加 $w_j$。  

此外，修改间隙有 $z$ 次查询：  

- 第 $j$ 次查询：求出在前 $p_j$ 天中，第 $d_j$ 棵树被吃掉的总叶子数。

修改会影响所有后面的查询，但是每个查询之间是独立的。

## 输入格式

第一行，三个正整数 $n,m,z$。

第二行，$n$ 个正整数 $a_1,a_2,\ldots,a_n$。

接下来 $(m+z)$ 行，每行三个正整数：
- $\texttt{1}$ $p_j$ $w_j$，描述一次修改操作；
- $\texttt{2}$ $p_j$ $d_j$，描述一次查询操作。


## 输出格式


输出 $z$ 行，每行一个非负整数，表示查询的答案。

## 样例

### 样例输入 #1
```
3 2 4
3 4 1
2 3 1
1 2 10
2 1 2
2 3 1
1 3 1
2 3 2
```
### 样例输出 #1
```
0
10
20
22
```
## 提示

### 样例解释

饮食计划如下：

- 第 $1$ 天：前往 $a_1 = 3$ 号树；  
- 第 $2$ 天：前往 $a_2 = 4$ 号树；
- 第 $3$ 天：前往 $a_3 = 1$ 号树；

初始时所有 $v_1 = v_2 = v_3 = 0$，即实际上一片叶子都不会摘。

1. 第一次查询，问前 $3$ 天中，$1$ 号树被摘掉的叶子数。答案显然为 $0$。
2. 第一次修改，将前 $2$ 天的 $v_i$ 各增加 $10$。  
   此时 $v_1=10,v_2=10,v_3=0$。
3. 第二次查询，问第 $1$ 天中，$2$ 号树被摘掉的叶子数。

	由于第一天摘了 $2$ 号树的叶子，所以答案为 $10$。
4. 第三次查询，问前 $3$ 天中，$1$ 号树被摘掉的总叶子数。
	
    由于前两天都会摘 $1$ 号树的叶子，所以答案为 $10+10=20$。
5. 第二次修改，将前 $3$ 天的 $v_i$ 各加 $1$。  

   此时，$v_1=11,v_2=11,v_3=1$。

6. 第四次查询，问前 $3$ 天中，$2$ 号树摘掉的叶子数。
   
   答案为 $11 + 11 + 0 = 22$。  


### 数据范围

- $1 \leq n, m, z \leq 10^6$；
- $n \cdot m \cdot z \leq 10^{16}$；
- $1\le a_i,w_j,d_j\le 10^6$；
- $1\le p_j\le n$。

### 子任务

子任务 $0$ 为样例。

下表中，符号 $a \sim b$ 表示 $0.99 \cdot b < a \le b$。

| 子任务编号 | 限制 | 
|:-------:|---------|
| $1$ | $(m + z) \cdot n \le 10^7$ |
| $2$ | $z \cdot m \le 10^7$，$n \cdot m \cdot z \sim 10^{13}$ |
| $3$ | $n = 10^4$，$n \cdot m \cdot z \sim 10^{14}$ |
| $4$ | $m = 10^4$，$n \cdot m \cdot z \sim 10^{14}$ |
| $5$ | $z = 10^4$，$n \cdot m \cdot z \sim 10^{14}$ |
| $6$ | $n \cdot m \cdot z \sim 10^{14}$ |
| $7$ | $n = 10^4$，$n \cdot m \cdot z \sim 10^{16}$ |
| $8$ | $m = 10^4$，$n \cdot m \cdot z \sim 10^{16}$ |
| $9$ | $z = 10^4$，$n \cdot m \cdot z \sim 10^{16}$ |
| $10$ | $n \cdot m \cdot z \sim 10^{16}$ |



---

---
title: "[CrCPC 2024] 平凡的数论题"
layout: "post"
diff: 省选/NOI-
pid: P11932
tag: ['2024', 'Special Judge', 'XCPC']
---
# [CrCPC 2024] 平凡的数论题
## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) B.
## 题目描述

给定非负整数序列 $a,b,c$，长度分别为 $|a|,|b|,|c|$。这里序列下标是 **0-indexed** 的。

令 $l=\max\{a_i,b_i,c_i\}$。

找到任意一个 $\in [l+1,10^{19})$ 的正整数 $B$，使得 $\displaystyle \left(\sum_{0\le i\lt |a|} a_iB^i\right)\left(\sum_{0\le j\lt |b|} b_jB^j\right)=\sum_{0\le k\lt |c|} c_kB^k$ 成立。

数据保证，若存在正整数 $B\ge l+1$ 使得上式成立，则存在一个 $\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。

## 输入格式

第一行，$|a|+1$ 个非负整数 $|a|,a_{|a|-1},a_{|a|-2},\ldots,a_0$。

第二行，$|b|+1$ 个非负整数 $|b|,b_{|b|-1},b_{|b|-2},\ldots,b_0$。

第一行，$|c|+1$ 个非负整数 $|c|,c_{|c|-1},c_{|c|-2},\ldots,c_0$。

**数据保证 $a_{|a|-1},b_{|b|-1},c_{|c|-1}\neq 0$。**

## 输出格式

如果存在 $\in [l+1,10^{19})$ 的 $B$，直接输出；

否则输出一行一个 $\texttt{impossible}。$


**数据保证，若存在正整数 $B\ge l+1$ 使得上式成立，则存在一个 $\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。**
## 样例

### 样例输入 #1
```
2 2 0
1 2
3 1 0 0
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
3 5 1 2
2 11 3
5 4 5 1 12 6
```
### 样例输出 #2
```
13
```
### 样例输入 #3
```
2 3 2
2 3 2
3 10 12 4
```
### 样例输出 #3
```
impossible
```
## 提示

- $1\le |a|,|b|,|c|\le 10^3$；
- $0\le a_i,b_i,c_i\le 2^{30}$；
- $a_{|a|-1},b_{|b-1|},c_{|c-1|}\neq 0$。
- 若存在正整数 $B\ge l+1$ 使得上式成立，则存在一个 $\in [l+1,10^{19})$ 的正整数 $B$ 使得上式成立。


---

---
title: "[CrCPC 2024] 修路"
layout: "post"
diff: 省选/NOI-
pid: P11933
tag: ['2024', 'Special Judge', 'XCPC']
---
# [CrCPC 2024] 修路
## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) C.

![](https://cdn.luogu.com.cn/upload/image_hosting/uwqqd8f7.png?x-oss-process=image/resize,w_200)
## 题目描述

有一条河流。这条河流由 $(n-1)$ 段线段组成，由 $n$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$ 顺次连接而成。这里，$\forall 1\le i\lt n$，都有 $y_i\lt y_{i+1}$。

要修建一条路，起点为 $(x_1,y_1)$，终点为 $(x_n,y_n)$。路同样也是折线段。

给定正实数 $T$。令折线段的（欧几里得）总长度为 $a$，**穿过**河流的次数为 $b$，一种修路方案的**代价**为 $a+T\cdot b$。

路可以贴着河流修，贴着河流修不算作穿过。

求出修路方案可能的最小代价。

## 输入格式

第一行，正整数 $n$ 和正实数 $T$。$T$ 最多有两位小数。

接下来 $n$ 行，第 $i$ 行两个整数 $x_i,y_i$。

**数据保证不存在三点共线。**

## 输出格式

输出一行一个实数表示代价。

当你的答案与标准答案的绝对或相对误差不大于 $10^{-6}$ 时，认为你的答案正确。

## 样例

### 样例输入 #1
```
5 1
0 0
-1 2
4 3
-3 4
1 5
```
### 样例输出 #1
```
6.8416192530
```
### 样例输入 #2
```
2 1
0 0
0 1
```
### 样例输出 #2
```
1.0000000000
```
## 提示

#### 样例解释

样例 $1$ 解释：见【题目背景】中的图。

#### 数据范围

- $2\le n\le 1\, 500$；
- $0\lt T\le 10^6$，$T$ 至多有两位小数；
- $|x_i|,|y_i|\le 10^5$；
- $\forall 1\le i\lt n$，有 $y_i\lt y_{i+1}$；
- 保证不存在三点共线。



---

---
title: "[CrCPC 2024] 萌萌交互题"
layout: "post"
diff: 省选/NOI-
pid: P11935
tag: ['2024', 'XCPC']
---
# [CrCPC 2024] 萌萌交互题
## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) E.
## 题目描述

**这是一道传统题。**

交互库有一个隐藏的长度为 $n$，值域为 $[1,k]$ 的正整数序列 $a=[a_1,\ldots,a_n]$。

每次询问可以给定一个长度为 $n$，值域为 $[1,k]$ 的正整数序列 $[b_1,\ldots,b_n]$，交互库会告诉你猜对了哪些位置。也就是，交互库会返回一个长度为 $n$ 的 $01$ 序列 $s$，$s_i=1$ 表示 $a_i=b_i$，$s_i=0$ 表示 $a_i\neq b_i$。

**交互库是非自适应的**，也就是说序列 $a$ 已经事先确定。

对于序列 $[a_1,a_2,\ldots,a_n]$，定义 $f([a_1,a_2,\ldots,a_n])$ 为：如果交互库隐藏的序列为 $a=[a_1,a_2,\ldots,a_n]$，最优策略下要多少次才能猜出 $a$ 序列。


若交互库在 $k^n$ 个长度为 $n$，值域 $\in [1,k]$ 的正整数序列 $[a_1,a_2,\ldots,a_n]$ 中等概率独立随机选取一个，求出 $f$ 的期望值。

换句话说，令 $\displaystyle p=\sum_{1\le a_1\le k}\sum_{1\le a_2\le k}\cdots \sum_{1\le a_n\le k}f([a_1,a_2,\ldots,a_n])$，$q=k^n$，求出 $p/q$。

只需要输出答案对 $(10^9+7)$ 取模后的结果。

（注记：当且仅当交互库返回 $[1,1,\ldots,1]$ 时，认为猜出了序列。换句话说，就算已经事先确定这个序列，也要再询问一次。）


## 输入格式

一行两个正整数 $n,k$。
## 输出格式

一行一个非负整数，表示答案对 $(10^9+7)$ 取模后的结果。
## 样例

### 样例输入 #1
```
4 8
```
### 样例输出 #1
```
663085949
```
### 样例输入 #2
```
8 8
```
### 样例输出 #2
```
480783235
```
### 样例输入 #3
```
3 2
```
### 样例输出 #3
```
875000008
```
## 提示

#### 样例解释

样例 $3$ 真实答案为 $\frac{1}{8}+\frac{7}{8}\cdot 2=\frac{15}{8}$。

#### 数据范围

- $1\le n\le 10^6$；
- $1\le k\le 10^9$。



---

---
title: "[CrCPC 2024] 传传爆"
layout: "post"
diff: 省选/NOI-
pid: P11937
tag: ['2024', 'XCPC']
---
# [CrCPC 2024] 传传爆
## 题目背景

译自 [Natjecanje timova studenata informatičara hrvatskih sveučilišta](https://hsin.hr/studenti2024/) G.

2025/3/19：加入一组来自 @_lmh_ 的 hack 数据，位于 Subtask 0。
## 题目描述

有一个 $n\times m$ 的矩阵，左上角的格子记为 $(1,1)$，右下角的格子记为 $(n,m)$。

格子要么是黑色的，要么是白色的。魔法少女从 $(1,1)$ 出发寻找食物，按照如下规则移动：

- 每次可以向上下左右移动一步，但是不能出界。
- 如果移动到黑色格子，则无事发生。
- 如果移动到白色格子，魔法少女会被**等概率独立随机**传送到任意一个白色格子（包括她所在的格子）上。传送完后可以继续移动。

当魔法少女到达 $(n,m)$ 时，她会停止移动。**魔法少女会最小化移动的期望次数**。求出魔法少女移动的期望步数。

**题目保证 $(1,1)$ 和 $(n,m)$ 都是黑色的。**

## 输入格式

**本题单个测试点内含有多组测试数据。**

第一行，一个正整数 $T$，表示数据组数。

接下来依次描述 $T$ 组数据：

每组数据第一行，两个正整数 $n,m$。

接下来一个 $n\times m$ 的矩阵，第 $i$ 行第 $j$ 列的字符是 $\texttt{C}$，表示 $(i,j)$ 是黑色；否则是 $\texttt{B}$，表示 $(i,j)$ 是白色。

## 输出格式

可以证明答案一定是一个有理数。

对于每组数据，输出一行一个**既约分数** $p/q$。
## 样例

### 样例输入 #1
```
3
2 2
CC
CC
2 2
CB
BC
1 12
CBCCCCCCCCBC
```
### 样例输出 #1
```
2/1
2/1
4/1
```
### 样例输入 #2
```
1
6 2
CC
CC
CC
CC
CC
CC
```
### 样例输出 #2
```
6/1
```
### 样例输入 #3
```
1
6 3
CBC
CBC
CBC
CBC
CBC
CBC
```
### 样例输出 #3
```
4/1
```
## 提示

- $1\le T\le 10^3$；
- $1\le n,m\le 10^3$；
- $\sum nm\le 10^6$。




---

---
title: "[JOI Open 2020] 黑白点 / Monochrome Points"
layout: "post"
diff: 省选/NOI-
pid: P11973
tag: ['2020', 'JOI（日本）']
---
# [JOI Open 2020] 黑白点 / Monochrome Points
## 题目描述

在一个环上有 $2n$ 个点，按照顺时针顺序编号为 $1,2,\dots 2n$。每个点是黑点或者白点，一共有 $n$ 个黑点和 $n$ 个白点。

我们画 $n$ 条线段连接环上的点，使其满足以下条件：

- 每个点恰好是一条线段的端点。
- 每条线段连接一个黑点和一个白点。

定义**相交数**为相交的线段对数。

给出每个点的颜色，计算 $n$ 条线段最大的相交数。
## 输入格式

第一行一个整数 $n$。

第二行一个长度为 $2n$ 的字符串 $S$，第 $i$ 个字符表示第 $i$ 个点的颜色。每个字符是 $\mathtt{B}$（黑色）或 $\mathtt{W}$（白色）。
## 输出格式

一个数，表示最大的相交数。
## 样例

### 样例输入 #1
```
3
BBWWBW
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
5
BWBWBBWBWW
```
### 样例输出 #2
```
8
```
### 样例输入 #3
```
10
WBBBWBBWWBWWBWWBWBWB
```
### 样例输出 #3
```
41
```
### 样例输入 #4
```
16
WWWBWBBBBWWBWWBWWBBWWBBBWBBBWWBW
```
### 样例输出 #4
```
105
```
## 提示

#### 样例解释 1

如果我们按左图绘制线段，那么相交数就是 $2$。另一方面，如果我们按右图绘制线段，那么相交数是 $3$，然而不满足题目描述中的条件。

![](https://cdn.luogu.com.cn/upload/image_hosting/7q5karom.png)

#### 数据规模与约定

#### 本题采用捆绑测试。

- Subtask 1（4 pts）：$n\le 8$；
- Subtask 2（21 pts）：$n\le 300$；
- Subtask 3（10 pts）：$n\le 2000$；
- Subtask 4（65 pts）：无特殊限制。

对于 $100\%$ 的数据，$1\le n\le 2\times 10^5$，保证 $S$ 的长度是 $2n$ 且只包含 $\mathtt{B}$ 和 $\mathtt{W}$ 两种字符。保证 $\mathtt{B}$ 和 $\mathtt{W}$ 都出现恰好 $n$ 次。

译自 [JOI Open 2020](https://contests.ioi-jp.org/open-2020/index.html) T2 「[白黒の点](https://s3-ap-northeast-1.amazonaws.com/data.cms.ioi-jp.org/open-2020/monochrome/2020-open-monochrome-statement.pdf) / [Monochrome Points](https://s3-ap-northeast-1.amazonaws.com/data.cms.ioi-jp.org/open-2020/monochrome/2020-open-monochrome-statement-en.pdf)」


---

---
title: "[JOIST 2025] 多方通信 / Multi Communication"
layout: "post"
diff: 省选/NOI-
pid: P11991
tag: ['2025', '提交答案', 'Special Judge', 'JOI（日本）']
---
# [JOIST 2025] 多方通信 / Multi Communication
## 题目背景

你可以提交数据生成器，也可以提交三个 $\texttt{.txt}$ 文件（$\texttt{1.txt}\sim \texttt{3.txt}$）。

## 题目描述


**这是一道提交答案题。**

K 主席为春季训练营的参与者准备了一个游戏。 

训练营中共有 $N$ 名参与者，每人被分配一个从 $1$ 到 $N$ 的唯一编号。每位参与者拥有一块白板。游戏按以下步骤进行：

1. K 主席选择一名参与者作为父节点（parent），其余参与者成为子节点（children）。但**父节点的身份不会向参与者公开**。  
2. K 主席在父节点的白板上写下字母 $\texttt{T}$，在所有子节点的白板上写下字母 $\texttt{F}$。  
3. 每位参与者阅读自己白板上的字母。然后，按照预先定义好的策略，执行以下回合制流程（共 $L$ 个回合）：  
   - 每位参与者擦除白板上的字母，并写下 $\texttt{T}$ 或 $\texttt{F}$，然后将白板提交给 K 主席。  
   - 对于每个参与者 $i$（$i = 1, 2, \ldots, N$）：
        - 参与者 $i$ 选择一个参与者 $p$（$1 \leq p \leq N$）并将编号 $p$ 告知 K 主席。  
        - K 主席将参与者 $p$ 的白板展示给参与者 $i$，参与者 $i$ 读取上面的字母。参与者可以选择自己作为 $p$。  
4. 经过 $L$ 个回合后，每位参与者必须猜测谁是父节点。  

游戏的目标是预先制定一个策略，使得无论谁被选为父节点，所有参与者都能在此流程结束时正确识别父节点。  

**更小的 $L$ 值意味着更高的得分**。你的目标是设计一个策略，在保证所有参与者能正确识别父节点的前提下，最小化 $L$。  

一个**策略**由以下两部分组成：  
- 一个非负整数 $L$，表示回合数；  
- 一组规则，用于确定每个参与者的行为。规则如下：  
  - 对于参与者 $i$（$1 \leq i \leq N$），在第 $t$ 个回合开始时（$1 \leq t \leq L$），若其已读取的字母序列为 $a_0, a_1, \ldots, a_{t-1}$，则仅基于这些信息（$i$, $t$, $a_0, a_1, \ldots, a_{t-1}$），必须确定：  
    - 在该回合要写入白板的字母；  
    - 在该回合选择观察的参与者编号。  
  - 对于参与者 $i$（$1 \leq i \leq N$），在第 $L$ 个回合结束后，若其已读取的字母序列为 $a_0, a_1, \ldots, a_L$，则仅基于这些信息（$i$, $L$, $a_0, a_1, \ldots, a_L$），必须推断出父节点的编号。  

请设计一个允许所有参与者正确识别父节点的策略（无论父节点是谁）。然后，针对每个可能的父节点选择（$1, 2, \ldots, N$），输出每位参与者按此策略在各回合写入白板的值和选择观察的参与者编号。  
## 输入格式

一行一个正整数 $N$。

## 输出格式


输出格式如下：

> $L$\
> $\mathrm{acts}_1$\
> $\mathrm{acts}_2$\
> $\vdots$\
> $\mathrm{acts}_N$

其中，$\mathrm{acts}_s$ 表示当参与者 $s$ 是父节点时，每位参与者的行动序列。其格式如下：  
1. 首先输出整数 $s$。  
2. 对于每个参与者 $i$（$1 \leq i \leq N$），输出一行表示其在 $L$ 个回合中的行动序列。每行应包含以下值：  
   - 字符 $c_{i,t}$（$\texttt{T}$ 或 $\texttt{F}$），表示该参与者在第 $t$ 个回合写入白板的字母。  
   - 参与者编号 $p_{i,t}$，表示该参与者在第 $t$ 个回合选择观察的对象。  

这些值需按回合顺序（$t=1,2,\ldots,L$）依次输出。因此，$\mathrm{acts}_s$ 
的输出格式为：  

> $s$\
> $c_{1,1}$ $p_{1,1}$ $c_{1,2}$ $p_{1,2}$ $\cdots$ $c_{1,L}$ $p_{1,L}$\
> $c_{2,1}$ $p_{2,1}$ $c_{2,2}$ $p_{2,2}$ $\cdots$ $c_{2,L}$ $p_{2,L}$\
> $\vdots$\
> $c_{N,1}$ $p_{N,1}$ $c_{N,2}$ $p_{N,2}$ $\cdots$ $c_{N,L}$ $p_{N,L}$
## 样例

### 样例输入 #1
```
3
```
### 样例输出 #1
```
3
1
T 1 T 2 T 3
F 1 F 2 F 3
F 1 F 2 F 3
2
F 1 F 2 F 3
T 1 T 2 T 3
F 1 F 2 F 3
3
F 1 F 2 F 3
F 1 F 2 F 3
T 1 T 2 T 3
```
## 提示


### 样例解释

样例中，参与者的策略如下：
- 令 $L = 3$。  
- 在每回合 $t$（$1 \leq t \leq L$）中：  
    - 参与者 $i$ 若其为父节点则写入 $\texttt{T}$，若为子节点则写入 $\texttt{F}$（根据初始步骤看到的字符，他们知道自己是否为父节点）。  
- 在每回合 $t$（$1 \leq t \leq L$）中：  
    - 参与者 $i$ 观察参与者 $t$，无论其当前已读取的字母序列如何。  
- 经过 $3$ 个回合后，每位参与者将恰好读取过包括自己在内的所有参与者的白板各一次。每位参与者将选择白板上出现过 $\texttt{T}$ 的参与者编号作为父节点。  

该策略确保所有人正确识别父节点，达成游戏目标。由于此策略在任何父节点选择下均满足游戏要求，因此输出被视为正确。  

注意：样例不在实际测试数据中，因其不满足题目给定的约束条件。  


### 数据范围

$N\in \{4,32,48\}$。

更为具体地说：

- 测试点 $1$ 中，$n=4$。
- 测试点 $2$ 中，$n=32$。
- 测试点 $3$ 中，$n=48$。

### 计分方式

当且仅当输出符合以下条件时，才被视为正确：该输出是通过参与者遵循一个**有效策略**（确保所有参与者都能正确识别父节点）所产生的结果。具体而言，必须满足以下两个条件：  
1. 对于任意参与者 $i$（$1 \leq i \leq N$）、任意回合 $t$（$1 \leq t \leq L$）以及任意两个不同的父节点候选 $x$ 和 $y$（$1 \leq x, y \leq N$ 且 $x \neq y$）：若参与者 $i$ 在回合 $t$ 之前读取的字母序列在 $x$ 为父节点和 $y$ 为父节点时完全相同，则参与者 $i$ 必须在回合 $t$ 采取相同的行动（即写入相同的字母并选择相同的观察对象）。  
2. 对于任意参与者 $i$（$1 \leq i \leq N$）以及任意两个不同的父节点候选 $x$ 和 $y$（$1 \leq x, y \leq N$ 且 $x \neq y$）：当 $x$ 为父节点时，参与者 $i$ 在第 $L$ 个回合结束时读取的字母序列必须与 $y$ 为父节点时的序列不同。  

---

该题的得分为三个测试点的得分之和。  

若输出不正确（例如格式错误或未遵循有效策略），则该测试点得 $0$ 分。  

否则，若输出正确，则按以下标准计算得分：  

| 测试点编号   | $N=$   | 计分方式 | 满分 |
|:-:|:-:|-|:-:|
| $1$       | $4$   | $\displaystyle \textsf{得分}=\begin{cases} 0 & 4\lt L \\ 16-7\cdot (L-2) & 2\lt L\le 4 \\ 16 & L\le 2\end{cases}$| $16$ |
| $2$       | $32$  | $\displaystyle \textsf{得分}=\begin{cases} 0 & 27\lt L \\ 60-3(L-8) & 8 < L \leq 27 \\ 60 & L\le 8\end{cases}$ | $60$ |
| $3$       |  $48$  | $\displaystyle \textsf{得分}=\begin{cases} 0 & 9\lt L \\ 24 & L\le 9 \end{cases}$ | $24$  |




---

---
title: "[USACO25OPEN] OohMoo Milk G"
layout: "post"
diff: 省选/NOI-
pid: P12030
tag: ['USACO', '2025']
---
# [USACO25OPEN] OohMoo Milk G
## 题目描述

农夫约翰正在生产他世界闻名的 OohMoo 牛奶以获取利润。他有 $N$ 个（$1 \leq N \leq 10^5$）瓶子需要装牛奶，每个瓶子初始含有 $m_i$（$0 \leq m_i \leq 10^9$）单位的牛奶。每天，他会选择 $A$ 个（$1 \leq A \leq N$）瓶子，每个被选中的瓶子增加 $1$ 单位牛奶。

不幸的是，他的竞争对手农夫 Nhoj 知道这个生产过程并计划破坏。每天在农夫约翰添加牛奶后，农夫 Nhoj 会偷偷从 $B$ 个（$0 \leq B < A$）不同的非空瓶子中各偷走 $1$ 单位牛奶。为了不被发现，农夫 Nhoj 确保 $B$ 严格小于 $A$。

经过 $D$ 天（$1 \leq D \leq 10^9$）后，农夫约翰将出售他的牛奶。如果一个瓶子含有 $M$ 单位牛奶，它将卖出 $M^2$ moonies 的价钱。

设 $P$ 为唯一确定的利润值，使得无论农夫 Nhoj 如何操作，农夫约翰都能保证至少获得 $P$ 利润；同时无论农夫约翰如何操作，农夫 Nhoj 都能确保农夫约翰最多获得 $P$ 利润。请输出 $P$ 对 $10^9+7$ 取模的结果。

## 输入格式

第一行包含 $N$ 和 $D$，分别表示瓶子数量和天数。

第二行包含 $A$ 和 $B$，表示农夫约翰每天添加的牛奶瓶数和农夫 Nhoj 每天偷取的瓶数。

第三行包含 $N$ 个整数 $m_i$，表示每个瓶子的初始牛奶量。

## 输出格式

输出 $P$ 对 $10^9+7$ 取模的结果。
## 样例

### 样例输入 #1
```
5 4
4 2
4 10 8 10 10
```
### 样例输出 #1
```
546
```
### 样例输入 #2
```
10 5
5 1
1 2 3 4 5 6 7 8 9 10
```
### 样例输出 #2
```
777

```
### 样例输入 #3
```
5 1000000000
3 1
0 1 2 3 4
```
### 样例输出 #3
```
10
```
## 提示

样例一解释：经过 $4$ 天后，可能的牛奶量为 $[4,11,11,12,12]$，总利润为 $4^2+11^2+11^2+12^2+12^2=546$。

- 测试点 $4\sim6$：$N,D \leq 1000$。
- 测试点 $7\sim10$：$D \leq 10^6$。
- 测试点 $11\sim20$：无额外限制。


---

---
title: "[USACO25OPEN] Lazy Sort P"
layout: "post"
diff: 省选/NOI-
pid: P12032
tag: ['USACO', '2025']
---
# [USACO25OPEN] Lazy Sort P
## 题目描述

Farmer John has $N$ cows ($2 \le N \le 5 \cdot 10^6$) and is attempting to get them to sort a non-negative integer array $A$ of length $N$ by relying on their laziness. He has a lot of heavy boxes so he lines the cows up one behind another, where cow $i+1$ is behind cow $i$, and gives $a_i$ boxes to cow $i$ ($0 \le a_i$).

Cows are inherently lazy so they always look to pass their work off to someone else. From cow 1 to $N-1$ in order, each cow looks to the cow behind them. If cow $i$ has strictly more boxes than cow $i+1$, cow $i$ thinks this is "unfair" and gives one of its boxes to cow $i+1$. This process repeats until every cow is satisfied.

Farmer John will then note the number of boxes $b_i$ that each cow $i$ is holding and create an array $B$ out of these values. If $B = \text{sorted}(A)$, then Farmer John will be happy. Unfortunately, Farmer John forgot all but $Q$ values ($2 \le Q \le \min(N, 100)$) in $A$. Luckily, those values include the number of boxes he was going to give to the first and last cow. Each value that FJ remembers is given in the form $c_i\; v_i$ representing that $a_{c_i} = v_i$ ($1 \le c_i \le N$, $1 \le v_i \le 10^9$). Determine the number of different ways the missing values can be filled in so that he will be happy mod $10^9 + 7$.
## 输入格式

The first line contains two space-separated integers $N$ and $Q$ representing the number of cows and queries respectively.

The next $Q$ lines contain two space separated integers $c_i\; v_i$ representing that cow $c_i$ initially holds $v_i$ boxes. It is guaranteed that $c_1 = 1$, $c_Q = N$, and $c_i < c_{i+1}$ (the order of the cows is strictly increasing).
## 输出格式

Print the number of different ways modulo $10^9 + 7$ that values $a_i$ can be assigned such that Farmer John will be happy after the cows perform the lazy sort. It is guaranteed that there will be at least one valid assignment.
## 样例

### 样例输入 #1
```
3 2
1 3
3 2
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
6 3
1 1
3 3
6 5
```
### 样例输出 #2
```
89
```
## 提示

### Sample 1 Explanation

In this example, FJ remembers the values at the ends of the array. The arrays $[3, 2, 2]$ and $[3, 3, 2]$ are the valid arrays that will make FJ happy at the end of the lazy sorting.

### SCORING:
- Inputs 3-4: $N,v_i\leq 100$
- Inputs 5-6: $N\leq 100$ and $v_i\leq 10^6$
- Inputs 7-9: $N\leq 2\times 10^5$ and $v_i\leq 10^6$
- Inputs 10-12: $N\leq 2\times 10^5$
- Inputs 13-15: No additional constraints.


---

---
title: "[NordicOI 2025] 点对处理 / Dodgeball Diplomacy"
layout: "post"
diff: 省选/NOI-
pid: P12118
tag: ['交互题', 'Special Judge']
---
# [NordicOI 2025] 点对处理 / Dodgeball Diplomacy
## 题目背景


Python / Java（很）可能无法通过本题。不建议不使用 C/C++。
## 题目描述

**这是一道交互题**。我们利用交互来让你强制在线回答询问。

有 $N$ 个点，编号从 $1$ 到 $N$，你需要解决如下 $Q$ 个询问：

- $\texttt{a u v p}$，在 $u$ 和 $v$ 之间添加长度为 $p$ 的无向边。

- $\texttt{r}$，删除当前图中最长的无向边。

- $\texttt{d}$，把当前图中连通块两两配对（如果连通块数量为奇数，那就选择一个连通块和大小为 $0$ 的连通块配对），记为 $(A_i,B_i)$。

	设有 $k$ 个连通块，令连通块 $A$ 的点数为 $|A|$，最小化 $\displaystyle \sum_{1\le i\le k}||A_i|-|B_i||$。只需要输出最小化后的这个值。
## 输入格式

第一行给定两个整数 $N,Q$。

接下来 $Q$ 行查询，每行格式即题目描述三者之一。
## 输出格式

对于每条类型为 $\texttt{d}$ 的查询，程序必须在处理后续查询之前立即输出答案。此外，你需要在每次输出答案后立即刷新输出缓冲区。


## 样例

### 样例输入 #1
```
3 5
a 1 2 1
a 2 3 2
d
r
d

```
### 样例输出 #1
```
3
1

```
### 样例输入 #2
```
6 10
a 2 3 10
a 1 2 5
a 3 4 8
d
r
d
a 4 5 1
a 3 6 7
r
d

```
### 样例输出 #2
```
4
0
2

```
## 提示

【样例解释】

注意以下解释只按顺序解释类型为 $\texttt{d}$ 的查询。

- 对于样例 $1$，第一次查询，连通块为 $(1,2,3)$，答案为 $3$，第二次查询，连通块为 $(1,2)$ 和 $(3)$，答案为 $1$。

- 对于样例 $2$，在第一次查询，有一个大小为 $4$ 的连通块和两个大小为 $1$ 的连通块，总不公平分数为 $4$；在第二次查询中，有两个大小为 $2$ 的连通块和两个大小为 $1$ 的连通块，答案为 $0$；在第三次查询，有三个大小为 $2$ 的联盟，答案为 $2$。


【数据规模与约定】

对于所有数据，满足：

$1 \leq N \leq 100000,1 \leq Q \leq 500000,1 \leq p \leq 10^{9},1 \leq u \leq N,1 \leq v \leq N$。 

对于类型 $\texttt{a}$ 的查询，$u \neq v$，添加无向边时，$u$ 和 $v$ 之间不存在无向边，且所有 $p$ 均唯一。

详细子任务附加限制及分值如下表所示：


|子任务编号  | 分值 | 附加限制 |
| :-----------: |:-----------: | :-----------: |
|$1$  | $9$ | $N \le 10,Q \le 20$ |
| $2$ | $10$ | $N \le 2000,Q\le 4000$ |
|$3$  | $6$ | 类型 $\texttt{d}$ 的查询不超过 $10$ 次 |
| $4$ | $17$ | 类型 $\texttt{a}$ 的查询，满足 $u+1=v$  |
| $5$ | $14$ | 满足随着边的建立，$p$ 递增 |
| $6$ | $26$ | 满足随着边的建立，$p$ 递减  |
| $7$ | $18$ | 无附加限制 |



---

---
title: "【MX-X11-T5】「蓬莱人形 Round 1」俄罗斯方块"
layout: "post"
diff: 省选/NOI-
pid: P12151
tag: ['O2优化', '梦熊比赛']
---
# 【MX-X11-T5】「蓬莱人形 Round 1」俄罗斯方块
## 题目背景

原题链接：<https://oier.team/problems/X11F>。

---

「興味がないこと本気じゃないもの全部後回しで」

「知ってることは知らんぷり 私は終わってる」

「恥ずかしい過去知ってるやつらの記憶消させて」

「迷惑かけてごめんってば ねえ誰か助けて」
## 题目描述

给定一个长为 $n$ 的整数序列 $h_i$，再给定 $n$ 个二元组 $(a_i,b_i)$，和一个正整数 $k$。


对于每个位置 $p$，你可以进行如下操作之一：

- 激活位置 $p$，选择一个位置 $j$ 满足 $1\le j-p\le k$，然后令 $h_p \leftarrow h_p + a_p$、$h_j \leftarrow h_j - b_p$。**每个位置最多激活一次**。

- 不激活位置 $p$。

有 $q$ 次询问 $(l_i,r_i,x_i)$，表示在只能激活位置 $p\in[l_i,r_i]$，且对应的 $j\in [p+1,\min(p+k,r_i)]$ 的条件下，可以选择多个位置激活，问此时是否存在一种激活方式使得 $\max_{t=l_i}^{r_i}h_t\le x_i$。

询问之间互相独立，即每次询问开始时序列 $h$ 被恢复到原始状态，每个位置均未选择操作方式。
## 输入格式

**本题有多组测试数据**。输入的第一行两个整数 $c,T$，分别表示子任务编号和测试数据组数，接下来输入每组测试数据。样例满足 $c=0$。

对于每组测试数据：

- 第一行，三个整数 $n,q,k$，分别表示序列长度、询问次数和激活的限制参数。
- 第二行，$n$ 个整数 $h_1,h_2,\ldots,h_n$。
- 第三行，$n$ 个整数 $a_1,a_2,\ldots,a_n$。
- 第四行，$n$ 个整数 $b_1,b_2,\ldots,b_n$。
- 接下来 $q$ 行，第 $i$ 行三个整数 $l_i,r_i,x_i$，分别表示询问的区间和最大值限制。
## 输出格式

对于每个询问输出 `Yes` 或 `No`，表示是否存在一种方案满足要求。
## 样例

### 样例输入 #1
```
0 1
3 2 1
2 0 2
4 1 1
0 8 0
2 3 1
1 3 1
```
### 样例输出 #1
```
Yes
No
```
### 样例输入 #2
```
0 2
7 7 3
4 1 2 2 3 2 2
4 1 4 0 3 2 1
3 3 4 1 3 3 0
5 5 4
3 4 5
1 4 3
2 5 0
1 2 3
1 4 5
1 3 4
7 7 3
5 2 1 5 2 5 2
4 2 1 4 3 1 2
1 5 3 4 1 5 1
6 7 5
1 4 5
2 4 5
5 7 5
1 2 5
3 4 5
2 6 5
```
### 样例输出 #2
```
Yes
Yes
No
No
No
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes
Yes

```
## 提示

**【样例解释 #1】**

对于询问 $(2,3,1)$，可以激活位置 $2$，令 $h_2 \leftarrow h_2 + a_2$、$h_3 \leftarrow h_3 - b_2$，最后的 $h$ 的区间 $[2,3]$ 为 $1,-6$，最大值为 $1$，符合要求。

对于询问 $(1,3,1)$，可以证明没有合法的操作方案。

**【数据范围】**

**本题使用子任务捆绑**。

对于所有测试数据，$1 \le T \le 3$，$1 \le n \le 2 \times 10^4$，$1\le q \le 10^5$，$0\le h_i,a_i,b_i,x_i \le 10^6$，$1\le l_i \le r_i \le n$，$1\le k \le 5$。

|子任务编号|$n\le$|$q \le$|$k \le$|$T \le$|特殊性质|分值|时限|
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$|$10$|$10$|$5$|$3$|无|$5$|1 s|
|$2$|$1000$|$1000$|$5$|$1$|无|$10$|1 s|
|$3$|$2\times 10^4$|$10^5$|$5$|$3$|A|$10$|4 s|
|$4$|$10^4$|$10^4$|$3$|$1$|B|$5$|1 s|
|$5$|$10^4$|$10^4$|$3$|$1$|无|$10$|1 s|
|$6$|$2\times 10^4$|$2\times 10^4$|$4$|$1$|B|$5$|1 s|
|$7$|$2\times 10^4$|$2\times 10^4$|$4$|$1$|无|$10$|1 s|
|$8$|$2\times 10^4$|$4\times 10^4$|$4$|$2$|B|$5$|1 s|
|$9$|$2\times 10^4$|$4\times 10^4$|$4$|$2$|无|$10$|1 s|
|$10$|$2\times 10^4$|$10^5$|$5$|$3$|无|$30$|4 s|

- 特殊性质 A：$\forall 1 \le i \le q,l_i=1,r_i = n$。
- 特殊性质 B：$\forall 1 \le i,j \le q,x_i = x_j$。

**【提示】**

请注意本题特别的时间限制。


---

---
title: "【MX-X11-T6】「蓬莱人形 Round 1」催眠术"
layout: "post"
diff: 省选/NOI-
pid: P12152
tag: ['O2优化', '梦熊比赛']
---
# 【MX-X11-T6】「蓬莱人形 Round 1」催眠术
## 题目背景

原题链接：<https://oier.team/problems/X11G>。

---

「こんな時代に誂えた  見て呉れの脆弱性」

「本当の芝居で騙される  矢鱈と煩い心臓の鼓動」

「残機は疾うにないなっている；；  擦り減る耐久性」

「目の前の事象を躱しつつ，生きるので手一杯！  誰か、助けてね(^^♪」
## 题目描述

给定 $n,m,k$，还有一个长为 $m$ 的值域在 $[1,k]$ 中的整数序列 $a$，再给定一个大小为 $n \times (m+1)$ 的矩阵 $c$。

定义一个整数序列是好的，当且仅当它的值域在 $[1,k]$ 中且所有值域在 $[1,k]$ 的长为 $m$ 的整数序列都是它的子序列。

定义一个好的整数序列 $b$ 的价值为 $\prod\limits_{i=1}^n c_{i,pre_i}$，其中 $pre_i$ 为 $a$ 的最长前缀长度使得 $a_{1 \sim pre_i}$ 是 $b_{1\sim i}$ 的一个子序列，若不存在则 $pre_i = 0$。

求所有长度为 $n$ 的好序列的价值和，答案对 $10^9+7$ 取模。 
## 输入格式

第一行，三个正整数 $n,m,k$。

第二行，$m$ 个正整数 $a_1,\ldots,a_m$。

接下来 $n$ 行，每行 $m+1$ 个正整数 $c_{i,0},c_{i,1},\ldots,c_{i,m}$。
## 输出格式

一行一个整数，表示所有好序列的价值和模 $10^9+7$ 后的值。
## 样例

### 样例输入 #1
```
2 1 2
2
2 3
2 3
```
### 样例输出 #1
```
15
```
### 样例输入 #2
```
10 2 5
2 3
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
1 1 1
```
### 样例输出 #2
```
14400

```
### 样例输入 #3
```
10 3 3
2 3 3
2 3 1 4
5 2 3 1
5 6 6 6
2 2 3 1
7 6 5 7
2 2 3 1
7 6 5 7
2 2 3 1
7 6 5 7
9 8 1 2

```
### 样例输出 #3
```
350920080

```
## 提示

**【样例解释 #1】**

满足要求的序列有 $1,2$ 和 $2,1$ 两种，价值分别为 $2\times 3=6$ 和 $3\times 3 = 9$，所以总和为 $6+9=15$。

**【数据范围】**

**本题使用子任务捆绑**。

对于所有测试数据，$1 \le n,m,k \le 400$，$1\le a_i\le k$，$1 \le c_{i,j} < 10^9+7$。

|子任务编号|$n\le$|$m \le$|$k \le$|特殊性质|分值|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$|$8$|$8$|$8$|无|$5$|
|$2$|$400$|$400$|$400$|A|$10$|
|$3$|$50$|$50$|$50$|无|$10$|
|$4$|$400$|$30$|$8$|无|$15$|
|$5$|$400$|$30$|$400$|无|$15$|
|$6$|$400$|$400$|$400$|B|$15$|
|$7$|$400$|$400$|$400$|无|$30$|

- 特殊性质 A：保证所有 $c_{i,j}$ 相等。
- 特殊性质 B：保证所有 $a_i$ 相等。


---

---
title: "[NOISG 2025 Prelim] Lasers 2"
layout: "post"
diff: 省选/NOI-
pid: P12196
tag: ['2025', 'NOISG（新加坡）']
---
# [NOISG 2025 Prelim] Lasers 2
## 样例

### 样例输入 #1
```
3 10 10
2 5 9
1 3 1
4 7 10
```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
10 10 50
8 8 0
3 3 0
6 6 2
7 7 9
1 1 50
5 5 21
6 6 4
10 10 4
10 10 3
10 10 3
```
### 样例输出 #2
```
9
```
### 样例输入 #3
```
4 17 0
2 4 1000000000
6 9 1000000000
8 13 1000000000
15 16 1000000000
```
### 样例输出 #3
```
4
```
## 提示

### Subtasks

For all testcases, the input will satisfy the following bounds:

- $1 \leq h, w \leq 2000$
- $0 \leq k \leq 10^9$
- $1 \leq l[i] \leq r[i] \leq w$ for all $1 \leq i \leq h$
- $0 \leq c[i] \leq 10^9$ for all $1 \leq i \leq h$

Your program will be tested on input instances that satisfy the following restrictions:

| Subtask | Marks | Additional constraints |
| :-: | :-: | :-: |
| $0$ | $0$ | Sample test cases |
| $1$ | $6$ | $k = 0, c[i] = 10^9$ |
| $2$ | $9$ | $l[i] = r[i]$ |
| $3$ | $10$ | $h, w \leq 18$ |
| $4$ | $7$ | $h, w \leq 100, k \leq 2000$ |
| $5$ | $15$ | $h, w \leq 100$ |
| $6$ | $23$ | $h, w \leq 500$ |
| $7$ | $8$ | $r[1] − l[1] = r[2] − l[2] = \ldots = r[h] − l[h]$ |
| $8$ | $22$ | No additional constraints |

### Sample Test Case 1 Explanation

This test case is valid for subtasks $3, 4, 5, 6$, and $8$.

The laser toy in the above figure corresponds to this test case. Pavement can unlock the first and second sliding walls for a total cost of $9 + 1 = 10$ dollars. He can then slide the first sliding wall such that it spans columns $4$ to $7$, and slide the second sliding wall to span columns $5$ to $7$.

![](https://cdn.luogu.com.cn/upload/image_hosting/glj93dtp.png)

This leaves $6$ lasers (in columns $1, 2, 3, 8, 9$, and $10$) unblocked, which is the maximum possible.

### Sample Test Case 2 Explanation

This test case is valid for subtasks $2$ to $8$.

### Sample Test Case 3 Explanation

This test case is valid for subtasks $1, 3, 4, 5, 6$, and $8$.


---

---
title: "「WyOJ Round 1」持 · 山海为肩"
layout: "post"
diff: 省选/NOI-
pid: P12228
tag: []
---
# 「WyOJ Round 1」持 · 山海为肩
## 题目背景

>人生得意须尽欢，莫使金樽空对月。天生我材必有用，千金散尽还复来。
>
>—— 李白《将进酒》
## 题目描述

李白和高适在玩石头剪刀布，总共有 $m$ 轮。

李白是天赋型选手，提前预知了高适**可能**的出招方式和概率。具体而言，高适有 $n$ 种出招方式，第 $i$ 种方式是由 `rock`，`paper`，`scissors` 构成的长度为 $m$ 的序列，出招使用第 $i$ 种方式的概率为 $p_i$。

李白想知道，在最优策略下，获胜的概率**最大**是多少？获胜指李白赢的轮数**不小于**输的轮数。  

注意：`paper` 能击败 `rock`，`scissors` 能击败 `paper`，`rock` 能击败 `scissors`  。  

注意：李白的策略是不能根据高适出的东西来决定。李白的 $m$ 次出法必须在开始就全部定下来。
## 输入格式

第一行包含两个整数 $n$ 和 $m$，表示出招方式的数量和比赛的轮数。

接下来 $n$ 行，每行先输入一个浮点数 $p_i$，然后是 $m$ 个由  `rock`，`paper`，`scissors` 构成的元素。
## 输出格式

第一行一个浮点数，表示最大的概率，四舍五入保留 $6$ 位小数。  

第二行，输出能得到最大概率的**字典序最小**的方案。  

注：方案 $p$ 比方案 $q$ 字典序小，当且仅当存在位置 $i$ 使得：  

* $\forall j\in [1,i), p_j=q_j$ 且 $p_i<q_i$。这里 $p_i$ 和 $q_i$ 分别表示两个方案在第 $i$ 轮出的是 `rock`，`paper` 还是 `scissors`，**特别注意，字典序上从小到大的顺序为 `rock`，`paper`，`scissors`**。
## 样例

### 样例输入 #1
```
2 3
0.3 rock scissors paper
0.7 rock rock scissors

```
### 样例输出 #1
```
1.000000
rock rock rock
```
## 提示

对于 $100\%$ 的数据，$1\le n\le 10^5$，$1\le m\le 12$。保证 $p_i\in [0,1]$ 且 $\sum\limits_{i=1}^n p_i=1$。$p_i$ 小数点后至多 $6$ 位。

| 测试点 | 数据范围 |
| -----------: | ----------- |
| $1\sim 3$ | $1\le n\le 10^3$，$1\le m\le 5$ |
| $4\sim 10$ | $1\le n\le 10^5$，$1\le m \le 12$ |



---

---
title: "[ICPC 2023 WF] Schedule"
layout: "post"
diff: 省选/NOI-
pid: P12296
tag: ['2023', 'ICPC']
---
# [ICPC 2023 WF] Schedule
## 题目描述

The Institute for Creative Product Combinations (ICPC) tries to find unusual and innovative ways to unite seemingly unrelated products or technologies, opening up new markets and creating new jobs. (For instance, their most recent success was the "hairbachi," a hair-dryer with a hibachi grill top attachment for preparing on-the-go hot meals.) The company employs $n$ teams of size $2$ to research individual products, then members of the different teams get together to explore ways of combining products.

During the pandemic, the ICPC management organized everyone's schedule in such a way that there were never more than $n$ people in the office at the same time, and things ran so smoothly that they continued the process once things began to return to normal. Here is the scheme they used. Label the teams with integers $1$ through $n$ and the two people on the $i^\text{th}$ team as $(i, 1)$ and $(i, 2)$ for each $i$ from $1$ to $n$. Each week, exactly one person from each team is allowed in the office, while the other has to stay away. The employees $(i, 1)$ and $(i, 2)$ know each other well and collaborate productively regardless of being isolated from each other, so members of the same team do not need to meet in person in the office. However, isolation between members from different teams is still a concern.

Each pair of teams $i$ and $j$ for $i \neq j$ has to collaborate occasionally. For a given number $w$ of weeks and for fixed team members $(i, a)$ and $(j, b)$, let $w_1 < w_2 < \ldots < w_k$ be the weeks in which these two team members meet in the office. The isolation of those two people is the maximum of

$$
\{w_1,w_2-w_1,w_3-w_2,\ldots,w_k-w_{k-1},w+1-w_k\}
$$

or infinity if those two people never meet. The isolation of the whole company is the maximum isolation across all choices of $i$, $j$, $a$, and $b$.

You have been tasked to find a weekly schedule that minimizes the isolation of the whole company over a given number $w$ of weeks.
## 输入格式

The input consists of a single line containing two integers $n$ ($2 \le n \le 10^4$) and $w$ ($1 \le w \le 52$), where $n$ is the number of teams and $w$ is the number of weeks that need to be scheduled.
## 输出格式

Output a line containing either an integer representing the minimum isolation achievable for $n$ teams or the word `infinity` if no schedule guarantees that every pair of individuals on different teams can meet. If the isolation is finite, it is followed by $w$ lines representing a schedule that achieves this isolation. The $j^\text{th}$ line of the schedule is a string of length $n$ containing only the symbols `1` and `2`, where the $i^\text{th}$ symbol indicates which of the two members from team $i$ comes into the office on week $j$.
## 样例

### 样例输入 #1
```
2 6

```
### 样例输出 #1
```
4
11
12
21
22
11
12

```
### 样例输入 #2
```
2 1

```
### 样例输出 #2
```
infinity

```


---

---
title: "[ICPC 2022/2023 WF] Three Kinds of Dice"
layout: "post"
diff: 省选/NOI-
pid: P12297
tag: ['2022', '2023', 'Special Judge', 'ICPC']
---
# [ICPC 2022/2023 WF] Three Kinds of Dice
## 样例

### 样例输入 #1
```
6 1 1 6 6 8 8
3 2 4 9

```
### 样例输出 #1
```
0.291666667 0.750000000

```
### 样例输入 #2
```
4 9 3 7 5
3 4 2 3

```
### 样例输出 #2
```
0.500000000 0.500000000

```


---

---
title: "[ICPC 2023 WF] Tilting Tiles"
layout: "post"
diff: 省选/NOI-
pid: P12300
tag: ['2023', 'ICPC']
---
# [ICPC 2023 WF] Tilting Tiles
## 样例

### 样例输入 #1
```
4 4
.r..
rgyb
.b..
.yr.

yrbr
..yr
...g
...b

```
### 样例输出 #1
```
yes

```
### 样例输入 #2
```
1 7
....x..

..x....

```
### 样例输出 #2
```
no

```
### 样例输入 #3
```
4 3
yr.
..b
ry.
b..

...
..b
.ry
byb
```
### 样例输出 #3
```
no

```


---

---
title: "[ICPC 2023 WF] Waterworld"
layout: "post"
diff: 省选/NOI-
pid: P12303
tag: ['2023', 'Special Judge', 'ICPC']
---
# [ICPC 2023 WF] Waterworld
## 样例

### 样例输入 #1
```
3 7
63 61 55 54 77 87 89
73 60 38 5 16 56 91
75 43 11 3 16 20 95

```
### 样例输出 #1
```
51.809523810

```
### 样例输入 #2
```
4 3
10 10 10
10 10 10
10 10 10
10 10 10

```
### 样例输出 #2
```
10.000000000

```


---

---
title: "[ICPC 2023 WF] Alea Iacta Est"
layout: "post"
diff: 省选/NOI-
pid: P12305
tag: ['2023', 'Special Judge', 'ICPC']
---
# [ICPC 2023 WF] Alea Iacta Est
## 样例

### 样例输入 #1
```
5 8
ABCDEP
AEHOXU
AISOLR
ABCDEF
ABCSCC
PARSE
PAUSE
PHASE
POISE
PROSE
PULSE
PURSE
PEACE

```
### 样例输出 #1
```
9.677887141

```
### 样例输入 #2
```
2 1
AAAAAA
BBBBBB
AB

```
### 样例输出 #2
```
1.0

```
### 样例输入 #3
```
3 1
123456
123456
123456
666

```
### 样例输出 #3
```
10.555444555

```
### 样例输入 #4
```
2 1
ABCDEF
GHI234
AB

```
### 样例输出 #4
```
impossible

```


---

---
title: "[ICPC 2022 WF] Zoo Management"
layout: "post"
diff: 省选/NOI-
pid: P12307
tag: ['2022', 'ICPC']
---
# [ICPC 2022 WF] Zoo Management
## 题目描述

When managing a zoo, you sometimes want to move the animals between enclosures. You might figure out that the zebras will enjoy the spacier enclosure currently occupied by the penguins, while the penguins might want to move to the colder enclosure where the koalas currently live; and koalas will move to an empty enclosure that can be filled up with eucalyptus. So, you would move the koalas first, to free up the colder enclosure, then move the penguins there, and finally move the zebras.

The way you move animals is by using special tunnels that connect the enclosures — you do not want the animals to move outside, both because of the risk that they will be scared, and because of the risk that they might run away and hurt themselves.

Unfortunately, you have acquired more animals recently, and all the enclosures are now full, which makes moving animals around much harder. Imagine, for instance, that the koalas were to move to the former zebra enclosure — you cannot move any set of animals first. Instead, what you learned to do, is to move the animals at the same time — the zebras, koalas and penguins start moving down different tunnels at the same time, and arrive at their new enclosures at the same time — and thus they never meet. Note that you cannot just swap the animals in two connected enclosures this way (because they would meet in the tunnel and become scared).

So, now you have a puzzle. You have a list of enclosures, each with an animal type inside; some of those enclosures are connected by tunnels. You can, any number of times, choose some set of animals and move each one to an enclosure adjacent by tunnel, as long as the animal in that enclosure is also moved as the part of the same move, and no tunnel is used more than once as a part of the same move. You also have your vision of the perfect way to position the animals. Is it possible to do so, in a series of moves?
## 输入格式

The first line of the input consists of two integers $n$ ($1 \le n \le 4\cdot 10^5$) and $m$ ($0 \le m \le 4\cdot 10^5$), indicating the number of enclosures and tunnels. Then follow $n$ lines, the $i^\text{th}$ of which contains two integers $b_i$ ($1 \le b_i \le 10^6$) and $e_i$ ($1 \le e \le 10^6$), indicating the type of animal that is in enclosure $i$ at the beginning, and the type of animal that you want to be in enclosure $i$ after all the moves. You may assume that $e_1, \ldots , e_n$ is a permutation of $b_1, \ldots , b_n$.

Then follow $m$ lines describing the tunnels. Each line contains two integers $x$ and $y$ ($1 \le x < y \le n$), indicating that enclosures $x$ and $y$ are connected by a two-way tunnel. No two enclosures are connected by more than one tunnel.
## 输出格式

If it is possible to move the animals so that every enclosure contains the desired animal type, output `possible`. Otherwise, output `impossible`.
## 样例

### 样例输入 #1
```
3 3
1 4
4 7
7 1
1 2
2 3
1 3

```
### 样例输出 #1
```
possible

```
### 样例输入 #2
```
2 1
1 2
2 1
1 2

```
### 样例输出 #2
```
impossible

```
### 样例输入 #3
```
5 6
10 40
20 30
30 50
40 20
50 10
1 2
2 3
1 3
3 4
3 5
4 5

```
### 样例输出 #3
```
possible

```
### 样例输入 #4
```
4 4
10 10
10 20
20 10
20 20
1 2
2 3
3 4
1 4

```
### 样例输出 #4
```
impossible

```


---

---
title: "[ICPC 2022 WF] Quartets"
layout: "post"
diff: 省选/NOI-
pid: P12309
tag: ['2022', 'ICPC']
---
# [ICPC 2022 WF] Quartets
## 样例

### 样例输入 #1
```
4
1 A 2 3C no
2 A 3 3A yes
2 A 4 3D yes
2 A 1 3C no

```
### 样例输出 #1
```
no
4

```
### 样例输入 #2
```
6
1 A 2 3C no
2 A 3 3A yes
2 A 4 3D yes
2 A 1 3B no
1 A 4 5B yes
1 Q 5

```
### 样例输出 #2
```
yes

```


---

---
title: "抱月"
layout: "post"
diff: 省选/NOI-
pid: P12411
tag: ['O2优化']
---
# 抱月
## 题目描述

记 $P(u,v)$ 表示树上从节点 $u$ 到节点 $v$ 依次经过的点组成的序列，包括 $u$ 和 $v$。

记 $dep_u$ 表示在以 $1$ 为树根时，节点 $u$ 的深度（根节点深度为 $0$）。

记 $\operatorname{LCA}(u,v)$ 为树上节点 $u$ 和 $v$ 在以 $1$ 为树根时的最近公共祖先。

抱月有一棵树，树根为 $1$，一共有 $n$ 个节点。其中第 $i$ 个节点的颜色是 $c_i$。她发现，对于一个节点 $x$ 和整数 $k$，如果将 $P(x,1)$ 中所有满足：$dep_y\equiv dep_x \pmod{k}$ 的 $y$ 都拿出来，这些 $y$ 是有意义的。

所以，你需要解决这样一个问题。给定 $m$ 次询问，每次两个整数 $x,k$，求**删掉** $P(x,1)$ 中所有满足 $dep_y\equiv dep_x \pmod{k}$ 的 $y$ 后，满足 $dep_z \le dep_x$ 的 $z$ 中不同 $c_z$ 的数量。**每次询问独立**，也就是说这次删的点在下一次询问会恢复。

如果不理解，请看样例解释。
## 输入格式

第一行两个整数 $n,m$。

第二行 $n$ 个整数 $c_i$。

接下来 $n-1$ 行，每行两个整数 $u~v$，表示 $u~v$ 之间有连边。

接下来 $m$ 行，每行两个整数 $x_i~k_i$，表示询问。
## 输出格式

共 $m$ 行，每行一个整数，表示答案。
## 样例

### 样例输入 #1
```
11 9
3 1 4 8 8 2 6 4 7 5 1
1 2
1 3
1 4
4 9
9 10
9 11
3 5
3 6
5 8
5 7
3 1
4 1
5 2
11 4
10 3
8 2
6 1
7 1
7 2
```
### 样例输出 #1
```
2
2
5
8
6
7
3
6
7
```
## 提示

对于所有测试数据，保证 $1 \le n,m,k_i \le 10^5$，$1 \le u,v,x_i \le n$，$0 \le c_i \le 10^5$。

| Subtask | 限制 | 分值 |
| :----------: | :----------: | :----------: |
| $0$ | $n,m \le 10^3$ | $10$ |
| $1$ | $c_i$ 相同 | $4$ |
| $2$ | $k_i > \max\limits_{j=1}^{n} dep_j$ | $16$ |
| $3$ | $n,m \le 5\times 10^4$ | $30$ |
| $4$ |无 | $40$ |

**样例解释**

对于第 $1$ 个询问，满足条件的 $y$ 为：$1,3$。删掉之后，满足条件的 $z$ 为：$2,4$。其中 $c_1=2,c_4=8$，所以答案为 $2$。

对于第 $3$ 个询问，满足条件的 $y$ 为：$1,5$。删掉之后，满足条件的 $z$ 为：$2,3,4,6,9$。其中 $c_2=1,c_3=4,c_4=8,c_6=2,c_9=7$，所以答案为 $5$。


---

---
title: "【MX-X12-T6】「ALFR Round 5」Coloring Nodes"
layout: "post"
diff: 省选/NOI-
pid: P12423
tag: ['O2优化', '梦熊比赛']
---
# 【MX-X12-T6】「ALFR Round 5」Coloring Nodes
## 题目背景

原题链接：<https://oier.team/problems/X12F>。
## 题目描述

给定一棵 $n$ 个点的树，初始时所有结点为白色。

你可以花费 $w_u$ 的代价将结点 $u$ 染黑。

有 $q$ 次询问，每次询问形如 `u l r`。对于每次询问，你需要花费尽可能小的代价，将一些结点染黑，使得点 $u$ 到**叶结点** $v$ 的简单路径上存在黑色结点，**当且仅当** $l \le v \le r$，并输出最小代价。
## 输入格式

第一行，两个整数 $n, q$，表示结点数量和询问个数。 

第二行，$n$ 个整数 $w_1, w_2, \ldots, w_n$，表示将每个结点染黑的代价。  

接下来 $n-1$ 行，每行两个整数 $u, v$，表示一条树边。 

接下来 $q$ 行，每行三个整数 $u, l, r$，表示一次询问。
## 输出格式

对于每个询问，输出一行：

若存在满足条件的染色方案，输出最小代价；否则输出 `Impossible`。
## 样例

### 样例输入 #1
```
3 4
4 3 1
1 3
3 2
2 1 2
1 2 3
1 1 3
3 1 2

```
### 样例输出 #1
```
3
1
4
1

```
### 样例输入 #2
```
7 3
1 -9 1 -9 8 -1 0
1 2
2 3
2 4
4 5
5 6
6 7
1 3 3
1 2 7
1 1 2
```
### 样例输出 #2
```
1
-19
Impossible
```
### 样例输入 #3
```
5 5
6 1 4 -6 8
2 4
1 5
3 4
5 4
5 2 3
1 2 3
5 3 3
3 1 5
2 5 5

```
### 样例输出 #3
```
-6
-6
4
-2
0
```
## 提示

**【样例解释 #1】**  

该样例满足特殊性质 A。  

对于第一次询问，染黑 $2$ 号点，最小代价为 $3$；  

对于第二次询问，染黑 $3$ 号点，最小代价为 $1$；

对于第三次询问，染黑 $1$ 号点，最小代价为 $4$；

对于第四次询问，染黑 $3$ 号点，最小代价为 $1$。

**【样例解释 #2】**  

该样例满足特殊性质 B。

对于第一次询问，染黑 $3$ 号点，最小代价为 $1$； 

对于第二次询问，染黑 $2,4,6,7$ 号点，最小代价为 $-19$；  

对于第三次询问，可证明没有可行的染色方案。

**【数据范围】**

**本题使用捆绑测试。**

对于 $100\%$ 的数据，$1 \le n, q \le 2 \times 10^5$，$|w_u| \le 10^9$，$1 \le u, v \le n$，$1 \le l \le r \le n$。

|子任务编号|$n \le$|$q \le$|特殊性质|分值|子任务依赖|
|:-:|:-:|:-:|:-:|:-:|:-:|
|$1$|$20$|$20$|无|$5$|-|
|$2$|$20$|$2 \times 10^5$|无|$5$|$1$|
|$3$|$8000$|$8000$|A|$5$|-|
|$4$|$8000$|$8000$|无|$5$|$3$|
|$5$|$8000$|$2 \times 10^5$|A|$10$|$3$|
|$6$|$8000$|$2 \times 10^5$|无|$10$|$2, 4, 5$|
|$7$|$2 \times 10^5$|$2 \times 10^5$|AB|$10$|-|
|$8$|$2 \times 10^5$|$2 \times 10^5$|A|$15$|$5, 7$|
|$9$|$2 \times 10^5$|$2 \times 10^5$|B|$15$|$7$|
|$10$|$2 \times 10^5$|$2 \times 10^5$|无|$20$|$6, 8, 9$|

特殊性质 A：$w_u \ge 0$。  

特殊性质 B：对于所有询问，$u=1$。


---

---
title: "[BalticOI 2025] Developer"
layout: "post"
diff: 省选/NOI-
pid: P12429
tag: ['2025', 'BalticOI（波罗的海）']
---
# [BalticOI 2025] Developer
## 题目描述

You are in charge of developing new properties in the suburbs of Toruń. You have already decided that there will be one main street and $n$ properties numbered from 1 to $n$ along the street. The area is somewhat hilly, and the elevation of the $i$-th property is $a_i$ centimetres.

It turns out that no one wants to buy a property that is on a slope. Formally, for elevations $a_1, a_2, \ldots, a_n$, a slope is a contiguous subsequence $a_{i-1}, a_i, \ldots, a_j, a_{j+1}$ with $2 \leq i \leq j \leq n-1$ such that either (i) $a_{i-1} < a_i = a_{i+1} = \ldots = a_j < a_{j+1}$, or (ii) $a_{i-1} > a_i = a_{i+1} = \ldots = a_j > a_{j+1}$. Intuitively, a slope is a contiguous range of properties at positions $i-1, i, i+1, \ldots, j, j+1$, where the elevations of all properties at positions $i, i+1, \ldots, j$ are equal to some $h$, and $h$ is strictly between $a_{i-1}$ and $a_{j+1}$.

You are able to increase or decrease the elevation of any property by any integer, but of course you want to minimise the overall effort. Your task is to determine the minimal total change in elevation such that there are no slopes at all. That is, you want to find elevations $b_1, b_2, \ldots, b_n$ without slopes such that $|a_1 - b_1| + |a_2 - b_2| + \ldots + |a_n - b_n|$ is as small as possible. The elevations $b_i$ must be integers (in particular, they don't have to be positive), and there are no other constraints on $b_i$.
## 输入格式

The first line contains an integer $n$ ($1 \leq n \leq 2 \cdot 10^5$) denoting the number of properties along the street.

The second line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($0 \leq a_i \leq 10^9$), where the $i$-th integer $a_i$ is the initial elevation of the $i$-th property.
## 输出格式

You should output the minimal total change in elevation to ensure that there are no slopes.
## 样例

### 样例输入 #1
```
11
7 2 1 2 5 7 8 8 10 8 8
```
### 样例输出 #1
```
5
```
## 提示

This is illustrated below. The dashed lines represent the changed elevations without slopes bi of their corresponding properties.

![](https://cdn.luogu.com.cn/upload/image_hosting/nbh6cd1e.png)

### Scoring

| Subtask | Constraints | Points |
| :---: | :---: | :---: |
| 1 | $n \leq 5$ and $a_i \leq 10$ | 4 |
| 2 | $n \leq 2000$ | 13 |
| 3 | $a_i \leq 10$ | 8 |
| 4 | $a_i < a_{i+1}$ | 19 |
| 5 | $n \leq 2 \cdot 10^4$ | 29 |
| 6 | No additional constraints. | 27 |



---

---
title: "[BalticOI 2025] Exponents"
layout: "post"
diff: 省选/NOI-
pid: P12430
tag: ['2025', 'BalticOI（波罗的海）']
---
# [BalticOI 2025] Exponents
## 题目描述

The famous polymath Nicolaus Copernicus was born and grew up in Toruń in the 15th century. Archaeologists have recently discovered his notebook, and learned that he was fond of using powers of two to store large numbers. In particular, even when he added two powers of two:

$$2^a + 2^b$$

Copernicus evaluated the result and then rounded up the result to the nearest power of two. That is, he would evaluate $2^a + 2^b$ to $2^{\max(a,b)+1}$. To evaluate a longer expression of the form:

$$2^{b_1}+2^{b_2}+\cdots + 2^{b_r}$$

he first inserted the brackets to make it well - parenthesised*. For example, an expression $2^5 + 2^4+2^4 + 2^4+2^5$ can be made well - parenthesised to obtain $((2^5 + 2^4)+(2^4+(2^4 + 2^5)))$. Finally, he evaluated the result of the obtained well - parenthesised expression, operating on powers of two as described above. Notice that the result might vary depending on how he inserts the brackets. For example, here are two possible ways to evaluate $2^5 + 2^4+2^4 + 2^4+2^5$:

$((2^5 + 2^4)+(2^4 + 2^5))=((2^6+2^4)+2^5)=(2^7 + 2^6)=2^8$

$((2^5+(2^4 + 2^4))+(2^4 + 2^5))=((2^5 + 2^5)+2^6)=(2^6+2^6)=2^7$

The first page of the Copernicus' notebook contains only a single expression $2^{a_1}+2^{a_2}+\cdots + 2^{a_n}$ called the main expression. Later pages of the notebook then reference fragments of the main expression, which are of the form $2^{a_\ell}+2^{a_{\ell + 1}}+\cdots + 2^{a_r}$, for some $1\leq \ell\leq r\leq n$.

You are not sure what their meaning, but suspect that you should calculate, for each such fragment, the smallest possible result that can be obtained when evaluating the result as described above for the fragment. Note that each fragment is evaluated independently of the other fragments.
## 输入格式

The first line contains two integers $n$ and $q$ ($1\leq n,q\leq300000$) denoting the length of the main expression from the first page of the notebook and the number of queries, respectively.

The second line contains $n$ integers $a_1,a_2,\cdots,a_n$ ($0\leq a_i\leq 10^9$), where the $i$ - th integer $a_i$ denotes the exponent of the $i$ - th power of two in the main expression.

The next $q$ lines describe the queries. Each query consists of two integers $\ell$ and $r$ ($1\leq \ell\leq r\leq n$) representing a fragment of the main expression starting at the $\ell$ - th power of two and ending at the $r$ - th power of two.
## 输出格式

You should output $q$ lines. The $i$ - th line should contain the smallest possible result that can be obtained when evaluating the fragment described in the $i$ - th query. You should output only the exponent of the corresponding power of two.
## 样例

### 样例输入 #1
```
8 4
2 4 2 5 4 4 4 5
4 8
1 4
2 5
1 7
```
### 样例输出 #1
```
7
7
7
8
```
## 提示

| Subtasks | Constrains | Score |
| :---: | :---: | :---: |
| 1 | $n \leq 8, q \leq 10$ | 6 |
| 2 | $n \leq 200$ | 8 |
| 3 | $n, q \leq 2000$ | 23 |
| 4 | $a_{i} \leq 20$ | 22 |
| 5 | No addition constrains | 41 |


---

---
title: "[COTS 2025] 答好位 / Vrsta"
layout: "post"
diff: 省选/NOI-
pid: P12446
tag: ['交互题', 'Special Judge']
---
# [COTS 2025] 答好位 / Vrsta
## 题目描述


**这是一道交互题。交互库是非自适应的。**

有一个隐藏的 $1\sim N$ 的排列 $p_1,\ldots,p_N$。

你可以提问交互库至多 $K$ 次，每次给定 $i,j$（$1\le i\lt j\le N$），交互库会回答 $p_{i},p_{i+1},\ldots,p_{j}$ 中次大元素的下标。

在你提问完后，交互库会向你提问 $Q$ 次，每次给定 $a,b$（$1\le a\lt b\le N$），你需要回答 $p_{a},p_{a+1},\ldots,p_{b}$ 中次大元素的下标。

请注意：在你提问完之后，才能得知交互库的提问。这 $Q$ 次交互库对你的提问一次性给出。

### 实现细节

首先读入正整数 $N$。

接下来，发起至多 $K$ 次提问：

- $\texttt{?}$ $i$ $j$：提问 $p_{i},p_{i+1},\ldots,p_{j}$ 中次大元素的下标。
    - 你需要保证 $1\le i\lt j\le N$。
- $\texttt{!}$：结束提问。

每次提问后，都需要换行并刷新缓冲区。

在结束提问后，读入正整数 $Q$，以及 $Q$ 对正整数 $a,b$，表示对交互库你的提问。交互库保证 $1\le a\lt b\le N$。

对于每个交互库的提问，输出一行一个正整数，表示次大元素的下标。

在你回答完所有询问后，你需要刷新缓冲区，然后终止程序运行。

**交互库是非自适应的**。也就是说，询问和排列在交互开始前就已经固定。

## 输入格式

见「实现细节」。

## 输出格式

见「实现细节」。

## 样例

### 样例输入 #1
```
4

2

1

2
1 4
2 3


```
### 样例输出 #1
```

? 1 2

? 1 3

!



4
2
```
## 提示


### 样例解释

样例的排列为 $p=[2,1,4,3]$。

### 数据范围

- $N\le 512$；
- $K=Q=2\, 048$。

### 子任务
子任务 $0$ 为样例。

其中，「$-$」表示「不保证」。

| 子任务编号 | $N\le$ |特殊性质 | 得分 |
| :-: | :-: |  :-: | :-: |
| $1$ | $64$ | $-$  |  $6$ |
| $2$ | $-$ | $\text{A}$ |  $10$ |
| $3$ | $-$ | $\text{B}$ |  $11$ |
| $4$ | $-$ | $\text{C}$  |  $13$ |
| $5$ | $256$ | $-$ |  $26$ |
| $6$ | $-$ |$-$ |  $34$ |


- 特殊性质 $\text{A}$：不存在 $i$ 使得 $p_i\gt \max\{p_{i-1},p_{i+1}\}$。
- 特殊性质 $\text{B}$：$p_1=N$。
- 特殊性质 $\text{C}$：不存在 $i$ 使得 $p_i\lt \min\{p_{i-1},p_{i+1}\}$。


**交互库是非自适应的**。也就是说，询问和排列在交互开始前就已经固定。





---

---
title: "[COTS 2025] 砍树 / Stablo"
layout: "post"
diff: 省选/NOI-
pid: P12447
tag: ['交互题', 'Special Judge']
---
# [COTS 2025] 砍树 / Stablo
## 题目描述


**这是一道交互题。本题中，交互库是非自适应的。**

有一棵 $N$ 个节点的树。这棵树中，每个节点度数至多为 $3$。

你可以提问至多 $K=2.5\times 10^5$ 次。每次给定三个两两不同的节点 $a,b,c$，交互库会回答：

- $\text{0}$，如果 $\operatorname{dist}(a,b)=\operatorname{dist}(a,c)$;
- $\text{1}$，如果 $\operatorname{dist}(a,b)\lt\operatorname{dist}(a,c)$;
- $\text{2}$，如果 $\operatorname{dist}(a,b)\gt\operatorname{dist}(a,c)$。  

定义 $\operatorname{dist}(u,v)$ 表示 $u,v$ 最短路上边的数量。

试通过询问还原这棵树。

虽然你可以提问 $K=2.5\times 10^5$ 次，但是想要获得更高的分数，需要更少的询问次数。见「计分方式」。

### 实现细节

首先读入正整数 $N$。读入后发起询问：

- $\texttt{?}$ $a$ $b$ $c$：发起一次询问。
    - 你需要保证 $1 \leq a, b, c \leq N$ 且 $a \neq b$，$b \neq c$，$c \neq a$。
    - **最多可以询问 $2.5\times 10^5$ 次。**
    - 从标准输入流读入一个整数表示答案，具体见「题目描述」。
- $\texttt{!}$：报告答案。
    - 输出 $\texttt{!}$ 后，接下来再输出 $(N-1)$ 行，每行两个正整数，描述一条树边。
    - 你可以以任意顺序输出这 $(N-1)$ 条边。
    - 报告答案后，你的程序必须终止运行。
     

**每次提问后，都需要换行并刷新缓冲区。**

**交互库是非自适应的**。也就是说，树的形态在交互开始前已经固定。
## 输入格式

见「实现细节」。
## 输出格式

见「实现细节」。
## 样例

### 样例输入 #1
```
4

1

2

0




```
### 样例输出 #1
```

? 1 2 3

? 1 4 3

? 2 1 3

!
1 2
2 3
3 4
```
## 提示


### 样例解释

样例中，树边有 $\{(1,2),(2,3),(3,4)\}$。

### 数据范围

- $N\lt 512$；
- 每个节点度数至多为 $3$。


### 子任务

- $\text{Subtask 0 (0 pts)}$：样例。
- $\text{Subtask 1 (10 pts)}$：每个节点度数至多为 $2$。
- $\text{Subtask 2 (20 pts)}$：树是满二叉树。
    - 换句话说，树是完全二叉树，且存在正整数 $k$ 使得 $N=2^k-1$。
- $\text{Subtask 3 (70 pts)}$：无额外限制。

### 计分方式

答案错误，询问次数超限，或者出现了任何未能成功运行结束的情况，得 $0$ 分。

假设你在某个分值为 $B$ 的子任务中至多用了 $K$ 次查询，则子任务得分为

$$\min\left(1, \left(\frac{14000}{K}\right)^{0.7}\right) \cdot B$$

**交互库是非自适应的**。也就是说，树的形态在交互开始前已经固定。



---

---
title: "[COTS 2025] 观草 / Trava"
layout: "post"
diff: 省选/NOI-
pid: P12448
tag: []
---
# [COTS 2025] 观草 / Trava
## 题目描述


给定正整数数列 $a_1\sim a_N$。

有 $Q$ 个操作：

- $\texttt{?}$ $k$：查询 $\displaystyle \sum_{1\le i\le N-k+1} \max(a_i,a_{i+1},\ldots,a_{i+k-1})$；
- $\texttt{+}$ $k$：令 $a_k\gets a_{k}+1$。

## 输入格式


>
>
> $N$ $Q$\
> $a_1$ $a_2$ $\ldots$ $a_N$\
> $\mathrm{op}_1$ $k_1$\
> $\vdots\quad\vdots$\
> $\mathrm{op}_Q$ $k_Q$

其中，$\mathrm{op}_i\in \{\texttt{?},\texttt{+}\}$，$1\le k_i\le N$，描述一次操作。
## 输出格式


对每个 $\texttt{?}$ 操作输出一行一个正整数，表示答案。
## 样例

### 样例输入 #1
```
6 5
1 7 2 3 5 4
+ 1
? 2
? 3
+ 5
? 3
```
### 样例输出 #1
```
27
24
26
```
### 样例输入 #2
```
10 4
1 2 2 1 3 2 1 3 2 2
? 4
? 5
+ 5
? 4
```
### 样例输出 #2
```
20
18
24
```
## 提示


### 数据范围

- $1\le N\le 5\times 10^5$；
- $0\le Q\le 5\times 10^5$；
- $1\le A_i\le 10^9$；
- $\mathrm{op}_i\in \{\texttt{?},\texttt{+}\}$；
- $1\le k_i\le N$；
- 所有输入的数均为整数。

### 子任务

Subtask 0 为样例。

| 子任务编号 | $N,Q\le$ | 特殊性质 | 得分 |
| :-: | :-: | :-: | :-: |
| $1$ | $7\, 000$ | $-$ | $13$ |
| $2$ | $5\times 10^5$ | $\text{A}$ | $16$ |
| $3$ | $5\times 10^5$ | $\text{B}$ | $23$ |
| $4$ | $5\times 10^5$ | $\text{C}$ | $10$ |
| $5$ | $10^5$ | $-$ | $20$ |
| $6$ | $5\times 10^5$ | $-$ | $18$ |

- 特殊性质 $\text{A}$：$\mathrm{op}_i\neq\texttt{+}$；
- 特殊性质 $\text{B}$：$a_i\le 10$；
- 特殊性质 $\text{C}$：对于所有 $\texttt{?}$ $k_i$ 操作，$k_i$ 均相等。



---

---
title: "[COTS 2025] 吸尘 / Usisavač"
layout: "post"
diff: 省选/NOI-
pid: P12449
tag: []
---
# [COTS 2025] 吸尘 / Usisavač
## 题目描述



Mirko 有一所大房子，由 $N$ 个房间通过 $N-1$ 条走廊连接而成。每条走廊连接两个不同的房间，且所有房间互相连通。每条走廊长 $1$ 米。Mirko 经常打扫房间，但很少清理走廊。现在走廊积满灰尘，Mirko 想要用吸尘器清理它们。  

每个吸尘器都有电缆长度限制。**每个房间有插座，吸尘器必须插入某个房间的插座才能工作**。Mirko 从房间 $1$ 出发，可以进行以下操作：  

- 若吸尘器未通电，他可以：  
    - 将吸尘器插入当前所在房间的插座。  
    - 手持吸尘器移动到相邻房间。穿过走廊需 $1$ 分钟。  
- 若吸尘器已通电，他可以：  
    - 若处于插入吸尘器的房间，可以拔下插头。  
    - 移动到相邻房间并清理路径上的走廊。仅当电缆长度足够时可行（即插入插座房间与目标房间的距离不超过电缆长度）。清理走廊需 $1$ 分钟。  

Mirko 的吸尘器坏了。现在商店有 $Q$ 台吸尘器，第 $i$ 台的电缆长度为 $r_i$ 米。他想知道对于每台吸尘器，清理所有走廊的最短时间。请帮他计算这些时间！  
## 输入格式


> $N$ $Q$\
> $x_1$ $y_1$\
> $\vdots\quad\vdots$\
> $x_{N-1}$ $y_{N-1}$\
> $r_1$ $r_2$ $\cdots$ $r_Q$

其中，$\forall 1\le i\le N-1$，$(x_i,y_i)$ 描述一条连接 $x_i$ 和 $y_i$ 的走廊。

## 输出格式

输出一行 $Q$ 个数，其中第 $i$ 个数表示使用第 $i$ 台吸尘器时的最短清理时间。  

## 样例

### 样例输入 #1
```
5 2
1 2
2 3
3 4
4 5
2 5
```
### 样例输出 #1
```
8 4
```
### 样例输入 #2
```
10 2
1 2
2 4
5 2
6 3
3 1
6 7
9 7
8 6
8 10
1 3
```
### 样例输出 #2
```
24 16
```
### 样例输入 #3
```
6 2
3 1
3 5
4 3
4 2
2 6
5 1
```
### 样例输出 #3
```
6 12
```
## 提示


### 样例解释

样例 $1$ 解释：对于 $r_i=2$ 的询问，一个最优方案如下：

- 从房间 $1$ 走到房间 $3$。（$2$ 分钟）
- 在房间 $3$ 插入吸尘器。
- 吸尘房间 $3,4$ 间以及房间 $4,5$ 间的走廊（$2$ 分钟）。
- 返回房间 $3$。（$2$ 分钟）
- 吸尘房间 $3,2$ 间以及房间 $2,1$ 间的走廊（$2$ 分钟）。这样所有走廊都已清理干净。

### 数据范围

- $2 \leq N \leq 3 \times 10^5$；
- $1 \leq Q \leq 3 \times 10^5$；
- $1\le x_i,y_i\le N$；
- $x_i\neq y_i$；
- 任意两个房间都通过走廊连通；
- $1\le r_i\le N$；
- 所有输入的数均为整数。

### 子任务

Subtask 0 为样例。

| 子任务编号 | $N\le$ | $Q\le$ | 特殊性质 | 得分 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $10^3$    | $10^3$ | $-$ | $16$ |
| $2$ | $3\times 10^5$    | $3\times 10^5$ | $\text{A}$ | $10$ |
| $3$ | $3\times 10^5$    | $1$ | $-$ | $22$ |
| $4$ | $10^5$    | $10^5$ | $-$ | $31$ |
| $5$ | $3\times10^5$    | $3\times10^5$ | $-$ | $21$ |

特殊性质 $\text{A}$：$\forall 1\le i\le N-1$，存在一条连接 $i$ 和 $i+1$ 的走廊。



---

---
title: "[TJOI2011] 书架"
layout: "post"
diff: 省选/NOI-
pid: P1295
tag: ['2011', '各省省选', '天津']
---
# [TJOI2011] 书架
## 题目背景

由于最近又购买了很多书，所以你打算在自己的书房做一个新书架，为了照顾整体效果，你希望你的书架的宽度越小越好。

书架背靠墙摆放，宽度就是指书架在垂直于墙面的方向上占据的距离。
## 题目描述

现按一定顺序给出所有要放置于书架上的书，共有 $n$ 本，第 $i$ 本书有一个长度 $h_i$。

书架有若干层，层与层之间的宽度不一定相等，但是一层的宽度不能小于其上所摆放的任何一本书的长度。同时，每层上的书的长度之和不能超过一个给定的参数 $m$，且任何层上的书必须是给出的书的序列中连续的几本。

书架的宽度是所有层的宽度之和，求书架的最小宽度。
## 输入格式

输入的第一行包含两个整数 $n$ 和 $m$。

第 $2$ 到第 $(n + 1)$ 行，每行一个整数，第 $(i + 1)$ 行的整数代表第 $i$ 本书的长度 $h_i$。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
4 6
1
3
3
1
```
### 样例输出 #1
```
5
```
## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $ n \leq 10^3$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^5$，$1 \leq h_i \leq 10^9$，$\max\limits_{i = 1}^{n} h_i \leq m \leq 10^9$。

#### 提示

由于原题题意严重模糊不清，现给出简化版题意：

给出一个长度为 $n$ 的序列 $h$，请将 $h$ 分成若干段，满足每段数字之和都不超过 $m$，最小化每段的最大值之和。 


---

---
title: "[CERC2016] Easy Equation"
layout: "post"
diff: 省选/NOI-
pid: P1400
tag: ['2016', 'Special Judge', 'ICPC']
---
# [CERC2016] Easy Equation
## 题目描述

Given an integer $k$ greater than $1$, it is possible to prove that there are infinitely many triples of positive integers $(a, b, c)$ that satisfy the following equation:

$$a^2+b^2+c^2=k(ab+bc+ca)+1$$

Given positive integers $n$ and $k$, find $n$ arbitrary triples $(a_1, b_1, c_1), (a_2, b_2, c_2), \cdots , (a_n, b_n, c_n)$ that all
satisfy the equation. Furthermore, all $3n$ integers $(a_1, b_1, c_1), (a_2, b_2, c_2), \cdots , (a_n, b_n, c_n)$ should be different positive integers with at most $100$ decimal digits each.
## 输入格式

The first line contains two integers $k$ and $n\;(2 \leq k \leq 1000, 1 \leq n \leq 1000)$ — the constant k in the
equation and the target number of triples.
## 输出格式

Output $n$ lines. The $i$-th line should contain three space separated integers $a_i$, $b_i$ and $c_i$ with at most $100$ digits each — the $i$-th of the solutions you found.
## 样例

### 样例输入 #1
```
2 8
```
### 样例输出 #1
```
1 2 6
3 10 24
12 35 88
15 28 84
4 5 18
14 33 90
40 104 273
21 60 152
```
### 样例输入 #2
```
3 3
```
### 样例输出 #2
```
1 3 12
8 21 87
44 165 615
```
## 题目翻译

### 题目描述：
假设 $k$ 大于 $1$，
可以证明有无穷多个正整数三元组 $(a, b, c)$ 满足以下方程:

   $a^2 + b^2 + c^2 = k(ab + bc + ca) + 1$
    
给定正整数 $n$ 和 $k$，找出 $n$ 个三元组 $(a_1, b_1, c_1), (a_2, b_2, c_2), ⋯ ,(a_n, b_n, c_n)$ 使它们都满足方程。另外，这 $3n$ 个正整数 $(a_1, b_1, c_1), (a_2, b_2, c_2), ⋯ ,(a_n, b_n, c_n)$ 应该是不同的，每个数最多有 $100$ 位。

### 输入格式：
第一行包含两个整数：
方程中的常数 $k$ 和 
所求三元组的数量 $n$ $(2 ≤ k ≤ 1000, 1 ≤ n ≤ 1000)$;

### 输出格式：
输出有 $n$ 行。第 $i$ 行应该包含三个空格分隔的正整数 $ai$, $bi$ 和 $ci$，
为你找到的第 $i$ 个解。每个数最多 $100$ 位。


---

---
title: "[集训队互测 2000] 丘比特的烦恼"
layout: "post"
diff: 省选/NOI-
pid: P1500
tag: ['2000', '集训队互测']
---
# [集训队互测 2000] 丘比特的烦恼
## 题目背景

随着社会的不断发展，人与人之间的感情越来越功利化。最近，爱神丘比特发现，爱情也已不再是完全纯洁的了。这使得丘比特很是苦恼，他越来越难找到合适的男女，并向他们射去丘比特之箭。于是丘比特千里迢迢远赴中国，找到了掌管东方人爱情的神——月下老人，向他求教。

月下老人告诉丘比特，纯洁的爱情并不是不存在，而是他没有找到。在东方，人们讲究的是缘分。月下老人只要做一男一女两个泥人，在他们之间连上一条红线，那么它们所代表的人就会相爱——无论他们身处何地。而丘比特的爱情之箭只能射中两个距离相当近的人，选择的范围自然就小了很多，不能找到真正的有缘人。
## 题目描述

情人节（Valentine's day）的午夜零时，丘比特开始了自己的工作。他选择了一组数目相等的男女，感应到他们互相之间的缘分大小，并依此射出了神箭，使他们产生爱意。他希望能选择最好的方法，使被他选择的每一个人被射中一次，且每一对被射中的人之间的缘分的和最大。

当然，无论丘比特怎么改造自己的弓箭，总还是存在缺陷的。首先，弓箭的射程尽管增大了，但毕竟还是有限的，不能像月下老人那样，做到“千里姻缘一线牵”。其次，无论怎么改造，箭的轨迹终归只能是一条直线，也就是说，如果两个人之间的连线段上有别人，那么莫不可向他们射出丘比特之箭，否则，按月下老人的话，就是“乱点鸳鸯谱”了。

作为一个凡人，你的任务是运用先进的计算机为丘比特找到最佳的方案。
## 输入格式

输入第一行为正整数 $k$，表示丘比特之箭的射程。

第二行为正整数 $n$。

随后有 $2 \times n$ 行，表示丘比特选中的人的信息，其中前 $n$ 行为男子，后 $n$ 行为女子。

每个人的信息由两部分组成：他的姓名和他的位置。姓名是长度小于 $20$ 且仅包含字母的字符串，忽略大小写的区别，位置是由一对整数表示的坐标，它们之间用空格分隔。格式为 ```x y Name```。

输入文件剩下的部分描述了这些人的缘分。每一行的格式为 ```Name1 Name2 p```。

`Name1` 和 `Name2` 为有缘人的姓名，$p$ 是他们之间的缘分值（$p$ 为小于等于 $255$ 的正整数）。

以一个 ```End``` 作为文件结束标志。

每两个人之间的缘分至多只被描述一次。如果没有被描述，则说明他们缘分值为 $1$。
## 输出格式

输出仅一个正整数，表示每一对被射中的人之间的缘分的总和。这个和应当是最大的。
## 样例

### 样例输入 #1
```
2
3
0 0 Adam
1 1 Jack
0 2 George
1 0 Victoria
0 1 Susan
1 2 Cathy
Adam Cathy 100
Susan George 20
George Cathy 40
Jack Susan 5
Cathy Jack 30
Victoria Jack 20
Adam Victoria 15
End

```
### 样例输出 #1
```
65
```
## 提示

$1\le n\le 30$。

CTSC2000 第二试



---

---
title: "[ICPC 2016 WF] Oil"
layout: "post"
diff: 省选/NOI-
pid: P1691
tag: ['2016', 'ICPC']
---
# [ICPC 2016 WF] Oil
## 题目描述

A large part of the world economy depends on oil, which is why research into new methods for finding
and extracting oil is still active. Profits of oil companies depend in part on how efficiently they can
drill for oil. The International Crude Petroleum Consortium (ICPC) hopes that extensive computer
simulations will make it easier to determine how to drill oil wells in the best possible way.

Drilling oil wells optimally is getting harder each day – the newly discovered oil deposits often do
not form a single body, but are split into many parts. The ICPC is currently concerned with stratified deposits, as illustrated in Figure G.1.

To simplify its analysis, the ICPC considers only the 2-dimensional case, where oil deposits are modeled
as horizontal line segments parallel to the earth’s surface. The ICPC wants to know how to place a single
oil well to extract the maximum amount of oil. The oil well is drilled from the surface along a straight
line and can extract oil from all deposits that it intersects on its way down, even if the intersection is at
an endpoint of a deposit. One such well is shown as a dashed line in Figure G.1, hitting three deposits.
In this simple model the amount of oil contained in a deposit is equal to the width of the deposit. Can
you help the ICPC determine the maximum amount of oil that can be extracted by a single well?
## 输入格式

The first line of input contains a single integer n ($1 ≤ n ≤ 2 000$), which is the number of oil deposits.

This is followed by $n$ lines, each describing a single deposit. These lines contain three integers $x_0$,
$x_1$, and y giving the deposit’s position as the line segment with endpoints $(x_0, y)$ and $(x_1, y)$. These
numbers satisfy $|x_0|, |x_1| ≤ 10^6$
and $1 ≤ y ≤ 10^6$
. No two deposits will intersect, not even at a point.

## 输出格式

Display the maximum amount of oil that can be extracted by a single oil well.
## 样例

### 样例输入 #1
```
5
100 180 20
30 60 30
70 110 40
10 40 50
0 80 70
```
### 样例输出 #1
```
200
```
### 样例输入 #2
```
3
50 60 10
-42 -42 20
25 0 10
```
### 样例输出 #2
```
25
```
## 题目翻译

### 题目描述
世界经济的很大一部分依赖于石油，这就是为什么对发现和开采石油的新方法的研究仍然活跃。石油公司的利润在一定程度上取决于他们能够多么有效地钻探石油。国际原油石油联盟（ICPC）希望通过广泛的计算机模拟来更容易地确定如何以最佳方式钻探油井。

每天钻探油井变得越来越困难，因为新发现的油藏通常不是一个整体，而是分裂成许多部分。ICPC目前关注的是分层沉积物。

为了简化其分析，ICPC只考虑二维情况，其中油藏被建模为与地球表面平行的水平线段。ICPC想知道如何放置一个单独的油井以提取最大量的石油。油井沿着一条直线从地面钻井，并可以从其下降的路径上相交的所有沉积物中提取石油，即使相交点位于沉积物的端点处。图G.1中显示了一个这样的井，击中三个沉积物。在这个简单的模型中，一个沉积物中含有的石油量等于该沉积物的宽度。你能帮助ICPC确定通过一个单井可以提取的最大石油量吗？

### 输入格式
输入的第一行包含一个整数 $n (1\le n\le 2000)$，表示油田的数量。

接下来的 $n$ 行，每行描述一个沉积物。这些行包含三个整数 $x_0、x_1$ 和 $y$，表示沉积物的位置为线段，其端点为 $(x_0,y)$ 和 $(x_1,y)$。这些数字满足 $|x_0|,|x_1|≤10^6$。没有两个沉积物会相交，甚至不会在一点相交。

### 输出格式
输出一个整数，表示单个油井可以提取的最大石油量。



---

---
title: "[CERC2016] Lost Logic"
layout: "post"
diff: 省选/NOI-
pid: P1745
tag: ['2016', 'Special Judge', 'ICPC']
---
# [CERC2016] Lost Logic
## 题目描述

Gustav is reading about *2-satisfiability*, a well known problem of assigning truth values to boolean
variables in order to satisfy a list of *constraints* — simple logical formulas involving two variables each.

We are using $n$ variables $x_1, x_2, \cdots , x_n$ that can take on values $0$ (false) and $1$ (true). A constraint is a
formula of the form $a\to b$ where both $a$ and $b$ are possibly negated variables. As usual, $\to$ denotes
logical implication: $a \to b$ is $0$ only when $a$ is $1$ and $b$ is $0$. The negation of variable $a$ is denoted by $!a$.

Given an assignment of values to variables, we say that the constraint is *satisfied* if it evaluates to $1$.
Gustav has constructed a list of constraints and correctly concluded that there are *exactly three* different
assignments of values to variables that satisfy all the constraints. Gustav has wrote down all three
assignments but has, unfortunately, lost the list of constraints.
Given three assignments of $n$ values to variables, find any list consisting of at most $500$ constrains such
that the three given assignments are the *only* assignments that satisfy all the constraints.


## 输入格式

The first line contains an integer $n (2 \leq n \leq 50)$ — the number of variables. Three lines follow, each
describing one assignment. The $k$-th line contains $n$ space-separated integers $v_1^k,v_2^k,\cdots,v_n^k$, where each $v_i^k$ is either $0$ or $1$ and denotes the value of the variable $x_i$ in the $k$-th assignment. All three assignments will be different.
## 输出格式

If there is no solution output a single line containing the integer $−1$.
Otherwise, the first line should contain an integer $m$ where $1 \leq m \leq 500$ — the number of constraints
in your solution. The $k$-th of the following $m$ lines should contain the $k$-th constraint. Each constraint
should be a string constructed according to the following rules:

- A *variable* is a string of the form “$\texttt{x}i$” where $i$ is an integer between $1$ and $n$ inclusive written
  without leading zeros.
- A *literal* is a string consisting of a variable possibly preceded by the “$\texttt{!}$” character.
- A *constraint* is a string of the form “$a\texttt{ -> }b$” where both $a$ and $b$ are literals. The implication sign
  consists of the “minus” character and the “greater-than” character and there is a single space
  character both before and after the implication sign.


## 样例

### 样例输入 #1
```
3
0 0 0
0 1 0
1 0 0
```
### 样例输出 #1
```
3
x1 -> !x2
x3 -> x1
x3 -> x2
```
### 样例输入 #2
```
4
0 0 1 0
1 0 0 0
1 0 1 1
```
### 样例输出 #2
```
-1
```
## 题目翻译

给定 $3$ 组随机布尔变量 $v_{i,1},...,v_{i,n}(1\leq i\leq 3)$，每组均为 $n$ 个。你需要构造关于布尔变量 $x_1,...,x_n$ 的若干组**条件**，使得满足全部条件的布尔变量赋值**有且仅有** $(v_{i,1},...,v_{i,n})(1\leq i\leq 3)$ 这 $3$ 组。

由于机器限制，你所构造每组条件的形式均应为：$A\rightarrow B$。这组条件的限制了：当 $A$ 为 $1$ 时 $B$ 一定为 $1$。其中，$A,B$ 可能形如：

- $x_i$：表示第 $i$ 个变量的值。
- $!x_i$：表示第 $i$ 个变量取反后的值。

例如，如果你构造了 $x_1\rightarrow x_2$，那么表示你规定 $x_1=1$ 时必有 $x_2=1$；如果你构造了 $!x_1\rightarrow x_2$，那么你规定了 $x_1=0$ 时必有 $x_2=1$。你需要找到一种使用不超过 $500$ 组条件来满足题意的方法，或者判定这样的条件组合不可能存在。如果有多组解，输出任意一组均可。

数据保证 $2\leq n\leq 50,v_{i,j}\in\{0,1\}(1\leq i\leq 3,1\leq j\leq n)$。


---

---
title: "帮助"
layout: "post"
diff: 省选/NOI-
pid: P1777
tag: ['NOI 导刊']
---
# 帮助
## 题目描述

Bubu 的书架乱成一团了！帮他一下吧！

他的书架上一共有 $n$ 本书。我们定义混乱值是连续相同高度书本的段数。例如，如果书的高度是 $[30,30,31,31,32]$，那么混乱值为 $3$；$[30,32,32,31]$ 的混乱度也是 $3$，但 $[31,32,31,32,31]$ 的混乱度是 $5$，这实在是太乱了。

Bubu 想尽可能地减少混乱度，但他有点累了，所以他决定最多取出 $k$ 本书，再随意将它们放到书架上。你能帮助他吗？
## 输入格式

每个输入文件包含最多 $20$ 组测试数据。

每组测试数据开头为两个整数 $n,k\ (1 \le k \le n \le 100)$，表示总共有 $n$ 本书，最多可以进行 $k$ 次搬书操作。

接下来一行有 $n$ 个整数，表示每本书的高度，从左到右。每本书的高度是 $25$ 到 $32$ 间的整数。

最后一组数据后有一行 $n=k=0$，表示输入结束。
## 输出格式

对于每一组数据，输出 $\text{Case}$ 标号和最终最小的混乱度。在每组数据后输出一个空行。

## 样例

### 样例输入 #1
```
5 2
25 25 32 32 25
5 1
25 26 25 26 25
0 0
```
### 样例输出 #1
```
Case 1: 2

Case 2: 3


```


---

---
title: "[国家集训队] 人员雇佣"
layout: "post"
diff: 省选/NOI-
pid: P1791
tag: []
---
# [国家集训队] 人员雇佣
## 题目背景

原《线段覆盖》请做P1803
## 题目描述

作为一个富有经营头脑的富翁，小 $L$ 决定从本国最优秀的经理中雇佣一些来经营自己的公司。这些经理相互之间合作有一个贡献指数，（我们用 $E_{i,j}$ 表示 $i$ 经理对 $j$ 经理的了解程度），即当经理 $i$ 和经理 $j$ 同时被雇佣时，经理 $i$ 会对经理 $j$ 做出贡献，使得所赚得的利润增加 $E_{i,j}$。

当然，雇佣每一个经理都需要花费一定的金钱 $A_i$，对于一些经理可能他做出的贡献不值得他的花费，那么作为一个聪明的人，小 $L$ 当然不会雇佣他。然而，那些没有被雇佣的人会被竞争对手所雇佣，这个时候那些人会对你雇佣的经理的工作造成影响，使得所赚得的利润减少 $E_{i,j}$（注意：这里的 $E_{i,j}$ 与上面的 $E_{i,j}$ 是同一个）。

作为一个效率优先的人，小 $L$ 想雇佣一些人使得净利润最大。你可以帮助小 $L$ 解决这个问题吗？
## 输入格式

第一行有一个整数，表示经理的个数。

第二行有 $N$ 个整数 $A_i$ 表示雇佣每个经理需要花费的金钱。

接下来的 $N$ 行中一行包含 $N$ 个数，表示 $E_{i,j}$，即经理 $i$ 对经理 $j$ 的了解程度。满足 $E_{i,j}=E_{j,i}$。
## 输出格式

第一行包含一个整数，即所求出的最大值。
## 样例

### 样例输入 #1
```
3
3 5 100
0 6 1
6 0 2
1 2 0
```
### 样例输出 #1
```
1
```
## 提示

- $20\%$ 的数据中 $N\le 10$；
- $50\%$ 的数据中 $N\le 100$；
- $100\%$ 的数据中 $N\le 1000$，$E_{i,j}<2^{31}$，$A_i<2^{31}$。

From 林衍凯。


---

---
title: "公共子序列"
layout: "post"
diff: 省选/NOI-
pid: P1819
tag: ['NOI 导刊']
---
# 公共子序列
## 题目描述

求 $3$ 个字符序列有多少个不同的公共子序列，不包括空序列。
## 输入格式

第一行为一个正整数 $n$，表示 $3$ 个序列的长度。

接下来 $3$ 行，每行一个无空格长度为 $n$ 的字符序列。只包含小写字母 `a` 到 `z`。
## 输出格式

一行一个正整数 $ans$，对 $10^8$ 取模。
## 样例

### 样例输入 #1
```
4   
aabb   
abab   
baba

```
### 样例输出 #1
```
5
```
## 提示

#### 样例 1解释

对于唯一的一个样例，有 $5$ 种子序列，分别是 `a`，`ab`，`aa`，`bb`，`b`。

#### 数据范围与约定

- 对于 $30\%$ 的数据，保证 $1 \le n \le 10$；
- 对于 $70\%$ 的数据，保证 $1 \le n \le 50$；
- 对于 $100\%$ 的数据，保证 $1 \le n \le 150$。


---

---
title: "无边的网格"
layout: "post"
diff: 省选/NOI-
pid: P1945
tag: []
---
# 无边的网格
## 题目描述

在一个 $R$ 行 $C$ 列的表格中，每个单元格都是正方形。这种表格便被称为“网格”，每个单元格的四个顶点都叫做“格点”。四个顶点都在格点上的正方形叫做“格点正方形”；类似地，三个顶点都在格点上的正三角形叫做“格点正三角形”。

对于给定的正整数 $R$ 和 $C$（$R,C \le 10$），请计算出网格中格点正方形和格点正三角形的个数。

这种题目 GZH 已经在数学试卷上见得多了。经过浮想联翩、鸟语花香的过程，他认为它与网格问题、计数问题、对称性问题等经典数学题型有异曲同工之妙，可以很方便快捷地解出。但是同时他也发现，一旦 $R$ 和 $C$ 不再满足题中的条件，而是变得很大，计数将会变得枯燥。

当然，聪明的你们对此肯定是喜闻乐见，因为编程在这里又可以派上用处了。

你们能写一个程序来帮 GZH 在这无边的网格中完成枯燥的计数吗？
## 输入格式

共一行，包含 $2$ 个用单个空格隔开的正整数 $R$ 和 $C$。
## 输出格式

共一行，包含 $2$ 个用单个空格隔开的整数 $\mathit{ans}_1$ 和 $\mathit{ans}_2$，按序表示网格中格点正方形和格点正三角形的个数。
## 样例

### 样例输入 #1
```
2 3


```
### 样例输出 #1
```
10 0


```
## 提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/s6aq84is.png)

输入文件表明，要求求出图中的格点正方形个数和格点正三角形个数。

- 格点正方形的个数被分类计数如下：  
  ![](https://cdn.luogu.com.cn/upload/image_hosting/fb9fn4gw.png)  
  共十个。
- 不难发现，所给的网格中找不到格点正三角形。

### 数据范围及约定

- 对于 $30\%$ 的数据，$R,C \le 50$；
- 对于 $50\%$ 的数据，$R,C \le 10^3$；
- 对于 $70\%$ 的数据，$R,C \le 10^5$，$\mathit{ans}_1,\mathit{ans}_2<2^{63}$；
- 对于 $90\%$ 的数据，$R,C \le 10^{100}$；
- 对于 $100\%$ 的数据，$R,C \le 10^{1000}$。


---

---
title: "[JSOI2010] 巨额奖金"
layout: "post"
diff: 省选/NOI-
pid: P2143
tag: ['2010', '各省省选', '江苏']
---
# [JSOI2010] 巨额奖金
## 题目描述

 NJ 市的快速发展得益于其便捷的交通。可是，随着经济的发展，大量的人进入 NJ 市， NJ 市的交通也承受着巨大的压力。现在， NJ 市正在筹划建设一个新型的交通枢纽，从而减轻交通的压力。

 NJ 市包含 $n$ 个区，有些区之间有双向的干道存在。新型交通枢纽建设在这些干道的基础上，将其中的部分干道改进为新型干道。改进后，干道能承受的压力可以比原来增加几十倍。为了和谐发展，在新型的交通枢纽建成后，要求任何两个区之间都可以只通过新型干道（直接或间接地）连接。政府已经预测出每条干道改进为新型干道的费用。政府希望建设新型交通枢纽的总费用最小，并以巨额奖金向市民征集方案。政府很快发现费用最小的方案不一定唯一，所以决定将奖金平分给每一种方案的第一个设计者，即如果一个人设计的费用是最小的而且前面没人和他设计出一模一样的方案，则他可获奖。

 Js08 被奖金深深的吸引，准备设计一种方案。可是，他发现方案可能会很多，如果最后获奖者太多，巨额的资金分到每个人头上的也不会太多。所以他决定先算一下可行的方案数是多少。

## 输入格式

输入共 $m + 1$ 行。

输入的第一行包含两个数 $n, m$，分别表示该市有多少个区和有多少条干道。

接下来 $m$ 行，每行三个数 $a_i$、$b_i$、$c_i$，表示 $a_i$ 区和 $b_i$ 区之间有一条干道，如果改进需要 $c_i$ 的费用。
## 输出格式

输出费用最小的方案有多少种。由于答案可能很大，你只要输出方案数除以 $31011$ 的模即可。
## 样例

### 样例输入 #1
```
4 6

1 2 1

1 3 1

1 4 1

2 3 2

2 4 1

3 4 1


```
### 样例输出 #1
```
8
```
## 提示

### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$，$1 \leq m \leq 1000$，$1 \leq a _ i, b _ i \leq n$，$1 \leq c _ i \leq 10 ^ 9$。


---

---
title: "[SDOI2009] 细胞探索"
layout: "post"
diff: 省选/NOI-
pid: P2156
tag: ['2009', '各省省选', '山东']
---
# [SDOI2009] 细胞探索
## 题目描述

生物课上，老师开始为同学们介绍细胞。为了加深同学们的印象，老师在一张N×M的矩阵中定义了一种细胞，矩阵中仅有井号“#”和点“.”：

细胞由细胞核、细胞质及细胞膜构成。细胞核是一个4连通（上下左右相连）的全为“#”的连通块，它必须实心，即不能存在一个4连通的“.”连通块被其完全包围（所谓完全包围指的是，这个“.”连通块不能位于矩阵边界相邻，且它的4相邻格子均属于包含它的“#”连通块）。细胞膜是一个8连通（上下左右，以及4个对角方向）的全为“#”的非实心连通块。细胞膜仅包围一个4连通的区域，且这个区域内有且仅有一个细胞核，这个区域剩下的位置全为“.”。

所有连通块必须极大化，即一个8连通块周围不能找到一个“#”与这个连通块的任意一个“#”8连通；同样，对于一个4连通块周围不能找到一个“#”与这个连通块的任意一个“#”4连通。

现在，老师画了一幅图画，并让小E回答图画中一共有几个细胞，并把图画中不属于任何一个细胞的“#”改成“.”。

## 输入格式

输入文件explore.in的第一行包含两个用空格分隔的正整数N和M，表示矩阵的高和长。

接下来一个N行M列的矩阵，矩阵中仅含井号“#”和点“.”，保证没有多余字符。

## 输出格式

输出文件explore.out第一行包含一个整数，表示输入的矩阵中的细胞数。

接下来一个N行M列的矩阵，矩阵中仅含井号“#”和点“.”，表示更改后的图画。

## 样例

### 样例输入 #1
```
12 13

.###..#####..

#...#.#....#.

#.#.#.#..#.#.

#...#..#...#.

.###.#..###..

....#..##...#

..........###

##########..#

#...........#

#.###...###.#

#...........#

#############


```
### 样例输出 #1
```
1

......#####..

......#....#.

......#..#.#.

.......#...#.

........###..

.......##....

.............

.............

.............

.............

.............

.............


```
### 样例输入 #2
```
9 14

#########.....

#.......#....#

#.#####.#...#.

#.#...#.#..#..

#.#.#.#.#.#..#

#.#...#.#..#..

#.#####.#...#.

#.......#....#

#########.....


```
### 样例输出 #2
```
1

..............

..............

..#####.......

..#...#.......

..#.#.#.......

..#...#.......

..#####.......

..............

..............


```
### 样例输入 #3
```
7 15

#######.#######

#.....#.#.....#

#.###.#.#.###.#

#.#.#.#.#.#...#

#.###.#.#.###.#

#.....#.#.....#

#######.#######


```
### 样例输出 #3
```
1

........#######

........#.....#

........#.###.#

........#.#...#

........#.###.#

........#.....#

........#######


```
## 提示

对于20%的数据，满足1 ≤ N, M ≤ 20。

另有20%的数据，满足所有“#”都属于某一个正确的细胞。

对于100%的数据，满足1 ≤ N, M ≤ 1,000。



---

---
title: "[SHOI2007] 交通网络"
layout: "post"
diff: 省选/NOI-
pid: P2164
tag: ['2007', '各省省选', '上海', 'Special Judge']
---
# [SHOI2007] 交通网络
## 题目描述

著名的城市交通规划师L.Serenade为OItown的各个城堡之间设计了一套的地铁交通网络。每一条地铁线路都用来双向连通两个城堡。因为是建在地下的不同深度，所以这些地铁线路是可以“交叉”的。

OItown的居民们的生活和工作都在不同的城堡中进行，于是，每个OItown的居民都要在每天早晨从家出发，乘地铁去工作，当然地铁换乘是允许的。不过每个居民都会选择换乘次数最少的乘车方式。如果有多种乘车方式，这些乘车方式所需要的换乘次数一样，那么居民每天都会等概率的随机选择其中一种。

现在L.Serenade想请你为他计算出，每天每条地铁线路在早晨的平均客流量。他会告诉你，每个居民的家和工作地址，还有他设计的地铁交通网络的全部信息。

当然L.Serenade保证，交通网络能把城市连为一体，而且任意两个城堡之间的最优乘车方式（即换成次数最少的）不超过2^63-1种。

## 输入格式

输入文件的第一行有两个整数n、m，分别表示OItown里的城堡数（这些城堡用1.2.3...n标号）和地铁线路的数量。

接下去m行，每行包含两个整数，x、y，表示这两个城堡之间有一条地铁线路。注意，两个城堡之间最多只有一条地铁线路，且每条地铁线路只被输入文件描述一次。

最后的n行，每行有n个整数。

第i行的第j个非负整数Ci，j表示每天早晨有Ci，j个OItown的居民要从i城堡去j城堡。输入数据保证Ci，i=0。

## 输出格式

输出文件有m行，每行依次表示每条地铁线路每天早晨的平均客流。精确到小数点后一位。整数也应输出一位小数，例如1应输出为1.0。

## 样例

### 样例输入 #1
```
6 7
1 2
1 3
2 4
2 5
3 5
4 6
5 6
0 0 0 0 0 1
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
0 0 0 0 0 0
```
### 样例输出 #1
```
0.7
0.3
0.3
0.3
0.3
0.3
0.7
```
## 提示

样例说明：从城堡1到城堡六的使得换乘次数最少的乘车方式共有3种：1-2-4-6；1-2-5-6；1-3-5-6。所以每个人都有1/3的概率选择这其中的每一种。


N< = 300

M< = N\*(N-1) div 2

0< = C(i,j) < = 100



---

---
title: "[HNOI2001] 软件开发"
layout: "post"
diff: 省选/NOI-
pid: P2223
tag: ['2001', '各省省选', '湖南']
---
# [HNOI2001] 软件开发
## 题目描述

某软件公司正在规划一项 $n$ 天的软件开发计划，根据开发计划第 $i$ 天需要 $n_i$ 个软件开发人员，为了提高软件开发人员的效率，公司给软件人员提供了很多的服务，其中一项服务就是要为每个开发人员每天提供一块消毒毛巾，这种消毒毛巾使用一天后必须再做消毒处理后才能使用。

消毒方式有两种，$A$ 种方式的消毒需要 $a$ 天时间，$B$ 种方式的消毒需要 $b$ 天，$A$ 种消毒方式的费用为每块毛巾 $f_A$, $B$ 种消毒方式的费用为每块毛巾 $f_B$，而买一块新毛巾的费用为 $f$（新毛巾是已消毒的，当天可以使用）。公司经理正在规划在这 $n$ 天中，每天买多少块新毛巾、每天送多少块毛巾进行 $A$ 种消毒和每天送多少块毛巾进行 $B$ 种消毒。当然，公司经理希望费用最低。

你的任务就是：为该软件公司计划每天买多少块毛巾、每天多少块毛巾进行 $A$ 种消毒和多少毛巾进行 $B$ 种消毒，使公司在这项 $n$ 天的软件开发中，提供毛巾服务的总费用最低。
## 输入格式

第一行为六个整数 $n,a,b,f,f_A,f_B$。

第二行为 $n$ 个整数 $n_1,n_2,\ldots,n_n$。

## 输出格式

仅一个整数，为最少的费用。
## 样例

### 样例输入 #1
```
4  1  2  3  2  1                         

8  2  1  6  


```
### 样例输出 #1
```
38
```
## 提示

#### 数据规模与约定
对于 $100\%$ 的数据，保证 $b>a$，$f>f_A>f_B$，$1\le f,f_A,f_B\le 60$，$1\le n\le 10^3$。


---

---
title: "[HNOI2002] 沙漠寻宝"
layout: "post"
diff: 省选/NOI-
pid: P2229
tag: ['2002', '各省省选', '湖南']
---
# [HNOI2002] 沙漠寻宝
## 题目描述

传说在漫无边际的沙漠中有一个古代城市的废墟，里面埋藏了大量的宝藏。听到这个消息的人一个又一个的前去寻宝，却没有发现一个回来的人。

探险家Jack是冒险者队伍中的后起之秀，它加入冒险者队伍的时间虽然不长，却屡屡依靠自己过人的智慧使自己和队友们脱离了险境。“明知山有虎，偏向虎山行”。 在Jack探险队的宗旨的指引下，Jack和他的队友们踏上了沙漠寻宝的旅程。

“我发现沙漠废墟了。”在一名队员的叫喊声中，Jack隐约看到了一些古代城市的残垣断壁和一个通道。 “一定就是这里了。”Jack带领着大家进入了通道。

然而，不幸的事情发生了。就在Jack他们进入通道的同时，通道的入口“轰”的一声就关闭了。Jack和他的队友走到了通道的尽头，正前方是一个巨大的铁门。最令人奇怪的是，铁门竟然使用的是一个极度先进的带有键盘和显示器的电子密码锁，铁门旁还赫然写着开锁的方法：“想到得到我的宝藏的人们，到这里的路途很辛苦吧！不过这一切很快就会结束的，这个铁门就是你们的葬身之地。除非你们能够计算出我屏幕上程序的结果，并且通过键盘输入进去，这扇门就会打开，里面就是我所有的宝藏”

我们的Jack果然不负众望，他打开了他的行囊，拿出了一个类似保险箱的东西。“没见过吗？这是最新型的笔记本电脑，没有它，我再怎么天才也不可能打开这扇门的。”面对大家疑惑的目光，Jack打开了笔记本电脑的开关。

“这个宝藏主人的程序十分的奇怪，我虽然没见过，但根据我的猜测，它的结构应该是这样的：

程序共包含6种语句：start,end,loop,continue,write,以及?=\*形式的语句。

start是程序的开始标志，其对应了一个结束标志end。

loop后面空一格并紧跟了一个表达式\*，表达式\*的值N表示即将循环N次，对应的循环结束标志也是end。

continue表示程序跳转到当前循环对应的end语句，break表示程序将跳出当前的循环。

write后面空一格并紧跟了一个表达式\*，表示要输出表达式\*的值，也就是要输入到密码锁中的内容。

?=\*是赋值语句，?是变量的名字，\*计算出来的值是要给?的。

另外，值得庆幸的是，变量名只允许使用’a’..’z’这26个小写字母，表达式也只允许使用加减乘除四种运算和以及括号，参与运算的也只能是26个变量或者是整数（允许不止一位整数）。表达式不会超过80个字符。”

“希望Jack能很快将锁打开。”大家心里默念着。

给定程序对所有语句的执行次数的总和小于2000000次。

## 输入格式

输入文件为program.in，给出了宝藏主人的程序。其中任两条语句用若干个空格或回车符隔开。

## 输出格式

输出文件为program.out，是你要输入密码锁的内容。每次输出占一行。

## 样例

### 样例输入 #1
```
start

     i=0

     j=0

     loop 100

          i=i+1

          j=j+i

          continue

          loop 10

               write j

          end

     end

     loop 100

          j=j+1

          break

          j=j+1

     end

     write j

end


```
### 样例输出 #1
```
5051
```


---

---
title: "[HNOI2002] 填数游戏"
layout: "post"
diff: 省选/NOI-
pid: P2232
tag: ['2002', '各省省选', '湖南', 'Special Judge']
---
# [HNOI2002] 填数游戏
## 题目描述

某商店最近开展了一个答题有奖的促销活动，公司经理将若干道有一定难度的问题贴到了商场的宣传栏内，如果你能够做出其中一道的话，你就能够获得优惠购买商品的权利。一段日子以后，大多数题目都被消费者们找出了答案，可是惟独有一道题目难倒了所有的人，这道题目是这样描述的：

将不同的完全平方数填满 $n \times m$ 的矩形方格表中的每一个小方格，使得每行、每列的和也是完全平方数（这个和必须小于 ${10}^{17}$）。希望你找到一种合理的方案。

Tiger 希望自己能够获得优惠购物的权利，于是他找到了准备参加 NOI2002 的你，希望你能够帮他设计一个程序找到一种合理的方案。

## 输入格式

输入文件中仅有一行，为两个正整数 $n, m$（$2 \le n, m \le 15$）。
## 输出格式

如果有解的话，输出 $n$ 行，每行有 $m$ 个数，表示一种合理的填数方案，无解时输出 `No answer`。

## 样例

### 样例输入 #1
```
2 2

```
### 样例输出 #1
```
225 1296
400 2304

```


---

---
title: "分段"
layout: "post"
diff: 省选/NOI-
pid: P2248
tag: ['O2优化']
---
# 分段
## 题目描述

给定你n个数$a_1、a_2、a_3、...、a_n$，要求将它们分成若干连续的段。


要求：


1. 有m对给定的数不能被分到同一段。


2. 分出一个段的代价是$K + S \times (P - Q)$，其中K和S均为给定的常数，而P则是该段中所有数的最大值，Q是该段中所有数的最小值。


3. 要求你求出每段代价之和最小的分段方案。

## 输入格式

第一行两个正整数n和m，表示数的个数和不能共存的m对数。


第二行两个非负整数K和S，含义见题面。


第三行n个非负整数，即给定的n个数。


接下来m行每行2个数$p_i$和$q_i$，表示$p_i$和$q_i$这两个编号的数不能共存。（编号从1开始）

## 输出格式

输出仅一行，表示最小的每段代价之和。

## 样例

### 样例输入 #1
```
5 2
3 1
2 3 12 14 16
2 3
3 1
```
### 样例输出 #1
```
11
```
## 提示

对于10%的数据，$n \leq 10$；

对于30%的数据，$n \leq 1500$；

对于另外10%的数据，$S = 0$；

对于另外30%的数据，$m = 0$；

对于100%的数据，1≤m,n≤100000，0≤K,S,a\_i≤100000，1≤pi,qi≤n，pi≠qi。



---

---
title: "[HNOI2002] 树的排序"
layout: "post"
diff: 省选/NOI-
pid: P2274
tag: ['2002', '各省省选', '湖南']
---
# [HNOI2002] 树的排序
## 题目描述

1. 空树编号为 $0$，只有根节点的树编号为 $1$；
2. 设 $m$ 为一任意非负整数，那么任意一棵有 $m$ 个节点的树的编号小于任意一棵有 $m+1$ 个节点的树；
3. 设 $A,B$ 是两棵节点数相同的树（$A,B$ 不相同），则 $A$ 编号比 $B$ 小时，一定满足下面两个条件之一（反之亦然）：
   1. $A$ 左子树编号小于 $B$ 左子树编号；
   2. $A$ 左子树编号等于 $B$ 左子树编号（即 $A,B$ 左子树形态相同），且 $A$ 右子树编号小于 $B$ 右子树编号；
4. 编号按照正常的规则，编号应是连续的非负整数，任意一棵树唯一对应一个编号，任意一个非负整数唯一对应一棵树。

（注：上述树均指二叉树）
## 输入格式

仅 $1$ 行，为一个整数 $n$，$1\le n\le 500{,}000{,}000$。

对于 $10\%$ 的数据，保证树节点个数不超过三个。
## 输出格式

仅 $1$ 行，为对应编号为 $n$ 的二叉树。按下列方式输出：

- 如果是一个结点的二叉树，则输出 $X$；
- 如果二叉树的左、右子树分别为 $L$ 和 $R$，$L,R$ 的输出形式分别为 $L'$ 和 $R'$，则输出为 $\texttt{(}L'\texttt{)}X\texttt{(}R'\texttt{)}$，当左子树为空时，输出为 $X\texttt{(}R'\texttt{)}$，当左子树为空时 $\texttt{(}L'\texttt{)}X$。

## 样例

### 样例输入 #1
```
20
```
### 样例输出 #1
```
((X)X(X))X
```


---

---
title: "[HNOI2002] 农场的果树"
layout: "post"
diff: 省选/NOI-
pid: P2276
tag: ['2002', '各省省选', '湖南']
---
# [HNOI2002] 农场的果树
## 题目描述

Farmer John 的农场环境优美，其中生长了许多苹果树，而苹果正是 Farmer John 农场里奶牛最喜爱的食物！

一天，闲来无事的奶牛 Besty 坐在苹果树下。她忽然发现，农场里的苹果树都是的二叉树！——当然，这种二叉树并不是严格意义上的二叉树，它可能有左子树而不存在右子树，反之也有可能。

刚学过 Computer Science 的 Besty 给二叉树上每个节点记录下其左子树的节点个数。例如下面的一棵树：

```cpp
                3
              /  \
             1     3
            / \   / \
           0   0  1  0
                 / \
                0   0
```
随后，用先序遍历给这棵树编码，需要注意的是叶子节点上的数值不必考虑。为了更方便表述，Besty 又在这样的编码前加入一个数字：该树上节点总数。于是，上面这棵数的编码就是：9 3 1 3 1。

这样一来，每一种编码就对应了一棵唯一的二叉树。

Besty 还发现，农场里的所有二叉树的节点总数都相同！并且在节点总数确定的情况下，对任意的合法编码，农场里都存在唯一的一棵树与之对应！

于是，Besty 将所有的二叉树按照上述编码规则编码，然后以编码为关键字进行字典排序。

现在，对于一个给定的编码，奶牛 Besty 想知道字典排序紧跟其后的编码是什么。

## 输入格式

输入文件名：next.in

输入文件有一行，为一个二叉树的编码。保证节点总数不超过 $5\times10^3$。

## 输出格式

输出文件名：next.out

输出文件有一行，为按字典排序紧跟其后的编码是什么。如果输入的编码是最后一个，则输出 `-1`。

## 样例

### 样例输入 #1
```
9 3 1 3 1
```
### 样例输出 #1
```
9 3 1 3 2 0
```


---

---
title: "[HNOI2003] 密室之门"
layout: "post"
diff: 省选/NOI-
pid: P2284
tag: ['2003', '各省省选', '湖南']
---
# [HNOI2003] 密室之门
## 题目描述

最近，我国考古学家在秦陵兵马俑的新墓坑中发现了若干个密室，每个密室都可以由一个奇特的门进入。那么怎样才能进入密室呢？

第 $i$ 个密室的门上有 $a_i$ 个转盘，该密室的第 $j$ 个转盘被均匀的分成 $b_{i,j}$ 格，这 $b_{i,j}$ 个格子按顺时针方向依次编号为 $0,1,\dots,b_{i,j}-1$，并且每一个转盘上面都有一个指针（结构类似于钟表），指针大约每过 $1.53$ 秒就会从原来指向编号为 $x$ 的格子变成指向编号为 $(x+1)\mod b_{i,j}$ 的格子。当一扇门上所有的转盘上的指针都指向编号为 $0$ 的格子的时候，那么这扇门就会被开启。

但是当考古学家发现密室时，转盘上的指针都指向不同编号的格子，考古学家经过计算发现按照门被开启的原理，有些密室是永远也打不开的。你的任务就是判断那些密室的门是可能被打开的。
## 输入格式

输入文件的第一行为 $n$，表示密室的个数。接下来的数据分为 $n$ 组，每组描述一扇门。每组数据的第一行为 $a_i$，即该密室门上转盘的个数，接下来的 $a_i$ 行每行有两个数据，第一个数据表示 $b_{i,j}$，第二个数据表示发现该密室时指针所指向的格子的编号。
## 输出格式

输出文件总共有 $n$ 行。若第 $i$ 间密室的门能够被打开，则输出文件的第 $i$ 行输出 `possible`，如果不能打开则输出 `impossible`。（注意小写输出）。
## 样例

### 样例输入 #1
```
2

2

5 3

4 2

2

4 3

6 2


```
### 样例输出 #1
```
possible

impossible


```
## 提示

对于 $100\%$ 的数据，$n<100$。


---

---
title: "[HNOI2005] 木梳"
layout: "post"
diff: 省选/NOI-
pid: P2314
tag: ['2005', '各省省选', '湖南']
---
# [HNOI2005] 木梳
## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/1353.png) 

![](https://cdn.luogu.com.cn/upload/pic/1354.png)

## 输入格式

从文件input.txt中读入数据，文件第一行为整数L，其中4<=L<=100000，且有50%的数据满足L<=10^4，表示木板下侧直线段的长。第二行为L个正整数A1,A2,…,AL，其中1<Ai<=10^8，表示第i段的高度。

## 输出格式

输出文件output.txt中仅包含一个整数D，表示为使梳子面积最大，需要从木板上挖掉的格子数。

## 样例

### 样例输入 #1
```
9 

4 4 6 5 4 2 3 3 5


```
### 样例输出 #1
```
3
```


---

---
title: "BBCode转换Markdown"
layout: "post"
diff: 省选/NOI-
pid: P2395
tag: []
---
# BBCode转换Markdown
## 题目背景

BBCode和Markdown是两种常用的格式语言。所谓格式语言指，例如在某些网站评论区发表评论时，可以使用其对你的评论进行修饰，使文字可以有颜色、粗体等各种样式。

## 题目描述

#### PDF版题目: http://pan.baidu.com/s/1i3mxk4t 提取密码hayc


BBCode的语法如下所示：

```cpp
[h1]Hello World![/h1]
[h2][i]This is a BBCode[/i][/h2]
[b][i]I love[/i] Olympic [i]Informatics[/i][/b]
```

例如，在标签[h1]中，在[h1]和[/h1]之间包裹的内容属于一级标题，对于这之间的文字要按照一级标题的样式渲染。

请注意BBCode要求标签的开闭必须完整且且嵌套无误，也就是说，如下列的例子都是不合法的BBCode：


```cpp
[h1]Hello World! //标签未闭合
[h1]Hello World![/h2] //两个标签不匹配
[h1][i]Hello World![/h1][/i] //嵌套次序错误
```

另外，极其重要的一点是，BBCode有一个特殊的标签[quote][/quote]，在其中的任意文字都不应被解析为BBCode代码，而应该对其进行Markdown化处理后被原样输出。


现在介绍Markdown。其语法如下所示：

```cpp
# Hello World! #
## *This is a Markdown* ##
__*I love* Olympic *Informatics*__
```

你的任务就是将给定的一串BBCode转换成Markdown，并对不合法的输入报错。


题目数据中会出现的所有BBCode的标签与其对应Markdown对应关系如下，保证不出现除此之外的对应：



 ![](https://cdn.luogu.com.cn/upload/pic/1493.png) 

对于[quote]标签的附加说明：


![](https://cdn.luogu.com.cn/upload/pic/1494.png)

## 输入格式

所需转换的BBCode。

## 样例

### 样例输入 #1
```
[h1]Hello World![/h1]
[h2]How are [i]you[/i]?[/h2]
```
### 样例输出 #1
```
# Hello World! #
## How are *you*? ##
```
### 样例输入 #2
```
[h1]Introducing Swift.[/h1][quote]
import SpriteKit
let object = SKSpriteNode(imageNamed: “[L2/Ascention]”
[/quote]
```
### 样例输出 #2
```
# Introducing Swift. #
> import SpriteKit
> let object = SKSpriteNode(imageNamed: “[L2/Ascention]”
```
### 样例输入 #3
```
[h1]I knew you were
trouble when you walked in[/h1]
[url=http://www.example.com]By Taylor Swift[/url]
```
### 样例输出 #3
```
# I knew you were
trouble when you walked in #
[By Taylor Swift](http://www.example.com)
```
### 样例输入 #4
```
[h1]Thanks for [i]inviting[/h1] me.[/i]
```
### 样例输出 #4
```
Match Error
```
### 样例输入 #5
```
[h2]Your gift is awesome!
```
### 样例输出 #5
```
Unclosed Mark
```
### 样例输入 #6
```
[quote][/quote][/quote]
```
### 样例输出 #6
```
Match Error
(对该数据的解释: 匹配到第一个关闭标签后即不认为后面的内容仍是代码段)
```
### 样例输入 #7
```
[quote][quote][/quote]
```
### 样例输出 #7
```
> [quote]
```
## 提示

为保证评测顺利不被误判，请注意下列要求：

尊重原输入输出的换行，不自行添删。

对于第一条的例外是， 遇到[quote]标签不在新的一行时，Markdown中请另起一行。另外[quote]标签中的代码段头尾空行请去除，不会出现空白的quote。

请注意上表中的空格。

对于不合法的BBCode输入，你的程序必须报错：对于匹配错误的标签输出Match Error，对于未闭合的标签输出Unclosed Mark，请参考样例。两种情况同时出现的时候（即同时有匹配错误和未闭合的标签时），按照匹配错误处理，输出Match Error。由于quote标签的特殊性，为保证不出现歧义，数据保证quote标签不会出现错误。(对于出现如[i][h1]Text[/i]这样的情况，按照Match Error处理，对于[i][h1]Text[/h1]这样的情况，按照Unclosed Mark处理)

由于洛谷限制，请大家在输出Unclosed Mark的时候在close中间切开分为两段字符串输出，否则会被吞记录。

保证以下三种字符不出现在除quote标签包裹的段落中的文字中：[,],/,\*,\_,#,>，但地址中可能会出现/字符。

保证输入不会出现标签不完整的情况，例如[h1]Text[/h

对于曾经在其他地方使用过Markdown与BBCode的同学：题中的格式不是严格的BBCode与Markdown格式，请勿被经验迷惑。



---

---
title: "分数统计"
layout: "post"
diff: 省选/NOI-
pid: P2442
tag: ['O2优化']
---
# 分数统计
## 题目背景

大宁考完联赛回来，成功的躲过了期中考试，但是他的班主任 Yellow_sword  不会放过他。
## 题目描述

Yellow_sword 要大宁给他弄一个数据库，维护班级的考试平均分。每个人期中考试各科的分数已经被统一的转化为评价值，为一个 $[1,100]$ 之间的整数。它评价了这个人的总体水平，现在 Yellow_sword 丢给了大宁 $n$ 个班级的班级平均评价值和每个班的人数，由于 Yellow_sword 和大宁都很懒，所以都假装每个班每个人的评价值就是班级的平均评价值。他想知道：

1. 连续的若干个班所有人评价值的平均数。
2. 连续的若干个班所有人评价值的众数（若有多个取最小的那个众数）。
3. 连续的若干个班所有人评价值的极差（即评价值最高和最低的差）。

既然大家都很懒，那事情就给你来做了。
## 输入格式

第一行为两个整数 $n$ 和 $q$，表示有 $n$ 个班级和 $q$ 个询问。

第二行为 $n$ 个整数 $a_i$，表示第 $i$ 个班的平均评价值。

第三行为 $n$ 个整数 $b_i$，表示第 $i$ 个班的人数。

接下来 $q$ 行，每行一个查询，格式为：`Opt u v`。

表示在第 $u$ 到 $v$ 个班级里查询 $Opt$ 对应的项，$Opt\in[1,3]$，意义为前文所述。
## 输出格式

对于每一个询问，在 $q$ 行中输出对应的结果，平均数保留两位小数。
## 样例

### 样例输入 #1
```
5 3
90 100 90 90 80
2 1 2 1 8
1 1 3
2 3 5
3 1 2

```
### 样例输出 #1
```
92.00
80
10

```
## 提示

|测试点| 数据规模| 时限 |
| :-------:| :----:| :----: |
| $1\sim3$ |$n=q=10^3$| $0.5s$ |
|$4\sim5$| $n=q=5\times 10^4$| $0.5s$ |
| $6\sim 7$ |     $n=q=10^5$| $1s$ |
| $8\sim 10$ |  $n=q=2\times 10^5$| $1s$ |

**建议使用较快的读入方式。**


---

---
title: "[SDOI2005] 动物园"
layout: "post"
diff: 省选/NOI-
pid: P2445
tag: ['2005', '各省省选', '山东', 'Special Judge']
---
# [SDOI2005] 动物园
## 题目描述

位于郊区的动物园很早就采用了当时先进的自动化管理设施对动物进行管理。但是由于当时的系统没有考虑 $2000$ 年问题，使得管理人员十分担心。虽然采取了很多防范措施，系统还是在世纪之交出现了一些 BUG，部分动物的笼子门自动打开了，关在里面的动物都跑出来了。

幸好动物园已经关闭，**动物不会跑出动物园**。警长 Still 接到报警后率领一支干警奔赴现场。这时动物已经跑出了笼子，所以干警们花了很多时间才控制住了局势，所有的动物都己经送到动物园的广场。但是此时有一个棘手的问题，由于系统完全崩溃，无法得知动物是从哪个笼子里面跑出来的。此时，干警们记得动物的一些行动，都是如下的形式：

第 $t$ 分钟看到某某动物在某个位置。

Still 希望通过这些零碎的信息得到动物是从哪个笼子跑出来的。

### 任务

根据给出的信息，编程求出每个动物的笼子的位置。

动物园的地形描述为一个 $n\times n$ 的网格，一个格子可以是建筑物或者平地。笼子的位置只可能在平地，动物也只在平地运动。每种动物的奔跑速度不一样，例如老虎一分钟可以跑 $5$ 个格子，猫一分钟只可以跑 $2$ 个格子等等。以下是一个例子（其中阴影部分是建筑物）：

![](https://cdn.luogu.com.cn/upload/pic/1577.png)

**每个笼子只关一只动物，不同的笼子关不同的动物。不同的笼子可能在同一个格子里。**
## 输入格式

第一行为自然数 $n$，表示网格的边长

以下 $n$ 行为一个 $n\times n$ 的字符串矩阵，表示动物园的地形。其中 `.` 表示空地，`*` 表示建筑物。

接着一行是自然数 $p$，表示笼子的数目（同时也是动物的数目）。

以下 $p$ 行，每行两个自然数 $R,C$，表示一个笼子处于网格的第 $R$ 行，第 $C$ 列。

以下 $p$ 行，每行一个整数 $V_i$，依次表示编号为 $i$ 的动物的速度（格子/分钟），每个动物用它的编号表示。

接着一行是自然数 $r$，表示干警们提供的信息数目。

以下 $r$ 行，每行四个自然数，$t,x, y, j$，表示第 $t$ 分钟在网格的 $(x, y)$ 位置看到动物 $j$。

具体格式参照样例。
## 输出格式

输出任意一个可行解。

包括 $p$ 行，每行三个整数 $i,x,y$，表示动物 $i$ 原来在格子 $(x,y)$。
## 样例

### 样例输入 #1
```
5
.....
.***.
.....
.***.
.....
2
1 3
5 2
1
2
2
5 3 1 2
4 5 5 1

```
### 样例输出 #1
```
1 5 2
2 1 3

```
## 提示

$1\leq n,p\leq 100$，$x,y\leq n$。

注：对于特定的数据可能有多解，输出任意一解即可。


---

---
title: "[SDOI2007] 科比的比赛"
layout: "post"
diff: 省选/NOI-
pid: P2460
tag: ['2007', '各省省选', '山东']
---
# [SDOI2007] 科比的比赛
## 题目描述

NBA球星云集，谁是最厉害的呢？没有定论。

Nba总裁大卫\*斯特恩最近闲得无聊，决定举办一场球员单挑大赛。

比赛是这样的:首先，我们给每人都打上个分数，表示了每个人的整体能力。然后让每个参赛队员都打n场比赛，首先看谁赢得最多，然后看谁打赢的人的能力值的和最大。

本人一向支持科比(我不支持),当然希望他赢。现在让我们和科比一起去赢得这场比赛吧！！

(科比照片一张)

假设总共比赛有m+1个人参加，告诉你科比和另外m个人的比赛的胜利可能性，你的任务就是求出在科比赢了的所有比赛的可能性最大的前提下(误差不超过1e-10)，科必打赢的人的最大能力值的和是多少？当然当一个人被你打败，他就不会再参加比赛了。

这里需要注意的是，科比能打赢其他人的可能性在不同场次是不同的。比如在比赛前期科比的手感不太好，对抗在内线称霸的人因为无法发挥外线的实力，而难以得分(接奥尼儿图一张)

中期时别人手感变好，状态起来，有实力的人会给科比制造很大的麻烦(接韦德图一张)

后期时消耗太多体力，对自己的命中率下降，难以发挥正常水平，所以对抗体力好的球员时占劣势(后接纳什图一张)

现在给你每场比赛科比对每个参赛者的获胜可能性，和每个人的能力值，帮助科比赢得比赛吧。

## 输入格式

第一行n,m(1<=n<<=10,n<=m<=100000),意义如题所述

接下来一行m个整数表示其他m个人的能力值si(1<=si<=100)

接下来是1个n\*m的矩阵，描述在每场碰到每个人的获胜可能vij(0<=vij<=1)

## 输出格式

第一行输出最大获胜可能性

第二行输出最大能力值和

Special Judge

## 样例

### 样例输入 #1
```
3 4

91 92 93 94

0.5 0.5 0.5 0.5

0.5 0.5 0.5 0.5

0.5 0.5 0.5 0.5
```
### 样例输出 #1
```
0.125

279
```


---

---
title: "[SDOI2010] 城市规划"
layout: "post"
diff: 省选/NOI-
pid: P2478
tag: ['2010', '各省省选', '山东']
---
# [SDOI2010] 城市规划
## 题目描述

小猪iPig来到了一个叫做pigsty的城市里，pigsty是一座专门为小猪所准备的城市，城市里面一共有n个小区给小猪们居住，并且存在许多条无向边连接着许多小区。因为这里是一个和谐的城市，所以小猪iPig准备在这个城市里面度过他的余生。

若干年之后小猪iPig当上了规划局长，这件事令他非常开心。不过与此同时pigsty城市里面出现了许多反和谐主义者，他们已经厌烦了这样和谐的生活，在城市里到处闹事。小猪iPig为了更好地控制局面，他把城市改造成了另外一个样子：iPig把道路全部摧毁之后重新修建了m条无向边，并且保证每一个小区最多存在于一个由无向边组成的环中。

iPig以为这样做就让那些反和谐主义者不敢继续猖狂下去了，谁知到在新的城市道路修建好以后反和谐主义者宣言要对城市的小区进行一次洗脑！

这下可麻烦了，iPig赶紧收集了许多的情报。iPig给每个小区标记了一个和谐值HX\_i，用它来表示第i个小区的和谐程度。

通过地下消息iPig又得知那些反和谐主义者进攻时有个规律：他们会选择若干个小区下手，这些小区都派一只猪过去，把这些小区的和谐值归零。在这个过程中，每个选择的小区所直接连接着的几个小区都派了一只猪去看守——以防被警猪给干扰。这个计划看似完美但是还是存在一个漏洞：因为人员之间都是在网络上认识的，互相没有见过面，为了防止不必要的麻烦（认错猪之类），每个小区最多只会有一头猪存在。

iPig突然感到了莫大的压力，他想知道在最坏情况下会丢失多少和谐值。但是不懂计算机的他不知道应该怎样计算。你能帮帮他吗？

## 输入格式

输入第一行有两个整数n和m，表示pigsty城市里面有n个小区，在iPig修整城市后有m条无向边连接着n个小区。

接下来一行有n个正整数，第i个正整数HX\_i表示第i个小区的和谐值为HX\_i。

接下来m行，每行两个正整数a和b（1<=a,b<=n），表示存在一条连接着小区a和小区 b的无向边。

## 输出格式

输出只有一行一个整数，表示最坏情况下损失的和谐值为多少。

## 样例

### 样例输入 #1
```
9 9
2 2 3 4 1 2 3 10 11
1 2
2 3
1 3
3 5
5 4
5 6
4 7
6 7
8 9

```
### 样例输出 #1
```
17
```
### 样例输入 #2
```
5 5
4 4 9 7 7
1 2
2 3
1 4
3 5
5 4

```
### 样例输出 #2
```
9
```
## 提示

【样例解释】

反和谐主义者选择的小区分别是小区3（看守的小区是小区1、小区2和小区5）、小区7（看守的小区是小区4和小区6）和小区9（看守的小区是小区8），这样会损失的总和谐值为3+3+11=17。

或者选择的小区分别是小区1（看守的小区是小区2和小区3）、小区4（看守的小区是小区5和小区7）和小区9（看守的小区是小区8），这样会损失的总和谐值为2+4+11=17。

如果同时选择小区3、小区4和小区9，虽然损失的总和谐值为18，但是小区3和小区4都要派猪来看守小区5，这不符合条件，故此方案不可行。


【数据约定】

对于20%的数据，保证每个点不存在于任何一个环中；

对于另外30%的数据，保证图中只存在一个环；

对于100%的数据，有N<=1000000，M<=2000000，所有的权值不超过1000。



---

---
title: "[SDOI2012] 体育课"
layout: "post"
diff: 省选/NOI-
pid: P2496
tag: ['2012', '各省省选', '山东']
---
# [SDOI2012] 体育课
## 题目背景

# 警告：滥用本题评测将被封号
## 题目描述

又是一节体育课的时间了，有 $n$ 个同学排成了一排。他们都很讨厌排在第一个位置的同学，于是后面的同学中比第一个高的都会产生一个高兴值，这个高兴值等于他的身高减去第一个同学的身高。当然比第一个同学矮的同学产生兴奋值为 $0$。

现在体育老师来了，他拥有神奇的魔法，现在他能做如下的三件事：

1. 询问某段区间高兴值最大的那个是多少。

2. 把某两个同学交换一下位置。

3. 选取一段区间的人，把第一个人身高加上 $t$，第二个加上 $2t$，第三个加上 $3t$ 以此类推。

但是体育老师不会数数，于是他找到你了，对于每一个询问，他要你帮他求出那个值。

## 输入格式

第一行两个整数 $n,m$，表示有 $n$ 个人，有 $m$ 个操作。

第二行 $n$ 个整数，顺序输入每个人的身高 $a_i$。

接下来 $m$ 行，每行第一个数位一个 $type$ 表示是做哪一件事情。

- 如果 $type=1$，那么接下来有两个整数 $l,r$，表示询问这段区间的最大的高兴值。
- 如果 $type=2$，接下来两个整数 $a,b$，表示交换这两个位置的人。
- 如果 $type=3$，接下来三个整数 $l,r,t$，表示把 $l$ 个人的升高增加 $t$,$l+1$ 个人增加 $2t$ ...第 $r$ 个人增加 $(r-l+1)t$。

## 输出格式

对于每个询问按照顺序输出每个操作 $1$ 的答案。
## 样例

### 样例输入 #1
```
6 7
109 827 100 530 10 826
3 1 6 1
2 2 6
1 2 4
1 2 3
2 2 6
1 2 6
1 2 5
```
### 样例输出 #1
```
722
722
722
719
```
## 提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $1 \le n,m \le 5 \times 10^3$。
- 另有 $10\%$ 的数据，没有第三种操作。
- 另有 $20\%$ 的数据，没有第二种操作。
- 对于 $100\%$ 的数据，$1 \le n,m \le 10^5$，$0 \le t \le 10^4$，$1 \leq a_i \leq 10^8$。


---

---
title: "[SDOI2012] 象棋"
layout: "post"
diff: 省选/NOI-
pid: P2499
tag: ['2012', '各省省选', '山东']
---
# [SDOI2012] 象棋
## 题目描述

小云和小南两姐妹从小喜欢下象棋，现在作为象棋高手的她们，已经不屑于玩平常的象棋了，于是她们便开始用棋盘和棋子玩各种各样的新游戏。

今天天气晴朗，阳光明媚，她们将在 $n\times m$ 的棋盘上进行游戏。

棋盘上有 $k$ 颗棋子和若干有障碍格子，令棋盘左上角格子坐标为 $(1,1)$，右下角格子坐标为 $(n,m)$，参数 $a,b$ 规定了所有棋子的走法：在 $(x, y)$ 的棋子下一步能走到 $(x + a, y + b), (x + a, y - b), (x  – a, y + b), (x – a, y – b), (x + b, y + a), (x + b, y - a), (x – b, y + a), (x – b, y – a)$ 这八个格子中的一个，棋子任何时候不能跃出棋盘或走到有障碍的格子上。

这k颗棋子是相同的，小云和小南的目标是用最少步数把所有棋子移动到特定格子，要求移动过程中不能出现多颗棋子同时在某一格的情况。

她们已经想出步数较少方案，但无法确定这是否为最少步数，所以向作为程序员的你求助。

## 输入格式

第一行五个空格隔开的整数 $n,m,k,a,b$；

接下来 $n$ 行，每行为长度 $m$ 的字符串，描述棋盘，`.` 表示没有障碍的格子，`*` 表示有障碍的格子；

接下来 $k$ 行，每行两个整数 $x$ 和 $y$，分别表示 $k$ 颗棋子的初始位置；

接下来 $k$ 行，每行两个整数 $x$ 和 $y$，分别表示 $k$ 颗棋子的目标位置。

## 输出格式

一个整数，为把所有棋子移动到目标位置的最少步数，数据保证有解。

## 样例

### 样例输入 #1
```
1 8 2 2 0
.......*
1 1
1 3
1 5
1 7
```
### 样例输出 #1
```
4
```
## 提示

【样例说明】

一可行方案如下：第二颗棋子向右跳两步，随后第一颗棋子向右跳两步，共 $4$ 步。值得注意的是，第一颗棋子向右跳三步，随后第二颗棋子向右跳一步的方案尽管能把棋子都移动到目标位置，但途中两颗棋子曾经同时在 $(1, 3)$，违反了规则，所以不能选用此方案。


数据范围

其中 $20\%$ 的数据，$n\times m\le 20$。

另外 $10\%$ 的数据，$n = 1$；

对于 $100\%$ 的数据，$1\le n,m\le 100$，$1\le k\le 500$。



---

---
title: "[SHOI2001] 小狗散步"
layout: "post"
diff: 省选/NOI-
pid: P2526
tag: ['2001', '各省省选', '上海', 'Special Judge']
---
# [SHOI2001] 小狗散步
## 题目描述

Grant 喜欢带着他的小狗 Pandog 散步。Grant 以一定的速度沿着固定路线走，该路线可能自交。Pandog 喜欢游览沿途的景点，不过会在给定的  $N$ 个点和主人相遇。小狗和主人同时从  $(X_1,Y_1)$ 点出发，并同时在  $(X_n,Y_n)$ 点汇合。小狗的速度最快是 Grant 的两倍。当主人从一个点以直线走向另一个点时，Pandog 跑向一个它感兴趣的景点。Pandog 每次与主人相遇之前最多只去一个景点。

你现在的任务是：为 Pandog 寻找一条路线（有可能与主人的路线部分相同），使它能够游览最多的景点，并能够准时与主人在给定地点相遇或者汇合。
## 输入格式

第一行是两个整数  $N$ 和  $M$。

第二行的  $N$ 个坐标给出了 Grant 的散步路线，即 Pandog 和主人相遇地点。

第三行的  $M$ 个坐标给出了所有 Pandog 感兴趣的景点。
## 输出格式

输出小狗的移动路线。

第一行是经过的点数，第二行依次为经过的点的二维坐标。
## 样例

### 样例输入 #1
```
4 5
1 4 5 7 5 2 -2 4
-4 -2 3 9 1 2 -1 3 8 -3

```
### 样例输出 #1
```
6
1 4 3 9 5 7 5 2 1 2 -2 4
```
## 提示

对于所有数据，有  $1\le N,M\le 100$，所有输入的坐标均不相同，且绝对值不超过  $10^3$。


---

---
title: "[SHOI2001] 击鼓传花"
layout: "post"
diff: 省选/NOI-
pid: P2529
tag: ['2001', '各省省选', '上海']
---
# [SHOI2001] 击鼓传花
## 题目描述

HC(Happy Child)小朋友最近经常在教室里跟同学一起玩击鼓传花的游戏，规则是第 $n$ 个拿到花的小朋友必须说出 $n!$ 最后一位非 0 的数字，如此循环游戏，如果谁讲错了就得罚唱一支歌曲。

经过几次游戏，HC 小朋友认为只要把前一个小朋友说得数字去乘以 $n$，说出得到的数的最后一位非 $0$ 的数字就可以了，可惜 HC 小朋友这次轮到了第 $15$ 个，结果被罚了唱歌(应该是 $8$，但是HC小朋友却说了$3$)。

HC 小朋友不希望这样的事情再次发生，所以希望你能编写一个程序，能够计算出 $n!$ 的最后一位非 $0$ 的数字。

## 输入格式

输入有 $5$ 行，第 $i$ ($1\le i\le 5$) 行是一个 $n$ ($1\le n\le10^{100}$)。

## 输出格式

输出有 $5$ 行。

第 $i$ 行对应输入中第 $i$ 行的 $n$ 的阶乘的最后一位非 $0$ 的数字。

## 样例

### 样例输入 #1
```
11
12
13
14
15

```
### 样例输出 #1
```
8
6
8
2
8

```


---

---
title: "[AHOI2012] 收集资源"
layout: "post"
diff: 省选/NOI-
pid: P2535
tag: ['2012', '各省省选', '安徽']
---
# [AHOI2012] 收集资源
## 题目描述

 ![](https://cdn.luogu.com.cn/upload/pic/1637.png) 

 ![](https://cdn.luogu.com.cn/upload/pic/1638.png) 


## 输入格式

![](https://cdn.luogu.com.cn/upload/pic/1639.png)

## 输出格式

![](https://cdn.luogu.com.cn/upload/pic/1640.png)

## 样例

### 样例输入 #1
```
8 8 10
1 1 3
2 2 4
3 3 5
3 4 3
4 3 2
4 4 6
5 5 7
6 6 8
```
### 样例输出 #1
```
28
```
## 提示

数据：

50%: 1<=N,M,T<=100

100%: 1<=N,M,T<=200



---

---
title: "[USACO16DEC] Robotic Cow Herd P"
layout: "post"
diff: 省选/NOI-
pid: P2541
tag: ['2016', 'USACO', 'Ad-hoc']
---
# [USACO16DEC] Robotic Cow Herd P
## 题目描述

Bessie is hoping to fool Farmer John by building a herd of $K$ realistic robotic cows ($1 \leq K \leq 100,000$).

It turns out that building a robotic cow is somewhat complicated. There are $N$ ($1 \leq n \leq 100,000$) individual locations on the robot into which microcontrollers must be connected (so a single microcontroller must be connected at each location). For each of these locations, Bessie can select from a number of different models of microcontroller, each varying in cost.

For the herd of robotic cows to look convincing to Farmer John, no two robots should behave identically. Therefore, no two robots should have exactly the same set of microcontrollers. For any pair of robots, there should be at least one location at which the two robots use a different microcontroller model. It is guaranteed that there will always be enough different microcontroller models to satisfy this constraint.

Bessie wants to make her robotic herd as cheaply as possible. Help her determine the minimum possible cost to do this!
## 输入格式

The first line of input contains $N$ and $K$ separated by a space.

The following $N$ lines contain a description of the different microcontroller models available for each location. The $i$th such line starts with $M_i$ ($1 \leq M_i \leq 10$), giving the number of models available for location $i$. This is followed by $M_i$ space separated integers $P_{i,j}$ giving the costs of these different models ($1 \le P_{i,j} \le 100,000,000$).
## 输出格式

Output a single line, giving the minimum cost to construct $K$ robots.
## 样例

### 样例输入 #1
```
3 10
4 1 5 3 10
3 2 3 3
5 1 3 4 6 6
```
### 样例输出 #1
```
61
```
## 题目翻译

### 题目描述

Bessie 希望通过建造 $K$ 头逼真的机器人奶牛（$1 \leq K \leq 100,000$）来愚弄 Farmer John。

事实证明，建造一头机器人奶牛有些复杂。机器人上有 $N$ 个（$1 \leq N \leq 100,000$）独立的位置需要连接微控制器（因此每个位置必须连接一个微控制器）。对于每个位置，Bessie 可以从多个不同的微控制器模型中选择，每个模型的成本各不相同。

为了让机器人牛群对 Farmer John 看起来逼真，任何两头机器人的行为都不应完全相同。因此，任何两头机器人都不应使用完全相同的微控制器集合。对于任意一对机器人，至少应有一个位置上的微控制器模型不同。保证始终有足够的不同微控制器模型来满足此约束。

Bessie 希望以尽可能低的成本建造她的机器人牛群。请帮助她确定实现这一目标的最小可能成本！

### 输入格式

输入的第一行包含用空格分隔的 $N$ 和 $K$。

接下来的 $N$ 行描述了每个位置可用的不同微控制器模型。第 $i$ 行以 $M_i$（$1 \leq M_i \leq 10$）开头，表示位置 $i$ 可用的模型数量。随后是 $M_i$ 个用空格分隔的整数 $P_{i,j}$，表示这些不同模型的成本（$1 \le P_{i,j} \le 100,000,000$）。

### 输出格式

输出一行，表示建造 $K$ 头机器人的最小成本。


---

---
title: "[HNOI2008] 明明的烦恼"
layout: "post"
diff: 省选/NOI-
pid: P2624
tag: ['2008', '各省省选', '湖南']
---
# [HNOI2008] 明明的烦恼
## 题目背景

原 编译优化 参见P1792
## 题目描述

自从明明学了树的结构,就对奇怪的树产生了兴趣...... 
给出标号为1到N的点,以及某些点最终的度数,允许在任意两点间连线,可产生多少棵度数满足要求的树?
## 输入格式

第一行为N(0<N<=1000),接下来N行,第i+1行给出第i个节点的度数Di,如果对度数不要求,则输入-1
## 输出格式

一个整数,表示不同的满足要求的树的个数,无解输出0
## 样例

### 样例输入 #1
```
3
1
-1
-1
```
### 样例输出 #1
```
2
```
## 提示

两棵树分别为1-2-3;1-3-2




---

---
title: "[TJOI2012] 桥"
layout: "post"
diff: 省选/NOI-
pid: P2685
tag: ['2012', '各省省选', '天津']
---
# [TJOI2012] 桥
## 题目描述

有 $n$ 个岛屿，$m$ 座桥，每座桥连通两座岛屿，桥上会有一些敌人，玩家只有消灭了桥上的敌人才能通过，与此同时桥上的敌人会对玩家造成一定伤害。而且会有一个大 Boss 镇守一座桥，以玩家目前的能力，是不可能通过的。而 Boss 是邪恶的， Boss 会镇守某一座使得玩家受到最多的伤害才能从岛屿 $1$ 到达岛屿 $n$（当然玩家会选择伤害最小的路径）。问，Boss 可能镇守的桥有哪些。

注意可以有**重边**和**自环**。
## 输入格式

第一行两个整数 $n,m$。

接下来 $m$ 行，每行三个整数 $s,t,c$，表示一座连接岛屿 $s$ 和 $t$ 的桥上的敌人会对玩家造成 $c$ 的伤害。

## 输出格式

一行，两个整数 $d,cnt$，$d$ 表示有 Boss 的情况下，玩家至少要受到的伤害，$cnt$ 表示 Boss 可能镇守的桥的数目。

## 样例

### 样例输入 #1
```
3 4
1 2 1
1 2 2
2 3 1
2 3 2
```
### 样例输出 #1
```
3 2
```
## 提示

- $30\%$ 的数据，$1 ≤ n ≤ 1000$；
- $100\%$ 的数据，$1 ≤ n ≤ 100000, 1 ≤ m ≤ 200000, 1 ≤ c ≤ 10000$；
- 数据保证玩家可以从岛屿 $1$ 到达岛屿 $n$。



---

---
title: "[SHOI2005] 树的双中心"
layout: "post"
diff: 省选/NOI-
pid: P2726
tag: ['2005', '各省省选', '上海']
---
# [SHOI2005] 树的双中心
## 题目描述

![](https://cdn.luogu.com.cn/upload/pic/15902.png)
## 输入格式

第一行为N，1<N<=50000,表示树的节点数目，树的节点从1到N编号。
接下来N-1行，每行两个整数U，V，表示U与V之间有一条边。
再接下N行，每行一个正整数，其中第i行的正整数表示编号为i的节点权值为W(I),树的深度<=100
## 输出格式

将最小的S（x,y)输出到median.out，结果保证不超过$10^9$
## 样例

### 样例输入 #1
```
5
1 2
1 3
3 4
3 5
5
7
6
5
4
```
### 样例输出 #1
```
14
```
## 提示

选取的两个中心节点分别为2和3


---

---
title: "[USACO09HOL] Cattle Bruisers G"
layout: "post"
diff: 省选/NOI-
pid: P2928
tag: ['2009', 'USACO']
---
# [USACO09HOL] Cattle Bruisers G
## 题目描述

Canmuu is out for revenge after being utterly defeated by Bessie in paintball and has challenged Bessie to a video game.

In this game, Bessie starts out at point (BX, BY) in the coordinate grid (-1,000 <= BX <= 1,000; -1000 <= BY <= 1,000), and tries to escape, starting at time 0. She moves continuously at a velocity of (BVX, BVY) units/second (-100 <= BVX <= 100; -100 <= BVY <= 100). Thus, at time 1 she will be at point (BX + BVX, BY + BVY); at time 1.5 she will be at (BX + 1.5\*BVX, BY + 1.5\*BVY).

Unfortunately, Canmuu has sent N (1 <= N <= 50,000) cattle bruisers to pursue Bessie.  At time t=0, cattle bruiser i is at position (X\_i, Y\_i) (-1,000 <= X\_i <= 1,000; -1,000 <= Y\_i <= 1,000) with velocity (VX\_i, VY\_i) units/second (-1,000 <= VX\_i <= 1,000; -1,000 <= VY\_i <= 1,000).

Each cattle bruiser carries a 'proximity' weapon to fire at Bessie; the weapon can hurt Bessie when the cattle bruiser is no further than R (1 <= R <= 2,500) units from her.

Bessie has a shield to protect herself from these attacks. However, she does not want to waste any of her shield's power, so she would like to know the maximum number of cattle bruisers within firing range for any (potentially non-integer) time t >= 0.

In order to avoid precision errors with real numbers, it is guaranteed that the answer produced will be the same whether the attack range is decreased to R-0.0001 or increased to R+0.0001.

FEEDBACK: Your first 50  submissions for this problem will be run on some of the official test data, and you will receive a summary of the results.

自从卡门在弹珠游戏中被贝茜彻底击败，他一直在想找机会复仇.这会儿，他邀贝茜去玩一 个电脑游戏.

游戏中，贝茜在（BX,BY）处开始行动，这时时刻为0.她要试图 逃离.她的速度为(BVX，BVY)每秒.

不幸的是，卡门为了复仇，放出N(l<=N< =50000)个杀手追击贝茜.在t = 0时，杀手i的位置 是Xi, Yi他的速度是Vxi,Vyi每秒.

由于每个杀手配备了手枪，手枪的射程是R，也就是说贝茜要与这个杀手的距 离保持超过R，否则有性命之虞.

然而，贝茜还有一件秘密武器，盾.但是，她不想过多地消耗盾的能量.所以，她想知道在 逃脱过程中，某一个时刻她在最多为多少个杀手的射程内.当然这个时刻不一定是整数.

为了防止出现精度误差，数据保证在R 土 0.0001时也能得出正确结果.

## 输入格式

\* Line 1: Six space-separated integers: N, R, BX, BY, BVX, and BVY

\* Lines 2..N+1: Line i+1 contains four space-separated integers: X\_i, Y\_i, VX\_i, and VY\_i

## 输出格式

\* Line 1: Print a single integer denoting the maximum number of cattle bruisers within attack range at any point in time.

## 样例

### 样例输入 #1
```
3 1 0 0 0 2 
0 -3 0 4 
1 2 -1 1 
1 -2 2 -1 

```
### 样例输出 #1
```
2 

```
## 提示

Bessie starts at point (0, 0) and is moving at 2 units per second in the (positive) y-direction. There are 3 cattle bruisers, the first of which starts at point (0, -3) and travels 4 units per second in the y-direction. The maximum distance for a cattle bruiser to be in range of Bessie is 1 unit.


At time 1.5, Bessie is at point (0, 3), and the three bruisers are at points (0, 3), (-0.5, 3.5), and (4, -3.5). The first two cattle bruisers are within 1 unit of Bessie, while the third will never be within 1 unit of Bessie, so 2 is the most achievable.



---

---
title: "[USACO09HOL] Holiday Painting G"
layout: "post"
diff: 省选/NOI-
pid: P2930
tag: ['2009', 'USACO']
---
# [USACO09HOL] Holiday Painting G
## 题目描述

To show their spirit for the holidays, the cows would like to paint a picture! Their picture will be represented as an R x C (1 <= R <= 50,000; 1 <= C <= 15) grid of unit squares, each of which is either 0 or 1. The grid rows are conveniently numbered 1..R; the columns are numbered 1..C.

Being pressed for time, the cows have asked their neighbors north of the border for help. Under the very helpful supervision of Canmuu the moose, they constructed a machine to throw paint at the picture in entire buckets! Beginning with all 0's in the picture grid, the machine splashes a certain paint color (either 0 or 1) over a

rectangle in the grid. In particular, Canmuu suggested that they perform Q (1 <= Q <= 10,000) operations; operation i consists of five integers R1\_i, R2\_i, C1\_i, C2\_i, and X\_i (1 <= R1\_i <= R2\_i <= R; 1 <= C1\_i <= C2\_i <= C; 0 <= X\_i <= 1), meaning that the cows will paint each unit square with a row index between R1\_i and R2\_i, inclusive, and a column index between C1\_i and C2\_i, inclusive, with color X\_i.

However, painting a picture like this is quite prone to mistakes. So Canmuu has enlisted you to determine, after each operation, the number of unit squares in the grid which are the correct color.

MEMORY LIMIT: 64 MB

TIME LIMIT: 1.5 seconds

为了表达假日的激情，奶牛们要画一幅巨大的画。

画布可以分成$R\times C$个方格，从上到下编为 $1$ 到 $R$ 行，从左到右编为 $1$ 到 $C$ 列。作画的颜色有两种，白色（用 $0$ 表示）或者黑色（用 $1$ 表示）。

由于时间紧迫，奶牛们不得不请教北面的邻居，卡门。卡门送给它们一台机器，一次操作只输入5个参数 $R1_i,R2_i,C1_i,C2_i,X_i$ $(1 \le R1_i \le R2_i \le R;1 \le C1_i \le C2_i \le C;0 \le X_i \le 1)$，把 $R1_i$ 行到 $R2_i$ 行，$C1_i$ 列到 $C2_i$ 列的一个大长方形涂成 $X_i$ 色。在所有操作还未进行的时候，画布是白色的。

奶牛们一共要进行 $Q$ 次操作。

因为这样的画法总要出些差错，所以奶牛们想请你算算，每一次操作过后，一共有多少个方格与它们的目标画里对应的方格是同色的。
## 输入格式

\* Line 1: Three space-separated integers: R, C, and Q

\* Lines 2..R+1: Line i+1 contains C characters, each '0' or '1', denoting the i-th row of the grid in the obvious way.

\* Lines R+2..R+Q+1: Line R+i+1 contains five space-separated integers representing a paint operation: R1\_i, R2\_i, C1\_i, C2\_i, and X\_i

## 输出格式

\* Lines 1..Q: On line i+1, print a single integer representing the number of matching unit squares after the i-th operation.

## 样例

### 样例输入 #1
```
17 15 10 
111111101111111 
111111000111111 
111110000011111 
111100000001111 
111000000000111 
111100000001111 
111000000000111 
110000000000011 
111000000000111 
110000000000011 
100000000000001 
110000000000011 
100000000000001 
000000000000000 
111111000111111 
111111000111111 
111111000111111 
5 8 2 14 1 
8 17 3 7 1 
4 5 10 15 0 
7 16 12 14 1 
2 17 13 14 0 
2 6 2 3 1 
13 14 4 8 1 
3 6 6 7 1 
1 16 10 11 0 
7 16 10 10 0 

```
### 样例输出 #1
```
113 
94 
95 
91 
87 
93 
91 
87 
93 
93 

```
## 提示

The cows want to paint a picture of a holiday tree


After the first operation, the picture grid looks as follows:

000000000000000

000000000000000

000000000000000

000000000000000

011111111111110

011111111111110

011111111111110

011111111111110

000000000000000

000000000000000

000000000000000

000000000000000

000000000000000

000000000000000

000000000000000

000000000000000

000000000000000

There are 113 unit squares which match the corresponding square in the tree image; they are denoted below by an 'x' (the other bits are shown as they appear after the first paint splash):

0000000x0000000

000000xxx000000

00000xxxxx00000

0000xxxxxxx0000

0xx111111111xx0

0xxx1111111xxx0

0xx111111111xx0

0x11111111111x0

000xxxxxxxxx000

00xxxxxxxxxxx00

0xxxxxxxxxxxxx0

00xxxxxxxxxxx00

0xxxxxxxxxxxxx0

xxxxxxxxxxxxxxx

000000xxx000000

000000xxx000000

000000xxx000000



---

---
title: "[USACO09NOV] Who Brings the Cookies? G"
layout: "post"
diff: 省选/NOI-
pid: P2961
tag: ['2009', 'USACO', 'Special Judge']
---
# [USACO09NOV] Who Brings the Cookies? G
## 题目描述

Farmer John's N (1 <= N <= 1,000) cows conveniently numbered 1..N decided to form M (1 <= M <= 100) study groups. A total of S\_i (1 <= S\_i <= 19) cows study in group G\_i (namely cows G\_i1, G\_i2, ...). A cow might study in more than one study group.

For each study group, one cow in the group must be chosen to bring cookies to the meeting. Cookies are costly and require time to acquire, so the cows want to divide the work of bringing cookies as fairly as possible.

They decided that if a cow attends meetings with size c\_1, c\_2, ..., c\_K, she is only willing to bring cookies to at most ceil(1/c\_1 + 1/c\_2 + ... + 1/c\_K) meetings.

Figure out which cow brings cookies to each meeting. If this isn't possible, just output '-1'. Choose any solution if more than one is possible.


## 输入格式

\* Line 1: Two space-separated integers: N and M

\* Lines 2..M+1: Line i+1 contains many space-separated integers: S\_i, G\_i1, G\_i2, ...

## 输出格式

\* Lines 1..M: If a mapping is possible, line i contains the number of the cow who brings cookies to study group i. Otherwise, line 1 contains just the integer -1.

## 样例

### 样例输入 #1
```
5 6 
3 2 4 5 
2 1 3 
3 1 2 3 
1 1 
2 2 5 
3 2 3 4 

```
### 样例输出 #1
```
5 
1 
3 
1 
2 
4 

```
## 提示

Cow1 can bring cookies to at most 2 meetings, cow2 can bring 2, cow3 can bring 2, cow4 can bring 1, and cow5 can bring 1.

## 题目翻译

农夫约翰的 $N(1 \le N \le 1000)$ 只奶牛（编号为 $1$ 到 $N$）决定成立 $M(1 \le M \le 100)$ 个学习小组。在学习小组 $G_i$ 中有 $S_i$ 只牛，分别为牛$G_{i1},G_{i2},\cdots$，一头牛可能会参加多个小组。

对于每个学习小组，有一只牛必须在每次聚会的时候带饼乾饮料请大家吃（衰～）。因为买这些零食会消耗牛们那为数不多的零花钱，还会花费牛们宝贵的时间，所以牛们希望尽可能公平地分摊带零食的责任。 牛们决定。如果一只牛参加了 $K$ 个学习小组，$K$ 个学习小组的大小分别为 $c_1,c_2, \cdots c_K$，那麽她最多负责为 $\lceil \frac{1}{c_1} + \frac {1}{c_2} + \cdots + \frac{1}{c_K} \rceil$ 个学习小组的聚会带零食。其中 $\lceil \rceil$为上取整函数。 请计算出一个方案，决定每个学习小组的聚会由哪一头牛负责带零食。如果没有一种方案可行，输出 `-1`。



---

---
title: "[USACO10HOL] Cow Politics G"
layout: "post"
diff: 省选/NOI-
pid: P2971
tag: ['2010', 'USACO']
---
# [USACO10HOL] Cow Politics G
## 题目描述

Farmer John's cows are living on N (2 <= N <= 200,000) different pastures conveniently numbered 1..N. Exactly N-1 bidirectional cow paths (of unit length) connect these pastures in various ways, and each pasture is reachable from any other cow pasture by traversing one or more of these paths (thus, the pastures and paths form a graph called a tree).

The input for a particular set of pastures will specify the parent node P\_i (0 <= P\_i <= N) for each pasture. The root node will specify parent P\_i == 0, which means it has no parent.

The cows have organized K (1 <= K <= N/2) different political parties conveniently numbered 1..K. Each cow identifies with a single

political party; cow i identifies with political party A\_i (1 <= A\_i <= K). Each political party includes at least two cows.

The political parties are feuding and would like to know how much 'range' each party covers. The range of a party is the largest distance between any two cows within that party (over cow paths).

For example, suppose political party 1 consists of cows 1, 3, and 6, political party 2 consists of cows 2, 4, and 5, and the pastures are connected as follows (party 1 members are marked as -n-):

-3-
|
-1-
/ | \
2  4  5

|
-6-
The greatest distance between any two pastures of political party 1 is 3 (between cows 3 and 6), and the greatest distance for political party 2 is 2 (between cows 2 and 4, between cows 4 and 5, and between cows 5 and 2).

Help the cows determine party ranges.

TIME LIMIT: 2 seconds

MEMORY LIMIT: 64MB

农夫约翰的奶牛住在N (2 <= N <= 200,000)片不同的草地上，标号为1到N。恰好有N-1条单位长度的双向道路，用各种各样的方法连接这些草地。而且从每片草地出发都可以抵达其他所有草地。也就是说，这些草地和道路构成了一种叫做树的图。输入包含一个详细的草地的集合，详细说明了每个草地的父节点P\_i (0 <= P\_i <= N)。根节点的P\_i == 0, 表示它没有父节点。因为奶牛建立了1到K一共K (1 <= K <= N/2)个政党。每只奶牛都要加入某一个政党，其中， 第i只奶牛属于第A\_i (1 <= A\_i <= K)个政党。而且每个政党至少有两只奶牛。 这些政党互相吵闹争。每个政党都想知道自己的“范围”有多大。其中，定义一个政党的范围是这个政党离得最远的两只奶牛（沿着双向道路行走）的距离。

## 输入格式

\* Line 1: Two space-separated integers: N and K

\* Lines 2..N+1: Line i+1 contains two space-separated integers: A\_i and P\_i

## 输出格式

\* Lines 1..K: Line i contains a single integer that is the range of party i.

## 样例

### 样例输入 #1
```
6 2 
1 3 
2 1 
1 0 
2 1 
2 1 
1 5 

```
### 样例输出 #1
```
3 
2 

```
## 题目翻译

农夫约翰的奶牛住在 $n$ 片不同的草地上，标号为 $1$ 到 $n$。

恰好有 $n-1$ 条单位长度的双向道路，用各种各样的方法连接这些草地。而且从每片草地出发都可以抵达其他所有草地。也就是说，这些草地和道路构成了一种叫做树的图。输入包含一个详细的草地的集合，详细说明了每个草地的父节点 $p_i$（$0 \le p_i \le n$）。根节点的 $p_i = 0$，表示它没有父节点。

因为奶牛建立了 $1$ 到 $k$ 一共 $k$ 个政党。每只奶牛都要加入某一个政党，其中，第 $i$ 只奶牛属于第 $a_i$（$1 \le a_i \le k$）个政党。而且每个政党至少有两只奶牛。每个政党都想知道自己的“范围”有多大。其中，定义一个政党的范围是这个政党离得最远的两只奶牛（沿着双向道路行走）的距离。

数据范围：$2 \le n \le 200000$，$1 \le k \le \dfrac n2$


---

---
title: "[USACO10JAN] Shipping Around an Island G"
layout: "post"
diff: 省选/NOI-
pid: P2976
tag: ['2010', 'USACO']
---
# [USACO10JAN] Shipping Around an Island G
## 题目描述

Farmer John decided to start his own cruise ship line! He has but one ship, but is hoping for big growth. He recently acquired a map of the area of ocean where his cruise ship will operate. It looks something like the diagram below, with height H (3 <= H <= 1000) and width W (3 <= W <= 1000).

```cpp
................... 
................... 
.....A............. 
.....A..x.......... 
..x..A.....AAAA.... 
.....A.....A..A.... 
.....AAAAAAAA.A.... 
........A.....A.... 
.xx...AAA...x.A.... 
......A............ 
...AAAAAAAAAAAAA... 
................... 
```
In this map, '.' denotes water; 'A' is an element of the main island; and 'x' are other islands.

Farmer John has decided his cruise ship will loop around the main island. However, due to trade restrictions, the path his ship takes is NOT allowed to go around any OTHER islands. For instance, the following path of length 50 is not allowed because it encloses the island denoted by 'x'.

```cpp
................... 
....+--+........... 
....|A.|........... 
....|A.|x.+-----+.. 
..x.|A.+--+AAAA.|.. 
....|A.....A..A.|.. 
....|AAAAAAAA.A.|.. 
....|...A.....A.|.. 
.xx.|.AAA...x.A.|..    <--- route circumnavigates 'x' -- illegal! ..+-+.A.........|.. 
..|AAAAAAAAAAAAA|.. 
..+-------------+.. 
```
Given a map, help Farmer John determine the shortest path his cruise ship can take to go around the main island without going around any other islands.

Two cells are considered connected if they lie vertically or

horizontally across from one another (not diagonally). It is

guaranteed that the main island is connected and that a solution exists.

Note that FJ's path may visit the same square more than once, for instance there are three squares that are visited more than once in FJ's optimal path (of length 62) for the example:

```cpp
................... 
....+--+........... 
....|A.|........... 
....|A.|x.+----+... 
..x.|A.+--+AAAA|... 
....|A.....A..A|... 
....|AAAAAAAA.A|... 
....|...A..+-+A|... 
.xx.|.AAA..|x|A|... 
..+-+.A....+-+-++.. 
..|AAAAAAAAAAAAA|.. 
..+-------------+.. 
```
The above diagram is somewhat unclear because of the path overlapping itself.  Drawn in two stages, FJ's optimal path is:

```cpp
...................            ................... 
...................            ....+--+........... 
.....A.............            ....|A.|........... 
.....A..x..........            ....|A.|x.+----+... 
..x..A.....AAAA....            ..x.|A.+--+AAAA|... 
.....A.....A..A....  and then  ....|A.....A..A|... 
.....AAAAAAAA.A....            ....|AAAAAAAA.A|... 
....V...A..+>.A....            ....V...A...>+A|... 
.xx.|.AAA..|x.A....            .xx...AAA...x|A|... 
..+-+.A....+----+..            .....A.......+-+... 
..|AAAAAAAAAAAAA|..            ...AAAAAAAAAAAAA... 
..+-------------+..            ................... 
```

John 得到一份地图，长 $H$（$3 \leq H\leq 1000$）宽 $W$（$3 \leq W\leq 1000$），地图中 ``.`` 表示水，`A` 表示大陆，`x` 表示其他小岛。他决定驾驶他的船绕大陆一圈，但并不想环绕其他小岛。John 可以再任意有水的格子出发，求绕一周最小路径长度（一个格子可以经过任意多次）。

输入格式：

第一行两个空格隔开正整数 $H$ 和 $W$（$3 \leq H,W\leq 1000$），接下来有 $H$ 行，每行 $W$ 个字符表示地图。
## 输入格式

\* Line 1: Two space-separated integers: H and W

\* Lines 2..H+1: Line i+1 contains contains W characters that are the elements of map row i (all '.' or 'x' or 'A')

## 输出格式

\* Line 1: The minimum length of a path that Farmer John's cruise ship can take

## 样例

### 样例输入 #1
```
12 19 
................... 
................... 
.....A............. 
.....A..x.......... 
..x..A.....AAAA.... 
.....A.....A..A.... 
.....AAAAAAAA.A.... 
........A.....A.... 
.xx...AAA...x.A.... 
......A............ 
...AAAAAAAAAAAAA... 
................... 

```
### 样例输出 #1
```
62 

```


---

---
title: "[USACO10MAR] StarCowraft G"
layout: "post"
diff: 省选/NOI-
pid: P2987
tag: ['2010', 'USACO']
---
# [USACO10MAR] StarCowraft G
## 题目描述

The beta version of StarCowraft II is ready! Farmer John and Bessie are testing it, trying different strategies in one-on-one battles against each other's armies. The goal in StarCowraft II is to defeat your opponent's army in a battle.

Each player's army fights in a battle. An army comprises as many as three different types of 'units' with respective strengths denoted by constant positive real numbers unknown to the players: cattlebruisers with strength S1, cow templars with strength S2, and ultracows with strength S3. The only given bounding information is that no unit is more than 100 times as strong as any another unit.

An army's total strength is the sum of the individual strengths of each of its units. An army that has, among others units, 23

cattlebruisers would gain 23\*S1 strength just from the cattlebruisers.

When two opposing armies fight in a battle, the army with a higher total strength value wins.  If the armies have exactly equal strength values, one of the players randomly wins.

Farmer John and Bessie played N (0 <= N <= 300) 'test battles'. In the i-th test battle, FJ's army had J1\_i cattlebruisers, J2\_i cow templars, and J3\_i ultracows (0 <= J1\_i + J2\_i + J3\_i <= 1,000). Similarly, Bessie's army had B1\_i cattlebruisers, B2\_i cow templars, and B3\_i ultracows (0 <= B1\_i + B2\_i + B3\_i <= 1,000). After their armies fought against each other, FJ and Bessie recorded the winner as a single 'victory letter' V\_i: 'J' if Farm John won the battle; 'B' if Bessie won.

Although these victory results are the only information that they have, they hope to predict some of the results of additional battles if they are given the unit compositions of two opposing armies. For some battles, though, they know it might not be possible to determine the winner with certainty.

Given the results of the N test battles that Farmer John and Bessie already played, write a program that decides the winner (if possible) for M (1 <= M <= 2,000) new battles.

The results reported for the test battles are correct; there exists at least one set of strength values which are consistent with the results.

For purposes of demonstrating the army strength evaluation functions, consider these test battles fought in a game where we (but neither FJ nor Bessie) know that S1=9.0, S2=7.0, and S3=4.0:

```cpp
---- Farmer John ----    ------- Bessie ------    Battle 
J1  J2  J3 J_Strength    B1  B2  B3 B_Strength   Outcome 
6   5   4    105         5   4   7    101          J 
5   4   2     81         3   5   5     82          B 
9   0  10    121         8   2   7    114          J 
```
These results connote the following deduced results for the reasons shown:

---- Farmer John ----    ------- Bessie ------    Battle

J1  J2  J3 J\_Strength    B1  B2  B3 B\_Strength   Outcome

6   6   4    112         5   4   7    101          J

FJ's army is even stronger than in test battle 1 9   0  10    121         8   2   6    110          J

Bessie's army is even weaker than in test battle 3

《星际争霸2》全面公测啦！Farmer John和Bessie正在测试中——在1v1的战役中使用一些不同的策略来对抗对方的部队。《星际争霸2》的游戏目标就是在战役中打败你对手的军队。

每个选手的军队都在战役中拼杀。一支军队由若干3种不同类型的单位所组成，不同单位有着不同的由正实数表示的，且不被选手所知道的力量值：cattlebruisers 的力量是S1，cow templars 的力量是S2，ultracows的力量是S3。唯一提供的信息是，没有一个单位的力量值超过另一个单位力量值的100倍。

一支军队的总力量值，是其中各自单独的单位的力量值的总和。比如一支军队除了其他单位有23个cattlebruisers，那么这支军队单独从cattlebruisers就能获得23\*S1的力量值。

当两支对立的军队在战役中厮杀，有着更高力量值的军队将获得胜利。如果两支军队的力量值恰好相同，那么将随机产生一个获胜方。

Farmer John 和 Bessie 进行了 N (0 <= N <= 300) 局的“测试战役”。在第 i 局测试战役中，Farmer John 有 J1\_i 个 cattlebruisers，J2\_i 个 cow templars 以及 J3\_i 个 ultracows(0 <= J1\_i + J2\_i + J3\_i <= 1,000)。相似的，Bessie的军队有 B1\_i 个 cattlebruisers，B2\_i 个 cow templars 以及 B3\_i 个 ultracows (0 <= B1\_i + B2\_i + B3\_i <= 1,000)。当他们的军队战斗结束后，FJ 和 Bessie 将胜者以一个单独的“胜利字母” V\_i 记录下来："J"表示 Farmer John 赢得了战役；"B" 表示 Bessie 获胜了。

虽然这些结果是他们唯一所拥有的信息，但是他们希望预测一些额外的战役的结果——如果告知他们两支对立军队的组成。尽管，可能对于一些比赛他们是无法确定到底哪一方一定能获胜的。

给出已经结束的 N 场测试战役的结果，写一个程序来确定(如果可能的话)M (1 <=M <=2,000)场额外战役的获胜方。

所有给出的测试战役的结果都是正确的。至少存在一种合法的力量值的取值符合这些结果。

## 输入格式

\* Line 1: Two space-separated integers: N and M

\* Lines 2..N+1: Line i+1 describes a test battle with seven

space-separated items -- a victory letter and six

space-separated integer unit counts: V\_i, J1\_i, J2\_i, J3\_i, B1\_i, B2\_i, and B3\_i

\* Lines N+2..N+M+1: Line i+N+1 describes a 'new battle' using six space-separated integers: J1\_i, J2\_i, J3\_i, B1\_i, B2\_i, and B3\_i

## 输出格式

\* Lines 1..M: Line i contains the outcome of the i-th new battle: 'J' if Farmer John definitely wins, 'B' if Bessie definitely wins, and 'U' (undecidable) if it is impossible to decide the winner with the given information.

## 样例

### 样例输入 #1
```
3 3 
J 6 5 4 5 4 7 
B 5 4 2 3 5 5 
J 9 0 10 8 2 7 
6 6 4 5 4 7 
9 0 10 8 2 6 
3 4 8 4 4 6 

```
### 样例输出 #1
```
J 
J 
U 

```
## 提示

First two games correspond to the examples in the description. The result of the last game cannot be determined with only the information that Farmer John and Bessie currently have. Specifically, both S\_1=9.0, S\_2=7.0, S\_3=4.0 and S\_1=12.0, S\_2=20.0, S\_3=10.0 are consistent with the &quot;test battles,&quot; but they give different results when plugged in the third &quot;new battle.&quot;



---

---
title: "[FJOI2014] 最短路径树问题"
layout: "post"
diff: 省选/NOI-
pid: P2993
tag: ['2014', '各省省选', '福建']
---
# [FJOI2014] 最短路径树问题
## 题目描述

给一个包含 $n$ 个点，$m$ 条边的无向连通图。从顶点 $1$ 出发，往其余所有点分别走一次并返回。

往某一个点走时，选择总长度最短的路径走。若有多条长度最短的路径，则选择经过的顶点序列字典序最小的那条路径（如路径 A 为 $1,32,11$，路径 B 为 $1,3,2,11$，路径 B 字典序较小。注意是序列的字典序的最小，而非路径中节点编号相连的字符串字典序最小）。到达该点后按原路返回，然后往其他点走，直到所有点都走过。

可以知道，经过的边会构成一棵最短路径树。请问，在这棵最短路径树上，最长的包含 $K$ 个点的简单路径长度为多长？包含 $K$ 个点的长度为该最长长度的不同路径有多少条？

这里的简单路径是指：对于一个点最多只经过一次的路径。不同路径是指路径两端端点至少有一个不同，点 A 到点 B 的路径和点 B 到点 A 视为同一条路径。
## 输入格式

第一行输入三个正整数 $n,m,K$，表示有 $n$ 个点 $m$ 条边，要求的路径需要经过 $K$ 个点。

接下来输入 $m$ 行，每行三个正整数 $A_i,B_i,C_i(1\leq Ai,Bi\leq n,1\leq C_i \leq 10000)$，表示 $A_i$ 和 $B_i$ 间有一条长度为 $C_i$ 的边。

数据保证输入的是连通的无向图。
## 输出格式

输出一行两个整数，以一个空格隔开，第一个整数表示包含 $K$ 个点的路径最长为多长，第二个整数表示包含 $K$ 个点的长度为该最长长度的不同路径有多少条。
## 样例

### 样例输入 #1
```
6 6 4
1 2 1
2 3 1
3 4 1
2 5 1
3 6 1
5 6 1
```
### 样例输出 #1
```
3 4
```
## 提示

对于所有数据 $n\leq 30000,m\leq 60000，2\leq K\leq n$。

数据保证最短路径树上至少存在一条长度为 $K$ 的路径。


---

---
title: "[USACO11JAN] Traffic Lights S"
layout: "post"
diff: 省选/NOI-
pid: P3011
tag: ['2011', 'USACO']
---
# [USACO11JAN] Traffic Lights S
## 题目背景

征求翻译。如果你能提供翻译或者题意简述，请直接发讨论，感谢你的贡献。

## 题目描述

Kenosha, the city nearest Farmer John, has M (1 <= M <= 14,000) roads conveniently numbered 1..M that connect N (2 <= N <= 300) junctions which are conveniently numbered 1..N. No two roads connect the same pair of junctions. No road connects a junction to itself. The integer travel time T\_ij (1 <= T\_ij <= 100) between junctions i and j is the same for both directions (i.e., T\_ij = T\_ji).

Each junction has a single traffic light with two colors: blue or purple. The color of each light alternates periodically: blue for certain duration and then purple for another duration.  Traffic is permitted to commence travel down the road between any two junctions, if and only if the lights at both junctions are the same color at the moment of departing from one junction for the other.  The lights do not necessarily have to be the same on the whole trip down the road.

If a vehicle arrives at a junction just at the moment the lights switch it must consider the new colors of lights. Vehicles are allowed to wait at the junctions. You are given the city map which shows:

```cpp
                                    Init  Remg  Blue   Purple
       4       76         Junction  Color Time  Cycle  Cycle
>>[1B]===[2P]======          1        B    2     16      99
    |   /          \         2        P    6     32      13
  40|  /75          \        3        P    2     87       4
    | /              \       4        P   38     96      49
  [3P]===============[4P]>>
           77
```
```cpp
* The travel times T_ij for all roads 
* The durations of the two colors at junction i. (DB_i (1 <= DB_i <= 100) for the blue light and DP_i (1 <= DP_i <= 100) for the purple light) 
* The initial color C_i of the light at junction i (a letter 'B' or 'P' with the obvious meaning) and the remaining time R_i (1 <= R_i <= 100) for this color to change 
Find the minimum time one needs to get from a given source S (1 <= S <= N) to a given destination D (1 <= D <= N; D != S). 
Consider the map below with four junctions and five roads. FJ wants to travel from junction 1 to junction 4. The first light is blue; the rest are purple. 
```
The minimum time is 127 utilizing the path 1-2-4.
Initially, the light at junction 1 is blue. Since the light at junction 2 is purple, vehicle waits at junction 1 for 2 seconds then travels 4 seconds to junction 2.

At time 6, the light at junction 2 switches to blue whereas the light at junction 4 has 32 more seconds to switch to blue. However, after 32 seconds, the light at junction 2 switches to purple and the light at junction 4 switches to blue at the same time. So the vehicle needs to wait 13 seconds more for junction 2 to switch to blue then the lights have the same color and vehicle travels 76 seconds to the destination junction 4.

The total time is 2+4+32+13+76=127 seconds. 

Below is a more graphical presentation of this travel plan:

```cpp
                                                                                                      1    1    1    1    1    1
             1    1    2    2    3    3    4    4    5    5    6    6    7    7    8    8    9    9    0    0    1    1    2    2
   0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5....0....5..
   --------------------------------------------------------------------------------------------------------------------------------
J1 BBBPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPBBBBBBBBBBBBBBBBPPPPPPPPPP
J2 PPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
J3 PPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
J4 PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB
FJ 1..>>>2............................................>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>4
```
## 输入格式

\* Line 1: Two space-separated integers: S and D

\* Line 2: Two space-separated integers: N and M

\* Lines 3..N+2: Line i+2 line describes junction i with a character and three integers (all separated by a single space): C\_i, R\_i, DB\_i, and DP\_i

\* Lines N+3..N+M+2: Line N+2+k describes road k with three integers: i, j, and T\_ij

## 输出格式

\* Line 1: One integer: the time taken by a minimum-time path from the source junction to the destination junction. If there is no path, output 0.

## 样例

### 样例输入 #1
```
1 4 
4 5 
B 2 16 99 
P 6 32 13 
P 2 87 4 
P 38 96 49 
1 2 4 
1 3 40 
2 3 75 
2 4 76 
3 4 77 

```
### 样例输出 #1
```
127 

```
## 题目翻译

## **题目描述**

和FJ靠的最近的城市Kenosha市有 $M$条道路。(编号为$1-M$) 连接着$N$个路口 (编号为$1-N$) 。保证没有重边和自环。 

从点$i$到点$j$需要的时间是$T_{ij}$， 且保证$T_{ij}$ = $T_{ji}$

每个路口有一个交通灯，有两种颜色：蓝色和紫色。两个颜色周期性的交替。蓝色持续一定时间，然后紫色持续一定时间。
想要从$i$到$j$只有在$i$和$j$的信号灯颜色相同的时候才可以走(从T1离开i走向j，只需T1时刻i与j的颜色相同即可，无其他任何约束。)

如果在变幻灯的那一秒到$j$，考虑的是变幻后的颜色。
给你所有第$i$个路口的蓝色灯持续时间$DB_i$和紫色灯持续时间$DP_i$
和每个路口刚开始灯的颜色$C_i$,剩余持续时间$R_i$
求一个给定的原点$S$到给定目标点$D$的最小时间。

## 输入输出格式
###   输入格式
 * 第一行两个整数 S和D
 * 第二行两个整数 N和M
 * 第三至N+2行。第i+2行描述点i的信号灯情况 $C_i$,   $R_i$,  $DB_i$,   $DP_i$
 * 第三道N+M+2行：第N+2+k行描述第k条道路 : $i$, $j$, $T_{ij}$
###   输出格式
 * 一个整数代表从S到D最少消耗的时间， 如果S、D不连通，输出0

感谢@ToBiChi 提供翻译


---

---
title: "[USACO11DEC] Simplifying the Farm G"
layout: "post"
diff: 省选/NOI-
pid: P3037
tag: ['2011', 'USACO']
---
# [USACO11DEC] Simplifying the Farm G
## 题目描述

Farmer John has been taking an evening algorithms course at his local university, and he has just learned about minimum spanning trees.  However, Farmer John now realizes that the design of his farm is not as efficient as it could be, and he wants to simplify the layout of his farm.

The farm is currently arranged like a graph, with vertices representing fields and edges representing pathways between these fields, each having an associated length.  Farmer John notes that for each distinct length, at most three pathways on his farm share this length.  FJ would like to remove some of the pathways on his farm so that it becomes a tree -- that is, so that there is one unique route between any pair of fields.  Moreover, Farmer John would like this to be a minimum spanning tree -- a tree having the smallest possible sum of edge lengths.

Help Farmer John compute not only the sum of edge lengths in a minimum spanning tree derived from his farm graph, but also the number of different possible minimum spanning trees he can create.

农夫约翰在一所夜校学习算法课程，他刚刚学会了最小生成树。现在约翰意识到他的农场设计得不够高效，他想简化农场的布局。


约翰的农场可以看做一个图，农田代表图中顶点，田间小路代表图中的边，每条边有一定的长度。约翰注意到，农场中最多有三条小路有着相同的长度。约翰想删除一些小路使得农场成为一棵树，使得两块农田间只有一条路径。但是约翰想把农场设计成最小生成树，也就是农场道路的总长度最短。


请帮助约翰找出最小生成树的总长度，同时请计算出总共有多少种最小生成树？

## 输入格式

\* Line 1: Two integers N and M (1 <= N <= 40,000; 1 <= M <= 100,000), representing  the number of vertices and edges in the farm graph, respectively.  Vertices are numbered as 1..N.

\* Lines 2..M+1: Three integers a\_i, b\_i and n\_i (1 <= a\_i, b\_i <= N; 1 <= n\_i <= 1,000,000)  representing an edge from vertex a\_i to b\_i with length n\_i.  No edge length n\_i will occur more than three times.

## 输出格式

\* Line 1: Two integers representing the length of the minimal spanning tree and the number of minimal spanning trees (mod

1,000,000,007).

## 样例

### 样例输入 #1
```
4 5 
1 2 1 
3 4 1 
1 3 2 
1 4 2 
2 3 2 

```
### 样例输出 #1
```
4 3 

```
## 提示

Picking both edges with length 1 and any edge with length 2 yields a minimum spanning tree of length 4.




---

---
title: "[USACO12JAN] Delivery Route S"
layout: "post"
diff: 省选/NOI-
pid: P3039
tag: ['2012', 'USACO']
---
# [USACO12JAN] Delivery Route S
## 题目描述

After several years of record milk production, Farmer John now operates an entire network of N farms (1 <= N <= 100).  Farm i is located at position (x\_i, y\_i) in the 2D plane, distinct from all other farms, with both x\_i and y\_i being integers.

FJ needs your help planning his daily delivery route to bring supplies to the N farms.  Starting from farm 1, he plans to visit the farms sequentially (farm 1, then farm 2, then farm 3, etc.), finally returning to farm 1 after visiting farm N.  It tames FJ one minute to make a single step either north, south, east, or west.  Furthermore, FJ wants to visit each farm exactly once during his entire journey (except farm 1, which he visits twice of course).

Please help FJ determine the minimum amount of time it will take him to complete his entire delivery route.


FJ有N (1 <= N <= 100)个农场，每个农场具有独立的整数坐标(x\_i, y\_i)。他需要一个物资配送路线，从第1个农场出发，依次经过农场1，农场2，农场3…，最后从农场N回到农场1.


FJ每次只能朝东南西北四个方向行走，每行走一个单位长度需要1分钟，除了农场1，其他农场能且仅能到达一次。


请计算FJ的最小时间花费。

## 输入格式

\* Line 1: The number of farms, N.

\* Lines 2..1+N: Line i+1 contains two space-separated integers, x\_i and y\_i  (1 <= x\_i, y\_i <= 1,000,000).

## 输出格式

\* Line 1: The minimum number of minutes FJ needs to complete his delivery route, or -1 if it is impossible to find a feasible delivery route that visits every farm exactly once (except farm 1).

## 样例

### 样例输入 #1
```
4 
2 2 
2 4 
2 1 
1 3 

```
### 样例输出 #1
```
12 

```
## 提示

FJ can complete his delivery route in 12 minutes: 2 minutes to go from farm 1 to farm 2, 5 minutes to go from farm 2 to farm 3 (circumventing farm 1), 3 minutes to go from farm 3 to farm 4, and then 2 minutes to return to farm 1.



---

---
title: "[USACO12MAR] Large Banner G"
layout: "post"
diff: 省选/NOI-
pid: P3050
tag: ['2012', 'USACO']
---
# [USACO12MAR] Large Banner G
## 题目描述

Bessie is returning from a long trip abroad to the Isle of Guernsey, and Farmer John wants to mount a nice "Welcome Home" banner for her arrival. Farmer John's field has integer dimensions M x N (1 <= M, N <= 100,000), and he has installed a post at every possible point in the field with integer coordinates (if we assign a coordinate system to the field so that (0,0) is in the lower-left corner and (M,N) is in the upper-right corner). Of these (M+1) \* (N+1) points, Farmer John must pick two as the endpoints of the banner.

 
Farmer John, being the perfectionist that he is, insists that the banner must be completely straight.  This means that, for the two posts he chooses, there cannot be any other post on the line segment that the banner will form between them.  Additionally, Farmer John wants the banner to have length at least L and at most H (1 <= L <= H <= 150,000).  Farmer John needs your help to figure out how many possible ways he can hang the banner. The banner is reversible, so switching the two endpoints of the banner counts as the same way to hang the banner. As this number may be very large, Farmer John simply wants to know what it is modulo B (1 <= B <= 1,000,000,000).

Consider the example below, with M = 2 and N = 2: 

\* \* \*
\* \* \*
\* \* \*
Farmer John wants the length of the banner to be between 1 and 3 inclusive. Any choice of posts satisfies this length requirement, but note that eight pairs cannot be picked:

(0, 0) and (2, 0): (1, 0) is on the line segment between them

(0, 1) and (2, 1): (1, 1) is on the line segment between them

(0, 2) and (2, 2): (1, 2) is on the line segment between them

(0, 0) and (2, 2): (1, 1) is on the line segment between them

(0, 0) and (0, 2): (0, 1) is on the line segment between them

(1, 0) and (1, 2): (1, 1) is on the line segment between them

(2, 0) and (2, 2): (2, 1) is on the line segment between them

(0, 2) and (2, 0): (1, 1) is on the line segment between them

Therefore, there are a total of (9 choose 2) - 8 = 28 possible locations.

给出n,m,l,h，问有多少点A(ax,ay),B(bx,by)满足：ax,bx∈[0,n], ay,by∈[0,m]，l<=AB<=h，且线段AB上除A,B外无整点。

## 输入格式

\* Line 1: Five space-separated integers: M, N, L, H and B.

## 输出格式

\* Line 1: One integer denoting the number of possible banners (modulo B).

## 样例

### 样例输入 #1
```
2 2 1 3 100 

```
### 样例输出 #1
```
28 

```


---

---
title: "[USACO12NOV] Concurrently Balanced Strings G"
layout: "post"
diff: 省选/NOI-
pid: P3059
tag: ['2012', 'USACO']
---
# [USACO12NOV] Concurrently Balanced Strings G
## 题目描述

Farmer John's cows are all of a very peculiar breed known for its distinctive appearance -- each cow is marked with a giant spot on its hide in the shape of a parenthesis (depending on the direction the cow is facing, this could look like either a left or a right parenthesis).

One morning, Farmer John arranges his cows into K lines each of N cows (1 <= K <= 10, 1 <= N <= 50,000).  The cows are facing rather arbitrary directions, so this lineup can be described by K length-N strings of parentheses S\_1,..., S\_k.  Farmer John notes with great excitement that some ranges of his cows are "concurrently balanced", where a range i...j of cows is concurrently balanced only if each of the strings S\_1,..., S\_k is balanced in that range (we define what it means for a single string of parentheses to be balanced below). For instance, if K = 3, and we have

S\_1 = )()((())))(()) 

S\_2 = ()(()()()((()) 

S\_3 = )))(()()))(()) 

1111
01234567890123

Then the range [3...8] is concurrently balanced because S\_1[3...8] = ((())), S\_2[3...8] = ()()(), and S\_3[3...8] = (()()). The ranges [10...13] and [11...12] are also concurrently balanced.

Given K length-N strings of parentheses, help Farmer John count the number of pairs (i,j) such that the range i...j is concurrently balanced.

There are several ways to define what it means for a single string of parentheses to be "balanced".  Perhaps the simplest definition is that there must be the same total number of ('s and )'s, and for any prefix of the string, there must be at least as many ('s as )'s.  For example, the following strings are all balanced:

() 
(()) 
()(()()) 

while these are not:

)( 
())( 
((()))) 

给出k个长度为n的括号序列，问有多少个区间在k个序列中对应的子串均平衡。

## 输入格式

\* Line 1: Two integers, K and N.

\* Lines 2..K+1: Each line contains a length-N string of parentheses.

## 输出格式

\* Line 1: A single integer, the number of concurrently balanced ranges.

## 样例

### 样例输入 #1
```
3 14 
)()((())))(()) 
()(()()()((()) 
)))(()()))(()) 

```
### 样例输出 #1
```
3 

```


---

---
title: "[USACO13NOV] Line of Sight G"
layout: "post"
diff: 省选/NOI-
pid: P3091
tag: ['2013', 'USACO']
---
# [USACO13NOV] Line of Sight G
## 题目描述

Farmer John's N cows (1 <= N <= 50,000) are located at distinct points in his two-dimensional pasture.  In the middle of the pasture is a large circular grain silo.  Cows on opposite sides of the silo cannot see each-other, since the silo blocks their view.  Please determine the number of pairs of cows that can see each-other via a direct line of sight.

The grain silo is centered at the origin (0,0) and has radius R.  No cow is located on or inside the circle corresponding to the silo, and no two cows lie on a tangent line to the silo.  The value of R is in the range 1..1,000,000, and each cow lives at a point with integer coordinates in the range -1,000,000..+1,000,000.

给定平面上的 $N$ 个点，求有多少点对能互相看见而不被以原点为圆心，$R$ 为半径的圆挡住。

题目保证不存在圆上或圆内的点，也不存在连接两点的线段为圆的切线。

$1\le N\le50000$

$1\le R\le10^6$ 

$|x|,|y|\le10^6$
## 输入格式

\* Line 1: Two integers: N and R.

\* Lines 2..1+N: Each line contains two integers specifying the (x,y) coordinates of a cow.

## 输出格式

\* Line 1: The number of pairs of cows who can see each-other.

## 样例

### 样例输入 #1
```
4 5 
0 10 
0 -10 
10 0 
-10 0 

```
### 样例输出 #1
```
4 

```
## 提示

There are 4 cows at positions (0,10), (0,-10), (10,0), and (-10,0).  The silo is centered at (0,0) and has radius 5.


All 6 pairs of cows can see each-other, except for the pairs situated on opposite sides of the silo: the cows at (-10,0) and (10,0) cannot see each-other, and the cows at (0,-10) and (0,10) cannot see each-other.



---

---
title: "[HNOI2008] 遥远的行星"
layout: "post"
diff: 省选/NOI-
pid: P3198
tag: ['2008', '湖南', 'Special Judge']
---
# [HNOI2008] 遥远的行星
## 题目描述

直线上 $N$ 颗行星，$X=i$ 处有行星 $i$，行星 $J$ 受到行星 $I$ 的作用力，当且仅当 $i \le A J$，此时 $J$ 受到作用力的大小为$F_{i->j}=\frac{M_i \times M_j}{j-i}$。

其中 $A$ 为很小的常量，故直观上说每颗行星都只受到距离遥远的行星的作用。
请计算每颗行星的受力，只要结果的相对误差不超过 5% 即可.


## 输入格式

第一行两个整数 $N$ 和 $A$。  
接下来 $N$ 行输入 $N$ 个行星的质量 $M_i$
## 输出格式

$N$ 行，依次输出各行星的受力情况
## 样例

### 样例输入 #1
```
5 0.3
3
5
6
2
4
```
### 样例输出 #1
```
0.000000
0.000000
0.000000
1.968750
2.976000
```
## 提示

$1 \le N \le 10^5$  
$0.01 < a \le 0.35$  
$0 \le M_i \le 10^7$  


---

---
title: "[HNOI2011] 赛车游戏"
layout: "post"
diff: 省选/NOI-
pid: P3218
tag: ['2011', '湖南']
---
# [HNOI2011] 赛车游戏
## 题目描述

名歌手LAALA最近迷上了一款赛车游戏，游戏中开车的玩家在不同的路段需要选择不同的速度，使得自己在最短的时间内到达终点。开始游戏时，车内的初始油量为f，所以游戏的关键是如何在速度和耗油量之间实现平衡。


LAALA 经过一段时间的研究后，发现这款游戏可以用一个简单的数学模型来描述，具体来说：从起点到终点的路线可以被简化成折线段，每条线段代表一个上坡或者下坡，若在一段斜率为 s(s>0 代表上坡，s=0 代表平地，s<0 代表下坡)的道路上以速度 v km/h 行驶，则每公里的耗油量为 max(0,av+bs)，其中 a 和 b 为游戏的内置参数，分别表示在平地行驶时的耗油率及斜坡对耗油量的影响(b 恒为正)。这里假设，加速和减速不耗油，且看成是瞬间完成的，所以即使在同一条线段上也可采取以不同的速度行驶的策略来缩短耗费的时间。


由于 LAALA 在以前的游戏中表现不佳，现在使用的车型依然是系统初始分配的，所以它的速度不能超过 vmax km/h。在获得这些参数后，LAALA 想知道在初始油量受限的情况下（中途不许加油）自己能得到的最佳成绩是多少。作为 LAALA 的歌迷，你能帮帮他吗?

## 输入格式

从文件input.txt中读入数据，输入文件的第一行是一个正整数T，表示数据组数。对每组数据，第一行是用空格隔开的4个浮点数a、b、vmax和f，其中a、b和vmax的意义如前所述，f表示初始油量，其单位也与前面的描述保持一致。第二行是一个正整数r，表示线段的数目。接下来的r行，每行是用空格隔开的2个浮点数xi和yi，分别表示在标准笛卡耳坐标系下该线段在水平方向和垂直方向的改变量(单位为米)。

## 输出格式

输出文件 output.txt 包含 T 行，依次对应输入中的 T 组数据。对某组数据，若基于初始油量无法到达终点，则对应行输出 IMPOSSIBLE，否则输出最少需要的时间(单位为小时)。

## 样例

### 样例输入 #1
```
3
10.0 1.0 150 0.0
1
100.0 -100.0
10.0 100.0 150 1.0
2
100 0
100 100
0.5 0.1 100 10
3
1000 0
100 10
100 -10
```
### 样例输出 #1
```
1.41421
IMPOSSIBLE
0.07212
```
## 提示

【数据范围】


100%的数据满足 T≤100,0.1≤a≤100,0.1≤b≤100,10≤vmax≤200,0≤f≤50,r≤10000,1≤xi≤1000,-1000≤yi≤1000，且如果问题有解，那么答案不超过 24。


你所输出的答案需要恰好保留到小数点后 5 位,当且仅当你的输出与标准答案完全一致时你的输出才被视作正确。




---

---
title: "[HNOI2012] 双十字"
layout: "post"
diff: 省选/NOI-
pid: P3221
tag: ['2012', '湖南']
---
# [HNOI2012] 双十字
## 题目描述

在 C 部落，双十字是非常重要的一个部落标志。所谓双十字，如下面两个例子，由两条水平的和一条竖直的 `1` 线段组成：

```
..........
....1.....      ..1..
..11111...      .111.
....1.....      ..1..
.1111111..      11111
....1.....      ..1..
....1.....
..........
```

合法的双十字要求满足以下几个限制：
- 两条水平的线段不能在相邻的两行。
- 竖直线段上端必须严格高于两条水平线段，下端必须严格低于两条水平线段。
- 竖直线段必须将两条水平线段严格划分成相等的两半。
- 上方的水平线段必须严格短于下方的水平线段。

所以上面右边的例子是满足要求的最小的双十字。

现在给定一个 $R\times C$ 的 `01` 矩阵，要求计算出这个 `01` 矩阵中有多少个双十字。例如下面这个例子，`01` 矩阵如下：

```
10001011
10111111
10001101
11111110
11111111
11101011
```

我们可以找到 $5$ 个满足条件的双十字，分别如下：

```
....1...  ....1...  ....1...
...111..  ...111..  ...111..
....1...  ....1...  ....1...
..11111.  ..11111.  ....1...
....1...  ....1...  ..11111.
........  ....1...  ....1...

....1...  ....1...
...111..  ..11111.
....1...  ....1...
....1...  ....1...
.1111111  .1111111
....1...  ....1...
```

注意最终的结果可能很大，只要求输出双十字的个数 $\bmod\ 10^9+9$ 的值。
## 输入格式

第一行为用空格隔开的两个正整数 $R$ 和 $C$，分别表示 `01` 矩阵的行数和列数。

第二行是一个非负整数 $N$，表示 `01` 矩阵中 `0` 的个数。

接下来的 $N$ 行，每行为用空格隔开的两个正整数 $x$ 和 $y$（$1\le x\le R,1\le y\le C$），表示 $(x,y)$ 是 `0`。数据保证 $N$ 个 `0` 的坐标两两不同。
## 输出格式

一行一个整数，为双十字的个数 $\bmod\ 10^9+9$ 的值。
## 样例

### 样例输入 #1
```
6  8
12
1  2
1  3
1  4
1  6
2  2
3  2
3  3
3  4
3  7
6  4
6  6
4  8
```
### 样例输出 #1
```
5
```
## 提示

对于 $100\%$ 的数据，保证 $5\le R,C\le 10^4$，$0\le N\le 10^4$，$RC\le 2\times 10^6$。


---

---
title: "[JLOI2012] 时间流逝"
layout: "post"
diff: 省选/NOI-
pid: P3251
tag: ['2012', '吉林']
---
# [JLOI2012] 时间流逝
## 题目描述

生活可以很简单。可以探索水底世界的神秘，也可以去发现奇特新生物，亦或踏上一段新生的旅程。在必须要迎接挑战或跟周围的生物进行生存争夺之前，享受自由的飞翔。此时你会觉得生活是如此美好。

像蛇喜欢吃浮游生物一样（哦，我好像忘记告诉你这个常识），每天，你可以吃一些你周围的基础生物，然后会在你的尾巴上得到一个能量圈。你将会有好多种不同的能量圈，每一个都会被赋予一个能量。你可以拥有多个同种的能量圈，但是对于新得到的相同的能量圈，它的能量不能大于你已拥有的任何一个能量圈。除了前面的规则，获得新的能量圈的种类的概率是一样的。一天天过去，你得到越来越多的能量，开始了进化演变。

但是你也有自己的问题，有时你会面对邪恶的果冻鱼。它会追着你咬你，你不得不扔出最小能量值的能量圈然后赶忙逃跑。在这种情况下，你不会有任何的胃口了，因此这天你将不再得到任何能量圈。幸好，当你没有任何能量圈的时候，果冻鱼就算看见你也不会追着你，此时你可以好好地享用美食。

你听说当你的总的能量值超过了某个阈值之后，可以进化成强大模式并能够吃掉果冻鱼。是时候反击了！下面是本题的问题：预计要过多少天你才能进化成强大模式？（第一天默认你没有任何能量圈）

## 输入格式

输入包含多个测例。对每个测例会有两行。第一行是一个浮点数P，一个整数T和一个整数N。P是每天遇到果冻鱼的概率，T是阈值。第二行是N个不同的正整数，表示每一种能量圈的能量值。

## 输出格式

对于每个测例，输出一行表示预计要过多少天你的能量值能够超过阈值，四舍五入到三位小数。

## 样例

### 样例输入 #1
```
0.5 0 1
1
0.5 1 2
1 2
```
### 样例输出 #1
```
1.000
2.000
```
## 提示

对于所有数据，0.1<=P<=0.9，1<=T<=50，1<=N<=50。



---

---
title: "[JLOI2015] 骗我呢"
layout: "post"
diff: 省选/NOI-
pid: P3266
tag: ['2015', '各省省选', '吉林']
---
# [JLOI2015] 骗我呢
## 题目描述

说起来，毕业之后 B 君也就见过 R 君两面而已。  
R 君有一个 $n \times m$ 的数组 $x_{i,j}(1 \le i \le n; 1 \le j \le m)$。  
对于 $1 \le i \le n; 1 \le j \le m$，满足$0 \le x_{i,j} \le m$。求 可能的数组$x_{i,j}$ 的解数。  
B 君觉得限制太宽松，还要求对于 $1 \le i \le n; 1 \le j<m$，满足 $x_{i,j} <x_{i,j+1}$，对于$1 <i \le n; 1 \le j<m$，满足 $x_{i,j} <x_{i-1,j+1}$。  
B 君认为 R 君可以直接 pwn 掉这个题。  
R 君说：「黑的实在逼真 =.=，你起码把解数模 $10^9+7$ 吧。」B 君觉得 R 君说的有道理，于是想让你求解数模 $10^9+7$ 的结果。

## 输入格式

一行两个整数表示 $n, m$，含义如题目中所述。

## 输出格式

一行一个数表示同时满足 B 君和 R 君的条件 $x_{i,j}$ 的解数，模 $10^9+7$ 的结果。

## 样例

### 样例输入 #1
```
3 3
```
### 样例输出 #1
```
40
```
## 提示

对于 $100\%$ 的数据，$1 \leq m, n \leq 10^6$



---

---
title: "[JLOI2016] 圆的异或并"
layout: "post"
diff: 省选/NOI-
pid: P3268
tag: ['2016', '吉林']
---
# [JLOI2016] 圆的异或并
## 题目描述

在平面直角坐标系中给定 $N$ 个圆。已知这些圆**两两没有交点**，即两圆的关系只存在相离和包含。求这些圆的异或面积并。

异或面积并定义为：当一片区域在奇数个圆内，则计入其面积，否则，当一片区域在偶数个圆内则不计入其面积。

## 输入格式

第一行包含一个正整数 $N$，代表圆的个数。

接下来 $N$ 行，每行 $3$ 个非负整数 $x,y,r$，表示一个圆心在 $(x,y)$，半径为 $r$ 的圆。

数据保证 $|x_i|,|y_i|\le 10^8$，$0<r\leq 10^6$，$1\le N\le 2\times 10^5$。

## 输出格式

仅一行一个整数，表示所有圆的异或面积并除以圆周率 $\pi$ 的结果。

## 样例

### 样例输入 #1
```
2
0 0 1
0 0 2
```
### 样例输出 #1
```
3
```


---

---
title: "改造异或树"
layout: "post"
diff: 省选/NOI-
pid: P3359
tag: []
---
# 改造异或树
## 题目描述

给定一棵n 个点的树，每条边上都有一个权值。现在按顺序删掉所有的n-1条边，每删掉一条边询问当前有多少条路径满足路径上所有边权值异或和为0。

## 输入格式

第一行一个整数n。

接下来n-1 行，每行三个整数ai，bi， zi，满足1<= ai， bi <=n，表示树上编号为ai 的点和编号为bi 的点中间连有一条权值为zi 的边。

接下来一行n-1 个整数，两两之间有一个空格隔开，表示一个1~ n- 1 的排列，表示n - 1 条边的删边顺序。

## 输出格式

输出n 行，每行一个整数，依次表示删掉第0~  n - 1 条边之后的边权异或和为零的路径数。

## 样例

### 样例输入 #1
```
4
1 2 0
2 3 0
2 4 0
3 1 2
```
### 样例输出 #1
```
6
3
1
0
```
## 提示

对于20% 数据，满足n  <= 1000。

对于另外30% 数据，满足所有的zi = 0。

对于全部数据，满足n <=10^5，0<= zi<= 10^9。



---

---
title: "Cool loves jiaoyi"
layout: "post"
diff: 省选/NOI-
pid: P3363
tag: ['洛谷原创']
---
# Cool loves jiaoyi
## 题目背景

Cool 交易得十分熟练。现在 Cool 即将参加一场 NOIP 普及组模拟赛。Cool 什么都不会，他将通过交易来获得每一题的题解 / 标程。
## 题目描述

Cool 的交易对象构成了一个树形结构。

对于每一场轰轰烈烈的交易，都会有一个交易起点和交易终点。在树上从交易起点到交易终点的路径称作交易链，交易链上的所有交易对象都将加入这场交易，交易的代价即为交易对象数。

现在 Cool 面临着 $m$ 场交易，现在 Cool 要钦点 $k$ 场交易，使得存在某个神秘交易对象参与了所有 $k$ 场交易，并且最小化这 $k$ 场交易中代价之差的最大值。
## 输入格式

输入包含若干行。

第一行三个整数 $,n,m,k$ 代表交易对象数、交易场数和 Cool 钦定的 $k$。接下来的 $n-1$ 行，每行两个整数 $u,v$ 代表交易对象 $u,v$ 在交易树上相连。

接下来的 $m$ 行，每行两个整数 $s,t$，表示每场交易的交易起点和交易终点（起点终点可以重合）。
## 输出格式

输出包含一个整数，表示 Cool 钦点的最小的最大代价之差，若不存在这样的 $k$ 场交易，输出 $-1$。
## 样例

### 样例输入 #1
```
5 4 3
1 2
1 3
1 4
4 5
2 3
3 5
2 5
4 5
```
### 样例输出 #1
```
1
```
## 提示

选择第 $1,2,3$ 三场交易，则交易对象 $3,4,5$ 被同时交易了 $3$ 次，且三场交易的代价分别为 $3,4,4$。他们交易代价之差最大为 $4-3$。此时最优。


---

---
title: "[POI 2005] DZI-Hollows"
layout: "post"
diff: 省选/NOI-
pid: P3427
tag: ['2005', 'POI（波兰）']
---
# [POI 2005] DZI-Hollows
## 题目描述

在 Byteotia 有两棵非常高的树，而每一棵的树干上都被挖出了许多洞，高度各不相同。现在 $n$ 只可以飞得非常快的鸟决定住在这些洞里，它们中的一些互相认识因此它们想要访问认识的的鸟。鸟们飞得非常快，而且通常沿着一条直线走。为了避免在飞行中撞到别的鸟，它们决定找到某种居住的方式可以满足下面的条件：

- 任何的鸟都可以访问它认识的鸟，而使访问的路线不与其他鸟访问的路线相交（但是可以有同一个终点）.

此外，还要使每只鸟居住的高度尽量低，保证树洞比鸟多。

我们都知道鸟的大脑很小，所以它们请你帮它们算一共有多少个方法可以满足以上条件，将答案模 $k$ 输出。
## 输入格式

在标准输入流的第一行有三个整数 $n，m$ 和 $k$，分别表示鸟的数量，鸟的关系数取模数（$2\le n\le 1000000,1\le m\le 10000000,2\le k\le 2000000$）。鸟的编号是 $1$ 到 $n$。

接下来 $m$ 行是鸟的认识关系，第 $i+1$ 行是两个数字 $a_i$和 $b_i$，用一个空格隔开。$1\le a,b\le n,a_i\ne b_i$。每一对认识的鸟只给出一次。

## 输出格式

设 $r$ 表示满足给定约束的鸟类的不同方案数。您的程序应该在标准输出的第一行中输出一个整数 $r\bmod k$。如果没有方案，则正确的结果为 $0$。
## 样例

### 样例输入 #1
```
3 2 10
1 2
1 3
```
### 样例输出 #1
```
4
```


---

---
title: "[POI 2006] ORK-Ploughing"
layout: "post"
diff: 省选/NOI-
pid: P3444
tag: ['2006', 'POI（波兰）']
---
# [POI 2006] ORK-Ploughing
## 题目描述

Byteasar, the farmer, wants to plough his rectangular field. He can begin with ploughing a slice from any of the field's edges, then he can plough a slice from any unploughed field's edges, and so on, until the whole field is ploughed. After the ploughing of every successive slice, the yet-unploughed field has a rectangular shape. Each slice has a span of $1$, and the length and width of the field are the integers $n$ and $m$.

Unfortunately, Byteasar has only one puny and frail nag (horse) at his disposal for the ploughing. Once the nag starts to plough a slice, it won't stop until the slice is completely ploughed. However, if the slice is to much for the nag to bear, it will die of exhaustion, so Byteasar has to be careful. After every ploughed slice, the nag can rest and gather strength. The difficulty of certain parts of the field varies, but Byteasar is a good farmer and knows his field well, hence he knows every part's ploughing-difficulty.

Let us divide the field into $m\times n$ unitary squares - these are called tiles in short.

We identify them by their coordinates $(i,j)$, for $1\le i\le m$ and $1\le j\le n$.

Each tile has its ploughing-difficulty - a non-negative integer.

Let $t_{i,j}$ denote the difficulty of the tile which coordinates are $(i,j)$.


For every slice, the sum of ploughing-difficulties of the tiles forming it up cannot exceed a certain constant $k$ - lest the nag dies.

A difficult task awaits Byteasar: before ploughing each subsequent slice he has to decide which edge of the field he'll plough, so that the nag won't die. On the other hand, he'd like to plough as few slices as possible.

TaskWrite a programme that:

reads the numbers $k$,$m$ and $n$ from the input file, as well as the ploughing-difficulty coefficients,     determines the best way to plough Byteasar's field,     writes the result to the output file.

Byteasar想耕种他那块矩形的田，他每次能耕种矩形的一边（上下左右都行），在他每次耕完后，剩下的田也一定是矩形，每块小区域边长为$1$，耕地的长宽分别为$m$和$n$，不幸的是Byteasar只有一匹老弱的马，从马开始耕地开始，只有当它耕完了一边才会停下休息。但有些地会非常难耕以至于马会非常的累，因此Byteasar需要特别小心。当耕完了一边之后，马可以停下来休息恢复体力。每块地耕种的难度不一，但是Byteasar都非常清楚。我们将地分成$m\times n$块单位矩形——我们用坐标$(i,j)$来定义它们。每块地都有一个整数$t_{i,j}$,来定义$(i,j)$的耕种难度。所以每次马耕一边地时的难度就是所有它耕种的地的难度总和，对于这匹虚弱的马而言，这个值不能超过他的体力值。Byteasar想知道在马不死掉的情况下最少需要耕多少次才能把地耕完。

## 输入格式

There are three positive integers in the first line of the input file: $k$,$m$ and $n$,separated by single spaces, $1\le k\le 200\ 000\ 000$,$1\le m,n\le 2000$.

In the following $n$ lines there are the ploughing-difficulty coefficients.

The line no. $j+1$ contains the coefficients $t_{1,j},t_{2,j}...,t_{n,m}$, separated by single spaces,$0\le t_{i,j}\le 100\ 000$.

## 输出格式

Your programme should write one integer to the output file: the minimum number of slices required to plough the field while satisfying the given conditions. Since we care for animals, we guarantee that the field can be ploughed according to the above rules. But remember, saving the nag is up to you!

## 样例

### 样例输入 #1
```
12 6 4
6 0 4 8 0 5
0 4 5 4 6 0
0 5 6 5 6 0
5 4 0 0 5 4
```
### 样例输出 #1
```
8
```
## 提示

感谢@NaVi\_Awson 提供翻译



---

---
title: "[POI 2006] TAN-Dancing in Circles"
layout: "post"
diff: 省选/NOI-
pid: P3445
tag: ['2006', 'POI（波兰）']
---
# [POI 2006] TAN-Dancing in Circles
## 题目背景



## 题目描述

$n$ kids attend a certain kindergarten. Everyday the kids arrange themselves in $k$ circles and dance.

At least $l$ kids dance in each circle. Two arrangements of children are considered distinct if there isa child who has a different right neighbour in one of the arrangements than in the other.

Your task is to calculate the number of all distinct arrangements modulo $2005$. Should there beno arrangements satisfying the aforementioned conditions, the correct outcome is $0$.

TaskWrite a programme which:

reads the numbers $n$, $k$ and $l$ from the standard input,        calculates the number $d'=d\ mod\ 2005$, where $d$ denotes the number of distinct arrangements    of the children ($d\ mod\ 2005$ denotes the remainder of the division of $d$ by $2005$),        writes $d'$ to the standard output.

幼儿园中有N个小朋友在做游戏，每天小朋友们都会有一个尬舞方案（围成K个圈尬舞）。


每个圈子里至少有L个小朋友，如果在一个方案里有一个小朋友他右面的小朋友和另一个方案里他右面的小朋友不同，那么两个尬舞方案就会被认为是不同的。


你的任务是计算所有不同的尬舞方案的数量，因为结果可能比较大，所以最后输出答案mod2005的结果。


如果没有符合要求的尬舞方案，输出0。

## 输入格式

The first and only line of the standard input contains three integers separated by single spaces: $n$- the number of children ($3\le n\le 1\ 000\ 000\ 000$), $k$ - the number of circles($1\le k\le n$) and $l$ - the minimal number of kids in a circle ($2\le l\le n$).

只有一行输入，三个整数N,K,L(3≤N≤1,000,000,000 ; 1≤K≤n ; 2≤L≤n)分别代表小朋友数量，圈子数量，每个圈子里最少的小朋友数。

## 输出格式

The first and only line of the standard output should contain a single integer: $d\ mod\ 2005$.

只有一行输出，即合理的尬舞方案数d(mod2005)

## 样例

### 样例输入 #1
```
7 2 3
```
### 样例输出 #1
```
420
```
## 提示

感谢@Paperback\_Writer 提供翻译



---

---
title: "[POI 2006] EST-Aesthetic Text"
layout: "post"
diff: 省选/NOI-
pid: P3446
tag: ['2006', 'POI（波兰）']
---
# [POI 2006] EST-Aesthetic Text
## 题目描述

Let us consider a text consisting of n words numbered from 1 to n. We represent any of its decompositions into k lines by a sequence of numbers (a\_1,a\_2...a\_{k-1}), such that the words with numbers from 1 to a\_1 are in the first line, the words with umbers from a\_1 + 1 to a\_2 are in the second line, and so on, and finally, the words with numbers from a\_{k-1} + 1 to n are in the last, k-th line.


Each word has a certain length (measured in the number of characters). Let length(x) denote the length of the word no. . Furthermore, every two subsequent words in a line are separated by a space of width of a single character. By length of the line we denote the sum of lengths of the words in this line, increased by the number of spaces between them. Let line(w) denote the length of the line no.w . I.e., if the line no.w contains the words with numbers from i to j inclusive, its length is:





```cpp
XXXX (1st line)
XXX XX (2nd line)
XXXXX (3rd line)
```

line(w)=length(i)+..length(j)+(j-i)

As an example, let us consider a text consisting of 4 words of lengths 4, 3, 2 and 5, respectively, and its decomposition (1,3) into 3 lines. Then the length of the first line is 4, second -6 , and third -5 :

We shall refer to the number


|line(1)-line(2)|+...+|line(k-1)-line(k)|

as the coefficient of aestheticism of a decomposition of the given text into k lines. Particularly, if the decomposition has only one line, its coefficient of aestheticism is 0.


Needles to say, the smaller the coefficient, the more aesthetical the decomposition. We shall consider only these decompositions that have no line whose length exceeds some constant m. Of all such decompositions of a given text into any number of lines we seek the one most aesthetical, i.e. the one with the smallest coefficient of aestheticism. The aforementioned examplary decomposition's coefficient is 3, and that is exactly the minimum coefficient of aestheticism for m=6 and m=7.

## 输入格式

The first line of the standard input contains the numbers $m$ and $n$, $1\le m\le 1\ 000\ 000$,$1\le n\le 2\ 000$, separated by a single space. The second, last line of the standard input contains $n$ integers, denotingthe lengths of subsequent words, $1\le length(i)\le m$ for $i=1,2,\cdots,n$, separated by single spaces.

## 输出格式

The first and only line of the standard output should contain exactly one integer: the minimumcoefficient of aestheticism for those decompositions, whose every line's length does not exceed $m$.

## 样例

### 样例输入 #1
```
6 4
4 3 2 5
```
### 样例输出 #1
```
3
```
## 题目翻译

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在, 我们有一个由$n$个单词组成的英文文本. 但是它们都挤在一行里, 单词间以一个半角空格分隔, 就像丑陋的压行代码. 你可以把他们通过$k-1$次换行分割成$k$行的文本并去除行首行末空格. 为方便题意表述, 我们以一个长度为$k-1$的数列$\{a_1,a_2,...,a_{k-1}\}$, 表示第$1$到第$a_1$个单词放在第$1$行, 第$a_1+1$到第$a_2$个单词放在第$2$行, 以此类推.  

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;不过, 为了让新的文本更加美妙, 你希望**在满足每一行的长度不大于$m$的情况下相邻行长度之差的和最小**. 具体地, 令$length(i)$表示第$i$个单词的长度, $line(i)$表示第$i$行的长度, 则:

$$

line(i)=(a_i-a_{i-1}-1)+\sum_{j=a_{i-1}+1}^{a_i}length(j)

$$

你需要求得的答案$Ans$为:

$$

Ans=\min_{k,line(i)\le m}\{\sum_{i=1}^{k-1}|line(i)-line(i+1)|\}

$$

现在输入单词数$n$, 行长度限制$m$, 每个单词的长度$length(i)$, 请输出答案.


---

---
title: "[POI 2006] KRY-Crystals"
layout: "post"
diff: 省选/NOI-
pid: P3447
tag: ['2006', 'POI（波兰）']
---
# [POI 2006] KRY-Crystals
## 题目描述

Byteman is a scientist who investigates creation of crystals consisting of atoms of different elements.

He has designed a special process for creating crystals and has discovered a formula specifying theamount of elements that can be used to create a crystal. Now, he wonders how many differentcrystals can be created in such process.

For non-negative integers $x$ and $y$, by $x\bigoplus y$ we shall denote their bit-wise xor. The basic xor forsingle bits is defined by:

$1\bigoplus 1=0\bigoplus 0=0$,$0\bigoplus 1=1\bigoplus 0=1$.

Byteman knows $n$ different elements that can be used to create crystals -these are numbered from $1$ to $n$. For each element $i$ there is an upper bound $m_i$ on number of atoms of this elementthat can be used to create a crystal. Byteman can create one unique crystal composed of $a_i$ atomsof the element $i$ (for $i=1,\cdots,n$), if and only if:

- $0\le a_i\le m_i$ for $i=1,\cdots,n$

- $a_1\bigoplus\cdots\bigoplus a_n=0$, and

- $a_1+a_2+\cdots+a_n\ge 1$.

Note that the last condition is quite obvious and essentially states that every crystal is composed ofat least one atom.

TaskWrite a programme which:

reads form the standard input: the number of elements and the bounds on numbers of atoms    of particular elements,        computes the number of different crystals that can be created,        writes the result to the standard output.
## 输入格式

The first line of the standard input contains the number of elements $n$, $1\le n\le 50$.

The second, last line of the standard input contains $n$ positive integers $m_1,\cdots,m_n$, separated by single spaces,$1\le m_i<2^{32}-1$.

## 输出格式

Your programme should write one integer to the standard output - total number of different crystals  that can be created. You can assume that this number is less than $2^{64}$.

## 样例

### 样例输入 #1
```
3
2 1 3
```
### 样例输出 #1
```
5
```
## 题目翻译

### 题目描述

给定 $n$ 个正整数 $m_1$ 到 $m_n$，对长度为 $n$ 且满足以下条件的整数序列 $a$ 计数：
- 对于任意 $1\le i\le n$，$0\le a_i\le m_i$；
- $a_1\oplus a_2\oplus\cdots\oplus a_n=0$，其中 $\oplus$ 为按位异或运算；
- $a_1+a_2+\cdots+a_n\ge1$。

### 输入格式
第一行有一个正整数 $n$。

第二行有 $n$ 个正整数，表示 $m_1,m_2,\ldots,m_n$。
### 输出格式
输出一行一个正整数表示序列的个数。
### 说明/提示
$1\le n\le50$。

$1\le m_i\le2^{32}-1$。

数据保证答案小于 $2^{64}$。

感谢 @FZzzz @UnyieldingTrilobite 提供翻译。


---

---
title: "[POI 2008] ROB-Robinson"
layout: "post"
diff: 省选/NOI-
pid: P3468
tag: ['2008', 'POI（波兰）']
---
# [POI 2008] ROB-Robinson
## 题目描述

Tossed by the storm on a deserted island, Robinson built himself a boat    so that he could go out to the sea and seek out human domicile.

He is an experienced sailor, therefore he built the boat with accordance to the rules    of craftsmanship: it has a longitudinal axis of symmetry and an appropriate    shape. The boat's prow is thin, and it widens gradually towards the boat's centre,    only to gradually narrow once again towards the stern.

In particular, at some point in the middle the boat is wider than both at the    prow and stern.

Unfortunately, Robinson has launched his boat in a most improper space: there    is extremely thick reed all around. It is, moreover, so stiff that the boat    cannot break through. Perhaps Robinson can get to the high seas by carefully    manoeuvring between the reed.

Due to lack of manoeuvrability, the boat can move forward and backward and    even sidewards (leftward or rightward), but it cannot turn.

It is thus allowed, and may be in fact necessary, that the boat moves with    its stern or broadside to the front.

You are to judge if Robinson can get to the high seas.

To make your task easier the island and its surroundings will be    represented by a square map divided into square unit fields, each    occupied by either water, part of Robinson's boat or an obstacle, eg.

land or reed. Initially the boat is set parallel to one of the cardinal    directions, ie. its longitudinal axis of symmetry is parallel to this    direction and the axis bisects the unit fields it is covered with.

We assume that the high seas starts where the map ends.

Hence Robinson may get to the high seas if his boat can leave    the area depicted in the map.

A single move consists in moving the boat to a side-adjacent    field in a chosen direction (north, south, east or west).

The move is permissible if both before and after it the boat    remains entirely in water (it does not occupy a field with an    obstacle).

Task      You are to write a programme that                        reads the map's description from the standard input,                      calculates the minimum possible number of boat's moves that          suffice to completely leave the area depicted in the map,                      writes out this number to the standard output.

被风暴抛弃在荒岛上的鲁滨逊（又译鲁滨孙）自己造了一条船，这样他就可以出海去寻找有人类居住的地方。

他是一位经验丰富的水手，因此他根据技术规程建造了它。它有一条纵向的对称轴，以及适于航行的外形：船头较尖，向船中逐渐扩宽，到船尾又逐渐收窄。

特别的是，船中的一些点比船头和船尾都宽。

可是很不幸，鲁滨逊在最不合适的位置让他的船下了水：周围有极其厚的芦苇。此外，这条船太僵硬以至于它无法突破芦苇。不过或许鲁滨逊可以通过在芦苇中小心翼翼地操纵船去往公海。

由于船太不灵活，船可以前进、后退甚至横着（向左或向右）移动，但它不能掉头。

允许船的船尾或者船舷在前进行移动，事实上这可能是必要的。

你需要判断鲁滨逊是否可以到达公海。

为了简化你的工作，岛屿和周围的环境将由一张划分成方格的正方形地图表示，每格只可能是水、鲁滨逊船的一部分或障碍物（比如说岛屿和芦苇）。最初船平行于一个主要方向（换句话说，即其纵向对称轴平行于此方向且其平分其覆盖的方格）

我们假定地图之外就是公海。

因此，如果他的船可以离开地图描绘的区域，鲁滨逊也许就能到达公海了。

一步表现为船往选定的方向（北，南，东或西）移动一格。

如果移动前后的船保持整个在水中（不占据任何有障碍物的格子），那么这个移动是合法的。

你的任务是编写一个程序，从标准输入中读取地图的描述，计算船离开地图描述的区域的最少步数，并输出至标准输出。

## 输入格式

The first line contains one integer $3\le n\le 2000$, denoting the length of the map's side.

In each of the following $n$ lines there are $n$ characters      describing successive fields of the map:

$i^{th}$ character in the $(j+1)^{th}$ line tells the contents      of the field $(i,j)$.

The following characters may appear there:

"." - (dot) denotes a field filled with water,             "X" - denotes an obstacle (land or reed),             "r" - denotes a part of Robinson's boat.
第一行一个正整数 $$3\le_n\le_2000$,$ 表示地图的边长。

接下来 $n$ 行每行 $n$ 个字符表示地图：（此处省略两张图片）第 $(j+1)$ 行的的第 $i$ 个字符表示方格 $(i,j)$。以下的字符可能会在输入中出现：`.`表示一格水，`X` 表示一格障碍物（岛屿或芦苇），`R` 表示鲁滨孙的船的一部分。

## 输出格式

Your programme should write out (in the first and only line of      the standard output) a single positive integer, equal to      the minimum number of boat's moves that suffice to completely      leave the area depicted in the map.

Should getting to the high seas be impossible, write out the word      'NIE' ('no' in Polish).

你的程序应当输出（在标准输出的第一行且仅有一行）一格正整数表示鲁滨逊的船完全离开地图标示的区域需要的最小步数。

如果鲁宾逊无法到达公海，输出一行 `NIE`（波兰语中否定的意思）

## 样例

### 样例输入 #1
```
10
..........
..........
..r.......
.rrrX.....
rrrrr.....
.rrr......
X.r.......
.Xr.......
..........
..........
```
### 样例输出 #1
```
10
```


---

---
title: "[POI 2008] PER-Permutation"
layout: "post"
diff: 省选/NOI-
pid: P3477
tag: ['2008', 'POI（波兰）']
---
# [POI 2008] PER-Permutation
## 题目描述

Multiset is a mathematical object similar to a set,    but each member of a multiset may have more than one membership.

Just as with any set, the members of a multiset can be ordered    in many ways. We call each such ordering a permutation    of the multiset. For example, among the permutations of the    multiset{1,1,2,3,3,3,7,8}. there are {2,3,1,3,3,7,1,8}   and{8,7,3,3,3,2,1,1}.

We will say that one permutation of a given multiset is smaller    (in lexicographic order) than another permutation, if on the first    position that does not match the first permutation has a smaller    element than the other one. All permutations of a given multiset    can be numbered (starting from one) in an increasing order.

Task      Write a programme that   reads the description of a permutation of a multiset and a positive          integerm from the standard input,                      determines the remainder of the rank of that permutation in the          lexicographic ordering modulo m,         writes out the result to the standard output.

多重集合是数学中的一个概念，它的定义很像集合，但是在多重集之中，同一个元素可以出现多次。


和集合一样，多重集的的元素可以有很多种元素的排布顺序。我们把它叫作多重集的排列。


现在我们定义多重集的某个排列$s_i$比某个排列$s_j$

的大小比较为字典序比较。这样某个多重集的排列可以从小到大得排起来。


现在给你一个元素个数为n的多重集的一个排列和m，求这个排列的排名取模m。

## 输入格式

The first line of the standard input holds two integers n($1\le n \le 300000$) and m  ($2 \le m \le 10^9$ ) ,separated by      a single space. These denote, respectively, the cardinality of the      multiset and \dots\ the number m.

The second line of the standard input contains n positive integers      $a_i$($1\le a_i \le 300000$), separated by single spaces and denoting      successive elements of the multiset permutation.

第一行 两个整数n,m


第二行 n个数，代表多重集的排列

## 输出格式

The first and only line of the standard output is to hold one integer,      the remainder modulo m of the rank of the input permutation in the      lexicographic ordering.


一行一个整数 排名取模m

## 样例

### 样例输入 #1
```
4 1000
2 1 10 2

```
### 样例输出 #1
```
5

```
## 提示

感谢@远航之曲 贡献的翻译



---

---
title: "[POI 2009] PRZ-Algorithm Speedup"
layout: "post"
diff: 省选/NOI-
pid: P3481
tag: ['2009', 'POI（波兰）']
---
# [POI 2009] PRZ-Algorithm Speedup
## 题目描述

As a punishment for misbehaving, Byteasar is to calculate a certain mysterious and nasty Boolean-valued function $F(x,y)$, which is defined for a pair of positive integer sequences $x=(x_1,x_2,\cdots,x_n)$, $y=(y_1,y_2,\cdots,y_n)$ as follows:

- boolean $F(x, y)$
- if $W(x)\neq W(y)$ then return $0$ 
- else if $|W(x)|=|W(y)|=1$ then return $1$
- else return $F(p(x), p(y)) \wedge F(s(x), s(y))$.

Where:

- $W(x)$ denotes the set of members of the sequence $x$ (order and repetitions of elements are insignificant),
- $p(x)$ denotes the longest prefix (initial part of any length) of the sequence $x$, such that $W(x)\neq W(p(x))$,
- $s(x)$ denotes the longest suffix (final part of any length) of the sequence $x$, such that $W(x)\neq W(s(x))$,
- $\wedge$ denotes the logical conjunction, $1$ - true, $0$ - false,      and $|z|$ - cardinality of set $z$.

For example, for the sequence $x=(2,3,7,2,7,4,7,2,4)$ we have: $W(x)=\{2,3,4,7\}$, $p(x)=(2,3,7,2,7)$, $s(x)=(7,2,7,4,7,2,4)$. For very large data a programme calculating values of the function $F$ directly from definition is too slow by any standards. Therefore you are to make these calculations as fast as possible.

Write a programme that reads several pairs of sequences $(x,y)$ from the standard input and    prints out the values $F(x,y)$ on the standard output for every input pair.


## 输入格式

The first line of the standard input contains one integer $k$ ($1\le k\le 13$) denoting the number of sequence pairs to analyse.

Next $3k$ line hold descriptions of test cases.

The first line of each description contains two integers $n$ and $m$ ($1\le n,m\le 100{,}000$) separated by a single space and denoting the lengths of the first and second sequence, respectively.

The second line holds $n$ integers $x_i$ ($1\le x_i\le 100$) that form the sequence $x$, separated by single spaces.

The third line holds $m$ integers $y_i$ ($1\le y_i\le 100$),    that form the sequence $y$, separated by single spaces.

## 输出格式

The output should consist of exactly $k$ lines; the $i$-th line (for $1\le i\le k$) should contain a single integer - 0 or 1 - the value of $F(x, y)$ for $i$-th test case.

## 样例

### 样例输入 #1
```
2
4 5
3 1 2 1
1 3 1 2 1
7 7
1 1 2 1 2 1 3
1 1 2 1 3 1 3

```
### 样例输出 #1
```
0
1

```
## 题目翻译

你的任务是计算一个函数F(x, y)，其中x和y是两个正整数序列。F的定义如下：

```cpp
boolean F(x, y)
if W(x) ≠ W(y) then return 0
else if |W(x)| = |W(y)| = 1 then return 1
else return F(p(x), p(y)) AND F(s(x), s(y)).
W(x)表示序列x中元素的集合。（元素的顺序和出现次数将被无视）
p(x)表示序列x的最长前缀，满足：W(x) ≠ W(p(x))
s(x)表示序列x的最长后缀。满足：W(x) ≠ W(s(x))
|Z|表示集合Z中元素个数
```


---

---
title: "[POI 2010] TEL-Teleportation"
layout: "post"
diff: 省选/NOI-
pid: P3505
tag: ['2010', 'POI（波兰）']
---
# [POI 2010] TEL-Teleportation
## 题目描述

King Byteasar is the ruler of the whole solar system that contains ![](http://main.edu.pl/images/OI17/tel-en-tex.1.png) planets.

This number is so large that people have abandoned the silly custom of naming the planets    and use numbers instead. The planets are thus conveniently numbered from 1 to ![](http://main.edu.pl/images/OI17/tel-en-tex.2.png).

Byteasar's palace is on the planet no. 1, while his military base on the planet no. 2.

A long time ago Byteasar had a teleportation portal established between these two planets,    which allows travelling from either planet to another in two hundred and fifty minutes    (slightly over four hours).

Nowadays the teleportation technology is more mature, and the recent teleportation devices shorten    the travel time to just a single hour. Let us note here, that all the portals, both the Byteasar's old one    and the new ones available on the market, are of course bidirectional, and that the teleportation    travel time is irrespective of the distance travelled.

Some planets of the system are already connected with these new teleportation portals.

In fact, it is already possible to travel between the planets no. 1 and 2 without using the king's private portal,    though this involves several other portals and is thus no faster than the king's portal.

Byteasar finds this rather fortunate, as he believes that such possibility would be a security breach.

The technology itself is increasingly available, and as everyone realises its economic significance,    each pair of planets that are not currently directly connected with a portal are petitioning for establishing    such a connection. Being a wise ruler, Byteasar intends to give his consent to as many constructions as possible,    though keeping himself secure, i.e., not allowing the travel between planets 1 and 2 faster than with his private portal.

Help the king determine how many portals he can agree to.
## 输入格式

Two integers are given in the first line of the standard input, ![](http://main.edu.pl/images/OI17/tel-en-tex.3.png) and ![](http://main.edu.pl/images/OI17/tel-en-tex.4.png)      (![](http://main.edu.pl/images/OI17/tel-en-tex.5.png), ![](http://main.edu.pl/images/OI17/tel-en-tex.6.png)), separated by a single space,      denoting the number of planets in Byteasar's realm and the number of new portals      that already exist.

These teleportation portals are described in the ![](http://main.edu.pl/images/OI17/tel-en-tex.7.png) lines that follow.

Each such line contains two integers ![](http://main.edu.pl/images/OI17/tel-en-tex.8.png) and ![](http://main.edu.pl/images/OI17/tel-en-tex.9.png) (![](http://main.edu.pl/images/OI17/tel-en-tex.10.png)),      separated by a single space, denoting that there is a teleportation portal of the new kind      connecting ![](http://main.edu.pl/images/OI17/tel-en-tex.11.png) and ![](http://main.edu.pl/images/OI17/tel-en-tex.12.png).

No pair of numbers appears twice.

You may assume that the existing network of new portals allows travel from      planet no. 1 to planet no. 2, but in no less than 250 minutes.

## 输出格式

Your program should print out just a single integer, namely the maximum number of portals      Byteasar can agree to without breaching his security.

## 样例

### 样例输入 #1
```
10 10
1 3
3 5
5 7
7 9
2 9
1 4
4 6
6 8
8 10
2 10
```
### 样例输出 #1
```
10
```
## 提示

数据保证，$2\le n\le 40\ 000$，$0\le m\le 10^6$，$1\le u_i,v_i\le n$，保证只考虑已有的边时， $1$ 号点与 $2$ 号点联通，且最短路长度大于 $250\min$ 。
## 题目翻译

### 题目描述

**译自 POI 2010 Stage 2. Day 2「[Teleportation](https://szkopul.edu.pl/problemset/problem/fKO3YZL0f_UM1nHQNDvw7mku/site/?key=statement)」**

现在有 $n$ 个点，目前在 $1$ 号点和 $2$ 号点之间有一条无向边，长度为 $250\min$ 。  
除此之外，还有 $m$ 条无向边，长度都为 $1\ \textrm{h}$ （即 $60\min$）， Byteasar 想知道，还能最多在添加多少条长度为 $1\ \textrm{h}$ 的无向边，使得新图无重边无自环，且 $1$ 号点到 $2$ 号点的最短路仍为 $250\min$ 。

### 输入格式

第一行两个空格隔开的正整数 $n,m$ 。  
接下来 $m$ 行，每行两个空格隔开的正整数 $u_i,v_i$ ，描述原有的边。

### 输出格式

一行一个整数，表示最多添加多少条边，可以使 $1$ 号点到 $2$ 号点的最短路长度保持不变。

翻译来自于 [LibreOJ](https://loj.ac/p/2449)。


---

---
title: "[POI 2011] PRZ-Shift"
layout: "post"
diff: 省选/NOI-
pid: P3516
tag: ['2011', 'POI（波兰）', 'Special Judge', 'O2优化']
---
# [POI 2011] PRZ-Shift
## 题目描述

Byteasar bought his son Bytie a set of blocks numbered from $1$ to $n$ and arranged them in a row in a certain order.

Bytie's goal is to rearrange the blocks so that they are ordered naturally, from the smallest number to the largest.

However, the only moves Bytie is allowed to make are:

putting the last block at the very beginning (move a), and                  putting the third block at the very beginning (move b).

Help Bytie by writing a program that tells whether a given arrangement of    blocks can be properly reordered, and tells the right sequence of moves if it is.

## 输入格式

In the first line of the standard input there is a single integer $n$, $1\le n\le 2\ 000$.

In the second line there are $n$ integers from the range $1$ to $n$, separated by single spaces.

No number appears twice, and thus they represent the initial arrangement of the blocks.

## 输出格式

If there is no sequence of moves leading to an arrangement with increasing blocks' numbers, your program should print out "NIE DA SIE" (there is no way in Polish), without the quotation marks.

Otherwise there should be a single integer $m$ ($m\le n^2$), denoting the number of operations, in the first line.

An operation is a $k$-fold execution of either a or b move.

If $m>0$, then there should be a sequence of $m$ integers with either a or b appended in the second line.

Thus $k$a (for $0<k<n$) denotes the $k$-fold execution of the move a.

Analogously, $k$b (for $0<k<n$) denotes the $k$-fold execution of the move b.

Furthermore, the characters appended to the numbers in the second line have to alternate.

Should there be more than one solution, your program is free to pick one arbitrarily.

## 样例

### 样例输入 #1
```
4
1 3 2 4
```
### 样例输出 #1
```
4
3a 2b 2a 2b
```
## 题目翻译

### 题目描述

**译自 POI 2011 Round 1. D「[Shift](https://szkopul.edu.pl/problemset/problem/n6S4y9QrbGqYUz64e2O-OV7D/site/?key=statement)」**

Byteasar 给他的儿子 Bytie 买了一盒共 $ n $ 块积木，他将这些积木从 $ 1 $ 到 $ n $ 编号，并按照一定的顺序摆成一排。Bytie 要将这些积木按照编号从小到大的顺序重新排列，但他只能做下面两种操作：

* 操作 a：将最后一个积木移到最前面。
* 操作 b：把第三个积木移到最前面。

我们将连续进行 $ k $ 次同一个操作称为「一块操作」，表示为 $ k a $ 或 $ k b $。  
你需要帮助 Bytie 写一个程序，告诉他有没有一个操作序列能够使积木按照编号从小到大的顺序重新排列，并告诉他操作序列。

### 输入格式

输入的第一行包含一个整数 $ n $，表示积木的个数。
第二行包含 $ n $ 个整数，表示积木初始的排列顺序，没有重复的数字。

### 输出格式

如果没有一种方案能将积木按照编号从小到大的顺序重新排列，你应当输出 `NIE DA SIE`（波兰语中的 `There is no way`）。

否则，第一行你应当输出一个整数 $ m $，表示操作的**块数**，$ m $ 必须满足 $ m \le n^2 $。  
第二行表示这 $ m $ 块操作，每块操作之间用空格隔开。  
每一块包含操作数 $ k $ 和操作方式，中间**没有**空格，如 `3a`（$ 3 $ 次 a 操作）。  
需要满足相邻两块操作的种类不同，每块操作中进行的次数 $ 0 \lt k \lt n $。

### 数据范围

对于 $ 100\% $ 的数据，$ 1 \le n \le 2000 $。

翻译来自于 [LibreOJ](https://loj.ac/p/2158)，checker 来自于 [帖子](https://www.luogu.com.cn/discuss/70755)。


---

---
title: "[POI 2010] Monotonicity"
layout: "post"
diff: 省选/NOI-
pid: P3541
tag: ['2010', 'POI（波兰）', 'Special Judge', 'O2优化']
---
# [POI 2010] Monotonicity
## 题目描述

**译自 POI 2010 Stage 3. Day 0「[Monotonicity](https://szkopul.edu.pl/problemset/problem/HVVwfLd9uyYNOW6hUZ_Zcnqe/site/?key=statement)」**

对于一个整数序列 $a_1, a_2, \cdots, a_n$，我们定义其“单调序列"为一个由 $<$，$>$ 和 $=$ 组成的符号序列 $s_1, s_2, \cdots,s_{n-1}$，其中符号 $s_i$ 表示 $a_i$ 和 $a_{i+1}$ 之间的关系。例如，数列 $2, 4, 3, 3, 5, 3$ 的单调序列为 $<, >, =, <, >$。

对于整数序列 $b_1, b_2, \cdots, b_{n+1}$ 以及其单调序列 $s_1, s_2, \cdots, s_n$，如果符号序列 $s_1', s_2', \cdots, s_k'$ 满足对所有 $1 \le i \le n$ 有 $s_i = s_{((i - 1) \bmod n) + 1}'$，我们就说序列 $s_1, s_2, \cdots, s_n$ 「实现」了序列 $s_1', s_2', \cdots, s_k'$。也就是说，序列 $s_1, s_2, \cdots, s_n$ 可以通过重复多次 $s_1', s_2', \cdots, s_k'$ 序列并删除一个后缀得到。例如，整数数列 $2, 4, 3, 3, 5, 3$ 至少实现了以下符号序列：

* $<, >, =$
* $<, >, =, <, >$
* $<, >, =, <, >, <, <, =$
* $<, >, =, <, >, =, >, >$

给定一个整数序列 $a_1, a_2, \cdots, a_n$ 以及一个单调序列 $s_1, s_2, \cdots, s_k$，求出原整数序列最长的子序列 $a_{i_1}, a_{i_2}, \cdots, a_{i_m} (1 \le i_1 \lt i_2 \lt \cdots \lt i_m \le n)$ 使得前者的单调序列实现后者的符号序列。
## 输入格式

第一行包含用空格分隔的两个整数 $n,k$，分别表示整数序列 $a_i$ 的长度和单调序列 $s_j$ 的长度。

第二行包含用空格分隔的 $n$ 个整数，表示序列 $a_i$。

第三行包含用空格分隔的 $k$ 个符号，表示符号序列 $s_j$。
## 输出格式

第一行输出一个整数 $m$，表示序列 $a_1, a_2, \cdots, a_n$ 的最长的「实现」了单调序列 $s_1, s_2, \cdots, s_n$ 的子序列。

第二行输出任意一个这样的子序列 $a_{i_1}, a_{i_2}, \cdots, a_{i_n}$，元素之间用空格分隔。
## 样例

### 样例输入 #1
```
7 3
2 4 3 1 3 5 3
< > =
```
### 样例输出 #1
```
6
2 4 3 3 5 3
```
## 提示

对于 $100\%$ 的数据，$1 \le n \le 20000$，$1 \le k \le 100$，$1 \le a_i \le 1000000$，$s_j \in \{<, >, =\}$。


---

---
title: "[POI 2017] Turysta"
layout: "post"
diff: 省选/NOI-
pid: P3561
tag: ['2017', 'POI（波兰）', 'Special Judge']
---
# [POI 2017] Turysta
## 题目描述

给出一个 $n$ 个点的有向图，任意两个点之间有且仅一条有向边。

对于每个点 $v$，求出从 $v$ 出发的一条经过点数最多，且没有重复经过同一个点两次及两次以上的简单路径。
## 输入格式

第一行包含一个正整数 $n$，表示点数。

接下来的 $n-1$ 行，其中的第 $i$ 行有 $i-1$ 个数。

如果第 $j$ 个数是 $1$，那么表示有向边 $j\rightarrow i+1$ ，如果是 $0$，那么表示有向边 $j\leftarrow i+1$。
## 输出格式

输出 $n$ 行，第 $i$ 行首先包含一个正整数 $k$，表示从 $i$ 点出发的最优路径所经过的点数。

接下来 $k$ 个正整数，依次表示路径上的每个点。

若有多组最优解，输出任意一组。

**本题使用 SPJ （Claris 制作）**
## 样例

### 样例输入 #1
```
4
1
1 1
1 0 1
```
### 样例输出 #1
```
4 1 2 3 4
3 2 3 4
3 3 4 2
3 4 2 3
```
## 提示

对于 $100\%$ 的数据，$2\le n\le 2 \times 10^3$。


---

---
title: "[POI 2013] LAS-Laser"
layout: "post"
diff: 省选/NOI-
pid: P3562
tag: ['2013', 'POI（波兰）']
---
# [POI 2013] LAS-Laser
## 题目描述

平面上有些线段，你最多从原点射出 $k$ 条射线，穿过最多的线段，且使得每条线段最多被穿过 $1$ 次。

求最多能穿过多少线段。
## 输入格式

第一行两个整数 $k$，$n$，其中 $n$ 是线段数量。  

之后 $n$ 行，每行四个整数 $x_1,y_1,x_2,y_2$ 表示一条线段。
## 输出格式

输出一个整数，表示最多能穿过几条线段。
## 样例

### 样例输入 #1
```
3 6
1 2 2 4
3 1 5 1
3 2 2 3
3 3 3 4
2 2 2 2
6 1 3 5
```
### 样例输出 #1
```
5
```
## 提示

对于 $100\%$ 的数据，$1 \leq k\le100$，$1 \leq n\le5\times10^5$，$1 \leq x_1, y_1, x_2, y_2 \leq 10^5$。


---

---
title: "yyy棋 II"
layout: "post"
diff: 省选/NOI-
pid: P3614
tag: ['洛谷原创', '提交答案', 'Special Judge', '洛谷月赛']
---
# yyy棋 II
## 题目背景

本题是提交答案题，所有测试数据的输入均开放下载。选手需要提供输出数据。洛谷评测机会根据提交的数据来评分。

输入数据和windows的checker

http://pan.baidu.com/s/1jHU2UwQ

linux的checker

http://pan.baidu.com/s/1nv8Yuy1

#udp1：所有答案文件末尾必须有且只有一个回车

## 题目描述

我们的英明的yyy某日无聊，发(chao)明(xi)了一款风靡世界的游戏。为了纪念这个伟大的发明，自己起名为“yyy棋”（kkk：喂！P2361已经叫做yyy棋了这个是smg？）

在其中的一种情况下棋盘是长这样的：

```cpp
ｘｘ．．．ｘｘ
ｘｘ．．．ｘｘ
．．．．．．．
．．．．．．．
．．．．．．．
ｘｘ．．．ｘｘ
ｘｘ．．．ｘｘ
```
这种情况下一个7\*7的棋盘，‘.’上可以走棋，而‘x’上不能。只有1种棋子，我们假设是‘Y’。

最开始的初始棋子和障碍都是系统给定的。我们假设是这个样子：

```cpp
ｘｘ．．．ｘｘ
ｘｘ．Ｙ．ｘｘ
．．．Ｙ．．．
．．．．．．．
．．．．．．．
ｘｘ．．．ｘｘ
ｘｘ．．．ｘｘ
```
走棋的规则很简单。任意一个棋子可以而且仅可以跳过它相邻的上下左右的一颗棋子而移动两格，而且目的地没有棋子且不是'x'。跳过之后，被跳的那个棋子就会消失。所以像刚刚给出的的那个，我们可以将上方的一个棋子跳到下方，然后就成了这样：

```cpp
ｘｘ．．．ｘｘ
ｘｘ．．．ｘｘ
．．．．．．．
．．．Ｙ．．．
．．．．．．．
ｘｘ．．．ｘｘ
ｘｘ．．．ｘｘ
```
我们的目标是通过一系列运♂动，消除尽可能多的棋子。希望最后可以只留下一个棋子。由于yyy有强迫症，他还希望最后的这一个棋子能够停留在**Zhong央**。

## 输入格式

所有输入数据 yyychess1.in~yyychess10.in ，分别对应 10 个任务。

对于每一个任务：

第一行一个整数N，表示棋盘的大小。

为了方便选手，我们定义坐标(i,j)为第i行第j列。

接下来一行，一个自然数M。

- 如果M=0，那么

接下来是N\*N的矩阵序列。我们用x表示不可走的地方，o表示可以走但是没有放棋的地方，y表示放棋的地方。每个字符不用空格隔开。

- 如果M>0，那么

接下来是M行，每行两个数字，依次表示每个棋子的坐标。这种情况下，没有障碍点。

## 输出格式

输出若干行，表示走法。

对于每一行，输出两个数字和一个字母。两个数字代表(i,j)也就是棋子的坐标，剩下的一个字母是UDLR中的一个，分别表示上下左右跳。

## 样例

### 样例输入 #1
```
7
0
xxoooxx
xxoyoxx
oooyooo
ooooooo
ooooooo
xxoooxx
xxoooxx
```
### 样例输出 #1
```
2 4 D
```
### 样例输入 #2
```
7
2
2 4
3 4
```
### 样例输出 #2
```
3 4 U
```
## 提示

样例解释

两个样例描述的是同一个棋盘，只是第二个没有障碍点。

第一个样例输出，可以拿100%的分数。

第二个样例输出，只能拿90%的分数，因为最后没有在中心$(\frac{n+1}{2},\frac{n+1}{2})$

评分标准：

当你的答案是合法的，并且最后只剩下一个棋子，而且这个棋子在最中心，得该点100%的分数。

当你的答案是合法的，并且最后只剩下一个棋子，而且这个棋子不在最中心，得该点90%的分数。

当你的答案是合法的，并且最后剩下2个，3个，4/5个棋子，分别得该点80%，60%，40%的分数。

除此之外，包括有非法的走法以及剩下超过5个棋子的，该点不得分。

压缩文件提供checker.exe可供预先使用。

方法：

所有文件解压，在命令行中输入checker.exe yyychess1.in youranswer.txt youranswer.txt (最后两个是你的输出文件，请输入两次)

就会告诉你结果。



---

---
title: "曲面"
layout: "post"
diff: 省选/NOI-
pid: P3636
tag: []
---
# 曲面
## 题目背景

xht喜欢研究数学函数，他特别喜欢反比例函数。

## 题目描述

我们知道，反比例函数xy=a的图象是双曲线。



 ![](https://cdn.luogu.com.cn/upload/pic/4375.png) 

xht于是想：把它推广到三维是什么样的呢？


定义曲面C(k)为**方程xyz=k所确定的曲面**。


又定义曲面的美观程度P(k)为曲面C(k)上所有**整点**（x,y,z坐标均为整数）到原点的曼哈顿距离的**平方**之和。


（点（x,y,z）到原点的曼哈顿距离为|x|+|y|+|z|）。

现在，xht把一些曲面{C(a),C(a+1)...C(b)}排成一列，你要求出它们美观程度之**和**对10007取模的结果。

## 输入格式

一行两个正整数数a，b

## 输出格式

一行一个数

![](https://cdn.luogu.com.cn/upload/pic/4376.png)

## 样例

### 样例输入 #1
```
3 3
```
### 样例输出 #1
```
300
```
### 样例输入 #2
```
64 19260817
```
### 样例输出 #2
```
9932
```
## 提示

样例1的解释：


在曲面xyz=3上共有12个整点(1,1,3),(1,3,1),(3,1,1),(-1-1,3),(-1,-3,1),(-3,-1,1),(1,-1,-3),(1,-3,-1),(3,-1,-1),(-1,1,-3),(-1,3,-1),(-3,1,-1)。它们到原点的曼哈顿距离的平方之和为5^2\*12=300。


对于20%的数据，a=b<=100

对于另外40%的数据，a,b<=3\*10^5

对于100%的数据，1<=a,b<=3\*10^8



---

---
title: "方程组"
layout: "post"
diff: 省选/NOI-
pid: P3637
tag: []
---
# 方程组
## 题目背景

从小学开始，我们就一直做各种各样的应用题，其中大多数的题目都可以抽象为解方程组。

为了提高效率，省下时间~~打隔膜~~学习OI，xht 准备开发一个自动解题器。其中的一个核心组件就是解方程组的程序，xht 决定将这个任务交给你。
## 题目描述

一开始，xht 有 $N$ 个变量，记为 $x_1,x_2,\cdots,x_n$。另有一个常数 $K$，以及 $M$ 个方程，每个方程都形如 $x_a-x_b≡c\pmod K$。

由于题目可能会变化，xht 需要不时增加一个新的方程，或者删掉一个方程。

同时，xht 会给你一些这样的询问：令变量 $x_a=c$，求另一个变量 $x_b \bmod K$ 的值。当然，有的时候会因为条件不足，无法解出 $x_b$，那么就输出 $-1$。

数据保证任意时刻两个变量之间最多存在一个方程。保证不会出现自相矛盾的方程组，也不会出现多余的条件（某个方程可以通过其他一些方程推出来）。
## 输入格式

第一行四个整数 $N,M,K,Q$，含义如上。$Q$ 代表操作的条数。

接下来 $M$ 行，每行三个整数 $a,b,c$，表示方程 $x_a-x_b≡c\pmod K$。

接下来 $Q$ 行，每行第一个数 $t$ 代表操作种类，

\* $t=1$，接下来输入 $a,b,c$，代表增加一条方程 $x_a-x_b≡c\pmod K$；

\* $t=2$，接下来输入 $a,b$，代表删除 $a,b$ 之间的方程，如果这条方程不存在，则什么也不做；

\* $t=3$，接下来输入 $a,b,c$，代表询问：令 $x_a=c$，求 $x_b \bmod K$ 的值；
## 输出格式

对于每一个 $3$ 操作（询问），输出一行一个数 $x$（$0\le x<K$），表示 $x_b \bmod K$，如果条件不足，则输出 $-1$。
## 样例

### 样例输入 #1
```
3 2 100 3
1 2 1
2 3 2
3 1 3 0
2 1 2
3 1 3 0
```
### 样例输出 #1
```
97
-1
```
## 提示

样例的解释：

一开始有两条方程：$x_1-x_2=1$，$x_2-x_3=2$。

第一次询问，令$x_1=0$，解得$x_3=(-3)\bmod100=97$。

第二次询问时，删掉了第二条方程，导致条件不足，无法解出 $x_3$，输出 $-1$。

对于 $40\%$ 的数据，只有询问操作。

对于 $100\%$ 的数据，$1\le M<N\le10^5$，$1\le Q\le10^5$，$2\le K\le10^3$，$1\le a,b\le N$，$0\le c<K$。

保证所有的 $a\ne b$。


---

---
title: "[CERC2016] 二分毯 Bipartite Blanket"
layout: "post"
diff: 省选/NOI-
pid: P3679
tag: ['2016']
---
# [CERC2016] 二分毯 Bipartite Blanket
## 题目描述

在二分图中，所有点被划分成了两个不相交的集合 $A$ 和 $B$，每条边都恰好连接着某个 $A$ 和某个 $B$。一个匹配是一个边集，满足没有任何两条边有相同的端点。我们称一个匹配 $M$ 覆盖了点集 $V$ 当且仅当 $V$ 中的每个点都是 $M$ 中至少一条边的端点。


给定一个二分图，每个点有一个正整数权值。定义一个点集的权值为其中所有点的权值之和。


给定一个参数 $t$，请统计有多少点集 $V$，满足 $V$ 的权值不小于 $t$，且 $V$ 被至少一个匹配 $M$ 覆盖。

## 输入格式

第一行包含两个正整数 $n,m$，分别表示 $A$ 集合的点数和 $B$ 集合的点数。

接下来 $n$ 行，每行 $m$ 个 01 字符，其中第 $i$ 行第 $j$ 列为 $1$ 表示 $A_i$ 和 $B_j$ 之间有一条边。

接下来一行包含 $n$ 个正整数 $v_1,v_2,\cdots,v_n$，分别表示 $A$ 中每个点的权值。

接下来一行包含 $m$ 个正整数 $w_1,w_2,\cdots,w_m$，分别表示 $B$ 中每个点的权值。

最后一行包含一个正整数 $t$，表示参数 $t$。

## 输出格式

输出一行一个整数，即满足条件的点集个数。

## 样例

### 样例输入 #1
```
3 3
010
111
010
1 2 3
8 5 13
21

```
### 样例输出 #1
```
3

```
## 提示

$1\leq n,m\leq 20$，$1\leq v_i,w_i\leq 10^7$，$1\leq t\leq 4\times 10^8$。


---

---
title: "[CERC2016] 舞动的盘子 Dancing Disks"
layout: "post"
diff: 省选/NOI-
pid: P3681
tag: ['2016', 'Special Judge']
---
# [CERC2016] 舞动的盘子 Dancing Disks
## 题目描述

Luka非常擅长解决汉诺塔问题，他发明了一种类似汉诺塔的使用盘子和柱子的游戏。这个游戏有n个不同大小的盘子以及36根柱子。盘子按照大小从小到大依次被编号为1到n。柱子形成了6行6列的矩阵，从上到下每行依次被编号为1到6，从左到右每列依次被编号为1到6。



 ![](https://cdn.luogu.com.cn/upload/pic/4686.png) 

游戏一开始，n个盘子都被堆叠在左上角坐标为(1,1)的柱子上。对于每一次操作，玩家可以选择一个柱子，取出最顶上若干个盘子，然后选择右边或者下面的某个柱子，将取出的盘子全部堆叠在其顶上（不会翻转顺序）。游戏的目标是把所有盘子都移动到(6,6)，且自底向上大小依次递减。


给定游戏的初始局面，请找到任意一组玩通关的方法。数据保证解必定存在。

## 输入格式

第一行包含一个正整数n(1<=n<=40000)，表示盘子的数目。

第二行包含n个正整数d\_1,d\_2,...,d\_n(1<=d\_i<=n)，自底向上表示(1,1)柱子上每个盘子的编号。

输入数据保证不存在两个盘子的编号相同。

## 输出格式

输出m行，m表示你的解中游戏操作的次数。

其中第i行包含4个参数r\_i,c\_i,p\_i,n\_i，表示第i步操作，即你选择了(r\_i,c\_i)最上方的n\_i(n\_i>=1)个盘子，然后往p\_i方向移动。

如果向右移动，那么p\_i为“R”（不含引号）；如果向下移动，那么p\_i为“D”（不含引号）。

若有多组方案，输出任意一组。

## 样例

### 样例输入 #1
```
6
1 6 5 4 3 2
```
### 样例输出 #1
```
1 1 D 6
2 1 D 6
3 1 D 6
4 1 D 6
5 1 D 6
6 1 R 6
6 2 R 6
6 3 R 6
6 4 R 6
6 5 R 5
6 5 R 1
```


---

---
title: "[HAOI2017] 方案数"
layout: "post"
diff: 省选/NOI-
pid: P3734
tag: ['2017', '河南', '各省省选']
---
# [HAOI2017] 方案数
## 题目描述

考虑定义非负整数间的“$ \subseteq $”，如果 $ a \subseteq b $，那么 $ a \land b = a $，其中 $ \land $ 表示二进制下的“与”操作。


考虑现在有一个无限大的空间，现在你在 $ (0, 0, 0) $，有三种位移操作。


一、$(x,y,z)\to(x',y,z)$ if $x\subseteq x'$  
二、$(x,y,z)\to(x,y',z)$ if $y\subseteq y'$  
三、$(x,y,z)\to(x,y,z')$ if $z\subseteq z'$  

由于来自东方的神秘力量，有些点被屏蔽了，也就是不能经过了。现在问你到某个点 $ (n, m, r) $ 的方案数，答案对 $ 998244353 $ 取模。

## 输入格式

第一行三个整数 $ n, m, r $。


接下来一行一个整数 $ o $，表示障碍物的数量。


接下来 $ o $ 行，每行三个整数 $ x, y, z $ 表示障碍物的坐标，$ 0 \le x \le n, 0 \le y \le m, 0 \le z \le r $，且障碍物不在 $ (0, 0, 0) $ 和 $ (n, m, r) $ 上，障碍物不会重复。


## 输出格式

一行一个整数，代表要求的答案。

## 样例

### 样例输入 #1
```
1 1 1
0
```
### 样例输出 #1
```
6
```
## 提示

【样例解释】

有8种状态（0,0,0),(0,0,1),(0,1,0),(0,1,1),(1,0,0),(1,0,1),(1,1,0),(1,1,1),分别方案数为 1,1,1,2,1,2,2,6。

【数据规模和约定】

对于 $ 20\% $ 的数据，满足：$ n, m, r \le 100 $


对于 $ 50\% $ 的数据，满足：$ n, m, r \le 10^6 $


对于另外 $ 20\% $ 的数据，满足：$ o \le 10 $


对于 $ 100\% $ 的数据，满足：$ n, m, r \le 10^{18}, o \le 10^4 $



---

---
title: "[TJOI2017] 龙舟"
layout: "post"
diff: 省选/NOI-
pid: P3762
tag: ['2017', '各省省选', '天津']
---
# [TJOI2017] 龙舟
## 题目描述

加里敦大学有一个龙舟队，龙舟队有 $n$ 支队伍，每只队伍有 $m$ 个划手。龙舟比赛是一个集体项目，和每个人的能力息息相关，但由于龙舟讲究配合，所以评价队伍的能力的是一个值 $C=\frac{b_1 \times b_2 \times \cdots \times b_m}{a_1 \times a_2 \times \cdots \times a_m}$，其中 $b_i$ 表示第 $i$ 个位置的标准能力值，$a_i$ 表示在队伍中第 $i$ 个位置的划手的能力值。最后通过约分，我们会得到 $C=\frac{B}{A}$，其中 $\gcd(B,A)=1$，即 $A,B$ 互质。

但是由于比赛现场的情况不一样，我们认为在现场压力为 $M$ 的情况下，队伍最后的表现情况是 $C^{-1}\mod M$。我们规定在模 $M$ 的条件下 $\frac{1}{x}=y$，其中 $y$ 满足 $xy \equiv 1\pmod M$，并且 $y$ 大于等于 $0$ 小于 $M$。如果不存在这样的 $y$ 我们就认为在压力为 $M$ 的条件下这支队伍会发挥失常（即 $y$ 是 $x$ 在模 $M$ 意义下的逆元，如果不存在逆元我们认为队伍发挥失常）。给出这个赛季的比赛安排情况，现在教练组想知道各队在比赛中的表现情况。
## 输入格式


第一行输入三个整数 $n,m,k$，表示有 $n$ 支队伍，每支队伍由 $m$ 个人组成，有 $k$ 场比赛。

第二行输入 $m$ 个整数，第 $i$ 个整数表示第 $i$ 个位置的标准能力值为 $b_i$。

第三行到第 $n+2$ 行，共 $n$ 行，每行有 $m$ 个数，第 $2+i$ 行第 $j$ 个数表示第 $i$ 支队伍第 $j$ 个位置划手的能力值。

第 $n+3$ 行到第 $n+k+2$ 行，共 $k$ 行，每行有两个数 $x,M$，分别表示第 $x$ 支队伍会在压力为 $M$ 的比赛中出战。
## 输出格式

共 $k$ 行，第 $i$ 行表示在第 $i$ 个参赛安排中队伍的现场表现情况 $C$，如果出现队伍发挥失常，输出 `-1`。
## 样例

### 样例输入 #1
```
2 3 3
5 2 3
3 2 3
2 3 2
1 4
2 4
1 7
```
### 样例输出 #1
```
3
-1
4
```
## 提示

对于 $20\%$ 的数据，$1<M,a_i,b_i<10^8$，$m \le 100$。

对于 $100\%$ 的数据，$1<M,a_i,b_i<2 \times 10^{18}$，$m \le 10000$，$n \le 20$，$k \le 50$。


---

---
title: "[SHOI2012] 火柴游戏"
layout: "post"
diff: 省选/NOI-
pid: P3828
tag: ['2012', '各省省选', '上海']
---
# [SHOI2012] 火柴游戏
## 题目背景

SHOI2012D1T1

## 题目描述

小明非常喜欢玩火柴游戏：首先用火柴棒摆出一个可能是错误的等式，然后通过添加、删除或移动火柴棒，使得等式成立。下图展示每个数字的样子：

 ![](https://cdn.luogu.com.cn/upload/pic/6548.png) 

我们只考虑形如“A = B”的式子，其中 A 和 B 是两个具有相同位数的整数。

小明可进行三种操作：

1. 在任意位置添加一根火柴棒；

2. 从任意位置删除一根火柴棒；

3. 将任意一根火柴棒移动到另一个位置。

在完成所有操作后，等号两侧必须都是合法的数字，且完全相等。我们约定：

1. 小明不能消除任何数字，也就是说，可以删除一个数字的部分火柴，但不能令它消失；

2. 小明不能增加任何数字，也就是说，可以在一个已有的数字上添加火柴，或将火柴移动到一个已有的数字上，但不能凭空增加一个数字；

3. 小明不能拆分或者合并数字，比如将一个 8 变成两个 1，或者将两个 1合并成一个 8；

4. 其中代表 1 的火柴棒必须靠右边摆放，放在左边不是有效的数字。每种操作都有一定的代价：

 对一个添加操作，如果这是第$i$次进行添加操作，这一步的费用为 $p_1\times i+q_1$

 对一个删除操作，如果这是第$i$次进行删除操作，这一步的费用为$p_2\times i+q_2$

 对一个移动操作，如果这是第$i$次进行移动操作，这一步的费用为$p_3\times i+q_3$

例如，小明在游戏中添加了 3 根火柴，移动了 1 根火柴，删除了 2 根火柴，那么他总的花费为$[(p_1\times 1+q_1)+(p_1\times 2+q_1)+(p_1\times 3+q_1)]+(p_3\times 1+q_3)+[(p_2\times 1+q_2 )+(p_2\times 2+q_2)]$。

小明想知道，他如何才能用最少的花费使等式成立。你能写个程序帮助他吗？

## 输入格式

第 1 行，一个整数 L，表示等式中两个数的位数。

第 2-3 行，每行各一个长度为 L、仅由数字构成的字符串，表示等式两侧的数。

第 4 行，给出六个不超过 100 的非负整数$p_1,q_1,p_2,q_2,p_3,q_3$。

## 输出格式

输出一行，包含一个整数，为使等式成立的最小的操作代价。

## 样例

### 样例输入 #1
```
2
46
78
0 1 0 1 0 1
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
2
23
52
1 1 1 1 1 1
```
### 样例输出 #2
```
9
```
## 提示

对于 30%数据，有$L\le 20$，且$p_1 = p_2 = p_3 = 0$；

对于 60%数据，有$L\le 100$；

对于 100%数据，有$L\le 200$。



---

---
title: "[TJOI2007] 足彩投注"
layout: "post"
diff: 省选/NOI-
pid: P3849
tag: ['2007', '各省省选', '天津']
---
# [TJOI2007] 足彩投注
## 题目背景

了解足球彩票的人可能知道，足球彩票中有一种游戏叫做“胜负彩”，意为猜比赛的胜负。下面是一些与胜负彩有关的术语：

注      ：每一组有效组合数据。

投    注：彩民以现金购买足球彩票的行为。

单式投注：彩民对于所有球队的比赛成绩均只选择一种预测结果的投注方式。投注的数量（注数）为1。

复式投注：彩民对于某些场次的比赛成绩选择两种以上的预测结果的投注方式。投注的数量为复式投注的组合数。例如，某彩民对一场比赛预测了两个结果（例如，胜平），           另一场比赛预测了三个结果（胜负平），其他比赛都只预测了一种结果，那么注数就是2×3 = 6。这样的一个复式投注，可以看成一个包含六种单式投注的集合。


胜负彩的玩法一般是这样的。彩票机构指定一轮比赛中的若干场，让彩民去猜每场比赛的结果（胜、负、平）。根据彩民猜中比赛的场次，来确定中奖的额度。

## 题目描述

我们现在考虑一个简化的模型。对于一轮比赛，彩民需要竞猜其中n场比赛的结果，每场比赛的胜负平都有一个概率p(i, r)。其中，i表示第i场比赛。r = 0, 1, 2，分别表示比赛结果的（主队）负、平、胜。p(i, r)则表示第i场比赛、结果为r的概率。此外，还有一个概率q(i, r)，表示第i场比赛，投注购买结果为r的概率。


例如，如果q(1,0) = 0.5，我们可以知道第一场比赛有50%的投注会买主队输球。我们假设这n场比赛互不相关，即p(i, r)的结果不会受p(j, r’)的影响，q(i, r)的结果也不会受q(j, r’)的影响（r ≠ r’）。


在这个模型里，我们规定，必须猜中全部n场比赛的结果才能获奖。总奖金为M，由所有获奖的投注平分。因此，对于一个单式投注Ri = {ri1, ri2, …, rin}，rij表示投注Ri对第j场比赛的预测结果，它的中奖概率为：

 ![](https://cdn.luogu.com.cn/upload/pic/6080.png) 

设投注总数为N，那么中奖的投注总数为：

 ![](https://cdn.luogu.com.cn/upload/pic/6081.png) 

于是，投注Ri所能得到的奖金的期望（平均意义下能够获得的奖金数）就是：

 ![](https://cdn.luogu.com.cn/upload/pic/6082.png) 

以上考虑的仅仅是单式投注的情况，即仅考虑单注Ri的中奖情况。对于复式投注，情况要复杂一些。采用复式投注时，投注的是一个集合R = {R1, R2, …, Rk}，其中k是投注的数量。例如，三场比赛，第一场猜“胜负”，第二场猜“平”，第三场猜“负平”，则k = 4，R集合如下：

 ![](https://cdn.luogu.com.cn/upload/pic/6083.png) 

复式投注R中，只要有一个Ri猜对所有比赛结果，即可中奖。因此，复式投注R所能获得的奖金的期望就是：


 ![](https://cdn.luogu.com.cn/upload/pic/6084.png) 

我们的问题是，给定n场比赛的信息（胜负平的概率和彩民购买三种结果的概率），以及复式投注中可以购买的最大注数U，要求设计一种复式投注的方案，在不超过最大注数（复式投注的注数k ≤ U）的前提下，使得获得奖金的期望最大。

## 输入格式

第一行四个整数n, N, M, U（n, U ≤ 10^4, N, M ≤ 10^9）。

以下n行，每行六个实数。第i + 1行的六个实数为p(i, 0), p(i, 1), p(i, 2), q(i, 0), q(i, 1)和q(i, 2)，用来描述第i场比赛的相关信息。其中，p(i, 0) + p(i, 1) + p(i, 2) = 1, q(i, 0) + q(i, 1) + q(i, 2) = 1, q(i, j) ≠ 0。

## 输出格式

一个实数，表示最大的奖金期望的自然对数

 ![](https://cdn.luogu.com.cn/upload/pic/6085.png) 

输出保留3位小数（四舍五入）。

## 样例

### 样例输入 #1
```
1 10 10 1
0.3 0.2 0.5 0.7 0.2 0.1
```
### 样例输出 #1
```
1.609
```


---

---
title: "[TJOI2007] 脱险"
layout: "post"
diff: 省选/NOI-
pid: P3851
tag: ['2007', '各省省选', '天津']
---
# [TJOI2007] 脱险
## 题目背景

一批探险队员正在一个迷宫一样的山洞里摸索，突然他们得到了一个糟糕的消息，由于附近发生地震，这个山洞将有可能在 $T$ 个单位时间后坍塌。现在他们要用最快的速度找出一个方案，使得在 $T$ 个单位时间内逃出的队员最多。已知探险队员在一个单位时间内可以向前后左右任一方向移动一格，也可以停留在原地不动。有一个糟糕的情况是，虽然山洞的内部比较宽敞，但山洞的出口都非常狭窄，一个单位时间只能允许一名队员通过。

## 题目描述

山洞的地图用一个 $R \times C$ 的字符矩阵表示：

- `.` 表示在开始的时候没有探险队员的空地，空地可以容纳任意多的探险队员；
- `P`表示在开始的时候有探险队员的空地，我们假设在开始的时候所有的队员都在不同的位置上，且没有队员恰好位于出口所在的方格；
- `*` 表示障碍物，探险队员不能经过被障碍物占据的方格；
- `O`（大写字母 `O`）表示出口，输入数据保证出口一定位于地图的边界上，即只有第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列有可能出现 `O`。

另外，输入数据保证整个地图被边界和出口围住，即第 $1$ 行，第 $R$ 行，第 $1$ 列，第 $C$ 列只能是 `*` 或 `O`。

## 输入格式

输入文件的第一行是用空格隔开的两个整数 $R$ 和 $C$，表示地图的大小。第二行是整数 $T$，即山洞将要坍塌的时间。接下来 $R$ 行，每行包含 $C$ 个字符，表示一幅山洞地图。

## 输出格式

输出一行，包含一个整数，即 $T$ 个单位时间内最多能逃出的人数。

## 样例

### 样例输入 #1
```
5 5
4
*****
*P..*
O**.O
*P..*
*****
```
### 样例输出 #1
```
1
```
## 提示

山洞有两个出口，但只有右边的出口是可以到达的。虽然在 $3$ 个单位时间内两人都可以到达出口左侧的方格处，但由于在出口处一个单位时间只能允许一人通过，故 $4$ 个单位时间内只能逃出一人。两人都逃出需要 $5$ 个单位时间。

- 对于 $30\%$ 的数据，队员数和出口数均不超过 $10$；
- 对于 $100\%$ 的数据，$3 \le R, C \le 12，0 < T \le 50$。



---

---
title: "[TJOI2010] 数字序列"
layout: "post"
diff: 省选/NOI-
pid: P3876
tag: ['2010', '各省省选', '天津']
---
# [TJOI2010] 数字序列
## 题目描述

考虑一个由数字0,1,2,3组成的长度为n的序列，如果它是一个合法序列，那么它应当满足以下两个条件：

1) 序列中任意相邻的两元素没有出现模式{'00', '11', '22', '33', '02', '20', '23', '32', '13', '31'}中的任一种;

2) 序列满足m个约束条件，每个约束条件的形式均为：{p1, p2, ... pL}，它表示序列中的p1, p2, ..., pL这些位置的值不同。例如约束条件{1, 5, 11}表示序列中的第一个，第五个和第十一个元素两两各不相同。

现在已知序列长度n，约束条件个数m以及这m个约束条件，问是否存在这样的合法序列。

## 输入格式

输入文件的第一行是一个正整数T，表示文件中包含T组测试数据。从文件的第二行开始，将依次给出所有的测试数据。每个测试数据的第一行是两个整数n和m，它们的涵义如上面题目描述中所示。接下来有m行，每行描述一个约束条件，其中在描述第i个约束条件的行中，第一个数字是表示这个约束条件包含多少个元素的正整数Li，后面由Li个正整数给出第i个约束的具体情况。

## 输出格式

共输出T行，对每组测试数据输出一行，如果存在满足条件的合法序列，输出"Yes"；否则，输出"No"。

## 样例

### 样例输入 #1
```
2
7 2
3 1 2 4
4 2 4 5 7
3 1
2 1 1

```
### 样例输出 #1
```
Yes
No

```
## 提示

T ≤ 10，1 ≤ n ≤ 100000，0 ≤ m ≤ 5000，1 ≤ Li ≤ 100，1 ≤ pi ≤ n

每个测试点时限1秒

第一组样例中，序列0103012是满足要求的一个合法序列。



---

---
title: "[TJOI2010] 打扫房间"
layout: "post"
diff: 省选/NOI-
pid: P3877
tag: ['2010', '各省省选', '天津']
---
# [TJOI2010] 打扫房间
## 题目描述

学校新建了一批宿舍，值日生小A要把所有的空房间都打扫一遍。这些宿舍的布局很奇怪，整个建筑物里所有的房间组成一个N \* M的矩阵，每个房间的东南西北四面墙上都有一个门通向隔壁房间。另外有些房间是堆放杂物的，无需打扫。小A想设计若干条打扫路线，使得恰好进出每个需打扫的房间各一次，而且进出每个房间不能通过同一个门。要求每条路线都是一个闭合的环线，并且每条路线经过的房间数大于2。

如下面两图所示均为满足要求的打扫方案（灰色格子为放杂物的房间）：

 ![](https://cdn.luogu.com.cn/upload/pic/6841.png) 

小A发现对于某些房间布局是不存在这样的满足要求的方案的。他请你写一个程序计算一下，对于一种给定的房间布局，满足要求的方案是否存在。

## 输入格式

输入文件的第一行是一个整数T (1 ≤ T ≤ 10)，表示该文件中一共有T组数据。接下来依次是T组数据的信息。每组数据的第一行包含两个整数N和M，接下来的N行，每行包含M个字符，表示一个房间布局。字符'.'表示该房间需要打扫，'#'表示该房间是堆放杂物的，无需打扫。

## 输出格式

共输出T行，对每组数据输出一行，为"YES"或"NO"，表示打扫方案存在与否。

## 样例

### 样例输入 #1
```
4
3 4
##..
....
....
3 4
##..
....
#...
3 4
##..
#...
#...
3 4
####
#..#
####

```
### 样例输出 #1
```
YES
NO
YES
NO

```
## 提示

对50%的数据，3 ≤ N,M ≤ 12

对100%的数据，3 ≤ N,M ≤ 30

每个测试点时限1秒



---

---
title: "[JLOI2008] 棋局定式"
layout: "post"
diff: 省选/NOI-
pid: P3883
tag: ['2008', '各省省选', '吉林']
---
# [JLOI2008] 棋局定式
## 题目描述

在“jloi-08”游戏中，还存有非常非常多的棋局定式，也就是常会用到的下棋的组合。有时在学习一个著名棋局时，电脑会考一考刘先生：在这局棋里面，有多少个定式啊？分别是什么啊？


对于30~40步的普通棋局，刘先生还能回答出来，可是有时候2个实力相当的大牛下的棋局，2000000步都有可能。如果电脑对这样的棋局提上面的问题时，刘先生就必须写一个程序来帮助自己了。可是，刘先生在这方面却…，怎么写也写不对。你能帮助刘先生吗？


棋局是由很多step组成的，而step是由一个字符串组成的，比如Kh2或者是Nxb7。

前者表示K(king)移动至h2格，后者表示N(knight)移动至b7格并吃掉原有的棋子。


第一个字符可能有6种：K Q B N R P，而后面可能是一个坐标或者是字符x后跟一个坐标。


坐标是由一个小写英文字母(a~h)和一个数字(1~8)组成的。


如果一个棋局中完整地并连续地包含一个定式中所有的step，那么这个棋局便包含这个定式。

## 输入格式

第一行2个整数n, m，表示定式的个数(1<=n<=2000)以及这个棋局所包含的步数


下面的n个块(block)，每块包含：

第一行一个整数k表示定式包含的步数(1<=k<=100000, ∑k<=200000)

第二行一个字符串表示该定式的名称(长度不超过50)

下面的k行每行一个字符串表示定式中的一步


最后的m行每行一个字符串，表示棋局中的一步

## 输出格式

按照输入文件包含的定式的顺序，输出棋局包含的所有定式的名称，一个一行。

## 样例

### 样例输入 #1
```
2 5
3
King's Knight Opening
Pe4
Pe5
Nf3
3
Nimzowitsch Variation
Pc4
Pe5
Nf3
Pe4
Pe5
Nf3
Nc6
Bb5

```
### 样例输出 #1
```
King's Knight Opening
```
## 提示

不保证给出的棋局和定式符合国际象棋的规则。



---

---
title: "[GDOI2014] 吃"
layout: "post"
diff: 省选/NOI-
pid: P3889
tag: ['2014', '各省省选', '广东']
---
# [GDOI2014] 吃
## 题目背景

感谢 @FFjet 提醒，第 8 个数据点损坏暂时删除。
## 题目描述

W师兄计划了很久，终于成功的在BG开了一家寿司店。

正当W师兄还在兴奋的时候，这时一个噩耗传来，吃货L师姐居然知道了这件事，而且正赶过来，W师兄瞬间心就冷了下去，但是机智的W师兄也瞬间想到了应付L师姐的策略.......

这时，L师姐到了寿司店，先四处望了望风景，发现现在只有L师姐一个顾客，下面是L师姐的选餐说明：

1.寿司店内的寿司被排在一行共N个盘子里，按从左到右编号为1~N。

2.每个位置上寿司的数量是确定的并且有玻璃窗保护。

3.每隔一段时间就会有一个选餐时间，L师姐可以在一个连续的区间[l, r]中选择其中一盘，然后在该区间之外选择另一盘（如果区间外有盘子）。

L师姐发现这家寿司店厨师的制作速度很快，总能在下一次选餐时间前将寿司数量恢复原样。

作为有尊严有追求的吃货，L师姐也有自己的规则，L师姐在选完两盘寿司后，会决定每口恰好吃D个寿司，且使得两盘寿司刚好可以分别吃完，不剩余任何寿司。比如两盘寿司数量为2和4,那么D=1或者D=2都可以恰好将两盘寿司分别吃干净，而两盘寿司数量为3和5时，那么只能D=1才行。

作为有特殊追求的L师姐才不在乎吃的数量，L师姐在乎的是一口吃多个寿司的感觉。于是，如果L师姐可以一口吃D个寿司，那么L师姐的愉悦值为D，但是L师姐没有选到两盘寿司，那么她的愉悦值为0。

现在L师姐知道每个盘子所放着的寿司数量，L师姐想知道每次选择时间过后她可以获得的最大愉悦值是多少？

## 输入格式

第一行输入一个整数N，表示寿司的盘子数量。

第二行输入N个整数a1,a2,…,aN，ai表示第i个盘子内的寿司数量。

第三行输入一个整数M，表示有多少个选餐时间。

接下来M行，每行两个整数li, ri (1 <= li <= ri <= N)，含义如题面所示。

## 输出格式

输出M行，第i行表示第i个选择时间师姐可能达到的最大愉悦值D。

## 样例

### 样例输入 #1
```
5
1 2 3 4 5
2
2 3
2 4
```
### 样例输出 #1
```
2
1
```
### 样例输入 #2
```
5
2 4 8 16 32
2
3 4
2 3
```
### 样例输出 #2
```
16
8

```
## 提示

###样例解释

样例1里的第一个选餐时间，可以选择2和4，这样L师姐就可以每次吃两个寿司，使得两个盘子都可以吃干净，第二个选餐时间，师姐不管选哪两个盘子，都只能每次吃一个。

样例2 里的第一个选餐时间，可以选择16和32,而第二个选餐时间，L师姐可以选择8和16或者8和32。

对于20%的数据，N <= 100, M <= 100, max(a1,a2,…,aN) <= 100。

对于50%的数据，N <= 10000, M <= 10000, max(a1,a2,…,aN) <= 10000。

对于100%的数据，N <= 100000, M <= 100000, max(a1,a2,…,aN) <= 100000。



---

---
title: "[GDOI2014] 比特矩阵"
layout: "post"
diff: 省选/NOI-
pid: P3890
tag: ['2014', '各省省选', '广东']
---
# [GDOI2014] 比特矩阵
## 题目背景

你知道矩阵乘法吗？

对于两个 $n\times n$ 的矩阵 A 和 B， 假设 $a_{i, j}$ 表示位于矩阵 A 的第 $i$ 行第 $j$ 列的元素， 同样对于B可以定义类似的 $b_{i,j}$。 那么如果 $C = A \times B$，则有 $c_{i, j}=\sum_{k=1}^{n} a_{ik} \times b_{kj}$。 其中 $ \sum$ 是序列求和符号，例如 $\sum_{i=1}^{n} i$ 表示 $1 + 2 + \cdots + n$。

## 题目描述

由于霍比特人的大热， L 的室友 X 最近热衷于研究它们所使用的货币。为了进行研究，X 需要了解一种叫比特矩阵的东西。 虽然比特矩阵也是矩阵，但是它的乘法和一般的矩阵有点不一样。

对于比特矩阵 $C = A \times B$， 意味着 $c_{i,j} = V_{k=1}^{n}a_{ik} \bigoplus b_{kj}$。其中 $V$ 是序列求按位或的符号，例如 $V_{i=1}^{n} i$ 表示 $1 \mid 2 \mid \cdots \mid n$。 $\mid$ 就是按位或的意思。 按位或是指从二进制的角度看两个数， 如果第 $i$ 位上两个数至少一个是1的话那结果的第 $i$ 位就是1， 否则第 $i$ 位就是 $0$。 $\bigoplus$ 表示按位异或运算， 即如果两个二进制数的第$i$位是不相同的话那么结果的第 $i$ 位就是 $1$，否则就是 $0$。

举个比特矩阵相乘的例子:

$$\begin{bmatrix}1&6\\3&5\end{bmatrix}\times\begin{bmatrix}3&6\\5&7\end{bmatrix}=\begin{bmatrix}3&7\\0&7\end{bmatrix}$$

现在 X 想要拜托你帮他算 $A^{m}$，其中 $A$ 是一个 $n\times n$ 的比特矩阵， 而 $A^{m}$ 表示 $m$ 个 $ A$ 相乘的结果。严谨地说:

- $A^{1}=A$；
- $A^{m}=A^{m-1}\times A,\ m>1$。

## 输入格式

输入第一行包含两个正整数 $n,m$。

接下来 $n$ 行，每行包含 $n$ 个非负整数，这 $n$ 行中第 $i$ 行的第 $j$ 个数表示比特矩阵 $a_{i,j}$ 的元素 。

## 输出格式

根据输入，输出一个比特矩阵 $A^{m}$。即按照输入给出 $A$ 的方式输出一个比特矩阵。 具体参看样例输出。

## 样例

### 样例输入 #1
```
2 4
10 5
5 10

```
### 样例输出 #1
```
0 15
15 0

```
### 样例输入 #2
```
3 16
6 5 7
5 6 7
7 7 6

```
### 样例输出 #2
```
0 3 3
3 0 3
3 3 0

```
## 提示

### 数据范围及约定

- 对于 $10\%$ 的数据 $n\le 4$，$ m\le 10000$。
- 对于 $30\%$ 的数据 $n\le 10$，$ m\le 10^9$。
- 对于 $100\%$ 的数据 $n\le 500$，$ m\le 10^9$, 所有输入的整数不超过$10^9$。



---

---
title: "[GDOI2014] 传送"
layout: "post"
diff: 省选/NOI-
pid: P3894
tag: ['2014', '各省省选', '广东']
---
# [GDOI2014] 传送
## 题目描述

有 $n$ 个国家，编号分别为 $0$ 到 $n-1$。第 $i$ 个国家包含 $m_i$ 个城市，编号分别为 $0$ 到 $m_{i}-1$，其中编号为 $0$ 的城市是该国家的首都。为了表示的方便，我们用 $(i,j)$ 来表示第 $i$ 个国家的第 $j$ 个城市。同一个国家的城市之间有通路，这些通路构成一棵树，首都则是这棵树的根。而不同国家的城市之间没有通路，只能通过传送门。每个国家只有处于叶子节点的城市具有传送门，传送门的目的地可以是编号相邻的国家的任意一个处于叶子节点的城市，每次传送需要花费 $1$ 个单位时间，并且每个传送门只能使用一次。如下图所示，如果出发地是 $(0,2)$，目的地是 $(2,1)$，则 $(0,2)\rightarrow(1,1)\rightarrow(1,0)\rightarrow(1,2)\rightarrow(2,1)$ 是一条可行路径，而 $(0,2)\rightarrow(1,1)\rightarrow(2,1)$ 则是非法的，因为 $(1,1)$ 的传送门在 $(0,2)\rightarrow(1,1)$ 的时候被使用了一次，在 $(1,1)\rightarrow(2,1)$ 的时候又被使用了一次。

 ![](https://cdn.luogu.com.cn/upload/pic/6852.png) 

给定出发地和目的地，问最少需要多少时间。
## 输入格式

输入第一行有一个正整数 $n$。

接下来有 $n$ 个模块，每块描述一个国家的情况。每个模块的第一行是一个正整数 $m_i$，表示编号为 $i$ 的国家包含的城市个数，接下来 $m_{i}-1$ 行，每行包含三个整数 $u,v,t$，表示从城市 $u$ 到城市 $v$ 有通路，需要花费的时间为 $t (1 \leq t \leq 10^{3})$。

接下来一行有一个正整数 $q$，表示查询的个数。接下来 $q$ 行，每一行包含四个整数，$s_0,s_1,e_0,e_1$，其中，$(s_0,s_1)$ 为出发地，$(e_0,e_1)$ 为目的地。
## 输出格式

输出有 $q$ 行，每行只包含一个整数。如果能从出发地到达目的地，输出最少时间，否则，输出 $-1$。
## 样例

### 样例输入 #1
```
5
3
0 1 1
0 2 1
3
0 1 2
2 0 1
3
0 1 1
0 2 1
2
0 1 2
3
0 1 1
0 2 1
3
0 2 2 1
0 0 2 1
2 2 4 1

```
### 样例输出 #1
```
5
6
-1

```
## 提示

对于 $40\%$ 的数据，$n \leq 10,\sum m_i \leq 10^{3},q \leq 10$。

对于 $60\%$ 的数据，$n \leq 10^{3},\sum m_i \leq 10^{6}$。

对于 $100\%$ 的数据，$n \leq 3.5 \times 10^{5},\sum m_i \leq 10^{6},1 \leq t \leq 10^{3},q \leq 10^{5}$。


---

---
title: "[湖南集训] Clever Rabbit"
layout: "post"
diff: 省选/NOI-
pid: P3896
tag: ['湖南']
---
# [湖南集训] Clever Rabbit
## 题目描述

聪明的兔子定义了三个函数:

- $g(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位降序排列组成的数字。

- $l(x)$ 表示将 $x$ 十进制表示中各位数字从高位到低位升序排列组成的数字。

- $f(x)=g(x)-l(x)$。

如果一个数 $x$ 与 $f(x)$ 相等，兔子们称它为幸运数。现在兔子们希望计算在所有的 $n$ 位数字中，所有幸运数的平方的和。结果对 $p$ 取模后输出，注意这里数字可以包含前导 $0$。
## 输入格式

一行两个整数 $n,p$。
## 输出格式

一行一个整数，表示所求的结果。
## 样例

### 样例输入 #1
```
4 10000

```
### 样例输出 #1
```
8276
```
## 提示

#### 数据规模与约定
- 对于 $20\%$ 的测试数据，保证 $1\leq n\leq 10$。
- 对于 $100\%$ 的测试数据，保证 $1\leq n\leq 30$，$1\leq p\leq 2\times 10^9$。


---

---
title: "分组"
layout: "post"
diff: 省选/NOI-
pid: P3940
tag: ['2017', 'O2优化']
---
# 分组
## 题目背景

大样例可在页面底部「附件」中下载。

## 题目描述

小 C 在了解了她所需要的信息之后，让兔子们调整到了恰当的位置。小 C 准备给兔子 们分成若干个小组来喂恰当的胡萝卜给兔子们吃。

此时， $n$ 只兔子按一定顺序排成一排，第 $i$ 只兔子的颜色是 $a_i$ 。由于顺序已经是被 调整好了的，所以每个小组都应当是序列上连续的一段。

在分组前，小 C 发现了一个规律：有些兔子会两两发生矛盾。并且，两只兔子会发生矛 盾，当且仅当代表他们的颜色的数值之和为一个正整数的平方。比如，1 色兔子和 2 色兔子 不会发生矛盾，因为 3 不是任何一个正整数的平方；而 1 色兔子却会和 3 色兔子发生矛盾， 因为 $4 = 2^2$。

小 C 认为，只要一个小组内的矛盾不要过大就行。因此，小 C 定义了一个小组的矛盾 值 $k$ ，表示在这个小组里，至少需要将这个组再一次分成 $k$ 个小团体；每个小团体并不需 要是序列上连续的一段，但是需要使得每个小团体内任意两只兔子之间都不会发生矛盾。

小 C 要求，矛盾值最大的小组的矛盾值 $k$ 不超过 $K$ 就可以了。当然，这样的分组方 法可能会有很多个；为了使得分组变得更加和谐，小 C 想知道，在保证分组数量最少的情况 下，字典序最小的方案是什么。你能帮帮她吗？

字典序最小的方案是指，按顺序排列分组的间隔位置，即所有存在兔子 $i$ 和 $i + 1$ 在 不同组的位置 $i$，和其它所有相同分组组数相同的可行方案相比总有第一个不同的位置比其 它方案小的方案。

## 输入格式

从标准输入中读入数据。

输入第 1 行两个正整数 $n,K$。

输入第 2 行 $n$ 个正整数，第 $i$ 个数表示第 $i$ 只兔子的颜色 $a_i$。

## 输出格式

输出到标准输出中。

输出第 1 行一个正整数 $m$，为你至少需要将兔子分为多少个小组。

输出第 2 行$m-1$个从小到大的排列的正整数，第 $i$ 个数 $s_i$ 表示 $s_i$ 和 $s_i + 1$ 在 你的方案里被分到了两个小组。如果 $m = 1$，那么请输出一个空行。

## 样例

### 样例输入 #1
```
5 2 
1 3 15 10 6
```
### 样例输出 #1
```
2
1 
```
## 提示

【样例 1 解释】

如果将五只兔子全部分到同一个小组的话，那么 (1, 3) (3, 6) (6, 10) (10, 15) (1, 15) 均 不能分到同一个小团体；因为最多分成两个小团体，所以为了满足前 4 对限制，只能分为 {{1, 6, 15}, {3, 10}}，但此时不满足 (1, 15) ，所以不存在一种组数为 1 的方案满足全部限制。


如果将五只兔子分为两个小组的话，一种字典序最小的可行的分组方案是 {1}, {3, 15, 10, 6}，此时第二组内的小团体数量不超过 2 的一种分法是 {{3, 10}, {15, 6}}。

【数据范围】

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解 决一部分测试数据。

每个测试点的数据规模及特点如下表：

 
  ![](https://cdn.luogu.com.cn/upload/pic/9809.png) 

特殊性质 1：保证最优分组方案唯一。

特殊性质 2：保证不会有两只相同颜色的兔子。



---

---
title: "[TJOI2013] 数字根"
layout: "post"
diff: 省选/NOI-
pid: P3962
tag: ['2013', '各省省选', '天津']
---
# [TJOI2013] 数字根
## 题目描述

一个数字的数字根定义为:这个数字每一位的数字加起来求和,反复这个过程直到和小于10。例如,64357的数字跟为7,因为6+4+3+5+7=25,2+5=7个区间的数字根定义为这个区间所有数字和的数字根。

给定一个序列A1,A2,A3,…,An,你需要回答一些询问。每一个询问给定个区间[L,R],求出这个区间所有连续子区间里最大的前5个不同的数字根，不够5个的用-1补全

## 输入格式

第一行一个整数N,表示序列的长度。第二行是N个整数Ai(0≤Ai<10^9)。第三行是一个整数Q表示询问次数。接下来Q行,每一行两个正整数1,r,表示询问区间。(1≤l≤r≤N)

## 输出格式

Q行,表示每一个查询区间所有连续子区间里最大的前5个不同的数字根,按降序输出,输出用空格隔开。

## 样例

### 样例输入 #1
```
5
101 240 331 4 52
3
1 3
4 5
1 5
```
### 样例输出 #1
```
8 7 6 4 2
7 4 2 -1 -1
9 8 7 6 4
```
## 提示

### 样例解释

第一个查询区间[1,3],它的连续子区间有[1,1],[2,2],[3,3],[1,2],[2,3],[1,3].可对应的数字根分别为2,6,7,8,4,6。所以最大的5个是8,7,6,4,2。

### 数据范围

30%的数据，N ≤ 1000; Q ≤ 1000

100%的数据，N ≤ 100000; Q ≤ 100000



---

---
title: "[TJOI2014] Alice and Bob"
layout: "post"
diff: 省选/NOI-
pid: P3971
tag: ['2014', '各省省选', '天津']
---
# [TJOI2014] Alice and Bob
## 题目描述

Alice 和 Bob 发明了一个新的游戏。给定一个序列 $\{x_0,x_1,\cdots,x_{n-1}\}$，Alice 得到一个序列 $\{a_0,a_1,\cdots,a_{n-1}\}$，其中 $a_i$ 表示以 $x_i$ 结尾的最长上升子序列的长度；Bob 得到一个序列$\{b_0,b_1,\cdots,b_{n-1}\}$，其中 $b_i$ 表示以 $x_i$ 开头的最长下降子序列的长度。Alice 的得分是序列 $\{a_i\}$ 的和，Bob的得分是序列 $\{b_i\}$ 的和。

## 输入格式

输入的第一行是 $n$，第二行是序列 $\{a_0,a_1,\cdots,a_{n-1}\}$。数据保证序列 $\{a_i\}$ 可以由至少一个 $1$ 到 $n$ 的排列得到。
## 输出格式

输出包含一行,表示在序列 $\{a_i\}$ 给定的情况下 Bob 能得到的最高分数。
## 样例

### 样例输入 #1
```
4
1 2 2 3
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
4
1 1 2 3
```
### 样例输出 #2
```
5
```
## 提示

### 数据范围

对于 $30\%$ 的数据，$N \le 1000$。

对于 $100\%$ 的数据，$N \le 10^5$。



---

---
title: "[TJOI2014] 电影评分"
layout: "post"
diff: 省选/NOI-
pid: P3972
tag: ['2014', '各省省选', '天津']
---
# [TJOI2014] 电影评分
## 题目描述

小Z发明了一套新的电影评分系统。这套系统有三种操作:发布新电影、对电影评分、以及询问电影评分的排名。具体是这样运作的:如果是发布新电影,并且这部电影的有所主演之前均没有出现过,那么这部新电影的评分为0,否则这部电影的评分为**最近一部**与该电影**至少有一个共同主演**的电影的评分;如果是对电影进行评分,那么这部电影的评分就变成之前评分与新的评分的平均数;如果是查询排名,则根据评分输出相应排名。评分最高的为第一名。如果有多部电影分数相同,那么输出最早的一部。电影的评分在0到5之间。

## 输入格式

输入的第一行是n,表示操作次数。接下来n行,每一行是以下三种操作之一：

1. Q x:查询当前排名为x的电影ID

2. R ID x actor1 actor2 …· actorx:发布新电影ID,该电影有x个主演分别为 actor1, actor2,…’

3. C ID score:评分操作,表示对电影ID的评分为 score

数据保证每个电影的ID不相同,且每部电影至多不超过5名主演。

1≤ actor1, actor2,··≤10^5

1≤ID≤10^5

## 输出格式

对于每一个查询操作,输出相应排名的电影的ID。

## 样例

### 样例输入 #1
```
10 
R 1 1 1 
R 2 2 1 2 
C 2 2 
R 3 1 2 
Q 1 
C 3 2 
C 1 5 
Q 1 
Q 2 
Q 3
```
### 样例输出 #1
```
2 
1 
3 
2
```
## 提示

### 样例解释

| Movie | 1 | 2 | 3 | 
| :-: | :-: | :-: | :-: | :-: | :-: |
| | 0 | - | - |
| | 0 | 0 | - |
| | 0 | 1 | - |
| | 0 | 1 | 1 |
| Q 1 => 2 | //Movie 2 wa|s released be|fore Movie 3 |
| | 0 | 1 | 1.5 |
| | 2.5 | 1 | 1.5 |
| Q 1 => 1 |
| Q 2 => 3 |
| Q 3 => 2 |
### 数据范围

对于 30% 的数据，n ≤ 100

对于 100% 的数据，n ≤ 10000



---

---
title: "[SHOI2013] 阶乘字符串"
layout: "post"
diff: 省选/NOI-
pid: P3989
tag: ['2013', '各省省选', '上海']
---
# [SHOI2013] 阶乘字符串
## 题目背景

shoi2013d1t2

（本题卡常数注意）

## 题目描述

给定一个由前 $n$ 个小写字母组成的串 $S$。串 $S$ 是阶乘字符串当且仅当前 $n$ 个小写字母的全排列（共 $n!$ 种）都作为的子序列（可以不连续）出现。

由这个定义出发，可以得到一个简单的枚举法去验证，但是它实在太慢了。所以现在请你设计一个算法，在 $1$ 秒内判断出给定的串是否是阶乘字符串。
## 输入格式

输入第 $1$ 行一个整数 $T$，表示这个文件中会有 $T$ 组数据。

接下来分 $T$ 个块，每块 $2$ 行：

- 第 $1$ 行一个正整数 $n$，表示 $S$ 由前 $n$ 个小写字母组成。
- 第 $2$ 行一个字符串 $s$。
## 输出格式

对于每组数据，分别输出一行。每行是 `YES` 或者 `NO`，表示该数据对应的串 $S$ 是否是阶乘字符串。
## 样例

### 样例输入 #1
```
2
2
bbaa
2
aba
```
### 样例输出 #1
```
NO
YES
```
## 提示

第一组数据中，`ab` 这个串没有作为子序列出现。

![](https://cdn.luogu.com.cn/upload/image_hosting/9zs871wl.png)



---

---
title: "失败的竞猜游戏"
layout: "post"
diff: 省选/NOI-
pid: P3996
tag: ['O2优化']
---
# 失败的竞猜游戏
## 题目背景

大宁是一个喜欢赌博的人，最近在玩一款竞猜游戏，然而屡战屡败。大宁非常不高兴，就去找游戏的运营商理论，质疑游戏的数据是否有意针对玩家。

## 题目描述

游戏规则如下：玩家给出 $A_0$，$a$，$b$ 三个整数，代表一个线性递推式：

$A_i=a \times A_{i-1} +b$

它定义了一个无限长度的数列 {$A_1$，$A_2$，$A_3$……}，而游戏系统会随机生成一个数 $n$，如果 $n$ 可以表示为该数列中的若干个**互不相同**的项 ( $A_0$ 不计入数列中) 之和，那么玩家胜利，反之玩家失败。现在大宁通过逼迫运营商交出了一组最近的游戏数据，但是他懒得一个个去算了，现在请你帮忙计算一下，数据中玩家一共获胜了多少次。

## 输入格式

第一行一个正整数 $T$，表示进行了 $T$ 场游戏。

接下来 $T$ 行，每行四个整数，描述一场游戏，分别为题目中的 $A_0$，$a$，$b$，$n$。

## 输出格式

输出一行 $Ans$，表示玩家在 $T$ 场游戏中获胜的次数。

## 样例

### 样例输入 #1
```
7
3 1 5 16
10 1 0 5
2 1 0 3
2 1 0 10
3 1 5 59
1 2 0 998
0 1 0 0

```
### 样例输出 #1
```
4
```
## 提示

样例说明：

第 $1\sim 3$ 场游戏玩家失败，$4\sim 7$ 场游戏玩家胜利。

| 测试点编号 | 数据范围 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1\sim 2$ | $T=10$, $n\leq 10^3$ | $a=1$ |
| $3\sim 4$ | $T=10^3$, $n\leq 10^4$ | $a=2$ |
| $5$ | $T=10^4$, $n\leq 10^9$ | $a\leq 3$ |
| $6$ | $T=10^5$, $n\leq 10^9$ | $b=0$ |
| $7\sim 10$ | $T=2\times 10^5$, $n\leq10^9$ | 无 |
对于所有数据，$1\leq a\leq10$, $0 \leq b \leq 10^4$, $0\leq n \leq 10^9$, $0 \leq A_0 \leq 100$。

事实上这个游戏玩家的胜率微乎其微。



---

---
title: "[Code+#2] 寄蒜几盒"
layout: "post"
diff: 省选/NOI-
pid: P4034
tag: ['Code+']
---
# [Code+#2] 寄蒜几盒
## 题目背景

R姓出题人：第一次出CodePlus月赛，好紧脏，怎么才能装作经常出CodePlus月赛的样子？


某W姓出题人：写题面记得要加背景。


R姓出题人：可是我的题目没有什么背景可以写，怎么办？


某W姓出题人：其实背景和题面没有关系也是可以的。


R姓出题人：原来如此，那我知道了。

## 题目描述

在二维平面上有$n$条直线，这些直线会将平面划分成若干个区域。给定$m$个点，求每个点所在的区域的面积。


聪明的读者会发现有些点所在的区域面积是无穷大的。R姓出题人早就想到了这一点，所以他给出了一个实数$L$，由额外的四条直线$x=L,x=-L,y=L,y=-L$框定了一个有限的平面区域，并且所有的询问点都在这个框定的平面区域内部。


聪明绝顶的读者会发现如果询问点恰好落在某条直线上或者离某条直线的距离非常近，那么精度误差会严重影响答案。R姓出题人早就想到了这一点，所以在他造的数据中，任意一个询问点距离任意一条直线的距离大于$10^{-7}$。

## 输入格式

从标准输入读入数据。


第一行两个正整数$n,m$和一个正实数$L$。


接下来$n$行每行三个实数$A,B,C$，表示这条直线的方程为$Ax+By+C=0$


接下来$m$行，第$i$行两个实数$x_i,y_i$，表示第$i$个点的坐标。

## 输出格式

输出到标准输出。


输出$m$行，每行一个实数，第iii行输出的实数表示第$i$个点所在的区域的面积。保留两位小数。

## 样例

### 样例输入 #1
```
2 4 3
1 1 -1
-1 1 -1
0 2
-2 1
2 1
0 0
```
### 样例输出 #1
```
4.00
8.50
8.50
15.00
```
## 提示

对于$20\%$的数据，$n,m \le 10$。


对于$40\%$的数据，$n,m \le 300$。


对于$100\%$的数据，$n \le 500,m \le 100000$。


对于$100\%$的数据，输入数据的绝对值$ \le 10^7$，且输入数据最多保留两位小数。


来自 CodePlus 2017 12 月赛，清华大学计算机科学与技术系学生算法与竞赛协会 荣誉出品。

Credit：idea/茹逸中 命题/茹逸中 验题/陈宇，王聿中

Git Repo：https://git.thusaac.org/publish/CodePlus201712

感谢腾讯公司对此次比赛的支持。



---

---
title: "[AHOI2014/JSOI2014] 奇怪的计算器"
layout: "post"
diff: 省选/NOI-
pid: P4041
tag: ['2014', '各省省选', '江苏', '安徽']
---
# [AHOI2014/JSOI2014] 奇怪的计算器
## 题目背景

JYY 有个奇怪的计算器，有一天这个计算器坏了，JYY 希望你能帮助他写一个程序来模拟这个计算器的运算。
## 题目描述

JYY 的计算器可以执行 $N$ 条预设好的指令。每次 JYY 向计算器输入一个正整数 $X$，计算器就会以 $X$ 作为初始值，接着依次执行预设的 $N$ 条指令，最后把最终得出的结果返回给 JYY。

每一条指令可以是以下四种指令之一：（这里 $a$ 表示一个正整数。）

1. $+a$：表示将当前的结果加上 $a$；
2. $-a$：表示将当前的结果减去 $a$；
3. $\times a$：表示将当前的结果乘以 $a$；
4. $@a$：表示将当前的结果加上 $a\times X$（$X$ 是一开始 JYY 输入的数）。

计算器用于记录运算结果的变量的存储范围是有限的，所以每次运算结束之后会有计算结果溢出的问题。

JYY 的计算器中，存储每计算结果的变量只能存储 $L$ 到 $R$ 之间的正整数，如果一次指令执行过后，计算结果超过了 $R$，那么计算器就会自动把结果变成 $R$，然后再以 $R$ 作为当前结果继续进行之后的计算。同理，如果运算结果小于 $L$，计算器也会把结果变成 $L$，再接着计算。

比如，假设计算器可以存储 $1$ 到 $6$ 之间的值，如果当前的计算结果是 $2$，那么在执行 $+5$ 操作之后，存储结果的变量中的值将会是 $6$。虽然 $2+5$ 的实际结果是 $7$，但是由于 $7$ 超过了存储范围的上界，所以结果就被自动更正成了上界的大小，也就是 $6$。

JYY 一共想在计算器上输入 $Q$ 个值，他想知道这 $Q$ 个值输入计算器之后，分别会得到什么结果呢？
## 输入格式

第一行包含三个正整数，$N$，$L$ 和 $R$。

接下来 $N$ 行，每行一个指令，每个指令如题述，由一个字符和一个正整数组成，字符和正整数中间有一个空格隔开。

第 $N+2$ 行包含一个整数 $Q$，表示 JYY 希望输入的数的数量。

第接下来 $Q$ 行每行一个正整数，第 $k$ 个正整数 $X_k$ 表示 JYY 在第 $k$ 次输入的整数。
## 输出格式

输出 $Q$ 行每行一个正整数，第 $k$ 行的整数表示输入 $X_k$ 后，依次经过 $N$ 个指令进行计算所得到的结果。
## 样例

### 样例输入 #1
```
5 1 6
+ 5
- 3
* 2
- 7
@ 2
3
2
1
5
```
### 样例输出 #1
```
5
3
6
```
## 提示

### 样例解释

当 JYY 输入 $2$ 时，计算器会进行 $5$ 次运算，每一次运算之后得到的结果分别是 $6$（实际计算结果为 $7$ 但是超过了上界），$3,6,1$（实际结果为 $-1$ 但是低于了下界）和 $5$（由于一开始输入的是 $2$，所以这一次计算为 $1+2 \times 2$）。

### 数据范围及约定

对于所有测试数据，$1\le N$，$Q\le 10^5$，$1\le L\le X_k\le R\le 10^9$，$1\le a\le 10^9$。


---

---
title: "[AHOI2014/JSOI2014] 保龄球"
layout: "post"
diff: 省选/NOI-
pid: P4044
tag: ['2014', '各省省选', '江苏', '安徽']
---
# [AHOI2014/JSOI2014] 保龄球
## 题目背景

JYY 很喜欢打保龄球，虽然技术不高，但是还是总想着的高分。这里 JYY 将向你介绍他所参加的特殊保龄球比赛的规则，然后请你帮他得到尽量多的分数。

## 题目描述

一场保龄球比赛一共有 $n$ 个轮次，每一轮都会有十个木瓶放置在木板道的另一端。每一轮中，选手都有两次投球的机会来尝试击倒全部的十个木瓶。对于每一次投球机会，选手投球的得分等于这一次投球所击倒的木瓶数量。选手每一轮的得分是他两次机会击倒全部木瓶的数量。

对于每一个轮次，有如下三种情况：

1、 “全中”：如果选手第一次尝试就击倒了全部十个木瓶，那么这一轮就为“全中”。在一个“全中”轮中，由于所有木瓶在第一次尝试中都已经被击倒，所以选手不需要再进行第二次投球尝试。同时，在计算总分时，选手在下一轮的得分将会被乘2计入总分。

2、“补中”：如果选手使用两次尝试击倒了十个木瓶，那么这一轮就称为“补中”。同时，在计算总分时，选手在下一轮中的第一次尝试的得分将会以双倍计入总分。

3、“失误”：如果选手未能通过两次尝试击倒全部的木瓶，那么这一轮就被称为“失误”。同时，在计算总分时，选手在下一轮的得分会被计入总分，没有分数被翻倍。此外，如果第 $n$ 轮是“全中”，那么选手可以进行一次附加轮：也就是，如果第 $n$ 轮是“全中”，那么选手将一共进行 $n+1$ 轮比赛。显然，在这种情况下，第 $n+1$ 轮的分数一定会被加倍。

附加轮的规则只执行一次。也就是说，即使第 $n+1$ 轮选手又打出了“全中”，也不会进行第 $n+2$ 轮比赛。因而，附加轮的成绩不会使得其他轮的分数翻番。最后，选手的总得分就是附加轮规则执行过，并且分数按上述规则加倍后的每一轮分数之和。

JYY 刚刚进行了一场 $n$ 个轮次的保龄球比赛，但是，JYY非常不满意他的得分。JYY想出了一个办法：他可以把记分表上，他所打出的所有轮次的顺序重新排列，这样重新排列之后，由于翻倍规则的存在，JYY就可以得到更高的分数了！

当然了，JYY不希望做的太假，他希望保证重新排列之后，所需要进行的轮数和重排前所进行的轮数是一致的：比如如果重排前JYY在第 $n$ 轮打出了“全中”，那么重排之后，第 $n$ 轮还得是“全中”以保证比赛一共进行 $n+1$ 轮；同样的，如果 JYY 第 $n$ 轮没有打出“全中”，那么重排过后第 $n$ 轮也不能是全中。请你帮助 JYY 计算一下，他可以得到的最高的分数。

## 输入格式

第一行包含一个整数 $n$，表示保龄球比赛所需要进行的轮数。

接下来包含 $n$ 或 $n+1$ 行，第i行包含两个非负整数 $x_i,y_i$，表示 JYY 在这一轮两次投球尝试所得到的分数，$x_i$ 表示第一次尝试，$y_i$ 表示第二次尝试。

特别地，`10 0` 表示一轮“全中”。

读入数据存在 $n+1$ 行，当且仅当 $x_n=10$ 且 $y_n=0$。

## 输出格式

输出一行一个整数，表示 JYY 最大可能得到的分数。

## 样例

### 样例输入 #1
```
2
5 2
10 0
3 7
```
### 样例输出 #1
```
44
```
## 提示

【样例说明】  
按照输入顺序，JYY 将得到 $37$ 分。
最佳方案是排列成如下顺序：
```plain
3 7
10 0
5 2
```

【数据范围】
对于 $100\%$ 的数据，$1\le n \le 50$。



---

---
title: "[JXOI2017] 数列"
layout: "post"
diff: 省选/NOI-
pid: P4063
tag: ['2017', '各省省选']
---
# [JXOI2017] 数列
## 题目描述

九条可怜手上有一个长度为 $n$ 的整数数列 $r_i$，她现在想要构造一个长度为 $n$ 的，满足如下条件的整数数列 $A$ ：

- $1 \le A_i \le r_i$

- 对于任意 $3 \le i \le n$ ，令 $R$ 为 $A_1$ 至 $A_{i-2}$ 中大于等于 $A_{i-1}$ 的最小值，$L$ 为 $A_1$ 至 $A_{i-2}$ 中小于等于 $A_{i-1}$ 的最大值。$A_i$ 必须满足 $L \le A_i \le R$ 。如果不存在大于等于 $A_{i-1}$ 的，那么 $R=+\infty$ ；如果不存在小于等于 $A_{i-1} $ 的，那么 $L = -\infty$ 。

现在可怜想要知道共有多少不同的数列满足这个条件。两个数列 $A$ 和 $B$ 是不同的当且仅当至少存在一个位置 $i$ 满足 $A_i \neq B_i$ 。
## 输入格式

第一行输入一个整数 $n$ ，第二行输入 $n$ 个整数$ r_i$。
## 输出格式

输出一个整数表示方案数，答案可能很大，对 $998244353$ 取模后输出。
## 说明
满足条件的序列有 $[1, 1, 1], [1, 2, 1], [1, 2, 2], [2, 1, 1], [2, 1, 2], [2, 2, 2]$
## 样例

### 样例输入 #1
```
3
2 2 2
```
### 样例输出 #1
```
6
```
## 提示

| 测试点编号 | $n$ | $r_i$ |
| :----------: | :----------: | :----------: |
| $1,2$ | $n\le7$ | $r_i\le7$ |
| $3,4$ | $n\le50$ | $r_i\le10$ |
| $5,6$ | $n\le50$ | $r_i\le16$ |
| $7,8$ | $n\le50$ | $r_i\le50$ |
| $9,10$ | $n\le50$ | $r_i\le150$ |


---

---
title: "[SDOI2016] 储能表"
layout: "post"
diff: 省选/NOI-
pid: P4067
tag: ['2016', '各省省选', '山东']
---
# [SDOI2016] 储能表
## 题目描述

有一个 $n$ 行 $m$ 列的表格，**行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号**。每个格子都储存着能量。最初，第 $i$ 行第 $j$ 列的格子储存着 $(i \oplus j)$ 点能量（$\oplus$ 表示**按位异或**）。所以，整个表格储存的总能量是

$$\sum_{i=0}^{n-1} \sum_{j=0}^{m-1} i \oplus j$$

随着时间的推移，格子中的能量会渐渐减少。每经过一个时间单位，每个格子中的能量都会减少 $1$。显然，**一个格子的能量减少到 $0$ 之后就不会再减少了。**

也就是说，$k$ 个时间单位后，整个表格储存的总能量是

$$\sum_{i=0}^{n-1} \sum_{j=0}^{m-1} \max((i \oplus j)-k,0)$$

给出一个表格，求 $k$ 个时间单位后它储存的总能量。

由于总能量可能较大，输出时对 $p$ 取模。
## 输入格式

第一行一个整数 $T$，表示数据组数。接下来 $T$ 行，每行四个整数 $n,m,k,p$。

## 输出格式

共 $T$ 行，每行一个数，表示总能量对 $p$ 取模后的结果。

## 样例

### 样例输入 #1
```
3
2 2 0 100
3 3 0 100
3 3 1 100
```
### 样例输出 #1
```
2
12
6
```
## 提示

对于 $100\%$ 的数据，保证 $1\le T\le 5000$，$1\le p\le 10^9$，$1\le n,m,k\le 10^{18}$。

| 测试点编号 | $T=$ | $n\le$ | $m\le$ | $k\le$ | $p\le$ |
| :--: | :--: | :--: | :--: | :--: | :--: |
| $1,2$ | $5000$ | $100$ | $100$ | $100$ | $10^9$ |
| $3$ | $5000$ | $10^{18}$ | $10^{18}$ | $0$ | $10^9$ |
| $4$ | $5000$ | $10^{18}$ | $10^{18}$ | $1$ | $10^9$ |
| $5$ | $5000$ | $10$ | $10^{18}$ | $10$ | $10^9$ |
| $6$ | $1$ | $10^5$ | $10^{18}$ | $10^5$ | $10^9$ |
| $7$ | $1$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |
| $8$ | $100$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |
| $9,10$ | $5000$ | $10^{18}$ | $10^{18}$ | $10^{18}$ | $10^9$ |

$\texttt{Statement fixed by Starrykiller.}$


---

---
title: "[SDOI2016] 硬币游戏"
layout: "post"
diff: 省选/NOI-
pid: P4077
tag: ['2016', '各省省选', '山东']
---
# [SDOI2016] 硬币游戏
## 题目描述

Alice 和 Bob 现在在玩的游戏，主角是依次编号为 $1$ 到 $n$ 的 $n$ 枚硬币。每一枚硬币都有两面，我们分别称之为正面和反面。一开始的时候，有些硬币是正面向上的，有些是反面朝上的。Alice 和 Bob 将轮流对这些硬币进行翻转操作，且 Alice 总是先手。


具体来说每次玩家可以选择一枚编号为 $x$，要求这枚硬币此刻是反面朝上的。对于编号 $x$ 来说，我们总可以将 $x$ 写成 $ c\cdot 2^a \cdot 3^b$ ，其中 $a$ 和 $b$ 是非负整数，$c$ 是与 $2,3$ 都互质的非负整数，然后有两种选择：


选择整数 $p,q$ 满足 $a \ge pq , p \ge 1$ 且 $1 \leq q \leq \text{MAXQ}$，然后同时翻转所有编号为 $c \cdot 2^{a-pj} \cdot 3^b$  的硬币，其中 $j = 0, 1, 2, \ldots ,q$。

选择整数 $p,q$ 满足 $b \ge pq, p \ge 1$  且 $1 \leq q \leq \text{MAXQ}$，然后同时翻转所有编号为 $c \cdot 2^a \cdot 3^{b-pj}$ 的硬币，其中 $j = 0, 1, 2, \ldots, q$。

可以发现这个游戏不能无限进行下去，当某位玩家无法继续操作上述操作时，便输掉了游戏。作为先手的 Alice，总是希望可以在比赛开始之前就知道自己能否获胜。她知道自己和 Bob 都是充分聪明的，所以在游戏过程中，两人都会最优化自己的策略并尽量保证自己处于不败的情形中。

## 输入格式


本题有多组测试数据，第一行输入一个整数 $T$，表示总的数据组数。之后给出 $T$ 组数据。

每组数据第一行输入两个整数 $n,\text{MAXQ}$。

第二行输入 $n$ 个整数，第 $i$ 个数表示第 $i$ 个硬币的初始状态，$0$ 表示反面朝上，$1$ 表示正面朝上。
## 输出格式

输出共有 $T$ 行。对于每一组数据来说，如果 Alice 先手必胜，则输出 `win`，否则输出 `lose`。

## 样例

### 样例输入 #1
```
6
16 14
1 0 0 1 0 0 0 0 1 0 0 0 1 0 1 1
16 14
0 1 0 0 0 1 1 1 1 1 1 0 1 0 0 1
16 11
0 1 0 0 0 1 1 1 0 1 0 0 0 1 0 1
16 12
1 1 1 1 1 1 1 1 0 0 1 1 0 1 1 0
16 4
1 0 0 1 0 0 1 0 0 0 0 1 0 1 1 0
16 20
0 0 0 0 1 0 1 0 0 0 1 0 0 1 0 0
```
### 样例输出 #1
```
win
lose
win
lose
win
win
```
## 提示

对于 $100\%$ 的数据 $1\le n \le 30000,1 \le \text{MAXQ} \le 20,t\le 100$。



---

---
title: "[SDOI2016] 探险路线"
layout: "post"
diff: 省选/NOI-
pid: P4078
tag: ['2016', '各省省选', '山东']
---
# [SDOI2016] 探险路线
## 题目描述

你所面对的丛林，可以被刻画为n行m列的格点图，其中第i行第j列的格子代表了一块区域，每个格子有整数权值v(i,j)（可能为负），表明了访问这一块区域的收益或代价。每一个格子最多只能被访问一次，且不可走出地图的边界，你被要求从第一行第一列出发，到第n行第m列结束，你的目标是最大化途经的所有格子的权值和。

因为一些缘故，你的探险路线受到了一些限制。起初你在起点，之后每一天的行动中，首先你需要选择上下左右中的某一个方向，沿着这个方向走0步（也就是不走）或任意步；之后重新选择一个方向（可以与原来方向相同，也可以是不同的方向），沿着这个方向一直走下去，走到地图的某个边界位置结束这一天的探险。探险可以有任意多天，每一天探险结束的边界位置就是第二天的起点位置，除非这一天就是探险的结束。注意，因为每一块格子只能被访问一次，且你最终的结束点必须是第n行第m列的位置，所以你需要谨慎计划每一天的路线。

你希望知道最优方案下，整个探险之旅的收益有多大，即你可以获得的权值和最大是多少。

## 输入格式

第一行输入两个整数，分别表示总行数n与总列数m。之后n行，每行有m个整数，。其中第i行第j列的整数对应了访问第i行第j列区域的收益或代价。

## 输出格式

输出一个整数，表示最优探险路线中所有被访问格子的权值和。

## 样例

### 样例输入 #1
```
10 10
+1 +1 +1 +1 +1 -1 -1 -1 -1 -1
-1 -1 +1 +1 +1 -1 -1 -1 -1 -1
-1 -1 +1 +1 +1 +1 +1 +1 +1 +1
+1 +1 +1 +1 -1 -1 -1 -1 -1 +1
+1 -1 -1 +1 -1 -1 -1 -1 -1 +1
+1 +1 +1 +1 -1 -1 -1 -1 -1 +1
+1 +1 +1 +1 +1 +1 +1 +1 +1 +1
+1 -1 -1 -1 -1 -1 -1 -1 -1 -1
+1 +1 +1 +1 -1 +1 +1 +1 +1 +1
-1 -1 -1 +1 +1 +1 -1 -1 -1 +1
```
### 样例输出 #1
```
53
```
## 提示

对于所有数据3<=n<=800且3<=m<=800，保证收益代价绝对值在100000以内



---

---
title: "[JSOI2010] 挖宝藏"
layout: "post"
diff: 省选/NOI-
pid: P4164
tag: ['2010', '各省省选', '江苏']
---
# [JSOI2010] 挖宝藏
## 题目描述

JP 不好好训练，又喜欢上了另一个游戏——寻宝。

游戏里有 $n$ 处宝藏，它们被埋在一个无限大的二维网格中。每个宝藏都有价值 $P_i$，位置是 $(x_i,y_i)$。

如果网格 $(x,y)$ 满足下面两个条件之一，则它是可挖掘的：

- $y=-1$。

- $(x-1,y+1),(x,y+1),(x+1,y+1)$ 这三个方格都已经被挖掘了。

挖掘一个方格的代价为 $1$。当一个宝藏被挖掘出来时，就认为已经获得了它的价值。请你帮 JP 求出所能得到的最大利润，也即价值减代价。（可能一个宝藏也不挖，利润为 $0$）

## 输入格式

第一行为 $n$，表示宝藏数量。

接下来 $n$ 行，每行三个整数 $x_i,y_i,P_i$ 表示宝藏的位置和价值。
## 输出格式

一行一个整数，表示最大利润。
## 样例

### 样例输入 #1
```
5
1 -1 2
0 -1 2
4 -1 1
3 -1 2
2 -1 2
```
### 样例输出 #1
```
4
```
## 提示

### 样例解释 1

挖 $1,2,4,5$ 号宝藏，价值为 $8$，花费代价为 $4$，所以利润为 $4$。可以证明没有更优的方案。

### 数据范围

对于 $30\%$ 的数据，$n\leq 15$。

对于 $50\%$ 的数据，$-10^3\leq y_i\leq 0$。

对于 $100\%$ 的数据，$n\leq 10^3,-10^4\leq x_i\leq 10^4,-10^4\leq y_i<0,1\leq P_i\leq 10^6$。



---

---
title: "[HNOI2006] 花仙子的魔法"
layout: "post"
diff: 省选/NOI-
pid: P4176
tag: ['2006', '各省省选', '湖南']
---
# [HNOI2006] 花仙子的魔法
## 题目描述

相传，在天地初成的远古时代，世界上只有一种叫做“元”的花。接下来，出现了一位拥有魔法的花仙子，她能给花附加属性，从此，“元”便不断变异，产生了大千世界千奇百怪的各种各样的花。据说，花仙子既可存在于二维空间（平面），又可存在于三维空间（立体），还可存在于 $n$ 维空间（想象）。二维空间的点可用向量 $\left(x_1,x_2\right)$ 表示，三维空间的点可用向量 $\left(x_1,x_2,x_3\right)$ 表示，一般来说，$n$ 维空间的点可用向量 $\left(x_1,x_2,\cdots,x_n\right)$ 表示。而 $n$ 维空间中两点 $\left(x_1,x_2,\cdots,x_n\right)$ 与 $\left(w_1,w_2,\cdots,w_n\right)$ 之间的距离定义为$\sqrt{\sum_{i=1}^{n}(X_i-W_i)^2}$。 在 $n$ 维空间中，花仙子每实施魔法就要选择一个参考点 $\left(w_1,w_2,\cdots,w_n\right)$ 和一个作用半径 $r$，并且参考点的位置和作用半径的大小可以任意选择。这时，$n$ 维空间中所有与参考点 $\left(w_1,w_2,\cdots,w_n\right)$ 之间的距离小于作用半径 $r$ 的花都会受到这次魔法的影响。每次魔法都会给受到影响的花带来不同的属性，且的效 果可以叠加。一般来说，若花仙子总共实施了 $m$ 次魔法，则 $n$ 维空间中处于某点的花所具有的属性可用长度为 $m$ 的二进制串 $\left(a_1,a_2,\cdots,a_n\right)$ 来描述，其中对 $1\le i\le m$，若该花受到第 $i$ 次魔法的影响，则 $a_i$ 的值为 $1$,否则为 $0$。显然，不同的属性对应不同的花。 现在的问题是：花仙子在 $n$ 维空间中实施了 $m$ 次魔法后，最多能得到多少种不同的花？

## 输入格式

包含两个整数，并用一个空格隔开，第一个整数表示实施魔法的次数 $m$，第二个整数表示空间的维数 $n$。其中，$1\le m\le 100$，$1 \le n \le 15$。

## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
3 1
```
### 样例输出 #1
```
6
```


---

---
title: "数字"
layout: "post"
diff: 省选/NOI-
pid: P4193
tag: []
---
# 数字
## 题目描述

小 D 喜欢的数有这样的性质：
令 $n$ 为正整数，$S(n)$ 为 $n$ 的各位数字之和，令

$$D(n)\begin{cases}\displaystyle S(n), S(n)<10 \\\displaystyle D(S(n)), S(n)>10\end{cases}$$

小 D 喜欢的数一定能表示成 $x×D(x)$ 这种形式（即若一个数 A 是被喜欢的，则存在一个数 $x$，使得 $A=x\times D(x)$）。
小 D 想知道在区间 [L, R] 中，有多少个数是他喜欢的。
## 输入格式

第一行一个整数T，表示数据组数。

以下每一行两个数L、R（保证区间合法），代表询问[L, R]。

## 输出格式

输出T行，每行一个数，表示在这个区间内小D喜欢的数出现了多少次。

你的输出当且仅当和标准输出一样才能得该测试点满分。

## 样例

### 样例输入 #1
```
3
1 5
3 9
8 8
```
### 样例输出 #1
```
2
2
0
```
## 提示

L,R<=$10^18$,T<=20



---

---
title: "矩阵"
layout: "post"
diff: 省选/NOI-
pid: P4194
tag: []
---
# 矩阵
## 题目描述

给定一个整数矩阵 $A[n\times m]$，求一个矩阵 $B[n\times m]$，满足 $\forall 1\le i\le n,1\le j\le m,B_{i,j}\in[L,R]$，且使下式值最小：

$$\max\begin{cases}\displaystyle\max_{1\le j\le m}\left\{\left|\sum_{i=1}^n\left(A_{i,j}-B_{i,j}\right)\right|\right\}\\\displaystyle\max_{1\le i\le n}\left\{\left|\sum_{j=1}^m\left(A_{i,j}-B_{i,j}\right)\right|\right\}\end{cases}$$
## 输入格式

第一行两个整数 $n$，$m$，表示矩阵的大小。

接下来 $n$ 行，每行 $m$ 个整数，描述矩阵 $A$。

最后一行有两个整数 $L$，$R$。
## 输出格式

输出一行一个整数代表答案。
## 样例

### 样例输入 #1
```
2 2
0 1
2 1
0 1
```
### 样例输出 #1
```
1
```
## 提示

对于 $100\%$ 的数据满足 $n,m\le200$，$0\le L\le R\le1000$，$0\le A_{i,j}\le1000$。


---

---
title: "学习小组"
layout: "post"
diff: 省选/NOI-
pid: P4209
tag: []
---
# 学习小组
## 题目描述

共有 $n$ 个学生，$m$ 个学习小组，每个学生只愿意参加其中的一些学习小组，且一个学生最多参加 $k$ 个学习小组。每个学生参加学习小组财务处都收一定的手续费，不同的学习小组有不同的手续费。若有 $a$ 个学生参加第 $i$ 个学习小组，财务处支付奖励 $C_i \times a^2$ 元。在参与学生（而不是每个学习小组的人数总和）尽量多的情况下，求财务处最少要支出多少钱。
## 输入格式


输入有若干行，第一行有三个用空格隔开的正整数 $n,m,k$。

接下来的一行有 $m$ 个正整数，表示每个 $C_i$。

第三行有 $m$ 个正整数，表示参加每个学习小组需要交的手续费 $F_i$。

再接下来有一个 $n$ 行 $m$ 列的矩阵，表若第 $i$ 行 $j$ 列的数字是 $1$，则表示第 $i$ 个学生愿意参加第 $j$ 个学习小组，若为 $0$，则为不愿意。
## 输出格式

输出只有一个整数，为最小的支出。
## 样例

### 样例输入 #1
```
3 3 1
1 2 3
3 2 1
111
111
111
```
### 样例输出 #1
```
-2
```
## 提示

对于 $100\%$ 的数据，$0＜n\le 100，0＜m≤90，0＜k\le m，0＜C_i\le 10，0＜F_i\le 100。$


---

---
title: "[SHOI2008] 安全的航线"
layout: "post"
diff: 省选/NOI-
pid: P4286
tag: ['2008', '各省省选', '上海']
---
# [SHOI2008] 安全的航线
## 题目描述

在设计航线的时候，安全是一个很重要的问题。首先，最重要的是应采取一切措施确保飞行不会发生任何事故，但同时也需要做好最坏的打算，一旦事故发生，就要确保乘客有尽量高的生还几率。

当飞机迫降到海上的时候，最近的陆地就是一个关键的因素。航线中最危险的地方就是距离最近的陆地最远的地方，我们称这种点为这条航线“孤地点”。孤地点到最近陆地的距离被称为“孤地距离”。作为航空公司的高级顾问，你接受的第一个任务就是尽量找出一条航线的孤地点，并计算这条航线的孤地距离。

为了简化问题，我们认为地图是一个二维平面，陆地可以用多边形近似，飞行线路为一条折线。航线的起点和终点都在陆地上，但中间的转折点是可能在海上（如下图所示，方格标示出了孤地点）。

![](https://cdn.luogu.com.cn/upload/pic/15457.png)
## 输入格式

输入的第一行包括两个整数C和N（1≤C≤20，2≤N≤20），分别代表陆地的数目的航线的转折点的数目。

接下来有N行，每行有两个整数x,y。(x,y)表示一个航线转折点的坐标，第一个转折点为航线的起点，最后一个转折点为航线的终点。

接下来的输入将用来描述C块大陆。每块输入由一个正整数M开始（M≤30），M表示多边形的顶点个数，接下来的M行，每行会包含两个整数x,y，(x,y)表示多边形的一个顶点坐标，我们保证这些顶点以顺时针或逆时针给出了该多边形的闭包，不会出现某些边相交的情况。此外我们也保证输入数据中任何两块大陆不会相交。

输入的所有坐标将保证在-10,000到10,000的范围之间。
## 输出格式

输出一个浮点数，表示航线的孤地距离，数据保留2位小数。
## 样例

### 样例输入 #1
```
1 2
-9 -6
5 1
3
0 16
-16 -12
17 -6
```
### 样例输出 #1
```
0.00
```
### 样例输入 #2
```
2 3
12 4
16 17
3 9
4
1 0
4 19
19 14
6 12
3
10 10
5 3
18 2
```
### 样例输出 #2
```
2.94
```
## 提示

对于50%的数据，1≤C≤2，2≤N≤5;

对于100%的数据，1≤C≤20，2≤N≤20。


---

---
title: "[SHOI2014] 信号增幅仪"
layout: "post"
diff: 省选/NOI-
pid: P4288
tag: ['2014', '各省省选', '上海']
---
# [SHOI2014] 信号增幅仪
## 题目描述

无线网络基站在理想状况下有效信号覆盖范围是个圆形。而无线基站的功
耗与圆的半径的平方成正比。现给出平面上若干网络用户的位置，请你选择一
个合适的位置建设无线基站 ……

就在你拿起键盘准备开始敲代码的时候，你的好朋友发明家SHTSC 突然出
现了。SHTSC 刚刚完成了他的新发明——无线信号增幅仪。增幅仪能够在不增
加无线基站功耗的前提下，使得有效信号的覆盖范围在某一特定方向上伸长若
干倍。即：使用了增幅仪的无线基站覆盖范围是个椭圆，其功耗正比于半短轴
长的平方。

现给出平面上若干网络用户的位置，请你选择一个合适的位置建设无线基
站，并在增幅仪的帮助下使所有的用户都能接收到信号，且无线基站的功耗最
小。

注意：由于SHTSC 增幅仪的工作原理依赖地磁场，增幅的方向是恒定的。
## 输入格式

第一行一个整数：n。平面内的用户个数。之后的n 行每行两个整数x, y，表示一个用户的位置。

第n+2 行一个整数：a。表示增幅仪的增幅方向，单位是度。表示增幅仪的
方向是从x 正方向逆时针转a 度。

第n+3 行一个整数：p。表示增幅仪的放大倍数。
## 输出格式

输出一行一个实数，为能够覆盖所有用户的最小椭圆的半短轴长，四舍五入到三位小数。
## 样例

### 样例输入 #1
```
2
1 0
-1 0
0
2
```
### 样例输出 #1
```
0.500
```
### 样例输入 #2
```
3
1 1
-1 -1
0 0
45
7
```
### 样例输出 #2
```
0.202
```
## 提示

- 对于10%的数据，保证最优方案的中心在原点。
- 对于20%的数据，保证点是随机生成的。
- 对于30%的数据，n≤100。
- 对于50%的数据，n≤5000。
- 对于100%的数据，n≤50000，0≤a<180，1≤p≤100，|x|,|y|≤$2×10^8$。


---

---
title: "[AHOI2006] 上学路线"
layout: "post"
diff: 省选/NOI-
pid: P4300
tag: ['2006', '各省省选', '安徽']
---
# [AHOI2006] 上学路线
## 题目描述

可可和卡卡家住 HF 市的东郊，每天上学他们都要转车多次才能到达市区西端的学校。直到有一天他们两人参加了学校的信息学奥林匹克竞赛小组才发现每天上学的乘车路线不一定是最优的。

可可：“很可能我们在上学的路途上浪费了大量的时间，让我们写一个程序来计算上学需要的最少时间吧！”

HF 市一共设有 $N$ 个公交车站，不妨将它们编号为 $1\sim N$ 的自然数，并认为可可和卡卡家住在 $1$ 号汽车站附近，而他们学校在 $N$ 号汽车站。市内有 $M$ 条直达汽车路线，执行第 $i$ 条路线的公交车往返于站点 $p_i$ 和 $q_i$ 之间，从起点到终点需要花费的时间为 $t_i$（$1\leq i\leq M$，$1\leq p_i,q_i\leq N$）。

两个人坐在电脑前，根据上面的信息很快就编程算出了最优的乘车方案。然而可可忽然有了一个鬼点子，他想趁卡卡不备，在卡卡的输入数据中删去一些路线，从而让卡卡的程序得出的答案大于实际的最短时间。而对于每一条路线 $i$ 事实上都有一个代价 $c_i$：删去路线的 $c_i$ 越大卡卡就越容易发现这个玩笑，可可想知道什么样的删除方案可以达到他的目的而让被删除的公交车路线 $c_i$ 之和最小。

编写一个程序：
-  从输入文件中读取 HF 市公交路线的信息；
-  计算出实际上可可和卡卡上学需要花费的最少时间；
-  帮助可可设计一个方案，删除输入信息中的一些公交路线，使得删除后从家到学校需要的最少时间变大，而被删除路线的 $c_i$ 和最小；
- 向输出文件输出答案。
## 输入格式

输入文件中第一行有两个正整数 $N$ 和 $M$，分别表示 HF 市公交车站和公交汽车路线的个数。

以下 $M$ 行，每行（第 $i$ 行，总第 $(i+1)$ 行）用四个正整数描述第 $i$ 条路线：$p_i,q_i,t_i,c_i$，具体含义见上文描述。
## 输出格式

第一行中仅有一个整数，表示从可可和卡卡家到学校需要的最短时间。 

第二行输出一个整数 $C$，表示 $c_i$ 之和。
## 样例

### 样例输入 #1
```
6 7 
1 2 1 3 
2 6 1 5 
1 3 1 1 
3 4 1 1 
4 6 1 1 
5 6 1 2 
1 5 1 4
```
### 样例输出 #1
```
2
5

```
## 提示

$2\leq N\leq 500$，$1\leq M\leq 124750$，$1\leq t_i,c_i\leq 10^4$。

HF 市的公交网络十分发达，你可以认为任意两个车站间都可以通过直达或转车互相到达，当然如果在你提供的删除方案中，家和学校无法互相到达，那么则认为上学需要的最短为正无穷大：这显然是一个合法的方案。


---

---
title: "[JSOI2010] 游戏"
layout: "post"
diff: 省选/NOI-
pid: P4333
tag: ['2010', '各省省选', '江苏']
---
# [JSOI2010] 游戏
## 题目描述

JSOI 集训队的小 L，小 H，小 X 在紧张的训练之余，总是喜欢玩一个称之为“取数”的游戏来调节自己：

这是一个人玩的游戏，仅仅需要一张白纸和一支笔。玩家在纸上随机写下一行共 $n$ 个整数，形成一个数列，就可以开始游戏了。

每次玩家从原数列最左端或最右端选择一个数，将它从原数列中划去，并写在下一行。当原数列的数全部被划去后，在第二行就出现了一个新的长度为 $n$ 的数列，记为 $S$。将按照如下方式计算数列 $S$ 的分数 $P$：

$$P=S_1\times 5^0+S_2\times 5^1+\cdots+S_n\times 5^{n-1}$$

算出分数 $P$ 后，将其转为二进制表示，如果末三位数字是  $011$ 的话，玩家就取得了游戏的胜利，否则就失败了。

在玩了很多次这个游戏后，小 L，小 H，小 X 发现一个重要的事实：对于某些随机写下的数列，是无论如何也无法取得游戏胜利的，这样的数列被称为“刁列”，其它的数列则被
称为“良列”。

这个游戏虽然趣味性极强，但有一个弊端：每次游戏前需要花很多时间来写出这个随机数列，这一点一直深深困扰着小 L，小 H 和小 X。

直到在今年省选前的那天晚上，小 L 想出了一个惊为天人的创意，一举攻克了这个难题：他们先在纸上画出一颗庞大的无根树（共 $m$ 个结点），每个结点上写下一个整数。当想要玩游戏时，玩家只需随便选择两个结点，通过找出连接这两个结点的那条唯一的路径，将路径上所有结点（包括两个端点）上标注的整数按路径的顺序列出来，就得到了一个数列，然后就可以在这个数列上玩游戏了。如果选择的两个端点分别是树上结点 $v_i$ 和结点 $v_j$，得到的数列就简记为 $i\sim j$。当然，如前所述，$i\sim j$ 这个数列也有“良列”和“刁列”两种可能。

他们发现这样改进以后真的方便了很多！不仅如此，还给游戏带来了一些新的趣味。比如小 X 就声称他发现了一个重要的规律：数列的属性是具有传递性的，即：对于任意互不相同的 $i,j,k$ 有：

- 如果 $i\sim j$ 是良列，$j\sim k$ 是良列，则 $i\sim k$ 是良列。

- 如果 $i\sim j$ 是刁列或 $j\sim k$ 是刁列，则 $i\sim k$ 是刁列。

这个结论出奇地优美，但很快就被小 H 找到了反例，这让小 X 心情沮丧。小 L 为了安慰小 X，说：不如我们来看看你这个结论在多少情况下是成立的吧。

小 X 振作了起来，大家一起投入了繁重的工作中。他们要找出存在多少个三元组 $(i,j,k)$，其中 $i<j<k$，使得 $i,j,k$ 满足小 X 发现的传递性结论。

## 输入格式

第一行一个整数 $m$，代表无根树的节点个数。

接下来 $m$ 行，每行两个整数 $f_i,x_i$，其中 $f_i<i$。$f_i$ 表示节点 $v_i$ 的父节点编号，如果 $f_i=0$ 则该节点为根，$x_i$ 表示节点 $v_i$ 上写的数。
## 输出格式

一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
3
0 3
1 5
1 7
```
### 样例输出 #1
```
0
```
### 样例输入 #2
```
5
0 8626
1 29255
2 21486
2 26193
1 22439
```
### 样例输出 #2
```
7
```
## 提示

### 数据范围

对于 $10\%$ 的数据，$1\leq m\leq 5$。

对于 $30\%$ 的数据，$1\leq m\leq 100$。

对于 $50\%$ 的数据，$1\leq m\leq 10^3$。

对于 $100\%$ 的数据，$1\leq m\leq 10^5$。


---

---
title: "[CERC2015] Book Borders"
layout: "post"
diff: 省选/NOI-
pid: P4347
tag: ['2015']
---
# [CERC2015] Book Borders
## 题目背景

A book is being typeset using a fixed width font and a simple greedy algorithm to fill each line. The
book contents is just a sequence of words, where each word contains one or more characters.
## 题目描述

Before typesetting, we choose a maximum line length and denote this value with m. Each line can be at most m characters long including the space characters between the words. The typesetting algorithm simply processes words one by one and prints each word with exactly one space character between two consecutive words on the same line. If printing the word on the current line would exceed the maximum line length m, a new line is started instead.

![](https://cdn.luogu.com.cn/upload/pic/16228.png)

You are given a text to be typeset and are experimenting with different values of the maximum line length m. For a fixed m, the leading sentence is a sentence (a sequence of words separated with a single space character) formed by the first words of lines top to bottom. In the example above, when the sample text is typeset with the maximum line length 14, the leading sentence is “its to you n”.

Given a text and two integers a and b, find the length of the leading sentence for every candidate maximum line length between a and b inclusive. The length of a sentence is the total number of characters it contains including the space characters.
## 输入格式

The first line contains the text to be typeset – a sequence of words separated by exactly one space character. Each word is a string consisting of one or more lowercase letters from the English alphabet.

The second line contains two integers a and b – the edges of the interval we are interested in, as described above.

It is guaranteed that $1<=w<=a<=b<=z<=500 000$, where w is the length of the longest word in the text and z is the total number of characters in the text including the space characters.
## 输出格式

Output $b - a + 1$ lines – the $k$-th of those lines should contain a single integer – the total length of the leading sentence when the maximum line length is equal to $a - 1 + k$.
## 样例

### 样例输入 #1
```
its a long way to the top if you wanna rock n roll
13 16
```
### 样例输出 #1
```
22
12
12
15
```
## 提示

Central Europe Regional Contest 2015
Problem B
## 题目翻译



现有一本书,用固定宽度的字体和简单的贪婪算法来填充每行文字。书的内容是一个单词序列，每个单词包含一个或多个字符。



排版前，我们选择一个最大的行长度，并用m表示这个值。每行最多可以有m个字符，包括单词之间的空格字符。请使用排版算法简单地逐个处理单词，并在同一行上的两个连续单词之间打印每个单词，每个单词只有一个空格字符。而且如果在当前行上打印该字超过最大行长度m，则开始新行。

![](https://cdn.luogu.org/upload/pic/16228.png)

现在你得到了一个要排版的文本，并且正在试验最大行长度m的不同值。对于固定m，前导句是一个句子(由一个空格字符分隔的一系列单词)，由行的第一个单词从上到下组成。在上例中，当样本文本以最大行长度14进行排版时，前导句是“对你来说是n”（its to you n）

给定一个文本和两个整数a和b，找出a和b之间每个候选最大行长度的前导句长度。句子的长度是它包含的字符总数，包括空格字符



**输入格式：**

第一行包含要排版的文本——由一个空格字符分隔的一系列单词。每个单词都是一个字符串，由英语字母表中的一个或多个小写字母组成。 第二行包含两个整数a和b——如上所述的区间边缘。保证1<=w <=a<=b<=z<=50000,

其中w是文本中最长单词的长度，z是文本中包括空格字符的字符总数。



**输出格式**

输出b-a+1行——这些行的第k行应该包含一个整数——最大行长度等于a-1+k时前导句的总长度。



**输入输出样例**



输入样例#1

```

its a long way to the top if you wanna rock n roll

13 16

```

输出样例#1

```

22

12

12

15

```


---

---
title: "[CERC2015] Export Estimate"
layout: "post"
diff: 省选/NOI-
pid: P4350
tag: ['2015']
---
# [CERC2015] Export Estimate
## 题目背景

Luka owns a geographic data company that maintains a detailed city map and exports the data to interested parties. Often, clients do not want the complete map. Instead, they want a simpliﬁed map containing only major streets. 
## 题目描述

City map is an undirected graph consisting of n intersections denoted with integers from 1 to n and m two-way streets. Each street is assigned a priority – a non-negative integer. When requesting a map, the client selects a threshold priority p. The original map is then copied and converted to the exported map using the following procedure:

1. All streets whose priority is lower than p are deleted. 

2. For each intersection i from 1,2,...,n (processed in that order): 

(a) If the intersection i is not connected to any streets it is deleted. 

(b) If the intersection i is connected to exactly two different streets x and y leading to intersections a and b both different from i then the intersection i is contracted using the following procedure: 

i. Streets x and y are deleted. 

ii. Intersection i is deleted. 

iii. New street z connecting intersections a and b is added.

![](https://cdn.luogu.com.cn/upload/pic/16236.png )

Initially, the map does not contain loops (loop is a street that connects an intersection to itself) or parallel edges (more than one street between the same pair of intersections), but the loops and parallel edges may form during the contraction procedure. Notice that, in the step 2. (b) above, neither x nor y can be a loop (both a and b have to be different from i), but the newly added street z could be a loop (it is possible that a and b are same). 

Given a map and a sequence of incoming export requests, for each request ﬁnd the number of intersections and the number of streets in the exported map.
## 输入格式

The ﬁrst line contains two integers n (1 ≤ n ≤ 300000) and m (1 ≤ m ≤ 300000) – the number of intersections and the number of streets, respectively. Each of the following m lines contains three integers a, b and p (1≤ a,b≤n,0≤ p≤300000) which describe a street with priority p connecting intersections a and b. No street connects an intersection to itself. There is at most one street between every two intersections. 

The following line contains an integer q (1 ≤ q ≤ 300000) – the number of export requests. The following line contains q integers. The k-th integer tk (0≤tk ≤300000) is the threshold priority of the k-th request.
## 输出格式

Output should consist of q lines. The k-th line should contain two integers–the number of intersections and the number of streets, respectively, in the exported map for the k-th request.
## 样例

### 样例输入 #1
```
6 7 
1 2 20 
2 3 80 
2 5 100 
3 5 50 
3 4 100 
5 6 90 
4 6 100 
4 
25 75 85 95
```
### 样例输出 #1
```
2 3 
1 1 
2 1 
4 2

```
### 样例输入 #2
```
10 14 
2 7 150 
1 2 100 
2 3 150 
3 1 200 
1 4 60 
4 5 20 
2 5 100 
5 6 90 
6 7 120 
7 5 130 
6 8 50 
8 9 200 
9 10 200 
10 7 200 
5 
300 50 95 100 110
```
### 样例输出 #2
```
0 0 
6 9 
4 5 
4 5 
5 4
```
## 提示

Central Europe Regional Contest 2015 Problem E
## 题目翻译

#### 题意翻译：

Luka 拥有一个地理数据公司保持着详细的城市地图和出口相关的数据。但是通常客户不想要完整的地图。相反，他们更想要一个只包含主要街道的简单地图：

1. 所有优先级小于 $p$ 的街道被删除

1. 对于每一个路口点 $i$ 从 $1$ 到 $n$（按照这个顺序处理）：

   (a)如果这个路口没有连接到任何街道，它就会被删除。

   (b)如果路口 $i$ 正好连接到两个不同的街道 $x$ 和 $y$，导致 $a$ 和 $b$ 两个路口都与路口 $i$ 不同，那么 $i$ 就会根据下面的过程进行收缩：

   i.删除道路 $x$ 和道路 $y$；

   ii.删除路口 $i$；

   iii.加入一个连接路口 $a$ 和 $b$ 的新道路 $z$；

最初，图中没有环（即一条连接到自身的边）或者平行的边（即在同一对交点之间有一条以上的边），但在收缩的过程中可能会形成环和平行边。

请注意，在步骤2.（b）之前，$x$ 和 $y$ 都不能是环（即 $a$ 和 $b$ 必须和 $i$ 不同），但是新增的 $z$ 可以是一个环（即 $a$ 和 $b$ 可能是相同的）。

给定一个地图和一系列的出口的询问,每个询问找到路口的数量和街道地图出口的数量。

#### 输入格式：
第一行包含两个整数 $n(1 \le n\le3\times10^5)$ 和 $m(1\le m\le 3\times10^5)$ 分别是点和边的数量。

后面 $m$ 行包含三个整数分别是 $a,b$ 和 $p(1\le a,b \le n,0\le p\le 3\times10^5)$ 用来描述 $a,b$ 之间边的优先级 $p$，没有一条边只连接一个点，两个点之间最多有一条边。

第 $m+2$ 行包含一个整数 $q(1\le q\le 3\times10^5)$ 表示询问的个数，下一行有 $q$ 个整数，第 $k$ 个整数 $t_k(0\le tk\le 3\times10^5)$ 是第 $k$ 次询问的优先级。

#### 输出格式：
输出包括 $q$ 行。第 $k$ 行包含两个整数，分别是第 $k$ 次询问的点和边的个数。


---

---
title: "[CERC2015] Frightful Formula"
layout: "post"
diff: 省选/NOI-
pid: P4351
tag: ['2015']
---
# [CERC2015] Frightful Formula
## 题目描述

A frightful matrix is a square matrix of order n where the ﬁrst row and the ﬁrst column are explicitly speciﬁed, while the other elements are calculated using a frightful formula which is, actually, a simple recursive rule. 

Given two integer sequences l and t,both of size n,as well as integer parameters a,b and c,the frightful matrix F is deﬁned as follows:

* The ﬁrst column of the matrix is the sequence l: 

$$F[k, 1] = lk$$ 

* The ﬁrst row of the matrix is the sequence t: 

$$F[1, k] = tk$$ 

* Other elements are calculated using a recursive formula: 

$$F[i,j]=a*F[i,j-1]+b*F[i-1,j]+c$$

Given a frightful matrix, ﬁnd the value of the element $F[n,n]$ modulo $10^6 +3$.
## 输入格式

The ﬁrst line contains four integers n, a, b and c (2≤n≤200000, 0≤ a, b, c≤$10^6$) – the size of the matrix and the recursion parameters, as described in the problem statement. 

The two following lines contain integers l1,...,ln and t1,...,tn, respectively (l1 = t1, 0≤lk, tk ≤106). 
## 输出格式

Output a single integer – the value of $F[n,n]$ modulo $10^6 +3$.
## 样例

### 样例输入 #1
```
3 0 0 0 
0 0 2 
0 3 0
```
### 样例输出 #1
```
0
```
### 样例输入 #2
```
4 3 5 2 
7 1 4 3 
7 4 4 8
```
### 样例输出 #2
```
41817
```
## 提示

Central Europe Regional Contest 2015 Problem F
## 题目翻译


定义一个矩阵 $F$，其中第一行和第一列是给定的，计算矩阵方法如下：

矩阵的第一列是序列  $l$：

 $F[k,1]=$  $l _ k$

矩阵的第一行是序列  $t$：

 $F[1,k]=$  $t _ k$

其他元素使用给定的递归公式进行计算：

$F[i,j]=a \times F[i,j-1]+b \times F[i-1,j]+c$。

现在要求找求出 $F[n,n]$ 模 $10^6+3$ 的值。

输入输出格式。

输入格式：

第一行包含四个整数 $n$，$a$，$b$ 和 $c(2 \le n \le 200000,0 \le a,b$，$c \le 10^6)$ 矩阵的大小和递归参数，如问题描述中所述。

下面两行分别包含整数 $l_1, \cdots ,l_n$ 和 $t_1, \cdots ,t_n(l_1=t_1,0 \le lk,tk \le 10^6)$。

输出格式：

输出一个整数的值即 $F[n,n]$ 模 $10^6+3$。

感谢 @ 守望提供的翻译。



---

---
title: "[CERC2015] Hovering Hornet"
layout: "post"
diff: 省选/NOI-
pid: P4353
tag: ['2015', 'Special Judge']
---
# [CERC2015] Hovering Hornet
## 题目描述

You have managed to trap a hornet inside a box lying on the top of your dining table. Unfortunately, your playing dice is also trapped inside – you cannot retrieve it and continue your game of Monopoly without risking the hornet’s wrath. Instead, you pass your time calculating the expected number of spots on the dice visible to the hornet. 

The hornet, the dice and the box are located in the standard three-dimensional coordinate system with the x coordinate growing eastwards, the y coordinate growing northwards and the z coordinate growing upwards. The surface of the table corresponds to the x-y plane.

![](https://cdn.luogu.com.cn/upload/pic/16240.png )

The dice is a 1×1×1 cube, resting on the table with the center of the bottom side exactly in the origin. Hence,the coordinates of its two opposite cornersare (−0.5, −0.5, 0) and (0.5, 0.5, 1). The top side of  the dice has 5 spots, the south side 1 spot, the east side 3 spots, the north side 6 spots, the west side 4 spots and the (invisible and irrelevant) bottom side 2 spots. 

The box is a 5×5×5 cube also resting on the table with the dice in its interior. The box is speciﬁed by giving the coordinates of its bottom side – a 5×5 square. 

Assume the hornet is hovering at a uniformly random point in the (continuous) space inside the box not occupied by the dice. Calculate the expected number of spots visible by the hornet. The dice is opaque and, hence, the hornet sees a spot only if the segment connecting the center of the spot and the location of the hornet does not intersect the interior of the dice.
## 输入格式

Input consists of 4 lines. The k-th line contains two ﬂoating-point numbers xk and yk (−5≤ xk, yk ≤5) –coordinates of the k-th corner of the bottom side of the box in the x-y plane. The coordinates are given in the counterclockwise direction and they describe a square with the side length of exactly 5. 

The box fully contains the dice. The surfaces of the box and the dice do not intersect or touch except along the bottom sides.
## 输出格式

Output a single ﬂoating point number – the expected number of spots visible. The solution will be accepted if the absolute or the relative difference from the judges solution is less than $10^{−6}$.
## 样例

### 样例输入 #1
```
-2.5 -1.5 
2.5 -1.5 
2.5 3.5 
-2.5 3.5
```
### 样例输出 #1
```
10.6854838710
```
### 样例输入 #2
```
3 0 
0 4 
-4 1 
-1 -3
```
### 样例输出 #2
```
10.1226478495
```
## 提示

Central Europe Regional Contest 2015 Problem H
## 题目翻译

你把一只蜜蜂困在你餐桌上的一个盒子里。但是，你玩的骰子也被困在里面（你无法取回它）不过，你通过计算蜜蜂可以看到的骰子上的预期点数来消磨时间。

蜜蜂、骰子和盒子位于一个三维坐标系中，x-y轴如图

骰子是一个1×1×1的立方体，放在桌子上，底部的中心为原点。因此，其两个相对角的坐标为(−0.5, −0.5,0）和（0.5,0.5,1）。骰子顶部有5个点，南侧1个点，东侧3个点，北侧6个点，西侧4个点，底部2个点（不可见和不相关）。

盒子是一个5×5×5的立方体，也放在桌子上，里面有骰子。该框通过给出其底部的坐标（一个5×5的正方形）来指定。

假设蜜蜂在盒子内没有骰子的（连续）空间中的一个均匀随机点上盘旋。计算蜜蜂可以看到的点数的数量。骰子是不透明的，因此，只有当连接点数中心和蜜蜂位置的部分不与骰子内部相交时，蜜蜂才能看到斑点。

输入格式：
输入由4行组成。第k行包含两个浮点数xk和yk(−5<=xk，yk<=5）x-y平面中长方体底部第k个角的坐标。坐标以逆时针方向给出，它们描述了边长正好为5的正方形。
盒子和骰子的表面不相交或接触，除非放在底部。
输出格式：
输出一个数——预期可见点数
（样例如下）


---

---
title: "[CERC2015] Ice Igloos"
layout: "post"
diff: 省选/NOI-
pid: P4354
tag: ['2015']
---
# [CERC2015] Ice Igloos
## 题目描述

A ﬁshing village built on the surface of a frozen lake far north in the arctic is endangered by global warming-fractures are starting to form on the lake surface. The village consists of n igloos of spherical shape, each occupying a circular area of the surface. 

An igloo can be represented as a circle in the coordinate plane: the center of the circle is a point with integer coordinates, while the radius is a positive ﬂoating-point number less than 1 with exactly one fractional digit. 

Given the locations of possible ice fractures, the villagers would like to know how many igloos are affected by each. Formally, given q queries where each query is a straight line segment deﬁned by the two endpoints, ﬁnd the number of igloos each segment intersects. A segment intersects an igloo if it has at least one point in common with the interior of the circle.
## 输入格式

The ﬁrst line contains an integer n (1≤n≤100000) - the number of igloos. Each of the following n lines contains three numbers x, y and r – the coordinates of the center and the radius of one igloo. The coordinates x and y are integers such that 1≤ x, y≤500, while r is a ﬂoating-point number with exactly one fractional digit such that 0 < r < 1. No two igloos will intersect or touch. 

The following line contains an integer q (1 ≤ q ≤ 100000) - the number of queries. Each of the following q linescontainsfourintegers x1, y1, x2, y2 (1≤ x1, y1, x2, y2 ≤500)-thecoordinatesofthe two endpoints of the segment. The two endpoints will be different. Endpoints may be inside igloos. 

You may assume that, for every igloo i and the segment s, the square of the distance between s and the center of i is either less than r2−10−5 or greater than r2 +10−5 where r is the radius of the igloo i. 
## 输出格式

Output should consist of q lines. The k-th line should contain a single integer – the number of igloos that are intersected by the k-th segment.
## 样例

### 样例输入 #1
```
5 
4 2 0.6 
7 3 0.7 
8 5 0.8 
1 3 0.7 
3 4 0.4 
2 
3 1 9 6 
3 4 7 2
```
### 样例输出 #1
```
2
1
```
## 提示

![](https://cdn.luogu.com.cn/upload/pic/16243.png )

Central Europe Regional Contest 2015 Problem I
## 题目翻译

给你$n$个圆$,m$条线段$,$求每条线段与多少圆相交

$n,m\le10^5,1\le x_i,y_i\le500,0\lt r_i\lt 1$ 

## 输入输出格式

### 输入格式

第一行一个整数$n$表示圆的个数

接下来$n$行每行两个整数$x,y$和一个实数$r$表示圆心坐标和半径

第$n+2$行一个整数$m$表示线段个数

接下来$m$行每行四个整数$x1,y1,x2,y2$表示线段的两个端点$(x1,y1),(x2,y2)$

### 输出格式

$m$行每行一个整数表示该条线段和多少圆相交


感谢@Kelin 提供的翻译




---

---
title: "[Code+#4] 白金元首与七彩魔法"
layout: "post"
diff: 省选/NOI-
pid: P4371
tag: ['Code+']
---
# [Code+#4] 白金元首与七彩魔法
## 题目背景

小朋友 你们好吗　还能记得 我是谁吗　我就是魔法元首まどか！
## 题目描述

「和我签订契约，成为魔法元首吧！」

于是这天元首不明所以地被地外生物 Kyubey 忽悠去成为了魔法元首。不过在开始练习魔法之前，元首需要为自己的魔法选择一个代表色。

下图是一个明度最大（即，HSV 色彩空间中 $V = 100\%$）的单位圆色盘。色盘上任意一点的坐标为一个非负实数对 (α°,$r\%$) $(0 \leq \alpha < 360,0 \leq r \leq 100)$，表示色相为 α°、饱和度为 $r\%$ 的颜色。另一种理解是，α° 表示从联结圆心和纯红色点的射线顺时针到达该点所经过的角度，$\frac {r}{100}$​​ 是该点到单位圆圆心的距离。

![0](https://i.loli.net/2018/04/02/5ac1bb23a4d50.png)

具体而言，从这个坐标 (α°,$r\%$) 到红绿蓝颜色值 $(R,G,B)$ 的转换如下：

![1](https://cdn.luogu.com.cn/upload/pic/16828.png)

请参照样例确认你对公式的理解和实现。

按照 Kyubey 的判断，元首可以选择色盘所在的平面上一条给定直线段 (α1°,$r1\%$)-(α2°,$r2\%$) 上的任意颜色。元首可不需要犹豫，作为一名 bling bling 的帝国领导者，当然要选择最亮的颜色啦！

一个颜色 $(R,G,B)$ 的亮度定义为 $L = 0.30R + 0.59G + 0.11B$。下图给出了彩色色盘和表示亮度的灰度色盘的左右对比。

![2](https://i.loli.net/2018/04/02/5ac1bb2371a0b.png)

你需要编写程序帮助元首计算给定直线段上所有颜色的最大亮度。
## 输入格式

从标准输入读入数据。

输入的第一行包含一个正整数 $T$—— 数据的组数。接下来包含 $T$ 组数据，格式如下，数据间没有空行。

第 $1$ 行：四个空格分隔的整数 $\alpha_1$​​、$r_1$​​、$\alpha_2$​​、$r_2$​​。


## 输出格式

输出到标准输出。

对于每组数据输出一行，包含一个 $[0,1]$ 范围内的十进制小数 —— 直线段 (α1°,$r1\%$)-(α2°,$r2\%$) 上所有颜色的最大亮度，四舍五入保留恰好四位小数。数据保证若参考答案为 $A$，则 [$A-10^{-5},A+10^{-5}$]​ 范围内任意实数四舍五入到第四位小数后均相等。

## 样例

### 样例输入 #1
```
6
30 30 30 30
120 60 120 60
270 100 270 100
30 30 120 60
120 60 270 100
270 100 30 30
```
### 样例输出 #1
```
0.8785
0.7540
0.2600
0.9704
0.9408
0.8785
```
## 提示

**样例解释**

点 (30°, $30\%$) 的红绿蓝颜色值为 $(1.00, 0.85, 0.70)$，亮度为 $0.30 \times 1.00 + 0.59 \times 0.85 + 0.11 \times 0.70 = 0.8785$；

点 (120°,$60\%$) 的红绿蓝颜色值为 $(0.40, 1.00, 0.40)$，亮度为 $0.30 \times 0.40 + 0.59 \times 1.00 + 0.11 \times 0.40 = 0.7540$； 

点 (270°,$100\%$) 的红绿蓝颜色值为 $(0.50, 0.00, 1.00)$，亮度为 $0.30 \times 0.50 + 0.59 \times 0.00 + 0.11 \times 1.00 = 0.2600$。

![6](https://cdn.luogu.com.cn/upload/pic/16899.png)

 “Ich glaube, ich habe mich klar genug ausgedrückt!”

题面与史实无关。

Credit: https://www.luogu.org/discuss/show/38908


---

---
title: "[JSOI2008] Blue Mary的旅行"
layout: "post"
diff: 省选/NOI-
pid: P4400
tag: ['2008', '各省省选', '江苏']
---
# [JSOI2008] Blue Mary的旅行
## 题目描述

在一段时间之后，网络公司终于有了一定的知名度，也开始收到一些订单，其中最大的一宗来自 B 市。

Blue Mary 决定亲自去签下这份订单。为了节省旅行经费，他的某个金融顾问建议只购买 U 航空公司的机票。 U 航空公司的所有航班每天都只有一班，并且都是上午出发当天下午到达的，所以他们每人每天只能坐一班飞机。

经过调查，他们得到了 U 航空公司经营的所有航班的详细信息，这包括每一航班的出发地，目的地以及最多能买到的某一天出发的票数。(注意: 对于一个确定的航班，无论是哪一天，他们最多能买到的那一天出发的票数都是相同的）。

Blue Mary 注意到他们一定可以只乘坐 U 航空公司的航班就从 A 市到达 B 市，但是，由于每一航班能买到的票的数量的限制，他们所有人可能不能在同一天到达 B 市。

所以现在 Blue Mary 需要你的帮助，设计一个旅行方案使得最后到达B市的人的到达时间最早。
## 输入格式

第一行包含 $3$ 个正整数 $N$，$M$ 和 $T$。  
题目中会出现的所有城市分别编号为 $1,2,\dots,N$，其中城市 A 编号一定为 $1$，城市 B 编号一定为 $N$。  
U 公司一共有 $M$ 条（单向）航班。而连 Blue Mary 在内，公司一共有 $T$ 个人要从 A 市前往 B 市。

以下 $M$ 行，每行包含3个正整数 $x,y,z,$ 表示 U 公司的每一条航班的出发地，目的地以及 Blue Mary 最多能够买到的这一航班某一天出发的票数。(即：无论是哪一天，Blue Mary 最多只能买到 $z$ 张 U 航空公司的从城市 $x$ 出发到城市 $y$ 的机票)。

输入保证从一个城市到另一个城市的单向航班最多只有一个。
## 输出格式

仅有一行，包含一个正整数，表示最后到达 B 市的人的最早到达时间。假设他们第一次乘飞机的那一天是第一天。
## 样例

### 样例输入 #1
```
3 3 5
1 2 1
2 3 5
3 1 4

```
### 样例输出 #1
```
6

```
## 提示

对于 $100\%$ 的数据，$2\le N\le 50,1\le M\le 2450,1\le T,z\le 50,1\le x,y\le N,x\neq y$。


---

---
title: "[Cerc2007] robotic sort 机械排序"
layout: "post"
diff: 省选/NOI-
pid: P4402
tag: ['2007']
---
# [Cerc2007] robotic sort 机械排序
## 题目描述

SORT公司是一个专门为人们提供排序服务的公司，该公司的宗旨是：“顺序是最美丽的”。他们的工作是通过一系列移动，将某些物品按顺序摆好。他们的工作规定只能使用如下方法排序：

![](https://cdn.luogu.com.cn/upload/pic/17272.png)

先找到编号最小的物品的位置P1，将区间[1，P1]反转，再找到编号第二小的物品的位置P2,将区间[2,P2]反转.........

上图是有6个物品的例子，编号最小的一个是在第4个位置。因此，最开始把前面4个物品反转，第二小的物品在最后一个位置，所以下一个操作是把2-6的物品反转，第三步操作是把3-4的物品进行反转……

在数据中可能存在有相同的编号，如果有多个相同的编号，则按输入的原始次序操作。
## 输入格式

输入共两行，第一行为一个整数N，N表示物品的个数，1<=N<=100000。

第二行为N个用空格隔开的正整数，表示N个物品最初排列的编号。
## 输出格式

输出共一行，N个用空格隔开的正整数P1,P2,P3…Pn，（1 < = Pi < = N），Pi表示第i次操作前第i小的物品所在的位置。

 注意：如果第i次操作前，第i小的物品己经在正确的位置Pi上，我们将区间[Pi,Pi]反转(单个物品)。
## 样例

### 样例输入 #1
```
6
3 4 5 1 6 2
```
### 样例输出 #1
```
4 6 4 5 6 6
```


---

---
title: "[SHOI2004] 最小生成树"
layout: "post"
diff: 省选/NOI-
pid: P4412
tag: ['2004', '各省省选', '上海']
---
# [SHOI2004] 最小生成树
## 题目描述


给定一个筒单图 $G=\langle V.E.W\rangle$，$V$ 为顶点集合，$E$ 为边的集合（无重边，即任意两个顶点之间至多只有一条边)，$W$ 为定义在 $E$ 上的权函数（值为整数)。给出其上的一棵生成树 $T$，现在要求用最小的代价修改 $W$，使得 $T$ 是 $G$ 上的一棵最小生成树（一个图可以有多棵最小生成树，只要 $T$ 的边权和最小即可)。对于任意一条边 $e \in E$ 修改方法为：

- 增加 $e$ 的权值，即令 $W'(e)=W(e)+\Delta(e)$，则修改该边的代价为 $\Delta(e)$
- 减小 $e$ 的权值，即令 $W'(e)=W(e)-\Delta(e)$，则修改该边的代价为 $\Delta(e)$
- 不改变 $e$ 的权，即 $W'(e)=W(e)$，修改代价为 $\Delta(e)=0$。

请注意：修改后的权函数 $W'$ 的值域也为整数。

总的修改代价记为 $S=\sum\limits_{e \in E} \Delta(e)$。
## 输入格式

第一行为 $N,M$，其中 $N$ 表示顶点的数目，$M$ 表示边的数目。顶点的编号为 $1,2,3,\cdots,N-1,N$。

接下来的 $M$ 行，每行三个整数 $U_i,V_i,W_i$，表示顶点 $U_i$ 与 $V_i$ 之间有一条边，其权值为 $W_i$。

所有的边在输入中会且仅会出现一次。再接着 $N-1$ 行，每行两个整数 $X_i,Y_i$，表示顶点 $X_i$ 与 $Y_i$ 之间的边是 $T$ 的一条边。
## 输出格式

输出最小的 $S$。
## 样例

### 样例输入 #1
```
6 9
1 2 2
1 3 2
2 3 3
3 4 3
1 5 1
2 6 3
4 5 4
4 6 7
5 6 6
1 3
2 3
3 4
4 5
4 6
```
### 样例输出 #1
```
8

```
## 提示

边 $(4,6)$ 的权由 $7$ 修改为 $3$，代价为 $4$；  
边 $(1,2)$ 的权由 $2$ 修改为 $3$，代价为 $1$；  
边 $(1,5)$ 的权由 $1$ 修改为 $4$，代价为 $3$；  

所以总代价为 $4+1+3=8$。

$1 \le N \le 50,1 \le M \le 1500,1 \le W_i \le 1000$。


---

---
title: "[COCI 2017/2018 #2] ​​Usmjeri"
layout: "post"
diff: 省选/NOI-
pid: P4434
tag: ['2017', 'COCI（克罗地亚）']
---
# [COCI 2017/2018 #2] ​​Usmjeri
## 题目描述

We are given a tree with N nodes denoted with different positive integers from 1 to N.
Additionally, you are given M node pairs from the tree in the form of ($a_1$
, $b_1$
), ($a_2$
, $b_2$
), …, ($a_M$
,
$b_M$
).

We need to direct each edge of the tree so that for each given node pair ($a_i$
, $b_i$
) there is a
path from $a_i$
to $b_i$ or from $b_i$
to $a_i$
. How many different ways are there to achieve this?
Since the solution can be quite large, determine it modulo $10^{9}+7$.

## 输入格式

The first line of input contains the positive integers N and M (1 ≤ N, M ≤ $3*10^5$), the number of
nodes in the tree and the number of given node pairs, respectively.

Each of the following N - 1 lines contains two positive integers, the labels of the nodes
connected with an edge.

The $i_{th}$ of the following M lines contains two different positive integers $a_{i}$ and $b_{i}$
, the labels of
the nodes from the $i_{th}$ node pair. All node pairs will be mutually different.

## 输出格式

You must output a single line containing the total number of different ways to direct the
edges of the tree that meet the requirement from the task, modulo $10^{9}+7$.

## 样例

### 样例输入 #1
```
4 1
1 2
2 3
3 4
2 4
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
7 2
1 2
1 3
4 2
2 5
6 5
5 7
1 7
2 6

```
### 样例输出 #2
```
8
```
### 样例输入 #3
```
4 3
1 2
1 3
1 4
2 3
2 4
3 4

```
### 样例输出 #3
```
0
```
## 提示

In test cases worth 20% of total points, the given tree will be a chain. In other words, node i
will be connected with an edge to node i + 1 for all i < N.

In additional test cases worth 40% of total points, it will hold N, M ≤ $5*10^3$.

A tree is a graph that consists of N nodes and N - 1 edges such that there exists a path from each
node to each other node.
## 题目翻译

给定一颗从1到n编号的n个结点的树

同时给定m个约束，诸如$(a_i,b_i)$

给每一条边定向，使得对于每一对约束对存在一条从$a_i$到$b_i$或从$b_i$到$a_i$的路径。

求可行的方案数，答案对$10^9 + 7$取模

$1 \le n,m \le 3 \times 10^5$

```
给定一颗从1到n编号的n个结点的树

同时给定m个约束，诸如$(a_i,b_i)$

给每一条边定向，使得每一对约束对存在一条从$a_i$到$b_i$或从$b_i$到$a_i$的路径。

求可行的方案数，答案对$10^9 + 7$取模

$1 \le n,m \le 3 \times 10^5$
```


---

---
title: "[COCI 2017/2018 #3] Dojave"
layout: "post"
diff: 省选/NOI-
pid: P4443
tag: ['2017', 'COCI（克罗地亚）']
---
# [COCI 2017/2018 #3] Dojave
## 题目背景

原题每个点4s，但我改不了= =，不过标程1s不到就过了。
## 题目描述

The biggest event of the year ended tragically for Croatian teams. The most influential theoretician of CERC of all time, the founder of the popular page CERC Tips, and in his free time an outstanding bass player, in his most recent performance failed to get his team to the finals.

In order to get over his existential troubles, our subject is spending time playing games of chance. He is especially interested in the following game:

You are given a positive integer M. Our protagonist sees in front of him a **permutation** of an array of numbers 0, 1, 2, ..., $2^M$- 1.

The computer chooses a **nonempty contiguous subsequence** of the given permutation, which it then lights up over a capital city of one of the countries in Southeastern Europe.

Our confidant, after fighting off tears caused by memories of old times, **must** choose two distinct elements of the permutation and **swap their places**​. Our man of the hour wins if and only if the **bitwise XOR** of the numbers in the lit up subsequence after the substitution is **precisely**​ $2^M$- 1.

Our hero wants to know **the number of contiguous subsequences** ​the computer can light up so that he can win.

Help our hero overcome his (id)entity crisis so our favourite page can be fully active again.

## 输入格式

The first line of input contains the integer M (1 ≤ M ≤ 20),

The following line contains $2^M$ space-separated numbers that make up a permutation of the array 0, 1, 2, ..., $2^M$- 1.

## 输出格式

You must output the total number of contiguous subsequences that a computer can light up so our hero can win.

## 样例

### 样例输入 #1
```
2
0 1 2 3

```
### 样例输出 #1
```
9
```
### 样例输入 #2
```
3
3 7 0 4 6 1 5 2

```
### 样例输出 #2
```
33
```
### 样例输入 #3
```
4
13 0 15 12 4 8 7 3
11 14 6 10 1 5 9 2

```
### 样例输出 #3
```
133
```
## 提示

In test cases worth 50% of total points, it will hold 1 ≤ M ≤ 14.

**Clarification​ ​of​ ​the​ ​test​ ​cases:**

In the first test case, if the computer chooses the subsequence [1 2 3], our hero can replace the numbers 0 and 3. In this case, he can actually win for every chosen contiguous subsequence, except the entire array.

In the second test case, if the computer chooses the entire array [3 7 0 4 6 1 5 2] as the lit up subsequence, our hero can’t change the XOR of the subsequence (which is 0), no matter which two elements are swapped.
## 题目翻译

给出一个长度为2^M的排列，元素分别是0， 1， 2， ... , 2^M -1。
选择其中某个非空连续子序列，然后允许交换这个排列中某两个不同的数，然后使得这个连续子序列的所有数的按位异或(bitwise XOR)的结果恰好等于2^M-1
求：有多少个连续子序列满足上述条件。





---

---
title: "[COCI 2017/2018 #3] Sažetak"
layout: "post"
diff: 省选/NOI-
pid: P4444
tag: ['2017', 'COCI（克罗地亚）']
---
# [COCI 2017/2018 #3] Sažetak
## 题目描述

An unknown array x consists of N integers. The K-summary of that array is obtained by dividing the array into segments of length K and summing up the elements in each segment.
If N is not divisible by K, the last segment of the division will have less than K elements.

In other words, the K-summary is an array where the elements are, respectively: (x[1] + … + x[K]), (x[K+1] + … + x[2K]), and so on, where the last sum that contains x[N] can have less than K summands. For example, the 5-summary of an array of 13 elements has three elements (sum of elements 1.-5., sum of elements 6.-10., sum of elements 11.-13.).

It is clear that we cannot reconstruct the elements of the original array from the K-summary, but that might be possible if we knew several K-summaries for different Ks. Write a program that will, given length N and set $K_1$, $K_2$
, …, $K_M$ , predict how many elements of the original array we would be able to uniquely determine if we knew all the $K_i$ -summaries of the array.
(It is not difficult to show that the number of reconstructed elements is independent of the content of the summaries.)

## 输入格式

The first line contains the integers N and M (3 <= N <= $10^9$
, 1 <= M <= 10), the array length and the number of K-summaries.

The second line contains distinct integers$K_1$, $K_2$ , …, $K_M$
(2 <= $K_i$ < N) from the task.
## 输出格式

You must output the required number of reconstructed elements
## 样例

### 样例输入 #1
```
3 1
2

```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
6 2
2 3

```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
123456789 3
5 6 9

```
### 样例输出 #3
```
10973937

```
## 提示

In test cases worth 40% of total points, it will hold N <= 5 000 000.

**Clarification​ ​of​ ​the​ ​first​ ​example**:​ ​We can determine one element: x[3].

**Clarification​ ​of​ ​the​ ​second​ ​example**:​ ​We can determine x[3] and x[4].
## 题目翻译

### 题目描述

有一个长度为 $N$ 的未知数组 $x$。这个数组的 $K$-总和定义为将该数组分割为若干长度为 $K$ 的区间，并对每个区间中的元素分别求和的结果。如果 $N$ 不能被 $K$ 整除，则最后一个区间的元素数将少于 $K$。

换言之，$K$-总和指的是一个数组，其中的元素分别为：$(x_1+\dots+x_K)$，$(x_{K+1}+\dots+x_{2K})$，以此类推；其中包含了 $x_N$ 的元素，即最后一个元素，可以由少于 $K$ 个部分组成。例如，一个含有十三个元素的数组的 $5$-总和有三个元素（第一到第五项之和，第六到第十项之和，第十一到第十三项之和）

可以发现我们无法通过一个 $K$-总和来重现原数组，但当我们知道几个 $K$ 值不同的 $K$-总和时就有可能做到这一点。给定 $N$ 和 $K_1,K_2,\dots,K_M$，请您编写一条程序，计算在已知一个长为 $N$ 的数组的 $K_i$-总和的前提下，有多少原数组的元素可以被唯一确定（不难发现唯一确定的元素数与 $K_i$-总和的内容无关）。

### 输入格式

第一行包含两个整数 $N$ 和 $M$，$N$ 为原数组大小，$M$ 为已知 $K$-总和的数量。

第二行包含 $M$ 个整数，分别为 $K_1,K_2,\dots,K_M$，如题所述。

### 输出格式

您需要输出唯一确定的元素数。

### 数据范围

对于 $40\%$ 的数据，$N\le5\times10^6$。

对于 $100\%$ 的数据，$3\le N\le10^9$，$1\le M\le10$，$2\le K_i<N$。

### 样例解释

对于第一个样例：我们可以确定 $x_3$。

对于第二个样例：我们可以确定 $x_3$ 和 $x_4$。

翻译来自于 @阿丑


---

---
title: "[国家集训队] JZPSTR"
layout: "post"
diff: 省选/NOI-
pid: P4465
tag: ['2012', '集训队互测']
---
# [国家集训队] JZPSTR
## 题目描述

你要对一个字符串进行三种操作：

0. 在位置$x_i$处插入一个字符串$y_i$

1. 删除位置$[x_i, y_i)$的字符串

2. 查询位置$[x_i, y_i)$的字符串包含多少次给定的子串$z_i$
## 输入格式

第一行，一个整数$T$，表示操作个数。

下面$T$行，每行第一个数$p_i$，表示这个操作的类型：

若$p_i=0$，则接下来有一个整数$x_i$和一个字符串$y_i$，表示进行插入操作；

若$p_i=1$，则接下来有两个整数$x_i$和$y_i$，表示进行删除操作；

若$p_i=2$，则接下来有两个整数$x_i$和$y_i$，以及一个字符串$z_i$，表示进行询问。

字符串的下标从$0$开始(即第一个字符的下标为$0$)。

初始时字符串为空。

对于插入操作，插入后字符串$y_i$的首字符的下标应为$x_i$；

对于删除操作，删除的区间$[x_i, y_i)$为左闭右开区间；

对于查询操作，询问的区间$[x_i, y_i)$为左闭右开区间。

所有插入的和查询的字符串均不为空，且只包含0~9的字符。

所有询问的区间和删除的区间均不为空。

保证输入数据合法。

对于"左闭右开区间"不理解的可以去看样例解释。
## 输出格式

对每个询问操作，输出一行，表示这个询问的答案。
## 样例

### 样例输入 #1
```
8
0 0 894894894
2 0 2 894
2 0 9 894
0 2 6
2 0 9 64
2 0 9 894
1 2 6
2 0 6 894
```
### 样例输出 #1
```
0
3
1
1
2
```
## 提示

第一次操作后，字符串为894894894；

第二次操作，询问的区间为89，不包含任何894；

第三次操作，询问的区间为894894894，包含三个894；

第四次操作后，字符串为8964894894；

第五次操作，询问的区间为896489489，包含一个64；

第六次操作，询问的区间为896489489，包含一个894；

第七次操作后，字符串为894894；

第八次操作，询问的区间为894894，包含两个894。

50%的数据中，询问个数<=100 (不是操作个数)

100%的数据中，插入总长度<=2000000，任何时刻字符串长度<=1000000，插入次数<=1001，删除次数<=1000，询问的z_i的总长度<=10000

来源：2012集训队互测，by gyz


---

---
title: "[国家集训队] 和与积"
layout: "post"
diff: 省选/NOI-
pid: P4466
tag: ['2012', '集训队互测']
---
# [国家集训队] 和与积
## 题目描述

给出 $n$，统计满足下面条件的数对 $(a,b)$ 的个数：

1. $1\le a<b \le n$。
2. $a+b$ 整除 $a\times b$。
## 输入格式

一行一个整数数 $n$。
## 输出格式

一行一个整数表示答案。
## 样例

### 样例输入 #1
```
15
```
### 样例输出 #1
```
4
```
## 提示

| Test | $N$ | Test | $N$ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 10$ | $11$ | $\leq 5\times 10^7$ |
| $2$ | $\leq 50$ | $12$ | $\leq 10^8$ |
| $3$ | $\leq 10^3$ | $13$ | $\leq 2\times 10^8$ |
| $4$ | $\leq 5\times 10^3$ | $14$ | $\leq 3\times 10^8$ |
| $5$ | $\leq 2\times 10^4$ | $15$ | $\leq 5\times 10^8$ |
| $6$ | $\leq 2\times 10^5$ | $16$ | $\leq 10^9$ |
| $7$ | $\leq 2\times 10^6$ | $17$ | $\leq 10^9$ |
| $8$ | $\leq 10^7$ | $18$ | $\leq 2^{31}-1$ |
| $9$ | $\leq 2\times 10^7$ | $19$ | $\leq 2^{31}-1$ |
| $10$ | $\leq 3\times 10^7$ | $20$ | $\leq 2^{31}-1$ |

来源：2012集训队互测，by ayq


---

---
title: "巧克力王国"
layout: "post"
diff: 省选/NOI-
pid: P4475
tag: []
---
# 巧克力王国
## 题目描述

巧克力王国里的巧克力都是由牛奶和可可做成的。但是并不是每一块巧克力都受王国人民的欢迎，因为大家都不喜欢过于甜的巧克力。

对于每一块巧克力，我们设 $x$ 和 $y$ 为其牛奶和可可的含量。由于每个人对于甜的程度都有自己的评判标准，所以每个人都有两个参数 $a$ 和 $b$ ，分别为他自己为牛奶和可可定义的权重， 因此牛奶和可可含量分别为 $x$ 和 $y$ 的巧克力对于他的甜味程度即为 $ax+by$。而每个人又有一个甜味限度 $c$ ，所有甜味程度大于等于 $c$ 的巧克力他都无法接受。每块巧克力都有一个美味值 $h$ 。

现在我们想知道对于每个人，他所能接受的巧克力的美味值之和为多少。
## 输入格式

第一行两个正整数 $n$ 和 $m$ ，分别表示巧克力个数和询问个数。  
接下来$n$行，每行三个整数 $x , y , h$ ，含义如题目所示。  
再接下来 $m$ 行，每行三个整数 $a , b , c$ ，含义如题目所示。
## 输出格式

输出$m$行，其中第$i$行表示第$i$个人所能接受的巧克力的美味值之和。
## 样例

### 样例输入 #1
```
3 3
1 2 5
3 1 4
2 2 1
2 1 6
1 3 5
1 3 7
```
### 样例输出 #1
```
5
0
4
```
## 提示

对于100%的数据，$1<=n,m<=50000$,$-10^9<=a_i,b_i,x_i,y_i<=10^9$。

保证数据用某种方式随机生成。


---

---
title: "[BJWC2018] 数字统计"
layout: "post"
diff: 省选/NOI-
pid: P4476
tag: ['2018', '北京']
---
# [BJWC2018] 数字统计
## 题目描述

小A 正在研究一些数字统计问题。有一天他突然看到了一个这样的问题：

将[L..R]中的所有整数用M 位二进制数表示（允许出现前导0）。现在将这些数中的每一个作如下变换：

从这个数的最低两位开始，如果这两位都是0，那么X=1，否则X=0。现在将这两位删去，然后将X 放在原来最低位的位置上。重复这个变换直到这个数只剩下一位为止。

例如01001 的变换过程如下：

01001-->0100-->011-->00-->1。

现在的问题是变换后的所有数中，值为Y（Y 为0 或1）的有多少个？

小A 不会了，他想让你帮助他完成这个问题。
## 输入格式

输入文件包含多组测试数据。

第一行，一个整数T，表示测试数据的组数。

接下来的T 节，每节对应一组测试数据，格式如下：

第一行，两个整数M、Y。

第二行，两个M 位二进制数L、R。
## 输出格式

对于每组测试数据，输出一行，一个二进制数，表示该组测试数据中[L..R]中的所有整数变换后的值为Y 的个数。这里的二进制数不允许出现前导0。
## 样例

### 样例输入 #1
```
1
3 1
001 101
```
### 样例输出 #1
```
11
```
## 提示

对于20%的数据：1 ≤ M ≤ 16。

对于40%的数据：1 ≤ M ≤ 32。

对于100%的数据：1 ≤ M ≤ 200，1 ≤ T ≤ 50。


---

---
title: "[BJWC2018] 上学路线"
layout: "post"
diff: 省选/NOI-
pid: P4478
tag: ['2018', '北京']
---
# [BJWC2018] 上学路线
## 题目描述

小 B 所在的城市的道路构成了一个方形网格，它的西南角为 $(0,0)$，东北角为 $(N,M)$。

小 B 家住在西南角，学校在东北角。现在有 $T$ 个路口进行施工，小 B 不能通过这些路口。小 B 喜欢走最短的路径到达目的地，因此他每天上学时都只会向东或北行走；而小 B 又喜欢走不同的路径，因此他问你按照他走最短路径的规则，他可以选择的不同的上学路线有多少条。由于答案可能很大，所以小 B 只需要让你求出路径数 mod $P$ 的值。
## 输入格式

第一行为四个整数 $N$ 、 $M$ 、 $T$ 、 $P$。

接下来的 $T$ 行，每行两个整数，表示施工的路口的坐标。
## 输出格式

一行一个整数，表示路径数 mod $P$ 的值。
## 样例

### 样例输入 #1
```
3 4 3 1019663265
3 0
1 1
2 2
```
### 样例输出 #1
```
8
```
## 提示

![](https://cdn.luogu.com.cn/upload/pic/17943.png)


---

---
title: "[BJWC2018] 神奇的钟点"
layout: "post"
diff: 省选/NOI-
pid: P4483
tag: ['2018', '北京']
---
# [BJWC2018] 神奇的钟点
## 题目描述

一天，小 L 看到了 3 块钟表，分别显示着 $\texttt{01:08}$、$\texttt{03:40}$、$\texttt{13:52}$。小 L 发现，每块表上的时间都是 $\texttt{hh:mm}$ 的形式，其中 $\texttt{hh}$ 表示小时，$\texttt{mm}$ 表示分钟，而且都不是整点（即 $0\leqslant\texttt{hh}<24$，$1\leqslant\texttt{mm}<60$）。

回想起小学数学老师刚刚讲的关于比例的知识，$\texttt{hh:mm}$ 也表示一个比，它的值等于 $\frac{\texttt{hh}}{\texttt{mm}}$。这时小 L 发现了一件神奇的事情：把这三个钟点加起来会得到 $\texttt{18:40}$，这也是一个不是整点的合法时间（注意小时数要小于 $24$），它对应的比值 $\frac{9}{20}$，与这三个钟点对应的比值 $\frac{1}{8}$、$\frac{3}{40}$、$\frac{1}{4}$ 之和竟然相等！

现在小 L 想知道，把所有的满足这个神奇的性质的 3 个钟点组成的钟点组按照字典序排序后，第 $k$ 小的是什么。
## 输入格式

输入仅包含一个正整数 $k$。
## 输出格式

输出字典序第 $k$ 小的满足题目所述神奇性质的钟点组，以一个空格隔开，详见样例输出。如果答案不存在，输出 `-1`。
## 样例

### 样例输入 #1
```
65432
```
### 样例输出 #1
```
01:08 03:40 13:52
```
### 样例输入 #2
```
1
```
### 样例输出 #2
```
00:01 00:01 00:01
```
### 样例输入 #3
```
58
```
### 样例输出 #3
```
00:01 00:02 00:01
```
### 样例输入 #4
```
2000000000
```
### 样例输出 #4
```
-1
```
## 提示

**【样例说明】**

注意钟点可以相同。

**【数据规模和约定】**

对于 $30\%$ 的数据，$k\leqslant 1000$。  
对于 $60\%$ 的数据，$k\leqslant 20000$。  
对于 $100\%$ 的数据，$1\leqslant k\leqslant 2\times 10^9$。


---

---
title: "[HAOI2018] 反色游戏"
layout: "post"
diff: 省选/NOI-
pid: P4494
tag: ['2018', '河南', '各省省选', 'O2优化']
---
# [HAOI2018] 反色游戏
## 题目描述

小$C$和小$G$经常在一起研究搏弈论问题，有一天他们想到了这样一个游戏．
有一个$n$个点$m$条边的无向图，初始时每个节点有一个颜色，要么是黑色，要
么是白色．现在他们对于每条边做出一次抉择：要么将这条边连接的两个节点都
反色（黑变白，白变黑），要么不作处理．他们想把所有节点都变为白色，他们
想知道在$2^m$种决策中，有多少种方案能达成这个目标．
小$G$认为这个问题太水了，于是他还想知道，对于第$i$个点，在删去这个点及
与它相连的边后，新的答案是多少．
由于答案可能很大，你只需要输出答案对$10^9+7$取模后的结果．
## 输入格式

从文件$game.in$中读入数据.
第一行一个整数$T$，表示数据组数．
每组数据第一行两个整数$n$,$m$表示点数和边数.
接下来$m$行，每行两个整数$u$,$v$,描述无向图的一条边．
接下来一行一个长度为$n$的$0/1$串，如果第$i$个字符为$0$表示第$i$个点为白色，否
则为黑色．
## 输出格式

输出到文件$game.out$中.
每组数据输出一行$n+1$个整数，第一个整数表示不删去任何点时的答案．接
下来$n$个整数，第$i$个表示删去第$i$个点时的答案．
## 样例

### 样例输入 #1
```
2
5 5
1 2
2 3
3 4
2 4
3 5
00000
5 4
1 2
2 3
2 4
2 5
11111
```
### 样例输出 #1
```
2 2 1 1 1 2
0 1 0 1 1 1
```
## 提示

对于所有数据，有$1\le T\le5$,$1\le n,m\le10^5$,$1\le u,v\le n$，没有重边和自
环．
![](https://cdn.luogu.com.cn/upload/pic/18145.png)
HAOI2018 round1 T2


---

---
title: "[COCI 2017/2018 #4] Vođe"
layout: "post"
diff: 省选/NOI-
pid: P4522
tag: ['2017', 'COCI（克罗地亚）']
---
# [COCI 2017/2018 #4] Vođe
## 题目背景

#滥用本题评测将被封号
## 题目描述

As we all very well know, goats and sheep have been fighting for years about the fields
they’re grazing. After many fierce fights, the goat leader and the sheep leader decided to
meet to try to find a peaceful solution to their problem. After many hours of discussion, they
agreed that they will play a game for each field and that the winner will get to graze that field.

The game is played such that a total of N animals (that can be goats or sheep) form a circle
(the exact order of goats and sheep is an agreement between their leaders). After animal i (1
≤ i ≤ N-1), the game is continued by animal i+1, and after animal N, the game is continued by
animal 1. The animal starting the game can say any positive integer from the interval [1, K],
but only if that number is not greater than M. If the animal that started the game said the
number j, then the next animal can say a number in interval [j+1, j+K], but only if that number
is not greater than M. In other words, each animal can say a number that is greater by
minimally 1, and maximally by K than the number said by the animal before, but only if the
new number is not greater than M. If an animal must say number M, its team (goats or
sheep) loses.

If both the goats and the sheep are playing optimally, for each i (1 ≤ i ≤ N), determine who
will win the field if the game is started by the $i^{th}$ animal.

## 输入格式

The first line of input contains N, M and K (1 ≤ N, M, K ≤ 5000), the numbers from the task.
The following line contains N numbers, 0 if the $i^{th}$  animal is a sheep, and 1 if it’s a goat.
## 输出格式

Output N space-separated numbers. For each animal i (1 ≤ i ≤ N) output 0 if the sheep will
win the field, and 1 if the goats will win, if the $i^{th}$   animal is starting the game.

## 样例

### 样例输入 #1
```
2 9 2
0 1
```
### 样例输出 #1
```
0 1
```
### 样例输入 #2
```
6 499 5
1 0 0 1 1 0
```
### 样例输出 #2
```
0 1 1 1 1 0
```
### 样例输入 #3
```
10 100 10
0 0 0 1 1 1 1 0 1 1
```
### 样例输出 #3
```
1 1 1 1 1 1 1 1 1 1
```
## 提示

In test cases worth a total of 60% of points, it will hold 1 ≤ N, M, K ≤ 500.

**Clarification of the first test case:**

When a sheep is playing first, it can play like this:

The sheep starts with number 2, after which the goat can say 3 or 4. In both cases, the sheep can say
5, after which the goat can say either 6 or 7. In both cases, the sheep can say 8, after which the goat
doesn’t have any other choice but 9 and thus losing the game and the field.
## 题目翻译

给n个人每个人有个团队（0或1），每个人可以报一个数，第一个人的范围为[1,k]，上一个人报的数x下一个人为[x+1,x+1+k]，报数超过m的人输，1-n按顺序报数，n的下一个为1直到游戏结束。每个人都会选择最优策略，问以每个人为起始点玩这个游戏，那个团队会赢。

由 @Unknown_Error  提供翻译


---

---
title: "[JSOI2011] Apple 的美食"
layout: "post"
diff: 省选/NOI-
pid: P4543
tag: ['2011', '各省省选', '江苏']
---
# [JSOI2011] Apple 的美食
## 题目描述

Apple 很喜欢吃巧克力，但它是一头挑剔的猪，有的品种的巧克力并不能满足它的胃口。如果主人给它的巧克力它不喜欢吃，它就会很不开心。主人并不知道，什么样的巧克力 Apple 喜欢吃，但她知道巧克力的可可含量是巧克力
口感的重要因素，因此她决定根据巧克力的可可含量来判断什么样的巧克力拿给 Apple 吃，什么样的巧克力不拿给 Apple 吃。

假设一块巧克力的可可含量有 $1\sim N$ 种不同的计量，则她认为可可含量在 $[a,b]$ 的范围内的巧克力是好吃的
。不过她不知道的这个范围到底是多少，需要你来帮忙确定这个范围，使得她可以让 Apple 吃到最多的喜欢吃的巧克力。

设 $pos_i$ 是可可脂含量为 $i$，且 Apple 认为是好吃的巧克力的数量，$neg_i$ 是可可脂含量为 $i$，且 Apple 认为是不好吃的巧克力的数量。这两个序列由以下方法生成：
$$\begin{cases}pos_i=a_{2i-1}\\neg_i=a_{2i}\end{cases}$$

其中，$a_i=(p_1a_{i-1}+p_2)\bmod M(i>1)$。

设 $TP$ 是 Apple 认为好吃的、且被主人认为是好吃的巧克力数量，$TN$ 是Apple 认为不好吃的、且被主人认为是不好吃的巧克力数量，$FP$ 是 Apple 认为不好吃的、且被主人认为是好吃的巧克力数量，$FN$ 是 Apple 认为好吃的、且被主人认为是不好吃的巧克力数量。

设 $r$ 为被正确判断为好吃的巧克力数占所有好吃的巧克力的比率，$p$ 为被正确判断为好吃的巧克力占所有被判定为好吃的巧克力数的比率，则

$$\begin{cases}r=\frac{TP}{TP+FN}\\p=\frac{TP}{TP+FP}\end{cases}$$

请你帮助 Apple 求出一个范围，使得 $f=\frac{2pr}{p+r}$ 最大。
## 输入格式

输入由若干行组成，每行是一组数据：$N,a_1,p_1,p_2,M$，中间用空格分开。

输入以一个 $0$ 结束，数据组数不超过 $1000$。
## 输出格式

每组数据输出一行，为 $f$ 的最大值（四舍五入保留 $6$ 位小数）。
## 样例

### 样例输入 #1
```
4 4 4 1 5
12 9 6 6 11
0
```
### 样例输出 #1
```
0.800000
0.683938
```
## 提示

### 数据范围

对于 $100\%$ 的数据，$1\leq N\leq 10^6,a_1,p_1,p_2<M\leq 20$，保证至少有一块 Apple 认为好吃的巧克力。


---

---
title: "[JXOI2018] 守卫"
layout: "post"
diff: 省选/NOI-
pid: P4563
tag: ['2018', '各省省选']
---
# [JXOI2018] 守卫
## 题目背景

九条可怜是一个热爱运动的女孩子。
## 题目描述

这一天她去爬山，她的父亲为了她的安全，雇了一些保镖，让他们固定地呆在在山的某些位置，来实时监视九条可怜，从而保护她。

具体来说，一座山可以描述为一条折线，折线的下方是岩石。这条折线有 $n$ 个折点，每个折点上有一个亭子，第 $i$ 个折点的坐标是 $(i,h_i)$ 。九条可怜只可能会在亭子处玩耍，那些保镖也只会在亭子处监视可怜。

由于技术方面的原因，一个保镖只能监视所有他能看得到的，横坐标不超过他所在位置的亭子。我们称一个保镖能看到一个亭子 $p$ ，当且仅当他所在的亭子 $q$ 和 $p$ 的连线不经过任何一块岩石。特别地，如果这条连线恰好经过了除了 $p,q$ 以外的亭子，那么我们认为保镖看不到可怜。

雇佣保镖是一件很费钱的事情，可怜的父亲希望保镖越少越好。

可怜的父亲还希望得到详尽的雇佣保镖的方案，他知道有些亭子可能正在维修，他想对所有的 $1\leq l\leq r\leq n$ 计算：如果事先已知了只有区间 $[l,r]$ 的亭子可以用来玩耍（和监视），那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。

可怜的父亲已经得到了一个结果，他希望和你核实他的结果是否正确。
## 输入格式

第一行输入一个整数 $n$ 表示亭子的数目。

接下来一行 $n$ 个整数，第 $i$ 个整数 $h_i$ 表示第 $i$ 个亭子的坐标是 $(i,h_i)$。
## 输出格式

对所有的 $1\leq l\leq r\leq n$ 计算：如果事先已知了可怜只会在 $[l,r]$ 这个区间的亭子里面玩耍，那么最少需要多少个保镖，才能让 $[l,r]$ 中的每一个亭子都被监视到。由于输出量太大，可怜的父亲只要你输出所有 $[l,r]$ 的答案的异或即可。

## 样例

### 样例输入 #1
```
3
2 3 1
```
### 样例输出 #1
```
3

```
## 提示

### 样例解释

如果 $r-l+1\leq 2$，那么答案显然是 $1$。

如果 $l=1$，$r=n$，那么答案是 $2$，需要安排两个保镖在 $(2,3),(3,1)$ 两个位置监视可怜。

### 数据范围与提示

对于 $30\%$ 的数据，$n\leq 20$。  
对于 $70\%$ 的数据，$n\leq 500$。  
对于 $100\%$ 的数据，$n\leq 5000$，$1\leq h_i\leq 10^9$。


---

---
title: "[JSOI2013] 哈利波特与死亡圣器"
layout: "post"
diff: 省选/NOI-
pid: P4572
tag: ['2013', '各省省选', '江苏']
---
# [JSOI2013] 哈利波特与死亡圣器
## 题目描述

伏地魔的黑暗势力控制了魔法部与霍格沃茨魔法学校之后，哈利与罗恩、赫敏不得不逃亡在外，隐形遁迹。为了完成校长邓布利多的遗命，一直在暗中寻机销毁伏地魔魂器的哈利，意外地获悉如果他们能够拥有传说中的三件死亡圣器，伏地魔将必死无疑。

在凤凰社成员的帮助下，哈利一行人重新掌控了霍格沃茨。然而此举激怒了伏地魔，他很快率领大批食死徒和黑暗生物向霍格沃茨进军。麦格教授紧急疏散了霍格沃茨的学生，并开始了守卫霍格沃茨的战斗。

霍格沃茨魔法学校的主要建筑共有 $n$ 处，我们编号为 $1$ 到 $n$，这些建筑间由魔法道路连接，整体呈树状分布，即任意两个建筑间有且仅有一条路径相连（路径可以是一条或多条道路组成）。霍格沃茨历经多年风雨，每个建筑自身有许多保护魔法，比如“石墩触动咒”、“降敌陷阱咒”、“统统加护咒”等，只需有人前往施用咒语即能保卫建筑。

现在，伏地魔大军已经到达 $1$ 号建筑——学校大门，凤凰社成员也已经在大门迎战，并且已经启用了大门的保护魔法。然而伏地魔大军势力壮大，保护魔法只能延缓大军的进攻锋芒，他们仍能用一个小时攻克一个建筑，随后整个大军便随机前往与之相邻的另一个建筑（兵贵神速，大军移动过程不需要时间；兵法无常，他们有可能前往已经攻克的建筑）。

目前除了 $1$ 号建筑，其他建筑的保护魔法都尚未被启用，凤凰社决定派出一些成员去其他建筑施用咒语来启动保护魔法。每个凤凰社成员可以瞬间达到任意一个建筑，并用一个小时完成对该建筑保护魔法的启用，之后可以再前往其他的建筑。他们的任务是，保证不论伏地魔大军如何行动，大军所到建筑的保护魔法都已经启用。为了集中更多力量直接打击伏地魔大军，凤凰社希望派出施用咒语的成员数尽可能少。

请你计算，至少需要派出多少位成员。

注：

- 伏地魔大军到达 $1$ 号建筑开始攻击的同时，凤凰社派出成员去其他建筑施咒。

- 当大军攻克某个建筑后，凤凰社成员可以在知道大军下一个小时去哪个建筑的情况下，再决定他们去哪些建筑施咒。这个过程也不需要时间。

- 已经启用过保护魔法的建筑无需再施咒，即便大军攻克该建筑以后某个时候又回到这个建筑，大军也会在这个建筑持续攻击一个小时后再离开。
## 输入格式

第一行一个整数 $n$，表示建筑的数量。

接下来 $n-1$ 行，每行两个整数 $u,v$，表示建筑 $u$ 和建筑 $v$ 之间有一条魔法道路。

## 输出格式

一行一个整数，表示最少需要派出施用咒语的成员数。
## 样例

### 样例输入 #1
```
7
1 2
1 3
2 5
2 6
7 2
4 1
```
### 样例输出 #1
```
3
```
## 提示

### 数据范围

对于 $100\%$ 的数据，$1\leq n\leq 3\times 10^5$。


---

---
title: "[FJOI2014] 树的重心"
layout: "post"
diff: 省选/NOI-
pid: P4582
tag: ['2014', '各省省选', '福建']
---
# [FJOI2014] 树的重心
## 题目描述

给定一个 $n$ 个点的树，每个点的编号从 $1 \sim n$ ，问这个树有多少不同的连通子树，和这个树有相同的重心。

其中 $n$ 个点的树指的是 $n$ 个点的最小连通图，显然 $n$ 个点的树有 $n-1$ 条边，去掉这 $n-1$ 条边中的任何一条，原图都不再联通，任意两个点之间由唯一一条路径相连。

对于一个树，树的重心定义为：删掉某点 $i$ 后，若剩余 $k$ 个连通分量，那么定义 $d(i)$ 为这些连通分量中点的个数的最大值，所谓重心，就是使得 $d(i)$ 最小的点 $i$。

基于以上定义，一个树的重心可能会有一个或者两个，题中所要求的联通子树，其重心编号和个数必须和原树的完全一样。

找出给定的树中有多少联通的子树和这个树有相同的重心。输出答案 $\bmod 10007$ 后的结果。
## 输入格式

第 $1$ 行中给出正整数 $Q$，表示该组数据中有多少组测试样例。

每组样例首先输入一个整数 $n$（$0 < n \le 200$），表示该组样例中输入的树包含 $n$ 个点，之后 $n-1$ 行，每行输入两整数数 $x,y$（$1 \le x,y \le n$），表示编号为 $x$ 的点和编号为 $y$ 的点之间存在一条边，所有点的编号从 $1 \sim n$。

## 输出格式

首先输出样例编号，之后输出满足条件的子树的个数，由于这个数字较大，你只需要输出这个数字 $\bmod\ 10007$ 后的结果，详见输出示例，请严格按照输出实例中的格式输出。

## 样例

### 样例输入 #1
```
3
2
1 2
3
1 2
2 3
5
1 2
1 3
2 4
2 5
```
### 样例输出 #1
```
Case 1: 1
Case 2: 2
Case 3: 6
```
## 提示

对于 $100 \%$ 的数据，满足 $1 \le Q \le 50, 1 \le n \le 200$。


---

---
title: "[FJOI2015] 世界树"
layout: "post"
diff: 省选/NOI-
pid: P4583
tag: ['2015', '各省省选', '福建']
---
# [FJOI2015] 世界树
## 题目描述

奥丁杀死的巨人伊米尔后，从伊米尔的尸体上生长出来一株巨大的梣树，它是整个宇宙的核心，被称为世界之树，这个巨木的枝干构成了整个世界，它被神秘的奥术力量所守护。

奥丁发现，世界树的每个节点至多有两棵子树，其蕴含的奥术力量是子树奥术力量的最大值 $+1$，如果一个节点没有子树，其奥术力量为 $1$，这些节点被称为“源”。

世界树在悠长的岁月里形成了奇妙的魔法平衡，具体来说，它的左子树与右子树的奥术力量的差的绝对值不会超过 $1$。若一个节点只有一棵子树（不妨设为左子树），则右子树的奥术力量视为 $0$。

现在奥丁想知道，在 $n$ 个节点的世界树中，最高和最低的两个“源”（即叶子节点）的深度差最大是多少？
## 输入格式

第一行一个整数 $T$，表示数据组数。

以下 $T$ 行，每行一个整数 $n$ 表示世界树的节点数。
## 输出格式

$T$ 行，每行一个整数表示任意两个“源”的奥术力量的差的最大值。
## 样例

### 样例输入 #1
```
2
5
12345
```
### 样例输出 #1
```
1
9
```
## 提示

对于 $100\%$ 的数据，$1\leq n\leq 10^{10000}$，$T\leq 50$。


---

---
title: "[FJOI2015] 带子串包含约束LCS问题"
layout: "post"
diff: 省选/NOI-
pid: P4584
tag: ['2015', '各省省选', '福建']
---
# [FJOI2015] 带子串包含约束LCS问题
## 题目描述

带有子串包含约束的最长公共子序列问题可以具体表述如下。
 
给定2个长度分别为n和m的序列X和Y，以及一个子串包含约束集S。

S中共有k个字符串$S=\{S_1,S_2,…,S_k\}$，其中字符串$S_i$的长度为$l_i$，1≤i≤k。带有子串包含约束的最长公共子序列问题就是要找出X和Y的包含约束集S中所有字符串为其子串的最长公共子序列。 

例如，如果给定的序列X和Y分别为X=actaagacct, Y=gacctacctc，子串包含约束集S={ata, tact}，则子序列actacct是X和Y的一个无约束的最长公共子序列，而包含约束集S中所有字符串为其子串的一个最长公共子序列是atact 。 
在本题中请特别关注子串与子序列的区别。字符串$T=t_1…t_n$的子串是一个形如$T$’$=t_1+i…t_m+i$的字符串，其中，0≤i，m+i≤n。例如，T=abcdefg，则bcd是T 的一个子串，而bce是T的一个子序列，但不是T 的子串。

设计一个算法，找出给定序列X和Y带有子串包含约束S的最长公共子序列。 
## 输入格式

第1行中给出正整数n,m,k，m＜300, n＜300, k＜6。n和m分别表示给定序列X和Y的长度。k表示子串包含约束集S中共有k个字符串。

第2行中有k个整数$l_i$，$0≤l_i≤300,1≤i≤k$，分别表示子串包含约束集S中k个字符串的长度。

第3行和第4行分别给出序列X和Y 。

接下来k行每行一个字符串$S_i$
## 输出格式

将计算出的X和Y带子串包含约束S的最长公共子序列的长度输出。
## 样例

### 样例输入 #1
```
10 10 2
3 4
actaagacct
gacctacctc
ata
tact
```
### 样例输出 #1
```
5
```
## 提示

字符串仅包含大小写字母.


---

---
title: "[TJOI2018] 碱基序列"
layout: "post"
diff: 省选/NOI-
pid: P4591
tag: ['2018', '各省省选', '天津']
---
# [TJOI2018] 碱基序列
## 题目描述

小豆参加了生物实验室。在实验室里，他主要研究蛋白质。他现在研究的蛋白质是由 $k$ 个氨基酸按一定顺序构成的。每一个氨基酸都可能有 $a$ 种碱基序列 $s_{i,j}$ 构成。

现在小豆有一个碱基串 $s$，小豆想知道在这个碱基上都多少种不同的组合方式可能得到这个蛋白质。即求由 $k$ 段字符串有序合并成的字符串 $s_1$，有多少种不同方式能够匹配字符串 $s$，其中 $k$ 段字符串的选法不同，或者与 $s$ 匹配上的位置不同认为是不同的方式。
## 输入格式


第一行一个数，表示这个蛋白质由 $k$ 个氨基酸组成。

第二行一个字符串 $s$，表示小豆现在有的碱基串。

第三行开始接下来 $k$ 行表示第 $i$ 个氨基酸可能的碱基序列，对于第 $i$ 个氨基酸，$a_i$ 表示这个氨基酸可能的碱基序列种数，接下来 $a_i$ 个字符串表示这 $a_i$ 种可能的碱基序列，用空格隔开。

## 输出格式

输出一个数目标是不同的方案数（不同的方案数是指不同的子碱基串或者相同的碱基串不同的氨基酸排列方式）。

答案对 $10^9+7$ 取模。
## 样例

### 样例输入 #1
```
2
ABC
2 A AB
2 C BC
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
2
AAA
2 A AA
2 A AA
```
### 样例输出 #2
```
4
```
## 提示

### 样例 1 解释

- 第一个选 $\tt A$ 第二个选 $\tt C$，得到 $\tt AC$ 能够与 $\tt ABC$ 产生 $0$ 种匹配方式；
- 第一个选 $\tt A$ 第二个选 $\tt BC$，得到 $\tt ABC$ 能够与 $\tt ABC$ 产生 $1$ 种匹配方式；
- 第一个选 $\tt AB$ 第二个选 $\tt C$，得到 $\tt ABC$ 能够与 $\tt ABC$ 产生 $1$ 种匹配方式；
- 第一个选 $\tt AB$ 第二个选 $\tt BC$，得到 $\tt ABBC$ 能够与 $\tt ABC$ 产生 $0$ 种匹配方式。

所以一共 $2$ 种。

### 样例 2 解释

- 第一个选 $\tt A$ 第二个选 $\tt A$，得到 $\tt AA$ 能够与 $\tt AAA$ 产生 $2$ 种匹配方式；
- 第一个选 $\tt A$ 第二个选 $\tt AA$，得到 $\tt AAA$ 能够与 $\tt AAA$ 产生 $1$ 种匹配方式；
- 第一个选 $\tt AA$ 第二个选 $\tt A$，得到 $\tt AAA$ 能够与 $\tt AAA$ 产生 $1$ 种匹配方式；
- 第一个选 $\tt AA$ 第二个选 $\tt AA$,得到 $\tt AAAA$ 能够与 $\tt AAA$ 产生 $0$ 种匹配方式。

所以一共 $4$ 种。

### 数据范围及约定

- 对于 $30\%$ 的数据，$1\leq k\leq 25$，$1\le |s|\leq 10000$，$1\le a_i\leq 3$。
- 对于 $100\%$ 的数据，$1\leq k\leq100$，$1\le |s|\leq 10000$，$1\le a_i \leq10$。碱基序列的长度均不超过 $15$。字符集为大写字母。


---

---
title: "序列 sequence"
layout: "post"
diff: 省选/NOI-
pid: P4597
tag: ['O2优化']
---
# 序列 sequence
## 题目背景

原题 CF13C 数据加强版
## 题目描述

给定一个序列，每次操作可以把某个数 $+1$ 或 $-1$。要求把序列变成非降数列。而且要求修改后的数列只能出现修改前的数。
## 输入格式

第一行，输入一个整数 $n$（$n \leq 5 \times 10^5$），表示有 $n$ 个数字。  
第二行输入 $n$ 个整数，整数的绝对值不超过 $10^9$。
## 输出格式

输出一个数，表示最少的操作次数。
## 样例

### 样例输入 #1
```
5
3 2 -1 2 11

```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
5
2 1 1 1 1

```
### 样例输出 #2
```
1
```
## 提示

对于 $100 \%$ 的数据，$1 \le n \le 5 \times {10}^5$。


---

---
title: "[COCI 2017/2018 #5] Planinarenje"
layout: "post"
diff: 省选/NOI-
pid: P4617
tag: ['2017', 'COCI（克罗地亚）']
---
# [COCI 2017/2018 #5] Planinarenje
## 题目描述

Mirko and Slavko like to hike together. Mirko likes mountain peaks, and Slavko likes valleys.
Because of this, every time they climb to a peak, Slavko decides which valley they are going
to descend to, given that a trail exists to it. Similarly, in each valley, Mirko decides which
peak they are going to climb up to. It will never be possible to directly climb from one peak to
another, or to get from one valley to another valley. In order to make the hiking as fun as
possible, they never visit the same spot twice (whether it’s a peak or a valley). Once they
reach a spot that only leads to spots they’ve visited before, they call the mountain rangers to
pick them up. If the final spot is a peak, Mirko wins, and if it is a valley, Slavko wins.

Naturally, you must already know what your task is: If we assume that both of them play
optimally, who wins? Answer this question for all initial peaks.
## 输入格式

The first line contains two positive integers, ​N and ​M (1 ≤ ​N ≤ 5000, 1 ≤ ​M ≤ min(5000, ​N
·​N
)).
Here ​N denotes the number of peaks and valleys (therefore, there are ​N peaks and ​N
valleys), and ​M
denotes the number of hiking trails.

Each of the following ​M lines contains two positive integers: ​$v_i$ and ​​$d_i$ (1 ≤ ​​$v_i$ , ​​$d_i$ ≤ ​N) that
denote there is a trail between peak ​​$v_i$ and valley ​$d_i$.
Between each peak and valley, there will exist at most one trail.
## 输出格式

You must output ​N
lines. The ​$i^{th}$ line denotes the winner if the starting point is peak ​i
.
## 样例

### 样例输入 #1
```
2 3
1 2
2 2
2 1
```
### 样例输出 #1
```
Slavko
Slavko
```
### 样例输入 #2
```
4 5
2 2
1 2
1 1
1 3
4 2
```
### 样例输出 #2
```
Slavko
Mirko
Mirko
Mirko
```
### 样例输入 #3
```
4 5
1 2
1 3
2 2
2 3
4 1
```
### 样例输出 #3
```
Slavko
Slavko
Mirko
Slavko
```
## 提示

In test cases worth 30% of total points, it will hold 1 ≤ ​N
≤ 10 and 1 ≤ ​M
≤ ​N
·​N
.

In test cases worth an additional 20% of total points, for each two connected spots, there will
exist a unique path between them. In other words, the graph will be a forest.

**Clarification of the second test case:**

Starting from the first peak, Slavko can choose to go to the first valley, so Slavko wins.

Starting from the second peak, Slavko can choose to go to the second valley, after which Mirko wins
by choosing to go to the fourth peak.

Starting from the third peak, there are no trails, so Mirko wins.

Starting from the fourth peak, Slavko must choose to go to the second valley, after which Mirko wins
by choosing the second peak.
## 题目翻译

米尔科$(Mirko)$和斯拉夫科$(Slavko)$喜欢一起远足。米尔科喜欢山峰，斯拉夫科喜欢山谷。正因为如此，每当他们爬上一个山峰，若有连向山谷的路，则斯拉夫科就决定他们要去哪一个山谷。同样地，在每个山谷中，若有连向山峰的路，米尔科就决定他们将爬到哪一个山峰。不可能出现从一个山峰直接攀登到另一个山峰的情况，也不可能出现从一个山谷到另一个山谷的情况。为了使徒步旅行尽可能有趣，他们从不去同一地点两次（无论是一个山峰或一个山谷）。一旦他们到达一个地点，没有其它的地方可去，他们会叫登山者来接他们。如果最后一个点是一个山峰，则米尔科获胜，如果是一个山谷，则斯拉夫科获胜。

现在你的任务是，对于每一个山峰，如果他们从这里出发，并且都采用最优策略，谁会赢？

第一行两个正整数 $N,M$ $(1 ≤ N ≤ 5000, 1 ≤ M ≤ min(5000, N^2))$。$N$ 表示共有 $N$ 个山峰和 $N$ 个山谷。$M$ 表示共有 $M$ 条双向道路。

接下来 $M$ 行，每行两个正整数$v_i,d_i$ $(1 ≤ v_i,d_i≤ N)$ 表示第 $v_i$ 个山峰与第 $d_i$ 个山谷有路相连。

共 $N$ 行，每行一个字符串，第 $i$ 行表示从第 $i$ 个山峰出发的胜利者。

$30\%$的数据 $1 ≤ N≤ 10$

另有$20\%$的数据是森林。


---

---
title: "[SHOI2010] 滚动的正四面体"
layout: "post"
diff: 省选/NOI-
pid: P4627
tag: ['2010', '各省省选', '上海']
---
# [SHOI2010] 滚动的正四面体
## 题目描述

正四面体总共有4个面，每个面都是一个正三角形。现在把它的一个面标记上字母A，如图 3中所示，A标记在底面上：

![](https://cdn.luogu.com.cn/upload/pic/19848.png)

一个正四面体的一次滚动显然有3个方向可以选择：向左（L）、向右（R）、向后（B）。如图 4所示：

![](https://cdn.luogu.com.cn/upload/pic/19850.png)

于是，这个正四面体的滚动过程就可以用一个只包含“L”“R”“B”的字符串来描述。

初始时，正四面体的A面朝下，现在SECSA将给这个正四面体一串滚动指令——当然就是一个这样的字符串——让这个正四面体每秒滚动一下。也就是说，第1秒内正四面体A面朝下，第1秒末执行第一条指令，第2秒末执行第2条指令，依次类推，直至将整个指令串执行完毕。

你的任务就是当SECSA询问你的时候告诉他：这个正四面体在第L秒到第R秒内A面有多少秒朝着地面。

当然，SECSA可能因为对这个正四面体的滚动路径不满意，他随时会修改他的某一条指令。因此你的程序应该能执行下面两个操作：

(1)接受SECSA修个第i条指令的信息

(2)回答SECSA的“在第L秒到第R秒内A面有多少秒朝着地面”的询问

例如，假如原指令串为“LLLLB”，那么第1、4、6秒内A面是朝下的。此时，如果SECSA向你询问第3秒到第6秒的情况，你就应该回答“2”。而SECSA将第3条指令修改为“R”的话，指令串就变成了“LLRLB”，那么正四面体就只有在第1、5秒内A面朝下了。如图 5所示：

![](https://cdn.luogu.com.cn/upload/pic/19851.png)


## 输入格式

输入文件的第一行是一个整数n，表示指令串中包含的指令条数。

输入文件的第二行是一个字符串，共包含n个字符，每个字符是“L”“R”“B”之一，表示初始的指令串。

输入文件的第三行是一个整数m，表示你的程序需要处理的操作总数。

接下去m行，每行描述一个操作，为以下两种格式之一：

(1)0 i c：表示把第i个操作改成c，c为“L”“R”“B”之一

(2)1 L R：表示询问第L秒到第R秒内，A面有多少秒朝下

输入文件保证：1<=i<=n，1<=L<=R<=n+1。
## 输出格式

输出文件对于每一个询问操作依次输出你的程序给出的回答，每个回答为一个整数，占一行。
## 样例

### 样例输入 #1
```
5
LLLLB
3
1 3 6
0 3 R
1 3 6
```
### 样例输出 #1
```
2
1
```
### 样例输入 #2
```
8
LLLLBRRR
7
1 1 9
1 4 7
0 2 R
1 1 9
1 2 9
0 7 B
1 3 5
```
### 样例输出 #2
```
4
2
1
0
0
```
## 提示

第1个样例就是问题描述中的例子

在第2个样例中，按照原指令“LLLLBRRR”，则第1、4、6、9秒内A面向下；按照第一次修改后的指令“LRLLBRRR”，则只有第1秒内A面向下；按照第二次修改后的指令“LRLLBRBR”，则第1、9秒内A面向下。

1<=n<=60000

1<=m<=150000


---

---
title: "[SHOI2015] 聚变反应炉"
layout: "post"
diff: 省选/NOI-
pid: P4629
tag: ['2015', '各省省选', '上海']
---
# [SHOI2015] 聚变反应炉
## 题目描述

曾经发明了零件组装机的发明家 SHTSC 又公开了他的新发明：聚变反应炉——一种可以产生大量清洁能量的神秘装置。

众所周知，利用核聚变产生的能量有两个难点：一是控制核聚变反应的反应强度，二是使用较少的能量激发聚变反应。而 SHTSC 已经完美解决了第一个问题。一个聚变反应炉由若干个相连的聚变块组成，为了能够使得聚变反应可控，SHTSC 保证任意两个聚能块都可以通过相互之间的链接到达，并且没有一个聚能块可以不重复经过一个链接回到它自己。

但是第二个问题 SHTSC 还没有完全解决。在他设计的聚变反应炉当中，每个聚变块都需要一定的初始能量 $d_i$ 来进行激发，不过 SHTSC 不需要手动激发所有聚变块，这是因为一旦一个聚变块被激发，则会向与其直接相连的所有还未被激发的聚变块传送 $c_i$ 个单位的能量。这样后被触发的聚变块可以以更低的初始能量来激发，甚至可能不需要额外的外界能量就可自行激发，从而降低了总激发能量的消耗。现在给出了一个聚变反应炉，求至少要多少能量才能激发所有聚变块。
## 输入格式

第一行一个整数 $n$，表示共有 $n$ 个聚能块，由 $1$ 至 $n$ 编号。  

第二行 $n$ 个整数，依次表示 $d_i$。  

第三行 $n$ 个整数，依次表示 $c_i$。  

以下 $n - 1$ 行每行两个整数 $u, v$，表示编号为 $u$ 和 $v$ 的聚能块是相连的。
## 输出格式

一行一个整数，表示至少需要多少个单位的能量才能激发所有聚变块。
## 样例

### 样例输入 #1
```
5
1 1 1 1 1
1 1 1 1 1
1 2
2 3
3 4
4 5
```
### 样例输出 #1
```
1
```
## 提示

| Case # | $\max\{c_i\}$ | $n$ | 附加限制 |
|:---:|:---:|:---:|:---:|
| 1 | $= 1$ | $\leq 10$ | $c_i = 1$ |
| 2 | $= 1$ | $\leq 100$ | $c_i = 1$ |
| 3 | $= 1$ | $\leq 200$ | $c_i = 1$ |
| 4 | $= 0$ | $\leq 10$ | - |
| 5 | $= 1$ | $\leq 200$ | $c_i = 1$ |
| 6 | $= 1$ | $\leq 200$ | - |
| 7 | $= 1$ | $\leq 100000$ | $c_i = 1$ |
| 8 | $= 0$ | $\leq 100000$ | - |
| 9 | $= 1$ | $\leq 100000$ | - |
| 10 | $= 1$ | $\leq 100000$ | - |
| 11 | $\leq 5$ | $\leq 20$ | - |
| 12 | $\leq 5$ | $\leq 20$ | $c_i$ 均相等 |
| 13 | $\leq 5$ | $\leq 200$ | - |
| 14 | $\leq 5$ | $\leq 200$ | $c_i$ 均相等 |
| 15 | $\leq 5$ | $\leq 200$ | - |
| 16 | $\leq 5$ | $\leq 200$ | - |
| 17 | $\leq 5$ | $\leq 2000$ | $c_i$ 均相等 |
| 18 | $\leq 5$ | $\leq 2000$ | - |
| 19 | $\leq 5$ | $\leq 2000$ | - |
| 20 | $\leq 5$ | $\leq 2000$ | - |

对于所有数据，保证 $1 \le d_i, \sum d_i \le {10}^9$。


---

---
title: "[POI 2004] WYS"
layout: "post"
diff: 省选/NOI-
pid: P4633
tag: ['2004', 'POI（波兰）']
---
# [POI 2004] WYS
## 题目背景

虽然题目名比较毒瘤，但这确实是一个简单题。
## 题目描述

给 $n$ 个互不相交的多边形，这些多边形的边均平行或垂直于坐标轴。定义多边形 $i$ 的深度 $d_i$ 为 $\max\{d_j\}+1$，其中多边形 $j$ 包含多边形 $i$。特别的，若一个多边形不被任何多边形包含，则其深度为 $1$。求深度最大的多边形的深度。
## 输入格式

第一行一个正整数 $n$。

接下来每行描述一个多边形。首先给出一个偶数 $k$ $(4 \leqslant k \leqslant 10000)$，接下来包含 $k$ 个整数: $x_1,x_2,\cdots,x_k$ $(0 \leqslant x_i \leqslant 10^8)$。这些点的坐标分别为 $(x_1, x_2), (x_3, x2), (x_3, x4), (x_5, x_4),\cdots,(x_{k-1}, x_k), (x_1, x_k)$。他们按照逆时针顺序构成多边形。
## 输出格式

输出一个整数表示最大深度。
## 样例

### 样例输入 #1
```
3
4 0 0 10 10
4 3 4 6 8
4 1 1 2 2
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
6
4 1 0 17 12
16 10 4 16 11 2 4 8 2 3 3 2 1 16 3 15 2
8 8 10 3 5 12 8 11 6
6 10 9 15 10 9 7
4 4 6 7 9
4 6 8 5 7
```
### 样例输出 #2
```
5
```
## 提示

对于 $100\%$ 的数据，$n \leqslant 40000, \sum k \leqslant 200000$。


---

---
title: "[SHOI2011] 直线拟合"
layout: "post"
diff: 省选/NOI-
pid: P4636
tag: ['2011', '各省省选', '上海']
---
# [SHOI2011] 直线拟合
## 题目描述

平面上有 $n$ 个点 $v_i(x_i,y_i)$ 。求 $D(l)=\max_{1\le i\le n} dis(v_i,l)$ 的最小可能值，其中变量 $l$ 是平面上的一条直线，函数 $dis(v_i,l)$ 表示直线 $l$ 与点 $v_i$ 之间的距离。
## 输入格式

输入的第一行为一个正整数 $n$ 。接下来 $n$ 行，每行一对整数 $x_i , y_i$​​ ，用一个空格分隔，依次表示这 $n$ 个点的坐标，其中 $|x_i|,|y_i| \le 10^8$ ，且不同的点不会重合。
## 输出格式

输出只有一行，包含一个实数，即 $D(l)$ 的最小值，四舍五入到小数点后两位。
## 样例

### 样例输入 #1
```
6
1 0
2 0
3 0
3 2
4 0
5 0
```
### 样例输出 #1
```
1.00
```
### 样例输入 #2
```
6
-2 -1
-1 2
1 2
2 3
3 3
4 4
```
### 样例输出 #2
```
0.86
```
## 提示

**样例解释 1**

样例 $1$ 中， 取到最小值时的直线 $l$ 为 $y=1$ 。

**样例解释 2**

样例 $2$ 中的 $6$ 个点，以及 $D(l)$ 取到最小值时的直线 $l$ 如图所示。

![1](https://cdn.luogu.com.cn/upload/pic/20067.png)

**数据范围与提示**

测试点 $1$：$n=3$。

测试点 $2 \sim 4$：$3 \le n \le 100$。

测试点 $5 \sim 7$：$100 < n \le 100000$ ，且输入文件如下生成：选定一条线段，每次先在该线段上等概率随机选择一个点，再取离该点最近的整点。

测试点 $8 \sim 10$：$3 < n \le 100000$。


---

---
title: "[SHOI2011] 银行家"
layout: "post"
diff: 省选/NOI-
pid: P4638
tag: ['2011', '各省省选', '上海']
---
# [SHOI2011] 银行家
## 题目描述

你在一家银行工作，任务是帮助客户取出他们存放在保险箱里的金币。

银行里有 $m$ 个保险箱，你没有办法打开这些保险箱，因为钥匙都在客户的手里。一个客户可能有很多个保险箱的钥匙，一个保险箱的钥匙也可能被多个客户拥有。今天早上，经理已经告知，你需要按照顺序接待 $n$ 个客户（任何客户都不会同时到场），你也知道，第 $i$ 个客户会要求取走 $c_i$​​ 枚金币。每个客户来到银行的时候，会打开所有他能打开的保险箱，然后从中取走 $c_i$​​ 枚金币（任何金币都没有区别），如果这些保险箱里的金币数量不足 ，他会感到不高兴，在取走尽量多的金币之后，到你的经理那里去投诉你们银行的服务质量太差了。

你当然不希望“上帝”的投诉让你丢了工作，于是想到了个补救的办法：虽然每个客户走的时候都会把保险箱重新关上，但是你可以在他取金币的时候，偷偷地调整被打开的保险箱里的金币数量，譬如说把 $1$ 号保险里多余的 $5$ 枚放到 $2$ 号里，这样说不定下个客户来的时候，就能取到更多的金币了。

尽管有这样的方法，还是可能没法完成所有客户的要求。然而，你希望，尽量帮助客户取走更多的金币，这样才能消除他们的怒气，保住这份来之不易的工作和薪水。 
## 输入格式

第一行有两个正整数： $m$ 和 $n$ ， $m$ 表示保险柜的数量， $n$ 表示客户的数量。

第二行有 $m$ 个非负正数，表示银行在开始营业前，第 $1$ 号保险柜到第 $m$ 号保险柜的金币数量。 接下来有 $n$ 行，按照前来银行的顺序，依次描述了每个客户的情况。每行的开始都是一个非负整数 $k$ ，接着有 $k$ 个 $1$ 到 $m$ 之间的整数 $a_1,a_2,…,a_k$ ，表示这个客户拥有 $a_1$​​ 号、 $a_2$ 号，直到 $a_k$​​ 号保险箱的钥匙。最后还有一个非负整数 $c_i$​​ ，表示他需要的金币数量。 输入保证所有出现在输入数据中的整数都不超过 $10000$ 。
## 输出格式

输出只需要一个整数，表示所有客户可以取走的金币总数的最大值。
输入保证答案不会超过 $100000$ 。 
## 样例

### 样例输入 #1
```
3 3
3 1 10
2 1 2 2
2 1 3 3
1 2 6
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
2 3
2 3
2 1 2 1
1 2 2
1 2 2
```
### 样例输出 #2
```
5
```
### 样例输入 #3
```
6 6
6 3 2 0 1 3
2 1 2 0
1 3 3
1 1 1
2 2 3 8
2 4 5 2
2 4 6 6
```
### 样例输出 #3
```
15
```
## 提示

### 数据范围

测试点编号 .|n$\le$ .|m$\le$ .
-|-|-
1|30|100
2|40|50
3|100|400
4|100|400
5|100|400
6|200|500
7|300|500
8|400|1500
9|500|2000
10|600|2500


---

---
title: "[SHOI2011] 编译优化"
layout: "post"
diff: 省选/NOI-
pid: P4639
tag: ['2011', '各省省选', '上海', '提交答案']
---
# [SHOI2011] 编译优化
## 题目背景

 
## 题目描述

就像 PASCAL 语言和 C/C++ 语言一样， SH 语言也是一种编程语言。 SH 语言共有 $26$ 个寄存器，用大写拉丁字母 A, B, … , Z 表示。 SH 语言的程序中，第一行依次是这 $26$ 个寄存器的初始值，用空格分隔。程序的第二行起，每一行都是一条命令。 SH 语言有三种命令，如下表所示（在格式这一列中，用下划线代替实际语言中的一个空格）。

-    ``ADD``命令 格式：``ADD_R1_R2``  功能：将寄存器 R2 的值加到寄存器 R1 上。 限制：无。

-    ``GOTO`` 命令 格式：``IF _R_ < _I1_ GOTO _LINE_ I2`` 功能：如果寄存器 R 的值小于立即数 I1 ，则跳转至第 I2 （ $\ge 2$ ）行，否则继续执行下一行。限制：至多出现一次，且只可能出现在第 I2 行之后。

-    ``PRINT`` 命令 格式：``PRINT_R`` 功能：打印寄存器 R 的值。限制：出现且仅出现在最后一行。

现给定一个 SH 语言的程序，请输出 ``PRINT`` 命令打印的值。
## 输入格式

每个输入文件都是一个 SH 语言的程序。输入文件保证：所有寄存器的初始值以及 ``GOTO`` 命令中出现的立即数，均为不超过 $2^{63}-1$ 的非负整数，但程序执行过程中寄存器的值不限于此。
## 输出格式

每个输出文件只有一行，包含一个整数，即 ``PRINT`` 命令所打印的值。
## 样例

### 样例输入 #1
```
0 100 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
ADD A B
IF A < 220 GOTO LINE 2
PRINT A
```
### 样例输出 #1
```
300
```
## 提示

在每个测试点，如果您的输出与标准答案完全一致，您将能得到该测试点的全部分数；否则，您将在该测试点得 $0$ 分。

本题为提交答案题，所有的 $10$ 个输入文件 ``compiler1.in ~ compiler10.in`` 都已存放在题目背景的下载链接中。对于每个输入文件，您需要分别给出相应的输出文件 ``compiler1.out ~ compiler10.out``。

注意：您只需提交输出文件而无需提交任何程序。


---

---
title: "[BJWC2008] 王之财宝"
layout: "post"
diff: 省选/NOI-
pid: P4640
tag: ['2008', '北京']
---
# [BJWC2008] 王之财宝
## 题目描述

《基尔伽美修》是人类历史上第一部英雄史诗，两河流域最杰出的文学作品之一。作品讲述了基尔伽美修一生的传奇故事。在动画Fate/stay night中，基尔伽美修与亚瑟王等传说中的英雄人物一起出现在了现实世界，展开了一场惊天地、泣鬼神的战斗。在记载于12块泥板的史诗中，基尔伽美修与同伴安吉杜一起降伏了森林的守护者——神兽洪芭芭，成为地上最强的王者，同时将世间所有财宝收归手中。王之财宝(Gate of Babylon)成为Fate中金皮卡（基尔伽美修的外号…）炫耀的资本……

一天金皮卡突发奇想：如果从自己无尽的财宝里面，随便抽不超过M件宝具出来砸死敌人的话。一共有多少种搭配方法呢？假设金皮卡一共有N种不同类型的宝具，大部分类型的宝具都有无限多，但其中T种超级神器的数量是有限的。设第i种超级神器的数量不超过$B_i$件。若相同类型的宝具数量相同，则认为是相同的搭配方案。

金皮卡知道方案数会很大，从小数学成绩就好的他挑选了一个质数P，请你帮他计算一下方案数模P后的余数。注意，一件也不选也是一种方案。
## 输入格式

第一行包含4个整数，分别为N，T，M，P

之后T行，每行一个整数，代表$B_i$

$N,M≤10^9$，$P≤10^5$，$B_i≤10^9$

$0≤T≤N$，$M>0$，$B_i>0$，$T≤15$
## 输出格式

仅包含一个整数，即方案数模P后的余数。
## 样例

### 样例输入 #1
```
2 1 10 13
3
```
### 样例输出 #1
```
12
```
## 提示

只有一种超级神器，数量不超过3

当不选择超级神器时，另一种宝具可以挑选0到10件，共11种方案

当选择1件神器出来时，另一种宝具可以挑选0到9件，共10种方案

当挑选2件神器时，共9种方案

挑选3件神器时，共8种方案

一共有11+10+9+8=38种方案，$38\bmod13=12$，于是答案等于12


---

---
title: "[IOI 2007] flood 洪水"
layout: "post"
diff: 省选/NOI-
pid: P4646
tag: ['2007', 'IOI', 'Special Judge']
---
# [IOI 2007] flood 洪水
## 题目描述

1964年的一场灾难性的洪水冲毁了萨格勒布城。洪水袭来时许多建筑的墙被彻底冲毁。在这个题目中，给定了城市在洪水来袭前的简化模型，你的任务是确定洪水过后哪些墙没有被冲毁。

简化模型由平面上的$N$个点和$W$堵墙构成。每堵墙连接两个点，没有任何一堵墙通过其它点。模型具有如下性质：

- 不存在两堵墙相交或者重合的情况，但是两堵墙可以在端点相连；
- 每堵墙或者平行于坐标系的横轴，或者平行于坐标系的纵轴。

最开始，整个坐标平面都是干的。在零时刻，洪水将城市的外围淹没（城市的外围是指没有被墙围起来的区域）。一个小时之后，所有一边是水，一边是空气的墙在水的压力下都会倒塌。于是洪水又会吞没那些没有被完好的墙围住的区域。接下来又有一些墙面临一边是水一边是空气，将要被洪水冲毁的局面。又过了一个小时，这些墙也被冲毁了。这样的过程不断重复，直到洪水淹没整个城市。

下图给出了洪水侵袭过程的一个例子。

![](https://cdn.luogu.com.cn/upload/pic/20664.png )

给定$N$个点的坐标和连接这些点的$W$堵墙的描述，编程确定洪水过后，哪些墙会被留下来。 
## 输入格式

输入的第一行包含一个整数$N(2 \leq N \leq 100 000)$, 表示平面上的点的个数。 接下来的$N$行每行包含两个整数$X$和$Y$（都是$0$到$1 000 000$之间（包括$0$和$1 000 000$）的整数），表示点的坐标。所有点按照它们被给出的顺序编号为$1$到$N$。没有两个点在同一位置上。 接下来一行包含一个整数$W(1 \leq W \leq 2N)$，表示墙的数目。 接下来$W$行每行包含两个不同的整数$A$和$B(1 \leq A \leq N, 1 \leq B \leq N)$，表示在洪水到来前，有一堵墙连接$A$和$B$。这些墙按照它们被给出的顺序编号为$1$到$W$。
## 输出格式

输出的第一行包含一个整数$K$，表示洪水过后留下的墙的数目。

接下来的$K$行包含留下的墙的序号，每行一个，序号可以以任意顺序输出。
## 样例

### 样例输入 #1
```
15 
1 1 
8 1 
4 2 
7 2 
2 3 
4 3 
6 3 
2 5 
4 5 
6 5 
4 6 
7 6 
1 8 
4 8 
8 8 
17 
1 2 
2 15 
15 14 
14 13 
13 1 
14 11 
11 12 
12 4 
4 3 
3 6 
6 5 
5 8 
8 9 
9 11 
9 10 
10 7 
7 6 
```
### 样例输出 #1
```
4 
6 
15 
16 
17 
```
## 提示

这个样例对应前页图中的例子。

有40分的测试点，所有坐标小于等于$500$。

在上面的测试点和另外15分的测试点中，点的个数不超过$500$个。


---

---
title: "[IOI 2007] sails 船帆"
layout: "post"
diff: 省选/NOI-
pid: P4647
tag: ['2007', 'IOI']
---
# [IOI 2007] sails 船帆
## 题目描述

让我们来建造一艘新的海盗船。船上有 N个旗杆，每根旗杆被分成单位长度的小节。旗杆的长度等于它被分成的小节的数目。每根旗杆上会挂一些帆，每张帆正好占据旗杆上的一个小节。在一根旗杆上的帆可以任意排布在不同的小节中，但是每个小节上至多能挂一张帆。

在风中，帆的不同排布方式会产生不同的推动力。靠近船头的帆比它后面的相同高度上的帆获得的推动力少，换句话说，靠近船头的帆的推动力由于受它后面相同高度的帆的影响而打了折扣。对于任意一张帆，它的推动力折扣等于在它后面并且和它在同一高度的帆的数目。

所有帆的任意一种位置组合的推动力折扣总和等于在该位置下所有帆的推动力折扣的总和。

![](https://cdn.luogu.com.cn/upload/pic/20670.png )

这条船上有6个旗杆，从前（图上的左边）到后的高度分别是3，5，4，2，4和3。图中所示的帆的位置组合的总推动力折扣是10。上图给出了每张帆自己的推动力折扣。

给定N个旗杆的高度和每个旗杆上挂的帆的数目，写一个程序求出所有位置组合中的可能达到的最小的总推动力折扣。 
## 输入格式

第一行包含一个整数$N(2 \leq N \leq 100 000)$，表示旗杆的数目。 接下来的N行每行包含两个整数$H$和$K(1 \leq H \leq 100 000, 1 \leq K \leq H)$，分别表示对应旗杆的高度及其上的帆的数目。旗杆按照从船头到船尾的顺序给出。 
## 输出格式

输出包含一个整数，表示可以达到的最小的总推动力折扣。

注意：计算和输出结果时使用64位整数类型（在C/C++中用```long long```, 在Pascal中用```int64```）。
## 样例

### 样例输入 #1
```
6 
3 2 
5 3 
4 1 
2 1 
4 3 
3 2 
```
### 样例输出 #1
```
10
```
## 提示

这个样例数据和上页中图示的样例相同。

在 25 分的测试数据中，帆的不同位置组合的总数目不超过 $1,000,000$ 。


---

---
title: "[CEOI 2017] One-Way Streets"
layout: "post"
diff: 省选/NOI-
pid: P4652
tag: ['2017', 'CEOI（中欧）']
---
# [CEOI 2017] One-Way Streets
## 题目描述

给定一张 $n$ 个点 $m$ 条边的无向图，现在想要把这张图定向。

有 $p$ 个限制条件，每个条件形如 $(x_i,y_i)$，表示在新的有向图当中，$x_i$ 要能够沿着一些边走到 $y_i$​​。

现在请你求出，每条边的方向是否能够唯一确定。同时请给出这些能够唯一确定的边的方向。

数据保证有解。
## 输入格式

第一行两个空格隔开的正整数 $n,m$ 。

接下来 $m$ 行，每行两个空格隔开的正整数 $a_i,b_i$​​，表示 $a_i,b_i$​​ 之间有一条边。

接下来一行一个整数 $p$，表示限制条件的个数。

接下来 $p$ 行，每行两个空格隔开的正整数 $x_i,y_i$，描述一个 $(x_i,y_i)$ 的限制条件。
## 输出格式

输出一行一个长度为 $m$ 的字符串，表示每条边的答案：

-    若第 $i$ 条边必须得要是 $a_i$​​ 指向 $b_i$ 的，那么这个字符串的第 $i$ 个字符应当为 ``R``；

-    若第 $i$ 条边必须得要是 $b_i$​​ 指向 $a_i$​​ 的，那么这个字符串的第 $i$ 个字符应当为 ``L``；

-    否则，若第 $i$ 条边的方向无法唯一确定，那么这个字符串的第 $i$ 个字符应当为 ``B``。

## 样例

### 样例输入 #1
```
5 6
1 2
1 2
4 3
2 3
1 3
5 1
2
4 5
1 3
```
### 样例输出 #1
```
BBRBBL
```
## 提示

对于所有测试点，有 $1\le n,m,p\le 100\ 000;1\le a_i,b_i,x_i,y_i\le n$。


---

---
title: "[BalticOI 2008] 阀门"
layout: "post"
diff: 省选/NOI-
pid: P4659
tag: ['2008', 'Special Judge', 'BalticOI（波罗的海）']
---
# [BalticOI 2008] 阀门
## 题目描述

成为码农多年的你，已经厌倦了码农生活。你决定跳槽，去做一些不一样的事情。

正在寻找下一份工作的你，被一份水产养殖的工作吸引住了。“太酷了！”并且，鱼是很好的生物 嗯切绘也是这么想的 。所以你毫不犹豫地去应聘了。幸运的是，你成功拿到了 Offer。今天是你工作的第一天。

你的老板已经给你分配了任务：分隔两个蓄水池。你手上的操作指南告诉了你如下信息：

这两个蓄水池之间有一些管道连通，每个管道有两个阀门。当两个阀门同时开启时，这个管道就处于开启状态，反之处于关闭状态。阀门用开关控制。同一个开关会控制一些阀门，但是每一个阀门都只被一个开关控制。有可能一个管道上的两个阀门被同一个开关控制，也可能有开关不控制任何阀门。 

![0](https://i.loli.net/2018/02/19/5a8ac86221c4b.png)

开关以以下两种方式控制阀门：

-    当开关闭合时阀门打开，当开关断开时阀门关闭
-    当开关闭合时阀门关闭，当开关断开时阀门打开

玩了一会儿开关之后你突然意识到你的编程经历会十分有用。给出每个阀门被哪个开关所控制，判断是否可能关闭所有管道，如果可以，找出这种合法配置下每一个开关的状态。 
## 输入格式

标准输入的第一行包含两个整数 $n$ 和 $m$，分别表示管道数和开关数。开关被从 $1$ 到 $m$ 标号。

接下来的 $n$ 行描述管道，一行用四个整数 $a,s_a,b,s_b$​​ 描述一个管道，$a,b$ 代表控制该管道的开关（$1\le a,b\le m$）。$s_a$ 和 $s_b$​ 为 $0$ 或 $1$，并与描述中的操作模式相符，$s_i=0$ 表示当且仅当开关 $i$ 断开时阀门关闭，$s_i=1$ 表示当且仅当开关 $i$ 闭合时阀门关闭。 
## 输出格式

如果有可能关闭所有管道，标准输出应包含 $m$ 行，如果开关 $i$ 断开，第 $i$ 行应输出 $0$，如果开关 $i$ 闭合，第 $i$ 行应输出 $1$。如果有很多可能的答案，你的程序可以输出任意一种。

如果不可能关闭所有管道，你的程序应输出一行，包含一个单词 ``IMPOSSIBLE``。 
## 样例

### 样例输入 #1
```
3 2
1 0 2 1
1 0 2 0
1 1 2 1
```
### 样例输出 #1
```
0
1
```
### 样例输入 #2
```
2 1
1 0 1 0
1 1 1 1
```
### 样例输出 #2
```
IMPOSSIBLE
```
## 提示

**数据范围**

对于 $30\%$ 的数据，$n\le 40, m\le 20$。

对于所有数据，$1\le n\le 2.5\times 10^5, 1\le m\le 5\times 10^5$​​。 


---

---
title: "[BalticOI 2008] 手套"
layout: "post"
diff: 省选/NOI-
pid: P4660
tag: ['2008', 'Special Judge', 'BalticOI（波罗的海）']
---
# [BalticOI 2008] 手套
## 题目描述

化学教授名曰“酸雨”。在他家黑暗的地下室，有两个装有手套的抽屉，一个抽屉装左手手套，另一个装右手手套。每个抽屉中有 $n$ 种不同颜色的手套。教授知道在每个抽屉中，每种颜色的手套数目（在不同抽屉中，相同颜色的手套数目可能不同）。保证他能够找到同色的一副手套。

只有教授带相同颜色的一副手套时试验才可能会成功（与哪种颜色无关），所以在每次试验开始之前他都要去地下室从抽屉中拿手套，并且希望至少有一副一样颜色的手套。但是地下室太黑了，不出地下室就不可能分辨出任何手套的颜色。教授讨厌去地下室超过一次，同时也讨厌拿一堆手套回实验室（以防没有相同颜色的手套）。

#任务

写一个程序能够：

-    从标准输入中读取颜色种数和每种颜色手套的数目
-    计算在确保拿出的手套中有一副颜色相同的手套的情况下需要取出手套的最小数目（需要明确指出从每个抽屉中取出手套的确切数目）
-    将结果写到标准输出

## 输入格式

标准输入的第一行包含一个正整数 $n$ （$1\le n\le 20$）描述不同的颜色种数。颜色从 $1$ 到 $n$ 编号；

输入第二行包含 $n$ 个非负整数 $0\le a_1,a_2,\cdots ,a_n\le 10^8$，$a_i$​​ 表示在装左手手套的抽屉中第 $i$ 种颜色手套的数目；

输入第三行包含 $n$ 个非负整数 $0\le b_1,b_2,\cdots ,b_n\le 10^8$​，$b_i$ 表示在装右手手套的抽屉中第 $i$ 种颜色手套的数目。 
## 输出格式

标准输出第一行包含单独一个整数，表示从装左手手套抽屉中取出的手套数。第二行包含单独一个整数，表示从装右手手套抽屉中取出的手套数。这两个数的总和应尽量小。

如果有多种正确答案，你的程序可以输出任意一组。
## 样例

### 样例输入 #1
```
4
0 7 1 6
1 5 0 6
```
### 样例输出 #1
```
2
8
```
## 提示

有 $40$ 分 $n\le 4$ 且 $a_i,b_i\le 10$。 

对于所有数据，$1\le n\le 20$。


---

---
title: "[BalticOI 2008] 魔法石"
layout: "post"
diff: 省选/NOI-
pid: P4663
tag: ['2008', 'BalticOI（波罗的海）']
---
# [BalticOI 2008] 魔法石
## 题目描述

知名的石头 $\text{Xi-n-k}$ 只能在 Wonderland 中找到，这样的石头只是一种碑文只有字母 ``X`` 和 ``I`` 的花岗岩板。每个石板包含 $n$ 个字母。每个石板上有不超过 $k$ 个位置 ``X`` 和 ``I`` 相邻。

石板的顶部和底部不是固定的，所以石头可以旋转，变为倒立状态。例如下面这两个图片描述的是一样的石头。 

![0](https://i.loli.net/2018/02/20/5a8ba0ad731f2.png)

(看同样石头的两种方式。这种石头的种类是 $\text{Xi-8-3}$，也是 $\text{Xi-8-4}$（当然也可以是 $\text{Xi-8-}k$，$k \ge 3$））。

现在 Wonderland 中任意两块魔法石都不是一样的，即两块石头都没有相同的碑文（注意旋转 $180^\circ$​​ 是允许的）。

如果可以以两种不同方式（用旋转 $180^\circ$​​ 的方式）读一块石头的碑文，那么对于这块石头，碑文的正规阅读方式被定义为两种阅读方式字典序小的那种。

如果一块石头的碑文是对称的，即旋转 $180^\circ$​​ 并不改变碑文，那么对于这块石头，碑文的的正规阅读方式被定义为这种独一无二的阅读方式。

例如：有六种 $\text{Xi-3-2}$ 魔法石，它们的正规阅读方式以字典序写出为：``III``，``IIX``，``IXI``，``IXX``，``XIX`` 和 ``XXX``。

Alice 是一个研究 Wonderland 的魔法石的专家。她想要创建一个 $\text{Xi-n-k}$ 魔法石的正规阅读方式字典（对于一些特定的 $n$ 和 $k$）。对于给出的 $i$，在字典中第 $i$ 个位置应该是什么碑文呢？

#任务

写一个程序能够：

-    从标准输入中读取数字 $n$，$k$，$i$
-    判定对于 $\text{Xi-n-k}$ 魔法石，第 $i$ 个正规阅读方式（按字典序）
-    输出结果到标准输出

## 输入格式

标准输入只有一行，包含三个数 $n$，$k$，$i$，用一个空格分开。
## 输出格式

标准输出只有一行，应该包含 $\text{Xi-n-k}$ 魔法石，第 $i$ 个正规阅读方式（按字典序）。

如果 $\text{Xi-n-k}$ 魔法石的数量比 $i$ 小，那么只输出一行一个短语 ``NO SUCH STONE``。 
## 样例

### 样例输入 #1
```
3 2 5
```
### 样例输出 #1
```
XIX
```
### 样例输入 #2
```
3 2 7
```
### 样例输出 #2
```
NO SUCH STONE
```
## 提示

**数据范围与提示**

对于全部数据，$0\le k<n\le 60,0<i<10^{18}$​​。

注：我们说 $\text{A}$ 的碑文字典序比 $\text{B}$ 小（假设 $\text{A}$ 和 $\text{B}$ 的碑文长度相同），当且仅当在第一个碑文不同的位置 $\text{A}$ 包含 ``I`` 且 $\text{B}$ 包含 ``X`` 。



---

---
title: "[IOI 2008] Fish"
layout: "post"
diff: 省选/NOI-
pid: P4684
tag: ['2008', 'IOI']
---
# [IOI 2008] Fish
## 题目描述

据Scheherazade说，在很远的沙漠中有一个湖。湖中起初有$F$条鱼。选择最值钱的$K$种宝石，对$F$条鱼的每一条只喂给它一块宝石。注意，因为$K$可能小于$F$，两条或更多的鱼可能会吞下同一种宝石。

随着时间的流逝，有些鱼吃掉了别的鱼。一条鱼能够吃掉另一条鱼，当且仅当它的长度至少是被吃掉的鱼的两倍($A$ 能吃掉$B$ 当且仅当$L_A \geq 2L_B$)。没有规则说明一条鱼何时会吃掉另一条鱼。有的鱼可能会一条接一条地吃掉几条小鱼，而有的鱼可能不吃别的鱼，即使它们有能力吃。当一条鱼吃掉一条小鱼时，它的身长并不改变，但是小鱼腹中的宝石会完好无损地进到大鱼腹中。

据Scheherazade说，如果你能够找到那个湖，你会被准许捕捉一条鱼，并且得到鱼腹中的宝石。你很想试试运气，但是在出发前很想知道捉到一条鱼可能会有多少种不同的宝石组合。

写一个程序，给定每条鱼的长度以及其最初吞食的宝石的种类，找出鱼腹中宝石不同组合的数量对给定整数$M$取模的值。组合由每种宝石的数量定义，与宝石的排列顺序无关。同一类宝石中任意两块是没有区别的。 
## 输入格式

你的程序需要从标准输入上读入下列数据：
- 第一行是整数$F$, 即湖中最初鱼的数量。
- 第二行是整数$K$, 即宝石的种类数。不同类型的宝石分别用从 $1$ 到 $K$的整数表示。 
- 第三行是整数$M$。 
- 以后 $F$ 行中的每一行用由一个空格分隔的两个整数描述一条鱼：按顺序分别是鱼的长度以及鱼腹中的宝石的类型。

注意: 在所有的测试用例中，$K$ 种宝石中的每一种都会至少有一块。 
## 输出格式

你的程序需要在标准输出上输出一个介于$0$和$M-1$(包含)的整数，即宝石所有可能的不同组合数量模$M$，占一行。注意，在问题求解中，数值$M$除了简化计算外没有其他的作用。
## 样例

### 样例输入 #1
```
5
3
7
2 2
5 1
8 3
4 1
2 3

```
### 样例输出 #1
```
4
```
## 提示

### 限制

有总计70分的测试数据，其中$K$不超过$7,000$。在这些测试数据中，有总计25分的测试数据的$K$不超过$20$。

对于所有的测试数据，$1 \leq F \leq 500,000$，$1 \leq K \leq F$，$2 \leq M \leq 30,000$，$1 \leq L_X \leq 1,000,000,000$。

### 样例说明

有 $11$ 种可能的组合，所以你需要输出$4$，也就是$11$ 模 $7$。这些可能的组合是: $[1] [1,2] [1,2,3] [1,2,3,3] [1,3] [1,3,3] [2] [2,3] [2,3,3] [3]$ 和 $[3,3]$。(对每一种组合, 我们列出其所包含的宝石。 例如，$[2,3,3]$ 包含一块$2$型宝石和两块$3$型宝石)

这些组合可以由下述方式获得:

$[1]$: 如果你在第二条鱼 (或第四条) 吃掉任何其它鱼之前捕捉到它。

$[1,2]$: 如果第二条鱼吃掉第一条鱼, 它就会有一块 $1$ 型宝石(它在初始时刻吞下的) 和一块2型宝石 (从第一条鱼腹中得到的)。

$[1,2,3]$: 一种可能的途径是: 第四条鱼吃掉第一条鱼，然后第三条鱼又吃掉它。如果你此时捉到了第三条鱼，那它腹中就有这三种宝石一样一块

$[1,2,3,3]$: 第四条鱼吃掉第一条鱼，第三条鱼吃掉第四条鱼，第三条鱼吃掉第五条鱼，你捉到了第三条鱼。

$[1,3]$: 第三条鱼吃掉第四条鱼，你捉到了第三条鱼。

$[1,3,3]$: 第三条鱼吃掉第五条鱼，第三条鱼吃掉第四条鱼，你捉到了第三条鱼。

$[2]$: 你捉到了第一条鱼。

$[2,3]$: 第三条鱼吃掉第一条鱼，你捉到了第三条鱼

$[2,3,3]$: 第三条鱼吃掉第一条鱼，第三条鱼吃掉第五条鱼，你捉到了第三条鱼。

$[3]$: 你捉到了第三条鱼。

$[3,3]$: 第三条鱼吃掉第五条鱼，你捉到了第三条鱼。


---

---
title: "[IOI 2008] Linear Garden"
layout: "post"
diff: 省选/NOI-
pid: P4685
tag: ['2008', 'IOI']
---
# [IOI 2008] Linear Garden
## 题目描述

拉美西斯二世刚刚获胜归来。为了纪念这一胜利，他决定建造一座壮观的花园。这个花园里的植物排成一行，从他在卢克索的宫殿直达卡纳克神庙。所种植的植物只有莲花和纸莎草，因为它们分别代表上埃及和下埃及。

这个花园中必须有$N$棵植物，并且必须保持平衡，即在花园中任取一段，其中莲花和纸莎草的棵数之差不能超过$2$。

花园可以被表示为由字母```L```（莲花）和```P```（纸莎草）组成的字符串。例如，当$N=5$时，有$14$种可能的平衡花园，按照字母排序如下：```LLPLP```，```LLPPL```，```LPLLP```，```LPLPL```，```LPLPP```， ```LPPLL```，```LPPLP```，```PLLPL```，```PLLPP```，```PLPLL```，```PLPLP```，```PLPPL```，```PPLLP``` 和 ```PPLPL```。

给定长度的所有可能的平衡花园可按字母顺序排序，并从$1$开始编号。例如，当$N=5$时，第$12$号花园是```PLPPL```。 

写一个程序，给定植物棵数$N$和一个表示平衡花园的字符串，计算该花园的序号模$M$的结果，其中$M$是一个给定的整数。 注意，在问题求解中，数值 $M$ 除了简化计算外没有其他的作用。 
## 输入格式

第一行是整数$N$，说明花园中植物的数量。第二行是整数$M$。第三行是长度为$N$的由字符```L```或```P```组成的字符串，表示一个平衡的花园。
## 输出格式

你的程序需要向标准输出上输出一个介于$0$和$M-1$（含）的整数，占一行，表示该花园的序号模$M$。
## 样例

### 样例输入 #1
```
5
7
PLPPL
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
12
10000
LPLLPLPPLPLL
```
### 样例输出 #2
```
39
```
## 提示

有总分40分的测试点的$N$不超过$40$。

对于所有测试点，$1 \leq N \leq 1,000,000$，$7 \leq M \leq 10,000,000$。 

### 样例说明

第一个样例中，实际的序号是12。因此输出的是12模7，即5。


---

---
title: "[PA 2013] Raper"
layout: "post"
diff: 省选/NOI-
pid: P4694
tag: ['2013', 'O2优化', 'PA（波兰）']
---
# [PA 2013] Raper
## 题目描述

你需要生产 $k$ 张光盘。每张光盘都要经过两道工序：先在 A 工厂进行挤压，再送到 B 工厂涂上反光层。

你知道每天 A、B 工厂分别加工一张光盘的花费。你现在有 $n$ 天时间，每天可以先送一张光盘到 A 工厂（或者不送），然后再送一张已经在 A 工厂加工过的光盘到 B 工厂（或者不送），每家工厂一天只能对一张光盘进行操作，同一张光盘在一天内生产出来是允许的。我们假定将未加工的或半成品的光盘保存起来不需要费用。

求生产出 $k$ 张光盘的最小花费。
## 输入格式

第一行包含两个整数 $n, k$，表示有 $n$ 天，要生产 $k$ 张光盘。

第二行包含 $n$ 个整数，第 $i$ 个整数表示第 $i$ 天送到 A 工厂加工光盘的花费。

第三行包含 $n$ 个整数，第 $i$ 个整数表示第 $i$ 天送到 B 工厂加工光盘的花费。
## 输出格式

输出一行一个整数，表示最小花费。
## 样例

### 样例输入 #1
```
8 4
3 8 7 9 9 4 6 8
2 5 9 4 3 8 9 1
```
### 样例输出 #1
```
32
```
## 提示

保证 $1 \leqslant k \leqslant n \leqslant 5 \times 10^5,$ $1 \leqslant  a_i, b_i \leqslant 10^9$。

注：添加了 2 组 Hack 数据，如未通过将扣除 3 分。


---

---
title: "[CEOI 2011] Matching"
layout: "post"
diff: 省选/NOI-
pid: P4696
tag: ['2011', 'CEOI（中欧）']
---
# [CEOI 2011] Matching
## 题目描述

对于整数序列 $(a_1,a_2,\cdots,a_n)$ 和 $1\sim n$ 的排列 $(p_1,p_2,\cdots,p_n)$，称 $(a_1,a_2,\cdots,a_n)$ 符合 $(p_1,p_2,\cdots,p_n)$，当且仅当：

-    $\{a\}$ 中任意两个数字互不相同；

-    将 $(a_1,a_2,\cdots,a_n)$ 从小到大排序后，将会得到 $(a_{p_1},a_{p_2},\cdots,a_{p_n})$。

现在给出 $1\sim n$ 的排列 $\{p\}$ 和序列 $h_1,h_2,\cdots,h_m$​​，请你求出哪些 $\{h\}$ 的子串符合排列 $\{p\}$。

## 输入格式

第一行两个空格隔开的正整数 $n,m$。

第二行 $n$ 个空格隔开的正整数，表示排列 $p$。

第三行 $m$ 个空格隔开的正整数，表示序列 $h$。
## 输出格式

第一行一个整数 $k$，表示符合 $\{p\}$ 的子串个数。

第二行 $k$ 个空格隔开的正整数，表示这些子串的起始位置（编号从 $1$ 开始）。请将这些位置按照从小到大的顺序输出。特别地，若 $k=0$，那么你也应当输出一个空行。
## 样例

### 样例输入 #1
```
5 10
2 1 5 3 4
5 6 3 8 12 7 1 10 11 9
```
### 样例输出 #1
```
2
2 6
```
## 提示

对于 $100\%$ 的数据，有 $2\le n\le m\le 1\ 000\ 000;1\le h_i\le 10^9;1\le p_i\le n$，保证 $\{h\}$ 中的元素互不相同，且 $\{p\}$ 是一个排列。


---

---
title: "[CEOI 2011] Hotel"
layout: "post"
diff: 省选/NOI-
pid: P4698
tag: ['2011', 'CEOI（中欧）']
---
# [CEOI 2011] Hotel
## 题目描述

你经营着一家旅馆，这家旅馆有 $n$ 个房间，每个房间有维护费用和容量。其中第 $i$ 个房间的维护费用为 $c_i$，容量为 $p_i$ 人。

现在有 $m$ 个订单，每个订单有两个参数：$v_i,d_i$ ，其中 $v_i$ 表示这个订单支付的租金，$d_i$​​ 表示人数。

你现在得要合理选择一些订单，并放弃其他订单，使得每个选择的订单被安排在同一间房间内，且人数不超过这个房间的容量限制。当然，两个不同的订单也不能被安排在同一间房间内。

现在你想要知道，在最多选出 $o$ 个订单时的最大收益。一个方案的收益的定义为，选出的订单的租金和，减去选出的房间的维护费用和。
## 输入格式

第一行三个空格隔开的整数 $n,m,o$ 。

接下来 $n$ 行，每行两个空格隔开的整数 $c_i,p_i$。

接下来 $m$ 行，每行两个空格隔开的整数 $v_i,d_i$。
## 输出格式

一行一个整数表示最大收益。注意答案可能很大。
## 样例

### 样例输入 #1
```
3 2 2
150 2
400 3
100 2
200 1
700 3
```
### 样例输出 #1
```
400
```
## 提示

**样例 $1$ 解释**

可以将第一个订单安排至第三个房间，将第二个订单安排至第二个房间。

**数据范围**

对于 $100\%$ 的数据，有 $1\le n,m\le 500\ 000;1\le o\le \min(n,m);1\le c_i,p_i,v_i,d_i\le 10^9$，保证 $\forall 1\le i,j\le n$，若 $p_i\lt p_j$，则 $c_i\le c_j$。


---

---
title: "[CEOI 2011] Teams"
layout: "post"
diff: 省选/NOI-
pid: P4699
tag: ['2011', 'Special Judge', 'CEOI（中欧）']
---
# [CEOI 2011] Teams
## 题目描述

有 $n$ 个小朋友要进行比赛，他们要被分为若干队伍。每一个小朋友都有一个要求，其中第 $i$ 个小朋友要求他所在的队伍最少要有 $a_i$ 个人（包括自己）。

现在请你求出一种划分方案，在满足所有小朋友的要求的情况下，最大化队伍的数量。同时在此基础上，请你最小化人数最多的队伍的人数。
## 输入格式

第一行一个数 $n$ 表示小朋友的个数。

接下来 $n$ 行，每行一个数，其中第 $i$ 行的数字为 $a_i$​​ 。
## 输出格式

第一行一个数 $t$ ，表示在你的方案中的队伍数量。

接下来 $t$ 行，每行若干个空格隔开的数字，表示一只队伍。每一行首先输出一个数 $k_i$​​ 表示第 $i$ 只队伍的人数，接下来 $k_i$ 个数依次描述该队伍内的小朋友的编号（从 $1$ 开始）。

若有多解（在满足题目要求的情况下），输出任意一个即可。
## 样例

### 样例输入 #1
```
5
2
1
2
2
3
```
### 样例输出 #1
```
2
2 4 2
3 5 1 3
```
## 提示

对于 $100\%$ 的数据，有 $1\le n\le 1\ 000\ 000;1\le a_i\le n$，输入保证有解。


---

---
title: "[CEOI 2011] Traffic"
layout: "post"
diff: 省选/NOI-
pid: P4700
tag: ['2011', 'CEOI（中欧）']
---
# [CEOI 2011] Traffic
## 题目描述

在平面直角坐标系上有 $n$ 个点，其中第 $i$ 个点的坐标是 $(x_i,y_i)$ ，所有点在一个以 $(0,0)$ 和 $(A,B)$ 为相对顶点的矩形内。

如果 $x_i=0$ ，那么我们称这个点在西侧。如果 $x_i=A$ ，那么我们称这个点在东侧。

这些点之间有 $m$ 条边，每条边可能是有向边也可能是无向边，保证边在交点以外的任何地方不相交。

现在请你求出，对于每一个西侧的点，能够沿着边到达多少东侧的点。
## 输入格式

第一行四个空格隔开的数 $n,m,A,B$ 。

接下来 $n$ 行，每行两个空格隔开的数 $x_i,y_i$ 。

接下来 $m$ 行，每行三个空格隔开的数 $c_i,d_i,k_i$​​ ，表示一条 $c_i$​​ 和 $d_i$ 之间的边。如果 $k_i=1$ ，那么表示这条边是有向边，方向为 $c_i$​​ 指向 $d_i$​​ ，否则这条边是无向边。
## 输出格式

输出有若干行，每行一个数表示答案。请按照 $y$ 从大到小的顺序输出所有点对应的答案。
## 样例

### 样例输入 #1
```
5 3 1 3
0 0
0 1
0 2
1 0
1 1
1 4 1
1 5 2
3 5 2
```
### 样例输出 #1
```
2
0
2
```
### 样例输入 #2
```
12 13 7 9
0 1
0 3
2 2
5 2
7 1
7 4
7 6
7 7
3 5
0 5
0 9
3 9
1 3 2
3 2 1
3 4 1
4 5 1
5 6 1
9 3 1
9 4 1
9 7 1
9 12 2
10 9 1
11 12 1
12 8 1
12 10 1
```
### 样例输出 #2
```
4
4
0
2
```
## 提示

**样例 $2$ 解释**

![0](https://i.loli.net/2018/04/18/5ad725326df6f.png)

**数据范围**

对于 $100\%$ 的数据，有 $1\le n\le 300\ 000;0\le m\le 900\ 000;1\le A,B\le 10^9;0\le x_i\le A;0\le y_i\le B;1\le c_i,d_i\le n;k_i\in \{1,2\}$。保证西侧的点至少有一个，保证每一个无序对 $\{c_i,d_i\}$ 只会出现一次。


---

---
title: "粘骨牌"
layout: "post"
diff: 省选/NOI-
pid: P4701
tag: ['O2优化', '洛谷月赛']
---
# 粘骨牌
## 题目描述

一个 $n \times m$ 的棋盘，除了某一个位置，其它所有位置都被 $1 \times 2$ 的多米诺骨牌覆盖，所以一共有 $\frac{nm - 1}{2}$ 个多米诺骨牌。

Alice 可以进行任意多次移动，每次移动需要保证移动后多米诺骨牌不超出棋盘，且不能存在两个多米诺骨牌重叠。

棋盘上有若干个特殊位置，一旦它们露出来，你就输了，所以你要避免 Alice 的移动使这些位置露出来。

你可以选择固定任意多个多米诺骨牌，固定一个骨牌需要一定的代价，身为 Bob 的你希望用最少的代价，使得无论 Alice 怎么移动，那些特殊位置都不会露出来，求出这个最小代价。

如果无论怎么固定，都不能满足，输出 "GG"。
## 输入格式

第一行三个整数 $n, m, k(1 \leq n, m \leq 1001, 0 \leq k \leq n \times m)$，分别表示棋盘的大小以及特殊位置的个数。保证 $n$ 和 $m$ 都是奇数。

接下来一行 $\frac{nm - 1}{2}$ 个数，第 $i$ 个数 $a_i(1 \leq a_i \leq 10^9)$表示固定第 $i$ 个骨牌需要的代价。

接下来 $k$ 行，每行两个整数 $x, y(1 \leq x \leq n, 1 \leq y \leq m)$，表示$ (x, y)$ 是一个特殊位置。不保证这 $k$ 个特殊位置互不相同，如果有相同的，忽略后一个即可。

接下来 $n$ 行，每行 $m$ 个数 $v_{i, j}(0 \leq v_{i, j} \leq \frac{nm - 1}{2})$，表示棋盘的覆盖情况。如果 $v_{i,j} = 0$，表示该位置未被覆盖，否则表示这个位置被编号为 $v_{i, j}$ 的骨牌覆盖。
## 输出格式

一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
3 3 1
5 5 5 5
1 1
0 1 1
2 3 4
2 3 4
```
### 样例输出 #1
```
GG
```
### 样例输入 #2
```
3 3 2
5 5 5 1
3 1
3 3
0 1 1
2 3 4
2 3 4
```
### 样例输出 #2
```
6
```
### 样例输入 #3
```
3 3 2
1 5 5 5
3 1
3 3
0 1 1
2 3 4
2 3 4
```
### 样例输出 #3
```
6
```


---

---
title: "[BalticOI 2015] Bowling"
layout: "post"
diff: 省选/NOI-
pid: P4731
tag: ['2015', 'BalticOI（波罗的海）']
---
# [BalticOI 2015] Bowling
## 题目描述

Byteasar is a fan of both bowling and statistics. He has written down the results of a few past bowling games.

Unfortunately, some characters in the notes are blurry, and thus unreadable. Byteasar asks you to write a
program to calculate the number of distinct games which are consistent with his notes.

## Rules of Bowling

A bowling game consists of $n$ frames: $n-1$ simple frames and one final frame. In a typical game $n = 10$. At the beginning of each frame $10$ pins are put standing upright at the end of a lane and a player gets no more than two (or three for the final frame) attempts (shots) to throw a bowling ball down the lane to try to knock down as many pins as possible. Each frame is denoted by two (for a simple frame) or three (for the final frame)
characters.

For each shot the player receives as basic points the total number of pins knocked down in this shot. The player’s basic points in each frame are the sum of basic points of all the shots in this frame. If all $10$ pins are knocked down in a simple frame (and therefore $10$ basic points are earned), the player gets additional bonus points.

For a simple frame the rules are the following:

   - If a player knocks down all $10$ pins in the first shot of a frame, she gets a strike and the frame ends. As bonus points she gets the sum of basic points of her next two shots. A strike is denoted as “``x-``”.
 
   - If a player knocks down all $10$ pins using both shots of a frame, she gets a spare. As bonus points she gets the basic points of her next shot. A spare is denoted as “``A/``”, where $A$ is a digit describing the number of pins knocked down in the first shot of the frame.
   
   - If $9$ or fewer pins are knocked down after both shots, the player gets just basic points and such a frame is denoted as “``AB``”, where $A$ is the one-digit number of pins knocked down in the first shot, and $B$ is the one-digit number of pins knocked down in the second shot $(A + B < 10)$.

Note that bonus points are included to the score of a frame in which the strike or the spare was obtained,regardless of the fact that the exact number of bonus points depends on future shots in next frames.

For the final frame the rules are the following:

   - Initially the player receives two shots in this frame. If $9$ or fewer pins are knocked down in the two shots,the frame ends. Otherwise (if the first two shots are a spare or the first shot is a strike), the player receives a third shot in the frame. Whenever the player knocks down all the pins in any of the three shots, the pins are reset to the initial configuration for the next shot. The score of the final frame is the total number of pins knocked down (note that no bonus points are earned due to strikes and spares).

   - Overall there are seven possible configurations of the final frame with the following outcomes ($A$ and $B$ stand for one-digit numbers):

![](https://cdn.luogu.com.cn/upload/image_hosting/vz466ecx.png)

Each game is described as a sequence of $2n + 1$ characters. At the end of the game the total number of points after each frame may be calculated. For example, for a game of $n = 10$ frames described as “``08x-7/2/x-x-23441/0/x``”, the player’s points after respective frames were as follows:

![](https://cdn.luogu.com.cn/upload/image_hosting/6arspls8.png)


## 输入格式

The first line of input contains one integer $q(1 \le q \le 25)$, specifying the number of test cases to consider. The following $3q$ lines of input contain descriptions of test cases. Each test case is described by three lines of input.
The first line of a test case description contains one integer $n(2 \le n \le 10)$, specifying the number of frames. The second line contains a sequence of $2n + 1$ characters which denotes the game description from Byteasar’s notes. Blurry characters are replaced by “``?``” characters. The third line contains $n$ integers, the total number of points after each frame, separated by spaces. In each number either all digits are readable, or all digits are blurry. Numbers in which all digits are blurry are replaced by “``-1``”.
## 输出格式

Your program should output $q$ lines, one line per each test case in the same order as in the input.

For each test case your program should write one integer: the number of possible distinct games corre-sponding to the test case. Two games are considered different if and only if they differ in at least one shot,that is, their $(2n+1)$-character game descriptions are different. You can assume that there is at least one game consistent with each test case in the input. You can assume that the result fits into 64-bit signed integer type.
## 样例

### 样例输入 #1
```
2
10
08x-7/2/x?x-23??1/???
8 -1 40 60 82 97 102 110 120 140
5
x-x-23?/00-
22 37 42 52 52
```
### 样例输出 #1
```
9
10
```
## 提示

**Explanation to the examples:** In the first case, in frame $5$ after the character “``x``” the only possible character is “``-``”. In frame $8$ the player got $8$ points in total. Thus there are $9$ possibilities how this sum could have been obtained: $0 + 8,1 + 7,...,8 + 0$. There were no bonus points in frame $9$. Therefore, there were no points on the first shot of the final frame. To obtain $20$ points in the last two shots, the only possibility is a spare with a following strike in the last shot of the frame. Therefore there are $9$ different valid games which correspond to this input data.

In the second case, any character from $0$ to $9$ is consistent with the input data.

以下子任务和评测无关，仅供参考。

![](https://cdn.luogu.com.cn/upload/image_hosting/v8uz3sto.png)

（但是我开不了 5 个 Subtask，所以就放在一起测了）


---

---
title: "[BalticOI 2015] Editor"
layout: "post"
diff: 省选/NOI-
pid: P4732
tag: ['2015', 'Special Judge', 'BalticOI（波罗的海）']
---
# [BalticOI 2015] Editor
## 题目描述

Byteasar is a programmer who works on a revolutionary text editor. In the editor there are two types of operations: one type allows to edit text in the editor, and the other type allows to undo previously performed operations. One of the innovative features of this editor is a multilevel undo operation. It works as follows.

We say that a text editing operation is an operation of level $0$. An undo operation of level $i(for \ i = 1,2,...)$ undoes the last operation of level at most $i-1$ which is not undone. For instance, an undo operation of level $1$ can undo only editing operations, and an undo operation of level $2$ can undo editing operations as well as undo operations of level $1$ (but no undo operations of greater levels).

More formally, each of the already performed operations can be in two states: active or undone. Let $X$ be one of the operations. Just after performing the operation $X$, it is in the state active. If $X$ is an undo operation of level $i$, we find the most recent operation in state active of level at most $i-1$ (denote it by $X_1$) and change the state of the operation X1 to undone. If X1 is also an undo operation, we must change to active the state of the operation which $X_1$ had undone (say $X_2$). We continue in the same manner: whenever
the state of an undo operation $X_j$ which had previously undone some operation $X_{j+1}$ changes, we must also change the state of the operation $X_{j+1}$(which, of course, may result in changing states of further operations).

The whole chain of state modifications finishes when an editing operation is reached.

For simplicity, the current contents of text in the editor will be specified by a single integer s, called the editor state (equal to $0$ at the beginning). Each editing operation specifies the editor state that it produces.

The editor state depends on the last editing operation in the state active. Help Byteasar and write a program which keeps track of the editor state.

Let us see this in action: the following table shows some operations performed by Byteasar and the editor state after performing each of them. The symbol $E_s$ denotes an editing operation which changes the editor state to $s$, whereas the symbol $U_i$ denotes an undo operation of level $i$.



| Operation |  | $\mathrm{E}_1$ | $\mathrm{E}_2$ | $\mathrm{E}_5$ | $\mathrm{U}_1$ | $\mathrm{U}_1$ | $\mathrm{U}_3$ | $\mathrm{E}_4$ | $\mathrm{U}_2$ | $\mathrm{U}_1$ | $\mathrm{U}_1$ | $\mathrm{E}_1$ |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
| Editor state | 0 | 1 | 2 | 5 | 2 | 1 | 2 | 4 | 2 | 1 | 0 | 1 |

First, Byteasar performed three editing operations. The editor state changed from $0$ to $1$, then to $2$, and finally to $5$. Next, he performed two undo operations of level $1$, which undid the operations $E_5$ and $E_2$(changing
their state to undone). Thus the editor state was restored to $1$. The following undo operation of level $3$ undid the last operation $U_1$(changing its state to undone), consequently restoring the operation $E_2$(changing its state
back to active). As a result the editor state changed once again to $2$. Operation $U_2$ undid the operation $E_4$,operation $U_1$ once again undid the restored operation $E_2$, the last operation $U_1$ undid the operation $E_1$, and the final operation is $E_1$.
## 输入格式

The first line of the input contains a positive integer $n$, specifying the number of operations performed by Byteasar. The next $n$ lines contain descriptions of operations, one per line, each being an integer $a_i(-n \le a_i \le n, a_i ≠ 0)$. If $a_i> 0$, then it specifies an editing operation which modifies the editor state to $a_i$. If $a_i< 0$,then it specifies an undo operation of level $-a_i$. You can assume that for every undo operation there will be some operation in the state active of smaller level to undo.
## 输出格式

Your program should output $n$ lines. The $i-th$ line should contain one integer specifying the editor state after performing the first $i$ operations from the input.
## 样例

### 样例输入 #1
```
11
1
2
5
-1
-1
-3
4
-2
-1
-1
1
```
### 样例输出 #1
```
1
2
5
2
1
2
4
2
1
0
1
```
## 提示

以下子任务和评测无关，仅供参考。

![](https://cdn.luogu.com.cn/upload/image_hosting/zejidndn.png)

（但是我开不了 4 个 Subtask，所以就放在一起测了）


---

---
title: "[CERC2017] Cumulative Code"
layout: "post"
diff: 省选/NOI-
pid: P4738
tag: ['2017']
---
# [CERC2017] Cumulative Code
## 题目描述

As you probably know, a tree is a graph consisting of $n$ nodes and $n - 1$ undirected edges in which any two nodes are connected by exactly one path. In a labeled tree each node is labeled with a different integer between $1$ and $n$.
The Prüfer code of a labeled tree is a unique sequence associated with the tree, generated by repeatedly removing nodes from the tree until only two nodes remain. More precisely, in each step we remove the leaf with the smallest label and append the label of its neighbour to the end of the code. Recall, a leaf is
a node with exactly one neighbour. Therefore, the Prüfer code of a labeled tree is an integer sequence of length $n - 2$. It can be shown that the original tree can be easily reconstructed from its Prüfer code.
The complete binary tree of depth $k$, denoted with $C_k$, is a labeled tree with $2^k - 1$ nodes where node $j$ is connected to nodes $2j$ and $2j + 1$ for all $j < 2^{k-1}$. Denote the Prüfer code of $C_k$ with $p_1,p_2,..., p_{2^k-3}$.
Since the Prüfer code of $C_k$ can be quite long, you do not have to print it out. Instead, you need to answer $n$ questions about the sums of certain elements on the code. Each question consists of three integers: $a, d$ and $m$. The answer is the sum of the of the $C_k'$ s Prüfer code elements $p_a, p_{a+d},p_{a+2d},...,p_{a+(m-1)d}$.

## 输入格式

The first line contains two integers $k$ and $q(2 \le k \le 30,1 \le q \le 300)$ — the depth of the complete binary tree and the number of questions. The $j-th$ of the following $q$ lines contains the $j-th$ question:three positive integers $a_j,d_j$ and $m_j$ such that $a_j,d_j$ and $a_j + (m_j - 1)d_j$ are all at most $2^k - 3$.

## 输出格式

Output 1 lines. The $j-th$ line should contain a single integer — the answer to the $j-th$ question.

## 样例

### 样例输入 #1
```
3 5
1 1 1
2 1 1
3 1 1
4 1 1
5 1 1
```
### 样例输出 #1
```
2
2
1
3
3
```
### 样例输入 #2
```
4 4
2 1 5
4 4 3
4 8 1
10 3 2
```
### 样例输出 #2
```
18
15
5
13
```
### 样例输入 #3
```
7 1
1 1 125
```
### 样例输出 #3
```
4031
```
## 提示

In the first example above, when constructing the Prüfer code for $C_3$ the nodes are removed in the following order: $4, 5, 2, 1, 6$. Therefore, the Prüfer code of $C_3$ is $2, 2, 1, 3, 3$.

## 题目翻译

给一棵深度为 $k$，点数为 $2^k-1$ 的完全二叉树，其中根节点编号为 $1$，节点 $x$ 的儿子为 $2x$ 和 $2x+1$。

记它的 prufer 序列为 $p$，下标从 $1$ 开始。给定 $q$ 次询问，每次给出三个参数 $a$、$d$、$m$，求 $\sum\limits_{i=0}^{m-1}p_{a+id}$。


---

---
title: "[CERC2017] Gambling Guide"
layout: "post"
diff: 省选/NOI-
pid: P4745
tag: ['2017', 'Special Judge']
---
# [CERC2017] Gambling Guide
## 题目描述

A railroad network in a nearby country consists of $n$ cities numbered $1$ through $n$, and $m$ two-way railroad tracks each connecting two different cities. Tickets can only be purchased at automated machines installed at every city. Unfortunately, hackers have tampered with the ticket machines and now they all work as follows: when a single coin is inserted in the machine installed at city $a$, the machine dispenses a single one-way ticket from $a$ to a random neighboring city. More precisely, the destination city is chosen uniformly at random among all cities directly connected to a with a railroad track. Destinations on different tickets originating in the same city are independent.

A computer science student needs to travel from city $1$ (where she lives) to city $n$ (where a regional programming contest has already started). She knows how the machines work (but of course cannot predict the random choices) and has a map of the railway network. In each city, when she purchases a ticket, she can either immediately use it and travel to the destination city on the ticket, or discard the ticket and purchase a new one. She can keep purchasing tickets indefinitely. The trip is finished as soon as she reaches city $n$.

After doing some calculations, she has devised a traveling strategy with the following properties:
  - The probability that the trip will eventually finish is $1$.
  - The expected number of coins spent on the trip is the smallest possible.

Find the expected number of coins she will spend on the trip.
## 输入格式

The first line contains two integers $n$ and $m(1 \le n,m \le 300 000)$ — the number of cities and the number of railroad tracks. Each of the following $m$ lines contains two different integers $a$ and $b(1 \le a, b \le n)$ which describe a railroad track connecting cities $a$ and $b$. 

There will be at most one railroad track between each pair of cities. It will be possible to reach city $n$ starting from city $1$.
## 输出格式

Output a single number — the expected number of coins spent. The solution will be accepted if the absolute or the relative difference from the judges solution is less than $10^{-6}$.
## 样例

### 样例输入 #1
```
4 4
1 2
1 3
2 4
3 4
```
### 样例输出 #1
```
3.0000000000
```
### 样例输入 #2
```
5 8
1 2
1 3
1 4
2 3
2 4
3 5
5 4
2 5
```
### 样例输出 #2
```
4.1111111111

```
## 题目翻译

一个铁路系统由 $n$ 个城市和 $m$ 条双向铁路组成。铁路票只能在安装在每个城市的自动售票机购买。不幸的是，黑客们已经篡改了这些售票机，现在它们有下面的规则：

当 $a$ 市的售票机有一个硬币投入时，机器会发一张从 $a$ 市到随机一个邻市的单程票。

你需要从城市 $1$ 到城市 $n$。你知道机器是怎么工作的并且有一份铁路系统的地图。在每一个城市，当你买了一张票时，你可以选择立即使用它后到达目的地，或者是丢掉它并买一张新票。你可以无限制的购买的票。当你到达城市 $n$，旅行就会结束。

你需要确定一个满足以下条件的策略：

- 旅行最终到达终点的概率为 $1$。

- 花在旅行上的硬币的期望值越少越好。

输出这个期望值。

**【输入格式】**

第一行包含两个整数 $n$ 和 $m(1 \le n,m \le 300000)$。

接下来 $m$ 行每行包含了两个不同的整数 $a$ 和 $b(1 \le a,b \le n)$，描述了一条连接 $a$ 市和 $b$ 市的双向铁路。

两个城市之间最多只会有一条铁路，输入保证有一条从城市 $1$ 到 $n$ 的路径。

**【输出格式】**

输出一个数，为期望值。此输出只要与正解的相对差或绝对差小于 $10^{−6}$ 就可以通过。


---

---
title: "[CERC2017] Intrinsic Interval"
layout: "post"
diff: 省选/NOI-
pid: P4747
tag: ['2017']
---
# [CERC2017] Intrinsic Interval
## 题目描述

Given a permutation $\pi$ of integers $1$ through $n$, an interval in $\pi$ is a consecutive subsequence consisting of consecutive numbers. More precisely, for indices $a$ and $b$ where $1 \le a \le b \le n$, the subsequence $\pi^b_a = (\pi_a, \pi_{a+1}, . . . ,\pi_b)$ is an interval if sorting it would yield a sequence of consecutive integers.

For example, in permutation $\pi = (3, 1, 7, 5, 6, 4, 2)$, the subsequence $\pi^6_3$ is an interval (it contains the numbers $4$ through $7$) while $\pi^3_1$ is not.

For a subsequence $\pi^y_x$ its intrinsic interval is any interval $\pi^b_a$ that contains the given subsequence $(a \le x \le y \le b)$ and that is, additionally, as short as possible. Of course, the length of an interval is defined as the number of elements it contains.

Given a permutation $\pi$ and $m$ of its subsequences, find some intrinsic interval for each subsequence.
## 输入格式

The first line contains an integer $n(1 \le n \le 100 000)$ — the size of the permutation $\pi$. The following line contains $n$ different integers $\pi_1, \pi_2, . . . , \pi_n (1 \le \pi_j \le n)$ — the permutation itself.

The following line contains an integer $m(1 \le m \le 100 000)$ — the number of subsequences. The $j-th$ of the following $m$ lines contains integers $x_j$ and $y_j(1 \le x_j \le y_j \le n)$ — the endpoints of the $j-th$ subsequence.

## 输出格式

Output $m$ lines. The $j-th$ line should contain two integers $a_j$ and $b_j$ where $1 \le a_j \le b_j \le n$ — the endpoints of some intrinsic interval of the $j-th$ subsequence $\pi^{y_j}_{x_j}$.
## 样例

### 样例输入 #1
```
7
3 1 7 5 6 4 2
3
3 6
7 7
1 3

```
### 样例输出 #1
```
3 6
7 7 
1 7
```
### 样例输入 #2
```
10
2 1 4 3 5 6 7 10 8 9
5
2 3
3 7
4 7
4 8
7 8

```
### 样例输出 #2
```
1 4
3 7
3 7
3 10
7 10

```
## 题目翻译

### 题目描述

对于正整数 $1,2,3 \cdots n$ 的一个排列 $\pi$，若它的一个子串 $\pi[a..b]$ 排序后是连续正整数，则称 $\pi[a..b]$ 是一个“区间”。例如对排列 $pi={3,1,7,5,6,4,2}$，子串 $\pi[3..6]$ 是一个“区间”（因为它包含 $4,5,6,7$），$\pi[1..3]$ 则不是。

一个子串的“本征区间”是包含该子串的最短区间。“包含”是指：若 $\pi[x..y]$ 的本征区间是 $\pi[a..b]$，则 $a \le x \le y \le b$。

给定一个排列 $\pi$ 及其 $m$ 个子串，求每个子串的“本征区间”。

### 输入格式

第一行一个整数 $n(1 \le n \le 100000)$。

第二行 $n$ 个整数，代表排列 $\pi$。

第三行一个整数 $m(1 \le m \le 100000)$。

此后 $m$ 行，每行两个整数 $x,y(1 \le x \le y \le n)$，代表子串 $\pi[x..y]$。

### 输出格式

输出 $m$ 行，每行两个整数 $a,b(1 \le a \le b \le n)$，代表子串对应的本征区间 $\pi[a..b]$。




---

---
title: "[CERC2017] Lunar Landscape"
layout: "post"
diff: 省选/NOI-
pid: P4750
tag: ['2017']
---
# [CERC2017] Lunar Landscape
## 题目描述

A satellite is surveying a possible rover landing area on the moon. The landing area is modeled as a square grid embedded in the standard coordinate system.

The satellite has taken $n$ photos, each capturing a square area of the surface. Careful camera calibration has ensured that all photos are aligned with the grid — all four vertices have integer coordinates. Due to the satellite’s changing orbit there are two types of photos:
   - Photos of type ``A`` have sides that are parallel to coordinate axes. Such a photo is specified by giving the integer coordinates $(x, y)$ of the square’s middle point and the length of its side $a$ — always an even integer.
   - Photos of type ``B`` have sides at a $45^{\circ}$ angle to the coordinate axes. Such a photo is specified by giving the integer coordinates $(x, y)$ of the square’s middle point and the length of its diagonal $d$ — always an even integer.

Find the total surface area captured in the satellite photos.

## 输入格式

The first line contains an integer $n(1 \le n \le 200 000)$ — the number of photos. The $j-th$ of the following $n$ lines is either of the form “$A \ x_j \ y_j  \ a_j$” or “$B \ x_j \ y_j \ d_j$” representing a photo of type ``A`` or ``B``,respectively.

The $x_j$ and $y_j$ are the integer coordinates of the middle point of the photo $(-1 000 \le x_j, y_j \le 1 000)$. The $a_j$ and $d_j$ are even integers $(2 \le a_j, d_j \le 1 000)$ — the side length and the diagonal length, respectively.
## 输出格式

Output a number with exactly two digits after the decimal point — the total area of the surface. The answer has to exactly correspond to the judge’s solution (no rounding errors are tolerated).
## 样例

### 样例输入 #1
```
2
A 0 0 2
B 1 0 2
```
### 样例输出 #1
```
5.00
```
### 样例输入 #2
```
8
A -7 10 4
B 3 10 8
A -6 6 6
A -2 5 8
B 3 -1 8
B -7 -4 8
A 3 9 2
B 8 6 6

```
### 样例输出 #2
```
205.50
```
## 题目翻译

（具体字母格式懒得操作）

月球的景观

题目描述

一个卫星正在为探测车在月球上寻找一个合适的降落区。降落区被看做在平面直角坐标系中的一个方形区域。

这颗卫星已经照了n张照片，每张照片都涵盖了月球表面的一块正方形区域。经过对相机的精细校准，可以保证所有照片涵盖的区域都和坐标对齐——正方形四个角的坐标都为整数。由于卫星的轨道一直在变化，所以照片有两种形式：
·A类照片的边缘和坐标轴平行。对于这样的照片，题目将会给出它中心的坐标(x,y)和它的边长a（a为偶数）。
·B类照片的边缘和坐标轴呈45°角。对于这样的照片，题目将会给出它中心的坐标(x,y)和它对角线的长度d（d为偶数）。

求出卫星图片拍摄到平面的总大小。

输入输出格式

输入格式：

第一行有一个整数n(1≤n≤200000)表示照片的数量。接下来n行中第j行的格式是"A xj yj aj"或"B xj yj dj" ，分别表示这张照片的类型是A或B。

xj和yj是这张图片中心的坐标(1000≤xj,yj≤1000)。aj和dj为偶数(2≤aj,dj≤1000)，分别表示正方形的边长和对角线长度。

输出格式：

输出平面总的大小，保留两位小数。答案必须和标准答案严格相等（精度问题零容忍↖(^ω^)↗）。


---

---
title: "[CERC2014] Parades"
layout: "post"
diff: 省选/NOI-
pid: P4757
tag: ['2014']
---
# [CERC2014] Parades
## 题目描述

In The City of Eternal Festivities, there are $n$ street junctions and $n-1$ bidirectional streets,each street connecting two of the junctions. Between every two junctions, there is exactly one (direct or indirect) path connecting them. No junction is an endpoint for more than 10 streets.

Every 13th of September (the 256th day of the year), there are many festivities going on in The City. In particular, the citizens want to organize $m$ parades. The parade number $i$ starts at junction $u_i$ and ends at $v_i$, following the unique path between the endpoints.

As the mayor of The City, you are responsible for citizens’ safety. Therefore you decreed that no two parades are ever allowed to use the same street, though they can have common junctions,or even common endpoints.

To appease your citizens, try to organize as many parades as possible, without breaking the safety regulations.
## 输入格式

The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:

The first line of each test case contains a single integer: the number of junctions $n(2 \le n \le 1000)$. Each of the next $n - 1$ lines contains two integers $a, b(1 \le a ≠ b \le n)$, denoting that junctions $a$ and $b$ are connected by a street. Each junction has at most $10$ streets leaving it.

The next line contains a single integer: the number of planned parades $m, 0 \le m \le (_2^n)$.

Each of the next $m$ lines contains two integers $u_i, v_i (1 \le u_i ≠ v_i \le n)$,meaning that a parade is planned to start at junction $u_i$, and finish at junction $v_i$. No two parades share both endpoints.
## 输出格式

For each test case, output one line containing the largest number of parades that can be organized with no street used by more than one parade.
## 样例

### 样例输入 #1
```
1
6
1 2
2 3
3 4
3 5
3 6
4
1 3
4 5
5 6
6 4
```
### 样例输出 #1
```
2
```
## 题目翻译

在永恒庆典的城市里，有N个街道路口和N-1个双向街道，每条街道连接两个路口。在每两个路口之间，正好有一条（直接或间接）连接它们的路径。没有路口是超过10条街道的终点。

九月的每第十三天（一年中的第二百五十六天），城市里会有很多庆祝活动。特别是市民要组织M游行。游行I从路口UI开始，结束于VI，是两端点之间的唯一路径。

作为城市的市长，你要对市民的安全负责。因此，你颁布法令，不允许两个游行使用同一条街，尽管它们可以有共同的连接点，甚至共同的端点。

为了安抚你的公民，在不违反安全条例的情况下，组织尽可能多的游行。





第一行输入包含测试用例T的数量。测试用例的描述如下：

每个测试用例的第一行包含一个整数：结点数n（2≤n≤1000）。 接下来的n-1行中的每一行包含两个整数a，b（1≤a≠b≤n），表示端点a和b由街道连接。 每个交叉路口最多有10条街道。

下一行包含一个整数：计划游行的数量m($0≤m≤{n\choose   2})$)。

接下来的m行中的每一行包含两个整数ui，vi（1≤ui≠vi≤n），这意味着游行计划从交叉点ui开始，并在交叉点vi处完成。 没有两个游行共享两个端点。





对于每个测试用例，输出一行包含最多数量的游行，这些游行可以被组织，不会有多个游行使用的相同的街道。


---

---
title: "[CERC2014] Mountainous landscape"
layout: "post"
diff: 省选/NOI-
pid: P4758
tag: ['2014']
---
# [CERC2014] Mountainous landscape
## 题目描述

You travel through a scenic landscape consisting mostly of mountains – there are $n$ landmarks (peaks and valleys) on your path. You pause for breath and wonder: which mountain are you currently seeing on the horizon?

![0](https://cdn.luogu.com.cn/upload/pic/23379.png)

Formally: you are given a polygonal chain $P_1,P_2,\cdots,P_n$ in the plane. The $x$ coordinates of the points are in strictly increasing order. For each segment $P_i P_{i+1}$ of this chain, find the smallest index $j > i$, for which any point of $P_j P_{j+1}$ is visible from $P_i P_{i+1}$ (lies **strictly above** the ray $P_i \ P^{\rightarrow}_{i+1}$).


## 输入格式

The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:

The first line of each test case contains an integer $n(2 \le n \le 100 000)$ – the number of vertices on the chain.

Each of the following $n$ lines contains integer coordinates $x_i, y_i$ of the vertex $P_i (0 \le x_1 < x_2 < \cdots < x_n \le 10^9, 0 \le y_i \le 10^9)$.

## 输出格式

For each test case, output a single line containing $n-1$ space-separated integers. These should be the smallest indices of chain segments visible to the right, or $0$ when no such segment exists.
## 样例

### 样例输入 #1
```
2
8
0 0
3 7
6 2
9 4
11 2
13 3
17 13
20 7
7
0 2
1 2
3 1
4 0
5 2
6 1
7 3
```
### 样例输出 #1
```
0 3 6 5 6 0 0
6 4 4 0 6 0
```
## 题目翻译

- 给定平面内一个由点依次连接起来形成的折线 $P_1,P_2,\cdots,P_n$，保证 $x$ 坐标递增。
- 对于折线上的所有线段，找到最小的 $j>i$，使得存在一个在 $P_jP_{j+1}$ 上的点可以被 $P_iP_{i+1}$ 上的任何一个点看到，也就是**严格**在射线 $P_iP_{i+1}$ 上方。若没有，输出 $0$.
- 多组数据。

$2\le n\le 10^5$，坐标均在 $10^9$ 以内。


---

---
title: "[CERC2014] Vocabulary"
layout: "post"
diff: 省选/NOI-
pid: P4761
tag: ['2014']
---
# [CERC2014] Vocabulary
## 题目描述

According to a popular belief, computer programmers drink a lot of coffee and know only a few words. The vocabulary of a typical programmer consists of just three words. Besides, he rarely knows how to spell them. To help programmers with their spelling mistakes, we published a book titled $The \ Dictionary \ of \ the \ Three \ Words \ Every \ Typical \ Programmer \ Should \ Know$.

You got a copy of the book but, soon after that, you spilled your coffee over it.

Now, youcannot read some of the characters. Fortunately, the three words were, as usually in dictionaries,distinct and printed in lexicographical order.
Before you attempt to use that fact to recover the missing characters, you want to know in how many different ways you can do it. Since you expect this number might be large, you want to know it modulo $10^9 + 9$.
## 输入格式

The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:

Each test case consists of three lines, each containing a single nonempty word – in the order they appear in the dictionary. Words consist of small letters of the English alphabet and question marks, the latter denoting missing characters. Each word is at most $1 000 000$ characters long.

## 输出格式

For each test case, output one line containing the number of different ways you can substitute each question mark with one of the $26$ letters from ``a`` to ``z`` in such a way that the three words are distinct and in lexicographical order. The number should be printed modulo $10^9 + 9$.
## 样例

### 样例输入 #1
```
3
?heoret?cal
c?mputer
?cience
jagiellonian
?niversity
kra?ow
?
b
c
```
### 样例输出 #1
```
42562
52
1
```
## 题目翻译

给你三个字符串，这些字符串有些单词模糊不可认了，用"?"来代表。
现在你可以用任意英文小写字母来代表它们。要求是使得给定的三个字符串中
所有的"?"被你认定的字母代替后，各不相同且按字典序出现。问有多少种方式。

输入：先给出一个数字N，代表数据组数。
接下来3*N行，每行给出一个字符串。长度<=1000 000

输出：输出结果 Mod 10^9+9


---

---
title: "[CERC2014] The Imp"
layout: "post"
diff: 省选/NOI-
pid: P4765
tag: ['2014', 'O2优化']
---
# [CERC2014] The Imp
## 题目描述

You arrive in Ye Olde Magic Shoppe with some hard-earned gold to purchase wondrous and unique magic items. There are $n$ such items in the shop, each of them locked in a special magic box. The $i-th$ box costs $c_i$ gold pieces to buy, and contains an item worth $v_i$ gold pieces. The costs and item values are known to you, as you have previously read, mastered, and memorized Ye Olde Magic Catalogue.

A mortal, such as you, can safely carry only one magic item. You therefore aim to get the most precious one. And obtain it you would, if not for a malicious, magical creature, known as The Imp.

The Imp can cast a mischievous spell, which transforms the content of any magic box into worthless dust. Of course, he will use the spell just after you buy a box, to make you pay for the item and not get it. You are thus forced to buy another box, and then the next one...

The Imp has enough magic to cast the spell at most $k$ times. He can, of course, refrain from using it, allowing you to keep an item. You can walk away at any time, empty-handed (though it would surely be a disgrace). However, if you get an item, you must keep it and leave the shop.

You aim to maximize your gain (the value of the acquired item minus all the expenses paid previously), while The Imp wants to minimize it. If both you and the creature use the optimal strategy, how much gold will you earn?
## 输入格式

The first line of input contains the number of test cases $T$. The descriptions of
the test cases follow:

Each test case starts with a line containing the number of items $n(1 \le n \le 150 000)$ and the the maximum number of The Imp’s spells $k(0 \le k \le 9)$. 

The next $n$ lines contain the items’values and costs, the $i-th$ line containing the numbers $v_i$ and $c_i$, in that order $(0 \le v_i, c_i \le 10^6)$.

## 输出格式

For each test case, output one line containing your gain.
## 样例

### 样例输入 #1
```
1
3 1
10 5
8 1
20 12
```
### 样例输出 #1
```
7
```
## 题目翻译

## 题目描述

你带着一些来之不易的金币来到了 Ye Olde 魔法商店，想要购买一些妙不可言的魔术物品。商店里有 $n$ 个魔术实体，每个实体都锁在一个特殊的魔术宝箱中。第 $i$ 个宝箱（和其中的实体）的售价为 $c_i$个金币，而其中实体的价值相当于 $v_i$ 个金币。你作为曾经完整钻研了《Ye Olde 魔法目录》的顶级做题家，当然毫无疑问地记住了每个盒子和其中实体的售价和价值。

然而像你这样的凡人，只能安全地携带一件魔法实体。因此，你想要得到最宝贵的一个。你本可以直接得到它的——如果不是因为调皮而又神奇的小恶魔的话。

小恶魔可以使用魔法，从而将某一个魔术宝箱内的实体转化为毫无价值的灰尘。当然，他会在你购买一个魔术宝箱后立即对其使用该魔法，这样你就为这个宝箱付了钱而没能得到里面的实体。因此，你被迫另买一个，再买一个……

小恶魔拥的魔力最多可以用来使用 $k$ 次魔法。当然，他可以不用完这 $k$ 次魔法，而你也可以随时空手走开（尽管这是一个奇耻大辱）。但是，如果你成功地买到了到一个实体（而没有被变成灰尘），则你必须保留该实体并离开商店。

你的目标是最大化你的收益（所购实体的价值减去支付的所有费用（包括购买当前实体和之前的灰尘）），而小恶魔则希望将其最小化。如果你和小恶魔都使用最佳策略，那么你的收益将会相当于多少金币？

## 输入格式

**本题每个测试点包含多组数据。**

第一行包含一个正整数 $T$ 表示测试数据组数。  
每组数据的第一行包括两个数 $n$ 和 $k$ ，分别表示魔术实体个数和小恶魔使用魔法的最大次数。  
接下来 $n$ 行，第 $i$ 行包括两个数 $v_i$ 和 $c_i$，意义如【题目描述】所述。同一行的数用空格隔开。

## 输出格式

对于每组数据，输出一行一个数表示答案。

## 数据范围与提示

$1\le n\le1.5\times10^5,0\le k\le9,0\le v_i,c_i\le10^6$。


---

---
title: "Counting swaps"
layout: "post"
diff: 省选/NOI-
pid: P4778
tag: []
---
# Counting swaps
## 题目背景

Just like yesterday (in problem U of the practice session), Bob is busy, so Alice keeps on playing some single-player games and puzzles. In her newest puzzle she has a permutation of numbers from 1 to n. The goal of the puzzle is to sort the permutation using the smallest possible number of swaps.    

Instead of simply solving the puzzle, Alice is wondering about the probability of winning it just by playing at random. In order to answer this question, she needs to know the number of optimal solutions to her puzzle.    
## 题目描述

You are given a permutation p1, …, pn of the numbers 1 through n. In each step you can choose two numbers x < y and swap px with py.  

Let m be the minimum number of such swaps needed to sort the given permutation. Compute the number of different sequences of exactly m swaps that sort the given permutation. Since this number may be large, compute it modulo 10^9 + 9.  
## 输入格式

The first line of the input file contains an integer t specifying the number of test cases. Each test case is preceded by a blank line.  

Each test case consists of two lines. The first line contains the integer n. The second line contains the sequence p1, …, pn: a permutation of 1, …, n.  

In the easy subproblem C1, 1 ≤ n ≤ 10.  

In the hard subproblem C2, 1 ≤ n ≤ 105.  
## 输出格式

For each test case, output a single line with a single integer: x%(10^9+9), where x is the number of ways to sort the given sequence using as few swaps as possible.  
## 样例

### 样例输入 #1
```
3

3
2 3 1

4
2 1 4 3

2
1 2
```
### 样例输出 #1
```
3
2
1
```
## 提示

In the first test case, we can sort the permutation in two swaps. We can make the first swap arbitrarily; for each of them, there’s exactly one optimal second swap. For example, one of the three shortest solutions is “swap p1 with p2 and then swap p1 with p3”.  

In the second test case, the optimal solution involves swapping p1 with p2 and swapping p3 with p4. We can do these two swaps in either order.  

The third sequence is already sorted. The optimal number of swaps is 0, and thus the only optimal solution is an empty sequence of swaps.  
题目来源：[IPSC2016](https://ipsc.ksp.sk/2016/real/problems/c.html)
## 题目翻译

给定你一个 $ 1∼n $ 的排列 $p$，可进行若干次操作，每次选择两个整数 $x,y$，交换 $px,py$。

请你告诉穰子，用最少的操作次数将给定排列变成单调上升的序列 $1,2,…,n$，有多少种方式呢？请输出方式数对 $10^9+9$ 取模的结果。

Translated by @LJC00118 


---

---
title: "[AHOI2008] 矩形藏宝地"
layout: "post"
diff: 省选/NOI-
pid: P4793
tag: ['2008', '各省省选', '安徽']
---
# [AHOI2008] 矩形藏宝地
## 题目描述

欢乐岛上最著名的游戏是一个寻宝游戏，小可可来到宝藏的埋藏地，这是一块开阔地，宝藏被分散的埋藏在这块地下，现在要做的是一件件的把宝藏挖出来。为了提示宝藏的埋藏点，游戏的主办方把这块开阔地当作第一象限，将所有可能埋藏宝藏的地方划成一个个矩形的土地，并把这些矩形土地的坐标都告诉了参赛者。挖宝的提示很简单，只要某一个矩阵土地至少被另外一个矩阵土地所包含，那么这个矩阵土地里肯定埋有宝藏。其实这些宝藏都是一些精美的纪念品，如果谁挖出来了纪念品就归谁了，小可可很想为这次旅程画上完美的句号，有你的帮助他信心十足，你只要告诉他：有多少个矩形土地里肯定埋有宝藏就行了。胜利就在眼前，加油吧！
## 输入格式

第一行包含一个整数 $N\leq 200000$，表示矩形的个数。
接下来 $N$ 行，每行用 $4$ 个整数 $x_1,\,y_1,\,x_2,\,y_2$，描述了一个矩形。其中 $(x_1,\,y_1)$ 表示这个矩形左下角的坐标，$(x_2,\,y_2)$ 表示右上角的坐标，一个 $x$ 值或 $y$ 值最多出现一次。 
## 输出格式

只包含一个整数，表示肯定埋有宝藏的矩形土地的个数。 
## 样例

### 样例输入 #1
```
3
0 0 5 5
1 2 3 4
2 1 4 3

```
### 样例输出 #1
```
2

```
## 提示

$30\%$ 的数据中，$N\leq 5000$。

$70\%$ 的数据中，$N\leq 50000$。

$100\%$ 的数据中，$N\leq 200000$。

所有数据中，一个 $x$ 值或 $y$ 值最多出现一次。坐标范围 $2\times 10 ^ 6$。


---

---
title: "[CEOI 2015] 波将金的路径 (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P4797
tag: ['2015', 'Special Judge', 'CEOI（中欧）']
---
# [CEOI 2015] 波将金的路径 (Day1)
## 题目描述



**译自 [CEOI2015](https://ceoi2015.fi.muni.cz/tasks.php) Day1 T1「[Potemkin cycle](https://ceoi2015.fi.muni.cz/day1/eng/day1task1-eng.pdf)」**

**简要题意** $\,$ 给一张无向图，$|V|=N,$ $|E|=R$。请找一条简单路径，设该路径的点集为 $V'$，要求：$|V'| \ge 4$，且 $V'$ 的导出子图只含该路径本身（也就是一条链）。

---

波将金公爵的领土可以视作一张无向图，他要求你找到一条路线，经过的结点以序列 $s_1,\dots,s_m$表示，且满足以下要求：

 - $m \geq 4$

- 经过的每个结点互不相同（即对于所有$i \neq j$满足$s_i \neq s_j$）

- 对于 $i = 1,\dots,m - 1$，满足 $s_i$ 与 $s_{i + 1}$ 直接连接，且 $s_m$ 与 $s_1$ 直接连接。

- 序列中的结点没有其他的边（即对于所有 $i < j$，使得 $j \neq i + 1$ 且 $i \neq 1$ 或者是 $j \neq m$，结点 $s_i$ 和 $s_j$ 之间没有边）。
## 输入格式

第一行，两个非负整数 $N$ 和 $R(0 \leq N \leq 1\ 000,0 \leq R \leq 100\ 000)$，分别表示结点的个数和道路的个数。

接下来 $R$ 行，其中第 $i$ 行包括两个不同的正整数 $a_i$ 和 $b_i(1 \leq a_i,b_i \leq N)$，表示结点 $a_i$ 与 $b_i$ 之间有一条边。

保证每两个结点最多有一条边连接。
## 输出格式

输出序列 $s_1,\dots,s_m$，表示问题描述的序列（如果有多解任意输出一个）。如果无解，输出`no`。
## 样例

### 样例输入 #1
```
5 6
1 2
1 3
2 3
4 3
5 2
4 5
```
### 样例输出 #1
```
2 3 4 5
```
### 样例输入 #2
```
4 5
1 2
2 3
3 4
4 1
1 3
```
### 样例输出 #2
```
no
```
## 提示

$N$ 与 $R$ 的上限如下表所示：

|数据点|$1-3$|$4-5$|$6-7$|$8-10$|
|-|:-:|:-:|:-:|:-:|
|$N$ 的上限|$10$|$100$|$300$|$1\ 000$|
|$R$ 的上限|$45$|$1\ 000$|$20\ 000$|$100\ 000$|


---

---
title: "[CCC 2016] 生命中的圆"
layout: "post"
diff: 省选/NOI-
pid: P4804
tag: ['2016', 'CCC（加拿大）']
---
# [CCC 2016] 生命中的圆
## 题目描述

**译自 [CCC2016](https://cemc.math.uwaterloo.ca/contests/computing/2016/index.html) Senior T5「[Circle of Life](https://cemc.math.uwaterloo.ca/contests/computing/2016/stage%201/seniorEn.pdf)」**

> 也许你听说过康威生命游戏（Conway's Game of Life）。康威生命游戏适用于方格组成的矩阵。但它可以产生十分复杂的结构。在这道题目中，我们将使用简化版的生命游戏来虐你。

这个游戏是 0 人游戏，换句话说，只要给定初始条件，这个游戏就能自己进行下去。

将一个圆环分为 $N$ 段，将这 $N$ 段顺时针依次编为 $1,\dots,N$ 号。每一段要么是活的（以 `1` 表示），要么是死的（以 `0` 表示）。

游戏会进行 $T$ 轮「变化」。如果一个方格**恰好**有一个相邻的方格在这次变化中存活，那么该方格会在下次变化中存活。否则，该方格会死亡。

给定圆环的初始状态，求经过 $T$ 次变化之后的状态。
## 输入格式

第一行，两个整数 $N$ 和 $T(3 \le N \le 100\ 000;1 \le T \le 10^{15})$。

第二行，一个长度为 $N$ 的字符串，表示 $N$ 个方格的初始状态。保证每个字符只有 `0` 或 `1` 两种可能。第 $i$ 位表示编号为 $i$ 的方格的初始状态。
## 输出格式

输出一个长度为 $N$ 的字符串，表示最终的状态。格式同输入。
## 样例

### 样例输入 #1
```
7 1
0000001
```
### 样例输出 #1
```
1000010
```
### 样例输入 #2
```
5 3
01011
```
### 样例输出 #2
```
10100
```
## 提示

#### 样例解释 1
方格 $1$ 和 $N - 1$ 和 $N$ 相邻，因此在一次变化后仍存活。

#### 样例解释 2
一次变化后，状态为 ` 00011`。

两次变化后，状态为 ` 10111`。

对于 $\frac{1}{15}$ 的数据，$N \le 15,T \le 15$。

对于另外的 $\frac{6}{15}$ 的数据，$N \le 15$。

对于另外的 $\frac{4}{15}$ 的数据，$N \le 4000,T \le 10\ 000\ 000$。

注意对于所有的数据，你需要使用 64 位整数。


---

---
title: "[CCC 2017] 地铁交通"
layout: "post"
diff: 省选/NOI-
pid: P4807
tag: ['2017', 'CCC（加拿大）']
---
# [CCC 2017] 地铁交通
## 题目背景

**滥用本题评测将被封号**
## 题目描述

 **译自 [CCC2017](https://cemc.math.uwaterloo.ca/contests/computing/2017/index.html) Senior T5「[RMT](https://cemc.math.uwaterloo.ca/contests/computing/2017/stage%201/seniorEF.pdf)」**

RMT 地铁交通运行着一个不寻常的地铁系统。有 $N$ 个地铁站，从 $1$ 到 $N$ 编号。有 $M$ 条地铁线路，从 $1$ 到 $M$ 编号，每个地铁站只属于一条线路且每条线路至少经过一个地铁站。整个地铁网络呈圆形。也就是说，如果有一个编号为 $S$ 的地铁站，那么与它同一线路的下一个地铁站是下一个编号比它大的地铁站。除非 $S$ 是同线路中编号最大的地铁站，在这种情况下，它的下一个地铁站是同一线路中编号最小的地铁站。

RMT 正在以志愿者对他们的系统进行负载测试。测试从每一站以一列地铁列车开始，且对于每一个 $i$，会有 $A_i$ 个志愿者在第 $i$ 站的测试列车上。在整个测试期间，志愿者不会离开对应的列车。

测试过程中，RMT 会进行 $Q$ 个操作，每个操作只有两种可能：一种是询问第 $l$ 站到第 $r$ 站地铁上的志愿者人数；或是在线路 $x$ 运行所有的地铁。当有一列地铁在 $x$ 线路运行，它会前往线路中的下一站。

你是 RMT 的铁杆骨灰级粉丝，所以你自愿协助他们进行操作并告诉他们操作的结果。
## 输入格式

第一行，三个整数，$N,M$ 和 $Q(1 \le M \le N \le 150\ 000;1 \le Q \le 150\ 000)$。

第二行，$N$ 个整数 $L_1,L_2,\dots,L_N$，表示每个地铁站所属线路的编号。

第三行，$N$ 个整数 $A_1,A_2,\dots,A_N$，表示每个地铁站起始时刻的志愿者人数。

以下 $Q$ 行，每行只有以下其中一种形态：

 - `1 l r`，表示一个询问 $(1 \le l \le r \le N)$。

 -  `2 x`，表示 RMT 会在 $x$ 线路运行 $(1 \le x \le M)$。
## 输出格式

对于每个询问，输出一行，表示询问的答案。
## 样例

### 样例输入 #1
```
5 2 5
1 2 1 2 2
1 2 3 4 5
1 1 5
2 1
1 3 5
2 2
1 1 3
```
### 样例输出 #1
```
15
10
9
```
### 样例输入 #2
```
3 1 7
1 1 1
114 101 109
1 1 1
2 1
1 1 1
2 1
1 1 1
2 1
1 1 1
```
### 样例输出 #2
```
114
109
101
114
```
## 提示

### 样例解释 1
地铁系统如下图所示，地铁站编号为 $1$ 到 $5$，由编号为 $1$ 或 $2$ 的线路连接：

![](https://i.loli.net/2018/08/16/5b74e41916341.png)

开始时，每个地铁站的志愿者人数为 $\{1,2,3,4,5\}$。

第一个询问的答案为 $1+2+3+4+5=15$。

线路 $1$ 被运行之后，每个地铁站的志愿者人数为 $\{3,2,1,4,5\}$。

第二个询问的答案为 $1+4+5=10$。

线路 $2$ 被运行之后，每个地铁站的志愿者人数为 $\{3,5,1,2,4\}$。

第三个询问的答案为 $3+5+1=9$。

#### 样例解释 2
地铁系统如下图所示，地铁站编号为 $1$ 到 $3$，只有线路 $1$ 连接：

![](https://i.loli.net/2018/08/16/5b74e56617ad0.png)

第一次询问之前，每个地铁站的志愿者人数为 $\{114,101,109\}$。

第二次询问之前，每个地铁站的志愿者人数为 $\{109,114,101\}$。

第三次询问之前，每个地铁站的志愿者人数为 $\{101,109,114\}$。

第四次询问之前，每个地铁站的志愿者人数为 $\{114,101,109\}$。

对于 $\frac2{15}$ 的数据，$N \le 1\ 000,Q \le 1\ 000$。

对于另外 $\frac2{15}$ 的数据，$L_i \le L{i+1}(1 \le i < N)$。

对于另外 $\frac3{15}$ 的数据，$M \le 200$。

对于另外 $\frac3{15}$ 的数据，每条线路的地铁数量都不超过 $200$。


---

---
title: "[CCC 2018] 平衡树"
layout: "post"
diff: 省选/NOI-
pid: P4808
tag: ['2018', 'CCC（加拿大）']
---
# [CCC 2018] 平衡树
## 题目描述

**题目译自 [CCC 2018](https://cemc.math.uwaterloo.ca/contests/computing/2018/) S4「[Balanced Trees](https://cemc.math.uwaterloo.ca/contests/computing/2018/stage%201/seniorEF.pdf)」**

我们定义「完美平衡树」如下：

每棵完美平衡树都有一个正整数权值。权值为 $1$  的完美平衡树为只含有 $1$  个节点的树。否则，这棵树的权值为 $w(w\ge2)$，则这棵树为一棵含有 $k(2\le k\le w)$ 棵子树的有根树。所有的 $k$ 棵子树都必须是相同的，且它的所有 $k$ 棵子树必须完全相同，且自身是完美平衡的。

特别地，所有 $k$ 棵子树权值必须相同。它们的权值必须为 $\left\lfloor\frac{w}{k}\right\rfloor$ 。例如，如果一棵权值为 $8$ 的完美平衡树有 $3$ 棵子树，那么每棵子树的权值为 $2$，因为 $2+2+2=6\le8$。

给定 $N$，求出权值为 $N$ 的完美平衡树的数量。

## 输入格式

输入包含一行一个整数 $N$。
## 输出格式

输出一个整数表示权值为 $N$ 的完美平衡树的数量。
## 样例

### 样例输入 #1
```
4
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
10
```
### 样例输出 #2
```
13
```
## 提示

#### 样例解释 1

合法的树如下：

 - 一棵以有 $4$ 棵权值为 $1$ 的子树为根的完美平衡树；
 - 一棵以有 $2$ 棵权值为 $2$ 的子树为根的完美平衡树；
 - 一棵以有 $3$ 棵权值为 $1$ 的子树为根的完美平衡树。

对于 $33\%$ 的数据，$N\le1000$；  
对于另外 $13\%$ 的数据，$N\le5\times 10^4$；  
对于另外 $13\%$ 的数据，$N\le10^6$；  
对于全部的数据，$1\le N\le10^9$。


---

---
title: "[CCC 2018] 最大战略储备"
layout: "post"
diff: 省选/NOI-
pid: P4809
tag: ['2018', 'CCC（加拿大）']
---
# [CCC 2018] 最大战略储备
## 题目描述

**题目译自 [CCC 2018](https://cemc.math.uwaterloo.ca/contests/computing/2018/) S5「[Maximum Strategic Savings](https://cemc.math.uwaterloo.ca/contests/computing/2018/stage%201/seniorEF.pdf)」**

有 $N$ 个星球，编号为 $1\ldots N$。每个星球有 $M$ 座城市，编号为 $1\ldots M$。我们将 $e$ 星球上的城市 $f$ 记作 $(e,\,f)$。

有 $N\times P$ 条双向航线，对于每个星球 $e(1\le e\le N)$，有 $P$ 条航线，编号为 $1$ 到 $P$。第 $i$ 条航线连接城市 $(e,\,a_i)$ 和 $(e,\,b_i)$，且每天需要花费 $c_i$ 的代价维护。

有 $M\times Q$ 个双向港口。对于所有编号为 $f(1\le f\le M)$ 的城市，有 $Q$ 个港口，编号为 $1$ 到 $Q$。第 $j$ 个港口可以连接城市 $(x_j,\,f)$ 和 $(y_j,\,f)$，且每天需要花费 $z_j$ 的代价维护。

现在需要拆除一些港口和（或）取消一些航线，使得城市之间仍能保持联通，且节省的代价之和最大。
## 输入格式

第一行四个整数，分别为 $N,\,M,\,P,\,Q\ (0\le N,\,M,\,P,\,Q\le10^5)$。

接下来 $P$ 行，每行三个整数 $a_i,\,b_i,\,c_i(1\le a_i,\,b_i\le M,\,1\le c_i\le10^8)$。

再接下来 $Q$ 行，每行三个整数 $x_j,\,y_j,\,z_j(1\le x_j,\,y_j\le N,\,1\le z_j\le 10^8)$。

数据保证城市之间两两联通，可能有重边或自环。
## 输出格式

输出一行一个整数表示每天最多能节省的代价之和。
## 样例

### 样例输入 #1
```
2 2 1 2
1 2 1
2 1 1
2 1 1
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
2 3 4 1
2 3 5
3 2 7
1 2 6
1 1 8
2 1 5
```
### 样例输出 #2
```
41
```
## 提示

#### 样例 2 解释
一种可行的最优解是关闭城市 $(1,\,1)$ 与 $(1,1)$、$(2,\,1)$ 与 $(2,\,1)$、$(1,\,1)$ 与 $(1,\,2)$、$(1,\,3)$ 与 $(1,\,2)$、$(2,\,3)$ 与 $(2,\,2)$ 之间的航线；并关闭城市 $(2,\,3)$ 与 $(1,\,3)$ 间的港口。最终可以节省 $8 + 8 + 6 + 7 + 7 + 5 = 41$ 的代价。

对于 $\frac{2}{15}$ 的数据，$P,\,Q\le100$，且对于所有的 $1\le i\le P$，都有 $c_i=1$；对于所有的 $1\le j\le Q$，都有 $z_j=1$；

对于另外 $\frac{2}{15}$ 的数据，$P,\,Q\le 200$；

对于另外 $\frac{5}{15}$ 的数据，$N,\,M\le 200$；

对于全部的数据，$1\le N,\,M,\,P,\,Q\le10^5$。


---

---
title: "[国家集训队] 书堆"
layout: "post"
diff: 省选/NOI-
pid: P4820
tag: ['集训队互测']
---
# [国家集训队] 书堆
## 题目描述

蚂蚁是勤劳的动物，他们喜欢挑战极限?现在他们迎来了一个难题！蚂蚁居住在图书馆里，图书馆里有大量的书籍。书是形状大小质量都一样的矩形。蚂蚁要把这些书摆在水平桌子的边緣。蚂蚁喜欢整洁的布置，所以蚂蚁规定书本必须水平摆放，宽必须平行于桌緣（如图），而且不允许同一高度摆多本书。

![](https://cdn.luogu.com.cn/upload/pic/30575.png)

蚂蚁想要让书本伸出桌子边缘尽量远，同时不让书因为重力垮下来。它们己经用不知道什么方法测出了书的长度M(如图)。如果总共有N本书，请你帮忙计算如何摆放使得最多水平伸出桌缘多远。你不用考虑蚂蚁用什么方法搭建这堆书。

如果某本书以上的所有书的重心的竖直射影不在这本书上，或者正好落在在这本书的边界上，那么这堆书是不稳定的，会因为重力而垮下来。

考虑以下的假设：

- 不考虑地球自转，重力系数也不因高度改变；
- 书是质量均匀，质地坚硬的理想二维物体；
- 在不会垮的前提下，每本书的位置坐标可以是任意实数。
## 输入格式

第一行正整数 N M
## 输出格式

一行（有换行符），L，表示水平延伸最远的整数距离 (不大于答案的最大整数)
## 样例

### 样例输入 #1
```
1 100
```
### 样例输出 #1
```
49
```
### 样例输入 #2
```
2 100
```
### 样例输出 #2
```
74
```
## 提示

 N <= 10^18,数据保证答案 < 10^6


---

---
title: "Scarlet loves WenHuaKe"
layout: "post"
diff: 省选/NOI-
pid: P4831
tag: ['洛谷月赛']
---
# Scarlet loves WenHuaKe
## 题目背景

Scarlet上大学了，在此之前，她加强了一道高考模拟题QAQ
## 题目描述

Scarlet尝试在$n$行$m$列的中国象棋棋盘上放置$2\times n$ 个炮，使得它们互不攻击。

大家都知道Scarlet沉迷搞事，她想问你有多少个方案。
## 输入格式

一行两个整数，分别表示$n$ 和 $m$
## 输出格式

一个整数，表示方案数对$998244353$取模后的值
## 样例

### 样例输入 #1
```
4 4
```
### 样例输出 #1
```
90
```
## 提示

对于20%的数据，$n,m\leq5$

对于另25%的数据，$n,m\leq2000$

对于另20%的数据，$n=m$

对于剩下的35%的数据，$m-n\leq10$

对于100%的数据，有$1\leq n\leq m\leq100000$


---

---
title: "[JSOI2014] 学生选课"
layout: "post"
diff: 省选/NOI-
pid: P4835
tag: ['2014', '各省省选', '江苏']
---
# [JSOI2014] 学生选课
## 题目描述

进入大学以后，学生们将面临选课，有 $n$ 个学生需要选课，学校里有三个老师 JYY，YJY，YYJ。

第一年里，每个学生们都选择了其中一位老师。经过了一年的学习，学生之间相互都有一定的印象，每个同学会根据自己的印象给另外 $n-1$ 个学生从好到坏排序。第二年的选课开始了，每个学生需要选择老师，可能是因为被坑多了，每一位同学都想换一个老师。这时需要你来调度同学们选课，使得上同一堂课的学生之间印象最坏的最好。
## 输入格式

第一行一个整数 $n$。

接下来 $n$ 行，每行 $n$ 个正整数，其中第 $i+1$ 行提供第 $i$ 个同学的信息。其中第一个整数 $A_i$，值为 $0,1,2$ 中的一个，表示第一年第 $i$ 个同学选的老师。
接下来 $n-1$ 个数字，是 $1,2,\cdots,i-1,i+1,\cdots,n$ 的一个排列，表示第 $i$ 个同学对其他同学印象从好到坏的排序。
## 输出格式

一行一个整数，为最小的非负整数 $T$，满足：

- 所有同学选择了和第一年不同的老师。

- 所有选择同一个老师的学生间彼此印象都是前 $T$ 好的。
## 样例

### 样例输入 #1
```
6
0 2 3 4 5 6
0 1 3 4 5 6
1 6 5 4 2 1
2 6 5 3 2 1
1 1 2 3 4 6
2 1 2 3 4 5
```
### 样例输出 #1
```
4
```
## 提示

### 样例解释 1

六名同学分别选择老师 $1,2,0,0,2,0$。

此时老师 $0$ 的课中同学 $6$ 对同学 $4$ 的印象为第 $4$ 好，所以答案 $T$ 为 $4$，并且找不到更小的 $T$。

### 数据范围

对于 $100\%$ 的数据，$n\leq 1000$。


---

---
title: "P 哥的桶"
layout: "post"
diff: 省选/NOI-
pid: P4839
tag: []
---
# P 哥的桶
## 题目描述

P 哥现在有 $n$ 个桶，它们排成了一排，这些桶可以装下任意多个球。每个球有一个固定的价值。

P 哥时不时地会找新球，并把新找的球丢进某个桶里面。我们用 $1\;k\;x$ 来表示 P 哥找了一个价值为 $x$ 的球，并且丢进了 $k$ 号桶里面。

P 哥每次会在特定的桶里面拿出一些球。我们用 $2\;l\;r$ 来表示 P 哥在 $l$ 号桶到 $r$ 号桶之间拿球。P 哥希望拿出来的球的价值异或和尽可能大。

**注意：P 哥拿出这些球后会把它们物归原位。**
## 输入格式

第一行两个整数 $n, m$，依次表示 P 哥的操作次数、这组数据会涉及到的最大编号。

接下来 $n$ 行，每行三个整数，表示操作。操作格式如题。
## 输出格式

对于每个 2 操作，输出 P 哥拿出的球的最大价值异或和。
## 样例

### 样例输入 #1
```
5 3
1 1 2
1 2 3
1 3 4
2 1 2
2 1 3
```
### 样例输出 #1
```
3
7
```
### 样例输入 #2
```
11 10
2 6 9
1 9 1523456696
1 1 1818963290
2 6 7
1 1 102229226
2 1 9
2 3 7
1 5 34895532
1 1 1652480680
1 1 1477666032
2 1 10
```
### 样例输出 #2
```
0
0
1818963290
0
1857442578

```
## 提示

对于 $20 \%$ 的数据，满足 $n,m\leq 100$。

对于 $40 \%$ 的数据，满足 $n,m\leq 1000$。

另有 $20 \%$ 的数据，所有询问满足 $l=1$，$r=m$。

对于 $100 \%$ 的数据，满足 $1 \le n, m \leq 5 \times 10^4$，$1 \le l\leq r\leq m$，$1 \le k \leq m$，$0 \le x \leq 2^{31}-1$。


---

---
title: "P哥旋转"
layout: "post"
diff: 省选/NOI-
pid: P4840
tag: []
---
# P哥旋转
## 题目背景

P哥开始学字符串了！
## 题目描述

P 哥学会了字符串处理的新方法——旋转。

“旋转”是这样一种操作：将原字符串最后面的字符抹去，然后把它加到最前面，得到一个新串。

P 哥可以进行无数次“旋转”操作，**让得到的新串中本质不同的回文子串尽可能多**。

两个回文串本质不同，当且仅当它们长度不同，或至少有一个相同位置的字符不同。

现在 P 哥得到了一个串 $S$，请你通过“旋转”操作帮 P 哥达成他的目标（即上面的加粗字体部分），并输出新串中不同的回文子串的个数。
## 输入格式

输入共一行，代表串 $S$，保证只有小写英文字母。
## 输出格式

输出一个整数表示答案。
## 样例

### 样例输入 #1
```
ioimoio

```
### 样例输出 #1
```
7

```
### 样例输入 #2
```
fcfcfcfcfczxqprvvlpstpasxvpyyhaejxehdlhckmwmibsjwqbmfzlwpjqjghmlxunefabkpryqxbkqridpqrzemvfcfcfcfcfc
```
### 样例输出 #2
```
47
```
## 提示

设 $n$ 为串 $S$ 的长度。

- 对于前 $20\%$ 的数据，$n \le 100$。
- 对于前 $40\%$ 的数据，$n \le 2000$。
- 对于另 $10\%$ 的数据，保证得出正确答案不用进行旋转。
- 对于 $100\%$ 的数据，$n \le 1.5\times 10^6$。

此外，对于后 $50\%$ 的数据，保证串 $S$ 的非随机部分长度不超过 $5000$。

**注意**：本题采用 subtask 方式计分。前 $50\%$ 的数据是 $subtask#1$，该 subtask 采用加和的方式计分（你可以认为是传统计分方式）。后 $50\%$ 的数据是 $subtask#2$，该 subtask 采用取 $\min$ 的方式计分（即只要错一个点，后 $50$ 分全部没有）。


---

---
title: "城市旅行"
layout: "post"
diff: 省选/NOI-
pid: P4842
tag: []
---
# 城市旅行
## 题目描述


W 国地大物博，由 $n$ 座城市组成，共 $n-1$ 条双向道路连接其中的两座城市，且任意两座城市都可相互到达。

风景秀美的 W 国吸引了无数慕名而来的游客，根据游客对每座城市的打分，我们定义第 $i$ 座城市的美丽度为 $a_i$。一次从城市 $x$ 到城市 $y$ 的旅行，所获得的的愉悦指数为从城市 $x$ 到城市 $y$ 所有城市的美丽度之和（包括 $x$ 和 $y$）。我们定义这个值为 $H(x,y)$。

现在小 A 在城市 $X$，Sharon 在城市 $Y$，他们想知道如果在城市 $X$ 到城市 $Y$ 之间的所有城市中任选两座城市 $x$ 和 $y$（$x$ 可以等于 $y$），那么 $H(x,y)$ 的期望值是多少，我们记这个期望值为 $E(x,y)$。

当然，城市之间的交通状况飘忽不定，因此我们不能排除某些时刻某些道路将无法通行。某些时刻会突然添加新的道路。以及游客们审美观的改变，某些城市的美丽度也会发生变化。作为 W 国负责旅游行业的 T 君，他要求你来写一个程序来模拟上面的所有过程。
## 输入格式

第一行两个整数，$n,m$ 表示城市个数和操作个数。

接下来一行 $n$ 个整数，第 $i$ 个表示 $a_i$。  
接下来 $n-1$ 行，每行两个整数 $u,v$，表示 $u$ 和 $v$ 之间有一条路。  
接下来 $m$ 行，是进行下面的操作：

- `1 u v` 如果城市 $u$ 和城市 $v$ 已经无直接连接的道路，则忽略这个操作，否则删除 $u,v$ 之间的道路。
- `2 u v` 如果城市 $u$ 和城市 $v$ 联通那么忽略。否则在 $u,v$ 之间添加一条道路。
- `3 u v d` 如果城市 $u$ 和城市 $v$ 不连通，那么忽略。否则将城市 $u$ 到城市 $v$ 的路径中所有城市（包括 $u$ 和 $v$）的美丽度都增加 $d$。
- `4 u v` 询问 $E(u,v)$ 的值。
## 输出格式

对于操作 4，输出答案，一个经过化简的分数 $\frac{p}{q}$。如果 $u$ 和 $v$ 不连通输出 `-1`。
## 样例

### 样例输入 #1
```
4 5
1 3 2 5
1 2
1 3
2 4
4 2 4
1 2 4
2 3 4
3 1 4 1
4 1 4
```
### 样例输出 #1
```
16/3
6/1
```
## 提示

对于所有数据满足 $1\le N\le 50000,1\le M\le 50000,1\le a_i\le 10^6,1\le D\le 100,1\le u,v\le N$。


---

---
title: "MloVtry的idea"
layout: "post"
diff: 省选/NOI-
pid: P4855
tag: []
---
# MloVtry的idea
## 题目背景

点击～

## 题目描述

MloVtry是一个脑洞很大的人，它总会想出一些奇奇怪怪的idea。

可问题是，MloVtry作为一个蒟蒻，很多时候都没办法解决自己提出的问题，所以MloVtry想出一套题的梦想一直被搁置。

不过好在MloVtry有一些神犇朋友，他们强的没边，所以MloVtry一有机会就会向这些dalao们请教。

现在MloVtry有n个idea，这n个idea在MloVtry二维的大脑里排成一列，每一个idea都有一个难度值，用a[i]表示，当然难度值越大越困难。

MloVtry准备与q个神犇进行交♂易，但是MloVtry不想问一些过于简单的idea来降自己的B格，又不好意思用太难的、无法解决的idea来伤害自己与神犇之间的感情，所以它每次都会挑idea序列中的第k简单的idea来向神犇询问（也就是难度值第k小的那个idea）。

MloVtry的脑子有坑，但是没关系，这个坑会反而会帮助MloVtry思考，不过这样数列的a[i]就会更新，具体的，设坑在第j个idea上，那么a[i]=a[i]-zz(i<=j);a[i]=i+a[i]-j(i>j)。

如果仅仅如此MloVtry也不会感到迷茫，但关键的是这个坑还会不定时的跳跃，这就让MloVtry手足无措了---它不知道这个时候要问哪个问题了。

现在MloVtry会给出你---它最好的朋友一些询问---一些二元组（at，k），表示脑洞位于at，且它想询问第k简单的idea，请你告诉MloVtry这个idea难度是多少。

## 输入格式

第一行三个整数n,q,zz，含义见题面

第二行n个整数a[1],a[2].....a[n]

随后q行，每行两个整数表示at与k

特别的，MloVtry是一个三维生物，所以它无法想象有人可以在时间轴上翻滚，所以at与k与上一个询问的答案的绝对值的异或值并对n取膜后再+1的值为本次的at和k。

（也就是设lastans为上次询问答案，每一次at=(at^abs(lastans))%n+1,k=(k^abs(lastans))%n+1,并将lastans更新，初始lastans=0）

## 输出格式

q行q个整数，表示对每个询问的回答

## 样例

### 样例输入 #1
```
13 12 56
10100 12208 11766 11872 11336 10815 10710 11872 11536 11988 10100 10908 10815 
11 13
1 3
3 10
1 7
8 4
7 11
11 4
5 2
13 11
13 6
3 11
11 10
```
### 样例输出 #1
```
10044
11932
10918
11280
10044
10759
10827
11874
12152
10759
10044
10713
```
## 提示

各个值保证在int范围内。

对于100%的数据，n,q<=6w。

对于40%的数据，n,q<=1000。

PS.可能有重复，例如

1 1 1 1 1 0

此时第1大、第2大....第5大的值都是1，第6大的值是0



---

---
title: "[PA 2013] Karty"
layout: "post"
diff: 省选/NOI-
pid: P4858
tag: ['2013', 'PA（波兰）']
---
# [PA 2013] Karty
## 题目描述

给定 $n\times m$ 的矩形，每个点仅可能为 `_` 或 `X`， 选出一个最大的 $r\times c$ 的矩形，使得多个 $r\times c$ 的矩形能够(可以重叠的)覆盖全部 `X` 部分，不覆盖 `_` 部分。
## 输入格式

第一行 $n,m$ 如题意所述。

接下来 $n$ 行，每行一个长为 $m$ 的字符串描述这个矩阵。
## 输出格式

输出一行，两个数 $r,c$，用空格隔开。

同时有多个面积最大的要输出 $r$ 最小的那个。
## 样例

### 样例输入 #1
```
4 5
_XXX_
XXXX_
XXXXX
_XXXX
```
### 样例输出 #1
```
2 3
```
## 提示

对于 $100\%$ 的数据，$1\le n,m\le 2.5\times 10^3$。


---

---
title: "已经没有什么好害怕的了"
layout: "post"
diff: 省选/NOI-
pid: P4859
tag: []
---
# 已经没有什么好害怕的了
## 题目描述

已经使 Madoka 有签订契约，和自己一起战斗的想法后，Mami 忽然感到自己不再是孤单一人了呢。

于是，之前的谨慎的战斗作风也消失了，在对 Charlotte 的傀儡使用终曲——Tiro Finale 后，Mami 面临着即将被 Charlotte 的本体吃掉的局面。

这时，已经多次面对过 Charlotte 的 Homura 告诉了学 OI 的你这样一个性质：Charlotte 的结界中有两种具有能量的元素，一种是“糖果”，另一种是“药片”，各有 $n$ 个。在 Charlotte 发动进攻前，“糖果”和“药片”会两两配对，若恰好糖果比药片能量大的组数比“药片”比“糖果”能量大的组数多 $k$ 组，则在这种局面下，Charlotte 的攻击会丟失，从而 Mami 仍有消灭 Charlotte 的可能。

你必须根据 Homura 告诉你的“糖果”和“药片”的能量的信息迅速告诉 Homura 这种情况的个数.
## 输入格式

第一行两个整数 $n,k$，含义如题目所描述。

接下来一行 $n$ 个整数，第 $i$ 个数表示第 $i$ 个糖果的能量。

接下来 $n$ 个整数，第 $j$ 个数表示第 $j$ 个药片的能量。

保证上面两行不会有重复的数字。
## 输出格式

一个答案，表示消灭 Charlotte 的情况个数，需要对 $10^9+9$ 取模。
## 样例

### 样例输入 #1
```
4 2
5 35 15 45
40 20 10 30

```
### 样例输出 #1
```
4
```
## 提示

【样例解释】

正确的组合为：

(5-40,35-20,15-10,45-30)，    
(5-40,45-20,15-10,35-30)，   
(45-40,5-20,15-10,35-30)，   
(45-40,35-20,15-10,5-30).   

【数据范围】
对于 $100\%$ 的数据，$1 \le n \le 2000$，$0 \le k \le n$。


---

---
title: "Jerry Loves Lines"
layout: "post"
diff: 省选/NOI-
pid: P4864
tag: ['O2优化']
---
# Jerry Loves Lines
## 题目背景

Jerry很喜欢在纸上面画直线呢..
## 题目描述

Jerry在纸上面画上了$N$条直线,每一条直线都可以用$y=k_ix+b_i$来表示.现在Jerry想知道对于$M$条可以表示为$X=A_j$的直线,从下往上数排名第$K$的交点的$y$坐标是多少.

如有$x$条直线与一条$X=A_j$的直线交于同一点,算$x$个点.
## 输入格式

第一行三个正整数$N$,$M$,$K$

接下来$N$行,每一行两个非零整数$k_i$和$b_i$描述了一条直线.

接下来$M$行,每行一个整数$A_j$表示一个询问.
## 输出格式

$M$行,每一行一个整数表示答案.
## 样例

### 样例输入 #1
```
2 3 1
1 2
2 1
0
1
2

```
### 样例输出 #1
```
1
3
4
```
## 提示

对于$30\%$的数据: $1 \leqslant N,M \leqslant 2000$

对于$100\%$的数据: $1 \leqslant N \leqslant 2000, 1 \leqslant M \leqslant 5*10^5$

其他所有读入的数全在int范围内,且保证$1 \leqslant K \leqslant N$.

温馨提示:如果对自己的做法的常数感到不放心,请吸入氧气..(食用O2优化)如果有着充足自信,尽管放手浪..

$\color{white}{\text{int*int会爆int!!!}}$


---

---
title: "[USACO14MAR] The Lazy Cow G"
layout: "post"
diff: 省选/NOI-
pid: P4876
tag: ['2014', 'USACO']
---
# [USACO14MAR] The Lazy Cow G
## 题目描述

It's a hot summer day, and Bessie the cow is feeling quite lazy. She wants to locate herself at a position in her field so that she can reach as much delicious grass as possible within only a short distance.

There are $N$ patches of grass $(1 <= N <= 100,000)$ in Bessie's field. The $ith$ such patch contains $g_i$ units of grass $(1 <= g_i <= 10,000)$ and is located at a distinct point $(x_i, y_i)$ in the field $(0 <= x_i,$ $y_i <= $ $1,000,000)$.  Bessie would like to choose a point in the field as her initial location (possibly the same point as a patch of grass, and possibly even a point with non-integer coordinates) so that a maximum amount of grass is within a distance of $K$ steps from this location $(1 <= K <= 2,000,000)$.

When Bessie takes a step, she moves 1 unit north, south, east, or west of her current position.  For example, to move from $(0,0)$ to $(3,2)$, this requires 5 total steps.  Bessie does not need to take integer-sized steps -- for example, 1 total step could be divided up as half a unit north and half a unit east.

Please help Bessie determine the maximum amount of grass she can reach, if she chooses the best possible initial location.

## 输入格式

* Line 1: The integers $N$ and $K$.

* Lines 2..1+N: Line $i+1$ describes the $ith$ patch of grass using 3 integers: $g_i, x_i, y_i.$

## 输出格式

* Line 1: The maximum amount of grass Bessie can reach within $K$ steps, if she locates herself at the best possible initial position.
## 样例

### 样例输入 #1
```
4 3
7 8 6
3 0 0
4 6 0
1 4 2
```
### 样例输出 #1
```
8
```
## 提示

INPUT DETAILS:

Bessie is willing to take at most 3 steps from her initial position.  There
are 4 patches of grass.  The first contains 7 units of grass and is located
at position $(8,6)$, and so on.

OUTPUT DETAILS:

By locating herself at $(3,0)$, the grass at positions $(0,0)$, $(6,0)$, and
$(4,2)$ is all within $K$ units of distance.
## 题目翻译

```
  Bessie的田里有N(1<=N<=100,000)块草地，每块草地的坐标是 (xi, yi) (0<=xi,yi<=1,000,000),上面长着gi(1<=gi<=10,000)个单位的牧草。 
  Bessie可以向东南西北方向走，一次走一步（一个单位长度）。如她从（0,0）走到（3,2）需要5步。她最多可以一次走k (1<=k<=2,000,000) 步。
  现在她想找一个位置，使她从该位置出发可以得到最多单位的牧草(她可以走多次，但每次都从该位置出发)。 
  输入格式： 
  第1行：两个整数N和K 
  第2~N+1行：三个整数gi，xi，yi 
  输出格式： 
  第1行：Bessie所能获得的最多单位牧草数
```


---

---
title: "lty loves 96！"
layout: "post"
diff: 省选/NOI-
pid: P4882
tag: []
---
# lty loves 96！
## 题目背景

众所周知，$lty$非常喜欢$96$这两个数字（想歪的现在马上面壁去），更甚于复读~~（人本复）~~！
## 题目描述

由于爱屋及乌，因此，$lty$对于那些含有$96$的数也非常喜欢，而这里的含有不是一般的含有，而是具有以下性质的含有（三条都需要满足）：
* 这个数为一个$N$位数，且没有前置零
* 这个数中至少要出现$M$次$9$和$6$（例：$986996$中出现了$5$次，$9$出现了$3$次，$6$出现了$2$次，共计$5$次）
* 这个数存在连续的三位$A$,$B$,$C$，满足下面任意一条
	* $A+B+C$为$9$或$6$
	* $(A^2+B^2)$%$C$为$9$或$6$，如果$C$为$0$，则该条件视为不满足
## 输入格式

一行，两个数$N$,$M$
## 输出格式

一个数，表示这样的数的个数
## 样例

### 样例输入 #1
```
3 1
```
### 样例输出 #1
```
16
```
## 提示

对于10%的数据，$N<=6$

对于40%的数据，$N<=18$

对于100%的数据，$N<=50$，$0<=M<=N$



---

---
title: "Never·island"
layout: "post"
diff: 省选/NOI-
pid: P4890
tag: ['洛谷月赛']
---
# Never·island
## 题目背景

您一觉醒来，发现已经到了20000年后的未来。
## 题目描述

为了寻找传说中的Avalon，island派出了 $n$ 个考察队。为了保持island的稳定，island有一个通向外界的大门。

这 $n$ 个考察队都需要出一次门进行考察，其中第 $i$ 支考察队会在 $l_i$ 时刻离开，并且在第 $r_i$ 时刻回来。我们保证这些值都是互不相等的。

每当一支考察队离开时，island的大门会变成开的。但是如果这支考察队得到了钥匙，那么他就可以决定关门或者不关门。同时每一个考察队回来的时候要么门本来就是开的（由于island是已知唯一的生活区，因此island内部人员不会主动为任何人开门），要么他必须拥有一把钥匙把门打开。注意，回来的时候无论有没有钥匙，那么这支考察队都可以选择把门关上。

由于一些奇怪的原因，island的设计者只设计了 $k$ 把钥匙，只能分给 $k$ 支考察队。得到钥匙证明了island上层对考察队的信任，因此考察队不会把钥匙交给任何人。

为了防止island下层居民逃出island，上层希望门处于开的时间越短越好。希望您帮他算出最短门会开多久。
## 输入格式

第一行是两个正整数 $n,k$

第二行开始共 $n$ 行，每行两个数，描述 $l_i,r_i$


## 输出格式

一个正整数，表示答案。
## 样例

### 样例输入 #1
```
5 2
1 9
2 10
3 5
7 12
15 17

```
### 样例输出 #1
```
6

```
## 提示

【样例解释】
``` 
④                     ================
③/⑤       -------                              ------
②      -------------------------
①   ========================= 
    1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17
状态 X  O  O  O  X  X  X  X  O  X  X  X  X  X  O  O 
```
其中，1、4号考察队会带钥匙。

【数据范围】

对于 $30\%$ 的测试数据，$n \leq 20$

对于 $60\%$的测试数据，$n \leq 200$

对于全部的测试数据，$n \leq 2000$

$1 \leq l_i < r_i\leq 10^9, k \le n$


---

---
title: "独钓寒江雪"
layout: "post"
diff: 省选/NOI-
pid: P4895
tag: ['O2优化']
---
# 独钓寒江雪
## 题目描述

给定一棵无根树，求其中本质不同的独立集的个数。
## 输入格式

第一行：一个整数$n$，树上的结点数量（$n \leq 5\times 10^5$）

第二行到第$n$行：每行两个整数$u$和$v$，表示$u$和$v$连着一条边
## 输出格式

单个整数：输出方案数模$10^9+7$的余数
## 样例

### 样例输入 #1
```
1

```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
5
1 2
1 3
1 4
1 5
```
### 样例输出 #2
```
6
```
### 样例输入 #3
```
6
1 2
1 3
1 4
4 5
4 6
```
### 样例输出 #3
```
9
```


---

---
title: "Marisa采蘑菇"
layout: "post"
diff: 省选/NOI-
pid: P4919
tag: []
---
# Marisa采蘑菇
## 题目背景

$\text {Marisa}$ 是一个爱魔法的女孩子，而火力高而华丽的八卦炉正是她常用的武器，随着时代的进步，$\text {Marisa}$ 也想要升级她的八卦炉的火力，所以她决定去魔法森林采蘑菇来获得做实验的材料  
## 题目描述

$\text {Marisa}$ 来到了森林之中，看到了一排 $n$ 个五颜六色的蘑菇，这些蘑菇的颜色分别为 $a_1,a_2,...,a_n$ 。由于她很挑剔，所以她只会采那些"魔法蘑菇" 。 

一个蘑菇被叫做"魔法蘑菇"，当且仅当它**在给定的某段区间内**，并且在这段给定区间内与它颜色相同的蘑菇(包括它本身)的个数，与在这个给定区间外这种颜色的蘑菇的个数之差小于等于给定的常数 $k$  

现在 $\text {Marisa}$ 会做出 $m$ 个询问,每次询问你 $[l,r]$ 中有多少种不同颜色的"魔法蘑菇"  
## 输入格式

第一行三个整数 $n,m,k$   

第二行 $n$ 个正整数，表示蘑菇的颜色 $a_i$   

之后 $m$ 行，每行两个正整数 $l_i,r_i$ ，表示 $\text{Marisa}$ 询问区间的左端点和右端点，数据保证 $0<l≤r≤n$  

## 输出格式

共 $m$ 行，每行一个整数 $x$ ，表示询问区间中**不同颜色**的"魔法蘑菇"的种数  
## 样例

### 样例输入 #1
```
6 3 2
2 3 2 4 1 2
1 2
2 4
1 6
```
### 样例输出 #1
```
2
3
3
```
## 提示

#### 样例解释:  

常数 $k=2$ ，对于区间  $[1,2]$:    

$a_1=2$，$2$这种颜色的蘑菇在区间 $[1,2]$ 内出现了 $1$ 次，在区间外出现了 $2$ 次，相差为 $|1-2|=1<2$   

$a_2=3$，$3$这种颜色的蘑菇在区间 $[1,2]$ 内出现了 $1$ 次，在区间外出现了 $0$ 次，相差为 $|1-0|=1<2$  

所以 $[1,2]$ 中有两种颜色不同的魔法蘑菇  

#### 数据范围:  

对于全部数据，$a_i \le 10^6,1 \le l_i \le r \le n$

对于 $20\%$ 的数据，$1 \le n,m \le 100,0 \le k \le 5$  

对于 $50\%$ 的数据，$1 \le n,m \le 10^5,0 \le k \le 100$   

对于 $100\%$ 的数据，$1 \le n,m \le 10^6,0 \le k \le 10^4$ 

ps:请注意读入效率  


---

---
title: "War1"
layout: "post"
diff: 省选/NOI-
pid: P4938
tag: ['Special Judge']
---
# War1
## 题目背景

`XM大战`来临之际，`ENLIGHTENED总部`为了抵御`RESISTANCE`的进攻，调整了某地`Portal`的能量值，使得其可以经受更多的打击。
## 题目描述

`ENLIGHTENED总部`有$N$个`Portal`，编号为$1$~$N$，编号为$i$的`Portal`初始能量值为$A[i]$，在`Portal`之间有$M$条`LINK`，每条`LINK`着连接着两个不同`Portal`，被连接着的两个`Portal`可以相互传输能量，每个`Portal`最多总共只能向其连接着的`Portal`传输$A[i]$点能量，现在`ENLIGHTENED行动指挥想让每第i个Portal的能量值变为至少B[i]，但他不知道着可不可行，所以找到了你，如果可行的话，需要你求出一种可行的能量传输方案。

**能量只能直接传输不能间接传输**
## 输入格式

第一行数两个个整数$N,M$。

第二行有$N$个整数，第$i$个整数代表$A[i]$

第三行有$N$个整数，第$i$个整数代表$B[i]$

下接$M$行，每行输入两个整数$X,Y$，代表编号为$X$的`Portal`到编号为$Y$的`Portal`有一条`LINK`。
## 输出格式

若有可行方案输出`YES`，并且下接$N$行，每行$N$个整数，第$i$行第$j$个数代表代表编号为$i$的`Portal`向编号为$j$的`Portal`传输的能量值。若$i=j$输出第$i$个`Portal`传输后留下的能量值。若有多种可行方案输出其中一种即可。

若无可行方案输出`NO`
## 样例

### 样例输入 #1
```
3 2 
1 2 3
0 0 6
1 3
2 3

```
### 样例输出 #1
```
YES
0 0 1
0 0 2
0 0 3 
```
### 样例输入 #2
```
3 2 
1 2 3
0 0 7
1 3
2 3
```
### 样例输出 #2
```
NO
```
## 提示

对于$20\%$的数据 $N \leq 10$

对于$40\%$的数据 $N\leq 25$

对于$60\%$的数据 $N\leq 50$

对于100\%的数据 $N \leq 100,M \leq 2*N,0 \leq A[i],B[i] \leq 100$


---

---
title: "War2"
layout: "post"
diff: 省选/NOI-
pid: P4941
tag: ['O2优化']
---
# War2
## 题目背景

`XM大战`如期而至，`Agent`们齐聚一地，展开最后的对决。对战有很多种方式，有些复杂的方式可以获得更高的分数。可惜`ENLIGHTENED`的人并不怎么聪明，只会简单的`hack`，所以`ENLIGHTENED行动指挥`找到了你来做他们的总参谋。
## 题目描述

地图上有$N$个`Portal`，现在某一名`Agent`的任务是占领该地图上的$M$个`Portal`，这名`Agent`占领第$i$个`Portal`可以得到的分数为$A[i]$，除了直接占领，还有其他的$K$种加分方式，对于着$N$个`Portal`，在占领完第$X[i]$个`Portal`后占领第$Y[i]$个`Portal`可以获得$B[i]$的加分，加分可能会有重复。`Agent`希望他可以为团队争取更多的分数，所以请求作为大战参谋的你来帮助他。
## 输入格式

第一行是输入三个整数$N,M,K$
第二行输入是$N$个数，第$i$个数代表$A[i]$的值。
下面$K$行每行有3个整数$X[i],Y[i],C[i]$，表示在占领完第$X[i]$个`Portal`后占领第$Y[i]$个`Portal`可以获得$B[i]$的加分
## 输出格式

输出仅一行一个整数，为该名`Agent`可以获得的最大分数值。
## 样例

### 样例输入 #1
```
3 2 1
1 1 1
1 2 3
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
4 3 2
1 1 1 1
4 3 2
3 2 1
```
### 样例输出 #2
```
6
```
## 提示

对于$20\%$的数据 $1 \leq M \leq N \leq 4,0 \leq A[i],B[i] \leq 10^3$

对于$40\%$的数据 $1 \leq M \leq N \leq 8,0 \leq A[i],B[i] \leq 10^5$

对于$60\%$的数据 $1 \leq M \leq N \leq 12,0 \leq A[i],B[i] \leq 10^7$

对于$100\%$的数据 $1 \leq M,X[i],Y[i] \leq N \leq 18,0 \leq K \leq N^2−N,0 \leq A[i],B[i] \leq 10^9$


---

---
title: "完美数字"
layout: "post"
diff: 省选/NOI-
pid: P4950
tag: []
---
# 完美数字
## 题目描述

给出两个数字集合$S$和$T$，其中元素均为$0$到$9$之间的整数。

定义“完美数字”为数位中包含$S$中所有的数且不包含$T$中任意一个数的数字。

例如$S=\{1,3,4\}$，$T=\{7,8\}$，则$1345$、$341166$、$4133129$都是完美数字。

而$13$、$8431$、$34171$都不是完美数字（因为$13$数位中不包含$4$，$8431$和$34171$中虽然包含了$1$、$3$、$4$这三个数但又包含$8$和$7$）。

求$[l,r]$中所有完美数字的和。
## 输入格式

第一行一个整数$t$，数据组数。

以下是$t$组数据：

第一行是两个整数$l$和$r$；

第二行首先一个正整数$|S|$，随后$|S|$个整数是$S$中的元素；

第三行首先一个正整数$|T|$，随后$|T|$个整数是$T$中的元素。

## 输出格式

对于每组数据输出一个整数，完美数字的和。
## 样例

### 样例输入 #1
```
3
11 40
1 3
2 4 7
2018 20170901
1 4
1 7
19260817 998244353
3 2 5 6
4 0 7 8 9

```
### 样例输出 #1
```
310
52885750312822
2039707997741122

```
## 提示

样例解释

对于第一组样例数据，完美数字为：

$13$、$23$、$30$、$31$、$32$、$33$、$35$、$36$、$38$、$39$。

所以总和为$310$。

数据范围

对于$30\%$的数据，$1<=l<=r<10^4$

另有$10\%$的数据，$|S|=|T|=0$

对于$100\%$的数据，$t<=2000$，$1<=l<=r<10^9$，保证$S$和$T$中的元素均为$[0,9]$中的整数且互不相同。


---

---
title: "[USACO02FEB] Cow Cycling"
layout: "post"
diff: 省选/NOI-
pid: P4953
tag: ['2002', 'USACO']
---
# [USACO02FEB] Cow Cycling
## 题目描述

奶牛自行车队由 $N$ 名队员组成，他们正准备参加一个比赛，这场比赛的路程共有 $D$ 圈。车队在比赛时会排成一条直线，由于存在空气阻力，当骑车速度达到每分钟 $x$ 圈时，领头的奶牛每分钟消耗的体力为 $x^2$，其它奶牛每分钟消耗的体力为 $x$。每头奶牛的初始体力值都是相同的，记作 $E$。如果有些奶牛在比赛过程中的体力不支，就会掉队，掉队的奶牛不能继续参加比赛。每支队伍最后只要有一头奶牛能到终点就可以了。

比赛规定，最小的计时单位是分钟，在每分钟开始的时候，车队要哪头奶牛负责领头，领头奶牛不能在这分数中内掉队，每分钟骑过的圈数也必须是整数。

请帮忙计划一下，采用什么样的策略才能让车队以最快的时间到达终点？
## 输入格式

第一行：三个正整数：$N, E, D$。$1 \leq N \leq 20$，$1 \leq E \leq 100$，$1 \leq D \leq 100$。
## 输出格式

第一行：单独一个整数，表示最早达到终点的时间，如果无法到达终点，输出 $0$。
## 样例

### 样例输入 #1
```
3 30 20
```
### 样例输出 #1
```
7
```
## 提示

![](https://cdn.luogu.com.cn/upload/image_hosting/spwg7uf6.png)


---

---
title: "[USACO09OPEN] Tower of Hay G"
layout: "post"
diff: 省选/NOI-
pid: P4954
tag: ['2009', 'USACO']
---
# [USACO09OPEN] Tower of Hay G
## 题目背景

为了调整电灯亮度，贝西要用干草包堆出一座塔，然后爬到牛棚顶去把灯泡换掉。干草包会从传送带上运来，共会出现 $n$ 包干草，第 $i$ 包干草的宽度是 $W_i$，高度和长度统一为 $1$。干草塔要从底层开始铺建。贝西会选择最先送来的若干包干草，堆在地上作为第一层，然后再把紧接着送来的几包干草包放在第二层， 再铺建第三层……重复这个过程，一直到所有的干草全部用完。每层的干草包必须紧靠在一起，不出现缝隙，而且为了建筑稳定，上层干草的宽度不能超过下层的宽度。 按顺序运来的干草包一定要都用上，不能将其中几个干草包弃置不用。贝西的目标是建一座最高的塔，请你来帮助她完成这个任务吧。
## 输入格式

第一行：一个整数 $n,\ (1 ≤ n ≤ 100000)$

第二行到 $n + 1$ 行：第 $i + 1$ 行有一个整数 $W_i,\ (1 ≤ W_i ≤ 10000)$。
## 输出格式

第一行：单个整数，表示可以建立的最高高度。
## 样例

### 样例输入 #1
```
3
1
2
3
```
### 样例输出 #1
```
2
```
## 提示

### 样例解释

将 $1$ 和 $2$ 放在第一层，将 $3$ 放在第二层。


---

---
title: "毒瘤之神TM菱树-①"
layout: "post"
diff: 省选/NOI-
pid: P4975
tag: []
---
# 毒瘤之神TM菱树-①
## 题目背景

本题图片可能较大请耐心加载

什么?菱树是什么??

好吧这个是蒟蒻自己搞事搞的一个非常简单的不是树但很像树的图..

就像这样..

![菱树](https://i.loli.net/2018/10/07/5bba0e85cbc10.png)

(好吧图有点大(空旷)..)
## 题目描述

现在给你一棵无限大的菱树(就是下面不止上面的图那么点大..)

然后有$T$组询问,每一组询问都是给出$u$和$v$,求出这两个点的最短路径的长度..
## 输入格式

第一行一个正整数$T$

接下来$T$行每一行两个正整数表示询问的两个点..
## 输出格式

$T$行,每行一个整数表示询问的答案.
## 样例

### 样例输入 #1
```
3
1 1
5 10
6 7

```
### 样例输出 #1
```
0
7
9

```
## 提示

${\rm Subtask\ 1(10\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq u_i, v_i \leq 100$

${\rm Subtask\ 2(20\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq u_i, v_i \leq 10^3$

${\rm Subtask\ 3(30\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq u_i, v_i \leq 10^5$

${\rm Subtask\ 4(40\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq u_i, v_i \leq 10^{18}$


---

---
title: "毒瘤之神TM菱树-②"
layout: "post"
diff: 省选/NOI-
pid: P4976
tag: ['O2优化']
---
# 毒瘤之神TM菱树-②
## 题目背景

什么?菱树是什么??

好吧这个是蒟蒻自己搞事搞的一个非常简单的不是树但很像树的图..

就像这样..

![菱树](https://i.loli.net/2018/10/07/5bba0e85cbc10.png)

(好吧图有点大(空旷)..)
## 题目描述

现在给你$T$棵菱树,每一颗菱树的层数为$n_i$,请求出菱树中所有点对的最短路径的和..
## 输入格式

第一行一个正整数$T$

接下来$T$行每一行一个正整数$n_i$表示菱树的大小..
## 输出格式

$T$行,每行一个整数表示对于当前这颗菱树的所有点对的最短路径的和模$998244853$的结果.
## 样例

### 样例输入 #1
```
5
1
2
3
4
5
```
### 样例输出 #1
```
0
4
43
225
812

```
## 提示

${\rm Subtask\ 1(10\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq n_i \leq 10$

${\rm Subtask\ 2(20\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq n_i \leq 100$

${\rm Subtask\ 3(30\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq n_i \leq 1000$

${\rm Subtask\ 4(40\ pts)}: 1 \leq T \leq 10000 \qquad 1 \leq n_i \leq 5*10^6$

为了防止打表，所以空间限制缩小至64MB。


---

---
title: "回文项链"
layout: "post"
diff: 省选/NOI-
pid: P4987
tag: ['洛谷原创']
---
# 回文项链
## 题目背景

**数据已增强，各位不要再交暴力了。**

国庆节期间，哥哥送了小埋一条项链。（假的，日本人过什么国庆。）

然而小埋不太开心，她更想要买一部新手机玩游戏。
## 题目描述

不过小埋很快发现了项链的神奇之处。

我们把项链看作一个$n$元环，记作$s$，环上每个结点由大写'A'-'Z'中的一个字母组成。小埋惊奇的发现，环上有很多回文串！我们定义回文串为环上一个首尾不重叠的连续子串（即环上每个结点最多被使用一次），且满足**存在一个回文中心**$i$，使得$i$之前的若干个字符分别与其关于$i$中心对称的字符相同。

现在，小埋给出你这个环，并希望知道有多少长度为$l$的本质不同的回文串；我们认为两个回文串本质不同，当且仅当它们回文中心所在结点不同。
## 输入格式

第一行，两个数表示$n$，$l$；

接下来一行读入连续的$n$个字母，分别表示$s_1$，$s_2$，…，$s_n$；其中$s_i$与$s_i$ $_{mod}$ $_{n+1}$相邻。
## 输出格式

一行，表示长度为$l$的回文串的个数。
## 样例

### 样例输入 #1
```
16 1
XIAOMAITAIBANGLE
```
### 样例输出 #1
```
16
```
### 样例输入 #2
```
4 3
ABAB
```
### 样例输出 #2
```
4
```
## 提示

**本题每个测试点时限500ms**

对于$30$%的数据，$n<=20$；

对于$50$%的数据，$n<=200$；

对于$80$%的数据，$n<=2000$；

对于$100$%的数据，$n<=10^6$，$0<l<=n$且$l$为奇数。

**仔细读题，本题回文串与传统意义上的回文串不同。**


---

---
title: "重排DL"
layout: "post"
diff: 省选/NOI-
pid: P4988
tag: ['洛谷原创', 'O2优化']
---
# 重排DL
## 题目背景

Dancing Line 的关卡排序总是很玄学。
## 题目描述

这天小埋给 Dancing Line 中关卡排序制定了一个新的规则：假设某一关为第 $n$ 个发布的关卡，那么它的位置 $a_n$ 满足 $a_{n+1}=(\sqrt[k]{a_n-n}+2)^k+n+1$，且第一个发布的关卡总是排在第一，即 $a_1=2$。

但是这样显然会出现一个问题：许多位置是空关卡。所以小埋又给出了一个限制条件：调整 $k$，使得第 $n$ 个关卡满足 $a_n \equiv b\pmod{m}$。现在小埋给了 $n,m,b$，求最小满足条件的**整数** $k$。
## 输入格式

第一行，三个数 $n,m,b$。
## 输出格式

一个数，表示最小的 $k$；如果不存在最小 $k$，则输出 `INF`。
## 样例

### 样例输入 #1
```
3 3 2
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
3 8 2
```
### 样例输出 #2
```
INF
```
## 提示

对于 $30\%$ 的数据，$n\le 100$，$0\le b<m\le 10000$；

对于 $50\%$ 的数据，$n\le 10^{12}$，$0\le b<m\le 10000$；

对于 $100\%$ 的数据，$n\le 10^{12}$，$0\le b<m\le 10^{12}$。

保证 $n,m,b$ 均为正整数。


---

---
title: "小埋与刺客传奇"
layout: "post"
diff: 省选/NOI-
pid: P4990
tag: ['洛谷原创', 'O2优化']
---
# 小埋与刺客传奇
## 题目背景

**数据已更新。**

经过几天几夜的硬肝，小埋终于玩到了最后一关，也是$Dancing$ $Line$的魔王关——$The$ $Legend$ $of$ $Assassin$

![avatar](https://cdn.luogu.com.cn/upload/pic/34876.png)

![avatar](https://cdn.luogu.com.cn/upload/pic/35145.png)
## 题目描述

如图，魔王关经常出现炸路与突发障碍。

小埋很苦恼，因为她不知道完整的地图。于是她进行了许多尝试，总结了随着时间变化而出现或消失的路与她在这些时刻时的位置，**为了简化问题，我们假定小埋的位置始终不变**。

现在她想知道，她至少从什么时刻开始才可以看到能通向终点的路；由于一些路径上有钻石，这些钻石能带来一定加分，小埋还希望知道她在最早看到能通向终点的路时，按照当前地图走向终点所能获得的最大得分。
## 输入格式

第一行，两个数$n$，$m$，分别表示地图的结点数与初始边数，结点从$1-n$进行编号；初始时，为第$0$时刻，小埋在$1$号结点，且终点始终为$n$；

接下来$m$行，每行三个数$u_i$，$v_i$，$w_i$，表示一条从$u_i$到$v_i$的得分为$w_i$的边；

接下来一行，一个整数$t$，表示出现新边或旧边消失的时刻数，如无边出现或消失，$t=0$；

接下来$t$行，每行第一个数为$tm_j$，表示出现这一事件的时刻；第二个数为$type$，若$type==0$，表示出现了一条新边，之后会有三个数$u_j$，$v_j$，$w_j$，分别表示一条边信息（含义同上）；若$type==1$，之后会有一个数$k$，表示当前**时刻**未消失的第$k$条路消失了。
## 输出格式

若任何时刻下都不能到达终点，则输出”$Continue$ $from$ $the$ $last$ $checkpoint$”，否则输出两行：第一行为一个数$tmp$，表示看到通向终点路径时的最小时刻；第二行为一个数$score$，表示在上述时刻时到达终点所能获得的最大分数。
## 样例

### 样例输入 #1
```
3 3
1 2 1
2 3 1
1 3 1
0
```
### 样例输出 #1
```
0
2
```
### 样例输入 #2
```
3 3
1 2 1
2 2 0
3 1 1
0
```
### 样例输出 #2
```
Continue from the last checkpoint
```
### 样例输入 #3
```
3 3
1 2 1
2 2 0
3 1 1
4
2 0 1 3 1
1 1 3
3 1 1
5 1 1
```
### 样例输出 #3
```
2
1
```
## 提示

本题共$10$个测试点，各测试点详细信息如下：

$1$：$n<=100000$，$m<=200000$，$t<=100000$；输出“$Continue$ $from$ $the$ $last$ $checkpoint$”；分值：$5$；

$2$：$n<=100$，$m<=10000$，$t<=100$；无特殊性质；分值：$10$；

$3$：$n<=100000$，$m<=200000$，$t<=100000$；所有边的分数为$0$；分值：$10$；

$4$：$n<=100000$，$m<=200000$，$t=0$；无新增或消失的边；分值：$5$；

$5$~$6$：$n<=100000$，$m<=200000$，$t<=100000$；无消失的边；分值：$10$；

$7$~$8$：$n<=100000$，$m<=200000$，$t<=100000$；无出现的边；分值：$10$；

$9$~$10$：$n<=100000$，$m<=200000$，$t<=100000$；消失的边不超过$1000$条；分值：$15$。

另外，对于所有数据，$0<u_i,u_j,v_i,v_j<=n$，$0<=w_i,w_j<=10$，$0<tm_j<=10t$，且$tm_j$互不相同；数据保证不出现正环。


---

---
title: "[SHOI2010] 最小生成树"
layout: "post"
diff: 省选/NOI-
pid: P5039
tag: ['2010', '各省省选', '上海']
---
# [SHOI2010] 最小生成树
## 题目描述

Secsa最近对最小生成树问题特别感兴趣。他已经知道如果要去求出一个 $ n $ 个点、 $ m $ 条边的无向图的最小生成树有一个Krustal算法和另一个Prim的算法。另外，他还知道，某一个图可能有多种不同的最小生成树。例如，下面图3中所示的都是图2中的无向图的最小生成树：

![](https://cdn.luogu.com.cn/upload/pic/43631.png)

当然啦，这些都不是今天需要你解决的问题。Secsa想知道对于某一条无向图中的边AB，至少需要多少代价可以保证AB边在这个无向图的最小生成树中。为了使得AB边一定在最小生成树中，你可以对这个无向图进行操作，一次单独的操作是指：先选择一条图中的边 P1P2，再把图中除了这条边以外的边，每一条的权值都减少 $ 1 $ 。如图4所示就是一次这样的操作：

![](https://cdn.luogu.com.cn/upload/pic/43632.png)


## 输入格式

输入文件的第一行有3个正整数 $ n,m,Lab $ 分别表示无向图中的点数、边数、必须要在最小生成树中出现的AB边的标号。

接下来 $ m $ 行依次描述标号为 $ 1,2,3 \ldots m $ 的无向边，每行描述一条边。每个描述包含3个整数 $ x,y,d $ ，表示这条边连接着标号为 $ x,y $ 的点，且这条边的权值为 $ d $ 。

输入文件保证 $ 1 \leq x,y \leq N $ ， $ x \neq y $ ，且输入数据保证这个无向图一定是一个连通图。
## 输出格式

输出文件只有一行，这行只有一个整数，即，使得标号为 $ Lab $ 边一定出现最小生成树中的最少操作次数。
## 样例

### 样例输入 #1
```
4 6 1
1 2 2
1 3 2
1 4 3
2 3 2
2 4 4
3 4 5
```
### 样例输出 #1
```
1
```
## 提示

$ 1 \leq N \leq 500,1 \leq M \leq 800,1 \leq d<10^6 $


---

---
title: "旅行"
layout: "post"
diff: 省选/NOI-
pid: P5060
tag: ['2018']
---
# 旅行
## 题目背景

$jjc$ 非常喜欢旅行~~（smy）~~！


## 题目描述

**$NOIP$ $2018$** 已经结束了，$jjc$ 决定去全国各地旅行，每个地方都有许多巨佬，他拥有一张地图来帮助他规划一条从 $A $ 地 到 $B $ 地 的路线，地图上有 $N $ 个地点编号为 $1$~$N$ ，有 $ M $ 条道路将不同(或相同)地点有向连通。

现在，$jjc$ 已经知道了通过第 $ i $ 条路从 $u_i $ 地 直接走到 $v_i $ 地 会遇到多少名巨佬，他将记录遇见的每一名巨佬的名字（不管是否记录过）。但是，每记录一名巨佬的名字就需要使用一张便签，便签以袋为单位出售，$jjc$ 选购的便签每一小袋有 $P$ 张。$jjc$ 不希望他购买的便签被浪费，因此他希望他旅程结束后他购买的每一袋便签都 **恰好** 被用完。除此以外，$jjc$ 正在存钱来$......QwQ$，他得减少消费，因此他希望这次旅行能消耗尽量少的便签。

然而，他不知道怎么才能找到最合适的路径，作为巨佬中的一员，你能帮 $jjc $ 解决这个问题，找到符合条件的最佳路径吗？

## 输入格式

第一行，给出五个整数，依次是$N$、$M$、$P$、起点$A$的编号、终点$B$的编号 

从第二行到第$M+1$行描述道路的信息，每行三个整数，依次是第$i$条道路连接的两个地点的起点编号$u_i$、终点编号$v_i$ 及这条道路上会遇见的巨佬数量$num_i$
## 输出格式

若存在满足条件路线，请输出两行，第一行一个整数，表示选择最佳路径上会遇见的巨佬总数，第二行输出从起点$A$到终点$B$的最佳路径的详细路线，数据保证答案是唯一的。

若无满足条件的路线 ，请输出一行一个字符串“$jjc$ $fails$ $in$ $travelling$” $($不含引号$)$
## 样例

### 样例输入 #1
```
2 2 3 1 2
1 2 1
2 2 1
```
### 样例输出 #1
```
3
1->2->2->2
```
### 样例输入 #2
```
4 6 3 2 3
2 1 7
2 4 0
4 3 6
1 4 0 
2 3 1
2 3 9
```
### 样例输出 #2
```
6
2->4->3
```
### 样例输入 #3
```
3 3 5 1 3
1 2 15
2 3 7
1 3 3 
```
### 样例输出 #3
```
jjc fails in travelling
```
## 提示

本题有 $ 3 $ 个 $ Subtask $

对$30$%的数据，$2≤N≤100$ ，$2≤M≤5000$ ，$1≤P≤50$

对另外$20$%的数据 ，$ 2≤N≤5×10^4$，$M≤2×10^5$，$P=1$

对另外$50$%的数据 ，$ 2≤N≤5×10^4$，$M≤2×10^5$，$1≤P≤50$ 

对于所有数据，$1≤A,B,u_i,v_i≤N$，$0≤num_i≤10^8 $  

$By : $ 学无止境


---

---
title: "秘密任务"
layout: "post"
diff: 省选/NOI-
pid: P5061
tag: ['2018', 'Special Judge']
---
# 秘密任务
## 题目背景

>飞雪连天射白鹿，笑书神侠倚碧鸳。

>谨纪念金庸先生。

 但是这与本题没有联系。

## 题目描述

wgr 是 $R$ 国军队总指挥官。现在，他决定组织两个小队分别去执行两个秘密任务。

wgr 将派出 $N$ 名战士来执行这两个任务，他们的编号为 $1 \sim N$ 。由于任务无比重要，wgr 需要使派出的队伍配合绝对默契 。配合绝对默契指队伍中**任何**两名战士的配合都是默契的。同时，他还需要使两个队伍的战斗力差距尽可能小，队伍的战斗力定义为 $F=2^{k}$，$k$ 为队伍的人数，不允许有人剩余。

wgr 已经知道哪些战士之间的配合是默契的，但由于时间紧迫，wgr 来不及慢慢整理资料了，现在，他请你以最快的速度帮他完成资料的整理，并告诉他：

1. 一共有多少种不同的分组方案。两种方案被认为是不同的当且仅当其两支队伍战斗力差值不同。
2. 所有分组方案中，最小的战斗力差值是多少，由于这个差值可能很大，请对  $10^9+7$ 取模后再输出。
3. 有多少对战士配合默契但是不可能被分在同一小组。

**注意：** 特别地，由于队伍的默契程度十分重要，一支队伍 $N$ 名战士另一支队伍 $0$ 名战士也是合法的分组方案。

## 输入格式

第一行两个正整数 $N,M$。 

接下来 $M$ 行每行两个正整数 $x,y$，表示编号为 $x$ 的战士与编号为 $y$ 的战士之间配合默契。

## 输出格式

输出共两行。

第一行，如果存在合法的方案，输出一行两个数，为分组方案数与最小的战斗力差值模 $10^9+7$ 的结果；如果不存在合法的分组方案，第一行输出一个数 $-1$ 即可。

第二行，输出一个整数，表示有多少对战士配合默契但是不可能被分在同一小组。
## 样例

### 样例输入 #1
```
4 4
3 4
1 2
2 4
2 3
```
### 样例输出 #1
```
2 0
0
```
### 样例输入 #2
```
10 2
1 7
3 5

```
### 样例输出 #2
```
-1
2
```
## 提示

本题共有三个 Subtask。

- Subtask 1：共 $5$ 个测试点，一个测试点 $5$ 分，满足 $N≤30$；
- Subtask 2：共 $3$ 个测试点，一个测试点 $10$ 分，满足 $N≤300$；
- Subtask 3：共 $3$ 个测试点，一个测试点 $15$ 分，满足 $N≤2500$。 

对于所有的数据，不会重复说明同一组关系，$1\le x,y\le  n$ 且 $x\neq y$。此外保证 $0\le m≤n\times (n-1)/2$。


本题开启 Special Judge：

- 若你的答案第一行输出正确你可以得到该测试点 $60\%$ 的分数；
- 若你的答案第二行输出正确你可以得到该测试点 $40\%$ 的分数。

为了确保你能够得到部分分，**请按格式要求输出**。



---

---
title: "函数"
layout: "post"
diff: 省选/NOI-
pid: P5083
tag: []
---
# 函数
## 题目描述

小奔有一个二元函数 $f(a,b)$。

如果 $a<2$ 或 $b<2$ 返回 $a+b$。

其他情况则返回以下四个式子的最大值（除号均为整除）：

$$a+b$$

$$g(a/2)+g(a/3)+g(a/8)+g(a/9)+b$$

$$g(b/2)+g(b/3)+g(b/8)+g(b/9)+a$$

$$g(b/2)+g(b/3)+g(b/8)+g(b/9)+g(a/2)+g(a/3)+g(a/8)+g(a/9)$$

其中，$g(n)$ 返回 $\max(g(n/2)+g(n/3)+g(n/8)+g(n/9),n)$，当 $n=0$ 时返回 $0$。

当然，白痴都想得到可以记忆化求出较小的 $f(a,b)$，所以小奔才不会考你那么简单的题呢。

他想问你当 $a,b$ 都小于 $10^{16}$ 时，$f(a,b)$ 的值。

## 输入格式

包含多组数据。

每组数据，包含一行，两个正整数 $a,b$。
## 输出格式

每组数据输出一行，即 $f(a,b)$ 的值。

## 样例

### 样例输入 #1
```
5 6
1 1
1 223
```
### 样例输出 #1
```
11
2
224
```
## 提示

对于 $40\%$ 的数据，$a,b<10^7$。

对于 $70\%$ 的数据，时间限制 $2$ 秒。

对于 $100\%$ 的数据，$a,b<10^{16}$。数据组数不超过 $10^4$ 组。


---

---
title: "不强制在线的动态快速排序"
layout: "post"
diff: 省选/NOI-
pid: P5105
tag: ['O2优化']
---
# 不强制在线的动态快速排序
## 题目背景

曦月最近学会了快速排序，但是她很快地想到了，如果要动态地排序，那要怎么办呢？

## 题目描述

为了研究这个问题，曦月提出了一个十分简单的问题

曦月希望维护一个允许重复的集合$S$，支持：

* 插入$[L, R]$，也就是插入$L, L + 1 ... , R$，这$R - L + 1$个数

* 询问$Sort(S)$

---

$Sort(S)$的定义为：

我们将集合$S$中的元素**从小到大按照快速排序**排好序，记为$a_1, a_2 ... a_n$

那么，$Sort(S) = \bigoplus \limits_{i = 2}^n (a_i^2 - a_{i - 1}^2)$，其中$\bigoplus$表示异或和

关于异或的定义，请咨询度娘
## 输入格式

第一行，一个数$q$

后$q$行，或者是$1\;l\;r$，表示插入$[l, r]$，或者是$2$，表示一次询问
## 输出格式

对于每个询问，一行一个答案
## 样例

### 样例输入 #1
```
2
1 1 1
2

```
### 样例输出 #1
```
0

```
### 样例输入 #2
```
10
1 22 27
1 50 55
1 82 87
1 2 7
2
1 47 52
1 62 67
1 61 66
1 41 46
2
```
### 样例输出 #2
```
2515
2141

```
## 提示

对于样例一的解释：

$S$中只有一个数，因此返回$0$

---

对于$30$分的数据，$q \leqslant 100$

对于$50$分的数据，$q \leqslant 5 * 10^4$

对于另外的$20$分的数据，满足$L = R$

对于$100$分的数据，$q \leqslant 3 * 10^5$，$1 \leqslant L \leqslant R \leqslant 10^9$

保证数据有梯度，可能略微地有卡常，请把自己的常数优化到极致


---

---
title: "dkw的lcm"
layout: "post"
diff: 省选/NOI-
pid: P5106
tag: []
---
# dkw的lcm
## 题目描述

**特别地，一个数的lcm是自身**

善良的dkw决定直接告诉你题面：
$$\prod_{i_1=1}^n\prod_{i_2=1}^n …\prod_{i_k=1}^n \varphi\big(lcm(i_1,i_2,…,i_k)\big)$$
请你求上述式子，答案对 $10^9+7$ 取模。

其中 $lcm(i_1,i_2,...,i_k)$ 代表这 $k$ 个数的最小公倍数。

其中 $\varphi$ 代表欧拉函数，不知道的可以问度娘。

其中 $\prod$ 代表连乘符号，简单来说就是 $\sum$ 的乘法版。
## 输入格式

两个正整数，$n,k$
## 输出格式

一个非负整数，代表式子的值对 $10^9+7$ 取模的结果。
## 样例

### 样例输入 #1
```
2 2
```
### 样例输出 #1
```
1
```
## 提示

对于 50% 的数据，$1\le n,k\le 8$

对于 100% 的数据，$1\le n,k\le 10^6$


---

---
title: "仰望半月的夜空"
layout: "post"
diff: 省选/NOI-
pid: P5108
tag: ['O2优化']
---
# 仰望半月的夜空
## 题目背景

“你不久也会遇到喜欢的女生吧。听好了，你可得好好守护她喔。”

这是父亲给予戎崎裕一的教诲

父亲称不上是一个合格的父亲

但是，却正是这样的父亲，连接了戎崎裕一和秋庭里香

![](https://www.cnblogs.com/images/cnblogs_com/reverymoon/1200086/o_0.png)

秋庭里香，明明是那样的傲娇，却不得不去守护的女生

但同时，又是一个为了回忆，为了懵懂的爱情而坚强着的女生

你是不是在她身上看到了小夜子的身影呢？夏目吾郎医生

你是不是在他身上看到了过去的自己呢？夏目吾郎医生

也许疾病切断了人与人之间的联系，但是曾经存在的痕迹，定将会化作美好的回忆，流传下去

愿你们幸福


## 题目描述

半月的夜空中，寄托了多少人与人之间的思念啊

曦月知道，这些思念会汇集成一个字符串 $S$（$n = |S|$）。

由于思念汇集的过于复杂，因此曦月希望提炼出所有的思念。

我们定义 $Y_S(i)$ 表示对于字符串 $S$ 而言，长度为 $i$ 的子串中，字典序最小的，左端点最小的左端点的值

比如对于串 $S = \texttt{"baa"}$，$Y_S(1) = 2$、$Y_S(2) = 2$、$Y_S(3) = 1$。

曦月会告知你 $S$ 串，你只需要告诉曦月 $Y_S(i)$（$1 \le i \le n$）即可。
## 输入格式

第一行，两个参数，分别是 $\sigma \in \{10, 26, 10^7\}$ 和 $n$。

如果 $\sigma = 26$，那么第二行将是一个长为 $n$ 的小写字母字符串 $S$。

其他情况下，第二行将输入 $n$ 个位于 $[0, \sigma]$ 内的整数。
## 输出格式

输出一行，第 $i$ 个数表示 $Y_S(i)$ 的值。
## 样例

### 样例输入 #1
```
26 11
remoonqaqac
```
### 样例输出 #1
```
8 10 8 8 2 2 2 2 2 2 1
```
### 样例输入 #2
```
26 11
txdydkwqaqa

```
### 样例输出 #2
```
9 9 9 5 5 5 5 3 3 1 1
```
### 样例输入 #3
```
10000000 17
9 9 8 2 4 4 3 5 3 1 9 2 6 0 8 1 7
```
### 样例输出 #3
```
14 14 14 14 10 10 10 10 4 4 4 4 4 4 3 2 1
```
## 提示

数据范围的图不见了 QAQ

最大范围是 $1 \le n \le 3 \times {10}^5$。


---

---
title: "块速递推"
layout: "post"
diff: 省选/NOI-
pid: P5110
tag: ['O2优化']
---
# 块速递推
## 题目背景

shadowice1984 发现了一道题：求斐波那契数列第 $n$ 项模 $10^9+7$ 的值，$n \leq 10^9$。

shadowice1984 想了一个星期可他还是不会做。

当然，这是 shadowice1984 刚学 OI 时候的事情了，今天他学习了矩阵快速幂并且花了一整天解决了上面的问题。

他决定出一道题来测试你的矩阵快速幂水平如何，为了检查他花了一个星期写出的 std 到底有没有错，他决定让你来帮他验题。
## 题目描述

给定一个数列 $a$ 满足递推式

$$a_{n}=233a_{n-1}+666a_{n-2},a_{0}=0,a_{1}=1$$

求这个数列第 $n$ 项模 $10^9+7$ 的值，一共有 $T$ 组询问。

为了在某种程度上减少你的输入和输出量，我们采用以下的代码来生成询问：

```C
namespace Mker
{
	unsigned long long SA,SB,SC;
	void init(){scanf("%llu%llu%llu",&SA,&SB,&SC);}
	unsigned long long rand()
	{
	    SA^=SA<<32,SA^=SA>>13,SA^=SA<<1;
	    unsigned long long t=SA;
		SA=SB,SB=SC,SC^=t^SA;return SC;
	}
}
```
在调用 `Mker::init()` 函数之后这个随机数生成器便可以正常工作了，当你第 $i$ 次调用 `Mker::rand()` 函数时返回的便是第 $i$ 次询问的 $n$ 值。

为了减少你的输出量，你只需要输出所有询问答案的异或和。
## 输入格式

仅一行四个整数，表示 $T,SA,SB,SC$ 的值，你可以在读入 $T$ 之后直接调用 `Mker::init()` 来完成输入工作。
## 输出格式

仅一行一个整数，表示所有答案的异或和。
## 样例

### 样例输入 #1
```
4779 17790102303135 73152356900611 22086182463002
```
### 样例输出 #1
```
391030355
```
### 样例输入 #2
```
49999561 116754637679537 79587668206509 80161279644028
```
### 样例输出 #2
```
705437004
```
## 提示

$SA,SB,SC$ 均在 `unsigned long long` 数据类型的范围之内，由此可以发现返回的 $n$ 值也是 `unsigned long long` 数据类型的范围之内。

前 6 个测试点每个测试点 $1$ 分。

对于 1,2 测试点 $T \leq 5000$。

对于 3,4,5,6 测试点 $T \leq 500000$。

对于所有测试点 $1 \leq T \leq 5×10^7$。


---

---
title: "子异和"
layout: "post"
diff: 省选/NOI-
pid: P5127
tag: []
---
# 子异和
## 题目描述

小L和小K正在激烈地讨论着。

（你不用知道谁说的哪句话……）

“你知道非空子集吗？”

“当然知道啊！比如说集合$\{1,2,3\}$，它的所有非空子集就是$\{1\},\{2\},\{3\},\{1,2\},\{2,3\},\{1,3\},\{1,2,3\}$。”

“那你知道每个非空子集里的数的亦或和是多少吗？”

“也知道啊，不就是$1,2,3,1⊕2=3,2⊕3=1,1⊕3=2,1⊕2⊕3=0$吗。”

“那你知道它们的和是多少吗？我们把它叫做子异和。”

“子异和……这个名字好奇怪啊，不过我知道，是$1+2+3+3+1+2+0=12$。”

“那我问你，$\{a_1,a_2,...,a_n\}$的子异和是多少？”

“慢慢暴力算呗！”

“如果$n\le 200000$呢？”

“……”

“如果把问题放在一颗树上呢？”

“……那你会不会做啊？”

“当然……不会做……”

现在，只有你能帮助小L和小K了，请你帮忙解决这个问题。

**为了更清晰的表达题意，我们再做一次解释。**

有一个$n$个节点的树，总共有$m$次操作。这些操作按照操作顺序输入。每次操作可能是询问或修改。

每次询问操作会给出两个节点编号$a,b$。根据常识，$a,b$在树上有唯一路径。我们设这条路径经过的所有点的点权集合为$S$。你要输出$S$的子异和。答案$mod\space(10^9+7)$。

每次修改操作会给出两个节点编号$a,b$与一个整数值$c$。你要将节点$a$到节点$b$的唯一路径上的所有点的点权分别异或$c$。

**这里的集合指可重集合**
## 输入格式

第一行三个正整数$n,m$。

接下来$n-1$行，每行两个正整数$a,b$，表示节点$a$和$b$之间有一条边。不会出现重边与自环。

接下来一行$n$个非负整数，第$i$个非负整数表示$i$节点的初始点权。

接下来$m$行，每行若干个整数，表示$m$个操作的信息。每行第一个整数只可能是$1$或$2$。如果是$1$，则此操作为询问，接下来两个数为$a,b$；如果是$2$，则此操作为修改，接下来三个数为$a,b,c$。
## 输出格式

对于每一个询问，输出一行表示答案。
## 样例

### 样例输入 #1
```
3 4
1 2
1 3
1 1 1
1 1 1
2 1 3 1
2 3 3 1
1 1 3
```
### 样例输出 #1
```
1
2
```
## 提示

样例解释：

第一次询问，$1$到$1$的路径经过$1$号节点，点权组成的集合为$\{1\}$，子异和为$1$。

两次修改后，$1$号点点权为$0$，$3$号点点权为$1$。

第二次询问，$1$到$3$的路径经过的点权集合为$\{0,1\}$，子异和为$0+1+1=2$。

本题共有$10$个测试点，每个测试点$10$分，总分为$100$分。

| 测试点编号 | $n$的范围 | $m$的范围 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1-2$ | $1\le n\le 1000$ | $1\le m\le 1000$ | 无 |
| $3-5$ | $1\le n\le 200000$ | $1\le m\le 200000$ | 每条边连接的两个节点编号均相邻 |
| $6-10$ | $1\le n\le 200000$ | $1\le m\le 200000$ | 无 |

对于$100\%$的数据：

输入的数均为不大于$10^9+7$的非负整数，$1\le a,b\le n$。


---

---
title: "纯粹的弹幕地狱"
layout: "post"
diff: 省选/NOI-
pid: P5130
tag: []
---
# 纯粹的弹幕地狱
## 题目背景

除了丰富的迷宫系统之外,TODR的弹幕系统也富有趣味,不仅有多种华丽的特效,还有如咲夜的连发小刀,` The World `等特殊的攻击.  

不仅自机如此,敌人也有自己独特的攻击方式,比如下图就是绵月丰姬的"净化之风"攻击模式    

![](https://cdn.luogu.com.cn/upload/pic/42759.png)  

## 题目描述

通过了不可思议的迷宫后,你一路顺利地过关斩将来到了最后一层,却遭遇了前所未有的强敌——纯狐  

所幸的是,纯狐的弹幕不像绀珠转的强度一样大,房间的地形也比较特殊,可以为你所用.     

形式化的来说,每一回合你和纯狐的行动模式如下:  

1. 你可以将房间当成一张正方形网格图,左下角坐标为$(0,0)$,右上角的坐标为$(n,n)$,房间的有效位置为这$(n+1)*(n+1)$个格点,在一回合开始的时候,你会被随机传送到房间的任意一个有效位置  

2. 之后,纯狐会随机出现在房间中的某个有效位置,当然,她不会和你出现在同一位置  

3. 纯狐会发射纯粹的自机狙,也就是向你的方向发射一片弹幕,如果这片弹幕在飞行过程中经过了某个不是纯狐和自机所在的格点,则格点上的弹幕结界会被触发,将其传送到亚空间,如果这片弹幕顺利到达你所在的格点,那么你会受到一些伤害  

4. 由于时间狂暴,纯狐在第$t$回合的弹幕伤害可以计算为$at^{2}+bt+c$  

5. 回合结束,开始下一回合   

经过粗略估计,你认为和纯狐的弹幕战会持续$k$回合,那么,为了稳妥起见,你想要算出自机受到的总期望伤害  

答案可能很大也可能丢精度,所以对$19260817$取模就可以了
## 输入格式

一行五个整数$n,a,b,c,k$,意义与题目描述保持一致
## 输出格式

一行一个整数,表示期望受到总伤害的值
## 样例

### 样例输入 #1
```
1 1 2 1 1
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
1 1 2 1 5
```
### 样例输出 #2
```
9630476
```
## 提示

样例$1$解释:  

手画一个网格图,不难发现纯狐能打到你的情况有$12$种(先放自机再放纯狐即可得到)  

所以第一发弹幕的伤害为$1*1*1+2*1+1=4$,期望伤害为$4*\frac{12}{16}=3$  

只有一回合,所以答案为$3$       

数据范围:  

![](https://cdn.luogu.com.cn/upload/pic/42785.png)  




---

---
title: "sequence"
layout: "post"
diff: 省选/NOI-
pid: P5136
tag: []
---
# sequence
## 题目背景

Wolfycz很喜欢数列（雾
## 题目描述

Wolfycz非常喜欢研究数列，同时他也喜欢研究黄金分割率，有一天Wolfycz写下了一个数列，他令$A_i=\lceil(\dfrac{\sqrt{5}+1}{2})^i\rceil$，但是Wolfycz并不知道$A_n$的值，所以希望你来帮帮他

注：请注意常数因子对程序运行效率的影响
## 输入格式

第一行读入$T$，表示有$T$组数据

之后每一行一个整数$n$
## 输出格式

输出共$T$行，每行一个整数，表示$\lceil(\dfrac{\sqrt{5}+1}{2})^n\rceil$的值，答案对998244353取模
## 样例

### 样例输入 #1
```
5
1
9
20
50
100
```
### 样例输出 #1
```
2
77
15127
192911239
996781931
```
## 提示

对于$5\%$的数据，$n\leqslant 20$

对于$40\%$的数据，$T\leqslant 5×10^4$

对于$100\%$的数据，$T\leqslant 10^5,n\leqslant 10^{18}$


---

---
title: "polynomial"
layout: "post"
diff: 省选/NOI-
pid: P5137
tag: []
---
# polynomial
## 题目背景

Wolfycz 很喜欢多项式（雾
## 题目描述

Wolfycz 喜欢研究多项式，尤其喜欢研究 $(a+b)^n$ 这样简单的问题，我们知道 $(a+b)^n=\sum\limits_{i=0}^n\binom{n}{i}a^ib^{n-i}$，但是 Wolfycz 对这样的式子并不满足，于是他把所有的系数全部改成了 $1$，即 $\sum\limits_{i=0}^na^ib^{n-i}$，但是 Wolfycz 发现自己太菜了，不会求答案，于是希望你来帮帮他。

UPD：请注意常数因子对程序运行效率的影响。
## 输入格式

第一行读入 $T$，表示有 $T$ 组数据。

接下来每一行读入四个整数 $n,a,b,p$。
## 输出格式

共 $T$ 行，每行一个整数，表示 $(\sum\limits_{i=0}^na^ib^{n-i})\bmod p$ 后的值。
## 样例

### 样例输入 #1
```
5
12 78 35 317
35 57 19 193
94 31 75 571
64 80 14 857
74 16 42 751

```
### 样例输出 #1
```
254
24
283
796
407
```
## 提示

对于$30\%$的数据，$T\leqslant 100,n,a,b,p\leqslant 10^5$

对于$100\%$的数据，$T\leqslant 10^5,n,a,b,p\leqslant 10^{18}$

UPD：不保证$p$为质数！！！


---

---
title: "xtq的棋盘"
layout: "post"
diff: 省选/NOI-
pid: P5165
tag: []
---
# xtq的棋盘
## 题目背景

自从二年级起，xtq就热爱棋类游戏。
## 题目描述

xtq有一个$1$行，$n+1$列的棋盘，从左到右编号为$0$到$n$。初始时刻，在$m$位置有一颗棋子。

xtq会在接下来的时间里随机操作。具体地说，如果某一秒棋子不位于$n$，那么他将有$prb$的概率将棋子向左移动一格，$1-prb$的概率向右移动一格；否则，他必然将棋子向左移动一格。

现在xtq想问你，期望多少秒之后棋子能够到达$0$。由于答案可能很大，并且为了避免不必要的精度误差，你只需要给出答案对于$10^9+7$取模的结果即可（可以证明，答案必然是一个有理数）。
## 输入格式

一行四个正整数$n,m,p,q$。

其中，$p,q$表示$prb = \frac{p}{q}$。
## 输出格式

一行，一个正整数，表示期望移动次数对$10^9+7$取模的结果。
## 样例

### 样例输入 #1
```
3 1 1 3
```
### 样例输出 #1
```
13
```
## 提示

对于$20\%$的数据，$n\le 4, 1\le p\le q\le 4$而且保证答案在取模前是一个整数。

对于$40\%$的数据，$n\le 300$。

对于$70\%$的数据，$n\le 1000000$。

对于$100\%$的数据，$1\le m\le n\le 10^9, 1\le p\le q\le 10^9$并且$p,q$互质。

此外，在全部的数据点中，有$30\%$的数据是满足$prb = \frac{1}{2}$的。

有理数对质数$p$取模定义如下：

设$\frac{a}{b}$对$p$取模的结果为$x$，那么需要满足$0\le x<p$且$a \equiv bx (mod p)$。

保证对于$100\%$的数据，一定存在满足要求的$x$。


---

---
title: "xtq的口令"
layout: "post"
diff: 省选/NOI-
pid: P5166
tag: []
---
# xtq的口令
## 题目背景

三年级时，xtq就展现出高超的身体素质，以至于体育老师允许他不用参加同学们的体育锻炼，而是可以自由活动。

xtq现在正在观察同学们跑步。
## 题目描述

$n$个同学在排队跑步。

体育老师发了一条指令，要求这$n$名同学加快跑步速度。然而，由于风太大，只有部分同学听到并执行了老师的指令。同时，没有听到指令的同学如果观察到其他的同学执行了老师的指令，他们也会执行老师的指令。

现在我们一般化这个情况。我们将位于队首的同学编号为$1$，将接下来的同学以此类推，最后位于队尾的同学编号为$n$。

经过观察，xtq给出了每位同学的若干位观察对象，这意味着当这位同学看到他的任何一个观察对象加快跑步速度（执行指令）时，他也会加快跑步速度（执行指令）。保证对于任何第i位同学，他的所有观察对象的编号都小于自己（一个同学只会观察排在自己前面同学中的一部分）。

现在有$q$条询问或修改，

询问：每次询问给出$L,R$，询问内容如下：如果编号在$[L,R]$区间范围内的同学听到了老师的指令，至少还需要几位同学听到了老师的指令，才能使得所有同学最后都能加快跑步速度。 格式为$1$ $L$ $R$。

修改：每次修改给出$L,R$以及$x$，代表编号在$[L,R]$的同学添加第$x$位同学为自己的观察对象。保证$x<L\le R$。不保证在修改以前$x$同学不是$[L,R]$范围内的任何一位同学的观察对象。但是，当一组$2$ $L$ $R$ $x$的修改完成后，$x$同学一定被$[L,R]$区间内的所有同学观察。格式$2$ $L$ $R$ $x$。
## 输入格式

第一行两个整数$n,q$。

接下来n行，每行第一个整数$a_i$，代表第$i$位同学被共计$a_i$位同学观察。接下来$a_i$个整数，代表观察第$i$位同学的编号。若$a_i=0$，代表没有同学观察这位同学。由于一个同学只会被自己后面的同学观察，所以输入的编号第一大于这位同学自己的编号

###### 请注意，输入的编号是 观察第$i$位同学 的同学编号，而不是 被第$i$位同学观察 的同学编号。

接下来$q$行，每行一个询问或修改，格式见题目描述
## 输出格式

对于每个询问操作，输出至少还需要几位同学知道指令，才能使最终每位同学都接执行了老师的指令。
## 样例

### 样例输入 #1
```
4 4
1 3
1 3
1 4
0
1 2 3
1 1 1
2 2 3 1
1 1 1
```
### 样例输出 #1
```
1
1
0
```
## 提示

【样例解释】

样例中，$1$同学被$3$同学观察，$2$同学被$3$号同学观察，$3$同学被$4$同学观察。

对于第一个询问$1$ $2$ $3$：这意味着$2,3$两位同学听到了老师的指令。因为$3$号同学被$4$号同学观察，所以当$3$同学加快跑步速度后，$4$同学也会加快跑步速度。所以需要告诉$1$号同学指令是什么，才能使所有同学收到指令。

【数据范围】

测试数据范围及特点如下表：

|编号|n|m|特殊性质|
| ------ | ------ | ------ | ------ |
|1|10|10|有|
|2|10|10|无|
|3|500|500|有|
|4|5000|5000|无|
|5|5000|5000|无|
|6|50000|50000|有|
|7|50000|50000|无|
|8|300000|300000|有|
|9|300000|300000|无|
|10|300000|300000|无|

有特殊性质是指：$q$个操作中，修改操作不超过$100$次。

对于$100\%$的数据，$n,q\le 300000$，$a_i$之和$\le 10000000$。

由于本题有巨大的输入/输出，请不要使用cin/cout


---

---
title: "xtq 的神笔"
layout: "post"
diff: 省选/NOI-
pid: P5167
tag: ['O2优化']
---
# xtq 的神笔
## 题目背景

xtq 在小学四年级的时候得到了一套神奇的画笔。为了测试神笔的威力（以及展现自己过人的艺术天赋），他决定先为美术老师临摹几幅画。
## 题目描述

每幅画的形态可以抽象为排成一列的 $n$ 个格子，其中第 $i$ 个格子具有一个权值 $a_i$。

xtq 有足够多不同颜色的画笔，每当他使用一根笔，他可以在格子上画下至少长度为 $k$ 的连续一段，然后再换另一根笔从下一个格子继续画，其中 $k<n$。

美术老师为了考验 xtq 的绘画功力，为他设置了一些挑战。

他可以从 $1$ 到 $k$ 的任意一个格子开始画到编号为 $n$ 的格子，其中从第 $i$ 个格子开始会获得 $b_i$ 的得分。

假设 xtq 使用同一根画笔，从编号为 $i$ 的格子连续地画到编号为 $j$ 的格子，他就会获得（$a_i \mathbin{\mathrm{or}} a_{i+1} \mathbin{\mathrm{or}} a_{i+2} \mathbin{\mathrm{or}} \cdots \mathbin{\mathrm{or}} a_j) + (a_i \mathbin{\mathrm{and}} a_{i+1} \mathbin{\mathrm{and}} a_{i+2} \mathbin{\mathrm{and}} \cdots \mathbin{\mathrm{and}} a_j) + \gcd(a_i, a_{i+1}, a_{i+2}, \ldots, a_j)$ 的分数，其中 $\gcd$ 代表最大公约数。

现在，xtq 希望找到一种安排画笔使用的方案，使得对于每一幅需要临摹的画，他总共获得的分数尽量多。
## 输入格式

第一行，一个正整数 $T$，表示画的数量。

对于每一幅画：

第一行，两个正整数 $n, k$。

第二行，$n$ 个正整数 $a_1, a_2, a_3, \ldots , a_n$。

第三行，$k$ 个整数 $b_1, b_2, b_3, \ldots , b_k$。
## 输出格式

对于每一幅画，输出一个整数，代表 xtq 完成这幅画最多能获得的分数。
## 样例

### 样例输入 #1
```
1
6 2
3 1 4 5 6 2
6 -2

```
### 样例输出 #1
```
31

```
## 提示

样例解释：

xtq 可以从 $1$ 开始，获得 $6$ 分初始得分；第一段画 $[1,2]$，获得 $5$ 分；第二段画 $[3,4]$，获得 $10$ 分；第三段画 $[5,6]$，获得 $10$ 分。共 $31$ 分。

对于 $20\%$ 的数据，$n\le 10$。  
对于 $40\%$ 的数据，$n\le 3000$。  
对于 $70\%$ 的数据，$n\le 30000$。  
对于 $100\%$ 的数据，$1\le k<n\le 3 \times {10}^5$，$T\le 10$，$1\le a_i\le 2^{30}$，$-2^{30}\le b_i\le 2^{30}$。

数据有梯度，应该不太卡常。


---

---
title: "xtq的异或和"
layout: "post"
diff: 省选/NOI-
pid: P5169
tag: []
---
# xtq的异或和
## 题目背景

xtq在六年级的时候开始大量研究离散数学。这一天，他正在对着一张密密麻麻的图思索。
## 题目描述

xtq有一张$n$个点，$m$条边的无向连通图。第$i$条边连接$s_i,t_i$，权值为$w_i$。不保证无重边或自环。

xtq认为，如果存在一条从$u$出发，到$v$结束的路径，使得所有**被这条路径恰经过奇数次的边**的权值的异或和为$x$，那么点对$(u,v)$关于$x$是巧妙的。

现在，xtq问了你$q$个问题，每次询问有多少个不同的点对$(u,v)$关于$x$是巧妙的。注意$u$可以等于$v$，且如果$u \neq v$那么$(u,v)$与$(v,u)$是不同的。


## 输入格式

第一行，三个正整数$n,m,q$

接下来$m$行，每行三个整数$s_i,t_i,w_i$

接下来$q$行，每行一个整数$x$，表示一次询问。
## 输出格式

$q$行，每行回答一次询问，输出对998244353取模后的结果。
## 样例

### 样例输入 #1
```
3 3 3
1 2 0
2 3 1
3 1 2
0
1
2
```
### 样例输出 #1
```
5
4
4
```
### 样例输入 #2
```
4 3 2
1 2 1
2 3 6
2 4 7
6
7
```
### 样例输出 #2
```
4
4
```
## 提示

##样例解释1

关于$0$巧妙的点对：

$(1,1): 1 \Rightarrow 2 \Rightarrow 1$，$(2,2),(3,3)$类似；$(1,2): 1 \Rightarrow 2$，$(2,1)$类似

关于$1$巧妙的点对：

$(2,3):2 \Rightarrow 3$，$(3,2)$类似；$(1,3):1 \Rightarrow 2 \Rightarrow 3$，$(3,1)$类似

关于$2$巧妙的点对：与$1$类似

##数据范围

|  测试点编号|$n$  |$m$  |      $\, w_i,x,q-1$  |       特殊限制  |
| ----------- | ----------- | ----------- | --------------- | ----------- |
|1  |$\le 5$  |$\le 10$  |$< 4$  | 无  |
|2  |$\le 10$  |$\le 50$  |$< 8$  | 无  |
|3  |$\le 100$  |$= n-1$  |$< 128$  | 是一棵树  |
|4  |$\le 100$  |$\le 500$  |$< 128$  | 无  |
|5  |$\le 1000$  |$= n-1$  |$< 1024$  | 是一棵树  |
|6  |$\le 1000$  |$\le 5000$  |$< 1024$  | 无  |
|7  |$\le 100000$  |$\le 300000$  |$< 1024$  | 无  |
|8  |$\le 100000$  |$\le 300000$  |$< 1024$  | 无  |
|9  |$\le 100000$  |$= n-1$  |$< 262144$  | 是一棵树  |
|10  |$\le 100000$  |$= n-1$  |$< 262144$  | 是一棵树  |
|11  |$\le 100000$  |$= n-1$  |$< 262144$  | 是一棵树  |
|12  |$\le 100000$  |$= n-1$  |$< 262144$  | 是一棵树  |
|13  |$\le 100000$  |$\le n+11$  |$< 262144$  | 无  |
|14  |$\le 100000$  |$\le n+11$  |$< 262144$  | 无  |
|15  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |
|16  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |
|17  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |
|18  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |
|19  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |
|20  |$\le 100000$  |$\le 300000$  |$< 262144$  | 无  |

对于100%的数据，$1\le n\le 10^5,n-1\le m\le 3*10^5,0\le w_i,x< 262144,0\le q\le 262144$



---

---
title: "Earthquake"
layout: "post"
diff: 省选/NOI-
pid: P5171
tag: []
---
# Earthquake
## 题目描述

给定 $a,\,b,\,c$ ，求满足方程 $ax+by \leqslant c$ 的非负整数解个数。
## 输入格式

输入三个整数 $a,\,b,\,c$ 。
## 输出格式

输出一个整数表示答案。
## 样例

### 样例输入 #1
```
3 4 13
```
### 样例输出 #1
```
12
```
## 提示

**样例解释：**

若以 $(x,\,y)$ 表示一组合法解，样例的 $12$ 组合法解如下：

$(0,\,0)$，$(0,\,1)$，$(0,\,2)$，$(0,\,3)$，$(1,\,0)$，$(1,\,1)$，$(1,\,2)$，$(2,\,0)$，$(2,\,1)$，$(3,\,0)$，$(3,\,1)$，$(4,\,0)$ 。

**数据规模：**

||||
|:-:|:-:|:-:|
|测试点编号|$a,\,b$|$c$|
|$1 \sim 5$|$\leqslant 10$|$\leqslant 10$|
|$6 \sim 10$|$\leqslant 10^5$|$\leqslant 10^9$|
|$11 \sim 25$|$\leqslant 10^9$|$\leqslant 10^{18}$|

对于所有数据，$1 \leqslant a,\,b \leqslant 10^9,\ 0 \leqslant c \leqslant \min(a,\,b) \times 10^9$ 。


---

---
title: "传球"
layout: "post"
diff: 省选/NOI-
pid: P5173
tag: []
---
# 传球
## 题目背景

临近中考，pG的班主任决定上一节体育课，放松一下。

题解：https://blog.csdn.net/kkkksc03/article/details/85008120
## 题目描述

老师带着 pG 的同学们一起做传球游戏。

游戏规则是这样的： $n$ 个同学站成一个圆圈，其中的一个同学手里拿着一个球，当老师吹哨子时开始传球，每个同学可以把球传给自己左右的两个同学中的一个（左右任意），当老师再次吹哨子时，传球停止，此时，拿着球没有传出去的那个同学就是败者，要给大家表演一个节目。

pG 提出一个有趣的问题：有多少种不同的传球方法可以使得从 pG 手里开始传的球，传了 $m$ 次以后，又回到 pG 手里。两种传球方法被视作不同的方法，当且仅当这两种方法中，接到球的同学按接球顺序组成的序列是不同的。比如有三个同学 $1$ 号、 $2$ 号、 $3$ 号，并假设 pG 为 $1$ 号，球传了 $3$ 次回到pG手里的方式有 $1 \to 2 \to 3 \to 1$ 和 $1 \to 3 \to 2 \to 1$ ，共$ 2$ 种。
## 输入格式

一行，有两个用空格隔开的整数 $n,m$
## 输出格式

$1$ 个整数，表示符合题意的方法数。

由于答案可能过大，对 $10^9+7$ 取模。
## 样例

### 样例输入 #1
```
3 3
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
30 30

```
### 样例输出 #2
```
155117522
```
### 样例输入 #3
```
1234 12345678

```
### 样例输出 #3
```
424074635
```
## 提示

对于8%的数据，$n \le 100,m \le 10^4$.

对于100%的数据，$n \le 3500,m \le 10^9$.

**数据有一定梯度。**



---

---
title: "数列"
layout: "post"
diff: 省选/NOI-
pid: P5175
tag: []
---
# 数列
## 题目背景

题解：https://blog.csdn.net/kkkksc03/article/details/85008130
## 题目描述

一个数列 $a_n $，已知 $a_1$ 及 $a_2$ 两项。

数列 $a_n$ 满足递推式 $a_n=x \times a_{n-1}+ y \times a_{n-2}(n≥3).$

求 $\sum_{i=1}^na_i^2$

由于答案可能过大，对 $10^9+7$ 取模。
## 输入格式

第一行一个整数 $T$，即数据组数。

下面 $T$ 行，每行 $5$ 个整数，$n,a_1,a_2,x,y$，含义如上。
## 输出格式

共 $T$ 行，每行一个整数，即为每组数据的答案。
## 样例

### 样例输入 #1
```
3
5 1 1 1 1
4 3 4 3 2
461564597527246 987489553 321654648 164165256 315648984
```
### 样例输出 #1
```
40
4193
480929868
```
## 提示

样例解释：

对于第一组样例，可知数列为 $1,1,2,3,5$，则答案是 $1^2+1^2+2^2+3^2+5^2=40$。

对于第二组样例，可知数列为 $3,4,18,62$，则答案是 $3^2+4^2+18^2+62^2=4193$。

~~第三组样例不予解释。~~

对于前 $20\%$ 的数据，保证 $x=y=1$。

对于 $100\%$ 的数据，$T=30000,1\le n \le 10^{18},1\le a_1,a_2 ,x,y \le 10^9$。


---

---
title: "Fraction"
layout: "post"
diff: 省选/NOI-
pid: P5179
tag: []
---
# Fraction
## 题目描述

给你四个正整数 $a,\,b,\,c,\,d$ ，求一个最简分数 $\frac{p}{q}$ 满足 $\frac{a}{b} < \frac{p}{q} < \frac{c}{d}$。

若有多组解，输出 $q$ 最小的一组，若仍有多组解，输出 $p$ 最小的一组。
## 输入格式

本题有多组数据，有若干行，每行四个正整数，为每组数据的 $a,\,b,\,c,\,d$。
## 输出格式

每组数据各输出一行，如果答案是 $\frac{p}{q}$，则以 `p/q` 的格式输出。
## 样例

### 样例输入 #1
```
1 3 1 2
2 1 3 1
2 1 4 1
1000 1001 1001 1002

```
### 样例输出 #1
```
2/5
5/2
3/1
2001/2003
```
## 提示

||||
|:-:|:-:|:-:|
|测试点编号|数据组数|$a,\,b,\,c,\,d$|
|$1 \sim 3$|$\leqslant 100$|$\leqslant 100$|
|$4 \sim 10$|$\leqslant 500$|$\leqslant 10^9$|

数据保证至少存在一个最简分数符合条件。


---

---
title: "[TJOI2012] 炸弹"
layout: "post"
diff: 省选/NOI-
pid: P5193
tag: ['2012', '天津']
---
# [TJOI2012] 炸弹
## 题目描述

在平面上有 $n$ 个炸弹 $[1 \ldots n]$，每个炸弹的爆炸范围是 $|x-x_i|+|y-y_i| \leqslant R$，如果某个炸弹爆炸了，那么它将引燃它范围内的所有炸弹。

求出至少引燃多少炸弹才能使得所有炸弹都爆炸。


## 输入格式

第一行两个整数 $n,r$。

接下来 $n$ 行，每行两个整数 $x_i,y_i$，炸弹的坐标。

## 输出格式

输出一行一个整数 $k$，表示最少引燃的炸弹数。


## 样例

### 样例输入 #1
```
3 2
0 0
0 2
3 2
```
### 样例输出 #1
```
2

```
## 提示

$30\%$ 的数据，$1 \leqslant n \leqslant 1000$；

$100\%$ 的数据，$1 \leqslant n \leqslant 100000 \,,\, 0 \leqslant r \leqslant 10^9 \,,\, 0 \leqslant x_i,y_i \leqslant 10^9$。



---

---
title: "[SHOI2014] 神秘金字塔"
layout: "post"
diff: 省选/NOI-
pid: P5215
tag: ['2014', '各省省选', '上海']
---
# [SHOI2014] 神秘金字塔
## 题目背景

SHOI2014 day2t3
## 题目描述

对神经组织的进化生物学研究将历史追溯到了人类社会形成之初、一个叫做 CCM 的神秘部落。

考古学证据表明，CCM 一度具有高度繁华的文明。然而 CCM 的历史却似乎在一夜之间神秘地消失了。考古学家近日在大西洋底发掘出了一处 CCM 文明遗迹,有希望能够揭开 CCM 古文明失落之谜。

CCM 遗迹的中央是一座巨大的石质建筑,被考古学家称之为金字塔。金字塔有这样四条性质:
1. CCM 金字塔由完全相同的 $1 \times 1 \times 1$ 单位的立方体石块构成；
2. CCM 金字塔由若干层组成，每一层的石块从正上方看都在平面上形成一个联通块。高层的石块都有低层的石块在下方作为支撑，不会有石块悬空；
3. CCM 金字塔的每一层严格都满足左右对称和上下对称，并且所有层的对称轴是重合的，从左右/上下对称轴向两端长度/宽度非严格递减；
4. CCM 金字塔的每一层的最大长度和最大宽度都相等，并且都是偶数（因为 CCM 人认为偶数代表了好运而奇数则会带来不幸）。

然而，不幸的是，遗迹中的金字塔由于年代过于久远，已经残缺不全，难以辨认全貌。为了尽可能地还原 CCM 金字塔的实际情况，考古学家们通过其他证据估计出了 CCM 金字塔所使用的石块个数、金字塔的高度以及每一层的宽度，他们想请你帮忙计算符合上述性质的可能的金字塔个数。
## 输入格式

第一行两个整数 $n,h$，表示 CCM 金字塔的总石块数和 CCM 金字塔的高度。  
从第二行开始的 $h$ 行，每行一个整数 $l$，表示从最底层开始的每一层的最大长度(宽度)，保证非严格递减。
## 输出格式

输出一行一个整数，表示可能的金字塔个数。由于方案数可能数量很大，输出答案为模 $10^9+7$ 之后的结果。
## 样例

### 样例输入 #1
```
36 3
6
4
2
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
44 2
6
4

```
### 样例输出 #2
```
3
```
## 提示

对于 10%的数据，$h=1$。

对于 30%的数据，$n\leq 200,l\leq 10, h\leq 5$。

对于 70%的数据，$n\leq 800,l\leq 20, h\leq8$。

对于 100%的数据，$n\leq 1000, 2\leq l\leq 20, 1\leq h\leq 10$。

![](https://cdn.luogu.com.cn/upload/pic/51009.png)


---

---
title: "无聊的水题 II"
layout: "post"
diff: 省选/NOI-
pid: P5218
tag: []
---
# 无聊的水题 II
## 题目背景

出题人过菜，只会出这种题。
## 题目描述

DLS 是一个喜欢玩游戏的男生。

今天他从朋友那里看到了 $N$ 件武器，其中第 $i$ 件武器的威力值为$i$。

他观察了这 $N$ 件武器许久，打算买下其中若干件武器，但他想用买下的武器的威力值组合出任意威力值，其中每一件武器已经的威力值可以叠加，甚至可以减去。  
例如一个威力值为 $3$ 的武器，可以组合成的威力值为 $\dots,-6,-3,0,3,6,\dots$。

他想找出所有满足以上条件的买下装备的方案，但方案数量实在太多了。你能帮他计算一下吗？    
答案对 $10^9+7$ 取模。
## 输入格式

一行一个整数 $N$。
## 输出格式

一行一个整数表示答案
## 样例

### 样例输入 #1
```
5
```
### 样例输出 #1
```
26
```
### 样例输入 #2
```
16
```
### 样例输出 #2
```
65243
```
## 提示

|数据百分比|限制|
|-|-|
|$10\%$|$N \le 20$|
|$30\%$|$N \le 2000$|
|$60\%$|$N \le 10^7$|
|$100\%$|$N \le 10^{11}$|


---

---
title: "无聊的水题 I"
layout: "post"
diff: 省选/NOI-
pid: P5219
tag: []
---
# 无聊的水题 I
## 题目背景

出题人过菜，只会出这种题，稍微有点卡常。
## 题目描述

DLS 喜欢上树。  
但是他并不想把一道数据结构题出到树上，他喜欢计 Tree。

这一天，他想自己造一棵树，他手头有 $N$ 个树的节点，标号为 $1 \sim N$，他会在它们之间连边，我们定义两颗树不同，当且仅当一对节点在一棵树中有连边，另一棵树中没有连边。  
但他不喜欢一棵太多分叉的树，于是他想让这棵树的节点中最大的度数为 $M$。

DLS 由于不太擅长理科，所以希望你帮他计算有多少棵这样的树。 
答案对 $998244353$ 取模。
## 输入格式

一行两个整数 $N, M$。
## 输出格式

一行一个整数表示答案。
## 样例

### 样例输入 #1
```
3 2
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
7 4
```
### 样例输出 #2
```
2520
```
## 提示

|数据百分比|限制|
|-|-|
|$10\%$|$N,M \le 8$|
|$30\%$|$N,M \le 100$|
|$50\%$|$N,M \le 500$|
|$70\%$|$N,M \le 2000$|
|$100\%$|$2 \le N,M \le 5 \times 10^4$|


---

---
title: "特工的信息流"
layout: "post"
diff: 省选/NOI-
pid: P5220
tag: []
---
# 特工的信息流
## 题目背景

$\text{TYM}$ 是一名特工。  
$\text{TYM}$ 所在的国家正受到侵犯，他被赋予一个任务：于城市之间传递信息。
## 题目描述

$\text{TYM}$ 所在的国家有 $n$ 个城市，编号为 $1,\dots,n$，由 $n - 1$ 条双向道路连接。保证任意两个城市间都有唯一的简单路径。  
以及，每个城市都有一个信息流的流量 $a_i$。

$\text{TYM}$ 一共要执行 $m_0$ 个任务，每个任务给定两个城市 $s,t$，其执行过程如下：  
第一个时刻，他从城市 $s$ 出发，以每个时刻移动到下一个城市的速度，走 $s,t$ 之间的简单路径到 $t$。  
每到达一个城市，他都会把这个城市的信息流 $a_i$ 发送到经过的每个城市。  
我们约定，他到达一个城市的同一时刻也会把这个城市的信息流发送给这个城市。我们定义一个城市的价值为这个城市所接受到的信息流的乘积。

请你求出每个任务中，$s$ 到 $t$ 的简单路径上经过的城市的价值的总和对 $20924$ 取模的结果。

此外，不幸地，由于侵略者同时也在行动，所以在他执行多个任务之间，可能会有某个 $a_i$ 发生改变。

他的任务总数与改变某个 $a_i$ 的次数之和为 $m$。
## 输入格式

第一行，两个整数 $n,m$。  
第二行，$n$ 个整数，第 $i$ 个表示第 $i$ 个城市的信息流流量 $a_i$。  
以下 $n - 1$ 行，每行两个整数 $u,v$，表示 $u,v$ 之间有一条双向道路。  
以下 $m$ 行，每行描述一个任务或是一次修改事件：
  - 形如 `Q s t`，表示 $\text{TYM}$ 从 $s$ 到 $t$ 执行了一次任务。
  - 形如 `C x k`，表示侵略者的行动令 $a_x \rightarrow a_x + k$。
## 输出格式

对于每次任务，输出经过的城市收到的信息流总流量。
## 样例

### 样例输入 #1
```
5 3
1 2 3 4 5
1 2
2 3
3 4
4 5
Q 1 5
C 1 2
Q 1 5
```
### 样例输出 #1
```
325
565
```
## 提示

**数据范围：**

对于 $20\%$ 的数据，$1 \leq n,m \leq 2000$；  
对于额外的 $20\%$ 的数据，满足 $a_i=2$，且没有修改操作；  
对于额外的 $20\%$ 的数据，满足道路从 $i$ 连向 $i+1$；  
对于 $100\%$ 的数据，$1 \leq n,m \leq 10^5,1 \leq a_i \leq 20923$。

**样例解释：**

第一个询问，$1 \cdot 2 \cdot 3 \cdot 4 \cdot 5 + 2 \cdot 3 \cdot 4 \cdot 5 + 3 \cdot 4 \cdot 5 + 4 \cdot 5 + 5 = 325$；  
修改，$a_1 = 1 + 2 = 3$；  
第二个询问，$3 \cdot 2 \cdot 3 \cdot 4 \cdot 5 + 2 \cdot 3 \cdot 4 \cdot 5 + 3 \cdot 4 \cdot 5 + 4 \cdot 5 + 5 = 565$；


---

---
title: "Game"
layout: "post"
diff: 省选/NOI-
pid: P5222
tag: ['O2优化']
---
# Game
## 题目背景

Justin摆弄着他的棋盘和棋...突然，他想到了一个非常好玩的游戏。
## 题目描述

棋盘可以看做是一个$N \times M$的网格，~~由于Justin太健壮了，~~所以他把$T$个格子弄坏了。也就是说，上面没法放棋子。

Justin想到的游戏是这样的：一开始，你可以选择棋盘的第一列的一些没有坏的格子，在上面各放上一枚棋子。然后，你可以执行依次以下操作若干次：

1. 选择一枚棋子，将其向上或者向下移动到**相邻**的一个好的且**没有其他棋子**的格子上。

2. 将所有棋子移动到下一列。若移动到下一列后有**任意一个**棋子落在坏的格子上，则不能执行此操作。

Justin现在给了你$Q$个问题，每一次给你一个$k_i$，询问你最多能在第一列上放多少枚棋子使得经过若干次操作后你能将所有棋子移动到最后一列，且**所有棋子加起来**最多执行$k_i$次1操作。

(感谢巨佬ywwywwyww 发现题目问题，现已修复。)



## 输入格式

第一行四个正整数:$N$,$M$,$T$,$Q$

接下来$T$行每行两个正整数$x_i$,$y_i$表示一个坏了的格子。

接下来$Q$行每行一个正整数$k_i$表示第$i$次Justin的询问。
## 输出格式

输出$Q$行，每行一个非负整数表示每一次询问的答案。
## 样例

### 样例输入 #1
```
3 5 2 3
1 2
2 4
0
1
2

```
### 样例输出 #1
```
1
2
2

```
### 样例输入 #2
```
5 1000 5 10
1 2
2 3
3 4
4 5
5 6
0
1
2
3
4
5
6
7
8
9

```
### 样例输出 #2
```
0
0
0
0
0
0
0
0
0
0

```
## 提示

第一组样例：限制为0时，可以在(3,1)放置一枚棋子，然后一直执行二操作。

限制为1时，可以在(3,1)放置一枚棋子，在(2,1)放置一枚棋子，然后执行两次二操作之后对(2,3)上的棋子执行一次一操作到(1,3)，然后一直执行二操作就好了。

限制为2时，和上面一样。因为如果放置三枚棋子的话是没办法执行操作二的。

第二组样例：发现完全堵死了，所以根本不可能移动到最后一列。

数据范围：

|测试点编号|$N\le$|$M\le$|$T\le$|$Q\le$|
|:-------:|:-------:|:-------:|:-------:|:-------:|
|$1$|$1$|$10^6$|$1$|$10^5$|
|$2-6$|$10$|$100$|$10$|$100$|
|$7-10$|$20$|$100$|$50$|$10^3$|
|$11-14$|$30$|$10^4$|$100$|$10^4$|
|$15-20$|$50$|$10^6$|$10^3$|$10^5$|

$$1 \le x_i \le N \qquad 1\le y_i \le M \qquad 0 \le k_i \le 2^{31}-1$$

此题测试点$11$~$20$的数据随机生成。


---

---
title: "Function"
layout: "post"
diff: 省选/NOI-
pid: P5223
tag: ['O2优化']
---
# Function
## 题目背景

${\rm CYJian}$最近想起了[水の三角](https://www.luogu.org/problemnew/show/P5014)，他觉得太水了，于是想了一个更加有意思的版本。
## 题目描述

给你$N$和$K$，请你求出：

$$\sum_{i=1}^{K}f[N][i] \ (\bmod\ 998244353)$$

其中：

$$f[i][j]=f[i-1][j]+f[i][j-1]+f[i-1][j-1](i>1,j \leq i)$$

$$f[1][1] = 1 \qquad f[i][0] = 0 \qquad f[i][j]=0(j>i)$$
## 输入格式

第一行两个正整数表示$N$，$K$。
## 输出格式

一行，输出上面式子的值。
## 样例

### 样例输入 #1
```
1 1
```
### 样例输出 #1
```
1

```
### 样例输入 #2
```
2 2

```
### 样例输出 #2
```
3

```
### 样例输入 #3
```
3 3

```
### 样例输出 #3
```
11

```
### 样例输入 #4
```
4 3

```
### 样例输出 #4
```
23

```
## 提示

对于$10\%$的数据：$1 \leq N \leq 10^3 \qquad 1 \leq K \leq 10^2$

对于$30\%$的数据：$1 \leq N \leq 10^6 \qquad 1 \leq K \leq 10^2$

对于$50\%$的数据：$1 \leq N \leq 10^{18} \qquad 1 \leq K \leq 10^2$

对于另$20\%$的数据：$1 \leq N \leq 10^6 \qquad 1 \leq K \leq 10^3$

对于$100\%$的数据：$1 \leq N \leq 10^{18} \qquad 1 \leq K \leq 10^3$

保证$K \leq N$

Upd：时限改为了：第$1$~$35$的测试点时限为$600ms$，第$36$~$50$的测试点时限为$400ms$。


---

---
title: "Candies"
layout: "post"
diff: 省选/NOI-
pid: P5224
tag: ['O2优化']
---
# Candies
## 题目背景

JerryC有一大袋糖果，他正以$1\ t/ms$的速度食用着这一袋糖果......
## 题目描述

JerryC的糖果有$N$箱(两两之间不同)。他一开始想挑$M$箱出来，但是觉得吃起来不过瘾，所以又想要多拿一些出来。由于他比较喜欢数字$K$，所以只要拿出来的糖的量$x(x \ge M)$满足：$x \equiv M\ (\bmod\ K)$，JerryC就会得到满足感。

求有多少种方案使得JerryC得到满足感。请输出方案数$\bmod\ 1004535809$的结果。
## 输入格式

一行三个非负整数$N$,$M$,$K$。
## 输出格式

一行一个非负整数，表示方案数$\bmod\ 1004535809$的结果。
## 样例

### 样例输入 #1
```
10 2 3

```
### 样例输出 #1
```
342

```
## 提示

样例解释：

可以拿出来：2箱 5箱 8箱，组合数算一下就是了：

$$\binom{10}{2}+\binom{10}{5}+\binom{10}{8}=342$$

数据范围：

|测试点编号|$N\le$|$K\le$|
|:-------:|:-------:|:-------:|
|$1$|$1$|$1$|
|$2-3$|$10^6$|$10$|
|$4-8$|$10^{12}$|$100$|
|$9-12$|$10^{15}$|$10^3$|
|$12-20$|$10^{18}$|$10^4$|

$$0 \leq M < K$$


---

---
title: "[AHOI2013] 立方体"
layout: "post"
diff: 省选/NOI-
pid: P5229
tag: ['2013', '各省省选', '安徽', 'O2优化']
---
# [AHOI2013] 立方体
## 题目描述

在一个三维空间中有 $N$个立方体，第 $i$ 个立方体占据 $x_{i_1},y_{i_1},z_{i_1}$ —— $x_{i_2}, y_{i_2}, z_{i_2}$的位置。这 $N$ 个立方体可能有相交，也可能重叠。他们构成了一个大的几何图形。现在求这个几何图形的外表面积
## 输入格式

第一行，一个整数 $N$，表示立方体的个数。

第二行至第 $N+1$ 行，每行 $6$ 个用空格隔开的整数，分别表示$x_1$,$y_1$,$z_1$,$x_2$,$y_2$,$z_2$. 
## 输出格式

一行，一个整数，表示外表面积的大小。
## 样例

### 样例输入 #1
```
1
0 0 0 1 1 1
```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
2 
0 1 0 3 2 1
1 0 0 2 3 1
```
### 样例输出 #2
```
22
```
## 提示

所有数据 $\in~[0,200]$。

$x_1~\leq~x_2$

$y_1~\leq~y_2$

$z_1~\leq~z_2$



---

---
title: "[AHOI2013] 好方的蛇"
layout: "post"
diff: 省选/NOI-
pid: P5230
tag: ['2013', '各省省选', '安徽', 'O2优化']
---
# [AHOI2013] 好方的蛇
## 题目描述

有一天，可爱的蛇心花怒放，把自己变成了一个正方形！但是她改变的时候
被induce了导致改变出了些问题.... 
 
按照预设，她应该变成一个 $N*N$ 的全黑正方形，但是这个正方形出现了一些白的格子...现在她的身体不幸出了些小反应，定义一个subsnake是一个至少有两格的全黑矩形。 

![qwq](http://images.cnblogs.com/cnblogs_com/yifusuyi/1229574/o_1(1).jpg)

现在蛇想让你帮忙求一下一共有多少对不相交的subsnake，答案模10007。
## 输入格式

第一行一个整数 $N$,   接下来 $N$ 行，每行一个长度为 $N$ 的字符串，如果是 $B$，那么是黑的，如果是 $W$ 那么是白的。 
## 输出格式

一行一个整数，表示答案
## 样例

### 样例输入 #1
```
3 
BBW
BBW 
BWW 
```
### 样例输出 #1
```
5
```
## 提示

$1~\leq~N~\leq~1000$


---

---
title: "[JSOI2012] 智者的考验"
layout: "post"
diff: 省选/NOI-
pid: P5232
tag: ['2012', '各省省选', '江苏', 'O2优化']
---
# [JSOI2012] 智者的考验
## 题目描述

公元$1371$年，太祖下令在北极阁上大建庙宇，短短几年，鸡笼山上便建成了帝王庙、关公庙、真武庙、功臣庙、蒋王庙、都城隍庙、卞壶庙、忠烈庙、刘越王庙、曹武惠王庙共十座庙宇，统称为“十庙”。 

后来，为了方便人们来鸡笼山进香礼佛，太祖下令疏通了鸡笼山下已淤塞多年的潮沟。于是，便有了“进香河”。 

然而并不是所有人都可以来鸡笼山的，太祖在进香河上修建了一座石桥，中间悬挂了一块高$Rx$宽$Ry$的机关格图（如下图所示）。所有格子都是活动可翻转的，一面是白色，一面是黑色，这里我们用$0$表示白色，用$1$表示黑色。初始情况下，所有格子都是白色面朝前的。有$Rx+Ry$个机关按钮，对应$Rx$行和$Ry$列。一个按钮一旦触发，就会引发对应的一行或一列的格子同时翻转。
 
![](https://cdn.luogu.com.cn/upload/pic/52643.png)

同时，善于识天象的谋臣刘基给出了一种黑白状态，称之为“厄运星”。每一位过往前去鸡笼山的人都需要触发且只触发一个按钮，触发后，如果来访者呈“厄运星”形状，则不允许通过。 

每一天要来鸡笼山的人数$N$是事先就知道的，同时天朝神威浩荡，每一位来者一开始总是有很大概率触发编号为$1$的按钮，我们不妨用数列$A_1$,$A_2$,$\dots$,$A_N$来表示，问题保证了初始时候的$A$数列全为$1$。同时在整个问题中，$A_i$满足$1 \leq A_i \leq Rx+Ry$。太祖很关心那些不允许去鸡笼山的人数。于是他时不时就会询问关于“某一段时间内会有多少人不能通过“厄运星”的考验”。然而那些前来鸡笼山的文人墨客并不愿意如此单一的操作。来访者有可能会突然决定修改自己的触发按钮。更麻烦的情况，结伴而来的连续若干人会突然决定修改触发按钮并且都去触发同一个按钮。 

现在这麻烦的问题交给了你。 
## 输入格式

输入文件第一行有$2$个数字$Rx$和$Ry$表示机关格图的高和宽（如图所示）。之后$Rx$行每一行$Ry$个数字，描述了“厄运星”形状，每一个数字都满足非$0$即$1$。 

之后一行有两个数字，分别为$N$和$M$，表示人数和询问修改的次数。 

之后$M$行，对应$M$次询问或修改。每一行先有一个数字$t$： 

若$t$为$0$：之后有$2$个数字$d$和$x$，表明将$A_d$修改为$x$。
 
若$t$为$1$：之后有$2$个数字$l$和$r$，表明询问第$l$个人到第$r$个人中有多少人触发按钮后会出现“厄运星”形状，从而无法通过。

若$t$为$2$：之后有$3$个数字$l$,$r$和$x$，表明将$A_l$,$A_{l+1}$,$\dots$,$A_{r-1}$,$A_r$都修改为$x$。 
## 输出格式

对于每一次询问(即$t$为$1$的情况)，输出单独一行，一个整数描述了在区间$[l,r]$中满足要求的人数。
## 样例

### 样例输入 #1
```
2 3 
0 0 1 
1 1 0 
7 4 
1 1 7 
0 2 3 
0 3 4	
1 1 7
```
### 样例输出 #1
```
0
3
```
## 提示

对于$40\%$的数据，$N \leq 5000$,$M \leq 10000$。

存在$70\%$的数据，$N \leq 130000$,$M \leq 30000$。

对于$100\%$的数据，$N \leq 1000000$，$M \leq 120000$，$Rx \leq 2$，$Ry \leq 3$。


---

---
title: "[JSOI2012] 爱之项链"
layout: "post"
diff: 省选/NOI-
pid: P5233
tag: ['2012', '各省省选', '江苏', 'O2优化']
---
# [JSOI2012] 爱之项链
## 题目描述

在进香河，流传着这样一段美丽的故事。$zyg$与$kzn$是两个生活在进香河的孩子，一天，他们两人闹矛盾了，于是$zyg$送给了$kzn$一条精美的爱之项链。从此他们幸福生活在一起。

这则故事的真实性到今天已经没有意义了，然而我们关注的是那一条精美的爱之项链。这是一条由$N$个精致的戒指与一块特殊纪念品相连而成的环形，如下图中的爱心符号正是一种特殊纪念品。(据说是$2012$年情人节时$zyg$特意托人订制的)上面的每一枚戒指又是由$M$个带磁性的特殊彩色球状物组成的环形。也许你会认为，这所谓的戒指，更像是一条条小项链。

下图给出了一种可行的方案，其中左边描述的是单一的一枚戒指，右图描述的是项链。

![](https://cdn.luogu.com.cn/upload/pic/52648.png) 

这里，所有带磁性的特殊彩色球状物的颜色只有$R$种，这里我们用$1$到$R$来表示。如果一枚戒指可以通过顺时针或逆时针的旋转后与另外一枚戒指相同，则认为这是两枚相同的戒指。 

对于一条爱之项链，要求满足任何相邻两枚戒指必须是不相同的。同时，特殊纪念品左右两枚戒指也必须是不同的。 

现在给定$N$，$M$和$R$，问究竟有多少种不同的爱之项链。 

注意： 

$1$、特殊纪念品的插入位置不同，也许会得到不同的爱之项链。
 
$2$、这里我们只考虑旋转后是否相同，不考虑翻转操作，这一点不论是对于每一枚戒指，还是对于整条项链，都是这样的。
## 输入格式

一行，三个正整数，分别是$N$，$M$和$R$。
## 输出格式

一行，表示有多少种不同的爱之项链。你只需要将答案模$3214567$。
## 样例

### 样例输入 #1
```
10 5 4
```
### 样例输出 #1
```
1398595
```
## 提示

对于$30\%$的数据，$N \leq 10^3$，$M \leq 3 \times 10^2$，$R \leq 10^2$。

对于$60\%$的数据，$N \leq 3 \times 10^4$，$M \leq 2 \times 10^3$，$R \leq 10^5$。

对于$80\%$的数据，$N \leq 10^7$，$M \leq 10^6$，$R \leq 10^6$。

对于$100\%$的数据，$N \leq 10^{15}$，$M \leq 10^9$，$R \leq 10^6$。


---

---
title: "[JSOI2012] 越狱老虎桥"
layout: "post"
diff: 省选/NOI-
pid: P5234
tag: ['2012', '各省省选', '江苏', 'O2优化']
---
# [JSOI2012] 越狱老虎桥
## 题目背景

这里，是美丽的南京；这里，是秀美的进香河；这里是安逸的老虎桥。 

如果说进香河的美，美在其秀美的风光，倒不如说是美在了那惬意的南京古典小巷式生活。如果说进香河的迷人，在其淳朴的民风，倒不如说是那被历史掩埋了的秘密吸引着人们好奇的心。 

也许很多人都还记得，老虎桥监狱，北洋时期江南最大的监狱，在近一个世纪中，面对满清、北洋、民国、新中国几朝兴衰，名称屡次更替，沧桑尽显其中。 

现在的人们，恐怕很难相信，到底有多少惊心动魄的事情曾经就在这里上演。 
## 题目描述

那是$1948$年的冬天，南京地下组织的一支小分队决定偷袭老虎桥监狱，救出被困的数百名人员。那时的老虎桥监狱，被$N$层电网围了起来，由内而外，依次编号为$1$,$2$,$\dots$,$N$。第$1$层电网接有高压电。有$M$条高压线，连接了所有电网，其中第$i$条高压线连接了第$a_i$和$b_i$层电网，如果要破坏第$i$条高压线，需要至少动用$T_i$位特工。面对这么多层电网，偷袭小分队犯愁了。至少需要破坏一层电网，否则是无法偷袭成功的。
 
然而，狡猾的间谍却知道了这件事情，为了破坏偷袭计划，敌人秘密地又增加了一条高压线，不让偷袭小分队的成员发现。 

为了能够偷袭成功，不论新增的这一条秘密高压线是连接哪两层电网的，小分队都必须要破坏且仅破坏一条高压线，使得至少有一层电网不通电。注意，对于新增的高压线，我们并不知道需要多少位特工才能成功破坏。现在的问题是，偷袭小分队至少需要多少名特工呢？
 
决战就在今夜！
## 输入格式

第一行有$2$个整数，$N$和$M$，分别表示电网层数和高压线个数。 
之后$M$行，每行$3$个整数，分别是$a_i$,$b_i$和$T_i$。
## 输出格式

输出只有一行，包含一个整数，表示最少需要动用的特工人数。 
如果计划必然失败，则输出$-1$。
## 样例

### 样例输入 #1
```
3 2
1 2 1
2 3 2
```
### 样例输出 #1
```
-1
```
### 样例输入 #2
```
4 3
1 2 1
1 3 2
1 4 3
```
### 样例输出 #2
```
3
```
## 提示

对于$30\%$的数据，$N \leq 200$，$M \leq 250$。

对于$70\%$的数据，$N \leq 50000$，$M \leq 100000$。

对于$100\%$的数据，$N \leq 500000$，$M \leq 1000000$，$T \leq 100000$。

对于第二组样例，新增的高压线只有可能出现在$2$和$3$，$2$和$4$或$3$和$4$之间。

如果出现在了$2$和$3$之间，则只能破坏$1$和$4$之间的高压线；如果出现在$2$和$4$之间，则只能破坏$1$和$3$之间的高压线；如果出现在$3$和$4$之间，则只能破坏$1$和$2$之间的高压线。

所以，至少需要出动$3$位特工，才能应付所有可能情况。


---

---
title: "Derivation"
layout: "post"
diff: 省选/NOI-
pid: P5240
tag: ['O2优化', '洛谷月赛']
---
# Derivation
## 题目描述

小 R 学会微积分中求导这一概念后，他的数学老师要求他开始做一部分导数的练习题加深自己的理解。

但颖悟绝伦的小 R 对繁复的练习题并不感兴趣。他希望你帮他设计一个程序，计算一个给定函数 $f(x)$ 的导数。

如果你对导数这一概念并不熟悉，请参阅【说明】中的内容。
## 输入格式

第一行一个正整数 $T$，表示小 R 要完成的练习题数量，亦即测试数据的组数。

每组测试数据的第一行是一个非空字符串，描述了输入的函数 $f(x)$。设 $p=998244353$。

字符串中可能包含的元素有：

1. 系数为 $1$ 的单项式，包括 $x^1,x^2,x^0$ 等，我们保证指数为非负整数（为 $1$ 时不省略）且不超过 $p-1$。所有幂号用 `^` 代替。
2. 常数，如 $0,19260817$ 等；我们保证一切常数是非负整数且不超过 $p-1$。
3. 复合函数。将以上两种函数组合的方式可以为加乘幂，括号等。数学中会省略乘号和括号，但我们保证任意情况下都不省略（也不会无意义冗余，即不存在 `((x)),(3)+(4)`）；保证任何指数都是常数，即不存在 $x^{g(x)}$ 的情况。

经过以上规定，我们发现 $f(x)$ 求导后一定是一个多项式函数。如果你对数据的输入形式仍有不确定，可以观察附加样例文件。

由于输出这样的函数存在技术困难，为确认你的输出是正确的，测试数据的第二行为两个整数，值在 $[0,p)$ 之间。你需要输出两个整数，表示这些整数代入导函数后的值模 $p$ 的结果。

注意：本题中认为 $0^0=1$。
## 输出格式

输出 $T$ 行，每行两个整数，已在【输入格式】中说明它们的意义。
## 样例

### 样例输入 #1
```
4
x
0 1
9
0 1
x*(x^(1*8))
0 1
(3*(x^3))+((2*(x^2))+(12*x))
0 1

```
### 样例输出 #1
```
1 1
0 0
0 9
12 25

```
## 提示

规定字符串长度不超过 $10^4$，字符串总长不超过 $5 \times 10^5$。

| 子任务编号 | 特殊性质                                                  | 分值 |
| :----------: | :---------------------------------------------------------: | :----: |
| 1          | $T \le 10^4$，字符串长度不超过 $20$，出现的常数不超过 $9$ | 20   |
| 2          | $T \le 100$，输入是一个化简后的多项式                     | 15   |
| 3          | $T \le 100$，出现的常数不超过 $9$                         | 15   |
| 4          | $T \le 100$，不存在多项式求幂                             | 20   |
| 5          | $T \le 100$                                               | 30   |

我们提供了 5 个附加样例文件，分别满足 5 个子任务的限制。

链接: https://pan.baidu.com/s/1dVSy8tU3pqGoq1-7CFYtBw 提取码: ya2u

**我们只保证以下定义在本题中适用。**

$f(x)$ 的导数是一个函数 $f'(x)$，满足：

$$ \displaystyle \lim_{h \to 0} f'(x)=\dfrac{f(x+h)-f(x)}{h} $$

我们称 $\displaystyle \lim_{x \to a}g(x)=L$ 当且仅当对于任何实数 $\epsilon > 0$ 我们都可以找到一个实数 $\delta > 0$ 使得 $\lvert g(x)-L\rvert < \epsilon$ 若 $0 < \lvert x - a \rvert < \delta$。

你可能用到以下的求导公式：

1. $f(x)=C,f'(x)=0$，其中 $C$ 是一常数。
2. $f(x)=x^n,f'(x)=nx^{n-1}$，其中 $n$ 为非 $0$ 常数。
3. $(f(x)+g(x))'=f'(x)+g'(x)$
4. $(f(x)g(x))'=f'(x)g(x)+f(x)g'(x)$
5. $(f(g(x)))'=f'(g(x))g'(x)$


---

---
title: "序列"
layout: "post"
diff: 省选/NOI-
pid: P5241
tag: ['洛谷月赛']
---
# 序列
## 题目描述

构建一个N个点的有向图G，初始没有任何边。接下来构建一个长度为E的边的序列A，序列中每条边都是满足1≤s,t≤N且s≠t的有向边(s,t)，且序列中的边互不相同。按照顺序把这些边加入到G中，每次加入后计算当前图的强连通分量个数并记录下来，得到一个新的长度为E的正整数序列B。如果两个边的序列得到的B相同则称它们本质相同。

请问有多少种本质不同的边的序列，你只要求出答案对$10^9+7$取模后的结果。
## 输入格式

输入一行，一个正整数N表示有向图G的点数。
## 输出格式

输出一行N×(N-1)个由空格隔开的整数，第i个数表示当E=i时的答案。
## 样例

### 样例输入 #1
```
3

```
### 样例输出 #1
```
1 2 4 7 7 7

```
## 提示

Subtask 1 (5pts)：N≤5。

Subtask 2 (10pts)：N≤10。

Subtask 3 (15pts)：N≤20。

Subtask 4 (15pts)：N≤30。

Subtask 5 (15pts)：N≤50。

Subtask 6 (20pts)：N≤100。

Subtask 7 (20pts)：无特殊限制

对于全部数据：1≤N≤400。

前6个子任务限时1s，第7个3.5s。

## 代码长度限制：10kb 超过这个限制赛后将会被标记为无效。


---

---
title: "【模板】多项式快速幂"
layout: "post"
diff: 省选/NOI-
pid: P5245
tag: ['O2优化']
---
# 【模板】多项式快速幂
## 题目背景

[加强版传送门](https://www.luogu.com.cn/problem/P5273)

模板题，无背景
## 题目描述

给定一个 $n-1$ 次多项式 $A(x)$，求一个在 $\bmod\ x^n$ 意义下的多项式 $B(x)$，使得 $B(x) \equiv (A(x))^k \ (\bmod\ x^n)$。

多项式的系数在 $\bmod\ 998244353$ 的意义下进行运算。
## 输入格式

第一行两个整数 $n,k$。

接下来 $n$ 个整数，依次表示 $A(x)$ 的系数 $a_0, a_1,...,a_{n-1}$。
## 输出格式

输出 $n$ 个整数，依次表示 $B(x)$ 的前 $n$ 项系数 $b_0, b_1,...,b_{n-1}$ 在模 $998244353$ 意义下的最小自然数值。
## 样例

### 样例输入 #1
```
9 18948465
1 2 3 4 5 6 7 8 9
```
### 样例输出 #1
```
1 37896930 597086012 720637306 161940419 360472177 560327751 446560856 524295016
```
### 样例输入 #2
```
4 1
1 1 0 0

```
### 样例输出 #2
```
1 1 0 0
```
### 样例输入 #3
```
4 2
1 1 0 0

```
### 样例输出 #3
```
1 2 1 0

```
### 样例输入 #4
```
4 3
1 1 0 0
```
### 样例输出 #4
```
1 3 3 1
```
## 提示

对于 $100\%$ 的数据，$1 < n \leq 10^5$，$0 < k \leq 10^{10^5}$，$a_i \in [0,998244352]$，$a_0=1$。


---

---
title: "[JSOI2013] 密码"
layout: "post"
diff: 省选/NOI-
pid: P5257
tag: ['2013', 'O2优化']
---
# [JSOI2013] 密码
## 题目背景

Will 有一个神秘盒，传说只要有人能解开神秘盒上的密码，就可以预知未来（比如知道这道题的标程是怎样的），你愿意来尝试一下么？
## 题目描述

对于一个 $m$ 位的十进制整数 $N~=~(\overline{n_1 n_2 n_3 \dots n_m})_{10}$，定义 $g(N)~=~\sum_{i = 1}^{m} n_i$。

定义集合 $S_N~=~\{x~|~x~>~0,~g(x)~\leq~N,x~\text{的十进制表示中任意位不为} 0\}$。

给定 $n$，求

$$f(n)~=~\sum_{x \in S_n} \sum_{y \in S_n \land x < y} x~\times~y$$

答案对 $10^6+3$ 取模。
## 输入格式

一行一个正整数 $n$。
## 输出格式

一行一个整数代表答案对 $10^6 + 3$ 取模的结果。
## 样例

### 样例输入 #1
```
2
```
### 样例输出 #1
```
35
```
## 提示

#### 样例输入输出 1 解释

$S_n={1, 2, 11}$，故 $f(N)~=~1 \times 2+1 \times 11+2 \times 11~=~35$。

---

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $3~\leq~n~\leq~10^{18}$。


---

---
title: "[JSOI2013] 游戏中的学问"
layout: "post"
diff: 省选/NOI-
pid: P5259
tag: ['2013', '各省省选', '江苏', 'O2优化']
---
# [JSOI2013] 游戏中的学问
## 题目描述

大家应该都见过很多人手拉手围着篝火跳舞的场景吧？一般情况下，大家手拉手跳舞总是会围成一个大圈，每个人的左手拉着旁边朋友的右手，右手拉着另
一侧朋友的左手。

不过，如果每一个人都随机的拉住两个不同人的手，然后再慢慢散开，事情
就变得有趣多了——此时大家依旧会形成圈，不过却可能会形成多个独立的圈。
当然这里我们依然要求一个人的右手只能拉另一个人的左手，反之亦然。

班里一共有 $N$ 个同学，由 $1$ 到 $N$ 编号。Will想知道，究竟有多少种本质不
同的拉手方案，使得最终大家散开后恰好形成 $k$ 个圈呢？

给定两种方案，若存在一个人和他的一只手，满足在这两种方案中，拉着这
只手的人的编号不同，则这两种方案本质不同。
## 输入格式

输入一行包含三个正整数$N,~k,~P$
## 输出格式

输出文件的包含一行一个整数，表示本质不同的方案数对p的余数。保证p
一定是一个质数。
## 样例

### 样例输入 #1
```
3 1 1000000009 
```
### 样例输出 #1
```
2
```
## 提示

$3~\leq~3k~\leq~N~\leq~3000$

$10^4~\leq~p~\leq~2~\times~10^9$


---

---
title: "[JSOI2013] 数字理论"
layout: "post"
diff: 省选/NOI-
pid: P5261
tag: ['2013', '各省省选', '江苏', 'O2优化']
---
# [JSOI2013] 数字理论
## 题目描述

给定 $4$ 个正整数 $K,~S,~P,~D$，要求在十进制数中，寻找一个最小的 $K$ 位自然数 $x$，满足 $x$ 的各个数位之和为 $S$，并且 $x$ 乘以 $D$ 之后各个数位之和为 $P$。
## 输入格式

输入数据中包含一行四个整数，分别为 $K,~S,~P,~D$。

## 输出格式

输出一行一个整数，表示满足条件的最小自然数 $x$。如果不存在则输出$-1$。
## 样例

### 样例输入 #1
```
2 9 9 5
```
### 样例输出 #1
```
18
```
## 提示

$1~\leq~K~\leq~100,~1~\leq~S,~P~\leq~1000,~1~\leq~D~\leq~9$


---

---
title: "无论怎样神树大人都会删库跑路"
layout: "post"
diff: 省选/NOI-
pid: P5270
tag: ['洛谷月赛']
---
# 无论怎样神树大人都会删库跑路
## 题目背景

众所周知，神J（Joker）每隔几天就会去成都法中假装上课，实际上是去玩指针。神J可以趁别人不注意掏出指针把自己指到任何位置（生物标本柜里大变活人？），或者把两个人的指针交换一下（成都法中版《你的名字》？），或者对着OJ念系统命令使得OJ随机变慢（mcfx：怎么这CPU睿频后反而变慢了）。

神树大人很不满意，因为树必须站在原地，而且神树大人也不会指针。但是神树大人是神，于是他打算把这个宇宙的数据库删了跑路，这样无所事事的神J就只能和神树大人玩牌了。
## 题目描述

现在有个长为$T$的字符串$S$和$n$个小字符串$a_i$。

给定一个长为$m$的数组$R$，数组下标从1开始，初始有一个空字符串$X$，神树大人打算进行$Q$次操作，第$i$次操作会把小字符串$a_{R_{(i-1)\bmod m+1}}$丢到这个$X$的末尾。

每次操作后，神树大人会检查这个字符串$X$是否存在一个后缀使得任意排列后可以变成$S$。

问有多少次这个字符串$X$存在一个后缀使得**任意排列**后可以变成$S$（即所有字符出现次数相同）。


可惜的是，这个字符串字符大小高达$10^5$，所以你必须读入一个整数数组
## 输入格式

输入$n,T,Q$

接下来输入$T$个数表示字符串$S$

接下来输入$n$行，每行第一个数$len$表示长度，接下来输入$len$个数表示这个小字符串，输入的每个数都在$[0,10^5]$范围内。

接下来输入$m$

输入一行$m$个数，表示$R$。
## 输出格式

输出答案
## 样例

### 样例输入 #1
```
5 5 20
2 2 0 2 0
2 2 0
2 0 2
3 0 2 0
3 0 2 0
2 2 2
10
2 1 5 5 2 2 4 2 5 3
```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
10 10 10000
0 1 1 1 0 1 1 0 0 0 
6 0 0 1 1 1 0 
6 0 0 0 0 0 0 
5 0 0 0 0 0 
4 1 0 0 0 
5 1 1 1 0 1 
2 1 1 
6 0 0 0 0 0 1 
1 0 
4 0 0 1 1 
1 1 
30
10 4 3 9 10 9 4 8 5 10 9 8 6 10 10 4 9 2 2 9 6 4 1 10 10 1 9 10 3 5 
```
### 样例输出 #2
```
3001
```
## 提示

样例1解释：

![](https://cdn.luogu.com.cn/upload/pic/54698.png)


##数据范围

对于所有数据，$n,T,m\leq 10^5,1\leq R_i\leq n,Q\leq 10^9$，所有小字符串的总长不超过$10^5$，所有字符$\in[0,10^5]$。

![](https://cdn.luogu.com.cn/upload/pic/54734.png)


---

---
title: "OwenOwl 不学车也不删库"
layout: "post"
diff: 省选/NOI-
pid: P5271
tag: ['Special Judge', '洛谷月赛']
---
# OwenOwl 不学车也不删库
## 题目背景

神 mcfx 和神 ComeIntoPower 没事就瞎编题目背景。OwenOwl 去问基佬 zcysky 他们这么做的原因，基佬 zcysky 却这样答复：

![](https://cdn.luogu.com.cn/upload/pic/54751.png)

OwenOwl 非常郁闷，于是他有一天找到了神 J，让神 J 造了 20010910 个指针把他们三个指到阿塞拜疆去陪 sunset 阿克了。

他们三个游览阿塞拜疆的时候，OwenOwl 就把车砸了，库恢复了。

但是因为神 mcfx 和神 ComeIntoPower 之前以 OwenOwl 这个 ID 出了太多毒瘤题，OwenOwl 早就风评被害了。为了证明毒瘤的是他俩，不是自己，OwenOwl 就出了道签到题。
## 题目描述

设 $p$ 是一个质数。

你有一个 $p^k$ 个点的无向完全图（任意两个点之间有一条无向边），点的标号是 $0$ 到 $p^k-1$。

现在你需要从中找出一些 $p$ 个点的完全图，使得原图中每条边属于且恰好属于其中一个完全图。

很显然你需要找出的完全图的个数是 $\frac{p^k(p^k-1)/2}{p(p-1)/2} $，可以发现这个式子一定是整数
## 输入格式

一行两个正整数 $p,k$。
## 输出格式

如果无解，输出一行 `NO`。

否则输出一行 `YES`，接下来输出 $\frac{p^k(p^k-1)/2}{p(p-1)/2} $ 行，每行 $p$ 个数表示你找出的这个完全图的点的编号。

按任意顺序输出任意一种方案即可。
## 样例

### 样例输入 #1
```
2 2
```
### 样例输出 #1
```
YES
0 1
2 0
3 0
1 2
1 3
3 2
```
### 样例输入 #2
```
3 1
```
### 样例输出 #2
```
YES
0 1 2
```
## 提示

对于 $10\%$ 的数据，$k \le 1$；

对于 $50\%$ 的数据，$k \le 2$；

另有 $20\%$ 的数据，$p = 2$；

对于 $100\%$ 的数据，$k$ 是正整数，$p$ 是质数，$2 \le p^k \le 2000$。

另外，保证输出总量不超过 2MB，但仍请注意控制输出所花费的时间。


---

---
title: "总而言之神J要去练习篮球"
layout: "post"
diff: 省选/NOI-
pid: P5272
tag: ['O2优化', '洛谷月赛']
---
# 总而言之神J要去练习篮球
## 题目背景

神J和神树大人正在开发一个睡眠程序，运行之后人们就能在梦里随机看到宇宙中的一角。当然大部分时候这一角都是黑的，所以人们总是觉得自己没有做梦。

神J留了个后门，只需要操控指针，就能钦定一个人的梦。于是神J天天操控神树大人梦里写代码。

神树大人很不满意，因为树必须天天睡觉。神树大人是神，早就知道神J在背后操控，所以他也留了个后门，只需要输入特殊命令，就能强迫神J睡觉，并在梦里做任何事情。

这天，神J突然发现自己身处一个大篮球场里，周围有许多学员在练习三人篮球赛。“你傻站在那干啥呢？”神树大人吹着哨子走了过来，“快去练习，都要举行肯德基三人篮球全国总决赛了，快去投进114514个球，再运球过1919810个人。zcy快过来监督他。”一个篮球突然出现在神J手里。于是神J就在zcy的监督下练习了一个下午的篮球。
## 题目描述

为了防止神J用篮球造出一个指针把自己指出去，神树大人钦定神J用篮球造一个矩阵。

这个矩阵无限大，行列从0开始标号，且$a[i][j]=i\ xor\ j$

![](https://cdn.luogu.com.cn/upload/pic/54403.png)

现在，对于一个左上角为$(lx,ly)$，右下角为$(rx,ry)$的子矩阵，$K(K\leq 10^9)$次随机从里面取$W\times H$的矩阵，问取出的矩阵完全一样的概率，对$10^9+7$取模。

## 输入格式

第一行一个数$Q$表示$Q$组询问

之后$Q$行每行7个数$lx,rx,ly,ry,W,H,K$
## 输出格式

输出答案对$10^9+7$取模。保证答案存在。
## 样例

### 样例输入 #1
```
5
54 63 5 59 5 27 2
33 42 1 29 9 23 2
54 55 56 57 2 1 3
40 64 17 40 19 9 1
54 65 35 50 3 10 3
```
### 样例输出 #1
```
626436786
71428572
250000002
1
154489797
```
### 样例输入 #2
```
3
1 2 1 2 1 1 2
3 100 39 100 1 1 2
48395 309846 34098 234095 1 1 2
```
### 样例输出 #2
```
500000004
779746001
262016540

```
## 提示

对于`1 2 1 2 1 1 2`这组询问

![](https://cdn.luogu.com.cn/upload/pic/54402.png)

可以取的矩阵有：0,3，各出现两次。

有如下情况：

第一次取到 3，第二次取到 0，一共4种方法

第一次取到 3，第二次取到 3，一共4种方法

第一次取到 0，第二次取到 0，一共4种方法

第一次取到 0，第二次取到 3，一共4种方法

一共16种方法，符合条件的有4+4=8种

所以答案为 8/16=500000004(mod 10^9+7)


##数据范围

对于所有的数据，$0\leq lx\leq rx\leq 10^9,0\leq ly\leq ry\leq 10^9,W\leq rx-lx+1,H\leq ry-ly+1,1\leq K\leq 10^9,Q\leq 10^3$

![](https://cdn.luogu.com.cn/upload/pic/54632.png)

空格为无特殊限制


---

---
title: "算术天才⑨与等差数列"
layout: "post"
diff: 省选/NOI-
pid: P5278
tag: []
---
# 算术天才⑨与等差数列
## 题目描述

算术天才⑨非常喜欢和等差数列玩耍。   
有一天，他给了你一个长度为 $n$ 的序列，其中第 $i$ 个数为 $a_i$。  
他想考考你，每次他会给出询问 $l,r,k$，问区间 $[l,r]$ 内的数从小到大排序后能否形成公差为 $k$ 的等差数列。  
当然，他还会不断修改其中的某一项。  
为了不被他鄙视，你必须要快速并正确地回答完所有问题。  
注意：只有一个数的数列也是等差数列。
## 输入格式

第一行包含两个正整数 $n,m$，分别表示序列的长度和操作的次数。   
第二行包含 $n$ 个整数，依次表示序列中的每个数 $a_i$。   
接下来 $m$ 行，每行一开始为一个数 $\text{op}$，   
若 $\text{op}=1$，则接下来两个整数 $x,y$，表示把 $a_x$ 修改为 $y$，  
若 $\text{op}=2$，则接下来三个整数 $l,r,k$，表示一个询问。  
在本题中，$x,y,l,r,k$ 都是经过加密的，都需要异或你之前输出的 `Yes` 的个数来进行解密。  
## 输出格式

输出若干行，对于每个询问，如果可以形成等差数列，那么输出 `Yes`，否则输出 `No`。
## 样例

### 样例输入 #1
```
5 3
1 3 2 5 6
2 1 5 1
1 5 4
2 1 5 1
```
### 样例输出 #1
```
No
Yes
```
## 提示

【数据范围】  
对于 $100\%$ 的数据， $1\le n,m \le 3\times 10^5$，$0\le a_i,y,k \le 10^9$。


---

---
title: "[十二省联考 2019] 春节十二响"
layout: "post"
diff: 省选/NOI-
pid: P5290
tag: ['2019', '各省省选', 'O2优化']
---
# [十二省联考 2019] 春节十二响
## 题目背景

“清明时节雨纷纷，路上行人欲断魂。”

$2075$ 年的清明没有春雨。在漫天飞雪的笼罩下，穿行在冰原间的，只有载着人类微薄希望的雪地车。

遥遥 $4.22$ 光年的征途，对于地球这孤独的旅人而言，恐怕也是无比寂寞吧。
## 题目描述

距离苏拉威西只有一百公里了，车内的空气比窗外更加冰冷。四双眼睛紧盯着艾莉
芬面前的屏幕，那是控制行星发动机的关键程序：春节十二响。他需要将其部署到电力控制系统的一个芯片中。

“春节十二响”由 $n$ 个子程序构成，第 $i$ 个子程序所需的内存空间是 $M_i$。这 $n$ 个子程序之间的调用关系构成了一棵以第 $1$ 个子程序为根的树，其中第 $i$ 个子程序在调用树上的父亲是第 $f_i$ 个子程序。

由于内存紧张，电力控制芯片上提供了一种内存分段机制。你可以将内存分为若干
个段 $S_1$, $S_2$, ..., $S_k$，并将每个程序预先分配到一个固定的段。如果两个子程序没有直接或间接的调用关系，则他们可以被分配到同一个段中，反之则不能。换言之，当且仅当 $a$ 和 $b$ 在调用树上**不是祖先—后代关系**，$a$ 和 $b$ 可以被分配到同一个段中。

一个段的大小应当是所有分配到这个段的子程序所需内存大小的最大值，所有段
大小的和不能超过系统的内存大小。

现在艾莉芬想要知道，电力控制芯片至少要有多少内存，才能保证春节十二响的正
确运行。即：最少需要多大的内存，才能通过先**将内存分成若干个段**，再**把每个子程序分配到一个段中，使得每个段中分配的所有子程序之间不存在祖先—后代关系**。
## 输入格式

第一行包含一个正整数 $n$ 表示子程序的个数，其中 $n \leqslant 2 \times 10^5$。

第二行有 $n$ 个用空格隔开的正整数 $M_1$, $M_2$, ..., $M_n$，$M_i$ 表示第 $i$ 个子程序所需的内存空间。

第三行有 $n - 1$ 个用空格隔开的正整数 $f_2$, $f_3$, ..., $f_n$，满足 $f_i < i$，表示第 $i$ 个子程序在调用树上的父亲是第 $f_i$ 个子程序。
## 输出格式

仅一个整数，表示最小的内存需求。
## 样例

### 样例输入 #1
```
5
10 20 20 30 30
1 1 2 2
```
### 样例输出 #1
```
60
```
### 样例输入 #2
```
10
2 1 1 1 1 2 1 1 1 2
1 1 1 4 5 3 3 4 3
```
### 样例输出 #2
```
6
```
### 样例输入 #3
```
15
10 1 10 10 2 6 9 6 8 6 3 4 4 5 5
1 2 2 1 5 4 4 1 2 10 1 9 6 1
```
### 样例输出 #3
```
31
```
## 提示

#### 样例 $1$ 解释
在最优方案中，内存被划分为大小为 $10$，$20$，$30$ 的三个段，其中第 $1$ 个子程序被分配在第 $1$ 个段中，第 $2$、$3$ 个子程序被分配在第 $2$ 个段中，第 $4$、$5$ 个子程序被分配在第 $3$ 个段中。可以证明，不存在更优的方案。

#### 子任务
![img](https://s2.ax1x.com/2019/04/07/AhSGzd.png)

注意：在第 $10$、$11$、$12$ 号测试点中，$1$ 号子程序**不一定**是链的一个端点。

其中 $M$ 是所有子内存需求的最大值，即 $\max\left\{M_i\right\}$。

对于全部数据，$1 \leqslant n \leqslant2 \times 10^5$，$1 \leqslant M \leqslant 10^9$。

艾莉芬经过仔细阅读题面、认真分析数据范围后，开始编写程序求解这个问题。

$\texttt{\$ login Elephant}$

$\texttt{password: ********}$

艾莉芬，高级程序员。豫阳市第三工程组提醒您：

- 做题千万条，读题第一条；

- 编程不规范，爆零两行泪。

$\texttt{\$ cd spring}$

$\texttt{\$ ac spring}$

$\texttt{Spring Accepted. Score: 100/100.}$



---

---
title: "[PKUWC2018] Slay the Spire"
layout: "post"
diff: 省选/NOI-
pid: P5299
tag: ['2018']
---
# [PKUWC2018] Slay the Spire
## 题目描述

九条可怜在玩一个很好玩的策略游戏：Slay the Spire，一开始九条可怜的卡组里有 $2n$ 张牌，每张牌上都写着一个数字$w_i$，一共有两种类型的牌，每种类型各 $n$ 张：

1. 攻击牌：打出后对对方造成等于牌上的数字的伤害。

2. 强化牌：打出后，假设该强化牌上的数字为 $x$，则其他剩下的**攻击牌**的数字都会乘上 $x$。**保证强化牌上的数字都大于 1**。

现在九条可怜会等概率随机从卡组中抽出 $m$ 张牌，由于费用限制，九条可怜最多打出 $k$ 张牌，假设九条可怜永远都会采取能造成最多伤害的策略，求她期望造成多少伤害。

假设答案为 $\text{ans}$ ，你只需要输出

$$\left (\text{ans}\times \frac{(2n)!}{m!(2n-m)!}\right) ~\bmod 998244353$$

即可。其中 $x!$ 表示 $\prod_{i=1}^{x}i$，特别地，$0!=1$ 。

## 输入格式

第一行一个正整数 $T$ 表示数据组数

接下来对于每组数据：

第一行三个正整数 $n,m,k$

第二行 $n$ 个正整数 $w_i$，表示每张强化牌上的数值。

第三行 $n$ 个正整数 $w_i$，表示每张攻击牌上的数值。

## 输出格式

输出 $T$ 行，每行一个非负整数表示每组数据的答案。

## 样例

### 样例输入 #1
```
2
2 3 2
2 3
1 2
10 16 14
2 3 4 5 6 7 8 9 10 11
1 2 3 4 5 6 7 8 9 10
```
### 样例输出 #1
```
19
253973805
```
## 提示

#### 样例解释
例如九条可怜抽到了攻击牌 $\{1,2\}$ 和强化牌 $\{3\}$，那最优策略是先用掉强化牌 $3$，此时攻击牌的数值变成 $\{3,6\}$，然后打出 $6$。


#### 数据范围

对于所有数据，有 $1\leq k\leq m\leq 2n\leq 3000$，且$1\leq w_i\leq 10^8$。

**保证强化牌上的数字都大于 1**。

以下 $(\sum 2n)$ 表示对于输入中所有数据的$2n$的和。

对于 $10\%$ 的数据，有 $1\leq \sum 2n\leq 10$

对于 $20\%$ 的数据，有 $1\leq \sum 2n\leq 100$

对于 $30\%$ 的数据，有 $1\leq \sum 2n\leq 500$

另有 $20\%$ 的数据，满足所有攻击牌的数值相同。

另有 $20\%$ 的数据，满足 $m=k$。

对于 $100\%$ 的数据，有 $1\leq \sum 2n\leq 30000$



---

---
title: "[COCI 2018/2019 #5] Transport"
layout: "post"
diff: 省选/NOI-
pid: P5306
tag: ['2018', 'COCI（克罗地亚）']
---
# [COCI 2018/2019 #5] Transport
## 题目描述

 一个国家有 $n$ 个城市，每个城市中都有一个加油站，燃料储量为 $a_i$。  
有 $n-1$ 条路径，将这些城市连接成一个树形结构。  

一个货车能从城市 $u$ 到达城市 $v$ ，货车的燃料量必须不小于 $u,v$ 之间的距离。  
每当货车抵达一个城市，就可以补充不超过加油站储量的燃料。  

假设货车的油箱是无限大的，请你算出有多少个有序数对 $(u,v)$ 满足：  
一个油箱燃料量初始为 $0$ 的货车，可以从城市 $u$ 出发，抵达城市 $v$。

请注意，货车只能走简单路径，也就是说不能走回头路。
## 输入格式

第一行一个正整数 $n$。  
第二行有 $n$ 个正整数 $a_i$ ，表示每个加油站的燃料储量。  
接下来 $n-1$ 行，每行三个正整数 $u,v,w$，表示城市 $u,v$ 之间有一条长为 $w$ 的路径。
## 输出格式

一行一个整数表示答案。
## 样例

### 样例输入 #1
```
2
3 1
1 2 2
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
5
3 1 2 4 5
1 2 3
3 2 2
4 2 6
5 4 3
```
### 样例输出 #2
```
5
```
## 提示

### 样例1解释：  
唯一可行的是 $(1,2)$，即只有 $1\rightarrow 2$ 是可行的。  

### 数据范围：  
对于 $20\%$ 的数据：  
$1\le n \le 5000$   
对于 $40\%$ 的数据：   
树是一条链    
对于 $100\%$ 的数据：   
$1\le n \le 10^5$      
$1\le u,v \le n$     
$1\le w,a_i \le 10^9$   


---

---
title: "[SNOI2019] 数论"
layout: "post"
diff: 省选/NOI-
pid: P5330
tag: ['2019', '各省省选', '陕西']
---
# [SNOI2019] 数论
## 题目描述

给出正整数 $P,Q,T$ ，大小为 $n$ 的整数集 $A$ 和大小为 $m$ 的整数集 $B$ ，请你求出：

$$
\sum_{i=0}^{T-1}[(i\bmod P) \in A \land (i\bmod Q) \in B]
$$


换言之，就是问有多少个小于 $T$ 的非负整数 $x$ 满足：$x$ 除以 $P$ 的余数属于 $A$ 且 $x$ 除以 $Q$ 的余数属于 $B$。
## 输入格式

第一行 $5$ 个用空格隔开的整数 $P,Q,n,m,T$。

第二行 $n$ 个用空格隔开的整数，表示集合 $A=\{A_1,A_2,\cdots,A_n\}$。保证 $A_i$ 两两不同，且 $0 \leq A_i<P$。

第三行 $m$ 个用空格隔开的整数，表示集合 $B=\{B_1,B_2,\cdots,B_m\}$。保证 $B_i$ 两两不同，且 $0 \leq B_i<Q$。

## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
4 6 3 3 14
0 1 3
2 4 5
```
### 样例输出 #1
```
4
```
## 提示

对于所有数据，$1 \leq n,m \leq 10^6 , 1 \leq P,Q \leq 10^6 , 1 \leq T \leq 10^{18}$。

对于10%的数据，$T \leq 10^6$。

对于另外20%的数据，$P,Q \leq 1000$。

对于另外10%的数据，$T$是$P,Q$的公倍数。

对于另外10%的数据，$P,Q$互质，且$P,Q \leq 10^5$。

对于另外10%的数据，$P,Q$互质。

对于另外10%的数据，$P,Q \leq 10^5$。

对于余下30%的数据，无特殊限制。

- 2023.11.17 添加三组 hack 数据。


---

---
title: "[TJOI2019] 甲苯先生的滚榜"
layout: "post"
diff: 省选/NOI-
pid: P5338
tag: ['2019', '各省省选', '天津']
---
# [TJOI2019] 甲苯先生的滚榜
## 题目描述

甲苯先生在制作一个 Online Judge，他发现做比赛的人们很关心自己的排名（显而易见）。

在 ACM 赛制的比赛中，如果通过题目数量不相等，则通过题目数量多的人排名更靠前；  
如果通过题目数量相等，则罚时更少的人排名更高。

甲苯先生想让大家帮忙设计一个程序，每次有人通过之后，就告诉他排名在他的前面有多少人。  
（不包括和他罚时题数都相同的同学）
## 输入格式

第一行输入一个整数 $T$ 表示测试样例的个数。

对于每一个样例，输入三个整数 $m, n, \text{seed}$。  
$m$ 表示参赛总人数（编号 $1 \sim m$），$n$ 表示一共有 $n$ 次 AC（假设 AC 已经去重，即不存在相同人的相同题目提交）。  
$\text{seed}$ 表示生成数据的种子。

接下来要求同学们使用之下的函数生成数据：
```cpp
typedef unsigned int ui ;
ui randNum( ui& seed , ui last , const ui m){ 
    seed = seed * 17 + last ; return seed % m + 1; 
}
```
（$\texttt{last}$ 为上一次输出的结果，在没有输出结果时 $\texttt{last} = 7$，多组数据时 $\texttt{last}$ 不需要重新赋值）  
要求每次生成两个数据 $\texttt{Ria}, \texttt{Rib}$，表示第 $\texttt{Ria}$ 个人 AC 了一道题目，他的罚时为 $\texttt{Rib}$。  
（也就是说 $\texttt{Ria}$ 的题目数量 $+1$，罚时长度 $+\texttt{Rib}$）。

要求一共生成 $n$ 组数据，代表一共有 $n$ 次提交。

对于所有数据，保证罚时总和不超过 $1.5\times 10^6$。
## 输出格式

每次提交输出一行整数，表示在第 $\texttt{Ria}$ 个人 AC 后，比 $\texttt{Ria}$ 成绩高的有多少个选手。
## 样例

### 样例输入 #1
```
1
7 3 1

```
### 样例输出 #1
```
0
1
0

```
## 提示

| 测试点# | 1, 2 | 3, 4 | 5 |6, 7, 8 | 9, 10 |
| :-: | :-: | :-: | :-: | :-: |:-:|
| $T$ | $\le10$ | $\le5$ | $\le15$ | $\le5$ | $\le5$ |
| $m$ | $\le1000$ | $\le10000$ | $\le10^5$ | $\le10^4$ |$\le10^5$|
| $n$ | $\le1000$ | $\le10000$ | $\le10^5$ | $\le10^6$ |$\le10^6$|



---

---
title: "[TJOI2019] 甲苯先生和大中锋的字符串"
layout: "post"
diff: 省选/NOI-
pid: P5341
tag: ['2019', '各省省选', '天津']
---
# [TJOI2019] 甲苯先生和大中锋的字符串
## 题目背景

TJOI2019 D2T2

源文件名：substring.*

时间限制: 1s 内存限制: 128M
## 题目描述

大中锋有一个长度为 $n$ 的字符串，他只知道其中的一个子串是祖上传下来的宝藏的密码。但是由于字符串很长，大中锋很难将这些子串一一尝试。

这天大中锋找到甲苯先生算命，但是甲苯先生说：“天机不可泄漏”。

在大中锋的苦苦哀求下，甲苯先生告诉大中锋：“密码是在字符串中恰好出现了 $k$ 次的子串”。

但是大中锋不知道该怎么做，在大中锋再三的恳求下，甲苯先生看其真诚，又告诉他：“在恰好出现了 $k$ 次的子串中，你去按照字串的长度分类，密码就在数量最多的那一类里”。

大中锋为了尝试这个密码，想让你帮忙找出子串长度出现次数最多的长度数（如果有多个输出最长长度）。
## 输入格式

第一行一个正整数 $T$ ，表示有 $T$ 组测试数据。

接下来 $T$ 行每行包含一个字符串和一个正整数 $k$ 。
## 输出格式

一共输出 $T$ 行，每行一个整数表示在出现 $k$ 次的子串中出现次数的最多的长度。如果不存在子串出现 $k$ 次，则输出 $-1$ 。
## 样例

### 样例输入 #1
```
6
aab 1
abc 1
aaaa 2
abab 2
ababacc 2
abab 4
```
### 样例输出 #1
```
2
1
3
1
2
-1
```
## 提示

### 数据说明 ###

对于第一个数据：其中子串 $b, aa, ab, aab$ 均只出现一次，其中长度为 $1$ 的子串出现了 $1$ 次，长度为 $2$ 的子串出现了 $2$ 次，长度为 $3$ 的子串出现了 $1$ 次。所以答案为 $2$ 。

对于第二个数据：其中子串 $a, b, c, ab, bc, abc$ 均只出现一次，其中长度为 $1$ 的子串出现了 $3$ 次，长度为 $2$ 的子串出现了 $2$ 次，长度为 $3$ 的子串出现了 $1$ 次。所以答案为 $1$ 。

对于第三个数据：其中子串 $aaa$ 出现二次，长度为 $3$ 的子串出现了 $1$ 次，其他长度均没有。所以答案为 $3$ 。

对于第四个数据：其中子串 $a, b, ab$ 出现二次，其中长度为 $1$ 的子串出现了 $2$ 次，长度为 $2$ 的子串出现了 $1$ 次。所以答案为 $1$ 。

对于第五个数据：其中子串 $b, c, ab, ba$ 出现二次，其中长度为 $1$ 的子串出现了 $2$ 次，长度为 $2$ 的子串出现了 $2$ 次。所以答案为 $2$ 。

对于第六个数据：其中子串没有出现四次。所以本题的本题的答案为 $-1$ 。

### 数据范围 ###

对于 $20\%$ 的数据， $1\leq k\leq n\leq 10$

对于 $100\%$ 的数据， $1\leq n\leq 10^5,1 \leq T \leq 100,\sum n \leq 3 * 10^6$ ，输入的字符串中仅包含小写英文字母。


---

---
title: "密码解锁"
layout: "post"
diff: 省选/NOI-
pid: P5348
tag: []
---
# 密码解锁
## 题目背景

在开锁公司劳动
## 题目描述

这天，WD发现了一个很奇怪的密码锁，他记得CX让他解开这个密码锁之前告诉过他一些数字，可惜由于WD菜的真实，早就忘了那些数字是啥，只记得把他们从1到$n$编号后，对于任意的正整数$d(1\le d\le n)$，编号为$d$的倍数的数字之和恰好等于$\mu(d)$（即$d$的莫比乌斯函数值）。

现在，由于要打开这个密码锁，他必须知道第$m$个位置上的数字。由于他什么都不会，当然要请你来帮忙啦……
## 输入格式

第一行一个数$T$，表示数据组数。接下来$T$行每行两个数，分别为$n,m$。
## 输出格式

共$T$行，每行一个数字，表示第$m$个数字的值。显然可以证明解是唯一的。
## 样例

### 样例输入 #1
```
2
5 1
5 2
```
### 样例输出 #1
```
4
-1
```
## 提示

$subtask1(21pts):~n\le 10^6,~T\le 5$

$subtask2(34pts):~n\le 10^7,~T\le 10$

$subtask3(45pts):~n\le 10^{18},~m\le 10^9,~\frac{n}{m}\le 10^9,~T\le 20$

对于所有数据，$m\le n$。

对于样例1，满足要求的数列为4 -1 -1 0 -1.


---

---
title: "幂"
layout: "post"
diff: 省选/NOI-
pid: P5349
tag: []
---
# 幂
## 题目背景

来到数学院劳动

## 题目描述

$$\text{求}\ \sum_{n=0}^{\infty}f(n)\ r^n\ ,\ f(n)\text{为一个多项式},\ r\text{是一个}(0,1)\text{内的有理数}$$

若答案的最简分数为$\frac{p}{q}$，你只需要输出$p\times q^{-1}\  \mathrm{mod} \ 998244353\ $的值即可。
## 输入格式

第一行两个整数$m,r$。$m$为多项式的次数。

第二行$m+1$个整数，第$i$个为$x^{i-1}$的系数$a_{i-1}$。
## 输出格式

仅一行一个数字，为答案。
## 样例

### 样例输入 #1
```
1 499122177
0 1
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
2 748683265
0 0 1
```
### 样例输出 #2
```
628524223
```
### 样例输入 #3
```
3 713031681
7 5 23 2
```
### 样例输出 #3
```
257147786
```
## 提示

对于$10\%$的数据，$m\le 5$。

对于$40\%$的数据，$m\le 2000$。

对于$100\%$的数据，$m\le 10^5\ ,\ a_i\in [0,998244353)$，保证$\ a_{m}\neq 0$

**捆绑测试**

----

**样例1解释：**

$499122177\equiv \frac{1}{2}\ (\mathrm{mod}\ 998244353)$

$\sum_{n=0}^{\infty}n\ (\frac{1}{2})^n=2$

-----

**样例2解释：**

$748683265\equiv \frac{1}{4}\ (\mathrm{mod}\ 998244353)$

$\sum_{n=0}^{\infty}n^2\ (\frac{1}{4})^n=\frac{20}{27}$

-----

**样例3解释：**

$713031681\equiv \frac{2}{7}\ (\mathrm{mod}\ 998244353)$

$\sum_{n=0}^{\infty}(2n^3+23n^2+5n+7)\ (\frac{2}{7})^n=\frac{25417}{625}$




---

---
title: "序列"
layout: "post"
diff: 省选/NOI-
pid: P5350
tag: ['洛谷原创']
---
# 序列
## 题目背景

搬运序列
## 题目描述

有一个序列$a_n$和若干操作。

- $\mathrm{1\  l \  r \ }$ 求$a_l$到$a_r$的和 
- $\mathrm{2\  l \  r \ val \ }$ 将$a_l$到$a_r$赋值为$\mathrm{val}$ 
- $\mathrm{3\  l \  r \ val\ }$将$a_l$到$a_r$加上$\mathrm{val}$ 
- $\mathrm{4\  l_1 \  r_1 \  l_2 \  r_2 }$将$a_{l_1}$到$a_{r_1}$复制到$a_{l_2}$到$a_{r_2}$处 
- $\mathrm{5\  l_1 \  r_1 \  l_2 \  r_2 }$将$a_{l_1}$到$a_{r_1}$与$a_{l_2}$到$a_{r_2}$交换 
- $\mathrm{6\  l \  r \ }$将$a_l$到$a_r$翻转 
## 输入格式

第一行两个数$n$和$m$，为序列长度和操作个数。

第二行$n$个数，为$a_i$。

下面$m$行，每行为操作种类和相应的若干整数。

## 输出格式

若干行，对于每个$1$操作，输出答案。

由于答案可能过大，对$10^9+7$取模。

最后一行输出序列$a_n$。当然也要取模。
## 样例

### 样例输入 #1
```
10 10
7 1 3 2 2 4 0 1 2 2 
4 10 10 3 3
3 4 10 5
6 6 7
6 9 10
1 10 10
5 9 10 6 7
2 8 10 0
5 4 4 5 5
5 2 4 8 10
3 3 9 0
```
### 样例输出 #1
```
7
7 0 0 0 7 7 7 1 2 7
```
## 提示

**请注意常数优化**

若是$\mathrm{copy}$和$\mathrm{swap}$操作，保证$r_1-l_1=r_2-l_2$且区间不重叠。


保证数据随机。

对于$30\%$的数据，保证$\ n,m\le 10^3\ $。

对于$50\%$的数据，保证$\ n,m\le 5\times 10^4\ $。

对于$70\%$的数据，保证$\ n,m\le 1.5\times 10^5\ $。

对于$100\%$的数据，保证$\ n,m\le 3\times 10^5\ ,\ 0\le a_i,\mathrm{val}\lt Mod\ $。


---

---
title: "Ruri Loves Maschera"
layout: "post"
diff: 省选/NOI-
pid: P5351
tag: ['O2优化']
---
# Ruri Loves Maschera
## 题目背景


琉璃最近沉迷于《Maschera》的二次创作。
## 题目描述

琉璃小说中的世界有 $n$ 座城市，其中有 $n-1$ 条道路，不包含重边、自环。这 $n-1$ 条道路中，第 $i$ 条道路的魔力值为 $w_i$。

琉璃作为夜魔女王，她决定要观光整个黑暗世界 。她每次会随机选一个城市为起点，经过不少于 $L$ 条且不多于 $R$ 条道路后在一个城市为终点结束。**她在观光的时候是不走回头路的。**若琉璃每次观光中经过道路的魔力值依次为 $v_1,v_2,...,v_k(L\leq k\leq R)$，那么她会获得 $\max(v_1,v_2,...,v_k)$ 的魔力值。

现在琉璃想知道，她尝试了所有合法的观光路线后，她所获得的魔力值总和为多少。

**注意，$x$ 到 $y$ 的路径和 $y$ 到 $x$ 的路径视为两条路径。**
## 输入格式

第一行三个数 $n,L,R$

接下来 $n-1$ 行，每行三个数 $x,y,w$，表示 $x$ 结点和 $y$ 结点之间有一条魔力值为 $w$ 的道路。
## 输出格式

输出她所获得的魔力值总和。
## 样例

### 样例输入 #1
```
5 2 3
1 2 2
2 3 2
3 4 4
4 5 5
```
### 样例输出 #1
```
40
```
## 提示

数据范围：

对于 $10\%$ 的数据，$n\leq 5000$

另有 $10\%$ 的数据，$\min(x,y)=1$

另有 $15\%$ 的数据，$|x-y|=1$

另有 $25\%$ 的数据，$L=1,R=n-1$

对于 $100\%$ 的数据，$n\leq 10^5,1\leq L\leq R\leq n-1,1\leq w_i\leq 10^5$


---

---
title: "Terrible Homework"
layout: "post"
diff: 省选/NOI-
pid: P5352
tag: []
---
# Terrible Homework
## 题目背景

“像糟糕的作业一样糟糕。”
## 题目描述

$ben$同学最讨厌做作业了。

现在，老师布置给了$ben$同学$n$份作业，每份作业有一个难度值$A_i$。

一开始，每份作业都是独立的。有一些操作，每次在两份作业$x,y$间加一条边或删除一条边。

由于老师喜怒无常，因此还有一些操作，是将两份作业$x,y$之间路径上的所有作业的难度值都$xor$上一个值。

同时，为了满足$ben$同学的好奇心，你需要回答两份作业$x,y$之间的所有作业的难度$and$和、难度$or$和、难度$xor$和以及难度和。
## 输入格式

第一行两个正整数$n,q$，分别表示作业份数和操作个数。

接下来一行，$n$个自然数$A_1,...,A_n$，表示每份作业的难度值。

接下来$q$行，每行一个操作：

- $L\ x\ y$：在$x,y$两份作业之间连一条边。（保证不会形成环，即任何时候这张图都是一个森林）
- $C\ x\ y$：删除$x,y$两份作业之间的边。（保证这条边存在且不会被删除多次）
- $U\ x\ y\ v$：将$x,y$两份作业之间路径上的所有作业的难度值都$xor$上$v$。（包括这两份作业，且保证联通，下同）
- $A\ x\ y$：询问$x,y$两份作业之间的所有作业的难度$and$和。
- $O\ x\ y$：询问$x,y$两份作业之间的所有作业的难度$or$和。
- $X\ x\ y$：询问$x,y$两份作业之间的所有作业的难度$xor$和。
- $S\ x\ y$：询问$x,y$两份作业之间的所有作业的难度和。
## 输出格式

对于每一个$A,O,X,S$操作，输出答案。
## 样例

### 样例输入 #1
```
4 10
1 2 3 4
L 1 2
L 2 3
L 2 4
A 1 4
U 3 4 2
O 1 4
C 2 4
L 3 4
X 1 4
S 1 3
```
### 样例输出 #1
```
0
7
6
2
```
## 提示

对于$10\%$的数据，$n=100,m=100$。

另有$10\%$的数据，$n=5000,m=5000$。

另有$20\%$的数据，$n=10000,m=10000$。

对于$100\%$的数据，$2\le n,m\le100000,0\le A_i<2^{30}$。


---

---
title: "[SDOI2019] 热闹的聚会与尴尬的聚会"
layout: "post"
diff: 省选/NOI-
pid: P5361
tag: ['2019', '各省省选', '山东', 'Special Judge', 'O2优化']
---
# [SDOI2019] 热闹的聚会与尴尬的聚会
## 题目背景

小 Q 的生日快到了，他决定周末邀请一些朋友到他的新房子一起聚会！
## 题目描述

他的联系薄上有 $n$ 位好友，他们两两之间或者互相认识，或者互相不认识。小 Q 希望在周六办一个热闹的聚会，再在周日办一个尴尬的聚会。

- 一场热闹度为 $p$ 的聚会请来了任意多位好友，对于每一位到场的好友来说都有至少 $p$ 位他认识的好友也参加了聚会，且至少对于一位到场的好友来说现场恰好有 $p$ 位他认识的好友；
- 一场尴尬度为 $q$ 的聚会请来了恰好 $q$ 位好友，且他们两两互不认识。

两场聚会可能有重复的参与者，联系薄上也有可能有某些好友同时缺席了两场聚会。

小 Q 喜欢周六聚会的热闹度 $p$ 与周日聚会的尴尬度 $q$ 之间满足：$\left\lfloor \frac{n}{p+1} \right\rfloor\! \le q$ 且 $\left\lfloor \frac{n}{q+1} \right\rfloor\! \le p$。

请帮助小 Q 找出一个可行的邀请方案。
## 输入格式

**输入含有多组测试数据**，并在第一行给定一个整数 $T$，表示总共有多少组测试数据。之后依次给出每一组数据。

每一组测试数据第一行给定两个整数 $n$ 和 $m$，依次表示联系薄中好友的总数，以及有多少对互相认识的好友。

之后 $m$ 行每行给定两个正整数 $u$ 和 $v$，满足 $1\le u\neq v\le n$ ，表示第 $u$ 个好友与第 $v$ 个好友互相认识。
## 输出格式

对于每一组数据输出两行，依次描述周六热闹的聚会的参加人员，与周日尴尬的聚会的参加人员列表：

第一行先输出一个正整数表示总共邀请来了多少位好友参加周六的聚会，再之后输出若干个不同的整数，按照任意顺序描述被邀请的是哪些好友。

第二行先输出一个正整数表示总共邀请来了多少位好友参加周日的聚会，再之后以任意顺序输出若干个不同的整数，同样描述了周日被邀请的好友。

如果有多组方案，你可以输出其中任何一组。
## 样例

### 样例输入 #1
```
2
6 15
1 2
1 3
1 4
1 5
1 6
2 3
2 4
2 5
2 6
3 4
3 5
3 6
4 5
4 6
5 6
8 11
1 2
2 3
1 4
3 7
4 5
5 2
2 6
6 7
5 6
5 8
6 8
```
### 样例输出 #1
```
6 1 2 3 4 5 6
1 4
8 1 2 3 4 5 6 7 8
4 8 4 7 2
```
## 提示

#### 数据规模与约定

- 子任务 $1$（$10$ 分）：$1\le n\le 500$；  
- 子任务 $2$（$10$ 分）：$1\le n\le 700$；  
- 子任务 $3$（$10$ 分）：$1\le n\le 900$；  
- 子任务 $4$（$10$ 分）：$1\le n\le 1.1 \times {10}^3$；  
- 子任务 $5$（$10$ 分）：$1\le n\le 2 \times {10}^3$；  
- 子任务 $6$（$10$ 分）：$1\le n\le 3 \times {10}^3$；  
- 子任务 $7$（$10$ 分）：$1\le n\le 4.5 \times {10}^3$；  
- 子任务 $8$（$10$ 分）：$1\le n\le 6 \times {10}^3$；  
- 子任务 $9$（$10$ 分）：$1\le n\le 8 \times {10}^3$；  
- 子任务 $10$（$10$ 分）：$1\le n\le {10}^4$。

对于全部的测试点，满足 $1\le T\le 32$ 且 $1\le m\le 10^5$。

---

#### 提示

本题读入量很大，请注意自己代码在读入上的所需时间。

---
#### 说明

感谢 @[81179332\_](/user/53994) 提供 spj！


---

---
title: "[SDOI2019] 移动金币"
layout: "post"
diff: 省选/NOI-
pid: P5363
tag: ['2019', '各省省选', '山东', 'O2优化']
---
# [SDOI2019] 移动金币
## 题目描述

Alice和Bob将要进行如下的一场游戏。二人轮流操作，且Alice先行。
当轮到一个玩家的时候，他可以选择一枚金币，并将其向左移动任意多格，且至少移动一格。
金币不能被移出棋盘，也不能越过其它金币。

一个 $1\times n$ 的棋盘上最初摆放有 $m$ 枚金币。其中每一枚金币占据了一个独立的格子，任意一个格子内最多只有一枚金币。

如果轮到一个玩家的时候他已经无法做出任何有效操作了（显然这个时候$m$枚金币恰好落在最左侧的$m$个格子中），则被判定为输家。已经知道Alice和Bob都是极致聪明的人，他们在任何局面下总能做出最优的操作。那么有多少初始状态能保证Alice必胜呢？
## 输入格式

输入仅有一行并包含两个正整数，依次为$n$和$m$，如题目所述。
## 输出格式

输出一个整数，表示有多少初始状态可以保证Alice作为先手方能先手必胜。由于答案可能很大，请输出关于$10^9+9$取模后的值。
## 样例

### 样例输入 #1
```
10 3
```
### 样例输出 #1
```
100
```
### 样例输入 #2
```
199 43
```
### 样例输出 #2
```
981535230
```
### 样例输入 #3
```
99999 47
```
### 样例输出 #3
```
39178973
```
## 提示

子任务$1$：（$50$分）$1\le n\le 250$且$1\le m\le 50$。

子任务$2$：（$50$分）$1\le n\le 150000$且$1\le m\le 50$。


---

---
title: "[SNOI2017] 礼物"
layout: "post"
diff: 省选/NOI-
pid: P5364
tag: ['2017', '各省省选']
---
# [SNOI2017] 礼物
## 题目描述

热情好客的**小猴子**请森林中的朋友们吃饭，他的朋友被编号为 $1\sim N$，每个到来的朋友都会带给他一些礼物：**大香蕉**。其中，第一个朋友会带给他 $1$ 个**大香蕉**，之后，每一个朋友到来以后，都会带给他之前所有人带来的礼物个数再加他的编号的 $K$ 次方那么多个。所以，假设 $K=2$，前几位朋友带来的礼物个数分别是：

$1,5,15,37,83,\ldots$

假设 $K=3$，前几位朋友带来的礼物个数分别是：

$1,9,37,111,\ldots$

现在，**小猴子**好奇自己到底能收到第 $N$ 个朋友多少礼物，因此拜托于你了。

已知 $N,K$，请输出第 $N$ 个朋友送的礼物个数对 $10^9+7$ 取模的结果。
## 输入格式

第一行，两个整数 $N,K$。
## 输出格式

一个整数，表示第 $N$ 个朋友送的礼物个数对 $10^9+7$ 取模的结果。
## 样例

### 样例输入 #1
```
4 2
```
### 样例输出 #1
```
37
```
### 样例输入 #2
```
2333333 2
```
### 样例输出 #2
```
514898185
```
### 样例输入 #3
```
1234567890000 3
```
### 样例输出 #3
```
891659731
```
### 样例输入 #4
```
66666666 10
```
### 样例输出 #4
```
32306309
```
## 提示

- $20\%$ 的数据：$N \le 10^6$；
- 另外 $10\%$ 的数据：$K=1$；
- 另外 $20\%$ 的数据：$K=2$；
- 另外 $20\%$ 的数据：$K=3$；
- $100\%$ 的数据：$N \le 10^{18}$，$K \le 10$。


---

---
title: "[PKUSC2018] 最大前缀和"
layout: "post"
diff: 省选/NOI-
pid: P5369
tag: ['2018']
---
# [PKUSC2018] 最大前缀和
## 题目描述

小 C 是一个算法竞赛爱好者，有一天小 C 遇到了一个非常难的问题：求一个序列的最大子段和。

但是小 C 并不会做这个题，于是小 C 决定把序列随机打乱，然后取序列的最大前缀和作为答案。

小 C 是一个非常有自知之明的人，他知道自己的算法完全不对，所以并不关心正确率，他只关心求出的解的期望值，现在请你帮他解决这个问题，由于答案可能非常复杂，所以你只需要输出答案乘上 $n!$ 后对 $998244353$ 取模的值，显然这是个整数。

注：最大前缀和的定义：$\forall i \in [1,n]$，$\sum_{j=1}^{i}a_j$的最大值。

## 输入格式

第一行一个正整数 $n$，表示序列长度。

第二行 $n$ 个数，表示原序列 $a[1..n]$，第 $i$ 个数表示 $a[i]$ 。

## 输出格式

输出一个**非负整数**，表示答案。

## 样例

### 样例输入 #1
```
2
-1 2
```
### 样例输出 #1
```
3
```
## 提示

对于$10\%$的数据，有$1\leq n\leq 9$。

对于$40\%$的数据，有$1\leq n\leq 15$。

另有$10\%$的数据，满足$a$中最多只有一个负数。

另有$10\%$的数据，满足$|a[i]|\leq 2$。

对于$100\%$的数据，满足$1\leq n\leq 20$，$\sum_{i=1}^{n}|a[i]|\leq 10^9$。



---

---
title: "[PKUSC2018] 主斗地"
layout: "post"
diff: 省选/NOI-
pid: P5370
tag: ['2018']
---
# [PKUSC2018] 主斗地
## 题目描述

如果你参加过 NOIP 2015 和 PKUWC 2018，那么你一定对一道叫做斗地主的题印象深刻。为了致敬经典，我们又出了一道有关打牌的题。在本题中，牌型和斗地主**类似但不完全相同**，我们称本题中的扑克游戏为主斗地。

主斗地是一种使用黑桃、红心、梅花、方片的A到K加上大小王的共54张牌来进行的扑克牌游戏，其中大小王各一张，其他数码牌各四张。在斗地主中，牌的大小关系根据牌的数码表示如下：$3<4<5<6<7<8<9<10(T)<J<Q<K<A<2< $小王 $(w)$ $<$ 大王 $(W)$，而花色并不对牌的大小产生影响。每一局游戏中，一副手牌由 $n$ 张牌组成。游戏者每次可以根据规定的牌型进行出牌，首先打光自己的手牌一方取得游戏的胜利。为了简化题目，本题不考虑花色的影响，即**所有的相同的数码的牌都是被视为一样的**。

在这道题中，允许的出牌牌型有（**这一部分与传统的斗地主有所出入，请注意**）：

|   名称    |           解释           |      举例       |     注     |
| :-----: | :--------------------: | :-----------: | :-------: |
|   单牌    |         单独的一张牌         |       6       | 单张的王也是单牌  |
|   对子    |        相同数码的两张牌        |      66       |  大小王不是对子  |
|   三张牌   |        相同数码的三张牌        |      666      |           |
|   三带一   |     相同数码的三张牌带上一张单牌     |     666w      |           |
|   三带二   |  相同数码的三张牌带上一个另外数码的对子   |     66699     |           |
|   顺子    |    大小连续的 $5$ 张及以上单牌    |    3456789    | 不能含有大小王和2 |
|   连对    |   大小连续的 $3$ 对及以上的对子    |   33445566    | 不能含有大小王和2 |
|   三顺    |     大小连续的两组及以上的三张牌     |   333444555   | 不能含有大小王和2 |
|   四带二   |     四张相同数码的牌带上两张单牌     | 444456 444455 | 注意不能带两个对子 |
| 飞机（单翅膀） | 三顺带上相同数量的**数码两两不同的**单牌 | 33344455569J  |           |
| 飞机（双翅膀） | 三顺带上相同数量的**数码两两不同的**对子 |  3334446699   |           |

**注意**：

1. 在牌型中没有连炸这种牌型，但是形如 444455556666 的牌仍然是能出的，它将被视为 444555666 带 456 的飞机（单翅膀）牌型。
2. 大王和小王数码不同，即飞机带大小王是合法的，例如 333444wW
3. 容易验证，上述牌型的规则是合法的，即对于任意合法的牌，它都有唯一的牌型。
4. 在牌型中，没有炸弹。**炸弹将被视为三带一，且没有炸弹的效果**，即它不能压任何牌型。
5. 在牌型中，没有火箭。这意味着 wW 不再是一个合法的牌型。

两手牌是属于相同牌型的当且仅当他们的名称相同且包含牌的数量相同。相同牌型的牌之间存在着大小关系：

1. 三带一三带二的大小取决于那三张相同牌的数码
2. 飞机的大小取决于三顺的大小
3. 四带二的大小取决于四张相同牌的大小
4. 其他牌型的大小取决于牌中的最大的一张牌

下面是对主斗地的游戏过程的描述：

1. 在主斗地中，有两个玩家，他们是同一个阵营的，两个玩家要一同达成游戏目标。为了方便，我们假设第一个玩家是九条可怜，第二个玩家是××网友。
2. 游戏只会使用一副完整的扑克牌。在游戏开始的时候，**会先把所有的 $3$ 扔掉**。之后双方各从这一副牌中随机抽取 $17$ 张，余下的 $16$张被丢弃。你可以认为是随机洗牌后，九条可怜取前 $17$ 张，××网友后 $17$ 张，剩下的 $16$ 张被掉了。
3. 游戏分成若干轮，每一轮分为两步：
   1. 第一步，九条可怜从当前手牌中选择一个任意牌型任意大小的牌 $C$ 并打出。
   2. 第二步，××网友从当前手牌中选择一个和 $C$ 牌型相同且大小 **严格更大** 的牌 $C'$ 打出。如果不存在这样的牌则游戏失败。
4. 在某一轮结束后，如果九条可怜和××网友中有至少一个人没有手牌，则游戏结束。如果两个人都没有手牌，则游戏胜利，否则游戏失败。

下面是一个例子：

假设九条可怜的牌是 44445556789TJQKwW，××网友的牌是 666789TJQKAAAA222。那么一个可以获胜的方案是：

1. 第一轮九条可怜出 4444wW，××网友出 AAAA22。
2. 第二轮九条可怜出 6789TJQ，××网友出 789TJQK。
3. 第三轮九条可怜出 555K，××网友出 6662。

这个游戏很考验两个玩家之间的默契。但是因为九条可怜和××网友无法相互理解，于是他们打算以明牌的方式进行游戏，即双方都知道对方的牌。因为两个人都会按照最优策略行动，所以在牌下发的时候，游戏的胜负就已经确定了。

现在给出××网友的牌，你需要计算九条可怜有多少种不同的可能的手牌可以获得胜利。

注意：××网友和九条可怜的牌都来自于同一副扑克，且分牌的时候没有 $3$。
## 输入格式

每组数据输入一行，一个长度为 $17$ 的字符串表示××网友的牌。我们用 456789TJQKA2wW 来表示每一种牌。

## 输出格式

对每组数据，输出一个整数表示答案，满足条件的九条可怜的牌数。答案可能很大，请对 $998244353$ 取模输出。

**注意**，在这题中我们不考虑花色，如果两种手牌的数码组成完全相同，但是花色不同，他们也是会被视为同一种的。

## 样例

### 样例输入 #1
```
556789TJJQKKAA22w
456789TJJQKKAA22w
456789TJQKKKAAA22
```
### 样例输出 #1
```
193483
0
613897
```
## 提示


因为种种原因，本题采用捆绑测试，一共有 $3$ 个 subtask:

| 子问题编号 |  分值  |       约定       |
| :---: | :--: | :------------: |
|   1   | $30$ | 每一种牌最多出现 $2$ 次 |
|   2   | $30$ | 每一种牌最多出现 $3$ 次 |
|   3   | $40$ | 每一种牌最多出现 $4$ 次 |

时间限制：2s 

空间限制：512M


---

---
title: "[SNOI2019] 纸牌"
layout: "post"
diff: 省选/NOI-
pid: P5371
tag: ['2019', '各省省选']
---
# [SNOI2019] 纸牌
## 题目描述

有一副纸牌。牌一共有 $n$ 种，分别标有 $1,2,...,n$ ，每种有 $C$ 张。故这副牌总共有 $nC$ 张。

三张连号的牌 $(i,i+1,i+2)$ 或三张相同的牌 $(i,i,i)$ 可以组成一**叠**。如果一组牌可以分成若干（包括零）**叠**，就称其为一组**王牌**。

你从牌堆中摸了一些初始牌。现在你想挑出一些牌组成一组王牌，请问有多少种可能组成的王牌呢？答案对 $998244353$ 取模。

两组牌相同当且仅当它们含有的每一种牌数量都相同。
## 输入格式

第 $1$ 行两个整数 $n,C$ 表示牌的种类数和每种的张数；

第 $2$ 行一个整数 $X$ 表示初始牌的种类数；

接下来 $X$ 行每行两个整数 $k_i,a_i$ ，表示初始牌中有 $a_i$ 张 $k_i$ 号牌。每行的 $k_i$ 依次递增。
## 输出格式

输出 $1$ 行 $1$ 个自然数表示答案，对 $998244353$ 取模。
## 样例

### 样例输入 #1
```
3 3
0
```
### 样例输出 #1
```
10
```
### 样例输入 #2
```
9 4
9
1 3
2 1
3 1
4 1
5 1
6 1
7 1
8 1
9 3
```
### 样例输出 #2
```
3521
```
## 提示

### 样例解释1

所有方案如下：

1. $\{\}$ （不选任何牌）
2. $\{1,1,1\}$
3. $\{2,2,2\}$
4. $\{3,3,3\}$
5. $\{1,2,3\}$
6. $\{1,1,1,2,2,2\}$
7. $\{1,1,1,3,3,3\}$
8. $\{2,2,2,3,3,3\}$
9. $\{1,1,2,2,3,3\}$
10. $\{1,1,1,2,2,2,3,3,3\}$

### 数据范围

对于所有数据， $1\leq n\leq 10^{18},0\leq a_i\leq C\leq 1000,0\leq X\leq 1000$ 。注意 $a_i$ 和 $C$ 可能为 $0$ 。

- 对于 $20\%$ 的数据， $n=9,C=4$ 。
- 对于另外 $15\%$ 的数据， $n\leq 10^5,C=2$ 。
- 对于另外 $15\%$ 的数据， $X\leq 5,C\leq 10$ 。
- 对于另外 $10\%$ 的数据， $X=0$ 。
- 对于另外 $20\%$ 的数据， $n\leq 10^5$ 。
- 对于余下 $20\%$ 的数据，无特殊限制。


---

---
title: "[SNOI2019] 积木"
layout: "post"
diff: 省选/NOI-
pid: P5372
tag: ['2019', '各省省选', 'Special Judge']
---
# [SNOI2019] 积木
## 题目描述

有一块 $n$ 行 $m$ 列的网格板， $n,m$ 都是奇数。网格上平铺着一些 $1\times 2$ 的积木。积木可以旋转，不能重叠。这些积木共有 $\frac{nm-1}{2}$ 块，也就是说，网格板上只有一格的空位。

你可以做两种操作：

1. 将一块与空白格相邻（指有公共边）的积木旋转 $90^\circ$ 到空白格中；
2. 将一块与空白格积木相邻的积木平移至空白格中。

如图所示（被移动的积木颜色较浅）：

![](https://cdn.luogu.com.cn/upload/pic/58669.png)

请你用以上两种操作将给定的网格板变换为指定的状态。
## 输入格式

第一行两个正奇数 $n,m$ ，分别表示网格的行数和列数。

接下来 $n$ 行，每行 $m$ 个字符，描述网格板的初始状态：

- `<`表示这个格子是一块积木的左半部分；
- `>`表示这个格子是一块积木的右半部分；
- `n`表示这个格子是一块积木的上半部分；
- `u`表示这个格子是一块积木的下半部分；
- `o`表示这个格子是空的。

接下来另外 $n$ 行，每行 $m$ 个字符，描述你需要将网格板变成的目标状态，格式同上。


## 输出格式

你需要输出一个字符串，按顺序表示你的操作：

- `L`表示你移动了空白格左侧的积木；
- `R`表示你移动了空白格右侧的积木；
- `U`表示你移动了空白格上方的积木；
- `D`表示你移动了空白格下方的积木。

当然，没有操作的话输出空串就好了。


## 样例

### 样例输入 #1
```
3 3
nnn
uuu
o<>
<>n
<>u
<>o
```
### 样例输出 #1
```
URLR
```
### 样例输入 #2
```
5 5
n<><>
un<>n
nuonu
u<>un
<><>u
<><>o
<><>n
<><>u
<><>n
<><>u
```
### 样例输出 #2
```
RLLRLRR
```
## 提示

#### 数据范围与说明

你输出的操作序列长度不能超过 $8\times 10^6$ 。

对于所有数据， $1\leq n,m\leq 2000$ 。

- 对于 $10\%$ 的数据， $n,m\leq 3$ ；
- 对于另外 $10\%$ 的数据， $n,m\leq 5$ ；
- 对于另外 $20\%$ 的数据， $m=3$ ；
- 对于另外 $20\%$ 的数据， $n,m\leq 50$ ；
- 对于另外 $20\%$ 的数据， $n,m\leq 200$ ；
- 对于余下 $20\%$ 的数据，无特殊限制。

#### SPJ 说明

参考 https://www.luogu.org/discuss/show/114298 ，感谢 @M_sea 的贡献。


---

---
title: "缩小社交圈"
layout: "post"
diff: 省选/NOI-
pid: P5464
tag: ['洛谷月赛']
---
# 缩小社交圈
## 题目描述

社交圈子里有 $n$ 个人，每个人都有一个 SAN 值范围 $[l_i,r_i]$。当两个人的 SAN 值交集不为空时，这两个人有 PY 关系。

现在希望从社交圈子里面挑选出一些人组成一个集合 $S$，如果将所有集合内的人中有 PY 关系的那一对人都连上边，则 $S$ 刚好成为一个树（森林不行哦）。

请问，有多少种可以选择的方案？由于答案可能很大，请对 $10^{9}+7$ 取模。
## 输入格式

第一行一个整数 $n$。

接下来 $n$ 行，每行 2 个整数，表示这个人的 SAN 值区间。
## 输出格式

一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
3
1 5
2 7
4 8

```
### 样例输出 #1
```
6
```
## 提示

对于20%的数据，满足 $n \leq 18$ 。

对于40%的数据，满足 $n \leq 50$

对于60%的数据，满足 $n \leq 200$

对于100%的数据，满足 $n \leq 2000,1 \leq l_{i} <r_{i} \leq 4000 $



---

---
title: "[PKUSC2018] 星际穿越"
layout: "post"
diff: 省选/NOI-
pid: P5465
tag: ['2018']
---
# [PKUSC2018] 星际穿越
## 题目描述

有 $n$ 个星球，它们的编号是 1 到 $n$，它们坐落在同一个星系内，这个星系可以抽象为一条数轴，每个星球都是数轴上的一个点，特别地，编号为 $i$ 的星球的坐标是 $i$。

一开始，由于科技上的原因，这 $n$ 个星球的居民之间无法进行交流，因此他们也不知道彼此的存在。现在，这些星球独立发展出了星际穿越与星际交流的工具。对于第 $i$ 个星球，他通过发射强力信号，成功地与编号在 $[l_i,i-1]$ 的所有星球取得了联系(编号为 1 的星球没有发出任何信号)，取得联系的两个星球会建立 **双向** 的传送门，对于建立了传送门的两个星球 $u,v$，$u$ 上的居民可以花费 1 单位时间传送到 $v$，$v$ 上的居民也可以花费 1 单位时间传送到 $u$ ，我们用 $dist(x,y)$ 表示从编号为 $x$ 的星球出发，通过一系列星球间的传送门，传送到编号为 $y$ 的星球最少需要花费的时间。

现在有 $q$ 个星际商人，第 $i$ 个商人初始所在的位置是 $x_i$, 他的目的地是 $[l_i,r_i]$ 中的其中一个星球，保证 $l_i<r_i<x_i$ 。他会在这些星球中等概率挑选一个星球 $y$ (每个星球都有一样的概率被选中作为目的地)，然后通过一系列星球的传送门，**花费最少的时间**到达星球 $y$ 。商人想知道他花费的期望时间是多少？也就是计算 $\frac{1}{r_i-l_i+1}{\sum_{y=l_i}^{r_i}{dist(x_i,y)}}$ 。

## 输入格式

第一行一个正整数 $n$ ，表示星球的个数。

第二行 $n-1$ 个正整数，第 $i$ 个正整数为  $l_{i+1}$ ，表示编号在 $[l_{i+1},i]$ 区间内所有星球已经与编号为 $i+1$ 的星球取得了联系，并且可以通过花费 1 单位进行彼此的传输。保证 $l_{i+1}\leq i$

第三行一个正整数 $q$ ，表示询问组数。

接下来 $q$ 行，每行三个数字 $l_i,r_i,x_i$ ，表示在 $[l_i,r_i]$ 这个区间中等概率选择一个星球 $y$，$dist(x_i,y)$ 的期望。保证 $l_i<r_i<x_i$

## 输出格式

对于每组询问，注意到答案必然是一个有理数，因此以 $p/q$ 的格式输出这个有理数，要求 $\gcd(p,q)=1$ 。

如果答案为整数 $m$ ，输出 $m/1$ 。
## 样例

### 样例输入 #1
```
7
1 1 2 1 4 6
5
3 4 6
1 5 7
1 2 4
1 2 6
1 3 5
```
### 样例输出 #1
```
3/2
13/5
3/2
2/1
1/1
```
## 提示

样例对应的无向图如下：![ex](https://cdn.luogu.com.cn/upload/pic/63831.png)

对于 $20\%$ 的数据，满足 $n \leq 100$。

对于另 $25\%$ 的数据，满足 $n\leq 2000$

对于另 $25\%$ 的数据，满足 $n\leq 5000$

对于 $100\%$ 的数据，满足 $n,q\leq 3\times 10^5$


---

---
title: "[PKUSC2018] 神仙的游戏"
layout: "post"
diff: 省选/NOI-
pid: P5466
tag: ['2018']
---
# [PKUSC2018] 神仙的游戏
## 题目描述

小 D 和小 H 是两位神仙。他们经常在一起玩神仙才会玩的一些游戏，比如 “口算一个 4 位数是不是完全平方数” 。

今天他们发现了一种新的游戏：首先称 $s$ 长度为 $len$ 的前缀成为 border 当且仅当 $s[1\dots len ] = s[|s|-len + 1\dots |s|]$ 。给出一个由 $\texttt{01?}$ 组成的字符串 $s$，将 $s$ 中的问号用 $\texttt{01}$ 替换，对每个 $len$ 口算是否存在替换问号的方案使得 $s$ 长度为 $len$ 的前缀成为 border，把这个结果记做 $f(len)\in \{0,1\}$。如果 $s$ 长度为 $len$ 的前缀能够成为 border 那么 $f(len) = 1$，否则 $f(len) = 0$。

由于小 D 和小 H 是神仙，所以他们计算的 $s$ 的长度很长，因此把计算的结果一一比对会花费很长的时间。为了方便比对，他们规定了一个校验值：$(f(1)\times 1^2)~\operatorname{xor}~(f(2)\times 2^2)~\operatorname{xor}~(f(3)\times 3^2)~\operatorname{xor}~\dots~\operatorname{xor}~(f(n)\times n^2)$ 来校验他们的答案是否相同。$\operatorname{xor}$ 表示按位异或。但是不巧，在某一次游戏中，他们口算出的校验值并不一样，他们希望你帮助他们来计算一个正确的校验值。当然，他们不强迫你口算，可以编程解决。

## 输入格式

一个串 $s$，保证每个字符都是 $\texttt 0$，$\texttt 1$ 或者 $\texttt ?$。
## 输出格式

输出字符串的校验值， 即 $(f(1)\times 1^2)~\operatorname{xor}~(f(2)\times 2^2)~\operatorname{xor}~(f(3)\times 3^2)~\operatorname{xor}~\dots~\operatorname{xor}~(f(n)\times n^2)$。
## 样例

### 样例输入 #1
```
1?0?
```
### 样例输出 #1
```
17
```
## 提示

### 样例解释

将问号填充为 1001，则这个串有长度为 1 的 border, 故 $f(1) = 1$。

将问号填充为 1101，则这个串有长度为 4 的 border, 故 $f(4) = 1$。

对于 $f(2)$ 和 $f(3)$，可以枚举填充的字符是什么来证明他们的值是 0。

故答案是 $1^2~\operatorname{xor}~4^2=17$。

### 数据范围

| 子任务编号 |        $\lvert s \rvert$         |         附加说明         | 分数 |
| :--------: | :------------------: | :----------------------: | :--: |
|     1      |     $\leq 1000$      |            无            |  8   |
|     2      | $\leq 5 \times 10^5$ |     输入的串没有问号     |  10  |
|     3      | $\leq 5\times 10^5$  |         数据随机         |  22  |
|     4      | $\leq 5\times 10^5$  | 问号个数至少是 $\lvert s \rvert -5000$ |  27  |
|     5      | $\leq 5\times 10^5$  |            无            |  33  |



---

---
title: "[PKUSC2018] PKUSC"
layout: "post"
diff: 省选/NOI-
pid: P5467
tag: ['2018']
---
# [PKUSC2018] PKUSC
## 题目描述

九条可怜是一个爱玩游戏的女孩子。

最近她在玩一个无双割草类的游戏，平面上有 $n$ 个敌人，每一个敌人的坐标为 $x_i,y_i$。可怜有一个技能是在平面上画一个 $m$ 个点的简单多边形，并消灭所有**严格**在多边形内部的敌人。

不难发现如果想要快速的消灭敌人的话，只要画一个足够大的简单多边形就行了。但是这样的游戏性就太差了。于是可怜打算为游戏增加一定的随机性。

可怜在平面上随便画了一个 $m$ 个点的简单多边形 $(a_i,b_i)$。接下来可怜打算按照 $[-\pi,\pi)$ 上的均匀分布随机选取数字 $\alpha$（可以理解为等概率选取），并把这个简单多边形绕原点逆时针旋转 $\alpha$ 的角度（弧度制）。

现在可怜给你了每一个点的坐标，多边形的坐标，你的任务是帮助可怜计算在随机旋转后她期望可以消灭多少个敌人。
## 输入格式

第一行四个整数 $n,m$。

接下来 $n$ 行每行两个整数 $x_i,y_i$ 描述了一个敌人的坐标。

接下来 $m$ 行每行两个整数 $a_i,b_i$ 按照逆时针的顺序描述了简单多边形的每一个顶点。
## 输出格式

输出一行一个整数表示期望值，保留五位小数。同时保证所有数据的小数点后第 $6$ 位在舍入前不会是 $4$ 和 $5$。
## 样例

### 样例输入 #1
```
4 4
0 0
1 0
-1 -1
0 1
0 0
1 0
1 1
0 1

```
### 样例输出 #1
```
0.50000

```
## 提示

### 样例解释

如果你对概率与期望不怎么了解，这儿给出一些 Hint:

1. 设 $P_i$ 为旋转之后恰好能消灭 $i$ 个敌人的概率，那么期望就是 $\sum_{i=1}^n iP_i$.
2. 计算 $P_i$ 的一个方法是，在所有 $[-\pi,\pi)$ 范围内的旋转角度中，旋转后恰好消灭 $i$ 个敌人的角度构成了 $t_i$ 个区间 $(l_j,r_j)$（开闭不影响），那么 $P_i=\frac{\sum_{j=1}^{t_i}(r_j-l_j)}{2\pi}$.

在这题中：能消灭 $0$ 个敌人的区间是 $[\frac{\pi}{2},\pi),[-\pi,-\frac{\pi}{2}]$，能消灭 $1$ 个敌人的区间是 $(-\frac{\pi}{2},0),(0,\frac{\pi}{2})$。于是 $P_0 = P_1=\frac{1}{2}$。所以答案为 $\frac{1}{2}=0.50000$.

### 数据范围

对于 $30\%$ 的数据，$n,m \leq 15$。

对于另外 $30\%$ 的数据，选择的简单多边形是一个凸多边形。

对于 $100\%$ 的数据，$n \leq 200, m \leq 500, |x|,|y| \leq 10^6$.


---

---
title: "[NOI2019] 弹跳"
layout: "post"
diff: 省选/NOI-
pid: P5471
tag: ['2019', 'NOI', 'O2优化']
---
# [NOI2019] 弹跳
## 题目背景

原题时限 2s

内存 128MB
## 题目描述

跳蚤国有 $n$ 座城市，分别编号为 $1 - n$，$1$ 号城市为首都。所有城市分布在一个$w \times h$ 范围的网格上。每座城市都有一个整数坐标 $(x, y) (1 \leq x \leq w, 1 \leq y \leq h)$，不同城市的坐标不相同。

在跳蚤国中共有 $m$ 个弹跳装置，分别编号为 $1 - m$，其中 $i$ 号弹跳装置位于 $p_i$ 号城市，并具有参数 $t_i, L_i, R_i, D_i, U_i$。利用该弹跳装置，跳蚤可花费 $t_i (t_i > 0)$ 个单位时间，从 $p_i$ 号城市跳至坐标满足 $L_i \leq x \leq R_i, D_i \leq y \leq U_i (1 \leq L_i \leq R_i \leq w, 1 \leq D_i \leq U_i \leq h)$ 的任意一座城市。需要注意的是，一座城市中可能存在多个弹跳装置，也可能没有弹跳装置。

由于城市间距离较远，跳蚤们必须依靠弹跳装置出行。具体来说，一次出行将经过
若干座城市，依次经过的城市的编号可用序列 $a_0, a_1, \cdots , a_k$ 表示；在此次出行中，依次利用的弹跳装置的编号可用序列 $b_1, b_2, \cdots , b_k$ 表示。其中每座城市可在序列 $\{a_j\}$ 中出现任意次，每个弹跳装置也可在序列 $\{b_j\}$ 中出现任意次，且满足，对于每个 $j (1 \leq j \leq k)$，编号为 $b_j$ 的弹跳装置位于城市 $a_{j-1}$，且跳蚤能通过该弹跳装置跳至城市 $a_j$。我们称这是一次从城市 $a_0$ 到城市 $a_k$ 的出行，其进行了 $k$ 次弹跳，共花费 $\sum^k_{i=1} t_{b_{i}}$ 个单位时间。

现在跳蚤国王想知道，对于跳蚤国除首都（$1$ 号城市）外的每座城市，从首都出发，到达该城市最少需要花费的单位时间。跳蚤国王保证，对每座城市，均存在从首都到它的出行方案。

## 输入格式

第一行包含四个整数 $n, m,w, h$，变量的具体意义见题目描述。

接下来 $n$ 行，第 $i$ 行包含两个整数 $x_i, y_i$，表示 $i$ 号城市的坐标。

接下来 $m$ 行，第 $i$ 行包含六个整数 $p_i, t_i, L_i, R_i, D_i, U_i$，分别表示 $i$ 号弹跳装置所在的城市编号、弹跳所需的时间、可到达的矩形范围。这些整数的具体意义见题目描述。
## 输出格式

输出 $n - 1$ 行，第 $i$ 行包含一个整数，表示从跳蚤国首都到 $i + 1$ 号城市最少需要花费的单位时间。

## 样例

### 样例输入 #1
```
5 3 5 5
1 1
3 1
4 1
2 2
3 3
1 123 1 5 1 5
1 50 1 5 1 1
3 10 2 2 2 2
```
### 样例输出 #1
```
50
50
60
123

```
## 提示

### 更多样例

您可以通过附加文件获得更多样例。

#### 样例 2

见附加文件中的 `jump/jump2.in` 与 `jump/jump2.ans`。

这组样例的数据范围为 $n = 10^4 , m = 2\times 10^4 , w = 10^4 , h = 1$。

#### 样例 3

见附加文件中的 `jump/jump3.in` 与 `jump/jump3.ans`。

这组样例的数据范围为 $n = 10^4 , m = 2\times 10^4 , w = 10^4 , h = 10^4$。

### 数据范围

对于所有测试点和样例满足：

$1 \leq n \leq 70000 , 1 \leq m \leq 150000 , 1 \leq w, h \leq n , 1 \leq t_i \leq 10000$。

每个测试点的具体限制见下表。

| 测试点编号 | $1\le n\le$ | $1\le m\le$ | 特殊限制 |
| :----------: | :----------: | :----------: | :----------: |
| $1\sim8$ | $100$ | $100$ | 无 |
| $9\sim13$ | $5\times 10^4$ | $10^5$ | 每个弹跳装置恰好可达一座城市，且 $L_i=R_i$，$D_i=U_i$ |
| $14\sim18$ | $5\times 10^4$ | $10^5$ | $h=1$ | 
| $19\sim22$ | $2.5\times 10^4$ | $5\times 10^4$ | 无 | 
| $23\sim25$ | $7\times 10^4$ | $1.5\times 10^5$ | 无 | 


---

---
title: "[BJOI2015] 骑士的旅行"
layout: "post"
diff: 省选/NOI-
pid: P5478
tag: ['2015', '各省省选', '北京', 'O2优化']
---
# [BJOI2015] 骑士的旅行
## 题目背景

在一片古老的土地上，有一个繁荣的文明。

这片大地几乎被森林覆盖，有N座城坐落其中。巧合的是，这N座城由恰好N-1条双向道路连接起来，使得任意两座城都是连通的。也就是说，这些城形成了树的结构，任意两座城之间有且仅有一条简单路径。

在这个文明中，骑士是尤其受到尊崇的职业。任何一名骑士，都是其家族乃至家乡的荣耀。Henry从小就渴望成为一名能守护家乡、驱逐敌人的骑士。勤奋训练许多年后，Henry终于满18岁了。他决定离开家乡，向那些成名已久的骑士们发起挑战！

## 题目描述

根据Henry的调查，大陆上一共有 $M$ 名受封骑士，不妨编号为 $1$ 到 $M$。第 $i$ 个骑士居住在城 $P_i$，武力值为 $F_i$。

Henry计划进行若干次旅行，每次从某座城出发沿着唯一的简单路径前往另一座城，同时会挑战路线上武力值最高的 $K$ 个骑士（Henry的体力有限，为了提高水平，当然要挑战最强的骑士）。如果路线上的骑士不足 $K$ 人，Henry会挑战遇到的所有人。

每次旅行前，可能会有某些骑士的武力值或定居地发生变化，Henry自然会打听消息，并对计划做出调整。

为了在每次旅行时做好充分准备，Henry希望你能帮忙在每次旅行前计算出这条路线上他将挑战哪些对手。
## 输入格式

第一行，一个整数 $N$ ，表示有 $N$ 座城，编号为 $1 \sim N$。

接下来 $N-1$ 行，每行两个整数 $u_i$ 和 $v_i$，表示城 $u_i$ 和城 $v_i$ 之间有一条道路相连。

第 $N+1$ 行，一个整数 $M$，表示有 $M$ 个骑士。

接下来M行，每行两个整数 $F_i$ 和 $P_i$ 。按顺序依次表示编号为 $1 \sim M$ 的每名骑士的武力值和居住地。

第 $N+M+2$ 行，两个整数 $Q,~K$，分别表示操作次数和每次旅行挑战的骑士数目上限。

接下来 $Q$ 行，每行三个整数 $T_i,~X_i,~Y_i$ 。$T_i$ 取值范围为 $\{1,~2,~3\}$，表示操作类型。

一共有以下三种类型的操作：

$T_i=1$ 时表示一次旅行，Henry将从城 $X_i$ 出发前往城市 $Y_i$；

$T_i=2$ 时表示编号为 $X_i$ 的骑士的居住地搬到城 $Y_i$；

$T_i=3$ 时表示编号为 $X_i$ 的骑士的武力值修正为 $Y_i$。
## 输出格式

输出若干行，依次为每个旅行的答案。

对每个 $T_i=1$ 的询问，输出一行，按从大到小的顺序输出Henry在这次旅行中挑战的

所有骑士的武力值。如果路线上没有骑士，输出一行，为一个整数 $-1$。
## 样例

### 样例输入 #1
```
5  
1 2  
1 3  
2 4  
2 5  
4  
10 1  
6 1  
14 5  
7 3  
5 3  
1 2 3  
1 5 3  
1 4 4  
2 1 4  
1 2 3
```
### 样例输出 #1
```
10 7 6  
14 10 7  
-1  
7 6
```
## 提示

100%的数据中，$1 \leq N,~M \leq 40,000,~1 \leq Ui,~Vi,~Pi \leq N,~1\leq Q \leq 80,000,~1 \leq K \leq 20$，旅行次数不超过 40,000 次，武力值为不超过1,000的正整数。


---

---
title: "[BJOI2015] 隐身术"
layout: "post"
diff: 省选/NOI-
pid: P5479
tag: ['2015', '各省省选', '北京']
---
# [BJOI2015] 隐身术
## 题目描述

给定两个串$A$、$B$。请问$~B~$中有多少个非空子串和$~A~$的编辑距离不超过$K$？

所谓“子串”，指的是$~B~$中连续的一段。不同位置的内容相同的子串算作多个。两个串之间的“编辑距离”指的是把一个串变成另一个串需要的最小的操作次数，每次操作可以插入、删除或者替换一个字符。
## 输入格式

第一行一个非负整数$K$。接下来两行，每行一个由大写字母组成的字符
串，分别表示$~A~$和$~B~$。
## 输出格式

输出一行一个整数，表示所求答案。
## 样例

### 样例输入 #1
```
1
AAA
AABBAAB
```
### 样例输出 #1
```
5
```
## 提示

对$100\%$的数据，$K\leq5$，两个字符串均非空，长度和小于$10^5$。


---

---
title: "[PKUWC2018] 随机算法"
layout: "post"
diff: 省选/NOI-
pid: P5492
tag: ['2018']
---
# [PKUWC2018] 随机算法
## 题目描述

我们知道，求任意图的最大独立集是一类NP完全问题，目前还没有准确的多项式算法，但是有许多多项式复杂度的近似算法。

例如，小 C 常用的一种算法是：

1. 对于一个 $n$ 个点的无向图，先等概率随机一个 $1\ldots n$ 的排列 $p[1\ldots n]$。

2. 维护答案集合 $S$ ，一开始 $S$ 为空集，之后按照 $i=1\ldots n$ 的顺序，检查 $\{p[i]\}\cup S$ 是否是一个独立集，如果是的话就令 $S=\{p[i]\}\cup S$。

3. 最后得到一个独立集 $S$ 作为答案。

小 C 现在想知道，对于给定的一张图，这个算法的正确率，输出答案对 $998244353$ 取模。
## 输入格式

第一行两个非负整数 $n,m$ 表示给定的图的点数和边数。

接下来 $m$ 行，每行有两个正整数 $(u,v) (u\neq v)$ 描述这张图的一条无向边。
## 输出格式

输出正确率，答案对 $998244353$ 取模。
## 样例

### 样例输入 #1
```
3 2
1 2
2 3
```
### 样例输出 #1
```
665496236
```
## 提示

#### 样例解释
这张图的最大独立集显然为 $2$，可以发现只有 $p[1]=2$ 时会得出 $S=\{2\}$，否则都是 $S=\{1,3\}$，所以答案是 $\frac{2}{3}$。


#### 数据范围
对于 $10\%$ 的数据，有$1\leq n\leq 9$。

对于 $30\%$ 的数据，有$1\leq n\leq 13$。

对于 $50\%$ 的数据，有$1\leq n\leq 17$。

另有 $10\%$ 的数据，满足给定的图是一条链。

另有 $10\%$ 的数据，满足给定的图是一棵树。

对于 $100\%$ 的数据，有$1\leq n\leq 20$，$0\leq m\leq \frac{n\times (n-1)}{2}$，保证给定的图没有重边和自环。


---

---
title: "[LnOI2019] 真正的 OIer 从不女装"
layout: "post"
diff: 省选/NOI-
pid: P5500
tag: []
---
# [LnOI2019] 真正的 OIer 从不女装
## 题目背景

题目提供者：朝田诗乃

众所周知，女装只有零次和无数次。
## 题目描述

给定一个长度为 $n$ 的序列 $a$。

有如下定义：若一个序列中所有数字都一样，那么这个序列被称作“诗乃序列”。

对于每次询问，给定 $l$ 和 $r$，求序列 $a$ 中**左右端点都在 $[l,r]$ 中**的最长“诗乃序列”长度。

这题难倒了 Abbi。Abbi 决定女装。当 Abbi 女装时，序列会出现神奇的变化：它可以**在询问的区间 $[l,r]$ 中**挑一个它喜欢的位置 $p$，将区间 $[l,p]$ 和 $(p,r]$ **分别**翻转。

Abbi 想知道，**最多**进行 $k$ 次女装后（可选择进行不足 $k$ 次或不进行女装），能得到的最长的“诗乃序列”的长度是多少？
## 输入格式

第一行，$n$、$m$，表示序列长度和操作个数。

第二行，$n$ 个数，第$i$个数表示序列初始值 $a_i$。

接下来 $m$ 行，每行描述一个操作，格式如下：

1. $R$ $l$ $r$ $x$：表示将区间 $[l,r]$ 上的数字全部变成 $x$。
2. $Q$ $l$ $r$ $k$：表示询问在 $[l,r]$ 中进行最多 $k$ 次女装所能得到的最长“诗乃序列”长度。

**注意：询问独立，即每次询问后会将序列复原，不实际执行反转操作。**
## 输出格式

对于每个 Q 操作，输出询问答案。
## 样例

### 样例输入 #1
```
10 4
3 3 3 3 2 3 3 3 2 2
Q 1 6 1
Q 1 6 0
R 8 8 2
Q 5 10 1
```
### 样例输出 #1
```
5
4
4
```
## 提示

**时空限制**：1s/512MB。

**数据范围：**

- 对于 $20\%$ 的数据，$1 ≤ n,m ≤ 100$。
- 对于另外 $10\%$ 数据，所有询问的 $k=0$。
- 对于另外 $10\%$ 数据，没有 R 操作。
- 对于 $100\%$ 的数据，$1≤n,m≤200000$，$0≤k≤1000$，$1≤a_i,x≤10^9$，$1≤l≤r≤n$。

特殊限制：对于后 $80\%$ 的数据，保证能卡飞 ODT。

**样例解释：**

对于第一次询问，询问的区间为：

```
3 3 3 3 2 3
```

女装 $1$ 次，将区间 $[1,4]$ 和 $[5,6]$ 分别翻转，得到：

```
3 3 3 3 3 2
```

此时可得到最长“诗乃序列”，长度为 $5$。可以证明没有别的女装方法能得到更长的“诗乃序列”。

此后询问以此类推。

**建议使用读入优化。**


---

---
title: "[JSOI2011] 柠檬"
layout: "post"
diff: 省选/NOI-
pid: P5504
tag: ['2011', '江苏']
---
# [JSOI2011] 柠檬
## 题目描述

$\text{Flute}$ 很喜欢柠檬。它准备了一串用树枝串起来的贝壳，打算用一种魔法把贝壳变成柠檬。贝壳一共有 $n$ $(1≤n≤100000)$ 只，按顺序串在树枝上。为了方便，我们从左到右给贝壳编号 $1..n$ 。每只贝壳的大小不一定相同，贝壳 $i$ 的大小为 $s_i(1≤s_i≤10000)$ 。

变柠檬的魔法要求$:\ \text{Flute}$ 每次从树枝一端取下一小段连续的贝壳，并选择一种贝壳的大小 $s_0$。如果这一小段贝壳中大小为 $s_0$ 的贝壳有 $t$ 只，那么魔法可以把这一小段贝壳变成 $s_0t^2$ 只柠檬。$\text{Flute}$ 可以取任意多次贝壳，直到树枝上的贝壳被全部取完。各个小段中，$\text{Flute}$ 选择的贝壳大小 $s_0$ 可以不同。而最终 $\text{Flute}$ 得到的柠檬数，就是所有小段柠檬数的总和。

$\text{Flute}$ 想知道，它最多能用这一串贝壳
变出多少柠檬。请你帮忙解决这个问题。
## 输入格式

第 $1$ 行：一个整数，表示 $n$ 。
第 $2..n+1$ 行：每行一个整数，第 $i+1$ 行表示 $s_i$。
## 输出格式

仅一个整数，表示 $\text{Flute}$ 最多能得到的柠檬数。
## 样例

### 样例输入 #1
```
5
2
2
5
2
3
```
### 样例输出 #1
```
21
```
## 提示

$\text{Flute}$ 先从左端取下 $4$ 只贝壳，它们的大小为 $2, 2, 5, 2$。选择 $s_0=2$，那么这一段里有 $3$ 只大小为 $s_0$ 的贝壳，通过魔法可以得到 $2×3^2 = 18$ 只柠檬。再从右端取下最后一只贝壳，通过魔法可以得到 $3×1^2 = 3$ 只柠檬。总共可以得到 $18+3=21$ 只柠檬。没有比这更优的方案了。


---

---
title: "[CEOI 2013] Board"
layout: "post"
diff: 省选/NOI-
pid: P5513
tag: ['2013', 'CEOI（中欧）']
---
# [CEOI 2013] Board
## 题目描述

给出这样一棵“二叉树”:
 - 每个节点有左右两个儿子，并如下定义每个节点的高度：假设父亲节点的高度为 $h$，那么他的两个儿子的节点的高度都是 $h+1$，相同高度的所有节点称作一层。

 - 每个节点的左儿子的子树都在右儿子的子树的左边，每一层相邻的两个节点之间有一条边。 下面是一个例子：

![](https://cdn.luogu.com.cn/upload/pic/74384.png)

每一条图上的路径用一个字符串表示，字符串中的每一个字符表示一 个移动。字符仅包含如下五种：

 - $\tt 1$：表示移动到当前节点的左儿子 
 - $\tt 2$：表示移动到当前节点的右儿子
 - $\tt U$：表示移动到当前节点的父亲节点 
 - $\tt L$：表示移动到当前节点同层的左边的节点（保证当前节点在这一层中不是最左边的节点）
 - $\tt R$：表示移动到当前节点同层的右边的节点（保证当前节点在这一层中不是最右边的节点）

 用一条路径来表示这条路径的终点，例如路径：$\tt  221LU$ 就表示上图中的节点 $A$。 给出两条路径，你的任务是求出着两条路径的终点之间的最短路。
## 输入格式

输入两行，每行一个字符串，分别表示两条路径。
## 输出格式

输出一行，表示两个节点之间的最短路。
## 样例

### 样例输入 #1
```
221LU
12L2
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
111RRRRRRR
222
```
### 样例输出 #2
```
0
```
### 样例输入 #3
```
11111
222222
```
### 样例输出 #3
```
10
```
## 提示

用 $D$ 表示所有经过的节点中，深度最大的节点的深度；$S$ 表示输入字符串的最大长度。 

- 对于 $10\%$ 的数据，$D \leq 10$;
- 对于 $30\%$ 的数据，$D \leq 50$;
- 对于 $50\%$ 的数据，$D \leq 10^3$;
- 对于 $70\%$ 的数据，$D\leq 2 \times 10^4$; 
- 对于 $100\%$ 的数据，$D \leq 10^5, S \leq 10^5$。


---

---
title: "篮球统计"
layout: "post"
diff: 省选/NOI-
pid: P5554
tag: ['Special Judge']
---
# 篮球统计
## 题目背景

小L喜欢唱、跳、Rap和篮球。

在同一时刻，篮球场上可能会有很多个在空中的篮球，小L想统计这些篮球的信息。
## 题目描述

当一个篮球被抛到空中时，小L会记下一个时刻 $l$ ，此时这个篮球开始被小L统计；当一个篮球被接住时，小L会记下一个时刻 $r$ ，在这之后这个篮球的状态不再被小L统计。对于每个篮球，小L会计算出在时刻 $l$ 这个篮球的高度和向上的初速度。

对于一个时刻 $x$ ，小L想知道，对于所有此时还在空中的篮球，高度最高的篮球的高度是多少。

**注意** ：被发现的篮球的出现时间 $l,r$ 和小L统计信息的时刻 $x$ 均没有任何单调性。
## 输入格式

输入的第一行为一个整数 $m$ 。

接下来的 $m$ 行，每行为一个操作或询问，为以下形式之一：

1.  `add a v l r` ：小L发现了一个在空中的篮球，这个篮球在时刻 $l$ 被抛向空中，在时刻 $r$ 被接住，这个篮球在时刻 $l$ 的高度是 $a$ ，向上的初始速度为 $v$ 。

2.  `query x` ：请告诉小L，在他已经给出的信息中，在时刻 $x$ 在空中的所有篮球中最高的高度是多少。
## 输出格式

对于每个 `query` 操作，输出一行，为这个最高的高度。如果此时不存在在空中的篮球，输出 `Undefined` 。

为了减小精度误差，推荐使用 `long double` 类型存储浮点数，输出格式为 `%Lf` 。

为了避免精度问题，本题使用 **Special Judge** 。如果您的答案与标程的答案相差小于等于 $0.005$ ，则会被视为是正确的。
## 样例

### 样例输入 #1
```
5
query 1.000
add 1.000 5.000 1.000 2.000
query 1.000
query 2.000
query 1.500
```
### 样例输出 #1
```
Undefined
1.000000
1.100000
2.275000
```
## 提示

对于 $30\%$ 的数据， $m\le 5000$

对于另外 $30\%$ 的数据， $-100< l,r,x< 100$

对于 $100\%$ 的数据， $1\le m\le 100000,-1000< a,v < 1000,-10^6< l,r,x < 10^6,l\le r$ ，保证输入中所有的小数均为 $3$ 位小数。

篮球高度可能是负数。

### 小K教你学物理

本题中所有的单位均采用国际单位制。即时间单位是秒（ $s$ ），长度单位是米（ $m$ ）。

本题中取重力加速度 $g=9.8 ~ m \cdot s^{-2}$ 。

省略掉篮球横向的位移，可以将篮球的运动看做是 **竖直上抛运动** 。根据题目中给出的信息，已知篮球初始的高度 $a$ ，初速度 $v$ ，重力加速度 $g$ ， **在空中的时间**  $t$ ，则篮球在这一时刻的高度是 $-\dfrac 1 2 g t^2 + vt+a$ 。


---

---
title: "[Celeste-B] Mirror Magic"
layout: "post"
diff: 省选/NOI-
pid: P5561
tag: ['O2优化']
---
# [Celeste-B] Mirror Magic
## 题目背景

> ...

> 呼吸。

> 你能站起来，Madeline

> 想想羽毛。你能拯救 Theo
## 题目描述

镜之神庙是一座有魔力的神庙，在这里你能一窥自己心灵的真相。

Theo 被困在了一面镜子里。当 Madeline 尝试去拯救 Theo 时，神庙里的"生物"们给她出了一道难题，这道难题是这样的：

神庙的"生物"们准备了 $n$ 串草莓，这些草莓的长度之和 $<= 10^6$，现在它们可以执行这样一些操作：

$1\ x\ l\ r$，表示将编号 $x$ 的草莓串的子草莓串 $[l,r]$ 复制一份，插入当前的草莓集合中，保证草莓串 $x$ 的长度 $>=r$。

$2\ k$，表示删除第 $k$ 次操作插入的草莓串，保证第 $k$ 次操作为插入并且此时第 $k$ 次操作插入的草莓串在集合中。

"生物"们认为和谐的味道才是美味的。在执行任意一次操作之后，"生物"们想要知道当前集合中所有草莓串的美味度(即 $LCP$ - 最长公共前缀)。（若集合为空，则美味度 $0$，若集合中只有一个草莓串，则美味度为草莓串的长度）

为了方便表达，我们把每一种草莓表示为一个**小写英文字母**。

多年以后，Madeline 又来到了镜之神庙，想要回忆多年前自己的登山旅途，可是她已经不记得自己当年是怎么解决那道谜题的了，你能帮帮她找到谜题的答案吗？
## 输入格式

第一行一个正整数 $n$，表示草莓串的个数。

接下来 $n$ 行一行一个**只包含小写字母**的字符串，表示原来的 $n$ 个草莓串。

接下来一行一个正整数 $q$，表示操作个数。

接下来 $q$ 行一行一个操作。
## 输出格式

输出 $q$ 行，对应每次操作之后集合中草莓串的美味度($LCP$ - 最长公共前缀).
## 样例

### 样例输入 #1
```
3
abccccd
abccddc
acbbcad
5
1 1 1 7
1 2 1 7
1 3 1 7
2 3
2 2

```
### 样例输出 #1
```
7
4
1
4
7

```
## 提示

样例解释：

第一次操作后，集合为 $\{"abccccd"\}$,$LCP=7$

第二次操作后，集合为 $\{"abccccd","abccddc"\}$,$LCP=4$

第三次操作后，集合为 $\{"abccccd","abccddc","acbbcad"\}$,$LCP=1$

第四次删除了第三次插入的串，故 $LCP=4$

第五次删除了第二次插入的串，故 $LCP=7$

令 $len$ 等于 $n$ 个串的长度之和。总有 $len \leq 10^6$

Subtask $1$($10$ Pts), $n \leq 5, q = 10$

Subtask $2$($30$ Pts), $n \leq 10^6, q = 10^6$, 保证每次插入的是串的一个前缀

Subtask $3$($10$ Pts), $n \leq 10^6, q = 10^5$, 不含 $2$ 操作, **保证询问为随机生成**

Subtask $4$($50$ Pts), $n \leq 10^6, q = 10^6$

提示：你可以根据 $q$ 判断 Subtask 编号




---

---
title: "[Celeste-B] No More Running"
layout: "post"
diff: 省选/NOI-
pid: P5563
tag: ['O2优化']
---
# [Celeste-B] No More Running
## 题目背景

> 逃离自己内心的人，

> 永远也到达不了顶峰。

> 想要到达山顶，你能做的只有

> 不再逃避
## 题目描述

通往山顶的路上水晶遍布。

在晶簇中，Madeline 发现了一个不同寻常的水晶洞穴，洞穴中镶嵌着五彩斑斓的宝石。

经过 Madeline 的观察，她发现这些宝石形成了一个奇妙的机关，只要让宝石收集到足够的魔力，就能打开机关，拿到水晶之心。

具体来说，在这个巨大的洞穴里有着 $n$ 颗宝石，每颗宝石都被镶嵌在**形态结构完全相同**但**相互独立**的树形结构里。更具体地，在这个洞穴里有 $n$ 个相同的树形结构 $T$，树形结构 $T$ 有 $n$ 个节点，而第 $i$ 颗宝石被镶嵌到了第 $i$ 个树形结构 $T$ 的第 $i$ 号节点上。

Madeline 能够推动宝石从而让宝石在树形结构上滑动。当宝石滑过树形结构的一条边**过后**，这条边就会被关闭，并且边上储存的魔力就会被积蓄到宝石中。(再次提醒，这 $n$ 颗宝石所在的树形结构是相互独立的，这意味着在一个树形结构中一条边的封闭并不会导致在其他树形结构中这条边也被封闭)

宝石能储存的魔力是有上限的，更具体而言，每颗宝石都只能储存 $mod$ 的魔力，一旦超过这个魔力上界，宝石的魔力就会溢出，你可以认为宝石此时储存的魔力会对 $mod$ 取模。

Madeline 想要知道，镶嵌在每个顶点上的宝石最终最多能储存多少魔力，你能帮帮她吗？
## 输入格式

第一行为两个整数 $n$，$mod$，表示树形结构的节点数和 $mod$

接下来 $n-1$ 行一行三个整数 $u,v,w$，描述树形结构中一条连接 $u,v$，能量值为 $w$ 的双向边 ($0 \leq w < mod$ )。(注意，封闭一条边是双向的，这意味着你不能走回头路)

保证这些边构成了一棵树。
## 输出格式

$n$ 行 $n$ 个整数，第 $i$ 个表示镶嵌在第 $i$ 个顶点的宝石最多能储存的魔力。
## 样例

### 样例输入 #1
```
5 16
1 2 13
2 3 15
3 4 7
3 5 3

```
### 样例输出 #1
```
15
15
15
10
15
```
## 提示

![图挂了](https://i.loli.net/2019/08/30/sPwyQKUDANRCT2f.png)

"特殊约定" 中，"一条链"意味着树形结构的第 $i$ 条边连接第 $i$ 个和第 $i+1$ 个节点。

对于所有数据有 $0\leq w<mod$ 

保证输入的所有边构成一棵树

对于 $1$~$6$ 号测试点，时限为 $1s$

对于 $7$~$12$ 号测试点，时限为 $2s$

对于 $13$~$20$ 号测试点，时限为 $3s$


---

---
title: "小 O 与排列"
layout: "post"
diff: 省选/NOI-
pid: P5604
tag: ['O2优化', '洛谷月赛']
---
# 小 O 与排列
## 题目背景

小 O 是一个喜爱数学的高中生，他现在在一个与排列有关的问题上陷入了迷茫之中，快来帮帮他！

**注意输入格式有修改，第二行与第三行被调换了。（以现在的题面为准）**
## 题目描述

小 O 有一个长为 $n$ 的排列 $p$，他的好朋友 $\texttt{euei}$ 有一个长为 $n$，值域是 $[1, n]$ 的序列 $a$。

有一天，小 O 忽然想知道是否存在数对 $i, j$，满足 $l \le i, j \le r$，且 $p_{a_i} = a_j$，他轻松地解决了这个问题。但是 $\texttt{euei}$ 有些时候会修改这个序列某个位置的值，还会对多对不同的 $l, r$ 询问上面的问题，这下小 O 就不会了。

聪明的你能帮助小 O 解决这个问题吗？
## 输入格式

第一行两个正整数 $n, m$，其中 $m$ 表示修改和询问数之和。

第二行 $n$ 个正整数 $p_1, p_2, \cdots, p_n$，表示排列 $p$。

第三行 $n$ 个正整数 $a_1, a_2, \cdots, a_n$，表示初始的序列 $a$。

接下来 $m$ 行，每行三个正整数，为以下两种格式之一：

- `1 i v`，表示将 $a_i$ 修改为 $v$。
- `2 l r`，表示询问是否存在数对 $i, j$，满足 $l \le i, j \le r$，且 $p_{a_i} = a_j$。
## 输出格式

对于每个询问，如果存在，那么输出 `Yes`，否则输出 `No`。
## 样例

### 样例输入 #1
```
3 4
3 1 2
2 2 1
2 2 3
1 2 3
1 3 3
2 2 3
```
### 样例输出 #1
```
Yes
No
```
## 提示

**提示**

本题读入量较大，请使用高效的读入方式。

**样例解释**

对于第一组询问，数对 $2, 3$ 满足要求。

对于第二组询问，没有数对满足要求。

**数据范围**

本题共有 $5$ 个子任务，你需要通过一个子任务内的所有测试点才能取得这个子任务的分数。

对于所有数据，$1 \le n,m \le 5\times 10^5$，$1 \le a_i, i, v, l, r \le n$ ，$p_i \neq i$。

| #    | 分数 | $n, m$           | 特殊性质                        | 时间限制    |
| ---- | ---- | ---------------- | ------------------------------- | ----------- |
| 1    | 7    | $\leqslant 300$  |                                 | $\text{1s}$ |
| 2    | 23   | $\leqslant 2000$ |                                 | $\text{1s}$ |
| 3    | 15   |                  | 没有`1`操作                     | $\text{3s}$ |
| 4    | 15   |                  | 每次询问时序列 $a$ 都是一个排列 | $\text{3s}$ |
| 5    | 40   |                  |                                 | $\text{3s}$ |

表格中留空表示该项无特殊限制。


---

---
title: "小 A 与两位神仙"
layout: "post"
diff: 省选/NOI-
pid: P5605
tag: ['O2优化', '洛谷月赛']
---
# 小 A 与两位神仙
## 题目背景

小 A 是一个普普通通的高中生，但是他某一天忽然被卷入了神仙的游戏中，快来帮帮他！
## 题目描述

某一天，小 A 正走在放学回家的路上，忽然遇见了两个神仙造梦者和杰瑞米，祂们一看到小 A 就说要和小 A 玩游戏，小 A 被笼罩在金光中，莫名其妙就答应了祂们的要求。

这个游戏的规则是这样的：两个神仙先选定一个正整数 $m$，保证 $m$ 是一个奇质数 $p$ 的正整数次幂。然后进行 $n$ 轮游戏，每轮中造梦者选定一个正整数 $x$，杰瑞米选定一个正整数 $y$，保证 $(x, m) = 1, (y, m) = 1$，即 $x$ 与 $m$ 互质，$y$ 与 $m$ 互质，接下来询问小 A 是否存在非负整数 $a$ 使得 $x^a \equiv y \pmod{m}$。

神仙们说小 A 只有在每一轮游戏中都回答正确才能回到正常的生活中，不得已之下他只好求助于聪明的你。

## 输入格式

第一行两个正整数 $m, n$。

接下来 $n$ 行，每行两个正整数 $x, y$。
## 输出格式

一共 $n$ 行，每行对应一轮游戏中小 A 的回答。

如果存在，那么答案为 `Yes`，否则为 `No`。
## 样例

### 样例输入 #1
```
9 3
1 4
2 1
7 4
```
### 样例输出 #1
```
No
Yes
Yes
```
### 样例输入 #2
```
29788562298698657 10
4623623705787050 4128735493476588
29371111781967946 19402395181570597
23313713550468151 18155134012955455
654639695903289 323875358727922
15727861955653242 26658913688488667
10815360622718474 4625834559167483
10836636083182170 10347869939717751
8972909638986721 1887397472131862
23442032136521081 29735793306181382
325363900801763 6960017105353559

```
### 样例输出 #2
```
Yes
No
No
Yes
Yes
Yes
No
Yes
Yes
No

```
## 提示

**样例解释**

$1^a \equiv 1 \not \equiv 4 \pmod {9}$。

$2^6 \equiv 64 \equiv 1 \pmod {9}$。

$7^2 \equiv 49 \equiv 4 \pmod {9}$。

**数据范围**

本题共 $7$ 个子任务，你需要通过一个子任务内的所有测试点才能取得这个子任务的分数。

对于所有数据满足 $1\le n\le 2\times 10^4$，$3\le m \le 10^{18}$，$1 \le x, y < m$ 。

| #    | 分数 | $n$                      | $m$                 | 特殊性质1 | 时间限制 |
| ---- | ---- | ------------------------ | ------------------- | --------- | --------- |
| 1    | 3    | $\le 5$            | $\le 10^6$    | ×         |  1s |
| 2    | 37   | $\le 5$            | $\le 10^9$    | ×         | 1s |
| 3    | 22   | $= 1$                    | $\le 10^{18}$ | ×         | 1s |
| 4    | 13   | $\le 100$          | $\le 10^{18}$ | √         | 1s |
| 5    | 10   | $\le 100$          | $\le 10^{18}$ | ×         | 1s |
| 6    | 5   | $\le 2000$         | $\le 10^{18}$ | ×         | 1s |
| 7    | 10   | $\le 2\times 10^4$ | $\le 10^{18}$ | ×         | 3s |

特殊性质1：令 $m = p^{a}$，则 $p$ 是在 $[3, 10^{18}]$ 等概率选取的一个素数。

**提示**

本题可以使用 `__int128`。


---

---
title: "[SDOI2015] 道路修建"
layout: "post"
diff: 省选/NOI-
pid: P5618
tag: ['2015', '各省省选']
---
# [SDOI2015] 道路修建
## 题目描述

某国有 $2N$ 个城市，这 $2N$ 个城市构成了一个 $2$ 行 $N$ 列的方格网。现在该国政府有一个旅游发展计划，这个计划需要选定 $L$、$R$ 两列 $(L \leq  R)$，修建若干条专用道路，使得这两列之间（包括这两列）的所有 $2(R-L+1)$ 个城市中每个城市可以只通过专用道路就可以到达这 $2(R-L+1)$ 个城市中的任何一个城市。这种专用道路只能在同一行相邻两列的城市或者同一列的两个城市之间修建，且修建需要花费一定的费用。

由于该国政府决定尽量缩减开支，因此政府决定，选定 $L$、$R$ 后，只修建 $2(R-L+1)-1$ 条专用道路，使得这些专用道路构成一个树结构。现在你需要帮助该国政府写一个程序，完成这个任务。具体地，该任务包含 $M$ 个操作，每个操作的格式如下：

1. ``C x0 y0 x1 y1 w``：由于重新对第 $x_0$ 行第 $y_0$ 列的城市和第 $x_1$ 行第 $y_1$ 列的城市之间的情况进行了考察，它们之间修建一条专用道路的花费变成了 $w$；

2. ``Q L R``：若政府选定的两列分别为 $L$、$R$，询问政府的最小开支。
## 输入格式

第一行，两个整数 $N$、$M$。  

第二行，$N-1$ 个整数，其中第 $i$ 个整数表示初始时第 $1$ 行第 $i$ 列的城市和第 $1$ 行第 $i+1$ 列的城市之间修建一条专用道路的费用。  

第三行，$N-1$ 个整数，其中第 $i$ 个整数表示初始时第 $2$ 行第 $i$ 列的城市和第 $2$ 行第 $i+1$ 列的城市之间修建一条专用道路的费用。  

第四行，$N$ 个整数，其中第 $i$个整数表示初始时第 $1$ 行第 $i$ 列的城市和第 $2$ 行第 $i$ 列的城市之间修建一条专用道路的费用。  
接下来的 $M$ 行，每行一个操作。
## 输出格式

对于每个询问操作，输出一行，表示你计算出的政府的最小开支。
## 样例

### 样例输入 #1
```
3 3
1 2
2 1
3 1 2
Q 1 3
C 1 2 2 2 3
Q 2 3
```
### 样例输出 #1
```
7
5
```
## 提示

对于全部的数据，$1 \leq N, M \leq 60000$，任何时刻任何一条专用道路的修建费用不超过 $10^4$。


---

---
title: "[DBOI2019] 德丽莎世界第一可爱"
layout: "post"
diff: 省选/NOI-
pid: P5621
tag: ['2019', '洛谷原创']
---
# [DBOI2019] 德丽莎世界第一可爱
## 题目背景

```cpp
众所周知，德丽莎世界第一可爱。
——zhengrunzhe
```

你正在打崩坏$3$，突然家长来了，于是你装作在打数据结构题。

![神恩颂歌](https://cdn.luogu.com.cn/upload/pic/70922.png)
## 题目描述

有 $n$ 个崩坏兽，每个崩坏兽有五个属性值：health 生命力，energy 能量力，attack 攻击力，defense 防御力， collapse 崩坏能。

德丽莎可以任选一只崩坏兽展开攻击。假如她干掉了崩坏兽$i$ 那么她会收获 `collapse[i]` 的可爱值。由于德丽莎越战越勇，她打的下一只崩坏兽 $j$ 需要满足 `health[j]≥ health[i]` , `energy[j]≥energy[i]` , `attack[j]≥attack[i]` , `defense[j]≥defense[i]`。

请你帮帮德丽莎计算一下她能够获得的最大可爱值。
## 输入格式

第一行一个正整数$n$。

接下来$n$行，第$i+1$行五个整数`health[i]`，`energy[i]`，`attack[i]`。`defense[i]`，`collapse[i]`，代表着第 $i$ 只崩坏兽的属性值。
## 输出格式

一行一个整数，代表最大可爱值（必须击杀至少一只崩坏兽），答案保证不会超过 long long 范围（$2^{63}-1$）。
## 样例

### 样例输入 #1
```
5
1 9 3 6 233
0 8 3 7 666
-3 9 4 2 810
2 3 3 3 -100
1 8 8 9 603
```
### 样例输出 #1
```
1269
```
## 提示


Subtask #1（$20$分）： 

$1\leq n\leq 100$。

Subtask #2（$20$分）： 

$1\leq n\leq 10000$。

Subtask #3（$60$分）： 

$1\leq n\leq 50000$。

对于 $100\%$ 的数据，满足 $|\mathrm{health}_i|, |\mathrm{energy}_i|, |\mathrm{attack_i}|, |\mathrm{defense}_i| \le 10^5$，$| \mathrm{collapse}_i|\le 10^9$。

### 题目提供者：[$\color{red}{zhengrunzhe}$](https://www.luogu.org/space/show?uid=14374)


---

---
title: "[Celeste-A] Black Moonrise"
layout: "post"
diff: 省选/NOI-
pid: P5624
tag: ['O2优化']
---
# [Celeste-A] Black Moonrise
## 题目背景

> 幽灵
>
> 不属于这个世界
> 
>但因这个世界而诞生
>
>潜藏在秩序之外
>
>$$
>
> 醒来吧，我的心是堡垒
>
>在梦中我易受伤害
## 题目描述

在 Madeline 的梦境中，城市的边境是由大大小小的宇宙碎片构成的

每个宇宙碎片都有一定的能量值，由于碎片的大小有一定的差异，因此它们的能量值也有大有小

Madeline 很享受在碎片之间穿梭，她每次都会选择两个宇宙碎片，并获得它们能量值的最大公约数的愉悦值。注意这两个宇宙碎片可以相同

宇宙碎片构成了一段序列$a_1,a_2,\cdots,a_n$，每次 Madeline 都会选择它的一个区间，对于这个区间里面的任意两个宇宙碎片$(u,v)$，她都会进行一次穿梭。注意这里的$(u,v)$是有序对

形式化地，Madeline 每次获得的愉悦值为

$$\sum_{i=l}^r\sum_{j=l}^r \gcd(a_i,a_j)$$

当 Madeline 从她的梦中被唤醒时，她发现所有的宇宙碎片都消失了。她不记得在梦中每次穿梭时获得的愉悦值是多少，只依稀记得她选择的区间了。

于是她找到了你——一个信息学大佬，请你根据她每次选择的区间，还原她当时的愉悦值

## 输入格式

第一行两个正整数$n,q$，分别表示碎片个数以及询问数

第二行有$n$个正整数$a_1,a_2,\cdots,a_n$，表示每个碎片的能量值

接下来$q$行，每行两个整数$l_i,r_i$，表示第$i$次询问 Madeline 选择的区间
## 输出格式

对于每个询问输出一行，表示在这次询问中，Madeline 获得的愉悦值的总和
## 样例

### 样例输入 #1
```
5 2
1 2 3 4 5
1 2
2 3
```
### 样例输出 #1
```
5
7
```
## 提示

对于$10\%$的数据，满足$n,q\leq 200$

对于$20\%$的数据，满足$n,q\leq 2250$

对于$40\%$的数据，满足$n,q\leq 4000$

对于$100\%$的数据，满足$n,q,a_i\leq 10^5$

**保证数列和询问均为随机生成**


---

---
title: "[Celeste-A] Good Karma"
layout: "post"
diff: 省选/NOI-
pid: P5625
tag: ['O2优化']
---
# [Celeste-A] Good Karma
## 题目背景

> "我们永远不会忘记在这里的时光"

> "再也没有其他地方能让我感到平静。谢谢。"

> "很遗憾，Oshiro 先生，山庄要关门了。"

> "我会赶上他们，直到这里的一切都井然有序……"

> "在离开这个山庄之后，我应该去哪儿呢？"
## 题目描述

天空度假山庄是位于 Celeste 山半山腰上的一座山庄，这里已经被废弃许久。

当 Madeline 来到这座山庄之时，这里只剩下了一个幽灵，Oshiro 先生，独自管理这座山庄。

因为山庄有着神奇的魔力，里面凝聚着许多 Oshiro 先生不好的想法。

一个想法可能包含 $k$ 种不好的念头，诸如山庄倒闭，无人问津，无人体谅等等，每种念头对于 Oshiro 先生的重要度是不一样的，具体来讲，第 $i$ 种不好的念头对 Oshiro 先生的重要程度为 $2^{i-1}$。

有时，Oshiro 先生会抓起一堆糟糕的想法进行回忆，Oshiro 会一个一个挨着观看这些想法，并获得其中不好的念头。特别地，当 Oshiro 先生**两次看到同一种不好的念头**时，他就会认为这种念头没什么，下一瞬间就会**忘记自己曾经看到过这种念头**。

一次回忆对 Oshiro 先生的重要程度为 Oshiro 在看完这些想法之后**记住的念头**的重要程度和。

自然，在天空度假山庄里，Oshiro 先生对 Madeline 大吐苦水。

多年以后，当 Madeline 回忆她的登山之旅的时候，已经不记得 Oshiro 每个想法对于他的重要程度了，她只记得 Oshiro 先生的某几次回忆的重要程度以及天空度假山庄之中不好的想法的数量与每种想法中可能的不好的念头的数量。

你能帮助她找出有多少种合法的想法序列满足 Oshiro 先生的每次回忆吗？

特别地，一个想法也可能是一团浆糊，即里面什么都没有。
## 输入格式

第一行为三个整数 $n,q,k$，表示不好的想法的数量，Madeline 告诉了你 $q$ 条信息，以及每个想法中可能存在的不好的念头的数量。

接下来 $q$ 行，一行一条信息，首先是信息的类型 $op$。

若 $op = 0$， 则接下来是三个整数 $l,r,val$，表示 Madeline 想起在某次回忆中 Oshiro 先生抓起编号在 $[l,r]$ 区间的想法回忆，回忆结束后重要度是 $val$。

若 $op = 1$，则接下来是一个整数 $cnt$，表示 Madeline 纠正了**第 $cnt$ 条 $op = 0$ 的说法**，第 $cnt$ 条说法是她错误回忆起来的，保证第 $cnt$ 条说法存在并且没有被纠正过。(你可以认为，被纠正的说法就不再存在了)

若 $op = 2$，则你需要输出一个整数，表示有多少种合法的想法序列满足当前 Oshiro 先生的每次回忆，对 $998244353$ 取模。
## 输出格式

对于每次 $op = 2$，输出方案数，对 $998244353$ 取模。
## 样例

### 样例输入 #1
```
4 3 2
0 3 4 1
0 2 3 3
2

```
### 样例输出 #1
```
16
```
### 样例输入 #2
```
8 9 6
0 1 1 1
0 2 2 9
0 3 3 2
0 4 4 6
0 5 5 0
0 6 6 8
0 7 7 1
0 8 8 7
2

```
### 样例输出 #2
```
1
```
### 样例输入 #3
```
10 15 14
2
0 6 6 439
0 3 8 1865
2
0 7 10 11371
2
1 1
2
2
1 3
2
0 5 8 7784
2
0 4 7 8497
2

```
### 样例输出 #3
```
155712307
76042715
719747106
76042715
76042715
74890016
76042715
719747106
```
## 提示

对于 $10\%$ 的数据, $ n,k\leq 5,q \leq 15$

对于 $30\%$ 的数据, $ n,q\leq 1000 $

对于额外 $10\%$ 的数据, $ k=1 $

对于额外 $15\%$ 的数据，不存在1操作

对于 $75\%$ 的数据, $n\leq 30000,q\leq 80000,k \leq 20$

对于 $100\%$ 的数据, $ n\leq 2 * 10^5,q\leq 10^6,k\leq 30,0 \leq val < 2^k$


---

---
title: "数码排序【加强版】"
layout: "post"
diff: 省选/NOI-
pid: P5634
tag: ['O2优化']
---
# 数码排序【加强版】
## 题目背景

**本题是[P5626](https://www.luogu.org/problem/P5626)的加强版**

小L从虚拟世界里出来啦！
## 题目描述

逃出来的同时，也有一部分数码逃了出来，吵着闹着让小L帮他们排序。

虚拟世界的数码都是不可见的。

小L目前只会选择排序，插入排序，冒泡排序，归并排序。

所以小L想问他在最坏情况下最少需要几次比较，才能使序列有序。

------

[排序的模板代码](https://www.luogu.org/paste/fdtepscp)
## 输入格式

输入仅有一行，给定一个正整数 $n$ ，表示序列的长度。
## 输出格式

输出最小的比较次数，答案对$100000007$取模。
## 样例

### 样例输入 #1
```
4
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
5
```
### 样例输出 #2
```
8
```
## 提示

- **样例$1$解释**

长度为$4$的序列归并调用，分成$2$组，一组$2$个元素。$2$个元素分别比较一次， 合并时最坏比较$3$次，所以是$3+1+1=5。$

- **数据范围**

对于 $10\%$ 的数据，$n\leq10^{18}$；

对于 $20\%$ 的数据，$n\leq10^{100}$；

对于 $50\%$ 的数据，$n\leq10^{1000}$；

对于 $80\%$ 的数据，$n\leq10^{10000}$；

对于 $100\%$ 的数据，$n\leq10^{100000}$。

**请注意时限**


---

---
title: "ckw的树"
layout: "post"
diff: 省选/NOI-
pid: P5637
tag: []
---
# ckw的树
## 题目描述

ckw有一棵无根树，ckw会随意挑一个点然后开始随机游走，每一个单位时间会等概率跳到与当前点距离不超过$2$的任意一个点。树上有一些点被标记了，求ckw第一次到达被标记的点的期望时间。

## 输入格式

第一行一个数$n$,$m$，表示点的个数和标记个数。

接下来$n-1$行，每行两个数$x$,$y$，表示$x$和$y$之间有一条边。

接下来$m$行，每行一个数表示被标记的点（可能有重复）

## 输出格式

$n$行每行一个数，第$i$行的数表示从编号为$i$的点开始随机游走的期望步数$mod\ 998244353$之后的值。

## 样例

### 样例输入 #1
```
2 1
1 2
1
```
### 样例输出 #1
```
0
2
```
### 样例输入 #2
```
10 2
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
9 10
2
5
```
### 样例输出 #2
```
3
0
3
4
0
8
10
13
14
15
```
### 样例输入 #3
```
10 2
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9  
1 10
3
6
```
### 样例输出 #3
```
5
5
0
5
5
0
5
5
5
5
```
## 提示

$2 \le n\le 10^5,1\le m \le n$

$subtask1(20pts):n\le 300$

$subtask2(16pts):$第$i$条边连接$i$和$i+1$

$subtask3(8pts):$第$i$条边链接$1$和$i+1$

$subtask4(20pts):n\le 3000$，且最大点的度数不超过$4$

$subtask5(36pts):$无限制


---

---
title: "基础函数练习题"
layout: "post"
diff: 省选/NOI-
pid: P5654
tag: ['洛谷月赛']
---
# 基础函数练习题
## 题目背景

YSGH is our red sun.

## 题目描述

YSGH 有一个 $1 \sim n$ 的排列 $p$ 和一个长度为 $n$ 的整数序列 $w$。

定义：

$$ F(l, r) = \begin{cases} \max(F(l, m - 1), F(m + 1, r)) + w_m & , l \le r \\ 0 & , l > r \end{cases} $$

其中 $m$ 为 $p$ 的区间 $[l, r]$ 的最大值的下标。

$q$ 次询问 $F(l, r)$ 的值。
## 输入格式

第一行两个正整数 $n, q$，意义同题目描述。

第二行共 $n$ 个正整数，第 $i$ 个表示 $p_i$，意义同题目描述。

第三行共 $n$ 个整数，第 $i$ 个表示 $w_i$，意义同题目描述。

接下来共 $q$ 行，每行两个正整数 $l, r$（$1 \le l \le r \le n$），表示询问 $F(l,r)$。
## 输出格式

输出共 $q$ 行，每行一个整数，表示答案。
## 样例

### 样例输入 #1
```
5 2
2 1 5 3 4
2 5 1 2 4
3 5
1 1
```
### 样例输出 #1
```
7
2
```
## 提示

**本题采用捆绑测试。**

- Subtask 1（10 points）：$n, q \le 5 \times {10}^3$。
- Subtask 2（10 points）：保证 $p$ 是随机的。
- Subtask 3（20 points）：$n ,q \le 5 \times {10}^4$。
- Subtask 4（20 points）：$n, q \le {10}^5$。
- Subtask 5（20 points）：$w_i \ge 0$。
- Subtask 6（20 points）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n, q \le 5 \times {10}^5$，$|w_i| \le 10^9$，$1 \le p_i \le n$，保证 $p$ 是一个 $1 \sim n$ 的排列。


---

---
title: "[SDOI2018] 原题识别-改"
layout: "post"
diff: 省选/NOI-
pid: P5669
tag: ['2018', '各省省选', '山东']
---
# [SDOI2018] 原题识别-改
## 题目背景

蒟蒻$\color{grey}{\text{suwakow}}$花了三天时间，研究出了[这道题](https://www.luogu.org/problem/P4618)的**线性空间**，且不依赖输入的随机性的一种优（du）秀（liu）做法。于是她决定拿出来毒瘤一下大家。
## 题目描述

有一棵$n$个点的有根树，根节点编号为$1$，且编号为$i$的节点有颜色$a_i$。你需要支持$m$次询问。询问有以下两种格式：

- $1~x~y$：询问树上编号为$x$的节点到编号为$y$的节点的最短路径中，不同的颜色有多少种。

- $2~a~b$：在节点$a$到根节点的路径中随机选择一个点$x$，在节点$b$到根节点的路径中随机选择一个点$y$，求询问 $1~x~y$ 的答案期望。（路径包含$a$, $b$和根节点）

对于询问$2$，设答案为$\mathrm{ans}$，$a$到根节点的路径经过的点数为$\mathrm{cnt_a}$，$b$到根节点的路径经过的点数为$\mathrm{cnt_b}$，你只需要输出$\mathrm{ans}\cdot \mathrm{cnt_a}\cdot \mathrm{cnt_b}$。

## 输入格式

**注意：输入格式与原题不同**

每个测试点仅包含一组数据。

输入数据的第一行包含两个非负整数$n$, $m$，表示节点个数和询问次数。

接下来一行包含$n$个正整数，第$i$个正整数为$a_i$，表示节点$i$的颜色。

接下来$n-1$行，每行包含两个整数$u$, $v$，表示编号为$u$的节点和编号为$v$的节点之间存在一条边。保证输入的边构成一棵树。

接下来$m$行，每行包含一个询问。询问的格式和意义见题目描述。
## 输出格式

输出$m$行，第$i$行包含一个非负整数，表示第$i$次询问的答案。
## 样例

### 样例输入 #1
```
5 3
1 4 4 5 4
1 2
2 3
3 4
2 5
1 2 3
2 1 3
1 3 2

```
### 样例输出 #1
```
1
5
1
```
### 样例输入 #2
```
10 5
3 4 3 8 9 3 2 8 5 7
1 2
2 3
3 4
4 5
5 6
4 7
4 8
8 9
8 10
1 1 10
2 3 5
2 7 5
2 5 4
1 8 6
```
### 样例输出 #2
```
4
34
61
45
3
```
## 提示

对于所有数据，保证$1\leq a_1, a_2, \ldots, a_n\leq n\leq 10^5$, $1\leq m\leq 2\times 10^5$。保证输入的边构成一棵树。

子任务$1$（$30$分）：保证不存在询问$2$。

子任务$2$（$30$分）：保证对于每一条边都有$v=u+1$。

子任务$3$（$40$分）：没有任何附加的限制。



---

---
title: "[CSP-S2019 江西] 散步"
layout: "post"
diff: 省选/NOI-
pid: P5688
tag: ['2019', 'CSP-S 提高级']
---
# [CSP-S2019 江西] 散步
## 题目背景

JXCSP-S T4
## 题目描述

公园内有 $n$ 个人正在散步，随着天色渐晚，所有人准备回家离开公园。公园的结构是一个首尾相连的环形图，它共有 $m$ 个出口，为了方便叙述，我们将人从 $1\sim n$ 编号，将出口按逆时针顺序从 $1\sim m$ 编号。

公园总长 $L$ 米，我们令 $1$ 号出口所在的位置为 $0$ 米，则 编号为 $i\ (2\le i\le m)$ 的出口在 $1$ 号出口逆时针方向 $a_i$ 米的位置上，其中 $a_i$ 严格递增 ，即 $i\ (1\le i < m)$ 号出口与 $i+1$ 号出口相邻，由于公园是环形图，故 $m$ 号出口与 $1$ 号出口也相邻。每个出口还有一个通行限制 $l_i$，表示最多有 $l_i$ 个人能从 $i$ 号出口离开。

所有人回家时将按自己的朝向，可能是顺时针方向，也可能是逆时针方向不断前行，当他们走到一个还能离开的出口时，将从该出口离开公园。特别地，当两个人同时走到一个只能允许 $1$ 个人离开的出口时，编号小的那个人能从该出口离开，编号较大的人将继续前进。

现在给定 $n$ 个人所在的起始位置与他们的前进方向，请你求出每个人从哪个出口离开，若编号为 $i$ 的 人从 $k_i$ 号出口离开，你只需要给出 $i\times k_i$ 的异或和，即：

$$ (1\times k_1) \operatorname{xor} (2\times k_2) \operatorname{xor}\cdots \operatorname{xor} (n\times k_n) $$

其中 $\operatorname{xor}$ 是位异或运算。特别地若一个人最后无法离开，则他的 $k_i = 0$。
## 输入格式

第一行三个正整数 $n, m, L$，意义见题目描述。

第二行 $m - 1$ 个正整数 $a_i\ (2\le i \le m)$ 表示出口位置。保证 $a_i$ 严格递增。

第三行 $m$ 个正整数 $l_i$ 表示出口的人数限制。

接下来 $n$ 行每行两个整数 $s_i,b_i\ (1 \le i \le n)$。若 $s_i$ 为 $0$ 表示编号为 $i$ 的人前进方向是逆时针方向，为 $1$ 表示是顺时针方向。 $b_i$ 表示编号为 $i$ 的人的起始位置为：离 $1$ 号出口逆时针方向 $b_i$ 米的位置。
## 输出格式

仅一行一个整数表示答案。
## 样例

### 样例输入 #1
```
3 2 5
2
2 1
0 1
1 3
0 4
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
3 2 5
2 
1 1
0 0 
0 2 
0 1
```
### 样例输出 #2
```
5
```
## 提示

#### 【输入输出样例 1 说明】
编号为 $1 ,2, 3$ 的人分别从 $2, 1, 1$ 号出口离开。

#### 【输入输出样例 2 说明】
编号为 $1,2$ 的人分别从 $1 ,2$ 号出口离开，编号为 $3$ 的人无法离开公园。

#### 【数据规模与约定】
对于 $12\%$ 的数据：$n, m, L \le 10$；   

对于 $32\%$ 的数据：$n, m \le 100$，$L \le 1000$；

对于 $52\%$ 的数据：$n, m \le 1000$；  

另有 $20\%$ 的数据：$n, m \le 10000$，所有 $s_i = 0$；   

对于 $100\%$ 的数据：$1 \le n,m \le 2 \times 10^5 $，$2 \le L \le 10^9$，$1\le a_i <L$，$1\le l_i \le n$，$s_i\in\{0,1\}$，$0\le b_i<L$。


---

---
title: "[NOI2004] 曼哈顿"
layout: "post"
diff: 省选/NOI-
pid: P5747
tag: ['2004', 'NOI', 'Special Judge']
---
# [NOI2004] 曼哈顿
## 题目描述

P 城是 M 国的著名旅游城市。在市长 G 先生的治理下，人民安居乐业，城市欣欣向荣。然而，G 市长并没有被自己的政绩冲昏头脑，他清醒地意识到城市的治理还存在着一些问题，其中之一就是交通问题。

P 城有 $m$ 条横向街道和 $n$ 条纵向街道，横向街道横贯东西，纵向街道纵穿南北，构成了 P 城整齐的交通网络（如图1所示）。

![](https://cdn.luogu.com.cn/upload/image_hosting/k1ei30qk.png)

由于街道狭窄，每条街道都只允许单向行驶，单向行驶的方向是事先设定好了的。一条横向街道的行驶方向只能是向东或者向西，一条纵向街道的行驶方向只能是向南或者向北，逆向行驶是绝对禁止的。

这项限制给交通带来了巨大的不便。如图 1，很多游人希望从宾馆前往购物中心，但限于街道的行驶方向，他们不得不绕一个大圈才能够到达。

这个问题一直困扰着 G 市长，每天他都会收到不少游人的来信，抱怨P城不合理的交通设计。但由于街道数目过多，他和他的部下始终不能解决这个问题……

令人高兴的是这个问题不久就可能得以解决。因为最近他们以重金聘请了著名的交通规划大师 B 先生，请他对 P 城的交通进行有效合理的改造。

B 先生知道不能通过拓宽街道的方法解决问题，因为这样势必影响到街道两旁的旅游景点，这是大家都不希望看到的。于是他准备重新设计街道的行驶方向（整条街道的行驶方向），使之尽可能满足大家的要求。

B 先生先把 P 城的街道编号，横向街道由北向南编号为 $1$，$2$，$\ldots$，$m$，纵向街道由西向东编号为 $1$，$2$，$\ldots$，$n$。这样任何一个十字路口的位置都可以用一对正整数来表示，第一个数是该路口所在的横向街道的编号，第二个数是它所在的纵向街道的编号，这对整数被称为该十字路口的坐标。比如图 1 中宾馆所在的十字路口的坐标是 $(2,3)$。
经过长期调查，他整理出了游人们提得相对集中的一些要求。每条要求都可以写成如下的形式：从一个十字路口到另一个十字路口的最短路径的长度必须等于它们之间的曼哈顿距离。所谓曼哈顿距离是指两个十字路口在东西方向上的距离加上在南北方向上的距离，坐标分别为 $(x_1,y_1)$ 和 $(x_2,y_2)$ 的两个十字路口之间的曼哈顿距离为 $|x_1-x_2|+|y_1-y_2|$。

好了，B 先生已经知道了 P 城目前所有街道的行驶方向和游人们提得相对集中的要求，他能不能重新设计街道的行驶方向，使之满足所有要求呢？

另外，改变每条街道的行驶方向都有一定的工作量，工作量的大小因道路而异。B 先生不仅想找到一个可行的改造计划，而且还希望这个计划的总工作量尽可能小。你能帮帮他吗？

## 输入格式

输入文件的第一行有两个正整数 $m$ 和 $n$，分别表示横向街道和纵向街道的数目。

第二行是一个长度为 $m$ 的字符串，由北向南列出了 $m$ 条横向街道改造前的行驶方向。`E` 表示向东，`W` 表示向西。

第三行是一个长度为 $n$ 的字符串，由西向东列出了 $n$ 条纵向街道改造前的行驶方向。`S` 表示向南，`N` 表示向北。

第四行有 $m$ 个非负整数，由北向南列出了改变每条横向街道的行驶方向的工作量。

第五行有 $n$ 个非负整数，由西向东列出了改变每条纵向街道的行驶方向的工作量。

第六行是一个正整数 $k$，表示游人们提得相对集中的要求的数目。

接下来的 $k$ 行，每行有四个正整数 $x_1$，$y_1$，$x_2$，$y_2$，表示一条要求。这条要求的内容是希望从坐标为 $(x_1,y_1)$ 的十字路口到坐标为 $(x_2,y_2)$ 的十字路口的最短路径的长度等于这两个路口之间的曼哈顿距离。
## 输出格式

第一行是一个字符串，`possible` 或者 `impossible`。输出 `possible` 表示可以通过改变街道的行驶方向满足输入数据中的所有要求，输出 `impossible` 表示无论怎么设计都不可能满足输入数据中的所有要求。

如果在第一行输出的是 `possible` 的话，在第二行输出一个整数，表示最小的总工作量，在第三行输出一个长度为 $m$ 的字符串，由北向南列出改造后的 $m$ 条横向街道的行驶方向，`E` 表示向东，`W` 表示向西，在第四行输出一个长度为 $n$ 的字符串，由西向东列出改造后的 $n$ 条纵向街道的行驶方向，`S` 表示向南，`N` 表示向北。
## 样例

### 样例输入 #1
```
2 3
WE
NNS
3 9
1 4 2
2
1 3 2 1
2 3 2 2
```
### 样例输出 #1
```
possible
9
WW
NNS
```
## 提示

#### 数据范围
对于全部的数据，$m\le 10$，$n\le 100$，$k\le 100$；改变一条街道的行驶方向的工作量不超过 $10000$。

#### 评分方式
- 如果你的输出文件的第一行是 `impossible`，
  - 如果确实无解，则该测试点满分。
  - 如果实际有解，则该测试点 $0$ 分。
- 如果你的输出文件的第一行是 `possible`，
  - 如果你的程序输出的方案不可行，则该测试点 $0$ 分。
  - 如果你的程序输出的总工作量与实际总工作量不一致，则该测试点 $0$ 分。
  - 如果你的程序输出的方案可行，但总工作量不是最小的，则该测试点 $4$ 分。
  - 如果你的程序输出的方案可行，且总工作量最小，则该测试点满分。


---

---
title: "[NOI2000] 古城之谜"
layout: "post"
diff: 省选/NOI-
pid: P5757
tag: ['2000', 'NOI']
---
# [NOI2000] 古城之谜
## 题目描述

著名的考古学家石教授在云梦高原上发现了一处古代城市遗址。让教授欣喜的是在这个他称为冰峰城 (Ice-Peak City) 的城市中有 $12$ 块巨大石碑，上面刻着用某种文字书写的资料，他称这种文字为冰峰文。然而当教授试图再次找到冰峰城时，却屡屡无功而返。

幸好当时教授把石碑上的文字都拍摄了下来，为了解开冰峰城的秘密，教授和他的助手牛博士开始研究冰峰文，发现冰峰文只有陈述句这一种句型和名词 (n) 、动词 (v) 、辅词 (a) 这三类单词，且其文法很简单：

![](https://cdn.luogu.com.cn/upload/image_hosting/fj2tbbqd.png)

在研究了大量资料后，他们总结了一部冰峰文词典，由于冰峰文恰好有 $26$ 个字母，为了研究方便，用字母 $a$ 到 $z$ 表示它们。

冰峰文在句子和句子之间以及单词和单词之间没有任何分隔符，因此划分单词和句子令石教授和牛博士感到非常麻烦，于是他们想到了使用计算机来帮助解决这个问题。假设你接受了这份工作，你的第一个任务是写一个程序，将一篇冰峰文文章划分为最少的句子，在这个前提下，将文章划分为最少的单词。

## 输入格式

-	第 $1$ 行为词典中的单词数 $n$ （$ n \le 1000 $）。
-	第 $2$ 行至第 $(n+1)$ 行每行表示一个单词，形为 $"α.mot"$ ，$α$ 表示词性，可能是 n (名词), v（动词）, a（辅词）中的一个， $mot$ 为单词，单词的长度不超过 $20$ 。拼写相同而词性不同的单词视为不同的单词，如输入示例中的 n.kick 与 v.kick 是两个不同的单词。
-	输入文件第 $(n+2)$ 行为需要划分的文章，以 "." 结束。
-	输入文件中的文章确保为冰峰文。文章是由有限个句子组成的，每个句子只包含有限个单词。文章长度不超过 5KB。

## 输出格式

-	为两行，每行一个整数。
-	第 $1$ 行为划分出来的句子数。
-	第 $2$ 行为划分出来的单词数。

## 样例

### 样例输入 #1
```
11
n.table
n.baleine
a.silly
n.snoopy
n.sillysnoopy
v.is
v.isnot
n.kick
v.kick
a.big
v.cry
sillysnoopyisnotbigtablebaleinekicksnoopysillycry.

```
### 样例输出 #1
```
2
9

```
## 提示

**样例说明**

（为了阅读方便，划分的单词用空格分隔，在单词的右上角标出它的词性，每行写一个句子，用句号表示句子结束。）

输出对应的划分：

$ sillysnoopy^n \quad isnot^v \quad big^a \quad table^n. \\
baleine^n \quad kick^v \quad snoopy^n \quad silly^a \quad cry^v. $

如果用下面的划分：

$ silly^a \quad snoopy^n \quad isnot^v \quad big^a \quad table^n. \\
baleine^n \quad kick^v \quad snoopy^n \quad silly^a \quad cry^v.$

则划分的句子数仍为 $2$ 个，但单词数却多了 $1$ 个，为 $10$ 个，显然应该按前者而不是后者划分。



---

---
title: "[JSOI2016] 位运算"
layout: "post"
diff: 省选/NOI-
pid: P5772
tag: ['2016', '各省省选', '江苏']
---
# [JSOI2016] 位运算
## 题目描述

JYY 最近在研究位运算。他发现位运算中最有趣的就是异或 (xor) 运算。对于两个数的异或运算，JYY 发现了一个结论：两个数的异或值为 $0$ 当且仅当他们相等。于是 JYY 又开始思考，对于 $N$ 个数的异或值会有什么性质呢？

JYY 想知道，如果在 $0$ 到 $R-1$ 的范围内，选出 $N$ 个不同的整数，并使得这 $N$ 个整数的异或值为 $0$，那么一共有多少种选择的方法呢？（选择的不同次序并不作重复统计，请参见样例）

JYY 是一个计算机科学家，所以他脑海里的 $R$ 非常非常大。为了能够方便的表达，如果我们将 $R$ 写成一个 $01$ 串，那么 $R$ 是由一个较短的 $01$ 串 $S$ 重复 $K$ 次得到的。比如，若 $S=101$，$K=2$，那么 $R$ 的二进制表示则为 $101101$。由于计算的结果会非常大，JYY 只需要你告诉他选择的总数对 $10^9+7$ 取模的结果即可。
## 输入格式

第一行包含两个正整数 $N$ 和 $K$；

接下来一行包含一个由 $0$ 和 $1$ 组成的字符串 $S$；

我们保证 $S$ 的第一个字符一定为 $1$。
## 输出格式

一行一个整数，表示选择的方案数对 $10^9+7$ 取模的值。
## 样例

### 样例输入 #1
```
3 1
100
```
### 样例输出 #1
```
1
```
## 提示

**样例说明**

唯一的一种选择方法是选择 $\{1,2,3\}$。

------

**数据范围**

对于 $100\%$ 的数据，$3 \le N \le 7$，$1 \le k \le 10^5$，$1 \le |S| \le 50$。


---

---
title: "[IOI 2019] 矩形区域"
layout: "post"
diff: 省选/NOI-
pid: P5781
tag: ['2019', 'IOI', 'O2优化']
---
# [IOI 2019] 矩形区域
## 题目背景

# 滥用本题评测将封号！
## 题目描述

19 世纪初，统治者下令在俯瞰美丽河景的高原上建造一座宫殿。这块高原被看做是一个由正方形单元格组成的 $n \times m$ 网格。网格的行从 $0$ 到 $n-1$ 编号，列从 $0$ 到 $m-1$ 编号。第 $i$ 行第 $j$ 列（$0 \le i \le n-1$，$0 \le j \le m-1$）的单元格记为单元格 $(i,j)$。每个单元格 $(i,j)$ 有特定的海拔高度，记为 $a_{i,j}$。

统治者指示他的建筑师选择一个矩形区域来建造宫殿。该区域不能包含网格边界（第 $0$ 行，第 $n-1$ 行，第 $0$ 列，以及第 $m-1$ 列）上的任何单元格。为此，建筑师应选出四个整数 $r_1$，$r_2$，$c_1$ 和 $c_2$（$1 \le r_1 \le r_2 \le n-2$ 且 $1 \le c_1 \le c_2 \le m-2$ )，对应于包括所有满足 $r_1 \le i \le r_2$ 且 $c_1 \le j \le c_2$ 的单元格 $(i,j)$ 的矩形区域。

此外，一个区域被认为是合法的，当且仅当对于该区域中的每个单元格 $(i,j)$，以下条件成立：对于与该区域相邻的、位于第 $i$ 行的两个单元格（单元格 $(i,c_1-1)$ 和 $(i,c_2+2)$），以及与该区域相邻的、位于第 $j$ 列的两个单元格（单元格 $(r_1-1)$ 和 $(r_2+2,j)$），单元格 $(i,j)$ 的海拔高度必须严格小于这四个单元格的海拔高度。

你的任务是帮助建筑师统计可建宫殿的合法区域的数量（也就是所对应区域为合法的 $r_1$，$r_2$，$c_1$ 和 $c_2$ 的数量）。


## 输入格式

第一行，两个整数 $n$ 和 $m$，表示网格的长和宽。

接下来 $n$ 行，第 $i$ 行 $m$ 个整数，为 $a_{i-1,0\dots m-1}$。


## 输出格式

一行，一个整数，表示合法区域的数量。
## 样例

### 样例输入 #1
```
6 5
4 8 7 5 6
7 4 10 3 5
9 7 20 14 2
9 14 7 3 6
5 7 5 2 7
4 5 13 5 6

```
### 样例输出 #1
```
6

```
## 提示

**样例解释**

![](https://loj-img.upyun.menci.memset0.cn/2019/08/09/5d4d529d7be55.jpg)

一共有 $6$ 个合法区域，分别为：
- $r_1=r_2=1, c_1=c_2=1$
- $r_1=1, r_2=2, c_1=c_2=1$
- $r_1=r_2=1, c_1=c_2=3$
- $r_1=r_2=4, c_1=2,c_2=3$
- $r_1=r_2=4, c_1=c_2=3$
- $r_1=3,r_2=4,c_1=c_2=3$

例如，$r_1=1, r_2=2, c_1=c_2=1$ 对应一个合法区域，原因是以下两个条件都成立：
- $a_{1,1}=4$ 严格小于 $a_{0,1}=8$，$a_{3,1}=14$，$a_{1,0}=7$，和 $a_{1,2}=10$。
- $a_{2,1}=7$ 严格小于 $a_{0,1}=8$，$a_{3,1}=14$，$a_{2,0}=9$，和 $a_{2,2}=20$。

**数据范围**

对于所有数据：
- $1 \le n, m \le 2500$。
- $0 \le a_{i,j} \le 7 \times 10^6 (0 \le i \le n - 1, 0 \le j \le m - 1)$。

详细子任务附加限制与分值如下表：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$n, m \le 30$|$8$|
|$2$|$n, m \le 80$|$7$|
|$3$|$n, m \le 200$|$12$|
|$4$|$n, m \le 700$|$22$|
|$5$|$n \le 3$|$10$|
|$6$|$0 \le a_{i,j} \le 1$|$13$|
|$7$|没有任何附加限制|$28$|


---

---
title: "[SEERC 2019] Tree Permutations"
layout: "post"
diff: 省选/NOI-
pid: P5803
tag: ['2019', 'ICPC']
---
# [SEERC 2019] Tree Permutations
## 题目描述

有一天，Cool 先生建了一棵 $n$ 个点的树（没有环的无向连通图），他给任一编号 $i > 1$ 的点规定了两个值：$p_i < i$ 代表点 $i$ 的父节点，与 $w_i$ 代表 $i$ 与 $p_i$ 之间的边的边权。点 $1$ 是树根，所以它没有父节点。

你想知道 Cool 先生建的树长啥样，但是 Cool 先生拒绝告诉你，但他给了你一些提示：

他把所有的 $p_i$ 和 $w_i$ 值写成一列，得到了长为 $2 \cdot n - 2$ 的数列 $b$。

$$ b=[p_2, w_2, p_3, w_3, \dots, p_{n-1}, w_{n-1}, p_n, w_n] $$

然后他将其随机打乱，得到了数列 $a$，并将 $a$ 告诉你。

然而只知道数列 $a$ 是无法还原那棵树的，你决定解决一个更难的问题。

定义一个树是 *$k$ 长*的，当且仅当点 $1$ 到点 $n$ 的路径上有恰好 $k$ 条边。

定义一个树是 *$k$ 完美*的，当且仅当这棵树是 *$k$ 长*的且点 $1$ 到点 $n$ 的路径上的边的边权之和是所有 *$k$ 长*的树中最大的。

你的任务是计算出每个 $k$ 值对应的 *$k$ 完美*的树中，点 $1$ 到点 $n$ 的路径上的边的边权之和。如果某个 $k$ 值不存在 *$k$ 完美*的树，则在该位置输出 $-1$。
## 输入格式

第一行包含一个整数 $n \ (2 \leq n \leq 10^5)$，代表树上的节点数。

第二行包含 $2 \cdot n -2$ 个整数 $a_1, a_2, \dots, a_{2n-2} \ (1 \leq a_i \leq n-1)$，代表数列 $a$ 中的数字。
## 输出格式

输出一行，共 $n-1$ 个空格隔开的整数 $w_1, w_2, w_3, \dots, w_{n-1}$，其中 $w_k$ 代表 *$k$ 完美*的树中点 $1$ 到点 $n$ 的路径上的边的边权之和。如果不存在 *$i$ 长*的树，则 $w_i=-1$。
## 样例

### 样例输入 #1
```
3
1 1 2 2
```
### 样例输出 #1
```
2 3
```
### 样例输入 #2
```
3
2 2 2 2
```
### 样例输出 #2
```
-1 -1
```
### 样例输入 #3
```
6
1 4 5 4 4 4 3 4 4 2
```
### 样例输出 #3
```
-1 -1 -1 17 20
```
## 提示

第一个样例中，*$1$ 完美*的树由数列 $[1, 2, 1, 2]$ 构成（即，$p_2=1, w_2=2, p_3=1, w_3=2$），*$2$ 完美*的树由数列 $[1, 2, 2, 1]$ 构成（即，$p_2=1, w_2=2, p_3=2, w_3=1$）。以下是这两棵树的图形（点 $1$ 到点 $n$ 的路径上的边都为粗线）。

![样例1](https://cdn.luogu.com.cn/upload/image_hosting/lgpg0jne.png)

第二个样例中，不存在能通过重排 $a$ 构造出的 *$k$ 完美*的树。

第三个样例中，只有 *$4$ 完美*的和 *$5$ 完美*的树可以被构造出。它们分别由数列 $[1, 4, 2, 4, 3, 4, 4, 4, 4, 5]$ 和 $[1, 4,2, 4, 3, 4, 4, 4, 5, 4]$ 构成。以下是这两棵树的图形。

![样例3](https://cdn.luogu.com.cn/upload/image_hosting/rz04b4ro.png)


---

---
title: "【模板】BEST 定理 | Which Dreamed It"
layout: "post"
diff: 省选/NOI-
pid: P5807
tag: []
---
# 【模板】BEST 定理 | Which Dreamed It
## 题目描述

有 $n$ 个房间，每个房间有若干把钥匙能够打开特定房间的门。

最初你在房间 $1$。每当你到达一个房间，你可以选择该房间的一把钥匙，前往该钥匙对应的房间，并将该钥匙丢到垃圾桶中。

你希望最终回到房间 $1$，且垃圾桶中有所有的钥匙。

你需要求出方案数，答案对 $10^6 + 3$ 取模。两组方案不同，当且仅当使用钥匙的顺序不同。

注意，每把钥匙都是不同的。

原 BZOJ3659。
## 输入格式

**本题有多组数据。**

第一行一个整数 $T$，表示数据组数。

对于每组数据：

第一行一个整数 $n$。

接下来 $n$ 行，第 $i$ 行描述房间 $i$：

首先一个数 $s$，表示这个房间的钥匙数目，接下来 $s$ 个数，分别描述每把钥匙能够打开的房间的门。
## 输出格式

对于每组数据，一行一个整数，表示答案对 $10^6+3$ 取模后的值。
## 样例

### 样例输入 #1
```
2
1
0
2
1 1
1 2

```
### 样例输出 #1
```
1
0

```
## 提示

【样例说明】

在第一组样例中，没有钥匙，则方案数为 $1$。

在第二组样例中，你不可能使用第二个房间的钥匙，所以方案数为 $0$。

【数据范围】

对于 $50\%$ 的数据，$n \le 4$，$\sum s \le 30$。

对于 $100\%$ 的数据，$1 \le T \le 15$，$1 \le n \le 100$，$0 \le \sum s \le 3141592$。

2021/5/14 加强 by [SSerxhs](https://www.luogu.com.cn/user/29826)&[滑大稽](https://www.luogu.com.cn/user/203743)


---

---
title: "【L&K R-03】音游大计算"
layout: "post"
diff: 省选/NOI-
pid: P5819
tag: ['2019', '洛谷原创']
---
# 【L&K R-03】音游大计算
## 题目描述

小 K 喜欢玩音游，特别是一款叫做 dimou 的音游。dimou 的判定机制是这样的：dimou 是单面（不像某 dy 开头的东西）下落式音游。具体来说，在屏幕底端有一条判定线。一首曲子有若干打击点（即 key，可以看做一条与判定线平行的只有左右宽度的线段），每个 key 会在某个时刻从顶端匀速下落，而玩家需要尽量精准地在每个 key 与判定线重合时点击它。

当然，玩家有可能在 key 接触判定线之前就点击了，也可能在 key 已经落到判定线之下时才点击。这时候，就需要考虑游戏的判定系统，以统计玩家完成一首曲子的情况。dimou 有三种判定：perfect，good 和 miss。总共有六种情况——

情况 $1$：玩家点击的时间在某个 key 下落至其与判定线重合的时间的前 $1s$ 或更多（记为 $\triangle t\ge1$，下同），则不会产生任何判定效果（等于无意义点击）；

情况 $2$：$0.6\le\triangle t<1$，则此 key 产生一次 miss 判定并消失；

情况 $3$：$0.2\le\triangle t<0.6$，则此 key 产生一次 good 判定并消失；

情况 $4$：$-0.2<\triangle t<0.2$（负数代表在 key 到达判定线之后点击），则此 key 产生一次 perfect 判定并消失；

情况 $5$：$-0.6<\triangle t\le-0.2$，则此 key 产生一次 good 判定并消失；

情况 $6$：$\triangle t\le-0.6$，则此 key 在点击之前就会落出屏幕，记一次 miss 判定并消失（即在此 key 落于判定线之下 $0.6s$ 后自己产生一次 miss 判定），点击对此 key 不会产生任何判定效果。

除此之外，dimou 还有最大连击判定（max combo）。一段连击（combo）是指从某一个非 miss 的判定开始，到某一个非 miss 的判定结束（在这段区间内 **（按时间顺序）** 没有任何 miss 判定），判定的总数量。而 max combo 则指的是所有 combo 的最大值。

除此之外，dimou 还有一些判定规则。一次点击的位置可以看做判定线上的一个点，则过此点作判定线的垂线，只有与此垂线有交点（交点可在端点）的 key 才**可能**因此次点击产生判定效果。并且， **每次点击只会对可能产生判定效果的 key 中位置（纵向高度）最低（离屏幕顶端最远）的一个产生判定效果。** 形象地说，你只有点击某个 key 下方的位置才可能将其消除，并且若两个 key 有上下相对距离地一起下落，那么如果点击可以使下面的 key 消除，则一定不会使上面的 key 消除。特殊地，如果一次点击对两个或以上位置（高度）相同的 key 都可能产生判定效果，且没有更低的可能产生判定效果的 key，则这些 key 都会被消除。

为了把一首曲子打好，小 K 决定背谱，即记住所有 key 的位置和它们下落到判定线的时间。当然，小 K 也会事先决定好自己的打法，即决定在什么时间在什么位置点击。可是小 K 并不会计算自己的打法可以得到的最终成绩。请你帮小 K 算算，他的打法会得到多少 perfect 判定，多少 good 判定，多少 miss 判定，以及 max combo。

注意：小 K 不会在同一时间点击两次或以上。如果同一时间有多个判定，按 miss，good，perfect 的顺序依次处理。
## 输入格式

第一行两个正整数 $n,m$，代表 key 数量与小 K 的点击数。

紧接着 $n$ 行，每行三个浮点数（小数位数不超过 $5$ 位）$t_i,a_i,b_i$，分别表示每个 key 从曲子开始算起到达判定线的时间，其左端点位置，右端点位置。

紧接着 $m$ 行，每行两个浮点数（小数位数不超过 $5$ 位）$T_i,x_i$，分别表示小 K 每次点击从曲子开始算起的时间和其位置。
## 输出格式

一行，输出四个非负整数，两两用单个空格隔开，分别代表 perfect 数，good 数，miss 数和 max combo。
## 样例

### 样例输入 #1
```
5 6
1 0.0 10.0
1.5 0.0 10.0
2.0 0.0 10.0
2.5 0.0 10.0
3.0 0.0 10.0
0.0 5.0
0.4 5.0
1.3 5.0
2.0 5.0
2.7 5.0
3.6 5.0
```
### 样例输出 #1
```
1 2 2 3
```
### 样例输入 #2
```
4 2
0.1 0.0 3.0
0.1 2.0 4.0
0.0 3.0 8.0
0.6 1.0 6.0
0.6 6.0
0.0 2.5
```
### 样例输出 #2
```
3 0 1 2
```
## 提示

样例 $3$：[输入](https://www.luogu.com.cn/paste/qrbt8fnq)，[输出](https://www.luogu.com.cn/paste/evke45h8)。

样例 $4$：[输入](https://www.luogu.com.cn/paste/a71namso)，[输出](https://www.luogu.com.cn/paste/jgpcani2)。

【样例解释】

对于样例 $1$：$5$ 个 key 产生的判定按时间顺序分别为 
 miss，good，perfect，good，miss。第一次和最后一次点击不产生判定效果。

对于样例 $2$：按时间顺序，第一次点击（$T=0.0$），可能产生判定效果的有（按输入顺序）第 $1,2,4$ 个 key。第 $1,2$ 个 key 同时到达判定线，第 $4$ 个 key 比第 $1,2$ 个 key 高。因此第一次点击只让第 $1,2$ 个 key 产生 perfect 判定。第二次点击（$T=0.6$），与其垂线有交点的有第 $3,4$ 个 key，但第 $3$ 个 key 此时已经产生 miss 判定并消失，因此这次点击让第 $4$ 个 key 产生一次 perfect 判定，此时在同一时间出现了两个判定 perfect，miss，按照规则先处理 miss 再处理 perfect。所以，所有判定按时间顺序分别是 perfect，perfect，miss，perfect。容易发现 miss 把判定序列分成了两段，第一段的 combo 为 $2$，第二段的 combo 为 $1$，所以 max combo 为 $2$。

【数据范围】

对于 $30\%$ 数据，$n,m\le5000$。

对于另外 $20\%$ 数据，$n\le5000$，$m\le114514$。

对于另外 $10\%$ 数据，所有 $a_i$ 相等，所有 $b_i$ 相等。

对于另外 $10\%$ 数据，$t_i,T_i,a_i,b_i,x_i$ 在 $[0,10^4]$ 中随机生成。

对于 $100\%$ 数据，$1\le n,m\le114514$，$0\le t_i,T_i,a_i,b_i,x_i\le 10^4$，$a_i\le b_i$。


---

---
title: "【L&K R-03】密码串匹配"
layout: "post"
diff: 省选/NOI-
pid: P5821
tag: ['2019', '洛谷原创']
---
# 【L&K R-03】密码串匹配
## 题目背景

众所周知，小 L 很喜欢用 $123321$ 做密码。每次登陆 Codeforces，都会看见显眼的一行提示：

```text
Your password is extremely weak or has been leaked . Please, change it ASAP. 
(see https://haveibeenpwned.com/)
```
## 题目描述

在被机惨之后，小 L 痛定思痛，决定使用更安全的密码。小 L 设计出了一个可能长达 $200,000$ 位的仅由小写字母构成的密码，并保证没有人能记住，猜出或试出（包括小 L 自己）。

为了防止自己忘记整串密码（不用防止了，已经忘记了），小 L 编写了一个程序，可以存储小 L 的密码串 $T$，但是不能直接输出（因为这个程序可能会被他人使用），小 L 第一次会根据记忆还原出长度为 $l$ 的一个字符串 $P$，后面会根据程序的输出修改 $P$ 的某一位，这个程序可以求出当前猜测串 $P$ 与密码串 $T$ 的相同长度的字串的 **失配度** 。

定义字符 `a` 的值为 $1$，字符 `b` 的值为 $2$，以此类推，字符 `z` 的值为 $26$。定义两个字符串 $s,t$ 的失配度为对应位置上的值相减后的平方。

现在，小 L 想知道他的程序是否正确，请你也编写一个类似的程序。
## 输入格式

输入的第一行为三个数 $n,l,m$，分别表示密码串 $T$ 的长度 $n$，猜测串 $P$ 的长度 $l$，和操作次数 $m$。

接下来的两行有两个字符串，分别为 $T$ 和 $P$。

接下来的 $m$ 行，每行的第一个整数为 $op$，表示操作的类型：

若 $op=1$，接下来有一个整数 $x$，表示要求 $P$ 和从 $T$ 的第 $x$ 位开始长度为 $l$ 的字串的失配度；

若 $op=2$，接下来有一个整数 $x$ 和一个字符 $c$，表示修改 $P$ 的第 $x$ 位，使其等于 $c$。
## 输出格式

对于每个 $1$ 操作，输出一行，为所求值。
## 样例

### 样例输入 #1
```
8 5 3
iamangry
anger
1 4
2 2 m
1 2
```
### 样例输出 #1
```
218
238
```
## 提示

**请注意本题特殊的时间限制。**

**本题数据规模大，请注意常数优化。**

为了防止题目过于卡常，本题 **提供 [八聚氧](https://www.luogu.com.cn/paste/ky1fh8zk)** ，直接加在代码最前提交即可。

本题中所有编号从 $1$ 开始。

- Subtask \#1：$30$ 分，保证 $n,m\le 5\times 10^3$；
- Subtask \#2：$30$ 分，保证没有 $2$ 操作；
- Subtask \#3：$40$ 分，保证 $n,m\le 2\times 10^5$。

对于 $100\%$ 的数据，保证 $1\le l\le n,1\le x$。

对于所有 $1$ 操作，保证 $x-1+l\le n$。

对于所有 $2$ 操作，保证 $x\le l$。

### 样例解释

$(a-a)^2+(n-n)^2+(g-g)^2+(r-e)^2+(y-r)^2=13^2+7^2=218$。

$(a-a)^2+(m-m)^2+(a-g)^2+(n-e)^2+(g-r)^2=6^2+9^2+11^2=238$。


---

---
title: "[IOI 2015] sorting"
layout: "post"
diff: 省选/NOI-
pid: P5862
tag: ['2015', 'IOI', 'Special Judge']
---
# [IOI 2015] sorting
## 题目描述

Aizhan 有一个由 $N$ 个互不相同的整数组成的序列 $S[0],S[1],\cdots,S[N-1]$，其中 $S[i]$ 取值范围是 $[0,N-1]$。Aizhan 试图通过交换某些元素对的方法将这个序列按照升序排序。Aizhan 的朋友 Ermek 也想交换某些元素对， Ermek 的交换未必有助于 Aizhan 的排序。

Ermek 和 Aizhan 打算通过若干轮次来修改这个序列。在每一轮，Ermek 首先做一次交换，然后 Aizhan 做另一次交换。更确切地说，做交换的人选择两个有效的下标并交换这两个下标的元素。请注意这两个下标可能相同。如果它们相等，则对这个元素自身做交换，并不改变这个序列。

Aizhan 知道 Ermek 并不关心对序列 
$S$ 排序的事情。Aizhan还知道 Ermek 将会选择哪些下标。Ermek 打算参加 $M$ 轮交换，将这些轮次从 $0$ 到 $M-1$ 编号。对于 $0$ 到 $M-1$ 之间的每个 $i$，Ermek 在第 $i$ 轮将选择下标 $X[i]$ 和 $Y[i]$ 的元素进行交换。

Aizhan 要对序列 $S$ 按升序进行排序。在每一轮之前，如果 Aizhan 看到当前的序列已经按升序排列，她将结束这个排序过程。给定初始序列 $S$ 以及 Ermek 要选择的下标，请你找出一个交换的序列，使得 Aizhan 能完成对序列 $S$ 的排序。此外，在有些子任务中，你还要找出尽可能短的交换序列来完成排序任务。题目保证通过 $M$ 或更少的轮次能够将序列 $S$ 排好序。

请注意如果 Aizhan 发现在 Ermek 的交换之后，序列 $S$ 已经排好序，则 Aizhan 可以选择交换两个相同下标（例如 $0$ 和 $0$）的元素。这样，序列 $S$ 在这一轮次之后也完成排序，于是也达到了 Aizhan 的目标。另外，如果初始序列 $S$ 就已经排好序，那么所需的最少排序轮数就是 $0$。
## 输入格式

- 第 $1$ 行有一个正整数 $N$，表示序列 $S$ 的长度；
- 第 $2$ 行有 $N$ 个正整数，分别为 $S[0],\cdots,S[N-1]$，即初始序列 $S$；
- 第 $3$ 行有一个正整数 $M$，表示 Ermek 打算做交换的次数；
- 第 $4$ 到 $M+3$ 行，有两个正整数 $X[i]$，$Y[i]$，表示对于 $0\le i\le M-1$, 在第 $i$ 轮 Ermek 打算交换下标为 $X[i]$ 和 $Y[i]$ 的数组。
## 输出格式

- 第 $1$ 行 : 交换的长度 $R$；
- 第 $2+i$（$0\le i < R$）行：$P[i]$，$Q[i]$。

注：$P$，$Q$分别为两个整数数组。利用这两个数组报告 Aizhan 完成对序列 $S$ 排序的一种可能的交换序列，假设这个交换序列的长度为 $R$，对于 $0$ 到 $R-1$ 之间的每个 $i$，Aizhan 在轮次 $i$ 选择的下标将被存入 $P[i]$ 和 $Q[i]$。 你可以假设数组 $P$ 和 $Q$ 均已分别被分配了 
$M$ 个元素。
## 样例

### 样例输入 #1
```
5
4 3 2 1 0
6
0 1
1 2
2 3
3 4
0 1
1 2

```
### 样例输出 #1
```
3
0 4
1 3
3 4
```
### 样例输入 #2
```
5
3 0 4 2 1
5
1 1
4 0
2 3
1 4
0 4

```
### 样例输出 #2
```
3
1 4
4 2
2 2
```
## 提示

对于 $100\%$ 的数据，$1 \le N\le 2 \times 10^5$，$1 \le M \le 6 \times 10^5$。要求 $R$ 取最小值。


---

---
title: "[SEERC 2018] Inversion"
layout: "post"
diff: 省选/NOI-
pid: P5871
tag: ['2018', 'ICPC']
---
# [SEERC 2018] Inversion
## 题目描述

定义一个长为 $n$ 的*排列*为一个序列 $p_1, p_2, \dots, p_n$，其中 $[1, n]$ 范围内的整数都恰好在这个序列中出现一次。定义排列中的一个*逆序对*为一对整数 $(i, j)$，其中 $i, j \in [1,n]$，且满足 $i<j, p_i>p_j$。

定义一个*逆序对图*为一个有 $n$ 个点的图，图中存在一条 $(i, j)$ 的边当且仅当 $(i,j)$ 是一个逆序对。

定义一个图中的*独立集*为一个图中点的集合，满足集合中的点两两之间没有边相连。定义一个图中的*支配集*为一个图中点的集合，满足不在这个集合中的点都与集合中的某个点有边相连。定义一个图中的*独立支配集*为一个图中点的集合，这个集合既是独立集又是支配集。

给定某一个长为 $n$ 的排列的逆序对图，请计算出这个图中独立支配集的数量。

数据保证答案不会超过 $10^{18}$。
## 输入格式

第一行包含两个整数 $n$ 和 $m \ (1 \leq n \leq 100, 0 \leq m \leq \frac{n \times (n-1)}{2})$，代表图中的点数和边数。

接下来 $m$ 行每行包含两个整数 $u_i$ 和 $v_i \ (1 \leq u_i, v_i \leq n)$，代表图中点 $u_i$ 和 $v_i$ 之间有一条边相连。

数据保证图一定对应某一个排列。
## 输出格式

输出图中独立支配集的数量。

数据保证答案不会超过 $10^{18}$。
## 样例

### 样例输入 #1
```
4 2
2 3
2 4
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
5 7
2 5
1 5
3 5
2 3
4 1
4 3
4 2
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
7 7
5 6
2 3
6 7
2 7
3 1
7 5
7 4
```
### 样例输出 #3
```
6
```
### 样例输入 #4
```
5 6
1 3
4 5
1 4
2 3
1 2
1 5
```
### 样例输出 #4
```
5
```
## 提示

第一个样例中，图对应排列 $[1,4,2,3]$，独立支配集有 $(1,3,4)$ 和 $(1,2)$。

第二个样例中，图对应排列 $[3,5,4,1,2]$，独立支配集有 $(1,2),(1,3),(4,5)$。

第三个样例中，图对应排列 $[2,4,1,5,7,6,3]$。

第四个样例中，图对应排列 $[5,2,1,4,3]$。


---

---
title: "小欧与回文串构造"
layout: "post"
diff: 省选/NOI-
pid: P5890
tag: ['Special Judge', 'O2优化', '洛谷月赛']
---
# 小欧与回文串构造
## 题目描述

小欧很喜欢字符串，尤其是只有 `0` 和 `1` 两种字符的回文串。

小欧也喜欢回文串，尤其是有那么一些回文子串但不是很多的串。

小欧更喜欢构造，所以他思考如下问题：

给定正整数 $n$ 和 $k$，保证 $k\le n$，能否构造一个长为 $n$ 的，只含有字符 `0` 和 `1` 的字符串 $S$，使得 $S$ 的本质不同非空回文子串个数恰好为 $k$ 呢？

小欧是构造小鬼，打不过已经爆切十万甚至九万道构造的先辈们，因此他找你帮忙解决这个问题，并希望你在有解时给出任意一个构造。

下面给出一些关于字符串的基本定义，字符串大手子可以跳过不读。

- 对于长为 $n$ 的字符串 $S$，定义 $S_i$ 为字符串 $S$ 的从左至右第 $i$ 个字符，
- 对于长为 $n$ 的字符串 $S$，定义其子串 $S[l;r]\; (1\le l\le r\le n)$ 为将字符 $S_l,S_{l+1},\ldots,S_{r}$ 自左至右拼接形成的字符串。特别地，空串也是 $S$ 的子串。
- 称 $S$ 的两个子串 $S[l_1;r_1]$ 和 $S[l_2;r_2]$ 本质不同，当且仅当 $S[l_1;r_1] \ne S[l_2;r_2]$。
- 对于长为 $n$ 的字符串 $S$，定义它的反串 $S^{T}$ 为将字符 $S_n,S_{n-1},\ldots,S_1$ 自左至右拼接形成的字符串。
- 字符串 $S$ 为回文串，当且仅当 $S=S^{T}$。
## 输入格式

**本题有多组数据**。

第一行一个正整数 $T$，表示数据组数。

对于每组数据：

一行两个正整数，表示这组数据给出的 $n$ 和 $k$。

## 输出格式

对于每组数据：

若该组数据没有解，输出一行一个字符串 `No`；

否则输出两行，第一行一个字符串 `Yes`，接下来一行一个长为 $n$ 的 `01` 串，为你构造的解。有多个解输出任意一个即可。

## 样例

### 样例输入 #1
```
4
4 4
8 6
15 14
114514 1
```
### 样例输出 #1
```
Yes
0101
No
Yes
010100000111101
No
```
## 提示

对于第一组数据，本质不同的回文子串有：`1`，`0`，`101`，`010` 共四个。

### 数据范围与约定

对于 $20\%$ 的数据，$n\le 15$。  
另有 $10\%$ 的数据，$k=n$。  
另有 $20\%$ 的数据，$1000\le n\le 2000$，$k\ge \left\lfloor\dfrac{n}{2}\right\rfloor+100$。  
对于 $100\%$ 的数据，$1 \le T \le 10$，$1\le k\le  n\le 2\times 10^5$。


---

---
title: "[IOI 2014] holiday 假期"
layout: "post"
diff: 省选/NOI-
pid: P5892
tag: ['2014', 'IOI']
---
# [IOI 2014] holiday 假期
## 题目描述

健佳正在制定下个假期去台湾的游玩计划。在这个假期，健佳将会在城市之间奔波，并且参观这些城市的景点。

在台湾共有 $n$ 个城市，它们全部位于一条高速公路上。这些城市连续地编号为 $0$ 到 $n-1$。

对于城市 $i$（$0 < i < n-1$ ）而言，与其相邻的城市是 $i-1$ 和 $i+1$。但是对于城市 $0$，唯一与其相邻的是城市 $1$。而对于城市 $n-1$，唯一与其相邻的是城市 $n-2$。

每个城市都有若干景点。健佳有 $d$ 天假期并且打算要参观尽量多的景点。健佳已经选择了假期开始要到访的第一个城市。在假期的每一天，健佳可以选择去一个相邻的城市，或者参观所在城市的所有景点，但是不能同时进行。即使健佳在同一个城市停留多次，他也不会去重复参观该城市的景点。请帮助健佳策划这个假期，以便能让他参观尽可能多的景点。

## 输入格式

- 第 $1$ 行：有三个非负整数， $n$ 代表城市数目，$start$ 代表起点城市编号，$d$ 代表假期天数。
- 第 $2$ 行：$n$ 个非负整数 $a[0],\cdots, a[n-1]$，对于 $0 \le i \le n-1$，$a[i]$ 代表城市 $i$ 的景点数目。

## 输出格式

- 共一行，最多参观的景点数目。
## 样例

### 样例输入 #1
```
5 2 7
10 2 20 30 1

```
### 样例输出 #1
```
60

```
## 提示

**子任务**

在所有的子任务中，有 $0 \le d \le 2n+floor(n/2)$。
而且，每个城市中的景点数都是非负整数。

| 子任务 | 分值 | $n$ | 各城市景点数的最大值 | 起点城市 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $7$ | $2 \le n \le 20$ | $10^9$ | 无限制 |
| $2$ | $23$ | $2 \le n \le 10^5$ | $100$ | 城市 $0$ |
| $3$ | $17$ | $2 \le n \le 3 \times 10 ^3$ | $10^9$ |无限制  |
| $4$ | $53$ | $2 \le n \le 10^5$ | $10^9$ | 无限制 |




---

---
title: "[IOI 2013] game 游戏"
layout: "post"
diff: 省选/NOI-
pid: P5893
tag: ['2013', 'IOI', 'O2优化']
---
# [IOI 2013] game 游戏
## 题目背景

警告：**滥用本题评测将被封号**。
## 题目描述

Bazza 和 Shazza 正在玩游戏。游戏在一个 $R$ 行 $C$ 列的网格上进行。其中， $R$ 行编号为 $0,\cdots, R - 1 $， $C$ 列编号为 $0,\cdots, C - 1 $。我们用 $(P, Q)$ 表示位于 $P$ 行 $Q$ 列的单元格。每个单元格包含一个非负整数，游戏开始时所有单元格内的整数均为零。

游戏如下进行：任意时刻，Bazza 可以做如下动作之一：
- 修改一个单元格 $(p, q)$ 内包含的整数值；
- 要求 Shazza 计算一个给定子矩阵中所有单元格内数字的最大公约数（GCD），子矩阵的两个对角分别为 $(p, q)$ 和 $(u, v)$ （子矩阵包含给定的两个对角点）。

Bazza 会做 $N_U + N_Q$ 次动作(其中，修改单元格内数据 $N_U$ 次，询问 GCD $N_Q$ 次) 。

你的任务是对 Bazza 提出的问题给出正确答案。
## 输入格式

- 第1行: $R$ 表示网格行数，$C$ 表示网格列数，$N$ 表示操作总数。
- 接下来的 $N$ 行: 每行表示一个动作，以动作发生的先后顺序给出。

表示每个动作的一行的格式如下：
- `update(P,Q,K)` 表示为： `1 P Q K`
- `calculate(P,Q,U,V)` 表示为： `2 P Q U V`


## 输出格式

共 $N_Q$ 行，对于每次询问，输出答案。

**说明**

`update(P,Q,K)`

- 当Bazza改变单元格中的整数时调用此函数，即把第 $P$ 行第 $Q$ 列的数改为 $K$。
- $P$: 单元格的行号（$0 \le P \le R - 1$ ）。
- $Q$: 单元格的列号（$0 \le Q \le C - 1$ ）。
- $K$: 这个单元格中新的整数（ $0 \le K \le 10^{18}$）。这个新整数可能与原来的整数相同。

`calculate(P,Q,U,V)`

- 该函数计算以 $(P, Q)$ 和 $(U, V)$ 为对角点的子矩阵中所有整数的最大公约数。这个范围是包含单元格 $(P, Q)$ 和 $(U, V)$ 的。

- 如果这个子矩阵中的所有整数都是 $0$，那么该函数返回 $0$。

- $P$: 子矩阵左上角单元格的行号（ $0 \le P \le R - 1$ ）。
- $Q$: 子矩阵左上角单元格的列号 （$ 0 \le Q \le C - 1$ ）。
- $U$: 子矩阵右下角单元格的行号（ $P \le U \le R - 1$ ）。
- $V$: 子矩阵右下角单元格的列号（ $Q \le V \le C - 1$ ）。
## 样例

### 样例输入 #1
```
1 1 64
2 0 0 0 0
2 0 0 0 0
2 0 0 0 0
1 0 0 5352072091165800
2 0 0 0 0
1 0 0 15571253006461152
1 0 0 36204425277916896
1 0 0 80686018200191040
1 0 0 720602986354563312
2 0 0 0 0
1 0 0 90705271009665312
2 0 0 0 0
1 0 0 583803309300971760
1 0 0 3317329660750560
2 0 0 0 0
2 0 0 0 0
2 0 0 0 0
1 0 0 84776821924066272
1 0 0 581927323100969664
1 0 0 93139161501610224
1 0 0 28340661117472704
1 0 0 74529074218959360
2 0 0 0 0
1 0 0 462419028676725120
1 0 0 4416867915235776
1 0 0 840475934823549024
1 0 0 8247617084266560
1 0 0 117571055091706944
1 0 0 839204903894797440
1 0 0 820805176764813240
1 0 0 82688722861897152
1 0 0 136422472061715840
1 0 0 555837014267982720
1 0 0 935087613488388360
1 0 0 17770822018565616
1 0 0 10726679222715456
1 0 0 621229604181863040
1 0 0 12477973789689408
2 0 0 0 0
1 0 0 227153207069268480
1 0 0 262037449583477568
1 0 0 562837835495871936
1 0 0 131875056326325312
1 0 0 922430858108760
1 0 0 763487168205041280
2 0 0 0 0
2 0 0 0 0
1 0 0 551850903114166656
1 0 0 243713152409807808
1 0 0 306811355534716032
1 0 0 115604757169181280
2 0 0 0 0
1 0 0 29254579698314880
1 0 0 35080064244441216
1 0 0 97819409912384160
1 0 0 34259332503876480
2 0 0 0 0
2 0 0 0 0
1 0 0 159548730492191040
1 0 0 11555364984947784
2 0 0 0 0
1 0 0 3373083100427040
2 0 0 0 0
2 0 0 0 0

```
### 样例输出 #1
```
0
0
0
5352072091165800
720602986354563312
90705271009665312
3317329660750560
3317329660750560
3317329660750560
74529074218959360
12477973789689408
763487168205041280
763487168205041280
115604757169181280
34259332503876480
34259332503876480
11555364984947784
3373083100427040
3373083100427040

```
## 提示

**子任务**

| 子任务 | 分数 | $R$ | $C$ | $N_U$ | $N_Q$ |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $\le 100$ | $\le 100$ | $\le 100$ | $\le 100$ |
| $2$ | $27$ | $\le 10$ | $\le 10^5$ | $\le 10^4$ | $\le 2.5\times 10^5$ |
| $3$ | $26$ | $\le 2 \times 10^3$ | $\le 2 \times 10^3$ | $\le 10^4$ | $\le 2.5 \times 10^5$ |
| $4$ | $17$ | $\le 10^9$ | $\le 10^9$ | $\le 10^4$ | $\le 2.5 \times 10^5$ |
| $5$ | $20$ | $\le 10^9$ | $\le 10^9$ | $\le 2.2 \times 10^4$ | $\le 2.5 \times 10^5$ |

**限制**

对于 $100\%$ 的数据，$1 \le R,C \le 10^9$，$0 \le K \le 10^{18}$，$K$ 表示 Bazza 放到单元格中的数字。


---

---
title: "[IOI 2009] Regions"
layout: "post"
diff: 省选/NOI-
pid: P5901
tag: ['2009', 'IOI', '交互题', 'Special Judge', 'O2优化']
---
# [IOI 2009] Regions
## 题目背景

## 滥用本题评测将被封号

IOI2009 D2T3

原题时间限制 8s，为节约评测资源，时间限制改为 4s。
## 题目描述

联合国区域发展委员会（The United Nations Regional Development Agency, UNRDA）有一个良好的组织结构。它任用了 $N$ 名委员，每名委员都属于几个地区中的一个。委员们按照其资历被编号为 $1$ 到 $N$ ，$1$ 号委员是主席，资历最高。委员所属地区被编号为 $1$ 到 $R$。除了主席之外所有委员都有一个直接导师。任何直接导师的资历都比他所指导的委员的资历要高。

我们称委员 $A$ 是委员 $B$ 的导师当且仅当 $A$ 是 $B$ 的直接导师或者 $A$ 是 $B$ 的直接导师的导师。显然，主席是所有其他委员的导师，没有任何两名委员互为导师。

现在，为了调查大量对 UNRDA 偏向某些地区的不平衡的组织结构的指控，UNRDA 想要建立一个计算机系统：在给定委员之间的直接导师关系的情况下，该系统可以回答下述形式的问题：给定两个地区 $r_1$ 和 $r_2$，要求系统回答委员会中有多少对委员 $e_1$ 和 $e_2$，满足 $e_1$ 属于 $r_1$，而 $e_2$ 属于 $r_2$，并且 $e_1$ 是 $e_2$ 的导师。每次询问都有两个参数 $r_1$ 和 $r_2$，结果是一个整数：满足上述条件的 $(e_1, e_2)$ 二元组的数量。

**任务**：编写一个程序，给定每个委员的地区和直接导师，**在线** 回答上述询问。

**强制在线将以交互的格式进行**。
## 输入格式

第一行包含三个整数 $N, R, Q$，分别由一个空格隔开，分别表示雇员人数，区域数和查询数。

接下来 $N$ 行按照资历的顺序给出了 $N$ 个委员的描述信息。其中第 $k$ 行描述了编号为 $k$ 的委员。第一行（描述主席的一行）包含一个整数：主席所属的地区 $H_1$。其余的 $N - 1$ 行，每行包含两个整数，以一个空格隔开分别表示委员 $k$ 的直接导师 $S_k$ 和委员 $k$ 所属的地区 $H_k$。

### 交互格式

在读入所有输入数据之后，你的程序必须依次从标准输入中读入询问，并将询问结果输出至标准输出。必须依次回答 $Q$ 个询问，每次回答一个。**在读入下一个询问之前，你必须先回答当前询问**。

每个询问是标准输入的一行，用两个不同整数 $r_1, r_2$ 表示。
## 输出格式

对查询的回答是标准输出的一行，包含一个整数，表示在 UNRDA 中有多少对委员 $e_1$ 和 $e_2$ 满足下述条件：$e_1$ 属于地区 $r_1$，$e_2$ 属于地区 $r_2$，并且 $e_1$ 是 $e_2$ 的导师。

**注意**：输入数据保证给出的任意询问的正确答案小于 $10 ^ 9$。

**特别注意**：为了正确地和交互库交互，你的程序必须 **在回答每次询问后刷新标准输出缓冲区**。你同样需要避免意外地在读入标准输入时堵住了输入流，这有可能在你使用 `scanf("%d\n", ...)` 的语句时发生。

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\n'`，也可以自动刷新缓冲区。
## 样例

### 样例输入 #1
```
6 3 4
1
1 2
1 3
2 3
2 3
5 1
1 2

1 3

2 3

3 1
```
### 样例输出 #1
```








1 [刷新缓冲区]

3 [刷新缓冲区]

2 [刷新缓冲区]

1 [刷新缓冲区]

```
## 提示

### 数据范围与约定

- 对于 $30\%$ 的数据，$N\leq 500$。
- 对于 $55\%$ 的数据，没有地区包含超过 $500$ 个委员。
- 同时满足上述两个条件的数据有 $15\%$，至少满足上述一个条件的数据有 $70\%$。
- 对于 $100\%$ 的数据，$1 \le N, Q \le 2 \times 10^5$，$1 \le H_k, r_1, r_2 \le R \le 2.5 \times 10^4$，$1 \le S_k < k$。


---

---
title: "[IOI 2009] Salesman"
layout: "post"
diff: 省选/NOI-
pid: P5902
tag: ['2009', 'IOI', 'O2优化']
---
# [IOI 2009] Salesman
## 题目背景

IOI2009 D2T4
## 题目描述

旅行商已经发现，最佳的陆上旅行计划是一个难以解决的计算问题，所以他将他的生意转移到多瑙河的线性世界。他有一条很快的船，可以在很短的时间内把他从沿河的任何地方送到任何地方，但不幸的是，这条船耗油量很大。旅行商向上游（靠近河流源头的方向）移动每一米的成本为 $U$ 美元，向下游（远离河流源头的方向）移动每一米的成本为 $D$ 美元。

沿河有 $N$ 个展销会，旅行商想参加。每场展销会只举行一天。对于每个展销会 $X$，旅行商知道它的日期 $T_X$（他买船后的天数为第 $0$ 天），集市的位置 $L_X$ 和他在这场集市上能获得的盈利 $M_X$。位置表示集市到河流源头的距离，以米为单位。他必须在位置为 $S$ 的家 **开始和结束** 他的旅程。

帮助旅行商选择参加哪些展销会（如果有的话）以及按什么顺序，这样他可以在旅行结束时最大化他的利润。旅行商的总利润是指他在参加集市时获得的美元减去他在河上下游旅行所花费的美元的总和。

请记住，如果展销会 $A$ 的举办时间早于展销会 $B$，则旅行商只能按此顺序去展销会（即，他不能先去展销会 $B$，然后再去展销会 $A$）。但是，如果两个集市在同一天举行，旅行商可以按任何顺序参观。旅行商一天去多少个集市是没有限制的，但他不能在同一个集市盈利两次。他可以经过他已经参观过的集市而一无所获。

**任务**：编写一个程序，给定所有展销会的日期，位置和旅行商的盈利额，以及旅行商的家的位置和他移动的代价，求出他在旅行结束时的最大利润。
## 输入格式

第一行包含四个整数 $N, U, D, S$，分别由一个空格隔开，分别表示展销会数，向上游（$U$）或下游（$D$）移动的单位代价，以及旅行商的家的位置。

接下来的 $N$ 行描述了 $N$ 个展销会。其中第 $k$ 行描述了第 $k$ 个展销会的信息，包含三个整数，分别由一个空格隔开，分别表示展销会日期 $T_k$，它的位置 $L_k$，以及旅行商在该次展销会能获得的的盈利 $M_k$。
## 输出格式

一行一个整数表示旅行商在旅行结束时的最大利润。
## 样例

### 样例输入 #1
```
4 5 3 100
2 80 100
20 125 130
10 75 150
5 120 110

```
### 样例输出 #1
```
50

```
## 提示

### 样例解释

在一个最优方案中，旅行商参加了编号为 $1$ 和 $3$ 的展销会（位置分别为 $80$ 和 $75$）。事件序列以及对应的利润如下：

- 旅行商从家出发，向上游移动 $20$ 米，花费 $100$ 美元。目前利润：$-100$。
- 旅行商参加展销会 $1$ 并赚取 $100$ 美元。目前利润：$0$。
- 旅行商向上游移动 $5$ 米，花费 $25$ 美元。目前利润 $-25$。
- 旅行商参加展销会 $3$ 并赚取 $150$ 美元。目前利润：$125$。
- 旅行商向下游移动 $25$ 米，回到自己的家，花费 $75$ 美元。最终利润：$50$。

### 数据范围与约定

- 对于 $60\%$ 的数据，没有两个展销会在同一天举行。
- 对于 $40\%$ 的数据，输入的所有数不超过 $5000$。
- 同时满足上述两个条件的数据有 $15\%$，至少满足上述一个条件的数据有 $85\%$。
- 对于 $100\%$ 的数据，$1 \le N, T_k \le 5\times 10^5$，$1 \le D \le U \le 10$，$1 \le S, L_k \le 5 \times 10^5 +1$，$1 \le M_k \le 4000$。


---

---
title: "[POI 2014] HOT-Hotels 加强版"
layout: "post"
diff: 省选/NOI-
pid: P5904
tag: ['2014', 'POI（波兰）', 'O2优化']
---
# [POI 2014] HOT-Hotels 加强版
## 题目背景

同 [[POI2014]HOT-Hotels](https://www.luogu.com.cn/problem/P3565)，数据范围加大到 $1 \le n \le 10^5$。

来源于 BZOJ4543。
## 题目描述

给出一棵有 $n$ 个点的树，求有多少组点 $(i,j,k)$ 满足 $i,j,k$ 两两之间的距离都相等。  

$(i,j,k)$ 与 $(i,k,j)$ 算作同一组。
## 输入格式

第一行一个整数 $n$。

接下来 $n-1$ 行，每行两个整数 $a,b$，表示在 $a,b$ 之间有一条边。
## 输出格式

一行一个整数，表示所有合法的点的组数。
## 样例

### 样例输入 #1
```
7
1 2
5 7
2 5
2 3
5 6
4 5

```
### 样例输出 #1
```
5

```
## 提示

对于 $100\%$ 的数据， $1\le n\le10^5, 1\le a\le b\le n$。


---

---
title: "[POI 2004] KAG"
layout: "post"
diff: 省选/NOI-
pid: P5913
tag: ['2004', 'POI（波兰）']
---
# [POI 2004] KAG
## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/8x4n4ya8.png)
## 输入格式

第一行一个整数 $k$ 表示 $k$ 组数据。

接下来描述每个数据开头两个数 $n$ 和 $m$，接下来 $m$ 行每行两个数表示一条边。
## 输出格式

输出共 $k$ 行，每行输出一个判定，如果该图为 c-algae 输出 `TAK`，否则输出 `NIE`。
## 样例

### 样例输入 #1
```
3
3 2
1 2
2 3
4 3
1 2
2 3
3 4
3 3
1 2
2 3
3 1
```
### 样例输出 #1
```
TAK
NIE
TAK

```
## 提示

对于 $100\%$ 的数据，$1\le k\le10$，$1\le n\le10^4$，$0\le m\le10^5$。


---

---
title: "[FJOI2015] 金币换位问题"
layout: "post"
diff: 省选/NOI-
pid: P5918
tag: ['2015', '福建', 'Special Judge']
---
# [FJOI2015] 金币换位问题
## 题目描述

给定一个 $n$，最开始序列长这样：

$$
\underbrace{\tt 111\cdots11}_{n \text{ 个 } 1}\underbrace{\tt 000\cdots00}_{n \text{ 个 } 0}\verb!__!
$$

现在要求用最少的交换步数，使得最终的序列为

$$
\underbrace{\tt 101010\cdots 1010}_{2\times n \text{ 个 } 01 \text{ 交替排列}}\verb!__!
$$

所谓交换是指**将相邻两个非空格的数一起挪到两个空格上**。

例如，下面是 $n=4$ 时的一组合法解：

- 初始状态：$\verb!11110000__!$。
- 第 $1$ 步：$\verb!__11000011!$。
- 第 $2$ 步：$\verb!101__00011!$。
- 第 $3$ 步：$\verb!1010100__1!$。
- 第 $4$ 步：$\verb!10101__001!$。
- 第 $5$ 步：$\verb!10101010__!$。

可以证明，最少的操作次数就是 $5$ 步。
## 输入格式

输入共一行一个整数 $n$。

## 输出格式

第一行输出最少移动步数。

接下来一行为移动方案，只要输出被移动的两个非空格格子左边那个的编号。详见样例。
## 样例

### 样例输入 #1
```
4
```
### 样例输出 #1
```
5
1 4 8 6 9
```
## 提示

对于 $100\%$ 的数据，$2<n\le 2\times 10^5$。


---

---
title: "[POI 2004] MAK"
layout: "post"
diff: 省选/NOI-
pid: P5919
tag: ['2004', 'POI（波兰）']
---
# [POI 2004] MAK
## 题目描述

置换就是 $n$ 个元素 $1$ 对 $1$ 的函数映射$p:\{1,2,\ldots,n\}\to\{1,2,\ldots,n\}$，一个置换 $p$ 的 `order` 等于最小的 $k\ge1$，且对所以的 $i=1,2,...,n$ 都满足：
$$p(p(...(p(i))...))=i$$
（共 $k$ 次）


举个例子，对于 $3$ 个元素的 `order` $p(1)=3,p(2)=2,p(3)=1$ 为 $ 2$，因为$p(p(1))=1,p(p(2))=2,p(p(3))=3$。

对于给定的 $n$ 我们想要一个长度为 $n$ 的置换的 `order` 尽量大。比如说长度为 $5$ 的置换的 order 最大为 $6$。

一个例子就是 $p(1)=4,p(2)=5,p(3)=2,p(4)=1,p(5)=3$。

对于所有使得 `order` 最大的置换中，我们要找到字典序最小的那个。

更精确来说，我们说置换 $p$ 小于置换 $r$，即存在一个 $i$，使得对于所有 $j<i$ 都满足 $p(j)=r(j)$ 且 $p(i)<r(i)$。那么对于长度为 $5$ 的置换中最小的那个为 $p(1)=2,p(2)=1,p(3)=4,p(4)=5,p(5)=3$。 
## 输入格式

第一行一个数 $d$ 表示一共 $d$ 组数据。

接下来 $d$ 行表示长度为 $n_1,n_2,...,n_d$。
## 输出格式

输出 $d$ 行每行一个最优置换。
## 样例

### 样例输入 #1
```
2
5
14
```
### 样例输出 #1
```
2 1 4 5 3
2 3 1 5 6 7 4 9 10 11 12 13 14 8
```
## 提示

对于 $100\%$ 的数据，$1\le d\le10$，$1\le n_i\le10^4$。


---

---
title: "[POI 1997] 跳"
layout: "post"
diff: 省选/NOI-
pid: P5940
tag: ['1997', 'POI（波兰）']
---
# [POI 1997] 跳
## 题目背景

在一个无限长的棋盘上玩一种跳棋游戏。
## 题目描述

其中棋盘被划分成许多区域，每一个区域中可以放置多个的棋子。

规定某一个区域的编号为 $0$，在它开始往左边连续的区域编号为 $-1,-2,-3,…,$在它的右边连续区域编号为 $1,2,3,…,$ ，若区域 $P$ 有棋子，那么棋子有两种跳法：

- 向左跳：则方格 $P-1$ 和 $ P-2 $ 中应增加一枚棋子，方格 $P$ 中应减少一枚棋子。 

- 向右跳：则方格 $P$ 和 $P+1$ 中应减少一枚棋子，方格 $P+2$ 中应增加一枚棋子。

对于给定的初始棋局，经过若干步跳棋后，总可以找到一种目标，就是任意两个相邻的区域棋子数目不超过 $1$ 。

你的任务是对给定的一种初始棋局，找到最终的目标棋局。
## 输入格式

第一行为一个正整数 $n$， 表示棋盘中放置棋子的状态数。

下面的 $n$ 行描述了每个状态，由两个用空格分隔的整数组成，第一个整数表示区域的位置（不超过 $10000$），第二个整数表示该区域放置的棋子数目（不超过 $100000000$）。
## 输出格式

输出最终的棋局，这一行包含若干个整数，其中每一个整数为有棋子的区域编号，所有的区域按从小到大排列。
## 样例

### 样例输入 #1
```
2
0 5
3 3
```
### 样例输出 #1
```
-4 -1 1 3 5
```
## 提示

对于 $100\%$ 的数据，$1\le n \le 10000$。


---

---
title: "[POI 2002] 出圈游戏"
layout: "post"
diff: 省选/NOI-
pid: P5944
tag: ['2002', 'POI（波兰）']
---
# [POI 2002] 出圈游戏
## 题目描述

有编号从 $1$ 到 $n$ 的 $n$ 个小朋友在玩一种出圈的游戏,编号为 $i+1 $ 的小朋友站在编号为 $i $ 小朋友左边。编号为 $1 $ 的小朋友站在编号为 $n$ 的小朋友左边。首先编号为 $1$ 的小朋友开始报数，接着站在左边的小朋友顺序报数，直到数到某个数字 $K$ 时就出圈。直到所有的小朋友都出圈，则游戏完毕。

现在给出出圈的顺序，求最小的 $K$。
## 输入格式

第一行有一个正整数 $n$。

第二行有 $n$ 个整数 $a_i$。其中第 $i$ 个整数表示编号为 $i$ 的小朋友第 $a_i$ 个出圈。
## 输出格式

求最小的 $K$，如果不存在，则输出一个单词 `NIE`。
## 样例

### 样例输入 #1
```
4
1 4 3 2
```
### 样例输出 #1
```
NIE
```
## 提示

对于 $100\%$ 的数据，$2\le n\le 20$。

---

$\text{upd 2022.8.24}$：新增加一组 Hack 数据。


---

---
title: "[POI 2018] 水箱"
layout: "post"
diff: 省选/NOI-
pid: P5952
tag: ['2018', 'POI（波兰）']
---
# [POI 2018] 水箱
## 题目描述

在地面上有一个水箱，它的俯视图被划分成了 $n$ 行 $m$ 列个方格，相邻两个方格之间有一堵厚度可以忽略不计的墙，水箱与外界之间有一堵高度无穷大的墙，因此水不可能漏到外面。已知水箱内每个格子的高度只能是 $[0,H]$ 之间的整数，请统计有多少可能的水位情况。

因为答案可能很大，请对 $10^9+7$ 取模输出。

我们说两种情况是不同的当且仅当存在至少一个方格的水位在两个情况中不同。
## 输入格式

第一行包含三个正整数 $n,m,H$。
接下来 $n$ 行，每行 $m-1$ 个整数$ a[i][j](1\le a[i][j]\le H)$，表示 $(i,j)$ 和 $(i,j+1)$ 之间的墙的高度。

接下来 $n-1$ 行，每行 $m$ 个整数 $b[i][j](1\le b[i][j]\le H)$ ，表示 $(i,j)$ 和 $(i+1,j)$ 之间的墙的高度。
## 输出格式

输出一行一个整数，即方案数模 $10^9+7$ 的结果。
## 样例

### 样例输入 #1
```
3 2 2
1
1
1
1 2
1 1
```
### 样例输出 #1
```
65

```
## 提示

对于 $100\%$ 的数据，$n\times m\le500000$，$1\le H\le10^9$。

----

### 样例解释：

要么全部格子水位都是 $2$，要么全部格子水位都在 $[0,1]$ 之间，共 $1+2^6=65$ 种情况。


---

---
title: "[POI 2018] Pionek"
layout: "post"
diff: 省选/NOI-
pid: P5955
tag: ['2018', 'POI（波兰）']
---
# [POI 2018] Pionek
## 题目描述

在无限大的二维平面的原点 $(0,0)$ 放置着一个棋子。你有 $n$ 条可用的移动指令，每条指令可以用一个二维整数向量表示。每条指令可以执行 $1$ 次或者不执行。棋子可以重复经过同一个点，两条指令的方向向量也可能相同。你的目标是让棋子最终离原点的**欧几里得距离**最远，请问这个最远距离是多少？
## 输入格式

第一行包含一个正整数 $n$，表示指令条数。

接下来 $n$ 行，每行两个整数 $x,y$，表示你可以从 $(a,b)$ 移动到 $(a+x,b+y)$。
## 输出格式

输出一行一个整数，即最大距离的平方。
## 样例

### 样例输入 #1
```
5
2 -2
-2 -2
0 2
3 1
-3 1
```
### 样例输出 #1
```
26
```
## 提示

对于 $100\%$ 的数据，$n\le 2 \times 10^5$，$|x|,|y| \le 10^4$。

-----

### 样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/aiztesh5.png)


---

---
title: "[POI 2016] Hydrorozgrywka"
layout: "post"
diff: 省选/NOI-
pid: P5966
tag: ['2016', 'POI（波兰）']
---
# [POI 2016] Hydrorozgrywka
## 题目描述

给定一个 $n$ 个点 $m$ 条边的无向连通图，保证每条边最多属于一个环。

两个人在这张图上玩游戏，一开始他们会在某个节点放一个棋子，然后依次移动这个棋子，已经走过的边不能再走，谁不能移动谁就输了。

请求出所有先手必胜的策略中游戏开始时放棋子的位置。
## 输入格式

第一行包含两个正整数 $ n,m$，表示点数和边数。

接下来 $m$ 行每行包含两个正整数 $a,b$，表示 $a$ 点到 $b$ 点之间有一条无向边。
## 输出格式

包含 $n$ 行，对于第 $i$ 行，如果在 $i$ 点放棋子先手必胜，输出 `1`，否则输出 `2`。
## 样例

### 样例输入 #1
```
6 7
1 2
2 3
3 1
3 4
4 5
5 6
6 3
```
### 样例输出 #1
```
1
1
1
2
1
2
```
## 提示

对于 $100\%$ 的数据，$3\le n,m\le 5 \times 10^5$，$1\le a,b\le n$，$a\ne b$。


---

---
title: "[CEOI 2006] ANTENNA"
layout: "post"
diff: 省选/NOI-
pid: P5974
tag: ['2006', 'Special Judge', 'CEOI（中欧）']
---
# [CEOI 2006] ANTENNA
## 题目描述

给出 $N$ 个点的坐标，要求能够覆盖其中至少 $K$ 个点的圆的最小半径及圆心位置。
## 输入格式

第一行两个整数 $N,K$。

接下来的 $N$ 行，每行两个整数，为每个点的坐标。
## 输出格式

第一行为圆的半径。

第二行为圆心的坐标。

使用 SPJ，满足以下两个条件才正确：

- $R$ 误差不超过 $10^{-4}$。

- 虽然多组解可以输出任意一组，但以你输出的坐标为圆心的圆如果以 $R+0.0002$为半径至少应该覆盖 $K$个点。
## 样例

### 样例输入 #1
```
10 5 
1 8 
2 6 
4 8 
2 2 
9 7 
8 5 
5 3 
3 3 
4 6 
4 1 
```
### 样例输出 #1
```
2.236068 
3 4 
```
## 提示

对于 $100\%$ 的数据， $2\le K\le N\le 500$，$0\le X,Y\le 10^4$。


---

---
title: "[PA 2019] Trzy kule"
layout: "post"
diff: 省选/NOI-
pid: P5982
tag: ['2019', 'PA（波兰）']
---
# [PA 2019] Trzy kule
## 题目描述

对于两个长度为 $n$ 的 $01$ 串 $a_{1..n},b_{1..n}$，定义它们的距离 $\operatorname{d(a,b)}=|a_1-b_1|+|a_2-b_2|+...+|a_n-b_n|$。

给定三个长度为 $n$的 $01$ 串 $s_1,s_2,s_3$以及三个非负整数 $r_1,r_2,r_3(0\le r_i\le n)$，问有多少个长度为 $n$ 的 $01$ 串 $S$满足$\operatorname{d(S,s[1])}\le r_1,\operatorname{d(S,s[2])}\le r_2,\operatorname{d(S,s[3])}\le r_3$ 这三个不等式中至少有一个成立。
## 输入格式

第一行一个正整数 $n$。

第二行一个非负整数 $r_1$，然后一个长度为 $n$ 的 $01$ 串 $s_1$。

第三行一个非负整数 $r_2$，然后一个长度为 $n$ 的 $01$ 串 $s_2$。

第四行一个非负整数 $r_3$，然后一个长度为 $n$  的 $01$ 串 $s_3$。
## 输出格式

输出一行一个整数，即满足条件的 $S$ 的数量模 $10^9+7$。
## 样例

### 样例输入 #1
```
5
2 10110
0 11010
1 00000
```
### 样例输出 #1
```
19
```
## 提示

对于 $100\%$ 的数据，$1\le n\le 10^4$。


---

---
title: "[PA 2019] Osady i warownie 2"
layout: "post"
diff: 省选/NOI-
pid: P5983
tag: ['2019', 'PA（波兰）']
---
# [PA 2019] Osady i warownie 2
## 题目描述

$n\times m$ 的网格，从上到下依次为第 $0$ 到 $n-1$ 行，从左到右依次为第 $0$ 到 $m-1$ 列，每个点都不是障碍格。

定义一条从起点 $(0,0)$ 到终点 $(n-1,m-1)$ 的路径是合法的，当且仅当这条路径经过恰好 $n+m-1$ 个格子(包括起点和终点)，且每一步要么往右走一格，要么往下走一格。当然，这条路径不能经过障碍格(包括起点和终点)。

你有一个 $int$ 变量 $v=0$，你现在需要模拟 $k$ 次操作，每次操作会给出三个非负整数 $r,c,z$，令 $x=(r \operatorname{xor}
 v)\bmod n,y=(c \operatorname{xor}
 v)\bmod m$：
1. 如果 $(x,y)$ 是障碍格，那么忽略这次操作，输出 `NIE`。
2. 否则如果将 $(x,y)$ 变成障碍格后仍然存在合法路径，那么将 $(x,y)$ 变成障碍格，输出 `NIE`。
3. 否则如果将 $(x,y)$ 变成障碍格后不存在合法路径，那么输出 `TAK`，并将 $v $ 修改为 $v \operatorname{xor} z$。
## 输入格式

第一行三个正整数 $n,m,k$。

接下来 $k$ 行，每行三个非负整数 $r,c,z$。
## 输出格式

对于每个操作输出一行 `TAK` 或 `NIE`。
## 样例

### 样例输入 #1
```
3 5 7
0 1 123
1 0 0
4 8 0
2 2 16
2 3 0
18 19 17
3 0 0
```
### 样例输出 #1
```
NIE
TAK
NIE
TAK
NIE
TAK
NIE
```
## 提示

对于 $100\%$ 的数据,$2\le n,m\le 10^5$， $1\le k\le 10^6$，$0\le r,c,z<2^{20}$。

----


### 解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/e5k1plm4.png)


---

---
title: "[PA 2019] Muzyka pop"
layout: "post"
diff: 省选/NOI-
pid: P5985
tag: ['2019', 'PA（波兰）']
---
# [PA 2019] Muzyka pop
## 题目描述

给定 $ n$ 个整数 $a_{1..n}$，请找到 $n$ 个非负整数 $b_{1..n}$，使得 $a_1\times \operatorname{f(b_1)}+a_2\times \operatorname{f(b_2)}+...+a_n\times \operatorname{f(b_n)}$ 的值最大，其中 $\operatorname{f(x)} $ 为 $x$ 在二进制下的 $1$ 的个数。

你找到的这 $n$ 个非负整数 $b_{1..n}$ 需要满足 $0\le b_1<b_2<...<b_n\le m$。
## 输入格式

第一行两个整数 $n,m$。

第二行包含 $n$ 个整数 $a_1,a_2,...,a_n$。
## 输出格式

输出一行一个整数，即 $a_1\times \operatorname{f(b_1)}+a_2\times \operatorname{f(b_2)}+...+a_n\times \operatorname{f(b_n)}$ 的最大值。
## 样例

### 样例输入 #1
```
3 5
2 -1 3
```
### 样例输出 #1
```
9
```
## 提示

对于 $100\%$ 的数据，$1\le n\le 200$，$n-1\le m\le 10^{18}$，$|a_i|\le 10^{14}$。

----

### 解释：

$b_1=3,b_2=4,b_3=5$，则答案为 $2\times 2+(-1)\times 1+3\times 2=9$。


---

---
title: "[PA 2019] Szprotki i szczupaki"
layout: "post"
diff: 省选/NOI-
pid: P5986
tag: ['2019', 'PA（波兰）']
---
# [PA 2019] Szprotki i szczupaki
## 题目描述

在湖中有 $n$ 条小鱼，第 $i$ 条小鱼的重量为 $w_i$。

共 $q$ 个操作，每个操作是下面 $3$ 种之一：

- `1 s k` 假如现在来了一条重量为 $s$ 的大鲨鱼，它的目标是让自己的重量达到至少 $k$ (包含 $k$)，问它至少需要吃掉多少条小鱼？如果鲨鱼当前的重量严格大于要吃掉的小鱼的重量 $w$，那么它可以吃掉这条小鱼，并使得自己的重量增加 $w$。
- `2 w` 添加一条重量为 $w$ 的小鱼。
- `3 w` 删除一条重量为 $w$ 的小鱼，保证存在至少一条这样的小鱼。
## 输入格式

第一行一个正整数 $n$。

第二行 $n$ 个正整数 $w_1,w_2,...,w_n$。

第三行一个正整数 $q$。

接下来 $q$ 行，每行若干个整数，描述一个操作。
## 输出格式

对于每个询问，如果有解，输出一行一个整数，即最少需要吃掉的小鱼数量，如果无解，输出 `-1`。
## 样例

### 样例输入 #1
```
4
1 4 8 1
15
1 2 3
1 2 4
1 2 5
1 3 3
1 3 5
1 3 16
1 4 16
1 8 17
1 100 101
1 100 115
1 3 9
2 2
1 3 9
3 4
1 3 9
```
### 样例输出 #1
```
1
2
-1
0
2
4
3
2
1
-1
3
2
-1
```
## 提示

对于 $100\%$ 的数据，$1\le w_i\le 10^{12}$，$1\le s,k\le 10^{18}$ ，$1\le w\le 10^{12}$，$1\le n\le 3\times 10^5$，$1\le q\le 10^5$。


---

---
title: "[PA 2019] Terytoria"
layout: "post"
diff: 省选/NOI-
pid: P5987
tag: ['2019', 'O2优化', 'PA（波兰）']
---
# [PA 2019] Terytoria
## 题目描述

在二维平面直角坐标系上，有一个长度为 $X$，宽度为 $Y$ 的地图，注意这个地图的左边界和右边界是连通的，下边界和上边界也是连通的。

在这个地图里，有 $X\times Y$ 个格子以及 $n$ 个边平行坐标轴的矩形。你只知道每个矩形两个对顶点的坐标，请问在最好情况下，被所有 $n$ 个矩形都覆盖住的格子数量有多少？
## 输入格式

第一行三个正整数 $n,X,Y$。

接下来 $n$ 行，每行四个整数 $x_1,y_1,x_2,y_2(0\le x_1,x_2<X,0\le y_1,y_2<Y,x_1\ne x_2,y_1\ne y_2)$，表示第 $i$ 个矩形两个对顶点的坐标为 $(x_1,y_1)$ 和 $(x_2,y_2)$。
## 输出格式

输出一行一个整数，即被所有 $n$ 个矩形都覆盖住的格子数量的最大可能值。
## 样例

### 样例输入 #1
```
2 10 7
2 1 8 6
5 2 4 4
```
### 样例输出 #1
```
15
```
## 提示

对于 $100\%$ 的数据，$1\le n\le 5\times 10^5$，$2\le X,Y\le 10^9$。


### 样例解释：

下图列举了一些情况，其中第3种情况是最优的：

![](https://cdn.luogu.com.cn/upload/image_hosting/9vwqe130.png)


---

---
title: "[PA 2014] Muzeum"
layout: "post"
diff: 省选/NOI-
pid: P5996
tag: ['2014', 'PA（波兰）']
---
# [PA 2014] Muzeum
## 题目描述

吉丽的漫展有 $n$ 件手办和 $m$ 名警卫。

现在我们对其建立平面直角坐标系，每个手办和警卫都可以看做一个点。警卫们的目光都朝着 $y$ 轴负方向，且都有相同大小的视角。警卫可以看见自己视角内（包括边界上的点）的所有手办，不用考虑视线的遮挡。

你打算抢劫吉丽的漫展，但不想被警卫发现。为了实施这次抢劫计划，你可以事先贿赂某些警卫，让他们闭上眼睛。只要某件手办不在任何睁着眼睛的警卫的视野内，你就可以偷走它。你知道每件手办的价格，以及每位警卫需要接受多少钱的贿赂。你想知道自己的最大收益是多少。
## 输入格式

第一行两个整数 $n,m$，分别表示手办的数量和警卫的数量。

第二行两个整数 $w,h$，表示每个警卫的视角的一半的正切值是 $\dfrac{w}{h}$。（见配图）

接下来 $n$ 行，每行三个整数 $x_i,y_i,v_i$，表示手办的坐标为 $(x_i,y_i)$，价格为 $v_i$。

接下来 $m$ 行，格式同上，表示警卫的坐标为 $(x_i,y_i)$，需接受贿赂的金额为 $v_i$。

**保证每个点最多只有一个手办或一个警卫。**
## 输出格式

输出仅一行表示最大收益。
## 样例

### 样例输入 #1
```
5 3
2 3
2 6 2
5 1 3
5 5 8
7 3 4
8 6 1
3 8 3
4 3 5
5 7 6
```
### 样例输出 #1
```
6
```
## 提示

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^5$，$1\le w,h\le 10^9$，$-10^9\le x_i,y_i\le 10^9$，$1\le v_i\le 10^9$。


----

### 样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/zxt0if8b.png)

贿赂 售价为 $3+6=9$ 元的两个警卫，偷走 价值共$2+8+4+1=15$ 元的 $4$ 个手办，收益 $15-9=6$ 元。



---

---
title: "[PA 2014] Plemiona"
layout: "post"
diff: 省选/NOI-
pid: P5998
tag: ['2014', 'PA（波兰）']
---
# [PA 2014] Plemiona
## 题目描述

远古时代，在吉丽王国的版图上分布着 $n$ 个部落。建立平面直角坐标系后，每个部落都是一个边平行于坐标轴的矩形。有些地盘可能同时属于多个部落。随着时间推移，部落之间会发生融合。具体来说，若两个部落的公共面积严格大于零，它们会合并成一个新的部落，新部落的形状是包含原来两个部落的最小矩形（边平行于坐标轴）。

数百万年后，部落之间终于达到了稳定状态（任两个部落都不能再合并了），然而吉丽也已经老了。他想知道最终还剩下几个部落，以及各个部落的位置。你能替他完成遗业吗？
## 输入格式

第一行一个整数 $n$，表示远古时代的部落数量。

接下来 $n$ 行，每行四个整数 $x_1,x_2,y_1,y_2$，表示部落的坐标。
## 输出格式

第一行输出一个整数 $m$，表示稳定后还剩下的部落数量。
接下来 $m$ 行，每行四个整数 $x_1,x_2,y_1,y_2$，表示部落的坐标。

请按照字典序（先比较 $x_1$，若 $x_1$ 相等则比较 $x_2$，以此类推）从小到大输出。
## 样例

### 样例输入 #1
```
5
7 8 1 4
1 5 2 3
4 5 2 7
2 3 5 9
4 6 8 9
```
### 样例输出 #1
```
2
1 6 2 9
7 8 1 4

```
## 提示

对于 $100\%$ 的数据，$1\le n\le 10^5$，$0\le x1<x2\le 10^6$，$0\le y1<y2\le 10^6$。


---

---
title: "[CEOI 2016] kangaroo"
layout: "post"
diff: 省选/NOI-
pid: P5999
tag: ['2016', 'CEOI（中欧）']
---
# [CEOI 2016] kangaroo
## 题目描述

有一个园子，里面有 $n$ 个草丛排成一排，标号 $1\sim n$，有一个袋鼠，从 $s$ 出发，每次跳一步跳到一个其他的草丛，经过每个草丛恰好一次，最终到达 $t$。显然他会跳跃 $n-1$ 次。为了不被人类发现，袋鼠每次跳跃的方向必须与前一次不同。

具体地，如果他现在在 $now$，他是从 $prev $ 跳跃一次到达 $now$ 的，然后他跳跃一次到达 $next$：

- 那么如果 $prev<now$，就必须有 $next<now$；

- 如果 $now<prev$，就必须有 $now<next$。

问从 $s$ 到 $t$ 的方案数模 $10^9+7$ 的结果。

两个路线不同，当且仅当草丛被访问的顺序不同。

保证至少有一种方案。

初始时可以往任意方向跳。
## 输入格式

 一行三个整数 $n,s,t$。


## 输出格式

 一行一个整数，代表答案。
## 样例

### 样例输入 #1
```
4 2 3
```
### 样例输出 #1
```
2
```
## 提示

对于 $100\%$ 的数据，$2\le n\le 2\times 10^3$，$1\le s,t\le n$


---

---
title: "[CEOI 2016] match"
layout: "post"
diff: 省选/NOI-
pid: P6000
tag: ['2016', 'CEOI（中欧）']
---
# [CEOI 2016] match
## 题目描述

给你一个由小写字母组成的字符串 $s$，要你构造一个字典序最小的（认为左括号的字典序比右括号小）合法的括号序列与这个字符串匹配。

字符串和括号序列匹配定义为：首先长度必须相等，其次对于一对匹配的左括号和右括号 $i,j$，必须有 $s_i=s_j$。


无解输出 `-1`。
## 输入格式

一行一个字符串 $s$。
## 输出格式

一行一个括号序列或者 `-1`。
## 样例

### 样例输入 #1
```
abbaaa
```
### 样例输出 #1
```
(()())
```
## 提示

对于 $100\%$ 的数据，$2\le n\le 10^5$。


---

---
title: "[CEOI 2016] popeala"
layout: "post"
diff: 省选/NOI-
pid: P6001
tag: ['2016', 'CEOI（中欧）']
---
# [CEOI 2016] popeala
## 题目描述

你办了一场比赛，有 $n$ 个人参加，只有一道题，有 $m$ 个数据点，标号为 $1\sim m$，每个测试点都有一个分数 $a_i$。

现在所有选手已经提交了程序并且测评完了，你知道每个人都能通过哪些测试点。

你现在要安排捆绑测试的方式，把数据点划分为若干个连续的区间，每个区间至少有一个测试点。每个区间只要有一个测试点错误就不会得分，如果所有
点都正确得分为所有测试点的分数的和。

**你的目的是最小化所有人的得分和**。你需要对 $1\le i\le S$，输出当把所有测试点划分为 $i$ 组时，最小的所有人分数和。
## 输入格式

第一行三个整数 $n,m,S$。

接下来一行 $m$ 个整数，代表 $a_i$。

接下来 $n$ 行每行一个长度为 $m$ 的 $01$ 串，代表第 $i$ 个人是否通过了第 $j$ 个测试点。
## 输出格式

$S$ 行，每行一个整数，代表当划分为 $i$ 个捆绑测试点时所有人分数和的最小值。
## 样例

### 样例输入 #1
```
2 3 3
4 3 5
101
110
```
### 样例输出 #1
```
0
8
16
```
## 提示

对于 $100\%$ 的数据，$1\le n\le 50$，$1\le m\le 2\times 10^4$，$S\le \min(50,m)，1\le a_i \le 10^4$，$\Sigma a_i\times n\le 2\times10^9$。



---

---
title: "[RC-02] XOR"
layout: "post"
diff: 省选/NOI-
pid: P6053
tag: []
---
# [RC-02] XOR
## 题目背景

FangZeLi 喜欢异或，所以就有了这道题（然而这并不是他出这种题的理由）。
## 题目描述

**注意，本题中一切 $\sum$ 均表示求异或和！**

一棵 $n$ 个节点，$n-1$ 条边的有根树，初始时以 $1$ 节点为根。

这棵树上的每个节点 $i$ 都有其点权 $V_{i}$。

令函数 $\operatorname{Xor}(x)=\sum_{y\in  \operatorname{Subtree}(x)}{V_{y}}$，其中 $\operatorname{Subtree}(x)$ 表示 $x$ 的子树。

现需支持以下五种操作：

1. `1 x`，表示将 $x$ 换为根，且查询 $\sum_{i=1}^{n}{\operatorname{Xor}(i)}$。
2. `2 x y`，表示令 $V_{x}=y$。
3. `3 x y` ，表示查询 $\operatorname{LCA}(x,y)$。
4. `4 x y`，表示查询 $x$ 到 $y$ 路径上的点的点权异或和。
5. `5 x`，表示查询 $\operatorname{Xor}(x)$。
## 输入格式

第一行三个整数，$n,m,q$，分别表示节点数，$1$ 操作个数，其余操作个数。

接下来一行 $n$ 个整数，表示 $V_{1}\dots V_{n}$。

接下来 $n-1$ 行，每行两个整数 $x,y$，表示 $x$ 和 $y$ 间有一条边。

接下来 $m+q$ 行，每行两到三个整数，第一个数为操作序号，接下来为相应的操作。
## 输出格式

若干行，表示 $1,3,4,5$ 操作的结果。
## 样例

### 样例输入 #1
```
5 4 4
0 0 2 2 1
1 2
1 3
2 4
2 5
1 1
1 1
1 1
2 3 0
4 3 3
5 1
1 2
3 1 2

```
### 样例输出 #1
```
3
3
3
0
3
0
2

```
### 样例输入 #2
```
10 8 8
5 6 2 1 0 4 0 0 0 3
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9
5 10
3 10 9
2 1 6
1 5
1 4
1 7
1 7
5 1
1 1
3 1 5
1 7
1 9
2 5 0
4 9 6
1 10
4 10 7
5 1

```
### 样例输出 #2
```
2
3
3
3
3
2
3
1
3
7
7
7
1
0

```
## 提示

对于所有数据，保证 $100\le n,m,q\le 10^6$，$0\le V_i\le 2^{31}-1$。详细数据范围如下表。

| 测试点编号 | 时间限制/秒 | $n$                | $m$                | $q$                 |
| :-----: | :--------: | :------------------: | :------------------: | :-------------------: |
| $1$   |  $1$     | $ 100 $            | $ 100 $            | $ 4 \times 10 ^ 5 $ |
| $2,3$   |$1$     | $ 100 $            | $10^ { 6 }$ | $ 4 \times 10 ^ 5 $ |
| $4,5$   | $1$     | $ 10 ^ 4$ | $100$              | $ 4 \times 10 ^ 5 $ |
| $6,7,8$ |  $ 1 $   | $ 10 ^ 4$ | $10 ^ 6$    | $ 4 \times 10 ^ 5 $ |
| $9$    | $ 1.8 $ | $ 10 ^ 6$ | $100$              | $ 10^6$      |
| $10$   | $ 2.3 $ | $ 10 ^ 6$ | $ 10^6$     | $ 10 ^ 6$    |


---

---
title: "[RC-02] GCD"
layout: "post"
diff: 省选/NOI-
pid: P6055
tag: []
---
# [RC-02] GCD
## 题目背景

小 A：数论题真是无聊呢，一天到晚枚举二元组、三元组，太无聊了。

小 B：对呀对呀，都是套路。

小 A：要不我们试试枚举四元组？

小 B：......

于是就有了这道题。

## 题目描述

给出 $N$，求：

$$
\sum_{i=1}^N\sum_{j=1}^N\sum_{p=1}^{\lfloor\frac{N}{j}\rfloor}\sum_{q=1}^{\lfloor\frac{N}{j}\rfloor}[\gcd(i,j)=1][\gcd(p,q)=1]
$$

答案模 $998244353$。

$[]$ 是条件表达式。当括号里面的式子成立时值为 $1$，否则为 $0$。
## 输入格式

仅一行一个整数，为 $N$。
## 输出格式

输出一个整数，为所求答案模上 $998244353$ 的值。
## 样例

### 样例输入 #1
```
50

```
### 样例输出 #1
```
104527

```
### 样例输入 #2
```
200

```
### 样例输出 #2
```
6664993

```
### 样例输入 #3
```
500000

```
### 样例输出 #3
```
835964450

```
### 样例输入 #4
```
10000000

```
### 样例输出 #4
```
503290049
```
### 样例输入 #5
```
100000000
```
### 样例输出 #5
```
712748411

```
### 样例输入 #6
```
1000000000
```
### 样例输出 #6
```
845640070

```
## 提示

对于所有数据，保证 $1\le N\le 2\times10^9$，所有测试点的时限均为 $1\text{s}$，空间限制均为 $500\text{MB}$。

| 测试点编号 | $N$               |
| ---------- | ----------------- |
| $1$          | $\le 100$         |
| $2$          | $\le 400$         |
| $3,4,5,6$ | $\le10^6$ |
| $7,8$       | $\le 2\times10^7$ |
| $9$          | $\le 2\times10^8$ |
| $10$         | $\le 2\times10^9$ |

这题其实可以搞一个测试点多组数据，但良心的出题人为了多给你们一点部分分，就决定只来一组数据。

idea 源自 @Fee_cle6418，题目的题面，标算，数据源自 @FangZeLi。


---

---
title: "[USACO05JAN] Muddy Fields G"
layout: "post"
diff: 省选/NOI-
pid: P6062
tag: ['2005', 'USACO']
---
# [USACO05JAN] Muddy Fields G
## 题目描述

大雨侵袭了奶牛们的牧场。

牧场是一个 $R \times C$ 的矩形，其中 $1 \leq R,C \leq 50$。大雨将没有长草的土地弄得泥泞不堪，可是小心的奶牛们不想在吃草的时候弄脏她们的蹄子。为了防止她们的蹄子被弄脏，约翰决定在泥泞的牧场里放置一些木板。每一块木板的宽度为 $1$ 个单位，长度任意，每一个板必须放置在平行于牧场的泥地里。 

约翰想使用最少的木板覆盖所有的泥地．一个木板可以重叠在另一个木板上，但是不能放在草地上。
## 输入格式

第一行两个整数 $R,C$。

接下来 $R$ 行，每行 $C$ 个字符，描述牧场，其中 `*` 为泥地，`.` 为草地。
## 输出格式

输出一个整数，最少需要多少木板。
## 样例

### 样例输入 #1
```
4 4
*.*.
.***
***.
..*.
```
### 样例输出 #1
```
4
```


---

---
title: "最小路径"
layout: "post"
diff: 省选/NOI-
pid: P6074
tag: []
---
# 最小路径
## 题目描述

一棵 $n$ 个点的树，每个点两个点权 $a_i$ 和 $b_i$，找一条长度为 $m$ 的简单路径，使 $\frac{\sum a_i}{\sum b_i}$ 最小。无解输出 $-1$。
## 输入格式

第一行两个正整数 $n$ 和 $m$。  
第二行 $n$ 个正整数 $a_i$。  
第三行 $n$ 个正整数 $b_i$。  
以下 $n-1$ 行，每行两个正整数 $u,v$，为一条边的两个端点。
## 输出格式

输出最小值，**保留两位小数**。
## 样例

### 样例输入 #1
```
3 1
2 3 3
6 6 6
1 2
2 3
```
### 样例输出 #1
```
0.42
```
### 样例输入 #2
```
9 2
9 4 4 1 6 5 1 9 5
8 3 3 1 5 4 1 8 4
1 2
2 3
3 4
3 5
1 6
6 7
7 8
6 9
```
### 样例输出 #2
```
1.15
```
## 提示

subtask 1 $20$：$n\le 100$，$m\le n$，$1\le a_i,b_i\le 2000$。

subtask 2 $40$：$n\le 10^4$，$m\le n$，$1\le a_i,b_i\le 2000$。

subtask 3 $40$：$n\le 2\times 10^5$，$m\le n$，$1\le a_i,b_i\le 2000$。

对于 $100\%$ 的数据，$1\le n\le 2\times 10^5$，$1\le m\le n$，$1\le a_i,b_i\le 2000$。


---

---
title: "[BalticOI 2007] Escape"
layout: "post"
diff: 省选/NOI-
pid: P6077
tag: ['2007', 'BalticOI（波罗的海）']
---
# [BalticOI 2007] Escape
## 题目描述

战犯们企图逃离监狱，他们详细地计划了如何逃出监狱本身，逃出监狱之后他们希望在附近的一个村子里找到掩护。

村子（下图中的 B）和监狱（图中的 A）中间有一个峡谷，这个峡谷也是有士兵守卫的。守卫峡谷的士兵们坐在岗哨上很少走动，每个士兵的观察范围是 $100$ 米。士兵所处位置决定了战犯们能否安全通过峡谷，安全通过的条件就是在任何时刻战犯们距离最近的士兵大于 $100$ 米。

给定峡谷的长、宽和每个士兵在峡谷中的坐标，假定士兵的位置一直保持不变，请你写一个程序计算战犯们能否不被士兵发现，顺利通过峡谷。

如果不能，那么战犯们最少需要消灭几个士兵才能安全通过峡谷（无论士兵是否被另一个士兵看到，他都可以被消灭）。 

![](https://cdn.luogu.com.cn/upload/image_hosting/59rrua2p.png)
## 输入格式

第一行有三个整数 $l$，$w$ 和 $n$，分别表示峡谷的长度、宽度和士兵的人数。

接下来的 $n$ 行，每行两个整数 $x_i$ 和 $y_i$，表示第 $i$ 个士兵在峡谷的坐标，坐标以米为单位，峡谷的西南角坐标为 $(0, 0)$，东北角坐标为 $(l, w)$，见上图。

注意：通过峡谷可以从 $(0, ys)$，（其中 $ys$ 满足 $0\leq ys \leq w$） 到 $(l, ye)$（其中 $ye$ 满足 $0 \leq ye \leq w$），其中 $ys$， $ye$ 不一定是整数。
## 输出格式

只有一行，为一个整数，即安全通过峡谷需要消灭的士兵的人数，如果不需要消灭任何士兵，则输出 $0$。
## 样例

### 样例输入 #1
```
130 340 5
10 50
130 130
70 170
0 180
60 260
```
### 样例输出 #1
```
1
```
## 提示

对于 $100\%$ 的数据，满足：$1 \leq w \leq 5\cdot 10^4$，$1\leq l \leq 5\cdot 10^4$，$1\leq n \leq 250$，$0 \leq x_i \leq l$，$0 \leq y_i \leq w$。


---

---
title: "[USACO05DEC] Cow Patterns G"
layout: "post"
diff: 省选/NOI-
pid: P6080
tag: ['2005', 'USACO']
---
# [USACO05DEC] Cow Patterns G
## 题目描述

Farmer John 的 $N$（$1 \leq N \leq 10^5$）头奶牛中出现了 $K$（$1 \leq K \leq 25000$）只坏蛋！这些坏蛋在奶牛排队的时候总站在一起。现在你需要帮助 FJ 找出他们。

为了区分，FJ 给每头奶牛发了号牌，上面写着一个 $1 \ldots S$ 之间的数字（$1 \leq S \leq 25$），虽然这不是个完美的方法，但也有一定作用。现在 FJ 记不得坏蛋们的具体号码，但他给出了一个模式串。原坏蛋的号码相同，模式串中的号码依旧相同，模式串中坏蛋号码的大小关系也和原号码相同。

例如模式串：$1,4,4,3,2,1$，原来的 $6$ 只坏蛋，最前面和最后面的号码相等且最小（不一定是 $1$），位置 $2,3$ 的坏蛋号码相同且最大（不一定是 $4$）。

现在有这样一个队列：$5, 6, 2, 10, 10, 7, 3, 2, 9$，它的子串 $2, 10, 10, 7, 3, 2$ 匹配模式串的相等关系和大小关系，这就可能是一个坏蛋团伙。

请找出所有团伙的可能情况。 
## 输入格式

第一行三个整数 $N,K,S$。

接下来 $N$ 行，每行一个整数，代表第 $i$ 奶牛的编号。

接下来 $K$ 行，每行一个整数，表示模式串中第 $i$ 个位置的号码。
## 输出格式

第一行输出一个整数 $B$。

接下来 $B$ 行，每行一个整数，为一种可能的坏蛋团伙的起始位置。

所有位置按升序输出。
## 样例

### 样例输入 #1
```
9 6 10
5
6
2
10
10
7
3
2
9
1
4
4
3
2
1
```
### 样例输出 #1
```
1
3
```


---

---
title: "[JSOI2013] 吃货 JYY"
layout: "post"
diff: 省选/NOI-
pid: P6085
tag: ['2013', '各省省选', '江苏']
---
# [JSOI2013] 吃货 JYY
## 题目背景

作为 JSOI 的著名吃货，JYY 的理想之一就是吃遍全世界的美食。要走遍全世界当然需要不断的坐飞机了。而不同的航班上所提供的餐食是很不一样的：比如中国的航班会提供中餐，英国的航班有奶茶和蛋糕，澳大利亚的航班有海鲜，新加坡的航班会有冰激凌……

JYY 选出了一些他特别希望品尝餐食的航班，希望制定一个花费最少的旅游计划，能够从南京出发，乘坐所有这些航班并最后回到南京。
## 题目描述

世界上一共有 $N$ 个 JYY 愿意去的城市，分别从 $1$ 编号到 $N$。JYY 选出了 $K$ 个他一定要乘坐的航班。除此之外，还有 $M$ 个 JYY 没有特别的偏好，可以乘坐也可以不乘坐的航班。

一个航班我们用一个三元组 $(x,y,z)$ 来表示，意义是这趟航班连接城市 $x$ 和 $y$，并且机票费用是 $z$。每个航班都是往返的，所以 JYY 花费 $z$ 的钱，既可以选择从 $x$ 飞往 $y$，也可以选择从 $y$ 飞往 $x$。

南京的编号是 $1$，现在 JYY 打算从南京出发，乘坐所有 K 个航班，并且最后回到南京，请你帮他求出最小的花费。

## 输入格式

输入数据的第一行包含两个整数 $N$ 和 $K$。

接下来 $K$ 行，每行三个整数 $x,y,z$ 描述必须乘坐的航班的信息，数据保证在这 $K$ 个航班中，不会有两个不同的航班在同一对城市之间执飞。

第 $K+2$ 行包含一个整数 $M$，接下来 $M$ 行，每行三个整数 $x,y,z$ 描述可以乘坐也可以不乘坐的航班信息。
## 输出格式

输出一行一个整数，表示最少的花费。数据保证一定存在满足 JYY 要求的旅行方案。
## 样例

### 样例输入 #1
```
6 3
1 2 1000
2 3 1000
4 5 500
2
1 4 300
3 5 300
```
### 样例输出 #1
```
3100
```
## 提示

### 样例解释

一个可行的最佳方案为 $1\rightarrow 2\rightarrow 3\rightarrow 5\rightarrow 4\rightarrow 1$。

机票所需的费用为 $1000+1000+300+500+300=3100$。

### 数据范围

对于 $100\%$ 的数据，$2\leq N\leq 13,0\leq K\leq 78,2\leq M\leq 200,1\leq x,y\leq N,1\leq z\leq 10^4$。


---

---
title: "[CEOI 2019] 立方填词"
layout: "post"
diff: 省选/NOI-
pid: P6090
tag: ['2019', 'CEOI（中欧）']
---
# [CEOI 2019] 立方填词
## 题目描述

立方填词是一种特殊的填词游戏。填词之前，你需要选择立方体的边长 $a$ ，然后你就可以建立一个有 $a^3$ 个单位立方体的立方体了。这个大立方体有 $12$ 条边。然后，你去掉所有没有接触大立方体边的单位立方体。下图展示了当 $a=6$ 时建立的最终立方体。

![](https://cdn.luogu.com.cn/upload/image_hosting/zzs7dshw.png)

最后，你需要给剩下的每个单位立方体填上一个字母。对于这个立方体，填词之后，每条边上的单词都应该是有意义的。每条边都可以双向阅读，只要从一个方向读起来有意义即可。

下图展示了当 $a=6$ 时的一个立方体。一些单位立方体已经填上了字母。你已经可以沿这个大立方体的三条边读到 **SUBMIT**，**ACCEPT** 和 **TURING** 三个单词了。

![](https://cdn.luogu.com.cn/upload/image_hosting/jzpyzoeu.png)

给定一系列有意义的单词，每个单词可以在合法的立方体的任意一条边上出现。求可以构造多少种不同的立方体对 $998244353$ 取模。

即使一个立方体可以通过旋转和镜像操作变成另一个立方体，也认为这两个立方体**是不同的**。
## 输入格式

第一行一个整数 $n$ ，表示单词的个数。

接下来 $n$ 行，每行一个单词，表示可以在大立方体的边上出现的单词。单词长度大于等于 $3$ ，并且小于等于 $10$ 。

保证所有单词都不同。
## 输出格式

输出一个整数，表示可以构造的不同立方体数对 $998244353$ 取模后的结果。
## 样例

### 样例输入 #1
```
1
radar
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
1
robot
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
2
FLOW
WOLF
```
### 样例输出 #3
```
2
```
### 样例输入 #4
```
2
baobab
bob
```
### 样例输出 #4
```
4097
```
### 样例输入 #5
```
3
TURING
SUBMIT
ACCEPT
```
### 样例输出 #5
```
162
```
### 样例输入 #6
```
3
MAN1LA
MAN6OS
AN4NAS
```
### 样例输出 #6
```
114
```
## 提示

#### 样例解释#1

第一个样例中，唯一一种可能是立方体的所有边上的单词均为 **radar**。

#### 样例解释#2

第二个样例中，有两种立方体，其中一个旋转后可以得到另一个立方体。立方体所有边上的单词都是 **robot**，两个立方体的不同之处在于左下角的字母是 **r** 还是 **t**。

#### 样例解释#3

第三个样例与第二个类似，注意阅读方向不会影响答案。

#### 样例解释#4

第四个样例中，如果把 **bob** 填在立方体的每条边上，有一种立方体。还有 $2^
{12} = 4096$ 种立方体，每条边都填 **baobab**（对于 $12$ 条边中的一条，我们有两种可能的阅读顺序）。

#### 数据范围

对于全部数据， $1 \le n \le 10^5$  。      

详细子任务限制及分值如下表：

| 子任务编号 | 限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | 单词中只包含小写的 `a` 到 `f` | $21$ |
| 2 | 单词中只包含小写的 `a` 到 `p` | $29$ |
| 3 | 单词中包含小写的 `a` 到 `p` 和大写的 `A` 到 `P` | $34$ |
| 4 | 单词中包含小写的 `a` 到 `z`，大写的 `A` 到 `Z` 和数字 `0` 到 `9`  | $16$ |


---

---
title: "[JSOI2012] 幼儿园的游戏"
layout: "post"
diff: 省选/NOI-
pid: P6128
tag: ['2012', '各省省选', '江苏']
---
# [JSOI2012] 幼儿园的游戏
## 题目描述

公元 $1770$ 年，纪昀先生途经进香河，与百姓谈说人世，谈说友善。他所告诉人们的为友之道，流传至今，深深影响着当地的人们，甚至是幼儿园的孩童。                 
一天，多诺达新幼儿园的孩子们与老师们排排坐，形成了一个 $n \times m$ 的矩形队列，一共有 $k$ 个老师，他们融入在了这个矩形队列之中，与小朋友们欢乐地唱着歌。“手拉手，我们永远都是好朋友！”于是老师要求每一位小朋友都和四周(即上下左右四个方向)的任意两个小朋友牵手。                 
作为幼儿园里最聪明的小朋友，你马上意识到这并不是单纯的游戏，而是一个非常有意义的问题。你非常希望知道一共有多少种不同的牵手方案，满足每一位小朋友都可以和四周恰好两位小朋友牵手。当然，每一位小朋友都只能和小朋友牵手，不能去和老师牵手。任何一位小朋友都不允许自己和自己牵手(即左手拉右手)。 
你所需要知道的只是方案个数，因为答案可能太大，所以需要对 $1000000007$ 取模。 
## 输入格式

第一行有三个整数，分别是 $n$,$m$ 和 $k$。如题。            
接下来 $k$ 行，每一行有 $2$ 个整数 $x$ 和 $y$，描述了一位老师的位置。 
## 输出格式

你只需要输出一个整数，表示答案关于 $10^9+7$ 取模后的结果。 
## 样例

### 样例输入 #1
```
3 6 2
2 2
2 5 
```
### 样例输出 #1
```
3
```
## 提示

对于 $100\%$ 的数据， $1 \le n \le 8,1 \le m \le 2^{31}-1$，$1 \le k \le 100$。


---

---
title: "[JSOI2015] 最小表示"
layout: "post"
diff: 省选/NOI-
pid: P6134
tag: ['2015', '各省省选', '江苏']
---
# [JSOI2015] 最小表示
## 题目背景

还记得去年 JYY 所研究的强连通分量的问题吗？去年的题目里，JYY 研究了对于有向图的“加边”问题。对于图论有着强烈兴趣的 JYY，今年又琢磨起了“删边”的问题。
## 题目描述

对于一个 $N$ 个点（每个点从 $1$ 到 $N$ 编号），$M$ 条边的有向图，JYY 发现，如果从图中删去一些边，那么原图的连通性会发生改变；而也有一些边，删去之后图的连通性并不会发生改变。

JYY 想知道，如果想要使得原图任意两点的连通性保持不变，我们最多能删掉多少条边呢？


为了简化一下大家的工作量，这次 JYY 保证他给定的有向图一定是一个有向无环图（JYY：大家经过去年的问题，都知道对于给任意有向图的问题，最后都能转化为有向无环图上的问题，所以今年 JYY 就干脆简化一下大家的工作）。
## 输入格式

第一行包含两个正整数 $N$ 和 $M$。

接下来 $M$ 行，每行包含两个 $1$ 到 $N$ 之间的正整数 $x_i$ 和 $y_i$，表示图中存在一条从 $x_i$ 到 $y_i$ 的有向边。

输入数据保证，任意两点间只会有至多一条边存在。
## 输出格式

输出一行包含一个整数，表示JYY最多可以删掉的边数。
## 样例

### 样例输入 #1
```
5 6
1 2
2 3
3 5
4 5
1 5
1 3
```
### 样例输出 #1
```
2
```
## 提示

### 样例解释

一种合法方案为删去 $1\rightarrow 5$ 和 $1\rightarrow 3$。容易证明没有比 $2$ 更优的答案。

### 数据范围

对于 $100\%$ 的数据，$1 \leq N\leq 3\times 10^4$，$0 \leq M\leq 10^5$。


---

---
title: "[IOI 2012] 理想城"
layout: "post"
diff: 省选/NOI-
pid: P6137
tag: ['2012', 'IOI']
---
# [IOI 2012] 理想城
## 题目描述

像许多同龄的科学家和艺术家一样，小 L 对城市规划和城区设计很感兴趣.他致力于构建一个理想城。理想城由 $N$ 个区块组成，而这些区块放在一个无限大的正方形网格上。第 $x$ 行第 $y$ 列的单元格由有序数对 $(x,y)$来标识。单元格 $(0,0)$ 位于网格的左上角。给定一个单元格 $(x,y)$，与之相邻的单元格（如果存在的话）分别为：$(x-1,y)$，$(x+1,y)$，$(x,y-1)$，$(x,y+1)$。每个区块在网格上恰好覆盖一个单元格。一个区块能够被放置在单元格 $(x,y)$ 上，当且仅当 $1 \le x,y \le 2^{31}-2$ 。我们将使用单元格的坐标同时来代表单元格上面的区块。若两个区块被放在相邻的单元格中，则视它们为相邻区块.理想城所有的区块连在一起，里面没有“洞”存在.换言之，所有单元格必须满足下述两个条件：
- 对于任意两个空白的单元格，至少存在一连串相邻的空白单元格连接它们。
- 对于任意两个非空的单元格，至少存在一连串相邻的非空单元格连接它们。

以下 $4$ 个图中的区块放置均不满足理想城的条件。前两个图不满足第一个条件。第 $3$ 个图不满足第二个条件，第 $4$ 个图两个条件均不满足。

![](https://cdn.luogu.com.cn/upload/image_hosting/uzw8c8c8.png)

当遍历理想城时，一个**跳步**代表**从一个区块走到一个相邻的区块**。跳步时不能移进空白单元格。假设 $v_0,v_1,\cdots,v_{N-1}$ 是 $N$ 个区块的坐标。对于任意两个不同的区块 $v_i$ 和 $v_j$，它们的距离 $d(v_i,v_j)$ 是从 $v_i$ 移动到 $v_j$ 所需的最小跳步数目。

下图是一个由 $11$ 个区块组成的理想城。区块坐标分别为

![](https://cdn.luogu.com.cn/upload/image_hosting/5whsvyjh.png)

$$v_0=(2,5) \quad v_1=(2,6) \quad v_2=(3,3)$$
$$v_3=(3,6) \quad v_4=(4,3) \quad v_5=(4,4)$$
$$v_6=(4,5) \quad v_7=(4,6) \quad v_8=(5,3)$$
$$v_9=(5,4) \quad v_{10}=(5,6)$$


其中，$d(v_1,v_3)=1$，$d(v_1,v_8)=6$，$d(v_6,v_10)=2$，$d(v_9,v_10)=4$。

给定一个理想域，试求
$$S=\sum_{i=0}^{N-2}\sum_{j=i+1}^{N-1}d(v_i,v_j)$$

## 输入格式

第 $1$ 行为一个正整数 $N$，为理想城区块的数目。

第 $2$ 行到第 $N+1$ 行，每行有两个非负整数。第 $i+2$ 行为第 $i$ 个区块的坐标 $v_i = (x_i， y_i)$。
## 输出格式

输出仅一行一个正整数，为 $S$ 的值。由于 $S$ 的值可能较大，你只需输出 $S$ 对 $10^9$ 取模的值。
## 样例

### 样例输入 #1
```
11
2 5
2 6
3 3
3 6
4 3
4 4
4 5
4 6
5 3
5 4
5 6

```
### 样例输出 #1
```
174
```
## 提示

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le x_i,y_i \le 2^{31}-2$ 。


---

---
title: "[IOI 2012] 骑马比武竞赛"
layout: "post"
diff: 省选/NOI-
pid: P6138
tag: ['2012', 'IOI']
---
# [IOI 2012] 骑马比武竞赛
## 题目描述

1491 年公爵 Milan Lodovico Sforza 为了他与 Beatrice d'Este 的婚礼，要求Leonardo 来负责筹备婚礼的庆典。在这个庆典中包含了一个盛大的持续三天的骑马比武竞赛，但是最受欢迎的骑士迟到了...

在一骑马比武的竞赛，$N$ 个骑士一开始被排成一排然后按照他们的位置从 $0$ 到 $N-1$ 开始编号。骑马比武的主持人每一回合叫出两个位置 $S$ 跟 $E$ （其中 $0 \le S < E \le N - 1$）。所有介于 $S$ 与 $E$ （含） 这两个位置的骑士则开始进行骑马比武。最后的赢家可以留下来继续进行竞赛， 并回到他原来的位置，而输家则离开这个竞赛。在这之后，剩下的骑士按照原来排列的顺 序，往前挤掉空出来的位置。所以他们的位置编号变成从 $0$ 到 $N - (E - S) - 1$。骑马比武竞赛的主持人接着进行下一个回合的比赛，直到最后剩下唯一个骑士。

Leonardo 知道所有骑士有不同的强度，这个强度从 $0$ (最弱) 到 $N-1$ (最强)。他也知道骑马比武竞赛的主持人会下怎么样的命令来进行C回合的竞赛，毕竟他是无所不能的   Leonardo。而且他也确定在每一个回合中，拥有最大强度的骑士会获得胜利。

$N$ 个骑士中的 $N-1$ 个骑士已经排成了一排，只是最受欢迎的骑士还未出现。这个骑士的强度为 $R$ 但是他迟到了。为了让这场竞赛达到最高潮, Leonardo  想要让这个骑士能好好展现他的风采，所以想要帮他安插一个位置，而这个位置可以使得这个骑士能获得最多回合的 胜利。请注意，我们不关心与此骑士无关的回合。我们只关心包含此骑士而且由他赢得胜利的回合。

**例子**

假设有 $5$ 个骑士，其中 $4$ 个骑士已经排列好，而他们的强度分别是 $[1,0,2,4]$。而迟到骑士的强度为 $3$ 。假设要进行 $3$ 回合，骑马比武的主持人打算要叫出的位置 $(S,E)$ 分别是 $(1, 3)$，$(0, 1)$，$(0, 1)$。

假设 Leonardo  将迟到的骑士插到第一个位置而且迟到的骑士强度为 $3$。那么骑士强度的排列将会是 $[3, 1, 0, 2, 4]$。第一回合参与的骑士为位置 $1,2,3$ 的骑士，他们的强度分别是 $1,0,2$，所以由强度 $2$ 的骑士获得胜利。经过这一回合，新的骑士强度的排列变成 $[3, 2, 4]]$。下一个回合是由强度 $3$ 与强度 $2$（位置 $0,1$）的骑士进行比赛，由强度 $3$ 的骑士获得胜利。而骑士强度的排列则变成 $[3,4]$。最后一回合（位置 $0,1$）由强度 $4$ 的骑士获得胜利。那么，迟到的骑士只有获得一回合的胜利 (第二回合)。

若 Leonardo 将迟到的骑士插入强度 $1$ 与强度 $0$ 的骑士中间，骑士强度的排列将会是 $[1,3,0,2,4]$。这一次,  第一回合比赛的骑士强度为 $3,0,2$。由强度 $3$ 的骑士获胜，然后骑士强度的排列变成 $[1,3,4]$。在第二回合中由强度 $1$ 对上强度 $3$ 的骑士，由强度 $3$ 的骑士获胜。最后的一回合，骑士强度的排列变成  $[3,4]$，由强度 $4$ 的骑士获得胜利。在这个排列中，迟到的骑士获得两回合的胜利。这实际上是最佳的位置，因为没有其他的位置可以让迟到的骑士获得两回合以上的胜利。

你的任务是写一个程序来帮迟到的骑士选择最佳的位置让他能获得最多的胜利回合数，以符合 Leonardo 的期待。
## 输入格式

- 第一行，$3$个整数 $N$，$C$，$R$，其中 $N$ 表示骑士的个数，$C$ 表示竞赛主持人会进行的回合数，$R$ 表示迟到的骑士的强度。
- 第二行，$N$ 个整数 $K[0],K[1],\cdots,K[N-1]$，表示已经排列好成一列的 $N-1$ 个骑士的强度
- 第三行，$2C$ 个整数 $S[0],E[0],S[1],E[1],\cdots,E[N-1],S[N-1]$，对于 $0 \le i \le C-1$，竞赛主持人进行第 $i +1$ 回合比赛的骑士为从位置 $S[i]$ 到位置 $E[i]$ (含). 你可以假设对每一个 $i$ , $S[i] < E[i]$。
## 输出格式

共一行，让迟到的骑士能获得最多胜利回合数的位置。如果存在多个最优的位置，输出编号最小的位置。
## 样例

### 样例输入 #1
```
5 3 3
1 0 2 4
1 3
0 1
0 1

```
### 样例输出 #1
```
1

```
## 提示

对于 $100\%$ 的数据，$1 \le N \le 10^5$，$1 \le C \le N-1$，在第 $i+1$ 回合，$E[i]$ 会小于这个回合剩下的骑士数量。经过 $C$ 回合的命令之后，只会剩下一个骑士。


---

---
title: "【模板】后缀平衡树"
layout: "post"
diff: 省选/NOI-
pid: P6164
tag: ['O2优化']
---
# 【模板】后缀平衡树
## 题目背景

"后缀平衡树"这个名字正确性存疑，由于 clj 给的"重量平衡树"定义有歧义。

字符串我也不会，所以也没去查证。
## 题目描述

给你一个字符串 `init`，要求你支持三个操作：

1. 在当前字符串的后面插入若干个字符。

2. 在当前字符串的后面删除若干个字符。

3. 询问字符串 $s$ 在当前字符串中出现了几次（作为连续子串）？

你必须在线支持这些操作。


## 输入格式

第一行一个数 $q$ 表示操作个数。

第二行一个字符串表示初始字符串 `init`。

接下来 $q$ 行，每行 $2$ 个字符串 `Type Str`。
 
Type是 `ADD` 的话表示在后面插入。

Type是 `DEL` 的话表示在后面删除。

Type是 `QUERY` 的话表示询问某字符串在当前字符串中出现了几次。

为了体现在线操作，你需要维护一个变量 `mask`，初始值为 $0$。

读入串 `Str` 之后，使用这个过程将之解码成真正询问的串 `TrueStr`。

询问的时候，对 `TrueStr` 询问后输出一行答案 `Result`。

然后 `mask = mask xor Result`

插入的时候，将 `TrueStr` 插到当前字符串后面即可。

![](https://cdn.luogu.com.cn/upload/image_hosting/whqt9ff9.png)
## 输出格式

对每个 $3$ 操作，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
3
A
QUERY B
ADD BBABBBBAAB
DEL 1
```
### 样例输出 #1
```
0
```
## 提示

数据字符串变化长度以及初始长度和 $ \le 8 \times 10^5$，询问次数 $\le 10^5$，询问总长度 $\le 3 \times 10^6$。

字符集为大写字母，注意 `ADD` 和 `QUERY` 操作的字符串都需要解压。


---

---
title: "[IOI 2016] railroad"
layout: "post"
diff: 省选/NOI-
pid: P6168
tag: ['2016', 'IOI', 'Special Judge']
---
# [IOI 2016] railroad
## 题目描述

Anna 在一个游乐园工作。她负责建造一个新的过山车铁路。她已经设计了影响过山车速度的 $n$ 个特殊的路段（方便起见标记为 $0$ 到 $n-1$）。现在 Anna 必须要把这些特殊的路段放在一起并提出一个过山车的最后设计。为了简化问题，你可以假设过山车的长度为零。

对于 $0$ 和 $n-1$ 之间的每个 $i$，这个特殊的路段 $i$ 具有如下两个性质：

- 当进入这个路段时，有一个速度限制：过山车的速度必须小于或等于 $s_i$ $\text{km/h}$（每小时千米）。

- 当离开这个路段时，过山车的速度刚好是 $t_i$ $\text{km/h}$，不管过山车进入该路段时的速度如何。

最后完成的过山车设计是一个以某种顺序包含这 $n$ 个特殊路段的单一铁路线。这 $n$ 个路段中的每一个应当被使用刚好一次。连续的路段之前用铁轨来连接。Anna 应该选择这 $n$ 个路段的顺序，然后确定每段铁轨的长度。铁轨的长度以米来衡量，可以是任意的非负整数（可以为零）。

两个特殊路段之间的每 $1$ 米铁轨可以将过山车的速度减慢 $1$ $\text{km/h}$。在这个过山车铁路的起点，过山车按照 Anna 选择的顺序进入第一个特殊路段时的速度是 $1$ $\text{km/h}$。

最后的设计还必须满足以下要求：

- 过山车在进入这些特殊路段时不能违反任一个速度限制。

- 过山车的速度在任意时刻为正。

你的任务是找出这些路段之间铁轨的最小可能总长度（这些路段之间铁轨总长度的最小值）。如果 $m=0$ 你只需要检查是否存在一个有效的过山车设计，使得每段铁轨的长度为零。

**举例**

```
4 1
1 7
4 3
5 8
6 6
```
在这个样例中有 $4$ 个特殊的路段。最好的解是按照 $0,3,1,2$ 的顺序构造，连接这些路段的铁轨长度分别是 $1,2,0$。下面给出过山车沿铁路铁轨的行驶方式：

- 最初过山车的速度是 $1$ km/h。

- 过山车由进入 $0$ 号路段开始行进。

- 过山车以 $7$ $\text{km/h}$ 的速度离开 00 号路段。

- 然后有一段长度为 $1$ $\text{m}$ 的铁轨。过山车在到达这段铁轨的末端时速度为 $6$ $\text{km/h}$。

- 过山车以 $6$ $\text{km/h}$ 的速度进入 $3$ 号路段并以相同的速度离开该路段。

- 在离开 $3$ 号路段后，过山车走过一段 $2$ $\text{m}$ 长的铁轨。速度降至 $4$ $\text{km/h}$。

- 过山车以 $4$ $\text{km/h}$ 的速度进入 $1$ 号路段，并且以 $3$ $\text{km/h}$ 的速度离开该路段。

- 离开 $1$ 号路段后，过山车立即进入 $2$ 号路段。

- 过山车离开 $2$ 号路段。其最终速度是 $8$ $\text{km/h}$。

路段之间的铁轨总长度：$1+2+0=3$。
## 输入格式

- 第一行：两个整数 $n$ 和 $m$，其中 $m=0$ 表示当答案不为 $0$ 时，你可以返回任意正整数，$m=1$ 表示你需要返回正确答案。

- 接下来 $n$ 行：第 $i$ 行的两个整数表示 $s_{i-1}$ 和 $t_{i-1}$。
## 输出格式

共一行，所有铁轨的最小可能总长度。（当 $m=0$ 时，如果存在一个有效的过山车设计使得每段铁轨的长度均为零，则函数返回零，如果上述设计不存在，则输出任意的正整数）。
## 样例

### 样例输入 #1
```
4 1
1 7
4 3
5 8
6 6

```
### 样例输出 #1
```
3

```
## 提示

对于 $100\%$ 的数据，$1 \le n \le 2 \times {10}^5$，$ 1 \le s_i \le 10^9$，$1 \le t_i \le 10^9$。


---

---
title: "[COCI 2019/2020 #6] Skandi"
layout: "post"
diff: 省选/NOI-
pid: P6220
tag: ['2019', 'COCI（克罗地亚）']
---
# [COCI 2019/2020 #6] Skandi
## 题目背景

题目翻译来自 [LOJ3269](https://loj.ac/problem/3269) 。


**由于洛谷评测机原因，数据有删改。**
## 题目描述

**译自 [COCI 2019/2020 Contest #6](https://hsin.hr/coci/archive/2019_2020/) T4.** ***[Skandi](https://hsin.hr/coci/archive/2019_2020/contest6_tasks.pdf)***

Dragica 不仅是当地的一个半专业保龄球队的队长，还是一位充满激情的厨师。除此之外，他还是克罗地亚数一数二的填字游戏（crossword）玩家。填字游戏是一个在 $N\times M$ 的网格上游玩的游戏。在游戏开始前，部分格子已经填上了字母，作为至多两题的起点，而玩家需要根据给出的提示以水平向右或竖直向下的方向在剩下的格子填上答案。在这里，一题的答案定义为从该题起点沿提示指定方向直至网格边界或另一题起点之前的部分。如果一题的起点右边一格是空的，则该题在水平方向上存在一题；类似的，如果一题的下面一格是空的，则该题在竖直方向上存在一题。

Dragica 当然知道答案啦，但他有点鸽，想让你帮他找出完成某个填字游戏最少回答的题目数。
## 输入格式

第一行两个空格分隔的整数 $N,~M$，含意见题目描述。

接下来 $N$ 行每行 $M$ 个字符 `0` 或 `1`，其中 `0` 表示这是个待填充答案的空格，而 `1` 表示该格已填有字符，是至多两题的起点。保证输入存在至少一个 `0` ，且第一行和第一列均为 `1`。
## 输出格式

第一行输出完成该次填字游戏的最小答案数 $X$。

接下来 $X$ 行每行以 `r c dir` 的格式回答一个问题，其中 `r` 表示题目的行号，`c` 表示题目的列号，`dir` 为 `DESNO` （克罗地亚语中的右）和 `DOLJE` （克罗地亚语中的下）之一，表示 Dragica 回答问题的方向。

如果有多解，输出任意一个。
## 样例

### 样例输入 #1
```
4 5
11111
10000
10000
10000
```
### 样例输出 #1
```
3
2 1 DESNO
3 1 DESNO
4 1 DESNO
```
### 样例输入 #2
```
6 4
1111
1011
1000
1011
1010
1000
```
### 样例输出 #2
```
4
1 2 DOLJE
4 4 DOLJE
5 3 DOLJE
3 1 DESNO
```
### 样例输入 #3
```
9 8
11111111
10000000
10001000
10010001
11100001
10100110
10001000
10100001
10010001
```
### 样例输出 #3
```
14
5 2 DOLJE
5 8 DOLJE
8 3 DOLJE
2 1 DESNO
3 1 DESNO
3 5 DESNO
4 1 DESNO
4 4 DESNO
5 3 DESNO
6 3 DESNO
7 1 DESNO
7 5 DESNO
8 3 DESNO
9 4 DESNO
```
## 提示

#### 样例 $3$ 解释：
下图展示了样例中的填词游戏，其中黑色的格子表示开始时已经填了字符的格子，在图下方所示的表中你可以看到给出的横着填和竖着填的提示。注意，已经填了字符的格子可以是零题、一题（例如第 $8$ 和 $13$ 题）或两题（例如第 $10$ 和 $12$）题的起点。要解出它，你至少需要知道 $14$ 题的答案，试试看看你会吗？~~（疑问语气）~~

*译者注：以下图片经过高清重制。中文的 crossword 没啥意义，就不翻译了。*

![](https://cdn.luogu.com.cn/upload/image_hosting/d7w61uk7.png)

![](https://cdn.luogu.com.cn/upload/image_hosting/4spl87ov.png)

-----


#### 数据范围：

对于 $100\%$ 的数据，有 $2\le N,~M\le 500$。

各子任务限制见下表：

|子任务|分值|特殊限制|
|:-:|:-:|:-:|
|1|16|至多 $9$ 个格子开始前填了字符|
|2|30|$N\le 500,~M\le 10$|
|3|54|无特殊限制|


---

---
title: "[BJWC2014] 数据"
layout: "post"
diff: 省选/NOI-
pid: P6224
tag: ['2014', '北京']
---
# [BJWC2014] 数据
## 题目描述

为了写论文，```Alex``` 经常要整理大量的数据。这一次，```Alex``` 面临一个严峻的考验：他需要实现一个数据结构来维护一个点集。

现在，二维平面上有 $N$ 个点。

```Alex``` 需要实现以下三种操作：

1. 在点集里添加一个点；

2. 给出一个点，查询它到点集里所有点的曼哈顿距离的最小值；

3. 给出一个点，查询它到点集里所有点的曼哈顿距离的最大值。

两个点的曼哈顿距离定义为它们的横坐标差的绝对值与纵坐标差的绝对值的和。

这么困难的问题，```Alex``` 当然不会做，只好再次请你帮忙了。
## 输入格式

第一行包含一个整数 $N$，表示点集最初的点数。

接下来 $N$ 行，每行两个整数，依次表示每个点的横坐标和纵坐标。

第 $N+2$ 行包含一个整数 $Q$，表示询问的数目。

接下来 $Q$ 行，每行三个整数，依次表示询问的类型，点的横坐标和纵坐标。$0$ 类型表示添加一个点，$1$ 类型表示查询到该点的曼哈顿距离的最小值，$2$ 类型表示查询最大值。
## 输出格式

输出若干行，依次表示每个查询操作的答案。
## 样例

### 样例输入 #1
```
3
7 5
6 2
3 1
5
1 6 1
1 5 5
2 7 1
0 3 2
1 1 0
```
### 样例输出 #1
```
1
2
4
3
```
## 提示

对于前 $20 \%$ 的数据：$1\le N , Q\le 10^3$

对于前 $100 \%$ 的数据： $1\le N , Q \le 10^5$；

点的坐标是不超过 $10^9$ 的非负整数。


---

---
title: "[JSOI2013] 公交系统"
layout: "post"
diff: 省选/NOI-
pid: P6231
tag: ['2013', '各省省选', '江苏', 'O2优化']
---
# [JSOI2013] 公交系统
## 题目背景

几年前南京因为修地铁的缘故，很多公交车线路都被迫改变了。

JYY 为此很苦恼：试想一下，当你坐上一辆公交车，却发现这辆公交车驶向了与你记忆完全不同的方向。

于是 JYY 打算开发一套可以利用手机进行实时更新的公交信息应用， 所有安装了这款应用的手机都可以向数据库发送最新的公交线路更改情况，同时也可以通过应用向数据库查询自己所需要的信息。
## 题目描述

南京一共有 $n$ 个公交站点，分别从 $1$ 到 $n$ 编号。两个不同的站点 $x$ 和 $y$ 之间可能会有公交车直接运营（不经过别的站点直接从 $x$ 开到 $y$） ，我们将这种关系看作一条无向边（公交线路显然是双向的，我们既可以从 $x$ 坐公交车到 $y$，也可以从 $y$ 坐车到 $x$）。

任意时刻任何公交站点都至多只会连有 $2$ 条边，并且所有这些边是不会形成
环的（公交车很少会出现环线，所以这些公交线路应该形成一些不相交的链，链
的两端分别对应两个终点站）。

JYY 的 IOS 应用按照时间顺序一共收到了 $q$ 条交互信息，每一条交互信息
都是下列五种信息之一：

- `add x y z`，表示当前时刻，站点 $x$ 到站点 $y$ 之间有新增了一班公交车直接运营，并且在当前路况下，公交车所需要的运营时间为 $z$。
- `del x y`，表示由于某种原因，原本在站点 $x$ 和站点 $y$ 之间直接运营的公交车停运了。
- `change x y z`，表示由于路况情况改变，站点 $x$ 到站点 $y$ 之间直接运营的公交车当前的运营时间为 $z$。
- `reach x y`，表示某个用户询问从站点 $x$ 坐车能不能坐到站点 $y$。
- `dest x y`，表示某个用户从站点 $x$ 上车，坐上了当前正开往站点 $y$ 的公交车。该用户想知道，他到达 $y$ 后继续乘坐可乘坐的线路(已经乘坐过的线路不能重复乘坐)，最终能够到达的终点站是哪一站？从站点 $x$ 开始需要多久才能
开到终点站？

**在收到第一条信息之前，没有任何公交车在运营**。

由于用户难免会提交错误的信息，所以 JYY 希望他的软件对于错误的信息也
要能够做出合理的反应：

- 对于 `add` 信息，如果加入边 $(x,y)$ 之后，任何站点连接的边数均不超过 $2$ 并且图中没有环，JYY 则认为这个信息是正确的，并根据这个信息更新
数据库中的公交线路数据，否则JYY会无视这个错误信息。
- 对于 `del` 和 `change` 信息，如果站点 $x$ 和站点 $y$ 之间有公交车直接运营， JYY 则认为这条信息是正确的，并更新数据库，否则 JYY 则会无视这个错误
信息。
- 对于 `dest` 信息，如果站点 $x$ 不能到达站点 $y$，JYY 也会认为这一条询问信
息是错误的。

JYY 希望你能够帮助他完成这一个公交信息应用。
## 输入格式

输入数据的第一行包含两个整数，分别代表站点数 $n$ 和交互信息条数 $q$。

接下来 $q$ 行，每行对应一个 JYY 需要处理的信息，其格式见【题目描述】。

## 输出格式

输出 $q$ 行，每行都对应一个输入文件中的信息，具体内容如下：

- 如果输入的信息是错误的，输出 `ERROR`。
- 对于一个正确的 `add`，`del`，`change` 信息，输出 `OK`。
- 对于一个正确的 `dest` 信息，输出一行两个整数，分别为终点站的编号和开到终点站所需要的时间.
- 对于 `reach` 信息，如果用户询问的两个公交站点相互可达，输出 `YES`，否则输出 `NO`。
## 样例

### 样例输入 #1
```
6 10
add 1 2 1
add 2 1 1
add 3 2 1
add 4 5 2
reach 4 6
dest 1 5
del 5 6
add 1 4 2
dest 2 3
dest 3 2
```
### 样例输出 #1
```
OK
ERROR
OK
OK
NO
ERROR
ERROR
OK
3 1
5 6
```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证：

- $2 \leq n \leq 10^5$，$2 \leq q \leq2×10^5$。
- $1 \leq x, y \leq n$，$x \neq y$，$1\leq z \leq10^4$。

---

#### 提示

请注意数据读入对程序效率造成的影响。


---

---
title: "[CEOI 2012] Printed Circuit Board"
layout: "post"
diff: 省选/NOI-
pid: P6237
tag: ['2012', 'CEOI（中欧）']
---
# [CEOI 2012] Printed Circuit Board
## 题目描述

给出一个 $n$ 个顶点的简单多边形，对于每个顶点，假如它和原点连成的线段只在这个顶点处和多边形相交，就称为满足要求的顶点。你的任务是输出所有满足要求的顶点编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/beasw2yx.png)


## 输入格式

第一行一个正整数 $n$。

下面 $n$ 行每行两个不超过 $10^6$ 的正整数，依次表示每个顶点的坐标。顶点按照输入顺序用正整数 $1,2,...,n$ 编号，并且顶点保证按照顺时针或逆时针顺序给出。
## 输出格式

第一行一个正整数 $m$，表示满足要求的顶点个数。 

第二行 $m$ 个正整数，按照升序给出满足要求的顶点编号。
## 样例

### 样例输入 #1
```
11
7 6
4 4
3 2
1 3
9 9
13 4
8 1
6 4
9 5
8 3
11 5
```
### 样例输出 #1
```
3
3 4 7
```
## 提示

对于 $100\%$ 的数据，满足 $1 \le n \le 2 \times 10^5$。


---

---
title: "[USACO06OPEN] The Milk Queue G"
layout: "post"
diff: 省选/NOI-
pid: P6243
tag: ['2006', 'USACO']
---
# [USACO06OPEN] The Milk Queue G
## 题目背景

题目是经过简写保证不改变原有题意的题目。
## 题目描述

每早，FJ 的 $N$ 头奶牛都排成一列挤奶．一个个进到仓库，为提高速率，FJ 把整个挤奶过程划分成两道工序，FJ负责实行第一道，第二道由 Rob 完成。

如果某头牛先于另一头牛开始进行第一道工序，那么她同样先开始第二道工序。

FJ 发现，如果奶牛们按某种顺序排队进行挤奶，那么可能会在排队等待上多花很多的时间。比如，如果 FJ 要花很长时间才能完成某头奶牛的第一道工序，那么 Rob 就会浪费一段时间。反之如果 FJ 的工作完成得太快，Rob 面前会有很多奶牛排起长队。

请你计算按最优方式排队后最少需要多少时间才能挤完奶。对于每头奶牛，数据提供第一道工序的时间 $A_i$ 和第二道工序的时间 $B_i$。
## 输入格式

第一行一个整数 $N$。

接下来 $N$ 行，每行两个整数表示第 $i$ 头牛的 $A_i$，$B_i$ 值。
## 输出格式

输出按最优方案排队后挤奶所需的最短时间。
## 样例

### 样例输入 #1
```
3
2 2
7 4
3 5
```
### 样例输出 #1
```
16
```
## 提示

#### 样例说明

把奶牛们按照 3，1，2  的顺序排队，这样挤奶总共花费 16 个单位时间．

$1\le N\le 25000$

$1\le A_i,B_i\le 2\times 10^4$


---

---
title: "[ICPC 2019 WF] Checks Post Facto"
layout: "post"
diff: 省选/NOI-
pid: P6253
tag: ['2019', 'Special Judge', 'O2优化', 'ICPC']
---
# [ICPC 2019 WF] Checks Post Facto
## 题目背景

### Warning: If you submit a malicious program, you will be banned.
### 警告：恶意提交本题将被封号。

## 题目描述

Your university's board game club just hosted a Checkers tournament, and you were assigned to take notes on the games. Unfortunately, while walking home, you dropped all of your papers into a puddle! Disaster! Much of what you wrote is now unreadable; all you have left are some lists of moves played in the middle of various games. Is there some way you can reconstruct what happened in those games? You had better fix things fast, or they will demote you to Tic-Tac-Toe recordkeeper!

Checkers (or English Draughts) is a well-known board game with simple rules. It is played on the dark squares of an $8 \times 8$ checkerboard. There are two players, Black and White, who alternate turns moving their pieces (all of Black's pieces are black and all of White's pieces are white). Each piece occupies a single dark square, and can be either a normal $man$ or a promoted $king$. A turn consists of choosing one piece and moving it in one of two ways:

1. Shifting it diagonally to an unoccupied adjacent dark square, as shown in Figure C.1(a). This is called a $simple~move$. If the piece is a man, it can move only in the two diagonal directions towards the opposing side of the board (towards the bottom for Black, the top for White). If the piece is a king, it can move in all four diagonal directions.

2. Jumping over an adjacent enemy piece to an unoccupied square immediately on the other side, then removing ($capturing$) that piece. Men can jump only in the two directions described above, while kings can jump in all four. The player can then repeat this step, continuing to jump with the same piece as long as there are properly-positioned enemy pieces to capture. Such a sequence of one or more jumps is called a $jump~move$. Figure C.1(b) shows a jump move comprising three
jumps.

![](https://cdn.luogu.com.cn/upload/image_hosting/onoiijvu.png)

In Checkers, captures are forced moves. If a jump move is available at the start of a player's turn, they must jump, and cannot stop jumping with that piece until it has no more possible jumps. They are free to choose which piece to jump with, and where, if there are multiple possibilities. In Figure C.1(b), Black could not have made any other move.

If a man reaches the farthest row from its player (that is, a black man reaches the bottom row or a white man reaches the top row), it is removed from the board and replaced by a king of the same color (it is said to be $promoted$), and the turn ends. A piece cannot be promoted and then jump backwards as a new king in the same turn.


Given a list of moves, find a setup of pieces such that the moves can be legally played in sequence starting from that setup. This setup may not have black men on the bottom row or white men on the top row, since they would have been promoted to kings already. You need only ensure that the rules above are obeyed; you do not need to ensure that this setup is reachable in a real game of Checkers.
## 输入格式

The first line of input contains a character $c$ and an integer $n$, where $c$ is either `B` or `W`, indicates which player makes the first move (Black or White respectively) and $n$ ($1 \leq n \leq 100$) is the number of moves in the list. Then follow $n$ lines, each of which describes a move in the standard Checkers notation defined below.


The dark squares are identified by numbers $1 \sim 32$, as shown in Figure C.1(c). A simple move from square $a$ to square $b$ is written as `a-b`. A jump move starting at $a$ and jumping to $b_1, b_2, \dots , b_k$ is written as $a\text{x}b_1\text{x}b_2\text{x} \dots \text{x}b_k$.

There is always a valid solution for the given set of moves.
## 输出格式

Output two boards side-by-side (separated by a space), giving the positions of all pieces on the board before (on the left) and after (on the right) the given moves. Use  `-` for light squares,  `.` for empty dark squares, lowercase `b` and `w` for black and white men, and uppercase `B` and `W` for black and white kings. If there is more than one valid solution, any one is acceptable.
## 样例

### 样例输入 #1
```
W 3
21-17
13x22x31x24
19x28
```
### 样例输出 #1
```
-b-.-.-. -b-.-.-.
.-.-.-.- .-.-.-.-
-.-.-.-. -.-.-.-.
B-.-w-.- .-.-w-.-
-.-.-W-. -.-.-.-.
w-.-.-.- .-.-.-.-
-.-w-w-. -.-.-.-W
.-.-.-.- .-.-.-.-
```
### 样例输入 #2
```
B 5
2-7
9x2
32-27
2x11x18
5-9
```
### 样例输出 #2
```
-.-b-.-W -.-.-.-W
b-b-.-.- .-.-.-.-
-w-.-.-. -b-.-.-.
B-w-b-.- B-w-.-.-
-.-.-.-. -.-W-.-.
.-.-.-.- .-.-.-.-
-.-.-.-. -.-.-B-.
.-.-.-B- .-.-.-.-
```
## 提示

Source: ICPC World Finals 2019.
## 题目翻译

游戏在一个 $8 \times 8$ 的方格棋盘的深色方格上进行。有两名玩家，黑方和白方，他们轮流移动他们的棋子（所有黑方的棋子都是黑色的，所有白方的棋子都是白色的）。每个棋子占据一个单独的深色方格，可以是**兵**或**王**。一个回合包括选择一个棋子并以以下两种方式之一移动它：

1. 将其**斜着**移动到一个相邻的未占用的深色方格，如图 (a) 所示。这被称为**简单移动**。兵只能沿向前的两种方向移动（对于黑方是朝下，对于白方是朝上）。如果棋子是王，它可以在所有四个斜方向移动。

2. 跳过对方的棋子到达空地，并吃掉对方的子。允许移动的方向与第一条相同。然后，玩家可以重复此步骤，继续使用相同的棋子跳。这样一个或多个跳的序列称为**跳跃移动**。图 (b) 展示了由三个跳跃组成的跳跃移动。

如果在玩家回合开始时有一个跳跃移动可用，他们必须进行跳跃，并且不能停止使用该棋子跳跃，直到它没有更多可能的跳跃。他们可以自由选择使用哪个棋子进行跳跃，以及在有多个可能性的情况下选择在哪里跳跃。在图 (b) 中，黑方不能进行任何其他移动。

如果一个兵达到其玩家的最远一行（即，一个黑子达到底行或一个白子达到顶行），它将变成同色的王（称为**晋升**），然后**回合结束**。这意味着一个兵不能在同一回合中被晋升然后以王的身份继续倒退跳跃。

给定一系列移动，请找到一个初始棋局，使得可以从该棋局开始按顺序合法进行这些移动。此棋局可能不能在底行有黑子或在顶行有白子，因为它们可能已经被晋升为王。你只需要确保上述规则被遵守；不需要确保这个棋局在实际跳棋游戏中是可达的。

### 输入格式

输入的第一行包含一个字符 $c$ 和一个整数 $n$，其中 $c$ 是 B 或 W，表示哪个玩家首先移动（分别为黑方或白方），$n$（$1 \leq n \leq 100$）是移动列表中的移动次数。然后是 $n$ 行，每行描述标准跳棋符号中定义的一步移动。

深色方格用数字 $1 \sim 32$ 标识，如图 (c) 所示。从方格 $a$ 到方格 $b$ 的简单移动写作 a-b。从 $a$ 开始跳到 $b_1, b_2, \dots , b_k$ 的跳跃移动写作 $a\text{x}b_1\text{x}b_2\text{x} \dots \text{x}b_k$。

对于给定的移动集合，总是存在至少一个答案。

### 输出格式

所有棋子在棋盘上的位置以两个并排的棋盘输出（用空格分隔），分别表示在给定的移动之前（左边）和之后（右边）的棋盘。

使用`-`表示浅色方格，`.`表示空的深色方格，小写的`b`和`w`表示黑色和白色兵，大写的`B`和`W`表示黑色和白色王。如果存在多个答案，则任何一个都可以接受。


---

---
title: "[ICPC 2019 WF] First of Her Name"
layout: "post"
diff: 省选/NOI-
pid: P6257
tag: ['2019', 'O2优化', 'ICPC']
---
# [ICPC 2019 WF] First of Her Name
## 题目背景

### Warning: If you submit a malicious program, you will be banned.
### 警告：恶意提交本题将被封号。

## 题目描述

In the Royal Family, names are very important! As the Royal Historian you have been charged with analyzing the patterns in the names of the Royal Ladies in the realm.

There have been n Royal Ladies, for convenience numbered from 1 to $n$. The name of each Lady is anuppercase letter concatenated with the name of her mother. The exception is the Lady numbered 1, the
founder of the Royal Family, whose name is just a single uppercase letter.

For example, ENERYS could be the mother of AENERYS (as the name AENERYS consists of the single uppercase letter 'A' concatenated with ENERYS, which is her mother's name). Similarly, AENERYS could be the mother of DAENERYS and YAENERYS.

You are given the description of all the Royal Ladies. Your task is to determine, for certain interesting strings $s$, the number of Royal Ladies for whom s is a prefix of their name.

For example, consider Sample Input 1 below, with a Royal Line that goes straight from the founder S to AENERYS (through YS, RYS, ERYS, NERYS and ENERYS), with each Lady having exactly one daughter. Then AENERYS has two daughters—DAENERYS and YAENERYS, with the latter havingone daughter, RYAENERYS.

In such a family, RY is a prefix of the names of two ladies: RYS and RYAENERYS. E is a prefix of the names of ERYS and ENERYS. N is a prefix only of NERYS's name, while S is a prefix only of the nameof the founder, S. AY is not a prefix of any Royal Lady's name.

## 输入格式

The first line of input contains two integers $n$ and $k$, where $n$ $(1 \leq n \leq 10^6)$ is the total number of Royal Ladies and $k$ $(1 \leq k \leq 10^6)$ is the number of query strings.

Then follow n lines describing the Royal Ladies. The $i^{th}$ of these lines describes the Royal Lady numbered $i$, and contains an uppercase letter $c_i$ ('A'–'Z') and an integer $p_i$, where $c_i$ is the first letter of the name of Lady $i$, and $p_i$ $(p1 = 0$ and $1 \leq pi \lt i$ for $i \gt 1)$ is the number of her mother (or $0$, in the case
of the First Lady). All the names are unique.

The remaining $k$ lines each contain one nonempty query string, consisting only of uppercase letters. The sum of the lengths of the query strings is at most $10^6$.
## 输出格式

Output $k$ lines, with the $i^{th}$ line containing the number of Royal Ladies who have the $i^{th}$ query string as a prefix of their name.
## 样例

### 样例输入 #1
```
10 5
S 0
Y 1
R 2
E 3
N 4
E 5
A 6
D 7
Y 7
R 9
RY
E
N
S
AY
```
### 样例输出 #1
```
2
2
1
1
0
```
## 提示

Source: ICPC World Finals 2019.
## 题目翻译

**题目描述**



众所周知，皇室家族的名字非常有讲究。而作为研究皇室的历史学家的你，最近接到了一个艰巨的任务——分析王国历史中所有皇室夫人的名字。



王国历史上有 $n$ 位皇室夫人，方便起见，我们将其从 $1$ 至 $n$ 编号。除了 $1$ 号夫人外，其余夫人的名字均为一个大写字母连接着她母亲的名字。而 $1$ 号夫人作为王国的首任王后，她的名字只有一个大写字母。



例如，由于 `AENERYS` 由 `A` 与 `ENERYS` 组成，因此 `ENERYS` 是 `AENERYS` 的母亲。相似地，`AENERYS` 是 `DAENERYS` 与 `YAENERYS` 的母亲。



你知道王国历史上所有皇室夫人的姓名与关系，而你需要完成的任务是，对于其他历史学家感兴趣的名字串 $s$，总共有多少位夫人的名字是以 $s$ 起始的。



例如在样例的皇室族谱中，`S` 至 `AENERYS` 的这一支（包含 `YS`、`RYS`、`ERYS`、`NERYS` 与 `ENERYS` 这几位夫人）均只有一位女儿。接下来 `AENERYS` 有两位女儿，分别是 `DAENERYS`，以及女儿是 `RYAENERYS` 的 `YAENERYS`。



在这个皇室家族内，有两位夫人的名字以 `RY` 起始，她们是 `RYS` 与 `RYAENERYS`。而 `ERYS` 与 `ENERYS` 均以 `E` 起始。名字以 `N` 起始的仅有一位夫人 `NERYS`。同样地，以 `S` 起始的仅有首位王后 `S`。而没有任何一位夫人的名字以 `AY` 起始。



**输入格式**



第一行有两个整数 $n,k$，分别代表王国历史上皇室夫人总数，以及其他历史学家感兴趣的名字串的个数。



接下来 $n$ 行描述所有皇室夫人的姓名与关系。第 $i+1$ 行描述第 $i$ 位夫人的资料 $c_i$ 与 $p_i$，其中字符 $c_i$ 表示她名字的首位字母，$p_i$ 为她母亲的编号。对于编号为 $1$ 的首位王后，$p_1=0$。所有夫人的名字均不重复。



接下来 $k$ 行，每行为一个大写字母构成的非空串，代表一个其他历史学家感兴趣的名字串。



**输出格式**



输出 $k$ 行，第 $i$ 行为一个整数，代表总共有多少位夫人的名字是以第 $i$ 个感兴趣的名字串起始的。



**数据范围**



$1\leq n\leq 10^6$，$1\leq k\leq 10^6$，$p_1=0$，特别地，对于 $1\lt i\leq n$，保证有 $1\leq p_i\lt i$。感兴趣的名字串总长不超过 $10^6$。


---

---
title: "[ICPC 2019 WF] Miniature Golf"
layout: "post"
diff: 省选/NOI-
pid: P6260
tag: ['2019', 'O2优化', 'ICPC']
---
# [ICPC 2019 WF] Miniature Golf
## 题目背景

### Warning: If you submit a malicious program, you will be banned.
### 警告：恶意提交本题将被封号。

## 题目描述

A group of friends has just played a round of miniature golf. Miniature golf courses consist of a number of holes. Each player takes a turn to play each hole by hitting a ball repeatedly until it drops into the hole.
A player's score on that hole is the number of times they hit the ball. 
To prevent incompetent players slowing down the game too much, there is also an upper limit $l$ (a positive integer) on the score: if a player has hit the ball $l$ times without the ball dropping into the hole, the score for that hole is recorded as $l$ and that player's turn is over. The total score of each player is simply the sum of their scores on all the holes. Naturally, a lower score is considered better.

There is only one problem: none of the players can remember the value of the integer $l$. They decide that they will not apply any upper limit while playing, allowing each player to keep playing until the ball
drops into the hole. After the game they intend to look up the value of $l$ and adjust the scores, replacing any score on a hole that is larger than $l$ with $l$.

The game has just finished, but the players have not yet looked up $l$. They wonder what their best possible ranks are. For this problem, the rank of a player is the number of players who achieved an equal or lower total score after the scores are adjusted with $l$. For example, if the adjusted scores of the players are $3, 5, 5, 4,$ and $3$, then their ranks are $2, 5, 5, 3$ and $2$ respectively.

Given the scores of the players on each hole, determine the smallest possible rank for each player.
## 输入格式

The first line of input contains two integers $p$ and $h$, where $p$ $(2 \leq p \leq 500)$ is the number of players and $h$ $(1 \leq h \leq 50)$ is the number of holes. The next $p$ lines each contain $h$ positive integers. The $j^{th}$ number on the $i^{th}$ of these lines is the score for player $i$ on hole $j$, and does not exceed $10^9$.

## 输出格式

Output a line with the minimum possible rank for each player, in the same order as players are listed in the input.
## 样例

### 样例输入 #1
```
3 3
2 2 2
4 2 1
4 4 1
```
### 样例输出 #1
```
1
2
2
```
### 样例输入 #2
```
6 4
3 1 2 2
4 3 2 2
6 6 3 2
7 3 4 3
3 4 2 4
2 3 3 5
```
### 样例输出 #2
```
1
2
5
5
4
3

```
## 提示

Source: ICPC World Finals 2019 Problem J: Miniature Golf.
## 题目翻译

### 题目描述
几个朋友玩了一场小型的高尔夫。这种小型的高尔夫是由若干个洞组成的。每个玩家轮流玩这个游戏，不停地击球直到球落到每个洞里。玩家在一个洞上的得分是他击球的次数。为了防止捣乱的玩家把游戏速度放慢太多，游戏规则中也会给一个上限$l$（一个正整数）来控制分数：如果一个玩家在一个洞上已经击球$l$次，但是球还没有落到洞里，那么这个玩家在这个洞上的得分就是$l$，并且这个玩家的回合就结束了。一个玩家的总得分就是他在各个洞上的得分之和。自然地，在这个游戏中，分越低越好。

但是有一个问题：没有玩家记得$l$的值。玩家们决定在玩的时候不设置$l$的值，允许每个玩家不断击球，直到球掉到洞里。玩完游戏，他们准备设置$l$的值，并更改那些在洞上的分数大于$l$的值。

游戏结束了，但他们还没有设置$l$。他们想知道自己的最佳排名是什么。一个人的排名是在所有人中，得分比这个人低或和这个人相等的人数（包含自己）。比如，当五个人的得分分别是 $3,5,5,4,3$，那么他们的排名就是 $2,5,5,3,2$。

给你每个玩家在每个洞上的得分，为每一个玩家求出最小的可能的排名。

### 输入格式

第一行：两个整数 $p$ 和 $h$，$p$（$2 \le p \le 500$）是玩家个数，$h$（$1 \le h \le 50$）是洞的个数。

接下来$p$行，每行$h$个正整数，第$i$行第$j$列的数表示第$i$个玩家在第$j$个洞上的得分，这些数都不会超过$10^9$。

### 输出格式

输出 $p$ 行，每行一个正整数，第 $i$ 行表示第 $i$ 个玩家的最小排名。

### 说明/提示

来源：ICPC World Finals 2019 Problem J 

题目名称：Miniature Golf


---

---
title: "[PA 2010] Planning the Roadworks"
layout: "post"
diff: 省选/NOI-
pid: P6379
tag: ['2010', 'Special Judge', 'O2优化', 'PA（波兰）']
---
# [PA 2010] Planning the Roadworks
## 题目描述

给定一个 $n$ 个点，$m$ 条边的有向图，求一个极大的可行边集使得删去这个边集之后原图连通性不变（能达到的仍然能到达）。

请给出一种可行的方案。
## 输入格式

第一行两个整数 $n$,$m$。

接下来 $m$ 行，每行两个数 $x,y$，表示存在一条从 $x$ 到 $y$ 的有向边。
## 输出格式

**本题存在 Special Judge**。

请在第一行输出一个整数 $k$，表示边集的大小。

接下来 $k$ 行，每行输出一个整数 $e_i$，表示删掉输入的第 $e_i$ 条边。

输入的边的编号从 $1$ 开始。
## 样例

### 样例输入 #1
```
5 6
1 2
1 3
2 3
3 2
2 4
3 4
```
### 样例输出 #1
```
2
2
6
```
## 提示

#### 样例 1 解释

一种可行的方案是，删除输入的第 $2$ 条边 $(1, 3)$ 和第 $6$ 条边 $(3, 4)$。

---

#### 数据规模与约定
对于全部的测试点，保证 $1\leq n\leq 5000$，$1\leq m\leq100000$，给定的图没有重边和自环。


---

---
title: "[SDOI2012] 棋盘覆盖"
layout: "post"
diff: 省选/NOI-
pid: P6407
tag: ['2012', '各省省选', '山东', 'O2优化']
---
# [SDOI2012] 棋盘覆盖
## 题目描述

在一个 $n\times m$ 的棋盘内，有 $K$ 个方格被称为特殊方格。我们要使用一组俄罗斯方块来覆盖这个棋盘，保证特殊方格不能被覆盖，非特殊方格只能被一个俄罗斯方块覆盖，求最多能容纳的俄罗斯方块的数量。

已知有以下三组俄罗斯方块，一个棋盘可能用其中的某一组。

![](https://cdn.luogu.com.cn/upload/image_hosting/8ck63qab.png)
## 输入格式

第一行三个整数 $n,m,K$ 和一个字符 `type` 为所用的俄罗斯方块组。

接下来 $K$ 行每行两个整数 $x,y$ 表示第 $x$ 行第 $y$ 列为特殊方格。
## 输出格式

一个整数，为所求的答案。
## 样例

### 样例输入 #1
```
8 8 0 A
```
### 样例输出 #1
```
32
```
### 样例输入 #2
```
7 6 6 C
3 1
3 6
5 3
5 4
5 7
6 7
```
### 样例输出 #2
```
12
```
## 提示

对于测试点 $1\sim 6$，$1\le n,m\le 100$，$0\le K\le nm$，`type` 为 `A`；

对于测试点 $7\sim 12$，$2\le n=m\le 2^{2\times 10^5}$，$n,m$ 为 $2$ 的整数次幂，$K=1$，`type` 为 `B`；

对于测试点 $13\sim 21$，$1\le n,m\le 11$，$0\le K\le nm$，`type` 为 `C`。


---

---
title: "[COCI 2008/2009 #3] NAJKRACI"
layout: "post"
diff: 省选/NOI-
pid: P6413
tag: ['2008', 'COCI（克罗地亚）']
---
# [COCI 2008/2009 #3] NAJKRACI
## 题目描述

有一个含 $n$ 个点，$m$ 条边的**有向图**。

对于每一条边，求出它被任意两点的最短路径经过的次数对 $10^9+7$ 取模的值。

如果 $A, B$ 两点之间有多条最短路，每条最短路都要计算一遍。你可以参考样例 $4$ 中第 $3, 4$ 条边的输出来理解这句话。
## 输入格式

第一行两个整数 $n$ 和 $m$。

接下来 $m$ 行，每行三个整数 $x$ ，$y$，$d$，即有一条 $x$ 到 $y$ 的有向边，边权为 $d$。
## 输出格式

共 $m$ 行，每一行输出一个整数，第 $i$ 行的数表示在第 $i+1$ 行读入的边被任意两点的最短路径经过的次数对 $10^9+7$ 取模的值。
## 样例

### 样例输入 #1
```
4 3
1 2 5
2 3 5
3 4 5 

```
### 样例输出 #1
```
3
4
3 
```
### 样例输入 #2
```
4 4
1 2 5
2 3 5
3 4 5
1 4 8 

```
### 样例输出 #2
```
2
3
2
1 
```
### 样例输入 #3
```
5 8
1 2 20
1 3 2
2 3 2
4 2 3
4 2 3
3 4 5
4 3 5
5 4 20 

```
### 样例输出 #3
```
0
4
6
6
6
7
2
6 
```
### 样例输入 #4
```
4 4
1 2 1
2 3 1
1 3 2
3 4 1

```
### 样例输出 #4
```
3
4
2
4
```
## 提示

#### 数据范围与约定
- 对于 $30\%$ 的数据，保证 $n\le 15$，$m\le 30$。
- 对于 $60\%$ 的数据，保证 $n\le 300$，$m\le 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 1.5\times 10^3$，$1\le m\le 5\times 10^3$，$a\neq b$，$1\le a,b\le n$，$1\le d\le 10^4$。
#### 说明
本题译自 [Croatian Open Competition in Informatics 2008/2009](https://hsin.hr/coci/archive/2008_2009) [Contest #3](https://hsin.hr/coci/archive/2008_2009/contest3_tasks.pdf) T6 NAJKRACI。


---

---
title: "[COCI 2008/2009 #2] CAVLI"
layout: "post"
diff: 省选/NOI-
pid: P6425
tag: ['2008', 'COCI（克罗地亚）']
---
# [COCI 2008/2009 #2] CAVLI
## 题目描述

Mirko 在阁楼上发现了一块木板和 $n$ 个钉子。 Mirko 尽快将钉子钉在板上。 通过坐标平面对板进行建模，钉子作为其中的点。 没有两个钉子具有相同的 $x$ 或 $y$ 坐标。
为了继续玩乐，Mirko 偷走了姐姐的松紧发带，将其散布在所有的钉子上，然后放开。 松紧带自然在钉子周围收紧。

然后，Mirko 重复这些步骤，保证在板上至少留下三个钉子：

1. 记录下由发圈围成的图形面积；

2. 在板上选择最左边，最右边，最上面或最下面的钉子。

3. 从板上卸下选择的钉子； 松紧带再次把仍留在板上的最靠外钉子绑起来。
   现在我们知道 Mirko 在每次执行步骤 $2$ 时选择的钉子，编写一个程序来计算在每次执行步骤 $1$ 时计算出的图形面积的大小。
## 输入格式

第一行一个整数 $n$，表示钉子的个数。

接下来 $n$ 行，每行两个整数 $x_i$ 和 $y_i$，用空格隔开，表示第 $i$ 个钉子的坐标。

下面一行一个字符串，由 $n-2$ 个字符组成，这些字符可能为 `L`，`R`，`U`，`D`，分别表示 Mirko 选择拔掉的钉子。这四个字符的含义如下：

- `L` 表示拔掉最左边的钉子（横坐标最小的钉子）；
- `R` 表示拔掉最右边的钉子（横坐标最大的钉子）；
- `U` 表示拔掉最上方的钉子（纵坐标最大的钉子）；
- `D` 表示拔掉最下方的钉子（纵坐标最小的钉子）。
## 输出格式

共 $n-2$ 行，每行一个浮点数，表示每一次执行步骤 $1$ 时计算出的图形面积的大小，保留一位小数。
## 样例

### 样例输入 #1
```
5
1 4
2 2
4 1
3 5
5 3
LUR
```
### 样例输出 #1
```
9.0
6.5
2.5
```
### 样例输入 #2
```
8
1 6
2 4
3 1
4 2
5 7
6 5
7 9
8 3
URDLUU
```
### 样例输出 #2
```
34.0
24.0
16.5
14.0
9.5
5.0
```
## 提示

#### 样例 #2 解释：
![](https://cdn.luogu.com.cn/upload/image_hosting/y16d8wid.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/qefp7alq.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/puomeovd.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/lp53b1zy.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/6rgbxuyo.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/5g5xhv94.png)

以上是对于样例 #2 的输入数据，程序应该按顺序模拟的六个步骤。
#### 数据规模与约定
- 对于 $50\%$ 的数据，保证 $3 \leq n \leq 1000$。
- 对于 $100\%$ 的数据，保证 $3 \leq n \leq 3 \times 10^5$。
#### 说明
#### 题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #2](https://hsin.hr/coci/archive/2008_2009/contest2_tasks.pdf) CAVLI，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。


---

---
title: "[COCI 2008/2009 #1] KRTICA"
layout: "post"
diff: 省选/NOI-
pid: P6431
tag: ['2008', 'Special Judge', 'O2优化', 'COCI（克罗地亚）']
---
# [COCI 2008/2009 #1] KRTICA
## 题目描述

有一棵 $n$ 个点的树，边权都为 $1$。

现在想删去一条边，增加一条边，使得最远的两个点距离最短。
## 输入格式

第一行为一个整数 $n$。

接下来 $n-1$ 行，每行两个整数 $a$ 和 $b$，表示有树上有一条从 $a$ 到 $b$ 的无向边。
## 输出格式

**本题存在 SPJ**。

第一行只有一个整数，表示删去一条边，增加一条边后最远的两个点的距离。

第二行两个整数，表示被删掉的一条边。

第三行两个整数，表示被增加的一条边。
## 样例

### 样例输入 #1
```
4
1 2
2 3
3 4 
```
### 样例输出 #1
```
2
3 4
4 2 

```
### 样例输入 #2
```
7
1 3
2 3
2 7
4 3
7 5
3 6 

```
### 样例输出 #2
```
3
2 3
7 3 
```
## 提示

#### 数据规模与约定
- 对于 $40\%$ 的数据，保证 $n\le 30$。
- 对于 $70\%$ 的数据，保证 $n\le 3\times 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n \le 3\times 10^5$，$1\le a,b\le n$。

---

#### 计分标准

- 如果输出的第一行不正确，得 $0$ 分。
- 如果输出得第一行正确，但是剩下的数字不正确或数量不足四个，得对应测试点 $70\%$ 的分数。
- 如果输出第一行正确，且给出的方案是可行且正确的，得到对应测试点 $100\%$ 的分数。

---
#### 说明
本题译自 [Croatian Open Competition in Informatics 2008/2009](https://hsin.hr/coci/archive/2008_2009) [Contest #1](https://hsin.hr/coci/archive/2008_2009/contest1_tasks.pdf) T6 KRTICA。

SPJ provided by @Tweetuzki 


---

---
title: "[COCI 2008/2009 #4] TREZOR"
layout: "post"
diff: 省选/NOI-
pid: P6452
tag: ['2008', 'COCI（克罗地亚）']
---
# [COCI 2008/2009 #4] TREZOR
## 题目描述

在平面直角坐标系中，有一个以 $(1,-A)$ 和 $(L,B)$ 为对角线上的两个端点的矩形。这个矩形内有 $L\times (A+1+B)$ 个点。

现在有两名警卫分别在 $(0,-A)$ 和 $(0,B)$ 两个点。他们都看向这个矩形。如果他的视线（为一条射线）与矩形内的一个点之间有其他点阻隔，那么他就看不到这个点。

对于每一个点：

- 如果它能被两个警卫都看到，那么就认为它是非常安全的；
- 如果z只能被其中一个警卫都看到，那么就认为它是安全的；
- 如果两个警卫都看不到它，那么就认为它是危险的。

给定 $A,B,L$，你需要找出非常安全的点、安全的点和危险的点分别的数量。

## 输入格式

输入第一行为两个整数 $A,B$。

第二行为一个整数 $L$。
## 输出格式

输出共 $3$ 行。每行一个整数，依次为危险、安全、非常安全的点的数量。
## 样例

### 样例输入 #1
```
1 1
3
```
### 样例输出 #1
```
2
2
5
```
### 样例输入 #2
```
2 3
4
```
### 样例输出 #2
```
0
16
8
```
### 样例输入 #3
```
7 11
1000000
```
### 样例输出 #3
```
6723409
2301730
9974861
```
## 提示

#### 数据规模与约定

- 对于 $50\%$ 的数据，$L\le 1000$；
- 对于另 $25\%$ 的数据，$A,B\le 100$；
- 对于 $100\%$ 的数据，$1\le A,B\le 2000$，$1\le L\le 10^9$。

#### 说明

**题目译自 [COCI2008-2009](https://hsin.hr/coci/archive/2008_2009/) [CONTEST #4](https://hsin.hr/coci/archive/2008_2009/contest4_tasks.pdf) *T5 TREZOR***。


---

---
title: "[COCI 2010/2011 #4] DUGOVI"
layout: "post"
diff: 省选/NOI-
pid: P6486
tag: ['2010', 'O2优化', 'COCI（克罗地亚）']
---
# [COCI 2010/2011 #4] DUGOVI
## 题目描述

在一个小镇上有 $n$ 位居民，每位居民都**恰好从其他一位**居民那里借了一些钱。

现在到了还债的时间。但问题是每个人都把自己的钱用完了；也就是说任何人都无力偿还债务。这样以来产生了很多冲突。

市长决定解决这个问题。他预想要给一部分居民一些钱，以便于他们用来还债。不过当一部分居民拿到了钱，一系列的连锁反应就开始了。

例如， $A$ 从市长那里得到了钱。$A$ 赶忙用这些钱偿还 $B$ 的债务。$B$ 也正好偿还 $C$ 的债务，以此类推。

其中，如果 $B$ 没有足够的钱来一次还清，那么他会把钱暂时留在自己手里等到钱够了；如果还完债后还有剩余， $B$ 也会自己留着。（$B$ 的行为对于任意一个人适用）

另一个例子：如果两个镇上的居民**互欠**对方 $100$ 美元，那么市长只需要给其中一个人 $100$ 美元，这两个债务就都解决了。

你需要通过程序来计算出：市长至少要支出多少元给一部分居民才能平息一切债务？
## 输入格式

输入一行一个整数 $n$，表示镇上居民的数量。

接下来的 $n$ 行，每行两个整数 $A_i,B_i$，表示第 $i$ 个人欠第 $A_i$ 个人 $B_i$ 美元。

居民从 $1\sim n$ 编号。
## 输出格式

输出一行一个整数，表示市长最少支出的金额。
## 样例

### 样例输入 #1
```
4
2 100
1 100
4 70
3 70
```
### 样例输出 #1
```
170
```
### 样例输入 #2
```
3
2 120
3 50
2 80
```
### 样例输出 #2
```
150
```
### 样例输入 #3
```
5
3 30
3 20
4 100
5 40
3 60
```
### 样例输出 #3
```
110
```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2\le n\le 2\times 10^5$，$1\le A_i\le n$ 且 $A_i\neq i$，$1\le B_i\le 10^4$。

#### 说明

**题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #4](https://hsin.hr/coci/archive/2010_2011/contest4_tasks.pdf) *T5 DUGOVI***。


---

---
title: "[COCI 2016/2017 #2] Zamjene"
layout: "post"
diff: 省选/NOI-
pid: P6498
tag: ['2016', 'O2优化', 'COCI（克罗地亚）']
---
# [COCI 2016/2017 #2] Zamjene
## 题目背景

**警告：滥用本题评测将被封号。**
## 题目描述

Dominik 构造了一个含有 $n$ 个元素的数组 $p_1,p_2,\dots,p_n$，和对其排序得到的数组 $q_1,q_2,\dots,q_n$。

此外，他还定义了「可交换集」。若无序数对 $(a,b)$ 属于「可交换集」，则他可以交换 $p_a,p_b$ 的位置。『通过「可交换集」』，即为**通过若干次这样的交换**。

现有四种操作：

- 操作 $1$：

	格式：`1 a b`。
    
    交换 $p_a,p_b$ 的位置（不受「可交换集」限制）。
    
- 操作 $2$：

	格式：`2 a b`。
    
    将无序数对 $(a,b)$ 加入「可交换集」。
    
- 操作 $3$：
	
    格式：`3`。
    
    判断能否通过「可交换集」完成对数组 $p$ 的排序。
    
- 操作 $4$：

	格式：`4`。
    
    若数组 $p$ 中的第 $x$ 个元素能通过「可交换集」移至第 $y$ 位，则称 $x,y$ 是相连的。其中 $x$ 可能等于 $y$。
    
    将所有与 $x$ 相连的 $y$ 构成的集合称作 $x$ 的「云」。若一朵「云」能通过「可交换集」使得「云」中任意的 $i$ 满足 $p_i=q_i$，则称这朵「云」是「祥云」。
    
    计算有多少组无序数对 $(a,b)$ 满足：
    
    - $1\le a,b\le n$ 且 $a\not=b$。
	- $a,b$ 不是相连的。
	- $a$ 的「云」与 $b$ 的「云」均不是「祥云」。
    - 将无序数对 $(a,b)$ 加入「可交换集」后，$a$ 的「云」变为「祥云」。
    
请你帮助 Dominik 完成这些操作。
## 输入格式

第一行两个整数 $n,q$，表示数组 $p$ 中元素的个数和操作次数。

第二行 $n$ 个整数 $p_i$。

接下来 $q$ 行按以下格式给出：

1. 一个整数 $t$，表示操作的类型。

2. 若 $t$ 为 $1$ 或 $2$，接下来给出两个不同的整数 $a,b$。
## 输出格式

- 对于每一次操作 $3$：

	若能通过「可交换集」完成对数组 $p$ 的排序，输出一行 `DA`。

	否则，输出一行 `NE`。

- 对于每一次操作 $4$：

	输出一行，一个整数，表示满足条件的无序数对 $(a,b)$ 组数。
## 样例

### 样例输入 #1
```
3 5
1 3 2
4
3
2 2 3
4
3 
```
### 样例输出 #1
```
1
NE
0
DA 
```
### 样例输入 #2
```
5 5
4 2 1 4 4
3
4
1 1 3
3
4 
```
### 样例输出 #2
```
NE
1
DA
0 
```
### 样例输入 #3
```
4 10
2 1 4 3
3
4
1 1 2
3
4
2 2 3
2 1 2
4
2 3 4
3 
```
### 样例输出 #3
```
NE
2
NE
1
3
DA 
```
## 提示

#### 样例 1 解释

- 第一次操作：仅有无序数对 $(2,3)$ 满足要求。
- 第二次操作：不能通过「可交换集」完成对数组 $p$ 的排序。
- 第三次操作：将无序数对 $(2,3)$ 加入「可交换集」。
- 第四次操作：不存在满足要求的无序数对。
- 第五次操作：交换 $p_2,p_3$，即可通过「可交换集」完成对数组 $p$ 的排序。

------------

#### 数据规模与约定

对于 $100\%$ 的数据，$1\le n,q\le 10^6$，$1\le p_i\le 10^6$，$1\le t\le 4$，$1\le a,b\le n$ 且 $a\not=b$。

------------

#### 说明

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #2](https://hsin.hr/coci/archive/2016_2017/contest2_tasks.pdf) _T5 Zamjene_**。


---

---
title: "[COCI 2016/2017 #2] Burza"
layout: "post"
diff: 省选/NOI-
pid: P6499
tag: ['2016', 'COCI（克罗地亚）']
---
# [COCI 2016/2017 #2] Burza
## 题目描述

Daniel 和 Stjepan 在一棵含有 $n$ 个节点的树上做游戏，树上各节点的编号为 $1,2,\dots,n$。游戏开始时，$1$ 号节点上有一枚硬币。

游戏规则如下：

1. Daniel 选择一个节点，将其标记。
2. Stjepan 标记当前硬币所在的节点。
3. Stjepan 将硬币移至一个**尚未标记**且**与当前所在的节点相邻**的节点。

重复以上操作。当 Stjepan 无法移动硬币时，游戏结束。

Daniel 想知道是否存在某种**既定**的操作策略，使得**无论 Stjepan 如何操作**，都能在 $k$ 轮操作内结束游戏。即 Stjepan 能移动硬币的次数**小于** $k$。
## 输入格式

第一行两个整数 $n,k$。

接下来 $n-1$ 行，每行两个整数 $a,b$，表示编号为 $a,b$ 的结点间存在一条边。
## 输出格式

若存在满足条件的操作策略，输出一行 `DA`。

否则，输出一行 `NE`。
## 样例

### 样例输入 #1
```
6 2
1 2
2 3
3 4
1 5
5 6 
```
### 样例输出 #1
```
DA 
```
### 样例输入 #2
```
3 1
1 2
1 3 
```
### 样例输出 #2
```
NE 
```
### 样例输入 #3
```
8 2
1 2
2 3
2 4
5 6
6 8
1 5
7 1 
```
### 样例输出 #3
```
DA 
```
## 提示

#### 【样例解释】

**样例 2 解释**

- 若 Daniel 标记结点 $1$，Stjepan 可以将硬币移至结点 $2$ 或结点 $3$。
- 若 Daniel 标记结点 $2$，Stjepan 可以将硬币移至结点 $3$。
- 若 Daniel 标记结点 $3$，Stjepan 可以将硬币移至结点 $2$。

均不能在 $1$ 轮操作内结束游戏。

即不存在满足条件的操作策略。

**样例 3 解释**

- 第一轮操作，Daniel 标记结点 $2$。
- 第二轮操作，Daniel 标记结点 $6$。

无论 Stjepan 如何操作，都无法第二次移动硬币。

即存在满足条件的操作策略。

------------

#### 【数据规模与约定】

对于 $100\%$ 的数据，$1\le k\le n\le 400$，$1\le a,b\le n$。

------------

#### 【说明】

**题目译自 [COCI2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #2](https://hsin.hr/coci/archive/2016_2017/contest2_tasks.pdf) _T6 Burza_**。


---

---
title: "[COCI 2015/2016 #1] UZASTOPNI"
layout: "post"
diff: 省选/NOI-
pid: P6534
tag: ['2015', 'COCI（克罗地亚）']
---
# [COCI 2015/2016 #1] UZASTOPNI
## 题目描述

这里有一棵有 $n$ 个点的树，每一个树上的节点有一个权值，即为 $v_i$，以 $1$ 为根，点以 $1\sim n$ 编号。

现在，我们想从选出一些点，并满足以下条件：

1. 一个点的父亲点若未被选择则其不能被选择。
1. 所选点的集合内不能有相同的权值。
1. 对于每一个选择的点，其子树中所有被选择点的权值必须可以构成公差为 $1$ 的等差数列。

您只需要输出满足上述条件的方案个数。

**注意：这里的方案指所选的数的集合不同的方案。**
## 输入格式

第一行为一个整数 $n$。

接下来一行 $n$ 个整数 $v_i$。

接下来 $n-1$ 行，一行两个整数 $a_i,b_i$，第 $i$ 行描述树上有一条以 $a_i$ 为父亲，$b_i$ 为儿子的边。 
## 输出格式

仅一行一个整数，表示满足上述条件的方案个数。
## 样例

### 样例输入 #1
```
4
2 1 3 4
1 2
1 3
3 4 
```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
4
3 4 5 6
1 2
1 3
2 4
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
6
5 3 6 4 2 1
1 2
1 3
1 4
2 5
5 6 
```
### 样例输出 #3
```
10
```
## 提示

#### 【样例解释】
#### 样例 1 解释
如下为选点的权值的六种情况：

$\{2\},\{2,3\},\{2,3,4\},\{1,2,3,4\},\{1,2\},\{1,2,3\}$。

#### 样例 2 解释
如下为选点的权值的三种情况：

$\{3\},\{3,4\},\{3,4,5\}$。

注意到不能选权值为 $6$ 的点，因为其父亲点与其构成的子树 $\{4,6\}$ 不符条件。
#### 【数据范围及限制】
- 对于 $50\%$ 的数据，保证 $n\le 100$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^4$，$1\le v_i\le 100$，$1\le a_i,b_i\le n$。
#### 【说明】
**本题满分 $160$ 分。**

本题译自 [Croatian Open Competition in Informatics 2015/2016](https://hsin.hr/coci/archive/2015_2016) [Contest #1](https://hsin.hr/coci/archive/2015_2016/contest1_tasks.pdf) T6 UZASTOPNI。


---

---
title: "[CEOI 2014] 007"
layout: "post"
diff: 省选/NOI-
pid: P6543
tag: ['2014', 'Special Judge', 'O2优化', 'CEOI（中欧）']
---
# [CEOI 2014] 007
## 题目背景

CEOI2014 Day2 T1，译者：小粉兔
## 题目描述

007 特工发现了她最大的敌人 De Referenced Nullpointer 博士（简称 Dr. Null）的一个阴谋：Dr. Null 将要摧毁洛谷的两台服务器中的某一台！Dr. Null 正准备去实施他的方案，并且他也正在去服务器的路上。很遗憾，这意味着 007 必须告别她正在泡着帅哥吃早餐的生活。

007 和 Dr. Null 都入侵了一个卫星系统，所以他们总是知道对方的位置。卫星系统把地图表示为一个**连通**的无向图，007 和 Dr. Null 以及两台服务器都位于节点上。**特别地，保证两台服务器位于相邻的两个节点上**。007 和 Dr. Null 都可以在一个单位时间内移动一条边，不过也可以不移动。Dr. Null 摧毁服务器也需要一个单位时间。Dr. Null 和 007 轮流行动，Dr. Null 先手。

如果 007 抓住了 Dr. Null（他们位于同一个节点上）或者可以保证 Dr. Null 在无限长的时间内无法摧毁服务器，就算 007 获胜。

007 想要知道她现在能吃着早餐泡帅哥最迟到什么时候，以确保无论 Dr. Null 采取什么策略依然可以取得胜利。

请你帮助 007 编写一个程序，计算她为了确保胜利，最迟停下吃早餐的时间。注意：当 007 还在吃早餐的时候她是没有办法抓住 Dr. Null 的，即使他们位于同一个节点上也不行。
## 输入格式

第一行两个正整数 $n, m$，分别表示图中节点数和边数。  
第二行四个互不相同的正整数 $s, d, a, b$，分别表示 007 的初始位置，Dr. Null 的初始位置，以及两台服务器的位置。  
接下来 $m$ 行，每行两个正整数 $u, v$，表示一条连接节点 $u$ 和 $v$ 之间的边。
## 输出格式

输出一行一个数，表示为了确保胜利，007 最多还能吃多久的早餐。具体地说，如果 007 在一开始就必须行动则输出 $0$。  
如果 007 无论如何都无法胜利，输出 $-1$。
## 样例

### 样例输入 #1
```
6 6
1 2 3 4
1 5
5 6
6 3
6 4
1 2
3 4
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
6 7
5 6 1 2
6 3
1 2
1 3
2 3
1 5
2 4
5 4
```
### 样例输出 #2
```
0
```
## 提示

对于所有数据，保证 $4 \le n \le 2 \times {10}^5$，$3 \le m \le 6 \times {10}^5$，$1 \le s, d, a, b \le n$ 且互不相同，保证图连通。

| 子任务编号 | 分值 | 特殊限制 |
| :-: | :-: | :-: |
| $1$ | $30$ | $n \le 800$，$m \le 1600$ |
| $2$ | $70$ | 无特殊限制 |

**部分分设置**：对于每个子任务，如果你的程序的输出在其中至少一组测试点中比非负的正确答案少 $1$ 并且在其它测试点中完全正确，则你将获得该子任务的 $30 \%$ 的分数。注意如果正确答案是 $0$ 时你的程序输出 $-1$ 也算作这种情况。


---

---
title: "[COCI 2010/2011 #2] CRNI"
layout: "post"
diff: 省选/NOI-
pid: P6551
tag: ['2010', 'COCI（克罗地亚）']
---
# [COCI 2010/2011 #2] CRNI
## 题目描述

尽管 Mirko 找到了所有最有趣的游乐设施，但他的热情仍然没有消失。 他打开方格纸笔记本，开始给方块上色，一个新的甚至更难的问题浮现在他身上。

您将得到一个 $n \times n$ 的表格。 每个单元格的颜色是黑色或白色。

如果表格内的某一个矩形图形的所有单元格均为黑色并且此矩形由至少两个单元格组成，则此矩形称为黑色矩形。

![](https://cdn.luogu.com.cn/upload/image_hosting/h7lgmovq.png)

上左图举了两个不是黑色矩形的例子。 标为 $1$ 的矩形不是黑色矩形，因为它包含一个白色单元格；标为 $2$ 的矩形不是黑色矩形，因为它仅包含一个单元格。 上右图则举了三个黑色矩形的例子。

计算选择两个没有公共单元格的黑色矩形的方法数。 由于所求的结果可能非常大，因此您应该输出该数除以 $10^4 + 7$ 后的余数。
## 输入格式

第一行一个整数 $n$，具体含义请见题目描述。

接下来 $n$ 行，每行一个长度为 $n$ 的大写字符串（由 `C`（表示该单元格颜色为黑）和 `B`（表示该单元格颜色为白）两种字符组成），表示表格。
## 输出格式

一行一个整数，表示所求方法数除以 $10^4 + 7$ 后的余数。
## 样例

### 样例输入 #1
```
2
CC
CC
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
3
CCB
CCB
CBB
```
### 样例输出 #2
```
5
```
### 样例输入 #3
```
5
BCCBB
BBCBB
BCCBB
BBBBB
CCBBB
```
### 样例输出 #3
```
8
```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $2 \leq n \leq 1 \times 10^3$，输入字符串的每一位只可能是 `C` 或 `B`，令 $|s|$ 为每个字符串长度，则 $|s| = n$。

#### 说明

- 本题满分 $130$ 分。
- 题目译自 [COCI2010-2011](https://hsin.hr/coci/archive/2010_2011/) [CONTEST #2](https://hsin.hr/coci/archive/2010_2011/contest2_tasks.pdf) CRNI，译者 @[mnesia](https://www.luogu.com.cn/user/115711)。


---

---
title: "The Forest"
layout: "post"
diff: 省选/NOI-
pid: P6556
tag: ['O2优化']
---
# The Forest
## 题目背景

Deep in the forest, swift in the night.

They come out, with the frightening shouting under the moonlight.

You stare at the horrible figures. They are real, alive.

I promise you've never experienced a worse night.

They come nearer, nearer, till a meter left.

You see their real faces. Scary eyes and hair in a mess.

You think they coming for you, then you are wrong.

They only want your delicious cheese, which is produced in a scary farm.

That's what happens in the forest. Enjoy your time!
## 题目描述

**请注意，本题的时间限制为 5s！**

探险家小 A 和小 B 需要用灯泡照亮这个森林。

有 $n$ 个灯泡，编号为 $1, 2, \cdots, n$。小 A 用 $n - 1$ 条红色绳子把它们连成了一棵树，小 B 用 $n - 1$ 条蓝色绳子把它们连成了另一棵树。

一开始所有灯泡都是熄灭的，现在要点亮若干个灯泡。小 A 喜欢联通块，而小 B 喜欢链。他们想知道：有多少种点亮灯泡的方案，满足点亮的灯泡在小 A 的树上形成一个联通块，在小 B 的树上形成一条链呢？
## 输入格式

第一行一个数 $T$，表示有 $T$ 组数据，对于每组数据：

第一行一个数 $n$。

第 $2$ 行到第 $n$ 行，第 $i + 1$ 行两个数 $a_i, b_i$，表示小 A 的树上的一条边。

第 $n + 1$ 行到第 $2n - 1$ 行，第 $i + n$ 行两个数 $c_i, d_i$，表示小 B 的树上的一条边。
## 输出格式

输出 $T$ 行，第 $i$ 行是第 $i$ 组数据的答案。
## 样例

### 样例输入 #1
```
3
3
1 2
2 3
1 2
1 3
5
1 2
1 3
2 4
2 5
1 2
2 3
3 4
4 5
5
3 1
3 2
3 4
3 5 
1 2
2 3
3 4
3 5

```
### 样例输出 #1
```
5
9
14

```
## 提示

**样例解释：**

[点击查看三组数据的图解](https://www.luogu.com.cn/paste/l5u1f2ob)。

对于第一组数据，可以点亮的灯泡集合有：

+ $\{1\}$；
+ $\{2\}$；
+ $\{3\}$；
+ $\{1, 2\}$；
+ $\{1, 2, 3\}$。

注意不能点亮集合 $\{1, 3\}$，因为编号为 $1, 3$ 的灯泡在小 A 的树上不构成联通块；也不能点亮集合 $\{2, 3\}$，因为编号为 $2, 3$ 的灯泡在小 B 的树上不构成一条链。

对于第二组数据，可以点亮的，**至少包含两个灯泡的**的灯泡集合有：

+ $\{1, 2\}$；
+ $\{1, 2, 3\}$；
+ $\{1, 2, 3, 4\}$；
+ $\{1, 2, 3, 4, 5\}$。

显然大小为 $1$ 的灯泡集合都合法，所以答案为 $4 + 5 = 9$。

**限制与约定：**

对于 $20 \%$ 的数据，$n \le 50$，满足特殊限制 $X$。  
对于 $40 \%$ 的数据，$n \le 3000$，满足特殊限制 $X$。  
对于 $70 \%$ 的数据，满足特殊限制 $X$。  
对于 $100 \%$ 的数据，$T = 3, 1 \le n \le 10^5$。

特殊限制 $X$：$c_i = i, d_i = i + 1$，也就是说**小 B 的树**是一条链，编号相邻的点之间有边。


---

---
title: "[NOI Online #3 提高组] 优秀子序列"
layout: "post"
diff: 省选/NOI-
pid: P6570
tag: ['2020', 'NOI Online']
---
# [NOI Online #3 提高组] 优秀子序列
## 题目描述

给定一个长度为 $n$ 的非负整数序列 $A=\{a_1,a_2,\cdots,a_n\}$，对于 $A$ 的一个子序列 $B=\{a_{b_1},a_{b_2},\cdots,a_{b_m}\}$（$0\le m\le n$，$1\le b_1<b_2<\cdots<b_m\le n$，下同），称 $B$ 是 $A$ 的优秀子序列当且仅当，其任意两个不同元素的按位与结果均为 $0$，即：$\forall 1\le i<j\le m$，满足：$a_{b_i}~\mathrm{and}~a_{b_j}=0$，其中 $~\mathrm{and}~$   是按位与运算。

对于子序列 $B=\{a_{b_1},a_{b_2},\cdots,a_{b_m}\}$，我们定义其价值为 $\varphi(1+\sum_{i=1}^m a_{b_i})$，其中 $\varphi(x)$ 表示小等于 $x$ 的正整数中与 $x$ 互质的数的个数。

现在请你求出 $A$ 的所有优秀子序列的价值之和，答案对 $10^9+7$ 取模。
## 输入格式

第一行一个正整数 $n$ 表示序列长度。

第二行 $n$ 个用空格分隔的非负整数，表示 $a_1,a_2,\cdots,a_n$。
## 输出格式

仅一行一个整数，表示答案对 $10^9+7$ 取模的结果。
## 样例

### 样例输入 #1
```
4
1 2 2 3
```
### 样例输出 #1
```
12
```
## 提示

#### 样例 1 解释
符合条件的子序列有：$\emptyset$，$\{1\}$，$\{2\}$，$\{2\}$，$\{3\}$，$\{1,2\}$，$\{1,2\}$，它们价值依次为 $1$，$1$，$2$，$2$，$2$，$2$，$2$，总和为 $12$。

#### 数据规模与约定
- 对于 $10\%$ 的数据，保证 $a_i\le 1$。
- 对于 $30\%$ 的数据，保证 $a_i\le 1000$。
- 对于 $60\%$ 的数据，保证 $a_i\le 30000$。
- 另有 $10\%$ 的数据，保证 $n\le 20$。
- 对于 $100\%$ 的数据，保证 $1\le n\le 10^6$，$0\le a_i\le 2\times 10^5$。


---

---
title: "[BalticOI 2017] Friends"
layout: "post"
diff: 省选/NOI-
pid: P6575
tag: ['2017', 'Special Judge', 'BalticOI（波罗的海）']
---
# [BalticOI 2017] Friends
## 题目背景

高中就是要交最棒的朋友！  
乌姆里奇校长要调查霍格沃茨学校的交友情况了！
## 题目描述

学校里有 $n$ 个同学，他们的交友情况满足以下的条件：

- 如果 $a$ 与 $b$ 是朋友那么 $b$ 与 $a$ 也是朋友；
- 同学们可以分成组，每个同学都恰好只在一个组里面，且：
	- 每个组的人数至少 $1$ 个最多 $p$ 个；
    - 每组都有这样最多 $q$ 对朋友满足一个人在这个组，另一个人在别的组。
    
在同一个组里的两个同学不一定必须是朋友。   
现在她来问您，想让您说出这些学生撒没撒谎。  
如果没有撒谎的话，她想让您给出一个合理的分组模式。
## 输入格式

第一行三个整数 $n,p,q$ 代表学生数，组别内学生的限制，和组别内不同组别朋友的限制。  
学生的编号为从 $0$ 到 $n - 1$。   
接下来 $n$ 行，从第 $0$ 个学生开始，首先一个整数 $m_i$ 代表这个学生与多少个学生为朋友，接下来 $m_i$ 个整数代表有哪些朋友。
## 输出格式

如果这些学生撒谎了，输出 `detention` 并结束程序。  
如果这些学生没撒谎，首先输出 `home`。  
然后一个整数 $G$ 代表这些学生可以分成 $G$ 组。  
接下来 $G$ 行每行首先一个整数 $G'$ 代表这一组有几个学生，然后 $G'$ 个整数 $g_i$ 代表这一组学生的编号。  
**任意输出一种方式即可。**
## 样例

### 样例输入 #1
```
4 2 1
1 1
2 0 2
2 1 3
1 2

```
### 样例输出 #1
```
home
2
2 0 1
2 2 3
```
### 样例输入 #2
```
5 2 1
1 1
2 0 2
2 1 3
2 2 4
1 3

```
### 样例输出 #2
```
detention
```
### 样例输入 #3
```
3 3 3
2 1 2
2 0 2
1 0

```
### 样例输出 #3
```
detention
```
## 提示

**数据规模与约定**

**本题采用捆绑测试。**

- Subtask 1（20 pts）：$n \le 16$。
- Subtask 2（37 pts）：$n \le 250$，$q \le 2$。
- Subtask 3（12 pts）：$q \le 2$。
- Subtask 4（31 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 2500$，$p+q \le 15$，$\sum m_i \le 30000$，同学们不以自己为朋友。

**本题使用 Special Judge。**

**说明**

**翻译自 [BOI 2017 D2](https://boi.cses.fi/files/boi2017_day2.pdf) T2 Friends。**  
翻译者：@[一只书虫仔](https://www.luogu.com.cn/user/114914)。

spj 提示信息说明：
- `Accepted`：答案正确。
- `Wrong Answer[0]`：判断错误。
- `Wrong Answer[1]`：某些组的大小不符合要求。
- `Wrong Answer[2]`：组里含有编号不在 $0$ 到 $n-1$ 内的人。
- `Wrong Answer[3]`：某些人属于多个组。
- `Wrong Answer[4]`：某些人不属于任何组。
- `Wrong Answer[5]`：分组不满足要求。

spj 作者：@[FZzzz](https://www.luogu.com.cn/user/174045)。


---

---
title: "中子衰变"
layout: "post"
diff: 省选/NOI-
pid: P6585
tag: ['交互题', 'Special Judge', '洛谷月赛']
---
# 中子衰变
## 题目背景

这是一道**交互题**。

可能会用到的前置知识：

质子带一个单位的正电荷。

电子带一个单位的负电荷。

中子不带电。
## 题目描述

Youyou 和小 Z 面前有 $n$ 个中子，从左往右排成一行，这些中子被强作用力固定在编号为 $1 \sim n$ 的位置上。

小 Z 拥有一台弱作用衰变机 Wadm（Weak Action Decay Machine）。Wadm 每次可以使一个中子发生弱作用衰变，放出一个电子和一个质子（本题中不考虑中微子），然后 Wadm 会根据 Youyou 或小 Z 的指令，留下其中一个粒子，然后将另一个粒子移出体系。

简而言之，Wadm 可以将一个中子变为一个电子或一个质子。

现在小 Z 想和 Youyou 玩一个游戏：两个人轮流使用 Wadm 操作一个中子，将其变为一个电子或一个质子。然而，如果一个电子和质子相邻，那么由于强大的库仑引力的作用，它们会脱离强作用力的束缚，所以这种情况是不被允许的。如果轮到某人操作时，所有位置都不能操作了，那么他就输了。

Youyou 快乐地答应了小 Z 的游戏请求，但是面对聪明的小 Z，Youyou 只好来求助你了。

特别地，**如果全部中子最后变成了同种粒子，那么后手获胜**。

如果你帮助 Youyou 打败了小 Z，那么 Youyou 就会送你一台 Wadm 作为奖励！

## 交互方式

你的程序应从标准输入中读入，向标准输出中输出。

输入中将包含两个整数 `n task_id` ，分别代表题目中的 $n$ 和子任务编号。

然后你需要输出一个整数 `order`，$\text{order}$ 只能是 $0$ 或 $1$。$0$ 代表你选择先手，$1$ 代表你选择后手。

接下来，你应该根据你选择的先后手情况通过标准输入输出与交互库进行交互。

- 若轮到你操作，那么你应该接着输出两个整数 `place type`，代表你将位置在 $\text{place}$ 的中子变为了电子（$\text{type}=-1$）或质子（$\text{type}=1$）。其中，你需要保证：
  - $\text{place} \in [1,n]$ 且该位置可以操作；
  - $\text{type} \in \{-1,1\}$；
  - **你已经清空缓冲区**。在 C 或 C++ 中，可使用 `fflush(stdout)` 函数。在 C++ 中，还可使用 `cout << flush`，`cout.flush()`，或使用 `endl` 而不是 `'\n'` 来输出一个换行。

- 若轮到小 Z 操作，那么你应该接着读入两个整数 `place type`，代表小 Z 将位置在 $\text{place}$ 的中子变为了电子（$\text{type}=-1$）或质子（$\text{type}=1$）。其中，保证：
  - $\text{place} \in [1,n]$ 且该位置可以操作；
  - $\text{type} \in \{-1,1\}$。

例如，如果你选择先手，那么你应该按照「输出，输入，输出，输入……」的顺序进行交互。如果你选择后手，那么你应该按照「输入，输出，输入，输出……」的顺序进行交互。

请注意，如果游戏结束，你应当立即终止程序。游戏结束后多余的输出可能会导致 RE 。
## 输入格式

见「交互方式」。
## 输出格式

见「交互方式」。
## 样例

### 样例输入 #1
```
4 1


2 1

```
### 样例输出 #1
```

0
1 1

4 -1
```
## 提示

* Subtask 1（5 分）：$n \leq 4$；
* Subtask 2（8 分）：$n \leq 8$；
* Subtask 3（12 分）：$n$ 为偶数，交互库特殊策略*；
* Subtask 4（15 分）：交互库特殊策略*；
* Subtask 5（20 分）：$n$ 为偶数；
* Subtask 6（40 分）：无特殊限制。

*交互库特殊策略：每次轮到交互库操作时，交互库会找到最左侧的能操作的位置，然后如果该位置能操作为质子，则操作为质子，否则操作为电子。

对于全部的数据，保证 $1 \leq n \leq 2^{10}$ 。


---

---
title: "[HNOI2016] 序列 加强版"
layout: "post"
diff: 省选/NOI-
pid: P6604
tag: ['2016']
---
# [HNOI2016] 序列 加强版
## 题目背景

本题是 [P3246](https://www.luogu.com.cn/problem/P3246) 的数据加强版，扩大了询问次数的范围，增加了强制在线，并加入了一组构造数据。

本题的输入输出格式与原题略有不同。
## 题目描述

给定长度为 $ n $ 的序列：$ a_1, a_2, \cdots , a_n $，记为 $ a[1 \colon n] $。类似地，$ a[l \colon r] $（$ 1 \leq l \leq r \leq N$）是指序列：$ a_{l}, a_{l+1}, \cdots ,a_{r-1}, a_r $。若 $1\leq l \leq s \leq t \leq r \leq n$，则称 $ a[s \colon t] $是 $ a[l \colon r] $ 的子序列。

现在有 $ q $ 个询问，每个询问给定两个数 $ l $ 和 $ r $，$ 1 \leq l \leq r \leq n $，求 $ a[l \colon r] $ 的不同子序列的最小值之和。例如，给定序列
 $ 5, 2, 4, 1, 3 $，询问给定的两个数为 $ 1 $ 和 $ 3 $，那么 $ a[1 \colon 3] $ 有 $ 6 $ 个子序列 $a[1 \colon 1], a[2 \colon 2], a[3 \colon 3], a[1 \colon 2],a[2 \colon 3], a[1 \colon 3] $，这 $6 $ 个子序列的最小值之和为 $5+2+4+2+2+2=17$。
## 输入格式

第一行三个整数 $n$，$q$，$type$ 表示序列长度，询问数与输入方式。

第二行 $n$ 个整数表示这个序列。

若 $type=0$，接下来 $q$ 行，每行两个数 $l$，$r$，代表询问区间 $[l,r]$。

若 $type=1$，则数据按照如下代码生成：
```cpp
namespace gen{
	typedef unsigned long long ull;
	ull s,a,b,c,lastans=0;
	ull rand(){
		return s^=(a+b*lastans)%c;
	}
};
```
其中，`s`，`a`，`b`，`c` 的初始值在第三行给出，满足 `s`，`a`，`b` 均在 $[0,10^9]$ 之间，`c` 在 $[1,10^9]$ 之间。`lastans` 表示上次询问的答案转化为 `unsigned long long` 类型后的值，第一次询问时值为 $0$。

每次询问时，你可以通过下面的方式生成 $l$ 和 $r$：
```cpp
l=gen::rand()%n+1;
r=gen::rand()%n+1;
if(l>r) std::swap(l,r);
```
## 输出格式

一行一个整数，表示每次询问的答案转成 `unsigned long long` 类型后的异或和。
## 样例

### 样例输入 #1
```
5 5 0
5 2 4 1 3
1 5
1 3
2 4
3 5
2 5

```
### 样例输出 #1
```
28

```
### 样例输入 #2
```
6 5 1
1 1 4 5 1 4
19 19 8 10

```
### 样例输出 #2
```
6

```
## 提示

- 对于 $30\%$ 的数据，$1\le q\le10^5$，$type=0$。
- 对于另外 $70\%$ 的数据，$1\le q\le10^7$，$type=1$。

对于 $100\%$ 的数据，$1\le n\le10^5$，$-10^9\le a_i\le10^9$。


---

---
title: "环 Rings"
layout: "post"
diff: 省选/NOI-
pid: P6616
tag: ['O2优化']
---
# 环 Rings
## 题目背景

> 一九二九不出手，三九四九冰上走，五九六九隔河看杨柳；
>
> 七九河开，八九雁来，九九加一九，耕牛遍地走。

「九」自古以来就是一个奇妙的数字，而你今天要解决的问题，也与「九」有关。
## 题目描述

你有一个 $n$ 连环，和你熟知的九连环有着相同的结构。

![这是一个九连环](https://cdn.luogu.com.cn/upload/image_hosting/x68krf0v.png)

> 上图是一个九连环。

顾名思义，$n$ 连环有一个长长的横梁，上面挂着 $n$ 个 **彼此影响** 的环。

我们给这 $n$ 个环编号，其中最靠横梁头部的环为第 $1$ 个环，其次为第 $2$ 个环，以此类推……最靠横梁尾部的环为第 $n$ 个环；

定义 $f_i$ 表示第 $i$ 个环的状态，其中 $f_i = 1$ 表示这个环在横梁上，$f_i = 0$ 表示这个环不在横梁上；

定义 **拆装一个环** 为使环的状态 **取反**，即状态从 $1$ 变成 $0$ 或从 $0$ 变成 $1$。

这些环的合法拆装规则如下：

1. 第 $1$ 个环随时可以单独拆装；
2. 第 $k+1$ 个环可以单独拆装，当且仅当 $f_k=1$ 且 $\forall i < k$，都有 $f_i = 0$；
3. 若 $f_1 = f_2$，则第 $1,2$ 两个环可以一起拆装。

现在你需要解决的问题是：已知一个 $n$ 连环的初始状态，请你求出拆除这个 $n$ 连环的最少拆装步数。
## 输入格式

本题数据量较大，故采取 **特殊** 输入方式。

第一行一个正整数 $n$。

第二行一个正整数 $m$；

接下来 $m$ 行输入描述了初始状态：

第 $i + 2$ 行有两个整数 $len_{i}, st_{i}$，表示往初始的 $n$ 连环的尾部连续添加 $len_{i}$ 个状态为 $st_{i}$ 的环。
## 输出格式

一行共一个整数，表示从拆下这个 $n$ 连环所需要的最少拆装次数。

由于答案可能很大，你只需要输出答案对 $1201201201$ 取模后的结果。
## 样例

### 样例输入 #1
```
4
3
1 1
1 0
2 1

```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
15
4
5 1
2 1
4 0
4 1

```
### 样例输出 #2
```
15424
```
### 样例输入 #3
```
3
3
1 1
1 0
1 1
```
### 样例输出 #3
```
5
```
## 提示

本题采用 **捆绑测试**，开启 **O2优化**。

$\text{Subtask 1 (10 pts)}:$ 保证 $1 \le n \le 20$；

$\text{Subtask 2 (15 pts)}:$ 保证 $1 \le n\le 1000$；

$\text{Subtask 3 (15 pts)}:$ 保证初始状态中 **只有** $1$ 个 $1$；

$\text{Subtask 4 (30 pts)}:$ 保证 $1 \le n \le 10^7$；

$\text{Subtask 5 (30 pts)}:$ 没有特殊限制。

对于所有数据，满足 $1 \le n \le 10^{18}$，$1 \le m \le 10^5$，$st_{i} \in \{0, 1\}$，$len_{i} \ge 1$

数据保证 $\sum\limits_{i=1}^m len_{i} = n$。

---

#### 样例 #1 解释

样例描述的是 $4$ 连环，初始状态为 `1101`。

用最少合法拆装次数完成的方法如下：

```plain
1. 1101 -> 1100
2. 1100 -> 0100
3. 0100 -> 0111
4. 0111 -> 0110
5. 0110 -> 0010
6. 0010 -> 0011
7. 0011 -> 0000
```

共 $7$ 步。

---

#### 题外话

本题中 $n$ 连环的第 $3$ 条拆装规则，在大部分的九连环玩法说明中都没有提到，但它确实是一个真实可行的操作呢！


---

---
title: "[BJOI2020] 封印"
layout: "post"
diff: 省选/NOI-
pid: P6640
tag: ['2020', '各省省选', '北京']
---
# [BJOI2020] 封印
## 题目背景

注：NOI 2020 北京队选拔赛因不可抗力因素取消，改为按前一年 CSP-S 第二轮成绩选出省队。因为出现同分，为决定最终 A 队名单，举办了加试。本题即为加试题。
## 题目描述

给出只包含小写字母 $a,b$ 的两个字符串 $s, t$，$q$ 次询问，每次询问 $s[l \dots r]$ 和 $t$ 的最长公共子串长度。
## 输入格式

输入共 $q+3$ 行。

第一行一个字符串 $s$。

第二行一个字符串 $t$。

第三行一个整数 $q$。

接下来的 $q$ 行，每行两个整数 $l_i, r_i(1\le l_i \le r_i \le |s|)$，表示一次询问。
## 输出格式

输出共 $q$ 行。

第 $i$ 行表示 $s[l_i \dots r_i]$ 和 $t$ 的最长公共子串长度。
## 样例

### 样例输入 #1
```
aaba
aaaabbbaa
3
1 4
1 3
2 4
```
### 样例输出 #1
```
3
3
2
```
## 提示

| 测试点编号 | $\vert s\vert , \vert t\vert \le $ |     $q\le$     |
| :--------: | :------------: | :------------: |
|    $1$     |      $50$      |      $50$      |
|   $2,3$    | $2\times 10^3$ | $2\times 10^3$ |
|   $4,5$    | $2\times 10^5$ |      $10$      |
| $6\sim 10$ | $2\times 10^5$ | $2\times 10^5$ |


---

---
title: "[BalticOI 2020] 染色 (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P6682
tag: ['2020', '交互题', 'Special Judge', 'BalticOI（波罗的海）']
---
# [BalticOI 2020] 染色 (Day1)
## 题目描述

Linda 喜欢时不时改变她头发的颜色，如果她的男友 Archie 注意到她头发颜色发生了改变，Linda 会十分高兴。当且仅当 Archie 发现 Linda 的头发颜色发生改变时，Archie 才会去评论 Linda 头发的新颜色。这意味着 Linda 始终可以知道 Archie 是否发现她的头发颜色有改变。

现在市场上有一个新染发剂系列，该染发剂系列有 $N$ 种颜色，从 $1$ 到 $N$ 编号。两个颜色的相近程度与它们编号的差值有关——差值越小，则越相近。

Linda 发现，对于该系列的染发剂，存在一个色差阈值 $C$（$1 \leq C \leq N$）。具体来说，假如 Linda 之前使用的染发剂颜色编号为 $color_{prew}$，Linda 接下来打算使用的染发剂颜色编号为 $color_{new}$，则 Archie 会注意到 Linda 的颜色头发差异，当且仅当 $\left | color_{new}-color_{prew}\right | \geq C$。

现在 Linda 买下了一套该系列的染发剂，准备做一个实验。她会不断地更换头发的颜色，并观察 Archie 是否注意到了头发颜色发生改变。因为染发剂有限，每种颜色的染发剂最多只能使用一次。

在实验开始之前，Linda 使用的是另外一个系列的染发剂，因此讨论第一次染发后 Archie 的反应是没有意义的。

现在 Linda 想要通过有限的时间找到阈值 $C$，请写一个程序帮助她完成这个任务。

### 交互方式

本题是一道交互题。

**与原题不同的是，为了压缩数据组数，本题单个测试点中将包含多组数据。**

输入第一行包含一个整数 $T$，表示该测试点的数据组数。

对于每组数据，你首先将读入一个整数 $N$，代表该系列染发剂的颜色数量。

接下来，你可以按如下形式输出来进行询问：`? P`。其中 $P$ 代表 Linda 下一次要使用的染发剂的颜色编号。你输出的 $P$ 需要满足 $1 \leq P \leq N$，且任意两次询问的 $P$ 均不相同。

在询问过后，你的程序将读入一个整数，若这个整数为 $1$，代表 Archie 注意到了 Linda 头发颜色的变化；若为 $0$，则表示他没有注意到颜色的变化。

当你确认了阙值 $C$ 后，按如下格式输出答案：`= C`。

如果答案正确，将会直接进入下一组数据的交互。

如果答案错误，交互器将直接终止你的程序。

对于每组测试数据，你的程序可以最多进行 $64$ 次询问（最后输出答案不算作询问）。

请注意，一般情况下程序的输出会存放在缓冲区中，为了确保你的输出能被交互库接收，请在输出一行之后刷新缓冲区。

- 对于 C++ 语言，可以使用 `std::cout<<std::endl` 来在输出换行的同时刷新缓冲区；
- 对于 Java 语言，可以使用 `System.out.flush();` 来刷新缓冲区；
- 对于 Python 语言，可以使用 `sys.stdout.flush()` 来刷新缓冲区。
## 样例

### 样例输入 #1
```
1
7

1

1

0

0

1

```
### 样例输出 #1
```


? 2

? 7

? 4

? 1

? 5

= 4
```
## 提示

### 样例解释

为了方便各位理解交互过程，部分行之间人为添加了空行。

下面依次解释每次询问过程：

1. 这一次询问的结果无意义。
2. 此次询问后有 $C \leq 5$；
3. 此次询问后有 $3 \lt C \leq 5$，这时候可以考虑检测差值为 $4$ 时的情况。但因为 $4+4=8$ 和 $4-4=0$ 都不合法，因此不再考虑这么做。
4. 此次询问后有 $3 \lt C \leq 5$。
5. 此次询问后有 $3 \lt C \leq 4$，即 $C=4$。

### 子任务

所有数据均满足：$1 \leq T \leq 1200$，$1 < N \leq 10^{18}$。

- 子任务 1（9 分）：$N \leq 64$；
- 子任务 2（13 分）：$N \leq 125$；
- 子任务 3（21 分）：$N \leq 10^3$；
- 子任务 4（24 分）：$N \leq 10^9$；
- 子任务 5（33 分）：无特殊限制。


---

---
title: "[BalticOI 2020] 混合调料 (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P6683
tag: ['2020', 'BalticOI（波罗的海）']
---
# [BalticOI 2020] 混合调料 (Day1)
## 题目描述

著名餐厅 *Salt, Pepper & Garlic* 的主厨 Serge 准备好成为一名米其林一星厨师。他已被告知，今晚一位秘密评审员将光临他的餐厅。

虽然他并没有得知这位评审员的姓名，但他已经得知了这位评审员将要点的菜和他的口味偏好。具体来说，这位评审员希望在菜肴中加入非常精确比例的盐，胡椒粉和大蒜粉。

Serge 在厨房的一个架子上放了若干盐，胡椒粉和大蒜粉的混合调料瓶。对于每种调料瓶，Serge 都知道该调料瓶中混合的盐，胡椒粉和大蒜粉的量（单位为千克），他可以通过将任意多瓶调料混合起来（当然也可以单独使用一瓶调料），得到所需比例的调料。

事实上菜肴里放的调料量并不多，因此可以认为调料的量是足够的。但是，评审员要求的盐，胡椒粉和大蒜粉的量之比中的数字可能非常大。

现在 Serge 想要求出，是否能够利用已有的调料瓶配制出满足评审员要求比例的调料？如果能够配制，最少需用多少个瓶子？

此外，Serge 可能会拿到新的调料瓶，或者将架子上已有的调料瓶给其他厨师，这意味着架子上的瓶子种类会不断发生改变，Serge 希望在每次架子上的调料瓶发生变化后，再解决上面的问题。

举个例子，假如评审员要求的盐，胡椒粉和大蒜粉的量的比例为 $1:1:1$，架子上有以下几种调料瓶：

| 调料瓶编号 |  盐  | 胡椒粉 | 大蒜粉 |
| :--------: | :--: | :----: | :----: |
|     1      |  10  |   20   |   30   |
|     2      | 300  |  200   |  100   |
|     3      |  12  |   15   |   27   |

则只需将瓶子 $1$ 中的全部调料，和瓶子 $2$ 中的 $60$ 千克调料（其中包括盐 $30$ 千克，胡椒粉 $20$ 千克，大蒜粉 $10$ 千克）混合即可满足要求。一旦取走瓶子 $2$，则无法满足评审员的要求。
## 输入格式

输入第一行包含三个整数 $S_f,P_f,G_f$，表示评审员要求的盐，胡椒粉，大蒜粉的量之比为 $S_f:P_f:G_f$，$\forall \alpha \gt 0$，$(\alpha S_f,\alpha P_f, \alpha G_f)$ 的混合调料也满足评审员要求。

下一行一个整数 $N$，表示架子上的瓶子要进行 $N$ 次变动。最开始架子上没有瓶子。

接下来 $N$ 行，每行描述一次变动。

- 若架子上新增了瓶子，则该行包含一个大写字母 `A` 和三个整数 $S_i,P_i,G_i$，分别代表该瓶中盐，胡椒粉，大蒜粉的量。瓶子按加入的先后顺序从 $1$ 开始编号，即如果该瓶子是第 $i$ 个加入架子的，则其编号为 $i$。
- 若架子上移除了瓶子，则该行包含一个大写字母 `R` 和一个整数 $r_i$，代表移除的瓶子编号。保证该编号的瓶子在架子上。
## 输出格式

输出 $N$ 行。第 $i$ 行输出在第 $i$ 次变动后，满足评审员要求所需的最少瓶子数量。特别地，若不存在一种方案满足评审员的要求，输出 $0$。
## 样例

### 样例输入 #1
```
1 2 3
6
A 5 6 7
A 3 10 17
R 1
A 15 18 21
A 5 10 15
R 3

```
### 样例输出 #1
```
0
2
0
2
1
1

```
## 提示

所有数据均满足：$1 \leq N \leq 10^5$，$S_f,P_f,G_f \geq 0$，$0 \lt S_f+P_f+G_f \leq 10^6$，$S_i,P_i,G_i \geq 0$，$0 \lt S_i+P_i+G_i \leq 10^6$。

- 子任务 1（13 分）：$N \leq 50$，$0 \lt S_i+P_i+G_i \leq 10^2$；
- 子任务 2（17 分）：$N \leq 500$，$0 \lt S_i+P_i+G_i \leq 10^3$；
- 子任务 3（30 分）：$N \leq 5000$，$0 \lt S_i+P_i+G_i \leq 10^4$；
- 子任务 4（40 分）：无特殊限制。


---

---
title: "[BalticOI 2020] 小丑 (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P6684
tag: ['2020', 'BalticOI（波罗的海）']
---
# [BalticOI 2020] 小丑 (Day1)
## 题目背景

由于官方测试数据量过大，为了避免过多资源占用，这里选取了部分官方数据作为本题测试数据。
## 题目描述

小丑回到了哥谭市，准备执行一个邪恶的计划。哥谭市有 $N$ 个路口（编号从 $1$ 到 $N$），$M$ 条道路（编号从 $1$ 到 $M$）。一条道路连接两个不同的路口，且两个路口间最多只有一条道路相连。

为了实现他的邪恶计划，小丑需要在城市中走完一个奇环。形式化地说，一个奇环为一个形如 $S,s_1,s_2,\ldots,s_k,S$ 的序列（要求 $k$ 为偶数），其中 $S$ 和 $s_1$，$s_k$ 和 $S$，以及 $\forall 1 \lt i \leq k$，$s_{i-1}$ 和 $s_i$ 之间都有道路直接相连。

然而，警察控制了城市中的部分街道。在第 $i$ 天，警察控制了编号在 $[l_i,r_i]$ 范围内的所有街道，小丑不能经过这些街道。然而小丑通过买通警察局的内鬼，了解到了警察在未来 $Q$ 天控制街道的计划，现在小丑想要知道，在哪些日子里，他的邪恶计划可以实现。
## 输入格式

输入第一行三个整数 $N,M,Q$。

接下来 $M$ 行，第 $i$ 行两个整数 $u,v$（保证 $u \neq v$），描述了编号为 $i$ 的街道。其连接了 $u$ 和 $v$ 两个路口。保证两个路口间最多只有一条街道相连。

接下来 $Q$ 行，第 $i$ 行两个整数 $l_i,r_i$，表示警察在第 $i$ 天将要控制编号在 $[l_i,r_i]$ 范围内的所有街道。
## 输出格式

输出 $Q$ 行。

在第 $i$ 行，若第 $i$ 天小丑的计划可以实现，输出 `YES`，否则输出 `NO`。
## 样例

### 样例输入 #1
```
6 8 2
1 3
1 5
1 6
2 5
2 6
3 4
3 5
5 6
4 8
4 7

```
### 样例输出 #1
```
NO
YES

```
## 提示

### 样例解释

![](https://cdn.luogu.com.cn/upload/image_hosting/qr5q8ha4.png)

### 子任务

所有数据均满足：$1 \leq N,M,Q \leq 2 \times 10^5$。

- 子任务 1（6 分）：$1 \leq N,M,Q \leq 200$；
- 子任务 2（8 分）：$1 \leq N,M,Q \leq 2 \times 10^3$；
- 子任务 3（25 分）：$\forall i \in [1,Q]$，$l_i =1$；
- 子任务 4（10 分）：$\forall i \in [1,Q]$，$l_i \leq 200$；
- 子任务 5（22 分）：$Q \leq 2 \times 10^3$；
- 子任务 6（29 分）：无特殊限制。


---

---
title: "序列"
layout: "post"
diff: 省选/NOI-
pid: P6689
tag: ['2020', '洛谷原创', '洛谷月赛']
---
# 序列
## 题目描述

小 C 想出关于括号序列的一道题，但是他不怎么会造数据，所以他采取了随机的方式。

小 C 钦定了括号序列 $S$ 的长度 $N$。$S$ 初始时全为 `(`。

他初始设定了一个参数 $K$，并按照如下流程随机，直到 $K=0$：

1. 在 $[1,N]$ 的范围内**均匀随机**一个整数，把 $S$ 这一位上的括号取反（左括号变右括号，右括号变左括号）。
2. 如果本次操作使得 `(` 的数量减少了，使 $K$ 的值减 $1$。

现在数据造好了，题也就出完了。

小 C 想请你求出，在经过上述操作后，$S$ 中**最长合法括号子序列**（不要求连续）在模 $998244353$ 意义下期望有多长。

## 输入格式

输入第一行，为两个正整数 $N,K$，含义题面已给出。
## 输出格式

输出共一行，一个非负整数，表示你所求得的答案对 $998244353$ 取模的结果。
## 样例

### 样例输入 #1
```
2 2
```
### 样例输出 #1
```
499122177
```
### 样例输入 #2
```
4 2 
```
### 样例输出 #2
```
873463811
```
### 样例输入 #3
```
1919 810
```
### 样例输出 #3
```
488346634
```
## 提示

**样例解释1**

最终括号序列只有 $3$ 种，`))`，`()`，`)(`。其对应的概率分别为 $\frac{1}{2}$，$\frac{1}{4}$，$\frac{1}{4}$。

它们对应的最长合法括号子序列长度分别为 $0,2,0$。所以最终答案为 $\frac{1}{2}$，也即 $499122177$。

**数据规模：**

对于前 $5\%$ 的数据，$N=1$；  
另有 $5\%$ 的数据，$N=2$；  
另有 $5\%$ 的数据，$N\le 7$，$K\le 5$；  
另有 $15\%$ 的数据，$N\le 15$，$K\le 500$；  
另有 $ 15\%$ 的数据，$N\le 50$，$K\le 50$；  
另有 $ 15\%$ 的数据，$N\le 500$，$K\le 100$；  
对于全部的数据，保证 $1\le N,K\le 5000$。


---

---
title: "[COCI 2015/2016 #5] OOP"
layout: "post"
diff: 省选/NOI-
pid: P6727
tag: ['2015', 'O2优化', 'COCI（克罗地亚）']
---
# [COCI 2015/2016 #5] OOP
## 题目描述

给定 $N$ 个单词和 $Q$ 个模板，一个模板由一个 `*` 和一些小写字母组成。一个模板覆盖了一个单词当且仅当将 `*` 替换为任意字母后，模板和单词能够完全重合。对于每个模板，求出它能够覆盖多少个单词。
## 输入格式

输入第一行两个整数 $N,Q$。

接下来的 $N$ 行，每行一个小写字母组成的单词。

接下来的 $Q$ 行，每行一个模板。

以上读入的字符总数少于 $3\times 10^6$。
## 输出格式

输出共 $Q$ 行。表示每个模板能够覆盖的单词的个数。
## 样例

### 样例输入 #1
```
3 3
aaa
abc
aba
a*a
aaa*
*aaa
```
### 样例输出 #1
```
2
1
1
```
### 样例输入 #2
```
5 3
eedecc
ebdecb
eaba
ebcddc
eb
e*
*dca
e*c
```
### 样例输出 #2
```
5
0
2
```
## 提示

#### 数据规模与约定
对于 $40\%$ 的数据，$1\le N,Q\le 10^3$；  
对于 $100\%$ 的数据，$1\le N,Q\le 10^5$。

#### 说明

**题目译自 [COCI2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #5](https://hsin.hr/coci/archive/2015_2016/contest5_tasks.pdf) *T5 OOP***。


---

---
title: "[BalticOI 2014] Sequence (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P6740
tag: ['2014', 'O2优化', 'BalticOI（波罗的海）']
---
# [BalticOI 2014] Sequence (Day1)
## 题目描述

现在有 $K$ 个连续正整数，每个整数你只能看见其中一位数字，求最开始的数 $N$ 的最小值。
## 输入格式

第一行一个整数 $K$ 代表数列长度。      
第二行 $K$ 的整数代表你能看见的数字。
## 输出格式

一行一个整数代表 $N$ 的最小值。
## 样例

### 样例输入 #1
```
6
7 8 9 5 1 2
```
### 样例输出 #1
```
47
```
## 提示

#### 样例说明

对于样例 $1$，使得 $N$ 最小的数列为 $47,48,49,50,51,52$，$N$ 的最小值为 $47$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（9 pts）：$N,K \le 1000$。
- Subtask 2（33 pts）：$K \le 1000$。
- Subtask 3（25 pts）：给定的数位都相等。
- Subtask 4（33 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le K \le 10^5$。

**本题强制 O2 优化。**

#### 说明

翻译自 [BalticOI 2014 Day1 C Sequence](http://www.boi2014.lmio.lt/tasks/sequence-en.pdf)。


---

---
title: "[IOI 2019] 视觉程序"
layout: "post"
diff: 省选/NOI-
pid: P6751
tag: ['2019', 'IOI', '交互题', 'Special Judge']
---
# [IOI 2019] 视觉程序
## 题目背景

[评测方式](https://www.luogu.com.cn/paste/5z13bn4l)

[一些说明~~和扯淡~~](https://www.luogu.com.cn/paste/l6kcccs4)
## 题目描述

你在给机器人编写一个视觉程序。每次机器人的摄像头拍下一张照片时，图像将以黑白图像的形式存储在机器人的内存中。每张图像是由像素构成的 $H\times W$ 网格。图像的行从 $0$ 到 $H-1$ 编号，列从 $0$ 到 $W-1$ 编号。每张图像含有**恰好两个**黑色像素，其他像素均为白色。

机器人可以用简单指令构成的程序来处理图像。给出 $H$，$W$ 和一个正整数 $K$ 的值，你的目标是要编写一个函数，用来为机器人生成程序。该程序需要判定图像中两个黑色像素的距离是否正好为 $K$。这里，在第 $r_1$ 行及第 $c_1$ 列上的像素与第 $r_2$ 行及第 $c_2$ 列上的像素之间的距离定义为 $|r_1-r_2|+|c_1-c_2|$。 在这个式子中，$|x|$ 表示 $x$ 的绝对值，即当 $x\ge0$ 时，其值为 $x$，而当 $x<0$ 时，其值为 $-x$。

下面描述机器人是如何运作的。

机器人的内存有足够多的存储单元，从 $0$ 开始编号。每个存储单元可以保存 $0$ 或 $1$，且它的内容一旦设置后就不可更改。图像一行接一行地保存在存储单元里，这些存储单元的编号从 $0$ 到 $H\cdot W-1$。第一行保存在存储单元 $0$ 到 $W-1$ 里，最后一行保存在存储单元 $(H-1)W$ 到 $H\cdot W-1$ 里。特别地，如果位于第 $i$ 行第 $j$ 列上的那个像素是黑色的，则保存在存储单元 $i\cdot W+j$ 里的值为 $1$，否则为 $0$。

机器人的程序是一个**指令**的序列，这些指令用从 $0$ 开始的连续整数进行编号。在程序运行时，指令将一条一条地被执行。每条指令读取一个或多个存储单元的值（我们将这些值称为指令的**输入**），同时产生一个 $0$ 或 $1$ 的值（我们称之为指令的**输出**）。指令 $i$ 的输出将会保存在存储单元 $H\cdot W+i$ 中。指令 $i$ 的输入只能是保存图像的存储单元，或者是保存之前指令输出的存储单元，也就是编号为从 $0$ 到 $H\cdot W+i-1$ 的存储单元。

机器人共有四种指令：
- `NOT`：有唯一一个输入。若输入为 $0$ 时，其输出为 $1$，否则为 $0$。
- `AND`：有一个或多个输入。其输出为 $1$ 当且仅当输入**全部**为 $1$。
- `OR`：有一个或多个输入。其输出为 $1$ 当且仅当输入中**至少有一个** $1$。
- `XOR`：有一个或多个输入。其输出为 $1$ 当且仅当输入中 $1$ 的个数是**奇数**。

如果两个黑色像素之间的距离正好为 $K$，则最后一条指令的输出应为 $1$，否则输出应为 $0$。
#### 实现细节
你需要实现以下函数：
```plain
void construct_network(int H, int W, int K)
```
- $H$，$W$：机器人摄像头所拍到的图像的尺寸
- $K$：一个正整数
- 这个函数需要生成一个机器人的程序。对于机器人摄像头所拍到的每幅图像，该程序应判定图像中两个黑色像素之间的距离是否正好为 $K$。

该程序应当通过调用以下函数将指令追加到机器人的程序中（最初机器人的程序是空的）：
```plain
int add_not(int N)
int add_and(int[] Ns)
int add_or(int[] Ns)
int add_xor(int[] Ns)
```
- 分别追加一条 `NOT`，`AND`，`OR` 或 `XOR` 指令。
- $N$（对于 `add_not` 而言）：要追加的 `NOT` 指令的输入存储单元编号
- $Ns$（对于 `add_and`，`add_or`，`add_xor` 而言）：要追加的 `AND`，`OR` 或 `XOR` 指令的输入存储单元的编号的数组
- 每次函数调用都会返回追加指令的输出存储单位的编号。对这些函数的连续调用将会返回从 $H\cdot W$ 开始的连续整数。

机器人的程序最多可以包含 $10^4$ 条指令。这些指令一共最多只能读入 $10^6$ 个值。换句话说，所有 `add_and`，`add_or` 及 `add_xor` 调用中的 $Ns$ 数组的长度总和再加上 `add_not` 调用的次数不得超过 $10^6$。


当追加完最后一条指令后，函数 `construct_network` 必须返回。所产生的机器人程序会在一些图像上进行评测。对于一幅图像，程序最后一条指令的输出是 $1$ 当且仅当两个黑色像素之间的距离正好为 $K$。如果对测试点中的每幅图像，你的解答所产生的程序都可以正确地输出结果，那就通过了该测试点。

评测程序在评测你的程序时可能会出现以下错误信息：
- `Instruction with no inputs`：一个空数组被作为 `add_and`，`add_or` 或 `add_xor` 的输入。
- `Invalid index`：给 `add_not`，`add_or` 或 `add_xor` 提供了不正确（可能是负数）的存储单元编号作为输入。
- `Too many instructions`：你的函数尝试添加多于 $10^4$ 条的指令。
- `Too many inputs`：程序中的指令一共读取了多于 $10^6$ 个值。
#### 评测程序示例
评测程序示例读取下述格式的输入：
- 第 $1$ 行：$H$，$W$，$K$
- 第 $2+i$ 行（$i\ge0$）：$r1_i$，$c1_i$，$r2_i$，$c2_i$
- 最后一行：$-1$

除第一行和最后一行外，每一行都表示了一幅含有两个黑色像素的图像。记第 $2+i$ 行上的图像为图像 $i$。该图像中，一个黑色像素位于第 $r_1[i]$ 行及第 $c_1[i]$ 列上，令一个黑色像素位于第 $r_2[i]$ 行及第 $c_2[i]$ 列上。

评测程序首先调用 `construct_network(H, W, K)`。若 `construct_network` 违反了题目描述中的限制条件，评测程序示例将会输出在实现细节一节末尾所列举的某条错误信息并退出。

否则，评测程序示例将输出两部分内容。

首先，评测程序示例会以下列格式输出机器人程序所产生的输出：
- 第 $1+i$ 行（$0\le i$）：对于图像 $i$，机器人程序最后一条指令的输出（$1$ 或 $0$）。

其次，评测程序示例会以下列格式输出到当前目录下一个名为 `log.txt` 的文件中：
- 第 $1+i$ 行（$0\le i$）：$m_{i,0}$，$m_{i,1}$，$\dots$，$m_{i,c-1}$

在第 $1+i$ 行上的序列描述以图像 $i$ 作为输入时，在机器人程序运行结束后放在内存中的数据。具体来说，$m_{i,j}$ 是保存在存储单元 $j$ 里面的值。注意，$c$ 的值（序列长度）等于 $H\cdot W$ 再加上机器人程序的指令数。
## 提示

#### 样例
假设 $H=2$，$W=3$，$K=3$。在此情况下，两个黑色像素之间的距离为 $3$ 的图像只有两种。

![](https://cdn.luogu.com.cn/upload/image_hosting/9fec7n4k.png)

- 情况一：黑色像素是 $0$ 和 $5$。
- 情况二：黑色像素是 $2$ 和 $3$。

一种可行的方案是通过以下调用来构造机器人程序：
1. `add_and([0, 5])`，将加入一条指令，当且仅当图像符合情况一时其输出为 $1$。输出结果将保存在存储单元 $6$ 里。
1. `add_and([2, 3])`，将加入一条指令，当且仅当图像符合情况二时其输出为 $1$。输出结果将保存在存储单元 $7$ 里。
1. `add_or([6, 7])`，将加入一条指令，当且仅当上述两种情况之一成立时其输出为 $1$。
#### 数据范围
对于所有数据：
- $1\le H,W\le200$；
- $2\le H\cdot W$；
- $1\le K\le H+W-2$。

详细子任务附加限制与分值如下表：
| 子任务编号 |                           附加限制                           | 分值 |
| :--------: | :----------------------------------------------------------: | :--: |
|    $1$     |                     $\max(H,W) \le 3$                        | $10$ |
|    $2$     |                     $\max(H,W) \le 10$                       | $11$ |
|    $3$     |                     $\max(H,W) \le 30$                       | $11$ |
|    $4$     |                     $\max(H,W) \le 100$                      | $15$ |
|    $5$     |                       $\min(H,W) = 1$                        | $12$ |
|    $6$     |     每幅图像上位于第 $0$ 行且位于第 $0$ 列的那个像素是黑色的         | $8$ |
|    $7$     |                           $K = 1$                            | $14$ |
|    $8$     |                      没有任何附加限制                           | $19$ |


---

---
title: "[NOI2020] 美食家"
layout: "post"
diff: 省选/NOI-
pid: P6772
tag: ['2020', 'NOI', 'O2优化']
---
# [NOI2020] 美食家
## 题目描述

坐落在 Bzeroth 大陆上的精灵王国击退地灾军团的入侵后，经过十余年的休养生息，重新成为了一片欣欣向荣的乐土，吸引着八方游客。小 W 是一位游历过世界各地的著名美食家，现在也慕名来到了精灵王国。

精灵王国共有 $n$ 座城市，城市从 $1$ 到 $n$ 编号，其中城市 $i$ 的美食能为小 W 提供 $c_i$ 的愉悦值。精灵王国的城市通过 $m$ 条**单向道路**连接，道路从 $1$ 到 $m$ 编号，其中道路 $i$ 的起点为城市 $u_i$ ，终点为城市 $v_i$，沿它通行需要花费 $w_i$ 天。也就是说，若小 W 在第 $d$ 天从城市 $u_i$ 沿道路 $i$ 通行，那么他会在第 $d + w_i$ 天到达城市 $v_i$。

小 W 计划在精灵王国进行一场为期 $T$ 天的旅行，更具体地：他会在第 $0$ 天从城市 $1$ 出发，经过 $T$ 天的旅行，最终在**恰好第 $T$ 天**回到城市 $1$ 结束旅行。由于小 W 是一位美食家，每当他到达一座城市时（包括第 $0$ 天和第 $T$ 天的城市 $1$），他都会品尝该城市的美食并获得其所提供的愉悦值，若小 W 多次到达同一座城市，他将**获得多次愉悦值**。注意旅行途中小 W **不能在任何城市停留**，即当他到达一座城市且还未结束旅行时，他当天必须立即从该城市出发前往其他城市。

![](https://cdn.luogu.com.cn/upload/image_hosting/2svum9ge.png)

对于上图，小 W 一种为期 $11$ 天的可行旅游方案为 $1 \to 2 \to 1 \to 2 \to 3 \to 1$：
- 第 $0$ 天，小 W 从城市 $1$ 开始旅行，获得愉悦值 $1$ 并向城市 $2$ 出发。
- 第 $1$ 天，小 W 到达城市 $2$，获得愉悦值 $3$ 并向城市 $1$ 出发。
- 第 $4$ 天，小 W 到达城市 $1$，获得愉悦值 $1$ 并向城市 $2$ 出发。
- 第 $5$ 天，小 W 到达城市 $2$，获得愉悦值 $3$ 并向城市 $3$ 出发。
- 第 $7$ 天，小 W 到达城市 $3$，获得愉悦值 $4$ 并向城市 $1$ 出发。
- 第 $11$ 天，小 W 到达城市 $1$，获得愉悦值 $1$ 并结束旅行。
- 小 W 在该旅行中获得的愉悦值之和为 $13$。

此外，精灵王国会在**不同**的时间举办 $k$ 次美食节。具体来说，第 $i$ 次美食节将于第 $t_i$ 天在城市 $x_i$ 举办，若小 W 第 $t_i$ 天时恰好在城市 $x_i$，那么他在品尝城市 $x_i$ 的美食时会**额外得到** $y_i$ 的愉悦值。现在小 W 想请作为精灵王国接待使者的你帮他算出，他在旅行中能获得的愉悦值之和的**最大值**。
## 输入格式

从标准输入中读入数据。

第一行四个整数 $n, m, T, k$，依次表示城市数、道路条数、旅行天数与美食节次数。

第二行 $n$ 个整数 $c_i$，表示每座城市的美食所能提供的愉悦值。接下来 $m$ 行每行三个整数 $u_i, v_i, w_i$，依次表示每条道路的起点、终点与通行天数。

最后 $k$ 行每行三个整数 $t_i, x_i, y_i$，依次表示每次美食节的举办时间、举办城市与提供的额外愉悦值。

本题中数据保证：
- 对所有 $1 \leq i \leq m$，有 $u_i\neq v_i$。但数据中可能存在路线重复的单向道路，即可能存在 $1 \leq i < j \leq m，使得 u_i = u_j, v_i = v_j$。
- 对每座城市都满足：至少存在一条以该该城市为起点的单向道路。
- 每次美食节的举办时间 $t_i$ 互不相同。
## 输出格式

输出到标准输出中。

仅一行一个整数，表示小 W 通过旅行能获得的愉悦值之和的最大值。

**若小 W 无法在第 $T$ 天回到城市 $1$，则输出 $-1$**。
## 样例

### 样例输入 #1
```
3 4 11 0
1 3 4
1 2 1
2 1 3
2 3 2
3 1 4
```
### 样例输出 #1
```
13
```
### 样例输入 #2
```
4 8 16 3
3 1 2 4
1 2 1
1 3 1
1 3 2
3 4 3
2 3 2
3 2 1
4 2 1
4 1 5
3 3 5
1 2 5
5 4 20
```
### 样例输出 #2
```
39
```
## 提示

#### 样例 1 解释

该样例为题目描述中的例子，最优旅行方案见题目描述。

#### 样例 2 解释

最优方案为 $1 \to 3 \to 4 \to 2 \to 3 \to 4 \to 1$。
- 第 $0$ 天，小 W 从城市 $1$ 开始旅行，获得愉悦值 $3$ 并沿道路 $3$ 通行。
- 第 $2$ 天，小 W 到达城市 $3$，获得愉悦值 $2$ 并沿道路 $4$ 通行。
- 第 $5$ 天，小 W 到达城市 $4$，由于美食节获得愉悦值 $20 + 4$ 并沿道路 $7$ 通行。
- 第 $6$ 天，小 W 到达城市 $2$，获得愉悦值 $1$ 并沿道路 $5$ 通行。
- 第 $8$ 天，小 W 到达城市 $3$，获得愉悦值 $2$ 并沿道路 $4$ 通行。
- 第 $11$ 天，小 W 到达城市 $4$，获得愉悦值 $4$ 并沿道路 $8$ 通行。
- 第 $16$ 天，小 W 到达城市 $1$，获得愉悦值 $3$ 并结束旅行。
- 小 W 获得的愉悦值之和为 $39$。

#### 样例 3

见选手目录下的 delicacy/delicacy3.in 与 delicacy/delicacy3.ans。

该样例满足 $k=0$

---

### 测试点约束

对于所有测试点：

$1 \leq n \leq 50$，$n \leq m \leq 501$，$0 \leq k \leq 200$，$1 \leq t_i \leq T \leq 10^9$。

$1 \leq w_i \leq 5$，$1 \leq c_i \leq 52501$，$1 \leq u_i, v_i, x_i \leq n$，$1 \leq y_i \leq 10^9$。

每个测试点的具体限制见下表：

| 测试点编号 |  $n$ |  $m$ |  $T$ | 特殊限制 |
| :-: | :-:| :-: |:-:| :-:|
|  $1\sim 4$ |  $\le 5$ |  $\le 50$ |  $\le 5$ | 无 |
|  $5\sim 8$ |  $\le 50$ |  $\le 50$ |  $\le 52501$ | 无 |
|  $9\sim 10$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ | A | 
|  $11\sim 13$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ |  $k=0$ |
|  $14\sim 15$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ |  $k\le 10$ |
|  $16\sim 17$ |  $\le 50$ |  $\le 50$ |  $\le 10^9$ | 无 |
|  $18\sim 20$ |  $\le 50$ |  $\le 501$ |  $\le 10^9$ | 无 |

特殊限制 A：$n = m$ 且 $u_i = i,v_i = (i \bmod n) + 1$。


---

---
title: "【模板】Chirp Z-Transform"
layout: "post"
diff: 省选/NOI-
pid: P6800
tag: ['O2优化']
---
# 【模板】Chirp Z-Transform
## 题目描述

给定一个 $n$ 项多项式 $P(x)$ 以及 $c, m$，请计算 $P(c^0),P(c^1),\dots,P(c^{m-1})$。所有答案都对 $998244353$ 取模。
## 输入格式

第一行三个正整数 $n,c,m$。  
第二行 $n$ 个非负整数 $a_0,a_1,\dots,a_{n-1}$，由低到高表示 $P(x)$ 的系数。

## 输出格式

一行 $m$ 个正整数，第 $i$ 个数表示 $P(c^{i-1})$。
## 样例

### 样例输入 #1
```
3 3 3
3 3 3
```
### 样例输出 #1
```
9 39 273
```
## 提示

对于 $100\%$ 的数据，$1\le n,m\le 10^6,0\le c,a_i<998244353$.


---

---
title: "[CEOI 2020] 道路"
layout: "post"
diff: 省选/NOI-
pid: P6802
tag: ['2020', 'Special Judge', 'O2优化', 'CEOI（中欧）']
---
# [CEOI 2020] 道路
## 题目背景

0.3s，32MB
## 题目描述

Treeland 政府准备建立一个全新的道路网。Treeland 共有 $2N$ 个城市，目前已经修建了 $N$ 条道路，每条道路都是一条连接两个城市的线段。这 $N$ 条道路两两没有交点（包括端点处）。你现在需要再修建 $N-1$ 条道路，要求：

1. 每条道路都是一条连接两个城市的线段。
2. 道路只能在端点处相交。
3. 对于任意两个城市，均能通过该路网相互抵达。
## 输入格式

输入第一行包含一个整数 $N$。

接下来 $N$ 行，每行包含四个整数 $x_1,y_1,x_2,y_2$，表示 $(x_1,y_1)$ 和 $(x_2,y_2)$ 两座城市间存在一条道路直接相连。
## 输出格式

输出 $N-1$ 行。

每行包含四个整数 $x_1,y_1,x_2,y_2$，代表新修一条连接 $(x_1,y_1)$ 和 $(x_2,y_2)$ 两座城市间的道路。

如果存在多种方案，任意输出一种即可。
## 样例

### 样例输入 #1
```
5
1 3 3 6
5 1 5 3
3 3 6 5
2 1 4 1
2 3 4 2
```
### 样例输出 #1
```
2 1 1 3
2 3 2 1
3 3 2 3
5 1 4 2
```
## 提示

### 样例解释

下图中，实线表示已经修建的道路，虚线代表新修道路。

![](https://cdn.luogu.com.cn/upload/image_hosting/qxnetdvo.png)

### 子任务

所有数据均满足：$2 \leq N \leq 10^5$，$-10^7 \leq x_1,y_1,x_2,y_2 \leq 10^7$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                                 |
| ---------- | ---- | ------------------------------------ |
| $1$        | $0$  | 样例                                 |
| $2$        | $15$ | 输入的所有线段均为竖直线段           |
| $3$        | $15$ | 任意两条输入线段互相平行             |
| $4$        | $15$ | 输入的所有线段均为水平线段或竖直线段 |
| $5$        | $15$ | $N \leq 10^4$                        |
| $6$        | $40$ | 无特殊约束                           |

注意实际评测分值分配与上述约定不同。


---

---
title: "[CEOI 2020] 权力药水"
layout: "post"
diff: 省选/NOI-
pid: P6804
tag: ['2020', '交互题', 'Special Judge', 'CEOI（中欧）']
---
# [CEOI 2020] 权力药水
## 题目背景

3s，256MB
## 题目描述

很久以前，在萨满之岛上，所有人都住在一个如天一样高的豆茎上。每位萨满都有一个独一无二的编号，编号的范围在 $0$ 和 $N-1$ 之间。第 $i$ 位萨满居住的高度用 $H_i$ 表示。定义两位萨满间的距离为其高度差的绝对值。

所有的萨满之间本来和谐共处，直到一天权力药水的配方被盗。为了掩盖他的行径，那位小偷给整座岛施加了诅咒，大多数居民不再彼此信任了。

虽然情况非常复杂，但是经过调查，某组织还是获得了如下信息：

- 诅咒刚生效时，所有的萨满停止彼此信任。
- 诅咒本身是不稳定的，在每天将要结束时（准确来说是午夜），某一对萨满将会建立信任或是停止信任。
- 不幸地是，一位萨满在任意时刻最多信任 $D$ 位萨满。

该组织还重建了萨满间的信任变化日志，该日志记录了在每个半夜，哪对萨满的信任关系发生了变化（从不信任到信任，或是从信任到不信任）。

该组织的成员相信，小偷还向一位邪恶的萨满通过隔空传话的方式泄露了配方。为了避免被发现，他们俩都各自拜访了一位信任的萨满的家，在拜访的过程中，小偷透过窗户向邪恶的萨满泄露配方。需要注意的是，那位信任的朋友当时不必在家中，事实上，两位萨满可能互相前往对方的家。毕竟萨满都很奇怪。

幸运的是，因为萨满们的听力有限，声音并不能传出太远，这意味着两位朋友（小偷的朋友和邪恶的萨满的朋友）之间的距离必须尽可能近。

现在该组织决定让你来协助调查。他们想要验证自己的猜想：当小偷为 $x$，邪恶的萨满为 $y$，泄露配方的日子为 $v$ 时，隔空传话的声音需要行进的最小值是多少？也即，你需要在第 $v$ 天时，在 $x$ 信任的所有萨满中找到一位萨满 $x'$，在 $y$ 信任的所有萨满中找到一位萨满 $y'$，使 $x'$ 和 $y'$ 间的距离最小。

你已经获得了求出答案所需的所有信息，但你需要**实时**回答每一组询问。
## 输入格式

**仅提供 IO 交互**。

输入第一行包含四个整数 $N,D,U,Q$，分别代表萨满的数量，一位萨满最多信任的朋友数，日志包含的天数，以及需要回答的询问数。

下一行包含 $N$ 个整数，两两间以一个空格隔开。其中第 $i$ 个整数代表第 $i-1$ 只萨满居住的高度 $H_{i-1}$。

接下来 $U$ 行，第 $i$ 行包含两个整数 $A_i,B_i$，代表编号为 $A_i$ 和 $B_i$ 的萨满在第 $i-1$ 天结束的时候，他们之间的信任状态发生了变化。即，如果 $A_i$ 和 $B_i$ 在第 $i-1$ 天互相信任，则他们自第 $i$ 天起不再互相信任，反之同理。

接下来你需要回答 $Q$ 组询问。询问必须实时回答，即你必须回答完一组询问后才能读入下一组询问。

每组询问包含三个整数 $x,y,v$，代表小偷为 $x$，邪恶的萨满为 $y$，泄露配方的日子为第 $v$ 天。
## 输出格式

对于每组询问，你需要在第 $v$ 天时，在 $x$ 信任的所有萨满中找到一位萨满 $x'$，在 $y$ 信任的所有萨满中找到一位萨满 $y'$，使 $x'$ 和 $y'$ 间的距离最小，并输出这个最小值。

特别地，

- 若存在一位萨满同时被 $x$ 和 $y$ 信任，输出 $0$。
- 若 $x$ 或 $y$ 在第 $v$ 天无信任的朋友，输出 $1000000000$（$10^9$）。

在回答完一组询问后，你需要立刻刷新缓冲区。

对于 C++ 选手，可以通过 `fflush(stdout);` 或 `cout.flush()` 来刷新缓冲区。
## 样例

### 样例输入 #1
```
6 5 11 4
2 42 1000 54 68 234
0 1
2 0
3 4
3 5
3 5
1 3
5 3
0 5
3 0
1 3
3 5
0 3 4
3 0 8
0 5 5
3 0 11
```
### 样例输出 #1
```
26
0
1000000000
14
```
## 提示

### 样例解释

下面是询问的情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/gdrha1bp.png)

下面是每一天时信任关系的变化情况：

![](https://cdn.luogu.com.cn/upload/image_hosting/uulqejgp.png)

### 子任务

所有数据均满足：$2 \leq N \leq 10^5$，$1 \leq D \leq 500$，$0 \leq U \leq 2 \times 10^5$，$1 \leq Q \leq 5 \times 10^4$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                                    |
| ---------- | ---- | --------------------------------------- |
| $1$        | $0$  | 样例                                    |
| $2$        | $17$ | $Q,U \leq 10^3$                         |
| $3$        | $14$ | 所有询问均满足 $v=U$                  |
| $4$        | $18$ | $\forall i \in [0,N)$，$H_i\in \{0,1\}$ |
| $5$        | $21$ | $U,N \leq 10^4$                         |
| $6$        | $30$ | 无特殊约束                              |


---

---
title: "[CEOI 2020] 春季大扫除"
layout: "post"
diff: 省选/NOI-
pid: P6805
tag: ['2020', 'CEOI（中欧）']
---
# [CEOI 2020] 春季大扫除
## 题目背景

0.3s，128MB
## 题目描述

春季大扫除也许是我们一生中最无聊的事情之一。当然，对于 Flóra 和她的母亲而言，今年的春季大扫除要有意思得多。因为她们在地毯下发现了一张已被灰尘覆盖的树形地图。

这棵树有 $N$ 个节点，节点从 $1$ 到 $N$ 进行编号，这 $N$ 个点通过 $N-1$ 条边相连。这些边上都积累了过多的灰尘，因此 Flóra 的母亲准备对这棵树进行清理。

清理这棵树的过程是这样的：Flóra 的母亲每次在这棵树上选择两个叶子节点（定义一棵树的叶子节点为只与恰好一个点直接相连的点），并对这两个叶子点路径上的所有边进行清理。如果这条路径上有 $d$ 条边，则清理的费用为 $d$。当这棵树上的所有边都被清理后，这棵树的清理过程就完成了。清理这棵树的总费用即为各次清理的费用之和。

因为她想保护这棵树的叶子节点，因此对于每个叶子节点，她最多只会选择一次。

Flóra 认为原来的树过于简单，她决定对原始的树进行一些改造。在第 $i$ 次改造中，她在原始的树的基础上添加了 $D_i$ 个叶子节点。具体来说，她会在原始的树上选择一个节点，并在该点与新的叶子节点之间连接一条边。需要注意的是，在添加新的叶子节点的过程中，原来的一些节点将不再是叶子节点。

现在你需要帮助 Flóra 求出清理改造后的树的最小费用。
## 输入格式

输入第一行包含两个数 $N,Q$，分别代表原始的树上的节点数，以及 Flóra 准备对原始的树进行的改造次数。

接下来 $N-1$ 行，每行两个整数 $u,v$，表示在原始的树上 $u,v$ 两个节点间有一条边相连。

接下来 $Q$ 行，每行第一个整数 $D_i$，表示 Flóra 准备在第 $i$ 次改造中添加 $D_i$ 个叶子节点。接下来 $D_i$ 个整数，第 $j$ 个整数 $a_j$ 表示 Flóra 准备在 $a_j$ 号点上添加一个叶子节点。同一个点上可能会添加多个叶子节点。

每次改造过程是独立的，即在一轮改造后，Flóra 会在原始的树上重新开始改造过程。
## 输出格式

对于每次改造，你需要输出一个整数，表示清理这棵改造后的树的最小费用。

特别地，若这棵树不能被完全清理，输出 $-1$。
## 样例

### 样例输入 #1
```
7 3
1 2
2 4
4 5
5 6
5 7
3 4
1 4
2 2 4
1 1
```
### 样例输出 #1
```
-1
10
8
```
## 提示

### 样例解释

下面展示的是第二次改造后的树：

![](https://cdn.luogu.com.cn/upload/image_hosting/9rj8iovq.png)

一种最优的清理方案是清理 $1-6$，$A-7$，$B-3$ 这三条路径上的所有边。

### 子任务

所有测试点均满足：$3 \leq N \leq 10^5$，$1 \leq Q \leq 10^5$，$\sum D_i \leq 10^5$，$1 \leq u,v \leq N$，$1 \leq a_j \leq N$。

各子任务的约束条件如下：

| 子任务编号 | 分值 | 约束                                                         |
| ---------- | ---- | ------------------------------------------------------------ |
| $1$        | $0$  | 样例                                                         |
| $2$        | $9$  | $Q=1$，$\forall i \in [2,N]$，都存在一条连接 $1$ 和 $i$ 的边，且 Flóra 不会在 $1$ 号点上添加叶子节点 |
| $3$        | $9$  | $Q=1$，$\forall i \in [1,N)$，$i$ 和 $i+1$ 之间有边相连，且 Flóra 不会在 $1$ 号点或 $N$ 号点上添加叶子节点 |
| $4$        | $16$ | $N \leq 2 \times 10^4$，$Q \leq 300$                         |
| $5$        | $19$ | 原始的树是一棵以 $1$ 号点为根的满二叉树，即每个非叶子节点均有恰好两个子节点，且各叶子节点到根节点间的距离相等 |
| $6$        | $17$ | $\forall i \in [1,Q]$，$D_i=1$                               |
| $7$        | $30$ | 无特殊约束                                                   |


---

---
title: "[PA 2013] Filary"
layout: "post"
diff: 省选/NOI-
pid: P6817
tag: ['2013', 'PA（波兰）']
---
# [PA 2013] Filary
## 题目描述

给定长度为 $n$ 的数列 $a$，从中选取 $k$ 个数使得这 $k$ 个数模 $m$ 相等，其中 $m\geq 2$。

求出 $k$ 的最大值，并在 $k$ 最大的前提下最大化 $m$。
## 输入格式

第一行一个正整数 $n$。

第二行 $n$ 个正整数，表示数列 $a$。
## 输出格式

一行两个数 $k,m$。
## 样例

### 样例输入 #1
```
6
7 4 10 8 7 1
```
### 样例输出 #1
```
5 3
```
## 提示

$2\leq n\leq 10^5$，$1\leq a_i\leq 10^7$，保证有解，且不存在所有 $a_i$ 都相等的情况。


---

---
title: "[PA 2012 Finals] Binary Dodgeball"
layout: "post"
diff: 省选/NOI-
pid: P6819
tag: ['2012', 'PA（波兰）']
---
# [PA 2012 Finals] Binary Dodgeball
## 题目描述

有 $n$ 个盒子，开始时每个盒子中有一个棋子。


两位选手轮流操作，每次可以选择一个 $i$ 号盒子中的棋子和一个正整数 $p$，将棋子移到编号为 $2^p\times i$ 的盒子中。若编号为 $2^p\times i$ 的盒子中已有棋子了，则这两个棋子都会被移出盒子。不能移动者输。

求第 $k$ 小的 $n$，使得**后**手能赢得游戏。
## 输入格式

仅一行，包含一个正整数 $k$。
## 输出格式

仅一行，包含一个正整数 $n$。
## 样例

### 样例输入 #1
```
2
```
### 样例输出 #1
```
10
```
## 提示

对于 $100\%$ 的数据，$1\le k<10^9$。


---

---
title: "[PA 2012 Finals] Tanie linie"
layout: "post"
diff: 省选/NOI-
pid: P6821
tag: ['2012', 'O2优化', 'PA（波兰）']
---
# [PA 2012 Finals] Tanie linie
## 题目描述

给定含 $n$ 个数的序列，求至多 $k$ 个不相交子段的和的最大值。
## 输入格式

第一行两个正整数 $n,k$。

接下来一行 $n$ 个整数，为这个序列。
## 输出格式

输出一个整数，为答案。
## 样例

### 样例输入 #1
```
5 2
7 -3 4 -9 5
```
### 样例输出 #1
```
13
```
## 提示

对于 $100\%$ 的数据，$1\le k\le n\le 10^6$。序列内所有数在 $[-10^9,10^9]$ 内。


---

---
title: "[PA 2012 Finals] Tax"
layout: "post"
diff: 省选/NOI-
pid: P6822
tag: ['2012', 'PA（波兰）']
---
# [PA 2012 Finals] Tax
## 题目描述

给出一个 $n$ 个点 $m$ 条边的无向图，经过一个点的代价是进入和离开这个点的两条边的边权的较大值，求从起点 $1$ 到点 $n$ 的最小代价。起点的代价是离开起点的边的边权，终点的代价是进入终点的边的边权。
## 输入格式

第一行两个数 $n,m$，分别表示点数和边数。

接下来 $m$ 行，每行三个数 $a,b,c$，表示 $a,b$ 之间存在一条长度为 $c$ 的边。


## 输出格式

一行一个数，表示答案。
## 样例

### 样例输入 #1
```
4 5
1 2 5
1 3 2
2 3 1
2 4 4
3 4 8
```
### 样例输出 #1
```
12
```
## 提示

$1\leq n\leq 10^5$，$1\leq m\leq 2\times 10^5$，$1\leq c\leq 10^6$。


---

---
title: "[CEOI 2019] Dynamic Diameter"
layout: "post"
diff: 省选/NOI-
pid: P6845
tag: ['2019', 'CEOI（中欧）']
---
# [CEOI 2019] Dynamic Diameter
## 题目描述

有一棵树，含 $n$ 个节点，边带权。

会有 $q$ 次修改，每次会将树上的一条边的边权进行修改，在每次修改后，您需要求出每次修改后，这棵树的直径上的边权和。

**本题强制在线。**
## 输入格式

第一行为三个整数 $n,q,w$，分别表示点的个数，询问的个数和边权的上限。

接下来 $n-1$ 行，每一行为三个整数 $a_i,b_i,c_i$，表示 $a_i$ 到 $b_i$ 有一条边权为 $c_i$ 的边。

接下来 $q$ 行，每行两个经过加密的整数 $d_j,e_j$。

解密方式如下：
- $d_j'=(d_j+\text{last})\bmod(n-1)$
- $e_j'=(e_j+\text{last})\bmod w$

其中 $\text{last}$ 表示上一个询问的答案，初值为 $0$。

表示将第 $d_j'+1$ 条边的边权改为 $e_j'$。
## 输出格式

共输出 $q$ 行，一行一个整数，第 $i$ 行的整数表示在第 $i$ 次修改后的直径上的权值总和。
## 样例

### 样例输入 #1
```
4 3 2000
1 2 100
2 3 1000
2 4 1000
2 1030
1 1020
1 890
```
### 样例输出 #1
```
2030
2080
2050

```
### 样例输入 #2
```
10 10 10000
1 9 1241
5 6 1630
10 5 1630
2 6 853
10 1 511
5 3 760
8 3 1076
4 10 1483
7 10 40
8 2051
5 6294
5 4168
7 1861
0 5244
6 5156
3 3001
8 5267
5 3102
8 3623
```
### 样例输出 #2
```
6164
7812
8385
6737
6738
7205
6641
7062
6581
5155
```
## 提示

#### 样例 1 解释

解密后的修改如下：
```
2 1030
0 1050
2 970
```
如图为树的边权变化过程，红边代表树的直径：
![](https://cdn.luogu.com.cn/upload/image_hosting/sswn0icz.png)
#### 数据范围
对于 $100\%$ 的数据，保证 $2\le n\le 10^5$，$1\le q\le 10^5$，$1\le w\le 2\times 10^{13}$，$1\le a_i,b_i\le n$，$0\le c_i,e_j<w$，$0\le d_j<n-1$。

详细子任务限制及分值如下表：

| 子任务编号 | 限制 | 分值 |
| :-: |:-:|:-:|
| 1 | $n,q\le 100$ 且 $w\le 10^4$ | $11$ | 
| 2 | $n,q\le 5\times 10^3$ 且 $w\le 10^4$ | $13$ | 
| 3 | $w\le 10^4$ 且边的形式均为 $(1,i)$ | $7$ | 
| 4 | $w\le 10^4$ 且边的形式均为 $(i,2\times i)$ 或 $(i,2\times i+1)$ | $18$ | 
| 5 | 保证有一条直径经过 $1$ 号节点 | $24$ | 
| 6 | 无特殊限制 | $27$ | 
#### 说明
本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 1](https://ceoi.sk/tasks/) [T2 Dynamic Diameter](https://ceoi.sk/static/statements/diameter-ENG.pdf)。


---

---
title: "[CEOI 2019] Amusement Park"
layout: "post"
diff: 省选/NOI-
pid: P6846
tag: ['2019', 'CEOI（中欧）']
---
# [CEOI 2019] Amusement Park
## 题目描述

有一个含 $n$ 个点，$m$ 条边的有向图，图无重边，无自环，两点之间不成环。

现在我们想改变一些边的方向，使得该有向图无环。

您需要求出，每一种改变方向后使得该有向图无环的方案的需改变边的数量之和 $\bmod\ 998244353$ 之后的答案。
## 输入格式

第一行为两个整数 $n,m$。

接下来 $m$ 行，一行两个整数 $a_i,b_i$，表示有一条起点为 $a_i$，终点为 $b_i$ 的有向边。
## 输出格式

仅一行一个整数，表示每一种改变方向后使得该有向图无环的方案的需改变边的数量之和 $\bmod\ 998244353$ 之后的答案。
## 样例

### 样例输入 #1
```
2 1
1 2

```
### 样例输出 #1
```
1

```
### 样例输入 #2
```
3 3
1 2
2 3
1 3
```
### 样例输出 #2
```
9
```
## 提示

#### 样例解释
#### 样例 1 解释
有如下两种方案：
- 改变方向。
- 不改变方向。

所以输出 $1+0=1$。
#### 样例 2 解释
共有六种可行的方案：
- $1\to2,2\to3,1\to3$
- $1\to2,3\to2,1\to3$
- $1\to2,3\to2,3\to1$
- $2\to1,2\to3,1\to3$
- $2\to1,2\to3,3\to1$
- $2\to1,3\to2,3\to1$

所以输出 $0+1+2+1+2+3=9$。
#### 数据范围
对于 $100\%$ 的数据，保证 $1\le n\le 18$，$0\le m\le \frac{n\times (n-1)}{2}$，$1\le a_i,b_i\le n$，$a_i\not=b_i$，对于 $i\not=j$，均有 $a_i\not=a_j$ 或者 $b_i\not=b_j$，无序数对 $\{a_i,b_i\}$ 互不相同。

详细子任务限制及分值如下表：

| 子任务编号 | 限制 | 分值 |
| :-: |:-:|:-:|
| 1 | $n\le 3$ | $7$ | 
| 2 | $n\le 6$ | $12$ | 
| 3 | $n\le 10$ | $23$ | 
| 4 | $n\le 15$ | $21$ | 
| 5 | 无特殊限制 | $37$ | 
#### 说明
本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T1 Amusement Park](https://ceoi.sk/static/statements/amusementpark-ENG.pdf)。


---

---
title: "[CEOI 2019] Magic Tree"
layout: "post"
diff: 省选/NOI-
pid: P6847
tag: ['2019', 'CEOI（中欧）']
---
# [CEOI 2019] Magic Tree
## 题目描述

有一棵以 $1$ 为根，节点从 $1$ 到 $n$ 编号的树。

在这棵树上有许多果实，第 $j$ 个果实会于第 $d_j$ 天在节点 $v_j$ 成熟，并且在收获后可获得 $w_j$ 的果汁。

第 $j$ 个果实仅能在第 $d_j$ 天收获。

收获的方式是断掉这棵树的一条边，这会获得在这条边上作为儿子的那个点的子树上的当天成熟的果实的果汁。

您要求出最多可以获得多少果汁。
## 输入格式

第一行为三个整数 $n,m,k$，分别表示节点的个数，果实的个数和果实可能成熟天数的最大值。

接下来 $n-1$ 行，一行一个整数 $p_i$，表示 $i+1$ 号节点的父亲是 $p_i$。

接下来 $m$ 行一行三个整数 $v_j,d_j,w_j$。
## 输出格式

一行一个数，表示最多可以获得多少果汁。
## 样例

### 样例输入 #1
```
6 4 10
1
2
1
4
4
3 4 5
4 7 2
5 4 1
6 9 3

```
### 样例输出 #1
```
9

```
## 提示

#### 样例解释
最优方案如下：
- 在第四天，断掉 $(4,5)$ 和 $(1,2)$，获得第一个和第三个果实，获得的果汁数量累计为 $6$。
- 在第七天，虽然我们有一个果实成熟，但是我们最好什么都不干。
- 在第九天，断掉 $(1,4)$，获得最后一个果实，获得的果汁数量累计为 $9$。
#### 数据范围
对于 $100\%$ 的数据，保证 $2\le n\le 10^5$，$1\le m\le n-1$，$1\le k\le 10^5$，$1\le p_i\le i-1$，$2\le v_j\le n$，$1\le d_j\le k$，$1\le w_j\le 10^9$，$v_j$ 互不相同。

详细子任务限制及分值如下表：

| 子任务编号 | 限制 | 分值 |
| :-: |:-:|:-:|
| 1 | $n,k\le 20$ 且 $w_j=1$ | $6$ | 
| 2 | $v_j\in $ 叶子节点 | $3$ | 
| 3 | 图是一条链且 $w_j=1$ | $11$ | 
| 4 | $k\le 2$ | $12$ | 
| 5 | $k\le 20$ 且 $w_j=1$ | $16$ | 
| 6 | $m\le 10^3$ | $13$ | 
| 7 | $w_j=1$ | $22$ | 
| 8 | 无特殊性质 | $17$ | 
#### 说明
本题译自 [Central-European Olympiad in Informatics 2019](https://ceoi.sk/) [Day 2](https://ceoi.sk/tasks/) [T2 Magic Tree](https://ceoi.sk/static/statements/magictree-ENG.pdf)。


---

---
title: "Tram"
layout: "post"
diff: 省选/NOI-
pid: P6854
tag: ['洛谷月赛']
---
# Tram
## 题目背景

电车开了，他的声音在我的脑海中萦绕不散：

「留下来，跟我来。」

我回头去看车站，他不见了。

我在德辅道寻找他的身影。

路人不多，但他却消失了。

我把窗拉下来，微风轻拂我的脸。

他到哪儿去了？

路人、街道、高楼大厦。

在我身边轻轻地流走。


## 题目描述

你就要出道了！

你的教练和同学为你联系了摄影师，你们来到德辅道边拍宣传照。

街上一共有 $n$ 幢楼房，从左到右排成一列，从 $1$ 到 $n$ 编号，编号为 $i$ 的楼房的高度是 $a_i$。

一张照片可以用二元组 $(l,r)$ 描述，其中 $1\le l\le r\le n$，这张照片中包含了编号在 $[l,r]$ 之间的所有楼房。

摄影师认为，一张照片是美丽的，当且仅当其同时满足下面的两个条件：

- 对于任意的 $i<j<k$，如果高度为 $i$ 和 $k$ 的楼房都在照片中出现过，那么高度为 $j$ 的楼房也在照片中出现过。
- 对于任意的 $i$，高度为 $i$ 的楼房要么不出现在照片中，要么在照片中出现恰好 $i$ 次。

摄像师问你，一共能拍出多少不同的美丽的照片呢？

两张照片 $(l_1,r_1)$ 和 $(l_2,r_2)$ 不同，当且仅当 $l_1\ne l_2$ 或 $r_1\ne r_2$。
## 输入格式

第一行一个正整数 $n$，表示楼房数量。

随后一行 $n$ 个正整数，第 $i$ 个为编号为 $i$ 的楼房的高度。
## 输出格式

输出一行一个整数表示能拍出的不同的美丽的照片数量。
## 样例

### 样例输入 #1
```
10
2 2 1 1 2 2 3 1 3 3 
```
### 样例输出 #1
```
8
```
## 提示

**本题采用捆绑测试**。你只有通过 subtask 中的所有测试点才能获得该 subtask 的分数。

- Subtask 1(10 points)：$n\le 200$；
- Subtask 2(5 points)：$n\le 1000$；
- Subtask 3(10 points)：$n\le 6000$；
- Subtask 4(20 points)：$n\le 3\times 10^4$；
- Subtask 5(30 points)：$n\le 10^5$；
- Subtask 6(25 points)：$n\le 10^6$。


对于所有数据满足：$1\le n,a_i\le 10^6$。

注意答案的大小可能超过 $32$ 位有符号整数的范围。

本题输入数据量较大，请使用较快的读入方式。


---

---
title: "[RC-03] 记忆"
layout: "post"
diff: 省选/NOI-
pid: P6864
tag: []
---
# [RC-03] 记忆
## 题目背景

小 W 想写一个关于记忆的题目背景，但是他忘记了。
## 题目描述

有一个括号串 $S$，一开始 $S$ 中只包含一对括号（即初始的 $S$ 为 `()`），接下来有 $n$ 个操作，操作分为三种：

1. 在当前 $S$ 的末尾加一对括号（即 $S$ 变为 `S()`）；

2. 在当前 $S$ 的最外面加一对括号（即 $S$ 变为 `(S)`）；

3. 取消第 $x$ 个操作，即去除第 $x$ 个操作造成过的**一切影响**（例如，如果第 $x$ 个操作也是取消操作，且取消了第 $y$ 个操作，那么当前操作的实质就是恢复了第 $y$ 个操作的作用效果）。

每次操作后，你需要输出 $S$ 的能够括号匹配的非空子串（子串要求连续）个数。

一个括号串能够括号匹配，当且仅当其左右括号数量相等，且任意一个前缀中左括号数量不少于右括号数量。
## 输入格式

第一行：一个整数 $n$，表示操作的个数。

接下来 $n$ 行：每行先有一个整数 $op$，表示操作的种类：

若 $op=1$，则表示执行了操作 $1$；

若 $op=2$，则表示执行了操作 $2$；

若 $op=3$，接下来还有一个整数 $x$，表示执行操作 $3$，取消了第 $x$ 个操作（操作按 $1$ 到 $n$ 编号，保证第 $x$ 个操作已发生），注意取消操作**并不影响任何操作的编号**，编号只取决于输入顺序。
## 输出格式

共 $n$ 行：第 $i$ 行输出一个整数 $ans_i$，表示第 $i$ 次操作结束后整个括号串的括号匹配的非空子串个数。
## 样例

### 样例输入 #1
```
6
1
2
3 1
1
3 3
3 5

```
### 样例输出 #1
```
3
4
2
4
6
4

```
### 样例输入 #2
```
10
1
2
2
3 2
1
3 3
3 6
1
2
1

```
### 样例输出 #2
```
3
4
5
4
6
6
6
9
10
12

```
## 提示

【样例 $1$ 解释】

用 $S[i,j]$ 表示从 $S_i$ 到 $S_j$ 的子串（下标从 $1$ 开始）。

一开始 $S$ 为 `()`，每次操作后：

第 $1$ 次操作后：$S$ 为 `()()`，匹配的子串有 $S[1,2]$，$S[1,4]$ 和 $S[3,4]$，共 $3$ 个。

第 $2$ 次操作后：$S$ 为 `(()())`，匹配的子串有 $S[1,6]$，$S[2,3]$，$S[2,5]$ 和 $S[4,5]$，共 $4$ 个。

第 $3$ 次操作后：$S$ 为 `(())`，匹配的子串有 $S[1,4]$ 和 $S[2,3]$，共 $2$ 个。

第 $4$ 次操作后：$S$ 为 `(())()`，匹配的子串有 $S[1,4]$，$S[1,6]$，$S[2,3]$ 和 $S[5,6]$，共 $4$ 个。

第 $5$ 次操作后：$S$ 为 `(()())()`，匹配的子串有 $S[1,6]$，$S[1,8]$，$S[2,3]$，$S[2,5]$，$S[4,5]$ 和 $S[7,8]$，共 $6$ 个。

第 $6$ 次操作后：$S$ 为 `(())()`，匹配的子串有 $S[1,4]$，$S[1,6]$，$S[2,3]$ 和 $S[5,6]$，共 $4$ 个。

---

【数据范围】

**本题采用捆绑测试。**

对于全部数据：$1\leq n\leq 2\times 10^5$，$op\in \{1,2,3\}$，$1\leq x\leq n$，一个操作在形式上最多只会被取消一次（即所有 $x$ 互不相同）。

| 子任务编号 |    $n\leq$     |   $op\in$   | 分值 |
| :--------: | :------------: | :---------: | :--: |
| Subtask 1  |     $100$      | $\{1,2,3\}$ | $10$ |
| Subtask 2  |     $10^3$     | $\{1,2,3\}$ | $10$ |
| Subtask 3  |     $10^5$     | $\{1,2,3\}$ | $30$ |
| Subtask 4  | $2\times 10^5$ |  $\{1,2\}$  | $20$ |
| Subtask 5  | $2\times 10^5$ | $\{1,2,3\}$ | $30$ |




---

---
title: "[COCI 2019/2020 #5] Matching"
layout: "post"
diff: 省选/NOI-
pid: P6868
tag: ['2019', 'Special Judge', 'COCI（克罗地亚）']
---
# [COCI 2019/2020 #5] Matching
## 题目描述

给你二维平面上的 $n$ 个整点。保证 $\forall a$，有至多两个形如 $(a,x)$ 的点；$\forall b$，有至多两个形如 $(x,b)$ 的点。

请你用 $n\over 2$ 条线段连接这 $n$ 个点。要求每个点都是一条线段的端点。要求这些线段都是水平的或竖直的。要求这些线段都不相交。

请你求出这是否可能。如果可能，请你输出任意一种方法。
## 输入格式

- 第一行有一个偶正整数 $n$。

- 接下来有 $n$ 行。第 $i$ 行有两个正整数 $x_i,y_i$，表示第 $i$ 个点的坐标。
## 输出格式

如果不可能，请在一行输出 `NE`。

如果可能，请在第一行输出 `DA`。在接下来的 $n\over 2$ 行中各输出两个整数，表示一条线段（整数是端点的编号，从 $1$ 开始）。
## 样例

### 样例输入 #1
```
8
1 1
1 3
2 2
2 4
3 1
3 3
4 2
4 4

```
### 样例输出 #1
```
DA
1 5
3 7
2 6
4 8
```
### 样例输入 #2
```
6
1 2
1 3
2 1
2 4
3 2
3 3

```
### 样例输出 #2
```
DA
1 2
3 4
5 6
```
### 样例输入 #3
```
2
1 1
2 2

```
### 样例输出 #3
```
NE
```
### 样例输入 #4
```
20
62488 5330
62488 5027
76436 5027
39827 79374
95732 59715
66222 46366
8346 59715
49581 53207
66222 79374
80123 46366
76436 5330
39590 5690
82990 89723
95732 89723
8346 79295
80123 16069
39827 16069
49581 5690
82990 79295
39590 53207

```
### 样例输出 #4
```
DA
3 11
1 2
16 10
6 9
4 17
13 19
15 7
5 14
12 20
8 18
```
## 提示

### 数据范围

**本题捆绑测试。**

- 对于 $5 pts$ 的数据：$2\leq n\leq 20$，且 $\forall a$ ，有偶数个形如 $(a,x)$ 的点和偶数个形如 $(x,a)$ 的点。
- 对于另外 $6 pts$ 的数据：$2\leq n\leq 20$。
- 对于另外 $7 pts$ 的数据：$2\leq n\leq 40$。
- 对于另外 $40 pts$ 的数据：$2\leq n\leq 2000$。
- 对于所有的数据：$2\leq n\leq 100000$ 且 $1\leq x_i,y_i\leq 100000$。对于任何整数 $a$ ，有至多 $2$ 个点 $(a,x)$ 和 至多 $2$ 个点 $(x,a)$。

### 说明

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #5](https://hsin.hr/coci/archive/2019_2020/contest5_tasks.pdf)  _T3 Matching_** ，译者 [90693](/user/90693)。

spj by [90693](/user/90693)，有任何问题请直接私信或@。


---

---
title: "[JOISC 2020] ビルの飾り付け 4"
layout: "post"
diff: 省选/NOI-
pid: P6891
tag: ['2020', 'Special Judge', 'JOI（日本）']
---
# [JOISC 2020] ビルの飾り付け 4
## 题目背景

JOISC2020 Day 1 T1

由于数据点较多，本题只评测其中的部分数据。
## 题目描述

给定两个长度为 $2n$ 的序列 $A,B$，构造一个长度为 $2n$ 的序列 $C$ 满足以下条件：

- 对于 $1\leq i\leq 2n$，$C_i$ 只能从 $A_i$ 和 $B_i$ 中选取

- $C_i$ 从 $A_i$ 中选取的次数和从 $B_i$ 中选取的次数都恰好为 $n$。

- $C$ 为单调不降的序列。

如果满足条件的 $C$ 有多个，只需要输出一个。
## 输入格式

第一行一个正整数 $n$。

第二行 $2n$ 个数字，第 $i$ 个为 $A_i$。

第三行 $2n$ 个数字，第 $i$ 个为 $B_i$。
## 输出格式

如果无解则输出 $-1$，否则按照以下方式输出一个字符串 $s$：

对于 $1\leq i\leq 2n$，如果 $C_i$ 是从 $A_i$ 选取的则 $s_i=\texttt{A}$，否则 $s_i=\texttt{B}$。
## 样例

### 样例输入 #1
```
3
2 5 4 9 15 11
6 7 6 8 12 14
```
### 样例输出 #1
```
AABABB
```
### 样例输入 #2
```
2
1 4 10 20
3 5 8 13
```
### 样例输出 #2
```
BBAA
```
### 样例输入 #3
```
2
3 4 5 6
10 9 8 7
```
### 样例输出 #3
```
-1
```
### 样例输入 #4
```
6
25 18 40 37 29 95 41 53 39 69 61 90
14 18 22 28 18 30 32 32 63 58 71 78
```
### 样例输出 #4
```
BABBABAABABA
```
## 提示

#### 样例 1 解释

构造的 $C=[2,5,6,9,12,14]$，可以自行这是满足条件的方案。

#### 样例 2 解释

另外有 $\texttt{AABB},\texttt{ABAB},\texttt{BABA},\texttt{BAAB},\texttt{ABBA}$ 这 $5$ 组解，输出任何一组均可。

#### 样例 3 解释

没有满足条件的方案。

#### 子任务

| 子任务 | 特殊性质 | 分数 |
| :----------: | :----------: | :----------: |
| $1$ | $1\leq n\leq 2\times 10^3$ | $11$ |
| $2$ | 无 | $89$ |

对于 $100\%$ 的数据，$1\leq n\leq 5\times 10^5,1\leq A_i,B_i\leq 10^9$。


---

---
title: "[ICPC 2015 WF] Catering"
layout: "post"
diff: 省选/NOI-
pid: P6906
tag: ['2015', 'ICPC']
---
# [ICPC 2015 WF] Catering
## 题目描述

 ![](https://vj.z180.cn/c3c77c406a120e9e6c632a7a3d0cfeac?v=1603344926)  

Paul owns a catering company and business is booming. The company has $k$ catering teams, each in charge of one set of catering equipment. Every week, the company accepts $n$ catering requests for various events. For every request, they send a catering team with their equipment to the event location. The team delivers the food, sets up the equipment, and instructs the host on how to use the equipment and serve the food. After the event, the host is responsible for returning the equipment back to Paul’s company. 

Unfortunately, in some weeks the number of catering teams is less than the number of requests, so some teams may have to be used for more than one event. In these cases, the company cannot wait for the host to return the equipment and must keep the team on-site to move the equipment to another location. The company has an accurate estimate of the cost to move a set of equipment from any location to any other location. Given these costs, Paul wants to prepare an Advance Catering Map to service the requests while minimizing the total moving cost of equipment (including the cost of the first move), even if that means not using all the available teams. Paul needs your help to write a program to accomplish this task. The requests are sorted in ascending order of their event times and they are chosen in such a way that for any $i < j$, there is enough time to transport the equipment used in the $i^{th}$ request to the location of the $j^{th}$ request.
## 输入格式

The first line of input contains two integers $n$ ($1 \le n \le 100$) and $k$ ($1 \le k \le 100$) which are the number of requests and the number of catering teams, respectively. Following that are $n$ lines, where the $i^{th}$ line contains $n-i+1$ integers between $0$ and $1\, 000\, 000$ inclusive. The $j^{th}$ number in the $i^{th}$ line is the cost of moving a set of equipment from location $i$ to location $i+j$. The company is at location $1$ and the $n$ requests are at locations $2$ to $n+1$.
## 输出格式

Display the minimum moving cost to service all requests. (This amount does not include the cost of moving the equipment back to the catering company.)
## 样例

### 样例输入 #1
```
3 2
40 30 40
50 10
50

```
### 样例输出 #1
```
80

```
### 样例输入 #2
```
3 2
10 10 10
20 21
21

```
### 样例输出 #2
```
40

```
## 提示

Time limit: 4000 ms, Memory limit: 1048576 kB. 

 International Collegiate Programming Contest (ACM-ICPC) World Finals 2015
## 题目翻译

有一家装备出租公司收到了按照时间顺序排列的 $n$ 个请求。

这家公司有 $k$ 个搬运工。每个搬运工可以搬着一套装备**按时间顺序**去满足一些请求。

一个搬运工从第 $i$ 个请求的位置把东西搬到第 $j$ 个请求的位置需要一些费用。公司的编号是 1，请求的编号是 $2\sim n+1$。所有搬运工必须从公司出发。

求满足所有请求所需的最小搬运费用.


---

---
title: "[ICPC 2015 WF] Tile Cutting"
layout: "post"
diff: 省选/NOI-
pid: P6913
tag: ['2015', 'ICPC']
---
# [ICPC 2015 WF] Tile Cutting
## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/f8fpcjx7.png) 

Youssef is a Moroccan tile installer who specializes in mosaics like the one shown on the right. He has rectangular tiles of many dimensions at his disposal, and the dimensions of all his tiles are integer numbers of centimeters. When Youssef needs parallelogram-shaped tiles, he cuts them from his supply on hand. To make this work easier, he invented a tile cutting machine that superimposes a centimeter grid on the cutting surface to guide the cuts on the tiles. Due to machine limitations, aesthetic sensibilities, and Youssef’s dislike of wasted tiles, the following rules determine the possible cuts. 

The rectangular tile to be cut must be positioned in the bottom left corner of the cutting surface and the edges must be aligned with the grid lines.

The cutting blade can cut along any line connecting two different grid points on the tile boundary as long as the points are on adjacent boundary edges.

The four corners of the resulting parallelogram tile must lie on the four sides of the original rectangular tile.

No edge of the parallelogram tile can lie along an edge of the rectangular tile.

Figure 1 shows the eight different ways in which a parallelogram tile of area $4$ square centimeters can be cut out of a rectangular tile, subject to these restrictions.

![](https://cdn.luogu.com.cn/upload/image_hosting/figekxdx.png)

   Figure 1: The eight different ways for cutting a parallelogram of area 4. 

Youssef needs to cut tiles of every area between $a_{\text {lo}}$ and $a_{\text {hi}}$. Now he wonders, for which area $a$ in this range can he cut the maximum number of different tiles?
## 输入格式

The input consists of multiple test cases. The first line of input contains an integer $n$ ($1 \le n \le 500$), the number of test cases. The next $n$ lines each contain two integers $a_{\text {lo}}, a_{\text {hi}}$ ($1 \le a_{\text {lo}} \le a_{\text {hi}} \le 500\, 000$), the range of areas of the tiles.
## 输出格式

For each test case $a_{\text {lo}}$, $a_{\text {hi}}$, display the value $a$ between $a_{\text {lo}}$ and $a_{\text {hi}}$ such that the number of possible ways to cut a parallelogram of area $a$ is maximized as well as the number of different ways $w$ in which such a parallelogram can be cut. If there are multiple possible values of $a$ display the smallest one.
## 样例

### 样例输入 #1
```
2
4 4
2 6

```
### 样例输出 #1
```
4 8
6 20

```
## 提示

Time limit: 11000 ms, Memory limit: 1048576 kB. 

 International Collegiate Programming Contest (ACM-ICPC) World Finals 2015
## 题目翻译

Youssef是一名专业贴瓷砖的修墙工，并且擅长用瓷砖贴出马赛克图案（如上图所示）。所有的瓷砖的尺寸长度均为整数，单位为$cm$。在马赛克图案中，平行四边形是不可或缺的。因此，Youssef会使用切割机，将矩形的瓷砖进行切割。在切割过程中，Youssef选择使用网格辅助切割机进行切割（在瓷砖上布上$cm$的网格方便切割）。

	切割过程有以下要求：
1.	可以从两个不同端点的连线切割（可以斜着切割）
2.	新平行四边形的四个角必须在矩形瓷砖的最外侧边上
3.	平行四边形的边不能与矩形的任意一条边边重叠

现在给出切割的面积的两个边界值$a_{lo}$和$a_{hi}$，求出Youssef能够最多切割掉的小矩形瓷砖数量。

**输入格式：**

给出测试样例数量$n$($1≤n≤500$)。下面$n$行给出切割面积的两个边界值$a_{lo}$和$a_{hi}$（$1≤a_{lo}≤a_{hi}≤500 000$）

**输出格式：**

每行先输出平行四边形面积$a$，再输出小矩形最多切割数量$w$。如果$a$有不同值的时候，输出最小的即可。


---

---
title: "[ICPC 2015 WF] Window Manager"
layout: "post"
diff: 省选/NOI-
pid: P6916
tag: ['2015', 'ICPC']
---
# [ICPC 2015 WF] Window Manager
## 题目描述

The past few years have seen a revolution in user interface technology. For many years, keyboards and mice were the tools used to interact with computers. But with the introduction of smart phones and tablets, people are increasingly using their computers by tapping and moving their fingers on the screen. Naturally this has led to new paradigms in user interface design. One important principle is that objects on the display obey “physical” laws. In this problem, you will see an example of this.

You have been hired to build a simulator for the window manager to be used in the next generation of smart phones from Advanced Cellular Manufacturers (ACM). Each phone they produce will have a rectangular screen that fully displays zero or more rectangular windows. That is, no window exceeds the boundaries of the screen or overlaps any other window. The simulator must support the following commands.

OPEN $x$ $y$ $w$ $h$ — open a new window with top-left corner coordinates $(x,y)$, width $w$ pixels and height $h$ pixels.

CLOSE $x$ $y$ — close an open window that includes the pixel at $(x,y)$. This allows a user to tap anywhere on a window to close it.

RESIZE $x$ $y$ $w$ $h$ — set the dimensions of the window that includes the pixel at $(x,y)$ to width $w$ and height $h$. The top-left corner of the window does not move.

MOVE $x$ $y$ $d_ x$ $d_ y$ — move the window that includes the pixel at $(x,y)$. The movement is either $d_ x$ pixels in the horizontal direction or $d_ y$ pixels in the vertical direction. At most one of $d_ x$ and $d_ y$ will be non-zero.

The OPEN and RESIZE commands succeed only if the resulting window does not overlap any other windows and does not extend beyond the screen boundaries. The MOVE command will move the window by as many of the requested pixels as possible. For example, if $d_ x$ is 30 but the window can move only 15 pixels to the right, then it will move 15 pixels.

![](https://cdn.luogu.com.cn/upload/image_hosting/3zw4uj2x.png)

   Figure 1: MOVE example 

ACM is particularly proud of the MOVE command. A window being moved might “bump into” another window. In this case, the first window will push the second window in the same direction as far as appropriate, exactly as if the windows were physical objects. This behavior can cascade – a moving window might encounter additional windows which are also pushed along as necessary. Figure 1 shows an example with three windows, where window A is moved to the right, pushing the other two along.
## 输入格式

The first line of input contains two positive integers $x_{\max }$ and $y_{\max }$, the horizontal and vertical dimensions of the screen, measured in pixels. Each is at most $10^9$ (ACM is planning on building displays with very high resolution). The top-left pixel of the screen has coordinates $(0,0)$. Each of the following lines contains a command as described above. One or more spaces separate the command name and the parameters from each other. The command parameters are integers that satisfy these conditions: $0 \leq x < x_{\max }$, $0 \leq y < y_{\max }$, $1 \leq w,h \leq 10^9$, and $|d_ x|,|d_ y| \leq 10^9$. There will be at most 256 commands.
## 输出格式

The output must follow the format illustrated in the sample output below.

Simulate the commands in the order they appear in the input. If any errors are detected during a command’s simulation, display the command number, command name, and the first appropriate message from the following list, and ignore the results of simulating that command (except as noted).

no window at given position — for the CLOSE, RESIZE, and MOVE commands — if there is no window that includes the pixel at the specified position.

window does not fit — for the OPEN and RESIZE commands — if the resulting window would overlap another window or extend beyond the screen boundaries.

moved $d’$ instead of $d$ — for the MOVE command — if the command asked to move a window $d$ pixels, but it could only move $d’$ pixels before requiring a window to move beyond the screen boundaries. The values $d$ and $d’$ are the absolute number of pixels requested and moved, respectively. The window is still moved in this case, but only for the smaller distance.

After all commands have been simulated and any error messages have been displayed, indicate the number of windows that are still open. Then for each open window, in the same order that they were opened, display the coordinates of the top-left corner $(x,y)$, the width, and the height.
## 样例

### 样例输入 #1
```
320 200
OPEN 50 50 10 10
OPEN 70 55 10 10
OPEN 90 50 10 10
RESIZE 55 55 40 40
RESIZE 55 55 15 15
MOVE 55 55 40 0
CLOSE 55 55
CLOSE 110 60
MOVE 95 55 0 -100

```
### 样例输出 #1
```
Command 4: RESIZE - window does not fit
Command 7: CLOSE - no window at given position
Command 9: MOVE - moved 50 instead of 100
2 window(s):
90 0 15 15
115 50 10 10

```
## 提示

Time limit: 1000 ms, Memory limit: 1048576 kB. 

 International Collegiate Programming Contest (ACM-ICPC) World Finals 2015
## 题目翻译

过去几年，用户界面技术发生了一场革命。多年来，键盘和鼠标一直是与计算机交互的工具。但随着智能手机和平板电脑的推出，人们越来越多地通过在屏幕上敲击和移动手指来使用电脑。这自然导致了用户界面设计的新范式。一个重要的原则是显示器上的对象遵守“物理”定律。在这个问题中，您将看到一个例子。

您已被聘请为window manager构建一个模拟器，用于高级手机制造商（ACM）的下一代智能手机。他们生产的每款手机都有一个矩形屏幕，可以完全显示零个或多个矩形窗口。也就是说，没有窗口超出屏幕边界或与任何其他窗口重叠。模拟器必须支持以下命令。

OPEN x y w h——打开一个具有左上角坐标（x，y）、宽度w像素和高度h像素的新窗口

CLOSE x y——关闭一个打开的窗口，其中包括（x，y）处的像素。这允许用户点击窗口上的任意位置以关闭窗口。

RESIZE x y w h——将包含（x，y）处像素的窗口尺寸设置为宽度w和高度h。窗口的左上角不移动。

MOVE x y dx dy——移动包含（x，y）处像素的窗口。移动是水平方向上的dx像素或垂直方向上的dy像素。dx和dy中最多有一个为非零。

![](https://cdn.luogu.com.cn/upload/image_hosting/3zw4uj2x.png)

图1：移动示例

ACM对MOVE命令特别自豪。正在移动的窗口可能会“撞上”另一个窗口。在这种情况下，第一个窗口将以相同的方向尽可能远地推动第二个窗口，就像这些窗口是物理对象一样。此行为可能会层叠–移动的窗口可能会遇到其他窗口，这些窗口也会根据需要被推送。图1显示了一个有三个窗口的示例，其中窗口A向右移动，推动其他两个窗口。

输入格式

第一行输入包含两个正整数x_max和y_max，即屏幕的水平和垂直尺寸，以像素为单位。每个显示器的最大分辨率为10^9（ACM正计划建造具有极高分辨率的显示器）。屏幕左上角的像素具有坐标（0,0）。下面的每一行都包含一个如上所述的命令。命令名和参数之间用一个或多个空格分隔。命令参数是满足这些条件的整数：0≤x<x_max，0≤y<y_max，1≤w，h≤10^9，|d_x|、|d_y|≤10^9。最多有256条命令。

输出格式

输出必须遵循以下示例输出中所示的格式。

按照命令在输入中出现的顺序模拟命令。如果在命令模拟过程中检测到任何错误，请显示命令编号、命令名称和下表中的第一条适当消息，并忽略模拟该命令的结果（除非另有说明）。

如果在指定位置没有包含像素的窗口，则在给定位置没有窗口（用于关闭、调整大小和移动命令）。

如果生成的窗口与另一个窗口重叠或超出屏幕边界，则窗口不适用于“打开”和“调整大小”命令。

如果命令要求移动窗口d个像素，则移动d'而不是d-对于MOVE命令，但在要求窗口移动到屏幕边界之外之前，它只能移动d'个像素。值d和d’分别是请求和移动的像素的绝对数量。在这种情况下，窗口仍会移动，但仅移动较小的距离。

模拟所有命令并显示任何错误消息后，指示仍打开的窗口数。然后，对于每个打开的窗口，按照打开的顺序显示左上角（x，y）的坐标、宽度和高度。

输入输出样例

输入 #1

320 200

OPEN 50 50 10 10

OPEN 70 55 10 10

OPEN 90 50 10 10

RESIZE 55 55 40 40

RESIZE 55 55 15 15

MOVE 55 55 40 0

CLOSE 55 55

CLOSE 110 60

MOVE 95 55 0 -100

输出 #1

Command 4: RESIZE - window does not fit

Command 7: CLOSE - no window at given position

Command 9: MOVE - moved 50 instead of 100

2 window(s):

90 0 15 15

115 50 10 10

说明/提示

时间限制：1000毫秒，内存限制：1048576 kB。

该题出自：2015年国际大学生编程大赛（ACM-ICPC）世界总决赛


---

---
title: "[ICPC 2016 WF] Branch Assignment"
layout: "post"
diff: 省选/NOI-
pid: P6918
tag: ['2016', 'ICPC']
---
# [ICPC 2016 WF] Branch Assignment
## 题目描述

The Innovative Consumer Products Company (ICPC) is planning to start a top-secret project. This project consists of $s$ subprojects. There will be $b \ge s$ branches of ICPC involved in this project and ICPC wants to assign each branch to one of the subprojects. In other words, the branches will form $s$ disjoint groups, with each group in charge of a subproject.

At the end of each month, each branch will send a message to every other branch in its group (a different message to each branch). ICPC has a particular protocol for its communications. Each branch $i$ has a secret key $k_ i$ known only to the branch and the ICPC headquarters. Assume branch $i$ wants to send a message to branch $j$. Branch $i$ encrypts its message with its key $k_ i$. A trusted courier picks up this message from this branch and delivers it to the ICPC headquarters. Headquarters decrypts the message with key $k_ i$ and re-encrypts it with key $k_ j$. The courier then delivers this newly encrypted message to branch $j$, which decrypts it with its own key $k_ j$. For security reasons, a courier can carry only one message at a time.

Given a road network and the locations of branches and the headquarters in this network, your task is to determine the minimum total distance that the couriers will need to travel to deliver all the end-of-month messages, over all possible assignments of branches to subprojects.
## 输入格式

The first line of input contains four integers $n$, $b$, $s$, and $r$, where $n$ ($2 \le n \le 5\, 000$) is the number of intersections, $b$ ($1 \le b \le n-1$) is the number of branches, $s$ ($1 \le s \le b$) is the number of subprojects, and $r$ ($1 \le r \le 50\, 000$) is the number of roads. The intersections are numbered from $1$ through $n$. The branches are at intersections $1$ through $b$, and the headquarters is at intersection $b + 1$. Each of the next $r$ lines contains three integers $u$, $v$, and $\ell $, indicating a one-way road from intersection $u$ to a different intersection $v$ ($1 \leq u,v \leq n$) of length $\ell $ ($0 \leq \ell \leq 10\, 000$). No ordered pair $(u,v)$ appears more than once, and from any intersection it is possible to reach every other intersection.
## 输出格式

Display the minimum total distance that the couriers will need to travel.
## 样例

### 样例输入 #1
```
5 4 2 10
5 2 1
2 5 1
3 5 5
4 5 0
1 5 1
2 3 1
3 2 5
2 4 5
2 1 1
3 4 2

```
### 样例输出 #1
```
13

```
### 样例输入 #2
```
5 4 2 10
5 2 1
2 5 1
3 5 5
4 5 10
1 5 1
2 3 1
3 2 5
2 4 5
2 1 1
3 4 2

```
### 样例输出 #2
```
24

```
## 提示

Time limit: 2000 ms, Memory limit: 1048576 kB. 

 International Collegiate Programming Contest (ACM-ICPC) World Finals 2016
## 题目翻译

题目描述

给定一个 $n$ 个点，$r$ 条边的有向强连通图，正整数 $s,b$ 满足 $1\le s\le b \le n-1$。第 $b+1$ 个点称为总部。点 $x$ 向点 $y$ 发送信息的代价是 $dis(x,b+1)+dis(b+1,y)$。  
现将点集 $\{1,2,\cdots,b\}$ 划分为 $s$ 个不相交的子集 $S_1,S_2,\cdots,S_s$。同一个子集内的点两两之间会互相发送信息。求最小化总代价。

数据范围

$2\le n \le 5000$，$1\le s\le b\le n-1$，$1\le r\le 50000$，边权非负且不大于 $10000$。


---

---
title: "[ICPC 2016 WF] Longest Rivers"
layout: "post"
diff: 省选/NOI-
pid: P6922
tag: ['2016', 'ICPC']
---
# [ICPC 2016 WF] Longest Rivers
## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/4ul9evsl.png)

The Chao Phraya River System is the main river system of Thailand. Its six longest rivers listed by decreasing length are:

Tha Chin ($765$ km)

Nan ($740$ km)

Yom ($700$ km)

Ping ($658$ km)

Pa Sak ($513$ km)

Wang ($335$ km)

A simplified model of this river system is shown in Figure 1, where the smaller red numbers indicate the lengths of various sections of each river. The point where two or more rivers meet as they flow downstream is called a confluence. Confluences are labeled with the larger black numbers. In this model, each river either ends at a confluence or flows into the sea, which is labeled with the special confluence number $0$. When two or more rivers meet at a confluence (other than confluence $0$), the resulting merged river takes the name of one of those rivers. For example, the Ping and the Wang meet at confluence $1$ with the resulting merged river retaining the name Ping. With this naming, the Ping has length $658$ km while the Wang is only $335$ km. If instead the merged river had been named Wang, then the length of the Wang would be $688$ km while the length of the Ping would be only $305$ km.

![](https://cdn.luogu.com.cn/upload/image_hosting/n8uvzv81.png)

   Figure 1: The river system in Sample Input 1. Same-colored edges indicate a river. 

The raised awareness of this phenomenon causes bitter rivalries among the towns along the rivers. For example, the townspeople along the Wang protest that maybe with a proper naming scheme, their river could actually be the longest, or maybe the second longest (or at least not last!). To end all the guessing, your task is to validate all such claims.

The rank of a river is its position in a list of all rivers ordered by decreasing length, where the best rank is $1$ for the longest river. For each river, determine its best possible rank over all naming schemes. At any confluence, the name of a new, larger river in any naming scheme must be one of the names of the smaller rivers which join at that confluence. If two or more rivers have equal lengths in a naming scheme, all the tied rivers are considered to have the best possible ranking. For example, if one river is the longest and all other rivers are equal, those rivers all have rank $2$.
## 输入格式

The first line of input contains two integers $n$ $(1 \le n \le 500\, 000)$, which is the number of river sources in the system, and $m$ $(0 \le m \le n - 1)$, which is the number of confluences with positive labels. These confluences are numbered from $1$ to $m$.

The next $n$ lines describe the rivers. Each of these lines consists of a string, which is the name of the river at the source, and two integers $c$ $(0 \leq c \leq m)$ and $d$ $(1 \leq d \leq 10^9)$, where $c$ is the identifier of the nearest confluence downstream, and $d$ is the distance from the source to that confluence in kilometers. River names use only lowercase and uppercase letters a–z, and consist of between $1$ and $10$ characters, inclusive.

The final $m$ lines describe confluences $1$ to $m$ in a similar fashion. The $k^\text {th}$ of these lines describes the confluence with identifier $k$ and contains two integers: the identifier of the nearest confluence downstream and the distance from confluence $k$ to this confluence in kilometers.

It is guaranteed that each confluence $1$ through $m$ appears as “the nearest downstream” at least twice, confluence $0$ appears at least once, and all sources are connected to confluence $0$.
## 输出格式

Display one river per line in the same order as in the input. On that line, display the name of the river and its best possible rank.
## 样例

### 样例输入 #1
```
6 2
PaSak 0 513
Nan 2 675
Yom 2 700
Wang 1 335
Ping 1 305
ThaChin 0 765
0 353
0 65

```
### 样例输出 #1
```
PaSak 5
Nan 2
Yom 1
Wang 3
Ping 4
ThaChin 1

```
## 提示

Time limit: 9000 ms, Memory limit: 1048576 kB. 

 International Collegiate Programming Contest (ACM-ICPC) World Finals 2016
## 题目翻译

有 $n$ 条河和 $m+1$ 个交汇处构成一棵以 $0$ 号点（即大海） 为根的树。

每条河有各自的名称。对于一个交汇处，从它流出的干流的名称是流入这个交汇处的各个支流的名称之一。一条河流的长度是以它为名称的河流的长度之和。对于一个可能的命名方案，一条河流的排名等于长度大于它的河流数 $+1$ 。

对于每条河，求出它在所有命名方案中，最小的排名。


---

---
title: "[ICPC 2016 WF] What Really Happened on Mars?"
layout: "post"
diff: 省选/NOI-
pid: P6928
tag: ['2016', 'ICPC']
---
# [ICPC 2016 WF] What Really Happened on Mars?
## 题目描述

Real-time software in the Mars Pathfinder spacecraft suffered from an issue known as priority inversion. One technique to address this issue is to use the Priority Ceiling Protocol.

In this problem, you will simulate the execution of multiple tasks according to this protocol. The tasks share a collection of resources, each of which can be used by only one task at a time. To ensure this, resources must be locked before use and unlocked after use. Each task is defined by a start time, a unique base priority, and a sequence of instructions. Each task also has a current priority, which may change during execution. Instructions come in three types:

compute – perform a computation for one microsecond

lock $k$ – lock resource $k$ (which takes no processor time)

unlock $k$ – unlock resource $k$ (which takes no processor time)

After locking a resource, a task is said to own the resource until the task unlocks it. A task will unlock only the owned resource it most recently locked, will not lock a resource it already owns, and will complete with no owned resources.

Each resource has a fixed priority ceiling, which is the highest base priority of any task that contains an instruction to lock that resource.

There is a single processor that executes the tasks. When the processor starts, it initializes its clock to zero and then runs an infinite loop with the following steps:

  Step 1.

Identify running tasks. A task is running if its start time is less than or equal to the current processor clock and not all of its instructions have been executed.

  Step 2.

Determine the current priorities of the running tasks and which of the running tasks are blocked. A running task $T$ is blocked if the next instruction in $T$ is to lock resource $k$ and either resource $k$ is already owned or at least one other task owns a resource $\ell $ whose priority ceiling is greater than or equal to the current priority of $T$. If $T$ is blocked, it is said to be blocked by every task owning such $k$ or $\ell $. The current priority of a task $T$ is the maximum of $T$’s base priority and the current priorities of all tasks that $T$ blocks.

  Step 3.

Execute the next instruction of the non-blocked running task (if any) with the highest current priority. If there was no such task or if a compute instruction was executed, increment the processor clock by one microsecond. If a lock or unlock instruction was executed, do not increment the clock.

The Priority Ceiling Protocol defined above has the following properties:

Current priority is defined in terms of current priority and blocking, and blocking is defined in terms of current priority. While this may appear circular, there will always be a unique set of current priorities that satisfy the definitions.

All tasks will eventually complete.

There will never be a tie in step 3.
## 输入格式

The first line of the input contains two integers $t$ $(1 \leq t \leq 20)$, which is the number of tasks, and $r$ ($1 \leq r \leq 20$), which is the number of resources. This is followed by $t$ lines, where the $i^\text {th}$ of these lines describes task $i$. The description of a task begins with three integers: the task’s start time $s$ ($1 \leq s \leq 10\, 000$), its base priority $b$ ($1 \leq b \leq t$), and an integer $a$ ($1 \leq a \leq 100$). A task description is concluded by a sequence of $a$ strings describing the instructions. Each string is a letter (C or L or U) followed by an integer. The string C$n$ ($1 \leq n \leq 100$) indicates a sequence of $n$ compute instructions. The strings L$k$ and U$k$ ($1 \leq k \leq r$) indicate instructions locking and unlocking resource $k$ respectively.

No two tasks have the same base priority.
## 输出格式

For each task, display the time it completes execution, in the same order that the tasks are given in the input.
## 样例

### 样例输入 #1
```
3 1
50 2 5 C1 L1 C1 U1 C1
1 1 5 C1 L1 C100 U1 C1
70 3 1 C1

```
### 样例输出 #1
```
106
107
71

```
### 样例输入 #2
```
3 3
5 3 5 C1 L1 C1 U1 C1
3 2 9 C1 L2 C1 L3 C1 U3 C1 U2 C1
1 1 9 C1 L3 C3 L2 C1 U2 C1 U3 C1

```
### 样例输出 #2
```
8
15
16

```
## 提示

Time limit: 1000 ms, Memory limit: 1048576 kB. 

 International Collegiate Programming Contest (ACM-ICPC) World Finals 2016
## 题目翻译

你有 $t$ 个进程和 $r$ 个资源，每个进程包含其起始时间与**基础优先级**（保证两两不同），以及若干条指令。指令有以下三种：

- `compute`：进行计算，消耗 $1$ 微秒。
- `lock k`：锁定编号为 $k$ 的资源，不耗时。
- `unlock k`：解锁编号为 $k$ 的资源，不耗时。

在进程锁定资源后，这个进程就拥有了这个资源直到这个进程将它解锁。保证任意进程只会解锁最近锁定的资源，不会锁定自身拥有的资源，且在进程结束时不会拥有任何资源。

每个资源有一个固定的属性**最高优先级**，即包含锁定该资源指令的所有进程的最高**基础优先级**。

有一个处理器处理这些进程。处理器有一个时钟初始为 $0$，然后重复执行下列步骤：

1. 找出所有正在运行的进程。如果进程开始的时间不大于处理器的时钟且该进程的指令未运行完毕，那么称这个进程正在运行。

2. 决定当前所有正在运行的进程的优先级，以及哪些正在运行的进程会被阻塞。进程 $T$ 会被阻塞当且仅当：

   - 进程 $T$ 的下一条指令是锁定资源 $k$。
   - 资源 $k$ 已经被其他进程拥有，或存在另一个进程拥有某个资源 $\ell$，$\ell$ 的**最高优先级**大于 $T$ 的**当前优先级**。

   此时我们称进程 $T$ 被所有拥有资源 $k$ 或满足条件的资源 $\ell$ 的进程阻塞。定义 $T$ 的**当前优先级**为所有阻塞它的进程的**当前优先级**与它本身的**基础优先级**的最大值。

3. 执行**当前优先级**最高且没有被阻塞的进程的下一条指令。如果不存在这样的进程或者执行的指令是 `compute`，则将时钟加 $1$ 微秒。

你需要求所有进程的结束时间。可以证明所有进程一定会结束。

输入格式：

第一行两个整数 $t,r$ 表示进程和资源个数。

接下来 $t$ 行每行描述一个进程，格式如下：

- 三个整数 $s,b,a$，表示进程起始时间、基础优先级、指令条数。
- 接下来 $a$ 个字符串，每个字符串表示一条指令。字符串形如 `Cn` 表示连续 $n$ 个 `compute` 指令（**相互独立**），`Lk` 表示锁定资源 $k$，`Rk` 表示解锁资源 `k`。

输出格式：

$t$ 行每行一个整数表示进程执行完毕的时间。

数据范围：$1 \le t,r \le 20,s \le 10^4,1 \le b \le t$ 且互不相同，$a \le 100$，`Cn` 中 $n \le 100$，`Lk,Rk` 中 $1 \le k \le r$。

Translated by pokefunc (uid=188716)


---

---
title: "[ICPC 2017 WF] Airport Construction"
layout: "post"
diff: 省选/NOI-
pid: P6929
tag: ['2017', 'Special Judge', 'ICPC']
---
# [ICPC 2017 WF] Airport Construction
## 题目描述



The tropical island nation of Piconesia is famous for its beautiful beaches, lush vegetation, cocoa and coffee plantations, and wonderful weather all year round. This paradise is being considered as a future location for the World Finals of the ACM International Collegiate Programming Contest (or at the very least a vacation spot for the executive council). There is only one small problem: the island is really hard to reach.

Currently, the fastest way to reach the island takes three days from the nearest airport, and uses a combination of fishing boat, oil tanker, kayak, and submarine. To make attending the ICPC World Finals slightly easier and to jump-start the island's tourism business, Piconesia is planning to build its first airport.

Since longer landing strips can accommodate larger airplanes, Piconesia has decided to build the longest possible landing strip on their island. Unfortunately, they have been unable to determine where this landing strip should be located. Maybe you can help?

For this problem we model the boundary of Piconesia as a polygon. Given this polygon, you need to compute the length of the longest landing strip (i.e., straight line segment) that can be built on the island. The landing strip must not intersect the sea, but it may touch or run along the boundary of the island. Figure A.1 shows an example corresponding to the first sample input.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14633/1.png)

Figure A.1 : The island modeled as a polygon. The longest possible landing strip is shown as a thick line.


## 输入格式



The input starts with a line containing an integer $n (3 \le n \le 200)$ specifying the number of vertices of the polygon. This is followed by $n$ lines, each containing two integers $x$ and $y (|x|, |y| \le 10^{6})$ that give the coordinates $(x , y)$ of the vertices of the polygon in counter-clockwise order. The polygon is simple, i.e., its vertices are distinct and no two edges of the polygon intersect or touch, except that consecutive edges touch at their common vertex. In addition, no two consecutive edges are collinear.


## 输出格式



Display the length of the longest straight line segment that fits inside the polygon, with an absolute or relative error of at most $10^{−6}.$


## 样例

### 样例输入 #1
```
7
0 20
40 0
40 20
70 50
50 70
30 50
0 50

```
### 样例输出 #1
```
76.157731059

```
### 样例输入 #2
```
3
0 2017
-2017 -2017
2017 0

```
### 样例输出 #2
```
4510.149110617

```
## 提示

Time limit: 2 s, Memory limit: 512 MB. 


## 题目翻译

给定一个 $n$ 边形，第 $i$ 个点为 $(x_i,y_i)$，并且保证顺时针给出。求一条在 $n$ 边形内的最长线段。

$3 \le n \le 200$，$|x|,|y| \le 10^6$。

翻译者：一只书虫仔


---

---
title: "[ICPC 2017 WF] Get a Clue!"
layout: "post"
diff: 省选/NOI-
pid: P6930
tag: ['2017', 'ICPC']
---
# [ICPC 2017 WF] Get a Clue!
## 题目描述



Developed in the $1940s$ in the United Kingdom, the game of Cluedo is one of the most popular board games in the world. The object of the game is to determine who murdered Mr. Body, which weapon was used to murder him, and where the murder took place. The game uses a set of cards representing six persons (labeled A , $B$ , . . . , $F)$ , six weapons (labeled $G , H$ , . . . , $L)$ and nine rooms (labeled $M , N$ , . . . , $U)$ . At the start of the game, one person card, one weapon card, and one room card are selected at random and removed from the deck so no one can see them $-$ they represent the murderer, the murder weapon, and the murder location. The remaining $18$ cards are shuffled and dealt to the players, starting with player $1$ , then to her right player $2$ , and so on. Some players may end up with one more card than others. For the purposes of this problem there are four players, so the person to the right of player $4$ is player $1$ .

The rest of the game is spent searching for clues. Players take turns, starting with player $1$ and moving to the right. A turn consists of making a suggestion (consisting of a murder suspect, a weapon, and a room) and asking other players if they have any evidence that refutes the suggestion. For example, you might say to another player `I believe the murderer was person A , using weapon $L$ , in room $T$ . $`$ If the other player is holding exactly one of these cards, that player must show you (and only you) that card. If they have more than one such card, they can show you any one of them.

When making a suggestion, you must first ask the person to your right for any evidence. If they have none, you continue with the person on their right, and so on, until someone has evidence, or no one has any of the cards in your suggestion.

Many times you can gain information even if you are not the person making the suggestion. Suppose, in the above example, you are the third player and have cards A and $T$ . If someone else shows evidence to the suggester, you know that it must be weapon card $L$ . Keeping track of suggestions and who gave evidence at each turn is an important strategy when playing the game.

To win the game, you must make an accusation, where you state your final guess of the murderer, weapon, and room. After stating your accusation, you check the three cards that were set aside at the start of the game $-$ if they match your accusation, you win! Needless to say, you want to be absolutely sure of your accusation before you make it.

Here is your problem. You are player $1$ . Given a set of cards dealt to you and a history of suggestions and evidence, you need to decide how close you are to being able to make an accusation.


## 输入格式



The input starts with an integer $n (1 \le n \le 50)$ , the number of suggestions made during the game. Following this is a line containing the five cards you are dealt, all uppercase letters in the range $‘A'.$ . . $‘U'.$ The remaining $n$ lines contain one suggestion per line. Each of these lines starts with three characters representing the suggestion (in the order person, weapon, room), followed by the responses of up to three players, beginning with the player to the right of the player making the suggestion. If a player presents no evidence, a $‘-'$ (dash) is listed; otherwise an `evidence character` is listed. If the specific evidence card is seen by you (either because you provided it or you were the person receiving the evidence) then the evidence $character identifies$ that card; otherwise the evidence character is $‘ \times '.$ Note that only the last response can be an evidence character. All characters are separated by single spaces. Only valid $suggestio_n/response$ sequences appear in the input.


## 输出格式



Display a three character string identifying the murderer, the murder weapon, and the room. If the murderer can be identified, use the appropriate letter for that person; otherwise use $‘?'.$ Do the same for the murder weapon and the room.


## 样例

### 样例输入 #1
```
1
B I P C F
A G M - - -

```
### 样例输出 #1
```
AGM

```
### 样例输入 #2
```
2
A B C D H
F G M M
F H M - *

```
### 样例输出 #2
```
E??

```
### 样例输入 #3
```
3
A C M S D
B G S - G
A H S - - S
C J S *

```
### 样例输出 #3
```
???

```
## 提示

Time limit: 4 s, Memory limit: 512 MB. 


## 题目翻译

翻译者吐槽：这个 Cluedo 不就是弹丸论破的学级裁判嘛（

---

Cluedo 是一个盛行的游戏，游戏目的是找出一场谋杀案的凶手。这个游戏是一个卡牌游戏，一共有 $21$ 张卡牌，分类为：A $\sim $ F 是嫌疑人卡牌，G $\sim $ L 是凶器卡牌，M $\sim $ U 是犯罪现场卡牌，在游戏的开始，会在三种卡牌中分别抽出一张，代表真正的凶手，凶器和犯罪现场。

今天，你和你的 $3$ 个小伙伴也来玩 Cluedo 了，你们坐成一个环，你是玩家 $1$，你的小伙伴分别为玩家 $2,3,4$，按照 $1 \to 2 \to 3 \to 4 \to 1 \to 2 \cdots$ 的顺序进行游戏。每一次会从剩下的卡堆中抽出任意一张卡给玩家，直到分完为止。

分完牌后，从玩家 $1$ 开始，还是按照环的顺序，依次提出意见，格式示例为「我认为嫌疑人 A 是凶手，凶器为 L，作案现场是 T」，然后从这个玩家的右手位开始提反对意见，如果要提反对意见的玩家手里有表明意见的玩家要说的牌（因为凶手，凶器和犯罪现场都已经拿出了，所以所有玩家手里都应该没有真正的牌，有的话说明意见错误），那么他就可以成功的提反对意见。如果他不提反对意见，那么反对意见权交给他的右手位，直到有人提出或者没有反对意见。注意，如果 A 对 B 提出反对意见，那么他进行反对的那一张卡牌只有 A 和 B 能看到。

你作为类似于学级裁判中的主侦探一位，你要说明最终意见，即你对凶手，凶器和犯罪现场的最终猜测。在进行猜测后，如果你的猜测与正确结果符合，那么你就赢了。因为你有脑子，所以你只会在得到准确证据后才会进行最终猜测。

现在给定意见数 $n$，你手中的初始卡牌，以及每一次意见，求你能推理出的最终猜测。如果你无法得到完整的最终猜测，请把你尚未得到结论的地方用 $\texttt ?$ 输出。

备注：意见如下描述：

- 首先三个字符代表这个意见所提出的凶手，凶器和犯罪现场。
- 接下来一个或两个或三个字符代表反对意见情况，从他的右手位开始表示，如果这个玩家没有反对意见，那么 $\texttt -$，如果这个玩家有反对意见，且你是提出意见的人或者是进行反对的人，那么输出反驳的是哪张卡牌。如果你不是提出意见的人或者进行反对的人，那么输出 $\texttt *$。当输出了反驳情况时，就可以换行进行下一个意见的反对意见判断了。否则，一直进行到三名玩家的反对意见都判断完。

$1 \le n \le 50$。

翻译者：一只书虫仔


---

---
title: "[ICPC 2017 WF] Mission Improbable"
layout: "post"
diff: 省选/NOI-
pid: P6931
tag: ['2017', 'ICPC']
---
# [ICPC 2017 WF] Mission Improbable
## 题目描述



It is a sunny day in spring and you are about to meet Patrick, a close friend and former partner in crime. Patrick lost most of his money betting on programming contests, so he needs to pull off another job. For this he needs your help, even though you have retired from a life of crime. You are reluctant at first, as you have no desire to return to your old criminal ways, but you figure there is no harm in listening to his plan.

There is a shipment of expensive consumer widgets in a nearby warehouse and Patrick intends to steal as much of it as he can. This entails finding a way into the building, incapacitating security guards, passing through various arrays of laser beams $-$ you know, the usual heist techniques. However, the heart of the warehouse has been equipped with a security system that Patrick cannot disable. This is where he needs your help.

The shipment is stored in large cubical crates, all of which have the same dimensions. The crates are stacked in neat piles, forming a three-dimensional grid. The security system takes pictures of the piles once per hour using three cameras: a front camera, a side camera and a top camera. The image from the front camera shows the height of the tallest pile in each column, the image from the side camera shows the height of the tallest pile in each row, and the image from the top camera shows whether or not each pile is empty. If the security system detects a change in any of the images, it sounds an alarm.

Once Patrick is inside, he will determine the heights of the piles and send them to you. Figure C.1 shows a possible layout of the grid and the view from each of the cameras.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14635/1.png)

Figure C.1 : Grid of heights and the corresponding camera views.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14635/2.png)

Figure C.2 : Possible grid of heights after the heist

Patrick wants to steal as many crates as possible. Since he cannot disable the security system, he plans to fool it by arranging the remaining crates into piles so that the next set of camera images are the same. In the above example, it is possible to steal nine crates. Figure C.2 shows one possible post-heist configuration that appears identical to the security system.

Patrick asks you to help him determine the maximum number of crates that can be stolen while leaving a configuration of crates that will fool the security system. Will you help him pull off this final job?


## 输入格式



The first line of input contains two integers $r (1 \le r \le 100)$ and $c (1 \le c \le 100)$ , the number of rows and columns in the grid, respectively. Each of the following $r$ lines contains $c$ integers, the heights (in crates) of the piles in the corresponding row. All heights are between $0$ and $10^{9}$ inclusive.


## 输出格式



Display the maximum number of crates that can be stolen without being detected.


## 样例

### 样例输入 #1
```
5 5
1 4 0 5 2
2 1 2 0 1
0 2 3 4 4
0 3 0 3 1
1 2 2 1 1

```
### 样例输出 #1
```
9

```
### 样例输入 #2
```
2 3
50 20 3
20 10 3

```
### 样例输出 #2
```
30

```
## 提示

Time limit: 1 s, Memory limit: 512 MB. 


## 题目翻译

给定一个 $r \times c$ 的平面，在上面摆有一些箱子。我们可以得到他的三视图（如下图，左边矩阵上的值为平面上每一位摆放的箱子个数，右边三个视图为正视图，俯视图，左视图）：

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14635/1.png)

你可以拿走一些箱子，和重新排列这些箱子的位置，你想知道，最多能拿走多少个箱子，使得这些箱子重新排列后正视图，俯视图，左视图不变？

比如上面这个例子，下面这种拿走 $9$ 个箱子后的重新排列方式也是可以的：

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14635/2.png)

$1 \le r,c \le 100$，平面上每一个位置的箱子个数在 $[0,10^9]$ 内。

翻译者：一只书虫仔


---

---
title: "[ICPC 2017 WF] Money for Nothing"
layout: "post"
diff: 省选/NOI-
pid: P6932
tag: ['2017', 'ICPC']
---
# [ICPC 2017 WF] Money for Nothing
## 题目描述



In this problem you will be solving one of the most profound challenges of humans across the world since the beginning of time $-$ how to make lots of money.

You are a middleman in the widget market. Your job is to buy widgets from widget producer companies and sell them to widget consumer companies. Each widget consumer company has an open request for one widget per day, until some end date, and a price at which it is willing to buy the widgets. On the other hand, each widget producer company has a start date at which it can start delivering widgets and a price at which it will deliver each widget.

Due to fair competition laws, you can sign a contract with only one producer company and only one consumer company. You will buy widgets from the producer company, one per day, starting on the day it can start delivering, and ending on the date specified by the consumer company. On each of those days you earn the difference between the producer's selling price and the consumer's buying price.

Your goal is to choose the consumer company and the producer company that will maximize your profits.


## 输入格式



The first line of input contains two integers $m$ and $n (1 \le m , n \le 500 000)$ denoting the number of producer and consumer companies in the market, respectively. It is followed by $m$ lines, the $i$ th of which contains two integers $p_{i}$ and $d_{i} (1 \le p_{i}, d_{i} \le 10^{9}),$ the price (in dollars) at which the $i$ th producer sells one widget and the day on which the first widget will be available from this company. Then follow $n$ lines, the $j$ th of which contains two integers $q_{j}$ and $e_{j} (1 \le q_{j}, e_{j} \le 10^{9}),$ the price (in dollars) at which the $j$ th consumer is willing to buy widgets and the day immediately after the day on which the last widget has to be delivered to this company.


## 输出格式



Display the maximum total number of dollars you can earn. If there is no way to sign contracts that gives you any profit, display $0$ .


## 样例

### 样例输入 #1
```
2 2
1 3
2 1
3 5
7 2

```
### 样例输出 #1
```
5

```
### 样例输入 #2
```
1 2
10 10
9 11
11 9

```
### 样例输出 #2
```
0

```
## 提示

Time limit: 5 s, Memory limit: 512 MB. 


## 题目翻译

一共有 $m$ 个生产商和 $n$ 个消费商。第 $i$ 个生产商从第 $d_i$ 个时刻开始销售物品，每个物品卖 $p_i$ 元。第 $i$ 个消费商从第 $1$ 个时刻开始需要消费，他的消费欲望一直到第 $e_i-1$ 的时刻，每个物品出价 $q_i$ 元。你作为中间商，只能与一间生产商和一间消费商签订合约，可以选择在生产商那里买下一些物品，也可以选择卖向消费商，你的目的就是赚中间的差价。

你想知道最多能赚到多少差价。

$1 \le m,n \le 5\times 10^5$，$1 \le p_i,d_i,q_i,e_i \le 10^9$。

翻译者：一只书虫仔


---

---
title: "[ICPC 2017 WF] Replicate Replicate Rfplicbte"
layout: "post"
diff: 省选/NOI-
pid: P6935
tag: ['2017', 'Special Judge', 'ICPC']
---
# [ICPC 2017 WF] Replicate Replicate Rfplicbte
## 题目描述



The owner of the Automatic Cellular Manufacturing corporation has just patented a new process for the mass production of identical parts. Her approach uses a two-dimensional lattice of two-state cells, each of which is either `empty` or `filled. ` The exact details are, of course, proprietary.

Initially, a set of cells in the lattice is filled with a copy of the part that is to be reproduced. In a sequence of discrete steps, each cell in the lattice simultaneously updates its state by examining its own state and those of its eight surrounding neighbors. If an odd number of these nine cells are filled, the cell's state in the next time step will be filled, otherwise it will be empty. Figure G.1 shows several steps in the replication process for a simple pattern consisting of three filled cells.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14639/1.png)

Figure G.1 : The replication process.

However, a bug has crept into the process. After each update step, one cell in the lattice might spontaneously flip its state. For instance, Figure G.2 shows what might happen if a cell flipped its state after the first time step and another flipped its state after the third time step.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/14639/2.png)

Figure G.2 : Errors in the replication process. This figure corresponds to Sample Input $1$ .

Unfortunately, the original patterns were lost, and only the (possibly corrupted) results of the replication remain. Can you write a program to determine a smallest possible nonempty initial pattern that could have resulted in a given final pattern?


## 输入格式



The first line of input contains two integers $w (1 \le w \le 300)$ and $h (1 \le h \le 300)$ , where $w$ and $h$ are the width and height of the bounding box of the final pattern. Following that are $h$ lines, each containing $w$ characters, giving the final pattern. Each character is either $‘. '$ (representing an empty cell) or $‘#'$ (representing a filled cell). There is at least one filled cell in the first row, in the last row, in the first column, and in the last column.


## 输出格式



Display a minimum-size nonempty pattern that could have resulted in the given pattern, assuming that at each stage of the replication process at most one cell spontaneously changed state. The size of a pattern is the area of its bounding box. If there is more than one possible minimum-size nonempty starting pattern, any one will be accepted. Use the character $‘. '$ for empty cells and $‘#'$ for filled cells. Use the minimum number of rows and columns needed to display the pattern.


## 样例

### 样例输入 #1
```
10 10
.#...#...#
##..##..##
##.#.##...
##.#.##...
.#...#####
...##..#.#
......###.
##.#.##...
#..#..#..#
##..##..##

```
### 样例输出 #1
```
.#
##

```
### 样例输入 #2
```
8 8
##..#.##
#.####.#
.#.#.#..
.##.#.##
.#.#.#..
.##.#.##
#..#.###
##.#.##.

```
### 样例输出 #2
```
####
#..#
#.##
###.

```
### 样例输入 #3
```
5 4
#....
..###
..###
..###

```
### 样例输出 #3
```
#

```
## 提示

Time limit: 3 s, Memory limit: 512 MB. 


## 题目翻译

定义一个黑白复制过程，每一次枚举所有格子初始时自身和周围 $8$ 个格子这 $9$ 个格子的黑白情况，如果有奇数个位置为黑，那么这个格子变为黑，否则变为白。但不幸的是，复制过程有 bug，每一次进行复制后，都会有任意一个格子从黑变为白，或者从白变为黑，当然也可以不变。现在给定一份包含 bug 的复制最终结果，包含 $w$ 行 $h$ 列，求行列数最小的初始黑白格子，使得能通过复制过程和 bug 变为最终结果。

$\texttt \#$ 为黑，$\texttt .$ 为白。

注意，如果有多余的白色格子请省掉，比如左边这个黑白格子情况可以变为右边的：

```
...........   .....##..#
......##..#   #........#
.#........#   #..#...#..
.#..#...#..   .#.......#
..#.......#
...........
...........
```

$1 \le w,h \le 300$。

翻译者：一只书虫仔


---

---
title: "[ICPC 2017 WF] Tarot Sham Boast"
layout: "post"
diff: 省选/NOI-
pid: P6939
tag: ['2017', 'ICPC']
---
# [ICPC 2017 WF] Tarot Sham Boast
## 题目描述



Curse your rival! Every year at the annual Rock Paper Scissors tournament, you have made it to the final match. (Your Rock technique is unmatched, and your Paper cuts to the bone! Your Scissors need a little work, though. ) But every year, he defeats you, even though his moves appear entirely random! And he claims to the press that he simply cannot be beaten. What is his secret?

Fortunately, you think you have figured it out. This year, just before the tournament, you caught him visiting various shamans around town. Aha! He is using the supernatural against you! You figured two can play at this game. So you went and visited a set of fortune-tellers, who have each used a Tarot deck to predict a sequence that your rival will end up using, sometime during the match.

However, your initial excitement has passed, and now you are feeling a little silly. This cannot possibly work, right? In the end it feels like you have paid good money for a fraudulent, random set of predictions. Oh well; you might as well keep an eye out for some of them during the match. But which predictions will you use?

In the final match, you and your rival will play $n$ rounds of Rock Paper Scissors. In each round, your rival and you will both choose one of the three options (Rock, Paper, or Scissors). Based on your selections, a winner of the round will be determined (exactly how is irrelevant to this problem).

Given the length of the final match and the various predictions, sort them in order of how likely they are to appear sometime during the match as a contiguous sequence of options chosen by your rival, assuming he is choosing his symbol in each round independently and uniformly at random.


## 输入格式



The first line of input contains two integers $n (1 \le n \le 10^{6}),$ the number of rounds in the final match, and $s (1 \le s \le 10)$ , the number of sequences. The remaining $s$ lines each describe a prediction, consisting of a string of characters $‘R', ‘P',$ and $‘S'.$ All predictions have the same length, which is between $1$ and $n$ characters long, inclusive, and no longer than $10^{5}.$


## 输出格式



Display all of the predictions, sorted by decreasing likelihood of appearance sometime during the final match. In the case of tied predictions, display them in the same order as in the input.


## 样例

### 样例输入 #1
```
3 4
PP
RR
PS
SS

```
### 样例输出 #1
```
PS
PP
RR
SS

```
### 样例输入 #2
```
20 3
PRSPS
SSSSS
PPSPP

```
### 样例输出 #2
```
PRSPS
PPSPP
SSSSS

```
## 提示

Time limit: 2 s, Memory limit: 512 MB. 


## 题目翻译

定义某字符串  $s$ 的出现概率为：随机敲  $n$ 个 `R,P,S`， $s$ 作为其子串出现的概率。

给出  $s$ 个长度为  $l$ 的只含 `R,P,S` 的字符串，请你按这  $l$ 个字符串的出现概率从大到小排序。若概率相等则按输入顺序排序。

 $n\le 10^6,s\le 10,l\le 10^5$。


---

---
title: "[ICPC 2018 WF] Gem Island"
layout: "post"
diff: 省选/NOI-
pid: P6944
tag: ['2018', 'Special Judge', 'ICPC']
---
# [ICPC 2018 WF] Gem Island
## 题目描述



Gem Island is a tiny island in the middle of the Pacific Ocean. Until recently, it was known as one of the poorest, but also most peaceful, places on Earth. Today, it is neither poor nor peaceful. What happened?

One sunny morning, not too long ago, all inhabitants of Gem Island woke up to a surprise. That morning, each of them suddenly held one sparkling gem in their hand. The gems had magically appeared overnight. This was cause for much rejoicing $-$ everybody was suddenly rich, they could finally afford all the things they had ever dreamed of, and the name of their island made so much more sense now.

The next morning, one of the inhabitants woke up to another surprise $-$ her gem had magically split into two gems! The same thing happened on each of the following nights, when exactly one of the gems (apparently uniformly at random among all the gems on the island) would split into two.

After a while, the inhabitants of Gem Island possessed a widely varying number of gems. Some had a lot and many had only a few. How come some inhabitants had more gems than others? Did they cheat, were they just lucky, or was something else at work?

The island elders have asked for your help. They want you to determine if the uneven distribution of gems is explained by pure chance. If so, that would greatly reduce tensions on the island.

The island has $n$ inhabitants. You are to determine the gem distribution after $d$ nights of gem splitting. In particular, you are interested in the expected number of gems collectively held by the $r$ people with the largest numbers of gems. More formally, suppose that after $d$ nights the numbers of gems held by the $n$ inhabitants are listed in non-increasing order as $a_{1} \ge a_{2} \ge $ . . . $ \ge a_{n}.$ What is the expected value of $a_{1} + · · · + a_{r}?$


## 输入格式



The input consists of a single line containing the three integers $n , d$ , and $r (1 \le n , d \le 500 , 1 \le r \le n)$ , as described in the problem statement above.


## 输出格式



Display the expected number of gems that the top $r$ inhabitants hold after $d$ nights, with an absolute or relative error of at most $10^{−6}.$


## 样例

### 样例输入 #1
```
2 3 1

```
### 样例输出 #1
```
3.5

```
### 样例输入 #2
```
3 3 2

```
### 样例输出 #2
```
4.9

```
### 样例输入 #3
```
5 10 3

```
### 样例输出 #3
```
12.2567433

```
## 提示

Time limit: 3 s, Memory limit: 1024 MB. 


## 题目翻译

有 $n$ 个人，最开始每个人手中有 $1$ 颗绿宝石，每天晚上，会随机选一个绿宝石分裂为两个。

求 $d$ 个晚上后绿宝石数量最多的 $r$ 个人的绿宝石数和的期望值。

$1 \le n,d \le 500$，$1 \le r\le n$。

翻译者：一只书虫仔


---

---
title: "[ICPC 2018 WF] Getting a Jump on Crime"
layout: "post"
diff: 省选/NOI-
pid: P6945
tag: ['2018', 'ICPC']
---
# [ICPC 2018 WF] Getting a Jump on Crime
## 题目描述



Your friend Robin is a superhero. When you first found out about this, you figured `everybody needs a hobby, and this seems more exciting than stamp collecting,` but now you are really thankful that somebody is doing something about the crime in your hometown.

Every night, Robin patrols the city by jumping from roof to roof and watching what goes on below. Naturally, superheroes need to respond to crises immediately, so Robin asked you for help in figuring out how to get around your hometown quickly.

Your hometown is built on a square grid, where each block is $w \times w$ meters. Each block is filled by a single building. The buildings may have different heights (see Figure E.1) . To get from one building to another (not necessarily adjacent) building, Robin makes a single jump from the center of the roof of the first building to the center of the roof of the second building. Robin cannot change direction while in the air, but can choose the angle at which to lift off.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15693/1.png)

Figure E.1 : Cross-section of buildings corresponding to the first sample input. Buildings are shown in black, and the jump from the roof at $(1 , 1)$ to the roof at $(4 , 1)$ is shown with a green line.

Of course, Robin only wants to perform jumps without colliding with any buildings. Such collisions do little damage to a superhero, but building owners tend to get irritated when someone crashes through their windows. You explain the physics to Robin: `All your jumps are done with the same initial velocity $v$ , which has a horizontal component $v_{d}$ towards the destination and vertical component $v_{h}$ upwards, so $v_{d}^{2} + v_{h}^{2} = v^{2}$ . As you travel, your horizontal velocity stays constant $(v_{d}(t) = v_{d}),$ but your vertical velocity is affected by gravity $(v_{h}(t) = v_{h} − t · g)$ , where $g = 9$ . $80665 m/s^{2}$ in your hometown. Naturally, your cape allows you to ignore the effects of air resistance. This allows you to determine your flight path and $ \cdots `$ at which point you notice that Robin has nodded off $-$ less math, more super-heroing!

So it falls to you: given a layout of the city and the location of Robin's secret hideout, you need to determine which building roofs Robin can reach, and the minimum number of jumps it takes to get to each roof.

Note that if Robin's jump passes over the corner of a building (where four buildings meet), then the jump needs to be higher than all four adjacent buildings.

$ $


## 输入格式



The input starts with a line containing six integers $d_{x}, d_{y}, w , v , ℓ_{x}, ℓ_{y}.$ These represent the size $d_{x} \times d_{y}$ of the city grid $(1 \le d_{x}, d_{y} \le 20)$ in blocks, the width of each building $(1 \le w \le 10^{3})$ in meters, Robin's takeoff velocity $(1 \le v \le 10^{3})$ in meters per second, and the coordinates $(ℓ_{x}, ℓ_{y})$ of Robin's secret hideout $(1 \le ℓ_{x} \le d_{x}, 1 \le ℓ_{y} \le d_{y}).$

The first line is followed by a description of the heights of the buildings in the city grid. The description consists of $d_{y}$ lines, each containing $d_{x}$ non-negative integers. The $j^{th}$ line contains the heights for buildings $(1 , j),(2 , j)$ , . . . $,(d_{x}, j)$ . All heights are given in meters and are at most $10^{3}.$


## 输出格式



Display the minimum number of jumps Robin needs to get from the secret hideout to the roof of each building. If there is no way to reach a building's roof, display $X$ instead of the number of jumps. Display the buildings in the same order as given in the input file, split into $d_{y}$ lines, each containing $d_{x}$ values.

You may assume that changing the height of any building by up to $10^{−6}$ would not change the answers.


## 样例

### 样例输入 #1
```
4 1 100 55 1 1
10 40 60 10

```
### 样例输出 #1
```
0 1 1 1

```
### 样例输入 #2
```
4 4 100 55 1 1
0 10 20 30
10 20 30 40
20 30 200 50
30 40 50 60

```
### 样例输出 #2
```
0 1 1 2
1 1 1 2
1 1 X 2
2 2 2 3

```
## 提示

Time limit: 2 s, Memory limit: 1024 MB. 


## 题目翻译

## 题目描述
你的朋友罗宾（Robin）是一位超级英雄。当你第一次发现这个事时，你认为“每个人都需要有爱好，这个看起来比收集邮票有意思多了”，但是现在你十分感谢那些在你的家乡胡作非为的人。

每个晚上， 罗宾（Robin）用在房顶上跳跃的方式巡逻整座城市，并且看下面发生了什么。自然，超级英雄需要立即应对危机，所以罗宾（Robin）寻求你的帮助，帮他找出如何迅速走遍你的家乡。

你的家乡建立在一个方形的格子上，其中每个区块有 $w\times w$ 米。每个区块是一个独立的建筑，建筑有可能有不同的高度,为了从一个建筑到另一个（不一定相邻的）建筑，罗宾（Robin）从第一个房屋屋顶的中间跳到第二个房屋屋顶的中间。不能在空中改变方向，但可以选择起飞的角度。

当然，罗宾（Robin）不想撞到任何一个建筑。一些碰撞很难对超级英雄造成伤害，但是当有人击穿房屋主人的窗户时，他们容易感到生气。你向罗宾（Robin）解释物理学：“你的每次跳都有一个初速度$v$，可以被分解成一个向前的水平分力$v_d$和一个向上的竖直分力$v_h$，且$v_{d}^{2} + v_{h}^{2} = v^{2}$.当你行动时，你的水平分力保持不变$(v_{dt} = v_{d}),$，但是竖直分力受到重力的影响$(v_{h}(t) = v_{h} − t · g)$，设在你的家乡重力加速度$g=9.80665$。自然，你的斗篷可以让你忽略空气阻力的影响。这可以让你确定你的飞行路线和……”这是你注意到罗宾（Robin）已经睡着了-少一点数学，多一点超级英雄！

所以现在轮到你了：已经给出城市的布局和罗宾（Robin）秘密藏身处的位置，你需要确定罗宾（Robin）能到达哪些屋顶并给出最少跳跃次数。

请注意，如果罗宾（Robin）的跳跃经过一栋建筑的角落（四栋建筑交汇的地方），那么跳跃需要比所有四栋相邻建筑都高。

## 输入格式
输入的第一行包含六个整数$d_x$,$d_y$,$w$,$v$,$l_x$,$l_x$.这些代表了 $d_x\times d_y$ 的城市面积（单位：区块）$(1 \le d_{x}, d_{y} \le 20)$，每座建筑的宽度$(1 \le w \le 10^{3})$，罗宾（Robin）的起跳速度$(1 \le v \le 10^{3})$（单位：米每秒），和罗宾（Robin）藏身处的坐标$(1 \le ℓ_{x} \le d_{x}, 1 \le ℓ_{y} \le d_{y}).$。

第一行后面是对城市网格中建筑高度的描述。描述由$d_y$行组成，每个行包含$d_{x}$个非负整数。第j行包含建筑物$(1 , j),(2 , j)$ , . . . $,(d_{x}, j)$ 的高度（单位：米）。高度最高不超过$10^3$米。

## 输出格式
输出罗宾从秘密藏身处跳到每栋建筑屋顶所需的最小跳跃次数。如果无法到达建筑物的屋顶，则显示$X$而不是跳跃次数。按输入文件中给定的顺序显示建筑，分为$d_{y}$行，每行包含$d_{x}$个值。


---

---
title: "[ICPC 2018 WF] Triangles"
layout: "post"
diff: 省选/NOI-
pid: P6949
tag: ['2018', 'ICPC']
---
# [ICPC 2018 WF] Triangles
## 题目描述



For your trip to Beijing, you have brought plenty of puzzle books, many of them containing challenges like the following: how many triangles can be found in Figure I.1 ?

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15697/1.png)

Figure I.1 : Illustration of Sample Input $2$ .

While these puzzles keep your interest for a while, you quickly get bored with them and instead start thinking about how you might solve them algorithmically. Who knows, maybe a problem like that will actually be used in this year's contest. Well, guess what? Today is your lucky day!


## 输入格式



The first line of input contains two integers $r$ and $c (1 \le r \le 3 000 , 1 \le c \le 6 000)$ , specifying the picture size, where $r$ is the number of rows of vertices and $c$ is the number of columns. Following this are 2r $− 1$ lines, each of them having at most 2c $− 1$ characters. Odd lines contain grid vertices (represented as lowercase $x$ characters) and zero or more horizontal edges, while even lines contain zero or more diagonal edges. Specifically, picture lines with numbers 4k $+ 1$ have vertices in positions $1 , 5 , 9 , 13$ , . . . while lines with numbers 4k $+ 3$ have vertices in positions $3 , 7 , 11 , 15$ , . . . . All possible vertices are represented in the input (for example, see how Figure I.1 is represented in Sample Input $2$) . Horizontal edges connecting neighboring vertices are represented by three dashes. Diagonal edges are represented by a single forward slash $(‘/')$ or backslash $(‘\')$ character. The edge characters will be placed exactly between the corresponding vertices. All other characters will be space characters. Note that if any input line could contain trailing whitespace, that whitespace may be omitted.


## 输出格式



Display the number of triangles (of any size) formed by grid edges in the input picture.


## 样例

### 样例输入 #1
```
3 3
x---x
 \ /
  x
 / \
x   x

```
### 样例输出 #1
```
1

```
### 样例输入 #2
```
4 10
x   x---x---x   x
     \ /   / \
  x   x---x   x   x
     / \ / \   \
x   x---x---x---x
   /   / \   \ / \
  x---x---x---x---x

```
### 样例输出 #2
```
12

```
## 提示

Time limit: 6 s, Memory limit: 1024 MB. 


## 题目翻译

**简要题意：** 输入 $r$ 行顶点，每行有 $c$ 列，顶点用 $x$ 表示，每个顶点用水平边（`-`）和对角边（用 `/` 和 `\` 表示）**精确连接**。总共 $2 r - 1$ 行，每行最多有 $2 c - 1$ 个字符，除上述字符外均为空白字符；行末可能存在可忽略的空格。你需要输出所输入的图中由网格边构成了多少个三角形（无论大小）。配图为样例 $2$。

对于所有数据，$1 \le r \le 3000$，$1 \le c \le 6000$。


---

---
title: "[NEERC 2017] Archery Tournament"
layout: "post"
diff: 省选/NOI-
pid: P6952
tag: ['2017', 'ICPC']
---
# [NEERC 2017] Archery Tournament
## 题目描述



You were invited to the annual archery tournament. You are going to compete against the best archers from all of the Northern Eurasia. This year, a new type of competition is introduced, where a shooting range is dynamic and new targets might appear at any second.

As the shooting range is far enough from you, it can be represented as a 2D plane, where $y = 0$ is the ground level. There are some targets in a shape of a circle, and all the targets are standing on the ground. That means, if a target's center is $(x , y) (y > 0)$ , then its radius is equal to $y$ , so that it touches the line $y = 0$ . No two targets simultaneously present at the range at any given time intersect (but they may touch).

Initially, the shooting range is empty. Your participation in this competition can be described as $n$ events: either a new target appears at the range, or you shoot an arrow at some point at the range. To hit a target, you must shoot strictly inside the circle (hitting the border does not count). If you shoot and hit some target, then the target is removed from the range and you are awarded one point.


## 输入格式



The first line of the input contains integer $n (1 \le n \le 2·10^{5}).$ Next $n$ lines describe the events happening at the tournament. The i-th line contains three integers $t_{i}, x_{i},$ and $y_{i} (t_{i} = 1 , 2$ ; $−10^{9} \le x_{i}, y_{i} \le 10^{9}$ ; $y_{i} > 0)$ .

If $t_{i} = 1$ , then a new target with center $(x_{i}, y_{i})$ and radius $y_{i}$ appears at the range.

If $t_{i} = 2$ , then you perform a shot, which hits the range at $(x_{i}, y_{i}).$


## 输出格式



For each of your shots, output a separate line with the single integer. If the shot did not hit any target, print `-1`. If the shot hit a target, print the number of event when that target was added to the range. Events are numbered starting from $1$ .


## 样例

### 样例输入 #1
```
8
1 0 12
2 -11 22
1 24 10
1 12 3
2 12 12
2 16 14
1 28 15
2 3 6

```
### 样例输出 #1
```
-1
-1
3
1

```
## 提示

Time limit: 3 s, Memory limit: 512 MB. 


## 题目翻译

给出一些圆，这些圆圆心在 $x$ 轴上方，且与 $x$ 轴相切，任意时刻，不存在图上的圆相交，给出两种操作：增加一个圆；向图中发送一颗子弹，如果击中某个圆，输出该圆编号并且删掉这个圆。如果未击中，则输出 `-1`。


---

---
title: "[NEERC 2017] The Final Level"
layout: "post"
diff: 省选/NOI-
pid: P6957
tag: ['2017', 'Special Judge', 'ICPC']
---
# [NEERC 2017] The Final Level
## 题目描述



Fiora is a game designer. Now she is designing the final level for her new game.

A level for this game is a labyrinth on a rectangular grid with lots of enemies. Player starts her game at the square $(0 , 0)$ and her purpose is to get to the square $(a , b)$ . Fiora has lots of ideas on how to put enemies, but she does not like designing labyrinths. She needs your help here.

Fiora is drawing levels in a special level editor which supports one basic block to design a labyrinth. This block is an L-shaped corner, consisting of two perpendicular rectangles $1 \times n$ squares in size intersecting at $1 \times 1$ square. It is possible to rotate this block in four ways. Blocks cannot intersect, but they can touch each other. Player can move through all the squares lying in any block. She can move between two squares if they are sharing a side, even if they are in different blocks.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/1.png)

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/2.png)

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15288/3.png)

Blocks with $n = 3$

The first example

The second example

Fiora wants to design the final level with the minimal possible number of blocks. Of course, it should be possible to move from square $(0 , 0)$ to square $(a , b)$ .


## 输入格式



The first line of the input consists of a single integer $m (1 \le m \le 100)$ -- the number of test cases. It is followed by $m$ test cases. Each test case is on a separate line and consists of three integers a , $b$ , and $n (−10^{8} \le $ a , $b \le 10^{8}; 2 \le n \le 10^{8})$ -- a is the coordinate of the final point along the horizontal axis, $b$ is the coordinate of the final point along the vertical axis, and $n$ is the size of the block. The final point is not same as the starting one (either a $≠ 0$ or $b ≠ 0)$ .


## 输出格式



For each test case, in the first line print the minimal number $k$ of blocks you need. In the following $k$ lines print description of these blocks. Each L-shaped corner block is described by coordinates of two cells. Print coordinates of the end of its vertical rectangle, followed by coordinates of the end of its horizontal rectangle. Specify the coordinates of the ends that are opposite to the intersection of the rectangles. Note that the order of cells in the block description matters, since a change of the order results in a reflected block. Coordinates of each end should be printed with the coordinate along the horizontal axis first, followed by the coordinate along the vertical axis.

All coordinates in the output should not exceed $10^{9}$ by absolute value.

It is guaranteed that the total number of blocks in the correct output does not exceed $10^{5}$ for all test cases combined.


## 样例

### 样例输入 #1
```
2
2 3 2
4 -1 3

```
### 样例输出 #1
```
2
1 1 0 0
1 2 2 3
2
0 0 2 -2
3 -3 5 -1

```
## 提示

Time limit: 3 s, Memory limit: 512 MB. 


## 题目翻译

用长度为 $n$ 的 L 型方块摆在二维网格平面上，仅通过方块从 $(0,0)$ 走到 $(a,b)$。

### 输入格式

第一行一个正整数 $m$ ，下面 $m$ 行每行 $3$ 个正整数 $a, b, n$。

### 输出格式

对于每组数据，输出最小 L 型块数 $k$，下面 $k$ 行每行按先横坐标后纵坐标的顺序输出每个 L 型块两端的坐标。

### 数据范围

对于 $100\%$ 的数据，$1 \le m \le 100, -10^8 \le a, b  \le 10^8, 2 \le n \le 10^8$。


---

---
title: "[NEERC 2017] The Great Wall"
layout: "post"
diff: 省选/NOI-
pid: P6958
tag: ['2017', 'ICPC']
---
# [NEERC 2017] The Great Wall
## 题目描述



Recently you had become an emperor of a small country of Sinai. You had decided to build a big wall at the border to save your country from barbarian raids. You had contacted `W Corp`, the only company in the world that builds non-penetrable walls.

`W Corp` builds each wall using the same pattern. The length of the wall is $n$ meters. Each one-meter piece of the wall is numbered by an integer from $1$ to $n$ along its length and may have a different height. The height pattern is based on three fixed arrays a , $b$ , and $c$ of $n$ elements each, such that $a_{i} < b_{i} < c_{i}$ for all $1 \le i \le n$ , and an integer $r (1 \le r < n)$ . These arrays and $r$ are the same for any wall that is built by `W Corp`.

The choice of the specific wall design is determined by two distinct integers $x$ and $y (1 \le x < y \le n−r+1)$ in the following way. Take two ranges of integers: [x , $x+r−1]$ and [y , $y+r−1]$ (these ranges are inclusive of their ends). Then the height of the wall at one meter piece $i$ for all $1 \le i \le n$ is equal to:

$a_{i}$ if $i$ does not belong to any of the chosen ranges;

$b_{i}$ if $i$ belongs to exactly one chosen range;

$c_{i}$ if $i$ belongs to both chosen ranges.

A strength of a wall is defined as the sum of all heights of its $n$ one meter pieces.

The arrays a , $b , c$ , and an integer $r$ are the same for any wall built by `W Corp`, so the company provides a price list with all the possible wall designs, sorted in non-decreasing order of their strength. You choose the k-th wall design from the list. The task is to find the strength of the chosen wall.


## 输入格式



The first line of the input contains three integers $n , r$ and $k (2 \le n \le 30 000 , 1 \le r < n , 1 \le k \le (n−r)(n−r+1)/2)$ -- the length of the wall, the length of the segments to choose, and the position of the wall in the price list.

The second line of the input contains the elements of the array a $(1 \le a_{i} \le 10^{6}).$

The third line of the input contains the elements of the array $b (a_{i} < b_{i} \le 10^{6}).$

The fourth line of the input contains the elements of the array $c (b_{i} < c_{i} \le 10^{6}).$


## 输出格式



Print one integer -- the strength of the k-th wall from `W Corp` price list.


## 样例

### 样例输入 #1
```
4 2 1
1 2 3 4
3 3 5 5
7 7 7 7

```
### 样例输出 #1
```
16

```
## 提示

Time limit: 3 s, Memory limit: 512 MB. 


## 题目翻译

最近你成为了西奈一个小国家的皇帝。你决定在边界建造一座长城保护你的国家不被野蛮人抢劫。你联系了“W Corp”——世界上唯一的建造坚不可摧的墙的公司。

“W Corp”用相同的格式建造所有墙。墙的长度是 $n$ 米，每一米墙按顺序从 $1$ 到 $n$ 编号，它们可能有不同的高度。高度的格式取决于三个固定的数组 $a,b,c$，它们各有 $n$ 个元素，对于任意 $1\le i\le n$ 满足 $a_i < b_i < c_i$，还有一个整数 $r\ (1\le r < n)$。三个数组和 $r$ 对于“W Corp”建造的任何墙都是相同的。

按照如下方式，具体的墙体设计的选择取决于两个不同的整数 $x,y\ (1\le x < y\le n-r+1)$。取两个整数区间：$[x,x+r-1]$ 和 $[y,y+r-1]$（区间包括端点）。那么第 $i$ 米墙的高度是：

- $a_i$，当 $i$ 不属于这两个区间
- $b_i$，当 $i$ 属于这两个区间中的恰好一个
- $c_i$，当 $i$ 属于这两个区间中的两个

墙的**强度**定义为每一米墙高度的和。

在“W Corp”建造的所有墙中，数组 $a,b,c$ 和整数 $r$ 都是固定的。公司提供了一份所有可能的墙体设计的列表，按照强度单调不减排序。你选择了其中第 $k$ 种墙体设计。你的任务是，求出你选择的墙的强度。

### 输入格式

第一行包括三个整数 $n,r,k\ (2\le n\le 30000,\ 1\le r < n,\ 1\le k\le \frac{(n-r)(n-r+1)}{2}\ \ )$，分别代表墙的长度，取的区间的长度，你的选择在列表中的位置。

第二行包括了数组 $a$ 的元素，$1\le a_i\le 10^6$。

第三行包括了数组 $b$ 的元素，$1\le b_i\le 10^6$。

第四行包括了数组 $c$ 的元素，$1\le c_i\le 10^6$。

### 输出格式

输出一个整数，“W Corp”的列表中第 $k$ 种墙的强度

### 样例解释

在样例中，能建造出的不同的墙有三种：

- 选择 $x=1,y=2$，墙的高度是 $[3,7,5,4]$，强度是 $19$。
- 选择 $x=1,y=3$，墙的高度是 $[3,3,5,5]$，强度是 $16$。
- 选择 $x=2,y=3$，墙的高度是 $[1,3,7,5]$，强度是 $16$。


---

---
title: "[NEERC 2017] Interactive Sort"
layout: "post"
diff: 省选/NOI-
pid: P6960
tag: ['2017', '交互题', 'Special Judge', 'ICPC']
---
# [NEERC 2017] Interactive Sort
## 题目背景

这是一道 IO 交互题。
## 题目描述

Ivan wants to play a game with you. He took all integers from $1$ to $n$ inclusive, shuffled them and then put all even numbers into array $e$ and all odd numbers into array $o$ .

Your task is to find arrays $e$ and $o$ .

You can ask Ivan questions of certain kind. Each question consists of two integers $i$ and $j$ . For each question Ivan says whether $e[i] < o[j]$ or not.

You can ask at most $300 000$ questions.

# Interaction Protocol

First, the testing system writes the integer $n (1 \le n \le 10 000)$ -- the number of integers Ivan used.

Your solution shall print requests of two types:

• “? i j”. $1 \le i \le ⌊n/2⌋, 1 \le j \le ⌈n/2⌉$. The testing system responds with the symbol $“<”$ if $e[i] < o[j]$ or with the symbol $“>”$ otherwise.

• “!\ $e_1\ e_2\ \cdots e_{⌊n/2⌋}\ o_1\ o_2 \cdots o_{⌈n/2⌉}$” tells the values of $e$ and $o$ that your program has determined.

Don't forget to flush the output after each request!

Your solution must issue exactly one request of the second type, which must be the last request, and thesolution must terminate gracefully after issuing it.

Your solution is allowed to issue at most $300 000$ requests of the first type.

For each test case the number $n$ is fixed and the numbers are shuffled using Java built-in shuffle functionwith fixed seed.



## 样例

### 样例输入 #1
```
5
>
>
<
>
<
<

```
### 样例输出 #1
```
? 1 1
? 1 2
? 1 3
? 2 1
? 2 2
? 2 3
! 4 2 1 3 5
```
## 题目翻译

有一个长度为 $n(n\le 10000)$ 的排列，所有奇数组成的序列设为 $o$，所有偶数组成的序列设为 $e$。

你可以进行不超过 $300000$ 次询问 `? i j`，每次交互库会返回一个 `<` 或 `>` 表示 $e_i$ 和 $o_j$ 的大小关系，最后你需要求出 $e,o$ 并输出，格式为 `! e o`。

保证数据随机。


---

---
title: "[NEERC 2017] Journey from Petersburg to Moscow"
layout: "post"
diff: 省选/NOI-
pid: P6961
tag: ['2017', 'ICPC']
---
# [NEERC 2017] Journey from Petersburg to Moscow
## 题目描述



To conduct The World Programming Cup $2112$ a network of wonderful toll roads was build in European part of Russia. This network consists of $m$ bidirectional roads that connect $n$ cities. Each road connects exactly two distinct cities, no two roads connect the same pair of cities, and it is possible to travel from any city to any other city using only this road network. Moreover, to ease the process of charging, no two roads intersect outside of the cities.

Each road is assigned some individual positive cost. Normally, if a driver makes a trip using some of these toll roads, at the end of his journey he would be charged the total cost equal to the sum of individual costs of all roads he has used. To increase the popularity of car travels between two capitals, the operator company Radishchev Inc introduced a special offer: make a journey from Saint Petersburg to Moscow and pay for only $k$ most expensive roads along your path.

Formally, let some path consists of $l$ roads. Denote as $c_{1}$ the cost of the most expensive road along this path, as $c_{2}$ the second most expensive and so on. Thus, we have a sequence $c_{1} \ge c_{2} \ge c_{3} \ge $ . . . $ \ge c_{l}$ of individual costs of all roads along the chosen path. If $l \le k$ , then the path is too short and the driver pays the sum of all individual costs as usual, i.e . $Σ^{l}_{i=1}c_{i}.$ If $l > k$ , then the driver only pays for $k$ most expensive roads, that is $Σ^{k}_{i=1}c_{i}.$

As the chief analyst of Radishchev Inc you were assigned a task to compute the cheapest possible journey from Saint Petersburg to Moscow.


## 输入格式



The first line of the input contains three integers $n , m$ and $k (2 \le n \le 3000 , 1 \le m \le 3000 , 1 \le k < n)$ -- the number of cities, the number of roads in the road network, and the maximum number of roads that one should pay for in a single journey.

Next $m$ lines contain description of roads. Each road description contains three integers $u_{i}, v_{i},$ and $w_{i} (1 \le u_{i}, v_{i} \le n , u_{i} ≠ v_{i}, 1 \le w_{i} \le 10^{9})$ -- the i-th bidirectional road that connects cities $u_{i}$ and $v_{i}$ with the cost of $w_{i}$ for any direction. It is guaranteed that there is at most one road between each pair of cities and it is possible to get from any city to any other city using only these roads.


## 输出格式



Print one integer equal to the minimum possible cost of travel from the city number $1$ (Saint Petersburg) to the city number $n (Moscow).$


## 样例

### 样例输入 #1
```
6 7 2
1 2 6
2 3 1
2 4 3
2 5 5
3 6 10
4 6 9
5 6 8

```
### 样例输出 #1
```
14

```
### 样例输入 #2
```
5 5 3
2 1 1
3 2 1
4 3 1
4 5 1
1 5 2

```
### 样例输出 #2
```
2

```
## 提示

Time limit: 3 s, Memory limit: 512 MB. 


## 题目翻译

有 $n$ 座城市 $m$ 条道路，每条道路连接两座城市，每条道路都需要过路费。

$\mathsf{\color{black}{K}\color{red}{arry5307}}$ 想从城市 $1$ 出发前往城市 $n$。根据相关法律法规，对于一条经过 $c$ 条边的路径，$\mathsf{\color{black}{K}\color{red}{arry5307}}$ 只需要支付路径上前 $k$ 大的过路费（当 $c<k$ 时需要支付路径上全部的过路费）。

现在 $\mathsf{\color{black}{K}\color{red}{arry5307}}$ 想要求出从 $1$ 到达 $n$ 的最小花费。因为 $\mathsf{\color{black}{K}\color{red}{arry5307}}$ 忙着写神仙题，所以这个任务交给了你。

$2\leq n\leq 3000,1\leq m\leq 3000,1\leq k<n$。


---

---
title: "[NEERC 2017] Laminar Family"
layout: "post"
diff: 省选/NOI-
pid: P6963
tag: ['2017', 'ICPC']
---
# [NEERC 2017] Laminar Family
## 题目描述



While studying combinatorial optimization, Lucas came across the notion of `laminar set family`. A subset family $F$ of some set $Ω$ is called laminar if and only if it does not contain an empty set and for any two distinct sets A , $B ∈ F$ it is correct that either $A ⊂ B$ or $B ⊂ A$ or $A ∩ B = ∅$.

As an experienced problem setter Lucas always tries to apply each new piece of knowledge he gets as an idea for a programming competition problem. An area of his scientific interests covers recognition problems that usually sound like `Given some weird combinatorial property, check if the given structure satisfies it`.

Lucas believes that the perfect programming competition problem should contain a cactus a tree in it. Trying to put together laminar sets and trees into a recognition problem, he finally came up with the following problem: given an undirected tree on $n$ vertices and a family $F = {F_{1}, . . . , F_{k}}$ of sets, where $F_{i}$ consists of all vertices belonging to the simple path between some two vertices $a_{i}$ and $b_{i}$ of the tree, check if the family $F$ is a laminar family. Note that in this case $Ω = V$ , and each $F_{i} ⊆ V$ .

As you can see, Lucas had succeeded in suggesting this problem to the programming contest. Now it is up to you to solve it.


## 输入格式



The first line of the input contains two integers $n$ and $f (1 \le n , f \le 100 000)$ -- the number of vertices in the tree and the number of elements in a family $F$ .

Next $n−1$ lines describe the tree structure. In the i-th line there are two integers $u_{i}$ and $v_{i} (1 \le u_{i}, v_{i} \le n , u_{i} ≠ v_{i})$ -- the indices of the vertices that are connected by the i-th edge of the tree.

Next $f$ lines describe the sets forming the family $F$ . In the i-th line there are two integers $a_{i}$ and $b_{i} (1 \le a_{i}, b_{i} \le n)$ , such that $F_{i}$ consists of all vertices belonging to the simple path between vertices $a_{i}$ and $b_{i}$ in the tree (including $a_{i}$ and $b_{i}).$


## 输出格式



Output the only word `Yes` or `No` depending on whether or not the given set family is laminar.


## 样例

### 样例输入 #1
```
4 2
1 2
2 3
2 4
1 2
4 2

```
### 样例输出 #1
```
No

```
### 样例输入 #2
```
6 5
1 2
2 3
3 4
5 6
5 2
2 1
6 6
1 4
3 4
4 1

```
### 样例输出 #2
```
Yes

```
## 提示

Time limit: 2 s, Memory limit: 512 MB. 


## 题目翻译

- 给定一棵 $n$ 个节点的树，给出 $f$ 条树上的路径，试判断下面的命题是否成立：
- $f$ 条路径中，任意两条路径的点集的交集为空，或者一个是另一个的子集。
- 成立输出 `Yes`，不成立输出 `No`。
- $1 \leq n,f \leq 10^5$


---

---
title: "[NEERC 2016] Cactus Construction"
layout: "post"
diff: 省选/NOI-
pid: P6966
tag: ['2016', 'Special Judge', 'ICPC']
---
# [NEERC 2016] Cactus Construction
## 题目描述



Let us consider the following way of constructing graphs. Pick the number of colors $ˆc$ . Let $n$ be the number of vertices in a graph. To build a graph, we use a workspace with several graphs in it. Each vertex of each graph has a color. Colors are denoted by integers from $1$ to $ˆc$ . Initially, we have $n$ graphs in a workspace with one vertex in each graph, all colored with color $1$ , and no edges. The only vertex of i-th graph has number $i$ .

The following operations are permitted:

join a $b$ : join graphs containing vertices a and $b$ into one graph. No edges are added. Vertices a and $b$ must be in different graphs.

recolor a $c_{1 }c_{2}:$ in graph containing vertex a recolor all vertices of color $c_{1}$ with color $c_{2}.$

connect a $c_{1 }c_{2}:$ in graph containing vertex a create edges between all pairs of vertices where one vertex has color $c_{1}$ and the other has color $c_{2}.$ If $c_{1} = c_{2}$ loops are not created. If such an edge already exists, then the second parallel edge is created. Multi-edges are not allowed in this problem, so this case must not occur.

At the end we should have a single graph and colors of its vertices do not matter.

The minimal number of colors $ˆc$ , that can be used to construct a graph, is called a clique width of a graph. Clique width is one of the characteristics of graph complexity. Many NP-hard problems can be solved in polynomial time on graphs with bounded clique width, using dynamic programming on this process of building a graph. For a general graph, calculating the exact value of a clique width is known to be NP-hard. However, for some graph classes bounds on a clique width are known.

Cactus is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively cactus is a generalization of a tree where some cycles are allowed. Multi-edges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus. It is known that a clique width of a cactus does not exceed $4$ .

You are given a cactus. Find out how to build it in the described way using at most $ˆc = 4$ colors.

![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.10.png)

![](https://onlinejudgeimages.s3.amazonaws.com/problem/13991/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202016-12-22%20%EC%98%A4%ED%9B%84%207.31.21.png)


## 输入格式



The first line of the input file contains two integers $n$ and $m (1 \le n \le 50 000$ ; $0 \le m \le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.

Each of the following $m$ lines contains a path in the graph. A path starts with an integer $k_{i} (2 \le k_{i } \le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in the path are distinct. The path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file.

The graph in the input file is a cactus.


## 输出格式



In the first line print one integer $q$ -- the number of operations you need. This number should not be greater than $10^{6}$ . In the next $q$ lines print operations. Each operation is denoted by its first letter (`j` for join, `r` for recolor and `c` for connect) and its arguments in the order they are described in the problem statement.

At the end, after applying all these operations, one should have one graph, which is equal to the cactus in the input. This means that there should be exactly one edge between each pair of vertices connected in the input graph, and no edges between vertices not connected in the input graph.


## 样例

### 样例输入 #1
```
8 2
5 1 2 3 4 7
5 4 5 6 1 8

```
### 样例输出 #1
```
17
r 2 1 2
j 2 3
c 2 1 2
r 6 1 2
j 5 6
c 6 1 2
r 4 1 3
j 4 3
j 4 6
j 4 7
c 4 3 1
r 4 3 1
r 8 1 2
r 1 1 3
j 1 8
j 1 4
c 1 3 2

```
### 样例输入 #2
```
15 3
9 1 2 3 4 5 6 7 8 3
7 2 9 10 11 12 13 10
5 2 14 9 15 10

```
### 样例输出 #2
```
39
r 7 1 2
r 5 1 2
j 7 8
c 7 1 2
j 5 4
c 5 1 2
r 6 1 3
j 6 7
j 6 5
c 6 3 2
r 3 1 4
j 6 3
c 6 4 1
r 11 1 2
r 13 1 2
j 12 11
j 12 13
c 11 1 2
r 10 1 3
j 12 10
c 10 2 3
r 10 1 2
r 10 4 2
r 15 1 3
j 15 10
c 15 3 3
j 9 10
c 9 1 3
r 9 3 2
r 9 1 4
r 14 1 4
j 9 14
c 9 4 4
r 1 1 4
r 3 1 2
j 2 1
j 2 14
j 2 3
c 2 1 4

```
## 提示

Time limit: 2 s, Memory limit: 512 MB. 


## 题目翻译

有 $n$ 个集合，初始第 $i$ 个集合只包含第 $i$ 个点，每个点的初始颜色都为 $1$。要求使用下列 $3$ 种操作构建出给定的仙人掌。输出方案，操作数不得多于 $10^6$。

- $j\ a\ b$，将 $a$ 所在的集合和 $b$ 所在的集合合并成一个集合。

- $r\ a\ c_1\ c_2$（$c_1,c_2\in[1,2,3,4]$），将 $a$ 所在的集合中，所有颜色为 $c_1$ 的点的颜色改为 $c_2$。

- $c\ a\ c_1\ c_2$，将 $a$ 所在的集合中，每一个颜色为 $c_1$ 的点连向每一个  颜色为 $c_2$ 的点，**不允许出现重边**。

输入第一行为点数 $n$ 和 $m$ 条（$n,m\leq 50000$）边不重复的路径，每条边**恰好**会出现一次。接下来每行第一个数字 $k_i$($2\leq k_i\leq1000$) 代表路径的点数，后面 $k_i$ 个数字表示一条路径。


---

---
title: "[NEERC 2016] Game on Graph"
layout: "post"
diff: 省选/NOI-
pid: P6970
tag: ['2016', 'ICPC']
---
# [NEERC 2016] Game on Graph
## 题目描述



Gennady and Georgiy are playing interesting game on a directed graph. The graph has $n$ vertices and $m$ arcs, loops are allowed. Gennady and Georgiy have a token placed in one of the graph vertices. Players take turns moving the token along one of the arcs that starts in the vertex the token is currently in. When there is no such arc, then this player loses the game.

For each initial position of the token and the player who is moving first, your task is to determine what kind of result the game is going to have. Does it seem to be easy? Not so much.

On one side, Gennady is having a lot of fun playing this game, so he wants to play as long as possible. He even prefers a strategy that leads to infinite game to a strategy that makes him a winner. But if he cannot make the game infinite, then he obviously prefers winning to losing.

On the other side, Georgiy has a lot of other work, so he does not want to play the game infinitely. Georgiy wants to win the game, but if he cannot win, then he prefers losing game to making it infinite.

Both players are playing optimally. Both players know preferences of the other player.


## 输入格式



In the first line there are two integers -- the number of vertices $n (1 \le n \le 100 000)$ and the number of arcs $m (1 \le m \le 200 000)$ . In the next $m$ lines there are two integers a and $b$ on each line, denoting an arc from vertex a to vertex $b$ . Vertices are numbered from $1$ to $n$ . Each $(a , b)$ tuple appears at most once.


## 输出格式



In the first line print $n$ characters -- i-th character should denote the result of the game if Gennady starts in vertex $i$ . In the second line print $n$ characters -- i-th character should denote the result of the game if Georgiy starts in vertex $i$ . The result of the game is denoted by `W` if the starting player wins the game, `L` if the starting player loses the game, and `D` (draw) if the game runs infinitely.


## 样例

### 样例输入 #1
```
6 7
1 2
2 1
2 3
1 4
4 1
4 5
5 6

```
### 样例输出 #1
```
WDLDWL
DWLLWL 

```
## 提示

Time limit: 2 s, Memory limit: 512 MB. 


## 题目翻译

Gennady 和 Georgiy 在玩一个有向图上的游戏。这个图有 $n$ 个点 $m$ 条边，两人轮流操作，每次可以将棋子沿着其中一条边移动，不能移动者输。

你要对于每个点，分别求出以这个店为起点开始游戏，两人分别作为先手，最终会输，赢，还是平局（游戏无限循环）。

其中，Gennady 因为玩得很开心，所以他更期望将游戏变为平局；Georgiy 还有很多其他事，所以他更期望游戏不要平局。当然，在不平局的基础上，两人都更希望赢。

### 输入格式 

第一行两个数 $n$，$m$ 表示有 $n$ 个点 $m$ 条边。  
接下来 $m$ 行每行两个数 $a,b$ 表示一条由 $a$ 至 $b$ 的边。

### 输出格式
两行，第一行表示分别以每一个点为起点 Gennady 先手的胜负情况；第二行表示分别以每一个点为起点 Georgiy 先手的胜负情况。`W` 表示赢，`L` 表示输，`D` 表示平局。

by a___


---

---
title: "[NEERC 2016] List of Primes"
layout: "post"
diff: 省选/NOI-
pid: P6973
tag: ['2016', 'Special Judge', 'ICPC']
---
# [NEERC 2016] List of Primes
## 题目描述

Lidia likes sets of prime numbers. When she is bored, she starts writing them down into the Extremely Long Notebook for Prime Sets.

Elements of each set are written down in ascending order. Each set of prime numbers appears in her notebook eventually. A set with a smaller sum always appears before a set with a larger sum. Sets with the same sum are sorted in ascending lexicographical order: they are compared by the first element, if the first elements are equal, then by second element, and so on.

Just in case someone decides to parse her notebook, she writes down her sets in a machine-readable JSON format. Of course, she puts a space after each comma. Here's the beginning of her notebook:

$[2], [3], [2 , 3], [5], [2 , 5], [7], [3 , 5], [2 , 7], [2 , 3 , 5], [3 , 7], [11], [2 , 3 , 7], [5 , 7], [2 , 11], [13], [2 , 5 , 7],$

Lidia wants to double-check her work, so here is her request for you: given two integers, $a$ and $b$ , output a substring of her notebook from the position $a$ to the position $b$ (inclusive, counting from $1$) .


## 输入格式



The first line contains two integers, $a$ and $b$ ($1 \le a \le b \le 10^{18}; b - a \le 10^{5}$).


## 输出格式



Output the substring of the notebook described in the problem statement from the position $a$ to the position $b$ . You must write a line with exactly $b - a + 1$ characters, including any leading or trailing spaces.


## 样例

### 样例输入 #1
```
1 35

```
### 样例输出 #1
```
[2], [3], [2, 3], [5], [2, 5], [7],

```
### 样例输入 #2
```
36 41

```
### 样例输出 #2
```
 [3, 5

```
## 提示

Time limit: 2 s, Memory limit: 512 MB. 


## 题目翻译

Lidia 喜欢素数集。当她无聊时，她就把它们写进她的「素数集的超长笔记本」。

集合中的元素按升序排列。每个集合都会在她的笔记本里出现，且以元素和为第一关键字，字典序为第二关键字排列。

为了预防有人决定解析她的笔记本，她把她的集合写成了机器可读的 JSON 格式。当然，她在每个逗号后面都加了空格。以下是她的笔记本的开头：

$$
[2], [3], [2 , 3], [5], [2 , 5], [7], [3 , 5], [2 , 7], [2 , 3 , 5], [3 , 7], [11], [2 , 3 , 7], [5 , 7], [2 , 11], [13], [2 , 5 , 7],
$$

Lidia 想仔细检查她的工作，所以她给了你两个整数 $a$ 和 $b$，要你输出她的笔记本中第 $a$ 到 $b$ 个字符（含两端，从 $1$ 开始）的内容。


---

---
title: "[NEERC 2015] Cactus Jubilee"
layout: "post"
diff: 省选/NOI-
pid: P6975
tag: ['2015', 'ICPC']
---
# [NEERC 2015] Cactus Jubilee
## 题目描述



This is the $20-th$ Northeastern European Regional Contest $(NEERC).$ Cactus problems had become a NEERC tradition. The first Cactus problem was given in $2005$ , so there is a jubilee -- $10$ years of Cactus.

Cactus is a connected undirected graph in which every edge lies on at most one simple cycle. Intuitively cactus is a generalization of a tree where some cycles are allowed. Multiedges (multiple edges between a pair of vertices) and loops (edges that connect a vertex to itself) are not allowed in a cactus.

You are given a cactus. Let's move an edge -- remove one of graph's edges, but connect a different pair of vertices with an edge, so that a graph still remains a cactus. How many ways are there to perform such a move?

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11737/1.png)

For example, in the left cactus above (given in the first sample), there are $42$ ways to perform an edge move. In the right cactus (given in the second sample), which is the classical NEERC cactus since the original problem in $2005$ , there are $216$ ways to perform a move.


## 输入格式



The first line of the input file contains two integers $n$ and $m (1 \le n \le 50 000 , 0 \le m \le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.

Each of the following $m$ lines contains a path in the graph. A path starts with an integer $k_{i} (2 \le k_{i} \le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in a path are distinct. Path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file.

The graph in the input file is a cactus.


## 输出格式



Write to the output file a single integer -- the number of ways to move an edge in the cactus.


## 样例

### 样例输入 #1
```
6 1
7 1 2 5 6 2 3 4

```
### 样例输出 #1
```
42

```
### 样例输入 #2
```
15 3
9 1 2 3 4 5 6 7 8 3
7 2 9 10 11 12 13 10
5 2 14 9 15 10

```
### 样例输出 #2
```
216

```
## 提示

Time limit: 1 s, Memory limit: 256 MB. 


## 题目翻译

题目描述

定义一种无向连通图叫`仙人掌图（Cactus图）`。仙人掌图中没有重边和自环，并且其中的每一条边至多位于一个简单环上。简单地说，`仙人掌图`是树的一种泛化形式，其中允许出现一些环。

现在有一个`仙人掌图`，你每次可以移动一条边（移除图的一条边，并将另一对顶点用一条边连接起来）。问如果要让后来得到的新图仍然是`仙人掌图`，有多少种移动边的办法？

输入格式

第一行包含两个整数n和m，分别表示图中的顶点数（顶点的编号分别为${1,2,3,...,n}$）和边的数目，且满足
$$1≤n≤50000,0≤m≤50000$$

第2~m+1行，每一行表示一条路径（从一个顶点出发一直往后走，直到当前所在的顶点没有任何未走过一条边）。

（译者注：虽然应该都能看出来了，但是还是用一个递归函数更浅显易懂）

设路径的开始点为$q_1$，$E_i$表示第$i$个点的边,$vis$数组中存储已经走过了的边，则整条路径可定义为：
```
1.x←q1
2.f(x)
	1.add(vis[],x)
	2.for i∈Ex do
	1.if i not in vis[] then
		1.call f(i->to)
3.print(vis[])
```
即：每一行的开始有一个整数$k_i$，满足
$2≤k_i≤1000$，紧接着有$k_i$个整数，表示这条路径所经过的顶点$q_i$，满足$q_i∈[1,n]$。

数据保证路径中的相邻顶点是不同的。

在路径中可以多次到达同一个顶点，但在整个输入文件中，每条边只遍历一次。

数据保证输入文件中的图形是仙人掌。

输出格式

输出文件中只有一个整数，即移动`仙人掌图`中一条边的方法数。

数据范围
$$1≤n≤50000,0≤m≤50000,2≤k_i≤1000,q_i∈[1,n]$$


---

---
title: "[NEERC 2015] Distance on Triangulation"
layout: "post"
diff: 省选/NOI-
pid: P6976
tag: ['2015', 'ICPC']
---
# [NEERC 2015] Distance on Triangulation
## 题目描述



You have a convex polygon. The vertices of the polygon are successively numbered from $1$ to $n$ . You also have a triangulation of this polygon, given as a list of $n − 3$ diagonals.

You are also given $q$ queries. Each query consists of two vertex indices. For each query, find the shortest distance between these two vertices, provided that you can move by the sides and by the given diagonals of the polygon, and the distance is measured as the total number of sides and diagonals you have traversed.


## 输入格式



The first line of the input file contains an integer $n$ -- the number of vertices of the polygon $(4 \le n \le 50 000)$ .

Each of the following $n−3$ lines contains two integers $a_{i}, b_{i}$ -- the ends of the i-th diagonal $(1 \le a_{i}, b_{i} \le n , a_{i} ≠ b_{i}).$

The next line contains an integer $q$ -- the number of queries $(1 \le q \le 100 000)$ .

Each of the following $q$ lines contains two integers $x_{i}, y_{i}$ -- the vertices in the i-th query $(1 \le x_{i}, y_{i} \le n)$ .

It is guaranteed that no diagonal coincides with a side of the polygon, and that no two diagonals coincide or intersect.


## 输出格式



For each query output a line containing the shortest distance.


## 样例

### 样例输入 #1
```
6
1 5
2 4
5 2
5
1 3
2 5
3 4
6 3
6 6

```
### 样例输出 #1
```
2
1
1
3
0

```
## 提示

Time limit: 2 s, Memory limit: 256 MB. 


## 题目翻译

给定一个正 $n$ 边形及其三角剖分, 共 $2n−3$ 条边 ($n$ 条多边形的边和 $n−3$ 条对角线), 每条边的长度为 $1$。

共 $q$ 次询问, 每次询问给定两个点, 求它们的最短距离。

Translated by Eason_AC  
2020.11.19


---

---
title: "[NEERC 2015] Hypercube"
layout: "post"
diff: 省选/NOI-
pid: P6980
tag: ['2015', 'ICPC']
---
# [NEERC 2015] Hypercube
## 题目描述



Consider a $4-hypercube$ also known as tesseract. A unit solid tesseract is a 4D figure that is equal to the convex hull of $16$ points with Cartesian coordinates $(±½, ±½, ±½, ±½)$ -- its vertices. It has $32$ edges $(1D), 24$ square faces $(2D),$ and $8$ cubic $3-faces$ (3D) also known as cells. We study hollow tesseracts and define a tesseract as a boundary of a solid tesseract. Thus, a tesseract is a connected union of $8$ solid cubes (its cells) that intersect between each other at $24$ tesseract's square faces, $32$ edges, and $16$ vertices.

Let's cut a tesseract along $17$ of its $24$ faces, so that it still remains connected via $7$ faces that were left intact. Unfold the tesseract into a 3D hyperplane by rotating its constituting cubes along the faces that were left intact until all its cells lie in the same 3D hyperplane. The result is called a $3-net$ of a tesseract. This process is a natural generalization of how a 3D cube is cut and unfolded onto a 2D plane to produce a $2-net$ of a cube that consists of $6$ squares.

In this problem you are given a tree-like $8-polycube$ in 3D space also known as octocube. An octocube is a collection of $8$ unit cubical cells joined face-to-face. More formally, intersection of each pair of cubical cells constituting an octocube is either empty, a point, a unit line $(1D),$ or a unit square $(2D).$ The given octocube is tree-like in the following sense. Consider an adjacency graph of the octocube -- a graph with $8$ vertices corresponding to its $8$ cells. There is an edge in the adjacency graph between pairs of adjacent cells. Two cells of an octocube are called adjacent when their intersection is a square. Cells that intersect at a point or a line are not considered adjacent. An octocube is called tree-like when its adjacency graph is a tree.

Your task is to determine whether the given tree-like octocube constitutes a $3-net$ of a tesseract. That is, whether this octocube being put onto a hyperplane in 4D space can be folded in 4D space along the squares of intersection between its cells into a tesseract.

For example, look at the leftmost picture below. It shows a wire-frame of the tree-like octocube. Rotate cell $GHLKG_{1}H_{1}L_{1}K_{1}$ around a plane GHLK and cell $FGKJF_{2}G_{2}K_{2}J_{2}$ around a plane FGKJ at angle $90$ degrees in $4-th$ dimension outside of the original hyperplane. As a result, point $G_{1}$ joins with $G_{2}$ and $K_{1}$ joins with $K_{2}.$ The face $GKK_{2}G_{2}$ is glued to face $GKK_{1}G_{1}.$ The result is shown on the right. The $4-th$ dimension is orthographically projected onto the $3$ shown in perspective. The points that have moved out of the original hyperplane are marked with hollow dots.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/1.png)

Rotate $EFJIE_{1}F_{1}J_{1}I_{1}$ around EFJI and $EHLIE_{2}H_{2}L_{2}I_{2}$ around EHLI. The result is shown on the following picture on the left. The remaining steps are as follows. Rotate MNOPQRST around MNOP, then rotate both MNOPQRST and IJKLMNOP around IJKL and rotate ABCDEFGH around EFGH. The last step is to glue all faces that meet together to get a tesseract that is shown on the right.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11742/2.png)


## 输入格式



The first line of the input file contains there integers $m , n , k$ -- the width, the depth, and the height of the box that contains the given octocube $(1 \le m , n , k \le 8)$ . The following $k$ groups of lines describe rectangular slices of the box from top to bottom. Each slice is described by $n$ rows with $m$ characters each. The characters on a line are either $‘. ',$ denoting an empty space, or $‘x',$ denoting a unit cube. The input file is guaranteed to describe a tree-like octocube.


## 输出格式



Write to the output file a single word `Yes` if the given octocube can be folded into a tesseract or `No` otherwise.


## 样例

### 样例输入 #1
```
3 3 4
...
.x.
...
.x.
xxx
.x.
...
.x.
...
...
.x.
...

```
### 样例输出 #1
```
Yes

```
### 样例输入 #2
```
8 1 1
xxxxxxxx

```
### 样例输出 #2
```
No

```
## 提示

Time limit: 1 s, Memory limit: 256 MB. 


## 题目翻译

给定一个三维图形，保证相邻小方格之间构成树形结构，判断它是否是4维超立方体的一个三维展开。


---

---
title: "[NEERC 2015] Iceberg Orders"
layout: "post"
diff: 省选/NOI-
pid: P6981
tag: ['2015', 'ICPC']
---
# [NEERC 2015] Iceberg Orders
## 题目描述



You are working for Metagonia stock exchange. Recently traders in Metagonia had heard about Iceberg orders traded on London stock exchange and asked your employer to add such functionality as well. A stock exchange is an engine that receives orders and generates trades.

An iceberg order is a quintuple of integers (ID, $T , P , V$ , TV). Each order has an identifier ID (unique among all orders), type $T$ (which is equal to either BUY $= 1$ or SELL $= 2)$ , price $P$ , total remaining volume $V$ and tip volume TV. For each order, exchange additionally keeps track of its current volume CV and priority PR. There is also a global priority counter of the exchange GP. An order book of the exchange is a set of orders.

Trades that are generated by the exchange are quadruples of integers (BUY ID, SELL ID, $P , V)$ . Each trade has BUY ID and SELL ID -- identifiers of matching BUY and SELL orders, trade price $P$ , and trade volume $V$ .

When an order is received by the exchange it is matched against orders currently on the order book. This is done as follows. Suppose an order a is received with $T_{a} =$ SELL. Among all orders currently on the order book we look for an order $b$ such that $T_{b} =$ BUY and $P_{b} \ge P_{a}.$ We select such an order $b$ with the largest price, and if there are several -- one with the smallest priority. If there is such an order $b$ , then a trade $t$ is generated with BUY $ID_{t} = ID_{b}$ and SELL $ID_{t} = ID_{a}$ at trade price $P_{t} = P_{b}$ with trade volume $V_{t} = mi_n(V_{a}, CV_{b}). V_{a}, V_{b},$ and $CV_{b}$ are all decreased by trade volume. If $V_{b} = 0$ after this, then the order $b$ is removed from the order book. If $CV_{b} = 0$ (but $V_{b} > 0)$ then we set current volume of order $b$ to $CV_{b} = mi_n(V_{b}, TV_{b}),$ set $PR_{b} =$ GP, and increment GP. We continue these operations of selecting $b$ and generating trades until either $V_{a} = 0$ or there are no more orders $b$ on the order book which satisfy the condition. In the latter case, we add order a to the order book with $CV_{a} = mi_n(V_{a}, TV_{a})$ and $PR_{a} =$ GP, and then increment GP. When the process of matching the order a is finished with several trades between the same pair of orders a and $b$ (and there can be lots of them!), they are all united into a single trade with the volume equal to the sum of individual trade volumes.

If $T_{a} =$ BUY we are looking for an order $b$ with $T_{b} =$ SELL and $P_{b} \le P_{a}$ and select such an order $b$ with the smallest price and the smallest priority among those. The rest of the matching process is as described above, with trades having BUY $ID_{t} = ID_{a},$ SELL $ID_{t} = ID_{b}, P_{t} = P_{b},$ and $V_{t} = mi_n(V_{a}, CV_{b}).$

Initially the order book is empty. You are presented with several orders that are received by the exchange one by one. You need to print generated trades and the order book state after all orders are processed.

Hint: The priority and GP are introduced in the problem statement only for the purpose of a formal description of the algorithm. The actual implementation does not have to keep track of priority. Typically, an exchange simply keeps a priority-ordered list of orders of each type at each price in its order book.


## 输入格式



The first line of the input contains the number of orders $n (1 \le n \le 50 000)$ . Each of the following $n$ lines represent an order. Each order is given by a space-separated quintuple ID $T P V$ TV , where $1 \le $ ID $ \le 1 000 000 , T = 1$ for BUY and $T = 2$ for SELL, $1 \le P \le 100 000$ and $1 \le $ TV $ \le V \le 1 000 000 000$ .


## 输出格式



For each order print all trades generated by processing this order, in ascending order of pairs (BUY ID, SELL ID), each trade on its own line. Each trade shall be printed as a space-separated quadruple of integers BUY ID SELL ID $P V$ . It is guaranteed that the total number of trades would not exceed $100 000$ . Print a blank line after all trades, followed by the order book. Each order that is still on the book shall be printed as a space-separated sextuple ID $T P V$ TV CV, sorted first by $P$ and then by PR.


## 样例

### 样例输入 #1
```
7
42 1 100 200 20
239 1 100 50 50
1111 1 101 30 15
1234 1 100 300 15
4321 2 99 125 25
5678 1 101 30 30
8765 2 101 100 20

```
### 样例输出 #1
```
42 4321 100 30
239 4321 100 50
1111 4321 101 30
1234 4321 100 15
5678 8765 101 30

42 1 100 170 20 10
1234 1 100 285 15 15
8765 2 101 70 20 20

```
## 提示

Time limit: 1 s, Memory limit: 256 MB. 




---

---
title: "[NEERC 2015] Jump"
layout: "post"
diff: 省选/NOI-
pid: P6982
tag: ['2015', '交互题', 'Special Judge', 'ICPC']
---
# [NEERC 2015] Jump
## 题目背景

这是一道 IO 交互题。
## 题目描述

暂无英文题面。
## 样例

### 样例输入 #1
```
2
1
0
1
2
```
### 样例输出 #1
```
01
11
10
00
```
## 题目翻译

给定长度为 $n$（$n$ 为偶数） 的 01 字符串 $S$。

你可以向交互库进行询问。你可以向交互库输出一个长度为 $n$ 的 01 字符串 $Q$。设 $S$ 和 $Q$ 有 $k$ 个对应的位置上的字符相同。若 $k=n$ 或 $k=\frac n 2$，则交互库将返回 $k$，否则交互库将返回 $0$。

你最多向交互库询问 $n+500$ 次，要求求出 $S$。你只需要使最后一次询问的返回值为 $n$ 即可。此时你应立即结束程序，否则将得到不可预料的结果。

若你的字符串长度不为 $n$ 或出现 01 以外的字符，或者你的询问次数超过上限，则交互库会返回 $-1$。此时你应立即结束程序，否则将得到不可预料的结果。

$1\leq n\leq 1000$。


---

---
title: "[NEERC 2015] King’s Inspection"
layout: "post"
diff: 省选/NOI-
pid: P6983
tag: ['2015', 'Special Judge', 'ICPC']
---
# [NEERC 2015] King’s Inspection
## 题目描述



King Karl is a responsible and diligent ruler. Each year he travels across his country to make certain that all cities are doing well.

There are $n$ cities in his country and $m$ roads. In order to control the travelers, each road is unidirectional, that is a road from city a to city $b$ can not be passed from $b$ to a .

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11745/1.png)

Karl wants to travel along the roads in such a way that he starts in the capital, visits every non-capital city exactly once, and finishes in the capital again.

As a transport minister, you are obliged to find such a route, or to determine that such a route doesn't exist.


## 输入格式



The first line contains two integers $n$ and $m (2 \le n \le 100 000 , 0 \le m \le n + 20)$ -- the number of cities and the number of roads in the country.

Each of the next $m$ lines contains two integers $a_{i}$ and $b_{i} (1 \le a_{i}, b_{i} \le n)$ , meaning that there is a one-way road from city $a_{i}$ to city $b_{i}.$ Cities are numbered from $1$ to $n$ . The capital is numbered as $1$ .


## 输出格式



If there is a route that passes through each non-capital city exactly once, starting and finishing in the capital, then output $n + 1$ space-separated integers -- a list of cities along the route. Do output the capital city both in the beginning and in the end of the route.

If there is no desired route, output `There is no route, Karl!` (without quotation marks).


## 样例

### 样例输入 #1
```
4 6
1 4
4 1
4 2
2 1
3 4
1 3

```
### 样例输出 #1
```
1 3 4 2 1

```
### 样例输入 #2
```
4 3
1 4
1 4
2 2

```
### 样例输出 #2
```
There is no route, Karl!

```
## 提示

Time limit: 10 s, Memory limit: 512 MB. 


## 题目翻译

国王 Karl 是一个负责并且勤奋的统治者。每年他都会游览并视察他的国家来保证每个城市都欣欣向荣。

他的国家有$n$个城市$m$条道路。每条道路是单向的，一条$a$到$b$的道路不能由$b$到$a$
经过。

Karl 想要游览他的国家，并且路线为由首都开始，经过每个非首都城市恰好一次，最终回到首都。

作为运输大臣，你有义务找到这样的一条路线，或者确定其不存在。


---

---
title: "[NEERC 2015] Landscape Improved"
layout: "post"
diff: 省选/NOI-
pid: P6984
tag: ['2015', 'ICPC']
---
# [NEERC 2015] Landscape Improved
## 题目描述



Louis $L$ Le Roi-Univers has ordered to improve the landscape that is seen from the royal palace. His Majesty prefers to see a high mountain.

The Chief Landscape Manager is going to raise a mountain for Louis. He represents a landscape as a flat picture on a grid of unit squares. Some of the squares are already filled with rock, while others are empty. This greatly simplifies the design. Unit squares are small enough, and the landscape seems to be smooth from the royal palace.

The Chief Landscape Manager has a plan of the landscape -- the heights of all rock-filled columns for each unit of width. He is going to add at most $n$ square units of stones atop of the existing landscape to make a mountain with as high peak as possible. Unfortunately, piles of stones are quite unstable. A unit square of stones may be placed only exactly on top of the other filled square of stones or rock, moreover the squares immediately to the bottom-left and to bottom-right of it should be already filled.

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11746/1.png)

![](https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/11746/2.png)

Existing landscape

Improved landscape

Your task is to help The Chief Landscape Manager to determine the maximum height of the highest mountain he can build.


## 输入格式



The first line of the input file contains two integers $w$ -- the width of the existing landscape and $n$ -- the maximum number of squares of stones to add $(1 \le w \le 100 000 , 0 \le n \le 10^{18}).$

Each of the following $w$ lines contains a single integer $h_{i}$ -- the height of the existing landscape column $(1 \le h_{i} \le 10^{9}).$


## 输出格式



The output file shall contain the single integer -- the maximum possible landscape height after at most $n$ unit squares of stones are added in a stable way.


## 样例

### 样例输入 #1
```
8 4
3
4
2
1
3
3
2
4

```
### 样例输出 #1
```
5

```
### 样例输入 #2
```
3 100
3
3
3

```
### 样例输出 #2
```
4

```
## 提示

Time limit: 1 s, Memory limit: 256 MB. 


## 题目翻译

给定序列 $\{h_i\}(i\in[1,w])$ 和常数 $n$。

$\forall i\in(1,w)$ ，仅当 $h_{i-1} \geq h_i$ 且 $h_{i+1} \geq h_i$ 时可使 $h_i$ 变为 $h_i+1$ ，且操作次数不能多于 $n$ 次。

求所有合法方案下，$\max\{h_i\}$ 的最大值。

$1\leq w\leq 10^5,1\leq h_i \leq 10^9,1\leq n\leq 10^{18}.$


---

---
title: "[NEERC 2014] Cactus Generator（征集SPJ）"
layout: "post"
diff: 省选/NOI-
pid: P6987
tag: ['2014', 'Special Judge', 'ICPC']
---
# [NEERC 2014] Cactus Generator（征集SPJ）
## 题目描述



NEERC featured a number of problems about cactuses -- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed.

In $2005$ , the first year where a problem about cactuses appeared, the problem was called simply `Cactus`. In $2007$ it was `Cactus Reloaded`, in $2010$ it was called `Cactus Revolution`, and in $2013$ it was called `Cactus Automorphisms`. Here is an example of cactus that was used in those problems:

![](/upload/images2/cactus.png)

For four years judges had to generate test files for cactuses with thousands of vertices. Of course, a number of test generators of ever-increasing complexity were built, culminating with a domain-specific language called CGL -- Cactus Generator Language. CGL can compactly define a big cactus for purposes of a test. In this problem you have to parse a simplified version of this language, which we call SCGL -- Simple Cactus Generator Language, and output a resulting cactus.

A cactus has to be output by listing the minimal set of edge-distinct paths that cover the whole graph.

The syntax of SCGL cactus definition is represented by the graph non-terminal in the grammar that is given below using the Extended Backus-Naur Form:

graph $=$ `c`

$|$ `c(` list `)`

$|$ `loop(` list `)`

$|$ `t(` list `)`

list $=$ graph ${$ `,` graph $}$

$|$ (number $|$ range $|$ variable ) $[$ `,` graph $]$

number $=$ nzdig ${$ `0` $|$ nzdig $}$

nzdig $=$ `1` $|$ `2` $| \cdots |$ `8` $|$ `9`

range $=$ `range(` variable `,` numvar `,` numvar `)`

variable $=$ `A` $|$ `B` $| \cdots |$ `Y` $|$ `Z`

numvar $=$ number $|$ variable

A graph production rule denotes a graph with two labeled vertices -- the first and the last. Graphs definition rules have the following semantics:

The basic building block $c$ denotes a graph with just two vertices (one is the first and the other one is the last) and one edge.

The $c(σ)$ rule connects a specified list of graphs $σ$ from left to right into a chain, merging the last vertex of the first graph in the list with the first vertex of the second graph in the list, the last vertex of the second graph with the first of the third one, and so on. The resulting graph's first vertex is the first vertex of the first graph in the list, and the resulting graph's last vertex is the last vertex of the last graph in the list.

The $loo_p(σ)$ rule connects a specified list of graphs $σ$ from left to right, merging the last vertex of the first graph in the list with the first vertex of the second graph in the list, and so on like in $c(σ),$ while the last vertex of the last graph in the list is merged with the first vertex of the first graph in the list to form a loop. The resulting graph's first and last vertices are the first and the last vertices of the first graph in the list. Loop can be applied only to lists with more than one graph.

The $t(σ)$ rule connects a specified list of graphs $σ,$ merging their first vertices. The resulting graph's first and last vertices are the first and the last vertices of the first graph in the list.

The list of graphs is either specified explicitly, by a comma-separated list, or using a list repetition with a number, a range, or a variable, optionally followed by a comma and a graph. When a graph is not explicitly specified in a list repetition, then the given graph is assumed to be $c$ .

The simplest list repetition is defined using a number non-terminal. It denotes a list of graphs with the specified integer number of copies of the given graph.

A range list repetition is defined by $range(ν, α, β)$ rule which has three components -- a variable $ν,$ and numbers $α$ and $β.$ If $ξ$ character sequence is a graph, then $c|loo_p|t(range(ν, α, β), ξ)$ are called rangeenabled rules and the variable $ν$ is called a bound variable in $ξ.$ In the context of a range-enabled rule, $ξ$ is repeated $|β − α| + 1$ times to form a list. Every occurrence of variable $ν$ in $ξ$ is replaced by consecutive integer numbers between $α$ and $β$ inclusive in ascending order. That produces a list of $|β −α|+ 1$ graphs, which are then connected according the specification of the corresponding range-enabled rule. The $α$ and $β$ themselves might refer to variables that are bound in the outer range-enabled rule.

In a well-formed graph:

each variable non-terminal (a letter from A to $Z)$ occurs at most once as $ν$ in $range(ν, α, β)$ rules;

all other occurrences of variable non-terminal that are allowed by the grammar are bound.

Note, that if a character sequence $ξ$ is a graph, then $ξ, c(ξ),$ c(1 , $ξ), t(ξ),$ and t(1 , $ξ)$ all denote the same graph. On the other hand, neither $loo_p(ξ)$ nor loop(1 , $ξ)$ are allowed.

The following examples illustrate these basic rules. The graphs have their first and last vertices marked with letters $F$ and $L$ correspondingly.

![](/upload/images2/cactus1.png)

![](/upload/images2/cactus2.png)


## 输入格式



The input file contains a single line with a well-formed cactus definition in SCGL. While the syntax and semantics of SCGL themselves do not guarantee that the resulting graph is a cactus, the input file for this problem always defines a cactus -- every edge belongs to at most one simple cycle and there are no multiple edges between vertices. For example, neither loop(3 , $loo_p(3))$ nor $loo_p(2)$ are possible.

The line in the input file is at most $1000$ characters long and defines a cactus with at most $50 000$ vertices. Integer numbers represented by number non-terminals do not exceed $50 000$ .


## 输出格式



The first line of the output file must contain two integer numbers $n$ and $m$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ , where $1$ is the number of the first vertex of the graph and $n$ is the number of the last vertex of the graph. The other vertices can be numbered arbitrarily. Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the minimal number of such paths.

Each of the following $m$ lines must contain a path in the graph. A path starts with an integer number $k_{i} (k_{i} \ge 2)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. A path can go to the same vertex multiple times, but every edge must be traversed exactly once in the whole output file.


## 样例

### 样例输入 #1
```
c(c,t(loop(3),c(c,loop(6))),loop(c,c,t(c,loop(4))))

```
### 样例输出 #1
```
15 1
19 1 2 9 10 11 12 13 10 15 9 14 2 3 4 5 6 7 8 3

```
### 样例输入 #2
```
c

```
### 样例输出 #2
```
2 1
2 1 2

```
### 样例输入 #3
```
c(2)

```
### 样例输出 #3
```
3 1
3 1 2 3

```
### 样例输入 #4
```
c(3)

```
### 样例输出 #4
```
4 1
4 1 2 3 4

```
### 样例输入 #5
```
t(c(3),c,c)

```
### 样例输出 #5
```
6 2
2 1 2
5 3 1 4 5 6

```
### 样例输入 #6
```
c(2,t(c(2),c,c))

```
### 样例输出 #6
```
9 3
3 2 1 3
3 4 5 6
5 1 7 5 8 9

```
## 提示

Time limit: 1 s, Memory limit: 256 MB. 


## 题目翻译

### 题目描述

NEERC 以大量关于仙人掌的题目为特色——每条边属于至多一个简单环连通的无向图。直观的说，仙人掌是一种一些环被允许的广义树。

2005年，第一个有关仙人掌的问题出现，这个问题被简单的叫做[“仙人掌”](https://codeforces.com/gym/101334)。在2007年是[“仙人掌再来”](https://codeforces.com/gym/100273)，在2010年叫做[“仙人掌变革”](https://codeforces.com/gym/101309)，以及2013年是[“仙人掌自同构”](https://codeforces.com/gym/100307)。以下是这些问题中使用的仙人掌例子：

![](/upload/images2/cactus.png)

四年来评测必须为顶点以千数的仙人掌生成测试文件。当然，复杂性日益增加的大量数据发生器被建立，最终有一个被称为 CGL（Cactus Generator Language，仙人掌发生器语言）的领域特定语言。CGL 可以为测试的目的简洁地定义一个大仙人掌。本题中你要解析该语言的我们称为 SCGL（Simple Cactus Generator Language，简单仙人掌发生器语言）的一个简化版本，输出一个仙人掌作结果。

一个仙人掌要以列出边的极小集（覆盖全图的不同路径）输出。

SCGL 仙人掌定义的语法由语法中的指定的用下面的扩展巴科斯-诺尔范式的非终止图表示：

$$
\begin{aligned}
graph &= “\texttt{\textup{c}}”&&&&&&&&&&&&&&&&&&&&&&&&&&&\\
&| “\texttt{\textup{c(}}” list “\texttt{\textup{)}}”\\
&| “\texttt{\textup{loop(}}” list “\texttt{\textup{)}}”\\
&| “\texttt{\textup{t(}}” list “\texttt{\textup{)}}”\\
\end{aligned}
$$

$$
\begin{aligned}
list &= graph \{ “\texttt{\textup{,}}” graph \}&&&&&&&&&&&&\\
&|(number | range | variable ) [ “\texttt{\textup{,}}” graph ]\\
\end{aligned}
$$

$$
\begin{aligned}
&number = nzdig \{ “\texttt{\textup{0}}” | nzdig \}\\
&nzdig = “\texttt{\textup{1}}” | “\texttt{\textup{2}}” | \cdots | “\texttt{\textup{8}}” | “\texttt{\textup{9}}”\\
&range = “\texttt{\textup{range(}}” variable “\texttt{\textup{,}}” numvar “\texttt{\textup{,}}” numvar “\texttt{\textup{)}}”\\
&variable = “\texttt{\textup{A}}” | “\texttt{\textup{B}}” | \cdots | “\texttt{\textup{Y}}” | “\texttt{\textup{Z}}”\\
&numvar = number | variable
\end{aligned}
$$

一个图的制造规则表示一个有两个点标记的图——首和尾。图定义规则有以下语义：

- 基本建立块 $c$ 列表示一个仅有两个点（一首一尾）标记与一边的图。

- $c(σ)$ 规则对于含有 $n$ 个图的指定图列表 $σ$ 将第 $i$ 图尾顶点与第 $i+1$ 图首顶点合并，加入列表。（$i\in\mathbb{N}^*,1\le i< n$）结果图的首顶点为第一图首顶点，尾顶点为第 $n$ 图尾顶点。

- $loop(σ)$ 规则与 $c(σ)$相似，但第 $n$ 图尾顶点与第一图首顶点合并,加入列表。结果图的首尾顶点为列表中第一图首尾顶点。环仅可被应用于一图以上的列表。

- $t(σ)$ 规则连接一个指定图列表 $σ$，合并他们的首顶点。结果图的首尾顶点为列表中第一图首尾顶点。

图列表不是以一逗号分隔列表明确指定，就是用一个有一个数字、范围或变量的选择性地跟随一个逗号或图的可重列表指定。当一图非于一可重列表中明确指定，则该指定图被假定为 $c$。

最简单的可重列表用一个非终止数定义。它表示一个有指定整数个指定图的副本的列表。

一个可重范围列表由有三个组件（变量 $ν$，数字 $α$ 与 $β$）的 $range(ν, α, β)$ 规则定义。若 $ξ$ 字符序列为一图，则 $c|loop|t(range(ν, α, β), ξ)$ 被称为范围启用规则，变量 $ν$ 被称为 $ξ$ 中的一个约束变量。在一个范围启用规则的语境中，$ξ$ 被重复 $|β − α| + 1$ 次以建立列表。变量 $ν$ 于 $ξ$ 中的每次出现按升序由连续的 $α$ 与 $β$ 之间的整数（包括 $α$ 与 $β$）取代。 那产出一个包括 $|β −α|+ 1$ 个图的列表，通过相应的范围启用规则的规范连接。$α$ 与 $β$ 自身可能指被约束于外范围启用规则的变量。

在一个语法正确的图中：

- 每一个非终止变量（一个从 A 到 Z 的字母）作为 $range(ν, α, β)$ 规则中的 $ν$ 至多存在一次；

- 非终止变量的语法允许的所有其他事件被绑定。

注意，若一字符序列 $ξ$ 为一图，那么 $ξ, c(ξ), c(1 , ξ), t(ξ),$ 与 $t(1 , ξ)$ 都指此一图。另一方面，不论 $loop(ξ)$ 还是 $loop(1 , ξ)$ 都不被允许。

下列例子说明这些基本规则。这些图有以 F 与 L 相应标记的始末点。

![](/upload/images2/cactus1.png)

![](/upload/images2/cactus2.png)

### 输入格式

输入文件包含一行，含有一个 SCGL 定义。定义格式正确，总描述一仙人掌，每条边属于至多一个简单环，无重边。比如，$loop(3 , loop(3))$ 与 $loop(2)$ 都不可能。

输入文件中该行至多长 $1000$ 字符，定义的仙人掌至多 $50000$ 个顶点。由非终止数代列表的整数不超过 $50000$。
### 输出格式

输出文件第一行必须包含两个整数 $n$ 与 $m$。$n$ 为图顶点数。顶点由 $1$ 到 $n$ 编号，$1$ 为首点编号，$n$ 为图尾点编号。其他点可随意编号。图中边由一个边不重路径集代表，$m$为该集合最小路径数。

后 $m$ 行，每行必须包含图中一条路径。一条路径以一个整数 $k_{i} (k_{i} \ge 2)$ 开始，后随 $k_{i}$ 个整数从 $1$ 到 $n$。这 $k_{i}$ 个整数代列表一条路径的顶点。一条路径可经过同一顶点多次，但每条边必须在整个输出文件中刚好经过一次。

### 注释
此题中出现的的EBNF：

非终端符号为被定义的语言的句法部分。

终端符号为由一个或多个字符组成的序列，是构成语言的不可约元素。

本题中一条语法规则形如$元标识符=定义列表$

定义列表形如$主要句法|主要句法|\cdots$。

其中主要句法为可选序列、重复序列、分组序列、元标识符、终端字符串、空序列之一。

可选序列形如[定义列表]，重复序列形如{定义列表}，分组序列形如(定义列表)。

元标识符是以字母开头的字母数字序列，即非终端符号的名称。

由语法定义的语言的终端符号由终端字符串表示，终端字符串形如“一个或多个除该引号符号以外的任何终端字符的序列” 。

EBNF的终端符号称为终端字符，是字母、数字, 与`=|{}“()[]`字符之一。

需要注意的是，这里给出的EBNF不完整，但足以解决题目。


---

---
title: "[NEERC 2014] Damage Assessment"
layout: "post"
diff: 省选/NOI-
pid: P6988
tag: ['2014', 'Special Judge', 'ICPC']
---
# [NEERC 2014] Damage Assessment
## 题目描述



A tank car that transports gasoline via rail road has a shape of cylinder with two spherical caps at the sides. The cylinder has a diameter $\(d\)$ and a length $\(l\).$ The spherical caps have a radius $\(r\) (\(2r\) \ge \(d\)).$ There was the rail road accident and the tank car had derailed. It now lies on the ground and some of the stored gasoline had flown out. The damage assessment must be performed. The location of the tank on the ground was established by measuring its tilt as the height difference $\(t\)$ from the bottom points of the cylinder on its left and right sides $(0 \le \(t\) \le \(l\)).$ The level of gasoline in the tank was established by measuring the height difference $\(h\)$ from the bottom point of the cylinder and the top level of gasoline. For the purpose of this problem, the top level of gasoline always intersects the cylinder part of the tank $(0 \le \(h\) \le \(t + d \sqrt{1 - (t/l)^2}).$

Your task is to figure out how much gasoline was left in the tank.

![](/upload/images2/dmaage.png)


## 输入格式



The input file consists of a single line with five integer numbers -- $\(d\), \(l\), \(r\), \(t\)$ and $\(h\),$ which represent the diameter and the length of the tank's cylinder part, the radius of its spherical caps, tilt and gasoline level measurements. They are all expressed in millimeters ($1$ millimeter $= 10^{−3}$ meters), they satisfy all constraints expressed in the problem statement and $\(d\), \(l\) \ge 100 , \(d\), \(l\), \(r\) \le 10 000$ .


## 输出格式



Write a single real number to the output file -- the volume of gasoline in the tank in liters ($1$ liter $= 10^{−3}$ cubic meters). The absolute error of the answer must not exceed $0$ . $1$ liters.


## 样例

### 样例输入 #1
```
3000 6000 1600 0 3000

```
### 样例输出 #1
```
50974.56

```
### 样例输入 #2
```
3000 6000 1600 3441 4228

```
### 样例输出 #2
```
40728.90

```
## 提示

Time limit: 1 s, Memory limit: 256 MB. 


## 题目翻译

有一个由一个长度为 $l$，底面直径为 $d$ 的圆柱和两个半径均为 $r\ (2r\ge d)$ 的球形盖组成的油箱。由于一个交通事故，该油箱现在倾斜了一个角度，有一些汽油被洒了出来。现在给定圆柱底部的左右两个端点的高度差 $t\ (0\le t\le l)$ 以及剩余汽油的水平面到圆柱底端的距离 $h$，保证汽油的水平面一定与油箱的圆柱部分有交，即 $(0\le h\le t+d\sqrt {1-(t/l)^2})$。所有长度单位均用毫米给出。

求还剩下多少汽油（升），精确到 $0.1$。

$d,l\ge 100$，$d,l,r\le 10^4$。

下图为原题图。

![](https://cdn.luogu.com.cn/upload/image_hosting/465n22d6.png)


---

---
title: "[NEERC 2014] Epic Win!"
layout: "post"
diff: 省选/NOI-
pid: P6989
tag: ['2014', 'Special Judge', 'ICPC']
---
# [NEERC 2014] Epic Win!
## 题目描述



A game of rock-paper-scissors is played by two players who simultaneously show out their moves: Rock, Paper , or Scissors. If their moves are the same, it's a draw. Otherwise, Rock beats Scissors, Paper beats Rock, and Scissors beat Paper .

The described procedure can be repeated many times. In this problem, two Finite State Machines (FSMs) will compete in a series of rounds. (Formally speaking, by FSMs we mean Moore machines in this problem. )

An FSM for playing rock-paper-scissors has finitely many states. Each state is described by the following: what move the FSM will make in the upcoming round, and what will be the new state in case of its opponent playing Rock, Paper , and Scissors.

![](/upload/images2/epic.png)

Fortunately, you know your opponent FSM -- the entire scheme except for one thing: you do not know the initial state of that FSM.

Your task is to design your own FSM to fight the given one. Your FSM must beat the opponent in at least $99\%$ of the first $1$ billion rounds. That's what we call an epic win!


## 输入格式



The input file contains a description of the opponent FSM in the following format.

The first line contains an integer $n (1 \le n \le 100)$ -- the number of states in the FSM. States are numbered from $1$ to $n$ . Each of the following $n$ lines contains a description of the state: a character $c_{i}$ denoting the move made by FSM and integers $r_{i}, p_{i}, s_{i}$ denoting the next state in case of seeing Rock, Paper, or Scissors respectively $(c_{i}$ can be `R`, `P`, or `S`; $1 \le r_{i}, p_{i}, s_{i} \le n$


## 输出格式



Write to the output the description of your FSM in the same format.

The initial state of your FSM is the first state.

The number of states may not exceed $50 000$ .


## 样例

### 样例输入 #1
```
2
R 1 1 2
P 2 2 1

```
### 样例输出 #1
```
2
P 1 2 1
S 1 1 1

```
## 提示

Time limit: 1 s, Memory limit: 256 MB. 


## 题目翻译

**【题目描述】**

在游戏「石头、剪子、布」中，两名玩家分别同时出示自己的行动：*石头*、*剪子*、或*布*。如果两人的行动一致，则平局。否则*石头*打败*剪子*、*布*打败*石头*、*剪子*打败*布*。

上述过程可以重复多次。在本题中，两台有限状态自动机（Finite State Machines，FSM）将游玩多轮「石头、剪子、布」（准确地说，本题中的 FSM 特指 Moore 状态机）。

一台被设计用来游玩「石头、剪子、布」的 FSM 有着有限的状态。每个状态由以下信息描述：下一轮中本台自动机将会出示怎样的行动，以及当下一轮中对手出示了*石头*、*剪子*、或*布*时应该转移到的新状态。

![](https://cdn.luogu.com.cn/upload/image_hosting/j121iya3.png)

幸运的是，你知道对手的 FSM：你知道它所有的结构，但唯独不知道它的初始状态。

你的任务是设计一台你自己的 FSM 去和对手的进行对战。你的 FSM 必须在前十亿（${10}^9$）轮中打败对手至少 $99 \%$ 轮。这就是所谓的史诗般的胜利（epic win）！

**【输入格式】**

从标准输入中读入对对手的 FSM 的描述，按如下格式：

第一行一个正整数 $n$，表示 FSM 中的状态数。所有状态从 $1$ 到 $n$ 编号。

接下来 $n$ 行，每行描述一个状态：一个字符 $c_i$ 以及三个正整数 $r_i, p_i, s_i$，分别表示该状态的行动、以及当对手出示了*石头*、*布*、或*剪子*后应该转移到的新状态的编号，其中 $c_i$ 只可能为 $\{\texttt{R}, \texttt{P}, \texttt{S}\}$ 之一，如果为 $\texttt{R}$ 则意味着行动为出示*石头*，如果为 $\texttt{P}$ 则意味着行动为出示*布*，如果为 $\texttt{S}$ 行动为出示*剪子*。

**【输出格式】**

将你设计的 FSM 以相同格式输出到标准输出中。

你的 FSM 的初始状态是 $1$ 号状态。

你的 FSM 的状态数量不应超过 $50000$。

**【样例解释】**

题目描述中的图片显示了样例输入中给出的对手的 FSM，以及样例输出中给出的一个你的 FSM。

对手的 FSM 持续出示*石头*或*布*（取决于初始状态）直到它接收到*剪子*：接收到*剪子*将导致它的行为改变。

一种打败这样的 FSM 的方法是出示*布*。如果对手持续出示*石头*，只需继续出示*布*即可胜利。如果对手出示了*布*，通过出示一次*剪子*让它的行为改变，接下来它就会持续出示*石头*，然后你就可以用*布*打败它了。

**【数据范围】**

对于全部数据，$1 \le n \le 100$，$c_i \in \{\texttt{R}, \texttt{P}, \texttt{S}\}$，$1 \le r_i, p_i, s_i \le n$。

**翻译来源**：IOI 2021 集训队第一部分作业，PinkRabbit。


---

---
title: "[NEERC 2014] Gomoku"
layout: "post"
diff: 省选/NOI-
pid: P6991
tag: ['2014', '交互题', 'Special Judge', 'ICPC']
---
# [NEERC 2014] Gomoku
## 题目背景

这是一道 IO 交互题。
## 题目描述



This is an interactive problem.

Gomoku is a two-player game on a two-dimensional grid. Each cell of the grid can be either empty, contain the first player's mark $(black),$ or contain the second player's mark $(white),$ but not both. Initially the entire grid is empty. Two players make alternating moves, starting with the first player. At each move, a player can put her mark into exactly one empty cell. The first player to have her five adjacent marks in a single row wins. The winning row can be either vertical, horizontal or diagonal.

![](https://upload.acmicpc.net/23c94254-2783-405a-907b-7b66bea5514b/-/preview/)

Position where the second player (white marks) had won.

The players use a $19 \times 19$ grid in this problem. If the entire grid gets filled with marks but no player has won, the game is declared a draw.

The first player uses the following strategy: as the first move, she puts her mark into the center cell of the grid. At every other move, she picks such a move that maximizes the score of the resulting position.

In order to find the score of a position, the first player considers all possible places where the winning combination might eventually form -- in other words, all horizonal, vertical and diagonal rows of five consecutive cells on the board (of course, they may overlap each other). If such a row contains both the first player's marks and the second player's marks, it is disregarded. If such a row contains no marks, it is disregarded as well. For each row with exactly $k (1 \le k \le 5)$ marks of the first player and no marks of the second player, add $50^{2k−1}$ to the score of the position. For each row with exactly $k$ marks of the second player and no marks of the first player, subtract $50^{2k}$ from the score of the position. Finally, add a random integer number between $0$ and $50^{2} − 1$ to the score. This random number is chosen uniformly.

In case when several moves of the first player have equal scores (such ties are quite rare because of the random addition mentioned above), the first player picks the one with the smallest x-coordinate, and in case of equal x-coordinates, the one with the smallest y-coordinate.

Your task is to write a program that plays the second player and beats this strategy.

Your program will play $100$ games against the strategy described above, with different seeds of random generator. Your program must win all these games.


## 输入格式




## 输出格式




## 样例

### 样例输入 #1
```
10 10
10 11
10 12
10 13
9 10
9 11
9 9
11 13
-1 -1

```
### 样例输出 #1
```
11 10
11 11
10 9
10 14
8 9
11 9
11 12
11 8

```
## 提示

Time limit: 2 s, Memory limit: 512 MB. 


## 题目翻译

这是一道交互题。

五子棋是一种两个人在二维棋盘上玩的游戏。棋盘上的每个格子可以为空，放有第一名玩家的棋子（黑），或者放有第二名玩家的棋子（白），但是不能都有。初始时所有的格子都是空的。两个玩家轮流操作，从第一名玩家开始。每次操作，一名玩家可以把他的棋子放进恰好一个空格子里。首先在一行中放下五个相邻棋子的玩家获胜。一行可以是横行、竖行或对角线。

![1.png](https://upload.acmicpc.net/23c94254-2783-405a-907b-7b66bea5514b/-/preview/)

*第二名玩家（白子）获胜的一种情况。*

在这个问题中，玩家们使用 $19 \times 19$ 的棋盘。如果整个棋盘都放满了棋子但无人获胜，游戏平局。

第一名玩家将会使用下面的策略：第一次操作时，她会把她的棋子放到棋盘的正中间。在后面的每次操作中，她会选择一个下子后局面分数最大的位置下子。

为了计算一个局面的分数，第一名玩家会考虑能组成胜利组合的所有地方——换句话说，棋盘上所有横行、竖行、对角线上五个连续的格子（当然，它们会互相重叠）。如果这一行同时包括了第一名玩家的棋子和第二名玩家的棋子，就无视它。如果这一行包括了恰好 $k\ (1\le k\le 5)$ 个第一名玩家的棋子而没有第二名玩家的棋子，给该局面的分数加上 $50^{2k-1}$。如果这一行包括了恰好 $k$ 个第二名玩家的棋子而没有第一名玩家的棋子，给该局面的分数减去 $50^{2k}$。最后，给分数加上一个 $0$ 到 $50^2-1$ 的随机数。随机数是均匀分布的。

如果第一名玩家有多个分数相同的格子可选（因为上面提到的随机分数的原因，这是非常罕见的），第一名玩家选择 X 坐标最小的位置，如果仍有多个格子有相同的 X 坐标，就选择 Y 坐标最小的位置。

你的任务是，写一个程序扮演第二名玩家，并打败上述的策略。

你的程序将会与上述策略对局 $100$ 局，每局的随机数种子不同。你的程序必须在每局中都获胜。

### 交互格式

每一步你的程序需要做：

1. 从标准输入读入两个整数 $x,y$。
2. 如果都是 $-1$，那么游戏结束，你的程序必须退出。
3. 否则这两个整数描述了第一名玩家下子的坐标，$1\le x,y\le 19$。
4. 输出第二名玩家下子的坐标，然后换行。别忘了清空缓冲区。

### 样例

在下面的样例中，第一名玩家**没有**使用题目描述中所述的策略。这个样例只是为了说明交互格式。

![2.png](https://s1.ax1x.com/2020/10/29/B8voct.png)

*样例最终的棋盘状态。*

### 说明

世界上有很多种不同的五子棋规则。请只考虑题目描述中说明的这一种规则。


---

---
title: "[NEERC 2014] Hidden Maze"
layout: "post"
diff: 省选/NOI-
pid: P6992
tag: ['2014', 'Special Judge', 'ICPC']
---
# [NEERC 2014] Hidden Maze
## 题目描述



Helen and Henry are fans of the TV show `Hidden Maze`, which is very popular in Hiddenland. During this show two participants (usually a married couple) are rushing through the maze consisting of $n$ halls connected by some tunnels. Each tunnel connects two different halls and there can't be more than one tunnel connecting any pair of halls.

In the beginning of the show, two participants are placed in two different halls. Then they need to move very quickly to meet each other before the time runs out. To pass through each tunnel, the participant needs to find a clue which is some positive integer number written on a small piece of paper.

If the participants finally meet in some tunnel before the time runs out, and successfully find a clue contained in the tunnel where they met, they are considered winners. The value of their prize is calculated by sorting all the clues found by them and taking the median value. The game is always set up in such a way, that the number of clues they find is odd.

Helen and Henry saw a large number of episodes of the show, and now they understand a lot about the mechanics of it. They noticed that the maze doesn't change between episodes, and they drew a complete map of the maze. Shortly after, Helen and Henry have discovered that the maze is built in such a manner that if you visit any tunnel at most once, then there is exactly one path between any two halls.

Helen and Henry have been wondering how this great maze is created, and not so long time ago they have seen an interview with Hillary, who worked for the company which had built the maze. Hillary has told that to make the show fair, the maze had been created using the following randomized algorithm:

Pick the number of halls $n$ . Build $n$ halls enumerated from $1$ to $n$ .

Choose at random two integers $i$ and $j$ , each of them uniformly distributed between $1$ and $n$ .

If halls $i$ and $j$ are the same or are already connected with some path of tunnels, then go to step $2$ .

Build the tunnel between $i$ and $j$ . If there is a path of tunnels from any hall to any other one, stop the process, otherwise go to step $2$ .

Helen and Henry have also noticed that each tunnel contains exactly one clue and its value never changes from episode to episode. However, they don't know what algorithm was used to generate clue values. Helen and Henry have written on their map the value of the clue for each tunnel.

It always takes $1$ minute to find a clue and to run through the tunnel from one hall to another. It takes half a minute to run from the hall to the center of the tunnel when the participants meet in the center of the tunnel at the end. The time given to participants is only enough to meet each other if they act optimally, that is they just run to each other via the shortest possible path, never make mistakes when finding clues, and never turn into any other tunnels that do not belong to the shortest path. To make the participants meet in the center of some tunnel, they are placed in the beginning of the show in such a way that the length of the shortest path between the halls where they are placed is odd.

Helen and Henry want to participate in the show. They know the maze by heart and they are pretty sure that they will succeed in moving optimally to each other and finding all clues in time. Provided that the pair of initial halls is selected uniformly from all pairs with an odd-length shortest path between them, they need to know the expected value of the prize they win. Your task is to help them find this expected value.


## 输入格式



The first line of the input contains an integer number $n (2 \le n \le 30 000)$ -- the number of halls. Each of the following $n − 1$ lines contains three integers: $u_{i}, v_{i}, c_{i} (1 \le u_{i}, v_{i} \le n , 1 \le c_{i} \le 10^{6}),$ describing the i-th tunnel connecting the halls $u_{i}$ and $v_{i},$ containing the clue with the value $c_{i}.$ The maze is always created by the randomized algorithm that is specified in the problem statement.


## 输出格式



Write to the output file a single real number -- the expected value of the prize. The absolute or relative error of the answer must not exceed $10^{−9}.$


## 样例

### 样例输入 #1
```
2
2 1 1

```
### 样例输出 #1
```
1

```
### 样例输入 #2
```
5
2 4 4
1 2 5
5 4 2
5 3 3

```
### 样例输出 #2
```
3.50

```
### 样例输入 #3
```
5
4 1 2
5 3 2
4 2 3
5 4 7

```
### 样例输出 #3
```
3.1666666667

```
## 题目翻译

给定一个 $n$ 个点的随机生成的无根树，每条边有正整数边权。每次随机两个最短路径边数为奇数的点，将这两点间路径上边权的中位数作为贡献。求这个贡献的期望。  

by a___


---

---
title: "[NEERC 2014] Improvements"
layout: "post"
diff: 省选/NOI-
pid: P6993
tag: ['2014', 'ICPC']
---
# [NEERC 2014] Improvements
## 题目描述



Son Halo owns $n$ spaceships numbered from $1$ to $n$ and a space station. They are initially placed on one line with the space station so the spaceship $i$ is positioned $x_i$ meters from the station and all ships are on the same side from the station $(x_i > 0)$ . All $x_i$ are distinct. Station is considered to have number $0$ and $x_0$ is considered to be equal to $0$ .

Every two spaceships with consequent numbers are connected by a rope, and the first one is connected to the station. The rope number $i$ (for $1 \le i \le n)$ connects ships $i$ and $i-1.$ Note, that the rope number $1$ connects the first ship to the station.

Son Halo considers that the rope $i$ and the rope $j$ intersect when the segments $[x_{i}^{min}, x_{i}^{max}]$ and $[x_{j}^{min}, x_{j}^{max}]$ have common internal point but neither one of them is completely contained in the other, where $x_{k}^{min} = \min(x_{k−1}, x_k)$, $x_{k}^{max} = max(x_{k−1}, x_k).$ That is:

$$\begin{cases} x_{i}^{min} < x_{j}^{min} \sim \& \sim x_{j}^{min} < x_{i}^{max} \sim \& \sim x_{i}^{max} < x_{j}^{max} \\ x_{j}^{min} < x_{i}^{min} \sim \& \sim x_{i}^{min} < x_{j}^{max} \sim \& \sim x_{j}^{max} < x_{i}^{max}  \end{cases}$$

Son Halo wants to rearrange spaceships in such a way, that there are no rope intersections. Because he is lazy, he wants to rearrange the ships in such a way, that the total number of ships that remain at their original position $x_i$ is maximal. All the ships must stay on the same side of the station and at different positions $x_i$ after rearrangement. However, ships can occupy any real positions $x_i$ after rearrangement.

Your task is to figure out what is the maximal number of ships that can remain at their initial positions.


## 输入格式



The first line of the input file contains $\(n\) (1 \le \(n\) \le 200 000)$ -- the number of ships. The following line contains $\(n\)$ distinct integers $\(x_i\) (1 \le \(x_i\) \le \(n\))$ -- the initial positions of the spaceships.


## 输出格式



The output file must contain one integer -- the maximal number of ships that can remain at their initial positions in the solution of this problem.


## 样例

### 样例输入 #1
```
4
1 3 2 4

```
### 样例输出 #1
```
3

```
### 样例输入 #2
```
4
1 4 2 3

```
### 样例输出 #2
```
4

```
## 提示

Time limit: 1 s, Memory limit: 256 MB. 


## 题目翻译

一个数轴上有 $n$ 个位置互异的点，第 $i$ 个点的坐标为 $x_i\ (x_i \gt 0)$，第 $i$ 个点和第 $i - 1$ 个点连了一根绳子（第 $1$ 个点和原点连了根绳子）定义两根绳子有交当且仅当它们跨越的区间有交且不是包含关系。你可以改变若干个点的坐标到一个任意的正实数位置，使得最后不存在任何两根绳子有交。最大化不动的点的个数。

$n\le 2\times 10^5$，$x_i$ 构成一个 $1,2,\cdots,n$ 的排列。


---

---
title: "[NEERC 2013] Cactus Automorphisms"
layout: "post"
diff: 省选/NOI-
pid: P6998
tag: ['2013', 'Special Judge', 'ICPC']
---
# [NEERC 2013] Cactus Automorphisms
## 题目描述



NEERC had featured a number of problems in previous years about cactuses -- connected undirected graphs in which every edge belongs to at most one simple cycle. Intuitively, cactus is a generalization of a tree where some cycles are allowed.

In $2005$ , the first year where problems about cactuses had appeared, the problem was called simply `Cactus`. In $2007$ it was `Cactus Reloaded` and in $2010$ it was called `Cactus Revolution`. An example of cactus from NEERC $2007$ problem is given on the picture below.

![](/upload/images2/cac.png)

The challenge that judges face when preparing test cases for those problems is that some wrong solutions may depend on the numbering of vertices in the input file. So, for the most interesting test cases judges typically include several inputs with the same graph, but having a different numbering of vertices. However, some graphs are so regular that the graph remains the same even if you renumber its vertices. Judges need some metric about the graph that tells how regular the given graph is in order to make an objective decision about the number of test cases that need to be created for this graph.

The metric you have to compute is the number of graph automorphisms. Given an undirected graph $(V , E)$ , where $V$ is a set of vertices and $E$ is a set of edges, where each edge is a set of two distinct vertices ${v_{1}, v_{2}} (v_{1}, v_{2} ∈ V ),$ graph automorphism is a bijection $m$ from $V$ onto $V$ , such that for each pair of vertices $v_{1}$ and $v_{2}$ that are connected by an edge (so ${v_{1}, v_{2}} ∈ E)$ the following condition holds: ${m(v_{1}), m(v_{2})} ∈ E$ .

Each graph has at least one automorphism (one where $m$ is an identity function) and may have up to $n$ ! automorphisms for a graph with $n$ vertices. Because the number of automorphisms may be a very big number, the answer must be presented as a prime factorization $∏^{k}_{i=1} p_{i}^{q_{i}},$ where $p_{i}$ are prime numbers in ascending order $(p_{i} \ge 2 , p_{i} 0)$ .


## 输入格式



The first line of the input file contains two integer numbers $n$ and $m (1 \le n \le 50 000 , 0 \le m \le 50 000)$ . Here $n$ is the number of vertices in the graph. Vertices are numbered from $1$ to $n$ . Edges of the graph are represented by a set of edge-distinct paths, where $m$ is the number of such paths.

Each of the following $m$ lines contains a path in the graph. A path starts with an integer number $k_{i} (2 \le k_{i} \le 1000)$ followed by $k_{i}$ integers from $1$ to $n$ . These $k_{i}$ integers represent vertices of a path. Adjacent vertices in a path are distinct. Path can go to the same vertex multiple times, but every edge is traversed exactly once in the whole input file. There are no multiedges in the graph (there is at most one edge between any two vertices).

The graph in the input file is a cactus.


## 输出格式



On the first line of the output file write number $k$ -- the number of prime factors in the factorization of the number of graph automorphisms. Write $0$ if the number of graph automorphisms is $1$ . On the following $k$ lines write prime numbers $p_{i}$ and their powers $q_i$ separated by a space. Prime numbers must be given in ascending order.


## 样例

### 样例输入 #1
```
15 3
9 1 2 3 4 5 6 7 8 3
7 2 9 10 11 12 13 10
5 2 14 9 15 10

```
### 样例输出 #1
```
1
2 2

```
### 样例输入 #2
```
2 1
2 1 2

```
### 样例输出 #2
```
1
2 1

```
### 样例输入 #3
```
15 7
3 1 2 3
3 4 2 5
3 6 2 7
3 8 2 9
3 10 2 11
3 12 2 13
3 14 2 15

```
### 样例输出 #3
```
6
2 11
3 5
5 2
7 2
11 1
13 1

```
## 提示

Time limit: 5 s, Memory limit: 256 MB. 


## 题目翻译

- **仙人掌**是满足如下条件的无向简单连通图：每条边被包含于至多一个简单环中。
- 设有无向图 $G=(V,E)$。称双射 $f:V\rightarrow V$ 是 $G$ 的**自同构**，当且仅当 $\forall v_1,v_2\in V$，都有 $(v_1,v_2)\in E\Leftrightarrow (f(v_1),f(v_2))\in E$。称两个自同构 $f_1,f_2$ 相同，当且仅当 $\forall v\in V$ 均有 $f_1(v)=f_2(v)$。
- 给定有 $n$ 个节点的仙人掌，求它的不同的自同构数。由于结果可能很大，你需要输出它的质因子分解的结果。
- 输入仙人掌的方式为：给定 $m$ 条路径，这些路径所覆盖的边即为仙人掌的全部边。保证这些路径不会重复经过一条边两次，且输入的图是仙人掌。
- $n,m\leq 5\times 10^4$。


---

---
title: "[NEERC 2013] Dictionary"
layout: "post"
diff: 省选/NOI-
pid: P6999
tag: ['2013', 'Special Judge', 'ICPC']
---
# [NEERC 2013] Dictionary
## 题目描述



Petr and Dmitry are working on a novel data compression scheme. Their task is to compress a given set of words. To compress a given set of words they have to build a rooted tree. Each edge of the tree is marked with exactly one letter.

Let us define a dictionary that is produced by this kind of tree as a set of words that can be constructed by concatenating letters on edges on any path from any vertex in the tree (not necessarily root) and going away from root down to the leaves (but not necessarily finishing on a leaf).

Boys have to construct such a tree with a dictionary that is a superset of the set of words that they are given to compress. This tree should have the smallest number of vertices between trees that satisfy the above condition. Any tree with the same number of vertices will do. Your task is to help them.

![](/upload/images2/dict.png)

For example, in a tree on the picture above with the root marked as $1$ , a path from $7$ to $5$ reads `north`, a path from $16$ to $12$ reads `eastern`, a path from $29$ to $2$ reads `european`, a path from $3$ to $25$ reads `regional`, and a path from $1$ to $31$ reads `contest`.


## 输入格式



The first line of the input file contains the number of words in a given set $n (1 \le n \le 50)$ . The following $n$ lines contain different non-empty words, one word per line, consisting of lowercase English letters. The length of each word is at most $10$ characters.


## 输出格式



On the first line output the number of vertices in the tree $m$ . The following $m$ lines shall contain descriptions of tree vertices, one description per line. Vertices are indexed from $1$ to $n$ in the order of their corresponding description lines. If the corresponding vertex is a tree root, then its description line shall contain a single integer number $0$ , otherwise its description line shall contain an index of its parent node and a letter on the edge to its parent node, separated by a space.


## 样例

### 样例输入 #1
```
5
north
eastern
european
regional
contest

```
### 样例输出 #1
```
31
0
7 n
2 o
18 t
4 h
29 e
17 a
7 s
8 t
9 e
10 r
11 n
6 u
13 r
14 o
15 p
16 e
3 r
18 e
19 g
20 i
21 o
22 n
23 a
24 l
1 c
26 o
27 n
28 t
6 s
30 t

```
## 提示

Time limit: 1 s, Memory limit: 128 MB. 


## 题目翻译

## 题目描述

Petr和Dmitry正在研究一种新的数据压缩方案。他们的任务是压缩一组给定的单词。为了压缩给定的一组单词，他们必须建立一个有根的树。这棵树的每一个边缘都有一个字母。

让我们定义一个由这种树生成的字典，它是一组单词，可以通过在树的任何顶点（不一定是根节点）的任何路径上的边上连接字母，从根向下到叶子（但不一定在叶节点上完成）来构造。

男孩们必须用字典来构造这样一棵树，字典是一组单词的超集，他们被给予压缩。满足上述条件的树之间的顶点数应该最小。任何具有相同顶点数的树都可以。你的任务是帮助他们。

例如，上图中的一棵树的根标记为1，从7到5的路径表示north，从16到12的路径表示eastern，从29到22的路径表示european，从3到25的路径表示regional，从1到31的路径表示contest。

## 输入格式
第一行是一个数字n（0<n<50）
接下来n行都是一个长度小于10的字符串

## 输出格式
在第一行输出树中的顶点数m。每行树应包含一行描述的顶点。顶点按其相应描述行的顺序从1索引到n。如果对应的顶点是树根，则其描述行应包含单个整数0，否则其描述行应包含其父节点的索引和父节点边缘上的字母，用空格隔开。


---

---
title: "[NEERC 2013] Easy Geometry"
layout: "post"
diff: 省选/NOI-
pid: P7000
tag: ['2013', 'Special Judge', 'ICPC']
---
# [NEERC 2013] Easy Geometry
## 题目描述



Eva studies geometry. The current topic is about convex polygons, but Eva prefers rectangles. Eva's workbook contains drawings of several convex polygons and she is curious what is the area of the maximum rectangle that fits inside each of them.

![](/upload/images2/eg.png)

Help Eva! Given the convex polygon, find the rectangle of the maximum possible area that fits inside this polygon. Sides of the rectangle must be parallel to the coordinate axes.


## 输入格式



The first line contains a single integer $n$ -- the number of sides of the polygon $(3 \le n \le 100 000)$ . The following $n$ lines contain Cartesian coordinates of the polygon's vertices -- two integers $x_{i}$ and $y_{i} (-10^{9} \le x_{i}, y_{i} \le 10^{9})$ per line. Vertices are given in the clockwise order.

The polygon is convex.


## 输出格式



Output four real numbers $x_{mi_n}, y_{mi_n}, x_{max}$ and $y_{max}$ -- the coordinates of two rectangle's corners $(x_{mi_n} < x_{max}, y_{mi_n} < y_{max}).$ The rectangle must fit into the polygon and have the maximum possible area.

The absolute precision of the coordinates should be at least $10-^{5}.$

The absolute or relative precision of the rectangle area should be at least $10^{-5}.$ That is, if $A'$ ; is the actual maximum possible area, the following must hold: $mi_n(|A-A'|,|A−A'|/A') ) \le 10^{-5}.$


## 样例

### 样例输入 #1
```
4
5 1
2 4
3 7
7 3

```
### 样例输出 #1
```
3.5 2.5 5.5 4.5

```
### 样例输入 #2
```
5
1 1
1 4
4 7
7 4
7 1

```
### 样例输出 #2
```
1 1 7 4

```
## 提示

Time limit: 1 s, Memory limit: 128 MB. 


## 题目翻译

**一句话题意：** 

给你一个凸 $n$ 边形，并按顺时针给出每一个顶点的坐标，求出在这个凸 $n$ 边形之内的面积最大的一个边平行坐标轴的矩形的四个顶点。

**输入格式：**

第一行是一个正整数 $n$ ，且 $3\le n \le 100000$ 。

接下来 $n$ 行，每行两个整数 $x$ ， $y$ ，代表一个顶点的 $x$ 坐标和 $y$ 坐标。 $-10^9 \le x,y \le 10^9$ 。

**输出格式：**

输出四个整数 $x_{min},y_{min},x_{max},y_{max}$ ，代表你给出的这个面积最大的矩形。其中 $x_{min} \le x_{max} $ ， $y_{min} \le y_{max} $ 。

精度要求：如果 $A$ 是你算出的值， $A'$ 是真实的最大面积，那么你需要保证 $min( |A-A'|,|A-A'|/A') \le10^{-5}$ 。


---

---
title: "[NEERC 2013] Interactive Interception"
layout: "post"
diff: 省选/NOI-
pid: P7004
tag: ['2013', '交互题', 'Special Judge', 'ICPC']
---
# [NEERC 2013] Interactive Interception
## 题目描述

This is an interactive problem.

North Eastern Emergency Rocket Control agency (NEERC) has developed a new radar control system that is designed to better control ballistic rocket interception. To test the new system NEERC agency had developed a mathematical model that is intended to show this system’s abilities.

Let us represent a rocket as a point on a line. Initially the point is at some unknown integer location between $0$ and $p$, inclusive. It has some unknown speed of $q$ which is an integer between $0$ and $v$, inclusive.

Each second the following happens. First, the control system makes a query to the radar of a form “`check L R`” and gets an answer whether the point is currently between $L$ and $R$, inclusive, or not.

After that, the point’s coordinate increases by $q$.

The goal of the radar control system is to learn the exact location of the point at the beginning of some second. When it does learn the point’s location, then instead of making a query to the radar, it gives a command to intercept the point at that location.

You have to implement the control system that locates and intercepts the point while making at most $100$ queries to the radar.

### Interaction protocol
Interaction starts with your program reading two integers — the values of $p$ and $v$ from the standard input($1\leq p\leq 10^5$,$1\leq v\leq 10^5$).

After that your program must print commands to the standard output. Each command must be one of the following two.

- “`check L R`” — make a query to the radar to get an answer whether the point is currently between $L$ and $R$, inclusive, or not. The answer must be read from the standard input and is either “`Yes`” or “`No`”. After that the point’s coordinate is increased by $q$. $L$ and $R$ must be integers.
- “`answer x`” — the exact coordinate $x$ of the point is known, and you order to intercept the point. After printing this command your program must exit.

Your program must write end-of-line sequence and flush the standard output after each command, including the last command “`answer x`” (end-of-line must be written and flushed before exiting).


## 样例

### 样例输入 #1
```
2 2
Yes
No
Yes
Yes
```
### 样例输出 #1
```
check 1 3
check 3 5
check 2 4
check 4 5
answer 5
```
## 提示

In the given example the point was initially at location $1$ and is moving at a speed $q = 1$.
## 题目翻译

**这是一道交互题**。

平面上有一个点，初始位置 $x\in[0,p]$，速度 $q\in[0,v]$，其中 $p,v$ 是给定的。

你可以进行不超过 $100$ 次询问，形如 ``check L R``，满足 $0\le L\le R\le 10^9$，交互库会告诉你是否有 $x\in[L,R]$，每次询问之后，交互库会令 $x\gets x+q$。你需要在某个询问后确定此时的 $x$，并告诉交互库，格式形如 ``answer x``。

$1\le p,v\le 10^5$。


---

---
title: "[CERC2013] Rubik's Rectangle"
layout: "post"
diff: 省选/NOI-
pid: P7007
tag: ['2013', 'Special Judge', 'ICPC']
---
# [CERC2013] Rubik's Rectangle
## 题目描述

A new puzzle which aims to conquer the game market is a fusion of Rubik's Cube and Fifteen. The board is an $H \times W$ frame with tiles with all numbers from $1$ to $H · W$ printed on them.

![](/upload/images2/rubik1.png)

The only type of move that is allowed is flipping either one of the rows or one of the columns. Flipping reverses the order of the row's (or column's) elements. Below the third row is flipped:

![](/upload/images2/rubik2.png)

You are given a board with tiles numbered in some arbitrary order. Determine a sequence of flips that brings the board to the nicely sorted position, if possible.

![](/upload/images2/rubik3.png)


## 输入格式

The first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:

The description of each test case starts with an empty line. The next line contains two space-separated integers $W$ and $H (1 \leq W,H \leq 100) -$ the width and height of the puzzle, respectively. Each of the next $H$ lines contains $W$ space-separated integers $-$ the numbers printed on consecutive tiles.


## 输出格式

Print the answers to the test cases in the order in which they appear in the input. Start the output for each test case with the word POSSIBLE or IMPOSSIBLE, depending on whether it is possible to solve the puzzle. If a solution exists, print (in the same line) first the number of moves (possibly $0$) and then their descriptions, each consisting of a single letter $R$ or $C$ specifying whether we are to flip a row or a column, concatenated with the index of the row or column to flip.

Any solution will be accepted as long as it does not use more than $10 · W · H$ moves. Each test case is either solvable within this limit, or not solvable at all.


## 样例

### 样例输入 #1
```
4

3 3
1 2 3
4 5 6
9 8 7

4 2
1 2 3 4
5 6 7 8

4 4
1 2 15 4
8 7 11 5
12 6 10 9
13 14 3 16

3 4
1 2 4
3 5 6
7 8 9
10 11 12

```
### 样例输出 #1
```
POSSIBLE 1 R3
POSSIBLE 0
POSSIBLE 3 R3 C3 R2
IMPOSSIBLE

```
## 提示

Time limit: 6 s, Memory limit: 128 MB. 


## 题目翻译

有一个 $h\times w$ 的棋盘，每个位置上有一个在 $[1,h\times w]$ 的整数，且没有重复。每次操作可以翻转一行或一列（顺序上翻转）。

每个测试点共有 $T$ 组数据，每组数据都有 $h,w$ ，以及给定的 $h$ 行 $w$ 列的矩阵，要求对于每组数据，输出一行一个操作序列，使得操作后矩阵满足从上到下，从左到右递增。

如果无解，输出 `IMPOSSIBLE`。

如果有解，先输出 `POSSIBLE`，再输出操作序列的长度，然后输出操作序列。如果翻转第 $i$ 行，输出 `Ri`。如果翻转第 $i$ 列，输出 `Ci`，用空格隔开，中间不换行。

本题有 Special Judge, 操作序列长度不能超过 $10hw$。

$h,w \le 100$。


---

---
title: "[CERC2013] Escape"
layout: "post"
diff: 省选/NOI-
pid: P7011
tag: ['2013', 'ICPC']
---
# [CERC2013] Escape
## 题目描述



You hit the emperor lich with full force and slay it. There is a stair leading upwards here. You climb upstairs. You drink from the pool. You feel much better. The karmic lizard punches through your armor and hits you. You die...

After an epic fight with the emperor lich, the hero struggles to escape the dungeon consisting of $n$ chambers and $n − 1$ corridors connecting them. He starts in chamber number $1$ and must reach chamber number $t$ , moving only along the corridors. All chambers are reachable from chamber number $1$ . Bruised after the last fight, the hero starts the journey with $0$ hit-points $(HP).$ These points represent his health $-$ if ever they fall below zero, the hero's story ends there as a tragic one.

In some chambers there are monsters $-$ a monster must be fought, and it always manages to take some of the hero's HP. In some other chambers there are magic pools $-$ every pool restores some number of the hit-points. There is no upper limit on the hero's health. Every chamber can be visited multiple times, but the gain or loss of HP happens only once, on the very first visit.

Determine whether the hero can escape the dungeon alive.


## 输入格式



The first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:

The first line of each test case contains two integers: the number of chambers $n , 2 \le n \le 200 000$ , and the number of the exit chamber $t , 2 \le t \le n$ . The second line contains $n$ space separated integers between $-10^{6}$ and $10^{6} -$ the i-th of them denotes the HP gain in the i-th chamber (negative denotes a monster, positive $-$ a pool, and zero means that the chamber is empty). The first chamber does not contain a monster, but a pool is possible there. The exit chamber may contain a pool or a monster, and the monster will have to be fought before escaping.

The next $n−1$ lines contain the descriptions of corridors. Each one contains a pair of integers $-$ the ends of a corridor.


## 输出格式



For each test case print a single line containing the word escaped if escape is possible, or trapped otherwise.


## 样例

### 样例输入 #1
```
2
7 7
0 -3 2 2 3 -4 0
1 2
2 3
2 4
1 5
5 6
6 7
3 2
3 3 -4
1 3
2 3

```
### 样例输出 #1
```
escaped
trapped

```
## 提示

Time limit: 8 s, Memory limit: 128 MB. 


## 题目翻译

### 题目背景

在经历和巫妖王史诗级别的战斗后，英雄们想要从地牢中逃走。

### 题目描述

这个地牢是由 $n$ 个房间和 $n-1$ 条走廊连接组成的树状结构，英雄一开始在 $1$ 号房间，而且他只有抵达 $t$ 号房间才能逃离这个地牢。从 $1$ 号房间出发可以抵达任何一个其它的房间，可惜的是，在经历激烈的战斗后，英雄的精力使用完了，所以一开始该英雄的精力为 $0$，并且一旦英雄的精力低于 $0$，那么英雄就会当场逝世，以悲剧结束。在这些房间中，里面暗藏玄机，里面可能有怪兽，也有可能是可以补充精力的魔泉，当然也可能什么也没有，如果是怪兽，那么英雄就必须与它战斗从而消耗一些精力，如果是魔泉，那么英雄可以补充自己的精力。所有的怪兽只会战斗一次，所有的魔泉只能使用一次。（换句话说就是所有的精力的上升或者下降只会发生在第一次访问这个房间的时候）

英雄的精力没有上限，每一个房间都可以反复走多次。

### 输入格式

输入包括多组数据，第一行表示测试的数据的组数 $T$。

每一个测试用例的第 $1$ 行都包括两个整数 $n$ $(2 \le n \le 200000 )$ 和 $t$ $(2 \le t \le n)$，分别表示地牢的房间的数量和英雄必须到达的房间号。第二行是 $n$ 个整数，代表了 $n$ 个房间的情况，其中第 $i$ 个数代表了第 $i$ 个房间情况，所有的数的绝对值都不大于 $10^{6}$。如果该数是负数，表明该房间里面有怪兽，精力会减少，如果是正数，表明房间里面有魔泉，可以补充精力，如果是 $0$，表明房间里面空空如也。注意 $1$ 号房间不会有怪兽，但是有可能会有魔泉，$t$ 号房间可能怪兽或者魔泉，如果是怪兽，那么英雄必须要击败怪兽才能逃离。

在接下来的 $n-1$ 行中，每行两个整数 $a$ 和 $b$ ，表示房间 $a, b$ 之间有一条走廊连接。

### 输出格式

对于每一个测试用例都单行输出：

如果英雄能够逃脱，那么输出 `escaped`，否则输出 `trapped`。


---

---
title: "[CERC2013] History course"
layout: "post"
diff: 省选/NOI-
pid: P7013
tag: ['2013', 'Special Judge', 'ICPC']
---
# [CERC2013] History course
## 题目描述

You are to give a series of lectures on important historical events, one event per lecture, in some order. Each event lasted for some time interval $[a_i, b_i].$ We say that two events are related if their intervals have a common point. It would be convenient to schedule lectures on related events close to each other. Moreover, lectures on unrelated events should be given in the order in which the events have taken place (if an event A preceded an unrelated event $B$ , then the lecture on A should precede the lecture on $B)$ .

Find the minimum integer $k \ge 0$ and an order of the lectures such that any two related events are scheduled at most $k$ lectures apart from each other (lectures number $i$ and $j$ are considered to be $|i−j|$ lectures apart).
## 输入格式


The first line of input contains the number of test cases $t$ . The descriptions of the test cases follow:

The first line of each test case contains the number $n (1 \le n \le 50000)$ . Each of the next $n$ lines contains two integers $a_i$ and $b_i (-10^9  \le a_i \le b_i \le 10^9) $ - the ends of the i-th interval. The intervals are pairwise different.
## 输出格式


Print the answers to the test cases in the order in which they appear in the input. The first line of the answer to each test case should contain the minimum value of $k$ . The next $n$ lines should list the intervals (in the same format as in the input) in an order such that any two related events are scheduled at most $k$ lectures apart. Remember to put any unrelated intervals in the proper order! 
## 样例

### 样例输入 #1
```
1
3
1 6
2 3
4 5

```
### 样例输出 #1
```
1
2 3
1 6
4 5

```
## 提示

Time limit: 10 s, Memory limit: 128 MB. 

感谢 [hht2006](/user/175829) 提供的 Special Judge。
## 题目翻译

给定 $n$ 个区间，第 $i$ 个区间为 $[a_i,b_i]$。你需要把这些区间按某种顺序排列，使得两个区间如果没有交点，则左端点更小的区间需要排在前面。

设第 $i$ 个区间排在第 $p_i$ 个位置，定义区间 $i$ 与 $j$ 之间的距离为 $|p_i-p_j|$。令 $k$ 为任意两个相交的区间之间的最大距离，你需要最小化 $k$，并输出一组对应的合法顺序。

对于 $100\%$ 的数据，满足 $1\leq n\leq 5\times 10^4$，$0\leq|a_i|,|b_i|\leq10^9$。


---

---
title: "[CERC2013] Chain & Co."
layout: "post"
diff: 省选/NOI-
pid: P7014
tag: ['2013', 'ICPC']
---
# [CERC2013] Chain & Co.
## 题目描述



Chain $&$ Co. specializes in producing infinitely strong chains. Because of their high quality products, they are quickly gaining market share. This leads to new challenges, some of which they could have never imagined before. Like, for example, automatic verification of link endurance with a computer program, which you are supposed to write.

The company produces links of equal size. Each link is an infinitely thin square frame in three dimensions (made of four infinitely thin segments).

During tests all links are $axis-aligned^{1}$ and placed so that no two frames touch. To make a proper strength test, two sets of links A and $B$ are forged so that every link of A is inseparable from every link of $B$ (being inseparable means that they cannot be moved apart without breaking one of them).

You stumble upon some links (axis-aligned, pairwise disjoint). Are they in proper testing position? In other words, can they be divided into two non-empty sets A and $B$ with the desired property?

$^{1}Axis-aligned$ means that all segments are parallel to either $X , Y$ , or $Z$ axis.


## 输入格式



The first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:

The description of each test case starts with an empty line. The next line contains an integer $n , 1 \le n \le 10^{6} -$ the number of links in the chain. Each of the next $n$ lines contains $6$ space separated integers $x_{i}, y_{i}, z_{i}, x_{i}', y_{i}', z_{i}',$ all between $-10^{9}$ and $10^{9} -$ the coordinates of two opposite corners of the i-th link.


## 输出格式



For each test case, print a single line containing the word YES if the set is in proper testing position, or NO otherwise.


## 样例

### 样例输入 #1
```
3

2
0 0 0 0 10 10
-5 5 15 5 5 25

5
0 0 0 0 10 10
-5 5 6 5 5 16
-5 5 -6 5 5 4
-5 6 5 5 16 5
-5 -6 5 5 4 5

3
0 0 0 3 0 -3
1 -1 -1 1 2 -4
-1 -2 -2 2 1 -2

```
### 样例输出 #1
```
NO
YES
YES

```
## 提示

Time limit: 10 s, Memory limit: 128 MB. 


## 题目翻译

给定三维空间中 $n$ 个平行于坐标轴的空心 **正方形**，请判断是否有一种划分方案，使得所有矩形被划分为两个 **非空** 集合 $A,B$，且对于 $\forall i\in A,\forall j\in B$，矩形 $i,j$ 可以扣起来。

这里对“扣起来”的定义是：矩形 $A,B$ 各有一条边穿过另一个矩形，而它的对边则在另一个矩形外。可以尝试想象锁链环环相扣的样子。

不同矩形的边互不相交。多组数据，$n\le 10^6$。


---

---
title: "[CERC2013] Captain Obvious and the Rabbit-Man"
layout: "post"
diff: 省选/NOI-
pid: P7016
tag: ['2013', 'ICPC']
---
# [CERC2013] Captain Obvious and the Rabbit-Man
## 题目描述



It's you, Captain Obvious! - cried the evil Rabbit-Man - you came here to foil my evil plans!

Yes, it's me.  - said Captain Obvious.

But... how did you know that $I$ would be here, on $625$ Sunflower Street?! Did you crack my evil code?

I did. Three days ago, you robbed a bank on $5$ Sunflower Street, the next day you blew up $25$ Sunflower Street, and yesterday you left quite a mess under number $125$ . These are all powers of $5$ . And last year you pulled a similar stunt with powers of $13$ . You seem to have a knack for Fibonacci numbers, Rabbit-Man. 

That's not over! $I$ will learn... arithmetics! - Rabbit-Man screamed as he was dragged into custody - You will never know what to expect... Owww! Not my ears, you morons!

Maybe, but right now you are being arrested.  - Captain added proudly.

Unfortunately, Rabbit-Man has now indeed learned some more advanced arithmetics. To understand it, let us define the sequence $F_n$ (being not completely unlike the Fibonacci sequence):

$F_{1} = 1$ ,

$F_{2} = 2$ ,

$F_{n} = F_{n-1} + F_{n-2}$ for $n \ge 3$ .

Rabbit-Man has combined all his previous evil ideas into one master plan. On the i-th day, he does a malicious act on the spot number $p(i)$ , defined as follows:

$p(i) = a_{1}·F_{1}^{i} + a_{2}·F_{2}^{i} + \cdots + a_{k}·F_{k}^{i}.$

The number $k$ and the integer coefficients $a_1 , \cdots $ , ak are fixed. Captain Obvious learned $k$ , but does not know the coefficients. Given $p(1) , p(2) , \cdots , p(k)$ , help him to determine p(k $+ 1)$ . To avoid overwhelmingly large numbers, do all the calculations modulo a fixed prime number $M$ . You may assume that $F_1 , F_2 , \cdots , F_n$ are pairwise distinct modulo $M$ . You may also assume that there always exists a unique solution for the given input.


## 输入格式



The first line of input contains the number of test cases $T$ . The descriptions of the test cases follow:

The first line of each test case contains two integers $k$ and $M , 1 \le k \le 4000 , 3 \le M \le 10^{9}.$ The second line contains $k$ space-separated integers $-$ the values of $p(1) , p(2) , \cdots , p(k)$ modulo $M$ .


## 输出格式



Print the answers to the test cases in the order in which they appear in the input. For each test case print a single line containing one integer: the value of $p(k + 1)$ modulo $M$ .


## 样例

### 样例输入 #1
```
2
4 619
5 25 125 6
3 101
5 11 29

```
### 样例输出 #1
```
30
83

```
## 提示

Time limit: 6 s, Memory limit: 128 MB. 


## 题目翻译

众所周知，斐波那契数列的公式如下：

$$F_i=\begin{cases}1&i=1\\2&i=2\\F_{i-1}+F_{i-2}&i\geqslant 3\end{cases}$$

定义 $p_i=\sum\limits_{j=1}^ka_j\times F_j^i$。现在给定 $k,m$ 以及 $\{p_i\}_{i=1}^k$，请求出 $p_{k+1}\bmod m$。

Translated by Eason_AC  
2020.11.19


---

---
title: "[NWRRC 2017] Dividing Marbles"
layout: "post"
diff: 省选/NOI-
pid: P7022
tag: ['2017', 'Special Judge', 'ICPC']
---
# [NWRRC 2017] Dividing Marbles
## 题目描述



Debbie, Debby, Debra and Deborah are going to play a game with marbles together. Debbie has brought $2^{d_{1}}$ marbles, Debby -- $2^{d_{2}}$ marbles, Debra -- $2^{d3}$ marbles, while Deborah -- $2^{d4}$ marbles. The kids have gathered their marbles into a single pile containing $2^{d_{1}} + 2^{d_{2}} + 2^{d_{3}} + 2^{d_{4}}$ marbles, and the game is starting.

The game consists of turns. Each turn consists of two steps:

The kids choose any of their piles with more than one marble and divide it into two non-empty piles. That is, if the chosen pile contains $m \ge 2$ marbles, the new piles must contain $m_{1}$ and $m_{2}$ marbles where $m_1$ and $m_2$ are positive integers, and $m_{1} + m_{2} = m$ .

If there are several piles with the same number of marbles, only one of these piles is kept, while all the others with this number of marbles are discarded (thrown away).

The game ends when only one pile is left, and this pile contains a single marble. The goal of the game is to end it in the least possible number of turns. Note that the game is cooperative, that is, the kids aren't playing against each other, but trying to reach a common goal together.

Help the kids and find the best way to play.


## 输入格式



The first line of the input contains a single integer $T$ -- the number of test cases $(1 \le T \le 500)$ .

Each of the next $T$ lines describes one test case and contains four non-negative integers $d_{1}, d_{2}, d_{3}, d_{4} (0 \le d_{i} \le 20)$ .


## 输出格式



For each test case, output an integer $t$ -- the smallest number of turns required to end the game.

Then, output $t$ turn descriptions, in the order the turns should be made. Each description should consist of three integers $m , m_{1}, m_{2}$ -- the size of the divided pile and the sizes of the new piles, respectively $(m \ge 2$ ; $m_{1} > 0$ ; $m_{2} > 0$ ; $m_{1} + m_{2} = m)$ . Note that a pile of size $m$ must exist at that moment, and at the end of the game there should be only one pile left and that pile should contain a single marble.


## 样例

### 样例输入 #1
```
2
1 0 1 0
0 1 2 3

```
### 样例输出 #1
```
3
6 2 4
4 2 2
2 1 1
5
15 10 5
10 5 5
5 1 4
4 2 2
2 1 1

```
## 提示

Time limit: 3 s, Memory limit: 512 MB. 


## 题目翻译

**题目描述**

Debbie, Debby, Debra 和 Deborah要一起玩一个关于弹珠的游戏。Debbie 带来了  $2^{d_{1}}$ 颗弹珠, Debby 带来了  $2^{d_{2}}$ 颗弹珠, Debra 带来了  $2^{d3}$ 颗弹珠, 而 Deborah 带来了  $2^{d4}$ 颗弹珠。这些孩子们把他们的弹珠放在一起，总共有 $2^{d_{1}} + 2^{d_{2}} + 2^{d_{3}} + 2^{d_{4}}$ 颗, 游戏开始了。

游戏是多回合制。每一个回合包括两个步骤：

这些孩子们选择他们的任意一堆大于1个的弹珠然后分入两个大于0个的堆中。相当于，如果选中的那堆有 $m \ge 2$ 颗弹珠, 新的一堆必须要有 $m_{1}$ 和 $m_{2}$ 颗弹珠且 $m_1$ 和 $m_2$ 为正整数, 且 $m_{1} + m_{2} = m$.

如果有许多堆拥有同样数目的弹珠，只有一堆会被保留，其他的都会被丢弃。

当只有一堆弹珠被留下且这堆弹珠只有一颗时，游戏就结束了。游戏的目标就是用尽量少的回合让游戏结束。注意这个游戏是合作性质的，那就是，这些孩子不是互相争斗的，而是一起尝试达成同一个目标。

请帮助这些孩子找到游戏的最佳方案。

**输入格式**

第一行包括一个单独的整数，T 即测试用例的数量$(1≤T≤500)$ .

下面的每一行都描述一个测试用例且包含四个非负整数 $d_{1}, d_{2}, d_{3}, d_{4} (0 \le d_{i} \le 20)$

**输出格式**

对于每一个测试用例，输出一个整数t，即游戏结束所需的最少次数。

然后，按照回合的顺序，输出这些回合的说明。每一行说明都要包括三个整数 $ m , m_{1}, m_{2}$ 即是被分的堆和新堆的弹珠数量，依次为$(m≥2 ; m_{1} > 0; m_{2} > 0 ;  m_{1} + m_{2} = m)$ 

请注意大小为m的弹珠堆一定要存在，且在游戏结束时应该只剩下一堆且那一堆应该只有一颗弹珠。

**说明/提示**

时间限制: 3 s, 内存限制: 512 MB.


---

---
title: "[NWRRC 2017] Fygon 2.0"
layout: "post"
diff: 省选/NOI-
pid: P7024
tag: ['2017', 'ICPC']
---
# [NWRRC 2017] Fygon 2.0
## 题目描述



The new version of beloved programming language Fygon has been released! The brand new Fygon $2$ . $0$ still has only two statements. The first statement is lag. It substitutes almost any other statement. Second statement is a for loop:

```
for <variable> in range(<from>, <to>):
    <body>
```

The for loop makes iterate from to , both inclusive.

If is greater than , is not executed at all.

is a lowercase letter from a to $z$ , except for $n$ , which is a variable that is defined prior to the given code snippet.

and can be equal to any variable defined in outer loop. In addition to that, can be $1$ and can be $n$ .

The of the loop is indented by four spaces and contains at least one statement.

If you are familiar with Fygon $1$ . $0$ , you can notice that, in the spirit of the best programming practices, Fygon $2$ . $0$ is not backwards compatible, since the range function now requires two parameters.

The performance of the new version is significantly improved, so you can write more nested for loops. That is why we are no longer interested in the exact number of operations, but in the asymptotic complexity of the program instead. For simplicity, all for loops are nested in a single chain and there is exactly one lag statement that is inside all for loops. All loop variables are different and are not equal to $n$ .

Let's define $f(n)$ as the number of lag operations exectuted by a given Fygon program as the function of $n$ . For non-negative integer $k$ and positive rational number $C$ we say that $C · n^{k}$ is the asymptotic complexity of the program if

$$\lim_{n \to \infty}{\frac{f(n)}{C \cdot n^k}} = 1$$

Given a Fygon $2$ . $0$ program, find its asymptotic complexity.


## 输入格式



The first line of the input contains single integer $m$ -- the number of lines in Fygon $2$ . $0$ program. Next $m$ lines contain the program itself. The program has at least $1$ and at most $20$ for statements. Each for statement contains either single nested for statement or lag statement.


## 输出格式



Output numbers $k$ and $C$ . $C$ should be output in the form of irreducible fraction $p/q$ , where $p$ and $q$ are coprime.


## 样例

### 样例输入 #1
```
4
for i in range(1, n):
    for j in range(1, i):
        for k in range(j, n):
            lag
```
### 样例输出 #1
```
3 1/3

```
## 提示

Time limit: 3 s, Memory limit: 512 MB. 


## 题目翻译

卡老师新发明了一种语言：Fygon 2.0。这种语言只有两种语句：`lag` 和 `for`。其中 `for` 的格式如下：

```
for <variable> in range(<from>, <to>):
    <body>
```

- `<variable>` 是一个 `a` 到 `z` 之间的字符，但是不包括 `n`。
- `<from>` 和 `<to>` 是外面的循环中定义的变量。特别的,`<from>` 还可以是 `1`，`<to>` 还可以是 `n`。
- 这个语句表示 `<variable>` 从 `<from>` 循环到 `<to>`，两端均包含。
- 如果 `<from>` 大于 `<to>`，则该语句不会执行。
- 这里的 `<body>` 一定是一个 `for` 语句或者 `lag`，前面一定有 4 个空格的缩进。

卡老师随手写出了一个 Fygon 2.0 程序。因为他忙着去托老师的精神世界中写神题，所以这个程序的 `for` 语句数不超过 $20$ 个。

现在他想要计算这个程序的渐进时间复杂度。渐进时间复杂度定义如下：

> 定义 $f(n)$ 为 `lag` 的执行次数，若非负整数 $k$ 和正有理数 $C$ 满足
> 
> $$\lim_{n\to\infty}\frac{f(n)}{C\cdot n^k}=1$$
> 
> 则该程序的渐进时间复杂度为 $C\cdot n^k$。

卡老师看了一眼就算出来了，但是他想考考你，请你帮他求出这个程序的渐进时间复杂度。


---

---
title: "[NWRRC 2017] Grand Test"
layout: "post"
diff: 省选/NOI-
pid: P7025
tag: ['2017', 'Special Judge', 'ICPC']
---
# [NWRRC 2017] Grand Test
## 题目描述



Jeremy, Richard and James like to test cars. It is always hard for them to decide where they should do it. Usually car test looks like this. They choose a country and examine its cities and two-way roads that connect them. To perform a test, they need to choose two different cities $S$ and $F$ , such that there exist three routes between them. Moreover, each city except $S$ and $F$ should be visited by at most one route, and none of the roads may be used twice.

Then each of them takes a car in city $S$ , drives along one of those routes and tries to get to city $F$ faster than others.

You are given a description of multiple countries. For each country you should decide if it is possible to choose two cities and three routes between them in a way described above.


## 输入格式



The first line of the input contains a single integer $T$ -- number of countries $(1 \le T \le 100 000)$ . It is followed by $T$ country descriptions.

The first line of each country description contains two integers $n$ and $m$ -- the number of its cities and roads $(1 \le n , m \le 100 000)$ . The following $m$ lines contain two integer numbers each: $u_{i}$ and $v_{i}$ -- the cities at the ends of the road $(1 \le u_{i} < v_{i} \le n)$ . All roads are two-way. Each pair of cities is connected by at most one road.

Both the total number of cities and roads in all countries does not exceed $100 000$ .


## 输出格式



Output the answer for each country in the order they are given in the input.

If it is not possible to test cars in this country, the answer is $−1$ . Otherwise the first line of the answer should contain two integers $S$ and $F$ -- start and finish cities. The next three lines should contain three distinct routes. Each route is described by an integer $k$ -- the number of cities it visits, and $k$ numbers $v_{1}, v_{2}, \cdots , v_{k}$ -- the cities, where $v_{1} = S , v_{k} = F$ , and there is a road between cities $v_{i}$ and $v_{i+1}$ for all $1 \le i \le k − 1$ .


## 样例

### 样例输入 #1
```
2
6 6
3 6
3 4
1 4
1 2
1 3
2 3
3 1
1 2

```
### 样例输出 #1
```
1 3
3 1 2 3
2 1 3
3 1 4 3
-1

```
## 提示

Time limit: 3 s, Memory limit: 512 MB. 


## 题目翻译

**题目描述**  
给定一张 $n$ 个节点 $m$ 条边的无向图，请在图中找出两个点 $S$ 和 $F$，使得这两点间至少存在三条不相交的路径。

**输入格式**   
输入的第一行包数据组数 $T(1 \leq T \leq 100000)$。对于每组数据，第一行为两个整数 $n$ 和 $m$。接下来 $m$ 行每行包含两个整数 $u$ 和 $v(1 \leq u < v \leq n)$，表示节点 $u$ 和 $v$ 之间有一条边。每对节点至多被一条边连接。保证 $\sum n$ 及 $\sum m$ 不超过 $100000$。

**输出格式**  
对于每组数据，若不存在，则输出`-1`。若存在，则第一行输出 $S$ 和 $F$。接下来三行输出三条路径。每行先输出路径路径包含的点数，然后依次输出由 $S$ 到 $F$ 的路径上各点。


---

---
title: "[NWRRC 2017] Hidden Supervisors"
layout: "post"
diff: 省选/NOI-
pid: P7026
tag: ['2017', 'Special Judge', 'ICPC']
---
# [NWRRC 2017] Hidden Supervisors
## 题目描述



Helena works in a big company as a psychologist. Her task is to organize a team building game to enhance social relations between employees. Each employee except the Big boss has a single supervisor. So, employees of the company form a tree where each employee is a node, and the parent of that node is their supervisor. The root of the tree is the Big boss.

A team building game requires teams of two people. Every team should consist of an employee and their supervisor.

Helena asked every employee except the Big boss to send their supervisor ID. Some of them didn't reply. She is going to assign a fake supervisor to every employee that didn't reply, so that she could arrange as many teams as possible. And, of course, fake and real supervisors must form a tree.

Helena had a difficult, but a successful day organizing the event. Will you be able to assign fake supervisors?


## 输入格式



The first line of the input contains a single integer $n$ -- the number of employees in the company $(2 \le n \le 100 000)$ .

The following line contains $n − 1$ integers $p_{2}, p_{3},$ . . . , $p_{n},$ where $p_{i}$ is the supervisor of employee $i (0 \le p_{i} \le n)$ . If employee $i$ didn't reply to Helena, $p_{i}$ equals zero, and she needs to assign a fake supervisor to that employee. The Big boss has the number $1$ .

It's possible to assign a fake supervisor to each employee that didn't reply to Helena so that all employees will form a tree having the Big boss as a root.


## 输出格式



In the first line output a single integer $m$ -- the maximum possible number of arranged teams.

The next line should contain supervisors: $n−1$ integers, i-th of which denoting the supervisor of employee $i + 1$ (either fake or real). Of course, all real supervisors should be preserved, and employees must form a tree. It should be possible to arrange $m$ teams using specified supervisors.


## 样例

### 样例输入 #1
```
6
3 1 0 4 4

```
### 样例输出 #1
```
2
3 1 2 4 4

```
### 样例输入 #2
```
6
3 1 0 6 4

```
### 样例输出 #2
```
3
3 1 1 6 4

```
## 提示

Time limit: 3 s, Memory limit: 512 MB. 


## 题目翻译

## 题目简述

有一棵大小为 $n$ 的有根树，根为 $1$，其中若干结点的父亲没有确定。试求出所有可能构成的以 $1$ 为根的有根树中，最大匹配的最大值是多少，并输出构造方案。保证数据有解。

## 输入格式

第一行输入一个整数 $n$。

第二行输入 $n-1$ 个整数 $p_2,p_3,\cdots,p_n$，分别表示 $2,3,\cdots,n$ 的父亲。其中 $p_i = 0$ 表示点 $i$ 的父亲未确定，$p_i \neq 0$ 表示点 $i$ 的父亲已确定。

## 输出格式

第一行输出一个整数表示最大匹配的最大值。

第二行输出 $n-1$ 个整数 $p'_2,p'_3,\cdots,p'_n$，分别表示 $2,3,\cdots,n$ 的父亲。


---

---
title: "[NWRRC 2016] Boys and Girls"
layout: "post"
diff: 省选/NOI-
pid: P7032
tag: ['2016', 'Special Judge', 'ICPC']
---
# [NWRRC 2016] Boys and Girls
## 题目描述



Bob found a nice task in his old math book for children. It says:

There are $10$ children standing in a circle, $5$ of them stand next to a boy, and $7$ of them stand next to a girl. How is it possible?

Here is the solution to the task. If $4$ boys and $6$ girls stand like this: BGBGBGBGGG, there are $5$ children who stand next to a boy (here they are underlined: BGBGBGBGGG), and $7$ children who stand next to a girl $(BGBGBGBGGG).$

Now Bob wants to solve a generalized version of this task:

There are $n$ children standing in a circle, $x$ of them stand next to a boy, and $y$ of them stand next to a girl. How is it possible?

Help Bob by writing a program that solves the generalized task.


## 输入格式



The single line of the input contains three integers $n , x$ and $y (2 \le n \le 100 000$ ; $0 \le x , y \le n)$ .


## 输出格式



If there is a solution, output a string of length $n$ , describing the order of children in the circle. $Character ‘G'$ corresponds to a girl, character $‘B'$ corresponds to a boy. If there are several solutions, output any $of the_m.$

If there is no solution, output `Impossible`.


## 样例

### 样例输入 #1
```
10 5 7

```
### 样例输出 #1
```
BGBGBGBGGG

```
### 样例输入 #2
```
10 3 8

```
### 样例输出 #2
```
Impossible

```
## 提示

Time limit: 2 s, Memory limit: 256 MB. 


## 题目翻译

### 题目描述

Bob在他那本给孩子们的旧数学书中找到了一个好任务。上面写着：

有 $10$ 个孩子站成一个圆圈，其中 $5$ 个站在一个男孩旁边， $7$ 个站在一个女孩旁边。如何解决这个任务？

这个任务的解决方案如下：如果 $4$ 个男孩和 $6$ 个女孩像这样站着：$bgbgbbggg$，那么有 555 个孩子站在一个男孩旁边（用粗体字标记：b**g**b**g**b**g**b**g**g**g**）， 777 个孩子站在一个女孩旁边（用粗体字标记：**b**g**b**g**b**g**bggg**）。

现在Bob想解决这个任务的广义版本：

有 $n$ 个孩子站在一个圆圈里，其中 $x$ 个孩子站在一个男孩旁边， $y$ 个孩子站在一个女孩旁边。如何解决这个任务？

请编写一个程序来帮助Bob解决这个任务。

### 输入格式
一行，包括三个整数 $n$ , $x$ , $y$ 。($2≤n≤100000$; $0≤x,y≤n$) 

### 输出格式
若有解，输出一个长度为 $n$ 的字符串，描述圆中元素的顺序。每个字符 $G$ 对应一个女孩，字符 $B$ 对应一个男孩。如果有多个解决方案，则输出其中任意一种。
如果没有解决方案，输出```'Impossible'```
。（不包括引号）



---

---
title: "[NWRRC 2016] Easy Reading"
layout: "post"
diff: 省选/NOI-
pid: P7035
tag: ['2016', 'Special Judge', 'ICPC']
---
# [NWRRC 2016] Easy Reading
## 题目描述



Eugene is reading a boring book. To make this process interesting he is drawing a picture at the  same time.  He has a piece of graph paper that is divided into square cells. All the cells are empty at  the beginning. 

Eugene starts by painting over one cell. Then he opens the book at a random page and starts reading.   Whenever  he sees the letter  `u`  in the text, he moves his pen one cell up and then paints over the  cell under  his pen. Whenever he sees the letter  `d`,  he does the same but moves his pen one cell down  instead of  up. For letters  `l`  and  `r`  he moves to the left and to the right, respectively. If he wants to paint  a cell  that was already painted, he paints it again.

You have found a piece of paper and the text of the book. Now you want to understand if the picture  o_n the  paper could be drawn by Eugene at some point of his book reading. Remember that Eugene  could use  some substring of the text.


## 输入格式



The first line of the input contains an integer $l$ -- the length of the text $(1 \le l \le 100 000)$ . The $second line$ contains a string of length $l$ -- the text. It contains only lowercase English letters, spaces, commas and periods. The text neither begins nor ends with a space.

The third line contains two positive integers $n$ and $m$ -- the picture dimensions $(2 \le n \times m \le 100 000)$ .

Each of the following $n$ lines contains a string of length $m$ . Painted cells are denoted by `X`, while empty cells -- by `.` . It is guaranteed that there are at least two painted cells in the picture.

The first of these $n$ lines corresponds to the top of the picture and the last one corresponds to the bottom of it.


## 输出格式



If the picture could be painted by Eugene, output `YES` on the first line. On the second line print two integers b and $e$ such that if Eugene read all letters from $b$ to $e$ , inclusive, he would draw exactly $the same$ picture as described in the input $(1 \le b \le e \le l)$ . If there are several solutions, output any of them.

If the picture couldn't be drawn by Eugene, output `NO`.


## 样例

### 样例输入 #1
```
43
you should read statement really carefully.
3 6
...XX.
..XXX.
...XXX

```
### 样例输出 #1
```
YES
3 42

```
### 样例输入 #2
```
43
you should read statement really carefully.
3 2
XX
XX
XX

```
### 样例输出 #2
```
NO

```
## 提示

Time limit: 2 s, Memory limit: 256 MB. 

## 题目翻译

## 题目描述

Eugene正在读一本无聊的书。为了使阅读更有趣，他在阅读的同时同时作画。 他有一张方格纸。 所有的方格一开始都是空的。

Eugene一开始在一个方格上作画。让后他随机翻开一页并开始阅读。当他遇到字母 `u`  时, 他把笔向上移动一格并在这格上画画。 当他看到 `d`时, 他会做同样的操作，但是向下移动一格而不是向上移动一格。 `l` ,`r`分别是向左和向右一格。 如果这个单元格已经画过了他会再画一次。

现在你有一张纸与这本书中的内容。 现在你想知道这张纸上的图片是否可能被Eugene在某一时刻画过。 记住：Eugene可以只使用用这个内容的子字符串。

## 输入格式

第一行是一个整数$l(1 \le l \le 10^5)$--表示这个内容的长度。 

第二行是一个长度为$l$的字符串$a$。它只包含小写英文字母、空格、逗号和句号。$a$既不会以空格开头也不会以空格结尾。

第三行是两个整数$n$ 与 $m$--图的大小$(2 \le n \times m \le 10^5)$ 。

第$4$~$3+n$行，每行一个长度为$m$的字符串。画过的格子用`x`表示，没画过的用`.`表示。保证一幅图中至少有两个格子已被涂色。

这 $n$ 行字符串中的第一行对应于图片的顶部，最后一行对应于图片的底部。

## 输出格式

如果可能被绘制，第一行输出`YES`，第二行输出用空格隔开的两个整数$b$和$e$,表示Eugene从第$b$个字母开始读，到第$e$个字母结束(包含$b$和$e$)。

如果不能，输出`NO`。

## 样例 #1

### 样例输入 #1

```
43
you should read statement really carefully.
3 6
...XX.
..XXX.
...XXX
```

### 样例输出 #1

```
YES
3 42
```

## 样例 #2

### 样例输入 #2

```
43
you should read statement really carefully.
3 2
XX
XX
XX
```

### 样例输出 #2

```
NO
```

## 说明/提示

时限: 2 s, 内存限制: 256 MB.


---

---
title: "[NWRRC 2016] Gangsters in Central City"
layout: "post"
diff: 省选/NOI-
pid: P7037
tag: ['2016', 'ICPC']
---
# [NWRRC 2016] Gangsters in Central City
## 题目描述



For a long time, there were no problems with water in Central City. The sewage of the city has a form of a rooted tree: the central reservoir is situated at the root and the houses are at the leaves. The water flows from the central reservoir to the houses by the pipes that runs along the edges of the tree. Each house has an access to water.

Suddenly, gangsters captured some of the houses. As a mayor of the city you are very concerned, and you want to kick out the gangsters. So you want to stop the water flow to houses captured by the gangsters.  To do that you could clog some pipes of the sewage system. If the path from the reservoir to a house contains at least one clogged pipe, the house does not have an access to water.

You are very afraid of the gangsters, so you decided to clog up the minimal number of pipes, that it could look like an accident. At the same time, you care about the citizens, so for the chosen number of clogged pipes, you want to minimize the number of houses without gangsters and access to water.

Unfortunately, the gangsters could appear and disappear from some houses. So, you are asking the scientists about the minimum required number of clogged pipes and the minimum required number of houses without gangsters and access to water after each change in the gangsters' location.


## 输入格式



The first line of the input contains two integers $n$ and $q$ -- the number of vertices in the tree which represents the sewage and the number of changes in the location of the gangsters $(2 \le n \le 100 000$ ; $1 \le q \le 100 000)$ .

The second line contains the description of the sewage: a sequence of $n − 1$ integers $p_{2}, p_{3},$ . . . , $p_{n}$, where $p_{i} is$ the parent of the vertex $i (1 \le p_{i} < i)$ . The central reservoir is located at the vertex $1$ .

The next $q$ lines represent the changes in the location of the gangsters. Each change could be one of two different types: 

- `+ v` -- the gangsters capture the house at vertex $v$ ; 
- `- v` -- the gangsters leave the house at vertex $v$ .

At the beginning all the houses are free of gangsters. All the changes form the correct sequence: the gangsters cannot capture the house if it is already captured and the gangsters could not leave the house if it is not captured.


## 输出格式



The output should contain 2q integers, two in each line: $c_{i}$ -- the minimum number of clogged pipes and $h_{i}$ -- the minimum number of houses without gangsters and have no access to water for the chosen $c_{i}$

.


## 样例

### 样例输入 #1
```
7 6
1 2 1 3 3 3
+ 4
+ 5
+ 6
+ 7
- 6
- 5

```
### 样例输出 #1
```
1 0
2 0
2 1
2 0
2 1
2 0

```
## 提示

Time limit: 2 s, Memory limit: 256 MB. 


## 题目翻译

给出一棵含有 $n$ 个节点的，且 $1$ 为根节点的树，叶子节点都是房屋，让你在一个集合里面进行添加房屋和移除房屋的操作。

每一次添加和移除后，你将要回答下面两个问题：

1.  最少需要砍多少条边，才能使已选房屋都不能从根节点到达。

2.  在第 $1$ 问的条件下，如何砍边使从根节点点开始走不能到达的非已选房屋数目最小，输出最小值。


---

---
title: "「MCOI-03」诗韵"
layout: "post"
diff: 省选/NOI-
pid: P7046
tag: ['O2优化', '洛谷月赛']
---
# 「MCOI-03」诗韵
## 题目背景

$\texttt{And the game was over and the player woke up from the dream. }$

游戏结束了，玩家从梦中醒来。

$\texttt{And the player began a new dream. }$

并开始了新的梦境。

$\texttt{And the player dreamed again, dreamed better.}$

并再次沉入梦境中，沉入更好的梦。

$\texttt{And the player was the universe. And the player was love.}$

而玩家就是宇宙。而玩家就是爱。

$\texttt{You are the player.}$

你就是那个玩家。


$\texttt{Wake up.}$


该醒了。
## 题目描述

小 C 想要写首诗文，但是写诗需要押韵。

一首诗文是由需多句子组成，这些句子需要押韵。

但押韵也有优劣。小 C 对押韵有一个评分。评分定义为这些句子的最长公共后缀长度，而韵脚被定义为这些句子的公共后缀。韵脚可以为空串，一个集合的韵脚可以有多个。

最开始，小 C 一个句子也没有写出来。即最开始的记忆集合为空。

小 C 会思考 $M$ 个时刻。每个时刻，他会想出一个句子。即向记忆集合中加入一个新的句子。

小 C 可能会加入多个相同的句子，请只保留一个。因为他的记忆力很好，所以他想到的句子不会被遗忘。

但是他不想花太多心思去造句，所以他认为，只要有 **大于** $K$ 个句子，就能写成一首诗。所以每想出一个句子后，他会向你询问集合所有的元素个数 $>K$ 的子集的评分的最大值，和集合所有元素个数 $>K$ 的子集的韵脚的种类。注意：如果有多个不同的满足条件的集合韵脚相同，则这个韵脚只能计算一次。

由于小 C 很强，所以他造的所有句子的总长度可能非常大。为了方便告诉你这些句子，他造的每一个句子都是长度为 $N$ 的母串 $T$ 的子串。

**注意**：集合是满足特异性的，即集合中的元素应该互不相同，如果有相同元素仅保留一个。
## 输入格式

第一行包括三个整数 $N,M,K$。


第二行包括一个长度为 $N$ 的字符串，即母串 $T$。   


接下来 $M$ 行，每行两个整数 $l,r$，表示当前时刻 小C 想起的句子是母串的 $[l,r]$ 子串。
## 输出格式

$M$ 行每行两个整数。第一个整数指不同的韵脚个数，第二个整数指评分的最大值。
## 样例

### 样例输入 #1
```
5 5 1
ababa
1 2
2 3
1 3
1 4
2 5
```
### 样例输出 #1
```
0 0
1 0
3 2
5 2
6 3
```
## 提示

#### 样例解释

第一个时刻后，记忆集合为 $\{\texttt{"ab"}\}$。没有子集满足条件，输出 $0\ 0$。

第二个时刻后，记忆集合为 $\{\texttt{"ab","ba"}\}$。能得到的韵脚只有空串。

第三个时刻后，记忆集合为 $\{\texttt{"ab","ba","aba"}\}$。能得到的韵脚有空串，$\texttt{"a"}$，$\texttt{"ba"}$。

第四个时刻后，记忆集合为 $\{\texttt{"ab","ba","aba","abab"}\}$。能得到的韵脚有空串，$\texttt{"a"}$，$\texttt{"ba"}$，$\texttt{"b"}$，$\texttt{"ab"}$。

第五个时刻后，记忆集合为 $\{\texttt{"ab","ba","aba","abab","baba"}\}$。能得到的韵脚有空串，$\texttt{"a"}$，$\texttt{"ba"}$，$\texttt{"b"}$，$\texttt{"ab"}$，$\texttt{"aba"}$。

#### 数据规模和约定

**本题采用捆绑测试。**

| 子任务编号 | $N\le$ | $M\le$ |  时限 | 分值 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $10$ | $\rm1s$ | $15$ |
| $2$ | $ 10^3$ | $10^3$  | $\rm 1s$ | $20$ |
| $3$ | $10^5$ | $10^5$  | $\rm 1s$ | $25$ |
| $4$ | $ 5\times 10^5$ | $5\times 10^5$ | $\rm 2.33s$ | $40$ |

对于 $100\%$ 的数据，$1 \le N\le 5\times 10^5$，$1 \le M\le   5 \times 10^5，0\le K \le M$。仅包含小写字母。



---

---
title: "[NWRRC 2014] Combinator Expression"
layout: "post"
diff: 省选/NOI-
pid: P7062
tag: ['2014', 'ICPC']
---
# [NWRRC 2014] Combinator Expression
## 题目描述

Combinatory logic may be thought as one of computational models allowing to express any computable function as a composition of functions from a small finite basis. In this problem we consider a restricted variant of BCKW basis, BCKI.

Combinator expression in BCKI basis is a string, corresponding to the following grammar:

```plain
⟨Expression⟩ ::= ⟨Expression⟩ ⟨Term⟩ | ⟨Term⟩
⟨Term⟩ ::= ‘(’⟨Expression⟩‘)’ | ‘B’ | ‘C’ | ‘K’ | ‘I’
```

As we can see from the grammar, the expression is a tree of applications where leafs are combinators $B, C, K$ and $I$. The application is left-associative. For example $BIC$ is equivalent to $(BI)C,$ but not to $B(IC)$.

For the sake of the explanation we will use lowercase English letters $(a \cdots z)$ to represent sub-expressions. These lowercase letters will not appear in real data. For example, $BIC$ can be represented by $BxC$ (that is, $B\underbrace { I }_{ x }C)$, $x(\underbrace {BIC}_{ x })$, $xy(\underbrace {BI}_{ x } \underbrace { C }_{ y })$, $Bxy (B\underbrace { I }_{ x }\underbrace { C }_{ y })$, but not by $Bx$.

We say that in expression $pq$ we apply $p$ to $q$. We can employ our intuition by saying that $p$ is a function and $q$ is its parameter. However, the evaluation process is quite different from traditional computation — instead of passing values over fixed expression tree, we evaluate by altering that tree so that the result is also some combinator expression.

To evaluate an expression, we need to select some sub-expression, corresponding to one of the patterns specified in the table below — that is, there should exist such $x$ (and maybe $y$ and $z$) that the pattern from the table becomes equal to the sub-expression. Then we need to replace the sub-expression with the reduction result from the table.

| Pattern | Reduction result |                   Description                   |
| :-----: | :--------------: | :---------------------------------------------: |
| $Bxyz$  |     $x(yz)$      | Composition function (Zusammensetzungsfunktion) |
| $Cxyz$  |     $(xz)y$      |    Exchange function (Vertauschungsfunktion)    |
|  $Kxy$  |       $x$        |      Constant function (Konstanzfunktion)       |
|  $Ix$   |       $x$        |     Identity function (Identitätsfunktion)      |

After the replacement took place we must repeat the process, until there remains no suitable subexpressions. This final expression is normal form of the original one. For example, in expression $CIC(CB)I$ we can make the following letter assignment

$$\underbrace { C }_{ C }\underbrace { I }_{ x }\underbrace { C }_{ y }\underbrace {(CB)}_{ z }I$$

and see that $CIC(CB)I ≡ (((CI)C)(CB))I ≡ (((Cx)y)z)I$ contains $C$ combinator pattern and thus reduces to $((xz)y)I ≡ I(CB)CI:$

$$(\underbrace { C }_{ C }\underbrace { I }_{ x }\underbrace { C }_{ y }\underbrace { (CB) }_{ Z })I \rightarrow (\underbrace { I }_{ x } \underbrace {(CB)}_{ z }\underbrace { C }_{ y })I$$

One more example: $B((CK)I)IC$ expression. Let us first reduce combinator $B:$

$$(\underbrace { B }_{ B }\underbrace { ((CK)I) }_{ x }\underbrace { I }_{ y }\underbrace { C }_{ z } \rightarrow \underbrace { ((CK)I) }_{ x } (\underbrace { I }_{ y }\underbrace { C }_{ z })$$

Now, let's reduce the last $I:$

$$((CK)I)(\underbrace { I }_{ I } \underbrace { C }_{ x }) \rightarrow ((CK)I)C$$

And now we finish evaluation with two more reductions:

$$((\underbrace { C }_{ C }\underbrace { K }_{ x }) \underbrace { I }_{ y }) \underbrace { C }_{ z } \rightarrow (\underbrace { K }_{ K }\underbrace { C }_{ x }) \underbrace { I }_{ y } \rightarrow C$$

It is possible to show that the normal form remains the same irrespectable to the order of evaluation. For example, the following evaluation order:

$$C(K(II)(\underbrace { I }_{ I }\underbrace { C }_{ x })) \rightarrow C(K(\underbrace { I }_{ I }\underbrace {  I}_{ x })(C)) \rightarrow C((\underbrace { K }_{ K }\underbrace { I }_{ x }) \underbrace { C }_{ y }) \rightarrow CI$$

leads to the same result as 

$$C(K(\underbrace {I}_{ I }\underbrace { I }_{ x })(IC)) \rightarrow C((\underbrace { K }_{ K }\underbrace { I }_{ x })\underbrace { (IC)}_{ y }) \rightarrow CI$$

However, as you see, the number of reductions is different: $3$ in the first case and $2$ in the second. This poses an interesting problem -- to find an evaluation order with the minimal number of reductions for a given formula.

Your task is to write a program which finds the minimal number of reductions required for a given combinator expression to be evaluated to its normal form.
## 输入格式



The only line of the input file contains a combinator expression corresponding to the grammar above. The length of the expression does not exceed $30 000$ . The expression contains no whitespaces or symbols not specified in the grammar.


## 输出格式



Output a single integer — the minimal number of reductions required for the given formula to evaluate it to normal form.


## 样例

### 样例输入 #1
```
C(K(II)(IC))

```
### 样例输出 #1
```
2

```
### 样例输入 #2
```
CIBI

```
### 样例输出 #2
```
3

```
### 样例输入 #3
```
BBBBBCCCCCKKKKKIIIII

```
### 样例输出 #3
```
15

```
## 提示

Time limit: 1 s, Memory limit: 256 MB. 


## 题目翻译

## 题目背景

## 题目描述
组合逻辑可以看作是一种计算模型，允许将任何可计算函数表示为从小的有限基底中选取的函数的组合。在这个问题中，我们考虑 BCKW 基底的一个受限变体，即 BCKI。

BCKI 基底中的组合表达式是一个字符串，对应于以下文法：

```plain
⟨表达式⟩ ::= ⟨表达式⟩ ⟨项⟩ | ⟨项⟩
⟨项⟩ ::= ‘(’⟨表达式⟩‘)’ | ‘B’ | ‘C’ | ‘K’ | ‘I’
```

从文法可以看出，表达式是应用树，叶子是组合子 $B, C, K$ 和 $I$。应用是左结合的。例如，$BIC$ 等价于 $(BI)C$，但不等价于 $B(IC)$。

为了便于解释，我们将使用小写英文字母 $(a \cdots z)$ 来表示子表达式。这些小写字母不会出现在实际数据中。例如，$BIC$ 可以表示为 $BxC$（即 $B\underbrace { I }_{ x }C$），$x(\underbrace {BIC}_{ x })$，$xy(\underbrace {BI}_{ x } \underbrace { C }_{ y })$，$Bxy (B\underbrace { I }_{ x }\underbrace { C }_{ y })$，但不能表示为 $Bx$。

在表达式 $pq$ 中，我们说将 $p$ 应用于 $q$。我们可以用直觉来理解，$p$ 是一个函数，而 $q$ 是它的参数。然而，求值过程与传统的计算非常不同——不是通过固定表达式树传递值，而是通过改变树结构，使得结果也是一个组合表达式。

为了求值一个表达式，我们需要选择一个子表达式，该子表达式应符合下表中的某个模式——也就是说，应该存在这样的 $x$（可能还有 $y$ 和 $z$），使得表中的模式与子表达式相等。然后我们需要将子表达式替换为表中的简化结果。

| 模式  | 简化结果 | 描述                           |
| :---: | :-------: | :-----------------------------: |
| $Bxyz$ | $x(yz)$  | 组合函数（Zusammensetzungsfunktion） |
| $Cxyz$ | $(xz)y$  | 交换函数（Vertauschungsfunktion）   |
| $Kxy$  | $x$      | 常数函数（Konstanzfunktion）       |
| $Ix$   | $x$      | 恒等函数（Identitätsfunktion）     |

替换完成后，我们必须重复这个过程，直到没有合适的子表达式为止。这个最终表达式就是原始表达式的规范形式。例如，在表达式 $CIC(CB)I$ 中，我们可以进行如下字母分配

$$\underbrace { C }_{ C }\underbrace { I }_{ x }\underbrace { C }_{ y }\underbrace {(CB)}_{ z }I$$

并看到 $CIC(CB)I ≡ (((CI)C)(CB))I ≡ (((Cx)y)z)I$ 包含了 $C$ 组合子模式，因此简化为 $((xz)y)I ≡ I(CB)CI:$

$$(\underbrace { C }_{ C }\underbrace { I }_{ x }\underbrace { C }_{ y }\underbrace { (CB) }_{ Z })I \rightarrow (\underbrace { I }_{ x } \underbrace {(CB)}_{ z }\underbrace { C }_{ y })I$$

另一个例子：$B((CK)I)IC$ 表达式。让我们先简化组合子 $B:$

$$(\underbrace { B }_{ B }\underbrace { ((CK)I) }_{ x }\underbrace { I }_{ y }\underbrace { C }_{ z } \rightarrow \underbrace { ((CK)I) }_{ x } (\underbrace { I }_{ y }\underbrace { C }_{ z }))$$

现在，让我们简化最后一个 $I:$

$$((CK)I)(\underbrace { I }_{ I } \underbrace { C }_{ x }) \rightarrow ((CK)I)C$$

最后，我们通过两次更多的简化完成求值：

$$((\underbrace { C }_{ C }\underbrace { K }_{ x }) \underbrace { I }_{ y }) \underbrace { C }_{ z } \rightarrow (\underbrace { K }_{ K }\underbrace { C }_{ x }) \underbrace { I }_{ y } \rightarrow C$$

可以证明，无论求值顺序如何，规范形式都是一样的。例如，以下求值顺序：

$$C(K(II)(\underbrace { I }_{ I }\underbrace { C }_{ x })) \rightarrow C(K(\underbrace { I }_{ I }\underbrace {  I}_{ x })(C)) \rightarrow C((\underbrace { K }_{ K }\underbrace { I }_{ x }) \underbrace { C }_{ y }) \rightarrow CI$$

和

$$C(K(\underbrace {I}_{ I }\underbrace { I }_{ x })(IC)) \rightarrow C((\underbrace { K }_{ K }\underbrace { I }_{ x })\underbrace { (IC)}_{ y }) \rightarrow CI$$

得到的结果相同。然而，如你所见，简化的次数不同：第一个情况下为 $3$ 次，第二个情况下为 $2$ 次。这提出了一个有趣的问题——找到一个给定公式所需的最小简化次数。

你的任务是编写一个程序，找到给定组合表达式求值到其规范形式所需的最小简化次数。

## 输入格式
输入文件只有一行，包含一个符合上述文法的组合表达式。表达式的长度不超过 $30 000$。表达式中不含空格或文法未指定的符号。

## 输出格式
输出一个整数——给定公式求值到规范形式所需的最小简化次数。

## 数据范围与提示
时间限制：1 秒，内存限制：256 MB。


---

---
title: "[NWRRC 2014] Fragmentation"
layout: "post"
diff: 省选/NOI-
pid: P7065
tag: ['2014', 'Special Judge', 'ICPC']
---
# [NWRRC 2014] Fragmentation
## 题目描述



Felix is working on a startup project in his garage. He has already found a great name for his project: SuperFastZilla. By now he is not sure what SuperFastZilla should do, but he is pretty sure it should do it fast, super fast.

Once he noticed that SuperFastZilla is working too slow, inspite of the fast algorithms used in it. Felix thinks that the problem may be caused by storage fragmentation.

The storage used by SuperFastZilla consists of $n$ blocks of memory. SuperFastZilla performs some operations on this storage. Each block is used in one operation only, the i-th block is used in the $a_{i}$-th operation.

Felix wants to sort these blocks by the index of the operation they are used. To make it faster, Felix wants to split the storage into minimal number of segments of consecutive blocks, and then rearrange these segments to get the sorted array of blocks. After this rearrangement the order of block's indices of operations must be non-decreasing.

Help Felix to find the way to split the storage that minimizes the number of segments.

For example, if $a = [2 , 3 , 1 , 1 , 2 , 2 , 1],$ it can be split into three parts: $[2 , 3], [1 , 1 , 2 , 2]$ and $[1].$ These parts can be rearranged to make the sorted array: $[1], [1 , 1 , 2 , 2], [2 , 3].$


## 输入格式



The first line of input file contains an integer $n (1 \le n \le 10^{5}).$ The next line contains $n$ integers $a_{i} (1 \le a_{i} \le 10^{5}).$


## 输出格式



The first line of the output file must contain an integer number $m$ — the minimal number of segments.

The next line must contains $m$ integers, the lengths of the segments, from left to right.


## 样例

### 样例输入 #1
```
7
2 3 1 1 2 2 1

```
### 样例输出 #1
```
3
2 4 1

```
## 提示

Time limit: 2 s, Memory limit: 256 MB. 


## 题目翻译

给定一个长度为 $n$ 的数组，你需要把它分成尽量少的段，使得你可以排列这些段令整个数组有序。


$n,a_i \le 10^5$


---

---
title: "[NWRRC 2013] Correcting Curiosity"
layout: "post"
diff: 省选/NOI-
pid: P7081
tag: ['2013', 'Special Judge', 'ICPC']
---
# [NWRRC 2013] Correcting Curiosity
## 题目描述



Curiosity is the rover that explores the Gale Crater on Mars. Recently it found an evidence of water in Martian soil, which will make it easier to plan the future manned missions. $ $

Curiosity can communicate with Earth directly at speeds up to $32 Kbit/s$ , but on average $14$ minutes and $6$ seconds will be required for signals to travel between Earth and Mars.

`You have just seen a stone and applied brakes, but you know that the rover is already passing that stone` -- Matt Heverly, the rover's driver, explains. `So we just plan the route, then write down a list of simple textual commands: move one meter ahead, turn left, make a photo and so on`.

Sometimes it is necessary to react very fast to some unexpected events. For example, if the cameras have seen something interesting, then you might want to change the route of the rover to make an additional photo. To do that, you send a substitution command of the form $s/〈string〉/〈replacement〉/g$ . This replaces all occurrences of $〈string〉,$ starting with the leftmost one, to $〈replacement〉.$

More formally, if A is a non-empty string and $B$ is a string, then to apply the substitution command $s/A/B/g$ to a string $S$ , you should do the following:

Find the leftmost occurrence of A in $S$ , such that $S =$ SL $+$ A $+$ SR.

If there is no such occurrence, stop. Then, $S$ is the answer.

Let $R$ be the result of applying $s/A/B/g$ to SR.

The answer is SL $+ B + R$ .

This means that:

If there are two overlapping occurrences of A in $S$ , only the leftmost one is replaced. For example, applying $`s/aba/c/g`$ to `abababa` yields `cbc`: after replacing the first occurrence of `aba` the string turns to `cbaba`, and only the last occurrence of `aba` can be replaced after that.

No substitution uses the results of previous substitutions. For example, applying $`s/a/ab/g`$ to `a` yields `ab`, applying $`s/a/ba/g`$ to `a` yields `ba`.

You know that the longer is the command, the bigger is the time necessary to transmit it. So, you have to write a program that finds shortest command that transforms the initial string to the final string.


## 输入格式



The first line contains the initial and the final strings. Both strings are non-empty and their lengths do not exceed $2000$ characters. The strings contain only English letters, spaces and punctuation signs (commas, colons, semicolons and hyphens: $‘,', ‘:', ‘;', ‘-').$ The given strings are not equal.


## 输出格式



Output the substitution command that transforms initial string to final string and has the minimum length. If there are several shortest substitution commands, output any of them.


## 样例

### 样例输入 #1
```
move left, move right; move up
move left, move down, move up

```
### 样例输出 #1
```
s/right;/down,/g

```
### 样例输入 #2
```
If not found: move x; else move -x
If found: move x; else move -x

```
### 样例输出 #2
```
s/ not//g

```
### 样例输入 #3
```
abababa
cbc

```
### 样例输出 #3
```
s/aba/c/g

```
## 提示

Time limit: 2 s, Memory limit: 256 MB. 


## 题目翻译

# [NWRRC2013] Correcting Curiosity

## 题目描述

“好奇号”是探索火星上盖尔陨石坑的火星车。最近，它在火星土壤中发现了水存在的证据，这将使未来的火星登陆任务变得更加容易。$ $

“好奇号”可以用高达$32 Kbit/s$的速度与地球直接通信 ，但在地球和火星之间传输信号分别平均需要$14$秒和$6$秒。

`你刚刚看到一块石头并踩下了刹车，但你知道火星车已经经过那块石头了` -- 火星车司机Matt Heverly解释道。`所以我们需要规划路线，然后写下一个简单的命令列表：如向前移动一米，左转，拍照等等`.

有时你有必要对一些突发事件做出非常迅速的反应。例如，当相机看到了一些有趣的东西，那么你可能会想改变火星车的路线来拍摄的照片。为此，您需要发送一个形式为 $s/〈string〉/〈replacement〉/g$ . 这将替换所有出现的 $〈string〉,$ 从最左边的开始, 到 $〈replacement〉.$

更确切地说，如果A是非空字符串，而$B$是字符串, 则要将替换命令$s/A/B/g$应用于字符串$s$，执行以下操作：

在$S$中查找最左边出现的A，这样$S=$SL$+$A$+$SR。

如果没有A，请停止操作。$S$就是答案。

让$R$成为对SR应用$s/A/B/g$的结果。

那么答案是SL$+B+R$。

这就说明:

如果在$S$中有两个重叠的A，那么只替换最左边的一个。例如，将$`s/aba/c/g`$应用于`abababa`会产生`cbc`：在替换第一个`aba `之后，字符串将变为`cbaba `，在此之后只能替换最后一个出现的` aba `。

如果没有替换就使用先前替换的结果。例如，将$`s/a/ab/g`$应用于`a`产生`ab`，将$`s/s/a/ba/g`$应用于`a`产生`ba`。

命令越长，传输它所需的时间就越长。因此，需要你编写一个程序，找到最短的命令，将初始字符串转换为最终字符串。

## 输入格式

第一行输入包含初始字符串和最终字符串。这两个字符串都不是空的，并且它们的长度不超过$2000$。字符串仅包含英文字母、空格和标点符号（逗号、冒号、分号和连字符：$'，'，'：'，'；'，'-'）。$给定的字符串不相同。

## 输出格式

输出将初始字符串转换为最终字符串并最短的替换命令。如果有多个最短的替换命令，请输出其中任何一个。

## 样例 #1

### 样例输入 #1

```
move left, move right; move up
move left, move down, move up
```

### 样例输出 #1

```
s/right;/down,/g
```

## 样例 #2

### 样例输入 #2

```
If not found: move x; else move -x
If found: move x; else move -x
```

### 样例输出 #2

```
s/ not//g
```

## 样例 #3

### 样例输入 #3

```
abababa
cbc
```

### 样例输出 #3

```
s/aba/c/g
```

## 提示

时间限制: 2 s, 内存限制: 256 MB.


---

---
title: "[NWRRC 2013] Heavy Chain Clusterization"
layout: "post"
diff: 省选/NOI-
pid: P7086
tag: ['2013', 'Special Judge', 'ICPC']
---
# [NWRRC 2013] Heavy Chain Clusterization
## 题目描述



A group of biologists is trying to find a cure for a viral disease. They have tried many antibodies of various origins that could potentially fight the viral antigens, and have selected $n$ antibodies that seem to work best during experiments.

Each antibody is identified by its heavy chain -- a sequence of amino acids.

The set of antibodies form a similarity cluster, if at least one of the following holds:

k-prefixes (first $k$ amino acids) of all their heavy chains are equal;

k-suffixes (last $k$ amino acids) of all their heavy chains are equal.

In order to simplify the future research, biologists want to group antibodies to similarity clusters.

You need to split the given antibodies to a minimum number of similarity clusters.


## 输入格式



The first line contains two integers $n$ and $k$ -- the number of heavy chains and the length of sequence of amino acids to coincide $(1 \le n \le 5 000 , 1 \le k \le 550)$ .

The following $n$ lines contain sequences of amino acids that form heavy chains of antibodies. Each amino acid described with an uppercase English letter. Each heavy chain contains at least $k$ and no more than $550$ amino acids.


## 输出格式



The first line of output must contain a single integer -- the minimum number of similarity clusters. The following lines must contain descriptions of clusters, one per line.

Each description starts with $m_i$ -- the number of antibodies in the cluster and is followed by $m_i$ integers -- numbers of these antibodies. Antibodies are numbered in the order of appearance in the input starting from one.

Each antibody must be present in exactly one cluster.


## 样例

### 样例输入 #1
```
4 1
AA
AB
BB
BA

```
### 样例输出 #1
```
2
2 1 2
2 3 4

```
### 样例输入 #2
```
3 2
ABA
BAB
XY

```
### 样例输出 #2
```
3
1 1
1 2
1 3

```
## 提示

Time limit: 2 s, Memory limit: 256 MB. 


## 题目翻译

现有$n$个抗生素，每一个抗生素都可以通过它的一个氨基酸序列被辨认。

如果有一组抗生素满足以下任意一个条件，这些抗生素才可以形成一个“相似群体”：

1. 组内所有抗生素的氨基酸序列的前$k$个氨基酸元素组成的序列全部相同

2. 组内所有抗生素的氨基酸序列的后$k$个氨基酸元素组成的序列全部相同

特别的，一种抗生素可以成为一个相似群体。

为了简化后续研究，生物学家们想要给抗生素分类，使得这$n$个抗生素被分成若干个相似群体。你需要找出一种方案，使得分类后的相似群体数量最少。

------

第一行包含两个正整数，$n$和$k$，含义如题意描述。（$1≤n≤5000，1≤k≤550$）

接下来有$n$行，每行包含一个氨基酸序列。氨基酸序列被描述为由大写英语字母组成的字符串，每个序列包含不少于$k$个，不多于$550$个英文字符。每个英文字符代表一种不同的氨基酸。

------

第一行包含一个正整数$ans$，表示被分成的相似群体最小可能的数目。

接下来有$ans$行，每行第一个数为$m_i$，表示第$i$个相似群体有$m_i$个元素。接下来有$m_i$个数，第$j$个数表示这个相似群体包含输入中的第$j$个抗生素。（编号从$1$开始。）

每一个抗生素必须恰好出现一次。


---

---
title: "[NWRRC 2013] Intellectual Property"
layout: "post"
diff: 省选/NOI-
pid: P7087
tag: ['2013', 'Special Judge', 'ICPC']
---
# [NWRRC 2013] Intellectual Property
## 题目描述



Erast Kopi is famous Sudoku puzzle designer. Resounding success of his puzzle compilations caused a number of imitations and plagiarisms. Prior to sending a lawsuit he decided to get more evidence.

Sudoku puzzle is a table $9 \times 9$ , divided into $3 \times 3$ subtables of $3 \times 3$ cells each. Each cell may contain a digit from $1$ to $9$ . The task is to fill empty cells with digits in a way that each row, each column and each of the $9$ subtables $3 \times 3$ contains each digit from $1$ to $9$ exactly once.

Kopi has a database of Sudoku puzzles and he wants to check if it contains similar puzzles. The puzzle $P$ is similar to the puzzle $Q$ , if it is possible to transform the puzzle $P$ into the puzzle $Q$ using a sequence of the following operations:

choose two digits $x$ and $y$ and replace all digits $x$ with $y$ and vice versa;

swap two triples of rows: $(1 , 2 , 3) , (4 , 5 , 6) , (7 , 8 , 9)$ ;

swap two rows in one triple of rows;

swap two triples of columns: $(1 , 2 , 3) , (4 , 5 , 6) , (7 , 8 , 9)$ ;

swap two columns in one triple of columns;

flip along top-left -- bottom-right axis. After this operation columns become rows and vice versa.

![](/upload/images2/ip.png)

Help Kopi to find similar puzzles in his database.


## 输入格式



The first line of the input contains single integer $n$ -- the number of puzzles in the database $(1 \le n \le 20)$ .

The rest of the input contains description of $n$ puzzles: $P_1 , P_2$ , . . . , Pn. Each puzzle is described by nine lines that contain nine characters each. Each character is either a digit from $1$ to $9$ , or a dot $(‘. ')$ denoting an empty cell. An empty line separates consecutive puzzles in the database.

There are no spaces in the input file.

The puzzles are not guaranteed to be solvable.


## 输出格式



Check if the puzzle $P_1$ is similar to puzzles $P_2$ , P3 , . . . , $P_n$ (in this order), than check if the puzzle $P_2$ is similar to puzzles P3 , P4 , . . . , $P_n$ (in this order) and so on.

If the puzzle $P_i$ is similar to the puzzle $Pj (1 \le i < j \le n)$ output `Yes`, otherwise output `No`. If the answer is positive, the next line should contain an integer qij -- the number of operations required to transform the puzzle $P_i$ to the puzzle $Pj$ . The number of operations is not required to be minimal, however it must not exceed $1000$ . In the following qij lines write the operations that transform the puzzle $P_i$ to the puzzle $Pj$ , one per line.

Operations are encoded in the following way:

`D $x$ y` for swapping digits $x$ and $y$ ;

`R a b` for swapping triples of rows (3a $− 2$ , 3a $− 1 , 3a)$ and (3b $− 2$ , 3b $− 1 , 3b);$

`r a b` for swapping rows a and $b$ , rows must belong to same triple of rows;

`C a b` for swapping triples of columns (3a $− 2$ , 3a $− 1 , 3a)$ and (3b $− 2$ , 3b $− 1 , 3b);$

`c a b` for swapping columns a and $b$ , columns must belong to same triple of columns;

`F` for flipping along top-left -- bottom-right axis.

The columns are numbered from left to right and the rows are numbered from top to bottom as they are given in the input file, starting from one.


## 样例

### 样例输入 #1
```
4
.....1...
1........
.2.....8.
.........
8....9...
.........
....7....
...2...1.
2...4....

....2....
...7.4...
8.......9
.8...2..1
..2......
.........
.........
..1.8....
.........

1........
.........
.........
.........
.........
.........
.........
.........
.........

.....1...
1........
.2.....8.
.........
8....9...
.........
....7....
...2...1.
2...4....

```
### 样例输出 #1
```
Yes
7
C 1 2
D 5 3
F
r 7 9
c 6 5
C 2 3
D 1 8
No
Yes
0
No
Yes
8
R 1 2
C 2 3
c 4 5
F
r 5 6
c 7 9
D 1 8
D 3 5
No

```
## 提示

Time limit: 2 s, Memory limit: 256 MB. 


## 题目翻译

对于两个 $9\times9$ 数独谜题（不管是否有解）$A,B$，定义 $A$ 和 $B$ 等价当且仅当 $A$ 可以通过下列操作进行若干次变换后成为 $B$。
- 选择两个数字 $x,y$，将所有 $x$ 变成 $y$，所有 $y$ 变成 $x$。
- 在 $(1,2,3),(4,5,6),(7,8,9)$ 三个三元组中，选择两个，作为整体交换以它为下标的行。
- 选择在同一个三元组中的两个数 $x,y$，交换谜题的第 $x$ 行和第 $y$ 行。
- 在 $(1,2,3),(4,5,6),(7,8,9)$ 三个三元组中，选择两个，作为整体交换以它为下标的列。
- 选择在同一个三元组中的两个数 $x,y$，交换谜题的第 $x$ 列和第 $y$ 列。
- 把 $A$ 转置。

现在给定 $n(n\le20)$ 个数独谜题，判断它们两两是否等价。若等价，还需要输出一种变换的方法。`D x y` 表示将两个数字交换，`R a b` 表示整体交换三元组 $(3a-2,3a-1,3a),(3b-2,3b-1,3b)$ 对应的行，`r a b` 表示交换两个行，同理有 `C a b` 和 `c a b` 作为列操作。`F` 表示取转置。

translated by @Starlight237


---

---
title: "[NWRRC 2013] Lonely Mountain"
layout: "post"
diff: 省选/NOI-
pid: P7090
tag: ['2013', 'Special Judge', 'ICPC']
---
# [NWRRC 2013] Lonely Mountain
## 题目描述



"This was made by Thror, your grandfather, Thorin", he said in answer to the dwarves' excited questions. "It is a plan of the Mountain. "

---

J. R. R. Tolkien. The Hobbit, or There and Back Again

The plan of the Lonely Mountain consists of two parallel projections of the mountain to two projection planes. Both planes are perpendicular to the ground and each other. Each projection has a mountain-like shape.

![](https://www.acmicpc.net/upload/images2/lonely.png)

Since Bilbo Baggins has never seen the mountain, he tries to imagine it. Is it really the Lonely Mountain or some ridges and other mountains surround it? In any case, it must be tremendous to hold the whole dwarves' kingdom!

Bilbo decided to estimate the maximum possible volume of the Lonely Mountain and nearby mountains (if any) based on the plan provided by Gandalf.


## 输入格式



The first line contains single integer number $n_{x}$ -- the number of points in the parallel projection of the mountain to the plane Oxz $(2 \le n_{x} \le 100 000)$ . The second line contains $n_{x}$ pairs of integer numbers $x_{i}, z_{i}$ -- the coordinates of the polygonal chain, representing the projection $(−10^{9} \le x_{1} < x_{2} <$ x3 $< · · · < x_{n_{x}} \le 10^{9}; 0 \le z_{i} \le 10^{9}; z_{1} = z_{n_{x}} = 0)$ .

The following two lines contain projection to the Oyz plane in the same format.


## 输出格式



The only line of the output file must contain a single number $V$ -- the maximum possible volume of the Lonely Mountain.

The absolute or relative precision of you answer should be at least $10^{−6}.$ E.g . if $V′is$ the actual maximum possible volume, the following must hold: $mi_n(|V−V′|,|V−V′|/V′) \le 10^{−6}.$

If there are no mountains corresponding to the given projections, output a single line `Invalid plan`.


## 样例

### 样例输入 #1
```
6
0 0 1 1 2 0 3 3 4 4 6 0
5
0 0 1 1 2 1 3 4 4 0

```
### 样例输出 #1
```
21.824074074074074073

```
### 样例输入 #2
```
3
-1 0 0 1 2 0
4
0 0 1 1 2 2 3 0

```
### 样例输出 #2
```
Invalid plan

```
## 提示

Time limit: 2 s, Memory limit: 256 MB. 


## 题目翻译

给定一个几何体的正视图和侧视图，求其最大体积。

### 输入格式

第一行一个整数 $n_x$ 表示正视图中点的数量。

第二行按 $x_i$ 递增的顺序给出 $n_x$ 个点对 $(x_i,z_i)$ 描述其正视图，保证 $z_1=z_{n_x}=0$

第三、四行同理，描述其侧视图。

所有的输入都是整数。

### 输出格式

若不存在一个合法方案，输出 ```Invalid plan```，否则输出最大体积。

你的答案与正确答案的绝对误差不应超过 $10^{-6}$.


---

---
title: "计数题"
layout: "post"
diff: 省选/NOI-
pid: P7092
tag: []
---
# 计数题
## 题目描述

您有一个无限大的集合，其中有所有小于等于 $n$ 的质数和其中它们的乘积。

如 $n=5$，集合中实际包含的数为 $2,3,5$（质数），$4,6,8,9,10,12.....$（质数之积），假设这个集合为 $T$。


求：

$\sum\limits_{S\subset T,S\neq\varnothing}\mu(\prod\limits_{i\in S}i)\varphi(\prod\limits_{i\in S}i)$

对 $998244353$ 取模。可以证明这个和是存在的。

为了您能更好的获得部分分，我们会给定一个 $k$，表示一些限制，**$k$ 的值可能影响答案！请认真阅读提示说明**。

$n\leq 10^6$
## 输入格式

一行两个整数 $n,k$。
## 输出格式

一行一个整数，表示答案，对 $998244353$ 取模。
## 样例

### 样例输入 #1
```
2 2
```
### 样例输出 #1
```
998244352
```
### 样例输入 #2
```
114514 2
```
### 样例输出 #2
```
662314206
```
## 提示

$k$ 的限制如下：

$k=0:$ 选出的集合 $S$ 中至少含有一个完全平方数。

$k=1:$ 选出的集合 $S$ 中只能含有质数。

$k=2:$ 无任何限制。

| 测试点编号 |$n$  |$k$  |
| :----------: | :----------: | :----------: |
| $1\sim 2$ |$\leq 5$  |$2$  |
| $3\sim 5$ |$\leq 20$  |$2$  |
| $6\sim 11$ |$\leq 5000$  |$2$  |
| $12$ |$\leq 10^6$  |$0$  |
| $13\sim 14$ |$\leq 10^6$  |$1$  |
| $15\sim 16$ |$\leq 10^5$  |$2$  |
| $17\sim 20$ |$\leq 10^6$  |$2$  |

样例 $1$ 解释：

答案为 $\mu(2)\varphi(2)=-1\times 1=-1$，对 $998244353$ 取模为 $998244352$。


---

---
title: "[CERC2014] Can't stop playing"
layout: "post"
diff: 省选/NOI-
pid: P7093
tag: ['2014', 'Special Judge', 'ICPC']
---
# [CERC2014] Can't stop playing
## 题目描述

Some computer games are extremely fun and this problem may be about one of these.

You are given a sequence of one dimensional blocks, each of length that is a power of two.
The goal of the game is to merge all the blocks into one big block. The blocks are presented
one by one, and for each one you have to decide whether to stick it immediately to the left or
immediately to the right of the previous blocks.

Every time two blocks of the same size are adjacent, they merge into one block that is twice
as long as each of them. Note that, as long as possible, the resulting blocks immediately merge
with adjacent ones. For example, if the current sequence of blocks is $2, 4, 16$, then sticking $2$ on
the left side leads to $8, 16$, while sticking it on the right side gives $2, 4, 16, 2$. Note that at any
moment there is at most one mergeable pair of blocks.

You have lost the game (again!) and you are wondering whether there was any way to win at all. Analyze the sequence to find out.
## 输入格式

The first line of input contains the number of test cases $T$. The descriptions of the test cases follow:

Each test case consists of two lines. The first one contains a positive integer $n \leq 1 000$ – the
length of the sequence. The next line contains a sequence of $n$ block lengths, each a power of two. The sum of all the lengths does not exceed $2^{13}$.
## 输出格式

For each test case, output one line containing the word $\texttt{no}$ if winning the game is not possible. Otherwise, output a word consisting of $n$ letters $\texttt{l}$ and $\texttt{r}$, denoting whether the corresponding block should be stuck to the left or to the right. Note that for the first block it does not matter.
## 样例

### 样例输入 #1
```
3
9
2 8 4 1 1 4 4 4 4
5
2 16 4 8 2
3
2 2 2
```
### 样例输出 #1
```
rrrlllrrr
no
no
```
## 题目翻译

### 题目描述
你有一个双端队列，同时给定一个长度为 $n$ 的序列 $a$ ，满足序列中的元素为 2 的非负整数幂  

从前到后遍历整个序列，每次对于 $a_i$ 可以选择将它放入双端队列的队头或者队尾，如果队列中存在相邻两个元素大小相同，那么它们将合并为一个新的元素，元素大小为先前两个元素之和

求是否存在一个合法的方案使得队列最后只剩下一个元素，若存在，输出方案，不存在输出 $no$

多组数据

### 读入格式

首先读入一个 $t$ 表示数据组数

对于每一组数据第一行读入一个 $n$ 表示序列长度，下一行读入 $n$ 个元素，$a_1$ 到 $a_n$ 

### 输出格式

若存在合法方案输出一个字符串，其中第 $i$ 个字符若为 $l$ 表示放入队头，$r$ 表示放入队尾,其中第一个元素 $l,r$ 任意

若不存在合法方案，输出 `no`


---

---
title: "[NOIP2020] 移球游戏"
layout: "post"
diff: 省选/NOI-
pid: P7115
tag: ['2020', 'NOIP 提高组', 'Special Judge']
---
# [NOIP2020] 移球游戏
## 题目描述

小 C 正在玩一个移球游戏，他面前有 $n + 1$ 根柱子，柱子从 $1 \sim n + 1$ 编号，其中 $1$ 号柱子、$2$ 号柱子、……、$n$ 号柱子上各有 $m$ 个球，它们自底向上放置在柱子上，$n + 1$ 号柱子上初始时没有球。这 $n \times m$ 个球共有 $n$ 种颜色，每种颜色的球各 $m$ 个。

初始时一根柱子上的球可能是五颜六色的，而小 C 的任务是将所有同种颜色的球移到同一根柱子上，这是唯一的目标，而每种颜色的球最后放置在哪根柱子则没有限制。

小 C 可以通过若干次操作完成这个目标，一次操作能将一个球从一根柱子移到另一根柱子上。更具体地，将 $x$ 号柱子上的球移动到 $y$ 号柱子上的要求为：

1. $x$ 号柱子上至少有一个球；
2. $y$ 号柱子上至多有 $m - 1$ 个球；
3. 只能将 $x$ 号柱子最上方的球移到 $y$ 号柱子的最上方。

小 C 的目标并不难完成，因此他决定给自己加加难度：在完成目标的基础上，使用的操作次数不能超过 $820000$。换句话说，小 C 需要使用至多 $820000$ 次操作完成目标。

小 C 被难住了，但他相信难不倒你，请你给出一个操作方案完成小 C 的目标。合法的方案可能有多种，你只需要给出任意一种，题目保证一定存在一个合法方案。
## 输入格式

第一行两个用空格分隔的整数 $n, m$。分别表示球的颜色数、每种颜色球的个数。  
接下来 $n$ 行每行 $m$ 个用单个空格分隔的整数，第 $i$ 行的整数按自底向上的顺序依次给出了 $i$ 号柱子上的球的颜色。
## 输出格式

本题采用自定义校验器（special judge）评测。  
你的输出的第一行应该仅包含单个整数 $k$，表示你的方案的操作次数。你应保证 $0 \le k \le 820000$。  
接下来 $k$ 行每行你应输出两个用单个空格分隔的正整数 $x, y$，表示这次操作将 $x$ 号柱子最上方的球移动到 $y$ 号柱子最上方。你应保证 $1 \le x, y \le n + 1$ 且 $x \ne y$。
## 样例

### 样例输入 #1
```
2 3
1 1 2
2 1 2

```
### 样例输出 #1
```
6
1 3
2 3
2 3
3 1
3 2
3 2

```
### 样例输入 #2
```
见附件中的 ball/ball2.in
```
### 样例输出 #2
```
见附件中的 ball/ball2.ans
```
### 样例输入 #3
```
见附件中的 ball/ball3.in
```
### 样例输出 #3
```
见附件中的 ball/ball3.ans
```
## 提示

**【样例 #1 解释】**

柱子中的内容为：按自底向上的顺序依次给出柱子上每个球的颜色。

| 操作 | $1$ 号柱子 | $2$ 号柱子 | $3$ 号柱子 |
|:-:|:-:|:-:|:-:|
| 初始 | $1\ 1\ 2$ | $2\ 1\ 2$ | |
| $1\ 3$ | $1\ 1$ | $2\ 1\ 2$ | $2$ |
| $2\ 3$ | $1\ 1$ | $2\ 1$ | $2\ 2$ |
| $2\ 3$ | $1\ 1$ | $2$ | $2\ 2\ 1$ |
| $3\ 1$ | $1\ 1\ 1$ | $2$ | $2\ 2$ |
| $3\ 2$ | $1\ 1\ 1$ | $2\ 2$ | $2$ |
| $3\ 2$ | $1\ 1\ 1$ | $2\ 2\ 2$ | |

**【数据范围】**

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 2$ | $2$ | $20$ |
| $3 \sim 5$ | $10$ | $20$ |
| $6 \sim 8$ | $50$ | $85$ |
| $9 \sim 14$ | $50$ | $300$ |
| $15 \sim 20$ | $50$ | $400$ |

对于所有测试点，保证 $2 \le n \le 50$，$2 \le m \le 400$。

**【校验器】**

为了方便选手测试，在附件中的 `ball` 目录下我们下发了 `checker.cpp` 文件，选手可以编译该程序，并使用它校验自己的输出文件。但请注意它与最终评测时所使用的校验器并不完全一致。你也不需要关心其代码的具体内容。

编译命令为：`g++ checker.cpp −o checker -std=c++11`。

`checker` 的使用方式为：`checker <inputfile> <outputfile>`，参数依次表示输入文件与你的输出文件。

若你输出的数字大小范围不合法，则校验器会给出相应提示。若你的输出数字大小范围正确，但方案错误，则校验器会给出简要的错误信息：

1. `A x`，表示进行到第 $x$ 个操作时不合法。
2. `B x`，表示操作执行完毕后第 $x$ 个柱子上的球不合法。

若你的方案正确，校验器会给出 `OK`。


---

---
title: "[NOIP2020] 微信步数"
layout: "post"
diff: 省选/NOI-
pid: P7116
tag: ['2020', 'NOIP 提高组']
---
# [NOIP2020] 微信步数
## 题目描述

小 C 喜欢跑步，并且非常喜欢在微信步数排行榜上刷榜，为此他制定了一个刷微信步数的计划。

他来到了一处空旷的场地，处于该场地中的人可以用 $k$ 维整数坐标 $(a_1, a_2, \ldots , a_k)$ 来表示其位置。场地有大小限制，第 $i$ 维的大小为 $w_i$，因此处于场地中的人其坐标应满足 $1 \le a_i \le w_i$（$1 \le i \le k$）。

小 C 打算在接下来的 $P = w_1 \times w_2 \times \cdots \times w_k$ 天中，每天从场地中一个新的位置出发，开始他的刷步数计划（换句话说，他将会从场地中每个位置都出发一次进行计划）。

他的计划非常简单，每天按照事先规定好的路线行进，每天的路线由 $n$ 步移动构成，每一步可以用 $c_i$ 与 $d_i$ 表示：若他当前位于 $(a_1, a_2, \ldots , a_{c_i}, \ldots, a_k)$，则这一步他将会走到 $(a_1, a_2, \ldots , a_{c_i} + d_i, \ldots , a_k)$，其中 $1 \le c_i \le k$，$d_i \in \{-1, 1\}$。小 C 将会不断重复这个路线，直到他走出了场地的范围才结束一天的计划。（即走完第 $n$ 步后，若小 C 还在场内，他将回到第 $1$ 步从头再走一遍）。

小 C 对自己的速度非常有自信，所以他并不在意具体耗费的时间，他只想知道 $P$ 天之后，他一共刷出了多少步微信步数。请你帮他算一算。
## 输入格式

第一行两个用单个空格分隔的整数 $n, k$。分别表示路线步数与场地维数。  
接下来一行 $k$ 个用单个空格分隔的整数 $w_i$，表示场地大小。  
接下来 $n$ 行每行两个用单个空格分隔的整数 $c_i, d_i$，依次表示每一步的方向，具体意义见题目描述。
## 输出格式

仅一行一个整数表示答案。答案可能很大，你只需要输出其对 ${10}^9 + 7$ 取模后的值。  
若小 C 的计划会使得他在某一天在场地中永远走不出来，则输出一行一个整数 $-1$。
## 样例

### 样例输入 #1
```
3 2
3 3
1 1
2 -1
1 1

```
### 样例输出 #1
```
21

```
### 样例输入 #2
```
5 4
6 8 6 5
3 1
2 1
1 1
2 1
2 -1

```
### 样例输出 #2
```
10265

```
### 样例输入 #3
```
见附件中的 walk/walk3.in
```
### 样例输出 #3
```
见附件中的 walk/walk3.ans
```
### 样例输入 #4
```
见附件中的 walk/walk4.in
```
### 样例输出 #4
```
见附件中的 walk/walk4.ans
```
## 提示

**【样例 #1 解释】**

从 $(1, 1)$ 出发将走 $2$ 步，从 $(1, 2)$ 出发将走 $4$ 步，从 $(1, 3)$ 出发将走 $4$ 步。  
从 $(2, 1)$ 出发将走 $2$ 步，从 $(2, 2)$ 出发将走 $3$ 步，从 $(2, 3)$ 出发将走 $3$ 步。  
从 $(3, 1)$ 出发将走 $1$ 步，从 $(3, 2)$ 出发将走 $1$ 步，从 $(3, 3)$ 出发将走 $1$ 步。  
共计 $21$ 步。

**【数据范围】**

| 测试点编号 | $n \le$ | $k \le$ | $w_i \le$ |
|:-:|:-:|:-:|:-:|
| $1 \sim 3$ | $5$ | $5$ | $3$ |
| $4 \sim 6$ | $100$ | $3$ | $10$ |
| $7 \sim 8$ | ${10}^5$ | $1$ | ${10}^5$ |
| $9 \sim 12$ | ${10}^5$ | $2$ | ${10}^6$ |
| $13 \sim 16$ | $5 \times {10}^5$ | $10$ | ${10}^6$ |
| $17 \sim 20$ | $5 \times {10}^5$ | $3$ | ${10}^9$ |

对于所有测试点，保证 $1 \le n \le 5 \times {10}^5$，$1 \le k \le 10$，$1 \le w_i \le {10}^9$，$d_i \in \{-1, 1\}$。


---

---
title: "「RdOI R1」平衡常数(balance)"
layout: "post"
diff: 省选/NOI-
pid: P7130
tag: ['2020']
---
# 「RdOI R1」平衡常数(balance)
## 题目描述

给定一棵以 $1$ 为根的点带权有根树 $G=(V,E)$，第 $i$ 个节点的权值记为 
 $w_i$，以 $i$ 为根的子树的点集记为 $V_i$，求一个点集 $V'\subseteq V$，满足以下条件：

- $\forall i$，都有 $|V_i \cap V'| \le \lfloor \frac{|V_i|}{2} \rfloor$

- 最大化 $\sum _{i \in V'} w_i$

输出 $\sum _{i\in V'} w_i$ 即可，也就是选取的点的权值和。
## 输入格式

第一行为一个正整数 $n$。

第二行为 $n$ 个正整数 $w_i$。

接下来 $n-1$ 行每行为两个整数 $u,v$，表示第 $i$ 条边的两个端点。
## 输出格式

输出只有一行，为你所求得的最大总和。
## 样例

### 样例输入 #1
```
3
1 2 3
1 2
1 3
```
### 样例输出 #1
```
1
```
## 提示

【数据范围】

| 测试点编号 | $n\leq$ | $w_i\leq$ | 特殊性质 |
| - | - | - | - |
| $1\sim2$ | $10$ | $10^3$ | |
| $3\sim 5$ | $2 \times 10^3$ | $10^3$ | |
| $6\sim12$ | $10^5$ | $10^3$ | |
| $13\sim16$ | $5 \times 10^5$ | $10^9$ | $v=u+1$ |
| $17\sim25$ | $5 \times 10^5$ | $10^9$ | |

对于 $100\%$ 的数据，$1 \leq n \leq 5 \times 10^5$，$0 < w_i \leq 10^9$，$1 \leq u,v \leq n$。

---

【说明/提示】

- Idea From : LCuter

---

【文件读入读出】**（模拟，提交代码时不需使用）**

- 文件名：`balance.cpp`
- 读入文件名：`balance.in`
- 读出文件名：`balance.out`


---

---
title: "「RdOI R1」变换(turn)"
layout: "post"
diff: 省选/NOI-
pid: P7131
tag: ['2020']
---
# 「RdOI R1」变换(turn)
## 题目描述

有 $n$ 个变换，其中第 $i$ 个有两个属性值 $p_i$ 和 $q_i$，当这个变换作用到 $x$ 时，$x$ 将会变成 $f_i(x),f_i(x)$ 的定义为：

$$f_i(x)=\left\lfloor\dfrac{x}{p_i}\right\rfloor+q_i$$

给定 $m$ 条操作，操作分两种：

**修改**操作可以修改某个变换的属性值；

**查询**操作将会给定 $x$ 以及两个序号 $s$ 和 $t$，你需要计算并输出：

$$f_{t}(f_{t-1}(\cdots f_{s+1}(f_{s}(x))))$$
## 输入格式

第一行：两个正整数表示 $n$ 和 $m$。

第二行：$n$ 个整数，表示 $p_1,p_2,\cdots,p_n$。

第三行：$n$ 个整数，表示 $q_1,q_2,\cdots,q_n$。

接下来 $m$ 行，每行表示一个操作：

修改 操作以字母 `m` 开头，后接三个参数 $i,p',q'$，表示将第 $i$ 个变换的属性值修改成 $p',q'$。保证任何时候属性都满足 $1\leq p_i\leq 1000, 0\leq q_i\leq 1000$。

查询 操作以字母 `q` 开头，后接三个参数 $x,s,t$，意义见题面，保证 $s\leq t, 0\leq x\leq 10^6$。
## 输出格式

对每个询问操作，输出一个整数，表示所求的答案，以换行分隔。
## 样例

### 样例输入 #1
```
3 3
2 1 2
1 1 1
q 100 1 3
m 2 2 0
q 100 1 3
```
### 样例输出 #1
```
27
13
```
### 样例输入 #2
```
见附件中的 turn-big-sample1.in
```
### 样例输出 #2
```
见附件中的 turn-big-sample1.out
```
## 提示

【数据范围】

- 对于 $20\%$ 的数据，$1 \le n \le 10^3,1 \le m \le 10^4$。
- 对于另外 $30\%$ 的数据，$1 \le n \le 10^4,1 \le m \le 10^5$。
- 对于 $100\%$ 的数据，$1 \le n \le 10^5,1 \le m \le 2 \times 10^5$。

---

【文件读入读出】**（模拟，提交代码时不需使用）**

- 文件名：`turn.cpp`
- 读入文件名：`turn.in`
- 读出文件名：`turn.out`


---

---
title: "小 H 的序列"
layout: "post"
diff: 省选/NOI-
pid: P7134
tag: ['O2优化']
---
# 小 H 的序列
## 题目背景

小 H 有一个序列。
## 题目描述

**提交时自动开启 O2 优化。**

小 H 想让你维护一个长为 $n$ 序列 $a_1,a_2,\ldots,a_n$，要求支持

- 修改操作：将所有满足$i\in[l,r]$且$u\le a_i\le v$的$a_i$的值修改为$w$；
- 查询操作：求出$\sum_{i=l}^ra_i^t\bmod k$。
## 输入格式

总共包括 $m+2$ 行。

第一行包含两个正整数 $n,m$，分别表示序列长度和操作次数。

第二行包含 $n$ 个正整数 $a_1,a_2\ldots,a_n$，表示最初的序列。

接下来的 $m$ 行，每行由一个数 $o$ 开头，表示操作类型。

- 如果 $o=0$，表示修改操作，紧接着给出五个正整数 $l,r,u,v,w$；
- 如果 $o=1$，表示查询操作，紧接着给出四个正整数 $l,r,t,k$，意义如【题目描述】中所述。

每行的两个数字间由单个空格隔开，数据在 Windows 下生成。**行末不保证没有多余空格**。
## 输出格式

一行一个整数，表示所有查询操作的答案的异或和（如果没有查询操作输出一个数 $0$）。
## 样例

### 样例输入 #1
```
10 9
4 3 2 1 9 6 8 8 1 3 
0 4 8 3 10 9
1 1 3 2 973874498
0 10 10 5 9 6
1 7 9 3 738164087
1 1 10 1 694888198
0 2 2 4 7 7
0 1 6 1 3 3
1 1 10 3 868703567
1 4 9 3 545789338

```
### 样例输出 #1
```
525
```
## 提示

输入的所有数字均为正整数。  
设存在数据范围 $\mathrm{randmax}$，满足 $n,m,a_i,w\le\mathrm{randmax},1\le l\le r\le n,1\le u\le v\le \mathrm{randmax},1\le t,k\le10^9$。

![](https://cdn.luogu.com.cn/upload/image_hosting/wt8vfeho.png)

保证数据除 $n,m$ 以及测试点 $4,5$ 的 $t$ 外随机，各变量意义如【题目描述】中所述。

由于本题输入量较大及为了省下不必要的评测耗时，请注意输入优化。在此给出以下模板（`c++`语言）：

```cpp
/* ---- read() & rlong() - begin ---- */
#define gc() (p0==p1&&(p1=(p0=buf)+fread(buf,1,1048576,stdin),p0==p1)?EOF:*p0++)
char buf[1048576],*p0,*p1;
inline int read() {
	int r=0; char c=gc(); while (c<48||c>57) c=gc();
	while (c>47&&c<58) {r=(r<<3)+(r<<1)+(c^48); c=gc();} return r;
}
#undef gc
/* ---- read() & rlong() -- end ----- */
```

调用`read()`函数会从输入中读入一个`int`型整数，注意该模板不能处理负数，调试时请使用文件输入。


---

---
title: "[COCI 2020/2021 #2] Svjetlo"
layout: "post"
diff: 省选/NOI-
pid: P7163
tag: ['2020', 'O2优化', 'COCI（克罗地亚）']
---
# [COCI 2020/2021 #2] Svjetlo
## 题目描述

有一个呈树状结构的吊灯，由 $n$ 个灯泡组成，这些灯泡之间有 $n-1$ 根电线连接。每个灯泡有一个按钮，能使灯泡的状态发生改变，即把打开的灯泡关闭，关闭的灯泡打开。你需要把所有的灯泡打开。

你可以选择一个序列，序列中两两相邻位置的灯泡相邻，灯泡可以在序列中出现多次。你可以依次改变序列中的灯泡的状态。

你需要计算出最短的符合题目要求的灯泡序列。保证至少有一个灯泡在开始时处于关闭状态。
## 输入格式

第一行一个整数 $n$，表示灯泡的数量。  
第二行一个长为 $n$ 的 01 序列，表示灯泡的状态，其中“0”代表关闭，“1”代表打开。  
接下来 $n - 1$ 行每行两个整数 $x, y$，表示 $x$ 与 $y$ 之间有边。
## 输出格式

输出序列的最小长度。可以证明这样的序列一定存在。
## 样例

### 样例输入 #1
```
3
010
1 2
2 3
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
5
00000
1 2
2 3
2 4
3 5
```
### 样例输出 #2
```
7
```
### 样例输入 #3
```
5
00100
1 2
2 3
2 4
3 5
```
### 样例输出 #3
```
8
```
## 提示

**【样例解释 #1】**

序列可以为 $1, 2, 3, 2$。

**【数据范围】**

对于 $100\%$ 的数据，$2 \leq n \leq 500,000$。

Subtask #1（$19$ pts）：$n \leq 100$。  
Subtask #2（$27$ pts）：每个灯泡最多与两个灯泡相连。  
Subtask #3（$27$ pts）：一开始所有灯泡均处于关闭状态。  
Subtask #4（$27$ pts）：无附加限制。

#### 说明

译自 [Croatian Open Competition in Informatics 2020 ~ 2021 Round 2 E Svjetlo](https://hsin.hr/coci/contest2_tasks.pdf)。


---

---
title: "【模板】有负圈的费用流"
layout: "post"
diff: 省选/NOI-
pid: P7173
tag: []
---
# 【模板】有负圈的费用流
## 题目描述

给定一张 $n$ 个点 $m$ 条边的费用网络，源为 $s$ 且汇为 $t$ ，求其最小费用最大流。

注意存在费用为负的边和总费用为负的环。

注意，本题中允许一个不经过 $s,t$ 的环整体加上一个流量。事实上，若不允许这种情况的出现，则哈密顿路可以归约为这个问题。
## 输入格式

输入第一行包括四个正整数 $n,m,s,t$。

第 $2$ 到 $m+1$ 行，每行四个整数 $x_i,y_i,f_i,v_i$，表示存在一条 $x_i$ 到 $y_i$ 的边，流量为 $f_i$，费用为 $v_i$。
## 输出格式

输出包括一行两个整数，分别表示最大流与最小费用。
## 样例

### 样例输入 #1
```
4 5 4 3
4 2 30 2
4 3 20 3
2 3 20 1
2 1 30 9
1 3 40 5

```
### 样例输出 #1
```
50 280

```
### 样例输入 #2
```
5 7 1 5
1 3 2 4
1 2 2 3
3 5 2 2
3 2 1 -1
2 4 2 -2
4 3 1 -1
4 5 1 3

```
### 样例输出 #2
```
3 12

```
## 提示

对于 $100\%$ 的数据：$1\leq n\leq 200$，$1\leq m\leq {10}^{4}$，$0\leq f_i,|v_i|\leq 100$。

注：不知道消圈算法能不能过，由于数据分档，即使不能过应该也能拿到一定的分数。


---

---
title: "[BalticOI 2004] REPEATS"
layout: "post"
diff: 省选/NOI-
pid: P7180
tag: ['2004', 'Special Judge', 'BalticOI（波罗的海）']
---
# [BalticOI 2004] REPEATS
## 题目描述

如果字符串 $s$ 满足：

- 对于一个数对 $(k,l)~(k\ge 1,l\ge 1)$。
- $s$ 是由 $k$ 个长度为 $l$ 的字符串 $t$ 拼接成的。

那么 $s$ 就被称作是一个 $(k,l)\text{ - repeat}$ 串。

如 $s=\tt abaabaabaaba$ 就是一个 $t=\tt aba$ 的 $(4,3)\text{ - repeat}$ 串。

对于一个字符串 $u$（仅含字符 $\texttt a$ 和 $\texttt b$），你需要找出其中的一段是 $(k,l)\text{ - repeat}$ 串的**连续的**字符串，使 $k$ 尽可能大。

例如 $u=\tt babb\underline{abaabaabaaba}b$，其中划线部分就是一个 $(4,3)\text{ - repeat}$ 串，这时 $k$ 的值最大。
## 输入格式

第一行一个整数 $n$，代表 $u$ 的长度。

接下来 $n$ 行，每行一个字符（$\texttt a$ 或 $\texttt b$），表示这个字符串。
## 输出格式

第一行一个数 $k$。

第二行一个数 $l$。

第三行一个数 $p$，表示这个 $(k,l)\text{ - repeat}$ 串的开始位置（位置从 $1$ 开始）。

**如果有多种情况，输出任意一种。**
## 样例

### 样例输入 #1
```
17
b
a
b
b
a
b
a
a
b
a
a
b
a
a
b
a
b 
```
### 样例输出 #1
```
4
3
5
```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，有 $1\le n\le 5\times 10^{4}$，$u_i\in\{\tt a,b\}$。

#### 说明

译自 [BalticOI 2004 Day2 A REPEATS](https://boi.cses.fi/files/boi2004_day2.pdf)

特别感谢 @[Sprague_Garundy](https://www.luogu.com.cn/user/764746) 提供的 SPJ！


---

---
title: "[COCI 2019/2020 #1] Trobojnica"
layout: "post"
diff: 省选/NOI-
pid: P7202
tag: ['2019', 'Special Judge', 'COCI（克罗地亚）']
---
# [COCI 2019/2020 #1] Trobojnica
## 题目描述

> "Everything will be in flames once red, white, and blue start running through your veins." - Slaven Bilić

在该任务中，我们将会研究一些多边形，它们具有 $N$ 条被涂成颜色的边（总共有三种颜色），而顶点的编号沿顺时针依次为 $1$ 至 $N$。

你的任务是找到一个多边形的三角形分割方式，即将一个多边形沿对角线分成 $N-2$ 个三角形，使得多边形的每个三角形的三条邻边都各分别为三种不同的颜色。
## 输入格式

第一行包含一个题中所提的整数 $N$。

第二行是一个共有 $N$ 个数位的整数，表示该多边形各边的颜色。其第一位表示边 $(1,2)$ 的颜色，第二位表示边 $(2,3)$ 的颜色，以此类推，第 $N$ 位表示边 $(N,1)$ 的颜色。所有数位都将会是 $1,2,3$ 中的其中一个。
## 输出格式

如果没有符合条件的分法，输出 `NE` 并结束整个程序。

否则，在第一行输出 `DA` 并在接下来的 $N-3$ 行中输出每一条被分割的对角线及其颜色。

每行输出格式为 `X Y C`。其中 $X,Y$ 为对角线的两个顶点，而 $C$ 为其颜色编号（$1 \le X,Y \le N, 1 \le C \le 3$），不必考虑对角线顶点顺序。

如果有多种符合条件的分法，输出任意一种。
## 样例

### 样例输入 #1
```
4
1212
```
### 样例输出 #1
```
DA
1 3 3
```
### 样例输入 #2
```
4
1213
```
### 样例输出 #2
```
NE
```
### 样例输入 #3
```
7
1223121
```
### 样例输出 #3
```
DA
1 3 3
3 5 1
5 7 3
7 3 2
```
## 提示

#### 数据范围及约定

| Subtask | 分值 | 数据范围及约定 |
| :----------: | :----------: | :----------: |
| $1$ | $20$ | $4 \le N \le 11$ |
| $2$ | $40$ | $4 \le N \le 10^3$ |
| $3$ | $50$ | $4 \le N \le 2 \times 10^5$ |

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

本题使用非官方的 [Special Judge](https://www.luogu.com.cn/paste/wxx1bxs2)，欢迎大家 hack（可私信或直接发帖）。

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #1](https://hsin.hr/coci/archive/2019_2020/contest1_tasks.pdf)  _T4 Trobojnica_ 。**


---

---
title: "[JOISC 2020] ジョイッターで友だちをつくろう"
layout: "post"
diff: 省选/NOI-
pid: P7212
tag: ['2020', 'O2优化', 'JOI（日本）']
---
# [JOISC 2020] ジョイッターで友だちをつくろう
## 题目背景

Joitter 是一款交友软件。
## 题目描述

在 Joitter 你可以关注他人，但你不可以关注自己和关注他人两次，即如果关注他人多次只会算作一次。

共有 $N$ 名新用户，$M$ 天。

在第 $i$ 天，用户 $A_i$ 会关注用户 $B_i$。

同时在关注之后，会举办一场交友活动，活动内容如下：

1. 选择一个用户 $x$。
2. 选择一个被用户 $x$ 关注的用户 $y$。
3. 选择一个用户 $z$，要求 $z\not=x$，$x$ 未关注 $z$ 且 $y$ 和 $z$ 互关。
4. 让 $x$ 关注 $z$。
5. 重复 $1,2,3,4$，直到选不出合适的三元组 $(x,y,z)$。

您需要求出，对于每一个 $i$，第 $i$ 天过后的所有关注总数。
## 输入格式

第一行为两个整数 $N,M$。

接下来 $M$ 行，一行两个整数 $A_i,B_i$。
## 输出格式

输出共 $M$ 行，每一行一个数，第 $i$ 行表示经过第 $i$ 天之后的关注总数。
## 样例

### 样例输入 #1
```
4 6
1 2
2 3
3 2
1 3
3 4
4 3
```
### 样例输出 #1
```
1
2
4
4
5
9
```
### 样例输入 #2
```
6 10
1 2
2 3
3 4
4 5
5 6
6 5
5 4
4 3
3 2
2 1
```
### 样例输出 #2
```
1
2
3
4
5
7
11
17
25
30
```
## 提示

#### 子任务
对于 $100\%$ 的数据，保证 $2\le N\le 10^5$，$1\le M\le 3\times 10^5$，$1\le A_i,B_i\le N$，$A_i\not=B_i$，$(A_i,B_i)\not=(A_j,B_j)$。

| 子任务编号 | $N\le $ | 分值 |
|:-:|:-:|:-:
| $1$ | $50$ | $1$ |
| $2$ | $2\times 10^3$ | $16$ |
| $3$ | 无 | $83$ |

#### 说明
本题译自 [第 19 回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/index.html) Day 2 [T2 ジョイッターで友だちをつくろう](https://www.ioi-jp.org/camp/2020/2020-sp-tasks/day2/joitter2-en.pdf)。


---

---
title: "[JSOI2010] 蔬菜庆典"
layout: "post"
diff: 省选/NOI-
pid: P7221
tag: ['2010', '各省省选', '江苏']
---
# [JSOI2010] 蔬菜庆典
## 题目描述

JYY 在火星上找到一片埋有宝藏的岛，并且带走了一些宝藏。之后 JYY 被火星人发现偷宝藏，抓了起来。火星人打算吃掉 JYY，除非 JYY 能在火星年度蔬菜庆典的游戏中赢得足够多的火星币来支付他带走宝藏的费用。

游戏在蔬菜广场上进行。首先放进广场的是一个巨大的转基因南瓜，接着各种其他巨大的蔬菜被陆续拖进广场，连同大南瓜一共 $n$ 个，第 $i$ 个放入的蔬菜会用一根绳子和先前放入的某个蔬菜连接起来。按照火星人的说法，蔬菜 $i$ 是蔬菜 $p_i$ 的 Dlihc，蔬菜 $p_i$ 是蔬菜 $i$ 的 Tnerap。JYY 立即看出，一开始的大南瓜没有 Tnerap，后来的每个蔬菜都恰好有一个 Tnerap；每个蔬菜可能有一个或多个的 Dlihc，也可能没有。$n$ 个蔬菜全部在广场上安置好后，火星人在每个蔬菜上贴一张纸条，蔬菜 $i$ 的纸条上写着一个整数 $v_i$，表示这个蔬菜的价钱。

游戏一个接一个地进行着。在整个晚会将要结束时，JYY 终于等到了适合自己的那一个。（你不能指望有恐高症的 JYY 会在蔬菜间玩走钢丝，尽管那样能有丰厚的报酬）。游戏规则是：游戏者（也就是 JYY）每次可以选择任意一个既有 Dlihc 又有 Tnerap 的蔬菜 $i$，将它的价钱 $v_i$ 改成 $v_p+v_c-v_i$，其中 $p$ 代表蔬菜 $i$ 的 Tnerap 的编号，$c$ 代表蔬菜 $i$ 的任意一个 Dlihc 的编号。火星人给的时间比较宽裕，足够 JYY 进行任意多次操作。当 JYY 决定不再操作时，游戏结束。之后所有巨型蔬菜将被火星政府按蔬菜上的标价收购。买菜所得的钱归 JYY 所有，用以支付他的债务。

JYY 想知道，他最多能把这些蔬菜卖出多少钱，或者他能通过一系列操作使得蔬菜的总价无限制地增大。请你帮助 JYY 解决这个问题。
## 输入格式

输入文件有多组数据，每组数据的格式为：

第一行一个整数 $n$ 表示广场上蔬菜的个数。

接下来 $n$ 行，每行两个整数 $p_i,v_i$，第 $i$ 行中的整数代表蔬菜 $i$ 的 Tnerap 的编号和蔬菜 $i$ 的价格。

当 $n=0$ 时表示输入结束。
## 输出格式

对于每组数据，输出一行。若蔬菜的总价能无限制增大，输出 `+inf`。否则输出一个整数，表示所有蔬菜的最大总价。
## 样例

### 样例输入 #1
```
5
-1 3
1 2
1 1
3 2
3 2
5
-1 3
1 2
1 1
3 2
3 3
0
```
### 样例输出 #1
```
13
+inf

```
## 提示

### 样例解释 1

共有两组数据。

对于第一组数据，我们只能对蔬菜 $3$ 进行操作，它的值只能是 $1$ 或 $4$，所以答案为 $3+2+4+2+2=13$。

对于第二组数据，可以按照如下方法使得所有蔬菜的价钱无限制地增大：

$$\begin{matrix}1\to 3+3-1=5\\5\to 3+2-5=0\\0\to 3+3-0=6\\6\to 3+2-6=-1\\-1\to 3+3-(-1)=7\\\cdots\end{matrix}$$

### 数据范围

对于 $100\%$ 的数据，$n\leq 2\times 10^5,-10^7\leq v_i\leq 10^7$。


---

---
title: "3D Cube"
layout: "post"
diff: 省选/NOI-
pid: P7239
tag: ['Special Judge', 'O2优化']
---
# 3D Cube
## 题目背景

**此题数据纯手造，并有手玩验证。**

idea & data：[zrmpaul](/user/226760)  
tester：[Hilarious_Reality](/user/80049)

--------

小 Z 喜欢三维模型，并从不同角度进行细致的观察。
## 题目描述

小 Z 拿到了一个二维矩阵。底面可以看作一个 $n \times m$ 的方格纸。

在每一个格子上，可以放任意个方块。由于有地心引力，方块不会悬空，且不会用胶水粘住。

他给出了这个三维矩阵的三视图，请你构造一个方块组，满足以下条件：

对于每一行、每一列，最多只有一个“**峰**”出现。特别地，底层矩阵的周围的高度被视为 $0$。如 `12321` 是一个“峰”，而 `13231` 有两个“峰”。

再举一些例子：

|方块排列|“峰”的数量|
|:----:|:----:|
|$\texttt{123}$|$1$|
|$\texttt{212}$|$2$|
|$\texttt{122221}$|$1$|
|$\texttt{00011000}$|$1$|
|$\texttt{10010101}$|$4$|

求出需要**最少**方块的矩阵。如果无解，请输出 `-1`。
## 输入格式

第一行两个整数：$n,m$。

第二行 $n$ 个整数：左视图，第 $i$ 个整数表示左视图中第 $i$ 列的方块个数。

第三行 $m$ 个整数：主视图，第 $j$ 个整数表示主视图中第 $j$ 列的方块个数。

接下来 $n$ 行，每行 $m$ 个整数：俯视图，其中 `0` 表示没有方块，`1` 表示有方块。
## 输出格式

如果无解，则输出 `-1`。

否则输出共 $n$ 行，每行 $m$ 个非负整数，为构造的三维矩阵的俯视图，其中第 $i$ 行第 $j$ 个整数表示该位置上的方块个数。

**请确保按照输出格式输出，否则可能导致 SPJ 返回 UKE 等结果。**
## 样例

### 样例输入 #1
```
3 3
2 2 2
2 2 2
0 1 0
1 1 1
0 1 0
```
### 样例输出 #1
```
0 2 0 
2 2 2 
0 2 0 
```
## 提示

### 数据范围

**本题各部分测试点采用捆绑测试。**

对于 $20\%$ 的数据：给出输入文件，程序打表输出答案，见附件 `easy.zip`。

对于 $100\%$ 的数据：$n\times m\leq25$。在俯视图中每个格子上最多有 $7\times10^8$ 个方块，且在俯视图中 `1` 的个数 $\leq20$。


---

---
title: "[COCI 2019/2020 #4] Klasika"
layout: "post"
diff: 省选/NOI-
pid: P7242
tag: ['2019', 'COCI（克罗地亚）']
---
# [COCI 2019/2020 #4] Klasika
## 题目描述

开始时，你有一个编号为 $1$ 的节点，它代表着一棵树的根。你的任务是对树进行 $Q$ 次操作。

操作分为两类：

- $\texttt{Add x y}$，给树上编号为 $x$ 的节点加入一个儿子，该儿子的编号为加入该节点后树的大小，它与 $x$ 的边的边权为 $y$。
- $\texttt{Query a b}$，查找从 $a$ 出发，到 $b$ 节点子树内某个节点（包括 $B$ ）的路径中边权异或和最大的一条，并输出其异或和。
## 输入格式

第一行一个整数 $Q$。

加下来 $Q$ 行，每行一个字符串和两个数字，描述一次操作。
## 输出格式

对于每个 $\texttt{Query}$ 操作，一行一个整数表示答案。
## 样例

### 样例输入 #1
```
4
Add 1 5
Query 1 1
Add 1 7
Query 1 1
```
### 样例输出 #1
```
5
7
```
### 样例输入 #2
```
6
Add 1 5
Add 2 7
Add 1 4
Add 4 3
Query 1 1
Query 2 4
```
### 样例输出 #2
```
7
2
```
### 样例输入 #3
```
10
Add 1 4
Add 1 9
Add 1 10
Add 2 2
Add 3 3
Add 4 4
Query 4 2
Query 1 3
Add 6 7
Query 1 3
```
### 样例输出 #3
```
14
10
13
```
## 提示

【数据规模与约定】

| 子任务编号 | 特殊限制                                   | 分值 |
| ---------- | ------------------------------------------ | ---- |
| $1$        | $Q\le 200$                                 | $10$ |
| $2$        | $Q\le 2\times 10^3$                        | $20$ |
| $3$        | 对于所有 $\texttt{Query}$ 操作，保证 $b=1$ | $30$ |
| $4$        | 无特殊限制                                 | $40$ |

对于 $100\%$ 的数据，$1\le Q\le 2\times 10^5$，$0\le y\le 2^{30}$，保证 $x,a,b$ 小于等于当前树的大小。

【提示与帮助】

**题目译自 [COCI 2019/2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #4](https://hsin.hr/coci/archive/2019_2020/contest4_tasks.pdf) T4 Klasika**

在 COCI 中，本题分值为 $110$ 分。


---

---
title: "手势密码"
layout: "post"
diff: 省选/NOI-
pid: P7246
tag: ['O2优化']
---
# 手势密码
## 题目背景

&emsp;&emsp;众目睽睽之下被要求解锁另一个人的手机是一件非常恐怖的事。

&emsp;&emsp;——特别是密码关于自己的时候。

---

&emsp;&emsp;被堆在讲台周围乌压压的同学围着，小灰毛表示自己真的很难。作为班长的阿绫被叫去开会，存着月考名次表的手机被交给天依保管。但消息不出意料地走漏，现在一班觊觎着分数数据的饿狼一致要求天依打开手机……

&emsp;&emsp;“真不知道密码啊！”拖延着，心里早就猜到手势密码的答案。

&emsp;&emsp;最后，试探而肯定地划出一个字母“Y”，解锁成功。什么意思呢？首先排除“依”的首字母。

&emsp;&emsp;这个时候肯定有起哄的啦！

&emsp;&emsp;“懂的都懂\~”“别问，问就是 [XX即是正义！](https://www.bilibili.com/video/BV1z741137vQ)”……
## 题目描述

乐正大小姐用的手机很高级，所以她的手势密码也很花哨。

具体地，现在有一棵 $n$ 个结点的树，对于两个结点 $u,v$，当且仅当 $(u,v)$ 是一条树边时，手势才能从其中一个点（$u$ 或 $v$）划向另一个点（$v$ 或 $u$）。更奇怪的是，这种手势密码不限制仅划一次，但每次划出的路径必须是树上的一条简单路径。

现在阿绫告诉了天依在她的密码中每个结点被手势划过的次数（作为手势的起点或终点也算划过一次），其中第 $i$ 个结点划过 $a_i$ 次。那么，天依至少要划多少次才能解开密码呢？

----

#### 简化题意

有一棵带点权的树。定义一次操作为选择树上的一条简单路径，并将这条简单路径上的所有点点权减去 $1$。问至少需要多少次操作，使树上所有点的点权**恰好**变为 $0$。
## 输入格式

第一行一个整数 $op$，表示数据输入方式类型。

如果 $op=1$：

第二行一个正整数 $n$，表示结点个数。

第三行 $n$ 个非负整数 $a_1,a_2,\cdots,a_n$，表示每个结点的点权。

接下来 $n-1$ 行，每行两个正整数 $u,v$，表示一条连接结点 $u$ 和结点 $v$ 的树边。

如果 $op=2$：

我们将给出一个输入的模板：
```cpp
#include <cstdio>
int a[3000005], u[3000005],v[3000005];
namespace Generate{
	int n,seed;
	static const int mod=1e9;
	int Rand(int x){
		seed=(1ll*seed*0x66CCF+19260817ll)%x+1;
		seed=(1ll*seed*0x77CCF+20060428ll)%x+1;
		seed=(1ll*seed*0x88CCF+12345678ll)%x+1;
		seed=(1ll*seed*0x33CCCCFF+10086001ll)%x+1;
		return seed;
	}
	void RS(int* a, int* u, int* v){ //你需要传入三个参数，分别表示点权，一条边的两个端点 
		int cnt=0;
		for(int i=1;i<=n;i++)a[i]=Rand(mod); 
		for(int i=2;i<=n;i++){
			int fa=Rand(i-1);
			cnt++;
			u[cnt]=fa,v[cnt]=i;
		}
	}
};
int main () {
	int op;
	scanf("%d",&op);
	if(op==1){
		//直接输入 
	}else{
		int n;
		scanf("%d %d",&Generate::seed,&n);//输入种子和n 
		Generate::n=n;//记得赋值 
		Generate::RS(a,u,v); //开始工作 
	}
	return 0;
}
```

第二行两个整数 $seed$ 和 $n$，表示生成器的种子与结点个数。
## 输出格式

一行一个整数，表示最少的操作次数。
## 样例

### 样例输入 #1
```
1
4
1 2 1 2
1 2
2 3
2 4
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
1
8
1 4 2 8 5 7 8 1
1 2
2 3
2 4
2 5
1 6
6 7
6 8
```
### 样例输出 #2
```
19
```
### 样例输入 #3
```
2
10086001 100000
```
### 样例输出 #3
```
26892182890608
```
## 提示

#### 样例解释 2
给出的树形态如下，括号中的数字表示该点的点权。

![样例2](https://cdn.luogu.com.cn/upload/image_hosting/djmtr8s9.png)

一种最优的操作方案为 $(3,4)\times2,(4,5),(4,4)\times4,(5,5)\times4,(4,7),(7,8),(6,7)\times6$。其中 $(u,v)$ 表示对从 $u$ 到 $v$ 的简单路径进行一次操作。

------------
#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$op\in\{1,2\}$，$1\le seed\le 10^9$，$1\le n\le 3\times 10^6$，$0\le a_i\le10^9$，$1\le u,v\le n$，保证 $u\ne v$。

| 子任务 | 分值 |    $op$    |           $n$            |      $a_i$      | 特殊性质 |
| :----: | :--: | :--------: | :----------------------: | :-------------: | :------: |
|   1    |  1   |    $1$     |           $2$            |        /        |    /     |
|   2    |  4   |    $1$     |           $3$            |        /        |    /     |
|   3    |  10  |    $1$     |      $\leq 6$       |  $\leq 3$  |    /     |
|   4    |  5   |    $1$     |     $\leq 10^6$     |        /        |    A     |
|   5    |  15  |    $1$     |      $\leq 50$      |        /        |    /     |
|   6    |  5   |    $1$     | $\leq 5\times 10^3$ | $\leq 100$ |    B     |
|   7    |  10  |    $1$     |     $\leq 10^5$     | $\leq 100$ |    B     |
|   8    |  10  |    $1$     |     $\leq 10^5$     |        /        |    C     |
|   9    |  10  |    $1$     |     $\leq 10^5$     | $\leq 100$ |    /     |
|   10   |  30  |    /     |            /             |        /        |    /     |


- 特殊限制 A：对于第 $i$ 条边 $(u,v)$，保证 $u=i,v=i+1$。
- 特殊限制 B：输入的边构成一棵满二叉树。
- 特殊限制 C：对于 $\forall 1\le i\le n$ 有 $a_i=1$。




------------
#### 提示
Subtask 10 时限 2S。

对于 $op=2$ 的数据，输入的模板只用于减小输入量，标程不依赖该数据生成方式。

【2024.7.2 补充】@[Edward1002001](https://www.luogu.com.cn/user/151415) 指出，Subtask 10 的数据生成器生成的树形并没有随机性。（因为在生成 $2$ 的父亲时，最终 `seed` 一定会变为 $1$，此后的随机序列就完全相同了。）这一点不影响数据的正确性，但导致数据强度下降，我们为此致歉。鉴于本题提交较多，不做题面和数据修改。


---

---
title: "教材运送"
layout: "post"
diff: 省选/NOI-
pid: P7247
tag: ['O2优化']
---
# 教材运送
## 题目背景

&emsp;&emsp;“如果天依来当志愿者的话，说不定会被累死哟。”

------------

&emsp;&emsp;“七年三班又在什么鬼地方啊……”，不信这个邪的小灰毛喘息着抱怨。发丝凝着汗珠，慵懒地趴在白皙的后颈，粘黏感若有若无地在心里描画着燥热。数十本教材抵在胸口，大腿前伸直的双手托着艰难的重量，贴着扶手一步一步挪上漫长的台阶。

&emsp;&emsp;背后，一撮可爱的棕色呆毛蹦蹦跳跳地跟了上来，“所以\~需要帮忙吗？”
## 题目描述

魔都中学的教学楼是一棵有 $n$ 个结点的树，结点 $i$ 对应编号为 $i$，人数为 $a_i$ 的教室。无向边 $i$ 描述为 $(u_i,v_i,b_i)$，对应连接教室 $u_i$ 和 $v_i$，垂直高差为 $b_i\ \text{m}$ 的台阶。

新学期开学，需要为同学们分发教材，不过传送系统的故障导致教材散落在各个教室。当天依在教室 $u$ 时，会随机抱起属于教室 $v~(v\in[1,n])$ 的 $a_v$ 本教材，并沿连接教室 $u,v$ 的唯一简单路径将这些教材送到教室 $v$。设天依走过的台阶高差为 $b_1,b_2,\cdots,b_m\ \text{m}$，每本教材重力为 $1\text{N}$，那么称此次运送中，天依的托举力做功的绝对值（上台阶取正功，下台阶取负功的绝对值）为 $W=a_v\left( \sum_{i=1}^{m} b_i \right)\text{J}$。换句话来说，一次运送的代价是**终点点权**与**走过路径边权之和**的乘积。

初始时，天依在 $1$ 号教室，但她不认识路，所以阿绫会带着天依运送教材，使得天依到达过每个教室至少一次。那么在达到这一目标之前，天依托举力做功的绝对值之和的期望为多少 $\text{J}$？

**由于答案可能是一个小数，为了避免损失精度，请输出答案在 $998244353$ 模意义下的值。**

------------

#### 简化题意

给定一棵包含 $n$ 个点，有点权和边权的无根树。设当前位置 $s$（初始时 $s=1$），每次在 $n$ 个结点内随机选择目标结点 $t$，付出「$s$ 到 $t$ 的简单路径上的边权之和」$\times$「$t$ 的点权」的代价，标记（可以重复标记）点 $t$ 并把 $s$ 置为 $t$。求每个点至少被标记一次时（其中 $1$ 号结点一开始就被标记）代价之和的期望。答案对 $998244353$ 取模。
## 输入格式

第一行输入一个整数 $n$，含义如题所述。

第二行有 $n$ 个整数，表示每个教室的人数。

随后 $n-1$ 行，每行三个整数 $u_i,v_i,b_i$ 表示教室 $u_i$ 与教室 $v_i$ 之间有一垂直高差为 $b_i\ \text{m}$ 的台阶。
## 输出格式

一行一个整数，表示答案在 $998244353$ 模意义下的值。
## 样例

### 样例输入 #1
```
3
1 2 3
1 2 1
2 3 1
```
### 样例输出 #1
```
332748127
```
### 样例输入 #2
```
5
2 3 4 2 5
1 2 3
2 4 2
2 5 5
1 3 3
```
### 样例输出 #2
```
615584181
```
### 样例输入 #3
```
2
1 2
1 2 2
```
### 样例输出 #3
```
4
```
## 提示

------------
#### 数据规模与约定
**本题采用捆绑测试。**

对于 $100\%$ 的数据，$1\le n\le 10^6$，$1\le a_i,b_i\lt 998244353$，$1\le u_i,v_i\le n$，保证 $u_i\ne v_i$。

| 子任务 | 分值 |         $n$          |               特殊限制                |
| :----: | :--: | :------------------: | :-----------------------------------: |
|   1    |  5  |      $ \le 3$       |                   /                   |
|   2    |  10  |      $ \le 13$       |                   /                   |
|   3    |  10  |      $ \le 20$       |                   /                   |
|   4    |  25  | $ \le 5\times 10^3 $ |                   /                   |
|   5    |  5   |          /           | 对于 $\forall 1\le i\le n$，$a_i=1$ |
|   6    |  10  |          /           | 对于每一条边，$v_i=u_i+1$，即树是一条链。 |
|   7    |  35  |          /           |                   /                   |



---

---
title: "纯洁憧憬"
layout: "post"
diff: 省选/NOI-
pid: P7278
tag: []
---
# 纯洁憧憬
## 题目背景

少年对他的憧憬，简直连续不断。  
少年的思绪，如同许多数字的排列一般凌乱。
## 题目描述

对于一个 $n$ 阶排列 $p_1,\dots,p_n$ 和一个区间 $[l,r]$，若 $\max\limits_{l\le i\le r} p_i - \min\limits_{l\le i\le r} p_i = r - l$，则称 $[l,r]$ 为一个**连续段**。

对于一个连续段 $[l,r]$，若其满足 $2 \le r - l + 1 < n$，则称 $[l,r]$ 为一个**非平凡连续段**。

**少年的思绪**可以抽象成一个**至少存在一个**长度大于 $k$ 的非平凡连续段的排列。

少年会给定 $n,k$，并询问你有多少 $n$ 阶排列可能是少年的思绪。答案对 $10^9 + 7$ 取模。
## 输入格式

第一行，两个正整数 $n,k$。
## 输出格式

一行，一个非负整数表示答案。
## 样例

### 样例输入 #1
```
3 2
```
### 样例输出 #1
```
0
```
### 样例输入 #2
```
4 2
```
### 样例输出 #2
```
20
```
## 提示

对于 $20\%$ 的数据，$n \le 10$；  
对于 $100\%$ 的数据，$1 \le k < n \le 400$。

#### 样例解释

对于第二个样例，不满足条件的排列有以下 $4$ 种：
1. $[2,1,4,3]$；
1. $[2,4,1,3]$；
1. $[3,4,1,2]$；
1. $[3,1,4,2]$。

另外 $4!-4=20$ 种方案都满足条件，可能是少年的思绪。


---

---
title: "光棱碎片"
layout: "post"
diff: 省选/NOI-
pid: P7279
tag: ['O2优化']
---
# 光棱碎片
## 题目背景

碎片在少年的世界里四处飘散。  
最后被少年收集起，成为一列仿若无意义的字符。
## 题目描述

少年只剩一个字符串 $S$，它的长度为 $n$，下标以 $1 \dots n$ 编号；  
以及一个数组 $a_{1\dots n}$。

少年写出了两个数 $L,R$ 并尝试寻找那些被光芒照耀过的碎片：  
对于 $S$ 中两个出现位置不同而本质相同的子串 $(S_{l_1\dots r_1},S_{l_2\dots r_2})$，若 $L \le (a_{r_1} \oplus a_{r_2}) + (r_1 - l_1 + 1) \le R$，则这两个子串之间存在光芒。  
其中 $S_{l\dots r}$ 表示 $S$ 的下标在 $[l,r]$ 内的字符顺次连接构成的子串，$\oplus$ 表示按位异或运算。

少年试图寻找，有多少对子串之间存在光芒。  
子串对是无序的。具体地，$(S_{l_1\dots r_1},S_{l_2\dots r_2})$ 和 $(S_{l_2\dots r_2},S_{l_1\dots r_1})$ 视为一个子串对。  
而你只需要将答案对 $998244353$ 取模之后告诉他就行了。
## 输入格式

第一行，一个正整数 $n$。  
第二行，一个字符串 $S$。  
第三行，$n$ 个非负整数 $a_{1\dots n}$。  
第四行，两个非负整数 $L,R$。
## 输出格式

一行，一个非负整数，表示答案。
## 样例

### 样例输入 #1
```
5
abcbc
0 1 2 3 4
2 7
```
### 样例输出 #1
```
2
```
## 提示

对于 $20\%$ 的数据，$n \le 100$；    
对于 $50\%$ 的数据，$n \le 10^3$；  
对于 $100\%$ 的数据，$1 \le n \le 10^5$, $0 \le a_i,L,R \le 10^5$, $L \le R$, $S$ 只包含小写字母。

**「出题人的馈赠」**  
勇敢一点。相信某算法的常数。你想到的可能就是垃圾标算。


---

---
title: "[COCI 2020/2021 #4] Janjetina"
layout: "post"
diff: 省选/NOI-
pid: P7283
tag: ['2020', 'COCI（克罗地亚）']
---
# [COCI 2020/2021 #4] Janjetina
## 题目背景

疫情封禁期间，克罗地亚的所有餐厅均被关闭。

Malnar 先生为此十分伤感。但他不久发现并没有必要感到如此伤心，因此他决定将在封禁结束后周游克罗地亚，并在最好的餐厅中享用最美味的羊肉。
## 题目描述

Malnar 先生将访问 $n$ 个城市，分别用整数 $1$ 到 $n$ 表示。同时，他经过调研发现，有 $n-1$ 条连接其中两个城市的双向路。

每条路上均有一家提供羊肉的餐厅，同时给定每个餐厅可以订购的最大羊肉的重量。

他将选择两个城市 $x$ 和 $y$，并以最短路径（指经过的最少的路）从 $x$ 到达 $y$。他将且仅将在一家餐厅停留，且这家餐厅为可提供羊肉重量最多的一家（如果有多家这样的餐厅，他将会选择任意一家），并将订购的羊肉全部吃光。

如果通过一种长度为 $l$ 的路径可以吃到 $w$ 千克的羊肉，且 $w-l \ge k$，那么 Malnar 先生就称之为**满意的**。一种路径的长度等同于其经过路的条数。

求有多少个有序数对 $(x,y)$，使得从 $x$ 到 $y$ 的最短路径是满意的。
## 输入格式

第一行输入整数 $n,k$，其中 $n$ 表示城市的个数。

接下来的 $n-1$ 行，每行输入三个整数 $x,y,w$，表示有一条连接城市 $x,y$ 的路，且这条道路有一家提供 $w$ 千克羊肉的餐厅。
## 输出格式

输出满足题意的有序数对的个数。
## 样例

### 样例输入 #1
```
3 1
1 2 3
1 3 2
```
### 样例输出 #1
```
6
```
### 样例输入 #2
```
4 1
1 2 1
2 3 2
3 4 3
```
### 样例输出 #2
```
6
```
### 样例输入 #3
```
5 2
1 2 2
1 3 3
3 4 2
3 5 4
```
### 样例输出 #3
```
8
```
## 提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/orifach0.png)

满足题意的有序数对有 $(1,3),(3,1),(1,5),(5,1),(3,5),(5,3),(4,5),(5,4)$。

#### 数据规模与约定

**本题采用捆绑评测。**

| Subtask | 分值 | 数据范围及约定 |
| :----------: | :----------: | :----------: |
| $1$ | $15$ | $1 \le n \le 1000$ |
| $2$ | $35$ | 城市 $i$ 和 $i+1$ （$1 \le i \le n-1$）直接相连（即最短距离为 $1$） |
| $2$ | $60$ | 无 |

对于 $100\%$ 的数据，$1 \le n,k,w \le 10^5$，$1 \le x,y \le n,x \neq y$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf)  _T4 Janjetina_。**


---

---
title: "[COCI 2018/2019 #1] Teoretičar"
layout: "post"
diff: 省选/NOI-
pid: P7307
tag: ['2018', 'Special Judge', 'O2优化', 'COCI（克罗地亚）']
---
# [COCI 2018/2019 #1] Teoretičar
## 题目描述

Alan 为了避免感到无聊，便让 Goran 给他出一道有趣的题目。由于他忙于准备考试，Goran 的回忆里只有一个巨大的二分图。他把二分图递给 Alan，让他用尽可能少的颜色涂满所有边，使得同种颜色的边没有公共点。

Goran 看到 Alan 的复杂方法后，决定大发慈悲，给定了一个简化版本：令 $C$ 为上述问题的答案，$X$ 为不小于 $C$ 的最小的 $2$ 的正整数次幂。仅需给出一种方案，使得颜色个数不超过 $X$。

请帮助 Alan 解决该题。

注：二分图是一种能够被分成两个集合的图，使得每条边连接的两个点都属于不同集合。
## 输入格式

第一行输入正整数 $L,R,M$，分别表示二分图其中第一个集合的点的个数、第二个集合的点的个数和边的个数。

接下来的 $M$ 行，每行输入两个正整数 $a_i,b_i$，表示第一个集合的第 $a_i$ 个点和第二个集合的第 $b_i$ 个点之间有一条边。数据保证，没有重边。
## 输出格式

第一行输出一个正整数 $K$，表示使用的颜色个数。

接下来的 $M$ 行，每行输出一个正整数 $c_i$（$1 \le c_i \le K$），表示第 $i$ 条边所用颜色。
## 样例

### 样例输入 #1
```
3 3 5
1 1
1 2
2 2
2 3
3 3
```
### 样例输出 #1
```
2
1
2
1
2
1
```
### 样例输入 #2
```
2 4 4
1 1
1 2
1 3
2 4
```
### 样例输出 #2
```
4
1
2
3
4
```
## 提示

#### 样例 2 解释

使用颜色最少个数为 $3$。然而，使用 $4$ 种颜色也是可行的。因为 $4$ 是不小于 $3$ 的最小的 $2$ 的正整数次幂。

#### 数据规模与约定

对于 $20\%$ 的数据，$L,R \le 100$。

对于另外 $20\%$ 的数据，$L,R \le 5000$。

对于 $100\%$ 的数据，$1 \le L,R \le 10^5$，$1 \le M \le 5 \times 10^5$，$1 \le a_i \le L$，$1 \le b_i \le R$。

#### 说明

**这里只选取其中具有梯度的 $10$ 个测试点进行评测，因此满分由 $130$ 调整为 $100$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #1](https://hsin.hr/coci/archive/2018_2019/contest1_tasks.pdf)  _T5 Teoretičar_。**


---

---
title: "[COCI 2018/2019 #3] Sajam"
layout: "post"
diff: 省选/NOI-
pid: P7315
tag: ['2018', 'COCI（克罗地亚）']
---
# [COCI 2018/2019 #3] Sajam
## 题目背景

原时限 5s，这里设为 1s，经测试正确算法可以正常通过。

Milo 组织了一场圣诞游园会。结束后，他想通过 LEET 来实现熄灯。
## 题目描述

每个区域都由 $N$ 行组成，其中每行有 $N$ 个摊位。现有 $3$ 种操作方式改变发光状态指将原来发光的灯改为熄灭，反之亦然）：

1. LEET 将选定一整行，并自动将这行所有的灯改变发光状态。
2. LEET 将选定一整列，并自动将这列所有的灯改变发光状态。
3. Milo 将选定一个摊位，并手动将该摊位的灯改变发光状态。

是否有方案使得 Milo 能在最多进行 $K$ 次操作 3 的情况下，将所有灯全部熄灭？
## 输入格式

第一行输入整数 $N,K$。

接下来的 $N$ 行，每行有 $N$ 个字符 `x` 或 `o`，表示圣诞游园会对应摊位灯的发光状态。其中 `x` 指熄灭，`o` 指发光。
## 输出格式

如果有符合题意的方案，则输出 `DA`，否则输出 `NE`。
## 样例

### 样例输入 #1
```
2 0
ox
ox
```
### 样例输出 #1
```
DA
```
### 样例输入 #2
```
3 1
ooo
xoo
oox
```
### 样例输出 #2
```
NE
```
### 样例输入 #3
```
4 2
oxxo
xxox
oxoo
oxxo
```
### 样例输出 #3
```
DA
```
## 提示

#### 样例 3 解释

一种符合题意的方案：

- 执行操作 $2$，选定第 $1$ 列。
- 执行操作 $3$，选定 $(2,2)$。
- 执行操作 $1$，选定第 $2$ 行。
- 执行操作 $2$，选定第 $4$ 列。
- 执行操作 $3$，选定 $(3,3)$。

#### 数据规模与规定

对于 $15$ 分的数据，$K=0$。

对于另外 $15$ 分的数据，$N \le 100$。

对于另外 $30$ 分的数据，$K \lt \dfrac{N}{2}$。

对于 $100\%$ 的数据，$1 \le N \le 1000$，$0 \le K \le N$。

#### 说明

**本题分值按 COCI 原题设置，满分 $90$。这里只选取其中具有梯度的 $18$ 个测试点进行评测。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #3](https://hsin.hr/coci/archive/2018_2019/contest3_tasks.pdf)  _T3 Sajam_。**


---

---
title: "[COCI 2018/2019 #3] NLO"
layout: "post"
diff: 省选/NOI-
pid: P7316
tag: ['2018', 'COCI（克罗地亚）']
---
# [COCI 2018/2019 #3] NLO
## 题目描述

给定一个 $N \times M$ 的矩形麦田。麦田的每个区域都生长有一定量的草。所有区域的初始草量均为 $1$。

在 $K$ 天内，圆形的 UFO 将降落在麦田上并画圆。在第 $i$ 天早上，一个半径为 $R_i$ 的 UFO 将降落在区域 $(X_i,Y_i)$，并使得以该区域为圆心，$R_i$ 的半径内的所有区域将会受到影响。如果一个区域 $(x,y)$ 受到影响，且 $(X_i-x)^2+(Y_i-y)^2 \le R_i^2$，则该区域的草量将降为 $0$。在新的一天到来时，每个区域的草量都会增加 $1$。

求在第 $K$ 天晚上，所有区域的草量之和。
## 输入格式

第一行输入正整数 $N,M$，表示麦地规模。

第二行输入正整数 $K$，表示天数。

接下来的 $K$ 行中的第 $i$ 行，输入正整数 $X_i,Y_i,R_i$，表示降落的区域和 UFO 的半径。
## 输出格式

输出草的总量。
## 样例

### 样例输入 #1
```
6 6
3
4 4 2
3 3 2
2 4 1
```
### 样例输出 #1
```
68
```
### 样例输入 #2
```
100 100
2
50 50 49
30 30 29
```
### 样例输出 #2
```
9534
```
### 样例输入 #3
```
33333 44444
1
11111 22222 9999
```
### 样例输出 #3
```
1167355751
```
## 提示

#### 样例 1 解释

第一天晚上的麦田：

|$1$|$1$|$1$|$1$|$1$|$1$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|$1$|$1$|$1$|$\red 0$|$1$|$1$|
|$1$|$1$|$\red 0$|$\red 0$|$\red 0$|$1$|
|$1$|$\red 0$|$\red 0$|$\red 0$|$\red 0$|$\red 0$|
|$1$|$1$|$\red 0$|$\red 0$|$\red 0$|$1$|
|$1$|$1$|$1$|$\red 0$|$1$|$1$|

第二天晚上的麦田：

|$2$|$2$|$\red 0$|$2$|$2$|$2$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|$2$|$\red 0$|$\red 0$|$\red 0$|$2$|$2$|
|$\red 0$|$\red 0$|$\red 0$|$\red 0$|$\red 0$|$2$|
|$2$|$\red 0$|$\red 0$|$\red 0$|$1$|$1$|
|$2$|$2$|$\red 0$|$1$|$1$|$2$|
|$2$|$2$|$2$|$1$|$2$|$2$|

第三天晚上的麦田：

|$3$|$3$|$1$|$\red 0$|$3$|$3$|
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
|$3$|$1$|$\red 0$|$\red 0$|$\red 0$|$3$|
|$1$|$1$|$1$|$\red 0$|$1$|$3$|
|$3$|$1$|$1$|$1$|$2$|$2$|
|$3$|$3$|$1$|$2$|$2$|$3$|
|$3$|$3$|$3$|$2$|$3$|$3$|

因此总草量为 $68$ 单位。

#### 数据规模与约定

对于 $20\%$ 的数据，$N,M \le 1000$。

对于 $100\%$ 的数据，$1 \le N,M \le 10^5$，$1 \le K \le 100$，$1 \lt X_i \lt N$，$1 \lt Y_i \lt M$，$1 \le R_i \le \min(X_i-1,Y_i-1,N-X_i,M-Y_i)$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #3](https://hsin.hr/coci/archive/2018_2019/contest3_tasks.pdf)  _T4 NLO_。**


---

---
title: "[COCI 2018/2019 #3] Praktični"
layout: "post"
diff: 省选/NOI-
pid: P7317
tag: ['2018', 'Special Judge', 'COCI（克罗地亚）']
---
# [COCI 2018/2019 #3] Praktični
## 题目描述

给定一个包含 $N$ 个结点和 $M$ 条边的无向图。每条边有一个小于 $10^9$ 的权值。

当一个环上的所有边的权值的异或和为 $0$，该环被称作好环。

可以对无向图进行若干次操作。每次操作包含下列步骤：

- 选定一个整数 $x$。
- 选定一个包含若干条边的非空集合。
- 给该集合中每条边都异或上 $x$。

请在尽可能少的操作次数之下使得无向图中的所有简单回路都是好环。请求出最少操作次数，并输出对应的操作参数。
## 输入格式

第一行输入正整数 $N,M$，分别表示结点和边的数量。

接下来的 $M$ 行中的第 $i$ 行，输入 $a_i,b_i,p_i$，分别表示第 $i$ 条边连接的结点和边的权值。保证图联通，且无重边。
## 输出格式

第一行输出 $K$，表示需要操作的最少次数。

接下来的 $K$ 行，每行输出若干个数，用空格分开：

- 第一个数为选定的数 $x$。
- 第二个数位 $B$，表示选定的边的数量。
- 接下来输出 $B$ 个数 $E_i$（$1 \le E_i \le M$），表示选定的边的序号。这 $B$ 个数必须按照从小到大的顺序输出。

输出的所有数必须小于等于 $2 \times 10^9$。
## 样例

### 样例输入 #1
```
4 4
1 2 10
2 3 9
3 4 8
4 1 7
```
### 样例输出 #1
```
1
12 3 1 2 3
```
### 样例输入 #2
```
2 1
1 2 3
```
### 样例输出 #2
```
0
```
### 样例输入 #3
```
6 8
1 2 6
2 3 1
3 5 6
3 1 5
4 5 0
3 6 0
4 2 8
4 1 1
```
### 样例输出 #3
```
2
2 2 4 6
15 1 7
```
## 提示

#### 样例 1 解释

图的初始和结束状态（在初始状态的基础上给前三条边的权值异或上 $12$）分别如下方左图和右图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/zh4zuicc.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/lbmx5f8v.png)

#### 样例 2 解释

该无向图无环，因此题意已经满足，不需要进行修改，因此最少操作次数为 $0$。

#### 数据规模与约定

对于 $20\%$ 的数据，$K=1$。

对于另外 $40\%$ 的数据，输入的所有数均小于等于 $10^6$。

对于 $100\%$ 的数据，$1 \le N,M \le 10^5$，$1 \le a_i,b_i \le N$，$a_i \neq b_i$，$0 \le p_i \le 10^9$。

#### 说明

**本题分值按 COCI 原题设置，满分 $130$。**

**题目译自 [COCI2018-2019](https://hsin.hr/coci/archive/2018_2019/) [CONTEST #3](https://hsin.hr/coci/archive/2018_2019/contest3_tasks.pdf)  _T5 Praktični_。**


---

---
title: "「MCOI-07」Dream and Discs"
layout: "post"
diff: 省选/NOI-
pid: P7327
tag: ['O2优化']
---
# 「MCOI-07」Dream and Discs
## 题目背景

**均匀随机** 指对所有可行的结果随机选一个结果，其中所有可行结果等概率被选择。
## 题目描述

Dream 有 $n$ 片音乐盘，编号为 $1$ 到 $n$。所有盘都存恰好一首歌，其中编号为 $i$ 的盘所存储歌由正整数 $a_i$ 表示。$a_i$ 满足 $1\le a_i\le n$。  
Dream 打算**均匀随机**选择一个编号区间 $P_1$ 和一个歌曲区间 $S_1$，其中 $P_1\subseteq [1,n]$，$S_1\subseteq [1,n]$，并且所有区间端点均为正整数。  
Dream 取完两个区间，他会选择尽量多的盘，使得盘编号在 $P_1$ 里，歌曲在 $S_1$ 里，并且所有歌曲互不相同。他准备把这集音乐盘给 Tommy。  
Dream 构造完集合发现他选了太多音乐盘，决定由以上选区间方法再次**均匀随机**选取两个区间 $P_2$ 和 $S_2$，其中 $P_2\subseteq P_1$ 并 $S_2\subseteq S_1$。这次，他构造的音乐盘集需要满足编号在 $P_2$ 里，歌曲在 $S_2$ 里。Dream 仍然会选尽量大，歌曲互不相同的集合。  
**Dream 永远不会选空区间。**  
现在 Tommy 感觉 Dream 给他的音乐盘太少了。请帮 Tommy 计算 Dream 第二次选取 **平均** 导致的集合大小减少量。  
这里，平均对所有合法 $(P_1,S_1,P_2,S_2)$ 选取方案等权重平均。
## 输入格式

第一行一个正整数 $n$。  
第二行 $n$ 个正整数，依次表示 $a_1,a_2,\dots,a_n$。
## 输出格式

假设答案可以表示为 $p/q$，其中 $p$ 和 $q$ 互质。请输出 $p\cdot q^{-1}\pmod{10^9+7}$。
## 样例

### 样例输入 #1
```
2
1 2
```
### 样例输出 #1
```
920000007
```
### 样例输入 #2
```
3
1 1 2
```
### 样例输出 #2
```
480000004
```
### 样例输入 #3
```
5
1 2 1 3 2
```
### 样例输出 #3
```
734081639
```
## 提示

#### 样例 1 解释

 - $P_1=[1,1],S_1=[1,1]$
   - $P_2=[1,1],S_2=[1,1],\Delta=1-1=0$
 - $P_1=[1,1],S_1=[1,2]$
   - $P_2=[1,1],S_2=[1,1],\Delta=1-1=0$
   - $P_2=[1,1],S_2=[1,2],\Delta=1-1=0$
   - $P_2=[1,1],S_2=[2,2],\Delta=1-0=1$
 - $P_1=[1,1],S_1=[2,2]$
   - $P_2=[1,1],S_2=[2,2],\Delta=0-0=0$
 - $P_1=[1,2],S_1=[1,1]$
   - $P_2=[1,1],S_2=[1,1],\Delta=1-1=0$
   - $P_2=[1,2],S_2=[1,1],\Delta=1-1=0$
   - $P_2=[2,2],S_2=[1,1],\Delta=1-0=1$
 - $P_1=[1,2],S_1=[1,2]$
   - $P_2=[1,1],S_2=[1,1],\Delta=2-1=1$
   - $P_2=[1,1],S_2=[1,2],\Delta=2-1=1$
   - $P_2=[1,1],S_2=[2,2],\Delta=2-0=2$
   - $P_2=[1,2],S_2=[1,1],\Delta=2-1=1$
   - $P_2=[1,2],S_2=[1,2],\Delta=2-2=0$
   - $P_2=[1,2],S_2=[2,2],\Delta=2-1=1$
   - $P_2=[2,2],S_2=[1,1],\Delta=2-0=2$
   - $P_2=[2,2],S_2=[1,2],\Delta=2-1=1$
   - $P_2=[2,2],S_2=[2,2],\Delta=2-1=1$
 - $P_1=[1,2],S_1=[2,2]$
   - $P_2=[1,1],S_2=[2,2],\Delta=1-0=1$
   - $P_2=[1,2],S_2=[2,2],\Delta=1-1=0$
   - $P_2=[2,2],S_2=[2,2],\Delta=1-1=0$
 - $P_1=[2,2],S_1=[1,1]$
   - $P_2=[2,2],S_2=[1,1],\Delta=0-0=0$
 - $P_1=[2,2],S_1=[1,2]$
   - $P_2=[2,2],S_2=[1,1],\Delta=1-0=1$
   - $P_2=[2,2],S_2=[1,2],\Delta=1-1=0$
   - $P_2=[2,2],S_2=[2,2],\Delta=1-1=0$
 - $P_1=[2,2],S_1=[2,2]$
   - $P_2=[2,2],S_2=[2,2],\Delta=1-1=0$

总共有 $25$ 方案，所有方案减量之和为 $14$，于是答案等于 $14/25$。

#### 样例 2 解释

答案为 $144/225$。

#### 样例 3 解释

答案为 $5921/4900$。

#### 数据规模与约定

**本题采用捆绑测试。**

 - Subtask 1（11 pts）：$n\le8$。
 - Subtask 2（17 pts）：$n\le64$。
 - Subtask 3（19 pts）：$n\le1024$。
 - Subtask 4（7 pts）：$a_i\le 10$。
 - Subtask 5（23 pts）：$n\le10^5$。
 - Subtask 6（23 pts）：无特殊限制。  

对于所有数据，$1\le n\le5\cdot10^5,1\le a_i\le n$。


---

---
title: "「MCOI-07」Dream and Machine Learning"
layout: "post"
diff: 省选/NOI-
pid: P7328
tag: ['O2优化']
---
# 「MCOI-07」Dream and Machine Learning
## 题目描述

Dream 构造了一个红石计算机来验证 $b^e\equiv r\pmod m$ 形式的公式。  
Dream 固定了 $b$ 和 $m$ 并且构造了 $n$ 对满足以上条件的 $(e,r)$ 正整数对。  
可惜，Dream 忘记了 $m$ 的具体值。现在他给了你 $b$ 和这 $n$ 对数。请替代 Dream 的计算机，回答 $q$ 组 $b^{a_i}\pmod m$ 形式的询问。
## 输入格式

第一行三个正整数，分别代表 $b$，$n$，和 $q$。  
接下来 $n$ 行，每行两个正整数，分别代表一对 $e$ 和 $r$。  
接下来 $q$ 行，每行一个正整数，代表一个 $a_i$。
## 输出格式

输出 $q$ 行，对应询问的答案。
## 样例

### 样例输入 #1
```
3 8 3
108 75
616 36
220 16
37 66
114 64
514 24
1919 65
810 33
19260817
123456789
23333333

```
### 样例输出 #1
```
3
79
49
```
### 样例输入 #2
```
请见附件 sample.in
```
### 样例输出 #2
```
请见附件 sample.out
```
## 提示

#### 样例 1 解释

可以唯一确定 $m=97$。  
样例 1 仅仅说明题意，并不代表任何 subtask 的任何测试点。

#### 数据规模与约定

**本题采用捆绑测试。**

 - Subtask 1（5 pts）：$m\le10^3$
 - Subtask 2（19 pts）：$m\le10^9$
 - Subtask 3（19 pts）：$m\le10^{19}$
 - Subtask 4（19 pts）：$m\le10^{29}$
 - Subtask 5（19 pts）：$m\le10^{99}$
 - Subtask 6（19 pts）：$m\le10^{199}$

对于 $100\%$ 的数据，$b\in\{2,3\}$，$1\le q\le100$，$2\le e,a_i\le 10^9$，$n=10^5$。  
**保证** $m$ 为质数。  
**保证** 所有 $e$ 互不相同。  
**保证** 数据随机。


---

---
title: "「MCOI-07」Dream and More Discs"
layout: "post"
diff: 省选/NOI-
pid: P7329
tag: ['交互题', 'Special Judge', 'O2优化']
---
# 「MCOI-07」Dream and More Discs
## 题目背景

**本题为 IO 交互题。**
## 题目描述

Dream 将 Tommy 的所有音乐盘分为 $n$ 类，其中第 $i$ 类有 $2^m-1$ 片音乐盘。所有盘都有一个唯一的正整数重要度。  
现在 Dream 已经把所有类之内的音乐盘按照重要度递增排序。Dream 想知道**所有**盘中重要度第 $k$ 小是哪个盘。

由于音乐盘数量实在太多，Dream 不能直接给你所有音乐盘的重要度。在寻找答案时，Dream 允许你访问第 $i$ 类重要度第 $j$ 小的盘重要度值。
## 输入格式

交互开始时，评测机输入第一行为四个正整数 $n$，$m$，$k$，和 $Th$，其中 $Th$ 为最多应用访问次数。  
每一次访问，评测机会回复所访问位置的音乐盘重要度。
## 输出格式

你的程序可以进行两个操作：

 1. `? i j`，表示访问第 $i$ 类型第 $j$ 小音乐盘重要度。评测机会回复这位置重要度。
 2. `! i j`，表示报告全局第 $k$ 小音乐盘为第 $i$ 类的第 $j$ 小音乐盘。
## 样例

### 样例输入 #1
```
2 2 2 22

222
```
### 样例输出 #1
```

? 2 2

! 2 2
```
## 提示

#### 样例 1 解释

Dream 的音乐盘重要度为 $[[2222,22222,222222],[22,222,2222222]]$。  
第 2 类型为 $[22,222]$；第 2 类型的第 2 小重要度为 $222$。  
全局第 2 小重要度也是这音乐盘。

#### 数据规模与约定

**本题采用捆绑测试。**

|  Subtask | 分值 | $n$ | $m$ | $k$ | $Th$ |
| ----------- | ----------- | ----------- | ----------- | ----------- | ----------- |
| 1 | 1 pts | $1$ | $1$| $1$| $15,000$ |
| 2 | 9 pts | $50$ | $8$ | 无 | $15,000$ |
| 3 | 19 pts | $20$ | $11$ | 无 | $15,000$ |
| 4 | 17 pts | $50$ | $11$ | 无 | $6,666$ |
| 5 | 23 pts | $50$ | $11$ | 无 | $2,333$ |
| 6 | 31 pts | $50$ | $11$ | 无 | $1,111$ |

对于所有数据，$1\le k\le n(2^m-1)$，所有音乐盘的重要度互不相同并且小于等于 $10^{18}$。


---

---
title: "「MCOI-04」纯水精灵"
layout: "post"
diff: 省选/NOI-
pid: P7347
tag: ['O2优化']
---
# 「MCOI-04」纯水精灵
## 题目背景

轻策的净水之主——「纯水精灵」洛蒂娅是一个掉水元素角色突破材料的 BOSS。今天你想刷点材料，所以……
## 题目描述

洛蒂娅所在的水面上有 $n$ 块平台，初始时均未沉没。有 $m$ 对不同的平台彼此相连。洛蒂娅与敌人战斗了 $k$ 个回合。每一回合，她可以选择一些未沉没的平台，让这些平台沉没（可以不选，但不可以让全部平台沉没）。然后她会选择最多的平台，满足任意两块选择的平台之间都相连，在每块平台上召唤一种不同的水之幻形。$k$ 回合结束后，洛蒂娅对敌人的伤害就是每回合召唤的水之幻形数量之和。洛蒂娅想知道，对于她的所有不同选择方案，伤害的总和是多少。两种方案被视为不同当且仅当存在一回合，使得两种方案在这一回合沉没的平台不同，而与召唤水之幻形的平台无关。由于答案可能很大，你需要输出它对 $10^9+7$ 取模的结果。

简要题意：给定无自环无重边的无向图，$k$ 回合中每回合可以删去现有点集的任意真子集，求所有方案中每回合后剩下的图最大团大小之和模 $10^9+7$。
## 输入格式

第一行输入三个整数 $n,m,k$，分别表示平台数，相连的平台对数，回合数。

接下来 $m$ 行每行两个整数 $x,y$，表示 $x$ 号平台和 $y$ 号平台相连。平台从 $0$ 到 $n-1$ 编号。保证没有自环和重边。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
2 1 2
0 1
```
### 样例输出 #1
```
14
```
### 样例输入 #2
```
5 7 100
0 1
1 2
2 3
3 4
0 4
0 3
0 2
```
### 样例输出 #2
```
969766107
```
## 提示

#### 样例解释

有五种不同的方案：

- 第一回合让 $0$ 号平台沉没，第二回合不选，伤害是 $1+1=2$。
- 第一回合让 $1$ 号平台沉没，第二回合不选，伤害是 $1+1=2$。
- 第一回合不选，第二回合让 $0$ 号平台沉没，伤害是 $2+1=3$。
- 第一回合不选，第二回合让 $1$ 号平台沉没，伤害是 $2+1=3$。
- 两回合都不选，伤害是 $2+2=4$。

五种方案的总伤害是 $2+2+3+3+4=14$。

#### 数据范围

本题采用捆绑测试，数据范围符合下表：

| 测试点编号 | $n\le$ | $k\le$ | 得分 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $10$ | $1$ | $10$ |
| $2$ | $16$ | $100$ | $10$ |
| $3$ | $20$ | $100$ | $20$ |
| $4$ | $26$ | $1$ | $20$ |
| $5$ | $26$ | $10^9$ | $20$ |
| $6$ | $28$ | $10^9$ | $20$ |

对于全部数据，$2\le n\le 28$，$1\le m\le\frac{n(n-1)}{2}$，$1\le k\le 10^9$。

#### 提示

请注意时空限制。

#### 说明
 
[Minecraft OI Round 4](https://www.luogu.com.cn/contest/33344) A         
idea & solution：鏡音リン check：namespace_std	


---

---
title: "「MCOI-04」Dream and Strings"
layout: "post"
diff: 省选/NOI-
pid: P7350
tag: ['Special Judge', 'O2优化']
---
# 「MCOI-04」Dream and Strings
## 题目描述

Tommy 的加密系统用了如下的字符串哈希算法：

```cpp
int Hash(std::string s, int base, int mod) {
  int result = 0;
  for(int i=0; i<s.length(); i++)
    result = (1ll * result * base + s[i]) % mod;
  return result;
}
```

其中 $\texttt{base}$ 和 $\texttt{mod}$ 是给定参数，满足 $257\le\texttt{base}\le\texttt{mod}\le10^9+9$，并且 $\texttt{mod}$ 是一个质数。

现在 Dream 要破解 Tommy 的密文，先需要找到一个适合的哈希碰撞。给定 $\texttt{base}$，$\texttt{mod}$，和一个字符串 $S$，请找一个一样长度的字符串 $T$ 使得 $|S|=|T|$，$\texttt{hash(S)=hash(T)}$，但是 $S$ 和 $T$ 有至少一个位置不同。

如果有多个合法的 $T$，输出任意一个即可。
## 输入格式

第一行，两个正整数 $\texttt{base}$ 和 $\texttt{mod}$。  
第二行，一个由小写字母组成的字符串 $S$。
## 输出格式

一行，一个由小写字母组成的字符串 $T$，表示答案。
## 样例

### 样例输入 #1
```
257 997
aabdccbabdcdcadbcabcabaabdbbddbaabcadabcbcdacbbaac
```
### 样例输出 #1
```
lmzaeccihyailccmzzaxshssgbvjvhthllyofzudraatifnzxy
```
## 提示

#### 数据规模与约定

如果 $S$ 是一个字符串，$|S|$ 是它的长度。 

对于前 $10\%$ 的数据，$\texttt{mod}=997$。  
对于前 $40\%$ 的数据，$|S|=2\times10^5$ 并且 $S$ 随机。  
对于 $100\%$ 的数据，$50\le|S|\le2\times10^5$，$257\le\texttt{base}<\texttt{mod}\le10^9+9$，$\texttt{mod}$ 是一个质数。

#### 说明

[Minecraft OI Round 4](https://www.luogu.com.cn/contest/33344) D          
idea & solution：w33z8kqrqk8zzzx33 check：MatKave


---

---
title: "炉心融解"
layout: "post"
diff: 省选/NOI-
pid: P7352
tag: []
---
# 炉心融解
## 题目背景

2020-2021 国家集训队自选题
## 题目描述

你叫了 $n$ 个人来玩游戏。$n$ 个人从 $0$ 到 $n-1$ 编号，按顺序坐成一圈，$0$ 号与 $n-1$ 号相邻。

你给这 $n$ 个人每人发了一张写着数字 $\texttt{0}$ 或 $\texttt{1}$ 的卡片。每个人都可以看到**除了相邻的两个人以外**所有人的卡片数字，也可以看到自己的。

游戏共进行 $m$ 回合。第 $i$ 回合你会向所有人公布 $k_i$ 条信息，信息的格式都是“某个集合里存在某种数字的卡片”。公布完之后：

- 如果某个人手里的卡片写着 $\texttt 0$，且他可以通过推断确定相邻的两个人卡片数字**逻辑或**的值，他就必须大喊“Meltdown！”。
- 如果某个人手里的卡片写着 $\texttt 1$，且他可以通过推断确定相邻的两个人卡片数字**逻辑异或**的值，他就必须大喊“Meltdown！”。

所有人都清楚游戏规则，且都有极强的推断能力，只要依据他已有的信息能够推断出来他就必须要喊。喊话是所有人同时喊，不可以听别人喊完了再继续推断。然后本回合结束，进入下一回合。

除此之外这 $n$ 个人没有任何信息交流。现在给出每个人的卡片数字和你公布的所有信息，求每个人第一次喊出“Meltdown！”是在第几回合。
## 输入格式

输入的第一行包括两个正整数 $n,m$，表示人数和回合数。第二行 $n$ 个整数，分别表示编号 $0$ 到 $n-1$ 的人的卡片上的数字。接下来包括 $m$ 个部分，第 $i$ 部分描述了第 $i$ 回合你公布的信息。

第 $i$ 部分的第一行包括一个非负整数 $k_i$，表示第 $i$ 回合公布的信息条数。接下来 $k_i$ 行，每行第一个正整数 $p$，表示集合的人数，接下来 $p$ 个互不相同的整数表示集合里所有人的编号。最后一个整数 $c$，表示这个集合里存在数字为 $c$ 的卡片。数据保证这些信息是正确的。
## 输出格式

输出包括一行 $n$ 个整数，分别表示编号 $0$ 到 $n-1$ 的人第一次喊出“Meltdown！”时的回合数。如果他自始自终都没有喊“Meltdown！”，这个数输出 $-1$。
## 样例

### 样例输入 #1
```
3 2
1 1 0
2
2 0 2 1
1 1 1
0
```
### 样例输出 #1
```
2 2 1
```
### 样例输入 #2
```
3 2
1 1 1
1
3 0 1 2 1
0
```
### 样例输出 #2
```
2 2 2
```
## 提示

对于 $100\%$ 的数据，$3\le n\le 16$，$\ 1\le m\le 100$，$0\le \sum k\le 2\times 10^3$。


---

---
title: "[COCI 2020/2021 #5] Magenta"
layout: "post"
diff: 省选/NOI-
pid: P7400
tag: ['2020', 'COCI（克罗地亚）']
---
# [COCI 2020/2021 #5] Magenta
## 题目描述

给定一个包含 $n$ 个结点，$n-1$ 条边的连通图，其中结点编号分别为 $1,2,\cdots,n$。这 $n-1$ 条边被涂成了不同的颜色，其中包含蓝色、红色和洋红。

Paula 和 Marin 的棋子分别从结点 $a$ 和 $b$ 出发。两人轮流行走，Paula 先走。Paula 的棋子只能沿着蓝色或洋红的边行走，而 Marin 的棋子只能沿着红色或洋红的边行走。然而，任何时候都不能行走都对方棋子所在的位置。如果由一方的棋子无法行走，则另一方获胜。

如果 Paula 和 Marin 每次都使用最优的走法，求最终胜利的一方。如果游戏无法决出胜负，则为平局。
## 输入格式

第一行输入整数 $n$，表示结点的数量。

第二行输入整数 $a,b$，表示 Paula 和 Marin 棋子的初始位置。

接下来的 $n-1$ 行，每行输入两个整数 $x,y$ 和一个字符串 $\text{color}$。如果 $\text{color}$ 为 $\texttt{plava}$，则表示连接 $x,y$ 的边的颜色为蓝色；如果为 $\texttt{crvena}$，则表示颜色为红色；如果为 $\texttt{magenta}$ 则为洋红。
## 输出格式

如果 Paula 获胜，则输出 $\texttt{Paula}$。

如果 Marin 获胜，则输出 $\texttt{Marin}$。

如果游戏平局，则输出 $\texttt{Magenta}$。
## 样例

### 样例输入 #1
```
3
1 3
3 2 magenta
2 1 magenta
```
### 样例输出 #1
```
Paula
```
### 样例输入 #2
```
5
3 5
1 2 magenta
1 3 magenta
2 4 plava
2 5 crvena
```
### 样例输出 #2
```
Marin
```
### 样例输入 #3
```
5
1 4
2 1 plava
1 3 crvena
5 2 plava
4 1 magenta
```
### 样例输出 #3
```
Magenta
```
## 提示

#### 样例 1 解释

Paula 的最优走法为前往结点 $2$，此时 Marin 无法行走。

#### 样例 2 解释

Paula 将前往结点 $1$，而 Marin 会前往结点 $2$。Paula 只能前往结点 $3$，此时 Marin 前往结点 $1$。这时 Paula 无法行走，Marin 获胜：

![](https://cdn.luogu.com.cn/upload/image_hosting/03flhrlq.png)

#### 数据规模与约定

**本题采用捆绑测试**。

|Subtask|分值|数据范围及约定|
| :----------: | :----------: | :----------: |
|$1$|$30$|$2 \le n \le 100$|
|$2$|$30$|连通图中所有边的颜色都为洋红|
|$3$|$50$|无|

对于 $100\%$ 的数据，$2 \le n \le 10^5$，$1 \le a,b \le n$，$a \neq b$，$1 \le x,y \le n$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2020-2021](https://hsin.hr/coci/) [CONTEST #5](https://hsin.hr/coci/contest5_tasks.pdf)  _T3 Magenta_。**


---

---
title: "[JOI 2021 Final] ロボット (Robot)"
layout: "post"
diff: 省选/NOI-
pid: P7407
tag: ['2021', 'O2优化', 'JOI（日本）']
---
# [JOI 2021 Final] ロボット (Robot)
## 题目描述

给定一个 $N$ 点无向图，这 $N$ 个点编号为 $1 \sim N$，由 $M$ 条边连接，这 $M$ 条边编号为 $1 \sim M$，分别连接点 $A_i$ 与点 $B_i$。这 $M$ 条边染上了颜色，第 $i$ 条边的颜色为 $C_i$，保证 $C_i \in [1,M]$ 但不保证 $C_i$ 互不相等。

你很智能，如果我说一种颜色 $L$，满足下面这些要求的话：

- 存在一条边的颜色为 $L$ 且一个端点为你现在在的点。
- 不存在大于等于两条边满足颜色为 $L$ 且一个端点为你现在在的点。

你就会移动到这条边走向对面的端点，否则你就会原地不动。

你现在在点 $1$ 处，我要你移动到点 $N$ 处，我可以告诉你一些颜色你按照这些颜色走。但这个图有可能不满足能从 $1$ 走向 $N$ 这个条件，因此我要改变一些边的颜色。改变第 $i$ 条边的颜色使其变为另一个在区间 $[1,M]$ 里的数需要的代价为 $P_i$，我想问，至少需要多少代价才能让你成功移动到点 $N$？
## 输入格式

第一行两个整数 $N,M$ 代表无向图点数和边数。

接下来 $M$ 行每行四个整数 $A_i,B_i,C_i,P_i$ 描述一条边。
## 输出格式

一行一个整数代表最小代价，如果无法到达输出 $-1$。
## 样例

### 样例输入 #1
```
4 6
1 4 4 4
3 4 1 3
1 3 4 4
2 4 3 1
2 3 3 2
1 2 4 2
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
5 2
1 4 1 2
3 5 1 4
```
### 样例输出 #2
```
-1
```
### 样例输入 #3
```
5 7
2 3 7 1
1 4 5 1
4 5 3 1
3 4 7 1
2 4 3 1
3 5 6 1
1 2 5 1
```
### 样例输出 #3
```
1
```
## 提示

#### 样例 1 解释

我可以进行如下操作：

- 将第 $4$ 条边的颜色改为 $4$，代价 $1$。
- 将第 $6$ 条边的颜色改为 $2$，代价 $2$。

总代价 $3$，然后我如下使唤你：

- 我说“颜色 $2$！”你从点 $1$ 移动到点 $2$。
- 我说“颜色 $4$！”你从点 $2$ 移动到点 $4$。

#### 样例 2 解释

很遗憾，即使如此智能的你也到达不了第 $N$ 个点。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（34 pts）：$N \le 1000$，$M \le 2000$。
- Subtask 2（24 pts）：$P_i=1$。
- Subtask 3（42 pts）：无特殊限制。

对于 $100\%$ 的数据，$2 \le N \le 10^5$，$1 \le M \le 2 \times 10^5$，$1 \le A_i<B_i \le N$，$1 \le C_i \le M$，$1 \le P_i \le 10^9$，保证图无重边。

#### 说明

翻译自 [The 20th Japanese Olympiad in Informatics Final Round D ロボット的英文翻译 Robot](https://www.ioi-jp.org/joi/2020/2021-ho/2021-ho-t4-en.pdf)。


---

---
title: "[USACO21FEB] Modern Art 3 G"
layout: "post"
diff: 省选/NOI-
pid: P7414
tag: ['USACO', '2021', 'O2优化']
---
# [USACO21FEB] Modern Art 3 G
## 题目描述

厌倦了常规的二维画作（同时也由于作品被他人抄袭而感到失落），伟大的奶牛艺术家牛加索决定转变为更为极简主义的一维风格。她的最新画作可以用一个长为 $N$（$1 \leq N \leq 300$）的一维数组来描述，其中每种颜色用 $1\ldots N$ 中的一个整数表示。

令牛加索感到沮丧的是，尽管这样，她的竞争对手哞奈似乎已经发现了如何抄袭她的这些一维画作！哞奈会用一种颜色涂在一个区间上，等待颜料干了再涂另一个区间，以此类推。哞奈可以使用 $N$ 中颜色中的每一种任意多次（也可以不用）。

请计算哞奈抄袭牛加索的最新一维画作所需要的涂色的次数。
## 输入格式

输入的第一行包含 $N$。

下一行包含 $N$ 个范围在 $1 \ldots N$ 之内的整数，表示牛加索的最新一维画作每个方格上的颜色。
## 输出格式

输出抄袭这一画作所需要的最小涂色次数。
## 样例

### 样例输入 #1
```
10
1 2 3 4 1 4 3 2 1 6
```
### 样例输出 #1
```
6
```
## 提示

#### 样例 1 解释：


在这个样例中，哞奈可以按下列方式进行涂色。我们用 $0$ 表示一个未涂色的方格。

 - 初始时，整个数组均未被涂色：`0 0 0 0 0 0 0 0 0 0`
 - 哞奈将前九个方格涂上颜色 $1$：`1 1 1 1 1 1 1 1 1 0`
 - 哞奈在一个区间上涂上颜色 $2$：`1 2 2 2 2 2 2 2 1 0`
 - 哞奈在一个区间上涂上颜色 $3$：`1 2 3 3 3 3 3 2 1 0`
 - 哞奈在一个区间上涂上颜色 $4$：`1 2 3 4 4 4 3 2 1 0`
 - 哞奈在一个方格上涂上颜色 $1$：`1 2 3 4 1 4 3 2 1 0`
 - 哞奈在最后一个方格上涂上颜色 $6$：`1 2 3 4 1 4 3 2 1 6 `

注意在第一次涂色时，哞奈可以同时在前九个方格之外将第十个方格也同时涂上颜色 $1$，这并不会影响最后的结果。

#### 测试点性质：

 - 对于另外 $15\%$ 的数据，画作中仅出现颜色 $1$ 和 $2$。
 - 对于另外 $30\%$ 的数据，对于每一个 $1\le i\le N$，第 $i$ 个方格的颜色在范围 $\left[12\left\lfloor\frac{i-1}{12}\right\rfloor+1,12\left\lfloor\frac{i-1}{12}\right\rfloor+12\right]$ 之内。
 - 对于另外 $50\%$ 的数据，没有额外限制。

供题：Brian Dean，Benjamin Qi


---

---
title: "[CERC2018] The Bridge on the River Kawaii"
layout: "post"
diff: 省选/NOI-
pid: P7457
tag: ['2018', 'ICPC']
---
# [CERC2018] The Bridge on the River Kawaii
## 题目描述

**译自[ [CERC2018]](https://contest.felk.cvut.cz/18cerc/)[ The Bridge on the River Kawaii](https://contest.felk.cvut.cz/18cerc/solved/bridge.pdf)**

在一个遥远的，叫做 Midsommer 的地方，有一条叫做 delta 的小河。河里流的是深紫色的酸，所以不可能在那里游泳。这条河周围有一些小岛，并且有桥连接它们。每座桥都有一个危险系数，表示通过这座桥有多危险。危险系数越高，通过这座桥就越危险。

一位叫做 Richard Hradecki 的侦探兼悬疑小说作家经常需要通过这些桥来追查案件。在所有可能的路径中，他更倾向于选择最安全的一条，也就是这条路径上经过桥的最大危险系数越低越好。

为了规划路线，Richard 经常让你为他找从一个岛到他要调查的岛的最安全路线。为了满足他的需求，你需要连续处理以下三种事件：

- 当地人在两座岛屿之间建了一座新桥；
- 一只酸性的并且毛茸茸的大粉熊 Lug 出现了，并摧毁了一座桥；
- Richard 要求你找两个岛屿之间的最安全路线。
## 输入格式

第一行包含两个整数 $N,Q$。$N$  是岛屿数（岛屿用 $0…N-1$ 标号），$Q$ 是需要处理的事件数。

接下来 $Q$ 行，每行表示一个事件，包含三或四个整数，说明如下：

- $0XYV$：在 $X$ 岛与 $Y$ 岛之间刚建成一座危险系数为 $V$ 的桥；
- $1XY$：连接 $X,Y$ 两岛的桥刚被摧毁；
- $2XY$：Richard 询问从 $X$ 到 $Y$ 的最安全路径。

对于所有类型的询问，$X,Y$ 表示一对合法的岛屿。保证任意两个岛屿之间最多只存在一座直达的桥，要被摧毁的桥在那一刻是存在的。
## 输出格式

对于每个种类为 $2$ 的事件，输出 $X$ 到 $Y$ 最安全路径上经过的最危险的桥的危险系数。如果 $X$ 与 $Y$ 之间没有路径，输出 $-1$。
## 样例

### 样例输入 #1
```
6 15
0 1 2 1
2 1 4
2 1 5
0 2 3 2
2 1 4
2 1 5
0 3 4 3
2 1 4
2 1 5
0 4 5 4
2 1 4
2 1 5
1 4 5
2 1 4
2 1 5
```
### 样例输出 #1
```
-1
-1
-1
-1
3
-1
3
4
3
-1
```
### 样例输入 #2
```
6 6
0 2 0 4
0 3 4 3
0 0 4 1
0 2 5 4
2 3 2
2 4 2
```
### 样例输出 #2
```
4
4
```
## 提示

$2≤N≤10^5,1≤Q≤10^5,0≤V≤10,0≤X,Y<N,X≠Y$


---

---
title: "[CERC2018] The Lord of the Kings"
layout: "post"
diff: 省选/NOI-
pid: P7463
tag: ['2018', 'ICPC']
---
# [CERC2018] The Lord of the Kings
## 题目描述

**译自[ [CERC2018]](https://contest.felk.cvut.cz/18cerc/) [The Lord of the Kings](https://contest.felk.cvut.cz/18cerc/solved/king.pdf)**

在多年与海外国家的战争后，我们的国家终于成功去除了大多数反动势力和敌人。如此光辉的胜利应该被长时间记住并庆祝。因此，我们的国王宣布将胜利日这一天定为一个公共节日，并且要举行胜利游行。在游行中，军队会跟着国王从他的宫殿出发，访问国家里的每个城市。

国王和他的随从将一种环保的电动直升机作为交通工具。这种直升机有一个缺点，就是它的航程较短。国王让你和你的顾问在一些农场和所有城市中修建停机坪，使得从他的宫殿出发，经过一些停机坪后都可以到达任何城市。然而，建停机坪和基础设施都很费钱。所以要最小化最小化停机坪的修建数量。

此外，由于直升机特殊的设计，国王和他的士兵需要以特殊的方式移动，这就会影响停机坪的数量和位置。

给你一张这个国家的矩形网格地图，其中包含代表村庄，城市和宫殿的网格。同时，也给你了直升机的移动方式——与国际象棋中「车（Rook）」、「后（Queen）」、「象（Bishop）」、「马（Knight）」或「王（King）」之一的移动方式一样（每种棋子的详细移动方式见「数据范围与提示」）。你的任务是求出最少需要在多少农场或城市修停机坪才能够满足国王的需求。国王的宫殿中已经修建了停机坪，因此不需要修一个新的了。
## 输入格式

第一行包含两个整数 $N,M$，表示我们的国家有 $N$ 行 $M$ 列；

第二行两个整数 $X,Y$，表示国王宫殿的位置，接着一个字符，表示移动方式（R——车，Q——后，B——象，N——马，K——王）；

第三行包含一个整数 $T$，表示国家里的城市数；

接下来 $T$ 行，每行包含两个整数 $W,Z$，表示一个城市的位置。所有城市都在不同的网格中，没有城市和宫殿位于同一格。所有既不代表城市也不代表宫殿的格子都是农场。
## 输出格式

输出一行一个整数，表示至少要修建多少停机坪。如果不可能使得国王和他的士兵能够到达每一个城市，输出 $-1$。
## 样例

### 样例输入 #1
```
3 3
3 1 K
2
1 1
1 3
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
3 3
3 1 Q
2
1 1
1 3
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
5 5
4 4 R
4
1 2
2 1
2 5
5 1
```
### 样例输出 #3
```
6
```
## 提示

$1 ≤ N, M ≤ 15,1 ≤ T ≤ 10, 1 ≤ X ,W ≤ N,1≤Y, Z≤M$

下图为直升机的运输方式（同国际象棋对应棋子的行棋规则）：
![#1](https://cdn.luogu.com.cn/upload/image_hosting/ip5cnfsa.png)


---

---
title: "梦现时刻"
layout: "post"
diff: 省选/NOI-
pid: P7481
tag: ['O2优化']
---
# 梦现时刻
## 题目描述

给定 $n,m$ ，保证 $m\le n$，令 $F(a,b)=\sum_{i=0}^{b}\binom{b}{i}\binom{n-i}{a}$。

求 $\bigoplus_{a=1}^{m}\bigoplus_{b=1}^{m}(F(a,b) \bmod 998244353)$。

其中 $\oplus$ 表示异或运算。
## 输入格式

第一行两个整数 $n,m$，意义同题面描述。
## 输出格式

一行一个整数表示答案。
## 样例

### 样例输入 #1
```
3 3
```
### 样例输出 #1
```
7
```
## 提示

**【数据范围】**

**本题采用捆绑测试。**

对于 $100 \%$ 的数据，$1 \le n \le {10}^9$，$1\le m\le 5000$，保证 $m\le n$

- Subtask 1（20 points）：$n \le 500$。
- Subtask 2（30 points）：$n \le 5000$。
- Subtask 3（50 points）：无特殊限制。


---

---
title: "不条理狂诗曲"
layout: "post"
diff: 省选/NOI-
pid: P7482
tag: ['O2优化']
---
# 不条理狂诗曲
## 题目背景

YSGHYYDS
## 题目描述

YSGH 有一个长度为 $n$ 的非负整数序列 $a$，定义 $f(l, r)$ 表示从 $a$ 序列的区间 $[l, r]$ 选择若干不相邻的数的和的最大值。 

YSGH 想知道 $\displaystyle \left[ \sum_{l = 1}^{n} \sum_{r = l}^{n} f(l, r) \right] \bmod ({10}^9 + 7)$ 。
## 输入格式

第一行，一个正整数 $n$，表示序列长度。

第二行，$n$ 个非负整数 $a_1, a_2, \ldots , a_n$。
## 输出格式

仅一行，一个整数，表示答案。
## 样例

### 样例输入 #1
```
3
1 2 4
```
### 样例输出 #1
```
18
```
## 提示

**【样例解释】**

$f(1, 1)=1$，$f(1, 2)=2$，$f(1, 3)=5$，$f(2, 2)=2$，$f(2, 3)=4$，$f(3, 3)=4$。

答案为 $1 + 2 + 5 + 2 + 4 + 4 = 18$。

---

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le {10}^5$，$0 \le a_i \le {10}^9$。

- Subtask 1（10 points）：$n \le 500$。
- Subtask 2（20 points）：$n \le 5000$。
- Subtask 3（20 points）：$a_i \in \{ 0, 1 \}$。
- Subtask 4（20 points）：$a_i \in \{ 1, x \}$，$x$ 是大于 $1$ 的整数。
- Subtask 5（30 points）：无特殊限制。


---

---
title: "「HMOI R1」可爱的德丽莎"
layout: "post"
diff: 省选/NOI-
pid: P7504
tag: ['O2优化']
---
# 「HMOI R1」可爱的德丽莎
## 题目背景

Polaris_Dane 非常菜，他不仅沉迷于数论，而且喜欢玩崩坏 3。
## 题目描述

可爱的德丽莎希望你能帮她求出

$$
\sum_{x = 1}^n\sum_{y = 1}^n\sum_{i = 1}^x[x \bot k_1][i \bot x]\cdot i\cdot \sum_{j = 1}^y[y \bot k_2][j \bot y]\cdot j
$$
的结果。

其中 $[x \bot y] = \begin{cases}1 & \operatorname{gcd}(x,y)=1 \\ 0 & \operatorname{gcd}(x,y)\neq 1\end{cases}$

德丽莎这么可爱，你怎么能不答应她呢？

由于答案可能很大，所以德丽莎只想知道它对 $998244353$ 取模后的结果。
## 输入格式

共一行三个整数 $n, k_1, k_2$。
## 输出格式

仅一行一个数，为所求的答案对 $998244353$ 取模后的结果。
## 样例

### 样例输入 #1
```
2 2 2
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
4 2 2
```
### 样例输出 #2
```
16
```
## 提示

**本题测试点编号倒序排列。**

对于所有数据：
- $1 \le n, k_1, k_2 \le 2 \times 10^9$。

---------

**本题采用捆绑测试。**

| No. | Constraints                   | Score |
| ----------- | ----------------------------- | ----- |
| $1$         | $1\le n,k_1,k_2\le 100$         | $10$  |
| $2$         | $1\le n,k_1,k_2\le 3000$ | $20$  |
| $3$         | $1\le n,k_1,k_2\le 5\times 10^5$ | $20$  |
| $4$         | No further constraints        | $50$  |

---------------

- Idea: Polaris_Dane
- Solution: Polaris_Dane
- Code: Polaris_Dane
- Data: Polaris_Dane


---

---
title: "三到六"
layout: "post"
diff: 省选/NOI-
pid: P7511
tag: ['O2优化']
---
# 三到六
## 题目背景

「听说 JOJO 6 要来力！」  
「好时代，来临力！」  
「可是那个无敌的男人……」  
「啊……在吃刀子之前，让我重温一下『欧拉欧拉』……」
## 题目描述

给定整数 $n,k$ 和一个 $n$ 阶排列 $\pi'$，问多少个排列 $\pi$ 满足恰有 $k$ 个位置 $i$ 满足 $1 \le i \le n$ 且 $\pi_i < \pi_{\pi'_i}$。答案对 $998244353$ 取模。
## 输入格式

第一行，两个整数 $n,k$。

第二行，$n$ 个正整数，表示 $\pi'$。
## 输出格式

一行，一个非负整数，表示满足条件的 $\pi$ 的数量。
## 样例

### 样例输入 #1
```
5 0
1 2 3 4 5
```
### 样例输出 #1
```
120
```
### 样例输入 #2
```
5 1
2 3 4 5 1
```
### 样例输出 #2
```
5
```
### 样例输入 #3
```
5 2
2 4 5 1 3
```
### 样例输出 #3
```
60
```
## 提示

**样例解释**

对于第一组样例，$\pi_i$ 不可能小于 $\pi_i$，故必然满足条件，则答案为 $5! = 120$。 

对于第二组样例，有以下 $5$ 种 $\pi$ 满足条件：

 1. $12345$；
 1. $23451$；
 1. $34512$；
 1. $45123$；
 1. $51234$。

对于第三组样例，不予解释。

**数据范围**

对于 $20\%$ 的数据，$n \le 10$。

对于 $40\%$ 的数据，$n \le 3 \times 10^2$。

对于 $60\%$ 的数据，$n \le 10^3$。

对于另外 $20\%$ 的数据，保证 $\pi'_i = i \bmod n + 1$（$1 \le i \le n$）。

对于 $100\%$ 的数据，$1 \le n \le 2 \times 10^5$，$0 \le k \le n$。


---

---
title: "[省选联考 2021 A 卷] 矩阵游戏"
layout: "post"
diff: 省选/NOI-
pid: P7515
tag: ['各省省选', '2021', 'Special Judge', 'O2优化']
---
# [省选联考 2021 A 卷] 矩阵游戏
## 题目描述

Alice 有一个 $n \times m$ 的矩阵 $a_{i, j}$（$1 \le i \le n$，$1 \le j \le m$），其每个元素为大小不超过 ${10}^6$ 的非负整数。

Bob 根据该矩阵生成了一个 $(n - 1) \times (m - 1)$ 的矩阵 $b_{i, j}$（$1 \le i \le n - 1$，$1 \le j \le m - 1$），每个元素的生成公式为

$$ b_{i, j} = a_{i, j} + a_{i, j + 1} + a_{i + 1, j} + a_{i + 1, j + 1} $$

现在 Alice 忘记了矩阵 $a_{i, j}$，请你根据 Bob 给出的矩阵 $b_{i, j}$ 还原出 $a_{i, j}$。
## 输入格式

**本题有多组数据。**

第一行，一个整数 $T$，表示数据组数。对于每组数据：

第一行，两个正整数 $n, m$，表示矩阵 $a_{i, j}$ 的大小。  
接下来 $n - 1$ 行，每行 $m - 1$ 个非负整数，表示 $b_{i, j}$。
## 输出格式

对于每组数据：

1. 若矩阵 $b_{i, j}$ 无法被生成，则输出一行一个字符串 `NO`。
2. 若矩阵 $b_{i, j}$ 可被生成，则先输出一行一个字符串 `YES`，接下来输出 $n$ 行每行 $m$ 个（用单个空格分隔的）大小不超过 ${10}^6$ 的非负整数表示 $a_{i, j}$。

若有多个矩阵 $a_{i, j}$ 可生成给出的 $b_{i, j}$，输出其中任意一个即可。
## 样例

### 样例输入 #1
```
3
3 3
28 25
24 25
3 3
15 14
14 12
3 3
0 3000005
0 0

```
### 样例输出 #1
```
YES
7 8 8
8 5 4
4 7 9
YES
4 2 2
5 4 6
5 0 2
NO

```
## 提示

**【数据范围】**

对于所有测试数据：$1 \le T \le 10$，$2 \le n, m \le 300$，$0 \le b_{i, j} \le 4 \times {10}^6$。

每个测试点的具体限制见下表：

| 测试点编号 | $n, m \le$ | 特殊限制 |
|:-:|:-:|:-:|
| $1 \sim 4$ | $3$ | 无 |
| $5 \sim 7$ | $10$ | $m = 2$ |
| $8 \sim 10$ | $100$ | $m = 2$ |
| $11 \sim 15$ | $300$ | $0 \le b_{i, j} \le 1$ |
| $16 \sim 20$ | $300$ | 无 |


---

---
title: "[省选联考 2021 A/B 卷] 图函数"
layout: "post"
diff: 省选/NOI-
pid: P7516
tag: ['各省省选', '2021', 'O2优化']
---
# [省选联考 2021 A/B 卷] 图函数
## 题目描述

对于一张 $n$ 个点 $m$ 条边的有向图 $G$（顶点从 $1 \sim n$ 编号），定义函数 $f(u, G)$：

1. 初始化返回值 $cnt = 0$，图 $G' = G$。
2. 从 $1$ 至 $n$ 按顺序枚举顶点 $v$，如果当前的图 $G'$ 中，从 $u$ 到 $v$ 与从 $v$ 到 $u$ 的路径都存在，则将 $cnt + 1$，并在图 $G'$ 中删去顶点 $v$ 以及与它相关的边。
3. 第 $2$ 步结束后，返回值 $cnt$ 即为函数值。

现在给定一张有向图 $G$，请你求出 $h(G) = f(1, G) + f(2, G) + \cdots + f(n, G)$ 的值。

更进一步地，记删除（按输入顺序给出的）第 $1$ 到 $i$ 条边后的图为 $G_i$（$1 \le i \le m$），请你求出所有 $h(G_i)$ 的值。
## 输入格式

第一行，两个整数 $n,m$，表示图的点数与边数。  
接下来 $m$ 行，每行两个整数，第 $i$ 行的两个整数 $x_i, y_i$ 表示一条有向边 $x_i \to y_i$。

数据保证 $x_i \neq y_i$ 且同一条边不会给出多次。
## 输出格式

输出一行 $m + 1$ 个整数，其中第一个数表示给出的完整图 $G$ 的 $h(G)$ 值。第 $i$（$2 \le i \le m + 1$）个整数表示 $h(G_{i-1})$。
## 样例

### 样例输入 #1
```
4 6
2 3
3 2
4 1
1 4
2 1
3 1

```
### 样例输出 #1
```
6 5 5 4 4 4 4

```
### 样例输入 #2
```
见附件中的 graph/graph2.in。
```
### 样例输出 #2
```
见附件中的 graph/graph2.ans。
```
## 提示

**【样例 #1 解释】**

对于给出的完整图 $G$：

1. $f(1, G) = 1$，过程中删除了顶点 $1$。
2. $f(2, G) = 1$，过程中删除了顶点 $2$。
3. $f(3, G) = 2$，过程中删除了顶点 $2, 3$。
4. $f(4, G) = 2$，过程中删除了顶点 $1, 4$。

---

**【数据范围】**

对于所有测试数据：$2 \le n \le {10}^3$，$1 \le m \le 2 \times {10}^5$，$1 \le x_i, y_i \le n$。

每个测试点的具体限制见下表：

| 测试点编号 | $n \le$ | $m\le$ |
|:-:|:-:|:-:|
| $1 \sim 4$ | $10$ | $10$ |
| $5 \sim 11$ | $100$ | $2 \times {10}^3$ |
| $12 \sim 20$ | ${10}^3$ | $5 \times {10}^3$ |
| $21 \sim 25$ | ${10}^3$ | $2 \times {10}^5$ |


---

---
title: "[省选联考 2021 A/B 卷] 滚榜"
layout: "post"
diff: 省选/NOI-
pid: P7519
tag: ['各省省选', '2021', 'O2优化']
---
# [省选联考 2021 A/B 卷] 滚榜
## 题目描述

封榜是 ICPC 系列竞赛中的一个特色机制。ICPC 竞赛是实时反馈提交结果的程序设计竞赛，参赛选手与场外观众可以通过排行榜实时查看每个参赛队伍的过题数与排名。竞赛的最后一小时会进行“封榜”，即排行榜上将隐藏最后一小时内的提交的结果。赛后通过滚榜环节将最后一小时的结果（即每只队伍最后一小时的过题数）公布。

Alice 围观了一场 ICPC 竞赛的滚榜环节。本次竞赛共有 $n$ 支队伍参赛，队伍从 $1 \sim n$ 编号，$i$ 号队伍在封榜前通过的题数为 $a_i$。排行榜上队伍按照过题数从大到小进行排名，若两支队伍过题数相同，则编号小的队伍排名靠前。

滚榜时主办方以 $b_i$ 不降的顺序依次公布了每支队伍在封榜后的过题数 $b_i$（最终该队伍总过题数为 $a_i + b_i$），并且每公布一支队伍的结果，排行榜上就会实时更新排名。Alice 并不记得队伍被公布的顺序，也不记得最终排行榜上的排名情况，只记得每次公布后，本次被公布结果的队伍都成为了新排行榜上的第一名，以及所有队伍在封榜后一共通过了 $m$ 道题（即 $\sum_{i = 1}^{n} b_i = m$）。

现在 Alice 想请你帮她算算，最终排行榜上队伍的排名情况可能有多少种。
## 输入格式

第一行，包含两个正整数 $n, m$，表示队伍数量与它们封榜后的总过题数。  
第二行，包含 $n$ 个正整数，表示 $a_i$。
## 输出格式

仅一行，一个整数，表示答案。
## 样例

### 样例输入 #1
```
3 6
1 2 1

```
### 样例输出 #1
```
5

```
### 样例输入 #2
```
6 50
4 7 9 3 0 3

```
### 样例输出 #2
```
96
```
### 样例输入 #3
```
11 300
6 8 8 12 0 11 6 1 0 15 5

```
### 样例输出 #3
```
30140983

```
## 提示

**【样例 #1 解释】**

1. 最终排名：$1, 3, 2$，滚榜情况（按公布顺序，下同）：$b_2 = 0$，$b_3 = 2$，$b_1 = 4$。

2. 最终排名：$2, 1, 3$，滚榜情况：$b_3 = 2$，$b_1 = 2$，$b_2 = 2$。

3. 最终排名：$2, 3, 1$，滚榜情况：$b_1 = 1$，$b_3 = 2$，$b_2 = 3$。

4. 最终排名：$3, 1, 2$，滚榜情况：$b_2 = 0$，$b_1 = 2$，$b_3 = 4$。

5. 最终排名：$3, 2, 1$，滚榜情况：$b_1 = 1$，$b_2 = 1$，$b_3 = 4$。

---

**【数据范围】**

对于所有测试数据：$1 \le n \le 13$，$1 \le m \le 500$，$0 \le a_i \le {10}^4$。

每个测试点的具体限制见下表：

| 测试点编号 | $n \le$ | $m \le$ |
|:-:|:-:|:-:|
| $1 \sim 2$ | $2$ | $10$ |
| $3 \sim 5$ | $3$ | $10$ |
| $6 \sim 8$ | $8$ | $100$ |
| $9 \sim 12$ | $10$ | $200$ |
| $13 \sim 16$ | $12$ | $300$ |
| $17 \sim 20$ | $13$ | $500$ |


---

---
title: "[省选联考 2021 A 卷] 支配"
layout: "post"
diff: 省选/NOI-
pid: P7520
tag: ['各省省选', '2021', 'O2优化']
---
# [省选联考 2021 A 卷] 支配
## 题目描述

给定一张 $n$ 个点 $m$ 条边的有向图 $G$，其顶点从 $1$ 到 $n$ 编号。

对于任意两个点 $u, v$，若从顶点 $1$ 出发到达顶点 $v$ 的所有路径都需要经过顶点 $u$，则称顶点 $u$ 支配顶点 $v$。特别地，每个顶点支配其自身。

对于任意一个点 $v$，我们将图中支配顶点 $v$ 的顶点集合称为 $v$ 的受支配集 $D_v$。

现在有 $q$ 次互相独立的询问，每次询问给出一条有向边，请你回答在图 $G$ 中加入该条边后，有多少个顶点的受支配集发生了变化。
## 输入格式

第一行，三个整数 $n, m, q$，分别表示图中的顶点数、边数，以及询问数。  
接下来 $m$ 行，每行两个整数 $x_i,y_i$，表示一条有向边从 $x_i$ 到 $y_i$。  
接下来 $q$ 行，每行两个整数 $s_i,t_i$，表示每次询问加入的边从 $s_i$ 到 $t_i$。

数据保证给出的图 $G$ 中，从 $1$ 号点出发能到达所有其他点，并且图中不包含重边与自环。
## 输出格式

对于每个询问，输出一行，一个整数，表示答案。
## 样例

### 样例输入 #1
```
6 6 3
1 2
1 3
3 4
4 5
2 6
4 1
5 6
3 2
2 4

```
### 样例输出 #1
```
1
0
2

```
### 样例输入 #2
```
见附件中的 dominator/dominator2.in。
```
### 样例输出 #2
```
见附件中的 dominator/dominator2.ans。
```
### 样例输入 #3
```
见附件中的 dominator/dominator3.in。
```
### 样例输出 #3
```
见附件中的 dominator/dominator3.ans。
```
## 提示

**【样例 #1 解释】**

对于原图，六个点的受支配集分别为：$D_1 = \{ 1 \}$，$D_2 = \{ 1, 2 \}$，$D_3 = \{ 1, 3 \}$，$D_4 =\{ 1, 3, 4 \}$，$D_5 = \{ 1, 3, 4, 5 \}$，$D_6 = \{ 1, 2, 6 \}$。

加入 $5 \to 6$ 后，$D_6 = \{ 1, 6 \}$，其他点受支配集不变。

加入 $3 \to 2$ 后没有点受支配集改变。

加入 $2 \to 4$ 后，$D_4 = \{ 1, 4 \}$，$D_5 = \{ 1, 4, 5 \}$，其他点受支配集不变。

---

**【数据范围】**

对于所有测试数据：$1 \le n \le 3 \times {10}^3$，$1 \le m \le 2 \times n$，$1 \le q \le 2 \times {10}^4$。

每个测试点的具体限制见下表：

| 测试点编号 | $n \le$ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | 无 |
| $3 \sim 6$ | $100$ | $q \le 100$ |
| $7 \sim 9$ | $1000$ | $m = n - 1$ |
| $10 \sim 15$ | $1000$ | $q \le 2000$ |
| $16 \sim 20$ | $3000$ | 无 |


---

---
title: "Shelter"
layout: "post"
diff: 省选/NOI-
pid: P7525
tag: ['2021', 'O2优化']
---
# Shelter
## 题目背景

![Shelter](https://cdn.luogu.com.cn/upload/image_hosting/dng2ysqs.png)

> It's a long way forward, so trust in me
>
> I'll give them shelter, like you've done for me
>
> And I know, I'm not alone
>
> You'll be watching over us, until you're gone
## 题目描述

在太空里的时间，Rin 除了在虚拟世界里自由创作，每天还会进行一个有趣的小游戏。

最初来到太空时，她的父亲留给她了一个由英文小写字母组成的非空的字符串 $s$，其长度为 $n$。每天，Rin 都会找到一个最大的整数 $i$（$0\le i<|s|$）使得字符串的长度为 $i$ 的前缀与其长度为 $i$ 的后缀相同（注意 $i$ 可能为 $0$），并将这个 前缀 / 后缀 追加在整个字符串的最后面形成新的字符串。例如，当字符串为 `mivikismivik` 时，最大的 $i=5$（字符串长为 $5$ 的前缀后缀皆为 `mivik`），于是 Rin 将 `mivik` 追加在字符串后面形成新字符串 `mivikismivikmivik`。

在太空中度过 $K$ 天后，这个字符串已经变得很长，Rin 突然很好奇这个字符串的长度现在是多少，你能帮帮她吗？由于答案可能很大，你只需要告诉她答案对 $998244353$ 取模的结果即可。
## 输入格式

第一行两个正整数 $n,K$，分别代表最初字符串的长度和 Rin 在太空中度过的天数。

第二行一个长度为 $n$ 的小写英文字母组成的字符串 $s$，代表 Rin 的父亲留给她的字符串。
## 输出格式

一行一个整数，代表 $K$ 天后字符串的长度对 $998244353$ 取模的结果。
## 样例

### 样例输入 #1
```
7 1
abcdabc
```
### 样例输出 #1
```
10
```
### 样例输入 #2
```
5 2
ioioi
```
### 样例输出 #2
```
11
```
### 样例输入 #3
```
8 50
idolidol
```
### 样例输出 #3
```
263923940
```
## 提示

### 样例解释

样例一：操作一次后得到字符串 `abcdabcabc`，长度为 $10$。

样例二：操作一次后得到字符串 `ioioiioi`，再操作一次得到 `ioioiioiioi`，长度为 $11$。

### 数据范围

对于全部数据，有 $1\le n\le 2\cdot 10^6$，$1\le K\le 10^{18}$。

Subtask 1 (15 pts)：保证 $s$ 只由一种字母构成。

Subtask 2 (20 pts)：保证 $s$ 有长度不为 $|s|$ 的整周期（即长度是 $|s|$ 的约数的周期）。

Subtask 3 (65 pts)：无特殊限制。



---

---
title: "[BJWC2014] 珠链"
layout: "post"
diff: 省选/NOI-
pid: P7546
tag: ['2014', '北京']
---
# [BJWC2014] 珠链
## 题目描述

Alex 喜欢玩网络游戏，认为这是智力和体力的综合锻炼。在一次游戏活动中，他意外获得了一个传说中威力极其强大的法宝：珠链。 

珠链，顾名思义，就是由许多小珠子串起来的一条链。珠子有很多种颜色。Alex 听说过，只有将珠链打磨纯净，珠链才能发挥最大的威力。 

纯净珠链是指这样的珠链：它可以分成若干个长度相等的段，使任何两段的任何相同位置的珠子的颜色均不同，相同位置指珠子在段内的相对位置相同；而且每段的长度以及划分的段数也是有规范的，Alex 记得，每段包含的珠子数目必须在 $L$ 到 $R$ 之间，而且划分的段数不能少于 $S$。 

所谓打磨，就是从珠链的首和尾拿掉连续的若干个珠子。打磨后的纯净珠链的威力等于它的每个珠子具有的魔力值之和。

一个珠子的魔力值只与它在打磨前的珠链中的位置有关。在查找和分析了大量实验数据以后，Alex 发现珠子的魔力值等于珠子原来位置编号的约数个数！ 

兴奋不已的 Alex 想将珠链打磨成威力最大的纯净珠链。然而，马上要参加期末考试的 Alex 来不及计算了，你能否帮助 Alex 算出最大的威力值呢？ 
## 输入格式

第一行是四个整数 $N,L,R,S$。 

第二行是一个长度等于 $N$ 的字符串，表示 Alex 得到的珠链。字符串的第 $i$ 个字符表示珠链的第 $i$ 个珠子的颜色。相同字母表示相同颜色。珠子的位置从 $1$ 编号到 $N$。

**保证输入的字符串只包含大写和小写的英文字母，并且字母区分大小写。**
## 输出格式

输出一行，表示打磨后的纯净珠链的最大威力值。

如果无法打磨成满足要求的纯净珠链，输出 `-1`。
## 样例

### 样例输入 #1
```
7 2 3 2
abcbcaa
```
### 样例输出 #1
```
15
```
## 提示

#### 【样例解释】

能够打磨出的合乎要求的纯净珠链有三种：$\texttt{bc/aa}$，$\texttt{abc/bca}$ 和 $\texttt{bcb/caa}$。其中威力最大的是第三种，其威力值等于 $2 + 2 + 3 + 2 + 4 + 2 = 15$。

如果给出的珠链是纯净珠链，那么可以不打磨。纯净珠链必须能划分成不少于 $S$ 个等长的段且每段长度在 $L$ 到 $R$ 之间。

#### 【数据范围】

对于 $100\%$ 的数据，$1 \le N \le 5 \cdot 10^5$，$1 \le L,R,S \le N$，$0 \le R - L \le 10$。


---

---
title: "[COCI 2020/2021 #6] Geometrija"
layout: "post"
diff: 省选/NOI-
pid: P7553
tag: ['2020', 'COCI（克罗地亚）']
---
# [COCI 2020/2021 #6] Geometrija
## 题目描述

平面内有不共线的 $n$ 个点。如果两条线段 $\overline{AB}$  和 $\overline{CD}$ 有异于 $A, B, C, D$ 的公共点，则称他们「相交」。

记 $S$ 为 $n$ 个点两两相连得到的线段的集合。求不与 $S$ 中任意其他线段相交的线段数量。
## 输入格式

第一行一个整数 $n$。

接下来 $n$ 行，每行两个整数 $x_i, y_i$，表示第 $i$ 个点的坐标。
## 输出格式

一行一个整数，表示满足要求的线段的数量。
## 样例

### 样例输入 #1
```
4
1 1
-1 1
-1 -1
1 -1
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
4
-1 -1
1 -1
0 1
0 0
```
### 样例输出 #2
```
6
```
## 提示

#### 样例 1 解释

符合要求的线段如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/hduk6ziy.png)

#### 样例 2 解释

符合要求的线段如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/21ce6qj8.png)

------------

#### 数据规模与约定

**本题采用捆绑测试**。

| Subtask | 分值 | 数据规模与约定 |
| :----------: | :----------: | :----------: |
| $1$ | $20$ | $3 \le n \le 40$ |
| $2$ | $30$ | $3 \le n \le 200$ |
| $3$ | $60$ | 无附加约定 |

对于 $100\%$ 的数据，$3 \le n \le 10^3$，$-10^9 \le x_i, y_i \le 10^9$。

------------

#### 说明

**本题分值按 COCI 原题设置，满分 $110$**。

**题目译自 [COCI2020-2021](https://hsin.hr/coci/archive/2020_2021/) [CONTEST #6](https://hsin.hr/coci/archive/2020_2021/contest6_tasks.pdf) _T4 Geometrija_**。


---

---
title: "[JOISC 2021] フードコート (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P7560
tag: ['2021', 'JOI（日本）']
---
# [JOISC 2021] フードコート (Day1)
## 题目背景

本题数据保留一部分，请在 [此处](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day1/foodcourt-data.zip) 获取完整数据。
## 题目描述

有 $N$ 家书虫食品店，有 $M$ 个家庭来享受用书虫制作的美味食物。

因为食品店十分火爆，所以顾客需要排队，刚开始所有队列都是空的。

今天食品店又全部开张了，发生了 $Q$ 个事件：

- **加入事件**：编号位于区间 $[L,R]$ 内的所有食品店中，都有编号为 $C$ 的家庭加入队尾，每个满足要求的食品店队尾都加入了 $K$ 个人。
- **离开事件**：编号位于区间 $[L,R]$ 内的所有食品店中，如果队列有超过 $K$ 个人，那么队列的前 $K$ 个人离开队列，否则队列里的所有人离开队列。
- **白嫖事件**：如果编号为 $A$ 的食品店的队列中有大于等于 $B$ 个人，那么食品店就会赠送从队列开头开始数第 $B$ 个人一份秘制书虫，否则店员会吃掉书虫。

求每次 **白嫖事件** 是否有顾客被赠送了秘制书虫，如果有的话，求顾客所在的家庭。
## 输入格式

第一行三个整数 $N,M,Q$ 代表食品店个数，家庭个数和事件个数。

接下来 $Q$ 行，每行首先一个整数 $T$：

- $T=1$，接下来四个整数 $L,R,C,K$ 描述 **加入事件**。
- $T=2$，接下来三个整数 $L,R,K$ 描述 **离开事件**。
- $T=3$，接下来两个整数 $A,B$ 描述 **白嫖事件**。
## 输出格式

对于所有 **白嫖事件**，一行一个整数：

- 如果有顾客被送了秘制书虫，输出他所在的家庭。
- 如果店员吃掉了书虫，输出 $0$。
## 样例

### 样例输入 #1
```
3 5 7
1 2 3 5 2
1 1 2 2 4
3 2 3
2 1 3 3
3 1 2
1 2 3 4 2
3 3 2
```
### 样例输出 #1
```
2
0
4
```
### 样例输入 #2
```
3 4 7
1 1 2 1 1
1 1 3 4 1
2 2 3 1
2 1 3 1
1 1 2 2 1
3 1 1
3 3 2
```
### 样例输出 #2
```
4
0
```
### 样例输入 #3
```
183326 218318 22
1 106761 160918 151683 574906362
3 68709 1
1 29240 156379 22166 957318472
1 14054 181502 82845 97183925
2 112033 122908 587808357
2 57819 160939 215041262
3 36674 524274467
1 35854 69866 32334 322730299
1 1384 7230 115069 454256926
1 44192 158235 8750 84192710
3 54457 1077490708
2 10592 110384 979714505
2 44594 79244 311724477
3 160965 97183926
1 88748 101697 39148 373927458
3 41166 58039001
1 91501 137591 205480 958877326
2 77775 169655 135756956
1 12497 57047 60918 15666764
1 47839 51716 144688 732270998
3 114514 774994894
3 48645 169986425
```
### 样例输出 #3
```
0
22166
32334
0
82845
8750
60918
```
## 提示

#### 样例 1 解释

我们用 $Q_i(a_1,a_2,\cdots,a_k)$ 代表第 $i$ 个食品店的队列，$a_1$ 为队首，$a_k$ 为队尾，其中 $a_i=p$ 就代表第 $i$ 个位置的人来自第 $p$ 个家庭。特殊地，$Q_i()$ 就代表当前队列为空。

根据样例 1 的这几个事件：

- 第 $1$ 个 **加入事件**：

$$Q_1(),Q_2(5,5),Q_3(5,5)$$

- 第 $2$ 个 **加入事件**：

$$Q_1(2,2,2,2),Q_2(5,5,2,2,2,2),Q_3(5,5)$$

- 第 $3$ 个 **白嫖事件**，第 $2$ 个食品店的第 $3$ 个人（第 $2$ 个家庭）被送上秘制书虫。
- 第 $4$ 个 **离开事件**：

$$Q_1(2),Q_2(2,2,2),Q_3()$$

- 第 $5$ 个 **白嫖事件**，第 $1$ 个食品店不够 $2$ 个人，店员会吃掉书虫。
- 第 $6$ 个 **加入事件**：

$$Q_1(2),Q_2(2,2,2,4,4),Q_3(4,4)$$

- 第 $7$ 个 **白嫖事件**，第 $3$ 个食品店的第 $2$ 个人（第 $4$ 个家庭）被送上秘制书虫。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（2 pts）：$N,Q \le 2000$，满足性质 A。
- Subtask 2（5 pts）：$N,Q \le 2000$。
- Subtask 3（7 pts）：$N,Q \le 65000$，满足性质 B。
- Subtask 4（21 pts）：$M=1$。
- Subtask 5（15 pts）：$N,Q \le 65000$，满足性质 A。
- Subtask 6（13 pts）：$N,Q \le 65000$，满足性质 C。
- Subtask 7（26 pts）：$N,Q \le 65000$。
- Subtask 8（11 pts）：无特殊限制。

对于 $100\%$ 的数据：

- $1 \le N,M,Q \le 25 \times 10^4$。
- $T \in \{1,2,3\}$。
- 对于所有 **加入事件**，$1 \le L \le R \le N$，$1 \le C \le M$，$1 \le K \le 10^9$。
- 对于所有 **离开事件**，$1 \le L \le R \le N$，$1 \le K \le 10^9$。
- 对于所有 **白嫖事件**，$1 \le A \le N$，$1 \le B \le 10^{15}$。
- 至少有一个 **白嫖事件**。

有以下若干个性质：

- 性质 A：对于所有 **加入事件** 和 **离开事件**，有 $K=1$。
- 性质 B：对于所有 **加入事件**，有 $R-L \le  10$ 和 $K=1$。
- 性质 C：只有 **加入事件** 和 **白嫖事件**。

#### 说明

翻译自 [第２０回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [Day1 C フードコート (Food Court) 的英文版本](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day1/foodcourt-en.pdf)。


---

---
title: "[JOISC 2021] ビーバーの会合 2 (Day3)"
layout: "post"
diff: 省选/NOI-
pid: P7565
tag: ['2021', 'JOI（日本）']
---
# [JOISC 2021] ビーバーの会合 2 (Day3)
## 题目背景

原限制 25s & 4096MB，但看起来不需要
## 题目描述

给定一棵有 $N$ 个点的树，每一个点上有一个人，这些人要开秘密会议。

假设一次秘密会议有 $P$ 个人参加，这 $P$ 个人分别在第 $p_1,p_2,\cdots,p_P$ 个点上。如果点 $k$ 满足下面这个值最小（$d(a,b)$ 为点 $a$ 到点 $b$ 的距离，$k$ 不需要满足 $k \in \{p_1,p_2,\cdots,p_P\}$）：

$$\sum\limits_{i=1}^Pd(k,p_i)$$

那么就称第 $k$ 个点为可期待的，这场会议的期待值即为所有点中中可期待点的个数。

对于每个 $j \in [1,N]$，求当会议里有 $j$ 个人的时候，会议的期待值的最大值是多少。
## 输入格式

第一行一个整数 $N$ 代表树的点数。

接下来 $N-1$ 行每行两个整数 $A_i,B_i$ 代表一条边。
## 输出格式

$N$ 行每行一个整数，第 $j$ 行代表会议有 $j$ 个人时的答案。
## 样例

### 样例输入 #1
```
5
1 2
2 3
4 2
3 5
```
### 样例输出 #1
```
1
4
1
2
1
```
### 样例输入 #2
```
7
1 2
2 3
3 4
4 5
2 6
3 7
```
### 样例输出 #2
```
1
5
1
3
1
2
1
```
## 提示

#### 样例 1 解释

下文我们称 $\displaystyle\beta_k=\sum\limits_{i=1}^Pd(k,p_i)$。

拿样例 1 中的树举个例子，假设这一次会议参加者为第 $1$ 个点上的人和第 $3$ 个点上的人，则：

- $P=2$，$p_i=\{1,3\}$。
- $\beta_1=2$。
- $\beta_2=2$。
- $\beta_3=2$。
- $\beta_4=4$。
- $\beta_5=4$。

$\min\limits_{i=1}^5\{\beta_i\}=2$，满足要求的点为 $1,2,3$，该会议的期待值为 $3$。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（4 pts）：$N \le 16$。
- Subtask 2（16 pts）：$N \le 4000$。
- Subtask 3（80 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le N \le 2 \times 10^5$，$1 \le A_i,B_i \le N$。

#### 说明

翻译自 [第２０回日本情報オリンピック　春季トレーニング合宿](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [Day3 C ビーバーの会合 2 (Meetings 2) 的英文版本](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day3/meetings2-en.pdf)。


---

---
title: "「MCOI-05」粘液"
layout: "post"
diff: 省选/NOI-
pid: P7569
tag: ['Special Judge', '洛谷月赛']
---
# 「MCOI-05」粘液
## 题目背景

2077 年 7 月 7 日，MineCraft 20.7.7 发布了。这次更新允许了玩家将红石电路刻进一块电路板中进行运算。

`namespace_std` 作为一只程序猿兼 MC 玩家，他想在新的版本用电路板建造一台简易的粘液块盾构机。

然而，`namespace_std` 由于太久没玩 MC 了，建错了 TNT 复制装置，被炸上了外太空。所以搭建这个粘液块盾构机的任务就交给书虫了。

书虫用他附有耐久 X 的肝写出了这个盾构机的程序。然而，事情并没有这么简单 ...
## 题目描述

书虫有一个 $1 \times 1$ 体积的盾构机，和一块 $n \times m$ 个格子的地块，书虫打算用盾构机将这块地块推平。形式化地说，书虫需要让这个盾构机经过每一个格子 **恰好一次**。

这看上去很简单。然而，这个盾构机的程序的实现却有一些故障。当盾构机向同一个方向 **连续** 移动 **达到** $k$ 步时，盾构机就会卡住并不断地向同一个地方投放 TNT。

注意：最开始摆放盾构机**不视为移动**。换言之，盾构机应当移动 $n \times m - 1$ 次。

书虫并不想像可怜的 `namespace_std` 一样被炸上天，因此书虫希望找到一种安排盾构机路线的方案，使得盾构机 **不会** 被卡住。
## 输入格式

输入一行三个整数 $n,m,k$，分别表示地块的长宽，以及盾构机程序中的 $k$ 值。
## 输出格式

如果有合法的方案，输出三行：

- 第一行输出一个字符串 `YES`；
- 第二行输出一个长为 $n \times m - 1$ 的只包含 `L`、`R`、`D`、`U` 的字符串，表示每一步移动的方向；
- 第三行输出两个整数 $x,y$，表示书虫设计的路线起点为 $(x,y)$，即第 $x$ 行第 $y$ 列。当有多种可能的答案的时候，书虫可以输出 **任意一种**。

否则，只需要输出一行 `NO`。

请注意输出量可能较大，**请使用较快的输出方式**。

## 样例

### 样例输入 #1
```
3 3 2

```
### 样例输出 #1
```
NO

```
### 样例输入 #2
```
3 3 3

```
### 样例输出 #2
```
YES
RDLDRRUU
1 1
```
### 样例输入 #3
```
6 4 4

```
### 样例输出 #3
```
YES
RRRDLLLDRRRDLLLDRRRDLLL
1 1

```
### 样例输入 #4
```
1 1 2000
```
### 样例输出 #4
```
YES

1 1
```
## 提示

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 0（1 pts）：样例，您可以通过提交结果得知您的答案是否通过了 `Special Judge`。
- Subtask 1（9 pts）：$n,m,k \leq 3$。
- Subtask 2（15 pts）：$n,m,k \leq 10$。
- Subtask 3（5 pts）：$k \geq n$。
- Subtask 4（15 pts）：$n \leq 5$。
- Subtask 5（20 pts）：$k \geq 5$。
- Subtask 6（10 pts）：保证存在合法解。
- Subtask 7（25 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,m,k \le 2000$。


---

---
title: "「RdOI R2」因数和(sum)"
layout: "post"
diff: 省选/NOI-
pid: P7580
tag: ['2021', 'O2优化']
---
# 「RdOI R2」因数和(sum)
## 题目背景

monsters 喜欢因数，所以他要出一道关于因数的题。
## 题目描述

众所周知，$i$ 的标准分解形式为：$\prod\limits_{j=1}^{k_i}p_{i,j}^{c_{i,j}}$。

给定一个序列 $a$，长度为 $n$。

定义 $f(x)=\sum\limits_{d|x}\left({a_{\frac{x}{d}}\times\prod\limits_{i=1}^{k_d}{C_{c_{d,i}+m}^{m}}}\right)$，现在需要你求出 $f(1),f(2),f(3),\cdots ,f(n)$，其中 $m$ 是给定常数。

由于 monsters 不喜欢太大的数，他需要你输出答案模 $998244353$ 的值。

另外，为了避免过大的输入输出量，本题使用随机数生成数据，并且只需要你输出所有答案的异或和。

如果你不知道 $C$ 是什么，$C_n^m=\dfrac{n!}{m!(n-m)!}$，其中 $!$ 代表阶乘。
## 输入格式

输入共有一行。

第一行，三个非负整数 $n,m,seed$。

你需要在程序中调用 $n$ 次数据生成器（```randomdigit```）来得到 $a$。
## 输出格式

输出共有一行一个整数，为所有 $f(x)$ 的异或和。
## 样例

### 样例输入 #1
```
3 0 12345678
```
### 样例输出 #1
```
175092810
```
### 样例输入 #2
```
114514 100000 1919810
```
### 样例输出 #2
```
212218651

```
### 样例输入 #3
```
9919810 2 12121121
```
### 样例输出 #3
```
204065242
```
## 提示

**数据生成器**

C/C++:
```cpp
#define uint unsigned int
uint seed;
inline uint randomdigit(){
	seed^=seed<<13;
	seed^=seed>>17;
	seed^=seed<<5;
	return seed;
}
```
pascal:
```pascal
var seed:dword;
function randomdigit:dword;
begin
	seed:=seed xor(seed shl 13);
	seed:=seed xor(seed shr 17);
	seed:=seed xor(seed shl 5);
	randomdigit:=seed;
end;
```

python3:
```python
seed = 0 # please input seed
mod = 1 << 32
def randomdigit():
    global seed
    seed ^= (seed << 13) % mod
    seed ^= (seed >> 17) % mod
    seed ^= (seed << 5) % mod
    return seed
```

---

**样例解释**

序列 $a$ 为 $506005380,3857352168,531380003$。

$f(1),f(2),f(3)$ 模 $998244353$ 的值分别为 $506005380,370380136,39141030$。

---

**数据范围**

对于 $100\%$ 的数据，$0\le m\le 10^5,1\le n\le 10^7,0\le a_1,a_2,\cdots,a_n,seed<2^{32}$。

- Subtask $1$（$30\%$ 的数据）：$n\le 10^6,m\le 10^5$。

在此 Subtask 中：

有 $10\%$ 的数据，满足 $m=0$。

另有 $10\%$ 的数据，满足 $n\le 100$。
- Subtask $2$（剩下 $70\%$ 的数据）：$n\le 10^7,m\le 3$。

**提示**

请注意空间限制和常数因子对程序运行效率的影响


---

---
title: "「EZEC-8」游戏蛇"
layout: "post"
diff: 省选/NOI-
pid: P7596
tag: ['O2优化']
---
# 「EZEC-8」游戏蛇
## 题目描述

小 A 和小 B 是两条蛇，他们正在一棵特殊的树上做游戏。

这棵树的结构如下：首先有一条长度为 $n$ 的链，称为“主链”。主链由 $1$ 至 $n$ 这 $n$ 个节点构成。在主链上，编号相邻的点有边相连，否则则没有。

主链上的每一个点都挂着一条链，称为“副链”。主链上的第 $i$ 个点挂的副链长度（链上的点数）为 $x_i$。

小 A 和小 B 初始时都在主链上，具体而言，小 A 的**蛇尾**在点 $a$，**蛇头**在点 $b$，小 B 的**蛇头**在点 $c$，**蛇尾**在点 $d$。满足 $1\le a<b<c<d\le n$。

他们的游戏规则如下：
- 小 A 和小 B 轮流移动，小 A 先手。
- 每条蛇移动时，他会尝试整体向某一方向移动一个节点，**但不能向原来蛇尾方向移动，也就是蛇不能倒退**。需满足移动后蛇头不得与另外一条蛇的任意部分重合。
- 当一条蛇无法移动时，游戏结束，对手获胜。

现在有 $q$ 次询问，每次询问给定 $a,b,c,d$，请求出当两条蛇都采取最优策略时，哪一条蛇会获胜。
## 输入格式

第一行两个正整数 $n,q$。

第二行 $n$ 个正整数，表示 $x_i$。

接下来 $q$ 行，每行四个正整数表示此次询问的 $a,b,c,d$。
## 输出格式

输出共 $q$ 行。

对于每组询问，输出 `A` 或 `B`，表示最终能获胜的蛇。
## 样例

### 样例输入 #1
```
10 10
1 10 6 2 2 5 10 8 9 5
1 3 5 7
2 3 5 6
3 6 9 10
1 4 5 10
1 2 4 7
1 2 4 9
3 5 7 8
4 7 8 9
2 3 4 8
1 5 6 7
```
### 样例输出 #1
```
A
A
A
B
A
A
B
A
A
B
```
## 提示

**本题采用捆绑测试。**

-  Subtask 1（10 points）：$n,q \le500$。
-  Subtask 2（10 points）：$n\le10^5$，$q\le500$。
-  Subtask 3（5 points）：所有 $x_i$ 都相等。
-  Subtask 4（10 points）：所有询问中小 A 和小 B 的长度总和不超过 $5\times10^7$。
-  Subtask 5（15 points）：$x_i$ 在 $[1,10^9]$ 内随机生成。
-  Subtask 6（20 points）：$n\le5\times10^3$。
-  Subtask 7（30 points）：无特殊限制。

对于 $100\%$ 的数据，$1\le n,q\le5\times10^5$，$1\le x_i\le10^9$，$1\le a<b<c<d\le n$。

小 A 的长度定义为 $b-a+1$，小 B 的长度定义为 $d-c+1$。


---

---
title: "「EZEC-8」猜树 加强版"
layout: "post"
diff: 省选/NOI-
pid: P7597
tag: ['交互题', 'Special Judge', 'O2优化']
---
# 「EZEC-8」猜树 加强版
## 题目背景

这是一道交互题。
## 题目描述

有一棵以 $1$ 为根的 $n$ 个点的有根树，您需要通过若干次询问得到这棵树的结构。

您可以使用两种询问：

1. `? 1 u v` 通过这种询问，您可以获得 $u$ 和 $v$ 之间的距离。
2. `? 2 u` 通过这种询问，您可以获得 $u$ 子树的大小和 $u$ 子树中的所有节点。

请通过使交互库输出不超过 $40000$ 个数，得到这棵树的结构。

### 交互方式

输入树的大小 $n$ 以开始交互。

交互过程中，您可以进行题目描述中的两种询问。

对于第一种询问，交互库将会返回一个非负整数，表示 $u$ 节点和 $v$ 节点间的距离。

对于第二种询问，交互库将会先返回一个正整数 $num$，表示 $u$ 子树的大小。接下来会在同一行中返回 $num$ 个正整数，表示 $u$ 子树中的所有节点（节点顺序会被打乱）。

在您确定答案后，请以 `! fa[2] fa[3] ... fa[n]` 的形式输出一行，停止交互。其中 $fa[i]$ 表示这棵树中 $i$ 号节点的父节点。

在您输出一行后，请清空缓冲区：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其它语言请自行查阅文档。
## 输入格式

见「交互方式」。
## 输出格式

见「交互方式」。
## 样例

### 样例输入 #1
```
5

1

5 1 5 2 4 3

3 4 2 5

1 3
```
### 样例输出 #1
```

? 1 1 2

? 2 1

? 2 2

? 2 3

! 1 1 2 2
```
## 提示

对于 $100\%$ 的数据：$2 \leq n \leq 5000$，$1\le u,v\le n$。


---

---
title: "[COCI 2012/2013 #5] MNOGOMET"
layout: "post"
diff: 省选/NOI-
pid: P7648
tag: ['2012', 'COCI（克罗地亚）']
---
# [COCI 2012/2013 #5] MNOGOMET
## 题目描述

人们正在踢足球，分成两个队。每个球员都穿着队服，上面印着一个在队中独一无二的 $1$ 到 $N$ 间正整数，包括 $1$ 和 $N$。

对于每个玩家，我们知道他的精准度，知道他能把球传给的队友（集合 $F$ ），也知道能抢断他的对手（集合 $E$ ）。

当一名球员恰好接得一球之后的一秒后有以下情况中的一种会发生:

- 球员将球传给随机一名队友

- 随机一位对手将球夺过

- 球员试图向球门射门

如果球员试图射门，得分的概率等于他的精准度。无论射门成功与否，将球判给对方的 $1$ 号球员。

不同事件的可能性为比例 $|F|:|E|:1$，仅依赖于当前持球的玩家（ $|S|$ 代表集合 $S$ 的大小）。

“随机”一词指的是集合 $F$（或 $E$ ）中的所有玩家均有相同的概率从目前持球的球员那里拿到传的球。

不需计算传球的时间。

比赛以队伍一的球员 $1$ 控球开始，当一个球队进了 $R$ 个球，或者 $T$ 秒过去了，比赛结束（以两者中先发生的时间为准）。对于每一个可能的进球，计算出比赛以它结束的概率。
## 输入格式

第一行包含三个正整数 $N,R,T$，分别表示每个队伍中球员的人数，赢得比赛需要的进球数和比赛的时长。

接下来的 $N$ 行，描述队伍一的球员的信息；再下来的 $N$ 行，描述队伍二的球员的信息。

对于每一个球员的信息，一个实数 $p$，表示此球员的精准度；两个正整数 $N_f,N_e$，分别表示此球员的队友数和敌人数；接下来 $N_f$ 个数，为此球员的队友的编号；接下来 $N_e$ 个数，为此球员的敌人的编号。

注意：此球员的队友编号中不会包含此球员的编号。
## 输出格式

共 $R\times (N+2)$ 行，每行一个实数，表示比赛以此进球结束的概率。

先按照时间顺序输出队伍一的进球，再按照时间顺序输出第二队的。

输出的答案与标准答案相差 $\le 0.000001$ 即视为正确。
## 样例

### 样例输入 #1
```
1 1 2
0.5 0 1 1
0.5 0 1 1
```
### 样例输出 #1
```
0.56250
0.18750
0.25000
```
### 样例输入 #2
```
2 2 5
0.0 1 2 2 1 2
1.0 0 0
0.5 1 0 2
0.5 1 0 1
```
### 样例输出 #2
```
0.2578125
0.2812500
0.0703125
0.1718750
0.1640625
0.0234375
0.0156250
0.0156250
```
## 提示

**【样例解释#1】**

比赛只持续 $2$ 次移动或直到某人得分。由于 $N=1$，比赛中只有两名选手，两个选手的射门精确度都是 $0.5$，也就是说每个人的精确度都是 $50\%$。

让我们将灰色玩家标记为 $A$，将白色玩家标记为 $B$。在这些假设下，只有 $6$ 个可能的情况。下表分别描述了这些情况和对应的概率：

| 概率 | 描述 | 比分 |
| :----------: | :----------: | :----------: |
| $0.25$ | $A$ 射门并得分 | $1:0$ |
| $0.25\times 0.25$ | $A$ 射门但未得分，$B$ 射门并得分 | $0:1$ |
| $0.25\times 0.25$ | $A$ 射门但未得分，$B$ 射门但并未得分 | $0:0$ |
| $0.50\times 0.25$ | 球被 $B$ 从 $A$ 那里抢走，$B$ 射门并得分 | $0:1$ |
| $0.50\times 0.50$ | 球被 $B$ 从 $A$ 那里抢走，球被 $A$ 从 $B$ 那里抢走 | $0:0$ |
| $0.50\times 0.25$ | 球被 $B$ 从 $A$ 那里抢走，$B$ 射门但并未得分 | $0:1$ |

通过把这些概率加在一起，我们可以得到答案：

| 比分 | 概率相加 | 总和 |
| :----------: | :----------: | :----------: |
| $0:0$ | $0.25 \times 0.25 + 0.5 \times 0.5 + 0.5 \times 0.25$ | $0.5625$ |
| $0:1$ | $0.25 \times 0.25 + 0.5 \times 0.25$ | $0.1875$ |
| $1:0$ | $0.25$ | $0.25$ |



**【数据范围】**

对于 $100\%$ 的数据，$1\le N\le 100$，$1\le R\le 10$，$1\le T\le 500$，$0\le p\le 1$，$0\le N_f\le N-1$，$0\le N_e\le N$。


------------

**【说明】**

本题 spj 用于判断答案精确度。

本题分值按 COCI 原题设置，满分 $160$。

题目译自 [COCI2012_2013](https://hsin.hr/coci/archive/2012_2013/) [CONTEST #5](https://hsin.hr/coci/archive/2012_2013/contest5_tasks.pdf) _**T6 MNOGOMET**_。


---

---
title: "[JOI2018] Commuter Pass"
layout: "post"
diff: 省选/NOI-
pid: P7669
tag: ['2018', 'JOI（日本）']
---
# [JOI2018] Commuter Pass
## 题目描述

JOI 君住在一个有 $N$ 个车站的城市。车站编号为 $1$ 至$N$。编号为 $1$ 至 $M$ 的有 $M$ 条铁路。铁路 $i$（$1 \leq i \leq M$）双向连接 $A_i$ 站和 $B_i$ 站，票价为 $C_i$ 日元。  
JOI 君住在 $S$ 站附近，去 $T$ 站附近的 IOI 高中。他打算买一张连接这两个站的通勤票。当他购买通勤票时，他需要选择一条成本最低的 $S$ 站和 $T$ 站之间的路线。使用此通勤票，他可以沿任何方向乘坐所选路线中包含的任何铁路，而无需额外费用。  
JOI 君经常去 $U$ 站和 $V$ 站附近的书店。因此，他想买一张通勤票，这样从 $U$ 站到 $V$ 站的费用可以降到最低。  
当他从 $U$ 站移动到 $V$ 站时，他首先选择了一条从 $U$ 站到 $V$ 站的路线，那么他需要支付的车费是：  
- $0$ 日元：如果铁路 $i$ 包含在他购买的通勤票时选择的路线中，或者，  
- $C_i$ 日元：如果铁路 $i$ 不包含在他购买通勤票时选择的路线中。  

上述票价的总和就是从 $U$ 站到 $V$ 站的成本。  
他想知道如果他在购买通勤票时选择合适的路线，从 $U$ 站到 $V$ 站的最低成本。
## 输入格式

第一行包含两个空格分隔的整数 $N$，$M$。这意味着 JOI 君居住的城市有 $N$ 个车站和 $M$ 条铁路。第二行包含两个空格分隔的整数 $S$，$T$。这意味着 JOI 君计划购买从 $S$ 站到 $T$ 站的通勤票。第三行包含两个空格分隔的整数 $U$，$V$。这意味着 JOI 君想要最小化从站 $U$ 到站 $V$ 的成本。接下来的 $M$ 行的第 $i$ 行包含三个空格分隔的整数 $A_i$，$B_i$，$C_i$。铁路 $i$ 双向连接 $A_i$ 站和 $B_i$ 站，票价为 $C_i$ 日元。
## 输出格式

如果他在购买通勤票时选择了适当的路线，则输出应包含一个整数为从站 $U$ 到站 $V$ 的最小成本。
## 样例

### 样例输入 #1
```
6 6
1 6
1 4
1 2 1
2 3 1
3 5 1
2 4 3
4 5 2
5 6 1
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
6 5
1 2
3 6
1 2 1000000000 
2 3 1000000000
3 4 1000000000
4 5 1000000000
5 6 1000000000
```
### 样例输出 #2
```
3000000000
```
### 样例输入 #3
```
8 8
5 7
6 8
1 2 2
2 3 3
3 4 4
1 4 1
1 5 5
2 6 6
3 7 7
4 8 8
```
### 样例输出 #3
```
15
```
### 样例输入 #4
```
5 5
1 5
2 3
1 2 1
2 3 10
2 4 10
3 5 10
4 5 10
```
### 样例输出 #4
```
0
```
### 样例输入 #5
```
10 15
6 8
7 9
2 7 12
8 10 17
1 3 1
3 8 14
5 7 15
2 3 7
1 10 14
3 6 12
1 5 10
8 9 1
2 9 7
1 4 1  
1 8 1
2 4 7
5 6 16
```
### 样例输出 #5
```
19
```
## 提示

#### 数据规模与约定  
对于 $100 \%$ 的数据，  
$2 \leq N \leq 10^5$，$1 \leq M \leq 2×10^5$，$1 \leq S \leq N$，$1 \leq T \leq N$，$1 \leq U \leq N$，$1 \leq V \leq N$，$S {=}\mathllap{/\,} T$，$U {=}\mathllap{/\,} V$，$ S{=}\mathllap{/\,} U$ 或 $T {=}\mathllap{/\,} V$，$1 \leq A_i \leq B_i \leq N$（$1 \leq i \leq M$）。对于每 $1 \leq i < j \leq M$，$A_i {=}\mathllap{/\,} A_j$ 或 $B_i {=}\mathllap{/\,} B_j$，$1 \leq C_i \leq 10^9$（$1 \leq i \leq M$）。JOI 君可以从任何车站移动到任何其他车站乘坐铁路。  
- Subtask $1$（$16$ points）：$S=U$。  
- Subtask $2$（$15$ points）：从 $S$ 站到 $T$ 站有一条成本最低的唯一路线。  
- Subtask $3$（$24$ points）：$N \leq 300$。  
- Subtask $4$（$45$ points）：没有额外的限制。  
#### 样例说明  
**对于样例 $1$**：JOI 君在购买通勤票时只能选择一条路线：$1$ 号站 → $2$ 号站 →$3$ 号站 → $5$ 号站 → $6$ 号站。为了尽量减少从 $1$ 号站到 $4$ 号站的成本 ，他选择以下路线：$1$ 站 → $2$ 站 → $3$ 站 → $5$ 站 → $4$ 站。选择这条路线时，他需要支付的车费为。  
- $2$ 日元用于车站 $4$ 和车站 $5$ 的铁路 $5$，以及，  
- $0$ 日元：其他铁路。  
  
**对于样例 $2$**：JOI 君从 $3$ 号站移动到 $6$ 号站时，不使用通勤票。  
#### 题目说明：  
来源于 The 17th Japanese Olympiad in Informatics (JOI 2017/2018) Final Round 的 [T4：Commuter Pass](https://www.ioi-jp.org/joi/2017/2018-ho/2018-ho-t4-en.pdf)。  
由 @[求学的企鹅](/user/271784) 翻译整理。  
#### Hack 说明  
[@gaojunqing](https://www.luogu.com.cn/user/536005) 于 2021 年 11 月 6 日向供题人提供一组 hack 数据，经过多次检验后于 2021 年 11 月 7 日加入到本题测试数据中。  
出于对该 JOI 原题的尊重与体验考虑，一律所加入的 hack 数据均不做分值改变，即满分依然为 100 分，新增 hack 数据单独放置在 Subtask #5 ，且分数为 0 分。即如通过原所有测试数据而未通过 hack 数据，将获得 100 分但不能 AC，当且仅当通过全部测试数据方可 AC。


---

---
title: "[JOI2018] Snake Escaping"
layout: "post"
diff: 省选/NOI-
pid: P7670
tag: ['2018', 'JOI（日本）']
---
# [JOI2018] Snake Escaping
## 题目描述

JOI 实验室有 $2^L$ 条毒蛇。蛇的编号为  $0,1,\cdots,2^L−1$。每条蛇从头到尾分为  $L$ 个部分。每个部分的颜色是蓝色或红色。 对于毒蛇 $i$，令 $i = \sum_{k=1}^{L} c_k2^{L-k}$（$0 \leq c_k \leq 1$）为 $i$ 的二进制表达式。那么，  
- 如果 $c_k=0$，毒蛇 $i$ 从头开始的第 $k$ 部分的颜色是蓝色，  
- 如果 $c_k=1$，毒蛇 $i$ 从头开始的第 $k$ 部分的颜色是红色。  

每条毒蛇都有一个 $0$ 到 $9$ 之间的整数，包括 $0$ 和 $9$，为毒性。给出一个由 $\texttt{0,1,2,3,4,5,6,7,8,9}$ 组成的长度为  $2^L$ 的字符串 $S$。第 $i$ 个字符（$1 \leq i \leq 2^L$）是毒蛇 $i−1$ 的毒性。由于毒蛇行动迅速，所以经常从 JOI 实验室逃走。住在实验室附近的人向 JOI 实验室投诉，他们看到毒蛇从实验室逃逸。您将收到 $Q$ 天的投诉清单。 第 $d$ 天的投诉（$1 \leq d \leq Q$）是一个长度为 $L$ 的字符串 $T_d$，由 $\texttt{0,1,?}$ 组成。  
- 如果 $T_d$ 的第 $j$ 个字符（$1 \leq j ≤ L$）为 $\texttt{0}$，这意味着第 $d$ 天从实验室逃出的每条毒蛇的第 $j$ 个部分是蓝色的，  
- 如果 $T_d$ 的第 $j$ 个字符（$1 \leq j \leq L$）为 $\texttt{1}$，这意味着第 $d$ 天从实验室逃出的每条毒蛇的第 $j$ 部分是红色的，并且  
- 如果 $T_d$ 的第 $j$ 个字符（$1 \leq j \leq L$）为 $\texttt{?}$，这意味着人们没有提供关于第 $d$ 天从实验室逃逸的毒蛇的第 $j$ 部分的信息。  

所有的投诉都是准确的信息。所有从实验室逃逸的毒蛇都在同一天被 JOI 实验室的工作人员收留。可能发生同一条蛇在不同的日子逃脱。  
JOI 实验室执行主任 K 教授为了估计毒蛇逃逸的风险，想知道可能逃出实验室的毒蛇的毒性总和。 你的任务是编写一个程序，根据 $Q$ 天的投诉列表，计算每天可能从实验室逃逸的蛇的毒性总和。  
现给定描述毒蛇毒性的字符串 $S$ 和 $Q$ 天的投诉列表，请编写一个程序来计算每天可能从实验室逃逸的蛇的毒性总和。  
请注意，此任务的内存限制很小。
## 输入格式

第一行包含两个空格分隔的整数 $L$，$Q$，分别是每条毒蛇的部位数和投诉天数。第二行包含长度为 $2^L$ 的字符串 $S$，描述了毒蛇的毒性。后面 $Q$ 行的第 $d$ 行包含一个长度为 $L$ 的字符串 $T_d$，为第 $d$ 天的投诉。
## 输出格式

共 $Q$ 行，第 $d$ 行应包含一个整数，即第 $d$ 天可能从实验室逃逸的蛇的毒性总和。
## 样例

### 样例输入 #1
```
3 5
12345678
000
0??
1?0
?11
???
```
### 样例输出 #1
```
1
10
12
12
36
```
### 样例输入 #2
```
4 8
3141592653589793
0101
?01?
??1?
?0??
1?00
01?1
??10
????
```
### 样例输出 #2
```
9
18
38
30
14
15
20
80
```
## 提示

#### 数据规模与约定  
对于 $100 \%$ 的数据，$1 \leq L \leq 20$，$1 \leq Q \leq 10^6$，$S$ 是长度为 $2^L$ 的字符串，字符串 $S$ 由 $\texttt{0,1,2,3,4,5,6,7,8,9}$ 组成，$T_d$ 是长度为 $L$（$1 \leq d \leq Q$）的字符串，字符串 $T_d$ 由 $\texttt{0,1,?}$（$1 \leq d \leq Q$）组成。  
- Subtask $1$（$5$ points）：$L \leq 10$，$Q \leq 1000$。  
- Subtask $2$（$7$ points）：$L \leq 10$。  
- Subtask $3$（$10$ points）：$L \leq 13$。  
- Subtask $4$（$53$ points）：$Q \leq 5000$。  
- Subtask $5$（$25$ points）：没有额外的限制。  

#### 样例说明  
**对于样例 $1$**：$L=3$，共 $2^3=8$条毒蛇，它们中的每一条都分为 $3$ 个部分。 投诉时间为 $5$ 天。  
- 第一天，可能逃出实验室的毒蛇只有毒蛇 $0$。毒性总和为 $1$。  
- 第二天，可能从实验室逃逸的毒蛇是毒蛇 $0,1,2,3$。毒性总和为 $10$。  
- 第三天，可能从实验室逃逸的毒蛇是毒蛇  $4,6$。毒性总和为 $12$。  
- 第四天，可能从实验室逃逸的毒蛇是毒蛇 $3,7$。毒性总和是 $12$。  
- 第五天，可能从实验室逃逸的毒蛇是毒蛇 $0,1,2,3,4,5,6,7$。毒性总和为 $36$。  
#### 题目说明：  
来源于 The 17th Japanese Olympiad in Informatics (JOI 2017/2018) Final Round 的 [T5：Snake Escaping](https://www.ioi-jp.org/joi/2017/2018-ho/2018-ho-t5-en.pdf)。  
由 @[求学的企鹅](/user/271784) 翻译整理。


---

---
title: "「MCOI-09」Dream and Strings REMATCH"
layout: "post"
diff: 省选/NOI-
pid: P7703
tag: ['Special Judge', 'O2优化']
---
# 「MCOI-09」Dream and Strings REMATCH
## 题目描述

给定 $N$ 以及非负整数序列 $a_1,a_2,\dots,a_N$。

请找到 **任何** 一个整数序列 $b_1,b_2,\dots,b_N$ 满足 $\sum |b_i|\neq 0$，$|b_i|\le 1$，和 $\sum a_ib_i=0$。
## 输入格式

第一行一个正整数 $T$。接下来 $T$ 组数据。

每一组数据两行，第一行一个正整数 $N$，接下来一行 $N$ 个正整数 $a_1,a_2,\dots,a_N$。
## 输出格式

输出 $T$ 行，第 $T$ 行输出对应组数据的 $b$ 序列。

如果无解，输出 $-1$。
## 样例

### 样例输入 #1
```
2
5
1 1 2 60 60
4
100 101 100 102
```
### 样例输出 #1
```
1 1 -1 1 -1
1 0 -1 0
```
## 提示

本样例不符合题意 $5000\le N$ 的限制。

**本题采用捆绑测试。**

 - Subtask 1（50 pts）：$10^5\le N$
 - Subtask 2（50 pts）：无特殊限制。

对于 $100\%$ 的数据：$1\le T\le 20$，$5000\le N\le\frac{10^5}{T}$，$0\le a_i\le 10^{18}$。**数据保证随机生成。**


---

---
title: "「Wdsr-2.7」百花齐放的太阳花田"
layout: "post"
diff: 省选/NOI-
pid: P7707
tag: ['O2优化']
---
# 「Wdsr-2.7」百花齐放的太阳花田
## 题目背景

> 春天到来，花儿盛开……只是这次开花比起以往多上许多，甚至所有季节的花都开了。

$$\kern{1pt}\tag*{\small\text{——东方花映冢}}$$

今年的太阳花田，因为各种各样花朵的开放而显得格外热闹。尽管这是一场有关于花的异变，但是太阳花田的主人风见幽香却格外享受由鲜花带来的五彩缤纷的花田——毕竟，向来冷清的花田因为各种妖精的活跃而变得热闹了起来。

幽香非常喜欢这些花朵。每朵花都有它自己的种类，也代表了一种性格。比如向日葵，比如蒲公英，比如天人菊……

奇怪的是，有些花朵可能会属于同一种类，但由于相关因素（比如年龄、营养等），使得每种花都有一个高度。

幽香非常感兴趣，因为这些花朵高高低低形形色色，使得太阳花田呈现出了别样的景色。兴致之余，幽香选取了一些花朵，希望你帮助她解决一个问题。


## 题目描述

一开始，幽香选择了太阳花田当中的 $n$ 朵花朵。每朵花有一个高度 $h_i$ ，以及它属于的类别 $t_i$ 。它们排成了一列，并且被标号为 $1,2,3\cdots n$ 。幽香有 $m$ 次操作，分为两种：

- $\colorbox{f0f0f0}{\verb!1 l r x!}$ ：考虑区间 $[l,r]$ 内的所有花朵。我们取出其中所有高度不超过 $x$ 的花朵（即 $h_i\le x$ 的花朵），**依次排列**（即不改变花朵在原序列中的顺序），可以根据它们的种类划分为若干段（比如，$\{\underline{1,}\ \underline{2,2},\underline{1,1},\underline {3,}\ \underline{4,4,4}\}$ 就能分为 $5$ 段）。幽香希望你告诉她一共有多少段。

- $\colorbox{f0f0f0}{\verb!2 x y!}$ ：幽香挑选了一朵高度为 $x$ ，种类为 $y$ 的花朵，拼接在末尾。

**强制在线。**
## 输入格式

- 第一行三个整数 $n,m,k$ 。$n,m$ 含义如上，而 $k$ 为**强制在线参数**。

- 接下来两行，第一行是 $n$ 个整数，表示 $\{h_1,h_2\cdots h_n\}$ ；第三行 $n$ 个整数，表示序列 $t_1,t_2\cdots t_n\}$ 。含义如题所示。

- 接下来 $m$ 行，每行首先一个整数 $op$ ，表示本次操作的种类。

  - 如果 $op = 1$，接下来三个整数 $l',r',x'$，描述一次查询。

  - 如果 $op = 2$，接下来两个整数 $x',y'$，表示一次修改。

- 在所有操作中，真正的 $l,r,x,y$ 都是输入的 $l',r',x',y'$ 异或上 $k \times last$ 后的值。其中， $last$ 表示最后一次查询的答案，初始为 $0$。
## 输出格式

- 共有若干行。对于每个操作 $1$ ，每行输出一个整数，表示答案。
## 样例

### 样例输入 #1
```
10 10 0
6 8 5 9 6 10 2 4 8 9 
2 4 3 3 4 1 2 3 3 2 
2 2 8
1 1 4 4
2 1 6
2 10 2
1 7 9 7
2 10 8
2 8 4
2 3 10
1 5 16 5
1 4 14 7

```
### 样例输出 #1
```
0
2
5
5

```
### 样例输入 #2
```
10 20 0
2 19 13 20 7 19 17 8 15 12 
1 2 4 3 5 3 2 4 2 2 
2 9 3
2 17 3
1 1 9 15
1 1 12 3
2 15 5
1 6 13 6
2 7 1
2 20 3
2 12 1
2 10 1
1 5 9 4
1 1 7 15
2 12 4
1 12 12 14
2 7 5
1 3 18 6
1 7 7 1
2 8 5
1 6 8 10
1 14 18 4

```
### 样例输出 #2
```
5
1
0
0
3
0
0
0
1
0

```
## 提示

$n'$ 表示进行所有操作后的序列长度。

$$
\def{\arraystretch}{1.5}
\begin{array}{|c|c|c|c|}\hline
\bf{Subtask} & \bm{n',m} & \textsf{\textbf{特殊性质}} & \textsf{\textbf{分值}} \cr\hline
1 & 1\le n',m \le 10^3 & \text{无} & 10 \cr\hline
2 & 1\le n',m \le 3\times 10^5 & k=0 & 20\cr\hline
3 & 1\le n',m \le 3\times 10^5 & l=1 & 25\cr\hline
4 & 1\le n',m \le 10^5 & \text{无} & 15\cr\hline
5 & 1\le n',m \le 3\times 10^5 & \text{无} & 20\cr\hline
6 & \text{无特殊限制} & \text{时限 3s，空限 300MB} & 10\cr\hline
\end{array}$$

- 对于 $100\%$ 的数据：

   $1 \le n',m \le 5 \times 10 ^ 5$。
   
   $1 \le h_i,t_i,x,y \le 10^9$，$1 \le l \le r \le n'$。
   
   $1 \le op \le 2$，$0 \le k \le 10^3$。

提示：请注意常数优化。


---

---
title: "[NOI2021] 轻重边"
layout: "post"
diff: 省选/NOI-
pid: P7735
tag: ['2021', 'NOI', 'O2优化']
---
# [NOI2021] 轻重边
## 题目描述

小 W 有一棵 $n$ 个结点的树，树上的每一条边可能是轻边或者重边。接下来你需要对树进行 $m$ 次操作，在所有操作开始前，树上所有边都是轻边。操作有以下两种：
1. 给定两个点 $a$ 和 $b$，首先对于 $a$ 到 $b$ 路径上的所有点 $x$（包含 $a$ 和 $b$），你要将与 $x$ 相连的所有边变为轻边。然后再将 $a$ 到 $b$ 路径上包含的所有边变为重边。
2. 给定两个点 $a$ 和 $b$，你需要计算当前 $a$ 到 $b$ 的路径上一共包含多少条重边。

## 输入格式

本题有多组数据，输入数据第一行一个正整数 $T$，表示数据组数。对于每组数据：

第一行包含两个整数 $n$ 和 $m$，其中 $n$ 表示结点数量，$m$ 表示操作数量。

接下来 $n - 1$ 行，每行包含两个整数 $u\ v$，表示树上的一条边。

接下来 $m$ 行，每行包含三个整数 ${\mathit{op}}_i\ a_i\ b_i$，描述一个操作，其中 ${\mathit{op}}_i = 1$ 表示第 $1$ 类操作，${\mathit{op}}_i = 2$ 表示第 $2$ 类操作。

数据保证 $a_i \neq b_i$。
## 输出格式

对于每一次第 $2$ 类操作，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
1
7 7
1 2
1 3
3 4
3 5
3 6
6 7
1 1 7
2 1 4
2 2 7
1 1 5
2 2 7
1 2 1
2 1 7
```
### 样例输出 #1
```
1
3
2
1
```
## 提示

**【样例解释 #1】**

第 $1$ 次操作后，重边有：$(1, 3)$，$(3, 6)$，$(6, 7)$。

第 $2$ 次操作，包含的重边有：$(1, 3)$。

第 $3$ 次操作，包含的重边有：$(1, 3)$，$(3, 6)$，$(6, 7)$。

第 $4$ 次操作，首先 $(1, 3)$，$(3, 6)$ 变为轻边，之后 $(1, 3)$，$(3, 5)$ 变为重边。

第 $5$ 次操作，包含的重边有：$(1, 3)$，$(6, 7)$。

第 $6$ 次操作，首先 $(1, 3)$ 变为轻边，之后 $(1, 2)$ 变为重边。

第 $7$ 次操作，包含的重边有：$(6, 7)$。

**【样例 #2】**

见附件 `edge/edge2.in` 与 `edge/edge2.ans`。

该样例约束与测试点 $3 \sim 6$ 一致。

**【样例 #3】**

见附件 `edge/edge3.in` 与 `edge/edge3.ans`。

该样例约束与测试点 $9 \sim 10$ 一致。

**【样例 #4】**

见附件 `edge/edge4.in` 与 `edge/edge4.ans`。

该样例约束与测试点 $11 \sim 14$ 一致。

**【样例 #5】**

见附件 `edge/edge5.in` 与 `edge/edge5.ans`。

该样例约束与测试点 $17 \sim 20$ 一致。

**【数据范围】**

对于所有测试数据：$T \le 3$，$1 \le n, m \le {10}^5$。

| 测试点编号 | $n, m \le $ | 特殊性质 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | 无 |
| $3 \sim 6$ | $5000$ | 无 |
| $7 \sim 8$ | ${10}^5$ | A，B |
| $9 \sim 10$ | ${10}^5$ | A |
| $11 \sim 14$ | ${10}^5$ | B |
| $15 \sim 16$ | $2\times {10}^4$ | 无 |
| $17 \sim 20$ | ${10}^5$ | 无 |

特殊性质 A：树的形态是一条链。

特殊性质 B：第 $2$ 类操作给出的 $a_i$ 和 $b_i$ 之间有边直接相连。


---

---
title: "[NOI2021] 路径交点"
layout: "post"
diff: 省选/NOI-
pid: P7736
tag: ['2021', 'NOI', 'O2优化']
---
# [NOI2021] 路径交点
## 题目描述

小 L 有一个有向图，图中的顶点可以分为 $k$ 层，第 $i$ 层有 $n_i$ 个顶点，第 $1$ 层与第 $k$ 层**顶点数相同**，即 $n_1 = n_k$，且对于第 $j$（$2 \leq j \leq k-1$）层，$n_1 \leq n_j \leq 2n_1$。对于第 $j$（$1 \leq j < k$）层的顶点，以它们为起点的边只会连向第 $j + 1$ 层的顶点。没有边连向第 $1$ 层的顶点，第 $k$ 层的顶点不会向其他顶点连边。

现在小 L 要从这个图中选出 $n_1$ 条路径，每条路径以第 $1$ 层顶点为起点，第 $k$ 层顶点为终点，并要求**图中的每个顶点至多出现在一条路径中**。更具体地，把每一层顶点按照 $1,2,\ldots,n_i$ 进行编号，则每条路径可以写为一个 $k$ 元组 $(p_1,p_2,\ldots,p_k)$，表示这条路径依次经过第 $j$ 层的 $p_j$（$1 \leq p_j \leq n_j$）号顶点，并且第 $j$（$1 \leq j < k$）层的 $p_j$ 号顶点有一条边连向第 $j+1$ 层的第 $p_{j+1}$ 号顶点。

小 L 把这些路径画在了纸上，发现它们会产生若干个交点。对于两条路径 $P,Q$，分别设它们在第 $j$ 层与第 $j+1$ 层之间的连边为 $(P_j,P_{j+1})$ 与 $(Q_j,Q_{j+1})$，若，

$$(P_j-Q_j)\times(P_{j+1}-Q_{j+1})<0$$

则称它们在第 $j$ 层后产生了一个交点。两条路径的交点数为它们在第 $1, 2,\ldots,k - 1$ 层后产生的交点总数。对于整个路径方案，它的交点数为**两两不同路径间交点数之和**。例如下图是一个 $3$ 条路径，共 $3$ 个交点的例子，其中红色点是交点。

![](https://cdn.luogu.com.cn/upload/image_hosting/pvr0iwkt.png)

小 L 现在想知道有偶数个交点的路径方案数比有奇数个交点的路径方案数多多少个。两个路径方案被视为相同的，当且仅当它们的 $n_1$ 条路径按第一层起点编号顺序写下的 $k$ 元组能对应相同。由于最后的结果可能很大，请你输出它对 $998244353$（一个大质数）取模后的值。
## 输入格式

本题有多组数据，输入数据第一行一个正整数 $T$ ，表示数据组数。对于每组数据：

第一行一个正整数 $k$，表示一共有 $k$ 层顶点。

第二行包含 $k$ 个整数 $n_1,n_2,\ldots,n_k$，依次表示每一层的顶点数量。保证 $n_1=n_k$，且 $n_1 \leq n_i \leq 2n_1$（$2 \leq i \leq k-1$）。

第三行包含 $k-1$ 个整数 $m_1,m_2,\ldots,m_{k-1}$，依次表示第 $j$ 层顶点到第 $j+1$ 层顶点的边数。保证 $m_j \leq n_j \times n_{j+1}$。

接下来有 $k-1$ 段输入。第 $j$（$1 \leq j < k$）段输入包含 $m_j$ 行，每一行两个整数 $u,v$，表示第 $j$ 层的 $u$ 号顶点有一条边连向第 $j+1$ 层的 $v$ 号顶点。

数据保证图中不会出现重边。
## 输出格式

输出共 $T$ 行，每行一个整数，表示该组数据的答案对 $998244353$ 取模后的值。
## 样例

### 样例输入 #1
```
1
3
2 3 2
4 4
1 1 
1 2
2 1
2 3
1 2
2 1
3 1
3 2
```
### 样例输出 #1
```
1
```
## 提示

**【样例解释 #1】**

偶数个交点的方案有 $2$ 个，奇数个交点的方案有 $1$ 个，所以答案为 $1$。

将下表中路径 $1$ 和路径 $2$ 的方案交换，将会得到相同的方案，例如路径 $1$ 为 $(2, 3, 1)$ 且路径 $2$ 为 $(1, 1, 2)$ 的方案与方案 $1$ 是相同的方案，所以不会被计入答案。

| 路径方案 | 路径 $1$  | 路径 $2$  | 交点总数 |
| :------: | :-------: | :-------: | :------: |
|   $1$    | $(1,1,2)$ | $(2,3,1)$ |   $1$    |
|   $2$    | $(1,2,1)$ | $(2,1,2)$ |   $2$    |
|   $3$    | $(1,2,1)$ | $(2,3,2)$ |   $0$    |

**【样例 #2】**

见附件 `xpath2.in` 与 `xpath2.ans`。

该样例约束与测试点 $7 \sim 8$ 一致。

**【样例 #3】**

见附件 `xpath3.in` 与 `xpath3.ans`。

该样例约束与测试点 $9 \sim 10$ 一致。

**【样例 #4】**

见附件 `xpath4.in` 与 `xpath4.ans`。

该样例约束与测试点 $14 \sim 15$ 一致。

**【数据范围】**

对于所有测试数据：$2 \leq k \leq 100$，$2 \leq n_1 \leq 100$，$1 \leq T \leq 5$。

每个测试点中，保证 $n_1 > 10$ 的数据只有 $1$ 组。

|  测试点编号  | $k=$  | $n_1 \leq$ | 特殊性质 |
| :----------: | :---: | :--------: | :------: |
|  $1 \sim 4$  |  $2$  |    $10$    |    无    |
|  $5 \sim 6$  | $10$  |    $10$    |   A，B    |
|  $7 \sim 8$  | $10$  |    $10$    |    A     |
| $9 \sim 10$  | $10$  |    $10$    |    无    |
| $11 \sim 13$ |  $2$  |   $100$    |    无    |
| $14 \sim 15$ | $100$ |   $100$    |   A，B    |
| $16 \sim 17$ | $100$ |   $100$    |    A     |
| $18 \sim 20$ | $100$ |   $100$    |    无    |

特殊性质 A：对于所有 $i$（$2 \leq i \leq k-1$）满足 $n_i = n_1$。

特殊性质 B：保证路径方案总数至多为 $1$。


---

---
title: "[NOI2021] 庆典"
layout: "post"
diff: 省选/NOI-
pid: P7737
tag: ['2021', 'NOI', 'O2优化']
---
# [NOI2021] 庆典
## 题目描述

C 国是一个繁荣昌盛的国家，它由 $n$ 座城市和 $m$ 条有向道路组成，城市从 $1$ 到 $n$ 编号。如果从 $x$ 号城市出发，经过若干条道路后能到达 $y$ 号城市，那么我们称 $x$ 号城市可到达 $y$ 号城市，记作 $x\Rightarrow y$。C 国的道路有一个特点：对于三座城市 $x$，$y$，$z$，若 $x\Rightarrow z$ 且 $y\Rightarrow z$，那么有 $x\Rightarrow y$ 或 $y\Rightarrow x$。

再过一个月就是 C 国成立的千年纪念日，所以 C 国的人民正在筹备盛大的游行庆典。目前 C 国得知接下来会有 $q$ 次游行计划，第 $i$ 次游行希望从城市 $s_i$ 出发，经过若干个城市后，在城市 $t_i$ 结束，且在游行过程中，**一个城市可以被经过多次**。为了增加游行的乐趣，每次游行还会**临时**修建出 $k$（$0 \le k \le 2$）条有向道路专门供本次游行使用，即其它游行计划不能通过本次游行修建的道路。

现在 C 国想知道，每次游行计划可能会**经过多少座城市**。

注意：临时修建出的道路**可以不满足 C 国道路原有的特点**。
## 输入格式

第一行包含四个整数 $n,m,q,k$，分别表示城市数、道路数、游行计划数以及每次游行临时修建的道路数。

接下来 $m$ 行，每行包含两个整数 $u,v$，表示一条有向道路 $u\rightarrow v$。

接下来 $q$ 行，每行前两个整数 $s_i,t_i$，表示每次游行的起点与终点；这行接下来有 $k$ 对整数 $a,b$，每对整数表示一条临时添加的有向道路 $a\rightarrow b$。

数据保证，将 C 国原有的有向道路视为无向道路后，所有城市可以互达。
## 输出格式

对于每次询问，输出一行一个整数表示答案。如果一次游行从起点出发无法到达终点，输出 $0$ 即可。
## 样例

### 样例输入 #1
```
5 6 4 1
1 2
1 3
1 4
2 5
4 5
5 4
1 4 5 1
2 3 5 3
1 2 5 2
3 4 5 1

```
### 样例输出 #1
```
4
4
4
0

```
## 提示

**【样例解释 #1】**

第 $1$ 次计划，起点为 $1$ 号点，终点为 $4$ 号点，临时修建道路为 $5\rightarrow1$，最终可能经过的城市编号为 $\{1,2,4,5\}$。

第 $2$ 次计划，起点为 $2$ 号点，终点为 $3$ 号点，临时修建道路为 $5\rightarrow3$，最终可能经过的城市编号为 $\{2,3,4,5\}$。

第 $3$ 次计划，起点为 $1$ 号点，终点为 $2$ 号点，临时修建道路为 $5\rightarrow2$，最终可能经过的城市编号为 $\{1,2,4,5\}$。

第 $4$ 次计划，起点为 $3$ 号点，终点为 $4$ 号点，临时修建道路为 $5\rightarrow1$，最终从 $3$ 号点出发无法到达 $4$ 号点。

**【样例 #2】**

见附件 `celebration/celebration2.in` 与 `celebration/celebration2.ans`。

该样例约束与测试点 $5 \sim 7$ 一致。

**【样例 #3】**

见附件 `celebration/celebration3.in` 与 `celebration/celebration3.ans`。

该样例约束与测试点 $10 \sim 11$ 一致。

**【样例 #4】**

见附件 `celebration/celebration4.in` 与 `celebration/celebration4.ans`。

该样例约束与测试点 $15 \sim 16$ 一致。

**【样例 #5】**

见附件 `celebration/celebration5.in` 与 `celebration/celebration5.ans`。

该样例约束与测试点 $20 \sim 25$ 一致。

**【数据范围】**

对于所有测试点，$1 \le n,q \le 3 \times {10}^5$，$n - 1 \le m \le 6 \times {10}^5$，$0 \le k \le 2$。

| 测试点编号 | $n, q \le$ | $k$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1 \sim 4$ | $5$ | $= 0$ | 无 |
| $5 \sim 7$ | $1000$ | $\le 2$ | 无 |
| $8 \sim 9$ | $3 \times {10}^5$ | $= 0$ | $m = n - 1$ |
| $10 \sim 11$ | $3 \times {10}^5$ | $= 1$ | $m = n - 1$ |
| $12 \sim 14$ | $3 \times {10}^5$ | $= 2$ | $m = n - 1$ |
| $15 \sim 16$ | $3 \times {10}^5$ | $= 0$ | 无 |
| $17 \sim 19$ | $3 \times {10}^5$ | $= 1$ | 无 |
| $20 \sim 25$ | $3 \times {10}^5$ | $= 2$ | 无 |


---

---
title: "[NOI2021] 量子通信"
layout: "post"
diff: 省选/NOI-
pid: P7738
tag: ['2021', 'NOI', 'O2优化']
---
# [NOI2021] 量子通信
## 题目背景

由于评测性能差异，本题时限 +0.5s。
## 题目描述

小 Z 正在自学量子计算机相关知识，最近他在研究量子通信章节，并遇到了一个有趣的问题。在该问题中，Alice 和 Bob 正在进行量子通信，它们的通信语言是一个大小为 $n$ 的字典 $S$，在该字典中，每一个单词 $s_i$（$1 \le i \le n$）都可以用一个 $\boldsymbol{256}$ **位的** $\boldsymbol{01}$ **串**来表示。在本题中 $s_i$ 可以通过调用函数 `gen` 来生成，选手可以在题目目录下的 `gen.cpp` 中查看，该函数的参数 `n`、`a1`、`a2` 将由输入数据给出。

Alice 和 Bob 接下来要进行 $m$ 次通信，每次通信由 Alice 向 Bob 传输**恰好一个**字典中的单词。然而，两人使用的通信信道并不可靠，会受到噪音的干扰。更具体地，对于第 $i$ 次传输，记 Alice 传输的原单词为 $x_i$，该 $01$ 串会受噪音干扰而**翻转最多** $\boldsymbol{k_i}$ **位**。换句话说，记 Bob 这次收到的 $01$ 串为 $y_i$，它与 $x_i$ 相比，可能有最多 $k_i$ 位是不同的，并且 $y_i$ 可能不在字典 $S$ 中出现。

与此同时，Bob 得知坏人 Eve 也潜入了两人的通信信道，并准备干扰两人的通信。他的干扰方式是将 Bob 收到的 $01$ 串变为任意的 $256$ 位 $01$ 串，并且这个串可能不在字典 $S$ 中出现。Eve 非常狡猾，他**不一定**会对每次通信都进行干扰。

现在 Bob 找来了你帮忙，对于接下来的每次通信，你需要根据 Bob 最终收到的 $01$ 串以及这次通信的噪音干扰阈值 $k_i$（$0 \le k_i \le 15$），判断这次通信是否有可能没有受到 Eve 的干扰（即 Bob 收到的 $01$ 串可以由字典中的某个单词翻转至多 $k_i$ 位后得到）。本次通信如果有可能没受到 Eve 干扰，请你输出 $1$，否则输出 $0$。Bob 很信任你的能力，所以你需要**在线地回答结果，具体要求见输入格式**。

为了降低读入用时， Bob 收到的串将用**长度为** $\boldsymbol{64}$ **的** $\boldsymbol{16}$ **进制串**给出，$16$ 进制串中包含数字字符 $\texttt{0} \sim \texttt{9}$ 与大写英文字母 $\texttt{A} \sim \texttt{F}$，其中字符 $\texttt{A} \sim \texttt{F}$ 依次表示数值 $10 \sim 15$。

$16$ 进制串可以逐位转化为 $01$ 串，例如：`5` 对应 `0101`，`A` 对应 `1010`，`C` 对应 `1100`。
## 输入格式

输入数据第一行包含四个非负整数 $n, m, a_1, a_2$，分别表示字典大小，通信次数，以及 `gen` 函数中参数 `a1` 和 `a2` 的初始值。

选手需要在自己的程序中调用题目描述中提到的 `gen` 函数生成单词表，选手可以复制并使用 `gen.cpp` 中的代码，程序中的布尔数组 `s[N+1][256]` 即为所有的单词。

接下来 $m$ 行，每行包含一个长度为 $64$ 的 $16$ 进制串和一个非负整数 $k_i$，分别表示第 $i$ 次通信 Bob 最终收到的 $01$ 串和噪音干扰阈值。

为了强制选手**在线地回答询问**，选手根据 $16$ 进制串还原出 $256$ 位 $01$ 串后，将 $01$ 串每一位异或上 ${\mathit{lastans}}$ 才能得到这次通信中 Bob 收到的真实 $01$ 串，其中 ${\mathit{lastans}} \in \{ 0, 1 \}$ 表示上一次询问的答案，第一个询问前 ${\mathit{lastans}}$ 初始值为 0。

注意：使用 `scanf` 和 `printf` 函数读入或输出 `unsigned long long` 类型变量时，对应的占位符为 `llu`。
## 输出格式

输出共 $m$ 行，每行一个整数 $0$ 或 $1$ 表示当前询问的答案。
## 样例

### 样例输入 #1
```
见附件中的 qi/qi1.in
```
### 样例输出 #1
```
见附件中的 qi/qi1.ans
```
### 样例输入 #2
```
见附件中的 qi/qi2.in
```
### 样例输出 #2
```
见附件中的 qi/qi2.ans
```
### 样例输入 #3
```
见附件中的 qi/qi3.in
```
### 样例输出 #3
```
见附件中的 qi/qi3.ans
```
## 提示

**【询问举例】**

为了方便解释题意，我们使用了直接给出字典中单词、缩小单词长度为 $4$、允许离线地回答询问等方式，对简化的情况举例。

考虑字典大小为 $n = 2$，单词有 `1010` 和 `0111`。

对于询问 `B = 1011` 和 $k_1 = 1$，回答应该是 $1$，通过翻转 `1010` 的第 $4$ 位（从高位到低位，下同）得到。

对于询问 `1 = 0001` 和 $k_2 = 2$，回答应该是 $1$，通过翻转 `0111` 的第 $2$、$3$ 位得到。

对于询问 `1 = 0001` 和 $k_3 = 1$，回答应该是 $0$。

- 翻转 `1010` 至多 $1$ 位可得 `1010`、`0010`、`1110`、`1000`、`1011`。
- 翻转 `0111` 至多 $1$ 位可得 `0111`、`1111`、`0011`、`0101`、`0110`。
- 无法得到 `1 = 0001`，它必定是由 Eve 干扰得到的。

**【数据范围】**

对于所有测试点：$1 \le n \le 4 \times {10}^5$，$1 \le m \le 1.2 \times {10}^5$，$0 \le k_i \le 15$，$a_1$ 和 $a_2$ 在 $[0, 2^{64} - 1]$ 之间均匀随机生成。

| 测试点编号 | $n =$ | $m =$ | $k_i \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10$ | $2$ | 无 |
| $2$ | $500$ | $500$ | $15$ | 无 |
| $3$ | $1000$ | $1000$ | $0$ | 无 |
| $4$ | $2000$ | $2000$ | $2$ | 无 |
| $5$ | $5000$ | $5000$ | $15$ | 无 |
| $6$ | $10^4$ | $10^4$ | $15$ | 无 |
| $7$ | $2\times 10^4$ | $2\times 10^4$ | $15$ | 无 |
| $8$ | $10^5$ | $10^5$ | $1$ | 无 |
| $9$ | $4\times 10^5$ | $1.2\times 10^5$ | $1$ | 无 |
| $10$ | $5\times 10^4$ | $5\times 10^4$ | $2$ | 无 |
| $11$ | $7\times 10^4$ | $7\times 10^4$ | $3$ | 无 |
| $12$ | $10^5$ | $10^5$ | $2$ | 无 |
| $13$ | $3\times 10^4$ | $3\times 10^4$ | $5$ | 无 |
| $14$ | $6\times 10^4$ | $6\times 10^4$ | $4$ | 无 |
| $15$ | $1.2\times 10^5$ | $1.2\times 10^5$ | $5$ | 无 |
| $16$ | $6\times 10^4$ | $6\times 10^4$ | $8$ | 所有询问串随机生成 |
| $17$ | $1.2\times 10^5$ | $1.2\times 10^5$ | $12$ | 所有询问串随机生成 |
| $18$ | $4\times 10^5$ | $10^5$ | $15$ | 所有询问串随机生成 |
| $19$ | $3\times 10^4$ | $3\times 10^4$ | $7$ | 无 |
| $20$ | $6\times 10^4$ | $6\times 10^4$ | $9$ | 无 |
| $21$ | $9\times 10^4$ | $9\times 10^4$ | $11$ | 无 |
| $22$ | $2\times 10^5$ | $1.2\times 10^5$ | $12$ | 无 |
| $23$ | $4\times 10^5$ | $8\times 10^4$ | $15$ | 无 |
| $24$ | $4\times 10^5$ | $10^5$ | $15$ | 无 |
| $25$ | $4\times 10^5$ | $1.2\times 10^5$ | $15$ | 无 |


---

---
title: "[COCI 2011/2012 #3] TRAKA"
layout: "post"
diff: 省选/NOI-
pid: P7747
tag: ['2011', 'COCI（克罗地亚）']
---
# [COCI 2011/2012 #3] TRAKA
## 题目描述

Mirko 的工厂里面有 $n$ 个工人。他们以流水线方式在传送带上制造汽车。工人从左往右编号为 $1\sim n$，其中工人 $1$ 即为 Mirko。汽车生产从工人 $1$（Mirko）开始，在他完成所有他的工作后，工人 $2$ 接手他的任务。之后工人 $3$ 再接手工人 $2$ 的任务，以此类推。当工人 $n$ 完成他的工作后，一辆汽车就生产完成了。

Mirko 和他的工人们必须生产 $m$ 辆汽车，且必须按 $1\sim m$ 的顺序生产。对于第 $i$ 个工人，他完成他的工作的时间为 $t_i$。对于第 $j$ 辆汽车，它装配的复杂度为 $f_j$。工人 $i$ 在汽车 $j$ 上完成他的工作所需时间为 $t_i\cdot f_j$。

根据公司政策，一个工人完成他的工作后，他必须立即将工作交给下一个工人，不得拖延。因此，下一个工人此时不能够在其他汽车上工作。为了满足这个条件，Mirko 必须等到一个好的时机开始制造一辆新车。为了提高效率，他将等待最少的时间，直到他确定能够满足所有条件。

编写一个程序，给定每个工人完成他的工作的时间和每辆车装配的复杂度，求生产所有汽车所需的总时间。
## 输入格式

输入共 $n+m+2$ 行。

第一行，两个整数 $n,m$，分别代表工人的个数和需要生产的汽车的辆数。  
随后 $n$ 行，每行一个整数 $t_i$，表示第 $i$ 个工人完成他的工作的时间。  
随后 $m$ 行，每行一个整数 $f_j$，表示第 $j$ 辆车装配的复杂度。
## 输出格式

输出仅一行一个整数，表示生产所有汽车所需的总时间。
## 样例

### 样例输入 #1
```
3 3
2
1
1
2
1
1
```
### 样例输出 #1
```
11
```
### 样例输入 #2
```
3 3
2
3
3
2
1
2
```
### 样例输出 #2
```
29
```
### 样例输入 #3
```
4 5
3
2
2
2
3
1
2
1
2
```
### 样例输出 #3
```
55
```
## 提示

**【样例 1 解释】**

对于样例 $1$，$4$ 个单位的时间后，工人 $1$ 完成了第一辆车的工作。他可能会立即开始在第二辆车上工作，但这违反了汽车必须在完成后立即传递给下一个工人的条件（$7$ 个单位的时间后第二个工人将完成他在第二辆车上的工作，但是第三个工人不能接手，因为他仍然在第一辆车上工作）。因此，第二辆车在 $5$ 个单位的时间后才能开始生产。$7$ 个单位的时间后开始生产第三辆汽车。第一辆车在 $8$ 个单位的时间后完成，第二辆车在 $9$ 个单位的时间后完成，第三辆车在 $11$ 个单位的时间后完成。因此总时间是 $11$。

**【数据范围】**

对于 $40\%$ 的数据，满足 $n,m\leqslant 1000$。  
对于所有数据，$1\leqslant n,m\leqslant 10^5$，$1\leqslant t_i,f_j\leqslant 10^4$。

**【题目来源】**

本题来源自 **_[COCI 2011-2012](https://hsin.hr/coci/archive/2011_2012/) [CONTEST 3](https://hsin.hr/coci/archive/2011_2012/contest3_tasks.pdf) T6 TRAKA_**，按照原题数据配置，满分 $160$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。


---

---
title: "「MCOI-Zero / AC6-M07」Selumna Peak"
layout: "post"
diff: 省选/NOI-
pid: P7781
tag: ['O2优化']
---
# 「MCOI-Zero / AC6-M07」Selumna Peak
## 题目背景

「Now that's what I call squadron！」

「Come on, it's payback time.」

**「Gracemeria is dead ahead！！」**

$$_{{\frac{\large\text{ACE COMBAT }\Large6}{\tiny{\text{F i r e s\quad O f\quad L i b e r a t i o n}}}}}\\ \text{Mission 07} \\\Large\text{Selumna Peak}\\\tiny-\textit{ Shimmering Death }-$$

![](https://cdn.luogu.com.cn/upload/image_hosting/owa6qtg4.png)
## 题目描述

给定 $1\sim n$ 的排列 $a_{[1,n]}$。

请对于每一个 $i$，考虑如下操作序列：

1. 首先在 $[1,i]$ 中选取一个子序列（可以为空）；
2. 然后将这个子序列内的数重新排列。

求出 **所有不同的操作序列产生的排列** 的逆序对数总和是多少，答案模 $20051131$。

两个操作序列不同当且仅当选取的子序列不同或重新排列的方式不同。

操作不会真正被执行到排列上。
## 输入格式

第一行一个整数 $n$。

接下来一行 $n$ 个数，表示排列 $a$。
## 输出格式

$n$ 行，每行一个数，表示对于前缀 $[1,i]$ 所有不同的操作序列产生的排列的逆序对数总和模 $20051131$ 的值。
## 样例

### 样例输入 #1
```
3
1 2 3
```
### 样例输出 #1
```
0
1
14
```
### 样例输入 #2
```
8
3 2 4 1 6 8 7 5
```
### 样例输出 #2
```
16
39
132
476
2842
21137
172002
1427424
```
## 提示

样例 1 解释：

- 对于 $[1,1]$，无法产生逆序对，答案为 $0$。
- 对于 $[1,2]$，只有一种操作序列可以产生 $2,1,3$，答案为 $1$。
- 对于 $[1,3]$：
	- 有 $8$ 种操作序列产生 $1,2,3$；
   - 有 $2$ 种操作序列产生 $1,3,2$；
   - 有 $2$ 种操作序列产生 $2,1,3$；
   - 有 $1$ 种操作序列产生 $2,3,1$；
   - 有 $1$ 种操作序列产生 $3,1,2$；
   - 有 $2$ 种操作序列产生 $3,2,1$；
- 答案为 $0\times 8+1\times 2+1\times 2+2\times 1+2\times 1+2\times 3=14$。

样例 2 解释：

- 对于 $i=1$，只有两种操作序列，产生的排列都有 $8$ 个逆序对，故答案是 $16$。
- 对于 $i=2$，有 $4$ 种操作序列产生 $3, 2, 4, 1, 6, 8, 7, 5$，有 $1$ 种操作序列产生 $2,3,4,1,6,8,7,5$，答案为 $8\times 4+7\times 1=39$。

数据范围：

- Subtask 1（10%）：$n\leq 8$。
- Subtask 2（20%）：$n\leq 50$。
- Subtask 3（20%）：$n\leq 300$。
- Subtask 4（20%）：$n\leq 3\times 10^3$。
- Subtask 5（30%）：无特殊限制。

对于 $100\%$ 的数据，$1\leq n\leq 10^6$。

idea：Sol1，solution：Sol1，code：Sol1，data：Sol1


---

---
title: "「MCOI-Zero / AC6-M03」 Sipli Field"
layout: "post"
diff: 省选/NOI-
pid: P7782
tag: ['O2优化']
---
# 「MCOI-Zero / AC6-M03」 Sipli Field
## 题目背景

You've been ordered to start the mission now. 

The interception op was a success, enemy air units around Khesed have been weakened, and the Republic of Emmeria's military has taken advantage of this prime opportunity to initiate a counterattack operation with all forces participating. 

Enemy forces have established a wide-scale defensive line around Sipli Field, consisting largely of tank battalions.

Our ground forces are set up to cross the river and penetrate it, and eventually gain control of Khesed. 

Garuda Team, we need you to support our advancing ground units, and eliminate all enemy forces. Multiple units will be simultaneously carrying out various operations on the ground. 

Pay attention to the airspace above each operation area, and provide support as needed. 

This must be the first time you've ever participated in a mission of this scale. 

The battle simulator is a good way to get some practical experience under your belt. 

Godspeed.



$$_{{\frac{\large\text{ACE COMBAT }\Large6}{\tiny{\text{F i r e s\quad O f\quad L i b e r a t i o n}}}}}\\ \text{Mission 03} \\\Large\text{Sipli Field}\\\tiny -\textit{ Fortunes of War
 }-$$

![](https://cdn.luogu.com.cn/upload/image_hosting/az0t8iij.png)
## 题目描述

给定一个 $n$ 个点的树，和两个常数 $L,R$。

请对于每一个点 $u$ 求出有多少条路径过 $u$ 且长度 $d\in [L,R]$。
## 输入格式

第一行三个整数 $n,L,R$。

接下来 $n-1$ 个整数，第 $i$ 个整数 $f_i$ 代表存在一条 $f_i\leftrightarrow i+1$ 的双向边。
## 输出格式

$n$ 行，每行一个整数，表示对应点的答案。
## 样例

### 样例输入 #1
```
5 1 3
1 1 2 2
```
### 样例输出 #1
```
7
9
4
4
4
```
## 提示

样例 1 解释：

- 过 1 的路径：1-2, 1-3, 1-4, 1-5, 2-3, 4-3, 5-3
- 过 2 的路径：2-1, 2-3, 2-4, 2-5, 1-4, 1-5, 3-4, 3-5, 4-5
- 过 3 的路径：3-1, 3-2, 3-4, 3-5
- 过 4 的路径：4-1, 4-2, 4-3, 4-5
- 过 5 的路径：5-1, 5-2, 5-3, 5-4

---

- Subtask 1（3 pts）：$R=1$。
- Subtask 2（7 pts）：$R\leq 2$。
- Subtask 3（10 pts）：$n\leq 100$。
- Subtask 4（10 pts）：$n\leq 2\times 10^3$。
- Subtask 5（15 pts）：$n\leq 10^5,L=1,R=n$。
- Subtask 6（15 pts）：$n\leq 10^5,L=R$。
- Subtask 7（20 pts）：$n\leq 10^5$。
- Subtask 8（20 pts）：无特殊限制。

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^6$，$1\leq L\leq R\leq n$。

idea：\_Solowing\_ClCN，solution：\_Solowing\_ClCN，code：\_Solowing\_ClCN，data：\_Solowing\_ClCN


---

---
title: "[COCI 2016/2017 #6] Gauss"
layout: "post"
diff: 省选/NOI-
pid: P7790
tag: ['2016', 'COCI（克罗地亚）']
---
# [COCI 2016/2017 #6] Gauss
## 题目描述

给出 $K$ 个整数 $F(1),F(2),...,F(K)$，并定义 $i>K$ 的 $F(i)=0$；又给出 $T$ 个幸运整数 $X_i$ 和它的价格 $C(X_i)$，$M$ 个整数 $L_1,L_2,...,L_M$。

一开始黑板上有一个整数 $A$，可以进行如下的两种操作：

- 令当前黑板上的数是 $N$，则可以写下 $N$ 的因数中任意一个小于 $N$ 的因数 $M$，花费 $F(d(N\div M))$。其中 $d(N\div M)$ 表示正整数 $N\div M$ 的因数个数（包括 $N/M$）。

- 如果 $N$ 是一个幸运整数，可以将 $N$ 留在黑板上，花费 $C(N)$。

定义 $G(A,B,L)$ 为以 $A$ 为起始的数，进行了 $L$ 次操作，最终留下 $B$ 的最小花费，请你根据给定的 $A$ 和 $B$，求出 $G(A,B,L_1)+G(A,B,L_2)+...+G(A,B,L_M)$。 
## 输入格式

第一行，一个正整数 $K$；

第二行，$K$ 个正整数 $F(1),F(2),...,F(K)$；

第三行，一个正整数 $M$；

第四行，$M$ 个正整数 $L_1,L_2,...,L_M$；

第五行，一个正整数 $T$；

接下来 $T$ 行，每行两个正整数 $X_i$ 和 $C(X_i)$，代表 $X_i$ 是一个幸运数且它的价格为 $C(X_i)$；

第 $T+5$ 行，一个正整数 $Q$，表示询问的个数；

接下来 $Q$ 行，每行两个正整数 $A$ 和 $B$。
## 输出格式

对于输入的每个询问，输出 $G(A,B,L_1)+G(A,B,L_2)+...+G(A,B,L_M)$。 
## 样例

### 样例输入 #1
```
4
1 1 1 1
2
1 2
2
2 5
4 10
1
4 2 
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
3
6 9 4
2
5 7
3
1 1
7 8
6 10
2
6 2
70 68 
```
### 样例输出 #2
```
118
-2
```
### 样例输入 #3
```
3
8 3 10
2
8 4
3
1 6
5 1
3 7
2
5 1
3 1 
```
### 样例输出 #3
```
16
66
```
## 提示

**【样例解释 #1】**

因为 $L_1=1$，所以将 $4$ 替换成 $2$，花费 $G(4,2,1)=F(d(2))=1$；

因为 $L_2=2$，所以有两种方法将 $4$ 变成 $2$：

- 将 $4$ 替换成 $2$，又因为 $2$ 是幸运数字，所以第二轮留下 $2$。花费 $F(d(4\div 2))+C(2)=1+5=6$；

- 因为 $4$ 是幸运数字，所以第一轮留下 $4$，第二轮将 $4$ 替换成 $2$。花费 $C(4)+F(d(4\div 2))=11+1=12$。

第一种方案花费更少，所以选择第一种方案。

所以答案是 $G(4,2,1)+G(4,2,2)=1+6=7$。

**【数据范围】**

对于 $100\%$ 的数据，$1\le K\le 10^4$，$1\le F(i)\le 10^3$，$1\le M\le 10^3$，$1\le L_i\le 10^4$，$1\le T\le 50$，$1\le X_i\le 10^6$，$1\le C(X_i)\le 10^3$，$1\le Q\le 5\times 10^4$，$1\le A,B\le 10^6$。

**【说明】**

本题分值按 COCI 原题设置，满分 $160$。

题目译自 [COCI2016_2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #6](https://hsin.hr/coci/archive/2016_2017/contest6_tasks.pdf) _**T6 GAUSS**_


---

---
title: "[COCI 2015/2016 #6] SAN"
layout: "post"
diff: 省选/NOI-
pid: P7802
tag: ['2015', 'COCI（克罗地亚）']
---
# [COCI 2015/2016 #6] SAN
## 题目描述

$\text{Anica}$ 有一张神秘的无限表，表里有无限行和无限列。有趣的是，表中的每个数字出现的次数是有限的。

定义函数 $\mathrm{rev}(i)$，返回 $i$ 在十进制下翻转后得到的新数字。例如 $\mathrm{rev}(213)=312$，$\mathrm{rev}(406800)=008604=8604$。

表中第 $i$ 行第 $j$ 列的数字 $A(i,j)$ 由以下方式得到：

- $A(i,1)=i$

- $A(i, j) = A(i, j − 1)+\mathrm{rev}\big(A(i,j-1)\big)$，$j>1$

![](https://cdn.luogu.com.cn/upload/image_hosting/aqhn1qzp.png)

现在 $\text{Anica}$ 给出 $Q$ 个询问，每个询问给出两个整数 $L$ 和 $R$，请你求出无限表中有多少个数的大小在 $\big[L,R\big]$ 中。
## 输入格式

第一行包含一个整数 $Q$。

接下来 $Q$ 行，每行包含两个整数 $L$ 和 $R$。
## 输出格式

输出包含 $Q$ 行，每行一个整数，其中第 $i$ 行为第 $i$ 个问题的答案。
## 样例

### 样例输入 #1
```
2
1 10
5 8
```
### 样例输出 #1
```
18
8
```
### 样例输入 #2
```
3
17 144
121 121
89 98
```
### 样例输出 #2
```
265
25
10
```
### 样例输入 #3
```
1
1 1000000000
```
### 样例输出 #3
```
1863025563
```
## 提示

**【数据范围】**

对于 $50\%$ 的数据，保证 $1\le L,R\le 10^6$。

对于 $100\%$ 的数据，保证 $1\le Q\le 10^5$，$1\le L,R\le 10^{10}$。

**【题目来源】**

**题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #6](https://hsin.hr/coci/archive/2015_2016/contest6_tasks.pdf) T6 SAN**。

**本题分值按 COCI 原题设置，满分 $160$**。


---

---
title: "[JOI Open 2021] Crossing"
layout: "post"
diff: 省选/NOI-
pid: P7803
tag: ['2021', 'JOI（日本）']
---
# [JOI Open 2021] Crossing
## 题目背景

# 警告：滥用本题评测将被封号！
## 题目描述

你的资源库里有 $3$ 个长度为 $N$ 的只由 `J`，`O`，`I` 组成的序列 $S_A,S_B,S_C$，你可以进行 C 操作（全名为 Cross 操作，简写为 C 操作），每一次 C 操作你可以在资源库里选择两个字符串 $C_1,C_2$，C 操作后产生的字符串为 $C_3$，则对于任意 $i \in [1,N]$，设这三个字符串第 $i$ 个位置上的字符分别为 $c_1,c_2,c_3$，有：

|$c_1$|$c_2$|$c_3$|
|:-:|:-:|:-:|
|J|J|J|
|J|O|I|
|J|I|O|
|O|J|I|
|O|O|O|
|O|I|J|
|I|J|O|
|I|O|J|
|I|I|I|

上面这个表格的意思是 $c_1,c_2$ 为对应字符时，$c_3$ 也应该是对应的字符。

进行 C 操作后将会把产生的字符串放入资源库。

你被给定了一个长度为 $N$ 的只由 `J`，`O`，`I` 组成的字符串 $T_0$，和 $Q$ 个整数 $L_j,R_j$ 和 $Q$ 个字符 $C_j$，由这些形成 $Q$ 个长度为 $N$ 的字符串 $T_j$，规则为：

> $T_j$ 是由 $T_{j-1}$ 的第 $L_j$ 个字符到第 $R_j$ 个字符都替换成 $C_j$ 得到的。

求对于每一个字符串（包括 $T_0$），是否能由给定的资源库进行一次或多次 C 操作得来。如果该字符串与资源库的其中一个字符串一模一样，也可以称“进行 C 操作得来”，详细内容请看样例 1 的 $T_2$。

第 $j$ 个字符串进行 C 操作时放入资源库的字符串将会在对第 $j+1$ 个字符串判断时清空。
## 输入格式

第一行一个整数 $N$ 代表字符串的长度。

接下来 $3$ 行 $S_A,S_B,S_C$ 代表给定的资源库里的字符串。

第五行一个整数 $Q$ 代表给定的字符串个数。

第六行一个字符串 $T_0$，意义如题面所述。

接下来 $Q$ 行每行两个整数和一个字符 $L_j,R_j,C_j$，意义如题面所述。
## 输出格式

$Q+1$ 行每行一个字符串 `Yes` 或 `No`，第 $j$ 行代表第 $T_{j-1}$ 个字符串是否可以由初始资源库得来。
## 样例

### 样例输入 #1
```
4
JOJO
JJOI
OJOO
3
IJOJ
1 4 O
2 2 J
2 4 I
```
### 样例输出 #1
```
Yes
No
Yes
Yes
```
### 样例输入 #2
```
3
JOI
JOI
JOI
2
OJI
1 2 O
1 1 J
```
### 样例输出 #2
```
No
No
Yes
```
## 提示

#### 样例 1 解释

- $T_0$ 可以由 `JJOI` 和 `OJOO` 经过 C 操作而来；
- $T_1$ 为 `OOOO`，无法从资源库经过 C 操作而来；
- $T_2$ 为 `OJOO`，资源库中有 `OJOO`，故可以；
- $T_3$ 为 `OIII`：
	1. 由 `JJOI` 和 `OJOO` 经过 C 操作产生 `IJOJ`；
    2. 由 `JOJO` 和 `IJOJ` 经过 C 操作产生 `OIII`。
    
#### 样例 2 解释

- $T_0$ 无法从资源库经过 C 操作而来；
- $T_1$ 为 `OOI`，无法从资源库经过 C 操作而来；
- $T_2$ 为 `JOI`，资源库中有 `JOI`，故可以。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（3 pts）：$S_A=S_B=S_C$，$N \le 100$；
- Subtask 2（23 pts）：$S_A=S_B=S_C$；
- Subtask 3（23 pts）：$N \le 100$；
- Subtask 4（51 pts）：无特殊限制。

对于 $100\%$ 的数据：

- $1 \le N \le 2 \times 10^5$；
- $S_A,S_B,S_C$ 是只包含 `J`，`O`，`I` 的长度为 $N$ 的字符串；
- $1 \le Q \le 2 \times 10^5$；
- $T_0$ 是只包含 `J`，`O`，`I` 的长度为 $N$ 的字符串；
- $1 \le L_j \le R_j \le N$；
- $C_j \in  \{$`J`，`O`，`I`$\}$。 

#### 说明

翻译自 [JOI 2020 / 2021 Open Contest A Crossing](http://s3-ap-northeast-1.amazonaws.com/data.cms.ioi-jp.org/open-2021/crossing/2021-open-crossing-statement-en.pdf)。


---

---
title: "[JOI Open 2021] Monster Game"
layout: "post"
diff: 省选/NOI-
pid: P7805
tag: ['2021', '交互题', 'Special Judge', 'JOI（日本）']
---
# [JOI Open 2021] Monster Game
## 题目背景

**本题为交互题。**

交互库与 spj 提供者 @[Liking_Cpp_In_Luogu](https://www.luogu.com.cn/user/705620)，感谢他的贡献！

请不要在代码中加入头文件 `monster.h`，在 Solve 函数前加上 `extern "C"`，开头加上 `extern "C" bool Query(int,int);` 即可。

# 警告：滥用本题评测将被封号！
## 题目描述

你圈养了 $N$ 只书虫，这 $N$ 只书虫编号为 $0 \sim N-1$，第 $i$ 只书虫的力量值为 $S_i$，满足 $S_i \in [0,N-1]$，且没有两只书虫的力量值是相等的。

你可以调用最多 $25000$ 次「打架事件」：

- 选择两只编号不相同的书虫 $a,b$：
	- 如果 $|S_a-S_b|=1$，则力量值小的书虫获胜；
    - 如果 $|S_a-S_b|>1$，则力量值大的书虫获胜。

请最小化调用「打架事件」的次数，你可以得到每次「打架事件」的结果，求所有书虫的力量值。

#### 交互格式

你的程序需要实现以下函数：

- `std::vector<int> Solve(int N)`
	- 对于每组数据，该函数只能被调用一次；
    - $N$：书虫的个数；
    - 该函数返回这 $N$ 只书虫的力量值数组 $T$；
    - 应该满足 $|T|=N$，否则您的程序将会被判为 `Wrong
Answer [1]`；
	- 应该满足 $T_i\in [0,N-1]$，否则您的程序将会被判为 `Wrong Answer [2]`；
    - 应该满足 $T_i=S_i$，否则您的程序将会被判为 `Wrong Answer [3]`。

你的程序可以调用以下函数：

- `bool Query(int a, int b)`
	- 你可以用这个函数调用「打架事件」；
    - $a,b$：书虫 $a$ 与书虫 $b$ 打架；
    - 如果 $a$ 获胜了，则返回 `true` 否则返回 `false`；
    - 应该满足 $a \in [0,N-1]\land b \in [0,N-1]$，否则您的程序将会被判为 `Wrong Answer [4]`；
    - 应该满足 $a \ne b$，否则您的程序将会被判为 `Wrong Answer [5]`；
    - 调用 `Query` 函数应该不超过 $25000$ 次。否则您的程序将会被判为 `Wrong Answer [6]`。
    
**特殊说明**

1. 您的程序可以调用其他标准库里的函数，或者使用全局变量；
2. 您的程序不得使用标准输入与标准输出。
## 输入格式

见「交互格式」。
## 输出格式

见「交互格式」。
## 样例

### 样例输入 #1
```
5
3 1 4 2 0
```
### 样例输出 #1
```

```
## 提示

#### 样例 1 解释

样例的交互过程：

|调用|返回|调用|返回|
|:-:|:-:|:-:|:-:|
|`Solve(5)`||||
|||`Query(1, 0)`|`false`|
|||`Query(4, 0)`|`false`|
|||`Query(1, 3)`|`true`|
||`[3, 1, 4, 2, 0]`||

#### 评测程序示例（样例）

评测程序示例以如下格式读取输⼊数据：

第一行：$N$       
第二行：$S_0\ S_1\ \cdots\ S_{N-1}$

评测程序示例以如下格式读取输出数据：

当程序成功结束运行后，样例交互器会在标准输出中输出以下内容：

- 如果你的程序被判为正确，样例交互器会输出类似 `Accepted: 100` 的信息，其中 $100$ 为你的程序调用 `Query` 函数的次数；
- 如果你的程序被判为错误，样例交互器的输出内容已在「交互格式」中描述。

如果你的程序有多数错误，样例交互器只会判断其中的一种。

注意，交互器在某些数据中是自适应性的，也就是实际的交互器刚开始并没有一个确定的答案，而是会随着之前 `Query` 函数的调用逐渐做出响应，能保证至少有一组答案满足交互库做出的响应。

（本来原题有一个工具可以用来检测，但是找不到检测文件了，所以就咕掉了）

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（10 pts）：$N \le 200$；
- Subtask 2（15 pts）：实际使用的交互库并不是自适应性的；
- Subtask 3（75 pts）：无特殊限制。

对于 $100\%$ 的数据：

- $4 \le N \le 1000$；
- $0 \le S_i \le N-1$；
- $S_i$ 保证互不相同。

对于 Subtask 3，特有一套评分标准：

如果你的程序通过了所有测试数据，那：

- 设 $X$ 为 Subtask 3 中你的程序对每个测试点调用的 `Query` 函数的次数的最大值；
- 你的分数将按照下面的过程计算：	
	- 如果 $10^4<X \le 2.5 \times 10^4$，你将得到 $\left\lfloor75 \times \dfrac{2.5 \times 10^4-X}{1.5 \times 10^4}\right\rfloor$ 分；
    - 如果 $X \le 10^4$，你将得到 $75$ 分。
    
#### 说明

翻译自 [JOI 2020 / 2021 Open Contest C Monster Game](http://s3-ap-northeast-1.amazonaws.com/data.cms.ioi-jp.org/open-2021/monster/2021-open-monster-statement-en.pdf)。


---

---
title: "「RdOI R3」闹钟"
layout: "post"
diff: 省选/NOI-
pid: P7823
tag: ['O2优化']
---
# 「RdOI R3」闹钟
## 题目描述

你有一个闹钟，闹钟的定时可以用两个变量 $a_1,a_2$ 表示，变量的初始值皆为 $0$。把一个变量从 $x$ 调整至 $y$ 需要 $|x-y|$ 的代价。

接下来给出 $n$ 个数 $k_1,k_2,\cdots,k_n$。对于第 $i$ 天，你都需要通过调整变量的值，使得两个变量中**至少**有一个等于 $k_i$。求最小代价。
## 输入格式

第一行一个整数 $n$。  
第二行 $n$ 个整数 $k_1,k_2,\cdots,k_n$。
## 输出格式

一行一个整数，表示最小代价。
## 样例

### 样例输入 #1
```
6
1 1 4 5 1 4
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
5
4 1 9 2 3
```
### 样例输出 #2
```
12
```
## 提示

### 样例解释

样例解释一：  
第一天：$a=\{1,0\}$。  
第二天：$a=\{1,0\}$。  
第三天：$a=\{4,0\}$。  
第四天：$a=\{5,0\}$。  
第五天：$a=\{5,1\}$。  
第六天：$a=\{4,1\}$。  

样例解释二：  
第一天：$a=\{4,0\}$。  
第二天：$a=\{4,1\}$。  
第三天：$a=\{9,1\}$。  
第四天：$a=\{9,2\}$。  
第五天：$a=\{9,3\}$。 

---

### 数据范围

|数据编号|$n\le$|特殊性质|
|:-:|:-:|:-:|
|$1$|$10$|无|
|$2$|$10^3$|$k_i\le100$|
|$3\sim4$|$10^3$|无|
|$5\sim7$|$10^5$|$k_i\le100$|
|$8\sim10$|$10^5$|无|

另外，为了卡掉一些错误做法，本题添加了若干 hack 测试点。hack 测试点的数据满足 $n\le10$ 且 $k_i\le 100$。若你的程序没有通过至少一个 hack 测试点，则此题分数记为 $0$ 分。

对于 $100\%$ 的数据，$1\le n\le10^5,1\le k_i\le10^9$。


---

---
title: "「RdOI R3」毒水"
layout: "post"
diff: 省选/NOI-
pid: P7824
tag: ['交互题', 'Special Judge', 'O2优化']
---
# 「RdOI R3」毒水
## 题目描述

**这是一道 IO 交互题。**

现在你面前有 $n$ 瓶水，从 $1\sim n$ 编号，其中有 $1$ 瓶水有毒，你可以用一些小白鼠来进行判断。

但是你找的小白鼠中**有且仅有**一只**变异鼠**，**如果它喝的水中有毒水，那么它不会死亡。否则它会在 $59$ 秒内死亡。其它小白鼠如果喝了毒水将在 $59$ 秒内死亡，否则不会死亡**。

你需要在一分钟内找出这瓶毒水，因为测试已经花了 $59$ 秒，所以你的代码只能运行 $1$ 秒。

### 交互方式

首先你需要从标准输入读取两个整数 $n$，$maxk$，表示水的数量，以及你最多能找到的小白鼠个数。

若你需要 $k$ 只小白鼠，你需要向标准输出打印 $k+1$ 行，除了最后一行，每一行的格式为：`1 m B1 B2 ... Bm`，表示你找到一只小白鼠并让它喝 $B_1$ 号，$B_2$ 号，$\cdots$，$B_m$ 号这 $m$ 瓶中的水。你需要在最后写上一行：`2`，随后清空缓冲区，表示你不需要更多的小白鼠了。

下面是一些语言的刷新缓冲区操作：

- C++：`fflush(stdout)` 或 `cout.flush()`。
- C: `fflush(stdout)`。
- Java: `System.out.flush()`。
- Python: `stdout.flush()`。
- Pascal: `flush(output)`。
- 其他语言：请参考对应语言的帮助文档。

当然，如果 $k>maxk$，交互库会返回 `WA`、`RE`、`UKE` 或 `TLE`，同时该测试点不得分。

然后你需要从标准输入读取 $k$ 个整数 $R_1,R_2,\cdots,R_k;R_i\in\{0,1\}$。若 $R_i=0$ 代表第 $i$ 号小白鼠已死亡，否则代表第 $i$ 号小白鼠仍存活。

最后你需要从标准输出打印一个整数，表示毒水的编号。
## 输入格式

见**交互方式**。
## 输出格式

见**交互方式**。
## 样例

### 样例输入 #1
```
4 12













1 0 1 1 1 1 1 1 1 0 1 1

```
### 样例输出 #1
```

1 1 1
1 1 2
1 1 3
1 1 4
1 1 1
1 1 2
1 1 3
1 1 4
1 1 1
1 1 2
1 1 3
1 1 4
2

2
```
## 提示

### 样例说明

毒水的编号为 $2$，且第 $2$ 次和第 $10$ 次均为让小白鼠喝下 $2$ 号毒水，故这两次操作返回的结果为 $0$。其他操作由于让小白鼠喝的不是毒水，返回的结果为 $1$。

**样例仅为理解交互方式使用，可能不符合逻辑。**

---

### 数据范围

**本题采用捆绑测试。**  

**注意：本题不存在一个 subtask 包含其他所有 subtask**。

| subtask | 分值 | $n$             | $maxk\ge$ |
| ------- | ---- | --------------- | ------- |
| $1$     | $1$  | $=1$            | $0$     |
| $2$     | $9$  | $\le 1000$      | $3000$  |
| $3$     | $20$ | $\le 1000$      | $30$    |
| $4$     | $30$ | $8\le n \le 16$ | $7$     |
| $5$     | $40$ | $\le 1000$      | $15$    |

---

### 注意

只有你向交互器发送 $2$ 操作时，交互器才会将你先前的 $1$ 操作的答案告诉你。也就是说，你不能在执行一次 $1$ 操作后立刻得到这次操作的返回结果。


---

---
title: "「dWoi R2」FFT / 狒狒贴"
layout: "post"
diff: 省选/NOI-
pid: P7844
tag: []
---
# 「dWoi R2」FFT / 狒狒贴
## 题目背景

狱原权太正在尝试学习 FFT ……
## 题目描述

给定一个长度为 $2^n$ 的非负整数序列 $a_0,a_1,\cdots,a_{2^n-1}$，请计算序列 $A=\text{DFT}^k(a)$。

其中 $\text{DFT}(b)_i$ 定义为：

$$\text{DFT}(b)_i=\sum_{j=0}^{2^n-1}b_j\omega^{ij}\mod{998244353}$$
$$\omega\equiv3^{\frac{998244352}{2^n}}\pmod{998244353}$$
## 输入格式

第一行两个非负整数 $n,k$。

接下来一行 $2^n$ 个非负整数 $a_0,a_1,\cdots,a_{2^n-1}$。
## 输出格式

一行 $2^n$ 个非负整数 $A_0,A_1,\cdots,A_{2^n-1}$。
## 样例

### 样例输入 #1
```
3 3
1 2 3 4 5 6 7 8
```
### 样例输出 #1
```
288 831546728 224054051 383438562 998244321 614805727 774190238 166697561
```
## 提示

#### 数据规模与约定

 - Subtask 1（10 pts）：$n\le 11$ 且 $k\le 10$；
 - Subtask 2（10 pts）：$k\le 10$；
 - Subtask 3（20 pts）：$n\le 5$；
 - Subtask 4（30 pts）：$n\le 11$；
 - Subtask 5（30 pts）：无额外限制。

对于所有数据，$1\le n\le 17$，$1\le k\le10^{18}$，$0\le a_i\le 998244353$。


---

---
title: "「JZOI-2」信号塔"
layout: "post"
diff: 省选/NOI-
pid: P7851
tag: []
---
# 「JZOI-2」信号塔
## 题目背景

团员们满脑子都是办周年庆，但小僖只想摸鱼。

小僖想看电视，但是发现没信号了，于是他去修理信号塔了。
## 题目描述

在一条有 $10^{999}+1$ 个点的直线上，满足直线上相邻两点间的距离相等，每个点上建立都建立了一个信号塔，从左到右编号为 $0\sim 10^{999}$，其中 $0$ 号塔是电视节目发送点。

由于小僖只想看电视，所以这里的信号只会从左往右传输。假设一个信号塔的强度为 $x$，那么它的信号最多能往右传输 $\lfloor\frac{x-1}{k}\rfloor$ 的距离。

现在小僖要给每个信号塔设置一个强度，但由于信号塔太多了，他忙不过来，于是他交给了笨笨机器人来做。

笨笨机器人按照以下方式给每个信号塔设置一个强度。

首先先将 $0$ 号塔的强度设为 $10^{30}$，然后从左到右，从 $1$ 号信号塔开始一直做到 $10^{999}$ 号信号塔。对于每个信号塔，在其左边寻找离它最近的一个信号塔 $a$，满足 $a$ 信号塔的信号可以传送到该信号塔，然后将该信号塔的信号强度赋值为这两个信号塔之间的距离。

这里定义 $i$ 号信号塔和 $j$ 号信号塔之间的距离为 $|i-j|$。

例如当 $k=2$ 的时候 $1\sim5$ 号的信号塔的强度分别为 $1,2,3,1,5$。

但小僖还是不放心笨笨机器人，所以他想知道第 $n$ 个信号塔的强度。
## 输入格式

一行，两个正整数 $n,k$。

具体意义见题面。
## 输出格式

一行，一个整数，表示编号为 $n$ 信号塔的强度。
## 样例

### 样例输入 #1
```
1 1
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
5 2
```
### 样例输出 #2
```
5
```
## 提示

对于 $10\%$ 的数据，$1\le n,k\le 2 \times 10^3$。  
对于 $30\%$ 的数据，$1\le n\le 1 \times 10^7$。  
对于另外 $15\%$ 的数据，$k=1$。  
对于另外 $15\%$ 的数据，$k=2$。  
对于 $100\%$ 的数据 $1\leq n\leq10^{18},1\leq k\leq10^{6}$。


---

---
title: "「MCOI-06」Eert Tuc Knil"
layout: "post"
diff: 省选/NOI-
pid: P7889
tag: ['2021', 'O2优化', '洛谷月赛']
---
# 「MCOI-06」Eert Tuc Knil
## 题目描述

给定一颗 $n$ 个节点有根树，第 $i$ 节点权值为 $a_i$。

在这个树上支持一种询问：

 - 给定节点 $u$ 和参数 $x$，**假如** 所有节点点权加 $x$，**在这种情况下，求：** 对于所有完全在 $u$ 子树内并包含 $u$ 的连通点集，权值之和最大可能为多少？
## 输入格式

第一行两个正整数 $n$ 和 $m$。

第二行 $n-1$ 个正整数 $f_2,f_3,\dots,f_n$，依次为 $2,3,\dots,n$ 的父亲节点编号，其中保证 $1\le f_i<i$。

第三行 $n$ 个整数 $a_1,a_2,\dots,a_n$，依次为 $1,2,\dots,n$ 点权。

接下来 $m$ 行，每行一个正整数 $u$ 和一个整数 $x$，代表一组询问，其中保证 $1\le u\le n$。
## 输出格式

输出 $m$ 行，每行一个整数，为对应询问的答案。
## 样例

### 样例输入 #1
```
10 6
1 1 2 2 3 5 5 5 6
5 2 3 1 -5 -7 1 1 1 2
1 0
1 -2
1 3
2 1
5 0
5 -2
```
### 样例输出 #1
```
11
4
34
7
-2
-7
```
## 提示

#### 数据规模与约定

**本题采用捆绑测试。**

 - Subtask 1（5 pts）：$n,m\le 1000$。
 - Subtask 2（10 pts）：$n,m\le 10^5$ 并且 $|a_i|,|x|\le 50$。
 - Subtask 3（15 pts）：$n\le 1000$。
 - Subtask 4（47 pts）：$n,m\le 10^5$。
 - Subtask 5（23 pts）：无特殊限制。

对于所有数据，$1\le n,m\le 10^6$，$|a_i|,|x|\le 10^8$，保证 $1\le u\le n$。


---

---
title: "黄牛の争"
layout: "post"
diff: 省选/NOI-
pid: P7905
tag: ['2021', 'Special Judge', 'O2优化', '洛谷月赛']
---
# 黄牛の争
## 题目背景

Source：天空之城

本题背景中「黄牛」仅代指某游戏中的一种怪物，与一般含义的「[**黄牛**](https://baike.baidu.com/item/黄牛党/285883)」无关。

本题「推荐题目」三灰一黑，但不太能说明本题难度和他们差不多（

相传在很久很久之前梅兰德大陆上空漂浮着一座天空之城，是当时财富、力量、荣誉中心，突然有一天再也不见踪影。

如今已多个世纪不见痕迹的天空之城突然出现，王国的勇士去探索一番，但是飞船船票可不是那么好得到的。

**飞艇码头的船长是梅德龙 · 杜鲁夫，船长为了牟利要求大家必须 *买* *票* *上* *船*，没有票的旅行者无法登船。**

დ琢喵 作为一届黄牛的首领——黄牛党，派出了 $q$ 组黄牛买断了梅德龙 · 杜鲁夫的船票。

她以高价卖出这些船票，并通过差价获取巨额利润。

为维护飞艇码头的治安，梅德龙 · 杜鲁夫规定不允许人类和黄牛打架，当然船长并没有规定黄牛之间不可以打架。
## 题目描述

დ琢喵 的手下有两种黄牛：

1. I 类黄牛「攻击」为 $a$，「血量」为 $A$；
2. II 类黄牛「攻击」为 $b$，「血量」为 $B$。

黄牛之间的作战，满足以下条件：

1. 任意时刻，某一方「血量」$\le 0$ 时，其对手胜利；
2. 每一回合，「攻击」高者先手；
3. 每回合每方出手一次，造成的伤害即其「攻击」值。

构造的 III 类黄牛应当满足下面条件：

1. 「攻击」数值与 I 类黄牛和 II 类黄牛都不同；
2. I 类黄牛和 II 类黄牛作战 II 类黄牛胜利；（若输入不满足该条件则应直接输出 `-1 -1`）
3. II 类黄牛和 III 类黄牛作战 III 类黄牛胜利；
4. III 类黄牛和 I 类黄牛作战 I 类黄牛胜利。

请给出一种合法的构造。

---

**题意简述**

解方程：（若 $x=\text{true}$ 则 $[x]=1$ 反之 $=0$）

$$\begin{aligned}\left\lceil\frac{A}{b}\right\rceil&+[b<a]\le\left\lceil\frac{B}{a}\right\rceil\\\left\lceil\frac{B}{c}\right\rceil&+[c<b]\le\left\lceil\frac{C}{b}\right\rceil\\\left\lceil\frac{C}{a}\right\rceil&+[a<c]\le\left\lceil\frac{A}{c}\right\rceil\\c&\ne a~\text{and}~c\ne b\end{aligned}$$

已知 $a,A,b,B$，解 $c,C$。
## 输入格式

**本题多测。**

第一行一个正整数 $q$。

接下来 $q$ 行，每行四个正整数 $a,A,b,B$。

数据满足 $a\ne b$。
## 输出格式

一共 $q$ 行，每行两个正整数表示你构造的 III 类黄牛的「攻击」数值和「血量」数值，无解时输出 `-1 -1`。

**本题采用 Special Judge，所有满足要求的解均给分。**
## 样例

### 样例输入 #1
```
3
1 5 2 3
2 3 4 1
4 1 1 5
```
### 样例输出 #1
```
4 1
1 5
2 3
```
### 样例输入 #2
```
4
14 1 10 15
14 1 10 15
14 1 10 15
14 1 10 15
```
### 样例输出 #2
```
11 11
11 12
11 13
11 14
```
### 样例输入 #3
```
1
1 1 999 999
```
### 样例输出 #3
```
-1 -1
```
## 提示

### 样例说明

对于样例 #1，可设 A 是 $(1,5)$，B 是 $(2,3)$，C 是 $(4,1)$。

其中二元组 $(x,y)$ 表示一个「攻击」为 $x$，「血量」为 $y$ 的黄牛。

下面的表格展现了 A、B、C 的对战情况，括号中的数字表示每回合开始时它们的「血量」数值。

| A 和 B 单挑 | B 和 C 单挑 | C 和 A 单挑 |
| :----------: | :----------: | :----------: |
| $\begin{aligned}&\texttt{A(5)~B(3)}\overset{\texttt{A-2~B-1}}{\Rightarrow\Rightarrow}\\&\texttt{A(3)~B(2)}\overset{\texttt{A-2~B-1}}{\Rightarrow\Rightarrow}\\&\texttt{A(1)~B(1)}\overset{\texttt{A-2}}{\Rightarrow}\\&\texttt{A}\le\texttt{0~\color{red}B win}\end{aligned}$ | $\begin{aligned}&\texttt{B(3)~C(1)}\overset{\texttt{B-4}}{\Rightarrow}\\&\texttt{B}\le\texttt{0~\color{red}C win}\end{aligned}$ | $\begin{aligned}&\texttt{A(5)~C(1)}\overset{\texttt{A-4~C-1}}{\Rightarrow\Rightarrow}\\&\texttt{C}\le\texttt{0~\color{red}A win}\end{aligned}$ |

因此输出剩下一类黄牛即给分。

对于样例 #2：钦定 III 类黄牛攻击力为 $11$，已经足以击倒 II 类黄牛，血量为 $11\sim14$ 都可以输给 I 类黄牛。

因此任意输出一组均给分。

对于样例 #3：II 类黄牛十分强大，难以再构造又能击败 II 类黄牛又能输给 I 类黄牛的 III 类黄牛品种。

因此输出 `-1 -1` 即给分。

### 数据规模

设 $M=\max\left(a,A,b,B\right)$：

- Subtask1(10pts)：$M\le10,q=399\underline0$。
- Subtask2(20pts)：$M\le100,q=399\underline1$，数据随机。
- Subtask3(10pts)：$M\le10^5,q=99\underline2$，数据随机。
- Subtask4(20pts)：$M\le10^5,q=99\underline3$。
- Subtask5(10pts)：$q=399\underline4$，数据随机。
- Subtask6(30pts)：$q=399\underline5$，无特殊限制。
- 本题根据数据强度设置了不同梯度的时间限制，如果有合理的满分做法被卡了请联系我。

提示：数据组数 $q$ **结尾** 的数字（$\underline0,\underline1,\underline2,\underline3,\underline4,\underline5$）可能有助于你判断 Subtask 的类型。

对于 $100\%$ 的数据：$1\le q<4000,1\le M\le10^8$。

### 大样例

本题提供符合 Subtask $2,3,5$ 限制的测试用例。

直接编译并运行下面代码，即可得到 `E01.in` `E02.in` `E03.in` 分别是满足 Subtask $2,3,5$ 限制的测试数据。

```cpp
#include<ctime>
#include<cstdio>
#include<random>
#include<string>
#include<cassert>
#include<cstdlib>
#include<iostream>
#define int long long
void print(int x){
	if (x < 0) x = -x, putchar('-');
	if (x > 9) print(x / 10);
	putchar(x % 10 + '0');
}
void printsp(int x){
	print(x), putchar(' ');
}
void println(int x){
	print(x), putchar('\n');
}
char str[] = "E  .in";
const int Buff = 3989;
std::string string;
namespace Data_Maker{
	std::mt19937 rnd(time(0));
	int rand(int l, int r) {
		int x = r - l + 1;
		return (rnd() % x + x) % x + l;
	}
	int a, A, b, B;
	void maker(int subtaskID) {
		int t = Buff + subtaskID;
		if (3 <= subtaskID && subtaskID <= 4)
			t -= 3000;
		println(t);
		if (subtaskID == 2 || subtaskID == 3 || subtaskID == 5) {
			int MOD = 0;
			if (subtaskID == 2) MOD = 100;
			if (subtaskID == 3) MOD = 100000;
			if (subtaskID == 5) MOD = 100000000;
			while (t--) {
				a = rand(1, MOD), A = rand(1, MOD);
				b = rand(1, MOD), B = rand(1, MOD);
				while (b == a)
					b = rand(1, MOD);
				printsp(a), printsp(A), printsp(b), println(B);
			}
		}
	}
	void File(int Test) {
		str[1] = Test / 10 + '0';
		str[2] = Test % 10 + '0';
		freopen(str, "w", stdout);
	}
	void Subtask2() {
		for (int Test = 1; Test <= 1; ++Test) {
			File(Test); maker(2);
		}
	}
	void Subtask3() {
		for (int Test = 2; Test <= 2; ++Test) {
			File(Test); maker(3);
		}
	}
	void Subtask5() {
		for (int Test = 3; Test <= 3; ++Test) {
			File(Test); maker(5);
		}
	}
}
using namespace Data_Maker;
signed main(){
	Subtask2();
	Subtask3();
	Subtask5();
}
```

另外还提供了下面的 Special Judge，可以编译并通过调用 `spj E.in E.out E.ans` 来获取返回信息。

```cpp

#include "testlib.h"
#define int long long
#define inf inf.readLong()
#define ouf ouf.readLong()
#define ans ans.readLong()
bool win(int a, int A, int b, int B){
  int x = 0, f = 1;
  if (a < b)
    a ^= b ^= a ^= b, A ^= B ^= A ^= B, f *= -1;
  while (1) {
    if (B - a <= 0) {
      x = 1;
      break;
    }
    if (A - b <= 0) {
      x = -1;
      break;
    }
    B -= a, A -= b;
  }
  x *= f;
  return x < 0;
}
signed main (signed argc, char**argv) {
  registerTestlibCmd(argc, argv);
  int q = inf;
  for (int t = 1; t <= q; ++t) {
    int a = inf, A = inf, b = inf, B = inf, c = ouf, C = ouf, d = ans, D = ans;
    if (d == -1 && c == -1 && C == -1)
      continue;
    if (c == a)
      quitf (_wa, "Test #%lld, a cannot equal to c!", t);
    if (c < 1 || C < 1)
      quitf (_wa, "Test #%lld, cannot print negative numbers!", t);
    if (!win(c, C, a, A))
      quitf (_wa, "Test #%lld, A cannot beat C!", t);
    if (!win(b, B, c, C))
      quitf (_wa, "Test #%lld, C cannot beat B!", t);
    if (!win(a, A, b, B))
      quitf (_wa, "Test #%lld, B cannot beat A!", t);
  }
  quitf (_ok, "Good job!");
}
```

题目附件中的是本题实际数据的脚造方式，如有更强有意义的数据欢迎在讨论区中提出并 at 出题人。


---

---
title: "[Kubic] Permutation"
layout: "post"
diff: 省选/NOI-
pid: P7920
tag: ['O2优化', '洛谷月赛']
---
# [Kubic] Permutation
## 题目背景

建议先看 E 题题目背景。
## 题目描述

对于一个 $1\sim n$ 的排列 $p$，定义 $G_p$ 为使用以下方法构造出来的**无向图**：
- 对于每一个 $i\in (1,n]$，找到最大的 $j\in [1,i)$ 满足 $p_i>p_j$，然后连一条 $i,j$ 之间的边，如果不存在这样的 $j$ 则不连。

给定一棵有 $n$ 个节点的树 $T$。

把 $p$ 称为**好排列**当且仅当 $G_p$ 与 $T$ 同构。

如果存在**好排列**，输出其中**字典序最大**的一个。否则输出 $-1$。

无向图 $G_1,G_2$ 同构当且仅当存在一个 $1\sim n$ 的排列 $q$，满足 $\forall (u,v)\in G_1,(q_u,q_v)\in G_2,\forall (u,v)\notin G_1,(q_u,q_v)\notin G_2$。
## 输入格式

第一行，一个整数 $n$。

接下来 $n-1$ 行，每行两个整数 $u,v$，表示 $u,v$ 之间有一条边。
## 输出格式

共一行，$n$ 个整数，表示答案；或一个数 $-1$，表示无解。
## 样例

### 样例输入 #1
```
5
1 2
1 3
2 4
2 5
```
### 样例输出 #1
```
1 5 4 2 3
```
### 样例输入 #2
```
9
1 2
2 3
1 4
4 5
5 6
1 7
7 8
8 9
```
### 样例输出 #2
```
1 9 2 6 7 8 3 4 5
```
## 提示

对于 $100\%$ 的数据，$1\le u,v\le n\le 5\times 10^3$。

||分值|$n$|特殊性质|
|:-:|:-:|:-:|:-:|
|$\operatorname{Subtask}1$|$15$|$\le 8$|无|
|$\operatorname{Subtask}2$|$5$|无特殊限制|树退化为一条链|
|$\operatorname{Subtask}3$|$15$|无特殊限制|度数 $\ge 3$ 的节点个数 $\le 1$|
|$\operatorname{Subtask}4$|$20$|$\le 100$|无|
|$\operatorname{Subtask}5$|$20$|$\le 10^3$|无|
|$\operatorname{Subtask}6$|$25$|无特殊限制|无|

**说明：样例解释中的节点编号是 $p$ 中的下标。**

### 样例解释 1

$G_p$ 的形态如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/yawh0shj.png)

可以证明没有更优的方案。

### 样例解释 2

$G_p$ 的形态如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/o9vgydub.png)

可以证明没有更优的方案。


---

---
title: "[COCI 2021/2022 #1] Logičari"
layout: "post"
diff: 省选/NOI-
pid: P7929
tag: ['2021', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #1] Logičari
## 题目描述

给定一个 $n$ 个点的基环树，现在对基环树上的点染色，使得每个点都有且仅有一个与他相连的点（不包括它自身）被染色，求最少的染色点数，或者返回无解。
## 输入格式

第一行一个整数 $n$。

接下来 $n$ 行，一行两个整数 $u_i,v_i$，表示 $u_i$ 与 $v_i$ 间有一条边。
## 输出格式

输出最小的染色点数，或者返回无解，无解输出 `-1`。
## 样例

### 样例输入 #1
```
4
1 2
2 3
3 4
4 1
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
3
1 2
2 3
3 1
```
### 样例输出 #2
```
-1
```
### 样例输入 #3
```
7
1 2
2 3
3 4
4 5
5 6
6 7
2 4
```
### 样例输出 #3
```
4
```
## 提示

#### 样例解释
#### 样例 1 解释
可以在 $1,2$ 号点染色。

#### 样例 2 解释
如果有一个点被染色，则被染色的点不会有被染色的相邻的点。

如果有两个点被染色，则不被染色的点会有两个被染色的相邻的点。

#### 数据范围

对于全部数据，$3\le n\le 10^5$，$1\le u_i,v_i\le n$。

| Subtask |      特殊限制      | 分数 |
| :-----: | :----------------: | :--: |
|   $1$   | 每个点的点度为 $2$ | $10$ |
|   $2$   |     $n\le 20$      | $10$ |
|   $3$   |    $n\le 10^3$     | $40$ |
|   $4$   |     无特殊限制     | $50$ |


#### 说明
**本题总分 $110$ 分。**

本题译自 [Croatian Open Competition in Informatics 2021/2022](https://hsin.hr/coci/archive/2021_2012) [Contest #1](https://hsin.hr/coci/archive/2021_2022/contest1_tasks.pdf) T3 Logičari。


---

---
title: "[COCI 2021/2022 #1] Set"
layout: "post"
diff: 省选/NOI-
pid: P7930
tag: ['2021', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #1] Set
## 题目背景

在知名游戏 SET 中，存在着一些数字、形状、颜色等不同的卡片，玩家的目标是确定一个存在的 triplet of cards（即卡片的三元组，也就是三张卡片构成的组合），使其符合特定的要求。Marin 和 Josip 很快就对这个游戏感到无趣，并对其进行了加强。
## 题目描述

在本题中，定义每张卡片代表着一个仅由 $ 1, 2, 3 $ 构成的长度为 $ k $ 的序列，共有 $ n $ 张卡片，卡片之间是无序的。

定义一个 SET 表示，当且仅当一个无序的 triplet of cards 其中的三个序列的每一位均相同或各不相同，用原文中的话就是 same 或 pairwise different，更严谨地表示，我们令这三个序列为 $ S_i, S_j, S_k $，则一定满足如下条件：

* $ i \lt j \lt k $
* $ \forall x \in \left[1, k\right] $，满足 $ S_i(x) = S_j(x) = S_k(x) $ 或 $ S_i(x) \neq S_j(x) \neq S_k(x) $

例如 $ (1123, 1322, 1221) $ 便满足 $ 1, 3 $ 位均相同，$ 2,4 $ 位各不相同。

给你这些序列，求可以组成多少种本质不同的 SET。
## 输入格式

第一行为两个整数正整数 $ n, k $。

接下来 $ n $ 行中每一行包含一个仅由 $ 1, 2, 3 $ 构成的长度为 $ k $ 的序列，代表着一张卡片。

保证每张卡片上的序列不同。
## 输出格式

仅一行一个整数，表示可以组成的本质不同的 SET 的数量。
## 样例

### 样例输入 #1
```
3 4
1123
1322
1221

```
### 样例输出 #1
```
1

```
### 样例输入 #2
```
2 2
11
22

```
### 样例输出 #2
```
0

```
### 样例输入 #3
```
5 3
111
222
333
123
132

```
### 样例输出 #3
```
2

```
## 提示

**【样例解释 \#3】**

可以组成的两个 SET 分别为 $ (S_1, S_2, S_3) $ 和  $ (S_1, S_4, S_5) $。

**【数据范围】**

对于全部数据，$1\le k\le 12$，$1\le n\le 3^k$，$S_i$ 互不相同，$1\le S_i(x) \le 3$。

| Subtask |  特殊限制  | 分数 |
| :-----: | :--------: | :--: |
|   $1$   |  $k\le 5$  | $10$ |
|   $2$   |  $k\le 7$  | $30$ |
|   $3$   | 无特殊限制 | $70$ |

#### 说明
**本题总分 $110$ 分。**

本题译自 [Croatian Open Competition in Informatics 2021/2022](https://hsin.hr/coci/archive/2021_2012) [Contest #1](https://hsin.hr/coci/archive/2021_2022/contest1_tasks.pdf) T4 Set。


---

---
title: "[COCI 2021/2022 #1] Volontiranje"
layout: "post"
diff: 省选/NOI-
pid: P7931
tag: ['2021', 'Special Judge', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #1] Volontiranje
## 题目描述

给定一个 $1\sim n$ 的排列 $p$，请从这里面取出尽可能多的不交的上升子序列，且他们的长度为原排列的 LIS 的长度，并构造一组方案。
## 输入格式

第一行为一个整数 $n$。

接下来一行 $n$ 个整数 $p_i$。
## 输出格式

第一行请输出您选择的上升子序列个数与他们的长度。

接下来若干行，一行若干个整数，表示某个上升子序列的每个元素的下标。

您可以以任意顺序输出您选择的上升子序列。
## 样例

### 样例输入 #1
```
3
1 2 3
```
### 样例输出 #1
```
1 3
1 2 3
```
### 样例输入 #2
```
4
4 3 2 1
```
### 样例输出 #2
```
4 1
1
2
3
4
```
### 样例输入 #3
```
7
2 1 6 5 7 3 4
```
### 样例输出 #3
```
2 3
1 3 5
2 6 7
```
## 提示

#### 数据范围

对于全部数据，$1\le n\le 10^6$，$1\le p_i\le n$。

| Subtask |  数据范围   | 分值 |
| :-----: | :---------: | :--: |
|   $1$   |  $n\le 15$  | $10$ |
|   $2$   | $n\le 10^3$ | $40$ |
|   $3$   | 无特殊限制  | $60$ |

#### 说明
**本题总分 $110$ 分。**

本题译自 [Croatian Open Competition in Informatics 2021/2022](https://hsin.hr/coci/archive/2021_2022) [Contest #1](https://hsin.hr/coci/archive/2021_2022/contest1_tasks.pdf) T5 Volontiranje。

在附加文件中下发了一份 checker.cpp。


---

---
title: "「Wdcfr-1」Yet Another Cirno Game (hard version)"
layout: "post"
diff: 省选/NOI-
pid: P7946
tag: ['Special Judge', 'O2优化']
---
# 「Wdcfr-1」Yet Another Cirno Game (hard version)
## 题目描述

**The only difference between the two versions is whether you have to find a way to get the maximum points.**

Cirno drew a graph. This graph consists of $4\cdot n$ nodes, which are numbered $0$ through $4\cdot n - 1$. Also:

- For $0\le i\le 3$ and $0 \le j, k \lt n$, node $(n\cdot i + j)$ and node $(n\cdot i + k)$ are connected.
- For $0 \le i \le n$ and $0 \le j, k \le 3$, node $(i + n\cdot j)$ and node $(i + n\cdot k)$ are connected.

Cirno called Daiyousei to come and play with her.

The rules for this game are as follows:

- Firstly, Cirno chooses $2\cdot n$ (i.e. half) of the nodes, and she colors them blue. The rest are left red.
- Then there are $2\cdot n$ turns: for each turn Cirno first chooses a blue node, and Daiyousei chooses a red node. If those two nodes are connected, Daiyousei gets a point.

Try to maximize the number of points Daiyousei gets.
## 输入格式

In the first line, $n$ is provided.

In the second line, $n$ numbers follow: they are the nodes that Cirno chose.
## 输出格式

In the first line output $x$, which is the maximum number of points Daiyousei can get.

Then output $2\cdot n$ integers. For each node that Cirno chooses, output the corresponding node that Daiyousei responds with. Obviously the order of the chosen nodes doesn't matter. The solution must get the maximum number of points possible.
## 样例

### 样例输入 #1
```
3
0 1 2 3 4 5
```
### 样例输出 #1
```
6
6 7 8 9 10 11
```
## 提示

### Explanation

In the following picture, nodes in matrices are connected to each other. Cirno chose nodes $0,1,2,3,4,5$.

Arrows below show a possible way for Daiyousei to get the maximum number of points she can get.

![](https://cdn.luogu.com.cn/upload/image_hosting/7v3w2cz9.png)

### Constraints

$1\le n\le 2\times 10^6$.
## 题目翻译

**两个难度之间的唯一区别为是否需要输出对应的匹配方案**

给定 $4n$ 个点，点的编号从 $0$ 到 $4n-1$。每个点有两种属性 $x$ 和 $y$，编号为 $i$ 的点的属性为 $x_i=\left\lfloor\frac{i}{n}\right\rfloor,y_i=i-n\left\lfloor\frac{i}{n}\right\rfloor$。对于每两个点 $i,j(0\le i <j < 4n)$ 之间，若 $x_i=x_j$ 或 $y_i= y_j$，则这两点有一条无向边相连。现有其中 $2n$ 个不同的点被选择，试给每个被选择的点都匹配上另一个点，使得：

- 被匹配到的点未被选择；
- 每个点都只被匹配一次；
- 若每个点与其匹配的点之间有连边，那么记为一分，需要最大化分值。

请输出最大的分值**和对应的匹配方案**。


---

---
title: "[✗✓OI R1] 后方之水"
layout: "post"
diff: 省选/NOI-
pid: P7950
tag: ['O2优化']
---
# [✗✓OI R1] 后方之水
## 题目背景

这个题目没有背景，因为我是圣人的同时还是神之右席。
## 题目描述

定义一次石子合并的过程如下：有一排 $n$ 堆石子，每一堆有 $a_i(a_i\ge1)$ 个。每次你可以选择相邻的两堆石子合并，设个数分别为 $x,y$，则你会得到一堆 $(x+y)$ 个石子，同时你要付出 $xy$ 的代价。最后要把所有石子合并成一堆。记 $f(a_1,\ldots,a_n)$ 为合并这些石子的最小代价。

给出石子总数 $S$，求
$$ \sum_{\sum a_i=S}f(a_1,\ldots,a_n) $$
答案对 $998244353$ 取模。
## 输入格式

**本题有多组测试数据。**

第一行一个整数 $T$，表示测试数据的数量。  
接下来 $T$ 行，每行两个整数，分别为 $n,S$。
## 输出格式

$T$ 行，每行一个整数，表示答案对 $998244353$ 取模的结果。
## 样例

### 样例输入 #1
```
3
2 6
3 5
4 7
```
### 样例输出 #1
```
35
45
336
```
### 样例输入 #2
```
5
182565 710825096
429580 541341177
741770 757408347
461909 941427258
114514 1919810

```
### 样例输出 #2
```
487324711
256967112
352532743
962265551
926494516

```
## 提示

**【样例解释】**

对第一个样例的第一组数据解释：  
划分有 $(1,5),(2,4),(3,3),(4,2),(5,1)$，共 $5$ 种。  
答案为 $1\times 5 + 2 \times 4 + 3 \times 3 + 4 \times 2 + 5 \times 1 = 35$。

**【数据范围】**

| 测试点编号 |    $n$    |    $S$    
| :--------: | :-------: | :-------: | 
| 1,2 |  $\le15$  |  $\le15$  |
| 3,4 |  $\le40$  |  $\le40$  |
| 5,6,7 |  $\le70$  |  $\le70$  | 
| 8,9 | $\le200$  | $\le200$  | 
| 10,11 | $\le2000$ | $\le2000$ | 
| 12,13,14 | $\le10^6$ | $\le10^6$ | 
| 15 |   $=2$    | $\le10^9$ | 
| 16,17,18 | $\le2000$ | $\le10^9$ | 
| 19~25 | $\le10^6$ | $\le10^9$ |

对于 $100\%$ 的数据，有 $1\le T\le5$，$1\le n\le10^6$，$1\le S\le10^9$。

![](https://cdn.luogu.com.cn/upload/image_hosting/am5zu5e6.png)


---

---
title: "[✗✓OI R1] 右方之火"
layout: "post"
diff: 省选/NOI-
pid: P7951
tag: ['Special Judge', 'O2优化']
---
# [✗✓OI R1] 右方之火
## 题目背景

> 「区区二十亿，区区两千年，根本就不够。」  
> 「本大爷所拥有的力量可比你想象的还多哦。」

你打不过右方之火。    
但是为了证明你的想象力很丰富，你要做一道构造题。
## 题目描述

你有一个 $n$ 个点 $m$ 条边的无向连通图，每个点有一个初始权值 $a_i$ 以及一个目标权值 $b_i$。现在你可以对这张图进行这样的操作：
- 选择一个整数 $c$，需要满足 $|c| \le 10^{18}$；
- 选一条点数为 $3$，边数为 $2$ 的链；
- 使得中间点的权值减去 $2c$，另外两个点的权值各加上 $c$。 

问是否可以进行若干次操作使得最后每个点的权值都为 $b_i$。如果可以，你需要输出方案，操作次数不能超过 $4n$。

**注意 $c$ 可以为负数。**
## 输入格式

**本题有多组测试数据。**

第一行一个正整数 $T$ ，表示测试数据的数量。  
对于每组数据，第一行两个正整数 $n,m$，分别表示点数和边数。  
接下来两行，每行各 $n$ 个正整数，表示初始权值 $a_i$ 和目标权值 $b_i$。  
接下来 $m$ 行，每行两个整数 $u,v$，表示 $u$ 号点和 $v$ 号点之间有一条边，保证图连通，没有自环和重边。
## 输出格式

对于每组数据，第一行输出一个字符串，若能够从初始权值变为目标权值，输出 `Yes` ，否则输出 `No`。**输出 `Yes` 和 `No` 的这一行不要有其他奇怪的字符，不然可能会被 checker 判成错误。**    
第二行输出一个整数 $k(k\le4n)$，表示构造方案共有 $k$ 步。    
接下来 $k$ 行，每行四个整数 $x,y,z,c$ 满足 $1 \le x,y,z \le n$，$|c| \le 10^{18}$，$(x,y),(y,z)\in E$，表示 $a_x \gets a_x+c,a_y \gets a_y-2c,a_z \gets a_z+c$。

**本题采用 Special Judge。如果有多种答案，输出任意一种即可。**
## 样例

### 样例输入 #1
```
3
7 6
8 6 0 6 1 1 10 
5 6 2 9 1 2 7 
1 2
2 3
3 4
4 5
5 6
6 7
7 6
8 6 0 6 1 0 11 
5 6 2 9 1 2 7 
1 2
2 3
3 4
4 5
5 6
6 7
7 6
8 6 0 6 1 1 10 
5 6 2 9 1 2 6 
1 2
2 3
3 4
4 5
5 6
6 7
```
### 样例输出 #1
```
Yes
5
7 6 5 -3
6 5 4 -5
5 4 3 -7
4 3 2 -6
3 2 1 -3
No
No

```
### 样例输入 #2
```
2
6 6
10 -3 4 21 -2 11 
4 4 8 8 8 9 
1 2
2 3
3 4
4 5
5 6
6 1
6 6
10 -3 4 21 -2 11 
4 4 8 8 9 8 
1 2
2 3
3 4
4 5
5 6
6 1
```
### 样例输出 #2
```
Yes
6
6 1 2 6
1 2 3 1
2 3 4 3
3 4 5 9
4 5 6 2
5 6 1 5
No

```
### 样例输入 #3
```
1
6 9
7 5 68 16 2 45
42 11 42 17 14 17
1 3
1 4
1 6
1 5
1 2
2 5
2 3
4 6
5 6
```
### 样例输出 #3
```
Yes
10
1 4 6 1
1 6 4 -6
2 1 4 -9
1 3 2 -17
5 1 4 25
2 1 6 32
1 6 5 33
4 1 3 39
4 6 5 -46
3 1 6 -99

```
## 提示

**本题采用多组测试数据，子任务评测。**

对于 $100\%$ 的数据，满足 $1\le T \leq 5 \times 10^4$，$3 \le n \le 5 \times 10^5$，$n-1 \le m \le 5 \times 10^5$，$\sum n,\sum m \leq 5\times 10^5$，$|a_i|,|b_i| \leq 10^7$。

| subtask | $n,m,T$ | 特殊性质 | 分数
| :----------: | :----------: | :-----------: | :-----------: |
| 1 | $n,m\le 20$，$T \le 5$ | 无 | 10 |
| 2 | $m=n-1$ | 保证第 $i$ 条边连接 $i$ 和 $(i+1)$ 号点 | 5 |
| 3 | $m=n-1$ | 保证第 $i$ 条边连接 $1$ 和 $(i+1)$ 号点 | 5 |
| 4 | $m=n-1$ | 无 | 10 |
| 5 | $m=n$ | 保证图是一个环 | 10 |
| 6 | $n,m\le 200,T \le 5$ | 无 | 10 |
| 7 | $ n,m\le 2000,T \le 5$ | 无 | 20 |
| 8 |  | 无 | 30 |

**温馨提示：对于部分数据点 $T \le 5$ 因此数据比较难造，看到只 WA 了少数几个点并不代表你的算法没有问题，请仔细思考算法的正确性。**  

![](https://cdn.luogu.com.cn/upload/image_hosting/bznsetls.png)


---

---
title: "[✗✓OI R1] 天动万象"
layout: "post"
diff: 省选/NOI-
pid: P7952
tag: ['O2优化']
---
# [✗✓OI R1] 天动万象
## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/rxbh6s4b.png)
## 题目描述

帝君给了你一棵以 $1$ 为根的有根树，每个点有一个点权 $a_i$，要求支持以下几种操作：

+ $\texttt{1 u}$ 表示查询以 $u$ 为根的子树的最大值。
+ $\texttt{2 u}$ 表示将 $u$ 为根的子树内每一个节点的权值 **同时变为** 其所有 **儿子** 的权值之和，即对这棵子树执行 $\forall x \in \operatorname{subtree}(u), a_x\gets \sum_{y\in \operatorname{son}(x)}a_y$。其中 **同时变为** 的意思是「某个点操作时认为其儿子停留在这次操作未进行前的状态」。
## 输入格式

第一行两个正整数 $n,q$ 表示树的大小和询问组数。   
第二行 $n$ 个正整数，第 $i$ 个数表示表示第 $i$ 个点的初始点权 $a_i$。  
第三行 $(n-1)$ 个整数，其中第 $i$ 个整数 $\mathit{fa}_{i+1}$ 表示第 $(i+1)$ 个节点的父亲编号。  
接下来 $q$ 行，每行两个整数表示一次操作，具体格式见「题目描述」。
## 输出格式

对于每次 $\texttt{1}$ 操作输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
6 6
1 1 4 5 1 4
1 2 2 4 1
1 2
1 1
2 4
1 2
2 2
1 1
```
### 样例输出 #1
```
5
5
4
5
```
### 样例输入 #2
```
15 12
512902574 823918122 595349487 580400545 453562767 72015781 850655655 442513356 619194214 644523811 935104539 371670625 477236621 785497862 282980318 
1 2 2 1 2 6 2 2 4 9 6 4 12 1 
2 5
2 1
2 1
2 4
2 15
1 2
1 3
2 2
2 7
1 1
1 2
1 6
```
### 样例输出 #2
```
3279191251
0
2309473383
785497862
0

```
## 提示

**【样例解释】**  

修改前每个点的权值分别为 $1,1,4,5,1,4$。  
第一次修改后变为 $1,1,4,1,0,4$。   
第二次修改后变为 $1,5,0,0,0,4$。  

[更直观的图片](https://www.luogu.com.cn/paste/blqun4u8)

**【数据范围】**  

**本题数据量较大，请注意常数优化。**

对于 $100\%$ 的数据，满足 $1\le n, q \le 10^6$，$1 \le u \le n$，$0 \le a_i \le 10^9$，$\mathit{fa}_i < i$。

以下是子任务（留空则表示无特殊性质），你必须通过一个子任务中的所有测试点以及该子任务依赖的所有测试点，才能获得这个子任务的分数：

| 子任务编号 | $n, q$             | 子任务总分 | 特殊性质 | 依赖子任务 |
| :--------: | :----------------: | :------: | :------: | :--------: |
| 0   | $\le 5\times 10^3$ | 3        | E        |            |
| 1   | $\le 10^5$         | 6        | A, B     |            |
| 2   |                    | 8        | C        |            |
| 3   |                    | 4        | D        |            |
| 4   |                    | 13       | E        | Subtask0   |
| 5   |                    | 36       | B        | Subtask1   |
| 6   |                    | 30       |          | Subtask0~5 |


特殊性质：  

+ 对于满足特殊性质 A 的测试点，保证每次 $1$ 操作 $u=1$。  
+ 对于满足特殊性质 B 的测试点，保证每次 $2$ 操作 $u=1$。  
+ 对于满足特殊性质 C 的测试点，保证对于所有节点 $i$， 满足 $\mathit{fa}_i=i-1$，换句话说树的形态是一条链。  
+ 对于满足特殊性质 D 的测试点，保证对于所有节点 $i$， 满足 $\mathit{fa}_i=1$，换句话说树的形态是一个菊花。  
+ 对于满足特殊性质 E 的测试点，保证数据随机，这里的数据随机指 $\texttt{1}$ 操作和 $\texttt{2}$ 操作等概率出现，$u$ 在 $[1, n]$ 内等概率随机，$\mathit{fa}_i$ 在 $[1, i - 1]$ 内等概率随机。

**提示：由于出题人很懒而且洛谷传不了很多数据点，因此本题数据可能较弱，而且为了避免赛事评测机压力导致的运行时间增加，本题放宽了时限，因此欢迎大家尝试用奇怪的乱搞通过本题。**

> 只愿荡涤四方，护得浮世一隅。


---

---
title: "[COCI 2021/2022 #2] Osumnjičeni"
layout: "post"
diff: 省选/NOI-
pid: P7968
tag: ['2021', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #2] Osumnjičeni
## 题目描述

现有 $n$ 个嫌疑人。由于其身高的不确定性，只知道每个嫌疑人的身高范围 $[l_i,r_i]$。

每次调查可以选取编号范围为 $[a,b]$ 内的所有嫌疑人，要求他们的身高范围没有交集。若嫌疑人在某次调查中出现，则目击者可以立即作出正确的判断。

给定 $q$ 组询问，每次给出 $p_i,q_i$。求在嫌疑人锁定在 $[p_i,q_i]$ 范围内的前提下，最多需要进行多少次调查。
## 输入格式

第一行一个正整数 $n$，表示嫌疑人的数量。

接下来的 $n$ 行，每行两个正整数 $l_i,r_i$，表示第 $i$ 个嫌疑人的身高范围。

接下来的一行，一个正整数 $q$，表示询问组数。

接下来的 $q$ 行，每行两个正整数 $p_i,q_i$，表示一组询问。
## 输出格式

共 $q$ 行，表示每组询问的答案。
## 样例

### 样例输入 #1
```
2
1 1
1 1
3
1 1
2 2
1 2
```
### 样例输出 #1
```
1
1
2
```
### 样例输入 #2
```
3
1 1
2 2
3 3
3
1 1
2 3
1 3
```
### 样例输出 #2
```
1
1
1
```
### 样例输入 #3
```
5
1 3
3 3
4 6
2 3
1 1
3
1 4
3 5
1 5
```
### 样例输出 #3
```
3
1
3
```
## 提示

**【样例 3 解释】**

- 询问 $1,3$：在 $[1,1],[2,3],[4,5]$ 范围内进行调查即可，答案为 $3$。
- 询问 $2$：调查 $[3,5]$ 即可，答案为 $1$。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：$q=p_1=1$，$q_1=n$。
- Subtask 2（10 pts）：$1 \le n,q \le 5000$。
- Subtask 3（20 pts）：$1 \le n \le 5000$。
- Subtask 4（20 pts）：$1 \le q \le 100$。
- Subtask 5（50 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,q \le 2 \times 10^5$，$1 \le a \le b \le n$，$1 \le l_i \le r_i \le 10^9$，$1 \le p_i \le q_i \le n$。

**【提示与说明】**

**题目译自 [COCI 2021-2022](https://hsin.hr/coci/) [CONTEST #2](https://hsin.hr/coci/contest2_tasks.pdf) _Task 5 Osumnjičeni_。**

**本题分值按 COCI 原题设置，满分 $110$。**


---

---
title: "[COCI 2016/2017 #5] Strelice"
layout: "post"
diff: 省选/NOI-
pid: P8018
tag: ['2016', 'COCI（克罗地亚）']
---
# [COCI 2016/2017 #5] Strelice
## 题目描述

Hansel 和 Gretel 正在玩「箭头游戏」。

该游戏在一个 $R$ 行 $S$ 列的棋盘上进行。其中每一个棋格内有一个箭头（$\leftarrow$、$\rightarrow$、$\uparrow$、$\downarrow$ 之一）。

游戏开始后，Hansel 可以选择任意 $K$ 个**不位于最后一列的**棋格进行填涂。接着，Gretel 可以选择**第一列的**任意一个棋格，作为机器人的初始棋格。机器人在放置到初始棋格后将按照箭头的指示自动行走。机器人一旦走到了最后一列，它将立即停止行走。

判定输赢的方式如下：

- 如果机器人在有限的时间内停在了最后一列，那么：当且仅当机器人恰好经过一个有色棋格时，判定 Hansel 获胜，否则 Gretel 获胜。
- 如果机器人无法停止行走（即处于无限循环的状态），那么判定 Hansel 获胜。

规定机器人经过的棋格包括初始棋格、终止棋格以及路径上的其它所有棋格。同时，数据保证箭头不会指向棋盘外部。

你的任务是判断 Hansel 是否有必胜的方案（即对于 Gretel 所选择的任意一个合法的初始棋格，Hansel 的填涂方案都可以使自己获胜）。如果有必胜的方案，输出该方案；否则输出 $-1$。
## 输入格式

第一行，三个整数 $R,S,K$。

接下来的 $R$ 行，每行 $S$ 个字符 $\texttt L$、$\texttt U$、$\texttt R$ 或 $\texttt D$，分别表示对应棋格内的箭头为 $\leftarrow$、$\rightarrow$、$\uparrow$ 和 $\downarrow$。
## 输出格式

如果没有必胜的方案，输出 $-1$。

否则输出 $K$ 行，每行两个整数 $A,B$，表示选择的 $K$ 个将要涂色的棋格。棋格必须互不相同。如果存在多种方案，请输出任意一种。

Special Judge 对输出格式要求较严，因此**请勿在每行行尾添加多余空格。**
## 样例

### 样例输入 #1
```
4 3 1
DRD
DUD
DUD
RUL
```
### 样例输出 #1
```
4 2
```
### 样例输入 #2
```
3 3 2
RRR
RRR
RRR
```
### 样例输出 #2
```
-1
```
### 样例输入 #3
```
4 4 2
RRDL
RRDL
DLRD
RRRL
```
### 样例输出 #3
```
2 3
4 1
```
## 提示

**【样例 1 解释】**

填涂 $(4,2)$ 后，无论初始棋格位于第一列的哪里，机器人都会经过 $(4,2)$。

**【样例 2 解释】**

由于需要填涂 $2$ 个棋格，因此至少有一行没有有色棋格。只要 Gretel 选择没有有色棋格的那一行的第一列放置机器人，Gretel 就会获胜。

**【样例 3 图解】**

![](https://cdn.luogu.com.cn/upload/image_hosting/oy6p59p5.png?x-oss-process=image/resize,m_lfit,h_200)

**【数据规模与约定】**

对于 $100\%$ 的数据，$1 \le R \times S \le 10^6$，$1 \le K \le 50$，$1 \le A \le R$，$1 \le B \lt S$。

**【提示与说明】**

欢迎大家通过私信或发帖对自行编写的 [Special Judge](https://www.luogu.com.cn/paste/k9jt7zoy) 进行 hack。

**题目译自 [COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST #5](https://hsin.hr/coci/archive/2016_2017/contest5_tasks.pdf) _T6 Strelice_。**

**本题分值按 COCI 原题设置，满分 $160$。**


---

---
title: "[COCI 2021/2022 #3] Akcija"
layout: "post"
diff: 省选/NOI-
pid: P8029
tag: ['2021', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #3] Akcija
## 题目描述

给定 $n$ 个商品，每个商品有一个价格 $w_i$ 和一个截止期 $d_i$，其中 $d_i$ 表示第 $i$ 个商品必须在第 $d_i$ 分钟之前完成购买。每次购买一个商品均需花费 $1$ 分钟进行下单，在下单之后才视为购买成功。

现可从这 $n$ 个商品中选择若干个（包括 $0$ 个）进行购买（每个商品最多购买一次），视为一种购买方案。

当一种购买方案内的商品数量大于另一种方案时，规定前者更优；当一种购买方案的商品数量与另一种相同且前者的总价格更低时，规定前者更优。求所有符合题意的购买方案中，第 $1 \sim k$ 优的方案的商品数量和总价格各是多少。
## 输入格式

第一行，两个正整数 $n,k$。数据保证 $k$ 不大于符合题意的方案总数。

接下来的 $n$ 行，每行两个正整数 $w_i,d_i$。
## 输出格式

输出共 $k$ 行，其中第 $i$ 行为第 $i$ 优方案的商品数量和总价格。
## 样例

### 样例输入 #1
```
3 1
1 1
1 1
1 3
```
### 样例输出 #1
```
2 2
```
### 样例输入 #2
```
4 3
1 1
10 1
2 3
10 3
```
### 样例输出 #2
```
3 13
3 22
2 3
```
### 样例输入 #3
```
2 4
1 1
2 2
```
### 样例输出 #3
```
2 3
1 1
1 2
0 0
```
## 提示

**【样例 2 解释】**

前 $k$ 优的方案为 $\{1,3,4\}$、$\{2,3,4\}$ 和 $\{1,3\}$（用商品编号代替对应商品）。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：$k=1$，$w_1=\cdots=w_n$。
- Subtask 2（20 pts）：$k=1$。
- Subtask 3（20 pts）：$k=2$。
- Subtask 4（10 pts）：$1 \le n \le 20$。
- Subtask 5（30 pts）：$1 \le n,k \le 100$。
- Subtask 6（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n,k \le 2000$，$1 \le w_i \le 10^9$，$1 \le d_i \le n$。

**【提示与说明】**

官方数据每个子任务有 $13$ 个测试点，所需总时限高达 $6.5$ 分钟。为了减少评测机负担，这里每个子任务只选取前两个测试点进行评测。

**题目译自 [COCI 2021-2022](https://hsin.hr/coci/) [CONTEST #3](https://hsin.hr/coci/contest3_tasks.pdf) _Task 3 Akcija_。**

**本题分值按 COCI 原题设置，满分 $110$。**


---

---
title: "[COCI 2015/2016 #7] Prokletnik"
layout: "post"
diff: 省选/NOI-
pid: P8037
tag: ['2015', 'COCI（克罗地亚）']
---
# [COCI 2015/2016 #7] Prokletnik
## 题目描述

定义魔法序列为满足所有元素的大小均在第一个元素和最后一个元素之间的序列。

现有一个元素个数为 $N$ 的数组 $a$。给出 $Q$ 次询问 $L,R$，求 $a$ 中下标在 $[L,R]$ 之间的最长的子魔法区间。
## 输入格式

第一行，一个整数 $N$。

第二行，$N$ 个整数 $a_i$。

第三行，一个整数 $Q$。

接下来的 $Q$ 行，每行两个整数 $L,R$。
## 输出格式

输出 $Q$ 行，每行对应一次询问的答案。
## 样例

### 样例输入 #1
```
5
5 4 3 3 2
3
1 2
1 1
2 4
```
### 样例输出 #1
```
2
1
3
```
### 样例输入 #2
```
6
6 6 5 1 6 2
3
4 5
4 6
1 4
```
### 样例输出 #2
```
2
2
4
```
## 提示

**【数据规模与约定】**

- 对于 $50\%$ 的数据，$N,Q \le 3 \times 10^4$。
- 对于 $100\%$ 的数据，$1 \le N,Q \le 5 \times 10^5$，$1 \le a_i \le 10^9$，$1 \le L \le R \le N$。

**【提示与说明】**

**题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [#7](https://hsin.hr/coci/archive/2015_2016/contest7_tasks.pdf) _Task 6 Prokletnik_。**

**本题分值按 COCI 原题设置，满分 $160$。**


---

---
title: "[COCI 2016/2017 #7] KLAVIR"
layout: "post"
diff: 省选/NOI-
pid: P8043
tag: ['2016', 'COCI（克罗地亚）']
---
# [COCI 2016/2017 #7] KLAVIR
## 题目描述

年轻的 Alisa 喜欢只用一根手指弹钢琴。但是，由于 Alisa 从来都没学过弹钢琴，因此她的弹琴过程完全是随机的。更准确地说，她会**等概率**选择钢琴的 $N$ 个音调上的任意一个，并且**独立于之前所有选择的音调**。

Alisa 的好朋友 Mirta 想要听一个连续的包含 $M$ 个音调 $A_1,A_2,\dots,A_M$ 的曲子，但由于 Alisa 弹琴过程是完全随机的，Mirta 只想知道，对于所有的 $1\leqslant i\leqslant M$，Alisa 选择音调使 Mirta 第一次听到连续的音调 $A_1,A_2,\dots,A_i$ 的**期望次数**。为了防止精度丢失，**答案对 $\bf 10^9+7$ 取模**。
## 输入格式

第一行输入一个整数 $N$，表示音调个数。  
第二行输入一个整数 $M$，表示 Mirta 想要听的曲子包含的音调个数。  
随后 $M$ 行，每行一个整数 $A_i$，表示曲子的第 $i$ 个音调。
## 输出格式

输出 $M$ 行，每行一个正整数，第 $i$ 行表示 Alisa 选择音调使 Mirta 第一次听到连续的音调 $A_1,A_2,\dots,A_i$ 的期望次数对 $\bf 10^9+7$ 取模之后的结果。
## 样例

### 样例输入 #1
```
2
2
1 2
```
### 样例输出 #1
```
2
4
```
### 样例输入 #2
```
2
2
1 1
```
### 样例输出 #2
```
2
6
```
### 样例输入 #3
```
3
3
1 2 3
```
### 样例输出 #3
```
3
9
27
```
## 提示

**【数据范围】**

对于 $40\%$ 的数据，保证 $1\leqslant M\leqslant 200$。  
对于所有数据，$1\leqslant N\leqslant 100$，$1\leqslant M\leqslant 10^6$，$1\leqslant A_i\leqslant N$。

**【题目来源】**

本题来源自 **_[COCI 2016-2017](https://hsin.hr/coci/archive/2016_2017/) [CONTEST 7](https://hsin.hr/coci/archive/2016_2017/contest7_tasks.pdf) T6 KLAVIR_**，按照原题数据配置，满分 $160$ 分。

由 [Eason_AC](https://www.luogu.com.cn/user/112917) 翻译整理提供。


---

---
title: "D ToPTree"
layout: "post"
diff: 省选/NOI-
pid: P8057
tag: ['O2优化', '洛谷月赛']
---
# D ToPTree
## 题目背景

ToPTree 即 **To**oth**P**aste **Tree**，它的工作方式就如同挤牙膏——挤一下它才动一下。
## 题目描述

你有 $n$ 个数组成的序列 $[a_1\sim a_n]$，初始时 $a_i=0$。

有 $q$ 次操作组成的操作序列 $A$，第 $i$ 次操作在所有可能的 $nN(n+1)$ 种操作之内均匀随机：

- 在以下两种操作之中以一半的概率随机选择一种操作，作为这次操作。
- 随机选取满足条件的正整数 $l,r,x\ (1\le l\le r\le n,1\le x\le N)$，把 $[l,r]$ 区间内的数加上 $x$。
- 随机选取满足条件的正整数 $l,r,x\ (1\le l\le r\le n,1\le x\le N)$，把 $[l,r]$ 区间内的数改为 $x$。
- 容易发现每次操作共有 $nN(n+1)$ 种可能。

由于这棵树是 ToothPaste Tree，只有在你询问的时候，它才会执行与你这次询问有关且还没执行的操作。具体地，假设你依次询问了 $a_{p_1\sim p_m}$ 的值，则

- 询问 $a_{p_i}$ 时，把所有 $A$ 中与这个数有关的操作（即这次操作的 $[l,r]$ 包含 $p_i$）按时间顺序（即按 $A$ 中的顺序）执行了，并从 $A$ 中删除它们。然后输出 $a_{p_i}$ 当前的值。

> 比如 $A$ 中目前按顺序有以下四个操作，且 $a$ 中所有元素目前都是 $0$：
> 
> 1. 给区间 $[2,3]$ 加一。
> 2. 给区间 $[3,4]$ 加一。
> 3. 把区间 $[2,4]$ 赋值为一。
> 4. 给区间 $[2,3]$ 加一。
> 
> 现在询问了 $a_2$ 的值，那么操作 $1,3,4$ 会被顺序执行，导致 $a_1\sim a_4$ 分别变为 $[0,2,2,1]$。因此 ToPTree 输出 $2$。操作序列变为：
> 
> 1. 给区间 $[3,4]$ 加一。
> 
> 再询问 $a_3$ 的值，操作 $1$ 会被执行，导致操作序列变为空，并且 $a_1\sim a_4$ 变为 $[0,2,3,2]$，故输出 $3$。注意这个输出结果与按照顺序执行所有操作 $1\sim 4$ 得到的结果并不一致。

给定 $n,m,q,N$ 以及序列 $p$，ToPTree 一共会按询问顺序输出 $m$ 个值，求这 $m$ 次输出分别的期望，对 $998244353$ 取模。

（第一次询问之前，没有任何操作被执行了。）


## 输入格式

第一行四个正整数 $n,m,q,N$。

接下来一行 $m$ 个正整数 $p_1\sim p_m$。
## 输出格式

输出一行 $m$ 个非负整数，用空格隔开，为答案，对 $998244353$ 取模。
## 样例

### 样例输入 #1
```
2 2 2 2
1 1
```
### 样例输出 #1
```
665496237 665496237
```
## 提示

**【数据范围】**

**本题采用捆绑测试。**

对于所有数据：$1\le n,N,q\le 9\times 10^8$，$1\le m\le 10^6$，$1\le p_i\le n$。详细数据范围如下：

- Subtask #1 (4 pts): $n,m,q,N\le 3$。
- Subtask #2 (10 pts): $n,m,q,N\le 5$。
- Subtask #3 (3 pts): $n=1$，$m,q\le 123456$。
- Subtask #4 (3 pts): $q=1$，$m\le 123456$。
- Subtask #5 (12 pts): $m=1$，$q\le 123456$。
- Subtask #6 (27 pts): $n,m,q,N\le 50$。
- Subtask #7 (9 pts): $m,q\le 5000$。
- Subtask #8 (16 pts): $m,q\le 123456$。
- Subtask #9 (16 pts): 没有任何附加限制。



---

---
title: "[BalticOI 2002] L Game © Edward de Bono (Day2)"
layout: "post"
diff: 省选/NOI-
pid: P8069
tag: ['2002', 'Special Judge', 'BalticOI（波罗的海）']
---
# [BalticOI 2002] L Game © Edward de Bono (Day2)
## 题目描述

L 棋是一种双人棋类游戏，在 $4 \times 4$ 的正方形棋盘上进行。

共有两种棋子：
- L 形棋：大小为 $4$，双方各有一枚；
- 中性棋：大小为 $1$，共两枚，中立。

任意时刻，棋盘上任意格子上方应至多有一枚棋子。

双方轮流操作。一次合法的操作是：先移动己方 L 形棋至一个合法的与当前位置不同的位置，再移动至多一枚中性棋。

无法进行合法操作者败。

![](https://cdn.luogu.com.cn/upload/image_hosting/pmca33zr.png)

记标有网格的 L 形棋操作者为 A，标有斜线者为 B。

若处于上图三种局面之一且 A 先手，则能且仅能将己方 L 形棋移至另外两种局面。此后，A 可以将中性棋之一移至某空格子，或不移动中性棋。故 A 共有 $2 \times (6 + 6 + 1)$ 种操作方案。

若处于下图局面且 A 先手，则 A 由于无法移动其 L 形棋而败，B 胜。

![](https://cdn.luogu.com.cn/upload/image_hosting/9j9uia3u.png)

「妙棋」指：先手进行后存在必胜策略的操作。「败局」指：先手无论如何操作，后手都存在必胜策略的局面。「和棋」指：先手不存在妙棋且不为败局的局面。

尽管棋盘很小，但 L 棋存在超过 $18 \thinspace 000$ 种可能的局面；且在同一时刻先手可能存在多达 $195$ 种操作方案，但其中仅有一种妙棋。

对于给定局面，找到一步妙棋，或判定该局面为败局或和棋。若存在多种妙棋，输出任意一种即可。
## 输入格式

四行，每行四个字符，表示棋局。

- `#` 表示先手棋子所在位置；
- `*` 表示后手棋子所在位置；
- `x` 表示中性棋子所在位置；
- `.` 表示空格子。
## 输出格式

- 若存在妙棋，则输出移动后的局面，格式同输入格式。注意 `#` 依然表示操作前的先手，`*` 同理。

- 否则第一行一个字符串 `No winning move`。
  - 若为和棋，则第二行输出一个字符串 `Draw`；
  - 若为败局，则第二行输出一个字符串 `Losing`。

注意：虽然 Special Judge 忽略行末回车与文末换行，但请不要输出多于 $64$ 个字符，否则会被判为 Wrong Answer。
## 样例

### 样例输入 #1
```
.*** 
#*.x 
###. 
x... 
```
### 样例输出 #1
```
.*** 
x*#x 
###. 
.... 
```
### 样例输入 #2
```
...x 
###. 
#*** 
x..* 
```
### 样例输出 #2
```
No winning move 
Draw 
```
### 样例输入 #3
```
.### 
x#*x 
***. 
.... 
```
### 样例输出 #3
```
No winning move 
Losing 
```
## 提示

#### 数据范围

保证给出局面合法。

#### 提示

[BalticOI](https://boi.cses.fi/contests.php) 2002 Day2 B.

你能在不存在妙棋的测试点得分，当且仅当你通过了至少一半存在妙棋的测试点。（注：原题面中为至少一个，但这里取原题解中说法即「一半」。）

由于自定义计分脚本参数配置，暂不支持 AC WA TLE MLE 外的评测状态显示。如果你得到了此外任何一种评测状态，你将得到 UKE。

Subtask #0 为样例；Subtask #1 为数据。


---

---
title: "[BalticOI 2021] The short shank (Day2)"
layout: "post"
diff: 省选/NOI-
pid: P8125
tag: ['2021', 'BalticOI（波罗的海）']
---
# [BalticOI 2021] The short shank (Day2)
## 题目描述

你入狱了，你现在正在洛谷第一监狱里。

监狱共有 $N$ 个牢房，从左到右编号为 $1 \sim N$。你和你的狱友们准备策划一场造反，第 $i$ 个牢房里的罪犯准备在第 $t_i$ 个时刻点造反，如果第 $i$ 个牢房的罪犯造反后，第 $i+1$ 个牢房的罪犯会无视他在第 $t_{i+1}$ 个时间点造反的规矩，在第 $t_i+1$ 个时间点就会造反。

狱警提前预知了一切，所以他们会放置 $D$ 个床垫，如果在第 $i$ 个牢房和第 $i+1$ 个牢房中间放置一个床垫，那么当第 $i$ 个牢房的罪犯造反时，第 $i+1$ 个牢房的罪犯不会立即造反，而会等到第 $t_{i+1}$ 个时间点。

你想知道，狱警合理安排床垫后，在第 $T$ 个时间点及以前最少会有多少个罪犯造反。
## 输入格式

第一行三个整数 $N,D,T$ 代表罪犯个数，床垫个数和希望的时间点。

第二行 $N$ 个整数 $t_i$ 代表第 $i$ 个罪犯造反的时间点。
## 输出格式

一行一个整数代表答案。
## 样例

### 样例输入 #1
```
5 1 42
13 37 47 11 42
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
5 2 5
1 9 4 6 7
```
### 样例输出 #2
```
2
```
## 提示

#### 样例 1 解释

最优解是在第 $2$ 个牢房和第 $3$ 个牢房之间放入床垫，造反的是第 $1,2,4,5$ 个牢房里的罪犯。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（15 pts）：$N \le 500$。
- Subtask 2（10 pts）：$N \le 5 \times 10^5$，$D=1$。
- Subtask 3（20 pts）：$N \le 4000$。
- Subtask 4（10 pts）：$N \le 7.5 \times 10^4$，$D \le 15$。
- Subtask 5（25 pts）：$N \le 7.5 \times 10^4$。
- Subtask 6（20 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le D<N \le 2 \times 10^6$，$1 \le T,t_i \le 10^9$。

另有 Subtask 0 为样例。

#### 说明

翻译自 [BalticOI 2021 Day2 A The short shank](https://boi.cses.fi/files/boi2021_day2.pdf)。


---

---
title: "[BalticOI 2021] The Collection Game (Day2)"
layout: "post"
diff: 省选/NOI-
pid: P8126
tag: ['2021', '交互题', 'Special Judge', 'BalticOI（波罗的海）']
---
# [BalticOI 2021] The Collection Game (Day2)
## 题目背景

**本题是交互题。**

你的代码不需要也不应该包含 `swaps.h` 头文件，但应包含以下声明：

```cpp
extern "C" void schedule(int i, int j);
extern "C" std::vector<int> visit();
extern "C" void answer(std::vector<int> r);
extern "C" void solve(int N, int Q) {
  // Code Here
}
```
## 题目描述

您要参观博物馆的 $N$ 个展馆，因为您之前有入狱史（BalticOI 2021 Day2 A），所以博物馆官方仅允许您参观小于等于 $V$ 次。每一次参观您可以浏览多次，每一次浏览您可以浏览 **一对** 展馆 $(i,j)$，然后您就可以得知这两个展馆哪个展馆的艺术价值最高。为了不浪费您的时间，每一次参观每个展馆只能浏览最多一次。

不幸的是，因为您的入狱史，博物馆 **可能** 会交换您要浏览的一对展馆里的展品，这样您得到的艺术价值关系就是反过来的，您最后对这 $N$ 个展馆中的其中一个的排名也应基于 **最后一次** 对这个展馆的浏览。

现在请通过浏览来确定这 $N$ 个展馆的艺术价值的排列。

### 交互格式

您需要实现函数 `void solve (int N, int V)`，其中 $N $ 和 $V$ 为展馆数量和最多参观次数。

`solve` 函数只被调用一次，并且可以在 `solve` 函数里面调用：

- `void schedule (int i, int j)` 浏览一对展馆 $(i,j)$，博物馆有可能交换展品。
- `vector <int> visit ()` 整理浏览结果，返回的序列按照浏览的展馆对数 $(i,j)$ 顺序返回若干个 $k$，如果第 $i$ 个展馆的艺术价值高于第 $j$ 个展馆，$k=1$，否则 $k=0$。
- `void answer (vector <int> r)` $r$ 是一个长度为 $N$ 的序列，并且是一个 $1 \sim N$ 的排列，$r_i=p$ 代表第 $i$ 个展馆在这 $N$ 个展馆的艺术价值排序中排第 $p$ 个。

如果您函数的调用不满足要求，一次参观一个展馆浏览了超过 $1$ 次，或者参观了超过 $V$ 次，您的程序都会立即停止然后判为 `Not correct`。请不要在标准输出中输出任何东西，否则会被判为 `Security violation!`。

如果您使用 C++ 编码，请调用 swaps.h 头文件，如果您想检验您的程序的正确性，可以在下方附件中下载 sample_grader.cpp 与 swaps_sample.cpp，分别为您提供检验正确性和示例说明的作用。

如果您使用 Python 编码，可以在下方附件中下载 swaps_sample.py 检验。

交互库希望标准输入里有一行：

- 一行两个整数 $N,V$。

随后，交互库会调用您的程序，最后，交互库会在标准输出中返回信息：

|信息|意义|
|:-:|:-:|
|**Invalid input.**|标准输入的格式错误|
|**Invalid schedule.**|`schedule` 函数调用无效|
|**Out of visits.**|`visit` 函数调用超过 $V$ 次|
|**Invalid answer.**|`answer` 函数调用无效|
|**Wrong answer.**|`answer` 函数调用的 $r$ 错误|
|**No answer.**|`solve` 函数没有调用 `answer` 函数|
|**Correct: v visit(s) used.**|上述事件都没有发生，调用了 $V$ 次 `visit` 函数|

针对上面若干个错误的情况，交互库仅会返回 **Not correct**，或者正确的时候返回 **Correct**。每当出现上面的若干个错误，或者您的程序调用了 `answer` 函数时，程序会被自动停止。
## 输入格式

见「交互格式」。
## 输出格式

见「交互格式」。
## 样例

### 样例输入 #1
```
4 50
```
### 样例输出 #1
```

```
## 提示

#### 样例 1 解释

$N=4$，$V=50$，下面是一种合法的调用：

|你的程序|返回值|博物馆是否交换
|:-:|:-:|:-:|
|`schedule(1,2)`|-|否|
|`schedule(3,4)`|-|是|
|`visit()`|`{1,0}`|-|
|`schedule(2,4)`|-|否|
|`visit()`|`{1}`|-|
|`answer({1,2,4,3})`|-|-|

对于上表，$r=\{2,1,4,3\}$ 也满足要求。如果第三次 `visit` 交换了，那么 $r=\{4,1,2,3\}$ 满足要求。

#### 数据规模与约定

**本题采用捆绑测试。**

- Subtask 1（5 pts）：$V=5000$，博物馆永远不会交换展品。
- Subtask 2（10 pts）：$V \ge 1000$，博物馆永远不会交换展品。
- Subtask 3（5 pts）：$N \le 100$，$V=5000$。
- Subtask 4（15 pts）：$V=5000$。
- Subtask 5（15 pts）：$V\ge 500$。
- Subtask 6（35 pts）：$V \ge 100$。
- Subtask 7（15 pts）：$V \ge 50$。

对于 $100\%$ 的数据，$1 \le N \le 500$，$50 \le V \le 5000$。

#### 说明

翻译自 [BalticOI 2021 Day2 B The Collection Game](https://boi.cses.fi/files/boi2021_day2.pdf)。


---

---
title: "[ICPC 2020 WF] Ley Lines"
layout: "post"
diff: 省选/NOI-
pid: P8133
tag: ['2020', 'O2优化', 'ICPC']
---
# [ICPC 2020 WF] Ley Lines
## 题目背景

ICPC2020 WF F
## 题目描述

In 1921, the amateur archaeologist Alfred Watkins coined the term
"ley lines" to refer to straight lines between numerous places of
geographical and historical interest. These lines have often been
associated with mysterious and mystical theories, many of which still
persist.

One of the common criticisms of ley lines is that lines one draws on a
map are actually of non-zero width, and finding "lines" that connect
multiple places is trivial, given a sufficient density of points and a
sufficiently thick pencil. In this problem you will explore that
criticism.

For simplicity, we will ignore the curvature of the earth, and just assume
we are dealing with a set of points on a plane, each of which has a
unique $(x, y)$ coordinate, and no three of which lie on a single
straight line. Given such a set, and the thickness of your pencil,
what is the largest number of points through which you can draw a
single line?
## 输入格式

The first line of input consists of two integers $n$ and $t$, where
$n$ ($3 \le n \le 3\,000$) is the number of points in the set
and $t$ ($0 \le t \le 10^9$) is the thickness of the pencil.
Then follow $n$ lines,
each containing two integers $x$ and $y$ ($-10^9 \le x, y \le 10^9$),
indicating the coordinates of a point in the set.

You may assume that the input is such that the answer would not change
if the thickness $t$ was increased or decreased by $10^{-2}$, and that no
three input points are collinear.
## 输出格式

Output the maximum number of points that lie on a single "line" of
thickness $t$.
## 样例

### 样例输入 #1
```
4 2
0 0
2 4
4 9
3 1
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
3 1
0 10
2000 10
1000 12
```
### 样例输出 #2
```
2
```
## 题目翻译

1921 年，业余考古学家 Alfred Watkins 提出了 _Ley lines_ 的概念，指的是连接众多地理和历史名胜的直线。这些线常常与神秘的理论联系在一起，其中许多至今仍在流传。

对 _Ley lines_ 的一个常见争议是，人们在地图上绘制的线的宽度实际上并非为 $0$，考虑到足够密集的点和足够宽的铅笔，找到连接多个地方的“线”是很容易的。为了探讨这种争议，你决定亲自在一个二维平面上亲自实践。

现在，这个二维平面上有 $n$ 个点，第 $i$ 个点的坐标为 $(x_i,y_i)$，并且没有三个点在同一条直线上。你有一个宽度为 $t$ 的铅笔，你想知道你用这支铅笔画一条线，最多能够连接多少个不同的点。你可以假设在 $t$ 增加或减少 $10^{-2}$ 的情况下，答案是不会改变的。

数据范围：

- $3\leqslant n\leqslant 3000$，$0\leqslant t\leqslant 10^9$。
- $-10^9\leqslant x_i,y_i\leqslant 10^9$。

Translated by Eason_AC


---

---
title: "[ICPC 2020 WF] Quests"
layout: "post"
diff: 省选/NOI-
pid: P8136
tag: ['2020', 'O2优化', 'ICPC']
---
# [ICPC 2020 WF] Quests
## 题目背景

ICPC2020 WF I
## 题目描述

To relax before competing in the ICPC World Finals, you have decided to play a
computer game called *Quests*. You have played it a
number of times already, and now you want to achieve a perfect
playthrough---to prepare for your perfect playthrough of the finals!

In the game, you have to complete a number
of quests, and you earn experience points (XPs) for completing each one. The
total number of XPs you have earned at any time determines your current level. You
reach a new level for every $v$ XPs that you earn. Formally, your level at
any time is the largest integer $L$ such that you have at least $L \cdot v$
XPs.

Each quest is assigned a number $x$ of XPs and a target
difficulty level $d$. If you complete the quest when your level is at least
$d$, you earn $x$ XPs. However, if you complete the quest when your level is
less than $d$, you will earn $c \cdot x$ XPs. The constant  $c$ is an XP multiplier
that results in a bonus for completing a
quest when you are at a lower level than the recommended level $d$.

You know all the $n$ quests and their respective $x$ and $d$ numbers by heart
(and you know the numbers $v$ and $c$ as well---you have played this game a lot).
You are also skilled enough to
complete any quest, regardless of its target difficulty level and your level.
You want to complete all the quests in an order that will allow you
to earn the largest possible number of XPs.

For example in the sample input, the maximum XPs you can earn is 43, which
is done as follows. First complete the second quest (you earn $4$ XPs,
because you are at level $0$, and you completed a quest with target difficulty
level $2$). Then complete the first quest (you earn $30$ XPs, because you are
still at level $0$, and the target difficulty level is $1$). With $34$ XPs, you
are now level $3$. Finally, complete the third quest (for which you earn $9$
XPs, without the multiplier, since you are already at level $3$).
## 输入格式

The first line of input contains three integers $n$, $v$, and $c$, where
$n$ $(1 \leq n \leq 2\,000)$ is the number of quests in the game, $v$
$(1 \leq v \leq 2\,000)$ is the number of XPs required to reach each level,
and $c$ $(2 \leq c \leq 2\,000)$ is the XP multiplier for completing a quest
before reaching its target difficulty level.

Following that are $n$ lines, each of which contains two integers $x$ and $d$
describing one quest, where $x$ $(1 \leq x \leq 2\,000)$ is the number of XPs
you earn for completing that quest if you are at or above its target difficulty
level and $d$ $(1 \leq d_i \leq 10^6)$ is the target difficulty level for that
quest.
## 输出格式

Output the maximum possible number of XPs you could earn by finishing all the
quests.
## 样例

### 样例输入 #1
```
3 10 2
15 1
2 2
9 1
```
### 样例输出 #1
```
43
```
## 题目翻译

为了在 ICPC 之前放松，小 A 决定玩一个名叫 _Quests_ 的游戏。你之前已经玩了很多次，因此这次你决定打一盘最完美的游戏——为你在决赛中的完美表现作准备！

游戏中你需要完成若干个任务，完成每一个任务都可以积攒经验值。你在某一时刻积攒的在总经验值决定了你的游戏等级，具体地，每次达到一个新的等级需要 $v$ 点经验值，也就是说，假设你在某一时刻积攒的总经验值为 $X$，那么你在该时刻的等级就是最大的满足 $L\cdot v\leqslant X$ 的整数 $L$。

游戏中的第 $i$ 个任务的设定经验值为 $x_i$，参考难度为 $d_i$。如果你在等级 $\geqslant d_i$ 的情况下完成了第 $i$ 个任务，那么你将获得 $x_i$ 点经验值。然而，如果你在等级 $<d_i$ 的情况下完成了第 $i$ 个任务，那么你将获得 $c\cdot x_i$ 点经验值。

现在，你已经知道了 $v,c$ 的值以及所有任务的设定经验值 $x_i$ 和参考难度 $d_i$，你想知道在按照某一特定顺序依次完成任务的情况下，能够攒到的总经验值最大是多少。

数据范围：

- $1\leqslant n,v\leqslant 2000$，$2\leqslant c\leqslant 2000$。
- $1\leqslant x_i\leqslant 2000$，$1\leqslant d\leqslant 10^6$。

Translated by Eason_AC


---

---
title: "[ICPC 2020 WF] Trailing Digits"
layout: "post"
diff: 省选/NOI-
pid: P8140
tag: ['2020', 'O2优化', 'ICPC']
---
# [ICPC 2020 WF] Trailing Digits
## 题目背景

ICPC2020 WF M
## 题目描述

A large shipment of doodads has just arrived, and each doodad has a suggested retail price of $b$ cents. You've noticed that consumers are much more likely to purchase goods when most of the trailing digits are the same. For example, items are more likely to be priced at $99$ cents rather than $57$ cents. So to make your goods more appealing, you've decided to sell your goods in bundles. To make a bundle, you choose a positive integer $k$, and sell $k$ doodads for $k \times b$ cents. With an appropriate choice of $k$ you can have a more pleasing price. For example, selling $57$-cent doodads in bundles of size $7$ means that each bundle sells for $399$ cents, which has two trailing $9$s, rather than no trailing $9$s of $57$. This idea of trailing $9$s can be generalized to any other trailing digit: bundles of $692$ $57$-cent doodads sell for $39\,444$ cents (three trailing $4$s) and bundles of one million doodads sell for $57\,000\,000$ cents (six trailing $0$s).

After a little thought, you realize that you do not want to make your bundles too large---not only can the price be excessive, but who really needs several million doodads? For any type of doodad, your marketing department has a maximum bundle price of $a$.

Given the price of a doodad, the desired trailing digit, and the maximum price of a bundle, write a program that optimizes the trailing digits.
## 输入格式

Input consists of a single line containing three integers $b$, $d$, and $a$, where $b$ ($1 \leq b < 10^{6}$) is the price of a doodad in cents, $d$ ($0 \leq d \leq 9$) is the desired trailing digit, and $a$ ($b \leq a < 10^{10\,000}$) is the maximum price of a bundle.
## 输出格式

Output the maximum number of consecutive occurrences of $d$ that can appear at the end of a bundle price, given that the price of the bundle cannot exceed $a$.
## 样例

### 样例输入 #1
```
57 9 1000
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
57 4 40000
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
57 4 39000
```
### 样例输出 #3
```
2
```
## 题目翻译

## 题目描述
有一批货，每个价值 $b$ 元，可以把 $n$ 个货打包出售，价格是 $b \times n$ 元（前提是$b \times n\le a$），使末尾含有尽可能多的数字 $d$ ，求最多的 $d$ 数量。
## 输入格式
一行三个整数，$b$ , $d$ 和 $a$。
## 输出格式
一个整数，最多的 $d$ 数量。
## 说明/提示
对于全部数据，有 $1 \le b < 10^6$ , $0 \le d \le 9$ , $b \le a < 10^{10000}$


---

---
title: "「PMOI-5」肥宅快乐水"
layout: "post"
diff: 省选/NOI-
pid: P8157
tag: ['O2优化']
---
# 「PMOI-5」肥宅快乐水
## 题目背景

lhm 喝肥宅快乐水的时候想到了这个 idea，于是就叫它肥宅快乐水。

~~此题为弱化版，强化版敬请期待 Ynoi。~~

特别感谢：验题人 双管荧光灯 吊打了此题的 std！
## 题目描述

lhm 的手中有 $n$ 个宽度为 $1$ 的矩形水平排列组成的多边形，其中第 $i$ 个矩形的高度为 $a_i$。现在他会进行 $k$ 次操作，每次使一个宽度为 $1$ 的矩形高度减 $1$，求他每次操作后的最大子矩形面积（显然，子矩形必须是连续的一块）。

**注意任何情况高度都大于等于 $0$。**

由于 lhm 太菜了，所以想要请聪明的你来帮他解决。
## 输入格式

输入数据共 $k+2$ 行。   
第一行两个整数 $n,k$，含义如题所示。    
第二行 $n$ 个整数 $a_i$，第 $i$ 个整数表示第 $i$ 个矩形的高度。    
接下来 $k$ 行，每行一个整数 $\operatorname{id}'$，操作编号 $\operatorname{id}=\operatorname{id}'\bigoplus \operatorname{lastans}$。其中 $\operatorname{lastans}$ 为上一次询问的答案，最开始 $\operatorname{lastans}=0$。
## 输出格式

输出数据共 $k$ 行。   
每行一个整数，表示每次询问所求答案。
## 样例

### 样例输入 #1
```
5 2
2 3 1 3 2
2
6
```
### 样例输出 #1
```
5
4
```
## 提示

**本题采用捆绑测试。**

|  子任务编号 | 分值 | $n, k$ |
| :-----------: | :---:| :-----------: |
| 1 | 10 | $\leq 500$ |
| 2 | 10 | $\leq 5000$ |
| 3 | 40 | $\leq 10^5$ |
| 4 | 40 | $\leq 5\times10^5$ |

对于 $100\%$ 的数据，$1\le n,k\le 5\times 10^5$，$1\leq a_i\leq 10^9$。保证 $\operatorname{id}'$ 在 `long long` 范围内。


---

---
title: "[CEOI 2021] Diversity"
layout: "post"
diff: 省选/NOI-
pid: P8171
tag: ['2021', 'CEOI（中欧）']
---
# [CEOI 2021] Diversity
## 题目背景

译自 CEOI2021 Day1 T1. [Diversity](https://hsin.hr/ceoi/competition/ceoi2021_day1_tasks.pdf)。  

原题时限 7s。由于洛谷时间以及测试点数量限制，这里只选取部分测试点并缩小时限。但保证在标程时限的 1.5 倍。
## 题目描述

定义一个序列的 _多样性_ 为其不同的元素个数，一个序列的 _总多样性_ 为其所有子区间的 _多样性_ 的和。

例如，序列 $(1,1,2)$ 的 _多样性_ 为 $2$ ，因为其有两种元素；它的 _总多样性_ 为序列 $(1),(1),(2),(1,1),(1,2),(1,1,2)$ 的 _多样性_ 之和，即 $1+1+1+1+2+2=8$。

给出长为 $N$ 的序列 $\{a _i\}$ 与 $Q$ 个**互相独立**的询问，每个询问给出 $[l,r]$。求将原序列 $[l,r]$ 内的数重排可以得到的该区间最小的 _总多样性_。
## 输入格式

输入第一行包含两个整数 $N$ 和 $Q$，表示序列长度和询问数量。

第二行 $N$ 个整数，表示序列 $\{a_i\}$。

接下来 $Q$ 行，每行两个整数 $l_i,r_i$，表示第 $i$ 次询问的区间。
## 输出格式

输出应包含 $Q$ 行整数，第 $i$ 行的整数表示第 $i$ 个询问的答案。
## 样例

### 样例输入 #1
```
3 1
1 2 3
1 3
```
### 样例输出 #1
```
10
```
### 样例输入 #2
```
4 2
1 1 1 1
1 2
2 4
```
### 样例输出 #2
```
3
6
```
### 样例输入 #3
```
5 3
1 2 1 3 2
2 5
1 3
3 4
```
### 样例输出 #3
```
16
8
4
```
## 提示

#### 样例解释

对于第一组样例，无论怎样重排，询问区间的 _总多样性_ 总是 $10$。

对于第二组样例，序列所有元素都为 $1$，故无需重排。区间 $[1,2]$ 的 _总多样性_ 为 $3$，区间 $[2,4]$ 的 _总多样性_ 为 $6$。

对于第三组样例，第一个询问可将序列重排为 $(1,2,2,3)$，它的 _总多样性_ 为 $1+1+1+1+2+1+2+2+2+3=16$；第二个询问可将序列重排为 $(1,1,2)$，它的 _总多样性_ 为 $1+1+1+1+2+2=8$；第三个询问可将序列重排为 $(1,3)$，它的 _总多样性_ 为 $1+1+2=4$。

#### 子任务

所有测试点均满足 $1\leq N\leq 3\times 10^5$，$1\leq a_i\leq 3\times 10^5$，$1\leq Q\leq 5\times 10^4$。

各子任务的约束条件如下：
| 子任务编号 | 分值 |                             约束                             |
| :--------: | :--: | :----------------------------------------------------------: |
|    $1$     | $4$  | $1\leq N\leq 11$，$1\leq a_i\leq 3\times 10^5$，$Q=1$，$l_1=1$，$r_1=N$  |
|    $2$     | $10$ | $1\leq N\leq 3\times 10^5$，$1\leq a_i\leq 11$，$Q=1$，$l_1=1$，$r_1=N$  |
|    $3$     | $8$  | $1\leq N\leq 3\times 10^5$，$1\leq a_i\leq 23$，$Q=1$，$l_1=1$，$r_1=N$  |
|    $4$     | $16$ | $1\leq N\leq 3\times 10^5$，$1\leq a_i\leq 1000$，$Q=1$，$l_1=1$，$r_1=N$ |
|    $5$     | $26$ | $1\leq N\leq 3\times 10^5$，$1\leq a_i\leq 3\times 10^5$，$Q=1$，$l_1=1$，$r_1=N$ |
|    $6$     | $36$ | $1\leq N\leq 3\times 10^5$，$1\leq a_i\leq 3\times 10^5$，$1\leq Q\leq 5\times 10^4$ |


---

---
title: "[CEOI 2021] L-triominoes"
layout: "post"
diff: 省选/NOI-
pid: P8172
tag: ['2021', 'CEOI（中欧）']
---
# [CEOI 2021] L-triominoes
## 题目背景

译自 CEOI2021 Day1 T2. [L-triominoes](https://hsin.hr/ceoi/competition/ceoi2021_day1_tasks.pdf)。
## 题目描述

给出一个 $H\times W$ 的矩形，我们称其中 $1\times 1$ 的最小矩形为单元格。这个矩形现在有 $K$ 个单元格遗失了。现在请问能否用形如下图的纸片完全覆盖整个矩形。

![捕获3.PNG](https://cdn.luogu.com.cn/upload/image_hosting/ylltjsyr.png)

我们认为一个矩形能被覆盖，当且仅当其所有未遗失的单元格恰好被纸片覆盖一次且没有纸片超出矩形或覆盖在遗失的单元格上。当然，纸片可以垂直或 $90°$ 旋转。
## 输入格式

输入的第一行包含三个非负整数，分别是 $W,H,K$，表示矩形的列数，行数和遗失的单元格数量。

接下来 $K$ 行，每行两个正整数 $x_i,y_i$ 表示一个遗失单元格的坐标。保证给出的单元格坐标互不相同。
## 输出格式

若能刚好覆盖则输出一行一个字符串 `YES`，否则输出一行一个字符串 `NO`。
## 样例

### 样例输入 #1
```
4 3 3
1 1
1 3
4 3
```
### 样例输出 #1
```
YES
```
### 样例输入 #2
```
5 2 4
1 2
2 1
5 1
5 2
```
### 样例输出 #2
```
NO
```
### 样例输入 #3
```
2 3 0
```
### 样例输出 #3
```
YES
```
## 提示

#### 样例解释

对于样例一，如图是一种合法的覆盖：

![捕获4.PNG](https://cdn.luogu.com.cn/upload/image_hosting/xgj9bfbw.png)

对于样例二，你永远无法覆盖 $(1,1)$ 上的单元格。 

![捕获5.PNG](https://cdn.luogu.com.cn/upload/image_hosting/hrrzvyjx.png)

对于样例三，如图是一种合法的覆盖： 

![捕获6.PNG](https://cdn.luogu.com.cn/upload/image_hosting/p5awynm4.png)

#### 子任务

所有测试点均满足 $1\leq W\leq 13$，$2\leq H\leq 10^9$，$0\leq K\leq 250$，$1\leq x_i\leq W$，$1\leq y_i\leq H$。

| 子任务编号 | 分值 |                    约束                     |
| :--------: | :--: | :-----------------------------------------: |
|    $1$     | $10$ | $2\leq W\leq 13$，$2\leq H\leq 10^3$，$K\leq 250$ |
|    $2$     | $7$  | $2\leq W\leq 13$，$2\leq H\leq 10^9$，$K=0$    |
|    $3$     | $11$ |  $2\leq W\leq3$，$2\leq H\leq 10^9$，$K\leq 250$  |
|    $4$     | $17$ | $4\leq W\leq 6$，$2\leq H\leq 10^9$，$K\leq 250$  |
|    $5$     | $35$ | $7\leq W\leq 13$，$2\leq H\leq 10^9$，$K\leq 250$ |
|    $6$     | $20$ | $2\leq W\leq 13$，$2\leq H\leq 10^9$，$K\leq 250$ |


---

---
title: "「EZEC-11」Unmemorable"
layout: "post"
diff: 省选/NOI-
pid: P8180
tag: ['O2优化', '洛谷月赛']
---
# 「EZEC-11」Unmemorable
## 题目描述

Unputdownable 手中有一个长度为 $n$ 的排列 $a$。

他在练习单调栈的时候用程序对于每一个 $i$ 求出了最大的 $l_i$ 使得 $a_{l_i} < a_i$ 且 $l_i<i$，以及最小的 $r_i$ 使得 $a_{r_i}<a_i$ 且 $r_i>i$。

特别的，若这样的 $l_i$ 不存在，则定义为 $0$，不存在的 $r_i$ 则定义为 $n+1$。

某日 Unputdownable 忘记了排列 $a$，而且只剩余**分别重排**后的 $l$ 和 $r$ 数组了，你能帮助他还原原来的排列 $a$ 吗？

随后由于他发现无法还原 $a$，你只要告诉他有多少种可能的原排列 $a$。 

答案对于 $998244353$ 取模，数据保证至少存在一种方案。
## 输入格式

第一行输入一个整数 $n$。

第二行输入 $n$ 个整数，表示重排后的 $l$。

第三行输入 $n$ 个整数，表示重排后的 $r$。
## 输出格式

输出一行，包含一个整数，表示可能的排列数量对 $998244353$ 取模后的值。
## 样例

### 样例输入 #1
```
5
3 1 0 0 4
6 3 6 3 6

```
### 样例输出 #1
```
6

```
## 提示

**样例解释 1**

一种可能的排列是 $\{2,5,1,3,4\}$，$l$ 数组是 $\{0,1,0,3,4\}$，$r$ 数组是 $\{3,3,6,6,6\}$。

**本题采用捆绑测试。**

- Subtask 1（5 pts）：$n\leq 8$。
- Subtask 2（15 pts）：$r_i\geq n$。
- Subtask 3（15 pts）：$n\leq 2000$，保证存在一个排列 $a$ 满足排列 $a$ 所求出的 $l,r$ 即为给定的。 
- Subtask 4（25 pts）：$n\leq 10^6$，保证存在一个排列 $a$ 满足排列 $a$ 所求出的 $l,r$ 即为给定的。 
- Subtask 5（40 pts）：无特殊限制。 

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$0 \leq l_i,r_i \leq n+1$，**数据保证至少存在一种方案**。


---

---
title: "[NOI Online 2022 提高组] 如何正确地排序"
layout: "post"
diff: 省选/NOI-
pid: P8253
tag: ['2022', 'O2优化', 'NOI Online']
---
# [NOI Online 2022 提高组] 如何正确地排序
## 题目背景

**经过管理员的考虑，我们打算将民间数据单独存放在最后一个 Subtask 中。这些测试点分数均为 0 分，但是没有通过其中的任何测试点将会视为此题不通过。**

**这一题中出现了评测记录测试点编号错乱的问题，是民间数据命名方式冲突导致的。但是我们保证其相对顺序没有混乱。**

民间数据提供者：@QwQcOrZ。
## 题目描述

有一个 $m\times n$ 的数组 $a_{i,j}$。  
定义：

$$f(i,j)=\min\limits_{k=1}^m(a_{k,i}+a_{k,j})+\max\limits_{k=1}^m(a_{k,i}+a_{k,j})$$

你需要求出 $\sum\limits_{i=1}^n\sum\limits_{j=1}^nf(i,j)$。
## 输入格式

第一行两个正整数 $m,n$。

接下来 $m$ 行，每行 $n$ 个正整数表示 $a_{i,j}$。
## 输出格式

一行一个正整数，表示答案。
## 样例

### 样例输入 #1
```
3 5
1 7 2 2 7
9 10 4 10 3
7 7 8 10 2
```
### 样例输出 #1
```
564
```
## 提示

**【样例 1 解释】**

以 $f(3,5)$ 为例：

$$\begin{aligned}f(3,5)&=\max(a_{1,3}+a_{1,5},a_{2,3}+a_{2,5},a_{3,3}+a_{3,5})+\min(a_{1,3}+a_{1,5},a_{2,3}+a_{2,5},a_{3,3}+a_{3,5})\\&=\max(9,7,10)+\min(9,7,10)\\&=10+7\\&=17\end{aligned}$$

下面给出 $f(i,j)$ 的数表，第 $i$ 行第 $j$ 列表示 $f(i,j)$：

$$\begin{array}{|c|c|c|c|c|}\hline20&27&18&22&20\\\hline27&34&24&29&23\\\hline18&24&20&22&17\\\hline22&29&22&24&22\\\hline20&23&17&22&18\\\hline\end{array}$$

它们的和是答案 $564$。

**【样例 2, 3, 4】**

见选手目录下的 `sort/sort*.in` 与 `sort/sort*.ans`。

**【数据范围与提示】**

对于所有测试点：$2\le m\le 4$，$1\le n\le 2\times {10}^5$，$1\le a_{i,j}\le 2\times 10^5$。

每个测试点的具体限制见下表

![](https://cdn.luogu.com.cn/upload/image_hosting/h38vdmnj.png)


---

---
title: "[COCI 2012/2013 #2] INSPEKTOR"
layout: "post"
diff: 省选/NOI-
pid: P8300
tag: ['2012', 'COCI（克罗地亚）']
---
# [COCI 2012/2013 #2] INSPEKTOR
## 题目背景

**本题分值按 COCI 原题设置，满分 $160$。**
## 题目描述

一个新城镇刚刚在一个小国家落成。 像往常一样，Mirko 获得了首席税务监察员的职位。 他的职责是确保镇上所有不同公司的充分会计处理。

沿大街有 $N$ 个营业厅，从左到右编号为 $1\sim N$。一开始所有的办公室都是空的； 随着时间的推移，公司将进出这些办公室。 不时，Mirko 会经过一些办公室，只检查这些办公室中目前最富有的一家。

搬入的公司用四个整数来描述：

- $T$：搬入的日期。此处设小镇建成当天为 $1$。

- $K$：办公室序号。

- $Z$：公司的每日利润（如果公司亏损，则可能为负数）。

- $S$：搬入当天公司账户余额。

如果办公室 $K$ 中已经有一家公司，则当新公司搬入时，该公司搬出。

新公司直到搬入后的第二天才开始营业（或赚取利润）。

米尔科的巡视由三个整数描述：

- $T$：巡视的日期。小镇建成当天为 $1$。

- $A,B$：Mirko 将会经过 $[A,B]$ 内所有办公室。

由于 Mirko 只在一天结束时工作，所以到 Mirko 散步时，所有公司都已经完成了当天的业务并公布了当天的利润。

帮助 Mirko 编写一个程序，在每次闲逛时查找 Mirko 路过的当前最富有的公司的账户余额。
## 输入格式

输入的第一行包含两个正整数，$N\ (1 ≤ N ≤ 10^5)$ 和 $M \ (1 ≤ M ≤ 3\times 10^5)$，
分别表示办公室和巡视的数量。

接下来 $M$ 行，每一行包含一个事件的描述，格式为 `1 T K Z S`（公司搬入）或 `2 T A B`（Mirko 的巡视）。

所有事件都按时间顺序给出，每天最多发生一个事件（即 $T$ 将是严格递增）。 最后一个事件的天数将小于 $10^6$, 所有 $Z$ 和 $S$ 数字的绝对值
值将小于 $10^6$。
## 输出格式

对于 Mirko 的每一次巡视，输出一行包含 Mirko 检查的公司的账户余额，或者如果他将经过的所有办公室都是空的，则输出单词 `nema`。
## 样例

### 样例输入 #1
```
2 4
1 1 1 2 4
1 2 2 3 2
2 5 1 2
2 7 1 2

```
### 样例输出 #1
```
12
17

```
### 样例输入 #2
```
3 6
1 1 1 4 -2
1 2 2 2 6
2 3 3 1
2 4 3 1
1 5 3 -6 20
2 6 2 3
```
### 样例输出 #2
```
8
10
14
```
### 样例输入 #3
```
5 9
1 1 5 4 -5
2 2 3 5
1 3 4 6 9
2 4 1 2
1 6 2 2 3
2 8 2 1
1 9 4 0 17
2 10 5 5
2 11 1 4
```
### 样例输出 #3
```
-1
nema
7
31
17
```


---

---
title: "[CoE R4 C] 网格"
layout: "post"
diff: 省选/NOI-
pid: P8303
tag: ['洛谷原创', '交互题', 'Special Judge', 'O2优化', '洛谷月赛']
---
# [CoE R4 C] 网格
## 题目描述

**这是一道交互题。**

有一张 $n$ 个点的无向无权图。

这张图有一个特殊性质：存在一个点 $u \ (1 \leq u \leq n)$ 到正整数对 $(x, y) \ (1 \leq x \leq l, 1 \leq y \leq c)$ 的**一一对应**关系，使得 $n = l \cdot c$，且点 $u, v$ 间存在边当且仅当 $u, v$ 对应的数对 $(x_u, y_u), (x_v, y_v)$ 满足 $|x_u - x_v| + |y_u - y_v| = 1$。换而言之，这张图和 $l$ 行 $c$ 列的网格图同构。

现在，你要通过一些询问还原这张图的结构。每次询问时，你需要给定一个点 $u \ (1 \leq u \leq n)$。询问的返回值是一个长为 $n$ 的数组 $\{d_i\} \ (1 \leq i \leq n)$，表示点 $u, i$ 间的最短路径所经过的边数。

请你使用不超过 $q$ 次询问，还原出这张图的结构。

---

### 交互格式

**本题有多组数据。**

首先输入一个整数 $T$，表示数据组数。

对于每组数据：

- 首先输入一个整数 $n$，表示图的点数。
- 接下来，你可以执行一些询问。对于每次询问，输出一个整数 $u$，为你询问的点。然后，输入 $n$ 个整数 $\{d_i\}$，为询问的返回值。
- 当你确定答案后，输出一个整数 $0$，然后输出答案。

在输出答案时：

- 第一行输出两个整数 $l, c$；
- 接下来，输出 $l$ 行 $c$ 列整数，为你还原的对应关系。第 $i$ 行 $j$ 列的数为 $(i, j)$ 对应的编号。

如果有多个答案，你可以输出任意一个。一个答案是正确的，当且仅当它和标准答案无法被任何询问区分：也就是，在这两个答案对应的网格图中，任意点对间的最短路径所经过的边数都是相同的。

---

请注意：**在每次执行询问或者输出答案后，你应该清空缓冲区：**

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Java 中，使用 `System.out.flush()`。
- 在 Python 中，使用 `stdout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 对于其他语言，请自行查阅对应语言的帮助文档。

## 输入格式

见「交互格式」。
## 输出格式

见「交互格式」。
## 样例

### 样例输入 #1
```
1
6

0 2 2 3 1 1

2 0 2 1 1 3

2 2 0 1 1 1

3 1 1 0 2 2

1 1 1 2 0 2

1 3 1 2 2 0
```
### 样例输出 #1
```


1

2

3

4

5

6

0
2 3
2 5 1
4 3 6
```
### 样例输入 #2
```
2
1



2

1 0
```
### 样例输出 #2
```


0
1 1
1

2

0
2 1
1
2
```
## 提示

### 样例 $1$ 解释

对于样例，以下 $3$ 行 $2$ 列的网格图也是正确的输出。

```
3 2
4 2
3 5
6 1
```

左边是样例对应的网格图，右边是以上输出对应的网格图。

![](https://cdn.luogu.com.cn/upload/image_hosting/jy23v0au.png)

---

### 评分标准

对于一个子任务，令 $q_{\max}$ 为你在这个子任务的所有测试数据中的最大询问次数。

如果交互的格式不合法，运行超出了时间限制，或者你的答案不正确，或者 $q_{\max} > q$，你的得分为 $0$。

否则，对于子任务 $1 \sim 3$，你得满分；对于子任务 $4$，你的分数由下表给出：

| 条件 | 分数 |
| :-: | :-: |
| $q_{\max} \leq 3$ | $61$ |
| $q_{\max} = 4$ | $41$ |
| $q_{\max} = 5$ | $31$ |
| $q_{\max} = 6$ | $21$ |
| $q_{\max} \geq 7$ | $11$ |

---

### 数据规模

**本题采用捆绑测试。**

| 子任务 | 分值 | $n \leq$ | $q = $  | 特殊性质 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $3$ | $4$ | $4$ | 无 |
| $2$ | $13$ | $10^5$ | $4$ | 存在解使得 $l = 1$ |
| $3$ | $23$ | $36$ | $36$ | 存在解使得 $2 \leq l, c \leq 6$ |
| $4$ | $61$ | $10^5$ | $12$ | 无 |

对于所有数据，保证 $1 \leq T \leq 10^3$，$1 \leq n \leq 10^5$，$\sum n \leq 3 \times 10^5$。

在部分测试数据中，交互器是自适应的。也就是，图的结构可能会根据你的询问而变化。但是可以保证：在每次询问之后，存在至少一个答案符合当前所有询问的返回值。



---

---
title: "[CoE R4 D] 01 串"
layout: "post"
diff: 省选/NOI-
pid: P8304
tag: ['洛谷原创', 'O2优化', '洛谷月赛']
---
# [CoE R4 D] 01 串
## 题目描述

定义一个好的 $01$ 串 $\mathcal{S}$ 满足以下条件：

+ $\mathcal{S}$ 非空。

+ $\mathcal{S}$ 的任意一个前缀 $\mathcal {S}$$ [1\dots p](p\in [1,|$$\mathcal S$$|])$ 中，$0$ 的数量都不多于 $1$ 的数量。
+ $\mathcal{S}$ 的任意一个后缀 $\mathcal S$$[p\dots |$$\mathcal{S}$$|](p\in [1,|$$\mathcal S$$|])$ 中，$0$ 的数量都不多于 $1$ 的数量。

现在你得到了一个长度为 $n$ 的 $01$ 串 $\mathcal{T}$，有 $q$ 次询问，每次询问给定一对 $l,r$，求 $\mathcal{T}[l\dots r]$ 中的最长的好的 $01$ **子序列** 的长度。若没有好的 $01$ 子序列，则输出 $-1$。

注意：**子序列** 是指去除某些元素但不破坏余下元素的相对位置而形成的新序列。
## 输入格式

第一行两个整数 $n,q$，分别表示 $01$ 串的长度和询问次数。

第二行一个长度为 $n$ 的 $01$ 串，表示 $\mathcal{T}$。

接下来 $q$ 行，每行两个整数 $l,r$，表示一次询问。
## 输出格式

输出 $q$ 行，每行一个整数，依次表示每次询问的答案。
## 样例

### 样例输入 #1
```
10 4
0100101011
1 1
1 5
2 9
1 10
```
### 样例输出 #1
```
-1
3
7
8
```
## 提示

### 样例解释

第一次询问中，询问的串为 $0$，没有任何的子序列是好的，所以答案是 $-1$。

第二次询问中，询问的串为 $01001$，子序列 $101$ 是好的且是最长的，所以答案是 $3$。

第三次询问中，询问的串为 $10010101$，子序列 $1010101$ 是好的且是最长的，所以答案是 $7$。

第四次询问中，询问的串为 $0100101011$，子序列 $10101011$ 是好的且是最长的，所以答案是 $8$。

---

### 数据规模

**本题采用捆绑测试。**

| 子任务 | 分值 | $n \le$ | $q \le$ |
| :-: | :-: | :-: | :-: |
| $1$ | $10$ | $10$ | $10$ |
| $2$ | $20$ | $2000$ | $2000$ |
| $3$ | $30$ | $8\times 10^4$ | $8\times 10^4$ |
| $4$ | $10$ | $10^5$ | $1$ |
| $5$ | $30$ | $5\times 10^5$ | $5\times 10^5$ |

对于 $100\%$ 的数据，$1 \leq l \leq r \leq n \leq 5 \times 10^5$，$1 \leq q \leq 5 \times 10^5$。


---

---
title: "[CoE R4 E] 伪随机"
layout: "post"
diff: 省选/NOI-
pid: P8305
tag: ['洛谷原创', 'Special Judge', 'O2优化', '洛谷月赛']
---
# [CoE R4 E] 伪随机
## 题目描述

很久很久以前，小明生成了一些数据。

他的数据生成器使用了以下两个函数生成随机数：

```plain
定义函数 srand(32 位无符号整数 seed)
	将 x 赋值为 seed

定义函数 rand()
	将 x 赋值为 x 异或 (x 左移 13 位)
	将 x 赋值为 x 异或 (x 右移 17 位)
	将 x 赋值为 x 异或 (x 左移 5 位)
	返回 x
```

小明在调用 $\text{srand(seed)}$ 后，连续调用了 $n$ 次 $\text{rand()}$，并且记录下了每次 $\text{rand()}$ 的返回值对 $p$ 取模时得到的余数 $a_i$。

很久很久以后，只有数据生成器依然残存（实现见下发文件的 `generator.cpp`），但生成器的参数 $\text{seed}$ 和 $p$ 已经消失。

小明想要从数据中恢复这两个参数。即给定序列 $a_i$，需要找到任意一组 $\text{seed}$ 和 $p$ 的可能的值。你能帮帮他吗？

---

**简要描述**

小明的数据生成器是下发文件的 `generator.cpp`。你需要根据生成器的输出，反推出生成器的输入。

## 输入格式

输入的第一行包含一个整数 $n$。

第二行包含 $n$ 个 $32$ 位无符号整数 $a_1, a_2, \cdots, a_n$，为小明生成的数据。

## 输出格式

输出仅包含两个 $32$ 位无符号整数 $\text{seed}$ 和 $p$，为你的答案。你需要保证 $0 < \text{seed}, p < 2^{32}$。

如果有多组解，你可以输出任意一组。

## 样例

### 样例输入 #1
```
见下发文件的 sample.in
```
### 样例输出 #1
```
见下发文件的 sample.out
```
## 提示

### 数据规模

本题共有 $50$ 个测试点，每个测试点 $2$ 分。

对于所有数据，保证 $n = 10^5$，$\text{seed}$ 是随机选取的，且至少存在一组解。



---

---
title: "[COCI 2021/2022 #4] Izbori"
layout: "post"
diff: 省选/NOI-
pid: P8313
tag: ['2021', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #4] Izbori
## 题目描述

Malnar 先生正在竞选县长，这个县一共有 $n$ 栋房屋，每栋房屋里都住着一位居民。Malnar 先生知道，选举的赢家不一定是最好的候选人，而是在选举前举办的宴会最好的候选人。因此，在选举前几天，他将邀请第 $l$ 至 $r(l\le r)$ 栋房屋内居住的居民，为他们准备一顿丰盛的晚餐。

Malnar 先生知道所有居民最喜欢吃的菜。在宴会上，他会准备大多数人喜欢的一道菜。如果一个人吃到了自己最喜欢吃的菜，将会投一票给 Malnar 先生。但是如果没有吃到自己最喜欢吃的菜，他们将会把票投给 Vlado 先生。如果没有来参加晚宴的居民，他们将会忘记选举，不做出任何投票。如果一个候选人获得了投了票的人中一半以上的人的支持，他将会赢得竞选。

Malnar 先生想知道，有多少组的 $(l,r)$ 可以使他赢得竞选。
## 输入格式

第一行包含一个整数 $n$，表示房屋的数量。

第二行包含 $n$ 个整数 $a_i$，表示第 $i$ 栋房屋内居民最喜欢的菜。
## 输出格式

仅一行，输出可以使 Malnar 先生赢得竞选的 $(l,r)$ 的组数。
## 样例

### 样例输入 #1
```
2
1 1
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
3
2 1 2
```
### 样例输出 #2
```
4
```
### 样例输入 #3
```
5
2 2 1 2 3
```
### 样例输出 #3
```
10
```
## 提示

**【样例 2 解释】**

可以使 Malnar 先生赢得竞选的 $(l,r)$ 为：$(1, 1),(2, 2),(3, 3),(1, 3)$。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：$1 ≤ n ≤ 300$。
- Subtask 2（15 pts）：$1 ≤ n ≤ 2\times10^3$。
- Subtask 3（15 pts）：$\forall i\in\{1,2,3,\dots,n\},1 ≤ a_i ≤ 2$。
- Subtask 4（70 pts）：没有额外限制。

对于 $100\%$ 的数据，$1 \le l\le r ≤ n ≤ 2\times10^5,1 ≤ a_i ≤ 10^9$。

**【提示与说明】**

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2021-2022](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf) T3 Izbori。**


---

---
title: "[COCI 2021/2022 #4] Parkovi"
layout: "post"
diff: 省选/NOI-
pid: P8314
tag: ['2021', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #4] Parkovi
## 题目背景

市政府决定修建公园来美化景观。为了让公园不仅好看，而且有用。市政府为了市民的幸福，希望公园里居民们更近一些。
## 题目描述

这个城市由 $n$ 个社区组成，社区间由 $n-1$ 条道路连接。并且从任意一个社区出发，可以到任意一个社区去。一共会建造 $k$ 座公园，同一个社区内只会存在一座公园。市政府希望尽可能减小从每个社区到最近公园的距离的最大值。

帮助政府应该在那些社区建造公园，可以使每个社区到最近公园的距离的最大值最小。
## 输入格式

第一行包含两个整数 $n,k$，分别表示社区数目和需要建造的公园数目。

接下来 $n-1$ 行，第 $i$ 行包含三个数 $a_i,b_i,w_i$，分别表示有一条长度为 $w_i$ 道路连接着社区 $a_i,b_i$。
## 输出格式

第一行包含一个整数，即每个社区到最近公园的距离的最大值的最小值。

第二行包含 $k$ 个整数，可以使每个社区到最近公园的距离的最大值最小所需要修建的公园所在的社区编号。

**如果有多组解输出一组解。**
## 样例

### 样例输入 #1
```
9 3
1 2 5
1 3 1
3 4 10
3 5 9
5 6 8
2 7 1
2 8 2
8 9 7
```
### 样例输出 #1
```
8
4 5 8
```
### 样例输入 #2
```
5 2
1 2 3
2 3 7
3 4 3
4 5 3
```
### 样例输出 #2
```
3
2 4
```
### 样例输入 #3
```
7 4
1 3 1
1 4 1
2 3 1
5 3 1
4 7 1
4 6 1

```
### 样例输出 #3
```
1
3 4 1 2
```
## 提示

**【样例 3 解释】**

如果只在 $3,4$ 号社区建公园，最大距离不会改变。但是市政府想建 $k$ 个公园，所以需要在其他地方再建两个。

**【数据规模与约定】**

**本题采用子任务捆绑测试。**

- Subtask 1（10 pts）：$1 ≤ n ≤ 20$。
- Subtask 2（10 pts）：$k=1$。
- Subtask 3（30 pts）：$\forall i\in\{1,2,3,\dots,n-1\},a_i=i,b_i=i+1$。
- Subtask 4（60 pts）：没有额外限制。

对于 $100\%$ 的数据，$1\le k\le n\le2\times10^5,1\le a_i,b_i\le n,1\le w_i \le 1e9$。

**【提示与说明】**

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2021-2022](https://hsin.hr/coci/) [CONTEST #4](https://hsin.hr/coci/contest4_tasks.pdf) T4 Parkovi。**


---

---
title: "[COCI 2021/2022 #5] Fliper"
layout: "post"
diff: 省选/NOI-
pid: P8326
tag: ['2021', 'Special Judge', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #5] Fliper
## 题目描述

现有一个包含 $n$ 块挡板的旧弹球机。

游戏在二维平面内进行，其中每块挡板与坐标轴所夹锐角总为 $45^\circ$，长度为 $1$ 个单位。挡板用其中心坐标 $(x_i,y_i)$ 和字符 / 或 \ 来表示。小球在碰到挡板后，其运动方向将会旋转 $90^\circ$。注意，挡板的两面都可使小球的运动方向发生偏转。

不难发现，当小球处于弹球机中时，它只有两种结局：

- 沿着某一方向一直运动下去而不碰到挡板
- 处于若干个挡板的循环之中

在翻新弹球机的过程中，有四种颜色的染料可供选择。现要将弹球机中的每个挡板进行染色，使得**每一个**循环内经过每一种颜色的次数相同且为偶数。

请给出一种符合题意的染色方式，或证明这样的染色方式不存在。如果不存在，输出 `-1`。
## 输入格式

第一行一个正整数 $n$，表示挡板的数量。

接下来的 $n$ 行，每行两个正整数 $x_i,y_i$ 和一个字符 $c_i$（/ 或 \），表示一个挡板。数据保证，挡板的位置不会相互重合。
## 输出格式

如果不存在符合题意的染色方式，输出 `-1`。

否则输出 $n$ 个整数 $1 \sim 4$，表示 $n$ 个挡板所选择的染料颜色。如果有多种符合题意的方式，输出任意一种。
## 样例

### 样例输入 #1
```
4
1 1 \
3 1 /
3 2 \
1 2 /
```
### 样例输出 #1
```
-1
```
### 样例输入 #2
```
9
1 2 \
1 3 /
2 1 \
2 2 \
2 3 \
3 1 /
3 2 \
4 2 /
4 3 \
```
### 样例输出 #2
```
1 3 2 4 1 3 2 4 1
```
### 样例输入 #3
```
12
1 2 \
1 3 /
2 1 \
2 2 \
2 3 \
2 4 /
3 1 /
3 2 \
3 3 \
3 4 \
4 2 /
4 3 \
```
### 样例输出 #3
```
1 3 2 4 2 4 1 3 1 3 2 4
```
## 提示

**【样例 2 图解】**

![](https://cdn.luogu.com.cn/upload/image_hosting/ksajf2n4.png)

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（20 pts）：$1 \le n \le 40$。
- Subtask 2（20 pts）：最多存在一个循环。
- Subtask 3（70 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 5 \times 10^5$，$0 \le |x_i|,|y_i| \le 10^9$。

**【说明】**

本题采用自行编写的 [Special Judge](https://www.luogu.com.cn/paste/g6cdziry)。如果对此有疑问或想要 hack，请[私信编写者](https://www.luogu.com.cn/chat?uid=137367)或[发帖](https://www.luogu.com.cn/discuss/lists?forumname=P8326)。

**【来源】[COCI 2021-2022#5](https://hsin.hr/coci/contest5_tasks.pdf) Task 3 Fliper。**


---

---
title: "[COCI 2021/2022 #5] Radio"
layout: "post"
diff: 省选/NOI-
pid: P8327
tag: ['2021', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #5] Radio
## 题目描述

克罗地亚有 $n$ 个初始状态下关闭的电台。当同时开启两个电台 $i,j$ 且 $i,j$ 不互质时，它们会互相干扰。

你需要写一个支持下列操作的程序：

1. `S x`：将电台的状态取反，即将原来开启的电台关闭，将原来关闭的开启。
2. `C l r`：检查在 $[l,r]$ 内是否存在互相干扰的现象。如果存在，输出 `DA`，否则输出 `NE`。
## 输入格式

第一行两个正整数 $n,q$，分别表示电台个数和操作次数。

接下来的 $q$ 行，具体输入格式见题目描述。
## 输出格式

对于每一次 C 操作，输出 `DA` 或者 `NE`。
## 样例

### 样例输入 #1
```
6 8
S 1
S 2
S 3
C 1 6
S 6
C 1 6
S 2
C 1 6
```
### 样例输出 #1
```
NE
DA
DA
```
### 样例输入 #2
```
11 6
S 4
S 10
C 3 11
C 2 7
S 6
C 2 7
```
### 样例输出 #2
```
DA
NE
DA
```
### 样例输入 #3
```
20 7
S 10
S 15
S 3
C 10 15
S 10
C 3 15
C 3 10
```
### 样例输出 #3
```
DA
DA
NE
```
## 提示

**【样例 1 解释】**

|C 操作序号|开启电台|是否互相干扰|
| :----------: | :----------: | :----------: |
|$1$|$1,2,3$|否|
|$2$|$1,2,3,6$|是|
|$3$|$1,3,6$|是|

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（10 pts）：$1 \le n \le 100$，$1 \le q \le 200$。
- Subtask 2（30 pts）：对于所有的 C 操作，$l=1,r=n$。
- Subtask 3（70 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le n \le 10^6$，$1 \le q \le 2 \times 10^5$，$1 \le x \le n$，$1 \le l \le r \le n$。

**【来源】[COCI 2021-2022#5](https://hsin.hr/coci/contest5_tasks.pdf) Task 4 Radio。**


---

---
title: "[COCI 2021/2022 #5] Usmjeravanje"
layout: "post"
diff: 省选/NOI-
pid: P8328
tag: ['2021', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #5] Usmjeravanje
## 题目描述

永无岛有两条河流。每条河流沿岸分布有若干个城市，其中城市数量分别为 $a,b$。

对于位于同一条河流沿岸的 $i,j$ 两个城市，如果 $i \lt j$，那么可以通过水路从城市 $i$ 到城市 $j$。

永无岛的居民们已经决定修建 $m$ 条连接第一条河流的城市 $x_i$ 和第二条河流的城市 $y_i$ 的单向航线，但方向有待商榷。

当两个城市之间可以通过水路或航线互相到达时，则称它们是连通的。在所有的城市中，存在若干个城市集合，使得集合中没有任何一对城市是连通的。请为每条航线选择一个方向，使得所有集合中包含元素最多的集合元素个数最少。
## 输入格式

第一行两个正整数 $a,b$。

第二行一个正整数 $m$。

接下来的 $m$ 行，每行两个正整数 $x_i,y_i$，表示一条连接第一条河流的城市 $x_i$ 和第二条河流的城市 $y_i$ 的单向航线。数据保证没有重复的无序数对 $(x_i,y_i)$ 出现。
## 输出格式

第一行一个正整数，表示最大集合元素个数的最小值。

第二行 $m$ 个整数 $0$ 或 $1$。其中 $0$ 表示方向从第一条河流的城市 $x_i$ 到第二条河流的城市 $y_i$，$1$ 则相反。

如果有多种符合题意的方案，输出任意一种。
## 样例

### 样例输入 #1
```
5 3
4
1 2
2 3
3 1
5 3
```
### 样例输出 #1
```
1
1 1 0 0
```
### 样例输入 #2
```
6 6
4
1 2
3 2
4 3
5 6
```
### 样例输出 #2
```
9
1 0 1 1
```
### 样例输入 #3
```
8 7
7
1 3
2 1
3 4
5 6
6 5
6 7
8 7
```
### 样例输出 #3
```
5
1 0 1 1 0 1 0
```
## 提示

**【样例 1 解释】**

最优的方案可以使得每对城市都连通，因此答案为 $1$。

**【数据规模与约定】**

**本题采用捆绑测试。**

- Subtask 1（20 pts）：$1 \le a,b,m \le 15$。
- Subtask 2（30 pts）：$1 \le a,b \le 1000$。
- Subtask 3（60 pts）：无特殊限制。

对于 $100\%$ 的数据，$1 \le a,b,m \le 2 \times 10^5$，$1 \le x_i \le a$，$1 \le y_i \le b$。

**【说明】**

本题采用自行编写的 [Special Judge](https://www.luogu.com.cn/paste/uv2vgxxa)。如果对此有疑问或想要 hack，请[私信编写者](https://www.luogu.com.cn/chat?uid=137367)或发帖。

**【来源】[COCI 2021-2022#5](https://hsin.hr/coci/contest5_tasks.pdf) Task 5 Usmjeravanje。**


---

---
title: "[AHOI2022] 钥匙"
layout: "post"
diff: 省选/NOI-
pid: P8339
tag: ['各省省选', '2022', '安徽', 'O2优化']
---
# [AHOI2022] 钥匙
## 题目描述

有 $n$ 座城市，编号为 $1, 2, \ldots, n$。这些城市由 $n - 1$ 条无向道路相连，每条无向道路连接两座城市，保证任意两个城市连通。即这 $n$ 座城市构成一棵树。

每座城市都有一件宝物。宝物分为两种：钥匙和宝箱。在一座城市里，要么有一把钥匙，要么有一个宝箱。钥匙和宝箱有不同的颜色，颜色为 $i$ 的钥匙只能打开颜色为 $i$ 的宝箱，打开宝箱后可以获得一枚金币，同时这把钥匙会损坏。

**由于某种特殊的原因，同一种的钥匙最多只有 $\bm{5}$ 把（同一种颜色的宝箱数量不限）。**

现在小 R 规划了 $m$ 次旅行，第 $i$ 次旅行的起点为 $s_i$，终点为 $e_i$。小 R 从 $s_i$ 沿最短路径走到 $e_i$。当他走到一座有钥匙的城市时，他可以将钥匙放入背包。当他走到一座有宝箱的城市时，如果他有相应颜色的钥匙，那么他就会打开这个宝箱并获得一个金币；如果他没有相应颜色的钥匙，那么他什么都不做（宝箱不能带走）。问每次旅行能获得多少枚金币。

**注意：旅行相互独立，即一次旅行完之后所有的钥匙和宝箱都会恢复到初始状态。**
## 输入格式

第一行两个正整数 $n, m$，表示城市数量和旅行数量。

接下来 $n$ 行，每行两个正整数 $t_i, c_i$，$t_i=1$ 表示第 $i$ 个城市里有一把钥匙，$t_i=2$ 表示有一个宝箱。$c_i$ 表示第 $i$ 座城市里钥匙或宝箱的颜色。数据保证每种颜色的钥匙都不超过 $5$ 把。

接下来 $n - 1$ 行，每行两个正整数 $u_i, v_i$，表示有一条连接 $u_i$ 和 $v_i$ 的无向道路。

接下来 $m$ 行，每行两个正整数 $s_i, e_i$ 表示一次旅行的起点和终点。
## 输出格式

输出 $m$ 行，每行一个整数，表示第 $i$ 次旅行能获得的金币数量。
## 样例

### 样例输入 #1
```
5 3
1 2
2 2
1 3
2 3
2 2
1 2
1 3
3 4
3 5
2 4
2 5
4 2

```
### 样例输出 #1
```
1
1
1

```
### 样例输入 #2
```
见附件中的 keys/keys2.in
```
### 样例输出 #2
```
见附件中的 keys/keys2.ans
```
### 样例输入 #3
```
见附件中的 keys/keys3.in
```
### 样例输出 #3
```
见附件中的 keys/keys3.ans
```
## 提示

**【样例 \#4】**

见附件中的 `keys/keys4.in` 与 `keys/keys4.ans`。

该组样例满足 $n, m \le {10}^5$ 和特殊性质 A。

**【数据范围】**

对于 $100 \%$ 的数据，$1 \le n \le 5 \times {10}^5$，$1 \le m \le {10}^6$，$1 \le t_i \le 2$，$1 \le c_i, u_i, v_i, s_i, e_i \le n$，每种颜色的钥匙都不超过 $5$ 把。

| 测试点编号 | $n \le$ | $m \le$ | 特殊性质 |
|:-:|:-:|:-:|:-:|
| $1$ | $100$ | $100$ | 无 |
| $2 \sim 3$ | $5000$ | $5000$ | 无 |
| $4 \sim 5$ | ${10}^5$ | ${10}^5$ | 无 |
| $6 \sim 8$ | $5 \times {10}^5$ | ${10}^6$ | A |
| $9 \sim 10$ | $5 \times {10}^5$ | ${10}^6$ | 无 |

特殊性质 A：对于每种出现过的颜色，恰有一把钥匙和一个宝箱对应该颜色。

**【提示】**

输入输出数据较大，请使用较为快速的输入输出方式。


---

---
title: "「WHOI-1」HanawoTori"
layout: "post"
diff: 省选/NOI-
pid: P8358
tag: ['O2优化']
---
# 「WHOI-1」HanawoTori
## 题目背景

春天到了，花园里的花竞相开放。樱花、梅花、梨花、桃花、牡丹都开放了。

你需要在花园里采花。

日文版题面：[JP 版リンク](https://www.luogu.com.cn/problem/T239022)。

如果你只会 `cout << 1` 这样骗分，建议不要浪费时间在这里。
## 题目描述

这个花园是由位于最左边的两个 $\texttt{start}$ 格子加上 $2 \times n$ 个方格组成的一个长列。如下图，$n=6$：


![](https://i.bmp.ovh/imgs/2022/04/07/405bb9192e6cf6d9.png)

注意 $n$ 并不包括最左边的两个 $\texttt{start}$ 格子。每个格子里面都有一棵花，花的美丽程度（下称“**美丽值**”）用一个整数表示，在上图中已经写在格子里了。


从**最左边任选**一个 $\texttt{start}$ 格子开始，每个时刻，你可以走到当前格子**右**、**右上**或**右下**的格子（只要不走出界），并采走里面的花。当走到花园**尽头**时结束。

然后你需要把采到的花按照美丽程度**升序排列**，组成一串花。记**排序过后的**花串中第 $i$ 朵花的美丽值为 $f_i$，那么这串花的“和谐度”$F$ 等于：

$$F = \min_{i=1}^{n-1} \begin{cases} k \times |f_i-f_{i+1}| && |f_i-f_{i+1}| \bmod  b = a \\ |f_i-f_{i+1}| && |f_i-f_{i+1}| \bmod  b  \not = a\\\end{cases}$$

现在知道了花园中每个格子内的花的美丽值，你需要计算出可能的**最大** $F$。即在所有可能的行走方案中，可能出现的最大的 $F$ 值。
## 输入格式

第一行四个整数，代表 $n,a,b,k$；

接下来一行 $n$ 个整数，第 $i$ 个整数代表第 $1$ 行第 $i$ 格内花的美丽值;

接下来一行 $n$ 个整数，第 $i$ 个整数代表第 $2$ 行第 $i$ 格内花的美丽值;

## 输出格式

一行一个整数，表示所求答案。

## 样例

### 样例输入 #1
```
6 5 4 3
1 3 4 6 10 10
1 2 7 8 5 9
```
### 样例输出 #1
```
1
```
## 提示

**应要求，本题提供一个大样例，链接在下方。**

样例 #1 解释：

一条路径如下图：![](https://i.bmp.ovh/imgs/2022/04/07/84cfe7c13c0d33c1.png)

按时间顺序，得到的花的美丽值为 $\{1,2,4,6,5,10\}$；排序后为 $\{1,2,4,5,6,10\}$，可以计算出 $F=1$，这是能得到最大的 $F$ 了。

如果您无法写出能够得到满分的程序，可参考如下数据范围获取部分分值：

| 编号 | 特殊限制 | 分值 | 时限 | 
| :----------: | :----------: | :----------: | :----------: |
| 1 | $n \leq 30$ | 10 | 1s |
| 2 | $n\leq 100$ | 10 | 1s |
| 3 | $n \leq 2500$ | 40 | 1s |
| 4 | $n \leq 100000$ | 40 | 2s |

对于所有数据，$0 \leq f_i,k \leq 10^{8},1  \leq b < a \leq 10^8,n \ge 2$。

提示：

- 可能需要注意常数因子带来的效率差异。
- 本题存在 $O(n \log V)$ 的做法。



---

---
title: "[SNOI2022] 军队"
layout: "post"
diff: 省选/NOI-
pid: P8360
tag: ['各省省选', '2022', 'O2优化', '陕西']
---
# [SNOI2022] 军队
## 题目描述

R 国的历史非常悠久。

R 国有 $n$ 个城市，国内有 $C$ 个党派，分别记为 $1,2,\dots,C$。由于 R 国的版图非常长，这 $n$ 个城市的位置可以近似为坐标轴上的 $n$ 个点。在历史的最初，记载了第 $i$ 个城市归属党派 $c_i$，城中有数量为 $a_i$ 的军队。

R 国的历史上，经常发生以下三种事件：

1. 党派 $y$ 进行了一次游说，使城市 $l$ 到城市 $r$ 的所有归属党派 $x$ 的城市全部归属了 $y$。

2. 党派 $x$ 进行了一次征兵，使城市 $l$ 到城市 $r$ 的所有归属党派 $x$ 的城市中的军队数量增加了 $v$。

3. 城市 $l$ 到城市 $r$ 之间的所有城市爆发了战争。这场战争的规模可以描述为两地之间的所有城市中的军队数量之和。注意战争不一定发生在不同党派之间，归属同一个党派的一些城市内部也可能发生内战。由于 R 国的医护系统足够先进，战争不会造成军队数量的减少。

小 N 是一个喜欢历史的女孩子，最近她想整理一下 R 国的战争史，特别是每场战争的规模。但是由于 R 国的历史实在太长了，她用纸和笔进行运算实在力不从心。于是她找到了你，希望你写一个程序，统计出 R 国历史上所有战争的规模。
## 输入格式

输入的第一行是三个正整数 $n,q,C$，分别表示城市的个数，事件的个数，和 R 国国内党派的个数。

接下来一行有 $n$ 个正整数 $a_1,a_2,\dots,a_n$，表示每个城市内初始的军队数。

接下来一行有 $n$ 个正整数 $c_1,c_2,\dots,c_n$，表示每个城市初始归属的党派。

接下来 $q$ 行，每行 $3$ 到 $5$ 个正整数，表示一次事件：

第一个正整数 $\mathit{op}$ 表示事件的类型。$\mathit{op}=1,2,3$ 分别表示【题目描述】中所述的游说，征兵和战争事件。

对于每个游说事件，接下来有 $4$ 个正整数 $l,r,x,y$，意义见【题目描述】。

对于每个征兵事件，接下来有 $4$ 个正整数 $l,r,x,v$，意义见【题目描述】。

对于每个战争事件，接下来有 $2$ 个正整数 $l,r$，意义见【题目描述】。
## 输出格式

对于每个战争事件，输出一行一个整数，表示此次战争的规模。
## 样例

### 样例输入 #1
```
5 7 3
1 2 4 8 16
1 2 3 2 3
2 2 4 2 32
3 1 4
1 1 5 3 1
2 2 5 1 64
3 2 4
2 1 3 3 128
3 3 5

```
### 样例输出 #1
```
79
142
188

```
### 样例输入 #2
```
样例 2 见附件 military2.in
本组数据满足测试点 4 的限制。
```
### 样例输出 #2
```
样例 2 见附件 military2.ans
```
### 样例输入 #3
```
样例 3 见附件 military3.in
本组数据满足测试点 14 的限制。
```
### 样例输出 #3
```
样例 3 见附件 military3.ans
```
### 样例输入 #4
```
样例 4 见附件 military4.in
本组数据满足测试点 18 的限制。
```
### 样例输出 #4
```
样例 4 见附件 military4.ans
```
## 提示

**【样例 1 解释】**

最初，五个城市的军队数量分别为 $1, 2, 4, 8, 16$，归属的党派分别为 $1, 2, 3, 2, 3$。

发生的事件依次为：
- 党派 $2$ 尝试在城市 $2, 3, 4$ 征兵，归属党派 $2$ 的城市 $2, 4$ 各增加了 $32$ 军队。
- 城市 $1$ 和 $4$ 之间的所有城市爆发了战争，规模为 $1 + 34 + 4 + 40 = 79$。
- 党派 $1$ 在城市 $1, 2, 3, 4, 5$ 进行了一次游说，使得原本归属党派 $3$ 的城市 $3, 5$ 归属了党派 $1$。
- 党派 $1$ 尝试在城市 $2, 3, 4, 5$ 征兵，归属党派 $1$ 的城市 $3, 5$ 各增加了 $64$ 军队。
- 城市 $2$ 和 $4$ 之间的所有城市爆发了战争，规模为 $34 + 68 + 40 = 142$。
- 党派 $3$ 尝试在城市 $1, 2, 3$ 征兵，但是党派 $3$ 现在不拥有任何城市，因此并没有成功征兵。
- 城市 $3$ 和 $5$ 之间的所有城市爆发了战争，规模为 $68 + 40 + 80 = 188$。

因此你的程序应该依次输出 $79, 142, 188$。

**【数据规模与约定】**

对于全部数据，$1 \leq n, q\leq 2.5 \times 10^5$，$1 \leq a_i, v \leq 10^8$，$1 \leq c_i, x, y \leq C$。

具体的数据规模与约定见下表。

| 测试点编号 |    $n,q\leq $     |     $C\leq $      |               特殊约定               |
| :--------: | :---------------: | :---------------: | :----------------------------------: |
|    $1$     |       $20$        |       $20$        |                                      |
|    $2$     |       $50$        |       $50$        |                                      |
|    $3$     |       $300$       |       $300$       |                                      |
|    $4$     |      $5000$       |      $5000$       |                                      |
|    $5$     |      $10^5$       |       $10$        |                                      |
|    $6$     | $1.5 \times 10^5$ |       $10$        |                                      |
|    $7$     |  $2 \times 10^5$  |       $10$        |                                      |
|    $8$     | $2.5 \times 10^5$ |       $10$        |                                      |
|    $9$     | $1.5 \times 10^5$ | $1.5 \times 10^5$ |    对于所有操作，保证 $l=1,r=n$。    |
|    $10$    | $2.5 \times 10^5$ | $2.5 \times 10^5$ |    对于所有操作，保证 $l=1,r=n$。    |
|    $11$    | $1.5 \times 10^5$ | $1.5 \times 10^5$ | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |
|    $12$    |  $2 \times 10^5$  |  $2 \times 10^5$  | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |
|    $13$    | $2.5 \times 10^5$ | $2.5 \times 10^5$ | 对于所有操作 $1,2$，保证 $l=1,r=n$。 |
|    $14$    | $1.5 \times 10^5$ | $1.5 \times 10^5$ |         保证不存在操作 $1$。         |
|    $15$    | $2.5 \times 10^5$ | $2.5 \times 10^5$ |         保证不存在操作 $1$。         |
|    $16$    |      $10^5$       |      $10^5$       |                                      |
|    $17$    | $1.5 \times 10^5$ | $1.5 \times 10^5$ |                                      |
|    $18$    |  $2 \times 10^5$  |  $2\times 10^5$   |                                      |
|    $19$    | $2.5 \times 10^5$ | $2.5 \times 10^5$ |                                      |
|    $20$    | $2.5 \times 10^5$ | $2.5 \times 10^5$ |                                      |


---

---
title: "[SNOI2022] 倍增"
layout: "post"
diff: 省选/NOI-
pid: P8361
tag: ['各省省选', '2022', 'Special Judge', 'O2优化', '陕西']
---
# [SNOI2022] 倍增
## 题目描述

小 Z 是一个喜欢编程的女孩子。

这天，她在做一道编程题的时候偶然发现了一个神奇的整数 $142857$。

$142857 \times 2 = 285714$，而 $285714$ 的所有数位恰好是 $142857$ 的一个排列。

她很好奇，有没有更大的满足这种性质的整数。

她写了一个搜索，发现了一些更大的有趣的数：

$26835741 \times 2 = 53671482$

$0987312654 \times 2 = 1974625308$

$\dots$

她不满足于解决十进制下这样的问题，于是她想知道，是否在 $B$ 进制下存在一个 $n$ 位正整数 $x$，满足 $2x$ 的所有数位在 $B$ 进制下是 $x$ 的所有数位的一个排列。

由于她讨厌数字 $0$，因此她还要求对于任意 $1 \leq i \leq n$，$x$ 和 $2x$ 在 $B$ 进制下的第 $i$ 位不能同时为 $0$。
## 输入格式

**输入包含多组数据。**

输入的第一行是一个正整数 $T$，表示数据组数。

接下来 $T$ 行，第 $i$ 行包含两个正整数 $n$ 和 $B$，表示第 $i$ 组数据。
## 输出格式

对于每组数据，输出一行。

若本组数据有解，按照从高位到低位的顺序输出 $n$ 个非负整数，表示你找到的答案在 $B$ 进制下的值。

否则只需要输出一个数 $-1$。
## 样例

### 样例输入 #1
```
3
6 10
3 3
6 7

```
### 样例输出 #1
```
1 4 2 8 5 7
-1
0 3 5 3 1 6
```
### 样例输入 #2
```
样例 2 见附件 double2.in
本组数据满足测试点 3 的限制。
```
### 样例输出 #2
```
样例 2 见附件 double2.ans
```
### 样例输入 #3
```
样例 3 见附件 double3.in
本组数据满足测试点 17 的限制。
```
### 样例输出 #3
```
样例 3 见附件 double3.ans
```
## 提示

**【样例 1 解释】**

- 第一组数据的解释参见【题目描述】。
- 对于第二组数据，可以通过枚举所有的 $n$ 位 $B$ 进制数说明一定不能找到这样的正整数。
- 对于第三组数据，$2x$ 的 $7$ 进制表示为 $103635_{(7)}$，因此这是一个满足题意的答案。

注意此样例的答案文件仅表明了一种可能的合法答案，不表明答案文件恰好对应标准程序的输出。

**【样例 2/3 解释】**

注意此样例的答案文件仅表明了一种可能的合法答案，不表明答案文件恰好对应标准程序的输出。

**【提示】**

由于答案可能不唯一，我们下发了校验器 `checker.cpp` 和库文件 `testlib.h`。

可以使用以下命令编译 `checker.cpp`：

```
g++ -o checker checker.cpp -O2 -std=c++11
```

将 `checker.cpp` 编译得到可执行文件 `checker` 后你可以使用以下方式测试你的答案：

`checker <input> <output> <answer>`：利用选手目录下的 `double/double*.ans` 可以用来检验你的答案在样例测试点 `double/double*.in` 的正确性。

`checker <input> <output> <output>`：会检查你的所有有解输出是否符合题目要求。注意以此种方式测试的时候，输出无解总会被报告为合法，因为在此种运行方式下我们只会检查你报告的所有解。

**请选手注意多组数据之间的清空问题。**

**【数据规模与约定】**

对于全部数据，$1 \leq T \leq 10^4$，$2 \leq \sum B \leq 2 \times 10^5$，$1 \leq \sum n \leq 2 \times 10^5$，$n \geq 1$，$B \geq 2$。

具体的数据规模与约定见下表。

| 测试点编号 |    $n \leq$     |    $ B \leq$    | $T \leq$ | 特殊约定            |
| :--------: | :-------------: | :-------------: | :------: | ------------------- |
|    $1$     |       $8$       |       $8$       |   $10$   |                     |
|    $2$     |       $8$       |       $8$       |  $10^4$  |                     |
|    $3$     | $2 \times 10^5$ |       $8$       |   $10$   |                     |
|    $4$     | $2 \times 10^5$ |       $8$       |  $10^4$  |                     |
|    $5$     | $2 \times 10^5$ |       $8$       |  $10^4$  |                     |
|    $6$     |      $15$       |      $15$       |  $100$   |                     |
|    $7$     |      $40$       |      $40$       |  $100$   |                     |
|    $8$     |      $100$      |      $100$      |  $100$   |                     |
|    $9$     |      $300$      |      $300$      |  $100$   |                     |
|    $10$    |     $1000$      |     $1000$      |  $100$   |                     |
|    $11$    |     $3000$      |     $3000$      |  $100$   |                     |
|    $12$    |     $15000$     |     $15000$     |  $100$   |                     |
|    $13$    |     $50000$     |     $50000$     |  $100$   |                     |
|    $14$    | $2 \times 10^5$ | $2 \times 10^5$ |  $100$   |                     |
|    $15$    |      $200$      |      $200$      |  $10^4$  | $n \geq 100$        |
|    $16$    |     $5000$      |     $5000$      |  $10^4$  | $n \geq 100$        |
|    $17$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  | $n \geq 100$        |
|    $18$    |      $300$      |      $300$      |  $10^4$  | $B=3k-1,k \in \N^*$ |
|    $19$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  | $B=3k-1,k \in \N^*$ |
|    $20$    |      $300$      |      $300$      |  $10^4$  | $B=3k,k \in \N^*$   |
|    $21$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  | $B=3k,k \in \N^*$   |
|    $22$    |      $100$      |      $100$      |  $10^4$  |                     |
|    $23$    |      $500$      |     $5000$      |  $10^4$  |                     |
|    $24$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  |                     |
|    $25$    | $2 \times 10^5$ | $2 \times 10^5$ |  $10^4$  |                     |



---

---
title: "[POI 2004] Gra"
layout: "post"
diff: 省选/NOI-
pid: P8382
tag: ['2004', 'POI（波兰）']
---
# [POI 2004] Gra
## 题目描述

让我们考虑一个在 $m \times 1$ 的板子上玩的游戏,板子被从 $1$ 到 $m$ 编号。 

现在板子上有 $n$ 个棋子，每个都严格占据板子上的一个格子，没有一个棋子占据格子 $m$。 

每个单独的移动遵循以下原则：移动的人选择一个棋子把它移动到比它大的格子中第一个未被占据的格子里去。两个选手交替移动，谁先占据格子 $m$ 谁赢。

我们在当且仅当他移动以后令一选手无论如何都无法赢他的时候说当前选手的移动称作 $\text{winning}$ 操作。

我们想知道先手有多少个移动是 $\text{winning}$ 操作。
## 输入格式

第一行有两个数 $m,n$ 。

然后接下来 $n$ 个上升的整数表示初始被占据的格子编号。
## 输出格式

输出先手有多少移动是 $\text{winning}$ 操作。
## 样例

### 样例输入 #1
```
5 2
1 3
```
### 样例输出 #1
```
1
```
## 提示

对于 $100$ % 的数据：$2 \le m \le 10^{9}, 1 \le n \le 10^{6}$ ，且有 $n + 1 \le m$ 。

下面是一个例子：

![](https://cdn.luogu.com.cn/upload/image_hosting/obrkvr84.png)

在 $m = 7$ 的时候，一个选手可以把 $2$ 移到 $4$，把 $3$ 移到 $4$ 或者把 $6$ 移动到 $7$。


---

---
title: "[BalticOI 2022] Event Hopping (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P8391
tag: ['2022', 'BalticOI（波罗的海）']
---
# [BalticOI 2022] Event Hopping (Day1)
## 题目描述

有 $n$ 个区间，第 $i$ 个区间为 $[l_i,r_i]$。

你可以在区间之间跳跃。当你在第 $x$ 个区间上时，你可以跳到一个覆盖右端点 $r_x$ 的区间 $y$ 上，即从 $x$ 能跳到 $y$ 当且仅当 $[r_x \in [l_y,r_y]]$。

有 $q$ 次询问，每次你一开始在第 $s_i$ 个区间，你需要跳到第 $t_i$ 个区间。你需要输出你至少需要跳多少次。如果不能跳到，输出 `impossible`。
## 输入格式

第一行，两个整数 $n, q$。

接下来 $n$ 行，每行两个整数 $l_i$，$r_i$。

接下来 $q$ 行，每行两个整数 $s_i$，$t_i$。
## 输出格式

输出 $q$ 行，第 $i$ 行输出第 $i$ 次询问的答案。如果无解输出 `impossible`。
## 样例

### 样例输入 #1
```
5 2
1 3
2 4
4 7
7 9
3 7
1 4
3 2
```
### 样例输出 #1
```
2
impossible

```
### 样例输入 #2
```
8 5
1 2
3 4
1 5
6 7
5 10
10 20
15 20
999999999 1000000000
1 6
1 7
2 4
3 3
5 8

```
### 样例输出 #2
```
3
4
impossible
0
impossible
```
## 提示

- 子任务 $1$ ($10$ 分)：每一个区间可以跳到至多一个其他区间。

- 子任务 $2$ ($10$ 分)：$n≤ 1000$，$q ≤100$。

- 子任务 $3$ ($15$ 分)：$n≤5000$。

- 子任务 $4$ ($15$ 分)：$q ≤100$。

- 子任务 $5$ ($20$ 分)：不存在两个区间 $i,j$ 满足 $[l_i, r_i] \subseteq [l_j,r_j]$。

- 子任务 $6$ ($30$ 分)：没有特殊限制。

对于所有数据，满足 $1≤n,q ≤100000$，$1≤l_i<r_i≤10^9$，$1≤s_i,t_i≤n$。


---

---
title: "[BalticOI 2022] Stranded Far From Home (Day2)"
layout: "post"
diff: 省选/NOI-
pid: P8393
tag: ['2022', 'BalticOI（波罗的海）']
---
# [BalticOI 2022] Stranded Far From Home (Day2)
## 题目描述

你就是不能放任不管……实际上你进行了闯入行动，并且最初所有事情就像计划一样进行。然而，你和你的助手之间的通讯情况变得十分糟糕（这是符合预期的，不是吗？）你没有安全返回吕贝克，而是被困在一个小岛上，并且你的潜艇没有燃料了。

为了及时返回参加 BOI 的颁奖仪式，你现在必须去岛的另一边坐船。然而，当地居民有着奇怪的传统。领带对他们来说非常重要，每个村庄都有自己喜欢的领带颜色，并且这个颜色可能会随着时间的推移而改变。

一份互联网上的报告显示，不同的村庄最初喜欢不同的领带颜色。不幸的是，这份报告已经相当过时了。从那时起，每个星期都有恰好一个村庄说服一个相邻的村庄喜欢和他们一样的领带颜色（如果两个村庄有公路直接相连，它们就是相邻的）。然而，只有当整个岛上喜欢第一个村庄的领带颜色不比喜欢第二个村庄的领带颜色的人少时，这种情况才会发生。足够长的时间过去了，所以现在所有的岛民都喜欢同样的领带颜色。

你基本可以肯定，如果你不戴符合他们喜好的领带，岛民就不会让你通过。因此，为了去渡口，你计划戴上岛民可能喜欢的每种颜色的领带。然而，戴太多的领带会让你看起来很可疑。编写一个程序，使用对岛屿的描述来计算你必须戴哪些领带。
## 输入格式

第一行包含两个整数 $n$，$m$。$n$ 表示村庄的个数，$m$ 表示岛上道路的条数。村庄从 $1$ 到 $n$ 编号。

接下来一行包含 $n$ 个整数 $s_1,\dots,s_n$，$s_i$ 表示村庄 $i$ 的居民数。

接下来 $m$ 行，每行两个整数 $a$，$b(1\le a,b\le n,a\neq b)$，表示村庄 $a$ 和 $b$ 之间有一条道路。所有村庄通过道路直接或间接相连。
## 输出格式

输出一个长度为 $n$ 的 $01$ 字符串。第 $i$ 位为 $1$ 当且仅当有可能所有的岛民现在都喜欢村庄 $i$ 最初喜欢的领带颜色。
## 样例

### 样例输入 #1
```
4 4
2 2 4 3
1 2
1 3
2 3
3 4

```
### 样例输出 #1
```
1110

```
### 样例输入 #2
```
4 3
4 2 2 1
1 2
3 2
4 1

```
### 样例输出 #2
```
1110

```
## 提示

【样例解释】

样例 #1 解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/g9hsfh2d.png)

【数据范围】

对于所有数据，满足 $1\le n\le 2\times 10^5$，$0\le m \le 2\times 10^5$，$1 \le s_ i\le 10^9$。


---

---
title: "[COCI 2021/2022 #6]  Superpozicija"
layout: "post"
diff: 省选/NOI-
pid: P8407
tag: ['2021', 'COCI（克罗地亚）']
---
# [COCI 2021/2022 #6]  Superpozicija
## 题目描述

世界闻名的物理学家 Juraj 最近发现了一种新的基本粒子——括号子（parenthesision）。括号子可以有开（（）或关（））两种状态。使用 Juraj 自制的粒子加速器，他创造了 $t$ 个由 $n$ 个括号子组成的叠加态序列。这 $t$ 个序列中的 $n$ 个括号子都是两个不同的位置和（不必不同的）状态的叠加态。如果序列被观测的话，括号子的波函数就将坍缩，每个括号子的位置和状态就是确定的了。Juraj 想知道这些括号子是否可以坍缩为一个合法的括号序列。

Juraj M. 博士知道这些革命性的且完全有科学依据的粒子的量子物理学已经超出了 COCI 的参赛者的知识范围，所以他提供了一个正式的题面：

给你 $t$ 个长度为 $2n$ 且由左右括号构成的括号序列。每个括号都恰好是一对括号中的一个。一对中的括号可以是不同的，也可以都是左括号或右括号。Juraj 想知道是否可以在每对括号中选一个，使得最后组成的括号序列是一个合法的括号序列。此外，如果是可能的，他需要你输出如何才能获得一个合法的括号序列。一个括号序列是合法的，如果它是一个空串，或者可以写成 $(A)$ 或者 $AB$，其中 $A$ 和 $B$ 是任意的合法括号序列。
## 输入格式

第一行包含一个整数 $t$，表示括号序列数。接下来描述这 $t$ 个序列。

第一行包含一个整数 $n$，表示这个序列里的括号对数。

第二行包含一个长度为 $2n$ 的字符串 $z$，$z$ 只由字符 `(` 和 `)` 组成。

接下来 $n$ 行，每行包含两个整数 $a_i,b_i$，数字 $1,2,\dots,2n$ 在其中都只出现恰好一次。
## 输出格式

输出 $t$ 行，第 $i$ 行输出一个 $01$ 序列，表示可能的括号选择方案。如果第 $i$ 个序列中，第 $j$ 对括号下标为 $a_j$ 的一个被选中，输出 $0$，如果是 $b_j$ 被选中，输出 $1$。如果没有合法的选择方案，输出 $-1$。
## 样例

### 样例输入 #1
```
1
4
()))((()
1 2
3 5
4 6
7 8
```
### 样例输出 #1
```
0 1 0 1
```
### 样例输入 #2
```
1
4
)()()()(
1 2
3 4
5 6
7 8
```
### 样例输出 #2
```
1 1 0 0
```
### 样例输入 #3
```
1
3
(()())
1 6
2 4
3 5
```
### 样例输出 #3
```
-1
```
## 提示

### 样例解释 1：

从原序列 `()))((()` 中，只有加粗的部分会留下 **(**))**)(**((**)**，即 **()()**，它是一个合法的括号序列。

### 数据范围：

对于 $9\%$ 的数据：$1\le n \le 10$。

对于 $9\%$ 的数据：$z[a_i]=z[b_i]$。

对于 $18\%$ 的数据：$b_i=a_i+1$。

对于 $100\%$ 的数据：$1\le t \le 10^5,\sum n\le10^5,1\le n \le 10^5 ,1\le a_i \le b_i \le 2\times n$。

本题分值与 [COCI 2021-2022#6](https://hsin.hr/coci/contest6_tasks.pdf) 分值相同，满分 $110$ 分。


---

---
title: "[JOI Open 2022] 跷跷板（Seesaw）"
layout: "post"
diff: 省选/NOI-
pid: P8424
tag: ['2022', 'Special Judge', 'O2优化', 'JOI（日本）']
---
# [JOI Open 2022] 跷跷板（Seesaw）
## 题目背景

**译自 [JOI Open 2022](https://contests.ioi-jp.org/open-2022/index.html) T1. [シーソー](http://s3-ap-northeast-1.amazonaws.com/data.cms.ioi-jp.org/open-2022/seesaw/2022-open-seesaw-statement.pdf) / [Seesaw](http://s3-ap-northeast-1.amazonaws.com/data.cms.ioi-jp.org/open-2022/seesaw/2022-open-seesaw-statement-en.pdf)。**
## 题目描述

一根长度为 ${10}^9$ 的直杆从左到右水平放置。你可以忽略这根杆的重量。共有 $N$ 个砝码挂在这根杆上，每个砝码的质量为一单位。这 $N$ 个砝码的位置两两不同。第 $i$（$1 \le i \le N$）个砝码的位置为 $A_i$。即，第 $i$ 个砝码到直杆最左端的距离为 $A_i$。

最开始，我们有一个宽度为 $w$ 的箱子。我们可以把这根杆子放在箱子上，支撑起杆从 $l$ 到 $r$（$0 \le l < r \le {10}^9$）的部分（包括两端），即，从杆上位置为 $l$ 到杆上位置为 $r$ 的区间。这里需要满足 $r = l + w$。之后我们不可以改变 $l$ 和 $r$ 的值。

接下来，我们去掉挂在杆上最左端或最右端的砝码。我们需要重复这个操作 $N - 1$ 次。在这个过程中，包括初始状态和最终状态，挂在杆上的所有砝码重心都需要保持在 $l$ 到 $r$ 之间（包括两端）。如果杆上挂有 $m$ 个砝码，位置分别为 $b_1, b_2, \ldots, b_m$，那么重心位置为 $\frac{b_1 + b_2 + \cdots + b_m}{m}$。

给定 $N$ 和这 $N$ 个砝码的位置 $A_1, A_2, \ldots, A_N$，写一个程序计算箱子的最小可能宽度 $w$。
## 输入格式

第一行，一个正整数 $N$。

第二行，$N$ 个非负整数 $A_1, A_2, \ldots, A_N$。
## 输出格式

输出箱子的最小可能宽度 $w$。只要你的输出与标准答案之间的绝对误差或相对误差小于等于 ${10}^{-9}$，你的程序就会被判为正确。
## 样例

### 样例输入 #1
```
3
1 2 4

```
### 样例输出 #1
```
0.8333333333

```
### 样例输入 #2
```
6
1 2 5 6 8 9

```
### 样例输出 #2
```
1.166666667

```
## 提示

**【样例解释 \#1】**

可让箱子的宽度为 $\frac{5}{6}$。我们令 $l = \frac{3}{2}, r = \frac{7}{3}$。进行如下操作：

- 最初，重心位置为 $\frac{7}{3}$。
- 第一次操作，我们去掉最右端的砝码（位置为 $4$ 的砝码）。重心位置变为 $\frac{3}{2}$。
- 第二次操作，我们去掉最左端的砝码（位置为 $1$ 的砝码）。重心位置变为 $2$。

在这个过程中，重心始终保持在 $l$ 到 $r$ 范围中。

因为箱子的宽度不会小于 $\frac{5}{6}$，因此输出 $\frac{5}{6}$ 的小数形式。

这组样例满足所有子任务的限制。

----

**【样例解释 \#2】**

这组样例满足所有子任务的限制。

----

**【数据范围】**

**本题采用捆绑测试。**

- 子任务 1（1 分）：$N \le 20$。
- 子任务 2（33 分）：$N \le 100$。
- 子任务 3（33 分）：$N \le 2000$。
- 子任务 4（33 分）：无特殊限制。

对于所有数据，满足 $2 \le N \le 2 \times 10^5$，$0 \le A_1 < A_2 < \cdots < A_N \le {10}^9$。


---

---
title: "Aleph-0 (Fan-made LGC 7)"
layout: "post"
diff: 省选/NOI-
pid: P8440
tag: ['洛谷原创', 'O2优化', '洛谷月赛']
---
# Aleph-0 (Fan-made LGC 7)
## 题目背景

Rolling_Code 是一个喜欢音游的女孩子。

![](https://cdn.luogu.com.cn/upload/image_hosting/rnkqui18.png)

Rolling_Code 打 $\aleph_0$ 的成绩如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/q298dfbe.png)

~~然而这并不是 IN。~~

慢报：Rolling_Code 将 Aleph-0 [IN 15(15.7)] All Perfect 了！
## 题目描述

LeaF 作为数学教师开办了一系列完美数学课堂，参加的学生包括了：Rolling_Code，你，美穗。助教：琪露诺。

第一节课，考试。

做出这道题目的同学可以获得特殊版 $\aleph_0$ 的率先游玩机会哦！——LeaF

~~Aleph-0 (Legacy - SP Lv.?)~~

Rolling_Code 对音游非常感兴趣，所以也非常想要获得这首曲子。但是它打开题面的时候震惊了：

> $f(x)=\begin{cases}0&x=0\\1&x=1\\2f(\frac{x}{2})&2|x\operatorname{and} x>0 \\ 2f(\frac{x-1}{2})+\frac{2}{x-1}f(\frac{x-1}{2})+x&\text{otherwise}\end{cases}$

求 $S=\left(\sum\limits_{i=0}^{r} f^k(i)\right)\bmod (10^9+7)$。

其中 $f^k(i)=(f(i))^k$。

本来是想要求 $r\rightarrow\aleph_0$ 的答案，可惜了啊，没有被定义，那就把 $r$ 范围放小一点吧。——LeaF

由于某些原因，LeaF 定义 $0^0=1$。

为了增加趣味，LeaF 还增加了多次对于 $r,k$ 的询问。

Rolling_Code 不会做，因此找你求助。

## 输入格式

**本题有多组数据。**

第一行一个数字 $t$，代表数据组数。

接下来 $t$ 行每行两个数字 $r_i,k_i$，表示第 $i$ 次询问中的 $r,k$。

## 输出格式

每行一个数字 $S_i$，表示第 $i$ 次询问的答案。

## 样例

### 样例输入 #1
```
5
1 2
14 2
51 2
4 2
1919810 2
```
### 样例输出 #1
```
1
6480
495741
57
936062395
```
### 样例输入 #2
```
5
43752 25
26701 25
43734 25
37553 25
67839 25
```
### 样例输出 #2
```
252345090
86394269
406573405
129371352
118835650
```
## 提示


**本题采用捆绑测试。**

**本题有多组数据。**

对于 $100\%$ 的数据，保证 $1\le t\le 10^3,1\le r\le 2^{63}-1,0\le k\le 30$。

Subtask 1：对于 $5\%$ 的数据，保证 $1\le t\le 100,1\le r\le 10^4$。

Subtask 2：对于 $10\%$ 的数据，保证 $1\le t\le 1000,1\le r\le 10^5$，**依赖于 Subtask 1**。

Subtask 3：对于 $10\%$ 的数据，保证 $1\le t\le 1000,1\le r\le 10^6,k$ 为定值。

Subtask 4：对于 $25\%$ 的数据：保证 $k=2$。

Subtask 5：对于最后 $50\%$ 的数据，无特殊限制，**依赖于 Subtask 1，2，3，4**。

---

### 样例解释

$f_0=0,f_1=1,f_2=2,f_3=6,f_4=4$。

对于 $r=4,k=2$ 的情况，$\text{Ans}=0^2+1^2+2^2+6^2+4^2=57$。


---

---
title: "旭日东升"
layout: "post"
diff: 省选/NOI-
pid: P8441
tag: ['洛谷原创', 'O2优化', '洛谷月赛']
---
# 旭日东升
## 题目背景

238 神教 #3

——还有多久，太阳才会出来？

——不知道……

在古老的传说中，你家附近的小村，由于惹怒了太阳神而被罚去了日光。庄稼纷纷枯死了，人们在寒冷与饥饿中求生。而小村的附近，除了你家以外，就是一片大荒。

神学开始在小村中兴起。越来越多的人成为了神学家，在当年集资修建的图书馆中没日没夜地研读着古籍。终于，大家在图书馆仓库的一个阴暗潮湿的角落里发现了一本——

古老而破旧的，据说早已失传的《祈日术》。
## 题目描述

书里的许多记载已不可辨识。根据残存的篇章，大家只能推测是要举办一场比赛，非常困难的比赛。至于比完之后怎么处理，完全没有头绪。

但大家决定试试，哪怕是自己摸索呢？

于是当你路过村子的时候，便看见展板上挂了这么一道题——唯一的比赛题。

> 维护一个不可重集合的序列 $a$，长度为 $n$。支持以下两种操作：
> 1. 给定 $l,r,x$，对于每个 $l\le i\le r$，将 $x$ 并入 $a_i$。
> 2. 给定 $l,r$，设 $S$ 把每个 $l\le i\le r$ 的 $a_i$ 并在一起的集合，输出 $S$ 中所有元素的和。

你看了看自己随身带着的电脑，决定去捧（za）个场。

那么，加油吧！
## 输入格式

输入数据的起始会有一个长度为 $2$ 的字符串，见【提示说明】处。它们可以用来帮你快速判断数据性质。

第二行两个正整数 $n,m$ 表示集合序列的长度和操作的次数，初始的集合 $a_1,a_2,\cdots,a_n$ 均为空。

接下来 $m$ 行每行先是三个正整数 $op,l,r$ 如题。如果 $op=1$，那么这一行还会有一个正整数 $x$ 如题。
## 输出格式

对于每行 $op=2$ 的输入，分别输出一个正整数，依次表示每次查询的结果。
## 样例

### 样例输入 #1
```
II
11 13
1 6 8 4
2 7 7
2 2 4
2 11 11
1 1 11 2
1 5 5 5
1 8 11 3
2 1 8
1 5 10 2
1 2 4 4
2 2 10
2 3 9
2 2 4
```
### 样例输出 #1
```
4
0
0
14
14
14
6

```
## 提示

**本题采用捆绑测试。**

对于 $100\%$ 的数据，保证 $1\le n,m,x\le10^5,1\le l\le r\le n$。

Subtask 1：对于 $10\%$ 的数据，保证 $1\le n,m,x\le100$;

Subtask 2：对于 $10\%$ 的数据，保证 $1\le n,m,x\le10^5$，第一行的字符串为 `PP`;

Subtask 3：对于 $20\%$ 的数据，保证 $1\le n,m,x\le10^5$，第一行的字符串为 `IP`;

Subtask 4：对于 $30\%$ 的数据，保证 $1\le n,m,x\le10^5$，第一行的字符串为 `PI`;

Subtask 5：对于最后 $30\%$ 的数据，无特殊限制。

---

输入第一行的字符串作用：该字符串包含两个为 `P` 或 `I` 的字符。如果第一个字符为 `P`，那么所有修改操作均满足 $l=r$；如果第二个字符为 `P`，那么所有查询操作均满足 $l=r$。对应位置为 `I` 表示无限制。

---

毫无疑问，你获得了第一名。

“好的，那么我们现在来宣读获奖名单！”

“第三名：……”（掌声，颁奖）

“第二名：……”（掌声，颁奖）

“第一……”

主持人突然停下来，揉揉眼睛，随即惶恐地看着天空。附近的人们好奇地凑上去看主持人手中的名单。只见第一名的名字正以一种不可名状的方式剧烈扭曲重构着，反复地在两种不同形态之间变换。

名单的上方突然出现了几个字符。随着字符逐渐变得清晰，人们看清了，是四个意义不明，但看着十分不耐烦的字符：“div1”。

这时，第一名的名字的变动也稳定了下来——就好像其中有一方主动退出了一样。

最终，名字固定在了五个字母：“David”。这并不是你随口报的那个假名。

人们又随主持人一并看向天际，一个看着大概五六岁的孩子正跌跌撞撞地跑来。“我是第一名！”他高兴地笑着。他的母亲——太阳神就站在远方，一脸怜爱地看着那个小小的背影。

一轮红日从地平线上喷薄而出。


---

---
title: "「REOI-p1」回忆"
layout: "post"
diff: 省选/NOI-
pid: P8461
tag: []
---
# 「REOI-p1」回忆
## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/3uztip2k.png)
![](https://cdn.luogu.com.cn/upload/image_hosting/rsmn7uez.png)

出题人：LinkyChristian

文案：小糯米
## 题目描述

“话虽如此，我们并没有四处游走让妖精一个一个地诞生。
只是在作为素材的巨大魂体上施予咒迹，好让她们带着接近人族的体格与人格自然诞生罢了。”

黄金妖精，自出生开始即刻下早夭诅咒之“人”，若非魔物无法抵御，是本不应在这茫茫尘世之中诞生之兵器。

每当前世之回忆涌上妖精之时，便是开启一朵含苞待放之花凋零倒计时之日。妖精的记忆，是由一条射线组成，为了便于叙述，我们不妨将射线当作数轴进行处理。在她们的记忆之中，会有若干个区间，在这个区间之内的回忆，是极易受到前世回忆的侵蚀的。但是由于生物的回忆本身自是不可探视分明之物，我们只能得知它们的 $m1$ 个开始区间 $[sl_i,sr_i]$ 与 $m2$ 个结束区间$[el_j,er_j]$ 。在这个回忆之内，会逐渐的有各种前世回忆涌出，侵蚀前期的记忆，当这些易于侵蚀的记忆区间全部被侵蚀殆尽后，黄金妖精便会就此“消失”。这些前世的回忆，可以看作成 $n$ 个不重叠的子段，这些子段的起点和终点恰好在一个开始区间和一个结束区间之内。而根据回忆的性质，不同的前世回忆的起点和终点自然是在不同的开始区间和结束区间内的。

记忆犹如湍急的小河，河水汩汩，顺流而下，搅动着石块与泥沙，不断地在水面上下浮沉。在上游之时，或许巉岩乱石，自有其沉重，因而水流清澈，自在澄明；越到入海口，石块逐渐的被泥沙所代替，哪怕只是微风逐浪，也会搅动其一片浑浊，将记忆都给摆弄的纠缠不清。每一次的记忆侵蚀，就如同翻腾的浪花，也许搅动的是泥沙，又或许只是将那些巨石推动了一隅。从数值上来叙述的话，第 $i$ 个起始区间被匹配能带来 $a_i$ 的贡献，第 $i$ 个结束区间被匹配能带来 $b_i$ 的贡献。当这些贡献达到了最大值，所谓的“侵蚀殆尽”，便会发生。那么现在这些妖精想知道，这个最大值究竟是多少。

特别的，如果数据本身无解，请输出 $-1$。


------------


简明题意：

给出 $m1$ 个开始区间 $[sl_i,sr_i]$ ，以及 $m2$ 个结束区间$[el_j,er_j]$ 。在数轴上选取不重叠的 $n$ 个子段，使得每个子段的起点和终点分别在一个开始区间和一个结束区间内。不同的子段的起点和终点需要在不同的开始区间和结束区间内。第 $i$ 个起始区间被匹配能带来 $a_i$ 的贡献，第 $i$ 个结束区间被匹配能带来 $b_i$ 的贡献。总贡献为选出的子段长度之和加上区间被匹配带来的贡献。求能最大总贡献是多少。

注意，将一个子段 $[l,r]$ 的长度定义为 $r-l$ ，这里的两个子段“重叠”定义为存在一个长度 > 0 的区间被同时包含在两个子段之内。

无解输出 $-1$。

## 输入格式

第一行三个整数 $n,m1,m2$

第二行 $2\times m1$ 个整数表示 $sl_1,sr_1,sl_2,sr_2,\dots , sl_{m1},sr_{m1}$，

第三行 $2\times m2$ 个整数表示 $el_1,er_1,el_2,er_2,\dots , el_{m2},er_{m2}$

第四行 $m1$ 个数表示 $a_1,a_2,\dots ,a_{m1}$

第五行 $m2$ 个数表示 $b_1,b_2,\dots ,b_{m2}$
## 输出格式

输出一个整数，表示最大的总贡献。
## 样例

### 样例输入 #1
```
2 2 2
1 3 7 8
4 5 9 10
0 0
0 0
```
### 样例输出 #1
```
7
```
### 样例输入 #2
```
2 3 3
1 2 3 5 100 200
5 7 9 10 400 500
1000 1000 0
1000 1000 0
```
### 样例输出 #2
```
4009
```
### 样例输入 #3
```
2 2 2
1 2 4 5
7 7 3 10
2 1
3 2
```
### 样例输出 #3
```
14
```
### 样例输入 #4
```
2 2 2
1 2 4 5
6 7 8 9
12 33
23 1
```
### 样例输出 #4
```
-1
```
## 提示

对于第一组样例，将起始区间 $[1,3]$ 与结束区间 $[4,5]$ 匹配，选取子段 $[1,5]$ 长度为 $5-1=4$，再将起始区间 $[7,8]$ 与结束区间 $[9,10]$ 匹配，选取子段 $[7,10]$ 长度为 $10-7=3$ ，选取总长度为 $4+3=7$ ,满足起始区间与结束区间存在 $n$ 个匹配，且选取的子段没有重合，总贡献最大。  
对于第二组样例，分别将 $[1,2]$ 与 $[9,10]$ ，$[3,5]$ 与 $[5,7]$ 匹配，选取子段 $[1,10]$ 和 $[5,5]$。   
对于第三组样例，分别将 $[1,2]$ 与 $[3,10]$ ，$[4,5]$ 与 $[7,7]$ 匹配，选取子段 $[1,5]$ 和 $[5,7]$。   
**subtask1:** 对于 $15\%$ 的数据，$n<=5,m1,m2<=10$。  
**subtask2:** 对于 $100\%$ 的数据，$n,m1,m2<=100$ ，题目中所有数据 $\le 10^3$。  


---

---
title: "「REOI-1」渺茫的希望"
layout: "post"
diff: 省选/NOI-
pid: P8464
tag: ['洛谷原创', '洛谷月赛']
---
# 「REOI-1」渺茫的希望
## 题目背景

威廉在与妖精们相处的日子里，留下了不少幸福的记忆。
## 题目描述

其中有一件令威廉记忆颇深的事情，便是活泼的少女们会时常的“抓住”威廉，让他来与她们一起读书。每逢此时，威廉总要开玩笑说“我脑筋超棒的哦，只要是五百年以上的古书尽管找我念”云云。但一来二去终究还是拗不过少女们的请求，半推半就的讲述一些以前的故事。长此以往，威廉在讲故事之余，会间或的用那些五百年以前的文字来和少女们玩一些“文字游戏”，游戏的规则如下：

威廉会给出一串由小写英文字母组成的字符串 $S$ ，其中每一个古文字便是由它的子串构成——如果我们说两个古文字不同，那么当且仅当这两个子串长度不同或长度相同且有任意一位不同——当两个不同的古文字拼凑在一起组成一个词语时，其音律、词义等各方面也会有所不同，于是威廉为了方便，就定义了一个“意境值”来衡量拼凑成的词语的质量。意境值的计算公式便是这两个本质不同子串在 $S$ 中出现的次数之和加上这两个本质不同子串的最长公共前缀的长度。

而当少女们把所有这些古文字拼凑成了一个句子后，威廉惊讶的发现，这个句子可以视作为任意两个古文字连边形成的完全图的最小生成树。他于是一鼓作气，推理出了这个句子的意境值的公式——这些最小生成树（因为最小生成树可能不唯一）的边权和。

其中，两个古文字的边权与她们组成的词语的意境值在数值上相等。

现在，威廉又在和少女们玩文字游戏了，威廉现在给出了一个字符串 $S$ ，但由于这是他临时起意写出的，他也不知道如果将它拼凑成一个句子，意境值究竟是多少——于是乎，威廉将求助的目光投向了你。

----

简要题意：

给定一个由小写英文字母组成的字符串 $S$ ，设在两个本质不同子串之间连边的权值为两个子串在 $S$ 中出现的次数之和加上这两个子串的最长公共前缀的长度，求对所有本质不同子串做最小生成树的边权之和（不含空串）。
## 输入格式

第一行一个整数 $n$ 。  
接下来一行 $n$ 个字符表示威廉给出的字符串 $S$ 。

## 输出格式

一行一个整数，表示这个句子的意境值。
## 样例

### 样例输入 #1
```
4
abab
```
### 样例输出 #1
```
15
```
## 提示

#### 样例解释 #1
![](https://cdn.luogu.com.cn/upload/image_hosting/fqjg81g9.png)

如图所示为一种最小生成树，边权和为 $15$。


#### 数据范围
对于 $10\%$ 的数据，$|S|\le 100$。  
对于 $30\%$ 的数据，$|S|\le 1000$。  
对于 $100\%$ 的数据，$1\le|S|\le 10^5$。  


---

---
title: "「REOI-1」调整圣剑"
layout: "post"
diff: 省选/NOI-
pid: P8465
tag: ['洛谷原创', '洛谷月赛']
---
# 「REOI-1」调整圣剑
## 题目背景

威廉从仓库搬出了瑟尼欧里斯。

六十八号悬浮岛的边陲，稍稍隆起的小山丘上。

风势平稳，空气澄净，星光柔和，各方面条件都合适的夜晚。

他掀开盖着瑟尼欧里斯的布，让剑身透风。

威廉注入些许魔力。太阳穴稍微会痛，不过这种程度还没什么大不了。

瑟尼欧里斯顿时绽发柔和光芒。

「——调整开始。」

## 题目描述

具体而言，圣剑瑟尼欧里斯由 $n$ 个护符组成，每个护符有一个权值 $a_i$。威廉会进行 $k$ 次调整，每次调整一个护符，并获得与护符权值相等的疲惫值。

然而由于护符间的某种奇怪联系，威廉调整护符时有一些限制，这些限制形如 $(i,j,x,y)$，表示威廉必须在第 $i$ 次调整时调整前 $x$ 个护符中的一个 **或** 在第 $j$ 次调整时调整后 $y$ 个护符中的一个，否则圣剑就会崩溃。

现在，珂朵莉想知道威廉在调整完所有护符后的最小疲惫值是多少。

**注意每个护符可以调整不止一遍。**
## 输入格式

第一行三个正整数 $n,k,q$。

接下来一行 $n$ 个正整数 $a_1,a_2,a_3...a_n$。

接下来 $q$ 行，每行 $4$ 个正整数 $i,j,x,y$。
## 输出格式

一个数表示威廉疲惫值的最小值。
## 样例

### 样例输入 #1
```
3 2 1
2 1 3
1 2 2 2 

```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
3 2 1
2 1 3
1 2 1 1 
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
10 4 2
5 2 1 3 3 1 4 5 5 3 
4 3 1 7
2 4 5 5
```
### 样例输出 #3
```
4
```
## 提示

样例解释：

对于第一组样例，第一次选取 $a_2$ ，第二次选取 $a_2$ 。可以证明这是满足限制的最小值。

对于第二组样例，第一次选择 $a_1$ ，第二次选择 $a_2$ 是为满足限制的最小值。

对于 $24\%$ 的数据：$1\le n \le 20,1\le k,q \le 14$ ；

对于 $56\%$ 的数据：$1\le n \le 100,1\le k,q \le 60$ ；

对于 $80\%$ 的数据：$1\le n \le 10^5, 1\le k,q\le 10^3$ ；

对于 $100\%$ 的数据：$1\le n \le 10^5,1\le k,q\le 10^4,1\le a_i\le 10^5$。

对于每一次询问有 $1 \le i,j \le k$ , $1 \le x,y \le n$。


---

---
title: "「GLR-R3」惊蛰"
layout: "post"
diff: 省选/NOI-
pid: P8476
tag: ['洛谷原创', 'O2优化', '洛谷月赛']
---
# 「GLR-R3」惊蛰
## 题目背景

&emsp;&emsp;「微雨众卉新，一雷惊蛰始」

---

&emsp;&emsp;中午，休息室，阿绫肩膀上。

&emsp;&emsp;“我有一个愿望，参加全国音乐祭，获奖，和阿绫一起，摆脱这训练的苦海。”

&emsp;&emsp;“为热爱而到来，为抽身而努力……吗”。

&emsp;&emsp;正午的阳光渗过窗帘，抚上困倦的人儿的脸颊。天依的左手悄悄搭上阿绫怀里的吉他，

&emsp;&emsp;“铮——”

&emsp;&emsp;蛰虫被雷声唤醒，没人向他们保证雨的降临。

---

&emsp;&emsp;**惊蛰**&emsp;「我愿把岁月磨成望镜寻遍这星空　将微光聚焦手心紧紧握住不放松」
## 题目描述

比赛临近，各式测试也丰富了起来，作为天依他们的专业分析师，你的工作是统计分析队员们表现情况——总之，某领导要来慰问，所以你被要求修改出一份令人赏心悦目的分析报告。

在已有的 $n$ 次测试中，对于某位特定的选手，他在第 $i$ 次测试的**波动值**是非负整数 $a_i$。波动值越小表示选手在测试中的心态和发挥越稳定，所以你需要“略微调整”波动值序列 $\{a_n\}$，得到另一个非负整数序列 $\{b_n\}$。不过，做人不能昧良心，但报告又必须好看，所以 $\{b_n\}$ 有如下要求：

- $\{b_n\}$ **单调不递增**，选手越来越厉害嘛；

- 对于每个 $i$，如果 $b_i<a_i$，老师会不高兴，所以你需要花费 $C$ 单位的精力说服老师（其中 $C$ 为给定常数）；
- 对于每个 $i$，如果 $a_i\le b_i$，选手会不高兴，而且可能很不高兴，所以你需要花费 $b_i-a_i$ 单位的精力安慰选手。

你希望在满足条件的情况下，**最小化**花费的精力之和。作为成熟的信竞选手，你自然需要自己动手，求出这一最小化的结果。

#### 形式化题意

给定非负整数序列 $\{a_n\}$，定义函数 $f(x,y)$ 为

$$
f(x,y)=\begin{cases}
x-y,&x\ge y\\
C,&x< y
\end{cases},
$$

其中 $C$ 是给定常数。请构造一个**不增**非负整数序列 $\{b_n\}$，最小化

$$
\sum_{i=1}^nf(b_i,a_i).
$$

你仅需输出这一最小化的结果。

## 输入格式

第一行两个整数，表示序列长度 $n$ 和给定常数 $C$。

接下来一行表示序列 $\{a_n\}$ 。
## 输出格式

输出一行一个整数，表示最小化的结果。
## 样例

### 样例输入 #1
```
3 3
4 5 2
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
10 5
12 17 20 2 0 1 13 6 10 1
```
### 样例输出 #2
```
26
```
## 提示

#### 样例 #1 解释

构造 $\{b_n\}=\{5,5,2\}$，可见：

$$
\begin{aligned}
\sum_{i=1}^nf(b_i,a_i) &=  f(5,4)+f(5,5)+f(2,2)\\
&= 1+0+0\\
&= 1.
\end{aligned}
$$

#### 样例 #2 解释

构造 $\{b_n\}=\{12,11,4,2,1,1,1,1,1,1\}$，可以得到答案。

### 数据规模与约定

**本题采用 Subtask 的计分方式。**

设 $V$ 为序列 $\{a_n\}$ 中元素以及常数 $C$ 的值域。

对于 $100\%$ 的数据，$1\le n\le10^6$，$V\subseteq[0,10^9]$。

对于不同的子任务，作如下约定：

| 子任务编号 |   $n$   |       $V$       | 特殊性质 | 子任务分值 |
| :--------: | :-------: | :-------------: | :------: | :--------: |
|    $1$     | $\le10^3$ | $\subseteq[0,10^9]$ |    无    |    $25$    |
|    $2$     | $\le10^5$ | $\subseteq[0,10^2]$ |  无   |    $15$    |
|    $3$     | $\le10^6$ | $\subseteq[0,10^9]$ |  **A**   |    $5$    |
|    $4$     | $\le10^6$ | $\subseteq[0,10^9]$ |  **B**   |    $15$    |
|    $5$     | $\le10^5$ | $\subseteq[0,10^9]$ |  无   |    $20$    |
|    $6$     | $\le10^6$ |   $\subseteq[0,10^9]$   |    无    |    $20$    |

- **特殊性质 A**：对于常数 $C$ ，满足 $C = 0$。
- **特殊性质 B**：对于序列 $\{a_n\}$ ，满足元素单调**递增**。


---

---
title: "[IOI 2022] 鲶鱼塘"
layout: "post"
diff: 省选/NOI-
pid: P8490
tag: ['2022', 'IOI', '交互题']
---
# [IOI 2022] 鲶鱼塘
## 题目背景

# 滥用评测资源者封号

### 由于技术限制，请不要使用 C++ 14 (GCC 9) 提交本题。

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 main 函数。

原题时间限制 1s，为了节约评测资源，时间限制修改为 0.5s。
## 题目描述

Bu Dengklek 有一个鲶鱼塘。这个鲶鱼塘是由 $N \times N$ 个网格单元构成的池塘。每个单元都是相同大小的正方形。网格各列自西向东编号为从 $0$ 到 $N - 1$，各行自南向北编号为从 $0$ 到 $N - 1$。我们把坐落在网格第 $c$ 列第 $r$ 行处（$0 \le c \le N - 1$，$0 \le r \le N - 1$）的单元记为单元 $(c, r)$。

池塘里总共有 $M$ 条鲶鱼，编号为从 $0$ 到 $M - 1$，分别位于**不同的**单元中。对每个满足 $0 \le i \le M - 1$ 的 $i$，鲶鱼 $i$ 在单元 $(X_i, Y_i)$ 中，其重量为 $W_i$ 克。

Bu Dengklek 想造些长堤来抓鲶鱼。在第 $c$ 列中长度为 $k$ 的长堤（对于所有 $0 \le c \le N - 1$ 和 $1 \le k \le N$），是一个从第 $0$ 行跨到第 $k - 1$ 行的矩形，盖住单元 $(c, 0), (c, 1), \ldots, (c, k - 1)$。对于每一列，Bu Dengklek 可以按照她自己选择的某个长度造长堤，也可以不造。

鲶鱼 $i$（对所有满足 $0 \le i \le M - 1$ 的 $i$）能被抓住，如果有某个长堤紧邻它的西侧或东侧，而且没有长堤盖住它所在的单元；也就是说，如果
* 单元 $(X_i - 1, Y_i)$ 或 $(X_i + 1, Y_i)$ 中 **至少有一个** 被某个长堤盖住，而且
* 没有长堤盖住单元 $(X_i, Y_i)$。

例如，考虑尺寸为 $N = 5$，有 $M = 4$ 条鲶鱼的池塘：

* 鲶鱼 $0$ 在单元 $(0, 2)$ 中，重量为 $5$ 克。
* 鲶鱼 $1$ 在单元 $(1, 1)$ 中，重量为 $2$ 克。
* 鲶鱼 $2$ 在单元 $(4, 4)$ 中，重量为 $1$ 克。
* 鲶鱼 $3$ 在单元 $(3, 3)$ 中，重量为 $3$ 克。

Bu Dengklek 可以这样来造长堤：

| 造长堤前 | 造长堤后 |
| :---: | :---: |
| ![](https://cdn.luogu.com.cn/upload/image_hosting/2rcnqc7k.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/yesaiovt.png) |

单元中的数字表示该单元中鲶鱼的重量。
阴影单元被长堤盖住。
在该场景中，鲶鱼 $0$（在单元 $(0, 2)$ 中）和鲶鱼 $3$（在单元 $(3, 3)$ 中）能被抓住。
鲶鱼 $1$（在单元 $(1, 1)$ 中）没被抓住，因为有一个长堤盖住了它所在的单元；鲶鱼 $2$（在单元 $(4, 4)$ 中）没被抓住，因为没有长堤紧邻它的西侧或东侧。

Bu Dengklek 希望造出来的长堤能让被抓住的鲶鱼的总重量尽量大。
你的任务是求出 Bu Dengklek 通过造长堤能抓住的鲶鱼的最大总重量。
## 输入格式

你需要实现下面的函数：

```go
int64 max_weights(int N, int M, int[] X, int[] Y, int[] W)
```

* $N$：池塘的尺寸。
* $M$：鲶鱼的数量。
* $X$, $Y$：长度为 $M$ 的两个数组，给出鲶鱼的位置。
* $W$：长度为 $M$ 的数组，给出鲶鱼的重量。
* 该函数需要返回一个整数，表示 Bu Dengklek 通过造长堤能抓住的鲶鱼的最大总重量。
* 该函数将被恰好调用一次。
## 输出格式

考虑如下调用：

```go
max_weights(5, 4, [0, 1, 4, 3], [2, 1, 4, 3], [5, 2, 1, 3])
```

该例子的解释请见前面的题面。

在造完所述的长堤后，Bu Dengklek 能抓住鲶鱼 $0$ 和 $3$，其总重量为 $5 + 3 = 8$ 克。
因为无法造出能够抓住总重量超过  $8$ 克的鲶鱼的长堤，函数应当返回 $8$。
## 提示

### 约束条件

* $2 \le N \le 100\;000$
* $1 \le M \le 300\;000$
* $0 \le X_i \le N - 1$，$0 \le Y_i \le N - 1$（对所有满足 $0 \le i \le M - 1$ 的 $i$）
* $1 \le W_i \le 10^9$（对所有满足 $0 \le i \le M - 1$ 的 $i$）
* 任意两条鲶鱼都不会在同一单元中。
  换句话说，$X_i \neq X[j]$ 或 $Y_i \neq Y[j]$（对于所有满足 $0 \le i \lt j \le M - 1$ 的 $i$ 和 $j$）。

### 子任务

1. （3 分） $X_i$ 是偶数（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （6 分） $X_i \le 1$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （9 分） $Y_i = 0$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （14 分） $N \le 300$，$Y_i \le 8$（对于所有满足 $0 \le i \le M - 1$ 的 $i$）
1. （21 分） $N \le 300$
1. （17 分） $N \le 3000$
1. （14 分） 在每列中至多有 $2$ 条鲶鱼。
1. （16 分） 没有额外限制。

### 评测程序示例

评测程序示例读取如下格式的输入：

* 第 $1$ 行：$N \; M$
* 第 $2 + i$ 行（$0 \le i \le M - 1$）：$X_i \; Y_i \; W_i$

评测程序示例将按照如下格式打印你的答案：

* 第 $1$ 行：`max_weights` 的返回值

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`int`、`int64`、`int[]`（数组）和 `int[][]`（数组的数组）。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `int` | `int64`     | `int[]`            |
| ------- | ----- | ----------- | ------------------ |
| `void ` | `int` | `long long` | `std::vector<int>` |

| `int[][]`                       | 数组 `a` 的长度 |
| ------------------------------- | ------------------- |
| `std::vector<std::vector<int>>` | `a.size()`          |



---

---
title: "[IOI 2022] 最罕见的昆虫"
layout: "post"
diff: 省选/NOI-
pid: P8494
tag: ['2022', 'IOI', '交互题', 'Special Judge']
---
# [IOI 2022] 最罕见的昆虫
## 题目背景

# 滥用评测资源者封号

**本题为交互题。**

您**不需要也不应该**在提交的程序中包含 `insects.h` 头文件和主函数。

但是在您的程序中，需要声明以下三个函数：

```cpp
void move_inside(int i);
void move_outside(int i);
int press_button();
```

例如，您的程序可以是这样：

```cpp
#include <bits/stdc++.h>
using namespace std;

void move_inside(int i);
void move_outside(int i);
int press_button();

int min_cardinality(int N) {
	// Code Here
}
```
## 题目描述

Pak Blangkon 的房子四周有 $N$ 只昆虫，编号为 $0$ 至 $N-1$。每只昆虫有一个**类型**，以从 $0$ 至 $10^9$（包含 $0$ 和 $10^9$）的整数编号。可能有多只昆虫类型相同。

假设将昆虫按照类型分组。我们定义**最常见**昆虫类型的基数是昆虫最多的分组中的昆虫数。类似地，**最罕见**昆虫类型的基数是昆虫最少的分组中的昆虫数。

例如，假设有 $11$ 只昆虫，类型分别为 $[5, 7, 9, 11, 11, 5, 0, 11, 9, 100, 9]$。在此情形中，**最常见**昆虫类型的基数是 $3$，是因为类型 $9$ 和类型 $11$ 的分组均有最多数目的昆虫，每个分组都有 $3$ 只。**最罕见**昆虫类型的基数是 $1$，是因为类型 $7$、类型 $0$ 和类型 $100$ 的分组均有最少数目的昆虫，每个分组都有 $1$ 只。

Pak Blangkon 不知道这些昆虫的类型。他有一台单按钮的机器，可以提供昆虫类型相关的信息。刚开始时，机器是空的。在使用机器时，可以做如下三种操作：

1. 将一只昆虫放进机器。
2. 将一只昆虫取出机器。
3. 按下机器的按钮。

每种操作最多可以做 $40\;000$ 次。

每当按下按钮时，机器会报告在机器内的**最常见**昆虫类型的基数。

你的任务是使用上述机器，确定 Pak Blangkon 的房子四周所有 $N$ 只昆虫中**最罕见**昆虫类型的基数。此外，在某些子任务里，你的得分取决于机器执行某种操作的最大次数（详见子任务一节）。
## 输入格式

你要实现以下函数：

```go
int min_cardinality(int N)
```

- $N$：昆虫数量。
- 此函数应返回 Pak Blangkon 的房子四周所有 $N$ 只昆虫中**最罕见**昆虫类型的基数。
- 此函数恰好被调用一次。

该函数可调用以下几个函数：

```go
void move_inside(int i)
```

- $i$：将被放进机器的昆虫编号。编号 $i$ 的取值范围是 $0$ 至 $N-1$（包含 $0$ 和 $N-1$）。
- 如果昆虫已在机器内，函数调用不会影响机器内昆虫的集合。但是，调用仍会被计入此类操作的次数。
- 此函数最多可以被调用 $40\;000$ 次。

```go
void move_outside(int i)
```

- $i$：将被从机器中取出的昆虫编号。编号 $i$ 的取值范围是 $0$ 至 $N-1$（包含 $0$ 和 $N-1$）。
- 如果昆虫已在机器外，函数调用不会影响机器内昆虫的集合。但是，调用仍会被计入此类操作的次数。
- 此函数最多可以被调用 $40\;000$ 次。

```go
int press_button()
```

- 此函数返回机器内**最常见**昆虫类型的基数。
- 此函数最多可以被调用 $40\;000$ 次。
- 评测程序**不是适应性**的。也就是说，所有 $N$ 只昆虫的类型在 `min_cardinality` 调用前已经确定。

## 输出格式

考虑在某个场景下，有 $6$ 只类型分别为 $[5, 8, 9, 5, 9, 9]$ 的昆虫。
函数 `min_cardinality` 的调用方式如下：

```go
min_cardinality(6)
```

此函数按以下次序调用了 `move_inside`、`move_outside` 和 `press_button`。

|     函数调用      |  返回值  |       机器内的昆虫       |   机器内的昆虫类型   |
| :---------------: | :------: | :----------------------: | :------------------: |
|                   | $\\{\\}$ |          $[\ ]$          |
| `move_inside(0)`  |          |        $\\{0\\}$         |        $[5]$         |
| `press_button()`  |   $1$    |        $\\{0\\}$         |        $[5]$         |
| `move_inside(1)`  |          |       $\\{0, 1\\}$       |       $[5, 8]$       |
| `press_button()`  |   $1$    |       $\\{0, 1\\}$       |       $[5, 8]$       |
| `move_inside(3)`  |          |     $\\{0, 1, 3\\}$      |     $[5, 8, 5]$      |
| `press_button()`  |   $2$    |     $\\{0, 1, 3\\}$      |     $[5, 8, 5]$      |
| `move_inside(2)`  |          |    $\\{0, 1, 2, 3\\}$    |    $[5, 8, 9, 5]$    |
| `move_inside(4)`  |          |  $\\{0, 1, 2, 3, 4\\}$   |  $[5, 8, 9, 5, 9]$   |
| `move_inside(5)`  |          | $\\{0, 1, 2, 3, 4, 5\\}$ | $[5, 8, 9, 5, 9, 9]$ |
| `press_button()`  |   $3$    | $\\{0, 1, 2, 3, 4, 5\\}$ | $[5, 8, 9, 5, 9, 9]$ |
| `move_inside(5)`  |          | $\\{0, 1, 2, 3, 4, 5\\}$ | $[5, 8, 9, 5, 9, 9]$ |
| `press_button()`  |   $3$    | $\\{0, 1, 2, 3, 4, 5\\}$ | $[5, 8, 9, 5, 9, 9]$ |
| `move_outside(5)` |          |  $\\{0, 1, 2, 3, 4\\}$   |  $[5, 8, 9, 5, 9]$   |
| `press_button()`  |   $2$    |  $\\{0, 1, 2, 3, 4\\}$   |  $[5, 8, 9, 5, 9]$   |

至此，已有充分信息表明，最罕见昆虫类型的基数是 $1$。
因此，函数 `min_cardinality` 应返回 $1$。

在这个例子里，`move_inside` 被调用 $7$ 次，`move_outside` 被调用 $1$ 次，`press_button` 被调用 $6$ 次。
## 提示

### 约束条件

- $2 \le N \le 2000$。

### 子任务

1. （10 分） $N \le 200$；
2. （15 分） $N \le 1000$；
3. （75 分） 没有额外的约束条件。

如果在某个测试用例上，函数 `move_inside`、`move_outside` 或 `press_button` 的调用次数不符合“实现细节”中给出的约束条件，或者 `min_cardinality` 的返回值不正确，你的解答在此子任务上得分为 $0$。

令 $q$ 为以下三个值的 **最大值**：`move_inside` 的调用次数、`move_outside` 的调用次数、`press_button` 的调用次数。

在子任务 3 中，你可能会得部分分。令 $m$ 为此子任务所有测试用例的 $\frac{q}{N}$ 的最大值。你在此子任务的得分将根据以下表格计算：

|       条件       |                   得分                   |
| :--------------: | :--------------------------------------: |
|    $20 \lt m$    | $0$ （CMS 报告“`Output isn’t correct`”） |
| $6 \lt m \le 20$ |           $\frac{225}{m - 2}$            |
| $3 \lt m \le 6$  |          $81 - \frac{2}{3} m^2$          |
|    $m \le 3$     |                   $75$                   |

### 评测程序示例

令 $T$ 是长度为 $N$ 的整数数组，其中 $T[i]$ 是编号为 $i$ 的昆虫的类型。

评测程序示例按以下格式读取输入：

- 第 $1$ 行：$N$；
- 第 $2$ 行：$T[0] \; T[1] \; \ldots \; T[N - 1]$。

如果评测程序示例检测到非法行为，评测程序示例将输出 `Protocol Violation: <MSG>`，其中 `<MSG>` 为如下某种类型：

<!-- IMPORTANT NOTE TO TRANSLATORS: THESE MESSAGES (IN BACKTICKS), AS WELL AS 'Protocol Violation:' ABOVE SHOULD NOT BE TRANSLATED -->

- `invalid parameter`：在函数调用 `move_inside` 或 `move_outside` 时，参数 $i$ 的值不在 $0$ 至 $N-1$ 的范围内（包括 $0$ 和 $N-1$）。
- `too many calls`：函数 `move_inside`、`move_outside` 或 `press_button` 中**某个**的调用次数超过 $40\;000$ 次。

否则，评测程序示例按以下格式输出：

- 第 $1$ 行：`min_cardinality` 的返回值；
- 第 $2$ 行：$q$。

### 约定

题面在给出函数接口时，会使用一般性的类型名称 `void`、`bool`、`int`、`int[]`（数组）和 `union(bool, int[])`。

在 C++ 中，评测程序会采用适当的数据类型或实现，如下表所示：

| `void ` | `bool` | `int` | `int[]`            |
| ------- | ------ | ------| ------------------ |
| `void ` | `bool` | `int` | `std::vector<int>` |

| `union(bool, int[])`                   | 数组 `a` 的长度 |
| -------------------------------------- | ------------------- |
| `std::variant<bool, std::vector<int>>` | `a.size()`          |

C++ 语言里，`std::variant` 定义在 `<variant>` 头文件中。
一个返回类型为 `std::variant<bool, std::vector<int>>` 的函数可以返回一个 `bool` 或一个 `std::vector<int>`。
以下示例代码给出了三个返回 `std::variant` 的函数，它们都能正常工作：

```cpp
std::variant<bool, std::vector<int>> foo(int N) {
    return N % 2 == 0;
}

std::variant<bool, std::vector<int>> goo(int N) {
    return std::vector<int>(N, 0);
}

std::variant<bool, std::vector<int>> hoo(int N) {
    if (N % 2 == 0) {
        return false;
    }

    return std::vector<int>(N, 0);
}
```


---

---
title: "[NOI2022] 众数"
layout: "post"
diff: 省选/NOI-
pid: P8496
tag: ['2022', 'NOI', 'O2优化']
---
# [NOI2022] 众数
## 题目描述

**对于一个序列，定义其众数为序列中出现次数严格大于一半的数字。注意该定义与一般的定义有出入，在本题中请以题面中给出的定义为准。**

一开始给定 $n$ 个长度不一的正整数序列，编号为 $1 \sim n$，初始序列可以为空。这 $n$ 个序列被视为存在，其他编号对应的序列视为不存在。

有 $q$ 次操作，操作有以下类型:

- $1 \ x \ y$：在 $x$ 号序列末尾插入数字 $y$。保证 $x$ 号序列存在，且 $1 \le x, y \le n + q$。
- $2 \ x$：删除 $x$ 号序列末尾的数字，保证 $x$ 号序列存在、非空，且 $1 \le x \le n + q$。
- $3 \ m \ x_1 \ x_2 \ x_m$：将 $x_1, x_2, \ldots, x_m$ 号序列顺次拼接，得到一个新序列，并询问其众数。如果不存在满足上述条件的数，则返回 $-1$。数据保证对于任意 $1 \le i \le m$，$x_i$ 是一个仍然存在的序列，$1 \le x_i \le n + q$，且拼接得到的序列非空。**注意：不保证 $\boldsymbol{x_1, \ldots, x_m}$ 互不相同，询问中的合并操作不会对后续操作产生影响。**
- $4 \ x_1 \ x_2 \ x_3$：新建一个编号为 $x_3$ 的序列，其为 $x_1$ 号序列后顺次添加 $x_2$ 号序列中数字得到的结果，然后删除 $x_1, x_2$ 对应的序列。此时序列 $x_3$ 视为存在，而序列 $x_1, x_2$ 被视为不存在，在后续操作中也不会被再次使用。保证 $1 \le x_1, x_2, x_3 \le n + q$、$x_1 \ne x_2$、序列 $x_1, x_2$ 在操作前存在、且在操作前没有序列使用过编号 $x_3$。
## 输入格式

输入的第一行包含两个正整数 $n$ 和 $q$，分别表示数列的个数和操作的次数，保证 $n \le 5 \times {10}^5$、$q \le 5 \times {10}^5$。

接下来 $n$ 行，第 $i$ 行表示编号为 $i$ 的数列。每一行的第一个非负整数 $l_i$ 表示初始第 $i$ 号序列的数字个数，接下来有 $l_i$ 个非负整数 $a_{i,j}$ 按顺序表示数列中的数字。假定 $C_l = \sum l_i$ 代表输入序列长度之和，则保证 $C_l \le 5 \times {10}^5$、$a_{i,j} \le n + q$。

接下来 $q$ 行，每行若干个正整数，表示一个操作，并按照题面描述中的格式输入。

假定 $C_m = \sum m$ 代表所有操作 $3$ 需要拼接的序列个数之和，则保证 $C_m \le 5 \times {10}^5$。
## 输出格式

对于每次询问，一行输出一个整数表示对应的答案。
## 样例

### 样例输入 #1
```
2 8
3 1 1 2
3 3 3 3
3 1 1
3 1 2
4 2 1 3
3 1 3
2 3
3 1 3
1 3 1
3 1 3

```
### 样例输出 #1
```
1
3
-1
3
-1

```
### 样例输入 #2
```
4 9
1 1
1 2
1 3
1 4
3 4 1 2 3 4
1 1 2
3 2 1 2
2 3
3 3 1 2 3
1 4 4
1 4 4
1 4 4
3 4 1 2 3 4

```
### 样例输出 #2
```
-1
2
2
4

```
## 提示

**【样例解释 \#1】**

第一次询问查询序列 $1$ 的众数。由于序列包含两个 $1$，超过序列长度的一半，因此众数为 $1$。

第二次询问查询序列 $2$ 的众数。由于序列只包含 $3$，因此众数为 $3$。

第三次询问询问序列 $3$ 的众数。此时序列 $3$ 为 $(3, 3, 3, 1, 1, 2)$，不存在出现次数大于 $3$ 次的数，因此输出为 $-1$。

----

**【样例解释 \#2】**

第一次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 3, 4)$，不存在出现次数大于两次的数，因此输出为 $-1$。

第四次询问查询序列 $1, 2, 3, 4$ 拼接后得到的序列的众数。拼接的结果为 $(1, 2, 2, 4, 4, 4, 4)$，众数为 $4$。

----

**【样例 \#3】**

见附件中的 `major/major3.in` 与 `major/major3.ans`。

该样例满足测试点 $1 \sim 3$ 的限制。

----

**【样例 \#4】**

见附件中的 `major/major4.in` 与 `major/major4.ans`。

该样例满足测试点 $11 \sim 12$ 的限制。

----

**【数据范围】**

对于所有测试数据，保证 $1 \le n, q, C_m, C_l \le 5 \times {10}^5$。

| $n, q$ | $C_m, C_l$ | 测试点编号 | 特殊性质 A | 特殊性质 B | 特殊性质 C |
|:-:|:-:|:-:|:-:|:-:|:-:|
| $\le 300$ | $\le 300$ | $1 \sim 3$ | 否 | 否 | 是 |
| $\le 4000$ | $\le 4000$ | $4 \sim 7$ | 否 | 否 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $8$ | 是 | 是 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $9$ | 是 | 否 | 否 |
| $\le {10}^5$ | $\le {10}^5$ | $10$ | 否 | 是 | 否 |
| $\le {10}^5$ | $\le {10}^5$ | $11 \sim 12$ | 否 | 否 | 是 |
| $\le {10}^5$ | $\le {10}^5$ | $13$ | 否 | 否 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $14$ | 是 | 是 | 是 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $15$ | 是 | 否 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $16$ | 否 | 是 | 否 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $17 \sim 18$ | 否 | 否 | 是 |
| $\le 5 \times {10}^5$ | $\le 5 \times {10}^5$ | $19 \sim 20$ | 否 | 否 | 否 |

特殊性质 A：保证 $n = 1$ 且没有操作 $4$。  
特殊性质 B：保证任意时刻任何序列中只有数字 $1$ 和 $2$。  
特殊性质 C：保证没有操作 $2$。


---

---
title: "[NOI2022] 挑战 NPC Ⅱ"
layout: "post"
diff: 省选/NOI-
pid: P8499
tag: ['2022', 'NOI', 'O2优化']
---
# [NOI2022] 挑战 NPC Ⅱ
## 题目描述

诸由杨是一名咸鱼大学生，虽然他每天仍然幻想着在多项式时间内解决 NPC 问题。

诸由杨上课的时候了解到子图同构问题是一个 NPC 问题。他打算给出一个子图同构问题的多项式判定算法，间接地去证明 P = NP，这样他一定可以凭借这个伟大的工作荣获图灵奖！只可惜诸由杨才疏学浅，连子图同构问题属于 NPC 的证明都没有想出来。因而他退而求其次，准备判定一个更加简单的问题：

给定两棵有根树 $G, H$。设 $\lvert G \rvert$ 代表树 $G$ 中的节点个数，则这两棵树满足如下限制：$1 \leq \lvert H \rvert \leq \lvert G \rvert \leq \lvert H \rvert + k$。这里诸由杨保证 $k$ 是一个小常数。

诸由杨可以删除 $G$ 中的若干个节点，假定删除节点后后得到的子图为 $G'$。他想要知道是否存在一种删除节点的方式，使得删除后得到的子图 $G'$ 满足如下条件：

- $G'$ 连通。
- $G'$ 包含 $G$ 中的根节点（也就是说 $G$ 根节点在删除过程中没有被删除）。
- $G'$ 和 $H$ 同构（也就是说存在一种让 $G'$ 中点重标号的方式，使得重标号得到的图和 $H$ 完全相同，且 $G$ 中的根节点经过重标号后恰好为 $H$ 的根节点）。
## 输入格式

本题有多组测试数据。

输入的第一行依次包含两个正整数 $C,T$ 和一个非负整数 $k$，三个数字分别表示当前测试点编号，测试数据组数和题目中给定的常数。如果当前测试数据为样例则 $C = 0$。保证 $T \leq 500$、$k \leq 5$。

对于每一组测试数据：

输入的第一行包含一个正整数 $n_1$，表示树 $G$ 中的节点个数，保证 $1 \leq n_1 \leq {10}^5$，且 $\sum n_1 \leq 5 \times {10}^5$。

输入的第二行包含 $n_1$ 个整数，描述了树 $G$ 的结构。具体地，第 $i$（$1 \leq i \leq n_1$）个整数 $a_i$ 表示在树 $G$ 中节点 $i$ 的父节点，如果其为根节点则 $a_i = -1$。保证按照上述规则得到的树为连通有根树。

输入的第三行包含一个正整数 $n_2$，表示 $H$ 中的节点个数，保证对于所有测试数据，满足 $\max(1, n_1 - k) \leq n_2 \leq n_1$。

输入的第四行包含 $n_2$ 个整数，描述了树 $H$ 的结构。具体地，第 $i$（$1 \leq i \leq n_2$）个整数 $b_i$ 表示在树 $H$ 中节点 $i$ 的父节点，如果其为根节点则 $b_i = -1$。保证按照上述规则得到的树为连通有根树。
## 输出格式

对于每一组测试数据：

输出一行一个字符串。如果存在删除 $G$ 中节点的方式，使得其能够同时满足上述三个条件，则输出 `Yes`；否则输出 `No`。
## 样例

### 样例输入 #1
```
0 3 1
3
2 -1 2
2
-1 1
4
3 3 -1 3
3
2 3 -1
5
-1 1 5 5 1
5
2 3 -1 3 2

```
### 样例输出 #1
```
Yes
No
Yes

```
## 提示

**【样例解释 \#1】**

对于第一个测试点，我们删除第一棵树的 $1$ 号节点。此时剩余的树和输入第二棵树均为包含两个节点的有根树，因而输出为 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/vyoktd4u.png)


对于第二个测试点，输入第一颗树深度为 $1$，但是输入第二颗树深度为 $2$。因而不论如何删除第一颗树的节点不会导致其树高增加到 $2$，因而输出为 `No`。

![](https://cdn.luogu.com.cn/upload/image_hosting/r1szu0zb.png)

对于第三个测试点，其输入两颗树均同构于下图的树，因而因而输出为 `Yes`。

![](https://cdn.luogu.com.cn/upload/image_hosting/kxyllt4y.png)

----

**【样例 \#2】**

见附件中的 `iso/iso2.in` 与 `iso/iso2.ans`。

该样例数据范围满足测试点 $7 \sim 8$。

----

**【样例 \#3】**

见附件中的 `iso/iso3.in` 与 `iso/iso3.ans`。

该样例数据范围满足测试点 $9 \sim 10$。

----

**【样例 \#4】**

见附件中的 `iso/iso4.in` 与 `iso/iso4.ans`。

该样例数据范围满足测试点 $13$。

----

**【数据范围】**

对于所有测试数据，满足 $1 \leq T \leq 500$，$1 \le n_2 \leq n_1 \le {10}^5$，$\sum n_1 \leq 5 \times {10}^5$，$0 \leq k \leq 5$。各测试点的附加限制如下表所示：

| $n_1,n_2$   | $\sum n_1$           | 测试点           | $k$      | 特殊性质         |
|:-----------:|:--------------------:|:-------------:|:--------:|:------------:|
| $\leq 8$    | $\leq 500$           | $1 \sim 3$       | $\leq 0$ | 无            |
| $\leq 8$    | $\leq 500$           | $4 \sim 6$       | $\leq 5$ | 无            |
| $\leq 16$   | $\leq 10^3$          | $7 \sim 8$         | $\leq 0$ | 无            |
| $\leq 16$   | $\leq 10^3$          | $9 \sim 10$        | $\leq 5$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $11$          | $\leq 0$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $12$          | $\leq 1$ | 无            |
| $\leq 150$  | $\leq 10^4$          | $13$          | $\leq 5$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $14 \sim 16$    | $\leq 0$ | A |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $17 \sim 20$ | $\leq 0$ | B  |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $21$          | $\leq 1$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $22 \sim 23$       | $\leq 3$ | 无            |
| $\leq 10^5$ | $\leq 5 \times 10^5$ | $24 \sim 25$       | $\leq 5$ | 无            |

其中附加限制中的特殊性质如下所示：

- 特殊性质 A：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $1$ 个儿子结点；另一种等价的表述是有根树 $G$ 构成了一条链，且根节点为链的一个端点。
- 特殊性质 B：保证有根树 $G$ 每个节点要么是叶节点，要么有恰好 $2$ 个儿子结点，同时保证 $G$ 的每一个叶节点深度均相同；另一种等价的表述是有根树 $G$ 构成一棵完全二叉树，且根节点为完全二叉树的根节点。

**【提示】**

数据没有**针对任何合理的哈希算法做任何针对性的构造**，所以在合理范围内不需要过度担心因为哈希碰撞而产生的失分问题。


---

---
title: "Sultan Rage"
layout: "post"
diff: 省选/NOI-
pid: P8565
tag: ['洛谷原创', 'O2优化', '洛谷月赛']
---
# Sultan Rage
## 题目描述

有一个数列 $\{a_n\}$ 满足对 $n > m$ 均有 $a_n=\sum\limits_{j=1}^m a_{n-j}$，并且 $a_1,a_2,\cdots,a_m$ 是输入中给出的正整数。

$q$ 次询问，每一次给出一个正整数 $x$，问有多少个不可重正整数集 $S$ 满足 $\sum\limits_{s\in S}a_s=x$。答案对质数 $998244353$ 取模。

本题有多组数据。
## 输入格式

**本题有多组数据。**

第一行一个整数 $T$ 表示数据组数。对于每一组数据：

第一行两个整数 $m,q$。

第二行 $m$ 个整数 $a_1,a_2,\cdots,a_m$。

第三行 $q$ 个整数，每一个整数代表一次询问。
## 输出格式

对于每组询问输出一行表示答案。
## 样例

### 样例输入 #1
```
2
2 5
1 1
3 5 7 9 11
3 5
1 2 5
4 7 10 18 22
```
### 样例输出 #1
```
3
3
3
5
5
0
1
1
1
1
```
## 提示

对于所有数据，$T=5$，$2 \le m \le 100$，$1 \le q,a_i \le 100$，$1 \le x \le 10^{18}$。
$$
\def{\arraystretch}{1.5}
\begin{array}{c|c|c|c|c|c}\hline 
\textbf{测试点编号}&\bm{m\le}&\bm{q \le }&\bm{a_i \le }& \bm{x \le}&\bm{\textbf{特殊性质}}\cr\hline 
\textsf1\sim \sf2 & 8&8  & 8 & 100\cr\hline 
\sf3\sim 5 & 15& &15&10^3 \cr\hline 
\textsf6 & & & & 1 &\cr\hline 
\sf7\sim 11 & & 1& & & \textsf{A}\cr\hline
\sf12\sim 16 & 2& & &\cr\hline
\sf17\sim 20 & &\cr\hline
\end{array}
$$

$\textsf A$：$m=10$，且 $x$ 在所有可能的 $x$ 中随机生成。


---

---
title: "[蓝桥杯 2021 省 B] 双向排序"
layout: "post"
diff: 省选/NOI-
pid: P8747
tag: ['2021', '蓝桥杯省赛', 'Ad-hoc']
---
# [蓝桥杯 2021 省 B] 双向排序
## 题目描述

给定序列 $\left(a_{1}, a_{2}, \cdots, a_{n}\right)=(1,2, \cdots, n)$，即 $a_{i}=i$ 。

小蓝将对这个序列进行 $m$ 次操作，每次可能是将 $a_{1}, a_{2}, \cdots, a_{q_{i}}$ 降序排列，或者将 $a_{q_{i}}, a_{q_{i}+1}, \cdots, a_{n}$ 升序排列。

请求出操作完成后的序列。
## 输入格式

输入的第一行包含两个整数 $n, m$，分别表示序列的长度和操作次数。

接下来 $m$ 行描述对序列的操作，其中第 $i$ 行包含两个整数 $p_{i}, q_{i}$ 表示操作类型和参数。

当 $p_{i}=0$ 时，表示将 $a_{1}, a_{2}, \cdots, a_{q_{i}}$ 降序排列;

当 $p_{i}=1$ 时，表示将 $a_{q_{i}}, a_{q_{i}+1}, \cdots, a_{n}$ 升序排列。
## 输出格式

输出一行，包含 $n$ 个整数，相邻的整数之间使用一个空格分隔，表示操作完成后的序列。
## 样例

### 样例输入 #1
```
3 3
0 3
1 2
0 2
```
### 样例输出 #1
```
3 1 2
```
## 提示

**【样例说明】**

原数列为 $(1,2,3)$。

第 1 步后为 $(3,2,1)$。

第 2 步后为 $(3,1,2)$。

第 3 步后为 $(3,1,2)$。与第 2 步操作后相同, 因为前两个数已经是降序了。

**【评测用例规模与约定】**

对于 $30 \%$ 的评测用例, $n, m \leq 1000$;

对于 $60 \%$ 的评测用例, $n, m \leq 5000$;

对于所有评测用例, $1 \leq n, m \leq 10^5,0 \leq p_{i} \leq 1,1 \leq q_{i} \leq n$ 。 

蓝桥杯 2021 第一轮省赛 B 组 I 题。


---

---
title: "[集训队互测 2022] 树链剖分"
layout: "post"
diff: 省选/NOI-
pid: P8821
tag: ['集训队互测', '2022', 'O2优化']
---
# [集训队互测 2022] 树链剖分
## 题目背景

请注意：**本题不是树链剖分模板题**。
## 题目描述

给定一棵 $n$ 个节点的树 $T$ 以及树上的 $m$ 条 **不同的** 路径 $I_i = (u_i, v_i)(u_i\neq v_i)$。具体地，$I_i$ 表示树上 $u_i$ 和 $v_i$ 之间的简单路径上所有点形成的点集。

考虑 $T$ 上某条路径 $I = (u, v)$，定义 $f(I) = \sum\limits_{i = 1} ^ m\sum\limits_{j = 1} ^ m [I_i\cup I = I_j\cup I]$。

对于 $T$ 上所有不同路径 $I$，求 $f(I)$ 之和，并将答案对 $998244353$ 取模。也就是说，你需要求 $\left(\sum\limits_{u = 1} ^ n\sum\limits_{v = u} ^ n f((u, v))\right) \bmod 998244353$。
## 输入格式

第一行一个整数 $S$，表示子任务编号。样例的子任务编号为 $-1$。

第二行两个整数 $n, m$，分别表示树的大小和路径条数。

接下来 $n - 1$ 行，每行两个整数 $x_i, y_i$ 表示 $T$ 上的一条边。

接下来 $m$ 行，每行两个整数 $u_i, v_i$ 表示第 $i$ 条路径 $I_i$。

**保证给定路径两两不同**。
## 输出格式

输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
-1
3 3
1 2
2 3
1 2
2 3
1 3
```
### 样例输出 #1
```
32
```
### 样例输入 #2
```
-1
4 6
1 2
1 3
1 4
1 2
1 3
1 4
2 3
2 4
3 4
```
### 样例输出 #2
```
120
```
### 样例输入 #3
```
-1
7 7
1 2
1 3
2 4
4 5
5 6
5 7
5 7
3 1
4 7
7 1
2 6
3 6
3 5
```
### 样例输出 #3
```
330
```
## 提示

本题采用捆绑测试，共 $25$ 个子任务，分别编号为 $0\sim 24$。**注意评测子任务编号为实际子任务编号 $+1$**。

子任务编号模 $5$ 的余数将子任务按数据大小划分。

- 若子任务编号模 $5$ 余 $0$，则 $n, m\leq 100$，记为 A1。
- 若子任务编号模 $5$ 余 $1$，则 $n, m\leq 500$，记为 B1。依赖于 A1。
- 若子任务编号模 $5$ 余 $2$，则 $n, m\leq 1557$，记为 C1。依赖于 B1。
- 若子任务编号模 $5$ 余 $3$，则 $n, m\leq 85500$，记为 D1。依赖于 C1。
- 若子任务编号模 $5$ 余 $4$，则 $n, m\leq 2\times 10 ^ 5$，记为 E1。依赖于 D1。

子任务编号除以 $5$ 的商将子任务按特殊限制划分。

- 若子任务编号除以 $5$ 商 $0$，则 $T$ 是一条链，记为 A2。
- 若子任务编号除以 $5$ 商 $1$，则 $T$ 是一个菊花，记为 B2。
- 若子任务编号除以 $5$ 商 $2$，则所有路径端点互不相同，记为 C2。
- 若子任务编号除以 $5$ 商 $3$，则所有路径以同一点为一端，记为 D2。
- 若子任务编号除以 $5$ 商 $4$，则无特殊限制，记为 E2。依赖于 A2，B2，C2，D2。

对于 $100\%$ 的数据，$2\leq n\leq 2\times 10 ^ 5$，$1\leq m\leq \min(\frac {n(n - 1)} 2, 2\times 10 ^ 5)$，$1\leq u_i, v_i, x_i, y_i\leq n$，且所有 $(x_i, y_i)$ 形成一棵树，所有 $I_i = (u_i, v_i)$ 互不相同，$u_i\neq v_i$。

各子任务分值如下表所示。

| **得分** | **A1** | **B1** | **C1** | **D1** | **E1** | **总和** |
| :------: | :----: | :----: | :----: | :----: | :----: | :------: |
|  **A2**  |  $1$   |  $2$   |  $3$   |  $7$   |  $7$   |   $20$   |
|  **B2**  |  $1$   |  $2$   |  $3$   |  $4$   |  $4$   |   $14$   |
|  **C2**  |  $1$   |  $2$   |  $5$   |  $7$   |  $7$   |   $22$   |
|  **D2**  |  $1$   |  $3$   |  $5$   |  $4$   |  $5$   |   $18$   |
|  **E2**  |  $2$   |  $3$   |  $3$   |  $9$   |  $9$   |   $26$   |
| **总和** |  $6$   |  $12$  |  $19$  |  $31$  |  $32$  |  $100$   |

**注：洛谷评测无子任务依赖**。

来源：2022 年集训队互测 Round 4。

出题人：Alex_Wei。


---

---
title: "『JROI-7』T2nz."
layout: "post"
diff: 省选/NOI-
pid: P8851
tag: ['洛谷原创', '交互题', 'Special Judge', 'O2优化', '洛谷月赛']
---
# 『JROI-7』T2nz.
## 题目背景

**这是一道交互题。**  
## 题目描述

小 X 陷入了一个奇怪的梦。在梦境里，她在和小 Q 下一种奇怪的棋。

这是一个 $2^{2n}\times 2n$ 的棋盘，小 X 执黑先行，小 Q 执白后行。

每次操作，需要**在当前未满的第一行内**，任意选择一格下棋。一格内只能有一个棋子。

下满之后，共有 $2^{2n}$ 行棋子，小 X 的得分为本质不同的行数。

小 X 想最大化她的得分，但小 Q 想最小化小 X 的得分。

你的任务是，扮演小 X 或小 Q，最大化或最小化得分。

**若你是小 X，在满足最大化得分 $ans$ 的同时，你也要最大化前 $ans$ 行中本质不同的行数**。

------------


### 交互格式

你要先从标准输入读入一行两个整数 $T,tp$，表示数据组数和你扮演的角色。保证 $tp\in\{0,1\}$。若 $tp=0$，表示你扮演小 Q（后手）；若 $tp=1$，表示你扮演小 X（先手）。

接下来每一组数据，你要先从标准输入读入一行一个正整数 $n$，含义见题目描述。

接下来会进行 $2^{2n}\times n$ 次交互。

在每次交互中：

- 若 $tp=0$，你要先从标准输入读入一行一个正整数 $x$，表示小 X 下了黑棋在当前未满的第一行的第 $x$ 列，接下来你要向标准输出输出一个正整数 $y$，表示你下了白棋在当前未满的第一行的第 $y$ 列；
- 若 $tp=1$，你要先向标准输出输出一个正整数 $x$，表示你下了黑棋在当前未满的第一行的第 $x$ 列，接下来你要从标准输入读入一行一个正整数 $y$ 表示小 Q 下了白棋在当前未满的第一行的第 $y$ 列。

你的输出都要**换行并清空缓存区**。

你需要保证你下棋的位置不能已有棋子。同时，交互库也会保证其下棋的位置不会已有棋子。

## 输入格式

见「交互格式」。
## 输出格式

见「交互格式」。
## 样例

### 样例输入 #1
```
1 1
1

2

1

2

1
```
### 样例输出 #1
```


1

2

1

2
```
## 提示

**【样例解释】**

读入的 $n=1$，因此棋盘的大小是 $4\times 2$ 的。两人模拟如[动图](https://i.ibb.co/ChCxHQH/e.gif)所示。最终结果如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/u2goi90a.png)

可以观察发现，最终本质不同的行数为 $2$。容易发现，这是小 X 能最大化的得分。同时，前 $2$ 行中本质不同行数为 $2$，显然无法达到更大的值。

------------

**【数据范围与规模】**

| 测试点编号 | $n \le$ | $tp=$ |
|:-:|:-:|:-:|
| $1$ | $3$ | $0$ |
| $2\sim 3$ | $7$ | $0$ |
| $4$ | $3$ | $1$ |
| $5$ | $4$ | $1$ |
| $6$ | $5$ | $1$ |
| $7 \sim 8$ | $6$ | $1$ |
| $9 \sim 10$ | $7$ | $1$ |

对于所有的数据，保证 $1 \le n \le 7$，$1 \le T \le 3$，$tp\in\{0,1\}$。

------------
**【提示】**

- 您可以使用如下语句来清空缓冲区：

	- 对于 C/C++：`fflush(stdout)`；
	- 对于 C++：`std::cout << std::flush`；
	- 对于 Java：`System.out.flush()`；
	- 对于 Python：`stdout.flush()`；
	- 对于 Pascal：`flush(output)`；
	- 对于其他语言，请自行查阅对应语言的帮助文档。
	- 特别的，对于 C++ 语言，在输出换行时使用 `std::endl` 而不是 `'\n'`，也可以自动刷新缓冲区。
    
- 我们保证交互库耗时在 $1.5\text{s}$ 内，空间消耗可以忽略不计。


---

---
title: "[POI 2002] 滑雪者"
layout: "post"
diff: 省选/NOI-
pid: P8857
tag: ['2002', 'POI（波兰）']
---
# [POI 2002] 滑雪者
## 题目描述

在某山的斜坡上有一些滑雪轨道和一个滑雪电梯，所有的轨道都是从山顶到山底。

每天清晨都有一群工人检查轨道情况，他们一起乘电梯到到达山顶。接着他们沿每个人选择的轨道滑到底端，每个工人只能滑一次。

工人选择的轨道可能有部分相同，每个轨道可由任一个向下滑行的工人检查。向下滑雪从高到底选择一条轨道进行。

滑雪轨道由一个空地网络组成，每个空地有不同的高度。任意两个空地之间最多有一条道相连。
## 输入格式

第一行一个整数 $n$ 表示空地的数目。

接下来 $n-1$ 行，第 $i+1$ 行的整数表示空地 $i$ 有轨道滑向它们。第一个整数 $k$ 表示空地数目，接着 $k$ 个整数，表示它们的编号（从西往东排列）。特别的，山顶编号为 $1$，山脚编号为 $n$。
## 输出格式

一行，表示最少需要多少个工人检查所有的滑道。
## 样例

### 样例输入 #1
```
15
5 3 5 9 2 4
1 9
2 7 5
2 6 8
1 7
1 10
2 14 11
2 10 12
2 13 10
3 13 15 12
2 14 15
1 15
1 15
1 15
```
### 样例输出 #1
```
8
```
## 提示

数据范围：$2 \le n \le 5000$，给定的图是平面图。


---

---
title: "[北大集训 2021] 随机游走"
layout: "post"
diff: 省选/NOI-
pid: P8989
tag: ['2021']
---
# [北大集训 2021] 随机游走
## 题目背景

CTT2021 D2T3
## 题目描述

给定一张 $n$ 个点的有向图，点标号为 $1,2,\dots,n$，初始时对 $\forall i\in\{1,2,\dots,n-1\}$，从 $i$ 到 $i+1$ 有一条有向边。

你可以在其中再加入 $m$ 条有向边（起点终点任意），允许有重边和自环。

小 A 会从 $1$ 出发，以随机游走的形式行动，直到抵达 $n$。你希望最大化小 A 从 $1$ 移动到 $n$ 的期望步数。

定义随机游走是这样的一种移动方式：设小 A 当前在点 $x$，$x$ 有 $d$ 条出边，则小 A 会从这 $d$ 条出边中**等概率**随机选择一条走过去。
## 输入格式

输入的第一行包含一个正整数 $T$，表示数据组数，保证 $T \le 10^5$。

接下来 $T$ 行，每行包含三个整数 $n,m,p$，分别表示有向图的点数、你添加的边数以及答案的模数，保证 $1 \leq n \leq 10^9$，$0 \leq m \leq 10^{18}$，$2\leq p\leq 10^9+7$ 且 $p$ 是质数。

## 输出格式

输出 $T$ 行，第 $i$ 行一个整数 $ans$ 表示第 $i$ 组数据中最大的期望步数对 $p$ 取模后的值（可以证明答案是有理数，设其用最简分数表示为 $\frac{a}{b}$，则你需要满足 $ans \cdot b \bmod p=a$，保证这样的 $ans$ 存在）。
## 样例

### 样例输入 #1
```
4
3 2 97
10 25 233
6 12345 2333
1000000000 1000000000000000000 1000000007 

```
### 样例输出 #1
```
6
131
1206
161905971

```
## 提示

| 测试包编号 | $n\le$ |  $m\le$   | $T\le$ | 特殊性质 | 分数 |
| :--------: | :----: | :-------: | :----: | :------: | :--: |
|    $1$     |  $5$   |    $5$    |  $10$  |    无    | $10$ |
|    $2$     |  $5$   |  $10^2$   |  $10$  |    无    | $10 $ |
|    $3$     | $10^8$ |  $10^2$   | $10^2$ |    无    | $20$ |
|    $4$     |  $50$  |  $3,000$  |  $3$   |    无    | $20 $ |
|    $5$     | $10^9$ |  $10^9$   | $10^5$ | $m<n-1$  | $10$ |
|    $6$     | $10^9$ | $10^{18}$ | $10^5$ |    无    | $30$ |



---

---
title: "[北大集训 2021] 出题高手"
layout: "post"
diff: 省选/NOI-
pid: P8991
tag: ['2021']
---
# [北大集训 2021] 出题高手
## 题目背景

CTT2021 D3T2
## 题目描述

Alice 是一个出题高手。

Alice 每天都会出一道题，这样 $n$ 天过去，她就出了 $n$ 道题了。

第 $n+1$ 天，Alice 没有出题，她打算从之前的 $n$ 道题中选择若干道组成一个比赛。方便起见，她决定这些选择的题目得是**连续**的一个时间段出的，也就是这些题目必须形如：第 $l$ 天到第 $r$ 天出的所有题目（$1\le l \le r \le n$）。

Alice 还给每个题目一个评分，第 $i$ 个题目的评分为 $a_i(-1000 \le a_i \le 1001)$ ，评分越高代表这道题越偏智商，评分越低说明这道题越偏码力。

Alice 希望组成的比赛具备特色，也即整体偏向代码或者整体偏向智商。一场以 Alice 第 $l$ 天到第 $r$ 天出的题目组成的比赛的特色程度定义为 $\Large \frac{(\sum_l^r a_i)^2}{r-l+1}$ ，Alice 想要**最大化**这个特色程度。

现在，对于 $m$ 个形如 $ql_i,qr_i$ 的询问，你需要回答如果将 Alice  能选择的题目限定在第 $ql_i$ 到 $qr_i$ 天出的题，Alice 能组成的特色程度最大的比赛的特色程度是多少，你需要以分数的形式输出这个特色程度。

由于 Alice 出题的水平过于高超，你可以认为每道题的评分是**随机生成**的。

## 输入格式


输入的第一行包含一个正整数 $n$。

输入的第二行包含 $n$ 个整数 $a_1 \dots a_n$，代表 Alice 对第 $i$ 天所出的题的评分。

输入的第三行包含一个正整数 $m$。

接下来 $m$ 行，每行输入两个正整数 $ql_i,qr_i$，表示询问。

## 输出格式

共 $m$ 行，每行两个整数 $p_i,q_i$，满足 $\gcd(p_i,q_i)=1$，表示答案为 $\frac{p_i}{q_i}$，若答案为 $0$，则 $p_i=0$，$q_i=1$。
## 样例

### 样例输入 #1
```
5
-962 -445 -613 -9 920
3
1 5
3 5
1 3

```
### 样例输出 #1
```
4080400 3
846400 1
4080400 3

```
## 提示

| 子任务 |   $n=$   |   $m=$   | 分值 |
| :----: | :------: | :------: | :--: |
|  $1$   |  $2000$  | $100000$ | $5$  |
|  $2$   | $100000$ |   $1$    | $15$ |
|  $3$   | $500000$ |   $1$    | $30$ |
|  $4$   | $100000$ |  $5000$  | $15$ |
|  $5$   | $100000$ | $300000$ | $35$ |



对于 第 $2$ 个和第 $3$ 个子任务，保证所有询问满足 $ql_i = 1$，$qr_i = n$。

所有的 $a_i$ 保证满足 $-1000 \le a_i \le 1001$。且对于 $a_i$ ，数据生成方式为每次独立地从 $[-1000,1001]$ 中等概率随机选取一个整数。



---

---
title: "[北大集训 2021] 算术"
layout: "post"
diff: 省选/NOI-
pid: P8993
tag: ['2021']
---
# [北大集训 2021] 算术
## 题目背景

CTT2021 D4T1
## 题目描述

今天，生活在 14 进制世界的小 Q 学习了一种判断给定的大数是否是 9 的倍数的方法。我们以 $(1BB40)_{14} = (70812)_{10}$ 作为例子描述该方法，下面设 $b=14$，$p=9$，下面的方法中所有的运算在 $b$ 进制下进行。

1. 从低位往高位，将每个连续的 $k=2$ 位划分为一段。例子中，$(1BB40)_{b}$ 被划分为 $1 \mid BB \mid 40$ 三段。
2. 从低位往高位从 $0$ 开始给每一段编号。例子中，第 $0$ 段为 $40$，第 $1$ 段为 $BB$，第 $2$ 段为 $1$。
3. 对于第 $i$ 段计算出值 $b_i$：设第 $i$ 段在 $b$ 进制下的值为 $a_i$，如果 $i$ 为奇数则 $b_i$ 为满足 $(a_i+b_i) \equiv 0 \pmod p$ 的最小非负整数 $b_i$，如果 $i$ 为偶数则 $b_i$ 为满足 $(a_i-b_i) \equiv 0 \pmod p$ 的最小非负整数 $b_i$。例子中有 $b_0=2$，$b_1=6$，$b_2=1$。
4. 将 $b_i$ 按照**下标大的在低位，下标小的在高位**的顺序顺次拼接，形成一个 $b$ 进制数并输出。例子中输出结果为 $(261)_{b} = (477)_{10}$。容易验证 $477$ 和 $70812$ 都是 $p$ 的倍数。

可以证明上述方法输入和输出的数要么同时是 $p$ 的倍数，要么同时不是 $p$ 的倍数。而且数字的位数变少了，所以多做几次就可以得到一个很小的数，然后就可以简单地判断了。

小 Q 深深地被这个算法吸引了，所以他想给出一个 $b,p$ 不同于 $14,9$ 时的通用方法。但是他发现，当上面的方法中 $b,p$ 的取值变化时，$k$ 不一定等于 $2$：有时会是 $1$，有时会大于 $2$，有时甚至不存在满足条件的 $k$。所以对于给定的 $b, p$，小 Q 想知道在 $b$ 进制下上述方法的第一步中**正整数** $k$ 的最小值，使得无论输入如何，输入和对应的输出要么同时是 $p$ 的倍数，要么同时不是 $p$ 的倍数，或者报告这样的 $k$ 不存在。

注意 $p$ 不一定是质数。

## 输入格式

**测试点有多组测试数据，保证同一测试点下的 $p$ 相同**。输入的第一行包含两个正整数 $T,p$，保证 $1 \le T \le 10^5$，$2 \leq p \le 10^{15}$，分别表示该组测试点的测试数据组数与方法的 $p$ 参数。

接下来 $T$ 行每行输入一行一个整数 $b$ 表示每组测试数据的进制。保证 $2 \leq p < b \leq 10 \times p$。

**输入中的所有数字按照十进制给出。**

## 输出格式

对于每组数据输出一行，若不存在合法的 $k$ 输出 `-1`，否则输出最小的满足条件的**正整数** $k$。

## 样例

### 样例输入 #1
```
2 9
14
16
```
### 样例输出 #1
```
2
-1
```
## 提示

| 子任务编号 | $2\leq p\leq$ | $1\leq T\leq$ | 分值 |
| :--------: | :-----------: | :-----------: | :--: |
|    $1$     |      $3$      |     $10$      | $5$  |
|    $2$     |     $10$      |     $10$      | $5 $  |
|    $3$     |    $10^2$     |    $10^2$     | $5$  |
|    $4$     |    $10^4$     |    $10^2$     | $11$ |
|    $5$     |    $10^6$     |    $10^2$     | $11 $ |
|    $6$     |    $10^8$     |    $10^3$     | $11$ |
|    $7$     |   $10^{10}$   |    $10^3$     | $11 $ |
|    $8$     |   $10^{12}$   |    $10^3$     | $7$  |
|    $9$     |   $10^{14}$   |    $10^4$     | $17$ |
|    $10$    |   $10^{15}$   |    $10^5$     | $17 $ |





为了选手们的身心健康，下发文件中的 `down.cpp` 中实现了大整数取模乘法函数 `mul(A, B, P)`，你需要保证 $A,B \in [0,P-1]$，函数会返回 $(A \times B) \bmod P$。你可以自由选择使用或者不使用这份代码。**其中需要保证你调用时 $A,B,P$ 均不超过 $10^{15}$。**


---

---
title: "[CEOI 2022] Abracadabra"
layout: "post"
diff: 省选/NOI-
pid: P8996
tag: ['2022', 'CEOI（中欧）']
---
# [CEOI 2022] Abracadabra
## 题目描述

Tin 是一位著名的魔术师，他的一个经典魔术与洗牌有关。

Tin 会准备一套牌，总共 $n$ 张（保证 $n$ 为偶数），各编号为 $1\sim n$，一开始的时候牌是乱的且倒扣在桌子上。紧接着他开始表演洗牌，在洗牌的任意时刻，观众都可以向 Tin 询问从底往上数第 $t$ 张牌是什么牌，很显然 Tin 一定会立即回答出正确答案。

事实上，Tin 采用如下方式来完成这个魔术，首先他记下了一开始的 $n$ 张牌的顺序，接着采用如下技巧洗牌：

1. 拿起自顶向下 $\frac{n}{2}$ 张牌放在右手，自底向上 $\frac{n}{2}$ 张牌放在左手，牌的正面对着桌子。
1. 借助他的记忆，将左右手最底下的牌进行比较，将编号较小的那张牌放下，重复这个操作直到左右手一边为空。
1. 将还有牌的那只手上的所有牌放下。

请你写一个程序模拟 Tin 的魔术。
## 输入格式

第一行两个整数 $N,Q$。

接下来一行 $N$ 个整数 $p_i$，从底向上描述了整个牌堆。

接下来 $Q$ 行，一行一个询问 $t,i$，表示询问 $t$ 次洗牌后自底向上第 $i$ 张牌编号是多少。
## 输出格式

对于每一个询问，输出你的答案。
## 样例

### 样例输入 #1
```
6 3
1 5 6 2 3 4
1 2
0 4
1 5
```
### 样例输出 #1
```
2
2
5
```
### 样例输入 #2
```
6 6
2 1 5 4 6 3
0 1
1 1
0 3
1 3
0 6
10 6
```
### 样例输出 #2
```
2
2
5
4
3
3
```
### 样例输入 #3
```
10 10
7 5 2 9 10 8 4 3 6 1
3 1
3 2
3 3
3 4
3 5
3 6
3 7
3 8
3 9
3 10
```
### 样例输出 #3
```
2
3
6
1
7
5
8
4
9
10
```
## 提示

### 样例 3 解释

| 洗牌次数 |          自底向上的牌堆           |
| :------: | :-----------------------------: |
|   $0$    | $7\ 5\ 2\ 9\ 10\ 8\ 4\ 3\ 6\ 1$ |
|   $1$    | $7\ 5\ 2\ 8\ 4\ 3\ 6\ 1\ 9\ 10$ |
|   $2$    | $3\ 6\ 1\ 7\ 5\ 2\ 8\ 4\ 9\ 10$ |
|   $3$    | $2\ 3\ 6\ 1\ 7\ 5\ 8\ 4\ 9\ 10$ |

### 数据规模与约定

对于全部数据，满足 $1\le N\le 2\times 10^5$，$N$ 为偶数，$1\le Q\le 10^6$，$0\le t\le 10^9$，$p$ 为 $1\sim n$ 的排列，$1\le i\le N$。

| Subtask 编号 |       特殊限制        |   分数   |
| :----------: | :------------------: | :------: |
|   $1$	    |   $N\le 10^3$	    |   $10$   |
|   $2$	    | 每一个询问的 $t$ 相同 | 	$40$ |
|   $3$	    |   $N,Q\le 10^5$	   |   $25$   |
|   $4$	    |      无特殊限制	      |   $25$   |


---

---
title: "[CEOI 2022] Parking"
layout: "post"
diff: 省选/NOI-
pid: P9001
tag: ['2022', 'Special Judge', 'CEOI（中欧）']
---
# [CEOI 2022] Parking
## 题目描述

Valerija 在一家饭店的停车场工作，她负责礼貌地接待重要的客人，保管他们的车钥匙并帮助他们停车。

一个晚上，她发现她管理的停车场中恰好有 $2N$ 辆车，它们共有 $N$ 种不同的颜色，每种颜色恰有两辆车。我们将颜色按 $1$ 到 $N$ 编号。

停车场共有 $M$ 个车位，按 $1$ 到 $M$ 编号，每一个车位可以停下两辆车，一个车位只有一个入口，我们称靠近入口的为「顶上的车」，远离入口的为「底下的车」，一辆车可以从入口开出当且仅当没有车挡着它。Valerija 在停车的时候，保证每个车位要么空，要么停满两辆车，要么只有一辆底下的车。

![](https://cdn.luogu.com.cn/upload/image_hosting/q0r8s8f5.png)

这张图描述的是第一个样例，同时呈现了唯一的第一次驾驶。

Valerija 想要重新停放车使得每一对相同颜色的车都在一个车位里。我们并不关心车位对应什么颜色以及哪辆车在顶上哪辆车在底下。Valerija 将执行如下操作：

- 驾驶一辆可以驶出车位的车，将车开到另一个车位，满足：
    - 这个车位是空的，并把车停在底下的车位，或者，
    - 这个车位有且只有一辆与当前驾驶的车颜色相同的车。
    
Valerija 想知道最少的操作次数与操作方案，请你解决这个问题。
## 输入格式

第一行两个整数 $N,M$。

接下来 $M$ 行，一行两个整数 $b_i,t_i$，$b_i$ 表示停在这个车位底下的车的颜色，$t_i$ 表示停在这个车位顶上的车的颜色，如为 $0$，则表示这个车位底下/顶上的位置没有车。
## 输出格式

如果没有办法完成要求，输出一行一个整数 $-1$。

否则，第一行一个整数 $K$，表示最少的操作次数。

接下来 $K$ 行，一行两个整数 $x_i,y_i$，表示第 $i$ 次操作将车位 $x_i$ 中可以驶出车位的车开到车位 $y_i$。

注意到最短解可能不唯一，你只需要输出任意一种即可。
## 样例

### 样例输入 #1
```
4 5
1 0
2 0
1 3
4 4
3 2
```
### 样例输出 #1
```
3
5 2
3 5
3 1
```
### 样例输入 #2
```
4 5
0 0
2 1
3 1
3 4
2 4
```
### 样例输出 #2
```
-1
```
### 样例输入 #3
```
5 7
1 0
2 1
2 3
4 3
5 4
5 0
0 0
```
### 样例输出 #3
```
6
2 1
3 7
4 7
2 3
5 4
5 6
```
## 提示

### 样例 1 解释

由题目描述中的图可以看出，这个样例只有唯一解。

### 数据规模与约定

对于全部数据，$1\le N\le M\le 2\times 10^5$。

如果你的程序正确求出了最少的操作次数，但是方案构造错误，你将会获得对应点 $20\%$ 的分数。

| Subtask 编号 |                 特殊限制                  | 分数 |
| :----------: | :--------------------------------------: | :--: |
|     $1$      |                 $M\le 4$                 | $10$ |
|     $2$      |                $2N\le M$                 | $10$ |
|     $3$      | $N\le 1000$，每个车位要么是空的要么是满的。 | $25$ |
|     $4$      |       每个车位要么是空的要么是满的。        | $15$ |
|     $5$      |               $N\le 1000$                | $25$ |
|     $6$      |                无特殊限制                 | $15$ |


---

---
title: "[RC-07] Game Theory"
layout: "post"
diff: 省选/NOI-
pid: P9003
tag: ['O2优化']
---
# [RC-07] Game Theory
## 题目描述

给出长度为 $n$ 的 `01` 序列 $a_{1\sim n}$，**序列中有偶数个 `1`**。NIT 和 TIN 轮流做以下操作，NIT 先手：

- 选择位置 $i\ (1\le i\le n)$，满足区间 $[1,i]$ 中有奇数个 `1`。再选择位置 $j\ (i<j\le n)$。将 $a_i,a_j$ 都取反（即，`0` 变 `1`，`1` 变 `0`）

当整个序列中的所有元素都变为 `0` 时，当前轮到的人就无法操作，他就输了。假设 NIT 和 TIN 都*绝顶*聪明，谁会赢？可以证明，游戏总会结束。

$n$ 可能很大，但序列中 $1$ 的个数不超过 $2\times 10^5$。
## 输入格式

**本题有多组数据。**

输入的第一行是数据组数 $T$。

接下来是每组数据的描述。每组数据的第一行是两个正整数 $n,m$，$m$ 为序列中 `1` 的个数，保证 $m$ 是偶数。

接下来一行 $m$ 个**递增**的正整数，描述这些 `1` 的下标，下标从 $1$ 开始。
## 输出格式

对每组数据，输出一行一个字符串 `NIT` 或 `TIN`，表示赢家的名字。
## 样例

### 样例输入 #1
```
3
4 2
1 3
4 4
1 2 3 4
10 4
1 3 7 8
```
### 样例输出 #1
```
NIT
TIN
NIT
```
## 提示

**样例解释**

第一组数据中，NIT 选择 $i=1,j=3$ 就能把全部位置都变成 0，使得 TIN 无法操作。

第二组数据中，无论 NIT 先手怎么操作，都会剩下恰好两个 1 的位置。TIN 只需要选择这两个剩下的位置，就可以把全部位置都变成 0。

第三组数据中，一种可能的游戏进程如下（注意该进程里，每一步不一定是最优的）：

- NIT 选择 $i=2,j=3$ 并将这两个位置取反。现在 
`1` 的位置在 $1,2,7,8$。
- TIN 选择 $i=7,j=9$ 并将这两个位置取反。现在 
`1` 的位置在 $1,2,8,9$。
- NIT 选择 $i=1,j=5$ 并将这两个位置取反。现在 
`1` 的位置在 $2,5,8,9$。
- TIN 选择 $i=3,j=4$ 并将这两个位置取反。现在 
`1` 的位置在 $2,3,4,5,8,9$。
- NIT 选择 $i=4,j=5$ 并将这两个位置取反。现在 
`1` 的位置在 $2,3,8,9$。
- TIN 选择 $i=2,j=9$ 并将这两个位置取反。现在 
`1` 的位置在 $3,8$。
- NIT 选择 $i=3,j=8$ 并将这两个位置取反。现在序列里没有 `1` 了。
- TIN 无法操作，NIT 获胜。

**数据范围**

对于所有数据，$1\le T\le 10^4$，$1\le n\le 10^{18}$，$2\le m\le 2\times 10^5$，$\sum m\le 10^6$。保证 $m$ 是偶数，保证为 `1` 的下标是递增顺序给出的。

- 子任务 1（$1$ 分）$T\le 10^3$，$n\le 10$。
- 子任务 2（$9$ 分）序列中全是 `1`。
- 子任务 3（$40$ 分）$T\le 100$，$n\le 100$。
- 子任务 4（$10$ 分）$\sum n\le 10^6$。
- 子任务 5（$40$ 分）没有任何附加限制。


---

---
title: "[RC-07] Abnormal Permutation Tuples"
layout: "post"
diff: 省选/NOI-
pid: P9004
tag: ['O2优化']
---
# [RC-07] Abnormal Permutation Tuples
## 题目描述

给出三个正整数 $n,m$ 和 $mod$。

有多少个 $1\sim n$ 的排列构成的有序 $m$ 元组，$(p_1,p_2,\dots,p_m)$，满足：

- 字典序：$p_1\lt p_2\lt \dots\lt p_m$
- 逆序对数：$p_1\gt p_2\gt \dots\gt p_m$

设 $f(n,m)$ 为答案模 $mod$ 的值。对于所有 $1\le i\le n,1\le j\le m$，请你输出 $f(i,j)$。

## 输入格式

输入包含一行三个正整数 $n,m,mod$。
## 输出格式

输出一个 $n\times m$ 的矩阵，第 $i$ 行第 $j$ 列为 $f(i,j)$。
## 样例

### 样例输入 #1
```
5 3 23333
```
### 样例输出 #1
```
1 0 0
2 0 0
6 0 0
24 17 0
120 904 1226
```
## 提示

保证 $2\le mod\le 10^9$，$1\le n\le 15$，$1\le m\le 30$。**注意，$n,m$ 不会同时取到 $15$ 和 $30$。**

$n,m$ 的范围如下：
 
- 子任务 1（$20$ 分）$n=7$，$m=30$。
- 子任务 2（$10$ 分）$n=10$，$m=10$。
- 子任务 3（$20$ 分）$n=11$，$m=10$。
- 子任务 4（$10$ 分）$n=12$，$m=8$。
- 子任务 5（$20$ 分）$n=13$，$m=15$。
- 子任务 6（$10$ 分）$n=14$，$m=30$。
- 子任务 7（$10$ 分）$n=15$，$m=20$。


---

---
title: "[RC-07] 超超立方体"
layout: "post"
diff: 省选/NOI-
pid: P9005
tag: ['O2优化']
---
# [RC-07] 超超立方体
## 题目描述

有一个 $n$ 维 $(a_1-1)\times (a_2-1)\times \dots \times (a_n-1)$ 超立方体。左下角坐标为 $(1,1,\dots,1)$，右上角坐标为 $(a_1,a_2,\dots,a_n)$。

考虑一个无向图，有 $a_1\times a_2\times \dots \times a_n$ 个有标号的结点。结点的标号分别为 $(x_1,\dots,x_n)\ (1\le x_i\le a_i)$，每个节点对应超立方体内部或者边界上一个整点。对于一对图上的顶点 $(U,V)\ (U=(x_1,\dots,x_n),V=(y_1,\dots,y_n))$，它们之间有边相连当且仅当 $UV$ 平行于超立方体的一条棱。换句话说，也就是 $\sum_{1\le i\le n}[x_i=y_i]=n-1$。

计算该图生成树个数对 $998244353$ 取模的结果。
## 输入格式

第一行一个正整数 $n$。

接下来一行 $n$ 个正整数 $a_1,a_2,\dots,a_n$。
## 输出格式

输出答案对 $998244353$ 取模的结果。
## 样例

### 样例输入 #1
```
1
5
```
### 样例输出 #1
```
125
```
### 样例输入 #2
```
5
2 3 4 5 6
```
### 样例输出 #2
```
676736091
```
## 提示

所有数据均满足：$1\le n\le 100$，$2\le a_i\le 5000$。

- 子任务 $1$（$5$ 分）：$n=1$。
- 子任务 $2$（$5$ 分）：$n\le 3,\prod a_i\le 500$。
- 子任务 $3$（$10$ 分）：$n=2$。
- 子任务 $4$（$80$ 分）：无特殊限制。


---

---
title: "[COCI 2022/2023 #1] Berilij（暂无spj）"
layout: "post"
diff: 省选/NOI-
pid: P9030
tag: ['2022', 'Special Judge', 'COCI（克罗地亚）']
---
# [COCI 2022/2023 #1] Berilij（暂无spj）
## 题目背景

小羊 Berilij 被外星人绑架了。她需要帮助外星人解决一个问题。
## 题目描述

就在 COCI 比赛当天，外星人计划乘 $n$ 艘宇宙飞船访问地球，授予参赛者丰厚的奖励。他们的宇宙飞船都是完美的圆形。

出于安全考虑，他们选择了 $m$ 对在着陆时外部必须相接触的飞船。外星人已经确定了每艘飞船的着陆点坐标，而 Berilij 的任务是确定每艘飞船的半径，以确保所有飞船都能安全着陆。

![](https://cdn.luogu.com.cn/upload/image_hosting/frerrx7n.png)

如图，左右两对飞船均不满足外部接触的条件。只有中间的一对飞船满足外部接触的条件。换句话说，“外部接触”定义为当且仅当两艘飞船对应的圆形**外切**时，这两艘飞船的外部相接触。

宇宙飞船造价昂贵，它们的成本等于它们的面积，所以外星人希望宇宙飞船成本尽可能小。由于外星人科技非常先进，因此外星人的宇宙飞船可以重叠，直径也可以为 $0$。

如果 Berilij 不能解决这个问题，外星人将会吃掉她！请你帮帮小羊 Berilij。
## 输入格式

第一行包含两个整数 $n,m$，分别表示外星人的飞船数量以及需要接触的飞船的对数。

接下来 $n$ 行每行两个实数 $x_i,y_i$，表示第 $i$ 艘飞船着陆点的坐标。给出的坐标均精确到小数点后十位。

下面的 $m$ 行包含两个整数 $a_i$ 和 $b_i$，表示第 $a_i$ 号和第 $b_i$ 号飞船在着陆后必须外部接触。数据保证无序对 $(a_i,b_i)$ 不重复。
## 输出格式

如果无解，输出一行```NE```。

否则第一行输出```DA```，接下来 $n$ 行输出成本最小的方案下每艘飞船的半径。
## 样例

### 样例输入 #1
```
3 3
0.0000000000 0.0000000000
0.0000000000 2.0000000000
2.0000000000 0.0000000000
1 2
2 3
3 1
```
### 样例输出 #1
```
DA
0.585786
1.414214
1.414214
```
### 样例输入 #2
```
5 4
-0.4585133080 0.2893567973
9.9368007273 7.1806641913
-8.4621834970 -2.8309311865
0.0122121945 -2.8309311865
2.3991780589 -8.8626906628
2 1
3 2
4 3
5 1
```
### 样例输出 #2
```
DA
0.000000
12.472076
8.474396
0.000000
9.587824
```
### 样例输入 #3
```
5 5
0.0000000000 0.0000000000
1.0000000000 2.0000000000
2.0000000000 4.0000000000
3.0000000000 6.0000000000
4.0000000000 8.0000000000
1 2
2 3
3 4
4 5
5 1
```
### 样例输出 #3
```
NE
```
## 提示

当你的答案与正确答案误差不大于 $10^{-4}$ 时，答案被视为正确的。

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $15$ | $n$ 为奇数且所有飞船都恰好与两艘飞船接触 |
| $2$ | $25$ | 数据保证有解 |
| $3$ | $30$ | 对于任何一对飞船 $(a,b)$ 都有且仅有一个飞船序列满足其起始于 $a$ 结束于 $b$ 且此序列内任意相邻的两艘飞船都彼此接触 |
| $4$ | $40$ | 无特殊性质 |

对于 $100\%$ 的数据，$1\leq n,m \leq 10^5,-10^4\leq x_i,y_i \leq 10^4,1\leq a_i,b_i \leq n$ 且 $a_i \neq b_i$。

本题满分 $110$ 分。


---

---
title: "[PA 2021] Drzewo czerwono-czarne"
layout: "post"
diff: 省选/NOI-
pid: P9039
tag: ['2021', 'PA（波兰）']
---
# [PA 2021] Drzewo czerwono-czarne
## 题目描述

你熟悉红黑树这种数据结构吗？在本题我们将考虑一种节点颜色为红色或黑色的树，但请放心，如果你听说过刚才提到的数据结构的话，最好迅速忘掉它。

给定一棵树（即，一个无环的无向连通图），每个节点被涂成红或黑两种颜色之一。你可以选择被一条边相连的两个节点 $v$ 和 $u$，并把 $v$ 重新涂成和 $u$ 一样的颜色。

你的任务是确定经过一系列操作（**有可能不进行任何操作**）之后，一种最初的涂色情况能否变为最终给定的涂色情况。
## 输入格式

**本题有多组测试数据。**

第一行，一个整数 $T$，表示数据组数。

对于每组数据：

第一行，一个整数 $n$，表示树的节点数；

第二行，$n$ 个字符，每个字符是 $0$ 或 $1$，如果第 $i$ 个字符是 $0$，则初始时第 $i$ 个节点被涂成红色。如果第 $i$ 个字符是 $1$，则初始时第 $i$ 个节点被涂成黑色；

第三行，$n$ 个字符，每个字符是 $0$ 或 $1$，如果第 $i$ 个字符是 $0$，则最后第 $i$ 个节点必须被涂成红色。如果第 $i$ 个字符是 $1$，则最后第 $i$ 个节点必须被涂成黑色；

接下来 $n - 1$ 行，其中第 $i$ 行有两个整数 $a_i, b_i$，表示树上的一条边；
## 输出格式

对于每组数据：

一行，一个字符串。如果存在一个操作序列能使涂色情况变为最终给定的情况，输出 `TAK`，否则输出 `NIE`。
## 样例

### 样例输入 #1
```
3
4
1011
1100
1 2
2 3
2 4
2
10
10
1 2
2
10
01
1 2
```
### 样例输出 #1
```
TAK
TAK
NIE
```
## 提示

对于 $100\%$ 的数据，$1 \leq T, n \leq 10^5$，$1 \leq \sum n \leq 10^6$，$1 \leq a_i, b_i \leq n$。


---

---
title: "[PA 2021] Poborcy podatkowi"
layout: "post"
diff: 省选/NOI-
pid: P9047
tag: ['2021', 'PA（波兰）']
---
# [PA 2021] Poborcy podatkowi
## 题目描述

给定一棵 $n$ 个点的树，你可以选择若干条长度为 $4$ 的不相交链（**可以不选**）。

每个选链的方案的收益为所选链的并集的边权和，求最大收益。
## 输入格式

第一行，一个整数 $n$；

接下来 $n - 1$ 行，每行三个整数 $u, v, w$，表示树上的一条边 $(u, v)$，其边权为 $w$。
## 输出格式

一行，一个整数，表示所求的值。
## 样例

### 样例输入 #1
```
19
1 2 1
2 3 2
3 4 -1
4 5 -1
5 6 2
6 7 11
7 8 12
8 9 13
9 10 14
11 12 3
12 13 0
13 14 0
14 15 0
15 16 1
16 4 0
4 17 0
17 18 0
18 19 2
```
### 样例输出 #1
```
57
```
### 样例输入 #2
```
6
1 2 2
2 3 -1
3 4 -1
4 5 -1
5 6 2
```
### 样例输出 #2
```
0
```
## 提示

#### 样例 #1 解释
给出一种最优方案：选择链 $2 \to 6$，$6 \to 10$，$11 \to 15$，$16 \to 19$。
#### 样例 #2 解释
由于每一条长度为 $4$ 的链权值均为负数，所以不选最优。
#### 数据范围
对于 $100\%$ 的数据，$2 \leq n \leq 2 \times 10^5$，$-10^9 \leq a_i \leq 10^9$。


---

---
title: "[集训队互测 2021] 数列重排"
layout: "post"
diff: 省选/NOI-
pid: P9055
tag: ['集训队互测', '2021', 'O2优化']
---
# [集训队互测 2021] 数列重排
## 题目背景

dottle bot。
## 题目描述

定义一个数列区间的 $\textrm{mex}$ 为区间中最小的没有出现过的自然数，定义一个数列的价值为其中 $\textrm{mex}\geq k$ 的区间数量。

给定 $n$ 个小于 $m$ 的自然数和一个区间 $[l,r]$，令 $f(k)$ 表示 $n$ 个数构成的数列所有重排列中数列价值的最大值，对于每一个 $k\in [l,r]$，求出 $f(k)$。

令 $a_i$ 表示数字 $i$ 出现的次数，保证存在正整数 $X$，使得  $\forall i\le m-1,a_i\in \{X,X+1\}$。
## 输入格式

由于 $n$ 可能很大，将采取如下方式减少读入量：

第一行四个整数 $m,l,r,X$。

第二行一个长度为 $m$ 的 $01$ 串，若其中第 $i$ 个位置为 $1$ 则数字 $i-1$ 的出现次数为 $X+1$，否则出现次数为 $X$。

根据输入可以推出 $n=mX+S$，其中 $S$ 为 $01$ 串中 $1$ 的数量。
## 输出格式

为了减少输出量，令 $ans=\displaystyle{\bigoplus_{i=l}^r}$$  (233^if(i)\bmod 998244353)$，其中 $\displaystyle\bigoplus$ 表示二进制下的按位异或，输出一行一个整数 $ans$。
## 样例

### 样例输入 #1
```
2 0 1 2
10
```
### 样例输出 #1
```
3034
```
### 样例输入 #2
```
14 1 14 13
10110101110101
```
### 样例输出 #2
```
379883349
```
## 提示

#### 样例 1 解释

在样例给出的数列中，有 $3$ 个 $0$ 和 $2$ 个 $1$，任意排列 $f(0)$ 均为 $15$，排列为 $\textrm{01010}$ 时 $f(1)$ 有最大值 $13$，答案为：
$$
\displaystyle (233^0\times 15\bmod 998244353)\oplus(233^1\times 13\bmod 998244353)=3034
$$

#### 数据范围

- Subtask 1（5 points）：$n,m\leq 9$。
- Subtask 2（15 points）：$n,m\leq 200$。
- Subtask 3（15 points）：$n,m\leq 5\times 10^3$。
- Subtask 4（5 points）：$m\leq 2$，$l=0$，$r=1$。
- Subtask 5（10 points）：$m\leq 10^6$，$l=m$，$r=m$。 
- Subtask 6（10 points）：$m\leq 10^6$，$X=1$，$s_i=0$。
- Subtask 7（15 points）：$m\leq 10^6$，$r-l+1\leq 10^4$。
- Subtask 8（15 points）：$m\leq 2\times 10^6$。
- Subtask 9（10 points）：无特殊限制。

对于所有数据，满足 $n\leq 10^9$，$m\leq 10^7$，$0\leq l\leq r\leq m$，$X\geq 1$。


---

---
title: "[PA 2018] Magiczne wieże"
layout: "post"
diff: 省选/NOI-
pid: P9081
tag: ['2018', 'Special Judge', 'PA（波兰）']
---
# [PA 2018] Magiczne wieże
## 题目描述

**译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/)  Runda 3 [Magiczne wieże](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/mag/)**

在一个王国中有 $n$ 个魔法师。每个魔法师有两座魔法塔。并且魔法师可以在自己的两座塔之间随意传送。

出于某种原因，该国的居民只想居住在被魔法师环绕的区域。具体来说，如果一位居民从住所向任何方向移动，他都将接近其中一个魔法师（无论在哪个塔），他的住所就是安全的。

依次连接所有的安全住所，它们围成了一个安全区域，请你求出这个区域的面积。
## 输入格式

第一行一个整数 $n$，表示魔法师的数量。

接下来的 $n$ 行，每行 $4$ 个整数 $ax_i,ay_i,bx_i,by_i$，表示第 $i$ 个魔法师所拥有的两座魔法塔 $a,b$。

数据保证没有两座塔在同一位置上。
## 输出格式

输出安全区域的面积。特殊地，如果没有安全点，那么区域的面积为 $0$。

你的输出与标准答案的相对误差不能超过 $10^{-8}$。
## 样例

### 样例输入 #1
```
4
0 0 0 -1
-1 5 -2 2
4 0 4 1
2 2 6 6
```
### 样例输出 #1
```
4.8000000000
```
## 提示

#### 样例 1 解释

![](https://cdn.luogu.com.cn/upload/image_hosting/yul09fhv.png)

如图，黑色线段为一位魔法师的两座塔，灰色区域为安全区域。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，$3\leq n\leq 100$，$-500\leq ax_i,ay_i,bx_i,by_i\leq 500$。

共 $10$ 个子任务，其中以下各个条件均至少有一个子任务满足：（每行为一个条件）

- $n\leq 10$，$-30\leq ax_i,ay_i,bx_i,by_i\leq 30$。

- $n\leq 10$。

- $-30\leq ax_i,ay_i,bx_i,by_i\leq 30$。


---

---
title: "[PA 2018] Skwarki"
layout: "post"
diff: 省选/NOI-
pid: P9084
tag: ['2018', 'PA（波兰）']
---
# [PA 2018] Skwarki
## 题目描述

**题目译自 [PA 2018](https://sio2.mimuw.edu.pl/c/pa-2018-1/dashboard/) Runda 5 [Skwarki](https://sio2.mimuw.edu.pl/c/pa-2018-1/p/skw/)** 。

求有多少种长度为 $ N $ 的满足以下条件的序列 ：

* $ 1 \sim N $ 这 $ N $ 个数在序列中各出现了一次；
* 至少进行 $K$ 次操作后，该序列才只含有 $1$ 个元素。

下面对操作进行描述：

设 $A_i$ 为序列中的第 $i$ 个元素（$1 < i < \mathrm{len}$ ， $\mathrm{len}$ 为序列长度），若 $A_{i-1} > A_{i}$ 或 $A_{i+1} > A_{i}$ 则标记 $A_i$ 。 若 $A_2 > A_1$ 则标记 $A_1$ ， 若 $A_{\mathrm{len}-1} > A_{\mathrm{len}}$ 则标记 $A_{\mathrm{len}}$ 。

然后，将有标记的元素从序列中删除。

满足条件的序列可能很多，所以请将结果对 $P$ 取模。
## 输入格式

输入仅一行，包含三个整数 $N,K,P$。
## 输出格式

输出一行一个整数，表示满足条件的序列个数对 $P$ 取模的结果。
## 样例

### 样例输入 #1
```
5 3 100000007
```
### 样例输出 #1
```
4
```
## 提示

#### 样例 1 解释

所有满足条件的序列列举如下：

- $(4,1,3,2,5)$
- $(4,2,3,1,5)$
- $(5,1,3,2,4)$
- $(5,2,3,1,4)$

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1 \le K,N \le 1000$ , $N \ge 2$ , $10^8 \le P \le 10^9$。


---

---
title: "[PA 2020] Sen o podboju"
layout: "post"
diff: 省选/NOI-
pid: P9096
tag: ['2020', 'PA（波兰）']
---
# [PA 2020] Sen o podboju
## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 2 [Sen o podboju](https://sio2.mimuw.edu.pl/c/pa-2020-1/p/sen/)**

国王 Byteur，Byteotia 的统治者，目前正梦想着征服 Bitotia。就像在现实世界中一样，在他的梦中他还远远没有打败敌人。因此，他想知道他能做些什么来削弱敌国的实力……

在他的梦中，Bitotia 由 $n$ 个城市（编号从 $1$ 到 $n$）组成，由 $n-1$ 条双向道路连接，可以只用这些道路从任意一个城市到达任意其他城市。换句话说，Bitotia 的地图形成了一棵树。然而，Byteur 并不记得 Bitotia 的确切道路网络……所以他的脑内生成了一个**随机**的道路网络。

国王得出的结论是，强行将 Bitotia 分割成 $k$ 个小国是个好主意。Byteur 所说的划分，是指秘密地破坏正好是 $k - 1$ 条道路，这将迫使 Bitotia 分解成 $k$ 个小国，这些小国是去除选定的边后形成的连通子图。

然而，对于国王来说，摧毁任何 $k-1$ 条道路都是不够的。每个 Bitotia 的城市都有一个**军事系数** $a_i$，也是由 Byteur 脑内想出来的。Byteur 知道，一个小国的军事力量越强，对 Byteotia 的威胁就越大。更准确地说：如果在一个小国，其城市的军事系数之和等于 $S$，那么来自这个小国的威胁就等于 $S^2$。对 Byteotia 的总威胁等于这 $k$ 个小国所产生的威胁之和。

现在 Byteur 求助于你——他的梦想（指的是字面意思！）程序员。请帮助他，计算出 Bitotia 分裂成各州后可能产生的最小总威胁。由于 Byteur 还没有决定参数 $k$ 的值，请计算 $k$ 取从 $1$ 到 $n$（包含两端）所有值的结果。
## 输入格式

第一行包含一个整数 $t$，表示测试点总数 ~~Byteur 做的梦的个数~~。接下来描述每一组测试点，测试点的输入格式都相同。

每个测试点第一行包含一个整数 $n$。

第二行包含一个长度为 $n$ 的整数序列 $a_1,a_2,\cdots ,a_n$。

接下来 $n-1$ 行是 Bitotia 的路网描述，每行两个整数 $b_i,c_i$，表示城市 $b_i,c_i$ 被一条路相连。保证输入的图是一棵树。

Byteur 按如下方法生成数据。首先手动选取一个整数 $t$，一个整数区间 $[n_{\min},n_{\max}]$ 和 $a_{\max}$ 的值。接下来按如下步骤独立生成每个测试点：

- 城市个数 $n$ 的值从 $[n_{\min},n_{\max}]$ 区间内均匀随机选取。
- 每个 $a_i$ 的值从 $[1,a_{\max}]$ 区间内独立均匀随机选取。
- 生成一个自然数序列 $(p_1,p_2,\cdots ,p_{n-2})$。序列中的每一个元素都是从 $[1,n]$ 区间中独立均匀随机选取的。Byteur 将其作为路网的 [Prüfer 序列](https://en.wikipedia.org/wiki/Pr%C3%BCfer_sequence)，也就是测试点中给出的树的 Prüfer 序列是 $(p_1,p_2,\cdots,p_{n-2})$。
## 输出格式

输出 $t$ 行，描述每个测试点的答案。每行包含 $n$ 个整数（其中 $n$ 是输入中的城市数量）；第 $k$ 个整数表示 Bitotia 在被划分为 $k$ 个小国后所能造成的最小威胁。
## 样例

### 样例输入 #1
```
2
7
9 1 4 2 6 4 7
1 7
6 4
2 3
5 7
3 4
5 3
5
4 8 2 3 1
4 3
3 1
4 2
5 1
```
### 样例输出 #1
```
1089 545 371 287 227 211 203
324 164 114 102 94
```
## 提示

#### 样例 1 解释

以上测试数据使用随机数种子为 $8\ 122\ 020$，$t=2,n_{\min}=5,n_{\max}=7,a_{\max}=10$ 的参数生成。

对于第一个测试案例，输出的第一个数字是 $(9+1+4+2+6+4+7)^2=1089$，代表未被分割的 Bitotia 所带来的总威胁。输出的第二个数字对应的是如果连接 $5$ 号和 $7$ 号城市的道路被摧毁的总威胁；在这种情况下，威胁将是 $(9+7)^2+(1+4+2+6+4)^2=545$。

------------

#### 数据生成

本题的样例生成器在附件中给出。生成器将以下内容作为输入接受：生成器种子和数字 $t,n_{\min},n_{\max},a_{\max}$。本题的所有测试数据都将用与之相当的生成器生成（即用不同的伪随机数库，与编译器的实现无关）。

为了确保测试的随机性，每个测试点的 $t,n_{\min},n_{\max},a_{\max}$ 的值都是手动选择的，生成器的种子是随机选择的。

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le t\le 10$，$2\le n\le 300$，$1\le a_i\le 10^6$，$1\le b_i,c_i\le n$，$2\le n_{\min}\le n_{\max}\le 300$，$1\le a_{\max}\le 10^6$。


---

---
title: "[PA 2020] Bardzo skomplikowany test"
layout: "post"
diff: 省选/NOI-
pid: P9103
tag: ['2020', 'PA（波兰）']
---
# [PA 2020] Bardzo skomplikowany test
## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Bardzo skomplikowany test](https://sio2.mimuw.edu.pl/c/pa-2020-1/bst/)**

Bytie 刚刚参加了算法和数据结构这门课的面试。他没有为之学习太长时间，所以他做得不是太好。经过几分钟的交谈，这位心碎的主讲老师决定给这个男孩最后一次机会。

- 「孩儿，你知道啥是 BST 不？」教授问

Bytie 听到这句话后内心狂喜，因为在他上课睡觉的时候记住了一些理论。

- 「知道。大小为 $n$ 的 BST 是一棵有根树，其顶点用 $1$ 到 $n$ 的整数来编号。每个节点最多可以有两个子节点；它可以有一个最多一个左子节点和一个最多一个右子节点。此外，每个节点的编号必须大于其左子树中所有节点的编号，并小于其右子树中所有顶点的编号。」Bytie 回答说，他达到了他潜意识的深处。
- 「很好。让我们看看你是否记住了如何对 BST 进行旋转。」一直坐在那里的教授回答说。他站起来，向黑板走去。

Bytie 被冷汗浸透了。他一时失去了信心，因为他记不起旋转的具体原理（可能在上这节课的时候，他正在另一边摸鱼，没听课）。考官在黑板上画了两棵同样大小的 BST 树，并让 Bytie 用正确的旋转将第一棵树转化为第二棵树。

Bytie 想了一会儿，认为左旋就是选择某个节点 $v$ 和它的右子节点 $w$，并让 $w$ 成为 $v$ 的父节点。Bytie 的直觉用以下伪代码描述。

```
if v.Parent != null then
    if v.Parent.RightSon == v then
        v.Parent.RightSon := w
    else
        v.Parent.LeftSon := w
w.Parent := v.Parent
v.Parent := w
w.LeftSon := v
v.RightSon := null
```

![](https://cdn.luogu.com.cn/upload/image_hosting/shqgiur7.png)

以此类推，Bytie 理解了右旋，其中 $w$ 是 $v$ 的左子节点。

```
if v.Parent != null then
    if v.Parent.RightSon == v then
        v.Parent.RightSon := w
    else
        v.Parent.LeftSon := w
w.Parent := v.Parent
v.Parent := w
w.RightSon := v
v.LeftSon := null
```

![](https://cdn.luogu.com.cn/upload/image_hosting/tpmzihlx.png)

然而，Bytie 很快就注意到有些不对劲。如果节点 $w$ 在左旋时有左子树，它就会丢失！同样在右转过程中，节点 $w$ 的右子树也会丢失。

- 「快点孩儿，你不是唯一一个想通过这次考试的人。」教授不耐烦地催促道。

在没有太多时间考虑的情况下，Bytie 假设只有在这个有问题的子树是空的情况下才能执行旋转，也就是说，如果没有顶点丢失并且树保持一致的话才进行旋转。

为了尽快结束他的煎熬，他决定进行最少次数的旋转，使他能够将第一棵树变成第二棵。请告诉他这是否可行，如果可行，他需要进行多少次轮换？由于这个数字可能相当大，请告诉他这个值对 $10^9+7$ 取模后的值。
## 输入格式

第一行包含一个整数 $n$，表示这个 BST 的大小。

接下来两行描述这两棵树。对于一棵树用一行 $n$ 个整数 $a_1,a_2,\cdots,a_n$ 描述。如果 $a_i\ge 1$，表示 $i$ 节点的父节点；如果 $a_i=-1$，则表示这是树的根节点。

你可以假设这两棵树都是合法的 BST，即树中没有环，恰好有一个根节点，每个节点最多只有一个比自己小的子节点和一个比自己大的子节点。
## 输出格式

输出应该包含一个整数，表示用 Bytie 的方式把第一棵树转化为第二棵树所需最少旋转次数对 $10^9+7$ 取模后的值，如果不可能转化，输出 $-1$。
## 样例

### 样例输入 #1
```
4
3 1 -1 3
2 -1 4 2
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
8
2 4 2 7 4 5 -1 7
2 3 6 5 3 -1 6 7
```
### 样例输出 #2
```
7
```
## 提示

#### 样例 1 解释

下图展示了旋转最小次数所采取的旋转方式。

![](https://cdn.luogu.com.cn/upload/image_hosting/f1dblwez.png)

------------

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n\le 5\times 10^5$，$-1\le a_i\le n$，$a_i\neq 0$。


---

---
title: "[PA 2020] Królewski bal"
layout: "post"
diff: 省选/NOI-
pid: P9104
tag: ['2020', 'PA（波兰）']
---
# [PA 2020] Królewski bal
## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 5 [Królewski bal](https://sio2.mimuw.edu.pl/c/pa-2020-1/bal/)**

自古以来，Byteotia 的所有统治者都会举行奢华的舞会，Byteur 国王也不例外。然而，每当他组织一次，他就觉得少了点什么。因此，他决定在下一次舞会中加入一些艺术元素。

为此，Byteur 国王委托他的首席顾问编排演出，不久之后，首席顾问向他提出了自己的设想。

根据顾问的计划，$n^2$ 名马戏团演员将参加演出，其中 $n$ 是一个正整数。在演出的压轴部分，他们将排成 $n$ 行，每行恰好有 $n$ 个马戏团演员，从而形成一个 $n\times n$ 大小的正方形。在压轴部分开始时，每个演员将带或不带燃烧的呼拉圈跳舞。在午夜时分，一些带着呼啦圈跳舞的马戏团演员可能会把呼啦圈扔给其他没有带呼啦圈跳舞的马戏团演员。每个演员最多允许扔给一个其他的演员。

他们都会在同一时间进行投掷。他们是专业人士，所以他们的呼啦圈肯定不会在空中相撞，但这里有一个问题。**每次投掷必须在位于同一行或同一列的演员之间进行**。

值得一提的是，Byteur 国王喜欢大规模的行动，所以马戏团演员的数量可能非常庞大。在制定计划时，他的顾问首先确定了数字 $n$，并假设所有马戏团的演员都会在没有燃烧呼拉圈的情况下开始最后的表演。然后，他会选择 $m$ 次一些特定的行列范围，画出一个矩形，并使得这个区域中的每个演员应该以不同的方式开始压轴表演。即，如果在之前的方案中他们拿着呼啦圈开始，则这版方案中他们就不拿呼啦圈开始，反之亦然。

Byteur 国王在得知顾问的计划后，立即明白，为了使演出尽可能地壮观，呼啦圈的抛掷次数应该尽可能地多。Byteur 国王想知道这个数字，但这并不容易，因为他不断修改计划。他的每项修改（他总共已经做了 $q$ 次修改）都涉及到挑选一个马戏团演员并改变他开始压轴表演的方式（即如果他之前拿着呼啦圈开始，那么他现在就不拿着呼啦圈开始，反之亦然）。国王的修改在方案上永久保留，也就是说，如果有任何适用于某个马戏团演员的修改，这个修改的效果一直保留到最后，除非国王再次修改他。

因此，顾问的任务并不简单。帮助他，对于区间 $[0, q]$ 中的每个整数 $i$，在考虑国王的前 $i$ 次修改后，确定可能发生的最大投掷次数。
## 输入格式

第一行三个整数 $n,m,q$。

接下来 $m$ 行描述顾问的方案，每行包含四个整数 $x_1,y_1,x_2,y_2$，表示对行编号 $x_1$ 到 $x_2$（包含两端），列编号 $y_1$ 到 $y_2$（包含两端）的艺术家进行一次操作。行列编号均从 $1$ 到 $n$。

接下来 $q$ 行描述国王的修改，第 $i$ 行包含两个数 $a_i,b_i$，表示国王修改第 $a_i$ 行第 $b_i$ 列的演员状态。
## 输出格式

输出 $q+1$ 行，第 $i$ 行输出如果考虑国王的前 $i-1$ 次修改，可能发生的最大投掷次数。
## 样例

### 样例输入 #1
```
4 3 4
1 2 4 2
3 1 3 4
3 2 3 2
4 4
3 2
4 3
4 4
```
### 样例输出 #1
```
6
7
7
8
7
```
### 样例输入 #2
```
7 2 0
1 1 6 6
2 2 7 7
```
### 样例输出 #2
```
22
```
## 提示

#### 样例 1 解释

下图展示了国王进行了第一次修改后的情况。演出开始有呼啦圈的演员用加粗圆圈标出，箭头标明了可能发生的投掷。

![](https://cdn.luogu.com.cn/upload/image_hosting/brbphngp.png)

------------

#### 数据范围

**本题采用捆绑测试**

- 对于一些子任务，满足 $n\le 50$，$m\le 10^4$，$q=0$。
- 对于一些其他的子任务，满足 $n\le 200$，$m\le 10^5$，$q\le 10$。
- 对于一些其他的子任务，满足 $n\le 2\times 10^3$，$m\le 10^5$，$q\le 5\times 10^3$。
- 对于一些其他的子任务，满足 $q=0$。

对于上述情况，至少有一个子任务满足。

对于 $100\%$ 的数据，保证 $1\le n\le 3\times 10^5$，$0\le m,q\le 3\times 10^5$，$1\le x_1\le x_2\le n$，$1\le y_1\le y_2\le n$，$1\le a_i,b_i\le n$。

此外，对于每个子任务，至少满足以下条件中的一个：

- $n\le 2\times 10^3$
- 时间限制为 $12$ 秒

由于未给出具体子任务时间限制，因此在洛谷上所有子任务的时间限制均为 $3$ 秒。


---

---
title: "[PA 2020] Malowanie płotu"
layout: "post"
diff: 省选/NOI-
pid: P9108
tag: ['2020', 'PA（波兰）']
---
# [PA 2020] Malowanie płotu
## 题目描述

**题目译自 [PA 2020](https://sio2.mimuw.edu.pl/c/pa-2020-1/dashboard/) Runda 4 [Malowanie płotu](https://sio2.mimuw.edu.pl/c/pa-2020-1/mal/)**

今年的秋季天气已经完全破坏了 Potyczek 先生的围栏上的漆。围栏需要尽快用特殊的蓝色防水剂进行处理，以免即将到来的冬季对其造成不可弥补的破坏。Potyczek 先生请他邻居的勤劳儿子 Bytie 来做这件事。这个男孩今天早上完成了任务，但做得相当粗心，因为他急着参加下一轮 PA。

Potyczek 先生的围栏由 $n$ 根木条组成，每根木条分为长度相等的 $m$ 段。Bytie 只把每根木条从上到下用防水剂涂了一遍，不幸的是，这可能还不足以把栅栏全部涂满。然而，在每根木条上涂防水剂的段都是连续的，每个段要么完全涂上，要么根本不涂。进一步看来，男孩所涂的那部分栅栏是一致的，即每两个连续的木条上所涂的段都存在一个非空的相交区间。

例如，涂完的围栏可能如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/2ov15dzh.png)

由于以下三个原因，下图所示情况是不可能的。

- 编号为 $1$ 的木条根本没涂防水剂。
- 编号为 $3$ 的木条一致的段没有涂防水剂。
- 编号 $5,6$ 的木条涂防水剂的部分相交区间为空。

![](https://cdn.luogu.com.cn/upload/image_hosting/9f315wbr.png)

编写一个程序，计算 Bytie 按照上述规则可以用多少种不同的方式来涂围栏。如果有一段围栏在其中一种方式中被涂上了颜色，而在另一种方式中没有被涂上颜色，那么就称这两种方式是不同的。方法的数量可能相当多，所以只要输出它除以质数 $p$ 的余数就可以了。
## 输入格式

输入一行三个整数 $n,m,p$。分别表示木条个数，每根木条上段的个数和质数 $p$。
## 输出格式

输出一个整数表示 Bytie 按照上述规则给围栏涂色的方案数对 $p$ 取模后的值。
## 样例

### 样例输入 #1
```
3 2 100000007
```
### 样例输出 #1
```
17
```
### 样例输入 #2
```
6 9 813443923
```
### 样例输出 #2
```
57
```
## 提示

#### 数据范围

**本题采用捆绑测试**

对于 $100\%$ 的数据，保证 $1\le n\times m\le 10^7$，$10^8\le p\le 10^9$，$p\in \mathbb{P}$。


---

---
title: "[IOI 2009] Hiring"
layout: "post"
diff: 省选/NOI-
pid: P9113
tag: ['2009', 'IOI', 'Special Judge', 'O2优化']
---
# [IOI 2009] Hiring
## 题目背景

IOI2009 D1T2
## 题目描述

你需要为一个建设项目雇佣一些工人。现在有 $N$ 位候选工人，标号为 $1\sim N$。第 $k$ 个工人要求如果自己被雇佣，则必须得到至少 $S_k$ 美元的工资。每个工人有能力值 $Q_k$。建筑业监管局规定，你必须按工人们的能力值的比例分配他们的工资。例如，如果 $Q_A = 3Q_B$，则你付给 $A$ 的工资必须恰为 $B$ 的三倍。你可以付给你的工人们任意非负实数金额的工资。

你的手上有 $W$ 美元，你想用这些钱雇佣最大数量的工人。你可以决定选用哪些工人以及付给他们的工资，但必须满足每个工人的最低工资要求以及监管局的分配规定，并保证工资总额不超过 $W$。

工人们的能力值和你的项目无关，因此你只想最大化雇佣工人的数量，而不关心他们的能力值。尽管如此，你仍希望最小化你的支出，即如果存在多种方案，则你需要选择支付给工人们的工资总额最小的那一个。如果仍存在多种方案，任意一个都是满足要求的。

**任务**：编写一个程序，给定每个工人的工资要求和能力值，以及你拥有的资金，计算出具体雇佣哪些工人。你必须在最大化工人的数量的前提下最小化支出，并满足上文提到的监管局的要求。
## 输入格式

第一行包含两个由空格隔开的整数 $N, W$，分别表示候选工人数和你拥有的资金。

接下来 $N$ 行，每行描述一个候选工人。其中第 $k$ 行描述第 $k$ 个候选工人，包含两个由空格隔开的整数 $S_k, Q_k$。
## 输出格式

第一行一个整数 $H$，表示你雇佣的工人数量。

接下来 $H$ 行，每行一个整数，表示你雇佣的所有工人的编号（互不相同），以任意顺序排列。
## 样例

### 样例输入 #1
```
4 100
5 1000
10 100
8 10
20 1

```
### 样例输出 #1
```
2
2
3

```
### 样例输入 #2
```
3 4
1 2
1 3
1 3

```
### 样例输出 #2
```
3
1
2
3
```
## 提示

### 样例解释

- 样例 1：选择工人 $2$ 和 $3$ 是唯一符合所有要求且雇佣了两个工人的方案。你可以分别付给他们 $80$ 美元和 $8$ 美元，满足 $100$ 美元的预算。

- 样例 2：你可以雇佣三个工人。你可以分别付给他们 $1$ 美元，$1.5$ 美元和 $1.5$ 美元。

### 数据范围与约定

对于任意测试点，如果你的方案满足了所有要求和你的目标，你将获得该测试点的满分。**否则**，如果你的第一行是正确的，即你输出了正确的工人数量 $H$，无论你接下来的输出是否符合格式，你都将获得该测试点 $50\%$ 的分数。

注意，在实际评测中，只有你的输出符合格式，才能获得测试点 $50\%$ 或 $100\%$ 的分数。

- 对于 $50\%$ 的数据，$N\leq 5000$。
- 对于 $100\%$ 的数据，$1\leq N\leq 5\times 10 ^ 5$，$1\leq S_k, Q_k\leq 2\times 10 ^ 4$，$1\leq W\leq 10 ^ {10}$。

注意，$W$ 超出了 $32$ 位整形变量的存储范围。你需要使用 $64$ 位整型变量存储 $W$，例如 C/C++ 中的 `long long` 或 Pascal 中的 `int64`。


---

---
title: "[春季测试 2023] 密码锁"
layout: "post"
diff: 省选/NOI-
pid: P9120
tag: ['2023', 'NOIP 提高组', 'O2优化']
---
# [春季测试 2023] 密码锁
## 题目描述

寒假过后，小 I 回到学校，发现自己忘记了自行车锁的密码，于是请你帮忙。

小 I 自行车上的密码锁有 $n$ 个拨圈，每个拨圈有 $k$（$k \leq 4$）格。密码锁上的每一格都包含一个正整数，其中第 $j$ 个拨圈的第 $i$ 格上的正整数为 $a _ {i, j}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/0owivo0l.png)

（一个锁的例子，其中 $k = n = 3$，每列表示一个拨圈，拨圈的格子从上往下编号。）

你可以对每个拨圈拨若干次（也可以不拨），每拨一次拨圈，它的格子就会进行一次轮换。形式化地，拨第 $j$ 个拨圈一次，则会让第 $j$ 个拨圈上第 $i$ 格的数字移动到第 $((i \bmod k) + 1)$ 格，其他拨圈不动。

![](https://cdn.luogu.com.cn/upload/image_hosting/9d3g6b74.png)

（一个拨动拨圈的例子，对左侧的锁拨一次第二个拨圈得到右侧的锁。）

为了方便记忆，小 I 设定密码时要求同一行上的数字尽可能靠近。
形式化地，对于 $1 \leq i \leq k$，定义密码锁第 $i$ 行的松散度为

$$
c(i) = \max \limits _ {j = 1} ^ n a _ {i, j} - \min \limits _ {j = 1} ^ n a _ {i, j} 
$$

同时定义整个密码锁的松散度为

$$
C = \max \limits _ {1 \leq i \leq k} c(i)
$$

因为能开锁的状态满足 $C$ 尽可能小，因此小 I 希望你找出最小的 $C$ 值。
## 输入格式

**本题有多组测试数据，题目保证一个测试点中所有测试数据的 $k$ 相同。**

第一行包含两个正整数 $T, k$，分别表示测试数据组数和密码锁拨圈上的格数。

接下来一共 $T$ 组数据，每组数据格式如下：

第一行包含一个正整数 $n$，表示拨圈数。

接下来 $k$ 行，每行包含 $n$ 个正整数，其中第 $i$ 行第 $j$ 个整数 $a _ {i,j}$ 表示密码锁第 $j$ 个拨圈上第 $i$ 格对应的数字。

**注意输入的矩阵中每一列对应一个拨圈，而非每一行对应一个拨圈。**
## 输出格式

对于每组数据，输出一行包含一个整数，表示所有方案中 $C$ 的最小值。
## 样例

### 样例输入 #1
```
2 3
3
1 2 1
2 3 2
3 1 3
2
1 2
2 1
1 2
```
### 样例输出 #1
```
0
1
```
### 样例输入 #2
```
见选手目录下的 lock/lock2.in。
```
### 样例输出 #2
```
见选手目录下的 lock/lock2.ans。
```
### 样例输入 #3
```
见选手目录下的 lock/lock3.in。
```
### 样例输出 #3
```
见选手目录下的 lock/lock3.ans。
```
### 样例输入 #4
```
见选手目录下的 lock/lock4.in。
```
### 样例输出 #4
```
见选手目录下的 lock/lock4.ans。
```
### 样例输入 #5
```
见选手目录下的 lock/lock5.in。
```
### 样例输出 #5
```
见选手目录下的 lock/lock5.ans。
```
## 提示

**【样例 1 解释】**

第一组样例对应题目描述中的例子。
在拨第二个拨圈一次后，每个拨圈都是 $\{1, 2, 3\}$，此时松散度为 $0$。
容易证明无论如何松散度都不可能小于 $0$，因此输出 $0$。

以下四个样例分别对应 $k = 1, 2, 3, 4$ 的情况，且样例中 $n$ 的取值有一定梯度。

**【数据范围】**

设 $\sum n$ 为一个测试点中所有测试数据的 $n$ 的和。

对于所有数据，保证 $1 \leq T$，$1 \leq k \leq 4$，$1 \leq a _ {i ,j} \leq  3 \times 10 ^ 4$。


本题分为两类测试点。


第一类测试点共有十二个，保证 $k \leq 3$，$n \leq 5 \times 10 ^ 4$，$\sum n \leq 1.5 \times 10 ^ 5$。

| 测试点编号 | $n \leq$ | $\sum n \leq $ | $k = $ |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $20$ | $100$ | $1$ |
| $2$ | $5 \times 10 ^ 4$ | $1.5 \times 10 ^ 5$ | $1$ |
| $3$ | $20$ | $100$ | $2$ |
| $4$ | $100$ | $1000$ | $2$ |
| $5$ | $2000$ | $10 ^ 4$ | $2$ |
| $6$ | $5 \times 10 ^ 4$ | $1.5 \times 10 ^ 5$ | $2$ |
| $7$ | $10$ | $50$ | $3$ |
| $8$ | $50$ | $500$ | $3$ |
| $9$ | $300$ | $3000$ | $3$ |
| $10$ | $3000$ | $2 \times 10 ^ 4$ | $3$ |
| $11$ | $3 \times 10 ^ 4$ | $1.2 \times 10 ^ 5$ | $3$ |
| $12$ | $5 \times 10 ^ 4$ | $1.5 \times 10 ^ 5$ | $3$ |

第二类测试点共有八个，保证 $k = 4$，$n \leq 10 ^ 4$，
$\sum n \leq 3 \times 10 ^ 4$。

| 测试点编号 | $n \leq$ | $\sum n \leq $ | $k = $ |
| :----------: | :----------: | :----------: | :----------: |
| $13$ | $10$ | $50$ | $4$ |
| $14$ | $50$ | $500$ | $4$ |
| $15$ | $200$ | $2000$ | $4$ |
| $16$ | $500$ | $4000$ | $4$ |
| $17$ | $2500$ | $10 ^ 4$ | $4$ |
| $18$ | $5000$ | $2 \times 10 ^ 4$ | $4$ |
| $19$ | $10 ^ 4$ | $3 \times 10 ^ 4$ | $4$ |
| $20$ | $10 ^ 4$ | $3 \times 10 ^ 4$ | $4$ |

**【后记】**

你花了九牛二虎之力算出 $C$ 的值之后，小 I 却告诉你他已经找开锁师傅用锤子暴力破解了。在你的百般劝说下，小 I 承诺以后锁车不用有大于等于一万个拨圈的密码锁。


---

---
title: "variance"
layout: "post"
diff: 省选/NOI-
pid: P9162
tag: ['O2优化']
---
# variance
## 题目描述

给定序列 $a_1,a_2,\cdots,a_n$，定义 $f(l,r)=(a_l\oplus a_{l+1}\oplus \cdots \oplus a_r)+(a_l\vee a_{l+1}\vee \cdots \vee a_r)$，其中 $\oplus$ 表示 **按位异或** 运算，$\vee$ 表示 **按位或** 运算。

你需要求出所有满足 $1\le l \le r \le n$ 的 $f(l,r)$ 的方差 $v$。为避免精度误差，以及答案可能很大，请输出 $(v\times \frac{n^2\times (n+1)^2}{4}) \kern{3pt}\mathrm {mod}\kern{3pt} 998244353$。

**注意：运算过程中不取模，仅将结果取模。**
## 输入格式

第一行一个正整数 $n$。

第二行 $n$ 个正整数 $a_1,a_2,\cdots,a_n$。
## 输出格式

输出一个整数 $(v\times \frac{n^2\times (n+1)^2}{4}) \kern{3pt}\mathrm {mod}\kern{3pt} 998244353$。
## 样例

### 样例输入 #1
```
3
2 1 3
```
### 样例输出 #1
```
80
```
### 样例输入 #2
```
4
4 1 3 2
```
### 样例输出 #2
```
1244
```
### 样例输入 #3
```
5
1 2 3 2 1
```
### 样例输出 #3
```
444
```
## 提示

方差的定义：对于 $n$ 个数 $a_1,a_2,\cdots,a_n$，它们的方差是：

$$
\frac 1 n\sum_{i=1}^n (a_i-\bar{a})^2
$$

其中 $\bar{a}$ 为 $a_1,a_2,\cdots,a_n$ 的平均数，即 $\dfrac {1} {n} \displaystyle\sum\limits_{i=1}^n a_i$。

----

对于 $10\%$ 的数据，$n \le 50$。

对于 $30\%$ 的数据，$n \le 5000$。

对于另 $20\%$ 的数据，$a_i \le 100$。  

对于 $100\%$ 的数据，$1\le n\le 10^5,1\le a_i < 2^{31}$。


---

---
title: "「INOH」Round 1 - 狂气"
layout: "post"
diff: 省选/NOI-
pid: P9164
tag: ['O2优化']
---
# 「INOH」Round 1 - 狂气
## 题目描述

有一个无限长的序列 $\{a\}$，**数组下标从 $1$ 开始**，初始 $a_1=1$，其余位置均为 $0$。

$m$ 次操作：
1. 对于所有**奇数** $i$，令 $a_{i+1}\gets a_{i+1}+a_i$。
2. 对于所有**偶数** $i$，令 $a_{i+1}\gets a_{i+1}+a_i$。

你需要求出所有操作进行完之后的序列。

为了方便输出，你只需要输出 $( \displaystyle\prod_{i = 1}^{m} (a_i + 1))\bmod 998244353$ 的值即可。  
## 输入格式

第一行一个正整数 $m$。

第二行一个长度为 $m$ 的字符串，表示操作序列。  
## 输出格式

一行，表示 $( \displaystyle\prod_{i = 1}^{m} (a_i + 1)) \bmod 998244353$ 的值。  
## 样例

### 样例输入 #1
```
5
11221
```
### 样例输出 #1
```
200
```
### 样例输入 #2
```
13
1122121212212
```
### 样例输出 #2
```
400201782
```
## 提示

**样例 1 解释**  

经过 5 次操作之后，序列前五项：  
$a_1 = 1$，$a_2 = 3$，$a_3 = 4$，$a_4 = 4$，$a_5 = 0$。

**本题采用捆绑测试**。 

- Subtask 0（10pts）：$1 \le m \le 1000$。  
- Subtask 1（20pts）：操作序列形如 $\tt121212\dots$。
- Subtask 2（20pts）：操作序列随机生成。  
- Subtask 3（50pts）：无特殊限制。  

对于 $100\%$ 的数据，有 $1 \le m \le 2 \times 10^5$。  

**请选手注意常数因子对运行效率的影响**


---

---
title: "[省选联考 2023] 城市建造"
layout: "post"
diff: 省选/NOI-
pid: P9167
tag: ['各省省选', '2023', 'O2优化']
---
# [省选联考 2023] 城市建造
## 题目描述

在这个国度里面有 $n$ 座城市，一开始城市之间修有若干条双向道路，导致这些城市形成了 $t \ge 2$ 个连通块，特别的，这些连通块之间两两大小差的绝对值不超过 $0 \le k \le 1$。为了方便城市建设与发展，$n$ 座城市中的某 $t$ 座城市**在这 $t$ 座城市之间**额外修建了至少一条双向道路，使得所有城市连通。

现在已经知道额外修建后的所有道路，你需要算出有哪些双向道路集合 $E'$，满足这些道路有可能是后来额外修建的，请输出答案对 $998,244,353$ 取模的结果。

即给定一张 $n$ 个点 $m$ 条边的**无向连通**图 $G = (V, E)$，询问有多少该图的子图 $G' = (V', E')$，满足 $E' \ne \varnothing$ 且 $G - E'$ 中恰好有 $|V'|$ 个连通块，且任意两个连通块大小之差不超过 $k$，保证 $0 \le k \le 1$，请输出答案对 $998,244,353$ 取模的结果。

## 输入格式

输入的第一行包含三个正整数 $n, m, k$，分别表示城市数、修建后的道路数以及任意两个连通块大小之差的上限。

接下来 $m$ 行每行包含两个正整数 $u, v$，表示城市 $u$ 和 $v$ 之间存在一条双向道路，保证 $u \ne v$。

## 输出格式

输出一个数表示答案对 $998,244,353$ 取模后的结果。

## 样例

### 样例输入 #1
```
4 4 1
1 2
2 3
1 3
3 4

```
### 样例输出 #1
```
2

```
### 样例输入 #2
```
见附件中的 cities/cities2.in
```
### 样例输出 #2
```
见附件中的 cities/cities2.ans
```
### 样例输入 #3
```
见附件中的 cities/cities3.in
```
### 样例输出 #3
```
见附件中的 cities/cities3.ans
```
### 样例输入 #4
```
见附件中的 cities/cities4.in
```
### 样例输出 #4
```
见附件中的 cities/cities4.ans
```
## 提示

**【样例 1 解释】**

有以下两种情况：

- 本来只有 $(3, 4)$ 这一条道路，此时有三个连通块，分别为 $\{1\}, \{2\}, \{3, 4\}$；后来城市 $1, 2, 3$ 决定在它们三座城市中额外修建了 $(1, 2), (2, 3), (1, 3)$ 这三条道路，使得所有城市连通。
- 本来没有任何道路，此时有四个连通块，分别为 $\{1\}, \{2\}, \{3\}, \{4\}$；后来城市 $1, 2, 3, 4$ 决定在它们四座城市中额外修建了 $(1, 2), (2, 3), (1, 3), (3, 4)$ 这四条道路，使得所有城市连通。

**【数据范围】**

对于所有的数据，保证：$3 \le n \le 10^5$，$n - 1 \le m \le 2 \times 10^5$，$0 \le k \le 1$。

|测试点|$n$|$m$|$k$|
|:-:|:-:|:-:|:-:|
|1, 2|$\le 15$|$\le 20$|$= 0$|
|3 ~ 5|$\le 20$|$\le 50$|$= 1$|
|6, 7|$\le 200$|$\le 300$|$= 0$|
|8, 9|$\le 2,000$|$= n - 1$|$= 1$|
|10, 11|$\le 2,000$|$\le 3,000$|$= 0$|
|12, 13|$\le 2,000$|$\le 3,000$|$= 1$|
|14, 15|$\le 10^5$|$= n - 1$|$= 1$|
|16, 17|$\le 10^5$|$\le 2 \times 10^5$|$= 0$|
|18 ~ 20|$\le 10^5$|$\le 2 \times 10^5$|$= 1$|



---

---
title: "[COCI 2022/2023 #5] Zastave"
layout: "post"
diff: 省选/NOI-
pid: P9181
tag: ['2022', 'Special Judge', 'COCI（克罗地亚）']
---
# [COCI 2022/2023 #5] Zastave
## 题目描述

有 $n$ 个直角三角形，第 $i$ 个直角三角形的斜边长度为 $r_i$，这些直角三角形的高度和不超过 $S$。求这 $n$ 个直角三角形的最大面积和。
## 输入格式

第一行两个整数 $n,S\ (1\le n\le 10^5,1\le S\le 10^{10})$，表示三角形个数和这些三角形的高度之和的最大值。

第二行 $n$ 个整数 $r_i\ (1\le r_i\le 10^5)$。
## 输出格式

输出这 $n$ 个直角三角形的最大面积和（保留 $10$ 位小数）。如果你的输出与答案的绝对误差或相对误差不超过 $10^{-6}$ 则认为你的输出正确。
## 样例

### 样例输入 #1
```
2 3
4 5

```
### 样例输出 #1
```
6.5200982141

```
### 样例输入 #2
```
1 6
10

```
### 样例输出 #2
```
24.0000000000

```
### 样例输入 #3
```
4 7
5 5 6 6

```
### 样例输出 #3
```
18.5706715170

```
## 提示

样例 $2$ 解释：

最大可能的情况是这个三角形的三边长为 $6,8,10$，面积为 $24$。

|子任务编号|	附加限制|	分值|
|:-:|:-:|:-:|
|$0$|	是样例|	$0$|
|$1$|	$n\le 100$|	$37$|
|$2$|	$n\le 1000$|	$20$|
|$3$|	无附加限制|	$43$|


---

---
title: "「PEOI Rd1」寻宝（treasure）"
layout: "post"
diff: 省选/NOI-
pid: P9225
tag: ['O2优化']
---
# 「PEOI Rd1」寻宝（treasure）
## 题目描述

有一天 wrzSama 在寻宝，突然他掉到了一个神奇的房间里。这个房间里有 $n$ 个机器，第 $i$ 个机器可以生产 $2^i$ 个钻石。

具体地，wrzSama 可以用 $a_i$ 的时间开动第 $i$ 个机器，让它生产 $2^i$ 个钻石。这些机器有个很特殊的性质，每当他用一次第 $i$ 个机器后，会让它的开动时间 $a_i$ 加上 $b_i$。这意味着当他要第二次得到这 $2^i$ 个钻石时就需要 $a_i + b_i$ 的时间，每次不断累加，第 $x$ 次开动就需要 $a_i+(x-1)b_i$ 的时间。

wrzSama 需要得到至少 $2^n$ 个钻石来得到宝藏，请问他最少需要多长时间。
## 输入格式

第一行一个正整数 $n$。

第二行 $n$ 个正整数，表示 $a_1,a_2,\dots,a_n$。

第三行 $n$ 个正整数，表示 $b_1,b_2,\dots,b_n$。
## 输出格式

一行一个正整数，即为答案。
## 样例

### 样例输入 #1
```
3
1 2 3
3 2 1
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
3
1 2 100
1 2 1
```
### 样例输出 #2
```
5
```
### 样例输入 #3
```
4
1 2 100 100
1 2 1 1
```
### 样例输出 #3
```
15
```
## 提示

#### 样例解释

样例 1 解释：直接获得 $2^3$，花费 3 的时间。

样例 2 解释：获得 2 个 $2^1$，花费 3 的时间，然后再花 2 的时间获得一个 $2^2$，这样 wrzSama 就可以得到 $2 \times 2^1 + 2^2 = 8 = 2^n$ 了。

样例 3 解释：获得 2 个 $2^1$ 和 3 个 $2^2$。

---
#### 数据范围

**本题采用捆绑测试。**

|子任务|分值|特殊限制|
|:-:|:-:|:-:|
|$1$|$16$|$1 \leq n \leq 10$|
|$2$|$16$|$1 \leq n \leq 20$|
|$3$|$24$|$1 \leq a_i \leq 3 \times 10^3$|
|$4$|$44$|无|

对于 $100\%$ 的数据，保证 $1 \le n \le 10^3$，$1 \le a_i,b_i \le 10^7$。


---

---
title: "[PA 2022] Wielki Zderzacz Termionów"
layout: "post"
diff: 省选/NOI-
pid: P9252
tag: ['2022', 'PA（波兰）']
---
# [PA 2022] Wielki Zderzacz Termionów
## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 1 [Wielki Zderzacz Termionów](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/wzt/)**

Albert Bynstein 教授发现了一种新的基本粒子：热离子。如果他的实验成功，就可以在他的帮助下修建一个发电站，这样就可以解决 Byteland 的能源问题了。

这些粒子有三种类型，用红色，绿色和蓝色表示。这个名称与粒子实际的颜色或者光的波长无关，只是 Bynstein 教授用这些颜色的马克笔标记这些粒子。

红色和绿色的热离子可以发生反应，但只与另一个相同颜色的粒子发生反应。当两个红色热离子碰撞时，产生一个绿色热离子，并释放 $1$ 字节焦耳的能量。如果两个绿色热离子发生碰撞，就会产生一个红色热离子，同时释放 $1$ 字节焦耳的能量。

蓝色热离子不与其他热离子反应，但是它们是不稳定的。产生蓝热离子 $72$ 小时后，它会随机变成红热离子或绿热离子中的一个，变成任何离子都不会释放能量。

教授正在准备一个受控的实验反应。为此，他在实验室里准备了排成一排的 $n$ 个热离子。几天后，他打算把这些离子带到目前正在首都地下建造的大型热离子对撞机。到那时，所有的蓝色热离子都将变成红色或绿色热离子。

在对撞实验中，教授想进行一连串的反应，以产生 $n-1$ 字节焦耳的能量，并最后只留下一个热离子。每次反应可以选择相邻的两个热离子。所产生的热离子与左边和右边的热离子相邻，并能与它们发生进一步的反应。

问题是，当所有的蓝色热离子都发生变化时，有多大概率存在一个可行的反应序列。

你的任务是计算蓝色热离子有多少种变化方式（对 $10^9+7$ 取模）能使完整的反应序列进行下去。

此外，教授还会在他的实验室里对热离子的位置进行改变，每次都把一个热离子换成另一个（也许不会改变其类型）。在每一次这样的变化之后，也要计算出结果。
## 输入格式

第一行包含两个整数 $n$ 和 $q$ 分别表示热离子个数和改变次数。

第二行一个长为 $n$ 的字符串，表示初始时热离子的排列情况。字符串只包含 `C`，`Z` 和 `N` 三种字符，分别表示红色，绿色和蓝色热离子。左起第 $k$ 个字符表示第 $k$ 个热离子的颜色。

接下来 $q$ 行表示对上述字符串的修改。每行包含一个数字 $k_i$ 和一个字符（`C`，`Z` 和 `N` 之一）。表示第 $i$ 步中，教授将第 $k_i$ 个粒子换成了这个字符所表示的新粒子。
## 输出格式

输出 $q+1$ 行，第 $i+1$ 行输出一个整数，表示经过前 $i$ 个修改后的答案。

输出蓝色热离子有多少种变化方式（对 $10^9+7$ 取模）能使完整的反应序列进行下去，生成 $n-1$ 字节焦耳能量。
## 样例

### 样例输入 #1
```
5 3
NNCCZ
3 N
2 Z
1 Z

```
### 样例输出 #1
```
3
5
3
1

```
## 提示

对于 $100\%$ 的数据，满足：

$1\le n\le 2 \times 10 ^ 5, 0\le q\le 10 ^ 5, 1\le k_i\le n$。


---

---
title: "[PA 2022] Drybling Bajtessiego"
layout: "post"
diff: 省选/NOI-
pid: P9258
tag: ['2022', 'PA（波兰）']
---
# [PA 2022] Drybling Bajtessiego
## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 3 [Drybling Bajtessiego](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/baj/)**

Bytessi 因是世界足坛最好的锋线（和球员）而广为人知。为了即将到来的世界杯，他编制了一份 $n$ 种运球方式的清单，其中每次运球可以用一串字母 `L` 和 `P` 来描述，表示他用左脚和右脚触球的顺序。

如果一个球员用左脚和右脚触球次数相等，我们就称这种运球方式是**平衡的**。此外，如果对于给定的这种运球方式，如果任意一个初始部分（前缀），满足左脚触球次数不少于右脚触球次数，就称这种运球方式是**左利脚的**。由于 Bytessi 是左利脚，他认为如果一种运球方式即平衡又左利脚，那么这种运球方式是**极佳的**。

世界杯是一个特殊的比赛，世界上最好的球员都会来参赛。出于这个原因，Bytessi 需要准备更多的运球方式。他决定使用一种简单的方式把运球方式增加到 $n^2$ 种——对于初始列表中每一对运球方式（可以相同），新的运球方式用这两种运球方式直接相连来描述。换句话说，他会先使用第一种运球方式运球，然后接着用第二种运球方式运球。

在激烈的比赛中，很容易忘记一些本应进行的触球，所以 Bytessi 最后的运球方式将是他最初想的运球方式的一个非空的子序列。换句话说，最后的运球方式将通过删除他想进行的运球方式中的一些（也许没有，但不是全部）字母来得到。其余字母的顺序必须保持不变。

最终采用的运球方式将是极佳的，如果这样的话 Bytessi 会非常高兴。他现在想知道，对于新清单中的每一种运球方式，他可以意外地进行多少种可能的极佳运球方式。由于这个数字可能非常大，Bytessi 只需要知道将这个数字除以 $10^9+7$ 的余数。请帮 Bytessi 解决这个问题。

注意：Bytessi 感兴趣的是其原始运球方式的子序列可以得到多少种不同的极佳运球，而不是从原始运球的描述中划掉字母而得到极佳运球的方法的数量。
## 输入格式

第一行一个整数 $n$，表示 Bytessi 准备的运球方式种数。

接下来 $n$ 行描述 Bytessi 的运球方式。第 $i$ 行包含一个由 `L` 和 `P` 组成的非空串，描述第 $i$ 种运球方式。
## 输出格式

输出 $n$ 行，每行 $n$ 个整数。第 $i$ 行第 $j$ 个整数表示如果把第 $i$ 种和第 $j$ 种运球方式相连，新的运球方式中有多少子序列是极佳的，结果对 $10^9+7$ 取模。
## 样例

### 样例输入 #1
```
4
LLPLPP
PPLP
LLP
P

```
### 样例输出 #1
```
29 9 8 5
8 2 2 1
11 4 3 2
4 1 1 0

```
## 提示

对于 $100\%$ 的数据，满足：

$1\le n\le 600$，

每种运球方式的长度不超过 $600$。


---

---
title: "[PA 2022] Płótno"
layout: "post"
diff: 省选/NOI-
pid: P9261
tag: ['2022', 'PA（波兰）']
---
# [PA 2022] Płótno
## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 4 [Płótno](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/plo/)**

由于圣诞节，Bytie 从父母那里得到了一块大画布，画布被分成 $2n$ 个方格，排列成两行 $n$ 列的矩形。为了方便在上面画画，这块画布被包在在一个很低很宽的圆柱体的侧面上，这样，画布的第一列就与最后一列相邻。如果画布上的两个方格有一条公共边，则认为它们是相邻的。即它们要么在同一列，要么在同一行的相邻列。

数学上，我们可以用一个有序数对 $(y,x)$ 表示画布上的每个方格，其中 $1\le y\le 2,1\le x\le n$。两个方格 $(y_1,x_1)$ 和 $(y_2,x_2)$ 相邻，如果满足：

- 它们在同一行，即 $y_1=y_2$，并且列相邻，即 $x_1+1\equiv x_2 \pmod n$ 或 $x_2+1\equiv x_1\pmod n$，或者
- 它们在同一列，即 $x_1=x_2$。

Bytie 一到画布前，就把 $2n$ 个方格的每一个都画成了**不同**的颜色。为简单起见，我们用 $1$ 到 $2n$ 的整数来表示颜色。

每个看到这个孩子的劳动成果的人都对这么小的孩子能够创造出如此宏伟的作品而感到非常惊讶。这甚至吸引了著名的艺术评论家 Bytona Bitego。他决定亲眼看看是什么让人们如此着迷，他将用自己特别准备的方法评估他的画，其方法如下：

我们选择一个特定的颜色区间 $[l, r]$，然后只考虑颜色在这个区间内的方格。我们称这个颜色区间的好奇值等于这些方格形成的连通区域的数量。如果存在一连串颜色在 $[l, r]$ 中的相邻方格使得两个颜色在 $[l,r]$ 的方格连通，那么这两个方格就在一个区域内。

Bytona Bitego 想知道对于每个 $v\in \{1,2,\ldots,k\}$，有多少区间的好奇值为 $v$。你的任务就是回答他的问题。
## 输入格式

第一行包含两个整数 $n,k$，分别表示画布的宽度和 Bajtona Bitego 想知道的最大好奇值。

第二行包含 $n$ 个整数，表示画布第一行方格的颜色。从左到右按列编号递增顺序给出。

类似地，第三行包含 $n$ 个整数，表示画布第二行方格的颜色，顺序与第一行相同。

第二行和第三行的数字合起来形成了一个 $1$ 到 $2n$ 的整数排列。
## 输出格式

输出一行 $k$ 个整数，第 $v$ 个整数表示有多少个区间的好奇值为 $v$。
## 样例

### 样例输入 #1
```
3 2
1 5 3
4 2 6

```
### 样例输出 #1
```
12 9

```
### 样例输入 #2
```
5 3
1 3 5 7 9
2 6 4 8 10

```
### 样例输出 #2
```
40 14 1

```
## 提示

对于 $100\%$ 的数据，满足：

$2\le n\le 10 ^ 5, 1\le k\le 10$。


---

---
title: "[PA 2022] Łamigłówka"
layout: "post"
diff: 省选/NOI-
pid: P9262
tag: ['2022', 'PA（波兰）']
---
# [PA 2022] Łamigłówka
## 题目描述

**题目译自 [PA 2022](https://sio2.mimuw.edu.pl/c/pa-2022-1/dashboard/) Runda 4 [Łamigłówka](https://sio2.mimuw.edu.pl/c/pa-2022-1/p/lam/)**

Byteasar 在玩拼图。它是一个由单元格组成的 $n\times m$ 大小的矩形。每个单元格可能是空的，也可能包含一个黑色或白色的方块。

在每次操作中，这个玩具可以向平行于矩形边的四个方向之一倾斜。然后所有的方块会朝那个方向滑动到最远可以所处的位置，而不超出矩形范围或重叠。

Byteasar 倾斜了多次，请给出倾斜最后一次后整个拼图的状态。
## 输入格式

第一行两个整数 $n,m$，表示这个矩形的大小。

接下来 $n$ 行，每行一个长为 $m$ 的字符串，表示初始状态。字符串中仅包含三种字符：`.` 表示这个单元格是空的，`B` 表示这个单元格中有一个白色方块，`C` 表示这个单元格中有一个黑色方块。

接下来一行一个整数 $k$，表示 Byteasar 倾斜的次数。

最后一行包含一个长为 $k$ 的字符串，表示 Byteasar 每次的倾斜方向。字符串中仅包含 `G`，`D`，`L`，`P` 四种字符，分别表示向上，向下，向左和向右倾斜。
## 输出格式

输出这个玩具的最终状态，输出格式与输入的初始状态格式相同，输出 $n$ 行，每行一个长度为 $m$ 的字符串，字符串中仅包含 `.`，`B`，`C` 三种字符。
## 样例

### 样例输入 #1
```
4 5
.....
.B.C.
..C..
...B.
3
GLP

```
### 样例输出 #1
```
..BCC
....B
.....
.....

```
## 提示

对于 $100\%$ 的数据，满足：

$1\le n,m\le 500, 1\le k\le 5 \times 10 ^ 5$。 


---

---
title: "[CEOI 2013] 有轨电车 / Tram"
layout: "post"
diff: 省选/NOI-
pid: P9270
tag: ['2013', 'CEOI（中欧）']
---
# [CEOI 2013] 有轨电车 / Tram
## 题目背景

翻译自 [CEOI 2013 Day 1](https://ceoi2013.hsin.hr/tasks/tasks_day1.pdf)。

在萨格勒布运营的电车的座位就像一个 $n$ 行 $2$ 列的网格，两个座位之间的距离，是相应网格正方形中心之间的欧几里得距离（直线距离）。


大多数乘客在使用公共交通工具时会社恐，也就是说，当乘客进入电车时，会选择一个没有人坐的座位，并且该座位与最近的座位的距离尽可能大。如果有多个这样的座位，他们总是会选择一个行号较小的座位（因为这样他不需要走太远）。如果仍然有多个这种座位，他们会选择列号较小（即列号为 $1$）的座位。乘客选择座位后，会一直坐在那里，直到他离开电车。如果电车是空的，进入的乘客将始终选择第 $1$ 排第 $1$ 列的座位。
## 题目描述

给定一系列事件，每个事件都是乘客进入或离开电车。你需要输出这位乘客进入时他会坐在哪里。电车一开始是空的。

输入中有 $m$ 个事件，按事件发生的顺序编号为 $1$ 到 $m$。有两种事件：`E` 类事件表示乘客进入有轨电车，而 `L` 类事件则表示乘客离开有轨电车。对于类型为 `L` 的事件，还给出了一个整数 $p$，它表示在该事件中离开的乘客是在**事件** $p$ 中进入的乘客。

测试数据确保每当乘客试图进入电车时，电车中至少有一个空位。
## 输入格式

第一行输入包含两个整数 $n$ 和 $m$。

接下来 $m$ 行，其中第 $i$ 行表示事件 $i$ 的内容，首先输入一个字符 `E` 或 `L`，当字符是 `L` 时再输入一个数 $p_i$，保证事件 $p_i$ 的类型一定是 `E`。
## 输出格式

输出中的行数应等于输入中 `E` 类事件的数量。对于第 $i$ 个类型为 `E` 的事件，在第 $i$ 行上输出该乘客选择的座位号 $r,c$（行和列），中间用一个空格隔开。
## 样例

### 样例输入 #1
```
3 7
E
E
E
L 2
E
L 1
E
```
### 样例输出 #1
```
1 1
3 2
1 2
3 1
1 1
```
### 样例输入 #2
```
13 9
E
E
E
E
E
E
E
E
E
```
### 样例输出 #2
```
1 1
13 2
7 1
4 2
10 1
2 2
3 1
5 1
6 2
```
### 样例输入 #3
```
10 9
E
E
E
E
L 3
E
E
L 6
E
```
### 样例输出 #3
```
1 1
10 2
5 2
7 1
4 2
2 2
4 1
```
## 提示

对于 $25\%$ 的数据，$n,m\le150$。

对于 $45\%$ 的数据，$n\le1500$。

对于 $65\%$ 的数据，$m\le1500$。

对于 $100\%$ 的数据，$n\le150000,m\le30000$。

前三个测试点是样例。


---

---
title: "[CEOI 2013] 停车场 / Splot"
layout: "post"
diff: 省选/NOI-
pid: P9271
tag: ['2013', 'Special Judge', 'CEOI（中欧）']
---
# [CEOI 2013] 停车场 / Splot
## 题目背景

翻译自 [CEOI 2013 Day 1](https://ceoi2013.hsin.hr/tasks/tasks_day1.pdf)。

亚得里亚海沿岸和岛屿都有各种形状和大小的美丽沙滩。然而，许多沙滩无法通过汽车到达。为了满足不断增长的需求，沿海附近的一片巨大空地被改建成停车场。

由于参与设计的所有建筑师都具有电气工程背景，想着怎么着自己学过的专业也得用上，于是停车场的布局就类似于在设计电路时常用的串并联图。

停车场由停车位和连接它们的双向道路组成。每条道路连接两个不同的停车位，每一对停车位之间最多只能通过一条道路连接。每个停车位在任何时刻最多只能停放一辆汽车。其他车辆不能通过被占用的停车位行驶。

![](https://cdn.luogu.com.cn/upload/image_hosting/j207s329.png)
$$\text{图 1：构建停车图的规则，对应下面的三点}$$

串并联停车场（也称为 splot，下文称为停车图）是一种由称为源点和终点的两个特定停车位构成的停车场，它是通过使用串并联组合规则从单个停车位构建而成的。每个停车图可以通过编码来指定其结构和停放车辆的位置，编码是一个描述其结构的字符序列。有效的停车图及其编码按照以下递归方式定义：

1. 只包含一个停车位且没有道路的停车场是一个有效的停车图。这个单个停车位既是停车图的源点也是终点。如果停车位为空，则该停车图的编码为小写字母 `o`，如果停车位被汽车占用，则编码为小写字母`x`。
   - ![](https://cdn.luogu.com.cn/upload/image_hosting/x6vficzn.png?x-oss-process=image/resize,m_lfit,h_170,w_225)

2. 如果 $G_1$ 和 $G_2$ 是两个有效的停车图，它们的串联组合 $G$ 也是一个停车图。串联组合是通过在 $G_1$ 的终点和 $G_2$ 的源点之间添加一条道路来获得的。新获得的停车图 $G$ 的源点是 $G_1$ 的源点，而终点是 $G_2$ 的终点。如果 $E_1$ 和 $E_2$ 分别是停车图 $G_1$ 和 $G_2$ 的编码，则 $G$ 的编码为 `SE1E2#`。换句话说，编码是通过连接大写字母 `S`、组成它的停车图的编码和井号 `#` 获得的。
   - ![](https://cdn.luogu.com.cn/upload/image_hosting/bzrozfho.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

3. 如果 $G_1$ 和 $G_2$ 是两个有效的停车图，它们的并联组合 $G$ 也是一个有效的停车图。并联组合是通过添加两个新的停车位 $s$ 和 $t$，添加从 $s$ 到 $G_1$ 和 $G_2$ 的源之间的道路，以及从 $t$ 到 $G_1$ 和 $G_2$ 的终端之间的道路得到的。新获得的停车图G的源是新添加的停车位 $s$，而 $G$ 的终端是新添加的停车位 $t$。如果 $E_1$ 和 $E_2$ 分别是停车图 $G_1$ 和 $G_2$ 的编码，而 $E_s$ 和 $E_t$ 是源 $s$ 和终端 $t$ 的编码（如果相应的空间为空，则为小写字母 `o`，否则为小写字母 `x`），则 $G$ 的编码为 `PEs|E1E2|Et#`。换句话说，编码是通过连接大写字母 `P`，源停车位的编码，竖线符号 `|`，被组合的停车图的编码，另一个竖线符号 `|`，终端停车位的编码，最后是井号 `#` 得到的。
   - ![](https://cdn.luogu.com.cn/upload/image_hosting/czj2m8t8.png?x-oss-process=image/resize,m_lfit,h_340,w_450)

![](https://cdn.luogu.com.cn/upload/image_hosting/6gyst5bp.png)
$$\text{图2：与下面第一个测试示例对应的停车图}$$

例如，上图中给出的停车图的编码是 `Po|Px|Sxo#Soo#|o#Soo#|o#`（译者注：`{Po|[Px|(Sxo#)(Soo#)|o#](Soo#)|o#}`）。请注意，停车图 $G$ 的编码中小写字母（`o` 或 `x`）的数量始终与 $G$ 中的停车位数量相同，并且停车图中的停车位与其编码中的小写字母之间存在一一对应关系。停车场只有一个出口，它就在整个停车图的**源停车位**。如果车辆可以通过一些道路和空的停车位到达源停车位，即它可以离开这个停车图，则我们称该车辆未被阻挡。例如，在上面的停车图中，两辆车都没有被阻挡，但是如果我们将一辆车停在停车图的终端（最右边的节点）上，则其中一辆车将被阻挡。允许将车停在停车图的源停车位上（但是如果这样做，停车图中的所有其他车辆都将被阻挡）。
## 题目描述

停车场的运营商希望以一种方式安排进站的车辆，让图中没有车辆被阻挡。

编写一个程序，计算可以停放在给定停车场的最大汽车总数，（**包括已经在那里的汽车**），使它没有任何汽车被阻挡，也不会移动任何已经在那里的车。此外，程序应该**找到一种方法**来安排停车图中最大数量的汽车。
## 输入格式

输入一行，包含一个至少 $1$ 个、最多 $10$ 万个字符的序列，表示给定的 splot 的编码。序列中只会出现大写字母 `P` 和 `S`，小写字母 `o` 和 `x`，以及字符 `#`（`ASCII 35`）和 `|`（`ASCII 124`）。根据上面的规则，输入将是一个 splot 的编码。输入保证已经在停车场的汽车都不会被阻挡。
## 输出格式

输出应包含 $2$ 行。第一行应该包含一个整数 $m$，表示可以停放在 splot 中的最大汽车数量。

第二行应该包含一个字符序列，表示最终将车停放进 splot 的最佳方案。该序列应恰好包含 $m$ 个字母 `x`，并且是通过将原来的一些字母 `o` 替换为 `x` 得来的。

可能有多个最佳安排，程序可以输出其中的任何一个。
## 样例

### 样例输入 #1
```
Po|Px|Sxo#Soo#|o#Soo#|o#
```
### 样例输出 #1
```
3
Po|Px|Sxo#Sox#|o#Soo#|o#
```
### 样例输入 #2
```
Po|SPo|oo|o#Px|oo|o##Po|Sxo#Po|ox|o#|o#|o#
```
### 样例输出 #2
```
7
Po|SPo|xx|o#Px|ox|o##Po|Sxx#Po|ox|o#|o#|o#
```
## 提示

样例解释见题目描述最后一趴。

如果输出不正确或不完整，但第一行输出（最大汽车数量）是正确的，你将获得相应测试点 $80\%$ 的分数。

在 $30\%$ 的测试点中，splot 中的停车位总数最多为 $20$ 个。

在另外 $40\%$ 的测试点中，splot 为空，即输入不包含字母 `x`。

对于 $100\%$ 的数据，给定的 splot 的编码最多包含 $10$ 万个字符。

SPJ 提供者：@[cff_0102](https://www.luogu.com.cn/user/542457) 。


---

---
title: "[POI 2020] Gang Biciaków / 布茨帮"
layout: "post"
diff: 省选/NOI-
pid: P9295
tag: ['2020', 'POI（波兰）']
---
# [POI 2020] Gang Biciaków / 布茨帮
## 题目背景

**题目译自 [XXVIII Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi28-1/dashboard/) [Gang Biciaków](https://sio2.mimuw.edu.pl/c/oi28-1/p/gan/)。**
## 题目描述

Bajtazar 在一家货运公司工作，他目前的工作是将建筑材料从 Bajtocji 的首都运输到附近城镇的商店。在 Bajtocji，有 $n$ 座城市（编号从 $1$ 到 $n$），这些城市通过 $n-1$ 条道路相互连接。每条道路上都有一个加油站。

Bajtazar 一天的工作是这样的：他从首都（编号为 $1$ 的城市）出发，沿着最短路径到达城市 $x$，再原路返回。

Bajtazara 的儿子 Bitek 非常喜欢加油站里卖的玩具狗。玩具狗一共有 $m$ 种（编号从 $1$ 到 $m$），但每个加油站只提供一种玩具狗，因此收集玩具狗并非一件轻松的事情。

现在给出 Bajtazara 每天前往的目的地，他想要知道他的儿子这天能够获得多少种玩具狗。麻烦的是，每个加油站里售卖的玩具狗的种类会发生变化，你能帮助他解决这个难题吗？

## 输入格式

输入第一行三个整数 $n,m,z$，分别代表 Bajtocji 的城市数，玩具狗的种类数，查询的次数。

接下来 $n-1$ 行，第 $i$ 行三个整数 $a_i,b_i,c_i$，代表第 $i$ 条道路连接城市 $a_i$ 和城市 $b_i$（$1 \leq a_i,b_i \leq n$），该道路上的加油站售卖的玩具狗种类为 $c_i$（$1 \leq c_i \leq m$）。

接下来 $z$ 行，每行描述一个询问或修改操作，格式如下：

- 询问操作：$\texttt{Z}\ x$ 表示 Bajtazara 想要知道，从首都出发到城市 $x$（$2 \leq x \leq n$），能收集到多少种玩具狗。
- 修改操作：$\texttt{B}\ i\ c$ 表示将第 $i$ 条道路上加油站售卖的玩具狗的类型改为 $c$（$1 \leq c \leq m$，注意如果该加油站本来就售卖 $c$ 类型玩具狗，执行该操作后将不会有任何影响）。
## 输出格式

对于每个 $\texttt{Z}$ 操作，输出一行一个整数，代表这一天 Bajtazara 的儿子能获得的玩具狗的种类数。
## 样例

### 样例输入 #1
```
6 3 5
1 2 3
1 3 2
3 4 3
5 3 1
6 4 2
Z 5
Z 6
B 2 1
Z 5
Z 6
```
### 样例输出 #1
```
2
2
1
3
```
### 样例输入 #2
```
8 4 20
1 2 3
8 2 4
6 4 2
1 6 1
3 4 3
4 5 2
7 4 1
Z 2
Z 3
Z 4
Z 5
Z 6
Z 7
Z 8
B 4 4
B 3 3
B 7 4
B 2 3
Z 2
Z 3
Z 4
Z 5
Z 6
Z 7
Z 8
B 3 4
Z 7
```
### 样例输出 #2
```
1
3
2
2
1
2
2
1
2
2
3
1
2
1
1
```
## 提示

【样例解释1】：

![pp5XLWV.png](https://s1.ax1x.com/2023/04/05/pp5XLWV.png)

注意该样例中存在一次修改操作，使得第二条道路上的加油站售卖的玩具狗的种类从 $2$ 变成了 $1$。

【数据范围】：

所有测试点均满足：$2 \leq n \leq 10^5$，$1 \leq m,z \leq 1.5 \times 10^5$，且至少存在一个 $\texttt{Z}$ 操作。

| 子任务编号 | 约束| 分值|
|:-:|:-:| :-: |
| $1$| $n,m,z \leq 100$| $7$  |
| $2$| $n,z \leq 2 \times 10^3$| $9$  |
|$3$ | 只有 $\texttt{Z}$ 类型操作| $9 $  |
| $4$| $m \leq 15$|$15$|
|$5$|道路 $i$ 连接城市 $i$ 和城市 $i+1$| $11$ |
| $6$ | 刚开始时，每个加油站售卖的玩具狗类型都是 $1$，在后续的 $\texttt{B}$ 类型操作中，玩具狗的类型会被更改为除 $1$ 之外的任意类型 | $13$ |
| $7$| 无附加约束| $36$ |


---

---
title: "[POI 2020] Licznik długu / 债务计数器"
layout: "post"
diff: 省选/NOI-
pid: P9297
tag: ['2020', 'POI（波兰）']
---
# [POI 2020] Licznik długu / 债务计数器
## 题目背景

**题目译自 [XXVIII Olimpiada Informatyczna – I etap](https://sio2.mimuw.edu.pl/c/oi28-1/dashboard/) [Licznik długu](https://sio2.mimuw.edu.pl/c/oi28-1/p/lic/)。**
## 题目描述

Bajterowicza 教授指出，Bajtocji 的经济形势现在不容乐观。为了警示民众，他让 Bajtazara 公司在 Bajtocji 首都的市中心安装一块大型显示屏，用来显示 Bajtocji 现在的公共债务是多少。

Bajtocji 的公共债务由两部分组成：国内债务和国际债务。国内债务和国际债务最多可由 $n-1$ 个十进制数组成。而在显示屏上显示的是两部分债务的总和。

随着时间推移，Bajtocji 的债务状况也在不断变化。你现在需要帮助 Bajtazara 公司完成显示软件的编辑工作。

这个软件需要执行如下三种操作：

- 更改国内债务数值在某一位上的值。
- 更改国际债务数值在某一位上的值。
- 输出总公共债务在某一位上的值。
## 输入格式

输入第一行两个整数 $n,z$，分别代表显示器能显示的数字位数和操作次数。

第二行包含一个长度 $n-1$ 的数字，代表 Bajtocji 最初的国内债务的值，这个数字可能有前导零。

第三行包含一个长度 $n-1$ 的数字，代表 Bajtocji 最初的国际债务的值，这个数字可能有前导零。

接下来 $z$ 行，每行描述一个询问操作：

- $\texttt{W}\ i \ c$ 表示将国内债务的第 $i$ 位的值更改为 $c$（$1 \leq i \leq n-1$，$0 \leq c \leq 9$）。
- $\texttt{Z}\ i \ c$ 表示将国际债务的第 $i$ 位的值更改为 $c$（$1 \leq i \leq n-1$，$0 \leq c \leq 9$）。
- $\texttt{S}\ i$ 表示输出总公共债务第 $i$ 位的值（$1 \leq i \leq n-1$）。
## 输出格式

对于每个 $\texttt{S}$ 操作，输出一行一个整数表示结果。
## 样例

### 样例输入 #1
```
5 6
7341
0150
S 3
W 3 0
S 3
Z 1 9
S 1
S 3
```
### 样例输出 #1
```
4
1
0
2
```
### 样例输入 #2
```
10 100
627280304
679703557
Z 9 9
Z 2 5
S 3
S 3
W 6 2
W 9 6
Z 6 2
Z 3 9
S 7
Z 5 9
S 3
S 6
S 8
Z 3 2
W 5 1
Z 4 5
W 5 8
S 1
W 4 7
W 8 7
S 9
Z 5 7
S 8
W 5 5
S 6
W 9 9
W 8 0
S 1
S 8
W 8 7
S 9
W 2 4
W 5 7
S 4
Z 6 0
Z 8 2
W 8 2
S 2
W 5 7
W 4 7
W 1 4
W 2 9
S 3
W 8 3
W 5 2
Z 4 2
W 5 9
W 8 3
W 6 6
S 6
W 6 8
Z 7 4
S 5
W 9 9
W 9 6
S 10
W 7 8
Z 1 5
Z 3 4
S 5
S 2
W 9 9
W 3 0
Z 9 4
Z 1 1
Z 5 9
W 7 2
S 3
S 5
W 3 6
Z 4 7
S 7
Z 5 4
S 7
S 1
W 2 8
Z 1 7
W 3 6
W 8 4
S 7
Z 8 8
Z 5 0
W 8 9
W 7 1
S 2
W 2 7
S 2
W 2 5
Z 5 0
W 9 8
W 4 5
Z 2 8
S 5
S 2
Z 2 7
S 1
S 1
W 8 1
W 4 8
Z 7 2
```
### 样例输出 #2
```
8
8
6
2
5
0
1
6
5
5
1
8
9
2
0
6
7
6
1
6
4
5
8
6
6
5
6
4
3
0
4
1
1
```
## 提示

【样例解释#1】：

最初公共债务总额为 $7341+150=7491$，因此第三位上的值为 $4$。

在操作 $2$ 后，公共债务总额为 $7041+150=7191$，因此第三位上的值为 $1$。

在操作 $4$ 后，公共债务总额为 $7041+159=7200$，因此第一位上的值为 $0$，第三位上的值为 $2$。

【数据范围】：

所有测试点均满足：$2 \leq n \leq 10^5$，$1 \leq z \leq 10^5$。

|子任务编号|约束|分值|
|:-:|:-:|:-:|
|$1$|$n,z\leq5\times10^3$|$30$|
| $2$|任何时刻，国内债务和国际债务的每个位上的数字都是 $0$ 或 $5$|$20$|
| $3$|无附加约束|$50$|




---

---
title: "「DTOI-5」#1f1e33"
layout: "post"
diff: 省选/NOI-
pid: P9308
tag: ['O2优化']
---
# 「DTOI-5」#1f1e33
## 题目背景

![](https://cdn.luogu.com.cn/upload/image_hosting/9pyd7oxa.png)

In the middle of night.
## 题目描述

定义函数 $f(n) = \displaystyle\sum_{i = 1}^n \sum_{j = 1}^n \sum_{k = 1}^n [i + j + k = n] \operatorname{lcm}(i, \gcd(j, k))$

给定 $n$，对于所有 $1 \leq i \leq n$，**求出所有** $f(i) \bmod 998244353$ 的值。
## 输入格式

一行，一个整数 $n$。
## 输出格式

一行，$n$ 个整数，表示所有 $f(i) \bmod 998244353$ 的值。
## 样例

### 样例输入 #1
```
10
```
### 样例输出 #1
```
0 0 1 4 11 20 42 60 100 134
```
## 提示

**【数据范围】**

$$
\def\or{\operatorname{or}}
%\def\arrayscretch{1.5}
\def\arraystretch{1.5}
\begin{array}{|c|c|c|}\hline
\textbf{测试点编号}&n= &\textbf{Points}\cr\hline
\sf1&100&10 \operatorname{pts}\cr\hline
\sf2&10^3&10 \operatorname{pts}\cr\hline
\sf3&10^4&20 \operatorname{pts}\cr\hline
\sf4&10^5&20 \operatorname{pts}\cr\hline
\sf5&/&40 \operatorname{pts}\cr\hline
\end{array}
$$
对于 $100\%$ 的数据，$1 \leq n \leq 10^6$。


---

---
title: "[JOISC 2023] Two Currencies (Day1)"
layout: "post"
diff: 省选/NOI-
pid: P9329
tag: ['2023', 'O2优化', 'JOI（日本）']
---
# [JOISC 2023] Two Currencies (Day1)
## 题目描述

There are $N$ cities in JOI Kingdom, numbered from $1$ to $N$. There are $N - 1$ roads in JOI Kingdom, numbered from $1$ to $N - 1$. The road $i \ (1 \le i \le N - 1)$ connects the city $A_i$ and the city $B_i$ bi-directionally. It is possible to travel from any city to any other city by passing through some of the roads.

There are checkpoints on some of the roads in JOI Kingdom. There are $M$ checkpoints, numbered from $1$ to $M$. The checkpoint $j \ (1 \le j \le M)$ is located on the road $P_j$. In order to pass through it, you need to pay either one gold coin or $C_j$ silver coins.

There are $Q$ citizens in JOI Kingdom, numbered from $1$ to $Q$. The citizen $k \ (1 \le k \le Q)$ has $X_k$ gold coins and $Y_k$ silver coins, and wants to travel from the city $S_k$ to the city $T_k$. Since gold coins are valuable, all the citizens want to keep as many gold coins as possible.

Write a program which, given information of the cities, the roads, the checkpoints, and the citizens in JOI Kingdom, for each $k \ (1 \le k \le Q)$, determines whether it is possible for the citizen $k$ to travel from the city $S_k$ to the city $T_k$, and, if it is possible, calculates the maximum possible number of gold coins the citizen $k$ can keep.
## 输入格式

Read the following data from the standard input.

> $N \ M \ Q$
>
> $A_1 \ B_1$
>
> $A_2 \ B_2$
>
> $\vdots$
>
> $A_{N - 1} \ B_{N - 1}$
>
> $P_1 \ C_1$
>
> $P_2 \ C_2$
>
> $\vdots$
>
> $P_M \ C_M$
>
> $S_1 \ T_1 \ X_1 \ Y_1$
>
> $S_2 \ T_2 \ X_2 \ Y_2$
>
> $\vdots$
>
> $S_Q \ T_Q \ X_Q \ Y_Q$
## 输出格式

Write $Q$ lines to the standard output. In the $k$-th line $(1 \le k \le Q)$, if the citizen $k$ can travel from the city $S_k$ to the city $T_k$, output the maximum possible number of gold coins the citizen $k$ can keep. Otherwise, output $-1$ in the $k$-th line.
## 样例

### 样例输入 #1
```
5 4 3
1 2
1 3
2 4
2 5
2 9
2 4
3 5
4 7
3 4 2 11
5 3 4 5
2 3 1 1

```
### 样例输出 #1
```
1
2
-1

```
### 样例输入 #2
```
10 7 9
1 8
6 3
5 9
7 9
3 1
3 4
10 1
2 6
5 6
9 4
7 4
7 4
2 4
7 4
7 4
1 4
8 6 5 3
3 9 8 0
4 7 6 15
7 4 9 3
6 4 8 0
9 10 5 16
5 3 2 4
2 8 4 3
6 1 3 3

```
### 样例输出 #2
```
3
6
6
7
7
3
1
2
2

```
### 样例输入 #3
```
8 7 11
1 2
2 3
3 4
4 5
5 6
6 7
7 8
4 4
3 7
2 10
5 2
4 1
4 4
5 6
6 3 7 69
7 1 5 55
3 1 6 8
8 2 5 45
4 6 4 45
6 1 3 33
2 1 0 19
3 7 2 31
7 1 2 31
7 2 4 58
8 3 5 63

```
### 样例输出 #3
```
7
5
5
5
4
2
0
2
1
4
5

```
### 样例输入 #4
```
8 7 11
1 8
1 4
3 1
3 6
6 7
2 1
5 2
5 5
5 8
4 7
6 6
4 1
6 4
1 7
4 7 2 18
2 4 5 1
4 2 1 32
1 5 7 21
2 5 0 50
8 4 4 33
1 7 6 16
4 8 7 18
1 2 8 13
5 4 10 42
7 1 6 40

```
### 样例输出 #4
```
1
3
1
7
0
4
5
7
8
10
6
```
## 提示

**【样例解释 #1】**

The citizen $1$ can travel from the city $3$ to the city $4$ as follows. After the travel, the citizen $1$ keeps one gold coin.

1.  The citizen $1$ travels from the city $3$ to the city $1$ by passing through the road $2$. There are the checkpoints $1, 2$ on the road $2$. The citizen $1$ pays one gold coin at the checkpoint $1$ and passes through it, and $4$ silver coins at the checkpoint $2$ and passes through it, respectively. After that, the citizen $1$ keeps one gold coin and $7$ silver coins.
2. The citizen $1$ travels from the city $1$ to the city $2$ by passing through the road $1$. Since there is no checkpoint on the road $1$, the citizen $1$ keeps one gold coin and $7$ silver coins.
3. The citizen $1$ travels from the city $2$ to the city $4$ by passing through the road $3$. There is the checkpoint $3$ on the road $3$. The citizen $1$ pays $5$ silver coins at the checkpoint $3$ and passes through it. After that, the citizen $1$ keeps one gold coin and $2$ silver coins.

Since it is impossible for the citizen $1$ to travel by finally keeping more than or equal to $2$ gold coins, output $1$ in the first line.

The citizen $2$ can travel from the city $5$ to the city $3$ as follows. After the travel, the citizen $2$ keeps two gold coins.

1. The citizen $2$ travels from the city $5$ to the city $2$ by passing through the road $4$. There is the checkpoint $4$ on the road $4$. The citizen $2$ pays one gold coin at the checkpoint $4$ and passes through it. After that, the citizen $2$ keeps $3$ gold coins and $5$ silver coins.
2. The citizen $2$ travels from the city $2$ to the city $1$ by passing through the road $1$. Since there is no checkpoint on the road $1$, the citizen $2$ keeps $3$ gold coins and $5$ silver coins.
3. The citizen $2$ travels from the city $1$ to the city $3$ by passing through the road $2$. On the road $2$, there are the checkpoints $1, 2$. The citizen $2$ pays one gold coin at the checkpoint $1$ and passes through it, and $4$ silver coins at the checkpoint $2$ and passes through it, respectively. After that, the citizen $2$ keeps $2$ gold coins and one silver coin.

Since it is impossible for the citizen $2$ to travel by finally keeping more than or equal to $3$ gold coins, output $2$ in the second line.

Since it is impossible for the citizen $3$ to travel from the city $2$ to the city $3$, output $-1$ in the third line.

该样例满足子任务 $1, 4$ 的限制。

**【样例解释 #2】**

该样例满足子任务 $1, 2, 4$ 的限制。

**【样例解释 #3】**

该样例满足子任务 $1, 3, 4$ 的限制。

**【样例解释 #4】**

该样例满足子任务 $1, 4$ 的限制。


**【数据范围】**

对于所有测试数据，满足 $2 \le N \le 10 ^ 5$，$1 \le M, Q \le 10 ^ 5$，$1 \le A_i, B_i \le N$，$1 \le P_j \le N - 1$，$1 \le C_j \le 10 ^ 9$，$1 \le S_k, T_k \le N$，$S_k \ne T_k$，$0 \le X_k \le 10 ^ 9$，$0 \le Y_k \le 10 ^ {18}$，保证给定的道路使所有城市连通，保证所有输入均为整数。

|子任务编号|分值|限制|
|:-:|:-:|:-:|
|$1$|$10$|$N, M, Q \le 2000$|
|$2$|$28$|$C_1 = C_2 = \dots = C_M$|
|$3$|$30$|$A_i = i$，$B_i = i + 1$|
|$4$|$32$|无|
## 题目翻译

#### 题目描述

在 JOI 王国中，有 $n$ 个城市，编号从 $1$ 到 $n$。JOI 王国有 $n−1$ 条双向道路，编号从 $1$ 到 $n−1$。第 $i$ 条道路连接城市 $a_i$ 和城市 $b_i$。

在 JOI 王国中，一些道路上放有检查站。有 $m$ 个检查站，编号从 $1$ 到 $m$。第 $j$ 个检查站位于道路 $p_j$ 上。通过该检查站需要支付 $1$ 枚金币或 $c_j$ 枚银币。

在 JOI 王国有 $q$ 名公民，编号从 $1$ 到 $q$。第 $k$ 名公民持有 $x_k$ 枚金币和 $y_k$ 枚银币，并希望从城市 $s_k$ 前往城市 $t_k$。由于金币具有较高的价值，所有公民都希望尽可能多地保留金币。

编写一个程序，给定 JOI 王国中的城市、道路、检查站和公民信息，对于每个 $k (1≤k≤q)$，判断公民 $k$ 是否能够从城市 $s_k$ 前往城市 $t_k$，并在此条件成立时计算公民 $k$ 所能保留的最多金币数。

#### 输入格式

从标准输入读入以下数据。
> $N \ M \ Q$
>
> $A_1 \ B_1$
>
> $A_2 \ B_2$
>
> $\vdots$
>
> $A_{N - 1} \ B_{N - 1}$
>
> $P_1 \ C_1$
>
> $P_2 \ C_2$
>
> $\vdots$
>
> $P_M \ C_M$
>
> $S_1 \ T_1 \ X_1 \ Y_1$
>
> $S_2 \ T_2 \ X_2 \ Y_2$
>
> $\vdots$
>
> $S_Q \ T_Q \ X_Q \ Y_Q$
#### 输出格式

向标准输出打印 $q$ 行。在第 $k$ 行 $(1≤k≤q)$ 中，如果公民 $k$ 可以从城市 $s_k$ 前往城市 $t_k$，请输出公民 $k$ 可以保留的最多金币数。否则，在第 $k$ 行中输出 $−1$。

Translate by @[ZeXic_B](https://www.luogu.com.cn/user/661274)


---

---
title: "[JOISC 2023] Belt Conveyor（交互，无法评测） (Day2)"
layout: "post"
diff: 省选/NOI-
pid: P9332
tag: ['2023', '交互题', 'O2优化', 'JOI（日本）']
---
# [JOISC 2023] Belt Conveyor（交互，无法评测） (Day2)
## 题目背景

**这是一道交互题。**

**由于技术原因，本题暂不支持提交与评测。**

**如果您能够提供官方数据对应的 grader，请与 @[_RSY_](/user/46197) 联系。**
## 题目描述

**【题目描述】**

In the factory of JOI Co., Ltd., there are $N$ tables, numbered from $0$ to $N - 1$. In the factory, there are $N - 1$ belt conveyors, numbered from $0$ to $N - 2$. The belt conveyor $i \ (0 \le i \le N - 2)$ connects the table $A_i$ and the table $B_i$. It transports products from one table to the other table. However, we cannot see the direction of transportation. If we ignore the directions of the belt conveyors, every pair of tables is connected by a number of belt conveyors.

IOI-kun is the director of the factory. Since he forgets the direction of transportation of every belt conveyor, he will perform the following sequential operations several times.

1. He chooses a number of belt conveyors, and reverses the directions of transportation of the chosen belt conveyors.
2. He chooses a number of tables, and puts a product on each chosen table.
3. For every table where a product is put, one of the following happens simultaneously.
    - If there is no belt conveyor transporting products from it, nothing happens.
    - If there are belt conveyors transporting products from it, the product on the table is transported by one of such belt conveyors. The product stops at the destination of the belt conveyor. The product will not move anymore.
4. IOI-kun confirms whether there are one or more products on each table. If there are products on a table, IOI-kun takes all of them.
5. For every belt conveyor whose direction is reversed in the operation 1., IOI-kun reverts its direction. Its direction becomes the original direction.

IOI-kun wants to specify the original direction of every belt conveyor by performing the above sequential operations at most $30$ times.

Write a program which, given information of the tables connected by the belt conveyors, implements IOI-kun’s strategy to specify the original direction of every belt conveyor by performing the above sequential operations at most $30$ times.

**【实现细节】**

You need to submit one file.

The file is `conveyor.cpp`. It should implement the following function. The program should include `conveyor.h` using the preprocessing directive `#include`.

In `conveyor.cpp`, the following function should be implemented.

```cpp
void Solve(int N, std::vector<int> A, std::vector<int> B)
```

This function is called only once for each test case.

- The parameter `N` is the number of tables $N$.
- The parameters `A，B` are arrays of length $N - 1$, describing the tables connected by the belt conveyors.

Your program can call the following function.

```cpp
std::vector<int> Query(std::vector<int> x, std::vector<int> y)
```

Using this function, IOI-kun performs the operations in the factory.

- The parameter `x` is an array of length $N - 1$. For $0 \le \texttt{i} \le N - 2$, IOI-kun reverses the direction of the belt conveyor `i` if `x[i] = 1`, and does not reverses the direction of the belt conveyor `i` if `x[i] = 0`.
- The parameter `y` is an array of length $$. For $0 \le \texttt{j} \le N - 1$, IOI-kun puts a product on the table `j` if `y[j] = 1`, and does not put a product on the table `j` if `y[j] = 0`.
- Let `z` be the return value of this function. It is an array of length $N$. For $0 \le \texttt{j} \le N - 1$, there are one or more products on the table `j` if `z[j] = 1`, and there is no product on the table `j` if `z[j] = 0`.
- The length of the array `x` should be equal to $N - 1$. If this condition is not satisfied, your program is judged as `Wrong Answer [1]`.
- Every element of the array `x` should be `0` or `1`. If this condition is not satisfied, your program is judged as `Wrong Answer [2]`.
- The length of the array `y` should be equal to $N$. If this condition is not satisfied, your program is judged as `Wrong Answer [3]`.
- Every element of the array `y` should be `0` or `1`. If this condition is not satisfied, your program is judged as `Wrong Answer [4]`.
- The function Query should not be called more than $30$ times. If it is called more than $30$ times, your program is judged as `Wrong Answer [5]`.

```cpp
void Answer(std::vector<int> a)
```

Using this function, IOI-kun reports the original direction of each belt conveyor.

- The parameter `a` is an array of length $N - 1$. For $0 \le \texttt{i} \le N - 2$, the belt conveyor `i` transports products from $A_i$ to $B_i$ if `a[i] = 0`, and it transports products from $B_i$ to $A_i$ if `a[i] = 1`.
- The length of the array `a` should be equal to $N - 1$. If this condition is not satisfied, your program is judged as `Wrong Answer [6]`.
- Every element of the array `a` should be `0` or `1`. If this condition is not satisfied, your program is judged as `Wrong Answer [7]`.
- If IOI-kun reports wrong direction of a belt conveyor, your program is judged as `Wrong Answer [8]`.
- The function `Answer` should be called exactly once. If the function `Answer` is called more than once, your program is judged as `Wrong Answer [9]`. When the function `Solve` terminates, if the function `Answer` is not called, your program is judged as `Wrong Answer [10]`.

#### Important Notices

- Your program can implement other functions for internal use, or use global variables.
- Your program must not use the standard input and the standard output. Your program must not communicate with other files by any methods. However, your program may output debugging information to the standard error.

**【评测方式】**

You can download an archive file from the contest webpage which contains the sample grader to test your program. The archive file also contains a sample source file of your program.

The sample grader is the file `grader.cpp`. In order to test your program, put `grader.cpp`, `conveyor.cpp`, `conveyor.h` in the same directory, and run the following command to compile your programs. Instead, you may run `compile.sh` contained in the archive file.

```plain
g++ -std=gnu++17 -O2 -o grader grader.cpp conveyor.cpp
```

When the compilation succeeds, the executable file `grader` is generated.

Note that the actual grader is different from the sample grader. The sample grader will be executed as a single process, which will read input data from the standard input and write the results to the standard output.
## 输入格式

The sample grader reads the following data from the standard input.

> $N$
>
> $A_0 \ A_1 \ \cdots \ A_{N - 2}$
>
> $B_0 \ B_1 \ \cdots \ B_{N - 2}$
>
> $C_0 \ C_1 \ \cdots \ C_{N - 2}$

For $0 \le i \le N - 2$, we have $C_i = 0$ if the belt conveyor $i$ transports products from the table $A_i$ to the table $B_i$. Otherwise, we have $C_i = 1$.
## 输出格式

The sample grader outputs the following information to the standard output (quotes for clarity).

- If your program is judged as correct, it reports the number of function calls to `Query` as `Accepted: 22`.
- If your program is judged as any type of Wrong Answer, the sample grader writes its type as `Wrong Answer [4]`.

If your program satisfies the conditions of several types of Wrong Answer, the sample grader reports only one of them.

In sample grader, among the belt conveyors transporting products from the table where a product is put, the belt conveyor transporting the product is chosen uniformly and randomly determined by pseudorandom numbers whose results do not change for different executions. In order to change the seed of pseudorandom numbers, run the sample grader with the first integer argument as follows.

```plain
./grader 2023
```
## 提示

**【评测程序示例】**

Here is a sample input for the sample grader and corresponding function calls.

**Sample Input 1:**

```plain
3
0 2
2 1
1 0
```

|Function Calls|Function Calls|Return Values|
|:-|:-|:-|
|`Solve(3, [0, 2], [2, 1])`|||
||`Query([0, 0], [0, 0, 1])`|`[1, 0, 0]`|
||`Query([1, 0], [1, 0, 1])`|`[0, 1, 1]`|
||`Query([1, 1], [0, 0, 1])`|`[0, 0, 1]`|
||`Query([0, 1], [1, 1, 1])`|`[1, 0, 1]`|
||`Answer([1, 0])`||

For the first function call to `Query`, another possible return value is `[0, 1, 0]` other than `[1, 0, 0]`.

For the second function call to `Query`, the product on the table $0$ is transported to the table $2$ by passing through the belt conveyor $0$, and stops there. Note that this product will not be transported to the table $1$ by passing through the belt conveyor $1$.

Note that this sample input **does not satisfy the constraints of any subtask**.

Among the files which can be obtained from the contest webpage, `sample-02.txt` satisfies the constraints of Subtask $1$, and `sample-03.txt` satisfies the constraints of Subtask $2$.

#### Notices for Grading

For some of the test cases, the actual grader is adaptive. This means the grader does not have a fixed answer in the beginning, and responds according to previous function calls to Query. It is guaranteed that there is at least one answer which does not contradict all the responses of the the grader.

**【数据范围】**

对于所有测试数据，满足 $0 \le A_i, B_i \le N - 1$，保证忽略所有传送带的方向后所有机器连通，保证所有输入均为整数。

|子任务编号|分值|$N =$|特殊性质|
|:-:|:-:|:-:|:-:|
|$1$|$1$|$2$|无|
|$2$|$14$|$30$|无|
|$3$|$10$|$10 ^ 5$|$A_i = i$，$B_i = i + 1$|
|$4$|$75$|$10 ^ 5$|无|
## 题目翻译

### 题目描述

在 JOI 有限公司的工厂里，有 $N$ 张桌子，从 $0$ 到 $N-1$ 编号。工厂里有 $N-1$ 条皮带输送机，从 $0$ 到 $N-2$ 编号。第 $i$ 条 $(0 \le i \le N-2)$ 皮带输送机连接桌子 $A_i$ 和桌子 $B_i$。它将产品从一张桌子运输到另一张桌子。然而，我们**不知道**运输的方向。


IOI-kun 是工厂的经理。由于他忘记了每条皮带输送机的运输方向，他将多次按照以下顺序执行操作。
1. 选择几条输送带，并反转所选输送带的运输方向。
2. 选择几张桌子，并在每张选定的桌子上放一件商品。
3. 每当把产品放在一张桌子上时，就会发生以下情况之一。

- 如果没有输送带将产品从该桌子运走，则不会发生任何事情。
- 如果有输送带将产品从该桌子运走，则桌子上的产品将由其中一条输送带运输。产品将在输送带的目的地停止，并且产品将不再移动。
4. IOI-kun 会确认每张桌子上是否有产品。如果有产品在桌子上，IOI-kun 会把它们全部拿走。
5. 对于每个在操作 1 中改变了方向的皮带输送机，IOI-kun 都会将其方向恢复到原来的方向。IOI-kun 希望通过最多执行 $30$ 次上述顺序操作来为每个皮带输送机指定原始方向。

请编写一个程序，根据皮带输送机之间的连接表，实现 IOI-kun 的策略，以通过最多执行 $30$ 次上述顺序操作来为每个皮带输送机指定原始方向。

### 实现细节

你需要实现一份 C++ 程序，提交时**不需要**包含 `conveyor.h`。

你应该实现以下函数。

```cpp
void Solve(int N, std::vector<int> A, std::vector<int> B)
```


该函数仅在每个测试用例中被调用一次：

- 参数 $N$：传送带连接的桌子的数量。
- 参数 $A$ 和 $B$ 是长度为 $N - 1$ 的数组，描述由皮带输送机连接的桌子。

您的程序可以调用以下函数：

```cpp
std::vector<int> Query(std::vector<int> x, std::vector<int> y)
```


使用这个函数，IOI-kun 在工厂中执行操作。

- 参数 $x$ 是一个长度为 $N - 1$ 的数组。对于 $0\le i\le N - 2$，如果 $x_i = 1$，IOI-kun 将反转第 $i$ 个传送带的方向，否则不反转该传送带的方向。
- 参数 $y$ 是一个长度为 $N$ 的数组。对于 $0 \le j \le N - 1$，如果 $y_j = 1$，IOI-kun 将在第 $j$ 个桌子上放置一个产品，否则不会在该桌子上放置产品。
- 设 $z$ 是该函数的返回值。它是一个长度为 $N$ 的数组。对于 $0 \le j \le N - 1$，如果 $z_j = 1$，则第 $j$ 个桌子上有产品，如果 $z_j = 0$，则第 $j$ 个桌子上没有产品。
- 数组 $x$ 的长度应等于 $N - 1$。如果不满足此条件，您的程序将被评为 `Wrong Answer[1]`。
- 数组 $x$ 中的每个元素都应为 $0$ 或 $1$。如果不满足此条件，您的程序将被评为 `Wrong Answer[2]`。
- 数组 $y$ 的长度应等于 $N$。如果不满足此条件，您的程序将被评为 `Wrong Answer[3]`。
- 数组 $y$ 中的每个元素都应为 $0$ 或 $1$。如果不满足上述条件，您的程序将被评为 `Wrong Answer[4]`。
- 函数 Query 最多只能被调用 $30$ 次。如果被调用次数超过 $30$ 次，您的程序将被评为 `Wrong Answer[5]`。

```cpp
void Answer(std::vector<int> a)
```

使用这个函数，IOI-kun 会报告每个输送带的原始方向。

- 参数 $a$ 是一个长度为 $N - 1$ 的数组。对于 $0 \le i \le N - 2$，如果 $a_i = 0$，则输送带 $i$ 将产品从 $A_i$ 运输到 $B_i$，如果 $a_i = 1$，则将产品从 $B_i$ 运输到 $A_i$。
- 数组 $a$ 的长度必须等于 $N - 1$。如果条件不满足，您的程序将被评为 `Wrong Answer[6]`。
- 数组 $a$ 中的每个元素都必须为 $0$ 或 $1$。如果条件不满足，您的程序将被评为 `Wrong Answer[7]`。
- 如果 IOI-kun 报告了输送带的错误方向，您的程序将被评为 `Wrong Answer[8]`。
- 函数 `Answer` 必须被**恰好调用一次**。如果函数 `Answer` 被调用多次，您的程序将被评为 `Wrong Answer[9]`。当函数 `Solve` 结束时，如果函数 `Answer` 尚未被调用，您的程序将被评为 `Wrong Answer[10]`。

### 输入格式
样例评测库将读入以下格式的数据：
```
N
A[0] A[1] ... A[N - 2]
B[0] B[1] ... B[N - 2]
C[0] C[1] ... C[N - 2]
```
对于 $0\le i\le N - 2$，如果第 $i$ 条传送带会将产品从 $A_i$ 运输至 $B_i$，那么 $C_i$ 为 $0$，否则 $C_i$ 为 $1$。

### 输出格式
样例评测库将以下信息输出到 stdout。

-如果你的程序被判断为正确，它报告的函数 `Query` 调用的数量为 `Accepted: 22` 。

-如果你的程序被判定为任何类型的错误答案，样例评分员将其类型写为 `Wrong Answer[4]`。



如果您的程序满足几种类型的错误答案的条件，则样例评测库只报告其中一种。

### 输入输出样例
#### 样例 #1
```plain
3
0 2
2 1
1 0
```

### 说明/提示
|函数调用|函数调用|返回值|
|:-|:-|:-|
|`Solve(3, [0, 2], [2, 1])`|||
||`Query([0, 0], [0, 0, 1])`|`[1, 0, 0]`|
||`Query([1, 0], [1, 0, 1])`|`[0, 1, 1]`|
||`Query([1, 1], [0, 0, 1])`|`[0, 0, 1]`|
||`Query([0, 1], [1, 1, 1])`|`[1, 0, 1]`|
||`Answer([1, 0])`||

对于对 `Query` 的第一次调用，另一个可能的返回值是 `[0,1,0]`。



对于对 `Query` 的第二次调用，位置为 $0$ 上的产品通过传送带 $0$ 被传送到位置 $2$，并停在那里。请注意，该产品不会被传送带 $1$ 输送到位置 $1$。



注意，这个示例输入**不满足任何子任务**的限制条件。



下发文件中，`sample-02.txt` 满足 Subtask $1$ 的限制条件，`sample-03.txt` 满足 Subtask $2$ 的限制条件。

对于某些测试用例，实际的评测程序**是自适应的**。这意味着评测程序在开始时没有固定的答案，并根据先前对 `Query` 函数的调用进行响应。

Translate by @[tbdsh](/user/752485).


---

---
title: "[JOISC 2023] Council (Day2)"
layout: "post"
diff: 省选/NOI-
pid: P9333
tag: ['2023', 'O2优化', 'JOI（日本）']
---
# [JOISC 2023] Council (Day2)
## 题目描述

In the council of JOI City, there are $N$ assembly members, numbered from $1$ to $N$. The council will open a meeting, and the assembly members will take votes on $M$ proposed ordinances, numbered from $1$ to $M$. If $A_{i, j} = 1$, the assembly member $i \ (1 \le i \le N)$ will cast an affirmative vote on the proposed ordinance $j \ (1 \le j \le M)$. If $A_{i, j} = 0$, the assembly member $i$ will cast a negative vote on the proposed ordinance $j$.

The council of JOI City will be performed as follows.

1. Among the $N$ assembly members, they will randomly choose a chairperson by drawing lots.
2. The chairperson will choose a deputy chairperson among the $N - 1$ assembly members except for the chairperson.
3. The votes will be taken on $M$ proposed ordinances. Each of the $N - 2$ assembly members except for the chairperson and the deputy chairperson will cast an affirmative vote or a negative vote on each proposed ordinance. The council will approve a proposed ordinance if a majority of the assembly members (i.e., more than or equal to $\lfloor \frac{N}{2} \rfloor$ assembly members) cast affirmative votes on it. Here, $\lfloor x \rfloor$ is the largest integer not exceeding $x$.

Mayor K, the mayor of JOI City, wants the council to approve as many proposed ordinances as possible. Mayor K collected information on assembly members. Mayor K knows, on each proposed ordinance, who will cast an affirmative vote and who will cast a negative vote.

Write a program which, given information of the votes of the assembly members, calculates, for each assembly member, the maximum possible number of proposed ordinances approved by the council if that assembly member is chosen as the chairperson.
## 输入格式

Read the following data from the standard input.

> $N \ M$
>
> $A_{1, 1} \ A_{1, 2} \ \cdots \ A_{1, M}$
>
> $A_{2, 1} \ A_{2, 2} \ \cdots \ A_{2, M}$
>
> $\vdots$
>
> $A_{N, 1} \ A_{N, 2} \ \cdots \ A_{N, M}$
## 输出格式

Write $N$ lines to the standard output. The $i$-th line $(1 \le i \le N)$ of output should contain the maximum possible number of proposed ordinances approved by the council if the assembly member $i$ is chosen as the chairperson.
## 样例

### 样例输入 #1
```
3 3
1 0 0
1 1 0
1 1 1

```
### 样例输出 #1
```
3
3
2

```
### 样例输入 #2
```
4 12
1 1 1 0 1 1 0 1 0 1 1 0
1 1 0 1 1 0 1 1 1 1 1 0
0 0 1 1 1 0 0 0 0 0 1 1
1 0 0 0 1 1 1 1 1 0 0 0

```
### 样例输出 #2
```
5
4
6
6

```
### 样例输入 #3
```
16 4
0 0 0 0
0 0 0 1
0 0 1 0
0 0 1 1
0 1 0 0
0 1 0 1
0 1 1 0
0 1 1 1
1 0 0 0
1 0 0 1
1 0 1 0
1 0 1 1
1 1 0 0
1 1 0 1
1 1 1 0
1 1 1 1

```
### 样例输出 #3
```
3
3
3
2
3
2
2
1
3
2
2
1
2
1
1
0

```
### 样例输入 #4
```
4 2
1 0
0 1
1 1
1 1

```
### 样例输出 #4
```
2
2
1
1

```
## 提示

**【样例解释 #1】**

- Let’s consider the case where the assembly member $1$ is chosen as the chairperson. If the assembly member $2$ is chosen as the deputy chairperson, the council will approve three proposed ordinances, i.e., the proposed ordinances $1, 2, 3$. If the assembly member $3$ is chosen as the deputy chairperson, the council will approve two proposed ordinances, i.e., the proposed ordinances $1, 2$. Therefore, the maximum number of proposed ordinances approved by the council is $3$. Output $3$ in the first line.
- Let’s consider the case where the assembly member $2$ is chosen as the chairperson. If the assembly member $1$ is chosen as the deputy chairperson, the council will approve three proposed ordinances, i.e., the proposed ordinances $1, 2, 3$. If the assembly member $3$ is chosen as the deputy chairperson, the
council will approve one proposed ordinance, i.e., the proposed ordinance $1$. Therefore, the maximum number of proposed ordinances approved by the council is $3$. Output $3$ in the second line.
- Let’s consider the case where the assembly member $3$ is chosen as the chairperson. If the assembly member $1$ is chosen as the deputy chairperson, the council will approve two proposed ordinances, i.e., the proposed ordinances $1, 2$. If the assembly member $2$ is chosen as the deputy chairperson, the council will approve one proposed ordinance, i.e., the proposed ordinance $1$. Therefore, the maximum number of proposed ordinances approved by the council is $2$. Output $2$ in the third line.

该样例满足子任务 $1, 2, 4, 5, 6, 7$ 的限制。

**【样例解释 #2】**

该样例满足子任务 $1, 2, 5, 6, 7$ 的限制。

**【样例解释 #3】**

该样例满足子任务 $1, 2, 4, 5, 6, 7$ 的限制。

**【样例解释 #4】**

该样例满足所有子任务的限制。

**【数据范围】**

对于所有测试数据，$3 \le N \le 3 \times 10 ^ 5$，$1 \le M \le 20$，$0 \le A_{i, j} \le 1$，保证所有输入均为整数。

|子任务编号|分值|限制|
|:-:|:-:|:-:|
|$1$|$8$|$N \le 300$|
|$2$|$8$|$N \le 3000$|
|$3$|$6$|$M \le 2$|
|$4$|$19$|$M \le 10$|
|$5$|$15$|$M \le 14$|
|$6$|$22$|$M \le 17$|
|$7$|$22$|无|
## 题目翻译

#### 题目翻译

在 JOI 市议会中，有 $N$ 名议员，编号从 $1$ 到 $N$。议会将召开会议，议员们将对 $M$ 项提案进行表决，编号为 $1$ 到 $M$。如果 $A_{i,j}=1$，则议员 $i (1≤i≤N)$ 将对提案 $j (1≤j≤M)$ 表决肯定票。如果 $A_{i,j}=0$，则议员 $i$ 将对提案 $j$ 表决否定票。

JOI 市议会的程序如下所示。

+ 在 $N$ 名议员中，通过抽签随机选择主席。

+ 主席将在除了主席以外的其他 $N−1$ 名议员中选择副主席。

+ 将对 $M$ 项提案进行表决。除了主席和副主席以外的其他 $N−2$ 名议员，每人对每个提案均投票支持或反对。如果大多数议员（即肯定票大于等于 $⌊\dfrac{N}{2}⌋$）投票赞成，则议会将批准该提案。其中 $⌊x⌋$ 表示不超过 $x$ 的最大整数。

市长 K 希望议会尽可能地批准更多的提案。市长 K 收集了议员的信息并知道每个议员在每个提案上的表决结果。

请编写程序，在给定议员投票信息的情况下，计算每个议员作为主席时议会可以批准的提案数量的最大可能值。

#### 输入格式

从标准输入读取以下数据。

> $N \ M$
>
> $A_{1, 1} \ A_{1, 2} \ \cdots \ A_{1, M}$
>
> $A_{2, 1} \ A_{2, 2} \ \cdots \ A_{2, M}$
>
> $\vdots$
>
> $A_{N, 1} \ A_{N, 2} \ \cdots \ A_{N, M}$

#### 输出格式

输出 $N$ 行。输出的第 $i$ 行（$1≤i≤N$）应包含议员 $i$ 作为主席时议会可以批准的提案数量的最大可能值。

#### 样例解释 #1
+ 假设议员 $1$ 被选为主席。如果议员 $2$ 被选为副主席，则议会将批准三个提案，即提案 $1,2,3$。如果议员 $3$ 被选为副主席，则议会将批准两个提案，即提案 $1,2$。因此，议会批准的提案数量的最大值是 $3$。在第一行输出 $3$。

+ 假设议员 $2$ 被选为主席。如果议员 $1$ 被选为副主席，则议会将批准三个提案，即提案 $1,2,3$。如果议员 $3$ 被选为副主席，则议会将批准一个提案，即提案 $1$。因此，议会批准的提案数量的最大值是 $3$。在第二行输出 $3$。

+ 假设议员 $3$ 被选为主席。如果议员 $1$ 被选为副主席，则议会将批准两个提案，即提案 $1,2$。如果议员 $2$ 被选为副主席，则议会将批准一个提案，即提案 $1$。因此，议会批准的提案数量的最大值是 $2$。在第三行输出 $2$。

Translate by @[ZeXic_B](https://www.luogu.com.cn/user/661274)


---

---
title: "[JOISC 2023] Tourism (Day3)"
layout: "post"
diff: 省选/NOI-
pid: P9340
tag: ['2023', 'O2优化', 'JOI（日本）']
---
# [JOISC 2023] Tourism (Day3)
## 题目描述

JOI Kingdom is an insular country consisting of $N$ islands, numbered from $1$ to $N$. The islands are connected by $N − 1$ bridges, numbered from $1$ to $N − 1$. The bridge $i\ (1 ≤ i ≤ N − 1)$ connects the island $A_i$ and the island $B_i$ bidirectionally. It is possible to travel from any island to any other island by passing through a number of
bridges.
In JOI Kingdom, there are $M$ sightseeing spots, numbered from $1$ to $M$. The sightseeing spot $j\ (1 ≤ j ≤ M)$ is located in the island $C_j$.
There are $Q$ travelers. They plan to visit sightseeing spots in JOI Kingdom. The travelers are numbered from $1$ to $Q$. Each traveler makes a trip in the following way.

1. The traveler chooses an island $x\ (1 ≤ x ≤ N)$. Taking an airplane, the traveler arrives at the island $x$.
2. The traveler takes the following actions a number of times. The order and the kinds of actions are arbitrary.

    - The traveler chooses a sightseeing spot in the current island, and visits there.
    - The traveler moves to another island by passing through a bridge.

3. Taking an airplane, the traveler leaves JOI Kingdom.
    The traveler $k\ (1 ≤ k ≤ Q)$ wants to visit all of the sightseeing spots $L_k, L_{k + 1}, . . . , R_k$. However, since the budget is limited, the traveler $k$ wants to minimize the number of islands where the traveler $k$ visits at least once.

Write a program which, given information of JOI Kingdom and the travelers, calculates, for each $k\ (1 ≤ k ≤ Q)$, the minimum possible number of islands where the traveler $k​$ visits at least once.
## 输入格式

Read the following data from the standard input.

> $N\ M\ Q$
> 
> $A_1\ B_1$
> 
> $A_2\ B_2$
> 
> $\vdots$
> 
> $A_{N−1}\ B_{N−1}$
> 
> $C_1\ C_2\ · · ·\ C_M$
> 
> $L_1\ R_1$
> 
> $L_2\ R_2$
> 
> $\vdots$
> 
> $L_Q\ R_Q$

## 输出格式

Write $Q$ lines to the standard output. The $k$-th line $(1 ≤ k ≤ Q)$ of output should contain the minimum possible number of islands where the traveler $k$ visits at least once.
## 样例

### 样例输入 #1
```
7 6 2
1 2
1 3
2 4
2 5
3 6
3 7
2 3 6 4 5 7
1 3
4 6
```
### 样例输出 #1
```
4
6
```
### 样例输入 #2
```
8 8 9
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 6 4 3 5 2 4 7
3 5
4 6
6 8
1 4
2 3
6 8
5 5
2 8
1 2
```
### 样例输出 #2
```
3
4
6
6
3
6
1
6
3
```
### 样例输入 #3
```
10 7 9
6 5
3 6
9 3
8 3
7 8
7 1
2 5
7 10
8 4
9 4 10 1 10 7 6
4 4
1 3
1 3
6 7
3 6
3 3
1 5
2 5
1 2
```
### 样例输出 #3
```
1
6
6
4
3
1
7
5
4
```
## 提示

**【样例解释 #1】**

The traveler 1 makes a trip in the following way, and visits all of the sightseeing spots 1, 2, 3.
1. The traveler 1 arrives at the island 2.
2. The traveler 1 visits the sightseeing spot 1 in the island 2.
3. The traveler 1 moves from the island 2 to the island 1 by passing through the bridge 1.
4. The traveler 1 moves from the island 1 to the island 3 by passing through the bridge 2.
5. The traveler 1 visits the sightseeing spot 2 in the island 3.
6. The traveler 1 moves from the island 3 to the island 6 by passing through the bridge 5.
7. The traveler 1 visits the sightseeing spot 3 in the island 6.
8. The traveler 1 departs from the island 6 and leaves JOI Kingdom.

The islands 1, 2, 3, 6 are the four islands where the traveler 1 visits at least once. If the number of islands traveler 1 visits at least once is less than or equal to 3, it is impossible to visit all of the sightseeing spots 1, 2, 3.
Therefore, output 4 in the first line.
The traveler 2 makes a trip in the following way, and visits all of the sightseeing spots 4, 5, 6.
1. The traveler 2 arrives at the island 3.
2. The traveler 2 moves from the island 3 to the island 7 by passing through the bridge 6.
3. The traveler 2 visits the sightseeing spot 6 in the island 7.
4. The traveler 2 moves from the island 7 to the island 3 by passing through the bridge 6.
5. The traveler 2 moves from the island 3 to the island 1 by passing through the bridge 2.
6. The traveler 2 moves from the island 1 to the island 2 by passing through the bridge 1.
7. The traveler 2 moves from the island 2 to the island 4 by passing through the bridge 3.
8. The traveler 2 visits the sightseeing spot 4 in the island 4.
9. The traveler 2 moves from the island 4 to the island 2 by passing through the bridge 3.
10. The traveler 2 moves from the island 2 to the island 5 by passing through the bridge 4.
11. The traveler 2 visits the sightseeing spot 5 in the island 5.
12. The traveler 2 departs from the island 5 and leaves JOI Kingdom.

The islands 1, 2, 3, 4, 5, 7 are the six islands where the traveler 2 visits at least once. If the number of islands
traveler 2 visits at least once is less than or equal to 5, it is impossible to visit all of the sightseeing spots 4, 5, 6.
Therefore, output 6 in the second line.
This sample input satisfies the constraints of Subtasks 1, 2, 4, 5, 6.

The islands 1, 2, 3, 4, 5, 7 are the six islands where the traveler 2 visits at least once. If the number of islands
traveler 2 visits at least once is less than or equal to 5, it is impossible to visit all of the sightseeing spots 4, 5, 6.
Therefore, output 6 in the second line.

This sample input satisfies the constraints of Subtasks 1, 2, 4, 5, 6.

**【样例解释 #2】**

This sample input satisfies the constraints of Subtasks 1, 2, 3, 6.

**【样例解释 #3】**

This sample input satisfies the constraints of Subtasks 1, 2, 6.

**【数据范围】**

- $1 ≤ N ≤ 100 000$.
- $1 ≤ M ≤ 100 000$.
- $1 ≤ Q ≤ 100 000$.
- $1 ≤ A_i ≤ N\ (1 ≤ i ≤ N − 1)$.
- $1 ≤ B_i ≤ N\ (1 ≤ i ≤ N − 1)$.
- It is possible to travel from any island to any other island by passing through a number of bridges.
- $1 ≤ C_j ≤ N\ (1 ≤ j ≤ M)$.
- $1 ≤ L_k ≤ R_k ≤ M\ (1 ≤ k ≤ Q)$.
- Given values are all integers.

**【子任务】**

1. (5 points) $N ≤ 300, M ≤ 300, Q ≤ 300$.
2. (5 points) $N ≤ 2 000, M ≤ 2 000, Q ≤ 2 000$.
3. (7 points) $A_i = i, B_i = i + 1\ (1 ≤ i ≤ N − 1)$.
4. (18 points) $L_1 = 1, R_{k} + 1 = L_{k+1}\ (1 ≤ k ≤ Q − 1), R_Q = M$.
5. (24 points) $A_i = \lfloor\frac{i+1}2\rfloor, B_i = i + 1\ (1 ≤ i ≤ N−1)$. Here, $⌊x⌋$ is the largest integer not exceeding x.
6. (41 points) No additional constraints.
## 题目翻译

给出一颗 $n$ 个节点的树，和一个长度为 $m$ 的序列 $a$，$q$ 次询问包含 $a_{l\cdots r}$ 中所有节点的最小联通块大小。

$n,m,q\le 10^5$


---

---
title: "[JOI 2023 Final] Maze"
layout: "post"
diff: 省选/NOI-
pid: P9351
tag: ['2023', 'O2优化', 'JOI（日本）']
---
# [JOI 2023 Final] Maze
## 题目描述

President K loves solving mazes. He found cells from which he may create a maze. The cells are rectangular grid with $R$ horizontal rows and $C$ vertical columns. Each cell is colored either white or black. The cell in the $i$-th row ($1 \leqslant i \leqslant R$) from the top and the $j$-th column ($1 \leqslant j \leqslant C$) from the left is called Cell $(i, j)$.

President K will solve the maze under the condition that he can pass the white cells, but he cannot pass the black cells. More precisely, he will solve the maze in the following way.

1. Among the white cells, he will choose Cell $(S_r, S_c)$, which is the starting cell of the maze, and Cell $(G_r, G_c)$, which is the goal cell of the maze.
2. It is possible to move from one cell to another white cell which is adjacent to the current cell in one of the four directions (top, bottom, left, or right). By repeating this, he will find a path from the starting cell to the goal cell.

President K already fixed the starting cell and the goal cell. However, he noticed that in some situations of the colors of the cells, there might not be a path from the starting cell to the goal cell consisting of white cells only. He has a stamp of size $N \times N$. He will perform the following **Operations** several times so that there will be a path from the starting cell to the goal cell consisting of white cells only.

**Operation.** He chooses a square region of $N \times N$ cells, and paint the cells in the region white. More precisely, he chooses integers $a, b$ satisfying $1 \leqslant a \leqslant R - N + 1$ and $1 \leqslant b \leqslant C − N + 1$, and for every pair $(i, j)$ of integers satisfying $a \leqslant i \leqslant a + N − 1$ and $b \leqslant j \leqslant b + N − 1$, he paints Cell $(i, j)$ white.

Since his hands becomes dirty if he uses the stamp, he wants to minimize the number of operations. Given
information of the colors of the cells, the size of the stamp, and the locations of the starting cell and the goal cell, write a program which calculates the minimum number of operations he has to perform so that there will be a path from the starting cell to the goal cell consisting of white cells only.
## 输入格式

Read the following data from the standard input.

> $R$ $C$ $N$  
$S_r$ $S_c$  
$G_r$ $G_c$  
$A_1$  
$A_2$  
$.$  
$.$  
$.$  
$A_R$

$A_i (1 \leqslant i \leqslant R)$ is a string of length $C$ consisting of `.` or `#`. The $j$-th character ($1 \leqslant j \leqslant C$) of $A_i$ represents the color of Cell $(i, j)$. Its color is white if the character is `.`, and its color is black if the character is `#`.
## 输出格式

Write one line to the standard output. The output should contain the minimum number of operations President
K has to perform so that there will be a path from the starting cell to the goal cell consisting of white cells only.
## 样例

### 样例输入 #1
```
2 4 2
1 1
2 4
.###
###.

```
### 样例输出 #1
```
1

```
### 样例输入 #2
```
6 6 1
1 6
6 1
..#.#.
##.###
####.#
...###
##.##.
.#.###

```
### 样例输出 #2
```
4

```
### 样例输入 #3
```
6 7 6
6 4
3 1
..#.#.#
##.##..
.######
#..#.#.
.######
..#.##.

```
### 样例输出 #3
```
1

```
### 样例输入 #4
```
1 15 1
1 15
1 1
...............

```
### 样例输出 #4
```
0

```
## 提示

#### 【样例解释 #1】

If he chooses $(a, b) = (1, 2)$ and perform an operation, Cells $(1, 2), (1, 3), (2, 2), (2, 3)$ become white. Then there will be a path from the starting cell to the goal cell consisting of white cells only. For example, the path $(1, 1) → (1, 2) → (1, 3) → (2, 3) → (2, 4)$ satisfies the condition.

If he does not perform an operation, there is no path from the starting cell to the goal cell consisting of white cells only. Therefore, output $1$.

该样例满足子任务 $2, 3, 4, 5, 6, 7, 8$ 的限制。

#### 【样例解释 #2】

该样例满足所有子任务的限制。

#### 【样例解释 #3】

该样例满足子任务 $2, 3, 4, 5, 6, 7, 8$ 的限制。

#### 【样例解释 #4】

Even if he does not perform an operation, there might be a path from the starting cell to the goal cell consisting of white cells only.

该样例满足所有子任务的限制。

#### 【数据范围】

对于所有测试数据，满足 $1 ≤ N ≤ R ≤ C$, $R × C ≤ 6 \times 10^6$, $1 ≤ S_r ≤ R$, $1 ≤ S_c ≤ C$, $1 ≤ G_r ≤ R$, $1 ≤ G_c ≤ C$, $(S_r, S_c) \neq (G_r, G_c)$.

保证 $A_i (1 ≤ i ≤ R)$ 是一个长为 $C$ 且只由 `.` 或 `#` 构成的字符串。保证格子 $(S_r, S_c)$ 与格子 $(G_r, G_c)$ 均为白色。

保证 $R, C, N, S_r, S_c, G_r, G_c$ 均为整数。

| 子任务编号 | 分值 | 限制 |
| :-: | :-: | :-: |
| $1$ | $8$ | $N = 1, R × C ≤ 1.5 \times 10^6$ |
| $2$ | $19$ | $R × C ≤ 10^3$ |
| $3$ | $16$ | 答案不超过 $10$, $R × C ≤ 1.5 \times 10^6$ |
| $4$ | $19$ | $R × C ≤ 6 \times 10^4$ |
| $5$ | $5$ | $R × C ≤ 1.5 \times 10^5$ |
| $6$ | $19$ | $R × C ≤ 1.5 \times 10^6$ |
| $7$ | $8$ | $R × C ≤ 3 \times 10^6$ |
| $8$ | $6$ | 无 |
## 题目翻译

给定一张 $R\times C$ 的地图，其中 ```.``` 可以走，而 ```#``` 不能走。一次操作可以将 $N \times N$ 的正方形范围内所有点变成 ```.```，给定起点和终点，求最少需要几次操作使得起点和终点连通（只能上下左右移动）。

$R\times C\le 6\times 10^6$，$N\le R\le C$。


---

---
title: "[ICPC 2022 Xi'an R] Contests"
layout: "post"
diff: 省选/NOI-
pid: P9361
tag: ['2022', 'O2优化', 'ICPC']
---
# [ICPC 2022 Xi'an R] Contests
## 题目描述

There are $n$ contestants and they take part in $m$ contests. You are given the ranklist of each contest. The ranklist of the $k$-th contest is a sequence $a_k$, indicating that the $a_{k, i}$-th contestant's rank is $i$.

SolarPea and PolarSea are two of the $n$ contestants. SolarPea wants to prove that he is stronger than PolarSea.

Define $x$ is $l$-stronger than $y$, if and only if there exists a sequence $b$ of length $l + 1$, such that $b_1 = x$, $b_{l + 1} = y$, and for all $1\leq i\leq l$, $b_i$ has a smaller rank than $b_{i + 1}$ in at least one contest.

There are $q$ queries. In the $i$-th query, SolarPea is contestant $x$ and PolarSea is contestant $y$. Please find the minimum positive number $l$ such that SolarPea is $l$-stronger than PolarSea.
## 输入格式

The first line contains two integers $n$ ($2\leq n\leq 10 ^ 5$) and $m$ ($1\leq m\leq 5$).

The $i$-th of the next $m$ lines contains $n$ intergers $a_{i, 1}, a_{i, 2}, \ldots, a_{i, n}$. It is guaranteed that $a_i$ is a permutaion of $1,2,\ldots,n$.

The next line contains an integer $q$ ($1\leq q\leq 10 ^ 5$).

Each of the next $q$ lines contains two integers $x$ and $y$ ($1 \le x,y \le n, x \neq y$), representing a query.
## 输出格式

For each query, output a number $l$ representing the answer. If there is no legal $l$, output $-1$.
## 样例

### 样例输入 #1
```
6 2
1 3 2 5 4 6
2 1 4 3 6 5
4
1 4
5 3
6 1
5 2

```
### 样例输出 #1
```
1
2
5
3

```
## 提示

**Source**: The 2022 ICPC Asia Xi'an Regional Contest Problem D.

**Author**: csy2005.
## 题目翻译

### 题目描述

$n$ 个选手参加了 $m$ 场比赛。给出每场比赛的排行榜。第 $k$ 场比赛的排行榜是一个 $n$ 阶排列 $a_k$，表示选手 $a_{k, i}$ 的排名为 $i$。

SolarPea 和 PolarSea 也是选手。SolarPea 想要证明他比 PolarSea 更强。

定义选手 $x$「$l$ - 强于」选手 $y$，当且仅当存在长度为 $l + 1$ 的序列，满足 $b_1 = x$，$b_{l + 1} = y$，且对于所有 $1\leq i\leq l$，均有 $b_i$ 在至少一场比赛中排名小于 $b_{i + 1}$。

给出 $q$ 组询问。在第 $i$ 组询问中，SolarPea 是选手 $x$，PolarSea 是选手 $y$。求出最小的正整数 $l$，使得 $x$「$l$ - 强于」$y$。

$2\leq n\leq 10 ^ 5$，$1\leq q\leq 10 ^ 5$，$1\leq m\leq 5$，$1\leq x, y\leq n$，$x\neq y$。

### 输入格式

第一行两个整数 $n, m$。

接下来 $m$ 行，每行 $n$ 个整数，表示第 $i$ 场比赛的排行榜。保证 $a_i$ 是 $1, 2, \ldots, n$ 的排列。

接下来一行一个整数 $q$。

接下来 $q$ 行，每行两个整数 $x, y$ 表示一组询问。

### 输出格式

对于每组询问，输出一行一个整数表示答案。若不存在这样的 $l$，输出 $-1$。




---

---
title: "[ICPC 2022 Xi'an R] Streets"
layout: "post"
diff: 省选/NOI-
pid: P9368
tag: ['2022', 'O2优化', 'ICPC']
---
# [ICPC 2022 Xi'an R] Streets
## 题目描述

You are given $n$ vertical lines with x-coordinates $x_1, x_2, \ldots, x_n$ and weights $a_1, a_2, \ldots, a_n$ and $m$ horizontal lines with y-coordinates $y_1, y_2, \ldots, y_m$ and weights $b_1, b_2, \ldots, b_m$.

Call a rectangle good if and only if all of its four edges lie on the given lines. On this basis, define the cost of a good rectangle as the sum of the costs of its four segments. The cost of a segment is the product of its length and the weight of the line it belongs.

Find the maximum area of good rectangles with cost no more than $c$. Note that the length and the width of the rectangle can be zero, so the answer always exists.

You need to answer $T$ queries with different $c$.
## 输入格式

The first line contains three integers $n$, $m$ ($2\leq n, m\leq 5\,000$) and $T$ ($1\leq T\leq 100$).

The second line contains $n$ integers $x_1, x_2, \ldots, x_n$ ($1\leq x_1 < x_2 < \ldots < x_n \leq 10 ^ 5$).

The third line contains $n$ integers $a_1, a_2, \ldots, a_n$ ($1\leq a_i\leq 10 ^ 7$).

The fourth line contains $m$ integers $y_1, y_2, \ldots, y_m$ ($1\leq y_1 < y_2 < \ldots < y_m \leq 10 ^ 5$).

The fifth line contains $m$ integers $b_1, b_2, \ldots, b_m$ ($1\leq b_i\leq 10 ^ 7$).

Each of the next $T$ lines contains a single integer $c$ ($1\leq c\leq 4\times 10 ^ {12}$), representing a query.
## 输出格式

For each query, output one line representing the answer.
## 样例

### 样例输入 #1
```
3 4 20
1 3 4
3 1 2
1 3 4 7
4 2 1 2
1
5
6
7
9
10
11
12
15
16
17
22
23
28
30
35
43
47
49
57

```
### 样例输出 #1
```
0
0
1
1
1
2
2
3
3
4
4
6
6
9
9
12
12
12
18
18

```
## 提示

**Source**: The 2022 ICPC Asia Xi'an Regional Contest Problem K.

**Author**: Alex_Wei.
## 题目翻译

### 题目描述：
给定 $n$ 条垂直的线和 $m$ 条水平线，每条线有重量。定义一个矩形是好的，当且仅当矩形的四个边都落在这些线上，好矩形的代价等于其内部四条边的长度与对应线重量的乘积之和。请找出最大面积的好矩形，使得其代价不超过 $c$。注意，矩形的长度和宽度可以为零。

### 输入格式：
第一行三个正整数 $n,m,T(2 \leq n, m \leq 5 \times 10^3, 1 \leq T \leq 100)$，依次表示垂直线、水平线的数量以及查询的次数。

第二行 $n$ 个正整数 $x_1,x_2,\cdots,x_n(1 \leq x_1 < x_2 < \cdots < x_n \leq 10^5)$，其中 $x_i$ 表示第 $i$ 条垂直线的位置。

第三行 $n$ 个正整数 $a_1,a_2,\cdots,a_n$，其中 $a_i$ 表示第 $i$ 条垂直线的重量。

第四行 $m$ 个正整数 $y_1,y_2,\cdots,y_m(1 \leq y_1 < y_2 < \cdots < y_m \leq 10^5)$，其中 $y_i$ 表示第 $i$ 条水平线的位置。

第五行 $m$ 个正整数 $b_1,b_2,\cdots,b_m(1 \leq b_i \leq 10^7)$，其中 $b_i$ 表示第 $i$ 条水平线的重量。

接下来 $T$ 行，每行一个正整数 $c(1 \leq c \leq 4\times 10^{12})$，表示一次查询。

### 输出格式：
对于每次查询，输出一个整数表示最小代价不超过 $c$ 的最大好矩形的面积。

translated by @[cff_0102](/user/542457)


---

---
title: "紫丁香"
layout: "post"
diff: 省选/NOI-
pid: P9393
tag: ['洛谷原创', 'O2优化', '洛谷月赛']
---
# 紫丁香
## 题目描述

对于一个字符串 $A$，记 $A_i$ 表示它的第 $i$ 个字符。

设 $S$ 是任意长度为 $m$ 的 $01$ 串。我们有 $n$ 个操作，第 $i$ 个操作可以表示成一个定义域和值域都是长度为 $m$ 的 $01$ 串集合的函数 $f_i$，表示经过这次操作后 $S$ 会变成 $f_i(S)$。而函数 $f_i$ 可以由一个长度为 $m$ 的串 $T_i$ 表示，$T_i$ 由 $\texttt{0,1,-}$ 三种字符组成，其中：

- $T_{i,j}=\texttt{0}$ 表示 $[f_i(S)]_j=\texttt{0}$。

- $T_{i,j}=\texttt{1}$ 表示 $[f_i(S)]_j=\texttt{1}$。

- $T_{i,j}=\texttt{-}$ 表示 $[f_i(S)]_j=S_j$。

也就是说，每个操作会将 $S$ 的一些位赋值为 $0$，一些位赋值为 $1$，还有一些位不变。

现在有 $q$ 次操作，每次操作给定一个长度为 $m$ 的 $01$ 串 $S$，你可以对它做任意多次操作，操作的顺序任意，一个操作可以做多次。得到的串 $S'$ 可以被看做一个二进制数，求对应二进制数最大的 $S'$。
## 输入格式

第一行：三个整数 $m,n,q$。

接下来 $n$ 行：每行一个长度为 $m$ 的串 $T$，表示一种操作。

接下来 $q$ 行：每行一个长度为 $m$ 的串 $S$，表示一个询问。
## 输出格式

输出 $q$ 行：每行一个长度为 $m$ 的串，依次表示每个询问的答案。
## 样例

### 样例输入 #1
```
5 3 3
-1-01
011-0
--010
00000
10010
00101

```
### 样例输出 #1
```
01110
11010
01110

```
## 提示

**【样例解释】**

对于第一个询问串 $\texttt{00000}$，可以依次进行操作 $3,2$，得到最优的 $S'$：

$$\texttt{00000}\to \texttt{00010}\to \texttt{01110}$$

对于第二个询问串 $\texttt{10010}$，可以依次进行操作 $1,3$，得到最优的 $S'$：

$$\texttt{10010}\to \texttt{11001}\to \texttt{11010}$$

对于第三个询问串 $\texttt{00101}$，可以依次进行操作 $3,2$，得到最优的 $S'$：

$$\texttt{00101}\to \texttt{00010}\to \texttt{01110}$$

---

**【数据范围】**

对于全部数据：$1\leq m\leq 22$，$1\leq n,q\leq 10^5$，$T$ 仅包含 $\texttt{0,1,-}$ 三种字符，$S$ 仅包含 $\texttt{0,1}$ 两种字符。

|     子任务编号     | $m\leq$ | $n\leq$ | $q\leq$ |         特殊性质          | 分值 |
| :----------------: | :-----: | :-----: | :-----: | :-----------------------: | :--: |
| $\text{Subtask 1}$ |  $10$   | $1000$  |   $1$   |            无             | $10$ |
| $\text{Subtask 2}$ |  $10$   | $1000$  | $1000$  |            无             | $20$ |
| $\text{Subtask 3}$ |  $20$   | $10^5$  | $10^5$  | $T$ 中没有 $\texttt{-}$ | $10$ |
| $\text{Subtask 4}$ |  $18$   | $10000$ |   $10$   |            无             | $18$ |
| $\text{Subtask 5}$ |  $20$   | $10^5$  |   $10$   |            无             | $18$ |
| $\text{Subtask 6}$ |  $22$   | $10^5$  | $10^5$  |            无             | $24$ |

---

![](https://cdn.luogu.com.cn/upload/image_hosting/793whkzq.png)


---

---
title: "[ICPC 2021 WF] Dungeon Crawler"
layout: "post"
diff: 省选/NOI-
pid: P9440
tag: ['2021', 'ICPC']
---
# [ICPC 2021 WF] Dungeon Crawler
## 题目描述

Alice and Bob are in charge of testing a new escape room! In this escape room, customers are trapped in a dungeon and have to explore the entire area. The dungeon consists of $n$ rooms connected by exactly $n-1$ corridors. It is possible to travel between any pair of rooms using these corridors.

Two of the dungeon rooms are special. One of these rooms contains a protective idol known as the "helix key´´. A different room contains a nasty "dome trap´´, which prevents the player from moving once activated. Entering the room with the trap before acquiring the key will result in the player being trapped in the dungeon forever. The player cannot start in the same room as the key or the trap.

There are $q$ different scenarios that Alice and Bob wish to examine. In the $i^{th}$ scenario, the player starts in room $s_i$, the key is in room $k_i$, and the trap is in room $t_i$. For each scenario, compute the minimum amount of time needed to explore the entire dungeon without getting trapped.
## 输入格式

The first line of input contains two integers $n$ and $q$, where $n$ ($3 \leq n \leq 2000$) is the number of rooms and $q$ ($1 \leq q \leq 200000$) is the number of scenarios to consider. Rooms are numbered from $1$ to $n$. The next $n-1$ lines each contain three integers $u$, $v$, and $w$ indicating that there is a corridor between rooms $u$ and $v$ ($1 \leq u, v \leq n, u \neq v$) that takes time $w$ ($1 \leq w \leq 10^9$) to traverse.

Then follow $q$ lines: the $i^{th}$ of these lines contains three distinct integers $s_i$, $k_i$, and $t_i$ ($1 \leq s_i, k_i, t_i \leq n$) indicating the room where the player starts, the room with the key, and the room with the trap, respectively.
## 输出格式

For each scenario, output the minimum amount of time needed to visit every room at least once. If it is impossible to visit every room at least once, output $\texttt{impossible}$.
## 样例

### 样例输入 #1
```
5 4
1 2 3
1 3 1
3 4 4
3 5 2
1 2 4
1 4 2
5 2 1
4 3 1

```
### 样例输出 #1
```
15
17
impossible
12

```
### 样例输入 #2
```
7 4
1 2 1
1 3 1
1 4 1
1 5 1
1 6 1
1 7 1
1 2 3
5 4 1
3 1 4
2 4 5

```
### 样例输出 #2
```
11
impossible
10
10

```
## 题目翻译

### 题目描述
有一棵 $n$ 个结点的树，边带权。你可以从一个结点通过边移动到一个相邻的结点，花费等同于边权的时间。

其中，有两个特殊结点，一个结点里有钥匙，一个结点里有陷阱。你只有先获得钥匙，才能进入陷阱所在的结点。

现有 $q$ 组询问，在第 $i$ 组询问中，你要从第 $s_i$ 号结点出发，钥匙在第 $k_i$ 号结点，陷阱在第 $t_i$ 号结点。你需要对于每组询问回答遍历整棵树所需的最短时间。题目保证你不会在钥匙所在的结点或者陷阱所在的结点出发。如果不可能遍历整棵树，输出 `impossible`。


### 输入格式
第一行两个整数 $n,q$，含义如题目所述。

接下来 $n-1$ 行，每行三个整数 $u,v,w$，表示有一条连接结点 $u,v$，权值为 $w$ 的边。

接下来 $q$ 行，每行三个整数 $s_i,k_i,t_i$，含义如题目所述。

$3\le n\le 2000$，$1\le q \le 2\times10^5$，$1\le u,v\le n,u\ne v$，$1\le w\le 10^9$，$1\le s_i,k_i,t_i\le n$。

### 输出格式
对于每组询问，输出一行，包含一个整数表示答案，或者输出 `impossible` 表示无解。


---

---
title: "[ICPC 2021 WF] Hand of the Free Marked"
layout: "post"
diff: 省选/NOI-
pid: P9443
tag: ['2021', 'Special Judge', 'ICPC']
---
# [ICPC 2021 WF] Hand of the Free Marked
## 题目描述

![](https://cdn.luogu.com.cn/upload/image_hosting/kdojyok4.png)

Example placement of cards for $k = 5$

There is a fairly well-known mentalism trick known as the Fitch Cheney trick. From a deck of $n$ playing cards, $k$ are selected uniformly at random and given to an assistant while the magician is out of the room. The assistant places $k-1$ of the selected cards on a table, face up, and the single remaining card face down. The cards are placed in a single row with the face-down card at the end (see the picture for an example). The magician enters the room, looks at the cards on the table, and announces what the $k^{th}$ card is, although its face is hidden. The trick is typically done with $n=52$ and $k=5$.

The assistant uses two ways of passing information to the magician. First, they can pick which one of the $k$ cards to keep hidden. Second, they can rearrange the other $k-1$ cards in a specific way. For the case $n=52$ and $k=5$ both techniques are needed, since there are only $24$ ways of rearranging four cards, which is not enough to reliably signal the fifth card. It is an interesting exercise to come up with a simple, easy-to-remember strategy for executing this trick, but right now you have another concern.

You were planning to perform this trick today, but just now you have learned that the deck has more cards than you expected. The trick may be impossible! In desperation, you have decided to cheat a little. You have $m$ distinguishable ways of marking the backs of the playing cards. You have marked the backs of all $n$ cards, allowing you to narrow down the possibilities for the $k^{th}$ card. For example, if there are $6$ cards marked with a particular method, and you see that the back of the $k^{th}$ card is marked with that method, you know it must be one of those $6$ cards.

Determine the probability that you will successfully guess the $k^{th}$ card, assuming you and the assistant execute an optimal (but likely very complicated!) strategy.
## 输入格式

The input contains one line with several integers. The first integer gives $k$ ($2 \leq k \leq 10$), the number of cards that will be selected. The second integer gives $m$ ($1 \leq m \leq 10$), the number of ways of marking the cards. The line is completed by $m$ positive integers, giving the number of cards marked with each distinct method. The sum of these $m$ integers is $n$ ($k \leq n \leq 10^9$), which is the size of the deck.
## 输出格式

Output the highest possible probability of guessing the $k^{th}$ card correctly, accurate up to an absolute error of $10^{-9}$.
## 样例

### 样例输入 #1
```
4 1 28

```
### 样例输出 #1
```
0.960000000000

```
### 样例输入 #2
```
3 3 5 12 3

```
### 样例输出 #2
```
0.854385964912

```
## 题目翻译

#### 简要题意
两个人 $A, B$ 玩一个游戏。规则如下 :

$A$ 有 $n$ 张互不相同的牌. 它们的**背面**有 $m$ 种不同的样式, 第 $i$ 种牌有 $a_i$ 张. 二人都对这套牌非常了解. 保证 $\sum\limits^{m}_{i=1}{a_i} = n$.

$B$ 在 $A$ 不在场的情况下从中随机抽出 $k$ 张, 然后选择一张牌倒置在桌面上. 然后 $B$ 可以以任意顺序重新排列其他牌并在桌面上依次排开, 并将倒置的牌放在序列的末尾. $A$ 和 $B$ 可以在游戏之前约定通过其他牌的排列顺序传递的信息.

随后 $A$ 需要根据桌面上牌的排列和倒置牌的背面说出倒置的牌具体是哪一张. 双方的目标都是使 $A$ 说出正确的牌。

现在给定 $m, a_i$ 和 $k$, 求二人均采取最佳策略的情况下, $A$ 的成功率是多少.

#### 输入格式
输入仅一行, 首先是两个整数 $k, m$, 然后是 $m$ 个整数 $a_i$.

#### 输出格式
一行, 一个实数, 表示答案. 答案与标准答案的差不超过 $10^{-9}$ 即判为正确.


---

---
title: "[ICPC 2021 WF] Islands from the Sky"
layout: "post"
diff: 省选/NOI-
pid: P9444
tag: ['2021', 'Special Judge', 'ICPC']
---
# [ICPC 2021 WF] Islands from the Sky
## 题目描述

You might never have heard of the island group of Iceepeecee, but that suits their inhabitants just fine. Located in a remote part of the South Pacific, they are truly off the beaten track, without any regular air or sea traffic, and they have remained a tropical paradise with unspoiled local fauna and flora.

Being off the map is great when you don't want to be overrun by hordes of tourists, but not so ideal when you actually do need a map for some reason. One such reason came up recently: Iceepeecee's central government needs an exact map of the islands to apportion government funds. Even tropical paradises need money, so Iceepeecee needs a map!

The easiest way to create a map would be an aerial survey. After dismissing chartering planes as too expensive, building an air balloon as too dangerous, and fitting carrier pigeons with cameras as too cruel to animals, they had a brilliant idea. Even with its remote location, there are still plenty of commercial airplanes crossing the skies above Iceepeecee. What if one mounted cameras on flights that are already scheduled to fly anyway? That would be a cheap solution to the problem!

Iceepeecee's plan is to install line-scan cameras on the planes. These cameras point straight downwards and collect images one line segment at a time, orthogonal to the flight path. The photographed line segment will be determined by the altitude that the plane is flying at, and the camera's aperture angle $\theta$ (see Figure F.1). Greater angles $\theta$ mean that the camera can see more, but also that the camera is more expensive.

Moreover, Iceepeecee wants to make sure that each island is observed in its entirety by at least one flight. That means it is not sufficient that an island is only partially photographed by multiple flights, even if the combination of the photographs covers the whole island.

![](https://cdn.luogu.com.cn/upload/image_hosting/99wwtofi.png)

Figure F.1: A view of the plane, shown head-on. Its camera points downward and can see the part of the ground underneath the plane that is shown in green. How much is visible depends on the aperture angle $\theta$.
  
Flight paths follow straight line segments in three-dimensional space, that is, ($x_1, y_1, z_1$) $-$ ($x_2, y_2, z_2$) (see Figure F.2), where the $z$-coordinates give the altitude of the plane. Photographs are taken only along these line segments.

Given the location of their islands and flights, Iceepeecee wants to find the smallest aperture angle $\theta$ that allows for a successful survey. Can you help?

![](https://cdn.luogu.com.cn/upload/image_hosting/3pdn3q1b.png)

Figure F.2: Three islands (shown in black) and two flight paths (red and green). Altitudes are not shown. The shaded areas represent the ground visible on the two flight paths for an optimally chosen $\theta$. This corresponds to the first sample input.Three islands (shown in black) and two flight paths (red and green). Altitudes are not shown. The shaded areas represent the ground visible on the two flight paths for an optimally chosen $\theta$. This corresponds to the first sample input.
## 输入格式

The input describes a set of islands and flight paths. It starts with a line containing two integers $n$ and $m$, the number $n$ of islands, and the number $m$ of flight paths, respectively ($1 \leq n,m \leq 100$). This is followed by descriptions of the $n$ islands. Each island description starts with a line containing a single integer $n_i$, the number of vertices of the polygon describing the $i^{th}$ island ($3 \leq n_i \leq 100$). It is followed by $n_i$ lines, each containing two integers $x_{ij}$, $y_{ij}$ ($|x_{ij}|, |y_{ij}| \leq 10^6$), specifying the vertices for the $i^{th}$ island in counterclockwise order. Each island's polygon is simple, that is, its vertices are distinct and no two edges of the polygon intersect or touch, other than consecutive edges which touch at their common vertex. Different islands do not intersect or touch.

The input concludes with another $m$ lines, each describing a flight path. Each such line contains six integers $x_1$, $y_1$, $z_1$, $x_2$, $y_2$, $z_2$ ($|x_i|, |y_i|, |z_i| \leq 10^6$, $z_i &gt; 0$ and ($x_1, y_1$) $\neq$ ($x_2, y_2$)). They specify that a flight takes place from ($x_1, y_1, z_1$) to ($x_2, y_2, z_2$).
## 输出格式

Output the smallest angle $\theta$ (in degrees) that allows for a complete survey of the islands with the given flights. The answer should be exact to an absolute or relative error of $10^{-6}$. If there is no such angle, then output $\texttt{impossible}$. The input is chosen such that if the coordinates of the island vertices are changed by at most $\pm 10^{-8}$, then the answer will not change more than the allowed rounding error.
## 样例

### 样例输入 #1
```
3 2
3
20 30
50 50
10 50
4
40 20
60 10
75 20
60 30
4
45 60
55 55
60 60
55 65
0 30 20 78 70 5
55 0 20 70 60 10

```
### 样例输出 #1
```
48.031693036

```
### 样例输入 #2
```
1 1
4
0 0
10 0
10 10
0 10
5 5 10 15 5 10

```
### 样例输出 #2
```
impossible

```
## 题目翻译

有一个空间直角坐标系 $O-xyz$，在坐标平面 $xOy$ 上有 $n$ 个岛，每个岛是一个简单多边形。保证岛屿之间不重叠。

坐标系中有 $m$ 条飞机航线，航线是一条线段，两个端点的坐标分别是 $(x_1,y_1,z_1)$ 和 $(x_2,y_2,z_2)$。飞机可以沿任意一条飞机航线飞行。

现在要在飞机上装扫描相机。扫描相机的能扫描的范围取决于角度 $\theta$。

飞机位于一点 $(x,y,z)$ 时，我们可以以 $(x,y,z)$ 为顶点做一个顶角为 $2\theta$ 的等腰三角形，这个等腰三角形所在的面和坐标平面 $xOy$ 垂直，同时也和这架飞机所在的飞机航线到坐标平面 $xOy$的投影垂直。
将飞机位于 $(x,y,z)$ 时，能扫描到的线段定义为这个等腰三角形的底边。

对于一条航线，其覆盖的范围定义为当飞机在这条航线上运动时，所有能扫描到的线段组成的四边形。

求最小的 $\theta$（角度制），使得每个岛都至少完全位于一条航线的覆盖范围内。如果无论 $\theta$ 取何值都不能满足条件，输出 `impossible`。

$1\le n,m\le 100$，多边形的边数不超过 $100$，所有给出的坐标绝对值不超过 $10^6$。


---

---
title: "[ICPC 2021 WF] Mosaic Browsing"
layout: "post"
diff: 省选/NOI-
pid: P9445
tag: ['2021', 'ICPC']
---
# [ICPC 2021 WF] Mosaic Browsing
## 题目描述

The International Center for the Preservation of Ceramics (ICPC) is searching for motifs in some ancient mosaics. According to the ICPC's definition, a $\textit{mosaic}$ is a rectangular grid where each grid square contains a colored tile. A $\textit{motif}$ is similar to a mosaic but some of the grid squares can be empty. Figure G.1 shows an example motif and mosaic.

The rows of an $r_q \times c_q$ mosaic are numbered $1$ to $r_q$ from top to bottom, and the columns are numbered $1$ to $c_q$ from left to right.

A contiguous rectangular subgrid of the mosaic matches the motif if every tile of the motif matches the color of the corresponding tile of the subgrid. Formally, an $r_p \times c_p$ motif appears in an $r_q \times c_q$ mosaic at position ($r$, $c$) if for all $1 \leq i \leq r_p$, $1 \leq j \leq c_p$, the tile ($r+i-1$, $c+j-1$) exists in the mosaic and either the square ($i$, $j$) in the motif is empty or the tile at ($i$, $j$) in the motif has the same color as the tile at ($r+i-1$, $c+j-1$) in the mosaic.

Given the full motif and mosaic, find all occurrences of the motif in the mosaic.

![](https://cdn.luogu.com.cn/upload/image_hosting/0n7urywk.png)

Figure G.1: Motif (left) and mosaic (right) of Sample Input 1.
## 输入格式

The first line of input contains two integers $r_p$ and $c_p$, where $r_p$ and $c_p$ ($1 \leq r_p, c_p \leq 1000$) are the number of rows and columns in the motif. Then $r_p$ lines follow, each with $c_p$ integers in the range $[0, 100]$, denoting the color of the motif at that position. A value of $0$ denotes an empty square.

The next line of input contains two integers $r_q$ and $c_q$ where $r_q$ and $c_q$ ($1 \leq r_q, c_q \leq 1000$) are the number of rows and columns in the mosaic. Then $r_q$ lines follow, each with $c_q$ integers in the range $[1, 100]$, denoting the color of the mosaic at that position.
## 输出格式

On the first line, output $k$, the total number of matches. Then output $k$ lines, each of the form $r c$ where $r$ is the row and $c$ is the column of the top left tile of the match. Sort matches by increasing $r$, breaking ties by increasing $c$.
## 样例

### 样例输入 #1
```
2 2
1 0
0 1
3 4
1 2 1 2
2 1 1 1
2 2 1 3

```
### 样例输出 #1
```
3
1 1
1 3
2 2

```
## 题目翻译

#### 简要题意
给出两个矩阵, 其中第二个矩阵所有元素非 $0$.

定义第一个矩阵在第二个矩阵中的坐标 $(l, r)$ 处「出现」, 当且仅当存在一种方式任意修改第一个矩阵所有为 $0$ 的元素后, 第一个矩阵的左上角在第二个矩阵的对应位置坐标为 $(l, r)$ 时可以与第二个矩阵的一部分完全重合.

求第一个矩阵在第二个矩阵中所有「出现」的位置和总「出现」次数。

#### 输入格式
第一行, 两个整数 $r_p, c_p$, 表示第一个矩阵的行数和列数.

接下来 $r_p$ 行, 每行 $c_p$ 个整数, 描述第一个矩阵.

接下来一行, 两个整数 $r_q, c_q$, 表示第二个矩阵的行数和列数.

接下来 $r_q$ 行，每行 $c_q$ 个整数, 描述第二个矩阵.

#### 输出格式
第一行, 一个整数 $k$, 表示「出现」的总次数.

接下来 $k$ 行, 每行两个整数 $x, y$, 表示每一次「出现」的坐标. 如果有多个, 请以 $x$ 为第一关键字, $y$ 为第二关键字升序排序后输出。


---

---
title: "[ICPC 2021 WF] Spider Walk"
layout: "post"
diff: 省选/NOI-
pid: P9447
tag: ['2021', 'ICPC']
---
# [ICPC 2021 WF] Spider Walk
## 题目描述

Charlotte the spider sits at the center of her spiderweb, which consists of a series of silken straight strands that go from the center to the outer boundary of the web. Charlotte's web also has bridges, each of which connects two adjacent strands. The two endpoints of a bridge always have the same distance to the center of the spiderweb.

When Charlotte has finished a late-night feasting in the center and wants to retreat to some corner, she walks to the edge on autopilot. To do this, she picks a starting strand, and walks along it until she meets the first bridge on that strand. She will cross the bridge and go to the other strand, and then keeps walking outwards until she meets another bridge. Then she will cross that bridge, and repeat this process, until there are no more bridges on the current strand, and then she will walk to the end of the current strand. Note that Charlotte must cross all the bridges that she meets. Figure I.1 illustrates one path Charlotte could take.

Charlotte's favorite corner to sleep in during the daytime is at the end of strand $s$. For each possible starting strand, she wants to know the minimum number of bridges to add to the original web in order to end at $s$. Charlotte can add a bridge at any point along the strand, as long as the added bridge does not touch any other bridge. The two endpoints of any added bridge must have the same distance to the center of the spiderweb, and the bridge must connect two adjacent strands.

![](https://cdn.luogu.com.cn/upload/image_hosting/7nb4cy7c.png)

Figure I.1: The path starting from strand 4 on the spiderweb in Sample Input 1.
## 输入格式

The first line of input has three integers $n$, $m$, and $s$, where $n$ ($3 \leq n \leq 200000$) is the number of strands, m ($0 \leq m \leq 500000$) is the number of bridges, and $s$ ($1 \leq s \leq n$) is Charlotte's favorite strand. Strands are labeled from $1$ to $n$ in counterclockwise order. Each of the remaining $m$ lines contains two integers $d$ and $t$ describing a bridge, where $d$ ($1 \leq d \leq 10^9$) is the bridge's distance from the center of the spiderweb and $t$ ($1 \leq t \leq n$) is the first strand of the bridge in counterclockwise order. Specifically, if $1 \leq t &lt; n$, then the bridge connects strands $t$ and $t+1$. If $t = n$, then the bridge connects strands $1$ and $n$. All bridge distances $d$ are distinct.
## 输出格式

Output $n$ lines, where the $i^{th}$ line is the minimum number of bridges Charlotte needs to add in order to end at strand $s$ after walking on autopilot from strand $i$.
## 样例

### 样例输入 #1
```
7 5 6
2 1
4 3
6 3
8 7
10 5

```
### 样例输出 #1
```
2
1
1
1
0
1
2

```
### 样例输入 #2
```
4 4 2
1 1
2 2
3 3
4 4

```
### 样例输出 #2
```
1
1
0
1

```
## 题目翻译

有一个蜘蛛网，蜘蛛网包含一个中心点，从中心点放射出的 $n$ 条射线，按逆时针方向从 $1$ 到 $n$ 编号，以及 $m$ 条线段，称为“桥”，每条“桥”连接相邻的两条射线。每一条“桥”都和其连接的两条射线构成以中心点为顶点的等腰三角形。

现有一只蜘蛛从某一条射线的无穷远方向出发向中心点移动。如果在路上遇到了“桥” 的一个端点，蜘蛛会沿桥前往另一个端点到达另一条射线，然后继续往中心点移动。

现在蜘蛛会从 $1-n$ 号的每一条射线出发，并且希望最终经由 $s$ 号射线到达中心点。为了这一目的，可以在任两条射线之间的任意位置添加若干个“桥”。你需要对于 $1-n$ 的每一个出发位置计算最少添加“桥”的数量。注意各个询问之间是独立的，在一个询问中添加的“桥”不会对后续询问造成影响。

$3\le n\le200000$，$0\le n\le 500000$，$1\le s\le n$。


---

---
title: "[NOI2023] 方格染色"
layout: "post"
diff: 省选/NOI-
pid: P9478
tag: ['2023', 'NOI', 'O2优化']
---
# [NOI2023] 方格染色
## 题目描述

有一个 $n$ 列 $m$ 行的棋盘，共 $n \times m$ 个方格，我们约定行、列均从 $1$ 开始标号，且第 $i$ 列、第 $j$ 行的方格坐标记为 $(i, j)$。初始时，所有方格的颜色均为白色。现在，你要对这个棋盘进行 $q$ 次染色操作。

染色操作分为三种，分别为：

1. 将一条横线染为黑色。具体地说，给定两个方格 $(x_1, y_1)$ 和 $(x_2, y_2)$，保证 $x_1 \le x_2$，$y_1 = y_2$，将这两个方格之间的所有方格（包括这两个方格）染为黑色。
2. 将一条竖线染为黑色。具体地说，给定两个方格 $(x_1, y_1)$ 和 $(x_2, y_2)$，保证 $x_1 = x_2$，$y_1 \le y_2$，将这两个方格之间的所有方格（包括这两个方格）染为黑色。
3. 将一条斜线染为黑色。具体地说，给定两个方格 $(x_1, y_1)$ 和 $(x_2, y_2)$，保证 $x_1 \le x_2$，$x_2 - x_1 = y_2 - y_1$，将这两个方格之间斜线上所有形如 $(x_1 + i, y_1 + i)$（$0 \le i \le x_2 - x_1$）的方格染为黑色。**这种染色操作发生的次数不超过 $5$ 次。**

现在你想知道，在经过 $q$ 次染色后，棋盘上有多少个黑色的方格。
## 输入格式

输入的第一行包含一个整数 $c$，表示测试点编号。$c = 0$ 表示该测试点为样例。

输入的第二行包含三个正整数 $n, m, q$，分别表示棋盘的列、行和染色操作的次数。

接下来 $q$ 行，每行输入五个正整数 $t, x_1, y_1, x_2, y_2$，其中 $t = 1$ 表示第一种染色操作，$t = 2$ 表示第二种染色操作，$t = 3$ 表示第三种染色操作。$x_1, y_1, x_2, y_2$ 表示染色操作的四个参数。
## 输出格式

输出一行包含一个整数，表示棋盘上被染为黑色的方格的数量。
## 样例

### 样例输入 #1
```
0
5 5 3
1 1 3 5 3
2 3 1 3 5
3 1 1 5 5

```
### 样例输出 #1
```
13

```
### 样例输入 #2
```
见附件中的 color/color2.in。
```
### 样例输出 #2
```
见附件中的 color/color2.ans。
```
### 样例输入 #3
```
见附件中的 color/color3.in。
```
### 样例输出 #3
```
见附件中的 color/color3.ans。
```
### 样例输入 #4
```
见附件中的 color/color4.in。
```
### 样例输出 #4
```
见附件中的 color/color4.ans。
```
### 样例输入 #5
```
见附件中的 color/color5.in。
```
### 样例输出 #5
```
见附件中的 color/color5.ans。
```
### 样例输入 #6
```
见附件中的 color/color6.in。
```
### 样例输出 #6
```
见附件中的 color/color6.ans。
```
### 样例输入 #7
```
见附件中的 color/color7.in。
```
### 样例输出 #7
```
见附件中的 color/color7.ans。
```
## 提示

**【样例解释 #1】**

在这组样例中，我们一共做了三次染色操作，如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/7ojo6cs1.png)

第一次操作时，将 $(1, 3), (2, 3), (3, 3), (4, 3), (5, 3)$ 染为黑色。

第二次操作时，将 $(3, 1), (3, 2), (3, 3), (3, 4), (3, 5)$ 染为黑色。

第三次操作时，将 $(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)$ 染为黑色。

**【样例解释 #2】**

这个样例满足测试点 $1 \sim 5$ 的条件限制。

**【样例解释 #3】**

这个样例满足测试点 $6 \sim 9$ 的条件限制。

**【样例解释 #4】**

这个样例满足测试点 $10 \sim 13$ 的条件限制。

**【样例解释 #5】**

这个样例满足测试点 $14 \sim 17$ 的条件限制。

**【样例解释 #6】**

这个样例满足测试点 $18 \sim 19$ 的条件限制。

**【样例解释 #7】**

这个样例满足测试点 $20$ 的条件限制。

**【数据范围】**

对于所有测试数据保证：$1 \le n, m \le 10 ^ 9$，$1 \le q \le 10 ^ 5$，$1 \le x_1, x_2 \le n$，$1 \le y_1, y_2 \le m$，**且最多有 $5$ 次第三种染色操作**。

|测试点编号|$n, m \le$|$q \le$|特殊性质|
|:-:|:-:|:-:|:-:|
|$1 \sim 5$|$300$|$300$|无|
|$6 \sim 9$|$10 ^ 5$|$2,000$|无|
|$10 \sim 13$|$10 ^ 5$|$10 ^ 5$|A|
|$14 \sim 17$|$10 ^ 5$|$10 ^ 5$|B|
|$18 \sim 19$|$10 ^ 5$|$10 ^ 5$|无|
|$20$|$10 ^ 9$|$10 ^ 5$|无|

特殊性质 A：保证只有第一种染色操作。

特殊性质 B：保证只有第一种和第二种染色操作。

Update on 2023-08-04: 更新一组 Hack 数据，该 Hack 数据的 $c = 0$。


---

---
title: "[NOI2023] 贸易"
layout: "post"
diff: 省选/NOI-
pid: P9481
tag: ['2023', 'NOI', 'O2优化']
---
# [NOI2023] 贸易
## 题目描述

近年来，A 国的商贸发展迅猛，但国内的道路建设却跟不上步伐，明显成为了人们贸易往来的限制，管理者为此费尽了心思。

具体而言，A 国共有 $2^n-1$ 个城市，其中 $1$ 号城市为首都。对于所有的非首都城市 $i$，都有一条**单向**道路从城市 $i$ 出发，到达城市 $\lfloor \frac{i}{2} \rfloor$。为方便起见，称这样的道路为“第一类道路”，称城市 $\lfloor \frac{i}{2} \rfloor$ 为城市 $i$ 的“上级城市”。

除此之外，还有 $m$ 条**单向**道路，设其中第 $i$ 条道路从城市 $u_i$ 出发，到达城市 $v_i$，这样的道路都有一个特殊性质：从城市 $v_i$ 出发，沿着第一类道路不断向“上级城市”走去，最终总能走到城市 $u_i$。称这样的道路为“第二类道路”。

每一条道路都有相应的长度值。由此，对于 A 国的任意两个城市 $x$ 和 $y$，都可以计算出从城市 $x$ 出发，沿道路走到城市 $y$，所经过的道路的长度之和的最小值，将这一数值记为 $dist(x,y)$。但由于 A 国的道路建设存在严重缺陷，从城市 $x$ 出发可能根本到达不了城市 $y$，此时定义 $dist(x,y)=0$。同时一个城市出发到自己是不需要经过任何道路的，因此定义 $dist(x,x)=0$。

现在管理者希望计算出这些 $dist(x,y)$ 的值，以便合理衡量人们贸易往来的便捷程度。但由于 A 国的城市数量太多，将这些值一一列出的工作量太大，因此管理者只希望求出所有 $dist(x,y)$ 值之和，也就是 $\sum_{x=1}^{2^n-1}{\sum_{y=1}^{2^n-1}{dist(x,y)}}$，并希望请你来帮忙。
## 输入格式

输入的第一行包含两个正整数 $n$ 和 $m$。

输入的第二行包含 $2^n-2$ 个正整数，第 $i$ 个数 $a_i$ 表示从城市 $i+1$ 出发, 到达城市 $\lfloor \frac{i+1}{2} \rfloor$ 的“第一类道路”的长度。

接下来的 $m$ 行，每行包含三个正整数 $u,v,w$，描述了一条从城市 $u$ 到城市 $v$ 的“第二类道路”, 其长度为 $w$。 
## 输出格式

输出一行一个正整数，表示对应的答案。由于答案可能很大, 你只需要输出模 $998244353$ 意义下的答案即可。
## 样例

### 样例输入 #1
```
2 1
2 1
1 2 2
```
### 样例输出 #1
```
8
```
### 样例输入 #2
```
见附件中的 trade/trade2.in。
```
### 样例输出 #2
```
见附件中的 trade/trade2.ans。
```
### 样例输入 #3
```
见附件中的 trade/trade3.in。
```
### 样例输出 #3
```
见附件中的 trade/trade3.ans。
```
### 样例输入 #4
```
见附件中的 trade/trade4.in。
```
### 样例输出 #4
```
见附件中的 trade/trade4.ans。
```
## 提示

**【数据范围】**

对于所有测试数据保证：$2 \le n \le 18$，$1 \le m \le 2 ^ n$，$1 \le u, v \le 2 ^ n - 1$，$1 \le a_i, w \le 10 ^ 9$。

| 测试点编号 | $n$ | $m$ | 是否有特殊性质 |
| :---: | :---: | :---: | :---: |
| $1\sim 2$ | $=8$ | $\le 256$ | 否 |
| $3\sim 4$ | $=9$ | $\le 512$ | 否 |
| $5\sim 8$ | $=12$ | $\le 4,096$ | 否 |
| $9$ | $=16$ | $\le 10$ |  否|
| $10$ | $=16$ | $\le 50$ | 否 |
| $11$ | $=16$ | $\le 100$ | 否 |
| $12$ | $=16$ | $\le 65,536$ | 是 |
| $13\sim 15$ | $=16$ | $\le 65,536$ | 否 |
| $16\sim 17$ | $=18$ | $\le 262,144$ | 是 |
| $18\sim 20$ | $=18$ | $\le 262,144$ | 否 |

特殊性质：保证每一条“第二类道路”都是从首都（城市 $1$）出发。


---

---
title: "[NOI2023] 字符串"
layout: "post"
diff: 省选/NOI-
pid: P9482
tag: ['2023', 'NOI', 'O2优化']
---
# [NOI2023] 字符串
## 题目描述

小 Y 是一名大学生，最近正在研究字符串方向的问题。

小 Y 了解到关于字符串的如下定义:

- 给定一个长度为 $n$ 的字符串 $s[1: n]$，我们定义其子串 $s[l: r]$（$1 \leq l \leq r \leq n$）为选择 $s[l], s[l+1], \dots, s[r]$, 将其顺次拼接得到的新字符串。
- 给定一个长度为 $n$ 的字符串 $s[1: n]$，我们定义其翻转后的结果 $R(s)$ 为将 $s[n], s[n-1], \dots, s[1]$ 顺次拼接，也就是将字符串反序拼接得到的字符串。
- 给定两个长度均为 $n$ 的字符串 $a[1: n], b[1: n]$，我们定义 $a$ 的字典序小于 $b$ 当且仅当存在 $1 \leq i \leq n$，使得对于任意 $1 \leq j < i$，$a[j] = b[j]$，且 $a[i] < b[i]$。

在了解了上述定义后，小 Y 想到了这样的问题:

给定一个长度为 $n$ 的字符串 $s[1: n]$。有 $q$ 次询问，每次询问给定两个参数 $i, r$。你需要求出有多少 $l$，满足如下条件:
- $1 \leq l \leq r$。
- $s[i: i+l-1]$ 字典序小于 $R(s[i+l: i+2l-1])$。

小 Y 想求助你帮忙解决这一问题。
## 输入格式

**本题有多组测试数据。**

输入的第一行包含两个整数 $c, t$，分别表示测试点编号和测试数据组数。$c=0$ 表示该测试点为样例。

接下来依次输入每组测试数据，对于每组测试数据：

输入的第一行包含两个正整数 $n, q$，表示字符串长度和询问次数。

输入的第二行包含一个长度为 $n$ 的仅包含小写字母的字符串 $s$。

输入的接下来 $q$ 行，每行包含两个正整数 $i, r$。表示一次询问，保证 $i+2r-1 \leq n$。
## 输出格式

对于每一组测试数据的每一次询问，输出一行一个整数，表示满足条件的 $l$ 的个数。
## 样例

### 样例输入 #1
```
0 2
9 3
abacababa
1 4
2 4
3 3
9 3
abaabaaba
1 4
2 4
3 3

```
### 样例输出 #1
```
4
0
3
2
0
2

```
### 样例输入 #2
```
见附件中的 string/string2.in。
```
### 样例输出 #2
```
见附件中的 string/string2.ans。
```
### 样例输入 #3
```
见附件中的 string/string3.in。
```
### 样例输出 #3
```
见附件中的 string/string3.ans。
```
### 样例输入 #4
```
见附件中的 string/string4.in。
```
### 样例输出 #4
```
见附件中的 string/string4.ans。
```
## 提示

**【样例解释 #1】**

对于第一组数据的第一组询问：
- $l = 1$ 时，$s[i: i + l - 1] = \texttt{a}$，$R(s[i + l: i + 2l - 1]) = \texttt{b}$。
- $l = 2$ 时，$s[i: i + l - 1] = \texttt{ab}$，$R(s[i + l: i + 2l - 1]) = \texttt{ca}$。
- $l = 3$ 时，$s[i: i + l - 1] = \texttt{aba}$，$R(s[i + l: i + 2l - 1]) = \texttt{bac}$。
- $l = 4$ 时，$s[i: i + l - 1] = \texttt{abac}$，$R(s[i + l: i + 2l - 1]) = \texttt{baba}$。

这四种情况中，$s[i: i + l - 1]$ 的字典序均小于 $R(s[i + l: i + 2l - 1])$。因此答案为 $4$。

**【样例解释 #2】**

该样例数据范围满足测试点 $5$。

**【样例解释 #4】**

该样例数据范围满足测试点 $24 \sim 25$。

**【数据范围】**

对于所有测试数据保证：$1 \le t \le 5$，$1 \le n \le 10 ^ 5$，$1 \le q \le 10 ^ 5$，$1 \le i + 2r - 1 \le n $，字符串 $s$ 仅包含小写字母。

|测试点编号|$n \le$|$q \le$|特殊性质|
|:-:|:-:|:-:|:-:|
|$1$|$5$|$5$|A|
|$2$|$10$|$10$|A|
|$3$|$20$|$20$|A|
|$4$|$50$|$50$|A|
|$5$|$10^2$|$10^2$|A|
|$6$|$10^3$|$10^3$|无|
|$7$|$2,000$|$2,000$|无|
|$8$|$3,000$|$3,000$|无|
|$9$|$4,000$|$4,000$|无|
|$10$|$23,333$|$23,333$|A|
|$11$|$5 \times 10 ^ 4$|$5 \times 10 ^ 4$|A|
|$12$|$75,000$|$75,000$|A|
|$13$|$9 \times 10 ^ 4$|$9 \times 10 ^ 4$|A|
|$14$|$10 ^ 5$|$10 ^ 5$|A|
|$15$|$23,333$|$23,333$|B|
|$16$|$75,000$|$75,000$|B|
|$17$|$9 \times 10 ^ 4$|$9 \times 10 ^ 4$|B|
|$18$|$10 ^ 5$|$10 ^ 5$|B|
|$19$|$23,333$|$23,333$|无|
|$20$|$5 \times 10 ^ 4$|$5 \times 10 ^ 4$|无|
|$21$|$75,000$|$75,000$|无|
|$22$|$9 \times 10 ^ 4$|$9 \times 10 ^ 4$|无|
|$23$|$95,000$|$95,000$|无|
|$24 \sim 25$|$10 ^ 5$|$10 ^ 5$|无|

特殊性质 A：保证字符串中仅包含字符 $\texttt{a}$ 和 $\texttt{b}$，且每个字符独立等概率地在 $\texttt{a}$ 和 $\texttt{b}$ 中选择。

特殊性质 B：保证字符串中的相邻字符互不相同。


---

---
title: "[JOI Open 2023] 花园"
layout: "post"
diff: 省选/NOI-
pid: P9514
tag: ['2023', 'O2优化', 'JOI（日本）']
---
# [JOI Open 2023] 花园
## 题目背景

**译自 [JOI Open 2023](https://contests.ioi-jp.org/open-2023/index.html) T3 「[庭園](https://s3-ap-northeast-1.amazonaws.com/data.cms.ioi-jp.org/open-2023/garden/2023-open-garden-statement.pdf) / [Garden](https://s3-ap-northeast-1.amazonaws.com/data.cms.ioi-jp.org/open-2023/garden/2023-open-garden-statement-en.pdf)」**
## 题目描述

JOI 王国是一个神秘的王国，疆域辽阔无边。JOI 君是 JOI 国国王，他在计划分割疆域的一部分来建造他的花园。

JOI 网络可以考虑成一个充分大的二维网格，网格由从上到下和从左到右的正方形单元格密铺而成。有一个单元格是坐标原点。令 $(x,y)$ 表示表示从原点向右移动 $x$ 个单元格，再向上移动 $y$ 个单元格所到达的单元格。这里，向左移动 $a$ 个单元格意味着向右移动 $-a$ 个单元格。类似地，向下移动 $a$ 个单元格意味着向上移动 $-a$ 个单元格。

在领土内有一些艺术品。这些艺术品根据放置在领土上的方式分为 **A 类**和 **B 类**。

- 有 $N$ 种 A 类艺术品。第 $i$ 种艺术品（$1\le i\le N$）放在每个形如 $(P_i+kD,Q_i+lD)$ 的单元格上，其中 $k,l$ 为整数。
- 有 $M$ 种 B 类艺术品。第 $j$ 种艺术品（$1\le j\le M$）放在每个形如 $(R_j+kD,y)$（其中 $k,y$ 为整数）或 $(x,S_j+lD)$（其中 $l,x$ 为整数）的单元格上。

注意一个单元格中可能包含多种不同类别的艺术品。

JOI 君计划在网格中选择一个矩形区域建造花园。换句话说，他会选择四个整数 $a,b,c,d$。然后形如 $(x,y)$ 的单元格将构成 JOI 君的花园，其中 $x,y$ 是满足 $a\le x\le b,c\le y\le d$ 的整数。因为 JOI 君喜欢看到多种艺术品，对于任意 $N+M$ 种艺术品中的一种，JOI 君的花园中需要至少包含这种艺术品中的一个。另一方面，如果 JOI 君计划要建的花园过大，JOI 国的居民就会生气。因此，JOI 君希望最小化花园包含的单元格数使得满足上述条件。

给定艺术品的信息，写一个程序计算 JOI 君的花园所包含的最小单元格数。
## 输入格式

第一行三个整数 $N,M,D$。

接下来 $N$ 行，每行两个整数 $P_i,Q_i$。

接下来 $M$ 行，每行两个整数 $R_j,S_j$。
## 输出格式

输出一行一个整数，表示 JOI 君的花园所包含的最小单元格数。
## 样例

### 样例输入 #1
```
2 1 5
1 4
2 2
0 0

```
### 样例输出 #1
```
8

```
### 样例输入 #2
```
3 4 100
20 26
81 56
20 3
58 71
74 82
95 61
95 61

```
### 样例输出 #2
```
2840

```
### 样例输入 #3
```
5 7 5000
1046 365
4122 1166
4009 2896
1815 4065
4372 1651
2382 123
1475 836
3313 4005
2579 568
4300 4867
1050 3214
3589 4653

```
### 样例输出 #3
```
10543092

```
## 提示

**【样例解释 #1】**

下图展示了 JOI 国领土中的满足 $0\le x<10,0\le y<10$ 的单元格 $(x,y)$。

![](https://cdn.luogu.com.cn/upload/image_hosting/pnsc7qm4.png)

在本图中，圆形和菱形分别表示 A 类和 B 类艺术品。圆形或菱形中的整数表示艺术品的种数。如果 JOI 君选择 $a=1,b=2,c=2,d=5$，JOI 君的花园就是黑色矩形区域。这种情况下，对于这三种艺术品，JOI 君的花园中至少会有每种中的一个。花园所占单元格数为 $8$。因为没有比这个花园占地更小且满足条件的花园了，因此输出 $8$。

这组样例满足所有子任务的限制。

**【样例解释 #2】**

这组样例满足子任务 $1,4,5,6$ 的限制。

**【样例解释 #3】**

这组样例满足子任务 $1,5,6$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $N,M\ge 1$
- $N+M\le 5\times 10^5$
- $1\le D\le 5\ 000$
- $0\le P_i,Q_i,R_j,S_j<D$

详细子任务附加限制及分值如下表所示。

| 子任务 |        附加限制        | 分值 |
| :----: | :--------------------: | :--: |
|  $1$   |        $M\le 8$        | $15$ |
|  $2$   | $D\le 10,N+M\le 5000$  | $6$  |
|  $3$   | $D\le 50,N+M\le 5000$  | $8$  |
|  $4$   | $D\le 100,N+M\le 5000$ | $16$ |
|  $5$   |     $N+M\le 5000$      | $30$ |
|  $6$   |       无附加限制       | $25$ |


---

---
title: "[JOISC 2022] 监狱"
layout: "post"
diff: 省选/NOI-
pid: P9520
tag: ['2022', 'O2优化', 'JOI（日本）']
---
# [JOISC 2022] 监狱
## 题目背景

JOISC2022 D1T1
## 题目描述

在 JOI 王国，安保最严格的地方就是 IOI 监狱。IOI 监狱中有 $N$ 个房间，以 $1,\dots,N$ 编号。其中有 $N-1$ 条通道。第 $i$ $(1\le i\le N-1)$ 条通道双向地连接房间 $A_i$ 和 $B_i$。任意两个房间都可以相互到达。

IOI 监狱中有 $M$ 个囚犯，以 $1,\dots,M$ 编号。第 $j$ $(1\le j\le M)$ 个囚犯的卧室和工作室分别是房间 $S_j,T_j$。一个囚犯可能在另一个囚犯的卧室工作。然而，每个房间最多成为一个囚犯的卧室，一个囚犯的工作室。

一天早上，这 $M$ 个囚犯需要从他们的卧室移动到他们的工作室。典狱长 APIO 先生需要按如下方式指示囚犯移动：  
- **指令**：选择一个囚犯，然后命令他从当前所在的房间移动到一个与该房间有直接连边的房间。为了避免囚犯交流，不允许将囚犯移动到有其他囚犯在的房间。

为了尽早开始工作，APIO 先生想知道，是否存在一种给出任意条指令的方案使得每个囚犯以**最短路径**从卧室到达工作室。

请编写一个程序，在给定如上房间、通道和罪犯的所有信息后判断是否存在满足条件的方案。
## 输入格式

每个测试数据包含多组测试用例。

第一行一个整数 $Q$，表示这个测试数据包含 $Q$ 组测试用例。

对于每组测试用例：

第一行一个整数 $N$，表示房间个数。

接下来 $N-1$ 行每行两个整数 $A_i,B_i$ 表示通道连接房间的编号。

接下来一行一个整数 $M$ 表示囚犯个数。

接下来 $M$ 行，每行两个整数 $S_i,T_i$ 表示囚犯的卧室和工作室。
## 输出格式

输出 $Q$ 行，第 $i$ 行表示对于第 $i$ 组测试用例，如果存在一种满足题意的方案，输出 `Yes`，否则输出 `No`。
## 样例

### 样例输入 #1
```
1
8
1 2
2 3
3 4
4 5
5 6
6 7
7 8
2
3 4
4 8
```
### 样例输出 #1
```
Yes
```
### 样例输入 #2
```
2
7
1 2
2 3
3 4
4 5
3 6
6 7
2
4 1
5 7
4
1 2
1 3
1 4
3
2 3
3 4
4 2
```
### 样例输出 #2
```
Yes
No
```
## 提示

**【样例解释 #1】**

可以通过发送如下指令完成任务：

1. 让囚犯 $2$ 从 $4$ 号房间移动到 $5$ 号房间。
2. 让囚犯 $1$ 从 $3$ 号房间移动到 $4$ 号房间。
3. 让囚犯 $2$ 从 $5$ 号房间移动到 $6$ 号房间。
4. 让囚犯 $2$ 从 $6$ 号房间移动到 $7$ 号房间。
5. 让囚犯 $2$ 从 $7$ 号房间移动到 $8$ 号房间。

这组样例满足所有子任务的限制。

**【样例解释 #2】**

这组样例满足子任务 $1,3,4,5,6,7$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $1\leq Q\leq 1000$。
- $1\leq N\leq 120000$。
- $1\leq A_i\lt B_i\leq N$ $(i\in [1,N-1])$。
- $2\leq M\leq N$。
- $1\leq S_i,T_i\leq N$ $(i\in [1,M])$。
- $S_i$ $(i\in[1,M])$ 互不相同。
- $T_i$ $(i\in[1,M])$ 互不相同。
- $S_j \ne T_j$ $(j\in [1, M])$。
- 任意两个房间之间可以通过给定道路互相到达。
- 对于所有测试用例，$N$ 的总和不超过 $120000$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$A_i=i,B_i=i+1~(i\in[1,N-1])$|$5$|
|$2$|$Q\leq 20, N\leq 250, M=2$|$5$|
|$3$|$Q\leq 20, N\leq 250, M\leq 6$|$16$|
|$4$|$Q\leq 20, N\leq 250, M\leq 100$|$28$|
|$5$|$Q\leq 20, M\leq 500$|$12$|
|$6$|任意两个房间之间都可以通过不超过 $20$ 条道路到达。|$11$|
|$7$|无附加限制|$23$|


---

---
title: "[JOISC 2022] 京都观光"
layout: "post"
diff: 省选/NOI-
pid: P9521
tag: ['2022', 'O2优化', 'JOI（日本）']
---
# [JOISC 2022] 京都观光
## 题目背景

JOISC2022 D1T2
## 题目描述

京都是世界级的观光圣地，它也被称为网格城市。你来到了京都观光，并且你计划步行游览一个著名的景点。本题中，我们考虑如下的简化问题。

在城市中，有 $H$ 条东西方向的街道和 $W$ 条南北方向的街道，因此城市是一个 $(H-1)\times(W-1)$ 的网格。从北数第 $i$ 条街道和从西数第 $j$ 条街道的交叉点记作路口 $(i,j)$。

不同的街道可能有不同的材质、宽度和拥挤程度，因此你的步行速度有可能不同。对于每条街道，你的步行速度如下：

- 如果你在从北数第 $i$ 条街道上行走单位长度，需要 $A_i$ 秒。即从路口 $(i,c)~\left(i\in[1,H],c\in[1,W)\right)$ 走到路口 $(i,c+1)$ 需要 $A_i$ 秒。

- 如果你在从西数第 $j$ 条街道上行走单位长度，需要 $B_j$ 秒。即从路口 $(c,j)~\left(c\in[1,H),j\in[1,W]\right)$ 走到路口 $(c+1,j)$ 需要 $B_j$ 秒。

你现在在路口 $(1,1)$，你想前往 $(H,W)$，你必须沿着街道行走，并且你不希望走远路，即你不会向北或向西走。

你希望尽早到达目的地，请你求出，在给定的条件下，从路口 $(1,1)$ 前往路口 $(H,W)$ 所需的最少时间。
## 输入格式

第一行两个整数 $H,W$ 表示街道条数。

第二行 $H$ 个整数，第 $i$ 个整数 $A_i$ 表示从北数第 $i$ 条东西方向街道的步行速度。

第三行 $W$ 个整数，第 $i$ 个整数 $B_i$ 表示从西数第 $i$ 条南北方向街道的步行速度。
## 输出格式

一行一个整数，表示所需的最小步行时间。
## 样例

### 样例输入 #1
```
2 2
1 3
2 5
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
5 5
7 1 5 2 8
7 2 4 1 6
```
### 样例输出 #2
```
20
```
### 样例输入 #3
```
4 6
454863204 543362989 866044086 813602010
71574269 17945210 688720933 392135202 38174709 168241720
```
### 样例输出 #3
```
2737473954
```
## 提示

**【样例解释 #1】**

有两条从 $(1,1)$ 到 $(2,2)$ 的路线：

1. $(1,1)\rightarrow(1,2)\rightarrow(2,2)$，所需时间为 $1+5=6$ 秒。
2. $(1,1)\rightarrow(2,1)\rightarrow(2,2)$，所需时间为 $2+3=5$ 秒。

因此最少花费时间为 $5$ 秒。

这个样例满足所有子任务的限制。

**【样例解释 #2】**

最优路线如下图：

![样例解释](https://cdn.luogu.com.cn/upload/image_hosting/mqsalajm.png)

这个样例满足所有子任务的限制。

**【样例解释 #3】**

这个样例满足子任务 $1,3$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $2\leq H,W\leq 100000$。
- $1\leq A_i\leq 10^9$ $(i\in[1,H])$。
- $1\leq B_i\leq 10^9$ $(i\in[1,W])$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$H,W\leq 1000$|$10$|
|$2$|$A_i\leq 1000, B_i\leq 1000$|$30$|
|$3$|无附加限制|$60$|


---

---
title: "[JOISC 2022] 错误拼写"
layout: "post"
diff: 省选/NOI-
pid: P9522
tag: ['2022', 'O2优化', 'JOI（日本）']
---
# [JOISC 2022] 错误拼写
## 题目背景

JOISC2022 D1T3
## 题目描述

从前，K 总统有着一个长度为 $N$ 的字符串 $S$，仅由小写字母组成。然而，他忘记了它。  
他还有一个词典，其中包含了各式各样的错误拼写。而他曾看过那本词典，现在他确认到 $S$ 满足以下条件：

- 令 $T_i$ $(1\le i\le N)$ 为 $S$ 删去第 $i$ 个字符并将前后字符相接所得的字符串。对于每个 $j$ $(1\le j\le M)$ 满足 $T_{A_j} \le T_{B_j}$。

其中 $T_{A_j} \le T_{B_j}$ 表示 $T_{A_j}$ 等于 $T_{B_j}$ 或 $T_{A_j}$ 在字典序上小于 $T_{B_j}$。

请写一个程序，对于 K 总统给定的如上关于 $S$ 的信息，输出可能的 $S$ 的个数，对 $10^9+7$ 取模。
## 输入格式

第一行，两个正整数 $N,M$，表示 $S$ 的长度与限制的个数。

以下 $M$ 行，其中第 $j$ $(1 \le j \le M)$ 行包含两个正整数 $A_j, B_j$，表示一条限制。
## 输出格式

一行一个非负整数，表示可能的 $S$ 的个数对 $10^9+7$ 取模的结果。
## 样例

### 样例输入 #1
```
3 2
1 3
3 2
```
### 样例输出 #1
```
5876
```
### 样例输入 #2
```
5 6
1 2
1 5
2 4
5 4
5 3
4 3
```
### 样例输出 #2
```
656981
```
### 样例输入 #3
```
10 9
3 6
4 6
6 7
7 9
10 8
9 8
8 5
5 2
5 1
```
### 样例输出 #3
```
206289833

```
### 样例输入 #4
```
7 6
1 3
3 4
4 6
6 5
5 7
7 2
```
### 样例输出 #4
```
7125651
```
### 样例输入 #5
```
5 4
2 4
4 3
3 5
5 1
```
### 样例输出 #5
```
61451
```
## 提示

**【样例解释 #1】**

举例说明，若 $S=\texttt{bab}$，则 $T_1 = \texttt{ab}, T_2 = \texttt{bb}, T_3 = \texttt{ba}$。其满足 $T_1 \le T_3$ 和 $T_3 \le T_2$。所以该 $S$ 是合法的。  
可以证明，总共有 $5876$ 种合法的 $S$。因此，输出 $5876$。

另一方面，若 $S=\texttt{aab}$，则 $T_1 = \texttt{ab}, T_2 = \texttt{ab}, T_3 = \texttt{aa}$。其不满足 $T_1 \le T_3$。所以该 $S$ 不合法。

该样例满足所有子任务的限制。

**【样例解释 #2】**

该样例满足子任务 $1,2,4,5$ 的限制。

**【样例解释 #3】**

取模前的结果为 $824\,206\,295\,601$，所以输出 $206\,289\,833$。

该样例满足子任务 $1,2,4,5$ 的限制。

**【样例解释 #4】**

该样例满足所有子任务的限制。

**【样例解释 #5】**

该样例满足所有子任务的限制。

**【数据范围】**

对于所有数据，满足：

- $2 \le N \le 500\,000$。  
- $1 \le M \le 500\,000$。
- $1 \le A_j,B_j \le N$ $(1 \le j \le M)$。
- $A_j\ne B_j$ $(1 \le j \le M)$。
- $(A_j,B_j)\ne(A_k,B_k)$ $(1 \le j < k \le M)$。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$N \le 10$|$8$|
|$2$|$N \le 200$|$20$|
|$3$|存在 $\{1,2,\dots,N\}$ 的排列 $P$ 满足 $A_j = P_j, B_j = P_{j+1}$ $(1 \le j \le M=N-1)$|$29$|
|$4$|$N \le 20\,000$|$32$|
|$5$|无附加限制|$11$|


---

---
title: "[JOISC 2022] 复制粘贴 3"
layout: "post"
diff: 省选/NOI-
pid: P9523
tag: ['2022', 'O2优化', 'JOI（日本）']
---
# [JOISC 2022] 复制粘贴 3
## 题目背景

JOISC2022 D2T1
## 题目描述

JOI 公司是一家以“没啥用发明”而闻名的公司。最近，JOI 公司开发了一款名为“没啥用编辑器”的编辑器。

在这个编辑器中，可以执行如下几种操作来输入某个字符串，设 $X$ 为屏幕上的字符串，$Y$ 为剪切板中的字符串，初始均为空串：

- 操作 A：输入字符 $c$，即将 $X$ 更新为 $X+c$。
- 操作 B：选择所有字符并剪切，即将 $Y$ 更新为 $X$，并将 $X$ 置为空串。
- 操作 C：将剪切板中的字符串粘贴到当前字符串末尾，即将 $X$ 更新为 $X+Y$。

对于字符串或字符 $x,y$，$x+y$ 表示将 $x$ 和 $y$ 顺次拼接得到的结果。使用一次操作 A,B,C 分别要花费 $A,B,C$ 单位时间。

你安装了“没啥用编辑器”，并想要尽可能快地输入一个长度为 $N$ 的字符串 $S$。

你需要计算出最少需要花费多少时间。
## 输入格式

第一行一个整数 $N$ 表示字符串长度。

第二行一个长度为 $N$ 的字符串 $S$ 表示要输入的字符串。

第三行一个整数 $A$ 表示操作 A 的代价。

第四行一个整数 $B$ 表示操作 B 的代价。

第五行一个整数 $C$ 表示操作 C 的代价。
## 输出格式

一行一个整数表示输入字符串 $S$ 最少要多少单位时间。
## 样例

### 样例输入 #1
```
11
mississippi
10
5
2
```
### 样例输出 #1
```
88
```
### 样例输入 #2
```
16
aaaaaaaaaaaaaaaa
1
1
1
```
### 样例输出 #2
```
9
```
### 样例输入 #3
```
18
aababbbababbbaabbb
1000000000
100000
10000000
```
### 样例输出 #3
```
8060200000
```
## 提示

**【样例解释 #1】**

以下是一组最优操作：

| 轮次 | 操作 | 解释 | $X$ | $Y$ | 代价 | 总时间 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| - | - | - | `""` | `""` | - | $0$ |
| $1$ | 操作 A | 输入字符 | `"s"` | `""` | $10$ | $10$ |
| $2$ | 操作 B | 全选并剪切 |` ""` | `"s"`| $5$ | $15$ |
| $3$ | 操作 C | 在尾部粘贴 | `"s"` | `"s"`| $2$ | $17$ |
| $4$ | 操作 C | 在尾部粘贴 | `"ss"` | `"s"`| $2$ | $19$ |
| $5$ | 操作 A | 输入字符 | `"ssi"` | `"s"`| $10$ | $29$ |
| $6$ | 操作 B | 全选并剪切 |` ""` | `"ssi"`| $5$ | $34$ |
| $7$ | 操作 A | 输入字符 | `"m"` | `"ssi"`| $10$ | $44$ |
| $8$ | 操作 A | 输入字符 | `"mi"` | `"ssi"`| $10$ | $54$ |
| $9$ | 操作 C | 在尾部粘贴 | `"missi"` | `"ssi"`| $2$ | $56$ |
| $10$ | 操作 C | 在尾部粘贴 | `"mississi"` | `"ssi"`| $2$ | $58$ |
| $11$ | 操作 A | 输入字符 | `"mississip"` | `"ssi"`| $10$ | $68$ |
| $12$ | 操作 A | 输入字符 | `"mississipp"` | `"ssi"`| $10$ | $78$ |
| $13$ | 操作 A | 输入字符 | `"mississippi"` | `"ssi"`| $10$ | $88$ |

这组样例满足子任务 $3,4,5,6$ 的限制。

**【样例解释 #2】**

一组最优策略如下：

| 轮次 | 操作 | 解释 | $X$ | $Y$ | 代价 | 总时间 |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| - | - | - | `""` | `""` | - | $0$ |
| $1$ | 操作 A | 输入字符 | ` "a"` | `""` | $1$ | $1$ |
| $2$ | 操作 A | 输入字符 | ` "aa"` | `""` | $1$ | $2$ |
| $3$ | 操作 A | 输入字符 | ` "aaa"` | `""` | $1$ | $3$ |
| $4$ | 操作 A | 输入字符 | ` "aaaa"` | `""` | $1$ | $4$ |
| $5$ | 操作 B | 全选并剪切 | `""` | `"aaaa"` | $1$ | $5$ |
| $6$ | 操作 C | 在尾部粘贴 | `"aaaa"` | `"aaaa"` | $1$ | $6$ |
| $7$ | 操作 C | 在尾部粘贴 | `"aaaaaaaa"` | `"aaaa"` | $1$ | $7$ |
| $8$ | 操作 C | 在尾部粘贴 | `"aaaaaaaaaaaa"` | `"aaaa"` | $1$ | $8$ |
| $9$ | 操作 C | 在尾部粘贴 | `"aaaaaaaaaaaaaaaa"` | `"aaaa"` | $1$ | $9$ |

这组样例满足子任务 $2,3,4,5,6$ 的限制。

**【样例解释 #3】**

这组样例满足子任务 $3,4,5,6$ 的限制。

**【数据范围】**

对于所有数据，满足：

- $1\leq N\leq 2500$
- $S$ 是一个长度为 $N$ 的小写字母串。
- $1\leq A,B,C\leq 10^9$

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分数|
|:-:|:-:|:-:|
|$1$|$N=3$|$1$|
|$2$|$S$ 只包含字符 $\texttt a$|$5$|
|$3$|$N\le 30$|$14$|
|$4$|$N\le 200$|$10$|
|$5$|$N \le 1000$|$32$|
|$6$|无附加限制|$38$|


---

---
title: "[JOISC 2022] 一流团子师傅"
layout: "post"
diff: 省选/NOI-
pid: P9529
tag: ['2022', '交互题', 'Special Judge', 'O2优化', 'JOI（日本）']
---
# [JOISC 2022] 一流团子师傅
## 题目背景

JOISC2022 D4T1

**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引用 `dango3.h`，而需要把 `dango3.h` 中的内容加入文件的开头。即，在程序中 `void Solve(int N, int M)` 的前面加入以下几行语句：**

```cpp
#include <vector>

void Solve(int N, int M);

int Query(const std::vector<int> &x);
void Answer(const std::vector<int> &a);
```
## 题目描述

JOI 君是一位专业的团子师傅。在 JOI 君的店里，团子的颜色很有讲究。一共有 $N$ 种颜色，编号为 $1,2,\dots,N$。

**一流团子串**是 JOI 君的店里的招牌食品。制作一个一流团子串，需要将 $N$ 个**颜色不同**的团子串在一根竹签上。

对于每一种颜色，JOI 君都制作了 $M$ 个这种颜色的团子。因此，JOI 君总共有了 $NM$ 个团子。这些团子被编号为 $1,2,\dots,NM$。使用这些团子和 $M$ 根竹签，JOI 君希望串出 $M$ 个一流团子串。

为了避免在颜色上犯错误，JOI 君将会启用他的团子检测器。如果 JOI 君输入一些团子的编号，团子检测器会返回使用这些团子能制作的一流团子串的个数的最大值。当然，前提是充分使用竹签。

JOI 君希望能通过使用若干次团子检测器将 $NM$ 个团子分为 $M$ 组。其中，每一组包含 $N$ 个团子，且每种颜色的团子恰有一个。

JOI 君想在使用不超过 $50\,000$ 次团子检测器的前提下完成这件事。

请写一个程序，对于给定的团子的信息，实现 JOI 君使用不超过 $50\,000$ 次团子检测器来完成任务的策略。

---

**【实现细节】**

你的程序需要实现以下函数。

  - `void Solve(int N, int M)`。  
    对于每组测试数据，该函数会被调用恰好一次。
      - 参数 $\texttt N$ 是团子的颜色数 $N$。
      - 参数 $\texttt M$ 是 JOI 君想制作的一流团子串的个数 $M$。

你的程序可以调用以下函数。

  - `int Query(const std::vector<int> &x)`。  
    你的程序可以通过调用这个函数来使用团子检测器。
      - 参数 `x` 是输入给团子检测器的团子的编号列表。
      - 该函数返回使用 `x` 中的团子能制作的一流团子串的最大值。
      - `x` 中的每个元素都应当是 $[1,NM]$ 中的整数。否则你的程序会被判定为 **Wrong Answer [1]**。
      - `x` 中的元素应当互不相同。否则你的程序会被判定为 **Wrong Answer [2]**。
      - 你的程序不得调用该函数超过 $50\,000$ 次。否则你的程序会被判定为 **Wrong Answer [3]**。

  - `void Answer(const std::vector<int> &a)`。  
    你的程序可以通过调用这个程序来报告分组方案。
      - 参数 `a` 是你分出的一组团子的编号列表。
      - `a` 的长度应当为 $N$。否则你的程序会被判定为 **Wrong Answer [4]**。
      - `a` 中的每个元素都应当是 $[1,NM]$ 中的整数。否则你的程序会被判定为 **Wrong Answer [5]**。
      - 在整个过程中，同一个团子不能出现在参数中多于一次。否则你的程序会被判定为 **Wrong Answer [6]**。
      - 如果用 `a` 中的团子并不能制作一个一流团子串，你的程序会被判定为 **Wrong Answer [7]**。
      - 该函数应当被调用恰好 $M$ 次。否则你的程序会被判定为 **Wrong Answer [8]**。
  
**【提示】**
  
  - 你的程序可以实现其他函数以供内部使用，或者使用全局变量。
  - 你的程序不得使用标准输入输出流，也不得以任何方式访问任何文件。然而，你可以输出调试信息到标准错误流。
  
**【编译与测试运行】**
  
你可以从「附加文件」中下载样例评分器来测试你的程序。「附加文件」中也提供了你应当提交的程序的一个样例。

样例评分器即 `grader.cpp`。为了测试你的程序，请将 `grader.cpp,dango3.cpp` 放置在同一个目录下，并执行如下命令来编译你的程序。

`g++ -std=gnu++17 -O2 -o grader grader.cpp dango3.cpp`

若编译成功，将会生成一个可执行文件 `grader`。

请注意，实际使用的评分器与下发的样例评分器不同。样例评分器仅会有单个进程，从标准输入中读取输入数据并将结果输出到标准输出。
  
**【样例评分器输入格式】**
  
第一行，两个正整数 $N,M$。表示团子的颜色数和 JOI 君想制作的一流团子串的个数。

第二行，$N\times M$ 个正整数 $C_1,C_2,\dots,C_{NM}$。其中 $C_i$ 是一个 $[1,N]$ 内的正整数，表示第 $i$ 个团子的颜色。
  
**【样例评分器输出格式】**
  
- 如果你的程序被判定为正确，样例评分器会输出调用 `Query` 的次数，如 “$\texttt{Accepted: 2022}$”。
- 如果你的程序被判定为任意一种 Wrong Answer，样例评分器会输出其类型，如 “$\texttt{Wrong Answer [4]}$”。

如果你的程序属于多种 Wrong Answer，样例评分器只会输出其中一种。
## 提示

**【样例交互】**

这里是样例评分器的一组样例输入和对应的交互过程。

```plain
3 2
3 3 1 2 1 2
```

|调用|调用|返回值|
|:-|:-|:-|
|$\texttt{Solve(3, 2)}$|||
||$\texttt{Query([])}$|$\texttt 0$|
||$\texttt{Query([4, 2, 1, 3])}$|$\texttt 1$|
||$\texttt{Query([3, 4, 5])}$|$\texttt 0$|
||$\texttt{Query([2, 6, 5])}$|$\texttt 1$|
||$\texttt{Query([6, 5, 4, 3, 2, 1])}$|$\texttt 2$|
||$\texttt{Answer([1, 6, 5])}$||
||$\texttt{Answer([2, 3, 4])}$||

注意，这组样例**不满足任意子任务的限制**。

从「附加文件」中可以下载到 $\texttt{sample-02.txt}$，其满足子任务 $1$ 的限制。

**【数据范围】**

对于所有测试数据，满足：

- $1 \le C_i \le N$ $(1 \le i \le NM)$。
- 对于每个 $j$ $(1 \le j \le N)$，恰有 $M$ 个 $i$ $(1 \le i \le NM)$ 满足 $C_i = j$。  
- $N,M$ 是正整数。
- $C_i$ $(1 \le i \le NM)$ 是一个 $[1,N]$ 内的整数。

详细子任务附加限制及分值如下表所示：

|子任务编号|附加限制|分值|
|:-:|:-:|:-:|
|$1$|$N=M=4$|$2$|
|$2$|$N=100$，$M=10$|$5$|
|$3$|$N=200$，$M=25$|$15$|
|$4$|$N=400$，$M=25$|$78$|


---

---
title: "[湖北省选模拟 2023] 环山危路 / road"
layout: "post"
diff: 省选/NOI-
pid: P9545
tag: ['2023', 'O2优化', '湖北']
---
# [湖北省选模拟 2023] 环山危路 / road
## 题目描述

R 国有 $n$ 座城市，编号从 $1$ 到 $n$。这些城市两两之间都有道路连接，形成一个图的结构。不过，这些路修得很烂，每条路都有一个固定的方向，车只能按照这个方向行驶；路还是一次性的，也就是说最多只能过一辆车。

现在 R 国正在制定防灾减灾预案。你需要帮助 R 国计算，如果 $t_i$ 号城市发生了灾难，并且 $s_{i,1},s_{i,2},\dots,s_{i,k_i}$ 这些城市有充足的救灾物资（可以认为它们都拥有可以装无数辆车的物资），那么最多能从这些城市运送几车物资到达 $t_i$。车只能走城间的那些一次性道路，不过车在到达 $t_i$ 之前是可以经过多个城市和多条道路中转的。
## 输入格式

输入共 $n+m +1$ 行。

第一行两个正整数 $n,m$，表示城市个数和询问次数。

第二行到第 $n+1$ 行，每行一个长为 $n$ 的 $01$ 字符串，第 $i+1$ 行第 $j$ 列表示是否有从 $i$ 通向 $j$ 的道路（$1$ 表示有，$0$ 表示无）。

接下来 $m$ 行，每行第一个正整数为 $t_i$，第二个正整数为 $k_i$，接着 $k_i$ 个正整数 $s_{i,1},s_{i,2},\dots,s_{i,k_i}$。保证 $s_{i,1},s_{i,2},\dots,s_{i,k_i}$ 中没有重复的数且没有 $t_i$。
## 输出格式

输出 $m$ 行，每行一个非负整数，表示第 $i$ 次询问的答案。
## 样例

### 样例输入 #1
```
5 2
01001
00110
10001
10101
01000
2 2 1 4
5 2 4 1

```
### 样例输出 #1
```
2
3

```
### 样例输入 #2
```
见选手目录下的 road/road2.in 与 road/road2.ans。
```
### 样例输出 #2
```
见选手目录下的 road/road2.in 与 road/road2.ans。
```
## 提示

### 样例 1 解释

城市间的路如下图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/3he9r0j2.png)

这是答案对应的一种可能的方案：

第一次询问中，一辆车走 $1 \rightarrow 2$，另一辆走 $4 \rightarrow 1 \rightarrow 5 \rightarrow 2$；

第二次询问中，一辆车走 $1 \rightarrow 5$，一辆走 $1 \rightarrow 2 \rightarrow 3 \rightarrow5$，还有一辆走 $4 \rightarrow 5$。

### 子任务

对于所有测试数据，保证 $1 \le n \le 3000$，$1 \le m,\sum\limits_{i=1}^mk_i \le 30000$。

![](https://cdn.luogu.com.cn/upload/image_hosting/d7a2om1c.png)

特殊性质 A：保证所有询问的 $t_i$ 相等。

特殊性质 B：保证 $u$ 与 $v$ 之间的路从 $\min(u,v)$ 通向 $\max(u,v)$。


---

---
title: "[湖北省选模拟 2023] 山路长环 / ring"
layout: "post"
diff: 省选/NOI-
pid: P9546
tag: ['2023', 'O2优化', '湖北']
---
# [湖北省选模拟 2023] 山路长环 / ring
## 题目描述

张三和李四在玩游戏。游戏规则是这样的：

在他们面前有一个棋盘，棋盘是一个由 $n$ 个节点和 $n$ 条边构成的环，边有边权。初始时，一枚棋子被放置在某个节点上。张三和李四轮流移动棋子，张三为先手，无法移动者败。每次移动时，必须选择棋子当前所在节点的某个相邻点（即有边相连的点），沿着边将棋子移动到这个相邻点去，并将边权减少任意正整数。需要注意的是，边权不允许被减小到负数。

张三想让你算算，对于给定的棋盘，有多少种初始棋子的摆放方式能使得他有必胜策略。

现在你有一个长为 $m$ 的序列 $a_1,a_2,\dots,a_m$，你需要完成 $q$ 次操作。每次操作形式为如下之一：

- `1 x y` 表示将 $a_x$ 赋值为 $y$；
- `2 l r` 表示查询如果棋盘上共 $(r-l+1)$ 个节点，且边权以顺时针方向分别为 $a_l,a_{l+1},\dots,a_r$，那么这样一盘游戏共有多少个不同的初始棋子位置可以让张三有必胜策略。
## 输入格式

输入共 $m+2$ 行。

第一行两个正整数 $m,q$。

第二行 $m$ 个整数，第 $i$ 个数为 $a_i$。

接下来 $q$ 行，每行三个整数，格式如题面所述。
## 输出格式

输出若干行，每行一个非负整数，表示一次询问的答案。
## 样例

### 样例输入 #1
```
6 7
0 1 0 2 3 0
2 1 6
1 1 1
2 1 6
2 4 5
1 4 3
2 3 5
2 4 5

```
### 样例输出 #1
```
3
2
2
1
0
```
### 样例输入 #2
```
见选手目录下的 ring/ring2.in 与 ring/ring2.ans。
```
### 样例输出 #2
```
见选手目录下的 ring/ring2.in 与 ring/ring2.ans。
```
## 提示

### 子任务

对于所有测试数据，保证 $1 \le m,q \le 3 \times 10^5$，$1 \le l \le r \le m$，$1\le x \le m$，$0 \le y,a_i \le 10^6$。

![](https://cdn.luogu.com.cn/upload/image_hosting/j579v06f.png)

特殊性质 A：保证 $0 \le y,a_i \le 1$。

特殊性质 B：保证所有询问满足 $l=1$，$r=m$。

特殊性质 C：保证没有修改操作。


---

---
title: "「PHOI-1」晚宴筵"
layout: "post"
diff: 省选/NOI-
pid: P9550
tag: ['O2优化']
---
# 「PHOI-1」晚宴筵
## 题目背景

小 X 在 Z 市长途奔波之后，他要去参加别人的晚宴。

![](https://cdn.luogu.com.cn/upload/image_hosting/2cpdwvwu.png)
## 题目描述

Z 市形如一个 $n \times n$ 的矩阵，小 X 打算仅使用瞬移机和时空穿越机到达别人的晚宴，若小 X 所在的位置 $(p,q)$ 满足 $l1_x \le p \le r1_x$ 且 $l2_y \le q \le r2_y(0 \le l1_x \le r1_x < x,0\le l2_y\le r2_y < y)$，那么小 X 就可以到达位置 $(x,y)$。

但是由于瞬移技术不太成熟以及时空穿越机的影响，瞬移时需花费 $w_p+w_q+w_x+w_y-p-q-x-y$ 秒（由于时空穿越机的特性，时间可能为负）。若下标不是正整数，瞬移机就会被损坏，所以小 X 只能到达都是正整数的下标。

现在小 X 在 $(1,1)$ 的位置，他要参加别人的晚宴，可是他目前不知道别人的晚宴在哪里，所以他想让你求，他到达每个地方 $(x,y)\text{ }\text{ }(1 \leq x,y \leq n)$ 所花费的最少时间，如果不能到达则输出 `inf`。
## 输入格式

第 $1$ 行一个整数 $n$，表示矩阵的大小。

第 $2$ 行 $n$ 个非负整数分别表示 $l1_1,l1_2 \ldots l1_n$。

第 $3$ 行 $n$ 个非负整数分别表示 $r1_1,r1_2 \ldots r1_n$。

第 $4$ 行 $n$ 个非负整数分别表示 $l2_1,l2_2 \ldots l2_n$。

第 $5$ 行 $n$ 个非负整数分别表示 $r2_1,r2_2 \ldots r2_n$。

第 $6$ 行 $n$ 个非负整数分别表示 $w_1,w_2 \ldots w_n$。

数据保证 $l1_i \leq r1_i,l2_i \leq r2_i$。
## 输出格式

输出 $n$ 行，每行 $n$ 个整数，第 $i$ 行第 $j$ 列的整数表示小 X 从 $(1,1)$ 到 $(i,j)$ 的最短路。
## 样例

### 样例输入 #1
```
3
0 1 1
0 1 2
0 0 2
0 1 2
2 0 4
```
### 样例输出 #1
```
0 inf inf
inf -2 inf
inf 1 -4
```
### 样例输入 #2
```
10
0 1 1 2 2 2 3 3 3 3
0 1 2 2 3 3 3 4 4 4
0 1 2 2 3 3 3 3 4 4
0 1 2 3 4 4 5 5 5 5
8 4 2 1 2 4 8 4 2 1
```
### 样例输出 #2
```
0 inf inf inf inf inf inf inf inf inf
inf 18 inf inf inf inf inf inf inf inf
inf 15 20 18 inf inf inf inf inf inf
inf inf 18 16 inf inf inf inf inf inf
inf inf 12 10 8 9 12 7 4 2
inf inf 13 11 9 10 13 8 5 3
inf inf 16 14 12 13 16 11 8 6
inf inf 11 7 3 4 7 2 -1 -3
inf inf 8 4 0 1 4 -1 -4 -6
inf inf 6 2 -2 -1 2 -3 -6 -8
```
## 提示

**本题采用捆绑测试。**

| Subtask | $n$ | $l1_i,l2_i$ | $w_i$ | 分值 |
| :-: | :-: | :-: | :-: | :-: |
| $0$ | $1 \le n \le 70$ | 无特殊限制 | $i \leq w_i \leq 10^5(1 \leq i \leq n)$ | $15$ |
| $1$ | $1 \le n \le 70$ | 无特殊限制 | 无特殊限制 | $25$ |
| $2$ | 无特殊限制 | $l1_i=l2_i=r1_i=r2_i=1(2\le i \le n)$ | 无特殊限制 | $5$ |
| $3$ | 无特殊限制 | 无特殊限制 | 无特殊限制 | $55$ | 

对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^3,0 \leq l1_i \leq r1_i \leq n,0 \leq l2_i \leq r2_i \leq n,0 \leq w_i \leq 10^5$ $,l1_i \leq r1_i < i,l2_i \leq r2_i < i $。

### 样例解释 #1:

- 从 $(1,1)$ 到 $(1,1)$ 显然要花费 $0$ 秒。

- 从 $(1,1)$ 可以直接到 $(2,2)$, 花费 $w_1 + w_1 + w_2 + w_2 - 1 - 1 - 2 - 2 = -2$ 秒。

- 从 $(1,1)$ 也可以直接到 $(3,2)$, 花费 $w_1 + w_1 + w_3 + w_2 - 1 - 1 - 3 - 2 = 1$ 秒。

- 要从 $(1,1)$ 到达 $(3,3)$，要先从 $(1,1)$ 到达 $(2,2)$，再从 $(2,2)$ 到达 $(3,3)$。花费 $w_1 + w_1 + w_2 + w_2 - 1 - 1 - 2 - 2 + w_2 + w_2 + w_3 + w_3 - 2 - 2 - 3 - 3 = -4$ 秒。

- 经过手算，可以发现，从 $(1,1)$ 不能到达其他位置。


---

---
title: "「CROI · R1」浣熊的阴阳鱼"
layout: "post"
diff: 省选/NOI-
pid: P9555
tag: ['O2优化']
---
# 「CROI · R1」浣熊的阴阳鱼
## 题目背景

> 往昔，阴阳由天地所创，孕大含深；今昔，时光为记忆所刻，随行如影。\
流水落花间，嬉闹于阴阳树的意境；沧海桑田间，铭心于阴阳忆的缤斓。\
阴鱼，阳鱼……挥翰着日月的闲情，留存着浣熊的惬意，却不复存在……\
小浣熊 CleverRaccoon 与最后一瞬阴阳，含泪而笑……
## 题目描述

一棵树的各结点都悬挂着 $1$ 条阴鱼或阳鱼（分别用 $0,1$ 表示），它们可能在某刻由于基因突变互相转化。

小浣熊 CleverRaccoon 带着一只能装 $2$ 条鱼的篮筐在此树的某条链上行走。当他所在点上的鱼与某条筐内鱼的属性相反时，他会将这 $2$ 条鱼合成 $1$ 条阴阳鱼并吃下；在筐中没有满的条件下，他会将所在点上的鱼放入筐中。

现有两种操作：

1. 一个结点上的阴阳鱼发生基因突变，变为另一种类型的阴阳鱼。
2. 帮助聪明的小浣熊 CleverRaccoon 求出：当他沿着这棵树上的某条链行走时，能吃下的阴阳鱼的条数。
## 输入格式

第一行，两个正整数 $n$ 和 $q$，表示结点个数、修改和询问总次数。

第二行 $n$ 个整数，表示每个结点上悬挂的鱼的属性。

接下来 $n−1$ 行，每行两个正整数 $u,v$，表示 $u$ 和 $v$ 两个点之间有一条边。

接下来 $q$ 行，格式为 `1 u` 或 `2 u v`。

若格式为 `1 u`，则表示结点 $u$ 上的鱼基因突变。

若格式为 `2 u v`，则表示询问小浣熊  CleverRaccoon 在从 $u$ 到 $v$ 的简单路径中能吃下的阴阳鱼的条数。
## 输出格式

对于每次询问，单行输出一个整数，表示小浣熊  CleverRaccoon 能吃下的阴阳鱼的条数。
## 样例

### 样例输入 #1
```
9 3
1 1 1 0 1 1 0 0 0
1 2
2 3
3 4
3 5
1 6
6 7
7 8
7 9
2 9 4
1 9
2 4 9

```
### 样例输出 #1
```
3
2
```
## 提示

**数据范围**

**本题采用 Subtask 捆绑测试**。

- Subtask 0（10 points）：$n,q \leq 10$。
- Subtask 1（15 points）：$n,q \leq 2\times10^3$。
- Subtask 2（15 points）：保证树的深度小于 $10^3$。
- Subtask 3（60 points）：无特殊限制。

对于所有测试数据： $1 \leq n,q\leq 10^5$。


---

---
title: "[SDCPC 2023] Trie"
layout: "post"
diff: 省选/NOI-
pid: P9558
tag: ['2023', '山东', 'O2优化', 'XCPC']
---
# [SDCPC 2023] Trie
## 题目描述

Recall the definition of a trie:

- A trie of size $n$ is a rooted tree with $n$ vertices and $(n - 1)$ edges, where each edge is marked with a character.
- Each vertex in a trie represents a string. Let $s(x)$ be the string vertex $x$ represents.
- The root of the trie represents an empty string. Let vertex $u$ be the parent of vertex $v$, and let $c$ be the character marked on the edge connecting vertex $u$ and $v$, we have $s(v) = s(u) + c$. Here $+$ indicates string concatenation, not the normal addition operation.
- The string each vertex represents is distinct.

We now present you a rooted tree with $(n + 1)$ vertices. The vertices are numbered $0, 1, \cdots, n$ and vertex $0$ is the root. There are $m$ key vertices in the tree where vertex $k_i$ is the $i$-th key vertex. It's guaranteed that all leaves are key vertices.

Please mark a lower-cased English letter on each edge so that the rooted tree changes into a trie of size $(n + 1)$. Let's consider the sequence $A = \{s(k_1), s(k_2), \cdots, s(k_m)\}$ consisting of all strings represented by the key vertices. Let $B = \{w_1, w_2, \cdots, w_m\}$ be the string sequence formed by sorting all strings in sequence $A$ from smallest to largest in lexicographic order. Please find a way to mark the edges so that sequence $B$ is minimized.

We say a string $P = p_1p_2\cdots p_x$ of length $x$ is lexicographically smaller than a string $Q = q_1q_2\cdots q_y$ of length $y$, if

- $x < y$ and for all $1 \le i \le x$ we have $p_i = q_i$, or
- there exists an integer $1 \le t \le \min(x, y)$ such that for all $1 \le i < t$ we have $p_i = q_i$, and $p_t < q_t$.

We say a string sequence $F = \{f_1, f_2, \cdots, f_m\}$ of length $m$ is smaller than a string sequence $G = \{g_1, g_2, \cdots, g_m\}$ of length $m$, if there exists an integer $1 \le t \le m$ such that for all $1 \le i < t$ we have $f_i = g_i$, and $f_t$ is lexicographically smaller than $g_t$.
## 输入格式

There are multiple test cases. The first line of th input contains an integer $T$ indicating the number of test cases. For each test case:

The first line contains two integers $n$ and $m$ ($1 \le m \le n \le 2 \times 10^5$) indicating the number of vertices other than the root and the number of key vertices.

The second line contains $n$ integers $a_1, a_2, \cdots, a_n$ ($0 \le a_i < i$) where $a_i$ is the parent of vertex $i$. It's guaranteed that each vertex has at most $26$ children.

The third line contains $m$ integers $k_1, k_2, \cdots, k_m$ ($1 \le k_i \le n$) where $k_i$ is the $i$-th key vertex. It's guaranteed that all leaves are key vertices, and all key vertices are distinct.

It's guaranteed that the sum of $n$ of all test cases will not exceed $2 \times 10^5$.
## 输出格式

For each test case output one line containing one answer string $c_1c_2\cdots c_n$ consisting of lower-cased English letters, where $c_i$ is the letter marked on the edge between $a_i$ and $i$. If there are multiple answers strings so that sequence $B$ is minimized, output the answer string with the smallest lexicographic order.
## 样例

### 样例输入 #1
```
2
5 4
0 1 1 2 2
1 4 3 5
1 1
0
1
```
### 样例输出 #1
```
abaab
a
```
## 提示

The answer of the first sample test case is shown as follows.

![](https://cdn.luogu.com.cn/upload/image_hosting/zvhqplsb.png)

The string represented by vertex $1$ is ``a``. The string represented by vertex $4$ is ``aba``. The string represented by vertex $3$ is ``aa``. The string represented by vertex $5$ is ``abb``. So $B = \{$``a``, ``aa``, ``aba``, ``abb``$\}$.
## 题目翻译

**【题目描述】**

请回忆字典树的定义：

- 一棵大小为 $n$ 的字典树是一棵有 $n$ 个节点和 $(n - 1)$ 条边的有根树，每一条边都标有一个字符。
- 字典树中的每个节点都代表一个字符串，令 $s(x)$ 表示节点 $x$ 代表的字符串。
- 字典树的根代表的是空字符串。设节点 $u$ 为节点 $v$ 的父节点，设 $c$ 表示节点 $u$ 和 $v$ 之间的边上标有的字符，则 $s(v) = s(u) + c$。这里的 $+$ 代表字符串连接，而不是普通的加法。
- 所有节点代表的字符串互不相同。

给定一棵有 $(n + 1)$ 个节点的有根树，节点编号为 $0, 1, \cdots, n$，其中节点 $0$ 是根节点。树上共有 $m$ 个关键节点，其中第 $i$ 个关键节点的编号为 $k_i$。保证所有叶子节点都是关键节点。

请为每一条边标上一个小写字母，使得这棵有根树变为一棵大小为 $(n + 1)$ 的字典树。考虑所有关键节点代表的字符串构成的序列 $A = \{s(k_1), s(k_2), \cdots, s(k_m)\}$，设 $B = \{w_1, w_2, \cdots, w_m\}$ 是由序列 $A$ 中所有字符串按字典序从小到大排序后得到的字符串序列，您需要找到一个标记字母的方案，使得序列 $B$ 最小。

称长度为 $x$ 的字符串 $P = p_1p_2\cdots p_x$ 的字典序小于长度为 $y$ 的字符串 $Q = q_1q_2\cdots q_y$，若

- $x < y$ 且对于所有 $1 \le i \le x$ 有 $p_i = q_i$，或者
- 存在一个整数 $1 \le t \le \min(x, y)$，对于所有 $1 \le i < t$ 有 $p_i = q_i$，且 $p_t < q_t$。

称长度为 $m$ 的字符串序列 $F = \{f_1, f_2, \cdots, f_m\}$ 小于长度为 $m$ 的字符串序列 $G = \{g_1, g_2, \cdots, g_m\}$，若存在一个整数 $1 \le t \le m$，对于所有 $1 \le i < t$ 有 $f_i = g_i$，且 $f_t$ 的字典序小于 $g_t$ 的字典序。

**【输入格式】**

有多组测试数据。第一行输入一个整数 $T$ 表示测试数据组数。对于每组测试数据：

第一行输入两个正整数 $n$ 和 $m$（$1 \le m \le n \le 2 \times 10^5$）表示除了根节点以外的节点数量和关键节点的数量。

第二行输入 $n$ 个整数 $a_1, a_2, \cdots, a_n$（$0 \le a_i < i$），其中 $a_i$ 代表节点 $i$ 的父节点。保证每个节点至多有 $26$ 个子节点。

第三行输入 $m$ 个整数 $k_1, k_2, \cdots, k_m$（$1 \le k_i \le n$），其中 $k_i$ 代表第 $i$ 个关键节点的编号。保证所有叶子节点都是关键节点，且没有重复的关键节点。

保证所有测试数据 $n$ 之和不超过 $2 \times 10^5$。

**【输出格式】**

每组数据输出一行一个由小写字母组成的答案字符串 $c_1c_2\cdots c_n$，其中 $c_i$ 表示节点 $a_i$ 到 $i$ 的边上标有的小写字母。若有多种答案字符串使得字符串序列 $B$ 最小，请输出字典序最小的答案字符串。

**【样例解释】**

第一组样例数据的答案如下图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/zvhqplsb.png)

其中，节点 $1$ 代表的字符串为 ``a``，节点 $4$ 代表的字符串为 ``aba``，节点 $3$ 代表的字符串为 ``aa``，节点 $5$ 代表的字符串为 ``abb``。因此 $B = \{$``a``, ``aa``, ``aba``, ``abb``$\}$。


---

---
title: "[JOI Open 2018] 冒泡排序 2"
layout: "post"
diff: 省选/NOI-
pid: P9596
tag: ['2018', 'O2优化', 'JOI（日本）']
---
# [JOI Open 2018] 冒泡排序 2
## 题目描述

冒泡排序是一个对序列排序的算法。现在我们要将一个长度为 $N$ 的序列 $A_0,A_1,\ldots ,A_{N-1}$​ 按不降顺序排序。当两个相邻的数没有按正确顺序排列时，冒泡排序会交换这两个数的位置。每次扫描这个序列就进行这种交换。更确切地说，在一趟**扫描**中，对于 $i=0,1,\ldots ,N-2$，并按这个顺序，如果 $A_i>A_{i+1}$​，那么我们就交换这两个数的位置。众所周知任何序列经过有限趟扫描后一定可以按非降顺序排好序。对于一个序列 $A$，我们定义**用冒泡排序的扫描趟数**为使用如上算法使得 $A$ 排好序的情况下所扫描的趟数。

JOI 君有一个长度为 $N$ 的序列 $A$。他打算处理 $Q$ 次修改 $A$ 的值的询问。更明确地说，在第 $(j+1)\ (0\le j\le Q-1)$ 次询问，$A_{X_j}$ 的值会变为 $V_j$。

JOI 君想知道处理每次修改之后，用冒泡排序的扫描趟数。
## 输入格式

LOJ 上为交互题，方便起见，这里使用传统题的方式进行评测。

第一行两个整数 $N,Q$。

第二行 $N$ 个整数 $A_0,A_1,\ldots ,A_{N-1}$。

接下来 $Q$ 行，每行两个整数 $X_j,V_j$。
## 输出格式

输出 $Q$ 行，第 $(j+1)\ (0\le j\le Q-1)$ 行表示处理第 $(j+1)$ 个询问后，对这个序列冒泡排序的扫描趟数。
## 样例

### 样例输入 #1
```
4 2
1 2 3 4
0 3
2 1
```
### 样例输出 #1
```
1
2
```
### 样例输入 #2
```
11 12
11 4 13 6 7 3 5 12 4 10 11
8 11
4 4
6 20
0 2
7 2
3 18
5 9
0 6
8 8
9 4
0 8
6 18

```
### 样例输出 #2
```
5
5
5
4
6
6
6
7
7
7
7
7
```
## 提示

**【样例解释】**

给定一个长度为 $N=4$ 的序列 $A=\{1,2,3,4\}$ 和 $Q=2$ 次询问：$X=\{0,2\},V=\{3,1\}$。

1. 对于第一次询问，$A_0$ 的值变为 $3$。我们得到 $A=\{3,2,3,4\}$。
2. 对于第一次询问，$A_2$ 的值变为 $1$。我们得到 $A=\{3,2,1,4\}$。

对 $A=\{3,2,3,4\}$ 做冒泡排序：

- $A$ 并未排好序，所以第一趟扫描开始。因为 $A_0>A_1$，所以我们交换它们，序列变为 $A=\{2,3,3,4\}$。因为 $A_1\le A_2$，所以我们不交换它们。因为 $A_2\le A_3$，所以我们也不交换它们。
- 现在 $A$ 已经排好序了，所以冒泡排序过程结束。

因此对于 $A=\{3,2,3,4\}$，冒泡排序的扫描趟数为 $1$。

对 $A=\{3,2,1,4\}$ 做冒泡排序：

- $A$ 并未排好序，所以第一趟扫描开始。因为 $A_0>A_1$，所以我们交换它们，序列变为 $A=\{2,3,1,4\}$。因为 $A_1> A_2$，所以我们交换它们，序列变为 $A=\{2,1,3,4\}$。因为 $A_2\le A_3$，所以我们也不交换它们。
- $A$ 并未排好序，所以第二趟扫描开始。因为 $A_0>A_1$，所以我们交换它们，序列变为 $A=\{1,2,3,4\}$。因为 $A_1\le A_2$，所以我们不交换它们。因为 $A_2\le A_3$，所以我们也不交换它们。
- 现在 $A$ 已经排好序了，所以冒泡排序过程结束。

因此对于 $A=\{3,2,1,4\}$，冒泡排序的扫描趟数为 $2$。

**【数据范围】**

共有四个子任务。每个子任务的分值及附加限制如下：

| 子任务编号 | 分值 |         $N$          |         $Q$          |              $A,V$               |
| :--------: | :--: | :------------------: | :------------------: | :------------------------------: |
|    $1$     | $17$ |  $1\le N\le 2\ 000$  |  $1\le Q\le 2\ 000$  |      $1\le A_i,V_j\le 10^9$      |
|    $2$     | $21$ |  $1\le N\le 8\ 000$  |  $1\le Q\le 8\ 000$  | $1\le A_i,V_j\le 10^9$ |
|    $3$     | $22$ | $1\le N\le 50\ 000$  | $1\le Q\le 50\ 000$  |      $1\le A_i,V_j\le 100$       |
|    $4$     | $40$ | $1\le N\le 500\ 000$ | $1\le Q\le 500\ 000$ |      $1\le A_i,V_j\le 10^9$      |




---

---
title: "[JOI Open 2018] 猫或狗"
layout: "post"
diff: 省选/NOI-
pid: P9597
tag: ['2018', '交互题', 'O2优化', 'JOI（日本）']
---
# [JOI Open 2018] 猫或狗
## 题目背景

**特别提醒，由于洛谷交互机制的特殊性，你不能在程序中引用 `catdog.h`，只需要实现要求的几个函数即可。**
## 题目描述

你的儿子 JOI 君喜欢养宠物。在你家的花园里有 $N$​ 个小屋可供饲养宠物，这 $N$ 个房子从 $1$ 到 $N$ 编号。有 $N-1$ 条双向路径双向连接这 $N$ 个小屋，并且对于任意两个小屋，都可以通过某些路径在它们之间移动。每个小屋最多可以住一只宠物。

JOI 君想要养猫和狗，但是他很担心宠物们可能会经常打架。对于每个小屋的如下状态：住了一只猫，住了一只狗，没有住宠物，他都按如下方式定义了花园的**危险级别**：

- 对于每只猫和每只狗，为了不让他们通过未阻塞的道路相遇，需要阻塞的最小路径数。

在定义危险级别后，JOI 君开始指定后 $Q$ 天使用花园的计划。初始时，所有小屋里都没有宠物。第 $i$ 天的计划是如下内容中的一个：

- 在目前没有宠物的小屋 $v$​​ 中养一只猫。
- 在目前没有宠物的小屋 $v$ 中养一只狗。
- 将小屋 $v$ 中的宠物送给邻居，这意味着在小屋 $v$​ 中就没有宠物了。

你作为家长，有责任检查你的儿子的计划是否危险。更确切地说，你需要求出这 $Q$ 天每天进行完计划后，这个花园的危险级别。

---

**为了在线地回答询问，本题采用交互的方式进行评测。**

你需要实现四个函数 `initialize`，`cat`，`dog` 和 `neighbor`。

最初，函数 `initialize` 被调用。这个函数的作用是接受花园的信息。

- `initialize(N, A, B)`
  - $N$：花园中小屋的数量。
  - $A, B$：长度为 $N-1$ 的数组。意味着对于 $0\le i\le N-2$，在小屋 $A_i$ 和小屋 $B_i$ 之间存在一条路径。保证对于任意两个不同的小屋，沿某些路径可以在它们之间移动。

然后，对于这 $Q$ 天的计划，按时间顺序会调用如下函数：

- `cat(v)`：调用此函数，在目前没有宠物的小屋 $v$ 中养一只猫。
- `dog(v)`：调用此函数，在目前没有宠物的小屋 $v$ 中养一只狗。
- `neighbor(v)`：调用此函数，让小屋 $v$ 中的宠物离开。

这些函数应返回在这个计划执行后花园的危险值。

目前不支持对 Java 和 Pascal 语言提交的测评。


## 输入格式

样例交互器按如下格式读取输入：

第一行一个整数 $N$。

接下来 $N-1$ 行，每行两个整数 $A_i,B_i$。

接下来一行一个整数 $Q$。

接下来 $Q$ 行，每行两个整数 $T_j,v_j$。

这里，如果在第 $j$ 天的调用是 $\texttt{cat}$，则 $T_j=1$，如果是 $\texttt{dog}$，则 $T_j=2$，如果是 $\texttt{neighbor}$，则 $T_j=3$。
## 输出格式

样例交互器按如下格式输出第 $j$ 天的函数调用结果 $D_j$：

第 $j$ 行输出 $D_j$。
## 样例

### 样例输入 #1
```
3
1 2
2 3
4
1 1
1 3
2 2
3 2

```
### 样例输出 #1
```
0
0
2
0
```
### 样例输入 #2
```
5
1 2
2 3
2 4
4 5
5
1 3
2 5
1 2
2 1
3 2
```
### 样例输出 #2
```
0
1
1
2
1
```
## 提示

**【样例】**

考虑有 $5$ 个小屋和 $4$ 条路径的情况。这四条路径连接小屋 $1$ 和小屋 $2$，小屋 $2$ 和小屋 $3$，小屋 $2$ 和小屋 $4$，小屋 $4$ 和小屋 $5$。

1. 假设他首先在小屋 $3$ 养了一只猫，在小屋 $5$ 养了一只狗。通过阻塞小屋 $2$ 和小屋 $4$ 之间的道路，他可以避免猫和狗相遇。因此，此时的危险等级是 $1$。
2. 假设他之后在小屋 $2$​ 养了一直新猫，在小屋 $1$​ 养了一只新狗。通过阻塞小屋 $2$​ 和小屋 $4$​ 之间的道路与小屋 $1$​ 和小屋 $2$​ 之间的道路，他可以避免猫和狗相遇。因此，此时的危险等级是 $2$。
3. 假设他最后将小屋 $2$ 的猫给了邻居。他只需要阻塞小屋 $2$ 和小屋 $3$ 之间的道路。因此，此时的危险等级是 $1$。



**【数据范围】**

本题有三个子任务。每个子任务的分值与附加限制如下表所示：

| 子任务编号 | 分值 |         $N$          |         $Q$          |
| :--------: | :--: | :------------------: | :------------------: |
|    $1$     | $8$  |    $1\le N\le 15$    |   $1\le Q\le 100$    |
|    $2$     | $30$ |  $1\le N\le 1\ 000$  |  $1\le Q\le 1\ 000$  |
|    $3$     | $62$ | $1\le N\le 100\ 000$ | $1\le Q\le 100\ 000$ |




---

---
title: "[IOI 2023] 封锁时刻"
layout: "post"
diff: 省选/NOI-
pid: P9600
tag: ['2023', 'IOI', '交互题', 'O2优化']
---
# [IOI 2023] 封锁时刻
## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。
## 题目描述

匈牙利有 $N$ 个城市，编号依次为 $0$ 到 $N - 1$。

这些城市之间由 $N - 1$ 条双向道路连接，编号为 $0$ 至 $N - 2$。对每个 $j$（$0 \le j \le N - 2$），第 $j$ 条道路连接城市 $U[j]$ 和城市 $V[j]$，其长度为 $W[j]$，表示这两个城市之间的交通时间为 $W[j]$ 个时间单位。每条道路连接两个不同的城市，且每两个城市之间最多由一条道路连接。

两个不同城市 $a$ 和 $b$ 之间的一条**路径**是一个由不同城市组成的序列 $p_0, p_1, \ldots, p_t$，满足以下条件：
 * $p_0 = a$， 
 * $p_t = b$， 
 * 对每个 $i$（$0 \le i \lt t$），存在一条道路连接 $p_i$ 和 $p_{i + 1}$。

利用这些道路从任意一个城市到任意一个其他的城市都是有可能的。换言之，任意两个不同城市之间都存在路径。  
可以证明两个不同城市之间的路径是唯一的。

一条路径 $p_0, p_1, \ldots, p_t$ 的**长度**是这条路径上连接相邻城市的 $t$ 条道路的长度之和。

在匈牙利，很多人都会在建国日去参加在两个主要城市举行的庆祝活动。当庆祝活动结束时，他们会回家。政府为了防止人群干扰当地人，所以决定在特定时刻封锁城市。每个城市被政府分配一个非负的**封锁时刻**。政府决定所有城市的封锁时刻总和不得超过 $K$。具体来说，对每个 $i$（$0 \leq i \leq N - 1$），分配给城市 $i$ 的封锁时刻是一个非负整数  $c[i]$。所有  $c[i]$ 之和不超过 $K$。

考虑一个城市 $a$ 和某个封锁时刻的分配方案，我们说城市 $b$ 是从城市 $a$ 可达的当且仅当以下两种情况中的任意一种情况成立。

情况 1：$b = a$。

情况 2：这两个城市之间的路径  $p_0, \ldots, p_t$ （$p_0 = a$ 且 $p_t = b$）满足以下条件：
* 路径 $p_0, p_1$ 的长度最多为 $c[p_1]$，并且
* 路径 $p_0, p_1, p_2$ 的长度最多为 $c[p_2]$，并且
* $\ldots$
* 路径 $p_0, p_1, p_2, \ldots, p_t$ 的长度最长为  $c[p_t]$。

今年，两个主要的庆祝地点位于城市 $X$ 和 $Y$。  
对于每一个封锁时刻的分配方案，可以定义一个**便利分数**，其定义为下面两个数字之和：
- 从城市 $X$ 可达的城市个数。
- 从城市 $Y$ 可达的城市个数。

注意如果一个城市既能从城市 $X$ 可达也能从城市 $Y$ 可达，那么它在计算便利分数时计算两次。

你的任务是计算能被某个封锁时刻分配方案实现的最大便利分数。
## 输入格式

令 $C$ 表示场景数，即调用 `max_score` 的次数。
评测程序实例按以下格式读取输入：

* 第 $1$ 行：$C$

以下是 $C$ 个场景的描述。

评测程序实例按以下格式读取每个场景的描述：

* 第 $1$ 行：$N \; X \; Y \; K$
* 第 $2 + j$ 行（$0 \le j \le N - 2$）：$U[j] \; V[j] \; W[j]$
## 输出格式

评测程序实例按以下格式为每个场景打印单独一行

* 第 $1$ 行： `max_score` 的返回值
## 样例

### 样例输入 #1
```
2
7 0 2 10
0 1 2
0 3 3
1 2 4
2 4 2
2 5 5
5 6 3
4 0 3 20
0 1 18
1 2 1
2 3 19

```
### 样例输出 #1
```
6
3

```
## 提示

#### 【实现细节】

你要实现以下函数。

```
int max_score(int N, int X, int Y, int64 K, int[] U, int[] V, int[] W)
```

* $N$：城市的个数
* $X$，$Y$：两个主要庆祝城市
* $K$：封锁时刻总和的上界
* $U$，$V$： 长度为 $N - 1$ 的描述道路连接情况的数组
* $W$：长度为 $N - 1$ 的描述道路长度的数组
* 该函数要返回能被某个封锁时刻分配方案实现的最大便利分数
* 每个测试用例可以多次调用该函数



#### 【例子】


考虑以下调用：

```
max_score(7, 0, 2, 10,
          [0, 0, 1, 2, 2, 5], [1, 3, 2, 4, 5, 6], [2, 3, 4, 2, 5, 3])
```



这对应以下道路网络：

![](https://cdn.luogu.com.cn/upload/image_hosting/wf5uw4qd.png)



假设封锁时刻如下分配：

| **城市**         | $0$ | $1$ | $2$ | $3$ | $4$ | $5$ | $6$ |
|:----------------:|:---:|:---:|:---:|:---:|:---:|:---:|:---:|
| **封锁时刻** | $0$ | $4$ | $0$ | $3$ | $2$ | $0$ | $0$ |



注意所有封锁时刻之和为 $9$，不超过 $K = 10$。城市 $0$，$1$ 和 $3$ 都是从城市 $X$（$X = 0$）可达的，而城市 $1$，$2$ 和 $4$ 都可以从城市 $Y$（$Y  = 2$）可达。 因此，便利分数为 $3+3 = 6$。不存在封锁时刻分配方案使得便利分数大于 $6$，所以该函数应该返回 $6$。



考虑另外一个调用：

```
max_score(4, 0, 3, 20, [0, 1, 2], [1, 2, 3], [18, 1, 19])
```



这对应以下道路网络：

![](https://cdn.luogu.com.cn/upload/image_hosting/zcw4gdi5.png)

假设封锁时间如下分配：

| **城市**         | $0$ | $1$ | $2$ | $3$ |
|:----------------:|:---:|:---:|:---:|:---:|
| **封锁时刻** | $0$ | $1$ | $19$| $0$ |



城市 $0$ 从城市 $X$（$X = 0$）可达，而城市 $2$ 和 $3$ 都是可以从城市 $Y$（$Y=3$）可达的。因此，便利分数是 $1 + 2 = 3$。不存在封锁时刻分配方案使得便利分数大于 $3$，所以函数应该返回 $3$。

#### 【约束条件】

* $2 \le N \le 200\,000$
* $0 \le X \lt Y \lt N$
* $0 \le K \le 10^{18}$
* $0 \le U[j] \lt V[j] \lt N$ (对每个 $j$ 满足 $0 \le j \le N - 2$)
* $1 \le W[j] \le 10^6$ (对每个 $j$ 满足 $0 \le j \le N - 2$)
* 利用这些道路可以从任意一个城市走到任意另外一个城市。
* $S_N \le 200\,000$，其中 $S_N$ 是所有调用函数 `max_score` 的  $N$ 的总和。


#### 【子任务】


我们说一个道路网络是**线性的**如果道路 $i$ 连接城市 $i$ 和 $i+1$（对每个$0 \le i \le N - 2$ 的 $i$）。

1. （8 分）从城市 $X$ 到城市 $Y$ 的路径长度大于 $2K$。
1. （9 分）$S_N \le 50$，道路网络是线性的。
1. （12 分）$S_N \le 500$，道路网络是线性的。
1. （14 分）$S_N \le 3\,000$，道路网络是线性的。
1. （9 分）$S_N \le 20$
1. （11 分）$S_N \le 100$
1. （10 分）$S_N \le 500$
1. （10 分）$S_N \le 3\,000$
1. （17 分）无额外的约束条件。


---

---
title: "[IOI 2023] 超车"
layout: "post"
diff: 省选/NOI-
pid: P9604
tag: ['2023', 'IOI', '交互题', 'O2优化']
---
# [IOI 2023] 超车
## 题目背景

这是一道交互题，你只需要实现代码中要求的函数。

你的代码不需要引用任何额外的头文件，也不需要实现 `main` 函数。

本题仅支持 C++ 语言提交。但请勿使用 C++14 (GCC 9)
## 题目描述

从布达佩斯机场到 Forrás 酒店有一条单向单车道的公路，公路的长度为 $L$ 公里。

IOI 2023 活动期间，有 $N+1$ 辆巴士在这条公路上行驶。巴士从 $0$ 到 $N$ 依次编号。巴士 $i$（$0 \le i \lt N$）计划在活动的第 $T[i]$ 秒从机场出发，行驶一公里用时 $W[i]$ 秒。巴士 $N$ 是备用巴士，行驶一公里用时 $X$ 秒。它从机场出发的时间 $Y$ 尚未确定。

巴士在这条公路上行驶时一般不允许超车，但允许在一些被称为**调度站**的地方进行超车。公路上一共有 $M$ 个调度站（$M \gt 1$），从 $0$ 到 $M - 1$ 依次编号，位于公路的不同位置。调度站 $j$（$0 \le j \lt M$）的位置在机场出发后沿公路的 $S[j]$ 公里处。调度站按照从机场开始的距离递增排列，也就是对于每个 $0 \le j \le M - 2$，有 $S[j] \lt S[j+1]$。首个调度站设在机场，最后一个设在酒店。也就是说，$S[0] = 0$，$S[M-1] = L$。

每辆巴士都以指定的最快速度行驶，除非它遇到前面有比它慢的巴士。在这种情况下，后面的快车会被前面的慢车压着，被迫以慢车的速度行驶。这种情况会持续到两车到达下一个调度站。在那里，快车会完成对慢车的超越。

形式化地说，对于满足 $0 \le i \le N$ 且 $0 \le j \lt M$ 的每组 $i$ 和 $j$，巴士 $i$ **到达**调度站 $j$ 的时间 $t_{i,j}$（以秒为单位）定义如下：对于每个 $0 \le i \lt N$，有 $t_{i,0} = T[i]$。另有 $t_{N,0} = Y$。对于满足 $0 \lt j \lt M$ 的每个 $j$：

* 定义巴士 $i$ 到达调度站 $j$ 的**期望到达时间** $e_{i,j}$（以秒为单位）为巴士 $i$ 到达调度站 $j-1$ 之后以全速行驶到达调度站 $j$ 的时间。也就是说，
  - 对于每个 $0 \le i \lt N$，有 $e_{i,j} = t_{i,j-1} + W[i] \cdot (S[j]-S[j-1])$；
  - 另有 $e_{N,j} = t_{N,j-1} + X \cdot (S[j]-S[j-1])$。
* 巴士 $i$ 到达调度站 $j$ 的时间，是巴士 $i$ 到达调度站 $j$ 的期望到达时间，以及其他比巴士 $i$ 早到调度站 $j-1$ 的巴士到达调度站 $j$ 的期望到达时间中的**最大值**。形式化地说，$t_{i,j}$ 是 $e_{i,j}$ 和所有满足 $0 \le k \le N$ 且 $t_{k,j-1} \lt t_{i,j-1}$ 的 $e_{k,j}$ 中的最大值。

IOI 组委会想要调度备用巴士（巴士 $N$）。你的任务是回答组委会的 $Q$ 个问题，问题的形式如下：给定备用巴士从机场出发的时间 $Y$（以秒为单位），它将于何时到达酒店？
## 输入格式

评测程序示例按以下格式读取输入：

* 第 $1$ 行：$L \; N \; X \; M \; Q$
* 第 $2$ 行：$T[0] \; T[1] \; \ldots \; T[N-1]$
* 第 $3$ 行：$W[0] \; W[1] \; \ldots \; W[N-1]$
* 第 $4$ 行：$S[0] \; S[1] \; \ldots \; S[M-1]$
* 第 $5 + k$ 行（$0 \le k \lt Q$）：问题 $k$ 的 $Y$
## 输出格式

评测程序示例按以下格式打印你的答案：

* 第 $1 + k$ 行（$0 \le k \lt Q$）：问题 $k$ 中 `arrival_time` 的返回值
## 样例

### 样例输入 #1
```
6 4 10 4 2
20 10 40 0
5 20 20 30
0 1 3 6
0
50

```
### 样例输出 #1
```
60
130

```
## 提示

**【实现细节】**

你的任务是实现以下函数：

```
void init(int L, int N, int64[] T, int[] W, int X, int M, int[] S)
```

* $L$：公路的长度
* $N$：常规（非备用）巴士的数量
* $T$：长度为 $N$ 的数组，描述常规巴士计划从机场出发的时间。
* $W$：长度为 $N$ 的数组，描述常规巴士的最大速度。
* $X$：备用巴士行驶一公里所需的时间
* $M$：调度站的数量
* $S$：长度为 $M$ 的数组，描述从机场到调度站的距离。
* 对于每个测试用例，这个函数都恰好调用一次，发生在对任何 `arrival_time` 的调用之前。

```
int64 arrival_time(int64 Y)
```

* $Y$：备用巴士（巴士 $N$）计划从机场出发的时间
* 这个函数应该返回备用巴士到达酒店的时间。
* 这个函数恰好调用 $Q$ 次。

---

**【例子】**

考虑以下调用序列：

```
init(6, 4, [20, 10, 40, 0], [5, 20, 20, 30], 10, 4, [0, 1, 3, 6])
```

忽略巴士 $4$（它还没有确定出发时间），下表列出了巴士到达每个调度站的期望时间和实际时间：

| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| $0$ | | $20$ | | $25$ | $30$ | | $40$ | $40$ | | $55$ | $55$ |
| $1$ | | $10$ | | $30$ | $30$ | | $70$ | $70$ | | $130$ | $130$ |
| $2$ | | $40$ | | $60$ | $60$ | | $100$ | $100$ | | $160$ | $180$ |
| $3$ | | $0$ | | $30$ | $30$ | | $90$ | $90$ | | $180$ | $180$ |

巴士到达调度站 $0$ 的时间就是它计划从机场出发的时间。也就是说，对于 $0 \le i \le 3$，$t_{i,0} = T[i]$。

到达调度站 $1$ 的期望时间和实际时间计算如下：

* 调度站 $1$ 的期望到达时间：
  - 巴士 $0$：$e_{0,1} = t_{0,0} + W[0] \cdot (S[1]-S[0]) = 20 + 5 \cdot 1 = 25$。
  - 巴士 $1$：$e_{1,1} = t_{1,0} + W[1] \cdot (S[1]-S[0]) = 10 + 20 \cdot 1 = 30$。
  - 巴士 $2$：$e_{2,1} = t_{2,0} + W[2] \cdot (S[1]-S[0]) = 40 + 20 \cdot 1 = 60$。
  - 巴士 $3$：$e_{3,1} = t_{3,0} + W[3] \cdot (S[1]-S[0]) = 0 + 30 \cdot 1 = 30$。
* 调度站 $1$ 的到达时间：
  - 巴士 $1$ 和 $3$ 早于巴士 $0$ 到达调度站 $0$，所以 $t_{0,1} = \max([e_{0,1},e_{1,1},e_{3,1}]) = 30$。
  - 巴士 $3$ 早于巴士 $1$ 到达调度站 $0$，所以 $t_{1,1} = \max([e_{1,1},e_{3,1}]) = 30$。
  - 巴士 $0$、巴士 $1$ 和巴士 $3$ 早于巴士 $2$ 到达调度站 $0$，所以 $t_{2,1} = \max([e_{0,1},e_{1,1},e_{2,1},e_{3,1}]) = 60$。
  - 没有比巴士 $3$ 更早到达调度站 $0$ 的巴士，所以 $t_{3,1} = \max([e_{3,1}]) = 30$。

```
arrival_time(0)
```

巴士 $4$ 行驶一公里需要 $10$ 秒，现在计划在第 $0$ 秒从机场出发。
这种情况下，下表列出每辆巴士的到达时间。
常规巴士期望和实际到达时间的唯一变动用下划线标注。

| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-: |
| $0$ | | $20$ | | $25$ | $30$ | | $40$ | $40$ | | $55$ | $\underline{60}$ |
| $1$ | | $10$ | | $30$ | $30$ | | $70$ | $70$ | | $130$ | $130$ |
| $2$ | | $40$ | | $60$ | $60$ | | $100$ | $100$ | | $160$ | $180$ |
| $3$ | | $0$ | | $30$ | $30$ | | $90$ | $90$ | | $180$ | $180$ |
| $4$ | | $0$ | | $10$ | $10$ | | $30$ | $30$ | | $60$ | $60$ |

由此可知巴士 $4$ 在第 $60$ 秒到达酒店。
因此，函数应该返回 $60$。

```
arrival_time(50)
```

巴士 $4$ 现在计划在第 $50$ 秒从机场出发。
这种情况下，与初始表格相比，常规巴士的到达时间没有变化。
下表列出了到达时间。

| $i$ | | $t_{i,0}$ | | $e_{i,1}$ | $t_{i,1}$ | | $e_{i,2}$ | $t_{i,2}$ | | $e_{i,3}$ | $t_{i,3}$ |
|:--:|:-:|:---------:|:-:|:---------:|:---------:|:-:|:---------:|:---------:|:-:|:---------:|:---------:|
| $0$ | | $20$      | | $25$      | $30$      | | $40$      | $40$      | | $55$      | $55$ |
| $1$ | | $10$      | | $30$      | $30$      | | $70$      | $70$      | | $130$     | $130$ |
| $2$ | | $40$      | | $60$      | $60$      | | $100$     | $100$     | | $160$     | $180$ |
| $3$ | | $0$       | | $30$      | $30$      | | $90$      | $90$      | | $180$     | $180$ |
| $4$ | | $50$      | | $60$      | $60$      | | $80$      | $90$      | | $120$     | $130$ |

巴士 $4$ 和较慢的巴士 $2$ 同时到达调度站 $1$，然后巴士 $4$ 超过了巴士 $2$。
接着，巴士 $4$ 在调度站 $1$ 和 $2$ 之间行驶时被巴士 $3$ 压着，导致它到达调度站 $2$ 的时间是第 $90$ 秒，而不是第 $80$ 秒。
在过了调度站 $2$ 之后，巴士 $4$ 被巴士 $1$ 压着，直到它们到达酒店。
巴士 $4$ 在第 $130$ 秒到达酒店。
因此，函数应该返回 $130$。

将每辆巴士从机场出发到不同距离的时间画成折线图。
图中 x 轴表示从机场出发的距离（以公里为单位），y 轴表示时间（以秒为单位）。
竖的虚线标注了调度站的位置。
不同颜色的实线（标注了巴士的编号）表示四辆常规巴士。
黑色的点线表示备用巴士。

| `arrival_time(0)` | `arrival_time(50)` |
|:-:|:-:|
| ![](https://cdn.luogu.com.cn/upload/image_hosting/rksq53n9.png) | ![](https://cdn.luogu.com.cn/upload/image_hosting/ua96w1x2.png) |

---

**【约束条件】**

* $1 \le L \le 10^9$
* $1 \le N \le 1\,000$
* $0 \le T[i] \le 10^{18}$（对于满足 $0 \le i \lt N$ 的每个 $i$）
* $1 \le W[i] \le 10^9$（对于满足 $0 \le i \lt N$ 的每个 $i$）
* $1 \le X \le 10^9$
* $2 \le M \le 1\,000$
* $0 = S[0] \lt S[1] \lt \cdots \lt S[M-1] = L$
* $1 \le Q \le 10^6$
* $0 \le Y \le  10^{18}$

---

**【子任务】**

1. （9 分）$N = 1, Q \le 1\,000$
1. （10 分）$M = 2, Q \le 1\,000$
1. （20 分）$N, M, Q \le 100$
1. （26 分）$Q \le 5\,000$
1. （35 分）没有额外的约束条件。


---

---
title: "歌姬"
layout: "post"
diff: 省选/NOI-
pid: P9620
tag: []
---
# 歌姬
## 题目背景

> 你如此一来就满足了吗？
>
> 没有想过去实现它吗?
>
> 为你而设的 为你而设的
>
> 可怜的制度化作温柔的义务
## 题目描述

现在 \*26 的头脑中想着 $n$ 件事情，它们形成一棵树．事情有现实和妄想两种状态．初始时所有事情都是妄想．不妨将事情 $1$ 假设成头脑中这棵树的根．那么一个事情 $u$ 的深度指从事情 $1$ 到事情 $u$ 的简单路径上的事情数（包含端点）．

我们称一个事情的集合 $S$ 为现实联通体，当其满足对于树上任意两个现实事情，其在树上简单路径（包括端点）中的事情都属于 $S$．极小现实连通体，即包含事情数最少的现实连通体．

随着时间推移，事情的状态可能发生一些变动．下面 \*26 和您提及了 $m$ 次事情的变动．变动分为以下两种不同的情况：

1. `Real u` 第 $u$ 件事情变成现实．
2. `Want u` 第 $u$ 件事情变成妄想．

每次变动后，\*26 会向您询问：目前至少还需要额外让几个事情变成妄想，才能使最小现实联通体中深度最小的事情的位置发生改变，或使当前头脑中不存在现实事情．
## 输入格式

第一行是两个整数 $n, m$ 表示事情个数和变动个数．

接下来 $n - 1$ 行每行两个整数表示树上的一条边．

接下来 $m$ 行形如：`Real u` 或 `Want u`．表示一次思考．其中 $1\le u\le n$．
## 输出格式

共 $m$ 行，每行一个整数，表示第 $i$ 次变动后，您向 \*26 提供的答案．
## 样例

### 样例输入 #1
```
7 8
1 2
1 5
2 3
2 4
5 6
5 7
Real 3
Real 4
Real 6
Real 7
Want 7
Real 2
Real 5
Want 3

```
### 样例输出 #1
```
1
1
1
2
1
1
2
2

```
## 提示

### 样例 #1 说明
举例最后一次变动结束后的情况．

此时树上除了事情 $1,3,7$ 是妄想，其余是现实．那么此时的最小现实联通体就是 $\{1,2,4,5,6\}$．

$\{2,4,5,6\}$ 不是最小现实连通体，因为存在两个现实事件如 $2,6$，其简单路径经过 $1$，而 $1$ 不在 $\{2,4,5,6\}$ 这个集合里；$\{1,2,3,4,5,6\}$ 同样不是最小现实联通体，因为存在一个现实联通体 $\{1,2,4,5,6\}$ 的大小小于它．

当我们令事情 $2,4$ 变成妄想后，现实事情仅剩下 $5,6$，这时最小现实连通体为 $\{5,6\}$．其中深度最小的事情由原来的 $1$ 变成了现在的 $5$．可以证明这个策略是最优策略之一．

### 数据点约束
|数据点编号|数据范围|
|:-:|:-:|
|$1,2$|$1\le n,m \le 20$|
|$3,4,5$|$1\le n,m \le 300$|
|$6,7,8$|$1\le n,m \le 3000$|
|$9,10,11,12$|$1\le n, m \le 39393$|
|$13 \sim 20$|$1\le n, m \le 2 \times 10^5$|

对于所有数据，保证在任意一次操作时，变动之前和变动之后事情的状态不一样．


---

---
title: "下次再见"
layout: "post"
diff: 省选/NOI-
pid: P9621
tag: []
---
# 下次再见
## 题目背景

> 在逝去的季节中 遗失的宝藏
>
> 是缺失一角的 珍贵拼图
>
> 就像白雪在街道上 温柔地堆积的样子
>
> 也将回忆相簿的空白 全部填满吧
## 题目描述

有一首由 $n$ 个圆圈组成的乐曲．玩家会 **等概率随机选定** $1 \sim n$ 中的一个位置开始游玩，顺序点击那个位置和之后的所有圆圈来完成乐曲的演奏．

对于每个圆圈的点击精准度存在四种判定，分别是 $\texttt{GREAT,OK,MEH,MISS}$．

存在一种机制：当连续 $K$ 次 $\texttt{MISS}$ 后，玩家会强制退出游戏；否则玩家会一直游玩直到点击完所有圆圈．

现在给出对于每个圆圈，玩家达成每一种判定的概率：对于第 $i$ 个圆圈，判定 $\texttt{GREAT},\texttt{OK},\texttt{MEH},\texttt{MISS}$ 的概率分别为 $P_{i,0}/100,\ P_{i,1}/100,\ P_{i,2}/100,\ P_{i,3}/100$．保证 $P_{i,0}+P_{i,1}+P_{i,2}+P_{i,3}=100$．

得分是衡量整段演奏的指标，它的计算方式是，假设整段演奏中出现了 $a$ 次 $\texttt{GREAT}$，$b$ 次 $\texttt{OK}$，$c$ 次 $\texttt{MEH}$，$d$ 次 $\texttt{MISS}$，那么演奏的得分为 $300a+100b+50c$．

你需要回答玩家得分的期望．

说明：如果强制退出游戏，那么计算得分时，整段演奏包括从开始的点击到最后一次判定 $\texttt{MISS}$ 的点击为止所有的点击．

在部分数据大小范围较大的测试点上，为了减小输入输出的交互量，我们采用了不同的输入方式．您需要在您的 c++ 代码中加入题目附件中提供的数据生成器．建议在阅读接下来的内容前先浏览一下生成器中提供的函数名称，这可以帮助您更好地理解输入格式．
## 输入格式

第一行包含两个整数 $Type,seed$．

当 $Type=1$ 的时候，您需要在读入 $seed$ 之后调用 `Ge.init(seed)` 来设置数据生成器的种子．否则您可以忽视 $seed$．

第二行包括两个整数 $n,K$．

接下来分两种情况：

- $Type=0$．接下来 $n$ 行，每行包括 $4$ 个整数，表示 $P_{i,0}\ P_{i,1}\ P_{i,2}\ P_{i,3}$．

- $Type=1$．接下来没有任何输入．您第 $i$ 次调用 ``Ge.get(a,b,c,d)`` 之后，$a,b,c,d$ 的值分别为 $P_{i,0}\ P_{i,1}\ P_{i,2}\ P_{i,3}$．
## 输出格式

一行一个整数，表示答案 $\bmod\ 998244353$．

说明：可以证明，答案能够表示为 $p/q$．您需要输出 $q$ 在 $\bmod\ 998244353$ 意义下的逆元和 $p$ 的乘积对 $998244353$ 取模后的结果．
## 样例

### 样例输入 #1
```
0 0
4 2
10 20 20 50
20 10 20 50
20 20 10 50
20 50 10 20

```
### 样例输出 #1
```
530317523
```
### 样例输入 #2
```
0 280114129
5 5
36 23 30 11
0 52 25 23
14 61 23 2
10 41 37 12
0 12 78 10

```
### 样例输出 #2
```
898420164
```
### 样例输入 #3
```
1 114
5141 919

```
### 样例输出 #3
```
800181066
```
## 提示

|测试点编号|数据范围|特殊性质|
|:-:|:-:|:-:|
|$1\sim 2$|$n\le 5$||
|$3\sim 4$|$n\le 50$||
|$5\sim 6$|$n\le 10^3$||
|$7\sim 8$|$n\le 10^5,K\le 10^3$||
|$9\sim 10$||$A$|
|$11\sim 12$||$B$|
|$13\sim 15$|$n,K\le 5\times 10^5$||
|$16\sim 20$||

$A$：保证所有位置的 $P_{i,3}$ 相等．

$B$：保证对于所有位置，$P_{i,3}$ 等于 $0$ 或等于 $100$．

---
对于编号在 $1\sim 15$ 的测试点，$Type=0$；对于编号在 $16\sim 20$ 的测试点，$Type=1$．

保证，对于全部数据，$0\le P_{i,0/1/2/3}\le 100$，$1\le K\le n\le 5\times 10^6$，$Type=0/1$，$1\le seed\le 10^9$．


---

---
title: "[ICPC 2020 Nanjing R] Certain Scientific Railgun"
layout: "post"
diff: 省选/NOI-
pid: P9624
tag: ['2020', 'O2优化', 'ICPC', '南京']
---
# [ICPC 2020 Nanjing R] Certain Scientific Railgun
## 题目描述

Misaka Mikoto is the third-ranked Level 5 esper in $\textit{Academy City}$ and has been nicknamed $\textit{Railgun}$ due to her signature move. One day, several evil robots invade Academy City and Misaka is planning to terminate all of them.

Consider Academy City as a 2-dimensional plane. There are $n$ robots in total and the position of the $i$-th robot is $(x_i, y_i)$. Misaka will start moving from $(0, 0)$ and her railgun ability will terminate all robots sharing the same $x$- or $y$-coordinate with her. More formally, if Misaka is now located at $(x_m, y_m)$, all robots whose $x_i = x_m$ or $y_i = y_m$ will be terminated.

As Misaka hates decimals and Euclidean geometry, she will only move from one integer point to another integer point and can only move horizontally (parallel to the $x$-axis) or vertically (parallel to the $y$-axis). As moving among the city is quite tiresome, Misaka asks you to calculate the minimum distance she has to move to terminate all robots.

Recall that an integer point is a point whose $x$-coordinate and $y$-coordinate are both integers.
## 输入格式

There are multiple test cases. The first line of the input contains an integer $T$ indicating the number of test cases. For each test case:

The first line contains an integer $n$ ($1 \leq n \leq 10^5)$ indicating the number of robots.

For the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($-10^9 \le x_i, y_i \le 10^9$) indicating the position of the $i$-th robot.

It is guaranteed that the sum of $n$ of all test cases will not exceed $10^5$.
## 输出格式

For each test case output one line containing one integer indicating the minimum distance Misaka needs to move to terminate all robots.
## 样例

### 样例输入 #1
```
3
2
0 1
1 0
4
1 1
-3 -3
4 -4
-2 2
4
1 100
3 100
-100 1
3 -100

```
### 样例输出 #1
```
0
8
4

```
## 提示

### Note

For the second sample test case, Misaka should first go to $(0, 1)$, then to $(0, 2)$, then to $(0, -3)$, then to $(0, -4)$.

For the third sample test case, Misaka should first go to $(1, 0)$, then to $(1, 1)$, then to $(3, 1)$.
## 题目翻译

平面上有 $n$ 个点。御坂美琴初始位于 $(0,0)$。她可以随意平行于 $x$ 轴或 $y$ 轴移动，并可以在任意位置使用电磁炮消灭所有 $x$ 或 $y$ 坐标与她相同的点。要消灭所有点，求她最小的移动距离。

$T$ 组数据，$n,\sum n\le 10^5$，$|x_i|,|y_i|\le 10^9$。


---

---
title: "[ICPC 2022 Jinan R] Torch"
layout: "post"
diff: 省选/NOI-
pid: P9668
tag: ['2022', 'O2优化', 'ICPC', '济南']
---
# [ICPC 2022 Jinan R] Torch
## 题目描述

Prof. Pang and Prof. Shou go to explore a cave together. Prof. Pang walks ahead of Prof. Shou. 

Each of them has a torch for illumination. The torches need fuel to burn. Prof. Pang's torch can burn for $a_1$ seconds once it has been refilled, and it takes $b_1$ seconds to refuel the torch after it burns out. Prof. Shou's torch can burn for $a_2$ seconds once it has been refilled, and it takes $b_2$ seconds to refuel the torch after it burns out. The person who is refueling the torch cannot walk simultaneously. For safety reasons, they cannot refuel the torch until the fuel runs out. 

Because Prof. Pang is too fat and the cave is too narrow, Prof. Shou cannot surpass Prof. Pang during the exploration, which means that Prof. Shou is at least 1 unit behind Prof. Pang. 

Each of them can walk forward a distance of 1 unit per second when his torch is burning. Every second, Prof. Pang moves first, then Prof. Shou does. In order to get to their destination earlier, they will move as long as they can walk forward. 

Now Prof. Shou has $n$ questions, and for the $i$-th question, he wants to know that at time $q_i$, how many units of the distance he has moved forward from the starting point? Prof. Shou starts 1 unit behind Prof. Pang. The initial time is 0. Both Prof. Pang and Prof. Shou refueled the torch before the initial time.
## 输入格式

The first line contains one integer $T~(1\le T \le 10^5)$, the number of test cases.

For each test case, the first line contains 5 integers $a_1, b_1, a_2, b_2, n~(1 \le a_1, b_1, a_2, b_2, n \le 10^6)$ denoting the time Prof. Pang's torch can burn, the time for Prof. Pang to refuel his torch, the time Prof. Shou's torch can burn, the time for Prof. Shou to refuel his torch, and the number of Prof. Shou's queries. Each of the next $n$ lines describes a query. Query $i$ is denoted by one integer $q_i~(1 \le q_i \le 10^{16})$.

It is guaranteed that over all test cases, each of the following numbers is no more than $10^6$:

- the sum of $a_1$, 
- the sum of $a_2$, 
- the sum of $b_1$, 
- the sum of $b_2$, 
- and the sum of $n$.
## 输出格式

For each query, print one line containing the answer -- the number of units that Prof. Shou has walked forward from the starting point.
## 样例

### 样例输入 #1
```
3
2 3 2 4 2
7
8
1 1 1 1 2
3
4
9 7 10 3 5
5
10
20
30
50
```
### 样例输出 #1
```
3
4
2
2
5
9
13
18
28
```
## 题目翻译

## 题目描述

胖子和瘦子在一个山洞里行走，胖子在瘦子前面。每个人都有一支火把。

胖子的火把填满燃料后可以燃烧 $a_1$ 秒，在熄灭后需要花费 $b_1$ 秒填充燃料。

瘦子的火把填满燃料后可以燃烧 $a_2$ 秒，在熄灭后需要花费 $b_2$ 秒填充燃料。

每个人只能在自己的火把燃烧时前进，速度为 $1\operatorname{m/s}$。

因为胖子太胖，所以瘦子只能跟在胖子后面而不能超过胖子。

每一秒胖子先移动，之后瘦子再移动。

初始时两个人的火把都已经填满了燃料，瘦子在胖子后面 $1 \operatorname{m}$。

给定 $n$ 个询问，每次给一个正整数 $q_i$，表示查询第 $q_i$ 秒后，瘦子的移动距离。

## 输入格式

**本题包含多组测试数据**

第一行一个正整数 $T$，表示数据组数。

对于每组数据：

第一行五个正整数 $a_1, b_1, a_2, b_2, n$，含义见题目描述。

接下来 $n$ 行，每行一个正整数 $q_i$，表示询问。

## 输出格式

每组数据输出 $n$ 行，表示每个询问的答案，即第 $q_i$ 秒后瘦子的移动距离。

## 数据范围

下面 $\sum n$ 表示所有数据的 $n$ 之和，$\sum a_1, \sum b_1, \sum a_2, \sum b_2$ 同理。

$1 \le T \le 10^5$，$1 \le a_1, b_1, a_2, b_2 \le 10^6$，$\sum a_1, \sum b_1, \sum a_2, \sum b_2, \sum n \le 10^6$，$1 \le q_i \le 10^{16}$。


---

---
title: "[ICPC 2022 Jinan R] Set of Intervals"
layout: "post"
diff: 省选/NOI-
pid: P9674
tag: ['2022', 'O2优化', 'ICPC', 'Ad-hoc', '分类讨论', '济南']
---
# [ICPC 2022 Jinan R] Set of Intervals
## 题目描述

Prof. Pang has a multi-set of intervals $S=\{[l_i,r_i]\}$($l_i<r_i$).

Prof. Pang will perform the following operation for $|S|-1$ times:

- Select two intervals $[a,b]$ and $[c,d]$ from $S$, and then choose two integers $x,y$ satisfying $x\in [a,b], y\in [c,d], x<y$. After that, delete $[a,b]$ and $[c,d]$ from $S$, and add $[x,y]$ to $S$.

It's easy to find that $S$ contains exactly one interval after the operations, and Prof. Pang will get the interval as a gift.

Now Prof. Pang wants you to calculate how many different intervals he can get.
## 输入格式

The first line contains one integer $T~$($1\le T \le 10^4$), the number of test cases.

For each test case, the first line contains one integer $n~$($1\le n\le 10^5$) --- the size of $S$. Each of the following $n$ lines contains two integers $l_i$ and $r_i~$($1\le l_i<r_i\le 10^9$), describing the $i$-th interval in $S$.

It is guaranteed that the sum of $n$ over all test cases is no more than $10^5$.
## 输出格式

For each test case, output one line containing the answer to Prof. Pang's question.
## 样例

### 样例输入 #1
```
4
1
1 1000000000
2
1 1000000000
1 1000000000
4
1 2
3 4
5 6
7 8
4
1 3
2 4
5 8
6 7
```
### 样例输出 #1
```
1
499999999500000000
26
28
```
## 题目翻译

蓝蓝有一个元素全为闭区间的可重集 $S=\{[l_i,r_i]\}$($l_i<r_i$)。

蓝蓝将会执行以下操作 $n-1$ 次：
- 从 $S$ 内选择两个闭区间 $[a,b]$ 和 $[c,d]$，再选择两个整数 $x,y$ 满足 $x\in [a,b], y\in [c,d], x<y$，然后从 $S$ 中删去 $[a,b]$ 和 $[c,d]$，并把 $[x,y]$ 添加进 $S$。

显然最终 $S$ 中有且仅有一个区间。现在蓝蓝想知道她可以获得多少不同的区间。


---

---
title: "[CEOI 2023] Balance"
layout: "post"
diff: 省选/NOI-
pid: P9731
tag: ['2023', 'Special Judge', 'O2优化', 'CEOI（中欧）']
---
# [CEOI 2023] Balance
## 题目背景

翻译自 CEOI2023 Day1 T3 [Balance](https://www.ceoi2023.de/wp-content/uploads/2023/09/3-balance.pdf)。
## 题目描述

由于黑客对评测机的攻击，组委会决定重测所有提交记录。

有 $N$ 台评测机，$T$ 个题目（编号为 $1, 2, \cdots, T$）。组委会已经确定，每台评测机要评测哪些提交（数目相同，都是 $S$ 个提交，保证 $S$ 是 $2$ 的整数次幂）。在接下来的 $S$ 分钟内，每分钟每台评测机会评测一个提交。

每个提交都会提交至某个题目。由于存数据的机器太脆弱了，所以要求，对于所有题目和任意两个时刻，在这两个时刻，这个题的被评测的提交的数量之差不超过 $1$。

请构造一组方案，使得满足上面的条件。
## 输入格式

第一行输入 $N, S, T$。

接下来 $N$ 行，每行输入 $S$ 个整数，表示这个评测机被分配到的提交的题目编号。
## 输出格式

输出 $N$ 行，每行 $S$ 个数，表示这个评测机按顺序要评测的提交的题目编号。

可以证明，一定存在一组解。
## 样例

### 样例输入 #1
```
3 2 3
1 2
2 3
2 3
```
### 样例输出 #1
```
2 1
3 2
2 3
```
### 样例输入 #2
```
3 4 3
2 3 2 2
2 3 3 2
2 2 3 2
```
### 样例输出 #2
```
2 2 2 3
3 2 3 2
2 3 2 2
```
## 提示

保证存在正整数 $k$ 使得 $S = 2 ^ k$，$1 \le N, S, T \le 10 ^ 5$，$NS \le 5 \times 10 ^ 5$。

- Subtask 1（$10$ 分）：$S = 2$ 且 $N, T \le 20$。
- Subtask 2（$15 + 5 + 5$ 分）：$S = 2$。
- Subtask 3（$15 + 5 + 5$ 分）：$NS \le 10 ^ 4$。
- Subtask 4（$20 + 10 + 10$ 分）：没有其它限制。

对于后三个子任务，存在部分分（对应括号中的分数）：

- 第一个数表示如果能解决满足 $T \le N$ 且对于每个题目的提交数量均整除 $S$ 时的所有测试点能得到的分数。
- 第二个数表示如果能解决满足 $T \le N$ 时的所有测试点能多得到的分数。
- 第三个数表示如果解决了整个 Subtask 时能多得到的分数。

在洛谷上，本题分为 $10$ 个子任务。对于原来的后三个 Subtask，在本题中分别按顺序分为三个子任务（如原 Subtask 3 就是子任务 $5, 6, 7$），有依赖关系。


---

---
title: "[CEOI 2023] The Ties That Guide Us (incursion)"
layout: "post"
diff: 省选/NOI-
pid: P9733
tag: ['2023', '交互题', 'Special Judge', 'O2优化', 'CEOI（中欧）']
---
# [CEOI 2023] The Ties That Guide Us (incursion)
## 题目描述

你用销售机器人的利润雇佣了一名助手，现在你准备好去拿走装有 CEOI 奖章的保险箱了。

保险箱位于一所由 $n$ 个房间所组成的大学建筑内，这些房间由 $n-1$ 扇门连接。每个房间都可以从其他任何房间到达，且每个房间最多与 $3$ 扇门相连。  
你和你的助手都有描述建筑物内房间相连情况的平面图，但是你们两个各自拥有的平面图虽然描述了相同的房间结构布局，但是房间和门的编号可能不同。

在比赛的第二天，委员会忙于处理赛时通知和选手提问。这将是接近装着奖牌的保险箱的完美机会。

你的助手会首先搜索整栋大楼。一旦他找到保险箱所在的房间，它就会给你留下前往那个房间的提示。由于手机不能带进赛场，他用了去年 BOI 留下的几乎无限供应的领带。由于这些领带完全相同无法区分，你能获得的信息就是他在任何给定房间里所留下的领带数量。由于一个房间内过多的领带非常可疑，因此任何单个房间内领带的最大数量应当尽可能少（参阅评分部分）。

之后，你计划在上厕所的时候溜出去，利用助手留下来的领带找到有保险箱的房间。保险箱藏在房间里，所以你进入带有保险箱的房间时，必须依靠领带识别这个房间；此外，由于“上厕所”时间过长会被发现，你必须尽快找到保险箱。你最多可以走过 $d+30$ 扇门，其中 $d$ 是你的初始位置到保险箱所在位置的最短路径上的门数量。若重复穿过同一扇门，则每次都计入。

因此，你需要编写一个程序，告诉助手需要在每个房间留下多少条领带，并引导你前往带有保险箱的房间。
## 输入格式

本题为函数交互题。

对于每个测试点，你的程序会运行两次。

你需要实现如下两个函数（函数原型已给出）：
```
vector<int> mark(vector<pair<int,int>> F, int safe);
```
- $F$: 包含了 $n-1$ 个二元组 $(u,v)$，其中 $1 \le u,v \le n$ 并且保证 $u \neq v$，代表在助手的地图上，$u$ 号房间和 $v$号房间之间由一扇门相连。
- $\mathrm{safe}$: 表示你的助手的地图上保险箱所在的房间编号。

该函数应当返回一个长度为 $n$ 的 `vector<int>` $v$，其中每个元素 $v_i$ 代表你的助手应当在他地图上 $i+1$ 号房间留下的领带数量。你应当保证 $0 \le v_i \le 10^9$。

```
void locate(vector<pair<int,int>> F,int curr,int t);
```
- $F$: 包含了 $n-1$ 个二元组 $(u,v)$，其中 $1 \le u,v \le n$ 并且保证 $u \neq v$，代表在你的地图上，$u$ 号房间和 $v$号房间之间由一扇门相连。
- $\mathrm{curr}$: 你目前所在的房间编号。
- $t$: 在你当前所处的房间中，找到的领带数量。

在如下的叙述中，房间编号采用你地图的编号方案。

在实现函数 `locate` 的过程中，你可以调用如下函数：
```
int visit(int v);
```
以此来从你目前所在的房间 $u$ 移动到一个相邻的房间 $v$。你需要保证操作合法，即 $1 \le v \le n,(u,v) \in F\:\vee (v,u) \in F$。

该函数返回一个非负整数 $k$，表示你在房间 $v$ 中找到的领带个数。

该函数调用的次数不应超过 $d+30$，其中 $d$ 是你的起点到终点的最短距离。

当函数 `locate` 终止时，你应当处于带有保险箱的房间内。

对于每个测试点，第一次运行程序时调用 `mark`，第二次调用 `locate`。

如果 `visit` 调用次数过多、调用不合法或在 `mark` 中被调用，你的程序将会被终止运行，提交将会被判**错误**。  
你的程序不得写入或读取 `stdin` 或 `stdout`，否则将会被判**违反安全规定**。  
但是你可以随便往 `stderr` 输出，没人管这个。

你需要在源代码文件开头加上 `#include "incursion.h"`。

你应当将程序与 `sample_grader.cpp` 链接以进行本地测试。

下面是示例评分器的说明，请参阅 `sample_grader.cpp` 以获取操作说明。

为简单起见，本评分器不会运行你的程序两次，而是在一次运行中调用两个函数各一次。附件中包含了一个 `sample_grader.cpp` 的示例实现。

注意：该实现不与评测所用的实现相同，禁止采用 Hack 评分器的方式试图通过本题！

## 提示

### 评分细则

共有 4 个 subtask。对于每个测试点，$2 \le n \le 45000$。

Subtask 1 (30 points)，保证没有一个房间有三扇门相连。
Subtask 2 (30 points). 有且仅有一个房间有两扇门相连。
Subtask 3 (40 points). 没有特殊性质。

对于每个测试点，假设使用领带最多的房间用了 $T_{\max}$ 条领带，
- $T_{\max}<2$，你将会获得该测试点 $100\%$ 的分数。
- $T_{\max}=2$，你将会获得该测试点 $40\%$ 的分数。
- $2 < T_{\max} \le 10^9$，你将会获得该测试点 $30\%$ 的分数。

### 交互库使用方法
**注意洛谷提供的交互库与原版不同。**

请使用 `g++ -std=c++17 -Wall -O2 -o test interactive_lib.cpp xxx.cpp` 编译，其中 `xxx.cpp` 是你的程序名字。

示例交互库首先从标准输入读入三个正整数, $n$, $s$, $seed$，表示点数、起点的原编号、随机数种子。

然后读入 $n-1$ 行，每行两个正整数 $u,v$，表示原树的一条边。其中需保证 $1 \le u < v \le n$。
然后读入一行一个字符串，表示打乱规则。

**你不需要在意打乱序号的具体实现。该实现与最终评测所用交互库不一定相同。**

接下来交互库将会调用一次 `mark`，一次 `locate`。注意交互库可能会打乱序号。

交互库可能向终端输出以下信息：

- `Invalid input.` 输入不合法。
- `Invalid call to visit. (ALICE CALLED VISIT)` 在 `mark` 中调用 `visit`。
- `Invalid call to visit. (INDEX ERROR)` 访问了不合法的点。
- `Invalid call to visit. (NOT CONNECTED)` 访问的点和当前所在的点没有直接的边相连。
- `Invalid call to visit. (TOO MANY VISITS)` 调用 `visit` 次数过多。
- `Invalid return value of mark.` `mark` 的返回值不合法。即返回的 `vector` 长度不为 $n$ 或者有小于 $0$ 或大于 $10^9$ 的数。
- `Not correct: current position is X` 最终并不在目标点，你应该在 $X$ 点（在第二张地图上）。
- `Correct: at most X tie(s) per room.` 到达目标点，且用领带最多的房间使用了 X 条领带。

最终评测时，只会返回正确与否的信息。


---

---
title: "[COCI 2022/2023 #2] Kruhologija"
layout: "post"
diff: 省选/NOI-
pid: P9739
tag: ['2022', '交互题', 'Special Judge', 'COCI（克罗地亚）']
---
# [COCI 2022/2023 #2] Kruhologija
## 题目背景

**这是一道交互题。**
## 题目描述

你是一只蚂蚁，你现在在一块漂浮在空中的面包上！

面包可以看成由若干个正方体组成的立体图形，这个图形在高度上最多只有一个方块，并且是连通的。

![](https://cdn.luogu.com.cn/upload/image_hosting/k9o74nmn.png)

左图是第一个样例，右图是不合法（不连通）的一个例子。

我们记这些正方体构成的立体图形有 $n$ 个面。你现在正在一个小块的一个面上，面向未知的方向。你可以进行 $q$ 次操作，每次你可以：

- $\texttt{K}$：向你面向的方向走一格；
- $\texttt{L}$：向左转 $90\degree$；
- $\texttt{D}$：向右转 $90\degree$；
- $\texttt{X}$：在当前格子上放置 / 删除标记。

注意：当你走到了边缘时，继续往前走，你会走到另一个面上，所以你可以向任意方向行走任意步。

一个立方体上的洞的定义为：完全被立方体包围的空间的一部分。

你很喜欢洞，所以你想要求出这个立方体上洞的数量。
## 输入格式

这是一道交互题。你需要输出面包上洞的数量。你可以向交互库发送一次操作，库会返回一个值。值为 $0$ 表示目前格子上没有标记，为 $1$ 则有。如果你的操作次数超过了 $q$ 次，你的答案将会被认为不正确。如果你找到了答案，输出 `! g`，$g$ 表示你在面包上找到了 $g$ 个洞。
## 样例

### 样例输入 #1
```


0


1



0

```
### 样例输出 #1
```
X
K

L
L
K

X
D
D
K

! 1
```
### 样例输入 #2
```


0

0

0

1

```
### 样例输出 #2
```
X
K

K

K

K

! 0
```
## 提示

|$\text{Subtask}$|分值|特殊性质|
|:-:|:-:|:-:|
|$1$|$49$|$n\le 40$，$q=20000$，面包上最多有一个洞|
|$2$|$61$|$n\le 200$，$q=20000$|


---

---
title: "「KDOI-06-S」签到题"
layout: "post"
diff: 省选/NOI-
pid: P9747
tag: ['2023', '洛谷原创', 'O2优化', '洛谷月赛']
---
# 「KDOI-06-S」签到题
## 题目背景

你正在追番，突然家长进来了，于是你假装在写一道数据结构题。


## 题目描述

定义一个长度为 $m$ 的数组 $v$ 是合法的，当且仅当经过若干次以下操作可以使 $v$ 中的所有元素相等：

* 选择四个整数 $a,b,c,d$（$1\leq a\leq b\leq m$，$1\leq c\leq d\leq m$）满足 $b-a+1=d-c+1$，且 $v_a\operatorname{~or~}v_{a+1}\operatorname{~or~}\cdots\operatorname{~or~}v_b=v_c\operatorname{~or~}v_{c+1}\operatorname{~or~}\cdots\operatorname{~or~}v_d$，其中 $\operatorname{or}$ 表示按位或运算。接下来，将区间 $[a,b]$ 的数**复制下来再覆盖**到区间 $[c,d]$。**注意：区间 $\bm{[a,b]}$ 和 $\bm{[c,d]}$ 可能会相交。**

给出一个长度为 $n$ 的序列 $a_1,a_2,\ldots,a_n$ 以及 $q$ 次询问，每次询问给定两个正整数 $l,r$，你需要回答区间 $[l,r]$ 内的最长合法子区间的长度。
## 输入格式

从标准输入读入数据。

**本题含有多组测试数据。**

输入的第一行包含两个整数 $T,id$，表示数据组数和测试点编号（样例的测试点编号为 $0$）。

对于每组测试数据数据，第一行两个正整数 $n,q$，表示序列长度与询问次数。

第二行 $n$ 个正整数 $a_1,a_2,\ldots,a_n$，表示序列 $a$ 中每个元素的值。

接下来 $q$ 行，每行两个正整数 $l,r$，表示询问的区间。
## 输出格式

输出到标准输出。

对于每组测试数据的每次询问，输出一行一个整数，表示区间 $[l,r]$ 内的最长合法子区间的长度。
## 样例

### 样例输入 #1
```
2 0
7 2
0 4 2 6 0 6 6
1 7
2 3
3 1
1 2 3
1 3
```
### 样例输出 #1
```
7
1
3
```
## 提示

**【样例解释 #1】**

对于第一组数据的第一个询问，最长的合法子区间为 $[1,7]$，以下是一种可能的操作序列：

1. 选择区间 $[1,4]$ 和 $[2,5]$，将区间 $[1,4]$ 中的数**先复制**下来，再覆盖到 $[2,5]$ 上，此时序列变为 $[0,0,4,2,6,6,6]$。

2. 选择区间 $[5,6]$ 和 $[3,4]$，此时序列变为 $[0,0,6,6,6,6,6]$。

3. 选择区间 $[4,7]$ 和 $[1,4]$，此时序列变为 $[6,6,6,6,6,6,6]$。

注意，操作**并不会**真正的修改原序列中的值。

对于第一组数据的第二个询问，最长的合法子区间为 $[2,2]$ 和 $[3,3]$。

**【样例 #2】**

见选手目录下的 `binary/binary2.in` 与 `binary/binary2.ans`。

这个样例满足测试点 $5\sim 8$ 的条件限制。

**【样例 #3】**

见选手目录下的 `binary/binary3.in` 与 `binary/binary3.ans`。

这个样例满足测试点 $25\sim 31$ 的条件限制。

**【样例 #4】**

见选手目录下的 `binary/binary4.in` 与 `binary/binary4.ans`。

这个样例满足测试点 $46\sim 50$ 的条件限制。

***

**【数据范围】**

对于所有数据保证：$1\le T\le 2\times 10^5$，$1\le n,q,\sum n,\sum q\le 2\times 10^6$，$0\le a_i < 2^{30}$。

| 测试点编号 | $\sum n\le$ | $\sum q\le$ | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $5$ | $5$ | 无 |
| $2\sim 4$ | $100$ | $100$ | 无 |
| $5\sim 8$ | $1000$ | $1000$ | 无 |
| $9\sim 14$ | $1000$ | $10^6$ | 无 |
| $15\sim 19$ | $6000$ | $10^6$ | 无 |
| $20\sim 24$ | $50000$ | $10$ | 无 |
| $25\sim 31$ | $10^5$ | $10^5$ | B |
| $32\sim 36$ | $2\times 10^5$ | $2\times 10^5$ | 无 |
| $37\sim 41$ | $5\times 10^5$ | $10^6$ | B |
| $42\sim 44$ | $5\times 10^5$ | $5\times 10^5$ | 无 |
| $45$ | $2\times 10^6$ | $2\times 10^6$ | A |
| $46\sim 50$ | $2\times 10^6$ | $2\times 10^6$ | 无 |

+ 特殊性质 A：保证序列 $a$ 中的每个数均在 $[0,2^{30})$ 之间均匀随机生成。
+ 特殊性质 B：保证对于任意 $1\le i\le n$，$a_i\le 3$。

***

**【提示】**

本题输入输出量较大，请使用适当的 I/O 方式。

**请注意常数因子对程序运行效率产生的影响。**

KDOI 出题组温馨提示：**多测不清空，爆零两行泪。**


---

---
title: "[COCI 2022/2023 #3] Baltazar"
layout: "post"
diff: 省选/NOI-
pid: P9758
tag: ['2022', 'O2优化', 'COCI（克罗地亚）']
---
# [COCI 2022/2023 #3] Baltazar
## 题目描述

Baltazar 准备去度假。他现在在 Baltazargrad，正想去 Primosten 旅游。为了抵达那里，他需要穿过许多个城市。一共有 $n$ 个城市，被 $m$ 条双向道路所联接。Baltazargrad 编号为 $1$，Primosten 编号为 $n$。

Baltazar 不确定从 Baltazargrad 去 Primosten 的路线，所以他将会使用 GPS，这会指引他以最短路线抵达。

但 Blatazar 真的很爱旅游，而且他可以将魔法药水使用在任何一条路上（即使他没有经过），从而将路的长度增长 $2$ 千米。但他仅能使用一次药水。

不久他意识到，他必须在中午之前在 Primosten 的 Zora 旅馆入住。所以他不能过分增加最短路的总长度。他现在想知道，一共有多少条路可以让他使用药水，使得最短路的长度恰好增加 $1$ 千米。
## 输入格式

多组数据。

第一行一个整数 $t$，表示数据组数。

接下来对于每组数据，第一行两个整数 $n,m$，分别表示城市的数量和城市之间道路的数量。

接下来的 $m$ 行，每行三个整数 $a_i,b_i,w_i$，表示一条连接城市 $a_i,b_i$ 且长度为 $w_i$ 的道路。两个城市间最多只有一条道路。

保证所有城市是相互联通的。也就是说，任何一对城市，都有一条相互可达的路径，但不一定是直接相连。

保证所有数据的 $n, m$ 各自之和均不超过 $300000$。


## 输出格式

第一行输出一个整数 $c$，表示 Baltazar 可以使用魔法药水的道路数量。

接下来一行 $c$ 个整数，以编号升序输出所有满足条件的道路。
## 样例

### 样例输入 #1
```
3
6 6
1 2 2
1 3 2
2 4 2
3 5 2
4 5 1
5 6 2
6 6
1 2 2
1 3 2
2 4 2
3 5 2
4 5 3
5 6 2
6 7
1 2 2
1 3 2
2 4 2
3 5 2
4 5 1
5 6 2
1 6 7
```
### 样例输出 #1
```
2
2 4
0

3
2 4 6
```
## 提示

**【样例解释】**

城市和道路如图所示。如果 Baltazar 把他的魔法药水使用在第二条道路上（连接城市 $3$ 和 $5$ 的），那么城市 $1$ 和 $n$ 之间最短的距离将会增加 $1$。

![](https://cdn.luogu.com.cn/upload/image_hosting/jeaidgpn.png)

**【数据范围】**

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $15$ | $n,m \leq 1000$ |
| $2$ | $30$ | 有一条在起点终点之间的道路，这条道路的长度满足恰好比两个城市之间的最短路线长 $1$ 千米。 |
| $3$ | $65$ | 无特殊性质 |

对于 $100\%$ 的数据，满足 $1\le t \le 10000,2\leq n \leq 3\times10^5,1\le m\le \min(3\times 10^5,\dfrac{n\times (n-1)}{2}), 1\le a_i,b_i\le n,a_i\neq b_i,1\le w_i\le 10^9$。

本题满分 $110$ 分。


---

---
title: "[COCI 2022/2023 #3] Skrivača"
layout: "post"
diff: 省选/NOI-
pid: P9760
tag: ['2022', 'O2优化', 'COCI（克罗地亚）']
---
# [COCI 2022/2023 #3] Skrivača
## 题目描述

Marin 和 Luka 正在他们的房子里玩一个流行的儿童游戏——捉迷藏。这个房子共有 $n$ 个房间，有 $m$ 对房间通过一扇门连接。房间从 $1$ 到 $n$ 编号，并且任意两个房间之间是存在道路相连通的。

Luka 想出了一个躲藏策略：当 Marin 进入房间 $v$ 时，Luka 会躲在房间 $a_v$ 里。在游戏的开始 Marin 选择他开始找人的房间 $v_0$，Luka 躲在房间 $a_{v_0}$里。在游戏的每一个回合，首先由 Marin 选择一个与当前相邻房间 $u$ 并进入。随后 Luka 知道 Marin 在房间 $u$ 中所以参照他的躲藏方式他会躲到房间 $a_u$ 中。注意到 Luka 可以选择任何抵达房间 $a_u$ 的路线并且在游戏的一个回合中他可以经过任意数量的房间。

定义 Marin 找到了 Luka 为当他们两个都在同一个房间中的时候，这时游戏结束。

Marin 发现了 Luka 的躲藏策略，所以她想要你考虑从每一个房间出发时，她是否可以在有限回合找到 Luka。如果可以，计算在理想状态下（Marin 尽可能减少回合数，Luka 尽可能增加回合数）最少需要的回合数。
## 输入格式

第一行两个整数 $n,m$，分别表示房间的数量和相连房间的对数。

第二行 $n$ 个整数 $a_i$，表示 Luka 的躲藏策略。

在接下来的 $m$ 行中，每行两个整数 $x_i,y_i$，表示这两个房间是相连的。任意两个房间最多只有一条直接相连的道路。
## 输出格式

一行 $n$ 个数，表示最少需要的回合数。如果无法在有限步中结束游戏，输出 $-1$。
## 样例

### 样例输入 #1
```
4 4
3 4 1 2
1 2
2 3
3 4
4 1
```
### 样例输出 #1
```
-1 -1 -1 -1
```
### 样例输入 #2
```
8 9
2 3 2 1 6 5 6 7
1 2
1 3
2 4
3 4
4 5
4 6
6 7
5 7
4 8
```
### 样例输出 #2
```
1 2 2 2 1 1 1 1
```
### 样例输入 #3
```
9 8
1 9 1 1 1 9 9 9 1
1 2
2 3
3 4
4 5
5 6
6 7
7 8
8 9
```
### 样例输出 #3
```
0 1 1 2 1 1 2 1 1
```
## 提示

**【样例解释 #2】**

Marin 第一回合从房间 $4$ 进入房间 $8$，第二回合回到房间 $4$。Luka 需要经过房间 $4$ 才能从房间 $7$ 到房间 $1$。所以可以在两个回合找到。

**【数据范围】**

| 子任务 | 分值 | 特殊性质 |
| :----------: | :----------: | :----------: |
| $1$ | $15$ | $n\le 1000,m\le2000$ |
| $2$ | $25$ | $m=n-1$ |
|$3$ | $30$| Luka 的躲藏策略满足他永远不会躲在与 Marin 当前所在房间相邻或相同的房间，并且房子的结构满足游戏可以在最多有 $5$ 个不同房间独立于 Luka 的躲藏策略之外的情况下结束游戏。 
| $4$ | $40$ | 无特殊性质 |

对于 $100\%$ 的数据，满足 $1\leq n \leq 2\times10^5,n-1\le m\le \min(5\times 10^5,\dfrac{n\times (n-1)}{2}), 1\le a_i,x_i,y_i\le n,x_i\neq y_i$。

本题满分 $110$ 分。


---

---
title: "[HUSTFC 2023] 逆 KMP"
layout: "post"
diff: 省选/NOI-
pid: P9770
tag: ['2023', 'O2优化', '高校校赛']
---
# [HUSTFC 2023] 逆 KMP
## 题目描述

Walk Alone 是一个字符串大师，但是他已经对传统的字符串算法感到无聊，如 KMP 算法，所以他最近在思考逆向的 KMP。下面是他提出的问题：

给你一个长度为 $n$ 的整数序列 $a$，对于任意的整数 $i\ (1\le i\le n)$，满足 $0\le a_i<i$。你需要构造另一个整数序列 $s$，满足以下条件：
- 序列 $s$ 的长度为 $n$，并且其中任意元素 $s_i$ 满足 $1\le s_i\le n$；
- 对于所有的整数 $i\ (1\le i\le n)$ 和 $j\ (1\le j\le a_i)$，满足 $s_{j}=s_{i-a_i+j}$；
- 满足上述条件的前提下，序列 $s$ 中出现的不同元素的数量**最多**。

当然，Walk Alone 可以很轻松地解决这道题，但他想把这道题当作对你的考验。

## 输入格式

第一行包含一个整数 $n\ (1\le n\le 2\cdot 10^5)$，表示序列 $a$ 的长度。

第二行包含 $n$ 个整数，其中第 $i$ 个整数定义为 $a_i\ (0\le a_i<i)$。
## 输出格式

输出用空格间隔的 $n$ 个整数，其中第 $i$ 个整数定义为 $s_i$。如果存在多个合法答案，请输出字典序最小的那个。
## 样例

### 样例输入 #1
```
5
0 0 1 2 3

```
### 样例输出 #1
```
1 2 1 2 1 
```
### 样例输入 #2
```
11
0 0 0 0 2 1 0 0 3 0 1

```
### 样例输出 #2
```
1 2 3 1 2 1 1 2 3 4 1 
```


---

---
title: "[HUSTFC 2023] 序列配对"
layout: "post"
diff: 省选/NOI-
pid: P9773
tag: ['2023', 'O2优化', '高校校赛']
---
# [HUSTFC 2023] 序列配对
## 题目描述

你有一个长度为 $n$ 的序列 $a_1,a_2,\dots,a_n$，初始序列内任意元素 $a_i=0$。

之后会告诉你 $n$ 组配对信息，每组配对信息形如整数对 $(l,r)$，表示将 $a_l$ 和 $a_r$ 进行配对。在配对之后，你必须执行下面两种操作之一（不可全选）：
- 令 $a_l$ 加 $1$，随后 $a_r$ 减 $1$。
- 令 $a_r$ 加 $1$，随后 $a_l$ 减 $1$。

你得知这些配对信息遵循着一个奇妙的规定：在 $n$ 组整数对内的 $2n$ 个整数中，每个序列的下标都恰好出现 $2$ 次！

此时你想知道，在所有操作方案中，使 $\sum_{i=1}^n{a_i}^2=k$ 的方案数，由于答案可能会很大，你只需要求出其对 $998\,244\,353$ 取模后的结果。

## 输入格式

第一行包含一个整数 $n\ (1\le n\le 2\cdot 10^5)$，表示序列的长度。

接下来 $n$ 行，其中第 $i$ 行包含两个整数 $l_i,r_i\ (1\le l\le r \le n)$，表示第 $i$ 组配对信息。保证输入的这 $2n$ 个整数符合题目要求。

最后一行包含一个整数 $k\ (0\le k \le 10^9)$，其含义如题目所述。
## 输出格式

输出一个整数，表示使 $\sum_{i=1}^n{a_i}^2=k$ 的方案数对 $998\,244\,353$ 取模后的结果。
## 样例

### 样例输入 #1
```
3
1 3
2 3
1 2
0
```
### 样例输出 #1
```
2

```
### 样例输入 #2
```
6
2 5
3 6
2 5
4 6
1 3
1 4
8
```
### 样例输出 #2
```
28

```


---

---
title: "[HUSTFC 2023] 狭义线段树"
layout: "post"
diff: 省选/NOI-
pid: P9776
tag: ['2023', 'O2优化', '高校校赛']
---
# [HUSTFC 2023] 狭义线段树
## 题目描述

你打算建立一棵有 $(2n - 1)$ 个节点，其中有 $n$ 个叶子节点的二叉树。具体地，建立这棵树的伪代码如图所示。

![1](https://cdn.luogu.com.cn/upload/image_hosting/eex8x40p.png)

不难发现，节点 $1$ 是根节点，并且所有节点的编号与其 DFS 序相同。另外，你认为叶子节点十分重要，因此你按照节点编号从小到大又把这 $n$ 个叶子节点分别称为 $1$ 号叶子，$2$ 号叶子，$\dots$，$n$ 号叶子。叶子节点会被其上方的节点管辖，具体来说，如果 $i$ 号叶子在节点 $j$ 的子树内，则称节点 $j$ 管辖 $i$ 号叶子，不妨用 $g(j,i)=1$ 表示；否则若节点 $j$ 不管辖 $i$ 号叶子，则 $g(j,i)=0$。注意，叶子节点同时也管辖自己本身。

同时，你认为一个好的二叉树要有点权，于是对于节点 $i$，定义其点权为 $v_i$。初始所有节点的点权都为 $0$。

在一次梦中，你正在改造这棵二叉树。你将会对这棵二叉树依次执行 $q$ 次操作，每次操作的格式和描述如下：
- $1\ s\ t\ v$：对于所有的整数 $i\ (i\in [s,t])$，将节点 $i$ 的点权加 $v$。
- $2\ s\ t\ v$：令 $\mathcal{S}={\textstyle \bigcup_{i\in [s,t]}}S_i$，其中 $S_i$ 表示节点 $i$ 管辖的叶子节点的集合。然后对于 $\mathcal{S}$ 中所有叶子节点，将其点权加 $v$。注意 $\mathcal{S}$ 是不重复集合，即在本次操作中，每个叶子节点最多被修改一次。
- $3\ l\ r$：计算 $\sum^{r}_{i=l}f(i)\bmod 998\,244\,353$，其中 $f(i)$ 表示管辖 $i$ 号叶子的所有节点的点权之和，即 $f(i)=\sum_{g(j,i)=1}{v_j}$。

你还想再加点操作，但是早八的铃声把你吵醒了，不过你还是决定实现一下这个奇思妙想。
## 输入格式

第一行包含一个整数 $n\ (3\le n\le 10^5)$，表示二叉树中叶子节点的数量。

第二行包含 $(2n-2)$ 个整数，其中第 $i$ 个整数表示节点 $i+1$ 的父亲节点编号。保证给出的树的形态与节点编号和题目所描述的相同。

第三行包含一个整数 $q\ (3\le q\le 10^5)$，表示操作次数。

接下来 $q$ 行，每行第一个整数 $opt\ (opt\in [1, 3])$ 表示操作类型，若 $opt=1$ 或 $opt=2$，则紧跟三个整数 $s,t,v\ (1\le s\le t\le 2n-1,\ 0\le v<998\,244\,353)$，表示一次修改操作；若 $opt=3$，则紧跟两个整数 $l,r\ (1\le l\le r\le n)$，表示一次询问操作。所有参数的含义如题目所述。
## 输出格式

对于每个 $opt=3$ 的操作，输出一行一个整数，表示本次询问的结果。
## 样例

### 样例输入 #1
```
5
1 2 3 3 2 1 7 7
5
1 2 4 3
3 1 5
2 5 7 5
3 2 5
3 1 5

```
### 样例输出 #1
```
18
29
38

```


---

---
title: "[HUSTFC 2023] 近似递增序列"
layout: "post"
diff: 省选/NOI-
pid: P9781
tag: ['2023', 'O2优化', '高校校赛']
---
# [HUSTFC 2023] 近似递增序列
## 题目描述

对于一个长度为 $m\ (m\ge 1)$ 的整数序列 $a_1,a_2,\cdots,a_m\ (a_i>0)$，如果**最多**只存在一个整数 $p\ (1\le p<m)$ 满足 $a_p\ge a_{p+1}$，则可以称这样的序列为近似递增序列，同时我们定义这个近似递增序列的权值为 $\prod_{i=1}^m a_i$。

设 $f(i)$ 表示权值为 $i$ 的近似递增序列的数量，duoluoluo 想知道 $\sum_{i=1}^n f(i)$ 的值，但是他连 $f(2)$ 都不会计算，你可以帮帮他吗？由于答案可能会非常大，你只需要求出其对 $998\,244\,353$ 取模后的值。
## 输入格式

一行包含一个整数 $n\ (1\le n\le 10^8)$，其含义如题目所述。
## 输出格式

输出一个整数，表示 $\sum_{i=1}^n f(i)$ 对 $998\,244\,353$ 取模后的值。
## 样例

### 样例输入 #1
```
2
```
### 样例输出 #1
```
7

```
### 样例输入 #2
```
5
```
### 样例输出 #2
```
26

```
## 提示

样例一中 $7$ 个近似递增序列为：$\{1\}$，$\{1,1\}$，$\{1,1,2\}$，$\{1,2\}$，$\{1,2,1\}$，$\{2\}$，$\{2,1\}$。


---

---
title: "[ROIR 2020] 海报 (Day 2)"
layout: "post"
diff: 省选/NOI-
pid: P9790
tag: ['2020', 'O2优化', 'ROIR（俄罗斯）']
---
# [ROIR 2020] 海报 (Day 2)
## 题目描述

**译自 [ROIR 2020](http://neerc.ifmo.ru/school/archive/2019-2020.html) Day2 T4.** ***[Плакаты](http://neerc.ifmo.ru/school/archive/2019-2020/ru-olymp-regional-2020-day2.pdf)***,译者ksyx

你的朋友们为了会见 IOI 回来的国家队选手准备了很多漂亮的海报，现在就还差要考虑些细节了。

为了欢迎这些选手，你的 $n$ 个朋友会拿着海报站成一个圈。为了方便描述，我们把他们编号为朋友 $1\ldots n$，其中对于 $i\in [1,n-1]$，朋友 $i$ 和朋友 $i+1$ 站在一起，且朋友 $n$ 和朋友 $1$ 站在一起。

每张海报都有一个美观度，其中朋友 $i$ 拿着的海报的美观度为 $a_i$。当开始庆祝时，一些朋友会举起他们的海报。为了美观，不能有 $4$ 个或以上排在一起的朋友同时举起他们的海报。

为了能够丰富节目效果，你的朋友们还打算在庆祝过程中更换 $q$ 次海报。每次更换后，海报 $p_i$ 的美观度将变为 $q_i$。你的朋友想知道每次更换后在符合上述条件下的最大美观度之和。

你的任务是给出初始的美观度，求出初始以及各次更换后的最大美观度之和。

*译者注：题面省略了部分难以理解的不必要细节。*
## 输入格式

第一行一个整数 $n$，朋友总数。

接下来一行 $n$ 个整数 $a_i$，表示初始美观度。

第三行 $q$ 个整数表示海报更换次数。

接下来 $q$ 行每行两个整数 $p_i,~v_i$，描述一次更换。
## 输出格式

输出 $q+1$ 行，表示初始时及各次更换后最大的美观度之和。
## 样例

### 样例输入 #1
```
6
1 2 3 4 5 6
2
6 0
2 5
```
### 样例输出 #1
```
17
13
15
```
## 提示

#### 【样例 1 解释】
初始状态下最佳方案为让朋友 $2,~4,~5,~6$ 举起海报，此时美观度之和为 $17$。

第一次改变后朋友 $6$ 的海报美观度变为 $0$，在此情况下最佳方案为让朋友 $1,~3,~4,~5$ 举起海报，美观度之和为 $13$。

第二次改变后朋友 $2$ 的海报美观度变为 $5$，在此情况下最佳方案为让朋友 $1,~2,~4,~5$ 举起海报，美观度之和为 $15$。

#### 【数据范围】
对于 $100\%$ 的数据，有 $4\le n\le 40000,$$~0\le a_i,~v_i\le 10^9,$$~1\le p_i\le n,$$~0\le q\le 40000$


各子任务如下：

|子任务编号|分值|限制|
|:-:|:-:|:-:|
|$1$||$11$|$4 \le n \le 10,~q=0$|
|$2$|$12$|$4 \le n \le 10,~0\le q\le 10$|
|$3$|$13$|$4 \le n \le 1000,~0\le q\le 1000$|
|$4$|$17$|$4 \le n \le 40000,~q=0$|
|$5$|$47$|$4 \le n \le 40000, 0\le q\le 40000$|


---

---
title: "[NERC 2018] Alice the Fan"
layout: "post"
diff: 省选/NOI-
pid: P9791
tag: ['2018', 'Special Judge', 'ICPC']
---
# [NERC 2018] Alice the Fan
## 题目背景

翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) A 题。
## 题目描述

Alice 喜欢看排球比赛，她尤其喜欢看 A 队打球，排球比赛的规则如下：

- 一场比赛最多有 $5$ 局。

- 前面 $4$ 均需获得至少 $25$ 分方可获胜，第 $5$ 局仅需获得 $15$ 分。

- 如果单局内其中一方满足获胜条件**但是**双方比分之差不满 $2$，不算获胜。

- 有一方比分达到 $3$ 即为获胜，此时立刻结束比赛。

现在分别给你 A 队和 B 队赢球的个数，请你帮忙确定 A 队最好的比分是多少，或者确定这场球赛还没有结束。

（注：本题定义最好的比分为，如果 A 队可以赢，要使得它们两队的比分差尽可能大，反之尽可能小。）
## 输入格式

第一行一个整数 $m(1 \leq m \leq 50000)$，表示 A 队打过 $m$ 场不同的比赛。

接下来 $m$ 行，每行两个整数 $a(1 \leq a \leq 200)$ 和 $b(1 \leq b \leq 200)$，分别表示该场比赛 A 队和 B 队的得分。
## 输出格式

对于每场比赛，输出 A 队最好的比分情况和一种符合条件的**每场**的比分，或者确定这是不可能的，输出 `Impossible`。
## 样例

### 样例输入 #1
```
6
75 0
90 90
20 0
0 75
78 50
80 100
```
### 样例输出 #1
```
3:0
25:0 25:0 25:0
3:1
25:22 25:22 15:25 25:21
Impossible
0:3
0:25 0:25 0:25
3:0
25:11 28:26 25:13
3:2
25:17 0:25 25:22 15:25 15:11
```
## 提示

测试数据保证 $1 \leq m \leq 50000$，$1 \leq a,b \leq 200$。

注：由于技术原因，SPJ 在评测时出现 UKE 是因为您的代码存在谬误，造成了 SPJ 读取字符时多/少读取到了，后面便无法正常评测。


---

---
title: "[NERC 2018]  Bimatching"
layout: "post"
diff: 省选/NOI-
pid: P9792
tag: ['2018', 'ICPC']
---
# [NERC 2018]  Bimatching
## 题目背景

翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) B 题。
## 题目描述

你与一些好友一起举办了一个舞会！

在这个舞会上，有 $n$ 位男性和 $m$ 位女性，本来舞蹈的形式是一男一女跳的，但是由于男性紧缺，你并不能让所有女性都有一个男性舞伴，于是你发明了一种新的舞蹈形式：一个男性，搭配两个女舞伴。

当然，每个女性在挑选舞伴时，都会对那些男性舞伴做出评价，如果评价是 $1$，说明这位女性愿意和这位男性一起跳舞，只有当两位女性都愿意和那位男性跳舞时，才能成为一对舞伴。

你作为一个组织者，自然要为大家着想，你需要求出能凑出的最多的舞伴对数，**每个舞伴不能重叠**。
## 输入格式

第一行一个数 $t (1 \leq t \leq 20)$，表示数据组数。

接下来 $t$ 组数据，每组第一行两个整数 $n$ 和 $m$，此处我们保证 $1 \leq n,m$ 且 $n + m \leq 150$。

然后一个 $n \times m$ 的矩阵，$a_{i,j}$ 表示 $j$ 号女士是否愿意和 $i$ 号男士一起跳舞。
## 输出格式

对于每组测试数据，输出一行，表示最多能凑出的舞伴对数。
## 样例

### 样例输入 #1
```
2
2 3
111
111
3 4
0110
1100
0011
```
### 样例输出 #1
```
1
2
```
### 样例输入 #2
```
1
3 6
001100
111111
001100
```
### 样例输出 #2
```
2
```
## 提示

数据保证 $1 \leq t \leq 20$，$1 \leq n, m$ 且 $n + m \leq 150$。

下图是对样例一和样例二的解释，其中加粗部分表示其中的一种可行方案。

样例一：

![](https://cdn.luogu.com.cn/upload/image_hosting/9dfwv4dr.png)

样例二：

![](https://cdn.luogu.com.cn/upload/image_hosting/woscpjcn.png)


---

---
title: "[NERC 2018]  Distance Sum"
layout: "post"
diff: 省选/NOI-
pid: P9794
tag: ['2018', 'ICPC']
---
# [NERC 2018]  Distance Sum
## 题目背景

翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) D 题。
## 题目描述

给你一个 $n$ 个顶点 $m$ 条边的连通无向图，定义 $u$ 与 $v$ 的距离 $d(u, v)$ 为从 $u$ 到 $v$ 最短路径上经过的边数。

现在请你求出 $\sum_{u=1}^n \sum_{v=u+1}^n d(u,v)$。
## 输入格式

第一行给定两个整数 $n(1 \leq n \leq 10^5)$，$m(n - 1 \leq m \leq n + 42)$，分别表示点数和边数。

接下来 $m$ 行，每行 $2$ 个整数 $x_i$ 和 $y_i(1 \leq x_i,y_i \leq n, x_i \neq y_i)$，表示 $x_i$ 和 $y_i$ 之间有一条边。

保证没有重边和自环。
## 输出格式

输出 $\sum_{u=1}^n \sum_{v=u+1}^n d(u,v)$。
## 样例

### 样例输入 #1
```
4 4
1 2
2 3
3 1
3 4
```
### 样例输出 #1
```
8
```
### 样例输入 #2
```
7 10
1 2
2 6
5 3
5 4
5 7
3 6
1 7
5 1
7 4
4 1
```
### 样例输出 #2
```
34
```
## 提示

对于所有数据保证 $1 \leq n \leq 10^5$，$n-1 \leq m \leq n + 42$，$1 \leq x_i, y_i \leq n$ 且 $x_i \neq y_i$。

样例一的图是：

![](https://cdn.luogu.com.cn/upload/image_hosting/39wue8qr.png)

其中 $d(1,2) = 1$，$d(1,3) = 1$，$d(1,4) = 2$，$d(2,3) = 1$，$d(2,3) = 2$，$d(3,4) = 1$，总和为 $1 + 1 + 2 + 1 + 2 + 1 = 8$。

样例二为：

![](https://cdn.luogu.com.cn/upload/image_hosting/89k279bd.png)


---

---
title: "[NERC 2018]  Interval-Free Permutations"
layout: "post"
diff: 省选/NOI-
pid: P9799
tag: ['2018', 'ICPC']
---
# [NERC 2018]  Interval-Free Permutations
## 题目背景

翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) I 题。
## 题目描述

我们定义一个从 $1 \sim n$ 的排列是“间隔排列”的情况是，在这个排列中存在连续的一段长度为 $2 \sim n-1$ 的子区间使得这段子区间在排序后是一串连续的自然数。比如，$\{6,7,1,8,5,3,2,4\}$ 是一个“间隔排列”，因为 $\{6,7\}$，$\{5,3,2,4\}$，$\{3,2\}$ 经过排序后都是一段连续的自然数。

现在已知 $n$，请你输出**不是**“间隔排列”的排列总数，由于输出可能很大，请对 $p$ 取模。
## 输入格式

第一行两个整数 $t (1 \leq t \leq 400)$ 和 $p (10^8 \leq p \leq 10^9)$，分别表示数据组数和模数。

接下来 $t$ 行，一行一个整数 $n (1 \leq n \leq 400)$。
## 输出格式

对于每组数据输出 $1 \sim n$ 的所有排列中**不是**“间隔排列”的排列总数对 $p$ 取模的值。
## 样例

### 样例输入 #1
```
4 998244353
1
4
5
9
```
### 样例输出 #1
```
1
2
6
28146
```
### 样例输入 #2
```
1 437122297
20
```
### 样例输出 #2
```
67777575
```
## 提示

数据保证 $1 \leq t \leq 400$，$10^8 \leq p \leq 10^9$，$1 \leq n \leq 400$。

对于样例一的解释：

第二组数据存在 $\{2,4,1,3\}$ 和 $\{3,1,4,2\}$ 符合要求。

第三组数据存在 $\{2,4,1,5,3\}$，$\{2,5,3,1,4\}$，$\{3,1,5,2,4\}$，$\{3,5,1,4,2\}$，$\{4,1,3,5,2\}$ 和 $\{4,2,5,1,3\}$ 满足要求。

对于样例二，一共有 $264111424634864638$ 种可能。


---

---
title: "[NERC 2018] JS Minification"
layout: "post"
diff: 省选/NOI-
pid: P9800
tag: ['2018', 'ICPC']
---
# [NERC 2018] JS Minification
## 题目背景

翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) J 题。
## 题目描述

你有一个程序，其中每行包含 $0$ 个或多个可以用空格分隔的标记，你需要将其按下列方法“压行”。

- 在每一行中，如果存在 `#` 开头的部分，说明这是一个注释，其与其同一行后面的东西一起不被执行。

- 通过重复跳过空格并从当前解析位置开始查找可能最长的标识符，将每一行从左到右解析为标识符序列，从而将源代码转换为标识符序列。下面列出了所有可能的标识符：

> - 保留标识符：缩小过程中应保留的任何类型的运算符、分隔符、文字、保留字或库函数的名称。保留标记是不包含 `#` 的非空格 ASCII 字符的固定字符串。
> - 数字标识符：有数字组成的一连串数字字符串。
> - 单词标识符：由以下集合中的一系列字符组成：小写字母、大写字母、数字、`_`、`$` 且不以数字开头。

请注意，在压缩过程中，满足数字或单词定义，但出现在保留标记列表中的**最长字符序列**被视为保留标识符。

在压缩过程中，使用以下算法以系统的方式重命名单词：

- 定义 $s$ 为若干个由小写字母组成的字符串按长度为第一关键词，字典序为第二关键词进行排序后的序列。

- 将标识符序列中遇到的第一个单词重命名为目标单词列表中的第一个词，并将标识符顺序中出现的所有相同单词重命名成第一个词。然后将标识符序列中遇到的第二个新词重命名为目标单词列表中的第二单词，依此类推。

此外，你可以删除原本某些不必要的空格与换行符。但是注意，你删除后并不可以使原本不是标识符的某些字符串变成了标识符，或是原本是标识符的变成了不是标识符的。
## 输入格式

输入的第一行包含一个整数 $n \ (1 \leq n \leq 40)$，代表标识符的数量。

输入的第二行包含由空格分隔的保留标识符的列表，该列表中没有重复，长度不小于 $1$，不大于 $20$。

输入的第三行包含单个整数 $m \ (1 \leq m \leq 40)$，代表输入代码中的行数。

接下来 $m$ 行一行一串代码（可能包含前导空格）。
## 输出格式

输出一行，是对输入代码进行压缩处理的结果。输出解析后的与具有相应重命名后的标识符序列，并且应包含尽可能少的空格。如果有多种方法，那请输出空格最少且长度最小的。
## 样例

### 样例输入 #1
```
16
fun while return var { } ( ) , ; > = + ++ - --
9
fun fib(num) { # compute fibs
  var return_value = 1, prev = 0, temp;
  while (num > 0) {
    temp = return_value; return_value = return_value + prev;
    prev = temp;
    num--;
  }
  return return_value;
}

```
### 样例输出 #1
```
fun a(b){var c=1,d=0,e;while(b>0){e=c;c=c+d;d=e;b--;}return c;}

```
### 样例输入 #2
```
10
( ) + ++ : -> >> >>: b c)
2
($val1++ + +4 kb) >> :out
b-> + 10 >>: t # using >>: 

```
### 样例输出 #2
```
(a+++ +4c )>> :d b->+10>>:e

```
## 提示

保证数据范围 $1 \leq n \leq 40$，$1 \leq m \leq 40$。


---

---
title: "[NERC 2018] King Kog’s Reception"
layout: "post"
diff: 省选/NOI-
pid: P9801
tag: ['2018', 'ICPC']
---
# [NERC 2018] King Kog’s Reception
## 题目背景

翻译自 [NERC 2018](https://neerc.ifmo.ru/archive/2018/neerc-2018-statement.pdf) K 题。
## 题目描述

有些骑士想要拜访国王，但是由于这里的骑士都很遵守礼节，他们都会提前预约好他要来拜访的时刻和拜访将持续的时间。骑士按照接待处记录的时刻顺序依次拜访国王，每个骑士必须等前面的骑士结束拜访。

很不幸，公主也准备要来拜访国王，但善良的公主并不会为此而打乱骑士们拜访的顺序，而她会等待骑士们拜访完了再来拜访，请你计算公主要等多长时间。
## 输入格式

共 $q+1$ 行。

第一行一个整数 $q (1 \leq q \leq 3 \times 10^5)$。

然后 $q$ 行，先是一个字符。

- 如果字符是 `+`，紧跟在后面两个数字，表示骑士 $i$ 要于 $t (1 \leq t \leq 10^6)$ 时刻到达，拜访时间 $d(1 \leq d \leq 10^6)$ 时间单位。

- 如果字符是 `-`，后面一个数字 $i(1 \leq i \leq q)$，表示骑士 $i$ 暂时取消了他的预约。

- 如果字符是 `?`，后面一个数字 $t (1 \leq t \leq 10^6)$，表示公主将于 $t$ 时刻拜访。
## 输出格式

对于每个 `?`，输出一行，表示公主要等待多长时间。注意此处公主拜访时骑士的预约记录只有前面的几个，并不包含后面加进来的。
## 样例

### 样例输入 #1
```
19
? 3
+ 2 2
? 3
? 4
+ 5 2
? 5
? 6
+ 1 2
? 2
? 3
? 4
? 5
? 6
? 7
? 9
- 8
? 2
? 3
? 6
```
### 样例输出 #1
```
0
1
0
2
1
3
2
1
2
1
0
0
2
1
1
```
## 提示

对于所有数据，保证 $1 \leq q \leq 3 \times 10^5$，$1 \leq t \leq 10^6$，$1 \leq d \leq 10^6$。


---

---
title: "[POI 2022 ~2023R1] wyp"
layout: "post"
diff: 省选/NOI-
pid: P9807
tag: ['POI（波兰）', '2022', '2023']
---
# [POI 2022 ~2023R1] wyp
## 题目背景

题目译自 [POI2022~2023R1 wyp](https://sio2.mimuw.edu.pl/c/oi30-1/p/wyp/)。
## 题目描述

你在高速上开着你新买的车，高速上共有 $2$ 个车道（分为左右，初始时所有车辆都在右侧），$n$ 辆在前面的车，但是由于这些车开的实在是太慢了，你想要进行超车。

已知你的速度为 $V$，其他车速度为 $v_i$（保证 $V > v_i$），如果你的车的车头已经要撞上其他车了，那么你将会向左开进行超车，如果你当前右侧位置存在一个空隙使得你的车进入的了，那么你一定进行右侧。

注意此处存在其他车相撞的情况，后面的车的速度会改成与它前面一样的速度。

问你的车会进行几次左转操作。
## 输入格式

第一行四个整数 $n$，$D$，$W$，$M$（$1 \leq n \leq 10^5$，$ 1 \leq D \leq 10^9$，$1 \leq W,M \leq 1000$），分别表示卡车的数量，自己车的长度，自己车的速度为 $W/M$，默认自己车的车头坐标为 $0$。

接下来 $n$ 行，每行 $4$ 个整数 $x_i$，$d_i$，$w_i$，$m_i$（$1 \leq x_i,d_i \leq 10^9$，$1 \leq w_i,m_i \leq 1000$），分别表示其他车的坐标、长度，速度为 $w_i / m_i$。

保证按 $x_i$ 升序排序给出。
## 输出格式

输出要实行超车 $n$ 辆车要左转的次数。
## 样例

### 样例输入 #1
```
3 1 1 1
3 2 1 4
6 3 1 2
10 2 1 4
```
### 样例输出 #1
```
2
```
## 提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/ymk60iqd.png)

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $v_i = v_{i+1}$ | $10$ |
| $2$ | $v_i \leq v_{i+1}$ | $20$ |
| $3$ | $n \leq 1000$ | $35$ |
| $4$ | 无附加限制 | $35$ |

本题中，子任务 $0$ 为样例。


---

---
title: "[POI 2022 ~2023R1] zbo"
layout: "post"
diff: 省选/NOI-
pid: P9808
tag: ['POI（波兰）', '2022', '2023']
---
# [POI 2022 ~2023R1] zbo
## 题目背景

题目译自 [POI2022~2023R1 zbo](https://sio2.mimuw.edu.pl/c/oi30-1/p/zbo/)。
## 题目描述

远古时期有一个国王，他统治了 $n$ 个村庄，这些村庄以 $n-1$ 条道路连接，原来的国王城堡在 $1$ 号村庄。

国王的儿子不久就要成年了，作为成年的王子们，其需要自己的城堡，所以在一些村庄会有**新的城堡**。

每座城堡都需要进行通讯，但是无奈距离太过遥远，为此，每个城堡每天都会派出若干个信鸽，向其他每个城堡发送消息。一只信鸽每行驶一公里就要吃一克谷物。

请你实现一个程序，求出按照输入顺序建造的每个城堡建造完之后所有城堡都能通讯的最少花费谷物数量。

具体的，定义 $dis(x,y)$ 为 $x$ 到 $y$ 所花费的谷物数，求每个城堡 $i$ 建造完后的 $\sum ^{i} _{x=1} \sum ^{i}_{y=1} dis(x,y)$。

注意上述式子默认两个相同的地点所花费为 $0$。
## 输入格式

输入第一行两个数字 $n$ 和 $k \ (1 \leq k < n \leq 10^5)$，分别表示村庄数量和即将建造的城堡数量。

接下来 $n-1$ 行，每行三个整数 $a,b,c \ (1 \leq a,b \leq n, a \neq b, 1 \leq c \leq 1000)$，表示 $a$ 到 $b$ 存在一条长度为 $c$ 的无向边。

再接下来 $k$ 行，每行一个整数 $d_{i}$，表示第 $i$ 个城堡建设在 $d_{i}$ 位置上，注意城堡不会重复建在一个位置。
## 输出格式

对于每个建造完的城堡，输出最小花费。
## 样例

### 样例输入 #1
```
5 3
1 4 3
3 1 6
1 2 5
4 5 1
5
3
2
```
### 样例输出 #1
```
8
40
90

```
## 提示

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $n \cdot k \leq 10^5$ | $15$ |
| $2$ | 村庄是一条从 $1$ 到 $n$ 的链 | $35$ |
| $3$ | 无特殊性质 | $50$ |

本题中，子任务 $0$ 为样例。


---

---
title: "游戏王"
layout: "post"
diff: 省选/NOI-
pid: P9818
tag: ['O2优化']
---
# 游戏王
## 题目背景

**本题已经增加 hack 数据**。hack 数据位于 subtask 7，记 0 分。此外本题时限较大数据点较多，希望各位不要滥用评测资源。

你正在打块，突然家长走了进来，于是你假装在玩原神。
## 题目描述

你改造了原神的抽卡系统。

具体而言，在第 $i$ 次抽卡时，系统将会给出一个可重集合 $S_i$，表示这次抽卡中可供选择的角色。第 $j$ 个角色有两个属性：力量值 $s_{i,j}$ 与魔力值 $m_{i,j}$。你可以从中选择一名角色，并将其加入到自己的背包中；当然，你也可以不做任何选择。你的力量值被定义为背包中所有角色的力量值之和，同时你需要时刻保证背包中角色的魔力值之积不超过魔力上限 $v$。你的任务是最大化自己的力量值。

但是，你很快就厌烦了千篇一律的抽卡。为了给生活找点乐子，你想到了这样的问题：如果游戏从第 $l$ 次抽卡开始，到第 $r$ 次抽卡结束，你的力量值最大是多少呢？

你一口气提出了 $q$ 个这样的问题。现在，你需要计算出它们的答案。

**形式化题意**：

给出一个长为 $n$ 的序列 $\{S_n\}$，其中 $S_i$ 为多个二元组 $(s_{i,j},m_{i,j})$ 构成的可重集。有 $q$ 次询问，每次给定 $l,r$，你需要从 $S_l,S_{l+1},\cdots,S_r$ 的每个集合中分别选出 $0$ 个或 $1$ 个二元组。记选出的 $k$ 个二元组为 $(s'_i,m'_i),1\le i\le k$，则你需要在保证 $\prod_{i=1}^km'_i\le v$ 的基础上，最大化 $\sum_{i=1}^k s'_i$。
## 输入格式

输入的第一行包含两个正整数 $n,v$。

接下来 $n$ 行，每行首先读入 $|S_i|$，接下来读入 $|S_i|$ 对正整数 $(s_{i,j},m_{i,j})$，即 $S_i$ 中每一角色的力量值与魔力值。

随后一行，读入一个正整数 $q$。

接下来 $q$ 行，每行两个正整数 $l,r$，表示一次询问。**注意询问间两两独立，即每次询问都将被视作一次新的游戏。**
## 输出格式

输出共 $q$ 行。对于每次询问，输出你的体力值的最大值。
## 样例

### 样例输入 #1
```
4 10
2 2 1 5 9
1 5 3
3 2 1 2 1 3 3
1 3 1
5
3 3
2 3
1 4
2 4
3 4
```
### 样例输出 #1
```
3
8
13
11
6
```
## 提示

#### 样例解释

对于第一组询问，最优策略是从 $S_3$ 中选择 $(3,3)$。此时你的能力值为 $3$。

对于第三组询问，最优策略是从 $S_1$ 中选择 $(2,1)$，$S_2$ 中选择 $(5,3)$，$S_3$ 中选择 $(3,3)$，$S_4$ 中选择 $(3,1)$，此时魔力值之积等于 $1\times 3\times 3\times 1=9\le 10$，你的能力值等于 $2+5+3+3=13$。 

#### 数据范围与约定

**本题使用子任务捆绑测试，只有通过子任务内全部测试点才可以获得该子任务的相应分数**。

记 $tot=\sum_{i=1}^n|S_i|$。

- 子任务 1（5 分）：保证 $n,tot\le 10$。
- 子任务 2（20 分）：保证 $n,v,tot,q\le 100$。
- 子任务 3（15 分）：保证所有 $m_{i,j}$ 在范围内均匀随机生成。
- 子任务 4（20 分）：保证 $1\le n,v,tot,q\le 10^4$。
- 子任务 5（15 分）：保证对于所有询问，均有 $l=1$ 或者 $r=n$。
- 子任务 6（25 分）：无特殊限制。

对于所有数据，保证 $1\le n,tot\le 10^5$，$1\le q\le 2\times 10^5$，$1\le m_{i,j}\le v\le 10^5$，$1\le s_{i,j}\le 10^4$，$1\le l\le r\le n$。


---

---
title: "[POI 2021 ~2022R2] age"
layout: "post"
diff: 省选/NOI-
pid: P9864
tag: ['POI（波兰）', '2021', '2022']
---
# [POI 2021 ~2022R2] age
## 题目背景

翻译自 [POI2021~2022R2 Day1T1](https://szkopul.edu.pl/problemset/problem/weKRWGa1NgLNHT1WLDo5ohuH/statement/)。

## 题目描述

有一个 $n$ 个城市的国家，我们可以将其看为一棵 $n-1$ 条道路连接的树，有一天，你突发奇想，想要派出 $k$ 个人在不同城市上。人及其移动需要满足如下条件：

- 每天只能是一个人移动，移动到其相邻存在道路连接一个城市。

- 假如有两个人 $a,b$，城市 $i$ 被 $a$ 到达过了，则 $b$ 不能到达 $i$ 城市。

初始时你知道了人的位置，每个人初始所在地不相同，且该城市视为“已到达过”的城市，你需要安排一个合法的经过城市的方案。

请你求出最少要几天才能使所有的城市都被人到达过。
## 输入格式

第一行两个整数 $n,k\ (1 \leq n \leq 5 \times 10^5, 1 \leq k \leq n)$。

第二行 $k$ 个数，表示那些人的初始位置。

然后 $n-1$ 行，描述了每条道路 $(a_i,b_i)\ (1 \leq a_i,b_i \leq n)$。
## 输出格式

输出最少天数。
## 样例

### 样例输入 #1
```
6 2
2 6
1 2
2 3
2 4
5 4
5 6
```
### 样例输出 #1
```
5
```
## 提示

样例解释：

![](https://cdn.luogu.com.cn/upload/image_hosting/y9gojuv8.png)

子任务分配如下：

| 子任务编号 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $n \leq 10$ | $6$ |
| $2$ | $n \leq 20$ | $13$ |
| $3$ | $n \leq 2000$ | $27$ |
| $4$ | $k=1$ | $10$ |
| $5$ | $k=2$ | $7$ |
| $6$ | 输入为一条链 | $7$ |
| $7$ | 无特殊性质 | $30$ |

子任务 $0$ 为样例。


---

---
title: "[ICPC 2018 Qingdao R] Airdrop"
layout: "post"
diff: 省选/NOI-
pid: P9895
tag: ['2018', 'O2优化', 'ICPC', '青岛']
---
# [ICPC 2018 Qingdao R] Airdrop
## 题目描述

PUBG is a multiplayer online battle royale video game. In the game, up to one hundred players parachute onto an island and scavenge for weapons and equipment to kill others while avoiding getting killed themselves. Airdrop in this game is a key element, as airdrops often carry with them strong weapons or numerous supplies, helping players to survive.

![](https://cdn.luogu.com.cn/upload/image_hosting/qv9hzuoe.png)
textit{Airdrop in the game(?)

Consider the battle field of the game to be a two-dimensional plane. An airdrop has just landed at point $(x_0, y_0)$ (both $x_0$ and $y_0$ are integers), and all the $n$ players on the battle field, where $(x_i, y_i)$ (both $x_i$ and $y_i$ are integers) indicates the initial position of the $i$-th player, start moving towards the airdrop with the following pattern:


- If the position of a living player at the beginning of this time unit is not equal to $(x_0, y_0)$, he will begin his next move.
- + Let's say he is currently at point $(x, y)$. For his next move, he will consider four points $(x, y - 1)$, $(x, y + 1)$, $(x - 1, y)$ and $(x + 1, y)$.
- + He will select one of the four points whose Manhattan distance to the airdrop $(x_0, y_0)$ is the smallest to be the destination of his next move. Recall that the Manhattan distance between two points $(x_a, y_a)$ and $(x_b, y_b)$ is defined as $|x_a - x_b| + |y_a - y_b|$.
- + If two or more points whose Manhattan distance to the airdrop is the same, he will use the following priority rule to break the tie: $(x, y - 1)$ has the highest priority to be selected, $(x, y + 1)$ has the second highest priority, $(x - 1, y)$ has the third highest priority, and $(x + 1, y)$ has the lowest priority.
- + At the end of this time unit, he arrives at his destination.
- If the position of a living player at the beginning of this time unit is equal to $(x_0, y_0)$, he will continue to fatten his backpack with the supplies in the airdrop and stays at $(x_0, y_0)$.


But the battle is tough and it's almost impossible for all the players to arrive at the airdrop safely. If two or more players meet at point $(x', y')$ other than $(x_0, y_0)$, where both $x'$ and $y'$ are integers, they will fight and kill each other and none of them survive.

BaoBao is a big fan of the game and is interested in the number of players successfully arriving at the position of the airdrop, but he doesn't know the value of $x_0$. Given the value of $y_0$ and the initial position of each player, please help BaoBao calculate the minimum and maximum possible number of players successfully arriving at the position of the airdrop for all $x_0 \in \mathbb{Z}$, where $\mathbb{Z}$ is the set of all integers (note that $x_0$ can be positive, zero or negative).

## 输入格式

There are multiple test cases. The first line of the input contains an integer $T$, indicating the number of test cases. For each test case:

The first line contains two integers $n$ and $y_0$ ($1 \le n \le 10^5$, $1 \le y_0 \le 10^5$), indicating the number of players and the $y$ value of the airdrop.

For the following $n$ lines, the $i$-th line contains two integers $x_i$ and $y_i$ ($1 \le x_i, y_i \le 10^5$), indicating the initial position of the $i$-th player.

It's guaranteed that the sum of $n$ in all test cases will not exceed $10^6$, and in each test case no two players share the same initial position.

## 输出格式

For each test case output one line containing two integers $p_\text{min}$ and $p_\text{max}$ separated by one space. $p_\text{min}$ indicates the minimum possible number of players successfully arriving at the position of the airdrop, while $p_\text{max}$ indicates the maximum possible number.

## 样例

### 样例输入 #1
```
3
3 2
1 2
2 1
3 5
3 3
2 1
2 5
4 3
2 3
1 3
4 3
```
### 样例输出 #1
```
1 3
0 3
2 2
```
## 提示

We now explain the first sample test case.

To obtain the answer of $p_\text{min} = 1$, one should consider $x_0 = 3$. The following table shows the position of each player at the end of each time unit when $x_0 = 3$.

![](https://cdn.luogu.com.cn/upload/image_hosting/itsnfe48.png)

To obtain the answer of $p_\text{max} = 3$, one should consider $x_0 = 2$. The following table shows the position of each player at the end of each time unit when $x_0 = 2$.

![](https://cdn.luogu.com.cn/upload/image_hosting/hvseoyfc.png)
## 题目翻译

### 题目描述
有 $n$ 个玩家在一个平面直角坐标系中打 PUBG. 此时一个空投落在了 $(x_0, y_0)$ 处.

现在场上还剩 $n$ 个「存活」的玩家. 从空投落地的时刻起, 每一个时刻执行如下操作 :

1. 移动阶段

对于每个「存活」的玩家 :
- 如果其不在 $(x_0, y_0)$ :
  - 向空投方向沿 $x$ 轴**或** $y$ 轴方向移动 $1$ 个单位距离, 使得移动后位置与 $(x_0, y_0)$ 的曼哈顿距离尽可能小. 
  - 在上一条规则的基础上, 如果有多种符合要求的移动方式, 则优先沿 $y$ 轴移动.
- 如果其在 $(x_0, y_0)$, 则不进行操作.

2. 战斗阶段

移动阶段结束后, 如果**除 $(x_0, y_0)$ 外**任意一点存在超过 $1$ 名玩家, 则将这一点所有玩家判定为「死亡」并移出游戏.

---

可以证明, 经过足够多次操作后, 所有仍「存活」的玩家都会处在 $(x_0, y_0)$ 位置.

给定 $y_0$, 求 $x_0$ 取任意整数值时, 最终「存活」玩家数的最大值与最小值.

### 输入输出格式与数据范围
首先给出一个整数 $T$, 表示数据组数. 接下来对于每组数据 :

第一行给出两个正整数 $n, y_0$, 意义如题所述.

接下来 $n$ 行, 每行两个正整数 $x, y$, 表示 $n$ 个玩家的坐标.

$n$ 和所有点的坐标值都不超过 $10^5$, 且保证不存在两名玩家初始处在同一位置. 单个测试点的 $\sum n \le 10^6$.

**注意 : $x_0$ 可以取 $0$ 或负值, 且不受坐标值不超过 $10^5$ 的限制.**

对于每组数据, 输出一行 2 个空格分开的整数, 分别表示最终「存活」玩家数的最大值和最小值.

Translated by @[Ja50nY0un9](/user/363302).


---

---
title: "[COCI 2023/2024 #1] Mostovi"
layout: "post"
diff: 省选/NOI-
pid: P9907
tag: ['2023', 'COCI（克罗地亚）']
---
# [COCI 2023/2024 #1] Mostovi
## 题目描述

When Leonhard Euler resolved the famous Königsberg bridge problem,he had no clue he had discovered a whole new area of mathematics -graph theory!

Unfortunately, the Königsberg bridge problem is far too easy for the programmers of this era, so Euler came up with another problem - the Zagreb bridge problem!

The bridges of Zagreb form a graph with $n$ nodes and $m$ edges where the edges represent the bridges and the nodes represent the riverine islands. The graph is connected, in other words, it’s possible to get from any node to any other by traveling across the edges. Now Euler asked, how many edges are there such that after their removal the graph becomes disconnected?

Again, Euler didn’t know that this problem is also famous today (those damn Codeforces blogs). So the author of this problem decided to give you an even harder one, how many edges are there such that after the removal of the nodes which it connects, the remaining $n − 2$ nodes become disconnected?

### 题目大意

给定一张 $n$ 个点 $m$ 条边的无向连通图，求有多少条边满足删去这条边两端的两个点之后，剩余的 $n-2$ 个点不连通。
## 输入格式

一行两个正整数 $n,m$ 分别表示点数和边数。

接下来一行每行两个正整数 $a_i,b_i$ 表示有一条边连接 $a_i,b_i$。
## 输出格式

一行一个整数表示符合条件的边的数量。
## 样例

### 样例输入 #1
```
4 5
1 2
2 3
3 4
4 1
1 3
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
6 7
1 2
2 4
2 6
3 5
6 1
4 3
2 5
```
### 样例输出 #2
```
4
```
## 提示

### 【样例解释#1】

对于边 $(1,3)$，删去它和对应的点 $1,3$ 之后，包含两个连通块，分别包括节点 $2$ 和 $4$，也就是说，图不连通了。容易验证这是唯一满足条件的边。

### 【样例解释#2】

满足条件的边有：$(1, 2), (2, 4), (2, 6) , (2, 5)$。

### 【数据范围】

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq3\times10^5$，$1\leq a_i,b_i\leq n$，图中无重边、自环。

**本题采用捆绑测试。**

| 子任务 | 特殊性质 | 分值 |
| :----------: | :----------: | :----------: |
| $1$ | $n\leq100$，$m\leq300$ | $13$ |
| $2$ | $n\leq1000$，$m\leq3000$ | $17$ |
| $3$ | $n\leq1000$ | $25$ |
| $4$ | $m-n\leq20$ | $12$ |
| $4$ | 无特殊性质 | $43$ |

### 【说明】

本题分值按 COCI 原题设置，满分 $110$。

题目译自 [COCI2022-2023](https://hsin.hr/coci/) [CONTEST #1](https://hsin.hr/coci/contest1_tasks.pdf) _**T5 Mostovi**_。


---

---
title: "[COCI 2023/2024 #2] Dizalo"
layout: "post"
diff: 省选/NOI-
pid: P9910
tag: ['2023', 'O2优化', 'COCI（克罗地亚）']
---
# [COCI 2023/2024 #2] Dizalo
## 题目描述

$n$ 个人坐电梯，第 $i$ 个人在第 $a_i$ 层下电梯，$a_{1\sim n}$ 构成一个排列。

电梯是长条形的，所以 $n$ 个人初始时按编号顺序在电梯里列成一列，电梯会从下往上依次经过第 $1\sim n$ 层。

当一个人要下电梯时，所有在他前面的人也必须暂时下电梯，然后可以以任意顺序返回电梯。在他后面的人不需要也不会下电梯。

如果每次临时下电梯的人总是以最优策略来决定返回电梯的顺序，请你求出所有人下电梯的总次数最少是多少。

给定 $q$ 次操作，每次给定 $x_i$ 表示移除编号为 $x_i$ 的人，你需要在第一次操作前以及每次操作之后求出答案。
## 输入格式

第一行两个整数 $n,q$。

第二行 $n$ 个数 $a_{1\sim n}$，保证构成一个 $1\sim n$ 的排列。

第三行 $q$ 个数 $x_{1\sim q}$，表示 $q$ 次询问。
## 输出格式

输出一行 $q+1$ 个数，表示第一次操作前的答案以及每次操作后的答案。
## 样例

### 样例输入 #1
```
5 2
3 4 1 2 5
3 2
```
### 样例输出 #1
```
9 6 4
```
### 样例输入 #2
```
7 0
4 5 2 1 6 3 7
```
### 样例输出 #2
```
13
```
### 样例输入 #3
```
3 2
3 1 2
1 2

```
### 样例输出 #3
```
5 2 1
```
## 提示

### 数据范围
|$\text{Subtask}$|分值|特殊性质|
|:-:|:-:|:-:|
|$1$|$16$|$n,q\le 100$|
|$2$|$19$|$n,q\le 1000$|
|$3$|$29$|$q=0$|
|$4$|$46$|无|

对于所有数据，$0\le q< n\le 10^5$。


---

---
title: "[POI 2023/2024 R1] CzatBBB"
layout: "post"
diff: 省选/NOI-
pid: P9922
tag: ['POI（波兰）', '2023']
---
# [POI 2023/2024 R1] CzatBBB
## 题目背景

译自 [XXXI Olimpiada Informatyczna - I etap](https://sio2.mimuw.edu.pl/c/oi31-1/dashboard/) [CzatBBB](https://sio2.mimuw.edu.pl/c/oi31-1/p/cza/)。

## 题目描述

给出一个 $n$ 个字母的字符串 $S$ 和一个参数 $k$，设 $R$ 为字符串 $S$ 的后 $k$ 个字母形成的字串。

假设字符串 $S'$ 为 $S$ 添加一个新字母生成的新字符串。

添加的规则如下所示： 对于字母 $X$ 字母，计算它在字符串 $S$ 中紧接着 $R$ 出现的次数。出现频率最高的字母为新添加的字母，如果有多个出现频率最高的字母，取最小的一个。如果 $R$ 在字符串 $S$ 中的其他地方都没有出现，则取 $X = a$。最后，我们扩展字符串 $S$，在其末尾添加字母 $X$。

例如，设 $S = \text{abaaabababa}$，$k = 3$ 则 $R$ 与后一个字母一起出现的字串为的：$\text{abaa}$、$\text{abab}$、$\text{abab}$。它最常与字母 $\text{b}$ 一起出现，因此我们在 $S$ 中加上 $\text{b}$，生成 $S' = \text{abaaabababab}$。

现在 $S' = \text{abaaabababab}$，$R = \text{bab}$，$R$ 与后一个字母一起出现的字串为：$\text{baba}$、$\text{baba}$，如 $\text{baba}$、$\text{baba}$，因此我们在 $S'$ 后面加上 $a$。

以此类推，这样的操作会进行无数次。

你的任务是编写一个程序，输出新字符串最后 $a$ 至 $b$ 个字符。
## 输入格式

第一行输入包含四个整数 $n$、$k$、$a$ 和 $b$。

第二行输入包含一个 $n$ 个字母的字符串，由小写英文字母组成的 $n$ 个字母字符串，表示单词 $S$。
## 输出格式

输出字符串 $S'$ 的第 $a$ 个字符 至第 $b$ 个字符，表示扩展单词 $S'$ 中位于以下位置的字母。
## 样例

### 样例输入 #1
```
11 3 12 13
abaaabababa

```
### 样例输出 #1
```
ba

```
### 样例输入 #2
```
20 3 30 40
abcdabcdabcdabcdabcd

```
### 样例输出 #2
```
bcdabcdabcd

```
### 样例输入 #3
```
见附件
```
### 样例输出 #3
```
aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa

```
### 样例输入 #4
```
见附件
```
### 样例输出 #4
```
见附件
```
## 提示

对于所有的数据，$2\leq n\leq10^6$，$1\leq k<n<a<b<10^{18}$，$b+1-a\leq10^6$，串只含小写字母。

| 子任务编号 | 附加限制 | 分值 |
| :----------: | :----------: | :----------: |
| 1 | $n\leq100$，$b\leq1000$ | 8 |
| 2 | $b\leq 10^8$ | 10 |
| 3 | $n\leq 500$，后缀 $R$ 的前一次出现将始终存在，并且每次出现后都会有相同的字母  | 16 |
| 4 | 后缀 $R$ 的前一次出现将始终存在，并且每次出现后都会有相同的字母 | 10 |
| 5 | $k\leq20$，$b\leq 10^{10}$，串只含 `ab` | 16 |
| 6 | 无任何限制  | 40 |


---

---
title: "[NFLSPC #6] 9.pop_book();"
layout: "post"
diff: 省选/NOI-
pid: P9933
tag: ['O2优化']
---
# [NFLSPC #6] 9.pop_book();
## 题目背景

*Alek 岁*在操场上跑圈。他看到有人超过他，很不爽。于是他采取了以下策略：
## 题目描述

在长度为 $m$ 的环形操场上有 $n$ 个人，第 $i$ 个人在 $t_i$ 时刻从位置 $p_i$ 出发以 $v_i$ 单位长度每秒的速度移动。现在 $0$ 时刻 *Alek 岁*在位置 $0$ 处，速度为 $0$，会跟着经过他的速度最快的人移动。$q$ 次询问 $T_i$ 时刻 *Alek 岁*的移动距离。可以证明这是一个整数。

注：从位置 $0$ 出发逆时针方向 $x$（$0\leq x < m$）单位长度的位置称为位置 $x$。所有人的运动方向都是逆时针。

多组数据。
## 输入格式

第一行一个整数 $T$ 表示数据组数。对于每组数据：

- 第一行三个整数 $n, m, q$，分别表示人数，操场长度和询问个数。
- 接下来 $n$ 行，每行三个整数 $p_i, v_i, t_i$，分别表示第 $i$ 个人出发时的位置，移动速度（单位长度每秒）和出发时间。
- 接下来 $q$ 行，每行一个整数 $T_i$ 表示一次询问。
## 输出格式

对于每个询问，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
1
3 30 8
0 2 1
6 5 2
25 4 4
1
5
9
10
11
12
13
14

```
### 样例输出 #1
```
0
8
16
19
23
27
31
36

```
## 提示

对于所有数据，$1\leq T\leq 10 ^ 3$，$1\leq n, \sum n\leq 5\times 10 ^ 5$，$1\leq m, q, \sum q \leq 10 ^ 6$，$1\leq v_i, t_i, T_i\leq 10 ^ 9$，$0\leq p_i < m$。保证 $t_i$ 单调不降，$T_i$ 单调递增。

- 子任务 1（$10$ 分）：$n\leq 5$。
- 子任务 2（$10$ 分）：$n\leq 50$。
- 子任务 3（$20$ 分）：$n\leq 500$。
- 子任务 4（$20$ 分）：$n\leq 5\times 10 ^ 3$。
- 子任务 5（$20$ 分）：$n\leq 5\times 10 ^ 4$。
- 子任务 6（$20$ 分）：无特殊限制。

**请注意，子任务并没有保证 $\sum q$ 的数量级**。

本题 IO 量较大，建议使用 `scanf/printf` 或关闭流同步的 `cin/cout` 或快速读入和快速输出。

Source：NFLSPC #6 I by Alex_Wei


---


---
title: "[LSOT-2] Tree and Xor"
layout: "post"
diff: 省选/NOI-
pid: P10157
tag: ['数学', '贪心', '二分', '位运算', 'Ad-hoc', '分类讨论']
---
# [LSOT-2] Tree and Xor
## 题目描述

给定 $n$，你需要构造一棵 $n$ 个点的以 $1$ 为根的有根树，满足 $\bigoplus\limits_{i=1}^ndegree(i)=0$ 且 $fa_2 \sim fa_n$ 的字典序最小。其中，$\oplus$ 表示异或运算。

其中 $degree(i)$ 表示与点 $i$ 相连的点数，$fa_i$ 表示点 $i$ 的父节点且 $fa_i < i$。

你需要输出 $\sum\limits_{i=2}^ni \times fa_i$，若无解则输出 $-1$。
## 输入格式

第一行，一个正整数 $T$，表示询问数量。

接下来每 $T$ 行每行一个正整数 $n$ 表示一次询问。
## 输出格式

一共 $T$ 行，每行一个整数表示答案除 $998244353$ 的余数。
## 样例

### 样例输入 #1
```
2
2
3
```
### 样例输出 #1
```
2
-1
```
## 提示

**「本题采用捆绑测试」**

- $\texttt{Subtask 1(5 pts)：}n \leq 7$。
- $\texttt{Subtask 2(10 pts)：} n \leq 20$。
- $\texttt{Subtask 3(20 pts)：}\sum n \leq 2000$。
- $\texttt{Subtask 4(15 pts)：}n = 2^k-1$，其中 $k$ 是自然数。
- $\texttt{Subtask 5(50 pts)：}$无特殊限制。

对于所有数据，$1\le T\le 10^6$，$2 \leq n \leq 10^{9}$。


---

---
title: "[USACO24FEB] Lazy Cow P"
layout: "post"
diff: 省选/NOI-
pid: P10196
tag: ['线段树', '二分', 'USACO', '2024', 'O2优化', '凸包']
---
# [USACO24FEB] Lazy Cow P
## 题目描述

Bessie 正在努力为美国件算机奥林匹克二月的竞赛准备测试用例。每一分钟，她可以选择不准备测试用例，不花费能量；或者对于某个正整数 $a$，花费 $3^{a−1}$ 能量准备 $a$ 个测试用例。

Farmer John 有 $D$（$1\le D\le 2\cdot 10^5$）个需求。对于第 $i$ 个需求，他告诉 Bessie，在前 $m_i$ 分钟内她总共需要准备至少 $b_i$ 个测试用例（$1\le m_i\le 10^6,1\le b_i\le 10^{12}$）。

令 $e_i$ 为满足前 $i$ 个需求 Bessie 最小需要花费的能量。输出 $e_1,\ldots,e_D$ 模 $10^9+7$ 的余数。 
## 输入格式

输入的第一行包含 $D$。以下 $D$ 行，第 $i$ 行包含两个空格分隔的整数 $m_i$ 和 $b_i$。
## 输出格式

输出 $D$ 行，第 $i$ 行包含 $e_i \bmod 10^9+7$。 
## 样例

### 样例输入 #1
```
4
5 11
6 10
10 15
10 30
```
### 样例输出 #1
```
21
21
25
90
```
### 样例输入 #2
```
2
100 5
100 1000000000000
```
### 样例输出 #2
```
5
627323485
```
### 样例输入 #3
```
20
303590 482848034083
180190 112716918480
312298 258438719980
671877 605558355401
662137 440411075067
257593 261569032231
766172 268433874550
8114 905639446594
209577 11155741818
227183 874665904430
896141 55422874585
728247 456681845046
193800 632739601224
443005 623200306681
330325 955479269245
377303 177279745225
880246 22559233849
58084 155169139314
813702 758370488574
929760 785245728062
```
### 样例输出 #3
```
108753959
108753959
108753959
148189797
148189797
148189797
148189797
32884410
32884410
32884410
32884410
32884410
32884410
32884410
3883759
3883759
3883759
3883759
3883759
3883759
```
## 提示

### 样例解释 1

对于第一个测试用例，

- $i=1$：如果 Bessie 在前 $5$ 天分别制作 $[2,3,2,2,2]$ 个测试用例，她将花费 $3^1+3^2+3^1+3^1+3^1=21$ 单位能量，并在第 $5$ 天结束时制作了 $11$ 个测试用例。
- $i=2$：Bessie 可以遵循上面的策略，确保在第 $5$ 天结束时制作了 $11$ 个测试用例，而这将自动满足第二个需求。
- $i=3$：如果 Bessie 在前 $10$ 天分别制作 $[2,3,2,2,2,0,1,1,1,1]$ 个测试用例，她将花费 $25$ 单位能量并满足所有需求。可以证明她无法花费更少的能量。
- $i=4$：如果 Bessie 在前 $10$ 天每一天制作 $3$ 个测试用例，她将花费 $3^2\cdot 10=90$ 单位能量并满足所有需求。

对于每一个 $i$，可以证明 Bessie 无法花费更少的能量满足前 $i$ 个需求。

### 测试点性质

- 测试点 $4-5$：$D\le 100$，且对于所有 $i$，$m_i\le 100$。
- 测试点 $6-8$：$D\le 3000$。
- 测试点 $9-20$：没有额外限制。


---

---
title: "[USACO24OPEN] Activating Robots P"
layout: "post"
diff: 省选/NOI-
pid: P10285
tag: ['二分', 'USACO', '2024', '状压 DP']
---
# [USACO24OPEN] Activating Robots P
## 题目描述

你和一个机器人初始时位于周长为 $L$（$1\le L\le 10^9$）的圆上的点 $0$ 处。你可以以每秒 $1$ 
单位的速度沿圆周顺时针或逆时针移动。本题中的所有移动都是连续的。

你的目标是放置恰好 $R-1$ 个机器人，使得最终每两个相邻的机器人彼此相距 $L/R$（$2\le R\le 20$，$R$ 整除 $L$）。有 $N$（$1\le N\le 10^5$）个激活点，其中第 $i$ 个激活点位于距点 $0$ 逆时针方向 $a_i$ 距离处（$0\le a_i<L$）处。如果你当前位于一个激活点，你可以立刻在该点放置一个机器人。所有机器人（包括初始的）均以每 $K$ 秒 $1$ 单位的速度逆时针移动（$1\le K\le 10^6$）。

计算达到目标所需要的最小时间。 
## 输入格式

输入的第一行包含 $L$，$R$，$N$ 和 $K$。

第二行包含 $N$ 个空格分隔的整数 $a_1,a_2,\ldots,a_N$。 
## 输出格式

 输出达到目标所需要的最小时间。
## 样例

### 样例输入 #1
```
10 2 1 2
6
```
### 样例输出 #1
```
22
```
### 样例输入 #2
```
10 2 1 2
7
```
### 样例输出 #2
```
4
```
### 样例输入 #3
```
32 4 5 2
0 23 12 5 11
```
### 样例输出 #3
```
48
```
### 样例输入 #4
```
24 3 1 2
16
```
### 样例输出 #4
```
48
```
## 提示

### 样例解释 1

我们可以通过顺时针移动在 $4$ 秒内到达点 $6$ 的激活点。此时，初始的机器人将位于点 $2$。再等待 $18$ 秒直到初始机器人位于点 $1$。现在我们可以放置一个机器人以立即获胜。 

### 样例解释 2

我们可以通过顺时针移动在 $3$ 秒内到达点 $7$ 的激活点。此时，初始的机器人将位于点 $1.5$。再等待一秒直到初始机器人位于点 $2$。现在我们可以放置一个机器人以立即获胜。 

### 测试点性质

- 测试点 $5-6$：$R=2$。
- 测试点 $7-12$：$R\le 10,N\le 80$。
- 测试点 $13-20$：$R\le 16$。
- 测试点 $21-24$：没有额外限制。


---

---
title: "BZOJ2162 男生女生"
layout: "post"
diff: 省选/NOI-
pid: P10598
tag: ['O2优化', '二分图', '容斥原理']
---
# BZOJ2162 男生女生
## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

---

雨荨的班主任安远老师是一个非常严厉的老师。到了大学，男生和女生之间难免会出现一些暧昧关系，但这样显然是影响学习的。所以作为艾利斯顿的一块招牌，安远老师当然要拒绝这种现象的出现以及繁衍。

所以每当安远老师发现一个男生和一个女生放学走在一起或者男女生之间互相传纸条等，他就会立马制止并且通知家长。他也要求所有男女生晚上八点之后必须关手机，并且不定期打电话检查。于是安远老师的学生都感慨：这货不是大学，不是大学。
## 题目描述

安远老师的学生里，一共有 $n$ 个男生和 $n$ 个女生，编号都以 $1\sim n$ 编号。有 $m$ 对男女生之间有暧昧关系。现在安远老师想找出这样一个男女生群体，每个男生都和每个女生之间有暧昧关系，并且男女生总数最大。注意，男生数目或者女生数目可以为 $0$。

如果有多个这样的群体，安远老师会选择男生最多的那个群体，因为他觉得男生会很不安分。如果这样的群体依然不唯一，他会选择任意一个。

接下来，安远老师从选出的这个群体的所有暧昧关系中，选出 $k$ 个进行调查，使得这个群体的所有男生和女生，都至少和其中的一对暧昧关系有关系（即是这个暧昧关系的男/女主人公）。安远老师想让你告诉他总方案数除以 $19921228$ 的余数是多少。
## 输入格式

输入的第一行包含两个正整数 $n$ 和 $k$，分别代表男生女生的个数，以及安远老师要选择的暧昧关系个数。

第二行为一个正整数 $m$，代表暧昧关系总个数。接下来 $m$ 行，每行两个整数，代表一对有暧昧关系的男女生编号。
## 输出格式

第一行有两个空格隔开的整数，代表选择的团体内男生和女生的个数。第二行有一个整数，代表选法除以 $19921228$ 的余数。
## 样例

### 样例输入 #1
```
3 2 
4
1 1
1 2
2 1
2 2
```
### 样例输出 #1
```
2 2
2
```
## 提示

对于所有数据，$1\leq n \leq 50$，$1\leq m,k \leq 2500$。同一对暧昧关系不会在输入中出现多次。


---

---
title: "[CEOI 2009] Harbingers"
layout: "post"
diff: 省选/NOI-
pid: P10602
tag: ['动态规划 DP', '2009', '二分', 'O2优化', 'CEOI（中欧）', '斜率优化', '单调栈']
---
# [CEOI 2009] Harbingers
## 题目描述

给定一颗树，树中每个结点有一个邮递员，每个邮递员要沿着唯一的路径走向 capital（$1$ 号结点），每到一个城市他可以有两种选择：

1. 继续走到下个城市；
2. 让这个城市的邮递员替他出发。

每个邮递员出发需要一个准备时间 $W_i$，他们的速度是 $V_i$，表示走一公里需要多少分钟。现在要你求出每个城市的邮递员到 capital 的最少时间（不一定是他自己到 capital，可以是别人帮他）？
## 输入格式

第一行一个正整数 $N$；

接下来 $N-1$ 行，每行三个正整数 $A,B,C$，表示结点 $A$ 和 $B$ 之间有一条长度为 $C$ 的边；

再接下来 $N-1$ 行，每行 $2$ 个整数 $W_i,V_i$。
## 输出格式

输出每个城市的邮递员到 capital 的最少时间。
## 样例

### 样例输入 #1
```
5
1 2 20
2 3 12
2 4 1
4 5 3
26 9
1 10
500 2
2 30
```
### 样例输出 #1
```
206 321 542 328
```
## 提示

对于 $20\%$ 的数据，$N\leq 2500$；

对于 $50\%$ 的数据，树是一条链；

对于所有数据，$3\leq N\leq 10^5$，$0\leq W_i,V_i\leq 10^9$，每条边长度不超过 $10^4$。


---

---
title: "异界之门"
layout: "post"
diff: 省选/NOI-
pid: P10610
tag: ['洛谷原创', 'Special Judge', 'O2优化', '二分图', '洛谷月赛']
---
# 异界之门
## 题目背景

跟随着线索，莲子来到了七夕坂。无暇欣赏此处的风景，高速运转着大脑的莲子，不断寻找异界的线索。翻转的地藏、奇异的裂缝、被隐匿的第五个季节……这个禁忌之中的世界，正向她揭晓着自己的秘密。

但莲子第一时间看到的只有梅莉，来不及思考，她一把抓住了梅莉的手——
## 题目描述

嗅觉敏锐的莲子察觉到，进入异界的方法一定和这些特别的地藏有所联系。她发现它们恰好构成了一棵形状特殊的树。

给定一棵 $n$ 个点的带点权的**有根**树，其根为 $1$，且点 $i$ 的点权为 $w_i$。**其满足对于任意两个深度相同的结点，它们的儿子数也相同**。

为了进入异界，莲子进行了一些操作来改变这棵树的点权：

1. 选择一条边，假设它连接了两点 $(u,v)$，设其中深度更高者为 $u$（即 $u$ 是 $v$ 的儿子），将 $w_u$ 加上 $w_v$。
2. 上述操作可以被执行任意多次，但是**不能重复选择同一条边**。

经过操作后，莲子求出了树的某个 [DFS 序列](https://oi-wiki.org/graph/dfs/)，并记录下了这个 DFS 序列所对应的点权序列 $c$（具体来说，$c_i$ 为 DFS 序过程中遍历到的第 $i$ 个点的点权）。

不幸的是，她突然忘记了她进行过哪些操作，也忘记了如何 DFS 这棵树，她希望你能还原出任意一组合法的操作方案与 DFS 序列。
## 输入格式

第一行一个整数 $n$。

对于接下来 $n$ 行：第 $i$ 行两个整数 $f_i,w_i$，其中 $f_i$ 代表点 $i$ 的父节点（特别的，$f_1=0$，对于其余节点有 $1\le f_i<i$），$w_i$ 代表点 $i$ 的权值。

接下来一行 $n$ 个整数描述序列 $c$，代表莲子的 DFS 序列所对应的点权序列 $c$。保证一定存在一种合法的操作方式和操作后的 DFS 方式得到序列 $c$。
## 输出格式

第一行一个整数 $m$，表示你进行的操作数。

接下来一行 $m$ 个数，第 $i$ 个数 $x_i$ 代表你在第 $i$ 次操作选择连接节点 $x_i$ 和其父节点 $f_{x_i}$ 的边进行操作。

接下来一行 $n$ 个数描述一个排列 $p$，其中 $p_i$ 代表你构造的 DFS 序列中遍历到的第 $i$ 个节点为点 $p_i$。
## 样例

### 样例输入 #1
```
4
0 1
1 2
2 3
3 4
1 3 5 9
```
### 样例输出 #1
```
3
3 4 2
1 2 3 4
```
### 样例输入 #2
```
5
0 1
1 -1
1 -1
2 3
3 4
1 0 3 0 3
```
### 样例输出 #2
```
3
2 5 3
1 2 4 3 5
```
### 样例输入 #3
```
4
0 1
1 2
1 3
1 4
1 4 3 3
```
### 样例输出 #3
```
1
2
1 4 2 3
```
### 样例输入 #4
```
5
0 1
1 1
1 1
2 1
3 1
1 2 2 2 3
```
### 样例输出 #4
```
4
2 4 5 3
1 3 5 2 4
```
## 提示

### 样例解释

#### 样例 \#1

![](https://cdn.luogu.com.cn/upload/image_hosting/ihq8vqnc.png)

其中一种可行的方案是依次操作边 $(2,3),(3,4),(1,2)$，操作后的树的点权序列为 $\{1,3,5,9\}$，选出的 DFS 序列为 $\{1,2,3,4\}$。

注意到该样例符合特殊性质 $\mathbf{A}$。

#### 样例 \#2

![](https://cdn.luogu.com.cn/upload/image_hosting/z14j0aeu.png)

其中一种可行的方案是依次操作边 $(1,2),(3,5),(1,3)$，操作后的树的点权序列为 $\{1,0,0,3,3\}$，选出的 DFS 序列为 $\{1,2,4,3,5\}$。
#### 样例 \#3

![](https://cdn.luogu.com.cn/upload/image_hosting/7livbzzu.png)

其中一种可行的方案是依次操作边 $(1,2)$，操作后的树的点权序列为 $\{1,3,3,4\}$，选出的 DFS 序列为 $\{1,4,2,3\}$。

注意到该样例符合特殊性质 $\mathbf{B}$。
#### 样例 \#4

![](https://cdn.luogu.com.cn/upload/image_hosting/9bopbeh3.png)

其中一种可行的方案是依次操作边 $(1,2),(2,4),(3,5),(1,3)$，操作后的树的点权序列为 $\{1,2,3,2,2\}$，选出的 DFS 序列为 $\{1,3,5,2,4\}$。

注意到该样例符合特殊性质 $\mathbf{C}$。

### 数据范围

**本题采用捆绑测试。**

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \textbf{\textsf{分值}} & \bm{n\le } & \textbf{\textsf{特殊性质}}&\textbf{Subtask \textsf{依赖}}\cr\hline
1 & 10 & 6 & - &-\cr\hline
2 & 10 & 100 & \mathbf{A}&- \cr\hline
3 & 10 & 100 & \mathbf{B}&- \cr\hline
4 & 15 & 2\times 10^3 & \mathbf{C}&-  \cr\hline
5 & 15 & 2\times 10^3 & \mathbf{D}&-  \cr\hline
6 & 15 & 100 & -&1,2,3  \cr\hline
7 & 25 & 2\times 10^3 & -&1,2,3,4,5,6  \cr\hline
\end{array}
$$

特殊性质 $\mathbf{A}$：保证给出的树满足 $f_i=i-1$ ($i\ne 1$)。\
特殊性质 $\mathbf{B}$：保证给出的树满足 $f_i=1$ ($i\ne 1$)。\
特殊性质 $\mathbf{C}$：保证给出的树满足 $w_i=1$。\
特殊性质 $\mathbf{D}$：保证给出的树满足所有非叶节点儿子数不超过 $2$。

对于所有数据满足：$1\le n\le 2000$，$-10^8\le w_i\le 10^8$，$-10^{14}\le c_i\le 10^{14}$。


---

---
title: "[JOI Open 2024] 图书馆 3"
layout: "post"
diff: 省选/NOI-
pid: P10628
tag: ['二分', '2024', '交互题', 'Special Judge', '置换', 'JOI（日本）']
---
# [JOI Open 2024] 图书馆 3
## 题目背景

由于洛谷评测系统的限制，实际提交时，不需要引入 $\texttt{library3.h}$。你需要在代码中添加：

```cpp
void answer(std::vector<int>);
int query(std::vector<int>);
```

请使用 C++ 20 提交，不保证使用其他标准提交能够通过。
## 题目描述

几百年的时光弹指一瞬，JOI 城已然是一片废墟。IOI 酱——一个探险家，正在探索图书馆的故址。由探索结果得知：

- JOI 城的图书馆中有一个水平的书架，上面有 $N$ 个**位置**来放书，从左到右依次编号为 $0\sim N-1$。一个位置只能放一本书。
- 有 $N$ 本书放在书架上，编号为 $0\sim N-1$。
- 定义 $N$ 本书的一个**摆放**为一种将 $N$ 本书放在 $N$ 个位置上的方式。
- 存在 $N$ 本书的一个**正确摆放**，其中第 $B_i$（$0\le i\le N-1$）本书放在位置 $i$ 上，其中 $B_i$ 两两不同。

书的摆放总会改变，而这个图书馆是通过不断重复以下步骤来将书还原成正确摆放的：

> **操作** 令 $x$ 是最左边的书，满足 $x$ 的位置与它在正确摆放中的位置不同。令 $y$ 为 $x$ 正确位置上的书，交换 $x,y$。

尽管 IOI 酱找到了许多旧书，她无法得知书的正确摆放。然而，她发现了一台旧机器，可以执行上面的操作。如果指定一个摆放并向机器发起询问，机器就会回答从当前摆放到正确摆放，需要重复执行多少次操作。IOI 酱想要利用这台机器，获得书的正确摆放。由于机器过于老旧，她最多只能询问 $5\, 000$ 次。

你需要写一个程序。给定书架的信息，通过最多 $5\,000$ 次询问，找出书的正确摆放。

【实现细节】

**这是一道交互题，你只需要提交一个文件（`library3.cpp`）。**

你需要在文件中引入 `library3.h`，并实现以下函数：

- `void solve(int N)`\
该函数在每个测试点中被调用恰好一次。
    - 参数 $N$ 代表书的数量。

在 `library3.cpp` 中，你可以调用以下函数：

- `int query(const std::vector<int> a)`\
IOI 酱用这个函数向机器发起询问。
    - 参数 `a` 为一个长度为 $N$ 的数组，即要询问的摆放。也就是说，在指定的摆放中，第 `a[i]` 本书（$0\le i\le N-1$）被放在位置 $i$。
    - 返回值为一个整数，即从指定的摆放到正确摆放，需要重复执行多少次操作。
    - 参数中，数组 `a` 的长度必须为 $N$。如果不满足这个条件，你的程序将被判为 **Wrong Answer[1]**。
    - 参数中，数组 `a` 中的每个元素都必须在 $0$ 到 $N-1$ 之间。如果不满足这个条件，你的程序将被判为 **Wrong Answer[2]**。
    - 参数中，数组 `a` 中的元素必须两两不同。如果不满足这个条件，你的程序将被判为 **Wrong Answer[3]**。
    - 该函数最多只能被调用 $5\,000$ 次。如果超出调用次数，你的程序将被判为 **Wrong Answer[4]**。

- `void answer(std::vector<int> b)`\
你的程序用这个函数回答正确摆放。
    - 参数 `b` 为一个长度为 $N$ 的数组，即正确摆放。也就是说，在正确摆放中，第 `b[i]` 本书（$0\le i\le N-1$）被放在位置 $i$。
    - 参数中，数组 `b` 的长度必须为 $N$。如果不满足这个条件，你的程序将被判为 **Wrong Answer[5]**。
    - 参数中，数组 `b` 中的每个元素都必须在 $0$ 到 $N-1$ 之间。如果不满足这个条件，你的程序将被判为 **Wrong Answer[6]**。
    - 参数中，数组 `b` 中的元素必须两两不同。如果不满足这个条件，你的程序将被判为 **Wrong Answer[7]**。
    - 如果你回答的摆放并不是正确摆放，你的程序将被判为 **Wrong Answer[8]**。
    - 该函数必须被调用恰好一次。如果超出调用次数，你的程序将被判为 **Wrong Answer[9]**。如果未调用，你的程序将被判为 **Wrong Answer[10]**。

【注意事项】

你的程序可以定义其他函数，也可以使用全局变量。

你的程序不得使用标准输入输出流，不得以任何形式读写其他文件。但是，你的程序可以使用标准错误流来输出调试信息。

【编译运行】

可以从附件中获取 sample grader。Sample grader 即为文件 `grader.cpp`。将 `grader.cpp`，`library3.cpp`，`library3.h` 放置在同一目录下，运行以下命令即可编译你的程序。你也可以运行文件 `compile.sh` 来编译程序。

> 编译命令：`g++ -std=gnu++20 -O2 -o grader grader.cpp library3.cpp`

编译成功的话，会生成可执行文件 `grader`。注意，实际评测时用的 grader 与 sample grader 是不同的。Sample grader 会以单进程方式执行，从标准输入流中读取数据，输出结果到标准输出流。

*赛时公告：Sample grader 是非适应性的。实际评测时使用的 grader 是否适应是未知的。


## 输入格式

Sample grader 按照以下方式读取输入：

> $N$\
> $B_0$ $B_1$ $\cdots$ $B_{N-1}$

在正确摆放中，第 $B_i$（$0\le i\le N-1$）本书放在位置 $i$ 上。
## 输出格式

Sample grader 会输出以下结果：

- 如果你的程序被评为正确的，返回调用 `query` 函数的次数。例如：`Accepted: 3000`。
- 否则，如果你的程序满足任一形式的错误，则按照题目描述中的错误类型输出。例如：`Wrong Answer[3]`。

如果你的程序同时满足多种错误的条件，只会输出一种错误。
## 样例

### 样例输入 #1
```
4
2 0 3 1
```
### 样例输出 #1
```

```
## 提示



如下是一种可能的交互过程：

| 调用 | 调用 | 返回值 |
| :--: | :--:| :--: |
| `solve(4)` | | |
| | `query([0, 1, 2, 3])` | `3` |
| | `query([1, 3, 0, 2])` | `2` |
| | `query([3, 0, 1, 2])` | `2` |
| | `query([2, 0, 3, 1])` | `0` |
| | `answer([2, 0, 3, 1])` | |


考虑调用 `query([0, 1, 2, 3])`。操作将会按照如下方式进行：

- 交换第 $0$ 本书和第 $1$ 本书的位置。于是，第 $1,0,2,3$ 本书分别被放在位置 $0,1,2,3$ 上。
- 交换第 $1$ 本书和第 $3$ 本书的位置。于是，第 $3,0,2,1$ 本书分别被放在位置 $0,1,2,3$ 上。
- 交换第 $3$ 本书和第 $2$ 本书的位置。于是，第 $2,0,3,1$ 本书分别被放在位置 $0,1,2,3$ 上。

在 $3$ 次操作后，将指定的摆放还原成了正确的摆放，所以返回值为 `3`。

样例满足所有子任务的限制条件。

### 数据范围

- $2 \le N \le 500$；
- $0 \le B_i \le N - 1$（$0 \le i \le N - 1$）；
- $B_i\neq B_j$（$0 \le i < j \le N - 1$）；
- 输入数字全为整数。

### 子任务

1. （$2 $ points）$N \le 6$；
2. （$19$ points）$N \le 100$；
3. （$79$ points）无额外约束。

由 Starrykiller 根据英文题面翻译。


---

---
title: "[COTS 2024] 划分 Particija"
layout: "post"
diff: 省选/NOI-
pid: P10683
tag: ['2024', 'O2优化', '二分图', 'COCI（克罗地亚）']
---
# [COTS 2024] 划分 Particija
## 题目背景

译自 [Izborne Pripreme 2024 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2024/) D2T1。$\texttt{1s,512M}$。
## 题目描述



给定正整数 $ N $。

集合 $ \{1, 2, \ldots, N\} $ 的**划分**为由非空集合组成的集族，满足：
- $\forall 1\le i\le N$，$i$ 出现在**恰好一个**集合中。

例如，$\{\{1,3\},\{2,4\},\{5\}\}$ 是集合 $ \{1, 2, 3, 4, 5\} $ 的一个划分。

可以用数列 $ [x_1, x_2, \ldots, x_N ]$ 来表示划分。当且仅当 $ x_i = x_j $ 时，$ i $ 和 $ j $ 在同一个集合中。上面提到的划分 $\{\{1,3\},\{2,4\},\{5\}\}$ 可以由数列 $[1, 2, 1, 2, 3]$ 或者 $[5, 1, 5, 1, 4]$ 表示。

Patricija 拥有两个划分：第一个划分用数列 $ [a_1, a_2, \ldots, a_N] $ 表示，第二个划分用数列 $ [b_1, b_2, \ldots, b_N] $ 表示。

Patricija 想知道以下问题的答案：如果她使用这两个划分中的集合，来构造集合 $ \{1, 2, \ldots, N\} $ 的划分，至少需要多少个集合。


给定参数 $k\in \{0,1,2\}$，

- 当 $k=0$ 时，你需要回答原问题的答案。
- 当 $k=1$ 时，允许更改 $2N$ 个数字（$a_1,\cdots,a_N,b_1,\cdots,b_N$）中**至多**一个，**最小化**构造划分需要的最少集合数。
- 当 $k=2$ 时，允许更改 $2N$ 个数字（$a_1,\cdots,a_N,b_1,\cdots,b_N$）中**至多**一个，**最大化**构造划分需要的最少集合数。

请注意，你需要保证在你修改后，$\forall 1\le i\le N$，$1\le a_i,b_i\le N$。
## 输入格式


**本题单个测试点内有多组测试数据。**

第一行，两个整数 $T,k$，分别表示测试数据数量，以及参数。

接下来依次描述 $T$ 组测试数据：

对于每组测试数据，输入三行。

第一行，一个正整数 $N$，含义见题面；

第二行，$N$ 个正整数，依次表示 $a_1,a_2,\cdots,a_N$；

第三行，$N$ 个正整数，依次表示 $b_1,b_2,\cdots,b_N$。


## 输出格式


对于每组测试数据，输出一行一个整数，表示所求的答案。
## 样例

### 样例输入 #1
```
2 0
4 
1 1 2 3
1 2 3 3
7
1 1 1 1 2 3 4
1 2 3 4 4 4 4
```
### 样例输出 #1
```
2
4
```
### 样例输入 #2
```
3 1
4
1 1 2 3
1 2 3 3
4
1 1 1 1
1 2 3 3
7
1 1 1 1 2 3 4
1 2 3 4 4 4 4
```
### 样例输出 #2
```
2
1
2
```
### 样例输入 #3
```
3 2
4 
1 1 2 3
1 2 3 3
4
1 1 1 3
1 2 3 3
7
1 1 1 2 3 4 5
1 2 3 4 4 4 4
```
### 样例输出 #3
```
3
3
4
```
## 提示


#### 样例解释

样例 $1$ 解释：

对于第一组数据，第一个划分为 $\{\{1,2\},\{3\},\{4\}\}$，第二个划分为 $\{\{1\},\{2\},\{3,4\}\}$。选取 $\{1,2\},\{3,4\}$ 即可。

对于第二组数据，第一个划分为 $\{\{1,2,3,4\},\{5\},\{6\},\{7\}\}$，第二个划分为 $\{\{1\},\{2\},\{3\},\{4,5,6,7\}\}$。选取第一个划分或第二个划分即可。

#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le T\le 200\, 000$，$k\in \{0,1,2\}$；
- $1\le a_i,b_i\le N$；
- $1\le N,\sum N\le 200\, 000$。

| 子任务编号 | 分值 | 约束  |
|:-----:|:------:|:-------:|
| $1$  | $7$  | $k=0,N\le 8,\sum 2^N\le 10^5$   |
| $2$  | $23$  | $k=0$  |
| $3$  | $15$  | $k=1,N\le 1\, 000,\sum N^2\le 10^6$ |
| $4$  | $16$  | $k=1$ |
| $5$  | $19$  | $k=2,N\le 1\, 000,\sum N^2\le 10^6$ |
| $6$  | $20$  | $k=2$ |




---

---
title: "[COTS 2024] 兔子 Zečevi"
layout: "post"
diff: 省选/NOI-
pid: P10685
tag: ['二分', '2024', 'O2优化', 'COCI（克罗地亚）']
---
# [COTS 2024] 兔子 Zečevi
## 题目背景

译自 [Izborne Pripreme 2024 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2024/) D2T3。$\texttt{8s,512M}$。

**请不要滥用本题评测。滥用本题评测将被封号。**
## 题目描述


数轴上有 $N$ 只兔子，第 $i$ 只兔子位于 $x_i$，起初，第 $i$ 只兔子的能量为 $p_i$。

每秒钟会发生如下的事件：

- 若存在至少一只兔子的能量为 $0$，则过程结束。
- 否则，每只兔子向右跳跃一个单位长度，同时能量减少 $1$。

数轴上分布着 $M$ 根胡萝卜，第 $i$ 根胡萝卜位于位置 $y_i$，质量为 $t_i$ 千克。当某只兔子的位置上有胡萝卜时，它可以选择吃 $a$ 千克的胡萝卜，其中 $a\in [0, y]$，其中 $y$ 为胡萝卜的质量。吃掉 $a$ 千克的胡萝卜后，兔子的能量增加 $a$，胡萝卜的质量减少 $a$。

显然兔子一旦停止跳跃，就再也不会跳跃了。在最优的情况下，兔子最多能跳跃多少秒？
## 输入格式


第一行，两个整数 $N,M$，含义见题面。

接下来 $N$ 行，第 $i$ 行两个整数 $x_i,p_i$；

接下来 $M$ 行，第 $i$ 行两个整数 $y_i,t_i$。

## 输出格式


输出一行一个整数，表示最优情况下的答案。
## 样例

### 样例输入 #1
```
3 5
2 4
7 3
9 5
3 2
8 1
10 2
6 3
1 3
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
5 1
2 6
3 7
5 4
1 10
7 2
8 27
```
### 样例输出 #2
```
11
```
## 提示


#### 样例解释

样例 $1$ 解释：

我们用二元组 $(x_i,p_i)$ 表示兔子的位置和能量。

跳跃三次后，三只兔子的状态分别为 $(5,1),(10,0),(6,2)$。第二只兔子吃掉 $2$ 千克的胡萝卜，状态变为 $(5,1),(10,2),(6,2)$。

接下来一次跳跃之后，三只兔子的状态分别为 $(6,0),(11,1),(7,1)$。第一只兔子吃掉 $3$ 千克胡萝卜，状态变为 $(6,3),(11,1),(7,1)$。

接下来一次跳跃之后，三只兔子的状态分别为 $(7,2),(12,0),(8,0)$。由于第二只兔子吃不到胡萝卜，所以跳跃过程终止。

可以证明这是最优的答案。

#### 数据范围

对于 $100\%$ 的数据，保证： 

- $1\le N,M\le  10^5$；
- $0\le x_i,y_i\le 10^9$；
- $0\le p_i,t_i\le 10^9$。

| 子任务编号 | 分值 | 约束  |
|:-----:|:------:|:-------:|
| $1$  | $9$  | $N=1$   |
| $2$  | $12$  | $M=1$  |
| $3$  | $26$  | $N,M\le 1\, 000$ |
| $4$  | $34$  | $N,Q\le 50\, 000$ |
| $5$  | $19$  | 无额外约束 |



---

---
title: "[NOIP 2012 提高组] 疫情控制"
layout: "post"
diff: 省选/NOI-
pid: P1084
tag: ['贪心', '树形数据结构', '2012', '倍增', '二分', 'NOIP 提高组', '排序']
---
# [NOIP 2012 提高组] 疫情控制
## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。

## 输入格式

第一行一个整数 $ n$，表示城市个数。

接下来的 $n-1$ 行，每行 $ 3 $ 个整数，$u,v,w$，每两个整数之间用一个空格隔开，表示从城市 $u $ 到城市 $ v$ 有一条长为 $w$ 的道路。数据保证输入的是一棵树，且根节点编号为 $1$。

接下来一行一个整数 $m$，表示军队个数。

接下来一行 $m $ 个整数，每两个整数之间用一个空格隔开，分别表示这 $m$ 个军队所驻扎的城市的编号。

## 输出格式

一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出 $-1$。

## 样例

### 样例输入 #1
```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2
```
### 样例输出 #1
```
3
```
## 提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题



---

---
title: "运输规划"
layout: "post"
diff: 省选/NOI-
pid: P10919
tag: ['O2优化', '二分图', '树链剖分', '笛卡尔树']
---
# 运输规划
## 题目背景

你需要规划卡车的运输方案，为了让您更好地解决问题，**请仔细阅读题面。**
## 题目描述

有 $n$ 个城市，对于任意 $1 < i \leq n$ 满足第 $i$ 个城市与第 $i-1$ 个城市间有一条双向的道路，每个城市有一个对卡车高度的限制 $h_i$，代表只有高度小于等于 $h_i$ 的卡车可以从这个城市经过，现在有 $m$ 个城市 $S_{1},S_{2},...,S_{m}$ 各有**恰好**一个运输任务，任务要求**编号为 $i$ 且高度为 $h_{S_{i}}$ 的**卡车从城市 $S_{i}$ 出发**到达**任意一个有机场的城市，而有 $m$ 个城市有机场，分别为 $T_{1},T_{2},...,T_{m}$，对于一个合法的运输方案而言，需要保证每个卡车都到达一个机场且每个机场**恰好**有一辆卡车**抵达**。一个机场**可以**同时被多辆卡车**经过**。请注意，如果你无法经过某个城市，那么你也无法抵达这个城市。

记 $c_i$ 表示抵达位于城市 $T_i$ 的机场的的**卡车编号**，令数组 $F = \{c_1,c_2,...,c_m\}$，请你最小化 $F$ 的字典序并输出 $F$。

我们定义两个长度为 $len$ 的数组 $A,B$ 满足 $A$ 的字典序小于 $B$ 当且仅当存在 $0 \leq i < len$ 满足对于任意 $1 \leq j \leq i$ 满足 $A_j = B_j$ 且 $A_{i+1} < B_{i+1}$。

数据保证有解，保证**所有 $h_i$ 互不相同**，所有 $T_i$ 互不相同，所有 $S_i$ 互不相同。但是**可能会**存在 $i,j$ 满足 $S_i = T_j$。

## 输入格式

第一行两个数 $n,m$。

接下来一行 $n$ 个数表示 $h_1,h_2,...,h_n$。

再接下来一行 $m$ 个数表示 $S_{1},S_{2},...,S_{m}$。

再接下来一行 $m$ 个数表示 $T_{1},T_{2},...,T_{m}$。


## 输出格式

输出一行 $m$ 个数表示 $F$。
## 样例

### 样例输入 #1
```
10 3 
1 2 3 5 4 10 8 6 7 9
1 2 8
6 10 3

```
### 样例输出 #1
```
1 3 2
```
### 样例输入 #2
```
20 5
12 13 14 15 16 17 18 19 20 22 21 30 29 28 27 26 23 24 25 1
1 20 2 5 3 
10 12 11 9 13 

```
### 样例输出 #2
```
1 2 3 4 5
```
## 提示

**本题采用捆绑测试**。

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $n,m \leq 50$ | $10$ |
| $2$ | 对于任意 $1 < i \leq n$ 满足 $h_i < h_{i-1}$ | $25$ |
| $3$ | $n,m \leq 10^3$ | $25$ |
| $4$ | 无特殊性质 | $40$ |

对于 $100\%$ 的数据保证 $1 \leq m \leq n \leq 2 \times 10^5,0 < h_i \leq 10^9$。



---

---
title: "「SFMOI Round I」Strange Dino Game"
layout: "post"
diff: 省选/NOI-
pid: P11147
tag: ['模拟', '动态规划 DP', '贪心', '二分', '洛谷原创', 'O2优化', '洛谷月赛']
---
# 「SFMOI Round I」Strange Dino Game
## 题目背景

[English statement](https://www.luogu.com.cn/problem/T517979). **You must submit your code at the Chinese version of the statement.**


![](https://cdn.luogu.com.cn/upload/image_hosting/59joca92.png?x-oss-process=image/resize,m_lfit,h_600)

![](https://cdn.luogu.com.cn/upload/image_hosting/iyhol5l6.png?x-oss-process=image/resize,m_lfit,h_600)

Watersphere 同学在家没网了，只好玩起了 dino 游戏，但是他很菜，一玩到后面就头晕眼花，所以想让你编个程序帮助他拿到更高分，于是有了这题。

本题的游戏背景是 [Dino](https://dinosaur.game)。可以考虑点击链接游玩，以便更好理解题意。
## 题目描述


我们将问题放在二维平面上描述。我们给出一些游戏要素：

- 玩家：Dino。可以将其视为一个点。
- 障碍物：
    - 仙人掌：形如 $(x_i',0),(x_i',h_i)$ 的线段。
    - 飞鸟：形如 $(x_i,d_i),(x_i,u_i)$ 的线段。
- 游戏结束：Dino 与障碍物上的任意一点（包括线段端点）重合时，游戏结束。
- 起点：原点 $(0,0)$。
- 终点：使游戏结束的位置，位于第一象限（或 $x$ 轴上）。可能不存在（即游戏能无限进行）。
- 游戏分数：终点的 $x$ 坐标。终点不存在时定义为无穷大。
- 跳跃参数：正整数 $d,h$。
- 步行：Dino 在 $x$ 轴上沿着 $x$ 轴正方向移动。
- 跳跃：当 Dino 在 $x$ 轴上时，可以进行一次跳跃。以起跳点为原点，跳跃轨迹为
    $$f(x) = \begin{cases}
    \displaystyle  \frac{h}{d}x & x\in [0, d)  \\
    \displaystyle-\frac{h}{d}x+2h  & x\in [d, 2d)  \\
    \end{cases}$$
    - 需要注意的是，由上述定义可以推出：**在一次跳跃后落地的瞬间进行第二次跳跃是合法的。**
    - 需要注意的是，可以在任意**实数点**（只要在 $x$ 轴上）处开始跳跃。也就是说，跳跃不一定在整点开始。
    
下图展示了 $d=2,h=6$ 时的一次跳跃。

![](https://cdn.luogu.com.cn/upload/image_hosting/1gxrno9x.png?x-oss-process=image/resize,m_lfit,h_400)

在一局游戏中，Dino 从起点出发向 $x$ 轴正方向移动。目标是最大化得分，即尽量避开障碍物，使自己移动的距离尽量长。

每一时刻，Dino 只能做一件事：步行，或跳跃。当且仅当 Dino 在 $x$ 轴上时可以进行跳跃。

形式化地说，Dino 的行为可以被描述为一个长度为 $(k+1)$ 的实数二元组序列 $[(x_0,t_0),(x_1,t_1),\cdots,(x_k,t_k)]$，满足：

- $x_0=0$；
- $t_i\in \{0,1\}$；
- $\forall 0\le i\lt k$, $x_i\lt x_{i+1}$；
- $t_i=1,i\lt k\implies x_{i+1}-x_i\ge 2d$；(二段跳是不允许的)
- $\forall 0\le i\lt k$, $t_i=t_{i+1}\implies t_i=t_{i+1}=1$。

当 $t_i=0$ 时，我们定义 Dino 在 $x_i$ **进入步行状态**，否则定义 Dino 在 $x_i$ **进入跳跃状态**。

当 Dino 与障碍物重合时，游戏结束。此时 Dino 在的位置为终点，得分为终点的 $x$ 坐标。

已知有 $b$ 只飞鸟和 $c$ 个仙人掌，求出 Dino 的最大得分。特别地，得分可以为无穷大。

可参阅样例解释的图片。
## 输入格式


**本题单个测试点内有多组测试数据。**

第一行，一个正整数 $T$，代表游戏次数。

接下来依次描述 $T$ 组数据：

- 每组数据第一行，两个正整数 $d,h$，表示 dino 的跳跃参数。
- 每组数据第二行，两个整数 $b,c$，表示飞鸟个数与仙人掌个数。
- 接下来 $b$ 行，每行三个正整数 $x_{i},u_i,d_i$，描述第 $i$ 只飞鸟。
- 接下来 $c$ 行，每行两个正整数 $x'_{i},h_{i}$，描述第 $i$ 株仙人掌。

## 输出格式

对于每组数据输出一行，表示得分的最大值。

特别地，如果得分为正无穷，输出 `Dino!`。

## 样例

### 样例输入 #1
```
2
1 3
1 2
1 2 1
2 2
3 2
1000000000 1000000000
1 0
114514 1919 810
```
### 样例输出 #1
```
3
Dino!
```
### 样例输入 #2
```
1
8 16
8 3
5 18 13
4 20 10
6 13 1
2 17 11
1 11 6
5 1 1
2 6 3
1 16 1
7 20
7 13
3 2
```
### 样例输出 #2
```
6
```
### 样例输入 #3
```
1
5 5
1 2
5 5 1
6 1
16 3
```
### 样例输出 #3
```
16
```
### 样例输入 #4
```
1
5 5
1 4
19 10 8
4 1
15 1
22 2
20 1
```
### 样例输出 #4
```
22
```
## 提示


样例 $1$ 解释：  

- 对于第 $1$ 组数据，dino 无论如何也无法跳过连续的两株高为 $2$ 的仙人掌，答案即为第二株仙人掌的 $x$ 轴坐标。
- 对于第 $2$ 组数据，dino 可以在原点直接起跳跳过唯一的一只鸟，也完全可以不起跳从飞鸟下方走过。

其中第一组数据的解释如下所示，红线代表飞鸟，绿线代表仙人掌，粉线代表 Dino 的轨迹。

![](https://cdn.luogu.com.cn/upload/image_hosting/ge17so5a.png?x-oss-process=image/resize,m_lfit,h_400)

### 数据范围

**本题采用捆绑测试。**

- Subtask 1（5 pts）：$c=0$；
- Subtask 2（5 pts）：$b,c \le 10$；
- Subtask 3（20 pts）：$b=0$；
- Subtask 4（20 pts）：$1 \le d,h,x_{b_i},d_i,u_i,x_i',h_i \le 10^5$;
- Subtask 5（40 pts）：无特殊限制。
- Subtask 6（10 pts）：无特殊限制。

对于 $100\%$ 的数据，保证：
- $1 \le T \le 10$；
- $0 \le b,c \le 2\times 10^4$；
- $1 \le d,h,x_{b_i},d_i,u_i,x_i',h_i\le 10^9$；
- $d_i\le u_i$。


---

---
title: "「KDOI-10」水杯降温"
layout: "post"
diff: 省选/NOI-
pid: P11189
tag: ['动态规划 DP', '贪心', '二分', '2024', '洛谷原创', 'O2优化', '洛谷月赛']
---
# 「KDOI-10」水杯降温
## 题目背景

[English Statement](https://www.luogu.com.cn/problem/T514967). You must submit your code at the Chinese version of the statement.

**本场比赛所有题目从标准输入读入数据，输出到标准输出。**
## 题目描述

小 S 有一棵包含 $n$ 个节点的有根树，且根为节点 $1$。节点 $i$ $(1\le i\le n)$ 上放置了一个初始水温为 $a_i$ 的水杯。

在不知道水温的情况下拿起水杯喝水并被烫了 inf 次的小 S 决定将这些水杯的水温全部变为 $0$ 后再喝它们。

现在，小 S 可以分别进行以下两种操作任意次：

* 使用一个在节点 $i$ 的加热装置。这会使以 $i$ 为根的子树内所有水杯里的水温均增加 $1$；
* 或者，从某个**叶子**节点 $i$ 向根方向吹一阵风。这会使 $i$ 到根所有水杯里的水温均减少 $1$。

请你帮小 S 判断：能否将所有节点上的水杯的水温都变为 $0$。


## 输入格式

从标准输入读入数据。

**本题有多组测试数据。** 

输入的第一行包含一个正整数 $c$，表示测试点编号。$c=0$ 表示该测试点为样例。

第二行包含一个正整数 $t$，表示测试数据组数。

对于每组测试数据：

- 第一行包含一个正整数 $n$，表示节点数量。
- 第二行 $n-1$ 个正整数 $f_2,\dots,f_n$，$f_i$ 表示 $i$ 节点的父亲节点编号。保证 $f_i<i$。
- 第三行 $n$ 个整数 $a_i$，表示初始水温。
## 输出格式

输出到标准输出。

对于每组测试数据：

- 如果可以将水温变为 $0$，输出一行一个字符串 `Huoyu`；
- 如果无法将水温变为 $0$，输出一行一个字符串 `Shuiniao`。
## 样例

### 样例输入 #1
```
0
5
5
1 1 2 3
6 5 2 2 1
5
1 1 2 2
6 5 1 2 1
5
1 1 2 2
4 -1 5 -2 -2
5
1 1 2 2
6 -4 8 -3 -3
5
1 1 2 2
-1 -1 -1 -4 -1
```
### 样例输出 #1
```
Shuiniao
Huoyu
Shuiniao
Shuiniao
Huoyu
```
## 提示

**【样例 1 解释】**

记 $A_u$ 表示在节点 $u$ 使用加热装置的操作，$B_u$ 表示从节点 $u$ 吹一阵风的操作，$(S)^k$ 表示将操作序列 $S$ 重复 $k$ 次。

- 对于第一、三、四组测试数据，可以证明，小 S 无法将所有水杯的水温都变为 $0$；
- 对于第二组测试数据，一种可能的操作序列为：$B_3(A_4)^2(B_4)^4B_5$；
- 对于第五组测试数据，一种可能的操作序列为：$(A_4)^3A_1$。

**【样例 2】**

见选手目录下的 `water/water2.in` 与 `water/water2.ans`。

这个样例满足测试点 $3$ 的约束条件。

**【样例 3】**

见选手目录下的 `water/water3.in` 与 `water/water3.ans`。

这个样例满足测试点 $7,8$ 的约束条件。

**【样例 4】**

见选手目录下的 `water/water4.in` 与 `water/water4.ans`。

这个样例满足测试点 $12$ 的约束条件。

**【样例 5】**

见选手目录下的 `water/water5.in` 与 `water/water5.ans`。

这个样例满足测试点 $13,14$ 的约束条件。

**【样例 6】**

见选手目录下的 `water/water6.in` 与 `water/water6.ans`。

这个样例满足测试点 $15\sim 17$ 的约束条件。

**【样例 7】**

见选手目录下的 `water/water7.in` 与 `water/water7.ans`。

这个样例满足测试点 $18\sim 21$ 的约束条件。


***

**【数据范围】**

记 $\sum n$ 为单个测试点内所有测试数据中 $n$ 的和。

对于全部的测试数据，保证：

- $1\leq t\leq 1\,000$；
- $2\leq n\leq 10^5$，$\sum n\le 10^6$；
- 对于任意 $2\le i\le n$，$1\le f_i<i$；
- 对于任意 $1\le i\le n$，$-10^{12}\leq a_i\leq10^{12}$。

| 测试点 | $n\leq$ | $\sum n\le $ | $\lvert a_i\rvert\leq$ | 特殊性质 |
| :----: | :-----: | :----------: | :--------------------: | :------: |
| $1$ | $5$ | $50$ | $5$ | 无 |
| $2$ | $5$ | $200$ | $5$ | 无 |
| $3$ | $5$ | $5\,000$ | $5$ | 无 |
| $4,5$ | $50$ | $500$ | $50$ | 无 |
| $6$ | $50$ | $500$ | $10^{8}$ | 无 |
| $7,8$ | $200$ | $2\,000$ | $200$ | 无 |
| $9$ | $200$ | $2\,000$ | $10^{8}$ | 无 |
| $10,11$ | $1\,000$ | $10^4$ | $1\,000$ | 无|
| $12$ | $1\,000$ | $10^4$ | $10^{8}$ | 无 |
| $13,14$ | $10^5$ | $3\times 10^5$ | $10^{12}$ | A |
| $15\sim 17$ | $10^5$ | $3\times 10^5$ | $10^{12}$ | B |
| $18\sim 21$ | $10^5$ | $3\times 10^5$ | $10^{12}$ | C |
| $22,23$ | $3\times 10^4$ | $10^5$ | $10^{8}$ | 无 |
| $24,25$ | $10^5$ | $10^6$ | $10^{12}$ | 无 |

- 特殊性质 A：对于任意 $2\le i\le n$，$f_i=i-1$；
- 特殊性质 B：对于任意 $1\le i\le n$，$a_i\le \left(\sum_{f_j=i}a_j\right)+5$，其中设 $f_1=0$；
- 特殊性质 C：树的深度不超过 $2$，其中深度指所有节点到根的边数中的最大值。

***

**【提示】**

本题输入输出量较大，请使用适当的 I/O 方式。


---

---
title: "『STA - R8』强制在线动态二维数点"
layout: "post"
diff: 省选/NOI-
pid: P11210
tag: ['线段树', '二分', '2024', '洛谷原创', 'O2优化', 'Ad-hoc', '洛谷比赛']
---
# 『STA - R8』强制在线动态二维数点
## 题目背景

> 数据结构界的最新成果！强制在线动态二维数点已经可以做到线性时间！

## 题目描述

要拿到图灵奖，你需要解决下面这道动态在线二维数点问题：

平面上有 $n$ 个点 $(x_i,y_i)$，**排列在 $\bm{y=x}$ 的直线下方（即，$\bm{y_i\le x_i}$ 成立）**。

我会进行 $q$ 次操作，操作有两种类型：

1. 修改操作 `U i x y`：令 $x_i:=x,y_i:=y$。（即，将 $x_i$ 和 $y_i$ 分别赋值为 $x$ 和 $y$。）
2. 询问操作 `Q l r`：给出一个**四个顶点分别是 $\bm{(l,l),(r,l),(l,r),(r,r)}$ 的矩形**，求出在给出的矩形内的点 $^\dagger$ $(x,y)$ 中最小的 $x-y$ 的值。**特别地，规定当矩形没有包含任何一个点时答案为 $\bm{0}$。**

两种操作会以某种方式进行加密，详细要求见下方【输入格式】一栏。

$^\dagger$：点 $(x,y)$ 在 $(l,l),(r,l),(l,r),(r,r)$ 所构成的矩形内，当且仅当 $l\le x\le r$ 且 $l\le y\le r$。
## 输入格式

第一行两个整数 $n$ 和 $q$。

随后 $n$ 行，每行两个整数 $x_i$ 和 $y_i$ 描述每个点的坐标。

接下来 $q$ 行，给出每个操作的类型和对应参数的加密值。解密后的真实的参数 $i,x,y,l,r$ 的值，**均要异或你上一次输出的答案**（第一次询问操作前不异或）。我会保证解密后 $1\le l\le r\le n$ 和 $1\le i\le n$，$1\le y\le x\le n$ 的约束存在。
## 输出格式

对每个询问操作，输出一行你的答案。
## 样例

### 样例输入 #1
```
5 6
4 1
4 1
4 2
4 1
5 2
Q 2 5
U 6 6 3
Q 3 7
Q 1 6
U 2 4 2
Q 2 3
```
### 样例输出 #1
```
2
2
0
0
```
## 提示

对于所有测试数据，$1\le n,q\le 5\times 10^5$，并且保证解密后的 $1\le l\le r\le n$ 且 $1\le i\le n$，$1\le y\le x\le n$。

**本题采用捆绑测试，并开启子任务依赖。**

- Subtask 0（5 points）：$n,q\le 5\times 10^3$。
- Subtask 1（20 points）：无修改操作。 
- Subtask 2（25 points）：满足特殊性质。
- Subtask 3（20 points）：$n,q\le 10^5$。
- Subtask 4（30 points）：无特殊限制。

特殊性质（数据随机）：操作类型、修改的位置、初始时和修改后的点的坐标和询问区间（参数 $(i,x,y),(l,r)$ 的值）在合法范围内独立地均匀随机生成。



---

---
title: "[COTS 2019] 疏散 Sklonište"
layout: "post"
diff: 省选/NOI-
pid: P11225
tag: ['2019', '网络流', '二分图', 'COCI（克罗地亚）']
---
# [COTS 2019] 疏散 Sklonište
## 题目背景


译自 [Izborne Pripreme 2019 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2019/) D2T2。$\texttt{4s,0.5G}$。
## 题目描述


给定 $N$ 个点 $M$ 条边的无向连通图，边有边权。有 $K$ 个关键点 $A_1,A_2,\cdots,A_K$，**容量**为 $S_1,S_2,\cdots,S_K$。

图中的居民要疏散。也就是说，你需要构造一个序列 $B_1,B_2,\cdots,B_N$，使得：

- $\forall 1\le i\le N$，$1\le B_i\le K$；
- 对于 $1\le i\le K$，定义 $\displaystyle \mathrm{cnt}_i=\sum_{1\le j\le N} [B_j=i]$，也就是 $i$ 在 $B$ 序列中出现的次数。则 $\mathrm{cnt}_i\le S_i$。

定义序列 $B$ 的**疏散时间**为 $\displaystyle \max_{1\le i\le N} \operatorname{dist}(i,A_{B_i})$，其中 $\operatorname{dist}(u,v)$ 指图中 $u,v$ 间最短路的长度。

求出疏散时间的最小值。保证 $\sum_i S_i\ge N$。

## 输入格式


第一行，三个正整数 $N,M,K$；

接下来 $M$ 行，每行三个正整数 $u,v,w$，描述一条无向边 $(u,v)$，边权为 $w$。保证 $u\neq v$。

接下来 $K$ 行，每行两个正整数描述 $A_i,S_i$。

保证 $\sum_i S_i\ge N$。
## 输出格式


输出一行一个数，表示答案。
## 样例

### 样例输入 #1
```
5 5 2
1 2 1
1 3 3
2 3 4
3 4 1
4 5 1
1 10
4 2
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
7 8 3
1 2 5
2 3 3
3 4 5
1 4 1
4 5 7
5 6 2
6 7 1
4 7 4
3 3
7 3
6 2
```
### 样例输出 #2
```
5
```
## 提示


对于 $100\%$ 的数据，保证：
- $1\le N\le 10^5$；
- $N-1\le M\le 3\times 10^5$；
- $1\le K\le 17$；
- 给定图连通，无自环；
- $1\le w,S_i\le 10^9$；
- $1\le u,v,A_i\le N$；
- $S_i$ 两两不同；
- $\sum_i S_i\ge N$。


| 子任务编号 | $N\le $ | $M\le $ | $K\le$    | 得分 |  
| :--: | :--: |:--: |  :--: | :--: | 
| $ 1 $    | $ 100 $ |   $ 500 $   |  $5$ | $30$ |
| $ 2 $    | $ 10^5 $ |  $ 3\times 10^5 $   |  $10 $ | $30$ |
| $ 3 $    | $ 10^5 $ | $ 3\times 10^5 $   |  $17$ |  $40$ |


---

---
title: "[KTSC 2024 R1] 警察与小偷"
layout: "post"
diff: 省选/NOI-
pid: P11237
tag: ['二分', '2024', '交互题', 'Special Judge', '树链剖分', 'KOI（韩国）']
---
# [KTSC 2024 R1] 警察与小偷
## 题目背景

**请勿使用 C++14 (GCC 9) 提交**。

你需要在程序开头加入如下代码：

```cpp
#include<vector>
#include<array>
std::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);
```
## 题目描述

**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T3 「[경찰과 도둑](https://assets.ioikorea.kr/ioitst/2024/1/police/police_statement.pdf)」**

KOI 村由 $N$ 座房子和连接这些房子的 $N-1$ 条双向道路组成。任意两座不同的房子都可以通过这些道路互相到达。也就是说，KOI 村的道路网络是一个树结构。

KOI 村的房子编号从 $0$ 到 $N-1$，道路编号从 $0$ 到 $N-2$。对于编号为 $i$ 的道路，它连接了编号为 $A[i]$ 和 $B[i]$ 的房子，长度为 $D[i]$ 米。

最近，KOI 村频繁发生盗窃事件，村民们非常困扰。为了应对这种情况，村里决定在某个房子里安排警察待命，以便在小偷出现时迅速抓捕。村民们想知道在不同情况下，警察需要多长时间才能抓住小偷。

你将会得到 $Q$ 个场景，每个场景编号从 $0$ 到 $Q-1$。每个场景如下：

- 在第 $j$ 个场景中，警察从编号为 $P[j]$ 的房子出发，最大速度为 $V1[j]$ 米/秒。
- 在第 $j$ 个场景中，小偷从编号为 $T[j]$ 的房子出发，最大速度为 $V2[j]$ 米/秒。
- 警察和小偷出发的房子不同，即 $P[j] \neq T[j]$。
- 房子的大小可以忽略不计，因此可以将房子视为一个点。道路的宽度也可以忽略不计，因此可以将道路视为一条线段。道路之间不相交。
- 警察和小偷可以在 KOI 村内自由移动，速度不超过各自的最大速度。可以选择不移动。
- 如果警察和小偷在同一个位置，警察就能抓住小偷。这个位置可以是房子，也可以是道路的中间。
- 在每个场景中，警察和小偷都知道对方的速度，并且随时知道对方的位置。
- 警察和小偷都会采用最优策略。警察会尽快抓住小偷，而小偷会尽量拖延被抓住的时间。可以证明，在最优策略下，小偷一定会在有限时间内被抓住。

你需要计算每个场景中，小偷被抓住所需的时间。

你需要实现以下函数：

```cpp
std::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);
```

- `A, B, D`：大小为 $N-1$ 的整数数组。对于每条编号为 $i$ 的道路，它连接了编号为 $A[i]$ 和 $B[i]$ 的房子，长度为 $D[i]$ 米。
- `P, V1, T, V2`：大小为 $Q$ 的整数数组。对于第 $j$ 个场景，警察从编号为 $P[j]$ 的房子出发，最大速度为 $V1[j]$ 米/秒，小偷从编号为 $T[j]$ 的房子出发，最大速度为 $V2[j]$ 米/秒。
- 该函数返回一个大小为 $Q$ 的数组 $C$，每个元素是一个大小为 $2$ 的数组。对于第 $j$ 个场景，小偷被抓住所需的时间（以秒为单位）表示为分数 $C[j][0] / C[j][1]$。
- $C[j][0] / C[j][1]$ 可以不是最简分数，但 $C[j][0]$ 和 $C[j][1]$ 必须是 $1$ 到 $10^{18}$ 之间的整数。可以证明，对于所有满足约束条件的输入，答案总能表示为这种形式的分数。

注意，提交的代码中不应包含任何输入输出操作。

## 输入格式

示例评测程序按以下格式读取输入：

- 第 $1$ 行：$N\,Q$
- 第 $2+i$ $(0 \leq i \leq N-2)$ 行：$A[i]\,B[i]\,D[i]$
- 第 $1+N+j$ $(0 \leq j \leq Q-1)$ 行：$P[j]\,V1[j]\,T[j]\,V2[j]$
## 输出格式

示例评测程序按以下格式读取输入：

- 第 $1$ 行：$N\,Q$
- 第 $2+i$ $(0 \leq i \leq N-2)$ 行：$A[i]\,B[i]\,D[i]$
- 第 $1+N+j$ $(0 \leq j \leq Q-1)$ 行：$P[j]\,V1[j]\,T[j]\,V2[j]$

假设 `police_thief` 返回的数组为 $C$。示例评测程序将输出：

- 第 $1+j$ $(0 \leq j \leq Q-1)$ 行：$C[j][0]\,C[j][1]$

## 样例

### 样例输入 #1
```
4 3
0 1 557912
0 2 517656
0 3 275807
3 265381 0 1000000
0 190435 2 12345
0 195025 3 67890
```
### 样例输出 #1
```
833719 265381
517656 190435
275807 195025
```
### 样例输入 #2
```
6 4
0 1 2
1 2 2
2 3 10
1 4 8
2 5 16
3 4 0 3
3 2 0 1
3 19 0 9
3 20 0 19
```
### 样例输出 #2
```
6 1
10 1
1 1
13 10
```
### 样例输入 #3
```
10 10
4 9 7
2 8 8
9 0 4
9 1 5
3 1 1
7 6 2
1 2 5
6 2 10
5 9 2
3 1 5 9
0 6 5 7
5 6 9 6
2 5 1 7
0 2 6 4
5 6 2 10
5 5 0 10
7 4 1 8
9 1 8 7
8 5 4 5
```
### 样例输出 #3
```
18 1
13 3
4 1
17 5
13 1
4 1
6 5
29 4
22 1
5 1
```
### 样例输入 #4
```
10 10
6 7 1
8 5 1
8 2 4
3 9 4
4 1 4
9 7 7
0 4 3
1 3 4
8 4 7
3 5 0 2
1 7 7 2
6 9 8 5
2 7 0 5
3 5 2 4
3 10 0 5
2 8 0 7
6 8 7 2
1 4 8 2
2 8 5 7
```
### 样例输出 #4
```
11 5
16 7
31 9
4 1
19 5
11 10
31 8
1 6
15 4
3 1
```
## 提示

对于所有输入数据，满足：

- $2 \leq N \leq 10^5$
- $1 \leq Q \leq 10^5$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$0 \leq A[i], B[i] \leq N-1$ 且 $A[i] \neq B[i]$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$1 \leq D[i] \leq 10^6$
- KOI 村是一棵树的结构
- 对于所有 $j$ $(0 \leq j \leq Q-1)$，$0 \leq P[j], T[j] \leq N-1$ 且 $P[j] \neq T[j]$
- 对于所有 $j$ $(0 \leq j \leq Q-1)$，$1 \leq V1[j], V2[j] \leq 10^6$

详细子任务附加限制及分值如下表所示。

| 子任务 | 分值 | 附加限制 |
| :-: | :-: | :-: |
| $1$ | $15$ | $N \leq 5000, Q \leq 5000$ |
| $2$ | $21$ | $N \leq 50000,Q \leq 50000$ |
| $3$ | $5$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$A[i]=i, B[i]=i+1$ |
| $4$ | $6$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$A[i]=0, B[i]=i+1$ |
| $5$ | $14$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$V1[j] \leq V2[j]$ |
| $6$ | $9$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$P[j]$ 和 $T[j]$ 之间的道路数量不超过 $10$ 条 |
| $7$ | $9$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$P[j]=0$ |
| $8$ | $10$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$T[j]=0$ |
| $9$ | $11$ | 无附加限制 |


---

---
title: "[COTS 2018] 逃遁 Bijeg"
layout: "post"
diff: 省选/NOI-
pid: P11264
tag: ['2018', '二分', 'Special Judge', '半平面交', 'COCI（克罗地亚）']
---
# [COTS 2018] 逃遁 Bijeg
## 题目背景


译自 [Izborne Pripreme 2018 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2018/) D2T2。$\texttt{10s,1G}$。

## 题目描述


考虑一个二维笛卡尔坐标系。

劫匪初始时在原点，此外有 $n$ 个警察分布在平面上。

他们的**速率**均为 $v$（一个正实数），且只会沿着一个特定的方向做**匀速直线**运动（每个人运动的方向可能不同）。

劫匪可以任意选定自己逃跑的方向，而警察会选择最优的方式追捕劫匪。当警察和劫匪的位置重合时，劫匪即被逮捕。

试判断：

- 劫匪是否可以成功逃跑，也就是，是否存在一个方向，使得劫匪不被逮捕。

如果无法逃跑，还需要求出劫匪被逮捕时，离原点的欧几里得距离的最大值。

数据保证这 $(n+1)$ 个人的位置两两不同。

## 输入格式


第一行，一个正整数 $n$。

接下来 $n$ 行，每行两个整数 $x,y$，描述警察的位置。


数据保证 $(n+1)$ 个人的位置两两不同。
## 输出格式


如果劫匪可以成功逃跑，输出 $-1$。

否则，输出一个实数，表示劫匪被逮捕时距离的最大值。

当且仅当你的答案与标准答案的绝对或相对误差不大于 $10^{-5}$ 时，认为你的答案正确。
## 样例

### 样例输入 #1
```
4
4 4
-4 4
-4 -4
4 -4
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
3
3 0
-3 1
-3 -1
```
### 样例输出 #2
```
9.617692030835672
```
### 样例输入 #3
```
2
1 1
0 1
```
### 样例输出 #3
```
-1
```
## 提示


#### 样例解释

样例 $1$ 解释如图所示。

![](https://cdn.luogu.com.cn/upload/image_hosting/fdrlttoq.png)

#### 子任务

对于 $100\%$ 的数据，保证 $1\le n\le 10^5$，$|x|,|y|\le 10^3$，所有人的位置均不同。


| 子任务编号 | $n\le $ |  $\vert x\vert ,\vert y\vert \le $ |  得分 |  
| :--: | :--: | :--: | :--: |  
| $ 1 $    | $ 100 $    |  $10$ | $ 20 $   |  
| $ 2 $    | $ 3\, 000 $   |  $100$ | $ 30 $   |  
| $ 3 $    | $ 10^5$ | $1\, 000$ |  $ 50 $   |  



---

---
title: "[COTS 2017] 盗道 Krimošten"
layout: "post"
diff: 省选/NOI-
pid: P11286
tag: ['2017', '二分', '树状数组', 'COCI（克罗地亚）']
---
# [COTS 2017] 盗道 Krimošten
## 题目背景

译自 [Izborne Pripreme 2017 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2017/) D1T2。$\texttt{4s,0.5G}$。

库纳（Kuna）是克罗地亚的货币单位。
## 题目描述


海岸线上有一排房子，从西到东标号 $1\sim n$。第 $i$ 座房子内有 $a_i$ 库纳。

有 $m$ 个窃贼要行窃。第 $i$ 个窃贼初始囊中有 $c_i$ 库纳，他将依次对编号为 $l_i,l_i+1,\cdots, r_i$ 的房子行窃。

盗亦有道，窃贼们践行盗之道。当窃贼对编号为 $j$ 的房子行窃时，令他囊中有 $k$ 库纳：

- 若 $k\lt a_j$，则窃贼将 $1$ 库纳收入囊中，即 $k\gets k+1$；
- 若 $k=a_j$，无事发生；
- 若 $k\gt a_j$，则窃贼拿出 $1$ 库纳赠给房主，即 $k\gets k-1$。

对于每个窃贼，求出他最后囊中会有多少库纳。

需要注意的是，**每个窃贼的行窃是独立的，不互相影响**。换句话说，可以认为一个窃贼行窃结束后，（在下一个窃贼行窃前）房子会恢复到初始状态。
## 输入格式


第一行，两个正整数 $n,m$;

第二行，$n$ 个非负整数 $a_1,a_2,\cdots,a_n$;

接下来 $m$ 行，每行三个整数 $l_i,r_i,c_i$。
## 输出格式

对于每个询问，输出一行一个整数表示答案。

## 样例

### 样例输入 #1
```
10 3
3 5 5 4 3 6 10 0 4 7
2 10 9
6 6 2
2 8 4
```
### 样例输出 #1
```
6
3
4
```
### 样例输入 #2
```
8 5
2 3 0 9 2 6 0 6
5 6 8
3 4 7
3 8 8
8 8 7
6 7 9
```
### 样例输出 #2
```
6
7
6
6
7
```
## 提示



对于 $100\%$ 的数据，保证：

- $1\le n\le 5\times 10^5$；
- $0\le a_i,c_i\le 10^6$；
- $1\le l_i\le r_i\le n $。


| 子任务编号 | $n\le $ |  $m\le $ |得分 |  
| :--: | :--: | :--: | :--: |  
| $ 1 $    | $ 10^3 $    |  $10^3$ |  $ 7 $   |  
| $ 2 $    | $ 5\times 10^4 $   |  $10^5$ |  $ 48 $   |  
| $ 3 $    | $ 5\times 10^5 $ | $5\times 10^5$ | $ 45 $   |  

再次提醒，**每个窃贼的行窃是独立的，不互相影响**。


---

---
title: "[NOISG 2022 Qualification] Dragonfly"
layout: "post"
diff: 省选/NOI-
pid: P11295
tag: ['2022', '树链剖分', '整体二分', 'NOISG（新加坡）']
---
# [NOISG 2022 Qualification] Dragonfly
## 题目背景

在植物园和碧山公园周围的池塘中，经常可以看到蜻蜓。在一个更密集的森林区域中，Benson 记录了 $n$ 个池塘，以及蜻蜓可以捕食的昆虫数量和种类。

在池塘 $i$，共有 $b_i$ 只昆虫，这些昆虫属于种类 $s_i$。

此外，还有 $n-1$ 条小径，每条小径连接两池塘 $u_j$ 和 $v_j$（双向）。

Benson 抓住了 $d$ 只蜻蜓，并计划依次释放到池塘 $1$。每只蜻蜓有一个目标池塘 $h_k \neq 1$，会沿着最短路径飞到目标池塘，并在经过的每个池塘中捕食昆虫（包括池塘 $1$）。

每次捕食会减少池塘中 $1$ 只昆虫（如果昆虫数量不为 $0$）。需要帮助 Benson 计算每只蜻蜓的飞行过程中捕食到的不同种类昆虫的数量。
## 题目描述

请确定每只蜻蜓的飞行过程中捕食到的不同种类昆虫的数量。
## 输入格式

- 第一行包含两个整数 $n$ 和 $d$，分别表示池塘数量和蜻蜓数量。
- 第二行包含 $n$ 个整数 $b_1, b_2, \dots, b_n$，表示每个池塘的昆虫数量。
- 第三行包含 $n$ 个整数 $s_1, s_2, \dots, s_n$，表示每个池塘昆虫的种类。
- 第四行包含 $d$ 个整数 $h_1, h_2, \dots, h_d$，表示每只蜻蜓的目标池塘。
- 接下来 $n-1$ 行，每行包含两个整数 $u_j$ 和 $v_j$，表示一条连接池塘 $u_j$ 和 $v_j$ 的小径。
## 输出格式

输出一行包含 $d$ 个整数，第 $k$ 个整数表示第 $k$ 只蜻蜓捕食到的不同种类昆虫数量。
## 样例

### 样例输入 #1
```
5 6
4 1 0 3 1
1 3 2 2 1
2 5 4 3 4 2
5 2
2 1
1 4
1 3
```
### 样例输出 #1
```
2 1 2 1 1 0
```
### 样例输入 #2
```
7 4
0 2 4 4 0 1 3
6 1 6 2 2 2 1
7 5 2 4
4 1
4 5
6 2
1 6
1 3
6 7
```
### 样例输出 #2
```
2 1 1 1
```
## 提示

【样例解释】

对于样例 $1$，第一只蜻蜓飞向池塘 $2$，捕食 $1$ 只种类 $1$ 的昆虫和 $1$ 只种类 $2$ 的昆虫。第二只蜻蜓飞向池塘 $5$，捕食种类 $1$ 的昆虫，总共捕食 $1$ 个种类。  

对于样例 $2$，每只蜻蜓飞行后捕食到的不同种类分别是 $2, 1, 1, 1$。

【数据范围】

- $2 \leq n \leq 2 \times 10^5$
- $1 \leq d \leq 2 \times 10^6$
- $1 \leq s_i \leq n$，$0 \leq b_i \leq d$，$1 \leq u_j, v_j < n$

| 子任务编号 | 分值 | 额外限制条件                              |
| :--------: | :--: | :---------------------------------------: |
| $1$        | $10$ | $n, d \leq 1000$                          |
| $2$        | $10$ | $b_i = d$                                 |
| $3$        | $12$ | $b_i \leq 10$                             |
| $4$        | $12$ | $u_j = j$, $v_j = j + 1$                  |
| $5$        | $37$ | $s_i = i$                                 |
| $6$        | $16$ | $d \leq 2 \times 10^5$                    |
| $7$        |  $3$ | 无额外限制                                |


---

---
title: "[COTS 2016] 删除 Brisanje"
layout: "post"
diff: 省选/NOI-
pid: P11305
tag: ['2016', '二分', '哈希 hashing', '后缀数组 SA', 'COCI（克罗地亚）']
---
# [COTS 2016] 删除 Brisanje
## 题目背景


译自 [Izborne Pripreme 2016 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2016/) D1T2。$\texttt{4s,0.5G}$。


为了卡掉理论复杂度较劣的解法，在 Subtask 0 添加了 Hack 数据（#35~#39，感谢 @Hoks 和 @N_z_），同时将时限改为 1.5s。欢迎对数据的加强。

## 题目描述


给定字符串 $s$。

定义 $s(l,r)$ 为 $s$ 第 $l\sim r$ 个字符组成的字符串。

定义 $t(l,r)$ 为 $s$ 删除第 $l\sim r$ 个字符后得到的字符串。

找到最长的区间 $[l,r]$，使得 $s(l,r)$ 在 $t(l,r)$ 中作为子串出现。

## 输入格式

一行一个字符串 $s$。

## 输出格式

输出一个整数，表示最长可能的区间长度。  

## 样例

### 样例输入 #1
```
abcxyzabc

```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
bbcdbcbbcbadadda
```
### 样例输出 #2
```
5
```
## 提示


#### 样例解释

不难注意到 $\texttt{bbcdbcb\underline{bcbad}adda} \to \texttt{bbcd\underline{bcbad}da}$。

#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le |s| \le 10^5$；
- $s$ 中只有小写字母。


| 子任务编号 | $\vert s\vert \in $ | 得分 |  
| :--: | :--: | :--: | 
| $ 1 $    | $ [1,400] $    |   $ 16 $   |  
| $ 2 $    | $ (400,5000] $   |  $ 24 $   |  
| $ 3 $    | $ (5000,10^5]$ | $ 60 $   |  




---

---
title: "[NOISG 2018 Finals] City Mapping【缺样例】"
layout: "post"
diff: 省选/NOI-
pid: P11597
tag: ['2018', '二分', '交互题', 'Special Judge', 'O2优化', '树链剖分', 'NOISG（新加坡）']
---
# [NOISG 2018 Finals] City Mapping【缺样例】
## 题目背景

译自 [NOISG 2018 Finals D. City Mapping](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/citymapping)。

----------------

当你在洛谷提交本题时，需要注意：

- 本题仅支持 C++ 系列语言。
- 你的代码中不应该包含头文件 `citymapping.h`。
- 你的代码中应当有如下两行函数声明：
	```cpp
	long long get_distance(int X, int Y);
	void find_roads(int N, int Q, int A[], int B[], int W[]);
	```
    
如遇评测问题，请联系搬题人。
## 题目描述

**这是一道交互题。**

Silvermill 市是一座有 $N$ 个路口和 $N-1$ 条道路的城市。其中道路的编号为 $0$ 到 $N-2$。

第 $i$ 条道路双向连接了 $(A_i,B_i)$ 两个路口，从任意方向通过这条道路都需要花费 $W_i$ 分钟。保证任意两个路口之间都能通过道路互相到达。

为了避免交通堵塞，Silvermill 市的**每个路口连接的道路不会超过 $3$ 条**。

你的任务是画出 Silvermill 市的地图，也就是找出所有 $N-1$ 条道路的 $(A_i,B_i,W_i)$。

为了达到这个目的，你可以询问市长至多 $Q$ 次从任意一个路口 $X$ 到任意一个路口 $Y$ 最少需要多少分钟。

### 实现细节

在本题中，**你不需要，也不应该实现主函数**。

你需要实现如下函数：

```cpp
void find_roads(int N, int Q, int A[], int B[], int W[])
```

该函数包含两个输入参数和三个输出参数，将在评测时被运行恰好一次。输入参数为 $N,Q$，分别表示路口的数量和最大询问次数；输出参数为 $A,B,W$，你需要确定城市中的 $N-1$ 条道路，按题意中的含义以数组 $A,B,W$ 的形式返回。返回道路的顺序可以是任意的，同一道路端点的顺序也可以是任意的。

注意数组的下标是从 $0$ 开始的。

你可以调用下面的函数来完成任务：

```cpp
long long get_distance(int X, int Y)
```

该函数将返回一个整数，表示从路口 $X$ 到路口 $Y$ 最少需要多少分钟。如果你调用此函数超过 $Q$ 次，或提供无效的路口编号作为参数，程序将立刻终止，你将得到 Wrong Answer 的评测状态。
## 输入格式

示例测试程序如下方式读入数据：

第一行三个整数 $N,Q,S$，分别表示路口的数量、最大询问次数和子任务编号。

之后是 $N-1$ 行，每行三个整数 $(A_i,B_i,W_i)$，描述一条道路。
## 输出格式

示例测试程序可能会产生的输出如下：

- `Wrong Input Format`，意味着对示例测试程序的输入格式有误。
- `Wrong Answer: Reported list of edges differ from actual.`，意味着你确定的道路与实际情况不符。
- `Wrong Answer: get_distance() arguments out of range.`，意味着你在询问时提供了无效的路口编号作为参数。
- `Wrong Answer: Too many calls to get_distance().`，意味着你超出了最大询问次数限制。
- 包含两行信息，分别是 `Score: s%` 和 `Correct: x out of y queries used.`，意味着你获得了该测试点 $s\%$ 的分数，最大询问次数为 $y$ 次，你使用了其中的 $x$ 次。
## 提示

### 调用示例

我们考虑如下的城市地图，展示一种可能的函数调用过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/m7bz8mwi.png)

假设此时最大询问次数 $Q=5\times 10^5$。

你的函数将这样被调用恰好一次：

```cpp
find_roads(5, 500000, A, B, W);
```

其中 $A,B,W$ 是定义在测试程序中的数组。

一种可能的交互过程如下：

- `get_distance(5, 4) = 10`：`get_distance` 函数返回从路口 $5$ 到达路口 $4$ 的最少分钟数。路线 $5\to 3\to 4$ 是最短的，需要 $10$ 分钟。
- `get_distance(2, 4) = 1`：`get_distance` 函数返回了从路口 $2$ 到达路口 $4$ 的最少分钟数。直接从 $2$ 走到 $4$ 是最短的，需要 $1$ 分钟。
- `get_distance(1, 3) = 15`：`get_distance` 函数返回了从路口 $1$ 到达路口 $3$ 的最少分钟数。路线 $1\to 4\to 3$ 是最短的，需要 $15$ 分钟。
- `get_distance(1, 2) = 9`：`get_distance` 函数返回了从路口 $1$ 到达路口 $2$ 的最少分钟数。路线 $1\to 4\to 2$ 是最短的，需要 $9$ 分钟。

此时，我们假设你的 `find_roads` 函数认为自己已经掌握了足够的信息，可以推导出正确的地图，所以将 $A,B,W$ 数组分别赋值为 $A=[3,4,4,5],B=[4,1,2,3],W=[7,8,1,3]$，然后终止。

这只是一种可能的答案，因为返回道路的顺序可以是任意的，同一道路端点的顺序也可以是任意的。

### 子任务

对于 $100\%$ 的数据，$2\le N\le1000$，$1\le A_i,B_i\le N$，$1\le W_i\le 10^9$。

| 子任务 | 得分 | $Q$ | 特殊性质及备注 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $9$ | $=5\times 10^5$ | $W_i=1$ |
| $2$ | $16$ | $=5\times 10^5$ | 无特殊限制 |
| $3$ | $13$ | $=12000$ | 每个路口最多连接两条道路，且 $W_i=1$ |
| $4$ | $19$ | $=12000$ | 每个路口最多连接两条道路 |
| $5$ | $43$ | $=25000$ | 无特殊限制，但有特殊的计分规则（请参阅**计分细则**） |

### 计分细则

子任务 $5$ 适用于以下的计分规则。你的得分依赖于你实现的函数询问的次数 $q$。

- 如果 $q>25000$，你将获得 $0$ 分。
- 如果 $12000<q\le 25000$，你将获得 $10-10\times \frac{q-12000}{13000}$ 分。
- 如果 $6500<q\le 12000$，你将获得 $40-30\times \frac{q-6500}{5500}$ 分。
- 如果 $q\le 6500$，你将获得 $43$ 分。

### 本地测试方式

我们在附件中下发了示例测试程序 `grader.cpp`，头文件 `citymapping.h`，你所需完成的代码的示例 `citymapping.cpp`，以及编译文件 `compile.sh`。

将这些文件置于同一文件夹下，使用 `compile.sh` 编译并运行生成的可执行文件，即可进行本地测试。

下发的示例测试程序与提交后使用的测试程序有所不同。

注意提交到洛谷上时有特殊的要求。


---

---
title: "[集训队互测 2015] 上帝之手"
layout: "post"
diff: 省选/NOI-
pid: P11733
tag: ['2015', '线段树', '二分', '集训队互测']
---
# [集训队互测 2015] 上帝之手
## 题目描述

上帝之手操纵着四维空间。假设四维空间中上帝关心的部分共 $n$ 天，定义第 $i$ 天结束时一个三维世界的混乱度为 $x_i$。由于一些自然的原因，第 $i$ 天该世界的混乱度会增加 $d_i$，但为了世界的平衡，每天该世界都有一个混乱度的上限值 $l_i$，即实际上 $x_i = \min\{x_{i-1}+d_i , l_i\}$。

上帝想对该四维空间作一系列测试，于是希望你帮忙建立一个模型。具体有以下三种测试：

1. 给定 $a, b$ 和 $k$，对于所有的 $c$ 满足 $a \leq c \leq b$，让世界以 $l_{c-1}$ 的初始混乱度从第 $c$ 天开始发展，把第 $b$ 天的混乱度 $x_b$ 写在一张纸上。你只需告诉上帝纸上第 $k$ 大的 $x_b$ 即可。保证 $1 \leq a \leq b \leq n$，且 $1 \leq k \leq b - a + 1$。
2. 给定 $a, b$ 和 $x_0$，对于所有的 $c$ 满足 $a \leq c \leq b$，让世界以 $x_0$ 的初始混乱度从第 $c$ 天开始发展，把第 $b$ 天的混乱度 $x_b$ 写在一张纸上。你只需告诉上帝纸上最大的 $x_b$ 即可。（注意：$x_0$ 可能大于 $l_{c-1}$）。保证 $1 \leq a \leq b \leq n$。
3. 给定 $a$ 和 $b$，对于所有的 $c$ 满足 $a \leq c \leq b$，让世界以 $l_{c-1}$ 的初始混乱度从第 $c$ 天开始发展，把第 $b$ 天的混乱度 $x_b$ 写在一张纸上。你只需告诉上帝纸上有多少种不同的 $x_b$ 即可。保证 $1 \leq a \leq b \leq n$。

当然，上帝还会修改某些位置的 $l_i$。你能成功帮助上帝完成测试吗？
## 输入格式

第一行包含两个正整数 $n$ 和 $m$，分别表示总天数和总操作（包含测试和修改）次数。

第二行为 $n$ 个非负整数 $d_1, \dots, d_n$。

第三行为 $n+1$ 个非负整数 $l_0, \dots, l_n$。含义见问题描述。

第四行起的 $m$ 行，每行第一个整数 $\mathrm{type}$ 表示操作种类。

若 $\mathrm{type}=0$，则后面跟有两个整数 $u$ 和 $x$，表示将 $l_u$ 改为 $x$。保证 $0 \leq u \leq n$。

若 $\mathrm{type}>0$，则 $\mathrm{type}$ 等于题目描述中对应的测试种类编号。$\mathrm{type} = 1$ 时后面跟有三个整数 $a, b$ 和 $k$；$\mathrm{type} = 2$ 时后面跟有三个整数 $a, b$ 和 $x_0$；$\mathrm{type} = 3$ 时后面跟有两个整数 $a$ 和 $b$。具体含义见问题描述。
## 输出格式

对于每个测试输出一行，包含一个整数表示测试结果。
## 样例

### 样例输入 #1
```
3 5
2 1 3
2 6 7 5
1 1 2 2
3 1 3
0 3 15
3 1 3
2 1 3 2
```
### 样例输出 #1
```
5
1
2
8
```
## 提示

- 对于前 $10\%$ 的数据，$n, m \leq 100$；
- 对于前 $20\%$ 的数据，$n, m \leq 5000$；
- 对于另 $10\%$ 的数据，$\mathrm{type} \leq 1$；
- 对于另 $20\%$ 的数据，$\mathrm{type} \leq 2$；
- 对于另 $15\%$ 的数据，$\mathrm{type} = 0$ 或 $3$；
- 对于 $100\%$ 的数据，$n \leq 10^5$，$m \leq 2 \times 10^5$，$0 \leq d_i \leq 10^4$，$0 \leq l_i \leq 10^9$。第二类测试操作中 $0 \leq x_0 \leq 10^9$，修改操作中 $0 \leq x \leq 10^9$。


---

---
title: "[USACO25FEB] Min Max Subarrays P"
layout: "post"
diff: 省选/NOI-
pid: P11845
tag: ['二分', 'USACO', '2025', '分类讨论', '单调栈']
---
# [USACO25FEB] Min Max Subarrays P
## 题目描述

**注意：本题的时间限制为 3 秒，通常限制的 1.5 倍。**

给定一个长为 $N$ 的整数数组 $a_1,a_2,\dots,a_N$（$2\le N \le 10^6$，$1\le a_i\le N$)。输出所有 $N(N+1)/2$ 个 $a$ 的连续子数组的以下子问题的答案之和。

给定一个非空整数列表，交替执行以下操作（从第一个操作开始）直到列表大小恰好为一。

1. 将列表内的两个相邻整数替换为它们的较小值。
1. 将列表内的两个相邻整数替换为它们的较大值。

求最终余下的整数的最大可能值。

例如，

$[4, 10, 3] \to [4, 3] \to [4]$

$[3, 4, 10] \to [3, 10] \to [10]$

在第一个数组中，$(10, 3)$ 被替换为 $\min(10, 3)=3$，随后 $(4, 3)$ 被替换为 $\max(4, 3)=4$。

## 输入格式

输入的第一行包含 $N$。

第二行包含 $a_1,a_2,\dots,a_N$。
## 输出格式

输出所有连续子数组的子问题的答案之和。

## 样例

### 样例输入 #1
```
2
2 1
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
3
3 1 3
```
### 样例输出 #2
```
12
```
### 样例输入 #3
```
4
2 4 1 3
```
### 样例输出 #3
```
22
```
## 提示

样例 1 解释：

对于 $[2]$ 答案为 $2$，对于 $[1]$ 答案为 $1$，对于 $[2, 1]$ 答案为 $1$。

因此，我们的输出应当为 $2+1+1 = 4$。

样例 3 解释：

考虑子数组 $[2, 4, 1, 3]$。


1. 在 $(1, 3)$ 上应用第一次操作，我们的新数组是 $[2, 4, 1]$。
1. 在 $(4, 1)$ 上应用第二次操作，我们的新数组是 $[2, 4]$。
1. 在 $(2, 4)$ 上应用第三次操作，我们最终的数是 $2$。

可以证明 $2$ 是最终的数的最大可能值。

- 测试点 $4\sim 5$：$N\le 100$。
- 测试点 $6\sim 7$：$N\le 5000$。
- 测试点 $8\sim 9$：$\max(a)\le 10$。
- 测试点 $10\sim 13$：没有额外限制。


---

---
title: "[USTCPC 2025] 送温暖"
layout: "post"
diff: 省选/NOI-
pid: P12038
tag: ['二分', '2025', '背包 DP', '双指针 two-pointer', '折半搜索 meet in the middle', '高校校赛']
---
# [USTCPC 2025] 送温暖
## 题目描述

克露丝卡尔酱听说大家都是经验丰富的信息竞赛老手，轻松暴力踩标算。为了让大家都体验一下暴力踩标算的乐趣，所以克露丝卡尔酱准备了一道简单的送温暖题：

给定一个 $n$ 个点的树，点 $i$ 的点权为 $a_i$，你需要从中选出一个连通块，使得它们的点权和模 $M$ 的余数最大。克露丝卡尔酱想知道这个点权和模 $M$ 的余数最大是多少。
## 输入格式

第一行两个正整数 $n$ $(1\leqslant n \leqslant 33)$ 和 $M$ $(2\leqslant M \leqslant 10^9)$。

为了方便输入，我们输入时假定以 $1$ 为根，但是请注意这是一棵无根树。

第二行有 $n - 1$ 个整数，第 $i$ 个整数表示第 $i + 1$ 个点的父节点 $f_{i + 1}$ $(1\leqslant f_{i+1} < i+1)$。

第三行有 $n$ 个整数，$a_1, \cdots, a_n$ $(0 \leqslant a_i < M)$ 表示每个点的点权。
## 输出格式

共一个整数表示答案。
## 样例

### 样例输入 #1
```
6 10
1 2 3 4 5
7 7 7 7 7 7
```
### 样例输出 #1
```
8
```
## 提示

这棵树是一条链 `1 - 2 - 3 - 4 - 5 - 6`。最优解为选择一条长度为 4 的链（例如 `1 - 2 - 3 - 4` 或者 `2 - 3 - 4 - 5` 等等），此时答案为 $4 \times 7 \equiv 8\pmod {10}$。


---

---
title: "[集训队互测 2024] 长野原龙势流星群"
layout: "post"
diff: 省选/NOI-
pid: P12479
tag: ['二分', '平衡树', '集训队互测', '2024', 'Special Judge', '树形 DP', '凸包']
---
# [集训队互测 2024] 长野原龙势流星群
## 题目描述

Naganohara Yoimiya 给了你一棵 $n$ 个节点的有根树，$1$ 号节点是根节点，每个点有点权 $w_i$。

你需要对每个点 $u$ 找到一个以 $u$ 为根的非空连通块，并最大化这个连通块内所有点的点权的平均值。

对每个点 $u$ 输出这个最大的平均值。
## 输入格式

第一行一个正整数 $n$。

接下来一行 $n-1$ 个正整数 $p_2,p_3,\cdots,p_n$，$p_i$ 表示 $i$ 的父节点的编号，保证 $p_i< i$。

接下来一行 $n$ 个正整数 $w_1,w_2,\cdots,w_n$。
## 输出格式

输出 $n$ 行，第 $i$ 行输出一个实数表示以节点 $i$ 为根的连通块内点权平均值的最大值。

如果你的答案和标准答案的相对误差或绝对误差不超过 $10^{-6}$ 则视为正确。
## 样例

### 样例输入 #1
```
6
1 2 2 1 4
3 1 5 6 6 7
```
### 样例输出 #1
```
4.6666666667
4.7500000000
5.0000000000
6.5000000000
6.0000000000
7.0000000000
```
## 提示

### 测试点约束

对于所有数据，$1\le n\le 2\times 10^5,1\le w_i\le 10^9$。

- Subtask 1（$10$ 分）：$1\le n\le 2000$。
- Subtask 2（$10$ 分）：$p_i=\lfloor i/2\rfloor$。
- Subtask 3（$40$ 分）：$1\le n\le 50000$。
- Subtask 4（$40$ 分）：无特殊限制。


---

---
title: "[XJTUPC 2025] Primal Core Optimization: Attribute Balance"
layout: "post"
diff: 省选/NOI-
pid: P12532
tag: ['二分', '2025', 'O2优化', '差分', '高校校赛']
---
# [XJTUPC 2025] Primal Core Optimization: Attribute Balance
## 题目描述

你正在玩一款被称为「韵律原罪」的游戏。在这个游戏里，你需要操纵你的搭档们，在「世界」中探索。

在游戏中，每一个搭档都有三种属性：$\mathrm{Stop}$ (S)，$\mathrm{Flag}$ (F) 和 $\mathrm{Ever}$ (E)。当所有搭档的属性完全一致时，她们就能成功融合。

现在你想要把所有搭档全部融合，换句话说就是让每一对搭档的属性全部相等。为了达成这一目的，你不得不对她们的属性进行修改。一次修改分为以下步骤：

- 你任选一位搭档作为修改的目标（你只能选一位搭档）；
- 你任选她的若干个属性；
- 将她的所选属性的数值全部增加 $1$ 或全部减少 $1$（必须同时执行同一种操作，即全部加或全部减）。

由于你的魔力不强，所以每次修改都需要花费 $1$ 源石。现在你想知道，你至少需要花费多少源石，才能达到你的目标。
## 输入格式

第一行，一个整数 $N$ ($1\le N\le 10^5$) 表示你拥有的搭档个数。

接下来 $N$ 行，每行三个整数 $S_i$, $F_i$ 和 $E_i$ ($1\le S_i, F_i, E_i \le 10^5$)，用一个空格分隔，表示第 $i$ 个搭档的三个属性的值。
## 输出格式

仅一个整数表示答案。
## 样例

### 样例输入 #1
```
3
2 2 2
2 2 2
1 2 3
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
3
2 3 1
3 5 3
3 2 1
```
### 样例输出 #2
```
4
```
### 样例输入 #3
```
1
201 502 10
```
### 样例输出 #3
```
0
```
### 样例输入 #4
```
4
1 2 3
1 2 3
4 5 6
4 5 6

```
### 样例输出 #4
```
6
```
## 提示

对于第一组样例，存在以下操作方式，使得总修改次数是 $2$ 次：

- 选择搭档 $3$ 和她的第一个属性，将她的属性修改为 $2$, $2$, $3$；
- 选择搭档 $3$ 和她的第三个属性，将她的属性修改为 $2$, $2$, $2$。

同时可以证明，不能通过少于 $2$ 次操作达成目标。所以，你应该输出 $2$。

对于第二组样例，存在以下操作方式，使得总修改次数是 $4$ 次：

- 选择搭档 $1$ 和她的第一、第三属性，将她的属性修改为 $3$, $3$, $2$；
- 选择搭档 $2$ 和她的第二、第三属性，将她的属性修改为 $3$, $4$, $2$；
- 选择搭档 $2$ 和她的第二个属性，将她的属性修改为 $3$, $3$, $2$；
- 选择搭档 $3$ 和她的第二、第三属性，将她的属性修改为 $3$, $3$, $2$。

同时可以证明，不能通过少于 $4$ 次操作达成目标。所以，你应该输出 $4$。

对于第三组样例，因为只有一位搭档，所以不需要进行操作。所以，你应该输出 $0$。



---

---
title: "[NERC 2022] Dominoes"
layout: "post"
diff: 省选/NOI-
pid: P12793
tag: ['2022', '二分图', 'ICPC', 'NERC/NEERC']
---
# [NERC 2022] Dominoes
## 题目描述

Dora likes to play with dominoes. She takes $n \times m$ table, marks some cells as occupied, and then tries to fill all unoccupied cells with $2 \times 1$ dominoes.

![](https://cdn.luogu.com.cn/upload/image_hosting/izci2rsk.png)

Her little brother Dani loves to play pranks on his older sister. So when she is away, he marks two more unoccupied cells as occupied. He wants to do it in such a way that it will be impossible to fill all unoccupied cells with dominoes.

Help Dani to count the number of ways he can select these two cells. Since Dani can only count to one million, if this number of ways is $x$, output $\min(x, 10^6)$.
## 输入格式

The first line contains integers $n$ and $m$ ($1\le n, m\le 1000$). Next $n$ lines contain $m$ characters each --- the initial state of the table. Character $\tt{\#}$ corresponds to an occupied cell, and character $\tt{.}$ corresponds to an unoccupied cell. It is guaranteed that there are at least two unoccupied cells, and that it is possible to fill all unoccupied cells with dominoes.
## 输出格式

Let $x$ be the number of ways Dani can mark two cells in such a way that it will be impossible to fill all unoccupied cells with dominoes. 

Print one integer $\min(x, 10^6)$.
## 样例

### 样例输入 #1
```
3 6
...#..
......
#...##
```
### 样例输出 #1
```
52
```
### 样例输入 #2
```
2 2
..
..
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
2 2
#.
#.
```
### 样例输出 #3
```
0
```


---

---
title: "[GCJ 2022 #2] Saving the Jelly"
layout: "post"
diff: 省选/NOI-
pid: P12995
tag: ['2022', '网络流', 'Special Judge', '二分图', 'Google Code Jam']
---
# [GCJ 2022 #2] Saving the Jelly
## 题目描述

Mr. Jolly teaches football (or soccer, for US speakers) to $\mathbf{N}$ children numbered from 1 to $\mathbf{N}$. He has taken to leaving sweets on the field where the games take place, one for each child. After the game is finished, each child can grab and eat one sweet as their reward.

The children are tired after games, so each child wants to grab the sweet closest to them (using Euclidean distance). This could lead to fights - if the same sweet is closest to two or more children. To avoid that, after the game all the children stop where they are, and Mr. Jolly calls out their names, one by one. When a child's name is called, they grab the closest sweet to them (out of the ones that weren't already grabbed, of course). In the case where two or more sweets are tied for the smallest distance, Mr. Jolly can decide which one the child grabs.

![](https://cdn.luogu.com.cn/upload/image_hosting/h3px6piy.png)

This has worked very well for Mr. Jolly for a while now, but today disaster struck! While laying out the sweets, Mr. Jolly accidentally dropped his blueberry jelly that he planned to eat after all the children go home. So now there are $\mathbf{N}$ children on the field, and $\mathbf{N}+1$ sweets. The sweets are numbered from 1 to $\mathbf{N}+1$, with sweet 1 being Mr. Jolly's blueberry jelly. Is there a way for Mr. Jolly to save his blueberry jelly by calling the children's names in such an order that the blueberry jelly is the one sweet left over?
## 输入格式

The first line of the input gives the number of test cases, $\mathbf{T}$. $\mathbf{T}$ test cases follow. Each test begins with a line containing a single integer, $\mathbf{N}$, the number of children on the field. The next $\mathbf{N}$ lines describe the positions of the children. Each of these lines contains two integers, $\mathbf{X}_{\mathbf{i}}$ and $\mathbf{Y}_{\mathbf{i}}$, representing the position of the $i$-th child after the game ends. Then there are $\mathbf{N}+1$ more lines that describe the positions of sweets after the game, where the first of the sweets is Mr. Jolly's blueberry jelly. Each of these lines contains two integers, $\mathbf{X}_{\mathbf{j}}$ and $\mathbf{Y}_{\mathbf{j}}$, representing the position of the $j$-th sweet.

## 输出格式

For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no way Mr. Jolly can choose the children (and break ties for the closest sweet) to leave his blueberry jelly uneaten. Otherwise, if Mr. Jolly can save his blueberry jelly, $y$ is POSSIBLE. If Mr. Jolly can save his jelly, output $\mathbf{N}$ additional lines representing the order the children will go and which jellies they will pick. The $i$-th line should contain two integers $A_{i}$ and $B_{i}$ representing that child $A_{i}$ will go next and will pick sweet $B_{i}$. The sweet $B_{i}$ must be the closest (or tied for the closest) sweet to child $A_{i}$ when they go to pick their sweet.
## 样例

### 样例输入 #1
```
4
2
-3 0
-1 0
3 0
-2 -1
-2 1
1
0 0
1 1
2 2
3
10 0
-10 0
0 0
0 5
-1 0
5 0
0 -5
2
3 4
3 4
5 7
3 4
5 7
```
### 样例输出 #1
```
Case #1: POSSIBLE
2 2
1 3
Case #2: IMPOSSIBLE
Case #3: POSSIBLE
3 2
2 4
1 3
Case #4: POSSIBLE
1 2
2 3
```
## 提示

**Sample Explanation**

Sample Case #1 is illustrated in the image above. Notice that each child is equally close to each of the two non-blueberry-jelly sweets. In our solution, Mr. Jolly assigns the second sweet to the second child and the third sweet to the first child, successfully leaving the first sweet (the blueberry jelly) for himself.

In Sample Case #2, the sole child is closer to the blueberry jelly than to the other sweet, so Mr. Jolly cannot prevent his precious blueberry jelly from being eaten.

In Sample Case #3, we present one of many solutions; it is actually possible to call the children in any order.

In Sample Case #4, note that children might share the same position, sweets might share the same position, and children and sweets might share the same position.

**Limits**

- $1 \leq \mathbf{T} \leq 100$.
- $-10^{9} \leq \mathbf{X}_{\mathbf{i}} \leq 10^{9}$, for all $i$.
- $-10^{9} \leq \mathbf{Y}_{\mathbf{i}} \leq 10^{9}$, for all $i$.
- $-10^{9} \leq \mathbf{X}_{\mathbf{j}} \leq 10^{9}$, for all $j$.
- $-10^{9} \leq \mathbf{Y}_{\mathbf{j}} \leq 10^{9}$, for all $j$.

**Test Set 1 (10 Pts, Visible Verdict)**

- Time limit: 10 seconds.
- $1 \leq \mathbf{N} \leq 10$.

**Test Set 2 (18 Pts, Hidden Verdict)**

- Time limit: 45 seconds.
- $1 \leq \mathbf{N} \leq 1000$.


---

---
title: "[GCJ 2022 Finals] Slide Parade"
layout: "post"
diff: 省选/NOI-
pid: P13003
tag: ['2022', '网络流', 'Special Judge', '欧拉回路', '二分图', 'Google Code Jam']
---
# [GCJ 2022 Finals] Slide Parade
## 题目描述

Gooli is a huge company that owns $\mathbf{B}$ buildings in a hilly area, numbered 1 through $\mathbf{B}$. Six years ago, Gooli built slides that allowed employees to go from one building to another. Each slide allows anyone to go from the slide's origin building to the slide's destination building, but not the other way around. Gooli's CEO is very proud of their slides and wants to organize a parade through the slides. She has tasked Melek, Gooli's Head of Transportation and a problem-solving enthusiast, with designing the parade's route.

![](https://cdn.luogu.com.cn/upload/image_hosting/njzcunb7.png)

She has some requirements for the parade route in mind:

* It must start and end at building 1, where her office is located.
* It must visit each building the same number of times. Being in building 1 at the start of the route does not count as a visit.
* It must use each slide at least once.
* It must have at most $10^6$ steps.

Given the layout of buildings and slides, help Melek find a route that satisfies all of the CEO's requirements, if one exists.
## 输入格式

The first line of the input gives the number of test cases, $\mathbf{T}$. $\mathbf{T}$ test cases follow. Each test case starts with a line containing two integers $\mathbf{B}$ and $\mathbf{S}$: the number of buildings and slides, respectively. Then, $\mathbf{S}$ lines follow. The $i$-th of these lines contains two integers $\mathbf{U}_i$ and $\mathbf{V}_i$, indicating that the $i$-th slide goes from building $\mathbf{U}_i$ to building $\mathbf{V}_i$.

## 输出格式

For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1). If there is no route that fulfills all the requirements, $y$ must be `IMPOSSIBLE`. If there is, $y$ must be an integer between $\mathbf{S} + 1$ and $10^6 + 1$, inclusive, representing the length of one such route you want to exhibit. In that case, output another line containing $y$ integers $z_1$ $z_2$ $\dots$ $z_y$, where $z_j$ is the $j$-th building in your proposed route. Notice that $z_1 = z_y = 1$ and that each building must appear the same number of times among the $z_j$, except for building 1, which appears exactly one extra time.
## 样例

### 样例输入 #1
```
5
2 2
2 1
1 2
3 4
2 3
1 2
3 2
1 3
3 6
1 2
1 3
2 1
2 3
3 1
3 2
3 4
1 2
2 1
1 3
3 1
4 6
1 2
1 4
2 3
3 2
3 4
4 1
```
### 样例输出 #1
```
Case #1: 7
1 2 1 2 1 2 1
Case #2: IMPOSSIBLE
Case #3: 7
1 2 3 1 3 2 1
Case #4: IMPOSSIBLE
Case #5: 9
1 4 1 2 3 2 3 4 1
```
## 提示

**Sample Explanation**

In Sample Case #1, another acceptable parade route is one that goes from building 1 to building 2 and then back for a total of 2 steps.

![](https://cdn.luogu.com.cn/upload/image_hosting/udzlxptm.png)

In Sample Case #2, there are no slides leading to building 1, so no valid parade can exist.

![](https://cdn.luogu.com.cn/upload/image_hosting/pp27u0fj.png)

In Sample Case #3, the parade route the sample output exhibits goes through each building twice.

![](https://cdn.luogu.com.cn/upload/image_hosting/e7pjon34.png)

Sample Case #4 is pictured below.

![](https://cdn.luogu.com.cn/upload/image_hosting/ff4gi295.png)

Sample Case #5 is the one illustrated in the problem statement. In the parade route in the sample output, the slides from 2 to 3 and from 4 to 1 are used twice, but the rest of the slides are used only once each.

**Limits**

- $1 \leq \mathbf{T} \leq 100$.
- $1 \leq \mathbf{U}_i \leq \mathbf{B}$, for all $i$.
- $1 \leq \mathbf{V}_i \leq \mathbf{B}$, for all $i$.
- $\mathbf{U}_i \neq \mathbf{V}_i$, for all $i$.
- $(\mathbf{U}_i, \mathbf{V}_i) \neq (\mathbf{U}_j, \mathbf{V}_j)$, for all $i \neq j$.

**Test Set 1 (11 Pts, Visible Verdict)**

- Time limit: 10 seconds.
- $2 \leq \mathbf{B} \leq 10$.
- $2 \leq \mathbf{S} \leq 10$.

**Test Set 2 (24 Pts, Hidden Verdict)**

- Time limit: 20 seconds.
- $2 \leq \mathbf{B} \leq 200$.
- $2 \leq \mathbf{S} \leq 5000$.



---

---
title: "[GCJ 2021 #2] Retiling"
layout: "post"
diff: 省选/NOI-
pid: P13038
tag: ['2021', '二分图', 'Google Code Jam']
---
# [GCJ 2021 #2] Retiling
## 题目描述

Cody-Jamal's latest artistic installment is a tiled kitchen floor that can be retiled to different patterns. The floor consists of a matrix of $\mathbf{R}$ rows and $\mathbf{C}$ columns of square tiles. Each tile is reversible, one side is magenta and the other one is green.

To retile the kitchen, there are two allowed operations:

* flip a tile, changing its visible color from magenta to green, or vice versa, and
* swap two adjacent tiles (horizontally or vertically, but not diagonally), without flipping either.

Viewing Cody-Jamal's artistic floor is free, but interacting with it is not. Performing a single flip operation costs $\mathbf{F}$ coins, and performing a single swap operation costs $\mathbf{S}$ coins.

You can see the current state of the floor and want to turn it into a particular pattern. What is the minimum amount of coins you need to spend to achieve your goal?
## 输入格式

The first line of the input gives the number of test cases, $\mathbf{T}$. $\mathbf{T}$ test cases follow. The first line of a test case contains 4 integers: $\mathbf{R}$, $\mathbf{C}$, $\mathbf{F}$ and $\mathbf{S}$, the number of rows and columns of the floor, the cost in coins of flipping and the cost in coins of swapping, respectively. Then, $2 \cdot \mathbf{R}$ lines follow. The first $\mathbf{R}$ lines contain $\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines represents the current state of the tile in the $i$-th row and $j$-th column. The character is $\mathsf{M}$ if the currently visible side is magenta and $\mathsf{G}$ otherwise. The last $\mathbf{R}$ lines also contain $\mathbf{C}$ characters each. The $j$-th character of the $i$-th of these lines represents the color you want for the tile in the $i$-th row and $j$-th column, using the same character code as for the current state.

## 输出格式

For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the minimum amount of coins you need to spend to perform operations that allow you to change the tile colors from their current state to your intended one.
## 样例

### 样例输入 #1
```
2
2 4 1 1
MGMG
MMMG
GMGM
MMMM
3 3 1 1
MGG
GMG
MMM
MMM
MGM
MMG
```
### 样例输出 #1
```
Case #1: 3
Case #2: 4
```
### 样例输入 #2
```
1
1 5 1000 1
MGGGG
GGGMM
```
### 样例输出 #2
```
Case #1: 1003
```
## 提示

**Sample Explanation**

In Sample Case #1, there are 5 tiles that have a different color between the current and the desired states of the floor. Since each operation can change at most 2 tiles, at least 3 operations, costing 3 coins, are needed. One way to do it with exactly 3 coins is:

1. Swap the leftmost two tiles in the top row.
2. Swap the rightmost two tiles in the top row.
3. Flip the bottom right corner tile.

The picture below illustrates the states the floor goes through. The highlighted tile or tiles in each state are the ones being changed by the operation.

![](https://cdn.luogu.com.cn/upload/image_hosting/lnckx68s.png)

In Sample Case #2, there are 6 tiles that need changing. However, since only swaps can change two tiles at a time, solving it with 3 operations would require all of them to be swaps. There is no way to involve all 6 tiles in a single swap each, so we need at least 4 operations. One way to use exactly 4 operations is:

1. Swap the topmost two tiles in the middle column.
2. Flip the top right corner tile.
3. Swap the bottommost two tiles in the rightmost column.
4. Flip the middle tile of the leftmost column.

The picture below illustrates the states the floor goes through.

![](https://cdn.luogu.com.cn/upload/image_hosting/yholjw9b.png)

Sample Test Set 2 fits the limits of Test Set 2. It will not be run against your submitted solutions.

In the Sample Case for Test Set 2, flips are so expensive that we want to avoid them at all costs. We need at least one since our desired floor state has more magenta tiles than the current one, and swaps do not change that amount. We can do it optimally with just one flip like this:

1. Swap the leftmost two tiles.
2. Flip the rightmost tile.
3. Swap the second and third tiles from the left.
4. Swap the third and fourth tiles from the left.

The picture below illustrates all the states the floor goes through.


![](https://cdn.luogu.com.cn/upload/image_hosting/7c22w7hy.png)

**Limits**

- $1 \leq \mathbf{T} \leq 100$.
- $1 \leq \mathbf{R} \leq 10$.
- $1 \leq \mathbf{C} \leq 10$.

**Test Set 1 (11 Pts, Visible Verdict)**

- $\mathbf{F}=1$.
- $\mathbf{S}=1$.

**Test Set 2 (23 Pts, Hidden Verdict)**

- $1 \leq \mathbf{F} \leq 10^{6}$.
- $1 \leq \mathbf{S} \leq 10^{6}$.


---

---
title: "[GCJ 2020 Qualification] Indicium"
layout: "post"
diff: 省选/NOI-
pid: P13052
tag: ['2020', '网络流', 'Special Judge', '二分图', 'Google Code Jam']
---
# [GCJ 2020 Qualification] Indicium
## 题目描述

Indicium means "trace" in Latin. In this problem we work with Latin squares and matrix traces.

A Latin square is an $\mathbf{N}$-by-$\mathbf{N}$ square matrix in which each cell contains one of $\mathbf{N}$ different values, such that no value is repeated within a row or a column. In this problem, we will deal only with "natural Latin squares" in which the $\mathbf{N}$ values are the integers between 1 and $\mathbf{N}$.

The trace of a square matrix is the sum of the values on the main diagonal (which runs from the upper left to the lower right).

Given values $\mathbf{N}$ and $\mathbf{K}$, produce any $\mathbf{N}$-by-$\mathbf{N}$ "natural Latin square" with trace $\mathbf{K}$, or say it is impossible. For example, here are two possible answers for $\mathbf{N}=3, \mathbf{K}=6$. In each case, the values that contribute to the trace are underlined.

$\begin{array}{llll}\underline{2} & 1 & 3 & \underline{3} \\3 & \underline{2} & 1 & 1 \\1 & 3 & \underline{2} & 2\end{array} \begin{array}{lll}1 & 2 \\ \underline{2} & 3 \\3 & \underline{1}\end{array}$

## 输入格式

The first line of the input gives the number of test cases, $\mathbf{T}$. $\mathbf{T}$ test cases follow. Each consists of one line containing two integers $\mathbf{N}$ and $\mathbf{K}$ : the desired size of the matrix and the desired trace.


## 输出格式

For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is IMPOSSIBLE if there is no answer for the given parameters or POSSIBLE otherwise. In the latter case, output $\mathbf{N}$ more lines of $\mathbf{N}$ integers each, representing a valid "natural Latin square" with a trace of $\mathbf{K}$, as described above.
## 样例

### 样例输入 #1
```
2
3 6
2 3
```
### 样例输出 #1
```
Case #1: POSSIBLE
2 1 3
3 2 1
1 3 2
Case #2: IMPOSSIBLE
```
## 提示

**Sample Explanation**

Sample Case #1 is the one described in the problem statement.

Sample Case #2 has no answer. The only possible 2-by-2 "natural Latin squares" are as follows:

```
1 2 2 1
2 1 1 2
```

These have traces of 2 and 4, respectively. There is no way to get a trace of 3.

**Limits**

- $\mathrm{N} \leqslant \mathrm{K} \leqslant \mathrm{N}^{2}$.

**Test set 1 (7 Pts, Visible Verdict)**

- $\mathrm{T}=44$.
- $2 \leqslant \mathrm{N} \leqslant 5$.

**Test set 2 (25 Pts, Hidden Verdict)**

- $1 \leqslant \mathrm{T} \leqslant 100$.
- $2 \leqslant \mathrm{N} \leqslant 50$.


---

---
title: "[GCJ 2020 Finals] Replace All"
layout: "post"
diff: 省选/NOI-
pid: P13074
tag: ['2020', '网络流', '二分图', 'Google Code Jam']
---
# [GCJ 2020 Finals] Replace All
## 题目描述

Banana Rocks Inc is coming up with a revolutionary technology to perform the common edit operation "replace all". Their implementation replaces every occurrence of a character within a given text with another character. (If the character does not appear in the text, then the operation occurs but has no effect.)

For example, if the starting text is `CODEJAMWORLDFINALS` and an operation is performed to replace A with o, the new text would be `CODEJOMWORLDFINOLS`. If another operation is performed on that result to replace o with y, the final text would be `CYDEJYMWYRLDFINYLS`.

Unfortunately, the implementation is incomplete, so it can only perform replacements from a specific list of $\mathbf{N}$ pairs of characters. Also, even if a replacement of a specific character $c_1$ with another character $c_2$ is implemented, the reverse replacement of $c_2$ with $c_1$ may or may not be implemented.

You want to try all the implemented replacements. You are given some initial string $\mathbf{S}$ to use as the initial text. You can perform any number of replacements in sequential order: the first replacement is performed on $\mathbf{S}$, and the (i+1)-th replacement is performed on the result of performing the i-th replacement. The only requirement is that each implemented replacement is performed at least once during this process. There is no upper limit on how many times you may perform each replacement.

The allowed characters are decimal digits and uppercase and lowercase English alphabet letters. In this problem, uppercase and lowercase versions of the same letter are treated as distinct characters.

What is the maximum number of unique characters that can appear in a text that is the result of the last replacement performed?
## 输入格式

The first line of the input gives the number of test cases, $\mathbf{T}$. $\mathbf{T}$ test cases follow. Each test case consists of two lines. The first line contains a string $\mathbf{S}$ and an integer $\mathbf{N}$: the initial text and the number of implemented replacements. The second line contains $\mathbf{N}$ two-character strings $\mathbf{R}_1$, $\mathbf{R}_2$, ..., $\mathbf{R}_\mathbf{N}$, representing the implemented replacements. $\mathbf{A}_i$ and $\mathbf{B}_i$ are the first and second characters of $\mathbf{R}_i$, respectively. The i-th implemented replacement corresponds to replacing all occurrences of $\mathbf{A}_i$ with $\mathbf{B}_i$.

## 输出格式

For each test case, output one line containing `Case #x: y`, where x is the test case number (starting from 1) and y is the maximum number of unique characters that can appear in a text that is the result of performing all implemented replacements to $\mathbf{S}$ one or more times each, in some order.
## 样例

### 样例输入 #1
```
4
CODEJAMWORLDFINALS 2
AO OY
xyz 3
xy zx yz
CJ 4
20 2O HC KS
AB 2
Ab bA
```
### 样例输出 #1
```
Case #1: 14
Case #2: 2
Case #3: 2
Case #4: 2
```
### 样例输入 #2
```
1
1234 5
12 2X X3 31 X2
```
### 样例输出 #2
```
Case #1: 4
```
## 提示

**Sample Explanation**

Sample Test Set 1 meets the limits for Test Set 1. Another sample case that does not meet those limits could appear in Test Set 2.

Sample Case #1 is the one in the statement. Notice that if we perform the replacements in the order mentioned in the statement, we get 13 different characters in the final text. If we perform them both once in the other order, however, we can get `CYDEJOMWYRLDFINOLS`, which has 14 different characters.

In Sample Case #2, one way to get 2 different characters in the final text is to perform the replacements in the order given from left to right, once each.

In Sample Case #3, none of the replacements affect the text at all, so it does not matter how we apply them. We will always be left with the original two letters. Notice that replacements can contain characters not appearing in the initial text, and the initial text can contain characters not appearing in the implemented replacements.

In Sample Case #4, remember that uppercase $\mathbf{B}$ is not the same character as lowercase $\mathbf{b}$.

In this additional sample case, one possibility is to perform the replacements in the following order: `X3 2X X2 2X 12 31`. This process goes through the following strings, starting with S: `1234 1234 1X34 1234 1X34 2X34 2X14`.

**Limits**

- $1 \leq \mathbf{T} \leq 100$.
- $2 \leq \text{length of } \mathbf{S} \leq 1000$, for all i.
- Each character of $\mathbf{S}$ is an uppercase or lowercase English alphabet letter or a decimal digit.
- $\mathbf{A}_i$ is an uppercase or lowercase English alphabet letter or a decimal digit, for all i.
- $\mathbf{B}_i$ is an uppercase or lowercase English alphabet letter or a decimal digit, for all i.
- $\mathbf{A}_i \neq \mathbf{B}_i$, for all i.
- $(\mathbf{A}_i, \mathbf{B}_i) \neq (\mathbf{A}_j, \mathbf{B}_j)$, for all $i \neq j$. (Each replacement is unique.)

**Test Set 1 (15 Pts, Visible Verdict)**

- $2 \leq \mathbf{N} \leq 62$.
- $\mathbf{B}_i \neq \mathbf{B}_j$, for all $i \neq j$.

**Test Set 2 (27 Pts, Hidden Verdict)**

- $2 \leq \mathbf{N} \leq 62 \times 61$.


---

---
title: "[GCJ 2019 Finals] Board Meeting [Can't Judge yet]"
layout: "post"
diff: 省选/NOI-
pid: P13123
tag: ['数学', '2019', '二分', '交互题', 'Special Judge', 'Google Code Jam']
---
# [GCJ 2019 Finals] Board Meeting [Can't Judge yet]
## 题目描述

Note that it is not necessary to know anything about the rules of chess to solve this problem.

There are $\mathbf{N}$ kings on an infinite chessboard (two-dimensional grid), located in cells with coordinates $(\mathbf{X}_{1}, \mathbf{Y}_{1})$, $(\mathbf{X}_{2}, \mathbf{Y}_{2})$, ..., $(\mathbf{X}_{\mathbf{N}}, \mathbf{Y}_{\mathbf{N}})$. Both $\mathbf{N}$ and the kings' coordinates are unknown to you. However, you do know the following things:

- $\mathbf{N}$ is at least 1 and at most $\mathbf{N}_{\text{max}}$.
- No king's coordinates (X or Y) have an absolute value exceeding $\mathbf{M}$.
- The $\mathbf{N}$ kings are located in $\mathbf{N}$ different cells.

The kings want to meet in a single cell of the board. If some cell $(\mathbf{X}, \mathbf{Y})$ were to be chosen as the meeting cell, then in order to get there, the i-th king would use a number of moves equal to the maximum of the absolute values of the differences of coordinates between its cell and the meeting cell: $\max(|\mathbf{X}-\mathbf{X}_{\mathbf{i}}|, |\mathbf{Y}-\mathbf{Y}_{\mathbf{i}}|)$. The total number of moves used by all kings is thus equal to the sum of those maximums over all values of $\mathbf{i}$. Note that it is not relevant to this problem exactly how the kings move on the board — only the source and destination cells matter, and the number of moves can always be computed using the above formula.

This problem has two phases. In the first phase, you may repeatedly do the following: propose a meeting location $(\mathbf{A}, \mathbf{B})$ (with each of $\mathbf{A}$ and $\mathbf{B}$ between $-10 \times \mathbf{M}$ and $10 \times \mathbf{M}$, inclusive), and have the judge tell you the total number of moves the kings would use to get there — the sum (over all $\mathbf{i}$) of $\max(|\mathbf{X}_{\mathbf{i}}-\mathbf{A}|, |\mathbf{Y}_{\mathbf{i}}-\mathbf{B}|)$. You can have at most $\mathbf{R}$ such exchanges with the judge, choosing your values of $\mathbf{A}$ and $\mathbf{B}$ each time. Note that the kings do not actually move, so their locations $(\mathbf{X}_{\mathbf{i}}, \mathbf{Y}_{\mathbf{i}})$ stay the same for all requests within one test case.

In the second phase, the roles are swapped: the judge gives you a meeting cell location $(\mathbf{C}, \mathbf{D})$ (with each of $\mathbf{C}$ and $\mathbf{D}$ between $-10 \times \mathbf{M}$ and $10 \times \mathbf{M}$, inclusive), and you must respond with the total number of moves the kings would use to get there, assuming that the kings are in the same locations as in the first phase. There are at most $\mathbf{R}$ such exchanges, and you must correctly respond to all of the judge's requests.

### Interactive Protocol

This is an interactive problem.

Initially, your program should read a single line containing four integers $\mathbf{T}$, $\mathbf{N}_{\text{max}}$, $\mathbf{M}$ and $\mathbf{R}$: the number of test cases, the maximum number of kings, the maximum absolute value for any coordinate for any king, and the maximum number of requests per phase, respectively. (Note that the values of $\mathbf{M}$ and $\mathbf{R}$ are fixed, and are provided as input only for convenience; see the Limits section for more details.) Then, you need to process $\mathbf{T}$ test cases.

In each test case, there are two phases. In the first phase, the i-th exchange is as follows:

- Your program sends one line containing two integers $\mathbf{A}_{\mathbf{i}}$ and $\mathbf{B}_{\mathbf{i}}$, representing the x and y coordinates of a cell.
    - Both $\mathbf{A}_{\mathbf{i}}$ and $\mathbf{B}_{\mathbf{i}}$ must be between $-10 \times \mathbf{M}$ and $10 \times \mathbf{M}$, inclusive.
- The judge responds with one line containing a single integer: the total number of moves the kings need to use to get from their unknown locations to your cell.

You may initiate at most $\mathbf{R}$ such exchanges in this phase. If you make more than $\mathbf{R}$ exchanges, or send a request that the judge can not parse or is out of bounds, the judge responds with one line with a single string $\text{ERROR}$.

To end the first phase and switch to the second phase, you must send one line with the string $\text{READY}$ (the case does not matter), to which the judge responds with the first request of the second phase.

In the second phase, the i-th exchange is as follows:

- The judge sends one line containing two integers $\mathbf{C}_{\mathbf{i}}$ and $\mathbf{D}_{\mathbf{i}}$, representing the x and y coordinates of a cell.
    - Each of $\mathbf{C}_{\mathbf{i}}$ and $\mathbf{D}_{\mathbf{i}}$ will be between $-10 \times \mathbf{M}$ and $10 \times \mathbf{M}$, inclusive.
- Your program must respond with one line containing a single integer: the total number of moves the kings would need to use to get to the given cell.

The judge is guaranteed to send at least 1 and at most $\mathbf{R}$ such requests. If you send an answer that is incorrect or unparseable, the judge responds with $\text{ERROR}$ as described above. If you answer all of the requests correctly, the judge sends one line with a single string $\text{DONE}$, at which point your program should initiate the next test case, or terminate with no error if all $\mathbf{T}$ test cases have been handled.

After the judge sends a line with $\text{ERROR}$, it does not send any other output. If your program continues to wait for the judge after receiving $\text{ERROR}$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive a Wrong Answer judgment instead of a Time Limit Exceeded error. As usual, if the memory limit is exceeded, or your program gets a runtime error, you will receive the appropriate judgment.

The number and location of the kings, as well as the number and positions of the requests that the judge sends during the second phases, are chosen before any exchanges occur.
## 输入格式

See Interactive Protocol.
## 输出格式

See Interactive Protocol.
## 样例

### 样例输入 #1
```

```
### 样例输出 #1
```

```
## 提示

**Sample Interaction**

Note that the following sample interaction is for test set 1, in which there is always exactly one king.

```
  // Suppose that the judge has decided that in the first test case, the king
  // is at the coordinates (1, -2), and the requests will be (5, -1) and
  // (7, 7).
  t, nmax, m, r = readline_int_list()   // Reads 10 1 1000000 1000
  // Our solution decides (for whatever reason) to check (3, 3) first.
  printline 3 3 to stdout
  flush stdout
  result = readline_int()               // Reads 5
  // Our solution now decides (for whatever reason) to check (2, 0).
  printline 2 0 to stdout
  flush stdout
  result = readline_int()               // Reads 2
  // Our solution concludes that the king is at (3, -2), which is consistent
  // with the observed information so far, but unfortunately not correct.
  // Our solution moves on to the request phase.
  printline READY to stdout
  request_line = readline()             // Reads 5 -1
  printline 2 to stdout                 // Wrong answer!
  request_line = readline()             // Reads ERROR
  exit                                  // exits to avoid an ambiguous TLE error
```

You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.

Instructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.

**Limits**

~~Note that a program that just makes valid exchanges with the judge (and does no other processing) takes the following time in our environment: ~13 seconds for C++, ~24 seconds for Java, ~19 seconds for Python and Go.~~

- $1 \leq \mathbf{T} \leq 15$.
- $\mathbf{M} = 10^{6}$.
- $-\mathbf{M} \leq \mathbf{X}_{\mathbf{i}} \leq \mathbf{M}$, for all $\mathbf{i}$.
- $-\mathbf{M} \leq \mathbf{Y}_{\mathbf{i}} \leq \mathbf{M}$, for all $\mathbf{i}$.
- The pairs $(\mathbf{X}_{\mathbf{i}}, \mathbf{Y}_{\mathbf{i}})$ are distinct.
- $-10 \times \mathbf{M} \leq \mathbf{C}_{\mathbf{i}} \leq 10 \times \mathbf{M}$, for all $\mathbf{i}$.
- $-10 \times \mathbf{M} \leq \mathbf{D}_{\mathbf{i}} \leq 10 \times \mathbf{M}$, for all $\mathbf{i}$.
- $\mathbf{R} = 1000$.

**Test set 1 (5 Pts, Visible)**

- $\mathbf{N}_{\text{max}} = 1$.

**Test set 2 (22 Pts, Hidden)**

- $\mathbf{N}_{\text{max}} = 10$.


---

---
title: "[GCJ 2018 Finals] Jurisdiction Restrictions"
layout: "post"
diff: 省选/NOI-
pid: P13153
tag: ['2018', '二分', '网络流', '最大流最小割定理', 'Google Code Jam']
---
# [GCJ 2018 Finals] Jurisdiction Restrictions
## 题目描述

The city of Gridtopia is a matrix of square cells ("blocks") with $R$ rows and $C$ columns; rows are numbered (starting from 1) from top to bottom, and columns are numbered (starting from 1) from left to right. The city is served by $S$ different police stations; the i-th station is in the block located in the $R_i$th row and the $C_i$th column, and no block contains more than one station.

Each station is only able to patrol blocks that are no more than $D_i$ blocks away from that station, either horizontally or vertically. That is, the i-th station can only patrol the block in row $R'$ and column $C'$ if $\max(|R' - R_i|, |C' - C_i|) \leq D_i$. Put another way, the i-th station can patrol only blocks within the square of side length $2D_i + 1$ centered on that station.

As the new police commissioner, you need to assign some blocks within the city to exactly one station that is able to patrol it. Blocks that contain stations and blocks that no station is able to patrol should not be assigned. All other blocks have to be assigned. Moreover, you must distribute this assignment load as evenly as possible among stations. Let $A_i$ denote the number of blocks assigned to the i-th station; then your goal is to minimize the difference between the maximum of all the $A_i$ values and the minimum of all of the $A_i$ values. If you make optimal assignments, what is the smallest possible difference?

## 输入格式

The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each case begins with one line with three integers $R$, $C$, and $S$: respectively, the numbers of rows and columns in the grid of cells, and the number of stations. Then, there are $S$ more lines. The i-th of these has three integers $R_i$, $C_i$, and $D_i$: respectively, the row and column in which the i-th station is located, and the parameter that determines which blocks that station is able to patrol, as described above.

## 输出格式

For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the difference described above.
## 样例

### 样例输入 #1
```
2
3 4 2
1 1 1
3 3 2
5 5 2
4 1 2
3 2 2
```
### 样例输出 #1
```
Case #1: 4
Case #2: 0
```
## 提示

In Sample Case #1, the city consists of a grid with 3 rows and 4 columns, with one station in the upper left block and one station in the block to the left of the lower right block. The first station can only patrol the three blocks that touch the edge or corner of its block; every other block is at a horizontal or vertical distance of more than 1 away. The second station can patrol any block in the grid (except for the blocks containing the stations). The difference in number of blocks assigned is minimized if you assign station 1 all three of the blocks it can patrol, and then assign the remaining seven blocks to station 2.

In Sample Case #2, one optimal strategy is to assign the blocks as follows. In this picture, $1$ represents station 1, $2$ represents station 2, $!$ represents a block assigned to station 1, $@$ represents a block assigned to station 2, and $.$ represents a block assigned to neither station (because neither station can patrol it). Notice that a station's assigned blocks do not need to form a single continuous area.

```
@@@@.
!!!@.
!2!@.
1!!@.
!@!@.
```

**Limits**

- $1 \leq T \leq 100.$
- $2 \leq S \leq 15.$
- $1 \leq R_i \leq R,$ for all $i.$
- $1 \leq C_i \leq C,$ for all $i.$
- For all $i \neq j,$ $R_i \neq R_j$ and/or $C_i \neq C_j.$ (No two stations are in the same block.)
- $1 \leq D_i < \max(R, C),$ for all $i.$

**Test set 1 (5 Pts, Visible)**

- $1 \leq R \leq 20.$
- $1 \leq C \leq 20.$

**Test set 2 (23 Pts, Hidden)**

- $1 \leq R \leq 10^9.$
- $1 \leq C \leq 10^9.$


---

---
title: "[GCJ 2018 Finals] Go, Gophers!"
layout: "post"
diff: 省选/NOI-
pid: P13155
tag: ['2018', '二分', '交互题', 'Special Judge', 'Google Code Jam']
---
# [GCJ 2018 Finals] Go, Gophers!
## 题目描述

Earlier this year, the Code Jam team planted an orchard with the help of an industrious gopher. It must have told other gophers, because we now have somewhere between 2 and 25 gophers living in the orchard. But it is hard to be sure exactly how many there are, because these gophers only emerge from their underground tunnels to eat at night, and we are too tired after a hard day of tree-pruning to stay up and watch for them. However, we do know how to make one "gopher snack" per day, which we can leave out each night to see whether it gets eaten. We think we can use this information to determine the number of gophers.

Here is what we know about the way that gophers eat. The $N$ gophers meet during one day in a council to determine an order in which they will emerge over the following $N$ nights, one at a time. Then, during each of the $i$-th of the next $N$ nights, the $i$-th gopher in the order emerges and looks for a gopher snack. Each gopher has its own particular taste level (which never changes), and it will eat a snack if and only if the snack's quality level is at least as high as that gopher's taste level. During the day after the $N$-th gopher in the order has emerged, the gophers choose a new order and the process continues. Notice that even if a gopher chooses not to eat the snack that it finds, it still does not emerge again until it comes up in the next order chosen by the council.

We must make exactly one new gopher snack each day; even if a snack is not eaten, it spoils and cannot be reused the next night. Each morning, we learn whether or not the previous night's snack was taken.

Today, we know that the gophers are meeting in their council to determine their next order, so tonight will mark the start of that order. We are willing to devote some serious time to this investigation — as many as $10^5$ nights. Using $S$ or fewer snacks, can you help us figure out how many gophers there are?

**Interactive Protocol**

This problem is interactive, which means that the concepts of input and output are different than in standard Code Jam problems. You will interact with a separate process that both provides you with information and evaluates your responses. All information comes into your program via standard input; anything that you need to communicate should be sent via standard output. Remember that many programming languages buffer the output by default, so make sure your output actually goes out (for instance, by flushing the buffer) before blocking to wait for a response. See the [FAQ](http://faq) for an explanation of what it means to flush the buffer. Anything your program sends through standard error is ignored, but it might consume some memory and be counted against your memory limit, so do not overflow it. To help you debug, a local testing tool script (in Python) is provided at the very end of the problem statement. In addition, sample solutions to a previous Code Jam interactive problem (in all of our supported languages) are provided in the analysis for [Number Guessing](http://number_guessing).

Initially, your program should read a single line containing a single integer $T$ indicating the number of test cases. Then, you need to process $T$ test cases. For each test case, your program will first read one line containing one integer $S$: the maximum number of snacks you can use. Then, your program will process up to $S + 1$ exchanges with our judge, in which the last exchange must be a guess at the answer.

For the $i$-th exchange, your program needs to use standard output to send a single line containing an integer $Q_i$.

* If $Q_i$ is in the inclusive range $[1, 10^6]$, it represents that you will leave out a gopher snack with quality level $Q_i$. In response, the judge will print a single line with a single integer: 1 if the gopher ate the snack, or 0 if it did not. This line will be printed to your input stream, as described above, and your program must read it through standard input. Then, you can start another exchange.
* If $Q_i$ is in the inclusive range $[-25, -2]$, it represents that your answer to the test case is that there are $-Q_i$ gophers. If your answer is correct, the judge will proceed to the next test case, if there is one.

The judge will print a single line with the integer $-1$, and then stop sending output to your input stream, if any of the following happen:

1. Your program sends a malformed or out-of-bounds value (e.g., $1000001$, $-1$, or GO_IS_THE_BEST_LANGUAGE), or too many values (e.g., 1 2).
2. Your program sends a value not in the inclusive range $[-25, -2]$ after having already sent $S$ values for the current test case.
3. Your program sends a value in the inclusive range $[-25, -2]$ that is not a correct answer. Note that this means that you only get one chance to answer a test case correctly.

If your program continues to wait for the judge after receiving $-1$, your program will time out, resulting in a Time Limit Exceeded error. Notice that it is your responsibility to have your program exit in time to receive the appropriate verdict (Wrong Answer, Runtime Error, etc.) instead of a Time Limit Exceeded error. As usual, if the total time or memory is exceeded, or your program gets a runtime error, you will receive the appropriate verdict.

You should not send additional information to the judge after solving all test cases. In other words, if your program keeps printing to standard output after sending the answer to the last test case, you will get a Wrong Answer judgment.
## 输入格式

See Interactive Protocol.
## 输出格式

See Interactive Protocol.
## 样例

### 样例输入 #1
```

```
### 样例输出 #1
```

```
## 提示

**Sample Interactions**

The following interaction is for Test set 1.

```
  // In this example, the problem setters have already determined that the first
  // test case has two gophers with taste levels 1 and 2 (we will call them A
  // and B, respectively), and that the second test case has four gophers with
  // taste levels 1, 999, 123, and 4567 (we will call them C, D, E, and F,
  // respectively).
  // The judge randomly generates the first order: A, B.
  t = readline_int()           // Code reads 2 into t.
  s = readline_int()           // Code reads 100000 into s.
  printline 1 to stdout        // Code sends a snack with quality level 1.
  flush stdout
  resp = readline_str()        // Code reads 1 into resp (gopher A ate the
                               //   snack).
  printline 1 to stdout
  flush stdout
  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat
                               //   the snack).
                               // Judge randomly generates B, A as the next
                               //   order.
  printline 2 to stdout
  flush stdout
  resp = readline_str()        // Code reads 1 into resp (gopher B ate the
                               //   snack).
  printline 1 to stdout
  flush stdout
  resp = readline_str()        // Code reads 1 into resp (gopher A ate the
                               //   snack).
                               // Judge randomly generates B, A as the next
                               //   order.
  printline 2 to stdout
  flush stdout
  resp = readline_str()        // Code reads 1 into resp (gopher B ate the
                               //   snack).
  printline 2 to stdout
  flush stdout
  resp = readline_str()        // Code reads 1 into resp (gopher A ate the
                               //   snack).
  printline -2 to stdout       // Code correctly determines that the only
  flush stdout                 //   scenario consistent with the information
                               //   given so far is two gophers with taste
                               //   levels 1 and 2.
                               // Judge rules that the answer is correct, and
                               //   prepares the next test case...
                               // Judge randomly generates C, E, F, D as the
                               //   first order.
  s = readline_int()           // Code reads 100000 into s. (This also shows
                               //   that the answer to the first test case was
                               //   correct.)
  printline 0 to stdout        // Code sends an invalid value.
  flush stdout
  resp = readline_str()        // Code reads -1 into resp.
  exit                         // Code exits to avoid an ambiguous TLE error.
```

The following interaction is for Test set 2. Notice that the interactions in the first test case are the same as in the previous example, but the outcome is different.

```

  // In this example, the problem setters have already determined that the first
  // test case has three gophers with taste levels 1, 2, and 1; we will call
  // them A, B, and C, respectively, and they will be ordered ABCCBAABCCBA...
  t = readline_int()           // Code reads 1 into t.
  s = readline_int()           // Code reads 100000 into s.
  printline 1 to stdout
  flush stdout
  resp = readline_str()        // Code reads 1 into resp (gopher A ate
                               //   the snack).
  printline 1 to stdout
  flush stdout
  resp = readline_srt()        // Code reads 0 into resp (gopher B did not eat
                               //   the snack).
  printline 1 to stdout
  flush stdout
  resp = readline_str()        // Code reads 1 into resp (gopher C ate the
                               //   snack).
  printline 2 to stdout
  flush stdout
  resp = readline_str()        // Code reads 1 into resp (gopher C ate the
                               //   snack).
  printline 2 to stdout
  flush stdout
  resp = readline_str()        // Code reads 1 into resp (gopher B ate the
                               //   snack).
  printline -2 to stdout       // Code erroneously decides that there
                               //   are two gophers A and B with taste levels
                               //   1 and 2; this is consistent with the
                               //   information given so far for the order
                               //   A,B,A,B,A, but the true number of gophers
  flush stdout                 //   is different, so judge rules it is wrong.
  s = readline_str()           // Code tries to read s but gets -1, meaning
                               //   that the answer to the last test case was
                               //   wrong.
  exit                         // Code exits to avoid an ambiguous TLE error.
```

You can use this testing tool to test locally or on our platform. To test locally, you will need to run the tool in parallel with your code; you can use our [interactive runner](https://storage.googleapis.com/coding-competitions.appspot.com/interactive_runner.py) for that. For more information, read the instructions in comments in that file.

Instructions for the testing tool are included in comments within the tool. We encourage you to add your own test cases. Please be advised that although the testing tool is intended to simulate the judging system, it is **NOT** the real judging system and might behave differently.

**Important warning**

Context switching between your program and the judge is expensive, and more so in our judging system. As opposed to other interactive problems, we found it necessary in all our reference solutions for this problem to bundle the exchanges to the server. That is, instead of "print taste level, read response, print taste level, read response" we can do "print taste level, print taste level, read response, read response" which requires less context switching.

**Benchmarks**

To give you some idea of how a given bundling of queries will perform in our system, we are providing some benchmarks. We wrote a program that performs $S = 10^5$ exchanges bundled into groups of specific sizes $B$ — that is, it prints $B$ taste levels, then reads $B$ responses, then prints $B$ more, then reads $B$ more, and so on, $S / B$ times. We implemented this in both Python and C++, always printing the $B$ taste levels to a string variable and printing that string later, ensuring the buffer is not flushed within a bundle. Here are the results for each bundle size $B$, in seconds (rounded up to the next half-second, and taking the worst case over multiple runs):

| $B$ | 1 | 10 | 50 | 100 | 200 | 500 | $10^5$ |
|:---:|:---:|:----:|:----:|:-----:|:-----:|:-----:|:--------:|
| Python | 167 | 21 | 6.5 | 5.5 | 5 | 5 | >250 |
| C++ | 130 | 18 | 5.5 | 5.5 | 4.5 | 2.5 | >250 |

Notice that with somewhat small bundle sizes, the context switching time gets below 5s per test, which is under a minute per test set.

**Limits**

- $1 \leq T \leq 10$.
- The number of gophers is between 2 and 25, inclusive. The taste level of each gopher is between 1 and $10^6$, inclusive. $S = 10^5$.

**Test set 1 (10 Pts, Visible)**

- No two gophers have the same taste level.
- The order in which the gophers emerge each night is chosen uniformly at random from all possible orders, and independently of all other orders.

**Test set 2 (38 Pts, Hidden)**

- The GCD of the set $\{x : \text{there exist exactly } x \geq 1 \text{ gophers in the input that share a taste level}\} = 1$.
- The order in which the gophers emerge is chosen independently of the provided snacks.

For each test case, the multiset of taste levels and the seed for the random number generation are generated by the problem setters in advance of the contest, and will be the same for any contestant, for any submission. That means two submissions that offer the same number $s_i$ of snacks for test case $i$ will see the gophers emerge in the same order.
  - For example, the following scenario would be possible in either of the test sets:
    * two gophers, one with taste level 1, and one with taste level 2
  - The following scenario would be possible in test set 2, but not in test set 1:
    * three gophers, two with taste level 1, and one with taste level 2
  - The following scenarios would not be possible in either of the test sets:
    * six gophers, four with taste level 1, and two with taste level 2
    * two gophers, both with taste level 7


---

---
title: "[GCJ 2017 #2] Shoot the Turrets"
layout: "post"
diff: 省选/NOI-
pid: P13174
tag: ['2017', 'Special Judge', '广度优先搜索 BFS', '二分图', 'Google Code Jam']
---
# [GCJ 2017 #2] Shoot the Turrets
## 题目描述

The fight to free the city from extraterrestrial invaders is over! People are happy that love and peace have returned.

The city is represented as a grid with $R$ rows and $C$ columns. Some cells on the grid are buildings (through which nobody can see, nobody can shoot, and nobody can walk), and some are streets (through which everybody can see, shoot and walk). Unfortunately, during the war, the now-defeated invaders set up automatic security turrets in the city. These turrets are only in streets (not in buildings). They pose a threat to the citizens, but fortunately, there are also some soldiers on the streets (not in buildings). Initially, no soldier is in the same place as a turret.

The invader turrets do not move. They are small, so they don't block sight and shooting. A soldier cannot walk through an active turret's cell, but can walk through it once it is destroyed. A turret can only see soldiers in the cells for which it has a horizontal or vertical line of sight. If a soldier enters such a cell, the turret does not fire. If a soldier attempts to exit such a cell (after entering it, or after starting in that cell), the turret fires. Luckily, a soldier can still shoot from that cell, and the turret will not detect that as movement. It means that none of your soldiers will actually die, because in the worst case they can always wait, motionless, for help (perhaps for a long time). Maybe you will have a chance to rescue them later.

Each soldier can make a total of $M$ unit moves. Each of these moves must be one cell in a horizontal or vertical direction. Soldiers can walk through each other and do not block the lines of sight of other soldiers or turrets. Each soldier also has one bullet. If a soldier has a turret in her horizontal or vertical line of sight, the soldier can shoot and destroy it. Each shot can only destroy one turret, but the soldiers are such excellent shooters that they can even shoot past one or several turrets or soldiers in their line of sight and hit another turret farther away!

You are given a map (with the soldier and turret positions marked). What is the largest number of turrets that the soldiers can destroy?
## 输入格式

The first line of the input gives the number of test cases, $T$. $T$ test cases follow. Each test case begins with a line containing the integer $C$ (the width of the map), $R$ (the height of the map) and $M$ (the number of unit moves each soldier can make). The next $R$ lines contain $C$ characters each, with . representing a street, # representing a building, S representing a soldier and T representing a turret.

## 输出格式

For each test case, output one line containing `Case #x: y`, where $x$ is the test case number (starting from 1) and $y$ is the maximum number of turrets that it is possible to destroy. Then $y$ lines should follow: each should contain two integers $s_i$ and $t_i$ denoting that the $i$th thing that happens should be soldier $s_i$ destroying turret $t_i$ (you don't need to specify exactly how the soldier has to move). If multiple valid strategies exist, you may output any one of them.

Soldiers are numbered from 1, reading from left to right along the top row, then left to right along the next row down from the top, and so on, from top to bottom.
## 样例

### 样例输入 #1
```
4
2 2 1
#S
T.
2 6 4
.T
.T
.T
S#
S#
S#
5 5 4
.....
SS#.T
SS#TT
SS#.T
.....
3 3 8
S.#
.#.
#.T
```
### 样例输出 #1
```
Case #1: 1
1 1
Case #2: 3
3 3
1 1
2 2
Case #3: 3
1 2
2 1
6 3
Case #4: 0
```
## 提示

**Sample Explanation**

In Case #2, one of the possible solutions is to move soldier $3$ up three cells and shoot turret $3$. Then soldier $1$ can move up one cell and right one cell (to where turret $3$ was) and shoot past turret $2$ to destroy turret $1$. Finally, soldier $2$ can move up three cells and shoot turret $2$.

In Case #3, soldier $1$ can move up one cell, then right three cells and shoot turret $2$. Then soldier $2$ can move up one cell, then right three cells and shoot turret $1$. Finally, soldier $6$ can move down one cell, then right three cells and shoot turret $3$. Other soldiers have insufficient move range to shoot any other turrets.

In Case #4, the soldier cannot move to within the same row or column as the turret, so the turret cannot be destroyed.

**Limits**

- $1 \leq T \leq 100$.
- $0 \leq M < C \times R$.

**Small dataset (Test Set 1 - Visible)**

- Time limit: ~~30~~ 7.5 seconds.
- $1 \leq C \leq 30$.
- $1 \leq R \leq 30$.
- The number of S symbols is between $1$ and $10$.
- The number of T symbols is between $1$ and $10$.

**Large dataset (Test Set 2 - Hidden)**

- Time limit: ~~60~~ 15 seconds.
- $1 \leq C \leq 100$.
- $1 \leq R \leq 100$.
- The number of S symbols is between $1$ and $100$.
- The number of T symbols is between $1$ and $100$.


---

---
title: "[GCJ 2016 #2] Freeform Factory"
layout: "post"
diff: 省选/NOI-
pid: P13201
tag: ['动态规划 DP', '图论', '2016', '二分图', 'Google Code Jam']
---
# [GCJ 2016 #2] Freeform Factory
## 题目描述

You have just built a brand new factory. Your factory has $\mathbf{N}$ different machines, and each machine needs to be operated by exactly one worker for the factory to function well.

You have also hired $\mathbf{N}$ workers to operate those machines. Since you were in a hurry when you hired them, you did not check whether they actually know how to operate your machines. Now you have finally asked them, and so you have the information on whether the i-th worker can operate the j-th machine, for each i and j.

In a typical working day, the workers will arrive at the factory in a random order, which can be different each day. As each worker arrives, they will find all machines that they know how to operate and that do not already have an operator. They will choose one of those at random and operate it for the whole working day. If all machines they know how to operate already have an operator, they will not work that day. Your goal is to make sure that all machines are being operated each working day, regardless of what order the workers arrive in and which machines they choose.

For example, suppose there are two workers $\mathrm{A}$ and $\mathrm{B}$, and two machines 1 and 2. Suppose that $\mathrm{A}$ knows how to operate 1 and 2, and $\mathrm{B}$ knows how to operate 1 but not 2. If worker $\mathrm{B}$ arrives first, he will pick machine 1, then when worker $\mathrm{A}$ arrives she will have to choose 2, and the factory will work well. However, if worker $\mathrm{A}$ arrives first, it might happen that she chooses to operate 1 on that day, and then when worker $\mathrm{B}$ arrives he does not have anything to do, leaving machine 2 without an operator, and causing your factory to waste a whole day!

As another example, suppose there are two workers $\mathrm{A}$ and $\mathrm{B}$, and two machines 1 and 2, and that $\mathrm{A}$ knows how to operate 1 but not 2, and $\mathrm{B}$ does not know how to operate anything. Then, regardless of the order in which the workers arrive, the factory will not be able to function well.

Before you open your factory, in order to guarantee that the factory will constantly function well, you can teach your workers how to operate machines. It costs one dollar to give a single worker a lesson on how to operate a single machine. Each lesson involves only one worker and only one machine, but you can teach any number of lessons to any number of workers, and the same worker can receive multiple lessons. You cannot make a worker forget how to operate a machine if they already know how to operate it.

For example, both examples above can be fixed by teaching worker $\mathrm{B}$ to operate machine 2. In that case each machine is guaranteed to have an operator every day, regardless of which order the workers arrive in and which machines they choose to operate when they have more than one possibility.

What is the minimum amount of dollars you need to spend on training workers to make sure the factory functions well every day?
## 输入格式

The first line of the input gives the number of test cases, $\mathbf{T}$. $\mathbf{T}$ test cases follow. Each test case starts with one line with an integer $\mathbf{N}$, the number of workers (and machines). This line is followed by $\mathbf{N}$ lines with a string of $\mathbf{N}$ characters each. The $\mathrm{j}$-th character on the i-th of those lines is 1 if the i-th worker knows how to operate the $\mathrm{j}$-th machine, and 0 otherwise.

## 输出格式

For each test case, output one line containing `Case #x: y`, where $\mathrm{x}$ is the test case number (starting from 1), and $\mathrm{y}$ is a non-negative integer: the minimum amount of dollars you need to spend to make sure that all $\mathbf{N}$ machines will always have an operator.
## 样例

### 样例输入 #1
```
5
2
11
10
2
10
00
3
000
000
000
1
1
3
000
110
000
```
### 样例输出 #1
```
Case #1: 1
Case #2: 1
Case #3: 3
Case #4: 0
Case #5: 3
```
## 提示

**Sample Explanation**

Sample cases #1 and #2 are the ones described in the problem statement.

In sample case #3, nobody knows how to do anything! One optimal strategy is to teach worker A to operate machine 1, worker B to operate machine 2, and worker C to operate machine 3.

In sample case #4, no action is necessary. There is only one worker, and the worker already knows how to operate the one machine.

In sample case #5, worker B already knows how to operate machines 1 and 2. One optimal strategy is to teach worker A to operate machine 3, and make A the only worker who can operate that machine. But now we have to consider that B might operate either machine 1 or 2 upon arrival, so C needs to be able to operate the one not chosen by B. So C must be taught to operate both 1 and 2.

**Sample Explantion**

- $1 \leqslant \mathbf{T} \leqslant 100$.

**Small dataset (6 Pts, Test Set 1 - Visible)**

- $1 \leqslant \mathbf{N} \leqslant 4$.

**Large dataset (25 Pts, Test Set 2 - Hidden)**

- $1 \leqslant \mathbf{N} \leqslant 25$.


---

---
title: "[GCJ 2014 #3] Crime House"
layout: "post"
diff: 省选/NOI-
pid: P13262
tag: ['贪心', '2014', '二分', '分类讨论', 'Google Code Jam']
---
# [GCJ 2014 #3] Crime House
## 题目描述

While working for the police, you've identified a house where people go to commit crimes, called Crime House. One day, you set up a camera over the door of the house and record a video.

You don't know how many people were in Crime House at the start of the day, but you can see people enter and leave through the front door. Unfortunately, because the people entering and leaving Crime House are criminals, sometimes they wear masks; and you aren't quite sure if the front door is the only way in or out.

Sometimes you can guess who was wearing a mask. If criminal #5 entered the house, then someone wearing a mask left, then criminal #5 entered the house again, then either the person wearing the mask was criminal #5, or there is another way out of Crime House.

At the end of the day, when Crime House has closed its doors for the night, you watch your video. Because you're an optimist, you want to figure out if it's possible that there are no other entrances or exits from crime house; and if so, you want to figure out the minimum number of people who could be in Crime House at the end of the day.
## 输入格式

The first line of the input gives the number of test cases, $\mathbf{T}$. $\mathbf{T}$ test cases follow. Each test case starts with a line containing a single integer $\mathbf{N}$, the number of times people pass through the front door of Crime House in the day. Next follows $\mathbf{N}$ lines, each of which contains information about one person entering or leaving Crime House through the front door.

That information consists of a single character, $\mathbf{E}$ or $\mathbf{L}$, followed by a space and then an integer $\mathbf{i d}$. If the first character is $\mathbf{E}$, that indicates someone entered Crime House through the front door; if it's $\mathbf{L}$, someone left through the front door. If $\mathbf{i d}$ is greater than zero, the person with that identifier entered or left Crime House. If $\mathbf{i d}$ is zero, then the person who entered or left Crime House was wearing a mask, and we don't know who he or she was.

## 输出格式

For each test case, output one line containing "Case #x: $y$", where $\mathrm{x}$ is the test case number (starting from 1). If it's possible that there are no other entrances or exits from Crime House, then $y$ should be the minimum number of people who could be in Crime House at the end of the day. If that's impossible, $y$ should be "CRIME TIME".
## 样例

### 样例输入 #1
```
5
3
E 5
L 0
E 5
2
L 1
L 1
4
L 1
E 0
E 0
L 1
7
L 2
E 0
E 1
E 2
E 0
E 3
L 4
13
L 4
L 1
L 2
E 0
L 1
E 0
L 2
E 0
L 2
E 0
E 0
L 1
L 4
```
### 样例输出 #1
```
Case #1: 1
Case #2: CRIME TIME
Case #3: 1
Case #4: 4
Case #5: 0
```
## 提示

**Limits**

- $1 \leq \mathbf{T} \leq 100 .$
- $0 \leq \text {id} \leq 2000 .$

**Small dataset(12 Pts)**

- Time limit: ~~60~~ 3 seconds.
- $1 \leq \mathbf{N} \leq 15 .$

**Large dataset(22 Pts)**

- Time limit: ~~120~~ 10 seconds.
- $1 \leq \mathbf{N} \leq 1000$


---

---
title: "[GCJ 2012 #3] Havannah"
layout: "post"
diff: 省选/NOI-
pid: P13329
tag: ['2012', '二分', '并查集', 'Google Code Jam']
---
# [GCJ 2012 #3] Havannah
## 题目背景

Havannah was created by Christian Freeling and MindSports. MindSports and Christian Freeling do not endorse and have no involvement with Google Code Jam.
## 题目描述

Havannah is an abstract strategy board game created by Christian Freeling. Havannah is a game played on a hexagonal board with $S$ hexagons to each side. Each hexagon has two horizontal and four slanted edges. The hexagons are identified by pairs of integer values. The hexagon in the bottom corner of the board is $(1, 1)$. The hexagon adjacent to $(x, y)$ in the direction of a two-o'clock hand is $(x, y+1)$. The hexagon adjacent to $(x, y)$ in the direction of a ten-o'clock hand is $(x + 1, y)$. Here is an example board with $S = 5$:

![](https://cdn.luogu.com.cn/upload/image_hosting/oegdj7r3.png)

In the game of Havannah, each hexagon can be occupied by at most one stone. Stones once put on the board are never removed or moved. The goal of the game is to build from stones a connected set of stones of one of three kinds. The winning structures are:

- A **ring** that encircles one or more empty hexagons. That is, at least one of the inner hexagons must be empty. More specifically, there is an empty hexagon that is separated from the outermost boundary of the board by hexagons with stones. Note that this rule is different from the official game Havannah.
- A **bridge** that connects any two corners of the board.
- A fork that connects any three of the board's six edges. Corners do not count as part of either adjacent edge.

This picture shows examples of winning structures:

![](https://cdn.luogu.com.cn/upload/image_hosting/iar2seqk.png)

Your program should determine whether a sequence of moves of a single player builds a winning structure. If so, it should output the name of the structure and the number of the move that completed it. If a move completes multiple rings, connects more than two corners, or connects more than three edges, the structure is still considered a ring, a bridge, or a fork, respectively. But if a move completes structures of different kinds at once, your program should output the names of all of them. We are only interested in the first winning move: ignore all moves following the winning one. If there is no winning structure on the board after playing all the moves from the sequence, your program should output none.
## 输入格式

The first line of input gives the number of test cases, $T$. $T$ test cases follow. The first line of each test case contains two integers $S$ and $M$, the number of hexagons on each side of the board and the number of moves in the sequence, respectively. The next $M$ lines provide the sequence of moves, in order, where each line contains a space-separated pair $(x, y)$ of hexagon identifiers. All the moves in the sequence lie on the board of size $S$. In each test case, the board is initially empty and the moves do not repeat.
## 输出格式

For each test case, output one line containing "Case #$n$: " followed by one of:

* none
* bridge in move $k$
* fork in move $k$
* ring in move $k$
* bridge-fork in move $k$
* bridge-ring in move $k$
* fork-ring in move $k$
* bridge-fork-ring in move $k$

The cases are numbered starting from 1. The moves are numbered starting from 1.
## 样例

### 样例输入 #1
```
7
2 4
1 1
1 2
2 3
3 3
3 6
2 1
2 2
2 3
2 4
1 2
4 4
3 7
3 3
2 2
2 3
3 4
4 4
4 3
3 2
3 6
2 2
2 3
3 4
4 4
4 3
3 2
3 8
1 1
2 1
1 3
2 4
1 2
3 2
3 3
3 4
3 7
1 1
2 2
3 5
3 4
5 3
4 3
3 3
3 3
1 1
1 3
3 5
```
### 样例输出 #1
```
Case #1: bridge in move 2
Case #2: fork in move 5
Case #3: none
Case #4: ring in move 6
Case #5: bridge-fork in move 5
Case #6: bridge in move 7
Case #7: none
```
## 提示

**Limits**

**Test set 1 (8 Pts, Visible Verdict)**

- Time limit: ~~30~~ 3 seconds.
- $1 \leq T \leq 200$
- $2 \leq S \leq 50$
- $0 \leq M \leq 100$

**Test set 2 (12 Pts, Hidden Verdict)**

- Time limit: ~~60~~ 6 seconds.
- $1 \leq T \leq 20$
- $2 \leq S \leq 3000$
- $0 \leq M \leq 10000$


---

---
title: "[GCJ 2012 #3] Quality Food"
layout: "post"
diff: 省选/NOI-
pid: P13330
tag: ['数学', '2012', '二分', '三分', 'Google Code Jam']
---
# [GCJ 2012 #3] Quality Food
## 题目描述

You just moved from your hometown to a big metropolitan city! You love everything about your new environment, except for the food. Your hometown provides the best food in the region (called "quality food") and you sure will miss it.

Fortunately, the largest restaurant in your hometown provides a food delivery service. You can purchase any amount of food in one delivery. There is a constant delivery fee for every delivery, regardless of the amount of food purchased in the delivery.

This restaurant serves different types of food. Each type of food has two properties: a price-per-meal, and a time-to-stale. One "meal" of food will feed you for one day; once a meal has been eaten, it cannot be eaten again. The time-to-stale of a type of food is the maximum number of days for which that food can still be eaten, counting from when you received it. A time-to-stale of zero means you must eat that type of food on the day of delivery.

In a single delivery you can purchase as many different types of food, and as many meals of each of those types, as you have money for. Note that if a particular type of food has a time-to-stale of $t$, it doesn't make any sense to order more than $t+1$ meals of that food in one delivery: at least one meal would go stale before you could eat it.

This restaurant has a very fast delivery service, so you will receive all the food in a delivery on the same day that you purchased it, and you may eat some of the food on the same day. Food delivery is the only way for you to receive quality food.

Given an amount of money, which you can spend on meal prices and delivery fees, what is the maximum number of days for which you can eat quality food every day?
## 输入格式

The first line of input gives the number of test cases, $T$. $T$ test cases follow. Each test case will begin with three integers, $M$, $F$ and $N$, denoting the amount of money you have, the delivery fee, and the number of types of food provided by the restaurant, respectively. $N$ lines follow, each will consist of two integers, $P_i$ and $S_i$, denoting respectively the price-per-meal and time-to-stale of one type of food.

## 输出格式

For each test case, output one line containing "Case #$x$: $y$", where $x$ is the case number (starting from 1) and $y$ is the maximum number of days that you can keep eating at least one meal of quality food everyday.
## 样例

### 样例输入 #1
```
3
32 5 2
5 0
10 2
10 10 1
10 10
10 1 1
1 5
```
### 样例输出 #1
```
Case #1: 3
Case #2: 0
Case #3: 8
```
## 提示

**Sample Explanation**

An example scenario for the first case is by purchasing one meal of the first type and one meal of the second type during your first day in the city (costing a total of 20). Eat the first type of food that day, and eat the second type the next day. During your third day, purchase one meal of the first type and eat it on the same day. This accounts for three days.

**Limits**

- $1 \leq T \leq 50.$
- $1 \leq F \leq M.$
- $1 \leq N \leq 200.$
- $1 \leq P_i \leq M.$

**Test set 1 (9 Pts, Visible Verdict)**

- $0 \leq S_i \leq 2,000,000.$
- $1 \leq M \leq 2,000,000.$

**Test set 2 (18 Pts, Hidden Verdict)**

- $0 \leq S_i \leq 10^{18}.$
- $1 \leq M \leq 10^{18}.$


---

---
title: "[GDCPC 2024] 图"
layout: "post"
diff: 省选/NOI-
pid: P13356
tag: ['图论', '二分', '2024', '广东', 'Special Judge', '生成树', 'XCPC']
---
# [GDCPC 2024] 图
## 题目背景

数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>
## 题目描述

给定一张 $n$ 个点 $m$ 条边的无向图，令 $k=\lceil\frac{m}{n-1}\rceil$，你需要判断能否找到两个不同的点 $u,v$，满足它们之间存在 $k$ 条**边不相交**路径，如果可以找到这样的 $u,v$，你需要输出这些路径，如果存在多种构造方案，输出任意一种即可。

额外需要注意的是输入**可能存在重边**，也就是对于同一个无序对 $(u,v)$，它们之间可能存在多条边，如果它们之间存在 $s$ 条边那么你可以理解为这条边可以经过 $s$ 次。

不过我们保证输入**不存在自环**。
## 输入格式

**本题包含多组输入数据。**

输入第一行一个正整数 $T(1\le T\le 10^4)$ 表示数据组数。

对于每组输入数据，第一行输入两个正整数 $n,m(2\le n\le 10^5,1\le m\le 2\times 10^5)$ 表示点数和边数，接下来 $m$ 行每行两个正整数 $u,v(1\le u,v\le n,u\not=v)$ 描述 $u,v$​ 间存在的一条边。

保证 $\sum n\le 10^5$，$\sum m\le 2\times 10^5$。其中 $\sum n,\sum m$ 分别表示同一个测试点内所有输入数据的 $n,m$ 之和。
## 输出格式

对于每组输入数据，如果不存在这样的 $u,v$，那么输出一行一个整数 `-1`，否则先输出一行两个正整数 $u,v$ 表示你找到的两个点，接下来输出 $k=\lceil\frac{m}{n-1}\rceil$ 行，每行第一个正整数 $t$ 描述你选出来的路径长度，接下来 $t$ 个正整数 $x_1,x_2,\dots,x_t$，表示你选择了 $x_1\to x_2\to\cdots\to x_t$ 这条路径，你需要保证 $x_1=u$ 且 $x_t=v$。且你需要保证输出的 $k$ 条路径满足边不相交的条件。
## 样例

### 样例输入 #1
```
3
3 1
1 3
4 7
1 2
2 3
3 4
4 1
1 3
2 4
1 4
5 5
1 2
2 3
3 4
4 5
3 5
```
### 样例输出 #1
```
1 3
2 1 3
1 4
4 1 2 3 4
2 1 4
2 1 4
3 5
3 3 4 5
2 3 5
```
## 提示

第一组输入数据，存在 $\lceil\frac{m}{n-1}\rceil=\lceil\frac{1}{3-1}\rceil=1$ 条 $1$ 到 $3$ 的边不相交路径 $1\to 3$。

第二组输入数据，存在 $\lceil\frac{m}{n-1}\rceil=\lceil\frac{7}{4-1}\rceil=3$ 条 $1$ 到 $4$ 的边不相交路径 $1\to 2\to 3\to 4,1\to 4,1\to 4$，注意到 $1\to 4$ 这条边虽然经过了两次，但是在原输入中这条边也输入了两次，所以认为它们还是不同的边。

第三组输入数据，存在 $\lceil\frac{m}{n-1}\rceil=\lceil\frac{5}{5-1}\rceil=2$ 条 $3$ 到 $5$ 的边不相交路径 $3\to 4\to 5,3\to 5$。


---

---
title: "[GDCPC 2024] 小班课"
layout: "post"
diff: 省选/NOI-
pid: P13358
tag: ['2024', '广东', 'Special Judge', '二分图', 'XCPC']
---
# [GDCPC 2024] 小班课
## 题目背景

数据、标程、题解等资源的获取：<https://gitlink.org.cn/thusaa/gdcpc2024>
## 题目描述

在 P 大学中，很多课程设立了小班课，学生可以自由根据需求选择小班课。当然，小班课的容量并不是无限的，并不是每个学生都能选上心仪的小班课。

本学期，共有 $n$ 名同学报名了 A 课程，该课程共设立了 $m$ 门小班课，第 $i$ 门小班课有容量 $b_i$。第 $i$ 名学生对小班课有一个意向度序列 $a_{i,1}\sim a_{i,k_i}$，其中 $a_{i,1}$ 表示意向度最高的课程，$a_{i,k_i}$ 表示意向度最低的课程。如果一门小班课 $j$ 不在这个序列里，那么说明学生 $i$ 无法参加第 $j$ 门小班课。

学生们按照 $1\sim n$ 的顺序进行选课，每次会选择优先度最高且未满的小班课，如果所有 $a_{i,1}\sim a_{i,k_i}$ 都已满，那么该学生不会选择任何小班课。

现在给出每个学生的意向度序列，请重排学生的顺序，使得选上小班课的学生最多。并构造方案。
## 输入格式

第一行一个正整数 $T(1\leq T\leq 500)$，表示数据组数。

对于每组数据，第一行两个正整数 $n,m(1\leq n,m\leq 500)$，即学生数量和小班课数量。

之后一行 $m$ 个非负整数 $b_i(0\leq b_i\leq 500)$，即每一门小班课的容量。

之后 $n$ 行，每行首先是一个非负整数 $k_i(0\leq k_i\leq m)$，之后是 $k_i$ 个两两不同的正整数 $a_{i,1}\sim a_{i,k_i}(1\leq a_{i,j}\leq m)$，表示意向度序列。

## 输出格式

对于每组数据，输出两行，第一行为一个整数 $ans$ 表示答案，之后一行 $n$ 个数，为一个 $1\sim n$ 的排列，表示构造的方案。如果有多种方案，输出任意一种即可。

## 样例

### 样例输入 #1
```
3
5 5
1 1 1 1 1
4 1 3 2 4
1 5
4 3 4 2 1
2 3 5
1 1
5 3
1 2 2
2 1 2
2 1 2
2 1 3
2 1 3
2 1 3
5 5
1 1 1 1 1
2 1 2
2 5 4
2 3 2
2 4 3
2 5 1
```
### 样例输出 #1
```
5
2 4 5 1 3
5
5 1 2 3 4
5
1 5 2 4 3
```
## 提示

对于第一组数据，按照给定的方案，学生 $2$ 首先选择 $5$，然后学生 $4$ 选择 $3$，学生 $5$ 选择 $1$，学生 $1$ 尝试选择 $1,5$ 但都已满员，所以最终选择 $2$，学生 $3$ 尝试选择 $3$ 但已满员，所以最终选择 $4$。该组数据的方案不唯一，例如，$\{2,5,4,3,1\}$ 也是一个可行解。

对于第二组数据，$\{1,2,3,4,5\}$ **不**是一个可行解，如果这样构造，那么学生 $1,2,3,4$ 会分别选择 $1,2,3,3$，这时对于学生 $5$，$1,3$ 都已满员，因此无法选择任何课程。


---

---
title: "[NWERC 2023] Isolated Island"
layout: "post"
diff: 省选/NOI-
pid: P13708
tag: ['图论', '计算几何', '2023', '平面图', '二分图', 'ICPC', 'Ad-hoc']
---
# [NWERC 2023] Isolated Island
## 题目描述

On a small island far far away, a handful of old men live isolated from the rest of the world.
The entire island is divided into plots of land by fences, and each old man owns
a single plot of land bounded by fences on all sides. (The region
outside all fences is the ocean.)
Each of the inhabitants needs fish to survive and the only place where they can fish is the ocean surrounding them.
Since not every plot of land is connected to the ocean,
some of the men might need to pass through the land of others before being able to fish.
The men can cross a single fence at a time, but cannot go through fenceposts or
locations where fences intersect.

Unfortunately, the old men are greedy.
They demand one fish each time a person wants to enter their land.
Since they do not want to lose too much fish to the others,
every old man chooses a route that minimizes the number of fish he has to pay to get to the ocean.

Over the years, this has led to rivalry between the old men.
Each man hates all other men who have to pay less than him to reach the ocean.
Two men only *like* each other if they have to pay the same amount of fish to reach the ocean.

|![](https://cdn.luogu.com.cn/upload/image_hosting/e253y5sb.png)|![](https://cdn.luogu.com.cn/upload/image_hosting/8aukzter.png)|![](https://cdn.luogu.com.cn/upload/image_hosting/ea4htdic.png)|
|:---:|:---:|:---:|

:::align{center}
Figure I.1: Illustrations of the first three Sample Inputs. In Sample Input 1, every man has direct access to the ocean, so they all like each other. In Sample Input 2, there does not exist a pair of neighbours who like each other, because the man living in the middle needs to pay one fish, whereas all of his neighbours do not have to pay any fish to reach the ocean. In Sample Input 3, there are six men, some of whom are friendly neighbours.
:::

The natural question which now occurs is:
are there some old men on this island who are neighbours (owning land on
opposite sides of a single fence) and like each other?
See Figure I.1 for two islands with opposite answers to this question.
## 输入格式

The input consists of:
- One line with an integer $n$ ($3 \le n \le 1000$), the number of fences.
- $n$ lines, each with four integers $x_1$, $y_1$, $x_2$, and $y_2$ ($\left|x_1\right|, \left|y_1\right|, \left|x_2\right|, \left|y_2\right|\leq 10^6$, $(x_1,y_1)\neq(x_2,y_2)$), indicating a straight fence between fenceposts at $(x_1,y_1)$ and $(x_2, y_2)$.

Note that fences may intersect internally, and that three or more fences may intersect in the same location.

It is guaranteed that any two fences intersect only in at most one point.
Furthermore, after crossing a single fence, one always ends up in a different region.
All regions together form a single island, where any region can be reached from any other region.

## 输出格式

If there exists a pair of neighbours who like each other, then output "$\texttt{yes}$". Otherwise, output "$\texttt{no}$".
## 样例

### 样例输入 #1
```
6
-3 -3 0 3
-3 -3 0 0
-3 -3 3 -3
0 0 0 3
0 0 3 -3
0 3 3 -3
```
### 样例输出 #1
```
yes
```
### 样例输入 #2
```
 6
-6 -3 0 3
0 3 6 -3
6 -3 -6 -3
-3 0 3 0
3 0 0 -3
0 -3 -3 0
```
### 样例输出 #2
```
no
```
### 样例输入 #3
```
8
0 1 2 1
2 2 0 0
1 2 1 0
1 0 2 1
0 0 2 0
1 2 2 2
0 1 0 0
2 2 2 0
```
### 样例输出 #3
```
yes
```
### 样例输入 #4
```
4
0 0 1 0
1 0 1 1
1 1 0 1
0 1 0 0
```
### 样例输出 #4
```
no
```


---

---
title: "酒店之王"
layout: "post"
diff: 省选/NOI-
pid: P1402
tag: ['福建省历届夏令营', '网络流', '二分图']
---
# 酒店之王
## 题目描述

XX 酒店的老板想成为酒店之王，本着这种希望，第一步要将酒店变得人性化。由于很多来住店的旅客有自己喜好的房间色调、阳光等，也有自己所爱的菜，但是该酒店只有 $p$ 间房间，一天只有固定的 $q$ 道不同的菜，每个房间只能住一位客人，每道菜也只能给一位客人食用。

有一天来了 $n$ 个客人，每个客人说出了自己喜欢哪些房间，喜欢哪道菜。但是很不幸，可能做不到让所有顾客满意（满意的条件是住进喜欢的房间且吃到喜欢的菜）。

要怎么分配，能使最多顾客满意呢？
## 输入格式

第一行给出三个整数，分别表示表示 $n,p,q$。

之后 $n$ 行，每行 $p$ 个整数，只可能是 $0$ 或 $1$，第 $i$ 行第 $j$ 个数表示第 $i$ 个人喜不喜欢第 $j$ 个房间（$1$ 表示喜欢， $0$ 表示不喜欢）。

之后 $n$ 行，每行 $q$ 个整数，只可能是 $0$ 或 $1$，第 $i$ 行第 $j$ 个数表示第 $i$ 个人喜不喜欢第 $j$ 道菜（$1$ 表示喜欢， $0$ 表示不喜欢）。
## 输出格式

最大的顾客满意数。


## 样例

### 样例输入 #1
```
2 2 2
1 0
1 0
1 1
1 1

```
### 样例输出 #1
```
1
```
## 提示

#### 数据规模与约定

对于全部的测试点，保证 $1 \leq n,p,q \leq 100$。


---

---
title: "火枪打怪"
layout: "post"
diff: 省选/NOI-
pid: P1485
tag: ['线性数据结构', '二分']
---
# 火枪打怪
## 题目描述

LXL 进入到了一片丛林,结果他发现有 $n$ 只怪物排成一排站在他面前。LXL 有一杆火枪能对付这些怪物。他知道从左至右数第 $i$ 只怪物的血量是 $m_i$。现在 LXL 可以将一些子弹射向某个怪物。LXL 可以控制他所发射的子弹数量及子弹的威力值。当某个子弹射到第 $i$ 个怪物，如果这个子弹的威力值为 $p$，除了这个怪物会掉 $p$ 点血以外，它左边的第 $j$ 个怪物 $(j<i)$，也会遭到 $\max(0, p - (i - j)^2)$ 的溅射伤害（好神奇的子弹）。当某只怪物的血量小于 $0$ 时，它就死了，但它的尸体还在，即怪物的位置永远不会改变。LXL 希望只用 $k$ 发子弹，请你求出一个最小的正整数 $p$，使 LXL 用 $k$ 发子弹且每发子弹的威力值为 $p$ 就可以消灭所有怪物。

## 输入格式

第一行，两个正整数 $n,k$。

第二行，$n$ 个正整数，第 $i$ 个正整数表示从左至右数第 $i$ 只怪物的血量 $m_i$。

## 输出格式

一个正整数，表示子弹的最小威力值 $p$。

## 样例

### 样例输入 #1
```
3 1
1 4 5

```
### 样例输出 #1
```
6
```
## 提示

对于 $30\%$ 的数据，$n\leq 300$。

对于 $100\%$ 的数据，$n\leq 5\times 10^5$，$k\leq 5\times 10^5$，$1\leq m_i\leq 10^{10}$。



---

---
title: "[国家集训队] 矩阵乘法"
layout: "post"
diff: 省选/NOI-
pid: P1527
tag: ['集训队互测', 'O2优化', '整体二分']
---
# [国家集训队] 矩阵乘法
## 题目描述

给你一个 $n \times n$ 的矩阵，不用算矩阵乘法，但是每次询问一个子矩形的第 $k$ 小数。

## 输入格式

第一行有两个整数，分别表示矩阵大小 $n$ 和询问组数 $q$。

第 $2$ 到第 $(n + 1)$ 行，每行 $n$ 个整数，表示这个矩阵。第 $(i + 1)$ 行的第 $j$ 个数表示矩阵第 $i$ 行第 $j$ 列的数 $a_{i, j}$。

接下来 $q$ 行，每行五个整数 $x_1, y_1, x_2, y_2, k$，表示一组询问，要求找到以 $(x_1, y_1)$ 为左上角，$(x_2, y_2)$ 为右下角的子矩形中的第 $k$ 小数。
## 输出格式

对于每组询问，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
2 2
2 1
3 4
1 2 1 2 1
1 1 2 2 3

```
### 样例输出 #1
```
1
3
```
## 提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 100$，$q \leq 10^3$。
- 对于 $40\%$ 的数据，保证 $n \leq 300$，$q \leq 10^4$。
- 对于 $60\%$ 的数据，保证 $n \leq 400$，$q \leq 3 \times 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 500$，$1 \leq q \leq 6 \times 10^4$，$0 \leq a_{i, j} \leq 10^9$。


---

---
title: "[USACO05FEB] Secret Milking Machine G"
layout: "post"
diff: 省选/NOI-
pid: P1674
tag: ['2005', '二分', 'USACO', '网络流']
---
# [USACO05FEB] Secret Milking Machine G
## 题目描述

约翰正在制造一台新型的挤奶机，但他不希望别人知道。他希望尽可能久地隐藏这个秘密。他把挤奶机藏在他的农场里，使它不被发现。在挤奶机制造的过程中，他需要去挤奶机所在的地方 $T$ 次。他的农场里有秘密的地道，但约翰只在返回的时候用它。农场被划分成 $N$ 块区域，用 $1$ 到 $200$ 标号。这些区域被 $P$ 条道路连接，每条路有一个小于 $10^6$ 的长度 $L$。两块区域之间可能有多条道路连接。为了减少被发现的可能，约翰不会两次经过农场上的任何一条道路。当然了，他希望走最短的路。请帮助约翰寻找这 $T$ 次从仓库走到挤奶机所在地的路线。仓库是区域 $1$，挤奶机所在地是区域 $N$。我们现在要求的是约翰经过的这些道路中最长的路的长度最小是多少，当然他不能重复走某一条路。请注意，我们要求的不是最短的总路程长度，而是所经过的直接连接两个区域的道路中最长的道路的最小长度。数据保证约翰可以找到 $T$ 条没有重复的从仓库到挤奶机所在区域的路。
## 输入格式

第 $1$ 行是 $3$ 个整数 $N$、$P$ 和 $T$，用空格隔开。

第 $2$ 到 $P+1$ 行，每行包括 $3$ 个整数，$A_i$，$B_i$，$L_i$。表示区域 $A_i$、$B_i$ 之间有一条长度为 $L_i$ 的道路。
## 输出格式

输出只有一行，包含一个整数，即约翰经过的这些道路中最长的路的最小长度。
## 样例

### 样例输入 #1
```
7 9 2
1 2 2
2 3 5
3 7 5
1 4 1
4 3 1
4 5 7
5 7 1
1 6 3
6 7 3
```
### 样例输出 #1
```
5
```
## 提示

选择 $1-2-3-7$ 和 $1-6-7$ 两条路线．这些路线中最长路的最小长度是 $5$。

对于 $100\%$ 的数据满足：$2\le N\le 200$，$1\le P\le 4\times 10^4$，$1\le T\le 200$，每条路的长度 $\le 10^6$。


---

---
title: "点菜"
layout: "post"
diff: 省选/NOI-
pid: P1752
tag: ['贪心', '二分', '堆']
---
# 点菜
## 题目描述

有 $n$ 个人到一家餐馆点菜。这家餐馆总共有 $m$ 道菜，每一道菜都有两个属性——美味度和价格。这 $n$ 个人每周都会来一次，每次只会点一道菜或不点。在这 $n$ 个人中，有 $p$ 个人比较挑剔，他们只能接受美味度大于等于一定值的菜；有 $q$ 个人比较贫穷，他们只能点价格小于等于一定值的菜。现在请你计算：这些人至少要来几周，才可能能把餐馆的所有的菜都点过一遍？
## 输入格式

第 $1$ 行，四个正整数 $n,m,p,q$。

第 $2 \sim m+1$ 行，每行两个数，表示菜的美味度和价格。

第 $m+2$ 行 $p$ 个数，表示 $p$ 个挑剔的人分别能接受的菜的美味度的下限。

第 $m+3$ 行 $q$ 个数，表示 $q$ 个贫穷的人分别能点的菜的价格的上限。
## 输出格式

一行一个数，即这些人最少要来的周数。若不论这些人来几周都不可能把菜点过一遍，输出 $-1$。
## 样例

### 样例输入 #1
```
2 3 1 1

5 2

5 3

6 4

5

1
```
### 样例输出 #1
```
3


```
## 提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$m \le 20$；
- 对于 $40\%$ 的数据，$m \le 2000$；
- 对于 $100\%$ 的数据，$p+q \le n \le 50000,m \le 200000$。


---

---
title: "[USACO12OPEN] Bookshelf G"
layout: "post"
diff: 省选/NOI-
pid: P1848
tag: ['2012', '线段树', '二分', 'USACO', '平衡树']
---
# [USACO12OPEN] Bookshelf G
## 题目描述

When Farmer John isn't milking cows, stacking haybales, lining up his cows, or building fences, he enjoys sitting down with a good book.  Over the years, he has collected N books (1 <= N <= 100,000), and he wants to build a new set of bookshelves to hold them all.

Each book i has a width W(i) and height H(i).  The books need to be added to a set of shelves in order; for example, the first shelf should contain books 1...k for some k, the second shelf should start with book k+1, and so on.  Each shelf can have a total width of at most L (1 <= L <= 1,000,000,000).  The height of a shelf is equal to the height of the tallest book on that shelf, and the height of the entire set of bookshelves is the sum of the heights of all the individual shelves, since they are all stacked vertically.

Please help FJ compute the minimum possible height for the entire set of bookshelves.
## 输入格式

第一行：两个数 $N$ 和 $L$ 。

接下来 $N$ 行每行两个数 $H_i$ 和 $W_i$ 。
## 输出格式

一个数，书架高度的最小值。
## 样例

### 样例输入 #1
```
5 10
5 7
9 2
8 5
13 2
3 8
```
### 样例输出 #1
```
21
```
## 题目翻译

当农夫约翰闲的没事干的时候，他喜欢坐下来看书。多年过去，他已经收集了 $N$ 本书 $(1 \le N \le 100,000)$ ， 他想造一个新的书架来装所有书。

每本书 $i$ 都有宽度 $W_i$ 和高度 $H_i$ 。书需要按顺序添加到一组书架上；比如说，第一层架子应该包含书籍 $1  ... k$ ，第二层架子应该以第 $k + 1$ 本书开始，以下如此。每层架子的总宽度最大为 $L(1 \le L \le 1,000,000,000)$ 。每层的高度等于该层上最高的书的高度，并且整个书架的高度是所有层的高度的总和，因为它们都垂直堆叠。

请帮助农夫约翰计算整个书架的最小可能高度。

有 $N(1 \le N \le 100,000)$ 本书，每本书有一个宽度 $W_i$ ，高度 $H_i$ ，$(1 \le H_i \le 1,000,000; 1 \le W_i \le L)$ 。

现在有足够多的书架，书架宽度最多是 $L (1 \le L \le 1,000,000,000)$ ，把书按顺序 $($先放 $1$ ，再放 $2.....)$ 放入书架。某个书架的高度是该书架中所放的最高的书的高度。

将所有书放入书架后，求所有书架的高度和的最小值。


---

---
title: "跳跳棋"
layout: "post"
diff: 省选/NOI-
pid: P1852
tag: ['二分', '最近公共祖先 LCA', 'CTT（清华集训/北大集训）']
---
# 跳跳棋
## 题目描述

跳跳棋是在一条数轴上进行的。棋子只能摆在整点上。每个点不能摆超过一个棋子。

![](https://cdn.luogu.com.cn/upload/image_hosting/hyfzn745.png)

我们用跳跳棋来做一个简单的游戏：棋盘上有 $3$ 颗棋子，分别在 $a,b,c$ 这三个位置。我们要通过最少的跳动把他们的位置移动成 $x,y,z$。（棋子是没有区别的）

跳动的规则很简单，任意选一颗棋子，对一颗中轴棋子跳动。跳动后两颗棋子距离不变。一次只允许跳过 $1$ 颗棋子。

写一个程序，首先判断是否可以完成任务。如果可以，输出最少需要的跳动次数。
## 输入格式

第一行包含三个整数，表示当前棋子的位置 $a,b,c$。（互不相同）

第二行包含三个整数，表示目标位置 $x,y,z$。（互不相同）
## 输出格式

如果无解，输出一行 `NO`。

如果可以到达，第一行输出 `YES`，第二行输出最少步数。

## 样例

### 样例输入 #1
```
1 2 3
0 3 5
```
### 样例输出 #1
```
YES
2
```
## 提示

### 数据范围及约定

- $20\%$ 输入整数的绝对值均不超过 $10$；
- $40\%$ 输入整数的绝对值均不超过 $10000$；
- $100\%$ 绝对值不超过 $10^9$。


---

---
title: "[NOI2009] 变换序列"
layout: "post"
diff: 省选/NOI-
pid: P1963
tag: ['2009', 'NOI', '二分图']
---
# [NOI2009] 变换序列
## 题目描述

对于 $N$ 个整数 $0, 1, \cdots, N-1$，一个变换序列 $T$ 可以将 $i$ 变成 $T_i$，其中 $T_i \in \{ 0,1,\cdots, N-1\}$ 且 $\bigcup_{i=0}^{N-1} \{T_i\} = \{0,1,\cdots , N-1\}$。$\forall x,y \in  \{0,1,\cdots , N-1\}$，定义 $x$ 和 $y$ 之间的距离 $D(x,y)=\min\{|x-y|,N-|x-y|\}$。给定每个 $i$ 和 $T_i$ 之间的距离 $D(i,T_i)$，你需要求出一个满足要求的变换序列 $T$。如果有多个满足条件的序列，输出其中字典序最小的一个。

说明：对于两个变换序列 $S$ 和 $T$，如果存在 $p<N$，满足对于 $i=0,1,\cdots p-1$，$S_i=T_i$ 且 $S_p<T_p$，我们称 $S$ 比 $T$ 字典序小。
## 输入格式

第一行包含一个正整数 $N$，表示序列的长度。接下来的一行包含 $N$ 个整数 $D_i$，其中 $D_i$ 表示 $i$ 和 $T_i$ 之间的距离。
## 输出格式

如果至少存在一个满足要求的变换序列 $T$，则输出文件中包含一行 $N$ 个整数，表示你计算得到的字典序最小的 $T$；否则输出 `No Answer`（不含引号）。注意：输出文件中相邻两个数之间用一个空格分开，行末不包含多余空格。
## 样例

### 样例输入 #1
```
5
1 1 2 2 1

```
### 样例输出 #1
```
1 2 4 0 3
```
## 提示

- 对于 $30\%$ 的数据，满足：$N \le 50$；
- 对于 $60\%$ 的数据，满足：$N \le 500$；
- 对于 $100\%$ 的数据，满足：$N \le 10 ^ 4$。



---

---
title: "[HAOI2007] 覆盖问题"
layout: "post"
diff: 省选/NOI-
pid: P2218
tag: ['贪心', '2007', '河南', '二分', '各省省选', '深度优先搜索 DFS']
---
# [HAOI2007] 覆盖问题
## 题目描述

某人在山上种了 $N$ 棵小树苗。冬天来了，温度急速下降，小树苗脆弱得不堪一击，于是树主人想用一些塑料薄膜把这些小树遮盖起来，经过一番长久的思考，他决定 用 $3$ 个 $L \times L$ 的正方形塑料薄膜将小树遮起来。我们不妨将山建立一个平面直角坐标系，设第 $i$ 棵小树的坐标为 $(X_i,Y_i)$ ，$3$ 个 $L \times L$ 的正方形的边要求平行于坐标轴，一个点如果在正方形的边界上，也算作被覆盖。当然，我们希望塑料薄膜面积越小越好，即求 $L$ 最小值。
## 输入格式

接下来有 $N$ 行，第 $i+1$ 行有 $2$ 个整数 $X_i,Y_i$，表示第 $i$ 棵树的坐标，保证不会有 $2$ 个树的坐标相同。
## 输出格式

一行，输出最小的 $L$ 值。

## 样例

### 样例输入 #1
```
4

0 1

0 -1

1 0

-1 0


```
### 样例输出 #1
```
1
```
## 提示

对于 $100\%$ 的数据，$-1,000,000,000 \le X_i,Y_i \le 1,000,000,000。$

对于 $30\%$ 的数据，$N \le 100。$

对于 $50\%$ 的数据，$N \le 2000。$

对于 $100\%$ 的数据，$N \le 20000。$


---

---
title: "[SDOI2010] 粟粟的书架"
layout: "post"
diff: 省选/NOI-
pid: P2468
tag: ['2010', '二分', '各省省选', '山东', '枚举', '可持久化线段树']
---
# [SDOI2010] 粟粟的书架
## 题目描述

幸福幼儿园 B29 班的粟粟是一个聪明机灵、乖巧可爱的小朋友，她的爱好是画画和读书，尤其喜欢 Thomas H. Cormen 的文章。粟粟家中有一个 $R$ 行 $C$ 列的巨型书架，书架的每一个位置都摆有一本书，上数第 $i$ 行、左数第 $j$ 列摆放的书有 $P_{i,j}$ 页厚。

粟粟每天除了读书之外，还有一件必不可少的工作就是摘苹果，她每天必须摘取一个指定的苹果。粟粟家果树上的苹果有的高、有的低，但无论如何凭粟粟自己的个头都难以摘到。不过她发现，如果在脚下放上几本书，就可以够着苹果；她同时注意到，对于第 $i$ 天指定的那个苹果，只要她脚下放置书的总页数之和不低于 $H_i$，就一定能够摘到。

由于书架内的书过多，父母担心粟粟一天内就把所有书看完而耽误了上幼儿园，于是每天只允许粟粟在一个特定区域内拿书。这个区域是一个矩形，第 $i$ 天给定区域的左上角是上数第$x1_i$ 行的左数第 $y1_i$ 本书，右下角是上数第 $x2_i$ 行的左数第 $y2_i$ 本书。换句话说，粟粟在这一天，只能在这 $(x2_i－x1_i＋1)\times(y2_i－y1_i＋1)$ 本书中挑选若干本垫在脚下，摘取苹果。

粟粟每次取书时都能及时放回原位，并且她的书架不会再撤下书目或换上新书，摘苹果的任务会一直持续 $M$ 天。给出每本书籍的页数和每天的区域限制及采摘要求，请你告诉粟粟，她每天至少拿取多少本书，就可以摘到当天指定的苹果。

## 输入格式

第一行是三个正整数 $R, C, M$。

接下来是一个 $R$ 行 $C$ 列的矩阵，从上到下、从左向右依次给出了每本书的页数 $P_{i,j}$。

接下来 $M$ 行，第 $i$ 行给出正整数 $x1_i, y1_i, x2_i, y2_i, H_i$，表示第 $i$ 天的指定区域是 $(x1_i, y1_i)$ 与 $(x2_i, y2_i)$ 间的矩形，总页数之和要求不低于Hi。

保证 $1\le x1_i\le x2_i\le R$，$1\le y1_i\le y2_i\le C$。

## 输出格式

输出共 $M$ 行，第 $i$ 行回答粟粟在第 $i$ 天时为摘到苹果至少需要拿取多少本书。如果即使取走所有书都无法摘到苹果，则在该行输出 `Poor QLW`。

## 样例

### 样例输入 #1
```
5 5 7
14 15 9 26 53
58 9 7 9 32
38 46 26 43 38
32 7 9 50 28
8 41 9 7 17
1 2 5 3 139
3 1 5 5 399
3 3 4 5 91
4 1 4 1 33
1 3 5 4 185
3 3 4 3 23
3 1 3 3 108
```
### 样例输出 #1
```
6
15
2
Poor QLW
9
1
3
```
### 样例输入 #2
```
1 10 7
14 15 9 26 53 58 9 7 9 32
1 2 1 9 170
1 2 1 9 171
1 5 1 7 115
1 1 1 10 228
1 4 1 4 45704571
1 1 1 1 1
1 7 1 8 16
```
### 样例输出 #2
```
6
7
3
10
Poor QLW
1
2
```
## 提示

对于 $10\%$ 的数据，满足 $R, C\le10$。

对于 $20\%$ 的数据，满足 $R, C\le 40$。

对于 $50\%$ 的数据，满足 $R, C\le 200$，$M\le 2\times 10^5$。

另有 $50\%$ 的数据，满足 $R＝1$，$C\le 5\times 10^5$，$M\le 2\times 10^4$。

对于 $100\%$ 的数据，满足 $1\le P_{i,j}\le 1000$，$1\le H_i\le 2\times 10^9$。



---

---
title: "[ZJOI2010] 贪吃的老鼠"
layout: "post"
diff: 省选/NOI-
pid: P2570
tag: ['2010', '二分', '网络流', '浙江', 'Special Judge']
---
# [ZJOI2010] 贪吃的老鼠
## 题目描述

奶酪店里最近出现了 $m$ 只老鼠！它们的目标就是把生产出来的所有奶酪都吃掉。奶酪店中一天会生产 $n$ 块奶酪，其中第 $i$ 块的大小为 $p_i$，会在第 $r_i$ 秒被生产出来，并且必须在第 $d_i$ 秒之前将它吃掉。第 $j$ 只老鼠吃奶酪的速度为 $s_j$，因此如果它单独吃完第 $i$ 块奶酪所需的时间为 $p_i/s_j$。老鼠们吃奶酪的习惯很独特，具体来说：

1. 在任一时刻，一只老鼠最多可以吃一块奶酪；
2. 在任一时刻，一块奶酪最多被一只老鼠吃。

由于奶酪的保质期常常很短，为了将它们全部吃掉，老鼠们需要使用一种神奇的魔法来延长奶酪的保质期。将奶酪的保质期延长 $T$ 秒是指所有的奶酪的 $d_i$ 变成 $d_i+T$。同时，使用魔法的代价很高，因此老鼠们希望找到最小的 $T$ 使得可以吃掉所有的奶酪。
## 输入格式

输入文件的第一行包含一个整数 $K$，表示输入文件中数据的组数。

每组数据的第一行包含两个整数 $n$ 和 $m$，分别表示奶酪和老鼠的数量。接下来的 $n$ 行每行包含三个整数 $p_i,r_i,d_i$。最后 $m$ 行每行包含一个整数，表示 $s_j$。$p_i,r_i,d_i,s_j$ 的含义如上文所述。
## 输出格式

包含 $K$ 行，每行包含一个实数，表示你找到的最小的 $T$。你的答案和标准答案的绝对误差不应超过 $10^{-4}$。
## 样例

### 样例输入 #1
```
2
2 2
13 0 4
10 1 3
4
2
1 1
1 0 2
1

```
### 样例输出 #1
```
0.5
0

```
## 提示

### 样例说明

第一组数据中：

第 $0$ 到第 $1$ 秒：

第一只老鼠吃第一块奶酪；

第 $1$ 到第 $3.5$ 秒：

- 第一只老鼠吃第二块奶酪；
- 第二只老鼠吃第一块奶酪；

第 $3.5$ 到第 $4.5$ 秒：第一只老鼠吃第一块奶酪。

### 数据规模

$30\%$ 的数据中，$1 \le n,m \le 5$；

$100\%$ 的数据中，$1 \le K \le 5$，$1 \le n,m \le 30$，$1 \le p_i \le 10^5$，$0 \le r_i<d_i \le 10^7$，$1 \le s_j \le 10^5$。


---

---
title: "[ZJOI2009] 对称的正方形"
layout: "post"
diff: 省选/NOI-
pid: P2601
tag: ['2009', '二分', '各省省选', '浙江', '哈希 hashing']
---
# [ZJOI2009] 对称的正方形
## 题目描述

Orez 很喜欢搜集一些神秘的数据，并经常把它们排成一个矩阵进行研究。最近，Orez 又得到了一些数据，并已经把它们排成了一个 $n$ 行 $m$ 列的矩阵。通过观察，Orez 发现这些数据蕴涵了一个奇特的数，就是矩阵中上下对称且左右对称的正方形子矩阵的个数。Orez 自然很想知道这个数是多少，可是矩阵太大，无法去数。只能请你编个程序来计算出这个数。

## 输入格式

文件的第一行为两个整数 $n$ 和 $m$。接下来 $n$ 行每行包含 $m$ 个正整数，表示 Orez 得到的矩阵。

## 输出格式

文件中仅包含一个整数 $ans$，表示矩阵中有 $ans$ 个上下左右对称的正方形子矩阵。

## 样例

### 样例输入 #1
```
5 5

4 2 4 4 4 

3 1 4 4 3 

3 5 3 3 3 

3 1 5 3 3 

4 2 1 2 4 
```
### 样例输出 #1
```
27
```
## 提示

- 对于 $30\%$ 的数据 $1\le n,m\le 100$；
- 对于 $100\%$ 的数据 $1\le n,m\le 1000$，矩阵中的数的大小不超过 $10^9$。



---

---
title: "大海战"
layout: "post"
diff: 省选/NOI-
pid: P2688
tag: ['动态规划 DP', '二分']
---
# 大海战
## 题目背景

一天，GD和MW正在玩一款名叫大海战的游戏。

## 题目描述

游戏在一个 $1 \times n$ 的棋盘上进行。一开始 GD 拥有 $c$ 种战舰，每种战舰的宽度为 $1$，长度为 $c_i$，共有 $t_i$ 个。GD 要将所有这些战舰放置在棋盘上，并且任意两艘战舰间不能重叠（但可以相邻）。

接下来，MW 进行 $q$ 次“攻击”，每次攻击一个 $1 \times 1$ 的格子，而 MW 将告知他这次攻击是否“打中”了一艘战舰（或者它的某个部分）。

令人疑惑的是，每次 MW 都告诉 GD 说他没有打中任何一艘战舰，而这显然是不现实的。现在 MW 把整个游戏的过程告诉了你，他想知道，最早在他的第几次询问之后，可以断定 GD 一定（至少有一次）说了谎。
## 输入格式

**本题单测试点内有多组数据**。

第一行一个整数 $t$，表示测试数据的组数。    

每组数据的输入格式如下：

每组数据的第一行有三个整数，分别代表棋盘的长度 $n$ 、战舰的种数 $c$ 和攻击的次数 $q$。

对于每组数据的第 $2$ 到第 $(c + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的两个整数分别代表第 $i$ 种战舰的长度 $c_i$ 和数量 $t_i$。

第 $(c + 2)$ 行有 $q$ 个整数，第 $i$ 个整数 $a_i$ 代表 MW 第 $i$ 次攻击的位置。
## 输出格式

对于每组数据，输出一个整数 $ans$，表示最早在第 $ans$ 次操作后可以断定 GD 说了谎。特别地，如果一开始就不可能按要求摆上所有的战舰，输出 $0$；如果 $q$ 次询问后都不能判断 GD 是否说了谎，则输出 $-1$。
## 样例

### 样例输入 #1
```
3
12 2 2
1 1
2 5
6 8
5 1 2
3 1
1 5
11 3 0
2 2
3 1
5 1
```
### 样例输出 #1
```
2
-1
0
```
## 提示

#### 样例输入输出 1 解释

- 对于第一个样例，存在布阵 $\{1,22,22,0,22,22,22\}$（$0$ 表示没有放置），使得第一次不会受到攻击；不存在一个布阵使得两次都没有受到攻击。
- 对于第二个样例，存在布阵 $\{0,333,0\}$，使得两次均不会受到攻击。
- 对于第三个样例，一开始就不可能把所有战舰合法地布置在棋盘上。

---

#### 数据规模与约定

- 对于测试点1，$n \leq 1000000000$，$c \leq 100000$，$q=0$；
- 对于测试点2、3，所有的 $t_i$ 均为 $1$；
- 对于测试点2-8，$n \leq 400000$，$c \leq 100$，$q=1$；
- 对于测试点9，$n \leq 100$，$c=1$，$q \leq 100$；
- 对于测试点10-14，$n \leq 200000$，$c=1$，$q \leq 200000$；
- 对于测试点15、16，$n \leq 200$，$c=2$，$q \leq 200$；
- 对于测试点17-20，$n \leq 4000$，$c=2$，$q \leq 4000$。
- 对于 $100\%$ 的数据，$1 \le t \le 5,n \ge 1,c \ge 1,q \ge 0,1 \le q_i \le n,0 \le c_i \le 10^5,0 \le t_i \le 10^5$。

---

#### 提示

- 请注意常数因子对程序效率造成的影响。




---

---
title: "[HEOI2016/TJOI2016] 排序"
layout: "post"
diff: 省选/NOI-
pid: P2824
tag: ['2016', '线段树', '二分', '各省省选', '河北', '排序']
---
# [HEOI2016/TJOI2016] 排序
## 题目描述

在 $2016$ 年，佳媛姐姐喜欢上了数字序列。因而她经常研究关于序列的一些奇奇怪怪的问题，现在她在研究一个难题，需要你来帮助她。  

这个难题是这样子的：给出一个 $1$ 到 $n$ 的排列，现在对这个排列序列进行 $m$ 次局部排序，排序分为两种：  

- `0 l r` 表示将区间 $[l,r]$ 的数字升序排序  
- `1 l r` 表示将区间 $[l,r]$ 的数字降序排序  

注意，这里是对**下标**在区间 $[l,r]$ 内的数排序。  
最后询问第 $q$ 位置上的数字。

## 输入格式

输入数据的第一行为两个整数 $n$ 和 $m$，$n$ 表示序列的长度，$m$ 表示局部排序的次数。  

第二行为 $n$ 个整数，表示 $1$ 到 $n$ 的一个排列。  

接下来输入 $m$ 行，每一行有三个整数 $\text{op},l,r$，$\text{op}$ 为 $0$ 代表升序排序，$\text{op}$ 为 $1$ 代表降序排序, $l,r$ 表示排序的区间。  

最后输入一个整数 $q$，表示排序完之后询问的位置

## 输出格式

输出数据仅有一行，一个整数，表示按照顺序将全部的部分排序结束后第 $q$ 位置上的数字。

## 样例

### 样例输入 #1
```
6 3
1 6 2 5 3 4
0 1 4
1 3 6
0 2 4
3
```
### 样例输出 #1
```
5
```
## 提示

河北省选2016第一天第二题。

对于 $30\%$ 的数据，$n,m\leq 1000$

对于 $100\%$ 的数据，$n,m\leq 10^5$，$1\leq q\leq n$


---

---
title: "[HEOI2016/TJOI2016] 游戏"
layout: "post"
diff: 省选/NOI-
pid: P2825
tag: ['2016', '各省省选', '网络流', '河北', '连通块', '二分图', '天津']
---
# [HEOI2016/TJOI2016] 游戏
## 题目描述

在 2016 年，佳媛姐姐喜欢上了一款游戏，叫做泡泡堂。

简单的说，这个游戏就是在一张地图上放上若干个炸弹，看是否能炸到对手，或者躲开对手的炸弹。在玩游戏的过程中，小 H 想到了这样一个问题：当给定一张地图，在这张地图上最多能放上多少个炸弹能使得任意两个炸弹之间不会互相炸到。炸弹能炸到的范围是该炸弹所在的一行和一列，炸弹的威力可以穿透软石头，但是不能穿透硬石头。

给定一张 $ n \times m $ 的网格地图:其中 ``*`` 代表空地，炸弹的威力可以穿透，可以在空地上放置一枚炸弹。 ``x`` 代表软石头，炸弹的威力可以穿透，不能在此放置炸弹。``#`` 代表硬石头，炸弹的威力是不能穿透的，不能在此放置炸弹。例如：给出 $ 1 \times 4 $ 的网格地图 `` *xx*``，这个地图上最多只能放置一个炸弹。给出另一个$ 1 \times 4 $ 的网格地图 ``*x#*``，这个地图最多能放置两个炸弹。

现在小 H 任意给出一张 $ n \times m $ 的网格地图，问你最多能放置多少炸弹。
## 输入格式

第一行输入两个正整数 $ n, m $，$ n $ 表示地图的行数，$ m $ 表示地图的列数。

接下来输入 $ n $ 行 $ m $ 列个字符，代表网格地图。``*``的个数不超过 $ n \times m $ 个。
## 输出格式

输出一个整数 $ a $，表示最多能放置炸弹的个数。
## 样例

### 样例输入 #1
```
4 4
#***
*#**
**#*
xxx#
```
### 样例输出 #1
```
5
```
## 提示

$1 \leq n,m \leq 50$


---

---
title: "[国家集训队] middle"
layout: "post"
diff: 省选/NOI-
pid: P2839
tag: ['二分', '集训队互测', '可持久化线段树']
---
# [国家集训队] middle
## 题目描述

一个长度为 $n$ 的序列 $a$，设其排过序之后为 $b$，其中位数定义为 $b_{n/2}$，其中 $a,b$ 从 $0$ 开始标号，除法下取整。

给你一个长度为 $n$ 的序列 $s$。

回答 $Q$ 个这样的询问：$s$ 的左端点在 $[a,b]$ 之间，右端点在 $[c,d]$ 之间的子区间中，最大的中位数。

其中 $a<b<c<d$。

位置也从 $0$ 开始标号。

我会使用一些方式强制你在线。

## 输入格式

第一行序列长度 $n$。

接下来 $n$ 行按顺序给出 $a$ 中的数。

接下来一行 $Q$。

然后 $Q$ 行每行 $a,b,c,d$，我们令上个询问的答案是 $x$（如果这是第一个询问则 $x=0$）。

令数组 $q=\{(a+x)\bmod n,(b+x)\bmod n,(c+x)\bmod n,(d+x)\bmod n\}$。

将 $q$ 从小到大排序之后，令真正的要询问的 $a=q_0$，$b=q_1$，$c=q_2$，$d=q_3$。

输入保证满足条件。

## 输出格式

$Q$ 行依次给出询问的答案。

## 样例

### 样例输入 #1
```
5
170337785
271451044
22430280
969056313
206452321
3
3 1 0 2
2 3 1 4
3 1 4 0
```
### 样例输出 #1
```
271451044
271451044
969056313
```
## 提示

对于 $5\%$ 的数据，$n,Q \leq 100$；

对于另 $25\%$ 的数据，$n \leq 2000$；

对于 $100\%$ 的数据，$1\leq n \leq 20000$，$1\leq Q \leq 25000$，$1\leq a_i\leq 10 ^ 9$。


---

---
title: "[USACO06FEB] Steady Cow Assignment G"
layout: "post"
diff: 省选/NOI-
pid: P2857
tag: ['贪心', '2006', '二分', 'USACO', '网络流', '枚举', '双指针 two-pointer']
---
# [USACO06FEB] Steady Cow Assignment G
## 题目描述

Farmer John's N (1 <= N <= 1000) cows each reside in one of B (1 <= B <= 20) barns which, of course, have limited capacity. Some cows really like their current barn, and some are not so happy.

FJ would like to rearrange the cows such that the cows are as equally happy as possible, even if that means all the cows hate their assigned barn.


Each cow gives FJ the order in which she prefers the barns.  A cow's happiness with a particular assignment is her ranking of her barn. Your job is to find an assignment of cows to barns such that no barn's capacity is exceeded and the size of the range (i.e., one more than the positive difference between the the highest-ranked barn chosen and that lowest-ranked barn chosen) of barn rankings the cows give their assigned barns is as small as possible.

## 输入格式

Line 1: Two space-separated integers, N and B


Lines 2..N+1: Each line contains B space-separated integers which are exactly 1..B sorted into some order. The first integer on line i+1 is the number of the cow i's top-choice barn, the second integer on that line is the number of the i'th cow's second-choice barn, and so on.


Line N+2: B space-separated integers, respectively the capacity of the first barn, then the capacity of the second, and so on. The sum of these numbers is guaranteed to be at least N.

## 输出格式

Line 1: One integer, the size of the minumum range of barn rankings the cows give their assigned barns, including the endpoints.

## 样例

### 样例输入 #1
```
6 4
1 2 3 4
2 3 1 4
4 2 3 1
3 1 2 4
1 3 4 2
1 4 2 3
2 1 3 2
```
### 样例输出 #1
```
2
```
## 提示

Explanation of the sample:




Each cow can be assigned to her first or second choice: barn 1 gets cows 1 and 5, barn 2 gets cow 2, barn 3 gets cow 4, and barn 4 gets cows 3 and 6.

## 题目翻译

有 $N$ 头牛，$B$ 个牛棚。告诉你每头牛心里牛棚的座次，即哪个牛棚他最喜欢，哪个第 $2$ 喜欢，哪个第 $3$ 喜欢，等等。但牛棚容量一定，所以每头牛分配到的牛棚在该牛心中的座次有高有低。现在求一种最公平的方法分配牛到牛棚，使所有牛中，所居牛棚的座次最高与最低的跨度最小。


---

---
title: "[USACO07DEC] Sightseeing Cows G"
layout: "post"
diff: 省选/NOI-
pid: P2868
tag: ['搜索', '2007', '二分', 'USACO', '最短路', '分数规划']
---
# [USACO07DEC] Sightseeing Cows G
## 题目描述

Farmer John has decided to reward his cows for their hard work by taking them on a tour of the big city! The cows must decide how best to spend their free time.

Fortunately, they have a detailed city map showing the L (2 ≤ L ≤ 1000) major landmarks (conveniently numbered 1.. L) and the P (2 ≤ P ≤ 5000) unidirectional cow paths that join them. Farmer John will drive the cows to a starting landmark of their choice, from which they will walk along the cow paths to a series of other landmarks, ending back at their starting landmark where Farmer John will pick them up and take them back to the farm. Because space in the city is at a premium, the cow paths are very narrow and so travel along each cow path is only allowed in one fixed direction.

While the cows may spend as much time as they like in the city, they do tend to get bored easily. Visiting each new landmark is fun, but walking between them takes time. The cows know the exact fun values Fi (1 ≤ Fi ≤ 1000) for each landmark i.

The cows also know about the cowpaths. Cowpath i connects landmark L1i to L2i (in the direction L1i -> L2i ) and requires time Ti (1 ≤ Ti ≤ 1000) to traverse.

In order to have the best possible day off, the cows want to maximize the average fun value per unit time of their trip. Of course, the landmarks are only fun the first time they are visited; the cows may pass through the landmark more than once, but they do not perceive its fun value again. Furthermore, Farmer John is making the cows visit at least two landmarks, so that they get some exercise during their day off.

Help the cows find the maximum fun value per unit time that they can achieve.

## 输入格式

\* Line 1: Two space-separated integers: L and P

\* Lines 2..L+1: Line i+1 contains a single one integer: Fi

\* Lines L+2..L+P+1: Line L+i+1 describes cow path i with three space-separated integers: L1i , L2i , and Ti

## 输出格式

\* Line 1: A single number given to two decimal places (do not perform explicit rounding), the maximum possible average fun per unit time, or 0 if the cows cannot plan any trip at all in accordance with the above rules.

## 样例

### 样例输入 #1
```
5 7
30
10
10
5
10
1 2 3
2 3 2
3 4 5
3 5 2
4 5 5
5 1 3
5 2 2
```
### 样例输出 #1
```
6.00
```
## 题目翻译

给你一张 $n$ 点 $m$ 边的有向图，第 $i$ 个点点权为 $F_i$，第 $i$ 条边边权为 $T_i$。

找一个环，设环上的点组成的集合为 $S$，环的边组成的集合为 $E$，最大化 $\dfrac{\sum_{u\in S}F_u}{\sum_{e\in E}T_e}$。

数据范围：$1\leq n,F_i,T_i\leq 10^3$，$1\leq m\leq 5\times10^3$。


---

---
title: "[HNOI2007] 紧急疏散EVACUATE"
layout: "post"
diff: 省选/NOI-
pid: P3191
tag: ['搜索', '2007', '二分', '网络流', '湖南']
---
# [HNOI2007] 紧急疏散EVACUATE
## 题目描述

发生了火警，所有人员需要紧急疏散！假设每个房间是一个N M的矩形区域。每个格子如果是'.'，那么表示这是一块空地；如果是'X'，那么表示这是一面墙，如果是'D'，那么表示这是一扇门，人们可以从这儿撤出房间。已知门一定在房间的边界上，并且边界上不会有空地。最初，每块空地上都有一个人，在疏散的时候，每一秒钟每个人都可以向上下左右四个方向移动一格，当然他也可以站着不动。疏散开始后，每块空地上就没有人数限制了（也就是说每块空地可以同时站无数个人）。但是，由于门很窄，每一秒钟只能有一个人移动到门的位置，一旦移动到门的位置，就表示他已经安全撤离了。现在的问题是：如果希望所有的人安全撤离，最短需要多少时间？或者告知根本不可能。

## 输入格式

输入文件第一行是由空格隔开的一对正整数N与M，3<=N <=20，3<=M<=20，以下N行M列描述一个N M的矩阵。其中的元素可为字符'.'、'X'和'D'，且字符间无空格。

## 输出格式

只有一个整数K，表示让所有人安全撤离的最短时间，如果不可能撤离，那么输出'impossible'（不包括引号）。

## 样例

### 样例输入 #1
```
5 5
XXXXX
X...D
XX.XX
X..XX
XXDXX
```
### 样例输出 #1
```
3
```
## 提示

2015.1.12新加数据一组，鸣谢1756500824

C++语言请用scanf("%s",s)读入！



---

---
title: "[HNOI2010] 平面图判定"
layout: "post"
diff: 省选/NOI-
pid: P3209
tag: ['2010', '并查集', '湖南', '2-SAT', '二分图']
---
# [HNOI2010] 平面图判定
## 题目描述

若能将无向图 $G=(V, E)$ 画在平面上使得任意两条无重合顶点的边不相交，则称 $G$ 是平面图。判定一个图是否为平面图的问题是图论中的一个重要问题。现在假设你要判定的是一类特殊的图，图中存在一个包含所有顶点的环，即存在哈密顿回路。

## 输入格式

输入文件的第一行是一个正整数 $T$，表示数据组数 (每组数据描述一个需要判定的图)。接下来从输入文件第二行开始有 $T$ 组数据，每组数据的第一行是用空格隔开的两个正整数 $N$ 和 $M$，分别表示对应图的顶点数和边数。紧接着的 $M$ 行，每行是用空格隔开的两个正整数 $u$ 和 $v$ $\left(1\leq u,v\leq N\right)$，表示对应图的一条边 $\left(u,v\right)$, 输入的数据保证所有边仅出现一次。每组数据的最后一行是用空格隔开的 $N$ 个正整数，从左到右表示对应图中的一个哈密顿回路：$V_1,V_2,…,V_N$，即对任意 $i\not=j$ 有 $V_i\not=V_j$ 且对任意 $1\leq i\leq N-1$ 有 $\left(V_i,V_{i+1}\right)\in E$ 及 $\left(V_1,V_N\right)\in E$。输入的数据保证 $100\%$ 的数据满足 $T\leq100,3\leq N\leq200,M\leq10000$。

## 输出格式

包含 $T$ 行，若输入文件的第 $i$ 组数据所对应图是平面图，则在第 $i$ 行输出 $\text{YES}$，否则在第 $i$ 行输出 $\text{NO}$，注意均为大写字母
## 样例

### 样例输入 #1
```
2
6 9
1 4
1 5
1 6
2 4
2 5
2 6
3 4
3 5
3 6
1 4 2 5 3 6
5 5
1 2
2 3
3 4
4 5
5 1
1 2 3 4 5
```
### 样例输出 #1
```
NO
YES
```
## 提示

感谢@hibiki 对题目进行修正

感谢@@Anguei  提供latex题面


---

---
title: "[HNOI2012] 射箭"
layout: "post"
diff: 省选/NOI-
pid: P3222
tag: ['2012', '二分', '湖南', '凸包', '半平面交']
---
# [HNOI2012] 射箭
## 题目描述

沫沫最近在玩一个二维的射箭游戏，如下图 $1$ 所示，这个游戏中的 $x$ 轴在地面，第一象限中有一些竖直线段作为靶子，任意两个靶子都没有公共部分，也不会接触坐标轴。

沫沫控制一个位于 $(0,0)$ 的弓箭手，可以朝 $0$ 至 $90$ 中的任意角度（不包括 $0$ 度和 $90$ 度），以任意大小的力量射出带有穿透能力的光之箭。由于游戏中没有空气阻力，并且光之箭没有箭身，箭的轨迹会是一条标准的抛物线，被轨迹穿过的所有靶子都认为被沫沫射中了，包括那些只有端点被射中的靶子。

这个游戏有多种模式，其中沫沫最喜欢的是闯关模式。

在闯关模式中，第一关只有一个靶子，射中这个靶子即可进入第二关，这时在第一关的基础上会出现另外一个靶子，若能够一箭双雕射中这两个靶子便可进入第三关，这时会出现第三个靶子。依此类推，每过一关都会新出现一个靶子，在第 $K$ 关必须一箭射中前 $K$ 关出现的所有 $K$ 个靶子才能进入第 $K+1$ 关，否则游戏结束。

沫沫花了很多时间在这个游戏上，却最多只能玩到第七关“七星连珠”，这让她非常困惑。于是她设法获得了每一关出现的靶子的位置，想让你告诉她，最多能通过多少关？
## 输入格式

输入文件第一行是一个正整数 $N$，表示一共有 $N$ 关。

接下来有 $N$ 行，第 $i+1$ 行是用空格隔开的三个正整数 $x_i,y_{i1},y_{i2}\ (y_{i1}<y_{i2})$，表示第 $i$ 关出现的靶子的横坐标是 $x_i$，纵坐标的范围是从 $y_{i1}$ 到 $y_{i2}$。
## 输出格式

仅包含一个整数，表示最多的通关数。

## 样例

### 样例输入 #1
```
5
2  8 12
5  4 5
3  8 10
6  2 3
1  3 7
```
### 样例输出 #1
```
3
```
## 提示

![](https://cdn.luogu.com.cn/upload/image_hosting/jv279yqz.png)

### 数据范围及约定

- $30\%$ 的数据满足 $N \le 100$；
- $50\%$ 的数据满足 $N \le 5000$；
- $100\%$ 的数据满足 $N \le 100000$ 且给出的所有坐标不超过 $10^9$。


---

---
title: "[HNOI2013] 消毒"
layout: "post"
diff: 省选/NOI-
pid: P3231
tag: ['搜索', '2013', '湖南', '枚举', '二分图']
---
# [HNOI2013] 消毒
## 题目描述


最近在生物实验室工作的小 T 遇到了大麻烦。 由于实验室最近升级的缘故，他的分格实验皿是一个长方体，其尺寸为 $a\times b\times c$。为了实验的方便，它被划分为 $a\times b\times c$ 个单位立方体区域，每个单位立方体尺寸为 $1\times 1\times 1$，并用 $(i,j,k)$ 标识一个单位立方体。这个实验皿已经很久没有人用了。现在，小 T 被导师要求将其中一些单位立方体区域进行消毒操作（每个区域可以被重复消毒）。

而由于严格的实验要求，他被要求使用一种特定的 F 试剂来进行消毒。 这种 F 试剂特别奇怪，每次对尺寸为 $x\times y\times z$ 的长方体区域（它由 $x\times y\times z$ 个单位立方体组成）进行消毒时，只需要使用 $\min(x,y,z)$ 单位的 F 试剂。F 试剂的价格不菲，这可难倒了小 T。

现在请你告诉他，最少要用多少单位的 F 试剂。
## 输入格式

**本题有多组数据。**

第一行是一个正整数 $D$，表示数据组数。

接下来是 $D$ 组数据，每组数据第一行是三个正整数 $a,b,c$ 表示实验皿的尺寸。

接下来会出现 $a$ 个 $b$ 行 $c$ 列的用空格隔开的 `01` 矩阵，`0` 表示对应的单位立方体不要求消毒，`1` 表示对应的单位立方体需要消毒：如，如果第 $1$ 个 `01` 矩阵的第 $2$ 行第 $3$ 列为 `1`，则表示单位立方体 $(1,2,3)$ 需要被消毒。
## 输出格式

$D$ 行，每行一个整数，表示对应实验皿最少要用多少单位的 F 试剂。
## 样例

### 样例输入 #1
```
1
4  4 4
1  0 1 1
0  0 1 1
0  0 0 0
0  0 0 0
0  0 1 1
1  0 1 1
0  0 0 0
0  0 0 0
0  0 0 0
0  0 0 0
1  0 0 0
0  0 0 0
0  0 0 0
0  0 0 0
0  0 0 0
1  0 0 0
```
### 样例输出 #1
```
3
```
## 提示

#### 样例 1 解释
对于区域 $(1,1,3)-(2,2,4)$ 和 $(1,1,1)-(4,4,1)$ 消毒，分别花费 $2$ 个单位和 $1$ 个单位的 F 试剂。

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1\le a,b,c\le 5\times 10^3$，$abc\le 5\times 10^3$，且 $1\le D\le 3$。



---

---
title: "[SCOI2016] 妖怪"
layout: "post"
diff: 省选/NOI-
pid: P3291
tag: ['2016', '四川', '二分', '枚举', '凸包']
---
# [SCOI2016] 妖怪
## 题目描述


邱老师是妖怪爱好者，他有 $n$ 只妖怪，每只妖怪有攻击力 $\mathrm{atk}$ 和防御力 $\mathrm{dnf}$ 两种属性。邱老师立志成为妖怪大师，于是他从真新镇出发，踏上未知的旅途，见识不同的风景。

环境对妖怪的战斗力有很大影响，环境 $(a,b)$ 由 $a,b$ 两个参数定义，其中 $a,b$ 为**正实数**。在环境 $(a,b)$ 中，妖怪可以降低自己 $k\times a$ 点攻击力，提升 $k\times b$ 点防御力或者提升自己 $k\times a$ 点攻击力，降低 $k\times b$ 点防御力。其中 $k$ 为**任意实数**，但是 **$\mathrm{atk}$ 和 $\mathrm{dnf}$ 必须始终非负**。

妖怪在环境 $(a,b)$ 中的**战斗力** $\mathrm{strength}$ 定义为妖怪在该种环境中能达到的最大攻击力和最大防御力之和，即 $\mathrm{strength}(a,b)=\max(\mathrm{atk}(a,b))+\max(\mathrm{dnf}(a,b))$。

比如当前环境 $a=3,b=2$，那么攻击力为 $6$，防御力为 $2$ 的妖怪，能达到的最大攻击力为 $9$，最大防御力为 $6$。所以该妖怪在 $a=3,b=2$ 的环境下战斗力为 $15$。

因此，在不同的环境，战斗力最强的妖怪可能发生变化。

作为一名优秀的妖怪训练师，邱老师想发掘每一只妖怪的最大潜力，他想知道在**最为不利的情况下**，他的 $n$ 只妖怪能够达到的最强战斗力值。换言之，存在一组正实数 $(a,b)$ 使得 $n$ 只妖怪在该环境下最强战斗力最低，你需要输出这个最低的战斗力。
## 输入格式

第一行一个n，表示有 $n$ 只妖怪。

接下来 $n$ 行，每行两个整数 $\mathrm{atk}_i$ 和 $\mathrm{dnf}_i$，表示第 $i$ 只妖怪的攻击力和防御力。

## 输出格式

输出在最不利情况下最强妖怪的战斗力值，保留 $4$ 位小数。
## 样例

### 样例输入 #1
```
3
1 1
1 2
2 2
```
### 样例输出 #1
```
8.0000
```
## 提示


对于 $100\%$ 的数据，$1\le n\le 10^6$，$0\lt \mathrm{atk},\mathrm{dnf}\le 10^8$。

Statement fixed by Starrykiller.


---

---
title: "[SDOI2015] 星际战争"
layout: "post"
diff: 省选/NOI-
pid: P3324
tag: ['2015', '二分', '网络流', '山东', 'Special Judge']
---
# [SDOI2015] 星际战争
## 题目描述

$3333$ 年，在银河系的某星球上，X 军团和 Y 军团正在激烈地作战。

在战斗的某一阶段，Y 军团一共派遣了 $N$ 个巨型机器人进攻 X 军团的阵地，其中第 $i$ 个巨型机器人的装甲值为 $A_i$。当一个巨型机器人的装甲值减少到 $0$ 或者以下时，这个巨型机器人就被摧毁了。

X 军团有 $M$ 个激光武器，其中第 $i$ 个激光武器每秒可以削减一个巨型机器人 $B_i$ 的装甲值。激光武器的攻击是连续的。

这种激光武器非常奇怪，一个激光武器只能攻击一些特定的敌人。Y 军团看到自己的巨型机器人被 X 军团一个一个消灭，他们急需下达更多的指令。

为了这个目标，Y 军团需要知道 X 军团最少需要用多长时间才能将 Y 军团的所有巨型机器人摧毁。但是他们不会计算这个问题，因此向你求助。
## 输入格式

题面修理器
第一行，两个整数，N,M。

第二行，N个整数，A1,A2...AN。

第三行，M个整数，B1,B2...BM。

接下来的M行，每行N个整数，这些整数均为0或者1。这部分中的第i行的第j个整数为0表示第i个激光武器不可以攻击第j个巨型机器人，为1表示第i个激光武器可以攻击第j个巨型机器人。


专有名词（用,隔开）

第一行，两个整数，$N,M$。

第二行，$N$ 个整数，$A_1,A_2 \cdots A_N$。

第三行，$M$ 个整数，$B_1,B_2 \cdots B_M$。

接下来的 $M$ 行，每行 $N$ 个整数，这些整数均为 $0$ 或者 $1$。这部分中的第 $i$ 行的第 $j$ 个整数为 $0$ 表示第 $i$ 个激光武器不可以攻击第 $j$ 个巨型机器人，为 $1$ 表示第 $i$ 个激光武器可以攻击第 $j$ 个巨型机器人。

## 输出格式

一行，一个实数，表示 X 军团要摧毁 Y 军团的所有巨型机器人最少需要的时间。输出结果与标准答案的绝对误差不超过 $10^{-3}$ 即视为正确。

## 样例

### 样例输入 #1
```
2 2
3 10
4 6
0 1
1 1
```
### 样例输出 #1
```
1.300000
```
## 提示

**【样例说明1】**

战斗开始后的前 $0.5$ 秒，激光武器 $1$ 攻击 $2$ 号巨型机器人，激光武器 $2$ 攻击 $1$ 号巨型机器人。$1$ 号巨型机器人被完全摧毁，$2$ 号巨型机器人还剩余 $8$ 的装甲值；

接下来的 $0.8$ 秒，激光武器 $1$ 、 $2$ 同时攻击 $2$ 号巨型机器人。$2$ 号巨型机器人被完全摧毁。

**【数据范围】**

对于全部的数据，$1 \le N,M \le 50$，$1 \le A_i \le 10^5$，$1 \le B_i \le 1000$，输入数据保证 X 军团一定能摧毁 Y 军团的所有巨型机器人。

[spj]


---

---
title: "[ZJOI2013] K大数查询"
layout: "post"
diff: 省选/NOI-
pid: P3332
tag: ['2013', '线段树', '浙江', '树套树', '整体二分']
---
# [ZJOI2013] K大数查询
## 题目描述

你需要维护 $n$ 个可重整数集，集合的编号从 $1$ 到 $n$。  
这些集合初始都是空集，有 $m$ 个操作：  

- `1 l r c`：表示将 $c$ 加入到编号在 $[l,r]$ 内的集合中  
- `2 l r c`：表示查询编号在 $[l,r]$ 内的集合的并集中，第 $c$ 大的数是多少。  

注意可重集的并是不去除重复元素的，如 $\{1,1,4\}\cup\{5,1,4\}=\{1,1,4,5,1,4\}$。

## 输入格式

第一行两个正整数 $n,m$，表示集合个数和操作个数。  
接下来 $m$ 行，每行四个整数表示一次操作。

## 输出格式

对于每个 $2$ 操作，输出一行一个整数表示答案。

## 样例

### 样例输入 #1
```
2 5
1 1 2 1
1 1 2 2
2 1 1 2
2 1 1 1
2 1 2 3
```
### 样例输出 #1
```
1
2
1
```
## 提示

【样例说明】   
第 $1$ 次操作在 $1,2$ 号集合中分别加入了一个  $1$。    
第 $2$ 次操作在 $1,2$ 号集合中分别加入了一个 $2$。   
第 $3$ 次操作查询 $1$ 号集合中第 $2$ 大的数，答案为 $1$。  
第 $4$ 次操作查询 $1$ 号集合中第 $1$ 大的数，答案为 $2$。    
第 $5$ 次操作查询 $1,2$ 号集合的并集 $\{1,2,1,2\}$ 中第 $3$ 大的数，答案为 $1$。

【数据范围】  
$1 \le n,m \le 5\times 10^4$   
$1\le l,r \le n$   
$1$ 操作中 $|c|\le n$   
$2$ 操作中 $1\le c < 2^{63}$，第 $c$ 大的数存在

---

$\text{upd 2023.8.23}$：新增加一组 Hack 数据。


---

---
title: "[POI 2006] ZAB-Frogs"
layout: "post"
diff: 省选/NOI-
pid: P3438
tag: ['2006', '二分', '单调队列', 'POI（波兰）', '广度优先搜索 BFS']
---
# [POI 2006] ZAB-Frogs
## 题目描述

A scourge of frogs destroying all the crop has started in Byteotia. A farmer named Byteasar has decided to fight the vermin with peculiar "scarefrogs", that he has set up at certain points of his field. While moving from one place to another, every frog tries to keep as far of them as possible, i.e. maximizes the distance to the closest scarefrog.

The field that belongs to Byteasar has rectangular shape. The frogs leap in directions parallel to the field's sides and their leaps are unitary (of length 1). The scarefrogs-distance, for a given frog's route, is the minimum of all distances from all scarefrogs at all inter-leap-points of the route.

Byteasar already knows the most common starting and destination points of the frogs' routes, therefore he experiments with various deployments of the scarefrogs. He asks you for help, namely he would like you to write a programme that calculates the maximum (over all routes) scarefrogs-distance for a given deployment of scarefrogs - which we call in short the frogshold distance.

TaskWrite a programme that:

reads from the standard input the size of the field, the coordinates of the screfrogs and the source and target position of a frog,determines the frogshold distance (the maximum scarefrogs-distance a frog may achieve while still being able to reach the target point)writes the square of this number to the standard output.

给定一个网格图，其中有一些坏点，要求使起点到终点的路径上的所有点到离该点最近的坏点的最小距离距离最大，求这个最大值。

## 输入格式

The first line of the input contains two integers: $w_x$ and $w_y$ separated by a single space - the breadth and length of the field ($2 \le w_x, w_y \le 1000$). The second line of the input contains four integers: $p_x$, $p_y$, $k_x$ and $k_y$ separated by single spaces; $(p_x, p_y)$ is the initial position of the frog, $(k_x, k_y)$is the target (final) position of the frog ($1 \le p_x, k_x \le w_x$, $1 \le p_y, k_y \le w_y$). The third line of the standard input contains one integer $n$ - these are the coordinates of the ith scarefrog ($1 \le n \le w_x \cdot w_y$). No two scarefrogs occupy the same position and none of them is at the point $(p_x, p_y)$ nor $(k_x, k_y)$.

## 输出格式

In the first and only line of the standard output one integer should be written, namely the square of the frogshold distance. If the frog cannot avoid leaping directly on some scarefrog the result is 0.

## 样例

### 样例输入 #1
```
5 5
1 1 5 5
2
3 3
4 2
```
### 样例输出 #1
```
4
```


---

---
title: "[POI 2010] MOS-Bridges"
layout: "post"
diff: 省选/NOI-
pid: P3511
tag: ['2010', '二分', 'POI（波兰）', '网络流', 'Special Judge', '欧拉回路']
---
# [POI 2010] MOS-Bridges
## 题目描述

San Bytecisco is a beautifully situated coastal town.

It consists of ![](http://main.edu.pl/images/OI17/mos-en-tex.1.png) small, yet densely populated islands,  numbered from ![](http://main.edu.pl/images/OI17/mos-en-tex.2.png) to ![](http://main.edu.pl/images/OI17/mos-en-tex.3.png).

Certain islands are connected with bridges, used for (bidirectional)  road traffic.

Each pair of islands can be connected with at most one bridge.

The islands are connected in such a way that every island can be reached  from every other by using the bridges only.

Byteasar and Bytie are going for a bike trip in San Bytecisco.

The will start their ride at the island no. 1.

They intend to visit every island, while passing along every bridge once  and ending the trip where it began, i.e., the island no. 1.

Being quite seasoned riders, they expect some serious trouble from... the wind!

After all, it is very windy along the coast, and especially so on the bridges between  the islands. Obviously, depending on its speed and direction, the wind makes it  hard to cross the bridge in different extent for either direction.

For simplicity we will assume for every bridge and direction of crossing,  the opposing wind speed is constant.

Help Byteasar and Bytie to find a route as they desire that will in addition  be the least tiresome. Byteasar and Bytie agreed on the maximum opposing wind speed as  a measure of a route's tiresomeness.



## 输入格式

In the first line of the standard input there are two integers separated by a single space: $n$ and $m$ ($2 \le n \le 1000$, $1 \le m \le 2000$), denoting the number of islands and the number of bridges in San Bytecisco respectively. The islands are numbered from 1 to n, while the bridges from 1 to m. The following  lines specify the bridges. The line no.($n+1$)  contains four integers $a_i,b_i,l_i,p_i$ ($1\le l_i,p_i \le 1000$), separated by single spaces. These denote that the bridge no. $i$ connects the islands no. $a$ and $b$. The opposing wind speeds are  when one goes moves from  to , and  if one goes from $a$ to $b$.
## 输出格式

If there is no route satisfying the requirements of the daring two riders,   the first and only line of the standard output should hold the word NIE   (no in Polish).

Otherwise, the output should have two lines, specifying the least tiresome route   over San Bytecisco.

The first line should hold the maximum opposing wind speed for that route, i.e.,   the number we wish to minimize.

The second line should hold ![](http://main.edu.pl/images/OI17/mos-en-tex.28.png) integers, separated by single spaces, giving   the numbers of successive bridges one crosses on the least tiresome route.

Should there be more than one least tiresome route, your program can pick one   arbitrarily.

## 样例

### 样例输入 #1
```
4 4
1 2 2 4
2 3 3 4
3 4 4 4
4 1 5 4
```
### 样例输出 #1
```
4
4 3 2 1
```
## 提示

$2 \le n \le 1000$，$1 \le m \le 2000$，$1 \le a_i,b_i \le n$，$a_i \neq b_i$，$1 \le l_i,p_i \le 1000$

## 题目翻译

给定一个图，边有权值且正着走和逆着走有不同权值，在这个图上求一条最大边权最小的欧拉回路，从点  $1$ 出发，要求输出方案。

第一行包括两个整数  $n$ 和  $m$，分别代表点的个数和边的个数。接下来  $m$ 行每行包括  $4$ 个整数  $a,b,l,p$，分别代表边的两个端点和正着走的权值和逆着走的权值。

如果没有符合要求的路径输出 `NIE`，否则输出两行。第一行一个整数表示最小的权值，第二行  $m$ 个整数表示依次经过的边的编号。

Translated by @Schwarzkopf_Henkal 


---

---
title: "[POI 2011] Lightning Conductor"
layout: "post"
diff: 省选/NOI-
pid: P3515
tag: ['动态规划 DP', '2011', 'POI（波兰）', '凸完全单调性（wqs 二分）', '栈']
---
# [POI 2011] Lightning Conductor
## 题目描述

Progressive climate change has forced the Byteburg authorities to build a huge lightning conductor    that would protect all the buildings within the city.

These buildings form a row along a single street, and are numbered from ![](http://main.edu.pl/images/OI18/pio-en-tex.1.png) to ![](http://main.edu.pl/images/OI18/pio-en-tex.2.png).

The heights of the buildings and the lightning conductor are non-negative integers.

Byteburg's limited funds allow construction of only a single lightning conductor.

Moreover, as you would expect, the higher it will be, the more expensive.

The lightning conductor of height ![](http://main.edu.pl/images/OI18/pio-en-tex.3.png) located on the roof of the building ![](http://main.edu.pl/images/OI18/pio-en-tex.4.png) (of height ![](http://main.edu.pl/images/OI18/pio-en-tex.5.png))    protects the building ![](http://main.edu.pl/images/OI18/pio-en-tex.6.png) (of height ![](http://main.edu.pl/images/OI18/pio-en-tex.7.png)) if the following inequality holds:

![](http://main.edu.pl/images/OI18/pio-en-tex.8.png)        where ![](http://main.edu.pl/images/OI18/pio-en-tex.9.png) denotes the absolute value of the difference between ![](http://main.edu.pl/images/OI18/pio-en-tex.10.png) and ![](http://main.edu.pl/images/OI18/pio-en-tex.11.png).

Byteasar, the mayor of Byteburg, asks your help.

Write a program that, for every building ![](http://main.edu.pl/images/OI18/pio-en-tex.12.png), determines the minimum height    of a lightning conductor that would protect all the buildings if it were put    on top of the building ![](http://main.edu.pl/images/OI18/pio-en-tex.13.png).



## 输入格式

In the first line of the standard input there is a single integer    ![](http://main.edu.pl/images/OI18/pio-en-tex.14.png) (![](http://main.edu.pl/images/OI18/pio-en-tex.15.png)) that denotes the number of buildings in Byteburg.

Each of the following ![](http://main.edu.pl/images/OI18/pio-en-tex.16.png) lines holds a single integer ![](http://main.edu.pl/images/OI18/pio-en-tex.17.png) (![](http://main.edu.pl/images/OI18/pio-en-tex.18.png))    that denotes the height of the ![](http://main.edu.pl/images/OI18/pio-en-tex.19.png)-th building.

## 输出格式

Your program should print out exactly ![](http://main.edu.pl/images/OI18/pio-en-tex.20.png) lines to the standard output.

The ![](http://main.edu.pl/images/OI18/pio-en-tex.21.png)-th line should give a non-negative integer ![](http://main.edu.pl/images/OI18/pio-en-tex.22.png) denoting the minimum    height of the lightning conductor on the ![](http://main.edu.pl/images/OI18/pio-en-tex.23.png)-th building.

## 样例

### 样例输入 #1
```
6
5
3
2
4
2
4
```
### 样例输出 #1
```
2
3
5
3
5
4
```
## 题目翻译

给定一个长度为 $n$ 的序列 $\{a_n\}$，对于每个 $i\in [1,n]$ ，求出一个最小的非负整数 $p$ ，使得 $\forall j\in[1,n]$，都有 $a_j\le a_i+p-\sqrt{|i-j|}$

$1 \le n \le 5\times 10^{5}$，$0 \le a_i \le 10^{9}$ 。


---

---
title: "[POI 2011] WYK-Plot"
layout: "post"
diff: 省选/NOI-
pid: P3517
tag: ['2011', '倍增', '二分', 'POI（波兰）', 'Special Judge']
---
# [POI 2011] WYK-Plot
## 题目描述

We call any sequence of points in the plane a plot.

We intend to replace a given plot $(P_1,\cdots,P_n)$ with another that will    have at most $m$ points ($m\le n$) in such a way that it "resembles" the    original plot best.

The new plot is created as follows. The sequence of points $P_1,\cdots,P_n$ can be partitioned into $s$ ($s\le m$) contiguous subsequences:

$(P_{k_0+1},\cdots,P_{k_1}),(P_{k_1+1},\cdots,P_{k_2}),\cdots,(P_{k_{s-1}+1},\cdots,P_{k_s})$ where $0=k_0<k_1<k_2<\cdots<k_s=n$,and afterwards each subsequence $(P_{k_{i-1}+1},\cdots,P_{k_i})$, for $i=1,\cdots,s$,is replaced by a new point $Q_i$.

In that case we say that each of the points $P_{k_{i-1}+1},\cdots,P_{k_i}$ has been contracted to the point $Q_i$.

As a result a new plot, represented by the points $Q_1,\cdots,Q_s$, is created.

The measure of such plot's resemblance to the original is the maximum distance of all the points $P_1,\cdots,P_n$ to the point it has been contracted to:

$max_{i=1,\cdots,s}(max_{j=k_{i-1}+1,\cdots,k_i}(d(P_j,Q_i)))$    where $d(P_j,Q_i)$ denotes the distance between $P_j$ and $Q_i$, given by the well-known formula:

$d((x_1,y_1),(x_2,y_2))=\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}$

 ![](https://cdn.luogu.com.cn/upload/pic/6975.png) 

An exemplary plot $P_1,\cdots,P_7$ and the new plot $(Q_1,Q_2)$, where $(P_1,\cdots,P_4)$ are contracted to $Q_1$, whereas $(P_5,P_6,P_7)$ to $Q_2$.

For a given plot consisting of $n$ points, you are to find the plot that    resembles it most while having at most $m$ points,    where the partitioning into contiguous subsequences is arbitrary.

Due to limited precision of floating point operations, a result is deemed    correct if its resemblance to the given plot is larger than the optimum    resemblance by at most $0.000001$.
## 输入格式

In the first line of the standard input there are two integers $n$ and $m$,      $1\le m\le n\le 100\ 000$, separated by a single space.

Each of the following $n$ lines holds two integers, separated by a single space.

The $(i+1)$-th line gives $x_i$,$y_i$,$-1\ 000\ 000\le x_i,y_i\le 1\ 000\ 000$ denoting the coordinates $(x_i,y_i)$ of the point $P_i$.

## 输出格式

In the first line of the standard output one real number $d$ should be printed out,      the resemblance measure of the plot found to the original one.

In the second line of the standard output there should be another integer $s$, $1\le s\le m$.

Next, the following $s$ lines should specify the coordinates of the points $Q_1,\cdots,Q_s$,one point per line.

Thus the $(i+2)$-th line should give two real numbers $u_i$ and $v_i$,      separated by a single space, that denote the coordinates $(u_i,v_i)$ of the point $Q_i$.All the real numbers should be printed with at most 15 digits after the decimal point.

## 样例

### 样例输入 #1
```
7 2
2 0
0 4
4 4
4 2
8 2
11 3
14 2
```
### 样例输出 #1
```
3.00000000
2
2.00000000 1.76393202
11.00000000 1.99998199
```
## 题目翻译

### 题目描述

**译自 POI 2011 Round 1. E「[Plot](https://szkopul.edu.pl/problemset/problem/mzrTn1kzVBOAwVYn55LUeAai/site/?key=statement)」**

给定 $n$ 个点 $ \left( P_1, \ldots, P_n \right) $，将其分成不多于 $m$ 个连续的段：

$$ \left( P_{k_0 + 1}, \ldots, P_{k_1} \right), \left( P_{k_1 + 1}, \ldots, P_{k_2} \right), \ldots, \left( P_{k_{s - 1}+ 1}, \ldots, P_{k_s} \right), $$

其中 $ 0 = k_0 \lt k_1 \lt k_2 \lt \ldots \lt k_s = n $，且对于 $ i = 1, \ldots, s $，子序列 $ \left( P_{k_{i - 1}+ 1}, \ldots, P_{k_i} \right) $ 用一个新点 $Q_i$ 替代。这时我们说 $ P_{k_i - 1}, \ldots, P_{k_i} $ 这些点被「收缩」到了点 $Q_i$，从而产生一个新的点集 $ Q_1, \ldots, Q_s $。两个点集的相似度定义为 $ P_1, \ldots, P_n $ 这些点与其对应的「收缩」后的点距离的最大值：

$$ \max_{i = 1, \ldots, s} \left( \max_{j = k_{i-1}+1, \ldots, k_i}\left( d\left( P_j, Q_i \right) \right) \right) ,$$

其中 $ d\left( P_j, Q_i \right) $ 表示 $P_j$ 和 $Q_i$ 之间的距离，公式为：

$$ d \left( \left(x_1, y_1 \right), \left( x_2, y_2 \right) \right) = \sqrt{ \left( x_2 - x_1 \right)^2 + \left( y_2 - y_1 \right)^2 } $$

 ![](https://cdn.luogu.com.cn/upload/pic/6975.png) 

上图为一个将 $ (P_1, \ldots, P_7) $ 收缩为 $ ( Q_1, Q_2 ) $ 的例子，其中 $ (P_1, \ldots, P_4) $ 被收缩为 $ Q_1 $，$ (P_5, P_6, P_7) $ 被收缩为 $Q_2$.

给定 $n$ 个点组成的序列，你需要将其「收缩」为最多 $m$ 个点，使得相似度最小。原序列可以任意切割。受限于浮点数的精度限制，只要答案比最优解多出不超过 $ 0.000001$ 即算正确。

### 输入格式

第一行两个整数 $n$ 和 $m$，$ 1 \le m \le n \le 100000 $，用一个空格分开。

接下来 $n$ 行每行两个整数，用一个空格分开。第 $i+1$ 行两个整数 $x_i, y_i$（$ -1000000 \le x_i,y_i \le 1000000$），表示 $P_i$ 的坐标为 $(x_i, y_i)$.

### 输出格式

第一行一个实数 $d$，表示与原序列的相似度。

接下来一个整数 $s$，表示收缩后点集的大小。

接下来 $s$ 行表示 $Q_i, \ldots, Q_s$ 的坐标。每行两个整数 $u_i$ 和 $v_i$ 表示 $Q_i$ 的坐标 $ (u_i, v_i) $。

翻译来自于 [LibreOJ](https://loj.ac/p/2159)。


---

---
title: "[POI 2011] DYN-Dynamite"
layout: "post"
diff: 省选/NOI-
pid: P3523
tag: ['贪心', '2011', '二分', 'POI（波兰）', '树形 DP']
---
# [POI 2011] DYN-Dynamite
## 题目描述

The Byteotian Cave is composed of $n$ chambers and $n-1$ corridors that       connect them.  For every pair of chambers there is unique way to move       from one of them to another without leaving the cave.

Dynamite charges are set up in certain chambers.

A fuse is laid along every corridor.

In every chamber the fuses from the adjacent corridors meet at one point,       and are further connected to the dynamite charge if there is one in the       chamber.  It takes exactly one unit of time for the fuse between two       neighbouring chambers to burn, and the dynamite charge explodes in the       instant that fire reaches the chamber it is inside.

We would like to light the fuses in some $m$ chambers (at the joints of       fuses) in such a way that all the dynamite charges explode in the shortest       time possible since the fuses are lit.  Write a program that will determine       the minimum such time possible.

## 输入格式

The first line of the standard input holds two integers $n$ and $m$($1\le m\le n\le 300\ 000$), separated by a single space, that denote, respectively, the number of chambers in the cave and the number of chambers in which fire can be set to the fuses.

The chambers are numbered from 1 to $n$.

The next line contains $n$ integers $d_1,d_2,\cdots,d_n$ ($d_i\in \{0,1\}$), separated by single spaces.

If $d_i=1$, then there is dynamite in the $i$-th chamber, and if $d_i=0$, there is none.The following $n-1$ lines specify the corridors of the cave. Each of them holds two integers $a,b$($1\le a<b\le n$), separated by a single space, denoting that there is a corridor connecting the chambers $a$ and $b$. Every corridor appears exactly once in the description.

You may assume that in tests worth 10% of the points it holds additionally that $n\le 10$ , while in tests worth 40% of the points it holds that $n\le 1\ 000$

## 输出格式

The first and only line of the standard output should hold a single         integer, equal to the minimum time it takes from lighting the fuses         to the explosion of all the charges.

## 样例

### 样例输入 #1
```
7 2
1 0 1 1 0 1 1
1 3
2 3
3 4
4 5
5 6
5 7
```
### 样例输出 #1
```
1

```
## 题目翻译

给一棵树，树上有一些关键节点，要求你选 $m$ 个点，第 $i$ 个关键节点到这些点中每个点距离的最小值记为 $dis_i$，记这全部 $dis$ 的最大值为 $K$，现在要使 $K$ 最小，求这个 $K$。


---

---
title: "[POI 2011] MET-Meteors"
layout: "post"
diff: 省选/NOI-
pid: P3527
tag: ['2011', '二分', '树状数组', 'POI（波兰）', 'O2优化', '整体二分', '离线处理']
---
# [POI 2011] MET-Meteors
## 题目描述

Byteotian Interstellar Union (BIU) has recently discovered a new planet in a nearby galaxy.  The planet is unsuitable for colonisation due to strange  meteor showers, which on the other hand make it an exceptionally interesting  object of study.

The member states of BIU have already placed space stations close to the  planet's orbit.  The stations' goal is to take samples of the rocks flying by.

The BIU Commission has partitioned the orbit into $m$ sectors, numbered  from $1$ to $m$, where the sectors $1$ and $m$ are adjacent.  In each sector  there is a single space station, belonging to one of the $n$ member states.

Each state has declared a number of meteor samples it intends to gather before  the mission ends.  Your task is to determine, for each state, when it can  stop taking samples, based on the meter shower predictions for the years to  come.



## 输入格式

The first line of the standard input gives two integers, $n$ and $m$ ($1\le n,m\le 300\ 000$), separated by a single space, that denote,respectively, the number of BIU member states and the number of sectors    the orbit has been partitioned into.

In the second line there are $m$ integers $o_i$ ($1\le o_i\le n$),separated by single spaces, that denote the states owning stations in    successive sectors.

In the third line there are $n$ integers $p_i$ ($1\le p_i\le 10^9$),separated by single spaces, that denote the numbers of meteor samples that the successive states intend to gather.

In the fourth line there is a single integer $k$ ($1\le k\le 300\ 000$) that denotes the number of meteor showers predictions. The following $k$ lines specify the (predicted) meteor showers chronologically. The $i$-th of these lines holds three integers $l_i,r_i,a_i$ (separated by single spaces), which denote that a meteor shower is expected in sectors $l_i,l_{i+1},...,r_i$(if $l_i\le r_i$) or sectors $l_i,l_{i+1},...,m,1,...,r_i$ (if $l_i>r_i$) , which should provide each station in those sectors with $a_i$ meteor samples ($1\le a_i\le 10^9$).

## 输出格式

Your program should print $n$ lines on the standard output.

The $i$-th of them should contain a single integer $w_i$, denoting the number of shower after which the stations belonging to the $i$-th state are    expected to gather at least $p_i$ samples, or the word NIE (Polish for no) if that state is not expected to gather enough samples in the foreseeable future.

## 样例

### 样例输入 #1
```
3 5
1 3 2 1 3
10 5 7
3
4 2 4
1 3 1
3 5 2
```
### 样例输出 #1
```
3
NIE
1
```
## 题目翻译

Byteotian Interstellar Union 

有 $n​$ 个成员国。现在它发现了一颗新的星球，这颗星球的轨道被分为 $m​$ 份（第 $m​$ 份和第 $1​$ 份相邻），第 $i​$ 份上有第 $a_i​$ 个国家的太空站。

这个星球经常会下陨石雨。BIU 已经预测了接下来 $k$ 场陨石雨的情况。

BIU 的第 $i$ 个成员国希望能够收集 $p_i$ 单位的陨石样本。你的任务是判断对于每个国家，它需要在第几次陨石雨之后，才能收集足够的陨石。

#### 输入格式

第一行是两个数 $n,m$。

第二行有 $m$ 个数，第 $i$ 个数 $o_i$ 表示第 $i$ 段轨道上有第 $o_i$ 个国家的太空站。

第三行有 $n$ 个数，第 $i$ 个数 $p_i$ 表示第 $i$ 个国家希望收集的陨石数量。

第四行有一个数 $k$，表示 BIU 预测了接下来的 $k$ 场陨石雨。 接下来 $k$ 行，每行有三个数 $l_i,r_i,a_i$ ，表示第 $k$ 场陨石雨的发生地点在从 $l_i$ 顺时针到 $r_i$ 的区间中（如果 $l_i \leq r_i$，则是 $l_i, l_i + 1 
\cdots, r_i$，否则就是 $l_i, l_i + 1, 
\cdots m - 1, m, 1, 2, \cdots r_i$），向区间中的每个太空站提供 $a_i$ 单位的陨石样本。

#### 输出格式

输出 $n$ 行。第 $i$ 行的数 $w_i$ 表示第 $i$ 个国家在第 $w_i$ 波陨石雨之后能够收集到足够的陨石样本。如果到第 $k$ 波结束后仍然收集不到，输出 `NIE`。

#### 数据范围

$1\le n,m,k\le 3\cdot10^5$；

$1\le p_i,a_i\le 10^9$；


---

---
title: "[POI 2012] STU-Well"
layout: "post"
diff: 省选/NOI-
pid: P3534
tag: ['2012', '二分', 'POI（波兰）', 'Special Judge']
---
# [POI 2012] STU-Well
## 题目描述

Byteasar has set off on a journey along the Dry River, which crosses the Byteotian Desert.

Unfortunately, the Dry River has dried out, and Byteasar has run out of water.

His only hope is to dig a deep enough well in the dried river bed.

Realising the graveness of his situation, Byteasar decides to plan everything carefully before he actually starts digging.

The danger is that he drains his strength before he reaches the water level - in such case he is unlikely to survive.

He managed to determine the depth of the water level.  He also knows how much he can dig before losing strength.

His only worry is a possible landslide, which might bury him alive.

He sends you (via a satellite telephone) a topographic map of the river bed.

And, of course, he asks you to help him determine where he should dig so that he reaches water before draining his strength    while keeping the slope of his excavation as gentle as possible.

He is waiting for your advice!


## 输入格式

In the first line of the standard input two positive integers are given, $n$ and $m$ ($1\le n\le 1\ 000\ 000$, $1\le m\le 10^{18}$), separated by a single space.

The second line holds $n$ positive integers $x_1,x_2,\cdots,x_n$ ($1\le x_i\le 10^9$), also separated by single spaces.

Byteasar has enough energy to perform $m$ swings of the shovel.

The numbers $x_1,x_2,\cdots,x_n$ describe the topography of the Dry River's bed.

They represent the depth of the sand layer above the ground water level in successive one meter spaced spots along the river bed.

With a single swing of the shovel Byteasar can extract an amount of the sand that decreases any of the numbers $x_i$ by 1.If any of these numbers, say $x_k$, drops to 0, this means that Byteasar has dug down to the water. But Byteasar has a secondary goal as well. He wants the following number $z$, characterising the slope of the sand hill, minimised:

$z=max_{i=1,2,\cdots,n-1}|x_i-x_{i+1}|$
If there are multiple correct values of the number $k$,representing the spot where Byteasar is to dig down to reach the water, your program can pick one arbitrarily. The spots $1,2,\cdots,n$ are the only ones suitable for digging - elsewhere there is rock rather than sand. You may assume that Byteasar has enough energy to reach water at one of the spots.

## 输出格式

Your program should print two integers to the standard output, separated by a single space:

the spot $k$, where Byteasar should dig for water, and the minimum value of the number $z$.

## 样例

### 样例输入 #1
```
16 15
8 7 6 5 5 5 5 5 6 6 7 8 9 7 5 5
```
### 样例输出 #1
```
1 2
```
## 题目翻译

给定一个非负整数序列 $A$，每次操作可以选择一个数然后减掉 $1$，要求进行不超过 $m$ 次操作使得存在一个 $A_k=0$ 且 $\max(|x_i-x_{i-1}|)$ 最小，输出使其最小的 $k$ 与这个最小值。如果有多组解，可以输出任意一组。

checker 来自 [LibreOJ](https://loj.ac/p/2692)。


---

---
title: "[POI 2013] INS-Inspector"
layout: "post"
diff: 省选/NOI-
pid: P3553
tag: ['贪心', '2013', '二分', 'POI（波兰）', '构造']
---
# [POI 2013] INS-Inspector
## 题目描述

Inspector Byteasar is investigating a crime that took place on the premises of a software development company.

He is trying to establish the chain of events.

Unfortunately, the programmers are rather scatterbrained.

Statements of the kind "Well, when I checked at 14:42,    there were five other programmers logged in on the server."    are the most informative of those that Byteasar could get.

It is known that every programmer came to office at some point    during that day, spent some time in there without going out,    and then left for good, never coming back on the same day.

Byteasar, confused by the programmers' statements, is not sure    if he should rely on them.  In fact, he is wondering whether it is at all    possible that they all tell the truth.  He asks you for help in finding    that out.

一天公司有n个员工和m个员工记录，每个员工只会在连续的一段时间内工作。现在给出m条记录分别是谁写的、什么时候写的以及写的时候除了他还有多少人。求最大的k使得前k条记录互不矛盾

## 输入格式

In the first line of the standard input, there is an integer $z$($1\le z\le 50$),      the number of data sets.

The lines that follow contain the $z$ data sets.

The first line of each data set holds two integers, $n$ and $m$,separated by a single space ($1\le n,m\le 100\ 000$).

These are the number of programmers working in the office and the      number of statements recorded by Byteasar.

The programmers are numbered from 1 to $n$.

Each of the $m$ lines that follow describes a single statement.

Each such line contains three integers $t$,$j$ and $i$, separated by single spaces ($1\le t\le m$,$1\le j\le n$,$0\le i\le n$). These indicate that the programmer no. $j$ confessed that at time $t$ he was in the office and there were $i$ more programmers apart from him.We assume that the programmers came in to the office and left it at times different from those appearing in the statements, i.e., either before, after or in between them.

## 输出格式

For each data set, your program should print a single positive integer      to the standard output.

Printing out the number $k$ ($1\le k\le m$) indicates that the first $k$ statements given on the input can be true but the first $k+1$ statements cannot.  In particular, if $k=m$, then all the statements given as input can be true.

## 样例

### 样例输入 #1
```
2
3 5
1 1 1
1 2 1
2 3 1
4 1 1
4 2 1
3 3
3 3 0
2 2 0
1 1 0

```
### 样例输出 #1
```
4
3

```
## 提示

一天公司有n个员工和m个员工记录，每个员工只会在连续的一段时间内工作。现在给出m条记录分别是谁写的、什么时候写的以及写的时候除了他还有多少人。求最大的k使得前k条记录互不矛盾



---

---
title: "[POI 2013] LUK-Triumphal arch"
layout: "post"
diff: 省选/NOI-
pid: P3554
tag: ['动态规划 DP', '2013', '二分', 'POI（波兰）', '树形 DP']
---
# [POI 2013] LUK-Triumphal arch
## 题目描述

The king of Byteotia, Byteasar, is returning to his country after a victorious battle.

In Byteotia, there are ![](http://main.edu.pl/images/OI20/luk-en-tex.1.png) towns connected with only ![](http://main.edu.pl/images/OI20/luk-en-tex.2.png) roads.

It is known that every town can be reached from every other town by a unique route,    consisting of one or more (direct) roads.

    (In other words, the road network forms a tree).

The king has just entered the capital.

Therein a triumphal arch, i.e., a gate a victorious king rides through, has been erected.

Byteasar, delighted by a warm welcome by his subjects, has planned a    triumphal procession to visit all the towns of Byteotia, starting with the capital he is currently in.

The other towns are not ready to greet their king just yet -    the constructions of the triumphal arches in those towns did not even begin!

But Byteasar's trusted advisor is seeing to the issue.

    He desires to hire a number of construction crews.

    Every crew can construct a single arch each day, in any town.

    Unfortunately, no one knows the order in which the king will visit the towns.

The only thing that is clear is that every day the king will travel from the city he is currently in to a neighboring one.

The king may visit any town an arbitrary number of times    (but as he is not vain, one arch in each town will suffice).

Byteasar's advisor has to pay each crew the same flat fee, regardless of how many arches this crew builds.

Thus, while he needs to ensure that every town has an arch when it is visited by the king, he wants to hire as few crews as possible.

Help him out by writing a program that will determine the minimum number    of crews that allow a timely delivery of the arches.


给一颗 $n$ 个节点的树（$n \le 3 \times 10^5$），初始时 $1$ 号节点被染黑，其余是白的。两个人轮流操作，一开始 B 在 $1$ 号节点。每一轮，A 选择 $k$ 个点染黑，然后 B 走到一个相邻节点，如果 B 当前处于白点则 B 胜，否则当 A 将所有点染为黑点时 A 胜。求能让 A 获胜的最小的 $k$ 。

## 输入格式

The first line of the standard input contains a single integer ![](http://main.edu.pl/images/OI20/luk-en-tex.3.png)    (![](http://main.edu.pl/images/OI20/luk-en-tex.4.png)), the number of towns in Byteotia.

The towns are numbered from 1 to ![](http://main.edu.pl/images/OI20/luk-en-tex.5.png), where the number 1 corresponds to the capital.

The road network is described in ![](http://main.edu.pl/images/OI20/luk-en-tex.6.png) lines that then follow.

Each of those lines contains two integers, ![](http://main.edu.pl/images/OI20/luk-en-tex.7.png)    (![](http://main.edu.pl/images/OI20/luk-en-tex.8.png)), separated by a single space,    indicating that towns ![](http://main.edu.pl/images/OI20/luk-en-tex.9.png) and ![](http://main.edu.pl/images/OI20/luk-en-tex.10.png) are directly connected with a two way road.

In tests worth 50% of the total points, an additional condition ![](http://main.edu.pl/images/OI20/luk-en-tex.11.png) holds.

## 输出格式

The first and only line of the standard output is to hold a single integer,    the minimum number of crews that Byteasar's advisor needs to hire.

## 样例

### 样例输入 #1
```
7
1 2
1 3
2 5
2 6
7 2
4 1

```
### 样例输出 #1
```
3

```
## 提示

给一颗树，1号节点已经被染黑，其余是白的，两个人轮流操作，一开始B在1号节点，A选择k个点染黑，然后B走一步，如果B能走到A没染的节点则B胜，否则当A染完全部的点时，A胜。求能让A获胜的最小的k


---

---
title: "[POI 2014] BAR-Salad Bar"
layout: "post"
diff: 省选/NOI-
pid: P3564
tag: ['2014', '二分', '单调队列', 'POI（波兰）']
---
# [POI 2014] BAR-Salad Bar
## 题目描述

Bytea went to a salad bar.

There are $n$ fruits one next to another on the bar counter.

Specifically, these are apples and oranges.

Bytea can pick any contiguous part of the line of fruits for her salad.

The fruits she chooses will be added to the salad either from left to right or from right to left.

As Bytea loves oranges, she requires that throughout the salad making process, the number of oranges    in it should always be no smaller than the number of apples, regardless of whether these are added %    from left to right or from right to left.

Help Bytea out by writing a program that will find the longest contiguous part of the line of fruits    that satisfies her requirements.

有一个长度为n的字符串，每一位只会是p或j。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的p的个数不小于j的个数。

## 输入格式

The first line of the standard input contains a single integer $n$ ($1\le n\le 1\ 000\ 000$), denoting the number of fruits.

The next line contains a string of $n$ characters $a_1,a_2,\cdots,a_n$ ($a_i\in \{j,p\}$).

These stand for Polish names of apples and oranges: jab\l{ka} and pomara\'ncze).

Consequently, if $a_i=j$, then the $i$-th fruit in a line is an apple,      and otherwise it is an orange.

## 输出格式

The first and only line of the standard output should contain a single integer equal to the number of fruits in the longest contiguous part of the line that satisfies Bytea's requirements.

Note that it could be the case that $0$ is the correct result.

## 样例

### 样例输入 #1
```
6
jpjppj

```
### 样例输出 #1
```
4

```
## 提示

有一个长度为n的字符串，每一位只会是p或j。求一个最长子串，使得不管是从左往右还是从右往左取，都保证每时每刻已取出的p的个数不小于j的个数。



---

---
title: "[POI 2014] MRO-Ant colony"
layout: "post"
diff: 省选/NOI-
pid: P3576
tag: ['动态规划 DP', '2014', '二分', 'POI（波兰）', '树形 DP']
---
# [POI 2014] MRO-Ant colony
## 题目背景

[English Edition](/paste/44plylwf)
## 题目描述

正在寻找食物的蚂蚁们来到了一座山。

这座山有 $n$ 个洞穴，并有 $n-1$ 条道路连接这些洞穴。也就是说，所有的洞穴和道路组成了一个树形结构。

对于每个只有一条道路连接的洞穴，都有一个出入口使得该洞穴与外界相连。

在**每个出入口**处，都有 $g$ 群蚂蚁，第 $i$ 群蚂蚁的大小为 $m_i$。

蚂蚁群会一个接一个地进入山中，当且仅当山中没有蚂蚁，下一群蚂蚁才会进入。

进入山后，蚂蚁们会按如下方式行动：

- 如果蚂蚁们进入了一个洞穴，该洞穴有 $d$ 条道路与之相连（不包括它们进入该洞穴经过的道路），则蚂蚁们会分为大小相等的 $d$ 个蚁群，每个蚁群各选择一条道路，使得一个道路恰好有一条蚁群经过，特别地，如果 $d=0$（即蚁群到达了出口），蚂蚁们会从该出口离开山。
- 根据上文，假如这个蚁群有 $x$ 只蚂蚁，则每个蚁群会有 $\left \lfloor \dfrac{x}{d} \right \rfloor$ 只蚂蚁，多余的蚂蚁将会消失（至于怎么消失，这并不重要 :)）。

下面这张图就是一个例子：大小为 $m$ 的蚁群到达了一个洞穴，该洞穴有 $3$ 条道路（除了它们进入该洞穴时经过的道路），则该蚁群分割成了三个大小为 $\left \lfloor \dfrac{m}{3} \right \rfloor$ 的蚁群。

![](https://cdn.luogu.com.cn/upload/pic/6972.png)

在其中一条道路上，有一只食蚁兽，当经过该道路的蚁群大小恰好为 $k$ 时，它会把这个蚁群的蚂蚁全部吃掉。

现在请你求出食蚁兽一共吃掉多少只蚂蚁。
## 输入格式

第一行三个整数 $n, g, k$。

之后一行 $g$ 个整数，分别为 $m_1, m_2,\dots, m_g$。

之后 $n-1$ 行，每行两个整数 $a, b$，表示在 $a, b$ 之间有一条边。

输入的第一条边是食蚁兽所在的边。
## 输出格式

输出一行一个整数， 表示所有被吃掉的蚁群的大小之和。
## 样例

### 样例输入 #1
```
7 5 3
3 4 1 9 11
1 2
1 4
4 3
4 5
4 6
6 7

```
### 样例输出 #1
```
21

```
## 提示

对于 $100\%$ 的数据，$2\le n,g\le10^6$，$1\le k,m_i\le10^9$，$1\le a_i,b_i\le n$。


---

---
title: "[POI 2014] ZAL-Freight"
layout: "post"
diff: 省选/NOI-
pid: P3580
tag: ['动态规划 DP', '2014', '二分', '树状数组', 'POI（波兰）']
---
# [POI 2014] ZAL-Freight
## 题目描述

The train stations in Upper Bytown and Lower Bytown are connected with a single track rail link.

It takes the train $s$ minutes to travel between them in either direction.

However, the trains departing a station have to be spaced at least one minute apart.

Moreover, at all times, all the trains on the rail link have to go in the same direction.

According to the timetable at our disposal, $n$ cargo trains destined for Lower Bytown are to pass  through the Upper Bytown.  They are to be loaded with goods in Lower Bytown and then return to  Upper Bytown.  For simplicity, we assume that loading the goods on the train takes virtually no time.

We are to determine the minimum possible time of the last train returning to Upper Bytown.

有两个城镇，从A到B需要的时间为S，然后有N辆列车需要从A到B再回来，任何时刻铁路上只能有向着同一个方向前进的列车，然后每辆列车有一个从A出发的最早出站时间，问所有列车全部回到A站的最早时间

## 输入格式

The first line of the standard input contains two integers $n$, $s$($1\le n\le 1\ 000\ 000$, $1\le s\le 10^9$),    separated by a single space, that specify the number of trains and the one-way travel time respectively.

The second line contains $n$ integers $t_1,t_2,\cdots,t_n$ ($0\le t_1\le t_2\le\cdots\le t_n\le 10^9$),separated by a single space, that specify the arrival times of successive trains at the Upper Bytown station.

## 输出格式

Your program should print out a single line with a single integer to the standard output:

the minimum possible time of the last train returning to Upper Bytown.

## 样例

### 样例输入 #1
```
3 4
1 8 11

```
### 样例输出 #1
```
20

```
## 提示



## 题目翻译

Upper Bytown和Lower Bytown的火车站通过一条轨道铁路连接。

沿任何一个方向在它们之间行驶都需要s分钟。

但是，离开车站的火车必须至少间隔一分钟。

而且，在任何时候，铁路上的所有列车都必须朝同一方向行驶。

根据我们的时间表，前往下拜镇的n列货运列车将通过上拜镇。 他们将在下拜敦装载货物，然后返回上拜敦。 为简单起见，我们假设将货物装载到火车上几乎不需要时间。

我们将确定最后一班火车返回Upper Bytown的最短时间。

**两个车站发车都必须至少间隔一分钟。**


---

---
title: "[SDOI2017] 新生舞会"
layout: "post"
diff: 省选/NOI-
pid: P3705
tag: ['2017', '二分', '各省省选', '山东', 'O2优化', '分数规划', '费用流']
---
# [SDOI2017] 新生舞会
## 题目描述

学校组织了一次新生舞会，Cathy 作为经验丰富的老学姐，负责为同学们安排舞伴。


有 $n$ 个男生和 $n$ 个女生参加舞会，一个男生和一个女生一起跳舞，互为舞伴。


Cathy 收集了这些同学之间的关系，比如两个人之前认识没，计算得出 $a_{i,j}$。

Cathy 还需要考虑两个人一起跳舞是否方便，比如身高体重差别会不会太大，计算得出 $b_{i,j}$，表示第 $i$ 个男生和第 $j$ 个女生一起跳舞时的不协调程度。


当然，还需要考虑很多其他问题。


Cathy 想先用一个程序通过 $a_{i,j}$ 和 $b_{i,j}$ 求出一种方案，再手动对方案进行微调。

Cathy 找到你，希望你帮她写那个程序。


一个方案中有 n 对舞伴，假设每对舞伴的喜悦程度分别是 $a'_1,a'_2,...,a'_n$，假设每对舞伴的不协调程度分别是 $b'_1,b'_2,...,b'_n$。令

$C=\frac {a'_1+a'_2+...+a'_n}{b'_1+b'_2+...+b'_n}$

Cathy 希望 $C$ 值最大。

## 输入格式

第一行一个整数 $n$。


接下来 $n$ 行，每行 $n$ 个整数，第 $i$ 行第 $j$ 个数表示 $a_{i,j}$。


接下来 $n$ 行，每行 $n$ 个整数，第 $i$ 行第 $j$ 个数表示 $b_{i,j}$。

## 输出格式

一行一个数，表示 $C$ 的最大值。四舍五入保留 $6$ 位小数，选手输出的小数需要与标准输出相等。

## 样例

### 样例输入 #1
```
3
19 17 16
25 24 23
35 36 31
9 5 6
3 4 2
7 8 9
```
### 样例输出 #1
```
5.357143
```
## 提示

对于 10% 的数据，$1\le n\le 5$

对于 40% 的数据，$1\le n\le 18$

另有 20% 的数据，$b_{i,j}\le 1$

对于 100% 的数据，$1\le n\le 100,1\le a_{i,j},b_{i,j}\le10^4$



---

---
title: "[HAOI2017] 新型城市化"
layout: "post"
diff: 省选/NOI-
pid: P3731
tag: ['2017', '河南', '各省省选', '强连通分量', '二分图']
---
# [HAOI2017] 新型城市化
## 题目描述

Anihc 国有 $n$ 座城市。城市之间存在一些贸易合作关系，如果城市 $x$ 与城市 $y$ 之间存在贸易协定，那么城市 $x$ 和城市 $y$ 则是一对贸易伙伴（注意： $(x,y)$ 和 $(y,x)$ 是同一对城市）。

为了实现新型城市化，实现统筹城乡一体化以及发挥城市群辐射与带动作用，国家决定规划新型城市关系。一些城市能够被称为城市群的条件是：这些城市两两都是贸易伙伴。由于Anihc 国之前也一直很重视城市关系建设，所以可以保证在目前已存在的贸易合作关系的情况下 Anihc 的 $n$ 座城市可以恰好被划分为不超过两个城市群。

为了建设新型城市关系 Anihc 国想要选出两个之前并不是贸易伙伴的城市，使这两个城市成为贸易伙伴，并且要求在这两个城市成为贸易伙伴之后，最大城市群的大小至少比他们成为贸易伙伴之前的最大城市群的大小增加 $1$。

Anihc 国需要在下一次会议上讨论扩大建设新型城市关系的问题，所以要请你求出在哪些城市之间建立贸易伙伴关系可以使得这个条件成立，即建立此关系前后的最大城市群的大小至少相差 $1$。
## 输入格式

第一行 $2$ 个整数 $n,m$，表示城市的个数，目前还没有建立贸易伙伴关系的城市的对数。

接下来 $m$ 行，每行 $2$ 个整数 $x,y$ 表示城市 $x,y$ 之间目前还没有建立贸易伙伴关系。
## 输出格式

第一行 $1$ 个整数 $\text{ans}$，表示符合条件的城市的对数。

接下来 $\text{ans}$ 行，每行两个整数，表示一对可以选择来建立贸易伙伴关系的城市。对于一对城市 $x,y$，请先输出编号更小的那一个。最后城市对与城市对之间顺序请按照字典序从小到大输出。
## 样例

### 样例输入 #1
```
5 3
1 5
2 4
2 5
```
### 样例输出 #1
```
2
1 5
2 4
```
## 提示

数据点 $1$：$n\le 16$；

数据点 $2$：$n\le 16$；

数据点 $3\sim 5$：$n\le 100$；

数据点 $6$：$n\le 500$；

数据点 $7\sim10$：$n\le 10^4$。

对于所有的数据保证： $n \le 10^4,0 \le m \le \min(1.5\times 10^5,\dfrac{n(n-1)}{2})$。保证输入的城市关系中不会出现 $(x,x)$ 这样的关系，同一对城市也不会出现两次（无重边，无自环）。


---

---
title: "【模板】三维偏序（陌上花开）"
layout: "post"
diff: 省选/NOI-
pid: P3810
tag: ['树状数组', 'cdq 分治', 'O2优化', '分治', '排序', '整体二分', 'K-D Tree']
---
# 【模板】三维偏序（陌上花开）
## 题目背景

这是一道模板题，可以使用 bitset，CDQ 分治，KD-Tree 等方式解决。
## 题目描述

有 $ n $ 个元素，第 $ i $ 个元素有 $ a_i,b_i,c_i $ 三个属性，设 $ f(i) $ 表示满足 $ a_j \leq a_i $ 且 $ b_j \leq b_i $ 且 $ c_j \leq c_i $ 且 $ j \ne i $ 的 $j$ 的数量。

对于 $ d \in [0, n) $，求 $ f(i) = d $ 的数量。
## 输入格式

第一行两个整数 $ n,k $，表示元素数量和最大属性值。

接下来 $ n $ 行，每行三个整数 $ a_i ,b_i,c_i $，分别表示三个属性值。
## 输出格式

$ n $ 行，第 $ d + 1 $ 行表示 $ f(i) = d $ 的 $ i $ 的数量。
## 样例

### 样例输入 #1
```
10 3
3 3 3
2 3 3
2 3 1
3 1 1
3 1 2
1 3 1
1 1 2
1 2 2
1 3 2
1 2 1

```
### 样例输出 #1
```
3
1
3
0
1
0
1
0
0
1

```
## 提示

$ 1 \leq n \leq 10^5$，$1 \leq a_i, b_i, c_i \le k \leq 2 \times 10^5 $。



---

---
title: "[IOI 2017] The Big Prize"
layout: "post"
diff: 省选/NOI-
pid: P3839
tag: ['2017', '线段树', '二分', 'IOI', '交互题', 'Special Judge', '分块']
---
# [IOI 2017] The Big Prize
## 题目背景

这里是洛谷。如果有疑问，可以发帖求助。

如果你习惯于写函数式交互，以下内容可能对你有帮助：

```cpp
vector<int>ask(int i)
{
	printf("? %d\n",i);fflush(stdout);
	vector<int>ret(2);
	scanf("%d%d",&ret[0],&ret[1]);
	return ret;
}
int find_best(int n)
{
	//
}
main()
{
	int n;scanf("%d",&n);
	printf("! %d\n",find_best(n));
}
```

无论如何，你都不应引入额外的头文件。
## 题目描述

“大奖”是一个家喻户晓的 TV 游戏节目。这次你很幸运地进入到最后一轮。已知编号从 $0$ 到 $n-1$ 的 $n$ 个盒子从左到右排成一行，你就站在这排盒子的前面。每个盒子里面放有一个奖品，必须打开盒子才能看到是什么奖品。已知有 $v\leq5$ 种不同类型的奖品。这 $v$ 种类型按照奖品价值的降序从 $1$ 到 $v$ 排列。

类型 $1$ 的奖品是一块钻石，价值最高。所有盒子加起来刚好只有一块钻石。类型 $v$ 的奖品是一块棒棒糖，价值最低。为使得游戏更加激动人心，相对便宜的奖品数量远比价值昂贵的奖品数量要多。更具体一点，对于满足 $2\leq t \leq v$ 的所有 $t$，我们有： 如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。

你的目标是赢得那块钻石。在游戏结束时，你必须打开一个盒子并收取盒子内的奖品。在选择要打开的盒子之前，你可以向节目主持人 Rambod 提一些问题。在每一个问题中，你选择就某个 $i$ 号盒子进行提问。Rambod 将给你一个包含两个整数的数组 $a$ 作为回答。这两个整数的意义如下：

- 在 $i$ 号盒子左面的盒子中，刚好有 $a[0]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。
- 在 $i$ 号盒子右面的盒子中，刚好有 $a[1]$ 个盒子中的奖品，价值比 $i$ 号盒子中的奖品价值要高。

例如，假设 $n=8$，在你的问题中，你选择就 $i=2$ 号盒子进行提问。Rambod 的回答是 $a=[1,2]$。这个回答的意义是：

- $0$ 号盒子和 $1$ 号盒子中恰好有一个盒子中的奖品比 $i$ 号盒子中的奖品更贵。
- 在 $3,4,\cdots,7$ 号盒子中恰好有 $2$ 个盒子中的奖品比 $2$ 号盒子中的奖品更贵。

你的任务就是通过问少量的问题找出包含钻石的盒子。
## 输入格式

你的程序开始运行时，应当读入一个正整数 $n$。

你可以按以下格式发起询问：

- `? i`  
	意为你选择就 $i$ 号盒子进行提问。你需要保证 $0\leq i<n$。  
	随后你应当读入两个整数 `a[0] a[1]`，是交互库对你的回答。

你可以按以下格式报告答案：

- `! i`  
	意为你确定 $i$ 号盒子内有钻石。  
    随后你应当立刻结束你的程序。
## 输出格式

在发起询问后，不要忘记刷新缓冲区。你可以使用：

- `fflush(stdout)` or `cout.flush()` in C++;
- `stdout.flush()` in Python;  
- 对于其他语言，参阅其文档。
## 样例

### 样例输入 #1
```
8

0 3

0 1

1 2

0 0

2 1

2 1

1 0

3 0
```
### 样例输出 #1
```

? 0

? 1

? 2

? 3

? 4

? 5

? 6

? 7

! 3
```
## 提示

### 样例解释

```plain
8
3 2 3 1 3 3 2 3
```

![](https://cdn.luogu.com.cn/upload/pic/6728.png)

上图阐释了这个例子。图中上半部分给出了每个盒子中奖品的类型。图中的下半部分阐释了询问 `? 2`。

### 限制

- $3\leq n \leq200000$.
- 每个盒子中奖品的类型介于 $1$ 和 $v$ 之间（含）。
- 类型 $1$ 的奖品恰有一个。
- 对于所有 $2\leq t \leq v$，如果类型 $t-1$ 的奖品有 $k$ 个，那么类型 $t$ 的奖品将严格多于 $k^2$ 个。


### 子任务与评分

1.  （$20$ 分）恰好有 $1$ 个钻石和 $n-1$ 个棒棒糖 （所以，$v=2$）。你可以询问最多 $10000$ 次。
2.  （$80$ 分）没有附加限制。


在子任务 2 中你可以获得部分分。令 $q$ 是在这个子任务的所有测试数据上发起询问的最大次数，那么你在这个子任务上的得分将按照下表计算：

![](https://cdn.luogu.com.cn/upload/pic/6729.png)


---

---
title: "[JLOI2008] 将军"
layout: "post"
diff: 省选/NOI-
pid: P3882
tag: ['2008', '各省省选', '吉林', '图论建模', '二分图']
---
# [JLOI2008] 将军
## 题目描述

刘先生最近在学习国际象棋，使用一个叫 jloi-08 的游戏软件。在这个游戏里，不但可以和电脑普通地对弈，还可以学习著名的棋局，还有针对初学者的规则指导等丰富功能。但是…大小却要 1.4G T\_T。

言归正传，在这个软件里，为了让玩家更好地理解和运用各个棋子，有很多趣味的游戏，比如以下就是一个：

给出一个棋盘和一些棋子，让你把这些棋子摆放在棋盘上，使得两两不互相攻击。你的得分由你摆放上去的棋子的个数与种类有关。

这个游戏很复杂，刘先生老是玩不到高分。于是电脑便降低了难度，替刘先生摆上了一些棋子，最后只给你任意多个 bishop（教主）。

现在刘先生便要考一考你，在电脑给出的这张棋盘上，最多能放几个 bishop。

国际象棋中一共有 6 种棋子：

- king（国王）；
- queen（皇后）；
- bishop（教主）；
- knight（骑士）；
- rook（车）；
- pawn（步兵）。

各棋子的攻击范围如下：

- queen 可以攻击与它在同一行，同一列，同一条对角线的棋子；
- knight 的攻击范围如下图所示：

![](https://cdn.luogu.com.cn/upload/pic/2669.png)

- rook 攻击水平和垂直两条线上的所有格子；
- pawn 攻击前方两条斜线方向各一格(“前方”指 $x$ 递增的方向，$x$ 行 $y$ 列）；
- king 攻击周围 8 个方向各 1 格；
- bishop 攻击两条对角线上的所有格子。

除 knight 以外，所有棋子的攻击范围均会被别的棋子所阻挡。

可惜的是这个软件也不是顶优秀，给出的棋盘上的棋子可能互相会攻击，不过你不用理会这些，你只要保证你摆放的 bishop 不与它们以及不互相攻击就可以了。
## 输入格式

第一行是两个整数 $x,y$（$1 \leq x,y \leq 1024$）。

下面的 $x$ 行每行 $y$ 个字符表示棋盘。

其中：`K` – king，`Q` – queen，`B` – bishop，`N` – knight，`R` – rook，`P` – pawn，`.` – blank.
## 输出格式

仅一行一个数，表示最多能够摆放的 bishop 的个数。

## 样例

### 样例输入 #1
```
3 3
..N
...
...

```
### 样例输出 #1
```
2
```
## 提示

```plain
BBN
...
...
```

```plain
BBN
...
B..
```

虽然看上去下面的方法比上面的优秀，但是 N 被第三行的 B 攻击了。也就是说，你需要避免的有 2 种情况： 你摆放的 bishop 之间的互相攻击以及你摆放的 bishop 与预先摆放好的棋子之间的互相攻击；但不用考虑预先摆放好的棋子之间的互相攻击。



---

---
title: "[TJOI2014] 匹配"
layout: "post"
diff: 省选/NOI-
pid: P3967
tag: ['2014', '各省省选', '枚举', '二分图', '费用流', '天津']
---
# [TJOI2014] 匹配
## 题目描述

有 $N$ 个单身的男孩和 $N$ 个单身女孩，男孩 $i$ 和女孩 $j$ 在一起得到的幸福值为 $H_{i,j}$。

一个匹配即对这 $N$ 个男孩女孩的安排：每个男孩恰好有一个女朋友，每个女孩恰好有一个男朋友。

一个匹配的幸福值即这 $N$ 对男女朋友的幸福值的和。

经典的问题是计算幸福值最大的匹配，即完美匹配。然而完美匹配有时候并不唯一，你需要计算对于所有的完美匹配，其交集是什么。
## 输入格式

输入的第一行是一个正整数 $N$ 。

接下来是一个 $N\times N$ 大小的矩阵 $H$，$H_{i,j}$ 表示男孩 $i$ 和女孩 $j$ 在一起的幸福值。
## 输出格式

第一行输出完美匹配的幸福值，接下来是若干行，每一行是一对整数 $i$ 和 $j$，表示男孩 $i$ 和女孩 $j$ 在所有完美匹配的交集中，以 $i$ 的递增顺序输出。
## 样例

### 样例输入 #1
```
3
1 1 1
2 1 1
1 1 1
```
### 样例输出 #1
```
4
2 1
```
## 提示

- 对于 $30\%$ 的数据，$N \leq 30$；
- 对于 $100\%$ 的数据，$1\leq N \leq 80$，$0\leq H_{i,j}\leq 5\times10^3$。


---

---
title: "[JSOI2009] 游戏"
layout: "post"
diff: 省选/NOI-
pid: P4055
tag: ['2009', '各省省选', '网络流', '江苏', '二分图']
---
# [JSOI2009] 游戏
## 题目描述

小 AA 和小 YY 得到了《喜羊羊和灰太狼》的电影票，都很想去观看，但是电影票只有一张，于是他们用智力游戏决定胜负，赢得游戏的人可以获得电影票。

在 $N \times M$ 的迷宫中有一个棋子，小 AA 首先任意选择棋子放置的位置。然后，小 YY 和小 AA 轮流将棋子移动到相邻的格子里。游戏的规则规定，在一次游戏中，同一个格子不能进入两次，且不能将棋子移动到某些格子中去。当玩家无法继续移动棋子时，游戏结束，最后一个移动棋子的玩家赢得了游戏。

例如下图所示的迷宫，迷宫中 `.` 表示棋子可以经过的格子，而 `#` 表示棋子不可以经过的格子：

```cpp
                                 .##
                                 ...
                                 #.# 
```                                 
若小 AA 将棋子放置在 $(1,1)$，则小 AA 则无论如何都无法赢得游戏。

而若小 AA 将棋子放置在 $(3,2)$ 或 $(2,3)$，则小 AA 能够赢得游戏。例如，小 AA 将棋子放置在 $(3,2)$，小 YY 只能将它移动到 $(2,2)$，此时小 AA 再将棋子移动到 $(2,3)$，就赢得了游戏。

小 AA 和小 YY 都是绝顶聪明的小朋友，且从不失误。小 AA 到底能不能赢得这场游戏，从而得到珍贵的电影票呢？
## 输入格式

输入数据首先输入两个整数 $N,M$，表示了迷宫的边长。

接下来 $N$ 行，每行 $M$ 个字符，描述了迷宫。

## 输出格式

若小 AA 能够赢得游戏，则输出一行 `WIN`，然后输出所有可以赢得游戏的起始位置，按行优先顺序输出，每行一个。

否则输出一行 `LOSE`。

## 样例

### 样例输入 #1
```
3 3
.##
...
#.#
```
### 样例输出 #1
```
WIN
2 3
3 2
```
## 提示

- 对 $30\%$ 的数据，有 $n,m \leq 5$；
- 对 $100\%$ 的数据，有 $1 \leq n,m \leq 100$。



---

---
title: "[SDOI2016] 数字配对"
layout: "post"
diff: 省选/NOI-
pid: P4068
tag: ['贪心', '2016', '各省省选', '网络流', '山东', '二分图', '素数判断,质数,筛法']
---
# [SDOI2016] 数字配对
## 题目描述

有 $n$ 种数字，第 $i$ 种数字是 $a_i$、有 $b_i$ 个，权值是 $c_i$。

若两个数字 $a_i$、$a_j$ 满足，$a_i$ 是 $a_j$ 的倍数，且 $a_i/a_j$ 是一个质数，

那么这两个数字可以配对，并获得 $c_i \times c_j$ 的价值。

一个数字只能参与一次配对，可以不参与配对。

在获得的价值总和不小于 $0$ 的前提下，求最多进行多少次配对。
## 输入格式

第一行一个整数 $n$。

第二行 $n$ 个整数 $a_1,a_2,\cdots,a_n$。

第三行 $n$ 个整数 $b_1,b_2,\cdots,b_n$。

第四行 $n$ 个整数 $c_1,c_2,\cdots,c_n$。
## 输出格式

一行一个数，最多进行多少次配对。
## 样例

### 样例输入 #1
```
3
2 4 8
2 200 7
-1 -2 1

```
### 样例输出 #1
```
4
```
## 提示

测试点 $1 \sim 3$： $n \leq 10 $， $a_i \leq 10 ^ 9 $ ， $b_i = 1 $，$ | c_i | \leq 10 ^ 5$；   

测试点 $4 \sim 5$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5  $，$c_i = 0$；

测试点 $6 \sim 10$： $n \leq 200 $， $a_i \leq 10 ^ 9 $ ， $b_i \leq 10 ^ 5$ ，$ | c_i | \leq 10 ^ 5$。


---

---
title: "[USACO17DEC] A Pie for a Pie G"
layout: "post"
diff: 省选/NOI-
pid: P4083
tag: ['2017', '二分', 'USACO', '并查集', '图论建模', '最短路']
---
# [USACO17DEC] A Pie for a Pie G
## 题目描述

Bessie and Elsie have each baked $N$ pies ($1 \leq N \leq 10^5$). Each of the $2N$ pies has a tastiness value according to Bessie and a (possibly different) tastiness value according to Elsie.

Bessie is thinking about giving one of her pies to Elsie. If Elsie receives a pie from Bessie, she will feel obligated to give one of her pies to Bessie. So as to not appear stingy nor flamboyant, Elsie will try to pick a pie that is at least as tasty (in Elsie's eyes) as the pie she received, but no more than $D$ units tastier ($0 \leq D \leq 10^9$). Such a pie may not exist, in which case Elsie will adopt a pseudonym and exile herself to Japan.


But if Elsie does give Bessie a pie in return, Bessie will similarly try to give Elsie a pie which is at least as tasty but no more than $D$ units tastier (in Bessie's eyes) as the pie Elsie just gave her. Should this be impossible, Bessie too will exile herself. Otherwise she will give her chosen pie to Elsie. This cycle will continue until one of the cows is exiled, an unhappy outcome, or one of the cows receives a pie which she accords a tastiness value of $0$, in which case the gift exchange will end and both cows will be happy.


Note that a pie may not be gifted twice, nor can either cow return a pie gifted to her.


For each of the $N$ pies Bessie could select as her initial gift to Elsie, determine the minimum number of pies that could possibly be gifted in the resulting exchange before the cows are happy.

## 输入格式

The first line contains the two integers $N$ and $D$.

The next $2N$ lines contain two space-separated integers each, respectively denoting the value of a particular pie according to Bessie, and the value of that pie according to Elsie.


The first $N$ lines refer to Bessie's pies, and the remaining $N$ lines refer to Elsie's pies.


It is guaranteed that all tastiness values are in the range $[0,10^9]$.

## 输出格式

There should be $N$ lines in the output. Line $i$ should contain a single integer: the minimum number of pies that could be gifted in a happy gift exchange started with Bessie's pie $i$. If no gift exchange starting with pie $i$ is happy, then line $i$ should contain the single integer $-1$ instead.

## 样例

### 样例输入 #1
```
2 1
1 1
5 0
4 2
1 4
```
### 样例输出 #1
```
3
1

```
## 题目翻译

### 题目描述

Bessie 和 Elsie 各自烤了 $N$ 个派（$1 \leq N \leq 10^5$）。这 $2N$ 个派中的每一个都有一个由 Bessie 评定的美味值和一个（可能不同的）由 Elsie 评定的美味值。

Bessie 正在考虑将她的一只派送给 Elsie。如果 Elsie 收到了 Bessie 的派，她会觉得有义务回赠 Bessie 一只派。为了既不显得吝啬也不显得炫耀，Elsie 会尝试选择一只在她看来至少与收到的派一样美味，但不超过 $D$ 单位更美味的派（$0 \leq D \leq 10^9$）。如果这样的派不存在，Elsie 将采用一个化名并自我流放到日本。

但如果 Elsie 确实回赠了 Bessie 一只派，Bessie 也会类似地尝试送给 Elsie 一只在她看来至少与 Elsie 刚送给她的派一样美味，但不超过 $D$ 单位更美味的派。如果这不可能，Bessie 也会自我流放。否则，她会将她选择的派送给 Elsie。这个循环将继续，直到其中一头奶牛被流放（一个不愉快的结果），或者其中一头奶牛收到一只她评定美味值为 $0$ 的派，在这种情况下，礼物交换将结束，两头奶牛都会感到高兴。

请注意，一只派不能被赠送两次，任何一头奶牛也不能回赠她收到的派。

对于 Bessie 可以选择作为初始礼物送给 Elsie 的每一只派，确定在奶牛们感到高兴之前，可能被赠送的派的最小数量。

### 输入格式

第一行包含两个整数 $N$ 和 $D$。

接下来的 $2N$ 行每行包含两个用空格分隔的整数，分别表示某只派由 Bessie 评定的美味值和由 Elsie 评定的美味值。

前 $N$ 行描述 Bessie 的派，剩下的 $N$ 行描述 Elsie 的派。

保证所有美味值都在 $[0,10^9]$ 范围内。

### 输出格式

输出应包含 $N$ 行。第 $i$ 行应包含一个整数：如果以 Bessie 的第 $i$ 只派开始的礼物交换是高兴的，则输出可能被赠送的派的最小数量；否则输出 $-1$。


---

---
title: "[BJOI2012] 连连看"
layout: "post"
diff: 省选/NOI-
pid: P4134
tag: ['2012', '各省省选', '北京', '二分图', '费用流']
---
# [BJOI2012] 连连看
## 题目描述

凡是考智商的题里面总会有这么一种消除游戏。不过现在面对的这关连连看可不是 QQ 游戏里那种考眼力的游戏。我们的规则是，给出一个闭区间 $[a,b]$ 中的全部整数，如果其中某两个数 $x$，$y$（$x>y$）的平方差 $x^2-y^2$ 是一个完全平方数 $z^2$，并且 $y$ 与 $z$ 互质，那么就可以将 $x$ 和 $y$ 连起来并且将它们一起消除，同时得到 $x+y$ 点分数。那么过关的要求就是，消除的数对尽可能多的前提下，得到足够的分数。快动手动笔算一算吧。
## 输入格式

只有一行，两个整数，分别表示 $a$，$b$。
## 输出格式

两个数，可以消去的对数，及在此基础上能得到的最大分数。

## 样例

### 样例输入 #1
```
1 15
```
### 样例输出 #1
```
2 34
```
## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $1\le a,b\le100$。
- 对于 $100\%$ 的数据，保证 $1\le a,b\le1000$。


---

---
title: "[SCOI2015] 小凸玩矩阵"
layout: "post"
diff: 省选/NOI-
pid: P4251
tag: ['2015', '四川', '二分', '各省省选', '网络流', '二分图']
---
# [SCOI2015] 小凸玩矩阵
## 题目描述

小凸和小方是好朋友，小方给了小凸一个 $n$ × $m$ $(n \leq m)$ 的矩阵 $A$，并且要求小凸从矩阵中选出 $n$ 个数，其中任意两个数都不能在同一行或者同一列。现在小凸想知道，选出的 $n$ 个数中第 $k$ 大的数的最小值是多少。
## 输入格式

第 $1$ 行读入 $3$ 个整数 $n, m, k$。

接下来 $n$ 行，每一行有 $m$ 个数字，第 $i$ 行第 $j$ 个数字代表矩阵中第 $i$ 行第 $j$ 列的元素 $A_{i,j}$。
## 输出格式

输出包含一行，为选出的 $n$ 个数中第 $k$ 大数的最小值。
## 样例

### 样例输入 #1
```
2 3 1
1 2 4
2 4 1
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
3 4 2
1 5 6 6
8 3 4 3
6 8 6 3
```
### 样例输出 #2
```
3
```
## 提示

对于 $20$% 的数据， $1 \leq n \leq m \leq 9$

对于 $40$% 的数据， $1 \leq n \leq m \leq 22, 1 \leq n \leq 12$

对于 $100$% 的数据， $1 \leq k \leq n \leq m \leq 250, 1 \leq A_{i,j} \leq 10^9$


---

---
title: "王者之剑"
layout: "post"
diff: 省选/NOI-
pid: P4474
tag: ['网络流', '二分图', '最小割']
---
# 王者之剑
## 题目描述

![https://cdn.luogu.com.cn/upload/pic/17920.png](https://cdn.luogu.com.cn/upload/pic/17920.png)  

这是在阿尔托利亚·潘德拉贡成为英灵前的事情，她正要去拔出石中剑成为亚瑟王，在这之前她要去收集一些宝石。

宝石排列在一个 $n \times m$ 的网格中，每个网格中有一块价值为 $v_{i,j}$ 的宝石，阿尔托利亚·潘德拉贡可以选择自己的起点。

开始时刻为 $0$ 秒。以下操作，每秒按顺序执行。

1. 在第 $i$ 秒开始的时候，阿尔托利亚·潘德拉贡在方格 $(x,y)$ 上，她可以拿走 $(x, y)$ 中的宝石。
2. 在偶数秒，阿尔托利亚·潘德拉贡周围四格的宝石会消失。
3. 若阿尔托利亚·潘德拉贡第 $i$ 秒开始时在方格 $(x,y)$ 上，则在第 $i+1$ 秒可以立即移动到 $(x+1,y),(x,y+1),(x-1,y)$ 或 $(x, y- 1)$ 上，也可以停留在（$x,y)$ 上。


求阿尔托利亚·潘德拉贡最多可以获得多少价值的宝石
## 输入格式

第一行给出数字 $N,M$ 代表行列数 $N,M$ 均小于等于 $100$，宝石的价值不会超过 $10000$。下面 $N$ 行 $M$ 列用于描述数字矩阵。
## 输出格式

输出最多可以拿到多少价值宝石。
## 样例

### 样例输入 #1
```
2 2
1 2
2 1
```
### 样例输出 #1
```
4
```
## 提示

姚金宇的原创题。


---

---
title: "[ZJOI2018] 胖"
layout: "post"
diff: 省选/NOI-
pid: P4501
tag: ['2018', '线段树', '二分', '各省省选', '浙江', 'ST 表']
---
# [ZJOI2018] 胖
## 题目背景

Cedyks 是九条可怜的好朋友（可能这场比赛公开以后就不是了），也是这题的主人公。
## 题目描述

Cedyks 是一个富有的男孩子。他住在著名的 The Place（宫殿）中。

Cedyks 是一个努力的男孩子。他每天都做着不一样的题来锻炼他的 The Salt（灵魂）。

这天，他打算在他的宫殿外围修筑一道城墙，城墙上有 $n$ 座瞭望塔。你可以把城墙看做一条线段，瞭望塔是线段上的 $n$ 个点，其中 $1$ 和 $n$ 分别为城墙的两个端点。其中第 $i$ 座瞭望塔和第 $i + 1$ 座瞭望塔的距离为 $w_i$，他们之间的道路是双向的。

城墙很快就修建好了，现在 Cedyks 开始计划修筑他的宫殿到城墙的道路。因为这题的题目名称，Cedyks 打算用他的宫殿到每一个瞭望塔的最短道路之和来衡量一个修建计划。

现在 Cedyks 手上有 $m$ 个设计方案，第 $k$ 个设计方案会在宫殿和瞭望塔之间修建 $T_k$ 条双向道路，第 $i$ 条道路连接着瞭望塔 $a_i$，长度为 $l_i$。

计算到每一个瞭望塔的最短路之和是一个繁重的工程，本来 Cedyks 想用广为流传的 SPFA 算法来求解，但是因为他的 butter（缓冲区）实在是太小了，他只能转而用原始的贝尔福特曼算法来计算，算法的流程大概如下：

1. 定义宫殿是 $0$ 号点，第 $i$ 个瞭望塔是 $i$ 号点，双向边 $(u_i, v_i, l_i)$ 为一条连接 $u_i$ 和 $v_i$ 的双向道路。令 $d$ 为距离数组，最开始 $d_0 = 0, d_i = 10^{18}(i ∈ [1, n])$。
2. 令辅助数组 $c = d$。依次对于每一条边 $(u_i, v_i,w_i)$ 进行增广，$c_{u_i} = \min(c_{u_i} , d_{v_i} + w_i)$，$c_{v_i} = \min(c_{v_i} , d_{u_i} + w_i)$。
3. 令 $t$ 为 $c$ 和 $d$ 中不一样的位置个数，即令 $S = \{i|c_i≠d_i\}$，则 $t = |S|$。若 $t = 0$，说明 $d$ 就是最终的最短路，算法结束。否则令 $d = c$，回到第二步。

因为需要计算的设计方案实在是太多了，所以 Cedyks 雇佣了一些人来帮他进行计算。为了避免这些人用捏造出来的数据偷懒，他定义一个设计方案的校验值为在这个方案上运行贝尔福特曼算法每一次进入第三步 $t$ 的和。他会让好几个雇佣来的人计算同样的设计方案，并比对每一个人给出的校验值。

你是 Cedyks 雇佣来的苦力之一，聪明的你发现在这个情形下计算最短路的长度的和是一件非常简单的事情。但是寄人篱下不得不低头，你不得不再计算出每一个方案的校验值来交差。
## 输入格式

第一行输入两个整数 $n,m$，表示瞭望塔个数和设计方案个数。

接下来一行 $n - 1$ 个数 $w_i$，表示瞭望塔 $i$ 和 $i + 1$ 之间道路的长度。

接下来 $m$ 行，每行描述一个设计方案。第一个整数 $K$ 表示设计方案中的道路数量，接下来 $K$ 个数对 $(a_i, l_i)$ 为一条宫殿到瞭望塔的边。
## 输出格式

对于每一个设计方案，输出一行一个整数表示校验值。
## 样例

### 样例输入 #1
```
5 5
2 3 1 4
1 2 2
2 1 1 4 10
3 1 1 3 1 5 1
3 1 10 2 100 5 1
5 1 1 2 1 3 1 4 1 5 1
```
### 样例输出 #1
```
5
8
5
8
5
```
## 提示

### 样例解释

对于第一个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,10^{18},2,10^{18},10^{18},10^{18}] \rightarrow$ $[0,4,2,5,10^{18},10^{18}] \rightarrow [0,4,2,5,6,10^{18}] \rightarrow [0,4,2,5,6,10]$。

因此校验值为 $1+2+1+1=5$。

对于第二个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,10^{18},10^{18},10,10^{18}] \rightarrow$ $[0,1,3,11,10,14] \rightarrow [0,1,3,6,10,14] \rightarrow [0,1,3,6,7,14] \rightarrow [0,1,3,6,7,11]$。

因此校验值为 $2+3+1+1+1=8$。

对于第三个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,10^{18},1,10^{18},1] \rightarrow [0,1,3,1,2,1]$。

因此校验值为 $3+1+1=5$。

对于第四个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,10,100,10^{18},10^{18},1] \rightarrow$ $[0,10,12,103,5,1] \rightarrow [0,10,12,6,5,1] \rightarrow [0,10,9,5,1]$。

因此校验值为 $3+3+1+1=8$。

对于第五个设计方案，每一个阶段 $d$ 的变化为：

- $[0,10^{18},10^{18},10^{18},10^{18},10^{18}] \rightarrow [0,1,1,1,1,1]$

因此校验值为 $5$。

### 数据范围

测试点|$n$|$m$|$K$|其他约定
-|-|-|-|-
1,2|$\le 1000$|$\le 1000$|$\le 100$|无
3,4|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 100$|无
5,6|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$1 \le w_i,l_i \le 50$
7,8,9,10|$\le 2 \times 10^5$|$\le 2 \times 10^5$|$\le 2 \times 10^5$|无


对于 $100\%$ 的数据，保证每个设计方案 $a_i$ 两两不同且 $1\le a_i\le n$。  
对于 $100\%$ 的数据，保证 $1\le w_i,l_i\le 10^9,1\le\sum K\le 2\times 10^5$。

感谢 @Xeonacid 提供题面


---

---
title: "[TJOI2018] 智力竞赛"
layout: "post"
diff: 省选/NOI-
pid: P4589
tag: ['2018', '二分', '各省省选', '二分图', '天津']
---
# [TJOI2018] 智力竞赛
## 题目描述

小豆报名参加智力竞赛，他带上了 $n$ 个好朋友作为亲友团一块来参加比赛。比赛规则如下：

一共有 $m$ 道题目，每个人都有 $1$ 次答题机会，每次答题为选择一道题目回答，在回答正确后，可以继续回答这个题目的后续题目，直到答错题目或者没有后续题目。

每个问题都会有一个价值，比赛最后参赛选手获得的奖励价值等价于该选手和他的亲友团没有回答的问题中的最低价值。

我们现在知道小豆和他的亲友团实力非常强，能够做出这次竞赛中的所有题目。

小豆想知道在知道题目和后续题目的条件下，他最大能获得的价值是多少？
## 输入格式

第一行有两个整数 $n,m$。（$n\leq50,m\leq500$）

接下来 $m$ 行，第 $i+1$ 行表示编号为 $i$ 的题目的题目信息，格式形如 $v_i,k_i,a_{i,1},a_{i,2},...,a_{i,k_i}$，其中 $v_i$ 表示该题目的价值，$k_i$ 表示这个题目的后续题目个数，$a_{i,1},a_{i,2},...,a_{i,k_i}$ 表示 $k_i$ 个后续题目的编号。
## 输出格式

如果全部题目都能答对，则输出 `AK`，否则输出小豆可以获得的最高奖励价值。
## 样例

### 样例输入 #1
```
1 3
1 0
2 1 3
3 0
```
### 样例输出 #1
```
AK
```
### 样例输入 #2
```
1 6
1 2 2 3
2 1 4
3 1 4
4 1 6
5 0
6 0
```
### 样例输出 #2
```
5
```
## 提示

对于 $10\%$ 的数据，有 $1<n,m\leq10$。

对于 $20\%$ 的数据，有 $1<n,m\leq100$。

对于 $100\%$ 的数据，有 $1<n\leq50,1<m\leq500,v_i\leq10^9,k_i,a_{i,j}\leq m$。


---

---
title: "[CTSC2018] 混合果汁"
layout: "post"
diff: 省选/NOI-
pid: P4602
tag: ['2018', '线段树', 'O2优化', '可持久化', '整体二分', 'CTSC/CTS']
---
# [CTSC2018] 混合果汁
## 题目描述

小 R 热衷于做黑暗料理，尤其是混合果汁。

商店里有 $n$ 种果汁，编号为 $0,1,\cdots,n-1$ 。$i$ 号果汁的美味度是 $d_i$，每升价格为 $p_i$。小 R 在制作混合果汁时，还有一些特殊的规定，即在一瓶混合果汁中，$i$ 号果汁最多只能添加 $l_i$ 升。

现在有 $m$ 个小朋友过来找小 R 要混合果汁喝，他们都希望小 R 用商店里的果汁制作成一瓶混合果汁。其中，第 $j$ 个小朋友希望他得到的混合果汁总价格不大于 $g_j$，体积不小于 $L_j$。在上述这些限制条件下，小朋友们还希望混合果汁的美味度尽可能地高，一瓶混合果汁的美味度等于所有参与混合的果汁的美味度的最小值。请你计算每个小朋友能喝到的最美味的混合果汁的美味度。
## 输入格式

输入第一行包含两个正整数 $n, m$，表示果汁的种数和小朋友的数量。

接下来 $n$ 行，每行三个正整数 $d_i, p_i, l_i$，表示 $i$ 号果汁的美味度为 $d_i$，每升价格为 $p_i$，在一瓶果汁中的添加上限为 $l_i$。

接下来 $m$ 行依次描述所有小朋友：每行两个数正整数 $g_j, L_j$ 描述一个小朋友，表示他最多能支付 $g_j$ 元钱，他想要至少 $L_j$ 升果汁。
## 输出格式

对于所有小朋友依次输出：对于每个小朋友，输出一行，包含一个整数，表示他能喝到的最美味的混合果汁的美味度。如果无法满足他的需求，则输出 $-1$。

## 样例

### 样例输入 #1
```
3 4
1 3 5
2 1 3
3 2 5
6 3
5 3
10 10
20 10
```
### 样例输出 #1
```
3
2
-1
1
```
## 提示

对于所有的测试数据，保证 $n, m \le 100000$，$1 \le d_i,p_i,l_i \le 10^5$，$1 \le g_j, L_j \le 10^{18}$。

测试点编号|$n=$|$m=$|其他限制
-|-|-|-
$1,2,3$|$10$|$10$|无
$4,5,6$|$500$|$500$|无
$7,8,9$|$5000$|$5000$|无
$10,11,12$|$100000$|$100000$|$p_i=1$
$13,14,15$|$100000$|$100000$|$l_i=1$
$16,17,18,19,20$|$100000$|$100000$|无


---

---
title: "[BalticOI 2008] 网格"
layout: "post"
diff: 省选/NOI-
pid: P4661
tag: ['2008', '二分', '枚举', 'BalticOI（波罗的海）']
---
# [BalticOI 2008] 网格
## 题目描述

Byteland 国的地图是一个大小为 $n\times m$ 的网格（$n$ 是垂直方向长度，$m$ 是水平方向长度）。标记分隔的水平线被叫做平行线，并编号为 $0$ 到 $n$，标记分隔的垂直线被叫做子午线，并编号为 $0$ 到 $m$。

在 Byteland 国，天气预报是一个十分严肃的话题，对于每个单元格，准备天气预报需要一定时间来计算。由于地形条件和其他因素，不同的单元格有着不同的计算时间。直到目前为止，预报系统还是会依次处理每一个单元格，所以完成预报天气需要花费的时间为计算所有单元的时间。

你被要求设计一个可以在多进程处理器上运行的新系统，为了共享处理器的计算能力，Byteland 国要被 $r$ 条平行线和 $s$ 条子午线划分为 $(r+1)(s+1)$ 个矩形。每个线程会依次处理一个矩形内部的单元格，这样的话对于一个矩形区域的计算时间，就为矩形区域内单元格计算时间之和。完成预报的计算时间是一个处理器上计算时间的最大值。

你的任务是找到对于选择 $r$ 条平行线和 $s$ 条子午线分隔后最小的计算时间。

#任务

写一个程序能够：

-    从标准输入读取 Byteland 的地图，要求的平行线和子午线条数以及每个单元格的处理时间；
-    找到完成预报的最小计算时间；
-    输出这个值到标准输出。

## 输入格式

第一行包含四个正整数 $n,m,r,s$，由一个空格隔开。

接下来 $n$ 行包含每一个单元格的计算时间 $c_{i,j}$。第 $i+1$ 行的第 $j$ 个数表示位于第 $i-1$ 和第 $i$ 条平行线，第 $j-1$ 和第 $j$ 条子午线之间的单元格需要的计算时间。 
## 输出格式

输出一行一个整数，表示最优的计算时间。
## 样例

### 样例输入 #1
```
7 8 2 1
0 0 2 6 1 1 0 0
1 4 4 4 4 4 3 0
2 4 4 4 4 4 3 0
1 4 4 4 8 4 4 0
0 3 4 4 4 4 4 3
0 1 1 3 4 4 3 0
0 0 0 1 2 1 2 0
```
### 样例输出 #1
```
31
```
## 提示

**样例解释**

![0](https://i.loli.net/2018/02/19/5a8ae8ca02cbb.png)

第二条和第四条平行线，第四条子午线把整个国家分为六个矩形，计算时间为 $21, 13, 27, 27, 17, 31$，所以完成预报的计算时间为 $31$。

**数据范围**

对于 $40\%$ 的数据，$n\le 10,m\le 10$；

对于全部数据，$1\le r<n\le 18,1\le s<m\le 18$，$1\le i\le n,1\le j\le m,0\le c_{i,j}\le 2\times 10^6$​​。 


---

---
title: "LJJ爱数书"
layout: "post"
diff: 省选/NOI-
pid: P4846
tag: ['贪心', '二分']
---
# LJJ爱数书
## 题目背景

题解请查看[https://www.cnblogs.com/Blog-of-Eden/p/9367521.html](https://www.cnblogs.com/Blog-of-Eden/p/9367521.html)
## 题目描述

LJJ的家里有一本“数书”，也就是说里面全都是数字的书，LJJ十分喜爱它。
数书里有一个序列A，每次操作可以**使一段连续的区间加1或减1**并**对K取模**（K-1加1后变为0，0减1后变为K-1），我们定义**和谐函数F(A,K)表示最少的操作次数，使得序列的所有元素都变为0**。
例如A={3,3,2,3}，K=4时，通过把A变成{0,0,3,0}，再把A变成{0,0,0,0}就能达到要求，所以F(A,K)=2。

现在，输入长度为**n（n<=200000）**的序列A，设A[L][R]表示序列A第L个位置到第R个位置的连续子序列。
 有**m（m<=100000）**次询问，每次询问**输入L,R,K**，求**F(A[L][R],K)的值**。

**注：数据保证K>Max{A[1],A[2],....,A[n]}。**
## 输入格式

第1行：两个整数n,m，表示序列长度为n，有m次询问。
第2行：n个整数，第i个整数表示A[i]
第3至m+2行：每行三个整数L,R,K（1<=L<=R<=n，K<=2^30）
## 输出格式

共m行：每行一个整数，表示每组询问的答案F(A[L][R],K)
## 样例

### 样例输入 #1
```
7 2
8 8 8 0 8 8 8
1 7 9
3 5 17
```
### 样例输出 #1
```
2
16
```
### 样例输入 #2
```
4 1
5 3 8 2
1 4 9
```
### 样例输出 #2
```
8
```
### 样例输入 #3
```
10 10
7 7 6 5 5 2 8 5 0 3 
1 8 11
3 10 11
4 7 12
9 10 12
3 5 10
2 7 10
7 9 10
2 7 11
1 4 11
4 7 10

```
### 样例输出 #3
```
12
15
9
3
5
8
5
9
6
7

```
## 提示

数据保证每组询问的K>Max{A[1],A[2],....,A[n]}。

10%：n<=10，m=1，K<=10

30%：n<=1000，m=1，K<=2^30

50%：n<=200000，m=1，K<=2^30

另有10%数据：n<=200000，m<=100000，K=2

另有20%数据：n<=30000，m<=30000，K<=2^30

100%：n<=200000，m<=100000，K<=2^30


---

---
title: "PION后缀自动机"
layout: "post"
diff: 省选/NOI-
pid: P4947
tag: ['字符串', '二分', '树链剖分']
---
# PION后缀自动机
## 题目背景

NOIP2018原创模拟题T6

NOIP2018原创模拟赛DAY2 T3

NOIP DAY1 T3+ or DAY2 T3 难度

鉴于 NOIP2017 DAY2 T3 的难度，就有了这道题。**然而这道题考察的知识并不是后缀自动机**
## 题目描述

小P是一个技术高超的程序员，他开发了一套自己的操作系统，称为PION系统，该系统与Windows和Linux有很大不同，目前他正在测试该系统。

PION系统与Windows系统最大的不同在于文件的储存与操作，POIN的文件夹没有父子之分。我们知道，在Windows系统中，可以在文件夹里新建子文件夹。但是，PION系统文件夹不分父子关系，**但是部分文件夹之间可以互相直接访问，我们称这种关系为互访关系，而且，对于一个有$n$个文件夹的系统来说，这种互访关系有$n-1$个，且保证所有文件夹均可以通过互访关系而互相访问。也就是说：我们可以把Windows中的文件夹的集合看作一棵有根树，而把PION系统中的文件夹集合看作为无根树。**

在PION系统中，每个文件夹都可以储存文件，和Windows一样，文件名包含后缀名。

现在小P正在构思一种可以对文件夹中文件后缀进行方便操作的交互式程序dmc，他也将其称为**PION后缀自动机**。由于他太忙了，所以他希望你帮他实现**部分功能**。

他希望你帮他实现三个功能：

1.计算两个文件夹之间的距离。我们定义：文件夹之间的距离为其中一个文件夹通过互访达到另一个文件夹最少互访次数。比如：同一个文件夹距离为0，两个有互访关系的文件夹距离为1。

2.计算两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件数量，**其中A是一个小写字符串。提示：我们可以把PION文件夹之间的路径理解为树中两节点之间的路径。**

3.删除两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件，并统计被删除文件的数量。

由于dmc是一个交互系统，所以我们用tab语言描述这三个操作：

```
query /p u v
```

表示操作一，其中 u,v 表示两文件夹的编号

```
query /e u v *.A
```

表示操作二，其中 u,v 表示两文件夹的编号，$'*'$ 为通配符，$'.'$用于分隔文件名与后缀，**A是一个小写字符串**。

```
del /e u v *.A
```

表示操作三， $u,v, *.A$ 意义与操作二相同。

**如果没有看懂题目请结合样例及样例解释来理解。**

最后，这个困难的任务就交给你了。
## 输入格式

第一行两个数，$n,m$，$n$表示文件夹的数量（文件夹编号在$[1,n]$），$m$表示操作的数量

接下来 $n-1$ 行，每行两个数 $u,v$，表示文件夹 $u,v$ 之间有互访关系

接下来 $n$ 行，第$i$行第一个数为 $k$，表示第$i$个文件夹有$k$个文件，接下来为$k$个字符串，表示每个文件的后缀名

再接下来$m$行，每行一串指令，格式见上文
## 输出格式

对于每个指令，输出一个数，输出数的意义见上文
## 样例

### 样例输入 #1
```
5 5
1 2
2 4
2 5
1 3
2 cpp c
3 pas txt txt
2 vbs bat
3 vbs cpp pas
4 cpp c pas txt
query /e 1 5 *.txt
query /p 1 4
del /e 2 2 *.txt
query /e 1 5 *.txt
query /e 4 3 *.vbs
```
### 样例输出 #1
```
3
2
2
1
2
```
### 样例输入 #2
```
12 7
1 2
1 3
1 4
2 5
2 6
3 7
7 12
8 4
8 9
10 9
11 9
0
2 c c
3 zz c c
0
1 gif
2 png bmp
3 avl avl mpshi
0
4 cpp c pas js
5 a b c d e
0
3 a b c
query /p 11 12
query /e 1 2 *.gif
query /e 6 10 *.c
del /e 2 9 *.c
del /e 3 12 *.c
query /e 5 6 *.gif
query /e 6 1 *.c
```
### 样例输出 #2
```
7
0
4
3
3
1
0
```
## 提示

**样例一解释：**

![T6](https://cdn.luogu.com.cn/upload/pic/34166.png)

如图为样例一大致结构，橙色方框为文件夹，灰色文字表示文件后缀名，红色线条表示文件互访关系。

对于第一个操作：文件夹1到5之间txt文件有3个所以输出3  
对于第二个操作：文件夹1与4距离为2  
对于第三个操作：删除的为文件夹2的文件，txt文件有两个，所以输出2  
对于第四个操作：由于文件夹2的txt文件被删除了，所以1到5之间txt文件只有1个  
对于第五个操作：文件夹3到4之间vbs文件有2个所以输出2

**数据范围：**

30%数据满足：$n,m<=100,k<=3$

50%数据满足：$n,m<=5000,k<=10$

70%数据满足：$n,m<=2 \times 10^4,k<=50$

90%数据满足：$n,m<=5 \times 10^4$

100%数据满足：$n,m<=10^5$，文件总数小于$5 \times 10^5$，文件后缀名为小写字符串且不超过6个字符

其他说明：

1.约50%的数据为完全随机生成

2.数据弱化版：[PION后缀自动机（数据弱化版）](https://www.luogu.org/problemnew/show/U41487)


---

---
title: "忘情"
layout: "post"
diff: 省选/NOI-
pid: P4983
tag: ['斜率优化', '凸完全单调性（wqs 二分）', '凸包']
---
# 忘情
## 题目背景

 “为什么要离开我！”

 “因为你没玩儿转！”

 “我玩儿转了！”

 “那好，你现在就给我维护这么一个式子！”

 “为什么要出这么毒瘤的东西。”

 “为了恶心你。”

 “......”

$…………………………….$

## 题目描述

你的 $npy$ 为了恶心你，特地请了四位大神和一个辣鸡！

 $\rm hdxrie$ 说：“我们得求和。”于是有了 $\sum\limits_{i=1}^{n}x_i $ 。

 $\rm Imagine$ 说：“我们得有平均数。”于是有了 $\bar x $ 。

 $\rm TimeTraveller$ 说：“我们得有加减乘除。”于是有了一些恶心的组合。

 $\rm Althen·Way·Satan$ 说：“我们还得有平方。”于是我们将它平方。

最垃圾的 $\rm ZredXNy$ 说：“那我帮你们整合一下。”

于是，我们得到了这么一个式子 $:$

$$\frac{\left((\sum\limits_{i=1}^{n}x_i×\bar x)+\bar x\right)^2}{\bar x^2}$$


我们定义一段序列的值为这个，其中  $n$为此序列的元素个数。

我们给定一段长度为 $n$ 的序列,现在要求将它分成 $m$ 段，要求每一段的值的总和最小，求出这个最小值。

## 输入格式

第一行两个正整数，分别为 $n$，$m$，定义见题面。

接下来一行为 $n$ 个正整数，依次给出这个序列的每个元素的值 $x_i$ 。
## 输出格式

一个整数，求出这个最小值。
## 样例

### 样例输入 #1
```
3 2
1 2 3

```
### 样例输出 #1
```
32
```
### 样例输入 #2
```
10 3
1 2 3 4 5 6 7 8 9 10

```
### 样例输出 #2
```
1140
```
## 提示

- 对于 $30 \%$ 的数据，$m≤n≤500$；

- 另有 $20 \%$ 的数据，保证 $m=2$；

- 对于 $100 \%$ 的数据，$m≤n≤100000$，$1≤x_i≤1000$。



---

---
title: "【XR-3】系统设计"
layout: "post"
diff: 省选/NOI-
pid: P5537
tag: ['字符串', '线段树', '二分', '树状数组', 'O2优化', '哈希 hashing']
---
# 【XR-3】系统设计
## 题目描述

小 X 需要你设计一个系统。

这个系统首先需要输入一棵 $n$ 个点的有根树和一个长度为 $m$ 的序列 $a$，接下来需要实现 $q$ 个操作。

操作分两种：

1. `1 x l r` 表示设定起点为有根树的节点 $x$，接下来依次遍历 $l \sim r$。当遍历到 $i$ 时，从当前节点走向它的编号第 $a_i$ 小的儿子。如果某一时刻当前节点的儿子个数小于 $a_i$，或者已经遍历完 $l \sim r$，则在这个点停住，并输出这个点的编号，同时停止遍历。
2. `2 t k` 表示将序列中第 $t$ 个数 $a_t$ 修改为 $k$。
## 输入格式

第一行 $3$ 个正整数 $n,m,q$，分别表示树的点数、序列的长度和操作个数。

第二行 $n$ 个整数 $f_{1 \dots n}$，其中 $f_i$ 表示点 $i$ 在树中的父亲节点编号，特别地，设根节点为 $rt$，则 $f_{rt} = 0$。

第三行 $m$ 个正整数 $a_{1 \dots m}$，表示序列 $a$。

接下来 $q$ 行，每行描述一个操作。

**数据范围：**

- $1 \le n,m,q \le 5 \times 10 ^ 5$。
- $1 \le a_i \le n$。
- 对于操作 $1$，保证 $1 \le x \le n$，$1 \le l \le r \le m$。
- 对于操作 $2$，保证 $1 \le t \le m$，$1 \le k \le n$。
## 输出格式

对于每个操作 $1$，一行一个正整数，表示答案。
## 样例

### 样例输入 #1
```
6 6 10
0 1 2 2 1 5
1 2 2 1 2 1
1 1 1 3
1 5 2 6
1 6 5 6
1 2 3 5
1 2 4 4
2 2 1
1 1 1 6
1 1 2 4
2 1 2
1 1 1 5

```
### 样例输出 #1
```
4
5
6
4
3
3
4
6

```
## 提示

本题读入、输出量较大，请使用[读入、输出优化](https://oi-wiki.org/misc/io/)。

【样例说明】

第一个操作为 `1 1 1 3`，即 $1 \rightarrow 2 \rightarrow 4$，因此答案为 $4$。

第九个操作后，序列变为 `2 1 2 1 2 1`。

第十个操作为 `1 1 1 5`，即 $1 \rightarrow 5 \rightarrow 6$，因此答案为 $6$。


---

---
title: "[BJ United Round #3] 观察星象"
layout: "post"
diff: 省选/NOI-
pid: P5549
tag: ['计算几何', '二分', '北京', 'Special Judge', '随机化']
---
# [BJ United Round #3] 观察星象
## 题目描述

EI 在用望远镜观察星星，星空中共有  $n$ 个星星，每个星星观察起来有一个二维直角坐标 $(x,y)$。  

他的望远镜如果定位在 $(x_0,y_0)$ 处，可以看到所有 $(x_0-x)^2 + (y_0-y)^2 \le r^2$ 的星星。  

望远镜的大小 $r$ 是可以调整的，EI 想知道如果他要至少看到 $m$ 个星星，至少需要把 $r$ 设置到多大？
## 输入格式

第一行两个正整数 $n,m$，表示星星的数量和要求看到的星星数量。  
接下来 $n$ 行，每行两个整数 $x,y$，表示一个星星的坐标。  
保证星星坐标两两不同。
## 输出格式

输出一行一个正实数，表示望远镜的最小半径。  
令你的答案为 $a$，标准答案为 $b$，若 $\frac{|a-b|}{\max(1,b)} \le 10^{-6}$  
( 即绝对误差或者相对误差不超过 $10^{-6}$ ) 即为正确。
## 样例

### 样例输入 #1
```
4 3
0 0
1 1
2 3
3 3
```
### 样例输出 #1
```
1.41421356
```
## 提示

| 子任务编号 | $n$ | $m$ | 分值 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $\leq 50$ | $\leq n$ | $10$ |
| $2$ | $\leq 200$ | $\leq n$ | $15$ |
| $3$ | $\leq 700$ | $\leq n$ | $15$ |
| $4$ | $\leq 2000$ | $= n$ | $20$ |
| $5$ | $\leq 2000$ | $\leq n$ | $40$ |


对于 $100\%$ 的数据，保证：  
$2 \le m \le n  \le 2000$  
$|x|,|y| \le 10^4$

By：EntropyIncreaser


---

---
title: "[CmdOI2019] 任务分配问题"
layout: "post"
diff: 省选/NOI-
pid: P5574
tag: ['动态规划 DP', 'O2优化', '分治', '凸完全单调性（wqs 二分）']
---
# [CmdOI2019] 任务分配问题
## 题目背景

挖矿的时候踢断电源线是一种怎样的体验?
## 题目描述

在某台有 $k$ 个 CPU 的计算机中，有 $n$ 个计算任务等待执行。

$a_i$ 为第 $i$ 个任务的优先级，方便起见， $a$ 为一个排列。

现在，要将这些任务分配给 CPU 去解决。

由于内存等原因，一个 CPU 只能负责连续一段的任务，并且要按 (从左到右的) 顺序执行。

**在某个 CPU 内**，无序度定义为：前者先执行，而后者优先级高的任务对的个数。

请最小化每个 CPU 的无序度之和。
## 输入格式

第一行两个整数 $n,k$ ，分别表示任务个数和 CPU 个数。

第二行 $n$ 个整数，表示 $a_{1\sim n}$ 。
## 输出格式

输出一个整数，表示最小的无序度之和。
## 样例

### 样例输入 #1
```
5 1
1 5 4 2 3
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
5 2
1 5 4 2 3
```
### 样例输出 #2
```
1
```
### 样例输入 #3
```
8 3
1 3 5 2 7 4 8 6
```
### 样例输出 #3
```
4
```
## 提示

### 样例说明

- **样例 #1**

  此时只能把所有任务交给单独的一个 CPU。

  第一个任务和其他所有任务都形成无序任务对；最后两个任务也形成无序任务对，共 $5$ 个。

- **样例 #2**

  第一个 CPU 单独处理任务 $1$ ，无序度为 $0$；
  
  第二个 CPU 处理 $\{5,4,2,3\}$ 无序度为 $1$。
  
### 限制与约定

对于所有测试数据，保证 $1\leq n\leq 2.5\times 10^4$，$1\leq k\leq 25$，$k\leq n$。

| 测试点编号 | $n$ | $k$ |
| :--: | :--: | :--: |
| $1\sim 2$ | $2.5\times 10^4$ | $1$ |
| $3$ | $2.5\times 10^4$ | $2$ |
| $4\sim 5$ | $1000$ | $10$ |
| $6\sim 10$ | $2.5\times 10^4$ | $25$ |


---

---
title: "最小度限制生成树"
layout: "post"
diff: 省选/NOI-
pid: P5633
tag: ['图论', 'Kruskal 重构树', '凸完全单调性（wqs 二分）', '生成树']
---
# 最小度限制生成树
## 题目描述

给你一个有 $n$ 个节点，$m$ 条边的带权无向图，你需要求得一个生成树，使边权总和最小，且满足编号为 $s$ 的节点正好连了 $k$ 条边。
## 输入格式

第一行四个数：$n,m,s,k$

下面的 $m$ 行，每行三个整数：$u,v,w$，表示有一条 $u$ 连向 $v$ 权值为 $w$ 的边。
## 输出格式

输出一个数：满足要求的生成树的总边权。

可能会出现无解的情况，如果无解，则输出 `Impossible`。
## 样例

### 样例输入 #1
```
5 7 1 1
1 3 1
2 1 5
4 2 3
2 5 4
5 1 2
3 5 7
4 1 6
```
### 样例输出 #1
```
15
```
## 提示

### 数据范围

对于 $20\%$ 的数据，$n \le 10$，$m \le 30$。  
对于 $50\%$ 的数据，$n \le 1000$，$m \le 5000$。  
对于 $100\%$ 的数据，$1\leq s \leq n \le 5\times 10^4$，$1\leq m \le 5\times 10^5 $，$1\leq k \le 100$，$0\leq w\leq 3\times 10^4$。

### 注意

本题设有 hack 数据（Subtask $2$），计 $0$ 分，但若没有通过 hack 数据则不算通过本题。


---

---
title: "ygg发神威"
layout: "post"
diff: 省选/NOI-
pid: P5647
tag: ['树形数据结构', '线段树', '二分', '平衡树', 'O2优化', '枚举', '排序']
---
# ygg发神威
## 题目背景

ygg 发神威了，机房的萌新们瑟瑟发抖。
## 题目描述

ygg 的机房内共有 $n$ 台电脑且都被使用，为了节省机房内电脑的开销，第 $i$ 台电脑会同时被 $a_i$ 个萌新使用。每台电脑都装有一个「多人在线交流平台」，一台电脑会直接地或间接地通过这个平台与其他所有电脑连接。由于「多人在线交流平台」仍然处于测试阶段，如果一台电脑有多于一种不同的消息传输方式将消息传输到另外的任意一台电脑，就会有各种稀奇古怪的问题产生。两种消息的传输方式被认为是不同的，当且仅当传输消息所经过的直接连接的线路的集合不同，或者传输所经过的电脑的集合不同。当然，消息的传输肯定不会经过一条线路多次。为了避免这种状况，「多人在线交流平台」的线路被特殊地设计了，以使得任意两台电脑之间的传输线路唯一。同时，为了防止一台电脑负荷过大，一台电脑最多会通过「多人在线交流平台」的线路与 $p$ 台电脑相连。

原本两台通过「多人在线交流平台」的线路相连的电脑之间可以相互传输数据，可是 ygg 发现，这会允许使用两台电脑的萌新们互相发送消息，引起大规模~~考试作弊~~膜拜 ygg 的行为。所以他大发神威，切断了所有连接线路的一半。具体地，他将原本通过「多人在线交流平台」的双向线路连接的两台电脑之间的线路变成了单向线路。即，原本通过一条双向线路连接的两台电脑中，只能有一台电脑向另一台电脑发送消息，而另一台电脑不能将任何消息发送回来。

机房内的萌新们在每个时刻都有若干条消息需要传递。如果一台电脑 $i$ 能够直接或间接地通过「多人在线交流平台」的线路连接到电脑 $j$，那么使用电脑 $i$ 的 $a_i$ 个萌新中的任何一个都可以向使用电脑 $j$ 的 $a_j$ 个萌新发送消息。显然，使用同一台电脑的萌新之间的消息只需要在线下传达，不需要使用「多人在线交流平台」，因此不会计入线上发送的消息。

其实机房中的萌新们早已知道了「多人在线交流平台」的管理员密码，所以能够对其线路的连接方向做出修改。可无论他们怎么尝试，都不能恢复最开始时双向连接的状态了。机房中的萌新们当然希望能够尽可能地发送消息，所以他们想要知道，在机房的电脑仅被单向的线路连接时，每一时刻最多能有多少条消息被通过「多人在线交流平台」发送。

为了简化问题，我们假设机房内的所有萌新均能够在同一时刻发送线上消息，并且每一个萌新可以同时向多个人发送消息。

**简要题面：给一棵结点编号** $1\sim n$**，结点权值** $a_i$**，且结点度数最大为** $p$ **的树。求将树的每条边改为有向边后下式的最大值：**

$$\sum_{i=1}^{n}\sum_{j=1}^{n}a_ia_j\left[i\rightarrow j\right]$$

$\left[i\rightarrow j\right]$ **定义为：若编号为** $i$ **的结点能通过有向边到达编号为** $j$ **的结点，则值为** $1$**；否则值为** $0$**，且** $\left[i\rightarrow i\right]=0$**。**
## 输入格式

输入共 $(n+1)$ 行。

第一行两个正整数 $n$ 和 $p$，分别代表机房内的电脑数与所有电脑的负荷的最大值。  
第二行共 $n$ 个正整数，第 $i$ 个整数 $a_i$ 为使用第 $i$ 台电脑的萌新的数量。  
接下来 $(n-1)$ 行，第 $(i+2)$ 行两个整数 $u_i,v_i$ ，表示第 $u_i$ 和 $v_i$ 台电脑之间原本有一条「多人在线交流平台」的双向线路。
## 输出格式

输出一行一个整数，表示在某一时刻能够发送的消息数的最大值。
## 样例

### 样例输入 #1
```
4 2
1 2 3 4
1 2
3 2
4 1

```
### 样例输出 #1
```
35

```
## 提示

### 样例解释

能够发送的消息最多时的消息传递方向如下：

![](https://i.loli.net/2019/10/30/3AsqcyzdY25E8gP.png)

在该连接方式下发送消息最多的时刻，使用 $1$ 号电脑的 $1$ 个萌新向 $5$ 个萌新各发送了一条消息，共 $1\times5=5$ 条消息；  
使用 $2$ 号电脑的 $2$ 个萌新分别向 $3$ 个萌新各发送了一条消息，共 $2\times3=6$ 条消息；  
使用 $3$ 号电脑的 $3$ 个萌新不能向任何萌新发送线上消息，因此没有消息从该电脑发送；  
使用 $4$ 号电脑的 $4$ 个萌新分别向 $6$ 个萌新各发送了一条消息，共 $4\times6=24$ 条消息。  
因此，在某一时刻，最多可以有 $5+6+24=35$ 条线上消息被发送。   
可以使用枚举法验证，不存在一种单向的连接方式，使得在某一时刻发送的线上消息的数量能够达到 $36$ 条或更多。

### 数据范围及约定

对于 $10\%$ 的数据，$n\le10$；  
对于另外 $10\%$ 的数据，$n=p+1$；  
对于另外 $10\%$ 的数据，$p=2$；  
对于另外 $10\%$ 的数据，$p\le20$；  
对于另外 $10\%$ 的数据，$p\le40$；  

对于所有数据，$2\le n\le10^5$，$2\le p\le50$，$1\le a_i\le100$，$1\le u_i,v_i\le n$。保证给出的双向连接线路能够使任意两台电脑之间的消息传输线路唯一。保证至少有一台电脑原本通过「多人在线交流平台」连接的线路数恰好为 $p$，且没有电脑原本连接的线路数大于 $p$。


---

---
title: "[SDOI2012] 任务安排"
layout: "post"
diff: 省选/NOI-
pid: P5785
tag: ['动态规划 DP', '2012', '二分', '各省省选', '单调队列', '山东', '斜率优化']
---
# [SDOI2012] 任务安排
## 题目描述

机器上有 $n$ 个需要处理的任务，它们构成了一个序列。这些任务被标号为 $1$ 到 $n$，因此序列的排列为 $1 , 2 , 3 \cdots n$。这 $n$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$。在每批任务开始前，机器需要启动时间 $s$，而完成这批任务所需的时间是各个任务需要时间的总和。

**注意，同一批任务将在同一时刻完成**。每个任务的费用是它的完成时刻乘以一个费用系数 $C_i$。

请确定一个分组方案，使得总费用最小。
## 输入格式

第一行一个整数 $n$。
第二行一个整数 $s$。

接下来 $n$ 行，每行有一对整数，分别为 $T_i$ 和 $C_i$，表示第 $i$ 个任务单独完成所需的时间是 $T_i$ 及其费用系数 $C_i$。
## 输出格式

一行，一个整数，表示最小的总费用。
## 样例

### 样例输入 #1
```
5
1
1 3
3 2
4 3
2 3
1 4

```
### 样例输出 #1
```
153

```
## 提示

对于 $100\%$ 数据，$1 \le n \le 3 \times 10^5$，$1 \le s \le 2^8$，$ \left| T_i \right| \le 2^8$，$0 \le C_i \le 2^8$。


---

---
title: "[USACO20JAN] Falling Portals P"
layout: "post"
diff: 省选/NOI-
pid: P6010
tag: ['贪心', '2020', '倍增', '二分', 'USACO', '凸包']
---
# [USACO20JAN] Falling Portals P
## 题目描述

有 $N$（$2 \leq N \leq 2 \times 10^5$）个世界，每个世界有一个传送门。初始时，世界 $i$（对于 $1 \leq i \leq N$）位于 $x$ 坐标 $i$，$y$ 坐标 $A_i$（$1 \leq A_i \leq 10^9$）。每个世界里还有一头奶牛。在时刻 $0$，所有的 $y$ 坐标各不相同，然后这些世界开始坠落：世界 $i$ 沿着 $y$ 轴负方向以 $i$ 单位每秒的速度移动。

在任意时刻，如果两个世界在某一时刻 $y$ 坐标相同（可能是非整数时刻），传送门之间就会“同步”，使得其中一个世界的奶牛可以选择瞬间传送到另一个世界。

对于每一个 $i$，在世界 $i$ 的奶牛想要去往世界 $Q_i$（$Q_i \neq i$）。帮助每头奶牛求出如果她以最优方案移动需要多少时间。

每个询问的输出是一个分数 $a/b$，其中 $a$ 和 $b$ 为互质的正整数，或者 $-1$，如果不可能到达。
## 输入格式

输入的第一行包含一个整数 $N$。

下一行包含 $N$ 个空格分隔的整数 $A_1,A_2,\ldots,A_N$。

下一行包含 $N$ 个空格分隔的整数 $Q_1,Q_2,\ldots,Q_N$。
## 输出格式

输出 $N$ 行，第 $i$ 行包含奶牛 $i$ 的旅程的时间。
## 样例

### 样例输入 #1
```
4
3 5 10 2
3 3 2 1
```
### 样例输出 #1
```
7/2
7/2
5/1
-1
```
## 提示

### 样例解释

考虑原先在世界 $2$ 的奶牛的答案。在时刻 $2$ 世界 $1$ 和世界 $2$ 同步，所以奶牛可以前往世界 $1$。在时刻 $\frac{7}{2}$ 世界 $1$ 和世界 $3$ 同步，所以奶牛可以前往世界 $3$。

### 子任务

- 测试点 $2 \sim 3$ 满足 $N \leq 100$。
- 测试点 $4 \sim 5$ 满足 $N \leq 2000$。
- 测试点 $6 \sim 14$ 没有额外限制。


---

---
title: "洪水"
layout: "post"
diff: 省选/NOI-
pid: P6021
tag: ['动态规划 DP', '线段树', '二分', '矩阵加速', '树链剖分']
---
# 洪水
## 题目描述

小 A 走到一个山脚下，准备给自己造一个小屋。这时候，小 A 的朋友（`op`，又叫管理员）打开了创造模式，然后飞到山顶放了格水。于是小 A 面前出现了一个瀑布。作为平民的小 A 只好老实巴交地爬山堵水。那么问题来了：我们把这个瀑布看成是一个 $n$ 个节点的树，每个节点有权值（爬上去的代价）。小 A 要选择一些节点，以其权值和作为代价将这些点删除（堵上），使得根节点与所有叶子结点不连通。问最小代价。不过到这还没结束。小 A 的朋友觉得这样子太便宜小 A 了，于是他还会不断地修改地形，使得某个节点的权值发生变化。不过到这还没结束。小 A 觉得朋友做得太绝了，于是放弃了分离所有叶子节点的方案。取而代之的是，每次他只要在某个子树中（和子树之外的点完全无关）。于是他找到你。
## 输入格式

输入文件第一行包含一个数 $n$，表示树的大小。

接下来一行包含 $n$ 个数，表示第 $i$ 个点的权值。

接下来 $n-1$ 行每行包含两个数 $fr,to$ 。表示树中有一条边 $(fr,to)$ 。

接下来一行一个整数，表示操作的个数。

接下来 $m$ 行每行表示一个操作，若该行第一个数为 $Q$，则表示询问操作，后面跟一个参数 $x$ ，表示对应子树的根；若为 $C$ ，则表示修改操作，后面接两个参数 $x,t$ ，表示将点 $x$ 的权值加上 $t$。
## 输出格式

对于每次询问操作，输出对应的答案，答案之间用换行隔开。
## 样例

### 样例输入 #1
```
4
4 3 2 1
1 2
1 3
4 2
4
Q 1
Q 2
C 4 10
Q 1
```
### 样例输出 #1
```
3
1
4
```
## 提示

$1 \leq n \leq 200000,1 \leq fr,to \leq n,1 \leq x \leq n$，权值和 $t$ 均在 `int` 范围内且非负。

BZOJ4712


---

---
title: "「ACOI2020」惊吓路径"
layout: "post"
diff: 省选/NOI-
pid: P6038
tag: ['2020', '线段树', '倍增', '二分', 'O2优化', 'ST 表']
---
# 「ACOI2020」惊吓路径
## 题目背景

![T6](https://s2.ax1x.com/2020/01/12/lopZpq.png)

3 年 E 班的同学们赢得了去南方的冲绳小岛的机会，在渚打败了鹰冈之后，他们受杀老师的邀请参加“试胆大会”。

试胆大会在一个黑漆漆的洞窟里面进行。赤羽 業（Akabane Karma）现在和奧田 愛美站在洞窟的门口。突然，業想到了一个事情。。。
## 题目描述

杀老师告诉过他们，洞窟可以近似地看成 $n$ 个点的外向树，因为地形原因，所以一个点到另一个点的边是有方向的，且边的方向都是同向的。这棵树的树根为入度为 $0$ 的点。每个点都有一个惊吓值，给出每个点的惊吓值 $a_i$。

杀老师告诉他们，这个洞穴有很多惊吓路径。如果两个节点 $u,v$ 构成的路径是一条惊吓路径的话，满足以下条件：

- $v$ 一定在 $u$ 的子树中。

- $u, v$ 这条路径上的所有的点的惊吓值的或值 $\geq k$。

走过一条惊吓路径就会收到杀老师的惊喜大礼。杀老师已经提前准备好了惊喜大礼，但是業当然已经知道杀老师有一些下流的意图，更别说惊喜大礼的数量可能不够！杀老师已经承诺有多少条惊吓路径就有多少个惊喜大礼。業已经通过一些神奇的途径知道了杀老师准备的惊喜大礼的个数，现在他想知道有多少条惊吓路径，也就是杀老师最少需要准备惊喜大礼的个数。如果不够，他就会揭穿杀老师的意图。现在業当然想赚，好好捉弄一下杀老师。所以他~~作弊~~提前得到了杀老师的地图，想问这个图里面有多少条惊吓路径？
## 输入格式

第一行两个整数 $n,k$。

第二行 $n$ 个整数，表示每个点的惊吓值。

接下来 $n-1$ 行，每行有两个整数 $u,v$ 表示节点 $u,v$ 之间有一条有向边，节点 $u$ 可以到达节点 $v$，**节点 $v$ 不可以到达节点 $u$**。




## 输出格式

一行一个整数，表示这个洞穴的惊吓路径条数。
## 样例

### 样例输入 #1
```
5 10
5 9 6 4 2
3 1
3 4
1 2
1 5

```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
7 5
6 7 4 5 7 8 9
1 2
2 3
2 4
1 5
5 6
5 7

```
### 样例输出 #2
```
16
```
### 样例输入 #3
```
8 5
4 3 2 5 6 7 6 2
1 2
1 5
2 3
2 4
5 6
5 7
6 8

```
### 样例输出 #3
```
16
```
## 提示

#### 样例解释 #1

![](https://cdn.luogu.com.cn/upload/image_hosting/lqu4ejku.png)

只有两条路径满足条件：

1. $3\to 1\to 2$，这条路径的所有点的惊吓值的或值是 $6\operatorname{or}5\operatorname{or}9=15$。

2. $1 \to 2$，这条路径的所有点的惊吓值的或值是 $5\operatorname{or}9=13$。

------------
#### 数据范围 
**本题采用捆绑测试**。

- Subtask 1（10 points）：$n \leq 5 \times 10^3$，$k \leq 10^5$。    
- Subtask 2（30 points）：对于任意一条边，$v=u+1$，$n \leq 10^6$，$k,a_i \leq 10^9$。     
- Subtask 3（20 points）：$n \leq 10^5$，$k,a_i \leq 10^9$。    
- Subtask 4（40 points）：$n \leq 5 \times 10^5$，$k,a_i \leq 10^9$。

对于 $100\%$ 的数据，$1 \leq n \leq 10^6$，$1 \leq k,a_i \leq 10^9$。

------------
#### 提示
**第四个子任务中的测试点空间 256MB，其余子任务中的测试点空间 128MB。**


---

---
title: "[JSOI2015] 送礼物"
layout: "post"
diff: 省选/NOI-
pid: P6087
tag: ['2015', '二分', '各省省选', '单调队列', '江苏', '分数规划']
---
# [JSOI2015] 送礼物
## 题目背景

JYY 和 CX 的结婚纪念日即将到来，JYY 来到萌萌开的礼品店选购纪念礼物。

萌萌的礼品店很神奇，所有出售的礼物都按照特定的顺序都排成一列，而且相邻
的礼物之间有一种神秘的美感。于是，JYY 决定从中挑选连续的一些礼物，但究
竟选哪些呢？
## 题目描述

假设礼品店一共有 $N$ 件礼物排成一列，每件礼物都有它的美观度。排在第 $i\ (1\leq i\leq N)$ 个位置的礼物美观度为正整数 $A_i$。JYY 决定选出其中连续的一段，即编号为 $i,i+1,\cdots,j-1,j$ 的礼物。选出这些礼物的美观程度定义为

$$\frac{M(i,j)-m(i,j)}{j-i+K}$$

其中 $M(i,j)$ 表示 $\max\{A_i,A_{i+1},\cdots,A_j\}$，$m(i,j)$ 表示 $\min\{A_i,A_{i+1},\cdots,A_j\}$，$K$ 为给定的正整数。
由于不能显得太小气，所以 JYY 所选礼物的件数最少为 $L$ 件；同时，选得太多也不好拿，因此礼物最多选 $R$ 件。JYY 应该如何选择，才能得到最大的美观程度？由于礼物实在太多挑花眼，JYY 打算把这个问题交给会编程的你。


## 输入格式

**本题每个测试点有多组数据。**

输入第一行包含一个正整数 $T$，表示有 $T$ 组数据。

每组数据包含两行。第一行四个非负整数 $N,K,L,R$。第二行包含 $N$ 个正整数，依次表示 $A_1,A_2,\cdots,A_n$。
## 输出格式

输出 $T$ 行，每行一个非负实数，依次对应每组数据的答案，数据保证答案不
会超过 $10^3$。输出四舍五入保留 $4$ 位小数。
## 样例

### 样例输入 #1
```
1
5 1 2 4
1 2 3 4 5
```
### 样例输出 #1
```
0.7500
```
## 提示

对于 $100\%$ 的数据，$T\leq 10$，$N,K\leq 5\times 10^4$，$1\leq A_i\leq 10^8$，$2\leq L,R\leq N$。


---

---
title: "[JSOI2015] 串分割"
layout: "post"
diff: 省选/NOI-
pid: P6095
tag: ['2015', '二分', '各省省选', '江苏', '后缀数组 SA']
---
# [JSOI2015] 串分割
## 题目背景

JYY 每天都会在地铁上度过很长的时间。

为了打发时间，JYY 随手写下了一个很长的环形的数字字符串，并且陷入了沉思。
## 题目描述

JYY 写下了一个长度为 $N$ 的，仅包含 `1`，`2`，……，`9` 这 $9$ 种不同字符的环形字符串 $S$。JYY 希望把 $S$ 进行 $K$ 次切割，并分成 $K$ 个非空的子串。对于每一个子串，由于其仅包含数字，我们可以将其看成一个十进制数——因此
经过 $K$ 次切割，JYY 可以得到 $K$ 个不同的十进制数。JYY 希望他得到的这 $K$ 个数中，最大的那一个尽量小。
## 输入格式

第一行包含两个整数 $N$ 和 $K$。

第二行包含一个长度为 $N$ 的字符串 $S$。
## 输出格式

输出一行包含一个正整数，表示最佳分割方案中，JYY 所得到的那 $K$ 个数中，最大的那一个。


## 样例

### 样例输入 #1
```
4 2
4321
```
### 样例输出 #1
```
32
```
## 提示

对于 $100\%$ 的数据，$3\leq N\leq 2\times 10^5$，$2\leq K\leq N$。


---

---
title: "「EZEC-1」越狱"
layout: "post"
diff: 省选/NOI-
pid: P6436
tag: ['搜索', '图论', '二分', '最短路', 'Tarjan', '最近公共祖先 LCA']
---
# 「EZEC-1」越狱
## 题目背景

由于监狱长 PF 的疏忽，罪犯小 E 找到了机会越狱。

然而，不学无术的小 E 不懂得保密。PF 很快发现了他的计划，并对他展开了追捕。

因为小 E 自己造船，而狱长 PF 坐的是官方的船，所以在每条航道上的表现不一样，通过时间可能不同。具体见输入格式。

为了不饿肚子，小 E 准备买一个包来装食物。
## 题目描述

小 E 的逃跑路线可以被看作是在 $n$ 个岛屿上，这些岛屿由 $n-1$ 条航线两两相连。

每个岛上都有足够的补给。**假设他每在海上航行一天，就要花费一个单位的食物**。黑心老板规定，**能装 $k$ 单位的食物的背包将会卖 $k$ 万元**。

PF 可以命令在任意两个**通过时间不超过 $d$**，**并且岛 $v$ 到岛 $u$ 的航线上至少有 $q$ 个岛屿**（**不包括 $u$ 和 $v$**）的岛屿 $u$ 与 $v$ 之间建立一条双向航线，通过这条航线的时间为 $\left\lfloor \dfrac{time(u \to v)}{2}\right\rfloor$。由于经济问题，**他只能建造一条额外的航线**。

小 E 可以根据官方给出的航线（**包括新增的航线**）确认 PF 到每个岛上的**最短时间**。

PF 将会在 $t$ 时发现小 E 逃走并开始追击。

为了节省钱，同时逃脱 PF 的追捕，小 E 想请你帮他编一个程序，计算最小的 $k$，使得他能够顺利逃脱到至少 $l$ 个岛屿。

**补给不需要时间，中途抓住也算抓住，同时到达则不算。**

**在岛屿上进行补给不需要时间，可以无限进行补给，只要背包装得下。**

题意概括：

有两个人 $a$，$b$ 和一颗 $n$ 个节点组成的树，$a$ 比 $b$早出发 $t$ 秒。如果两个节点之间通过时间不超过 $d$ 则 $b$ 可以在这两点之间建一条通过时间为 $\left\lfloor \dfrac{time(u \to v)}{2}\right\rfloor$ 的线路，求一个方案使 $a$ 至少到 $l$ 个点的最短时间不比 $b$ 长，并在此基础下要求岛屿之间距离最大值尽量小。
## 输入格式

第一行五个整数，$n,t,d,l,q$，表示岛屿的数量，PF 发现的时间，建立航线要求的通过时间范围，至少要到达的岛屿数量，以及建立航线所要求的中间岛屿的数量。他们的出发点均为点 $1$ 。

接下来 $n-1$ 行，每行四个整数 $u,v,p_i,e_i$，表示岛屿 $u$ 和岛屿 $v$ 之间有一条道路。$p_i$ 表示小 E 走这条航线的时间，$e_i$ 表示 PF 走这条航线的时间。**航线为双向** 。
## 输出格式

若有解，输出共两行。

第一行一个整数 $k$，表示最小能够逃脱所需要的钱数（单位：万元）。

第二行一个整数 $r$，表示用 $k$ 万元买背包时的能跑到的岛屿数量（ $1$ 号岛也算在内）。

若无解，只需输出 "no solution" (引号不需要输出)。
## 样例

### 样例输入 #1
```
5 3 20 4 2
1 2 5 5
2 3 5 5
2 4 7 10
1 5 4 1
```
### 样例输出 #1
```
7
4
```
### 样例输入 #2
```
5 2 6 3 2
1 2 5 3
2 3 8 6
1 4 8 2
2 5 4 6
```
### 样例输出 #2
```
5
3
```
### 样例输入 #3
```
5 0 23 4 1
1 2 21 26
1 3 14 16
3 4 4 5
1 5 19 18
```
### 样例输出 #3
```
no solution
```
## 提示

【样例解释】

样例 $1$：

![](https://cdn.luogu.com.cn/upload/image_hosting/sc3vdm8k.png)

对于样例 $1$，最后能到的点为 $1,2,4,5$，最小花费为 $7$。由于狱长 PF 从点 $3\to 5$ 要经过点为 $5\to1\to2\to3$，满足中间的点数 $\ge q$，故狱长 PF 可以连边点 $3$ 和点 $5$。如果狱长 PF 选择连边 $5\to3$，那么到点 $3$ 的时间为 $3+1+ \left\lfloor \dfrac{1+5+5}{2}\right\rfloor = 9$。而小 E 到点 $3$ 的最短时间为 $5 + 5 = 10$，不满足条件，故无论 $k$ 的大小，点 $3$ 都是不可到达的。


------------

【数据范围】

| 测试点编号 | $n\le$ | $t\le$ | $p_i,e_i\le$ |    $d\le$    | 时间限制| 空间限制 |特点|
| :----------: | :----------: | :----------: | :----------: | :----------: |:-----: | :----------: |:----------: |
|$1$ | $10$ | $50$ | $50$ | $50$ |$1s$ | $128M$ |加边操作 不影响答案|
|$2$ | $16$ | $50$ | $50$ | $50$ |$1s$ | $128M$ |无|
| $3,4$ | $500$ | ${500}$ | ${500}$ |$500$ | $1s$ |  $128M$ |加边操作 不影响答案|
| $5$ | $500$ | ${500}$ | ${500}$ |${500}$ | $1s$ |  $128M$ |$q = 0$|
| $6,7$ | $500$ | ${500}$ | ${500}$ |${500}$ | $1s$ |  $128M$ |无|
| $8$ | $\small{2.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ | $1s$ | $128M$ |加边操作 不影响答案|
| $9,10$ | $\small{2.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ | $1s$ | $128M$ |$q = 0$|
| $11 \sim 14$ | $\small{2.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ | $1s$ | $128M$ |无|
| $15$ | $\small{2.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ | $1s$ | $256M$ |无|
| $16$ | $\small{7.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ |  $2s$ | $256M$ |无|
| $17$ | $\small{7.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ |  $1s$ | $256M$ |无|
| $18 \sim 20$ | $\small{7.5 \times 10^3}$ | $10^8$ | $10^8$ |$10^8$ |  $3s$ |$512M$ |无|

对于 $100 \%$ 的数据，$n\le 7.5\times 10^3$，$1\le l\le n$，$0\le t \le 10^8$，$0 \le u_i<v_i \le n$，$1\le p_i,e_i,d\le 10^8$，$0\le q\le 20$。

**保证可能新建立的双向航线方案数不超过 $5 \times 10^6$**。



---

---
title: "分散层叠算法(Fractional Cascading)"
layout: "post"
diff: 省选/NOI-
pid: P6466
tag: ['二分', 'O2优化', '排序', '分散层叠']
---
# 分散层叠算法(Fractional Cascading)
## 题目背景

`Fractional Cascading` 算法，国内多译为“分散层叠”。

本题仅提供一个简单而经典的方式给算法验证正确性，原则上会尽量卡掉比较暴力的做法，但不保证乱搞一定无法通过。
## 题目描述

给出 $k$ 个长度为 $n$ 的**有序数组**。

现在有 $q$ 个查询 : 给出数 $x$，分别求出每个数组中大于等于 $x$ 的最小的数(非严格后继)。

若后继不存在，则定义为 $0$。

每个查询的答案定义为 $k$ 个后继的**异或和**。

你需要**在线地**回答这些询问。

由于输出太多不好，给出参数 $d$，你只需要输出编号为 $d$ 的倍数的询问的答案。询问从 $1$ 开始编号。


## 输入格式

第一行四个整数 $n,k,q,d$，意义如题面所述。

后 $k$ 行，每行 $n$ 个整数，描述一个数组。**所有数组中出现过的数不重复**，保证每个数组严格递增。

后 $q$ 行，每行一个整数 $x$，描述一个询问。

输入中所得的 $x$ 需要与上一个询问的答案(**无论是否输出**)异或解密，如果这是第一个询问，则无需操作。
## 输出格式

对于编号为 $d$ 的倍数的每个询问，输出一行一个整数，表示  $k$ 个后继的异或和。
## 样例

### 样例输入 #1
```
6 3 8 1
1 4 6 7 10 20 
2 3 8 11 14 18 
5 9 12 13 15 17 
20
6
9
4
29
5
14
9
```
### 样例输出 #1
```
20
6
9
23
13
11
11
3
```
### 样例输入 #2
```
2 4 1 1
64 65
25 26
44 62
35 81
81
```
### 样例输出 #2
```
81
```
### 样例输入 #3
```
20 4 10 1
553 897 1333 1949 2261 2541 2901 3133 3209 3713 4373 4749 5761 7405 8733 10417 13013 15185 16825 16981 
246 750 806 1534 2274 2470 2486 3278 3954 4618 5306 5638 6114 6310 7106 7522 7734 8170 8702 8974 
1047 1275 2347 2711 3607 4719 5911 6051 7099 7519 8087 8435 8499 8687 8835 10151 10491 11159 11915 12483 
548 1392 2188 3260 3404 3768 5076 5668 5732 6612 7284 7492 8900 9008 9536 9768 11160 12096 12300 13100 
3133
3331
4139
2685
2229
1163
3228
2694
3913
7058
```
### 样例输出 #3
```
600
8156
676
1176
600
3800
8
432
8156
320
```
## 提示

#### 样例解释

对于样例 1，解密后的数据为:

```cpp
6 3 8 1
1 4 6 7 10 20
2 3 8 11 14 18
5 9 12 13 15 17
20
18
15
13
10
8
5
2
```
---
#### 数据规模的与约定
- 对于 $20\%$ 的数据，$k\leq 10$，$n\leq 1000$，$q\leq 1000$。
- 对于 $50\%$ 的数据，$k\leq 10$，$q\leq 2\times 10^5$。
- 对于 $100\%$ 的数据，$1 \leq k\leq 100$，$2\leq n\leq 10^4$，$q\leq 5\times 10^5$，$1\leq d\leq 10$，解密后输入中出现的数均在 $[1,5\times 10^8)$ 范围内。


---

---
title: "『JROI-1』 关系树"
layout: "post"
diff: 省选/NOI-
pid: P6589
tag: ['2020', '二分', '点分治', '平衡树', 'O2优化']
---
# 『JROI-1』 关系树
## 题目背景

小 L 有许多喜欢的游戏角色，他把这些游戏角色按照一定的关系联系起来。这些游戏角色和他们之间的关系构成了一棵树，小 L 把这棵树称之为「关系树」。
## 题目描述

关系树是由 $n$ 个点和 $n-1$ 条无向边组成的一棵树。

对于一张给定的图 $G$，定义图 $G$ 对于点集 $E$ 的 **顶点导出子图** 为点集 $E$ 和所有的 **两个端点都属于 $E$** 且属于原图 $G$ 的边组成的图。

定义一张图是 **整洁的**，当且仅当图中任意两点 $u,v$，$u$ 和 $v$ **不连通** 或 **距离不超过** $k$。

小 L 想要知道对于一组 $l,r(l \leq r)$，有多少对 $(a,b)$，满足 $l\leq a\leq b\leq r$，且所有序号在 $a$ 和 $b$ 之间（包括 $a,b$）的点组成的顶点导出子图是 **整洁的**。不仅如此，他还想问你所有的区间长度（即 $b-a+1$）之和。

因为小 L 喜欢问问题，所以你一共需要回答 $q$ 组询问。
## 输入格式

第一行有三个整数 $n$，$q$，$k$，意义如上。

接下来 $n-1$ 行，每行两个整数 $u$，$v$，描述一条边。

接下来 $q$ 行，每行两个整数 $l$，$r$，表示一组询问。
## 输出格式

$q$ 行，每行两个整数，依次为满足的 $(a,b)$ 组数和所有的区间长度之和。
## 样例

### 样例输入 #1
```
5 3 2
1 2
1 5
4 5
3 5
1 3
2 5
1 5
```
### 样例输出 #1
```
6 10
10 20
14 30
```
## 提示

#### 样例 1 解释

形成的关系树如图

![](https://cdn.luogu.com.cn/upload/image_hosting/zb12y5mq.png)

满足的 $(a,b)$ 有 $(1,1),(1,2),(1,3),(1,4),(2,2),(2,3),(2,4),(2,5),(3,3),(3,4),(3,5),(4,4),(4,5),(5,5)$。

三组询问的答案依次为 $6,10$，$10,20$，$14,30$。

--------------------------------

#### 数据规模与约定

**本题采用捆绑测试**。

+ Subtask 1 ( $10\%$ )：$n\leq 2000$。
+ Subtask 2 ( $30\%$ )：$n\leq 2\times 10^4$，形成的关系树为一条链。
+ Subtask 3 ( $60\%$ )：$n\leq 2\times 10^4$。
+ Subtask 4 ( 加强版数据，时限 $4.5s$ )：无特殊限制。

对于 $100\%$ 的测试点，保证 $1\leq n \leq 8\times 10^4$，$1\leq q \leq 10^5$，$0\leq k <n$，$1\leq u,v,l,r \leq n$。


---

---
title: "[省选联考 2020 A/B 卷] 冰火战士"
layout: "post"
diff: 省选/NOI-
pid: P6619
tag: ['2020', '线段树', '二分', '各省省选', '树状数组', '离散化']
---
# [省选联考 2020 A/B 卷] 冰火战士
## 题目背景

A 卷 D1T1，B 卷 D1T3。

时限 3s，内存 512MB。
## 题目描述

一场比赛即将开始。

每位战士有两个属性：温度和能量，有两派战士：冰系战士的技能会对周围造成降温冰冻伤害，因而要求场地温度不低于他的自身温度才能参赛；火系战士的技能会对周围造成升温灼烧伤害，因而要求场地温度不高于他的自身温度才能参赛。

当场地温度确定时，双方能够参赛的战士分别排成一队。冰系战士按自身温度从低到高排序，火系战士按自身温度从高到低排序，温度相同时能量大的战士排在前面。首先，双方的第一位战士之间展开战斗，两位战士消耗相同的能量，能量少的战士将耗尽能量退出比赛，而能量有剩余的战士将继续和对方的下一位战士战斗（能量都耗尽则双方下一位战士之间展开战斗）。如此循环，直至某方战士队列为空，比赛结束。

你需要寻找最佳场地温度：使冰火双方消耗总能量最高的温度的最高值。

现在，比赛还处于报名阶段，目前还没有任何战士报名，接下来你将不断地收到报名信息和撤回信息。其中，报名信息包含报名战士的派系和两个属性，撤回信息包含要撤回的报名信息的序号。每当报名情况发生变化（即收到一条信息）时，你需要立即报出当前局面下的最佳场地温度，以及该场地温度下双方消耗的总能量之和是多少。若当前局面下无论何种温度都无法开展比赛（某一方没有战士能参赛），则只要输出 `Peace`。
## 输入格式

第一行一个数 $Q$，表示信息的数量。

接下来 $Q$ 行，每行为 `1 t x y` $(t \in \{0, 1\}$，$x$ 和 $y$ 都是正整数 $)$ 或 `2 k`（$k$ 是正整数）：

`1 t x y` 表示一条报名信息，$t = 0$ 时报名战士是冰系，$t = 1$ 时报名战士是火系，$x$ 表示战士的自身温度，$y$ 表示战士的能量。

`2 k` 表示一条撤回信息，撤回的是第 $k$ 条信息。被撤回的信息一定是报名信息，已被撤回的信息不会再次被撤回。
## 输出格式

共 $Q$ 行，每行有两个用空格隔开的正整数，分别表示当前局面下的最佳温度和该温度下冰火双方消耗的总能量之和。
## 样例

### 样例输入 #1
```
8
1 1 103 150
1 0 100 100
1 1 102 150
1 0 103 300
2 1
1 1 101 100
1 1 104 350
1 0 100 400
```
### 样例输出 #1
```
Peace
103 200
103 200
103 300
102 200
102 200
104 700
102 1000
```
## 提示

#### 样例 1 解释
为说明方便，约定：若第 $k$ 条信息是报名信息，则该条报名信息对应战士 $k$。样例中含有战士 $1,2,3,4,6,7,8$，由于第 $5$ 条是撤回信息，所以没有战士 $5$。

下面逐个解释每个输出：

1. 只有火系战士：战士 $1$，无法比赛，输出 `Peace`。
2. 温度为 $100 \sim 103$ 都能消耗最多的能量 $200$：战士 $1$ 对阵战士 $2$ 消耗能量 $200$，最佳温度为 $103$。
3. 温度为 $100 \sim 103$ 都能消耗最多的能量 $200$：战士 $1$ 对阵战士 $2$ 消耗能量 $200$，最佳温度为 $103$。
4. 温度 $103$ 能消耗最多的能量 $300$：首先，战士 $1$ 对阵战士 $2$ 消耗能量 $200$；然后，战士 $1$ 对阵战士 $4$ 消耗能量 $100$，最佳温度为 $103$。
5. 从现在起战士 $1$ 不再存在。温度 $100 \sim 102$ 能消耗最多的能量 $200$：战士 $2$ 对阵战士 $3$ 消耗能量 $200$，最佳温度为 $102$。

#### 样例 2

见附加文件中 `icefire2.in` 与 `icefire2.ans`。

#### 数据范围

$10\%$ 的数据：$Q \leq 100$，$x \leq 10^3$。

另有 $20\%$ 的数据：$Q \leq 10^4$，$x \leq 5000$，不存在撤回信息，且输入的 $x$ 按顺序不降。

$60\%$ 的数据（包含上述 $20\%$，下同）：$Q \leq 2 \times 10^5$，$x \leq 2 \times 10^5$。

$90\%$ 的数据：$Q \leq 2 \times 10^6$，$x \leq 2 \times 10^6$。

$100\%$ 的数据：$1 \leq Q \leq 2 \times 10^6$，$1 \leq x \leq 2 \times 10^9$，所有 $y$ 之和不超过 $2 \times 10^9$，保证不存在 $t, x, y$ 完全相同的两个战士。


---

---
title: "「JYLOI Round 1」常规"
layout: "post"
diff: 省选/NOI-
pid: P6638
tag: ['二分', '可持久化线段树']
---
# 「JYLOI Round 1」常规
## 题目描述

LS 制定了 $n$ 项常规，其中第 $i$ 项常规制定的时间是 $a_i$。

对于第 $i$ 项常规，从第 $i$ 项常规的制定时间 $a_i$ 后的每 $k$ 秒，他都要做一次第 $i$ 项常规，他做一次常规的时间可以忽略不计。

现在 LS 想给你 $m$ 个询问，每个询问用一个区间 $[l_i, r_i]$ 来表示，问你在第 $l_i$ 到 $r_i$ 秒，他一共做了多少次常规。
## 输入格式

输入的第一行是一个为 0 或 1 的整数 $type$，在接下来会用到。

对于 $type = 0$ 的情况，接下来有一行三个正整数 $n$、$m$、$k$，含义如题所述。

接下来有一行 $n$ 个正整数，这一行中的第 $i$ 个正整数表示的是 $a_i$，$a_i$ 的含义如题所述。

接下来有 $m$ 行，第 $i$ 行表示的是第 $i$ 个询问是一个区间 $[l_i, r_i]$，$l_i$ 和 $r_i$ 的含义如题所述。对于 $type = 0$ 的所有询问，我们都没有进行加密。

对于 $type=1$ 的情况，接下来有一行四个正整数 $n$、$m$、$k$ 和 $mod$，$n$、$m$、$k$ 的含义如题所述，其中 $mod$ 是一个会在下面用到的参数。

接下来有一行 $n$ 个正整数，这一行中的第 $i$ 个正整数表示的是 $a_i$，$a_i$ 的含义如题所述。

接下来有 $m$ 行，这 $m$ 行中的第 $i$ 行有两个正整数 $l_i$ 和 $r_i$，表示第 $i$ 个询问是一个区间 $[l_i, r_i]$，$l_i$ 和 $r_i$ 的含义如题所述。特别地，我们加密了第 2 至第 $m$ 个询问，对于第 $i(2 \leq i \leq m)$ 个询问，解密后的：
$$l_i = \min((l_i + \text{lastans} - 1) \;\text{mod}\; mod + 1, (r_i + \text{lastans} - 1) \;\text{mod}\; mod + 1)$$

$$r_i=\max((l_i + \text{lastans} - 1) \;\text{mod}\; mod + 1, (r_i + \text{lastans} - 1) \;\text{mod}\; mod + 1)$$

其中 $\text{lastans}$ 是第 $(i - 1)$ 个询问的答案，对于第 2 到第 $m$ 个询问，你的程序需要回答解密后的询问所对应的答案。

**特别地，第一个询问没有被加密。**
## 输出格式

输出共有 $m$ 行，对于每个解密后的询问输出一行，输出中的第 $i$ 行表示的是第 $i$ 个询问的答案。
## 样例

### 样例输入 #1
```
0
5 10 3
1 2 3 4 5
1 5
2 5
3 5
4 5
5 5
10 10
20 30
10 30
1 30
5 30
```
### 样例输出 #1
```
2
2
2
2
1
2
18
35
43
42
```
### 样例输入 #2
```
1
5 10 3 100
1 2 3 4 5
1 5
2 5
3 5
4 5
5 5
10 10
20 30
10 30
1 30
5 30
```
### 样例输出 #2
```
2
5
5
3
2
1
18
35
50
44
```
## 提示

### 样例 2 说明

解密后的询问分别为 [1, 5]、[4, 7]、[8, 10]、[9, 10]、[8, 8]、[12, 12]、[21, 31]、[28, 48]、[36, 65]、[55, 80]，因此可以得出答案。

____________

### 数据范围

对于 $100\%$ 的数据，满足 $type \in \{0, 1\}; 1 \leq n, m \leq 10^5; 0 \leq l_i \leq r_i \leq 10^9; 0 \leq a_i \leq 10^9; 1 \leq k, mod \leq 10^9$。

子任务 1（有 10 个测试点，每个测试点 1 分，共 10 分）：$type = 0; n, m, k \leq 10^3; r_i \leq 10^3$。

子任务 2（有 10 个测试点，每个测试点 1 分，共 10 分）：$type = 0; n, m \leq 10^3$。

子任务 3（有 2 个测试点，每个测试点 5 分，共 10 分）：$type = 0, r_i \leq 10^5,k = 1$。

子任务 4（共 20 分）：$type = 0, k \leq 10^5, r_i \leq 10^5$。

子任务 5（共 30 分）：$type = 0$。

子任务 6（共 20 分）：无特殊限制。

对于子任务 4、5、6，分别捆绑计分（即你需要通过一个子任务内的所有测试点才能够拿到这个子任务的分数），本题总共 50 个测试点、100 分。

## 题目来源

「JYLOI Round 1」 D

Idea / Solution / Data ：abcdeffa


---

---
title: "[COCI 2019/2020 #3] Lampice"
layout: "post"
diff: 省选/NOI-
pid: P7206
tag: ['2019', '二分', '哈希 hashing', 'COCI（克罗地亚）']
---
# [COCI 2019/2020 #3] Lampice
## 题目描述

Mirko 用 $N$ 个 LED 灯来装饰圣诞树，它们的颜色是已知的，并且通过 $(N-1)$ 条电线连接。

Mirko 在大功告成后，仔细地品味自己的作品。他被一种叫作「回文段」的特殊图案所吸引。「回文段」指一条从 $u$ 至 $v$ 的路径，它满足从 $u$ 到 $v$ 的路径所包含灯的颜色等于从 $v$ 到 $u$ 的路径所包含灯的颜色。

求出圣诞树中最长的「回文段」。
## 输入格式

第一行，输入一个整数 $N$，表示 LED 灯的数量。

第二行，输入一个由 $N$ 个英文小写字母组成的字符串，其中第 $i$ 个字母代表第 $i$ 个灯的颜色。

接下来的 $(N-1)$ 行，每行输入两个整数 $A,B$，表示 $A,B$ 之间用一条电线连接。
## 输出格式

输出圣诞树中最长的「回文段」。
## 样例

### 样例输入 #1
```
7
imanade
1 2
2 3
3 4
4 5
5 6
6 7
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
4
aabb
1 2
1 3
3 4
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
8
acdbabcd
1 6
6 7
6 3
3 4
4 5
5 2
8 5
```
### 样例输出 #3
```
5
```
## 提示

#### 数据范围及约定

| Subtask | 分值 | 数据范围及约定 |
| :----------: | :----------: | :----------: |
| $1$ | $17$ | $N \le 3000$ |
| $2$ | $25$ | 第 $i$ 个与第 $i+1$ 个灯直接相连（$1 \le i \lt N$） |
| $3$ | $31$ | 至多有 $100$ 个灯与另一个灯直接相连 |
| $4$ | $37$ | 无 |

对于 $100\%$ 的数据，$1 \le N \le 5 \times 10^4, 1 \le A,B \le N, A \neq B$。

#### 说明

**本题分值按 COCI 原题设置，满分 $110$。**

**题目译自 [COCI2019-2020](https://hsin.hr/coci/archive/2019_2020/) [CONTEST #3](https://hsin.hr/coci/archive/2019_2020/contest3_tasks.pdf)  _T4 Drvca_ 。**


---

---
title: "『MdOI R4』Balance"
layout: "post"
diff: 省选/NOI-
pid: P7340
tag: ['数学', '二分', 'Special Judge', 'O2优化', '洛谷月赛']
---
# 『MdOI R4』Balance
## 题目背景

可怜的 $\rm\textcolor {grey}{JohnVictor}$ 玩的卡组在平衡性调整中被削弱了，现在他掉了很多杯，他想知道什么样的一个世界才是真正平衡的。

于是就有了这题。
## 题目描述

给定长度为 $n$ 的，由整数构成的数组 $a,b,p,q$，并定义函数 $f(i,j)=\dfrac{a_i+b_j}{p_i+q_j}(1\le i,j\le n)$。

再给定两个整数 $x,y$，你需要求出一对 $(i,j)$，使得 $f(i,j)$ 在所有 $f(i,t)(t=1,2,\cdots,n)$ 中是第 $x$ 小的，在所有 $f(s,j)(s=1,2,\cdots,n)$ 中是第 $y$ 小的。 

在本题中，我们称一个数 $x$ 在序列 $c_{1\ldots n}$ 中是第 $k$ 小的，当且仅当在 $c$ 中有且仅有 $\alpha$ 个数 $y$ 满足 $y<x$，且有且仅有 $\beta$ 个数 $y$ 满足 $y\le x$，同时 $\alpha<k\le \beta$。

如果不存在这样的 $(i,j)$，请输出 `0 0`。

如果有多组这样的 $(i,j)$，输出任意一组即可。

由于平衡性的问题不是一次就能问清楚的，所以出题人会问你多次。
## 输入格式

**本题有多组数据。**

第一行一个整数 $T$ 表示数据组数，对于每组数据：

第一行三个正整数 $n,x,y$。

接下来 $n$ 行，每行 $4$ 个整数。第 $i$ 行的四个整数为 $a_i,b_i,p_i,q_i$。
## 输出格式

$T$行，每一行两个整数，表示你找出的 $(i,j)$。
## 样例

### 样例输入 #1
```
1
3 3 2
2 4 1 4
10 4 3 4
1 3 1 3

```
### 样例输出 #1
```
1 3

```
## 提示

【样例解释 #1】
- $f(1,1)=1.2;f(1,2)=1.2;f(1,3)=1.25$。
- $f(2,1)=2;f(2,2)=2;f(2,3)=2\frac{1}{6}$。
- $f(3,1)=1;f(3,2)=1;f(3,3)=1$。

$f(1,3)$ 在 $f(1,1),f(1,2),f(1,3)$ 中是第 $3$ 小的，$f(1,3)$ 在 $f(1,3),f(2,3),f(3,3)$ 中是第 $2$ 小的。

【数据规模与约定】

**本题采用捆绑测试**

| 子任务编号 | $\sum n\le$         | $\vert a_i\vert ,\vert b_i\vert ,p_i,q_i\le$ | $(x,y)= $  | 分值  |
| ---------- | -------------- | -------------------- | ---------- | ----- |
| $1$        | $5\times 10^3$ | 无特殊限制           | 无特殊限制 | $10$  |
| $2$        | 无特殊限制     | $3$                  | 无特殊限制 | $10$  |
| $3$        | $10^5$         | 无特殊限制           | $(1,n)$        | $30 $ |
| $4$        | $10^5$         | 无特殊限制           | 无特殊限制 | $20$  |
| $5$        | 无特殊限制     | 无特殊限制           | 无特殊限制 | $30$  |

对于 $100\%$ 的数据，$1 \le x,y \le n \le 5 \times 10^5$，$\sum n \le 5 \times 10^5$，$|a_i|,|b_i|\le 10^9$，$0<p_i,q_i\le 10^9$，其中 $\sum n $ 表示所有数据中 $n$ 的和。

【提示与帮助】

本题读入量较大，请选手选择较快的读入方式。


---

---
title: "「PMOI-1」中位数"
layout: "post"
diff: 省选/NOI-
pid: P7357
tag: ['树形数据结构', '二分', 'O2优化', '可持久化线段树', '可持久化']
---
# 「PMOI-1」中位数
## 题目描述

给定一棵以 $1$ 为根的包含 $n$ 个节点的**有根树**。第 $i$ 个节点有点权 $a_i$。

定义函数 $f(u,v)$ 表示从 $u$ 到 $v$ 经过的所有节点的点权的**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\frac{t+1}2\right\rceil$ 小的数。

定义函数 $\text{cover}(x_1,y_1,x_2,y_2)$ 表示从 $x_1$ 到 $y_1$ 的路径是否完全覆盖了从 $x_2$ 到 $y_2$ 的路径。如果完全覆盖，则 $\text{cover}(x_1,y_1,x_2,y_2)=1$，否则  $\text{cover}(x_1,y_1,x_2,y_2)=0$。

你需要依次处理 $q$ 次操作，按照以下格式给出：

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ **异或**；

` 2 u v`：表示一次询问，需要你求出 $\max\limits_{1\le i\le n,1\le j\le n}\{\text{cover}(i,j,u,v)f(i,j)\}$。

对于第二类操作，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

你需要对于每个第二类操作，输出对应的值。
## 输入格式

第一行两个正数 $n$ 和 $q$ ，分别表示树的节点数与询问次数。

第二行 $n$ 个整数，第 $i$ 个数表示第 $i$ 个节点的点权 $a_i$。

下面 $n-1$ 行，每行两个整数 $x,y$ ，描述一条连接 $x$ 与 $y$ 的边。

下面 $q$ 行，每行先输入一个整数 $opt$ ，表示本次是是操作还是询问。 若 $opt=1$ ，则这是一次操作，且接下来会输入一个整数 $u$ ；若 $opt=2$ ，则这是一次询问，且接下来会输入两个整数 $u,v$ 。其具体意义见【题目描述】。
## 输出格式

对于每次询问输出一行，即对应询问的答案。
## 样例

### 样例输入 #1
```
8 3
4 2 3 4 2 1 4 3
1 2
1 3
2 4
2 5
3 6
6 7
6 8
2 4 8
1 3 
2 2 3
```
### 样例输出 #1
```
3
4
```
## 提示

【样例解释】

第一次是询问。显然，只有 $(i=4,j=8)$ 满足 $\text{cover}(i,j,u,v)=1$。此时 $f(i,j)=3$。

第二次是操作。将 $3$ 号节点的点权改为了 $2$。

第三次是询问。当 $i=4,j=3$ 时，$\text{cover}(i,j,u,v)=1$ 且 $f(i,j)=4$ 。不难发现，对于其他所有满足 $\text{cover}(i,j,u,v)=1$ 的节点对 $(i,j)$，均没有 $f(i,j) >4$。

【数据范围】
- Subtask1（8pts）：$n,q\le50$；
- Subtask2（12pts）：$n,q\le2\times10^3$；
- Subtask3（16pts）：$n,q\le4\times10^4$；
- Subtask4（10pts）：保证树的形态随机生成；
- Subtask5（12pts）：保证没有 $1$ 操作；
- Subtask6（12pts）：保证每次询问的 $u,v$ 都是叶子节点；
- Subtask7（30pts）：无特殊限制。

Subtask4 的随机方式为 ：随机生成一个的排列 $p$，对于 $i\in[2,n]$，$p_i$ 向 $p_1,p_2,...,p_{i-1}$ 中等概率随机的一个点连边。

对于 $100\%$ 的数据满足，$1\le n,q,a_i \le 10^5$，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$ 。


---

---
title: "[THUPC 2017] 天天爱射击"
layout: "post"
diff: 省选/NOI-
pid: P7424
tag: ['2017', '树状数组', '可持久化线段树', '可持久化', '分块', '整体二分', 'THUPC']
---
# [THUPC 2017] 天天爱射击
## 题目描述

小 C 爱上了一款名字叫做《天天爱射击》的游戏。如图所示，这个游戏有一些平行于 $x$ 轴的木板。现在有一些子弹，按顺序沿着 $y$ 轴方向向这些木板射去。第 $i$ 块木板被 $S_i$ 个子弹贯穿以后，就会碎掉消失。一个子弹可以贯穿其弹道上的全部木板，特别的，如果一个子弹触碰到木板的边缘，也视为贯穿木板。

小 C 现在知道了游戏中 $n$ 块木板位置，以及知道了 $m$ 个子弹射击位置。现在问你每个子弹射出去以后，有多少木板会碎掉？
## 输入格式

从标准输入读入数据。

第一行两个整数 $n$ 和 $m$，表示木板数量和子弹数量。其中 $1\le n,m\le 2\times 10^5$。

接下来 $n$ 行，每行三个整数 $x_1,x_2,s$，表示每块木板的左端点 $x$ 坐标、右端点 $x$ 坐标，以及贯穿多少次会碎掉。其中保证 $1\le x_1\le x_2\le2\times 10^5,1\le s\le 2\times 10^5$。

接下来 $m$ 行，每行一个整数 ，表示每个子弹的 $x$ 坐标。子弹按照发射顺序给出。其中保证 $1\le x\le2\times 10^5$。
## 输出格式

输出到标准输出。

$m$ 行，每行一个整数。表示每颗子弹射出去后，有多少木板碎掉。
## 样例

### 样例输入 #1
```
3 2
1 3 1
2 4 2
3 4 1
2
3
```
### 样例输出 #1
```
1
2
```
## 提示

![](https://cdn.luogu.com.cn/upload/image_hosting/ocqlbnl3.png)
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。

$\text{upd}2021.7.6$：感谢 @[jiangbowen](https://www.luogu.com.cn/user/366807) 提供的一组 hack 数据，不计分，但若不通过 hack 数据则不算通过此题。


---

---
title: "[THUPC 2017] 组合数问题"
layout: "post"
diff: 省选/NOI-
pid: P7430
tag: ['数学', '2017', '二分', 'Special Judge', 'THUPC']
---
# [THUPC 2017] 组合数问题
## 题目描述

小葱是一名勇士。

小葱踏上了拯救世界的征途。

小葱面前有 $N$ 只大葱怪。

大葱怪很厉害，第 $i$ 只大葱怪攻击力为 $a_i$，防御力为 $d_i$。

小葱的攻击力为 $A$，防御力为 $D$。

小葱打掉第 $i$ 只大葱怪的代价是 $A\times d_i+D\times a_i$。

小葱打倒很多只大葱怪的代价不是打倒每一只大葱怪的代价之和，而是最大值。

小葱现在需要打倒 $R$ 只大葱怪。

神葱是葱的神，神葱会对小葱打倒 $R$ 只大葱怪做出评价。神葱对小葱打倒 $R$ 只大葱的评价为小葱打倒这 $R$ 只大葱怪所需要的代价除以小葱以同样的攻击力和防御力打倒所有 $N$ 只大葱怪的代价。

神葱是葱的神，所以神葱会在小葱选择了 $R$ 只要被打倒的大葱怪后，设定小葱的攻击力和防御力，使得小葱得到的评价最低。

神葱不希望这个值是负的，所以如果这个值是负的，神葱会强制把它变为 $0$。

小葱是一名勇士。

小葱不会屈服。

小葱需要选择出 $R$ 只大葱怪，使得自己能够从神葱那里得到的评价最高。

小葱求这个评价值。

小葱很善良，所以小葱为你写出了评价值的数学表示：
$$\max_{S\subseteq [N],|S|=R}\Big\lbrack\min_{A,D\in\Z^+}\dfrac{\max_{i\in S}(A\times d_i+D\times a_i)}{\max_{i\in [N]}(A\times d_i+D\times a_i)}\Big\rbrack$$
## 输入格式

测试点包含多组数据。

对于每组数据，第一行两个整数代表 $N,R$。

接下来 $N$ 行每行两个实数分别代表 $a_i,d_i$。
## 输出格式

对于每组数据，一行一个实数代表答案，你需要保证你的答案与标准答案的误差不超过 $10^{-6}$。
## 样例

### 样例输入 #1
```
3 3
1 3
2 5
2 3
5 1
1 5
2 4
3 3
4 2
5 1
```
### 样例输出 #1
```
1.000000
0.600000
```
## 提示

$1\le R\le N\le 10^3,a_i,d_i$ 均为正整数，数据组数不超过 $50$ 组，所有攻击力和防御力都是正整数。
#### 版权信息
来自 THUPC（THU Programming Contest，清华大学程序设计竞赛）2017。


---

---
title: "[省选联考 2021 A/B 卷]  宝石"
layout: "post"
diff: 省选/NOI-
pid: P7518
tag: ['倍增', '二分', '各省省选', '2021', '数据结构', 'O2优化', '可持久化线段树']
---
# [省选联考 2021 A/B 卷]  宝石
## 题目背景

**链的部分分官方数据有误。这里已经修改，如仍有误请反馈。**
## 题目描述

欧艾大陆上有 $n$ 座城市，城市从 $1 \sim n$ 编号，所有城市经由 $n - 1$ 条无向道路互相连通，即 $n$ 座城市与 $n - 1$ 条道路构成了一棵树。

每座城市的集市上都会出售宝石，总共有 $m$ 种不同的宝石，用 $1 \sim m$ 编号。$i$ 号城市的集市出售的是第 $w_i$ 种宝石，一种宝石可能会在多座城市的集市出售。

K 神有一个宝石收集器。这个宝石收集器能按照顺序收集至多 $c$ 颗宝石，其收集宝石的顺序为：$P_1, P_2, \ldots , P_c$。更具体地，收集器需要先放入第 $P_1$ 种宝石，然后才能再放入第 $P_2$ 种宝石，之后再能放入第 $P_3$ 种宝石，以此类推。其中 $P_1, P_2, \ldots , P_c$ 互不相等。

K 神到达一个城市后，如果该城市的集市上出售的宝石种类和当前收集器中需要放入的种类相同，则他可以在该城市的集市上购买一颗宝石并放入宝石收集器中；否则他只会路过该城市什么都不做。

现在 K 神给了你 $q$ 次询问，每次给出起点 $s_i$ 与终点 $t_i$，他想知道如果从 $s_i$ 号城市出发，沿最短路线走到 $t_i$ 号城市后，他的收集器中最多能收集到几个宝石？（在每次询问中，收集器内初始时没有任何宝石。起点与终点城市集市上的宝石可以尝试被收集）
## 输入格式

第一行，包含三个正整数 $n, m, c$，分别表示城市数，宝石种类数，收集器的容量。  
第二行，包含 $c$ 个正整数 $P_i$。数据保证 $1 \le P_i \le m$ 且这些数互不相等。  
第三行，包含 $n$ 个正整数 $w_i$，表示每个城市集市上出售的宝石种类。  
接下来 $n - 1$ 行，每行两个正整数 $u_i, v_i$，表示一条连接 $u_i$ 和 $v_i$ 号城市的道路。  
接下来一行，包含一个正整数 $q$，表示询问次数。  
接下来 $q$ 行，每行两个正整数 $s_i, t_i$，表示该次询问的起点与终点。
## 输出格式

按输入顺序输出 $q$ 行，每行一个整数，表示询问的答案。
## 样例

### 样例输入 #1
```
7 3 3
2 3 1
2 1 3 3 2 1 3
1 2
2 3
1 4
4 5
4 6
6 7
5
3 5
1 3
7 3
5 7
7 5

```
### 样例输出 #1
```
2
2
2
3
1

```
### 样例输入 #2
```
见附件中的 gem/gem2.in
```
### 样例输出 #2
```
见附件中的 gem/gem2.ans
```
### 样例输入 #3
```
见附件中的 gem/gem3.in
```
### 样例输出 #3
```
见附件中的 gem/gem3.ans
```
## 提示

**【数据范围】**

对于所有测试数据：$1 \le n, q \le 2 \times {10}^5$，$1 \le c \le m \le 5 \times {10}^4$，$1 \le w_i \le m$。

每个测试点的具体限制见下表：

| 测试点编号 | $n, q \le$ | 特殊限制 |
|:-:|:-:|:-:|
| $1 \sim 2$ | $10$ | 无 |
| $3 \sim 5$ | $1000$ | 无 |
| $6 \sim 10$ | $2 \times {10}^5$ | $m \le 300$ |
| $11 \sim 14$ | $2 \times {10}^5$ | $u_i = i$，$v_i = i + 1$ |
| $15 \sim 20$ | $2 \times {10}^5$ | 无 |


---

---
title: "[JOISC 2021] 道路の建設案 (Road Construction) (Day2)"
layout: "post"
diff: 省选/NOI-
pid: P7561
tag: ['二分', '堆', '2021', '优先队列', 'K-D Tree', 'JOI（日本）', '双指针 two-pointer']
---
# [JOISC 2021] 道路の建設案 (Road Construction) (Day2)
## 题目背景

10s,2048M
## 题目描述

JOI 国是一个 $x\times y$ 的二维平面，王国里有 $n$ 个城镇，分别编号为 $1, 2, \cdots, n$，其中第 $i$ 个城镇的 **坐标** 为 $(x_i, y_i)$。

在 JOI 国，正计划修建连接两座城镇的路（下文简称：**「修路的项目」**），路有 $k$ 条。连接两个不同的城镇 $a$ 和 $b$ 将花费 $|x_a − x_b| + |y_a − y_b|$ 元。若有一条连接 $c$，$d$ 的路，则不需要也不可以在建一条连接 $d$，$c$ 的路，因为它们是相同的。

你要管理这个「修路的项目」，为了计算花费情况，你得弄明白连接一些城镇所需的花费。在这 $\dfrac{n\cdot(n-1)}{2}$ 条道路中，你想了解最便宜的 $k$ 条道路的花费。

给你城镇的坐标以及 $k$，请计算最便宜的 $k$ 条路所需要的钱。
## 输入格式

输入数据共 $n+1$ 行。

第一行，$2$ 个正整数 $n, k$，$n$ 表示城镇的数量，$k$ 含义见 **「题目描述」** 部分。

接下来的第 $2 \sim n+1$ 行，每行 $2$ 个正整数，分别是 $x_i$ 和 $y_i$，其中 $1\le i \le n$，表示第 $i$ 个城镇的坐标。
## 输出格式

输入数据共 $k$ 行。

对于第 $k$ 行，有一个整数表示第 $k$ 便宜的路需要的日元。
## 样例

### 样例输入 #1
```
3 2
-1 0
0 2
0 0

```
### 样例输出 #1
```
1
2

```
### 样例输入 #2
```
5 4
1 -1
2 0
-1 0
0 2
0 -2

```
### 样例输出 #2
```
2
2
3
3

```
### 样例输入 #3
```
4 6
0 0
1 0
3 0
4 0

```
### 样例输出 #3
```
1
1
2
3
3
4

```
### 样例输入 #4
```
10 10
10 -8
7 2
7 -8
-3 -6
-2 1
-8 6
8 -1
2 4
6 -6
2 -1

```
### 样例输出 #4
```
3
3
4
5
6
6
6
7
7
7

```
## 提示

#### 样例 #1 解释
有 $\dfrac{3 \times 2}{2} = 3$ 种方案。

- 城镇 $1 \to$ 城镇 $2$，$|(-1)-0|+|0-2| = 3$ 日元。
- 城镇 $1 \to$ 城镇 $3$，$|(-1)-0|+|0-0| = 1$ 日元。
- 城镇 $2 \to$ 城镇 $3$，$|0-0|+|2-0| = 2$ 日元。

将其进行排序为 $1,2,3$，所以输出是 $1$ 和 $2$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #2 解释

有 $\dfrac{5 \times 4}{2} = 10$ 种方案。

将钱数排序后是 $2, 2, 3, 3, 3, 3, 4, 4, 4, 4$。

本样例满足 Subtask $1, 4, 5, 6$。

#### 样例 #3 解释

本样例满足 Subtask $1, 2, 4, 5, 6$。

#### 样例 #4 解释

本样例满足 Subtask $1, 4, 5, 6$。

#### 数据范围与约定

**本题采用 Subtask 计分法。**

| Subtask | 分值占比百分率 | $n$ | $k$ | $y_i$ |
| :----: | :----: | :----: | :----:| :----: |
| $1$ | $5\%$ | $\le 10^3$ | / | / |
| $2$ | $6\%$ | / | / | $=0$ |
| $3$ | $7\%$ | / | $=1$ | / |
| $4$ | $20\%$ | / | $\le 10$ | / |
| $5$ | $27\%$ |  / | $\le 10 ^ 5$ | / |
| $6$ | $35\%$ | / | / | / |

**注：斜线表示无特殊限制。**

对于 $100\%$ 的数据：
- $2 \le n \le 2.5 \times 10^5$；
- $1 \le k \le \min(2.5\times 10^5,\ \dfrac{n\cdot(n-1)}{2}$)；
- $-10^9 \le x_i, y_i \le 10^9$，且 $1 \le i \le n$；
- $(x_i,y_i)\not = (x_j, y_j)$ 且 $1 \le i < j \le n$。

#### 说明

本题译自 [第２０回日本情報オリンピック 2020/2021春季トレーニング合宿 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/index.html) [競技 2 -](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/2021-sp-d2-notice.pdf) [T2 日文题面](https://www.ioi-jp.org/camp/2021/2021-sp-tasks/day2/road_construction.pdf)。



---

---
title: "「PMOI-3」简单模拟题"
layout: "post"
diff: 省选/NOI-
pid: P7577
tag: ['二分', 'O2优化', '可持久化线段树']
---
# 「PMOI-3」简单模拟题
## 题目描述

给定一个长度为 $n$ 的序列 $s$。

$q$ 次询问，每个询问形如 `a b c d e f`，需要你求出下面式子的值：
$$\sum_{L=a}^{b}[e\le G(F(L,c),F(L,c+1),\cdots,F(L,d))\le f]$$
这里 $F(l,r)$ 表示 $s$ 序列区间 $[l,r]$ 中不同的数的个数，$G(x_1,x_2,\cdots,x_k)$ 表示 $x_1,x_2,\cdots,x_k$ 中不同的数的个数。
## 输入格式

第一行两个整数 $n,q$，表示序列长度与命令次数。

第二行输入 $n$ 个整数，第 $i$ 个数表示 $s_i$。

下面 $q$ 行，每行输入 $6$ 个数 $a',b',c',d',e,f$。令上一次询问的答案为 $\text{lastans}$（特别的，若这是第一次询问，则 $\text{lastans}=0$），则本次询问中

$a=(a'+\text{lastans})\bmod n+1\\$
$b=(b'+\text{lastans})\bmod n+1\\$
$c=(c'+\text{lastans})\bmod n+1\\$
$d=(d'+\text{lastans})\bmod n+1\\$

**注意，你需要将 $a,b,c,d$ 重新排序使得 $a\le b\le c\le d$。**
## 输出格式

对于每次询问，依次输出答案。
## 样例

### 样例输入 #1
```
3 1
2020 2021 2020
3 3 2 2 1 1
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
10 3
2 2 4 3 5 3 5 4 1 2
3 5 2 4 1 2
5 7 2 9 2 4
1 3 1 8 1 3
```
### 样例输出 #2
```
2
4
4
```
## 提示

【样例一解释】

第一次询问中，$a=1,b=1,c=3,d=3,e=1,f=1$。

不难得到 $G(F(1,3))=1$，且 $e\le G(F(1,3))\le f$，所以答案为 $1$。

【样例二解释】
| 询问编号 | $a$ | $b$ | $c$ | $d$ | $e$ | $f$ |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| ① | 3 | 4 | 5 | 6 | 1 | 2 |
| ② | 2 | 5 | 8 | 10 | 2 | 4 |
| ③ | 3 | 6 | 6 | 8 | 1 | 3 |

【数据范围】

**本题采用捆绑测试**。
- Subtask1（10pts）：$n,q\le500$，$1\le s_i\le10^6$；
- Subtask2（15pts）：$n,q\le3\times10^3$；
- Subtask3（20pts）：$b-a\le20$；
- Subtask4（25pts）：$n,q\le10^5$；
- Subtask5（30pts）：无特殊限制。

对于 $100\%$ 的数据满足，$1\le n,q\le3\times10^5$，$0\le|s_i|\le10^9$，对于所有询问，$1\le a,b,c,d\le n$，$0\le e\le f\le n$。

【提示】
1. 本题中，$[x \le y \le z]$ 表示 $y$ 是否 $\in[x,z]$。如果在该区间内，则值为 $1$；否则为 $0$。

2. 输入量较大，请采用较快的读入方式。


---

---
title: "[AHOI2021初中组] 地铁"
layout: "post"
diff: 省选/NOI-
pid: P7624
tag: ['二分', '2021', '安徽', '图论建模', '负权环', '差分约束']
---
# [AHOI2021初中组] 地铁
## 题目背景

AHOI2021 初中组 T4

**你可以选择跳过背景部分。**

小可可发现自己所学算法在生活中其实无大用，感觉十分沮丧。小雪见状还是嘀咕了几句“应该还是有用的吧”。

“不过没用又怎么样呢？算法只不过是一块名牌大学的敲门砖罢了。”

“你这话我就不同意了。跳蚤国王曾经和我说过，以后科研或者工作中我们还会和信息学竞赛中的某些东西重逢，虽然可能不会再有信息学竞赛这么难。

“除开功利的因素之外，搞信息学竞赛还是能享受到很多思考的乐趣的。”

“你说的也对。每次我在考场上不会做质疑这题是不是有问题的时候，考后看题解总是懊恼又快乐——这么自然的思路我怎么想不到呢！”

一颗理论计算机科学家的种子悄悄萌芽。

沙尘暴突然神奇般的散去了。实在坐不下去的两人决定出门坐地铁瞎逛，随性下车。即使没有刻意为之，小雪在地铁上却想出了一个有意思的问题，你能解决吗？
## 题目描述

B 市的地铁历史悠久，小雪和小可可乘坐的 X 号线是环形路线，上面分布着 $n$ 个车站，**相邻两个车站之间的铁路长度为正整数**。现在小雪进行了一些观察，得到了 $m$ 条信息，第 $i$ 条信息是如下形式之一：

1. 环上顺时针由 $S_i$ 到 $T_i$ 的一段距离不小于一个给定的值 $L_i$（$S_i$ 和 $T_i$ 是两个车站）；
2. 环上顺时针由 $S_i$ 到 $T_i$ 的一段距离不大于一个给定的值 $L_i$。

小雪想要你计算最后 X 线地铁的总长度有多少种不同的合法取值。
## 输入格式

第一行两个空格隔开的正整数 $n$ 和 $m$。

下面 $m$ 行，第 $i$ 行四个空格隔开的正整数 $type_i,S_i,T_i,L_i$，其中 $type_i \in \{1,2\}$ 表示信息的类型。车站顺时针编号为从 1 开始的连续整数。保证 $1 \le S_i,T_i \le n$ 且 $S_i \ne T_i$。
## 输出格式

仅一行一个整数，表示所求答案。如果有无穷种取值，请输出 `-1`。

**保证答案不为 0，即至少有一种可能的方案。**
## 样例

### 样例输入 #1
```
4 6
1 1 3 3
2 2 4 5
1 2 4 4
1 3 1 4
2 4 2 5
1 4 2 3
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
3 2
2 1 2 1
2 2 3 1
```
### 样例输出 #2
```
-1
```
### 样例输入 #3
```
见附加文件的 subway3.in。 
```
### 样例输出 #3
```
见附加文件的 subway3.ans。
```
## 提示

【样例 1 解释】

定义数组 $d[1..4]$，其中 $d[i]$ 表示 $i$ 号车站顺时针到 $i+1$ 号车站的铁路长度。

1. $d=[1,2,2,2]$，总长度为 $7$；
2. $d=[1,2,2,3]$，总长度为 $8$；
3. $d=[1,2,2,4]$，总长度为 $9$；
4. $d=[1,2,3,4]$，总长度为 $10$。

可以证明，不存在其他的可能长度，于是答案为 $4$。

【样例 2 解释】

$3$ 号车站顺时针到 $1$ 号车站的铁路长度可以为任意正整数。

【数据范围与提示】

- 对于 $30\%$ 的数据，保证 $n,m \le 9$，$L_i \le 5$；
- 对于另外 $15\%$ 的数据，保证 $T_i$ 是 $S_i$ 顺时针方向后第一个车站；
- 对于另外 $20\%$ 的数据，保证 $T_i$ 是 $S_i$ 顺时针方向后第二个车站；
- 对于另外 $25\%$ 的数据，保证 $n,m \le 50$；
- 对于 $100\%$ 的数据，保证 $3 \le n \le 500$，$1 \le m \le 500$，$1 \le L_i \le 10^9$。


---

---
title: "[CEOI 2005] Depot Rearrangement"
layout: "post"
diff: 省选/NOI-
pid: P7684
tag: ['图论', '2005', 'Special Judge', 'CEOI（中欧）', '欧拉回路', '二分图', '构造']
---
# [CEOI 2005] Depot Rearrangement
## 题目描述

一家公司经营着 $N$ 个店铺，每个店铺都销售 $M$ 种不同的产品。该公司有一个大型仓库，产品在运送到商店之前在都会那里进行包装。每家商店将会收到相同数量的每种产品。因此，该公司将一定数量的相应产品分别包装到一个集装箱中，并用产品标识符标记该集装箱。产品由 $1$ 到 $M$ 的数字标识。因此，在包装结束后，仓库中将会有 $N×M$ 个集装箱，并且正好 $N$ 个集装箱贴有每个产品的对应标签。由于该仓库位于一个狭窄的建筑物内，所以集装箱排成了一排。但为了加快配送速度，仓库经理想要重新排列集装箱。由于将产品配送到商店是通过向每个商店发出一辆卡车来实现的，并且每辆卡车运载每种产品的一个集装箱，其合适的安排如下。该行最前部分 $M$ 个集装箱必须贴有不同的产品标签，该行的第二部分 $M$ 个集装箱必须贴有不同的产品标签，依此类推。不幸的是，在这一行的尽头只有一个空闲的地方可以放置一个集装箱。因此，必须通过依次拿起集装箱并将其移动到空闲位置来进行重新排列。重新排列后，空闲位置也必须在行的末尾。  
目标是通过最少的移动以实现所需的重新排列。  
现请您编写一个程序来计算需要最少移动多少次使得达成目标重排。
## 输入格式

第一行包含两个整数 $N$ 和 $M$。$N$ 是商店的数量，$M$ 是产品的数量。第二行包含 $N×M$ 个整数，即按初始顺序排列的集装箱标签。每个产品标识符 $x$ 在行中恰好出现 $N$ 次。
## 输出格式

第一行包含一个整数 $S$，这是达成集装箱所需排列所需的最小移动次数。以下 $S$ 行描述了重新排列。每行包含一对整数 $x$，$y$。一对 $x$，$y$ 描述了一个移动：位于 $x$ 位置的集装箱将移动到位置 $y$。位置由从 $1$ 到 $N×M+1$ 的数字标识；最初位置 $N×M+1$ 是空闲的（没有集装箱）。只有在移动之前位置 $y$ 是空闲的，从 $x$ 到 $y$ 的移动才是合法的。从 $x$ 移动到 $y$ 后，位置 $x$ 将是空闲的。
## 样例

### 样例输入 #1
```
5  6
4 1 3 1 6 5 2 3 2 3 5 6 2 1 4 5 6 4 1 3 2 4 5 5 1 2 3 4 6 6
```
### 样例输出 #1
```
8
9 31
18 9
10 18 
4 10
31 4
30 31
24 30
31 24
```
## 提示

#### 数据规模与约定  
对于 $100 \%$ 的数据，$1 \leq N \leq 400$，$1 \leq M \leq 400$，$1 \leq x \leq M$。  
#### 题目说明  
来源于 CENTRAL-EUROPEAN OLYMPIAD IN INFORMATICS 2005 的 Depot Rearrangement。  
由 @[求学的企鹅](/user/271784) 翻译整理。  
Special Judge 感谢 @[abruce](/user/104324)。


---

---
title: "[JDWOI-1] 蜀道难"
layout: "post"
diff: 省选/NOI-
pid: P7730
tag: ['网络流', '二分图', '费用流']
---
# [JDWOI-1] 蜀道难
## 题目背景

蜀道难，难于上青天…… 

蜀道之所以难，就是因为山路崎岖不平。
## 题目描述

小 K 和小 M 也模拟了蜀道难。在蜀道难中，有 $n$ 座山，每座山高度为 $h_i$。小 K 和小 M 有 $m$ 种魔法，每一次膜法可以把连续 $l_i$ 座山的高度抬高或压低 $1$，同时消耗 $c_i$ 点体力。

现在，小 K 和小 M 想让蜀道难的 $n$ 座山的高度不下降，这样蜀道就不难了。请问他们最少需消耗多少体力？

**注**：所有时候山的高度都不能为负。
## 输入格式

第一行两个整数 $n,m$，表示山的数量和膜法数量。

第二行 $n$ 个整数 $h_i$，表示山的高度。

接下来 $m$ 行，每行一个字符和两个整数 $w_i, l_i, c_i$，描述一种膜法（如果 $w_i$ 为 $+$，代表抬高；如果 $w_i$ 为 $-$，代表压低）。
## 输出格式

一行一个整数，表示最小消耗的体力。

如果无解，输出 $-1$。
## 样例

### 样例输入 #1
```
3 3
1 3 2
- 1 10
- 2 3
+ 1 1
```
### 样例输出 #1
```
1
```
## 提示

### 样例解释

使用 $1$ 体力值将第三座山升高 $1$。

### 数据范围

- 对于 $10\%$ 的数据，$1\leq n,m \leq 10$；
- 对于另外 $30\%$ 的数据，$1\leq n,m \leq 20$；
- 对于另外 $10\%$ 的数据，$m=1$；
- 对于所有的数据，$1\leq n, m \leq 200$，$1\leq l_i \leq n$，$1\leq h_i, c_i \leq 10^3$。


---

---
title: "[COCI 2015/2016 #2] DRŽAVA"
layout: "post"
diff: 省选/NOI-
pid: P7862
tag: ['2015', '二分', 'COCI（克罗地亚）']
---
# [COCI 2015/2016 #2] DRŽAVA
## 题目描述

一个遥远的国家刚刚举行了选举，新首相当选了。目前，这个国家没有一条公路，所以首相决定用双向公路把国内的城市连接起来，组成县，使国家现代化。

这个国家共有 $N$ 个城市，每个县由一个或多个城市组成，**两个城市将位于同一个县，当且仅当使用新建的道路可以从一个城市到达另一个城市**。这些城市在二维坐标系中用点来表示，两个城市之间的道路表示为连接两个城市所在点的线段。这条路的长度等于以公里为单位的线段的长度。

该国目前正遭受经济衰退，因此首相决定，由于缺乏预算，他们将不修建超过 $D$ 公里的道路。此外，**如果至少有一个县存在一个非空子县（可以包括该县的所有城市），使得子县内的居民总数可以被 $K$ 整除，首相就会高兴**。例如，如果 $K=4$，一个县的城市分别有 `3`、`5`、`7` 个居民，首相就会高兴，因为前两个城市的居民总数等于 `8`。

请你确定最小的 $D$ 来帮助首相降低成本，使得首相感到高兴。
## 输入格式

第一行包含两个整数 $N,K$。

接下来 $N$ 行，每行三个整数 $x_i,y_i,k_i$，分别表示这个城市的坐标和这个城市的人口。
## 输出格式

一行一个实数，表示最小的 $D$，**四舍五入保留三位小数**。
## 样例

### 样例输入 #1
```
3 3
0 4 4
1 5 1
2 6 1

```
### 样例输出 #1
```
1.414

```
### 样例输入 #2
```
6 11
0 0 1
0 1 2
1 0 3
1 1 4
5 5 1
20 20 10

```
### 样例输出 #2
```
5.657
```
### 样例输入 #3
```
6 5
20 20 9
0 0 3
0 1 1
10 0 1
10 1 6
12 0 3

```
### 样例输出 #3
```
2.000
```
## 提示

**【样例 1 解释】**

只有当所有城市都在同一个县里首相才能高兴，所以最小的 $D$ 为 $1.414$。

**【样例 2 解释】**

当前五个城市都在同一个县里首相才能高兴，且此时 $D$ 是最小的，所以最小的 $D$ 为 $5.657$。

**【数据范围】**

对于 $40\%$ 的数据，$1\le N\le10^3$；

对于 $100\%$ 的数据，$1\le N\le5\times10^4，1\le K\le30，0\le x_i,y_i,k_i\le10^8$。

**【说明】**

**本题数据点得分依原题，满分 160**。

题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #2](https://hsin.hr/coci/archive/2015_2016/contest2_tasks.pdf) **T6 DRŽAVA**。


---

---
title: "「EVOI-RD1」飞鸟和蝉"
layout: "post"
diff: 省选/NOI-
pid: P7863
tag: ['图论建模', '二分图', '费用流']
---
# 「EVOI-RD1」飞鸟和蝉
## 题目背景

你骄傲地飞远，我栖息的叶片。  
听不见的宣言，重复过很多年。  
沧海月的想念羽化我昨天，  
在我成熟的笑脸，  
你却未看过一眼。
## 题目描述

蝉 Charlie 要去寻找他的好朋友飞鸟了。 

具体来说，Charlie 和他的好朋友生活的地方可以看作一个 $n \times m$ 的网格，左上角为 $(1,1)$，右下角为 $(n,m)$。每个格子 $(i,j)$ 有一个海拔高度 $h_{i,j}$。Charlie 的目标是从他的家 $(x_0,y_0)$ 出发，不重不漏地经过网格中的每个格子**恰好一次**，**最终回到自己的家** $(x_0,y_0)$。Charlie 有两种移动方式：

1. 跳跃。用这种方式，Charlie 可以到达上下左右 $4$ 个相邻格子中**海拔严格低于当前格子**的一个格子。注意跳跃不消耗体力。  
2. 飞行。用这种方式，Charlie 可以从当前格子 $(x,y)$ 到达网格中**任意一个**格子 $(x',y')$，并消耗 $h_{x',y'}-h_{x,y}$ 个单位的体力。**注意飞行所消耗的体力值可以是负数**。  

Charlie 希望用尽量少的飞行次数完成目标，**在此前提下**再令消耗的体力最少。由于网格实在太大了，Charlie 希望你能帮助他。
## 输入格式

第一行四个整数，分别代表 $n,m,x_0,y_0$，含义如上所述。  
接下来 $n$ 行，每行 $m$ 个整数，第 $i$ 行第 $j$ 个数代表格子 $(i,j)$ 的海拔 $h_{i,j}$。
## 输出格式

一行两个整数，分别代表“飞行的最少次数”与“飞行次数最少的前提下消耗的最少体力值”。
## 样例

### 样例输入 #1
```
3 3 1 1
1 2 3
8 9 4
7 6 5
```
### 样例输出 #1
```
1 8
```
### 样例输入 #2
```
3 3 2 3
1 2 3
2 2 4
1 2 2
```
### 样例输出 #2
```
5 4
```
### 样例输入 #3
```
4 4 2 3
5 9 6 2
4 2 3 6
7 2 5 2
4 2 3 9
```
### 样例输出 #3
```
7 25
```
### 样例输入 #4
```
10 10 3 3
9 13 7 7 3 8 6 5 12 8
1 4 10 11 9 10 13 6 2 18
3 3 19 6 14 2 19 10 2 16
3 1 11 14 14 18 8 8 16 14
13 5 7 4 11 17 3 16 10 20
10 16 12 19 14 12 11 20 15 10
10 15 5 1 16 2 7 5 14 5
3 19 12 19 8 13 17 7 10 13
2 10 17 6 8 11 8 7 1 4
3 7 8 1 3 5 4 11 9 17
```
### 样例输出 #4
```
36 254
```
## 提示

**本题采用捆绑测试**

样例 1 解释：从 $(1,1)$ 飞到 $(2,2)$，再绕一圈即可。

样例 2 解释：一种最佳方案为：$(2,3)-(1,3)-(1,2)-(1,1)=(2,1)-(3,1)=(2,2)=(3,2)=(3,3)=(2,3)$，其中 $=$ 代表飞行。  

- Subtask 1 (10 pts)：满足 $1 \leq n,m \leq 3$。
- Subtask 2 (20 pts)：满足 $1 \leq n,m \leq 5$。
- Subtask 3 (20 pts)：保证至多有两种不同的海拔高度。 
- Subtask 4 (50 pts)：无特殊限制。

对于 $100\%$ 的数据：
- $1 \leq n,m \leq 50$。

- $1 \leq x_0 \leq n,1 \leq y_0 \leq m,1 \leq h_{i,j} \leq 10^9$。  

出题人：[冷月葬T魂](https://www.luogu.com.cn/user/340903)


---

---
title: "[BalkanOI 2003] Farey 序列"
layout: "post"
diff: 省选/NOI-
pid: P8058
tag: ['2003', '二分', '数论', '素数判断,质数,筛法', '最大公约数 gcd', '莫比乌斯反演', 'Stern-Brocot 树', 'BalkanOI（巴尔干半岛）']
---
# [BalkanOI 2003] Farey 序列
## 题目描述

把所有分子和分母都 $\leq n$ 的**最简真分数**从小到大排成一行，形成的序列称为 Farey 序列。

求出 $n$ 所对应的 Farey 序列中第 $k$ 小的数。
## 输入格式

一行，两个整数 $n, k$。
## 输出格式

一行，两个整数 $p, q$，表示答案 $\frac{p}{q}$。
## 样例

### 样例输入 #1
```
5 6
```
### 样例输出 #1
```
3 5
```
## 提示

对于 $100\%$ 的数据，$2 \leq n \leq 4 \times 10^4$，$1 \leq k \leq$ 符合条件的分数的个数。


---

---
title: "「WHOI-2」D&D"
layout: "post"
diff: 省选/NOI-
pid: P8434
tag: ['动态规划 DP', '搜索', '数学', '二分', '洛谷原创', 'O2优化', '位运算', '双指针 two-pointer']
---
# 「WHOI-2」D&D
## 题目背景

有没有发现少了什么？

我们的 miku 决定出门逛街了。但是好巧不巧的就是她家里的装饰物少的可怜，并且只有一些数字可以作为装饰。

但是 miku 发现如果有若干个装饰物组成的数集 $A$，那么 $A$ 的子集 $f(A)$ 是最好看的（尽管不知道为什么）。所以就有了这道题。

但是因为看到了标题，所以聪明的你应该知道 miku 要去哪里了（误）。
## 题目描述

给定**不重**集合 $A$，定义其 _装饰子集_ 

$$f(A)=\{a\in A|\forall b\in A-\{a\},a|b\not= b \}$$

这里的 $\texttt{“|”}$ 表示按位或；这里 $b\in A-\{a\}$ 表示 $b\in A$ 且 $b\not=a$。

miku 有一个长度为 $n$ 的正整数序列 $a_i$。你要给这个序列连续地划分为若干个（至少一个）连续子串。要求这些连续子串元素所组成的**不重集合**的 _装饰子集_ 相同。

求方案数对 $10^9+7$ 取模。
## 输入格式

第一行一个正整数表示 $n$。

接下来长度为 $n$ 的正整数序列表示 $a_i$。
## 输出格式

一行一个正整数表示答案。
## 样例

### 样例输入 #1
```
10
1 2 3 4 5 5 4 3 2 1
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
9
1 2 2 1 1 1 2 2 1
```
### 样例输出 #2
```
16
```
## 提示

**【样例#1解释】** 可以证明，两种方法分别是：
$$[1,2,3,4,5,5,4,3,2,1]$$
$$[1,2,3,4,5],[5,4,3,2,1]$$

这里三个子集所组成的不重集合都是 $\{1,2,3,4,5\}$。它们的装饰子集都是 $\{3,5\}$。具体说明如下：

- $1:1|3=3$，故不属于。
- $2:2|3=3$，故不属于。
- $3:3|1=3,3|2=3,3|4=7,3|5=7$，故属于。
- $4:4|5=5$，故不属于。
- $5:5|1=5,5|2=7,5|3=7,5|4=5$，故属于。

---
**本题采用捆绑测试**

- $\text{subtask1(5pts)}:n\leq10$。
- $\text{subtask2(10pts)}:a_i\leq7$。
- $\text{subtask3(20pts)}:a_i=2^a+2^b$。其中 $a\not = b$。
- $\text{subtask4(20pts)}:a_i=2^a+2^b$。其中不保证 $a\not =b$。
- $\text{subtask5(10pts)}:$ 保证 $a_i$ 随机生成。
- $\text{subtask6(35pts)}:$ 无特殊限制。时限为 $3s$。

对于 $100\%$ 的数据，保证 $1\leq n\leq 3\times10^6,0\leq a_i\leq2\times 10^6$。


---

---
title: "「Wdoi-2」死亡之后愈发愉悦"
layout: "post"
diff: 省选/NOI-
pid: P8541
tag: ['倍增', '二分', '洛谷原创', '交互题', 'Special Judge', 'O2优化', '洛谷月赛']
---
# 「Wdoi-2」死亡之后愈发愉悦
## 题目背景

落樱缤纷春不待，如果错过了这次机会，可能得等到紫藤绽放的春夏之际才能赏花了。  
但是两人依然无心在樱花树下席地而宴。

因为正体不明的灵体在两人面前倏现骤消的飘浮着。  
后来才明白这些四处飘浮的正体不明灵体，既非普通幽灵，也不是前阵子出现的怨灵。  
这些是神灵。本应超脱为神的灵体。

一般而言，神灵多半居住在神社里，其实它们是随处可见的没有固定型态的灵体。  
这些神灵让她们困惑不已。

超乎常人的强烈人欲、想法、恐惧与情感，是神灵出现的原因。一般而言，神灵很少危害人类，如果没有强烈的欲望。例如祈求丰收，或是除厄避邪等，是不会产生神灵的……

小神灵指引着灵梦与魔理沙深入命莲寺的地底，与千年复苏的敌人交手。从命莲寺墓地到莲池中央的梦殿大祀庙，从彷徨的亡灵到极具传说色彩的圣德太子，从欲望加速到小小的欲望星空，一切都显得那么不可思议。

「死亡之后，才能得到更加绚烂的重生。」
## 题目描述

**【这是一道交互题】**

定义 $f(x)$ 表示严格大于 $x$ 的最小的完全平方数，定义 $g(x)$ 为小于等于 $x$ 的最大的完全平方数。例如，$f(1)=f(2)=g(4)=g(8)=4$。

一个正整数是“可爱”的，当且仅当 $x-g(x)<f(x)-x$，例如，$1,5,11$ 是可爱的正整数，而 $3,8,15$ 不是。

为了倾听小神灵的愿望，主角组需要向神子询问。小神灵有一个最喜欢的正整数 $a$，神子可以根据灵梦给出的 $x\quad(x\in[0,10^9])$，向小神灵询问，而小神灵只能回答她，$a+x$ 是不是可爱的正整数（$\text{cute number}$）。

请通过适当的询问找出 $a$。
## 输入格式

第一行有一个正整数 $T$，表示数据组数。每一组之间互相独立。

接下来，对于每一组数据，你将可以进行以下两种操作：

- $\verb!? x!$：询问 $a+x$ 是否是 $\text{cute number}$。要注意，$x$ 的值应当在 $[0,10^9]$ 以内。对于正确的询问，交互库会返回一个数字 $1$ 或者 $0$，表示 $a+x$ 是/不是 $\text{cute number}$。
- $\verb|! a|$：报告你发现的 $a$。如果你给出的 $a$ 正确，该组数据结束。注意：报告操作不计入询问操作的总次数。

如果你的询问次数超过了 $100$，或者 $x$ 不符合数据范围，或者你报告的 $a$ 不正确，交互库会返回一个数字 $-1$。此时你应当立即结束程序，否则可能发生不可预知的错误。
## 样例

### 样例输入 #1
```
1

1

1

1

1

1

0

0

1
```
### 样例输出 #1
```

? 0

? 1

? 2

? 3

? 10

? 100

? 233

? 1919810

! 114514
```
## 提示

### 样例解释

样例当中的过程仅供参考。

样例当中，$a=114514$，是 $\text{cute number}$（因为 $338^2\le 114514 <339^2$，而 $114514-338^2=270<339^2-114514=407$）。

同样地，$a+0,a+1,a+2,a+3,a+10$ 均为 $\text{cute number}$。而 $a+100=114614$ 不是 $\text{cute number}$，因为 $338^2\le 114614 <339^2$，而 $114614-338^2=370\ge 339^2-114614=307$。

### 数据范围及约定

$$
\def\arraystretch{1.5}
\begin{array}{|c|c|c|c|c|}\hline
\textbf{Subtask} & \bm{a\le } & \bm{T\le} & \textbf{特殊性质} & \textbf{分值}\\\hline
1 & 100 & 100 & - & 10\\\hline
3 & 10^9 & 2\times 10^3 & -  & 20\\\hline
2 & 10^{12} & 2\times 10^3 & \textbf{A}  & 30\\\hline
4 & 10^{12} & 2\times 10^3 & -  & 40\\\hline
\end{array}
$$

**特殊性质** $\textbf{A}$：保证 $a$ 是 $\text{cute number}$。

对于全部数据，保证 $1\le a\le 10^{12}$。你发起的询问当中，$x$ 的值应当在 $[0,10^9]$ 以内。

---

此外，你每个测试点的得分还与该测试点所有询问次数的最大值有关。具体而言，设某个测试点你询问操作一共进行了 $\text{max\_count}$ 次。

- 若 $\text{max\_count}< 64$，你将获得该测试点 $100\%$ 的分数；
- 若 $64\le \text{max\_count}< 81$，你将获得该测试点 $50\%$ 的分数；
- 若 $81\le \text{max\_count}< 100$，你将获得该测试点 $20\%$ 的分数；
- 若 $\text{max\_count}\ge 100$，你将不能获得该测试点的分数。


---

---
title: "[JRKSJ R6] func"
layout: "post"
diff: 省选/NOI-
pid: P8568
tag: ['数学', '二分', '2022', '三分', '洛谷原创', '交互题', 'Special Judge', 'O2优化']
---
# [JRKSJ R6] func
## 题目描述

**这是一道 IO 交互题．**

你有一个一次函数 $f(x)=kx+b$（$1\le x \le n-1$）．这个一次函数满足 $k,b$ 均为整数且 $k>0$．

vectorwyx 修改了这个函数，具体而言，他会选择一个整数 $t$（$1\le t \le n-1$），将这个函数在直线 $x=t$ 及右侧的部分向右平移一个单位长度，并把两部分的端点用直线段连接，得到一个分段函数 $g(x)$：

$$
g(x)=\begin{cases}
kx+b&1\le x<t\\
kt+b& t\le x <t+1\\
k(x-1)+b& t+1\le x \le n
\end{cases}
$$

请通过交互的方式得到 $t$ 的值．

### 交互方式

**本题单个测试点中含有多组数据．**

1. 首先从标准输入流读入一个整数 $T$，表示数据组数．
1. 接下来你将进行 $T$ 组数据的交互．对于每组数据，首先从标准输入流读入三个整数 $n,Q,P$．
1. 你可以通过向标准输出流输出 `? l r p` $(1\le l \le r \le n$，$2\le p \le P$$)$ 的方式来询问．在单组数据中，你最多只能进行 $Q$ 次 `?` 操作．交互库会根据你的询问依次做出以下判断并向标准输入流发送返回结果：
    - 若你的询问数据范围错误，回答为 $-2$．此时交互库会直接返回 WA．你需要立刻退出你的程序来避免与已经结束程序的交互库交互引起超时．
    - 若 $g(l)=g(r)$，回答为 $-1$．
    - 否则回答为 $(g(l) + g(r))\bmod p$．
1. 你可以通过向标准输出流输出 `! t` 的方式来给出答案．你只能进行一次回答操作，且回答操作必须是你在每组数据中进行的最后一个操作．交互完成后，从标准输入流读入一个零或一的整数 $x$．若 $x=1$ 则代表当前数据回答正确，你需要回到步骤 $2$ 以进行下一组数据的交互．否则 $x=0$，你需要立刻退出自己的程序．

**不要忘记在每次输出后刷新缓冲区，否则你将会 TLE．**

下面是一些语言的刷新缓冲区操作：

- C++：`fflush(stdout)` 或 `cout.flush()`．
- C: `fflush(stdout)`．
- Java: `System.out.flush()`．
- Python: `stdout.flush()`．
- Pascal: `flush(output)`．
- 其他语言：请参考对应语言的帮助文档．

## 输入格式

见「交互方式」．
## 输出格式

见「交互方式」，
## 样例

### 样例输入 #1
```
1
5 999 999

0

1

1
```
### 样例输出 #1
```


? 1 3 2

? 4 5 2

! 3
```
## 提示

### 样例解释

请注意，样例仅用来表示交互的规则，不保证有逻辑性．

#### 样例 #1

$f(x)=3x-2$（$1\le x \le 4$），$t=3$．

$$
g(x)=\begin{cases}
3x-2&1\le x<3\\
7& 3\le x <4\\
3x-5& 4\le x \le 5.
\end{cases}
$$

所以第一次询问的结果 $(g(1) + g(3))\bmod 2 = (1+7)\bmod 2=0$，第二次询问的结果 $(g(4)+g(5))\bmod 2 = (7+ 10)\bmod 2=1$．

### 数据范围与约束

**本题采用捆绑测试．且不存在一个 Subtask 包含其它所有 Subtask 的限制．**

| Subtask | 分值 |    $n$     | $Q=$ |       $P=$        | $g(x)\le$ |    特殊性质     |
| ------- | ---- | ---------- | ---- | ----------------- | --------- | --------------- |
| $1$     | $10$ | $\le 10^9$ | $42$ | $2\times 10^{18}$ | $10^{18}$ | 无              |
| $2$     | $20$ | $\le 10^9$ | $30$ | $2$               | $10^{18}$ | 斜率 $k$ 为奇数 |
| $3$     | $30$ | $\le 10^9$ | $42$ | $50$              | $10^{18}$ | 无              |
| $4$     | $39$ | $\le 10^9$ | $32$ | $50$              | $10^{18}$ | 无              |
|$5$|$1$|$ = 1162261531$| $32$| $50$| $7857125847061472735$|无|

对于 $100\%$ 的数据，保证 $1 \le T \le 10$，$2\le n\le 1162261531$．且满足 $\forall x \in [1,n], 0 \le g(x)\le 7857125847061472735$．

### 提示

由于本题不存在一个 Subtask 包含其它所有 Subtask 的限制．所以数据范围中「对于 $100\%$ 的数据」部分的 $n$ 和 $g(x)$ 的上界没有任何意义．但由于直接写「对于 $100\%$ 的数据，满足 $n \ge 2$，$g(x)\ge 0$」会被某些管理以「你管这叫数据范围」打回，故此题中保留该没有意义的上界．


---

---
title: "[PA 2021] Wystawa"
layout: "post"
diff: 省选/NOI-
pid: P9051
tag: ['动态规划 DP', '贪心', '二分', '平衡树', '2021', 'Special Judge', 'PA（波兰）']
---
# [PA 2021] Wystawa
## 题目描述

给定长度为 $n$ 的序列 $a, b$。

你需要构造一个序列 $c$，构造方法为：

- 选择 $k$ 个 $i$，令 $c_i \leftarrow a_i$。
- 对于其他 $i$，令 $c_i \leftarrow b_i$。

求序列 $c$ 的最大子段和的最小值，并给出一种方案。
## 输入格式

第一行，两个整数 $n, k$；

第二行，$n$ 个整数 $a_1, a_2, \cdots, a_n$；

第三行，$n$ 个整数 $b_1, b_2, \cdots, b_n$。
## 输出格式

第一行，一个整数，表示序列 $c$ 的最大子段和的最小值；

第二行，一个长为 $n$ 的字符串 $s$，若令 $c_i \leftarrow a_i$，$s_i = \text{A}$；否则，$s_i = \text{B}$。

**如有多解，输出任意一组均可。**
## 样例

### 样例输入 #1
```
6 2
-1 7 0 2 -5 0
3 1 4 -3 -3 12
```
### 样例输出 #1
```
4
BBABBA
```
### 样例输入 #2
```
3 2
-1 -4 -1
-4 -2 -1
```
### 样例输出 #2
```
0
AAB
```
## 提示

对于 $100\%$ 的数据，$1 \leq n \leq 10^5$，$0 \leq k \leq n$，$-10^9 \leq a_i, b_i \leq 10^9$。


---

---
title: "[THUPC 2023 初赛] 最后的活动"
layout: "post"
diff: 省选/NOI-
pid: P9144
tag: ['动态规划 DP', '二分', '2023', 'Special Judge', 'O2优化', 'THUPC']
---
# [THUPC 2023 初赛] 最后的活动
## 题目背景

各位亲爱的《La Lumière: Scarlet Intense Flame》玩家：

感谢您一直给予《La Lumière: Scarlet Intense Flame》的支持与厚爱。我们非常遗憾地宣布，《La Lumière: Scarlet Intense Flame》将于 2023 年 3 月 5 日 16:00 停止运营服务。

停止运营相关时间表如下：

……
## 题目描述

元老级二次元手游《La Lumière: Scarlet Intense Flame》将于今年 3 月停止运营服务。作为这款游戏的忠实玩家，小 S 希望能在游戏的最后一次活动中刷到一个特殊的分数，以此为近十年来与这款游戏共度的难忘时光画上一个圆满的句号。

《La Lumière: Scarlet Intense Flame》中的每种活动都有其独特的规则，而最后一次活动是 Chase Festival。在 Chase Festival 中，玩家需要多次攻略每次随机生成的多层迷宫，每次退出迷宫时根据在迷宫中各层击杀怪物的评价独立结算本次随机迷宫的分数。每次挑战迷宫时的流程简化如下：

1. 选择挑战的随机迷宫的难度。小 S 是这款游戏的资深玩家，因此在本题中假定小 S 总是挑战最高难度的迷宫。最高难度的迷宫最深为 $N$ 层。确定难度后，从随机生成的迷宫的第 1 层开始挑战。

2. 进行第 $i$ 层的挑战。挑战第 $i$ 层时，小 S 有可能挑战失败，挑战成功并获得普通评价，或者挑战成功并获得高评价。如果小 S 选择保守的挑战策略，则有 $p_{i,0}$ 的概率挑战失败，有 $p_{i,1}$ 的概率挑战成功并获得普通评价，有 $p_{i,2}$ 的概率挑战成功并获得高评价；如果小 S 选择激进的挑战策略，则有 $q_{i,0}$ 的概率挑战失败，有 $q_{i,1}$  的概率挑战成功并获得普通评价，有 $q_{i, 2}$ 的概率挑战成功并获得高评价。
   
   - 获得普通评价时，在当前层获得 $s_{i,1}$ 的分数；获得高评价时，在当前层获得 $s_{i,2}$ 的分数。这部分获得的分数**不会直接加算**到玩家的总分数中，而是**在退出迷宫时结算**。如果挑战成功，且当前不是最后一层（$i<N$），则跳转到第 3 步，选择是否继续挑战；否则（$i=N$），退出迷宫并跳转到第 4 步进行结算。
   
   - 如果挑战失败，则强制退出迷宫，跳转到第 4 步。

3. 如果当前不是最后一层，玩家可以选择是否继续挑战下一层。如果选择继续，则返回第 2 步；否则退出当前迷宫，跳转到第 4 步进行结算。

4. 本次迷宫的分数结算：如果因为失败而强制退出，则当前层不获得任何奖励，且**本次迷宫中之前各层**累积的分数需要乘上惩罚系数 $c$（为了使最终分数为整数，游戏会对惩罚后的分数先求和再下取整）；除了强制退出之外，玩家主动退出或者通关迷宫后退出都可以获得全部尚未结算的分数。

小 S 想得到的目标分数是一个比较大的分数，因此小 S 需要先大量刷最高难度的迷宫，再在接近目标分数时根据当前剩余的分数选择相对稳定的策略，以确保活动结束时能恰好获得目标分数。小 S 不会编程，因此小 S 找到了你，希望你能帮忙计算当剩余分数在 $1$ 至 $M$ 分之间，仅按照上述的流程挑战迷宫，并采用最佳策略时，最终能够恰好达到目标分数的最大概率。
## 输入格式

输入的第一行包含三个整数 $N, M, c'$，其中 $N$ 和 $M$ 的含义与题面相同，$c'=100c$。保证 $1\le N\le 6$，$1\le M\le 10000$，$0\le c'\le 100$。

接下来 $N$ 行，每行输入八个整数 $s_{i,1},s_{i,2},u_{i,0},u_{i,1},u_{i,2}, v_{i,0}, v_{i,1}, v_{i,2}$，其中 $s_{i,1}$ 与 $s_{i,2}$ 分别表示挑战时普通评价和高评价对应的分数；$u_{i,j}$ 和 $v_{i,j}$ 分别表示使用保守的挑战策略及激进的挑战策略时，对应结果的概率权重：$p_{i,j}=\dfrac{u_{i,j}}{u_{i,0}+u_{i,1}+u_{i,2}}$，$q_{i,j}=\dfrac{v_{i,j}}{v_{i,0}+v_{i,1}+v_{i,2}}$。保证 $1\le s_{i, 1} \le s_{i, 2}\le 10000$，$0\le u_{i,j}, v_{i,j}\le 10000$ 且 $u_{i,1}+u_{i,2}\ge 1$，$v_{i,1}+v_{i,2}\ge 1$。
## 输出格式

输出一行 $M$ 个实数，其中第 $i$ （$1\le i\le M$）个实数表示当距离目标分数恰好还剩 $i$ 分时，在最优策略下能够恰好获得 $i$ 分的最大概率。 当你输出中的每个实数与相应标准输出的绝对误差不超过 $10^{-6}$ 时，我们认为你的输出是正确的。
## 样例

### 样例输入 #1
```
2 8 50
3 4 0 1 1 0 1 1
4 5 1 2 1 1 1 2

```
### 样例输出 #1
```
0.125000000000000000 0.140625000000000000 0.515625000000000000 0.564453125000000000 0.135009765625000000 0.328369140625000000 0.548858642578125000 0.625278472900390625

```
### 样例输入 #2
```
见附件中的 2.in
```
### 样例输出 #2
```
见附件中的 2.ans
```
## 提示

#### 子任务

对于 $100\%$ 的数据，保证 $1\le N\le 6$，$1\le M\le 10000$，$0\le c'\le 100$，$1\le s_{i,1}\le s_{i, 2}\le 10000$，$0\le u_{i, 0}, u_{i, 1}, u_{i, 2}, v_{i, 0}, v_{i, 1}, v_{i, 2}\le 10000$，$u_{i,1}+u_{i,2}\ge 1$，$v_{i,1}+v_{i,2}\ge 1$。

#### 提示

《La Lumière: Scarlet Intense Flame 2》将于 2023 年春暖花开的时节与大家相见！

#### 题目来源

来自 2023 清华大学学生程序设计竞赛暨高校邀请赛（THUPC2023）初赛。

题解等资源可在 <https://github.com/THUSAAC/THUPC2023-Pre> 查看。


---

---
title: "「GMOI R2-T3」粒子环游"
layout: "post"
diff: 省选/NOI-
pid: P9200
tag: ['数学', '线段树', '二分', '树状数组', '洛谷原创', 'O2优化', '枚举', '洛谷月赛']
---
# 「GMOI R2-T3」粒子环游
## 题目背景

热爱珂学的小 Z 正在进行一项无聊的实验。
## 题目描述

实验室中有一个由 $n$ 个实验腔连接而成的环形轨道，其中第 $i$ 个实验腔顺时针连向第 $i+1$ 个实验腔（特别的，第 $n$ 个实验腔连向第 $1$ 个实验腔）。同时还有一个标号为 $n+1$ 的新建实验腔要接入这个环形轨道。它可以接在任意两个原本相连的实验腔之间。

第 $i$ 个实验腔可以将带电荷量为 $Q$ 的粒子运输到它的下一个实验腔，这个过程花费的能量为 $\vert Q \vert \times c_i$。除此之外，第 $i$ 个实验腔本身就存储了量为 $e_i$ 的电荷（电荷量有正负）。由于众所周知的电荷守恒定律，第 $n+1$ 个实验腔储存的电荷量与前 $n$ 个实验腔储存的总电荷量的代数和为 $0$。

小 Z 有一个原本不带电的粒子。等到第 $n+1$ 个实验腔接入轨道后，他要任选一个实验腔（包括第 $n+1$ 个）作为出发点，将粒子放入，并使之在实验腔的能量驱动下顺时针环游一周回到出发点。粒子每到达一个实验腔（包括出发点），它所带电荷量就会变成原来所带的电荷量和这个实验腔所储存的电荷量的代数和。

**注意：电荷量会先加上实验腔所含电荷量，再计算能量贡献。**

现在，小 Z 想知道，在所有接入新建实验腔并选定出发点的方案中，粒子环游一周所需的能量最少为多少？
## 输入格式

第一行为一个正整数 $n$ ，表示环形轨道原有实验腔数。

第二行有 $n+1$ 个非负整数，依次表示 $c_1,c_2,...,c_{n+1}$。

第三行有 $n$ 个整数，依次表示 $e_1,e_2,...,e_{n}$。
## 输出格式

输出共一行，包括一个数，表示粒子环游一周所需的最少能量。
## 样例

### 样例输入 #1
```
3
1 3 2 2
3 -5 1
```
### 样例输出 #1
```
9
```
### 样例输入 #2
```
12
4 7 7 8 8 4 5 5 9 10 1 1 10 
0 -5 7 8 1 -1 -6 8 2 4 10 8 
```
### 样例输出 #2
```
509
```
## 提示

样例 $1$ 解释：一种最优方案为将 $4$ 号实验腔接在 $3$ 号实验腔与 $1$ 号实验腔之间，以 $4$ 号实验腔为出发点，花费能量为 $ 1\times 2\ +\ 4\times 1\ + \vert -1 \vert \times 3 \ +\ 0 \times 2 =9$。

**本题采用 Subtask 捆绑测试。**

| Subtask | $n\le$ | $c_i\le$ | $\vert e_i\vert$ | 特殊性质 | 对应测试点 | 总分 |
| :----------: | :----------: | :----------: | :----------: | :----------: | :----------: | :----------: |
| $0$ | $300$ | $100$ | $100$ | $-$ | $1\sim 5$ | $10$ |
| $1$ | $10^3$ | $10^3$ | $10^3$ | $\bf A$ | $6\sim 7$ | $5$ |
| $2$ | $10^4$ | $10^4$ | $10^4$ | $-$ | $8\sim12$ | $15$ |
| $3$ | $10^5$ | $10^5$ | $10^5$ | $\bf B$ | $13\sim 16$ | $10$ |
| $4$ | $2.5\times 10^5$ | $10^5$ |$10^5$ | $-$ | $17\sim 25$ | $60$ |

特殊性质 $\bf A$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=0$。

特殊性质 $\bf B$：对于所有的 $i\in[1,n+1](i\in \Z)$，满足 $c_i=1$。

对于 $100\%$ 的数据，$1\le n\le 2.5\times 10^5$，$0\le c_i\le 10^5$，$0\le |e_i|\le 10^5$。

保证答案在 long long 范围内。


---

---
title: "「DBOI」Round 1 人生如树"
layout: "post"
diff: 省选/NOI-
pid: P9399
tag: ['倍增', '二分', 'O2优化', '树链剖分', '树论', '哈希 hashing']
---
# 「DBOI」Round 1 人生如树
## 题目背景

> _永远这么酷 永远永远这么酷_\
_像个冒险家一样 不断探着山顶的路_\
——《Hustle》

张均好望着窗外，朱芝心走过来坐在他旁边，折了一架纸飞机飞出去。他对张均好说，要带着对未来的期待，往前走，别回头。

正如 [命运](https://www.luogu.com.cn/problem/P6773) 所述，每个人的人生都是一棵树。它总在无限的随机与缘分中伸展，有的枝丫茂盛了，有些却也不可避免地枯萎。
## 题目描述

朱芝心用魔法得到了张均好的人生树。

这是一棵 $n$ 个节点的树，节点 $i$ 上有权值 $w_i$。

朱芝心想要观测 $m$ 次张均好的人生：

设**当前**张均好人生树上的节点数量为 $s$。

1. 输入四个整数 $u_1,v_1,u_2,v_2$。令 $u_1\to v_1$ 的简单路径上**顺次组成**的数组为 $a$，$u_2\to v_2$ 的简单路径上**顺次组成**的数组为 $b$。朱芝心认为张均好这两段人生的相似度是 $LRP(a,b)$，希望你求出它。保证 $1\leq u_1,v_1,u_2,v_2 \leq s$。

2. 输入两个整数 $u,w'$。朱芝心观测到了张均好的另外一种可能，因此你需要新建一个点权为 $w'$ 的节点，编号为 $s+1$，建立一条 $(s+1,u)$ 的无向边，其中 $u\leq s$。显然，此后 $s\leftarrow s+1$。

对于两个数组 $a,b$，设它们的相似度 $LRP(a,b)$ 表示最大的 $i$ 满足 $i\leq \min\{|a|, |b|\}$ 且**对于所有** $1\leq j\leq i$，都有 $b_j=a_j+j$。其中 $|a|$ 表示数组 $a$ 的长度。特殊地，若不存在这样的 $i$，则 $LRP(a,b) = 0$。

## 输入格式

第一行三个正整数 $n,m,idx$，分别表示树的节点数量，操作数量和该测试点所在 Subtask 编号。对于样例，有 $idx = 0$。

接下来一行 $n$ 个整数，第 $i$ 个整数表示 $w_i$，即点 $i$ 上的权值。

接下来 $n - 1$ 行，每行两个正整数 $u_i,v_i$，表示有一条 $(u_i,v_i)$ 的无向边。

接下来 $m$ 行，每行一个操作。每行第一个整数是 $opt$，后面的若干整数表示操作的具体内容。$opt=1$ 时表示是操作 $1$，$opt=2$ 时表示是操作 $2$。
## 输出格式

对于每个操作 $1$，输出一行，表示当前询问的 $LRP(a, b)$。
## 样例

### 样例输入 #1
```
9 3 0
7 3 2 4 6 5 5 3 7
1 2
2 3
2 4
4 5
4 6
1 7
7 8
7 9
2 9 10
1 3 5 8 10
1 3 6 8 10
```
### 样例输出 #1
```
4
3
```
### 样例输入 #2
```
13 5 0
15 12 9 11 5 6 16 14 15 10 12 1 2
7 8
5 6
2 9
1 2
4 5
8 2
9 10
2 3
10 11
3 4
3 13
3 12
1 1 6 7 11
1 12 12 13 13
2 1 10
2 2 11
1 14 14 15 15
```
### 样例输出 #2
```
6
1
1
```
## 提示

### 样例解释

对于样例一，第一个操作结束后，$w_{10}=10$，树如图所示：

![](https://s1.ax1x.com/2023/04/26/p9MV9pV.png)

- 对于第二个操作，第一条路径为 $3\to 2\to 4\to 5$，故 $a=\{2, 3, 4, 6\}$，第二条路径为 $8\to 7\to 9\to 10$，故 $b=\{3, 5, 7, 10\}$，由于 $3=2+1$，$5=3+2$，$7=4+3$，$10=6+4$，所以答案为 $4$；
- 对于第三个操作，$a=\{2, 3, 4, 5\}$，$b=\{3, 5, 7, 10\}$，由于 $3=2+1$，$5=3+2$，$7=4+3$，$10\ne 5+4$，所以答案为 $3$。

对于样例二，初始的树如图所示：

![](https://s1.ax1x.com/2023/04/26/p9MVZkR.png)


| Subtask | $n \le$ | $m \le$ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| Subtask 1 | $5000$ | $5000$ | 无 | $10$ |
| Subtask 2 | $10^5$ | $5\times{10}^4$ | A & B | $30$ |
| Subtask 3 | $10^5$ | $5\times{10}^4$ | B | $30$ |
| Subtask 4 | $10^5$ | $5 \times {10}^4$ | 无 | $20$ | 
| Subtask 5 | $10^5$ | $10^5$ | 无 | $10$ |

特殊性质 A：$v_i=u_i+1$。

特殊性质 B：保证无操作 2。

对于 $100\%$ 的数据，$1\leq n,m\leq 10^5$，$1\leq w_i,w'\leq 10^6$，$1\leq u_i,v_i\leq n$。  



---

---
title: "「EZEC-14」终点"
layout: "post"
diff: 省选/NOI-
pid: P9462
tag: ['二分', '洛谷原创', '交互题', 'Special Judge', 'O2优化', '广度优先搜索 BFS', '深度优先搜索 DFS', '洛谷月赛']
---
# 「EZEC-14」终点
## 题目背景

~~出题人怎么还没鸟加这首歌啊。~~

于 2023.8.5 拿下。
## 题目描述

**这是一道交互题。**

dXqwq 有一棵 $n$ 个点的无根树，结点从 $1$ 到 $n$ 编号。您需要通过若干次询问得到这棵树的结构。

您可以选择两个整数 $1\leq u,v\leq n$，并输出 `? u v` 进行询问。

对于每次询问，如果 $u,v$ 的路径中点在一个结点上，交互库返回该点的编号，否则返回 ``0``。

请通过不超过 $147154$ 次询问，得到这棵树的结构。

保证树的形态是提前确定的，即**交互库不自适应。**

### 交互方式

输入测试点所在子任务编号 $id$ 和树的大小 $n$ 以开始交互。

交互过程中，您可以进行题目描述中的询问。

对于每次询问，如果你提供的 $u,v$ 不合法或者超出询问次数上限，交互库会返回 ``-1``，否则交互库将会返回一个非负整数，含义见「题目描述」。

当你读取到 ``-1`` 后应立刻退出程序，在此之后交互库的行为未定义。

在您确定答案后，请先输出 `!`，然后接下来 $n-1$ 行依次输出两个整数 ``u[i] v[i]`` 代表树的每条边，最后退出程序。你可以以任意顺序输出这些边。

在您输出一行后，请清空缓冲区：

- 在 C++ 中，使用 `fflush(stdout)` 或 `cout.flush()`。
- 在 Pascal 中，使用 `flush(output)`。
- 在 Python 中，使用 `stdout.flush()`。
- 其它语言请自行查阅文档。
## 输入格式

见「交互方式」。
## 输出格式

见「交互方式」。
## 样例

### 样例输入 #1
```
1 5

1

2

3

4

0
```
### 样例输出 #1
```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 2
2 3
3 4
4 5
```
### 样例输入 #2
```
5 5

1

0

0

2

2
```
### 样例输出 #2
```
 
? 1 1

? 1 3

? 2 4

? 3 5

? 4 5

!
1 3
2 3
2 4
2 5
```
## 提示

**本题采用捆绑测试。**

-  Subtask 1（10 pts）：$n \leq 10$，树满足性质 A。
-  Subtask 2（10 pts）：保证存在一个点度数为 $n-1$。
-  Subtask 3（10 pts）：保证所有点度数 $\leq 2$。
-  Subtask 4（10 pts）：$n \leq 500$，树满足性质 A。
-  Subtask 5（20 pts）：$n \leq 500$。 
-  Subtask 6（20 pts）：树满足性质 A。
-  Subtask 7（20 pts）：无特殊限制。

性质 A：对于 $i=2,3,\cdots,n$ 存在整数 $1\leq j<i$ 满足有一条边连接 $i,j$。

对于 $100\%$ 的数据，$2 \leq n \leq 10^4$。

![](https://cdn.luogu.com.cn/upload/image_hosting/3u2zy1q5.png)


---

---
title: "[湖北省选模拟 2023] 棋圣 / alphago"
layout: "post"
diff: 省选/NOI-
pid: P9542
tag: ['动态规划 DP', '图论', '2023', 'O2优化', '二分图', 'Ad-hoc', '湖北']
---
# [湖北省选模拟 2023] 棋圣 / alphago
## 题目描述

小 K 是一名棋手，厌倦了传统围棋之后，他发明了一种新式围棋。

新式围棋是一种单人游戏。这个游戏的棋盘是一张包含 $n$ 个顶点，$m$ 条边的无向连通图，并且不存在重边和自环。同时，每条边有一个权值，第 $i$ 条边的权值为 $w_i$。

游戏开始时，每个顶点上可能有一颗黑棋或者一颗白棋，或者什么也没有。**至少有一个顶点上没有棋子。** 接下来，玩家需要进行若干次操作。每次的操作形式如下：

首先，选定一个上面没有棋子的顶点 $u$。可以说明，在题目数据范围下，一定存在这样的顶点。

接下来，对于每一颗棋子，若它位于顶点 $v$，则玩家需任选一条从 $v$ 到 $u$ 的**简单路径**，并将这颗棋子沿着这条简单路径移动一步。形式化地，一条简单路径为一个顶点序列 $\{p_1,p_2 \ldots p_k\}$，满足 $p_1 = v$，$p_k = u$ ，$p_1,p_2 \ldots p_k$ **互不相同**，且 $p_i$ 和 $p_{i+1}$ 之间存在一条边。在操作之后，这颗棋子将被移动至顶点 $p_2$。

需要注意的是，虽然在游戏开始时每个顶点上至多存在一颗棋子，但在若干次操作之后一个顶点上可能有多个棋子。对于同一个顶点上的不同棋子，一次操作中选取的简单路径可以不同。

玩家可以在进行任意次操作（可以是 $0$ 次）之后进行**点目**，即结算游戏分数。对于每一对颜色不同的棋子，若它们所在的顶点之间由一条权值为 $w$ 的边直接相连，则称它们**围住了这条边**，会使玩家得到 $w$ 的**目数**。而一个玩家所得到的**目数**即所有棋子对产生的**目数**之和。

现小 K 给了你一张游戏开始时的棋盘，请你帮他求出在这张棋盘上最多可能得到的**目数**。
## 输入格式

输入共 $m+k+1$ 行。

第一行三个整数 $n,m,k$，分别表示点和边的数量，以及棋子的数量。

接下来 $k$ 行，每行两个整数 $x,c$，表示顶点 $x$ 上有一颗颜色为 $c$ 的棋子。其中 $c=0$ 表示一颗黑棋，$c=1$ 表示一颗白棋。

接下来 $m$ 行每行三个整数 $u,v,w$，表示图中有一条连接 $u$ 和 $v$ 的权值为 $w$ 的边。
## 输出格式

输出一行一个整数，为所求答案。
## 样例

### 样例输入 #1
```
3 2 2
1 0
2 1
1 2 1
2 3 2

```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
4 4 3
1 1
2 1
3 0
1 2 1
2 3 1
3 4 1
4 1 3
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
见选手目录下的 alphago/alphago3.in 与 alphago/alphago3.ans。
```
### 样例输出 #3
```
见选手目录下的 alphago/alphago3.in 与 alphago/alphago3.ans。
```
### 样例输入 #4
```
见选手目录下的 alphago/alphago4.in 与 alphago/alphago4.ans。
```
### 样例输出 #4
```
见选手目录下的 alphago/alphago4.in 与 alphago/alphago4.ans。
```
### 样例输入 #5
```
见选手目录下的 alphago/alphago5.in 与 alphago/alphago5.ans。
```
### 样例输出 #5
```
见选手目录下的 alphago/alphago5.in 与 alphago/alphago5.ans。
```
## 提示

### 样例 1 解释

对于第一组样例，可以选定顶点 $3$，然后将 $1$ 号点上的黑棋移动到顶点 $2$，将 $2$ 号点的黑棋移动到顶点 $3$，这样两颗棋子所在的顶点之间由一条边权为 $2$ 的边连接，产生的目数为 $2$。

### 子任务

对于所有测试数据，保证  $3 \leq n \leq 100$，$n-1 \leq m \leq \frac{n(n-1)}{2}$，$1 \leq k \leq n-1$，$0 \leq w_i \leq 10^5$。

![](https://cdn.luogu.com.cn/upload/image_hosting/5iu3ldkx.png)


---

---
title: "「TAOI-2」Ciallo～(∠・ω< )⌒★"
layout: "post"
diff: 省选/NOI-
pid: P9576
tag: ['二分', '树状数组', '洛谷原创', 'O2优化', '哈希 hashing', '洛谷月赛']
---
# 「TAOI-2」Ciallo～(∠・ω< )⌒★
## 题目背景

柚子厨差不多得了。

~(·<)~(·<)~(·<)~(·<)~(·<)~(·<)~(·<)~(·<)~(·<)~(·<)~(·<)~(·<)~(·<)~(·<)

![](https://cdn.luogu.com.cn/upload/image_hosting/0nqiwonz.png)
## 题目描述

小 δ 喜欢造词。他学习了一种造词方法。

首先，他拥有一个「模板串」，设为 $s$。然后他会选择一对 $1 \le l \le r \le |s|$，将 $s$ 的第 $l$ 至 $r$ 个字符删掉，把两边的字符串拼起来，他设得到的这个新字符串为 $s'$。

接下来，他会选择一对新的 $1 \le l' \le r' \le |s'|$，然后设 $s'$ 的第 $l'$ 至 $r'$ 个字符组成的字符串为 $s''$。他所造出的这个词就是 $s''$。

例如，如果「模板串」为 $s=\texttt{cciaohalloo}$，那么一种造词方法是，选择 $l=5$，$r=7$，得到 $s'=\texttt{ccialloo}$，然后选择 $l'=2$，$r'=7$，得到 $s''=\texttt{ciallo}$。

现在小 δ 有一个「目标串」 $t$，他想知道有多少种不同的方案，可以使用「模板串」$s$ 造出单词 $t$。定义两种方案相同当且仅当选择的 $l,r,l',r'$ 均相同。
## 输入格式

共两行，分别为字符串 $s$ 和 $t$。
## 输出格式

共一行，代表造出「目标串」$t$ 的方案数。
## 样例

### 样例输入 #1
```
aabbaaba
aba
```
### 样例输出 #1
```
23
```
### 样例输入 #2
```
ciaohallo
ciallo
```
### 样例输出 #2
```
2
```
### 样例输入 #3
```
babacbbaababbacbababbabbbaaabaabababbabbabababba
ababab
```
### 样例输出 #3
```
1535
```
### 样例输入 #4
```
sssssssssssssssssssssssssssssssssssss
sss
```
### 样例输出 #4
```
15470
```
### 样例输入 #5
```
abcbbbcbcbcbacbacbaaabcbcbcbaabacbca
cb
```
### 样例输出 #5
```
3995
```
## 提示

### 数据范围

**本题采用捆绑测试**。

- Subtask 0（6 points）：$|s| \le 400$，$|t| \le 200$。
- Subtask 1（10 points）：$|s| \le 700$，$|t| \le 300$。
- Subtask 2（10 points）：$\forall i,j,s_i=t_j$。
- Subtask 3（10 points）：$|t|=1$。
- Subtask 4（20 points）：$|s| \le 10^4$，$|t| \le 3 \times 10^3$。
- Subtask 5（14 points）：$|t|=2$。
- Subtask 6（30 points）：无特殊限制。

对于所有测试数据，$1 \le |s| \le 4 \times 10^5$，$1 \le |t| \le 2 \times 10^5$。$s,t$ 只包含小写英文字母。


---

---
title: "「RiOI-03」Just a Q. (Easy ver.)"
layout: "post"
diff: 省选/NOI-
pid: P9916
tag: ['数学', '二分', '洛谷原创', '交互题', 'Special Judge', 'O2优化', '洛谷月赛', 'Ad-hoc']
---
# 「RiOI-03」Just a Q. (Easy ver.)
## 题目背景

「Yes, I am Q.」

面前的小 R 莞尔一笑。

+ 保证本题的任何合理的部分分或正解的 std + spj 均可以在当前数据下，$400$ ms 的时间限制、$32$ MB 的空间限制内正确运行并获得 AC 状态。
+ 本题不添加仅为无意义地卡满 spj 运行时间的 hack 数据。

**请注意，本题只有约束范围与困难版不同，且两个版本的约束范围并不完全重叠。**
## 题目描述

**这是一道交互题。**

小 R 有一个变量 $Q$。$Q$ 初始为 $0$。

小 R 有 $n$ 个隐藏的整数 $q_1 \dots q_n$，满足 $1 \leq \lvert q_i \rvert \leq V$，且有且仅有一个 $i$ 满足 $q_i \lt 0$，而面前的你，需要得出这个满足 $q_i \lt 0$ 的下标 $i$。

小 R 承诺不会让你以仅仅 $\frac{1}{n}$ 的几率盲猜，所以她可以允许你进行最多 $k$ 次询问。每次询问，你可以向小 R 给出**可重**正整数集合 $S$ 满足 $0 \leq \lvert S \rvert \leq S_{\max}$ 且 $\forall i \in S, i \leq n$，她会计算 $M = \prod\limits_{i\in S}q_i$，然后让 $Q \leftarrow Q + M$。特殊地，若 $S$ 为空集，则 $M = 1$。

一次询问后，小 R 会向你给出此时的 $\text{sgn}(Q)$（为 `+`，`-` 或 `0`），表示 $Q$ 的符号。具体地，若 $Q \gt 0$，小 R 返回 `+`；若 $Q \lt 0$，小 R 返回 `-`；否则返回 `0`。

请你在不超过 $k$ 次询问后，找到那个满足 $q_i \lt 0$ 的下标 $i$。

**保证对于所有数据，满足 $q_i \lt 0$ 的下标 $i$ 是在 $[1, n]$ 内均匀随机选取的。请注意报告下标属于一次询问。**
## 输入格式

### 交互格式

第一行，输入三个正整数 $n, k, S_{\max}$。

在此之后，你应当进行若干次询问。

对于你的每组询问，输出 $?\ m\ s_1\ s_2 \dots s_m$，表示给出一个**可重**正整数集合 $S$，其大小为 $m$，你需要保证 $0 \leq m \leq S_{\max}$。此外，同时应有 $1 \leq s_i \leq n$，描述这个集合里的元素编号。

如果你已经得到答案，请输出 $!\ i$，满足 $1 \leq i \leq n$，代表你得到 $q_i \lt 0$，在这之后你应当立即退出本轮交互。

每次你输出之后，请**刷新缓冲区**。

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\n'`，也可以自动刷新缓冲区。

每次询问并刷新缓冲区后，你将从标准输入中输入一个字符，字符为 `+`，`-` 或 `0`，表示当前 $Q$ 的符号 $\text{sgn}(Q)$。

### 输入格式

本题有多组数据。

第一行，一个整数 $T$ 表示数据组数。

对于每一组数据，请按照 **【交互格式】** 进行交互。当你报告下标后：

+ 如果你给出的下标正确：
	+ 如果这是最后一组数据，交互库退出并返回 Accepted；
	+ 如果这不是最后一组数据，你应当接着读入 $n, k, S_{\max}$ 以进行下一组数据的交互。
+ 否则，下标错误，交互库会立刻终止，返回 Unaccepted。
## 输出格式

见 **【输入格式】**。
## 样例

### 样例输入 #1
```
1
6 6 6

-

-

-

+

0



```
### 样例输出 #1
```


? 1 1

? 5 1 2 3 4 5

? 3 2 4 6

? 1 4

? 3 1 5 6

! 1
```
## 提示

### 样例解释 1

$q = \{-1, 1, 4, 5, 1, 4\}$。

### 数据规模与约定

**本题采用捆绑测试。**

+ Subtask 0（5 pts）：$q_i \neq 1$ 且 $q_i \neq -1$。
+ Subtask 1（10 pts）：$q_i \neq -1$，$k = 2n$。
+ Subtask 2（10 pts）：$q_i \neq 1$，$k = 2n$。
+ Subtask 3（9 pts）：$n = 13$，$k = 5000$。
+ Subtask 4（11 pts）：$n = 13$，$k = 2500$。
+ Subtask 5（20 pts）：$k = 2n$。
+ Subtask 6（35 pts）：无特殊限制。

对于每组数据，$1 \leq n \leq 200$，$1 \leq V \leq 10^6$，$n \leq k \leq 5\times 10^3$，$S_{\max} = n$。

对于每个测试点，$1 \leq T \leq 500$，$\sum n^2 \leq 2\times 10^5$，$\sum k \leq 2\times 10^5$。


---

---
title: "「RiOI-03」Just a Q. (Hard ver.)"
layout: "post"
diff: 省选/NOI-
pid: P9918
tag: ['数学', '二分', '洛谷原创', '交互题', 'Special Judge', 'O2优化', '洛谷月赛', 'Ad-hoc']
---
# 「RiOI-03」Just a Q. (Hard ver.)
## 题目背景

「Yes, I am Q.」

面前的小 R 莞尔一笑。

+ 保证本题的任何合理的部分分或正解的 std + spj 均可以在当前数据下，$900$ ms 的时间限制、$32$ MB 的空间限制内正确运行并获得 AC 状态。
+ 本题不添加仅为无意义地卡满 spj 运行时间的 hack 数据。

**请注意，本题只有约束范围与普通版不同，且两个版本的约束范围并不完全重叠。**
## 题目描述

**这是一道交互题。**

小 R 有一个变量 $Q$。$Q$ 初始为 $0$。

小 R 有 $n$ 个隐藏的整数 $q_1 \dots q_n$，满足 $1 \leq \lvert q_i \rvert \leq V$，且有且仅有一个 $i$ 满足 $q_i \lt 0$，而面前的你，需要得出这个满足 $q_i \lt 0$ 的下标 $i$。

小 R 承诺不会让你以仅仅 $\frac{1}{n}$ 的几率盲猜，所以她可以允许你进行最多 $k$ 次询问。每次询问，你可以向小 R 给出**可重**正整数集合 $S$ 满足 $0 \leq \lvert S \rvert \leq S_{\max}$ 且 $\forall i \in S, i \leq n$，她会计算 $M = \prod\limits_{i\in S}q_i$，然后让 $Q \leftarrow Q + M$。特殊地，若 $S$ 为空集，则 $M = 1$。

一次询问后，小 R 会向你给出此时的 $\text{sgn}(Q)$（为 `+`，`-` 或 `0`），表示 $Q$ 的符号。具体地，若 $Q \gt 0$，小 R 返回 `+`；若 $Q \lt 0$，小 R 返回 `-`；否则返回 `0`。

请你在不超过 $k$ 次询问后，找到那个满足 $q_i \lt 0$ 的下标 $i$。

**保证对于所有数据，满足 $q_i \lt 0$ 的下标 $i$ 是在 $[1, n]$ 内均匀随机选取的。请注意报告下标属于一次询问。**
## 输入格式

### 交互格式

第一行，输入三个正整数 $n, k, S_{\max}$。

在此之后，你应当进行若干次询问。

对于你的每组询问，输出 $?\ m\ s_1\ s_2 \dots s_m$，表示给出一个**可重**正整数集合 $S$，其大小为 $m$，你需要保证 $0 \leq m \leq S_{\max}$。此外，同时应有 $1 \leq s_i \leq n$，描述这个集合里的元素编号。

如果你已经得到答案，请输出 $!\ i$，满足 $1 \leq i \leq n$，代表你得到 $q_i \lt 0$，在这之后你应当立即退出本轮交互。

每次你输出之后，请**刷新缓冲区**。

你可以使用如下语句来清空缓冲区：

- 对于 C/C++：`fflush(stdout)`；
- 对于 C++：`std::cout << std::flush`；
- 对于 Java：`System.out.flush()`；
- 对于 Python：`stdout.flush()`；
- 对于 Pascal：`flush(output)`；
- 对于其他语言，请自行查阅对应语言的帮助文档。

特别的，对于 C++ 语言，在输出换行时如果你使用 `std::endl` 而不是 `'\n'`，也可以自动刷新缓冲区。

每次询问并刷新缓冲区后，你将从标准输入中输入一个字符，字符为 `+`，`-` 或 `0`，表示当前 $Q$ 的符号 $\text{sgn}(Q)$。

### 输入格式

本题有多组数据。

第一行，一个整数 $T$ 表示数据组数。

对于每一组数据，请按照 **【交互格式】** 进行交互。当你报告下标后：

+ 如果你给出的下标正确：
	+ 如果这是最后一组数据，交互库退出并返回 Accepted；
	+ 如果这不是最后一组数据，你应当接着读入 $n, k, S_{\max}$ 以进行下一组数据的交互。
+ 否则，下标错误，交互库会立刻终止，返回 Unaccepted。
## 输出格式

见 **【输入格式】**。
## 样例

### 样例输入 #1
```
1
6 6 6

-

-

-

+

0



```
### 样例输出 #1
```


? 1 1

? 5 1 2 3 4 5

? 3 2 4 6

? 1 4

? 3 1 5 6

! 1
```
## 提示

### 样例解释 1

$q = \{-1, 1, 4, 5, 1, 4\}$。

### 数据规模与约定

**本题采用捆绑测试。**

| 子任务编号 | $n \leq$ | $T \leq$ | $k = $ | $S_{\max} = $ | 分值 |
| :-: | :-: | :-: | :-: | :-: | :-: |
| $0$ | $200$ | $500$ | $20$ | $20n + 1$ | $11$ |
| $1$ | $1000$ | $50$ | $41$ | $8n + 10$ | $25$ |
| $2$ | $1000$ | $50$ | $50$ | $6n + 10$ | $30$ |
| $3$ | $10^4$ | $10$ | $39$ | $\lceil 1.5n\rceil + 10$ | $34$ |

对于子任务 $0, 1, 3$，若通过所有测试点则获得全部分数，否则获得 $0$ 分。

对于子任务 $2$：

+ 你需要保证你所使用的实际操作次数 $k'$ 满足 $0 \leq k' \leq 50$。
+ 你需要保证你所使用的实际操作次数 $S'$ 满足 $0 \leq S' \leq 6n + 10$。
+ 单个测试点的得分为 $\left(1 - \max(\frac{\max k' - 35}{20}, \max(\frac{S' - 3n - 10}{4n + 1}), 0)\right)\times 30$。
+ Subtask 的得分取所有测试点的得分最小值。

对于所有数据，$1 \leq V \leq 10^6$，$1 \leq n \leq 10^4$，$1 \leq T \leq 500$，**注意由于交互库限制 $\bm{n, T}$ 不会同时取到最大值**；此外，对每个子任务 $k, S_{\max}$ 的值已经给出。


---


---
title: "[DTCPC 2024] mex,min,max"
layout: "post"
diff: 省选/NOI-
pid: P10169
tag: ['线段树', '2024', '颜色段均摊（珂朵莉树 ODT）', '洛谷月赛', '单调栈']
---
# [DTCPC 2024] mex,min,max
## 题目描述

给定序列 $\{a_n\}$ 和 $k$，求有多少子区间 $[l,r]$ 满足 $\operatorname{mex}\{a_l,a_{l+1},\dots,a_{r-1},a_r\}+\min\{a_l,a_{l+1},\dots,a_{r-1},a_r\}+k\geq \max\{a_l,a_{l+1},\dots,a_{r-1},a_r\}$。

$\operatorname{mex}$ 定义为集合内没有出现过的最小的**非负整数**。
## 输入格式

第一行两个整数 $n,k$（$1\leq n\leq 5\times 10^5,0\leq k\leq n$）。

第二行 $n$ 个非负整数，第 $i$ 个表示 $a_i$（$0\leq a_i\leq n$）。
## 输出格式

一行一个数，表示满足条件的子区间个数。
## 样例

### 样例输入 #1
```
3 0
1 0 2
```
### 样例输出 #1
```
5
```


---

---
title: "[Opoi 2024] 二十六点"
layout: "post"
diff: 省选/NOI-
pid: P10536
tag: ['线段树', '树上启发式合并', 'O2优化', '树链剖分', '单调栈']
---
# [Opoi 2024] 二十六点
## 题目背景

二十六点：

> 。 。 。 。 。 。 。 。 。 。 。 。 。
>
> 。 。 。 。 。 。 。 。 。 。 。 。 。

凑二十六点真好玩，而为了凑四道题，就有了这道权值只有 $26$ 种的凑数题。
## 题目描述


给你一棵有 $n$ 个结点的以 $1$ 为根的树 $T$，第 $i$ 个结点有一个颜色 $c_i$，${\tt a} \le c_i \le {\tt z}$，和一个值 $P_i$。

对于每一个点 $x$，**从它到它子树中每一个点**（注意顺序是从它本身到子树中的点）都有一条路径，一共有子树的大小条路径。

现在忽略掉这些路径中的第 $2$ 到第 $P_x$ 个的点，特别地，若 $P_x = 1$ 则不忽略任何点。将忽略后的路径当作一个序列，序列中每个点的权值为路径上点的 $c_i$，求**每一个点的所有序列最长不下降子序列长度的最大值**。

注: 若有路径 $j$ 上的节点数 $len_j < P_x$，则相当于忽略这条路径上除第一个点外的所有点。

## 输入格式

第一行一个整数 $n$。

第二行 $n$ 个整数 $P_i$。

第三行 $n$ 个小写字母 $c_i$，**字符与字符间没有空格**。

接下来 $n - 1$ 行，描述树 $T$，每行两个整数 $u,v$，表示 $u,v$ 存在一条边。

行末可能有多余空格（慎用 `getchar()`）。
## 输出格式

输出 $n$ 行，表示每一个点的答案，按照编号从小到大输出。
## 样例

### 样例输入 #1
```
7
2 1 1 9 8 5 1
zzabcad
1 2
2 3
3 4
3 5
5 6
5 7
```
### 样例输出 #1
```
3
3
3
1
1
1
1

```
### 样例输入 #2
```
12
1 2 2 4 1 3 4 3 1 4 3 1 
baabbbbbbbaa
4 6
5 7
1 2
12 10
8 2
10 11
5 9
10 3
2 3
4 3
4 5

```
### 样例输出 #2
```
5
4
3
1
2
1
1
1
1
1
1
1
```
## 提示



### 样例一解释：

样例中树的形态：

![](https://cdn.luogu.com.cn/upload/image_hosting/6vbio7vo.png?x-oss-process=image/resize,h_450,m_lfit)

对于 $1$ 号节点：
$P_1=2$。

|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |
| :----------: | :----------: | :----------: | :----------: |
| 1 | z | 1 | z |
| 1 3 | za | 1 |  z |
| 1 3 4 |  zab | 2  | ab |
| 1 3 5  |  zac | 2 |  ac   |
| 1 3 5 6 |  zaca | 2  | ac |
| 1 3 5 7 | zacd| 3 | acd  |

长度最长的最长不降子序列：acd。

$2$ 号节点和 $1$ 号节点同理。

对于 $3$ 号节点：
$P_3=1$。

|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |
| :----------: | :----------: | :----------: | :----------: |
| 3 | a | 1 | a |
| 3 4 | ab | 1 |  ab |
| 3 5  |  ac | 2  | ac |
| 3 5 6  |  aca | 2 |  ac   |
|3 5 7   |  acd | 3  |acd |

长度最长的最长不降子序列：acd。

对于 $4,5,6,7$，它的所有序列中都只有它自己一个点，所以输出 $1$。
### 数据范围

本题采用 Subtask 计分。

| Subtask | Limit | Pts |
| :-----------: | :-----------: | :-----------: |
| 0 | $n \le 100$ | 5 |
| 1 | $n \le 2000$ | 15 |
| 2 | $\forall 1 \le i \le n \quad P_i=1$ | 30 |
| 3 | Empty | 50 |

对于 $100\%$ 的数据：

$1 \le n \le 10^5$。

$\forall 1 \le i \le n$， $c_i$ 为小写字母，$1 \le P_i \le n$。

给出的树连通且合法。


---

---
title: "[CEOI 2009] Harbingers"
layout: "post"
diff: 省选/NOI-
pid: P10602
tag: ['动态规划 DP', '2009', '二分', 'O2优化', 'CEOI（中欧）', '斜率优化', '单调栈']
---
# [CEOI 2009] Harbingers
## 题目描述

给定一颗树，树中每个结点有一个邮递员，每个邮递员要沿着唯一的路径走向 capital（$1$ 号结点），每到一个城市他可以有两种选择：

1. 继续走到下个城市；
2. 让这个城市的邮递员替他出发。

每个邮递员出发需要一个准备时间 $W_i$，他们的速度是 $V_i$，表示走一公里需要多少分钟。现在要你求出每个城市的邮递员到 capital 的最少时间（不一定是他自己到 capital，可以是别人帮他）？
## 输入格式

第一行一个正整数 $N$；

接下来 $N-1$ 行，每行三个正整数 $A,B,C$，表示结点 $A$ 和 $B$ 之间有一条长度为 $C$ 的边；

再接下来 $N-1$ 行，每行 $2$ 个整数 $W_i,V_i$。
## 输出格式

输出每个城市的邮递员到 capital 的最少时间。
## 样例

### 样例输入 #1
```
5
1 2 20
2 3 12
2 4 1
4 5 3
26 9
1 10
500 2
2 30
```
### 样例输出 #1
```
206 321 542 328
```
## 提示

对于 $20\%$ 的数据，$N\leq 2500$；

对于 $50\%$ 的数据，树是一条链；

对于所有数据，$3\leq N\leq 10^5$，$0\leq W_i,V_i\leq 10^9$，每条边长度不超过 $10^4$。


---

---
title: "[COTS 2023] 下 Niz"
layout: "post"
diff: 省选/NOI-
pid: P10833
tag: ['线段树', '2023', 'O2优化', '分治', '哈希 hashing', 'COCI（克罗地亚）', '单调栈']
---
# [COTS 2023] 下 Niz
## 题目背景


译自 [Izborne Pripreme 2023 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2023/) D2T2。$\texttt{1s,0.5G}$。

祝 NaCly_Fish 生日快乐！（2024.7.28）
## 题目描述


给定长度为 $N$ 的序列 $a$，求满足以下条件的 $(l,r)$ 对数：

- $1\le l\le r\le N$；
- $a_l,a_{l+1},\cdots,a_{r-1},a_r$ 是 $1\sim r-l+1$ 的排列。

## 输入格式


第一行，一个正整数 $N$，表示序列长度；

第二行，$N$ 个正整数，描述序列 $a$。
## 输出格式

一行一个整数，即满足条件的 $(l,r)$ 的数量。
## 样例

### 样例输入 #1
```
3
3 1 2 
```
### 样例输出 #1
```
3
```
### 样例输入 #2
```
5
3 2 1 2 3
```
### 样例输出 #2
```
5
```
### 样例输入 #3
```
7
2 1 3 1 2 3 4
```
### 样例输出 #3
```
8
```
## 提示


### 样例解释

样例 $3$ 解释：满足条件的 $(l,r)$ 有 $(2,2),(1,2),(1,3),(4,4),(4,5),(4,6),(4,7),(3,5)$。   

#### 数据范围

对于 $100\%$ 的数据，保证：

- $1\le N\le 10^6$；
- $1\le a_i\le N$。

| 子任务编号 | 分值 | 约束  |
|:-----:|:------:|:-------:|
| $1$  | $13$  | 每个数只在序列中出现一次  |
| $2$  | $20$  | $N\le 5\, 000$  |
| $3$  | $33$  | $N\le 50\, 000$ |
| $4$  | $34$  | 无额外约束 |






---

---
title: "「GFOI Round 2」Turtle and Nediam"
layout: "post"
diff: 省选/NOI-
pid: P11283
tag: ['洛谷原创', 'O2优化', '洛谷月赛', '单调栈']
---
# 「GFOI Round 2」Turtle and Nediam
## 题目背景

**[English statement](https://www.luogu.com.cn/problem/T533511). You must submit your code at the Chinese version of the statement.**
## 题目描述

对一个元素互不相同的长度 $\ge 3$ 的正整数序列 $a$，定义 $a$ 的“肿胃数（nediam）”$f(a)$ 为：

- 当 $|a| = 3$ 时，$f(a)$ 为 $a$ 的中位数；
- 当 $|a| > 3$ 时，取 $a$ 的任意一个长度为 $3$ 的子段 $[a_i, a_{i + 1}, a_{i + 2}]$，记这个子段的中位数为 $x$，$a$ 删掉 $x$ 后的序列为 $b$，$f(a)$ 为所有 $b$ 中 $f(b)$ 的最大值。

乌龟给你一个 $1 \sim n$ 的排列 $p_1, p_2, \ldots, p_n$ 和 $m$ 次询问，每次询问给定 $l, r$，你需要求出 $[p_l, p_{l + 1}, \ldots, p_r]$ 的“肿胃数（nediam）”，即 $f([p_l, p_{l + 1}, \ldots, p_r])$。
## 输入格式

为了加快读入速度，我们采用以下读入方法。

第一行包含六个正整数 $n, m, seed, A, B, C$。

第二行包含一个排列 $p_1, p_2, \ldots, p_n$。

接下来的 $m$ 组询问，每组询问你要按照如下的方式生成 $(l, r)$：

```cpp
unsigned seed, A, B, C;

inline unsigned rnd() {
	seed = A * seed * seed + B * seed + C;
	seed = seed ^ (seed << 27);
	seed = seed ^ (seed >> 19);
	return seed;
}

inline std::pair<int, int> gen() {
	int l, r;
	do {
		l = rnd() % n + 1;
		r = rnd() % n + 1;
	} while (abs(l - r) < 2);
	if (l > r) {
		std::swap(l, r);
	}
	return std::make_pair(l, r);
}
```

每组询问调用一次 `gen()` 生成这组询问的 $(l, r)$。
## 输出格式

为了加快输出速度，我们采用以下输出方法。

设第 $i$ 组询问的答案为 $ans_i$，你需要输出 $(1 \times ans_1) \oplus (2 \times ans_2) \oplus \cdots \oplus (m \times ans_m)$，其中 $\oplus$ 为按位异或。
## 样例

### 样例输入 #1
```
4 4 114 514 1919 810
1 3 4 2

```
### 样例输出 #1
```
1

```
### 样例输入 #2
```
10 100 123456 789123 456789 123456789
3 9 5 7 6 4 10 8 2 1

```
### 样例输出 #2
```
142

```
## 提示

#### 【样例解释 #1】

生成的四组询问分别为 $(1, 4), (1, 3), (1, 3), (2, 4)$，答案分别为 $2, 3, 3, 3$，所以你需要输出 $(1 \times 2) \oplus (2 \times 3) \oplus (3 \times 3) \oplus (4 \times 3) = 2 \oplus 6 \oplus 9 \oplus 12 = 1$。

对于第一组询问，选择子段 $[1, 3, 4]$ 或 $[3, 4, 2]$ 都会使得 $3$ 被删除。删除 $3$ 后的序列为 $[1, 4, 2]$，中位数为 $2$。

#### 【数据范围】

**本题使用捆绑测试。**

| 子任务编号 | $n \le$ | $m \le$ | 特殊性质 | 分值 |
| :-: | :-: | :-: | :-: | :-: |
| $1$ | $18$ | $100$ | 无 | $9$ |
| $2$ | $10^6$ | $5 \times 10^6$ | A | $5$ |
| $3$ | $10^3$ | $10^4$ | 无 | $19$ |
| $4$ | $10^5$ | $10^5$ | 无 | $17$ |
| $5$ | $10^6$ | $10^6$ | B | $15$ |
| $6$ | $10^6$ | $10^6$ | 无 | $13$ |
| $7$ | $10^6$ | $5 \times 10^6$ | 无 | $22$ |

- 特殊性质 A：$p_i = i$；
- 特殊性质 B：$p$ 从所有 $1 \sim n$ 的排列中等概率随机生成。

对于所有数据，满足：

- $3 \le n \le 10^6$；
- $1 \le m \le 5 \times 10^6$；
- $0 \le seed, A, B, C < 2^{32}$；
- $p$ 是一个 $1 \sim n$ 的排列。


---

---
title: "[USACO25FEB] Min Max Subarrays P"
layout: "post"
diff: 省选/NOI-
pid: P11845
tag: ['二分', 'USACO', '2025', '分类讨论', '单调栈']
---
# [USACO25FEB] Min Max Subarrays P
## 题目描述

**注意：本题的时间限制为 3 秒，通常限制的 1.5 倍。**

给定一个长为 $N$ 的整数数组 $a_1,a_2,\dots,a_N$（$2\le N \le 10^6$，$1\le a_i\le N$)。输出所有 $N(N+1)/2$ 个 $a$ 的连续子数组的以下子问题的答案之和。

给定一个非空整数列表，交替执行以下操作（从第一个操作开始）直到列表大小恰好为一。

1. 将列表内的两个相邻整数替换为它们的较小值。
1. 将列表内的两个相邻整数替换为它们的较大值。

求最终余下的整数的最大可能值。

例如，

$[4, 10, 3] \to [4, 3] \to [4]$

$[3, 4, 10] \to [3, 10] \to [10]$

在第一个数组中，$(10, 3)$ 被替换为 $\min(10, 3)=3$，随后 $(4, 3)$ 被替换为 $\max(4, 3)=4$。

## 输入格式

输入的第一行包含 $N$。

第二行包含 $a_1,a_2,\dots,a_N$。
## 输出格式

输出所有连续子数组的子问题的答案之和。

## 样例

### 样例输入 #1
```
2
2 1
```
### 样例输出 #1
```
4
```
### 样例输入 #2
```
3
3 1 3
```
### 样例输出 #2
```
12
```
### 样例输入 #3
```
4
2 4 1 3
```
### 样例输出 #3
```
22
```
## 提示

样例 1 解释：

对于 $[2]$ 答案为 $2$，对于 $[1]$ 答案为 $1$，对于 $[2, 1]$ 答案为 $1$。

因此，我们的输出应当为 $2+1+1 = 4$。

样例 3 解释：

考虑子数组 $[2, 4, 1, 3]$。


1. 在 $(1, 3)$ 上应用第一次操作，我们的新数组是 $[2, 4, 1]$。
1. 在 $(4, 1)$ 上应用第二次操作，我们的新数组是 $[2, 4]$。
1. 在 $(2, 4)$ 上应用第三次操作，我们最终的数是 $2$。

可以证明 $2$ 是最终的数的最大可能值。

- 测试点 $4\sim 5$：$N\le 100$。
- 测试点 $6\sim 7$：$N\le 5000$。
- 测试点 $8\sim 9$：$\max(a)\le 10$。
- 测试点 $10\sim 13$：没有额外限制。


---

---
title: "[CEOI 2011] Balloons"
layout: "post"
diff: 省选/NOI-
pid: P4697
tag: ['计算几何', '2011', 'Special Judge', 'CEOI（中欧）', '单调栈']
---
# [CEOI 2011] Balloons
## 题目描述

有 $n$ 个气球，他们一开始都是空的。

接下来，它们会按照从 $1$ 到 $n$ 的顺序依次充气，其中第 $i$ 个气球与地面在 $x_i$ 位置接触。

当气球碰到碰到前面的某个气球，或者达到半径最大限制时，就会停止充气。其中第 $i$ 个气球的半径最大限制为 $r_i$。

现在请你求出，每个气球最终半径是多少。
## 输入格式

第一行一个正整数 $n$，表示气球个数。

接下来 $n$ 行，每行两个空格隔开的整数 $x_i,r_i$。
## 输出格式

输出 $n$ 行，每行一个浮点数，第 $i$ 行的浮点数表示最终第 $i$ 个气球的半径。

你的答案会被判为正确，当且仅当与答案的绝对误差不超过 $10^{-3}$​​。
## 样例

### 样例输入 #1
```
3
0 9
8 1
13 7
```
### 样例输出 #1
```
9.000
1.000
4.694
```
## 提示

对于 $100\%$ 的数据，保证 $1\le n\le 200\ 000;0\le x_i\le 10^9;1\le r_i\le 10^9;x_1< x_2< \cdots < x_n$。


---

---
title: "『STA - R1』Crossnews"
layout: "post"
diff: 省选/NOI-
pid: P8879
tag: ['Special Judge', '单调栈']
---
# 『STA - R1』Crossnews
## 题目背景

Informational problems make us better.
## 题目描述

定义两个序列 $\{a_n\}$，$\{b_n\}$ 的联合权值为
$$\operatorname{unval}(a,b)=\sum_{i=1}^nb_i(b_i-a_i)$$

现给定一个序列 $\{a_n\}$，求满足 $\operatorname{unval}(a,b)$ 最小的单调不减序列 $\{b\}$，只需输出 $\operatorname{unval}(a,b)$ 的值即可。

注意，$\{b\}$ 中的元素不一定要为整数。
## 输入格式

第一行一个正整数 $n$。

第二行 $n$ 个整数表示 $a_i$。
## 输出格式

一行一个答案。
## 样例

### 样例输入 #1
```
5
1 2 3 4 5
```
### 样例输出 #1
```
-13.7500000
```
### 样例输入 #2
```
10
1000 1 2 8 9 5 4 1000 -40 1000
```
### 样例输出 #2
```
-403015.7500000
```
## 提示

提示：如果你不会做这道题，可以问问 [APJifengc](/user/279652)。
***

样例 1 解释：使得联合权值取到最小值的 $\{b\}$ 为 `0.5 1 1.5 2 2.5`。

***
数据范围和约定：
$$
\newcommand{\arraystretch}{1.5}
\begin{array}{c|c|c|c}\hline\hline
\textbf{Subtask} & \bm{n}\le & \textbf{分值} & \textbf{特殊性质}\\\hline
\textsf{1} & 100 & 10 & \textbf{无} \\\hline
\textsf{2} & 10^6 & 5 & \{a\}\textbf{ 全部相等} \\\hline
\textsf{3} & 10^6 & 5 & \{a\}\textbf{ 单调不减} \\\hline
\textsf{4} & 10^4 & 30 & \textbf{无} \\\hline
\textsf{5} & 10^6 & 50 & \textbf{无}
\\\hline\hline
\end{array}
$$

对于全部数据，有 $1\le n\le 10^6$，$|a_i|\le 10^3$。

***

评分规则：

本题使用 Special Judge，如果你的答案是 $pans$，标准答案是 $cans$，则你将获得
$$\min\Bigg\{100,\Bigg\lfloor\dfrac{0.1}{\min\Big\{|pans-cans|,\Big|\dfrac{|pans-cans|}{cans}\Big|\Big\}}\Bigg\rfloor\Bigg\}$$
分。

**每个 Subtask 内捆绑测试**。即取 Subtask 内得分最小的作为 Subtask 得分。


---

---
title: "「Cfz Round 1」Wqs Game"
layout: "post"
diff: 省选/NOI-
pid: P9580
tag: ['树状数组', '洛谷原创', 'O2优化', '线性基', '洛谷月赛', '单调栈']
---
# 「Cfz Round 1」Wqs Game
## 题目背景

『博』和『奕』喜欢博弈，尤其喜欢 wqs 带权博弈。
## 题目描述

wqs 带权博弈在一个数列 $\{a_i\}$ 上进行，对应有一个 $01$ 串 $\{b_i\}$。

1. 若 $b_i=0$，则 $a_i$ 这个数字是属于『博』的；
2. 若 $b_i=1$，则 $a_i$ 这个数字是属于『奕』的。

游戏规则是，每次给定一个区间 $[l,r]$，从 $a_l$ 到 $a_r$，拥有这个数的人**依次**决定选该数或者不选，两个人都会采用**最优策略**。

因为『博』很强大，她会让着『奕』，于是博弈的规则是，如果最后两个人选的数**按位异或和不为零**，则『奕』获胜，否则『博』获胜。

注意每个人**能看到**对方的选数情况，可以选**多个**数（只要这个数是自己的），最后计算两个人选数的总**异或**和。

对于任意区间 $[l,r]$，若『奕』获胜，则 $w(l,r)=1$，否则 $w(l,r)=0$。

每次查询 $\sum\limits_{l=L}^R\sum\limits_{r=l}^Rw(l,r)$ 的值，对 $2^{32}$ 取模。

由于输入输出量过大，对于 $tp\ne 0$ 的测试点，选手需要自行生成数列 $a_i$ 和询问区间 $[L,R]$，并用特殊方式输出答案。

注意正解**不依赖**特殊的输入输出方式。
## 输入格式

第一行三个正整数 $n,q,tp$，表示数列长度，天数以及每天局数，以及读入方式。

第二行一个长度为 $n$ 的字符串，表示 $01$ 串 $\{b_i\}$；

若 $tp=0$，则第三行 $n$ 个正整数，表示数列 $\{a_i\}$，接下来 $q$ 行，每行两个正整数 $L,R$，表示询问  $\sum\limits_{l=L}^R\sum\limits_{r=l}^Rw(l,r)$ 对 $2^{32}$ 取模的值。

否则，令 `Sd` 初值为 $tp$，`Cnt` 初值为 $0$，先使用函数 `GetA` 依次生成 $a_i$，再使用函数 `GetLR` 依次生成 $L,R$，具体方式以代码形式后附。
## 输出格式

若 $tp=0$ 则输出 $q$ 行，每行一个正整数，表示该询问的答案。

否则，令 $ans_i$ 为第 $i$ 次询问的答案，你需要输出 $(ans_i\times i)\bmod 2^{32}$ 的**按位异或和**。
## 样例

### 样例输入 #1
```
3 2 0
100
3 1 2
1 3
2 3
```
### 样例输出 #1
```
2
0
```
### 样例输入 #2
```
5 2 0
10100
2 7 6 3 5
1 5
2 4
```
### 样例输出 #2
```
8
4
```
### 样例输入 #3
```
20 100 8551679995685981130
11001000000000000000
```
### 样例输出 #3
```
1673
```
## 提示

#### 【样例解释 #1】

只有 $w(1,1)=w(1,2)=1$。

对于区间 $[1,3]$，如果『奕』选第一个数，则『博』选后两个数，否则『博』不选，于是『博』获胜。

注意是从左往右依次选取，『博』在选后两个数之前能够知道『奕』是否选了第一个数。

#### 【样例解释 #2】

只有 $w(1,1)=w(1,2)=w(1,3)=w(1,4)=w(2,3)=w(2,4)=w(3,3)=w(3,4)=1$。

#### 【样例解释 #3】

由于本样例 $tp\ne 0$，所以你需要使用特殊方式输入输出。

#### 【数据范围】

对于所有数据，$1\le n\le5\times10^5,1\le q\le 1.5\times10^6,0<a_i<2^{60},1\le L\le R\le n,0\le tp<2^{64}$。

| 子任务编号 | 分值 |    $n\le$     |     $q\le$      |  $tp$  |  $a_i<$  | 特殊性质 |
| :--------: | :--: | :-----------: | :-------------: | :----: | :------: | :------: |
|    $1$     | $6$  |     $20$      |      $100$      |  $=0$  | $2^{60}$ |    有    |
|    $2$     | $7$  |     $100$     |     $10^3$      |  $=0$  | $2^{10}$ |    有    |
|    $3$     | $8$  |     $700$     |     $10^3$      |  $=0$  | $2^{10}$ |    无    |
|    $4$     | $9$  |    $3000$     |     $10^5$      |  $=0$  | $2^{60}$ |    无    |
|    $5$     | $14$ | $3\times10^4$ |     $10^5$      |  $=0$  | $2^{20}$ |    无    |
|    $6$     | $17$ | $2\times10^5$ | $1.5\times10^6$ | $\ge1$ | $2^{60}$ |    有    |
|    $7$     | $19$ | $5\times10^5$ | $1.5\times10^6$ | $\ge1$ | $2^{60}$ |    有    |
|    $8$     | $20$ | $5\times10^5$ | $1.5\times10^6$ | $\ge1$ | $2^{60}$ |    无    |

特殊性质：序列 $b_i$ 中最多有 $10$ 个 $0$。

#### 【备注】

数据生成方式：

```cpp
using ul=unsigned long long;
using ui=unsigned int;
ui Ans,ans;
ul Sd,Cnt;
ul Rd(){Sd^=Sd<<19,Sd^=Sd>>12,Sd^=Sd<<29;return Sd^=++Cnt;}
void GetA(ul &a){a=Rd()%((1ull<<60)-2)+1;}
void GetLR(int &l,int &r){
    l=Rd()%n+1,r=Rd()%n+1;
    if(l>r)swap(l,r);
}
int main(){
    //read n,q,tp,b[i]
    if(tp){
        Sd=tp,Cnt=0;
        for(int i=1;i<=n;++i)GetA(a[i]);
        for(int qi=1;qi<=q;++qi){
            GetLR(l,r);
            //sol
            Ans^=ans*qi;
        }
        printf("%u\n",Ans);
	}
}
```


---

---
title: "[CERC2019] Be Geeks!"
layout: "post"
diff: 省选/NOI-
pid: P9607
tag: ['2019', '线段树', '倍增', 'ST 表', 'ICPC', '笛卡尔树', '单调栈']
---
# [CERC2019] Be Geeks!
## 题目背景

**题目译自 [CERC 2019](https://contest.felk.cvut.cz/19cerc/solved.html) 「[Be Geeks!](https://contest.felk.cvut.cz/19cerc/solved/begeeks.pdf)」**
## 题目描述

音乐乐队 Be Geeks! 的名字并非偶然，因为所有成员都是真正的数学怪才。除此之外，他们喜欢研究数列的各种性质。下面是他们感兴趣的一个例子：
- 设 $A$ 是一个非空正整数序列，$A=(a_1, a_2, \dots, a_N)$。
- $G(i, j)=\gcd (a_i, a_{i+1}, \dots, a_j)$，其中 $1\le i\le j\le N$。
- $M(i, j)=\max (a_i, a_{i+1}, \dots, a_j)$，其中 $1\le i\le j\le N$。
- $P(i, j)=G(i, j)\times M(i, j)$，其中 $1\le i\le j\le N$。
- $F(A)=\sum P(i, j)[1\le i\le j\le N]$。

给出一个序列 $A$，你需要求出 $F(A)\bmod 1\,000\,000\,007$ 的值。
## 输入格式

第一行包含一个整数 $N\ (1\le N\le 2\times 10^5)$，代表序列 $A$ 的长度。

第二行包含 $N$ 个整数 $a_1, a_2, \dots, a_N\ (1\le a_i\le 10^9)$，代表序列 $A$。
## 输出格式

输出一个整数，代表 $F(A)\bmod 1\,000\,000\,007$ 的值。
## 样例

### 样例输入 #1
```
4
1 2 3 4

```
### 样例输出 #1
```
50

```
### 样例输入 #2
```
5
2 4 6 12 3

```
### 样例输出 #2
```
457

```


---


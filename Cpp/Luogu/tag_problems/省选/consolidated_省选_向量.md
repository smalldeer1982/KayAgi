---
title: "[NOI2013] 向量内积"
layout: "post"
diff: 省选/NOI-
pid: P1224
tag: ['2013', 'NOI', 'Special Judge', '矩阵乘法', '向量']
---
# [NOI2013] 向量内积
## 题目描述

两个 $d$ 维向量 $A=[a_1,a_2,\ldots,a_d]$ 与 $B=[b_1,b_2,\ldots,b_d]$ 的内积为其相对应维度的权值的乘积和，即：

$$(A,B)=\sum_{i=1}^d a_ib_i=a_1b_1+a_2b_2+\ldots+a_db_d$$

现有 $n$ 个 $d$ 维向量 $x_1,\ldots,x_n$ ，小喵喵想知道是否存在两个向量的内积为 $k$ 的倍数。请帮助她解决这个问题。

## 输入格式

第一行包含 $3$ 个正整数 $n,d,k$，分别表示向量的个数，维数以及待检测的倍数。

接下来 $n$ 行每行有 $d$ 个非负整数，其中第 $i$ 行的第 $j$ 个整数表示向量 $x_i$ 的第 $j$ 维权值 $x_{i,j}$。

## 输出格式

包含两个整数，用空格隔开。

如果存在两个向量 $x_p,x_q$ 的内积为 $k$ 的整数倍，则输出两个向量的编号 $p$ 与 $q$（要求 $p<q$）。如果存在多组这样的向量组合，输出其中任意一组即可。

若不存在这样的向量组合，则输出两个 $-1$。

## 样例

### 样例输入 #1
```
3 5 2 
1 0 1 0 1 
1 1 0 1 0 
0 1 0 1 1

```
### 样例输出 #1
```
2 3

```
## 提示

### 数据范围

| 测试点编号 | $n$ | $d$ | $k$ | $x_{i,j}$ |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| $1$ | $2$ | $20$ | $2$ | $\leq 10$ |
| $2$ | $5$ | $20$ | $2$ | $\leq 10$ |
| $3$ | $10$ | $20$ | $3$ | $\leq 10$ |
| $4$ | $20$ | $20$ | $2$ | $\leq 100$ |
| $5$ | $50$ | $20$ | $3$ | $\leq 100$ |
| $6$ | $50$ | $50$ | $2$ | $\leq 10^3$ |
| $7$ | $50$ | $50$ | $3$ | $\leq 3\times 10^6 $ |
| $8$ | $80$ | $80$ | $2$ | $\leq 2\times 10^6 $ |
| $9$ | $100$ | $100$ | $3$ | $\leq 3\times 10^6 $ |
| $10$ | $500$ | $100$ | $3$ | $\leq 3\times 10^6$ |
| $11$ | $10^3$ | $100$ | $2$ | $\leq 2\times 10^6$ |
| $12$ | $10^3$ | $100$ | $3$ | $\leq 3\times 10^6$ |
| $13$ | $10^4$ | $100$ | $2$ | $<10$ |
| $14$ | $10^4$ | $100$ | $3$ | $<10$ |
| $15$ | $1.5\times 10^4$ | $100$ | $2$ | $<10$ |
| $16$ | $1.8\times 10^4$ | $100$ | $2$ | $<10$ |
| $17$ | $2\times 10^4$ | $100$ | $2$ | $<10$ |
| $18$ | $5\times 10^4$ | $30$ | $3$ | $<10$ |
| $19$ | $8\times 10^4$ | $30$ | $3$ | $<10$ |
| $20$ | $10^5$ | $30$ | $3$ | $<10$ |


---

---
title: "[ZJOI2008] 无序运动"
layout: "post"
diff: 省选/NOI-
pid: P2603
tag: ['2008', '各省省选', '浙江', '向量', 'AC 自动机']
---
# [ZJOI2008] 无序运动
## 题目描述

D 博士对物理有着深入的研究，经典物理、天体物理、量子物理都有着以他的名字命名的定理。最近 D 博士着迷于研究粒子运动的无规则性。对圣经深信不疑的他相信，上帝创造的任何事物必然是有序的、有理可循的，而不是无规则的、混沌的。

经过长时间的研究，D 博士找到了很多出现相当频繁的轨迹片断，他把这些轨迹片断储存在一个很大的数据库内。他需要你帮助他写一个程序，对于一个给出的粒子运动轨迹，统计数据库中每个轨迹片断的出现的次数。

为清楚起见，我们定义一个粒子的轨迹为二维平面上的一个点列 $(P_1, P_2, \dots, P_N)$。点列 $P$ 的一个子列 $[i, j]$ 定义为 $P$ 中一段连续的子序列 $(P_i, P_{i + 1}, \dots, P_j)$。点列 $P$ 的一个子列 $[u, v]$ 被称为点列 $Q = (Q_1, Q_2, \dots, Q_{v - u + 1})$ 在 $P$ 中的一次出现，当且仅当 $Q$ 经过有限次的平移、旋转、翻转、放缩之后得到 $Q'$ 满足 $\forall 1 \le k \le u - v + 1$，$ Q'_k = P_{u + k - 1}$。

对点列进行四种操作的解释：
|操作名称|解释|
|:-:|:-:|
|平移|设平移向量为 $(d_x, d_y)$，则任意点 $(x, y)$ 平移后的结果为 $(x + d_x, y + d_y)$|
|旋转|设旋转角为 $t$，则任意点 $(x, y)$ 旋转后的结果为 $(x \cos t - y \sin t, x \sin t + y \cos t)$|
|翻转|任意点 $(x, y)$ 翻转后的结果为 $(x, -y)$
|放缩|设放缩比例为 $p(p \ne 0)$，则任意点 $(x, y)$ 放缩后的结果为 $(px, py)$|
## 输入格式

第一行两个整数 $N, M$，分别描述待处理的粒子运动轨迹的点列大小与数据库内的轨迹片断个数。

接下来 $M$ 行依次给出每个轨迹片断。每行先是一个正整数 $K$，表示该轨迹片断点列的长度。然后 $2K$ 个整数，依次描述点列中的 $K$ 个点的横坐标与纵坐标。

接下来一行 $2N$ 个整数，依次描述待处理的粒子运动轨迹的点列中 $N$ 个点的横坐标与纵坐标。

注：输入中的每条轨迹中任意相邻两点不会相同。
## 输出格式

应包含 $M$ 行，依次给出每个片段在待处理运动轨迹中的出现次数。
## 样例

### 样例输入 #1
```
3 2
2 17 0 10 1
3 0 0 1 0 1 -1
0 0 1 0 1 1

```
### 样例输出 #1
```
2
1

```
## 提示

记片段总长度为 $L$。

对于 $30\%$ 的测试数据，满足 $N, M, K \le 100$，$L \le 500$;

对于 $50\%$ 的测试数据，满足 $N, M, K \le 1000$，$L \le 5000$;

对于 $100\%$ 的测试数据，满足 $N, K \le 2 \times 10 ^ 5$，$L \le 2 \times 10 ^ 6$，保证输入中给出所有点坐标绝对值均不大于 $10 ^ 4$。


---

---
title: "[JLOI2015] 装备购买"
layout: "post"
diff: 省选/NOI-
pid: P3265
tag: ['2015', '吉林', '高斯消元', '线性基', '向量']
---
# [JLOI2015] 装备购买
## 题目描述

脸哥最近在玩一款神奇的游戏，这个游戏里有 $n$ 件装备，每件装备有 $m$ 个属性，用向量 $\mathbf{z_i}=(a_1, \ldots ,a_j, \ldots , a_m)$ 表示 ($1 \leq i \leq n, \ 1 \leq j \leq m$)，每个装备需要花费 $c_i$，现在脸哥想买一些装备，但是脸哥很穷，所以总是盘算着怎样才能花尽量少的钱买尽量多的装备。对于脸哥来说，如果一件装备的属性能用购买的其他装备组合出（也就是说脸哥可以利用手上的这些装备组合出这件装备的效果），那么这件装备就没有买的必要了。

严格的定义是，如果脸哥买了 $\mathbf{z_{i_1}}, \ldots , \mathbf{z_{i_p}}$这 $p$ 件装备，那么对于任意待决定的 $\mathbf{z_h}$，不存在 $b_1, \ldots ,b_p$使得 $b_1\mathbf{z_{i_1}} + \ldots + b_p\mathbf{z_{i_p}} = \mathbf{z_h}$
​​ （$b_i$均是实数），那么脸哥就会买 $\mathbf{z_h}$，否则 $\mathbf{z_h}$ 对脸哥就是无用的了，自然不必购买。

举个例子，$\mathbf{z_1}=(1, 2, 3), \ \mathbf{z_2}=(3, 4, 5), \ \mathbf{z_h}=(2, 3, 4), \ b_1 =\frac{1}{2}, \ b_2 =\frac{1}{2}$，就有 $b_1\mathbf{z_1} + b_2\mathbf{z_2} = \mathbf{z_h}$ ，那么如果脸哥买了 $\mathbf{z_1}$和 $\mathbf{z_2}$ 就不会再买 $\mathbf{z_h}$了。

脸哥想要在买下最多数量的装备的情况下花最少的钱，你能帮他算一下吗？
## 输入格式

第一行两个数 $n,m$。接下来 $n$ 行，每行 $m$ 个数，其中第 $i$ 行描述装备 $i$ 的各项属性值。接下来一行 $n$ 个数，其中 $c_i$ 表示购买第 $i$ 件装备的花费。
## 输出格式

一行两个数，第一个数表示能够购买的最多装备数量，第二个数表示在购买最多数量的装备的情况下的最小花费。
## 样例

### 样例输入 #1
```
3 3
1 2 3
3 4 5
2 3 4
1 1 2
```
### 样例输出 #1
```
2 2
```
## 提示

如题目中描述，选择装备 $1$ 装备 $2$，装备 $1$ 装备 $3$，装备 $2$ 装备 $3$ 均可，但选择装备 $1$ 和装备 $2$ 的花费最小，为 $2$。

对于 $100\%$ 的数据 $,1 \le n,m \le 500$，$0 \le a_j \le 1000$。


---

---
title: "[SDOI2014] 向量集"
layout: "post"
diff: 省选/NOI-
pid: P3309
tag: ['2014', '线段树', '山东', '向量', '凸包']
---
# [SDOI2014] 向量集
## 题目描述

维护一个向量集合，在线支持以下操作：

- `A x y`（$|x|,|y| \le 10^8$）：加入向量 $(x,y)$；
- `Q x y l r`（$|x|,|y| \le 10^8$，$1 \le l \le r \le t$，其中 $t$ 为已经加入的向量个数）：询问第 $l$ 个到第 $r$ 个加入的向量与向量 $(x,y)$ 的点积的最大值。

集合初始时为空。
## 输入格式

输入的第一行包含整数 $N(1 \le N \le 4 \times 10^5)$ 和字符 $s$，分别表示操作数和数据类别；

接下来 $N$ 行，每行一个操作，格式如上所述。    

请注意 $s$ 不为 `E` 时，输入中的所有整数都经过了加密。你可以使用以下程序得到原始输入：

```
inline int decode(int x, long long lastans) {    
    return x ^ (lastans & 0x7fffffff);
}
```

其中 `x` 为程序读入的数，`lastans` 为之前最后一次询问的答案。在第一次询问之前，`lastans` 为 $0$。注：向量 $(x, y)$ 和 $(z, w)$ 的点积定义为 $xz+yw$。
## 输出格式

对每个 `Q` 操作，输出一个整数表示答案。
## 样例

### 样例输入 #1
```
6 A
A 3 2
Q 1 5 1 1
A 15 14
A 12 9
Q 12 8 12 15
Q 21 18 19 18
```
### 样例输出 #1
```
13
17
17

```
## 提示

样例解释：解密之后的输入为
```
    6 E
    A 3 2
    Q 1 5 1 1
    A 2 3
    A 1 4
    Q 1 5 1 2
    Q 4 3 2 3
```



---

---
title: "【模板】多项式乘法（FFT）"
layout: "post"
diff: 省选/NOI-
pid: P3803
tag: ['递归', 'O2优化', '向量', '快速傅里叶变换 FFT']
---
# 【模板】多项式乘法（FFT）
## 题目背景

这是一道多项式乘法模板题。

注意：本题并不属于中国计算机学会划定的提高组知识点考察范围。


## 题目描述

给定一个 $n$ 次多项式 $F(x)$，和一个 $m$ 次多项式 $G(x)$。

请求出 $F(x)$ 和 $G(x)$ 的卷积。

## 输入格式

第一行两个整数 $n,m$。

接下来一行 $n+1$ 个数字，从低到高表示 $F(x)$ 的系数。

接下来一行 $m+1$ 个数字，从低到高表示 $G(x)$ 的系数。

## 输出格式

一行 $n+m+1$ 个数字，从低到高表示 $F(x) \cdot G(x)$ 的系数。

## 样例

### 样例输入 #1
```
1 2
1 2
1 2 1
```
### 样例输出 #1
```
1 4 5 2
```
## 提示

保证输入中的系数大于等于 $0$ 且小于等于 $9$。

对于 $100\%$ 的数据：$1 \le n, m \leq {10}^6$。


---

---
title: "[WC2011] 最大XOR和路径"
layout: "post"
diff: 省选/NOI-
pid: P4151
tag: ['图论', '贪心', '2011', '枚举', '深度优先搜索 DFS', '线性基', '向量', 'WC']
---
# [WC2011] 最大XOR和路径
## 题目描述

XOR（异或）是一种二元逻辑运算，其运算结果当且仅当两个输入的布尔值不相等时才为真，否则为假。 XOR 运算的真值表如下（$1$ 表示真， $0$ 表示假）：

| 输入 | 输入 | 输出 |
| :----------: | :----------: | :----------: |
| A | B | A XOR B |
| 0 | 0 | 0 |
| 0 | 1 | 1 |
| 1 | 0 | 1 |
| 1 | 1 | 0 |


而两个非负整数的 XOR 是指将它们表示成二进制数，再在对应的二进制位进行 XOR 运算。

譬如 $12$ XOR $9$ 的计算过程如下：

$$
12=(1100)_2\ \ \ 9=(1001)_2\\
\begin{matrix}
&1\ 1\ 0\ 0\\
\text{XOR}&1\ 0\ 0\ 1\\
\hline
&0\ 1\ 0\ 1\\
\end{matrix}\\
(0101)_2=5
$$

故 $12$ XOR $9 = 5$。

容易验证， XOR 运算满足交换律与结合律，故计算若干个数的 XOR 时，不同的计算顺序不会对运算结果造成影响。从而，可以定义 $K$ 个非负整数 $A_1$，$A_2$，……，$A_{K-1}$，$A_K$的 XOR 和为

$A_1$ XOR $A_2$ XOR …… XOR $A_{K-1}$ XOR $A_K$

考虑一个边权为非负整数的无向连通图，节点编号为 $1$ 到 $N$，试求出一条从 $1$ 号节点到 $N$ 号节点的路径，使得路径上经过的边的权值的 XOR 和最大。

路径可以重复经过某些点或边，当一条边在路径中出现了多次时，其权值在计算 XOR 和时也要被计算相应多的次数，具体见样例。

## 输入格式

输入文件 xor.in 的第一行包含两个整数 $N$ 和 $M$， 表示该无向图中点的数目与边的数目。

接下来 $M$ 行描述 $M$ 条边，每行三个整数 $S_i$， $T_i$ ， $D_i$， 表示 $S_i$ 与 $T_i$ 之间存在一条权值为 $D_i$ 的无向边。

图中可能有重边或自环。

## 输出格式

输出文件 xor.out 仅包含一个整数，表示最大的 XOR 和（十进制结果）。

## 样例

### 样例输入 #1
```
5 7
1 2 2
1 3 2
2 4 1
2 5 1
4 5 3
5 3 4
4 3 2
```
### 样例输出 #1
```
6
```
## 提示

【样例说明】

![](https://cdn.luogu.com.cn/upload/image_hosting/p6bf4fgf.png)

如图，路径$1 \rightarrow 2 \rightarrow 4 \rightarrow 3 \rightarrow 5 \rightarrow 2 \rightarrow 4 \rightarrow 5$对应的XOR和为

$2$ XOR $1$ XOR $2$ XOR $4$ XOR $1$ XOR $1$ XOR $3 = 6$

当然，一条边数更少的路径$1 \rightarrow 3 \rightarrow 5$对应的XOR和也是$2$ XOR $4 = 6$。

【数据规模】

对于 $20 \%$ 的数据，$N \leq 100$， $M \leq 1000$，$D_i \leq 10^{4}$；

对于 $50 \%$ 的数据，$N \leq 1000$， $M \leq 10000$，$D_i \leq 10^{18}$；

对于 $70 \%$ 的数据，$N \leq 5000$， $M \leq 50000$，$D_i \leq 10^{18}$；

对于 $100 \%$ 的数据，$N \leq 50000$， $M \leq 100000$，$D_i \leq 10^{18}$。





---

---
title: "[SCOI2007] 最大土地面积"
layout: "post"
diff: 省选/NOI-
pid: P4166
tag: ['2007', '四川', '各省省选', '枚举', '向量', '凸包', '叉积']
---
# [SCOI2007] 最大土地面积
## 题目描述

在某块平面土地上有N个点，你可以选择其中的任意四个点，将这片土地围起来，当然，你希望这四个点围成的多边形面积最大。

## 输入格式

第1行一个正整数N，接下来N行，每行2个数x,y，表示该点的横坐标和纵坐标。

## 输出格式

最大的多边形面积，答案精确到小数点后3位。

## 样例

### 样例输入 #1
```
5
0 0
1 0
1 1
0 1
0.5 0.5
```
### 样例输出 #1
```
1.000
```
## 提示

数据范围 n<=2000, |x|,|y|<=100000



---

---
title: "[CQOI2006] 凸多边形 /【模板】半平面交"
layout: "post"
diff: 省选/NOI-
pid: P4196
tag: ['2006', '重庆', '各省省选', '排序', '向量', '栈', '队列', '半平面交']
---
# [CQOI2006] 凸多边形 /【模板】半平面交
## 题目描述

逆时针给出 $n$ 个凸多边形的顶点坐标，求它们交的面积。例如 $n=2$ 时，两个凸多边形如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/7ieux7g3.png)

则相交部分的面积为 $5.233$。
## 输入格式

第一行有一个整数 $n$，表示凸多边形的个数，以下依次描述各个多边形。第 $i$ 个多边形的第一行包含一个整数 $m_i$，表示多边形的边数，以下 $m_i$ 行每行两个整数，逆时针给出各个顶点的坐标。
## 输出格式

输出文件仅包含一个实数，表示相交部分的面积，保留三位小数。
## 样例

### 样例输入 #1
```
2
6
-2 0
-1 -2
1 -2
2 0
1 2
-1 2
4
0 -3
1 -1
2 2
-1 0
```
### 样例输出 #1
```
5.233
```
## 提示

对于 $100\%$ 的数据：$2 \leq n \leq 10$，$3 \leq m_i \leq 50$，每维坐标为 $[-1000,1000]$ 内的整数。


---

---
title: "[CQOI2018] 社交网络"
layout: "post"
diff: 省选/NOI-
pid: P4455
tag: ['2018', '重庆', '各省省选', '生成树', '向量', '构造']
---
# [CQOI2018] 社交网络
## 题目背景

当今社会，在社交网络上看朋友的消息已经成为许多人生活的一部分。通常，一个用户在社交网络上发布一条消息后，他的好友们也可以看见这条消息，并可能转发。转发的消息还可以继续被人转发，进而扩散到整个社交网络中。
## 题目描述

在一个实验性的小规模社交网络中我们发现，有时一条热门消息最终会被所有人转发。为了研究这一现象发生的过程，我们希望计算一条消息所有可能的转发途径有多少种。为了编程方便，我们将初始消息发送者编号为 $1$，其他用户编号依次递增。

该社交网络上的所有好友关系是已知的，也就是说对于 $a, b$ 两个用户，我们知道 $a$ 用户可以看到 $b$ 用户发送的消息。注意可能存在单向的好友关系，即 $a$ 能看到 $b$ 的消息，但 $b$ 不能看到 $a$ 的消息。

还有一个假设是，如果某用户看到他的多个好友转发了同一条消息，他只会选择从其中一个转发，最多转发一次消息。从不同好友的转发，被视为不同的情况。

如果用箭头表示好友关系，下图展示了某个社交网络中消息转发的所有可能情况。（初始消息是用户 $1$ 发送的，加粗箭头表示一次消息转发）

![](https://cdn.luogu.com.cn/upload/pic/17549.png)
![](https://cdn.luogu.com.cn/upload/pic/17550.png)
![](https://cdn.luogu.com.cn/upload/pic/17551.png)
![](https://cdn.luogu.com.cn/upload/pic/17552.png)
![](https://cdn.luogu.com.cn/upload/pic/17553.png)
![](https://cdn.luogu.com.cn/upload/pic/17554.png)

答案对 $10^4 + 7$ 取模。
## 输入格式

第一行有一个整数，表示用户的数量 $n$。  
第二行有一个整数，表示好友关系数目 $m$。  
接下来 $m$ 行，每行两个整数 $a, b$，表示一组好友关系，即用户 $a$ 可以看到用户 $b$ 发送的信息。
## 输出格式

输出一行一个整数表示答案对 $10^4 + 7$ 取模的结果。
## 样例

### 样例输入 #1
```
4
7
2 1
3 1
1 3
2 3
3 2
4 3
4 2

```
### 样例输出 #1
```
6
```
## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 10$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 250$，$1 \leq m \leq n \times (n - 1)$，$1 \leq a, b \leq n$。


---

---
title: "[USACO23OPEN] Good Bitstrings P"
layout: "post"
diff: 省选/NOI-
pid: P9193
tag: ['递推', 'USACO', '2023', 'O2优化', '向量']
---
# [USACO23OPEN] Good Bitstrings P
## 题目描述

For any two positive integers $a$ and $b$, define the function `gen_string(a,b)` by the following Python code:

```
def gen_string(a: int, b: int):
	res = ""
	ia, ib = 0, 0
	while ia + ib < a + b:
		if ia * b <= ib * a:
			res += '0'
			ia += 1
		else:
			res += '1'
			ib += 1
	return res
```

Equivalent C++ code:

```
string gen_string(int64_t a, int64_t b) {
	string res;
	int ia = 0, ib = 0;
	while (ia + ib < a + b) {
		if ((__int128)ia * b <= (__int128)ib * a) {
			res += '0';
			ia++;
		} else {
			res += '1';
			ib++;
		}
	}
	return res;
}
```

$ia$ will equal $a$ and $ib$ will equal $b$ when the loop terminates, so this function returns a bitstring of length $a+b$ with exactly $a$ zeroes and $b$ ones. For example, `gen_string(4,10)=01110110111011`.

Call $a$ bitstring $s$ **good** if there exist positive integers $x$ and $y$ such that s=`gen_string(x,y)`. Given two positive integers $A$ and $B$ $(1\le A,B\le10^{18})$, your job is to compute the number of good prefixes of `gen_string(A,B)`. For example, there are $6$ good prefixes of `gen_string(4,10)`:

```
x = 1 | y = 1 | gen_string(x, y) = 01
x = 1 | y = 2 | gen_string(x, y) = 011
x = 1 | y = 3 | gen_string(x, y) = 0111
x = 2 | y = 5 | gen_string(x, y) = 0111011
x = 3 | y = 7 | gen_string(x, y) = 0111011011
x = 4 | y = 10 | gen_string(x, y) = 01110110111011
```
## 输入格式

The first line contains $T$ $(1\le T\le10)$, the number of independent test cases.

Each of the next $T$ lines contains two integers $A$ and $B$.
## 输出格式

The answer for each test case on a new line.
## 样例

### 样例输入 #1
```
6
1 1
3 5
4 7
8 20
4 10
27 21

```
### 样例输出 #1
```
1
5
7
10
6
13
```
## 提示

Input $2$: $A,B\le100$;\
Input $3$: $A,B\le1000$;\
Inputs $4-7$: $A,B\le10^6$;\
Inputs $8-13$: All answers are at most $10^5$.\
Inputs $14-21$: No additional constraints.
## 题目翻译

### 题目描述

对于任意两个正整数 $a$ 和 $b$，定义函数 `gen_string(a,b)` 如下 Python 代码所示：

```python
def gen_string(a: int, b: int):
	res = ""
	ia, ib = 0, 0
	while ia + ib < a + b:
		if ia * b <= ib * a:
			res += '0'
			ia += 1
		else:
			res += '1'
			ib += 1
	return res
```

等效的 C++ 代码如下：

```cpp
string gen_string(int64_t a, int64_t b) {
	string res;
	int ia = 0, ib = 0;
	while (ia + ib < a + b) {
		if ((__int128)ia * b <= (__int128)ib * a) {
			res += '0';
			ia++;
		} else {
			res += '1';
			ib++;
		}
	}
	return res;
}
```

当循环结束时，$ia$ 将等于 $a$，$ib$ 将等于 $b$，因此该函数返回一个长度为 $a+b$ 的比特串，其中恰好包含 $a$ 个零和 $b$ 个一。例如，`gen_string(4,10)=01110110111011`。

称一个 $0/1$ 串 $s$ 是**好的**，如果存在正整数 $x$ 和 $y$，使得 $s = \text{gen\_string}(x,y)$。给定两个正整数 $A$ 和 $B$ $(1 \le A, B \le 10^{18})$，你的任务是计算 `gen_string(A,B)` 的所有好前缀的数量。例如，`gen_string(4,10)` 有 $6$ 个好前缀：

```
x = 1 | y = 1 | gen_string(x, y) = 01
x = 1 | y = 2 | gen_string(x, y) = 011
x = 1 | y = 3 | gen_string(x, y) = 0111
x = 2 | y = 5 | gen_string(x, y) = 0111011
x = 3 | y = 7 | gen_string(x, y) = 0111011011
x = 4 | y = 10 | gen_string(x, y) = 01110110111011
```

### 输入格式

第一行包含 $T$ $(1 \le T \le 10)$，表示独立测试用例的数量。

接下来的 $T$ 行，每行包含两个整数 $A$ 和 $B$。

### 输出格式

每个测试用例的答案单独占一行。

### 提示

输入 $2$：$A, B \le 100$；\
输入 $3$：$A, B \le 1000$；\
输入 $4-7$：$A, B \le 10^6$；\
输入 $8-13$：所有答案不超过 $10^5$；\
输入 $14-21$：没有额外限制。


---


---
title: "【MX-X1-T4】「KDOI-05」简单的字符串问题"
layout: "post"
diff: 省选/NOI-
pid: P10716
tag: ['字符串', '倍增', '树上启发式合并', 'O2优化', 'KMP 算法', '梦熊比赛']
---
# 【MX-X1-T4】「KDOI-05」简单的字符串问题
## 题目背景

原题链接：<https://oier.team/problems/X1D>。
## 题目描述

你有一个字符串 $S$。$q$ 个询问，每次给出 $(i,k)$，求有多少个非空字符串 $A$，使得存在可空字符串 $B_1,B_2,\dots,B_{k-1}$ 满足：

$$S[1,i]=AB_1AB_2A\dots AB_{k-1}A$$

其中 $S[1,i]$ 表示 $S$ 的长度为 $i$ 的前缀。
## 输入格式

第一行一个正整数 $n$ 表示 $S$ 的长度。

接下来一个长度为 $n$ 且仅包含小写字母的字符串表示 $S$。

接下来一行一个正整数表示 $q$。

接下来 $q$ 行，每行两个正整数表示一个询问的 $i,k$。
## 输出格式

输出 $q$ 行，每行一个非负整数表示答案。
## 样例

### 样例输入 #1
```
10
aabaacaaaa
5
5 3
5 2
6 1
10 4
10 5
```
### 样例输出 #1
```
1
2
1
2
1
```
### 样例输入 #2
```
10
bababababa
10
6 1
6 2
6 3
6 4
6 5
10 2
10 3
9 4
5 5
4 2
```
### 样例输出 #2
```
1
1
1
0
0
2
1
1
0
1

```
## 提示

**【样例解释 \#1】**

对于第一次询问 $(5,3)$，可以取 $A=\texttt{a}$，$B_1=\varepsilon$，$B_2=\texttt{ba}$，其中 $\varepsilon$ 表示空串。可以证明有且仅有一个合法的 $A$。

**【数据范围】**

**本题采用捆绑测试。**

| 子任务编号 | 分值 | $n,q\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|
| $1$ | $5$ | $500$ | 无 |
| $2$ | $10$ | $5000$ | 无 |
| $3$ | $10$ | $2\times10^5$ | $S$ 中字符从 $\tt a,b$ 中随机生成 |
| $4$ | $20$ | $2\times10^5$ | 每个询问的 $k$ 相同 |
| $5$ | $20$ | $5\times10^4$ | 无 |
| $6$ | $35$ | $2\times10^5$ | 无 |

对于 $100\%$ 的数据：$1\leq k\leq i\leq n\leq 2\times 10^5$，$1\leq q\leq 2\times 10^5$，$s$ 仅包含小写字母。


---

---
title: "[NOI2016] 优秀的拆分"
layout: "post"
diff: 省选/NOI-
pid: P1117
tag: ['字符串', '2016', 'NOI', 'O2优化', '枚举', '后缀数组 SA']
---
# [NOI2016] 优秀的拆分
## 题目描述

如果一个字符串可以被拆分为 $\text{AABB}$ 的形式，其中 $\text{A}$ 和 $\text{B}$ 是任意**非空**字符串，则我们称该字符串的这种拆分是优秀的。  
例如，对于字符串 $ \texttt{aabaabaa} $ ，如果令 $\text{A}=\texttt{aab}$，$\text{B}=\texttt{a}$，我们就找到了这个字符串拆分成 $\text{AABB}$ 的一种方式。

一个字符串可能没有优秀的拆分，也可能存在不止一种优秀的拆分。  
比如我们令 $\text{A}=\texttt{a}$，$\text{B}=\texttt{baa}$，也可以用 $\text{AABB}$ 表示出上述字符串；但是，字符串 $\texttt{abaabaa}$ 就没有优秀的拆分。

现在给出一个长度为 $n$ 的字符串 $S$，我们需要求出，在它所有子串的所有拆分方式中，优秀拆分的总个数。这里的子串是指字符串中连续的一段。

以下事项需要注意：

1. 出现在不同位置的相同子串，我们认为是不同的子串，它们的优秀拆分均会被记入答案。
2. 在一个拆分中，允许出现 $\text{A}=\text{B}$。例如 $\texttt{cccc}$ 存在拆分 $\text{A}=\text{B}=\texttt{c}$。
3. 字符串本身也是它的一个子串。
## 输入格式

每个输入文件包含多组数据。

输入文件的第一行只有一个整数 $T$，表示数据的组数。

接下来 $T$ 行，每行包含一个仅由英文小写字母构成的字符串 $S$，意义如题所述。
## 输出格式

输出 $T$ 行，每行包含一个整数，表示字符串 $S$ 所有子串的所有拆分中，总共有多少个是优秀的拆分。
## 样例

### 样例输入 #1
```
4
aabbbb
cccccc
aabaabaabaa
bbaabaababaaba

```
### 样例输出 #1
```
3
5
4
7

```
## 提示

### 样例解释

我们用 $S[i, j]$ 表示字符串 $S$ 第 $i$ 个字符到第 $j$ 个字符的子串（从 $1$ 开始计数）。

第一组数据中，共有三个子串存在优秀的拆分：  
$S[1,4]=\texttt{aabb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{b}$；  
$S[3,6]=\texttt{bbbb}$，优秀的拆分为 $\text{A}=\texttt{b}$，$\text{B}=\texttt{b}$；  
$S[1,6]=\texttt{aabbbb}$，优秀的拆分为 $\text{A}=\texttt{a}$，$\text{B}=\texttt{bb}$。  
而剩下的子串不存在优秀的拆分，所以第一组数据的答案是 $3$。

第二组数据中，有两类，总共四个子串存在优秀的拆分：  
对于子串 $S[1,4]=S[2,5]=S[3,6]=\texttt{cccc}$，它们优秀的拆分相同，均为 $\text{A}=\texttt{c}$，$\text{B}=\texttt{c}$，但由于这些子串位置不同，因此要计算三次；  
对于子串 $S[1,6]=\texttt{cccccc}$，它优秀的拆分有两种：$\text{A}=\texttt{c}$，$\text{B}=\texttt{cc}$ 和 $\text{A}=\texttt{cc}$，$\text{B}=\texttt{c}$，它们是相同子串的不同拆分，也都要计入答案。  
所以第二组数据的答案是 $3+2=5$。

第三组数据中，$S[1,8]$ 和 $S[4,11]$ 各有两种优秀的拆分，其中 $S[1,8]$ 是问题描述中的例子，所以答案是 $2+2=4$。

第四组数据中，$S[1,4]$，$S[6,11]$，$S[7,12]$，$S[2,11]$，$S[1,8]$ 各有一种优秀的拆分，$S[3,14]$ 有两种优秀的拆分，所以答案是 $5+2=7$。

### 数据范围

对于全部的测试点，保证 $1 \leq T \leq 10$。以下对数据的限制均是对于单组输入数据而言的，也就是说同一个测试点下的 $T$ 组数据均满足限制条件。

我们假定 $n$ 为字符串 $S$ 的长度，每个测试点的详细数据范围见下表：

| 测试点编号   | $n \leq$  | 特殊性质           |
| ------------ | --------- | ------------------ |
| $1 \sim 2$   | $300$     | $S$ 中所有字符相同 |
| $3 \sim 4$   | $2\,000$  | $S$ 中所有字符相同 |
| $5 \sim 6$   | $10$      |                    |
| $7 \sim 8$   | $20$      |                    |
| $9 \sim 10$  | $30$      |                    |
| $11 \sim 12$ | $50$      |                    |
| $13 \sim 14$ | $100$     |                    |
| $15$         | $200$     |                    |
| $16$         | $300$     |                    |
| $17$         | $500$     |                    |
| $18$         | $1\,000$  |                    |
| $19$         | $2\,000$  |                    |
| $20$         | $30\,000$ |                    |


---

---
title: "【MX-S6-T3】「KDOI-11」简单的字符串问题 2"
layout: "post"
diff: 省选/NOI-
pid: P11291
tag: ['字符串', '贪心', '倍增', 'Special Judge', 'O2优化', '哈希 hashing', '前缀和', 'KMP 算法', '梦熊比赛']
---
# 【MX-S6-T3】「KDOI-11」简单的字符串问题 2
## 题目背景

原题链接：<https://oier.team/problems/S6C>。
## 题目描述

给定 $n$ 个字符串 $S_1, \ldots, S_n$ 以及一个字符串 $T$。

对于一个字符串 $R$，定义 $|R|$ 表示 $R$ 的长度、$R_{[l,r]}$ 表示 $R$ 的第 $l\sim r$ 个字符组成的字符串。字符串 $R'$ 是字符串 $R$ 的前缀当且仅当存在 $1\leq p\leq |R|$ 且 $p$ 为整数使得 $R'=R_{[1,p]}$。

定义一个字符串 $R$ 是**好的**当且仅当它是某个 $S_i$ 的前缀**或** $R$ **为空**。

对于若干字符串 $R_1,R_2,\dots,R_k$，定义 $R_1+R_2+\dots+R_k$ 为 $R_1,R_2,\dots,R_k$ 顺次拼接得到的字符串。

定义一个三元组 $(l,r,k)$（$l,r,k$ 均为整数）是好的当且仅当 $1\leq l\leq r\leq|T|$，$1\leq k\leq K$ 且存在 $k$ 个**好的**字符串 $R_1,R_2,\dots,R_k$ 使得 $R_1+R_2+\dots+R_k=T_{[l,r]}$。

请你求出好的三元组的数量，并对于每个 $i$ 求出有多少好的三元组 $(l,r,k)$ 满足 $l\leq i\leq r$。如果你只能求出两者中其一，也可以获得部分分数，见【**输出格式**】。
## 输入格式

第一行，三个非负整数 $id,n,K$，其中 $id$ 表示测试点编号（所有样例满足 $id=0$），$n$ 表示字符串数量，$K$ 表示对好的三元组的限制。

接下来 $n$ 行，每行一个字符串 $S_i$。

接下来一行，一个字符串 $T$。
## 输出格式

第一行，一个非负整数，表示好的三元组的数量。

第二行，$\lvert T\rvert$ 个非负整数，第 $i$ 个表示满足 $l\leq i\leq r$ 的好的三元组 $(l,r,k)$ 的数量。

本题使用**自定义校验器**进行评分，对于每个测试点：

* 如果你的程序正确地求出了好的三元组的数量并正确地对于每个 $1\leq i\leq |T|$ 求出了满足 $l\leq i\leq r$ 的好的三元组 $(l,r,k)$ 的数量，你可以获得该测试点 $100\%$ 的分数。
* 如果你的程序未能正确地求出了好的三元组的数量但正确地对于每个 $1\leq i\leq |T|$ 求出了满足 $l\leq i\leq r$ 的好的三元组 $(l,r,k)$ 的数量，你可以获得该测试点 $80\%$ 的分数。
* 如果你的程序正确地求出了好的三元组的数量但未能正确地对于每个 $1\leq i\leq |T|$ 求出了满足 $l\leq i\leq r$ 的好的三元组 $(l,r,k)$ 的数量，你可以获得该测试点 $60\%$ 的分数。
* 否则，你不能获得该测试点的任何分数。

注意，即使你希望获得某测试点 $80\%$ 或 $60\%$ 的分数，你也需要在第一行输出一个数并在第二行输出 $\lvert T\rvert$ 个数。
## 样例

### 样例输入 #1
```
0 1 2
ab
abaab
```
### 样例输出 #1
```
13
5 3 5 6 3
```
### 样例输入 #2
```
0 3 2
abc
ac
b
bacabcab
```
### 样例输出 #2
```
27
4 9 6 11 10 5 6 5
```
### 样例输入 #3
```
0 10 10
wooogpgpoo
owpwgwwp
ooogpgpooo
gppwppgwoo
wooogpgpoo
wowooogpgp
gwwp
ggggogwgpp
wowooogpgp
pgpoooowpw
pgwgwggggggogwgppwppgwooggoogwowooogpgpoooowpwgwwp
```
### 样例输出 #3
```
7698
183 390 577 792 990 1213 1422 1651 1780 1889 1984 2099 2235 2355 2491 2458 2435 2426 2439 2466 2478 2498 2503 2489 2481 2477 2477 2483 2491 2527 2532 2559 2571 2540 2489 2433 2372 2276 2163 2041 1932 1803 1662 1491 1308 1111 900 702 486 252
```
## 提示

**【样例解释 #1】**

符合要求的 $(l,r,k)$ 有以下 $13$ 组：

* $(1,1,1)$；
* $(1,1,2)$；
* $(1,2,1)$；
* $(1,2,2)$；
* $(1,3,2)$；
* $(3,3,1)$；
* $(3,3,2)$；
* $(3,4,2)$；
* $(3,5,2)$；
* $(4,4,1)$；
* $(4,4,2)$；
* $(4,5,1)$；
* $(4,5,2)$。

**【样例 #4】**

见附件中的 `string/string4.in` 与 `string/string4.ans`。

该组样例满足测试点 $1\sim3$ 的约束条件。

**【样例 #5】**

见附件中的 `string/string5.in` 与 `string/string5.ans`。

该组样例满足测试点 $4\sim6$ 的约束条件。

**【样例 #6】**

见附件中的 `string/string6.in` 与 `string/string6.ans`。

该组样例满足测试点 $7\sim10$ 的约束条件。

**【样例 #7】**

见附件中的 `string/string7.in` 与 `string/string7.ans`。

该组样例满足测试点 $13\sim14$ 和测试点 $16\sim17$ 的约束条件。

**【样例 #8】**

见附件中的 `string/string8.in` 与 `string/string8.ans`。

该组样例满足测试点 $18\sim20$ 的约束条件。

**【数据范围】**

对于所有测试数据，保证：$1\leq n\leq10$，$1\leq |S_i|\leq5\times10^4$，$1\leq |T|,K\leq5\times10^5$，字符串仅包含小写英文字母 $\texttt{a}\sim\texttt{z}$。

| 测试点编号 | $n\leq$ | $\lvert S_i\rvert\leq$ |  $\lvert T\rvert\leq$ | $K\leq$ | 特殊性质 |
|:--:|:--:|:--:|:--:|:--:|:--:|
| $1\sim3$ | $10$ | $50$ | $50$ | $50$ | 无 |
| $4\sim6$ | $10$ | $100$ | $300$ | $300$ | 无 |
| $7\sim10$ | $10$ | $1000$ | $5000$ | $5000$ | 无 |
| $11\sim12$ | $10$ | $5\times10^4$ | $5\times10^5$ | $1$ | 无 |
| $13\sim14$ | $10$ | $5\times10^4$ | $5\times10^5$ | $10$ | 无 |
| $15$ | $10$ | $5\times10^4$ | $5\times10^5$ | $5\times10^5$ | 所有字符均为 $\texttt{a}$ |
| $16\sim17$ | $10$ | $5\times10^4$ | $5\times10^5$ | $5\times10^5$ | 所有字符在 $\{\texttt{a},\texttt{b}\}$ 中独立均匀随机生成 |
| $18\sim20$ | $10$ | $5\times10^4$ | $5\times10^5$ | $5\times10^5$ | 无 |


---

---
title: "[TOIP 2023] 分子環"
layout: "post"
diff: 省选/NOI-
pid: P11851
tag: ['字符串', '2023', 'Special Judge', '构造', '台湾']
---
# [TOIP 2023] 分子環
## 样例

### 样例输入 #1
```
2 1 1
```
### 样例输出 #1
```
-1
```
### 样例输入 #2
```
2 1 2
```
### 样例输出 #2
```
2
XXYXY
```
### 样例输入 #3
```
0 0 4
```
### 样例输出 #3
```
2
XXYY
```
### 样例输入 #4
```
4 4 0
```
### 样例输出 #4
```
1
XYXYXYXY
```
### 样例输入 #5
```
5 3 10
```
### 样例输出 #5
```
3
XYYYXYYXYXXXYXXYXX
```


---

---
title: "Mivik 写书"
layout: "post"
diff: 省选/NOI-
pid: P1316
tag: ['字符串', '枚举', '容斥原理', '快速数论变换 NTT']
---
# Mivik 写书
## 题目背景

Mivik 想当大作家。
## 题目描述

Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。由于 Mivik 不会写文章，所以他只好**等概率**随机乱按了 $n$ 个键，打出了一篇文章。

Mivik 定义一篇文章的复杂度是这篇文章所有**非空**本质不同子串的数目。我们认为两个字符串本质不同当且仅当它们的长度不同或者它们有任意一位上的字符不同。例如，文章 `abaa` 的复杂度是 8，因为它一共有 `a`、`b`、`ab`、`ba`、`aa`、`aba`、`baa`、`abaa` 这 8 个非空的本质不同子串。

Mivik 现在想知道，这篇文章期望的复杂度是多少。由于 Mivik 不喜欢奇形怪状的小数，你只需要输出期望的复杂度对 $10^9+7$ 取模后的值。
## 输入格式

一行两个整数 $n$ 和 $m$，意义见题目描述。
## 输出格式

一行一个整数，代表答案对 $10^9+7$ 取模后的值。
## 样例

### 样例输入 #1
```
2 2
```
### 样例输出 #1
```
500000006
```
### 样例输入 #2
```
3 3
```
### 样例输出 #2
```
5
```
### 样例输入 #3
```
3 4
```
### 样例输出 #3
```
250000007
```
## 提示

### 样例解释

样例一：假设键盘上的字符分别为 `a` 和 `b`，那么可能打出来的文章一共有 `aa`、`ab`、`ba`、`bb` 四种，它们的复杂度分别为 2、3、3、2，因此答案为 $\frac{2+3+3+2}{4}=\frac{5}{2}$，对 $10^9+7$ 取模后得到 500000006。

### 数据范围

对于全部数据，有 $1\le n\le 20$，$1\le m\le 5\cdot 10^6$。

Subtask 1 (10 pts)：满足 $1\le n, m\le 7$。

Subtask 2 (20 pts)：满足 $1\le n\le 5$。

Subtask 3 (20 pts)：满足 $1\le n\le 10$。

Subtask 4 (50 pts)：无特殊限制。


---

---
title: "Mivik 的标题"
layout: "post"
diff: 省选/NOI-
pid: P1393
tag: ['字符串', '数学', 'KMP 算法', '快速数论变换 NTT']
---
# Mivik 的标题
## 题目背景

Mivik 现在已经写好了他的书，他现在准备给这本书起个书名去投稿。
## 题目描述

由于 Mivik 写书是乱敲键盘敲出来的，他准备对书名干同样的事情。Mivik 的键盘上有 $m$ 个不同的按键，对应着 $m$ 个不同的字符。Mivik 决定在这个键盘上**等概率**随机敲 $n$ 次敲出标题。但出于某些原因，Mivik 希望书名中要包含有一个人的名字 $S$。于是 Mivik 来问你，他随机敲出的标题有多大的概率包含有这个名字。

同样的，Mivik 并不喜欢奇形怪状的小数，所以你只需要输出这个概率对 $998244353$ 取模后的值。
## 输入格式

第一行三个整数 $n$、$m$、$|S|$，其中 $|S|$ 代表这个名字的长度。

第二行给出 $|S|$ 个整数 $a_i$，代表这个名字。
## 输出格式

一行一个整数，代表概率对 $998244353$ 取模后的值。
## 样例

### 样例输入 #1
```
3 2 2
1 1
```
### 样例输出 #1
```
623902721
```
### 样例输入 #2
```
6 3 4
1 2 3 2
```
### 样例输出 #2
```
480636170
```
## 提示

### 样例解释

样例一：为方便描述，我们定义键盘上两个按键为 `a` 和 `b`。那么长度为 3 的所有字符串共有 `aaa`、`aab`、`aba`、`abb`、`baa`、`bab`、`bba`、`bbb` 这 8 个，其中包含有指定名字 `aa` 的共有 `aaa`、`aab`、`baa` 这三个，则概率为 $\frac{3}{8}$，取模后得到 623902721。

### 数据范围

对于全部数据，有 $1\le |S|\le 10^5$，$|S|\le n\le |S|+10^5$，$1\le m\le 10^8$。

Subtask 1 (5 pts)：满足 $m=1$。

Subtask 2 (20 pts)：满足 $1\le n, m\le 250$。

Subtask 3 (30 pts)：满足 $1\le n, m\le 5000$。

Subtask 3 (45 pts)：无特殊限制。


---

---
title: "拆分数列"
layout: "post"
diff: 省选/NOI-
pid: P1415
tag: ['字符串', '动态规划 DP', '搜索', '洛谷原创']
---
# 拆分数列
## 题目描述

给出一列数字，需要你添加任意多个逗号将其拆成若干个严格递增的数。如果有多组解，则输出使得最后一个数最小的同时，字典序最大的解（即先要满足最后一个数最小；如果有多组解，则使得第一个数尽量大；如果仍有多组解，则使得第二个数尽量大，依次类推……）。

## 输入格式

共一行，为初始的数字。

## 输出格式

共一行，为拆分之后的数列。每个数之间用逗号分隔。行尾无逗号。

## 样例

### 样例输入 #1
```
3456
```
### 样例输出 #1
```
3,4,5,6
```
### 样例输入 #2
```
3526
```
### 样例输出 #2
```
3,5,26
```
### 样例输入 #3
```
3546
```
### 样例输出 #3
```
35,46
```
### 样例输入 #4
```
0001
```
### 样例输出 #4
```
0001
```
### 样例输入 #5
```
100000101
```
### 样例输出 #5
```
100,000101
```
## 提示


### 数据范围及约定

记输入的字符串的长度为 $l$。

- 对于 $10\%$ 的数据，$l \le 5$；
- 对于 $30\%$ 的数据，$l \le 15$；
- 对于 $50\%$ 的数据，$l \le 50$；
- 对于 $100\%$ 的数据，$l \le 500$。

### 题目来源

lzn 改编


---

---
title: "计算电压"
layout: "post"
diff: 省选/NOI-
pid: P2011
tag: ['字符串', '数学', '高斯消元']
---
# 计算电压
## 题目背景

相信不少人轻松灭掉 1，2 两题（蒟蒻无视此句） ，我相信，大家对物理也是很有兴趣的（众人：我们对揍人也是很有兴趣的） ，那么，再奉上 100 分给 Physicaler 们。
## 题目描述

现给定一个电阻网络，已知其中每条边上的电阻，和若干个点和负极之间的电压（电源电压不变） ，现在求任意两点之间的电压。
## 输入格式

第一行四个正整数 $n,m,k,q$，表示有 $n$ 个节点（可能是几个点用导线相连接，与一个点等价，编号为 $1$ 至 $n$，$0$ 号节点为电源负极），$m$ 个定值电阻（每个定值电阻连接两个点），电源正极有 $k$ 个接口，有 $q$ 个询问。

接下来 $k$ 行，每行两个正整数，表示这个正极的编号与该接线柱与电源负极之间的电压 $u_i$。

再接下来 $m$ 行，每行三个正整数 $v_i,w_i,r_i$，表示节点 $v_i$ 与 $w_i$ 之间有一条阻值为 $r_i$ 的电阻丝。

再接下来 $q$ 行，每行两个正整数 $a_i,b_i$，表示要求 $a_i$ 与 $b_i$ 之间的电压。
## 输出格式

一共 $q$ 行，每行一个实数表示 $a_i$ 与 $b_i$ 之间的电压（保留两位小数）。若 $a_i$ 点电压小于 $b_i$ 点电压，输出负值。
## 样例

### 样例输入 #1
```
3 5 1 3

1 18

1 2 6

1 3 2

2 3 6

3 0 6

2 0 2

1 0

2 3

1 2


```
### 样例输出 #1
```
18.00

-6.00

12.00


```
## 提示

【数据范围】

对于 $10\%$ 的数据，$1\le q\le 10$；

对于 $20\%$ 的数据，$1\le n\le 10$，且保证电路为串联、并联或混联；

对于 $40\%$ 的数据，$1\le n\le 40$，$k\le 5$；

对于 $100\%$ 的数据，$1\le k\le n\le 200$，$1\le m\le 2\times 10^5$，$1\le r_i,u_i\le 10^4$，$1\le q\le 10^6$。

【时空限制】

时间限制：1.00s，空间限制：125.00MB。

【样例解释】

如图所示。

![样例解释](https://cdn.luogu.com.cn/upload/pic/722.png)


---

---
title: "不同子串个数"
layout: "post"
diff: 省选/NOI-
pid: P2408
tag: ['字符串', '动态规划 DP', '线性数据结构', '后缀自动机 SAM']
---
# 不同子串个数
## 题目背景

因为 NOI 被虐傻了，蒟蒻的 YJQ 准备来学习一下字符串，于是它碰到了这样一道题：

## 题目描述

给你一个长为 $n$ 的字符串，求不同的子串的个数。

我们定义两个子串不同，当且仅当有这两个子串长度不一样或者长度一样且有任意一位不一样。

子串的定义：原字符串中连续的一段字符组成的字符串。

## 输入格式

第一行一个整数 $n$。

接下来一行 $n$ 个字符表示给出的字符串。

## 输出格式

一行一个整数，表示不一样的子串个数。

## 样例

### 样例输入 #1
```
5
aabaa
```
### 样例输出 #1
```
11
```
### 样例输入 #2
```
3
aba
```
### 样例输出 #2
```
5
```
## 提示

### 提示

请使用64位整数来进行输出。

### 数据规模与约定
- 对于 $30\%$ 的数据，保证 $n\le 1000$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \le 10^5$，字符串中只有小写英文字母。



---

---
title: "[NOI2011] 阿狸的打字机"
layout: "post"
diff: 省选/NOI-
pid: P2414
tag: ['字符串', '树形数据结构', '2011', 'NOI', '深度优先搜索 DFS', 'AC 自动机']
---
# [NOI2011] 阿狸的打字机
## 题目描述

阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有 $28$ 个按键，分别印有 $26$ 个小写英文字母和 `B`、`P` 两个字母。经阿狸研究发现，这个打字机是这样工作的：

* 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。
* 按一下印有 `B` 的按键，打字机凹槽中最后一个字母会消失。
* 按一下印有 `P` 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。

例如，阿狸输入 `aPaPBbP`，纸上被打印的字符如下：

```
a
aa
ab
```

我们把纸上打印出来的字符串从 $1$ 开始顺序编号，一直到 $n$。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数 $(x,y)$（其中 $1\leq x,y\leq n$），打字机会显示第 $x$ 个打印的字符串在第 $y$ 个打印的字符串中出现了多少次。

阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？

## 输入格式

输入的第一行包含一个字符串，按阿狸的输入顺序给出所有阿狸输入的字符。

第二行包含一个整数 $m$，表示询问个数。

接下来 $m$ 行描述所有由小键盘输入的询问。其中第 $i$ 行包含两个整数 $x, y$，表示第 $i$ 个询问为 $(x, y)$。

## 输出格式

输出 $m$ 行，其中第 $i$ 行包含一个整数，表示第 $i$ 个询问的答案。

## 样例

### 样例输入 #1
```
aPaPBbP
3
1 2
1 3
2 3
```
### 样例输出 #1
```
2
1
0
```
## 提示

### 数据范围

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq10^5$，第一行总长度 $\leq 10^5$。

|测试点|$n$ 的规模|$m$ 的规模|字符串长度|第一行长度|
|:-:|:-:|:-:|:-:|:-:|
|$1,2$|$1\leq n\leq 100$|$1\leq m\leq 10^3$| - |$\leq 100$|
|$3,4$|$1\leq n\leq 10^3$|$1\leq m\leq 10^4$|单个长度 $\leq 10^3$，总长度 $\leq 10^5$|$\leq 10^5$|
|$5\sim 7$|$1\leq n\leq 10^4$|$1\leq m\leq 10^5$|总长度 $\leq 10^5$|$\leq 10^5$|
|$8\sim 10$|$1\leq n\leq 10^5$|$1\leq m\leq 10^5$| - |$\leq 10^5$|




---

---
title: "[POI 2000] 病毒"
layout: "post"
diff: 省选/NOI-
pid: P2444
tag: ['字符串', '2000', 'POI（波兰）', 'AC 自动机']
---
# [POI 2000] 病毒
## 题目描述

二进制病毒审查委员会最近发现了如下的规律：某些确定的二进制串是病毒的代码。如果某段代码中不存在任何一段病毒代码，那么我们就称这段代码是安全的。现在委员会已经找出了所有的病毒代码段，试问，是否存在一个无限长的安全的二进制代码。

示例：

例如如果 $\{011, 11, 00000\}$ 为病毒代码段，那么一个可能的无限长安全代码就是 $010101 \ldots$。如果 $\{01, 11, 000000\}$ 为病毒代码段，那么就不存在一个无限长的安全代码。

现在给出所有的病毒代码段，判断是否存在无限长的安全代码。
## 输入格式

第一行包括一个整数 $n$，表示病毒代码段的数目。

以下的 $n$ 行每一行都包括一个非空的 $01$ 字符串，代表一个病毒代码段。

## 输出格式

如果存在无限长的安全代码，输出 `TAK`，否则输出 `NIE`。
## 样例

### 样例输入 #1
```
3
01 
11 
00000

```
### 样例输出 #1
```
NIE
```
## 提示

$1 \leq n \leq 2000$，所有病毒代码段的总长度不超过 $3 \times 10^4$。


---

---
title: "[SCOI2007] 压缩"
layout: "post"
diff: 省选/NOI-
pid: P2470
tag: ['字符串', '动态规划 DP', '2007', '四川', '各省省选', '区间 DP']
---
# [SCOI2007] 压缩
## 题目描述

给一个由小写字母组成的字符串，我们可以用一种简单的方法来压缩其中的重复信息。压缩后的字符串除了小写字母外还可以（但不必）包含大写字母R与M，其中M标记重复串的开始，R重复从上一个M（如果当前位置左边没有M，则从串的开始算起）开始的解压结果（称为缓冲串）。


`bcdcdcdcd` 可以压缩为 `bMcdRR`，下面是解压缩的过程：


已经解压的部分|解压结果|缓冲串
---|---|---
b|b|b
bM|b|.
bMc|bc|c
bMcd|bcd|cd
bMcdR|bcdcd|cdcd
bMcdRR|bcdcdcdcd|cdcdcdcd


## 输入格式

输入仅一行，包含待压缩字符串，仅包含小写字母，长度为n。

## 输出格式

输出仅一行，即压缩后字符串的最短长度。

## 样例

### 样例输入 #1
```
aaaaaaa
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
bcdcdcdcdxcdcdcdcd
```
### 样例输出 #2
```
12
```
## 提示

在第一个例子中，解为aaaRa，在第二个例子中，解为bMcdRRxMcdRR。


【限制】

50%的数据满足：1<=n<=20

 
100%的数据满足：1<=n<=50




---

---
title: "[SDOI2010] 猪国杀"
layout: "post"
diff: 省选/NOI-
pid: P2482
tag: ['模拟', '字符串', '2010', '各省省选', '山东']
---
# [SDOI2010] 猪国杀
## 题目描述

### 游戏背景

《猪国杀》是一种多猪牌类回合制游戏，一共有 $3$ 种角色：主猪，忠猪，反猪。每局游戏主猪有且只有 $1$ 只，忠猪和反猪可以有多只，每只猪扮演 $1 $ 种角色。

### 游戏目的

主猪 / $\texttt{MP}$：自己存活的情况下消灭所有的反猪。  
忠猪 / $\texttt{ZP}$：不惜一切保护主猪，胜利条件与主猪相同。  
反猪 / $\texttt{FP}$：杀死主猪。

### 游戏过程

游戏开始时，每个玩家手里都会有 $4$ 张牌，且体力上限和初始体力都是 $4$ 。

开始游戏时，从主猪开始，按照逆时针方向（数据中就是按照编号从 $ 1 , 2, 3 \ldots n , 1 \ldots $ 的顺序）依次行动。

每个玩家自己的回合可以分为 2 个阶段：

* **摸牌阶段**：从牌堆顶部摸 $2$ 张牌，依次放到手牌的最右边；  
* **出牌阶段**：你可以使用任意张牌，每次使用牌的时候都使用最靠左的能够使用的牌。当然，要满足如下规则：
  1. 如果没有猪哥连弩，每个出牌阶段只能使用 $1$ 次「杀」来攻击；
  2. 任何牌被使用后被弃置（武器是装备上）；被弃置的牌以后都不能再用，即与游戏无关。

### 各种牌介绍

每张手牌用 $1$ 个字母表示，字母代表牌的种类。

#### 基本牌

- 『桃 / $\texttt{P}$』在自己的回合内，如果自己的体力值不等于体力上限，那么使用 $1$ 个桃可以为自己补充 $1$ 点体力，否则不能使用桃；桃只能对自己使用；在自己的回合外，如果自己的血变为 $0$ 或者更低，那么也可以使用。

- 『杀 / $\texttt{K}$』在自己的回合内，对攻击范围内除自己以外的 $1$ 名角色使用。如果没有被『闪』抵消，则造成 $1$ 点伤害。无论有无武器，杀的攻击范围都是 $1$。

- 『闪 / $\texttt{D}$』当你受到杀的攻击时，可以弃置 $1$ 张闪来抵消杀的效果。

#### 锦囊牌

- 『决斗 / $\texttt{F}$』出牌阶段，对除自己以外任意 $1$ 名角色使用，由目标角色先开始，自己和目标角色轮流弃置 $1$ 张杀，首先没有杀可弃的一方受到 $1$ 点伤害，另一方视为此伤害的来源。

- 『南猪入侵 / $\texttt{N}$』出牌阶段，对除你以外所有角色使用，按逆时针顺序从使用者下家开始依次结算，除非弃置 $1$ 张杀，否则受到 $1$ 点伤害。

- 『万箭齐发 / $\texttt{W}$』和南猪入侵类似，不过要弃置的不是杀而是闪。

- 『无懈可击 / $\texttt{J}$』在目标锦囊生效前抵消其效果。每次有 $1$ 张锦囊即将生效时，从使用这张锦囊的猪开始，按照逆时针顺序，依次得到使用无懈可击的机会；效果：用于决斗时，决斗无效并弃置；用于南猪入侵或万箭齐发时，当结算到某个角色时才能使用，当前角色不需弃置牌并且不会受到伤害（仅对 $1$ 个角色产生效果）；用于无懈可击时，成为目标的无懈可击被无效。

#### 装备牌

- 『猪哥连弩 / $\texttt{Z}$』武器，攻击范围 $1$ ，出牌阶段你可以使用任意张杀; 同一时刻最多只能装 $1$ 把武器；如果先前已经有了 $1$ 把武器，那么之后再装武器的话，会弃置以前的武器来装现在的武器。

### 特殊事件及概念解释

* **伤害来源**：杀、南猪入侵、万箭齐发的伤害来源均是使用该牌的猪，决斗的伤害来源如上；

* **距离**：两只猪的距离定义为沿着逆时针方向间隔的猪数 $+1$ 。即初始时 $1$ 和 $2$ 的距离为 $1$ ，但是 $2$ 和 $1$ 的距离就是 $n-1$ 。注意一个角色的死亡会导致一些猪距离的改变；

* **玩家死亡**：如果该玩家的体力降到 $0$ 或者更低，并且自己手中没有足够的桃使得自己的体力值回到 $1$ ，那么就死亡了，死亡后所有的牌（装备区，手牌区）被弃置；

* **奖励与惩罚**：反猪死亡时，最后一个伤害来源处（即使是反猪）立即摸 $3$ 张牌。忠猪死亡时，如果最后一个伤害来源是主猪，那么主猪所有装备牌、手牌被弃置。

注意：一旦达成胜利条件，游戏立刻结束，因此即使会摸 $3$ 张牌或者还有牌可以用也不用执行了。

现在，我们已经知道每只猪的角色、手牌，还有牌堆初始情况，并且假设每个角色会按照如下的行为准则进行游戏，你需要做的就是告诉小猪 iPig 最后的结果。

### 几种行为

* **献殷勤**：使用无懈可击挡下南猪入侵、万箭齐发、决斗；使用无懈可击抵消表敌意；  
* **表敌意**：对某个角色使用杀、决斗；使用无懈可击抵消献殷勤；  
* **跳忠**：即通过行动表示自己是忠猪。跳忠行动就是对主猪或对某只已经跳忠的猪献殷勤，或者对某只已经跳反的猪表敌意；  
* **跳反**：即通过行动表示自己是反猪。跳反行动就是对主猪或对某只已经跳忠的猪表敌意，或者对某只已经跳反的猪献殷勤。

**注意：忠猪不会跳反，反猪也不会跳忠；不管是忠猪还是反猪，能够跳必然跳**。

### 行动准则

#### 共性

* 每个角色如果手里有桃且生命值未满，那么必然吃掉；
* 有南猪入侵、万箭齐发、必然使用；有装备必然装上；
* 受到杀时，有闪必然弃置；
* 响应南猪入侵或者万箭齐发时候，有杀 / 闪必然弃置；
* 不会对未表明身份的猪献殷勤（**包括自己**）。

#### 特性

 - 主猪：
   + 主猪会认为「没有跳身份，且用南猪入侵 / 万箭齐发对自己造成伤害的猪」是**类**反猪（没伤害到不算，注意类反猪并没有表明身份），如果之后跳了，那么主猪会重新认识这只猪；  
   + 对于每种表敌意的方式，对逆时针方向能够执行到的第一只类反猪或者已跳反猪表；如果没有，那么就不表敌意；
   + 决斗时会不遗余力弃置杀；
   + 如果能对已经跳忠的猪或自己献殷勤，那么一定献；如果能够对已经跳反的猪表敌意，那么一定表。
 - 忠猪：
   + 对于每种表敌意的方式，对「逆时针方向能够执行到的第一只已经跳反的猪」表，如果没有，那么就不表敌意；
   + 决斗时，如果对方是主猪，那么不会弃置杀，否则，会不遗余力弃置杀；
   + 如果有机会对主猪或者已经跳忠的猪献殷勤，那么一定献。
 - 反猪：
   + 对于每种表敌意的方式，如果有机会则对主猪表，否则，对「逆时针方向能够执行到的第一只已经跳忠的猪」表，如果没有，那么就不表敌意；
   + 决斗时会不遗余力弃置杀；
   + 如果有机会对已经跳反的猪献殷勤，那么一定献。

限于 iPig 只会用 P++ 语言写 A + B，他请你用 Pigcal (Pascal)、P (C) 或 P++ (C++) 语言来帮他预测最后的结果。
## 输入格式

输入文件第一行包含两个正整数 $ n $ $ (2 \leqslant n \leqslant 10) $ 和 $m$ $ (m \leqslant 2000) $，分别代表玩家数和牌堆中牌的数量。数据保证牌的数量够用。

接下来 $n$ 行，每行 $5$ 个字符串，依次表示对第 $i$ 只猪的角色和初始 $4 $ 张手牌描述。编号为 $1$ 的肯定是主猪。

再接下来一行，一共 $m$ 个字符串，按照从牌堆顶部到牌堆底部的顺序描述每张牌。

**注意：所有的相邻的两个字符串都严格用 $1$ 个空格隔开，行尾没有多余空格**。
## 输出格式

输出数据第一行包含一个字符串代表游戏结果。如果是主猪胜利，那么输出 $\texttt{MP}$ ，否则输出 $\texttt{FP}$ 。数据保证游戏总会结束。

接下来 $n$ 行，第 $i$ 行是对第 $i$ 只猪的手牌描述（注意只需要输出手牌），按照手牌从左往右的顺序输出，相邻两张牌用 $1$ 个空格隔开，行末尾没有多余空格。如果这只猪已阵亡，那么只要输出 $\texttt{DEAD}$ 即可。

**注意：如果要输出手牌而没有手牌的话，那么只需输出 $1$ 个空行**。

**由于数据问题，若牌堆已空，按照每次抽牌抽到的都是最后一张。**
## 样例

### 样例输入 #1
```
3 10
MP D D F F
ZP N N N D
FP J J J J
F F D D J J F F K D

```
### 样例输出 #1
```
FP
DEAD
DEAD
J J J J J J D

```
## 提示

### 样例解释

第一回合：
* 主猪没有目标可以表敌意；
* 接下来忠猪使用了 $3$ 张南猪入侵，主猪掉了 $3$ 点体力，并认为该角色为类反猪，$3$ 号角色尽管手里有无懈可击，但是因为自己未表明身份，所以同样不能对自己用，乖乖掉 $3$ 点体力；  

下一回合：
* 反猪无牌可出；
* 接下来主猪对着类反猪爆发，使用 $4$ 张决斗，忠猪死亡，结果主猪弃掉所有牌；
* 下来反猪摸到 $1$ 张杀直接杀死主猪获胜。

### 子任务

一共 $20$ 组测试数据，每个点 $5$ 分。

$10\%$ 的数据没有锦囊牌，另外 $20\%$ 的数据没有无懈可击。


---

---
title: "[HAOI2016] 找相同字符"
layout: "post"
diff: 省选/NOI-
pid: P3181
tag: ['字符串', '2016', '河南', '后缀数组 SA']
---
# [HAOI2016] 找相同字符
## 题目描述

给定两个字符串，求出在两个字符串中各取出一个子串使得这两个子串相同的方案数。两个方案不同当且仅当这两个子串中有一个位置不同。

## 输入格式

两行，两个字符串 $s_1,s_2$，长度分别为 $n_1,n_2$。

## 输出格式

输出一个整数表示答案。

## 样例

### 样例输入 #1
```
aabb
bbaa
```
### 样例输出 #1
```
10
```
## 提示

$1\le n_1,n_2\le 2\times 10^5$，字符串中只有小写字母。


---

---
title: "[HNOI2011] 括号修复 / [JSOI2011] 括号序列"
layout: "post"
diff: 省选/NOI-
pid: P3215
tag: ['字符串', '2011', '各省省选', '平衡树', '湖南']
---
# [HNOI2011] 括号修复 / [JSOI2011] 括号序列
## 题目描述

一个合法的括号序列是这样定义的：

1.    空串是合法的。
2.    如果字符串 `S` 是合法的，则`(S)`也是合法的。
3.    如果字符串 `A` 和 `B` 是合法的，则 `AB` 也是合法的。

现在给你一个长度为 $n$ 的由`(`和`)`组成的字符串，位置标号从 $1$ 到 $n$。对这个字符串有下列四种操作：


-  `Replace a b c`：将 $[a,b]$ 之间的所有括号改成 $c$。假设原来的字符串为：`))())())(`，那么执行操作 `Replace 2 7 (`  后原来的字符串变为：`)(((((()(`。

-  `Swap a b`：将 $[a,b]$ 之间的字符串翻转。假设原来的字符串为：`))())())(`，那么执行操作 `Swap 3 5` 后原来的字符串变为：`))))(())(`。

-  `Invert a b`：将 $[a,b]$ 之间的 `(` 变成 `)` ，`)` 变成 `(`。假设原来的字符串为：`))())())(`，那么执行操作 `Invert 4 8` 后原来的字符串变为：`))((()(((`。

-  `Query a b`：询问 $[a,b]$ 之间的字符串至少要改变多少位才能变成合法的括号序列。改变某位是指将该位的 `(` 变成 `)` 或 `)` 变成 `(`。注意执行操作 `Query` 并不改变当前的括号序列。假设原来的字符串为：`))())())(`，那么执行操作 `Query 3 6` 的结果为 $2$，因为要将位置 $5$ 的`)`变成`(`并将位置 $6$ 的`(`变成`)`。

## 输入格式

输入文件的第一行是用空格隔开的两个正整数 $n,q$，分别表示字符串的长度和将执行的操作个数。  

第二行是长度为 $n$ 的初始字符串 $S$。接下来的 $q$ 行是将依次执行的$q$个操作，其中操作名与操作数之间以及相邻操作数之间均用空格隔开。

## 输出格式

对于每个 `Query` 操作，输出一行一个整数表示答案。输入数据保证有解。
## 样例

### 样例输入 #1
```
4 5
((((
Replace 1 2 )
Query 1 2
Swap 2 3
Invert 3 4
Query 1 4
```
### 样例输出 #1
```
1
2

```
## 提示

### 样例解释

输入中有 $2$ 个 `Query` 操作，所以输出有 $2$ 行。   
执行第一个 `Query` 操作时的括号序列为 `))((`，因改变第 $1$ 位可使 $[1,2]$ 之间的字符串变成合法的括号序列，故输出的第一行为 `1`。  

执行第二个 `Query` 操作时的括号序列为 `)(()`，因要改变第 $1$ 位和第 $2$ 位才能使 $[1,4]$ 之间的字符串变成合法的括号序列，故输出的第二行为 `2`。

### 数据范围

对于 $30\%$ 的数据，$1\le n,q \le 3000$；   
对于 $100\%$ 的数据，$1\le n,q \le 10^5$。


---

---
title: "[HNOI2014] 抄卡组"
layout: "post"
diff: 省选/NOI-
pid: P3234
tag: ['字符串', '2014', '湖南', '哈希 hashing', '前缀和']
---
# [HNOI2014] 抄卡组
## 题目描述

一天闲着无聊的小L找来了当前正火爆的游戏《炉石传说》来玩，但是怎么打怎么输，于是他大喊一声”我要抄卡组！“就找来了游戏传说组第一名的游戏高手小H的直播来看。

但是小L家的网络技术还停留在拨号，看着直播画面又是卡顿又是花屏，他不给力的网络让他完全无法记录小H展示的给力的卡组。小L周围都是学霸没有人玩游戏想去帮他这个忙，但是学霸们热衷于讨论各种信息学问题。

于是他想到了一个方法：由于每次花屏的屏幕位置不一样，于是小H每次总能记录下卡组的一些部分，如果这样记录多次，不就有可能还原出小L想要的一个卡组么？

但是存在的一个问题是，小H每次展示的卡组有可能不一样，所以他想知道他每次看直播抄下来几次的卡组碎片是否一致。

这样一来小H将他遇到的游戏问题抽象成这样一个学术问题让学霸（你）解决：'\*'可以匹配任意长度个的字符 （包含0个），问所有字符串是否两两匹配。

## 输入格式

第一行包含一个正整数T，表示了数据组数。    接下来包含T组数据：    每组数据的第一行是一个正整数N，表示该组数据酌字符串个数。    接下来N行，每行一个字符串，字符串仅包含小写字母、数字、通配符术。注意:数据为UNIX格式，中间包含空行,你可以采用逐字符读入的方式

## 输出格式

输出包含T行，每行一个字母Y或者N，Y表示这组数据中所有字符串两两匹配，N表示这组数据中至少有一对字符串不匹配。

## 样例

### 样例输入 #1
```
10
2
1234567890*1234567890
1234567890a1234567890
2
1234567890*1234567890
1234567890*1234567890
2
1234*67890a1234567890
1234567890*1234567890
2
1234567890*1234567890
1234567890a12345*7890
2
1234567890*1234567890
*12345
2
12345*67890
1234567890*1234567890
2
1234567890*1234567890
12345*
2
1234567890*1234567890
*67890
2
67890*
1234567890*1234567890
2
1234567890*a*1234567890
1234567890*1234567890
```
### 样例输出 #1
```
Y

Y

Y

Y

N

Y

Y

Y

N

Y
```
## 提示

对于100%的数据，满足N<= 100000，T= 10，输入文件不超过10M，N\*最长字符串长度不超过2x10^8

目前有且仅有 hack 数据中 $T = 1$。


---

---
title: "[HNOI2016] 大数"
layout: "post"
diff: 省选/NOI-
pid: P3245
tag: ['字符串', '2016', '离散化', '湖南', '排序']
---
# [HNOI2016] 大数
## 题目描述

小 B 有一个很大的数 $S$，长度达到了 $n$ 位；这个数可以看成是一个数字串，它可能有前导 $0$，例如 `00009312345`。小 B 还有一个素数 $p$。现在，小 B 提出了 $m$ 个询问，每个询问求 $S$ 的一个子串中有多少子串是 $p$ 的倍数（$0$ 也是 $p$ 的倍数）。例如 $S$ 为 `0077` 时，其子串 `007` 有 $6$ 个子串：`0,0,7,00,07,007`；显然 `0077` 的子串 `007` 有 $6$ 个子串都是素数 $7$ 的倍数。
## 输入格式

第一行一个整数：$p$。

第二行一个数字串：$S$。

第三行一个整数：$m$。接下来 $m$ 行，每行两个整数 $fr,to$，表示对 $S$ 的子串 $S[fr\dots to]$ 的一次询问。注意：$S$ 的最左端的数字的位置序号为 $1$；例如 $S$ 为 `213567`，则 $S[1\dots 3]$ 为 `213`。

## 输出格式

输出 $m$ 行，每行一个整数，第 $i$ 行是第 $i$ 个询问的答案。
## 样例

### 样例输入 #1
```
11
121121
3
1 6
1 5
1 4
```
### 样例输出 #1
```
5

3

2

//第一个询问问的是整个串，满足条件的子串分别有：121121,2112,11,121,121。
```
## 提示

#### 样例 1 解释

第一个询问问的是整个串，满足条件的子串分别有：`121121,2112,11,121,121`。

#### 数据范围

对于 $100\%$ 的数据，$1\le n,m\le 2\times 10^5$，$2\le p\le 10^9$，$S$ 中只有数字字符，$p$ 为素数。


---

---
title: "[SCOI2013] 密码"
layout: "post"
diff: 省选/NOI-
pid: P3279
tag: ['字符串', '2013', '四川', '并查集', '各省省选']
---
# [SCOI2013] 密码
## 题目描述

Fish是一条生活在海里的鱼。有一天他很无聊，就到处去寻宝。他找到了位于海底深处的宫殿，但是一扇带有密码锁的大门却阻止了他的前进。

通过翻阅古籍，Fish 得知了这个密码的相关信息：

1. 该密码的长度为N。

2. 密码仅含小写字母。

3. 以每一个字符为中心的最长回文串长度。

4. 以每两个相邻字符的间隙为中心的最长回文串长度。

很快Fish 发现可能有无数种满足条件的密码。经过分析，他觉得这些密码中字典序最小的一个最有可能是答案，你能帮他找到这个密码么？

注意：对于两个串A和B，如果它们的前i个字符都相同，而A的第i+1个字符比B的第i+1个字符小，那么认为是则称密码A 的字典序小于密码B 的字典序，例如字符串abc 字典序小于字符串acb。如果密码A的字典序比其他所有满足条件的密码的字典序都小，则密码A是这些密码中字典序最小的一个。

## 输入格式

输入由三行组成。第一行仅含一个整数N，表示密码的长度。第二行包含N 个整数，表示以每个字符为中心的最长回文串长度。第三行包含N - 1 个整数，表示每两个相邻字符的间隙为中心的最长回文串长度。

## 输出格式

输出仅一行。输出满足条件的最小字典序密码。古籍中的信息是一定正确的，故一定存在满足条件的密码。

## 样例

### 样例输入 #1
```
3
1 1 1
0 0
```
### 样例输出 #1
```
abc

```
### 样例输入 #2
```
3
1 3 1
0 0
```
### 样例输出 #2
```
aba
```
### 样例输入 #3
```
3
1 3 1
2 2
```
### 样例输出 #3
```
aaa
```
## 提示

对于20% 的数据，1 <= n <= 100。

另有30% 的数据，1 <= n <= 1000。

最后50% 的数据，1 <= n <= 10^5。



---

---
title: "[SCOI2013] 数数"
layout: "post"
diff: 省选/NOI-
pid: P3281
tag: ['字符串', '2013', '四川', '数位 DP', '进制']
---
# [SCOI2013] 数数
## 题目描述

Fish 是一条生活在海里的鱼，有一天他很无聊，就开始数数玩。他数数玩的具体规则是：

1. 确定数数的进制B

2. 确定一个数数的区间[L, R]

3. 对于[L, R] 间的每一个数，把该数视为一个字符串，列出该字符串的每一个（连续的）子串对应的B进制数的值。

4. 对所有列出的数求和。现在Fish 数了一遍数，但是不确定自己的结果是否正确了。由于[L, R] 较大，他没有多余精力去验证是否正确，你能写一个程序来帮他验证吗？

## 输入格式

输入包含三行。

第一行仅有一个数B，表示数数的进制。

第二行有N +1 个数，第一个数为N，表示数L 在B 进制下的长度为N，接下里的N个数从高位到低位的表示数L 的具体每一位。

第三行有M+ 1 个数，第一个数为M，表示数R 在B 进制下的长度为M，接下里的M个数从高位到低位的表示数R 的具体每一位。

## 输出格式

输出仅一行，即按照Fish 数数规则的结果，结果用10 进制表示，由于该数可能很大，输出该数模上20130427的模数。

数据中有 $r<l$ 的情况，输出的是 $-ans[r+1,l-1]\bmod 20130427$
## 样例

### 样例输入 #1
```
10
3 1 0 3
3 1 0 3
```
### 样例输出 #1
```
120

```
## 提示

【样例解释】

[103, 103] 之间仅有数103，该数的所有子串包括1, 10, 103, 0, 03, 3，其和为120。

【数据范围与约定】

20% 数据，0 <= L <= R <= 10^5。

50% 数据，2 <= B <= 1000，1 <= N,M <= 1000。

100% 数据，2 <= B <= 10^5，1 <= N,M <= 10^5。



---

---
title: "[SDOI2014] 数数"
layout: "post"
diff: 省选/NOI-
pid: P3311
tag: ['字符串', '动态规划 DP', '2014', '山东', 'O2优化', '数位 DP', 'AC 自动机']
---
# [SDOI2014] 数数
## 题目描述

我们称一个正整数 $x$ 是幸运数，当且仅当它的十进制表示中不包含数字串集合 $s$ 中任意一个元素作为其子串。例如当 $s = \{22, 333, 0233\}$ 时，$233$ 是幸运数，$2333$、$20233$、$3223$ 不是幸运数。给定 $n$ 和 $s$，计算不大于 $n$ 的幸运数个数。

答案对 $10^9 + 7$ 取模。
## 输入格式

第一行有一个整数，表示 $n$。

第二行有一个整数，表示 $s$ 中的元素个数 $m$。

接下来 $m$ 行，每行一个数字串 $s_i$，表示 $s$ 中的一个元素。
## 输出格式

输出一行一个整数，表示答案对 $10^9 + 7$ 取模的结果。
## 样例

### 样例输入 #1
```
20
3
2
3
14
```
### 样例输出 #1
```
14
```
## 提示

#### 样例 1 解释

除了 $3, 13, 2, 12, 20, 14$ 以外，不大于 $20$ 的整数都是幸运数字。

#### 数据规模与约定

对于全部的测试点，保证：

$1 \leq n < 10^{1201}$，$1 \leq m \leq 100$，$1 \leq \sum_{i = 1}^m |s_i| \leq 1500$，$\min_{i = 1}^m |s_i| \geq 1$，其中 $|s_i|$ 表示字符串 $s_i$ 的长度。$n$ 没有前导 $0$，但是 $s_i$ 可能有前导 $0$。


---

---
title: "[SDOI2015] 双旋转字符串"
layout: "post"
diff: 省选/NOI-
pid: P3318
tag: ['字符串', '2015', '山东', '哈希 hashing']
---
# [SDOI2015] 双旋转字符串
## 题目描述

给定两个字符串集合 S 和 T 。其中 S 中的所有字符串长度都恰好为 N ，而 T 中所有字符串长度都恰好为 M 。且 N+M 恰好为偶数。如果记 S 中字符串全体为 S1，S2，...，STotalS ,而 T 中字符串全体为 T1，T2，...，TTotalT 。现在希望知道有多少对 <i,j> ，满足将 Si 和 Tj 拼接后得到的字符串 Si+Tj 满足双旋转性。

一个长度为偶数字符串 W 可以表示成两段长度相同的字符串的拼接，即 W=U+V。如果 V 可以通过 U 旋转得到，则称 W 是满足双旋转性的。比如说字符串 U=”vijos“可以通过旋转得到”ijosv“，”josvi“，”osvij“ 或”svijo“。那么”vijosjosvi“就是满足双旋转性的字符串。

## 输入格式

第一行输入四个正整数，分别为 TotalS，TotalT，N 和 M，依次表示集合 S 的大小，集合 T 的大小，集合 S 中字符串的长度和集合 T 中字符串的长度。之后 TotalS 行，依次给出 S 中所有的字符串 Si，1<=i<=TotalS。保证每一个字符串长度都恰为 N ，且字符串只由 26 个小写字母组成。之后 TotalT 行，依次给出 T 中所有的字符串 Ti，1<=i<=TotalT。保证每一个字符串长度都恰为 M ，且字符串只由 26 个小写字母组成。1<=N<=100；1<=M<=100；1<=TotalS<=100；1<=Total^T<=100,2<=N\*TotalS+M\*TotalT<=4&times;10^6

## 输出格式

输出一个整数，表示满足要求的数字对 <i,j> 有多少个。

## 样例

### 样例输入 #1
```
4 4 7 3
vijosvi
josvivi
vijosos
ijosvsv
jos
vij
ijo
jos
```
### 样例输出 #1
```
6
```


---

---
title: "[ZJOI2015] 诸神眷顾的幻想乡"
layout: "post"
diff: 省选/NOI-
pid: P3346
tag: ['字符串', '2015', '浙江', '后缀自动机 SAM', 'O2优化']
---
# [ZJOI2015] 诸神眷顾的幻想乡
## 题目描述

幽香是全幻想乡里最受人欢迎的萌妹子，这天，是幽香的 $2600$ 岁生日，无数幽香的粉丝到了幽香家门前的太阳花田上来为幽香庆祝生日。

粉丝们非常热情，自发组织表演了一系列节目给幽香看。幽香当然也非常高兴啦。

这时幽香发现了一件非常有趣的事情，太阳花田有 $n$ 块空地。

在过去，幽香为了方便，在这 $n$ 块空地之间修建了 $n-1$ 条边将它们连通起来。

也就是说，这 $n$ 块空地形成了一个树的结构。

有 $n$ 个粉丝来到了太阳花田上。

为了表达对幽香生日的祝贺，他们选择了 $c$ 种颜色的衣服，每种颜色恰好可以用一个 $0$ 到 $c-1$ 之间的整数来表示。

并且每个人都站在一个空地上，每个空地上也只有一个人。

这样，整个太阳花田就花花绿绿了。幽香看到了，感觉也非常开心。

粉丝们策划的一个节目是这样的，选中两个粉丝 $A$ 和 $B$（$A$ 和 $B$ 可以相同），然后A所在的空地到B所在的空地的路径上的粉丝依次跳起来（包括端点）。

这样幽香就能看到一个长度为 $A$ 到 $B$ 之间路径上的所有粉丝的数目（包括 $A$ 和 $B$）的颜色序列。

一开始大家打算让任意两个粉丝（注意：$A,B$ 和 $B,A$ 是不同的，他们形成的序列刚好相反）都来一次。

但是有人指出这样可能会出现一些一模一样的颜色序列，会导致审美疲劳。

于是他们想问，在这个树上，一共有多少可能的不同的颜色序列幽香可以看到呢？

由于太阳花田的结构比较特殊，只与一个空地相邻的空地数量不超过 $20$ 个。
## 输入格式

第一行两个正整数 $n,c$，表示空地数量和颜色数量。

第二行有 $n$ 个 $0$ 到 $c-1$ 之间，由空格隔开的整数，依次表示第 $i$ 块空地上的粉丝的衣服颜色。

接下来 $n-1$ 行，每行两个正整数 $u,v$，表示有一条连接空地 $u$ 和空地 $v$ 的边。
## 输出格式

一行，输出一个整数，表示答案。
## 样例

### 样例输入 #1
```
7 3
0 2 1 2 1 0 0
1 2
3 4
3 5
4 6
5 7
2 5
```
### 样例输出 #1
```
30
```
## 提示

#### 数据规模与约定

- 对于 $15\%$ 的数据，$n\le2\times 10^3$。
- 另有 $5\%$ 的数据，所有空地都至多与两个空地相邻。
- 另有 $5\%$ 的数据，除一块空地与三个空地相邻外，其他空地都分别至多与两个空地相邻。
- 另有 $5\%$ 的数据，除某两块空地与三个空地相邻外，其他空地都分别至多与两个空地相邻。
- 对于 $100\%$ 的数据，$1\le n\le10^5$，$1\le c\le10$，$1 \leq u, v \leq n$。


---

---
title: "[POI 2007] OSI-Axes of Symmetry"
layout: "post"
diff: 省选/NOI-
pid: P3454
tag: ['字符串', '计算几何', '2007', 'POI（波兰）', 'KMP 算法']
---
# [POI 2007] OSI-Axes of Symmetry
## 题目描述

Little Johnny - a well-respected young mathematician - has a younger sister, Justina. Johnny likes hissister very much and he gladly helps her with her homework, but, like most scientific minds, he does mindsolving the same problems again. Unfortunately, Justina is a very diligent pupil, and so she asks Johnny toreview her assignments many times, for sake of certainty. One sunny Friday, just before the famous LongMay Weekend1 the math teacher gave many exercises consisting in finding the axes of symmetry of variousgeometric figures. Justina is most likely to spend considerable amount of time solving these tasks. LittleJohnny had arranged himself a trip to the seaside long time before, nevertheless he feels obliged to help hislittle sister. Soon, he has found a solution - it would be best to write a programme that wouldease checking Justina's solutions. Since Johnny is a mathematician, not a computer scientist, and you are hisbest friend, it falls to you to write it.

## Task

Write a programme that:

- reads the descriptions of the polygons from the standard input,

- determines the number of axes of symmetry for each one of them,

- writes the result to the standard output.


给定一个多边形，求对称轴数量。

## 输入格式

In the first line of the input there is one integer $t$ ($1 \le t \le 10$) - it is the number of polygons, for which the number of axes of symmetry is to be determined. Next, $t$ descriptions of the polygons follow. The first line of each description contains one integer $n$ ($3 \le n \le 100\ 000$) denoting the number of vertices of the polygon. In each of the following $n$ lines there are two integers $x$ and $y$ ($-100\ 000\ 000 \le x, y \le 100\ 000\ 000$) representing the coordinates of subsequent vertices of the polygon. The polygons need not be convex, but they have no self-intersections - any two sides have at most one common point - their common endpoint, if they actually share it. Furthermore, no pair of consecutive sides is parallel.

## 输出格式

Your programme should output exactly $t$ lines, with the $k$'th line containing a sole integer $n_k$ - the number of axes of symmetry of the $k$'th polygon.

## 样例

### 样例输入 #1
```
2
12
1 -1
2 -1
2 1
1 1
1 2
-1 2
-1 1
-2 1
-2 -1
-1 -1
-1 -2
1 -2
6
-1 1
-2 0
-1 -1
1 -1
2 0
1 1
```
### 样例输出 #1
```
4
2
```
## 题目翻译

### 题目描述

Johnny 是一位非常年轻的数学家，但他此刻正在为他妹妹的数学作业烦恼。

这个周末，他的妹妹需要完成一项作业，计算各种几何图形的对称轴数量。因为 Johnny 这个周末想要去海边旅行，所以他希望他的妹妹能尽快完成这项作业。

于是他找到了擅长编程的你，你一定能帮助他完成这项任务的！

### 输入格式

输入包含多组数据。

第一行包含一个整数 $t$，代表数据的组数。

对于每组数据，第一行一个整数 $n$，代表多边形的顶点数。

接下来 $n$ 行，每行两个整数 $x_i,y_i$，代表每个顶点的坐标。

输入中的第 $i$ 个顶点会与第 $i+1$ 个顶点连一条边。特别地，输入中的第 $n$ 个顶点会与第一个顶点连一条边。

输入给出的多边形**不保证**是凸多边形，但是保证任意两条边只会在端点处相交，且任意两条相邻的边不共线。

### 输出格式

对于每组数据，输出一行一个整数，即多边形对称轴的数量。

### 数据范围

$1 \leq t \leq 10$，$3 \leq n \leq 10^5$，$-10^8 \leq x_i,y_i \leq 10^8$。


---

---
title: "[POI 2012] PRE-Prefixuffix"
layout: "post"
diff: 省选/NOI-
pid: P3546
tag: ['字符串', '2012', 'POI（波兰）', '哈希 hashing', '线性递推', 'KMP 算法']
---
# [POI 2012] PRE-Prefixuffix
## 题目描述

We consider strings consisting of lowercase letters of the English alphabet in this problem.

An initial fragment of a given string is called its prefix.

A final (terminal) fragment of a given string is called its suffix.

In particular, the empty string is both a prefix and a suffix of any string.

Two strings are cyclically equivalent if one of them can be obtained from another by    moving its certain suffix from the end of the string to its beginning.

For example, the strings ![](http://main.edu.pl/images/OI19/pre-en-tex.1.png) and ![](http://main.edu.pl/images/OI19/pre-en-tex.2.png) are cyclically equivalent, whereas the strings ![](http://main.edu.pl/images/OI19/pre-en-tex.3.png) and ![](http://main.edu.pl/images/OI19/pre-en-tex.4.png) are not.

In particular, every string is cyclically equivalent to itself.

A string ![](http://main.edu.pl/images/OI19/pre-en-tex.5.png) consisting of ![](http://main.edu.pl/images/OI19/pre-en-tex.6.png) letters is given.

We are looking for its prefix ![](http://main.edu.pl/images/OI19/pre-en-tex.7.png) and suffix ![](http://main.edu.pl/images/OI19/pre-en-tex.8.png) of equal length such that:

![](http://main.edu.pl/images/OI19/pre-en-tex.9.png) and ![](http://main.edu.pl/images/OI19/pre-en-tex.10.png) are cyclically equivalent,                  the common length of ![](http://main.edu.pl/images/OI19/pre-en-tex.11.png) and ![](http://main.edu.pl/images/OI19/pre-en-tex.12.png) does not exceed ![](http://main.edu.pl/images/OI19/pre-en-tex.13.png)        (i.e., the prefix ![](http://main.edu.pl/images/OI19/pre-en-tex.14.png) and the suffix ![](http://main.edu.pl/images/OI19/pre-en-tex.15.png) do not overlap in ![](http://main.edu.pl/images/OI19/pre-en-tex.16.png)), and                  the common length of ![](http://main.edu.pl/images/OI19/pre-en-tex.17.png) and ![](http://main.edu.pl/images/OI19/pre-en-tex.18.png) is maximized.

对于两个串 $S_1, S_2$，如果能够将 $S_1$ 的一个后缀移动到开头后变成 $S_2$，就称 $S_1$ 和 $S_2$ 循环相同。例如串 ababba 和串 abbaab 是循环相同的。

给出一个长度为 $n$ 的串 $S$，求满足下面条件的最大的 $L(L\leq \frac n 2)$：$S$ 的 $L$ 前缀和 $S$ 的 $L$ 后缀是循环相同的。
## 输入格式

The first line of the standard input contains a single integer ![](http://main.edu.pl/images/OI19/pre-en-tex.19.png)      (![](http://main.edu.pl/images/OI19/pre-en-tex.20.png)) denoting the length of the string ![](http://main.edu.pl/images/OI19/pre-en-tex.21.png).

The second line of input contains the string ![](http://main.edu.pl/images/OI19/pre-en-tex.22.png) itself, consisting of ![](http://main.edu.pl/images/OI19/pre-en-tex.23.png) lowercase letters of the English alphabet.

In tests worth 30% of the points the condition ![](http://main.edu.pl/images/OI19/pre-en-tex.24.png) holds in addition.

In tests worth 50% of the points the condition ![](http://main.edu.pl/images/OI19/pre-en-tex.25.png) holds in addition.

## 输出格式

Your program should print a single integer in the first and only line of the standard output,      namely the common length of the prefix ![](http://main.edu.pl/images/OI19/pre-en-tex.26.png) and the suffix ![](http://main.edu.pl/images/OI19/pre-en-tex.27.png) that we are looking for.

## 样例

### 样例输入 #1
```
15
ababbabababbaab
```
### 样例输出 #1
```
6
```
## 提示

数据范围：

- 对于 $30\%$ 的数据，保证 $n\le 500$；
- 对于 $50\%$ 的数据，保证 $n\le 5000$；
- 对于 $100\%$ 数据，保证 $1\le n\le 10^6$。


---

---
title: "[APIO2014] 回文串"
layout: "post"
diff: 省选/NOI-
pid: P3649
tag: ['字符串', '2014', 'APIO', '后缀自动机 SAM', '后缀数组 SA', '回文自动机 PAM']
---
# [APIO2014] 回文串
## 题目描述

给你一个由小写拉丁字母组成的字符串 $s$。我们定义 $s$ 的一个子串的存在值为这个子串在 $s$ 中出现的次数乘以这个子串的长度。

对于给你的这个字符串 $s$，求所有回文子串中的最大存在值。

## 输入格式

一行，一个由小写拉丁字母（a~z）组成的非空字符串 $s$。

## 输出格式

输出一个整数，表示所有回文子串中的最大存在值。

## 样例

### 样例输入 #1
```
abacaba

```
### 样例输出 #1
```
7

```
### 样例输入 #2
```
www
```
### 样例输出 #2
```
4
```
## 提示

【样例解释1】

用 $\lvert s \rvert$ 表示字符串 $s$ 的长度。

一个字符串 $s_1 s_2 \dots s_{\lvert s \rvert}$ 的子串是一个非空字符串 $s_i s_{i+1} \dots s_j$，其中 $1 \leq i \leq j \leq \lvert s \rvert$。每个字符串都是自己的子串。

一个字符串被称作回文串当且仅当这个字符串从左往右读和从右往左读都是相同的。

这个样例中，有 $7$ 个回文子串 a，b，c，aba，aca，bacab，abacaba。他们的存在值分别为 $4, 2, 1, 6, 3, 5, 7$。

所以回文子串中最大的存在值为 $7$。



第一个子任务共 8 分，满足 $1 \leq \lvert s \rvert \leq 100$。

第二个子任务共 15 分，满足 $1 \leq \lvert s \rvert \leq 1000$。

第三个子任务共 24 分，满足 $1 \leq \lvert s \rvert \leq 10000$。

第四个子任务共 26 分，满足 $1 \leq \lvert s \rvert \leq 100000$。

第五个子任务共 27 分，满足 $1 \leq \lvert s \rvert \leq 300000$。



---

---
title: "[CERC2016] 凸轮廓线 Convex Contour"
layout: "post"
diff: 省选/NOI-
pid: P3680
tag: ['字符串', '数学', '计算几何', '2016', 'Special Judge', '凸包']
---
# [CERC2016] 凸轮廓线 Convex Contour
## 题目描述

一些几何图形整齐地在一个网格图上从左往右排成一列。它们占据了连续的一段横行，每个位置恰好一个几何图形。每个图形是以下的三种之一：


1. 一个恰好充满单个格子的正方形。


2. 一个内切于单个格子的圆。


3. 一个底边与格子重合的等边三角形。


 ![](https://cdn.luogu.com.cn/upload/pic/4685.png) 

已知每个格子的边长都为 $1$，请求出这些几何图形的凸包的周长。
## 输入格式

第一行包含一个正整数 $n$，表示几何图形的个数。

第二行包含 $n$ 个字符，从左往右依次表示每个图形，`S` 表示正方形，`C` 表示圆形，`T` 表示等边三角形。

## 输出格式

输出一行一个实数，即凸包的周长。与答案的绝对或相对误差不超过 $10^{-6}$ 时被认为是正确的。
## 样例

### 样例输入 #1
```
4
TSTC
```
### 样例输出 #1
```
9.088434417

```
## 提示

对于 $100\%$ 的数据，$1 \le n \le 20$。


---

---
title: "CYaRon!语"
layout: "post"
diff: 省选/NOI-
pid: P3695
tag: ['模拟', '字符串', '洛谷原创', 'O2优化', '洛谷月赛']
---
# CYaRon!语
## 题目背景

「千歌です」（我是千歌）、「曜です」（我是曜）、「ルビィです」（我是露比）、「3人合わせて、We are CYaRon！ よろしくね！」（三人在一起，我们是CYaRon！多多指教哦！）


CYaRon!的三人在学习了编程之后，决定发明一种自己的编程语言，她们称为CYaRon!语。



(ltt: 明明是我帮她们发明的。)

可是，因为洛谷评测机这时候突然爆了，ltt没有时间再帮CYaRon!的三位小姐姐写CYaRon!语的解释器了。


于是ltt就出了这样一道题，然后等着有人交了AC程序就偷走给小姐姐们。

## 题目描述

以下是一个典型的CYaRon! 语程序。


```cpp
{ vars
    chika:int
    you:int
    ruby:array[int, 1..2]
    i:int
}
# 以上变量默认值均为0
# 变量名只可是英文字母。

# yosoro语句可以输出一个数字，随后跟一个空格。
:yosoro 2
# 输出2和一个空格(以下不再提到空格)。

# set语句可以为变量赋值。
# 运算符只支持加减号即可。
:set chika, 1
:set you, 2
:yosoro chika + you
# 上一条语句将输出3

# 以下的判断语句均使用以下的格式：
# 操作符，表达式，表达式
# 例如eq, a, 1即C语言中 a==1
# 所有操作符包括: lt: < gt: > le: <= ge: >= eq: == neq: !=

# 日本来的CYaRon三人没法正确地发出if这个音，因此她们就改成了ihu。
{ ihu eq, chika, 1
    :set you, 3
    :yosoro 1
}
# 输出1
# 以上是ihu语句，无需支持else。

# hor语句同理，
# for i=1 to you如下
{ hor i, 1, you
    :yosoro i
}
# 输出1 2 3

# 如下是while和数组的使用方法。
:set i, 1
{ while le, i, 2
    :yosoro i
    :set ruby[i], i+1
    :yosoro ruby[i]
    :set i, i+1
}
# 输出1 2 2 3

# 数组不会出现嵌套，即只会有a[i]、a[i+2]而不会有类似于a[i+b[i]]这样的。

# CYaRon语的最后一行，一定是一个换行。
 
```

你的任务是写一个CYaRon!语的解释器，实现输入CYaRon!语的程序，解释之执行后输出执行结果。

## 输入格式

输入文件全部为CYaRon!语程序，最后一行保证是个空行。

请处理输入的时候，一直读到EOF为止。

## 输出格式

该CYaRon!语程序的执行结果。

具体上，是该CYaRon!语程序所有:yosoro语句的输出。

## 样例

### 样例输入 #1
```
{ vars
    a:int
    b:int
}

:set a, 1
:set b, 2
:yosoro a+b

```
### 样例输出 #1
```
3
```
## 提示

对数据做出以下保证：

1. 输入数据一定是合法的CYaRon!语程序，不包含注释，代码、缩进风格 （四个空格）与上述样例相同。**但不保证逗号、运算符前面的空格数量和有无一定相同**。

2. 变量名在10个字符以下，仅包含小写英文，数组最大大小为1000，变量最多50个，所有表达式的运算结果，包括变量的值一定在int范围内。 （但数组可能是类似于[2001..3000]的，下标可能范围为0到1亿）

3. 所有指令小写。

4. 该程序一定能够在合理的时间、内存限制内执行完毕。

5. hor语句执行过程中，循环变量、初始值、结束值不会被循环中的代码改变。

6. **该程序最多500行**

![](https://cdn.luogu.com.cn/upload/pic/4595.png)



---

---
title: "[BJOI2017] 魔法咒语"
layout: "post"
diff: 省选/NOI-
pid: P3715
tag: ['字符串', '2017', '各省省选', '矩阵加速', 'AC 自动机', '构造']
---
# [BJOI2017] 魔法咒语
## 题目描述

Chandra 是一个魔法天才。

从一岁时接受火之教会洗礼之后，Chandra 就显示出对火元素无与伦比的亲和力，轻而易举地学会种种晦涩难解的法术。这也多亏 Chandra 有着常人难以企及的语言天赋，让她能轻松流利地说出咒语中那些极其拗口的魔法词汇。

直到十四岁，开始学习威力强大的禁咒法术时，Chandra 才遇到了障碍。

根据火之魔法规则，禁咒的构成单位是 $N$ 个基本词汇。施法时只要凝聚精神力，说出一段用这些词语组成的长度恰好等于 $L$ 的语言，就能释放威力超乎想象的火法术。过去的魔法师们总结了几种表达起来最连贯的组合方式，方便施法者以最快语速完成法术。

但具有魔法和语言双重天才的 Chandra 不满足于这几种流传下来的禁咒，因为她可以毫无困难地说出普通人几乎不可能表达的禁咒语句。然而，在实际施法时，Chandra 发现有些自创禁咒念出后不但没有预期效果，反而会使自己的精神力迅速枯竭，十分难受。

这个问题令 Chandra 万分不解。她大量阅读典籍，到处走访魔法学者，并且不顾精神折磨一次又一次尝试新咒语，希望找出问题的答案。

很多年过去了，在一次远古遗迹探险中，Chandra 意外闯进了火之神艾利克斯的不知名神殿。根据岩土特征分析，神殿应该有上万年的历史，这是极其罕见的。Chandra 小心翼翼地四处探索，沿着魔力流动来到一间密室。她看见密室中央悬浮着一本书籍。在魔法保护下书籍状况完好。精通上古语言的 Chandra 读过此书，终于解开了多年的困惑。


禁咒法术之所以威力强大，是因为咒语借用了火之神艾利克斯的神力。这本书里记载了艾利克斯生平忌讳的 $M$ 个词语，比如情敌的名字、讨厌的植物等等。使用禁咒法术时，如果语言中含有任何忌讳词语，就会触怒神力而失效，施法者也一并遭受惩罚。

例如，若 `banana` 是唯一的忌讳词语，`an`、`ban`、`analysis` 是基本词汇，禁咒长度须是 $11$，则 `bananalysis` 是无效法术，`analysisban`、`anbanbanban` 是两个有效法术。注意：一个基本词汇在禁咒法术中可以出现零次、一次或多次；只要组成方式不同就认为是不同的禁咒法术，即使书写形式相同。

谜题破解，Chandra 心情大好。她决定计算一共有多少种有效的禁咒法术。

由于答案可能很大，你只需要输出答案模 $10 ^ 9 + 7$ 的结果。

## 输入格式

第一行，三个正整数 $N, M, L$。

接下来 $N$ 行，每行一个只含小写英文字母的字符串，表示一个基本词汇。

接下来 $M$ 行，每行一个只含小写英文字母的字符串，表示一个忌讳词语。

## 输出格式

仅一行，一个整数，表示答案（模 $10^9+7$）。

## 样例

### 样例输入 #1
```
4 2 10
boom
oo
ooh
bang
ob
mo
```
### 样例输出 #1
```
14
```
### 样例输入 #2
```
3 1 3
a
ab
aba
aaa
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
3 1 14
ban
an
analysis
banana
```
### 样例输出 #3
```
15
```
## 提示

【样例解释 1】

有效的禁咒法术共有 $14$ 种：`boom/bang/oo`，`oo/oo/oo/oo/oo`，`oo/oo/ooh/ooh`，`oo/ooh/oo/ooh`，`oo/ooh/ooh/oo`，`ooh/oo/oo/ooh`，`ooh/oo/ooh/oo`，`
ooh/ooh/boom`，`ooh/ooh/oo/oo`，`ooh/ooh/bang`，`ooh/bang/ooh`，`bang/oo/oo/oo`，`bang/ooh/ooh`，`bang/bang/oo`。

【样例解释 2】

有效的禁咒法术有 `a/ab`，`ab/a`，`aba` 共三种。注意，`ab/a` 和 `aba` 算成两种不同的禁咒法术。

【数据规模与约定】

本题一共有 $10$ 个测试点。

下表是每个测试点的数据规模和约定：

 ![](https://cdn.luogu.com.cn/upload/pic/5191.png) 

对于 $100\%$ 的数据，$1 \le N, M \le 50，1 \le L \le 10^8$，基本词汇的长度之和不超过 $100$，忌讳词语的长度之和不超过 $100$。保证基本词汇不重复，忌讳词语不重复。



---

---
title: "【模板】后缀自动机（SAM）"
layout: "post"
diff: 省选/NOI-
pid: P3804
tag: ['字符串', '后缀自动机 SAM', 'O2优化', '后缀数组 SA']
---
# 【模板】后缀自动机（SAM）
## 题目描述

给定一个只包含小写字母的字符串 $S$。

请你求出 $S$ 的所有出现次数不为 $1$ 的子串的出现次数乘上该子串长度的最大值。

## 输入格式

一行一个仅包含小写字母的字符串 $S$。
## 输出格式

一个整数，为所求答案。
## 样例

### 样例输入 #1
```
abab
```
### 样例输出 #1
```
4
```
## 提示

对于 $10 \%$ 的数据，$\lvert S \rvert \le 1000$。  
对于 $100\% $的数据，$1 \le \lvert S \rvert \le {10}^6$。

- 2023.7.30：添加一组 hack 数据。


---

---
title: "【模板】后缀排序"
layout: "post"
diff: 省选/NOI-
pid: P3809
tag: ['字符串', 'O2优化', '排序', '后缀数组 SA']
---
# 【模板】后缀排序
## 题目背景

这是一道模板题。

## 题目描述

读入一个长度为 $ n $ 的由大小写英文字母或数字组成的字符串，请把这个字符串的所有非空后缀按字典序（用 ASCII 数值比较）从小到大排序，然后按顺序输出后缀的第一个字符在原串中的位置。位置编号为 $ 1 $ 到 $ n $。

## 输入格式

一行一个长度为 $ n $ 的仅包含大小写英文字母或数字的字符串。

## 输出格式

一行，共 $n$ 个整数，表示答案。

## 样例

### 样例输入 #1
```
ababa
```
### 样例输出 #1
```
5 3 1 4 2
```
## 提示

$1\le n \le 10^6$。



---

---
title: "[FJOI2017] 树的平均路长问题"
layout: "post"
diff: 省选/NOI-
pid: P3816
tag: ['字符串', '动态规划 DP', '2017', '各省省选', '福建', '枚举']
---
# [FJOI2017] 树的平均路长问题
## 题目描述

一棵树 $T$ 的平均路长 $IPL(T)$定义为：

$IPL(T)=\sum_{v\varepsilon T}length(path(v))$

其中， $v$ 是树 $T$ 中的内结点， $length(path(v))$是从树根到结点$v$的路径长度。

红黑树是一类特殊的二叉搜索树，其中每个结点被“染成”红色或黑色。若将二叉搜索树结点中的空指针看作是指向一个空结点，则称这类空结点为二叉搜索树的前端结点。并规定所有前端结点的高度为$-1$。除了前端结点外，其他结点均为内结点。

一棵红黑树是满足下面“红黑性质”染色二叉搜索树：

1. 每个结点被染成红色或黑色；

2. 每个前端结点为黑色结点；

3. 任一红结点的儿子结点均为黑结点；

4. 在从任一结点到其子孙前端结点的所有路径上具有相同的黑结点数。

从红黑树中任一结点 $x$ 出发(不包括结点 $x$)，到达一个前端结点的任意一条路径上的黑结点个数称为结点 $x$ 的黑高度，记作 $bh(x)$。红黑树的黑高度定义为其根结点的黑高度。

给定正整数 $n$，试设计一个算法，计算出在所有含有 $n$ 个结点的红黑树中，平均路长的最大值。

## 输入格式

文件有多个测试项。每行有1个正整数$n$， ($1\le n\le 30000$)，表示红黑树的结点数。文件最后以一个$0$结束。

## 输出格式

对每行中红黑树的结点数 $n$，将计算出的平均路长的最大值输出到文件中。

每行输出一个最大值。 文件最后以一个$0$ 结束。

## 样例

### 样例输入 #1
```
1
2
3
0
```
### 样例输出 #1
```
1
3
5
0
```


---

---
title: "[NOI2017] 蚯蚓排队"
layout: "post"
diff: 省选/NOI-
pid: P3823
tag: ['字符串', '2017', 'NOI', 'O2优化', '哈希 hashing']
---
# [NOI2017] 蚯蚓排队
## 题目描述

蚯蚓幼儿园有 $n$ 只蚯蚓。幼儿园园长神刀手为了管理方便，时常让这些蚯蚓们列队表演。

所有蚯蚓用从 $1$ 到 $n$ 的连续正整数编号。每只蚯蚓的长度可以用一个正整数表示，根据入园要求，所有蚯蚓的长度都不超过 $6$ 。神刀手希望这些蚯蚓排成若干个队伍，初始时，每只蚯蚓各自排成一个仅有一只蚯蚓的队伍，该蚯蚓既在队首，也在队尾。

神刀手将会依次进行 $m$ 次操作，每个操作都是以下三种操作中的一种：

1. 给出 $i$ 和 $j$ ，令 $i$ 号蚯蚓与 $j$ 号蚯蚓所在的两个队伍合并为一个队伍，具体来说，令 $j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后，其余蚯蚓保持队伍的前后关系不变。

2. 给出 $i$ ，令 $i$ 号蚯蚓与紧挨其后的一只蚯蚓分离为两个队伍，具体来说，在分离之后， $i$ 号蚯蚓在其中一个队伍的队尾，原本紧挨其后的那一只蚯蚓在另一个队伍的队首，其余蚯蚓保持队伍的前后关系不变。

3. 给出一个正整数 $k$ 和一个长度至少为 $k$ 的数字串 $s$ ，对于 $s$ 的每个长度为 $k$ 的连续子串 $t$ （这样的子串共有 $|s|-k+1$ 个，其中 $|s|$ 为 $s$ 的长度），定义函数 $f(t)$，询问所有这些 $f(t)$ 的**乘积**对 $998244353$ 取模后的结果。其中 $f(t)$ 的定义如下：

对于当前的蚯蚓队伍，定义某个蚯蚓的**向后 $k$ 数字串**为：从该蚯蚓出发，沿队伍的向后方向，寻找最近的 $k$ 只蚯蚓（包括其自身），将这些蚯蚓的长度视作字符连接而成的数字串；如果这样找到的蚯蚓不足 $k$ 只，则其没有**向后$k$数字串**。例如蚯蚓的队伍为 $10$ 号蚯蚓在队首，其后是 $22$ 号蚯蚓，其后是 $3$ 号蚯蚓（为队尾），这些蚯蚓的长度分别为 $4$ 、 $5$ 、 $6$ ，则 $10$ 号蚯蚓的**向后 $3$ 数字串**为 `456`， $22$ 号蚯蚓没有**向后 $3$ 数字串**，但其**向后 $2$ 数字串**为 `56`，其**向后 $1$ 数字串**为 `5`。

而 $f(t)$ 表示所有蚯蚓中，**向后 $k$ 数字串**恰好为 $t$ 的蚯蚓只数。
## 输入格式

输入文件的第一行有两个正整数 $n,m$ ，分别表示蚯蚓的只数与操作次数。

第二行包含 $n$ 个不超过 $6$ 的正整数，依次表示编号为 $1,2,\dots,n$ 的蚯蚓的长度。

接下来 $m$ 行，每行表示一个操作。每个操作的格式可以为：

* `1` $i$ $j$（$1 \leq i, j \leq n$）表示：令 $i$ 号与 $j$ 号蚯蚓**所在**的两个队伍合并为一个队伍，新队伍中， $j$ 号蚯蚓紧挨在 $i$ 号蚯蚓之后。保证在此操作之前， $i$ 号蚯蚓在某个队伍的队尾，$j$ 号蚯蚓在某个队伍的队首，且两只蚯蚓不在同一个队伍中。

* `2` $i$（$1 \leq i \leq n$）表示：令 $i$ 号蚯蚓与紧挨其后一个蚯蚓分离为两个队伍。保证在此操作之前， $i$ 号蚯蚓不是某个队伍的队尾。

* `3` $s$ $k$（$k$为正整数，$s$为一个长度至少为$k$的数字串）表示：询问 $s$ 的每个长度为 $k$ 的子串 $t$ 的 $f(t)$ 的乘积，对 998244353 取模的结果。 $f(t)$ 的定义见题目描述。

同一行输入的相邻两个元素之间，用恰好一个空格隔开。

输入文件可能较大，请不要使用过于缓慢的读入方式。
## 输出格式

依次对于每个形如 `3 s k` 的操作，输出一行，仅包含一个整数，表示询问的结果。
## 样例

### 样例输入 #1
```
5 9
3 1 3 5 3
3 333135 2
3 333135 1
1 1 3
1 2 5
1 3 2
1 5 4
3 333135 2
3 333135 1
3 333135 3
```
### 样例输出 #1
```
0
81
1
81
0
```
### 样例输入 #2
```
2 10
6 6
3 666666 1
1 1 2
3 666666 2
3 666666 4
3 666666666666666666666666666666 1
2 1
1 2 1
3 666666 2
3 666666 4
3 666666666666666666666666666666 1
```
### 样例输出 #2
```
64
1
0
75497471
1
0
75497471
```
## 提示

保证 $n \leq 2 \times 10^{5}$，$m \leq 5 \times 10^{5}$，$k \leq 50$ 。

设 $\sum |s|$ 为某个输入文件中所有询问的 $s$ 的长度总和，则 $\sum |s| \leq 10^{7}$  。

设 $c$ 为某个输入文件中形如 `2 i` 的操作的次数，则 $c \leq 10^{3}$ 。

每个测试点的详细信息见下表：

| 测试点编号 | $n$ | $m$ | $k$ | $\sum \|s\|$ | $c$ | 全为 $\texttt{1}$ |
|:-:|:-:|:-:|:-:|:-:|:-:|:-:|
| 1 | $=1$ | $\leq 10^{3}$ | $=1$ | $\leq 10^{3}$ | $=0$ | No |
| 2 | $\leq 20$ | $\leq 40$ | $\leq 10$ | $\leq 10^{3}$ | $=0$ | No |
| 3 | $\leq 150$ | $\leq 2,000$ | $\leq 50$ | $\leq 10^{3}$ | $\leq 10^{3}$ | No |
| 4 | $\leq 500$ | $\leq 600$ | $\leq 50$ | $\leq 10^{3}$ | $=0$ | No |
| 5 | $\leq 10^{3}$ | $\leq 2,000$ | $\leq 50$ | $\leq 10^{3}$ | $\leq 10^{3}$ | No |
| 6 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 5$ | $\leq 5 \times 10^{4}$ | $\leq 10^{3}$ | No |
| 7 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $=0$ | Yes |
| 8 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $=0$ | No |
| 9 | $\leq 5 \times 10^{4}$ | $\leq 6 \times 10^{4}$ | $\leq 50$ | $\leq 5 \times 10^{4}$ | $\leq 10^{3}$ | No |
| 10 | $\leq 5 \times 10^{4}$ | $\leq 8 \times 10^{4}$ | $\leq 50$ | $\leq 2.5 \times 10^{6}$ | $=0$ | No |
| 11 | $\leq 5 \times 10^{4}$ | $\leq 8 \times 10^{4}$ | $\leq 50$ | $\leq 2.5 \times 10^{6}$ | $\leq 10^{3}$ | No |
| 12 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 6$ | $\leq 10^{5}$ | $\leq 10^{3}$ | No |
| 13 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $=0$ | Yes |
| 14 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $=0$ | No |
| 15 | $\leq 10^{5}$ | $\leq 1.1 \times 10^{5}$ | $\leq 50$ | $\leq 10^{5}$ | $\leq 10^{3}$ | No |
| 16 | $\leq 10^{5}$ | $\leq 1.5 \times 10^{5}$ | $\leq 50$ | $\leq 5 \times 10^{6}$ | $=0$ | No |
| 17 | $\leq 10^{5}$ | $\leq 1.5 \times 10^{5}$ | $\leq 50$ | $\leq 5 \times 10^{6}$ | $\leq 10^{3}$ | No |
| 18 | $\leq 2 \times 10^{5}$ | $\leq 5 \times 10^{5}$ | $=1$ | $\leq 10^{7}$ | $=0$ | No |
| 19 | $\leq 2 \times 10^{5}$ | $\leq 5 \times 10^{5}$ | $=1$ | $\leq 10^{7}$ | $\leq 10^{3}$ | No |
| 20 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 7$ | $\leq 2 \times 10^{5}$ | $\leq 10^{3}$ | No |
| 21 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $=0$ | Yes |
| 22 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $=0$ | No |
| 23 | $\leq 2 \times 10^{5}$ | $\leq 2.5 \times 10^{5}$ | $\leq 50$ | $\leq 2 \times 10^{5}$ | $\leq 10^{3}$ | No |
| 24 | $\leq 2 \times 10^{5}$ | $\leq 3 \times 10^{5}$ | $\leq 50$ | $\leq 10^{7}$ | $=0$ | No |
| 25 | $\leq 2 \times 10^{5}$ | $\leq 3 \times 10^{5}$ | $\leq 50$ | $\leq 10^{7}$ | $\leq 10^{3}$ | No |

如果一个测试点的“全为`1`”的一列为“Yes”，表示该测试点的所有蚯蚓的长度均为 1，并且所有询问串 $s$ 的每一位也均为`1`。


---

---
title: "斐波那契数列"
layout: "post"
diff: 省选/NOI-
pid: P4000
tag: ['字符串', '数学', 'O2优化', '素数判断,质数,筛法', '斐波那契数列']
---
# 斐波那契数列
## 题目描述

大家都知道，斐波那契数列是满足如下性质的一个数列：

• $f_1 = 1$

• $f_2 = 1$

• $f_n = f_{n-1} + f_{n-2}$ ($n \geq 2$ 且 $n$ 为整数)

请你求出 $f_n \mod p$ 的值。

## 输入格式

- 第 1 行：一个整数 $n$。

- 第 2 行：一个整数 $p$。

## 输出格式

- 第 1 行：$f_n \mod p$ 的值。

## 样例

### 样例输入 #1
```
5
1000000007
```
### 样例输出 #1
```
5
```
### 样例输入 #2
```
10
1000000007
```
### 样例输出 #2
```
55
```
## 提示

对于 $100\%$ 的数据，$n \leq 10^{30000000}, p<2^{31}$



---

---
title: "[NOI2003] 文本编辑器"
layout: "post"
diff: 省选/NOI-
pid: P4008
tag: ['字符串', '2003', '平衡树', '递归', 'NOI', '分块']
---
# [NOI2003] 文本编辑器
## 题目描述

很久很久以前，$DOS3.x$ 的程序员们开始对 $EDLIN$ 感到厌倦。于是，人们开始纷纷改用自己写的文本编辑器⋯⋯

多年之后，出于偶然的机会，小明找到了当时的一个编辑软件。进行了一些简单的测试后，小明惊奇地发现：那个软件每秒能够进行上万次编辑操作（当然，你不能手工进行这样的测试） ！于是，小明废寝忘食地想做一个同样的东西出来。你能帮助他吗？

为了明确目标，小明对“文本编辑器”做了一个抽象的定义:

文本：由 $0$ 个或多个 ASCII 码在闭区间 [$32$, $126$] 内的字符构成的序列。

光标：在一段文本中用于指示位置的标记，可以位于文本首部，文本尾部或文本的某两个字符之间。


文本编辑器：由一段文本和该文本中的一个光标组成的，支持如下操作的数据结构。如果这段文本为空，我们就说这个文本编辑器是空的。

| 操作名称  | 输入文件中的格式  | 功能  |
| :------------ | :------------ | :------------ |
| $\text{Move}(k)$  | Move k  |  将光标移动到第 $k$ 个字符之后，如果 $k=0$，将光标移到文本开头 |
| $\text{Insert}(n,s)$  | Insert n s  | 在光标处插入长度为 $n$ 的字符串 $s$，光标位置不变$n\geq1$|
| $\text{Delete}(n)$  | Delete n  | 删除光标后的 $n$ 个字符，光标位置不变，$n \geq 1$  |
| $\text{Get}(n)$  | Get n  |输出光标后的 $n$ 个字符，光标位置不变，$n \geq 1$   |
| $\text{Prev}()$  | Prev  | 光标前移一个字符  |
| $\text{Next}()$  | Next |  光标后移一个字符 |


你的任务是：

- 建立一个空的文本编辑器。

- 从输入文件中读入一些操作并执行。

- 对所有执行过的 `GET` 操作，将指定的内容写入输出文件。

## 输入格式

输入文件 `editor.in` 的第一行是指令条数 $t$，以下是需要执行的 $t$ 个操作。其中：

为了使输入文件便于阅读， `Insert` 操作的字符串中可能会插入一些回车符， 请忽略掉它们（如果难以理解这句话，可以参照样例） 。

除了回车符之外，输入文件的所有字符的 ASCII 码都在闭区间 [$32$, $126$] 内。且

行尾没有空格。

这里我们有如下假定：

-  `MOVE` 操作不超过 $50000$ 个， `INSERT` 和 `DELETE` 操作的总个数不超过 $4000$，`PREV` 和 `NEXT` 操作的总个数不超过 $200000$。

-  所有 `INSERT` 插入的字符数之和不超过 $2M$（$1M=1024\times 1024$ 字节） ，正确的输出文件长度不超过 $3M$ 字节。

-  `DELETE` 操作和 `GET` 操作执行时光标后必然有足够的字符。 `MOVE` 、 `PREV` 、 `NEXT` 操作必然不会试图把光标移动到非法位置。

-  输入文件没有错误。

对 C++ 选手的提示：经测试，最大的测试数据使用 `fstream` 进行输入有可能会比使用 `stdio` 慢约 $1$ 秒。
## 输出格式

输出文件 editor.out 的每行依次对应输入文件中每条 `Get` 指令的输出。

## 样例

### 样例输入 #1
```
15
Insert 26
abcdefghijklmnop
qrstuv wxy
Move 15
Delete 11
Move 5
Insert 1
^
Next
Insert 1
_
Next
Next
Insert 4
.\/.
Get 4
Prev
Insert 1
^
Move 0
Get 22


```
### 样例输出 #1
```
.\/.
abcde^_^f.\/.ghijklmno

```


---

---
title: "[JSOI2008] 火星人"
layout: "post"
diff: 省选/NOI-
pid: P4036
tag: ['字符串', '2008', '各省省选', '平衡树', '江苏', '哈希 hashing']
---
# [JSOI2008] 火星人
## 题目描述

火星人最近研究了一种操作：求一个字串两个后缀的公共前缀。

比方说，有这样一个字符串：madamimadam，我们将这个字符串的各个字符予以标号：
```
序号 1 2 3 4 5 6 7 8 9 10 11 
字符 m a d a m i m a d a m
```
现在，火星人定义了一个函数 $LCQ(x, y)$，表示：该字符串中第 $x$ 个字符开始的字串，与该字符串中第 $y$ 个字符开始的字串，两个字串的公共前缀的长度。比方说，$LCQ(1, 7) = 5, LCQ(2, 10) = 1, LCQ(4, 7) = 0$

在研究 $LCQ$ 函数的过程中，火星人发现了这样的一个关联：如果把该字符串的所有后缀排好序，就可以很快地求出 $LCQ$ 函数的值；同样，如果求出了 $LCQ$ 函数的值，也可以很快地将该字符串的后缀排好序。

尽管火星人聪明地找到了求取 $LCQ$ 函数的快速算法，但不甘心认输的地球人又给火星人出了个难题：在求取 $LCQ$ 函数的同时，还可以改变字符串本身。具体地说，可以更改字符串中某一个字符的值，也可以在字符串中的某一个位置插入一个字符。地球人想考验一下，在如此复杂的问题中，火星人是否还能够做到很快地求取 $LCQ$ 函数的值。
## 输入格式

第一行给出初始的字符串。第二行是一个非负整数 $M$ ，表示操作的个数。接下来的M行，每行描述一个操作。操作有 $3$ 种，如下所示

1. 询问。语法：$Q$ $x$ $y$ ，$x$ ,$y$ 均为正整数。功能：计算 $LCQ(x,y)$ 限制：$1$ $\leq$ $x$ , $y$ $\leq$ 当前字符串长度 。
2. 修改。语法：$R$ $x$ $d$，$x$ 是正整数，$d$ 是字符。功能：将字符串中第 $x$ 个数修改为字符 $d$ 。限制：$x$ 不超过当前字符串长度。
3. 插入：语法：$I$ $x$ $d$ ，$x$ 是非负整数，$d$ 是字符。功能：在字符串第 $x$ 个字符之后插入字符 $d$ ，如果 $x=0$，则在字符串开头插入。限制：$x$ 不超过当前字符串长度
## 输出格式

对于输入文件中每一个询问操作，你都应该输出对应的答案。一个答案一行。
## 样例

### 样例输入 #1
```
madamimadam
7
Q 1 7
Q 4 8
Q 10 11
R 3 a
Q 1 7
I 10 a
Q 2 11
```
### 样例输出 #1
```
5
1
0
2
1
```
## 提示

1. 所有字符串自始至终都只有小写字母构成。
2. $M\leq150,000$
3. 字符串长度L自始至终都满足$L\leq100,000$
4. 询问操作的个数不超过 $10,000$ 个。

对于第 $1$，$2$ 个数据，字符串长度自始至终都不超过 $1,000$
对于第 $3$，$4$，$5$ 个数据，没有插入操作。

2024/07/40 更新一组 hack。


---

---
title: "[JSOI2009] 密码"
layout: "post"
diff: 省选/NOI-
pid: P4045
tag: ['字符串', '2009', '各省省选', '江苏', 'AC 自动机', '状压 DP']
---
# [JSOI2009] 密码
## 题目描述

众所周知，密码在信息领域起到了不可估量的作用。对于普通的登陆口令以，唯一的破解方法就是暴力破解——逐个尝试所有可能的字母组合，但这是一项很耗时又容易被发现的工作。所以，为了获取对方的登陆口令，在暴力破解密码之前，必须先做大量的准备工作。经过情报的搜集，现在得到了若干有用信息，形如：

> ​     “我观察到，密码中含有字符串*。”

例如，对于一个 $10$ 位的密码以及观察到的字符串 `hello` 与 `world`，可能的密码组合为 `helloworld`与 `worldhello`；而对于 $6$ 位的密码以及到的字符串 `good` 与 `day`,可能的密码组合为 `gooday`。

有了这些信息，就能够大大地减少尝试的次数了。请编一个程序，计算所有密码组合的可能。密码中仅可能包含 `a-z` 之间的小写字母。
## 输入格式

输入数据首先输入两个整数 $L,N$，分别表示密码的长度与观察到子串的个数。

接下来 $N$ 行，每行若干个字符，描述了每个观察到的字符串。

## 输出格式

输出数据第一行为一个整数，代表了满足所有观察条件字符串的总数。

若这个数字小于等于 $42$，则按字典顺序输出所有密码的可能情况，每行一个，否则，只输出满足所有观察条件字符串的总数即可。

## 样例

### 样例输入 #1
```
10 2
hello
world
```
### 样例输出 #1
```
2
helloworld
worldhello
```
## 提示

对于 $100\%$ 的数据，$1\leq L\leq 25,1\leq N\leq 10$，每个观察到的字符串长不超过 $10$，并且保证输出结果小于 $2^{63}$。



---

---
title: "[JSOI2007] 字符加密"
layout: "post"
diff: 省选/NOI-
pid: P4051
tag: ['字符串', '2007', '各省省选', '江苏', '后缀数组 SA']
---
# [JSOI2007] 字符加密
## 题目描述

喜欢钻研问题的JS 同学，最近又迷上了对加密方法的思考。一天，他突然想出了一种他认为是终极的加密办法：把需要加密的信息排成一圈，显然，它们有很多种不同的读法。

例如‘JSOI07’，可以读作：  JSOI07 SOI07J OI07JS I07JSO 07JSOI 7JSOI0 把它们按照字符串的大小排序： 07JSOI 7JSOI0 I07JSO JSOI07 OI07JS SOI07J 读出最后一列字符：I0O7SJ，就是加密后的字符串（其实这个加密手段实在很容易破解，鉴于这是突然想出来的，那就^^）。 但是，如果想加密的字符串实在太长，你能写一个程序完成这个任务吗？

## 输入格式

输入文件包含一行，欲加密的字符串。注意字符串的内容不一定是字母、数字，也可以是符号等。

## 输出格式

输出一行，为加密后的字符串。

## 样例

### 样例输入 #1
```
JSOI07
```
### 样例输出 #1
```
I0O7SJ
```
## 提示

对于40%的数据字符串的长度不超过10000。

对于100%的数据字符串的长度不超过100000。



---

---
title: "[SDOI2016] 生成魔咒"
layout: "post"
diff: 省选/NOI-
pid: P4070
tag: ['字符串', '2016', '各省省选', '平衡树', '山东', '后缀自动机 SAM', '后缀数组 SA']
---
# [SDOI2016] 生成魔咒
## 题目描述

魔咒串由许多魔咒字符组成，魔咒字符可以用数字表示。例如可以将魔咒字符 $1,2$ 拼凑起来形成一个魔咒串 $[1,2]$。

一个魔咒串 $S$ 的非空字串被称为魔咒串 $S$ 的生成魔咒。

例如 $S=[1,2,1]$ 时，它的生成魔咒有 $[1],[2],[1,2],[2,1],[1,2,1]$ 五种。$S=[1,1,1]$ 时，它的生成魔咒有 $[1],[1,1],[1,1,1]$ 三种，最初 S 为空串。  

共进行 $n$ 次操作，每次操作是在 $S$ 的结尾加入一个魔咒字符。每次操作后都需要求出，当前的魔咒串 $S$ 共有多少种生成魔咒。

## 输入格式

第一行一个整数 $n$。

第二行 $n$ 个数，第 $i$ 个数表示第 $i$ 次操作加入的魔咒字符 $x_i$。

## 输出格式

输出 $n$ 行，每行一个数。  
第 $i$ 行的数表示第 $i$ 次操作后 $S$ 的生成魔咒数量。

## 样例

### 样例输入 #1
```
7
1 2 3 3 3 1 2
```
### 样例输出 #1
```
1
3
6
9
12
17
22
```
## 提示

#### 数据规模与约定   
对于 $10\%$ 的数据，保证 $1 \le n \le 10$；  
对于 $30\%$ 的数据，保证 $1 \le n \le 100$；  
对于 $60\%$ 的数据，保证 $1 \le n \le 10^3$；   
对于 $100\%$ 的数据，保证 $1 \le n \le 10^5$，$1 \leq x_i \leq 10^9$。



---

---
title: "[USACO17DEC] Standing Out from the Herd P"
layout: "post"
diff: 省选/NOI-
pid: P4081
tag: ['字符串', '2017', 'USACO', '后缀自动机 SAM', '后缀数组 SA']
---
# [USACO17DEC] Standing Out from the Herd P
## 题目描述

Just like humans, cows often appreciate feeling they are unique in some way. Since Farmer John's cows all come from the same breed and look quite similar, they want to measure uniqueness in their names.

Each cow's name has some number of substrings. For example, "amy" has substrings {a, m, y, am, my, amy}, and "tommy" would have the following substrings: {t, o, m, y, to, om, mm, my, tom, omm, mmy, tomm, ommy, tommy}.

A cow name has a "uniqueness factor" which is the number of substrings of that name not shared with any other cow. For example, If amy was in a herd by herself, her uniqueness factor would be 6. If tommy was in a herd by himself, his uniqueness factor would be 14. If they were in a herd together, however, amy's uniqueness factor would be 3 and tommy's would be 11.

Given a herd of cows, please determine each cow's uniqueness factor.
## 输入格式

The first line of input will contain $N$ ($1 \le N \le 10^5$). The following $N$ lines will each contain the name of a cow in the herd. Each name will contain only lowercase characters a-z. The total length of all names will not exceed $10^5$.

## 输出格式

Output $N$ numbers, one per line, describing the uniqueness factor of each cow.

## 样例

### 样例输入 #1
```
3
amy
tommy
bessie
```
### 样例输出 #1
```
3
11
19
```
## 题目翻译

### 题目描述

就像人类一样，奶牛也常常希望在某些方面感到自己与众不同。由于 Farmer John 的奶牛都来自同一品种且外观非常相似，它们希望通过名字来衡量独特性。

每头奶牛的名字都有一些子字符串。例如，"amy" 的子字符串为 {a, m, y, am, my, amy}，而 "tommy" 的子字符串为 {t, o, m, y, to, om, mm, my, tom, omm, mmy, tomm, ommy, tommy}。

一头奶牛的名字有一个“独特性因子”，即该名字中不与任何其他奶牛共享的子字符串的数量。例如，如果 amy 独自在一个牛群中，她的独特性因子为 6。如果 tommy 独自在一个牛群中，他的独特性因子为 14。然而，如果它们在一个牛群中，amy 的独特性因子为 3，而 tommy 的独特性因子为 11。

给定一个牛群，请计算每头奶牛的独特性因子。

### 输入格式

输入的第一行包含 $N$（$1 \le N \le 10^5$）。接下来的 $N$ 行每行包含牛群中一头奶牛的名字。每个名字仅包含小写字母 a-z。所有名字的总长度不超过 $10^5$。

### 输出格式

输出 $N$ 个数字，每行一个，表示每头奶牛的独特性因子。


---

---
title: "残缺的字符串"
layout: "post"
diff: 省选/NOI-
pid: P4173
tag: ['字符串', '数学', 'KMP 算法', '快速傅里叶变换 FFT']
---
# 残缺的字符串
## 题目描述

很久很久以前，在你刚刚学习字符串匹配的时候，有两个仅包含小写字母的字符串 $A$ 和 $B$，其中 $A$ 串长度为 $m$，$B$ 串长度为 $n$。可当你现在再次碰到这两个串时，这两个串已经老化了，每个串都有不同程度的残缺。

你想对这两个串重新进行匹配，其中 $A$ 为模板串，那么现在问题来了，请回答，对于 $B$ 的每一个位置 $i$，从这个位置开始连续 $m$ 个字符形成的子串是否可能与 $A$ 串完全匹配？
## 输入格式

第一行包含两个正整数 $m,n$，分别表示 $A$ 串和 $B$ 串的长度。

第二行为一个长度为 $m$ 的字符串 $A$。

第三行为一个长度为 $n$ 的字符串 $B$。

两个串均仅由小写字母和 $\texttt *$ 组成，其中 $\texttt *$ 表示相应位置已经残缺。
## 输出格式

第一行包含一个整数 $k$，表示 $B$ 串中可以完全匹配 $A$ 串的位置个数。

若 $k>0$，则第二行输出 $k$ 个正整数，从小到大依次输出每个可以匹配的开头位置（下标从 $1$ 开始）。
## 样例

### 样例输入 #1
```
3 7
a*b
aebr*ob
```
### 样例输出 #1
```
2
1 5
```
## 提示

$100\%$ 的数据满足 $1 \le m \le n \le 3 \times 10^5$。


---

---
title: "万径人踪灭"
layout: "post"
diff: 省选/NOI-
pid: P4199
tag: ['字符串', '枚举', '快速傅里叶变换 FFT']
---
# 万径人踪灭
## 题目背景

保先生是个好司机，总是开车带学生们上山玩。但是保先生去年开了最后一趟车后，由于一些奇奇怪怪的原因转行了。半年间，再也没有从这条路上山的人了。

当 VFleaKing 再次来到这座山玩的时候，发现已经没有往日的来来往往的游人了。算了，过去保先生还在的时候，来山上玩的人，也不全是来欣赏山上的风景的。
## 题目描述

如果机房马上要关门了，或者你急着要走，请直接跳到第六个自然段。

VFleaKing 注意到了这条上山下山的土路，有些地方能欣赏到美景，有些地方则不能。把上山的道路每 $10$ cm 分为一小段，则对于每一小段，用 `a` 表示能欣赏到美景，用 `b` 表示不能欣赏到美景，就能得到一个只含 `a`、`b` 的字符串 $s$。当然由于下山和上山是一条路，所以下山的道路的字符串就是将上山的道路的字符串反过来。

设上山字符串长度为 $n$，每个字符依次为 $s_1, s_2 .…, s_n$。在上山和下山的路上，VFleaKing 会选择某些小段查看旁边的景色，其他时间低头走路。即 VFleaKing 会选择 $k$ 个小段 $x_1, x_2 …x_k$，且 $k >0$，$1\le x_1<x_2<…<x_k\le n$，VFleaKing 上山和下山的过程中会在这些地方查看景色。

![](https://cdn.luogu.com.cn/upload/image_hosting/t9qpo3f9.png)

VFleaKing 希望，上山下山时看到的美景的情况相同。也就是说，VFleaKing 上山时是否看到了美景的情况是： $s_{x_1},s_{x_2},\cdots,s_{x_k}$ 记为字符序列 $T_1$，下山时是否看到了美景的情况是：$s_{x_k},s_{x_{k-1}},\cdots,s_{x_1}$ 记为字符序列 $T_2$。VFleaKing 希望 $T_1=T_2$。

VFleaKing 还希望，上山下山时查看景色的间隔相等。也就是说，上山时查看景色的间隔为：$x_2-x_1,x_3-x_2,x_k-x_{k-1}$，记为数列 $P_1$。下山时查看景色的间隔为：$x_k-x_{k-1},x_{k-1}-x_{k-2},…,x_2-x_1$，记为数列 $P_2$。VFleaKing 希望 $P_1=P_2$。

VFleaKing 觉得，如果第一次查看景色和最后一次查看景色这段时间里，没有一次低头看路他就会摔倒。也就是说，如果对于所有 $1\le i\le k$ 都有$x_i=x_1+i- 1$，VFleaKing 就会摔倒，VFleaKing不希望发生这样的情况。

就是要在一个只含 `a`、`b` 的字符串中选取一个子序列，使得:

1. 位置和字符都关于某条对称轴对称。
2. 不能是连续的一段。

以 $s = \texttt{"abaaaaabbabbabaa"}$ 为例。如果我们用符号 $[a_1, a_2,…,a_k]$ 表示一个序列，那么 $[1,4]$ 就是一个合法的序列 $x$，$[5,8,10,12,15]$ 也是，$[4,5,8,9,10,11,12,15,16]$ 也是。但是 $[1,2]$ 不满足 VFleaKing 第一个希望和第三个希望，所以不是。$[1,2,4]$ 不满足第二个希望，所以不是。$[9,10,11]$ 不满足第三个希望，所以不是。

![](https://cdn.luogu.com.cn/upload/image_hosting/6849dqla.png)

给你字符串 $s$，现在 VFleaKing 想知道，有多少个合法的 $x$。答案可能很大，VFleaKing 想知道对 $1000000007$ 取模的值。
## 输入格式

一行，一个只包含 `a`、`b` 的两种字符的字符串。
## 输出格式

一行，一个非负整数表示问题的答案。
## 样例

### 样例输入 #1
```
abaabaa
```
### 样例输出 #1
```
14
```
### 样例输入 #2
```
aaabbbaaa
```
### 样例输出 #2
```
44
```
### 样例输入 #3
```
aaaaaaaa
```
### 样例输出 #3
```
53
```
## 提示

## 样例解释

### 样例解释 1

$14$ 个方案分别是：

- $[1,3]$，$[1,4]$，$[2,5]$，$[1,6]$，$[3,6]$，$[4,6]$，$[1,7]$，$[3,7]$，$[4,7]$；
- $[1,4,7]$，$[3,5,7]$；
- $[1,3,4,6]$，$[1,2,5,6]$，$[3,4,6,7]$。

### 样例解释 2

我已经想到了一个绝妙的解释，可惜方案太多，写不下了。

### 样例解释 3

我已经想到了一个绝妙的解释，可惜方案太多，写不下了。

## 数据范围

- 其中 $10\%$ 的数据，字符串仅包含字母 `a` 或字母 `b`。
- 另有 $20\%$ 的数据，$n\le 1000$。
- 另有 $20\%$ 的数据，要么 `a` 的个数不超过 $10$，要么 `a` 的个数不超过 $10$。
- 另有 $10\%$ 的数据，$n\le 10000$。
- 对于 $100\%$ 的数据，$n \le 100000$。

## 来源

- 2013 湖北互测 week1
- bzoj 3160
- 信息学奥赛之数学一本通
- stong9070 整理




---

---
title: "Hash?"
layout: "post"
diff: 省选/NOI-
pid: P4235
tag: ['字符串', '哈希 hashing', '概率论']
---
# Hash?
## 题目背景

**zhoutb2333**学习了哈希算法，他于是去统计给定一些字符串，其中有多少个本质不同的字符串。


但是**zhoutb2333**突发奇想，如果哈希采用的$base$每次随机，那么结果会变成什么样呢？

**辣鸡出题人又出锅了！subtask3的数据有问题，现在统一将模数改为65537**

题目来源：[zhoutb2333](https://www.luogu.org/space/show?uid=31564)
## 题目描述

他通过某种办法，获得了一个函数:$int \ Rand(int  \ x)$，它会等概率地返回一个$[0,x)$中的整数。

他写下了这样的代码：
``` cpp
#include<bits/stdc++.h>
using namespace std;

typedef long long ll;
const int x=10,maxn=35,maxlen=16010;
ll HASH[maxn];
const ll p=65537;
char str[maxlen];
ll Hash(){
    int base=Rand(x);
    ll ret=0;
    for(int i=1;str[i];i++)
        ret=(ret*base+str[i]-'a'+1)%p;
    return ret;
}
int main(){
    int ans=0,n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%s",str+1),HASH[i]=Hash();
    sort(HASH+1,HASH+n+1);
    HASH[0]=-1;
    for(int i=1;i<=n;i++)
        ans+=(HASH[i]!=HASH[i-1]);
    printf("%d\n",ans);
    return 0;
}
```
**zhoutb2333**想问你，给定一些字符串和参数$x$，答案$ans$的期望是多少呢？

$65537= 2^{16}+1$**是质数**

**参数$x$在这个程序中是确定的$10$，但是每次输入会给定。**
## 输入格式

第一行三个整数$x,N$，表示$base$生成的参数和字符串的个数

接下来$N$行每行一个字符串，字符串仅由小写字母组成。
## 输出格式

一行一个小数，表示答案$ans$的期望，**模$65537$输出**。

即：如果你的答案为$\frac{q}{p}$（$gcd(p,q)=1$），那么输出使得$px \equiv q \ (mod \ 65537$的最小正整数$x$。可以证明答案$ans$一定为正有理数，并且这样的$x$一定存在。
## 样例

### 样例输入 #1
```
2 2
aa
aa
```
### 样例输出 #1
```
32770

```
### 样例输入 #2
```
3 6
i
dont
know
what
to
say
```
### 样例输出 #2
```
58261

```
## 提示

本题由$3$个$subtask$组成，设$M$为这$N$个字符串中，每个字符串长度的最大值。

对于$subtask \ 1$：$1 \le N \le 8 , M \le 10,x \le 4$，分值为$20$，时间限制为$1s$。

对于$subtask \ 2$：$1 \le N \le 30 , M \le 500,x \le 500$，分值为$50$，时间限制为$1s$。

对于$subtask \ 3$：$1 \le N \le 5 , M \le 16000,x \le 16000$，分值为$30$，时间限制为$4.5s$。

**样例#1解释：**

参数$x=2$，那么可能的哈希$base$为$0,1$。

如果哈希第一个`aa`采用的$base$和第二个`aa`的$base$相同，那么答案为$1$。

如果两个$base$不相同，那么答案为$2$。

分析发现这两种情况发生的概率相同，都是$\frac{1}{2}$，那么答案$ans$的期望为$1 * \frac{1}{2} + 2 * \frac{1}{2}=\frac{3}{2}$。使得$2x \equiv 3 \ (mod \ 65537)$的最小正整数$x$为$32770$。

**样例#2解释：**

求得答案为$\frac{53}{9}$。使得$9x \equiv 53 \ (mod \ 65537)$的最小正整数$x$为$58261$。

**注意：本题允许手动开$O2$优化以避免被卡常数，方法如下：**
``` cpp
%:pragma GCC optimize(2)
/*程序*/
```


---

---
title: "[SHOI2011] 双倍回文"
layout: "post"
diff: 省选/NOI-
pid: P4287
tag: ['字符串', '2011', '各省省选', '上海', '回文自动机 PAM', 'Manacher 算法']
---
# [SHOI2011] 双倍回文
## 题目描述

记字符串 $w$ 的倒置为 $w^{\mathsf R}$。例如$\tt (abcd)^{\mathsf R}=dcba$，$\tt (abba)^{\mathsf R}=abba$。

对字符串 $x$，如果 $x$ 满足 $x^{\mathsf R}=x$，则称之为回文。例如 $\tt abba$ 是一个回文，而 $\tt abed$ 不是。

如果 $x$ 能够写成 $ww^{\mathsf R} ww^{\mathsf R}$ 形式，则称它是一个“双倍回文”。换句话说，若要 $x$ 是双倍回文，它的长度必须是 $4$ 的倍数，而且 $x$，$x$ 的前半部分，$x$ 的后半部分都要是回文。例如 $\tt abbaabba$ 是一个双倍回文，而 $\tt abaaba$ 不是，因为它的长度不是 $4$ 的倍数。

- $x$ 的子串是指在 $x$ 中连续的一段字符所组成的字符串。例如 $\tt be$ 是 $\tt abed$ 的子串，而 $\tt ac$ 不是。
- $x$ 的回文子串，就是指满足回文性质的 $x$ 的子串。
- $x$ 的双倍回文子串，就是指满足双倍回文性质的 $x$ 的子串。

你的任务是，对于给定的字符串，计算它的最长双倍回文子串的长度。
## 输入格式

输入分为两行。

第一行为一个整数，表示字符串的长度。  
第二行有个连续的小写的英文字符，表示字符串的内容。
## 输出格式

输出文件只有一行即输入数据中字符串的最长双倍回文子串的长度，如果双倍回文子串不存在，则输出 $0$。
## 样例

### 样例输入 #1
```
16
ggabaabaabaaball
```
### 样例输出 #1
```
12
```
## 提示

### 数据范围及约定

对于全部数据，$1\le N \le 500000$。


---

---
title: "[HAOI2008] 排名系统"
layout: "post"
diff: 省选/NOI-
pid: P4291
tag: ['模拟', '字符串', '2008', '河南', '各省省选', '平衡树']
---
# [HAOI2008] 排名系统
## 题目描述

排名系统通常要应付三种请求：上传一条新的得分记录、查询某个玩家的当前排名以及返回某个区段内的排名记录。当某个玩家上传自己最新的得分记录时，他原有的得分记录会被删除。为了减轻服务器负担，在返回某个区段内的排名记录时，最多返回10条记录。
## 输入格式

第一行是一个整数n（10<=n<=250000）表示请求总数目。接下来n行,每行包含了一个请求。请求的具体格式如下：

+Name Score 上传最新得分记录。Name表示玩家名字，由大写英文字母组成，不超过10个字符。Score为最多8位的正整数。

?Name 查询玩家排名。该玩家的得分记录必定已经在前面上传。如果两个玩家的得分相同，则先得到该得分的玩家排在前面。

?Index 返回自第Index名开始的最多10名玩家名字。Index必定合法，即不小于1，也不大于当前有记录的玩家总数。
## 输出格式

对于?Name格式的请求，应输出一个整数表示该玩家当前的排名。

对于?Index格式的请求，应在一行中依次输出从第Index名开始的最多10名玩家姓名，用一个空格分隔。
## 样例

### 样例输入 #1
```
20
+ADAM 1000000
+BOB 1000000
+TOM 2000000
+CATHY 10000000
?TOM
?1
+DAM 100000
+BOB 1200000
+ADAM 900000
+FRANK 12340000
+LEO 9000000
+KAINE 9000000
+GRACE 8000000
+WALT 9000000
+SANDY 8000000
+MICK 9000000
+JACK 7320000
?2
?5
?KAINE
```
### 样例输出 #1
```
2
CATHY TOM ADAM BOB
CATHY LEO KAINE WALT MICK GRACE SANDY JACK TOM BOB
WALT MICK GRACE SANDY JACK TOM BOB ADAM DAM
4
```
## 提示

20%数据满足N<=100

100%数据满足N<=250000


---

---
title: "[SCOI2007] k短路"
layout: "post"
diff: 省选/NOI-
pid: P4467
tag: ['字符串', '2007', '四川', '各省省选', '排序', '最短路', 'A*  算法']
---
# [SCOI2007] k短路
## 题目描述

有 $n$ 个城市和 $m$ 条单向道路，城市编号为 $1$ 到 $n$。每条道路连接两个不同的城市，且任意两条道路要么起点不同要么终点不同，因此 $n$ 和 $m$ 满足$m \le n(n-1)$。

给定两个城市 $a$ 和 $b$，可以给 $a$ 到 $b$ 的所有简单路（所有城市最多经过一次，包括起点和终点）排序：先按长度从小到大排序，长度相同时按照字典序从小到大排序。你的任务是求出 $a$ 到 $b$ 的第 $k$ 短路。

## 输入格式

输入第一行包含五个正整数 $n,m,k,a,b$。

以下 $m$ 行每行三个整数 $u,v,l$，表示从城市 $u$ 到城市 $v$ 有一条长度为 $l$ 的单向道路。
## 输出格式

如果 $a$ 到 $b$ 的简单路不足 $k$ 条，输出 `No`，否则输出第 $k$ 短路：从城市 $a$ 开始依次输出每个到达的城市，直到城市 $b$，中间用减号 `-` 分割。
## 样例

### 样例输入 #1
```
5 20 10 1 5
1 2 1
1 3 2
1 4 1
1 5 3
2 1 1
2 3 1
2 4 2
2 5 2
3 1 1
3 2 2
3 4 1
3 5 1
4 1 1
4 2 1
4 3 1
4 5 2
5 1 1
5 2 1
5 3 1
5 4 1
```
### 样例输出 #1
```
1-2-4-3-5
```
### 样例输入 #2
```
4 6 1 1 4
2 4 2
1 3 2
1 2 1
1 4 3
2 3 1
3 4 1
```
### 样例输出 #2
```
1-2-3-4
```
### 样例输入 #3
```
3 3 5 1 3
1 2 1
2 3 1
1 3 1
```
### 样例输出 #3
```
No
```
## 提示

第一个例子有 $5$ 个城市，所有可能出现的道路均存在。从城市 $1$ 到城市 $5$ 一共有 $5$ 条简单路，排序如下：

![](https://cdn.luogu.com.cn/upload/pic/17706.png)

- $20\%$ 的数据满足：$n\leq 5$；
- $40\%$ 的数据满足：$n\leq 30$；
- $100\%$ 的数据满足：$2\leq n\leq 50$，$1\leq k\leq 200$，$1\le l\le 10^4$。


---

---
title: "[BJWC2011] 禁忌"
layout: "post"
diff: 省选/NOI-
pid: P4569
tag: ['字符串', '2011', '北京', 'Special Judge', '矩阵乘法', 'AC 自动机']
---
# [BJWC2011] 禁忌
## 题目描述

Magic Land上的人们总是提起那个传说：他们的祖先John在那个东方岛屿帮助Koishi与其姐姐Satori最终战平。而后，Koishi恢复了读心的能力……

如今，在John已经成为传说的时代，再次造访那座岛屿的人们却发现Koishi遇到了新麻烦。

这次她遇到了Flandre Scarlet——她拥有可以使用禁忌魔法而不会受到伤害的能力。

为了说明什么是禁忌魔法及其伤害，引入以下概念：

1. 字母集$A$上的每个非空字符串对应了一个魔法。其中$A$是包含了前alphabet个小写字母的集合。
2. 有一个集合$T$，包含了$N$个字母集$A$上的字符串。$T$中的每一串称为一个禁忌串（Taboo string）
3. 一个魔法，或等价地，其对应的串$s$因为包含禁忌而对使用者造成的伤害按以下方式确定：把$s$分割成若干段，考虑其中是禁忌串的段的数目，不同的分割可能会有不同的数目，其最大值就是这个伤害。

由于拥有了读心的能力，Koishi总是随机地使用Flandre Scarlet的魔法，可以确定的是，她的魔法正好对应字母集$A$上所有长度为$len$的串。

但是，Flandre Scarlet所使用的一些魔法是带有禁忌的，由于其自身特性，她可以使用禁忌魔法而不受到伤害，而Koishi就不同了。可怜的Koishi每一次使用对方的魔法都面临着受到禁忌伤害的威胁。

你现在需要计算的是如果Koishi使用对方的每一个魔法的概率是均等的，那么每一次随机使用魔法所受到的禁忌伤害的期望值是多少。
## 输入格式

第一行包含三个正整数 $N$、$len$、$alphabet$。  
接下来$N$行，每行包含一个串$T_i$，表示禁忌串。
## 输出格式

一个非负实数，表示所受到禁忌伤害的期望值。你的答案需要保证绝对误差不超过 $10^{-6}$。
## 样例

### 样例输入 #1
```
2 4 2
aa
abb
```
### 样例输出 #1
```
0.75

```
## 提示

【样例1解释】
一共有$2^4 = 16$种不同的魔法。

需要注意的是“aabb”的禁忌伤害是1而不是2。

### 数据范围

有不少于40%的数据中：$N = 1$。  
100%的数据中$N ≤ 5$，$len ≤10^9$，$1 ≤ alphabet ≤ 26$。  
数据保证每个串$T_i$的长度不超过$15$，并且不是空串。  
数据保证每个$T_i$均仅含有前$alphabet$个小写字母。  
数据保证集合$T$中没有相同的元素，即对任意不同的$i$和$j$，有$T_i \neq T_j$。


---

---
title: "[TJOI2018] 游园会"
layout: "post"
diff: 省选/NOI-
pid: P4590
tag: ['字符串', '递推', '2018', '各省省选', '枚举', '有限状态自动机', '天津', 'DP 套 DP']
---
# [TJOI2018] 游园会
## 题目描述

小豆参加了 NOI 的游园会，会场上每完成一个项目就会获得一个奖章，奖章只会是 $\texttt{N}$、$\texttt{O}$、$\texttt{I}$ 的字样。在会场上他收集到了 $K$ 个奖章组成的串。兑奖规则是奖章串和兑奖串的最长公共子序列长度为小豆最后奖励的等级。现在已知兑奖串长度为 $N$，并且在兑奖串上不会出现连续三个奖章为 $\texttt{NOI}$，即奖章中不会出现子串 $\texttt{NOI}$。现在小豆想知道各个奖励等级会对应多少个不同的合法兑奖串。

## 输入格式

第一行两个数，$N, K$ 分别代表兑奖串的长度，小豆收集的奖章串的长度（$N\leq1000,K\leq15$）。

第二行一共 $K$ 个字符，表示小豆得到的奖章串。
## 输出格式

一共 $K+1$ 行，第行表示小豆最后奖励等级为 $i-1$ 的不同的合法兑奖串的个数，可能这个数会很大，结果对 $10^9+7$ 取模。
## 样例

### 样例输入 #1
```
3 2
NO
```
### 样例输出 #1
```
1
19
6
```
## 提示

### 样例解释

最长公共子序列长度为 $0$ 的串有：$\texttt{III}$;

最长公共子序列长度为 $2$ 的串有：$\texttt{NON}$、$\texttt{NNO}$、$\texttt{NOO}$、$\texttt{ONO}$、$\texttt{INO}$、$\texttt{NIO}$；

除去 $\texttt{NOI}$，余下的 $19 = 26-6-1$ 种为最长公共子序列长度为 $1$。

### 数据范围

- 对于 $10\%$ 的数据，$N\leq10,K\leq10$；
- 对于 $30\%$ 的数据，$N\leq100,K\leq4$；
- 对于 $100\%$ 的数据，$N\leq1000,K\leq15$。


---

---
title: "[FJOI2016] 所有公共子序列问题"
layout: "post"
diff: 省选/NOI-
pid: P4608
tag: ['字符串', '高精度', '2016', '各省省选', '福建', '有限状态自动机']
---
# [FJOI2016] 所有公共子序列问题
## 题目描述

一个给定序列的子序列是在该序列中删去若干元素后得到的序列。确切地说，若给定序列 $X=x_1x_2\ldots x_m$，则另一序列 $Z=z_1z_2\ldots z_k$ 是 $X$ 的子序列是指存在一个严格递增下标序列 $i_1,i_2, \ldots ,i_k$ 使得对于所有 $j=1,2,…,k$ 有 $z_j=x_{i_j}$。

例如，序列 $Z=$``GACT`` 是序列 $X=$``GCTACT`` 的子序列，相应的递增下标序列为 $1,4,5,6$。给定两个序列 $X$ 和 $Y$，当另一序列 $Z$ 既是 $X$ 的子序列又是 $Y$ 的子序列时，称 $Z$ 是序列 $X$ 和 $Y$ 的公共子序列。例如，若 $X=$``GCTACT``， $Y=$``GATCCT``，序列 $T$ 是 $X$ 和 $Y$ 的一个公共子序列，序列 ``GACT`` 也是 $X$ 和 $Y$ 的一个公共子序列。注意对于任何给定的序列 $X$ 和 $Y$，空序列总是它们的一个公共子序列。

所有公共子序列问题是要求对于给定的 $2$ 个序列 $X=x_1x_2\ldots x_m$ 和 $Y=y_1y_2\ldots y_m$，找出 $X$ 和 $Y$ 的所有不同的公共子序列。
## 输入格式

文件的第一行有两个正整数 $m$ 和 $n$，分别表示 $2$ 个输入序列 $X$ 和 $Y$ 的长度。

接下来的两行分别给出输入序列 $X=x_1x_2\cdots x_m$ 和 $Y=y_1y_2\cdots y_m$，其中序列中每个元素均为二十六个英文大小写字母。

文件的最后一行给出一个非负整数 $k$。

$k$ 的值为 $1$ 时，表示计算结果要输出 $X$ 和 $Y$ 的所有不同的公共子序列，以及 $X$ 和 $Y$ 有多少个不同的公共子序列。

$k$ 的值为 $0$ 时，表示计算结果只要输出 $X$ 和 $Y$ 有多少个不同的公共子序列。
## 输出格式

将计算出的 $X$ 和 $Y$ 的所有不同的公共子序列，或 $X$ 和 $Y$ 有多少个不同的公共子序列输出到文件中。当 $k=1$ 时，先输出 $X$ 和 $Y$ 的所有不同的公共子序列，每行输出一个公共子序列，按字典序从小到大输出。最后输出不同的公共子序列的个数。当 $k=0$ 时，只要输出不同的公共子序列的个数。
## 样例

### 样例输入 #1
```
6 6
GCTACT
GATCCT 1
```
### 样例输出 #1
```
A
AC
ACT
AT 
C  
CC 
CCT
CT 
G  
GA 
GAC
GACT
GAT 
GC  
GCC 
GCCT
GCT 
GT  
GTC 
GTCT
GTT 
T   
TC  
TCT 
TT  
26
```
## 提示

$1 \leq m,n \leq 3010$

答案....很大啦


---

---
title: "小奔上课"
layout: "post"
diff: 省选/NOI-
pid: P4908
tag: ['字符串', '递归', '栈']
---
# 小奔上课
## 题目背景

这一堂课是数学课！
## 题目描述

小奔最喜欢数学了QvQ，但是因为晚上太困睡着了，所以当他反应过来要写题目时，黑板上的算式已经残缺不堪了。

没办法，小奔只好依靠人品猜一下了，只是猜也是有方法的，小奔想请你给出最大可能值和最输出只有一行，为最大可能值和最小可能值的平均值，并保留两位小数小可能值的平均值。
## 输入格式

只有一行，为残缺的算式（可能有括号），残缺部分用$*$表示~~（与乘号相同）~~，残缺部分可以为数字$0$到$9$，也可以是四则运算符号之一，不存在残缺括号。

## 输出格式

输出只有一行，为最大可能值和最小可能值的平均值，并保留两位小数
## 样例

### 样例输入 #1
```
1*1+9-2*3/1
```
### 样例输出 #1
```
-41.50
```
## 提示

样例解释:

最大值：$191+9-2+3/1=201$

最小值：$1-1+9-293/1=-284$

$07+1$（0不能打头），$5/0$（0不能做除数）等算式都是非法的

但$8+-6$是合法的，代表$8$加负$6$，同理$8/-6$也可

保证结果在$float$范围内


对于$40$%的数据，算式有括号

对于$10$%的数据，算式完全残缺（全是 * ）



---

---
title: "河童重工的计算机"
layout: "post"
diff: 省选/NOI-
pid: P4911
tag: ['模拟', '字符串', '栈']
---
# 河童重工的计算机
## 题目背景

河童重工业会社的计算机产品在幻想乡中有着极其广泛的应用。

有一天，妖怪之山发大水啦！洪水夹杂着泥沙和滚木汹涌着冲进了河童的城市。

本来河童们的机械设施都是防水的，可是洪水还是对城市造成了不小的破坏。其中，河童们的服务器被砸坏了！

坏掉的电脑在短时间内不能修复，可是幻想乡里的许多事情都离不开河童们的服务器！河童们也很无奈，于是荷取找到了你！你作为一名优秀的信竞选手，决定帮助荷取，减轻服务器故障所带来的压力。
## 题目描述

你从荷取那里得到了一份纸质资料，扫描版在这里：

[Ktx-65式微处理器汇编语言规范文件.pdf](https://www.touhou-oi.tk/uploads/Ktx-65%E5%BC%8F%E5%BE%AE%E5%A4%84%E7%90%86%E5%99%A8%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%A7%84%E8%8C%83%E6%96%87%E4%BB%B6.pdf)

（若此网站无法打开，请在附件中下载）

（为什么说是扫描版呢，因为，你应该不能复制里面的文字）

以下这一段是汇编教程附带的示例：
```asm
[ progfunc.asm ]
[ Shows the function functionailties of the KTX-65 ALI ]

[main]
wint #line;    [output the current physical line number]
wch 13;        [putchar \r]
wch 10;        [putchar \n]
callfunc $Function1;
callfunc $Function2;
hlt;           [halt]

function $Function1;
rint %r1;      [read int]
add %r2 1 %r2; [loop contents]
lle %r2 %r1;   [loop conditions]
jif 2;         [end loop conditional jump]
wint %r2;      [output int]
wch 13;        [putchar \r]
wch 10;        [putchar \n]
ret;           [return]

function $Function2;
rint %r1;      [read int]
rint %r2;      [read int]
add %r1, %r2;  [add]
wint %val;     [output value]
wch 13;        [putchar \r]
wch 10;        [putchar \n]
ret;           [return]
```
你需要用洛谷评测机支持的语言编写一个程序，它读入一个Ktx-65汇编语言程序和一段输入，解释运行这个程序，然后输出这个程序输出的东西。
## 输入格式

第一行是一个整数N，表示汇编程序的行数。

接下来N行是这个汇编程序，保证不会出现空行。

接下来的所有行都是这个汇编程序的输入。
## 输出格式

一堆东西，表示这个汇编程序的输出。

~~**评测系统将以逐字节比较的方式判断你的输出是否正确。**~~假的，洛谷不支持
## 样例

### 样例输入 #1
```
5
rint %r1;
rint %r2;
add %r1 %r2;
wint;
hlt;
5 4
```
### 样例输出 #1
```
9
```
## 提示



**注意**：样例输出中只有9这一个字节。

**保证一行中只有一个指令。**

对于10%的数据：程序中只有输入和输出的指令，且不会出现数字常量，也不会有注释。

对于另外10%：程序中只有输入、输出和加法指令，且没有注释。

对于另外30%：包括除函数调用和跳转在内的所有指令。

对于剩下50%：指令没有限制。

对于全部的数据：命令条数不超过50000条，剩余输入不超过500千字节，程序需要执行的步数不超过80000步。

保证汇编程序和数据不出现编译或是运行时错误。

保证程序输入足够满足汇编程序中读入的需要。

不保证这是或不是一道毒瘤题

不保证考试时会不会有人AC这道题

不保证这次考试会不会有人AK

保证出题人为：[洩矢诹访子](https://www.luogu.org/space/show?uid=53151)

考试时打不开河童给的文件可以向我索要，不保证是否会回答

~~其实这道题数据非常简单，只是量大而已~~


---

---
title: "PION后缀自动机"
layout: "post"
diff: 省选/NOI-
pid: P4947
tag: ['字符串', '二分', '树链剖分']
---
# PION后缀自动机
## 题目背景

NOIP2018原创模拟题T6

NOIP2018原创模拟赛DAY2 T3

NOIP DAY1 T3+ or DAY2 T3 难度

鉴于 NOIP2017 DAY2 T3 的难度，就有了这道题。**然而这道题考察的知识并不是后缀自动机**
## 题目描述

小P是一个技术高超的程序员，他开发了一套自己的操作系统，称为PION系统，该系统与Windows和Linux有很大不同，目前他正在测试该系统。

PION系统与Windows系统最大的不同在于文件的储存与操作，POIN的文件夹没有父子之分。我们知道，在Windows系统中，可以在文件夹里新建子文件夹。但是，PION系统文件夹不分父子关系，**但是部分文件夹之间可以互相直接访问，我们称这种关系为互访关系，而且，对于一个有$n$个文件夹的系统来说，这种互访关系有$n-1$个，且保证所有文件夹均可以通过互访关系而互相访问。也就是说：我们可以把Windows中的文件夹的集合看作一棵有根树，而把PION系统中的文件夹集合看作为无根树。**

在PION系统中，每个文件夹都可以储存文件，和Windows一样，文件名包含后缀名。

现在小P正在构思一种可以对文件夹中文件后缀进行方便操作的交互式程序dmc，他也将其称为**PION后缀自动机**。由于他太忙了，所以他希望你帮他实现**部分功能**。

他希望你帮他实现三个功能：

1.计算两个文件夹之间的距离。我们定义：文件夹之间的距离为其中一个文件夹通过互访达到另一个文件夹最少互访次数。比如：同一个文件夹距离为0，两个有互访关系的文件夹距离为1。

2.计算两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件数量，**其中A是一个小写字符串。提示：我们可以把PION文件夹之间的路径理解为树中两节点之间的路径。**

3.删除两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件，并统计被删除文件的数量。

由于dmc是一个交互系统，所以我们用tab语言描述这三个操作：

```
query /p u v
```

表示操作一，其中 u,v 表示两文件夹的编号

```
query /e u v *.A
```

表示操作二，其中 u,v 表示两文件夹的编号，$'*'$ 为通配符，$'.'$用于分隔文件名与后缀，**A是一个小写字符串**。

```
del /e u v *.A
```

表示操作三， $u,v, *.A$ 意义与操作二相同。

**如果没有看懂题目请结合样例及样例解释来理解。**

最后，这个困难的任务就交给你了。
## 输入格式

第一行两个数，$n,m$，$n$表示文件夹的数量（文件夹编号在$[1,n]$），$m$表示操作的数量

接下来 $n-1$ 行，每行两个数 $u,v$，表示文件夹 $u,v$ 之间有互访关系

接下来 $n$ 行，第$i$行第一个数为 $k$，表示第$i$个文件夹有$k$个文件，接下来为$k$个字符串，表示每个文件的后缀名

再接下来$m$行，每行一串指令，格式见上文
## 输出格式

对于每个指令，输出一个数，输出数的意义见上文
## 样例

### 样例输入 #1
```
5 5
1 2
2 4
2 5
1 3
2 cpp c
3 pas txt txt
2 vbs bat
3 vbs cpp pas
4 cpp c pas txt
query /e 1 5 *.txt
query /p 1 4
del /e 2 2 *.txt
query /e 1 5 *.txt
query /e 4 3 *.vbs
```
### 样例输出 #1
```
3
2
2
1
2
```
### 样例输入 #2
```
12 7
1 2
1 3
1 4
2 5
2 6
3 7
7 12
8 4
8 9
10 9
11 9
0
2 c c
3 zz c c
0
1 gif
2 png bmp
3 avl avl mpshi
0
4 cpp c pas js
5 a b c d e
0
3 a b c
query /p 11 12
query /e 1 2 *.gif
query /e 6 10 *.c
del /e 2 9 *.c
del /e 3 12 *.c
query /e 5 6 *.gif
query /e 6 1 *.c
```
### 样例输出 #2
```
7
0
4
3
3
1
0
```
## 提示

**样例一解释：**

![T6](https://cdn.luogu.com.cn/upload/pic/34166.png)

如图为样例一大致结构，橙色方框为文件夹，灰色文字表示文件后缀名，红色线条表示文件互访关系。

对于第一个操作：文件夹1到5之间txt文件有3个所以输出3  
对于第二个操作：文件夹1与4距离为2  
对于第三个操作：删除的为文件夹2的文件，txt文件有两个，所以输出2  
对于第四个操作：由于文件夹2的txt文件被删除了，所以1到5之间txt文件只有1个  
对于第五个操作：文件夹3到4之间vbs文件有2个所以输出2

**数据范围：**

30%数据满足：$n,m<=100,k<=3$

50%数据满足：$n,m<=5000,k<=10$

70%数据满足：$n,m<=2 \times 10^4,k<=50$

90%数据满足：$n,m<=5 \times 10^4$

100%数据满足：$n,m<=10^5$，文件总数小于$5 \times 10^5$，文件后缀名为小写字符串且不超过6个字符

其他说明：

1.约50%的数据为完全随机生成

2.数据弱化版：[PION后缀自动机（数据弱化版）](https://www.luogu.org/problemnew/show/U41487)


---

---
title: "Annihilate"
layout: "post"
diff: 省选/NOI-
pid: P5028
tag: ['字符串', '后缀数组 SA']
---
# Annihilate
## 题目背景

前情提要：小正方形与黑暗之主展开了大战，最后小正方形击败了黑暗之主，成功从黑暗之主的手上夺下最后一个三角。

三角旋转着，净化着，正当三角即将净化完成时，黑暗之主突然到来，阻断了三角形的净化，吸收了三角的能量。

可是，因为三角的能量太过巨大，导致黑暗之主发生了变异，现在的黑暗之主一次次复制，最终成为了一条蜈蚣……

现在，小正方形还能阻止黑暗之主毁灭世界吗？
## 题目描述

黑暗之主的蜈蚣几乎可以毁灭一切，因此小正方形陷入了苦战……

小正方形现在需要减弱黑暗之主的攻击。

一个黑暗之主的攻击可以用一个仅有小写字母的字符串表示。

现在黑暗之主向小正方形发动了若干攻击，对于两个攻击，小正方形能选出它们最长的公共**子串**，并把这一段消除。

现在小正方形想要知道，对于**任意两个**黑暗之主的攻击，它们的最长公共子串长度是多少，你能帮帮它吗？
## 输入格式

第一行为一个整数 $n$，表示字符串数目。

接下来 $n$ 行，一行一个字符串，保证所有字符串长度之和 <= 1000000


## 输出格式

输出共有 $n$ 行，每行 $n - 1$个正整数

第一行第一个正整数表示第1个串与第2个串的最长公共子串

第二个正整数表示第1个串与第3个串的最长公共子串

……

第二行第一个正整数表示第2个串与第1个串的最长公共子串

以此类推。
## 样例

### 样例输入 #1
```
3
abb
bcc
aba
```
### 样例输出 #1
```
1 2
1 1
2 1
```
## 提示

对于 $30\%$ 的数据，$n <= 5$，每个字符串长度 $<= 500$

对于 $100\%$ 的数据，$2 <= n <= 50$，字符串长度之和 $ <= 1000000$

**注意：本题内存限制仅为 64 MB,请尽量使用内存运用优秀的方法。**

另外，对于占 60 Pts 的测试点，您每通过一个点即可获得 10 Pts

对于剩下的测试点，您只有全部通过才能获得 40 Pts.

**对于所有数据点，不保证数据为随机生成。**


---

---
title: "FZOUTSY"
layout: "post"
diff: 省选/NOI-
pid: P5112
tag: ['字符串', 'O2优化']
---
# FZOUTSY
## 题目描述

### 原始题意

cdm1020 是一名废宅，他平时最喜欢的事情就是水（复）群（读）。

他截取了他最近水的群的聊天记录，并且通过某种奥妙重重的压缩算法将这些聊天记录压缩成了一个长度为 $n$ 的字符串，因为他是一个中二社厨，所以这个字符串当中仅仅含有 $\mathtt{f,z,o,u,t,s,y}$ 这 $7$ 种字符，出于对后缀数据结构的狂热，他只对这个字符串的后缀感兴趣，他定义一个后缀的编号为 $i$，当且仅当它代表的字符串的区间为 $[i,n]$。

cdm1020 定义一对后缀 $(i,j)$ 是"$k$级复读的"当且仅当 $i$ 和 $j$ 的最长公共前缀的长度大于等于 $k$，换句话说一对$k$级复读的后缀也是 $k-1,k-2,k-3,\cdots,1,0$ 级复读的。

现在他想问你对于编号在 $(l,r)$ 中的后缀，有多少对后缀是 $k$ 级复读的。

### 一句话题意

给定一个长度为 $n$ 并且字符集为 $\mathtt{f,z,o,u,t,s,y}$ 的字符串和一个询问参数 $k$，多组询问 $(l,r)$ 求编号在 $(l,r)$ 间的后缀中，有多少对后缀的 LCP（最长公共前缀）长度大于等于 $k$。

定义一个后缀的编号为 $i$ 当且仅当这个后缀代表的是 $(i,n)$ 这段区间的字符。
## 输入格式

第一行三个正整数 $n,m,k$ 分别代表字符串的长度 $n$，询问次数 $m$ 和询问的参数 $k$。

第二行一个长度为 $n$ 的字符串表示你需要处理的字符串。

接下来 $m$ 行，每行两个正整数 $l,r$ 表示询问的区间 $l,r$。
## 输出格式

输出 $m$ 行正整数，表示询问区间中 LCP 长度大于等于 $k$ 的后缀对数量。
## 样例

### 样例输入 #1
```
20 15 3
oouuoouuoouuoouuoouu
10 16
2 15
4 13
6 7
4 12
12 14
12 13
7 19
1 5
6 13
1 15
9 15
11 15
1 19
15 18
```
### 样例输出 #1
```
3
18
8
0
6
0
0
12
1
4
21
3
1
32
0
```
## 提示

### 数据范围及约定

对于全部数据，$1\leq l\leq r\leq n \leq 3×10^6$，$1\leq k \leq n \leq 3×10^6$，$1\leq m \leq 10^5$，$1 \leq n^2m \leq 10^{15}$。

保证输入的字符串中仅含 $\mathtt{f,z,o,u,t,s,y}$ 这 $7$ 种小写字母。


---

---
title: "[JSOI2012] 玄武密码"
layout: "post"
diff: 省选/NOI-
pid: P5231
tag: ['字符串', '2012', '各省省选', '江苏', '后缀自动机 SAM', 'O2优化', 'AC 自动机', '后缀数组 SA']
---
# [JSOI2012] 玄武密码
## 题目背景

在美丽的玄武湖畔，鸡鸣寺边，鸡笼山前，有一块富饶而秀美的土地，人们唤作进香河。相传一日，一缕紫气从天而至，只一瞬间便消失在了进香河中。老人们说，这是玄武神灵将天书藏匿在此。 

很多年后，人们终于在进香河地区发现了带有玄武密码的文字。更加神奇的是，这份带有玄武密码的文字，与玄武湖南岸台城的结构有微妙的关联。于是，漫长的破译工作开始了。
## 题目描述

 经过分析，我们可以用东南西北四个方向来描述台城城砖的摆放，不妨用一个长度为 $n$ 的序列 $s$ 来描述，序列中的元素分别是 `E`，`S`，`W`，`N`，代表了东南西北四向，我们称之为母串。而神秘的玄武密码是由四象的图案描述而成的 $m$ 段文字。这里的四象，分别是东之青龙，西之白虎，南之朱雀，北之玄武，对东南西北四向相对应。 

现在，考古工作者遇到了一个难题。对于每一段文字 $t$，求出其最长的前缀 $p$，满足 $p$ 是 $s$ 的子串。
## 输入格式

第一行有两个整数，分别表示母串的长度 $n$ 和文字段的个数 $m$。

第二行有一个长度为 $n$ 的字符串，表示母串 $s$。

接下来 $m$ 行，每行一个字符串，表示一段带有玄武密码的文字 $t$。
## 输出格式

对于每段文字，输出一行一个整数，表示最长的 $p$ 的长度。
## 样例

### 样例输入 #1
```
7 3
SNNSSNS
NNSS
NNN
WSEE

```
### 样例输出 #1
```
4
2
0
```
## 提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，保证 $n \leq 100$，$m \leq 50$。
- 对于 $40\%$ 的数据，保证 $n \leq 2 \times 10^4$，$m \leq 2 \times 10^3$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^6$，$m \leq 2 \times 10^4$。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 10^7$，$1 \leq m \leq 10^5$，$1 \leq |t| \leq 100$，$s, t$ 中均只含字母 `E` `S` `W` `N`。


---

---
title: "树上后缀排序"
layout: "post"
diff: 省选/NOI-
pid: P5353
tag: ['字符串', '倍增', 'O2优化', '后缀数组 SA']
---
# 树上后缀排序
## 题目描述

给定一棵以 $1$ 为根包含 $n$ 个节点的树，保证对于 $2 \sim n$ 的每个节点，其父亲的编号均小于自己的编号。

每个节点上有一个的字符，一个节点所代表的字符串定义为从当前节点一直到根节点的简单路径上经过的所有字符连起来形成的字符串。

请你给这些字符串按照字典序排序。

特别地，如果两个节点所代表的字符串完全相同，它们的大小由它们父亲排名的大小决定，即谁的父亲排名大谁就更大；如果仍相同，则由它们编号的大小决定，即谁的编号大谁就更大。
## 输入格式

第一行包含一个正整数 $n$。

第二行包含 $n-1$ 个数 $f_{2 \dots n}$，其中 $f_i$ 表示 $i$ 的父亲。

第三行为一个包含 $n$ 个**小写字母**的字符串 $s$，其中 $s_i$ 表示编号为 $i$ 的节点上的字符。
## 输出格式

输出一行 $n$ 个正整数，第 $i$ 个正整数表示代表**排名第 $i$ 的字符串**的节点编号。
## 样例

### 样例输入 #1
```
5
1 1 3 2
abbaa
```
### 样例输出 #1
```
1 5 4 2 3
```
## 提示

对于 $20\%$ 的数据，$n \le 10 ^ 3$。

对于 $50\%$ 的数据，$n \le 10 ^ 5$。

对于 $100\%$ 的数据，$1 \le n \le 5 \times 10 ^ 5$。


---

---
title: "[BJOI2016] IP地址"
layout: "post"
diff: 省选/NOI-
pid: P5460
tag: ['字符串', '2016', '各省省选', '北京', 'O2优化', '字典树 Trie']
---
# [BJOI2016] IP地址
## 题目描述

路由表中每一项对应了一个形如 1011101????????????????????????? 的规则，会匹配指定的前缀为给定形式的 $\texttt{ip}$。  

当有多个规则匹配时，前缀最长的生效。同一时刻不会有多个匹配的规则的前缀一样长。每一个时刻，会有一条规则被加入，或者之前被加入的某条规则会过期。   

给一系列 $\texttt{ip}$，问每一个 $\texttt{ip}$ 在一个给定的时间区间内匹配到的生效规则变了几次？  
   
例如，有一系列事件：    
 
$\texttt{Add}$ $110$   
$\texttt{Add}$ $11$   
$\texttt{Del}$ $110$   
$\texttt{Del}$ $11$   
$\texttt{Add}$ $110$     

那么，$\texttt{ip}$ 地址 11011101001001010101011101000010 在这五个时刻之后匹配到的生效规则分别是：  

$110$ (第一条)，   
$110$ (第一条)，   
$11$ (第二条)，   
空，   
$110$ (第三条)。     

其中，在第二个事件后到第五个事件后的这段过程中，一共变了 $3$ 次。
## 输入格式

第一行两个正整数 $n,q$，表示事件数有询问数。  
接下来 $n$ 行，每行描述一个事件，格式为：  

$\texttt{Add}$ $s$ 表示新建一个规则，匹配前缀为 $s$ 的所有 $\texttt{ip}$。  
$\texttt{Del}$ $s$ 表示把当前前缀 $s$ 对应的规则删掉(过期)。保证之前有这样的一条规则还没被删。     

接下来 $q$ 行，每行一个 $\texttt{ip}$ 与两个正整数 $a,b$，表示查询在第 $a$ 个事件后到第 $b$ 个事件的这段时间里，这个 $\texttt{ip}$ 匹配到的生效规则变化的次数。 $\texttt{ip}$ 用01字符串来表示。
## 输出格式

对于每次查询，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
5 1
Add 110
Add 11
Del 110
Del 11
Add 110
11011101001001010101011101000010 2 5
```
### 样例输出 #1
```
3
```
## 提示

【数据范围】  

$1\le n,q \le 10^5$


---

---
title: "【模板】回文自动机（PAM）"
layout: "post"
diff: 省选/NOI-
pid: P5496
tag: ['字符串', 'O2优化', '回文自动机 PAM']
---
# 【模板】回文自动机（PAM）
## 题目描述

给定一个字符串 $s$。保证每个字符为小写字母。对于 $s$ 的每个位置，请求出以该位置结尾的回文子串个数。

这个字符串被进行了加密，除了第一个字符，其他字符都需要通过上一个位置的答案来解密。

具体地，若第 $i(i\geq 1)$ 个位置的答案是 $k$，第 $i+1$ 个字符读入时的 $\rm ASCII$ 码为 $c$，则第 $i+1$ 个字符实际的 $\rm ASCII$ 码为 $(c-97+k)\bmod 26+97$。所有字符在加密前后都为小写字母。
## 输入格式

一行一个字符串 $s$ 表示被加密后的串。
## 输出格式

一行， $|s|$ 个整数。第 $i$ 个整数表示原串以第 $i$ 个字符结尾的回文子串个数。
## 样例

### 样例输入 #1
```
debber

```
### 样例输出 #1
```
1 1 1 2 1 1

```
### 样例输入 #2
```
lwkvjfrphhgkfvzzyx

```
### 样例输出 #2
```
1 1 2 2 3 1 1 1 1 2 3 1 1 1 1 2 3 4

```
### 样例输入 #3
```
azzzyyzyyx
```
### 样例输出 #3
```
1 2 1 2 3 2 2 2 3 3
```
## 提示

### 样例解释

三个样例解码后分别为：

- $\verb!dfccgs!$；
- $\verb!lxlxlisqiiingwaaaa!$；
- $\verb!aabaabbaaa!$。

### 数据范围及约定

对于 $100\%$ 的数据， $1\leq |s|\leq 5\times 10^5$。


---

---
title: "【XR-3】系统设计"
layout: "post"
diff: 省选/NOI-
pid: P5537
tag: ['字符串', '线段树', '二分', '树状数组', 'O2优化', '哈希 hashing']
---
# 【XR-3】系统设计
## 题目描述

小 X 需要你设计一个系统。

这个系统首先需要输入一棵 $n$ 个点的有根树和一个长度为 $m$ 的序列 $a$，接下来需要实现 $q$ 个操作。

操作分两种：

1. `1 x l r` 表示设定起点为有根树的节点 $x$，接下来依次遍历 $l \sim r$。当遍历到 $i$ 时，从当前节点走向它的编号第 $a_i$ 小的儿子。如果某一时刻当前节点的儿子个数小于 $a_i$，或者已经遍历完 $l \sim r$，则在这个点停住，并输出这个点的编号，同时停止遍历。
2. `2 t k` 表示将序列中第 $t$ 个数 $a_t$ 修改为 $k$。
## 输入格式

第一行 $3$ 个正整数 $n,m,q$，分别表示树的点数、序列的长度和操作个数。

第二行 $n$ 个整数 $f_{1 \dots n}$，其中 $f_i$ 表示点 $i$ 在树中的父亲节点编号，特别地，设根节点为 $rt$，则 $f_{rt} = 0$。

第三行 $m$ 个正整数 $a_{1 \dots m}$，表示序列 $a$。

接下来 $q$ 行，每行描述一个操作。

**数据范围：**

- $1 \le n,m,q \le 5 \times 10 ^ 5$。
- $1 \le a_i \le n$。
- 对于操作 $1$，保证 $1 \le x \le n$，$1 \le l \le r \le m$。
- 对于操作 $2$，保证 $1 \le t \le m$，$1 \le k \le n$。
## 输出格式

对于每个操作 $1$，一行一个正整数，表示答案。
## 样例

### 样例输入 #1
```
6 6 10
0 1 2 2 1 5
1 2 2 1 2 1
1 1 1 3
1 5 2 6
1 6 5 6
1 2 3 5
1 2 4 4
2 2 1
1 1 1 6
1 1 2 4
2 1 2
1 1 1 5

```
### 样例输出 #1
```
4
5
6
4
3
3
4
6

```
## 提示

本题读入、输出量较大，请使用[读入、输出优化](https://oi-wiki.org/misc/io/)。

【样例说明】

第一个操作为 `1 1 1 3`，即 $1 \rightarrow 2 \rightarrow 4$，因此答案为 $4$。

第九个操作后，序列变为 `2 1 2 1 2 1`。

第十个操作为 `1 1 1 5`，即 $1 \rightarrow 5 \rightarrow 6$，因此答案为 $6$。


---

---
title: "秩序魔咒"
layout: "post"
diff: 省选/NOI-
pid: P5555
tag: ['字符串', '后缀自动机 SAM', '哈希 hashing', '回文自动机 PAM']
---
# 秩序魔咒
## 题目描述

现代魔法师小L和小K正在研究魔咒。

“你知道如何使用魔咒吗？”

“当然知道，这是一个现代魔法师最基本的修养。”

“那你对魔咒的发展史了解多少？”

“课上讲的我还记得一点。那是在很久很久之前了。当时，世界上还没有人会使用魔咒，而混沌魔法成为了魔法界当时的主流魔法。这是一种邪恶的法术，不需要技巧，不需要规则，内心越黑暗，力量越强。于是，邪恶的魔法师们自相残杀，弄得天昏地暗，血流成河。其中，以自称‘混沌恶魔’的魔法师为首的魔法师集团通过极其肮脏的手段控制了几乎整个魔法界，让那些向往秩序与和平的魔法师难以生存。就在这个时候，世界救星的救星出现了。名为莱赫穆拉和肯埋多卡的两名魔法师勇敢地站了出来，仅凭两个人的力量就与混沌恶魔集团展开了决战，可终究寡不敌众，被逼到了绝境。就在混沌恶魔的最后一击打中他们的身体时，莱赫穆拉和肯埋多卡利用这一击的巨大魔力，将两人余下的全部魔法与意志升格成了概念，创造了秩序魔咒体系，扭转了世界理论，使得混沌魔法被永远封印。而混沌恶魔也在这强烈的扭曲中灰飞烟灭。从此，魔法界由混沌纪元进入了秩序纪元，人们遵循莱赫穆拉和肯埋多卡这两位圣人的遗志，在秩序魔咒体系下使用魔咒，直到现在。”

“原来是这样。我们如今需要遵循一系列原则来使用魔咒，是这个原因啊。”

“是啊，这正是两位圣人为维持现在这个世界不退回混沌纪元而做的努力。话说，你是上个星期才刚刚上了第一堂魔法课，你还记得使用魔咒的几个原则吗？”

“我想想。第一，必须出现在秩序序列中。当时二位圣人留下来的体系，经过后代魔法师不懈的努力，被翻译成了名为秩序序列的存在。为了方便现代魔法师使用，**秩序序列只由英文小写字母组成**。由于体系的力量过于强大而不能仅仅限制在一个序列中，**魔法师们分别将两位圣人的遗志转移到了两个秩序序列里**。魔咒必须受到秩序序列的限制。**具体来说，是必须出现在秩序序列里（是秩序序列的子串）**。由于二位圣人的遗志不可分割，**魔咒必须同时出现在两个秩序序列里**。第二，为了让魔咒稳定而精确，秩序体系规定了魔咒的形态。**具体来说，魔咒的第一个字符需要与魔咒的倒数第一个字符相同，魔咒的第二个字符需要与魔咒的倒数第二个字符相同，以此类推**。这样就可以使魔咒对称而有秩序了。还有的话，让我看看……”

“别看了别看了，最重要的就是这些了。还有，你说不定还不知道，魔咒越长，力量越强大。”

“是这样的吗？难怪那天老师演示的魔咒魔力比我的大那么多。”

“是的是的。你是不是已经发现了，魔咒的力量是有最高限制的？”

“啊，好像没错。但老师那天说，最强魔咒的使用者还没出现？”

“对。使用者自身必须要有与魔咒同样程度的能力，才可能顺利地使用这个魔咒。我们这些初学者，不知道何年何月才能达到这个程度呢……”

“唉……不如，我们来数一数力量最强的魔咒的长度，和它们有多少个吧。”

“嗯，反正没事可做，我们就来干一干这种力所能及的事吧。”

于是，小L和小K就开始数最强魔咒的长度和个数。可过了不一会儿，它们就坚持不住了，因为秩序序列实在太长太长了。

现在，你作为一个资深魔法师，有必要告诉他们这种基本的常识。你当然已经知道两个秩序序列的形态，请你帮小L和小K算出最强魔咒的长度和个数。
## 输入格式

第一行，两个整数$n,m$，分别表示两个秩序序列的长度。

接着第二行与第三行，两个字符串，表示两个秩序序列，长度分别为$n,m$。
## 输出格式

一行两个整数，用单个空格隔开，分别表示最强魔咒的长度与个数。
## 样例

### 样例输入 #1
```
6 7
aaabab
ababaaa
```
### 样例输出 #1
```
3 3
```
### 样例输入 #2
```
10 10
bbaabaaaac
bbaabaaaac
```
### 样例输出 #2
```
5 1
```
## 提示

**样例解释**

样例1：符合规定的魔咒有$a,b,aa,aaa,aba,bab$，其中最强的有$aaa,aba,bab$，长度为$3$，共$3$个。

样例2：符合规定的魔咒有$a,b,aa,aaa,aaaa,bb,baab,aba,aabaa,c$，其中最强的有$aabaa$，长度为$5$，共$1$个。

**数据范围**

由于某些原因，本题需要使用$Subtask$。为取得一个$Subtask$的得分，你需要通过此$Subtask$中的所有数据点。
|  | 分值 | $n,m$取值范围 | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $Subtask1$ | $0$ | $1\le n,m\le260817$ | 是样例 |
| $Subtask2$ | $5$ | $1\le n,m\le260817$ | 两个秩序序列由同一字符组成 |
| $Subtask3$ | $5$ | $1\le n,m\le10$ | 无 |
| $Subtask4$ | $10$ | $1\le n,m\le300$ | 无 |
| $Subtask5$ | $10$ | $1\le n,m\le2000$ | 无 |
| $Subtask6$ | $30$ | $1\le n,m\le260817$ | 两个秩序序列相同 |
| $Subtask7$ | $40$ | $1\le n,m\le260817$ | 无 |

显然，相同的魔咒数量只计一次。保证至少存在一个长度不小于$1$的符合规定的魔咒。

注意时限为$3s$。


---

---
title: "[JSOI2013] 快乐的 JYY"
layout: "post"
diff: 省选/NOI-
pid: P5685
tag: ['字符串', '2013', '各省省选', '江苏', '后缀自动机 SAM', '回文自动机 PAM']
---
# [JSOI2013] 快乐的 JYY
## 题目背景

JYY 在 JSOI 有很多很多的好朋友，比如 PUPPY，KFC 还有 PUPPUP 。因为
有了这么多的好朋友，所以 JYY 每天都很快乐。某天，JYY 发现好朋友之间关
系的好坏和名字有很大的关系，比如 PUPPY 和 PUPPUP 的关系就特别好，但是和 KFC 的关系就很一般。JYY 苦思冥想终于发现了其中的规律，现在 JYY 想知道两个朋友之间关系的好坏，你能帮助 JYY 么？
## 题目描述

给定两个字符串 $A$ 和 $B$，表示 JYY 的两个朋友的名字。我们用 $A(i,\,j)$ 表示 $A$ 
字符串中从第 $i$ 个字母到第 $j$ 个字母所组成的子串。同样的，我们也可以定义 $B(x,\,y)$ 。

JYY 发现两个朋友关系的紧密程度，等于同时满足如下条件的四元组 $(i,\,j,\,x,\,y)$
的个数：
1. $1\leq i\leq j\leq |A|$
2. $1\leq x\leq y\leq |B|$
3. $A(i,\,j)=B(x,\,y)$
4. $A(i,\,j)$ 是回文串

$|A|$ 表示字符串 $A$ 的长度。

JYY 希望你帮助他计算出这两个朋友之间关系的紧密程度。
## 输入格式

数据包行两行由大写字母组成的字符串 $A$ 和 $B$ 。

## 输出格式

包含一行一个整数，表示紧密程度，也就是满足要求的 $4$ 元组个数
## 样例

### 样例输入 #1
```
PUPPY
PUPPUP

```
### 样例输出 #1
```
17
```
## 提示

$1\leq |A|,\,|B|\leq 50000$


---

---
title: "[CTSC1998] 算法复杂度"
layout: "post"
diff: 省选/NOI-
pid: P5698
tag: ['模拟', '字符串', '1998', '栈', 'CTSC/CTS']
---
# [CTSC1998] 算法复杂度
## 题目背景

CTSC1998 D1T3

我们在编程时，最关心的一个问题就是算法的时间复杂度。但是分析一个程序的复杂度是一项很困难的工作，在程序的码风不是很好的情况下更是如此。

所以，专门研究算法的 SERKOI 小组决定开发出一个分析程序时间复杂度的软件。由于这是一个全新的领域，所以 SERKOI 小组决定先从简单情况入手进行分析。
## 题目描述

为了简化问题,程序只包含循环和顺序结构,程序的结构定义如下：

$\texttt{begin <statement> end}$ 

一个语句块的结构是**递归定义**的，如下所示：

$\texttt{loop x <statement> end}$

或者 $\texttt{op <statement>}$ 

或者为 $\texttt{break <statement>}$ 

或者为 $\texttt{continue <statement>}$ 

语句块可以为空。

注意：

1. 一个程序都是以 $\texttt{begin}$ 开始，以相应的 $\texttt{end}$ 结束；

2. $\texttt{loop x <statement> end}$ 表示其中的语句重复执行 $x$ 次；

3. $\texttt{op x}$ 表示执行 $x$ 个单位操作；

4. 上面两点中的 $x$ 可以是一个正整数或 $n$；

5. $\texttt{break}$ 语句的作用是跳出这一层循环, $\texttt{continue}$ 语句的作用是跳过这一层循
环的其它语句，直接进入下一次循环。如果它（$\texttt{break}$ 或 $\texttt{continue}$）不在任何一层循环中，**请忽略它们**。

你需要写一个程序，用来求出题目描述的程序的时间复杂度，并以多项式的形式输出。

注意，该多项式是关于 $n$ 的多项式，而且，**常数项和系数不能省略**。

数据保证能求出该程序的时间复杂度。
## 输入格式

输入中包含一个完整的程序，
每两条语句之间至少用一个空格或换行符隔开。

## 输出格式

将计算出的时间复杂度多项式按**降幂排列**输出。
## 样例

### 样例输入 #1
```
begin loop n loop 3 loop n
op 20
end end end
loop n op 3 break end
loop n loop n
op 1
break
end end
end

```
### 样例输出 #1
```
60n^2+n+3
```
### 样例输入 #2
```
begin
op n
loop 3
op n
break
end
loop n
loop n
op 1
continue
op n
end
end
end 
```
### 样例输出 #2
```
n^2+2n
```
## 提示

循环的嵌套最多不超过 $20$ 层。

保证最终时间复杂度多项式每项的系数不超过 ${10}^9$。


---

---
title: "【模板】Lyndon 分解"
layout: "post"
diff: 省选/NOI-
pid: P6114
tag: ['字符串', 'Lyndon 分解']
---
# 【模板】Lyndon 分解
## 题目描述

这是一道模板题。

读入一个由小写英文字母组成的字符串 $s$ ，请把这个字符串分成若干部分 $s=s_1s_2s_3\cdots s_m$，使得每个 $s_i$ 都是 [$\text{Lyndon Word}$](https://en.wikipedia.org/wiki/Lyndon_word)，且 $\forall 1\le i<m:s_i\ge s_{i+1}$。输出 $s_1$ 到 $s_m$ 这些串长度的右端点的位置。位置编号为 $1$ 到 $n$。

一个字符串 $s$ 是一个 $\text{Lyndon Word}$，当且仅当 $s$ 是其所有后缀中最小的字符串。

为了减小输出量，你只需要输出所有右端点的异或和。
## 输入格式

一行一个长度为 $n$ 的仅包含小写英文字母的字符串 $s$。
## 输出格式

一行一个整数，表示所有右端点的异或和。
## 样例

### 样例输入 #1
```
ababa

```
### 样例输出 #1
```
3

```
### 样例输入 #2
```
bbababaabaaabaaaab

```
### 样例输出 #2
```
23

```
## 提示

第一组样例的答案为 `2 4 5`。

第二组样例的答案为 `1 2 4 6 9 13 18`。

- 对于 $20\%$ 的数据，保证 $1\le n\le 1000$；
- 对于 $100\%$ 的数据，保证 $1\le n\le 5\times 10^6+1$。


---

---
title: "[JSOI2009] 有趣的游戏"
layout: "post"
diff: 省选/NOI-
pid: P6125
tag: ['字符串', '动态规划 DP', '2009', '高斯消元', 'AC 自动机']
---
# [JSOI2009] 有趣的游戏
## 题目描述

小阳阳发明了一个有趣的游戏：有 $n$ 个玩家，每个玩家都有一个长度为 $l$ 的字母序列，任何两个玩家的字母序列不同。共有 $m$ 种不同的字母，所有的字母序列都由这 $m$ 种字母构成。为了方便，我们取大写字母的前 $m$ 个字母。   
例如 $m=3,l=4,\texttt{ABAA}$ 和 $\texttt{CBCA}$ 是两个合法的字母序列。       
现在由小阳阳来操控一台神奇的机器，每个时刻机器会随机产生一个字母，其中第 $i$ 种字母随机出来的概率为 $\dfrac{p_i}{q_i}$ ，显然 $\sum \limits_{k=1}^m \dfrac{p_i}{q_i}=1$。  
这样 $T$ 个时刻后机器会产生一个长度为 $T$ 的字母序列。  
如果某个时刻某个玩家发现自己的字母序列在机器产生的字母序列中出现了，“出现”的定义是玩家的字母序列是机器产生的字母序列中连续的一段，那么我们称这个玩家获胜，游戏结束。       
现在小阳阳感兴趣的一个问题是，每个玩家分别有多大的概率能获得这场游戏的胜利呢？  
## 输入格式

第一行有三个正整数 $n,l,m$ 表示有 $n$ 个人，每个字母的序列长度均为 $l$，共有 $m$ 个字母。   
接下来 $m$ 行，每行有两个非负整数 $p, q$，表示随机到第 $i$ 个字母的概率为 $\frac{p}{q}$。   
接下来 $n$ 行，每行有一个长度为 $l$ 的字母序列，表示第 $i$ 个人的字母序列。
## 输出格式

包含 $n$ 行，每行一个实数，表示第 $i$ 个人获胜的概率，输出结果四舍五入到两位小数。 
## 样例

### 样例输入 #1
```
3 2 2
1 2
1 2
AB
BA
AA
```
### 样例输出 #1
```
0.25
0.50
0.25
```
### 样例输入 #2
```
3 4 2
1 2
1 2
AABA
ABAA
BAAA
```
### 样例输出 #2
```
0.31
0.33
0.37
```
## 提示

$1 \leq n,l,m \leq 10$，$0 \leq p_i \leq q_i \leq 10$ 且 $\gcd(p,q) = 1$。


---

---
title: "要有光"
layout: "post"
diff: 省选/NOI-
pid: P6396
tag: ['字符串', '动态规划 DP', '图论', '贪心', '2020', '倍增', '最短路', '回文自动机 PAM']
---
# 要有光
## 题目背景

$$ \text{Der mir zeigt wo ich bin}$$   
$$_\texttt{告诉我身在何方}  $$
$$\text{Divano}$$   
$$_\texttt{神啊}$$  
$$\text{Sei mein Licht}  $$
$$_\texttt{做我的光}$$
$$\text{Ich sm chte mich dir schenken}$$  
$$_\texttt{我愿将自己赐予与你}$$
$$\text{Noch vor dem Sonnenaufgang}$$  
$$_\texttt{在晨曦来临之前}$$


&emsp;&emsp;那时正值春深，丛林里生灵闹哄哄地雀跃，享受着空气中升腾的灵气。  
&emsp;&emsp;“嗖”的一声，一团银灰色的小东西突然从她眼前的地面划过，要不是腾起的尘土在阳光下悠闲地闪烁，她甚至怀疑是自己花了眼。  
&emsp;&emsp;紧接着，又“嗖”的一声，这次她看清楚了，是一只雪白的幼龄狐妖，“还……有点可爱。”  
&emsp;&emsp;“真走运，捉了这只，就可以交差啦。”她，虽年少却赫赫有名的除妖师，绫，急忙跟了上去。
## 题目描述

万物有灵，法术亦是如此。任何法术都等价为一段**仅包括大小写字母**的字符串 $S=s_1s_2\dots s_n$，现规定如下几种法术记号：

- **元素**。即字符串中的每个字符。在本题中，元素仅为大小写字母。
- **法术大小**。即字符串长度。记号为 $|S|$ 。
- **空法术**。大小为 $0$ 的法术为空法术。
- **等法术**。对于法术 $S,T$ 。当且仅当 $|S|=|T|,\forall i \leq |S| , s_i = t_i$ 时，称 $S$ 与 $T$ 为等法术，记为 $S=T$  。
- **逆法术**。设现有法术 $S=s_1s_2\dots s_n$，称法术 $T$ 是 $S$ 的逆法术，当且仅当 $|S|=|T|$ 且 $\forall i \leq |S| , s_i=t_{n-i+1}$。本题将 $T$ 记作 $S_r$。
- **逆法术对**。称两法术 $S$，$T$ 构成逆法术对 $(S,T)$，当且仅当 $T=S_r$。
- **归法术**。设现有法术 $S$，称 $S$ 为归法术当且仅当 $S$ 对应的字符串为**回文串**。特别地，**空法术被视作归法术**。
- **子法术**。设现有法术 $S$ ，则对于 $1\le i\le j\le |S|$ ，称 $T=s_is_{i+1}\dots s_j$ 为 $S$ 的子法术，并规定子法术的记号 $S[i,j]$ 。当 $i>j$ 时，$S[i,j]$ 为空法术。

---

现在，绫有一个法术源 $S_0$, 而她已经凝练出了一个初始的法术 $S=S_0$。对于每种妖魔，都有一个法术弱点  $T$。绫的法术性火，而火系法术又以淬光之术为上等。所以绫想要练习淬光之术。只要绫通过以下淬光法术变换使 $S=T$，就能轻易击败妖魔：

- **光归**。对于**任意非空法术** $S$，保留其**最大归法术后缀**。若$|S|=n$即取一个最小的 $i \in [1,n]$ 使得 $S[i+1,n]$ 为归法术，并令 $S \leftarrow T$。**允许 $T$ 为空法术**。消耗时间 $A$。
- **光辉**。对于**归法术** $S$，在 $S_0$ 中寻找一个**子归法术** $T$，满足 $S$ 为 $T$ 的**最大归法术后缀**（其定义见 "光归" ），并令 $S\leftarrow T$。**空法术**被认为是**任何法术的后缀**。消耗时间 $B$。
- **光隐**。对于**非空归法术** $S$，$|S|=n$ 删去其长度相等且长度**不大于 $k$ **的**前缀与后缀**。即取一个 $i\in[1,\min\{k,\lfloor\frac{n-1}2\rfloor\}]$，使 $T=S[1+i,n-i]$，并令 $S\leftarrow T$。特别地，$T$ **不可以为空法术**，消耗时间 $C$。
- **光腾**。对于**非空归法术** $S,|S|=n$，在其左右加上一对逆法术对。即取一逆法术对 $(P,Q)$，设 $|P|=|Q|=l$，使 $T=p_1p_2\dots p_ls_1s_2\dots s_nq_1q_2\dots q_l$，且 $T$ **须为 $S_{0}$ 的子法术** ，并令 $S\leftarrow T$。消耗时间 $D$。
- **光弋**。对于**任意非空法术** $S,|S|=n$ ，在其前端加入任意元素。即取一个元素 $a$，使 $T=as_1s_2\dots s_n$，并令 $S\leftarrow T$，消耗时间 $E$。光弋变换玄妙莫测，绫还没有熟练掌握此法术变换。所以**在使用此变换之后，无法再使用其它类型的法术变换**。

现在绫想知道，对于不同妖魔的法术弱点 $T$，自己至少要消耗多少时间进行如上法术变换使 $S=T$。**每组询问间互不干扰**。

## 输入格式

第一行输入一个**仅包含大小写字母**的字符串，表示绫的法术源 $S_0$。由题意，初始法术 $S=S_0$。  

第二行输入一个正整数 $k$，表示**光隐**变换所允许删去前缀后缀的最长长度。  

第三行输入五个正整数 $A,B,C,D,E$，表示每种法术变换的消耗时间。   

第四行一个正整数 $q$，表示询问组数。  

接下来 $q$ 行，每行包含两个正整数 $l,r$，表示一种妖魔的法术弱点为 $T=S_0[l,r]$。

## 输出格式

对于每个询问，输出一行一个整数，表示第 $i$ 个询问的答案。
## 样例

### 样例输入 #1
```
ababa
2
3 2 4 2 1
3
1 5
2 3
1 3
```
### 样例输出 #1
```
0
5
3
```
### 样例输入 #2
```
aaaaaa
1
3 1 4 1 10
2
2 4
2 3
```
### 样例输出 #2
```
7
8
```
## 提示

#### 样例解释 #1

对于第一个询问，因为 $T=\texttt{"ababa"}=S$，不需要操作。

对于第二个询问，$T=\texttt{"ba"}$，最优策略为先使用一次**光隐**，得到 $S'=\texttt{"a"}$；接着使用一次**光弋**，在 $S'$ 前添加元素 $\texttt{'b'}$ 得到 $S''=\texttt{"ba"}=T$，耗时 $4+1=5$。
 
对于第三个询问，$T=\texttt{"aba"}$，最优策略为使用一次**光归**，得到 $S'=\texttt{"aba"}=T$。耗时 $3$。

------------
#### 数据范围
对于不同的测试点，我们约定数据规模如下:

| 测试点编号 | $\left\vert S \right\vert,\left\vert T \right\vert \le$ | $q\le$ | 特殊限制 |
|:-:|:-:|:-:|:-:|
| $1 \sim 5$ | $10^3$ | $10^3$ | 无 |
| $6 \sim 9$ | $10^5$ | $10^5$ | 初始法术只有一种元素 |
| $10 \sim 20$ | $10^5$ | $10^5$ | 无 |

对于 $100\%$ 的数据，$1 \le q,|S| \leq 10^5$，$1 \leq A,B,C,D,E \leq 10^9$，$1 \leq l \leq r \leq |S|$，$1 \leq k \leq 5$。

------------
### 题目背景 ( 续 )
&emsp;&emsp;这边，绫还在摸索着变换法术，却感觉腰间的令牌被抓了一下。“喂？！”  
&emsp;&emsp;只见一个披头散发的少女正半跪着扒在她的腰间，左手还提着银灰色毛发的小兔子的一对耳朵，“你……是刚才那只狐狸？”绫尴尬地收回法术，不自觉地伸出手揉了揉少女头顶雪白的兽耳，心想着这只狐狸精得有多傻。“我可是除妖师哟，你不怕吗？”  
&emsp;&emsp;“……绫？”少女并没有理会绫的话，只是努力地认出了令牌上刻着的名字。  
&emsp;&emsp;绫好奇的目光撞上了少女璀璨的碧绿双眸，又不经意间扫过小巧的鼻梁，玲珑的小嘴，白皙的脖子，但再随着如凝的肌肤滑下……  
&emsp;&emsp;一直被视作男儿的绫哪见过这般风景，只觉得自己大脑当了机，还隐约嗅到出自鼻腔的铁锈味儿，身体便向后靠倒在一棵树干上，连忙用双手捂住滚烫的脸颊。  
&emsp;&emsp;“绫？绫？你怎么啦？！”少女心急地凑上去，绫吓得下意识往后退，却忘记身后是一棵粗壮的树干。“欸，绫手上的，是血吗……”双眼紧闭的绫听得出来少女像是被吓到了，看来还是一只没开过荤的狐狸精呢。  
&emsp;&emsp;“绫……你没事吧……”少女分明带着哭腔，小心翼翼地学着自己还是小狐狸的时候妈妈照顾自己的方式，在绫的身上东摸西摸。  
&emsp;&emsp;“我，我没事……”绫已经不敢想象究竟是哪些部位在触碰自己的皮肤了，“你……你先变回狐狸……快！”绫当然想把少女推开，却又怎么敢伸出手触碰少女呢？  
&emsp;&emsp;少女闻言，一怔，但还是乖乖变回了一只狐狸，还不忘叼起几欲逃走的兔子。  
&emsp;&emsp;绫赶忙收拾了自己的窘相，惊恐地扶着树干，确认自己的人身安全后，轻轻捏住小狐狸的后颈，提起在地上的两小只。  
&emsp;&emsp;“以后不许再胡乱变成人形了，听到没有！”绫后怕地警告着小狐狸，却见右手的小狐狸直勾勾地盯着左手的小兔子，而左手的小兔子好像想钻进自己的手心里，哪有听她的话呀……  
&emsp;&emsp;“哎，算了……”绫把小狐狸放在肩头，把似乎吓晕的小兔子递给她，“一会儿再吃哦。”（雨兔兔：我好难qwq。）  
&emsp;&emsp;“就算……捡了一只宠物吧。”绫心里想着。  

&emsp;&emsp;（未完待续www……）


---

---
title: "[SNOI2020] 字符串"
layout: "post"
diff: 省选/NOI-
pid: P6793
tag: ['字符串', '2020', '各省省选', '后缀自动机 SAM', '树形 DP', '后缀数组 SA']
---
# [SNOI2020] 字符串
## 题目描述

有两个长度为 $n$ 的由小写字母组成的字符串 $a,b$，取出他们所有长为 $k$ 的子串（各有 $n-k+1$ 个），这些子串分别组成集合 $A,B$。现在要修改 $A$ 中的串，使得 $A$ 和 $B$ 完全相同。可以任意次选择修改 $A$ 中一个串的一段后缀，花费为这段后缀的长度。总花费为每次修改花费之和，求总花费的最小值。
## 输入格式

第一行两个整数 $n,k$ 表示字符串长度和子串长度；   
第二行一个小写字母字符串 $a$；   
第三行一个小写字母字符串 $b$。
## 输出格式

输出一行一个整数表示总花费的最小值。
## 样例

### 样例输入 #1
```
5 3
aabaa
ababa
```
### 样例输出 #1
```
3
```
## 提示

#### 样例说明

对于样例 $1$，所有子串为：$A = \{aab,aba,baa\}, B = \{aba, bab, aba\}$。可以看出有一对 $aba$ 是相同的，另外要把 $aab$ 改成 $aba$（花费 $2$），$baa$ 改成 $bab$（花费 $1$），总花费为 $3$。

#### 数据规模与约定

对于所有数据，$1\le k\le n\le 1.5\times 10^5$。

- 对于 $10\%$ 的数据，$n \le 11$；
- 对于另外 $20\%$ 的数据，$n \le 200$；
- 对于另外 $20\%$ 的数据，$n \le 2000$；
- 对于另外 $10\%$ 的数据，字符串的每一位在小写字母中均匀随机；
- 对于余下 $40\%$ 的数据，无特殊限制。


---

---
title: "SvT"
layout: "post"
diff: 省选/NOI-
pid: P7409
tag: ['字符串', '图论', '后缀自动机 SAM', '虚树', '后缀数组 SA', '后缀树']
---
# SvT
## 题目背景

（我并不想告诉你题目名字是什么鬼）
## 题目描述

有一个长度为  $n$ 的仅包含小写字母的字符串  $S$，下标范围为  $[1,n]$。

现在有若干组询问,对于每一个询问,我们给出若干个后缀（以其在  $S$ 中出现的起始位置来表示），求这些后缀两两之间的 LCP（最长公共前缀）的长度之和。一对后缀之间的 LCP 长度仅统计一遍。



## 输入格式

第一行两个正整数  $n,m$，分别表示  $S$ 的长度以及询问的次数。

接下来一行有一个字符串  $S$。

接下来有  $m$ 组询问，对于每一组询问，均按照以下格式在一行内给出：

首先是一个整数  $t$，表示共有多少个后缀。接下来  $t$ 个整数分别表示  $t$ 个后缀在字符串  $S$ 中的出现位置。
## 输出格式

对于每一组询问，输出一行一个整数，表示该组询问的答案。由于答案可能很大，仅需要输出这个答案对于 $\text{23333333333333333}$ （一个巨大的质数）取模的余数。
## 样例

### 样例输入 #1
```
7 3
popoqqq
1 4
2 3 5
4 1 2 5 6
```
### 样例输出 #1
```
0
0
2
```
## 提示

样例解释:

对于询问一，只有一个后缀 `oqqq`，因此答案为 $0$。

对于询问二，有两个后缀`poqqq`以及`qqq`，两个后缀之间的 LCP 为 $0$，因此答案为 $0$。

对于询问三，有四个后缀 `popoqqq` , `opoqqq` , `qqq` , `qq`，其中只有 `qqq`，`qq` 两个后缀之间的LCP不为 $0$，且长度为 $2$，因此答案为 $2$。

对于 $100\%$ 的测试数据，有 $|S|\le 5\times 10^5$，且 $\sum t\le3\times10^6$。

特别注意:由于另一世界线的某些参数发生了变化，对于一组询问，即使一个后缀出现了多次，也仅算一次。

题目来源：bzoj 3879


---

---
title: "[CERC2018] The ABCD Murderer"
layout: "post"
diff: 省选/NOI-
pid: P7456
tag: ['字符串', '2018', '哈希 hashing', 'AC 自动机', 'KMP 算法', '后缀数组 SA', 'ICPC']
---
# [CERC2018] The ABCD Murderer
## 题目描述

**译自[ [CERC2018]](https://contest.felk.cvut.cz/18cerc/) [The ABCD Murderer](https://contest.felk.cvut.cz/18cerc/solved/abcd.pdf)**

Oscar 特别喜欢看犯罪电影。他钦佩那些罪犯，因为他们富有创造力。他也想展示他的创造力。但很可惜的是，他没什么经验，也想不出来什么原创伎俩。所以他想从已有的招数中寻找灵感。他一直喜欢看罪犯从报纸上剪下字母，然后用这些字母拼勒索信的桥段。然而 Oscar 根本不想抄袭，所以他自己想了一个这种方法的变体。他觉得把字母一个一个拼成文本既无聊又费时间。所以他决定通过剪下一整个单词的方式拼出自己的勒索信。

Oscar 买来一些主流报纸，这样他几乎就有了无限的单词库。他可以多次剪出任意特定的单词。然而，他还是被报纸中出现的的单词集限制。问题是一些单词根本没在报纸中出现。为了让这项工作更简单，他决定去除勒索信中所有的标点符号和空格并且忽略字母的大小写。他同时允许剪出的单词互相重叠，只需要重叠部分相同。现在 Oscar 想知道他至少要剪下多少次单词才能拼成他想要的勒索信。
## 输入格式

第一行包含一个整数 $L$，表示在报纸中发现的单词数；

下一行包含勒索信的内容 $s$。保证内容非空并且只包含小写英文字母。

接下来 $L$ 行，每行包含一个在报纸中出现的单词 $a_i$，保证只出现小写英文字母。这些单词中没有空串，也没有比勒索信长的单词。所有报纸中单词在输入中出现至少一次。
## 输出格式

输出 Oscar 最少要从报纸中剪下多少次单词才能组成勒索信、如果不能组成，输出 $-1$ 。每个单词都要被记实际从报纸剪下那么多次。
## 样例

### 样例输入 #1
```
3
aaaaa
a
aa
aaa
```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
5
abecedadabra
abec
ab
ceda
dad
ra
```
### 样例输出 #2
```
5
```
### 样例输入 #3
```
9
icpcontesticpc
international
collegiate
programming
contest
central
europe
regional
contest
icpc
```
### 样例输出 #3
```
3
```
## 提示

$1≤L,|s|,∑|a_i|≤3×10^5$


---

---
title: "「不死鸟附体」"
layout: "post"
diff: 省选/NOI-
pid: P9211
tag: ['字符串', 'Special Judge', '随机化', '传智杯']
---
# 「不死鸟附体」
## 题目背景

死而复生，生而复死。所谓的不死鸟就是这样的一种生物，在无尽的时间里无尽地循环往复。

果然最好还是别获得不老不死的能力吧。
## 题目描述

不死鸟的「一生」可以被看成一个长度不超过 $l_{\max}$ 的字符串 $S_0$。在无尽的轮回后形成了一个无限长的字符串 $S_{\mathrm{inf}}=S_0+S_0+S_0+\cdots$。现在截取 $S_{\mathrm{inf}}$ 前 $l$ 个字符，作为可观测时间里不死鸟的生命 $S_{\mathrm{fin}}$。

然而所谓的轮回并不是机械死板的循环往复。因此，$S_\mathrm{fin}$ 当中会有**不超过 $n$ 个字符**被修改成了别的字符，变成了 $S_{\mathrm{real}}$。

现在观测到了 $S_{\mathrm{real}}$，我们希望找到这轮回的周期 $S_0$。然而由于不死鸟的轮回太过漫长，我们只希望找到这样一个 $S_0'$，使得由它生成的 $S_\mathrm{fin}'$ 修改**不超过 $m$ 个字符**后就可以变成 $S_{\mathrm{real}}$。

## 输入格式

第一行有四个正整数 $l,l_{\max},n,m$。

第二行描述观测到的长度为 $l$ 的字符串 $S_{\mathrm{real}}$。
## 输出格式

第一行输出一个正整数 $l_0$，表示你所找到的 $S_0$ 的长度。你应当保证 $1\le l_0\le l_{\max}$。

第二行输出一个长度为 $l_0$ 的字符串 $S_0$，表示你所找到的字符串。
## 样例

### 样例输入 #1
```
25 8 5 10
aaacdaabbbaabccaabcdaabcd

```
### 样例输出 #1
```
5
aaacd
```
## 提示

### 样例解释

样例仅供理解题意，**不符合数据范围的约束**。具体约束请参见「数据范围及约定」。

生成 $S_{\mathrm{real}}$ 所用的 $S_0=\verb!aabcd!$。

- 由此生成 $S_{\mathrm{inf}}=\verb!aabcdaabcdaabcdaabcdaabcd!\cdots$；
- 由此生成 $S_{\mathrm{fin}}=\verb!aabcdaabcdaabcdaabcdaabcd!$；
- 由此生成 $S_{\mathrm{real}\kern{-2.5pt}}=\verb!aaacdaabbbaabccaabcdaabcd!$。

样例输出给出了一个可能的 $S_0'=\verb!aaacd!$。由此计算出 $S_{\mathrm{fin}}'$ 与 $S_{\mathrm{real}}$ 的差距：

$$\begin{aligned}
S_{\mathrm{fin}}'=&\texttt{aaacdaa\textcolor{red}a\textcolor{red}c\textcolor{red}daa\textcolor{red}ac\textcolor{red}daa\textcolor{red}acdaa\textcolor{red}acd}\cr
S_{\mathrm{real}}=&\texttt{aaacdaabbbaabccaabcdaabcd}\cr
\end{aligned}$$

相差为 $7$，不超过 $m=10$，可以被接受。

### 数据范围及约定

对于全部数据，保证 $l=3\times 10^5$，$n=3\times 10^3$，$m=10^4$，$1\le l_{\max} \le 10^5$。


---

---
title: "[NFLSPC #6] 啊，忘记了。"
layout: "post"
diff: 省选/NOI-
pid: P9935
tag: ['字符串', '线段树', 'O2优化', '哈希 hashing', '虚树', '字典树 Trie', 'AC 自动机']
---
# [NFLSPC #6] 啊，忘记了。
## 题目背景

> 好像忘了什么事…… 算了，想必不是什么重要的事吧。
## 题目描述



你在你的电脑上发现了 $n$ 份文本。冥冥之中，你没来由地感觉这似乎全都是一份记录的复制。

- 首先，原始记录是一个长度未知（甚至可以为空）的字符串，称作 **记录串**。对于一份复制，其将记录串切成了三段 **可以为空** 的字符串 **片段**。**每份复制中切割方案不保证相同**。你暂且将这三份 **片段** 依次称作 **前面**，**中间** 和 **后面**。
- 某些复制中的某些片段可能被忘记了。具体而言，前面有可能被替换为 `QIANMIANWANGLE`，中间有可能被替换为 `ZHONGJIANWANGLE`，后面有可能被替换为 `HOUMIANWANGLE`；在发生替换的场合，表示这一段片段被 **完全遗忘** 了；否则，表示该片段被 **完整保存**。
- 你有一种预感，记录串中的所有字符都是 **小写英文字符**。
- $n$ 份复制不一定自洽。

你的目标是，寻找初始的记录串。这个记录串需要满足所有字符均是小写英文字符。你希望其匹配尽量多的复制串。

- 记录串与复制串匹配的要求是，存在记录串的一种划分，使得其中记录串的三段与复制串的三段分别相同，或者复制串中这段划分忘了（此时本段划分中，记录串为任何可以为空的小写英文字符串均合法）。

你希望求出该记录串能匹配的最多复制串数目。**至于记录串本身，你感觉它并不是很重要，所以你不需要求出它**。

> / 我，毋畏遗忘 /
## 输入格式

**为了避免输入过大，输入进行了一定程度的压缩。请务必认真阅读输入格式**。

第一行一个正整数 $n$，表示记录数目。

接下来 $n$ 行，每行三个非空字符串，其中第一段要么是非空小写字符串，要么是 `Q`（表示 `QIANMIANWANGLE`），要么是 `E` 表示这是一段空串（因为空串不可见所以选取 `E` 作为占位符），不存在其它可能；第二段则是非空小写字符串、`Z`（表示 `ZHONGJIANWANGLE`）、`E` 三者之一；最后一段是非空小写字符串、`H`（表示 `HOUMIANWANGLE`）、`E` 三者之一。
## 输出格式

一行一个整数，表示所有记录串中，能匹配的最多的复制的数目。

## 样例

### 样例输入 #1
```
3
nflsalgo Z H
Q nflspc H
Q Z qidong

```
### 样例输出 #1
```
3

```
## 提示

### 样例 1 解释

你希望这个串是 `nflsalgonflspcqidong`。你确信，不会再有其它串比它更匹配现存的记录了。

### 数据范围与约定

对于所有数据，保证输入的所有字符串长度之和不超过 $5\times 10 ^ 5$。

- 子任务 1（$30$ 分）：保证所有复制的 “后面” 段都是 `H`。
- 子任务 2（$70$ 分）：无特殊限制。

Source：NFLSPC #6 K by Troverld


---


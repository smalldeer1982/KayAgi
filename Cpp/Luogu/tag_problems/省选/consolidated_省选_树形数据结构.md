---
title: "[NOIP 2012 提高组] 疫情控制"
layout: "post"
diff: 省选/NOI-
pid: P1084
tag: ['贪心', '树形数据结构', '2012', '倍增', '二分', 'NOIP 提高组', '排序']
---
# [NOIP 2012 提高组] 疫情控制
## 题目描述

H 国有 $n $ 个城市，这 $n$ 个城市用 $ n-1 $ 条双向道路相互连通构成一棵树，$1 $ 号城市是首都，也是树中的根节点。

H 国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。

## 输入格式

第一行一个整数 $ n$，表示城市个数。

接下来的 $n-1$ 行，每行 $ 3 $ 个整数，$u,v,w$，每两个整数之间用一个空格隔开，表示从城市 $u $ 到城市 $ v$ 有一条长为 $w$ 的道路。数据保证输入的是一棵树，且根节点编号为 $1$。

接下来一行一个整数 $m$，表示军队个数。

接下来一行 $m $ 个整数，每两个整数之间用一个空格隔开，分别表示这 $m$ 个军队所驻扎的城市的编号。

## 输出格式

一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出 $-1$。

## 样例

### 样例输入 #1
```
4 
1 2 1 
1 3 2 
3 4 3 
2 
2 2
```
### 样例输出 #1
```
3
```
## 提示

【输入输出样例说明】

第一支军队在 $2$ 号点设立检查点，第二支军队从 $2$ 号点移动到$ 3$ 号点设立检查点，所需时间为 $3$ 个小时。

 
【数据范围】

保证军队不会驻扎在首都。

- 对于 $20\%$ 的数据，$2 \le n\le 10$；
- 对于 $40\%$ 的数据，$2 \le n\le 50$，$0<w <10^5$；
- 对于 $60\%$ 的数据，$2 \le n\le 1000$，$0<w <10^6$；
- 对于 $80\%$ 的数据，$2 \le n\le 10^4$；
- 对于 $100\%$ 的数据，$2\le m\le n≤5\times 10^4$，$0<w <10^9$。


NOIP 2012 提高组 第二天 第三题



---

---
title: "树"
layout: "post"
diff: 省选/NOI-
pid: P1411
tag: ['动态规划 DP', '树形数据结构', '福建省历届夏令营']
---
# 树
## 题目背景

L 发明了一种与树有关的游戏。
## 题目描述

他从树中删除任意数量（可以为 $0$）的边，计算删除后所有连通块大小的乘积，L 将得到这么多的分数。

你的任务就是对于一颗给定的树，求出 L 能得到的最大分数。

## 输入格式

第一行一个整数 $n$，表示树的节点个数。

接下来 $(n-1)$ 行，每行两个整数 $u, v$，代表存在一条连接 $u, v$ 的边。

## 输出格式

输出一行一个整数，表示 L 能得到的最大分数。

## 样例

### 样例输入 #1
```
5
1 2
2 3
3 4
4 5

```
### 样例输出 #1
```
6

```
### 样例输入 #2
```
8
1 2
1 3
2 4
2 5
3 6
3 7
6 8

```
### 样例输出 #2
```
18

```
### 样例输入 #3
```
3
1 2
1 3 

```
### 样例输出 #3
```
3 

```
## 提示

#### 数据规模与约定

- 对于 $10\%$ 的数据，保证 $n \leq 5$。
- 对于 $30\%$ 的数据，保证 $n \leq 100$。
- 另有 $30\%$ 的数据，保证给出的树是一条链。
- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 700$，$1 \leq u, v \leq n$。



---

---
title: "[CEOI 2007] 树的匹配 Treasury"
layout: "post"
diff: 省选/NOI-
pid: P1623
tag: ['动态规划 DP', '高精度', '树形数据结构', '2007', 'CEOI（中欧）']
---
# [CEOI 2007] 树的匹配 Treasury
## 题目描述

给一棵树，你可以匹配有边相连的两个点，问你这棵树的最大匹配是多少，并且计算出有多少种最大匹配。
## 输入格式

第一行一个整数 $N$，表示有多少个结点。

接下来 $N$ 行，每行第一个整数，表示要描述的那个结点。然后一个整数 $m$，表示这个结点有 $m$ 个儿子，接下来 $m$ 个整数，表示它的 $m$   个儿子的编号。
## 输出格式

输出两行，第一行输出最大匹配数，第二行输出最大匹配方案数。

## 样例

### 样例输入 #1
```
7
1 3 2 4 7
2 1 3
4 1 6
3 0
7 1 5
5 0
6 0
```
### 样例输出 #1
```
3
4
```
## 提示

$1\leq N\leq 10^3$，其中 $40\%$ 的数据答案不超过 $10^8$。


---

---
title: "[NOI2011] 阿狸的打字机"
layout: "post"
diff: 省选/NOI-
pid: P2414
tag: ['字符串', '树形数据结构', '2011', 'NOI', '深度优先搜索 DFS', 'AC 自动机']
---
# [NOI2011] 阿狸的打字机
## 题目描述

阿狸喜欢收藏各种稀奇古怪的东西，最近他淘到一台老式的打字机。打字机上只有 $28$ 个按键，分别印有 $26$ 个小写英文字母和 `B`、`P` 两个字母。经阿狸研究发现，这个打字机是这样工作的：

* 输入小写字母，打字机的一个凹槽中会加入这个字母(这个字母加在凹槽的最后)。
* 按一下印有 `B` 的按键，打字机凹槽中最后一个字母会消失。
* 按一下印有 `P` 的按键，打字机会在纸上打印出凹槽中现有的所有字母并换行，但凹槽中的字母不会消失。

例如，阿狸输入 `aPaPBbP`，纸上被打印的字符如下：

```
a
aa
ab
```

我们把纸上打印出来的字符串从 $1$ 开始顺序编号，一直到 $n$。打字机有一个非常有趣的功能，在打字机中暗藏一个带数字的小键盘，在小键盘上输入两个数 $(x,y)$（其中 $1\leq x,y\leq n$），打字机会显示第 $x$ 个打印的字符串在第 $y$ 个打印的字符串中出现了多少次。

阿狸发现了这个功能以后很兴奋，他想写个程序完成同样的功能，你能帮助他么？

## 输入格式

输入的第一行包含一个字符串，按阿狸的输入顺序给出所有阿狸输入的字符。

第二行包含一个整数 $m$，表示询问个数。

接下来 $m$ 行描述所有由小键盘输入的询问。其中第 $i$ 行包含两个整数 $x, y$，表示第 $i$ 个询问为 $(x, y)$。

## 输出格式

输出 $m$ 行，其中第 $i$ 行包含一个整数，表示第 $i$ 个询问的答案。

## 样例

### 样例输入 #1
```
aPaPBbP
3
1 2
1 3
2 3
```
### 样例输出 #1
```
2
1
0
```
## 提示

### 数据范围

对于 $100\%$ 的数据，$1\leq n\leq 10^5$，$1\leq m\leq10^5$，第一行总长度 $\leq 10^5$。

|测试点|$n$ 的规模|$m$ 的规模|字符串长度|第一行长度|
|:-:|:-:|:-:|:-:|:-:|
|$1,2$|$1\leq n\leq 100$|$1\leq m\leq 10^3$| - |$\leq 100$|
|$3,4$|$1\leq n\leq 10^3$|$1\leq m\leq 10^4$|单个长度 $\leq 10^3$，总长度 $\leq 10^5$|$\leq 10^5$|
|$5\sim 7$|$1\leq n\leq 10^4$|$1\leq m\leq 10^5$|总长度 $\leq 10^5$|$\leq 10^5$|
|$8\sim 10$|$1\leq n\leq 10^5$|$1\leq m\leq 10^5$| - |$\leq 10^5$|




---

---
title: "泡芙"
layout: "post"
diff: 省选/NOI-
pid: P2416
tag: ['图论', '树形数据结构', '洛谷原创', '洛谷月赛']
---
# 泡芙
## 题目背景

此题空间限制 $256$ MB，保证系统栈空间与内存限制大小相同。
## 题目描述

火星猫经过一番努力终于到达了冥王星。他发现冥王星有 $N$ 座城市，$M$ 条无向边。火星猫准备出发去找冥王兔，他听说有若干泡芙掉落在一些边上，他准备采集一些去送给冥王兔。但是火星猫的火星光环和冥王星相生相克，当火星猫走过一条路之后，这条路就不能再走了。如果冥王兔吃不到泡芙，他们就不能嘿嘿嘿了。所以告诉你火星猫和冥王兔的位置，请问冥王兔能不能吃到泡芙。
## 输入格式

第一行 $N,M$ 表示点数和边数。

接下来 $M$ 行每行 $X,Y,Z$ 表示 $X$ 到 $Y$ 有一条无向边，$Z=1$ 表示有泡芙，$Z=0$ 表示没有

接下来一行是 $Q$，表示有 $Q$ 组询问。

每行 $S,T$ 表示火星猫和冥王兔的位置。
## 输出格式

对于每组询问输出 `YES` 或 `NO`。
## 样例

### 样例输入 #1
```
6 7
1 2 0
2 3 0
3 1 0
3 4 1
4 5 0
5 6 0
6 4 0
1
1 6
```
### 样例输出 #1
```
YES
```
## 提示

|  测试点编号  |     $N \le $      |     $M \le $      |     $Q \le $      |    特殊性质    |
| :----------: | :---------------: | :---------------: | :---------------: | :------------: |
|  $1 \sim 4$  |      $1000$       |       $N-1$       | $5 \times 10 ^ 4$ | 保证图是一棵树 |
|  $5 \sim 8$  | $3 \times 10 ^ 5$ |       $N-1$       | $3 \times 10 ^ 5$ |       无       |
| $9 \sim 10$  |       $20$        |       $50$        |        $5$        |       无       |
| $11 \sim 14$ |      $1000$       |      $5000$       | $5 \times 10 ^ 4$ |       无       |
| $15 \sim 20$ | $3 \times 10 ^ 5$ | $3 \times 10 ^ 5$ | $3 \times 10 ^ 5$ |       无       |

保证图联通。


---

---
title: "树的数量"
layout: "post"
diff: 省选/NOI-
pid: P2767
tag: ['动态规划 DP', '图论', '树形数据结构', '洛谷原创']
---
# 树的数量
## 题目描述

求出包含 $n$ 个节点（无标号）的有根 $m$ 叉树的个数，对 $10\,007$ 取模。

两个有根树相同，当且仅当其根节点相同，且**从左到右**每一棵子树也相同。特别地，两个有根树均为空树，视为两个有根树相同。
## 输入格式

输入两个整数 $n$，$m$。

## 输出格式

输出包含 $n$ 个节点（无标号）的有根 $m$ 叉树的个数，对 $10\,007$ 取模后的值。
## 样例

### 样例输入 #1
```
2 2
```
### 样例输出 #1
```
2
```
## 提示

$n,m \leq 127$


---

---
title: "[POI 2005] SZA-Template"
layout: "post"
diff: 省选/NOI-
pid: P3426
tag: ['树形数据结构', '2005', '平衡树', 'POI（波兰）', 'KMP 算法']
---
# [POI 2005] SZA-Template
## 题目描述

你打算在纸上印一串字母。

为了完成这项工作，你决定刻一个印章。印章每使用一次，就会将印章上的**所有**字母印到纸上。

同一个位置的相同字符可以印多次。例如：用 `aba` 这个印章可以完成印制 `ababa` 的工作（中间的 `a` 被印了两次）。但是，因为印上去的东西不能被抹掉，在同一位置上印不同字符是不允许的。例如：用 `aba` 这个印章不可以完成印制 `abcba` 的工作。

因为刻印章是一个不太容易的工作，你希望印章的字符串长度尽可能小。
## 输入格式

输入一个长度不超过 $5 \times 10^5$ 的非空字符串（只包含小写字母），代表要在纸上印的字符。
## 输出格式

输出一个整数，代表印章上字符串长度的最小值。
## 样例

### 样例输入 #1
```
ababbababbabababbabababbababbaba
```
### 样例输出 #1
```
8
```
## 提示

印章为 `ababbaba`。

印制过程如下：

```plain
ababbababbabababbabababbababbaba
ababbaba
     ababbaba
            ababbaba
                   ababbaba
                        ababbaba
```


---

---
title: "[POI 2011] INS-Inspection"
layout: "post"
diff: 省选/NOI-
pid: P3525
tag: ['动态规划 DP', '树形数据结构', '2011', 'POI（波兰）']
---
# [POI 2011] INS-Inspection
## 题目描述

The railway network of the Byteotian Railways (BR) consists of bidirectional    tracks connecting certain pairs of stations.

Each pair of stations is connected by at most one segment of tracks.

Furthermore, there is a unique route from every station to every other station.

(The route may consist of several segments of tracks, but it may not pass through any station more than once.) Byteasar is an undercover inspector of the BR.

His job is to pick one of the stations (denote it by $S$) for centre of his operations and to travel to all other stations.

His journey should be as follows:

Byteasar starts in station $S$.

Next, he picks one of the stations he did not yet control and goes to it along the shortest path (by train, of course), inspects the station, and        then goes back to $S$.

The crooked employees of BR warn one another of Byteasar's comings.

To deceive them, Byteasar picks the next station for control in such a way that he sets off from the station $S$ in different direction than the last time, i.e., along a different segment of tracks leaving from $S$.

Each station (except $S$) is inspected exactly once.

After inspecting the last station Byteasar does not come back        to $S$.

The travel time along every segment of tracks takes the same amount of time:

one hour.

Byteasar intends to consider all the stations as the initial station $S$.

For each of them he wants to know the order of inspecting the remaining stations that minimises the total travel time, provided that it is possible at all for that particular $S$.


## 输入格式

The first line of the standard input contains a single integer $n$($1\le n\le 1\ 000\ 000$) that denotes the number of stations.

These are numbered from 1 to $n$.

The following $n-1$ lines specify the track segments, one per line.

Each of them holds two integers $a,b$ ($1\le a,b\le n$, $a\ne b$),      separated by a single space, indicating that there is a track segment      connecting the stations $a$ and $b$.

Each track segments appears exactly once in the description.

In tests worth at least 30% of the points it holds additionally that $n\le 2\ 000$.

## 输出格式

Your program should print $n$ lines on the standard output,each holding a single integer.

The one in the $i$-th line should be the minimum number of hours Byteasar has to spend travelling to inspect the stations when $S=i$ - if inspecting them all is possible for $S=i$;if it is not, the $i$-th line should hold the number $-1$.

## 样例

### 样例输入 #1
```
9
3 6
2 4
2 6
2 5
1 7
2 7
8 9
7 8
```
### 样例输出 #1
```
-1
23
-1
-1
-1
-1
-1
-1
-1
```
## 提示



## 题目翻译

一棵 $n$ 个节点的树，行动中心 $S$ 从 $1$ 至 $N$。从 $S$ 出发前往任意一个未标记到的点（沿树上两点的唯一路径走），标记该节点，然后返回 $S$。相邻两次行动所经过的道路不允许有重复，最后一次标记后不需要返回，求路程总和的最小值。

第 $i$ 行输出行动中心为 $i$ 时的答案，如果不可能则输出 $-1$。


---

---
title: "【XR-4】复读"
layout: "post"
diff: 省选/NOI-
pid: P5597
tag: ['树形数据结构', '洛谷月赛']
---
# 【XR-4】复读
## 题目背景

**赛时提醒：当机器人在这棵完全二叉树的根时，执行 `U` 是非法的，即你需要保证不可能出现这种情况。**

**赛时提醒：这棵二叉树是无限向下延伸的，即所有节点均有左子节点与右子节点，除了根的所有节点均有父亲。**
## 题目描述

小 X 捡到了一台复读机，这台复读机可以向机器人发号施令。机器人将站在一棵完全二叉树的根上，完全二叉树是无限延伸的。你将向复读机录入一串指令，这串指令单个字符可以是：

* `L`：命令机器人向当前节点的左子走；
* `R`：命令机器人向当前节点的右子走；
* `U`：命令机器人向当前节点的父亲走（若没有，则命令非法）。

录入指令后，复读机将会把指令无限复读下去。比如命令为 `LR`，那么机器人会遵从 `LRLRLRLR...` 一直走下去。

这棵完全二叉树上有一个 $n$ 个节点的连通块，保证这个连通块包含根节点。连通块上的每个节点都埋有宝藏，机器人到达过的地方如果有宝藏，则会将其开采。如果一个地方没有宝藏，机器人也可以到那里去。机器人也可以反复经过一个地方。

显然，这个连通块本身也是一棵二叉树。

现在，有人告诉了小 X 埋有宝藏的这棵二叉树的前序遍历，小 X 需要寻找到一条尽量短的指令，使得机器人能够挖掘出所有宝藏。
## 输入格式

一行一个字符串，由 `0123` 中的字符组成，表示埋有宝藏的这棵二叉树的前序遍历。

* `0`：表示这是一个没有儿子的节点。
* `1`：表示这是一个只有左子的节点。
* `2`：表示这是一个只有右子的节点。
* `3`：表示这是一个既有左子又有右子的节点。
## 输出格式

一个整数，表示最短指令的长度。
## 样例

### 样例输入 #1
```
1313000

```
### 样例输出 #1
```
3

```
### 样例输入 #2
```
333003003300300

```
### 样例输出 #2
```
15

```
## 提示

【样例 1 说明】

一种可行的最短指令为 `LRU`。

---

**本题采用捆绑测试。**

- Subtask 1（31 points）：$2 \le n \le 10$。
- Subtask 2（32 points）：$2 \le n \le 200$。
- Subtask 3（37 points）：无特殊限制。

对于 $100\%$ 的数据，$2 \le n \le 2 \times 10^3$。


---

---
title: "ygg发神威"
layout: "post"
diff: 省选/NOI-
pid: P5647
tag: ['树形数据结构', '线段树', '二分', '平衡树', 'O2优化', '枚举', '排序']
---
# ygg发神威
## 题目背景

ygg 发神威了，机房的萌新们瑟瑟发抖。
## 题目描述

ygg 的机房内共有 $n$ 台电脑且都被使用，为了节省机房内电脑的开销，第 $i$ 台电脑会同时被 $a_i$ 个萌新使用。每台电脑都装有一个「多人在线交流平台」，一台电脑会直接地或间接地通过这个平台与其他所有电脑连接。由于「多人在线交流平台」仍然处于测试阶段，如果一台电脑有多于一种不同的消息传输方式将消息传输到另外的任意一台电脑，就会有各种稀奇古怪的问题产生。两种消息的传输方式被认为是不同的，当且仅当传输消息所经过的直接连接的线路的集合不同，或者传输所经过的电脑的集合不同。当然，消息的传输肯定不会经过一条线路多次。为了避免这种状况，「多人在线交流平台」的线路被特殊地设计了，以使得任意两台电脑之间的传输线路唯一。同时，为了防止一台电脑负荷过大，一台电脑最多会通过「多人在线交流平台」的线路与 $p$ 台电脑相连。

原本两台通过「多人在线交流平台」的线路相连的电脑之间可以相互传输数据，可是 ygg 发现，这会允许使用两台电脑的萌新们互相发送消息，引起大规模~~考试作弊~~膜拜 ygg 的行为。所以他大发神威，切断了所有连接线路的一半。具体地，他将原本通过「多人在线交流平台」的双向线路连接的两台电脑之间的线路变成了单向线路。即，原本通过一条双向线路连接的两台电脑中，只能有一台电脑向另一台电脑发送消息，而另一台电脑不能将任何消息发送回来。

机房内的萌新们在每个时刻都有若干条消息需要传递。如果一台电脑 $i$ 能够直接或间接地通过「多人在线交流平台」的线路连接到电脑 $j$，那么使用电脑 $i$ 的 $a_i$ 个萌新中的任何一个都可以向使用电脑 $j$ 的 $a_j$ 个萌新发送消息。显然，使用同一台电脑的萌新之间的消息只需要在线下传达，不需要使用「多人在线交流平台」，因此不会计入线上发送的消息。

其实机房中的萌新们早已知道了「多人在线交流平台」的管理员密码，所以能够对其线路的连接方向做出修改。可无论他们怎么尝试，都不能恢复最开始时双向连接的状态了。机房中的萌新们当然希望能够尽可能地发送消息，所以他们想要知道，在机房的电脑仅被单向的线路连接时，每一时刻最多能有多少条消息被通过「多人在线交流平台」发送。

为了简化问题，我们假设机房内的所有萌新均能够在同一时刻发送线上消息，并且每一个萌新可以同时向多个人发送消息。

**简要题面：给一棵结点编号** $1\sim n$**，结点权值** $a_i$**，且结点度数最大为** $p$ **的树。求将树的每条边改为有向边后下式的最大值：**

$$\sum_{i=1}^{n}\sum_{j=1}^{n}a_ia_j\left[i\rightarrow j\right]$$

$\left[i\rightarrow j\right]$ **定义为：若编号为** $i$ **的结点能通过有向边到达编号为** $j$ **的结点，则值为** $1$**；否则值为** $0$**，且** $\left[i\rightarrow i\right]=0$**。**
## 输入格式

输入共 $(n+1)$ 行。

第一行两个正整数 $n$ 和 $p$，分别代表机房内的电脑数与所有电脑的负荷的最大值。  
第二行共 $n$ 个正整数，第 $i$ 个整数 $a_i$ 为使用第 $i$ 台电脑的萌新的数量。  
接下来 $(n-1)$ 行，第 $(i+2)$ 行两个整数 $u_i,v_i$ ，表示第 $u_i$ 和 $v_i$ 台电脑之间原本有一条「多人在线交流平台」的双向线路。
## 输出格式

输出一行一个整数，表示在某一时刻能够发送的消息数的最大值。
## 样例

### 样例输入 #1
```
4 2
1 2 3 4
1 2
3 2
4 1

```
### 样例输出 #1
```
35

```
## 提示

### 样例解释

能够发送的消息最多时的消息传递方向如下：

![](https://i.loli.net/2019/10/30/3AsqcyzdY25E8gP.png)

在该连接方式下发送消息最多的时刻，使用 $1$ 号电脑的 $1$ 个萌新向 $5$ 个萌新各发送了一条消息，共 $1\times5=5$ 条消息；  
使用 $2$ 号电脑的 $2$ 个萌新分别向 $3$ 个萌新各发送了一条消息，共 $2\times3=6$ 条消息；  
使用 $3$ 号电脑的 $3$ 个萌新不能向任何萌新发送线上消息，因此没有消息从该电脑发送；  
使用 $4$ 号电脑的 $4$ 个萌新分别向 $6$ 个萌新各发送了一条消息，共 $4\times6=24$ 条消息。  
因此，在某一时刻，最多可以有 $5+6+24=35$ 条线上消息被发送。   
可以使用枚举法验证，不存在一种单向的连接方式，使得在某一时刻发送的线上消息的数量能够达到 $36$ 条或更多。

### 数据范围及约定

对于 $10\%$ 的数据，$n\le10$；  
对于另外 $10\%$ 的数据，$n=p+1$；  
对于另外 $10\%$ 的数据，$p=2$；  
对于另外 $10\%$ 的数据，$p\le20$；  
对于另外 $10\%$ 的数据，$p\le40$；  

对于所有数据，$2\le n\le10^5$，$2\le p\le50$，$1\le a_i\le100$，$1\le u_i,v_i\le n$。保证给出的双向连接线路能够使任意两台电脑之间的消息传输线路唯一。保证至少有一台电脑原本通过「多人在线交流平台」连接的线路数恰好为 $p$，且没有电脑原本连接的线路数大于 $p$。


---

---
title: "[Ynoi2010] Fusion tree"
layout: "post"
diff: 省选/NOI-
pid: P6018
tag: ['树形数据结构', '2010', 'O2优化', '字典树 Trie', 'Ynoi']
---
# [Ynoi2010] Fusion tree
## 题目背景

题目背景和题意无关，可以跳过

## 1.前言：
Fusion Tree，中文译作融合树，是一种亚log的数据结构，与1993年由Michael L.Fredman和Dan E.Willard提出。

用途：$O( \log n/ \log w+ \log w )$时间复杂度支持插入，删除，前驱，后继，min，max，以及用于整数排序。

信息论断言对$n$个数的排序在最坏情况下需要$n\log n$次比较，不过对这个界我们还需要一些研究。

有人证明了任意unit cost RAM算法，其中只包含加法，减法，乘法，和0比较（但是不包含除法和位运算）最坏情况下需要$\Omega(n\log n)$的时间去对$n$个数排序。

如果允许使用除法和位运算，他们有一个线性时间复杂度的算法，但是这个算法对unit cost滥用。

这里我们规定我们使用的计算模型的字长是w，每个输入的数都是在$[0,2^w-1]$中的整数。

## 2.一些记号：
对于一个集合$S$和一个整数$x$，定义$rank(S,x)$为S集合中$\le x$的元素个数。
对于一些非负整数$a$，定义$bin(a_1,...,a_n)=2^{a_i}+...+2^{a_n}$。

对于两个非负整数$a,b$，定义$msb(u,v)$为$u$和$v$最高的不相同的位。

## 3.概述：
Fusion Tree大概可以看做是一棵特殊的B-Tree，特性：

1. 叉数$B=O(w^{1/5})$

2. 在一次搜索时，每个在搜索路径上的节点的正确的儿子可以被$O(1)$确定

从这些特性我们可以看出Fusion Tree单次操作的时间复杂度是$O( \log _w(n) + \log w) = O( \log n/\log w +\log  w)$的，比$O( \log n )$低。

但是由于其实现方式，Fusion Tree每次对内部节点的更新复杂度是$O( B^4 )$的。
为了控制Fusion Tree均摊的更新复杂度，我们将这棵B-Tree的每对叶子节点之间的部分替换为一个大小大约为$O( B^4 )$的Weight Balanced Tree，只在WBT根节点发生变化的时候更新Fusion Tree的内部节点。

具体来说，我们B-Tree维护的是一个排序后的数组的分块，其中每个块都由一棵平衡二叉搜索树维护，fusion tree上只维护一个值来表示块边界，用途是指引每次插入，删除，查询在哪个块中。

可以发现这样我们把内部节点的变化次数除掉了一个$B^4$。

## 4.压缩key的表示：

如何$O(1)$确定搜索路径上的一个节点的正确的儿子：

考虑一个B-Tree的节点，其上面包含了$k$个key，其中$B/2 \le k \le B$，记作$S={u_1,u_2,...u_k}$。

然后我们定义出$B(S)$表示"有区别的位的位置"，用人话来说就是我们把这$k$个key的trie建出来，然后所有有超过$1$个儿子的节点的高度构成的集合
（当然这里我们不用把trie建出来，只是这么解释比较直观，而且更能反映出其的一些性质）。

再定义一个集合$K(S)$，为$S$只保留$B(S)$中那些位之后的值，记作$K(S)={u'_1,u'_2,...u'_k}$，发现这个压缩操作对于原集合是保序的。

对于一个任意的$w-bit$的数$u$，我们记$u'(S)$表示$u$只保留$B(S)$中那些位，即把非$B(S)$中的位都置为$0$之后的值。

下面引理表达了一个压缩key的重要性质：

### 引理1：
设$B(S)$排序后为$c_1<c_2<...<c_r$，定义边界$c_0=-1,c_{r+1}=b$。

定义$u'_i$为$K(S)$中任意的一个压缩后的key。

对于一个任意的$w-bit$的数$u$，满足$u \neq u_i$，

设$msb(u'(S),u'_i)=c_m$，即$u$和$u_i$在bit位置$c_{m+1},...,c_r$位置处相等，但是在$c_m$处不相等，如果$u'(S)=u'_i$，则我们记$m=0$。

如果$u$和$u_i$不同的最高位$p$满足$p>c_m$，那么我们可以通过：

1. 唯一的一个区间$[c_{j-1},c_j]$满足$p$属于这个区间

2. $u$和$u_i$的大小关系

来确定$rank(S,u)$的值。

证明平凡，把trie画出来，显然可以画成一个平面图，然后可以发现这两个可以唯一地确定出一个平面区域，这个区域中的$S$集合元素个数就是$rank(S,u)$（感觉这种东西光写一堆自然语言也不能说明正确性，需要形式化证明一下？）。

注意到这个引理虽然是对任意$u_i$成立的，但是要求$u$和$u_i$不相同的最高位不是$B(S)$中的一个点，可以发现这个$u_i$其实必须在$u$"脱离"这个trie的位置，也就是$p$的父亲子树中。

引理$1$使得我们可以将$rank(S,u)$的计算规模降低到$rank(K(S),u'(S))$，通过计算$rank(K(S),u'(S))$，我们可以确定$u'(S)$在$K(S)$中的前驱后继$u'_j$和$u'_{j+1}$（这两个值不一定存在，但经过平凡的讨论就可以解决。

如果$u_j \le u \le u_{j+1}$，那我们已经解决了这个问题
否则我们令$i=j$或者$i=j+1$，计算出$msb(u_i,u)=p$，然后只要我们知道了包含$p$的区间$[c_j,c_{j+1}]$，我们就可以通过引理$1$来确定出$rank(S,u)$的值。

这里如果我们$u_j \le u \le u_{j+1}$，那我们已经达成了目的，不用继续考虑了。

否则如果不满足$u_j \le u \le u_{j+1}$，也就是说我们在这个sketch的过程中丢失了信息，即说明保留$K(S)$这些位的信息是不够的，那么$p$一定不在$K(S)$中，也就是说$i=j$和$i=j+1$中$p$较小的$i$满足$p>c_m$，故可以使用引理$1$。

计算$K(S)$和$u'(S)$：
我们发现没有平凡的方法可以将一个$w-bit$的数$u$在$O(1)$时间把$B(S)$那些位提取出来之后放到连续的一段中（可能可以通过硬件支持实现？），即使经过了一定预处理。

其实我们不需要做到这个，可以用具有：

1. 将需要提取出的位提取出，并放到（可以不连续）的更短的一段中

2. 保序性

的其他变化来实现我们需要的效果。

我们可以通过一次恰当的乘法和一次与运算来实现这个：

沿用引理$1$的定义，设我们需要从$u$中提取这些位，令$C=bin(c_1,...,c_r)$。

假设我们已经算出了$C$，我们先通过令$v=u\;\mathrm{AND}\;C$来将$u$中不需要的那些位置$0$。

然后我们将$v$乘以一个量$M$，从而把$v$中我们需要的那些$bit$转化到一个狭窄的范围内，然后再通过一次$\mathrm{AND}$来清除掉不需要的位置
这里给出对一个量$M$的存在性证明和构造：

记$M=bin(m_1,...,m_r)$，如果我们暂时忽略交叉和进位造成的影响，那么可以认为$v$乘$M$是把$c_1,...c_r$这些位置的位重新定位到了。

$c_1+m_1,...,c_r+m_r$上。

如果对任意$1 \le i,j \le r$，这$r^2$个$c_i+m_j$都是不同的，那么就不会发生交叉和进位了。

我们现在的目标是构造一个整数集合${m_1,...,m_r}$，使得：

1. $c_1+m_1<c_2+m_2<...<c_r+m_r$

2. 对任意$1 \le i,j \le r$，$c_i+m_j$都是两两不同的。

3. 变换后的区间$[c_1+m_1,c_r+m_r]$"相对较小"，这里的相对较小其实只要是$O( poly(r) )$的即可，因为这样我们可以通过调整树的叉数来满足后续的条件。

### 引理2：

给一个$r$个整数的序列，$c_1<...<c_r$，存在一个$r$个整数的序列，$m_1,...m_r$，满足：

1. $c_1+m_1<c_2+m_2<...<c_r+m_r$

2. 对任意$1 \le i,j \le r$，$c_i+m_j$都是两两不同的。

3. $(c_r+m_r)-(c_1+m_1) \le r^4$

证明：

先考虑证明存在整数序列$m'_1,...,m'_r$，使得对任意$i,j,a,b$，$m'_i+c_a$与$m'_j+c_b$在模$r^3$的意义下不同余。

如果我们找到了这样的整数序列，那么所有$r^2$个$c_i+m'_j$都是两两不同的，并且由于这个是在模$r^3$意义下两两不同的，所以我们可以对第$i$个$c_i+m'_i$加上$(i-1)*r^3$，这样就可以保证对所有$i$满足$c_i+m'_i<c_{i+1}+m'_{i+1}$了。

关于$m'_1,...,m'_r$的存在性：

使用数学归纳法来证明，显然我们可以找到$m'_1$，这个平凡。

假设结论对$t$成立，即我们已经找到了$m'_1,...,m'_t$，满足对任意$1 \le i,j \le t$，$a,b$,有$m'_i+c_a$与$m'_j+c_b$在模$r^3$的意义下不同余。
可以观察到$m'_{t+1}+c_i \equiv m'_s+c_j (\mod r^3\;)$，即$m'_{t+1} \equiv m'_s+c_j-c_i (\mod r^3\;)$。


我们可以令$m'_{t+1}$是$[0,r^3)$中最小的和所有$m'_s+c_j-c_i$不同余的数，这里$1 \le s \le t,1 \le i,j \le r$。

由鸽巢原理，由于$t*r^2<r^3$，所以我们一定可以找到$m'_{t+1}$。

故当$t+1 \le s$时，结论对$t+1$成立
由数学归纳法知结论对$s$成立，同时我们这里给出了一个暴力的$O( r^4 )$的构造算法（$r$轮，每轮最坏枚举$O( r^3 )$个位置）。

## 5.融合：
融合树的"融合"即指将每个节点上的key放到同一个$w-bit$的word上，通过对这个word进行运算来一起处理这些key。

沿用之前$u_i$和$B(S)=\{c_i\}$的记号：

我们这个B-Tree的每个节点存了$C=bin(c_1,...c_r)$和$M=bin(m_1,...,m_r)$这两个量，用于计算$u'(S)$，同时还存了$D=bin(c_1+m_1,...,c_r+m_r)$这个量，用于清空$u'(S)$的计算中不需要的位。

同时还需要两个数组，存排序后的$u_i$和$u'_i$，和一个表$f[i][j][2]$表示引理$1$中，如果知道了$u_i$和$j$，还有$u$和$u_i$的大小关系，我们唯一确定的答案是多少。

回顾之前的内容，当我们算出了$j=rank(K(S),u'(S))$后，如果$u$不在$[u_j,u_{j+1}]$的区间中，那么我们把$u'(S) \;\mathrm{XOR}\; u'_j$和$u'(S) \;\mathrm{XOR}\; u'_{j+1}$比较一下，较小的值所对应的$u'_h$，$h=j$或$j+1$，和$u$有更长的公共前缀，即$msb$更小。

令$m=msb(u,u_h)$，然后我们需要知道$m$被哪个$B(S)$中的区间$[c_i,c_{i+1}]$包含，所以需要进行一次$i=rank(B(S),m)$的计算
还需要进行一次$u$和$u_h$的比较，这个平凡，当这些都做完了，我们查一下表$f$即可得到$rank(S,u)$。

可以发现fusion tree的每个内部节点需要存下$O( B^2 )$大小的表，内部节点个数是$O( n/B^4 )$个，所以是$O( n )$空间的。

下面给出对

1. $rank(K(S),u'(S))$

2. $rank(B(S),m)$，其中$m$是在$[0,w]$中的整数

3. 两个$w-bit$的整数$u,v$，$msb(u,v)$

的计算方法：

### $O(1)$计算$rank(K(S),u'(S))$：
我们把每个$K(S)$中的元素前面补一个$1$，然后从小到大拼到一起来，这个拼起来的操作就是所谓的"融合"。

由于我们$K(S)$中有$k$个元素，每个元素有$r^4$位，所以这里总共用了$k(r^4+1)$位，由于$B/2 \le k \le B$，所以我们总的位数是$O( B^5 )$的，由于$B=O( w^{1/5} )$，所以总的位数是$O( w )$的。

所以我们拼起来的这个东西是$O( 1 )$个word的，这里将其定义为$A$。

令$C=\sum \limits _{i = 0} ^ {B} 2^{(r^4+1)i}$
通过$u'(S) \times C$，可以将$u'(S)$前面补一个$0$之后复制$B$遍，然后拼到一起
通过$A-u'(S) \times C$，可以发现对每个$A$中补$1$的位置，其对应的那个$u_i(S)$如果$<u'(S)$，则这个$1$变成$0$，否则$1$不变
所以我们通过$(A-u'(S) \times C)\&C$，然后对这个word数$1$的个数即可知道$rank(K(S),u'(S))$。

由于这个word只在$2^{(r^4+1)i}$这样的位置有$1$，我们可以通过一次对$2^{r^4+1}-1$的取模来得到其中$1$的个数，虽然对常数取模可以用乘法和位运算$O(1)$实现，但我们这里可以给出一个更合适的构造。

我们可以通过将其乘$C \& (2^{(r^4+1)k}-1)$，这样相当于把其叠加了$k$次之后加起来，可以发现其中有一个长为$r^4+1$的段，这段的二进制表示的值等于这个word在$2^{(r^4+1)i}$这些位置的元素的和。

通过位移和$\mathrm{AND}$我们可以取出这个长$r^4+1$的段，于是就完成了。

答案即$((((A-u'(S) \times C) \& C) \times (C \& (2^{(r^4+1)k}-1))) \& C)>>((k(r^4+1)-1)$

### $O(1)$计算$rank(B(S),m)$，$m$是在$[0,w]$中的整数：

由于我们可以$O(1)$计算$rank(K(S),u'(S))$，所以把这个查出来然后判断那一个数的大小，并且进行一次查表即可。

### $O(1)$计算$msb(u,v)$：
等价于求$u \;\mathrm{XOR}\; v$的最高位$1$的位置，设$A=u \;\mathrm{XOR}\; v$。

我们将$A$分为$r^c$大小的块，总共$r$块，这里$c$是一个常数,$c>1$
令$C=(100...0100...0......)_2$，这里每两个$1$之间有$r-1$个$1$，$C$是一个常数。

注意到：

$((100...0)_2-0)\&(1<<(r^c)-1)=(1<<(r^c)-1)$

$((100...0)_2-y)\&(1<<(r^c)-1)=0$，这里$y>0$

先考虑对每个块去掉首位，块内是否有$1$。

我们用$A\& \sim C$可以去掉每一块的首位。

然后用$C-(A\& \sim C)$可以使得每一块中除首位外如果有$1$，则其在该块首位为$0$，否则为$1$。

然后用$(C-(A\& \sim C))\&C$去掉了$C-(A\& \sim C)$中每一块中除首位外的部分。

然后用$(C-((C-(A\& \sim C))\&C))$可以得到：如果一块中除首位外有$1$，则块首位为$1$，否则为$0$，且块首位外所有位置都是$0$的一个数
再考虑对每个块只保留首位，块内是否有$1$。

这个用$A\&C$即可。

最后$(A\&C)|(C-((C-(A\& \sim C))\&C))$可以得到：如果一块中有$1$，则块首位为$1$，否则为$0$，且块首位外所有位置都是$0$的一个数。

令$D= \sum \limits _{k=0}^{r-1} 2^{k(r^c-1)}$，

通过$(((A\&C)|(C-((C-(A\& \sim C))\&C))) \times D)>>(w-r)$可以将每块首位的数字拼到一个长$r$的二进制数中。

然后我们可以使用前面的$O(1)$计算$rank$的方法，令$B'(S)={2^i}$，$i$在$[0,r-1]$间，是整数。

通过$rank(B'(S),(((A\&C)|(C-((C-(A\& \sim C))\&C))) \times D)>>(w-r))$就可以得到这个长$r$的二进制数中第一个非0的首位的位置了。

我们知道了第一个非$0$位在哪个块中，然后查这个块里面第一个非$0$位的位置就可以了。

由于我们每个块是$r^c$的大小，所以对一个大小为$r^c$，包含了$2^i$的集合用一次rank即找到了块内第一个非$0$的首位位置。

取$c=4,r=w^{1/5}$，$r^c=w^{4/5}$，我们便$O(1)$查询，$O(w^{4/5})$预处理时间复杂度解决了这个问题，由于预处理次数是$O( n/B^4 )$，所以这里也是线性的。

综上所述，我们得到了一个单次操作复杂度$O( \log n/\log w + \log w )$的数据结构，这里**据说**可以通过一些优化做到$O( \log n/\log w )$，但在这里由于我还没看所以暂时不做介绍。

## 6.一些拓展
如果我们允许下列中的一个：

1. 放松线性空间的限制

2. 保留线性空间的限制，但是使用随机化和整数除法

那么我们可以得到一个$O( \sqrt{ \log n } )$的动态搜索的时间复杂度上界。

当$n$超过$2^{(\log w)^2/36}$时（这里$1/36$的常数是论文中给出的，由于我的部分细节和论文中不同，可能是不同的常数），

对于1的case，可以通过使用vEB树来实现，对于2的case，可以通过使用Y-fast trie实现。

对于这样的$n$，这两个数据结构可以在$O( \log \log U )=O( \log w )=O( \sqrt{\log n} )$的时间完成一次搜索操作。

当$n$小于这个数时，

对于较小的$n$，我们使用fusion tree，通过调节$B=Θ(2^ {\sqrt{\log n}})$。

在这个$B$下，我们的时间复杂度是$O( \log n/\log B + \log B ) = O( \sqrt{\log n} )$。

综上所述，如果引入随机化和整数除法，可以$O( n \sqrt{\log n} )$时间，线性空间整数排序。

## 7.总结
由信息论可以证明基于比较的排序下界是$\Omega( n\log n )$的，但整数排序其实是非常复杂的一个问题，还有待研究。
## 题目描述

魔法森林里有一颗大树，下面经常有小孩召开法。

大树可以看做一个有 $n$ 个节点，$n - 1$ 条边的无向连通图。大树的每个节点都有若干瓶矿泉水，初始第 $i$ 个节点有 $a_i$ 瓶矿泉水。

麦杰斯住在大树顶端，有一天他想改造一下大树，方便他巨大多喝水之后可以垃圾分类矿泉水瓶。

麦杰斯喜欢二进制运算，所以他会有以下三种操作：

1. 将树上与一个节点 $x$ 距离为 $1$ 的节点上的矿泉水数量 $+1$。这里树上两点间的距离定义为从一点出发到另外一点的最短路径上边的条数。
2. 在一个节点 $x$ 上喝掉 $v$ 瓶水。
3. 询问树上与一个节点 $x$ 距离为 $1$ 的所有节点上的矿泉水数量的异或和。

麦杰斯共有 $m$ 次操作，他希望你在每次 $3$ 操作后告诉他答案。
## 输入格式

第一行两个正整数 $n,m$，分别表示树的节点个数和麦杰斯的询问个数。

第二行到第 $n$ 行，每行两个整数表示有一条连接这两个节点的边。

第 $n + 1$ 行 $n$ 个整数，第 $i$ 个整数表示初始第 $i$ 个节点上的矿泉水数量。

第 $n + 2$ 行到第 $n + m + 1$ 行，每行先读入一个整数 $opt$ 表示操作类型。

如果 $opt = 1$ 或 $3$ ，接下来读入一个整数 $x$ 表示麦杰斯操作的节点标号。

否则接下来读入两个整数 $x, v$ 表示麦杰斯操作的节点标号和他喝的水的数量。
## 输出格式

对于每一个 $3$ 操作，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
3 2
1 2
2 3
1 1 4
1 1
3 2
```
### 样例输出 #1
```
5
```
## 提示

Idea：dangxingyu，Solution：dangxingyu，Code：dangxingyu，Data：dangxingyu

对于 $30\%$ 的数据，满足 $n \le 10^3$，$m\le 10^3$。

对于 $60\%$ 的数据，满足 $n \le 10^5$，$m \le 10^5$。

对于另外 $10\%$ 的数据，存在一个点满足所有点到该节点的距离 $\le 1$。

对于 $100\%$ 的数据，满足 $1\le n \le 5\times 10^5$，$1\le m \le 5\times 10^5$，$0\le a_i \le 10^5$，$1 \le x \le n$，$opt\in\{1,2,3\}$。

保证任意时刻每个节点的矿泉水数非负。

温馨提示：矿泉水瓶不是干垃圾也不是湿垃圾，而是可回收垃圾。



---

---
title: "『MdOI R2』Resurrection"
layout: "post"
diff: 省选/NOI-
pid: P6383
tag: ['动态规划 DP', '树形数据结构', '构造', '洛谷月赛']
---
# 『MdOI R2』Resurrection
## 题目背景

如果你不清楚本题的某些定义，可以阅读【说明/提示】部分。
## 题目描述

有一棵包含 $n$ 个节点的树 $T$，它的所有边依次编号为 $1$ 至 $n-1$。

保证对于 $T$ 中任意一个节点 $u$ ，从 $u$ 到 $n$ 号节点的简单路径都不经过任何编号小于 $u$ 的节点。

按照如下步骤生成一张包含 $n$ 个节点的无向图 $G$：

选取一个 $1 \sim n-1$ 的排列 $p$，然后依次进行 $n-1$ 次操作。在进行第 $i$ 次操作时，首先删除树 $T$ 中编号为 $p_i$ 的边 $(a,b)$，然后，记 $u$ 和 $v$ 分别为当前树 $T$ 中与 $a,b$ 联通的所有点中，编号最大的点，并在图 $G$ 的 $u$ 号点和 $v$ 号点之间连一条边。

求对于给定的树 $T$，按上述方式一共可以生成多少种本质不同的图 $G$。图 $G_1$ 和 $G_2$ 本质不同当且仅当存在 $u$ 和 $v$ 满足在 $G_1$ 中不存在边 $(u,v)$，而 $G_2$ 中存在。 

因为答案可能很大，你只需要求出答案对 $998244353$ 取模的值。

## 输入格式

第一行一个整数 $n$，表示树 $T$ 中的节点数量。

接下来 $n-1$ 行，第 $i$ 行两个整数 $u,v$，表示在 $T$ 中编号为 $i$ 的边是 $(u,v)$。
## 输出格式

一行一个整数，答案对 $998244353$ 取模的值。
## 样例

### 样例输入 #1
```
4
1 4
2 3
3 4

```
### 样例输出 #1
```
2
```
### 样例输入 #2
```
11
1 4
2 6
3 11
4 6
5 6
6 7
7 9
8 9
9 10
10 11

```
### 样例输出 #2
```
4605
```
## 提示

【帮助与提示】

为方便选手测试代码，本题额外提供一组附加样例供选手使用。  

[样例输入](https://www.luogu.com.cn/paste/09anxo5k) [样例输出](https://www.luogu.com.cn/paste/3idipkty)      

---

【样例解释】

样例一中可能生成的图 $G$ 如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/aaq591b7.png)

当 $p = \{1,2,3\},\{2,1,3\},\{2,3,1\}$ 时将生成右侧的图，否则将生成左侧的图。

对于样例二，我有一个绝妙的解释，只可惜这里空白的位置太小，写不下。

---

【数据范围】

**本题采用捆绑测试。**

对于全部数据，保证 $1 \leq n \leq 3 \times 10^3$，$1 \leq u,v \leq n$。

保证，输入的边形成一棵树，且对于任意一个节点 $u$ ，从 $u$ 到 $n$ 号节点的简单路径都不经过任何编号小于 $u$ 的节点。

| 子任务编号 | $n\leq$ |         特殊性质          | 分值 |
| :--------: | :-----: | :-----------------------: | :--: |
| Subtask 1  |   $5$   |            无             | $32$ |
| Subtask 2  |  $14$   |            无             | $16$ |
| Subtask 3  | $10^3$  | 所有节点都与 $n$ 号点直接相连 | $1$  |
| Subtask 4  | $10^3$  |     树的形态是一条链      | $7$  |
| Subtask 5  |  $50$   |            无             | $22$ |
| Subtask 6  | $3 \times 10^3$  |            无             | $22$ |

---

下面是本题用到的一些定义：

- 一棵树是一张有 $n$ 个节点，$n-1$ 条边的无向连通图。

- 边 $(u,v)$ 表示连接点 $u$ 和点 $v$ 的一条边。

- 一条路径是一个序列 $p_1,p_2 \ldots p_k$ ，满足对于任意 $1 \leq i < k$，边 $(p_i,p_{i+1})$ 都存在于 $T$ 中，且 **没有被之前的操作删除**。

- 点 $u$ 和 $v$ 联通当且仅当存在一条路径 $p_1,p_2 \ldots p_k$ 满足 $p_1=u$ 且 $p_k=v$。任何一个点都和自己联通。






---

---
title: "[YsOI2020] 造林"
layout: "post"
diff: 省选/NOI-
pid: P6653
tag: ['树形数据结构', 'O2优化', '树形 DP', '哈希 hashing']
---
# [YsOI2020] 造林
## 题目背景

「承前」

Ysuperman 响应号召，决定在幼儿园外造林。

呐呐，如果这样的话，Ysuperman 便能在这炎热的夏天与小朋友们玩游戏了呢。
## 题目描述

为了落实环保工作，Ysuperman 购进了一批树，它们都长一个样。由于树还没有种下去，所以这些树还没有根，可以认为是**无根树**。

Ysuperman 觉得全都种长得一样的树太无聊了，于是 TA 请到了园艺公司帮 TA 规划。园艺公司提供给了 TA 一个方法——「嫁接」。

下面给出「嫁接」操作的定义：

定义「叶子节点」为树上度数为 $1$ 的节点。
 
「嫁接」操作指：在一棵**无根树**上接入一个新的「叶子节点」。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/jfaksqwy.png)

图 2 是由图 1 的树进行一次合法的嫁接操作后得到的树，图 3 也是由图 1 的树进行一次合法的嫁接操作后得到的树。

那么，我们还知道，树有一个基本属性：「品种」。

一棵树的「品种」是指**每个点的最大子树大小所构成的可重集**。

两棵树的「品种」不同，当且仅当**每个点的最大子树大小所构成的可重集不同**。

这里的一个点的**最大子树大小**指将这个点删掉后**最大的联通块所包含的点数**。

例如：  
![](https://cdn.luogu.com.cn/upload/image_hosting/zzyznfl7.png)

图 4 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 5 的树的每个点的最大子树大小所构成的可重集为：$ \{ 2,2,3,3 \} $  
图 6 的树的每个点的最大子树大小所构成的可重集为：$ \{ 1,3,3,3 \} $  
所以说，图 4 的树与图 5 的树「品种」相同，与图 6 的树「品种」不同。

Ysuperman 想知道，通过一次「嫁接」操作，可以构造出的树包含多少不同的「品种」，以及对于每个「品种」，有多少不同的「嫁接」方法可以构造。请**从小到大**输出每个「品种」的「嫁接」方法数。

两个「嫁接」方案不同，当且仅当在「嫁接」操作中与新接入的「叶子节点」直接相连的点不同。

## 输入格式

第一行一个数 $n$ 。  
接下来 $n-1$ 行，每行两个数 $u,v$ 表示 $u,v$ 之间有一条**无向边**。
## 输出格式

第一行一个数 $cnt$，表示可以构造出的树包含多少不同的「品种」。  
第二行到第 $cnt+1$ 行，**从小到大**输出每个「品种」的「嫁接」方法数。
## 样例

### 样例输入 #1
```
5
1 2
2 3
3 4
4 5

```
### 样例输出 #1
```
3
1
2
2

```
### 样例输入 #2
```
7
1 2
1 3
2 4
2 5
3 6
3 7

```
### 样例输出 #2
```
3
1
2
4

```
### 样例输入 #3
```
25
15 9
22 15
23 22
25 15
13 23
6 22
12 15
1 23
19 13
18 9
11 15
17 1
4 25
3 1
8 9
20 1
10 18
21 20
16 8
2 22
24 1
7 19
5 16
14 7

```
### 样例输出 #3
```
17
1
1
1
1
1
1
1
1
1
1
2
2
2
2
2
2
3

```
## 提示

**本题采用捆绑测试。**
### 样例解释 1
可以构造出 1 种「品种」为 $\{2,4,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,5,5,5\}$ 的树。  
可以构造出 2 种「品种」为 $\{3,3,4,4,5,5\}$ 的树。
### 样例解释 2
可以构造出 1 种「品种」为 $\{3,5,5,7,7,7,7,7\}$ 的树。  
可以构造出 2 种「品种」为 $\{4,4,5,7,7,7,7,7\}$ 的树。  
可以构造出 4 种「品种」为 $\{4,4,5,6,7,7,7,7\}$ 的树。


对于 100% 的数据，满足 $1 \le n\le2\cdot 10^6$。

定义「链」为所有节点度数不超过 $2$ 的树。  
定义「菊花」为包含 $n-1$ 个「叶子节点」的树。

特殊性质 1：保证树的形态为一条「链」。  
特殊性质 2：保证树的形态为一朵「菊花」。  
特殊性质 3：保证树的形态为一棵完全二叉树。

| subtask | $n$ | 特殊性质 | 分值 | 时间限制 |
| :-----------: | :-----------: | :-----------: | :--------:| :---------:|
| 1 | $\le 2\cdot 10^6$ | 2 | 2 | 4s |
| 2 | $\le 2\cdot 10^6$ | 1 | 3 | 4s |
| 3 | $\le 300$ | 无 | 5 | 1s |
| 4 | $\le 2\cdot10^6$ | 3 | 7 | 4s |
| 5 | $\le 5000$ | 无 | 23 | 1s |
| 6 | $\le 5\cdot10^4$ | 无 | 29 | 2s |
| 7 | $\le 2\cdot10^6$ | 无 | 31 | 4s |

### 提示：

如果你不知道完全二叉树是什么意思，Ysuperman 提供了一个链接：[Link](https://zh.wikipedia.org/zh/%E4%BA%8C%E5%8F%89%E6%A0%91#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91)。

输入输出较大，请使用较快的输入输出方式。

如果您使用了所需栈空间较大的递归算法，可以在本地（NOI linux 下）先使用 ```sudo su``` 获取权限，再使用 ```ulimit -s unlimited ``` 命令开启无限栈。

题目并不难。


---

---
title: "「PMOI-4」可怜的团主"
layout: "post"
diff: 省选/NOI-
pid: P7320
tag: ['搜索', '图论', '树形数据结构', 'Special Judge', 'O2优化', '深度优先搜索 DFS', '构造', '洛谷月赛']
---
# 「PMOI-4」可怜的团主
## 题目描述

lnlhm 被塞给了一张 $n$ 个点 $m$ 条边的**简单无向连通**图。很快，他就被 ducati 和 b6e0 盯上了。

ducati 希望能够从中找到**恰好** $\left \lceil \frac n 6 \right \rceil$ 条**不同**的路径，使得所有的点都被至少一条路径经过。

b6e0 希望找到一个大小**恰好**为 $\lfloor \frac n 3 \rfloor$ 的节点集合，使得它们之间**两两没有边**。

lnlhm 知道，如果他没有满足某个人的要求，那么他就会被揍。因此，他向你求助：是否存在一种选择边或点的方案，使得**最多被一个人揍**？
## 输入格式

第一行两个正整数 $n,m$，表示点数以及边数。

下面 $m$ 行，每行两个点 $u,v$，描述一条**无向边**。
## 输出格式

若想要满足 ducati 的需求，在第一行输出 $1$，并在下面的 $\left \lceil \frac {n} 6 \right \rceil$ 行中，每行输出一条路径，你需要保证这些路径两两不同（例如，不能同时输出 $5 \to 3 \to 1$ 和 $1 \to 3 \to 5$）。输出一条路径的格式如下：

- 先输出一个正整数 $k(1\le k\le n)$，表示路径经过的节点数。

- 接下来 $k$ 个正整数，表示路径上的点，点之间用空格隔开。你需要保证，每相邻两个点之间有连边，不存在一个点被**某条**路径经过不少于两次，且每个点均被至少一条路径经过。

若想要满足 b6e0 的需求，在第一行输出 $2$，并在第二行中输出 $\lfloor \frac n 3 \rfloor$ 个点表示选出的独立集，之间用空格隔开。

特别的，若两个人的要求一个也无法满足，那么输出一行 `Poor lnlhm!`。
## 样例

### 样例输入 #1
```
6 7
1 2
1 3
2 3
2 5
4 5
5 6
4 6
```
### 样例输出 #1
```
2
1 4
```
### 样例输入 #2
```
6 6
1 2
2 3
3 4
4 5
5 6
1 6
```
### 样例输出 #2
```
1
6 1 2 3 4 5 6
```
## 提示

【样例解释】

对于第一组样例，我们只需要为 b6e0 选出节点集合 $\{1,4\}$ 即可。注意，$\{1,5\}\{1,6\}\{2,4\}\{2,6\}\{3,4\}\{3,5\}\{3,6\}$ 同样合法。

对于第二组样例，我们只需要为 ducati 选出路径 $1 \to 2 \to 3 \to 4 \to 5 \to 6$ 即可。

【数据范围】

**本题采用捆绑测试**。

- Subtask 1（20pts）：$n,m\le10$。
- Subtask 2（20pts）：保证图为一棵树。
- Subtask 3（60pts）：无特殊限制。

对于 $100\%$ 的数据满足，$3\le n\le10^3$，$3\le m\le\dfrac{n(n-1)}2$，保证给定的图为简单无向连通图。

**温馨提示: 输入量较大，请使用较快的读入方式。**


---

---
title: "「PMOI-1」中位数"
layout: "post"
diff: 省选/NOI-
pid: P7357
tag: ['树形数据结构', '二分', 'O2优化', '可持久化线段树', '可持久化']
---
# 「PMOI-1」中位数
## 题目描述

给定一棵以 $1$ 为根的包含 $n$ 个节点的**有根树**。第 $i$ 个节点有点权 $a_i$。

定义函数 $f(u,v)$ 表示从 $u$ 到 $v$ 经过的所有节点的点权的**可重集**的中位数。

请注意，**本题中的中位数的定义与数学中的定义略有不同**：这里一个长度为 $t$ 的序列的中位数定义为这个序列第 $\left\lceil\frac{t+1}2\right\rceil$ 小的数。

定义函数 $\text{cover}(x_1,y_1,x_2,y_2)$ 表示从 $x_1$ 到 $y_1$ 的路径是否完全覆盖了从 $x_2$ 到 $y_2$ 的路径。如果完全覆盖，则 $\text{cover}(x_1,y_1,x_2,y_2)=1$，否则  $\text{cover}(x_1,y_1,x_2,y_2)=0$。

你需要依次处理 $q$ 次操作，按照以下格式给出：

`1 u`：表示一次操作，需要你将点 $u$ 的点权对 $1$ **异或**；

` 2 u v`：表示一次询问，需要你求出 $\max\limits_{1\le i\le n,1\le j\le n}\{\text{cover}(i,j,u,v)f(i,j)\}$。

对于第二类操作，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$。

你需要对于每个第二类操作，输出对应的值。
## 输入格式

第一行两个正数 $n$ 和 $q$ ，分别表示树的节点数与询问次数。

第二行 $n$ 个整数，第 $i$ 个数表示第 $i$ 个节点的点权 $a_i$。

下面 $n-1$ 行，每行两个整数 $x,y$ ，描述一条连接 $x$ 与 $y$ 的边。

下面 $q$ 行，每行先输入一个整数 $opt$ ，表示本次是是操作还是询问。 若 $opt=1$ ，则这是一次操作，且接下来会输入一个整数 $u$ ；若 $opt=2$ ，则这是一次询问，且接下来会输入两个整数 $u,v$ 。其具体意义见【题目描述】。
## 输出格式

对于每次询问输出一行，即对应询问的答案。
## 样例

### 样例输入 #1
```
8 3
4 2 3 4 2 1 4 3
1 2
1 3
2 4
2 5
3 6
6 7
6 8
2 4 8
1 3 
2 2 3
```
### 样例输出 #1
```
3
4
```
## 提示

【样例解释】

第一次是询问。显然，只有 $(i=4,j=8)$ 满足 $\text{cover}(i,j,u,v)=1$。此时 $f(i,j)=3$。

第二次是操作。将 $3$ 号节点的点权改为了 $2$。

第三次是询问。当 $i=4,j=3$ 时，$\text{cover}(i,j,u,v)=1$ 且 $f(i,j)=4$ 。不难发现，对于其他所有满足 $\text{cover}(i,j,u,v)=1$ 的节点对 $(i,j)$，均没有 $f(i,j) >4$。

【数据范围】
- Subtask1（8pts）：$n,q\le50$；
- Subtask2（12pts）：$n,q\le2\times10^3$；
- Subtask3（16pts）：$n,q\le4\times10^4$；
- Subtask4（10pts）：保证树的形态随机生成；
- Subtask5（12pts）：保证没有 $1$ 操作；
- Subtask6（12pts）：保证每次询问的 $u,v$ 都是叶子节点；
- Subtask7（30pts）：无特殊限制。

Subtask4 的随机方式为 ：随机生成一个的排列 $p$，对于 $i\in[2,n]$，$p_i$ 向 $p_1,p_2,...,p_{i-1}$ 中等概率随机的一个点连边。

对于 $100\%$ 的数据满足，$1\le n,q,a_i \le 10^5$，保证每次询问均满足 $u$ 不是 $v$ 的祖先且 $v$ 不是 $u$ 的祖先，且 $u \neq v$ 。


---

---
title: "「TOCO Round 1」Eternal Star"
layout: "post"
diff: 省选/NOI-
pid: P7393
tag: ['树形数据结构', '递归', 'Special Judge', '构造']
---
# 「TOCO Round 1」Eternal Star
## 题目背景

「诚挚地祈愿」

「在星辰坠落的那一瞬间」

「水中倒映着两个人的身影」

「交相辉映」

![](https://cdn.luogu.com.cn/upload/image_hosting/7tf5iu0p.png)
## 题目描述

Kuon 想要一棵结点数量尽可能少的树。

她会给每个结点编号为一个正整数，使得相邻结点编号不同并且所有结点的编号和最小。如果存在很多种方案她会选择任意一种。

请你帮忙构造出一棵树使得它在 Kuon 编号后的最大编号一定不小于 $k$。
## 输入格式

两个整数 $k$ 和 $x$，其中 $k$ 见题目描述，$x$ 表示评分参数。
## 输出格式

第一行一个整数 $n$ 表示你构造的树的大小。

接下来 $n-1$ 行每行两个整数 $u,v$ 表示你构造的树的一条边。
## 样例

### 样例输入 #1
```
2 5
```
### 样例输出 #1
```
5
1 2
2 3
3 4
4 5
```
### 样例输入 #2
```
3 20
```
### 样例输出 #2
```
16
1 2
1 3
1 4
1 5
1 6
1 7
1 8
1 9
2 10
2 11
2 12
2 13
2 14
2 15
2 16
```
## 提示

本题给分方式如下：

- 如果构造的树满足要求并且 $1\leq n\leq x$，$1\leq u,v\leq n$ 那么你将获得该测试点的所有分数。
- 否则该测试点你将获得 $0$ 分。

| 测试点编号 | $k$ | $x$ |
| :-: | :-: | :-: |
| $1$ | $1$ | $/$ |
| $2$ | $2$ | $/$ |
| $3$ | $3$ | $10$ |
| $4$ | $3$ | $8$ |
| $5$ | $4$ | $40$ |
| $6$ | $4$ | $34$ |
| $7$ | $5$ | $/$ |
| $8\sim 16$ | $/$ | $/$ |
| $17$ | $10$ | $53808$ |
| $18\sim 19$ | $/$ | $/$ |
| $20$ | $12$ | $519616$ |

对于 $100\%$ 的数据，$1\leq k\leq 12$，$1\leq x\leq 10^6$，每个测试点必定存在一种树的构造方案能获得满分。


---

---
title: "「RdOI R3」RBT"
layout: "post"
diff: 省选/NOI-
pid: P7826
tag: ['树形数据结构', '线段树', 'O2优化', '分块', '位运算']
---
# 「RdOI R3」RBT
## 题目描述

你有一棵以 $1$ 为根，编号为 $1\sim n$ 的有根树，第 $i$ 号节点上有一个整数权值 $a_i$。同时每一个点都被染上了红色或蓝色。初始所有点全是红色点。你需要维护这棵树，进行 $q$ 次操作。操作分若干种，具体格式如下：

- `1 x v` ：使 $x$ 节点的子树中的每个节点的权值增加 $v$ 并对 $p$ 取模。
- `2 x v`：将 $a_x$ 赋值为 $v$。**注意不是赋值整棵子树。**
- `3 x`：将 $x$ 号点染成蓝色，设 $j$ 节点为 $x$ 号节点在它的**红色**兄弟节点中**编号**（不是权值）排名的前驱，将 $x$ 节点连接父亲的边删除。然后将 $x$ 节点作为儿子节点接到 $j$ 节点上，如果 $x$ 节点没有红色兄弟节点或 $x$ 节点的红色兄弟节点的编号均比 $x$ 大则什么都不做。
- `4 x`：设 $S$ 为 $x$ 的子树中的节点的权值中出现次数为奇数的数组成的集合。输出集合中的每个数的 $k$ 次方之和，对 $998244353$ 取模。即 $(\sum_{z\in S}z^k)\bmod 998244353$。

特别的，数据保证每个点只能被执行 $3$ 操作至多 $1$ 次。也就是说不会出现对一个蓝色点进行 $3$ 操作的情况。
## 输入格式

第一行四个整数 $n,q,p,k$。  
第二行 $n$ 个整数，代表初始的 $a_1,a_2,\cdots,a_n$。  
接下来 $n-1$ 行，每行两个整数 $f,t$。表示一条连接 $f \leftrightarrow t$ 的双向树边。  
接下来 $q$ 行，每行两个或三个整数 $op,x(,v)$。
## 输出格式

对于每个询问操作，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
10 10 500 1
3 2 1 2 1 3 2 1 3 4
1 4
7 8
3 6
8 10
2 3
2 5
8 9
7 2
2 1
4 1
1 3 1
2 1 2
4 1
4 3
4 6
1 4 1
3 7
1 5 1
4 5

```
### 样例输出 #1
```
10
5
6
4
12

```
## 提示

### 样例解释

#### 样例 \#1

- 询问 `4 1`，子树中点的权值分别为 $3,2,1,2,1,3,2,1,3,4$，$S$ 集合为 $\{1,2,3,4\}$，故答案为 $10$。
- 修改 `1 3 1`，树中各点权值变为 $3,2,2,2,1,4,2,1,3,4$。
- 修改 `2 1 2`，树中各点权值变为 $2,2,2,2,1,4,2,1,3,4$。
- 询问 `4 1`，子树中点的权值分别为 $2,2,2,2,1,4,2,1,3,4$，$S$ 集合为 $\{2,3\}$，故答案为 $5$。
- 询问 `4 3`，子树中点的编号为 $3,6$，权值分别为 $2,4$，$S$ 集合为 $\{2,4\}$，故答案为 $6$。
- 询问 `4 6`，由于这是一个叶子节点，子树中点的权值为它本身的权值 $4$，$S$ 集合为 $\{4\}$，故答案为 $4$。
- 修改 `1 4 1`，树中各点权值变为 $2,2,2,3,1,4,2,1,3,4$。
- 修改 `3 7`，将 $7$ 涂成蓝色，删除树中的边 $2\leftrightarrow 7$，并将 $7$ 作为儿子节点接到 $5$ 上。
- 修改  `1 5 1`，树中各点权值变为 $2,2,2,3,2,4,3,2,4,5$。
- 询问 `4 5`，子树中各点编号为 $5,7,8,9,10$，权值分别为 $2,3,2,4,5$，$S$ 集合为 $\{3,4,5\}$，故答案为 $12$。

---

### 数据范围

**本题采用捆绑测试。**

对于所有数据，$1\le x\le n\le 10^5$，$1\le q \le 10^5$，$0 \le a_i, v < p \le 500$，$p\ne 0$，$0\le k \le 10^9$。

| subtask | 分值 | 特殊限制                                    |
| ------- | ---- | ------------------------------------------- |
| $1$     | $10$ | $op,a_i,x,v$ 和初始树的形态均等概率随机生成 |
| $2$     | $90$ | 无                                          |


---


---
title: "[JOISC 2024] JOI 之旅 (Day3)"
layout: "post"
diff: 省选/NOI-
pid: P10437
tag: ['线段树', '2024', '交互题', 'O2优化', '树链剖分', 'JOI（日本）', '动态 DP']
---
# [JOISC 2024] JOI 之旅 (Day3)
## 题目背景

提交时请不要引用 `joitour.h`。

请不要使用 C++14 (GCC 9) 提交。
## 题目描述

在 IOI 国，有 $N$ 个城市，编号为 $0$ 到 $N-1$，有 $N-1$ 条道路，编号为 $0$ 到 $N-2$。路 $j\ (0\le j\le N-2)$ 双向连接城市 $U_j$ 和城市 $V_j$。你可以通过道路从一个城市到达另一其他城市。

IOI 国的每个城市都有一家餐厅。在城市 $i\ (0\le i\le N-1)$ 的餐厅类型用 $F_i$ 表示，具体来说：

- $F_i=0$：果汁店
- $F_i=1$：日式煎蛋卷店
- $F_i=2$：冰淇淋店

理惠女士是 IOI 国的导游，她正在规划一个叫做 **JOI 之旅**的观光计划。JOI 之旅中计划按如下顺序前往 $3$ 种餐厅：

1. 选择有果汁店的城市 $i_0\ (0\le i_0\le N-1)$，并从城市 $i_0$ 开始旅行。
2. 前往城市 $i_0$ 的果汁店。
3. 选择有日式煎蛋卷店的城市 $i_1\ (0\le i_1\le N-1)$，并从城市 $i_0$ 出发乘公交车沿最短路径前往城市 $i_1$。
4. 前往城市 $i_1$ 的日式煎蛋卷店。
5. 选择有冰淇淋店的城市 $i_2\ (0\le i_2\le N-1)$，并从城市 $i_1$ 出发乘公交车沿最短路径前往城市 $i_2$​。
6. 前往城市 $i_2$​ 的冰淇淋店。
7. 在城市 $i_2$ 结束行程。

为了避免游客无聊，理惠女士决定选择三个城市 $i_0,i_1,i_2$ 满足它们不会经过相同的道路两次。我们称这样的 JOI 之旅是好的。为了帮助她找到理想的旅行计划，你被要求计算好的 JOI 之旅的数量。换句话说，你需要找到满足所有如下条件的三元组 $(i_0,i_1,i_2)$ 的个数：

- 城市 $i_0$ 中的餐厅是果汁店。
- 城市 $i_1$ 中的餐厅是日式煎蛋卷店。
- 城市 $i_2$ 中的餐厅是冰淇淋店。
- 当我们沿最短路径从城市 $i_0$ 移动到 $i_1$ 再移动到 $i_2$ 的过程中，不会经过相同的道路两次。

在 IOI 国，会有 $Q$ 次餐厅类型改变的事件。当第 $(k+1)\ (0\le k\le Q-1)$ 个事件发生时，会给出两个整数 $X_k$ 和 $Y_k$，满足 $0\le X_k\le N-1$ 且 $0\le Y_k\le 2$。然后，在城市 $X_k$ 的餐厅类型会变为 $Y_k$。也就是说，当 $Y_k=0,1,2$ 时，餐厅类型会分别变为果汁店，日式煎蛋卷店和冰淇淋店。在每个事件过后，你应该立即计算最新的好的 JOI 之旅的数量并告诉理惠女士。

给定道路和餐厅信息，在每次类型改变事件发生之后计算好的 JOI 之旅的数量。

### 实现细节

你需要实现如下函数。

- `void init(int N, std::vector<int> F, std::vector<int> U, std::vector<int> V, int Q)`
  - 使用此函数给出道路和餐厅信息。
  - 这个函数仅在程序开始时调用一次。
  - 参数 `N` 是城市个数 $N$。
  - 参数 `F` 是长为 $N$ 的数组。`F[i]` （$0\le i\le N-1$）表示城市 $i$ 中餐厅的类别，也就是 $F_i$。
  - 参数 `U` 和 `V` 是长为 $N-1$ 的数组。`U[j]` 和 `V[j]`（$0\le j\le N-2$）是被路 $j$ 连接的两个城市 $U_j$ 和 $V_j$。
  - 参数 `Q` 是餐厅类型改变事件的个数 $Q$。
- `void change(int X, int Y)`
  - 使用此函数给出餐厅类型改变事件。
  - 这个函数被调用 $Q$ 次。
  - 第 $(k+1)\ (0\le k\le Q-1)$ 次调用中，参数 `X` 是餐厅类型改变发生的城市编号，也就是 $X_k$。
  - 第 $(k+1)\ (0\le k\le Q-1)$ 次调用中，参数 `Y` 是餐厅的新类型，也就是 $Y_k$。保证新类型与原类型不同。
- `long long num_tours()`
  - 这个函数在如下场景被调用，共 $Q+1$ 次。
    - 在执行完函数 `init` 后。
    - 在执行完函数 `change` 后。
  - 这个函数应返回最新的好 JOI 之旅数。
## 输入格式

**以下为下发 grader 的输入格式，你不应该从标准输入中读入任何信息。**

第一行一个整数 $N$。

第二行 $N$ 个整数 $F_0,\ldots,F_{N-1}$。

接下来 $N-1$ 行，每行两个整数 $U_j,V_j$。

接下来一行一个整数 $Q$。

接下来 $Q$ 行，每行两个整数 $X_k,Y_k$。
## 输出格式

**以下为下发 grader 的输出格式，你不应该向标准输出中打印任何信息。**

下发 grader 会在每次调用 `num_tours` 函数后输出一行一个整数，表示这个函数的返回值。
## 样例

### 样例输入 #1
```
3
0 1 2
0 1
1 2
0
```
### 样例输出 #1
```
1
```
### 样例输入 #2
```
3
0 1 2
0 1
1 2
2
2 0
0 2
```
### 样例输出 #2
```
1
0
1
```
### 样例输入 #3
```
7
1 0 2 2 0 1 0
0 1
0 2
1 3
1 4
2 5
2 6
7
0 0
1 1
2 0
3 0
4 2
5 2
6 2
```
### 样例输出 #3
```
3
0
4
4
0
4
5
5
```
## 提示

#### 样例解释 1

|                函数调用                 | 返回值 |
| :-------------------------------------: | :----: |
| `init(3, [0, 1, 2], [0, 1], [1, 2], 0)` |        |
|              `num_tours()`              |  $1$   |

只有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(0,1,2)$。下面是对于它满足是好的 JOI 之旅条件的解释。

- $F_0=0$，在城市 $0$ 的餐厅是果汁店。
- $F_1=1$，在城市 $1$ 的餐厅是日式煎蛋卷店。
- $F_2=2$，在城市 $2$ 的餐厅是冰淇淋店。
- 当我们沿最短路径从城市 $0$ 移动到 $1$，然后从 $1$ 移动到 $2$ 时，我们没有经过相同的道路两次。

因此，第一次 `num_tours()` 函数的调用返回值为 $1$。

该样例满足子任务 $1,2,3,4,6,7$ 的限制。

#### 样例解释 2

|                函数调用                 | 返回值 |
| :-------------------------------------: | :----: |
| `init(3, [0, 1, 2], [0, 1], [1, 2], 2)` |        |
|              `num_tours()`              |  $1$   |
|             `change(2, 0)`              |        |
|              `num_tours()`              |  $0$   |
|             `change(0, 2)`              |        |
|              `num_tours()`              |  $1$   |

最初有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(0,1,2)$。因此，第一次 `num_tours()` 函数的调用返回值为 $1$。

在第一个事件中，在城市 $2$ 的餐厅从冰淇淋店变成了果汁店。在这次变化后，冰淇淋店从 IOI 国消失了，好的 JOI 之旅也没有了。因此，第二次 `num_tours()` 函数的调用返回值为 $0$。

在第二个事件中，在城市 $0$ 的餐厅从果汁店变成了冰淇淋店。在这次变化后，有一个好的 JOI 之旅，表示为 $(i_0,i_1,i_2)=(2,1,0)$。因此，第三次 `num_tours()` 函数的调用返回值为 $1$。

该样例满足子任务 $1,2,4,6,7$ 的限制。

#### 样例解释 3

这组样例满足子任务 $1,2,5,6,7$ 的限制。

### 重要提示

- 你的程序可以实现其它函数供内部使用，或者使用全局变量。
- 你的程序禁止使用标准输入输出。你的程序禁止与其他文件通过任何方式交互。然而，你的程序可以使用标准错误输出输出调试信息。

### 编译和测试运行

你可以在「文件 - 附加文件」中下载样例交互器来测试你的程序。附加文件中还包含一个样例程序。

样例交互器是文件 `grader.cpp`。为了测试你的程序，请将 `grader.cpp`，`joitour.cpp` 和 `joitour.h` 放在同一目录下，并且执行如下命令编译程序。此外你也可以运行 `compile.sh` 来编译你的程序。

```bash
g++ -std=gnu++20 -O2 -o grader grader.cpp joitour.cpp
```

当编译成功时，会生成可执行文件 `grader`。

注意测评时使用的交互器与样例交互器不同。样例交互器会以单进程的形式执行，它会从标准输入中读入数据，输出结果到标准输出。

### 约束条件

- $3\le N\le 2\times 10^5$。
- $0\le F_i\le 2\ (0\le i\le N-1)$。
- $0\le U_j<V_j\le N-1\ (0\le j\le N-2)$。
- 可以通过道路从一个城市前往任意其他城市。
- $0\le Q\le 5\times 10^4$。
- $0\le X_k\le N-1\ (0\le k\le Q-1)$。
- $0\le Y_k\le 2\ (0\le k\le Q-1)$。
- 对于每次调用函数 `change`，新类型不同于原类型。

### 子任务

- （6 分）$N\le 400$，$Q\le 100$。
- （8 分）$N\le 4\,000$，$Q\le 1\,000$。
- （6 分）$Q=0$。
- （16 分）$U_j=j,V_j=j+1\ (0\le j\le N-2)$。
- （16 分）$U_j=\lfloor\frac{j}{2}\rfloor,V_j=j+1\ (0\le j\le N-2)$。
- （34 分）$N\le 10^5$，$Q\le 2.5\times 10^4$。
- （14 分）无额外约束。


---

---
title: "[Opoi 2024] 二十六点"
layout: "post"
diff: 省选/NOI-
pid: P10536
tag: ['线段树', '树上启发式合并', 'O2优化', '树链剖分', '单调栈']
---
# [Opoi 2024] 二十六点
## 题目背景

二十六点：

> 。 。 。 。 。 。 。 。 。 。 。 。 。
>
> 。 。 。 。 。 。 。 。 。 。 。 。 。

凑二十六点真好玩，而为了凑四道题，就有了这道权值只有 $26$ 种的凑数题。
## 题目描述


给你一棵有 $n$ 个结点的以 $1$ 为根的树 $T$，第 $i$ 个结点有一个颜色 $c_i$，${\tt a} \le c_i \le {\tt z}$，和一个值 $P_i$。

对于每一个点 $x$，**从它到它子树中每一个点**（注意顺序是从它本身到子树中的点）都有一条路径，一共有子树的大小条路径。

现在忽略掉这些路径中的第 $2$ 到第 $P_x$ 个的点，特别地，若 $P_x = 1$ 则不忽略任何点。将忽略后的路径当作一个序列，序列中每个点的权值为路径上点的 $c_i$，求**每一个点的所有序列最长不下降子序列长度的最大值**。

注: 若有路径 $j$ 上的节点数 $len_j < P_x$，则相当于忽略这条路径上除第一个点外的所有点。

## 输入格式

第一行一个整数 $n$。

第二行 $n$ 个整数 $P_i$。

第三行 $n$ 个小写字母 $c_i$，**字符与字符间没有空格**。

接下来 $n - 1$ 行，描述树 $T$，每行两个整数 $u,v$，表示 $u,v$ 存在一条边。

行末可能有多余空格（慎用 `getchar()`）。
## 输出格式

输出 $n$ 行，表示每一个点的答案，按照编号从小到大输出。
## 样例

### 样例输入 #1
```
7
2 1 1 9 8 5 1
zzabcad
1 2
2 3
3 4
3 5
5 6
5 7
```
### 样例输出 #1
```
3
3
3
1
1
1
1

```
### 样例输入 #2
```
12
1 2 2 4 1 3 4 3 1 4 3 1 
baabbbbbbbaa
4 6
5 7
1 2
12 10
8 2
10 11
5 9
10 3
2 3
4 3
4 5

```
### 样例输出 #2
```
5
4
3
1
2
1
1
1
1
1
1
1
```
## 提示



### 样例一解释：

样例中树的形态：

![](https://cdn.luogu.com.cn/upload/image_hosting/6vbio7vo.png?x-oss-process=image/resize,h_450,m_lfit)

对于 $1$ 号节点：
$P_1=2$。

|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |
| :----------: | :----------: | :----------: | :----------: |
| 1 | z | 1 | z |
| 1 3 | za | 1 |  z |
| 1 3 4 |  zab | 2  | ab |
| 1 3 5  |  zac | 2 |  ac   |
| 1 3 5 6 |  zaca | 2  | ac |
| 1 3 5 7 | zacd| 3 | acd  |

长度最长的最长不降子序列：acd。

$2$ 号节点和 $1$ 号节点同理。

对于 $3$ 号节点：
$P_3=1$。

|  序列| 权值 | 最长不下降子序列长度 | 最长不下降子序列 |
| :----------: | :----------: | :----------: | :----------: |
| 3 | a | 1 | a |
| 3 4 | ab | 1 |  ab |
| 3 5  |  ac | 2  | ac |
| 3 5 6  |  aca | 2 |  ac   |
|3 5 7   |  acd | 3  |acd |

长度最长的最长不降子序列：acd。

对于 $4,5,6,7$，它的所有序列中都只有它自己一个点，所以输出 $1$。
### 数据范围

本题采用 Subtask 计分。

| Subtask | Limit | Pts |
| :-----------: | :-----------: | :-----------: |
| 0 | $n \le 100$ | 5 |
| 1 | $n \le 2000$ | 15 |
| 2 | $\forall 1 \le i \le n \quad P_i=1$ | 30 |
| 3 | Empty | 50 |

对于 $100\%$ 的数据：

$1 \le n \le 10^5$。

$\forall 1 \le i \le n$， $c_i$ 为小写字母，$1 \le P_i \le n$。

给出的树连通且合法。


---

---
title: "BZOJ2164 采矿"
layout: "post"
diff: 省选/NOI-
pid: P10599
tag: ['动态规划 DP', '线段树', '背包 DP', '树链剖分']
---
# BZOJ2164 采矿
## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。
## 题目描述

浩浩荡荡的 cg 大军发现了一座矿产资源极其丰富的城市，他们打算在这座城市实施新的采矿战略。

这个城市可以看成一棵有 $n$ 个节点的有根树，我们把每个节点用 $1$ 到 $n$ 的整数编号。为了方便起见，对于任何一个非根节点 $v$，它任何一个祖先的编号都严格小于 $v$。树上的每个节点表示一个矿点，每条边表示一条街道。

作为 cg 大军的一个小队长，你拥有 $m$ 个部下。你有一张二维的动态信息表，用 $T_{i,j}$ 表示第 $i$ 行第 $j$ 列的数据。当你被允许开采某个区域时，你可以将你的部下分配至各个矿点。在第 $i$ 个矿点安排 $j$ 个人可以获得 $T_{i,j}$ 单位的矿产。

允许开采的区域是这样描述的：给你一对矿点 $(u,v)$，保证 $v$ 是 $u$ 的祖先（这里定义祖先包括 $u$ 本身）；$u$ 为你控制的区域，可以在以 $u$ 为根的子树上任意分配部下；$u$ 到 $v$ 的简单路径（不包括 $u$ 但包括 $v$，若 $u=v$ 则包括 $u$）为探险路径，在该路径上你可以选择至多一个矿点安排部下。你这次开采的收益为安排有部下的矿点的收益之和。
## 输入格式

输入的第一行包含 $5$ 个正整数 $n,m,A,B,Q$。其中 $n$ 为矿点的个数，$m$ 为部下的数量。$A,B,Q$ 是与动态信息表有关的数据。

第二行包含 $n-1$ 个正整数，第 $i$ 个数为 $F_{i+1}$，表示节点 $i+1$ 的父亲。

接下来需要你用下文的方法依次生成 $n$ 组数据，每组数据共 $m$ 个。其中第 $i$ 组的 $m$ 个数据为信息表中第 $i$ 行的 $m$ 个数据。紧接着一行包含一个正整数 $C$，表示事件的数量。

最后给出 $C$ 行，每行描述一个事件。每个事件会先给出一个 $0$ 或 $1$ 的整数。如果该数为 $0$，则后面有一个正整数 $p$，表示动态信息表有更新，你需要生成一组 $m$ 个数据，来替换信息表中第 $p$ 行的 $m$ 个数据。如果该数为$1$，则后面有两个正整数 $u,v$，表示出现了一个你可以开采的区域，你需要回答这次开采的收益。同一行的各个数之间均用一个空格隔开，没有多余的空格和换行。

数据的生成方法如下：每次生成一组 $m$ 个从小到大排列的数据，替换动态信息表的一行。其中，从小到大第 $j$ 个数替换信息表中第 $j$ 列的数。调用以下代码 $m$ 次并排序得到一组数据。（注意可能会出现重复的数）

```
Function GetInt 

A←((A xor B)+(B div X)+(B * X))and Y 
B←((A xor B)+(A div X)+(A * X))and Y 

return (A xor B)mod Q 
```

其中 $A,B,Q$ 均用 $32$ 位有符号整数保存（C/C++ 的 signed long int 类型，pascal 的 longint 类型），$X=2^{16}$，$Y=2^{31}-1$，xor 为位异或运算，div 为整除运算，and 为位且运算，mod 为取余运算。由于只保留了低 $31$ 位，易得我们不用考虑数据的溢出问题。注意每次 $A$ 和 $B$ 都会被改变）
## 输出格式

对于每个开采事件（开头为 $1$ 的事件），输出一行一个整数，为每次的收益。
## 样例

### 样例输入 #1
```
10 5 1 2 10
1 1 3 3 4 4 6 6 9
4
1 6 3
1 9 1
0 1
1 1 1
```
### 样例输出 #1
```
11
9
12
```
## 提示

**【样例解释】**

最初的信息表如下：

| 0 | 1 | 1 | 2 | 2 |
| :----------: | :----------: | :----------: | :----------: | :----------: |
| 0 | 5 | 7 | 7 | 9 |
| 1 | 2 | 3 | 4 | 5 |
| 0 | 1 | 2 | 4 | 5 |
| 2 | 4 | 7 | 8 | 8 |
| 0 | 2 | 3 | 8 | 9 |
| 1 | 3 | 5 | 6 | 8 |
| 3 | 3 | 3 | 7 | 8 |
| 0 | 1 | 2 | 3 | 9 |
| 0 | 0 | 1 | 4 | 4 |

变化后的第 $1$ 行，为：
```
1 1 1 4 7
```
第一次开采可以在矿点 $6,8,9,10$ 任意安排，可以在矿点 $3$ 或 $4$ 中选取一个安排开采。一种最优安排是在矿点 $6$ 安排 $4$人，在矿点 $8$ 安排 $1$ 人。第二次开采可以在矿点 $9$ 安排，可以在矿点 $6,4,3,1$ 中选择一个安排。一种最优安排是在矿点 $9$ 安排 $1$ 人，在矿点 $6$ 安排 $4$ 人。

**【数据范围】**

有 $50\%$ 的数据，对于满足 $2\leq i\leq n$ 的整数 $i$，$F_i=i-1$。这些数据中有 $40\%$ 的数据（即所有数据的 $20\%$）满足 $n\leq 500，m\leq 20，C\leq 500$。

除上述数据，另有 $40\%$ 的数据满足 $n\leq 500$，$m\leq 20$，$C\leq 500$。

对于 $100\%$ 的数据 $1\leq n\leq 20000$，$1\leq m\leq 50$，$1\leq C\leq 2000$。对于满足 $2\leq i\leq n$ 的整数 $i$，$1\leq F_i<i$。$1\leq A,B\leq 2^{31}-1$，$1\leq Q\leq 10000$。


---

---
title: "BZOJ4372 烁烁的游戏"
layout: "post"
diff: 省选/NOI-
pid: P10603
tag: ['线段树', 'O2优化', '树链剖分', '动态树分治']
---
# BZOJ4372 烁烁的游戏
## 题目背景

题目来自原 BZOJ，我们承认题面及原数据的版权均属于原 BZOJ 或将题目授权给 BZOJ 使用的出题人。如果您是版权所有者且认为我们侵犯了您的权益，可联系我们。

---

烁烁很喜欢爬树，这吓坏了树上的皮皮鼠。

给定一颗 $n$ 个节点的树，边权均为 $1$，初始树上没有皮皮鼠。

烁烁他每次会跳到一个节点 $u$ ，把周围与他距离不超过 $d$ 的节点各吸引出 $w$ 只皮皮鼠。皮皮鼠会被烁烁吸引，所以会一直待在节点上不动。

烁烁很好奇，在当前时刻，节点 $u$ 有多少个他的好朋友——皮皮鼠。
## 题目描述

题目背景可以被抽象成这个问题：

给一棵 $n$ 个结点的树，边权均为 $1$，初始点权均为 $0$。进行 $m$ 次操作：
- $\text{Q x}$：询问结点 $x$ 的点权。
- $\text{M x d w}$：将树上与结点 $x$ 距离不超过 $d$ 的节点的点权均加上 $w$。
## 输入格式

第一行两个正整数 $n,m$。

接下来的 $n-1$ 行，每行三个正整数 $u,v$，代表 $u,v$ 之间有一条边。

接下来的 $m$ 行，每行给出上述两种操作中的一种。
## 输出格式

对于每个 $Q$ 操作，输出当前 $x$ 结点的点权。
## 样例

### 样例输入 #1
```
7 6
1 2
1 4
1 5
2 3
2 7
5 6
M 1 1 2
Q 5
M 2 2 3
Q 3
M 1 2 1
Q 2
```
### 样例输出 #1
```
2
3
6
```
## 提示

对于所有数据，保证 $1\leq n,m\leq 10^5$，$|w|\leq 10^4$。注意：$w$ 不一定为正整数，


---

---
title: "[JOI Open 2024] 考试 2"
layout: "post"
diff: 省选/NOI-
pid: P10626
tag: ['动态规划 DP', '线段树', '树上启发式合并', '2024', '树链剖分', '动态树 LCT', 'JOI（日本）']
---
# [JOI Open 2024] 考试 2
## 题目描述

JOI 君在 IOI 高中上学，期末考试即将来临。考试的内容是计算 **IOI 函数**。IOI 函数是将 $[1,10^9]$ 之间的整数映射到布尔值（即 $\texttt{True}/\texttt{False}$）的函数。IOI 函数可以从以下六条 IOI 高中规定的规则中构造：

1. 设 $a$ 为 $[1,10^9]$ 之间的整数，则 $\texttt{[a]}$ 是一个 IOI 函数。它将不小于 $a$ 的整数映射成 $\texttt{True}$，将小于 $a$ 的整数映射成 $\texttt{False}$。

2. 记 $\texttt{f}$ 为 IOI 函数，则 $\texttt{(f)}$ 是一个 IOI 函数，它的映射规则与 $\texttt{f}$ 的映射规则相同。

3. 记 $\texttt{f}$ 为 IOI 函数，则 $\texttt{!f}$ 是一个 IOI 函数。设 $x$ 为整数，若 $\texttt{f}$ 将 $x$ 映射为 $\texttt{True}$，则 $\texttt{!f}$ 将 $x$ 映射为 $\texttt{False}$；否则 $\texttt{!f}$ 将 $x$ 映射为 $\texttt{True}$。

4. 记 $\texttt{f},\texttt{g}$ 为 IOI 函数，则 $\texttt{f\&g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\texttt{f\&g}$ 将 $x$ 映射为 $\texttt{True}$，当且仅当 $\texttt{f},\texttt{g}$ 都将 $x$ 映射为 $\texttt{True}$。

5. 记 $\texttt{f},\texttt{g}$ 为 IOI 函数，则 $\texttt{f\^ g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\texttt{f\^ g}$ 将 $x$ 映射为 $\texttt{True}$，当且仅当 $\texttt{f},\texttt{g}$ 中恰好有一个将 $x$ 映射为 $\texttt{True}$。

6. 记 $\texttt{f},\texttt{g}$ 为 IOI 函数，则 $\texttt{f|g}$ 也是一个 IOI 函数。设 $x$ 为整数，则 $\texttt{f|g}$ 将 $x$ 映射为 $\texttt{True}$，当且仅当 $\texttt{f},\texttt{g}$ 中至少有一个将 $x$ 映射为 $\texttt{True}$。

如果某个 IOI 函数用多条规则构造出，数字更大的规则将决定函数值。例如，对于 $\texttt{[1]\&[2]|[3]}$ 应当应用规则 6，其中 $\texttt{f} = \texttt{[1]\&[2]},\texttt{g} = \texttt{[3]}$（而非应用规则 4，其中 $\texttt{f} = \texttt{[1]},\texttt{g} = \texttt{[2]|[3]}$）。额外地，对于规则 4，5，6，应当最大化 $\texttt{f}$ 的长度。例如，对于 $\texttt{[4]ˆ[5]ˆ[6]}$，应当在 $\texttt{f} = \texttt{[4]ˆ[5]},\texttt{g} = \texttt{[6]}$ 上应用规则 5（而非 $\texttt{f} = \texttt{[4]},\texttt{g} = \texttt{[5]ˆ[6]}$）。

为备战期末考试，JOI 君准备好了一个长度为 $N$ 的 IOI 函数 $S$。他打算用 $Q$ 个整数 $X_1,X_2,\cdots,X_Q$ 来练习他的计算技能。于是他找来了你——能够熟练处理 IOI 函数的人，来解决这个问题。

你需要写一个程序。给定 $N,Q,S$ 以及 $X_1,X_2,\cdots,X_Q$，对于 $i=1,2=\cdots,Q$，回答 IOI 函数 $S$ 会将 $X_i$ 映射成 $\texttt{True}$ 还是 $\texttt{False}$。

## 输入格式

输入格式如下所示：

> $N$ $Q$\
> $S$\
> $X_1$\
> $X_2$\
> $\vdots$\
> $X_Q$
## 输出格式

输出 $Q$ 行，第 $i$ 行为 $\texttt{True}$ 或者 $\texttt{False}$，即 $X_i$ 被 $S$ 映射成的值。
## 样例

### 样例输入 #1
```
15 5
(![2]|[3])&![4]
1
2
3
4
5
```
### 样例输出 #1
```
True
False
True
False
False
```
### 样例输入 #2
```
20 4
(!![23])^((([116])))
54
1
200
89
```
### 样例输出 #2
```
True
False
False
True
```
### 样例输入 #3
```
32 4
[2]|[5]&[1]|(([1000000000])|[7])
4
10
6
1
```
### 样例输出 #3
```
True
True
True
False
```
## 提示


### 样例解释

样例 $1$ 解释如下：

| $X_i$ | $\texttt{![2]}$ | $\texttt{[3]}$ | $\texttt{![2]\|[3]}$ | $\texttt{![4]}$ | $\texttt{(![2]\|[3])\&![4]}$ |
| :--: | :--: | :--: | :--: | :--: | :--: |
| $1$ | $\texttt{True}$ | $\texttt{False}$ | $\texttt{True}$ | $\texttt{True}$ | $\texttt{True}$ |
| $2$ | $\texttt{False}$ | $\texttt{False}$ | $\texttt{False}$ | $\texttt{True}$ | $\texttt{False}$ |
| $3$ |  $\texttt{False}$ | $\texttt{True}$ | $\texttt{True}$ | $\texttt{True}$ | $\texttt{True}$ |
| $4$ | $\texttt{False}$ | $\texttt{True}$ | $\texttt{True}$ | $\texttt{False}$ | $\texttt{False}$ |
| $5$ |  $\texttt{False}$ | $\texttt{True}$ | $\texttt{True}$ | $\texttt{False}$ | $\texttt{False}$ |

样例 $1$ 满足子任务 $3,6,7$ 的条件。

样例 $2$ 满足子任务 $1,3,5\sim 7$ 的条件。

样例 $3$ 满足子任务 $3,4,6,7$ 的条件。	

### 数据范围

- $1 \le N \le 1\,000\,000$；
- $1 \le Q \le 200\,000$；
- $S$ 为长度为 $N$ 的 IOI 函数；
- $1 \le X_i \le 10^9$（$1 \le i \le Q$）；
- $N, Q, X_i$（$1 \le i \le Q$）均为整数。

### 子任务

1. （$5$ points）$S$ 中不含 $\texttt{\&}$ 和 $\texttt{|}$；
2. （$20$ points）$Q = 1$；
3. （$10$ points）$N \le 10\,000$；
4. （$6$ points）$S$ 中不含 $\texttt{!}$ 和 $\texttt{ˆ}$；
5. （$12$ points）当应用规则 4 或 6 来构造 $S$ 时，$\texttt{f}$ 和 $\texttt{g}$ 中至少有一个是用规则 1 得到的；
6. （$20$ points）$N \le 400\, 000$；
7. （$27$ points）无额外约束。

*赛时公告：如果你复制题面中的 LaTeX，可能会得到 `ˆ`，但实际上是 `^`。请特别注意。

由 Starrykiller 根据英文题面翻译。


---

---
title: "运输规划"
layout: "post"
diff: 省选/NOI-
pid: P10919
tag: ['O2优化', '二分图', '树链剖分', '笛卡尔树']
---
# 运输规划
## 题目背景

你需要规划卡车的运输方案，为了让您更好地解决问题，**请仔细阅读题面。**
## 题目描述

有 $n$ 个城市，对于任意 $1 < i \leq n$ 满足第 $i$ 个城市与第 $i-1$ 个城市间有一条双向的道路，每个城市有一个对卡车高度的限制 $h_i$，代表只有高度小于等于 $h_i$ 的卡车可以从这个城市经过，现在有 $m$ 个城市 $S_{1},S_{2},...,S_{m}$ 各有**恰好**一个运输任务，任务要求**编号为 $i$ 且高度为 $h_{S_{i}}$ 的**卡车从城市 $S_{i}$ 出发**到达**任意一个有机场的城市，而有 $m$ 个城市有机场，分别为 $T_{1},T_{2},...,T_{m}$，对于一个合法的运输方案而言，需要保证每个卡车都到达一个机场且每个机场**恰好**有一辆卡车**抵达**。一个机场**可以**同时被多辆卡车**经过**。请注意，如果你无法经过某个城市，那么你也无法抵达这个城市。

记 $c_i$ 表示抵达位于城市 $T_i$ 的机场的的**卡车编号**，令数组 $F = \{c_1,c_2,...,c_m\}$，请你最小化 $F$ 的字典序并输出 $F$。

我们定义两个长度为 $len$ 的数组 $A,B$ 满足 $A$ 的字典序小于 $B$ 当且仅当存在 $0 \leq i < len$ 满足对于任意 $1 \leq j \leq i$ 满足 $A_j = B_j$ 且 $A_{i+1} < B_{i+1}$。

数据保证有解，保证**所有 $h_i$ 互不相同**，所有 $T_i$ 互不相同，所有 $S_i$ 互不相同。但是**可能会**存在 $i,j$ 满足 $S_i = T_j$。

## 输入格式

第一行两个数 $n,m$。

接下来一行 $n$ 个数表示 $h_1,h_2,...,h_n$。

再接下来一行 $m$ 个数表示 $S_{1},S_{2},...,S_{m}$。

再接下来一行 $m$ 个数表示 $T_{1},T_{2},...,T_{m}$。


## 输出格式

输出一行 $m$ 个数表示 $F$。
## 样例

### 样例输入 #1
```
10 3 
1 2 3 5 4 10 8 6 7 9
1 2 8
6 10 3

```
### 样例输出 #1
```
1 3 2
```
### 样例输入 #2
```
20 5
12 13 14 15 16 17 18 19 20 22 21 30 29 28 27 26 23 24 25 1
1 20 2 5 3 
10 12 11 9 13 

```
### 样例输出 #2
```
1 2 3 4 5
```
## 提示

**本题采用捆绑测试**。

| 子任务编号 | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: |
| $1$ | $n,m \leq 50$ | $10$ |
| $2$ | 对于任意 $1 < i \leq n$ 满足 $h_i < h_{i-1}$ | $25$ |
| $3$ | $n,m \leq 10^3$ | $25$ |
| $4$ | 无特殊性质 | $40$ |

对于 $100\%$ 的数据保证 $1 \leq m \leq n \leq 2 \times 10^5,0 < h_i \leq 10^9$。



---

---
title: "[KTSC 2024 R1] 警察与小偷"
layout: "post"
diff: 省选/NOI-
pid: P11237
tag: ['二分', '2024', '交互题', 'Special Judge', '树链剖分', 'KOI（韩国）']
---
# [KTSC 2024 R1] 警察与小偷
## 题目背景

**请勿使用 C++14 (GCC 9) 提交**。

你需要在程序开头加入如下代码：

```cpp
#include<vector>
#include<array>
std::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);
```
## 题目描述

**题目译自 [2024년도 국제정보올림피아드 대표학생 선발고사 - 1차 선발고사](https://www.ioikorea.kr/archives/ioitst/2024/)  T3 「[경찰과 도둑](https://assets.ioikorea.kr/ioitst/2024/1/police/police_statement.pdf)」**

KOI 村由 $N$ 座房子和连接这些房子的 $N-1$ 条双向道路组成。任意两座不同的房子都可以通过这些道路互相到达。也就是说，KOI 村的道路网络是一个树结构。

KOI 村的房子编号从 $0$ 到 $N-1$，道路编号从 $0$ 到 $N-2$。对于编号为 $i$ 的道路，它连接了编号为 $A[i]$ 和 $B[i]$ 的房子，长度为 $D[i]$ 米。

最近，KOI 村频繁发生盗窃事件，村民们非常困扰。为了应对这种情况，村里决定在某个房子里安排警察待命，以便在小偷出现时迅速抓捕。村民们想知道在不同情况下，警察需要多长时间才能抓住小偷。

你将会得到 $Q$ 个场景，每个场景编号从 $0$ 到 $Q-1$。每个场景如下：

- 在第 $j$ 个场景中，警察从编号为 $P[j]$ 的房子出发，最大速度为 $V1[j]$ 米/秒。
- 在第 $j$ 个场景中，小偷从编号为 $T[j]$ 的房子出发，最大速度为 $V2[j]$ 米/秒。
- 警察和小偷出发的房子不同，即 $P[j] \neq T[j]$。
- 房子的大小可以忽略不计，因此可以将房子视为一个点。道路的宽度也可以忽略不计，因此可以将道路视为一条线段。道路之间不相交。
- 警察和小偷可以在 KOI 村内自由移动，速度不超过各自的最大速度。可以选择不移动。
- 如果警察和小偷在同一个位置，警察就能抓住小偷。这个位置可以是房子，也可以是道路的中间。
- 在每个场景中，警察和小偷都知道对方的速度，并且随时知道对方的位置。
- 警察和小偷都会采用最优策略。警察会尽快抓住小偷，而小偷会尽量拖延被抓住的时间。可以证明，在最优策略下，小偷一定会在有限时间内被抓住。

你需要计算每个场景中，小偷被抓住所需的时间。

你需要实现以下函数：

```cpp
std::vector<std::array<long long, 2>> police_thief(std::vector<int> A, std::vector<int> B, std::vector<int> D, std::vector<int> P, std::vector<int> V1, std::vector<int> T, std::vector<int> V2);
```

- `A, B, D`：大小为 $N-1$ 的整数数组。对于每条编号为 $i$ 的道路，它连接了编号为 $A[i]$ 和 $B[i]$ 的房子，长度为 $D[i]$ 米。
- `P, V1, T, V2`：大小为 $Q$ 的整数数组。对于第 $j$ 个场景，警察从编号为 $P[j]$ 的房子出发，最大速度为 $V1[j]$ 米/秒，小偷从编号为 $T[j]$ 的房子出发，最大速度为 $V2[j]$ 米/秒。
- 该函数返回一个大小为 $Q$ 的数组 $C$，每个元素是一个大小为 $2$ 的数组。对于第 $j$ 个场景，小偷被抓住所需的时间（以秒为单位）表示为分数 $C[j][0] / C[j][1]$。
- $C[j][0] / C[j][1]$ 可以不是最简分数，但 $C[j][0]$ 和 $C[j][1]$ 必须是 $1$ 到 $10^{18}$ 之间的整数。可以证明，对于所有满足约束条件的输入，答案总能表示为这种形式的分数。

注意，提交的代码中不应包含任何输入输出操作。

## 输入格式

示例评测程序按以下格式读取输入：

- 第 $1$ 行：$N\,Q$
- 第 $2+i$ $(0 \leq i \leq N-2)$ 行：$A[i]\,B[i]\,D[i]$
- 第 $1+N+j$ $(0 \leq j \leq Q-1)$ 行：$P[j]\,V1[j]\,T[j]\,V2[j]$
## 输出格式

示例评测程序按以下格式读取输入：

- 第 $1$ 行：$N\,Q$
- 第 $2+i$ $(0 \leq i \leq N-2)$ 行：$A[i]\,B[i]\,D[i]$
- 第 $1+N+j$ $(0 \leq j \leq Q-1)$ 行：$P[j]\,V1[j]\,T[j]\,V2[j]$

假设 `police_thief` 返回的数组为 $C$。示例评测程序将输出：

- 第 $1+j$ $(0 \leq j \leq Q-1)$ 行：$C[j][0]\,C[j][1]$

## 样例

### 样例输入 #1
```
4 3
0 1 557912
0 2 517656
0 3 275807
3 265381 0 1000000
0 190435 2 12345
0 195025 3 67890
```
### 样例输出 #1
```
833719 265381
517656 190435
275807 195025
```
### 样例输入 #2
```
6 4
0 1 2
1 2 2
2 3 10
1 4 8
2 5 16
3 4 0 3
3 2 0 1
3 19 0 9
3 20 0 19
```
### 样例输出 #2
```
6 1
10 1
1 1
13 10
```
### 样例输入 #3
```
10 10
4 9 7
2 8 8
9 0 4
9 1 5
3 1 1
7 6 2
1 2 5
6 2 10
5 9 2
3 1 5 9
0 6 5 7
5 6 9 6
2 5 1 7
0 2 6 4
5 6 2 10
5 5 0 10
7 4 1 8
9 1 8 7
8 5 4 5
```
### 样例输出 #3
```
18 1
13 3
4 1
17 5
13 1
4 1
6 5
29 4
22 1
5 1
```
### 样例输入 #4
```
10 10
6 7 1
8 5 1
8 2 4
3 9 4
4 1 4
9 7 7
0 4 3
1 3 4
8 4 7
3 5 0 2
1 7 7 2
6 9 8 5
2 7 0 5
3 5 2 4
3 10 0 5
2 8 0 7
6 8 7 2
1 4 8 2
2 8 5 7
```
### 样例输出 #4
```
11 5
16 7
31 9
4 1
19 5
11 10
31 8
1 6
15 4
3 1
```
## 提示

对于所有输入数据，满足：

- $2 \leq N \leq 10^5$
- $1 \leq Q \leq 10^5$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$0 \leq A[i], B[i] \leq N-1$ 且 $A[i] \neq B[i]$
- 对于所有 $i$ $(0 \leq i \leq N-2)$，$1 \leq D[i] \leq 10^6$
- KOI 村是一棵树的结构
- 对于所有 $j$ $(0 \leq j \leq Q-1)$，$0 \leq P[j], T[j] \leq N-1$ 且 $P[j] \neq T[j]$
- 对于所有 $j$ $(0 \leq j \leq Q-1)$，$1 \leq V1[j], V2[j] \leq 10^6$

详细子任务附加限制及分值如下表所示。

| 子任务 | 分值 | 附加限制 |
| :-: | :-: | :-: |
| $1$ | $15$ | $N \leq 5000, Q \leq 5000$ |
| $2$ | $21$ | $N \leq 50000,Q \leq 50000$ |
| $3$ | $5$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$A[i]=i, B[i]=i+1$ |
| $4$ | $6$ | 对于所有 $i$ $(0 \leq i \leq N-2)$，$A[i]=0, B[i]=i+1$ |
| $5$ | $14$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$V1[j] \leq V2[j]$ |
| $6$ | $9$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$P[j]$ 和 $T[j]$ 之间的道路数量不超过 $10$ 条 |
| $7$ | $9$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$P[j]=0$ |
| $8$ | $10$ | 对于所有 $j$ $(0 \leq j \leq Q-1)$，$T[j]=0$ |
| $9$ | $11$ | 无附加限制 |


---

---
title: "[NOISG 2022 Qualification] Dragonfly"
layout: "post"
diff: 省选/NOI-
pid: P11295
tag: ['2022', '树链剖分', '整体二分', 'NOISG（新加坡）']
---
# [NOISG 2022 Qualification] Dragonfly
## 题目背景

在植物园和碧山公园周围的池塘中，经常可以看到蜻蜓。在一个更密集的森林区域中，Benson 记录了 $n$ 个池塘，以及蜻蜓可以捕食的昆虫数量和种类。

在池塘 $i$，共有 $b_i$ 只昆虫，这些昆虫属于种类 $s_i$。

此外，还有 $n-1$ 条小径，每条小径连接两池塘 $u_j$ 和 $v_j$（双向）。

Benson 抓住了 $d$ 只蜻蜓，并计划依次释放到池塘 $1$。每只蜻蜓有一个目标池塘 $h_k \neq 1$，会沿着最短路径飞到目标池塘，并在经过的每个池塘中捕食昆虫（包括池塘 $1$）。

每次捕食会减少池塘中 $1$ 只昆虫（如果昆虫数量不为 $0$）。需要帮助 Benson 计算每只蜻蜓的飞行过程中捕食到的不同种类昆虫的数量。
## 题目描述

请确定每只蜻蜓的飞行过程中捕食到的不同种类昆虫的数量。
## 输入格式

- 第一行包含两个整数 $n$ 和 $d$，分别表示池塘数量和蜻蜓数量。
- 第二行包含 $n$ 个整数 $b_1, b_2, \dots, b_n$，表示每个池塘的昆虫数量。
- 第三行包含 $n$ 个整数 $s_1, s_2, \dots, s_n$，表示每个池塘昆虫的种类。
- 第四行包含 $d$ 个整数 $h_1, h_2, \dots, h_d$，表示每只蜻蜓的目标池塘。
- 接下来 $n-1$ 行，每行包含两个整数 $u_j$ 和 $v_j$，表示一条连接池塘 $u_j$ 和 $v_j$ 的小径。
## 输出格式

输出一行包含 $d$ 个整数，第 $k$ 个整数表示第 $k$ 只蜻蜓捕食到的不同种类昆虫数量。
## 样例

### 样例输入 #1
```
5 6
4 1 0 3 1
1 3 2 2 1
2 5 4 3 4 2
5 2
2 1
1 4
1 3
```
### 样例输出 #1
```
2 1 2 1 1 0
```
### 样例输入 #2
```
7 4
0 2 4 4 0 1 3
6 1 6 2 2 2 1
7 5 2 4
4 1
4 5
6 2
1 6
1 3
6 7
```
### 样例输出 #2
```
2 1 1 1
```
## 提示

【样例解释】

对于样例 $1$，第一只蜻蜓飞向池塘 $2$，捕食 $1$ 只种类 $1$ 的昆虫和 $1$ 只种类 $2$ 的昆虫。第二只蜻蜓飞向池塘 $5$，捕食种类 $1$ 的昆虫，总共捕食 $1$ 个种类。  

对于样例 $2$，每只蜻蜓飞行后捕食到的不同种类分别是 $2, 1, 1, 1$。

【数据范围】

- $2 \leq n \leq 2 \times 10^5$
- $1 \leq d \leq 2 \times 10^6$
- $1 \leq s_i \leq n$，$0 \leq b_i \leq d$，$1 \leq u_j, v_j < n$

| 子任务编号 | 分值 | 额外限制条件                              |
| :--------: | :--: | :---------------------------------------: |
| $1$        | $10$ | $n, d \leq 1000$                          |
| $2$        | $10$ | $b_i = d$                                 |
| $3$        | $12$ | $b_i \leq 10$                             |
| $4$        | $12$ | $u_j = j$, $v_j = j + 1$                  |
| $5$        | $37$ | $s_i = i$                                 |
| $6$        | $16$ | $d \leq 2 \times 10^5$                    |
| $7$        |  $3$ | 无额外限制                                |


---

---
title: "[COTS 2016] 搜索树 Jelka"
layout: "post"
diff: 省选/NOI-
pid: P11306
tag: ['2016', '线段树', '倍增', '树状数组', '树的遍历', '树链剖分', 'COCI（克罗地亚）']
---
# [COTS 2016] 搜索树 Jelka
## 题目背景

译自 [Izborne Pripreme 2016 (Croatian IOI/CEOI Team Selection)](https://hsin.hr/pripreme2016/) D2T1。$\texttt{1s,0.5G}$。

## 题目描述


给定一棵 $n$ 个点的二叉树，点有点权，其中 $1$ 号点为根节点。

$m$ 次操作修改某个点的点权。在每次修改后询问：这棵树上有多少个节点的子树（包含自身）是二叉搜索树（BST）？

我们给定 BST 的定义：

- 含有一个节点的树是 BST。
- 对于大于一个节点的树，它是 BST 当且仅当：
	- 根节点的左子树为空，或者左子树是二叉搜索树，且左子树内所有点的点权均**不大于**根节点的点权；
   - 根节点的右子树为空，或者右子树是二叉搜索树，且右子树内所有点的点权均**不小于**根节点的点权。


## 输入格式


第一行，两个正整数 $n,m$。

接下来 $n$ 行，每行两个整数 $l_i,r_i$，表示 $i$ 号点的左儿子和右儿子编号。
- 特别地，若不存在，则为 $0$。

接下来一行，$n$ 个整数 $a_1,\cdots,a_n$，表示每个点的点权。

接下来 $m$ 行，每行两个整数 $x,v$，表示一次操作 $a_x\gets v$。

## 输出格式

输出 $m$ 行 $m$ 个整数，表示答案。

## 样例

### 样例输入 #1
```
6 5
2 3
4 0
5 6
0 0
0 0
0 0
4 1 3 2 2 5
3 3
2 2
3 5
5 4
6 1
```
### 样例输出 #1
```
4
5
5
6
4
```
### 样例输入 #2
```
8 10
4 5
8 0
0 0
3 7
0 6
0 0
2 0
0 0
7 0 9 3 6 0 6 2
3 0
4 0
8 2
2 3
7 6
1 6
5 7
6 9
1 1
1 7
```
### 样例输出 #2
```
3
3
3
6
6
6
6
8
7
8
```
## 提示


#### 样例解释

样例 $1$ 解释如图所示。

其中节点内的数字表示 BST 权值，节点外的数字表示节点编号。

![](https://cdn.luogu.com.cn/upload/image_hosting/yabnaj75.png)

#### 数据范围

对于 $100\%$ 的数据，保证：
- $1\le n,m\le 2\times 10^5$；
- $0\le a_i,v\le 10^9$；
- 操作和树的形态均合法。


| 子任务编号 | $n,m\le  $ | 特殊性质 | 得分 |  
| :--: | :--: | :--: | :--: |
| $ 1 $    | $ 5\, 000$    |  | $ 16 $   |  
| $ 2 $    | $ 2\times 10^5 $   | A |  $ 24 $   |  
| $ 3 $    | $ 2\times 10^5$ | | $ 60 $   |  

特殊性质 A：$\forall 1\le i\le n$，$l_i=0\lor r_i=0$。




---

---
title: "[NOISG 2022 Finals] Grapevine"
layout: "post"
diff: 省选/NOI-
pid: P11330
tag: ['2022', '树链剖分', 'NOISG（新加坡）']
---
# [NOISG 2022 Finals] Grapevine
## 题目描述

Syrup 有一个巨大的葡萄藤。这个葡萄藤上共有 $N$ 片叶子，用 $1 \sim N$ 编号；这些叶子之间有 $N-1$ 条藤连接。第 $i$ 条藤连接第 $A_i$ 和第 $B_i$ 片叶子，长度为 $W_i$。换句话说，这些叶子和藤组成了一棵树。没有两个葡萄藤的两端相同，且这些叶子之间都可以相互到达。

Syrup 精通养护葡萄藤。他可以向一个叶子 $j$ **浇水**，使得这里飞速生长。如果这片叶子上还没有葡萄，那么浇完水后会立刻长出；如果已经有葡萄了，那么这个葡萄会因为水分过多而消失。

他也可以选择一条树枝，并**改变它的长度**。因为这个葡萄藤实在太大了，所以他需要站在叶子上，并快速**找到**离它距离最近的一个葡萄。

现在，刚刚经历过暴风雨的葡萄藤上没有葡萄。在这一周内，Syrup 打算进行 $Q$ 次以上操作，他想让你帮他快速回答出他的问题。
## 输入格式

第一行，两个整数 $N,Q$；

接下来 $N-1$ 行，每行三个整数 $A_i,B_i,W_i$。

接下来 $Q$ 行，表示 $Q$ 个操作：

- `1 q`：现在 Syrup 站在编号为 $q$ 的叶子上，他想找到离它最近的葡萄，请你输出这个最小距离。

- `2 u`：向编号为 $u$ 的叶子浇水。

- `3 a b w`：将第 $a$ 片叶子和第 $b$ 片叶子之间的树枝长度改为 $w$。
## 输出格式

对于每个 `1` 操作，输出距离的最小值。如果当前没有任何一个葡萄，输出 `-1`。
## 样例

### 样例输入 #1
```
7 11
1 2 2
2 3 4
5 6 1
5 3 6
3 7 6
2 4 9
2 6
2 4
2 7
1 1
3 2 3 0
1 1
3 6 5 0
1 1
3 3 5 0
3 2 4 0
1 1

```
### 样例输出 #1
```
11
8
8
2
```
### 样例输入 #2
```
6 11
1 2 3
1 3 4
2 4 1
2 5 4
3 6 6
2 3
1 2
2 4
3 1 3 2
1 1
2 3
3 2 1 2
2 4
1 3
2 2
1 3

```
### 样例输出 #2
```
7
2
-1
4
```
### 样例输入 #3
```
7 8
1 2 2
2 3 3
3 6 2
4 6 1
5 6 4
6 7 3
2 3
1 4
2 3
2 5
1 1
3 6 7 4
1 5
1 7

```
### 样例输出 #3
```
3
11
0
8
```
## 提示

**【数据范围】**

|$\text{Subtask}$|分值|特殊性质|
|:-:|:-:|:-:|
|$0$|$0$|样例|
|$1$|$6$|$N,Q\le2000$|
|$2$|$14$|对于所有查询操作，保证 $q=1$|
|$3$|$15$|整个葡萄藤是一颗完全二叉树，$A_i=\lfloor\frac{i+1}{2}\rfloor,B_i=i+1$|
|$4$|$15$|在任意时刻整个葡萄藤上都最多只有一个葡萄|
|$5$|$18$|所有 `2` 操作都在 `1` 和 `3` 操作之前，且对于所有 `3` 操作，$w=0$|
|$6$|$32$|无|

对于 $100\%$ 的数据，$2 \le N \le 100000,1 \le Q \le 100000,1 \le A_i \not = B_i \le N,0 \le W_i \le 10^9$。


---

---
title: "[NOISG 2018 Finals] City Mapping【缺样例】"
layout: "post"
diff: 省选/NOI-
pid: P11597
tag: ['2018', '二分', '交互题', 'Special Judge', 'O2优化', '树链剖分', 'NOISG（新加坡）']
---
# [NOISG 2018 Finals] City Mapping【缺样例】
## 题目背景

译自 [NOISG 2018 Finals D. City Mapping](https://github.com/noisg/sg_noi_archive/tree/master/2018/tasks/citymapping)。

----------------

当你在洛谷提交本题时，需要注意：

- 本题仅支持 C++ 系列语言。
- 你的代码中不应该包含头文件 `citymapping.h`。
- 你的代码中应当有如下两行函数声明：
	```cpp
	long long get_distance(int X, int Y);
	void find_roads(int N, int Q, int A[], int B[], int W[]);
	```
    
如遇评测问题，请联系搬题人。
## 题目描述

**这是一道交互题。**

Silvermill 市是一座有 $N$ 个路口和 $N-1$ 条道路的城市。其中道路的编号为 $0$ 到 $N-2$。

第 $i$ 条道路双向连接了 $(A_i,B_i)$ 两个路口，从任意方向通过这条道路都需要花费 $W_i$ 分钟。保证任意两个路口之间都能通过道路互相到达。

为了避免交通堵塞，Silvermill 市的**每个路口连接的道路不会超过 $3$ 条**。

你的任务是画出 Silvermill 市的地图，也就是找出所有 $N-1$ 条道路的 $(A_i,B_i,W_i)$。

为了达到这个目的，你可以询问市长至多 $Q$ 次从任意一个路口 $X$ 到任意一个路口 $Y$ 最少需要多少分钟。

### 实现细节

在本题中，**你不需要，也不应该实现主函数**。

你需要实现如下函数：

```cpp
void find_roads(int N, int Q, int A[], int B[], int W[])
```

该函数包含两个输入参数和三个输出参数，将在评测时被运行恰好一次。输入参数为 $N,Q$，分别表示路口的数量和最大询问次数；输出参数为 $A,B,W$，你需要确定城市中的 $N-1$ 条道路，按题意中的含义以数组 $A,B,W$ 的形式返回。返回道路的顺序可以是任意的，同一道路端点的顺序也可以是任意的。

注意数组的下标是从 $0$ 开始的。

你可以调用下面的函数来完成任务：

```cpp
long long get_distance(int X, int Y)
```

该函数将返回一个整数，表示从路口 $X$ 到路口 $Y$ 最少需要多少分钟。如果你调用此函数超过 $Q$ 次，或提供无效的路口编号作为参数，程序将立刻终止，你将得到 Wrong Answer 的评测状态。
## 输入格式

示例测试程序如下方式读入数据：

第一行三个整数 $N,Q,S$，分别表示路口的数量、最大询问次数和子任务编号。

之后是 $N-1$ 行，每行三个整数 $(A_i,B_i,W_i)$，描述一条道路。
## 输出格式

示例测试程序可能会产生的输出如下：

- `Wrong Input Format`，意味着对示例测试程序的输入格式有误。
- `Wrong Answer: Reported list of edges differ from actual.`，意味着你确定的道路与实际情况不符。
- `Wrong Answer: get_distance() arguments out of range.`，意味着你在询问时提供了无效的路口编号作为参数。
- `Wrong Answer: Too many calls to get_distance().`，意味着你超出了最大询问次数限制。
- 包含两行信息，分别是 `Score: s%` 和 `Correct: x out of y queries used.`，意味着你获得了该测试点 $s\%$ 的分数，最大询问次数为 $y$ 次，你使用了其中的 $x$ 次。
## 提示

### 调用示例

我们考虑如下的城市地图，展示一种可能的函数调用过程。

![](https://cdn.luogu.com.cn/upload/image_hosting/m7bz8mwi.png)

假设此时最大询问次数 $Q=5\times 10^5$。

你的函数将这样被调用恰好一次：

```cpp
find_roads(5, 500000, A, B, W);
```

其中 $A,B,W$ 是定义在测试程序中的数组。

一种可能的交互过程如下：

- `get_distance(5, 4) = 10`：`get_distance` 函数返回从路口 $5$ 到达路口 $4$ 的最少分钟数。路线 $5\to 3\to 4$ 是最短的，需要 $10$ 分钟。
- `get_distance(2, 4) = 1`：`get_distance` 函数返回了从路口 $2$ 到达路口 $4$ 的最少分钟数。直接从 $2$ 走到 $4$ 是最短的，需要 $1$ 分钟。
- `get_distance(1, 3) = 15`：`get_distance` 函数返回了从路口 $1$ 到达路口 $3$ 的最少分钟数。路线 $1\to 4\to 3$ 是最短的，需要 $15$ 分钟。
- `get_distance(1, 2) = 9`：`get_distance` 函数返回了从路口 $1$ 到达路口 $2$ 的最少分钟数。路线 $1\to 4\to 2$ 是最短的，需要 $9$ 分钟。

此时，我们假设你的 `find_roads` 函数认为自己已经掌握了足够的信息，可以推导出正确的地图，所以将 $A,B,W$ 数组分别赋值为 $A=[3,4,4,5],B=[4,1,2,3],W=[7,8,1,3]$，然后终止。

这只是一种可能的答案，因为返回道路的顺序可以是任意的，同一道路端点的顺序也可以是任意的。

### 子任务

对于 $100\%$ 的数据，$2\le N\le1000$，$1\le A_i,B_i\le N$，$1\le W_i\le 10^9$。

| 子任务 | 得分 | $Q$ | 特殊性质及备注 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $9$ | $=5\times 10^5$ | $W_i=1$ |
| $2$ | $16$ | $=5\times 10^5$ | 无特殊限制 |
| $3$ | $13$ | $=12000$ | 每个路口最多连接两条道路，且 $W_i=1$ |
| $4$ | $19$ | $=12000$ | 每个路口最多连接两条道路 |
| $5$ | $43$ | $=25000$ | 无特殊限制，但有特殊的计分规则（请参阅**计分细则**） |

### 计分细则

子任务 $5$ 适用于以下的计分规则。你的得分依赖于你实现的函数询问的次数 $q$。

- 如果 $q>25000$，你将获得 $0$ 分。
- 如果 $12000<q\le 25000$，你将获得 $10-10\times \frac{q-12000}{13000}$ 分。
- 如果 $6500<q\le 12000$，你将获得 $40-30\times \frac{q-6500}{5500}$ 分。
- 如果 $q\le 6500$，你将获得 $43$ 分。

### 本地测试方式

我们在附件中下发了示例测试程序 `grader.cpp`，头文件 `citymapping.h`，你所需完成的代码的示例 `citymapping.cpp`，以及编译文件 `compile.sh`。

将这些文件置于同一文件夹下，使用 `compile.sh` 编译并运行生成的可执行文件，即可进行本地测试。

下发的示例测试程序与提交后使用的测试程序有所不同。

注意提交到洛谷上时有特殊的要求。


---

---
title: "[UTS 2024] Two Trees"
layout: "post"
diff: 省选/NOI-
pid: P12562
tag: ['线段树', '2024', '树链剖分', 'UOI（乌克兰）']
---
# [UTS 2024] Two Trees
## 题目描述

You are given two equal undirected trees $G$ and $H$ consisting of $n$ vertices. Trees are equal if, for all pairs of vertices $(u;v)$, the edge between $G_u$ and $G_v$ exists if and only if the edge between $H_u$ and $H_v$ exists.  

Some vertices can be connected to their version in another tree with an undirected edge. Especially, a leaf vertex $G_v$ can be connected to vertex $H_v$. Let us say that if leaf vertex $G_v$ is connected to $H_v$ directly, then vertex $v$ is **enabled**, and the vertex is **disabled** otherwise.

Initially, all leaf vertices are **disabled**. You are asked to handle the following queries:

- $1$ $v$ --- toggle the status of vertex $v$, if $v$ is **disabled** then change its status to **enabled** and vice versa otherwise;
- $2$ $u$ $v$ --- print the length of the shortest path from vertex $G_u$ to vertex $H_v$.
## 输入格式

The first line contains two integers $n$ and $q$ ($3 \le n \le 2 \cdot 10^5$; $1 \le q \le 2 \cdot 10^5$) --- number of vertices and queries, respectively.

Each of the following $n-1$ lines contains two integers $u$, $v$ $(1 \le u,v \le n)$ --- description of trees, edges $(G_u;G_v)$ and $(H_u;H_v)$.

Each of the following $q$ lines contains a description of queries. There are two possible query descriptions:

- $1$ $v$ $(1 \le v \le n)$ --- toggle the status of vertex $v$;
- $2$ $u$ $v$ $(1 \le u,v \le n)$ --- print the length of the shortest path from vertex $G_u$ to $H_v$.
## 输出格式

For each query of the second type, print a single integer in a single line --- the length of the shortest path between given vertices. If there is no such path, print $\texttt{-1}$.
## 样例

### 样例输入 #1
```
7 11
1 2
2 3
1 4
2 5
4 6
4 7
1 6
1 3
2 1 6
2 1 2
1 7
2 5 4
2 6 3
1 6
1 3
1 5
2 6 3
```
### 样例输出 #1
```
2
3
5
4
6
```
### 样例输入 #2
```
3 2
1 2
1 3
1 3
2 1 2
```
### 样例输出 #2
```
3
```
## 提示

Let $k$ be the number of queries of the second type.

- ($3$ points): $n \le 16$, $q \le 16$;
- ($3$ points): $n \le 16$, $q \le 2 \cdot 10^5$;
- ($2$ points): $n \le 2000$, $q \le 2 \cdot 10^5,k \le 5$;
- ($8$ points): $n \le 2000$, $q \le 2000$;
- ($9$ points): $n \le 2 \cdot 10^5$, $q \le 2 \cdot 10^5, k \le 5$;
- ($30$ points): $n \le 2 \cdot 10^5$, $q \le 2 \cdot 10^5$, there is no query of first type after query of second type;
- ($45$ points): no additional restrictions.


---

---
title: "[UOI 2021] 树上的强盗"
layout: "post"
diff: 省选/NOI-
pid: P12577
tag: ['线段树', '2021', '树链剖分', 'UOI（乌克兰）']
---
# [UOI 2021] 树上的强盗
## 题目描述

有 $n$ 个城市，编号从 $1$ 到 $n$。所有城市通过 $n-1$ 条道路连接，形成一个连通图。每条道路都有特定的长度。

已知编号为 $i$ 的城市在时间 $t_i$ 被编号为 $a_i$ 的强盗团伙占领（$1 \leq a_i \leq n$）。从被占领的时刻 $t_i$ 开始（包括 $t_i$ 时刻），只有 $a_i$ 号团伙的成员才能通过该城市。

你需要回答 $m$ 个如下形式的查询：

- `u v b T`：判断编号为 $b$ 的团伙成员能否在时间 $T$ 从城市 $u$ 前往城市 $v$。如果无法完成旅程，还需要输出路径上第一个无法通过的城市编号。在城市间移动需要花费时间，时间等于路的长度。

## 输入格式

第一行包含一个整数 $n$（$2 \leq n \leq 10^5$）——城市数量。

接下来的 $n-1$ 行，每行包含两个整数 $p_i$ 和 $d_i$（$1 \leq p_i < i$，$1 \leq d_i \leq 10^3$），表示城市 $i$ 和 $p_i$ 之间有一条长度为 $d_i$ 的道路。编号从 2 开始。

下一行包含 $n$ 个整数 $a_i$（$1 \leq a_i \leq n$），表示占领每个城市的强盗团伙编号。

下一行包含 $n$ 个整数 $t_i$（$1 \leq t_i \leq 10^9$），表示每个城市被占领的时间。

下一行包含一个整数 $m$（$1 \leq m \leq 10^5$）——查询数量。

最后 $m$ 行，每行包含四个整数 $u_i$, $v_i$, $b_i$, $T_i$（$1 \leq u_i, v_i, b_i \leq n$，$1 \leq T_i \leq 10^9$），分别表示查询的起点城市、终点城市、团伙编号和出发时间。

## 输出格式

对于每个查询，输出一行一个整数——路径上第一个无法通过的城市编号。如果全程可通行，输出 `-1`。

注意本题输入输出数据量较大，建议使用快速的输入输出方法，例如：
- C++ 中使用 `scanf/printf` 而非 `cin/cout`；
- Python 中使用 `sys.stdin.readline` 而非 `input`；
- 建议使用 PyPy 解释器运行 Python 代码。
## 样例

### 样例输入 #1
```
5
1 7
1 3
2 2
2 1
1 1 2 3 3
10 4 15 15 1
8
5 3 3 1
5 3 3 2
5 3 3 3
5 3 1 1
4 3 1 2
4 3 1 3
3 4 1 3
2 1 1 100
```
### 样例输出 #1
```
-1
1
2
5
-1
3
4
-1
```
### 样例输入 #2
```
5
1 4
1 1
1 1
1 4
3 2 2 2 2
4 4 6 7 5
5
5 2 4 7
1 1 1 3
4 2 1 9
1 4 3 7
3 4 2 4
```
### 样例输出 #2
```
5
-1
4
4
1
```
### 样例输入 #3
```
5
1 4
2 1
3 3
4 1
2 1 2 3 2
8 3 7 7 9
5
1 5 2 4
1 2 1 4
5 2 1 6
1 4 3 5
1 5 4 7
```
### 样例输出 #3
```
2
-1
4
2
2
```
## 提示

### 评分标准

1. （$7$ 分）：所有 $p_i = 1$；
2. （$9$ 分）：$n, m \leq 10^3$；
3. （$11$ 分）：$p_i = i-1$，$t_i = 1$；
4. （$18$ 分）：$p_i = i-1$，$a_i = 1$，$b_i = 2$；
5. （$15$ 分）：$p_i = i-1$；
6. （$11$ 分）：$t_i = 1$；
7. （$17$ 分）：$a_i = 1$，$b_i = 2$；
8. （$12$ 分）：无额外限制。

翻译由 DeepSeek V3 完成


---

---
title: "K-LCA"
layout: "post"
diff: 省选/NOI-
pid: P13644
tag: ['莫队', 'O2优化', '树链剖分']
---
# K-LCA
## 题目背景

成本越低，赚的越多！
## 题目描述

T 国由 $n$ 座城市组成，首都在 $1$ 号城市，有 $(n-1)$ 条道路连接着这些城，且所有城市都可以通过这些道路到达首都。

有 $q$ 轮旅行活动，第 $i$ 次旅游会有一个参数 $(l_i,r_i)$，每次都有 $k$ 个人，他们每个人都会在编号在 $[l_i,r_i]$ 的城市中选择一个城市作为出发点。为了让每个人都有独处空间，任意两人不会选择同一个城市。

然后他们开始进行旅行。由于靠近首都的城市更高级，所以旅行者会向首都方向移动。

最终他们会在一个城市会聚，然后旅行结束。旅游公司没有足够经费让旅行者去更高级的城市，所以旅游公司会让他们会聚的城市离首都尽可能远。

现在旅游公司问你，他们会聚的地方，离首都距离最远是多少？两个城市之间的距离定义为最短路径上城市的个数（包括路径端点的两个城市）。
## 输入格式

第一行三个数 $n,q,k$。

接下来 $(n-1)$ 行，每行两个正整数 $u,v$ 表示一条边。

接下来 $q$ 行，每行两个正整数 $l,r$ 表示一次询问。
## 输出格式

共 $q$ 行，第 $i$ 行表示第 $i$ 次询问的答案。
## 样例

### 样例输入 #1
```
5 7 2
1 2
1 3
2 4
2 5
1 3
1 4
1 5
2 4
2 5
3 5
4 5

```
### 样例输出 #1
```
1
2
2
2
2
2
2

```
## 提示

**本题有捆绑测试**，每个子任务均为 $20$ 分。

| 子任务编号 | $n$ | $q$ | 特殊性质 | 时间限制 | 子任务依赖 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| $0$ | $10^4$ | $10^4$ | 无 | 3s | 无 |
| $1$ | $2\times10^4$ | $5\times10^4$ | 无 | 3s | $0$ |
| $2$ | $5\times10^4$ | $5\times10^4$ | 无 | 5s | $1$ |
| $3$ | $10^5$ | $10^5$ | **有** | 7s | 无 |
| $4$ | $10^5$ | $10^5$ | 无 | 7s | $2,3$ |

特殊性质：树的形态是以 $1$ 结点为链顶的一条链

对于 $100\%$ 的数据，$n\le 10^5,q\le10^5,1< k\le n,r-l+1\ge k$。


---

---
title: "[NOIP 2016 提高组] 天天爱跑步"
layout: "post"
diff: 省选/NOI-
pid: P1600
tag: ['2016', '线段树', 'NOIP 提高组', '最近公共祖先 LCA', '树链剖分', '动态树 LCT', '差分']
---
# [NOIP 2016 提高组] 天天爱跑步
## 题目背景

NOIP2016 提高组 D1T2
## 题目描述

小 C 同学认为跑步非常有趣，于是决定制作一款叫做《天天爱跑步》的游戏。《天天爱跑步》是一个养成类游戏，需要玩家每天按时上线，完成打卡任务。

这个游戏的地图可以看作一棵包含 $n$ 个结点和 $n-1$ 条边的树，每条边连接两个结点，且任意两个结点存在一条路径互相可达。树上结点编号为从 $1$ 到 $n$ 的连续正整数。

现在有 $m$ 个玩家，第 $i$ 个玩家的起点为 $s_i$，终点为 $t_i$。每天打卡任务开始时，所有玩家在第 $0$ 秒同时从自己的起点出发，以每秒跑一条边的速度，不间断地沿着最短路径向着自己的终点跑去，跑到终点后该玩家就算完成了打卡任务。（由于地图是一棵树，所以每个人的路径是唯一的）

小 C 想知道游戏的活跃度，所以在每个结点上都放置了一个观察员。在结点 $j$ 的观察员会选择在第 $w_j$ 秒观察玩家，一个玩家能被这个观察员观察到当且仅当该玩家在第 $w_j$ 秒也正好到达了结点 $j$。小 C 想知道每个观察员会观察到多少人?

注意：我们认为一个玩家到达自己的终点后该玩家就会结束游戏，他不能等待一 段时间后再被观察员观察到。 即对于把结点 $j$ 作为终点的玩家：若他在第 $w_j$ 秒前到达终点，则在结点 $j$ 的观察员不能观察到该玩家；若他正好在第 $w_j$ 秒到达终点，则在结点 $j$ 的观察员可以观察到这个玩家。

## 输入格式

第一行有两个整数 $n$ 和 $m$。其中 $n$ 代表树的结点数量, 同时也是观察员的数量, $m$ 代表玩家的数量。

接下来 $n-1$ 行每行两个整数 $u$ 和 $v$，表示结点 $u$ 到结点 $v$ 有一条边。

接下来一行 $n$ 个整数，其中第 $j$ 个整数为 $w_j$ , 表示结点 $j$ 出现观察员的时间。

接下来 $m$ 行，每行两个整数 $s_i$，和 $t_i$，表示一个玩家的起点和终点。

对于所有的数据，保证 $1\leq s_i,t_i\leq n, 0\leq w_j\leq n$。

## 输出格式

输出 $1$ 行 $n$ 个整数，第 $j$ 个整数表示结点 $j$ 的观察员可以观察到多少人。

## 样例

### 样例输入 #1
```
6 3
2 3
1 2 
1 4 
4 5 
4 6 
0 2 5 1 2 3 
1 5 
1 3 
2 6 
```
### 样例输出 #1
```
2 0 0 1 1 1 
```
### 样例输入 #2
```
5 3 
1 2 
2 3 
2 4 
1 5 
0 1 0 3 0 
3 1 
1 4
5 5 
```
### 样例输出 #2
```
1 2 1 0 1 
```
## 提示

**样例 1 说明**

对于 $1$ 号点，$w_i=0$，故只有起点为 $1$ 号点的玩家才会被观察到，所以玩家 $1$ 和玩家 $2$ 被观察到，共有 $2$ 人被观察到。

对于 $2$ 号点，没有玩家在第 $2$ 秒时在此结点，共 $0$ 人被观察到。

对于 $3$ 号点，没有玩家在第 $5$ 秒时在此结点，共 $0$ 人被观察到。

对于 $4$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $5$ 号点，玩家 $1$ 被观察到，共 $1$ 人被观察到。

对于 $6$ 号点，玩家 $3$ 被观察到，共 $1$ 人被观察到。

**子任务**

每个测试点的数据规模及特点如下表所示。 

提示：数据范围的个位上的数字可以帮助判断是哪一种数据类型。

| 测试点编号 | $n=$ | $m=$ | 约定 |
| :--------: | :----: | :----: | :----: |
|     $1\sim 2$      |  $991$   |  $991$   | 所有人的起点等于自己的终点，即 $\forall i,\ s_i=t_i$  |
|     $3\sim 4$      |  $992$   |  $992$   | 所有 $w_j=0$  |
|     $5$      |  $993$   |  $993$   | 无  |
|     $6\sim 8$      |  $99994$   |  $99994$   | $\forall i\in[1,n-1]$，$i$ 与 $i+1$ 有边。即树退化成 $1,2,\dots,n$ 按顺序连接的链  |
|     $9\sim 12$      |  $99995$   |  $99995$   | 所有 $s_i=1$  |
|     $13\sim 16$      |  $99996$   |  $99996$   | 所有 $t_i=1$  |
|     $17\sim 19$      |  $99997$   |  $99997$   | 无  |
|     $20$      |  $299998$   |  $299998$   | 无  |



**提示**

（提示：由于原提示年代久远，不一定能完全反映现在的情况，现在已经对该提示做出了一定的修改，提示的原文可以在[该剪贴板](https://www.luogu.com.cn/paste/3fneb8m6)查看）

在最终评测时，调用栈占用的空间大小不会有单独的限制，但在我们的工作环境中默认会有 $1 \text{MiB}$ 的限制。 这可能会引起**函数调用层数较多时，程序发生栈溢出崩溃**，程序中**较深层数的递归**往往会导致这个问题。如果你的程序需要用到较大的栈空间，请务必注意该问题。

我们可以使用一些方法修改调用栈的大小限制。

- Linux

我们可以在终端中输入下列命令：`ulimit -s 1048576`。此命令的意义是，将调用栈的大小限制修改为 $1048576\text{KiB}=1 \text{GiB}$。

例如，对于如下程序 `sample.cpp`：

```cpp
#include <bits/stdc++.h>
using namespace std;
int f[1000005];
void dfs(int a){
	if(a == 0){
		f[a] = 0;
		return;
	}
	dfs(a - 1);
	f[a] = f[a - 1] + 1;
}
int main(){
	dfs(1000000);
	return 0;
}
```

将上述源代码用命令 `g++ sample.cpp -o sample` 编译为可执行文件 `sample` 后，使用 `./sample` 执行程序。

如果在没有使用命令 `ulimit -s 1048576` 的情况下运行该程序，`sample` 会因为栈溢出而崩溃；如果使用了上述命令后运行该程序，该程序则不会崩溃。

特别地，当你打开多个终端时，它们并不会共享该命令，你需要分别对它们运行该命令。

请注意，调用栈占用的空间会计入总空间占用中，和程序其他部分占用的内存共同受到内存限制。

- Windows

如果你使用 Windows 下的 Dev-C++，请选择 `工具-编译选项` 并在如下区域填入以下命令 `-Wl,--stack=1073741824`，填入后注意确认“编译时加入以下命令的”的框是**已勾选**状态。

此处 `1073741824` 的单位是 $\text{B/Bytes}$。

![](https://cdn.luogu.com.cn/upload/image_hosting/z6mbzfqo.png)  ![](https://cdn.luogu.com.cn/upload/image_hosting/zvrzkyq5.png)


---

---
title: "[SDOI2011] 染色"
layout: "post"
diff: 省选/NOI-
pid: P2486
tag: ['2011', '线段树', '各省省选', '山东', '树链剖分', '动态树 LCT']
---
# [SDOI2011] 染色
## 题目描述

给定一棵 $n$ 个节点的无根树，共有 $m$  个操作，操作分为两种：

1. 将节点 $a$ 到节点 $b$ 的路径上的所有点（包括 $a$ 和 $b$）都染成颜色 $c$。
2. 询问节点 $a$ 到节点 $b$ 的路径上的颜色段数量。

颜色段的定义是极长的连续相同颜色被认为是一段。例如 `112221` 由三段组成：`11`、`222`、`1`。
## 输入格式

输入的第一行是用空格隔开的两个整数，分别代表树的节点个数 $n$ 和操作个数 $m$。

第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数 $w_i$ 代表结点 $i$ 的初始颜色。

第 $3$ 到第 $(n + 1)$ 行，每行两个用空格隔开的整数 $u, v$，代表树上存在一条连结节点 $u$ 和节点 $v$ 的边。

第 $(n + 2)$ 到第 $(n + m + 1)$ 行，每行描述一个操作，其格式为：

每行首先有一个字符 $op$，代表本次操作的类型。

- 若 $op$ 为 `C`，则代表本次操作是一次染色操作，在一个空格后有三个用空格隔开的整数 $a, b, c$，代表将 $a$ 到 $b$ 的路径上所有点都染成颜色 $c$。
- 若 $op$ 为 `Q`，则代表本次操作是一次查询操作，在一个空格后有两个用空格隔开的整数 $a, b$，表示查询 $a$ 到 $b$ 路径上的颜色段数量。
## 输出格式

对于每次查询操作，输出一行一个整数代表答案。
## 样例

### 样例输入 #1
```
6 5
2 2 1 2 1 1
1 2
1 3
2 4
2 5
2 6
Q 3 5
C 2 1 1
Q 3 5
C 5 1 2
Q 3 5

```
### 样例输出 #1
```
3
1
2

```
## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，$1 \leq n, m \leq 10^5$，$1 \leq w_i, c \leq 10^9$，$1 \leq a, b, u, v \leq n$，$op$ 一定为 `C` 或 `Q`，保证给出的图是一棵树。

除原数据外，还存在一组不计分的 hack 数据。



---

---
title: "[AHOI2005] 航线规划"
layout: "post"
diff: 省选/NOI-
pid: P2542
tag: ['2005', '线段树', '各省省选', '安徽', 'O2优化', '最近公共祖先 LCA', '树链剖分']
---
# [AHOI2005] 航线规划
## 题目描述

对 Samuel 星球的探险已经取得了非常巨大的成就，于是科学家们将目光投向了 Samuel 星球所在的星系——一个巨大的由千百万星球构成的 Samuel 星系。

星际空间站的 Samuel II 巨型计算机经过长期探测，已经锁定了 Samuel 星系中 $n$ 个星球的空间坐标，并对这些星球以 $1$ 至 $n$ 依次编号。

一些先遣飞船已经出发，在星球之间开辟探险航线。

探险航线是双向的，例如从 $1$ 号星球到 $3$ 号星球开辟探险航线，那么从 $3$ 号星球到 $1$ 号星球也可以使用这条航线。

例如下图所示：

 ![](https://cdn.luogu.com.cn/upload/pic/1644.png) 

在 $5$ 个星球之间，有 $5$ 条探险航线。

$A,B$ 两星球之间，如果某条航线不存在，就无法从 $A$ 星球抵达 $B$ 星球，我们则称这条航线为关键航线。

显然上图中，$1$ 号与 $5$ 号星球之间的关键航线有 $1$ 条：即为 $4\leftrightarrow5$ 航线。

然而，在宇宙中一些未知的磁暴和行星的冲撞，使得已有的某些航线被破坏，随着越来越多的航线被破坏，探险飞船又不能及时恢复这些航线，可见两个星球之间的关键航线会越来越多。

假设在上图中，航线 $4\leftrightarrow2$（从 $4$ 号星球到 $2$ 号星球）被破坏。此时，$1$ 号与 $5$ 号星球之间的关键航线就有 $3$ 条：$1 \leftrightarrow 3$，$3 \leftrightarrow 4$，$4 \leftrightarrow 5$。

小联的任务是，不断关注航线被破坏的情况，并随时给出两个星球之间的关键航线数目。现在请你帮助完成。

## 输入格式

第一行有两个整数，分别表示星球个数 $n$ 和初始时的航线条数 $m$。

接下来 $m$ 行，每行有两个不相同的整数 $u, v$，表示星球 $u$ 和星球 $v$ 之间存在一条航线。

接下来有若干行，每行首先给出一个整数 $op$，表示一次操作的类型。

- 若 $op = 1$，则后接两个整数 $u, v$，表示询问当前 $u, v$ 两星球之间有多少关键航线。
- 若 $op = 0$，则后接两个整数 $u, v$，表示 $u, v$ 之间的航线被破坏。
- 若 $op = -1$，则表示输入结束，后面不再存在操作。

## 输出格式

对每个 $op = 1$ 的询问，输出一行一个整数表示关键航线数目。

## 样例

### 样例输入 #1
```
5 5
1 2
1 3
3 4
4 5
4 2
1 1 5
0 4 2
1 5 1
-1
```
### 样例输出 #1
```
1
3
```
## 提示

#### 数据规模与约定

对于全部的测试点，保证：

- $1 \leq n \leq 3 \times 10^4$，$1 \leq m \leq 10^5$。
- $-1 \leq op \leq 1$，$1 \leq u, v \leq n$。
- 无论航线如何被破坏，任意时刻任意两个星球都能够相互到达。在整个数据中，任意两个星球之间最多只可能存在一条直接的航线。
- 对于 $op = 0$ 的操作，保证操作前航线 $u \leftrightarrow v$ 存在。
- 询问与破坏航线的总次数不超过 $4 \times 10^4$。


---

---
title: "[USACO11JAN] Bottleneck G"
layout: "post"
diff: 省选/NOI-
pid: P3006
tag: ['2011', '线段树', 'USACO', '最短路', '树链剖分']
---
# [USACO11JAN] Bottleneck G
## 题目描述

Farmer John is gathering the cows. His farm contains a network of N (1 <= N <= 100,000) fields conveniently numbered 1..N and connected by N-1 unidirectional paths that eventually lead to field 1. The fields and paths form a tree.

Each field i > 1 has a single one-way, exiting path to field P\_i, and currently contains C\_i cows (1 <= C\_i <= 1,000,000,000). In each time unit, no more than M\_i (0 <= M\_i <= 1,000,000,000) cows can travel from field i to field P\_i (1 <= P\_i <= N) (i.e., only M\_i cows can traverse the path).

Farmer John wants all the cows to congregate in field 1 (which has no limit on the number of cows it may have). Rules are as follows:

\* Time is considered in discrete units.

\* Any given cow might traverse multiple paths in the same time unit. However, no more than M\_i total cows can leave field i (i.e., traverse its exit path) in the same time unit.

\* Cows never move \*away\* from field #1.

In other words, every time step, each cow has the choice either to

a) stay in its current field

b) move through one or more fields toward field #1, as long as the bottleneck constraints for each path are not violated

Farmer John wants to know how many cows can arrive in field 1 by certain times. In particular, he has a list of K (1 <= K <= 10,000) times T\_i (1 <= T\_i <= 1,000,000,000), and he wants to know, for each T\_i in the list, the maximum number of cows that can arrive at field 1 by T\_i if scheduled to optimize this quantity.

Consider an example where the tree is a straight line, and the T\_i list contains only T\_1=5, and cows are distibuted as shown:

```cpp
Locn:      1---2---3---4      <-- Pasture ID numbers 
C_i:       0   1   12  12     <-- Current number of cows 
M_i:           5   8   3      <-- Limits on path traversal; field 1 has no limit since it has no exit 
The solution is as follows; the goal is to move cows to field 1: 
```
Tree:      1---2---3---4
```cpp
t=0        0   1   12  12     <-- Initial state 
t=1        5   4   7   9      <-- field 1 has cows from field 2 and 3 t=2        10  7   2   6 
t=3        15  7   0   3 
t=4        20  5   0   0 
t=5        25  0   0   0 
Thus, the answer is 25: all 25 cows can arrive at field 1 by time t=5. 

## 输入格式

\* Line 1: Two space-separated integers: N and K

\* Lines 2..N: Line i (not i+1) describes field i with three 

space-separated integers: P\_i, C\_i, and M\_i

\* Lines N+1..N+K: Line N+i contains a single integer: T\_i

## 输出格式

\* Lines 1..K: Line i contains a single integer that is the maximum number of cows that can arrive at field 1 by time T\_i.

## 样例

### 样例输入 #1
```
4 1 
1 1 5 
2 12 7 
3 12 3 
5 

```
### 样例输出 #1
```
25 

```
## 题目翻译

WC正在召集奶牛,他的农场有一个包含 ***N*** 块农田的网络，编号为 **1 -- N** ，每个农场里有 $C_i$ 头牛。农场被 **N-1**  条 **单向** 边链接,（每个农场有通向$P_i$的路） 保证从任何点可以到达1号点。WC想让所有奶牛集中到1号农场。 

**时间是离散的** 奶牛可以在1单位时间里走过任意多条道路，但是每条路有一个容纳上限 *$M_i$*  并且奶牛不会离开1号农场(农场没有容量上限) 

### 每一个单位时间，奶牛可以选择如下几种行动 
1. 留在当前的农场
2. 经过几条道路，向1号农场移动（需要满足$M_i$）

WC想要知道有多少牛可以在某个特定的时刻到达1号农场，
他有一张列着 ***K*** 个时间（分别为$T_i$)的单子
，他想知道在每个$T_i$, 采用最优策略在$T_i$结束最多能有多少牛到1号农场

### 数据范围如下：
$1 \le N \le  10^5$

$1 \le C_i \le  10^9$

$0 \le M_i \le 10^9$

$1 \le P_i \le N$

$1 \le K \le 10^4$

$1 \le T_i \le 10^9$


## **输入输出格式**
* 输入格式
 
    *第一行：两个整数 N 和 K
    
    *第2—N行，第i行描述一块农场及它的路 $P_i \;C_i\;M_i$

    *第N+1 - N+K行， 第N+i 一个整数 $T_i$
* 输出格式
    
    *每行一个答案对应$T_i$

感谢@ToBiChi 提供翻译


---

---
title: "[HNOI2016] 网络"
layout: "post"
diff: 省选/NOI-
pid: P3250
tag: ['2016', '线段树', '湖南', '最近公共祖先 LCA', '树链剖分']
---
# [HNOI2016] 网络
## 题目描述

一个简单的网络系统可以被描述成一棵无根树。每个节点为一个服务器。连接服务器与服务器的数据线则看做一条树边。两个服务器进行数据的交互时，数据会经过连接这两个服务器的路径上的所有服务器（包括这两个服务器自身）。

由于这条路径是唯一的，当路径上的某个服务器出现故障，无法正常运行时，数据便无法交互。此外，每个数据交互请求都有一个重要度，越重要的请求显然需要得到越高的优先处理权。现在，你作为一个网络系统的管理员，要监控整个系统的运行状态。系统的运行也是很简单的，在每一个时刻，只有可能出现下列三种事件中的一种：

1. 在某两个服务器之间出现一条新的数据交互请求；  
2. 某个数据交互结束请求；
3. 某个服务器出现故障。系统会在任何故障发生后立即修复。也就是在出现故障的时刻之后，这个服务器依然是正常的。但在服务器产生故障时依然会对需要经过该服务器的数据交互请求造成影响。

你的任务是在每次出现故障时，维护未被影响的请求中重要度的最大值。注意，如果一个数据交互请求已经结束，则不将其纳入未被影响的请求范围。

## 输入格式

第一行两个正整数 $n,m$，分别描述服务器和事件个数。服务器编号是从 $1$ 开始的，因此 $n$ 个服务器的编号依次是 $1,2,3,\cdots,n$。

接下来 $n-1$ 行，每行两个正整数 $u,v$，描述一条树边。$u$ 和 $v$ 是服务器的编号。

接下来 $m$ 行，按发生时刻依次描述每一个事件；即第 $i$ 行（$i=1,2,3,...,m$）描述时刻 $i$ 发生的事件。每行的第一个数 $\mathrm{type}$ 描述事件类型，共 $3$ 种类型：

1. 若 $\mathrm{type}=0$，之后有三个正整数 $a,b,v$，表示服务器 $a,b$ 之间出现一条重要度为 $v$ 的数据交互请求；
2. 若 $\mathrm{type}=1$，之后有一个正整数 $t$，表示时刻 $t$（也就是第 $t$ 个发生的事件）出现的数据交互请求结束；
3. 若 $\mathrm{type}=2$，之后有一个正整数 $x$，表示服务器 $x$ 在这一时刻出现了故障。

对于每个 $\mathrm{type}$ 为 $2$ 的事件，就是一次询问，即询问“当服务器 $x$ 发生故障时，未被影响的请求中重要度的最大值是多少？”注意可能有某个服务器自身与自身进行数据交互的情况。$2 \le n \le 10^5$，$1 \le m \le 2\times 10^5$，其他的所有输入值不超过 $10^9$。

## 输出格式

对于每个 $\mathrm{type}=2$ 的事件，即服务器出现故障的事件，输出一行一个整数，描述未被影响的请求中重要度的最大值。如果此时没有任何请求，或者所有请求均被影响，则输出 $-1$。

## 样例

### 样例输入 #1
```
13 23
1 2
1 3
2 4
2 5
3 6
3 7
4 8
4 9
6 10
6 11
7 12
7 13
2 1
0 8 13 3
0 9 12 5
2 9
2 8
2 2
0 10 12 1
2 2
1 3
2 7
2 1
0 9 5 6
2 4
2 5
1 7
0 9 12 4
0 10 5 7
2 1
2 4
2 12
1 2
2 5
2 3
```
### 样例输出 #1
```
-1 
3 
5 
-1 
1 
-1 
1 
1 
3 
6 
7 
7 
4 
6
```
## 提示

样例给出的树如下所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/ka4zpxia.png)

解释其中的部分询问；下面的解释中用 $(a,b;t,v)$ 表示在 $t$ 时刻出现的服务器 $a$ 和 $b$ 之间的重要度为 $v$ 的请求：

对于第一个询问（在时刻 $1$），此时没有任何请求，输出 $-1$。

对于第四个询问（在时刻 $6$），此时有两条交互$(8,13;2,3),(9,12;3,5)$，所有询问均经过 $2$ 号服务器，输出 $-1$。

对于第五个询问（在时刻 $8$），此时有三条交互 $(8,13;2,3),(9,12;3,5),(10,12;7,1)$，只有交互 $(10,12;7,1)$ 没有经过 $2$ 号服务器，因此输出其重要度 $1$。

对于最后一个询问（在时刻 $23$），此时有三条交互 $(9,5;12,6),(9,12;16,4),(10,5;17,7)$。当 $3$ 号服务器出现故障时，只有交互 $(9,5;12,6)$ 没有经过 $3$ 号服务器，因此输出 $6$。

$\text{upd 2016.5.20}$：新加一组 $\text{Hack}$ 数据。


---

---
title: "[SDOI2014] 旅行"
layout: "post"
diff: 省选/NOI-
pid: P3313
tag: ['2014', '线段树', '山东', '树链剖分', '分块']
---
# [SDOI2014] 旅行
## 题目描述

S 国有 $N$ 个城市，编号从 $1$ 到 $N$。城市间用 $N-1$ 条双向道路连接，满足从一个城市出发可以到达其它所有城市。每个城市信仰不同的宗教，如飞天面条神教、隐形独角兽教、绝地教都是常见的信仰。

为了方便，我们用不同的正整数代表各种宗教，S 国的居民常常旅行。旅行时他们总会走最短路，并且为了避免麻烦，只在信仰和他们相同的城市留宿。当然旅程的终点也是信仰与他相同的城市。S 国为每个城市标定了不同的旅行评级，旅行者们常会记下途中（包括起点和终点）留宿过的城市的评级总和或最大值。

在 S 国的历史上常会发生以下几种事件：

- `CC x c`：城市 $x$ 的居民全体改信了 $c$ 教；
- `CW x w`：城市 $x$ 的评级调整为 $w$；
- `QS x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级总和；
- `QM x y`：一位旅行者从城市 $x$ 出发，到城市 $y$，并记下了途中留宿过的城市的评级最大值。

由于年代久远，旅行者记下的数字已经遗失了，但记录开始之前每座城市的信仰与评级，还有事件记录本身是完好的。请根据这些信息，还原旅行者记下的数字。 为了方便，我们认为事件之间的间隔足够长，以致在任意一次旅行中，所有城市的评级和信仰保持不变。
## 输入格式

输入的第一行包含整数 $N,Q$ 依次表示城市数和事件数。

接下来 $N$ 行，第 $i+1$ 行两个整数 $W_i,C_i$ 依次表示记录开始之前，城市 $i$ 的评级和信仰。

接下来 $N-1$ 行每行两个整数 $x,y$ 表示一条双向道路。

接下来 $Q$ 行，每行一个操作，格式如上所述。
## 输出格式

对每个 `QS` 和 `QM` 事件，输出一行，表示旅行者记下的数字。
## 样例

### 样例输入 #1
```
5 6
3 1
2 3
1 2
3 3
5 1
1 2
1 3
3 4
3 5
QS 1 5
CC 3 1
QS 1 5
CW 3 3
QS 1 5
QM 2 4
```
### 样例输出 #1
```
8
9
11
3
```
## 提示

对于 $100\%$ 的数据，$N,Q \leq10^5,C \leq10^5$

数据保证对所有 `QS` 和 `QM` 事件，起点和终点城市的信仰相同；在任意时刻，城市的评级总是不大于 $10^4$ 的正整数，且宗教值不大于 $C$。


---

---
title: "洛谷树"
layout: "post"
diff: 省选/NOI-
pid: P3401
tag: ['线段树', '洛谷原创', '树链剖分', '洛谷月赛']
---
# 洛谷树
## 题目背景

萌哒的 Created_equal 小仓鼠种了一棵洛谷树！

（题目背景是辣鸡小仓鼠乱写的 QAQ）。

## 题目描述

树是一个无环、连通的无向图，由 $n$ 个点和 $n-1$ 条边构成。树上两个点之间的路径被定义为他们之间的唯一一条简单路径——显然这是一条最短路径。

现在引入一个概念——子路径。假设树上两个点 $p_1$ 和 $p_n$ 之间的路径是 $P = \langle p_1,p_2,p_3, \ldots, p_n \rangle $，那么它的子路径被定义为某一条路径 $P'$，满足 $P'= \langle p_i,p_{i+1},p_{i+2},\ldots,p_j \rangle $，其中 $1\le i \le j \le n$。显然，原路径是一条子路径，任意一个点也可以作为子路径。

我们给每条边赋予一个边权。萌萌哒的 Sugar 问小仓鼠：对于任意两个点 $u$ 和 $v$，你能快速求出，$u$ 到 $v$ 的路径上所有子路径经过的边的边权的 $\text{xor}$ 值的和是多少。具体地说就是，你把 $u$ 到 $v$ 的路径上所有子路径全部提出来，然后分别把每个子路径上经过的边的边权 $\text{xor}$ 在一起，最后求出得到的所有 $\text{xor}$ 值的和。

什么？你不知道 $\text{xor}$？那就去百度啊！

这时候，fjzzq2002 大爷冒了粗来：窝还要你滋磁修改某条边边权的操作！

小仓鼠那么辣鸡，当然不会做这道题啦。于是他就来向你求救！

## 输入格式

第一行两个正整数 $n$ 和 $q$，表示点的个数，查询和询问的总次数。

接下来 $n-1$ 行，每行两个正整数 $u,v$ 和一个非负整数 $w$，表示 $u$ 和 $v$ 两个点之间有一条边权为 $w$ 的边。

接下来 $q$ 行，格式为 `1 u v` 或 `2 u v w`。   
如果为 `1 u v` 操作，你需要输出 $u$ 到 $v$ 的路径上所有子路径经过的边的边权的 $\text{xor}$ 值的和是多少。  
如果为 `2 u v w` 操作，你需要把 $u$ 到 $v$ 这条边的边权改为 $w$，保证这条边存在。

## 输出格式

对于每个 $1$ 操作，输出答案。

## 样例

### 样例输入 #1
```
5 3
1 2 3
2 3 3
2 4 6
4 5 1
1 3 4
2 2 4 7
1 3 5
```
### 样例输出 #1
```
14
26

```
## 提示

|测试点编号|$n=$|$q=$|备注|
|:-:|:-:|:-:|:-:|
|$1$|$100$|$5$|无|
|$2$|$100$|$20$|无|
|$3$|$100$|$100$|无|
|$4$|$5\times 10^3$|$10^3$|无|
|$5$|$5\times 10^3$|$2\times 10^3$|无|
|$6$|$5\times 10^3$|$3\times 10^3$|无|
|$7$|$10^4$|$10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点，且没有 $2$ 操作|
|$8$|$10^4$|$2\times 10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点，且没有 $2$ 操作|
|$9$|$10^4$|$10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点|
|$10$|$10^4$|$2\times 10^4$|第 $i$ 条边连接第 $i$ 个点和第 $i+1$ 个点|
|$11$|$10^4$|$10^4$|没有 $2$ 操作|
|$12$|$10^4$|$2\times 10^4$|没有 $2$ 操作|
|$13$|$2\times 10^4$|$2\times 10^4$|没有 $2$ 操作|
|$14$|$3\times 10^4$|$3\times 10^4$|没有 $2$ 操作|
|$15$|$3\times 10^4$|$10^4$|无|
|$16$|$2\times 10^4$|$2\times 10^4$|无|
|$17$|$2\times 10^4$|$2\times 10^4$|无|
|$18$|$3\times 10^4$|$2\times 10^4$|无|
|$19$|$2\times 10^4$|$3\times 10^4$|无|
|$20$|$3\times 10^4$|$3\times 10^4$|无|

对于 $100\%$ 的数据，所有边权小于等于 $1023$。



---

---
title: "小清新数据结构题"
layout: "post"
diff: 省选/NOI-
pid: P3676
tag: ['点分治', '洛谷原创', 'O2优化', '树链剖分', '动态树 LCT', '洛谷月赛']
---
# 小清新数据结构题
## 题目背景

**本题时限2s，内存限制256M**

## 题目描述

在很久很久以前，有一棵n个点的树，每个点有一个点权。

现在有q次操作，每次操作是修改一个点的点权或指定一个点，询问以这个点为根时每棵子树点权和的平方和。

（题目不是很好懂，没看太懂的可以看看样例解释）

## 输入格式

第一行两个整数n、q。

接下来n-1行每行两个整数a和b，表示树中a与b之间有一条边，保证给出的边不会重复。

接下来一行n个整数，第i个整数表示第i个点的点权。

接下来q行每行两或三个数，如果第一个数为1，那么接下来有两个数x和y，表示将第x个点的点权修改为y，如果第一个数为2，那么接下来有一个数x，表示询问以x为根时每棵子树点权和的平方和。

## 输出格式

对于每个询问输出答案。

## 样例

### 样例输入 #1
```
4 5
1 2
2 3
2 4
4 3 2 1
2 2
1 1 3
2 3
1 2 4
2 4
```
### 样例输出 #1
```
121
140
194
```
## 提示

##### 样例解释

这是一个菊花图，2与1、3、4间有边。

一开始每个点点权分别为4、3、2、1。

第一个询问以2为根，1、3、4子树中都只有本身一个点，2子树中有所有点，那么1、3、4子树中的点权和就分别是自己的点权4、2、1，2子树中的点权和就是4+3+2+1=10，$4^2+2^2+1^1+10^2=121$。

接下来将第一个点点权修改为3，每个点点权分别为3、3、2、1。

第二个询问以3为根，1、4子树中只有自己，2子树中有1、2、4，3子树中有所有点，1、4子树点权和就是自己的点权3、1，2子树点权和就是3+3+1=7，3子树点权和为3+3+2+1=9，$3^2+1^2+7^2+9^2=140$。

接下来把第二个点点权修改为4，每个点点权分别为3、4、2、1。

第三个询问以4为根，1、3子树点权和就是3和2，2子树点权和就是3+4+2=9，4子树点权和为3+4+2+1=10，$3^2+2^2+9^2+10^2=194$。

##### 数据范围

对于10%的数据，$n,q \leq 2000$。

对于40%的数据，$n,q \leq 60000$。

对于另外30%的数据，保证每次询问的根都为1。

对于100%的数据，$1 \leq n,q \leq 200000$，$-10 \leq$输入的每个点权$\leq 10$。

建议使用输入优化~~，虽然标程没加读入优化也能过~~



---

---
title: "[CERC2016] 机棚障碍 Hangar Hurdles"
layout: "post"
diff: 省选/NOI-
pid: P3684
tag: ['2016', '树链剖分']
---
# [CERC2016] 机棚障碍 Hangar Hurdles
## 题目描述

你正在评估一些关于一个巨型飞机仓库的建设计划。飞机仓库的地面可以表示为 $n$ 行 $n$ 列的网格图，其中每个格子要么是空的，要么有障碍物。行从上到下依次被编号为 $1$ 到 $n$，列从左到右依次被编号为 $1$ 到 $n$。

存放飞机零件的大型集装箱能在飞机仓库的地面上自由移动是很重要的。我们可以将每个集装箱看作一个以某个格子为中心的边平行于坐标轴的正方形。对于一个奇数 $k$，一个尺寸为 $k$ 的集装箱是一个包含 $k$ 行 $k$ 列的正方形。一个集装箱的坐标为其中心格子的坐标。集装箱可以向上下左右移动，但不能碰到障碍物，且不能移出仓库的边界。

给定 $q$ 对格子 $A_k$ 和 $B_k$，对于每对格子，请找到能从 $A_k$ 移动到 $B_k$ 的集装箱的最大尺寸，注意这个尺寸也要是一个奇数。
## 输入格式

第一行包含一个正整数 $n$（$2\le n \le 1000$），表示仓库的尺寸。

接下来 $n$ 行，每行 $n$ 个字符，描述整个仓库，其中 `.` 表示空格子，`#` 表示障碍物。

接下来一行包含一个正整数 $q$（$1\le q\le 300000$），表示询问的个数。

接下来 $q$ 行，每行四个正整数 $A_x,A_y,B_x,B_y$（$1\le A_x,A_y,B_x,B_y\le n$），分别表示 $A$ 和 $B$ 的坐标。

输入数据保证 $A$ 和 $B$ 是不同的空格子。
## 输出格式

输出 $q$ 行，每行一个整数，对于每个询问输出最大尺寸，如果不存在解，那么输出 $0$。
## 样例

### 样例输入 #1
```
7
.....#.
...#.#.
....#..
....###
....#..
#......
.......
5
2 5 5 2
2 5 3 6
2 2 6 3
2 2 6 6
1 1 7 7
```
### 样例输出 #1
```
1
0
3
1
1
```


---

---
title: "【模板】动态树（LCT）"
layout: "post"
diff: 省选/NOI-
pid: P3690
tag: ['O2优化', '树链剖分', '动态树 LCT']
---
# 【模板】动态树（LCT）
## 题目描述

给定 $n$ 个点以及每个点的权值，要你处理接下来的 $m$ 个操作。  
操作有四种，操作从 $0$ 到 $3$ 编号。点从 $1$ 到 $n$ 编号。


- `0 x y` 代表询问从 $x$ 到 $y$ 的路径上的点的权值的 $\text{xor}$ 和。保证 $x$ 到 $y$ 是联通的。
- `1 x y` 代表连接 $x$ 到 $y$，若 $x$ 到 $y$ 已经联通则无需连接。
- `2 x y` 代表删除边 $(x,y)$，不保证边 $(x,y)$ 存在。
- `3 x y` 代表将点 $x$ 上的权值变成 $y$。

## 输入格式

第一行两个整数，分别为 $n$ 和 $m$，代表点数和操作数。

接下来 $n$ 行，每行一个整数，第 $(i + 1)$ 行的整数 $a_i$ 表示节点 $i$ 的权值。

接下来 $m$ 行，每行三个整数，分别代表操作类型和操作所需的量。

## 输出格式

对于每一个 $0$ 号操作，你须输出一行一个整数，表示 $x$ 到 $y$ 的路径上点权的 $\text{xor}$ 和。

## 样例

### 样例输入 #1
```
3 3 
1
2
3
1 1 2
0 1 2 
0 1 1
```
### 样例输出 #1
```
3
1

```
### 样例输入 #2
```
5 14
114
514
19
19
810
1 1 2
0 1 2
2 1 2
1 1 2
1 2 3
2 1 3
1 1 3
1 4 5
1 2 5
0 3 5
0 3 4
3 5 233333
0 1 5
0 2 5

```
### 样例输出 #2
```
624
315
296
232709
232823

```
## 提示

#### 数据规模与约定

对于全部的测试点，保证：
- $1 \leq n \leq 10^5$，$1 \leq m \leq 3 \times 10^5$，$1 \leq a_i \leq 10^9$。
- 对于操作 $0, 1, 2$，保证 $1 \leq x, y \leq n$。
- 对于操作 $3$，保证 $1 \leq x \leq n$，$1 \leq y \leq 10^9$。



---

---
title: "[SDOI2017] 树点涂色"
layout: "post"
diff: 省选/NOI-
pid: P3703
tag: ['2017', '线段树', '各省省选', '山东', '树链剖分', '动态树 LCT']
---
# [SDOI2017] 树点涂色
## 题目描述

Bob 有一棵 $n$ 个点的有根树，其中 $1$ 号点是根节点。Bob 在每个点上涂了颜色，并且每个点上的颜色不同。

定义一条路径的权值是：这条路径上的点（包括起点和终点）共有多少种不同的颜色。

Bob可能会进行这几种操作：

- `1 x` 表示把点 $x$ 到根节点的路径上所有的点染上一种没有用过的新颜色。


- `2 x y` 求 $x$ 到 $y$ 的路径的权值。

- `3 x` 在以 $x$ 为根的子树中选择一个点，使得这个点到根节点的路径权值最大，求最大权值。


Bob一共会进行 $m$ 次操作

## 输入格式

第一行两个数 $n,m$。

接下来 $n-1$ 行，每行两个数 $a,b$，表示 $a$ 与 $b$ 之间有一条边。

接下来 $m$ 行，表示操作，格式见题目描述
## 输出格式

每当出现 $2,3$ 操作，输出一行。

如果是 $2$ 操作，输出一个数表示路径的权值

如果是 $3$ 操作，输出一个数表示权值的最大值

## 样例

### 样例输入 #1
```
5 6
1 2
2 3
3 4
3 5
2 4 5
3 3
1 4
2 4 5
1 5
2 4 5
```
### 样例输出 #1
```
3
4
2
2
```
## 提示

共 $10$ 个测试点。

测试点 $1$，$1\leq n,m\leq1000$；

测试点 $2,3$，没有 $2$ 操作；

测试点 $4,5$，没有 $3$ 操作；

测试点 $6$，树的生成方式是，对于 $i(2\leq i \leq n)$，在 $1 \sim i-1$ 中随机选一个点作为 $i$ 的父节点；

测试点 $7$，$1\leq n,m\leq 5\times 10^4$；

测试点 $8$，$1\leq n \leq 5 \times 10^4$；

测试点9,10，无特殊限制

对所有数据，$1\leq n \leq 10^5$，$1\leq m \leq 10^5$。



---

---
title: "aaa被续"
layout: "post"
diff: 省选/NOI-
pid: P3925
tag: ['线段树', '树状数组', '洛谷原创', 'O2优化', '树链剖分', '洛谷月赛']
---
# aaa被续
## 题目背景

HansBug持续无聊ing

## 题目描述

由于aaa没有完成HansBug的任务。所以HansBug开始计划着如何续aaa。

现在HansBug手里有 $ N $个aaa，每个aaa有一个码力值。一共存在 $ N - 1 $条连接两个aaa的边，故这 $ N $个aaa构成一棵**有根树**，根为1号aaa。

现在HansBug想要续了这 $ N $个aaa。HansBug所采用的策略是，对于第 $ i$个aaa，先让他和他的各级子aaa们~~乖乖♂站好~~成一队，然后依次续掉。

经过长期对于aaa码力值的研究，HansBug发现，**对于每一队aaa**，设有 $n$个，码力值依次为$ v_i $，则续了队伍里的第 $ i $个aaa所能获得的码力值为 $ v_1 + v_2 + \cdots + v_i $。


然而，aaa之间的关系树相当的复杂，HansBug的智商早已不够用，于是这个任务就交给了你。不过HansBug知道，任何一个aaa都不会有超过5个的直接子aaa

HansBug想要知道在每次排♂队方法最优的情况下，续了这些aaa最多可以获得的码力值~~，事成之后分给你100000 % 10点码力值~~。

## 输入格式

第一行包含一个正整数 $ N $，表示aaa的个数。

接下来 $ N-1 $行，每行包含两个正整数 $ u, v$，代表第 $u $个aaa和第 $ v $个aaa之间存在从属关系（最高级别的aaa编号为 $ 1$）

最后一行包含 $ N $个非负整数，依次代表第 $ i $个aaa的码力值。

## 输出格式

输出包含一个整数，打表HansBug续掉全部的aaa之后最多能获得的码力值。

**由于结果较大，所以请对 $ 1000000007 $ 取模 （$ {10} ^ 9 + 7 $）**

## 样例

### 样例输入 #1
```
5
5 3
1 2
1 5
4 5
3 9 10 4 7 

```
### 样例输出 #1
```
189

```
## 提示

**样例解释：**

 ![](https://cdn.luogu.com.cn/upload/pic/7980.png) 

故续了5个aaa所得的最大总码力值为：118 + 9 + 10 + 4 + 48 = 189

**对1000000007取模后得到答案189**


**数据范围：**

对于30%的数据：$ 1 \leq N \leq 3 \cdot {10}^3 $

对于50%的数据：$ 1 \leq N \leq 2 \cdot {10}^4 $

对于70%的数据：$ 1 \leq N \leq {10}^5 $

对于100%的数据：$ 1 \leq N \leq 5 \cdot {10}^5 $

对于每一个aaa的码力值 $ a_i $，保证 $ 0 \leq a_i \leq {10}^8 $



---

---
title: "[TJOI2015] 旅游"
layout: "post"
diff: 省选/NOI-
pid: P3976
tag: ['2015', '线段树', '各省省选', '树链剖分', '动态树 LCT', '天津']
---
# [TJOI2015] 旅游
## 题目描述

为了提高智商，ZJY 准备去往一个新世界去旅游。这个世界的城市布局像一棵树，每两座城市之间只有一条路径可以互达。  

每座城市都有一种宝石,有一定的价格。ZJY 为了赚取最高利益,她会选择从 A 城市买入再转手卖到 B 城市。  

由于ZJY买宝石时经常卖萌，因而凡是 ZJY 路过的城市，这座城市的宝石价格会上涨。让我们来算算 ZJY 旅游完之后能够赚取的最大利润。(如 A 城市宝石价格为 $v$，则ZJY出售价格也为 $v$)

## 输入格式

第一行输入一个正整数 $n$ 表示城市个数

接下来一行输入 $n$ 个正整数表示每座城市宝石的最初价格 $p$,每个宝石的初始价格不超过 $100$。

第三行开始连续输入 $n-1$ 行,每行有两个数字 $x$ 和 $y$。表示 $x$ 城市和 $y$ 城市有一条路径。城市编号从$1$开始。  

下一行输入一个正整数 $q$ 表示询问次数。

接下来 $q$ 行每行输入三个正整数 $a,b,v$，表示 ZJY 从 $a$ 旅游到 $b$，城市宝石上涨 $v$。

## 输出格式

对于每次询问，输出 ZJY 可能获得的最大利润，如果亏本了则输出 $0$。

## 样例

### 样例输入 #1
```
3
1 2 3
1 2
2 3
2
1 2 100
1 3 100
```
### 样例输出 #1
```
1
1
```
### 样例输入 #2
```
5
1 2 3 4 5
1 2
1 3
2 4
4 5
6
1 5 50
2 4 500
3 4 5000
3 5 50000
1 3 500000
2 3 5000000

```
### 样例输出 #2
```
4
2
551
551
0
499499
```
## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \le 100$，$q \le 10^4$。
- 对于 $100\%$ 的数据，保证 $1\le n,q \le 5\times 10^4$，在任何时刻任何城市的宝石价格都不超过 $10^9$。



---

---
title: "遥远的国度"
layout: "post"
diff: 省选/NOI-
pid: P3979
tag: ['线段树', '倍增', '最近公共祖先 LCA', '树链剖分']
---
# 遥远的国度
## 题目描述

`zcwwzdjn` 在追杀 `zhx` ，而 `zhx` 逃入了一个遥远的国度。当 `zcwwzdjn` 准备进入遥远的国度继续追杀时，守护神 `RapiD` 阻拦了 `zcwwzdjn` 的去路，他需要 `zcwwzdjn` 完成任务后才能进入遥远的国度继续追杀。

问题是这样的：遥远的国度有 $n$ 个城市，这些城市之间由一些路连接且这些城市构成了一颗树。这个国度有一个首都，我们可以把这个首都看做整棵树的根，但遥远的国度比较奇怪，首都是随时有可能变为另外一个城市的。遥远的国度的每个城市有一个防御值，第 $i$ 个的防御值为 $val_i$，有些时候 `RapiD` 会使得某两个城市之间的路径上的所有城市的防御值都变为某个值。

`RapiD` 想知道在某个时候，如果把首都看做整棵树的根的话，那么以某个城市为根的子树的所有城市的防御值最小是多少。

由于 `RapiD` 无法解决这个问题，所以他拦住了 `zcwwzdjn` 希望他能帮忙。但 `zcwwzdjn` 还要追杀 `zhx`，所以这个重大的问题就被转交到了你的手上。
## 输入格式

第 $1$ 行两个整数 $n\ m$，代表城市个数和操作数。

第 $2$ 行至第 $n$ 行，每行两个整数 $u\ v$，代表城市 $u$ 和城市 $v$ 之间有一条路。

第 $n+1$ 行，有 $n$ 个整数，第 $i$ 个代表第 $i$ 个点的初始防御值 $val_i$。

第 $n+2$ 行一个整数 $id$，代表初始的首都为 $id$。

第 $n+3$ 行至第 $n+m+2$ 行，首先有一个整数 $opt$。

如果 $opt=1$，接下来有一个整数 $id$，代表把首都修改为 $id$；

如果 $opt=2$，接下来有三个整数 $x\ y\ v$，代表将 $x\ y$ 路径上的所有城市的防御值修改为 $v$；

如果 $opt=3$，接下来有一个整数 $id$，代表询问以城市 $id$ 为根的子树中的最小防御值。
## 输出格式

对于每个 $opt=3$ 的操作，输出一行代表对应子树的最小点权值。
## 样例

### 样例输入 #1
```
3 7
1 2
1 3
1 2 3
1
3 1
2 1 1 6
3 1
2 2 2 5
3 1
2 3 3 4
3 1
```
### 样例输出 #1
```
1
2
3
4
```
## 提示

对于 $20\%$ 的数据，$n\le 1000,m\le 1000$。

对于另外 $10\%$ 的数据，$n\le 100000,m\le 100000$，保证修改为单点修改。

对于另外 $10\%$ 的数据，$n\le100000,m \le 100000$，保证树为一条链。

对于另外 $10\%$ 的数据，$n\le 100000,m\le100000$，没有修改首都的操作。

对于 $100\%$ 的数据，$1 \leq n\le 100000,1 \leq m \le 100000,0<val_i<2^{31}$。


---

---
title: "树链剖分"
layout: "post"
diff: 省选/NOI-
pid: P3995
tag: ['Special Judge', 'O2优化', '树链剖分', '期望', '差分']
---
# 树链剖分
## 题目背景

树链剖分，计算机术语，指一种对树进行划分的算法，它先通过轻重边剖分将树分为多条链，保证每个点属于且只属于一条链，然后再通过数据结构（树状数组、SBT、SPLAY、线段树等）来维护每一条链。(摘自百度百科)

## 题目描述

大宁最近在研究树链剖分。他发现树链剖分的时间复杂度主要由轻重链的划分方式保证，最常见的剖分方式是按照子树大小剖分。如图（摘自百度百科），黑边为重链，长度任意，白边为轻链，长度全部为1。注意，下图 1-2, 1-3 为不同轻链。

 ![](https://cdn.luogu.com.cn/upload/pic/11502.png) 

其中对于每个节点，其在重链上的儿子叫做重儿子，且只有唯一一个，而叶子节点没有重儿子。例如对于图上 1 号点，重儿子是 4 号点。显然，对于不同剖分方式，同一组查询访问的链的数量不同。现在给定一棵根为 1 号节点的有根树和若干询问操作，每次询问访问从 $u$ 到 $v$ 上面的所有轻重链一次。例如在上图的剖分方式中，查询 3 到 8 一共访问了 3 条：轻链 1-3，重链 1-4，轻链 4-8；查询 3 到 11 一共访问了 3 条：轻链 1-3，轻链 1-2，重链 2-11。

大宁请你给出一种剖分方案，使所有询问操作总共访问的**轻重链总条数**最小，由于可能有许多合法方案，请任意输出一种，我们提供Special Judge检验你的方案的正确性。

设你的剖分方式的查询链数为 $x$，std 答案的查询数为 $x_0$，评分参数为 $a$ 。

你得到的分数是：

* $10$ 分  当 $x\leq x_0$ 。

* $8$ 分  当 $0<(x-x_0)\leq a$ 。

* $7$ 分  当 $a<(x-x0)\leq 2\times a$ 。

* $6$ 分  当 $2\times a<(x-x0)\leq 3\times a$ 。

* $1$ 分  输出了合法的方案。



$a=\lfloor\frac{q}{300}\rfloor$, $q$ 为询问总数。

我们提供了 `Div\_Checker.exe` 来检验你的答案。把它放到 `div.in` , `div.out` 同文件夹下运行，其中 `div.in` 是输入数据的文件形式, `div.out` 是你的程序在该输入下的输出。如果你的 `div.out` 答案合法，它会返回：

`Your answer is XXX.`

`XXX` 是你的剖分方式在该输入数据下的查询次数，否则返回：

`Wrong Outdata.`

**注意: 在正式提交的时候不能使用文件输入输出。**

## 输入格式

第一行有两个正整数 $n$ 和 $q$ ，表示该树的节点数 $n$ 和查询次数 $q$ 。

接下来 $n-1$ 行，各有两个正整数 $u$ ，$v$ ，表示 $u$ 和 $v$ 之间有一条边。

接下来 $q$ 行为 $q$ 个询问，为 $U$，$V$，表示有一次从 $U$ 到 $V$ 的询问。

## 输出格式

一共 $n$ 行，对于 $i$ 号节点，如果它不是叶子节点，那么输出它在你的剖分方案里的重儿子，否则输出 0。

## 样例

### 样例输入 #1
```
14 7
1 4
4 10
4 9
4 8
9 13
13 14
3 1
7 3
2 1
2 6
6 12
11 6
5 2
11 3
7 8
2 8
11 1
8 14
5 7
9 14

```
### 样例输出 #1
```
2
6
7
8
0
11
0
0
13
0
0
0
14
0

```
## 提示

样例即为上图，但图上的剖分方式对于此处的查询并非最优。

对于 $20\%$ 的数据，$n,q<=10$

对于 $60\%$ 的数据，$n,q<=1000$

对于 $100\%$ 的数据，$1<=n<=100000$,$1<=q<=200000$ ,保证给出的是一棵合法的树。

[Div\_Checker下载](https://pan.baidu.com/s/1c26OLf6)

如果对Checker的使用方式不太理解，请参照下面的图片

图中数据为样例。

 ![](https://cdn.luogu.com.cn/upload/pic/11563.png) 

一个合法方案的输出。

 ![](https://cdn.luogu.com.cn/upload/pic/11564.png) 

不合法方案的输出。

![](https://cdn.luogu.com.cn/upload/pic/11565.png)

---

$\text{upd 2022.8.26}$：新增加一组 Hack 数据。


---

---
title: "[SDOI2016] 游戏"
layout: "post"
diff: 省选/NOI-
pid: P4069
tag: ['2016', '线段树', '各省省选', '山东', '最近公共祖先 LCA', '树链剖分']
---
# [SDOI2016] 游戏
## 题目描述

Alice 和 Bob 在玩一个游戏。

游戏在一棵有 $n$ 个点的树上进行。最初，每个点上都只有一个数字，那个数字是 $123456789123456789$。

有时，Alice 会选择一条从 $s$ 到 $t$ 的路径，在这条路径上的每一个点上都添加一个数字。对于路径上的一个点 $r$，若 $r$ 与 $s$ 的距离是 $dis$，那么 Alice 在点 $r$ 上添加的数字是 $a\times dis+b$。

有时，Bob 会选择一条从 $s$ 到 $t$ 的路径。他需要先从这条路径上选择一个点，再从那个点上选择一个数字。

Bob 选择的数字越小越好，但大量的数字让 Bob 眼花缭乱。Bob 需要你帮他找出他能够选择的最小的数字。

## 输入格式

第一行两个数字 $n,m$，表示树的点数和进行的操作数。

接下来 $n-1$ 行，每行三个数字 $u,v,w$，表示树上有一条连接 $u,v$ 的边，长度是 $w$。

接下来 $m$ 行。每行第一个数字是 $1$ 或 $2$。

若第一个数是 $1$，表示 Alice 进行操作，接下来四个数字 $s,t,a,b$。

若第一个数是 $2$，表示 Bob 进行操作，接下来两个数字 $s,t$。

## 输出格式

每当 Bob 进行操作，输出一行一个数，表示他能够选择的最小的数字

## 样例

### 样例输入 #1
```
3 5
1 2 10
2 3 20
2 1 3
1 2 3 5 6
2 2 3
1 2 3 -5 -6
2 2 3
```
### 样例输出 #1
```
123456789123456789
6
-106
```
## 提示

测试点 1 ~ 2：$ n \leq 10 $，$ m \leq 10 $，$ | a | \leq 10000 $；

测试点 3 ~ 4：$ n \leq 1000 $，$ m \leq 1000 $，$ | a | \leq 10000 $；

测试点 5：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 0 $，树是一条链；

测试点 6 ~ 7：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 0 $；

测试点 8：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 1 $，树是一条链；

测试点 9 ~ 10：$ n \leq 100000 $，$ m \leq 100000 $，$ a = 1 $；

测试点 11 ~ 13：$ n \leq 100000 $，$ m \leq 100000 $，$ | a | \leq 10000 $，树是一条链；

测试点 14 ~ 20：$ n \leq 100000 $，$ m \leq 100000 $，$ | a | \leq 10000 $。

对于所有数据，$0\le w, |b|\le 10^9$。


---

---
title: "Qtree4"
layout: "post"
diff: 省选/NOI-
pid: P4115
tag: ['点分治', '堆', 'O2优化', '分治', '树链剖分']
---
# Qtree4
## 题目背景

#欢迎提供更强的数据，本题目支持无限加数据（可私信，百度网盘地址）

#数据范围和spoj略有不同

## 题目描述

给出一棵边带权的节点数量为n的树，初始树上所有节点都是白色。有两种操作：

C x，改变节点x的颜色，即白变黑，黑变白

A，询问树中最远的两个白色节点的距离，这两个白色节点可以重合(此时距离为0)。

## 输入格式

In the first line there is an integer N (N <= 100000)

In the next N-1 lines, the i-th line describes the i-th edge: a line with three integers a b c denotes an edge between a, b of value c (-1000 <= c <= 1000)

In the next line, there is an integer Q denotes the number of instructions (Q <= 200000)

In the next Q lines, each line contains an instruction "C a" or "A"

## 输出格式

For each "A" operation, write one integer representing its result. If there is no white node in the tree, you should write "They have disappeared.".

## 样例

### 样例输入 #1
```
3
1 2 1
1 3 1
7
A
C 1
A
C 2
A
C 3
A
```
### 样例输出 #1
```
2
2
0
They have disappeared.
```


---

---
title: "[CTSC2008] 网络管理"
layout: "post"
diff: 省选/NOI-
pid: P4175
tag: ['2008', '线段树', '平衡树', '树状数组', '树链剖分', '可持久化线段树', 'CTSC/CTS']
---
# [CTSC2008] 网络管理
## 题目描述

M 公司是一个非常庞大的跨国公司，在许多国家都设有它的下属分支机构或部门。为了让分布在世界各地的 $n$ 个部门之间协同工作，公司搭建了一个连接整个公司的通信网络。  

该网络的结构由 $n$ 个路由器和 $n-1$ 条高速光缆组成。每个部门都有一个专属的路由器，部门局域网内的所有机器都联向这个路由器，然后再通过这个通信子网与其他部门进行通信联络。该网络结构保证网络中的任意两个路由器之间都存在一条直接或间接路径以进行通信。   

高速光缆的数据传输速度非常快，以至于利用光缆传输的延迟时间可以忽略。但是由于路由器老化，在这些路由器上进行数据交换会带来很大的延迟。而两个路由器之间的通信延迟时间则与这两个路由器通信路径上所有路由器中最大的交换延迟时间有关。  

作为 M 公司网络部门的一名实习员工，现在要求你编写一个简单的程序来监视公司的网络状况。该程序能够随时更新网络状况的变化信息（路由器数据交换延迟时间的变化），并且根据询问给出两个路由器通信路径上延迟第 $k$ 大的路由器的延迟时间。
****
【任务】   
你的程序从输入文件中读入 $n$ 个路由器和 $n-1$ 条光缆的连接信息，每个路由器初始的数据交换延迟时间 $t_i$，以及 $q$ 条询问（或状态改变）的信息。并依次处理这 $q$ 条询问信息，它们可能是：

1. 由于更新了设备，或者设备出现新的故障，使得某个路由器的数据交换延迟时间发生了变化。

2. 查询某两个路由器 $a$ 和 $v$ 之间的路径上延迟第 $k$ 大的路由器的延迟时间。

## 输入格式

第一行为两个整数 $n$ 和 $q$，分别表示路由器总数和询问的总数。

第二行有 $n$ 个整数，第 $i$ 个数表示编号为i的路由器初始的数据延迟时间 $t_i$。

紧接着 $n-1$ 行，每行包含两个整数 $x$ 和 $y$。表示有一条光缆连接路由器 $x$ 和路由器 $y$。

紧接着是 $q$ 行，每行三个整数 $k,a,b$。

如果 $k=0$，则表示路由器 $a$ 的状态发生了变化，它的数据交换延迟时间由 $t_a$ 变为 $b$。

如果 $k>0$，则表示询问 $a$ 到 $b$ 的路径上所经过的所有路由器（包括 $a$ 和 $b$）中延迟第 $k$ 大的路由器的延迟时间。注意 $a$ 可以等于 $b$，此时路径上只有一个路由器。

## 输出格式

对于每一个第二种询问（即 $k>0$ ），输出一行。  
包含一个整数为相应的延迟时间。如果路径上的路由器不足 $k$ 个，则输出信息 `invalid request!`。

## 样例

### 样例输入 #1
```
5 5
5 1 2 3 4
3 1
2 1
4 3
5 3
2 4 5
0 1 2
2 2 3
2 1 4
3 3 5
```
### 样例输出 #1
```
3
2
2
invalid request!
```
## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le n,q \le 80000$，$0 \le k \le n$，任意一个路由器在任何时刻都满足延迟时间小于 $10^8$。




---

---
title: "[LNOI2014] LCA"
layout: "post"
diff: 省选/NOI-
pid: P4211
tag: ['2014', '线段树', '各省省选', '辽宁', '最近公共祖先 LCA', '树链剖分', '差分', '离线处理']
---
# [LNOI2014] LCA
## 题目描述

给出一个 $n$ 个节点的有根树（编号为 $0$ 到 $n-1$，根节点为 $0$）。

一个点的深度定义为这个节点到根的距离 $+1$。 

设 $dep[i]$ 表示点 $i$ 的深度，$\operatorname{LCA}(i, j)$ 表示 $i$ 与 $j$ 的最近公共祖先。 

有 $m$ 次询问，每次询问给出 $l, r, z$，求 $\sum_{i=l}^r dep[\operatorname{LCA}(i,z)]$ 。
## 输入格式

第一行 $2$ 个整数，$n, m$。

接下来 $n-1$ 行，分别表示点 $1$ 到点 $n-1$ 的父节点编号。

接下来 $m$ 行，每行 $3$ 个整数，$l, r, z$。
## 输出格式

输出 $m$ 行，每行表示一个询问的答案。每个答案对 $201314$ 取模输出。
## 样例

### 样例输入 #1
```
5 2
0
0
1
1
1 4 3
1 4 2
```
### 样例输出 #1
```
8
5
```
## 提示

### 数据范围及约定

- 对于 $20\%$ 的数据，$n\le 10000,m\le 10000$；
- 对于 $40\%$ 的数据，$n\le 20000,m\le 20000$；
- 对于 $60\%$ 的数据，$n\le 30000,m\le 30000$；
- 对于 $80\%$ 的数据，$n\le 40000,m\le 40000$；
- 对于 $100\%$ 的数据，$1\le n\le 50000,1\le m\le 50000$。


---

---
title: "[SCOI2015] 情报传递"
layout: "post"
diff: 省选/NOI-
pid: P4216
tag: ['2015', '四川', '线段树', '各省省选', '平衡树', '树链剖分', '可持久化线段树']
---
# [SCOI2015] 情报传递
## 题目描述

奈特公司是一个巨大的情报公司，它有着庞大的情报网络。情报网络中共有 $n$ 名情报员。每名情报员可能有若干名 (可能没有) 下线，除 $1$ 名大头目外其余 $n-1$ 名情报员有且仅有 $1$ 名上线。奈特公司纪律森严，每名情报员只能与自己的上、下线联系，同时，情报网络中任意两名情报员一定能够通过情报网络传递情报。

奈特公司每天会派发以下两种任务中的一个任务：

1. 搜集情报：指派 $T$ 号情报员搜集情报；
2. 传递情报：将一条情报从 $X$ 号情报员传递给 $Y$ 号情报员。

情报员最初处于潜伏阶段，他们是相对安全的，我们认为此时所有情报员的危险值为 $0$；一旦某个情报员开始搜集情报，他的危险值就会持续增加，每天增加 $1$ 点危险值 (开始搜集情报的当天危险值仍为 $0$，第 $2$ 天危险值为 $1$，第 $3$ 天危险值为 $2$，以此类推)。传递情报并不会使情报员的危险值增加。

为了保证传递情报的过程相对安全，每条情报都有一个风险控制值 $C$。奈特公司认为，参与传递这条情报的所有情报员中，危险值大于 $C$ 的情报员将对该条情报构成威胁。现在，奈特公司希望知道，对于每个传递情报任务，参与传递的情报员有多少个，其中对该条情报构成威胁的情报员有多少个。
## 输入格式

第一行包含一个正整数 $n$，表示情报员个数。
笫二行包含 $n$ 个非负整数，其中第 $i$ 个整数 $P_i$ 表示 $i$ 号情报员上线的编号。特别地，若 $P_i=0$，表示 $i$ 号情报员是大头目。
第三行包含一个正整数 $q$，表示奈特公司将派发 $q$ 个任务 (每天一个)。

随后 $q$ 行，依次描述 $q$ 个任务。每行首先有一个正整数 $k$。

- 若 $k=1$，表示任务是传递情报，随后有三个正整数 $X_i$、$Y_i$、$C_i$，依次表示传递情报的起点、终点和风险控制值。
- 若 $k=2$，表示任务是搜集情报，随后有 $1$ 个正整数 $T_i$，表示搜集情报的情报员编号。
## 输出格式

对于每个传递情报任务输出一行，包含两个整数，分别是参与传递情报的情报员个数和对该条情报构成威胁的情报员个数。
## 样例

### 样例输入 #1
```
7
0 1 1 2 2 3 3 
6
1 4 7 0
2 1
2 4
2 7
1 4 7 1
1 4 7 3
```
### 样例输出 #1
```
5 0
5 2
5 1
```
## 提示

样例解释：

对于 $3$ 个传递情报任务，都是经过 $5$ 名情报员，分别是 $4$ 号、$2$ 号、$1$ 号、$3$ 号和 $7$ 号。

- 第 $1$ 个任务，所有情报员 (危险值为 $0$) 都不对情报构成威胁；
- 第 $2$ 个任务，有 $2$ 名情报员对情报构成威胁，分别是 $1$ 号情报员 (危险值为 $3$) 和 $4$ 号情报员 (危险值为 $2$)，$7$ 号情报员 (危险值为 $1$) 并不构成威胁；
- 第 $3$ 个任务，只有 $1$ 名情报员对情报构成威胁。

数据范围：

$n\leqslant 2\times 10^5,Q\leqslant 2\times 10^5,0<P_i,C_i\leqslant N,1\leqslant T_i,X_i,Y_i\leqslant n$。


---

---
title: "[BJOI2014] 大融合"
layout: "post"
diff: 省选/NOI-
pid: P4219
tag: ['2014', '树链剖分', '动态树 LCT', '线段树分治']
---
# [BJOI2014] 大融合
## 题目描述

小强要在 $N$ 个孤立的星球上建立起一套通信系统。这套通信系统就是连接 $N$ 个点的一个树。

这个树的边是一条一条添加上去的。

在某个时刻，一条边的负载就是它所在的当前能够联通的树上路过它的简单路径的数量。

![](https://cdn.luogu.com.cn/upload/pic/13969.png)

例如，在上图中，现在一共有了 $5$ 条边。其中，$(3,8)$ 这条边的负载是 $6$，因为有六条简单路径 $2-3-8$,$2-3-8-7$,$3-8,3-8-7$,$4-3-8$,$4-3-8-7$ 路过了 $(3,8)$。

现在，你的任务就是随着边的添加，动态的回答小强对于某些边的负载的询问。
## 输入格式

第一行包含两个整数  $N, Q$,表示星球的数量和操作的数量。星球从 $1$ 开始编号。

接下来的 $Q$  行，每行是如下两种格式之一：

 - ```A x y``` 表示在 $x$ 和 $y$ 之间连一条边。保证之前 $x$ 和 $y$ 是不联通的。
 - ```Q x y```表示询问 $(x,y)$ 这条边上的负载。保证 $x$ 和 $y$ 之间有一条边。
## 输出格式

对每个查询操作，输出被查询的边的负载。
## 样例

### 样例输入 #1
```
8 6
A 2 3
A 3 4
A 3 8
A 8 7
A 6 5
Q 3 8
```
### 样例输出 #1
```
6
```
## 提示

对于所有数据，$1≤N,Q≤10^5$


---

---
title: "道路相遇"
layout: "post"
diff: 省选/NOI-
pid: P4320
tag: ['图论', '倍增', 'O2优化', '树链剖分', '圆方树']
---
# 道路相遇
## 题目描述

在 H 国的小 w 决定到从城市 $u$ 到城市 $v$ 旅行，但是此时小 c 由于各种原因不在城市 $u$，但是小 c 决定到在中途与小 w 相遇

由于 H 国道路的原因，小 w 从城市 $u$ 到城市 $v$ 的路线不是固定的，为了合理分配时间，小 c 想知道从城市 $u$ 到城市 $v$ 有多少个城市小 w 一定会经过，特别地，$u, v$ 也必须被算进去，也就是说无论如何答案不会小于 2

由于各种特殊的原因，小 c 并不知道小 w 的起点和终点，但是小 c 知道小 w 的起点和终点只有 $q$ 种可能，所以对于这 $q$ 种可能，小 c 都想知道小 w 一定会经过的城市数

H 国所有的边都是无向边，两个城市之间最多只有一条道路直接相连，没有一条道路连接相同的一个城市

任何时候，H 国不存在城市 $u$ 和城市 $v$ 满足从 $u$ 无法到达 $v$
## 输入格式

第一行两个正整数 $n,m$，表示 H 国的城市数，以及道路数。

下面 $m$ 行，每行两个不同的正整数 $u, v$，表示城市 $u$ 到城市 $v$ 之间有一条边。

然后一行一个正整数 $q$。
接下来 $q$ 行，每行两个正整数 $u, v$ 表示小 w 旅行的一种可能的路线
## 输出格式

输出共 $q$ 行，每行一个正整数
## 样例

### 样例输入 #1
```
5 6
1 2
1 3
2 3
3 4
4 5
3 5
1
1 5
```
### 样例输出 #1
```
3
```
## 提示

从城市 $1$ 到城市 $5$ 总共有 $4$ 种可能 : 

$1 \to 2 \to 3 \to 4 \to 5$

$1 \to 2 \to 3 \to 5$

$1 \to 3 \to 4 \to 5$

$1 \to 3 \to 5$

可以发现小 w 总会经过城市 $1,3,5$，所以答案为 $3$

你可以认为小 w 不会经过相同的城市两次，当然，如果你认为可以经过相同的城市两次也不会影响答案

subtask1 : 15分，$m = 5, q = 50$

subtask2 : 15分，$n = 100, q = 5000$

subtask3 : 20分，$n = 3000, q = 5\times 10^5$

subtask4 : 20分，$n = 499999, q = 5 \times 10^5, m = n-1$

subtask5 : 30分，$n = q = 5 \times 10^5$

对于所有数据 : $1\leq n\leq 5 \times 10^5, 1\leq q\leq 5\times 10^5, 1\leq m\leq \min(\frac{n(n-1)}{2}, 10^6)$


---

---
title: "[SHOI2014] 三叉神经树"
layout: "post"
diff: 省选/NOI-
pid: P4332
tag: ['模拟', '2014', '线段树', '各省省选', '上海', 'O2优化', '分治', '树链剖分', '动态树 LCT']
---
# [SHOI2014] 三叉神经树
## 题目描述

计算神经学作为新兴的交叉学科近些年来一直是学术界的热点。一种叫做 SHOI 的神经组织因为其和近日发现的化合物 SHTSC 的密切联系引起了人们的极大关注。

SHOI 组织由若干个 SHOI 细胞构成，SHOI 细胞之间形成严密的树形结构。每个 SHOI 细胞都有且只有一个输出端,被称为轴突,除了一个特殊的、被称为根细胞的 SHOI 细胞的输出作为整个组织的输出以外,其余细胞的轴突均连向其上级 SHOI 细胞；并且有且只有三个接收端,被称为树突,从其下级细胞或者其它神经组织那里接收信息。SHOI 细胞的信号机制较为简单,仅有 $0$和 $1$ 两种。每个 SHOI 细胞根据三个输入端中 $0$和 $1$ 信号的多寡输出较多的那一种。

现在给出了一段 SHOI 组织的信息，以及外部神经组织的输入变化情况。请你模拟 SHOI 组织的输出结果。
## 输入格式

输入的第一行包含一个整数 $n$。表示 SHOI 组织的总细胞个数。SHOI 细胞由 $1\sim n$ 编号,编号为 $1$ 的是根细胞。

从第二行开始的 $n$ 行,每行三个整数 $x_1, x_2, x_3$，分别表示编号为 $1\sim n$ 的 SHOI 细胞的树突连接。$1 < x_i \leq n$ 表示连向编号为 $x_i$ 的细胞的轴突, $n < x_i \leq 3n+1$ 表示连向编号为 $x_i$ 的外界输入。输入数据保证给出的 SHOI 组织是合法的，且所有的 $x_i$ 两两不同。

接下来一行包含 $2n+1$ 个整数（$0$ 或者 $1$），表示初始时的外界输入。

第 $n+3$ 行有一个整数 $q$，表示总操作数。

之后 $q$ 行，每行一个整数 $x$，表示编号为 $x$ 的外界输入发生了变化。
## 输出格式

输出共 $q$ 行，每行一个整数，对应第 $i$ 次外界输入变化后的根细胞的输出。
## 样例

### 样例输入 #1
```
3
2 3 4
5 6 7
8 9 10
0 0 0 0 1 1 1
5
4
4
5
6
8

```
### 样例输出 #1
```
1
0
0
1
1

```
## 提示

- 对于 $10 \%$ 的数据，满足 $1\le n \leq 10^3$，$ 1\le q \leq 10^3$。
- 对于 $30 \%$ 的数据，满足 $1\le n \leq 10^5$，$ 1\le q \leq 10^5$。
- 对于 $100 \%$ 的数据，满足 $1\le n \leq 5\times 10^5$，$ 1\le q \leq 5\times 10^5$。


---

---
title: "[ZJOI2011] 道馆之战"
layout: "post"
diff: 省选/NOI-
pid: P4679
tag: ['2011', '线段树', '浙江', '树链剖分']
---
# [ZJOI2011] 道馆之战
## 题目描述

口袋妖怪（又名神奇宝贝或宠物小精灵）红/蓝/绿宝石中的水系道馆需要经过三个冰地才能到达馆主的面前，冰地中的每一个冰块都只能经过一次。当一个冰地上的所有冰块都被经过之后，到下一个冰地的楼梯才会被打开。

三个冰地分别如下：

![](https://cdn.luogu.com.cn/upload/image_hosting/4tq073ig.png)

当走出第三个冰地之后，就可以与馆主进行道馆战了。馆主发现这个难度太小，导致经常有挑战者能通过，为了加大难度，将道馆分成了$n$个房间，任意两个房间之间均有且仅有一条路径相连，即这$n$个房间构成一个树状结构。每个房间分成了$A$和$B$两个区域，每一区域都是一个薄冰块或者障碍物。每次只能移动到相邻房间的同一类区域（即若你现在在这个房间的$A$区域，那么你只能移动到相邻房间的$A$区域）或这个房间的另一区域。现在挑战者从房间$u$出发，馆主在房间$v$，那么挑战者只能朝接近馆主所在房间的方向过去。一开始挑战者可以在房间$u$的任意一个冰块区域内。如果挑战者踩过的冰块数达到了最大值（即没有一种方案踩过的冰块数更多了），那么当挑战者走到最后一个冰块上时，他会被瞬间传送到馆主面前与馆主进行道馆战。自从馆主修改规则后已经经过了$m$天，每天要么是有一个挑战者来进行挑战，要么就是馆主将某个房间进行了修改。对于每个来的挑战者，你需要计算出他若要和馆主进行战斗需要经过的冰块数。
## 输入格式

第一行包含两个正整数$n$和$m$。

第$2$行到第$n$行，每行包含两个正整数$x$和$y$，表示一条连接房间$x$和房间$y$的边。房间编号为$1\cdots n$。

接下来$n$行，每行包含两个字符。第$n+k$行表示房间$k$的两个区域，第一个字符为$A$区域，第二个字符为$B$区域。其中“.”（ASCII码为46）表示是薄冰块，“#”（ASCII码为35）表示是障碍物。

最后的$m$行，每行一个操作：

$C$ $u$ $s$：将房间$u$里的两个区域修改为$s$。

$Q$ $u$ $v$：询问挑战者在房间$u$，馆主在房间$v$时，挑战者能与馆主进行挑战需要踩的冰块数。如果房间$u$的两个区域都是障碍物，那么输出$0$。
## 输出格式

包含若干行，每行一个整数。即对于输入中的每个询问，依次输出一个答案。
## 样例

### 样例输入 #1
```
5 3
1 2
2 3
2 4
1 5
.#
..
#.
.#
..
Q 5 3
C 1 ##
Q 4 5

```
### 样例输出 #1
```
6
3
```
## 提示

测试点$1$~$6$：$n≤1000,m≤10000$

测试点$7$~$15$：$n≤30000,m≤80000$

测试点$16$~$20$：$n≤50000,m≤100000$


---

---
title: "【模板】动态 DP"
layout: "post"
diff: 省选/NOI-
pid: P4719
tag: ['线段树', 'O2优化', '树链剖分', '矩阵乘法', '动态 DP']
---
# 【模板】动态 DP
## 题目描述

给定一棵 $n$ 个点的树，点带点权。

有 $m$ 次操作，每次操作给定 $x,y$，表示修改点 $x$ 的权值为 $y$。

你需要在每次操作之后求出这棵树的最大权独立集的权值大小。
## 输入格式

第一行有两个整数，分别表示结点个数 $n$ 和操作个数 $m$。

第二行有 $n$ 个整数，第 $i$ 个整数表示节点 $i$ 的权值  $a_i$。

接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u$ 与 $v$ 的边。

接下来 $m$ 行，每行两个整数 $x,y$，表示一次操作，修改点 $x$ 的权值为 $y$。
## 输出格式

对于每次操作，输出一行一个整数表示答案。
## 样例

### 样例输入 #1
```
10 10
-11 80 -99 -76 56 38 92 -51 -34 47 
2 1
3 1
4 3
5 2
6 2
7 1
8 2
9 4
10 7
9 -44
2 -17
2 98
7 -58
8 48
3 99
8 -61
9 76
9 14
10 93

```
### 样例输出 #1
```
186
186
190
145
189
288
244
320
258
304
```
## 提示

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n,m\le 10$。
- 对于 $60\%$ 的数据，保证 $n,m\le 10^3$。
- 对于 $100\%$ 的数据，保证 $1\le n,m\le 10^5$，$1 \leq u, v , x \leq n$，$-10^2 \leq a_i, y \leq 10^2$。



---

---
title: "【模板】动态 DP（加强版）"
layout: "post"
diff: 省选/NOI-
pid: P4751
tag: ['动态规划 DP', '线段树', 'O2优化', '树链剖分', '动态树 LCT', '动态 DP', '全局平衡二叉树']
---
# 【模板】动态 DP（加强版）
## 题目背景

树剖常数小！跑不满！

shadowice1984 为了向你证明他能卡树剖并且会卡树剖从而出了这道毒瘤题。

保证答案均在 `int` 范围内。

然后就被离线算法针对了……

因此这道题变成了强制在线。

## 题目描述

同 [P4719](https://www.luogu.com.cn/problem/P4719)。

给定一个 $n$ 个点的带点权树，进行 $m$ 次修改点权的操作。

你需要在每次修改之后输出树上最大带权独立集的权值之和。
## 输入格式

同 [P4719](https://www.luogu.com.cn/problem/P4719)。

第一行两个正整数 $n$，$m$ 表示树的点数和总操作个数

第二行 $n$ 个整数 $V_1,\dots,V_n$ 表示每个点的点权。

接下来 $(n - 1)$ 行，每行两个整数 $u, v$，表示存在一条连接 $u$ 与 $v$ 的边。

接下来 $m$ 行每行两个整数 $x$，$y$ 表示将 $x$ 的点权修改为 $y$。

对于第 $1$ 行，$x$ 即为被操作的点的编号。

对于第 $2$ 到 $m$ 行，被操作的点的编号 $=x\oplus lastans$。

其中 $lastans$ 是上一次操作后输出的答案，$\oplus$ 表示按位异或操作。
## 输出格式

输出 $m$ 行，第 $i$ 行表示表示第 $i$ 次操作之后树上最大带权独立集的权值和。
## 样例

### 样例输入 #1
```
10 10
-11 80 -99 -76 56 38 92 -51 -34 47
2 1
3 1
4 3
5 2
6 2
7 1
8 2
9 4
10 7
9 -44
184 -17
184 98
185 -58
153 48
190 99
296 -61
253 76
329 14
264 93

```
### 样例输出 #1
```
186
186
190
145
189
288
244
320
258
304
```
## 提示

数据范围 $n \leq 1 \times 10^6$，$m \leq 3 \times 10^6$。保证任意时刻各点点权的绝对值 $\leq 100$。

时限为标程的二倍，如果卡常数的话请使用 `int` 类型。


---

---
title: "快递员"
layout: "post"
diff: 省选/NOI-
pid: P4886
tag: ['点分治', '递归', 'O2优化', '树链剖分', '洛谷月赛']
---
# 快递员
## 题目描述

Bob 的城市里有 $n$ 个邮递站，由于经济考虑，这些邮递站被 $n - 1$ 条带权无向边相连。即：这 $n$ 个邮递站构成了一棵树。

Bob 正在应聘一个快递员的工作，他需要送 $m$ 个商品，第 $i$ 个商品需要从 $u$ 送到 $v$。由于 Bob 不能带着商品走太长的路，所以对于一次送货，他需要先从快递中心到 $u$，再从 $u$ 回到快递中心，再从快递中心到 $v$，最后从 $v$ 返回快递中心。换句话说，如果设快递中心是 $c$ 号点，那么他的路径是 $c \rightarrow u \rightarrow c \rightarrow v \rightarrow c$。

现在 Bob 希望确定一个点作为快递中心，使得他送货所需的最长距离最小。显然，这个最长距离是个偶数，你只需要输出最长距离除以 $2$ 的结果即可。
## 输入格式

第一行输入两个数 $n, m$，意义如上。

接下来 $n-1$ 行，每行三个数 $u_i, v_i, w_i$，表示一条连接 $u_i, v_i$，长度为 $w_i$ 的边。

接下来 $m$ 行，每行两个整数 $u_i, v_i$，表示商品的起止位置。
## 输出格式

一行一个整数，表示答案。
## 样例

### 样例输入 #1
```
3 1
1 2 1
2 3 1
1 3

```
### 样例输出 #1
```
2
```
## 提示

对于 $25\%$ 的数据，满足 $1 \leq n, m \leq 1000$。

对于 $100\%$ 的数据，满足 $1 \leq n, m \leq 10^5, 1 \leq w_i \leq 1000$。


---

---
title: "PION后缀自动机"
layout: "post"
diff: 省选/NOI-
pid: P4947
tag: ['字符串', '二分', '树链剖分']
---
# PION后缀自动机
## 题目背景

NOIP2018原创模拟题T6

NOIP2018原创模拟赛DAY2 T3

NOIP DAY1 T3+ or DAY2 T3 难度

鉴于 NOIP2017 DAY2 T3 的难度，就有了这道题。**然而这道题考察的知识并不是后缀自动机**
## 题目描述

小P是一个技术高超的程序员，他开发了一套自己的操作系统，称为PION系统，该系统与Windows和Linux有很大不同，目前他正在测试该系统。

PION系统与Windows系统最大的不同在于文件的储存与操作，POIN的文件夹没有父子之分。我们知道，在Windows系统中，可以在文件夹里新建子文件夹。但是，PION系统文件夹不分父子关系，**但是部分文件夹之间可以互相直接访问，我们称这种关系为互访关系，而且，对于一个有$n$个文件夹的系统来说，这种互访关系有$n-1$个，且保证所有文件夹均可以通过互访关系而互相访问。也就是说：我们可以把Windows中的文件夹的集合看作一棵有根树，而把PION系统中的文件夹集合看作为无根树。**

在PION系统中，每个文件夹都可以储存文件，和Windows一样，文件名包含后缀名。

现在小P正在构思一种可以对文件夹中文件后缀进行方便操作的交互式程序dmc，他也将其称为**PION后缀自动机**。由于他太忙了，所以他希望你帮他实现**部分功能**。

他希望你帮他实现三个功能：

1.计算两个文件夹之间的距离。我们定义：文件夹之间的距离为其中一个文件夹通过互访达到另一个文件夹最少互访次数。比如：同一个文件夹距离为0，两个有互访关系的文件夹距离为1。

2.计算两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件数量，**其中A是一个小写字符串。提示：我们可以把PION文件夹之间的路径理解为树中两节点之间的路径。**

3.删除两个文件夹路径之间（包含这两个文件夹）的文件夹中的文件的后缀名为A的文件，并统计被删除文件的数量。

由于dmc是一个交互系统，所以我们用tab语言描述这三个操作：

```
query /p u v
```

表示操作一，其中 u,v 表示两文件夹的编号

```
query /e u v *.A
```

表示操作二，其中 u,v 表示两文件夹的编号，$'*'$ 为通配符，$'.'$用于分隔文件名与后缀，**A是一个小写字符串**。

```
del /e u v *.A
```

表示操作三， $u,v, *.A$ 意义与操作二相同。

**如果没有看懂题目请结合样例及样例解释来理解。**

最后，这个困难的任务就交给你了。
## 输入格式

第一行两个数，$n,m$，$n$表示文件夹的数量（文件夹编号在$[1,n]$），$m$表示操作的数量

接下来 $n-1$ 行，每行两个数 $u,v$，表示文件夹 $u,v$ 之间有互访关系

接下来 $n$ 行，第$i$行第一个数为 $k$，表示第$i$个文件夹有$k$个文件，接下来为$k$个字符串，表示每个文件的后缀名

再接下来$m$行，每行一串指令，格式见上文
## 输出格式

对于每个指令，输出一个数，输出数的意义见上文
## 样例

### 样例输入 #1
```
5 5
1 2
2 4
2 5
1 3
2 cpp c
3 pas txt txt
2 vbs bat
3 vbs cpp pas
4 cpp c pas txt
query /e 1 5 *.txt
query /p 1 4
del /e 2 2 *.txt
query /e 1 5 *.txt
query /e 4 3 *.vbs
```
### 样例输出 #1
```
3
2
2
1
2
```
### 样例输入 #2
```
12 7
1 2
1 3
1 4
2 5
2 6
3 7
7 12
8 4
8 9
10 9
11 9
0
2 c c
3 zz c c
0
1 gif
2 png bmp
3 avl avl mpshi
0
4 cpp c pas js
5 a b c d e
0
3 a b c
query /p 11 12
query /e 1 2 *.gif
query /e 6 10 *.c
del /e 2 9 *.c
del /e 3 12 *.c
query /e 5 6 *.gif
query /e 6 1 *.c
```
### 样例输出 #2
```
7
0
4
3
3
1
0
```
## 提示

**样例一解释：**

![T6](https://cdn.luogu.com.cn/upload/pic/34166.png)

如图为样例一大致结构，橙色方框为文件夹，灰色文字表示文件后缀名，红色线条表示文件互访关系。

对于第一个操作：文件夹1到5之间txt文件有3个所以输出3  
对于第二个操作：文件夹1与4距离为2  
对于第三个操作：删除的为文件夹2的文件，txt文件有两个，所以输出2  
对于第四个操作：由于文件夹2的txt文件被删除了，所以1到5之间txt文件只有1个  
对于第五个操作：文件夹3到4之间vbs文件有2个所以输出2

**数据范围：**

30%数据满足：$n,m<=100,k<=3$

50%数据满足：$n,m<=5000,k<=10$

70%数据满足：$n,m<=2 \times 10^4,k<=50$

90%数据满足：$n,m<=5 \times 10^4$

100%数据满足：$n,m<=10^5$，文件总数小于$5 \times 10^5$，文件后缀名为小写字符串且不超过6个字符

其他说明：

1.约50%的数据为完全随机生成

2.数据弱化版：[PION后缀自动机（数据弱化版）](https://www.luogu.org/problemnew/show/U41487)


---

---
title: "[NOIP 2018 提高组] 保卫王国"
layout: "post"
diff: 省选/NOI-
pid: P5024
tag: ['动态规划 DP', '2018', '倍增', 'NOIP 提高组', '树链剖分', '动态 DP', '全局平衡二叉树']
---
# [NOIP 2018 提高组] 保卫王国
## 题目背景

NOIP2018 提高组 D2T3
## 题目描述

Z 国有 $n$ 座城市，$(n - 1)$ 条双向道路，每条双向道路连接两座城市，且任意两座城市都能通过若干条道路相互到达。  

Z 国的国防部长小 Z 要在城市中驻扎军队。驻扎军队需要满足如下几个条件： 

- 一座城市可以驻扎一支军队，也可以不驻扎军队。   
- 由道路直接连接的两座城市中至少要有一座城市驻扎军队。   
- 在城市里驻扎军队会产生花费，在编号为 $i$ 的城市中驻扎军队的花费是 $p_i$。      

小 Z 很快就规划出了一种驻扎军队的方案，使总花费最小。但是国王又给小 Z 提出了 $m$ 个要求，每个要求规定了其中两座城市是否驻扎军队。小 Z 需要针对每个要求逐一给出回答。具体而言，如果国王提出的第 $j$ 个要求能够满足上述驻扎条件（不需要考虑第 $j$ 个要求之外的其它要求），则需要给出在此要求前提下驻扎军队的最小开销。如果国王提出的第 $j$ 个要求无法满足，则需要输出 $-1$。现在请你来帮助小 Z。 
## 输入格式

第一行有两个整数和一个字符串，依次表示城市数 $n$，要求数 $m$ 和数据类型 $type$。$type$ 是一个由大写字母 `A`，`B` 或 `C` 和一个数字 `1`，`2`，`3` 组成的字符串。它可以帮助你获得部分分。你可能不需要用到这个参数。这个参数的含义在【数据规模与约定】中 有具体的描述。

第二行有 $n$ 个整数，第 $i$ 个整数表示编号 $i$ 的城市中驻扎军队的花费 $p_i$。

接下来 $(n - 1)$ 行，每行两个整数 $u,v$，表示有一条 $u$ 到 $v$ 的双向道路。 

接下来 $m$ 行，每行四个整数 $a, x, b, y$，表示一个要求是在城市 $a$ 驻扎 $x$ 支军队，在城市 $b$ 驻扎 $y$ 支军队。其中，$x,y$ 的取值只有 $0$ 或 $1$：
- 若 $x$ 为 $0$，表示城市 $a$ 不得驻扎军队。
- 若 $x$ 为 $1$，表示城市 $a$ 必须驻扎军队。
- 若 $y$ 为 $0$，表示城市 $b$ 不得驻扎军队。
- 若 $y$ 为 $1$，表示城市 $b$ 必须驻扎军队。    

输入文件中每一行相邻的两个数据之间均用一个空格分隔。 
## 输出格式

输出共 $m$ 行，每行包含一个个整数，第 $j$ 行表示在满足国王第 $j$ 个要求时的最小开销， 如果无法满足国王的第 $j$ 个要求，则该行输出 $-1$。 
## 样例

### 样例输入 #1
```
5 3 C3 
2 4 1 3 9 
1 5 
5 2 
5 3 
3 4 
1 0 3 0 
2 1 3 1 
1 0 5 0

```
### 样例输出 #1
```
12 
7 
-1
```
## 提示

#### 样例 1 解释

- 对于第一个要求，在 $4$ 号和 $5$ 号城市驻扎军队时开销最小。
- 对于第二个要求，在 $1$ 号、$2$ 号、$3$ 号城市驻扎军队时开销最小。   
- 第三个要求是无法满足的，因为在 $1$ 号、$5$ 号城市都不驻扎军队就意味着由道路直接连 接的两座城市中都没有驻扎军队。  

#### 数据规模与约定  

| 测试点编号 | $\text{type}$ | $n = m=$ |
|:-:|:-:|:-:|
| $1,2$ | `A3` | $10$ |
| $3,4$ | `C3` | $10$ |
| $5,6$ | `A3` | $100$ |
| $7$ | `C3` | $100$ |
| $8,9$ | `A3` | $2\times 10^3$ |
| $10,11$ | `C3` | $2\times 10^3$ |
| $12,13$ | `A1` | $10^5$ |
| $14, 15, 16$ | `A2` | $10^5$ |
| $17$ | `A3` | $10^5$ |
| $18,19$ | `B1` | $10^5$ |
| $20,21$ | `C1` | $10^5$ |
| $22$ | `C2` | $10^5$ |
| $23, 24, 25$ | `C3` | $10^5$ |

数据类型的含义：   

- `A`：城市 $i$ 与城市 $i + 1$ 直接相连。    
- `B`：任意城市与城市 $1$ 的距离不超过 $100$（距离定义为最短路径上边的数量），即如果这 棵树以 $1$ 号城市为根，深度不超过 $100$。   
- `C`：在树的形态上无特殊约束。   
- `1`：询问时保证 $a = 1,x = 1$，即要求在城市 $1$ 驻军。对 $b,y$ 没有限制。   
- `2`：询问时保证 $a,b$ 是相邻的（由一条道路直接连通）  
- `3`：在询问上无特殊约束。

对于 $100\%$的数据，保证 $1 \leq n,m ≤ 10^5$，$1 ≤ p_i ≤ 10^5$，$1 \leq u, v, a, b \leq n$，$a \neq b$，$x, y \in \{0, 1\}$。


---

---
title: "【模板】静态仙人掌"
layout: "post"
diff: 省选/NOI-
pid: P5236
tag: ['图论', '强连通分量', '仙人掌', '树链剖分']
---
# 【模板】静态仙人掌
## 题目背景

这是一道静态仙人掌(Block Forest Data Structure)的模板题。   
如果您不知道什么是仙人掌，那么此处给出无向仙人掌图的定义：  
>任意一条边至多只出现在一条简单回路的无向连通图称为仙人掌。
## 题目描述

给你一个有 $n$ 个点和 $m$ 条边的仙人掌图，和 $q$ 组询问  
每次询问两个点 $u,v$，求两点之间的最短路。

保证输入数据没有重边。
## 输入格式

第一行三个正整数 $n,m,q$，意义如题目描述。  
接下来 $m$ 行，每行三个正整数 $u,v,w$，表示 $u,v$ 之间有一条权值为 $w$ 的无向边。   
然后 $q$ 行，每行两个正整数 $u,v$，询问 $u$ 到 $v$ 的最短路。
## 输出格式

$q$ 行，每行一个正整数，对应一次询问的结果。
## 样例

### 样例输入 #1
```
9 10 2
1 2 1
1 4 1
3 4 1
2 3 1
3 7 1
7 8 2
7 9 2
1 5 3
1 6 4
5 6 1
1 9
5 7
```
### 样例输出 #1
```
5
6
```
### 样例输入 #2
```
9 10 3
1 2 1
2 3 1
2 4 4
3 4 2
4 5 1
5 6 1
6 7 2
7 8 2
8 9 4
5 9 2
1 9
5 8
3 4
```
### 样例输出 #2
```
7
5
2
```
## 提示

**样例1解释：**  
样例1中的仙人掌是这个样子的：  
![](https://cdn.luogu.com.cn/upload/pic/52854.png)   
询问有两个，分别是询问 $1\rightarrow 9$ 和 $5\rightarrow 7$ 的最短路  
显然答案分别为 $5$ 和 $6$。

**数据范围：**   
$1\le n,q \le 10000$      
$1\le m \le 20000$   
$1\le w \le 10^5$     

保证输入数据没有重边。

请注意时限为 $300\text{ms}$      



---

---
title: "[Cnoi2019] 青染之心"
layout: "post"
diff: 省选/NOI-
pid: P5391
tag: ['2019', 'O2优化', '背包 DP', '树链剖分']
---
# [Cnoi2019] 青染之心
## 题目背景

这里原本有着一个史诗般的可歌可泣的背景故事，可是这里空太小，写不下。
## 题目描述

Cirno 初始有一个空的物品序列，一个大小为 $V$ 的背包，现在你有 $q$ 个操作，分为两种：

- `add x y`：表示加入一种体积为 $x$, 价值为 $y$ 的物品到序列末尾。
- `erase`：表示删除序列末尾的物品。

在每个操作结束以后，你需要求出：

假设序列中的每种物品都有无穷多个，Cirno 的背包可以装下的物品最大价值和。
## 输入格式

第一行，两个整数，$q$，$V$ 分别表示操作数和背包大小。

以下 $q$ 行，每行一个操作。
## 输出格式

$q$ 行，每行表示每次操作后的答案。
## 样例

### 样例输入 #1
```
4 10
add 10 3
add 5 2
add 3 3
erase
```
### 样例输出 #1
```
3
4
9
4
```
## 提示

对于 $100\%$ 的数据 $1\le q, V, x, y \le 2\times10^4 $


---

---
title: "EntropyIncreaser 与 动态图"
layout: "post"
diff: 省选/NOI-
pid: P5489
tag: ['洛谷原创', '树链剖分', '动态树 LCT']
---
# EntropyIncreaser 与 动态图
## 题目背景

话说 NaCly_Fish 在和  $\mathsf E \color{red}\mathsf{ntropyIncreaser}$ 吃饭时，问过她一个问题：“一个无向图，支持动态加边，求两点间割点数，怎么做？” 

$\mathsf E \color{red} \mathsf{ntropyIncreaser}$ 想了几秒，说：“这不是sb题吗，随便怎么做都行吧。”然后三两句道出了一个算法。

而 NaCly_Fish 还是不会，请你来教教她这题怎么做吧。
## 题目描述

有一个 $n$ 个点的图，初始没有边。  
有 $q$ 个操作，分为 $3$ 种，具体如下：  

- `1 u v` 表示在 $u,v$ 之间连一条无向边  
- `2 u v` 表示求 $u,v$ 间的割边数量   
- `3 u v` 表示求 $u,v$ 间的割点数量   

特别地，对于 $2$、$3$ 操作，若 $u,v$ 不连通，则输出 $-1$    
****
为了防止有歧义，这里给出对两点间割边和割点数量的定义：  
对于所有包含 $u,v$ 的路径的节点集合之交 $S$ ，定义 $S$ 中的元素数量为 $u,v$ 间的割点数。  
对于所有包含 $u,v$ 的路径的边集合之交 $T$ ，定义 $T$ 中的元素数量为 $u,v$ 间的割边数。  
****
**本题强制在线。**  
从第二行开始，每次的输入的 $u,v$ 都需要异或上 $\text{last}$ ，才是实际操作的 $u,v$。  
 $\text{last}$ 为最近一次**答案非 $-1$ 的**询问的答案，定义初始 $\text{last}=0$   
ps：如果您不知道异或是什么意思，可以看这里：[xor](https://www.baidu.com/link?url=bhG_De1gZYsqrIq7dkhgGj8vP87xSSyoIwk0-5p1fyKmf58cznvq0oYJg0XGoyKNpuGk7EsvjUnyvgJ19_ZA3PhoMJ3hIufHZ5GXh1OaIoS&wd=&eqid=ab26bc160004324d000000035d1ed64e)
## 输入格式

第一行两个正整数 $n,q$，表示节点数和操作次数。   
接下来 $q$ 行，每行三个整数，表示一次操作。   

## 输出格式

对于每个$2$、$3$ 操作，输出一行一个整数表示答案。 
## 样例

### 样例输入 #1
```
5 10
1 1 2
1 2 3
2 1 3
3 0 1
1 3 1
1 1 6
2 3 7
1 6 7
1 7 1
3 3 6
```
### 样例输出 #1
```
2
2
-1
3
```
## 提示

~~题目背景为真实事件~~

### 样例说明：  
实际操作为：  
```cpp
5 10
1 1 2
1 2 3
2 1 3
3 2 3
1 1 3
1 3 4
2 1 5
1 4 5
1 5 3
3 1 4
```

【数据范围】
  
对于 $20\%$ 的数据，$1\le n,q \le 2000$ ；   
对于另外 $30\%$ 的数据，所有 $2$、$3$ 操作均在 $1$ 操作之后；    
对于 $100\%$ 的数据，$1\le n \le 10^5$，$1\le q \le 3\times 10^5$。
    
对于 $1$ 操作，保证 $u\neq  v$。  

By：NaCly_Fish

****

欢迎加入 EI队长粉丝裙，群号：$747262201$   


---

---
title: "[LnOI2019] Abbi并不想研学"
layout: "post"
diff: 省选/NOI-
pid: P5499
tag: ['树链剖分']
---
# [LnOI2019] Abbi并不想研学
## 题目背景

题目提供者：XuKaFy
## 题目描述

【原版题目】

给定一颗$n$个节点的树，树的叶节点全部是数字，非叶节点全部是符号`+`或者`*`。

请先对该树进行树链剖分。注意：若出现子树大小相同的情况，请选择编号较小的子节点作为重儿子。

一个节点的权值这样计算：若该节点为叶节点，数值即为节点数值；若该节点非叶节点，则该点的权值为【【【该点的【所有不在该点所在重链上】的子节点】所在重链的所有节点权值】相`+`或者相`*`的结果（操作取决于该节点的符号）】。

另一种表示方式是：设某一节点$i$的儿子集合为$D_{i}$，节点$i$的父亲为$F_{i}$，节点$i$的所在重链节点集合为$P_{i}$。

我们设：
$$Charge_{i}=\cup_{k\in D_{i},\ k\not\in P_{i}}P_{k}$$

令$C_{i}$为这个节点的符号，这个节点的权值就是：
$$
V_{i}=
\begin{cases}
\sum_{j\in Charge_{i}}V_{j} &C_{i}=`+'\\
\prod_{j\in Charge_{i}}V_{j} &C_{i}=`\times'
\end{cases}  
$$

数据不保证每一个非叶节点都有至少一个非链上儿子，若没有合法的儿子则忽略该节点。

你需要支持这三种操作：

- $1$.改变某一叶节点的数值；

- $2$.改变某一非叶节点的符号为`+`或者`*`；

- $3$.查询某一节点所在重链所有节点权值相`+`与相`*`的值。

为防止溢出，请将所有权值$mod\ 99991$。
## 输入格式

第一行输入两个数$n$与$m$表示学生数量与要求数量。

接下来输入$1$行，$n-1$个数，表示第$i+1$个节点的父亲为$a$。

接下来一行$n$个数，分别为每个节点的信息：若该节点为叶节点，则是一个数字表示$V_{i}$，否则为一个数，`0`表示`+`，`1`表示`*`。

接下来输入$m$行，每行一个数字$c$与编号$k$，表示要求类型为$c$，操作的节点编号为$k$。若$c=1$，那么再输入一个数$V_{i}$表示新的权值。
## 输出格式

对于每一个$3$操作，请输出一行，该行包括两个数$a$、$b$，分别表示将本节点所在重链的所有节点权值相加**与**相乘的结果。
## 样例

### 样例输入 #1
```
8 5
1 2 3 3 2 2 7
1 0 1 3 4 5 0 6
3 1
2 2
3 1
1 4 1
3 1
```
### 样例输出 #1
```
18 132
37 360
35 120
```
## 提示

对于$30\%$的数据，$1≤n,m≤1000$。

对于$100\%$的数据，$1≤n,m≤10^{6}, 1≤V_{i}<99991$。

**数据保证任何时刻树上没有权值为$0$的节点。**


---

---
title: "圣剑护符"
layout: "post"
diff: 省选/NOI-
pid: P5556
tag: ['树状数组', '树链剖分', '线性基']
---
# 圣剑护符
## 题目背景

小L和小K正在研究传说中的圣剑。

“所谓圣剑，是封入了各种护符并将其固定为刀剑外形的一种东西。据说一旦用咒力线把护符们接合在一起，就会产生复杂的相互干涉作用。”
## 题目描述

小L和小K面前的圣剑由 $n$ 块护符组成，分别编号为 $1,2,\ldots , n$ ，有 $n-1$ 条咒力线连接两块护符，形成了一个树形结构。

经过小L和小K的长时间的研究，他们发现护符之间的相互作用并不复杂。每块护符都有一个属性值，第 $i$ 块护符的属性值记为 $v_i$ 。这个值的每个二进制位上的 $0$ 或 $1$ 表示这块护符是否拥有特定属性。所有属性值中相同的二进制位对应的是相同的属性。

对于一系列护符（护符的集合），对于每种特定属性，统计其中包含这一属性的护符数量，如果为偶数，则这一系列护符形成了干涉，最终的属性值对应的二进制位上为 $0$ ，如果为奇数则干涉后剩下了一块护符的影响，对应的二进制位为 $1$ 。也就是说， **护符集合的属性值为单个护符的属性值的异或和** 。 **空集的属性值定义为 $0$** 。

现在，小L想知道，如果取出两块护符 $x,y$ 间的简单路径上的所有护符，能否找到两个不相等的子集，使得两个子集的属性值相同（注意到空集也是路径上所有护符集合的子集）。同时，小K还会将两块护符间的路径上的所有护符取出进行调整，将所有这些护符的属性值在某些相同二进制位上进行修改（即 $0$ 变为 $1$ ， $1$ 变为 $0$ ），可以看做是将所有这些护符的属性值异或上了一个值。
## 输入格式

输入的第一行为两个整数 $n,q$ ，分别表示护符的数量和小L和小K的操作的数量。

下一行有 $n$ 个整数，第 $i$ 个数表示第 $i$ 块护符的属性值 $v_i$ 。

接下来的 $n-1$ 行，每行有两个整数 $x,y$ ，表示有一条咒力线连接了 $x,y$ 两块护符。保证形成一个树形结构。

接下来的 $q$ 行，每行一个操作，形式如下：

1.  `Update x y z` ：将编号分别为 $x,y$ 的两块护符间的简单路径上的所有护符的属性值异或上一个值 $z$ 。

2. `Query x y` ： 判断对于编号分别为 $x,y$ 的两块护符间的简单路径上的护符的集合，是否存在两个不相等的子集，使得两个子集的属性值相同。
## 输出格式

对于每个 `Query` 操作，输出一行 `YES` 或 `NO` 。
## 样例

### 样例输入 #1
```
2 3
3 4
1 2
Query 1 2
Update 2 2 7
Query 2 1
```
### 样例输出 #1
```
NO
YES
```
## 提示

由于某种原因，本题将采用 **捆绑测试** 。只有通过一个子任务内的所有测试点，才能得到该子任务的全部分数，否则得 $0$ 分。

$Subtask\#1$ ： $20pts$ ， $x,y$ 在树上的距离小于等于 $5$ 。

$Subtask\#2$ ： $40pts$ ， $n,q\le 5000,0\le v_i,z\le 2^{10}$

$Subtask\#3$ ： $40pts$ ，无特殊限制。

对于 $100\%$ 的数据，有 $1\le n,q\le 10^5,1\le x,y\le n,0\le v_i,z< 2^{30}$



---

---
title: "心上秋"
layout: "post"
diff: 省选/NOI-
pid: P5558
tag: ['动态规划 DP', '倍增', 'O2优化', '矩阵加速', '树链剖分']
---
# 心上秋
## 题目背景

辗转经由他人唇齿

多少日夜听闻你的故事

难道这情之一字

竟连抛生死亦不可探知

听说北国的那座城池

被冬雪覆了终日

等到故人长诀渐行渐远

转眼已隔两世

谁向生而死 谁患得患失

相顾也再无多时

画中人暗自 竟心荡神痴

一滴泪氤氲满纸

挥墨描眉目 提笔勾鬓丝

寥寥几笔竟如此

夜半无人处 对月展卷时

忽然看懂这相思

落款谁提了名字

————《心上秋》
## 题目描述

竟宁元年（前33年）正月，昭君出塞前一晚。

画师跌跌撞撞地来到昭君居住的宫殿。

     听说北国的那座城池
     被冬雪覆了终日
     等到故人长诀渐行渐远
     转眼已隔两世
                ——《心上秋》

如果再也不能相见的话，画师想着，他想给昭君留下些什么。

他想把他的画笔送给昭君。

**昭君的宫殿里有$N$个房间，有$N-1$条道路连接这些房间。**

**画师现在在宫殿的入口大厅$S$房间，他依稀记得，昭君的房间在$T$号。**

窗外，风雨大作，宫内忽暗忽明，一个人影也没有。

画家走进晦暗的通道，每条通道里的墙壁上都画有若干片枫叶，这是之前昭君让画师画的。昭君说，她特别喜欢秋天，尤其喜欢秋天的枫叶。

      并肩长谈过多少往事，恍然间黄昏已至    ——《心上秋》

通道内晦暗无比，画师想点亮通道内备好的蜡烛，他记得昭君有个习惯，**每个通道内的蜡烛数量就是墙上枫叶的数量。昭君若想点燃一条通道内的蜡烛，就会全部点燃，此时昭君认为这条通道已被点亮，并且不会再点亮任何枫叶数少于这条通道的通道**。

这应该是最后一次来到这个地方了，画师想着，他要按昭君的习惯，走到昭君的房间。

**现在画师想知道，他从宫殿大厅$S$走到昭君房间$T$，最多可以点亮多少通道。**
## 输入格式

第一行一个数$N$，表示宫殿房间数量。

接下来有$N-1$行，每行三个数$u_{i},v_{i},leaf_{i}$，表示$u,v$之间有一条通道，通道上画有$leaf_{i}$片枫叶。

接下来一个数$M$。

最后$M$行，每行两个数$S_{i},T_{i}$
## 输出格式

输出$M$行，对于每组$S_{i},T_{i}$，输出最多能够点亮的通道数。
## 样例

### 样例输入 #1
```
5
1 2 5
2 3 1
1 4 1
3 5 4
3
2 1
4 2
1 1

```
### 样例输出 #1
```
1
2
0

```
### 样例输入 #2
```
7
1 2 1
1 3 5
2 4 1
4 5 4
5 6 1
1 7 1
5
7 5
7 6
2 7
1 1
2 4
```
### 样例输出 #2
```
4
4
2
0
1

```
### 样例输入 #3
```
20
1 2 1
1 3 3
2 4 5
1 5 1
5 6 5
1 7 5
1 8 4
7 9 1
8 10 2
1 11 1
2 12 5
3 13 1
3 14 3
3 15 3
10 16 1
5 17 1
12 18 5
7 19 4
7 20 5
10
10 3
17 16
11 9
4 6
16 17
11 16
11 11
13 11
2 1
10 11
```
### 样例输出 #3
```
2
3
2
3
3
2
0
2
1
2

```
## 提示

| 数据编号 | N | M | 特殊性质 |
| :----------: | :----------: | :----------: | :----------: |
| $1$ | $100$ | $100$ | 无 |
| $2$ | $100$ | $100$ | 无 |
| $3$ | $100$ | $1000$ | 无 |
| $4$ | $10000$ | $10000$ | 无 |
| $5$ | $10000$ | $10000$ | $1$ |
| $6$ | $10000$ | $10000$ | $1,2$ |
| $7$ | $10000$ | $10000$ | $1,2$ |
| $8$ | $30000$ | $100000$ | 无 |
| $9$ | $30000$ | $100000$ | 无 |
| $10$ | $30000$ |$300000$  | 无 |
特殊性质$1$：$1<=leaf_{i}<=2$

特殊性质$2$：$u_{i}+1=v_{i}$

对于所有的数据，保证$1<=leaf_{i}<=5$

样例一解析：

![](https://cdn.luogu.com.cn/upload/image_hosting/eaxwdth6.png)

询问$1$：从$2$走到$1$最多点亮$1$条通道（$2-1$）

询问$2$：从$4$走到$2$最多点亮$2$条通道（$4-1,1-2$）

询问$3$：显然无法点亮通道。

样例二解析：

![](https://cdn.luogu.com.cn/upload/image_hosting/8z9tovt5.png))

询问$1$：从$7$走到$5$，可以点亮$4$个通道（$7-1,1-2,2-4,4-5$）

询问$2$：从$7$走到$6$，可以点亮$4$个通道（$7-1,1-2,2-4,4-5$），不点亮（$5-6$）是因为已经点亮（$4-5$）后无法点亮比枫叶数小于$4$的通道，易知这样是最优的，或者不点亮（$4-5$）而点亮（$5-6$），这同样是最优解。

询问$3$：从$2$走到$7$，可以点亮$2$个通道（$2-1$,$1-7$）

询问$4$：不经过任何通道。

询问$5$：经过$1$条通道（$2-4$）


     何处合成愁。离人心上秋。纵芭蕉，不雨也飕飕。都道晚凉天气好，有明月，怕登楼。

     年事梦中休。花空烟水流。燕辞归，客尚淹留。垂柳不萦裙带住。漫长是，系行舟。



---

---
title: "失昼城的守星使"
layout: "post"
diff: 省选/NOI-
pid: P5559
tag: ['线段树', '树状数组', 'O2优化', '树链剖分']
---
# 失昼城的守星使
## 题目背景

> 月伏潮汐生，星染万屿寂，无晦明之变化者，是为失昼。   ————《失昼城手札·起源》

失昼城四面环海，建城于7325年前。

失昼城没有黑夜白天的变化，一轮明月自建城伊始就挂在天空，故名失昼。


失昼城城主月凌霜，掌控着失昼城的守星塔，守星塔在终日无昼的失昼城中作为照明的灯塔，一直是城里人们的精神寄托，她的另一个身份是失昼城的守星使，比起作为城主，月凌霜更喜欢守着守星塔。

失昼城的特殊环境导致其空间异常不稳定，根据失昼城城史记载，七千多年历史的失昼城，其和平的时间总共不超过三百年，其他大部分时间失昼城局部地区都在空间风暴的笼罩之下，依托于特殊空间存在的守星塔，同时兼具着向人们传递信息的功能，在不稳定的空间影响下，这是唯一能够维持信号稳定的方法。


## 题目描述

失昼城共由$N$座岛屿组成，由$N-1$条传递信息的空间通道联通。

作为失昼城的守星使，月凌霜具有部署守星塔的能力，具体而言，为了依靠特殊空间波动向每个有居民居住的岛屿传递消息，月凌霜可以任意数量地部署守星塔，每座岛屿只能部署一座守星塔，**但是同一时刻所有部署的守星塔必须依靠空间通道连成一条链**。

失昼城常年受到空间风暴的困扰，常常会出现某座岛屿遭受空间风暴，岛上全体居民被迫离开岛屿，此时，**守星塔不再需要向该地传输消息**，等到空间风暴散去，居民重新回到这里，**守星塔才需要恢复向该地的信息传输**。

由于空间波动的干扰，守星塔传递消息必须依靠联通岛屿的空间通道完成，具体而言，如果一座守星塔要向一座岛屿传递消息，**其消耗的能量为该座守星塔所处的岛屿到需要接收消息的岛屿的所有空间通道能耗总和**，当然，如果一座守星塔向自身所处的岛屿发送消息，则不需要消耗能量，守星塔对岛屿传递消息的信号波动互相独立，也就是说，**每座守星塔对于每座岛屿的能量传输互不干扰**。

作为城主兼守星使，月凌霜近期正在研究怎样部署守星塔才能使消息传递所消耗的能量最小，现在月凌霜已经找到了记载失昼城七千多年来空间风暴的爆发情况和当时失昼城的守星塔部署的资料，由于历史过于久远，每次能量的消耗情况已经不得而知，现在月凌霜希望你帮助她还原这些史料，具体详见输入格式。
## 输入格式

第一行三个数$N,Q,Type$，表示失昼城岛屿数量，月凌霜的询问个数以及该数据点的特殊性质，$Type$在二进制下，若第$i-1$位为$1$，则表示存在特殊性质$i$。

接下来$N-1$行，每行三个数$u_{i},v_{i},w_{i}$表示岛屿$u$和岛屿$v$之间存在一条双向空间通道，消息经过这条空间通道需要消耗能量为$w_i$。

接下来一行$N$个数，由$0,1$两个数字构成，表示第$i$个岛屿在失昼城建城之时是否存在空间风暴，$0$表示存在空间风暴，$1$表示不存在，同时我们认为，**如果一个岛屿不存在空间风暴，那么它一定会吸引人们聚居，若存在空间风暴，则不会有人们在该岛屿居住**。

最后$Q$行，每行表示一个事件，具体如下：

$1$  $x$：对于岛屿$x$，若原本该岛屿没有空间风暴，则空间风暴产生，岛上全体居民撤出该岛，否则表示该岛屿空间风暴散去，人们重新回到这里居住。

$2$  $x$  $y$：月凌霜向你提出一个询问，询问若此时部署守星塔在$x$到$y$的简单路径上，则向**所有有居民的岛屿**传递一次消息所需要的能量消耗之和**最小**为多少。一座守星塔可以同时向多座岛屿传递消息，也可以不向任何岛屿传递消息。
## 输出格式

输出$Q$行，每行一个数，表示该次询问的答案。
## 样例

### 样例输入 #1
```
5 2 0
1 2 2
1 3 3
4 3 2
5 3 7
0 1 1 0 1
2 2 4
2 4 3
```
### 样例输出 #1
```
7
12
```
### 样例输入 #2
```
6 3 0
2 1 3
3 1 5
4 1 2
6 4 8
4 5 9
1 1 1 0 0 1
2 1 1
1 5
2 3 6
```
### 样例输出 #2
```
18
12
```
## 提示

![](https://cdn.luogu.com.cn/upload/pic/74843.png)

特殊性质$1$：$v_{i}=u_{i}+1$

特殊性质$2$：月凌霜所有的询问的$x$和$y$相同。

特殊性质$3$：月凌霜所有的询问的$x=1$。

对于所有的$w_{i}$，保证$0$<=$w_{i}$<=$10^{5}$

对于$100\%$的数据，保证$n,m\leq 200000,0\leq Type\leq 7$.

样例1解释：

![](https://cdn.luogu.com.cn/upload/pic/74831.png)

初始图像如左图。

对于第一个询问如中图，有$2,3,5$有居民，所以$ans_2=ans_3=0,ans_5=7.$所以$ans=7$.

对于第二组询问如右图，$ans_2=2+3=5,ans_3=0,ans_5=7,$,因此$ans=7+5=12$.

样例2解释：

![](https://cdn.luogu.com.cn/upload/pic/74836.png)

初始图如左上。

询问$1$点如图右上，存在$1,2,3,6$有居民。
$ans_1=0,ans_2=3,ans_3=5,ans_6=8+2=10.$因此$ans=3+5+10=18$

1操作后所有有居民点如左下。

接下来的操作图为右下，同上有$ans_1=0,ans_2=3,ans_3=0,ans_5=9,ans_6=0$,所以$ans=3+9=12$.


---

---
title: "[JSOI2016] 轻重路径"
layout: "post"
diff: 省选/NOI-
pid: P5773
tag: ['2016', '各省省选', '江苏', '树链剖分']
---
# [JSOI2016] 轻重路径
## 题目描述

JYY 最近学习了一种处理树形结构的高级技巧，叫「轻重路径剖分」。这种技术会将树中的边划分成轻边和重边。相连的重边会形成一些树上相离的路径。「轻重路径剖分」可以使得从树上任意一点走到根，都至多只会经过 $(\log N)$ 条不同的重路径。

如果你不了解轻重路径剖分，JYY 在这里简单介绍一下：对于一棵有根树中的任意一个点 $u$，我们用 $size(u)$ 表示其为根的子树中的点的数量。对于 $u$ 的所有孩子中，我们选出 $size$ 值最大的孩子 $v$，并将边 $(u,v)$ 设置成重边，$u$ 和其他孩子之间的边我们均设置为轻边。

为了简化问题，这里 JYY 仅考虑一棵 $N$ 个点的有根二叉树。这 $N$ 个点由 $1$ 到 $N$ 编号。并且如果 $u$ 存在两个 $size$ 值一样的孩子，则我们默认 $u$ 和其左孩子的连边为重边。

现在 JYY 希望执行额外 $Q$ 次删点操作，每次 JYY 会随机删掉一个当前二叉树的叶子节点，而你则需要动态的维护这棵树的轻重路径剖分。

为了方便输出，你只需要在每次操作后输出所有重边指向的点的编号之和即可。

如果删除一个点之后，存在一个点 $u$ 拥有两个 $size$ 值一样的孩子，则我们保持 $u$ 在该操作执行之前的重边划分。
## 输入格式

第一行包含一个整数 $N$；

接下来 $N$ 行，第 $i$ 行包含两个整数 $L_i,R_i$，表示编号为 $i$ 的点的左孩子编号和右孩子编号，$L_i=0$表示点 $i$ 没有左孩子， $R_i=0$表示点 $i$ 没有右孩子；

第 $N+2$ 行包含一个整数 $Q$，表示 JYY 进行的删点操作；

第 $N+3$ 行包含 $Q$ 个空格分开的正整数，表示 JYY 删去的叶子的编号。

输入数据保证每次删除操作均删除了一个叶子。
## 输出格式

输出 $Q+1$ 行，每行包含一个整数，表示在轻重路径剖分中所有重边指向的点的编号的和。其中第一行对应初始的路径剖分，之后的 $Q$ 行对应进行了相应删点操作之后路径划分。
## 样例

### 样例输入 #1
```
8
2 3
4 5
0 0
6 7
0 8
0 0
0 0
0 0
7
6 7 8 5 4 2 3

```
### 样例输出 #1
```
20
21
15
7
6
2
3
0

```
## 提示

对于 $30\%$ 的数据，满足 $N \le 1000$；

对于 $50\%$ 的数据，满足 $N \le 5 \times 10^4$；

对于全部数据，满足 $N \le 2 \times 10^5$。


---

---
title: "洪水"
layout: "post"
diff: 省选/NOI-
pid: P6021
tag: ['动态规划 DP', '线段树', '二分', '矩阵加速', '树链剖分']
---
# 洪水
## 题目描述

小 A 走到一个山脚下，准备给自己造一个小屋。这时候，小 A 的朋友（`op`，又叫管理员）打开了创造模式，然后飞到山顶放了格水。于是小 A 面前出现了一个瀑布。作为平民的小 A 只好老实巴交地爬山堵水。那么问题来了：我们把这个瀑布看成是一个 $n$ 个节点的树，每个节点有权值（爬上去的代价）。小 A 要选择一些节点，以其权值和作为代价将这些点删除（堵上），使得根节点与所有叶子结点不连通。问最小代价。不过到这还没结束。小 A 的朋友觉得这样子太便宜小 A 了，于是他还会不断地修改地形，使得某个节点的权值发生变化。不过到这还没结束。小 A 觉得朋友做得太绝了，于是放弃了分离所有叶子节点的方案。取而代之的是，每次他只要在某个子树中（和子树之外的点完全无关）。于是他找到你。
## 输入格式

输入文件第一行包含一个数 $n$，表示树的大小。

接下来一行包含 $n$ 个数，表示第 $i$ 个点的权值。

接下来 $n-1$ 行每行包含两个数 $fr,to$ 。表示树中有一条边 $(fr,to)$ 。

接下来一行一个整数，表示操作的个数。

接下来 $m$ 行每行表示一个操作，若该行第一个数为 $Q$，则表示询问操作，后面跟一个参数 $x$ ，表示对应子树的根；若为 $C$ ，则表示修改操作，后面接两个参数 $x,t$ ，表示将点 $x$ 的权值加上 $t$。
## 输出格式

对于每次询问操作，输出对应的答案，答案之间用换行隔开。
## 样例

### 样例输入 #1
```
4
4 3 2 1
1 2
1 3
4 2
4
Q 1
Q 2
C 4 10
Q 1
```
### 样例输出 #1
```
3
1
4
```
## 提示

$1 \leq n \leq 200000,1 \leq fr,to \leq n,1 \leq x \leq n$，权值和 $t$ 均在 `int` 范围内且非负。

BZOJ4712


---

---
title: "最优性剪枝"
layout: "post"
diff: 省选/NOI-
pid: P6048
tag: ['搜索', '数学', '2020', '线段树', '剪枝', '树链剖分', '期望']
---
# 最优性剪枝
## 题目背景

Nauuo 是一名出题人。

众所周知，某些出题人非常懒，导致[随便爆搜](https://www.luogu.com.cn/discuss/show/185420)加上一个[最优性剪枝](https://www.luogu.com.cn/discuss/show/184641)就能通过。Nauuo 决定把这些 naive 的暴力都卡掉。
## 题目描述

Nauuo 决定卡一个暴力搜索程序，为此她构建了一组数据。为了简化题目，你将得到这组数据产生的搜索树 $T$。$T$ 中包含 $n$ 个节点，依次编号为 $1 \sim n$，其中 $1$ 号点是 $T$ 的根节点。一个节点的深度是它到 $1$ 号点的简单路径上的节点个数。

这个程序的伪代码如下

```cpp
answer := inf

procedure dfs(node,depth)
	if (node is leaf) 
		answer := min(answer,depth)
		return
	if (depth < answer)
		for i in children of node
			dfs(i,depth+1)

dfs(1,1)
```

其中，`:=` 表示赋值运算。

翻译成人话就是说，这个暴力搜索程序将**深度优先**地遍历这棵搜索树，当访问到一个叶节点时，这个程序将用这个叶节点的深度更新答案。

同时，这个程序有一个最优性剪枝，也就是说，当这个程序访问到任意一个深度等于答案的节点时，它将不会再访问这个节点的子节点。

然而，可怜的 Nauuo 并不知道这个程序在某个节点时访问自己子节点的顺序，因此她认为每个节点访问子节点的顺序都是在所有可能的情况中等概率随机的，显然，一共有 $\prod d_i!$ 种情况，其中 $d_i$ 表示 $i$ 号节点的子节点数量。

现在她想知道这个程序访问到的节点数量的期望，以确定这个程序会不会被自己的数据卡掉。

为了避免浮点误差，答案对 $998244353$ 取模。保证答案能被表示为最简分数 $\frac{p}{q}$，你只需要输出一个 $x (0\leq x < 998244353)$ 使得 $qx \equiv p \pmod {998244353}$。
## 输入格式

第一行一个整数 $n$。

第二行 $n-1$ 个整数 $p_2, p_3 \cdots p_n$，其中 $p_i$ 表示 $i$ 号节点的父节点编号。
## 输出格式

一行一个整数，所求 $x$。
## 样例

### 样例输入 #1
```
4
1 1 3
```
### 样例输出 #1
```
499122180
```
### 样例输入 #2
```
3
1 2
```
### 样例输出 #2
```
3
```
### 样例输入 #3
```
13
1 1 1 3 5 4 2 3 7 4 4 6
```
### 样例输出 #3
```
776412285
```
## 提示

#### 样例解释

第一组样例的真实答案为 $\frac{7}{2}$。

一共只有两种情况，如果 $1$ 号节点先遍历 $3$ 号节点，则程序将访问到搜索树中所有节点。如果 $1$ 号节点先遍历 $2$ 号节点，则 $4$ 号节点不会被访问到。

第二组样例中，每个非叶节点的子节点都是唯一的，因此只有一种可能的情况，所有节点都必然被访问到。

第三组样例的真实答案为 $\frac{94}{9}$。

---

#### 数据范围

**「本题采用捆绑测试」**

对于所有测试点，保证 $1 \leq n \leq 3\times 10^5$，$1 \leq p_i < i$。

$\text{Subtask 1 (11 pts)}$ $n \leq 9$。

$\text{Subtask 2 (18 pts)}$ $n \leq 100$。

$\text{Subtask 3 (19 pts)}$ $n\leq 10^3$。

$\text{Subtask 4 (4 pts)}$ $p_i = i-1$。

$\text{Subtask 5 (8 pts)}$ $p_i =\lfloor \frac{i}{2} \rfloor$。

$\text{Subtask 6 (40 pts)}$ 无特殊限制。

---

#### 提示

如果你不知道怎么对分数取模，可以参考[这里](https://www.luogu.com.cn/problem/P3811)。




---

---
title: "有趣的游戏"
layout: "post"
diff: 省选/NOI-
pid: P6157
tag: ['2020', '线段树', '树链剖分']
---
# 有趣的游戏
## 题目背景

小 A 和小 B 正在玩一个有趣的电脑游戏。
## 题目描述

游戏在一棵大小为 $n$ 的树上进行。其中每个点都有点权，第 $i$ 个点的点权为 $w_i$。

每一次系统会给出一条链，小 A 可以从这条链上找出两个**点权不同**的点 $x,y$，他的得分是 $w_x\bmod w_y$。然后小 B 会从**整棵树**中选取两个**小 A 没有选过**的点，计分方式同小 A。

为了保持游戏难度，系统有时会增加一个点的权值。

当然，小 A 会尽可能使自己得分最大，他想知道这个值是多少。同时，他想知道，在自己得分最大的情况下，小 B 的最大得分是多少。
## 输入格式

第一行一个整数 $n$ 表示树的节点个数。

接下来 $n-1$ 行，每行两个整数 $a,b$，表示 $a,b$ 之间有一条边。

接下来一行 $n$ 个整数，第 $i$ 个数表示第 $i$ 个点的点权。

接下来一行一个整数 $q$。

接下来 $q$ 行，每行三个整数 $opt,x,y$。

若 $opt=0$，将  $w_x$ 增加 $y$。

若 $opt=1$，表示系统给出一条从 $x$ 到 $y$ 的链。
## 输出格式

对于每一次 $opt=1$，输出一行两个整数 $suma,sumb$ 。分别表示小 A 的最大得分和在这情况下小 B 的最大得分 。

**如果小 A 无法选出两个权值不同的点，那么只输出一个数 $-1$。**
## 样例

### 样例输入 #1
```
7
1 2
2 3
2 4
1 5
5 6
5 7
5 4 3 2 1 4 3
6
1 3 4
1 2 5
1 2 1
0 2 1
1 2 5
1 2 1
```
### 样例输出 #1
```
3 4
4 3
4 3
1 4
-1
```
## 提示

样例解释：

第一次：小 A 选择点 $3$ 和点 $2$，得分为 $3\bmod 4=3$，小 B 选择点 $6$ 和点 $1$ 得分为 $4\bmod 5=4$。

第二次：小 A 选择点 $2$ 和点 $1$，得分为 $4\bmod 5=4$，小 B 选择点 $7$ 和点 $6$ 得分为 $3\bmod 4=3$。

第三次：小 A 选择点 $2$ 和点 $1$，得分为 $4\bmod 5=4$，小 B 选择点 $7$ 和点 $6$ 得分为 $3\bmod 4=3$。

第四次：第 $2$ 个点点权变为 $5$。

第五次：小 A 选择点 $5$ 和点 $1$，得分为 $1\bmod 5=1$，小 B 选择点 $6$ 和点 $2$ 得分为 $4\bmod 5=4$。

第六次：小 A 可以选的点只有 $1,2$ ，点权都是 $5$，没有可以选的方案。

**本题采用捆绑测试。**
| Subtasks |$n,q$  |特殊性质  |分数  |
| :----------: | :----------: | :----------: | :----------: |
|Subtask1  |$\leq10^3$  |无  |$10$  |
|Subtask2  |$\leq10^5$  |树的形态，点权随机  |$15$  |
|Subtask3  |$\leq10^5$  |最多有 $5$ 种不同的点权，且没有修改 |$15$  |
|Subtask4  |$\leq10^5$  |树为一条链，且第 $i$$(i>1)$ 个点的父亲为 $i-1$ |$25$  |
|Subtask5  |$\leq10^5$  |无  |$35$  |

对于所有数据 $1 \leq n,q \leq 10^5$，$1 \leq w_i \leq 10^4$，增加的数为不大于 $10^3$ 的正整数，且输入为一棵合法的树。**保证任何时候不同种类的数大于等于 $4$。**


---

---
title: "Count on a tree II/【模板】树分块"
layout: "post"
diff: 省选/NOI-
pid: P6177
tag: ['倍增', '最近公共祖先 LCA', '树链剖分', '可持久化', '分块']
---
# Count on a tree II/【模板】树分块
## 题目背景

原 bzoj2589。
## 题目描述

给定一个 $n$ 个节点的树，每个节点上有一个整数，$i$ 号点的整数为 $val_i$。

有 $m$ 次询问，每次给出 $u',v$，您需要将其解密得到 $u,v$，并查询 $u$ 到 $v$ 的路径上有多少个不同的整数。

解密方式：$u=u' \operatorname{xor} lastans$。

$lastans$ 为上一次询问的答案，若无询问则为 $0$。
## 输入格式

第一行有两个整数 $n$ 和 $m$。

第二行有 $n$ 个整数。第 $i$ 个整数表示 $val_i$。

在接下来的 $n-1$ 行中，每行包含两个整数 $u,v$，描述一条边。

在接下来的 $m$ 行中，每行包含两个整数 $u',v$，描述一组询问。
## 输出格式

对于每个询问，一行一个整数表示答案。
## 样例

### 样例输入 #1
```
8 2
105 2 9 3 8 5 7 7 
1 2
1 3
1 4
3 5
3 6
3 7
4 8
2 5
3 8
```
### 样例输出 #1
```
4
4
```
## 提示

对于 $100\%$ 的数据，$1\le u,v\le n\le 4\times 10^4$，$1\le m\le 10^5$，$0\le u',val_i<2^{31}$。


---

---
title: "「RdOI R2」路径权值(distance)"
layout: "post"
diff: 省选/NOI-
pid: P7581
tag: ['2021', '树形 DP', '树链剖分']
---
# 「RdOI R2」路径权值(distance)
## 题目背景

此题读入量较大，请选择合适的读入方式。
## 题目描述

给你一棵 $n$ 个点的边带权有根树，根节点为编号为 $1$ 的节点。定义 $u$ 的 $k-son$ 为 $u$ 子树中深度（指经过边数）比 $u$ **恰好**大 $k$ 的所有点。  
$m$ 次询问求一个点 $u$ 的 $k-son$ 两两之间距离的和。你需要输出这个值 $\bmod\left(10^9+7\right)$ 的结果。
## 输入格式

第一行两个数 $n,m$。  
接下来 $n-1$ 行每行三个数 $u,v,w$，代表 $u,v$ 之间有一条边权为 $w$ 的边。  
接下来 $m$ 行每行两个数 $u,k$，代表一个询问。
## 输出格式

对于每个询问输出一行答案。
## 样例

### 样例输入 #1
```
5 3 
1 2 2
1 3 1
2 4 1
2 5 2
1 1
1 2
2 1
```
### 样例输出 #1
```
3
3
3
```
### 样例输入 #2
```
10 5
1 2 1
1 3 3
2 4 2
2 5 2
3 6 3
3 7 1
5 8 2
6 9 1
6 10 3
1 2
3 2
6 1
1 3
2 2
```
### 样例输出 #2
```
40
4
4
30
0
```
## 提示

**样例 $1$ 解释**

以下是样例中的树。  
![](https://cdn.luogu.com.cn/upload/image_hosting/lz4oy8ao.png)

---

**样例 $2$ 解释**

以下是样例中的树。  
![](https://cdn.luogu.com.cn/upload/image_hosting/hb45pofr.png)

---

**数据范围**

对于 $20\%$ 的数据，$n,m,k\le100$。  
对于 $50\%$ 的数据，$n,m,k\le10^3$。  
对于 $80\%$ 的数据，$n,m,k\le10^5$。  
对于 $100\%$ 的数据，$1\le n,m,k\le10^6,1\le k\le n,1\le w\le10^5,1\le u,v\le n$，保证给出的是一棵树。  


---

---
title: "[CSP-S 2022] 数据传输"
layout: "post"
diff: 省选/NOI-
pid: P8820
tag: ['动态规划 DP', '2022', 'O2优化', '树链剖分', '矩阵乘法', 'CSP-S 提高级']
---
# [CSP-S 2022] 数据传输
## 题目背景

**请勿滥用本题评测，违者可能处以封号处罚。**
## 题目描述

小 C 正在设计计算机网络中的路由系统。

测试用的网络总共有 $n$ 台主机，依次编号为 $1 \sim n$。这 $n$ 台主机之间由 $n - 1$ 根网线连接，第 $i$ 条网线连接个主机 $a_i$ 和 $b_i$。保证任意两台主机可以通过有限根网线直接或者间接地相连。受制于信息发送的功率，主机 $a$ 能够直接将信息传输给主机 $b$ 当且仅当两个主机在可以通过不超过 $k$ 根网线直接或者间接的相连。

在计算机网络中，数据的传输往往需要通过若干次转发。假定小 C 需要将数据从主机 $a$ 传输到主机 $b$（$a \neq b$），则其会选择出若干台用于传输的主机 $c_1 = a, c_2, \ldots, c_{m - 1}, c_m = b$，并按照如下规则转发：对于所有的 $1 \le i < m$，主机 $c_i$ 将信息直接发送给 $c_{i + 1}$。

每台主机处理信息都需要一定的时间，第 $i$ 台主机处理信息需要 $v_i$ 单位的时间。数据在网络中的传输非常迅速，因此传输的时间可以忽略不计。据此，上述传输过程花费的时间为 $\sum_{i = 1}^{m} v_{c_i}$。

现在总共有 $q$ 次数据发送请求，第 $i$ 次请求会从主机 $s_i$ 发送数据到主机 $t_i$。小 C 想要知道，对于每一次请求至少需要花费多少单位时间才能完成传输。
## 输入格式

输入的第一行包含三个正整数 $n, Q, k$，分别表示网络主机个数，请求个数，传输参数。数据保证 $1 \le n \le 2 \times {10}^5$，$1 \le Q \le 2 \times {10}^5$，$1 \le k \le 3$。

输入的第二行包含 $n$ 个正整数，第 $i$ 个正整数表示 $v_i$，保证 $1 \le v_i \le {10}^9$。

接下来 $n - 1$ 行，第 $i$ 行包含两个正整数 $a_i, b_i$，表示一条连接主机 $a_i, b_i$ 的网线。保证 $1 \le a_i, b_i \le n$。

接下来 $Q$ 行，第 $i$ 行包含两个正整数 $s_i, t_i$，表示一次从主机 $s_i$ 发送数据到主机 $t_i$ 的请求。保证 $1 \le s_i, t_i \le n$，$s_i \ne t_i$。
## 输出格式

$Q$ 行，每行一个正整数，表示第 $i$ 次请求在传输的时候至少需要花费多少单位的时间。
## 样例

### 样例输入 #1
```
7 3 3
1 2 3 4 5 6 7
1 2
1 3
2 4
2 5
3 6
3 7
4 7
5 6
1 2

```
### 样例输出 #1
```
12
12
3

```
## 提示

**【样例解释 \#1】**

对于第一组请求，由于主机 $4, 7$ 之间需要至少 $4$ 根网线才能连接，因此数据无法在两台主机之间直接传输，其至少需要一次转发；我们让其在主机 $1$ 进行一次转发，不难发现主机 $1$ 和主机 $4, 7$ 之间都只需要两根网线即可连接，且主机 $1$ 的数据处理时间仅为 $1$，为所有主机中最小，因此最少传输的时间为 $4 + 1 + 7 = 12$。

对于第三组请求，由于主机 $1, 2$ 之间只需要 $1$ 根网线就能连接，因此数据直接传输就是最优解，最少传输的时间为 $1 + 2 = 3$。

**【样例 \#2】**

见附件中的 `transmit/transmit2.in` 与 `transmit/transmit2.ans`。

该样例满足测试点 $2$ 的限制。

**【样例 \#3】**

见附件中的 `transmit/transmit3.in` 与 `transmit/transmit3.ans`。

该样例满足测试点 $3$ 的限制。

**【样例 \#4】**

见附件中的 `transmit/transmit4.in` 与 `transmit/transmit4.ans`。

该样例满足测试点 $20$ 的限制。

**【数据范围】**

对于所有的测试数据，满足 $1 \le n \le 2 \times {10}^5$，$1 \le Q \le 2 \times {10}^5$，$1 \le k \le 3$，$1 \le a_i, b_i \le n$，$1 \le s_i, t_i \le n$，$s_i \ne t_i$。

| 测试点 | $n \le$ | $Q \le$ | $k =$ | 特殊性质 |
|:-:|:-:|:-:|:-:|:-:|
| $1$ | $10$ | $10$ | $2$ | 是 |
| $2$ | $10$ | $10$ | $3$ | 是 |
| $3$ | $200$ | $200$ | $2$ | 是 |
| $4 \sim 5$ | $200$ | $200$ | $3$ | 是 |
| $6 \sim 7$ | $2000$ | $2000$ | $1$ | 否 |
| $8 \sim 9$ | $2000$ | $2000$ | $2$ | 否 |
| $10 \sim 11$ | $2000$ | $2000$ | $3$ | 否 |
| $12 \sim 13$ | $2 \times {10}^5$ | $2 \times {10}^5$ | $1$ | 否 |
| $14$ | $5 \times {10}^4$ | $5 \times {10}^4$ | $2$ | 是 |
| $15 \sim 16$ | ${10}^5$ | ${10}^5$ | $2$ | 是 |
| $17 \sim 19$ | $2 \times {10}^5$ | $2 \times {10}^5$ | $2$ | 否 |
| $20$ | $5 \times {10}^4$ | $5 \times {10}^4$ | $3$ | 是 |
| $21 \sim 22$ | ${10}^5$ | ${10}^5$ | $3$ | 是 |
| $23 \sim 25$ | $2 \times {10}^5$ | $2 \times {10}^5$ | $3$ | 否 |

特殊性质：保证 $a_i = i + 1$，而 $b_i$ 则从 $1, 2, \ldots, i$ 中等概率选取。


---

---
title: "[北大集训 2021] 经典游戏"
layout: "post"
diff: 省选/NOI-
pid: P8994
tag: ['树状数组', '2021', 'O2优化', '分治', '树链剖分', '字典树 Trie', 'SG 函数']
---
# [北大集训 2021] 经典游戏
## 题目背景

CTT2021 D4T2
## 题目描述

某天，`C` 和 `K` 觉得很无聊，于是决定玩一个经典小游戏：

在一棵有 $n$ 个结点的有根树上，标号为 $i$ 的节点上有 $a_i$ 个棋子。游戏时玩家轮流操作，每次可以将任意一个节点 $u$ 上的一个棋子放置到任意一个点 $v \in U(u)$上，其中 $U(u)=subtree\{u\}\setminus\{u\}$ ，表示 $u$ 的子树内（不包含 $u$ 本身）的点组成的集合。不能进行操作者失败。

而 `C` 和 `K` 作为 `P**` 和 `T**` 的在读学生，这种一眼就能找出必胜策略的游戏实在是索然无味，于是两人觉得，每个人给自己一个特殊能力可能会比较有趣：

`C` 在开始游戏之前，**可以选择**将当前树的树根 $R$ 换到与 $R$ 相邻的任意一个点 $R^{\prime}$ 上。定义两个点相邻当且仅当这两个点有边直接相连。

`K` 在开始游戏之前，**必须选择**树上的一个节点，在上面加上一颗棋子。

`C` 和 `K` 决定玩 $m$ 局游戏。每局游戏的流程如下：

1. 游戏开始前，`C` 和 `K` 会商量好，先在标号为 $x$ 的节点上放上一个棋子，然后将树根设为 $y$。
2. 之后 `C` 可以选择是否发动特殊能力，`C` 决策完之后 `K` 可以选择是否发动特殊能力。
3. 特殊能力的决策结束后，会在这棵树上进行一局 `C` 先手、`K` 后手的游戏。游戏完成后会将树上棋子的状态**还原到流程 `1` 结束后的状态**。

`C` 觉得这个游戏可以出成一个简单题，于是他决定考考你：`C` 在每局游戏的第二步的时候，有多少种决策方式使得不管 `K` 如何进行特殊能力的操作，开始游戏时都存在**必胜策略**？两种决策方式不同，**当且仅当**两种决策**更换的树根** $R^{\prime}$ **不同**，或者**两者中仅有一个没有发动特殊能力**。

## 输入格式

第一行包括一个整数，表示该测试点所在的子任务的分数。你可以使用这个信息判断该测试点满足的特殊性质。特别的，下发样例中此行使用 $0$ 代替。

第二行包含两个用空格隔开的正整数 $n, m$，表示树的节点数目以及游戏的轮数。树上的节点从 $1$ 到 $n$ 编号。

接下来 $n-1$ 行，每行包含两个用空格隔开的正整数 $u_i,v_i$，满足 $1 \le u_i,v_i \le n$，表示编号为 $u_i$ 和 $v_i$ 的节点之间有边直接相连。

接下来一行包含 $n$ 个用空格隔开的整数 $a_1,a_2,\ldots,a_n$，满足 $0 \leq a_1,a_2,\ldots,a_n \leq 10^9$。

接下来 $m$ 行，每行包含两个用空格隔开的正整数 $x, y$ 描述一局游戏，满足 $1 \le x,y \le n$。

## 输出格式


你需要输出 $m$ 行，其中第 $i$ 行应当包含一个非负整数 $x$ 表示第 $i$ 局游戏中，`C` 存在多少种使用特殊能力的决策方案，使得 `C` 在这局游戏中存在必胜策略。注意，**不使用特殊能力**也是一种**可能可行**的决策方案。

## 样例

### 样例输入 #1
```
0
5 2
1 2
1 3
2 4
2 5
1 0 1 0 1
2 2
4 4
```
### 样例输出 #1
```
2
1

```
### 样例输入 #2
```
0
10 10
6 3
7 4
8 2
2 1
9 1
1 3
3 4
4 5
5 10
0 0 1 1 1 0 1 1 0 0 
8 3
2 3
7 10
7 3
6 7
8 5
9 8
2 10
5 4
3 9

```
### 样例输出 #2
```
1
1
0
1
1
1
0
0
2
1

```
## 提示

| 子任务分数 | $1\le n,m\le$ | $\max\{a_1,a_2,\dots,a_n\}\le$ |              特殊性质              |
| :--------: | :-----------: | :----------------------------: | :--------------------------------: |
|    $16$    |      $5$      |              $1$               |                 无                 |
|    $15$    |     $300$     |              $1$               |                 无                 |
|    $14$    |    $5000$     |             $10^9$             |                 无                 |
|    $13$    |   $100000$    |             $10^9$             |        保证给出的树是一条链        |
|    $12$    |   $100000$    |             $10^9$             | 保证给出的树存在一个点度数为 $n-1$ |
|    $11$    |   $100000$    |             $10^9$             |   保证 $m$ 次游戏初始给定根一致    |
|    $10$    |   $500000$    |             $10^9$             |                 无                 |
|    $9$     |   $1000000$   |             $10^9$             |                 无                 |





---

---
title: "「DBOI」Round 1 人生如树"
layout: "post"
diff: 省选/NOI-
pid: P9399
tag: ['倍增', '二分', 'O2优化', '树链剖分', '树论', '哈希 hashing']
---
# 「DBOI」Round 1 人生如树
## 题目背景

> _永远这么酷 永远永远这么酷_\
_像个冒险家一样 不断探着山顶的路_\
——《Hustle》

张均好望着窗外，朱芝心走过来坐在他旁边，折了一架纸飞机飞出去。他对张均好说，要带着对未来的期待，往前走，别回头。

正如 [命运](https://www.luogu.com.cn/problem/P6773) 所述，每个人的人生都是一棵树。它总在无限的随机与缘分中伸展，有的枝丫茂盛了，有些却也不可避免地枯萎。
## 题目描述

朱芝心用魔法得到了张均好的人生树。

这是一棵 $n$ 个节点的树，节点 $i$ 上有权值 $w_i$。

朱芝心想要观测 $m$ 次张均好的人生：

设**当前**张均好人生树上的节点数量为 $s$。

1. 输入四个整数 $u_1,v_1,u_2,v_2$。令 $u_1\to v_1$ 的简单路径上**顺次组成**的数组为 $a$，$u_2\to v_2$ 的简单路径上**顺次组成**的数组为 $b$。朱芝心认为张均好这两段人生的相似度是 $LRP(a,b)$，希望你求出它。保证 $1\leq u_1,v_1,u_2,v_2 \leq s$。

2. 输入两个整数 $u,w'$。朱芝心观测到了张均好的另外一种可能，因此你需要新建一个点权为 $w'$ 的节点，编号为 $s+1$，建立一条 $(s+1,u)$ 的无向边，其中 $u\leq s$。显然，此后 $s\leftarrow s+1$。

对于两个数组 $a,b$，设它们的相似度 $LRP(a,b)$ 表示最大的 $i$ 满足 $i\leq \min\{|a|, |b|\}$ 且**对于所有** $1\leq j\leq i$，都有 $b_j=a_j+j$。其中 $|a|$ 表示数组 $a$ 的长度。特殊地，若不存在这样的 $i$，则 $LRP(a,b) = 0$。

## 输入格式

第一行三个正整数 $n,m,idx$，分别表示树的节点数量，操作数量和该测试点所在 Subtask 编号。对于样例，有 $idx = 0$。

接下来一行 $n$ 个整数，第 $i$ 个整数表示 $w_i$，即点 $i$ 上的权值。

接下来 $n - 1$ 行，每行两个正整数 $u_i,v_i$，表示有一条 $(u_i,v_i)$ 的无向边。

接下来 $m$ 行，每行一个操作。每行第一个整数是 $opt$，后面的若干整数表示操作的具体内容。$opt=1$ 时表示是操作 $1$，$opt=2$ 时表示是操作 $2$。
## 输出格式

对于每个操作 $1$，输出一行，表示当前询问的 $LRP(a, b)$。
## 样例

### 样例输入 #1
```
9 3 0
7 3 2 4 6 5 5 3 7
1 2
2 3
2 4
4 5
4 6
1 7
7 8
7 9
2 9 10
1 3 5 8 10
1 3 6 8 10
```
### 样例输出 #1
```
4
3
```
### 样例输入 #2
```
13 5 0
15 12 9 11 5 6 16 14 15 10 12 1 2
7 8
5 6
2 9
1 2
4 5
8 2
9 10
2 3
10 11
3 4
3 13
3 12
1 1 6 7 11
1 12 12 13 13
2 1 10
2 2 11
1 14 14 15 15
```
### 样例输出 #2
```
6
1
1
```
## 提示

### 样例解释

对于样例一，第一个操作结束后，$w_{10}=10$，树如图所示：

![](https://s1.ax1x.com/2023/04/26/p9MV9pV.png)

- 对于第二个操作，第一条路径为 $3\to 2\to 4\to 5$，故 $a=\{2, 3, 4, 6\}$，第二条路径为 $8\to 7\to 9\to 10$，故 $b=\{3, 5, 7, 10\}$，由于 $3=2+1$，$5=3+2$，$7=4+3$，$10=6+4$，所以答案为 $4$；
- 对于第三个操作，$a=\{2, 3, 4, 5\}$，$b=\{3, 5, 7, 10\}$，由于 $3=2+1$，$5=3+2$，$7=4+3$，$10\ne 5+4$，所以答案为 $3$。

对于样例二，初始的树如图所示：

![](https://s1.ax1x.com/2023/04/26/p9MVZkR.png)


| Subtask | $n \le$ | $m \le$ | 特殊性质 | 分值 |
| :-----------: | :-----------: | :-----------: | :-----------: | :-----------: |
| Subtask 1 | $5000$ | $5000$ | 无 | $10$ |
| Subtask 2 | $10^5$ | $5\times{10}^4$ | A & B | $30$ |
| Subtask 3 | $10^5$ | $5\times{10}^4$ | B | $30$ |
| Subtask 4 | $10^5$ | $5 \times {10}^4$ | 无 | $20$ | 
| Subtask 5 | $10^5$ | $10^5$ | 无 | $10$ |

特殊性质 A：$v_i=u_i+1$。

特殊性质 B：保证无操作 2。

对于 $100\%$ 的数据，$1\leq n,m\leq 10^5$，$1\leq w_i,w'\leq 10^6$，$1\leq u_i,v_i\leq n$。  



---

